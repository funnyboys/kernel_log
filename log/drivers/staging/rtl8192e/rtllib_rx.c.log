commit 39ddadf14da77c5c7176e0395db5f832b7da06c0
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Mar 11 10:24:50 2020 +0100

    staging: rtl8192e: Use scnprintf() for avoiding potential buffer overflow
    
    Since snprintf() returns the would-be-output size instead of the
    actual output size, the succeeding calls may go beyond the given
    buffer limit.  Fix it by replacing with scnprintf().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Link: https://lore.kernel.org/r/20200311092451.23933-3-tiwai@suse.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index 0bae0a0a4cbe..d31b5e1c8df4 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -2092,7 +2092,7 @@ int rtllib_parse_info_param(struct rtllib_device *ieee,
 						 MAX_RATES_LENGTH);
 			for (i = 0; i < network->rates_len; i++) {
 				network->rates[i] = info_element->data[i];
-				p += snprintf(p, sizeof(rates_str) -
+				p += scnprintf(p, sizeof(rates_str) -
 					      (p - rates_str), "%02X ",
 					      network->rates[i]);
 				if (rtllib_is_ofdm_rate
@@ -2120,7 +2120,7 @@ int rtllib_parse_info_param(struct rtllib_device *ieee,
 						    MAX_RATES_EX_LENGTH);
 			for (i = 0; i < network->rates_ex_len; i++) {
 				network->rates_ex[i] = info_element->data[i];
-				p += snprintf(p, sizeof(rates_str) -
+				p += scnprintf(p, sizeof(rates_str) -
 					      (p - rates_str), "%02X ",
 					      network->rates_ex[i]);
 				if (rtllib_is_ofdm_rate

commit 756e4624ddcfdc2792fe389262ba7447f22d8913
Author: YueHaibing <yuehaibing@huawei.com>
Date:   Wed Jul 17 22:35:51 2019 +0800

    staging: rtl8192e: remove set but not used variable 'payload '
    
    Fixes gcc '-Wunused-but-set-variable' warning:
    
    drivers/staging/rtl8192e/rtllib_rx.c: In function rtllib_rx_InfraAdhoc:
    drivers/staging/rtl8192e/rtllib_rx.c:1303:6: warning:
     variable payload set but not used [-Wunused-but-set-variable]
    
    Reported-by: Hulk Robot <hulkci@huawei.com>
    Signed-off-by: YueHaibing <yuehaibing@huawei.com>
    Link: https://lore.kernel.org/r/20190717143551.29200-1-yuehaibing@huawei.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index 0c19ac2bc3bf..0bae0a0a4cbe 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -1300,7 +1300,6 @@ static int rtllib_rx_InfraAdhoc(struct rtllib_device *ieee, struct sk_buff *skb,
 	struct rx_ts_record *pTS = NULL;
 	u16 fc, sc, SeqNum = 0;
 	u8 type, stype, multicast = 0, unicast = 0, nr_subframes = 0, TID = 0;
-	u8 *payload;
 	u8 dst[ETH_ALEN];
 	u8 src[ETH_ALEN];
 	u8 bssid[ETH_ALEN] = {0};
@@ -1412,7 +1411,6 @@ static int rtllib_rx_InfraAdhoc(struct rtllib_device *ieee, struct sk_buff *skb,
 
 	/* Parse rx data frame (For AMSDU) */
 	/* skb: hdr + (possible reassembled) full plaintext payload */
-	payload = skb->data + hdrlen;
 	rxb = kmalloc(sizeof(struct rtllib_rxb), GFP_ATOMIC);
 	if (!rxb)
 		goto rx_dropped;

commit 18056f34c3b755f027a0923b0bb9d50a2e339caa
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Apr 2 12:31:58 2019 +0200

    staging: rtl8192e: add proper SPDX identifiers on files that did not have them.
    
    There were a few files for the rtl8192e driver that did not have SPDX
    identifiers on them, so fix that up.  At the same time, remove the "free
    form" text that specified the license of the file, as that is impossible
    for any tool to properly parse.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index debc2e40af00..0c19ac2bc3bf 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Original code based Host AP (software wireless LAN access point) driver
  * for Intersil Prism2/2.5/3 - hostap.o module, common routines
@@ -7,20 +8,11 @@
  * Copyright (c) 2002-2003, Jouni Malinen <jkmaline@cc.hut.fi>
  * Copyright (c) 2004, Intel Corporation
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation. See README and COPYING for
- * more details.
- ******************************************************************************
-
-  Few modifications for Realtek's Wi-Fi drivers by
-  Andrea Merello <andrea.merello@gmail.com>
-
-  A special thanks goes to Realtek for their support !
-
-******************************************************************************/
-
-
+ * Few modifications for Realtek's Wi-Fi drivers by
+ * Andrea Merello <andrea.merello@gmail.com>
+ *
+ * A special thanks goes to Realtek for their support !
+ */
 #include <linux/compiler.h>
 #include <linux/errno.h>
 #include <linux/if_arp.h>

commit 43defd93289fac1c136397f5b27076b908777a9c
Author: Himadri Pandya <himadri18.07@gmail.com>
Date:   Sun Feb 10 14:13:15 2019 +0530

    staging: rtl8192e: rename function Dot11d_UpdateCountryIe to dot11d_update_country - style
    
    Rename function Dot11d_UpdateCountryIe to dot11d_update_country to fix
    checkpatch warning: Avoid CamelCase.
    
    Signed-off-by: Himadri Pandya <himadri18.07@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index 501ded929329..debc2e40af00 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -1812,7 +1812,7 @@ static inline void rtllib_extract_country_ie(
 					netdev_info(ieee->dev,
 						    "Received beacon ContryIE, SSID: <%s>\n",
 						    network->ssid);
-				Dot11d_UpdateCountryIe(ieee, addr2,
+				dot11d_update_country(ieee, addr2,
 						       info_element->len,
 						       info_element->data);
 			}

commit e4441911d9694a177be30eb77adf54d511ae192f
Author: Colin Ian King <colin.king@canonical.com>
Date:   Mon Jan 7 23:22:49 2019 +0000

    staging: rtl8192e: fix various indentation issues
    
    There are several statements that have indentation issues, fix these.
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index fa580ce1cf43..501ded929329 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -913,7 +913,7 @@ static size_t rtllib_rx_get_hdrlen(struct rtllib_device *ieee,
 		rx_stats->bContainHTC = true;
 	}
 
-	 if (RTLLIB_QOS_HAS_SEQ(fc))
+	if (RTLLIB_QOS_HAS_SEQ(fc))
 		rx_stats->bIsQosData = true;
 
 	return hdrlen;

commit 1b873bd4ead85b9f89a673b9d83ce7fa0d555e4b
Author: Santha Meena Ramamoorthy <santhameena13@gmail.com>
Date:   Wed Feb 28 12:40:48 2018 -0800

    staging: rtl8192e: move logical continuation to previous line
    
    Move logical continuation '&&' to the previous line to conform to the
    Linux kernel coding style. Issue found using checkpatch.
    
    Signed-off-by: Santha Meena Ramamoorthy <santhameena13@gmail.com>
    Acked-by: Julia Lawall <julia.lawall@lip6.fr>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index 30f72d220af1..fa580ce1cf43 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -2644,8 +2644,8 @@ static inline void rtllib_process_probe_response(
 	   (network->ssid_len ? 1 : 0))) {
 		update_network(ieee, &ieee->current_network, network);
 		if ((ieee->current_network.mode == IEEE_N_24G ||
-		     ieee->current_network.mode == IEEE_G)
-		     && ieee->current_network.berp_info_valid) {
+		     ieee->current_network.mode == IEEE_G) &&
+		    ieee->current_network.berp_info_valid) {
 			if (ieee->current_network.erp_value & ERP_UseProtection)
 				ieee->current_network.buseprotection = true;
 			else

commit 783778e38e4adf9d3e1691151c0f408e8cae514a
Author: Colin Ian King <colin.king@canonical.com>
Date:   Sat Jan 20 22:21:40 2018 +0000

    staging: rtl8192e: remove two redundant assignments
    
    Clang detected two redundant assignments that can be safely removed.
    The first is the removal of the duplicated assignment to pointer 'hdr',
    this has already been initialized with the same value.  The second is
    the removal of the redundant initialization of variable 'timeout', this
    assigned value is never read and the variable is reassigned a new value
    a little later.
    
    Remove both redundant assignments, cleans up clang warnings:
    drivers/staging/rtl8192e/rtllib_rx.c:1305:27: warning: Value stored to
    'hdr' during its initialization is never read
    drivers/staging/rtl8192e/rtllib_softmac.c:1971:6: warning: Value stored
    to 'timeout' during its initialization is never read
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index 7bc9cb131bcc..30f72d220af1 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -1317,7 +1317,6 @@ static int rtllib_rx_InfraAdhoc(struct rtllib_device *ieee, struct sk_buff *skb,
 	bool bToOtherSTA = false;
 	int ret = 0, i = 0;
 
-	hdr = (struct rtllib_hdr_4addr *)skb->data;
 	fc = le16_to_cpu(hdr->frame_ctl);
 	type = WLAN_FC_GET_TYPE(fc);
 	stype = WLAN_FC_GET_STYPE(fc);

commit 5518b69b76680a4f2df96b1deca260059db0c2de
Merge: 8ad06e56dcbc 0e72582270c0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jul 5 12:31:59 2017 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net-next
    
    Pull networking updates from David Miller:
     "Reasonably busy this cycle, but perhaps not as busy as in the 4.12
      merge window:
    
       1) Several optimizations for UDP processing under high load from
          Paolo Abeni.
    
       2) Support pacing internally in TCP when using the sch_fq packet
          scheduler for this is not practical. From Eric Dumazet.
    
       3) Support mutliple filter chains per qdisc, from Jiri Pirko.
    
       4) Move to 1ms TCP timestamp clock, from Eric Dumazet.
    
       5) Add batch dequeueing to vhost_net, from Jason Wang.
    
       6) Flesh out more completely SCTP checksum offload support, from
          Davide Caratti.
    
       7) More plumbing of extended netlink ACKs, from David Ahern, Pablo
          Neira Ayuso, and Matthias Schiffer.
    
       8) Add devlink support to nfp driver, from Simon Horman.
    
       9) Add RTM_F_FIB_MATCH flag to RTM_GETROUTE queries, from Roopa
          Prabhu.
    
      10) Add stack depth tracking to BPF verifier and use this information
          in the various eBPF JITs. From Alexei Starovoitov.
    
      11) Support XDP on qed device VFs, from Yuval Mintz.
    
      12) Introduce BPF PROG ID for better introspection of installed BPF
          programs. From Martin KaFai Lau.
    
      13) Add bpf_set_hash helper for TC bpf programs, from Daniel Borkmann.
    
      14) For loads, allow narrower accesses in bpf verifier checking, from
          Yonghong Song.
    
      15) Support MIPS in the BPF selftests and samples infrastructure, the
          MIPS eBPF JIT will be merged in via the MIPS GIT tree. From David
          Daney.
    
      16) Support kernel based TLS, from Dave Watson and others.
    
      17) Remove completely DST garbage collection, from Wei Wang.
    
      18) Allow installing TCP MD5 rules using prefixes, from Ivan
          Delalande.
    
      19) Add XDP support to Intel i40e driver, from Björn Töpel
    
      20) Add support for TC flower offload in nfp driver, from Simon
          Horman, Pieter Jansen van Vuuren, Benjamin LaHaise, Jakub
          Kicinski, and Bert van Leeuwen.
    
      21) IPSEC offloading support in mlx5, from Ilan Tayari.
    
      22) Add HW PTP support to macb driver, from Rafal Ozieblo.
    
      23) Networking refcount_t conversions, From Elena Reshetova.
    
      24) Add sock_ops support to BPF, from Lawrence Brako. This is useful
          for tuning the TCP sockopt settings of a group of applications,
          currently via CGROUPs"
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/davem/net-next: (1899 commits)
      net: phy: dp83867: add workaround for incorrect RX_CTRL pin strap
      dt-bindings: phy: dp83867: provide a workaround for incorrect RX_CTRL pin strap
      cxgb4: Support for get_ts_info ethtool method
      cxgb4: Add PTP Hardware Clock (PHC) support
      cxgb4: time stamping interface for PTP
      nfp: default to chained metadata prepend format
      nfp: remove legacy MAC address lookup
      nfp: improve order of interfaces in breakout mode
      net: macb: remove extraneous return when MACB_EXT_DESC is defined
      bpf: add missing break in for the TCP_BPF_SNDCWND_CLAMP case
      bpf: fix return in load_bpf_file
      mpls: fix rtm policy in mpls_getroute
      net, ax25: convert ax25_cb.refcount from atomic_t to refcount_t
      net, ax25: convert ax25_route.refcount from atomic_t to refcount_t
      net, ax25: convert ax25_uid_assoc.refcount from atomic_t to refcount_t
      net, sctp: convert sctp_ep_common.refcnt from atomic_t to refcount_t
      net, sctp: convert sctp_transport.refcnt from atomic_t to refcount_t
      net, sctp: convert sctp_chunk.refcnt from atomic_t to refcount_t
      net, sctp: convert sctp_datamsg.refcnt from atomic_t to refcount_t
      net, sctp: convert sctp_auth_bytes.refcnt from atomic_t to refcount_t
      ...

commit b952f4dff2751252db073c27c0f8a16a416a2ddc
Author: yuan linyu <Linyu.Yuan@alcatel-sbell.com.cn>
Date:   Sun Jun 18 22:52:04 2017 +0800

    net: manual clean code which call skb_put_[data:zero]
    
    Signed-off-by: yuan linyu <Linyu.Yuan@alcatel-sbell.com.cn>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index bae98ca0a9b6..03a81ba136b2 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -782,7 +782,6 @@ static u8 parse_subframe(struct rtllib_device *ieee, struct sk_buff *skb,
 	u8		nPadding_Length = 0;
 	u16		SeqNum = 0;
 	struct sk_buff *sub_skb;
-	u8	     *data_ptr;
 	/* just for debug purpose */
 	SeqNum = WLAN_GET_SEQ_SEQ(le16_to_cpu(hdr->seq_ctl));
 	if ((RTLLIB_QOS_HAS_SEQ(fc)) &&
@@ -817,7 +816,7 @@ static u8 parse_subframe(struct rtllib_device *ieee, struct sk_buff *skb,
 		if (!sub_skb)
 			return 0;
 		skb_reserve(sub_skb, 12);
-		data_ptr = skb_put_data(sub_skb, skb->data, skb->len);
+		skb_put_data(sub_skb, skb->data, skb->len);
 		sub_skb->dev = ieee->dev;
 
 		rxb->subframes[0] = sub_skb;
@@ -869,7 +868,7 @@ static u8 parse_subframe(struct rtllib_device *ieee, struct sk_buff *skb,
 		if (!sub_skb)
 			return 0;
 		skb_reserve(sub_skb, 12);
-		data_ptr = skb_put_data(sub_skb, skb->data, nSubframe_Length);
+		skb_put_data(sub_skb, skb->data, nSubframe_Length);
 
 		sub_skb->dev = ieee->dev;
 		rxb->subframes[rxb->nr_subframes++] = sub_skb;

commit 59ae1d127ac0ae404baf414c434ba2651b793f46
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Fri Jun 16 14:29:20 2017 +0200

    networking: introduce and use skb_put_data()
    
    A common pattern with skb_put() is to just want to memcpy()
    some data into the new space, introduce skb_put_data() for
    this.
    
    An spatch similar to the one for skb_put_zero() converts many
    of the places using it:
    
        @@
        identifier p, p2;
        expression len, skb, data;
        type t, t2;
        @@
        (
        -p = skb_put(skb, len);
        +p = skb_put_data(skb, data, len);
        |
        -p = (t)skb_put(skb, len);
        +p = skb_put_data(skb, data, len);
        )
        (
        p2 = (t2)p;
        -memcpy(p2, data, len);
        |
        -memcpy(p, data, len);
        )
    
        @@
        type t, t2;
        identifier p, p2;
        expression skb, data;
        @@
        t *p;
        ...
        (
        -p = skb_put(skb, sizeof(t));
        +p = skb_put_data(skb, data, sizeof(t));
        |
        -p = (t *)skb_put(skb, sizeof(t));
        +p = skb_put_data(skb, data, sizeof(t));
        )
        (
        p2 = (t2)p;
        -memcpy(p2, data, sizeof(*p));
        |
        -memcpy(p, data, sizeof(*p));
        )
    
        @@
        expression skb, len, data;
        @@
        -memcpy(skb_put(skb, len), data, len);
        +skb_put_data(skb, data, len);
    
    (again, manually post-processed to retain some comments)
    
    Reviewed-by: Stephen Hemminger <stephen@networkplumber.org>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index 43a77745e6fb..bae98ca0a9b6 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -817,8 +817,7 @@ static u8 parse_subframe(struct rtllib_device *ieee, struct sk_buff *skb,
 		if (!sub_skb)
 			return 0;
 		skb_reserve(sub_skb, 12);
-		data_ptr = (u8 *)skb_put(sub_skb, skb->len);
-		memcpy(data_ptr, skb->data, skb->len);
+		data_ptr = skb_put_data(sub_skb, skb->data, skb->len);
 		sub_skb->dev = ieee->dev;
 
 		rxb->subframes[0] = sub_skb;
@@ -870,8 +869,7 @@ static u8 parse_subframe(struct rtllib_device *ieee, struct sk_buff *skb,
 		if (!sub_skb)
 			return 0;
 		skb_reserve(sub_skb, 12);
-		data_ptr = (u8 *)skb_put(sub_skb, nSubframe_Length);
-		memcpy(data_ptr, skb->data, nSubframe_Length);
+		data_ptr = skb_put_data(sub_skb, skb->data, nSubframe_Length);
 
 		sub_skb->dev = ieee->dev;
 		rxb->subframes[rxb->nr_subframes++] = sub_skb;
@@ -1141,13 +1139,12 @@ static int rtllib_rx_decrypt(struct rtllib_device *ieee, struct sk_buff *skb,
 			/* copy first fragment (including full headers) into
 			 * beginning of the fragment cache skb
 			 */
-			memcpy(skb_put(frag_skb, flen), skb->data, flen);
+			skb_put_data(frag_skb, skb->data, flen);
 		} else {
 			/* append frame payload to the end of the fragment
 			 * cache skb
 			 */
-			memcpy(skb_put(frag_skb, flen), skb->data + hdrlen,
-			       flen);
+			skb_put_data(frag_skb, skb->data + hdrlen, flen);
 		}
 		dev_kfree_skb_any(skb);
 		skb = NULL;

commit 8f931dcd0c6919f7035d31773e8cd56f8ac6412b
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sat May 13 17:41:17 2017 +0100

    staging: rtl8192e: Remove RX: IEEE802.1X EAPOL frame! warning.
    
    RX will receive countless EAPOL frames over the life of the connection.
    
    A number of conditional calls to rtllib_is_eapol_frame are made in this function.
    
    So this call serves no purpose other than to spam logs with false warning that
    it is indeed a EAPOL frame, remove it.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index 43a77745e6fb..0033dc6979e7 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -1214,9 +1214,6 @@ static int rtllib_rx_decrypt(struct rtllib_device *ieee, struct sk_buff *skb,
 		return -1;
 	}
 
-	if (rtllib_is_eapol_frame(ieee, skb, hdrlen))
-		netdev_warn(ieee->dev, "RX: IEEE802.1X EAPOL frame!\n");
-
 	return 0;
 }
 

commit 4a7c972644c1151f6dd34ff4b5f7eacb239e22ee
Author: Tobias Klauser <tklauser@distanz.ch>
Date:   Wed Jan 18 17:45:01 2017 +0100

    net: Remove usage of net_device last_rx member
    
    The network stack no longer uses the last_rx member of struct net_device
    since the bonding driver switched to use its own private last_rx in
    commit 9f242738376d ("bonding: use last_arp_rx in slave_last_rx()").
    
    However, some drivers still (ab)use the field for their own purposes and
    some driver just update it without actually using it.
    
    Previously, there was an accompanying comment for the last_rx member
    added in commit 4dc89133f49b ("net: add a comment on netdev->last_rx")
    which asked drivers not to update is, unless really needed. However,
    this commend was removed in commit f8ff080dacec ("bonding: remove
    useless updating of slave->dev->last_rx"), so some drivers added later
    on still did update last_rx.
    
    Remove all usage of last_rx and switch three drivers (sky2, atp and
    smc91c92_cs) which actually read and write it to use their own private
    copy in netdev_priv.
    
    Compile-tested with allyesconfig and allmodconfig on x86 and arm.
    
    Cc: Eric Dumazet <eric.dumazet@gmail.com>
    Cc: Jay Vosburgh <j.vosburgh@gmail.com>
    Cc: Veaceslav Falico <vfalico@gmail.com>
    Cc: Andy Gospodarek <andy@greyhouse.net>
    Cc: Mirko Lindner <mlindner@marvell.com>
    Cc: Stephen Hemminger <stephen@networkplumber.org>
    Signed-off-by: Tobias Klauser <tklauser@distanz.ch>
    Acked-by: Eric Dumazet <edumazet@google.com>
    Reviewed-by: Jay Vosburgh <jay.vosburgh@canonical.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index e5ba7d1a809f..43a77745e6fb 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -1375,7 +1375,6 @@ static int rtllib_rx_InfraAdhoc(struct rtllib_device *ieee, struct sk_buff *skb,
 		ieee->LinkDetectInfo.NumRecvDataInPeriod++;
 		ieee->LinkDetectInfo.NumRxOkInPeriod++;
 	}
-	dev->last_rx = jiffies;
 
 	/* Data frame - extract src/dst addresses */
 	rtllib_rx_extract_addr(ieee, hdr, dst, src, bssid);

commit 29f22246477e4a754a198eb842271c83bda7a93c
Author: Yamanappagouda Patil <goudapatilk@gmail.com>
Date:   Tue Nov 15 14:10:47 2016 +0530

    staging: rtl8192e: Added new line after declaration
    
    Fixed checkpatch.pl "Missing a blank line after declarations" warnings.
    
    Signed-off-by: Yamanappagouda Patil <goudapatilk@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index d67e3f3db76d..e5ba7d1a809f 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -1201,6 +1201,7 @@ static int rtllib_rx_decrypt(struct rtllib_device *ieee, struct sk_buff *skb,
 	if (crypt && !(fc & RTLLIB_FCTL_WEP) &&
 	    rtllib_is_eapol_frame(ieee, skb, hdrlen)) {
 		struct eapol *eap = (struct eapol *)(skb->data + 24);
+
 		netdev_dbg(ieee->dev, "RX: IEEE 802.1X EAPOL frame: %s\n",
 			   eap_get_type(eap->type));
 	}

commit 15ed5398c94c8e29ee11022926351cb77cf70e7f
Author: Elise Lennion <elise.lennion@gmail.com>
Date:   Fri Oct 28 22:29:21 2016 -0200

    staging: rtl8192e: Standardize test for NULL.
    
    The test for NULL of the return variable of functions was changed from
    (ret == NULL) to !ret to match the standard.
    
    Coccinelle was used with semantic patch:
    @@
    expression e;
    identifier id, f;
    statement S;
    @@
    
    f(...) { <+...
    
    id =
    \(kmalloc\|devm_kzalloc\|kmalloc_array\|devm_ioremap
    \|usb_alloc_urb\|alloc_netdev\|dev_alloc_skb\) (...)
    
    ... when any
        when != id = e
    
    + if (!id)
    - if (\(NULL == id\|id == NULL\))
    S
    
    ...+> }
    
    Signed-off-by: Elise Lennion <elise.lennion@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index d6777ecda64d..d67e3f3db76d 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -130,7 +130,7 @@ rtllib_frag_cache_get(struct rtllib_device *ieee,
 				    ETH_ALEN /* WDS */ +
 				    /* QOS Control */
 				    (RTLLIB_QOS_HAS_SEQ(fc) ? 2 : 0));
-		if (skb == NULL)
+		if (!skb)
 			return NULL;
 
 		entry = &ieee->frag_cache[tid][ieee->frag_next_idx[tid]];
@@ -1430,7 +1430,7 @@ static int rtllib_rx_InfraAdhoc(struct rtllib_device *ieee, struct sk_buff *skb,
 	/* skb: hdr + (possible reassembled) full plaintext payload */
 	payload = skb->data + hdrlen;
 	rxb = kmalloc(sizeof(struct rtllib_rxb), GFP_ATOMIC);
-	if (rxb == NULL)
+	if (!rxb)
 		goto rx_dropped;
 
 	/* to parse amsdu packets */

commit 5d43dfdba0e377c22fdd69e5d7b3e361c77348bb
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Oct 24 17:38:34 2016 +0200

    staging: rtl8192x: fix bogus maybe-uninitialized warning
    
    The rtllib_rx_extract_addr() is supposed to set up the mac addresses
    for four possible cases, based on two bits of input data. For
    some reason, gcc decides that it's possible that none of the these
    four cases apply and the addresses remain uninitialized:
    
    drivers/staging/rtl8192e/rtllib_rx.c: In function ‘rtllib_rx_InfraAdhoc’:
    include/linux/etherdevice.h:316:61: error: ‘*((void *)&dst+4)’ may be used uninitialized in this function [-Werror=maybe-uninitialized]
    drivers/staging/rtl8192e/rtllib_rx.c:1318:5: note: ‘*((void *)&dst+4)’ was declared here
    ded from /git/arm-soc/drivers/staging/rtl8192e/rtllib_rx.c:40:0:
    include/linux/etherdevice.h:316:36: error: ‘dst’ may be used uninitialized in this function [-Werror=maybe-uninitialized]
    drivers/staging/rtl8192e/rtllib_rx.c:1318:5: note: ‘dst’ was declared here
    
    This warning is clearly nonsense, but changing the last case into
    'default' makes it obvious to the compiler too, which avoids the
    warning and probably leads to better object code too.
    
    As the same warning appears in other files that have the exact
    same code, I'm fixing it in both rtl8192e and rtl8192u, even
    though I did not observe it for the latter.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index c743182b933e..d6777ecda64d 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -986,7 +986,7 @@ static void rtllib_rx_extract_addr(struct rtllib_device *ieee,
 		ether_addr_copy(src, hdr->addr4);
 		ether_addr_copy(bssid, ieee->current_network.bssid);
 		break;
-	case 0:
+	default:
 		ether_addr_copy(dst, hdr->addr1);
 		ether_addr_copy(src, hdr->addr2);
 		ether_addr_copy(bssid, hdr->addr3);

commit 138bdc6de21c8b48d1e048c8a902ee722350c226
Author: Tapan Prakash T <tapanprakasht@gmail.com>
Date:   Wed Feb 24 23:06:12 2016 +0530

    drivers: staging: rtl8192e: rtllib_rx.c: Fix blank lines before a close brace
    
    Fixed checkpatch.pl issue 'Blank lines aren't necessary before a close
    brace'
    
    Signed-off-by: Tapan Prakash T <tapanprakasht@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index cac519035588..c743182b933e 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -1829,7 +1829,6 @@ static inline void rtllib_extract_country_ie(
 		if (IS_EQUAL_CIE_SRC(ieee, addr2))
 			UPDATE_CIE_WATCHDOG(ieee);
 	}
-
 }
 
 static void rtllib_parse_mife_generic(struct rtllib_device *ieee,
@@ -1902,7 +1901,6 @@ static void rtllib_parse_mife_generic(struct rtllib_device *ieee,
 				       info_element->data,
 				       network->bssht.bdHTInfoLen);
 			}
-
 		}
 	}
 

commit 3d15286201b3d0c28777a0cb1a9e965ffad9d3bd
Author: Tapan Prakash T <tapanprakasht@gmail.com>
Date:   Wed Feb 24 22:47:47 2016 +0530

    drivers: staging: rtl8192e: rtllib_rx.c: Fix code indent for conditional statement
    
    Fixed checkpatch.pl warning 'suspect code indent for conditional
    statements'
    
    Signed-off-by: Tapan Prakash T <tapanprakasht@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index af64bd3b1c53..cac519035588 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -467,7 +467,7 @@ static bool AddReorderEntry(struct rx_ts_record *pTS,
 		else if (SN_EQUAL(pReorderEntry->SeqNum,
 			((struct rx_reorder_entry *)list_entry(pList->next,
 			struct rx_reorder_entry, List))->SeqNum))
-				return false;
+			return false;
 		else
 			break;
 	}

commit 7949be663f7d3693cde96bb65fc3cb3b981c5700
Author: Bhaktipriya Shridhar <bhaktipriya96@gmail.com>
Date:   Fri Feb 19 03:13:56 2016 +0530

    staging: rtl8192e: Drop useless initialisation
    
    Removed initialisation of a varible if it is immediately reassigned.
    
    Changes were made using Coccinelle.
    
    @@
    type T;
    constant C;
    expression e;
    identifier i;
    @@
    T i
    - = C
    ;
    i = e;
    
    Signed-off-by: Bhaktipriya Shridhar <bhaktipriya96@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index 37343ec3b484..af64bd3b1c53 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -905,7 +905,7 @@ static size_t rtllib_rx_get_hdrlen(struct rtllib_device *ieee,
 {
 	struct rtllib_hdr_4addr *hdr = (struct rtllib_hdr_4addr *)skb->data;
 	u16 fc = le16_to_cpu(hdr->frame_ctl);
-	size_t hdrlen = 0;
+	size_t hdrlen;
 
 	hdrlen = rtllib_get_hdrlen(fc);
 	if (HTCCheck(ieee, skb->data)) {

commit 4c29207a96885b82175979c723a63de05d5fb2f9
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Sun Sep 20 21:04:27 2015 +0200

    staging: rtl8192e: Fix CONSTANT_COMPARISON warnings
    
    Remove yoda conditions where pointed by checkpatch.
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index 2d56a2e038d7..37343ec3b484 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -1530,7 +1530,7 @@ int rtllib_rx(struct rtllib_device *ieee, struct sk_buff *skb,
 {
 	int ret = 0;
 
-	if ((NULL == ieee) || (NULL == skb) || (NULL == rx_stats)) {
+	if (!ieee || !skb || !rx_stats) {
 		pr_info("%s: Input parameters NULL!\n", __func__);
 		goto rx_dropped;
 	}
@@ -2554,7 +2554,7 @@ static inline int is_beacon(u16 fc)
 
 static int IsPassiveChannel(struct rtllib_device *rtllib, u8 channel)
 {
-	if (MAX_CHANNEL_NUMBER < channel) {
+	if (channel > MAX_CHANNEL_NUMBER) {
 		netdev_info(rtllib->dev, "%s(): Invalid Channel\n", __func__);
 		return 0;
 	}
@@ -2567,7 +2567,7 @@ static int IsPassiveChannel(struct rtllib_device *rtllib, u8 channel)
 
 int rtllib_legal_channel(struct rtllib_device *rtllib, u8 channel)
 {
-	if (MAX_CHANNEL_NUMBER < channel) {
+	if (channel > MAX_CHANNEL_NUMBER) {
 		netdev_info(rtllib->dev, "%s(): Invalid Channel\n", __func__);
 		return 0;
 	}

commit fc00af0cd0313f1446cf4ff9d536a2db216f8fb7
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Sun Sep 20 21:04:26 2015 +0200

    staging: rtl8192e: Fix SUSPECT_CODE_INDENT warnings
    
    Fix SUSPECT_CODE_INDENT warnings (indentation).
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index 09f0820fb340..2d56a2e038d7 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -1200,11 +1200,9 @@ static int rtllib_rx_decrypt(struct rtllib_device *ieee, struct sk_buff *skb,
 
 	if (crypt && !(fc & RTLLIB_FCTL_WEP) &&
 	    rtllib_is_eapol_frame(ieee, skb, hdrlen)) {
-			struct eapol *eap = (struct eapol *)(skb->data +
-				24);
-			netdev_dbg(ieee->dev,
-				   "RX: IEEE 802.1X EAPOL frame: %s\n",
-				   eap_get_type(eap->type));
+		struct eapol *eap = (struct eapol *)(skb->data + 24);
+		netdev_dbg(ieee->dev, "RX: IEEE 802.1X EAPOL frame: %s\n",
+			   eap_get_type(eap->type));
 	}
 
 	if (crypt && !(fc & RTLLIB_FCTL_WEP) && !ieee->open_wep &&

commit 5143f7a3e970a1d0b6659cf41a3b46dd48a9bc6f
Author: Ioan-Adrian Ratiu <adi@adirat.com>
Date:   Thu Jul 23 16:24:10 2015 +0300

    staging: rtl8192e: rtllib: fix macro style issue
    
    Remove macro and use explicit case statements. Code is a little
    longer but clearer. Checkpatch.pl does not complain anymore.
    
    Signed-off-by: Ioan-Adrian Ratiu <adi@adirat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index 54dfff61f485..09f0820fb340 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -1744,37 +1744,61 @@ static int rtllib_parse_qos_info_param_IE(struct rtllib_device *ieee,
 	return rc;
 }
 
-#define MFIE_STRING(x) case MFIE_TYPE_ ##x: return #x
-
 static const char *get_info_element_string(u16 id)
 {
 	switch (id) {
-	MFIE_STRING(SSID);
-	MFIE_STRING(RATES);
-	MFIE_STRING(FH_SET);
-	MFIE_STRING(DS_SET);
-	MFIE_STRING(CF_SET);
-	MFIE_STRING(TIM);
-	MFIE_STRING(IBSS_SET);
-	MFIE_STRING(COUNTRY);
-	MFIE_STRING(HOP_PARAMS);
-	MFIE_STRING(HOP_TABLE);
-	MFIE_STRING(REQUEST);
-	MFIE_STRING(CHALLENGE);
-	MFIE_STRING(POWER_CONSTRAINT);
-	MFIE_STRING(POWER_CAPABILITY);
-	MFIE_STRING(TPC_REQUEST);
-	MFIE_STRING(TPC_REPORT);
-	MFIE_STRING(SUPP_CHANNELS);
-	MFIE_STRING(CSA);
-	MFIE_STRING(MEASURE_REQUEST);
-	MFIE_STRING(MEASURE_REPORT);
-	MFIE_STRING(QUIET);
-	MFIE_STRING(IBSS_DFS);
-	MFIE_STRING(RSN);
-	MFIE_STRING(RATES_EX);
-	MFIE_STRING(GENERIC);
-	MFIE_STRING(QOS_PARAMETER);
+	case MFIE_TYPE_SSID:
+		return "SSID";
+	case MFIE_TYPE_RATES:
+		return "RATES";
+	case MFIE_TYPE_FH_SET:
+		return "FH_SET";
+	case MFIE_TYPE_DS_SET:
+		return "DS_SET";
+	case MFIE_TYPE_CF_SET:
+		return "CF_SET";
+	case MFIE_TYPE_TIM:
+		return "TIM";
+	case MFIE_TYPE_IBSS_SET:
+		return "IBSS_SET";
+	case MFIE_TYPE_COUNTRY:
+		return "COUNTRY";
+	case MFIE_TYPE_HOP_PARAMS:
+		return "HOP_PARAMS";
+	case MFIE_TYPE_HOP_TABLE:
+		return "HOP_TABLE";
+	case MFIE_TYPE_REQUEST:
+		return "REQUEST";
+	case MFIE_TYPE_CHALLENGE:
+		return "CHALLENGE";
+	case MFIE_TYPE_POWER_CONSTRAINT:
+		return "POWER_CONSTRAINT";
+	case MFIE_TYPE_POWER_CAPABILITY:
+		return "POWER_CAPABILITY";
+	case MFIE_TYPE_TPC_REQUEST:
+		return "TPC_REQUEST";
+	case MFIE_TYPE_TPC_REPORT:
+		return "TPC_REPORT";
+	case MFIE_TYPE_SUPP_CHANNELS:
+		return "SUPP_CHANNELS";
+	case MFIE_TYPE_CSA:
+		return "CSA";
+	case MFIE_TYPE_MEASURE_REQUEST:
+		return "MEASURE_REQUEST";
+	case MFIE_TYPE_MEASURE_REPORT:
+		return "MEASURE_REPORT";
+	case MFIE_TYPE_QUIET:
+		return "QUIET";
+	case MFIE_TYPE_IBSS_DFS:
+		return "IBSS_DFS";
+	case MFIE_TYPE_RSN:
+		return "RSN";
+	case MFIE_TYPE_RATES_EX:
+		return "RATES_EX";
+	case MFIE_TYPE_GENERIC:
+		return "GENERIC";
+	case MFIE_TYPE_QOS_PARAMETER:
+		return "QOS_PARAMETER";
 	default:
 		return "UNKNOWN";
 	}

commit ed4360336931ea99d029f1208d3e55b60c2bc621
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Tue Jul 14 22:04:25 2015 +0200

    staging: rtl8192e: Make rtllib_rx_mgt() static
    
    Function is not referenced outside of rtllib_rx.c
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index 0698a0d1f466..54dfff61f485 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -44,6 +44,9 @@
 #include "rtllib.h"
 #include "dot11d.h"
 
+static void rtllib_rx_mgt(struct rtllib_device *ieee, struct sk_buff *skb,
+			  struct rtllib_rx_stats *stats);
+
 static inline void rtllib_monitor_rx(struct rtllib_device *ieee,
 				     struct sk_buff *skb,
 				     struct rtllib_rx_stats *rx_status,
@@ -2715,9 +2718,9 @@ static inline void rtllib_process_probe_response(
 	kfree(network);
 }
 
-void rtllib_rx_mgt(struct rtllib_device *ieee,
-		      struct sk_buff *skb,
-		      struct rtllib_rx_stats *stats)
+static void rtllib_rx_mgt(struct rtllib_device *ieee,
+			  struct sk_buff *skb,
+			  struct rtllib_rx_stats *stats)
 {
 	struct rtllib_hdr_4addr *header = (struct rtllib_hdr_4addr *)skb->data;
 

commit e93c18c7236f3fb90e87c6239ed78ad2c2552dfd
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Tue Jul 14 22:04:09 2015 +0200

    staging: rtl8192e: Remove rtllib_stats structure
    
    Two remaining fields of rtllib_stats are only incremented, but
    never read.
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index da862c3da4ce..0698a0d1f466 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -317,7 +317,6 @@ rtllib_rx_frame_decrypt(struct rtllib_device *ieee, struct sk_buff *skb,
 			netdev_dbg(ieee->dev,
 				   "Decryption failed ICV mismatch (key %d)\n",
 				   skb->data[hdrlen + 3] >> 6);
-		ieee->ieee_stats.rx_discards_undecryptable++;
 		return -1;
 	}
 
@@ -1077,7 +1076,6 @@ static int rtllib_rx_get_crypt(struct rtllib_device *ieee, struct sk_buff *skb,
 			netdev_dbg(ieee->dev,
 				   "Decryption failed (not set) (SA= %pM)\n",
 				   hdr->addr2);
-			ieee->ieee_stats.rx_discards_undecryptable++;
 			return -1;
 		}
 	}

commit 47eae6ddd9cf12781cefe6ec458d791174cb59b9
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Mon Jun 15 21:06:10 2015 +0200

    staging: rtl8192e: Remove rtllib_device::agregation
    
    Variable is always true; Resolve condition where it is used
    (and change indentation of conditional expression).
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index 48a188a1ad46..da862c3da4ce 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -1883,38 +1883,34 @@ static void rtllib_parse_mife_generic(struct rtllib_device *ieee,
 		}
 	}
 
-	if (ieee->aggregation) {
-		if (network->bssht.bdSupportHT) {
-			if (info_element->len >= 4 &&
-			    info_element->data[0] == 0x00 &&
-			    info_element->data[1] == 0xe0 &&
-			    info_element->data[2] == 0x4c &&
-			    info_element->data[3] == 0x02) {
-				ht_realtek_agg_len = min_t(u8,
-							   info_element->len,
-							   MAX_IE_LEN);
-				memcpy(ht_realtek_agg_buf,
-				       info_element->data,
-				       info_element->len);
-			}
-			if (ht_realtek_agg_len >= 5) {
-				network->realtek_cap_exit = true;
-				network->bssht.bdRT2RTAggregation = true;
-
-				if ((ht_realtek_agg_buf[4] == 1) &&
-				    (ht_realtek_agg_buf[5] & 0x02))
-					network->bssht.bdRT2RTLongSlotTime = true;
-
-				if ((ht_realtek_agg_buf[4] == 1) &&
-				    (ht_realtek_agg_buf[5] & RT_HT_CAP_USE_92SE))
-					network->bssht.RT2RT_HT_Mode |= RT_HT_CAP_USE_92SE;
-			}
+	if (network->bssht.bdSupportHT) {
+		if (info_element->len >= 4 &&
+		    info_element->data[0] == 0x00 &&
+		    info_element->data[1] == 0xe0 &&
+		    info_element->data[2] == 0x4c &&
+		    info_element->data[3] == 0x02) {
+			ht_realtek_agg_len = min_t(u8, info_element->len,
+						   MAX_IE_LEN);
+			memcpy(ht_realtek_agg_buf, info_element->data,
+			       info_element->len);
 		}
 		if (ht_realtek_agg_len >= 5) {
-			if ((ht_realtek_agg_buf[5] & RT_HT_CAP_USE_SOFTAP))
-				network->bssht.RT2RT_HT_Mode |= RT_HT_CAP_USE_SOFTAP;
+			network->realtek_cap_exit = true;
+			network->bssht.bdRT2RTAggregation = true;
+
+			if ((ht_realtek_agg_buf[4] == 1) &&
+			    (ht_realtek_agg_buf[5] & 0x02))
+				network->bssht.bdRT2RTLongSlotTime = true;
+
+			if ((ht_realtek_agg_buf[4] == 1) &&
+			    (ht_realtek_agg_buf[5] & RT_HT_CAP_USE_92SE))
+				network->bssht.RT2RT_HT_Mode |= RT_HT_CAP_USE_92SE;
 		}
 	}
+	if (ht_realtek_agg_len >= 5) {
+		if ((ht_realtek_agg_buf[5] & RT_HT_CAP_USE_SOFTAP))
+			network->bssht.RT2RT_HT_Mode |= RT_HT_CAP_USE_SOFTAP;
+	}
 
 	if ((info_element->len >= 3 &&
 	     info_element->data[0] == 0x00 &&

commit 7f5678ee533b2e9a1c7a4c436e42607be50e0fb5
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Mon Jun 15 21:06:06 2015 +0200

    staging: rtl8192e: Remove rtllib_network::last_associate
    
    Variable was initialized and never used.
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index 2bef1f63be79..48a188a1ad46 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -2326,7 +2326,6 @@ static inline int rtllib_network_init(
 	/* Where to pull this? beacon->listen_interval;*/
 	network->listen_interval = 0x0A;
 	network->rates_len = network->rates_ex_len = 0;
-	network->last_associate = 0;
 	network->ssid_len = 0;
 	network->hidden_ssid_len = 0;
 	memset(network->hidden_ssid, 0, sizeof(network->hidden_ssid));
@@ -2504,7 +2503,6 @@ static inline void update_network(struct rtllib_device *ieee,
 	dst->qos_data.active = qos_active;
 	dst->qos_data.old_param_count = old_param;
 
-	/* dst->last_associate is not overwritten */
 	dst->wmm_info = src->wmm_info;
 	if (src->wmm_param[0].ac_aci_acm_aifsn ||
 	   src->wmm_param[1].ac_aci_acm_aifsn ||

commit 1208097416fb382b8fcdb8bf9e63954c36cdb62b
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Fri Jun 5 12:24:06 2015 +0300

    staging: rtl8192e: fix some confusing indenting
    
    The indenting here causes a static checker warning:
    
            drivers/staging/rtl8192e/rtllib_rx.c:626 RxReorderIndicatePacket()
            warn: curly braces intended?
    
    The code is actually correct, it's just that these lines were pushed in
    an extra indent level by mistake in 35e33b0468ab ('staging: rtl8192e:
    Fix LONG_LINE warnings').
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index 6977f04ccd4d..2bef1f63be79 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -623,9 +623,9 @@ static void RxReorderIndicatePacket(struct rtllib_device *ieee,
 		else
 			pTS->RxIndicateSeq = 4095 -
 					     (WinSize - (SeqNum + 1)) + 1;
-			netdev_dbg(ieee->dev,
-				   "Window Shift! IndicateSeq: %d, NewSeq: %d\n",
-				   pTS->RxIndicateSeq, SeqNum);
+		netdev_dbg(ieee->dev,
+			   "Window Shift! IndicateSeq: %d, NewSeq: %d\n",
+			   pTS->RxIndicateSeq, SeqNum);
 	}
 
 	/* Indication process.

commit d9c1fff59ac0ea84410a8ae39f81cd176368ec6e
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Sun May 31 20:19:51 2015 +0200

    staging: rtl8192e: Fix trivial LONG_LINE errors
    
    Reindent lines to make checkpatch happy.
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index 2280d1809ffe..6977f04ccd4d 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -1256,14 +1256,16 @@ static void rtllib_rx_indicate_pkt_legacy(struct rtllib_device *ieee,
 		struct sk_buff *sub_skb = rxb->subframes[i];
 
 		if (sub_skb) {
-			/* convert hdr + possible LLC headers into Ethernet header */
+			/* convert hdr + possible LLC headers
+			 * into Ethernet header
+			 */
 			ethertype = (sub_skb->data[6] << 8) | sub_skb->data[7];
 			if (sub_skb->len >= 8 &&
 				((memcmp(sub_skb->data, rfc1042_header, SNAP_SIZE) == 0 &&
 				ethertype != ETH_P_AARP && ethertype != ETH_P_IPX) ||
 				memcmp(sub_skb->data, bridge_tunnel_header, SNAP_SIZE) == 0)) {
-				/* remove RFC1042 or Bridge-Tunnel encapsulation and
-				 * replace EtherType
+				/* remove RFC1042 or Bridge-Tunnel encapsulation
+				 * and replace EtherType
 				 */
 				skb_pull(sub_skb, SNAP_SIZE);
 				ether_addr_copy(skb_push(sub_skb, ETH_ALEN),
@@ -1272,7 +1274,9 @@ static void rtllib_rx_indicate_pkt_legacy(struct rtllib_device *ieee,
 						dst);
 			} else {
 				u16 len;
-				/* Leave Ethernet header part of hdr and full payload */
+				/* Leave Ethernet header part of hdr
+				 * and full payload
+				 */
 				len = sub_skb->len;
 				memcpy(skb_push(sub_skb, 2), &len, 2);
 				ether_addr_copy(skb_push(sub_skb, ETH_ALEN),
@@ -1293,7 +1297,8 @@ static void rtllib_rx_indicate_pkt_legacy(struct rtllib_device *ieee,
 			sub_skb->dev = dev;
 			sub_skb->dev->stats.rx_packets++;
 			sub_skb->dev->stats.rx_bytes += sub_skb->len;
-			sub_skb->ip_summed = CHECKSUM_NONE; /* 802.11 crc not sufficient */
+			/* 802.11 crc not sufficient */
+			sub_skb->ip_summed = CHECKSUM_NONE;
 			netif_rx(sub_skb);
 		}
 	}
@@ -1835,11 +1840,10 @@ static void rtllib_parse_mife_generic(struct rtllib_device *ieee,
 
 	if (*tmp_htcap_len == 0) {
 		if (info_element->len >= 4 &&
-		   info_element->data[0] == 0x00 &&
-		   info_element->data[1] == 0x90 &&
-		   info_element->data[2] == 0x4c &&
-		   info_element->data[3] == 0x033) {
-
+		    info_element->data[0] == 0x00 &&
+		    info_element->data[1] == 0x90 &&
+		    info_element->data[2] == 0x4c &&
+		    info_element->data[3] == 0x033) {
 			*tmp_htcap_len = min_t(u8, info_element->len,
 					       MAX_IE_LEN);
 			if (*tmp_htcap_len != 0) {

commit a94aa9adb6fe79ddb9181bddd34ade3e8718c582
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Sun May 31 20:19:45 2015 +0200

    staging: rtl8192e: Replace ?: with max_t
    
    Improve readability and make checkpatch happy.
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index 588c6d7cf2f9..2280d1809ffe 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -1685,7 +1685,7 @@ static int rtllib_qos_convert_ac_to_parameters(struct rtllib_qos_parameter_info
 		qos_param->aifs[aci] = (ac_params->aci_aifsn) & 0x0f;
 
 		/* WMM spec P.11: The minimum value for AIFSN shall be 2 */
-		qos_param->aifs[aci] = (qos_param->aifs[aci] < 2) ? 2 : qos_param->aifs[aci];
+		qos_param->aifs[aci] = max_t(u8, qos_param->aifs[aci], 2);
 
 		qos_param->cw_min[aci] = cpu_to_le16(ac_params->ecw_min_max &
 						     0x0F);

commit 310852327ab3b5182dd9c1b8b7f44831eaa2454a
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Sun May 31 20:19:41 2015 +0200

    staging: rtl8192e: Fix LONG_LING in rtllib_parse_info_param()
    
    Take out MIFE_TYPE_HT_CAP processing into separate function -
    rtllib_parse_mfie_ht_cap()
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index 8e3aabf6e796..588c6d7cf2f9 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -2010,6 +2010,33 @@ static void rtllib_parse_mife_generic(struct rtllib_device *ieee,
 	}
 }
 
+static void rtllib_parse_mfie_ht_cap(struct rtllib_info_element *info_element,
+				     struct rtllib_network *network,
+				     u16 *tmp_htcap_len)
+{
+	struct bss_ht *ht = &network->bssht;
+
+	*tmp_htcap_len = min_t(u8, info_element->len, MAX_IE_LEN);
+	if (*tmp_htcap_len != 0) {
+		ht->bdHTSpecVer = HT_SPEC_VER_EWC;
+		ht->bdHTCapLen = min_t(u16, *tmp_htcap_len,
+				       sizeof(ht->bdHTCapBuf));
+		memcpy(ht->bdHTCapBuf, info_element->data, ht->bdHTCapLen);
+
+		ht->bdSupportHT = true;
+		ht->bdHT1R = ((((struct ht_capab_ele *)
+				ht->bdHTCapBuf))->MCS[1]) == 0;
+
+		ht->bdBandWidth = (enum ht_channel_width)
+					     (((struct ht_capab_ele *)
+					     (ht->bdHTCapBuf))->ChlWidth);
+	} else {
+		ht->bdSupportHT = false;
+		ht->bdHT1R = false;
+		ht->bdBandWidth = HT_CHANNEL_WIDTH_20;
+	}
+}
+
 int rtllib_parse_info_param(struct rtllib_device *ieee,
 		struct rtllib_info_element *info_element,
 		u16 length,
@@ -2191,27 +2218,9 @@ int rtllib_parse_info_param(struct rtllib_device *ieee,
 		case MFIE_TYPE_HT_CAP:
 			netdev_dbg(ieee->dev, "MFIE_TYPE_HT_CAP: %d bytes\n",
 				   info_element->len);
-			tmp_htcap_len = min_t(u8, info_element->len, MAX_IE_LEN);
-			if (tmp_htcap_len != 0) {
-				network->bssht.bdHTSpecVer = HT_SPEC_VER_EWC;
-				network->bssht.bdHTCapLen = tmp_htcap_len > sizeof(network->bssht.bdHTCapBuf) ?
-					sizeof(network->bssht.bdHTCapBuf) : tmp_htcap_len;
-				memcpy(network->bssht.bdHTCapBuf,
-				       info_element->data,
-				       network->bssht.bdHTCapLen);
 
-				network->bssht.bdSupportHT = true;
-				network->bssht.bdHT1R = ((((struct ht_capab_ele *)
-							network->bssht.bdHTCapBuf))->MCS[1]) == 0;
-
-				network->bssht.bdBandWidth = (enum ht_channel_width)
-							     (((struct ht_capab_ele *)
-							     (network->bssht.bdHTCapBuf))->ChlWidth);
-			} else {
-				network->bssht.bdSupportHT = false;
-				network->bssht.bdHT1R = false;
-				network->bssht.bdBandWidth = HT_CHANNEL_WIDTH_20;
-			}
+			rtllib_parse_mfie_ht_cap(info_element, network,
+						 &tmp_htcap_len);
 			break;
 
 

commit 35e33b0468ab3b3f5b610bfa4fc9367a3b7c09a8
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Sun May 31 20:19:40 2015 +0200

    staging: rtl8192e: Fix LONG_LINE warnings
    
    Fix most of simple LONG_LINE warnings. None of the changes should affect
    behaviour of code, so several modifications are included in this patch:
    - Code is reindented where needed
    - Local variable names are compacted (priv -> p)
    - Unnecessary casts are removed
    - Nested ifs are replaced with logical and
    - a = b = c = d expressions are split
    - Replace if/then series with clamp_t()
    - Removed unneeded scopes
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index 11c6013d133e..8e3aabf6e796 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -45,8 +45,9 @@
 #include "dot11d.h"
 
 static inline void rtllib_monitor_rx(struct rtllib_device *ieee,
-				struct sk_buff *skb, struct rtllib_rx_stats *rx_status,
-				size_t hdr_length)
+				     struct sk_buff *skb,
+				     struct rtllib_rx_stats *rx_status,
+				     size_t hdr_length)
 {
 	skb->dev = ieee->dev;
 	skb_reset_mac_header(skb);
@@ -101,7 +102,8 @@ rtllib_frag_cache_get(struct rtllib_device *ieee,
 	struct rtllib_hdr_4addrqos *hdr_4addrqos;
 	u8 tid;
 
-	if (((fc & RTLLIB_FCTL_DSTODS) == RTLLIB_FCTL_DSTODS) && RTLLIB_QOS_HAS_SEQ(fc)) {
+	if (((fc & RTLLIB_FCTL_DSTODS) == RTLLIB_FCTL_DSTODS) &&
+	    RTLLIB_QOS_HAS_SEQ(fc)) {
 		hdr_4addrqos = (struct rtllib_hdr_4addrqos *)hdr;
 		tid = le16_to_cpu(hdr_4addrqos->qos_ctl) & RTLLIB_QCTL_TID;
 		tid = UP2AC(tid);
@@ -123,7 +125,8 @@ rtllib_frag_cache_get(struct rtllib_device *ieee,
 				    2 /* alignment */ +
 				    8 /* WEP */ +
 				    ETH_ALEN /* WDS */ +
-				    (RTLLIB_QOS_HAS_SEQ(fc) ? 2 : 0) /* QOS Control */);
+				    /* QOS Control */
+				    (RTLLIB_QOS_HAS_SEQ(fc) ? 2 : 0));
 		if (skb == NULL)
 			return NULL;
 
@@ -169,7 +172,8 @@ static int rtllib_frag_cache_invalidate(struct rtllib_device *ieee,
 	struct rtllib_hdr_4addrqos *hdr_4addrqos;
 	u8 tid;
 
-	if (((fc & RTLLIB_FCTL_DSTODS) == RTLLIB_FCTL_DSTODS) && RTLLIB_QOS_HAS_SEQ(fc)) {
+	if (((fc & RTLLIB_FCTL_DSTODS) == RTLLIB_FCTL_DSTODS) &&
+	    RTLLIB_QOS_HAS_SEQ(fc)) {
 		hdr_4addrqos = (struct rtllib_hdr_4addrqos *)hdr;
 		tid = le16_to_cpu(hdr_4addrqos->qos_ctl) & RTLLIB_QCTL_TID;
 		tid = UP2AC(tid);
@@ -291,7 +295,8 @@ rtllib_rx_frame_decrypt(struct rtllib_device *ieee, struct sk_buff *skb,
 		return 0;
 
 	if (ieee->hwsec_active) {
-		struct cb_desc *tcb_desc = (struct cb_desc *)(skb->cb + MAX_DEV_ADDR_SIZE);
+		struct cb_desc *tcb_desc = (struct cb_desc *)
+						(skb->cb + MAX_DEV_ADDR_SIZE);
 
 		tcb_desc->bHwSec = 1;
 
@@ -331,7 +336,8 @@ rtllib_rx_frame_decrypt_msdu(struct rtllib_device *ieee, struct sk_buff *skb,
 	if (crypt == NULL || crypt->ops->decrypt_msdu == NULL)
 		return 0;
 	if (ieee->hwsec_active) {
-		struct cb_desc *tcb_desc = (struct cb_desc *)(skb->cb + MAX_DEV_ADDR_SIZE);
+		struct cb_desc *tcb_desc = (struct cb_desc *)
+						(skb->cb + MAX_DEV_ADDR_SIZE);
 
 		tcb_desc->bHwSec = 1;
 
@@ -371,7 +377,8 @@ static int is_duplicate_packet(struct rtllib_device *ieee,
 	struct rtllib_hdr_4addrqos *hdr_4addrqos;
 	u8 tid;
 
-	if (((fc & RTLLIB_FCTL_DSTODS) == RTLLIB_FCTL_DSTODS) && RTLLIB_QOS_HAS_SEQ(fc)) {
+	if (((fc & RTLLIB_FCTL_DSTODS) == RTLLIB_FCTL_DSTODS) &&
+	    RTLLIB_QOS_HAS_SEQ(fc)) {
 		hdr_4addrqos = (struct rtllib_hdr_4addrqos *)header;
 		tid = le16_to_cpu(hdr_4addrqos->qos_ctl) & RTLLIB_QCTL_TID;
 		tid = UP2AC(tid);
@@ -399,7 +406,8 @@ static int is_duplicate_packet(struct rtllib_device *ieee,
 				break;
 		}
 		if (p == &ieee->ibss_mac_hash[index]) {
-			entry = kmalloc(sizeof(struct ieee_ibss_seq), GFP_ATOMIC);
+			entry = kmalloc(sizeof(struct ieee_ibss_seq),
+					GFP_ATOMIC);
 			if (!entry)
 				return 0;
 
@@ -469,7 +477,8 @@ static bool AddReorderEntry(struct rx_ts_record *pTS,
 	return true;
 }
 
-void rtllib_indicate_packets(struct rtllib_device *ieee, struct rtllib_rxb **prxbIndicateArray, u8 index)
+void rtllib_indicate_packets(struct rtllib_device *ieee,
+			     struct rtllib_rxb **prxbIndicateArray, u8 index)
 {
 	struct net_device_stats *stats = &ieee->stats;
 	u8 i = 0, j = 0;
@@ -484,9 +493,12 @@ void rtllib_indicate_packets(struct rtllib_device *ieee, struct rtllib_rxb **prx
 		/* convert hdr + possible LLC headers into Ethernet header */
 			ethertype = (sub_skb->data[6] << 8) | sub_skb->data[7];
 			if (sub_skb->len >= 8 &&
-			    ((memcmp(sub_skb->data, rfc1042_header, SNAP_SIZE) == 0 &&
-			    ethertype != ETH_P_AARP && ethertype != ETH_P_IPX) ||
-			    memcmp(sub_skb->data, bridge_tunnel_header, SNAP_SIZE) == 0)) {
+			    ((memcmp(sub_skb->data, rfc1042_header,
+				     SNAP_SIZE) == 0 &&
+			      ethertype != ETH_P_AARP &&
+			      ethertype != ETH_P_IPX) ||
+			    memcmp(sub_skb->data, bridge_tunnel_header,
+				   SNAP_SIZE) == 0)) {
 				/* remove RFC1042 or Bridge-Tunnel encapsulation
 				 * and replace EtherType
 				 */
@@ -508,11 +520,13 @@ void rtllib_indicate_packets(struct rtllib_device *ieee, struct rtllib_rxb **prx
 				stats->rx_bytes += sub_skb->len;
 
 				memset(sub_skb->cb, 0, sizeof(sub_skb->cb));
-				sub_skb->protocol = eth_type_trans(sub_skb, ieee->dev);
+				sub_skb->protocol = eth_type_trans(sub_skb,
+								   ieee->dev);
 				sub_skb->dev = ieee->dev;
 				sub_skb->dev->stats.rx_packets++;
 				sub_skb->dev->stats.rx_bytes += sub_skb->len;
-				sub_skb->ip_summed = CHECKSUM_NONE; /* 802.11 crc not sufficient */
+				/* 802.11 crc not sufficient */
+				sub_skb->ip_summed = CHECKSUM_NONE;
 				ieee->last_rx_ps_time = jiffies;
 				netif_rx(sub_skb);
 			}
@@ -522,7 +536,8 @@ void rtllib_indicate_packets(struct rtllib_device *ieee, struct rtllib_rxb **prx
 	}
 }
 
-void rtllib_FlushRxTsPendingPkts(struct rtllib_device *ieee,	struct rx_ts_record *pTS)
+void rtllib_FlushRxTsPendingPkts(struct rtllib_device *ieee,
+				 struct rx_ts_record *pTS)
 {
 	struct rx_reorder_entry *pRxReorderEntry;
 	u8 RfdCnt = 0;
@@ -536,7 +551,9 @@ void rtllib_FlushRxTsPendingPkts(struct rtllib_device *ieee,	struct rx_ts_record
 			break;
 		}
 
-		pRxReorderEntry = (struct rx_reorder_entry *)list_entry(pTS->RxPendingPktList.prev, struct rx_reorder_entry, List);
+		pRxReorderEntry = (struct rx_reorder_entry *)
+				  list_entry(pTS->RxPendingPktList.prev,
+					     struct rx_reorder_entry, List);
 		netdev_dbg(ieee->dev, "%s(): Indicate SeqNum %d!\n", __func__,
 			   pRxReorderEntry->SeqNum);
 		list_del_init(&pRxReorderEntry->List);
@@ -544,7 +561,8 @@ void rtllib_FlushRxTsPendingPkts(struct rtllib_device *ieee,	struct rx_ts_record
 		ieee->RfdArray[RfdCnt] = pRxReorderEntry->prxb;
 
 		RfdCnt = RfdCnt + 1;
-		list_add_tail(&pRxReorderEntry->List, &ieee->RxReorder_Unused_List);
+		list_add_tail(&pRxReorderEntry->List,
+			      &ieee->RxReorder_Unused_List);
 	}
 	rtllib_indicate_packets(ieee, ieee->RfdArray, RfdCnt);
 
@@ -603,10 +621,11 @@ static void RxReorderIndicatePacket(struct rtllib_device *ieee,
 		if (SeqNum >= (WinSize - 1))
 			pTS->RxIndicateSeq = SeqNum + 1 - WinSize;
 		else
-			pTS->RxIndicateSeq = 4095 - (WinSize - (SeqNum + 1)) + 1;
-		netdev_dbg(ieee->dev,
-			   "Window Shift! IndicateSeq: %d, NewSeq: %d\n",
-			   pTS->RxIndicateSeq, SeqNum);
+			pTS->RxIndicateSeq = 4095 -
+					     (WinSize - (SeqNum + 1)) + 1;
+			netdev_dbg(ieee->dev,
+				   "Window Shift! IndicateSeq: %d, NewSeq: %d\n",
+				   pTS->RxIndicateSeq, SeqNum);
 	}
 
 	/* Indication process.
@@ -621,7 +640,8 @@ static void RxReorderIndicatePacket(struct rtllib_device *ieee,
 	 */
 	if (bMatchWinStart) {
 		/* Current packet is going to be indicated.*/
-		netdev_dbg(ieee->dev, "Packets indication! IndicateSeq: %d, NewSeq: %d\n",
+		netdev_dbg(ieee->dev,
+			   "Packets indication! IndicateSeq: %d, NewSeq: %d\n",
 			   pTS->RxIndicateSeq, SeqNum);
 		ieee->prxbIndicateArray[0] = prxb;
 		index = 1;
@@ -633,24 +653,26 @@ static void RxReorderIndicatePacket(struct rtllib_device *ieee,
 					struct rx_reorder_entry, List);
 			list_del_init(&pReorderEntry->List);
 
-			/* Make a reorder entry and insert into a the packet list.*/
+			/* Make a reorder entry and insert
+			 * into a the packet list.
+			 */
 			pReorderEntry->SeqNum = SeqNum;
 			pReorderEntry->prxb = prxb;
 
 			if (!AddReorderEntry(pTS, pReorderEntry)) {
+				int i;
+
 				netdev_dbg(ieee->dev,
 					   "%s(): Duplicate packet is dropped. IndicateSeq: %d, NewSeq: %d\n",
 					   __func__, pTS->RxIndicateSeq,
 					   SeqNum);
 				list_add_tail(&pReorderEntry->List,
-					      &ieee->RxReorder_Unused_List); {
-					int i;
+					      &ieee->RxReorder_Unused_List);
 
-					for (i = 0; i < prxb->nr_subframes; i++)
-						dev_kfree_skb(prxb->subframes[i]);
-					kfree(prxb);
-					prxb = NULL;
-				}
+				for (i = 0; i < prxb->nr_subframes; i++)
+					dev_kfree_skb(prxb->subframes[i]);
+				kfree(prxb);
+				prxb = NULL;
 			} else {
 				netdev_dbg(ieee->dev,
 					   "Pkt insert into struct buffer. IndicateSeq: %d, NewSeq: %d\n",
@@ -681,10 +703,12 @@ static void RxReorderIndicatePacket(struct rtllib_device *ieee,
 		netdev_dbg(ieee->dev, "%s(): start RREORDER indicate\n",
 			   __func__);
 
-		pReorderEntry = (struct rx_reorder_entry *)list_entry(pTS->RxPendingPktList.prev,
-				 struct rx_reorder_entry, List);
+		pReorderEntry = (struct rx_reorder_entry *)
+					list_entry(pTS->RxPendingPktList.prev,
+						   struct rx_reorder_entry,
+						   List);
 		if (SN_LESS(pReorderEntry->SeqNum, pTS->RxIndicateSeq) ||
-				SN_EQUAL(pReorderEntry->SeqNum, pTS->RxIndicateSeq)) {
+		    SN_EQUAL(pReorderEntry->SeqNum, pTS->RxIndicateSeq)) {
 			/* This protect struct buffer from overflow. */
 			if (index >= REORDER_WIN_SIZE) {
 				netdev_err(ieee->dev,
@@ -697,7 +721,8 @@ static void RxReorderIndicatePacket(struct rtllib_device *ieee,
 			list_del_init(&pReorderEntry->List);
 
 			if (SN_EQUAL(pReorderEntry->SeqNum, pTS->RxIndicateSeq))
-				pTS->RxIndicateSeq = (pTS->RxIndicateSeq + 1) % 4096;
+				pTS->RxIndicateSeq = (pTS->RxIndicateSeq + 1) %
+						     4096;
 
 			ieee->prxbIndicateArray[index] = pReorderEntry->prxb;
 			netdev_dbg(ieee->dev, "%s(): Indicate SeqNum %d!\n",
@@ -912,7 +937,8 @@ static int rtllib_rx_check_duplicate(struct rtllib_device *ieee,
 		!ieee->current_network.qos_data.active ||
 		!IsDataFrame(skb->data) ||
 		IsLegacyDataFrame(skb->data)) {
-		if (!((type == RTLLIB_FTYPE_MGMT) && (stype == RTLLIB_STYPE_BEACON))) {
+		if (!((type == RTLLIB_FTYPE_MGMT) &&
+		      (stype == RTLLIB_STYPE_BEACON))) {
 			if (is_duplicate_packet(ieee, hdr))
 				return -1;
 		}
@@ -1015,7 +1041,8 @@ static int rtllib_rx_data_filter(struct rtllib_device *ieee, u16 fc,
 
 		/* {broad,multi}cast packets to our BSS go through */
 		if (is_multicast_ether_addr(dst)) {
-			if (memcmp(bssid, ieee->current_network.bssid, ETH_ALEN))
+			if (memcmp(bssid, ieee->current_network.bssid,
+				   ETH_ALEN))
 				return -1;
 		}
 	}
@@ -1193,7 +1220,8 @@ static int rtllib_rx_decrypt(struct rtllib_device *ieee, struct sk_buff *skb,
 	return 0;
 }
 
-static void rtllib_rx_check_leave_lps(struct rtllib_device *ieee, u8 unicast, u8 nr_subframes)
+static void rtllib_rx_check_leave_lps(struct rtllib_device *ieee, u8 unicast,
+				      u8 nr_subframes)
 {
 	if (unicast) {
 
@@ -1310,7 +1338,8 @@ static int rtllib_rx_InfraAdhoc(struct rtllib_device *ieee, struct sk_buff *skb,
 	/*Filter pkt has too small length */
 	hdrlen = rtllib_rx_get_hdrlen(ieee, skb, rx_stats);
 	if (skb->len < hdrlen) {
-		netdev_info(dev, "%s():ERR!!! skb->len is smaller than hdrlen\n",
+		netdev_info(dev,
+			    "%s():ERR!!! skb->len is smaller than hdrlen\n",
 			    __func__);
 		goto rx_dropped;
 	}
@@ -1355,10 +1384,13 @@ static int rtllib_rx_InfraAdhoc(struct rtllib_device *ieee, struct sk_buff *skb,
 		goto rx_dropped;
 
 	/* Send pspoll based on moredata */
-	if ((ieee->iw_mode == IW_MODE_INFRA)  && (ieee->sta_sleep == LPS_IS_SLEEP)
-		&& (ieee->polling) && (!bToOtherSTA)) {
+	if ((ieee->iw_mode == IW_MODE_INFRA)  &&
+	    (ieee->sta_sleep == LPS_IS_SLEEP) &&
+	    (ieee->polling) && (!bToOtherSTA)) {
 		if (WLAN_FC_MORE_DATA(fc)) {
-			/* more data bit is set, let's request a new frame from the AP */
+			/* more data bit is set, let's request a new frame
+			 * from the AP
+			 */
 			rtllib_sta_ps_send_pspoll_frame(ieee);
 		} else {
 			ieee->polling =  false;
@@ -1384,7 +1416,8 @@ static int rtllib_rx_InfraAdhoc(struct rtllib_device *ieee, struct sk_buff *skb,
 		&& (!bToOtherSTA)) {
 		TID = Frame_QoSTID(skb->data);
 		SeqNum = WLAN_GET_SEQ_SEQ(sc);
-		GetTs(ieee, (struct ts_common_info **) &pTS, hdr->addr2, TID, RX_DIR, true);
+		GetTs(ieee, (struct ts_common_info **) &pTS, hdr->addr2, TID,
+		      RX_DIR, true);
 		if (TID != 0 && TID != 3)
 			ieee->bis_any_nonbepkts = true;
 	}
@@ -1399,7 +1432,9 @@ static int rtllib_rx_InfraAdhoc(struct rtllib_device *ieee, struct sk_buff *skb,
 	/* to parse amsdu packets */
 	/* qos data packets & reserved bit is 1 */
 	if (parse_subframe(ieee, skb, rx_stats, rxb, src, dst) == 0) {
-		/* only to free rxb, and not submit the packets to upper layer */
+		/* only to free rxb, and not submit the packets
+		 * to upper layer
+		 */
 		for (i = 0; i < rxb->nr_subframes; i++)
 			dev_kfree_skb(rxb->subframes[i]);
 		kfree(rxb);
@@ -1421,7 +1456,8 @@ static int rtllib_rx_InfraAdhoc(struct rtllib_device *ieee, struct sk_buff *skb,
 	}
 
 	/* Indicate packets to upper layer or Rx Reorder */
-	if (ieee->pHTInfo->bCurRxReorderEnable == false || pTS == NULL || bToOtherSTA)
+	if (ieee->pHTInfo->bCurRxReorderEnable == false || pTS == NULL ||
+	    bToOtherSTA)
 		rtllib_rx_indicate_pkt_legacy(ieee, rx_stats, rxb, dst, src);
 	else
 		RxReorderIndicatePacket(ieee, rxb, pTS, SeqNum);
@@ -1550,8 +1586,9 @@ static int rtllib_verify_qos_info(struct rtllib_qos_information_element
 
 /* Parse a QoS parameter element */
 static int rtllib_read_qos_param_element(struct rtllib_qos_parameter_info
-					    *element_param, struct rtllib_info_element
-					    *info_element)
+							*element_param,
+					 struct rtllib_info_element
+							*info_element)
 {
 	int ret = 0;
 	u16 size = sizeof(struct rtllib_qos_parameter_info) - 2;
@@ -1573,10 +1610,10 @@ static int rtllib_read_qos_param_element(struct rtllib_qos_parameter_info
 }
 
 /* Parse a QoS information element */
-static int rtllib_read_qos_info_element(struct
-					   rtllib_qos_information_element
-					   *element_info, struct rtllib_info_element
-					   *info_element)
+static int rtllib_read_qos_info_element(struct rtllib_qos_information_element
+							*element_info,
+					struct rtllib_info_element
+							*info_element)
 {
 	int ret = 0;
 	u16 size = sizeof(struct rtllib_qos_information_element) - 2;
@@ -1586,7 +1623,8 @@ static int rtllib_read_qos_info_element(struct
 	if (info_element == NULL)
 		return -1;
 
-	if ((info_element->id == QOS_ELEMENT_ID) && (info_element->len == size)) {
+	if ((info_element->id == QOS_ELEMENT_ID) &&
+	    (info_element->len == size)) {
 		memcpy(element_info->qui, info_element->data,
 		       info_element->len);
 		element_info->elementID = info_element->id;
@@ -1596,14 +1634,14 @@ static int rtllib_read_qos_info_element(struct
 
 	if (ret == 0)
 		ret = rtllib_verify_qos_info(element_info,
-						QOS_OUI_INFO_SUB_TYPE);
+					     QOS_OUI_INFO_SUB_TYPE);
 	return ret;
 }
 
 
 /* Write QoS parameters from the ac parameters. */
 static int rtllib_qos_convert_ac_to_parameters(struct rtllib_qos_parameter_info *param_elm,
-		struct rtllib_qos_data *qos_data)
+					       struct rtllib_qos_data *qos_data)
 {
 	struct rtllib_qos_ac_parameter *ac_params;
 	struct rtllib_qos_parameters *qos_param = &(qos_data->parameters);
@@ -1649,9 +1687,11 @@ static int rtllib_qos_convert_ac_to_parameters(struct rtllib_qos_parameter_info
 		/* WMM spec P.11: The minimum value for AIFSN shall be 2 */
 		qos_param->aifs[aci] = (qos_param->aifs[aci] < 2) ? 2 : qos_param->aifs[aci];
 
-		qos_param->cw_min[aci] = cpu_to_le16(ac_params->ecw_min_max & 0x0F);
+		qos_param->cw_min[aci] = cpu_to_le16(ac_params->ecw_min_max &
+						     0x0F);
 
-		qos_param->cw_max[aci] = cpu_to_le16((ac_params->ecw_min_max & 0xF0) >> 4);
+		qos_param->cw_max[aci] = cpu_to_le16((ac_params->ecw_min_max &
+						      0xF0) >> 4);
 
 		qos_param->flag[aci] =
 		    (ac_params->aci_aifsn & 0x10) ? 0x01 : 0x00;
@@ -1742,15 +1782,19 @@ static inline void rtllib_extract_country_ie(
 {
 	if (IS_DOT11D_ENABLE(ieee)) {
 		if (info_element->len != 0) {
-			memcpy(network->CountryIeBuf, info_element->data, info_element->len);
+			memcpy(network->CountryIeBuf, info_element->data,
+			       info_element->len);
 			network->CountryIeLen = info_element->len;
 
 			if (!IS_COUNTRY_IE_VALID(ieee)) {
-				if (rtllib_act_scanning(ieee, false) && ieee->FirstIe_InScan)
+				if (rtllib_act_scanning(ieee, false) &&
+				    ieee->FirstIe_InScan)
 					netdev_info(ieee->dev,
 						    "Received beacon ContryIE, SSID: <%s>\n",
 						    network->ssid);
-				Dot11d_UpdateCountryIe(ieee, addr2, info_element->len, info_element->data);
+				Dot11d_UpdateCountryIe(ieee, addr2,
+						       info_element->len,
+						       info_element->data);
 			}
 		}
 
@@ -1929,7 +1973,8 @@ static void rtllib_parse_mife_generic(struct rtllib_device *ieee,
 			network->MBssidMask = network->CcxRmState[1] & 0x07;
 			if (network->MBssidMask != 0) {
 				network->bMBssidValid = true;
-				network->MBssidMask = 0xff << (network->MBssidMask);
+				network->MBssidMask = 0xff <<
+						      (network->MBssidMask);
 				ether_addr_copy(network->MBssid,
 						network->bssid);
 				network->MBssid[5] &= network->MBssidMask;
@@ -2001,7 +2046,8 @@ int rtllib_parse_info_param(struct rtllib_device *ieee,
 
 			network->ssid_len = min(info_element->len,
 						(u8) IW_ESSID_MAX_SIZE);
-			memcpy(network->ssid, info_element->data, network->ssid_len);
+			memcpy(network->ssid, info_element->data,
+			       network->ssid_len);
 			if (network->ssid_len < IW_ESSID_MAX_SIZE)
 				memset(network->ssid + network->ssid_len, 0,
 				       IW_ESSID_MAX_SIZE - network->ssid_len);
@@ -2172,7 +2218,8 @@ int rtllib_parse_info_param(struct rtllib_device *ieee,
 		case MFIE_TYPE_HT_INFO:
 			netdev_dbg(ieee->dev, "MFIE_TYPE_HT_INFO: %d bytes\n",
 				   info_element->len);
-			tmp_htinfo_len = min_t(u8, info_element->len, MAX_IE_LEN);
+			tmp_htinfo_len = min_t(u8, info_element->len,
+					       MAX_IE_LEN);
 			if (tmp_htinfo_len) {
 				network->bssht.bdHTSpecVer = HT_SPEC_VER_IEEE;
 				network->bssht.bdHTInfoLen = tmp_htinfo_len >

commit 7bdfaa0abfdf4d3189b499585c09de6e941e93a3
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Sun May 31 20:19:39 2015 +0200

    staging: rtl8192e: Fix PREFER_PR_LEVEL warnings
    
    Fix most of remaining PREFER_PR_LEVEL warnings in rtllib.
    Replace printk() with netdev_* if possible, pr_* in other cases.
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index 58c9cf281959..11c6013d133e 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -346,8 +346,9 @@ rtllib_rx_frame_decrypt_msdu(struct rtllib_device *ieee, struct sk_buff *skb,
 	res = crypt->ops->decrypt_msdu(skb, keyidx, hdrlen, crypt->priv);
 	atomic_dec(&crypt->refcnt);
 	if (res < 0) {
-		printk(KERN_DEBUG "%s: MSDU decryption/MIC verification failed (SA= %pM keyidx=%d)\n",
-		       ieee->dev->name, hdr->addr2, keyidx);
+		netdev_dbg(ieee->dev,
+			   "MSDU decryption/MIC verification failed (SA= %pM keyidx=%d)\n",
+			   hdr->addr2, keyidx);
 		return -1;
 	}
 

commit b94436b5d527d06403120be23570343a02b2283b
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Sun May 31 20:19:35 2015 +0200

    staging: rtl8192e: Remove RTLLIB_DEBUG()
    
    - Use netdev_dbg or netdev_vdbg instead of RTLLIB_DEBUG()
    - Reformat some messages for better readability
    - Remove RTLLIB_DEBUG messages that make no sense
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index f9863c40fd7f..58c9cf281959 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -536,7 +536,8 @@ void rtllib_FlushRxTsPendingPkts(struct rtllib_device *ieee,	struct rx_ts_record
 		}
 
 		pRxReorderEntry = (struct rx_reorder_entry *)list_entry(pTS->RxPendingPktList.prev, struct rx_reorder_entry, List);
-		RTLLIB_DEBUG(RTLLIB_DL_REORDER, "%s(): Indicate SeqNum %d!\n", __func__, pRxReorderEntry->SeqNum);
+		netdev_dbg(ieee->dev, "%s(): Indicate SeqNum %d!\n", __func__,
+			   pRxReorderEntry->SeqNum);
 		list_del_init(&pRxReorderEntry->List);
 
 		ieee->RfdArray[RfdCnt] = pRxReorderEntry->prxb;
@@ -561,8 +562,9 @@ static void RxReorderIndicatePacket(struct rtllib_device *ieee,
 	bool bMatchWinStart = false, bPktInBuf = false;
 	unsigned long flags;
 
-	RTLLIB_DEBUG(RTLLIB_DL_REORDER, "%s(): Seq is %d, pTS->RxIndicateSeq is %d, WinSize is %d\n", __func__, SeqNum,
-		     pTS->RxIndicateSeq, WinSize);
+	netdev_dbg(ieee->dev,
+		   "%s(): Seq is %d, pTS->RxIndicateSeq is %d, WinSize is %d\n",
+		   __func__, SeqNum, pTS->RxIndicateSeq, WinSize);
 
 	spin_lock_irqsave(&(ieee->reorder_spinlock), flags);
 
@@ -573,8 +575,9 @@ static void RxReorderIndicatePacket(struct rtllib_device *ieee,
 
 	/* Drop out the packet which SeqNum is smaller than WinStart */
 	if (SN_LESS(SeqNum, pTS->RxIndicateSeq)) {
-		RTLLIB_DEBUG(RTLLIB_DL_REORDER, "Packet Drop! IndicateSeq: %d, NewSeq: %d\n",
-				 pTS->RxIndicateSeq, SeqNum);
+		netdev_dbg(ieee->dev,
+			   "Packet Drop! IndicateSeq: %d, NewSeq: %d\n",
+			   pTS->RxIndicateSeq, SeqNum);
 		pHTInfo->RxReorderDropCounter++;
 		{
 			int i;
@@ -600,7 +603,9 @@ static void RxReorderIndicatePacket(struct rtllib_device *ieee,
 			pTS->RxIndicateSeq = SeqNum + 1 - WinSize;
 		else
 			pTS->RxIndicateSeq = 4095 - (WinSize - (SeqNum + 1)) + 1;
-		RTLLIB_DEBUG(RTLLIB_DL_REORDER, "Window Shift! IndicateSeq: %d, NewSeq: %d\n", pTS->RxIndicateSeq, SeqNum);
+		netdev_dbg(ieee->dev,
+			   "Window Shift! IndicateSeq: %d, NewSeq: %d\n",
+			   pTS->RxIndicateSeq, SeqNum);
 	}
 
 	/* Indication process.
@@ -615,8 +620,8 @@ static void RxReorderIndicatePacket(struct rtllib_device *ieee,
 	 */
 	if (bMatchWinStart) {
 		/* Current packet is going to be indicated.*/
-		RTLLIB_DEBUG(RTLLIB_DL_REORDER, "Packets indication!! IndicateSeq: %d, NewSeq: %d\n",
-				pTS->RxIndicateSeq, SeqNum);
+		netdev_dbg(ieee->dev, "Packets indication! IndicateSeq: %d, NewSeq: %d\n",
+			   pTS->RxIndicateSeq, SeqNum);
 		ieee->prxbIndicateArray[0] = prxb;
 		index = 1;
 	} else {
@@ -632,10 +637,10 @@ static void RxReorderIndicatePacket(struct rtllib_device *ieee,
 			pReorderEntry->prxb = prxb;
 
 			if (!AddReorderEntry(pTS, pReorderEntry)) {
-				RTLLIB_DEBUG(RTLLIB_DL_REORDER,
-					     "%s(): Duplicate packet is dropped!! IndicateSeq: %d, NewSeq: %d\n",
-					    __func__, pTS->RxIndicateSeq,
-					    SeqNum);
+				netdev_dbg(ieee->dev,
+					   "%s(): Duplicate packet is dropped. IndicateSeq: %d, NewSeq: %d\n",
+					   __func__, pTS->RxIndicateSeq,
+					   SeqNum);
 				list_add_tail(&pReorderEntry->List,
 					      &ieee->RxReorder_Unused_List); {
 					int i;
@@ -646,9 +651,9 @@ static void RxReorderIndicatePacket(struct rtllib_device *ieee,
 					prxb = NULL;
 				}
 			} else {
-				RTLLIB_DEBUG(RTLLIB_DL_REORDER,
-					 "Pkt insert into struct buffer!! IndicateSeq: %d, NewSeq: %d\n",
-					 pTS->RxIndicateSeq, SeqNum);
+				netdev_dbg(ieee->dev,
+					   "Pkt insert into struct buffer. IndicateSeq: %d, NewSeq: %d\n",
+					   pTS->RxIndicateSeq, SeqNum);
 			}
 		} else {
 			/* Packets are dropped if there are not enough reorder
@@ -672,7 +677,8 @@ static void RxReorderIndicatePacket(struct rtllib_device *ieee,
 
 	/* Check if there is any packet need indicate.*/
 	while (!list_empty(&pTS->RxPendingPktList)) {
-		RTLLIB_DEBUG(RTLLIB_DL_REORDER, "%s(): start RREORDER indicate\n", __func__);
+		netdev_dbg(ieee->dev, "%s(): start RREORDER indicate\n",
+			   __func__);
 
 		pReorderEntry = (struct rx_reorder_entry *)list_entry(pTS->RxPendingPktList.prev,
 				 struct rx_reorder_entry, List);
@@ -693,7 +699,8 @@ static void RxReorderIndicatePacket(struct rtllib_device *ieee,
 				pTS->RxIndicateSeq = (pTS->RxIndicateSeq + 1) % 4096;
 
 			ieee->prxbIndicateArray[index] = pReorderEntry->prxb;
-			RTLLIB_DEBUG(RTLLIB_DL_REORDER, "%s(): Indicate SeqNum %d!\n", __func__, pReorderEntry->SeqNum);
+			netdev_dbg(ieee->dev, "%s(): Indicate SeqNum %d!\n",
+				   __func__, pReorderEntry->SeqNum);
 			index++;
 
 			list_add_tail(&pReorderEntry->List,
@@ -725,8 +732,7 @@ static void RxReorderIndicatePacket(struct rtllib_device *ieee,
 	}
 
 	if (bPktInBuf && pTS->RxTimeoutIndicateSeq == 0xffff) {
-		RTLLIB_DEBUG(RTLLIB_DL_REORDER, "%s(): SET rx timeout timer\n",
-			     __func__);
+		netdev_dbg(ieee->dev, "%s(): SET rx timeout timer\n", __func__);
 		pTS->RxTimeoutIndicateSeq = pTS->RxIndicateSeq;
 		mod_timer(&pTS->RxPktPendingTimer, jiffies +
 			  msecs_to_jiffies(pHTInfo->RxReorderPendingTime));
@@ -1084,10 +1090,10 @@ static int rtllib_rx_decrypt(struct rtllib_device *ieee, struct sk_buff *skb,
 		netdev_dbg(ieee->dev, "Rx Fragment received (%u)\n", frag);
 
 		if (!frag_skb) {
-			RTLLIB_DEBUG(RTLLIB_DL_RX | RTLLIB_DL_FRAG,
-					"Rx cannot get skb from fragment cache (morefrag=%d seq=%u frag=%u)\n",
-					(fc & RTLLIB_FCTL_MOREFRAGS) != 0,
-					WLAN_GET_SEQ_SEQ(sc), frag);
+			netdev_dbg(ieee->dev,
+				   "Rx cannot get skb from fragment cache (morefrag=%d seq=%u frag=%u)\n",
+				   (fc & RTLLIB_FCTL_MOREFRAGS) != 0,
+				   WLAN_GET_SEQ_SEQ(sc), frag);
 			return -1;
 		}
 		flen = skb->len;

commit e9fea2ecb018e5ca4dad80ac36b34ba9c320415a
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Sun May 31 20:19:33 2015 +0200

    staging: rtl8192e: Remove RTLLIB_DEBUG_MGMT()
    
    - Use netdev_dbg() instead of RTLLIB_DEBUG_MGMT()
    - Remove RTLLIB_DEBUG_MGMT()
    - Pass net_device to auth_parse(), auth_rq_parse() and assoc_rq_parse()
    - Remove duplicated messages
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index 5a3593ba0ae7..f9863c40fd7f 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -1951,12 +1951,10 @@ static void rtllib_parse_mife_generic(struct rtllib_device *ieee,
 	    info_element->data[1] == 0x50 &&
 	    info_element->data[2] == 0xf2 &&
 	    info_element->data[3] == 0x04) {
-		RTLLIB_DEBUG_MGMT("MFIE_TYPE_WZC: %d bytes\n",
-				  info_element->len);
-		network->wzc_ie_len = min(info_element->len+2,
-					  MAX_WZC_IE_LEN);
-		memcpy(network->wzc_ie, info_element,
-		       network->wzc_ie_len);
+		netdev_dbg(ieee->dev, "MFIE_TYPE_WZC: %d bytes\n",
+			   info_element->len);
+		network->wzc_ie_len = min(info_element->len+2, MAX_WZC_IE_LEN);
+		memcpy(network->wzc_ie, info_element, network->wzc_ie_len);
 	}
 }
 
@@ -1975,10 +1973,10 @@ int rtllib_parse_info_param(struct rtllib_device *ieee,
 
 	while (length >= sizeof(*info_element)) {
 		if (sizeof(*info_element) + info_element->len > length) {
-			RTLLIB_DEBUG_MGMT("Info elem: parse failed: info_element->len + 2 > left : info_element->len+2=%zd left=%d, id=%d.\n",
-					     info_element->len +
-					     sizeof(*info_element),
-					     length, info_element->id);
+			netdev_dbg(ieee->dev,
+				   "Info elem: parse failed: info_element->len + 2 > left : info_element->len+2=%zd left=%d, id=%d.\n",
+				   info_element->len + sizeof(*info_element),
+				   length, info_element->id);
 			/* We stop processing but don't return an error here
 			 * because some misbehaviour APs break this rule. ie.
 			 * Orinoco AP1000.
@@ -2001,8 +1999,8 @@ int rtllib_parse_info_param(struct rtllib_device *ieee,
 				memset(network->ssid + network->ssid_len, 0,
 				       IW_ESSID_MAX_SIZE - network->ssid_len);
 
-			RTLLIB_DEBUG_MGMT("MFIE_TYPE_SSID: '%s' len=%d.\n",
-					     network->ssid, network->ssid_len);
+			netdev_dbg(ieee->dev, "MFIE_TYPE_SSID: '%s' len=%d.\n",
+				   network->ssid, network->ssid_len);
 			break;
 
 		case MFIE_TYPE_RATES:
@@ -2029,8 +2027,8 @@ int rtllib_parse_info_param(struct rtllib_device *ieee,
 				}
 			}
 
-			RTLLIB_DEBUG_MGMT("MFIE_TYPE_RATES: '%s' (%d)\n",
-					     rates_str, network->rates_len);
+			netdev_dbg(ieee->dev, "MFIE_TYPE_RATES: '%s' (%d)\n",
+				   rates_str, network->rates_len);
 			break;
 
 		case MFIE_TYPE_RATES_EX:
@@ -2052,22 +2050,22 @@ int rtllib_parse_info_param(struct rtllib_device *ieee,
 				}
 			}
 
-			RTLLIB_DEBUG_MGMT("MFIE_TYPE_RATES_EX: '%s' (%d)\n",
-					     rates_str, network->rates_ex_len);
+			netdev_dbg(ieee->dev, "MFIE_TYPE_RATES_EX: '%s' (%d)\n",
+				   rates_str, network->rates_ex_len);
 			break;
 
 		case MFIE_TYPE_DS_SET:
-			RTLLIB_DEBUG_MGMT("MFIE_TYPE_DS_SET: %d\n",
-					     info_element->data[0]);
+			netdev_dbg(ieee->dev, "MFIE_TYPE_DS_SET: %d\n",
+				   info_element->data[0]);
 			network->channel = info_element->data[0];
 			break;
 
 		case MFIE_TYPE_FH_SET:
-			RTLLIB_DEBUG_MGMT("MFIE_TYPE_FH_SET: ignored\n");
+			netdev_dbg(ieee->dev, "MFIE_TYPE_FH_SET: ignored\n");
 			break;
 
 		case MFIE_TYPE_CF_SET:
-			RTLLIB_DEBUG_MGMT("MFIE_TYPE_CF_SET: ignored\n");
+			netdev_dbg(ieee->dev, "MFIE_TYPE_CF_SET: ignored\n");
 			break;
 
 		case MFIE_TYPE_TIM:
@@ -2106,30 +2104,31 @@ int rtllib_parse_info_param(struct rtllib_device *ieee,
 		case MFIE_TYPE_ERP:
 			network->erp_value = info_element->data[0];
 			network->flags |= NETWORK_HAS_ERP_VALUE;
-			RTLLIB_DEBUG_MGMT("MFIE_TYPE_ERP_SET: %d\n",
-					     network->erp_value);
+			netdev_dbg(ieee->dev, "MFIE_TYPE_ERP_SET: %d\n",
+				   network->erp_value);
 			break;
 		case MFIE_TYPE_IBSS_SET:
 			network->atim_window = info_element->data[0];
-			RTLLIB_DEBUG_MGMT("MFIE_TYPE_IBSS_SET: %d\n",
-					     network->atim_window);
+			netdev_dbg(ieee->dev, "MFIE_TYPE_IBSS_SET: %d\n",
+				   network->atim_window);
 			break;
 
 		case MFIE_TYPE_CHALLENGE:
-			RTLLIB_DEBUG_MGMT("MFIE_TYPE_CHALLENGE: ignored\n");
+			netdev_dbg(ieee->dev, "MFIE_TYPE_CHALLENGE: ignored\n");
 			break;
 
 		case MFIE_TYPE_GENERIC:
-			RTLLIB_DEBUG_MGMT("MFIE_TYPE_GENERIC: %d bytes\n",
-					     info_element->len);
+			netdev_dbg(ieee->dev, "MFIE_TYPE_GENERIC: %d bytes\n",
+				   info_element->len);
+
 			rtllib_parse_mife_generic(ieee, info_element, network,
 						  &tmp_htcap_len,
 						  &tmp_htinfo_len);
 			break;
 
 		case MFIE_TYPE_RSN:
-			RTLLIB_DEBUG_MGMT("MFIE_TYPE_RSN: %d bytes\n",
-					     info_element->len);
+			netdev_dbg(ieee->dev, "MFIE_TYPE_RSN: %d bytes\n",
+				   info_element->len);
 			network->rsn_ie_len = min(info_element->len + 2,
 						  MAX_WPA_IE_LEN);
 			memcpy(network->rsn_ie, info_element,
@@ -2210,10 +2209,10 @@ int rtllib_parse_info_param(struct rtllib_device *ieee,
 			break;
 /* TODO */
 		default:
-			RTLLIB_DEBUG_MGMT
-			    ("Unsupported info element: %s (%d)\n",
-			     get_info_element_string(info_element->id),
-			     info_element->id);
+			netdev_dbg(ieee->dev,
+				   "Unsupported info element: %s (%d)\n",
+				   get_info_element_string(info_element->id),
+				   info_element->id);
 			break;
 		}
 
@@ -2672,8 +2671,8 @@ void rtllib_rx_mgt(struct rtllib_device *ieee,
 	switch (WLAN_FC_GET_STYPE(le16_to_cpu(header->frame_ctl))) {
 
 	case RTLLIB_STYPE_BEACON:
-		RTLLIB_DEBUG_MGMT("received BEACON (%d)\n",
-				  WLAN_FC_GET_STYPE(le16_to_cpu(header->frame_ctl)));
+		netdev_dbg(ieee->dev, "received BEACON (%d)\n",
+			   WLAN_FC_GET_STYPE(le16_to_cpu(header->frame_ctl)));
 		rtllib_process_probe_response(
 				ieee, (struct rtllib_probe_response *)header,
 				stats);
@@ -2686,15 +2685,14 @@ void rtllib_rx_mgt(struct rtllib_device *ieee,
 		break;
 
 	case RTLLIB_STYPE_PROBE_RESP:
-		RTLLIB_DEBUG_MGMT("received PROBE RESPONSE (%d)\n",
-			WLAN_FC_GET_STYPE(le16_to_cpu(header->frame_ctl)));
+		netdev_dbg(ieee->dev, "received PROBE RESPONSE (%d)\n",
+			   WLAN_FC_GET_STYPE(le16_to_cpu(header->frame_ctl)));
 		rtllib_process_probe_response(ieee,
 			      (struct rtllib_probe_response *)header, stats);
 		break;
 	case RTLLIB_STYPE_PROBE_REQ:
-		RTLLIB_DEBUG_MGMT("received PROBE RESQUEST (%d)\n",
-				  WLAN_FC_GET_STYPE(
-					  le16_to_cpu(header->frame_ctl)));
+		netdev_dbg(ieee->dev, "received PROBE RESQUEST (%d)\n",
+			   WLAN_FC_GET_STYPE(le16_to_cpu(header->frame_ctl)));
 		if ((ieee->softmac_features & IEEE_SOFTMAC_PROBERS) &&
 		    ((ieee->iw_mode == IW_MODE_ADHOC ||
 		    ieee->iw_mode == IW_MODE_MASTER) &&

commit 8f90dfbf649b53152654562b89074b11c8f4fe7d
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Sun May 31 20:19:32 2015 +0200

    staging: rtl8192e: Remove RTLLIB_DEBUG_QOS()
    
    - Pass extra argument (rtllib_device) to rtllib_parse_qos_info_param_IE()
      and update_network()
    - Replace RTLLIB_DEBUG_QOS() with netdev_dbg()
    - Remove RTLLIB_DEBUG_QOS()
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index 8ea3e2fa5042..5a3593ba0ae7 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -1657,9 +1657,10 @@ static int rtllib_qos_convert_ac_to_parameters(struct rtllib_qos_parameter_info
  * parameters element. check the information element length to decide
  * which type to read
  */
-static int rtllib_parse_qos_info_param_IE(struct rtllib_info_element
+static int rtllib_parse_qos_info_param_IE(struct rtllib_device *ieee,
+					  struct rtllib_info_element
 					     *info_element,
-					     struct rtllib_network *network)
+					  struct rtllib_network *network)
 {
 	int rc = 0;
 	struct rtllib_qos_information_element qos_info_element;
@@ -1684,7 +1685,7 @@ static int rtllib_parse_qos_info_param_IE(struct rtllib_info_element
 	}
 
 	if (rc == 0) {
-		RTLLIB_DEBUG_QOS("QoS is supported\n");
+		netdev_dbg(ieee->dev, "QoS is supported\n");
 		network->qos_data.supported = 1;
 	}
 	return rc;
@@ -1761,7 +1762,7 @@ static void rtllib_parse_mife_generic(struct rtllib_device *ieee,
 	u16 ht_realtek_agg_len = 0;
 	u8  ht_realtek_agg_buf[MAX_IE_LEN];
 
-	if (!rtllib_parse_qos_info_param_IE(info_element, network))
+	if (!rtllib_parse_qos_info_param_IE(ieee, info_element, network))
 		return;
 	if (info_element->len >= 4 &&
 	    info_element->data[0] == 0x00 &&
@@ -2352,7 +2353,8 @@ static inline int is_same_network(struct rtllib_network *src,
 }
 
 
-static inline void update_network(struct rtllib_network *dst,
+static inline void update_network(struct rtllib_device *ieee,
+				  struct rtllib_network *dst,
 				  struct rtllib_network *src)
 {
 	int qos_active;
@@ -2426,12 +2428,12 @@ static inline void update_network(struct rtllib_network *dst,
 		       sizeof(struct rtllib_qos_data));
 	if (dst->qos_data.supported == 1) {
 		if (dst->ssid_len)
-			RTLLIB_DEBUG_QOS
-				("QoS the network %s is QoS supported\n",
-				dst->ssid);
+			netdev_dbg(ieee->dev,
+				   "QoS the network %s is QoS supported\n",
+				   dst->ssid);
 		else
-			RTLLIB_DEBUG_QOS
-				("QoS the network is QoS supported\n");
+			netdev_dbg(ieee->dev,
+				   "QoS the network is QoS supported\n");
 	}
 	dst->qos_data.active = qos_active;
 	dst->qos_data.old_param_count = old_param;
@@ -2567,7 +2569,7 @@ static inline void rtllib_process_probe_response(
 	spin_lock_irqsave(&ieee->lock, flags);
 	if (is_same_network(&ieee->current_network, network,
 	   (network->ssid_len ? 1 : 0))) {
-		update_network(&ieee->current_network, network);
+		update_network(ieee, &ieee->current_network, network);
 		if ((ieee->current_network.mode == IEEE_N_24G ||
 		     ieee->current_network.mode == IEEE_G)
 		     && ieee->current_network.berp_info_valid) {
@@ -2637,7 +2639,7 @@ static inline void rtllib_process_probe_response(
 		    network->ssid_len) == 0) &&
 		    (ieee->state == RTLLIB_NOLINK))))
 			renew = 1;
-		update_network(target, network);
+		update_network(ieee, target, network);
 		if (renew && (ieee->softmac_features & IEEE_SOFTMAC_ASSOCIATE))
 			rtllib_softmac_new_net(ieee, network);
 	}

commit e77c752f3917c4d3cec864e3354c0a64fdeba03e
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Sun May 31 20:19:31 2015 +0200

    staging: rtl8192e: Remove RTLLIB_DEBUG_(FRAG|EAP|DROP|STATE|TX|RX)()
    
    Use netdev_dbg() instead.
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index a6dde350fc9b..8ea3e2fa5042 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -69,9 +69,9 @@ rtllib_frag_cache_find(struct rtllib_device *ieee, unsigned int seq,
 		entry = &ieee->frag_cache[tid][i];
 		if (entry->skb != NULL &&
 		    time_after(jiffies, entry->first_frag_time + 2 * HZ)) {
-			RTLLIB_DEBUG_FRAG(
-				"expiring fragment cache entry seq=%u last_frag=%u\n",
-				entry->seq, entry->last_frag);
+			netdev_dbg(ieee->dev,
+				   "expiring fragment cache entry seq=%u last_frag=%u\n",
+				   entry->seq, entry->last_frag);
 			dev_kfree_skb_any(entry->skb);
 			entry->skb = NULL;
 		}
@@ -187,8 +187,9 @@ static int rtllib_frag_cache_invalidate(struct rtllib_device *ieee,
 					  hdr->addr1);
 
 	if (entry == NULL) {
-		RTLLIB_DEBUG_FRAG(
-			"could not invalidate fragment cache entry (seq=%u)\n", seq);
+		netdev_dbg(ieee->dev,
+			   "Couldn't invalidate fragment cache entry (seq=%u)\n",
+			   seq);
 		return -1;
 	}
 
@@ -305,11 +306,12 @@ rtllib_rx_frame_decrypt(struct rtllib_device *ieee, struct sk_buff *skb,
 	res = crypt->ops->decrypt_mpdu(skb, hdrlen, crypt->priv);
 	atomic_dec(&crypt->refcnt);
 	if (res < 0) {
-		RTLLIB_DEBUG_DROP(
-			"decryption failed (SA= %pM) res=%d\n", hdr->addr2, res);
+		netdev_dbg(ieee->dev, "decryption failed (SA= %pM) res=%d\n",
+			   hdr->addr2, res);
 		if (res == -2)
-			RTLLIB_DEBUG_DROP("Decryption failed ICV mismatch (key %d)\n",
-					     skb->data[hdrlen + 3] >> 6);
+			netdev_dbg(ieee->dev,
+				   "Decryption failed ICV mismatch (key %d)\n",
+				   skb->data[hdrlen + 3] >> 6);
 		ieee->ieee_stats.rx_discards_undecryptable++;
 		return -1;
 	}
@@ -840,7 +842,8 @@ static u8 parse_subframe(struct rtllib_device *ieee, struct sk_buff *skb,
 		sub_skb->dev = ieee->dev;
 		rxb->subframes[rxb->nr_subframes++] = sub_skb;
 		if (rxb->nr_subframes >= MAX_SUBFRAME_COUNT) {
-			RTLLIB_DEBUG_RX("ParseSubframe(): Too many Subframes! Packets dropped!\n");
+			netdev_dbg(ieee->dev,
+				   "ParseSubframe(): Too many Subframes! Packets dropped!\n");
 			break;
 		}
 		skb_pull(skb, nSubframe_Length);
@@ -991,9 +994,9 @@ static int rtllib_rx_data_filter(struct rtllib_device *ieee, u16 fc,
 		    stype != RTLLIB_STYPE_DATA_CFACKPOLL &&
 		    stype != RTLLIB_STYPE_QOS_DATA) {
 			if (stype != RTLLIB_STYPE_NULLFUNC)
-				RTLLIB_DEBUG_DROP(
-					"RX: dropped data frame with no data (type=0x%02x, subtype=0x%02x)\n",
-					type, stype);
+				netdev_dbg(ieee->dev,
+					   "RX: dropped data frame with no data (type=0x%02x, subtype=0x%02x)\n",
+					   type, stype);
 			return -1;
 		}
 	}
@@ -1037,8 +1040,9 @@ static int rtllib_rx_get_crypt(struct rtllib_device *ieee, struct sk_buff *skb,
 			 * frames silently instead of filling system log with
 			 * these reports.
 			 */
-			RTLLIB_DEBUG_DROP("Decryption failed (not set) (SA= %pM)\n",
-					     hdr->addr2);
+			netdev_dbg(ieee->dev,
+				   "Decryption failed (not set) (SA= %pM)\n",
+				   hdr->addr2);
 			ieee->ieee_stats.rx_discards_undecryptable++;
 			return -1;
 		}
@@ -1077,7 +1081,7 @@ static int rtllib_rx_decrypt(struct rtllib_device *ieee, struct sk_buff *skb,
 		int flen;
 		struct sk_buff *frag_skb = rtllib_frag_cache_get(ieee, hdr);
 
-		RTLLIB_DEBUG_FRAG("Rx Fragment received (%u)\n", frag);
+		netdev_dbg(ieee->dev, "Rx Fragment received (%u)\n", frag);
 
 		if (!frag_skb) {
 			RTLLIB_DEBUG(RTLLIB_DL_RX | RTLLIB_DL_FRAG,
@@ -1148,12 +1152,13 @@ static int rtllib_rx_decrypt(struct rtllib_device *ieee, struct sk_buff *skb,
 			 */
 			struct eapol *eap = (struct eapol *)(skb->data +
 				24);
-			RTLLIB_DEBUG_EAP("RX: IEEE 802.1X EAPOL frame: %s\n",
-						eap_get_type(eap->type));
+			netdev_dbg(ieee->dev,
+				   "RX: IEEE 802.1X EAPOL frame: %s\n",
+				   eap_get_type(eap->type));
 		} else {
-			RTLLIB_DEBUG_DROP(
-				"encryption configured, but RX frame not encrypted (SA= %pM)\n",
-				hdr->addr2);
+			netdev_dbg(ieee->dev,
+				   "encryption configured, but RX frame not encrypted (SA= %pM)\n",
+				   hdr->addr2);
 			return -1;
 		}
 	}
@@ -1162,15 +1167,16 @@ static int rtllib_rx_decrypt(struct rtllib_device *ieee, struct sk_buff *skb,
 	    rtllib_is_eapol_frame(ieee, skb, hdrlen)) {
 			struct eapol *eap = (struct eapol *)(skb->data +
 				24);
-			RTLLIB_DEBUG_EAP("RX: IEEE 802.1X EAPOL frame: %s\n",
-						eap_get_type(eap->type));
+			netdev_dbg(ieee->dev,
+				   "RX: IEEE 802.1X EAPOL frame: %s\n",
+				   eap_get_type(eap->type));
 	}
 
 	if (crypt && !(fc & RTLLIB_FCTL_WEP) && !ieee->open_wep &&
 	    !rtllib_is_eapol_frame(ieee, skb, hdrlen)) {
-		RTLLIB_DEBUG_DROP(
-			"dropped unencrypted RX data frame from %pM (drop_unencrypted=1)\n",
-			hdr->addr2);
+		netdev_dbg(ieee->dev,
+			   "dropped unencrypted RX data frame from %pM (drop_unencrypted=1)\n",
+			   hdr->addr2);
 		return -1;
 	}
 

commit 521a9cbdb27142d7b9a166810807af010dcf6181
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Sun May 31 20:19:30 2015 +0200

    staging: rtl8192e: Remove RTLLIB_DEBUG_SCAN()
    
    Use netdev_dbg() instead, remove duplicated logs.
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index 304404d3474d..a6dde350fc9b 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -2130,8 +2130,8 @@ int rtllib_parse_info_param(struct rtllib_device *ieee,
 			break;
 
 		case MFIE_TYPE_HT_CAP:
-			RTLLIB_DEBUG_SCAN("MFIE_TYPE_HT_CAP: %d bytes\n",
-					     info_element->len);
+			netdev_dbg(ieee->dev, "MFIE_TYPE_HT_CAP: %d bytes\n",
+				   info_element->len);
 			tmp_htcap_len = min_t(u8, info_element->len, MAX_IE_LEN);
 			if (tmp_htcap_len != 0) {
 				network->bssht.bdHTSpecVer = HT_SPEC_VER_EWC;
@@ -2157,8 +2157,8 @@ int rtllib_parse_info_param(struct rtllib_device *ieee,
 
 
 		case MFIE_TYPE_HT_INFO:
-			RTLLIB_DEBUG_SCAN("MFIE_TYPE_HT_INFO: %d bytes\n",
-					     info_element->len);
+			netdev_dbg(ieee->dev, "MFIE_TYPE_HT_INFO: %d bytes\n",
+				   info_element->len);
 			tmp_htinfo_len = min_t(u8, info_element->len, MAX_IE_LEN);
 			if (tmp_htinfo_len) {
 				network->bssht.bdHTSpecVer = HT_SPEC_VER_IEEE;
@@ -2173,8 +2173,8 @@ int rtllib_parse_info_param(struct rtllib_device *ieee,
 			break;
 
 		case MFIE_TYPE_AIRONET:
-			RTLLIB_DEBUG_SCAN("MFIE_TYPE_AIRONET: %d bytes\n",
-					     info_element->len);
+			netdev_dbg(ieee->dev, "MFIE_TYPE_AIRONET: %d bytes\n",
+				   info_element->len);
 			if (info_element->len > IE_CISCO_FLAG_POSITION) {
 				network->bWithAironetIE = true;
 
@@ -2196,8 +2196,8 @@ int rtllib_parse_info_param(struct rtllib_device *ieee,
 			break;
 
 		case MFIE_TYPE_COUNTRY:
-			RTLLIB_DEBUG_SCAN("MFIE_TYPE_COUNTRY: %d bytes\n",
-					     info_element->len);
+			netdev_dbg(ieee->dev, "MFIE_TYPE_COUNTRY: %d bytes\n",
+				   info_element->len);
 			rtllib_extract_country_ie(ieee, info_element, network,
 						  network->bssid);
 			break;
@@ -2304,10 +2304,9 @@ static inline int rtllib_network_init(
 	}
 
 	if (network->mode == 0) {
-		RTLLIB_DEBUG_SCAN("Filtered out '%s (%pM)' network.\n",
-				     escape_essid(network->ssid,
-						  network->ssid_len),
-				     network->bssid);
+		netdev_dbg(ieee->dev, "Filtered out '%s (%pM)' network.\n",
+			   escape_essid(network->ssid, network->ssid_len),
+			   network->bssid);
 		return 1;
 	}
 
@@ -2505,33 +2504,32 @@ static inline void rtllib_process_probe_response(
 	if (!network)
 		return;
 
-	RTLLIB_DEBUG_SCAN(
-		"'%s' ( %pM ): %c%c%c%c %c%c%c%c-%c%c%c%c %c%c%c%c\n",
-		escape_essid(info_element->data, info_element->len),
-		beacon->header.addr3,
-		(le16_to_cpu(beacon->capability) & (1<<0xf)) ? '1' : '0',
-		(le16_to_cpu(beacon->capability) & (1<<0xe)) ? '1' : '0',
-		(le16_to_cpu(beacon->capability) & (1<<0xd)) ? '1' : '0',
-		(le16_to_cpu(beacon->capability) & (1<<0xc)) ? '1' : '0',
-		(le16_to_cpu(beacon->capability) & (1<<0xb)) ? '1' : '0',
-		(le16_to_cpu(beacon->capability) & (1<<0xa)) ? '1' : '0',
-		(le16_to_cpu(beacon->capability) & (1<<0x9)) ? '1' : '0',
-		(le16_to_cpu(beacon->capability) & (1<<0x8)) ? '1' : '0',
-		(le16_to_cpu(beacon->capability) & (1<<0x7)) ? '1' : '0',
-		(le16_to_cpu(beacon->capability) & (1<<0x6)) ? '1' : '0',
-		(le16_to_cpu(beacon->capability) & (1<<0x5)) ? '1' : '0',
-		(le16_to_cpu(beacon->capability) & (1<<0x4)) ? '1' : '0',
-		(le16_to_cpu(beacon->capability) & (1<<0x3)) ? '1' : '0',
-		(le16_to_cpu(beacon->capability) & (1<<0x2)) ? '1' : '0',
-		(le16_to_cpu(beacon->capability) & (1<<0x1)) ? '1' : '0',
-		(le16_to_cpu(beacon->capability) & (1<<0x0)) ? '1' : '0');
+	netdev_dbg(ieee->dev,
+		   "'%s' ( %pM ): %c%c%c%c %c%c%c%c-%c%c%c%c %c%c%c%c\n",
+		   escape_essid(info_element->data, info_element->len),
+		   beacon->header.addr3,
+		   (le16_to_cpu(beacon->capability) & (1<<0xf)) ? '1' : '0',
+		   (le16_to_cpu(beacon->capability) & (1<<0xe)) ? '1' : '0',
+		   (le16_to_cpu(beacon->capability) & (1<<0xd)) ? '1' : '0',
+		   (le16_to_cpu(beacon->capability) & (1<<0xc)) ? '1' : '0',
+		   (le16_to_cpu(beacon->capability) & (1<<0xb)) ? '1' : '0',
+		   (le16_to_cpu(beacon->capability) & (1<<0xa)) ? '1' : '0',
+		   (le16_to_cpu(beacon->capability) & (1<<0x9)) ? '1' : '0',
+		   (le16_to_cpu(beacon->capability) & (1<<0x8)) ? '1' : '0',
+		   (le16_to_cpu(beacon->capability) & (1<<0x7)) ? '1' : '0',
+		   (le16_to_cpu(beacon->capability) & (1<<0x6)) ? '1' : '0',
+		   (le16_to_cpu(beacon->capability) & (1<<0x5)) ? '1' : '0',
+		   (le16_to_cpu(beacon->capability) & (1<<0x4)) ? '1' : '0',
+		   (le16_to_cpu(beacon->capability) & (1<<0x3)) ? '1' : '0',
+		   (le16_to_cpu(beacon->capability) & (1<<0x2)) ? '1' : '0',
+		   (le16_to_cpu(beacon->capability) & (1<<0x1)) ? '1' : '0',
+		   (le16_to_cpu(beacon->capability) & (1<<0x0)) ? '1' : '0');
 
 	if (rtllib_network_init(ieee, beacon, network, stats)) {
-		RTLLIB_DEBUG_SCAN("Dropped '%s' ( %pM) via %s.\n",
-				  escape_essid(info_element->data,
-				  info_element->len), beacon->header.addr3,
-				  is_beacon(frame_ctl) ? "BEACON" :
-							 "PROBE RESPONSE");
+		netdev_dbg(ieee->dev, "Dropped '%s' ( %pM) via %s.\n",
+			   escape_essid(info_element->data, info_element->len),
+			   beacon->header.addr3,
+			   is_beacon(frame_ctl) ? "BEACON" : "PROBE RESPONSE");
 		goto free_network;
 	}
 
@@ -2594,10 +2592,10 @@ static inline void rtllib_process_probe_response(
 			/* If there are no more slots, expire the oldest */
 			list_del(&oldest->list);
 			target = oldest;
-			RTLLIB_DEBUG_SCAN("Expired '%s' ( %pM) from network list.\n",
-					     escape_essid(target->ssid,
-							  target->ssid_len),
-					     target->bssid);
+			netdev_dbg(ieee->dev,
+				   "Expired '%s' ( %pM) from network list.\n",
+				   escape_essid(target->ssid, target->ssid_len),
+				   target->bssid);
 		} else {
 			/* Otherwise just pull from the free list */
 			target = list_entry(ieee->network_free_list.next,
@@ -2605,22 +2603,20 @@ static inline void rtllib_process_probe_response(
 			list_del(ieee->network_free_list.next);
 		}
 
+		netdev_dbg(ieee->dev, "Adding '%s' ( %pM) via %s.\n",
+			   escape_essid(network->ssid, network->ssid_len),
+			   network->bssid,
+			   is_beacon(frame_ctl) ? "BEACON" : "PROBE RESPONSE");
 
-		RTLLIB_DEBUG_SCAN("Adding '%s' ( %pM) via %s.\n",
-				  escape_essid(network->ssid,
-				  network->ssid_len), network->bssid,
-				  is_beacon(frame_ctl) ? "BEACON" :
-							 "PROBE RESPONSE");
 		memcpy(target, network, sizeof(*target));
 		list_add_tail(&target->list, &ieee->network_list);
 		if (ieee->softmac_features & IEEE_SOFTMAC_ASSOCIATE)
 			rtllib_softmac_new_net(ieee, network);
 	} else {
-		RTLLIB_DEBUG_SCAN("Updating '%s' ( %pM) via %s.\n",
-				  escape_essid(target->ssid, target->ssid_len),
-				  target->bssid,
-				  is_beacon(frame_ctl) ? "BEACON" :
-							 "PROBE RESPONSE");
+		netdev_dbg(ieee->dev, "Updating '%s' ( %pM) via %s.\n",
+			   escape_essid(target->ssid, target->ssid_len),
+			   target->bssid,
+			   is_beacon(frame_ctl) ? "BEACON" : "PROBE RESPONSE");
 
 		/* we have an entry and we are going to update it. But this
 		 *  entry may be already expired. In this case we do the same
@@ -2670,7 +2666,6 @@ void rtllib_rx_mgt(struct rtllib_device *ieee,
 	case RTLLIB_STYPE_BEACON:
 		RTLLIB_DEBUG_MGMT("received BEACON (%d)\n",
 				  WLAN_FC_GET_STYPE(le16_to_cpu(header->frame_ctl)));
-		RTLLIB_DEBUG_SCAN("Beacon\n");
 		rtllib_process_probe_response(
 				ieee, (struct rtllib_probe_response *)header,
 				stats);
@@ -2685,7 +2680,6 @@ void rtllib_rx_mgt(struct rtllib_device *ieee,
 	case RTLLIB_STYPE_PROBE_RESP:
 		RTLLIB_DEBUG_MGMT("received PROBE RESPONSE (%d)\n",
 			WLAN_FC_GET_STYPE(le16_to_cpu(header->frame_ctl)));
-		RTLLIB_DEBUG_SCAN("Probe response\n");
 		rtllib_process_probe_response(ieee,
 			      (struct rtllib_probe_response *)header, stats);
 		break;
@@ -2693,7 +2687,6 @@ void rtllib_rx_mgt(struct rtllib_device *ieee,
 		RTLLIB_DEBUG_MGMT("received PROBE RESQUEST (%d)\n",
 				  WLAN_FC_GET_STYPE(
 					  le16_to_cpu(header->frame_ctl)));
-		RTLLIB_DEBUG_SCAN("Probe request\n");
 		if ((ieee->softmac_features & IEEE_SOFTMAC_PROBERS) &&
 		    ((ieee->iw_mode == IW_MODE_ADHOC ||
 		    ieee->iw_mode == IW_MODE_MASTER) &&

commit ad5c8e0586bfda28b086472e3336903ca1e4d3d2
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Sun May 31 20:19:29 2015 +0200

    staging: rtl8192e: Simplify rtllib_process_probe_response()
    
    - Extract frame_ctl once and use it as variable.
    - Drop endian conversion in is_beacon() function
      (used in simplified function only)
    - Simplify debug messages
    - Invert STYPE checks in debug messages - it is valid
      as only BEACON and PROBE_RESP are allowed
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index 3dc05831d3ec..304404d3474d 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -2457,9 +2457,9 @@ static inline void update_network(struct rtllib_network *dst,
 	dst->BssCcxVerNumber = src->BssCcxVerNumber;
 }
 
-static inline int is_beacon(__le16 fc)
+static inline int is_beacon(u16 fc)
 {
-	return (WLAN_FC_GET_STYPE(le16_to_cpu(fc)) == RTLLIB_STYPE_BEACON);
+	return (WLAN_FC_GET_STYPE(fc) == RTLLIB_STYPE_BEACON);
 }
 
 static int IsPassiveChannel(struct rtllib_device *rtllib, u8 channel)
@@ -2500,6 +2500,7 @@ static inline void rtllib_process_probe_response(
 	short renew;
 	struct rtllib_network *network = kzalloc(sizeof(struct rtllib_network),
 						 GFP_ATOMIC);
+	u16 frame_ctl = le16_to_cpu(beacon->header.frame_ctl);
 
 	if (!network)
 		return;
@@ -2528,12 +2529,9 @@ static inline void rtllib_process_probe_response(
 	if (rtllib_network_init(ieee, beacon, network, stats)) {
 		RTLLIB_DEBUG_SCAN("Dropped '%s' ( %pM) via %s.\n",
 				  escape_essid(info_element->data,
-				  info_element->len),
-				  beacon->header.addr3,
-				  WLAN_FC_GET_STYPE(
-					  le16_to_cpu(beacon->header.frame_ctl)) ==
-				  RTLLIB_STYPE_PROBE_RESP ?
-				  "PROBE RESPONSE" : "BEACON");
+				  info_element->len), beacon->header.addr3,
+				  is_beacon(frame_ctl) ? "BEACON" :
+							 "PROBE RESPONSE");
 		goto free_network;
 	}
 
@@ -2541,8 +2539,7 @@ static inline void rtllib_process_probe_response(
 	if (!rtllib_legal_channel(ieee, network->channel))
 		goto free_network;
 
-	if (WLAN_FC_GET_STYPE(le16_to_cpu(beacon->header.frame_ctl)) ==
-	    RTLLIB_STYPE_PROBE_RESP) {
+	if (WLAN_FC_GET_STYPE(frame_ctl) == RTLLIB_STYPE_PROBE_RESP) {
 		if (IsPassiveChannel(ieee, network->channel)) {
 			netdev_info(ieee->dev,
 				    "GetScanInfo(): For Global Domain, filter probe response at channel(%d).\n",
@@ -2575,7 +2572,7 @@ static inline void rtllib_process_probe_response(
 			else
 				ieee->current_network.buseprotection = false;
 		}
-		if (is_beacon(beacon->header.frame_ctl)) {
+		if (is_beacon(frame_ctl)) {
 			if (ieee->state >= RTLLIB_LINKED)
 				ieee->LinkDetectInfo.NumRecvBcnInPeriod++;
 		}
@@ -2612,22 +2609,18 @@ static inline void rtllib_process_probe_response(
 		RTLLIB_DEBUG_SCAN("Adding '%s' ( %pM) via %s.\n",
 				  escape_essid(network->ssid,
 				  network->ssid_len), network->bssid,
-				  WLAN_FC_GET_STYPE(
-					  le16_to_cpu(beacon->header.frame_ctl)) ==
-				  RTLLIB_STYPE_PROBE_RESP ?
-				  "PROBE RESPONSE" : "BEACON");
+				  is_beacon(frame_ctl) ? "BEACON" :
+							 "PROBE RESPONSE");
 		memcpy(target, network, sizeof(*target));
 		list_add_tail(&target->list, &ieee->network_list);
 		if (ieee->softmac_features & IEEE_SOFTMAC_ASSOCIATE)
 			rtllib_softmac_new_net(ieee, network);
 	} else {
 		RTLLIB_DEBUG_SCAN("Updating '%s' ( %pM) via %s.\n",
-				  escape_essid(target->ssid,
-				  target->ssid_len), target->bssid,
-				  WLAN_FC_GET_STYPE(
-					  le16_to_cpu(beacon->header.frame_ctl)) ==
-				  RTLLIB_STYPE_PROBE_RESP ?
-				  "PROBE RESPONSE" : "BEACON");
+				  escape_essid(target->ssid, target->ssid_len),
+				  target->bssid,
+				  is_beacon(frame_ctl) ? "BEACON" :
+							 "PROBE RESPONSE");
 
 		/* we have an entry and we are going to update it. But this
 		 *  entry may be already expired. In this case we do the same
@@ -2648,7 +2641,7 @@ static inline void rtllib_process_probe_response(
 	}
 
 	spin_unlock_irqrestore(&ieee->lock, flags);
-	if (is_beacon(beacon->header.frame_ctl) &&
+	if (is_beacon(frame_ctl) &&
 	    is_same_network(&ieee->current_network, network,
 	    (network->ssid_len ? 1 : 0)) &&
 	    (ieee->state == RTLLIB_LINKED)) {

commit 11e672c3e2d2a10189a6292678f5174597927076
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Sun May 31 20:19:26 2015 +0200

    staging: rtl8192e: Replace RTLLIB_DEBUG(DL_ERR) with netdev_*()
    
    Replace all RTLLIB_DEBUG(RTLLIB_DL_ERR, *) calls with netdev_err()
    for errors that really should be reported to user.
    Use netdev_warn() for the rest.
    Rephrase some of the messages to make them more readable/compact.
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index f8f192041d98..3dc05831d3ec 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -654,7 +654,9 @@ static void RxReorderIndicatePacket(struct rtllib_device *ieee,
 			 * indicate all the packets in struct buffer and get
 			 * reorder entries.
 			 */
-			RTLLIB_DEBUG(RTLLIB_DL_ERR, "RxReorderIndicatePacket(): There is no reorder entry!! Packet is dropped!!\n");
+			netdev_err(ieee->dev,
+				   "%s(): There is no reorder entry! Packet is dropped!\n",
+				   __func__);
 			{
 				int i;
 
@@ -676,7 +678,9 @@ static void RxReorderIndicatePacket(struct rtllib_device *ieee,
 				SN_EQUAL(pReorderEntry->SeqNum, pTS->RxIndicateSeq)) {
 			/* This protect struct buffer from overflow. */
 			if (index >= REORDER_WIN_SIZE) {
-				RTLLIB_DEBUG(RTLLIB_DL_ERR, "RxReorderIndicatePacket(): Buffer overflow!!\n");
+				netdev_err(ieee->dev,
+					   "%s(): Buffer overflow!\n",
+					   __func__);
 				bPktInBuf = true;
 				break;
 			}
@@ -707,7 +711,9 @@ static void RxReorderIndicatePacket(struct rtllib_device *ieee,
 		pTS->RxTimeoutIndicateSeq = 0xffff;
 
 		if (index > REORDER_WIN_SIZE) {
-			RTLLIB_DEBUG(RTLLIB_DL_ERR, "RxReorderIndicatePacket(): Rx Reorder struct buffer full!!\n");
+			netdev_err(ieee->dev,
+				   "%s(): Rx Reorder struct buffer full!\n",
+				   __func__);
 			spin_unlock_irqrestore(&(ieee->reorder_spinlock),
 					       flags);
 			return;
@@ -911,7 +917,8 @@ static int rtllib_rx_check_duplicate(struct rtllib_device *ieee,
 			pRxTS->RxLastFragNum = frag;
 			pRxTS->RxLastSeqNum = WLAN_GET_SEQ_SEQ(sc);
 		} else {
-			RTLLIB_DEBUG(RTLLIB_DL_ERR, "ERR!!%s(): No TS!! Skip the check!!\n", __func__);
+			netdev_warn(ieee->dev, "%s(): No TS! Skip the check!\n",
+				    __func__);
 			return -1;
 		}
 	}

commit 80d2579d8608f5f7642776d8dc5c050a087f9d69
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Sun May 31 20:19:23 2015 +0200

    staging: rtl8192e: Fix DEEP_INDENTATION warning in rtllib_parse_info_param()
    
    Move MFIE_TYPE_GENERIC handler to rtllib_parse_mife_generic() function.
    Code was not altered significantly, therefore in some places it generates
    LONG_LINE checkpatch.pl warnings.
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index bde80c8fa8d5..f8f192041d98 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -1739,6 +1739,213 @@ static inline void rtllib_extract_country_ie(
 
 }
 
+static void rtllib_parse_mife_generic(struct rtllib_device *ieee,
+				      struct rtllib_info_element *info_element,
+				      struct rtllib_network *network,
+				      u16 *tmp_htcap_len,
+				      u16 *tmp_htinfo_len)
+{
+	u16 ht_realtek_agg_len = 0;
+	u8  ht_realtek_agg_buf[MAX_IE_LEN];
+
+	if (!rtllib_parse_qos_info_param_IE(info_element, network))
+		return;
+	if (info_element->len >= 4 &&
+	    info_element->data[0] == 0x00 &&
+	    info_element->data[1] == 0x50 &&
+	    info_element->data[2] == 0xf2 &&
+	    info_element->data[3] == 0x01) {
+		network->wpa_ie_len = min(info_element->len + 2,
+					  MAX_WPA_IE_LEN);
+		memcpy(network->wpa_ie, info_element, network->wpa_ie_len);
+		return;
+	}
+	if (info_element->len == 7 &&
+	    info_element->data[0] == 0x00 &&
+	    info_element->data[1] == 0xe0 &&
+	    info_element->data[2] == 0x4c &&
+	    info_element->data[3] == 0x01 &&
+	    info_element->data[4] == 0x02)
+		network->Turbo_Enable = 1;
+
+	if (*tmp_htcap_len == 0) {
+		if (info_element->len >= 4 &&
+		   info_element->data[0] == 0x00 &&
+		   info_element->data[1] == 0x90 &&
+		   info_element->data[2] == 0x4c &&
+		   info_element->data[3] == 0x033) {
+
+			*tmp_htcap_len = min_t(u8, info_element->len,
+					       MAX_IE_LEN);
+			if (*tmp_htcap_len != 0) {
+				network->bssht.bdHTSpecVer = HT_SPEC_VER_EWC;
+				network->bssht.bdHTCapLen = min_t(u16, *tmp_htcap_len, sizeof(network->bssht.bdHTCapBuf));
+				memcpy(network->bssht.bdHTCapBuf,
+				       info_element->data,
+				       network->bssht.bdHTCapLen);
+			}
+		}
+		if (*tmp_htcap_len != 0) {
+			network->bssht.bdSupportHT = true;
+			network->bssht.bdHT1R = ((((struct ht_capab_ele *)(network->bssht.bdHTCapBuf))->MCS[1]) == 0);
+		} else {
+			network->bssht.bdSupportHT = false;
+			network->bssht.bdHT1R = false;
+		}
+	}
+
+
+	if (*tmp_htinfo_len == 0) {
+		if (info_element->len >= 4 &&
+		    info_element->data[0] == 0x00 &&
+		    info_element->data[1] == 0x90 &&
+		    info_element->data[2] == 0x4c &&
+		    info_element->data[3] == 0x034) {
+			*tmp_htinfo_len = min_t(u8, info_element->len,
+						MAX_IE_LEN);
+			if (*tmp_htinfo_len != 0) {
+				network->bssht.bdHTSpecVer = HT_SPEC_VER_EWC;
+				network->bssht.bdHTInfoLen = min_t(u16, *tmp_htinfo_len, sizeof(network->bssht.bdHTInfoBuf));
+				memcpy(network->bssht.bdHTInfoBuf,
+				       info_element->data,
+				       network->bssht.bdHTInfoLen);
+			}
+
+		}
+	}
+
+	if (ieee->aggregation) {
+		if (network->bssht.bdSupportHT) {
+			if (info_element->len >= 4 &&
+			    info_element->data[0] == 0x00 &&
+			    info_element->data[1] == 0xe0 &&
+			    info_element->data[2] == 0x4c &&
+			    info_element->data[3] == 0x02) {
+				ht_realtek_agg_len = min_t(u8,
+							   info_element->len,
+							   MAX_IE_LEN);
+				memcpy(ht_realtek_agg_buf,
+				       info_element->data,
+				       info_element->len);
+			}
+			if (ht_realtek_agg_len >= 5) {
+				network->realtek_cap_exit = true;
+				network->bssht.bdRT2RTAggregation = true;
+
+				if ((ht_realtek_agg_buf[4] == 1) &&
+				    (ht_realtek_agg_buf[5] & 0x02))
+					network->bssht.bdRT2RTLongSlotTime = true;
+
+				if ((ht_realtek_agg_buf[4] == 1) &&
+				    (ht_realtek_agg_buf[5] & RT_HT_CAP_USE_92SE))
+					network->bssht.RT2RT_HT_Mode |= RT_HT_CAP_USE_92SE;
+			}
+		}
+		if (ht_realtek_agg_len >= 5) {
+			if ((ht_realtek_agg_buf[5] & RT_HT_CAP_USE_SOFTAP))
+				network->bssht.RT2RT_HT_Mode |= RT_HT_CAP_USE_SOFTAP;
+		}
+	}
+
+	if ((info_element->len >= 3 &&
+	     info_element->data[0] == 0x00 &&
+	     info_element->data[1] == 0x05 &&
+	     info_element->data[2] == 0xb5) ||
+	     (info_element->len >= 3 &&
+	     info_element->data[0] == 0x00 &&
+	     info_element->data[1] == 0x0a &&
+	     info_element->data[2] == 0xf7) ||
+	     (info_element->len >= 3 &&
+	     info_element->data[0] == 0x00 &&
+	     info_element->data[1] == 0x10 &&
+	     info_element->data[2] == 0x18)) {
+		network->broadcom_cap_exist = true;
+	}
+	if (info_element->len >= 3 &&
+	    info_element->data[0] == 0x00 &&
+	    info_element->data[1] == 0x0c &&
+	    info_element->data[2] == 0x43)
+		network->ralink_cap_exist = true;
+	if ((info_element->len >= 3 &&
+	     info_element->data[0] == 0x00 &&
+	     info_element->data[1] == 0x03 &&
+	     info_element->data[2] == 0x7f) ||
+	     (info_element->len >= 3 &&
+	     info_element->data[0] == 0x00 &&
+	     info_element->data[1] == 0x13 &&
+	     info_element->data[2] == 0x74))
+		network->atheros_cap_exist = true;
+
+	if ((info_element->len >= 3 &&
+	     info_element->data[0] == 0x00 &&
+	     info_element->data[1] == 0x50 &&
+	     info_element->data[2] == 0x43))
+		network->marvell_cap_exist = true;
+	if (info_element->len >= 3 &&
+	    info_element->data[0] == 0x00 &&
+	    info_element->data[1] == 0x40 &&
+	    info_element->data[2] == 0x96)
+		network->cisco_cap_exist = true;
+
+
+	if (info_element->len >= 3 &&
+	    info_element->data[0] == 0x00 &&
+	    info_element->data[1] == 0x0a &&
+	    info_element->data[2] == 0xf5)
+		network->airgo_cap_exist = true;
+
+	if (info_element->len > 4 &&
+	    info_element->data[0] == 0x00 &&
+	    info_element->data[1] == 0x40 &&
+	    info_element->data[2] == 0x96 &&
+	    info_element->data[3] == 0x01) {
+		if (info_element->len == 6) {
+			memcpy(network->CcxRmState, &info_element[4], 2);
+			if (network->CcxRmState[0] != 0)
+				network->bCcxRmEnable = true;
+			else
+				network->bCcxRmEnable = false;
+			network->MBssidMask = network->CcxRmState[1] & 0x07;
+			if (network->MBssidMask != 0) {
+				network->bMBssidValid = true;
+				network->MBssidMask = 0xff << (network->MBssidMask);
+				ether_addr_copy(network->MBssid,
+						network->bssid);
+				network->MBssid[5] &= network->MBssidMask;
+			} else {
+				network->bMBssidValid = false;
+			}
+		} else {
+			network->bCcxRmEnable = false;
+		}
+	}
+	if (info_element->len > 4  &&
+	    info_element->data[0] == 0x00 &&
+	    info_element->data[1] == 0x40 &&
+	    info_element->data[2] == 0x96 &&
+	    info_element->data[3] == 0x03) {
+		if (info_element->len == 5) {
+			network->bWithCcxVerNum = true;
+			network->BssCcxVerNumber = info_element->data[4];
+		} else {
+			network->bWithCcxVerNum = false;
+			network->BssCcxVerNumber = 0;
+		}
+	}
+	if (info_element->len > 4  &&
+	    info_element->data[0] == 0x00 &&
+	    info_element->data[1] == 0x50 &&
+	    info_element->data[2] == 0xf2 &&
+	    info_element->data[3] == 0x04) {
+		RTLLIB_DEBUG_MGMT("MFIE_TYPE_WZC: %d bytes\n",
+				  info_element->len);
+		network->wzc_ie_len = min(info_element->len+2,
+					  MAX_WZC_IE_LEN);
+		memcpy(network->wzc_ie, info_element,
+		       network->wzc_ie_len);
+	}
+}
+
 int rtllib_parse_info_param(struct rtllib_device *ieee,
 		struct rtllib_info_element *info_element,
 		u16 length,
@@ -1749,8 +1956,6 @@ int rtllib_parse_info_param(struct rtllib_device *ieee,
 	short offset;
 	u16	tmp_htcap_len = 0;
 	u16	tmp_htinfo_len = 0;
-	u16 ht_realtek_agg_len = 0;
-	u8  ht_realtek_agg_buf[MAX_IE_LEN];
 	char rates_str[64];
 	char *p;
 
@@ -1903,191 +2108,9 @@ int rtllib_parse_info_param(struct rtllib_device *ieee,
 		case MFIE_TYPE_GENERIC:
 			RTLLIB_DEBUG_MGMT("MFIE_TYPE_GENERIC: %d bytes\n",
 					     info_element->len);
-			if (!rtllib_parse_qos_info_param_IE(info_element,
-							       network))
-				break;
-			if (info_element->len >= 4 &&
-			    info_element->data[0] == 0x00 &&
-			    info_element->data[1] == 0x50 &&
-			    info_element->data[2] == 0xf2 &&
-			    info_element->data[3] == 0x01) {
-				network->wpa_ie_len = min(info_element->len + 2,
-							  MAX_WPA_IE_LEN);
-				memcpy(network->wpa_ie, info_element,
-				       network->wpa_ie_len);
-				break;
-			}
-			if (info_element->len == 7 &&
-			    info_element->data[0] == 0x00 &&
-			    info_element->data[1] == 0xe0 &&
-			    info_element->data[2] == 0x4c &&
-			    info_element->data[3] == 0x01 &&
-			    info_element->data[4] == 0x02)
-				network->Turbo_Enable = 1;
-
-			if (tmp_htcap_len == 0) {
-				if (info_element->len >= 4 &&
-				   info_element->data[0] == 0x00 &&
-				   info_element->data[1] == 0x90 &&
-				   info_element->data[2] == 0x4c &&
-				   info_element->data[3] == 0x033) {
-
-					tmp_htcap_len = min_t(u8, info_element->len, MAX_IE_LEN);
-					if (tmp_htcap_len != 0) {
-						network->bssht.bdHTSpecVer = HT_SPEC_VER_EWC;
-						network->bssht.bdHTCapLen = min_t(u16, tmp_htcap_len, sizeof(network->bssht.bdHTCapBuf));
-						memcpy(network->bssht.bdHTCapBuf, info_element->data, network->bssht.bdHTCapLen);
-					}
-				}
-				if (tmp_htcap_len != 0) {
-					network->bssht.bdSupportHT = true;
-					network->bssht.bdHT1R = ((((struct ht_capab_ele *)(network->bssht.bdHTCapBuf))->MCS[1]) == 0);
-				} else {
-					network->bssht.bdSupportHT = false;
-					network->bssht.bdHT1R = false;
-				}
-			}
-
-
-			if (tmp_htinfo_len == 0) {
-				if (info_element->len >= 4 &&
-				    info_element->data[0] == 0x00 &&
-				    info_element->data[1] == 0x90 &&
-				    info_element->data[2] == 0x4c &&
-				    info_element->data[3] == 0x034) {
-					tmp_htinfo_len = min_t(u8, info_element->len, MAX_IE_LEN);
-					if (tmp_htinfo_len != 0) {
-						network->bssht.bdHTSpecVer = HT_SPEC_VER_EWC;
-						network->bssht.bdHTInfoLen = min_t(u16, tmp_htinfo_len, sizeof(network->bssht.bdHTInfoBuf));
-						memcpy(network->bssht.bdHTInfoBuf, info_element->data, network->bssht.bdHTInfoLen);
-					}
-
-				}
-			}
-
-			if (ieee->aggregation) {
-				if (network->bssht.bdSupportHT) {
-					if (info_element->len >= 4 &&
-					    info_element->data[0] == 0x00 &&
-					    info_element->data[1] == 0xe0 &&
-					    info_element->data[2] == 0x4c &&
-					    info_element->data[3] == 0x02) {
-						ht_realtek_agg_len = min_t(u8, info_element->len, MAX_IE_LEN);
-						memcpy(ht_realtek_agg_buf, info_element->data, info_element->len);
-					}
-					if (ht_realtek_agg_len >= 5) {
-						network->realtek_cap_exit = true;
-						network->bssht.bdRT2RTAggregation = true;
-
-						if ((ht_realtek_agg_buf[4] == 1) && (ht_realtek_agg_buf[5] & 0x02))
-							network->bssht.bdRT2RTLongSlotTime = true;
-
-						if ((ht_realtek_agg_buf[4] == 1) && (ht_realtek_agg_buf[5] & RT_HT_CAP_USE_92SE))
-							network->bssht.RT2RT_HT_Mode |= RT_HT_CAP_USE_92SE;
-					}
-				}
-				if (ht_realtek_agg_len >= 5) {
-					if ((ht_realtek_agg_buf[5] & RT_HT_CAP_USE_SOFTAP))
-						network->bssht.RT2RT_HT_Mode |= RT_HT_CAP_USE_SOFTAP;
-				}
-			}
-
-			if ((info_element->len >= 3 &&
-			     info_element->data[0] == 0x00 &&
-			     info_element->data[1] == 0x05 &&
-			     info_element->data[2] == 0xb5) ||
-			     (info_element->len >= 3 &&
-			     info_element->data[0] == 0x00 &&
-			     info_element->data[1] == 0x0a &&
-			     info_element->data[2] == 0xf7) ||
-			     (info_element->len >= 3 &&
-			     info_element->data[0] == 0x00 &&
-			     info_element->data[1] == 0x10 &&
-			     info_element->data[2] == 0x18)) {
-				network->broadcom_cap_exist = true;
-			}
-			if (info_element->len >= 3 &&
-			    info_element->data[0] == 0x00 &&
-			    info_element->data[1] == 0x0c &&
-			    info_element->data[2] == 0x43)
-				network->ralink_cap_exist = true;
-			if ((info_element->len >= 3 &&
-			     info_element->data[0] == 0x00 &&
-			     info_element->data[1] == 0x03 &&
-			     info_element->data[2] == 0x7f) ||
-			     (info_element->len >= 3 &&
-			     info_element->data[0] == 0x00 &&
-			     info_element->data[1] == 0x13 &&
-			     info_element->data[2] == 0x74))
-				network->atheros_cap_exist = true;
-
-			if ((info_element->len >= 3 &&
-			     info_element->data[0] == 0x00 &&
-			     info_element->data[1] == 0x50 &&
-			     info_element->data[2] == 0x43))
-				network->marvell_cap_exist = true;
-			if (info_element->len >= 3 &&
-			    info_element->data[0] == 0x00 &&
-			    info_element->data[1] == 0x40 &&
-			    info_element->data[2] == 0x96)
-				network->cisco_cap_exist = true;
-
-
-			if (info_element->len >= 3 &&
-			    info_element->data[0] == 0x00 &&
-			    info_element->data[1] == 0x0a &&
-			    info_element->data[2] == 0xf5)
-				network->airgo_cap_exist = true;
-
-			if (info_element->len > 4 &&
-			    info_element->data[0] == 0x00 &&
-			    info_element->data[1] == 0x40 &&
-			    info_element->data[2] == 0x96 &&
-			    info_element->data[3] == 0x01) {
-				if (info_element->len == 6) {
-					memcpy(network->CcxRmState, &info_element[4], 2);
-					if (network->CcxRmState[0] != 0)
-						network->bCcxRmEnable = true;
-					else
-						network->bCcxRmEnable = false;
-					network->MBssidMask = network->CcxRmState[1] & 0x07;
-					if (network->MBssidMask != 0) {
-						network->bMBssidValid = true;
-						network->MBssidMask = 0xff << (network->MBssidMask);
-						ether_addr_copy(network->MBssid, network->bssid);
-						network->MBssid[5] &= network->MBssidMask;
-					} else {
-						network->bMBssidValid = false;
-					}
-				} else {
-					network->bCcxRmEnable = false;
-				}
-			}
-			if (info_element->len > 4  &&
-			    info_element->data[0] == 0x00 &&
-			    info_element->data[1] == 0x40 &&
-			    info_element->data[2] == 0x96 &&
-			    info_element->data[3] == 0x03) {
-				if (info_element->len == 5) {
-					network->bWithCcxVerNum = true;
-					network->BssCcxVerNumber = info_element->data[4];
-				} else {
-					network->bWithCcxVerNum = false;
-					network->BssCcxVerNumber = 0;
-				}
-			}
-			if (info_element->len > 4  &&
-			    info_element->data[0] == 0x00 &&
-			    info_element->data[1] == 0x50 &&
-			    info_element->data[2] == 0xf2 &&
-			    info_element->data[3] == 0x04) {
-				RTLLIB_DEBUG_MGMT("MFIE_TYPE_WZC: %d bytes\n",
-						     info_element->len);
-				network->wzc_ie_len = min(info_element->len+2,
-							  MAX_WZC_IE_LEN);
-				memcpy(network->wzc_ie, info_element,
-						network->wzc_ie_len);
-			}
+			rtllib_parse_mife_generic(ieee, info_element, network,
+						  &tmp_htcap_len,
+						  &tmp_htinfo_len);
 			break;
 
 		case MFIE_TYPE_RSN:

commit b57ceb19aba7d40403ca985ec565db8db20f4331
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Sun May 31 20:19:22 2015 +0200

    staging: rtl8192e: Fix PREFER_ETHER_ADDR_COPY warnings
    
    Replace memcpy() with ether_addr_copy() where possible to make
    checkpatch.pl happy.
    Change was target tested (download 1Mb file over WPA2 network)
    with BUG trap for unaligned addresses in ether_addr_copy()
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index 3228bfd1a5f6..bde80c8fa8d5 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -139,8 +139,8 @@ rtllib_frag_cache_get(struct rtllib_device *ieee,
 		entry->seq = seq;
 		entry->last_frag = frag;
 		entry->skb = skb;
-		memcpy(entry->src_addr, hdr->addr2, ETH_ALEN);
-		memcpy(entry->dst_addr, hdr->addr1, ETH_ALEN);
+		ether_addr_copy(entry->src_addr, hdr->addr2);
+		ether_addr_copy(entry->dst_addr, hdr->addr1);
 	} else {
 		/* received a fragment of a frame for which the head fragment
 		 * should have already been received
@@ -400,7 +400,7 @@ static int is_duplicate_packet(struct rtllib_device *ieee,
 			if (!entry)
 				return 0;
 
-			memcpy(entry->mac, mac, ETH_ALEN);
+			ether_addr_copy(entry->mac, mac);
 			entry->seq_num[tid] = seq;
 			entry->frag_num[tid] = frag;
 			entry->packet_time[tid] = jiffies;
@@ -927,24 +927,24 @@ static void rtllib_rx_extract_addr(struct rtllib_device *ieee,
 
 	switch (fc & (RTLLIB_FCTL_FROMDS | RTLLIB_FCTL_TODS)) {
 	case RTLLIB_FCTL_FROMDS:
-		memcpy(dst, hdr->addr1, ETH_ALEN);
-		memcpy(src, hdr->addr3, ETH_ALEN);
-		memcpy(bssid, hdr->addr2, ETH_ALEN);
+		ether_addr_copy(dst, hdr->addr1);
+		ether_addr_copy(src, hdr->addr3);
+		ether_addr_copy(bssid, hdr->addr2);
 		break;
 	case RTLLIB_FCTL_TODS:
-		memcpy(dst, hdr->addr3, ETH_ALEN);
-		memcpy(src, hdr->addr2, ETH_ALEN);
-		memcpy(bssid, hdr->addr1, ETH_ALEN);
+		ether_addr_copy(dst, hdr->addr3);
+		ether_addr_copy(src, hdr->addr2);
+		ether_addr_copy(bssid, hdr->addr1);
 		break;
 	case RTLLIB_FCTL_FROMDS | RTLLIB_FCTL_TODS:
-		memcpy(dst, hdr->addr3, ETH_ALEN);
-		memcpy(src, hdr->addr4, ETH_ALEN);
-		memcpy(bssid, ieee->current_network.bssid, ETH_ALEN);
+		ether_addr_copy(dst, hdr->addr3);
+		ether_addr_copy(src, hdr->addr4);
+		ether_addr_copy(bssid, ieee->current_network.bssid);
 		break;
 	case 0:
-		memcpy(dst, hdr->addr1, ETH_ALEN);
-		memcpy(src, hdr->addr2, ETH_ALEN);
-		memcpy(bssid, hdr->addr3, ETH_ALEN);
+		ether_addr_copy(dst, hdr->addr1);
+		ether_addr_copy(src, hdr->addr2);
+		ether_addr_copy(bssid, hdr->addr3);
 		break;
 	}
 }
@@ -1218,15 +1218,19 @@ static void rtllib_rx_indicate_pkt_legacy(struct rtllib_device *ieee,
 				 * replace EtherType
 				 */
 				skb_pull(sub_skb, SNAP_SIZE);
-				memcpy(skb_push(sub_skb, ETH_ALEN), src, ETH_ALEN);
-				memcpy(skb_push(sub_skb, ETH_ALEN), dst, ETH_ALEN);
+				ether_addr_copy(skb_push(sub_skb, ETH_ALEN),
+						src);
+				ether_addr_copy(skb_push(sub_skb, ETH_ALEN),
+						dst);
 			} else {
 				u16 len;
 				/* Leave Ethernet header part of hdr and full payload */
 				len = sub_skb->len;
 				memcpy(skb_push(sub_skb, 2), &len, 2);
-				memcpy(skb_push(sub_skb, ETH_ALEN), src, ETH_ALEN);
-				memcpy(skb_push(sub_skb, ETH_ALEN), dst, ETH_ALEN);
+				ether_addr_copy(skb_push(sub_skb, ETH_ALEN),
+						src);
+				ether_addr_copy(skb_push(sub_skb, ETH_ALEN),
+						dst);
 			}
 
 			ieee->stats.rx_packets++;
@@ -2050,7 +2054,7 @@ int rtllib_parse_info_param(struct rtllib_device *ieee,
 					if (network->MBssidMask != 0) {
 						network->bMBssidValid = true;
 						network->MBssidMask = 0xff << (network->MBssidMask);
-						memcpy(network->MBssid, network->bssid, ETH_ALEN);
+						ether_addr_copy(network->MBssid, network->bssid);
 						network->MBssid[5] &= network->MBssidMask;
 					} else {
 						network->bMBssidValid = false;
@@ -2210,7 +2214,7 @@ static inline int rtllib_network_init(
 	memset(&network->qos_data, 0, sizeof(struct rtllib_qos_data));
 
 	/* Pull out fixed field data */
-	memcpy(network->bssid, beacon->header.addr3, ETH_ALEN);
+	ether_addr_copy(network->bssid, beacon->header.addr3);
 	network->capability = le16_to_cpu(beacon->capability);
 	network->last_scanned = jiffies;
 	network->time_stamp[0] = beacon->time_stamp[0];

commit 06c111072892d3f5fed9d73d1becb59d3f33410b
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Sun May 31 20:19:21 2015 +0200

    staging: rtl8192e: Make ethernet addresses properly aligned
    
    Reorder ethernet addresses allocated on stack or in non-packed
    structures to keep them aligned(2).
    Use ETH_ALEN as array length in places where it was hardcoded to 6.
    
    Alignment verified using pahole where possible and target-tested
    with BUG_ON() trap in ether_addr_copy.
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index bb789cc9208d..3228bfd1a5f6 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -1258,7 +1258,11 @@ static int rtllib_rx_InfraAdhoc(struct rtllib_device *ieee, struct sk_buff *skb,
 	struct rx_ts_record *pTS = NULL;
 	u16 fc, sc, SeqNum = 0;
 	u8 type, stype, multicast = 0, unicast = 0, nr_subframes = 0, TID = 0;
-	u8 dst[ETH_ALEN], src[ETH_ALEN], bssid[ETH_ALEN] = {0}, *payload;
+	u8 *payload;
+	u8 dst[ETH_ALEN];
+	u8 src[ETH_ALEN];
+	u8 bssid[ETH_ALEN] = {0};
+
 	size_t hdrlen = 0;
 	bool bToOtherSTA = false;
 	int ret = 0, i = 0;

commit fbb052f9fe6839ff85839d729ae1f44ff7c03760
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Mon Apr 13 23:47:30 2015 +0200

    staging: rtl8192e: Fix DEEP_INDENTATION warnings in rtllib_parse_info_param()
    
    - Replace ?: with min_t
    - Remove condition that is always true
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index 95cd17eda768..bb789cc9208d 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -1924,13 +1924,12 @@ int rtllib_parse_info_param(struct rtllib_device *ieee,
 				   info_element->data[2] == 0x4c &&
 				   info_element->data[3] == 0x033) {
 
-						tmp_htcap_len = min_t(u8, info_element->len, MAX_IE_LEN);
-						if (tmp_htcap_len != 0) {
-							network->bssht.bdHTSpecVer = HT_SPEC_VER_EWC;
-							network->bssht.bdHTCapLen = tmp_htcap_len > sizeof(network->bssht.bdHTCapBuf) ?
-								sizeof(network->bssht.bdHTCapBuf) : tmp_htcap_len;
-							memcpy(network->bssht.bdHTCapBuf, info_element->data, network->bssht.bdHTCapLen);
-						}
+					tmp_htcap_len = min_t(u8, info_element->len, MAX_IE_LEN);
+					if (tmp_htcap_len != 0) {
+						network->bssht.bdHTSpecVer = HT_SPEC_VER_EWC;
+						network->bssht.bdHTCapLen = min_t(u16, tmp_htcap_len, sizeof(network->bssht.bdHTCapBuf));
+						memcpy(network->bssht.bdHTCapBuf, info_element->data, network->bssht.bdHTCapLen);
+					}
 				}
 				if (tmp_htcap_len != 0) {
 					network->bssht.bdSupportHT = true;
@@ -1951,12 +1950,8 @@ int rtllib_parse_info_param(struct rtllib_device *ieee,
 					tmp_htinfo_len = min_t(u8, info_element->len, MAX_IE_LEN);
 					if (tmp_htinfo_len != 0) {
 						network->bssht.bdHTSpecVer = HT_SPEC_VER_EWC;
-						if (tmp_htinfo_len) {
-							network->bssht.bdHTInfoLen = tmp_htinfo_len > sizeof(network->bssht.bdHTInfoBuf) ?
-								sizeof(network->bssht.bdHTInfoBuf) : tmp_htinfo_len;
-							memcpy(network->bssht.bdHTInfoBuf, info_element->data, network->bssht.bdHTInfoLen);
-						}
-
+						network->bssht.bdHTInfoLen = min_t(u16, tmp_htinfo_len, sizeof(network->bssht.bdHTInfoBuf));
+						memcpy(network->bssht.bdHTInfoBuf, info_element->data, network->bssht.bdHTInfoLen);
 					}
 
 				}

commit f669228512e533468437a1058ef11303afa4e878
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Mon Apr 13 23:47:27 2015 +0200

    staging: rtl8192e: Fix SPACING errors
    
    Fix several SPACING errors to make checkpatch happy.
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index fe3e7e1273ff..95cd17eda768 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -469,7 +469,7 @@ static bool AddReorderEntry(struct rx_ts_record *pTS,
 void rtllib_indicate_packets(struct rtllib_device *ieee, struct rtllib_rxb **prxbIndicateArray, u8 index)
 {
 	struct net_device_stats *stats = &ieee->stats;
-	u8 i = 0 , j = 0;
+	u8 i = 0, j = 0;
 	u16 ethertype;
 
 	for (j = 0; j < index; j++) {

commit 8852112e1c23a27e41f1b6b401c254c2de0f82b5
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Wed Apr 1 00:24:38 2015 +0200

    staging: rtl8192e: Remove dead code
    
    Remove commented-out code
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index c1418b457a45..fe3e7e1273ff 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -2208,13 +2208,6 @@ static inline int rtllib_network_init(
 	struct rtllib_network *network,
 	struct rtllib_rx_stats *stats)
 {
-
-	/*
-	network->qos_data.active = 0;
-	network->qos_data.supported = 0;
-	network->qos_data.param_count = 0;
-	network->qos_data.old_param_count = 0;
-	*/
 	memset(&network->qos_data, 0, sizeof(struct rtllib_qos_data));
 
 	/* Pull out fixed field data */

commit 14b40d92881533dca8b25647f105b9546433cda2
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Wed Apr 1 00:24:37 2015 +0200

    staging: rtl8192e: Comment cleanup (style/format)
    
    - Multiline comments use "network subsystem comment style"
    - Merge short multiline comments
    - Remove empty comments
    - Remove function name comment at the end of small (<1 screen) functions
    - Reformat 802.11 data frame format to use spaces and network format
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index c17112396d45..c1418b457a45 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -143,7 +143,8 @@ rtllib_frag_cache_get(struct rtllib_device *ieee,
 		memcpy(entry->dst_addr, hdr->addr1, ETH_ALEN);
 	} else {
 		/* received a fragment of a frame for which the head fragment
-		 * should have already been received */
+		 * should have already been received
+		 */
 		entry = rtllib_frag_cache_find(ieee, seq, frag, tid, hdr->addr2,
 						  hdr->addr1);
 		if (entry != NULL) {
@@ -199,7 +200,8 @@ static int rtllib_frag_cache_invalidate(struct rtllib_device *ieee,
  *
  * Responsible for handling management control frames
  *
- * Called by rtllib_rx */
+ * Called by rtllib_rx
+ */
 static inline int
 rtllib_rx_frame_mgmt(struct rtllib_device *ieee, struct sk_buff *skb,
 			struct rtllib_rx_stats *rx_stats, u16 type,
@@ -224,8 +226,9 @@ rtllib_rx_frame_mgmt(struct rtllib_device *ieee, struct sk_buff *skb,
 	return 0;
 }
 
-/* See IEEE 802.1H for LLC/SNAP encapsulation/decapsulation */
-/* Ethernet-II snap header (RFC1042 for most EtherTypes) */
+/* See IEEE 802.1H for LLC/SNAP encapsulation/decapsulation
+ * Ethernet-II snap header (RFC1042 for most EtherTypes)
+ */
 static unsigned char rfc1042_header[] = {
 	0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00
 };
@@ -482,7 +485,8 @@ void rtllib_indicate_packets(struct rtllib_device *ieee, struct rtllib_rxb **prx
 			    ethertype != ETH_P_AARP && ethertype != ETH_P_IPX) ||
 			    memcmp(sub_skb->data, bridge_tunnel_header, SNAP_SIZE) == 0)) {
 				/* remove RFC1042 or Bridge-Tunnel encapsulation
-				 * and replace EtherType */
+				 * and replace EtherType
+				 */
 				skb_pull(sub_skb, SNAP_SIZE);
 				memcpy(skb_push(sub_skb, ETH_ALEN), prxb->src, ETH_ALEN);
 				memcpy(skb_push(sub_skb, ETH_ALEN), prxb->dst, ETH_ALEN);
@@ -582,8 +586,7 @@ static void RxReorderIndicatePacket(struct rtllib_device *ieee,
 		return;
 	}
 
-	/*
-	 * Sliding window manipulation. Conditions includes:
+	/* Sliding window manipulation. Conditions includes:
 	 * 1. Incoming SeqNum is equal to WinStart =>Window shift 1
 	 * 2. Incoming SeqNum is larger than the WinEnd => Window shift N
 	 */
@@ -598,13 +601,12 @@ static void RxReorderIndicatePacket(struct rtllib_device *ieee,
 		RTLLIB_DEBUG(RTLLIB_DL_REORDER, "Window Shift! IndicateSeq: %d, NewSeq: %d\n", pTS->RxIndicateSeq, SeqNum);
 	}
 
-	/*
-	 * Indication process.
+	/* Indication process.
 	 * After Packet dropping and Sliding Window shifting as above, we can
 	 * now just indicate the packets with the SeqNum smaller than latest
 	 * WinStart and struct buffer other packets.
-	 */
-	/* For Rx Reorder condition:
+	 *
+	 * For Rx Reorder condition:
 	 * 1. All packets with SeqNum smaller than WinStart => Indicate
 	 * 2. All packets with SeqNum larger than or equal to
 	 *	 WinStart => Buffer it.
@@ -647,8 +649,7 @@ static void RxReorderIndicatePacket(struct rtllib_device *ieee,
 					 pTS->RxIndicateSeq, SeqNum);
 			}
 		} else {
-			/*
-			 * Packets are dropped if there are not enough reorder
+			/* Packets are dropped if there are not enough reorder
 			 * entries. This part should be modified!! We can just
 			 * indicate all the packets in struct buffer and get
 			 * reorder entries.
@@ -698,7 +699,8 @@ static void RxReorderIndicatePacket(struct rtllib_device *ieee,
 	}
 
 	/* Handling pending timer. Set this timer to prevent from long time
-	 * Rx buffering.*/
+	 * Rx buffering.
+	 */
 	if (index > 0) {
 		if (timer_pending(&pTS->RxPktPendingTimer))
 			del_timer_sync(&pTS->RxPktPendingTimer);
@@ -973,7 +975,8 @@ static int rtllib_rx_data_filter(struct rtllib_device *ieee, u16 fc,
 	}
 
 	/* Nullfunc frames may have PS-bit set, so they must be passed to
-	 * hostap_handle_sta_rx() before being dropped here. */
+	 * hostap_handle_sta_rx() before being dropped here.
+	 */
 	if (!ieee->IntelPromiscuousModeInfo.bPromiscuousOn) {
 		if (stype != RTLLIB_STYPE_DATA &&
 		    stype != RTLLIB_STYPE_DATA_CFACK &&
@@ -1015,7 +1018,8 @@ static int rtllib_rx_get_crypt(struct rtllib_device *ieee, struct sk_buff *skb,
 
 		*crypt = ieee->crypt_info.crypt[idx];
 		/* allow NULL decrypt to indicate an station specific override
-		 * for default encryption */
+		 * for default encryption
+		 */
 		if (*crypt && ((*crypt)->ops == NULL ||
 			      (*crypt)->ops->decrypt_mpdu == NULL))
 			*crypt = NULL;
@@ -1024,7 +1028,8 @@ static int rtllib_rx_get_crypt(struct rtllib_device *ieee, struct sk_buff *skb,
 			/* This seems to be triggered by some (multicast?)
 			 * frames from other than current BSS, so just drop the
 			 * frames silently instead of filling system log with
-			 * these reports. */
+			 * these reports.
+			 */
 			RTLLIB_DEBUG_DROP("Decryption failed (not set) (SA= %pM)\n",
 					     hdr->addr2);
 			ieee->ieee_stats.rx_discards_undecryptable++;
@@ -1088,11 +1093,13 @@ static int rtllib_rx_decrypt(struct rtllib_device *ieee, struct sk_buff *skb,
 
 		if (frag == 0) {
 			/* copy first fragment (including full headers) into
-			 * beginning of the fragment cache skb */
+			 * beginning of the fragment cache skb
+			 */
 			memcpy(skb_put(frag_skb, flen), skb->data, flen);
 		} else {
 			/* append frame payload to the end of the fragment
-			 * cache skb */
+			 * cache skb
+			 */
 			memcpy(skb_put(frag_skb, flen), skb->data + hdrlen,
 			       flen);
 		}
@@ -1102,19 +1109,22 @@ static int rtllib_rx_decrypt(struct rtllib_device *ieee, struct sk_buff *skb,
 		if (fc & RTLLIB_FCTL_MOREFRAGS) {
 			/* more fragments expected - leave the skb in fragment
 			 * cache for now; it will be delivered to upper layers
-			 * after all fragments have been received */
+			 * after all fragments have been received
+			 */
 			return -2;
 		}
 
 		/* this was the last fragment and the frame will be
-		 * delivered, so remove skb from fragment cache */
+		 * delivered, so remove skb from fragment cache
+		 */
 		skb = frag_skb;
 		hdr = (struct rtllib_hdr_4addr *) skb->data;
 		rtllib_frag_cache_invalidate(ieee, hdr);
 	}
 
 	/* skb: hdr + (possible reassembled) full MSDU payload; possibly still
-	 * encrypted/authenticated */
+	 * encrypted/authenticated
+	 */
 	if (ieee->host_decrypt && (fc & RTLLIB_FCTL_WEP) &&
 		rtllib_rx_frame_decrypt_msdu(ieee, skb, keyidx, crypt)) {
 		netdev_info(ieee->dev, "%s: ==>decrypt msdu error\n", __func__);
@@ -1127,7 +1137,8 @@ static int rtllib_rx_decrypt(struct rtllib_device *ieee, struct sk_buff *skb,
 		    rtllib_is_eapol_frame(ieee, skb, hdrlen)) {
 
 			/* pass unencrypted EAPOL frames even if encryption is
-			 * configured */
+			 * configured
+			 */
 			struct eapol *eap = (struct eapol *)(skb->data +
 				24);
 			RTLLIB_DEBUG_EAP("RX: IEEE 802.1X EAPOL frame: %s\n",
@@ -1204,7 +1215,8 @@ static void rtllib_rx_indicate_pkt_legacy(struct rtllib_device *ieee,
 				ethertype != ETH_P_AARP && ethertype != ETH_P_IPX) ||
 				memcmp(sub_skb->data, bridge_tunnel_header, SNAP_SIZE) == 0)) {
 				/* remove RFC1042 or Bridge-Tunnel encapsulation and
-				 * replace EtherType */
+				 * replace EtherType
+				 */
 				skb_pull(sub_skb, SNAP_SIZE);
 				memcpy(skb_push(sub_skb, ETH_ALEN), src, ETH_ALEN);
 				memcpy(skb_push(sub_skb, ETH_ALEN), dst, ETH_ALEN);
@@ -1396,7 +1408,8 @@ static int rtllib_rx_InfraAdhoc(struct rtllib_device *ieee, struct sk_buff *skb,
 
 	/* Returning 0 indicates to caller that we have not handled the SKB--
 	 * so it is still allocated and can be used again by underlying
-	 * hardware as a DMA target */
+	 * hardware as a DMA target
+	 */
 	return 0;
 }
 
@@ -1442,7 +1455,8 @@ static int rtllib_rx_Mesh(struct rtllib_device *ieee, struct sk_buff *skb,
 
 /* All received frames are sent to this function. @skb contains the frame in
  * IEEE 802.11 format, i.e., in the format it was sent over air.
- * This function is called only as a tasklet (software IRQ). */
+ * This function is called only as a tasklet (software IRQ).
+ */
 int rtllib_rx(struct rtllib_device *ieee, struct sk_buff *skb,
 		 struct rtllib_rx_stats *rx_stats)
 {
@@ -1488,10 +1502,7 @@ EXPORT_SYMBOL(rtllib_rx);
 
 static u8 qos_oui[QOS_OUI_LEN] = { 0x00, 0x50, 0xF2 };
 
-/*
-* Make ther structure we read from the beacon packet has
-* the right values
-*/
+/* Make ther structure we read from the beacon packet has the right values */
 static int rtllib_verify_qos_info(struct rtllib_qos_information_element
 				     *info_element, int sub_type)
 {
@@ -1509,9 +1520,7 @@ static int rtllib_verify_qos_info(struct rtllib_qos_information_element
 }
 
 
-/*
- * Parse a QoS parameter element
- */
+/* Parse a QoS parameter element */
 static int rtllib_read_qos_param_element(struct rtllib_qos_parameter_info
 					    *element_param, struct rtllib_info_element
 					    *info_element)
@@ -1535,9 +1544,7 @@ static int rtllib_read_qos_param_element(struct rtllib_qos_parameter_info
 	return ret;
 }
 
-/*
- * Parse a QoS information element
- */
+/* Parse a QoS information element */
 static int rtllib_read_qos_info_element(struct
 					   rtllib_qos_information_element
 					   *element_info, struct rtllib_info_element
@@ -1566,9 +1573,7 @@ static int rtllib_read_qos_info_element(struct
 }
 
 
-/*
- * Write QoS parameters from the ac parameters.
- */
+/* Write QoS parameters from the ac parameters. */
 static int rtllib_qos_convert_ac_to_parameters(struct rtllib_qos_parameter_info *param_elm,
 		struct rtllib_qos_data *qos_data)
 {
@@ -1627,8 +1632,7 @@ static int rtllib_qos_convert_ac_to_parameters(struct rtllib_qos_parameter_info
 	return 0;
 }
 
-/*
- * we have a generic data element which it may contain QoS information or
+/* we have a generic data element which it may contain QoS information or
  * parameters element. check the information element length to decide
  * which type to read
  */
@@ -1750,7 +1754,8 @@ int rtllib_parse_info_param(struct rtllib_device *ieee,
 					     length, info_element->id);
 			/* We stop processing but don't return an error here
 			 * because some misbehaviour APs break this rule. ie.
-			 * Orinoco AP1000. */
+			 * Orinoco AP1000.
+			 */
 			break;
 		}
 
@@ -2302,7 +2307,8 @@ static inline int is_same_network(struct rtllib_network *src,
 	/* A network is only a duplicate if the channel, BSSID, ESSID
 	 * and the capability field (in particular IBSS and BSS) all match.
 	 * We treat all <hidden> with the same BSSID and channel
-	 * as one network */
+	 * as one network
+	 */
 	return (((src->ssid_len == dst->ssid_len) || (!ssidbroad)) &&
 		(src->channel == dst->channel) &&
 		!memcmp(src->bssid, dst->bssid, ETH_ALEN) &&
@@ -2524,10 +2530,12 @@ static inline void rtllib_process_probe_response(
 	 *
 	 * NOTE:  This search is definitely not optimized.  Once its doing
 	 *	the "right thing" we'll optimize it for efficiency if
-	 *	necessary */
+	 *	necessary
+	 */
 
 	/* Search for this entry in the list and update it if it is
-	 * already there. */
+	 * already there.
+	 */
 
 	spin_lock_irqsave(&ieee->lock, flags);
 	if (is_same_network(&ieee->current_network, network,
@@ -2556,7 +2564,8 @@ static inline void rtllib_process_probe_response(
 	}
 
 	/* If we didn't find a match, then get a new network slot to initialize
-	 * with this beacon's information */
+	 * with this beacon's information
+	 */
 	if (&target->list == &ieee->network_list) {
 		if (list_empty(&ieee->network_free_list)) {
 			/* If there are no more slots, expire the oldest */

commit 025b8bbe49939dfd68a57cc94bca65c39a5409b8
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Wed Apr 1 00:24:29 2015 +0200

    staging: rtl8192e: Fix UNNECESSARY_PARENTHESES warnings
    
    Fix 'Unnecessary parentheses' checkpatch.pl warning
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index e2a748bdb396..c17112396d45 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -1166,7 +1166,7 @@ static void rtllib_rx_check_leave_lps(struct rtllib_device *ieee, u8 unicast, u8
 {
 	if (unicast) {
 
-		if ((ieee->state == RTLLIB_LINKED)) {
+		if (ieee->state == RTLLIB_LINKED) {
 			if (((ieee->LinkDetectInfo.NumRxUnicastOkInPeriod +
 			    ieee->LinkDetectInfo.NumTxOkInPeriod) > 8) ||
 			    (ieee->LinkDetectInfo.NumRxUnicastOkInPeriod > 2)) {

commit 0f0688b3ced6cf085a1bce52fb9984ecc8f39a45
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Wed Apr 1 00:24:27 2015 +0200

    staging: rtl8192e: Fix RETURN_VOID warnings
    
    Fix 'void function return statements are not generally useful'
    checkpatch.pl warnings
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index 2592bd19054b..e2a748bdb396 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -2623,7 +2623,6 @@ static inline void rtllib_process_probe_response(
 	}
 free_network:
 	kfree(network);
-	return;
 }
 
 void rtllib_rx_mgt(struct rtllib_device *ieee,

commit 285b7c00e06b4fdd6e9ac63b9b8082508340f1ab
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Wed Apr 1 00:24:26 2015 +0200

    staging: rtl8192e: Fix UNNECESSARY_ELSE warning
    
    Fix checkpatch warnings 'else is not generally useful after a break or return'
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index 9fc635395ca5..2592bd19054b 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -783,74 +783,74 @@ static u8 parse_subframe(struct rtllib_device *ieee, struct sk_buff *skb,
 		memcpy(rxb->dst, dst, ETH_ALEN);
 		rxb->subframes[0]->dev = ieee->dev;
 		return 1;
-	} else {
-		rxb->nr_subframes = 0;
-		memcpy(rxb->src, src, ETH_ALEN);
-		memcpy(rxb->dst, dst, ETH_ALEN);
-		while (skb->len > ETHERNET_HEADER_SIZE) {
-			/* Offset 12 denote 2 mac address */
-			nSubframe_Length = *((u16 *)(skb->data + 12));
-			nSubframe_Length = (nSubframe_Length >> 8) +
-					   (nSubframe_Length << 8);
-
-			if (skb->len < (ETHERNET_HEADER_SIZE + nSubframe_Length)) {
-				netdev_info(ieee->dev,
-					    "%s: A-MSDU parse error!! pRfd->nTotalSubframe : %d\n",
-					    __func__, rxb->nr_subframes);
-				netdev_info(ieee->dev,
-					    "%s: A-MSDU parse error!! Subframe Length: %d\n",
-					    __func__, nSubframe_Length);
-				netdev_info(ieee->dev,
-					    "nRemain_Length is %d and nSubframe_Length is : %d\n",
-					    skb->len, nSubframe_Length);
-				netdev_info(ieee->dev,
-					    "The Packet SeqNum is %d\n",
-					    SeqNum);
-				return 0;
-			}
+	}
 
-			/* move the data point to data content */
-			skb_pull(skb, ETHERNET_HEADER_SIZE);
+	rxb->nr_subframes = 0;
+	memcpy(rxb->src, src, ETH_ALEN);
+	memcpy(rxb->dst, dst, ETH_ALEN);
+	while (skb->len > ETHERNET_HEADER_SIZE) {
+		/* Offset 12 denote 2 mac address */
+		nSubframe_Length = *((u16 *)(skb->data + 12));
+		nSubframe_Length = (nSubframe_Length >> 8) +
+				   (nSubframe_Length << 8);
 
-			/* altered by clark 3/30/2010
-			 * The struct buffer size of the skb indicated to upper layer
-			 * must be less than 5000, or the defraged IP datagram
-			 * in the IP layer will exceed "ipfrag_high_tresh" and be
-			 * discarded. so there must not use the function
-			 * "skb_copy" and "skb_clone" for "skb".
-			 */
+		if (skb->len < (ETHERNET_HEADER_SIZE + nSubframe_Length)) {
+			netdev_info(ieee->dev,
+				    "%s: A-MSDU parse error!! pRfd->nTotalSubframe : %d\n",
+				    __func__, rxb->nr_subframes);
+			netdev_info(ieee->dev,
+				    "%s: A-MSDU parse error!! Subframe Length: %d\n",
+				    __func__, nSubframe_Length);
+			netdev_info(ieee->dev,
+				    "nRemain_Length is %d and nSubframe_Length is : %d\n",
+				    skb->len, nSubframe_Length);
+			netdev_info(ieee->dev,
+				    "The Packet SeqNum is %d\n",
+				    SeqNum);
+			return 0;
+		}
 
-			/* Allocate new skb for releasing to upper layer */
-			sub_skb = dev_alloc_skb(nSubframe_Length + 12);
-			if (!sub_skb)
-				return 0;
-			skb_reserve(sub_skb, 12);
-			data_ptr = (u8 *)skb_put(sub_skb, nSubframe_Length);
-			memcpy(data_ptr, skb->data, nSubframe_Length);
-
-			sub_skb->dev = ieee->dev;
-			rxb->subframes[rxb->nr_subframes++] = sub_skb;
-			if (rxb->nr_subframes >= MAX_SUBFRAME_COUNT) {
-				RTLLIB_DEBUG_RX("ParseSubframe(): Too many Subframes! Packets dropped!\n");
-				break;
-			}
-			skb_pull(skb, nSubframe_Length);
+		/* move the data point to data content */
+		skb_pull(skb, ETHERNET_HEADER_SIZE);
 
-			if (skb->len != 0) {
-				nPadding_Length = 4 - ((nSubframe_Length +
-						  ETHERNET_HEADER_SIZE) % 4);
-				if (nPadding_Length == 4)
-					nPadding_Length = 0;
+		/* altered by clark 3/30/2010
+		 * The struct buffer size of the skb indicated to upper layer
+		 * must be less than 5000, or the defraged IP datagram
+		 * in the IP layer will exceed "ipfrag_high_tresh" and be
+		 * discarded. so there must not use the function
+		 * "skb_copy" and "skb_clone" for "skb".
+		 */
 
-				if (skb->len < nPadding_Length)
-					return 0;
+		/* Allocate new skb for releasing to upper layer */
+		sub_skb = dev_alloc_skb(nSubframe_Length + 12);
+		if (!sub_skb)
+			return 0;
+		skb_reserve(sub_skb, 12);
+		data_ptr = (u8 *)skb_put(sub_skb, nSubframe_Length);
+		memcpy(data_ptr, skb->data, nSubframe_Length);
 
-				skb_pull(skb, nPadding_Length);
-			}
+		sub_skb->dev = ieee->dev;
+		rxb->subframes[rxb->nr_subframes++] = sub_skb;
+		if (rxb->nr_subframes >= MAX_SUBFRAME_COUNT) {
+			RTLLIB_DEBUG_RX("ParseSubframe(): Too many Subframes! Packets dropped!\n");
+			break;
 		}
+		skb_pull(skb, nSubframe_Length);
+
+		if (skb->len != 0) {
+			nPadding_Length = 4 - ((nSubframe_Length +
+					  ETHERNET_HEADER_SIZE) % 4);
+			if (nPadding_Length == 4)
+				nPadding_Length = 0;
 
-		return rxb->nr_subframes;
+			if (skb->len < nPadding_Length)
+				return 0;
+
+			skb_pull(skb, nPadding_Length);
+		}
 	}
+
+	return rxb->nr_subframes;
 }
 
 

commit d69d20549be9e44b928d5f857898fe7432deeaac
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Tue Mar 17 00:00:52 2015 +0100

    staging: rtl8192e: fix coding style warnings (printk -> netdev_*)
    
    Use netdev_*, dev_* or pr_* instead of printk where possible.
    KERN_DEBUG messages are left intact as pr_dbg has different behaviour.
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index 15f7d3479274..9fc635395ca5 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -523,7 +523,9 @@ void rtllib_FlushRxTsPendingPkts(struct rtllib_device *ieee,	struct rx_ts_record
 	del_timer_sync(&pTS->RxPktPendingTimer);
 	while (!list_empty(&pTS->RxPendingPktList)) {
 		if (RfdCnt >= REORDER_WIN_SIZE) {
-			printk(KERN_INFO "-------------->%s() error! RfdCnt >= REORDER_WIN_SIZE\n", __func__);
+			netdev_info(ieee->dev,
+				    "-------------->%s() error! RfdCnt >= REORDER_WIN_SIZE\n",
+				    __func__);
 			break;
 		}
 
@@ -792,13 +794,18 @@ static u8 parse_subframe(struct rtllib_device *ieee, struct sk_buff *skb,
 					   (nSubframe_Length << 8);
 
 			if (skb->len < (ETHERNET_HEADER_SIZE + nSubframe_Length)) {
-				printk(KERN_INFO "%s: A-MSDU parse error!! pRfd->nTotalSubframe : %d\n",\
-				       __func__, rxb->nr_subframes);
-				printk(KERN_INFO "%s: A-MSDU parse error!! Subframe Length: %d\n", __func__,
-				       nSubframe_Length);
-				printk(KERN_INFO "nRemain_Length is %d and nSubframe_Length is : %d\n", skb->len,
-				       nSubframe_Length);
-				printk(KERN_INFO "The Packet SeqNum is %d\n", SeqNum);
+				netdev_info(ieee->dev,
+					    "%s: A-MSDU parse error!! pRfd->nTotalSubframe : %d\n",
+					    __func__, rxb->nr_subframes);
+				netdev_info(ieee->dev,
+					    "%s: A-MSDU parse error!! Subframe Length: %d\n",
+					    __func__, nSubframe_Length);
+				netdev_info(ieee->dev,
+					    "nRemain_Length is %d and nSubframe_Length is : %d\n",
+					    skb->len, nSubframe_Length);
+				netdev_info(ieee->dev,
+					    "The Packet SeqNum is %d\n",
+					    SeqNum);
 				return 0;
 			}
 
@@ -858,7 +865,8 @@ static size_t rtllib_rx_get_hdrlen(struct rtllib_device *ieee,
 	hdrlen = rtllib_get_hdrlen(fc);
 	if (HTCCheck(ieee, skb->data)) {
 		if (net_ratelimit())
-			printk(KERN_INFO "%s: find HTCControl!\n", __func__);
+			netdev_info(ieee->dev, "%s: find HTCControl!\n",
+				    __func__);
 		hdrlen += 4;
 		rx_stats->bContainHTC = true;
 	}
@@ -1048,7 +1056,7 @@ static int rtllib_rx_decrypt(struct rtllib_device *ieee, struct sk_buff *skb,
 
 	keyidx = rtllib_rx_frame_decrypt(ieee, skb, crypt);
 	if (ieee->host_decrypt && (fc & RTLLIB_FCTL_WEP) && (keyidx < 0)) {
-		printk(KERN_INFO "%s: decrypt frame error\n", __func__);
+		netdev_info(ieee->dev, "%s: decrypt frame error\n", __func__);
 		return -1;
 	}
 
@@ -1071,8 +1079,9 @@ static int rtllib_rx_decrypt(struct rtllib_device *ieee, struct sk_buff *skb,
 			flen -= hdrlen;
 
 		if (frag_skb->tail + flen > frag_skb->end) {
-			printk(KERN_WARNING "%s: host decrypted and reassembled frame did not fit skb\n",
-			       __func__);
+			netdev_warn(ieee->dev,
+				    "%s: host decrypted and reassembled frame did not fit skb\n",
+				    __func__);
 			rtllib_frag_cache_invalidate(ieee, hdr);
 			return -1;
 		}
@@ -1108,7 +1117,7 @@ static int rtllib_rx_decrypt(struct rtllib_device *ieee, struct sk_buff *skb,
 	 * encrypted/authenticated */
 	if (ieee->host_decrypt && (fc & RTLLIB_FCTL_WEP) &&
 		rtllib_rx_frame_decrypt_msdu(ieee, skb, keyidx, crypt)) {
-		printk(KERN_INFO "%s: ==>decrypt msdu error\n", __func__);
+		netdev_info(ieee->dev, "%s: ==>decrypt msdu error\n", __func__);
 		return -1;
 	}
 
@@ -1148,7 +1157,7 @@ static int rtllib_rx_decrypt(struct rtllib_device *ieee, struct sk_buff *skb,
 	}
 
 	if (rtllib_is_eapol_frame(ieee, skb, hdrlen))
-		printk(KERN_WARNING "RX: IEEE802.1X EAPOL frame!\n");
+		netdev_warn(ieee->dev, "RX: IEEE802.1X EAPOL frame!\n");
 
 	return 0;
 }
@@ -1180,7 +1189,7 @@ static void rtllib_rx_indicate_pkt_legacy(struct rtllib_device *ieee,
 	int i = 0;
 
 	if (rxb == NULL) {
-		printk(KERN_INFO "%s: rxb is NULL!!\n", __func__);
+		netdev_info(dev, "%s: rxb is NULL!!\n", __func__);
 		return;
 	}
 
@@ -1261,7 +1270,8 @@ static int rtllib_rx_InfraAdhoc(struct rtllib_device *ieee, struct sk_buff *skb,
 	/*Filter pkt has too small length */
 	hdrlen = rtllib_rx_get_hdrlen(ieee, skb, rx_stats);
 	if (skb->len < hdrlen) {
-		printk(KERN_INFO "%s():ERR!!! skb->len is smaller than hdrlen\n", __func__);
+		netdev_info(dev, "%s():ERR!!! skb->len is smaller than hdrlen\n",
+			    __func__);
 		goto rx_dropped;
 	}
 
@@ -1404,13 +1414,16 @@ static int rtllib_rx_Monitor(struct rtllib_device *ieee, struct sk_buff *skb,
 	size_t hdrlen = rtllib_get_hdrlen(fc);
 
 	if (skb->len < hdrlen) {
-		printk(KERN_INFO "%s():ERR!!! skb->len is smaller than hdrlen\n", __func__);
+		netdev_info(ieee->dev,
+			    "%s():ERR!!! skb->len is smaller than hdrlen\n",
+			    __func__);
 		return 0;
 	}
 
 	if (HTCCheck(ieee, skb->data)) {
 		if (net_ratelimit())
-			printk(KERN_INFO "%s: Find HTCControl!\n", __func__);
+			netdev_info(ieee->dev, "%s: Find HTCControl!\n",
+				    __func__);
 		hdrlen += 4;
 	}
 
@@ -1436,11 +1449,11 @@ int rtllib_rx(struct rtllib_device *ieee, struct sk_buff *skb,
 	int ret = 0;
 
 	if ((NULL == ieee) || (NULL == skb) || (NULL == rx_stats)) {
-		printk(KERN_INFO "%s: Input parameters NULL!\n", __func__);
+		pr_info("%s: Input parameters NULL!\n", __func__);
 		goto rx_dropped;
 	}
 	if (skb->len < 10) {
-		printk(KERN_INFO "%s: SKB length < 10\n", __func__);
+		netdev_info(ieee->dev, "%s: SKB length < 10\n", __func__);
 		goto rx_dropped;
 	}
 
@@ -1460,7 +1473,7 @@ int rtllib_rx(struct rtllib_device *ieee, struct sk_buff *skb,
 		ret = rtllib_rx_Mesh(ieee, skb, rx_stats);
 		break;
 	default:
-		printk(KERN_INFO"%s: ERR iw mode!!!\n", __func__);
+		netdev_info(ieee->dev, "%s: ERR iw mode!!!\n", __func__);
 		break;
 	}
 
@@ -1701,7 +1714,9 @@ static inline void rtllib_extract_country_ie(
 
 			if (!IS_COUNTRY_IE_VALID(ieee)) {
 				if (rtllib_act_scanning(ieee, false) && ieee->FirstIe_InScan)
-					printk(KERN_INFO "Received beacon ContryIE, SSID: <%s>\n", network->ssid);
+					netdev_info(ieee->dev,
+						    "Received beacon ContryIE, SSID: <%s>\n",
+						    network->ssid);
 				Dot11d_UpdateCountryIe(ieee, addr2, info_element->len, info_element->data);
 			}
 		}
@@ -2138,8 +2153,8 @@ int rtllib_parse_info_param(struct rtllib_device *ieee,
 			}
 			break;
 		case MFIE_TYPE_QOS_PARAMETER:
-			printk(KERN_ERR
-			       "QoS Error need to parse QOS_PARAMETER IE\n");
+			netdev_err(ieee->dev,
+				   "QoS Error need to parse QOS_PARAMETER IE\n");
 			break;
 
 		case MFIE_TYPE_COUNTRY:
@@ -2418,7 +2433,7 @@ static inline int is_beacon(__le16 fc)
 static int IsPassiveChannel(struct rtllib_device *rtllib, u8 channel)
 {
 	if (MAX_CHANNEL_NUMBER < channel) {
-		printk(KERN_INFO "%s(): Invalid Channel\n", __func__);
+		netdev_info(rtllib->dev, "%s(): Invalid Channel\n", __func__);
 		return 0;
 	}
 
@@ -2431,7 +2446,7 @@ static int IsPassiveChannel(struct rtllib_device *rtllib, u8 channel)
 int rtllib_legal_channel(struct rtllib_device *rtllib, u8 channel)
 {
 	if (MAX_CHANNEL_NUMBER < channel) {
-		printk(KERN_INFO "%s(): Invalid Channel\n", __func__);
+		netdev_info(rtllib->dev, "%s(): Invalid Channel\n", __func__);
 		return 0;
 	}
 	if (rtllib->active_channel_map[channel] > 0)
@@ -2497,8 +2512,9 @@ static inline void rtllib_process_probe_response(
 	if (WLAN_FC_GET_STYPE(le16_to_cpu(beacon->header.frame_ctl)) ==
 	    RTLLIB_STYPE_PROBE_RESP) {
 		if (IsPassiveChannel(ieee, network->channel)) {
-			printk(KERN_INFO "GetScanInfo(): For Global Domain, filter probe response at channel(%d).\n",
-			       network->channel);
+			netdev_info(ieee->dev,
+				    "GetScanInfo(): For Global Domain, filter probe response at channel(%d).\n",
+				    network->channel);
 			goto free_network;
 		}
 	}

commit dc986e3ed39830df78a24e5053b3c05acd6f0527
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Tue Mar 17 00:00:49 2015 +0100

    staging: rtl8192e: fix coding style issues (spaces before semicolon)
    
    Fix checkpatch.pl warning 'space prohibited before semicolon'.
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index c1085a5907a2..15f7d3479274 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -1181,7 +1181,7 @@ static void rtllib_rx_indicate_pkt_legacy(struct rtllib_device *ieee,
 
 	if (rxb == NULL) {
 		printk(KERN_INFO "%s: rxb is NULL!!\n", __func__);
-		return ;
+		return;
 	}
 
 	for (i = 0; i < rxb->nr_subframes; i++) {

commit 8b9733c1ad884548ba6417fee239e54693719f41
Author: Vaishali Thakkar <vthakkar1994@gmail.com>
Date:   Wed Mar 11 13:51:36 2015 +0530

    Staging: rtl8192e: Eliminate use of MSECS macro
    
    Use msecs_to_jiffies instead of driver specific macro
    MSECS. This is done using Coccinelle and semantic
    patch used for this is as follows:
    
    @@expression t;@@
    
    - MSECS(t)
    + msecs_to_jiffies(t)
    
    Signed-off-by: Vaishali Thakkar <vthakkar1994@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index e8261aec919f..c1085a5907a2 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -717,7 +717,7 @@ static void RxReorderIndicatePacket(struct rtllib_device *ieee,
 			     __func__);
 		pTS->RxTimeoutIndicateSeq = pTS->RxIndicateSeq;
 		mod_timer(&pTS->RxPktPendingTimer, jiffies +
-			  MSECS(pHTInfo->RxReorderPendingTime));
+			  msecs_to_jiffies(pHTInfo->RxReorderPendingTime));
 	}
 	spin_unlock_irqrestore(&(ieee->reorder_spinlock), flags);
 }

commit d009f0d7ae38bf1fdc0ff1a914a6dee538059869
Author: Darshana Padmadas <darshanapadmadas@gmail.com>
Date:   Sun Mar 8 23:33:40 2015 +0530

    staging: rtl8192e: Replace min with min_t
    
    This patch replaces min with min_t and eliminates the
    following warnings found by checkpatch.pl:
    
    WARNING: min() should probably be min_t
    
    Signed-off-by: Darshana Padmadas <darshanapadmadas@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index d640420f0076..e8261aec919f 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -1904,7 +1904,7 @@ int rtllib_parse_info_param(struct rtllib_device *ieee,
 				   info_element->data[2] == 0x4c &&
 				   info_element->data[3] == 0x033) {
 
-						tmp_htcap_len = min(info_element->len, (u8)MAX_IE_LEN);
+						tmp_htcap_len = min_t(u8, info_element->len, MAX_IE_LEN);
 						if (tmp_htcap_len != 0) {
 							network->bssht.bdHTSpecVer = HT_SPEC_VER_EWC;
 							network->bssht.bdHTCapLen = tmp_htcap_len > sizeof(network->bssht.bdHTCapBuf) ?
@@ -1928,7 +1928,7 @@ int rtllib_parse_info_param(struct rtllib_device *ieee,
 				    info_element->data[1] == 0x90 &&
 				    info_element->data[2] == 0x4c &&
 				    info_element->data[3] == 0x034) {
-					tmp_htinfo_len = min(info_element->len, (u8)MAX_IE_LEN);
+					tmp_htinfo_len = min_t(u8, info_element->len, MAX_IE_LEN);
 					if (tmp_htinfo_len != 0) {
 						network->bssht.bdHTSpecVer = HT_SPEC_VER_EWC;
 						if (tmp_htinfo_len) {
@@ -1949,7 +1949,7 @@ int rtllib_parse_info_param(struct rtllib_device *ieee,
 					    info_element->data[1] == 0xe0 &&
 					    info_element->data[2] == 0x4c &&
 					    info_element->data[3] == 0x02) {
-						ht_realtek_agg_len = min(info_element->len, (u8)MAX_IE_LEN);
+						ht_realtek_agg_len = min_t(u8, info_element->len, MAX_IE_LEN);
 						memcpy(ht_realtek_agg_buf, info_element->data, info_element->len);
 					}
 					if (ht_realtek_agg_len >= 5) {
@@ -2079,7 +2079,7 @@ int rtllib_parse_info_param(struct rtllib_device *ieee,
 		case MFIE_TYPE_HT_CAP:
 			RTLLIB_DEBUG_SCAN("MFIE_TYPE_HT_CAP: %d bytes\n",
 					     info_element->len);
-			tmp_htcap_len = min(info_element->len, (u8)MAX_IE_LEN);
+			tmp_htcap_len = min_t(u8, info_element->len, MAX_IE_LEN);
 			if (tmp_htcap_len != 0) {
 				network->bssht.bdHTSpecVer = HT_SPEC_VER_EWC;
 				network->bssht.bdHTCapLen = tmp_htcap_len > sizeof(network->bssht.bdHTCapBuf) ?
@@ -2106,7 +2106,7 @@ int rtllib_parse_info_param(struct rtllib_device *ieee,
 		case MFIE_TYPE_HT_INFO:
 			RTLLIB_DEBUG_SCAN("MFIE_TYPE_HT_INFO: %d bytes\n",
 					     info_element->len);
-			tmp_htinfo_len = min(info_element->len, (u8)MAX_IE_LEN);
+			tmp_htinfo_len = min_t(u8, info_element->len, MAX_IE_LEN);
 			if (tmp_htinfo_len) {
 				network->bssht.bdHTSpecVer = HT_SPEC_VER_IEEE;
 				network->bssht.bdHTInfoLen = tmp_htinfo_len >

commit ad22d55c4b304a163c7372c00768f50adaecc686
Author: Matteo Semenzato <mattew8898@gmail.com>
Date:   Wed Mar 4 19:53:10 2015 +0100

    Staging: rtl8192e: remove assignment of function parameter
    
    This patch removes the assignment of a function parameter that has no
    effect.
    
    Signed-off-by: Matteo Semenzato <mattew8898@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index 0a9cf445a0ef..d640420f0076 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -1225,7 +1225,6 @@ static void rtllib_rx_indicate_pkt_legacy(struct rtllib_device *ieee,
 		}
 	}
 	kfree(rxb);
-	rxb = NULL;
 }
 
 static int rtllib_rx_InfraAdhoc(struct rtllib_device *ieee, struct sk_buff *skb,

commit b6b0012c2d410704782301299d36d311f9a39334
Author: Quentin Lambert <lambert.quentin@gmail.com>
Date:   Thu Mar 5 14:12:15 2015 +0100

    staging: rtl8192e: Remove unnecessary OOM message
    
    This patch reduces the kernel size by removing error messages that duplicate
    the normal OOM message.
    
    A simplified version of the semantic patch that finds this problem is as
    follows: (http://coccinelle.lip6.fr)
    
    @@
    identifier f,print,l;
    expression e;
    constant char[] c;
    @@
    
    e = \(kzalloc\|kmalloc\|devm_kzalloc\|devm_kmalloc\)(...);
    if (e == NULL) {
      <+...
    -  print(...,c,...);
      ... when any
    (
      goto l;
    |
      return ...;
    )
      ...+> }
    
    Signed-off-by: Quentin Lambert <lambert.quentin@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index 1664040efdab..0a9cf445a0ef 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -394,10 +394,9 @@ static int is_duplicate_packet(struct rtllib_device *ieee,
 		}
 		if (p == &ieee->ibss_mac_hash[index]) {
 			entry = kmalloc(sizeof(struct ieee_ibss_seq), GFP_ATOMIC);
-			if (!entry) {
-				printk(KERN_WARNING "Cannot malloc new mac entry\n");
+			if (!entry)
 				return 0;
-			}
+
 			memcpy(entry->mac, mac, ETH_ALEN);
 			entry->seq_num[tid] = seq;
 			entry->frag_num[tid] = frag;
@@ -1345,11 +1344,9 @@ static int rtllib_rx_InfraAdhoc(struct rtllib_device *ieee, struct sk_buff *skb,
 	/* skb: hdr + (possible reassembled) full plaintext payload */
 	payload = skb->data + hdrlen;
 	rxb = kmalloc(sizeof(struct rtllib_rxb), GFP_ATOMIC);
-	if (rxb == NULL) {
-		RTLLIB_DEBUG(RTLLIB_DL_ERR,
-			     "%s(): kmalloc rxb error\n", __func__);
+	if (rxb == NULL)
 		goto rx_dropped;
-	}
+
 	/* to parse amsdu packets */
 	/* qos data packets & reserved bit is 1 */
 	if (parse_subframe(ieee, skb, rx_stats, rxb, src, dst) == 0) {

commit b5133fde1b7f9d9d5af40293b4c588c15e33d534
Author: Rickard Strandqvist <rickard_strandqvist@spectrumdigital.se>
Date:   Sun Dec 21 18:53:37 2014 +0100

    staging: rtl8192e: rtllib_rx.c: Remove some unused functions
    
    Removes some functions that are not used anywhere:
    update_ibss_network() rtllib_SignalStrengthTranslate()
    
    This was partially found by using a static code analysis program called cppcheck.
    
    Signed-off-by: Rickard Strandqvist <rickard_strandqvist@spectrumdigital.se>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index fdc349eb602c..1664040efdab 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -2176,34 +2176,6 @@ int rtllib_parse_info_param(struct rtllib_device *ieee,
 	return 0;
 }
 
-static inline u8 rtllib_SignalStrengthTranslate(u8  CurrSS)
-{
-	u8 RetSS;
-
-	if (CurrSS >= 71 && CurrSS <= 100)
-		RetSS = 90 + ((CurrSS - 70) / 3);
-	else if (CurrSS >= 41 && CurrSS <= 70)
-		RetSS = 78 + ((CurrSS - 40) / 3);
-	else if (CurrSS >= 31 && CurrSS <= 40)
-		RetSS = 66 + (CurrSS - 30);
-	else if (CurrSS >= 21 && CurrSS <= 30)
-		RetSS = 54 + (CurrSS - 20);
-	else if (CurrSS >= 5 && CurrSS <= 20)
-		RetSS = 42 + (((CurrSS - 5) * 2) / 3);
-	else if (CurrSS == 4)
-		RetSS = 36;
-	else if (CurrSS == 3)
-		RetSS = 27;
-	else if (CurrSS == 2)
-		RetSS = 18;
-	else if (CurrSS == 1)
-		RetSS = 9;
-	else
-		RetSS = CurrSS;
-
-	return RetSS;
-}
-
 static long rtllib_translate_todbm(u8 signal_strength_index)
 {
 	long	signal_power;
@@ -2331,13 +2303,6 @@ static inline int is_same_network(struct rtllib_network *src,
 		(dst->capability & WLAN_CAPABILITY_ESS)));
 }
 
-static inline void update_ibss_network(struct rtllib_network *dst,
-				  struct rtllib_network *src)
-{
-	memcpy(&dst->stats, &src->stats, sizeof(struct rtllib_rx_stats));
-	dst->last_scanned = jiffies;
-}
-
 
 static inline void update_network(struct rtllib_network *dst,
 				  struct rtllib_network *src)

commit 6d6163c3bc35fc5ca4aa4e919c347df06d47372f
Author: Jonathan Jin <jjin082693@gmail.com>
Date:   Mon Dec 15 21:28:23 2014 -0600

    staging: rtl8192e: rejoin split quoted strings
    
    Fix a checkpatch.pl warning regarding quoted string splits across lines.
    While each join of these quoted strings results in a new checkpatch.pl
    "lines over 80 characters" warning, the regained ability to grep for
    these log strings in the codebase is, I would argue, well worth the
    trade-off.
    
    Signed-off-by: Jonathan Jin <jjin082693@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index cf11b042b93a..fdc349eb602c 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -70,8 +70,7 @@ rtllib_frag_cache_find(struct rtllib_device *ieee, unsigned int seq,
 		if (entry->skb != NULL &&
 		    time_after(jiffies, entry->first_frag_time + 2 * HZ)) {
 			RTLLIB_DEBUG_FRAG(
-				"expiring fragment cache entry "
-				"seq=%u last_frag=%u\n",
+				"expiring fragment cache entry seq=%u last_frag=%u\n",
 				entry->seq, entry->last_frag);
 			dev_kfree_skb_any(entry->skb);
 			entry->skb = NULL;
@@ -188,8 +187,7 @@ static int rtllib_frag_cache_invalidate(struct rtllib_device *ieee,
 
 	if (entry == NULL) {
 		RTLLIB_DEBUG_FRAG(
-			"could not invalidate fragment cache "
-			"entry (seq=%u)\n", seq);
+			"could not invalidate fragment cache entry (seq=%u)\n", seq);
 		return -1;
 	}
 
@@ -305,11 +303,9 @@ rtllib_rx_frame_decrypt(struct rtllib_device *ieee, struct sk_buff *skb,
 	atomic_dec(&crypt->refcnt);
 	if (res < 0) {
 		RTLLIB_DEBUG_DROP(
-			"decryption failed (SA= %pM"
-			") res=%d\n", hdr->addr2, res);
+			"decryption failed (SA= %pM) res=%d\n", hdr->addr2, res);
 		if (res == -2)
-			RTLLIB_DEBUG_DROP("Decryption failed ICV "
-					     "mismatch (key %d)\n",
+			RTLLIB_DEBUG_DROP("Decryption failed ICV mismatch (key %d)\n",
 					     skb->data[hdrlen + 3] >> 6);
 		ieee->ieee_stats.rx_discards_undecryptable++;
 		return -1;
@@ -345,8 +341,7 @@ rtllib_rx_frame_decrypt_msdu(struct rtllib_device *ieee, struct sk_buff *skb,
 	res = crypt->ops->decrypt_msdu(skb, keyidx, hdrlen, crypt->priv);
 	atomic_dec(&crypt->refcnt);
 	if (res < 0) {
-		printk(KERN_DEBUG "%s: MSDU decryption/MIC verification failed"
-		       " (SA= %pM keyidx=%d)\n",
+		printk(KERN_DEBUG "%s: MSDU decryption/MIC verification failed (SA= %pM keyidx=%d)\n",
 		       ieee->dev->name, hdr->addr2, keyidx);
 		return -1;
 	}
@@ -559,8 +554,7 @@ static void RxReorderIndicatePacket(struct rtllib_device *ieee,
 	bool bMatchWinStart = false, bPktInBuf = false;
 	unsigned long flags;
 
-	RTLLIB_DEBUG(RTLLIB_DL_REORDER, "%s(): Seq is %d, pTS->RxIndicateSeq"
-		     " is %d, WinSize is %d\n", __func__, SeqNum,
+	RTLLIB_DEBUG(RTLLIB_DL_REORDER, "%s(): Seq is %d, pTS->RxIndicateSeq is %d, WinSize is %d\n", __func__, SeqNum,
 		     pTS->RxIndicateSeq, WinSize);
 
 	spin_lock_irqsave(&(ieee->reorder_spinlock), flags);
@@ -600,8 +594,7 @@ static void RxReorderIndicatePacket(struct rtllib_device *ieee,
 			pTS->RxIndicateSeq = SeqNum + 1 - WinSize;
 		else
 			pTS->RxIndicateSeq = 4095 - (WinSize - (SeqNum + 1)) + 1;
-		RTLLIB_DEBUG(RTLLIB_DL_REORDER, "Window Shift! IndicateSeq: %d,"
-			     " NewSeq: %d\n", pTS->RxIndicateSeq, SeqNum);
+		RTLLIB_DEBUG(RTLLIB_DL_REORDER, "Window Shift! IndicateSeq: %d, NewSeq: %d\n", pTS->RxIndicateSeq, SeqNum);
 	}
 
 	/*
@@ -617,8 +610,7 @@ static void RxReorderIndicatePacket(struct rtllib_device *ieee,
 	 */
 	if (bMatchWinStart) {
 		/* Current packet is going to be indicated.*/
-		RTLLIB_DEBUG(RTLLIB_DL_REORDER, "Packets indication!! "
-				"IndicateSeq: %d, NewSeq: %d\n",
+		RTLLIB_DEBUG(RTLLIB_DL_REORDER, "Packets indication!! IndicateSeq: %d, NewSeq: %d\n",
 				pTS->RxIndicateSeq, SeqNum);
 		ieee->prxbIndicateArray[0] = prxb;
 		index = 1;
@@ -636,9 +628,7 @@ static void RxReorderIndicatePacket(struct rtllib_device *ieee,
 
 			if (!AddReorderEntry(pTS, pReorderEntry)) {
 				RTLLIB_DEBUG(RTLLIB_DL_REORDER,
-					     "%s(): Duplicate packet is "
-					     "dropped!! IndicateSeq: %d, "
-					     "NewSeq: %d\n",
+					     "%s(): Duplicate packet is dropped!! IndicateSeq: %d, NewSeq: %d\n",
 					    __func__, pTS->RxIndicateSeq,
 					    SeqNum);
 				list_add_tail(&pReorderEntry->List,
@@ -652,8 +642,7 @@ static void RxReorderIndicatePacket(struct rtllib_device *ieee,
 				}
 			} else {
 				RTLLIB_DEBUG(RTLLIB_DL_REORDER,
-					 "Pkt insert into struct buffer!! "
-					 "IndicateSeq: %d, NewSeq: %d\n",
+					 "Pkt insert into struct buffer!! IndicateSeq: %d, NewSeq: %d\n",
 					 pTS->RxIndicateSeq, SeqNum);
 			}
 		} else {
@@ -663,9 +652,7 @@ static void RxReorderIndicatePacket(struct rtllib_device *ieee,
 			 * indicate all the packets in struct buffer and get
 			 * reorder entries.
 			 */
-			RTLLIB_DEBUG(RTLLIB_DL_ERR, "RxReorderIndicatePacket():"
-				     " There is no reorder entry!! Packet is "
-				     "dropped!!\n");
+			RTLLIB_DEBUG(RTLLIB_DL_ERR, "RxReorderIndicatePacket(): There is no reorder entry!! Packet is dropped!!\n");
 			{
 				int i;
 
@@ -687,8 +674,7 @@ static void RxReorderIndicatePacket(struct rtllib_device *ieee,
 				SN_EQUAL(pReorderEntry->SeqNum, pTS->RxIndicateSeq)) {
 			/* This protect struct buffer from overflow. */
 			if (index >= REORDER_WIN_SIZE) {
-				RTLLIB_DEBUG(RTLLIB_DL_ERR, "RxReorderIndicate"
-					     "Packet(): Buffer overflow!!\n");
+				RTLLIB_DEBUG(RTLLIB_DL_ERR, "RxReorderIndicatePacket(): Buffer overflow!!\n");
 				bPktInBuf = true;
 				break;
 			}
@@ -699,8 +685,7 @@ static void RxReorderIndicatePacket(struct rtllib_device *ieee,
 				pTS->RxIndicateSeq = (pTS->RxIndicateSeq + 1) % 4096;
 
 			ieee->prxbIndicateArray[index] = pReorderEntry->prxb;
-			RTLLIB_DEBUG(RTLLIB_DL_REORDER, "%s(): Indicate SeqNum"
-				     " %d!\n", __func__, pReorderEntry->SeqNum);
+			RTLLIB_DEBUG(RTLLIB_DL_REORDER, "%s(): Indicate SeqNum %d!\n", __func__, pReorderEntry->SeqNum);
 			index++;
 
 			list_add_tail(&pReorderEntry->List,
@@ -719,8 +704,7 @@ static void RxReorderIndicatePacket(struct rtllib_device *ieee,
 		pTS->RxTimeoutIndicateSeq = 0xffff;
 
 		if (index > REORDER_WIN_SIZE) {
-			RTLLIB_DEBUG(RTLLIB_DL_ERR, "RxReorderIndicatePacket():"
-				     " Rx Reorder struct buffer full!!\n");
+			RTLLIB_DEBUG(RTLLIB_DL_ERR, "RxReorderIndicatePacket(): Rx Reorder struct buffer full!!\n");
 			spin_unlock_irqrestore(&(ieee->reorder_spinlock),
 					       flags);
 			return;
@@ -809,14 +793,11 @@ static u8 parse_subframe(struct rtllib_device *ieee, struct sk_buff *skb,
 					   (nSubframe_Length << 8);
 
 			if (skb->len < (ETHERNET_HEADER_SIZE + nSubframe_Length)) {
-				printk(KERN_INFO "%s: A-MSDU parse error!! "
-				       "pRfd->nTotalSubframe : %d\n",\
+				printk(KERN_INFO "%s: A-MSDU parse error!! pRfd->nTotalSubframe : %d\n",\
 				       __func__, rxb->nr_subframes);
-				printk(KERN_INFO "%s: A-MSDU parse error!! "
-				       "Subframe Length: %d\n", __func__,
+				printk(KERN_INFO "%s: A-MSDU parse error!! Subframe Length: %d\n", __func__,
 				       nSubframe_Length);
-				printk(KERN_INFO "nRemain_Length is %d and "
-				       "nSubframe_Length is : %d\n", skb->len,
+				printk(KERN_INFO "nRemain_Length is %d and nSubframe_Length is : %d\n", skb->len,
 				       nSubframe_Length);
 				printk(KERN_INFO "The Packet SeqNum is %d\n", SeqNum);
 				return 0;
@@ -844,8 +825,7 @@ static u8 parse_subframe(struct rtllib_device *ieee, struct sk_buff *skb,
 			sub_skb->dev = ieee->dev;
 			rxb->subframes[rxb->nr_subframes++] = sub_skb;
 			if (rxb->nr_subframes >= MAX_SUBFRAME_COUNT) {
-				RTLLIB_DEBUG_RX("ParseSubframe(): Too many "
-						"Subframes! Packets dropped!\n");
+				RTLLIB_DEBUG_RX("ParseSubframe(): Too many Subframes! Packets dropped!\n");
 				break;
 			}
 			skb_pull(skb, nSubframe_Length);
@@ -922,8 +902,7 @@ static int rtllib_rx_check_duplicate(struct rtllib_device *ieee,
 			pRxTS->RxLastFragNum = frag;
 			pRxTS->RxLastSeqNum = WLAN_GET_SEQ_SEQ(sc);
 		} else {
-			RTLLIB_DEBUG(RTLLIB_DL_ERR, "ERR!!%s(): No TS!! Skip"
-				     " the check!!\n", __func__);
+			RTLLIB_DEBUG(RTLLIB_DL_ERR, "ERR!!%s(): No TS!! Skip the check!!\n", __func__);
 			return -1;
 		}
 	}
@@ -996,9 +975,7 @@ static int rtllib_rx_data_filter(struct rtllib_device *ieee, u16 fc,
 		    stype != RTLLIB_STYPE_QOS_DATA) {
 			if (stype != RTLLIB_STYPE_NULLFUNC)
 				RTLLIB_DEBUG_DROP(
-					"RX: dropped data frame "
-					"with no data (type=0x%02x, "
-					"subtype=0x%02x)\n",
+					"RX: dropped data frame with no data (type=0x%02x, subtype=0x%02x)\n",
 					type, stype);
 			return -1;
 		}
@@ -1041,8 +1018,7 @@ static int rtllib_rx_get_crypt(struct rtllib_device *ieee, struct sk_buff *skb,
 			 * frames from other than current BSS, so just drop the
 			 * frames silently instead of filling system log with
 			 * these reports. */
-			RTLLIB_DEBUG_DROP("Decryption failed (not set)"
-					     " (SA= %pM)\n",
+			RTLLIB_DEBUG_DROP("Decryption failed (not set) (SA= %pM)\n",
 					     hdr->addr2);
 			ieee->ieee_stats.rx_discards_undecryptable++;
 			return -1;
@@ -1086,8 +1062,7 @@ static int rtllib_rx_decrypt(struct rtllib_device *ieee, struct sk_buff *skb,
 
 		if (!frag_skb) {
 			RTLLIB_DEBUG(RTLLIB_DL_RX | RTLLIB_DL_FRAG,
-					"Rx cannot get skb from fragment "
-					"cache (morefrag=%d seq=%u frag=%u)\n",
+					"Rx cannot get skb from fragment cache (morefrag=%d seq=%u frag=%u)\n",
 					(fc & RTLLIB_FCTL_MOREFRAGS) != 0,
 					WLAN_GET_SEQ_SEQ(sc), frag);
 			return -1;
@@ -1097,8 +1072,7 @@ static int rtllib_rx_decrypt(struct rtllib_device *ieee, struct sk_buff *skb,
 			flen -= hdrlen;
 
 		if (frag_skb->tail + flen > frag_skb->end) {
-			printk(KERN_WARNING "%s: host decrypted and "
-			       "reassembled frame did not fit skb\n",
+			printk(KERN_WARNING "%s: host decrypted and reassembled frame did not fit skb\n",
 			       __func__);
 			rtllib_frag_cache_invalidate(ieee, hdr);
 			return -1;
@@ -1152,8 +1126,7 @@ static int rtllib_rx_decrypt(struct rtllib_device *ieee, struct sk_buff *skb,
 						eap_get_type(eap->type));
 		} else {
 			RTLLIB_DEBUG_DROP(
-				"encryption configured, but RX "
-				"frame not encrypted (SA= %pM)\n",
+				"encryption configured, but RX frame not encrypted (SA= %pM)\n",
 				hdr->addr2);
 			return -1;
 		}
@@ -1170,9 +1143,7 @@ static int rtllib_rx_decrypt(struct rtllib_device *ieee, struct sk_buff *skb,
 	if (crypt && !(fc & RTLLIB_FCTL_WEP) && !ieee->open_wep &&
 	    !rtllib_is_eapol_frame(ieee, skb, hdrlen)) {
 		RTLLIB_DEBUG_DROP(
-			"dropped unencrypted RX data "
-			"frame from %pM"
-			" (drop_unencrypted=1)\n",
+			"dropped unencrypted RX data frame from %pM (drop_unencrypted=1)\n",
 			hdr->addr2);
 		return -1;
 	}
@@ -1762,9 +1733,7 @@ int rtllib_parse_info_param(struct rtllib_device *ieee,
 
 	while (length >= sizeof(*info_element)) {
 		if (sizeof(*info_element) + info_element->len > length) {
-			RTLLIB_DEBUG_MGMT("Info elem: parse failed: "
-					     "info_element->len + 2 > left : "
-					     "info_element->len+2=%zd left=%d, id=%d.\n",
+			RTLLIB_DEBUG_MGMT("Info elem: parse failed: info_element->len + 2 > left : info_element->len+2=%zd left=%d, id=%d.\n",
 					     info_element->len +
 					     sizeof(*info_element),
 					     length, info_element->id);
@@ -2321,8 +2290,7 @@ static inline int rtllib_network_init(
 	}
 
 	if (network->mode == 0) {
-		RTLLIB_DEBUG_SCAN("Filtered out '%s (%pM)' "
-				     "network.\n",
+		RTLLIB_DEBUG_SCAN("Filtered out '%s (%pM)' network.\n",
 				     escape_essid(network->ssid,
 						  network->ssid_len),
 				     network->bssid);
@@ -2568,8 +2536,7 @@ static inline void rtllib_process_probe_response(
 	if (WLAN_FC_GET_STYPE(le16_to_cpu(beacon->header.frame_ctl)) ==
 	    RTLLIB_STYPE_PROBE_RESP) {
 		if (IsPassiveChannel(ieee, network->channel)) {
-			printk(KERN_INFO "GetScanInfo(): For Global Domain, "
-			       "filter probe response at channel(%d).\n",
+			printk(KERN_INFO "GetScanInfo(): For Global Domain, filter probe response at channel(%d).\n",
 			       network->channel);
 			goto free_network;
 		}
@@ -2618,8 +2585,7 @@ static inline void rtllib_process_probe_response(
 			/* If there are no more slots, expire the oldest */
 			list_del(&oldest->list);
 			target = oldest;
-			RTLLIB_DEBUG_SCAN("Expired '%s' ( %pM) from "
-					     "network list.\n",
+			RTLLIB_DEBUG_SCAN("Expired '%s' ( %pM) from network list.\n",
 					     escape_essid(target->ssid,
 							  target->ssid_len),
 					     target->bssid);

commit 73df998683eaddffca8c29ea74a339abac68e939
Author: Athira Lekshmi <andnlnbn18@gmail.com>
Date:   Fri Nov 28 18:26:13 2014 +0530

    Drivers:staging:rtl8192e: Fixed checkpatch warning
    
    Fixed checkpatch warning:
    WARNING: space prohibited before semicolon
    
    Signed-off-by: Athira Lekshmi <andnlnbn18@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index ca76ad013f5f..cf11b042b93a 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -2687,7 +2687,7 @@ void rtllib_rx_mgt(struct rtllib_device *ieee,
 		      struct sk_buff *skb,
 		      struct rtllib_rx_stats *stats)
 {
-	struct rtllib_hdr_4addr *header = (struct rtllib_hdr_4addr *)skb->data ;
+	struct rtllib_hdr_4addr *header = (struct rtllib_hdr_4addr *)skb->data;
 
 	if ((WLAN_FC_GET_STYPE(le16_to_cpu(header->frame_ctl)) !=
 	    RTLLIB_STYPE_PROBE_RESP) &&

commit f14557f93620f78adcf419f1adaa281947a5101d
Author: Tapasweni Pathak <tapaswenipathak@gmail.com>
Date:   Fri Oct 24 21:45:26 2014 +0530

    staging: rtl8192e: Remove unnecessary code
    
    kfree on NULL pointer is a no-op.
    
    This used the following semantic patch to identify such a instance
    
    // <smpl>
    @@ expression E; @@
    - if (E != NULL) { kfree(E); }
    + kfree(E);
    @@ expression E; @@
    - if (E != NULL) { kfree(E); E = NULL; }
    + kfree(E);
    + E = NULL;
    // </smpl>
    
    As rxb is always null at this point, so the code to kfree it and intializing
    it to NULL is removed completely.
    
    Suggested by: Julia Lawall <julia.lawall@lip6.fr>
    Signed-off-by: Tapasweni Pathak <tapaswenipathak@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index 1c2014fd8d81..ca76ad013f5f 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -1415,10 +1415,6 @@ static int rtllib_rx_InfraAdhoc(struct rtllib_device *ieee, struct sk_buff *skb,
 	return 1;
 
  rx_dropped:
-	if (rxb != NULL) {
-		kfree(rxb);
-		rxb = NULL;
-	}
 	ieee->stats.rx_dropped++;
 
 	/* Returning 0 indicates to caller that we have not handled the SKB--

commit 3f76a4ea5383ba2f9e76f9625f77ff246907a134
Author: Mahati Chamarthy <mahati.chamarthy@gmail.com>
Date:   Thu Sep 18 19:27:09 2014 +0530

    Staging: rtl8192e: Fix __constant_htons to htons style warning
    
    This fixes the following checkpatch.pl warning:
    WARNING: __constant_htons should be htons
    
    Signed-off-by: Mahati Chamarthy <mahati.chamarthy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index 8f4f5893303b..1c2014fd8d81 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -52,7 +52,7 @@ static inline void rtllib_monitor_rx(struct rtllib_device *ieee,
 	skb_reset_mac_header(skb);
 	skb_pull(skb, hdr_length);
 	skb->pkt_type = PACKET_OTHERHOST;
-	skb->protocol = __constant_htons(ETH_P_80211_RAW);
+	skb->protocol = htons(ETH_P_80211_RAW);
 	memset(skb->cb, 0, sizeof(skb->cb));
 	netif_rx(skb);
 }

commit 59422a74b55c616d500c3be721077ff0d00f7fb0
Author: Mahati Chamarthy <mahati.chamarthy@gmail.com>
Date:   Fri Sep 19 23:12:53 2014 +0530

    Staging: rtl8192e: Fix else is not useful style warning
    
    This fixes the following checkpatch.pl warnings:
    WARNING: else is not generally useful after a break or return
    
    Signed-off-by: Mahati Chamarthy <mahati.chamarthy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index 9ded5417f5b6..8f4f5893303b 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -917,12 +917,10 @@ static int rtllib_rx_check_duplicate(struct rtllib_device *ieee,
 		if (GetTs(ieee, (struct ts_common_info **) &pRxTS, hdr->addr2,
 			(u8)Frame_QoSTID((u8 *)(skb->data)), RX_DIR, true)) {
 			if ((fc & (1<<11)) && (frag == pRxTS->RxLastFragNum) &&
-			    (WLAN_GET_SEQ_SEQ(sc) == pRxTS->RxLastSeqNum)) {
+			    (WLAN_GET_SEQ_SEQ(sc) == pRxTS->RxLastSeqNum))
 				return -1;
-			} else {
-				pRxTS->RxLastFragNum = frag;
-				pRxTS->RxLastSeqNum = WLAN_GET_SEQ_SEQ(sc);
-			}
+			pRxTS->RxLastFragNum = frag;
+			pRxTS->RxLastSeqNum = WLAN_GET_SEQ_SEQ(sc);
 		} else {
 			RTLLIB_DEBUG(RTLLIB_DL_ERR, "ERR!!%s(): No TS!! Skip"
 				     " the check!!\n", __func__);

commit 3a6b70c3f3558a2e47d2ca82752f0aed0f3c33c6
Author: Matthew Casey <mdcasey@chabloom.com>
Date:   Fri Aug 22 06:27:52 2014 -0400

    staging: rtl8192e: fixed coding style issues
    
    Fixed missing blank line after declarations issues
    
    Signed-off-by: Matthew Casey <mdcasey@chabloom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index 7db3e7445428..9ded5417f5b6 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -290,6 +290,7 @@ rtllib_rx_frame_decrypt(struct rtllib_device *ieee, struct sk_buff *skb,
 
 	if (ieee->hwsec_active) {
 		struct cb_desc *tcb_desc = (struct cb_desc *)(skb->cb + MAX_DEV_ADDR_SIZE);
+
 		tcb_desc->bHwSec = 1;
 
 		if (ieee->need_sw_enc)
@@ -330,6 +331,7 @@ rtllib_rx_frame_decrypt_msdu(struct rtllib_device *ieee, struct sk_buff *skb,
 		return 0;
 	if (ieee->hwsec_active) {
 		struct cb_desc *tcb_desc = (struct cb_desc *)(skb->cb + MAX_DEV_ADDR_SIZE);
+
 		tcb_desc->bHwSec = 1;
 
 		if (ieee->need_sw_enc)
@@ -389,6 +391,7 @@ static int is_duplicate_packet(struct rtllib_device *ieee,
 		struct ieee_ibss_seq *entry = NULL;
 		u8 *mac = header->addr2;
 		int index = mac[5] % IEEE_IBSS_MAC_HASH_SIZE;
+
 		list_for_each(p, &ieee->ibss_mac_hash[index]) {
 			entry = list_entry(p, struct ieee_ibss_seq, list);
 			if (!memcmp(entry->mac, mac, ETH_ALEN))
@@ -471,8 +474,10 @@ void rtllib_indicate_packets(struct rtllib_device *ieee, struct rtllib_rxb **prx
 	struct net_device_stats *stats = &ieee->stats;
 	u8 i = 0 , j = 0;
 	u16 ethertype;
+
 	for (j = 0; j < index; j++) {
 		struct rtllib_rxb *prxb = prxbIndicateArray[j];
+
 		for (i = 0; i < prxb->nr_subframes; i++) {
 			struct sk_buff *sub_skb = prxb->subframes[i];
 
@@ -572,6 +577,7 @@ static void RxReorderIndicatePacket(struct rtllib_device *ieee,
 		pHTInfo->RxReorderDropCounter++;
 		{
 			int i;
+
 			for (i = 0; i < prxb->nr_subframes; i++)
 				dev_kfree_skb(prxb->subframes[i]);
 			kfree(prxb);
@@ -638,6 +644,7 @@ static void RxReorderIndicatePacket(struct rtllib_device *ieee,
 				list_add_tail(&pReorderEntry->List,
 					      &ieee->RxReorder_Unused_List); {
 					int i;
+
 					for (i = 0; i < prxb->nr_subframes; i++)
 						dev_kfree_skb(prxb->subframes[i]);
 					kfree(prxb);
@@ -661,6 +668,7 @@ static void RxReorderIndicatePacket(struct rtllib_device *ieee,
 				     "dropped!!\n");
 			{
 				int i;
+
 				for (i = 0; i < prxb->nr_subframes; i++)
 					dev_kfree_skb(prxb->subframes[i]);
 				kfree(prxb);
@@ -905,6 +913,7 @@ static int rtllib_rx_check_duplicate(struct rtllib_device *ieee,
 		}
 	} else {
 		struct rx_ts_record *pRxTS = NULL;
+
 		if (GetTs(ieee, (struct ts_common_info **) &pRxTS, hdr->addr2,
 			(u8)Frame_QoSTID((u8 *)(skb->data)), RX_DIR, true)) {
 			if ((fc & (1<<11)) && (frag == pRxTS->RxLastFragNum) &&
@@ -1074,6 +1083,7 @@ static int rtllib_rx_decrypt(struct rtllib_device *ieee, struct sk_buff *skb,
 	if ((frag != 0 || (fc & RTLLIB_FCTL_MOREFRAGS))) {
 		int flen;
 		struct sk_buff *frag_skb = rtllib_frag_cache_get(ieee, hdr);
+
 		RTLLIB_DEBUG_FRAG("Rx Fragment received (%u)\n", frag);
 
 		if (!frag_skb) {

commit 4fa426021426bb1846b3e86dee74517e481e089f
Author: Emil Goode <emilgoode@gmail.com>
Date:   Wed Jul 2 11:25:51 2014 +0200

    Staging: rtl8192e: Fix potential NULL pointer dereference
    
    We need to make sure the struct rtllib_device pointer ieee is not NULL
    after the goto rx_dropped label since it is dereferenced there.
    
    Signed-off-by: Emil Goode <emilgoode@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index 60de54cc601f..7db3e7445428 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -1496,7 +1496,8 @@ int rtllib_rx(struct rtllib_device *ieee, struct sk_buff *skb,
 	return ret;
 
  rx_dropped:
-	ieee->stats.rx_dropped++;
+	if (ieee)
+		ieee->stats.rx_dropped++;
 	return 0;
 }
 EXPORT_SYMBOL(rtllib_rx);

commit 4764ca981b040048766e4f39a45a4b9c5cecff9c
Author: Peter Senna Tschudin <peter.senna@gmail.com>
Date:   Mon May 26 16:08:50 2014 +0200

    drivers/staging: Remove useless return variables
    
    This patch remove variables that are initialized with a constant,
    are never updated, and are only used as parameter of return.
    Return the constant instead of using a variable.
    
    Verified by compilation only.
    
    The coccinelle script that find and fixes this issue is:
    // <smpl>
    @@
    type T;
    constant C;
    identifier ret;
    @@
    - T ret = C;
    ... when != ret
        when strict
    return
    - ret
    + C
    ;
    // </smpl>
    
    Signed-off-by: Peter Senna Tschudin <peter.senna@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index 7413816dd92b..60de54cc601f 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -1589,7 +1589,6 @@ static int rtllib_qos_convert_ac_to_parameters(struct rtllib_qos_parameter_info
 {
 	struct rtllib_qos_ac_parameter *ac_params;
 	struct rtllib_qos_parameters *qos_param = &(qos_data->parameters);
-	int rc = 0;
 	int i;
 	u8 aci;
 	u8 acm;
@@ -1640,7 +1639,7 @@ static int rtllib_qos_convert_ac_to_parameters(struct rtllib_qos_parameter_info
 		    (ac_params->aci_aifsn & 0x10) ? 0x01 : 0x00;
 		qos_param->tx_op_limit[aci] = ac_params->tx_op_limit;
 	}
-	return rc;
+	return 0;
 }
 
 /*

commit 430fb250902b7d563216077bc018108dd20cf8fa
Author: Masanari Iida <standby24x7@gmail.com>
Date:   Fri Apr 25 01:48:41 2014 +0900

    staging: rtl8192e: Fix typo in rtl8192e
    
    Fix spelling typo in comments within rtl8192e.
    
    Signed-off-by: Masanari Iida <standby24x7@gmail.com>
    Reviewed-by: James Cameron <quozl@laptop.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index 6c8a8e12b2b5..7413816dd92b 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -712,7 +712,7 @@ static void RxReorderIndicatePacket(struct rtllib_device *ieee,
 
 		if (index > REORDER_WIN_SIZE) {
 			RTLLIB_DEBUG(RTLLIB_DL_ERR, "RxReorderIndicatePacket():"
-				     " Rx Reorer struct buffer full!!\n");
+				     " Rx Reorder struct buffer full!!\n");
 			spin_unlock_irqrestore(&(ieee->reorder_spinlock),
 					       flags);
 			return;

commit a0711c4da327de531a9f4af7a40d7043d06771b4
Author: Matthias Schoepe <matthias.schoepe@studium.uni-erlangen.de>
Date:   Thu Dec 26 20:23:32 2013 +0100

    Staging rtl8192e: Fixing checkpatch errors
    
    We fixed checkpatch errors of the following type:
            ERROR: "foo * bar" should be "foo *bar"
    
    The error was fixed in the following files of the rtl8192e staging driver:
            rtllib_softmac.c
            rtllib_rx.c
            rtllib_crypt.c
            rtllib.h
    
    There are no functional changes in this patch.
    
    Signed-off-by: Matthias Schoepe <matthias.schoepe@studium.uni-erlangen.de>
    Signed-off-by: Andreas Frembs <andreas.frembs@studium.uni-erlangen.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index 1fab69d313ba..6c8a8e12b2b5 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -211,7 +211,7 @@ rtllib_rx_frame_mgmt(struct rtllib_device *ieee, struct sk_buff *skb,
 	 * this is not mandatory.... but seems that the probe
 	 * response parser uses it
 	 */
-	struct rtllib_hdr_3addr * hdr = (struct rtllib_hdr_3addr *)skb->data;
+	struct rtllib_hdr_3addr *hdr = (struct rtllib_hdr_3addr *)skb->data;
 
 	rx_stats->len = skb->len;
 	rtllib_rx_mgt(ieee, skb, rx_stats);

commit e0b1ca6055d454d7f4c1fa9c7db5bf5da5a8a885
Author: Rashika Kheria <rashika.kheria@gmail.com>
Date:   Sat Nov 2 23:37:04 2013 +0530

    Staging: rtl8192e: Fix incorrect casting in rtllib_rx.c
    
    This patch fixes the following sparse warning in rtllib_rx.c-
    
    drivers/staging/rtl8192e/rtllib_rx.c:2267:34: warning: cast to restricted __le32
    drivers/staging/rtl8192e/rtllib_rx.c:2268:34: warning: cast to restricted __le32
    drivers/staging/rtl8192e/rtllib_rx.c:2269:36: warning: cast to restricted __le32
    drivers/staging/rtl8192e/rtllib_rx.c:2269:36: warning: cast from restricted __le16
    
    Signed-off-by: Rashika Kheria <rashika.kheria@gmail.com>
    Reviewed-by: Josh Triplett <josh@joshtriplett.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index 6b46af596b35..1fab69d313ba 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -2260,9 +2260,9 @@ static inline int rtllib_network_init(
 	memcpy(network->bssid, beacon->header.addr3, ETH_ALEN);
 	network->capability = le16_to_cpu(beacon->capability);
 	network->last_scanned = jiffies;
-	network->time_stamp[0] = le32_to_cpu(beacon->time_stamp[0]);
-	network->time_stamp[1] = le32_to_cpu(beacon->time_stamp[1]);
-	network->beacon_interval = le32_to_cpu(beacon->beacon_interval);
+	network->time_stamp[0] = beacon->time_stamp[0];
+	network->time_stamp[1] = beacon->time_stamp[1];
+	network->beacon_interval = le16_to_cpu(beacon->beacon_interval);
 	/* Where to pull this? beacon->listen_interval;*/
 	network->listen_interval = 0x0A;
 	network->rates_len = network->rates_ex_len = 0;

commit 26a6b074971cfb8568e2bf1f972c6f7c10c2c749
Author: Rashika Kheria <rashika.kheria@gmail.com>
Date:   Sat Nov 2 23:36:12 2013 +0530

    Staging: rtl8192e: Fix Sparse warning of restricted __le16 degrades to integer in rtllib_rx.c
    
    This patch fixes the following sparse warning in rtllib_rx.c-
    warning: restricted __le16 degrades to integer
    
    Signed-off-by: Rashika Kheria <rashika.kheria@gmail.com>
    Reviewed-by: Josh Triplett <josh@joshtriplett.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index 6aa837e1c512..6b46af596b35 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -2528,29 +2528,30 @@ static inline void rtllib_process_probe_response(
 		"'%s' ( %pM ): %c%c%c%c %c%c%c%c-%c%c%c%c %c%c%c%c\n",
 		escape_essid(info_element->data, info_element->len),
 		beacon->header.addr3,
-		(beacon->capability & (1<<0xf)) ? '1' : '0',
-		(beacon->capability & (1<<0xe)) ? '1' : '0',
-		(beacon->capability & (1<<0xd)) ? '1' : '0',
-		(beacon->capability & (1<<0xc)) ? '1' : '0',
-		(beacon->capability & (1<<0xb)) ? '1' : '0',
-		(beacon->capability & (1<<0xa)) ? '1' : '0',
-		(beacon->capability & (1<<0x9)) ? '1' : '0',
-		(beacon->capability & (1<<0x8)) ? '1' : '0',
-		(beacon->capability & (1<<0x7)) ? '1' : '0',
-		(beacon->capability & (1<<0x6)) ? '1' : '0',
-		(beacon->capability & (1<<0x5)) ? '1' : '0',
-		(beacon->capability & (1<<0x4)) ? '1' : '0',
-		(beacon->capability & (1<<0x3)) ? '1' : '0',
-		(beacon->capability & (1<<0x2)) ? '1' : '0',
-		(beacon->capability & (1<<0x1)) ? '1' : '0',
-		(beacon->capability & (1<<0x0)) ? '1' : '0');
+		(le16_to_cpu(beacon->capability) & (1<<0xf)) ? '1' : '0',
+		(le16_to_cpu(beacon->capability) & (1<<0xe)) ? '1' : '0',
+		(le16_to_cpu(beacon->capability) & (1<<0xd)) ? '1' : '0',
+		(le16_to_cpu(beacon->capability) & (1<<0xc)) ? '1' : '0',
+		(le16_to_cpu(beacon->capability) & (1<<0xb)) ? '1' : '0',
+		(le16_to_cpu(beacon->capability) & (1<<0xa)) ? '1' : '0',
+		(le16_to_cpu(beacon->capability) & (1<<0x9)) ? '1' : '0',
+		(le16_to_cpu(beacon->capability) & (1<<0x8)) ? '1' : '0',
+		(le16_to_cpu(beacon->capability) & (1<<0x7)) ? '1' : '0',
+		(le16_to_cpu(beacon->capability) & (1<<0x6)) ? '1' : '0',
+		(le16_to_cpu(beacon->capability) & (1<<0x5)) ? '1' : '0',
+		(le16_to_cpu(beacon->capability) & (1<<0x4)) ? '1' : '0',
+		(le16_to_cpu(beacon->capability) & (1<<0x3)) ? '1' : '0',
+		(le16_to_cpu(beacon->capability) & (1<<0x2)) ? '1' : '0',
+		(le16_to_cpu(beacon->capability) & (1<<0x1)) ? '1' : '0',
+		(le16_to_cpu(beacon->capability) & (1<<0x0)) ? '1' : '0');
 
 	if (rtllib_network_init(ieee, beacon, network, stats)) {
 		RTLLIB_DEBUG_SCAN("Dropped '%s' ( %pM) via %s.\n",
 				  escape_essid(info_element->data,
 				  info_element->len),
 				  beacon->header.addr3,
-				  WLAN_FC_GET_STYPE(beacon->header.frame_ctl) ==
+				  WLAN_FC_GET_STYPE(
+					  le16_to_cpu(beacon->header.frame_ctl)) ==
 				  RTLLIB_STYPE_PROBE_RESP ?
 				  "PROBE RESPONSE" : "BEACON");
 		goto free_network;
@@ -2560,7 +2561,7 @@ static inline void rtllib_process_probe_response(
 	if (!rtllib_legal_channel(ieee, network->channel))
 		goto free_network;
 
-	if (WLAN_FC_GET_STYPE(beacon->header.frame_ctl) ==
+	if (WLAN_FC_GET_STYPE(le16_to_cpu(beacon->header.frame_ctl)) ==
 	    RTLLIB_STYPE_PROBE_RESP) {
 		if (IsPassiveChannel(ieee, network->channel)) {
 			printk(KERN_INFO "GetScanInfo(): For Global Domain, "
@@ -2629,7 +2630,8 @@ static inline void rtllib_process_probe_response(
 		RTLLIB_DEBUG_SCAN("Adding '%s' ( %pM) via %s.\n",
 				  escape_essid(network->ssid,
 				  network->ssid_len), network->bssid,
-				  WLAN_FC_GET_STYPE(beacon->header.frame_ctl) ==
+				  WLAN_FC_GET_STYPE(
+					  le16_to_cpu(beacon->header.frame_ctl)) ==
 				  RTLLIB_STYPE_PROBE_RESP ?
 				  "PROBE RESPONSE" : "BEACON");
 		memcpy(target, network, sizeof(*target));
@@ -2640,7 +2642,8 @@ static inline void rtllib_process_probe_response(
 		RTLLIB_DEBUG_SCAN("Updating '%s' ( %pM) via %s.\n",
 				  escape_essid(target->ssid,
 				  target->ssid_len), target->bssid,
-				  WLAN_FC_GET_STYPE(beacon->header.frame_ctl) ==
+				  WLAN_FC_GET_STYPE(
+					  le16_to_cpu(beacon->header.frame_ctl)) ==
 				  RTLLIB_STYPE_PROBE_RESP ?
 				  "PROBE RESPONSE" : "BEACON");
 
@@ -2682,15 +2685,17 @@ void rtllib_rx_mgt(struct rtllib_device *ieee,
 {
 	struct rtllib_hdr_4addr *header = (struct rtllib_hdr_4addr *)skb->data ;
 
-	if (WLAN_FC_GET_STYPE(header->frame_ctl) != RTLLIB_STYPE_PROBE_RESP &&
-	    WLAN_FC_GET_STYPE(header->frame_ctl) != RTLLIB_STYPE_BEACON)
+	if ((WLAN_FC_GET_STYPE(le16_to_cpu(header->frame_ctl)) !=
+	    RTLLIB_STYPE_PROBE_RESP) &&
+	    (WLAN_FC_GET_STYPE(le16_to_cpu(header->frame_ctl)) !=
+	    RTLLIB_STYPE_BEACON))
 		ieee->last_rx_ps_time = jiffies;
 
-	switch (WLAN_FC_GET_STYPE(header->frame_ctl)) {
+	switch (WLAN_FC_GET_STYPE(le16_to_cpu(header->frame_ctl))) {
 
 	case RTLLIB_STYPE_BEACON:
 		RTLLIB_DEBUG_MGMT("received BEACON (%d)\n",
-				  WLAN_FC_GET_STYPE(header->frame_ctl));
+				  WLAN_FC_GET_STYPE(le16_to_cpu(header->frame_ctl)));
 		RTLLIB_DEBUG_SCAN("Beacon\n");
 		rtllib_process_probe_response(
 				ieee, (struct rtllib_probe_response *)header,
@@ -2705,14 +2710,15 @@ void rtllib_rx_mgt(struct rtllib_device *ieee,
 
 	case RTLLIB_STYPE_PROBE_RESP:
 		RTLLIB_DEBUG_MGMT("received PROBE RESPONSE (%d)\n",
-			WLAN_FC_GET_STYPE(header->frame_ctl));
+			WLAN_FC_GET_STYPE(le16_to_cpu(header->frame_ctl)));
 		RTLLIB_DEBUG_SCAN("Probe response\n");
 		rtllib_process_probe_response(ieee,
 			      (struct rtllib_probe_response *)header, stats);
 		break;
 	case RTLLIB_STYPE_PROBE_REQ:
 		RTLLIB_DEBUG_MGMT("received PROBE RESQUEST (%d)\n",
-				  WLAN_FC_GET_STYPE(header->frame_ctl));
+				  WLAN_FC_GET_STYPE(
+					  le16_to_cpu(header->frame_ctl)));
 		RTLLIB_DEBUG_SCAN("Probe request\n");
 		if ((ieee->softmac_features & IEEE_SOFTMAC_PROBERS) &&
 		    ((ieee->iw_mode == IW_MODE_ADHOC ||

commit 1f5a0d0cd43f2a02af16a1c23fba8ae14f707d49
Author: Rashika Kheria <rashika.kheria@gmail.com>
Date:   Sat Nov 2 23:34:44 2013 +0530

    Staging: rtl8192e: Fix incorrect type in assignment in rtllib_rx.c
    
    This patch fixes the following Sparse warning in rtllib_rx.c-
    
    drivers/staging/rtl8192e/rtllib_rx.c:493:37: warning: incorrect type in assignment (different base types)
    drivers/staging/rtl8192e/rtllib_rx.c:493:37:    expected unsigned short [unsigned] [usertype] len
    drivers/staging/rtl8192e/rtllib_rx.c:493:37:    got restricted __be16 [usertype] <noident>
    
    drivers/staging/rtl8192e/rtllib_rx.c:1227:37: warning: incorrect type in assignment (different base types)
    drivers/staging/rtl8192e/rtllib_rx.c:1227:37:    expected unsigned short [unsigned] [usertype] len
    drivers/staging/rtl8192e/rtllib_rx.c:1227:37:    got restricted __be16 [usertype] <noident>
    
    drivers/staging/rtl8192e/rtllib_rx.c:1635:40: warning: incorrect type in assignment (different base types)
    drivers/staging/rtl8192e/rtllib_rx.c:1635:40:    expected restricted __le16 <noident>
    drivers/staging/rtl8192e/rtllib_rx.c:1635:40:    got int
    
    drivers/staging/rtl8192e/rtllib_rx.c:1637:40: warning: incorrect type in assignment (different base types)
    drivers/staging/rtl8192e/rtllib_rx.c:1637:40:    expected restricted __le16 <noident>
    drivers/staging/rtl8192e/rtllib_rx.c:1637:40:    got int
    
    drivers/staging/rtl8192e/rtllib_rx.c:1641:45: warning: incorrect type in assignment (different base types)
    drivers/staging/rtl8192e/rtllib_rx.c:1641:45:    expected restricted __le16 <noident>
    drivers/staging/rtl8192e/rtllib_rx.c:1641:45:    got unsigned short [unsigned] [usertype] <noident>
    
    Signed-off-by: Rashika Kheria <rashika.kheria@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index 1a011b9b9da6..6aa837e1c512 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -490,7 +490,7 @@ void rtllib_indicate_packets(struct rtllib_device *ieee, struct rtllib_rxb **prx
 			} else {
 				u16 len;
 			/* Leave Ethernet header part of hdr and full payload */
-				len = htons(sub_skb->len);
+				len = sub_skb->len;
 				memcpy(skb_push(sub_skb, 2), &len, 2);
 				memcpy(skb_push(sub_skb, ETH_ALEN), prxb->src, ETH_ALEN);
 				memcpy(skb_push(sub_skb, ETH_ALEN), prxb->dst, ETH_ALEN);
@@ -1224,7 +1224,7 @@ static void rtllib_rx_indicate_pkt_legacy(struct rtllib_device *ieee,
 			} else {
 				u16 len;
 				/* Leave Ethernet header part of hdr and full payload */
-				len = htons(sub_skb->len);
+				len = sub_skb->len;
 				memcpy(skb_push(sub_skb, 2), &len, 2);
 				memcpy(skb_push(sub_skb, ETH_ALEN), src, ETH_ALEN);
 				memcpy(skb_push(sub_skb, ETH_ALEN), dst, ETH_ALEN);
@@ -1632,13 +1632,13 @@ static int rtllib_qos_convert_ac_to_parameters(struct rtllib_qos_parameter_info
 		/* WMM spec P.11: The minimum value for AIFSN shall be 2 */
 		qos_param->aifs[aci] = (qos_param->aifs[aci] < 2) ? 2 : qos_param->aifs[aci];
 
-		qos_param->cw_min[aci] = ac_params->ecw_min_max & 0x0F;
+		qos_param->cw_min[aci] = cpu_to_le16(ac_params->ecw_min_max & 0x0F);
 
-		qos_param->cw_max[aci] = (ac_params->ecw_min_max & 0xF0) >> 4;
+		qos_param->cw_max[aci] = cpu_to_le16((ac_params->ecw_min_max & 0xF0) >> 4);
 
 		qos_param->flag[aci] =
 		    (ac_params->aci_aifsn & 0x10) ? 0x01 : 0x00;
-		qos_param->tx_op_limit[aci] = le16_to_cpu(ac_params->tx_op_limit);
+		qos_param->tx_op_limit[aci] = ac_params->tx_op_limit;
 	}
 	return rc;
 }

commit 014e4c27c68a3ec40b19fef6ae0431e639632531
Author: Valentina Manea <valentina.manea.m@gmail.com>
Date:   Tue Oct 29 20:58:48 2013 +0200

    staging: rtl8192e: use true and false for bool variables
    
    This patch fixes coccinelle errors for bool variables
    initialized with 1 or 0 instead of true and false.
    
    Signed-off-by: Valentina Manea <valentina.manea.m@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index 6862172af172..1a011b9b9da6 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -873,11 +873,11 @@ static size_t rtllib_rx_get_hdrlen(struct rtllib_device *ieee,
 		if (net_ratelimit())
 			printk(KERN_INFO "%s: find HTCControl!\n", __func__);
 		hdrlen += 4;
-		rx_stats->bContainHTC = 1;
+		rx_stats->bContainHTC = true;
 	}
 
 	 if (RTLLIB_QOS_HAS_SEQ(fc))
-		rx_stats->bIsQosData = 1;
+		rx_stats->bIsQosData = true;
 
 	return hdrlen;
 }

commit 4bb01423ab05af02feaba04823ba6b852dbe5aa6
Author: Valentina Manea <valentina.manea.m@gmail.com>
Date:   Fri Oct 25 11:28:10 2013 +0300

    staging: rtl8192e: do not use comparisons on bool tests
    
    This patch fixes coccinelle errors regarding comparisons
    used in bool tests.
    
    Signed-off-by: Valentina Manea <valentina.manea.m@gmail.com>
    Reviewed-by: Lisa Nguyen <lisa@xenapiadmin.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index 8ee80c50303a..6862172af172 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -1729,7 +1729,7 @@ static inline void rtllib_extract_country_ie(
 			network->CountryIeLen = info_element->len;
 
 			if (!IS_COUNTRY_IE_VALID(ieee)) {
-				if ((rtllib_act_scanning(ieee, false) == true) && (ieee->FirstIe_InScan == 1))
+				if (rtllib_act_scanning(ieee, false) && ieee->FirstIe_InScan)
 					printk(KERN_INFO "Received beacon ContryIE, SSID: <%s>\n", network->ssid);
 				Dot11d_UpdateCountryIe(ieee, addr2, info_element->len, info_element->data);
 			}

commit 8329419a29d15abebc3aefb57f4c6bfdbded7d89
Author: Joe Perches <joe@perches.com>
Date:   Sun Sep 1 12:15:47 2013 -0700

    Staging: Convert uses of compare_ether_addr to ether_addr_equal
    
    Preliminary to removing compare_ether_addr altogether:
    
    Use the new bool function ether_addr_equal to add
    some clarity and reduce the likelihood for misuse
    of compare_ether_addr for sorting.
    
    Additionally:
    
    Used is_zero_ether_addr, removed now unused variable
    Converted uses of &foo[0] to foo
    
    Done via cocci script: (and a little typing)
    
    $ cat compare_ether_addr.cocci
    @@
    expression a,b;
    @@
    -       !compare_ether_addr(a, b)
    +       ether_addr_equal(a, b)
    
    @@
    expression a,b;
    @@
    -       compare_ether_addr(a, b)
    +       !ether_addr_equal(a, b)
    
    @@
    expression a,b;
    @@
    -       !ether_addr_equal(a, b) == 0
    +       ether_addr_equal(a, b)
    
    @@
    expression a,b;
    @@
    -       !ether_addr_equal(a, b) != 0
    +       !ether_addr_equal(a, b)
    
    @@
    expression a,b;
    @@
    -       ether_addr_equal(a, b) == 0
    +       !ether_addr_equal(a, b)
    
    @@
    expression a,b;
    @@
    -       ether_addr_equal(a, b) != 0
    +       ether_addr_equal(a, b)
    
    @@
    expression a,b;
    @@
    -       !!ether_addr_equal(a, b)
    +       ether_addr_equal(a, b)
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index 8aeaed5a987d..8ee80c50303a 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -957,16 +957,15 @@ static void rtllib_rx_extract_addr(struct rtllib_device *ieee,
 static int rtllib_rx_data_filter(struct rtllib_device *ieee, u16 fc,
 				 u8 *dst, u8 *src, u8 *bssid, u8 *addr2)
 {
-	u8 zero_addr[ETH_ALEN] = {0};
 	u8 type, stype;
 
 	type = WLAN_FC_GET_TYPE(fc);
 	stype = WLAN_FC_GET_STYPE(fc);
 
 	/* Filter frames from different BSS */
-	if (((fc & RTLLIB_FCTL_DSTODS) != RTLLIB_FCTL_DSTODS)
-		&& (compare_ether_addr(ieee->current_network.bssid, bssid) != 0)
-		&& memcmp(ieee->current_network.bssid, zero_addr, ETH_ALEN)) {
+	if (((fc & RTLLIB_FCTL_DSTODS) != RTLLIB_FCTL_DSTODS) &&
+	    !ether_addr_equal(ieee->current_network.bssid, bssid) &&
+	    !is_zero_ether_addr(ieee->current_network.bssid)) {
 		return -1;
 	}
 
@@ -974,8 +973,8 @@ static int rtllib_rx_data_filter(struct rtllib_device *ieee, u16 fc,
 	if (ieee->IntelPromiscuousModeInfo.bPromiscuousOn  &&
 		ieee->IntelPromiscuousModeInfo.bFilterSourceStationFrame) {
 		if ((fc & RTLLIB_FCTL_TODS) && !(fc & RTLLIB_FCTL_FROMDS) &&
-			(compare_ether_addr(dst, ieee->current_network.bssid) != 0) &&
-			(compare_ether_addr(bssid, ieee->current_network.bssid) == 0)) {
+		    !ether_addr_equal(dst, ieee->current_network.bssid) &&
+		    ether_addr_equal(bssid, ieee->current_network.bssid)) {
 			return -1;
 		}
 	}
@@ -1275,7 +1274,7 @@ static int rtllib_rx_InfraAdhoc(struct rtllib_device *ieee, struct sk_buff *skb,
 	/*Filter pkt not to me*/
 	multicast = is_multicast_ether_addr(hdr->addr1);
 	unicast = !multicast;
-	if (unicast && (compare_ether_addr(dev->dev_addr, hdr->addr1) != 0)) {
+	if (unicast && !ether_addr_equal(dev->dev_addr, hdr->addr1)) {
 		if (ieee->bNetPromiscuousMode)
 			bToOtherSTA = true;
 		else

commit 559a4c318ca303880fc9f26d50711791c16ae2f3
Author: Andrea Merello <andrea.merello@gmail.com>
Date:   Mon Aug 26 13:53:30 2013 +0200

    staging: Update e-mail address for Andrea Merello
    
    A lot of files contain reference to my old e-mail address.
    Now I'm going not to read mail from it anymore, so update it
    with my current address everywhere.
    
    Signed-off-by: Andrea Merello <andrea.merello@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index 6a51f29e0737..8aeaed5a987d 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -14,7 +14,7 @@
  ******************************************************************************
 
   Few modifications for Realtek's Wi-Fi drivers by
-  Andrea Merello <andreamrl@tiscali.it>
+  Andrea Merello <andrea.merello@gmail.com>
 
   A special thanks goes to Realtek for their support !
 

commit 59aabd6a223de6af2a513bfac1bb783764820c72
Author: Iker Pedrosa <ikerpedrosam@gmail.com>
Date:   Thu Aug 8 12:56:44 2013 +0200

    Staging: rtl8192e: rtllib_rx: checking NULL value after doing dev_alloc_skb
    
    Checking the return of dev_alloc_skb as stated in the following bug:
    https://bugzilla.kernel.org/show_bug.cgi?id=60401
    
    Reported-by: RUC_Soft_Sec rucsoftsec@gmail.com
    Cc: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Iker Pedrosa <ikerpedrosam@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index e75364e3eb43..6a51f29e0737 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -777,6 +777,8 @@ static u8 parse_subframe(struct rtllib_device *ieee, struct sk_buff *skb,
 
 		/* Allocate new skb for releasing to upper layer */
 		sub_skb = dev_alloc_skb(RTLLIB_SKBBUFFER_SIZE);
+		if (!sub_skb)
+			return 0;
 		skb_reserve(sub_skb, 12);
 		data_ptr = (u8 *)skb_put(sub_skb, skb->len);
 		memcpy(data_ptr, skb->data, skb->len);
@@ -825,6 +827,8 @@ static u8 parse_subframe(struct rtllib_device *ieee, struct sk_buff *skb,
 
 			/* Allocate new skb for releasing to upper layer */
 			sub_skb = dev_alloc_skb(nSubframe_Length + 12);
+			if (!sub_skb)
+				return 0;
 			skb_reserve(sub_skb, 12);
 			data_ptr = (u8 *)skb_put(sub_skb, nSubframe_Length);
 			memcpy(data_ptr, skb->data, nSubframe_Length);

commit 03e71d6b91d970900747cd64bbd9bbbe0e9489f8
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Wed May 29 09:57:36 2013 +0300

    Staging: rtl8192e: printing the wrong array
    
    Smatch complained that there is an array overflow here.  It looks
    like we are supposed to be printing the ->rates_ex[] array which is
    slightly larger than the ->rates[] array.  This is a cut and paste
    error.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index 8b8a5c661a26..e75364e3eb43 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -1822,7 +1822,7 @@ int rtllib_parse_info_param(struct rtllib_device *ieee,
 				network->rates_ex[i] = info_element->data[i];
 				p += snprintf(p, sizeof(rates_str) -
 					      (p - rates_str), "%02X ",
-					      network->rates[i]);
+					      network->rates_ex[i]);
 				if (rtllib_is_ofdm_rate
 				    (info_element->data[i])) {
 					network->flags |= NETWORK_HAS_OFDM;

commit 14fc42355f10199f39bc38dd2d3e9288a31e770c
Author: Joe Perches <joe@perches.com>
Date:   Tue May 8 10:11:56 2012 -0700

    staging: Remove test of is_broadcast with is_multicast
    
    A broadcast packet is a multicast packet, no need to test twice.
    
    Reorder one defective test in rtl_core of is_multi_ether_addr
    before is_broadcast_ether_addr as the is_multi returns true for
    broadcast frames.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index 40a59c998efe..8b8a5c661a26 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -1000,7 +1000,7 @@ static int rtllib_rx_data_filter(struct rtllib_device *ieee, u16 fc,
 			return -1;
 
 		/* {broad,multi}cast packets to our BSS go through */
-		if (is_multicast_ether_addr(dst) || is_broadcast_ether_addr(dst)) {
+		if (is_multicast_ether_addr(dst)) {
 			if (memcmp(bssid, ieee->current_network.bssid, ETH_ALEN))
 				return -1;
 		}
@@ -1269,7 +1269,7 @@ static int rtllib_rx_InfraAdhoc(struct rtllib_device *ieee, struct sk_buff *skb,
 	sc = le16_to_cpu(hdr->seq_ctl);
 
 	/*Filter pkt not to me*/
-	multicast = is_multicast_ether_addr(hdr->addr1)|is_broadcast_ether_addr(hdr->addr1);
+	multicast = is_multicast_ether_addr(hdr->addr1);
 	unicast = !multicast;
 	if (unicast && (compare_ether_addr(dev->dev_addr, hdr->addr1) != 0)) {
 		if (ieee->bNetPromiscuousMode)
@@ -1350,7 +1350,7 @@ static int rtllib_rx_InfraAdhoc(struct rtllib_device *ieee, struct sk_buff *skb,
 	/* Get TS for Rx Reorder  */
 	hdr = (struct rtllib_hdr_4addr *) skb->data;
 	if (ieee->current_network.qos_data.active && IsQoSDataFrame(skb->data)
-		&& !is_multicast_ether_addr(hdr->addr1) && !is_broadcast_ether_addr(hdr->addr1)
+		&& !is_multicast_ether_addr(hdr->addr1)
 		&& (!bToOtherSTA)) {
 		TID = Frame_QoSTID(skb->data);
 		SeqNum = WLAN_GET_SEQ_SEQ(sc);

commit cd01712397ad428f443c05add5d7435e899c0ef1
Author: Justin P. Mattock <justinmattock@gmail.com>
Date:   Mon Apr 23 07:36:52 2012 -0700

    staging: rtl8192e: Fix typos.
    
    Signed-off-by: Justin P. Mattock <justinmattock@gmail.com>
    ACKed-by: Larry Finger <Larry.finger@lwfinger.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index 13979b5ea32a..40a59c998efe 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -496,7 +496,7 @@ void rtllib_indicate_packets(struct rtllib_device *ieee, struct rtllib_rxb **prx
 				memcpy(skb_push(sub_skb, ETH_ALEN), prxb->dst, ETH_ALEN);
 			}
 
-			/* Indicat the packets to upper layer */
+			/* Indicate the packets to upper layer */
 			if (sub_skb) {
 				stats->rx_packets++;
 				stats->rx_bytes += sub_skb->len;
@@ -1233,7 +1233,7 @@ static void rtllib_rx_indicate_pkt_legacy(struct rtllib_device *ieee,
 			if (is_multicast_ether_addr(dst))
 				ieee->stats.multicast++;
 
-			/* Indicat the packets to upper layer */
+			/* Indicate the packets to upper layer */
 			memset(sub_skb->cb, 0, sizeof(sub_skb->cb));
 			sub_skb->protocol = eth_type_trans(sub_skb, dev);
 			sub_skb->dev = dev;

commit a2f9dc55345baff05378c23de6e9e026f6838556
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Thu Jan 12 22:49:27 2012 +0100

    drivers/staging: adjust double test
    
    Rewrite a duplicated test to test the correct value
    
    The semantic match that finds this problem is as follows:
    (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @@
    expression E;
    @@
    
    (
    * E
      || ... || E
    |
    * E
      && ... && E
    )
    // </smpl>
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index 6c5061f12bad..13979b5ea32a 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -2453,7 +2453,7 @@ static inline void update_network(struct rtllib_network *dst,
 	if (src->wmm_param[0].ac_aci_acm_aifsn ||
 	   src->wmm_param[1].ac_aci_acm_aifsn ||
 	   src->wmm_param[2].ac_aci_acm_aifsn ||
-	   src->wmm_param[1].ac_aci_acm_aifsn)
+	   src->wmm_param[3].ac_aci_acm_aifsn)
 		memcpy(dst->wmm_param, src->wmm_param, WME_AC_PRAM_LEN);
 
 	dst->SignalStrength = src->SignalStrength;

commit 0ddcf5fdfac6bd80e153ee5c405bdfc9cb868b95
Author: Sean MacLennan <seanm@seanm.ca>
Date:   Mon Dec 19 23:21:41 2011 -0500

    staging/rtl8192e: Convert to lib80211_crypt_info
    
    Convert rtllib to use lib80211_crypt_info.
    
    Signed-off-by: Sean MacLennan <seanm@seanm.ca>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index d02a88bb3a46..6c5061f12bad 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -1019,7 +1019,7 @@ static int rtllib_rx_get_crypt(struct rtllib_device *ieee, struct sk_buff *skb,
 		if (skb->len >= hdrlen + 3)
 			idx = skb->data[hdrlen + 3] >> 6;
 
-		*crypt = ieee->crypt[idx];
+		*crypt = ieee->crypt_info.crypt[idx];
 		/* allow NULL decrypt to indicate an station specific override
 		 * for default encryption */
 		if (*crypt && ((*crypt)->ops == NULL ||

commit 32c44cb5b9fdc6eaa445bd622008dd672a3dd1a7
Author: Sean MacLennan <seanm@seanm.ca>
Date:   Mon Dec 19 23:20:41 2011 -0500

    staging/rtl8192e: Convert to lib80211_crypt_data and lib80211_crypt_ops
    
    Convert rtllib_crypt_data to lib80211_crypt_data and
    rtllib_crypt_ops to lib80211_crypt_ops.
    
    This is almost a 1:1 replacement, only extra_prefix_len and
    extra_postfix_len changed.
    
    Signed-off-by: Sean MacLennan <seanm@seanm.ca>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index e662fd6b0f99..d02a88bb3a46 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -280,7 +280,7 @@ static int rtllib_is_eapol_frame(struct rtllib_device *ieee,
 /* Called only as a tasklet (software IRQ), by rtllib_rx */
 static inline int
 rtllib_rx_frame_decrypt(struct rtllib_device *ieee, struct sk_buff *skb,
-			struct rtllib_crypt_data *crypt)
+			struct lib80211_crypt_data *crypt)
 {
 	struct rtllib_hdr_4addr *hdr;
 	int res, hdrlen;
@@ -321,7 +321,7 @@ rtllib_rx_frame_decrypt(struct rtllib_device *ieee, struct sk_buff *skb,
 /* Called only as a tasklet (software IRQ), by rtllib_rx */
 static inline int
 rtllib_rx_frame_decrypt_msdu(struct rtllib_device *ieee, struct sk_buff *skb,
-			     int keyidx, struct rtllib_crypt_data *crypt)
+			     int keyidx, struct lib80211_crypt_data *crypt)
 {
 	struct rtllib_hdr_4addr *hdr;
 	int res, hdrlen;
@@ -340,7 +340,7 @@ rtllib_rx_frame_decrypt_msdu(struct rtllib_device *ieee, struct sk_buff *skb,
 	hdrlen = rtllib_get_hdrlen(le16_to_cpu(hdr->frame_ctl));
 
 	atomic_inc(&crypt->refcnt);
-	res = crypt->ops->decrypt_msdu(skb, keyidx, hdrlen, crypt->priv, ieee);
+	res = crypt->ops->decrypt_msdu(skb, keyidx, hdrlen, crypt->priv);
 	atomic_dec(&crypt->refcnt);
 	if (res < 0) {
 		printk(KERN_DEBUG "%s: MSDU decryption/MIC verification failed"
@@ -1009,7 +1009,7 @@ static int rtllib_rx_data_filter(struct rtllib_device *ieee, u16 fc,
 }
 
 static int rtllib_rx_get_crypt(struct rtllib_device *ieee, struct sk_buff *skb,
-			struct rtllib_crypt_data **crypt, size_t hdrlen)
+			struct lib80211_crypt_data **crypt, size_t hdrlen)
 {
 	struct rtllib_hdr_4addr *hdr = (struct rtllib_hdr_4addr *)skb->data;
 	u16 fc = le16_to_cpu(hdr->frame_ctl);
@@ -1044,7 +1044,7 @@ static int rtllib_rx_get_crypt(struct rtllib_device *ieee, struct sk_buff *skb,
 
 static int rtllib_rx_decrypt(struct rtllib_device *ieee, struct sk_buff *skb,
 		      struct rtllib_rx_stats *rx_stats,
-		      struct rtllib_crypt_data *crypt, size_t hdrlen)
+		      struct lib80211_crypt_data *crypt, size_t hdrlen)
 {
 	struct rtllib_hdr_4addr *hdr;
 	int keyidx = 0;
@@ -1252,7 +1252,7 @@ static int rtllib_rx_InfraAdhoc(struct rtllib_device *ieee, struct sk_buff *skb,
 {
 	struct net_device *dev = ieee->dev;
 	struct rtllib_hdr_4addr *hdr = (struct rtllib_hdr_4addr *)skb->data;
-	struct rtllib_crypt_data *crypt = NULL;
+	struct lib80211_crypt_data *crypt = NULL;
 	struct rtllib_rxb *rxb = NULL;
 	struct rx_ts_record *pTS = NULL;
 	u16 fc, sc, SeqNum = 0;

commit e0ec8a67089762b29071e879388986ab7370d330
Author: Devendra Naga <devendra.aaru@gmail.com>
Date:   Tue Dec 13 01:49:29 2011 -0500

    staging: remove version.h includes in rtl8192e
    
    Signed-off-by: Devendra Naga <devendra.aaru@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index b640c8797f4a..e662fd6b0f99 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -36,7 +36,6 @@
 #include <linux/slab.h>
 #include <linux/tcp.h>
 #include <linux/types.h>
-#include <linux/version.h>
 #include <linux/wireless.h>
 #include <linux/etherdevice.h>
 #include <linux/uaccess.h>

commit 976d534118219b04277fb6cfcdb71607b730746d
Author: Sean MacLennan <seanm@seanm.ca>
Date:   Wed Nov 30 15:18:52 2011 -0500

    rtl8192e: Rename clashing symbols
    
    The "rtl8192e: Export symbols" patch exported three functions already
    exported by the rtl8192u driver. This patch renames the three functions:
      Dot11d_Init => dot11d_init
      HTUpdateSelfAndPeerSetting => HT_update_self_and_peer_setting
      IsLegalChannel => rtllib_legal_channel
    
    Signed-off-by: Sean MacLennan <seanm@seanm.ca>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index 9655b881e73f..b640c8797f4a 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -2493,7 +2493,7 @@ static int IsPassiveChannel(struct rtllib_device *rtllib, u8 channel)
 	return 0;
 }
 
-int IsLegalChannel(struct rtllib_device *rtllib, u8 channel)
+int rtllib_legal_channel(struct rtllib_device *rtllib, u8 channel)
 {
 	if (MAX_CHANNEL_NUMBER < channel) {
 		printk(KERN_INFO "%s(): Invalid Channel\n", __func__);
@@ -2504,7 +2504,7 @@ int IsLegalChannel(struct rtllib_device *rtllib, u8 channel)
 
 	return 0;
 }
-EXPORT_SYMBOL(IsLegalChannel);
+EXPORT_SYMBOL(rtllib_legal_channel);
 
 static inline void rtllib_process_probe_response(
 	struct rtllib_device *ieee,
@@ -2555,7 +2555,7 @@ static inline void rtllib_process_probe_response(
 	}
 
 
-	if (!IsLegalChannel(ieee, network->channel))
+	if (!rtllib_legal_channel(ieee, network->channel))
 		goto free_network;
 
 	if (WLAN_FC_GET_STYPE(beacon->header.frame_ctl) ==

commit 3b28499c5519e59fbe9c2dea49ece5a3665be787
Author: Sean MacLennan <seanm@seanm.ca>
Date:   Mon Nov 28 20:20:26 2011 -0500

    rtl8192e: Export symbols
    
    The rtl8192e driver had a natural split between the more generic
    rtllib code and the more specific rtl8192e code. This patch exports
    all the symbols needed by the r8192 specific code from the rtllib
    generic code.
    
    Signed-off-by: Sean MacLennan <seanm@seanm.ca>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index 8d0af5ed8ecf..9655b881e73f 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -1497,6 +1497,7 @@ int rtllib_rx(struct rtllib_device *ieee, struct sk_buff *skb,
 	ieee->stats.rx_dropped++;
 	return 0;
 }
+EXPORT_SYMBOL(rtllib_rx);
 
 static u8 qos_oui[QOS_OUI_LEN] = { 0x00, 0x50, 0xF2 };
 
@@ -2503,6 +2504,7 @@ int IsLegalChannel(struct rtllib_device *rtllib, u8 channel)
 
 	return 0;
 }
+EXPORT_SYMBOL(IsLegalChannel);
 
 static inline void rtllib_process_probe_response(
 	struct rtllib_device *ieee,

commit 2eed3dee92453c1798f0932613b1b66f0763ab2e
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Thu Sep 1 12:23:20 2011 -0500

    staging: rtl8192e: Fix smatch warnings regarding large arrays on stack
    
    Smatch reports the follwing warnings:
    
      CHECK   drivers/staging/rtl8192e/rtllib_rx.c
    drivers/staging/rtl8192e/rtllib_rx.c +552 RxReorderIndicatePacket(6) warn: 'prxbIndicateArray' puts 1024 bytes on stack
    
      CHECK   drivers/staging/rtl8192e/rtl819x_TSProc.c
    drivers/staging/rtl8192e/rtl819x_TSProc.c +40 RxPktPendingTimeout(9) warn: 'stats_IndicateArray' puts 1024 bytes on stack
    
      CHECK   drivers/staging/rtl8192e/r8192E_phy.c
    drivers/staging/rtl8192e/r8192E_phy.c +859 rtl8192_phy_SwChnlStepByStep(11) warn: function puts 797 bytes on stack
    
      CHECK   drivers/staging/rtl8192e/rtllib_rx.c
    drivers/staging/rtl8192e/rtllib_rx.c +552 RxReorderIndicatePacket(6) warn: 'prxbIndicateArray' puts 1024 bytes on stack
    
    These are fixed by adding the arrays in question as a union in a struct used
    by nearly all routines.
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index 745ae0861dfa..8d0af5ed8ecf 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -520,7 +520,6 @@ void rtllib_indicate_packets(struct rtllib_device *ieee, struct rtllib_rxb **prx
 void rtllib_FlushRxTsPendingPkts(struct rtllib_device *ieee,	struct rx_ts_record *pTS)
 {
 	struct rx_reorder_entry *pRxReorderEntry;
-	struct rtllib_rxb *RfdArray[REORDER_WIN_SIZE];
 	u8 RfdCnt = 0;
 
 	del_timer_sync(&pTS->RxPktPendingTimer);
@@ -534,12 +533,12 @@ void rtllib_FlushRxTsPendingPkts(struct rtllib_device *ieee,	struct rx_ts_record
 		RTLLIB_DEBUG(RTLLIB_DL_REORDER, "%s(): Indicate SeqNum %d!\n", __func__, pRxReorderEntry->SeqNum);
 		list_del_init(&pRxReorderEntry->List);
 
-		RfdArray[RfdCnt] = pRxReorderEntry->prxb;
+		ieee->RfdArray[RfdCnt] = pRxReorderEntry->prxb;
 
 		RfdCnt = RfdCnt + 1;
 		list_add_tail(&pRxReorderEntry->List, &ieee->RxReorder_Unused_List);
 	}
-	rtllib_indicate_packets(ieee, RfdArray, RfdCnt);
+	rtllib_indicate_packets(ieee, ieee->RfdArray, RfdCnt);
 
 	pTS->RxIndicateSeq = 0xffff;
 }
@@ -550,7 +549,6 @@ static void RxReorderIndicatePacket(struct rtllib_device *ieee,
 {
 	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
 	struct rx_reorder_entry *pReorderEntry = NULL;
-	struct rtllib_rxb *prxbIndicateArray[REORDER_WIN_SIZE];
 	u8 WinSize = pHTInfo->RxReorderWinSize;
 	u16 WinEnd = 0;
 	u8 index = 0;
@@ -617,7 +615,7 @@ static void RxReorderIndicatePacket(struct rtllib_device *ieee,
 		RTLLIB_DEBUG(RTLLIB_DL_REORDER, "Packets indication!! "
 				"IndicateSeq: %d, NewSeq: %d\n",
 				pTS->RxIndicateSeq, SeqNum);
-		prxbIndicateArray[0] = prxb;
+		ieee->prxbIndicateArray[0] = prxb;
 		index = 1;
 	} else {
 		/* Current packet is going to be inserted into pending list.*/
@@ -693,7 +691,7 @@ static void RxReorderIndicatePacket(struct rtllib_device *ieee,
 			if (SN_EQUAL(pReorderEntry->SeqNum, pTS->RxIndicateSeq))
 				pTS->RxIndicateSeq = (pTS->RxIndicateSeq + 1) % 4096;
 
-			prxbIndicateArray[index] = pReorderEntry->prxb;
+			ieee->prxbIndicateArray[index] = pReorderEntry->prxb;
 			RTLLIB_DEBUG(RTLLIB_DL_REORDER, "%s(): Indicate SeqNum"
 				     " %d!\n", __func__, pReorderEntry->SeqNum);
 			index++;
@@ -720,7 +718,7 @@ static void RxReorderIndicatePacket(struct rtllib_device *ieee,
 					       flags);
 			return;
 		}
-		rtllib_indicate_packets(ieee, prxbIndicateArray, index);
+		rtllib_indicate_packets(ieee, ieee->prxbIndicateArray, index);
 		bPktInBuf = false;
 	}
 

commit 49aab5fd9df153a73992afa7cc386661d759c8e3
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Thu Aug 25 14:07:05 2011 -0500

    staging: rtl8192e: Fix sparse (non-endian) warnings - Part II
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index 35f70d6fe2eb..745ae0861dfa 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -442,15 +442,20 @@ static int is_duplicate_packet(struct rtllib_device *ieee,
 	return 1;
 }
 
-bool AddReorderEntry(struct rx_ts_record *pTS, struct rx_reorder_entry *pReorderEntry)
+static bool AddReorderEntry(struct rx_ts_record *pTS,
+			    struct rx_reorder_entry *pReorderEntry)
 {
 	struct list_head *pList = &pTS->RxPendingPktList;
 
 	while (pList->next != &pTS->RxPendingPktList) {
-		if (SN_LESS(pReorderEntry->SeqNum, ((struct rx_reorder_entry *)list_entry(pList->next, struct rx_reorder_entry, List))->SeqNum))
+		if (SN_LESS(pReorderEntry->SeqNum, ((struct rx_reorder_entry *)
+		    list_entry(pList->next, struct rx_reorder_entry,
+		    List))->SeqNum))
 			pList = pList->next;
-		else if (SN_EQUAL(pReorderEntry->SeqNum, ((struct rx_reorder_entry *)list_entry(pList->next, struct rx_reorder_entry, List))->SeqNum))
-			return false;
+		else if (SN_EQUAL(pReorderEntry->SeqNum,
+			((struct rx_reorder_entry *)list_entry(pList->next,
+			struct rx_reorder_entry, List))->SeqNum))
+				return false;
 		else
 			break;
 	}
@@ -539,8 +544,9 @@ void rtllib_FlushRxTsPendingPkts(struct rtllib_device *ieee,	struct rx_ts_record
 	pTS->RxIndicateSeq = 0xffff;
 }
 
-void RxReorderIndicatePacket(struct rtllib_device *ieee, struct rtllib_rxb *prxb,
-		struct rx_ts_record *pTS, u16 SeqNum)
+static void RxReorderIndicatePacket(struct rtllib_device *ieee,
+				    struct rtllib_rxb *prxb,
+				    struct rx_ts_record *pTS, u16 SeqNum)
 {
 	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
 	struct rx_reorder_entry *pReorderEntry = NULL;
@@ -728,9 +734,9 @@ void RxReorderIndicatePacket(struct rtllib_device *ieee, struct rtllib_rxb *prxb
 	spin_unlock_irqrestore(&(ieee->reorder_spinlock), flags);
 }
 
-u8 parse_subframe(struct rtllib_device *ieee, struct sk_buff *skb,
-		  struct rtllib_rx_stats *rx_stats,
-		  struct rtllib_rxb *rxb, u8 *src, u8 *dst)
+static u8 parse_subframe(struct rtllib_device *ieee, struct sk_buff *skb,
+			 struct rtllib_rx_stats *rx_stats,
+			 struct rtllib_rxb *rxb, u8 *src, u8 *dst)
 {
 	struct rtllib_hdr_3addr  *hdr = (struct rtllib_hdr_3addr *)skb->data;
 	u16		fc = le16_to_cpu(hdr->frame_ctl);
@@ -853,8 +859,9 @@ u8 parse_subframe(struct rtllib_device *ieee, struct sk_buff *skb,
 }
 
 
-size_t rtllib_rx_get_hdrlen(struct rtllib_device *ieee, struct sk_buff *skb,
-		 struct rtllib_rx_stats *rx_stats)
+static size_t rtllib_rx_get_hdrlen(struct rtllib_device *ieee,
+				   struct sk_buff *skb,
+				   struct rtllib_rx_stats *rx_stats)
 {
 	struct rtllib_hdr_4addr *hdr = (struct rtllib_hdr_4addr *)skb->data;
 	u16 fc = le16_to_cpu(hdr->frame_ctl);
@@ -874,8 +881,8 @@ size_t rtllib_rx_get_hdrlen(struct rtllib_device *ieee, struct sk_buff *skb,
 	return hdrlen;
 }
 
-int rtllib_rx_check_duplicate(struct rtllib_device *ieee, struct sk_buff *skb,
-			      u8 multicast)
+static int rtllib_rx_check_duplicate(struct rtllib_device *ieee,
+				     struct sk_buff *skb, u8 multicast)
 {
 	struct rtllib_hdr_4addr *hdr = (struct rtllib_hdr_4addr *)skb->data;
 	u16 fc, sc;
@@ -916,9 +923,9 @@ int rtllib_rx_check_duplicate(struct rtllib_device *ieee, struct sk_buff *skb,
 	return 0;
 }
 
-void rtllib_rx_extract_addr(struct rtllib_device *ieee,
-			    struct rtllib_hdr_4addr *hdr, u8 *dst, u8 *src,
-			    u8 *bssid)
+static void rtllib_rx_extract_addr(struct rtllib_device *ieee,
+				   struct rtllib_hdr_4addr *hdr, u8 *dst,
+				   u8 *src, u8 *bssid)
 {
 	u16 fc = le16_to_cpu(hdr->frame_ctl);
 
@@ -946,8 +953,8 @@ void rtllib_rx_extract_addr(struct rtllib_device *ieee,
 	}
 }
 
-int rtllib_rx_data_filter(struct rtllib_device *ieee, u16 fc, u8 *dst, u8 *src,
-			  u8 *bssid, u8 *addr2)
+static int rtllib_rx_data_filter(struct rtllib_device *ieee, u16 fc,
+				 u8 *dst, u8 *src, u8 *bssid, u8 *addr2)
 {
 	u8 zero_addr[ETH_ALEN] = {0};
 	u8 type, stype;
@@ -1004,7 +1011,7 @@ int rtllib_rx_data_filter(struct rtllib_device *ieee, u16 fc, u8 *dst, u8 *src,
 	return 0;
 }
 
-int rtllib_rx_get_crypt(struct rtllib_device *ieee, struct sk_buff *skb,
+static int rtllib_rx_get_crypt(struct rtllib_device *ieee, struct sk_buff *skb,
 			struct rtllib_crypt_data **crypt, size_t hdrlen)
 {
 	struct rtllib_hdr_4addr *hdr = (struct rtllib_hdr_4addr *)skb->data;
@@ -1038,7 +1045,7 @@ int rtllib_rx_get_crypt(struct rtllib_device *ieee, struct sk_buff *skb,
 	return 0;
 }
 
-int rtllib_rx_decrypt(struct rtllib_device *ieee, struct sk_buff *skb,
+static int rtllib_rx_decrypt(struct rtllib_device *ieee, struct sk_buff *skb,
 		      struct rtllib_rx_stats *rx_stats,
 		      struct rtllib_crypt_data *crypt, size_t hdrlen)
 {
@@ -1168,7 +1175,7 @@ int rtllib_rx_decrypt(struct rtllib_device *ieee, struct sk_buff *skb,
 	return 0;
 }
 
-void rtllib_rx_check_leave_lps(struct rtllib_device *ieee, u8 unicast, u8 nr_subframes)
+static void rtllib_rx_check_leave_lps(struct rtllib_device *ieee, u8 unicast, u8 nr_subframes)
 {
 	if (unicast) {
 
@@ -1184,7 +1191,7 @@ void rtllib_rx_check_leave_lps(struct rtllib_device *ieee, u8 unicast, u8 nr_sub
 	ieee->last_rx_ps_time = jiffies;
 }
 
-void rtllib_rx_indicate_pkt_legacy(struct rtllib_device *ieee,
+static void rtllib_rx_indicate_pkt_legacy(struct rtllib_device *ieee,
 		struct rtllib_rx_stats *rx_stats,
 		struct rtllib_rxb *rxb,
 		u8 *dst,
@@ -1243,7 +1250,7 @@ void rtllib_rx_indicate_pkt_legacy(struct rtllib_device *ieee,
 	rxb = NULL;
 }
 
-int rtllib_rx_InfraAdhoc(struct rtllib_device *ieee, struct sk_buff *skb,
+static int rtllib_rx_InfraAdhoc(struct rtllib_device *ieee, struct sk_buff *skb,
 		 struct rtllib_rx_stats *rx_stats)
 {
 	struct net_device *dev = ieee->dev;
@@ -1412,13 +1419,13 @@ int rtllib_rx_InfraAdhoc(struct rtllib_device *ieee, struct sk_buff *skb,
 	return 0;
 }
 
-int rtllib_rx_Master(struct rtllib_device *ieee, struct sk_buff *skb,
+static int rtllib_rx_Master(struct rtllib_device *ieee, struct sk_buff *skb,
 		 struct rtllib_rx_stats *rx_stats)
 {
 	return 0;
 }
 
-int rtllib_rx_Monitor(struct rtllib_device *ieee, struct sk_buff *skb,
+static int rtllib_rx_Monitor(struct rtllib_device *ieee, struct sk_buff *skb,
 		 struct rtllib_rx_stats *rx_stats)
 {
 	struct rtllib_hdr_4addr *hdr = (struct rtllib_hdr_4addr *)skb->data;
@@ -1443,7 +1450,7 @@ int rtllib_rx_Monitor(struct rtllib_device *ieee, struct sk_buff *skb,
 	return 1;
 }
 
-int rtllib_rx_Mesh(struct rtllib_device *ieee, struct sk_buff *skb,
+static int rtllib_rx_Mesh(struct rtllib_device *ieee, struct sk_buff *skb,
 		 struct rtllib_rx_stats *rx_stats)
 {
 	return 0;
@@ -2223,7 +2230,7 @@ static inline u8 rtllib_SignalStrengthTranslate(u8  CurrSS)
 	return RetSS;
 }
 
-long rtllib_translate_todbm(u8 signal_strength_index)
+static long rtllib_translate_todbm(u8 signal_strength_index)
 {
 	long	signal_power;
 

commit ac50ddaaeeca4f649c53ce31175aa68d26420138
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Thu Aug 25 14:07:03 2011 -0500

    staging: rtl8192e: Remove MAC_FMT and MAC_ARG for %pM
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index 205c57508497..35f70d6fe2eb 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -305,8 +305,8 @@ rtllib_rx_frame_decrypt(struct rtllib_device *ieee, struct sk_buff *skb,
 	atomic_dec(&crypt->refcnt);
 	if (res < 0) {
 		RTLLIB_DEBUG_DROP(
-			"decryption failed (SA=" MAC_FMT
-			") res=%d\n", MAC_ARG(hdr->addr2), res);
+			"decryption failed (SA= %pM"
+			") res=%d\n", hdr->addr2, res);
 		if (res == -2)
 			RTLLIB_DEBUG_DROP("Decryption failed ICV "
 					     "mismatch (key %d)\n",
@@ -345,8 +345,8 @@ rtllib_rx_frame_decrypt_msdu(struct rtllib_device *ieee, struct sk_buff *skb,
 	atomic_dec(&crypt->refcnt);
 	if (res < 0) {
 		printk(KERN_DEBUG "%s: MSDU decryption/MIC verification failed"
-		       " (SA=" MAC_FMT " keyidx=%d)\n",
-		       ieee->dev->name, MAC_ARG(hdr->addr2), keyidx);
+		       " (SA= %pM keyidx=%d)\n",
+		       ieee->dev->name, hdr->addr2, keyidx);
 		return -1;
 	}
 
@@ -1028,8 +1028,8 @@ int rtllib_rx_get_crypt(struct rtllib_device *ieee, struct sk_buff *skb,
 			 * frames silently instead of filling system log with
 			 * these reports. */
 			RTLLIB_DEBUG_DROP("Decryption failed (not set)"
-					     " (SA=" MAC_FMT ")\n",
-					     MAC_ARG(hdr->addr2));
+					     " (SA= %pM)\n",
+					     hdr->addr2);
 			ieee->ieee_stats.rx_discards_undecryptable++;
 			return -1;
 		}
@@ -1138,8 +1138,8 @@ int rtllib_rx_decrypt(struct rtllib_device *ieee, struct sk_buff *skb,
 		} else {
 			RTLLIB_DEBUG_DROP(
 				"encryption configured, but RX "
-				"frame not encrypted (SA=" MAC_FMT ")\n",
-				MAC_ARG(hdr->addr2));
+				"frame not encrypted (SA= %pM)\n",
+				hdr->addr2);
 			return -1;
 		}
 	}
@@ -1156,9 +1156,9 @@ int rtllib_rx_decrypt(struct rtllib_device *ieee, struct sk_buff *skb,
 	    !rtllib_is_eapol_frame(ieee, skb, hdrlen)) {
 		RTLLIB_DEBUG_DROP(
 			"dropped unencrypted RX data "
-			"frame from " MAC_FMT
+			"frame from %pM"
 			" (drop_unencrypted=1)\n",
-			MAC_ARG(hdr->addr2));
+			hdr->addr2);
 		return -1;
 	}
 
@@ -2309,11 +2309,11 @@ static inline int rtllib_network_init(
 	}
 
 	if (network->mode == 0) {
-		RTLLIB_DEBUG_SCAN("Filtered out '%s (" MAC_FMT ")' "
+		RTLLIB_DEBUG_SCAN("Filtered out '%s (%pM)' "
 				     "network.\n",
 				     escape_essid(network->ssid,
 						  network->ssid_len),
-				     MAC_ARG(network->bssid));
+				     network->bssid);
 		return 1;
 	}
 
@@ -2516,9 +2516,9 @@ static inline void rtllib_process_probe_response(
 		return;
 
 	RTLLIB_DEBUG_SCAN(
-		"'%s' (" MAC_FMT "): %c%c%c%c %c%c%c%c-%c%c%c%c %c%c%c%c\n",
+		"'%s' ( %pM ): %c%c%c%c %c%c%c%c-%c%c%c%c %c%c%c%c\n",
 		escape_essid(info_element->data, info_element->len),
-		MAC_ARG(beacon->header.addr3),
+		beacon->header.addr3,
 		(beacon->capability & (1<<0xf)) ? '1' : '0',
 		(beacon->capability & (1<<0xe)) ? '1' : '0',
 		(beacon->capability & (1<<0xd)) ? '1' : '0',
@@ -2537,10 +2537,10 @@ static inline void rtllib_process_probe_response(
 		(beacon->capability & (1<<0x0)) ? '1' : '0');
 
 	if (rtllib_network_init(ieee, beacon, network, stats)) {
-		RTLLIB_DEBUG_SCAN("Dropped '%s' (" MAC_FMT ") via %s.\n",
+		RTLLIB_DEBUG_SCAN("Dropped '%s' ( %pM) via %s.\n",
 				  escape_essid(info_element->data,
 				  info_element->len),
-				  MAC_ARG(beacon->header.addr3),
+				  beacon->header.addr3,
 				  WLAN_FC_GET_STYPE(beacon->header.frame_ctl) ==
 				  RTLLIB_STYPE_PROBE_RESP ?
 				  "PROBE RESPONSE" : "BEACON");
@@ -2604,11 +2604,11 @@ static inline void rtllib_process_probe_response(
 			/* If there are no more slots, expire the oldest */
 			list_del(&oldest->list);
 			target = oldest;
-			RTLLIB_DEBUG_SCAN("Expired '%s' (" MAC_FMT ") from "
+			RTLLIB_DEBUG_SCAN("Expired '%s' ( %pM) from "
 					     "network list.\n",
 					     escape_essid(target->ssid,
 							  target->ssid_len),
-					     MAC_ARG(target->bssid));
+					     target->bssid);
 		} else {
 			/* Otherwise just pull from the free list */
 			target = list_entry(ieee->network_free_list.next,
@@ -2617,10 +2617,9 @@ static inline void rtllib_process_probe_response(
 		}
 
 
-		RTLLIB_DEBUG_SCAN("Adding '%s' (" MAC_FMT ") via %s.\n",
+		RTLLIB_DEBUG_SCAN("Adding '%s' ( %pM) via %s.\n",
 				  escape_essid(network->ssid,
-				  network->ssid_len),
-				  MAC_ARG(network->bssid),
+				  network->ssid_len), network->bssid,
 				  WLAN_FC_GET_STYPE(beacon->header.frame_ctl) ==
 				  RTLLIB_STYPE_PROBE_RESP ?
 				  "PROBE RESPONSE" : "BEACON");
@@ -2629,10 +2628,9 @@ static inline void rtllib_process_probe_response(
 		if (ieee->softmac_features & IEEE_SOFTMAC_ASSOCIATE)
 			rtllib_softmac_new_net(ieee, network);
 	} else {
-		RTLLIB_DEBUG_SCAN("Updating '%s' (" MAC_FMT ") via %s.\n",
+		RTLLIB_DEBUG_SCAN("Updating '%s' ( %pM) via %s.\n",
 				  escape_essid(target->ssid,
-				  target->ssid_len),
-				  MAC_ARG(target->bssid),
+				  target->ssid_len), target->bssid,
 				  WLAN_FC_GET_STYPE(beacon->header.frame_ctl) ==
 				  RTLLIB_STYPE_PROBE_RESP ?
 				  "PROBE RESPONSE" : "BEACON");

commit db8971b618ed967c93fb89622dfe6006a58d55a5
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Thu Aug 25 11:48:25 2011 -0500

    staging: rtl8192e: Cleanup checkpatch -f errors - Part XIII
    
    With this patch, all of the checkpatch errors are fixed; however, only
    some of the lines that are too long were fixed. To complete the fixing
    of these warnings, the file rtl_dm.c will need refactoring. In addition,
    some of the variables will need renaming. Those changes can be deferred.
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index 9606bedf16de..205c57508497 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -39,18 +39,18 @@
 #include <linux/version.h>
 #include <linux/wireless.h>
 #include <linux/etherdevice.h>
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
 #include <linux/ctype.h>
 
 #include "rtllib.h"
 #include "dot11d.h"
 
 static inline void rtllib_monitor_rx(struct rtllib_device *ieee,
-				struct sk_buff *skb,struct rtllib_rx_stats *rx_status,
+				struct sk_buff *skb, struct rtllib_rx_stats *rx_status,
 				size_t hdr_length)
 {
 	skb->dev = ieee->dev;
-        skb_reset_mac_header(skb);
+	skb_reset_mac_header(skb);
 	skb_pull(skb, hdr_length);
 	skb->pkt_type = PACKET_OTHERHOST;
 	skb->protocol = __constant_htons(ETH_P_80211_RAW);
@@ -61,7 +61,7 @@ static inline void rtllib_monitor_rx(struct rtllib_device *ieee,
 /* Called only as a tasklet (software IRQ) */
 static struct rtllib_frag_entry *
 rtllib_frag_cache_find(struct rtllib_device *ieee, unsigned int seq,
-			  unsigned int frag, u8 tid,u8 *src, u8 *dst)
+			  unsigned int frag, u8 tid, u8 *src, u8 *dst)
 {
 	struct rtllib_frag_entry *entry;
 	int i;
@@ -103,18 +103,18 @@ rtllib_frag_cache_get(struct rtllib_device *ieee,
 	struct rtllib_hdr_4addrqos *hdr_4addrqos;
 	u8 tid;
 
-	if (((fc & RTLLIB_FCTL_DSTODS) == RTLLIB_FCTL_DSTODS)&&RTLLIB_QOS_HAS_SEQ(fc)) {
-	  hdr_4addrqos = (struct rtllib_hdr_4addrqos *)hdr;
-	  tid = le16_to_cpu(hdr_4addrqos->qos_ctl) & RTLLIB_QCTL_TID;
-	  tid = UP2AC(tid);
-	  tid ++;
+	if (((fc & RTLLIB_FCTL_DSTODS) == RTLLIB_FCTL_DSTODS) && RTLLIB_QOS_HAS_SEQ(fc)) {
+		hdr_4addrqos = (struct rtllib_hdr_4addrqos *)hdr;
+		tid = le16_to_cpu(hdr_4addrqos->qos_ctl) & RTLLIB_QCTL_TID;
+		tid = UP2AC(tid);
+		tid++;
 	} else if (RTLLIB_QOS_HAS_SEQ(fc)) {
-	  hdr_3addrqos = (struct rtllib_hdr_3addrqos *)hdr;
-	  tid = le16_to_cpu(hdr_3addrqos->qos_ctl) & RTLLIB_QCTL_TID;
-	  tid = UP2AC(tid);
-	  tid ++;
+		hdr_3addrqos = (struct rtllib_hdr_3addrqos *)hdr;
+		tid = le16_to_cpu(hdr_3addrqos->qos_ctl) & RTLLIB_QCTL_TID;
+		tid = UP2AC(tid);
+		tid++;
 	} else {
-	  tid = 0;
+		tid = 0;
 	}
 
 	if (frag == 0) {
@@ -125,7 +125,7 @@ rtllib_frag_cache_get(struct rtllib_device *ieee,
 				    2 /* alignment */ +
 				    8 /* WEP */ +
 				    ETH_ALEN /* WDS */ +
-				    (RTLLIB_QOS_HAS_SEQ(fc)?2:0) /* QOS Control */);
+				    (RTLLIB_QOS_HAS_SEQ(fc) ? 2 : 0) /* QOS Control */);
 		if (skb == NULL)
 			return NULL;
 
@@ -146,7 +146,7 @@ rtllib_frag_cache_get(struct rtllib_device *ieee,
 	} else {
 		/* received a fragment of a frame for which the head fragment
 		 * should have already been received */
-		entry = rtllib_frag_cache_find(ieee, seq, frag, tid,hdr->addr2,
+		entry = rtllib_frag_cache_find(ieee, seq, frag, tid, hdr->addr2,
 						  hdr->addr1);
 		if (entry != NULL) {
 			entry->last_frag = frag;
@@ -170,21 +170,21 @@ static int rtllib_frag_cache_invalidate(struct rtllib_device *ieee,
 	struct rtllib_hdr_4addrqos *hdr_4addrqos;
 	u8 tid;
 
-	if (((fc & RTLLIB_FCTL_DSTODS) == RTLLIB_FCTL_DSTODS)&&RTLLIB_QOS_HAS_SEQ(fc)) {
-	  hdr_4addrqos = (struct rtllib_hdr_4addrqos *)hdr;
-	  tid = le16_to_cpu(hdr_4addrqos->qos_ctl) & RTLLIB_QCTL_TID;
-	  tid = UP2AC(tid);
-	  tid ++;
+	if (((fc & RTLLIB_FCTL_DSTODS) == RTLLIB_FCTL_DSTODS) && RTLLIB_QOS_HAS_SEQ(fc)) {
+		hdr_4addrqos = (struct rtllib_hdr_4addrqos *)hdr;
+		tid = le16_to_cpu(hdr_4addrqos->qos_ctl) & RTLLIB_QCTL_TID;
+		tid = UP2AC(tid);
+		tid++;
 	} else if (RTLLIB_QOS_HAS_SEQ(fc)) {
-	  hdr_3addrqos = (struct rtllib_hdr_3addrqos *)hdr;
-	  tid = le16_to_cpu(hdr_3addrqos->qos_ctl) & RTLLIB_QCTL_TID;
-	  tid = UP2AC(tid);
-	  tid ++;
+		hdr_3addrqos = (struct rtllib_hdr_3addrqos *)hdr;
+		tid = le16_to_cpu(hdr_3addrqos->qos_ctl) & RTLLIB_QCTL_TID;
+		tid = UP2AC(tid);
+		tid++;
 	} else {
-	  tid = 0;
+		tid = 0;
 	}
 
-	entry = rtllib_frag_cache_find(ieee, seq, -1, tid,hdr->addr2,
+	entry = rtllib_frag_cache_find(ieee, seq, -1, tid, hdr->addr2,
 					  hdr->addr1);
 
 	if (entry == NULL) {
@@ -198,8 +198,6 @@ static int rtllib_frag_cache_invalidate(struct rtllib_device *ieee,
 	return 0;
 }
 
-
-
 /* rtllib_rx_frame_mgtmt
  *
  * Responsible for handling management control frames
@@ -217,7 +215,7 @@ rtllib_rx_frame_mgmt(struct rtllib_device *ieee, struct sk_buff *skb,
 	struct rtllib_hdr_3addr * hdr = (struct rtllib_hdr_3addr *)skb->data;
 
 	rx_stats->len = skb->len;
-	rtllib_rx_mgt(ieee,skb,rx_stats);
+	rtllib_rx_mgt(ieee, skb, rx_stats);
 	if ((memcmp(hdr->addr1, ieee->dev->dev_addr, ETH_ALEN))) {
 		dev_kfree_skb_any(skb);
 		return 0;
@@ -231,11 +229,13 @@ rtllib_rx_frame_mgmt(struct rtllib_device *ieee, struct sk_buff *skb,
 
 /* See IEEE 802.1H for LLC/SNAP encapsulation/decapsulation */
 /* Ethernet-II snap header (RFC1042 for most EtherTypes) */
-static unsigned char rfc1042_header[] =
-{ 0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00 };
+static unsigned char rfc1042_header[] = {
+	0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00
+};
 /* Bridge-Tunnel header (for EtherTypes ETH_P_AARP and ETH_P_IPX) */
-static unsigned char bridge_tunnel_header[] =
-{ 0xaa, 0xaa, 0x03, 0x00, 0x00, 0xf8 };
+static unsigned char bridge_tunnel_header[] = {
+	0xaa, 0xaa, 0x03, 0x00, 0x00, 0xf8
+};
 /* No encapsulation header if EtherType < 0x600 (=length) */
 
 /* Called by rtllib_rx_frame_decrypt */
@@ -280,8 +280,8 @@ static int rtllib_is_eapol_frame(struct rtllib_device *ieee,
 
 /* Called only as a tasklet (software IRQ), by rtllib_rx */
 static inline int
-rtllib_rx_frame_decrypt(struct rtllib_device* ieee, struct sk_buff *skb,
-			   struct rtllib_crypt_data *crypt)
+rtllib_rx_frame_decrypt(struct rtllib_device *ieee, struct sk_buff *skb,
+			struct rtllib_crypt_data *crypt)
 {
 	struct rtllib_hdr_4addr *hdr;
 	int res, hdrlen;
@@ -289,9 +289,8 @@ rtllib_rx_frame_decrypt(struct rtllib_device* ieee, struct sk_buff *skb,
 	if (crypt == NULL || crypt->ops->decrypt_mpdu == NULL)
 		return 0;
 
-	if (ieee->hwsec_active)
-	{
-		struct cb_desc *tcb_desc = (struct cb_desc *)(skb->cb+ MAX_DEV_ADDR_SIZE);
+	if (ieee->hwsec_active) {
+		struct cb_desc *tcb_desc = (struct cb_desc *)(skb->cb + MAX_DEV_ADDR_SIZE);
 		tcb_desc->bHwSec = 1;
 
 		if (ieee->need_sw_enc)
@@ -322,7 +321,7 @@ rtllib_rx_frame_decrypt(struct rtllib_device* ieee, struct sk_buff *skb,
 
 /* Called only as a tasklet (software IRQ), by rtllib_rx */
 static inline int
-rtllib_rx_frame_decrypt_msdu(struct rtllib_device* ieee, struct sk_buff *skb,
+rtllib_rx_frame_decrypt_msdu(struct rtllib_device *ieee, struct sk_buff *skb,
 			     int keyidx, struct rtllib_crypt_data *crypt)
 {
 	struct rtllib_hdr_4addr *hdr;
@@ -330,9 +329,8 @@ rtllib_rx_frame_decrypt_msdu(struct rtllib_device* ieee, struct sk_buff *skb,
 
 	if (crypt == NULL || crypt->ops->decrypt_msdu == NULL)
 		return 0;
-	if (ieee->hwsec_active)
-	{
-		struct cb_desc *tcb_desc = (struct cb_desc *)(skb->cb+ MAX_DEV_ADDR_SIZE);
+	if (ieee->hwsec_active) {
+		struct cb_desc *tcb_desc = (struct cb_desc *)(skb->cb + MAX_DEV_ADDR_SIZE);
 		tcb_desc->bHwSec = 1;
 
 		if (ieee->need_sw_enc)
@@ -343,7 +341,7 @@ rtllib_rx_frame_decrypt_msdu(struct rtllib_device* ieee, struct sk_buff *skb,
 	hdrlen = rtllib_get_hdrlen(le16_to_cpu(hdr->frame_ctl));
 
 	atomic_inc(&crypt->refcnt);
-	res = crypt->ops->decrypt_msdu(skb, keyidx, hdrlen, crypt->priv,ieee);
+	res = crypt->ops->decrypt_msdu(skb, keyidx, hdrlen, crypt->priv, ieee);
 	atomic_dec(&crypt->refcnt);
 	if (res < 0) {
 		printk(KERN_DEBUG "%s: MSDU decryption/MIC verification failed"
@@ -371,18 +369,18 @@ static int is_duplicate_packet(struct rtllib_device *ieee,
 	struct rtllib_hdr_4addrqos *hdr_4addrqos;
 	u8 tid;
 
-	if (((fc & RTLLIB_FCTL_DSTODS) == RTLLIB_FCTL_DSTODS)&&RTLLIB_QOS_HAS_SEQ(fc)) {
-	  hdr_4addrqos = (struct rtllib_hdr_4addrqos *)header;
-	  tid = le16_to_cpu(hdr_4addrqos->qos_ctl) & RTLLIB_QCTL_TID;
-	  tid = UP2AC(tid);
-	  tid ++;
+	if (((fc & RTLLIB_FCTL_DSTODS) == RTLLIB_FCTL_DSTODS) && RTLLIB_QOS_HAS_SEQ(fc)) {
+		hdr_4addrqos = (struct rtllib_hdr_4addrqos *)header;
+		tid = le16_to_cpu(hdr_4addrqos->qos_ctl) & RTLLIB_QCTL_TID;
+		tid = UP2AC(tid);
+		tid++;
 	} else if (RTLLIB_QOS_HAS_SEQ(fc)) {
-	  hdr_3addrqos = (struct rtllib_hdr_3addrqos*)header;
-	  tid = le16_to_cpu(hdr_3addrqos->qos_ctl) & RTLLIB_QCTL_TID;
-	  tid = UP2AC(tid);
-	  tid ++;
+		hdr_3addrqos = (struct rtllib_hdr_3addrqos *)header;
+		tid = le16_to_cpu(hdr_3addrqos->qos_ctl) & RTLLIB_QCTL_TID;
+		tid = UP2AC(tid);
+		tid++;
 	} else {
-	  tid = 0;
+		tid = 0;
 	}
 
 	switch (ieee->iw_mode) {
@@ -427,10 +425,8 @@ static int is_duplicate_packet(struct rtllib_device *ieee,
 
 	if ((*last_seq == seq) &&
 	    time_after(*last_time + IEEE_PACKET_RETRY_TIME, jiffies)) {
-		if (*last_frag == frag){
+		if (*last_frag == frag)
 			goto drop;
-
-		}
 		if (*last_frag + 1 != frag)
 			/* out-of-order fragment */
 			goto drop;
@@ -445,28 +441,18 @@ static int is_duplicate_packet(struct rtllib_device *ieee,
 
 	return 1;
 }
-bool
-AddReorderEntry(
-	struct rx_ts_record *pTS,
-	struct rx_reorder_entry *pReorderEntry
-	)
+
+bool AddReorderEntry(struct rx_ts_record *pTS, struct rx_reorder_entry *pReorderEntry)
 {
 	struct list_head *pList = &pTS->RxPendingPktList;
 
-	while(pList->next != &pTS->RxPendingPktList)
-	{
-		if ( SN_LESS(pReorderEntry->SeqNum, ((struct rx_reorder_entry *)list_entry(pList->next,struct rx_reorder_entry,List))->SeqNum) )
-		{
+	while (pList->next != &pTS->RxPendingPktList) {
+		if (SN_LESS(pReorderEntry->SeqNum, ((struct rx_reorder_entry *)list_entry(pList->next, struct rx_reorder_entry, List))->SeqNum))
 			pList = pList->next;
-		}
-		else if ( SN_EQUAL(pReorderEntry->SeqNum, ((struct rx_reorder_entry *)list_entry(pList->next,struct rx_reorder_entry,List))->SeqNum) )
-		{
+		else if (SN_EQUAL(pReorderEntry->SeqNum, ((struct rx_reorder_entry *)list_entry(pList->next, struct rx_reorder_entry, List))->SeqNum))
 			return false;
-		}
 		else
-		{
 			break;
-		}
 	}
 	pReorderEntry->List.next = pList->next;
 	pReorderEntry->List.next->prev = &pReorderEntry->List;
@@ -476,24 +462,24 @@ AddReorderEntry(
 	return true;
 }
 
-void rtllib_indicate_packets(struct rtllib_device *ieee, struct rtllib_rxb** prxbIndicateArray,u8  index)
+void rtllib_indicate_packets(struct rtllib_device *ieee, struct rtllib_rxb **prxbIndicateArray, u8 index)
 {
 	struct net_device_stats *stats = &ieee->stats;
-	u8 i = 0 , j=0;
+	u8 i = 0 , j = 0;
 	u16 ethertype;
 	for (j = 0; j < index; j++) {
-		struct rtllib_rxb* prxb = prxbIndicateArray[j];
-		for (i = 0; i<prxb->nr_subframes; i++) {
+		struct rtllib_rxb *prxb = prxbIndicateArray[j];
+		for (i = 0; i < prxb->nr_subframes; i++) {
 			struct sk_buff *sub_skb = prxb->subframes[i];
 
 		/* convert hdr + possible LLC headers into Ethernet header */
 			ethertype = (sub_skb->data[6] << 8) | sub_skb->data[7];
 			if (sub_skb->len >= 8 &&
-				((memcmp(sub_skb->data, rfc1042_header, SNAP_SIZE) == 0 &&
-				  ethertype != ETH_P_AARP && ethertype != ETH_P_IPX) ||
-				 memcmp(sub_skb->data, bridge_tunnel_header, SNAP_SIZE) == 0)) {
-			/* remove RFC1042 or Bridge-Tunnel encapsulation and
-			 * replace EtherType */
+			    ((memcmp(sub_skb->data, rfc1042_header, SNAP_SIZE) == 0 &&
+			    ethertype != ETH_P_AARP && ethertype != ETH_P_IPX) ||
+			    memcmp(sub_skb->data, bridge_tunnel_header, SNAP_SIZE) == 0)) {
+				/* remove RFC1042 or Bridge-Tunnel encapsulation
+				 * and replace EtherType */
 				skb_pull(sub_skb, SNAP_SIZE);
 				memcpy(skb_push(sub_skb, ETH_ALEN), prxb->src, ETH_ALEN);
 				memcpy(skb_push(sub_skb, ETH_ALEN), prxb->dst, ETH_ALEN);
@@ -506,7 +492,7 @@ void rtllib_indicate_packets(struct rtllib_device *ieee, struct rtllib_rxb** prx
 				memcpy(skb_push(sub_skb, ETH_ALEN), prxb->dst, ETH_ALEN);
 			}
 
-		/* Indicat the packets to upper layer */
+			/* Indicat the packets to upper layer */
 			if (sub_skb) {
 				stats->rx_packets++;
 				stats->rx_bytes += sub_skb->len;
@@ -526,24 +512,21 @@ void rtllib_indicate_packets(struct rtllib_device *ieee, struct rtllib_rxb** prx
 	}
 }
 
-void
-rtllib_FlushRxTsPendingPkts(struct rtllib_device *ieee,	struct rx_ts_record *pTS)
+void rtllib_FlushRxTsPendingPkts(struct rtllib_device *ieee,	struct rx_ts_record *pTS)
 {
 	struct rx_reorder_entry *pRxReorderEntry;
-	struct rtllib_rxb*		RfdArray[REORDER_WIN_SIZE];
-	u8					RfdCnt = 0;
-
+	struct rtllib_rxb *RfdArray[REORDER_WIN_SIZE];
+	u8 RfdCnt = 0;
 
 	del_timer_sync(&pTS->RxPktPendingTimer);
-	while(!list_empty(&pTS->RxPendingPktList))
-	{
-		if (RfdCnt >= REORDER_WIN_SIZE){
-			printk("-------------->%s() error! RfdCnt >= REORDER_WIN_SIZE\n", __func__);
+	while (!list_empty(&pTS->RxPendingPktList)) {
+		if (RfdCnt >= REORDER_WIN_SIZE) {
+			printk(KERN_INFO "-------------->%s() error! RfdCnt >= REORDER_WIN_SIZE\n", __func__);
 			break;
 		}
 
-		pRxReorderEntry = (struct rx_reorder_entry *)list_entry(pTS->RxPendingPktList.prev,struct rx_reorder_entry,List);
-		RTLLIB_DEBUG(RTLLIB_DL_REORDER,"%s(): Indicate SeqNum %d!\n",__func__, pRxReorderEntry->SeqNum);
+		pRxReorderEntry = (struct rx_reorder_entry *)list_entry(pTS->RxPendingPktList.prev, struct rx_reorder_entry, List);
+		RTLLIB_DEBUG(RTLLIB_DL_REORDER, "%s(): Indicate SeqNum %d!\n", __func__, pRxReorderEntry->SeqNum);
 		list_del_init(&pRxReorderEntry->List);
 
 		RfdArray[RfdCnt] = pRxReorderEntry->prxb;
@@ -556,41 +539,38 @@ rtllib_FlushRxTsPendingPkts(struct rtllib_device *ieee,	struct rx_ts_record *pTS
 	pTS->RxIndicateSeq = 0xffff;
 }
 
-
-void RxReorderIndicatePacket( struct rtllib_device *ieee,
-		struct rtllib_rxb* prxb,
-		struct rx_ts_record *pTS,
-		u16			SeqNum)
+void RxReorderIndicatePacket(struct rtllib_device *ieee, struct rtllib_rxb *prxb,
+		struct rx_ts_record *pTS, u16 SeqNum)
 {
 	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
 	struct rx_reorder_entry *pReorderEntry = NULL;
-	struct rtllib_rxb* prxbIndicateArray[REORDER_WIN_SIZE];
-	u8			WinSize = pHTInfo->RxReorderWinSize;
-	u16			WinEnd = 0;
-	u8			index = 0;
-	bool			bMatchWinStart = false, bPktInBuf = false;
+	struct rtllib_rxb *prxbIndicateArray[REORDER_WIN_SIZE];
+	u8 WinSize = pHTInfo->RxReorderWinSize;
+	u16 WinEnd = 0;
+	u8 index = 0;
+	bool bMatchWinStart = false, bPktInBuf = false;
 	unsigned long flags;
 
-	RTLLIB_DEBUG(RTLLIB_DL_REORDER,"%s(): Seq is %d,pTS->RxIndicateSeq is %d, WinSize is %d\n",__func__,SeqNum,pTS->RxIndicateSeq,WinSize);
+	RTLLIB_DEBUG(RTLLIB_DL_REORDER, "%s(): Seq is %d, pTS->RxIndicateSeq"
+		     " is %d, WinSize is %d\n", __func__, SeqNum,
+		     pTS->RxIndicateSeq, WinSize);
 
 	spin_lock_irqsave(&(ieee->reorder_spinlock), flags);
 
-	WinEnd = (pTS->RxIndicateSeq + WinSize -1)%4096;
+	WinEnd = (pTS->RxIndicateSeq + WinSize - 1) % 4096;
 	/* Rx Reorder initialize condition.*/
-	if (pTS->RxIndicateSeq == 0xffff) {
+	if (pTS->RxIndicateSeq == 0xffff)
 		pTS->RxIndicateSeq = SeqNum;
-	}
 
 	/* Drop out the packet which SeqNum is smaller than WinStart */
 	if (SN_LESS(SeqNum, pTS->RxIndicateSeq)) {
-		RTLLIB_DEBUG(RTLLIB_DL_REORDER,"Packet Drop! IndicateSeq: %d, NewSeq: %d\n",
+		RTLLIB_DEBUG(RTLLIB_DL_REORDER, "Packet Drop! IndicateSeq: %d, NewSeq: %d\n",
 				 pTS->RxIndicateSeq, SeqNum);
 		pHTInfo->RxReorderDropCounter++;
 		{
 			int i;
-			for (i =0; i < prxb->nr_subframes; i++) {
+			for (i = 0; i < prxb->nr_subframes; i++)
 				dev_kfree_skb(prxb->subframes[i]);
-			}
 			kfree(prxb);
 			prxb = NULL;
 		}
@@ -607,33 +587,38 @@ void RxReorderIndicatePacket( struct rtllib_device *ieee,
 		pTS->RxIndicateSeq = (pTS->RxIndicateSeq + 1) % 4096;
 		bMatchWinStart = true;
 	} else if (SN_LESS(WinEnd, SeqNum)) {
-		if (SeqNum >= (WinSize - 1)) {
-			pTS->RxIndicateSeq = SeqNum + 1 -WinSize;
-		} else {
-			pTS->RxIndicateSeq = 4095 - (WinSize - (SeqNum +1)) + 1;
-		}
-		RTLLIB_DEBUG(RTLLIB_DL_REORDER, "Window Shift! IndicateSeq: %d, NewSeq: %d\n",pTS->RxIndicateSeq, SeqNum);
+		if (SeqNum >= (WinSize - 1))
+			pTS->RxIndicateSeq = SeqNum + 1 - WinSize;
+		else
+			pTS->RxIndicateSeq = 4095 - (WinSize - (SeqNum + 1)) + 1;
+		RTLLIB_DEBUG(RTLLIB_DL_REORDER, "Window Shift! IndicateSeq: %d,"
+			     " NewSeq: %d\n", pTS->RxIndicateSeq, SeqNum);
 	}
 
 	/*
 	 * Indication process.
-	 * After Packet dropping and Sliding Window shifting as above, we can now just indicate the packets
-	 * with the SeqNum smaller than latest WinStart and struct buffer other packets.
+	 * After Packet dropping and Sliding Window shifting as above, we can
+	 * now just indicate the packets with the SeqNum smaller than latest
+	 * WinStart and struct buffer other packets.
 	 */
 	/* For Rx Reorder condition:
 	 * 1. All packets with SeqNum smaller than WinStart => Indicate
-	 * 2. All packets with SeqNum larger than or equal to WinStart => Buffer it.
+	 * 2. All packets with SeqNum larger than or equal to
+	 *	 WinStart => Buffer it.
 	 */
 	if (bMatchWinStart) {
 		/* Current packet is going to be indicated.*/
-		RTLLIB_DEBUG(RTLLIB_DL_REORDER, "Packets indication!! IndicateSeq: %d, NewSeq: %d\n",\
+		RTLLIB_DEBUG(RTLLIB_DL_REORDER, "Packets indication!! "
+				"IndicateSeq: %d, NewSeq: %d\n",
 				pTS->RxIndicateSeq, SeqNum);
 		prxbIndicateArray[0] = prxb;
 		index = 1;
 	} else {
 		/* Current packet is going to be inserted into pending list.*/
 		if (!list_empty(&ieee->RxReorder_Unused_List)) {
-			pReorderEntry = (struct rx_reorder_entry *)list_entry(ieee->RxReorder_Unused_List.next,struct rx_reorder_entry,List);
+			pReorderEntry = (struct rx_reorder_entry *)
+					list_entry(ieee->RxReorder_Unused_List.next,
+					struct rx_reorder_entry, List);
 			list_del_init(&pReorderEntry->List);
 
 			/* Make a reorder entry and insert into a the packet list.*/
@@ -641,34 +626,40 @@ void RxReorderIndicatePacket( struct rtllib_device *ieee,
 			pReorderEntry->prxb = prxb;
 
 			if (!AddReorderEntry(pTS, pReorderEntry)) {
-				RTLLIB_DEBUG(RTLLIB_DL_REORDER, "%s(): Duplicate packet is dropped!! IndicateSeq: %d, NewSeq: %d\n",
-					__func__, pTS->RxIndicateSeq, SeqNum);
-				list_add_tail(&pReorderEntry->List,&ieee->RxReorder_Unused_List);
-				{
+				RTLLIB_DEBUG(RTLLIB_DL_REORDER,
+					     "%s(): Duplicate packet is "
+					     "dropped!! IndicateSeq: %d, "
+					     "NewSeq: %d\n",
+					    __func__, pTS->RxIndicateSeq,
+					    SeqNum);
+				list_add_tail(&pReorderEntry->List,
+					      &ieee->RxReorder_Unused_List); {
 					int i;
-					for (i =0; i < prxb->nr_subframes; i++) {
+					for (i = 0; i < prxb->nr_subframes; i++)
 						dev_kfree_skb(prxb->subframes[i]);
-					}
 					kfree(prxb);
 					prxb = NULL;
 				}
 			} else {
 				RTLLIB_DEBUG(RTLLIB_DL_REORDER,
-					 "Pkt insert into struct buffer!! IndicateSeq: %d, NewSeq: %d\n",pTS->RxIndicateSeq, SeqNum);
+					 "Pkt insert into struct buffer!! "
+					 "IndicateSeq: %d, NewSeq: %d\n",
+					 pTS->RxIndicateSeq, SeqNum);
 			}
-		}
-		else {
+		} else {
 			/*
-			 * Packets are dropped if there is not enough reorder entries.
-			 * This part shall be modified!! We can just indicate all the
-			 * packets in struct buffer and get reorder entries.
+			 * Packets are dropped if there are not enough reorder
+			 * entries. This part should be modified!! We can just
+			 * indicate all the packets in struct buffer and get
+			 * reorder entries.
 			 */
-			RTLLIB_DEBUG(RTLLIB_DL_ERR, "RxReorderIndicatePacket(): There is no reorder entry!! Packet is dropped!!\n");
+			RTLLIB_DEBUG(RTLLIB_DL_ERR, "RxReorderIndicatePacket():"
+				     " There is no reorder entry!! Packet is "
+				     "dropped!!\n");
 			{
 				int i;
-				for (i =0; i < prxb->nr_subframes; i++) {
+				for (i = 0; i < prxb->nr_subframes; i++)
 					dev_kfree_skb(prxb->subframes[i]);
-				}
 				kfree(prxb);
 				prxb = NULL;
 			}
@@ -676,16 +667,17 @@ void RxReorderIndicatePacket( struct rtllib_device *ieee,
 	}
 
 	/* Check if there is any packet need indicate.*/
-	while(!list_empty(&pTS->RxPendingPktList)) {
-		RTLLIB_DEBUG(RTLLIB_DL_REORDER,"%s(): start RREORDER indicate\n",__func__);
+	while (!list_empty(&pTS->RxPendingPktList)) {
+		RTLLIB_DEBUG(RTLLIB_DL_REORDER, "%s(): start RREORDER indicate\n", __func__);
 
-		pReorderEntry = (struct rx_reorder_entry *)list_entry(pTS->RxPendingPktList.prev,struct rx_reorder_entry,List);
-		if ( SN_LESS(pReorderEntry->SeqNum, pTS->RxIndicateSeq) ||
-				SN_EQUAL(pReorderEntry->SeqNum, pTS->RxIndicateSeq))
-		{
+		pReorderEntry = (struct rx_reorder_entry *)list_entry(pTS->RxPendingPktList.prev,
+				 struct rx_reorder_entry, List);
+		if (SN_LESS(pReorderEntry->SeqNum, pTS->RxIndicateSeq) ||
+				SN_EQUAL(pReorderEntry->SeqNum, pTS->RxIndicateSeq)) {
 			/* This protect struct buffer from overflow. */
 			if (index >= REORDER_WIN_SIZE) {
-				RTLLIB_DEBUG(RTLLIB_DL_ERR, "RxReorderIndicatePacket(): Buffer overflow!! \n");
+				RTLLIB_DEBUG(RTLLIB_DL_ERR, "RxReorderIndicate"
+					     "Packet(): Buffer overflow!!\n");
 				bPktInBuf = true;
 				break;
 			}
@@ -696,74 +688,76 @@ void RxReorderIndicatePacket( struct rtllib_device *ieee,
 				pTS->RxIndicateSeq = (pTS->RxIndicateSeq + 1) % 4096;
 
 			prxbIndicateArray[index] = pReorderEntry->prxb;
-			RTLLIB_DEBUG(RTLLIB_DL_REORDER,"%s(): Indicate SeqNum %d!\n",__func__, pReorderEntry->SeqNum);
+			RTLLIB_DEBUG(RTLLIB_DL_REORDER, "%s(): Indicate SeqNum"
+				     " %d!\n", __func__, pReorderEntry->SeqNum);
 			index++;
 
-			list_add_tail(&pReorderEntry->List,&ieee->RxReorder_Unused_List);
+			list_add_tail(&pReorderEntry->List,
+				      &ieee->RxReorder_Unused_List);
 		} else {
 			bPktInBuf = true;
 			break;
 		}
 	}
 
-	/* Handling pending timer. Set this timer to prevent from long time Rx buffering.*/
-	if (index>0) {
-		if (timer_pending(&pTS->RxPktPendingTimer)){
+	/* Handling pending timer. Set this timer to prevent from long time
+	 * Rx buffering.*/
+	if (index > 0) {
+		if (timer_pending(&pTS->RxPktPendingTimer))
 			del_timer_sync(&pTS->RxPktPendingTimer);
-		}
 		pTS->RxTimeoutIndicateSeq = 0xffff;
 
-		if (index>REORDER_WIN_SIZE){
-			RTLLIB_DEBUG(RTLLIB_DL_ERR, "RxReorderIndicatePacket(): Rx Reorer struct buffer full!! \n");
-			spin_unlock_irqrestore(&(ieee->reorder_spinlock), flags);
+		if (index > REORDER_WIN_SIZE) {
+			RTLLIB_DEBUG(RTLLIB_DL_ERR, "RxReorderIndicatePacket():"
+				     " Rx Reorer struct buffer full!!\n");
+			spin_unlock_irqrestore(&(ieee->reorder_spinlock),
+					       flags);
 			return;
 		}
 		rtllib_indicate_packets(ieee, prxbIndicateArray, index);
 		bPktInBuf = false;
 	}
 
-	if (bPktInBuf && pTS->RxTimeoutIndicateSeq==0xffff) {
-		RTLLIB_DEBUG(RTLLIB_DL_REORDER,"%s(): SET rx timeout timer\n", __func__);
+	if (bPktInBuf && pTS->RxTimeoutIndicateSeq == 0xffff) {
+		RTLLIB_DEBUG(RTLLIB_DL_REORDER, "%s(): SET rx timeout timer\n",
+			     __func__);
 		pTS->RxTimeoutIndicateSeq = pTS->RxIndicateSeq;
-		mod_timer(&pTS->RxPktPendingTimer,  jiffies + MSECS(pHTInfo->RxReorderPendingTime));
+		mod_timer(&pTS->RxPktPendingTimer, jiffies +
+			  MSECS(pHTInfo->RxReorderPendingTime));
 	}
 	spin_unlock_irqrestore(&(ieee->reorder_spinlock), flags);
 }
 
-u8 parse_subframe(struct rtllib_device* ieee,struct sk_buff *skb,
-                  struct rtllib_rx_stats *rx_stats,
-		  struct rtllib_rxb *rxb,u8* src,u8* dst)
+u8 parse_subframe(struct rtllib_device *ieee, struct sk_buff *skb,
+		  struct rtllib_rx_stats *rx_stats,
+		  struct rtllib_rxb *rxb, u8 *src, u8 *dst)
 {
-	struct rtllib_hdr_3addr  *hdr = (struct rtllib_hdr_3addr* )skb->data;
+	struct rtllib_hdr_3addr  *hdr = (struct rtllib_hdr_3addr *)skb->data;
 	u16		fc = le16_to_cpu(hdr->frame_ctl);
 
-	u16		LLCOffset= sizeof(struct rtllib_hdr_3addr);
+	u16		LLCOffset = sizeof(struct rtllib_hdr_3addr);
 	u16		ChkLength;
 	bool		bIsAggregateFrame = false;
 	u16		nSubframe_Length;
 	u8		nPadding_Length = 0;
-	u16		SeqNum=0;
+	u16		SeqNum = 0;
 	struct sk_buff *sub_skb;
-	u8             *data_ptr;
+	u8	     *data_ptr;
 	/* just for debug purpose */
 	SeqNum = WLAN_GET_SEQ_SEQ(le16_to_cpu(hdr->seq_ctl));
-	if ((RTLLIB_QOS_HAS_SEQ(fc))&&\
-			(((union frameqos *)(skb->data + RTLLIB_3ADDR_LEN))->field.reserved)) {
+	if ((RTLLIB_QOS_HAS_SEQ(fc)) &&
+	   (((union frameqos *)(skb->data + RTLLIB_3ADDR_LEN))->field.reserved))
 		bIsAggregateFrame = true;
-	}
 
-	if (RTLLIB_QOS_HAS_SEQ(fc)) {
+	if (RTLLIB_QOS_HAS_SEQ(fc))
 		LLCOffset += 2;
-	}
-	if (rx_stats->bContainHTC) {
+	if (rx_stats->bContainHTC)
 		LLCOffset += sHTCLng;
-	}
 
-	ChkLength = LLCOffset;/* + (Frame_WEP(frame)!=0 ?Adapter->MgntInfo.SecurityInfo.EncryptionHeadOverhead:0);*/
+	ChkLength = LLCOffset;
 
-	if ( skb->len <= ChkLength ) {
+	if (skb->len <= ChkLength)
 		return 0;
-	}
 
 	skb_pull(skb, LLCOffset);
 	ieee->bIsAggregateFrame = bIsAggregateFrame;
@@ -787,25 +781,31 @@ u8 parse_subframe(struct rtllib_device* ieee,struct sk_buff *skb,
 
 		rxb->subframes[0] = sub_skb;
 
-		memcpy(rxb->src,src,ETH_ALEN);
-		memcpy(rxb->dst,dst,ETH_ALEN);
+		memcpy(rxb->src, src, ETH_ALEN);
+		memcpy(rxb->dst, dst, ETH_ALEN);
 		rxb->subframes[0]->dev = ieee->dev;
 		return 1;
 	} else {
 		rxb->nr_subframes = 0;
-		memcpy(rxb->src,src,ETH_ALEN);
-		memcpy(rxb->dst,dst,ETH_ALEN);
-		while(skb->len > ETHERNET_HEADER_SIZE) {
+		memcpy(rxb->src, src, ETH_ALEN);
+		memcpy(rxb->dst, dst, ETH_ALEN);
+		while (skb->len > ETHERNET_HEADER_SIZE) {
 			/* Offset 12 denote 2 mac address */
-			nSubframe_Length = *((u16*)(skb->data + 12));
-			nSubframe_Length = (nSubframe_Length>>8) + (nSubframe_Length<<8);
-
-			if (skb->len<(ETHERNET_HEADER_SIZE + nSubframe_Length)) {
-				printk("%s: A-MSDU parse error!! pRfd->nTotalSubframe : %d\n",\
-						__func__,rxb->nr_subframes);
-				printk("%s: A-MSDU parse error!! Subframe Length: %d\n",__func__, nSubframe_Length);
-				printk("nRemain_Length is %d and nSubframe_Length is : %d\n",skb->len,nSubframe_Length);
-				printk("The Packet SeqNum is %d\n",SeqNum);
+			nSubframe_Length = *((u16 *)(skb->data + 12));
+			nSubframe_Length = (nSubframe_Length >> 8) +
+					   (nSubframe_Length << 8);
+
+			if (skb->len < (ETHERNET_HEADER_SIZE + nSubframe_Length)) {
+				printk(KERN_INFO "%s: A-MSDU parse error!! "
+				       "pRfd->nTotalSubframe : %d\n",\
+				       __func__, rxb->nr_subframes);
+				printk(KERN_INFO "%s: A-MSDU parse error!! "
+				       "Subframe Length: %d\n", __func__,
+				       nSubframe_Length);
+				printk(KERN_INFO "nRemain_Length is %d and "
+				       "nSubframe_Length is : %d\n", skb->len,
+				       nSubframe_Length);
+				printk(KERN_INFO "The Packet SeqNum is %d\n", SeqNum);
 				return 0;
 			}
 
@@ -824,27 +824,27 @@ u8 parse_subframe(struct rtllib_device* ieee,struct sk_buff *skb,
 			sub_skb = dev_alloc_skb(nSubframe_Length + 12);
 			skb_reserve(sub_skb, 12);
 			data_ptr = (u8 *)skb_put(sub_skb, nSubframe_Length);
-			memcpy(data_ptr,skb->data,nSubframe_Length);
+			memcpy(data_ptr, skb->data, nSubframe_Length);
 
 			sub_skb->dev = ieee->dev;
 			rxb->subframes[rxb->nr_subframes++] = sub_skb;
 			if (rxb->nr_subframes >= MAX_SUBFRAME_COUNT) {
-				RTLLIB_DEBUG_RX("ParseSubframe(): Too many Subframes! Packets dropped!\n");
+				RTLLIB_DEBUG_RX("ParseSubframe(): Too many "
+						"Subframes! Packets dropped!\n");
 				break;
 			}
-			skb_pull(skb,nSubframe_Length);
+			skb_pull(skb, nSubframe_Length);
 
 			if (skb->len != 0) {
-				nPadding_Length = 4 - ((nSubframe_Length + ETHERNET_HEADER_SIZE) % 4);
-				if (nPadding_Length == 4) {
+				nPadding_Length = 4 - ((nSubframe_Length +
+						  ETHERNET_HEADER_SIZE) % 4);
+				if (nPadding_Length == 4)
 					nPadding_Length = 0;
-				}
 
-				if (skb->len < nPadding_Length) {
+				if (skb->len < nPadding_Length)
 					return 0;
-				}
 
-				skb_pull(skb,nPadding_Length);
+				skb_pull(skb, nPadding_Length);
 			}
 		}
 
@@ -863,7 +863,7 @@ size_t rtllib_rx_get_hdrlen(struct rtllib_device *ieee, struct sk_buff *skb,
 	hdrlen = rtllib_get_hdrlen(fc);
 	if (HTCCheck(ieee, skb->data)) {
 		if (net_ratelimit())
-			printk("%s: find HTCControl!\n", __func__);
+			printk(KERN_INFO "%s: find HTCControl!\n", __func__);
 		hdrlen += 4;
 		rx_stats->bContainHTC = 1;
 	}
@@ -874,7 +874,8 @@ size_t rtllib_rx_get_hdrlen(struct rtllib_device *ieee, struct sk_buff *skb,
 	return hdrlen;
 }
 
-int rtllib_rx_check_duplicate(struct rtllib_device *ieee, struct sk_buff *skb, u8 multicast)
+int rtllib_rx_check_duplicate(struct rtllib_device *ieee, struct sk_buff *skb,
+			      u8 multicast)
 {
 	struct rtllib_hdr_4addr *hdr = (struct rtllib_hdr_4addr *)skb->data;
 	u16 fc, sc;
@@ -886,19 +887,18 @@ int rtllib_rx_check_duplicate(struct rtllib_device *ieee, struct sk_buff *skb, u
 	sc = le16_to_cpu(hdr->seq_ctl);
 	frag = WLAN_GET_SEQ_FRAG(sc);
 
-	if ( (ieee->pHTInfo->bCurRxReorderEnable == false) ||
+	if ((ieee->pHTInfo->bCurRxReorderEnable == false) ||
 		!ieee->current_network.qos_data.active ||
 		!IsDataFrame(skb->data) ||
 		IsLegacyDataFrame(skb->data)) {
-		if (!((type == RTLLIB_FTYPE_MGMT) && (stype == RTLLIB_STYPE_BEACON))){
-			if (is_duplicate_packet(ieee, hdr)){
+		if (!((type == RTLLIB_FTYPE_MGMT) && (stype == RTLLIB_STYPE_BEACON))) {
+			if (is_duplicate_packet(ieee, hdr))
 				return -1;
-			}
 		}
 	} else {
 		struct rx_ts_record *pRxTS = NULL;
 		if (GetTs(ieee, (struct ts_common_info **) &pRxTS, hdr->addr2,
-			(u8)Frame_QoSTID((u8*)(skb->data)), RX_DIR, true)) {
+			(u8)Frame_QoSTID((u8 *)(skb->data)), RX_DIR, true)) {
 			if ((fc & (1<<11)) && (frag == pRxTS->RxLastFragNum) &&
 			    (WLAN_GET_SEQ_SEQ(sc) == pRxTS->RxLastSeqNum)) {
 				return -1;
@@ -907,41 +907,47 @@ int rtllib_rx_check_duplicate(struct rtllib_device *ieee, struct sk_buff *skb, u
 				pRxTS->RxLastSeqNum = WLAN_GET_SEQ_SEQ(sc);
 			}
 		} else {
-			RTLLIB_DEBUG(RTLLIB_DL_ERR, "ERR!!%s(): No TS!! Skip the check!!\n",__func__);
+			RTLLIB_DEBUG(RTLLIB_DL_ERR, "ERR!!%s(): No TS!! Skip"
+				     " the check!!\n", __func__);
 			return -1;
 		}
 	}
 
 	return 0;
 }
-void rtllib_rx_extract_addr(struct rtllib_device *ieee, struct rtllib_hdr_4addr *hdr, u8 *dst, u8 *src, u8 *bssid)
+
+void rtllib_rx_extract_addr(struct rtllib_device *ieee,
+			    struct rtllib_hdr_4addr *hdr, u8 *dst, u8 *src,
+			    u8 *bssid)
 {
 	u16 fc = le16_to_cpu(hdr->frame_ctl);
 
 	switch (fc & (RTLLIB_FCTL_FROMDS | RTLLIB_FCTL_TODS)) {
-		case RTLLIB_FCTL_FROMDS:
-			memcpy(dst, hdr->addr1, ETH_ALEN);
-			memcpy(src, hdr->addr3, ETH_ALEN);
-			memcpy(bssid, hdr->addr2, ETH_ALEN);
-			break;
-		case RTLLIB_FCTL_TODS:
-			memcpy(dst, hdr->addr3, ETH_ALEN);
-			memcpy(src, hdr->addr2, ETH_ALEN);
-			memcpy(bssid, hdr->addr1, ETH_ALEN);
-			break;
-		case RTLLIB_FCTL_FROMDS | RTLLIB_FCTL_TODS:
-			memcpy(dst, hdr->addr3, ETH_ALEN);
-			memcpy(src, hdr->addr4, ETH_ALEN);
-			memcpy(bssid, ieee->current_network.bssid, ETH_ALEN);
-			break;
-		case 0:
-			memcpy(dst, hdr->addr1, ETH_ALEN);
-			memcpy(src, hdr->addr2, ETH_ALEN);
-			memcpy(bssid, hdr->addr3, ETH_ALEN);
-			break;
+	case RTLLIB_FCTL_FROMDS:
+		memcpy(dst, hdr->addr1, ETH_ALEN);
+		memcpy(src, hdr->addr3, ETH_ALEN);
+		memcpy(bssid, hdr->addr2, ETH_ALEN);
+		break;
+	case RTLLIB_FCTL_TODS:
+		memcpy(dst, hdr->addr3, ETH_ALEN);
+		memcpy(src, hdr->addr2, ETH_ALEN);
+		memcpy(bssid, hdr->addr1, ETH_ALEN);
+		break;
+	case RTLLIB_FCTL_FROMDS | RTLLIB_FCTL_TODS:
+		memcpy(dst, hdr->addr3, ETH_ALEN);
+		memcpy(src, hdr->addr4, ETH_ALEN);
+		memcpy(bssid, ieee->current_network.bssid, ETH_ALEN);
+		break;
+	case 0:
+		memcpy(dst, hdr->addr1, ETH_ALEN);
+		memcpy(src, hdr->addr2, ETH_ALEN);
+		memcpy(bssid, hdr->addr3, ETH_ALEN);
+		break;
 	}
 }
-int rtllib_rx_data_filter(struct rtllib_device *ieee, u16 fc, u8 *dst, u8 *src, u8 *bssid, u8 *addr2)
+
+int rtllib_rx_data_filter(struct rtllib_device *ieee, u16 fc, u8 *dst, u8 *src,
+			  u8 *bssid, u8 *addr2)
 {
 	u8 zero_addr[ETH_ALEN] = {0};
 	u8 type, stype;
@@ -951,14 +957,14 @@ int rtllib_rx_data_filter(struct rtllib_device *ieee, u16 fc, u8 *dst, u8 *src,
 
 	/* Filter frames from different BSS */
 	if (((fc & RTLLIB_FCTL_DSTODS) != RTLLIB_FCTL_DSTODS)
-                && (compare_ether_addr(ieee->current_network.bssid, bssid) != 0)
-                && memcmp(ieee->current_network.bssid, zero_addr, ETH_ALEN)) {
+		&& (compare_ether_addr(ieee->current_network.bssid, bssid) != 0)
+		&& memcmp(ieee->current_network.bssid, zero_addr, ETH_ALEN)) {
 		return -1;
 	}
 
 	/* Filter packets sent by an STA that will be forwarded by AP */
-	if ( ieee->IntelPromiscuousModeInfo.bPromiscuousOn  &&
-                ieee->IntelPromiscuousModeInfo.bFilterSourceStationFrame ) {
+	if (ieee->IntelPromiscuousModeInfo.bPromiscuousOn  &&
+		ieee->IntelPromiscuousModeInfo.bFilterSourceStationFrame) {
 		if ((fc & RTLLIB_FCTL_TODS) && !(fc & RTLLIB_FCTL_FROMDS) &&
 			(compare_ether_addr(dst, ieee->current_network.bssid) != 0) &&
 			(compare_ether_addr(bssid, ieee->current_network.bssid) == 0)) {
@@ -968,13 +974,12 @@ int rtllib_rx_data_filter(struct rtllib_device *ieee, u16 fc, u8 *dst, u8 *src,
 
 	/* Nullfunc frames may have PS-bit set, so they must be passed to
 	 * hostap_handle_sta_rx() before being dropped here. */
-	if (!ieee->IntelPromiscuousModeInfo.bPromiscuousOn){
+	if (!ieee->IntelPromiscuousModeInfo.bPromiscuousOn) {
 		if (stype != RTLLIB_STYPE_DATA &&
 		    stype != RTLLIB_STYPE_DATA_CFACK &&
 		    stype != RTLLIB_STYPE_DATA_CFPOLL &&
-		    stype != RTLLIB_STYPE_DATA_CFACKPOLL&&
-		    stype != RTLLIB_STYPE_QOS_DATA
-		    ) {
+		    stype != RTLLIB_STYPE_DATA_CFACKPOLL &&
+		    stype != RTLLIB_STYPE_QOS_DATA) {
 			if (stype != RTLLIB_STYPE_NULLFUNC)
 				RTLLIB_DEBUG_DROP(
 					"RX: dropped data frame "
@@ -992,18 +997,15 @@ int rtllib_rx_data_filter(struct rtllib_device *ieee, u16 fc, u8 *dst, u8 *src,
 
 		/* {broad,multi}cast packets to our BSS go through */
 		if (is_multicast_ether_addr(dst) || is_broadcast_ether_addr(dst)) {
-			if (memcmp(bssid, ieee->current_network.bssid, ETH_ALEN)) {
+			if (memcmp(bssid, ieee->current_network.bssid, ETH_ALEN))
 				return -1;
-			}
 		}
 	}
 	return 0;
 }
-int rtllib_rx_get_crypt(
-		struct rtllib_device *ieee,
-		struct sk_buff *skb,
-		struct rtllib_crypt_data **crypt,
-		size_t hdrlen)
+
+int rtllib_rx_get_crypt(struct rtllib_device *ieee, struct sk_buff *skb,
+			struct rtllib_crypt_data **crypt, size_t hdrlen)
 {
 	struct rtllib_hdr_4addr *hdr = (struct rtllib_hdr_4addr *)skb->data;
 	u16 fc = le16_to_cpu(hdr->frame_ctl);
@@ -1035,12 +1037,10 @@ int rtllib_rx_get_crypt(
 
 	return 0;
 }
-int rtllib_rx_decrypt(
-		struct rtllib_device *ieee,
-		struct sk_buff *skb,
-		struct rtllib_rx_stats *rx_stats,
-		struct rtllib_crypt_data *crypt,
-		size_t hdrlen)
+
+int rtllib_rx_decrypt(struct rtllib_device *ieee, struct sk_buff *skb,
+		      struct rtllib_rx_stats *rx_stats,
+		      struct rtllib_crypt_data *crypt, size_t hdrlen)
 {
 	struct rtllib_hdr_4addr *hdr;
 	int keyidx = 0;
@@ -1052,15 +1052,14 @@ int rtllib_rx_decrypt(
 	sc = le16_to_cpu(hdr->seq_ctl);
 	frag = WLAN_GET_SEQ_FRAG(sc);
 
-	if ((!rx_stats->Decrypted)){
+	if ((!rx_stats->Decrypted))
 		ieee->need_sw_enc = 1;
-	}else{
+	else
 		ieee->need_sw_enc = 0;
-	}
 
-	if (ieee->host_decrypt && (fc & RTLLIB_FCTL_WEP) &&
-	    ((keyidx = rtllib_rx_frame_decrypt(ieee, skb, crypt)) < 0)) {
-		printk("%s: decrypt frame error\n", __func__);
+	keyidx = rtllib_rx_frame_decrypt(ieee, skb, crypt);
+	if (ieee->host_decrypt && (fc & RTLLIB_FCTL_WEP) && (keyidx < 0)) {
+		printk(KERN_INFO "%s: decrypt frame error\n", __func__);
 		return -1;
 	}
 
@@ -1120,9 +1119,8 @@ int rtllib_rx_decrypt(
 	/* skb: hdr + (possible reassembled) full MSDU payload; possibly still
 	 * encrypted/authenticated */
 	if (ieee->host_decrypt && (fc & RTLLIB_FCTL_WEP) &&
-		rtllib_rx_frame_decrypt_msdu(ieee, skb, keyidx, crypt))
-	{
-		printk("%s: ==>decrypt msdu error\n", __func__);
+		rtllib_rx_frame_decrypt_msdu(ieee, skb, keyidx, crypt)) {
+		printk(KERN_INFO "%s: ==>decrypt msdu error\n", __func__);
 		return -1;
 	}
 
@@ -1164,21 +1162,20 @@ int rtllib_rx_decrypt(
 		return -1;
 	}
 
-	if (rtllib_is_eapol_frame(ieee, skb, hdrlen)) {
+	if (rtllib_is_eapol_frame(ieee, skb, hdrlen))
 		printk(KERN_WARNING "RX: IEEE802.1X EAPOL frame!\n");
-	}
 
 	return 0;
 }
+
 void rtllib_rx_check_leave_lps(struct rtllib_device *ieee, u8 unicast, u8 nr_subframes)
 {
-	if (unicast){
+	if (unicast) {
 
-		if ((ieee->state == RTLLIB_LINKED) /*&& !MgntInitAdapterInProgress(pMgntInfo)*/)
-		{
-			if (	((ieee->LinkDetectInfo.NumRxUnicastOkInPeriod +ieee->LinkDetectInfo.NumTxOkInPeriod) > 8 ) ||
-				(ieee->LinkDetectInfo.NumRxUnicastOkInPeriod > 2) )
-			{
+		if ((ieee->state == RTLLIB_LINKED)) {
+			if (((ieee->LinkDetectInfo.NumRxUnicastOkInPeriod +
+			    ieee->LinkDetectInfo.NumTxOkInPeriod) > 8) ||
+			    (ieee->LinkDetectInfo.NumRxUnicastOkInPeriod > 2)) {
 				if (ieee->LeisurePSLeave)
 					ieee->LeisurePSLeave(ieee->dev);
 			}
@@ -1186,10 +1183,10 @@ void rtllib_rx_check_leave_lps(struct rtllib_device *ieee, u8 unicast, u8 nr_sub
 	}
 	ieee->last_rx_ps_time = jiffies;
 }
-void rtllib_rx_indicate_pkt_legacy(
-		struct rtllib_device *ieee,
+
+void rtllib_rx_indicate_pkt_legacy(struct rtllib_device *ieee,
 		struct rtllib_rx_stats *rx_stats,
-		struct rtllib_rxb* rxb,
+		struct rtllib_rxb *rxb,
 		u8 *dst,
 		u8 *src)
 {
@@ -1197,21 +1194,21 @@ void rtllib_rx_indicate_pkt_legacy(
 	u16 ethertype;
 	int i = 0;
 
-	if (rxb == NULL){
-		printk("%s: rxb is NULL!!\n", __func__);
+	if (rxb == NULL) {
+		printk(KERN_INFO "%s: rxb is NULL!!\n", __func__);
 		return ;
 	}
 
-	for (i = 0; i<rxb->nr_subframes; i++) {
+	for (i = 0; i < rxb->nr_subframes; i++) {
 		struct sk_buff *sub_skb = rxb->subframes[i];
 
 		if (sub_skb) {
 			/* convert hdr + possible LLC headers into Ethernet header */
 			ethertype = (sub_skb->data[6] << 8) | sub_skb->data[7];
 			if (sub_skb->len >= 8 &&
-					((memcmp(sub_skb->data, rfc1042_header, SNAP_SIZE) == 0 &&
-					  ethertype != ETH_P_AARP && ethertype != ETH_P_IPX) ||
-					 memcmp(sub_skb->data, bridge_tunnel_header, SNAP_SIZE) == 0)) {
+				((memcmp(sub_skb->data, rfc1042_header, SNAP_SIZE) == 0 &&
+				ethertype != ETH_P_AARP && ethertype != ETH_P_IPX) ||
+				memcmp(sub_skb->data, bridge_tunnel_header, SNAP_SIZE) == 0)) {
 				/* remove RFC1042 or Bridge-Tunnel encapsulation and
 				 * replace EtherType */
 				skb_pull(sub_skb, SNAP_SIZE);
@@ -1229,9 +1226,8 @@ void rtllib_rx_indicate_pkt_legacy(
 			ieee->stats.rx_packets++;
 			ieee->stats.rx_bytes += sub_skb->len;
 
-			if (is_multicast_ether_addr(dst)) {
+			if (is_multicast_ether_addr(dst))
 				ieee->stats.multicast++;
-			}
 
 			/* Indicat the packets to upper layer */
 			memset(sub_skb->cb, 0, sizeof(sub_skb->cb));
@@ -1246,13 +1242,14 @@ void rtllib_rx_indicate_pkt_legacy(
 	kfree(rxb);
 	rxb = NULL;
 }
+
 int rtllib_rx_InfraAdhoc(struct rtllib_device *ieee, struct sk_buff *skb,
 		 struct rtllib_rx_stats *rx_stats)
 {
 	struct net_device *dev = ieee->dev;
 	struct rtllib_hdr_4addr *hdr = (struct rtllib_hdr_4addr *)skb->data;
 	struct rtllib_crypt_data *crypt = NULL;
-	struct rtllib_rxb* rxb = NULL;
+	struct rtllib_rxb *rxb = NULL;
 	struct rx_ts_record *pTS = NULL;
 	u16 fc, sc, SeqNum = 0;
 	u8 type, stype, multicast = 0, unicast = 0, nr_subframes = 0, TID = 0;
@@ -1279,8 +1276,8 @@ int rtllib_rx_InfraAdhoc(struct rtllib_device *ieee, struct sk_buff *skb,
 
 	/*Filter pkt has too small length */
 	hdrlen = rtllib_rx_get_hdrlen(ieee, skb, rx_stats);
-	if (skb->len < hdrlen){
-		printk("%s():ERR!!! skb->len is smaller than hdrlen\n",__func__);
+	if (skb->len < hdrlen) {
+		printk(KERN_INFO "%s():ERR!!! skb->len is smaller than hdrlen\n", __func__);
 		goto rx_dropped;
 	}
 
@@ -1290,9 +1287,8 @@ int rtllib_rx_InfraAdhoc(struct rtllib_device *ieee, struct sk_buff *skb,
 		goto rx_dropped;
 
 	/* Filter CTRL Frame */
-	if (type == RTLLIB_FTYPE_CTL) {
+	if (type == RTLLIB_FTYPE_CTL)
 		goto rx_dropped;
-	}
 
 	/* Filter MGNT Frame */
 	if (type == RTLLIB_FTYPE_MGMT) {
@@ -1307,7 +1303,7 @@ int rtllib_rx_InfraAdhoc(struct rtllib_device *ieee, struct sk_buff *skb,
 	/* Filter WAPI DATA Frame */
 
 	/* Update statstics for AP roaming */
-	if (!bToOtherSTA){
+	if (!bToOtherSTA) {
 		ieee->LinkDetectInfo.NumRecvDataInPeriod++;
 		ieee->LinkDetectInfo.NumRxOkInPeriod++;
 	}
@@ -1321,9 +1317,8 @@ int rtllib_rx_InfraAdhoc(struct rtllib_device *ieee, struct sk_buff *skb,
 	if (ret < 0)
 		goto rx_dropped;
 
-	if (skb->len == hdrlen){
+	if (skb->len == hdrlen)
 		goto rx_dropped;
-	}
 
 	/* Send pspoll based on moredata */
 	if ((ieee->iw_mode == IW_MODE_INFRA)  && (ieee->sta_sleep == LPS_IS_SLEEP)
@@ -1352,32 +1347,29 @@ int rtllib_rx_InfraAdhoc(struct rtllib_device *ieee, struct sk_buff *skb,
 	hdr = (struct rtllib_hdr_4addr *) skb->data;
 	if (ieee->current_network.qos_data.active && IsQoSDataFrame(skb->data)
 		&& !is_multicast_ether_addr(hdr->addr1) && !is_broadcast_ether_addr(hdr->addr1)
-		&& (!bToOtherSTA))
-	{
+		&& (!bToOtherSTA)) {
 		TID = Frame_QoSTID(skb->data);
 		SeqNum = WLAN_GET_SEQ_SEQ(sc);
-		GetTs(ieee,(struct ts_common_info **) &pTS,hdr->addr2,TID,RX_DIR,true);
-		if (TID !=0 && TID !=3){
+		GetTs(ieee, (struct ts_common_info **) &pTS, hdr->addr2, TID, RX_DIR, true);
+		if (TID != 0 && TID != 3)
 			ieee->bis_any_nonbepkts = true;
-		}
 	}
 
 	/* Parse rx data frame (For AMSDU) */
 	/* skb: hdr + (possible reassembled) full plaintext payload */
 	payload = skb->data + hdrlen;
-	rxb = (struct rtllib_rxb*)kmalloc(sizeof(struct rtllib_rxb),GFP_ATOMIC);
-	if (rxb == NULL)
-	{
-		RTLLIB_DEBUG(RTLLIB_DL_ERR,"%s(): kmalloc rxb error\n",__func__);
+	rxb = kmalloc(sizeof(struct rtllib_rxb), GFP_ATOMIC);
+	if (rxb == NULL) {
+		RTLLIB_DEBUG(RTLLIB_DL_ERR,
+			     "%s(): kmalloc rxb error\n", __func__);
 		goto rx_dropped;
 	}
 	/* to parse amsdu packets */
 	/* qos data packets & reserved bit is 1 */
-	if (parse_subframe(ieee,skb,rx_stats,rxb,src,dst) == 0) {
+	if (parse_subframe(ieee, skb, rx_stats, rxb, src, dst) == 0) {
 		/* only to free rxb, and not submit the packets to upper layer */
-		for (i =0; i < rxb->nr_subframes; i++) {
+		for (i = 0; i < rxb->nr_subframes; i++)
 			dev_kfree_skb(rxb->subframes[i]);
-		}
 		kfree(rxb);
 		rxb = NULL;
 		goto rx_dropped;
@@ -1386,7 +1378,7 @@ int rtllib_rx_InfraAdhoc(struct rtllib_device *ieee, struct sk_buff *skb,
 	/* Update WAPI PN */
 
 	/* Check if leave LPS */
-	if (!bToOtherSTA){
+	if (!bToOtherSTA) {
 		if (ieee->bIsAggregateFrame)
 			nr_subframes = rxb->nr_subframes;
 		else
@@ -1397,11 +1389,10 @@ int rtllib_rx_InfraAdhoc(struct rtllib_device *ieee, struct sk_buff *skb,
 	}
 
 	/* Indicate packets to upper layer or Rx Reorder */
-	if (ieee->pHTInfo->bCurRxReorderEnable == false ||pTS == NULL || bToOtherSTA){
+	if (ieee->pHTInfo->bCurRxReorderEnable == false || pTS == NULL || bToOtherSTA)
 		rtllib_rx_indicate_pkt_legacy(ieee, rx_stats, rxb, dst, src);
-	}else{
+	else
 		RxReorderIndicatePacket(ieee, rxb, pTS, SeqNum);
-	}
 
 	dev_kfree_skb(skb);
 
@@ -1409,8 +1400,7 @@ int rtllib_rx_InfraAdhoc(struct rtllib_device *ieee, struct sk_buff *skb,
 	return 1;
 
  rx_dropped:
-	if (rxb != NULL)
-	{
+	if (rxb != NULL) {
 		kfree(rxb);
 		rxb = NULL;
 	}
@@ -1427,6 +1417,7 @@ int rtllib_rx_Master(struct rtllib_device *ieee, struct sk_buff *skb,
 {
 	return 0;
 }
+
 int rtllib_rx_Monitor(struct rtllib_device *ieee, struct sk_buff *skb,
 		 struct rtllib_rx_stats *rx_stats)
 {
@@ -1434,14 +1425,14 @@ int rtllib_rx_Monitor(struct rtllib_device *ieee, struct sk_buff *skb,
 	u16 fc = le16_to_cpu(hdr->frame_ctl);
 	size_t hdrlen = rtllib_get_hdrlen(fc);
 
-	if (skb->len < hdrlen){
-		printk("%s():ERR!!! skb->len is smaller than hdrlen\n", __func__);
+	if (skb->len < hdrlen) {
+		printk(KERN_INFO "%s():ERR!!! skb->len is smaller than hdrlen\n", __func__);
 		return 0;
 	}
 
 	if (HTCCheck(ieee, skb->data)) {
 		if (net_ratelimit())
-			printk("%s: Find HTCControl!\n", __func__);
+			printk(KERN_INFO "%s: Find HTCControl!\n", __func__);
 		hdrlen += 4;
 	}
 
@@ -1466,12 +1457,12 @@ int rtllib_rx(struct rtllib_device *ieee, struct sk_buff *skb,
 {
 	int ret = 0;
 
-	if ((NULL==ieee) || (NULL==skb) || (NULL==rx_stats)){
+	if ((NULL == ieee) || (NULL == skb) || (NULL == rx_stats)) {
 		printk(KERN_INFO "%s: Input parameters NULL!\n", __func__);
 		goto rx_dropped;
 	}
 	if (skb->len < 10) {
-		printk(KERN_INFO "%s: SKB length < 10 \n", __func__);
+		printk(KERN_INFO "%s: SKB length < 10\n", __func__);
 		goto rx_dropped;
 	}
 
@@ -1509,19 +1500,19 @@ static u8 qos_oui[QOS_OUI_LEN] = { 0x00, 0x50, 0xF2 };
 * the right values
 */
 static int rtllib_verify_qos_info(struct rtllib_qos_information_element
-                                     *info_element, int sub_type)
+				     *info_element, int sub_type)
 {
 
-        if (info_element->qui_subtype != sub_type)
-                return -1;
-        if (memcmp(info_element->qui, qos_oui, QOS_OUI_LEN))
-                return -1;
-        if (info_element->qui_type != QOS_OUI_TYPE)
-                return -1;
-        if (info_element->version != QOS_VERSION_1)
-                return -1;
+	if (info_element->qui_subtype != sub_type)
+		return -1;
+	if (memcmp(info_element->qui, qos_oui, QOS_OUI_LEN))
+		return -1;
+	if (info_element->qui_type != QOS_OUI_TYPE)
+		return -1;
+	if (info_element->version != QOS_VERSION_1)
+		return -1;
 
-        return 0;
+	return 0;
 }
 
 
@@ -1529,56 +1520,56 @@ static int rtllib_verify_qos_info(struct rtllib_qos_information_element
  * Parse a QoS parameter element
  */
 static int rtllib_read_qos_param_element(struct rtllib_qos_parameter_info
-                                            *element_param, struct rtllib_info_element
-                                            *info_element)
+					    *element_param, struct rtllib_info_element
+					    *info_element)
 {
-        int ret = 0;
-        u16 size = sizeof(struct rtllib_qos_parameter_info) - 2;
-
-        if ((info_element == NULL) || (element_param == NULL))
-                return -1;
-
-        if (info_element->id == QOS_ELEMENT_ID && info_element->len == size) {
-                memcpy(element_param->info_element.qui, info_element->data,
-                       info_element->len);
-                element_param->info_element.elementID = info_element->id;
-                element_param->info_element.length = info_element->len;
-        } else
-                ret = -1;
-        if (ret == 0)
-                ret = rtllib_verify_qos_info(&element_param->info_element,
-                                                QOS_OUI_PARAM_SUB_TYPE);
-        return ret;
+	int ret = 0;
+	u16 size = sizeof(struct rtllib_qos_parameter_info) - 2;
+
+	if ((info_element == NULL) || (element_param == NULL))
+		return -1;
+
+	if (info_element->id == QOS_ELEMENT_ID && info_element->len == size) {
+		memcpy(element_param->info_element.qui, info_element->data,
+		       info_element->len);
+		element_param->info_element.elementID = info_element->id;
+		element_param->info_element.length = info_element->len;
+	} else
+		ret = -1;
+	if (ret == 0)
+		ret = rtllib_verify_qos_info(&element_param->info_element,
+						QOS_OUI_PARAM_SUB_TYPE);
+	return ret;
 }
 
 /*
  * Parse a QoS information element
  */
 static int rtllib_read_qos_info_element(struct
-                                           rtllib_qos_information_element
-                                           *element_info, struct rtllib_info_element
-                                           *info_element)
+					   rtllib_qos_information_element
+					   *element_info, struct rtllib_info_element
+					   *info_element)
 {
-        int ret = 0;
-        u16 size = sizeof(struct rtllib_qos_information_element) - 2;
-
-        if (element_info == NULL)
-                return -1;
-        if (info_element == NULL)
-                return -1;
-
-        if ((info_element->id == QOS_ELEMENT_ID) && (info_element->len == size)) {
-                memcpy(element_info->qui, info_element->data,
-                       info_element->len);
-                element_info->elementID = info_element->id;
-                element_info->length = info_element->len;
-        } else
-                ret = -1;
-
-        if (ret == 0)
-                ret = rtllib_verify_qos_info(element_info,
-                                                QOS_OUI_INFO_SUB_TYPE);
-        return ret;
+	int ret = 0;
+	u16 size = sizeof(struct rtllib_qos_information_element) - 2;
+
+	if (element_info == NULL)
+		return -1;
+	if (info_element == NULL)
+		return -1;
+
+	if ((info_element->id == QOS_ELEMENT_ID) && (info_element->len == size)) {
+		memcpy(element_info->qui, info_element->data,
+		       info_element->len);
+		element_info->elementID = info_element->id;
+		element_info->length = info_element->len;
+	} else
+		ret = -1;
+
+	if (ret == 0)
+		ret = rtllib_verify_qos_info(element_info,
+						QOS_OUI_INFO_SUB_TYPE);
+	return ret;
 }
 
 
@@ -1588,16 +1579,16 @@ static int rtllib_read_qos_info_element(struct
 static int rtllib_qos_convert_ac_to_parameters(struct rtllib_qos_parameter_info *param_elm,
 		struct rtllib_qos_data *qos_data)
 {
-        struct rtllib_qos_ac_parameter *ac_params;
+	struct rtllib_qos_ac_parameter *ac_params;
 	struct rtllib_qos_parameters *qos_param = &(qos_data->parameters);
-        int rc = 0;
-        int i;
+	int rc = 0;
+	int i;
 	u8 aci;
 	u8 acm;
 
 	qos_data->wmm_acm = 0;
-        for (i = 0; i < QOS_QUEUE_NUM; i++) {
-                ac_params = &(param_elm->ac_params_record[i]);
+	for (i = 0; i < QOS_QUEUE_NUM; i++) {
+		ac_params = &(param_elm->ac_params_record[i]);
 
 		aci = (ac_params->aci_aifsn & 0x60) >> 5;
 		acm = (ac_params->aci_aifsn & 0x10) >> 4;
@@ -1605,43 +1596,43 @@ static int rtllib_qos_convert_ac_to_parameters(struct rtllib_qos_parameter_info
 		if (aci >= QOS_QUEUE_NUM)
 			continue;
 		switch (aci) {
-			case 1:
-				/* BIT(0) | BIT(3) */
-				if (acm)
-					qos_data->wmm_acm |= (0x01<<0)|(0x01<<3);
-				break;
-			case 2:
-				/* BIT(4) | BIT(5) */
-				if (acm)
-					qos_data->wmm_acm |= (0x01<<4)|(0x01<<5);
-				break;
-			case 3:
-				/* BIT(6) | BIT(7) */
-				if (acm)
-					qos_data->wmm_acm |= (0x01<<6)|(0x01<<7);
-				break;
-			case 0:
-			default:
-				/* BIT(1) | BIT(2) */
-				if (acm)
-					qos_data->wmm_acm |= (0x01<<1)|(0x01<<2);
-				break;
+		case 1:
+			/* BIT(0) | BIT(3) */
+			if (acm)
+				qos_data->wmm_acm |= (0x01<<0)|(0x01<<3);
+			break;
+		case 2:
+			/* BIT(4) | BIT(5) */
+			if (acm)
+				qos_data->wmm_acm |= (0x01<<4)|(0x01<<5);
+			break;
+		case 3:
+			/* BIT(6) | BIT(7) */
+			if (acm)
+				qos_data->wmm_acm |= (0x01<<6)|(0x01<<7);
+			break;
+		case 0:
+		default:
+			/* BIT(1) | BIT(2) */
+			if (acm)
+				qos_data->wmm_acm |= (0x01<<1)|(0x01<<2);
+			break;
 		}
 
-                qos_param->aifs[aci] = (ac_params->aci_aifsn) & 0x0f;
+		qos_param->aifs[aci] = (ac_params->aci_aifsn) & 0x0f;
 
 		/* WMM spec P.11: The minimum value for AIFSN shall be 2 */
-                qos_param->aifs[aci] = (qos_param->aifs[aci] < 2) ? 2:qos_param->aifs[aci];
+		qos_param->aifs[aci] = (qos_param->aifs[aci] < 2) ? 2 : qos_param->aifs[aci];
 
-                qos_param->cw_min[aci] = ac_params->ecw_min_max & 0x0F;
+		qos_param->cw_min[aci] = ac_params->ecw_min_max & 0x0F;
 
-                qos_param->cw_max[aci] = (ac_params->ecw_min_max & 0xF0) >> 4;
+		qos_param->cw_max[aci] = (ac_params->ecw_min_max & 0xF0) >> 4;
 
-                qos_param->flag[aci] =
-                    (ac_params->aci_aifsn & 0x10) ? 0x01 : 0x00;
-                qos_param->tx_op_limit[aci] = le16_to_cpu(ac_params->tx_op_limit);
-        }
-        return rc;
+		qos_param->flag[aci] =
+		    (ac_params->aci_aifsn & 0x10) ? 0x01 : 0x00;
+		qos_param->tx_op_limit[aci] = le16_to_cpu(ac_params->tx_op_limit);
+	}
+	return rc;
 }
 
 /*
@@ -1650,96 +1641,94 @@ static int rtllib_qos_convert_ac_to_parameters(struct rtllib_qos_parameter_info
  * which type to read
  */
 static int rtllib_parse_qos_info_param_IE(struct rtllib_info_element
-                                             *info_element,
-                                             struct rtllib_network *network)
+					     *info_element,
+					     struct rtllib_network *network)
 {
-        int rc = 0;
-        struct rtllib_qos_information_element qos_info_element;
-
-        rc = rtllib_read_qos_info_element(&qos_info_element, info_element);
-
-        if (rc == 0) {
-                network->qos_data.param_count = qos_info_element.ac_info & 0x0F;
-                network->flags |= NETWORK_HAS_QOS_INFORMATION;
-        } else {
-                struct rtllib_qos_parameter_info param_element;
-
-                rc = rtllib_read_qos_param_element(&param_element,
-                                                      info_element);
-                if (rc == 0) {
-                        rtllib_qos_convert_ac_to_parameters(&param_element,
-                                                               &(network->qos_data));
-                        network->flags |= NETWORK_HAS_QOS_PARAMETERS;
-                        network->qos_data.param_count =
-                            param_element.info_element.ac_info & 0x0F;
-                }
-        }
-
-        if (rc == 0) {
-                RTLLIB_DEBUG_QOS("QoS is supported\n");
-                network->qos_data.supported = 1;
-        }
-        return rc;
+	int rc = 0;
+	struct rtllib_qos_information_element qos_info_element;
+
+	rc = rtllib_read_qos_info_element(&qos_info_element, info_element);
+
+	if (rc == 0) {
+		network->qos_data.param_count = qos_info_element.ac_info & 0x0F;
+		network->flags |= NETWORK_HAS_QOS_INFORMATION;
+	} else {
+		struct rtllib_qos_parameter_info param_element;
+
+		rc = rtllib_read_qos_param_element(&param_element,
+						      info_element);
+		if (rc == 0) {
+			rtllib_qos_convert_ac_to_parameters(&param_element,
+							       &(network->qos_data));
+			network->flags |= NETWORK_HAS_QOS_PARAMETERS;
+			network->qos_data.param_count =
+			    param_element.info_element.ac_info & 0x0F;
+		}
+	}
+
+	if (rc == 0) {
+		RTLLIB_DEBUG_QOS("QoS is supported\n");
+		network->qos_data.supported = 1;
+	}
+	return rc;
 }
 
 #define MFIE_STRING(x) case MFIE_TYPE_ ##x: return #x
 
 static const char *get_info_element_string(u16 id)
 {
-        switch (id) {
-                MFIE_STRING(SSID);
-                MFIE_STRING(RATES);
-                MFIE_STRING(FH_SET);
-                MFIE_STRING(DS_SET);
-                MFIE_STRING(CF_SET);
-                MFIE_STRING(TIM);
-                MFIE_STRING(IBSS_SET);
-                MFIE_STRING(COUNTRY);
-                MFIE_STRING(HOP_PARAMS);
-                MFIE_STRING(HOP_TABLE);
-                MFIE_STRING(REQUEST);
-                MFIE_STRING(CHALLENGE);
-                MFIE_STRING(POWER_CONSTRAINT);
-                MFIE_STRING(POWER_CAPABILITY);
-                MFIE_STRING(TPC_REQUEST);
-                MFIE_STRING(TPC_REPORT);
-                MFIE_STRING(SUPP_CHANNELS);
-                MFIE_STRING(CSA);
-                MFIE_STRING(MEASURE_REQUEST);
-                MFIE_STRING(MEASURE_REPORT);
-                MFIE_STRING(QUIET);
-                MFIE_STRING(IBSS_DFS);
-                MFIE_STRING(RSN);
-                MFIE_STRING(RATES_EX);
-                MFIE_STRING(GENERIC);
-                MFIE_STRING(QOS_PARAMETER);
-        default:
-                return "UNKNOWN";
-        }
+	switch (id) {
+	MFIE_STRING(SSID);
+	MFIE_STRING(RATES);
+	MFIE_STRING(FH_SET);
+	MFIE_STRING(DS_SET);
+	MFIE_STRING(CF_SET);
+	MFIE_STRING(TIM);
+	MFIE_STRING(IBSS_SET);
+	MFIE_STRING(COUNTRY);
+	MFIE_STRING(HOP_PARAMS);
+	MFIE_STRING(HOP_TABLE);
+	MFIE_STRING(REQUEST);
+	MFIE_STRING(CHALLENGE);
+	MFIE_STRING(POWER_CONSTRAINT);
+	MFIE_STRING(POWER_CAPABILITY);
+	MFIE_STRING(TPC_REQUEST);
+	MFIE_STRING(TPC_REPORT);
+	MFIE_STRING(SUPP_CHANNELS);
+	MFIE_STRING(CSA);
+	MFIE_STRING(MEASURE_REQUEST);
+	MFIE_STRING(MEASURE_REPORT);
+	MFIE_STRING(QUIET);
+	MFIE_STRING(IBSS_DFS);
+	MFIE_STRING(RSN);
+	MFIE_STRING(RATES_EX);
+	MFIE_STRING(GENERIC);
+	MFIE_STRING(QOS_PARAMETER);
+	default:
+		return "UNKNOWN";
+	}
 }
 
 static inline void rtllib_extract_country_ie(
 	struct rtllib_device *ieee,
 	struct rtllib_info_element *info_element,
 	struct rtllib_network *network,
-	u8 * addr2)
+	u8 *addr2)
 {
 	if (IS_DOT11D_ENABLE(ieee)) {
-		if (info_element->len!= 0) {
+		if (info_element->len != 0) {
 			memcpy(network->CountryIeBuf, info_element->data, info_element->len);
 			network->CountryIeLen = info_element->len;
 
-			if (!IS_COUNTRY_IE_VALID(ieee))
-			{
-				if ((rtllib_act_scanning(ieee,false) == true) && (ieee->FirstIe_InScan == 1))
-					printk("Received beacon ContryIE, SSID: <%s>\n",network->ssid);
+			if (!IS_COUNTRY_IE_VALID(ieee)) {
+				if ((rtllib_act_scanning(ieee, false) == true) && (ieee->FirstIe_InScan == 1))
+					printk(KERN_INFO "Received beacon ContryIE, SSID: <%s>\n", network->ssid);
 				Dot11d_UpdateCountryIe(ieee, addr2, info_element->len, info_element->data);
 			}
 		}
 
-		if (IS_EQUAL_CIE_SRC(ieee, addr2)) {
+		if (IS_EQUAL_CIE_SRC(ieee, addr2))
 			UPDATE_CIE_WATCHDOG(ieee);
-		}
 	}
 
 }
@@ -1752,9 +1741,9 @@ int rtllib_parse_info_param(struct rtllib_device *ieee,
 {
 	u8 i;
 	short offset;
-        u16	tmp_htcap_len=0;
-	u16	tmp_htinfo_len=0;
-	u16 ht_realtek_agg_len=0;
+	u16	tmp_htcap_len = 0;
+	u16	tmp_htinfo_len = 0;
+	u16 ht_realtek_agg_len = 0;
 	u8  ht_realtek_agg_buf[MAX_IE_LEN];
 	char rates_str[64];
 	char *p;
@@ -1864,28 +1853,28 @@ int rtllib_parse_info_param(struct rtllib_device *ieee,
 			network->tim.tim_count = info_element->data[0];
 			network->tim.tim_period = info_element->data[1];
 
-                        network->dtim_period = info_element->data[1];
-                        if (ieee->state != RTLLIB_LINKED)
-                                break;
+			network->dtim_period = info_element->data[1];
+			if (ieee->state != RTLLIB_LINKED)
+				break;
 			network->last_dtim_sta_time = jiffies;
 
-                        network->dtim_data = RTLLIB_DTIM_VALID;
-
+			network->dtim_data = RTLLIB_DTIM_VALID;
 
-                        if (info_element->data[2] & 1)
-                                network->dtim_data |= RTLLIB_DTIM_MBCAST;
 
-                        offset = (info_element->data[2] >> 1)*2;
+			if (info_element->data[2] & 1)
+				network->dtim_data |= RTLLIB_DTIM_MBCAST;
 
+			offset = (info_element->data[2] >> 1)*2;
 
-                        if (ieee->assoc_id < 8*offset ||
-                                ieee->assoc_id > 8*(offset + info_element->len -3))
 
-                                break;
+			if (ieee->assoc_id < 8*offset ||
+			    ieee->assoc_id > 8*(offset + info_element->len - 3))
+				break;
 
-                        offset = (ieee->assoc_id / 8) - offset;
-                        if (info_element->data[3+offset] & (1<<(ieee->assoc_id%8)))
-                                network->dtim_data |= RTLLIB_DTIM_UCAST;
+			offset = (ieee->assoc_id / 8) - offset;
+			if (info_element->data[3 + offset] &
+			   (1 << (ieee->assoc_id % 8)))
+				network->dtim_data |= RTLLIB_DTIM_UCAST;
 
 			network->listen_interval = network->dtim_period;
 			break;
@@ -1923,13 +1912,13 @@ int rtllib_parse_info_param(struct rtllib_device *ieee,
 				       network->wpa_ie_len);
 				break;
 			}
-                        if (info_element->len == 7 &&
-                            info_element->data[0] == 0x00 &&
-                            info_element->data[1] == 0xe0 &&
-                            info_element->data[2] == 0x4c &&
-                            info_element->data[3] == 0x01 &&
-                            info_element->data[4] == 0x02)
-                                network->Turbo_Enable = 1;
+			if (info_element->len == 7 &&
+			    info_element->data[0] == 0x00 &&
+			    info_element->data[1] == 0xe0 &&
+			    info_element->data[2] == 0x4c &&
+			    info_element->data[3] == 0x01 &&
+			    info_element->data[4] == 0x02)
+				network->Turbo_Enable = 1;
 
 			if (tmp_htcap_len == 0) {
 				if (info_element->len >= 4 &&
@@ -1938,193 +1927,160 @@ int rtllib_parse_info_param(struct rtllib_device *ieee,
 				   info_element->data[2] == 0x4c &&
 				   info_element->data[3] == 0x033) {
 
-						tmp_htcap_len = min(info_element->len,(u8)MAX_IE_LEN);
-						if (tmp_htcap_len != 0){
+						tmp_htcap_len = min(info_element->len, (u8)MAX_IE_LEN);
+						if (tmp_htcap_len != 0) {
 							network->bssht.bdHTSpecVer = HT_SPEC_VER_EWC;
-							network->bssht.bdHTCapLen = tmp_htcap_len > sizeof(network->bssht.bdHTCapBuf)?\
-								sizeof(network->bssht.bdHTCapBuf):tmp_htcap_len;
-							memcpy(network->bssht.bdHTCapBuf,info_element->data,network->bssht.bdHTCapLen);
+							network->bssht.bdHTCapLen = tmp_htcap_len > sizeof(network->bssht.bdHTCapBuf) ?
+								sizeof(network->bssht.bdHTCapBuf) : tmp_htcap_len;
+							memcpy(network->bssht.bdHTCapBuf, info_element->data, network->bssht.bdHTCapLen);
 						}
 				}
-				if (tmp_htcap_len != 0){
+				if (tmp_htcap_len != 0) {
 					network->bssht.bdSupportHT = true;
 					network->bssht.bdHT1R = ((((struct ht_capab_ele *)(network->bssht.bdHTCapBuf))->MCS[1]) == 0);
-				}else{
+				} else {
 					network->bssht.bdSupportHT = false;
 					network->bssht.bdHT1R = false;
 				}
 			}
 
 
-			if (tmp_htinfo_len == 0){
+			if (tmp_htinfo_len == 0) {
 				if (info_element->len >= 4 &&
-					info_element->data[0] == 0x00 &&
-					info_element->data[1] == 0x90 &&
-					info_element->data[2] == 0x4c &&
-					info_element->data[3] == 0x034){
-
-						tmp_htinfo_len = min(info_element->len,(u8)MAX_IE_LEN);
-						if (tmp_htinfo_len != 0){
-							network->bssht.bdHTSpecVer = HT_SPEC_VER_EWC;
-							if (tmp_htinfo_len){
-								network->bssht.bdHTInfoLen = tmp_htinfo_len > sizeof(network->bssht.bdHTInfoBuf)?\
-									sizeof(network->bssht.bdHTInfoBuf):tmp_htinfo_len;
-								memcpy(network->bssht.bdHTInfoBuf,info_element->data,network->bssht.bdHTInfoLen);
-							}
-
+				    info_element->data[0] == 0x00 &&
+				    info_element->data[1] == 0x90 &&
+				    info_element->data[2] == 0x4c &&
+				    info_element->data[3] == 0x034) {
+					tmp_htinfo_len = min(info_element->len, (u8)MAX_IE_LEN);
+					if (tmp_htinfo_len != 0) {
+						network->bssht.bdHTSpecVer = HT_SPEC_VER_EWC;
+						if (tmp_htinfo_len) {
+							network->bssht.bdHTInfoLen = tmp_htinfo_len > sizeof(network->bssht.bdHTInfoBuf) ?
+								sizeof(network->bssht.bdHTInfoBuf) : tmp_htinfo_len;
+							memcpy(network->bssht.bdHTInfoBuf, info_element->data, network->bssht.bdHTInfoLen);
 						}
 
+					}
+
 				}
 			}
 
-			if (ieee->aggregation){
-				if (network->bssht.bdSupportHT){
+			if (ieee->aggregation) {
+				if (network->bssht.bdSupportHT) {
 					if (info_element->len >= 4 &&
-						info_element->data[0] == 0x00 &&
-						info_element->data[1] == 0xe0 &&
-						info_element->data[2] == 0x4c &&
-						info_element->data[3] == 0x02){
-
-						ht_realtek_agg_len = min(info_element->len,(u8)MAX_IE_LEN);
-						memcpy(ht_realtek_agg_buf,info_element->data,info_element->len);
-
+					    info_element->data[0] == 0x00 &&
+					    info_element->data[1] == 0xe0 &&
+					    info_element->data[2] == 0x4c &&
+					    info_element->data[3] == 0x02) {
+						ht_realtek_agg_len = min(info_element->len, (u8)MAX_IE_LEN);
+						memcpy(ht_realtek_agg_buf, info_element->data, info_element->len);
 					}
-					if (ht_realtek_agg_len >= 5){
+					if (ht_realtek_agg_len >= 5) {
 						network->realtek_cap_exit = true;
 						network->bssht.bdRT2RTAggregation = true;
 
 						if ((ht_realtek_agg_buf[4] == 1) && (ht_realtek_agg_buf[5] & 0x02))
-						network->bssht.bdRT2RTLongSlotTime = true;
+							network->bssht.bdRT2RTLongSlotTime = true;
 
-						if ((ht_realtek_agg_buf[4]==1) && (ht_realtek_agg_buf[5] & RT_HT_CAP_USE_92SE))
-						{
+						if ((ht_realtek_agg_buf[4] == 1) && (ht_realtek_agg_buf[5] & RT_HT_CAP_USE_92SE))
 							network->bssht.RT2RT_HT_Mode |= RT_HT_CAP_USE_92SE;
-						}
 					}
 				}
-				if (ht_realtek_agg_len >= 5){
+				if (ht_realtek_agg_len >= 5) {
 					if ((ht_realtek_agg_buf[5] & RT_HT_CAP_USE_SOFTAP))
 						network->bssht.RT2RT_HT_Mode |= RT_HT_CAP_USE_SOFTAP;
 				}
 			}
 
-			{
-				if ((info_element->len >= 3 &&
-					 info_element->data[0] == 0x00 &&
-					 info_element->data[1] == 0x05 &&
-					 info_element->data[2] == 0xb5) ||
-					 (info_element->len >= 3 &&
-					 info_element->data[0] == 0x00 &&
-					 info_element->data[1] == 0x0a &&
-					 info_element->data[2] == 0xf7) ||
-					 (info_element->len >= 3 &&
-					 info_element->data[0] == 0x00 &&
-					 info_element->data[1] == 0x10 &&
-					 info_element->data[2] == 0x18)){
-
-						network->broadcom_cap_exist = true;
-
-				}
+			if ((info_element->len >= 3 &&
+			     info_element->data[0] == 0x00 &&
+			     info_element->data[1] == 0x05 &&
+			     info_element->data[2] == 0xb5) ||
+			     (info_element->len >= 3 &&
+			     info_element->data[0] == 0x00 &&
+			     info_element->data[1] == 0x0a &&
+			     info_element->data[2] == 0xf7) ||
+			     (info_element->len >= 3 &&
+			     info_element->data[0] == 0x00 &&
+			     info_element->data[1] == 0x10 &&
+			     info_element->data[2] == 0x18)) {
+				network->broadcom_cap_exist = true;
 			}
 			if (info_element->len >= 3 &&
-				info_element->data[0] == 0x00 &&
-				info_element->data[1] == 0x0c &&
-				info_element->data[2] == 0x43)
-			{
+			    info_element->data[0] == 0x00 &&
+			    info_element->data[1] == 0x0c &&
+			    info_element->data[2] == 0x43)
 				network->ralink_cap_exist = true;
-			}
 			if ((info_element->len >= 3 &&
-				info_element->data[0] == 0x00 &&
-				info_element->data[1] == 0x03 &&
-				info_element->data[2] == 0x7f) ||
-				(info_element->len >= 3 &&
-				info_element->data[0] == 0x00 &&
-				info_element->data[1] == 0x13 &&
-				info_element->data[2] == 0x74))
-			{
+			     info_element->data[0] == 0x00 &&
+			     info_element->data[1] == 0x03 &&
+			     info_element->data[2] == 0x7f) ||
+			     (info_element->len >= 3 &&
+			     info_element->data[0] == 0x00 &&
+			     info_element->data[1] == 0x13 &&
+			     info_element->data[2] == 0x74))
 				network->atheros_cap_exist = true;
-			}
 
 			if ((info_element->len >= 3 &&
-				info_element->data[0] == 0x00 &&
-				info_element->data[1] == 0x50 &&
-				info_element->data[2] == 0x43) )
-				{
-					network->marvell_cap_exist = true;
-				}
+			     info_element->data[0] == 0x00 &&
+			     info_element->data[1] == 0x50 &&
+			     info_element->data[2] == 0x43))
+				network->marvell_cap_exist = true;
 			if (info_element->len >= 3 &&
-				info_element->data[0] == 0x00 &&
-				info_element->data[1] == 0x40 &&
-				info_element->data[2] == 0x96)
-			{
+			    info_element->data[0] == 0x00 &&
+			    info_element->data[1] == 0x40 &&
+			    info_element->data[2] == 0x96)
 				network->cisco_cap_exist = true;
-			}
 
 
 			if (info_element->len >= 3 &&
-				info_element->data[0] == 0x00 &&
-				info_element->data[1] == 0x0a &&
-				info_element->data[2] == 0xf5)
-			{
+			    info_element->data[0] == 0x00 &&
+			    info_element->data[1] == 0x0a &&
+			    info_element->data[2] == 0xf5)
 				network->airgo_cap_exist = true;
-			}
 
 			if (info_element->len > 4 &&
-				info_element->data[0] == 0x00 &&
-				info_element->data[1] == 0x40 &&
-				info_element->data[2] == 0x96 &&
-				info_element->data[3] == 0x01)
-			{
-				if (info_element->len == 6)
-				{
+			    info_element->data[0] == 0x00 &&
+			    info_element->data[1] == 0x40 &&
+			    info_element->data[2] == 0x96 &&
+			    info_element->data[3] == 0x01) {
+				if (info_element->len == 6) {
 					memcpy(network->CcxRmState, &info_element[4], 2);
 					if (network->CcxRmState[0] != 0)
-					{
 						network->bCcxRmEnable = true;
-					}
 					else
 						network->bCcxRmEnable = false;
 					network->MBssidMask = network->CcxRmState[1] & 0x07;
-					if (network->MBssidMask != 0)
-					{
+					if (network->MBssidMask != 0) {
 						network->bMBssidValid = true;
 						network->MBssidMask = 0xff << (network->MBssidMask);
 						memcpy(network->MBssid, network->bssid, ETH_ALEN);
 						network->MBssid[5] &= network->MBssidMask;
-					}
-					else
-					{
+					} else {
 						network->bMBssidValid = false;
 					}
-				}
-				else
-				{
+				} else {
 					network->bCcxRmEnable = false;
 				}
 			}
 			if (info_element->len > 4  &&
-				info_element->data[0] == 0x00 &&
-				info_element->data[1] == 0x40 &&
-				info_element->data[2] == 0x96 &&
-				info_element->data[3] == 0x03)
-			{
-				if (info_element->len == 5)
-				{
+			    info_element->data[0] == 0x00 &&
+			    info_element->data[1] == 0x40 &&
+			    info_element->data[2] == 0x96 &&
+			    info_element->data[3] == 0x03) {
+				if (info_element->len == 5) {
 					network->bWithCcxVerNum = true;
 					network->BssCcxVerNumber = info_element->data[4];
-				}
-				else
-				{
+				} else {
 					network->bWithCcxVerNum = false;
 					network->BssCcxVerNumber = 0;
 				}
 			}
 			if (info_element->len > 4  &&
-				info_element->data[0] == 0x00 &&
-				info_element->data[1] == 0x50 &&
-				info_element->data[2] == 0xf2 &&
-				info_element->data[3] == 0x04)
-			{
+			    info_element->data[0] == 0x00 &&
+			    info_element->data[1] == 0x50 &&
+			    info_element->data[2] == 0xf2 &&
+			    info_element->data[3] == 0x04) {
 				RTLLIB_DEBUG_MGMT("MFIE_TYPE_WZC: %d bytes\n",
 						     info_element->len);
 				network->wzc_ie_len = min(info_element->len+2,
@@ -2146,22 +2102,26 @@ int rtllib_parse_info_param(struct rtllib_device *ieee,
 		case MFIE_TYPE_HT_CAP:
 			RTLLIB_DEBUG_SCAN("MFIE_TYPE_HT_CAP: %d bytes\n",
 					     info_element->len);
-			tmp_htcap_len = min(info_element->len,(u8)MAX_IE_LEN);
-			if (tmp_htcap_len != 0){
+			tmp_htcap_len = min(info_element->len, (u8)MAX_IE_LEN);
+			if (tmp_htcap_len != 0) {
 				network->bssht.bdHTSpecVer = HT_SPEC_VER_EWC;
-				network->bssht.bdHTCapLen = tmp_htcap_len > sizeof(network->bssht.bdHTCapBuf)?\
-					sizeof(network->bssht.bdHTCapBuf):tmp_htcap_len;
-				memcpy(network->bssht.bdHTCapBuf,info_element->data,network->bssht.bdHTCapLen);
+				network->bssht.bdHTCapLen = tmp_htcap_len > sizeof(network->bssht.bdHTCapBuf) ?
+					sizeof(network->bssht.bdHTCapBuf) : tmp_htcap_len;
+				memcpy(network->bssht.bdHTCapBuf,
+				       info_element->data,
+				       network->bssht.bdHTCapLen);
 
 				network->bssht.bdSupportHT = true;
-				network->bssht.bdHT1R = ((((struct ht_capab_ele *)(network->bssht.bdHTCapBuf))->MCS[1]) == 0);
+				network->bssht.bdHT1R = ((((struct ht_capab_ele *)
+							network->bssht.bdHTCapBuf))->MCS[1]) == 0;
 
-				network->bssht.bdBandWidth = (enum ht_channel_width)(((struct ht_capab_ele *)(network->bssht.bdHTCapBuf))->ChlWidth);
-			}
-			else{
+				network->bssht.bdBandWidth = (enum ht_channel_width)
+							     (((struct ht_capab_ele *)
+							     (network->bssht.bdHTCapBuf))->ChlWidth);
+			} else {
 				network->bssht.bdSupportHT = false;
 				network->bssht.bdHT1R = false;
-				network->bssht.bdBandWidth = HT_CHANNEL_WIDTH_20 ;
+				network->bssht.bdBandWidth = HT_CHANNEL_WIDTH_20;
 			}
 			break;
 
@@ -2169,34 +2129,33 @@ int rtllib_parse_info_param(struct rtllib_device *ieee,
 		case MFIE_TYPE_HT_INFO:
 			RTLLIB_DEBUG_SCAN("MFIE_TYPE_HT_INFO: %d bytes\n",
 					     info_element->len);
-			tmp_htinfo_len = min(info_element->len,(u8)MAX_IE_LEN);
-			if (tmp_htinfo_len){
+			tmp_htinfo_len = min(info_element->len, (u8)MAX_IE_LEN);
+			if (tmp_htinfo_len) {
 				network->bssht.bdHTSpecVer = HT_SPEC_VER_IEEE;
-				network->bssht.bdHTInfoLen = tmp_htinfo_len > sizeof(network->bssht.bdHTInfoBuf)?\
-					sizeof(network->bssht.bdHTInfoBuf):tmp_htinfo_len;
-				memcpy(network->bssht.bdHTInfoBuf,info_element->data,network->bssht.bdHTInfoLen);
+				network->bssht.bdHTInfoLen = tmp_htinfo_len >
+					sizeof(network->bssht.bdHTInfoBuf) ?
+					sizeof(network->bssht.bdHTInfoBuf) :
+					tmp_htinfo_len;
+				memcpy(network->bssht.bdHTInfoBuf,
+				       info_element->data,
+				       network->bssht.bdHTInfoLen);
 			}
 			break;
 
 		case MFIE_TYPE_AIRONET:
 			RTLLIB_DEBUG_SCAN("MFIE_TYPE_AIRONET: %d bytes\n",
 					     info_element->len);
-			if (info_element->len >IE_CISCO_FLAG_POSITION)
-			{
+			if (info_element->len > IE_CISCO_FLAG_POSITION) {
 				network->bWithAironetIE = true;
 
-				if (	(info_element->data[IE_CISCO_FLAG_POSITION]&SUPPORT_CKIP_MIC)	||
-					(info_element->data[IE_CISCO_FLAG_POSITION]&SUPPORT_CKIP_PK)	)
-				{
+				if ((info_element->data[IE_CISCO_FLAG_POSITION]
+				     & SUPPORT_CKIP_MIC) ||
+				     (info_element->data[IE_CISCO_FLAG_POSITION]
+				     & SUPPORT_CKIP_PK))
 					network->bCkipSupported = true;
-				}
 				else
-				{
 					network->bCkipSupported = false;
-				}
-			}
-			else
-			{
+			} else {
 				network->bWithAironetIE = false;
 				network->bCkipSupported = false;
 			}
@@ -2209,7 +2168,8 @@ int rtllib_parse_info_param(struct rtllib_device *ieee,
 		case MFIE_TYPE_COUNTRY:
 			RTLLIB_DEBUG_SCAN("MFIE_TYPE_COUNTRY: %d bytes\n",
 					     info_element->len);
-			rtllib_extract_country_ie(ieee, info_element, network, network->bssid);
+			rtllib_extract_country_ie(ieee, info_element, network,
+						  network->bssid);
 			break;
 /* TODO */
 		default:
@@ -2227,70 +2187,43 @@ int rtllib_parse_info_param(struct rtllib_device *ieee,
 	}
 
 	if (!network->atheros_cap_exist && !network->broadcom_cap_exist &&
-		!network->cisco_cap_exist && !network->ralink_cap_exist && !network->bssht.bdRT2RTAggregation)
-	{
+	    !network->cisco_cap_exist && !network->ralink_cap_exist &&
+	    !network->bssht.bdRT2RTAggregation)
 		network->unknown_cap_exist = true;
-	}
 	else
-	{
 		network->unknown_cap_exist = false;
-	}
 	return 0;
 }
 
-static inline u8 rtllib_SignalStrengthTranslate(
-	u8  CurrSS
-	)
+static inline u8 rtllib_SignalStrengthTranslate(u8  CurrSS)
 {
 	u8 RetSS;
 
 	if (CurrSS >= 71 && CurrSS <= 100)
-	{
 		RetSS = 90 + ((CurrSS - 70) / 3);
-	}
 	else if (CurrSS >= 41 && CurrSS <= 70)
-	{
 		RetSS = 78 + ((CurrSS - 40) / 3);
-	}
 	else if (CurrSS >= 31 && CurrSS <= 40)
-	{
 		RetSS = 66 + (CurrSS - 30);
-	}
 	else if (CurrSS >= 21 && CurrSS <= 30)
-	{
 		RetSS = 54 + (CurrSS - 20);
-	}
 	else if (CurrSS >= 5 && CurrSS <= 20)
-	{
 		RetSS = 42 + (((CurrSS - 5) * 2) / 3);
-	}
 	else if (CurrSS == 4)
-	{
 		RetSS = 36;
-	}
 	else if (CurrSS == 3)
-	{
 		RetSS = 27;
-	}
 	else if (CurrSS == 2)
-	{
 		RetSS = 18;
-	}
 	else if (CurrSS == 1)
-	{
 		RetSS = 9;
-	}
 	else
-	{
 		RetSS = CurrSS;
-	}
-
-
 
 	return RetSS;
 }
 
-long rtllib_translate_todbm(u8 signal_strength_index	)
+long rtllib_translate_todbm(u8 signal_strength_index)
 {
 	long	signal_power;
 
@@ -2308,10 +2241,10 @@ static inline int rtllib_network_init(
 {
 
 	/*
-        network->qos_data.active = 0;
-        network->qos_data.supported = 0;
-        network->qos_data.param_count = 0;
-        network->qos_data.old_param_count = 0;
+	network->qos_data.active = 0;
+	network->qos_data.supported = 0;
+	network->qos_data.param_count = 0;
+	network->qos_data.old_param_count = 0;
 	*/
 	memset(&network->qos_data, 0, sizeof(struct rtllib_qos_data));
 
@@ -2332,9 +2265,9 @@ static inline int rtllib_network_init(
 	network->flags = 0;
 	network->atim_window = 0;
 	network->erp_value = (network->capability & WLAN_CAPABILITY_IBSS) ?
-            0x3 : 0x0;
+	    0x3 : 0x0;
 	network->berp_info_valid = false;
-        network->broadcom_cap_exist = false;
+	network->broadcom_cap_exist = false;
 	network->ralink_cap_exist = false;
 	network->atheros_cap_exist = false;
 	network->cisco_cap_exist = false;
@@ -2358,12 +2291,12 @@ static inline int rtllib_network_init(
 	network->rsn_ie_len = 0;
 	network->wzc_ie_len = 0;
 
-        if (rtllib_parse_info_param(ieee,
+	if (rtllib_parse_info_param(ieee,
 			beacon->info_element,
 			(stats->len - sizeof(*beacon)),
 			network,
 			stats))
-                return 1;
+		return 1;
 
 	network->mode = 0;
 	if (stats->freq == RTLLIB_52GHZ_BAND)
@@ -2384,7 +2317,7 @@ static inline int rtllib_network_init(
 		return 1;
 	}
 
-	if (network->bssht.bdSupportHT){
+	if (network->bssht.bdSupportHT) {
 		if (network->mode == IEEE_A)
 			network->mode = IEEE_N_5G;
 		else if (network->mode & (IEEE_G | IEEE_B))
@@ -2393,7 +2326,7 @@ static inline int rtllib_network_init(
 	if (rtllib_is_empty_essid(network->ssid, network->ssid_len))
 		network->flags |= NETWORK_EMPTY_ESSID;
 	stats->signal = 30 + (stats->SignalStrength * 70) / 100;
-	stats->noise = rtllib_translate_todbm((u8)(100-stats->signal)) -25;
+	stats->noise = rtllib_translate_todbm((u8)(100-stats->signal)) - 25;
 
 	memcpy(&network->stats, stats, sizeof(network->stats));
 
@@ -2407,11 +2340,11 @@ static inline int is_same_network(struct rtllib_network *src,
 	 * and the capability field (in particular IBSS and BSS) all match.
 	 * We treat all <hidden> with the same BSSID and channel
 	 * as one network */
-	return
-		(((src->ssid_len == dst->ssid_len) || (!ssidbroad)) &&
+	return (((src->ssid_len == dst->ssid_len) || (!ssidbroad)) &&
 		(src->channel == dst->channel) &&
 		!memcmp(src->bssid, dst->bssid, ETH_ALEN) &&
-		(!memcmp(src->ssid, dst->ssid, src->ssid_len) || (!ssidbroad)) &&
+		(!memcmp(src->ssid, dst->ssid, src->ssid_len) ||
+		(!ssidbroad)) &&
 		((src->capability & WLAN_CAPABILITY_IBSS) ==
 		(dst->capability & WLAN_CAPABILITY_IBSS)) &&
 		((src->capability & WLAN_CAPABILITY_ESS) ==
@@ -2438,14 +2371,12 @@ static inline void update_network(struct rtllib_network *dst,
 	dst->rates_len = src->rates_len;
 	memcpy(dst->rates_ex, src->rates_ex, src->rates_ex_len);
 	dst->rates_ex_len = src->rates_ex_len;
-	if (src->ssid_len > 0)
-	{
-		if (dst->ssid_len == 0)
-		{
+	if (src->ssid_len > 0) {
+		if (dst->ssid_len == 0) {
 			memset(dst->hidden_ssid, 0, sizeof(dst->hidden_ssid));
 			dst->hidden_ssid_len = src->ssid_len;
 			memcpy(dst->hidden_ssid, src->ssid, src->ssid_len);
-		}else{
+		} else {
 			memset(dst->ssid, 0, dst->ssid_len);
 			dst->ssid_len = src->ssid_len;
 			memcpy(dst->ssid, src->ssid, src->ssid_len);
@@ -2455,8 +2386,7 @@ static inline void update_network(struct rtllib_network *dst,
 	dst->flags = src->flags;
 	dst->time_stamp[0] = src->time_stamp[0];
 	dst->time_stamp[1] = src->time_stamp[1];
-	if (src->flags & NETWORK_HAS_ERP_VALUE)
-	{
+	if (src->flags & NETWORK_HAS_ERP_VALUE) {
 		dst->erp_value = src->erp_value;
 		dst->berp_info_valid = src->berp_info_valid = true;
 	}
@@ -2468,12 +2398,14 @@ static inline void update_network(struct rtllib_network *dst,
 	dst->last_dtim_sta_time = src->last_dtim_sta_time;
 	memcpy(&dst->tim, &src->tim, sizeof(struct rtllib_tim_parameters));
 
-        dst->bssht.bdSupportHT = src->bssht.bdSupportHT;
+	dst->bssht.bdSupportHT = src->bssht.bdSupportHT;
 	dst->bssht.bdRT2RTAggregation = src->bssht.bdRT2RTAggregation;
-	dst->bssht.bdHTCapLen= src->bssht.bdHTCapLen;
-	memcpy(dst->bssht.bdHTCapBuf,src->bssht.bdHTCapBuf,src->bssht.bdHTCapLen);
-	dst->bssht.bdHTInfoLen= src->bssht.bdHTInfoLen;
-	memcpy(dst->bssht.bdHTInfoBuf,src->bssht.bdHTInfoBuf,src->bssht.bdHTInfoLen);
+	dst->bssht.bdHTCapLen = src->bssht.bdHTCapLen;
+	memcpy(dst->bssht.bdHTCapBuf, src->bssht.bdHTCapBuf,
+	       src->bssht.bdHTCapLen);
+	dst->bssht.bdHTInfoLen = src->bssht.bdHTInfoLen;
+	memcpy(dst->bssht.bdHTInfoBuf, src->bssht.bdHTInfoBuf,
+	       src->bssht.bdHTInfoLen);
 	dst->bssht.bdHTSpecVer = src->bssht.bdHTSpecVer;
 	dst->bssht.bdRT2RTLongSlotTime = src->bssht.bdRT2RTLongSlotTime;
 	dst->broadcom_cap_exist = src->broadcom_cap_exist;
@@ -2497,7 +2429,8 @@ static inline void update_network(struct rtllib_network *dst,
 	old_param = dst->qos_data.param_count;
 	dst->qos_data.supported = src->qos_data.supported;
 	if (dst->flags & NETWORK_HAS_QOS_PARAMETERS)
-		memcpy(&dst->qos_data, &src->qos_data, sizeof(struct rtllib_qos_data));
+		memcpy(&dst->qos_data, &src->qos_data,
+		       sizeof(struct rtllib_qos_data));
 	if (dst->qos_data.supported == 1) {
 		if (dst->ssid_len)
 			RTLLIB_DEBUG_QOS
@@ -2512,12 +2445,11 @@ static inline void update_network(struct rtllib_network *dst,
 
 	/* dst->last_associate is not overwritten */
 	dst->wmm_info = src->wmm_info;
-	if (src->wmm_param[0].ac_aci_acm_aifsn|| \
-	   src->wmm_param[1].ac_aci_acm_aifsn|| \
-	   src->wmm_param[2].ac_aci_acm_aifsn|| \
-	   src->wmm_param[1].ac_aci_acm_aifsn) {
-	  memcpy(dst->wmm_param, src->wmm_param, WME_AC_PRAM_LEN);
-	}
+	if (src->wmm_param[0].ac_aci_acm_aifsn ||
+	   src->wmm_param[1].ac_aci_acm_aifsn ||
+	   src->wmm_param[2].ac_aci_acm_aifsn ||
+	   src->wmm_param[1].ac_aci_acm_aifsn)
+		memcpy(dst->wmm_param, src->wmm_param, WME_AC_PRAM_LEN);
 
 	dst->SignalStrength = src->SignalStrength;
 	dst->RSSI = src->RSSI;
@@ -2528,24 +2460,24 @@ static inline void update_network(struct rtllib_network *dst,
 
 	dst->bWithAironetIE = src->bWithAironetIE;
 	dst->bCkipSupported = src->bCkipSupported;
-	memcpy(dst->CcxRmState,src->CcxRmState,2);
+	memcpy(dst->CcxRmState, src->CcxRmState, 2);
 	dst->bCcxRmEnable = src->bCcxRmEnable;
 	dst->MBssidMask = src->MBssidMask;
 	dst->bMBssidValid = src->bMBssidValid;
-	memcpy(dst->MBssid,src->MBssid,6);
+	memcpy(dst->MBssid, src->MBssid, 6);
 	dst->bWithCcxVerNum = src->bWithCcxVerNum;
 	dst->BssCcxVerNumber = src->BssCcxVerNumber;
-
 }
+
 static inline int is_beacon(__le16 fc)
 {
 	return (WLAN_FC_GET_STYPE(le16_to_cpu(fc)) == RTLLIB_STYPE_BEACON);
 }
 
-static int IsPassiveChannel( struct rtllib_device *rtllib, u8 channel)
+static int IsPassiveChannel(struct rtllib_device *rtllib, u8 channel)
 {
 	if (MAX_CHANNEL_NUMBER < channel) {
-		printk("%s(): Invalid Channel\n", __func__);
+		printk(KERN_INFO "%s(): Invalid Channel\n", __func__);
 		return 0;
 	}
 
@@ -2555,10 +2487,10 @@ static int IsPassiveChannel( struct rtllib_device *rtllib, u8 channel)
 	return 0;
 }
 
-int IsLegalChannel( struct rtllib_device *rtllib, u8 channel)
+int IsLegalChannel(struct rtllib_device *rtllib, u8 channel)
 {
 	if (MAX_CHANNEL_NUMBER < channel) {
-		printk("%s(): Invalid Channel\n", __func__);
+		printk(KERN_INFO "%s(): Invalid Channel\n", __func__);
 		return 0;
 	}
 	if (rtllib->active_channel_map[channel] > 0)
@@ -2567,7 +2499,6 @@ int IsLegalChannel( struct rtllib_device *rtllib, u8 channel)
 	return 0;
 }
 
-
 static inline void rtllib_process_probe_response(
 	struct rtllib_device *ieee,
 	struct rtllib_probe_response *beacon,
@@ -2578,7 +2509,8 @@ static inline void rtllib_process_probe_response(
 	struct rtllib_info_element *info_element = &beacon->info_element[0];
 	unsigned long flags;
 	short renew;
-	struct rtllib_network *network = kzalloc(sizeof(struct rtllib_network), GFP_ATOMIC);
+	struct rtllib_network *network = kzalloc(sizeof(struct rtllib_network),
+						 GFP_ATOMIC);
 
 	if (!network)
 		return;
@@ -2606,12 +2538,12 @@ static inline void rtllib_process_probe_response(
 
 	if (rtllib_network_init(ieee, beacon, network, stats)) {
 		RTLLIB_DEBUG_SCAN("Dropped '%s' (" MAC_FMT ") via %s.\n",
-				     escape_essid(info_element->data,
-						  info_element->len),
-				     MAC_ARG(beacon->header.addr3),
-				     WLAN_FC_GET_STYPE(beacon->header.frame_ctl) ==
-				     RTLLIB_STYPE_PROBE_RESP ?
-				     "PROBE RESPONSE" : "BEACON");
+				  escape_essid(info_element->data,
+				  info_element->len),
+				  MAC_ARG(beacon->header.addr3),
+				  WLAN_FC_GET_STYPE(beacon->header.frame_ctl) ==
+				  RTLLIB_STYPE_PROBE_RESP ?
+				  "PROBE RESPONSE" : "BEACON");
 		goto free_network;
 	}
 
@@ -2619,10 +2551,12 @@ static inline void rtllib_process_probe_response(
 	if (!IsLegalChannel(ieee, network->channel))
 		goto free_network;
 
-	if (WLAN_FC_GET_STYPE(beacon->header.frame_ctl) == RTLLIB_STYPE_PROBE_RESP) {
+	if (WLAN_FC_GET_STYPE(beacon->header.frame_ctl) ==
+	    RTLLIB_STYPE_PROBE_RESP) {
 		if (IsPassiveChannel(ieee, network->channel)) {
-			printk("GetScanInfo(): For Global Domain, "
-			       "filter probe response at channel(%d).\n", network->channel);
+			printk(KERN_INFO "GetScanInfo(): For Global Domain, "
+			       "filter probe response at channel(%d).\n",
+			       network->channel);
 			goto free_network;
 		}
 	}
@@ -2631,32 +2565,32 @@ static inline void rtllib_process_probe_response(
 	 * to see if we can find it in our list.
 	 *
 	 * NOTE:  This search is definitely not optimized.  Once its doing
-	 *        the "right thing" we'll optimize it for efficiency if
-	 *        necessary */
+	 *	the "right thing" we'll optimize it for efficiency if
+	 *	necessary */
 
 	/* Search for this entry in the list and update it if it is
 	 * already there. */
 
 	spin_lock_irqsave(&ieee->lock, flags);
-	{
-		if (is_same_network(&ieee->current_network, network, (network->ssid_len?1:0))) {
-			update_network(&ieee->current_network, network);
-			if ((ieee->current_network.mode == IEEE_N_24G || ieee->current_network.mode == IEEE_G)
-			&& ieee->current_network.berp_info_valid){
-			if (ieee->current_network.erp_value& ERP_UseProtection)
+	if (is_same_network(&ieee->current_network, network,
+	   (network->ssid_len ? 1 : 0))) {
+		update_network(&ieee->current_network, network);
+		if ((ieee->current_network.mode == IEEE_N_24G ||
+		     ieee->current_network.mode == IEEE_G)
+		     && ieee->current_network.berp_info_valid) {
+			if (ieee->current_network.erp_value & ERP_UseProtection)
 				ieee->current_network.buseprotection = true;
-		else
-			ieee->current_network.buseprotection = false;
+			else
+				ieee->current_network.buseprotection = false;
 		}
-		if (is_beacon(beacon->header.frame_ctl))
-		{
-				if (ieee->state >= RTLLIB_LINKED)
-					ieee->LinkDetectInfo.NumRecvBcnInPeriod++;
-			}
+		if (is_beacon(beacon->header.frame_ctl)) {
+			if (ieee->state >= RTLLIB_LINKED)
+				ieee->LinkDetectInfo.NumRecvBcnInPeriod++;
 		}
 	}
 	list_for_each_entry(target, &ieee->network_list, list) {
-		if (is_same_network(target, network,(target->ssid_len?1:0)))
+		if (is_same_network(target, network,
+		   (target->ssid_len ? 1 : 0)))
 			break;
 		if ((oldest == NULL) ||
 		    (target->last_scanned < oldest->last_scanned))
@@ -2684,49 +2618,51 @@ static inline void rtllib_process_probe_response(
 
 
 		RTLLIB_DEBUG_SCAN("Adding '%s' (" MAC_FMT ") via %s.\n",
-				     escape_essid(network->ssid,
-						  network->ssid_len),
-				     MAC_ARG(network->bssid),
-				     WLAN_FC_GET_STYPE(beacon->header.frame_ctl) ==
-				     RTLLIB_STYPE_PROBE_RESP ?
-				     "PROBE RESPONSE" : "BEACON");
+				  escape_essid(network->ssid,
+				  network->ssid_len),
+				  MAC_ARG(network->bssid),
+				  WLAN_FC_GET_STYPE(beacon->header.frame_ctl) ==
+				  RTLLIB_STYPE_PROBE_RESP ?
+				  "PROBE RESPONSE" : "BEACON");
 		memcpy(target, network, sizeof(*target));
 		list_add_tail(&target->list, &ieee->network_list);
 		if (ieee->softmac_features & IEEE_SOFTMAC_ASSOCIATE)
 			rtllib_softmac_new_net(ieee, network);
 	} else {
 		RTLLIB_DEBUG_SCAN("Updating '%s' (" MAC_FMT ") via %s.\n",
-				     escape_essid(target->ssid,
-						  target->ssid_len),
-				     MAC_ARG(target->bssid),
-				     WLAN_FC_GET_STYPE(beacon->header.frame_ctl) ==
-				     RTLLIB_STYPE_PROBE_RESP ?
-				     "PROBE RESPONSE" : "BEACON");
-
-		/* we have an entry and we are going to update it. But this entry may
-		 * be already expired. In this case we do the same as we found a new
-		 * net and call the new_net handler
+				  escape_essid(target->ssid,
+				  target->ssid_len),
+				  MAC_ARG(target->bssid),
+				  WLAN_FC_GET_STYPE(beacon->header.frame_ctl) ==
+				  RTLLIB_STYPE_PROBE_RESP ?
+				  "PROBE RESPONSE" : "BEACON");
+
+		/* we have an entry and we are going to update it. But this
+		 *  entry may be already expired. In this case we do the same
+		 * as we found a new net and call the new_net handler
 		 */
-		renew = !time_after(target->last_scanned + ieee->scan_age, jiffies);
+		renew = !time_after(target->last_scanned + ieee->scan_age,
+				    jiffies);
 		if ((!target->ssid_len) &&
-			(((network->ssid_len > 0) && (target->hidden_ssid_len == 0))
-			|| ((ieee->current_network.ssid_len == network->ssid_len) &&
-			   (strncmp(ieee->current_network.ssid, network->ssid, network->ssid_len) == 0) &&
-			   (ieee->state == RTLLIB_NOLINK)))
-			) {
+		    (((network->ssid_len > 0) && (target->hidden_ssid_len == 0))
+		    || ((ieee->current_network.ssid_len == network->ssid_len) &&
+		    (strncmp(ieee->current_network.ssid, network->ssid,
+		    network->ssid_len) == 0) &&
+		    (ieee->state == RTLLIB_NOLINK))))
 			renew = 1;
-		}
 		update_network(target, network);
 		if (renew && (ieee->softmac_features & IEEE_SOFTMAC_ASSOCIATE))
 			rtllib_softmac_new_net(ieee, network);
 	}
 
 	spin_unlock_irqrestore(&ieee->lock, flags);
-	if (is_beacon(beacon->header.frame_ctl)&&is_same_network(&ieee->current_network, network, (network->ssid_len?1:0))&&\
-		(ieee->state == RTLLIB_LINKED)) {
-		if (ieee->handle_beacon != NULL) {
-			ieee->handle_beacon(ieee->dev,beacon,&ieee->current_network);
-		}
+	if (is_beacon(beacon->header.frame_ctl) &&
+	    is_same_network(&ieee->current_network, network,
+	    (network->ssid_len ? 1 : 0)) &&
+	    (ieee->state == RTLLIB_LINKED)) {
+		if (ieee->handle_beacon != NULL)
+			ieee->handle_beacon(ieee->dev, beacon,
+					    &ieee->current_network);
 	}
 free_network:
 	kfree(network);
@@ -2734,48 +2670,48 @@ static inline void rtllib_process_probe_response(
 }
 
 void rtllib_rx_mgt(struct rtllib_device *ieee,
-                      struct sk_buff *skb,
+		      struct sk_buff *skb,
 		      struct rtllib_rx_stats *stats)
 {
-    struct rtllib_hdr_4addr *header = (struct rtllib_hdr_4addr *)skb->data ;
-    if (WLAN_FC_GET_STYPE(header->frame_ctl) != RTLLIB_STYPE_PROBE_RESP &&
-            WLAN_FC_GET_STYPE(header->frame_ctl) != RTLLIB_STYPE_BEACON)
-        ieee->last_rx_ps_time = jiffies;
-
-    switch (WLAN_FC_GET_STYPE(header->frame_ctl)) {
-
-        case RTLLIB_STYPE_BEACON:
-            RTLLIB_DEBUG_MGMT("received BEACON (%d)\n",
-                    WLAN_FC_GET_STYPE(header->frame_ctl));
-            RTLLIB_DEBUG_SCAN("Beacon\n");
-            rtllib_process_probe_response(
-                    ieee, (struct rtllib_probe_response *)header, stats);
-
-            if (ieee->sta_sleep || (ieee->ps != RTLLIB_PS_DISABLED &&
-                        ieee->iw_mode == IW_MODE_INFRA &&
-                        ieee->state == RTLLIB_LINKED))
-		tasklet_schedule(&ieee->ps_task);
-
-            break;
-
-        case RTLLIB_STYPE_PROBE_RESP:
-            RTLLIB_DEBUG_MGMT("received PROBE RESPONSE (%d)\n",
-                    WLAN_FC_GET_STYPE(header->frame_ctl));
-            RTLLIB_DEBUG_SCAN("Probe response\n");
-            rtllib_process_probe_response(
-                    ieee, (struct rtllib_probe_response *)header, stats);
-            break;
-        case RTLLIB_STYPE_PROBE_REQ:
-            RTLLIB_DEBUG_MGMT("received PROBE RESQUEST (%d)\n",
-                    WLAN_FC_GET_STYPE(header->frame_ctl));
-            RTLLIB_DEBUG_SCAN("Probe request\n");
-            if ((ieee->softmac_features & IEEE_SOFTMAC_PROBERS) &&
-                    ((ieee->iw_mode == IW_MODE_ADHOC ||
-                      ieee->iw_mode == IW_MODE_MASTER) &&
-                     ieee->state == RTLLIB_LINKED)){
-                rtllib_rx_probe_rq(ieee, skb);
-            }
-            break;
-    }
+	struct rtllib_hdr_4addr *header = (struct rtllib_hdr_4addr *)skb->data ;
+
+	if (WLAN_FC_GET_STYPE(header->frame_ctl) != RTLLIB_STYPE_PROBE_RESP &&
+	    WLAN_FC_GET_STYPE(header->frame_ctl) != RTLLIB_STYPE_BEACON)
+		ieee->last_rx_ps_time = jiffies;
+
+	switch (WLAN_FC_GET_STYPE(header->frame_ctl)) {
+
+	case RTLLIB_STYPE_BEACON:
+		RTLLIB_DEBUG_MGMT("received BEACON (%d)\n",
+				  WLAN_FC_GET_STYPE(header->frame_ctl));
+		RTLLIB_DEBUG_SCAN("Beacon\n");
+		rtllib_process_probe_response(
+				ieee, (struct rtllib_probe_response *)header,
+				stats);
 
+		if (ieee->sta_sleep || (ieee->ps != RTLLIB_PS_DISABLED &&
+		    ieee->iw_mode == IW_MODE_INFRA &&
+		    ieee->state == RTLLIB_LINKED))
+			tasklet_schedule(&ieee->ps_task);
+
+		break;
+
+	case RTLLIB_STYPE_PROBE_RESP:
+		RTLLIB_DEBUG_MGMT("received PROBE RESPONSE (%d)\n",
+			WLAN_FC_GET_STYPE(header->frame_ctl));
+		RTLLIB_DEBUG_SCAN("Probe response\n");
+		rtllib_process_probe_response(ieee,
+			      (struct rtllib_probe_response *)header, stats);
+		break;
+	case RTLLIB_STYPE_PROBE_REQ:
+		RTLLIB_DEBUG_MGMT("received PROBE RESQUEST (%d)\n",
+				  WLAN_FC_GET_STYPE(header->frame_ctl));
+		RTLLIB_DEBUG_SCAN("Probe request\n");
+		if ((ieee->softmac_features & IEEE_SOFTMAC_PROBERS) &&
+		    ((ieee->iw_mode == IW_MODE_ADHOC ||
+		    ieee->iw_mode == IW_MODE_MASTER) &&
+		    ieee->state == RTLLIB_LINKED))
+			rtllib_rx_probe_rq(ieee, skb);
+		break;
+	}
 }

commit 0dd565069b21ae20f4916cf305b64268bb3f9d3f
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Thu Aug 25 11:48:12 2011 -0500

    staging: rtl8192e: Modify time handling
    
    In several places, the driver keeps times (in jiffies) in two 32-bit
    quantities. In the rtl8192_hw_to_sleep(), there is an error in the
    calculation of the difference between two 64-bit quantities. Rather
    than fix that error, I have converted to a single 64-bit number. That
    makes the code be much cleaner and clearer.
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index 24ad9713d0b6..9606bedf16de 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -1867,8 +1867,7 @@ int rtllib_parse_info_param(struct rtllib_device *ieee,
                         network->dtim_period = info_element->data[1];
                         if (ieee->state != RTLLIB_LINKED)
                                 break;
-			network->last_dtim_sta_time[0] = jiffies;
-                        network->last_dtim_sta_time[1] = stats->mac_time[1];
+			network->last_dtim_sta_time = jiffies;
 
                         network->dtim_data = RTLLIB_DTIM_VALID;
 
@@ -2466,8 +2465,7 @@ static inline void update_network(struct rtllib_network *dst,
 	dst->atim_window = src->atim_window;
 	dst->dtim_period = src->dtim_period;
 	dst->dtim_data = src->dtim_data;
-	dst->last_dtim_sta_time[0] = src->last_dtim_sta_time[0];
-	dst->last_dtim_sta_time[1] = src->last_dtim_sta_time[1];
+	dst->last_dtim_sta_time = src->last_dtim_sta_time;
 	memcpy(&dst->tim, &src->tim, sizeof(struct rtllib_tim_parameters));
 
         dst->bssht.bdSupportHT = src->bssht.bdSupportHT;

commit 6e579119b104967e91e506de2c7ac7ec1ac4d213
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Tue Jul 19 18:20:30 2011 -0500

    staging: rtl8192e: Convert typedef HT_CHANNEL_WIDTH to enum ht_channel_width
    
    Remove typedef from enum.
    Rename enum.
    Rename uses.
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index ee05d7685f92..24ad9713d0b6 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -2157,7 +2157,7 @@ int rtllib_parse_info_param(struct rtllib_device *ieee,
 				network->bssht.bdSupportHT = true;
 				network->bssht.bdHT1R = ((((struct ht_capab_ele *)(network->bssht.bdHTCapBuf))->MCS[1]) == 0);
 
-				network->bssht.bdBandWidth = (HT_CHANNEL_WIDTH)(((struct ht_capab_ele *)(network->bssht.bdHTCapBuf))->ChlWidth);
+				network->bssht.bdBandWidth = (enum ht_channel_width)(((struct ht_capab_ele *)(network->bssht.bdHTCapBuf))->ChlWidth);
 			}
 			else{
 				network->bssht.bdSupportHT = false;

commit 66ba443abf111ab8e8df86e6eb0fb8d87fd5dc21
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Tue Jul 19 10:37:34 2011 -0500

    staging: rtl8192e: Convert typedef frameqos to union frameqos
    
    Remove typedef from union.
    Rename union.
    Rename uses.
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index 68f4aeed9e56..ee05d7685f92 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -748,7 +748,7 @@ u8 parse_subframe(struct rtllib_device* ieee,struct sk_buff *skb,
 	/* just for debug purpose */
 	SeqNum = WLAN_GET_SEQ_SEQ(le16_to_cpu(hdr->seq_ctl));
 	if ((RTLLIB_QOS_HAS_SEQ(fc))&&\
-			(((frameqos *)(skb->data + RTLLIB_3ADDR_LEN))->field.reserved)) {
+			(((union frameqos *)(skb->data + RTLLIB_3ADDR_LEN))->field.reserved)) {
 		bIsAggregateFrame = true;
 	}
 

commit fc22c052e20496935ee165609ed814eed336cd4a
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Tue Jul 19 00:32:34 2011 -0500

    staging: rtl8192e: Convert typedef buffer to struct buffer
    
    Remove typedef from struct.
    Rename struct.
    Rename uses.
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index 909a2f5e8de6..68f4aeed9e56 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -618,7 +618,7 @@ void RxReorderIndicatePacket( struct rtllib_device *ieee,
 	/*
 	 * Indication process.
 	 * After Packet dropping and Sliding Window shifting as above, we can now just indicate the packets
-	 * with the SeqNum smaller than latest WinStart and buffer other packets.
+	 * with the SeqNum smaller than latest WinStart and struct buffer other packets.
 	 */
 	/* For Rx Reorder condition:
 	 * 1. All packets with SeqNum smaller than WinStart => Indicate
@@ -654,14 +654,14 @@ void RxReorderIndicatePacket( struct rtllib_device *ieee,
 				}
 			} else {
 				RTLLIB_DEBUG(RTLLIB_DL_REORDER,
-					 "Pkt insert into buffer!! IndicateSeq: %d, NewSeq: %d\n",pTS->RxIndicateSeq, SeqNum);
+					 "Pkt insert into struct buffer!! IndicateSeq: %d, NewSeq: %d\n",pTS->RxIndicateSeq, SeqNum);
 			}
 		}
 		else {
 			/*
 			 * Packets are dropped if there is not enough reorder entries.
 			 * This part shall be modified!! We can just indicate all the
-			 * packets in buffer and get reorder entries.
+			 * packets in struct buffer and get reorder entries.
 			 */
 			RTLLIB_DEBUG(RTLLIB_DL_ERR, "RxReorderIndicatePacket(): There is no reorder entry!! Packet is dropped!!\n");
 			{
@@ -683,7 +683,7 @@ void RxReorderIndicatePacket( struct rtllib_device *ieee,
 		if ( SN_LESS(pReorderEntry->SeqNum, pTS->RxIndicateSeq) ||
 				SN_EQUAL(pReorderEntry->SeqNum, pTS->RxIndicateSeq))
 		{
-			/* This protect buffer from overflow. */
+			/* This protect struct buffer from overflow. */
 			if (index >= REORDER_WIN_SIZE) {
 				RTLLIB_DEBUG(RTLLIB_DL_ERR, "RxReorderIndicatePacket(): Buffer overflow!! \n");
 				bPktInBuf = true;
@@ -714,7 +714,7 @@ void RxReorderIndicatePacket( struct rtllib_device *ieee,
 		pTS->RxTimeoutIndicateSeq = 0xffff;
 
 		if (index>REORDER_WIN_SIZE){
-			RTLLIB_DEBUG(RTLLIB_DL_ERR, "RxReorderIndicatePacket(): Rx Reorer buffer full!! \n");
+			RTLLIB_DEBUG(RTLLIB_DL_ERR, "RxReorderIndicatePacket(): Rx Reorer struct buffer full!! \n");
 			spin_unlock_irqrestore(&(ieee->reorder_spinlock), flags);
 			return;
 		}
@@ -771,7 +771,7 @@ u8 parse_subframe(struct rtllib_device* ieee,struct sk_buff *skb,
 		rxb->nr_subframes = 1;
 
 		/* altered by clark 3/30/2010
-		 * The buffer size of the skb indicated to upper layer
+		 * The struct buffer size of the skb indicated to upper layer
 		 * must be less than 5000, or the defraged IP datagram
 		 * in the IP layer will exceed "ipfrag_high_tresh" and be
 		 * discarded. so there must not use the function
@@ -813,7 +813,7 @@ u8 parse_subframe(struct rtllib_device* ieee,struct sk_buff *skb,
 			skb_pull(skb, ETHERNET_HEADER_SIZE);
 
 			/* altered by clark 3/30/2010
-			 * The buffer size of the skb indicated to upper layer
+			 * The struct buffer size of the skb indicated to upper layer
 			 * must be less than 5000, or the defraged IP datagram
 			 * in the IP layer will exceed "ipfrag_high_tresh" and be
 			 * discarded. so there must not use the function

commit 3b83db43ccbb26863f38caccc1e7fae370f31e57
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Tue Jul 19 00:01:29 2011 -0500

    staging: rtl8192e: Convert typedef cb_desc to struct cb_desc
    
    Remove typedef from struct.
    Rename struct.
    Rename uses.
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index 03e9df1e918c..909a2f5e8de6 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -291,7 +291,7 @@ rtllib_rx_frame_decrypt(struct rtllib_device* ieee, struct sk_buff *skb,
 
 	if (ieee->hwsec_active)
 	{
-		cb_desc *tcb_desc = (cb_desc *)(skb->cb+ MAX_DEV_ADDR_SIZE);
+		struct cb_desc *tcb_desc = (struct cb_desc *)(skb->cb+ MAX_DEV_ADDR_SIZE);
 		tcb_desc->bHwSec = 1;
 
 		if (ieee->need_sw_enc)
@@ -332,7 +332,7 @@ rtllib_rx_frame_decrypt_msdu(struct rtllib_device* ieee, struct sk_buff *skb,
 		return 0;
 	if (ieee->hwsec_active)
 	{
-		cb_desc *tcb_desc = (cb_desc *)(skb->cb+ MAX_DEV_ADDR_SIZE);
+		struct cb_desc *tcb_desc = (struct cb_desc *)(skb->cb+ MAX_DEV_ADDR_SIZE);
 		tcb_desc->bHwSec = 1;
 
 		if (ieee->need_sw_enc)

commit 8cba1432cee4c88668160750f1892aa09a2ba56a
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Mon Jul 18 22:16:48 2011 -0500

    staging: rtl8192e: Convert typedef RX_REORDER_ENTRY to struct rx_reorder_entry
    
    Remove typedef from struct.
    Rename struct.
    Rename uses.
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index ff69523a79df..03e9df1e918c 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -448,18 +448,18 @@ static int is_duplicate_packet(struct rtllib_device *ieee,
 bool
 AddReorderEntry(
 	struct rx_ts_record *pTS,
-	PRX_REORDER_ENTRY		pReorderEntry
+	struct rx_reorder_entry *pReorderEntry
 	)
 {
 	struct list_head *pList = &pTS->RxPendingPktList;
 
 	while(pList->next != &pTS->RxPendingPktList)
 	{
-		if ( SN_LESS(pReorderEntry->SeqNum, ((PRX_REORDER_ENTRY)list_entry(pList->next,RX_REORDER_ENTRY,List))->SeqNum) )
+		if ( SN_LESS(pReorderEntry->SeqNum, ((struct rx_reorder_entry *)list_entry(pList->next,struct rx_reorder_entry,List))->SeqNum) )
 		{
 			pList = pList->next;
 		}
-		else if ( SN_EQUAL(pReorderEntry->SeqNum, ((PRX_REORDER_ENTRY)list_entry(pList->next,RX_REORDER_ENTRY,List))->SeqNum) )
+		else if ( SN_EQUAL(pReorderEntry->SeqNum, ((struct rx_reorder_entry *)list_entry(pList->next,struct rx_reorder_entry,List))->SeqNum) )
 		{
 			return false;
 		}
@@ -529,7 +529,7 @@ void rtllib_indicate_packets(struct rtllib_device *ieee, struct rtllib_rxb** prx
 void
 rtllib_FlushRxTsPendingPkts(struct rtllib_device *ieee,	struct rx_ts_record *pTS)
 {
-	PRX_REORDER_ENTRY	pRxReorderEntry;
+	struct rx_reorder_entry *pRxReorderEntry;
 	struct rtllib_rxb*		RfdArray[REORDER_WIN_SIZE];
 	u8					RfdCnt = 0;
 
@@ -542,7 +542,7 @@ rtllib_FlushRxTsPendingPkts(struct rtllib_device *ieee,	struct rx_ts_record *pTS
 			break;
 		}
 
-		pRxReorderEntry = (PRX_REORDER_ENTRY)list_entry(pTS->RxPendingPktList.prev,RX_REORDER_ENTRY,List);
+		pRxReorderEntry = (struct rx_reorder_entry *)list_entry(pTS->RxPendingPktList.prev,struct rx_reorder_entry,List);
 		RTLLIB_DEBUG(RTLLIB_DL_REORDER,"%s(): Indicate SeqNum %d!\n",__func__, pRxReorderEntry->SeqNum);
 		list_del_init(&pRxReorderEntry->List);
 
@@ -563,7 +563,7 @@ void RxReorderIndicatePacket( struct rtllib_device *ieee,
 		u16			SeqNum)
 {
 	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
-	PRX_REORDER_ENTRY	pReorderEntry = NULL;
+	struct rx_reorder_entry *pReorderEntry = NULL;
 	struct rtllib_rxb* prxbIndicateArray[REORDER_WIN_SIZE];
 	u8			WinSize = pHTInfo->RxReorderWinSize;
 	u16			WinEnd = 0;
@@ -633,7 +633,7 @@ void RxReorderIndicatePacket( struct rtllib_device *ieee,
 	} else {
 		/* Current packet is going to be inserted into pending list.*/
 		if (!list_empty(&ieee->RxReorder_Unused_List)) {
-			pReorderEntry = (PRX_REORDER_ENTRY)list_entry(ieee->RxReorder_Unused_List.next,RX_REORDER_ENTRY,List);
+			pReorderEntry = (struct rx_reorder_entry *)list_entry(ieee->RxReorder_Unused_List.next,struct rx_reorder_entry,List);
 			list_del_init(&pReorderEntry->List);
 
 			/* Make a reorder entry and insert into a the packet list.*/
@@ -679,7 +679,7 @@ void RxReorderIndicatePacket( struct rtllib_device *ieee,
 	while(!list_empty(&pTS->RxPendingPktList)) {
 		RTLLIB_DEBUG(RTLLIB_DL_REORDER,"%s(): start RREORDER indicate\n",__func__);
 
-		pReorderEntry = (PRX_REORDER_ENTRY)list_entry(pTS->RxPendingPktList.prev,RX_REORDER_ENTRY,List);
+		pReorderEntry = (struct rx_reorder_entry *)list_entry(pTS->RxPendingPktList.prev,struct rx_reorder_entry,List);
 		if ( SN_LESS(pReorderEntry->SeqNum, pTS->RxIndicateSeq) ||
 				SN_EQUAL(pReorderEntry->SeqNum, pTS->RxIndicateSeq))
 		{

commit e92b71d571dfc08ae0ac792ffa463c0a601c32a5
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Mon Jul 18 20:34:19 2011 -0500

    staging: rtl8192e: Convert typedef HT_CAPABILITY_ELE to struct ht_capab_ele
    
    Remove typedef from struct.
    Rename struct.
    Rename uses.
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index a6a27847adac..ff69523a79df 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -1949,7 +1949,7 @@ int rtllib_parse_info_param(struct rtllib_device *ieee,
 				}
 				if (tmp_htcap_len != 0){
 					network->bssht.bdSupportHT = true;
-					network->bssht.bdHT1R = ((((PHT_CAPABILITY_ELE)(network->bssht.bdHTCapBuf))->MCS[1]) == 0);
+					network->bssht.bdHT1R = ((((struct ht_capab_ele *)(network->bssht.bdHTCapBuf))->MCS[1]) == 0);
 				}else{
 					network->bssht.bdSupportHT = false;
 					network->bssht.bdHT1R = false;
@@ -2155,9 +2155,9 @@ int rtllib_parse_info_param(struct rtllib_device *ieee,
 				memcpy(network->bssht.bdHTCapBuf,info_element->data,network->bssht.bdHTCapLen);
 
 				network->bssht.bdSupportHT = true;
-				network->bssht.bdHT1R = ((((PHT_CAPABILITY_ELE)(network->bssht.bdHTCapBuf))->MCS[1]) == 0);
+				network->bssht.bdHT1R = ((((struct ht_capab_ele *)(network->bssht.bdHTCapBuf))->MCS[1]) == 0);
 
-				network->bssht.bdBandWidth = (HT_CHANNEL_WIDTH)(((PHT_CAPABILITY_ELE)(network->bssht.bdHTCapBuf))->ChlWidth);
+				network->bssht.bdBandWidth = (HT_CHANNEL_WIDTH)(((struct ht_capab_ele *)(network->bssht.bdHTCapBuf))->ChlWidth);
 			}
 			else{
 				network->bssht.bdSupportHT = false;

commit 7796d93eae46054d5a3bb5411fde735801998dc5
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Mon Jul 18 20:22:19 2011 -0500

    staging: rtl8192e: Convert typedef RT_HIGH_THROUGHPUT to struct rt_hi_throughput
    
    Remove typedef from struct.
    Rename struct.
    Rename uses.
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index 3c8c11c99230..a6a27847adac 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -562,7 +562,7 @@ void RxReorderIndicatePacket( struct rtllib_device *ieee,
 		struct rx_ts_record *pTS,
 		u16			SeqNum)
 {
-	PRT_HIGH_THROUGHPUT	pHTInfo = ieee->pHTInfo;
+	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
 	PRX_REORDER_ENTRY	pReorderEntry = NULL;
 	struct rtllib_rxb* prxbIndicateArray[REORDER_WIN_SIZE];
 	u8			WinSize = pHTInfo->RxReorderWinSize;

commit 74724de1c40192d74a213e615b945df8de935ca2
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Mon Jul 18 20:19:19 2011 -0500

    staging: rtl8192e: Convert typedef TS_COMMON_INFO to struct ts_common_info
    
    Remove typedef from struct.
    Rename struct.
    Rename uses.
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index 35715315c677..3c8c11c99230 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -897,7 +897,7 @@ int rtllib_rx_check_duplicate(struct rtllib_device *ieee, struct sk_buff *skb, u
 		}
 	} else {
 		struct rx_ts_record *pRxTS = NULL;
-		if (GetTs(ieee, (PTS_COMMON_INFO*) &pRxTS, hdr->addr2,
+		if (GetTs(ieee, (struct ts_common_info **) &pRxTS, hdr->addr2,
 			(u8)Frame_QoSTID((u8*)(skb->data)), RX_DIR, true)) {
 			if ((fc & (1<<11)) && (frag == pRxTS->RxLastFragNum) &&
 			    (WLAN_GET_SEQ_SEQ(sc) == pRxTS->RxLastSeqNum)) {
@@ -1356,7 +1356,7 @@ int rtllib_rx_InfraAdhoc(struct rtllib_device *ieee, struct sk_buff *skb,
 	{
 		TID = Frame_QoSTID(skb->data);
 		SeqNum = WLAN_GET_SEQ_SEQ(sc);
-		GetTs(ieee,(PTS_COMMON_INFO*) &pTS,hdr->addr2,TID,RX_DIR,true);
+		GetTs(ieee,(struct ts_common_info **) &pTS,hdr->addr2,TID,RX_DIR,true);
 		if (TID !=0 && TID !=3){
 			ieee->bis_any_nonbepkts = true;
 		}

commit 2c47ae282a4bbaebfdbba614fb6133db520212ba
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Mon Jul 18 20:11:56 2011 -0500

    staging: rtl8192e: Convert typedef RX_TS_RECORD to struct rx_ts_record
    
    Remove typedef from struct.
    Rename struct.
    Rename uses.
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index 2c4e777f3c08..35715315c677 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -447,7 +447,7 @@ static int is_duplicate_packet(struct rtllib_device *ieee,
 }
 bool
 AddReorderEntry(
-	PRX_TS_RECORD			pTS,
+	struct rx_ts_record *pTS,
 	PRX_REORDER_ENTRY		pReorderEntry
 	)
 {
@@ -527,7 +527,7 @@ void rtllib_indicate_packets(struct rtllib_device *ieee, struct rtllib_rxb** prx
 }
 
 void
-rtllib_FlushRxTsPendingPkts(struct rtllib_device *ieee,	PRX_TS_RECORD pTS)
+rtllib_FlushRxTsPendingPkts(struct rtllib_device *ieee,	struct rx_ts_record *pTS)
 {
 	PRX_REORDER_ENTRY	pRxReorderEntry;
 	struct rtllib_rxb*		RfdArray[REORDER_WIN_SIZE];
@@ -559,7 +559,7 @@ rtllib_FlushRxTsPendingPkts(struct rtllib_device *ieee,	PRX_TS_RECORD pTS)
 
 void RxReorderIndicatePacket( struct rtllib_device *ieee,
 		struct rtllib_rxb* prxb,
-		PRX_TS_RECORD		pTS,
+		struct rx_ts_record *pTS,
 		u16			SeqNum)
 {
 	PRT_HIGH_THROUGHPUT	pHTInfo = ieee->pHTInfo;
@@ -896,7 +896,7 @@ int rtllib_rx_check_duplicate(struct rtllib_device *ieee, struct sk_buff *skb, u
 			}
 		}
 	} else {
-		PRX_TS_RECORD pRxTS = NULL;
+		struct rx_ts_record *pRxTS = NULL;
 		if (GetTs(ieee, (PTS_COMMON_INFO*) &pRxTS, hdr->addr2,
 			(u8)Frame_QoSTID((u8*)(skb->data)), RX_DIR, true)) {
 			if ((fc & (1<<11)) && (frag == pRxTS->RxLastFragNum) &&
@@ -1253,7 +1253,7 @@ int rtllib_rx_InfraAdhoc(struct rtllib_device *ieee, struct sk_buff *skb,
 	struct rtllib_hdr_4addr *hdr = (struct rtllib_hdr_4addr *)skb->data;
 	struct rtllib_crypt_data *crypt = NULL;
 	struct rtllib_rxb* rxb = NULL;
-	PRX_TS_RECORD pTS = NULL;
+	struct rx_ts_record *pTS = NULL;
 	u16 fc, sc, SeqNum = 0;
 	u8 type, stype, multicast = 0, unicast = 0, nr_subframes = 0, TID = 0;
 	u8 dst[ETH_ALEN], src[ETH_ALEN], bssid[ETH_ALEN] = {0}, *payload;

commit 8cc638e95bcef31d5f8896bbe5ca06fd52fa7947
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Thu Jul 14 18:48:38 2011 -0500

    staging: rtl8192e: Remove ifdefs for CONFIG_RTLLIB_DEBUG
    
    This symbol is unconditionally defined in a header file, thus tests for it can be removed.
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index b6e23a2ab08f..2c4e777f3c08 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -1131,14 +1131,12 @@ int rtllib_rx_decrypt(
 		if (/*ieee->ieee802_1x &&*/
 		    rtllib_is_eapol_frame(ieee, skb, hdrlen)) {
 
-#ifdef CONFIG_RTLLIB_DEBUG
 			/* pass unencrypted EAPOL frames even if encryption is
 			 * configured */
 			struct eapol *eap = (struct eapol *)(skb->data +
 				24);
 			RTLLIB_DEBUG_EAP("RX: IEEE 802.1X EAPOL frame: %s\n",
 						eap_get_type(eap->type));
-#endif
 		} else {
 			RTLLIB_DEBUG_DROP(
 				"encryption configured, but RX "
@@ -1148,7 +1146,6 @@ int rtllib_rx_decrypt(
 		}
 	}
 
-#ifdef CONFIG_RTLLIB_DEBUG
 	if (crypt && !(fc & RTLLIB_FCTL_WEP) &&
 	    rtllib_is_eapol_frame(ieee, skb, hdrlen)) {
 			struct eapol *eap = (struct eapol *)(skb->data +
@@ -1156,7 +1153,6 @@ int rtllib_rx_decrypt(
 			RTLLIB_DEBUG_EAP("RX: IEEE 802.1X EAPOL frame: %s\n",
 						eap_get_type(eap->type));
 	}
-#endif
 
 	if (crypt && !(fc & RTLLIB_FCTL_WEP) && !ieee->open_wep &&
 	    !rtllib_is_eapol_frame(ieee, skb, hdrlen)) {
@@ -1686,7 +1682,6 @@ static int rtllib_parse_qos_info_param_IE(struct rtllib_info_element
         return rc;
 }
 
-#ifdef CONFIG_RTLLIB_DEBUG
 #define MFIE_STRING(x) case MFIE_TYPE_ ##x: return #x
 
 static const char *get_info_element_string(u16 id)
@@ -1722,7 +1717,6 @@ static const char *get_info_element_string(u16 id)
                 return "UNKNOWN";
         }
 }
-#endif
 
 static inline void rtllib_extract_country_ie(
 	struct rtllib_device *ieee,
@@ -1762,10 +1756,9 @@ int rtllib_parse_info_param(struct rtllib_device *ieee,
 	u16	tmp_htinfo_len=0;
 	u16 ht_realtek_agg_len=0;
 	u8  ht_realtek_agg_buf[MAX_IE_LEN];
-#ifdef CONFIG_RTLLIB_DEBUG
 	char rates_str[64];
 	char *p;
-#endif
+
 	while (length >= sizeof(*info_element)) {
 		if (sizeof(*info_element) + info_element->len > length) {
 			RTLLIB_DEBUG_MGMT("Info elem: parse failed: "
@@ -1800,18 +1793,14 @@ int rtllib_parse_info_param(struct rtllib_device *ieee,
 			break;
 
 		case MFIE_TYPE_RATES:
-#ifdef CONFIG_RTLLIB_DEBUG
 			p = rates_str;
-#endif
 			network->rates_len = min(info_element->len,
 						 MAX_RATES_LENGTH);
 			for (i = 0; i < network->rates_len; i++) {
 				network->rates[i] = info_element->data[i];
-#ifdef CONFIG_RTLLIB_DEBUG
 				p += snprintf(p, sizeof(rates_str) -
 					      (p - rates_str), "%02X ",
 					      network->rates[i]);
-#endif
 				if (rtllib_is_ofdm_rate
 				    (info_element->data[i])) {
 					network->flags |= NETWORK_HAS_OFDM;
@@ -1832,18 +1821,14 @@ int rtllib_parse_info_param(struct rtllib_device *ieee,
 			break;
 
 		case MFIE_TYPE_RATES_EX:
-#ifdef CONFIG_RTLLIB_DEBUG
 			p = rates_str;
-#endif
 			network->rates_ex_len = min(info_element->len,
 						    MAX_RATES_EX_LENGTH);
 			for (i = 0; i < network->rates_ex_len; i++) {
 				network->rates_ex[i] = info_element->data[i];
-#ifdef CONFIG_RTLLIB_DEBUG
 				p += snprintf(p, sizeof(rates_str) -
 					      (p - rates_str), "%02X ",
 					      network->rates[i]);
-#endif
 				if (rtllib_is_ofdm_rate
 				    (info_element->data[i])) {
 					network->flags |= NETWORK_HAS_OFDM;
@@ -2322,8 +2307,6 @@ static inline int rtllib_network_init(
 	struct rtllib_network *network,
 	struct rtllib_rx_stats *stats)
 {
-#ifdef CONFIG_RTLLIB_DEBUG
-#endif
 
 	/*
         network->qos_data.active = 0;
@@ -2594,9 +2577,7 @@ static inline void rtllib_process_probe_response(
 {
 	struct rtllib_network *target;
 	struct rtllib_network *oldest = NULL;
-#ifdef CONFIG_RTLLIB_DEBUG
 	struct rtllib_info_element *info_element = &beacon->info_element[0];
-#endif
 	unsigned long flags;
 	short renew;
 	struct rtllib_network *network = kzalloc(sizeof(struct rtllib_network), GFP_ATOMIC);
@@ -2704,7 +2685,6 @@ static inline void rtllib_process_probe_response(
 		}
 
 
-#ifdef CONFIG_RTLLIB_DEBUG
 		RTLLIB_DEBUG_SCAN("Adding '%s' (" MAC_FMT ") via %s.\n",
 				     escape_essid(network->ssid,
 						  network->ssid_len),
@@ -2712,7 +2692,6 @@ static inline void rtllib_process_probe_response(
 				     WLAN_FC_GET_STYPE(beacon->header.frame_ctl) ==
 				     RTLLIB_STYPE_PROBE_RESP ?
 				     "PROBE RESPONSE" : "BEACON");
-#endif
 		memcpy(target, network, sizeof(*target));
 		list_add_tail(&target->list, &ieee->network_list);
 		if (ieee->softmac_features & IEEE_SOFTMAC_ASSOCIATE)

commit 69dbddce03e40650fb28fc5954c3ccd59a53d201
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Thu Jul 14 17:18:14 2011 -0500

    staging: rtl8192e: Remove dead code associated with CONFIG_RTLLIB_CRYPT_TKIP
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index cef04e59515f..b6e23a2ab08f 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -301,18 +301,6 @@ rtllib_rx_frame_decrypt(struct rtllib_device* ieee, struct sk_buff *skb,
 	hdr = (struct rtllib_hdr_4addr *) skb->data;
 	hdrlen = rtllib_get_hdrlen(le16_to_cpu(hdr->frame_ctl));
 
-#ifdef CONFIG_RTLLIB_CRYPT_TKIP
-	if (ieee->tkip_countermeasures &&
-	    strcmp(crypt->ops->name, "TKIP") == 0) {
-		if (net_ratelimit()) {
-			printk(KERN_DEBUG "%s: TKIP countermeasures: dropped "
-			       "received packet from " MAC_FMT "\n",
-			       ieee->dev->name, MAC_ARG(hdr->addr2));
-		}
-		return -1;
-	}
-#endif
-
 	atomic_inc(&crypt->refcnt);
 	res = crypt->ops->decrypt_mpdu(skb, hdrlen, crypt->priv);
 	atomic_dec(&crypt->refcnt);

commit 1bd7bcfc633eeb821b85a90067be2bea79510d39
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Thu Jul 14 17:08:46 2011 -0500

    staging: rtl8192e: Remove dead code associated with CONFIG_CFG_80211
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index f4f7ec509b3b..cef04e59515f 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -45,276 +45,6 @@
 #include "rtllib.h"
 #include "dot11d.h"
 
-#if defined CONFIG_CFG_80211
-#include <linux/crc32.h>
-
-struct ieee80211_channel *rtllib_get_channel(struct wiphy *wiphy,
-						  int freq)
-{
-	enum ieee80211_band band;
-	struct ieee80211_supported_band *sband;
-	int i;
-
-	for (band = 0; band < IEEE80211_NUM_BANDS; band++) {
-		sband = wiphy->bands[band];
-
-		if (!sband)
-			continue;
-
-		for (i = 0; i < sband->n_channels; i++) {
-			if (sband->channels[i].center_freq == freq)
-				return &sband->channels[i];
-		}
-	}
-
-	return NULL;
-}
-
-int rtllib_channel_to_frequency(int chan)
-{
-	if (chan < 14)
-		return 2407 + chan * 5;
-
-	if (chan == 14)
-		return 2484;
-
-	/* FIXME: 802.11j 17.3.8.3.2 */
-	return (chan + 1000) * 5;
-}
-
-u32 rtllib_parse_elems_crc(u8 *start, size_t len,
-			       struct ieee802_11_elems *elems,
-			       u64 filter, u32 crc)
-{
-	size_t left = len;
-	u8 *pos = start;
-	bool calc_crc = filter != 0;
-
-	memset(elems, 0, sizeof(*elems));
-	elems->ie_start = start;
-	elems->total_len = len;
-
-	while (left >= 2) {
-		u8 id, elen;
-
-		id = *pos++;
-		elen = *pos++;
-		left -= 2;
-
-		if (elen > left)
-			break;
-
-		if (calc_crc && id < 64 && (filter & BIT(id)))
-			crc = crc32_be(crc, pos - 2, elen + 2);
-
-		switch (id) {
-		case WLAN_EID_SSID:
-			elems->ssid = pos;
-			elems->ssid_len = elen;
-			break;
-		case WLAN_EID_SUPP_RATES:
-			elems->supp_rates = pos;
-			elems->supp_rates_len = elen;
-			break;
-		case WLAN_EID_FH_PARAMS:
-			elems->fh_params = pos;
-			elems->fh_params_len = elen;
-			break;
-		case WLAN_EID_DS_PARAMS:
-			elems->ds_params = pos;
-			elems->ds_params_len = elen;
-			break;
-		case WLAN_EID_CF_PARAMS:
-			elems->cf_params = pos;
-			elems->cf_params_len = elen;
-			break;
-		case WLAN_EID_TIM:
-			if (elen >= sizeof(struct ieee80211_tim_ie)) {
-				elems->tim = (void *)pos;
-				elems->tim_len = elen;
-			}
-			break;
-		case WLAN_EID_IBSS_PARAMS:
-			elems->ibss_params = pos;
-			elems->ibss_params_len = elen;
-			break;
-		case WLAN_EID_CHALLENGE:
-			elems->challenge = pos;
-			elems->challenge_len = elen;
-			break;
-		case WLAN_EID_VENDOR_SPECIFIC:
-			if (elen >= 4 && pos[0] == 0x00 && pos[1] == 0x50 &&
-			    pos[2] == 0xf2) {
-				/* Microsoft OUI (00:50:F2) */
-
-				if (calc_crc)
-					crc = crc32_be(crc, pos - 2, elen + 2);
-
-				if (pos[3] == 1) {
-					/* OUI Type 1 - WPA IE */
-					elems->wpa = pos;
-					elems->wpa_len = elen;
-				} else if (elen >= 5 && pos[3] == 2) {
-					/* OUI Type 2 - WMM IE */
-					if (pos[4] == 0) {
-						elems->wmm_info = pos;
-						elems->wmm_info_len = elen;
-					} else if (pos[4] == 1) {
-						elems->wmm_param = pos;
-						elems->wmm_param_len = elen;
-					}
-				}
-			}
-			break;
-		case WLAN_EID_RSN:
-			elems->rsn = pos;
-			elems->rsn_len = elen;
-			break;
-		case WLAN_EID_ERP_INFO:
-			elems->erp_info = pos;
-			elems->erp_info_len = elen;
-			break;
-		case WLAN_EID_EXT_SUPP_RATES:
-			elems->ext_supp_rates = pos;
-			elems->ext_supp_rates_len = elen;
-			break;
-		case WLAN_EID_HT_CAPABILITY:
-			if (elen >= sizeof(struct ieee80211_ht_cap))
-				elems->ht_cap_elem = (void *)pos;
-			break;
-		case WLAN_EID_HT_INFORMATION:
-			if (elen >= sizeof(struct ieee80211_ht_info))
-				elems->ht_info_elem = (void *)pos;
-			break;
-		case WLAN_EID_MESH_ID:
-			elems->mesh_id = pos;
-			elems->mesh_id_len = elen;
-			break;
-		case WLAN_EID_MESH_CONFIG:
-			elems->mesh_config = pos;
-			elems->mesh_config_len = elen;
-			break;
-		case WLAN_EID_PEER_LINK:
-			elems->peer_link = pos;
-			elems->peer_link_len = elen;
-			break;
-		case WLAN_EID_PREQ:
-			elems->preq = pos;
-			elems->preq_len = elen;
-			break;
-		case WLAN_EID_PREP:
-			elems->prep = pos;
-			elems->prep_len = elen;
-			break;
-		case WLAN_EID_PERR:
-			elems->perr = pos;
-			elems->perr_len = elen;
-			break;
-		case WLAN_EID_CHANNEL_SWITCH:
-			elems->ch_switch_elem = pos;
-			elems->ch_switch_elem_len = elen;
-			break;
-		case WLAN_EID_QUIET:
-			if (!elems->quiet_elem) {
-				elems->quiet_elem = pos;
-				elems->quiet_elem_len = elen;
-			}
-			elems->num_of_quiet_elem++;
-			break;
-		case WLAN_EID_COUNTRY:
-			elems->country_elem = pos;
-			elems->country_elem_len = elen;
-			break;
-		case WLAN_EID_PWR_CONSTRAINT:
-			elems->pwr_constr_elem = pos;
-			elems->pwr_constr_elem_len = elen;
-			break;
-		case WLAN_EID_TIMEOUT_INTERVAL:
-			elems->timeout_int = pos;
-			elems->timeout_int_len = elen;
-			break;
-		default:
-			break;
-		}
-
-		left -= elen;
-		pos += elen;
-	}
-
-	return crc;
-}
-
-void rtllib_parse_elems(u8 *start, size_t len,
-			    struct ieee802_11_elems *elems)
-{
-	rtllib_parse_elems_crc(start, len, elems, 0, 0);
-}
-
-void ieee80211_scan_rx(struct rtllib_device *ieee, struct sk_buff *skb, struct rtllib_rx_stats *rx_status)
-{
-	struct rtllib_hdr_4addr *header = (struct rtllib_hdr_4addr *)skb->data ;
-	struct ieee80211_mgmt *mgmt;
-	struct ieee80211_bss *bss;
-	u8 *elements;
-	struct ieee80211_channel *channel;
-	size_t baselen;
-	int freq;
-	__le16 fc;
-	bool presp, beacon = false;
-	struct ieee802_11_elems elems;
-	s32 signal = 0;
-
-	if (skb->len < 2)
-		return;
-
-	mgmt = (struct ieee80211_mgmt *) skb->data;
-	fc = mgmt->frame_control;
-
-	if (skb->len < 24)
-		return;
-
-	presp = (WLAN_FC_GET_STYPE(header->frame_ctl) == RTLLIB_STYPE_PROBE_RESP);
-	if (presp) {
-		/* ignore ProbeResp to foreign address */
-		if (memcmp(mgmt->da, ieee->dev->dev_addr, ETH_ALEN))
-			return ;;
-
-		presp = true;
-		elements = mgmt->u.probe_resp.variable;
-		baselen = offsetof(struct ieee80211_mgmt, u.probe_resp.variable);
-	} else {
-		beacon =  (WLAN_FC_GET_STYPE(header->frame_ctl) == RTLLIB_STYPE_BEACON);
-		baselen = offsetof(struct ieee80211_mgmt, u.beacon.variable);
-		elements = mgmt->u.beacon.variable;
-	}
-
-	if (!presp && !beacon)
-		return;
-
-	if (baselen > skb->len)
-		return;
-
-	rtllib_parse_elems(elements, skb->len - baselen, &elems);
-
-	if (elems.ds_params && elems.ds_params_len == 1)
-		freq = rtllib_channel_to_frequency(elems.ds_params[0]);
-	else
-		return;
-
-	channel = rtllib_get_channel(ieee->wdev.wiphy, freq);
-
-	if (!channel || channel->flags & IEEE80211_CHAN_DISABLED)
-		return;
-
-		signal = rx_status->signal * 100;
-
-	bss = (void *)cfg80211_inform_bss_frame(ieee->wdev.wiphy, channel,
-						mgmt, skb->len, signal, GFP_ATOMIC);
-
-	return;
-}
-#endif
-
 static inline void rtllib_monitor_rx(struct rtllib_device *ieee,
 				struct sk_buff *skb,struct rtllib_rx_stats *rx_status,
 				size_t hdr_length)
@@ -499,7 +229,6 @@ rtllib_rx_frame_mgmt(struct rtllib_device *ieee, struct sk_buff *skb,
 	return 0;
 }
 
-#ifndef CONFIG_CFG_80211
 /* See IEEE 802.1H for LLC/SNAP encapsulation/decapsulation */
 /* Ethernet-II snap header (RFC1042 for most EtherTypes) */
 static unsigned char rfc1042_header[] =
@@ -508,7 +237,6 @@ static unsigned char rfc1042_header[] =
 static unsigned char bridge_tunnel_header[] =
 { 0xaa, 0xaa, 0x03, 0x00, 0x00, 0xf8 };
 /* No encapsulation header if EtherType < 0x600 (=length) */
-#endif
 
 /* Called by rtllib_rx_frame_decrypt */
 static int rtllib_is_eapol_frame(struct rtllib_device *ieee,

commit e11fd5132459f0b1b534faa15a0224723ecdafb0
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Wed Jul 13 22:01:59 2011 -0500

    staging: rtl8192e: Remove dead code associated with NOT_YET
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index d2659d2b69c4..f4f7ec509b3b 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -497,52 +497,6 @@ rtllib_rx_frame_mgmt(struct rtllib_device *ieee, struct sk_buff *skb,
 	dev_kfree_skb_any(skb);
 
 	return 0;
-
-#ifdef NOT_YET
-	if (ieee->iw_mode == IW_MODE_MASTER) {
-		printk(KERN_DEBUG "%s: Master mode not yet suppported.\n",
-		       ieee->dev->name);
-		return 0;
-/*
-  hostap_update_sta_ps(ieee, (struct hostap_rtllib_hdr_4addr *)
-  skb->data);*/
-	}
-
-	if (ieee->hostapd && type == RTLLIB_TYPE_MGMT) {
-		if (stype == WLAN_FC_STYPE_BEACON &&
-		    ieee->iw_mode == IW_MODE_MASTER) {
-			struct sk_buff *skb2;
-			/* Process beacon frames also in kernel driver to
-			 * update STA(AP) table statistics */
-			skb2 = skb_clone(skb, GFP_ATOMIC);
-			if (skb2)
-				hostap_rx(skb2->dev, skb2, rx_stats);
-		}
-
-		/* send management frames to the user space daemon for
-		 * processing */
-		ieee->apdevstats.rx_packets++;
-		ieee->apdevstats.rx_bytes += skb->len;
-		prism2_rx_80211(ieee->apdev, skb, rx_stats, PRISM2_RX_MGMT);
-		return 0;
-	}
-
-	    if (ieee->iw_mode == IW_MODE_MASTER) {
-		if (type != WLAN_FC_TYPE_MGMT && type != WLAN_FC_TYPE_CTRL) {
-			printk(KERN_DEBUG "%s: unknown management frame "
-			       "(type=0x%02x, stype=0x%02x) dropped\n",
-			       skb->dev->name, type, stype);
-			return -1;
-		}
-
-		hostap_rx(skb->dev, skb, rx_stats);
-		return 0;
-	}
-
-	printk(KERN_DEBUG "%s: hostap_rx_frame_mgmt: management frame "
-	       "received in non-Host AP mode\n", skb->dev->name);
-	return -1;
-#endif
 }
 
 #ifndef CONFIG_CFG_80211

commit 94114a5ad75c6c9dcc931170855d2a90eea53d97
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Wed Jul 13 18:47:44 2011 -0500

    staging: rtl8192e: Remove dead code associated with TCP_CSUM_OFFLOAD_RX
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index 10ec50cf58b6..d2659d2b69c4 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -846,15 +846,7 @@ void rtllib_indicate_packets(struct rtllib_device *ieee, struct rtllib_rxb** prx
 				sub_skb->dev = ieee->dev;
 				sub_skb->dev->stats.rx_packets++;
 				sub_skb->dev->stats.rx_bytes += sub_skb->len;
-#ifdef TCP_CSUM_OFFLOAD_RX
-				if ( prxb->tcp_csum_valid)
-					sub_skb->ip_summed = CHECKSUM_UNNECESSARY;
-				else
-					sub_skb->ip_summed = CHECKSUM_NONE;
-
-#else
 				sub_skb->ip_summed = CHECKSUM_NONE; /* 802.11 crc not sufficient */
-#endif
 				ieee->last_rx_ps_time = jiffies;
 				netif_rx(sub_skb);
 			}
@@ -1581,14 +1573,7 @@ void rtllib_rx_indicate_pkt_legacy(
 			sub_skb->dev = dev;
 			sub_skb->dev->stats.rx_packets++;
 			sub_skb->dev->stats.rx_bytes += sub_skb->len;
-#ifdef TCP_CSUM_OFFLOAD_RX
-			if ( rx_stats->tcp_csum_valid)
-				sub_skb->ip_summed = CHECKSUM_UNNECESSARY;
-			else
-				sub_skb->ip_summed = CHECKSUM_NONE;
-#else
 			sub_skb->ip_summed = CHECKSUM_NONE; /* 802.11 crc not sufficient */
-#endif
 			netif_rx(sub_skb);
 		}
 	}
@@ -1749,9 +1734,6 @@ int rtllib_rx_InfraAdhoc(struct rtllib_device *ieee, struct sk_buff *skb,
 	if (ieee->pHTInfo->bCurRxReorderEnable == false ||pTS == NULL || bToOtherSTA){
 		rtllib_rx_indicate_pkt_legacy(ieee, rx_stats, rxb, dst, src);
 	}else{
-#ifdef TCP_CSUM_OFFLOAD_RX
-		rxb->tcp_csum_valid = rx_stats->tcp_csum_valid;
-#endif
 		RxReorderIndicatePacket(ieee, rxb, pTS, SeqNum);
 	}
 

commit 2b259bd38fdfdf6a4103234172eafc13d7f774b6
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Wed Jul 13 09:35:45 2011 -0500

    staging: rtl8192e: Remove ifdefs that depend on ENABLE_DOT11D
    
    This configuration parameter is selected in the Makefile, thus the
    conditional code can be removed.
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index 7e0fabad64d4..10ec50cf58b6 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -43,9 +43,7 @@
 #include <linux/ctype.h>
 
 #include "rtllib.h"
-#ifdef ENABLE_DOT11D
 #include "dot11d.h"
-#endif
 
 #if defined CONFIG_CFG_80211
 #include <linux/crc32.h>
@@ -2074,7 +2072,6 @@ static const char *get_info_element_string(u16 id)
 }
 #endif
 
-#ifdef ENABLE_DOT11D
 static inline void rtllib_extract_country_ie(
 	struct rtllib_device *ieee,
 	struct rtllib_info_element *info_element,
@@ -2100,7 +2097,6 @@ static inline void rtllib_extract_country_ie(
 	}
 
 }
-#endif
 
 int rtllib_parse_info_param(struct rtllib_device *ieee,
 		struct rtllib_info_element *info_element,
@@ -2574,13 +2570,11 @@ int rtllib_parse_info_param(struct rtllib_device *ieee,
 			       "QoS Error need to parse QOS_PARAMETER IE\n");
 			break;
 
-#ifdef ENABLE_DOT11D
 		case MFIE_TYPE_COUNTRY:
 			RTLLIB_DEBUG_SCAN("MFIE_TYPE_COUNTRY: %d bytes\n",
 					     info_element->len);
 			rtllib_extract_country_ie(ieee, info_element, network, network->bssid);
 			break;
-#endif
 /* TODO */
 		default:
 			RTLLIB_DEBUG_MGMT
@@ -2717,10 +2711,8 @@ static inline int rtllib_network_init(
 	network->Turbo_Enable = 0;
 	network->SignalStrength = stats->SignalStrength;
 	network->RSSI = stats->SignalStrength;
-#ifdef ENABLE_DOT11D
 	network->CountryIeLen = 0;
 	memset(network->CountryIeBuf, 0, MAX_IE_LEN);
-#endif
 	HTInitializeBssDesc(&network->bssht);
 	if (stats->freq == RTLLIB_52GHZ_BAND) {
 		/* for A band (No DS info) */
@@ -2898,10 +2890,8 @@ static inline void update_network(struct rtllib_network *dst,
 	dst->RSSI = src->RSSI;
 	dst->Turbo_Enable = src->Turbo_Enable;
 
-#ifdef ENABLE_DOT11D
 	dst->CountryIeLen = src->CountryIeLen;
 	memcpy(dst->CountryIeBuf, src->CountryIeBuf, src->CountryIeLen);
-#endif
 
 	dst->bWithAironetIE = src->bWithAironetIE;
 	dst->bCkipSupported = src->bCkipSupported;

commit 34a7eb3db27f3bcb6e1544523e283a9bf6acfd0d
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Tue Jul 12 21:54:48 2011 -0500

    staging: rtl8192e: Remove dead code inside 'ifdef MERGE_TO_DO'
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index 96f824ba8129..7e0fabad64d4 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -894,9 +894,6 @@ rtllib_FlushRxTsPendingPkts(struct rtllib_device *ieee,	PRX_TS_RECORD pTS)
 	rtllib_indicate_packets(ieee, RfdArray, RfdCnt);
 
 	pTS->RxIndicateSeq = 0xffff;
-
-#ifdef MERGE_TO_DO
-#endif
 }
 
 

commit 8df91dae5d258ad72a666af32d54e20e29ead6fb
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Mon Jul 11 22:43:02 2011 -0500

    staging: rtl8192e: Remove dead code associated with RTL8192SU
    
    The vendor code will generate several different drivers.  Eliminate
    code used to generate code for the RTL8192SU devices.
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index e11d9a3d9ff6..96f824ba8129 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -1519,7 +1519,6 @@ int rtllib_rx_decrypt(
 }
 void rtllib_rx_check_leave_lps(struct rtllib_device *ieee, u8 unicast, u8 nr_subframes)
 {
-#if !defined(RTL8192SU) && !defined(RTL8192U)
 	if (unicast){
 
 		if ((ieee->state == RTLLIB_LINKED) /*&& !MgntInitAdapterInProgress(pMgntInfo)*/)
@@ -1532,7 +1531,6 @@ void rtllib_rx_check_leave_lps(struct rtllib_device *ieee, u8 unicast, u8 nr_sub
 			}
 		}
 	}
-#endif
 	ieee->last_rx_ps_time = jiffies;
 }
 void rtllib_rx_indicate_pkt_legacy(

commit 1e71e6d0cf764841cdf60dec4a40849ff41be75c
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Mon Jul 11 22:25:07 2011 -0500

    staging: rtl8192e: Remove dead code associated with RTL8192SE
    
    The vendor code will generate several different drivers. As the RTL8192SE
    is covered by a mac80211 driver in mainline, eliminate that code heere.
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index 4c3590b4a96a..e11d9a3d9ff6 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -1608,9 +1608,6 @@ int rtllib_rx_InfraAdhoc(struct rtllib_device *ieee, struct sk_buff *skb,
 	struct net_device *dev = ieee->dev;
 	struct rtllib_hdr_4addr *hdr = (struct rtllib_hdr_4addr *)skb->data;
 	struct rtllib_crypt_data *crypt = NULL;
-#if defined(RTL8192U) || defined(RTL8192SU) || defined(RTL8192SE)
-	struct sta_info * psta = NULL;
-#endif
 	struct rtllib_rxb* rxb = NULL;
 	PRX_TS_RECORD pTS = NULL;
 	u16 fc, sc, SeqNum = 0;
@@ -1695,14 +1692,6 @@ int rtllib_rx_InfraAdhoc(struct rtllib_device *ieee, struct sk_buff *skb,
 		}
 	}
 
-#if defined(RTL8192U) || defined(RTL8192SU) || defined(RTL8192SE)
-	if (ieee->iw_mode == IW_MODE_ADHOC){
-		psta = GetStaInfo(ieee, src);
-		if (NULL != psta)
-			psta->LastActiveTime = jiffies;
-	}
-#endif
-
 	/* Get crypt if encrypted */
 	ret = rtllib_rx_get_crypt(ieee, skb, &crypt, hdrlen);
 	if (ret == -1)
@@ -2935,231 +2924,6 @@ static inline int is_beacon(__le16 fc)
 	return (WLAN_FC_GET_STYPE(le16_to_cpu(fc)) == RTLLIB_STYPE_BEACON);
 }
 
-#if defined(RTL8192U) || defined(RTL8192SU) || defined(RTL8192SE)
-u8 AsocEntry_ComputeSum(u8 *paddr)
-{
-	u32 sum;
-
-	sum =	paddr[0]+
-			paddr[1]+
-			paddr[2]+
-			paddr[3]+
-			paddr[4]+
-			paddr[5];
-
-	return (u8)(sum % PEER_MAX_ASSOC);
-}
-u8 AsocEntry_AssignAvailableAID(struct rtllib_device *ieee, u8 *paddr)
-{
-	int		i;
-
-	for (i = 0; i < PEER_MAX_ASSOC; i++)
-	{
-		if (ieee->AvailableAIDTable[i] == 99)
-		{
-			ieee->AvailableAIDTable[i] = AsocEntry_ComputeSum(paddr);
-			return i+1;
-		}
-	}
-
-	return 1;
-}
-
-void InitStaInfo(struct rtllib_device *ieee,int index)
-{
-	int idx = index;
-	ieee->peer_assoc_list[idx]->StaDataRate = 0;
-	ieee->peer_assoc_list[idx]->StaSS = 0;
-	ieee->peer_assoc_list[idx]->RetryFrameCnt = 0;
-	ieee->peer_assoc_list[idx]->NoRetryFrameCnt = 0;
-	ieee->peer_assoc_list[idx]->LastRetryCnt = 0;
-	ieee->peer_assoc_list[idx]->LastNoRetryCnt = 0;
-	ieee->peer_assoc_list[idx]->AvgRetryRate = 0;
-	ieee->peer_assoc_list[idx]->LastRetryRate = 0;
-	ieee->peer_assoc_list[idx]->txRateIndex = 11;
-	ieee->peer_assoc_list[idx]->APDataRate = 0x2;
-	ieee->peer_assoc_list[idx]->ForcedDataRate = 0x2;
-
-}
-static u8 IsStaInfoExist(struct rtllib_device *ieee, u8 *addr)
-{
-	int k=0;
-	struct sta_info * psta = NULL;
-	u8 sta_idx = PEER_MAX_ASSOC;
-
-	for (k=0; k<PEER_MAX_ASSOC; k++)
-	{
-		psta = ieee->peer_assoc_list[k];
-		if (NULL != psta)
-		{
-			if (memcmp(addr, psta->macaddr, ETH_ALEN) == 0)
-			{
-				sta_idx = k;
-				break;
-			}
-		}
-	}
-	return sta_idx;
-}
-static u8 GetFreeStaInfoIdx(struct rtllib_device *ieee, u8 *addr)
-{
-	int k = 0;
-	while((ieee->peer_assoc_list[k] != NULL) && (k < PEER_MAX_ASSOC))
-		k++;
-	printk("%s: addr:"MAC_FMT" index: %d\n", __func__, MAC_ARG(addr), k);
-	return k;
-}
-struct sta_info *GetStaInfo(struct rtllib_device *ieee, u8 *addr)
-{
-	int k=0;
-	struct sta_info * psta = NULL;
-	struct sta_info * psta_find = NULL;
-
-	for (k=0; k<PEER_MAX_ASSOC; k++)
-	{
-		psta = ieee->peer_assoc_list[k];
-		if (NULL != psta)
-		{
-			if (memcmp(addr, psta->macaddr, ETH_ALEN) == 0)
-			{
-				psta_find = psta;
-				break;
-			}
-		}
-	}
-	return psta_find;
-}
-void DelStaInfoList(struct rtllib_device *ieee)
-{
-	int idx = 0;
-	struct sta_info * AsocEntry = NULL;
-
-	atomic_set(&ieee->AsocEntryNum, 0);
-	for (idx=0; idx<PEER_MAX_ASSOC; idx++){
-		AsocEntry = ieee->peer_assoc_list[idx];
-		if (NULL != AsocEntry){
-			kfree(AsocEntry);
-			ieee->peer_assoc_list[idx] = NULL;
-		}
-		ieee->AvailableAIDTable[idx] = 99;
-	}
-}
-void DelStaInfo(struct rtllib_device *ieee, u8 *addr)
-{
-	struct sta_info * psta = NULL;
-	int k=0;
-
-	for (k=0; k<PEER_MAX_ASSOC; k++)
-	{
-		psta = ieee->peer_assoc_list[k];
-		if (NULL != psta){
-			if (memcmp(addr, psta->macaddr, ETH_ALEN) == 0){
-				if (psta->aid > 0 && psta->aid-1 < PEER_MAX_ASSOC)
-					ieee->AvailableAIDTable[psta->aid-1] = 99;
-				else
-					printk("%s(): clear non-existing entry AID\n", __func__);
-
-				kfree(psta);
-				ieee->peer_assoc_list[k] = NULL;
-				atomic_dec(&ieee->AsocEntryNum);
-			}
-		}
-	}
-}
-void IbssAgeFunction(struct rtllib_device *ieee)
-{
-	struct sta_info*	AsocEntry = NULL;
-	int				idx;
-	unsigned long		CurrentTime;
-	signed long		TimeDifference;
-	struct rtllib_network *target;
-
-	CurrentTime = jiffies;
-
-	for (idx = 0; idx < PEER_MAX_ASSOC; idx++)
-	{
-		AsocEntry = ieee->peer_assoc_list[idx];
-		if (AsocEntry)
-		{
-			TimeDifference = jiffies_to_msecs(CurrentTime - AsocEntry->LastActiveTime);
-
-			if (TimeDifference > 20000)
-			{
-				printk("IbssAgeFunction(): "MAC_FMT" timeout\n", MAC_ARG(AsocEntry->macaddr));
-				kfree(AsocEntry);
-				ieee->peer_assoc_list[idx] = NULL;
-				atomic_dec(&ieee->AsocEntryNum);
-
-				if (atomic_read(&ieee->AsocEntryNum) == 0){
-
-					down(&ieee->wx_sem);
-					rtllib_stop_protocol(ieee,true);
-
-					list_for_each_entry(target, &ieee->network_list, list) {
-						if (is_same_network(target, &ieee->current_network,(target->ssid_len?1:0))){
-							printk("delete sta of previous Ad-hoc\n");
-							list_del(&target->list);
-							break;
-						}
-					}
-
-					rtllib_start_protocol(ieee);
-					up(&ieee->wx_sem);
-				}
-			}
-		}
-	}
-
-#ifdef TO_DO_LIST
-	if (AsocEntry_AnyStationAssociated(pMgntInfo)==false)
-		DrvIFIndicateDisassociation(Adapter, unspec_reason);
-
-	if (pMgntInfo->dot11CurrentWirelessMode == WIRELESS_MODE_G ||
-		(IS_WIRELESS_MODE_N_24G(Adapter) && pMgntInfo->pHTInfo->bCurSuppCCK)	)
-	{
-		if (nBModeStaCnt == 0)
-		{
-			pMgntInfo->bUseProtection = false;
-			ActUpdate_mCapInfo(Adapter, pMgntInfo->mCap);
-		}
-	}
-
-	if (IS_WIRELESS_MODE_N_24G(Adapter) || IS_WIRELESS_MODE_N_5G(Adapter) )
-	{
-		if (nLegacyStaCnt > 0)
-		{
-			pMgntInfo->pHTInfo->CurrentOpMode = HT_OPMODE_MIXED;
-		}
-		else
-		{
-			if ((pMgntInfo->pHTInfo->bCurBW40MHz) && (n20MHzStaCnt > 0))
-				pMgntInfo->pHTInfo->CurrentOpMode = HT_OPMODE_40MHZ_PROTECT;
-			else
-				pMgntInfo->pHTInfo->CurrentOpMode = HT_OPMODE_NO_PROTECT;
-
-		}
-	}
-
-	if (IS_WIRELESS_MODE_G(Adapter) ||
-		(IS_WIRELESS_MODE_N_24G(Adapter) && pMgntInfo->pHTInfo->bCurSuppCCK))
-	{
-		if (pMgntInfo->bUseProtection)
-		{
-			u8 CckRate[4] = { MGN_1M, MGN_2M, MGN_5_5M, MGN_11M };
-			OCTET_STRING osCckRate;
-			FillOctetString(osCckRate, CckRate, 4);
-			FilterSupportRate(pMgntInfo->mBrates, &osCckRate, false);
-			Adapter->HalFunc.SetHwRegHandler(Adapter, HW_VAR_BASIC_RATE, (pu1Byte)&osCckRate);
-		}
-		else
-		{
-			Adapter->HalFunc.SetHwRegHandler( Adapter, HW_VAR_BASIC_RATE, (pu1Byte)(&pMgntInfo->mBrates) );
-		}
-	}
-#endif
-}
-#endif
-
 static int IsPassiveChannel( struct rtllib_device *rtllib, u8 channel)
 {
 	if (MAX_CHANNEL_NUMBER < channel) {
@@ -3258,76 +3022,6 @@ static inline void rtllib_process_probe_response(
 	 * already there. */
 
 	spin_lock_irqsave(&ieee->lock, flags);
-#if defined(RTL8192U) || defined(RTL8192SU) || defined(RTL8192SE)
-	if (is_beacon(beacon->header.frame_ctl)){
-		if ((ieee->iw_mode == IW_MODE_ADHOC) && (ieee->state == RTLLIB_LINKED))
-		{
-			if ((network->ssid_len == ieee->current_network.ssid_len)
-				&& (!memcmp(network->ssid,ieee->current_network.ssid,ieee->current_network.ssid_len))
-				&& (network->channel == ieee->current_network.channel)
-				&& (ieee->current_network.channel > 0)
-				&& (ieee->current_network.channel <= 14))
-			{
-				if (!memcmp(ieee->current_network.bssid,network->bssid,6))
-				{
-					int idx = 0;
-					struct rtllib_hdr_3addr* header = NULL;
-					int idx_exist = 0;
-					if (timer_pending(&ieee->ibss_wait_timer))
-						del_timer_sync(&ieee->ibss_wait_timer);
-					header = (struct rtllib_hdr_3addr*)&(beacon->header);
-					idx_exist = IsStaInfoExist(ieee,header->addr2);
-					if (idx_exist >= PEER_MAX_ASSOC) {
-						idx = GetFreeStaInfoIdx(ieee, header->addr2);
-					} else {
-						ieee->peer_assoc_list[idx_exist]->LastActiveTime = jiffies;
-						goto no_alloc;
-					}
-					if (idx >= PEER_MAX_ASSOC - 1) {
-						printk("\n%s():ERR!!!Buffer overflow - could not append!!!",__func__);
-						goto free_network;
-					} else {
-						ieee->peer_assoc_list[idx] = (struct sta_info *)kmalloc(sizeof(struct sta_info), GFP_ATOMIC);
-						memset(ieee->peer_assoc_list[idx], 0, sizeof(struct sta_info));
-						ieee->peer_assoc_list[idx]->LastActiveTime = jiffies;
-						memcpy(ieee->peer_assoc_list[idx]->macaddr,header->addr2,ETH_ALEN);
-						ieee->peer_assoc_list[idx]->ratr_index = 8;
-						InitStaInfo(ieee,idx);
-						atomic_inc(&ieee->AsocEntryNum);
-						ieee->peer_assoc_list[idx]->aid = AsocEntry_AssignAvailableAID(ieee, ieee->peer_assoc_list[idx]->macaddr);
-						ieee->check_ht_cap(ieee->dev,ieee->peer_assoc_list[idx],network);
-						queue_delayed_work_rsl(ieee->wq, &ieee->update_assoc_sta_info_wq, 0);
-						ieee->Adhoc_InitRateAdaptive(ieee->dev,ieee->peer_assoc_list[idx]);
-					}
-				}
-			}
-		}
-	}
-	if (ieee->iw_mode == IW_MODE_ADHOC){
-		if ((network->ssid_len == ieee->current_network.ssid_len)
-			&& (!memcmp(network->ssid,ieee->current_network.ssid,ieee->current_network.ssid_len))
-			&& (network->capability & WLAN_CAPABILITY_IBSS)
-			&& (ieee->state == RTLLIB_LINKED_SCANNING))
-		{
-			if (memcmp(ieee->current_network.bssid,network->bssid,6))
-			{
-				printk("%s(): SSID matched but BSSID mismatched.\n",__func__);
-
-				ieee->TargetTsf = beacon->time_stamp[1];
-				ieee->TargetTsf <<= 32;
-				ieee->TargetTsf |= beacon->time_stamp[0];
-
-				ieee->CurrTsf = stats->TimeStampLow;
-
-				queue_delayed_work_rsl(ieee->wq, &ieee->check_tsf_wq, 0);
-			}
-		}
-	}
-#endif
-#if defined(RTL8192U) || defined(RTL8192SU) || defined(RTL8192SE)
-no_alloc:
-	if (ieee->iw_mode == IW_MODE_INFRA)
-#endif
 	{
 		if (is_same_network(&ieee->current_network, network, (network->ssid_len?1:0))) {
 			update_network(&ieee->current_network, network);
@@ -3345,14 +3039,6 @@ static inline void rtllib_process_probe_response(
 			}
 		}
 	}
-#if defined(RTL8192U) || defined(RTL8192SU) || defined(RTL8192SE)
-	else if (ieee->iw_mode == IW_MODE_ADHOC)
-	{
-		if (is_same_network(&ieee->current_network, network, (network->ssid_len?1:0))) {
-			update_ibss_network(&ieee->current_network, network);
-		}
-	}
-#endif
 	list_for_each_entry(target, &ieee->network_list, list) {
 		if (is_same_network(target, network,(target->ssid_len?1:0)))
 			break;

commit 4f6807e8d2e972393009830d305ecec2d80c0449
Author: Mike McCormack <mikem@ring3k.org>
Date:   Mon Jul 11 08:56:20 2011 +0900

    rtl8192e: Remove occurences of #if 1
    
    Signed-off-by: Mike McCormack <mikem@ring3k.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index 9d8b2770b0ee..4c3590b4a96a 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -608,7 +608,7 @@ rtllib_rx_frame_decrypt(struct rtllib_device* ieee, struct sk_buff *skb,
 
 	if (crypt == NULL || crypt->ops->decrypt_mpdu == NULL)
 		return 0;
-#if 1
+
 	if (ieee->hwsec_active)
 	{
 		cb_desc *tcb_desc = (cb_desc *)(skb->cb+ MAX_DEV_ADDR_SIZE);
@@ -617,7 +617,7 @@ rtllib_rx_frame_decrypt(struct rtllib_device* ieee, struct sk_buff *skb,
 		if (ieee->need_sw_enc)
 			tcb_desc->bHwSec = 0;
 	}
-#endif
+
 	hdr = (struct rtllib_hdr_4addr *) skb->data;
 	hdrlen = rtllib_get_hdrlen(le16_to_cpu(hdr->frame_ctl));
 
@@ -983,7 +983,6 @@ void RxReorderIndicatePacket( struct rtllib_device *ieee,
 			pReorderEntry->SeqNum = SeqNum;
 			pReorderEntry->prxb = prxb;
 
-#if 1
 			if (!AddReorderEntry(pTS, pReorderEntry)) {
 				RTLLIB_DEBUG(RTLLIB_DL_REORDER, "%s(): Duplicate packet is dropped!! IndicateSeq: %d, NewSeq: %d\n",
 					__func__, pTS->RxIndicateSeq, SeqNum);
@@ -1000,7 +999,6 @@ void RxReorderIndicatePacket( struct rtllib_device *ieee,
 				RTLLIB_DEBUG(RTLLIB_DL_REORDER,
 					 "Pkt insert into buffer!! IndicateSeq: %d, NewSeq: %d\n",pTS->RxIndicateSeq, SeqNum);
 			}
-#endif
 		}
 		else {
 			/*
@@ -1023,7 +1021,7 @@ void RxReorderIndicatePacket( struct rtllib_device *ieee,
 	/* Check if there is any packet need indicate.*/
 	while(!list_empty(&pTS->RxPendingPktList)) {
 		RTLLIB_DEBUG(RTLLIB_DL_REORDER,"%s(): start RREORDER indicate\n",__func__);
-#if 1
+
 		pReorderEntry = (PRX_REORDER_ENTRY)list_entry(pTS->RxPendingPktList.prev,RX_REORDER_ENTRY,List);
 		if ( SN_LESS(pReorderEntry->SeqNum, pTS->RxIndicateSeq) ||
 				SN_EQUAL(pReorderEntry->SeqNum, pTS->RxIndicateSeq))
@@ -1049,7 +1047,6 @@ void RxReorderIndicatePacket( struct rtllib_device *ieee,
 			bPktInBuf = true;
 			break;
 		}
-#endif
 	}
 
 	/* Handling pending timer. Set this timer to prevent from long time Rx buffering.*/
@@ -1831,7 +1828,6 @@ int rtllib_rx_Mesh(struct rtllib_device *ieee, struct sk_buff *skb,
 	return 0;
 }
 
-#if 1
 /* All received frames are sent to this function. @skb contains the frame in
  * IEEE 802.11 format, i.e., in the format it was sent over air.
  * This function is called only as a tasklet (software IRQ). */
@@ -1875,595 +1871,6 @@ int rtllib_rx(struct rtllib_device *ieee, struct sk_buff *skb,
 	ieee->stats.rx_dropped++;
 	return 0;
 }
-#else
-int rtllib_rx(struct rtllib_device *ieee, struct sk_buff *skb,
-		 struct rtllib_rx_stats *rx_stats)
-{
-	struct net_device *dev = ieee->dev;
-	struct rtllib_hdr_4addr *hdr;
-	size_t hdrlen;
-	u16 fc, type, stype, sc;
-	struct net_device_stats *stats = NULL;
-	unsigned int frag;
-	u8 *payload;
-	u16 ethertype;
-	u8	TID = 0;
-	u16	SeqNum = 0;
-	PRX_TS_RECORD pTS = NULL;
-#ifdef NOT_YET
-	struct net_device *wds = NULL;
-	struct sk_buff *skb2 = NULL;
-	struct net_device *wds = NULL;
-	int frame_authorized = 0;
-	int from_assoc_ap = 0;
-	void *sta = NULL;
-#endif
-	u8 dst[ETH_ALEN];
-	u8 src[ETH_ALEN];
-	u8 bssid[ETH_ALEN] = {0};
-	u8 zero_addr[ETH_ALEN] = {0};
-	struct rtllib_crypt_data *crypt = NULL;
-	int keyidx = 0;
-#if defined(RTL8192U) || defined(RTL8192SU) || defined(RTL8192SE)
-	struct sta_info * psta = NULL;
-#endif
-	bool unicast_packet = false;
-	int i;
-	struct rtllib_rxb* rxb = NULL;
-	int multicast = 0;
-	bool tmp_dump = false;
-	bool bToOtherSTA = false;
-	hdr = (struct rtllib_hdr_4addr *)skb->data;
-	stats = &ieee->stats;
-
-	multicast = is_multicast_ether_addr(hdr->addr1)|is_broadcast_ether_addr(hdr->addr1);
-	if (!multicast && (compare_ether_addr(dev->dev_addr, hdr->addr1) != 0)) {
-		if ((ieee->iw_mode == IW_MODE_MONITOR) || ieee->bNetPromiscuousMode){
-			bToOtherSTA = true;
-		}else{
-			goto rx_dropped;
-		}
-	}
-
-	fc = le16_to_cpu(hdr->frame_ctl);
-	type = WLAN_FC_GET_TYPE(fc);
-	stype = WLAN_FC_GET_STYPE(fc);
-	sc = le16_to_cpu(hdr->seq_ctl);
-	frag = WLAN_GET_SEQ_FRAG(sc);
-
-	ieee->need_sw_enc = 0;
-
-	hdrlen = rtllib_get_hdrlen(fc);
-	if (skb->len < hdrlen){
-		printk("%s():ERR!!! skb->len is smaller than hdrlen\n",__func__);
-		goto rx_dropped;
-	}
-
-	if (HTCCheck(ieee, skb->data)) {
-		if (net_ratelimit())
-			printk("find HTCControl\n");
-		hdrlen += 4;
-		rx_stats->bContainHTC = 1;
-	}
-	if (RTLLIB_QOS_HAS_SEQ(fc))
-		rx_stats->bIsQosData = 1;
-	if ((0) && (type == RTLLIB_FTYPE_DATA) && ((is_broadcast_ether_addr(hdr->addr1)) || (compare_ether_addr(dev->dev_addr, hdr->addr1) == 0))) {
-		printk("===>RX data before decrypt\n");
-		tmp_dump = true;
-		dump_buf(skb->data,skb->len);
-	}
-#ifdef NOT_YET
-	hostap_update_rx_stats(local->ap, hdr, rx_stats);
-#endif
-
-	if (ieee->host_decrypt) {
-		int idx = 0;
-		if (skb->len >= hdrlen + 3)
-			idx = skb->data[hdrlen + 3] >> 6;
-		crypt = ieee->crypt[idx];
-#ifdef NOT_YET
-		sta = NULL;
-
-		/* Use station specific key to override default keys if the
-		 * receiver address is a unicast address ("individual RA"). If
-		 * bcrx_sta_key parameter is set, station specific key is used
-		 * even with broad/multicast targets (this is against IEEE
-		 * 802.11, but makes it easier to use different keys with
-		 * stations that do not support WEP key mapping). */
-
-		if (!(hdr->addr1[0] & 0x01) || local->bcrx_sta_key)
-			(void) hostap_handle_sta_crypto(local, hdr, &crypt,
-							&sta);
-#endif
-
-		/* allow NULL decrypt to indicate an station specific override
-		 * for default encryption */
-		if (crypt && (crypt->ops == NULL ||
-			      crypt->ops->decrypt_mpdu == NULL))
-			crypt = NULL;
-
-		if (!crypt && (fc & RTLLIB_FCTL_WEP)) {
-			/* This seems to be triggered by some (multicast?)
-			 * frames from other than current BSS, so just drop the
-			 * frames silently instead of filling system log with
-			 * these reports. */
-			RTLLIB_DEBUG_DROP("Decryption failed (not set)"
-					     " (SA=" MAC_FMT ")\n",
-					     MAC_ARG(hdr->addr2));
-			ieee->ieee_stats.rx_discards_undecryptable++;
-			goto rx_dropped;
-		}
-	}
-
-	if (skb->len < RTLLIB_DATA_HDR3_LEN)
-		goto rx_dropped;
-
-	if ( (ieee->pHTInfo->bCurRxReorderEnable == false) ||
-		!ieee->current_network.qos_data.active ||
-		!IsDataFrame(skb->data) ||
-		IsLegacyDataFrame(skb->data)) {
-		if (!((type == RTLLIB_FTYPE_MGMT) && (stype == RTLLIB_STYPE_BEACON))){
-			if (is_duplicate_packet(ieee, hdr)){
-				goto rx_dropped;
-			}
-		}
-	} else {
-		PRX_TS_RECORD pRxTS = NULL;
-		if (GetTs(ieee, (PTS_COMMON_INFO*) &pRxTS, hdr->addr2,
-			(u8)Frame_QoSTID((u8*)(skb->data)), RX_DIR, true)) {
-			if ((fc & (1<<11)) && (frag == pRxTS->RxLastFragNum) &&
-			    (WLAN_GET_SEQ_SEQ(sc) == pRxTS->RxLastSeqNum)) {
-				goto rx_dropped;
-			} else {
-				pRxTS->RxLastFragNum = frag;
-				pRxTS->RxLastSeqNum = WLAN_GET_SEQ_SEQ(sc);
-			}
-		} else {
-			RTLLIB_DEBUG(RTLLIB_DL_ERR, "ERR!!%s(): No TS!! Skip the check!!\n",__func__);
-			goto rx_dropped;
-		}
-	}
-	if (type == RTLLIB_FTYPE_MGMT) {
-		if (bToOtherSTA)
-			goto rx_dropped;
-		if (rtllib_rx_frame_mgmt(ieee, skb, rx_stats, type, stype))
-			goto rx_dropped;
-		else
-			goto rx_exit;
-	}
-	if (type == RTLLIB_FTYPE_CTL) {
-		goto rx_dropped;
-	}
-	/* Data frame - extract src/dst addresses */
-	switch (fc & (RTLLIB_FCTL_FROMDS | RTLLIB_FCTL_TODS)) {
-	case RTLLIB_FCTL_FROMDS:
-		memcpy(dst, hdr->addr1, ETH_ALEN);
-		memcpy(src, hdr->addr3, ETH_ALEN);
-		memcpy(bssid, hdr->addr2, ETH_ALEN);
-		break;
-	case RTLLIB_FCTL_TODS:
-		memcpy(dst, hdr->addr3, ETH_ALEN);
-		memcpy(src, hdr->addr2, ETH_ALEN);
-		memcpy(bssid, hdr->addr1, ETH_ALEN);
-		break;
-	case RTLLIB_FCTL_FROMDS | RTLLIB_FCTL_TODS:
-		if (skb->len < RTLLIB_DATA_HDR4_LEN)
-			goto rx_dropped;
-		memcpy(dst, hdr->addr3, ETH_ALEN);
-		memcpy(src, hdr->addr4, ETH_ALEN);
-		memcpy(bssid, ieee->current_network.bssid, ETH_ALEN);
-		break;
-	case 0:
-		memcpy(dst, hdr->addr1, ETH_ALEN);
-		memcpy(src, hdr->addr2, ETH_ALEN);
-		memcpy(bssid, hdr->addr3, ETH_ALEN);
-		break;
-	}
-
-	/* Filter frames from different BSS */
-	if ((type != RTLLIB_FTYPE_CTL) && ((fc & RTLLIB_FCTL_DSTODS) != RTLLIB_FCTL_DSTODS)
-                && (compare_ether_addr(ieee->current_network.bssid, bssid) != 0) && memcmp(ieee->current_network.bssid, zero_addr, ETH_ALEN)) {
-		goto rx_dropped;
-	}
-
-	/* Filter packets sent by an STA that will be forwarded by AP */
-	if ( ieee->IntelPromiscuousModeInfo.bPromiscuousOn  &&
-                ieee->IntelPromiscuousModeInfo.bFilterSourceStationFrame ) {
-		if ((fc & RTLLIB_FCTL_TODS) && !(fc & RTLLIB_FCTL_FROMDS) &&
-			(compare_ether_addr(dst, ieee->current_network.bssid) != 0) &&
-			(compare_ether_addr(bssid, ieee->current_network.bssid) == 0)) {
-			goto rx_dropped;
-		}
-	}
-
-#ifdef NOT_YET
-	if (hostap_rx_frame_wds(ieee, hdr, fc, &wds))
-		goto rx_dropped;
-	if (wds) {
-		skb->dev = dev = wds;
-		stats = hostap_get_stats(dev);
-	}
-
-	if (ieee->iw_mode == IW_MODE_MASTER && !wds &&
-	    (fc & (RTLLIB_FCTL_TODS | RTLLIB_FCTL_FROMDS)) == RTLLIB_FCTL_FROMDS &&
-	    ieee->stadev &&
-	    memcmp(hdr->addr2, ieee->assoc_ap_addr, ETH_ALEN) == 0) {
-		/* Frame from BSSID of the AP for which we are a client */
-		skb->dev = dev = ieee->stadev;
-		stats = hostap_get_stats(dev);
-		from_assoc_ap = 1;
-	}
-#endif
-
-	dev->last_rx = jiffies;
-
-#ifdef NOT_YET
-	if ((ieee->iw_mode == IW_MODE_MASTER ||
-	     ieee->iw_mode == IW_MODE_REPEAT) &&
-	    !from_assoc_ap) {
-		switch (hostap_handle_sta_rx(ieee, dev, skb, rx_stats,
-					     wds != NULL)) {
-		case AP_RX_CONTINUE_NOT_AUTHORIZED:
-			frame_authorized = 0;
-			break;
-		case AP_RX_CONTINUE:
-			frame_authorized = 1;
-			break;
-		case AP_RX_DROP:
-			goto rx_dropped;
-		case AP_RX_EXIT:
-			goto rx_exit;
-		}
-	}
-#endif
-	/* Nullfunc frames may have PS-bit set, so they must be passed to
-	 * hostap_handle_sta_rx() before being dropped here. */
-	if (stype != RTLLIB_STYPE_DATA &&
-	    stype != RTLLIB_STYPE_DATA_CFACK &&
-	    stype != RTLLIB_STYPE_DATA_CFPOLL &&
-	    stype != RTLLIB_STYPE_DATA_CFACKPOLL&&
-	    stype != RTLLIB_STYPE_QOS_DATA
-	    ) {
-		if (stype != RTLLIB_STYPE_NULLFUNC)
-			RTLLIB_DEBUG_DROP(
-				"RX: dropped data frame "
-				"with no data (type=0x%02x, "
-				"subtype=0x%02x, len=%d)\n",
-				type, stype, skb->len);
-		goto rx_dropped;
-	}
-
-	if (skb->len == hdrlen){
-		goto rx_dropped;
-	}
-
-	{
-		/* network filter more precisely */
-		switch (ieee->iw_mode) {
-		case IW_MODE_ADHOC:
-			/* packets from our adapter are dropped (echo) */
-			if (!memcmp(hdr->addr2, dev->dev_addr, ETH_ALEN))
-				goto rx_dropped;
-
-			/* {broad,multi}cast packets to our BSSID go through */
-			if (is_multicast_ether_addr(hdr->addr1)) {
-				if (!memcmp(hdr->addr3, ieee->current_network.bssid, ETH_ALEN))
-					break;
-				else
-					goto rx_dropped;
-			}
-
-			/* packets not to our adapter, just discard it */
-			if (memcmp(hdr->addr1, dev->dev_addr, ETH_ALEN)) {
-				if (bToOtherSTA)
-					break;
-				else
-					goto rx_dropped;
-			}
-
-			break;
-
-		case IW_MODE_INFRA:
-			/* packets from our adapter are dropped (echo) */
-			if (!memcmp(hdr->addr3, dev->dev_addr, ETH_ALEN))
-				goto rx_dropped;
-
-			/* {broad,multi}cast packets to our BSS go through */
-			if (is_multicast_ether_addr(hdr->addr1)) {
-				if (!memcmp(hdr->addr2, ieee->current_network.bssid, ETH_ALEN))
-					break;
-				else
-					goto rx_dropped;
-			}
-
-			/* packets to our adapter go through */
-			if (memcmp(hdr->addr1, dev->dev_addr, ETH_ALEN)) {
-				if (bToOtherSTA)
-					break;
-				else
-					goto rx_dropped;
-			}
-
-			break;
-		}
-
-
-	}
-
-	if ((ieee->iw_mode == IW_MODE_INFRA)  && (ieee->sta_sleep == LPS_IS_SLEEP)
-		&& (ieee->polling)) {
-		if (WLAN_FC_MORE_DATA(fc)) {
-			/* more data bit is set, let's request a new frame from the AP */
-			rtllib_sta_ps_send_pspoll_frame(ieee);
-		} else {
-			ieee->polling =  false;
-		}
-	}
-
-#if defined(RTL8192U) || defined(RTL8192SU) || defined(RTL8192SE)
-	if (ieee->iw_mode == IW_MODE_ADHOC){
-		psta = GetStaInfo(ieee, src);
-		if (NULL != psta)
-			psta->LastActiveTime = jiffies;
-	}
-#endif
-	/* skb: hdr + (possibly fragmented, possibly encrypted) payload */
-	if ((!rx_stats->Decrypted)){
-		ieee->need_sw_enc = 1;
-	}
-
-	if (ieee->host_decrypt && (fc & RTLLIB_FCTL_WEP) &&
-	    ((keyidx = rtllib_rx_frame_decrypt(ieee, skb, crypt)) < 0)) {
-		printk("decrypt frame error\n");
-		goto rx_dropped;
-	}
-	if (tmp_dump) {
-		printk("************after decrypt\n");
-		dump_buf(skb->data,skb->len);
-	}
-	hdr = (struct rtllib_hdr_4addr *) skb->data;
-
-	/* skb: hdr + (possibly fragmented) plaintext payload */
-	if ((frag != 0 || (fc & RTLLIB_FCTL_MOREFRAGS))) {
-		int flen;
-		struct sk_buff *frag_skb = rtllib_frag_cache_get(ieee, hdr);
-		RTLLIB_DEBUG_FRAG("Rx Fragment received (%u)\n", frag);
-
-		if (!frag_skb) {
-			RTLLIB_DEBUG(RTLLIB_DL_RX | RTLLIB_DL_FRAG,
-					"Rx cannot get skb from fragment "
-					"cache (morefrag=%d seq=%u frag=%u)\n",
-					(fc & RTLLIB_FCTL_MOREFRAGS) != 0,
-					WLAN_GET_SEQ_SEQ(sc), frag);
-			goto rx_dropped;
-		}
-		flen = skb->len;
-		if (frag != 0)
-			flen -= hdrlen;
-
-		if (frag_skb->tail + flen > frag_skb->end) {
-			printk(KERN_WARNING "%s: host decrypted and "
-			       "reassembled frame did not fit skb\n",
-			       dev->name);
-			rtllib_frag_cache_invalidate(ieee, hdr);
-			goto rx_dropped;
-		}
-
-		if (frag == 0) {
-			/* copy first fragment (including full headers) into
-			 * beginning of the fragment cache skb */
-			memcpy(skb_put(frag_skb, flen), skb->data, flen);
-		} else {
-			/* append frame payload to the end of the fragment
-			 * cache skb */
-			memcpy(skb_put(frag_skb, flen), skb->data + hdrlen,
-			       flen);
-		}
-		dev_kfree_skb_any(skb);
-		skb = NULL;
-
-		if (fc & RTLLIB_FCTL_MOREFRAGS) {
-			/* more fragments expected - leave the skb in fragment
-			 * cache for now; it will be delivered to upper layers
-			 * after all fragments have been received */
-			goto rx_exit;
-		}
-
-		/* this was the last fragment and the frame will be
-		 * delivered, so remove skb from fragment cache */
-		skb = frag_skb;
-		hdr = (struct rtllib_hdr_4addr *) skb->data;
-		rtllib_frag_cache_invalidate(ieee, hdr);
-	}
-
-	/* skb: hdr + (possible reassembled) full MSDU payload; possibly still
-	 * encrypted/authenticated */
-	if (ieee->host_decrypt && (fc & RTLLIB_FCTL_WEP) &&
-	    rtllib_rx_frame_decrypt_msdu(ieee, skb, keyidx, crypt)) {
-		printk("==>decrypt msdu error\n");
-		goto rx_dropped;
-	}
-
-	ieee->LinkDetectInfo.NumRecvDataInPeriod++;
-	ieee->LinkDetectInfo.NumRxOkInPeriod++;
-
-	hdr = (struct rtllib_hdr_4addr *) skb->data;
-	if ((!is_multicast_ether_addr(hdr->addr1)) && (!is_broadcast_ether_addr(hdr->addr1)))
-		unicast_packet = true;
-	if (crypt && !(fc & RTLLIB_FCTL_WEP) && !ieee->open_wep) {
-		if (/*ieee->ieee802_1x &&*/
-		    rtllib_is_eapol_frame(ieee, skb, hdrlen)) {
-
-#ifdef CONFIG_RTLLIB_DEBUG
-			/* pass unencrypted EAPOL frames even if encryption is
-			 * configured */
-			struct eapol *eap = (struct eapol *)(skb->data +
-				24);
-			RTLLIB_DEBUG_EAP("RX: IEEE 802.1X EAPOL frame: %s\n",
-						eap_get_type(eap->type));
-#endif
-		} else {
-			RTLLIB_DEBUG_DROP(
-				"encryption configured, but RX "
-				"frame not encrypted (SA=" MAC_FMT ")\n",
-				MAC_ARG(hdr->addr2));
-			goto rx_dropped;
-		}
-	}
-
-#ifdef CONFIG_RTLLIB_DEBUG
-	if (crypt && !(fc & RTLLIB_FCTL_WEP) &&
-	    rtllib_is_eapol_frame(ieee, skb, hdrlen)) {
-			struct eapol *eap = (struct eapol *)(skb->data +
-				24);
-			RTLLIB_DEBUG_EAP("RX: IEEE 802.1X EAPOL frame: %s\n",
-						eap_get_type(eap->type));
-	}
-#endif
-
-	if (crypt && !(fc & RTLLIB_FCTL_WEP) && !ieee->open_wep &&
-	    !rtllib_is_eapol_frame(ieee, skb, hdrlen)) {
-		RTLLIB_DEBUG_DROP(
-			"dropped unencrypted RX data "
-			"frame from " MAC_FMT
-			" (drop_unencrypted=1)\n",
-			MAC_ARG(hdr->addr2));
-		goto rx_dropped;
-	}
-	if (ieee->current_network.qos_data.active && IsQoSDataFrame(skb->data)
-	    && !is_multicast_ether_addr(hdr->addr1) && !is_broadcast_ether_addr(hdr->addr1)) {
-		TID = Frame_QoSTID(skb->data);
-		SeqNum = WLAN_GET_SEQ_SEQ(sc);
-		GetTs(ieee,(PTS_COMMON_INFO*) &pTS,hdr->addr2,TID,RX_DIR,true);
-		if (TID !=0 && TID !=3)
-			ieee->bis_any_nonbepkts = true;
-	}
-	/* skb: hdr + (possible reassembled) full plaintext payload */
-	payload = skb->data + hdrlen;
-	rxb = (struct rtllib_rxb*)kmalloc(sizeof(struct rtllib_rxb),GFP_ATOMIC);
-	if (rxb == NULL) {
-		RTLLIB_DEBUG(RTLLIB_DL_ERR,"%s(): kmalloc rxb error\n",__func__);
-		goto rx_dropped;
-	}
-	/* to parse amsdu packets */
-	/* qos data packets & reserved bit is 1 */
-	if (parse_subframe(ieee,skb,rx_stats,rxb,src,dst) == 0) {
-		/* only to free rxb, and not submit the packets to upper layer */
-		for (i =0; i < rxb->nr_subframes; i++) {
-			dev_kfree_skb(rxb->subframes[i]);
-		}
-		kfree(rxb);
-		rxb = NULL;
-		goto rx_dropped;
-	}
-#if !defined(RTL8192SU) && !defined(RTL8192U)
-		if (unicast_packet) {
-			if (type == RTLLIB_FTYPE_DATA) {
-				if (ieee->bIsAggregateFrame)
-					ieee->LinkDetectInfo.NumRxUnicastOkInPeriod+=rxb->nr_subframes;
-				else
-					ieee->LinkDetectInfo.NumRxUnicastOkInPeriod++;
-
-				if ((ieee->state == RTLLIB_LINKED) /*&& !MgntInitAdapterInProgress(pMgntInfo)*/) {
-					if (((ieee->LinkDetectInfo.NumRxUnicastOkInPeriod +ieee->LinkDetectInfo.NumTxOkInPeriod) > 8 ) ||
-					   (ieee->LinkDetectInfo.NumRxUnicastOkInPeriod > 2)) {
-						if (ieee->LeisurePSLeave)
-							ieee->LeisurePSLeave(dev);
-					}
-				}
-			}
-		}
-#endif
-		ieee->last_rx_ps_time = jiffies;
-		if (ieee->pHTInfo->bCurRxReorderEnable == false ||pTS == NULL || bToOtherSTA ){
-			for (i = 0; i<rxb->nr_subframes; i++) {
-				struct sk_buff *sub_skb = rxb->subframes[i];
-
-				if (sub_skb) {
-					/* convert hdr + possible LLC headers into Ethernet header */
-					ethertype = (sub_skb->data[6] << 8) | sub_skb->data[7];
-					if (sub_skb->len >= 8 &&
-							((memcmp(sub_skb->data, rfc1042_header, SNAP_SIZE) == 0 &&
-							  ethertype != ETH_P_AARP && ethertype != ETH_P_IPX) ||
-							 memcmp(sub_skb->data, bridge_tunnel_header, SNAP_SIZE) == 0)) {
-						/* remove RFC1042 or Bridge-Tunnel encapsulation and
-						 * replace EtherType */
-						skb_pull(sub_skb, SNAP_SIZE);
-						memcpy(skb_push(sub_skb, ETH_ALEN), src, ETH_ALEN);
-						memcpy(skb_push(sub_skb, ETH_ALEN), dst, ETH_ALEN);
-					} else {
-						u16 len;
-						/* Leave Ethernet header part of hdr and full payload */
-						len = htons(sub_skb->len);
-						memcpy(skb_push(sub_skb, 2), &len, 2);
-						memcpy(skb_push(sub_skb, ETH_ALEN), src, ETH_ALEN);
-						memcpy(skb_push(sub_skb, ETH_ALEN), dst, ETH_ALEN);
-					}
-
-					stats->rx_packets++;
-					stats->rx_bytes += sub_skb->len;
-
-					if (is_multicast_ether_addr(dst)) {
-						stats->multicast++;
-					}
-
-					/* Indicat the packets to upper layer */
-					memset(sub_skb->cb, 0, sizeof(sub_skb->cb));
-					sub_skb->protocol = eth_type_trans(sub_skb, dev);
-					sub_skb->dev = dev;
-					sub_skb->dev->stats.rx_packets++;
-					sub_skb->dev->stats.rx_bytes += sub_skb->len;
-#ifdef TCP_CSUM_OFFLOAD_RX
-					if ( rx_stats->tcp_csum_valid)
-						sub_skb->ip_summed = CHECKSUM_UNNECESSARY;
-					else
-						sub_skb->ip_summed = CHECKSUM_NONE;
-#else
-					sub_skb->ip_summed = CHECKSUM_NONE; /* 802.11 crc not sufficient */
-#endif
-
-					netif_rx(sub_skb);
-				}
-			}
-			kfree(rxb);
-			rxb = NULL;
-
-		}
-		else
-		{
-			RTLLIB_DEBUG(RTLLIB_DL_REORDER,"%s(): REORDER ENABLE AND PTS not NULL, and we will enter RxReorderIndicatePacket()\n",__func__);
-#ifdef TCP_CSUM_OFFLOAD_RX
-			rxb->tcp_csum_valid = rx_stats->tcp_csum_valid;
-#endif
-			RxReorderIndicatePacket(ieee, rxb, pTS, SeqNum);
-		}
-#ifndef JOHN_NOCPY
-	dev_kfree_skb(skb);
-#endif
-
- rx_exit:
-#ifdef NOT_YET
-	if (sta)
-		hostap_handle_sta_release(sta);
-#endif
-	return 1;
-
- rx_dropped:
-	if (rxb != NULL)
-	{
-		kfree(rxb);
-		rxb = NULL;
-	}
-	stats->rx_dropped++;
-
-	/* Returning 0 indicates to caller that we have not handled the SKB--
-	 * so it is still allocated and can be used again by underlying
-	 * hardware as a DMA target */
-	return 0;
-}
-#endif
-
-#define MGMT_FRAME_FIXED_PART_LENGTH            0x24
 
 static u8 qos_oui[QOS_OUI_LEN] = { 0x00, 0x50, 0xF2 };
 
@@ -2852,7 +2259,6 @@ int rtllib_parse_info_param(struct rtllib_device *ieee,
                         if (info_element->data[2] & 1)
                                 network->dtim_data |= RTLLIB_DTIM_MBCAST;
 
-#if 1
                         offset = (info_element->data[2] >> 1)*2;
 
 
@@ -2864,25 +2270,6 @@ int rtllib_parse_info_param(struct rtllib_device *ieee,
                         offset = (ieee->assoc_id / 8) - offset;
                         if (info_element->data[3+offset] & (1<<(ieee->assoc_id%8)))
                                 network->dtim_data |= RTLLIB_DTIM_UCAST;
-#else
-			{
-				u16 numSta = 0;
-				u16 offset_byte = 0;
-				u16 offset_bit = 0;
-
-				numSta = (info_element->data[2] &0xFE)*8;
-
-				if (ieee->assoc_id < numSta ||
-						ieee->assoc_id > (numSta + (info_element->len -3)*8))
-					break;
-
-				offset = ieee->assoc_id - numSta;
-				offset_byte = offset / 8;
-				offset_bit = offset % 8;
-				if (info_element->data[3+offset_byte] & (0x01<<offset_bit))
-					network->dtim_data |= RTLLIB_DTIM_UCAST;
-			}
-#endif
 
 			network->listen_interval = network->dtim_period;
 			break;

commit 3591733d287446edbeb14bbc36fb6f23a9f8cefd
Author: Mike McCormack <mikem@ring3k.org>
Date:   Mon Jul 11 08:56:03 2011 +0900

    rtl8192e: Remove WIRELESS_EXT macro checks
    
    Signed-off-by: Mike McCormack <mikem@ring3k.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index 7f033815f242..9d8b2770b0ee 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -1818,11 +1818,10 @@ int rtllib_rx_Monitor(struct rtllib_device *ieee, struct sk_buff *skb,
 		hdrlen += 4;
 	}
 
-#if WIRELESS_EXT > 15
 	rtllib_monitor_rx(ieee, skb, rx_stats, hdrlen);
 	ieee->stats.rx_packets++;
 	ieee->stats.rx_bytes += skb->len;
-#endif
+
 	return 1;
 }
 

commit cb76215448947ddcc133c4b1c2ff2d4a77e851e0
Author: Mike McCormack <mikem@ring3k.org>
Date:   Mon Jul 11 08:56:20 2011 +0900

    rtl8192e: Remove extra ifdefs
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
    Signed-off-by: Mike McCormack <mikem@ring3k.org>

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
index 2a7133c6ef38..7f033815f242 100644
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -47,10 +47,6 @@
 #include "dot11d.h"
 #endif
 
-#if defined(RTLLIB_RADIOTAP) && (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,10))
-#include <net/ieee80211_radiotap.h>
-#endif
-
 #if defined CONFIG_CFG_80211
 #include <linux/crc32.h>
 
@@ -321,140 +317,17 @@ void ieee80211_scan_rx(struct rtllib_device *ieee, struct sk_buff *skb, struct r
 }
 #endif
 
-
-#if defined(RTLLIB_RADIOTAP) && (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,10))
-static int rtllib_rx_radiotap_len(struct rtllib_device *ieee, struct rtllib_rx_stats *rx_status)
-{
-	int len;
-
-	/* always present fields */
-	len = sizeof(struct ieee80211_radiotap_header) +
-		8 + /* TSFT */
-		1 + /* FLAGS */
-		1 + /* RATE */
-		2 + /* CHANNEL IN MHZ */
-		2 + /* CHANNEL BITFIELD */
-		1 + /* HW SIGNAL DBM */
-		1 + /* HW NOISE DBM */
-		1;  /* ANTENNA NUMBER */
-
-
-	if (len & 1) /* padding for RX_FLAGS if necessary */
-		len++;
-
-	/* make sure radiotap starts at a naturally aligned address */
-	if (len % 8)
-		len = roundup(len, 8);
-
-	return len;
-}
-
-static void rtllib_add_rx_radiotap_header(struct rtllib_device *ieee,
-		struct sk_buff *skb, int rtap_len, struct rtllib_rx_stats *rx_status)
-{
-	struct ieee80211_radiotap_header *rthdr;
-	unsigned char *pos;
-	printk("add header!\n");
-	rthdr = (struct ieee80211_radiotap_header *)skb_push(skb, rtap_len);
-	memset(rthdr, 0, rtap_len);
-
-	rthdr->it_version = PKTHDR_RADIOTAP_VERSION;
-	rthdr->it_pad = 0;
-	rthdr->it_len = cpu_to_le16(rtap_len);
-	/* radiotap header, set always present flags */
-	rthdr->it_present = cpu_to_le32(
-		(1 << IEEE80211_RADIOTAP_TSFT) |
-		(1 << IEEE80211_RADIOTAP_FLAGS) |
-		(1 << IEEE80211_RADIOTAP_RATE) |
-		(1 << IEEE80211_RADIOTAP_CHANNEL) |
-		(1 << IEEE80211_RADIOTAP_DBM_ANTSIGNAL) |
-		(1 << IEEE80211_RADIOTAP_DBM_ANTNOISE) |
-		(1 << IEEE80211_RADIOTAP_ANTENNA));
-
-	pos = (unsigned char *)(rthdr+1);
-	/* the order of the following fields is important */
-	/* IEEE80211_RADIOTAP_TSFT */
-	*(__le64 *)pos = cpu_to_le64(rx_status->TimeStampLow);
-	pos += 8;
-
-	/* IEEE80211_RADIOTAP_FLAGS */
-	if (rx_status->bCRC)
-		*pos |= IEEE80211_RADIOTAP_F_BADFCS;
-	if (rx_status->bShortPreamble)
-		*pos |= IEEE80211_RADIOTAP_F_SHORTPRE;
-	pos++;
-
-	/* IEEE80211_RADIOTAP_RATE */
-	*pos = rx_status->rate / 5;
-	pos++;
-
-	/* IEEE80211_RADIOTAP_CHANNEL */
-	*(__le16 *)pos = cpu_to_le16(rx_status->received_channel);
-	pos += 2;
-	pos += 2;
-
-
-	/* IEEE80211_RADIOTAP_DBM_ANTSIGNAL */
-	*pos = rx_status->RxPower;
-	pos++;
-
-	/* IEEE80211_RADIOTAP_DBM_ANTNOISE */
-	*pos = rx_status->noise;
-	pos++;
-
-	/* IEEE80211_RADIOTAP_ANTENNA */
-	*pos = rx_status->Antenna;
-	pos++;
-
-	/* IEEE80211_RADIOTAP_DB_ANTNOISE is not used */
-
-	/* IEEE80211_RADIOTAP_RX_FLAGS */
-	/* ensure 2 byte alignment for the 2 byte field as required */
-}
-#endif
-
 static inline void rtllib_monitor_rx(struct rtllib_device *ieee,
 				struct sk_buff *skb,struct rtllib_rx_stats *rx_status,
 				size_t hdr_length)
 {
-
-#if defined(RTLLIB_RADIOTAP) && (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,10))
-	int needed_headroom = 0;
-	struct sk_buff *radiotap_skb;
-
-	needed_headroom = rtllib_rx_radiotap_len(ieee, rx_status);
-	printk("needed_headroom = %d\n", needed_headroom);
-	radiotap_skb = skb_copy_expand(skb, needed_headroom, 0, GFP_ATOMIC);
-	dev_kfree_skb(skb);
-	if (!radiotap_skb) {
-		return;
-	}
-
-	rtllib_add_rx_radiotap_header(ieee, radiotap_skb, needed_headroom, rx_status);
-	radiotap_skb->dev = ieee->dev;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
-        skb_reset_mac_header(radiotap_skb);
-#else
-        radiotap_skb->mac.raw = radiotap_skb->data;
-#endif
-	radiotap_skb->ip_summed = CHECKSUM_UNNECESSARY;
-	radiotap_skb->pkt_type = PACKET_OTHERHOST;
-	radiotap_skb->protocol = htons(ETH_P_802_2);
-	memset(radiotap_skb->cb, 0, sizeof(radiotap_skb->cb));
-	netif_rx(radiotap_skb);
-#else
 	skb->dev = ieee->dev;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
         skb_reset_mac_header(skb);
-#else
-        skb->mac.raw = skb->data;
-#endif
 	skb_pull(skb, hdr_length);
 	skb->pkt_type = PACKET_OTHERHOST;
 	skb->protocol = __constant_htons(ETH_P_80211_RAW);
 	memset(skb->cb, 0, sizeof(skb->cb));
 	netif_rx(skb);
-#endif
 }
 
 /* Called only as a tasklet (software IRQ) */
@@ -3252,12 +3125,10 @@ int rtllib_parse_info_param(struct rtllib_device *ieee,
 			{
 				RTLLIB_DEBUG_MGMT("MFIE_TYPE_WZC: %d bytes\n",
 						     info_element->len);
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 				network->wzc_ie_len = min(info_element->len+2,
 							  MAX_WZC_IE_LEN);
 				memcpy(network->wzc_ie, info_element,
 						network->wzc_ie_len);
-#endif
 			}
 			break;
 
@@ -3489,9 +3360,7 @@ static inline int rtllib_network_init(
 
 	network->wpa_ie_len = 0;
 	network->rsn_ie_len = 0;
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 	network->wzc_ie_len = 0;
-#endif
 
         if (rtllib_parse_info_param(ieee,
 			beacon->info_element,
@@ -3624,10 +3493,8 @@ static inline void update_network(struct rtllib_network *dst,
 	dst->wpa_ie_len = src->wpa_ie_len;
 	memcpy(dst->rsn_ie, src->rsn_ie, src->rsn_ie_len);
 	dst->rsn_ie_len = src->rsn_ie_len;
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 	memcpy(dst->wzc_ie, src->wzc_ie, src->wzc_ie_len);
 	dst->wzc_ie_len = src->wzc_ie_len;
-#endif
 
 	dst->last_scanned = jiffies;
 	/* qos related parameters */
@@ -3945,16 +3812,10 @@ static inline void rtllib_process_probe_response(
 #endif
 	unsigned long flags;
 	short renew;
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,13))
 	struct rtllib_network *network = kzalloc(sizeof(struct rtllib_network), GFP_ATOMIC);
-#else
-	struct rtllib_network *network = kmalloc(sizeof(*network), GFP_ATOMIC);
-	memset(network,0,sizeof(*network));
-#endif
 
-	if (!network) {
+	if (!network)
 		return;
-	}
 
 	RTLLIB_DEBUG_SCAN(
 		"'%s' (" MAC_FMT "): %c%c%c%c %c%c%c%c-%c%c%c%c %c%c%c%c\n",

commit 94a799425eee8225a1e3fbe5f473d2ef04002577
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Tue Aug 23 19:00:42 2011 -0500

    From: wlanfae <wlanfae@realtek.com>
    [PATCH 1/8] rtl8192e: Import new version of driver from realtek
    
    Signed-off-by: wlanfae <wlanfae@realtek.com>
    Signed-off-by: Mike McCormack <mikem@ring3k.org>
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
    ---

diff --git a/drivers/staging/rtl8192e/rtllib_rx.c b/drivers/staging/rtl8192e/rtllib_rx.c
new file mode 100644
index 000000000000..2a7133c6ef38
--- /dev/null
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@ -0,0 +1,4234 @@
+/*
+ * Original code based Host AP (software wireless LAN access point) driver
+ * for Intersil Prism2/2.5/3 - hostap.o module, common routines
+ *
+ * Copyright (c) 2001-2002, SSH Communications Security Corp and Jouni Malinen
+ * <jkmaline@cc.hut.fi>
+ * Copyright (c) 2002-2003, Jouni Malinen <jkmaline@cc.hut.fi>
+ * Copyright (c) 2004, Intel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation. See README and COPYING for
+ * more details.
+ ******************************************************************************
+
+  Few modifications for Realtek's Wi-Fi drivers by
+  Andrea Merello <andreamrl@tiscali.it>
+
+  A special thanks goes to Realtek for their support !
+
+******************************************************************************/
+
+
+#include <linux/compiler.h>
+#include <linux/errno.h>
+#include <linux/if_arp.h>
+#include <linux/in6.h>
+#include <linux/in.h>
+#include <linux/ip.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/netdevice.h>
+#include <linux/pci.h>
+#include <linux/proc_fs.h>
+#include <linux/skbuff.h>
+#include <linux/slab.h>
+#include <linux/tcp.h>
+#include <linux/types.h>
+#include <linux/version.h>
+#include <linux/wireless.h>
+#include <linux/etherdevice.h>
+#include <asm/uaccess.h>
+#include <linux/ctype.h>
+
+#include "rtllib.h"
+#ifdef ENABLE_DOT11D
+#include "dot11d.h"
+#endif
+
+#if defined(RTLLIB_RADIOTAP) && (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,10))
+#include <net/ieee80211_radiotap.h>
+#endif
+
+#if defined CONFIG_CFG_80211
+#include <linux/crc32.h>
+
+struct ieee80211_channel *rtllib_get_channel(struct wiphy *wiphy,
+						  int freq)
+{
+	enum ieee80211_band band;
+	struct ieee80211_supported_band *sband;
+	int i;
+
+	for (band = 0; band < IEEE80211_NUM_BANDS; band++) {
+		sband = wiphy->bands[band];
+
+		if (!sband)
+			continue;
+
+		for (i = 0; i < sband->n_channels; i++) {
+			if (sband->channels[i].center_freq == freq)
+				return &sband->channels[i];
+		}
+	}
+
+	return NULL;
+}
+
+int rtllib_channel_to_frequency(int chan)
+{
+	if (chan < 14)
+		return 2407 + chan * 5;
+
+	if (chan == 14)
+		return 2484;
+
+	/* FIXME: 802.11j 17.3.8.3.2 */
+	return (chan + 1000) * 5;
+}
+
+u32 rtllib_parse_elems_crc(u8 *start, size_t len,
+			       struct ieee802_11_elems *elems,
+			       u64 filter, u32 crc)
+{
+	size_t left = len;
+	u8 *pos = start;
+	bool calc_crc = filter != 0;
+
+	memset(elems, 0, sizeof(*elems));
+	elems->ie_start = start;
+	elems->total_len = len;
+
+	while (left >= 2) {
+		u8 id, elen;
+
+		id = *pos++;
+		elen = *pos++;
+		left -= 2;
+
+		if (elen > left)
+			break;
+
+		if (calc_crc && id < 64 && (filter & BIT(id)))
+			crc = crc32_be(crc, pos - 2, elen + 2);
+
+		switch (id) {
+		case WLAN_EID_SSID:
+			elems->ssid = pos;
+			elems->ssid_len = elen;
+			break;
+		case WLAN_EID_SUPP_RATES:
+			elems->supp_rates = pos;
+			elems->supp_rates_len = elen;
+			break;
+		case WLAN_EID_FH_PARAMS:
+			elems->fh_params = pos;
+			elems->fh_params_len = elen;
+			break;
+		case WLAN_EID_DS_PARAMS:
+			elems->ds_params = pos;
+			elems->ds_params_len = elen;
+			break;
+		case WLAN_EID_CF_PARAMS:
+			elems->cf_params = pos;
+			elems->cf_params_len = elen;
+			break;
+		case WLAN_EID_TIM:
+			if (elen >= sizeof(struct ieee80211_tim_ie)) {
+				elems->tim = (void *)pos;
+				elems->tim_len = elen;
+			}
+			break;
+		case WLAN_EID_IBSS_PARAMS:
+			elems->ibss_params = pos;
+			elems->ibss_params_len = elen;
+			break;
+		case WLAN_EID_CHALLENGE:
+			elems->challenge = pos;
+			elems->challenge_len = elen;
+			break;
+		case WLAN_EID_VENDOR_SPECIFIC:
+			if (elen >= 4 && pos[0] == 0x00 && pos[1] == 0x50 &&
+			    pos[2] == 0xf2) {
+				/* Microsoft OUI (00:50:F2) */
+
+				if (calc_crc)
+					crc = crc32_be(crc, pos - 2, elen + 2);
+
+				if (pos[3] == 1) {
+					/* OUI Type 1 - WPA IE */
+					elems->wpa = pos;
+					elems->wpa_len = elen;
+				} else if (elen >= 5 && pos[3] == 2) {
+					/* OUI Type 2 - WMM IE */
+					if (pos[4] == 0) {
+						elems->wmm_info = pos;
+						elems->wmm_info_len = elen;
+					} else if (pos[4] == 1) {
+						elems->wmm_param = pos;
+						elems->wmm_param_len = elen;
+					}
+				}
+			}
+			break;
+		case WLAN_EID_RSN:
+			elems->rsn = pos;
+			elems->rsn_len = elen;
+			break;
+		case WLAN_EID_ERP_INFO:
+			elems->erp_info = pos;
+			elems->erp_info_len = elen;
+			break;
+		case WLAN_EID_EXT_SUPP_RATES:
+			elems->ext_supp_rates = pos;
+			elems->ext_supp_rates_len = elen;
+			break;
+		case WLAN_EID_HT_CAPABILITY:
+			if (elen >= sizeof(struct ieee80211_ht_cap))
+				elems->ht_cap_elem = (void *)pos;
+			break;
+		case WLAN_EID_HT_INFORMATION:
+			if (elen >= sizeof(struct ieee80211_ht_info))
+				elems->ht_info_elem = (void *)pos;
+			break;
+		case WLAN_EID_MESH_ID:
+			elems->mesh_id = pos;
+			elems->mesh_id_len = elen;
+			break;
+		case WLAN_EID_MESH_CONFIG:
+			elems->mesh_config = pos;
+			elems->mesh_config_len = elen;
+			break;
+		case WLAN_EID_PEER_LINK:
+			elems->peer_link = pos;
+			elems->peer_link_len = elen;
+			break;
+		case WLAN_EID_PREQ:
+			elems->preq = pos;
+			elems->preq_len = elen;
+			break;
+		case WLAN_EID_PREP:
+			elems->prep = pos;
+			elems->prep_len = elen;
+			break;
+		case WLAN_EID_PERR:
+			elems->perr = pos;
+			elems->perr_len = elen;
+			break;
+		case WLAN_EID_CHANNEL_SWITCH:
+			elems->ch_switch_elem = pos;
+			elems->ch_switch_elem_len = elen;
+			break;
+		case WLAN_EID_QUIET:
+			if (!elems->quiet_elem) {
+				elems->quiet_elem = pos;
+				elems->quiet_elem_len = elen;
+			}
+			elems->num_of_quiet_elem++;
+			break;
+		case WLAN_EID_COUNTRY:
+			elems->country_elem = pos;
+			elems->country_elem_len = elen;
+			break;
+		case WLAN_EID_PWR_CONSTRAINT:
+			elems->pwr_constr_elem = pos;
+			elems->pwr_constr_elem_len = elen;
+			break;
+		case WLAN_EID_TIMEOUT_INTERVAL:
+			elems->timeout_int = pos;
+			elems->timeout_int_len = elen;
+			break;
+		default:
+			break;
+		}
+
+		left -= elen;
+		pos += elen;
+	}
+
+	return crc;
+}
+
+void rtllib_parse_elems(u8 *start, size_t len,
+			    struct ieee802_11_elems *elems)
+{
+	rtllib_parse_elems_crc(start, len, elems, 0, 0);
+}
+
+void ieee80211_scan_rx(struct rtllib_device *ieee, struct sk_buff *skb, struct rtllib_rx_stats *rx_status)
+{
+	struct rtllib_hdr_4addr *header = (struct rtllib_hdr_4addr *)skb->data ;
+	struct ieee80211_mgmt *mgmt;
+	struct ieee80211_bss *bss;
+	u8 *elements;
+	struct ieee80211_channel *channel;
+	size_t baselen;
+	int freq;
+	__le16 fc;
+	bool presp, beacon = false;
+	struct ieee802_11_elems elems;
+	s32 signal = 0;
+
+	if (skb->len < 2)
+		return;
+
+	mgmt = (struct ieee80211_mgmt *) skb->data;
+	fc = mgmt->frame_control;
+
+	if (skb->len < 24)
+		return;
+
+	presp = (WLAN_FC_GET_STYPE(header->frame_ctl) == RTLLIB_STYPE_PROBE_RESP);
+	if (presp) {
+		/* ignore ProbeResp to foreign address */
+		if (memcmp(mgmt->da, ieee->dev->dev_addr, ETH_ALEN))
+			return ;;
+
+		presp = true;
+		elements = mgmt->u.probe_resp.variable;
+		baselen = offsetof(struct ieee80211_mgmt, u.probe_resp.variable);
+	} else {
+		beacon =  (WLAN_FC_GET_STYPE(header->frame_ctl) == RTLLIB_STYPE_BEACON);
+		baselen = offsetof(struct ieee80211_mgmt, u.beacon.variable);
+		elements = mgmt->u.beacon.variable;
+	}
+
+	if (!presp && !beacon)
+		return;
+
+	if (baselen > skb->len)
+		return;
+
+	rtllib_parse_elems(elements, skb->len - baselen, &elems);
+
+	if (elems.ds_params && elems.ds_params_len == 1)
+		freq = rtllib_channel_to_frequency(elems.ds_params[0]);
+	else
+		return;
+
+	channel = rtllib_get_channel(ieee->wdev.wiphy, freq);
+
+	if (!channel || channel->flags & IEEE80211_CHAN_DISABLED)
+		return;
+
+		signal = rx_status->signal * 100;
+
+	bss = (void *)cfg80211_inform_bss_frame(ieee->wdev.wiphy, channel,
+						mgmt, skb->len, signal, GFP_ATOMIC);
+
+	return;
+}
+#endif
+
+
+#if defined(RTLLIB_RADIOTAP) && (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,10))
+static int rtllib_rx_radiotap_len(struct rtllib_device *ieee, struct rtllib_rx_stats *rx_status)
+{
+	int len;
+
+	/* always present fields */
+	len = sizeof(struct ieee80211_radiotap_header) +
+		8 + /* TSFT */
+		1 + /* FLAGS */
+		1 + /* RATE */
+		2 + /* CHANNEL IN MHZ */
+		2 + /* CHANNEL BITFIELD */
+		1 + /* HW SIGNAL DBM */
+		1 + /* HW NOISE DBM */
+		1;  /* ANTENNA NUMBER */
+
+
+	if (len & 1) /* padding for RX_FLAGS if necessary */
+		len++;
+
+	/* make sure radiotap starts at a naturally aligned address */
+	if (len % 8)
+		len = roundup(len, 8);
+
+	return len;
+}
+
+static void rtllib_add_rx_radiotap_header(struct rtllib_device *ieee,
+		struct sk_buff *skb, int rtap_len, struct rtllib_rx_stats *rx_status)
+{
+	struct ieee80211_radiotap_header *rthdr;
+	unsigned char *pos;
+	printk("add header!\n");
+	rthdr = (struct ieee80211_radiotap_header *)skb_push(skb, rtap_len);
+	memset(rthdr, 0, rtap_len);
+
+	rthdr->it_version = PKTHDR_RADIOTAP_VERSION;
+	rthdr->it_pad = 0;
+	rthdr->it_len = cpu_to_le16(rtap_len);
+	/* radiotap header, set always present flags */
+	rthdr->it_present = cpu_to_le32(
+		(1 << IEEE80211_RADIOTAP_TSFT) |
+		(1 << IEEE80211_RADIOTAP_FLAGS) |
+		(1 << IEEE80211_RADIOTAP_RATE) |
+		(1 << IEEE80211_RADIOTAP_CHANNEL) |
+		(1 << IEEE80211_RADIOTAP_DBM_ANTSIGNAL) |
+		(1 << IEEE80211_RADIOTAP_DBM_ANTNOISE) |
+		(1 << IEEE80211_RADIOTAP_ANTENNA));
+
+	pos = (unsigned char *)(rthdr+1);
+	/* the order of the following fields is important */
+	/* IEEE80211_RADIOTAP_TSFT */
+	*(__le64 *)pos = cpu_to_le64(rx_status->TimeStampLow);
+	pos += 8;
+
+	/* IEEE80211_RADIOTAP_FLAGS */
+	if (rx_status->bCRC)
+		*pos |= IEEE80211_RADIOTAP_F_BADFCS;
+	if (rx_status->bShortPreamble)
+		*pos |= IEEE80211_RADIOTAP_F_SHORTPRE;
+	pos++;
+
+	/* IEEE80211_RADIOTAP_RATE */
+	*pos = rx_status->rate / 5;
+	pos++;
+
+	/* IEEE80211_RADIOTAP_CHANNEL */
+	*(__le16 *)pos = cpu_to_le16(rx_status->received_channel);
+	pos += 2;
+	pos += 2;
+
+
+	/* IEEE80211_RADIOTAP_DBM_ANTSIGNAL */
+	*pos = rx_status->RxPower;
+	pos++;
+
+	/* IEEE80211_RADIOTAP_DBM_ANTNOISE */
+	*pos = rx_status->noise;
+	pos++;
+
+	/* IEEE80211_RADIOTAP_ANTENNA */
+	*pos = rx_status->Antenna;
+	pos++;
+
+	/* IEEE80211_RADIOTAP_DB_ANTNOISE is not used */
+
+	/* IEEE80211_RADIOTAP_RX_FLAGS */
+	/* ensure 2 byte alignment for the 2 byte field as required */
+}
+#endif
+
+static inline void rtllib_monitor_rx(struct rtllib_device *ieee,
+				struct sk_buff *skb,struct rtllib_rx_stats *rx_status,
+				size_t hdr_length)
+{
+
+#if defined(RTLLIB_RADIOTAP) && (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,10))
+	int needed_headroom = 0;
+	struct sk_buff *radiotap_skb;
+
+	needed_headroom = rtllib_rx_radiotap_len(ieee, rx_status);
+	printk("needed_headroom = %d\n", needed_headroom);
+	radiotap_skb = skb_copy_expand(skb, needed_headroom, 0, GFP_ATOMIC);
+	dev_kfree_skb(skb);
+	if (!radiotap_skb) {
+		return;
+	}
+
+	rtllib_add_rx_radiotap_header(ieee, radiotap_skb, needed_headroom, rx_status);
+	radiotap_skb->dev = ieee->dev;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
+        skb_reset_mac_header(radiotap_skb);
+#else
+        radiotap_skb->mac.raw = radiotap_skb->data;
+#endif
+	radiotap_skb->ip_summed = CHECKSUM_UNNECESSARY;
+	radiotap_skb->pkt_type = PACKET_OTHERHOST;
+	radiotap_skb->protocol = htons(ETH_P_802_2);
+	memset(radiotap_skb->cb, 0, sizeof(radiotap_skb->cb));
+	netif_rx(radiotap_skb);
+#else
+	skb->dev = ieee->dev;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
+        skb_reset_mac_header(skb);
+#else
+        skb->mac.raw = skb->data;
+#endif
+	skb_pull(skb, hdr_length);
+	skb->pkt_type = PACKET_OTHERHOST;
+	skb->protocol = __constant_htons(ETH_P_80211_RAW);
+	memset(skb->cb, 0, sizeof(skb->cb));
+	netif_rx(skb);
+#endif
+}
+
+/* Called only as a tasklet (software IRQ) */
+static struct rtllib_frag_entry *
+rtllib_frag_cache_find(struct rtllib_device *ieee, unsigned int seq,
+			  unsigned int frag, u8 tid,u8 *src, u8 *dst)
+{
+	struct rtllib_frag_entry *entry;
+	int i;
+
+	for (i = 0; i < RTLLIB_FRAG_CACHE_LEN; i++) {
+		entry = &ieee->frag_cache[tid][i];
+		if (entry->skb != NULL &&
+		    time_after(jiffies, entry->first_frag_time + 2 * HZ)) {
+			RTLLIB_DEBUG_FRAG(
+				"expiring fragment cache entry "
+				"seq=%u last_frag=%u\n",
+				entry->seq, entry->last_frag);
+			dev_kfree_skb_any(entry->skb);
+			entry->skb = NULL;
+		}
+
+		if (entry->skb != NULL && entry->seq == seq &&
+		    (entry->last_frag + 1 == frag || frag == -1) &&
+		    memcmp(entry->src_addr, src, ETH_ALEN) == 0 &&
+		    memcmp(entry->dst_addr, dst, ETH_ALEN) == 0)
+			return entry;
+	}
+
+	return NULL;
+}
+
+/* Called only as a tasklet (software IRQ) */
+static struct sk_buff *
+rtllib_frag_cache_get(struct rtllib_device *ieee,
+			 struct rtllib_hdr_4addr *hdr)
+{
+	struct sk_buff *skb = NULL;
+	u16 fc = le16_to_cpu(hdr->frame_ctl);
+	u16 sc = le16_to_cpu(hdr->seq_ctl);
+	unsigned int frag = WLAN_GET_SEQ_FRAG(sc);
+	unsigned int seq = WLAN_GET_SEQ_SEQ(sc);
+	struct rtllib_frag_entry *entry;
+	struct rtllib_hdr_3addrqos *hdr_3addrqos;
+	struct rtllib_hdr_4addrqos *hdr_4addrqos;
+	u8 tid;
+
+	if (((fc & RTLLIB_FCTL_DSTODS) == RTLLIB_FCTL_DSTODS)&&RTLLIB_QOS_HAS_SEQ(fc)) {
+	  hdr_4addrqos = (struct rtllib_hdr_4addrqos *)hdr;
+	  tid = le16_to_cpu(hdr_4addrqos->qos_ctl) & RTLLIB_QCTL_TID;
+	  tid = UP2AC(tid);
+	  tid ++;
+	} else if (RTLLIB_QOS_HAS_SEQ(fc)) {
+	  hdr_3addrqos = (struct rtllib_hdr_3addrqos *)hdr;
+	  tid = le16_to_cpu(hdr_3addrqos->qos_ctl) & RTLLIB_QCTL_TID;
+	  tid = UP2AC(tid);
+	  tid ++;
+	} else {
+	  tid = 0;
+	}
+
+	if (frag == 0) {
+		/* Reserve enough space to fit maximum frame length */
+		skb = dev_alloc_skb(ieee->dev->mtu +
+				    sizeof(struct rtllib_hdr_4addr) +
+				    8 /* LLC */ +
+				    2 /* alignment */ +
+				    8 /* WEP */ +
+				    ETH_ALEN /* WDS */ +
+				    (RTLLIB_QOS_HAS_SEQ(fc)?2:0) /* QOS Control */);
+		if (skb == NULL)
+			return NULL;
+
+		entry = &ieee->frag_cache[tid][ieee->frag_next_idx[tid]];
+		ieee->frag_next_idx[tid]++;
+		if (ieee->frag_next_idx[tid] >= RTLLIB_FRAG_CACHE_LEN)
+			ieee->frag_next_idx[tid] = 0;
+
+		if (entry->skb != NULL)
+			dev_kfree_skb_any(entry->skb);
+
+		entry->first_frag_time = jiffies;
+		entry->seq = seq;
+		entry->last_frag = frag;
+		entry->skb = skb;
+		memcpy(entry->src_addr, hdr->addr2, ETH_ALEN);
+		memcpy(entry->dst_addr, hdr->addr1, ETH_ALEN);
+	} else {
+		/* received a fragment of a frame for which the head fragment
+		 * should have already been received */
+		entry = rtllib_frag_cache_find(ieee, seq, frag, tid,hdr->addr2,
+						  hdr->addr1);
+		if (entry != NULL) {
+			entry->last_frag = frag;
+			skb = entry->skb;
+		}
+	}
+
+	return skb;
+}
+
+
+/* Called only as a tasklet (software IRQ) */
+static int rtllib_frag_cache_invalidate(struct rtllib_device *ieee,
+					   struct rtllib_hdr_4addr *hdr)
+{
+	u16 fc = le16_to_cpu(hdr->frame_ctl);
+	u16 sc = le16_to_cpu(hdr->seq_ctl);
+	unsigned int seq = WLAN_GET_SEQ_SEQ(sc);
+	struct rtllib_frag_entry *entry;
+	struct rtllib_hdr_3addrqos *hdr_3addrqos;
+	struct rtllib_hdr_4addrqos *hdr_4addrqos;
+	u8 tid;
+
+	if (((fc & RTLLIB_FCTL_DSTODS) == RTLLIB_FCTL_DSTODS)&&RTLLIB_QOS_HAS_SEQ(fc)) {
+	  hdr_4addrqos = (struct rtllib_hdr_4addrqos *)hdr;
+	  tid = le16_to_cpu(hdr_4addrqos->qos_ctl) & RTLLIB_QCTL_TID;
+	  tid = UP2AC(tid);
+	  tid ++;
+	} else if (RTLLIB_QOS_HAS_SEQ(fc)) {
+	  hdr_3addrqos = (struct rtllib_hdr_3addrqos *)hdr;
+	  tid = le16_to_cpu(hdr_3addrqos->qos_ctl) & RTLLIB_QCTL_TID;
+	  tid = UP2AC(tid);
+	  tid ++;
+	} else {
+	  tid = 0;
+	}
+
+	entry = rtllib_frag_cache_find(ieee, seq, -1, tid,hdr->addr2,
+					  hdr->addr1);
+
+	if (entry == NULL) {
+		RTLLIB_DEBUG_FRAG(
+			"could not invalidate fragment cache "
+			"entry (seq=%u)\n", seq);
+		return -1;
+	}
+
+	entry->skb = NULL;
+	return 0;
+}
+
+
+
+/* rtllib_rx_frame_mgtmt
+ *
+ * Responsible for handling management control frames
+ *
+ * Called by rtllib_rx */
+static inline int
+rtllib_rx_frame_mgmt(struct rtllib_device *ieee, struct sk_buff *skb,
+			struct rtllib_rx_stats *rx_stats, u16 type,
+			u16 stype)
+{
+	/* On the struct stats definition there is written that
+	 * this is not mandatory.... but seems that the probe
+	 * response parser uses it
+	 */
+	struct rtllib_hdr_3addr * hdr = (struct rtllib_hdr_3addr *)skb->data;
+
+	rx_stats->len = skb->len;
+	rtllib_rx_mgt(ieee,skb,rx_stats);
+	if ((memcmp(hdr->addr1, ieee->dev->dev_addr, ETH_ALEN))) {
+		dev_kfree_skb_any(skb);
+		return 0;
+	}
+	rtllib_rx_frame_softmac(ieee, skb, rx_stats, type, stype);
+
+	dev_kfree_skb_any(skb);
+
+	return 0;
+
+#ifdef NOT_YET
+	if (ieee->iw_mode == IW_MODE_MASTER) {
+		printk(KERN_DEBUG "%s: Master mode not yet suppported.\n",
+		       ieee->dev->name);
+		return 0;
+/*
+  hostap_update_sta_ps(ieee, (struct hostap_rtllib_hdr_4addr *)
+  skb->data);*/
+	}
+
+	if (ieee->hostapd && type == RTLLIB_TYPE_MGMT) {
+		if (stype == WLAN_FC_STYPE_BEACON &&
+		    ieee->iw_mode == IW_MODE_MASTER) {
+			struct sk_buff *skb2;
+			/* Process beacon frames also in kernel driver to
+			 * update STA(AP) table statistics */
+			skb2 = skb_clone(skb, GFP_ATOMIC);
+			if (skb2)
+				hostap_rx(skb2->dev, skb2, rx_stats);
+		}
+
+		/* send management frames to the user space daemon for
+		 * processing */
+		ieee->apdevstats.rx_packets++;
+		ieee->apdevstats.rx_bytes += skb->len;
+		prism2_rx_80211(ieee->apdev, skb, rx_stats, PRISM2_RX_MGMT);
+		return 0;
+	}
+
+	    if (ieee->iw_mode == IW_MODE_MASTER) {
+		if (type != WLAN_FC_TYPE_MGMT && type != WLAN_FC_TYPE_CTRL) {
+			printk(KERN_DEBUG "%s: unknown management frame "
+			       "(type=0x%02x, stype=0x%02x) dropped\n",
+			       skb->dev->name, type, stype);
+			return -1;
+		}
+
+		hostap_rx(skb->dev, skb, rx_stats);
+		return 0;
+	}
+
+	printk(KERN_DEBUG "%s: hostap_rx_frame_mgmt: management frame "
+	       "received in non-Host AP mode\n", skb->dev->name);
+	return -1;
+#endif
+}
+
+#ifndef CONFIG_CFG_80211
+/* See IEEE 802.1H for LLC/SNAP encapsulation/decapsulation */
+/* Ethernet-II snap header (RFC1042 for most EtherTypes) */
+static unsigned char rfc1042_header[] =
+{ 0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00 };
+/* Bridge-Tunnel header (for EtherTypes ETH_P_AARP and ETH_P_IPX) */
+static unsigned char bridge_tunnel_header[] =
+{ 0xaa, 0xaa, 0x03, 0x00, 0x00, 0xf8 };
+/* No encapsulation header if EtherType < 0x600 (=length) */
+#endif
+
+/* Called by rtllib_rx_frame_decrypt */
+static int rtllib_is_eapol_frame(struct rtllib_device *ieee,
+				    struct sk_buff *skb, size_t hdrlen)
+{
+	struct net_device *dev = ieee->dev;
+	u16 fc, ethertype;
+	struct rtllib_hdr_4addr *hdr;
+	u8 *pos;
+
+	if (skb->len < 24)
+		return 0;
+
+	hdr = (struct rtllib_hdr_4addr *) skb->data;
+	fc = le16_to_cpu(hdr->frame_ctl);
+
+	/* check that the frame is unicast frame to us */
+	if ((fc & (RTLLIB_FCTL_TODS | RTLLIB_FCTL_FROMDS)) ==
+	    RTLLIB_FCTL_TODS &&
+	    memcmp(hdr->addr1, dev->dev_addr, ETH_ALEN) == 0 &&
+	    memcmp(hdr->addr3, dev->dev_addr, ETH_ALEN) == 0) {
+		/* ToDS frame with own addr BSSID and DA */
+	} else if ((fc & (RTLLIB_FCTL_TODS | RTLLIB_FCTL_FROMDS)) ==
+		   RTLLIB_FCTL_FROMDS &&
+		   memcmp(hdr->addr1, dev->dev_addr, ETH_ALEN) == 0) {
+		/* FromDS frame with own addr as DA */
+	} else
+		return 0;
+
+	if (skb->len < 24 + 8)
+		return 0;
+
+	/* check for port access entity Ethernet type */
+	pos = skb->data + hdrlen;
+	ethertype = (pos[6] << 8) | pos[7];
+	if (ethertype == ETH_P_PAE)
+		return 1;
+
+	return 0;
+}
+
+/* Called only as a tasklet (software IRQ), by rtllib_rx */
+static inline int
+rtllib_rx_frame_decrypt(struct rtllib_device* ieee, struct sk_buff *skb,
+			   struct rtllib_crypt_data *crypt)
+{
+	struct rtllib_hdr_4addr *hdr;
+	int res, hdrlen;
+
+	if (crypt == NULL || crypt->ops->decrypt_mpdu == NULL)
+		return 0;
+#if 1
+	if (ieee->hwsec_active)
+	{
+		cb_desc *tcb_desc = (cb_desc *)(skb->cb+ MAX_DEV_ADDR_SIZE);
+		tcb_desc->bHwSec = 1;
+
+		if (ieee->need_sw_enc)
+			tcb_desc->bHwSec = 0;
+	}
+#endif
+	hdr = (struct rtllib_hdr_4addr *) skb->data;
+	hdrlen = rtllib_get_hdrlen(le16_to_cpu(hdr->frame_ctl));
+
+#ifdef CONFIG_RTLLIB_CRYPT_TKIP
+	if (ieee->tkip_countermeasures &&
+	    strcmp(crypt->ops->name, "TKIP") == 0) {
+		if (net_ratelimit()) {
+			printk(KERN_DEBUG "%s: TKIP countermeasures: dropped "
+			       "received packet from " MAC_FMT "\n",
+			       ieee->dev->name, MAC_ARG(hdr->addr2));
+		}
+		return -1;
+	}
+#endif
+
+	atomic_inc(&crypt->refcnt);
+	res = crypt->ops->decrypt_mpdu(skb, hdrlen, crypt->priv);
+	atomic_dec(&crypt->refcnt);
+	if (res < 0) {
+		RTLLIB_DEBUG_DROP(
+			"decryption failed (SA=" MAC_FMT
+			") res=%d\n", MAC_ARG(hdr->addr2), res);
+		if (res == -2)
+			RTLLIB_DEBUG_DROP("Decryption failed ICV "
+					     "mismatch (key %d)\n",
+					     skb->data[hdrlen + 3] >> 6);
+		ieee->ieee_stats.rx_discards_undecryptable++;
+		return -1;
+	}
+
+	return res;
+}
+
+
+/* Called only as a tasklet (software IRQ), by rtllib_rx */
+static inline int
+rtllib_rx_frame_decrypt_msdu(struct rtllib_device* ieee, struct sk_buff *skb,
+			     int keyidx, struct rtllib_crypt_data *crypt)
+{
+	struct rtllib_hdr_4addr *hdr;
+	int res, hdrlen;
+
+	if (crypt == NULL || crypt->ops->decrypt_msdu == NULL)
+		return 0;
+	if (ieee->hwsec_active)
+	{
+		cb_desc *tcb_desc = (cb_desc *)(skb->cb+ MAX_DEV_ADDR_SIZE);
+		tcb_desc->bHwSec = 1;
+
+		if (ieee->need_sw_enc)
+			tcb_desc->bHwSec = 0;
+	}
+
+	hdr = (struct rtllib_hdr_4addr *) skb->data;
+	hdrlen = rtllib_get_hdrlen(le16_to_cpu(hdr->frame_ctl));
+
+	atomic_inc(&crypt->refcnt);
+	res = crypt->ops->decrypt_msdu(skb, keyidx, hdrlen, crypt->priv,ieee);
+	atomic_dec(&crypt->refcnt);
+	if (res < 0) {
+		printk(KERN_DEBUG "%s: MSDU decryption/MIC verification failed"
+		       " (SA=" MAC_FMT " keyidx=%d)\n",
+		       ieee->dev->name, MAC_ARG(hdr->addr2), keyidx);
+		return -1;
+	}
+
+	return 0;
+}
+
+
+/* this function is stolen from ipw2200 driver*/
+#define IEEE_PACKET_RETRY_TIME (5*HZ)
+static int is_duplicate_packet(struct rtllib_device *ieee,
+				      struct rtllib_hdr_4addr *header)
+{
+	u16 fc = le16_to_cpu(header->frame_ctl);
+	u16 sc = le16_to_cpu(header->seq_ctl);
+	u16 seq = WLAN_GET_SEQ_SEQ(sc);
+	u16 frag = WLAN_GET_SEQ_FRAG(sc);
+	u16 *last_seq, *last_frag;
+	unsigned long *last_time;
+	struct rtllib_hdr_3addrqos *hdr_3addrqos;
+	struct rtllib_hdr_4addrqos *hdr_4addrqos;
+	u8 tid;
+
+	if (((fc & RTLLIB_FCTL_DSTODS) == RTLLIB_FCTL_DSTODS)&&RTLLIB_QOS_HAS_SEQ(fc)) {
+	  hdr_4addrqos = (struct rtllib_hdr_4addrqos *)header;
+	  tid = le16_to_cpu(hdr_4addrqos->qos_ctl) & RTLLIB_QCTL_TID;
+	  tid = UP2AC(tid);
+	  tid ++;
+	} else if (RTLLIB_QOS_HAS_SEQ(fc)) {
+	  hdr_3addrqos = (struct rtllib_hdr_3addrqos*)header;
+	  tid = le16_to_cpu(hdr_3addrqos->qos_ctl) & RTLLIB_QCTL_TID;
+	  tid = UP2AC(tid);
+	  tid ++;
+	} else {
+	  tid = 0;
+	}
+
+	switch (ieee->iw_mode) {
+	case IW_MODE_ADHOC:
+	{
+		struct list_head *p;
+		struct ieee_ibss_seq *entry = NULL;
+		u8 *mac = header->addr2;
+		int index = mac[5] % IEEE_IBSS_MAC_HASH_SIZE;
+		list_for_each(p, &ieee->ibss_mac_hash[index]) {
+			entry = list_entry(p, struct ieee_ibss_seq, list);
+			if (!memcmp(entry->mac, mac, ETH_ALEN))
+				break;
+		}
+		if (p == &ieee->ibss_mac_hash[index]) {
+			entry = kmalloc(sizeof(struct ieee_ibss_seq), GFP_ATOMIC);
+			if (!entry) {
+				printk(KERN_WARNING "Cannot malloc new mac entry\n");
+				return 0;
+			}
+			memcpy(entry->mac, mac, ETH_ALEN);
+			entry->seq_num[tid] = seq;
+			entry->frag_num[tid] = frag;
+			entry->packet_time[tid] = jiffies;
+			list_add(&entry->list, &ieee->ibss_mac_hash[index]);
+			return 0;
+		}
+		last_seq = &entry->seq_num[tid];
+		last_frag = &entry->frag_num[tid];
+		last_time = &entry->packet_time[tid];
+		break;
+	}
+
+	case IW_MODE_INFRA:
+		last_seq = &ieee->last_rxseq_num[tid];
+		last_frag = &ieee->last_rxfrag_num[tid];
+		last_time = &ieee->last_packet_time[tid];
+		break;
+	default:
+		return 0;
+	}
+
+	if ((*last_seq == seq) &&
+	    time_after(*last_time + IEEE_PACKET_RETRY_TIME, jiffies)) {
+		if (*last_frag == frag){
+			goto drop;
+
+		}
+		if (*last_frag + 1 != frag)
+			/* out-of-order fragment */
+			goto drop;
+	} else
+		*last_seq = seq;
+
+	*last_frag = frag;
+	*last_time = jiffies;
+	return 0;
+
+drop:
+
+	return 1;
+}
+bool
+AddReorderEntry(
+	PRX_TS_RECORD			pTS,
+	PRX_REORDER_ENTRY		pReorderEntry
+	)
+{
+	struct list_head *pList = &pTS->RxPendingPktList;
+
+	while(pList->next != &pTS->RxPendingPktList)
+	{
+		if ( SN_LESS(pReorderEntry->SeqNum, ((PRX_REORDER_ENTRY)list_entry(pList->next,RX_REORDER_ENTRY,List))->SeqNum) )
+		{
+			pList = pList->next;
+		}
+		else if ( SN_EQUAL(pReorderEntry->SeqNum, ((PRX_REORDER_ENTRY)list_entry(pList->next,RX_REORDER_ENTRY,List))->SeqNum) )
+		{
+			return false;
+		}
+		else
+		{
+			break;
+		}
+	}
+	pReorderEntry->List.next = pList->next;
+	pReorderEntry->List.next->prev = &pReorderEntry->List;
+	pReorderEntry->List.prev = pList;
+	pList->next = &pReorderEntry->List;
+
+	return true;
+}
+
+void rtllib_indicate_packets(struct rtllib_device *ieee, struct rtllib_rxb** prxbIndicateArray,u8  index)
+{
+	struct net_device_stats *stats = &ieee->stats;
+	u8 i = 0 , j=0;
+	u16 ethertype;
+	for (j = 0; j < index; j++) {
+		struct rtllib_rxb* prxb = prxbIndicateArray[j];
+		for (i = 0; i<prxb->nr_subframes; i++) {
+			struct sk_buff *sub_skb = prxb->subframes[i];
+
+		/* convert hdr + possible LLC headers into Ethernet header */
+			ethertype = (sub_skb->data[6] << 8) | sub_skb->data[7];
+			if (sub_skb->len >= 8 &&
+				((memcmp(sub_skb->data, rfc1042_header, SNAP_SIZE) == 0 &&
+				  ethertype != ETH_P_AARP && ethertype != ETH_P_IPX) ||
+				 memcmp(sub_skb->data, bridge_tunnel_header, SNAP_SIZE) == 0)) {
+			/* remove RFC1042 or Bridge-Tunnel encapsulation and
+			 * replace EtherType */
+				skb_pull(sub_skb, SNAP_SIZE);
+				memcpy(skb_push(sub_skb, ETH_ALEN), prxb->src, ETH_ALEN);
+				memcpy(skb_push(sub_skb, ETH_ALEN), prxb->dst, ETH_ALEN);
+			} else {
+				u16 len;
+			/* Leave Ethernet header part of hdr and full payload */
+				len = htons(sub_skb->len);
+				memcpy(skb_push(sub_skb, 2), &len, 2);
+				memcpy(skb_push(sub_skb, ETH_ALEN), prxb->src, ETH_ALEN);
+				memcpy(skb_push(sub_skb, ETH_ALEN), prxb->dst, ETH_ALEN);
+			}
+
+		/* Indicat the packets to upper layer */
+			if (sub_skb) {
+				stats->rx_packets++;
+				stats->rx_bytes += sub_skb->len;
+
+				memset(sub_skb->cb, 0, sizeof(sub_skb->cb));
+				sub_skb->protocol = eth_type_trans(sub_skb, ieee->dev);
+				sub_skb->dev = ieee->dev;
+				sub_skb->dev->stats.rx_packets++;
+				sub_skb->dev->stats.rx_bytes += sub_skb->len;
+#ifdef TCP_CSUM_OFFLOAD_RX
+				if ( prxb->tcp_csum_valid)
+					sub_skb->ip_summed = CHECKSUM_UNNECESSARY;
+				else
+					sub_skb->ip_summed = CHECKSUM_NONE;
+
+#else
+				sub_skb->ip_summed = CHECKSUM_NONE; /* 802.11 crc not sufficient */
+#endif
+				ieee->last_rx_ps_time = jiffies;
+				netif_rx(sub_skb);
+			}
+		}
+		kfree(prxb);
+		prxb = NULL;
+	}
+}
+
+void
+rtllib_FlushRxTsPendingPkts(struct rtllib_device *ieee,	PRX_TS_RECORD pTS)
+{
+	PRX_REORDER_ENTRY	pRxReorderEntry;
+	struct rtllib_rxb*		RfdArray[REORDER_WIN_SIZE];
+	u8					RfdCnt = 0;
+
+
+	del_timer_sync(&pTS->RxPktPendingTimer);
+	while(!list_empty(&pTS->RxPendingPktList))
+	{
+		if (RfdCnt >= REORDER_WIN_SIZE){
+			printk("-------------->%s() error! RfdCnt >= REORDER_WIN_SIZE\n", __func__);
+			break;
+		}
+
+		pRxReorderEntry = (PRX_REORDER_ENTRY)list_entry(pTS->RxPendingPktList.prev,RX_REORDER_ENTRY,List);
+		RTLLIB_DEBUG(RTLLIB_DL_REORDER,"%s(): Indicate SeqNum %d!\n",__func__, pRxReorderEntry->SeqNum);
+		list_del_init(&pRxReorderEntry->List);
+
+		RfdArray[RfdCnt] = pRxReorderEntry->prxb;
+
+		RfdCnt = RfdCnt + 1;
+		list_add_tail(&pRxReorderEntry->List, &ieee->RxReorder_Unused_List);
+	}
+	rtllib_indicate_packets(ieee, RfdArray, RfdCnt);
+
+	pTS->RxIndicateSeq = 0xffff;
+
+#ifdef MERGE_TO_DO
+#endif
+}
+
+
+void RxReorderIndicatePacket( struct rtllib_device *ieee,
+		struct rtllib_rxb* prxb,
+		PRX_TS_RECORD		pTS,
+		u16			SeqNum)
+{
+	PRT_HIGH_THROUGHPUT	pHTInfo = ieee->pHTInfo;
+	PRX_REORDER_ENTRY	pReorderEntry = NULL;
+	struct rtllib_rxb* prxbIndicateArray[REORDER_WIN_SIZE];
+	u8			WinSize = pHTInfo->RxReorderWinSize;
+	u16			WinEnd = 0;
+	u8			index = 0;
+	bool			bMatchWinStart = false, bPktInBuf = false;
+	unsigned long flags;
+
+	RTLLIB_DEBUG(RTLLIB_DL_REORDER,"%s(): Seq is %d,pTS->RxIndicateSeq is %d, WinSize is %d\n",__func__,SeqNum,pTS->RxIndicateSeq,WinSize);
+
+	spin_lock_irqsave(&(ieee->reorder_spinlock), flags);
+
+	WinEnd = (pTS->RxIndicateSeq + WinSize -1)%4096;
+	/* Rx Reorder initialize condition.*/
+	if (pTS->RxIndicateSeq == 0xffff) {
+		pTS->RxIndicateSeq = SeqNum;
+	}
+
+	/* Drop out the packet which SeqNum is smaller than WinStart */
+	if (SN_LESS(SeqNum, pTS->RxIndicateSeq)) {
+		RTLLIB_DEBUG(RTLLIB_DL_REORDER,"Packet Drop! IndicateSeq: %d, NewSeq: %d\n",
+				 pTS->RxIndicateSeq, SeqNum);
+		pHTInfo->RxReorderDropCounter++;
+		{
+			int i;
+			for (i =0; i < prxb->nr_subframes; i++) {
+				dev_kfree_skb(prxb->subframes[i]);
+			}
+			kfree(prxb);
+			prxb = NULL;
+		}
+		spin_unlock_irqrestore(&(ieee->reorder_spinlock), flags);
+		return;
+	}
+
+	/*
+	 * Sliding window manipulation. Conditions includes:
+	 * 1. Incoming SeqNum is equal to WinStart =>Window shift 1
+	 * 2. Incoming SeqNum is larger than the WinEnd => Window shift N
+	 */
+	if (SN_EQUAL(SeqNum, pTS->RxIndicateSeq)) {
+		pTS->RxIndicateSeq = (pTS->RxIndicateSeq + 1) % 4096;
+		bMatchWinStart = true;
+	} else if (SN_LESS(WinEnd, SeqNum)) {
+		if (SeqNum >= (WinSize - 1)) {
+			pTS->RxIndicateSeq = SeqNum + 1 -WinSize;
+		} else {
+			pTS->RxIndicateSeq = 4095 - (WinSize - (SeqNum +1)) + 1;
+		}
+		RTLLIB_DEBUG(RTLLIB_DL_REORDER, "Window Shift! IndicateSeq: %d, NewSeq: %d\n",pTS->RxIndicateSeq, SeqNum);
+	}
+
+	/*
+	 * Indication process.
+	 * After Packet dropping and Sliding Window shifting as above, we can now just indicate the packets
+	 * with the SeqNum smaller than latest WinStart and buffer other packets.
+	 */
+	/* For Rx Reorder condition:
+	 * 1. All packets with SeqNum smaller than WinStart => Indicate
+	 * 2. All packets with SeqNum larger than or equal to WinStart => Buffer it.
+	 */
+	if (bMatchWinStart) {
+		/* Current packet is going to be indicated.*/
+		RTLLIB_DEBUG(RTLLIB_DL_REORDER, "Packets indication!! IndicateSeq: %d, NewSeq: %d\n",\
+				pTS->RxIndicateSeq, SeqNum);
+		prxbIndicateArray[0] = prxb;
+		index = 1;
+	} else {
+		/* Current packet is going to be inserted into pending list.*/
+		if (!list_empty(&ieee->RxReorder_Unused_List)) {
+			pReorderEntry = (PRX_REORDER_ENTRY)list_entry(ieee->RxReorder_Unused_List.next,RX_REORDER_ENTRY,List);
+			list_del_init(&pReorderEntry->List);
+
+			/* Make a reorder entry and insert into a the packet list.*/
+			pReorderEntry->SeqNum = SeqNum;
+			pReorderEntry->prxb = prxb;
+
+#if 1
+			if (!AddReorderEntry(pTS, pReorderEntry)) {
+				RTLLIB_DEBUG(RTLLIB_DL_REORDER, "%s(): Duplicate packet is dropped!! IndicateSeq: %d, NewSeq: %d\n",
+					__func__, pTS->RxIndicateSeq, SeqNum);
+				list_add_tail(&pReorderEntry->List,&ieee->RxReorder_Unused_List);
+				{
+					int i;
+					for (i =0; i < prxb->nr_subframes; i++) {
+						dev_kfree_skb(prxb->subframes[i]);
+					}
+					kfree(prxb);
+					prxb = NULL;
+				}
+			} else {
+				RTLLIB_DEBUG(RTLLIB_DL_REORDER,
+					 "Pkt insert into buffer!! IndicateSeq: %d, NewSeq: %d\n",pTS->RxIndicateSeq, SeqNum);
+			}
+#endif
+		}
+		else {
+			/*
+			 * Packets are dropped if there is not enough reorder entries.
+			 * This part shall be modified!! We can just indicate all the
+			 * packets in buffer and get reorder entries.
+			 */
+			RTLLIB_DEBUG(RTLLIB_DL_ERR, "RxReorderIndicatePacket(): There is no reorder entry!! Packet is dropped!!\n");
+			{
+				int i;
+				for (i =0; i < prxb->nr_subframes; i++) {
+					dev_kfree_skb(prxb->subframes[i]);
+				}
+				kfree(prxb);
+				prxb = NULL;
+			}
+		}
+	}
+
+	/* Check if there is any packet need indicate.*/
+	while(!list_empty(&pTS->RxPendingPktList)) {
+		RTLLIB_DEBUG(RTLLIB_DL_REORDER,"%s(): start RREORDER indicate\n",__func__);
+#if 1
+		pReorderEntry = (PRX_REORDER_ENTRY)list_entry(pTS->RxPendingPktList.prev,RX_REORDER_ENTRY,List);
+		if ( SN_LESS(pReorderEntry->SeqNum, pTS->RxIndicateSeq) ||
+				SN_EQUAL(pReorderEntry->SeqNum, pTS->RxIndicateSeq))
+		{
+			/* This protect buffer from overflow. */
+			if (index >= REORDER_WIN_SIZE) {
+				RTLLIB_DEBUG(RTLLIB_DL_ERR, "RxReorderIndicatePacket(): Buffer overflow!! \n");
+				bPktInBuf = true;
+				break;
+			}
+
+			list_del_init(&pReorderEntry->List);
+
+			if (SN_EQUAL(pReorderEntry->SeqNum, pTS->RxIndicateSeq))
+				pTS->RxIndicateSeq = (pTS->RxIndicateSeq + 1) % 4096;
+
+			prxbIndicateArray[index] = pReorderEntry->prxb;
+			RTLLIB_DEBUG(RTLLIB_DL_REORDER,"%s(): Indicate SeqNum %d!\n",__func__, pReorderEntry->SeqNum);
+			index++;
+
+			list_add_tail(&pReorderEntry->List,&ieee->RxReorder_Unused_List);
+		} else {
+			bPktInBuf = true;
+			break;
+		}
+#endif
+	}
+
+	/* Handling pending timer. Set this timer to prevent from long time Rx buffering.*/
+	if (index>0) {
+		if (timer_pending(&pTS->RxPktPendingTimer)){
+			del_timer_sync(&pTS->RxPktPendingTimer);
+		}
+		pTS->RxTimeoutIndicateSeq = 0xffff;
+
+		if (index>REORDER_WIN_SIZE){
+			RTLLIB_DEBUG(RTLLIB_DL_ERR, "RxReorderIndicatePacket(): Rx Reorer buffer full!! \n");
+			spin_unlock_irqrestore(&(ieee->reorder_spinlock), flags);
+			return;
+		}
+		rtllib_indicate_packets(ieee, prxbIndicateArray, index);
+		bPktInBuf = false;
+	}
+
+	if (bPktInBuf && pTS->RxTimeoutIndicateSeq==0xffff) {
+		RTLLIB_DEBUG(RTLLIB_DL_REORDER,"%s(): SET rx timeout timer\n", __func__);
+		pTS->RxTimeoutIndicateSeq = pTS->RxIndicateSeq;
+		mod_timer(&pTS->RxPktPendingTimer,  jiffies + MSECS(pHTInfo->RxReorderPendingTime));
+	}
+	spin_unlock_irqrestore(&(ieee->reorder_spinlock), flags);
+}
+
+u8 parse_subframe(struct rtllib_device* ieee,struct sk_buff *skb,
+                  struct rtllib_rx_stats *rx_stats,
+		  struct rtllib_rxb *rxb,u8* src,u8* dst)
+{
+	struct rtllib_hdr_3addr  *hdr = (struct rtllib_hdr_3addr* )skb->data;
+	u16		fc = le16_to_cpu(hdr->frame_ctl);
+
+	u16		LLCOffset= sizeof(struct rtllib_hdr_3addr);
+	u16		ChkLength;
+	bool		bIsAggregateFrame = false;
+	u16		nSubframe_Length;
+	u8		nPadding_Length = 0;
+	u16		SeqNum=0;
+	struct sk_buff *sub_skb;
+	u8             *data_ptr;
+	/* just for debug purpose */
+	SeqNum = WLAN_GET_SEQ_SEQ(le16_to_cpu(hdr->seq_ctl));
+	if ((RTLLIB_QOS_HAS_SEQ(fc))&&\
+			(((frameqos *)(skb->data + RTLLIB_3ADDR_LEN))->field.reserved)) {
+		bIsAggregateFrame = true;
+	}
+
+	if (RTLLIB_QOS_HAS_SEQ(fc)) {
+		LLCOffset += 2;
+	}
+	if (rx_stats->bContainHTC) {
+		LLCOffset += sHTCLng;
+	}
+
+	ChkLength = LLCOffset;/* + (Frame_WEP(frame)!=0 ?Adapter->MgntInfo.SecurityInfo.EncryptionHeadOverhead:0);*/
+
+	if ( skb->len <= ChkLength ) {
+		return 0;
+	}
+
+	skb_pull(skb, LLCOffset);
+	ieee->bIsAggregateFrame = bIsAggregateFrame;
+	if (!bIsAggregateFrame) {
+		rxb->nr_subframes = 1;
+
+		/* altered by clark 3/30/2010
+		 * The buffer size of the skb indicated to upper layer
+		 * must be less than 5000, or the defraged IP datagram
+		 * in the IP layer will exceed "ipfrag_high_tresh" and be
+		 * discarded. so there must not use the function
+		 * "skb_copy" and "skb_clone" for "skb".
+		 */
+
+		/* Allocate new skb for releasing to upper layer */
+		sub_skb = dev_alloc_skb(RTLLIB_SKBBUFFER_SIZE);
+		skb_reserve(sub_skb, 12);
+		data_ptr = (u8 *)skb_put(sub_skb, skb->len);
+		memcpy(data_ptr, skb->data, skb->len);
+		sub_skb->dev = ieee->dev;
+
+		rxb->subframes[0] = sub_skb;
+
+		memcpy(rxb->src,src,ETH_ALEN);
+		memcpy(rxb->dst,dst,ETH_ALEN);
+		rxb->subframes[0]->dev = ieee->dev;
+		return 1;
+	} else {
+		rxb->nr_subframes = 0;
+		memcpy(rxb->src,src,ETH_ALEN);
+		memcpy(rxb->dst,dst,ETH_ALEN);
+		while(skb->len > ETHERNET_HEADER_SIZE) {
+			/* Offset 12 denote 2 mac address */
+			nSubframe_Length = *((u16*)(skb->data + 12));
+			nSubframe_Length = (nSubframe_Length>>8) + (nSubframe_Length<<8);
+
+			if (skb->len<(ETHERNET_HEADER_SIZE + nSubframe_Length)) {
+				printk("%s: A-MSDU parse error!! pRfd->nTotalSubframe : %d\n",\
+						__func__,rxb->nr_subframes);
+				printk("%s: A-MSDU parse error!! Subframe Length: %d\n",__func__, nSubframe_Length);
+				printk("nRemain_Length is %d and nSubframe_Length is : %d\n",skb->len,nSubframe_Length);
+				printk("The Packet SeqNum is %d\n",SeqNum);
+				return 0;
+			}
+
+			/* move the data point to data content */
+			skb_pull(skb, ETHERNET_HEADER_SIZE);
+
+			/* altered by clark 3/30/2010
+			 * The buffer size of the skb indicated to upper layer
+			 * must be less than 5000, or the defraged IP datagram
+			 * in the IP layer will exceed "ipfrag_high_tresh" and be
+			 * discarded. so there must not use the function
+			 * "skb_copy" and "skb_clone" for "skb".
+			 */
+
+			/* Allocate new skb for releasing to upper layer */
+			sub_skb = dev_alloc_skb(nSubframe_Length + 12);
+			skb_reserve(sub_skb, 12);
+			data_ptr = (u8 *)skb_put(sub_skb, nSubframe_Length);
+			memcpy(data_ptr,skb->data,nSubframe_Length);
+
+			sub_skb->dev = ieee->dev;
+			rxb->subframes[rxb->nr_subframes++] = sub_skb;
+			if (rxb->nr_subframes >= MAX_SUBFRAME_COUNT) {
+				RTLLIB_DEBUG_RX("ParseSubframe(): Too many Subframes! Packets dropped!\n");
+				break;
+			}
+			skb_pull(skb,nSubframe_Length);
+
+			if (skb->len != 0) {
+				nPadding_Length = 4 - ((nSubframe_Length + ETHERNET_HEADER_SIZE) % 4);
+				if (nPadding_Length == 4) {
+					nPadding_Length = 0;
+				}
+
+				if (skb->len < nPadding_Length) {
+					return 0;
+				}
+
+				skb_pull(skb,nPadding_Length);
+			}
+		}
+
+		return rxb->nr_subframes;
+	}
+}
+
+
+size_t rtllib_rx_get_hdrlen(struct rtllib_device *ieee, struct sk_buff *skb,
+		 struct rtllib_rx_stats *rx_stats)
+{
+	struct rtllib_hdr_4addr *hdr = (struct rtllib_hdr_4addr *)skb->data;
+	u16 fc = le16_to_cpu(hdr->frame_ctl);
+	size_t hdrlen = 0;
+
+	hdrlen = rtllib_get_hdrlen(fc);
+	if (HTCCheck(ieee, skb->data)) {
+		if (net_ratelimit())
+			printk("%s: find HTCControl!\n", __func__);
+		hdrlen += 4;
+		rx_stats->bContainHTC = 1;
+	}
+
+	 if (RTLLIB_QOS_HAS_SEQ(fc))
+		rx_stats->bIsQosData = 1;
+
+	return hdrlen;
+}
+
+int rtllib_rx_check_duplicate(struct rtllib_device *ieee, struct sk_buff *skb, u8 multicast)
+{
+	struct rtllib_hdr_4addr *hdr = (struct rtllib_hdr_4addr *)skb->data;
+	u16 fc, sc;
+	u8 frag, type, stype;
+
+	fc = le16_to_cpu(hdr->frame_ctl);
+	type = WLAN_FC_GET_TYPE(fc);
+	stype = WLAN_FC_GET_STYPE(fc);
+	sc = le16_to_cpu(hdr->seq_ctl);
+	frag = WLAN_GET_SEQ_FRAG(sc);
+
+	if ( (ieee->pHTInfo->bCurRxReorderEnable == false) ||
+		!ieee->current_network.qos_data.active ||
+		!IsDataFrame(skb->data) ||
+		IsLegacyDataFrame(skb->data)) {
+		if (!((type == RTLLIB_FTYPE_MGMT) && (stype == RTLLIB_STYPE_BEACON))){
+			if (is_duplicate_packet(ieee, hdr)){
+				return -1;
+			}
+		}
+	} else {
+		PRX_TS_RECORD pRxTS = NULL;
+		if (GetTs(ieee, (PTS_COMMON_INFO*) &pRxTS, hdr->addr2,
+			(u8)Frame_QoSTID((u8*)(skb->data)), RX_DIR, true)) {
+			if ((fc & (1<<11)) && (frag == pRxTS->RxLastFragNum) &&
+			    (WLAN_GET_SEQ_SEQ(sc) == pRxTS->RxLastSeqNum)) {
+				return -1;
+			} else {
+				pRxTS->RxLastFragNum = frag;
+				pRxTS->RxLastSeqNum = WLAN_GET_SEQ_SEQ(sc);
+			}
+		} else {
+			RTLLIB_DEBUG(RTLLIB_DL_ERR, "ERR!!%s(): No TS!! Skip the check!!\n",__func__);
+			return -1;
+		}
+	}
+
+	return 0;
+}
+void rtllib_rx_extract_addr(struct rtllib_device *ieee, struct rtllib_hdr_4addr *hdr, u8 *dst, u8 *src, u8 *bssid)
+{
+	u16 fc = le16_to_cpu(hdr->frame_ctl);
+
+	switch (fc & (RTLLIB_FCTL_FROMDS | RTLLIB_FCTL_TODS)) {
+		case RTLLIB_FCTL_FROMDS:
+			memcpy(dst, hdr->addr1, ETH_ALEN);
+			memcpy(src, hdr->addr3, ETH_ALEN);
+			memcpy(bssid, hdr->addr2, ETH_ALEN);
+			break;
+		case RTLLIB_FCTL_TODS:
+			memcpy(dst, hdr->addr3, ETH_ALEN);
+			memcpy(src, hdr->addr2, ETH_ALEN);
+			memcpy(bssid, hdr->addr1, ETH_ALEN);
+			break;
+		case RTLLIB_FCTL_FROMDS | RTLLIB_FCTL_TODS:
+			memcpy(dst, hdr->addr3, ETH_ALEN);
+			memcpy(src, hdr->addr4, ETH_ALEN);
+			memcpy(bssid, ieee->current_network.bssid, ETH_ALEN);
+			break;
+		case 0:
+			memcpy(dst, hdr->addr1, ETH_ALEN);
+			memcpy(src, hdr->addr2, ETH_ALEN);
+			memcpy(bssid, hdr->addr3, ETH_ALEN);
+			break;
+	}
+}
+int rtllib_rx_data_filter(struct rtllib_device *ieee, u16 fc, u8 *dst, u8 *src, u8 *bssid, u8 *addr2)
+{
+	u8 zero_addr[ETH_ALEN] = {0};
+	u8 type, stype;
+
+	type = WLAN_FC_GET_TYPE(fc);
+	stype = WLAN_FC_GET_STYPE(fc);
+
+	/* Filter frames from different BSS */
+	if (((fc & RTLLIB_FCTL_DSTODS) != RTLLIB_FCTL_DSTODS)
+                && (compare_ether_addr(ieee->current_network.bssid, bssid) != 0)
+                && memcmp(ieee->current_network.bssid, zero_addr, ETH_ALEN)) {
+		return -1;
+	}
+
+	/* Filter packets sent by an STA that will be forwarded by AP */
+	if ( ieee->IntelPromiscuousModeInfo.bPromiscuousOn  &&
+                ieee->IntelPromiscuousModeInfo.bFilterSourceStationFrame ) {
+		if ((fc & RTLLIB_FCTL_TODS) && !(fc & RTLLIB_FCTL_FROMDS) &&
+			(compare_ether_addr(dst, ieee->current_network.bssid) != 0) &&
+			(compare_ether_addr(bssid, ieee->current_network.bssid) == 0)) {
+			return -1;
+		}
+	}
+
+	/* Nullfunc frames may have PS-bit set, so they must be passed to
+	 * hostap_handle_sta_rx() before being dropped here. */
+	if (!ieee->IntelPromiscuousModeInfo.bPromiscuousOn){
+		if (stype != RTLLIB_STYPE_DATA &&
+		    stype != RTLLIB_STYPE_DATA_CFACK &&
+		    stype != RTLLIB_STYPE_DATA_CFPOLL &&
+		    stype != RTLLIB_STYPE_DATA_CFACKPOLL&&
+		    stype != RTLLIB_STYPE_QOS_DATA
+		    ) {
+			if (stype != RTLLIB_STYPE_NULLFUNC)
+				RTLLIB_DEBUG_DROP(
+					"RX: dropped data frame "
+					"with no data (type=0x%02x, "
+					"subtype=0x%02x)\n",
+					type, stype);
+			return -1;
+		}
+	}
+
+	if (ieee->iw_mode != IW_MODE_MESH) {
+		/* packets from our adapter are dropped (echo) */
+		if (!memcmp(src, ieee->dev->dev_addr, ETH_ALEN))
+			return -1;
+
+		/* {broad,multi}cast packets to our BSS go through */
+		if (is_multicast_ether_addr(dst) || is_broadcast_ether_addr(dst)) {
+			if (memcmp(bssid, ieee->current_network.bssid, ETH_ALEN)) {
+				return -1;
+			}
+		}
+	}
+	return 0;
+}
+int rtllib_rx_get_crypt(
+		struct rtllib_device *ieee,
+		struct sk_buff *skb,
+		struct rtllib_crypt_data **crypt,
+		size_t hdrlen)
+{
+	struct rtllib_hdr_4addr *hdr = (struct rtllib_hdr_4addr *)skb->data;
+	u16 fc = le16_to_cpu(hdr->frame_ctl);
+	int idx = 0;
+
+	if (ieee->host_decrypt) {
+		if (skb->len >= hdrlen + 3)
+			idx = skb->data[hdrlen + 3] >> 6;
+
+		*crypt = ieee->crypt[idx];
+		/* allow NULL decrypt to indicate an station specific override
+		 * for default encryption */
+		if (*crypt && ((*crypt)->ops == NULL ||
+			      (*crypt)->ops->decrypt_mpdu == NULL))
+			*crypt = NULL;
+
+		if (!*crypt && (fc & RTLLIB_FCTL_WEP)) {
+			/* This seems to be triggered by some (multicast?)
+			 * frames from other than current BSS, so just drop the
+			 * frames silently instead of filling system log with
+			 * these reports. */
+			RTLLIB_DEBUG_DROP("Decryption failed (not set)"
+					     " (SA=" MAC_FMT ")\n",
+					     MAC_ARG(hdr->addr2));
+			ieee->ieee_stats.rx_discards_undecryptable++;
+			return -1;
+		}
+	}
+
+	return 0;
+}
+int rtllib_rx_decrypt(
+		struct rtllib_device *ieee,
+		struct sk_buff *skb,
+		struct rtllib_rx_stats *rx_stats,
+		struct rtllib_crypt_data *crypt,
+		size_t hdrlen)
+{
+	struct rtllib_hdr_4addr *hdr;
+	int keyidx = 0;
+	u16 fc, sc;
+	u8 frag;
+
+	hdr = (struct rtllib_hdr_4addr *)skb->data;
+	fc = le16_to_cpu(hdr->frame_ctl);
+	sc = le16_to_cpu(hdr->seq_ctl);
+	frag = WLAN_GET_SEQ_FRAG(sc);
+
+	if ((!rx_stats->Decrypted)){
+		ieee->need_sw_enc = 1;
+	}else{
+		ieee->need_sw_enc = 0;
+	}
+
+	if (ieee->host_decrypt && (fc & RTLLIB_FCTL_WEP) &&
+	    ((keyidx = rtllib_rx_frame_decrypt(ieee, skb, crypt)) < 0)) {
+		printk("%s: decrypt frame error\n", __func__);
+		return -1;
+	}
+
+	hdr = (struct rtllib_hdr_4addr *) skb->data;
+	if ((frag != 0 || (fc & RTLLIB_FCTL_MOREFRAGS))) {
+		int flen;
+		struct sk_buff *frag_skb = rtllib_frag_cache_get(ieee, hdr);
+		RTLLIB_DEBUG_FRAG("Rx Fragment received (%u)\n", frag);
+
+		if (!frag_skb) {
+			RTLLIB_DEBUG(RTLLIB_DL_RX | RTLLIB_DL_FRAG,
+					"Rx cannot get skb from fragment "
+					"cache (morefrag=%d seq=%u frag=%u)\n",
+					(fc & RTLLIB_FCTL_MOREFRAGS) != 0,
+					WLAN_GET_SEQ_SEQ(sc), frag);
+			return -1;
+		}
+		flen = skb->len;
+		if (frag != 0)
+			flen -= hdrlen;
+
+		if (frag_skb->tail + flen > frag_skb->end) {
+			printk(KERN_WARNING "%s: host decrypted and "
+			       "reassembled frame did not fit skb\n",
+			       __func__);
+			rtllib_frag_cache_invalidate(ieee, hdr);
+			return -1;
+		}
+
+		if (frag == 0) {
+			/* copy first fragment (including full headers) into
+			 * beginning of the fragment cache skb */
+			memcpy(skb_put(frag_skb, flen), skb->data, flen);
+		} else {
+			/* append frame payload to the end of the fragment
+			 * cache skb */
+			memcpy(skb_put(frag_skb, flen), skb->data + hdrlen,
+			       flen);
+		}
+		dev_kfree_skb_any(skb);
+		skb = NULL;
+
+		if (fc & RTLLIB_FCTL_MOREFRAGS) {
+			/* more fragments expected - leave the skb in fragment
+			 * cache for now; it will be delivered to upper layers
+			 * after all fragments have been received */
+			return -2;
+		}
+
+		/* this was the last fragment and the frame will be
+		 * delivered, so remove skb from fragment cache */
+		skb = frag_skb;
+		hdr = (struct rtllib_hdr_4addr *) skb->data;
+		rtllib_frag_cache_invalidate(ieee, hdr);
+	}
+
+	/* skb: hdr + (possible reassembled) full MSDU payload; possibly still
+	 * encrypted/authenticated */
+	if (ieee->host_decrypt && (fc & RTLLIB_FCTL_WEP) &&
+		rtllib_rx_frame_decrypt_msdu(ieee, skb, keyidx, crypt))
+	{
+		printk("%s: ==>decrypt msdu error\n", __func__);
+		return -1;
+	}
+
+	hdr = (struct rtllib_hdr_4addr *) skb->data;
+	if (crypt && !(fc & RTLLIB_FCTL_WEP) && !ieee->open_wep) {
+		if (/*ieee->ieee802_1x &&*/
+		    rtllib_is_eapol_frame(ieee, skb, hdrlen)) {
+
+#ifdef CONFIG_RTLLIB_DEBUG
+			/* pass unencrypted EAPOL frames even if encryption is
+			 * configured */
+			struct eapol *eap = (struct eapol *)(skb->data +
+				24);
+			RTLLIB_DEBUG_EAP("RX: IEEE 802.1X EAPOL frame: %s\n",
+						eap_get_type(eap->type));
+#endif
+		} else {
+			RTLLIB_DEBUG_DROP(
+				"encryption configured, but RX "
+				"frame not encrypted (SA=" MAC_FMT ")\n",
+				MAC_ARG(hdr->addr2));
+			return -1;
+		}
+	}
+
+#ifdef CONFIG_RTLLIB_DEBUG
+	if (crypt && !(fc & RTLLIB_FCTL_WEP) &&
+	    rtllib_is_eapol_frame(ieee, skb, hdrlen)) {
+			struct eapol *eap = (struct eapol *)(skb->data +
+				24);
+			RTLLIB_DEBUG_EAP("RX: IEEE 802.1X EAPOL frame: %s\n",
+						eap_get_type(eap->type));
+	}
+#endif
+
+	if (crypt && !(fc & RTLLIB_FCTL_WEP) && !ieee->open_wep &&
+	    !rtllib_is_eapol_frame(ieee, skb, hdrlen)) {
+		RTLLIB_DEBUG_DROP(
+			"dropped unencrypted RX data "
+			"frame from " MAC_FMT
+			" (drop_unencrypted=1)\n",
+			MAC_ARG(hdr->addr2));
+		return -1;
+	}
+
+	if (rtllib_is_eapol_frame(ieee, skb, hdrlen)) {
+		printk(KERN_WARNING "RX: IEEE802.1X EAPOL frame!\n");
+	}
+
+	return 0;
+}
+void rtllib_rx_check_leave_lps(struct rtllib_device *ieee, u8 unicast, u8 nr_subframes)
+{
+#if !defined(RTL8192SU) && !defined(RTL8192U)
+	if (unicast){
+
+		if ((ieee->state == RTLLIB_LINKED) /*&& !MgntInitAdapterInProgress(pMgntInfo)*/)
+		{
+			if (	((ieee->LinkDetectInfo.NumRxUnicastOkInPeriod +ieee->LinkDetectInfo.NumTxOkInPeriod) > 8 ) ||
+				(ieee->LinkDetectInfo.NumRxUnicastOkInPeriod > 2) )
+			{
+				if (ieee->LeisurePSLeave)
+					ieee->LeisurePSLeave(ieee->dev);
+			}
+		}
+	}
+#endif
+	ieee->last_rx_ps_time = jiffies;
+}
+void rtllib_rx_indicate_pkt_legacy(
+		struct rtllib_device *ieee,
+		struct rtllib_rx_stats *rx_stats,
+		struct rtllib_rxb* rxb,
+		u8 *dst,
+		u8 *src)
+{
+	struct net_device *dev = ieee->dev;
+	u16 ethertype;
+	int i = 0;
+
+	if (rxb == NULL){
+		printk("%s: rxb is NULL!!\n", __func__);
+		return ;
+	}
+
+	for (i = 0; i<rxb->nr_subframes; i++) {
+		struct sk_buff *sub_skb = rxb->subframes[i];
+
+		if (sub_skb) {
+			/* convert hdr + possible LLC headers into Ethernet header */
+			ethertype = (sub_skb->data[6] << 8) | sub_skb->data[7];
+			if (sub_skb->len >= 8 &&
+					((memcmp(sub_skb->data, rfc1042_header, SNAP_SIZE) == 0 &&
+					  ethertype != ETH_P_AARP && ethertype != ETH_P_IPX) ||
+					 memcmp(sub_skb->data, bridge_tunnel_header, SNAP_SIZE) == 0)) {
+				/* remove RFC1042 or Bridge-Tunnel encapsulation and
+				 * replace EtherType */
+				skb_pull(sub_skb, SNAP_SIZE);
+				memcpy(skb_push(sub_skb, ETH_ALEN), src, ETH_ALEN);
+				memcpy(skb_push(sub_skb, ETH_ALEN), dst, ETH_ALEN);
+			} else {
+				u16 len;
+				/* Leave Ethernet header part of hdr and full payload */
+				len = htons(sub_skb->len);
+				memcpy(skb_push(sub_skb, 2), &len, 2);
+				memcpy(skb_push(sub_skb, ETH_ALEN), src, ETH_ALEN);
+				memcpy(skb_push(sub_skb, ETH_ALEN), dst, ETH_ALEN);
+			}
+
+			ieee->stats.rx_packets++;
+			ieee->stats.rx_bytes += sub_skb->len;
+
+			if (is_multicast_ether_addr(dst)) {
+				ieee->stats.multicast++;
+			}
+
+			/* Indicat the packets to upper layer */
+			memset(sub_skb->cb, 0, sizeof(sub_skb->cb));
+			sub_skb->protocol = eth_type_trans(sub_skb, dev);
+			sub_skb->dev = dev;
+			sub_skb->dev->stats.rx_packets++;
+			sub_skb->dev->stats.rx_bytes += sub_skb->len;
+#ifdef TCP_CSUM_OFFLOAD_RX
+			if ( rx_stats->tcp_csum_valid)
+				sub_skb->ip_summed = CHECKSUM_UNNECESSARY;
+			else
+				sub_skb->ip_summed = CHECKSUM_NONE;
+#else
+			sub_skb->ip_summed = CHECKSUM_NONE; /* 802.11 crc not sufficient */
+#endif
+			netif_rx(sub_skb);
+		}
+	}
+	kfree(rxb);
+	rxb = NULL;
+}
+int rtllib_rx_InfraAdhoc(struct rtllib_device *ieee, struct sk_buff *skb,
+		 struct rtllib_rx_stats *rx_stats)
+{
+	struct net_device *dev = ieee->dev;
+	struct rtllib_hdr_4addr *hdr = (struct rtllib_hdr_4addr *)skb->data;
+	struct rtllib_crypt_data *crypt = NULL;
+#if defined(RTL8192U) || defined(RTL8192SU) || defined(RTL8192SE)
+	struct sta_info * psta = NULL;
+#endif
+	struct rtllib_rxb* rxb = NULL;
+	PRX_TS_RECORD pTS = NULL;
+	u16 fc, sc, SeqNum = 0;
+	u8 type, stype, multicast = 0, unicast = 0, nr_subframes = 0, TID = 0;
+	u8 dst[ETH_ALEN], src[ETH_ALEN], bssid[ETH_ALEN] = {0}, *payload;
+	size_t hdrlen = 0;
+	bool bToOtherSTA = false;
+	int ret = 0, i = 0;
+
+	hdr = (struct rtllib_hdr_4addr *)skb->data;
+	fc = le16_to_cpu(hdr->frame_ctl);
+	type = WLAN_FC_GET_TYPE(fc);
+	stype = WLAN_FC_GET_STYPE(fc);
+	sc = le16_to_cpu(hdr->seq_ctl);
+
+	/*Filter pkt not to me*/
+	multicast = is_multicast_ether_addr(hdr->addr1)|is_broadcast_ether_addr(hdr->addr1);
+	unicast = !multicast;
+	if (unicast && (compare_ether_addr(dev->dev_addr, hdr->addr1) != 0)) {
+		if (ieee->bNetPromiscuousMode)
+			bToOtherSTA = true;
+		else
+			goto rx_dropped;
+	}
+
+	/*Filter pkt has too small length */
+	hdrlen = rtllib_rx_get_hdrlen(ieee, skb, rx_stats);
+	if (skb->len < hdrlen){
+		printk("%s():ERR!!! skb->len is smaller than hdrlen\n",__func__);
+		goto rx_dropped;
+	}
+
+	/* Filter Duplicate pkt */
+	ret = rtllib_rx_check_duplicate(ieee, skb, multicast);
+	if (ret < 0)
+		goto rx_dropped;
+
+	/* Filter CTRL Frame */
+	if (type == RTLLIB_FTYPE_CTL) {
+		goto rx_dropped;
+	}
+
+	/* Filter MGNT Frame */
+	if (type == RTLLIB_FTYPE_MGMT) {
+		if (bToOtherSTA)
+			goto rx_dropped;
+		if (rtllib_rx_frame_mgmt(ieee, skb, rx_stats, type, stype))
+			goto rx_dropped;
+		else
+			goto rx_exit;
+	}
+
+	/* Filter WAPI DATA Frame */
+
+	/* Update statstics for AP roaming */
+	if (!bToOtherSTA){
+		ieee->LinkDetectInfo.NumRecvDataInPeriod++;
+		ieee->LinkDetectInfo.NumRxOkInPeriod++;
+	}
+	dev->last_rx = jiffies;
+
+	/* Data frame - extract src/dst addresses */
+	rtllib_rx_extract_addr(ieee, hdr, dst, src, bssid);
+
+	/* Filter Data frames */
+	ret = rtllib_rx_data_filter(ieee, fc, dst, src, bssid, hdr->addr2);
+	if (ret < 0)
+		goto rx_dropped;
+
+	if (skb->len == hdrlen){
+		goto rx_dropped;
+	}
+
+	/* Send pspoll based on moredata */
+	if ((ieee->iw_mode == IW_MODE_INFRA)  && (ieee->sta_sleep == LPS_IS_SLEEP)
+		&& (ieee->polling) && (!bToOtherSTA)) {
+		if (WLAN_FC_MORE_DATA(fc)) {
+			/* more data bit is set, let's request a new frame from the AP */
+			rtllib_sta_ps_send_pspoll_frame(ieee);
+		} else {
+			ieee->polling =  false;
+		}
+	}
+
+#if defined(RTL8192U) || defined(RTL8192SU) || defined(RTL8192SE)
+	if (ieee->iw_mode == IW_MODE_ADHOC){
+		psta = GetStaInfo(ieee, src);
+		if (NULL != psta)
+			psta->LastActiveTime = jiffies;
+	}
+#endif
+
+	/* Get crypt if encrypted */
+	ret = rtllib_rx_get_crypt(ieee, skb, &crypt, hdrlen);
+	if (ret == -1)
+		goto rx_dropped;
+
+	/* Decrypt data frame (including reassemble) */
+	ret = rtllib_rx_decrypt(ieee, skb, rx_stats, crypt, hdrlen);
+	if (ret == -1)
+		goto rx_dropped;
+	else if (ret == -2)
+		goto rx_exit;
+
+	/* Get TS for Rx Reorder  */
+	hdr = (struct rtllib_hdr_4addr *) skb->data;
+	if (ieee->current_network.qos_data.active && IsQoSDataFrame(skb->data)
+		&& !is_multicast_ether_addr(hdr->addr1) && !is_broadcast_ether_addr(hdr->addr1)
+		&& (!bToOtherSTA))
+	{
+		TID = Frame_QoSTID(skb->data);
+		SeqNum = WLAN_GET_SEQ_SEQ(sc);
+		GetTs(ieee,(PTS_COMMON_INFO*) &pTS,hdr->addr2,TID,RX_DIR,true);
+		if (TID !=0 && TID !=3){
+			ieee->bis_any_nonbepkts = true;
+		}
+	}
+
+	/* Parse rx data frame (For AMSDU) */
+	/* skb: hdr + (possible reassembled) full plaintext payload */
+	payload = skb->data + hdrlen;
+	rxb = (struct rtllib_rxb*)kmalloc(sizeof(struct rtllib_rxb),GFP_ATOMIC);
+	if (rxb == NULL)
+	{
+		RTLLIB_DEBUG(RTLLIB_DL_ERR,"%s(): kmalloc rxb error\n",__func__);
+		goto rx_dropped;
+	}
+	/* to parse amsdu packets */
+	/* qos data packets & reserved bit is 1 */
+	if (parse_subframe(ieee,skb,rx_stats,rxb,src,dst) == 0) {
+		/* only to free rxb, and not submit the packets to upper layer */
+		for (i =0; i < rxb->nr_subframes; i++) {
+			dev_kfree_skb(rxb->subframes[i]);
+		}
+		kfree(rxb);
+		rxb = NULL;
+		goto rx_dropped;
+	}
+
+	/* Update WAPI PN */
+
+	/* Check if leave LPS */
+	if (!bToOtherSTA){
+		if (ieee->bIsAggregateFrame)
+			nr_subframes = rxb->nr_subframes;
+		else
+			nr_subframes = 1;
+		if (unicast)
+			ieee->LinkDetectInfo.NumRxUnicastOkInPeriod += nr_subframes;
+		rtllib_rx_check_leave_lps(ieee, unicast, nr_subframes);
+	}
+
+	/* Indicate packets to upper layer or Rx Reorder */
+	if (ieee->pHTInfo->bCurRxReorderEnable == false ||pTS == NULL || bToOtherSTA){
+		rtllib_rx_indicate_pkt_legacy(ieee, rx_stats, rxb, dst, src);
+	}else{
+#ifdef TCP_CSUM_OFFLOAD_RX
+		rxb->tcp_csum_valid = rx_stats->tcp_csum_valid;
+#endif
+		RxReorderIndicatePacket(ieee, rxb, pTS, SeqNum);
+	}
+
+	dev_kfree_skb(skb);
+
+ rx_exit:
+	return 1;
+
+ rx_dropped:
+	if (rxb != NULL)
+	{
+		kfree(rxb);
+		rxb = NULL;
+	}
+	ieee->stats.rx_dropped++;
+
+	/* Returning 0 indicates to caller that we have not handled the SKB--
+	 * so it is still allocated and can be used again by underlying
+	 * hardware as a DMA target */
+	return 0;
+}
+
+int rtllib_rx_Master(struct rtllib_device *ieee, struct sk_buff *skb,
+		 struct rtllib_rx_stats *rx_stats)
+{
+	return 0;
+}
+int rtllib_rx_Monitor(struct rtllib_device *ieee, struct sk_buff *skb,
+		 struct rtllib_rx_stats *rx_stats)
+{
+	struct rtllib_hdr_4addr *hdr = (struct rtllib_hdr_4addr *)skb->data;
+	u16 fc = le16_to_cpu(hdr->frame_ctl);
+	size_t hdrlen = rtllib_get_hdrlen(fc);
+
+	if (skb->len < hdrlen){
+		printk("%s():ERR!!! skb->len is smaller than hdrlen\n", __func__);
+		return 0;
+	}
+
+	if (HTCCheck(ieee, skb->data)) {
+		if (net_ratelimit())
+			printk("%s: Find HTCControl!\n", __func__);
+		hdrlen += 4;
+	}
+
+#if WIRELESS_EXT > 15
+	rtllib_monitor_rx(ieee, skb, rx_stats, hdrlen);
+	ieee->stats.rx_packets++;
+	ieee->stats.rx_bytes += skb->len;
+#endif
+	return 1;
+}
+
+int rtllib_rx_Mesh(struct rtllib_device *ieee, struct sk_buff *skb,
+		 struct rtllib_rx_stats *rx_stats)
+{
+	return 0;
+}
+
+#if 1
+/* All received frames are sent to this function. @skb contains the frame in
+ * IEEE 802.11 format, i.e., in the format it was sent over air.
+ * This function is called only as a tasklet (software IRQ). */
+int rtllib_rx(struct rtllib_device *ieee, struct sk_buff *skb,
+		 struct rtllib_rx_stats *rx_stats)
+{
+	int ret = 0;
+
+	if ((NULL==ieee) || (NULL==skb) || (NULL==rx_stats)){
+		printk(KERN_INFO "%s: Input parameters NULL!\n", __func__);
+		goto rx_dropped;
+	}
+	if (skb->len < 10) {
+		printk(KERN_INFO "%s: SKB length < 10 \n", __func__);
+		goto rx_dropped;
+	}
+
+	switch (ieee->iw_mode) {
+	case IW_MODE_ADHOC:
+	case IW_MODE_INFRA:
+		ret = rtllib_rx_InfraAdhoc(ieee, skb, rx_stats);
+		break;
+	case IW_MODE_MASTER:
+	case IW_MODE_REPEAT:
+		ret = rtllib_rx_Master(ieee, skb, rx_stats);
+		break;
+	case IW_MODE_MONITOR:
+		ret = rtllib_rx_Monitor(ieee, skb, rx_stats);
+		break;
+	case IW_MODE_MESH:
+		ret = rtllib_rx_Mesh(ieee, skb, rx_stats);
+		break;
+	default:
+		printk(KERN_INFO"%s: ERR iw mode!!!\n", __func__);
+		break;
+	}
+
+	return ret;
+
+ rx_dropped:
+	ieee->stats.rx_dropped++;
+	return 0;
+}
+#else
+int rtllib_rx(struct rtllib_device *ieee, struct sk_buff *skb,
+		 struct rtllib_rx_stats *rx_stats)
+{
+	struct net_device *dev = ieee->dev;
+	struct rtllib_hdr_4addr *hdr;
+	size_t hdrlen;
+	u16 fc, type, stype, sc;
+	struct net_device_stats *stats = NULL;
+	unsigned int frag;
+	u8 *payload;
+	u16 ethertype;
+	u8	TID = 0;
+	u16	SeqNum = 0;
+	PRX_TS_RECORD pTS = NULL;
+#ifdef NOT_YET
+	struct net_device *wds = NULL;
+	struct sk_buff *skb2 = NULL;
+	struct net_device *wds = NULL;
+	int frame_authorized = 0;
+	int from_assoc_ap = 0;
+	void *sta = NULL;
+#endif
+	u8 dst[ETH_ALEN];
+	u8 src[ETH_ALEN];
+	u8 bssid[ETH_ALEN] = {0};
+	u8 zero_addr[ETH_ALEN] = {0};
+	struct rtllib_crypt_data *crypt = NULL;
+	int keyidx = 0;
+#if defined(RTL8192U) || defined(RTL8192SU) || defined(RTL8192SE)
+	struct sta_info * psta = NULL;
+#endif
+	bool unicast_packet = false;
+	int i;
+	struct rtllib_rxb* rxb = NULL;
+	int multicast = 0;
+	bool tmp_dump = false;
+	bool bToOtherSTA = false;
+	hdr = (struct rtllib_hdr_4addr *)skb->data;
+	stats = &ieee->stats;
+
+	multicast = is_multicast_ether_addr(hdr->addr1)|is_broadcast_ether_addr(hdr->addr1);
+	if (!multicast && (compare_ether_addr(dev->dev_addr, hdr->addr1) != 0)) {
+		if ((ieee->iw_mode == IW_MODE_MONITOR) || ieee->bNetPromiscuousMode){
+			bToOtherSTA = true;
+		}else{
+			goto rx_dropped;
+		}
+	}
+
+	fc = le16_to_cpu(hdr->frame_ctl);
+	type = WLAN_FC_GET_TYPE(fc);
+	stype = WLAN_FC_GET_STYPE(fc);
+	sc = le16_to_cpu(hdr->seq_ctl);
+	frag = WLAN_GET_SEQ_FRAG(sc);
+
+	ieee->need_sw_enc = 0;
+
+	hdrlen = rtllib_get_hdrlen(fc);
+	if (skb->len < hdrlen){
+		printk("%s():ERR!!! skb->len is smaller than hdrlen\n",__func__);
+		goto rx_dropped;
+	}
+
+	if (HTCCheck(ieee, skb->data)) {
+		if (net_ratelimit())
+			printk("find HTCControl\n");
+		hdrlen += 4;
+		rx_stats->bContainHTC = 1;
+	}
+	if (RTLLIB_QOS_HAS_SEQ(fc))
+		rx_stats->bIsQosData = 1;
+	if ((0) && (type == RTLLIB_FTYPE_DATA) && ((is_broadcast_ether_addr(hdr->addr1)) || (compare_ether_addr(dev->dev_addr, hdr->addr1) == 0))) {
+		printk("===>RX data before decrypt\n");
+		tmp_dump = true;
+		dump_buf(skb->data,skb->len);
+	}
+#ifdef NOT_YET
+	hostap_update_rx_stats(local->ap, hdr, rx_stats);
+#endif
+
+	if (ieee->host_decrypt) {
+		int idx = 0;
+		if (skb->len >= hdrlen + 3)
+			idx = skb->data[hdrlen + 3] >> 6;
+		crypt = ieee->crypt[idx];
+#ifdef NOT_YET
+		sta = NULL;
+
+		/* Use station specific key to override default keys if the
+		 * receiver address is a unicast address ("individual RA"). If
+		 * bcrx_sta_key parameter is set, station specific key is used
+		 * even with broad/multicast targets (this is against IEEE
+		 * 802.11, but makes it easier to use different keys with
+		 * stations that do not support WEP key mapping). */
+
+		if (!(hdr->addr1[0] & 0x01) || local->bcrx_sta_key)
+			(void) hostap_handle_sta_crypto(local, hdr, &crypt,
+							&sta);
+#endif
+
+		/* allow NULL decrypt to indicate an station specific override
+		 * for default encryption */
+		if (crypt && (crypt->ops == NULL ||
+			      crypt->ops->decrypt_mpdu == NULL))
+			crypt = NULL;
+
+		if (!crypt && (fc & RTLLIB_FCTL_WEP)) {
+			/* This seems to be triggered by some (multicast?)
+			 * frames from other than current BSS, so just drop the
+			 * frames silently instead of filling system log with
+			 * these reports. */
+			RTLLIB_DEBUG_DROP("Decryption failed (not set)"
+					     " (SA=" MAC_FMT ")\n",
+					     MAC_ARG(hdr->addr2));
+			ieee->ieee_stats.rx_discards_undecryptable++;
+			goto rx_dropped;
+		}
+	}
+
+	if (skb->len < RTLLIB_DATA_HDR3_LEN)
+		goto rx_dropped;
+
+	if ( (ieee->pHTInfo->bCurRxReorderEnable == false) ||
+		!ieee->current_network.qos_data.active ||
+		!IsDataFrame(skb->data) ||
+		IsLegacyDataFrame(skb->data)) {
+		if (!((type == RTLLIB_FTYPE_MGMT) && (stype == RTLLIB_STYPE_BEACON))){
+			if (is_duplicate_packet(ieee, hdr)){
+				goto rx_dropped;
+			}
+		}
+	} else {
+		PRX_TS_RECORD pRxTS = NULL;
+		if (GetTs(ieee, (PTS_COMMON_INFO*) &pRxTS, hdr->addr2,
+			(u8)Frame_QoSTID((u8*)(skb->data)), RX_DIR, true)) {
+			if ((fc & (1<<11)) && (frag == pRxTS->RxLastFragNum) &&
+			    (WLAN_GET_SEQ_SEQ(sc) == pRxTS->RxLastSeqNum)) {
+				goto rx_dropped;
+			} else {
+				pRxTS->RxLastFragNum = frag;
+				pRxTS->RxLastSeqNum = WLAN_GET_SEQ_SEQ(sc);
+			}
+		} else {
+			RTLLIB_DEBUG(RTLLIB_DL_ERR, "ERR!!%s(): No TS!! Skip the check!!\n",__func__);
+			goto rx_dropped;
+		}
+	}
+	if (type == RTLLIB_FTYPE_MGMT) {
+		if (bToOtherSTA)
+			goto rx_dropped;
+		if (rtllib_rx_frame_mgmt(ieee, skb, rx_stats, type, stype))
+			goto rx_dropped;
+		else
+			goto rx_exit;
+	}
+	if (type == RTLLIB_FTYPE_CTL) {
+		goto rx_dropped;
+	}
+	/* Data frame - extract src/dst addresses */
+	switch (fc & (RTLLIB_FCTL_FROMDS | RTLLIB_FCTL_TODS)) {
+	case RTLLIB_FCTL_FROMDS:
+		memcpy(dst, hdr->addr1, ETH_ALEN);
+		memcpy(src, hdr->addr3, ETH_ALEN);
+		memcpy(bssid, hdr->addr2, ETH_ALEN);
+		break;
+	case RTLLIB_FCTL_TODS:
+		memcpy(dst, hdr->addr3, ETH_ALEN);
+		memcpy(src, hdr->addr2, ETH_ALEN);
+		memcpy(bssid, hdr->addr1, ETH_ALEN);
+		break;
+	case RTLLIB_FCTL_FROMDS | RTLLIB_FCTL_TODS:
+		if (skb->len < RTLLIB_DATA_HDR4_LEN)
+			goto rx_dropped;
+		memcpy(dst, hdr->addr3, ETH_ALEN);
+		memcpy(src, hdr->addr4, ETH_ALEN);
+		memcpy(bssid, ieee->current_network.bssid, ETH_ALEN);
+		break;
+	case 0:
+		memcpy(dst, hdr->addr1, ETH_ALEN);
+		memcpy(src, hdr->addr2, ETH_ALEN);
+		memcpy(bssid, hdr->addr3, ETH_ALEN);
+		break;
+	}
+
+	/* Filter frames from different BSS */
+	if ((type != RTLLIB_FTYPE_CTL) && ((fc & RTLLIB_FCTL_DSTODS) != RTLLIB_FCTL_DSTODS)
+                && (compare_ether_addr(ieee->current_network.bssid, bssid) != 0) && memcmp(ieee->current_network.bssid, zero_addr, ETH_ALEN)) {
+		goto rx_dropped;
+	}
+
+	/* Filter packets sent by an STA that will be forwarded by AP */
+	if ( ieee->IntelPromiscuousModeInfo.bPromiscuousOn  &&
+                ieee->IntelPromiscuousModeInfo.bFilterSourceStationFrame ) {
+		if ((fc & RTLLIB_FCTL_TODS) && !(fc & RTLLIB_FCTL_FROMDS) &&
+			(compare_ether_addr(dst, ieee->current_network.bssid) != 0) &&
+			(compare_ether_addr(bssid, ieee->current_network.bssid) == 0)) {
+			goto rx_dropped;
+		}
+	}
+
+#ifdef NOT_YET
+	if (hostap_rx_frame_wds(ieee, hdr, fc, &wds))
+		goto rx_dropped;
+	if (wds) {
+		skb->dev = dev = wds;
+		stats = hostap_get_stats(dev);
+	}
+
+	if (ieee->iw_mode == IW_MODE_MASTER && !wds &&
+	    (fc & (RTLLIB_FCTL_TODS | RTLLIB_FCTL_FROMDS)) == RTLLIB_FCTL_FROMDS &&
+	    ieee->stadev &&
+	    memcmp(hdr->addr2, ieee->assoc_ap_addr, ETH_ALEN) == 0) {
+		/* Frame from BSSID of the AP for which we are a client */
+		skb->dev = dev = ieee->stadev;
+		stats = hostap_get_stats(dev);
+		from_assoc_ap = 1;
+	}
+#endif
+
+	dev->last_rx = jiffies;
+
+#ifdef NOT_YET
+	if ((ieee->iw_mode == IW_MODE_MASTER ||
+	     ieee->iw_mode == IW_MODE_REPEAT) &&
+	    !from_assoc_ap) {
+		switch (hostap_handle_sta_rx(ieee, dev, skb, rx_stats,
+					     wds != NULL)) {
+		case AP_RX_CONTINUE_NOT_AUTHORIZED:
+			frame_authorized = 0;
+			break;
+		case AP_RX_CONTINUE:
+			frame_authorized = 1;
+			break;
+		case AP_RX_DROP:
+			goto rx_dropped;
+		case AP_RX_EXIT:
+			goto rx_exit;
+		}
+	}
+#endif
+	/* Nullfunc frames may have PS-bit set, so they must be passed to
+	 * hostap_handle_sta_rx() before being dropped here. */
+	if (stype != RTLLIB_STYPE_DATA &&
+	    stype != RTLLIB_STYPE_DATA_CFACK &&
+	    stype != RTLLIB_STYPE_DATA_CFPOLL &&
+	    stype != RTLLIB_STYPE_DATA_CFACKPOLL&&
+	    stype != RTLLIB_STYPE_QOS_DATA
+	    ) {
+		if (stype != RTLLIB_STYPE_NULLFUNC)
+			RTLLIB_DEBUG_DROP(
+				"RX: dropped data frame "
+				"with no data (type=0x%02x, "
+				"subtype=0x%02x, len=%d)\n",
+				type, stype, skb->len);
+		goto rx_dropped;
+	}
+
+	if (skb->len == hdrlen){
+		goto rx_dropped;
+	}
+
+	{
+		/* network filter more precisely */
+		switch (ieee->iw_mode) {
+		case IW_MODE_ADHOC:
+			/* packets from our adapter are dropped (echo) */
+			if (!memcmp(hdr->addr2, dev->dev_addr, ETH_ALEN))
+				goto rx_dropped;
+
+			/* {broad,multi}cast packets to our BSSID go through */
+			if (is_multicast_ether_addr(hdr->addr1)) {
+				if (!memcmp(hdr->addr3, ieee->current_network.bssid, ETH_ALEN))
+					break;
+				else
+					goto rx_dropped;
+			}
+
+			/* packets not to our adapter, just discard it */
+			if (memcmp(hdr->addr1, dev->dev_addr, ETH_ALEN)) {
+				if (bToOtherSTA)
+					break;
+				else
+					goto rx_dropped;
+			}
+
+			break;
+
+		case IW_MODE_INFRA:
+			/* packets from our adapter are dropped (echo) */
+			if (!memcmp(hdr->addr3, dev->dev_addr, ETH_ALEN))
+				goto rx_dropped;
+
+			/* {broad,multi}cast packets to our BSS go through */
+			if (is_multicast_ether_addr(hdr->addr1)) {
+				if (!memcmp(hdr->addr2, ieee->current_network.bssid, ETH_ALEN))
+					break;
+				else
+					goto rx_dropped;
+			}
+
+			/* packets to our adapter go through */
+			if (memcmp(hdr->addr1, dev->dev_addr, ETH_ALEN)) {
+				if (bToOtherSTA)
+					break;
+				else
+					goto rx_dropped;
+			}
+
+			break;
+		}
+
+
+	}
+
+	if ((ieee->iw_mode == IW_MODE_INFRA)  && (ieee->sta_sleep == LPS_IS_SLEEP)
+		&& (ieee->polling)) {
+		if (WLAN_FC_MORE_DATA(fc)) {
+			/* more data bit is set, let's request a new frame from the AP */
+			rtllib_sta_ps_send_pspoll_frame(ieee);
+		} else {
+			ieee->polling =  false;
+		}
+	}
+
+#if defined(RTL8192U) || defined(RTL8192SU) || defined(RTL8192SE)
+	if (ieee->iw_mode == IW_MODE_ADHOC){
+		psta = GetStaInfo(ieee, src);
+		if (NULL != psta)
+			psta->LastActiveTime = jiffies;
+	}
+#endif
+	/* skb: hdr + (possibly fragmented, possibly encrypted) payload */
+	if ((!rx_stats->Decrypted)){
+		ieee->need_sw_enc = 1;
+	}
+
+	if (ieee->host_decrypt && (fc & RTLLIB_FCTL_WEP) &&
+	    ((keyidx = rtllib_rx_frame_decrypt(ieee, skb, crypt)) < 0)) {
+		printk("decrypt frame error\n");
+		goto rx_dropped;
+	}
+	if (tmp_dump) {
+		printk("************after decrypt\n");
+		dump_buf(skb->data,skb->len);
+	}
+	hdr = (struct rtllib_hdr_4addr *) skb->data;
+
+	/* skb: hdr + (possibly fragmented) plaintext payload */
+	if ((frag != 0 || (fc & RTLLIB_FCTL_MOREFRAGS))) {
+		int flen;
+		struct sk_buff *frag_skb = rtllib_frag_cache_get(ieee, hdr);
+		RTLLIB_DEBUG_FRAG("Rx Fragment received (%u)\n", frag);
+
+		if (!frag_skb) {
+			RTLLIB_DEBUG(RTLLIB_DL_RX | RTLLIB_DL_FRAG,
+					"Rx cannot get skb from fragment "
+					"cache (morefrag=%d seq=%u frag=%u)\n",
+					(fc & RTLLIB_FCTL_MOREFRAGS) != 0,
+					WLAN_GET_SEQ_SEQ(sc), frag);
+			goto rx_dropped;
+		}
+		flen = skb->len;
+		if (frag != 0)
+			flen -= hdrlen;
+
+		if (frag_skb->tail + flen > frag_skb->end) {
+			printk(KERN_WARNING "%s: host decrypted and "
+			       "reassembled frame did not fit skb\n",
+			       dev->name);
+			rtllib_frag_cache_invalidate(ieee, hdr);
+			goto rx_dropped;
+		}
+
+		if (frag == 0) {
+			/* copy first fragment (including full headers) into
+			 * beginning of the fragment cache skb */
+			memcpy(skb_put(frag_skb, flen), skb->data, flen);
+		} else {
+			/* append frame payload to the end of the fragment
+			 * cache skb */
+			memcpy(skb_put(frag_skb, flen), skb->data + hdrlen,
+			       flen);
+		}
+		dev_kfree_skb_any(skb);
+		skb = NULL;
+
+		if (fc & RTLLIB_FCTL_MOREFRAGS) {
+			/* more fragments expected - leave the skb in fragment
+			 * cache for now; it will be delivered to upper layers
+			 * after all fragments have been received */
+			goto rx_exit;
+		}
+
+		/* this was the last fragment and the frame will be
+		 * delivered, so remove skb from fragment cache */
+		skb = frag_skb;
+		hdr = (struct rtllib_hdr_4addr *) skb->data;
+		rtllib_frag_cache_invalidate(ieee, hdr);
+	}
+
+	/* skb: hdr + (possible reassembled) full MSDU payload; possibly still
+	 * encrypted/authenticated */
+	if (ieee->host_decrypt && (fc & RTLLIB_FCTL_WEP) &&
+	    rtllib_rx_frame_decrypt_msdu(ieee, skb, keyidx, crypt)) {
+		printk("==>decrypt msdu error\n");
+		goto rx_dropped;
+	}
+
+	ieee->LinkDetectInfo.NumRecvDataInPeriod++;
+	ieee->LinkDetectInfo.NumRxOkInPeriod++;
+
+	hdr = (struct rtllib_hdr_4addr *) skb->data;
+	if ((!is_multicast_ether_addr(hdr->addr1)) && (!is_broadcast_ether_addr(hdr->addr1)))
+		unicast_packet = true;
+	if (crypt && !(fc & RTLLIB_FCTL_WEP) && !ieee->open_wep) {
+		if (/*ieee->ieee802_1x &&*/
+		    rtllib_is_eapol_frame(ieee, skb, hdrlen)) {
+
+#ifdef CONFIG_RTLLIB_DEBUG
+			/* pass unencrypted EAPOL frames even if encryption is
+			 * configured */
+			struct eapol *eap = (struct eapol *)(skb->data +
+				24);
+			RTLLIB_DEBUG_EAP("RX: IEEE 802.1X EAPOL frame: %s\n",
+						eap_get_type(eap->type));
+#endif
+		} else {
+			RTLLIB_DEBUG_DROP(
+				"encryption configured, but RX "
+				"frame not encrypted (SA=" MAC_FMT ")\n",
+				MAC_ARG(hdr->addr2));
+			goto rx_dropped;
+		}
+	}
+
+#ifdef CONFIG_RTLLIB_DEBUG
+	if (crypt && !(fc & RTLLIB_FCTL_WEP) &&
+	    rtllib_is_eapol_frame(ieee, skb, hdrlen)) {
+			struct eapol *eap = (struct eapol *)(skb->data +
+				24);
+			RTLLIB_DEBUG_EAP("RX: IEEE 802.1X EAPOL frame: %s\n",
+						eap_get_type(eap->type));
+	}
+#endif
+
+	if (crypt && !(fc & RTLLIB_FCTL_WEP) && !ieee->open_wep &&
+	    !rtllib_is_eapol_frame(ieee, skb, hdrlen)) {
+		RTLLIB_DEBUG_DROP(
+			"dropped unencrypted RX data "
+			"frame from " MAC_FMT
+			" (drop_unencrypted=1)\n",
+			MAC_ARG(hdr->addr2));
+		goto rx_dropped;
+	}
+	if (ieee->current_network.qos_data.active && IsQoSDataFrame(skb->data)
+	    && !is_multicast_ether_addr(hdr->addr1) && !is_broadcast_ether_addr(hdr->addr1)) {
+		TID = Frame_QoSTID(skb->data);
+		SeqNum = WLAN_GET_SEQ_SEQ(sc);
+		GetTs(ieee,(PTS_COMMON_INFO*) &pTS,hdr->addr2,TID,RX_DIR,true);
+		if (TID !=0 && TID !=3)
+			ieee->bis_any_nonbepkts = true;
+	}
+	/* skb: hdr + (possible reassembled) full plaintext payload */
+	payload = skb->data + hdrlen;
+	rxb = (struct rtllib_rxb*)kmalloc(sizeof(struct rtllib_rxb),GFP_ATOMIC);
+	if (rxb == NULL) {
+		RTLLIB_DEBUG(RTLLIB_DL_ERR,"%s(): kmalloc rxb error\n",__func__);
+		goto rx_dropped;
+	}
+	/* to parse amsdu packets */
+	/* qos data packets & reserved bit is 1 */
+	if (parse_subframe(ieee,skb,rx_stats,rxb,src,dst) == 0) {
+		/* only to free rxb, and not submit the packets to upper layer */
+		for (i =0; i < rxb->nr_subframes; i++) {
+			dev_kfree_skb(rxb->subframes[i]);
+		}
+		kfree(rxb);
+		rxb = NULL;
+		goto rx_dropped;
+	}
+#if !defined(RTL8192SU) && !defined(RTL8192U)
+		if (unicast_packet) {
+			if (type == RTLLIB_FTYPE_DATA) {
+				if (ieee->bIsAggregateFrame)
+					ieee->LinkDetectInfo.NumRxUnicastOkInPeriod+=rxb->nr_subframes;
+				else
+					ieee->LinkDetectInfo.NumRxUnicastOkInPeriod++;
+
+				if ((ieee->state == RTLLIB_LINKED) /*&& !MgntInitAdapterInProgress(pMgntInfo)*/) {
+					if (((ieee->LinkDetectInfo.NumRxUnicastOkInPeriod +ieee->LinkDetectInfo.NumTxOkInPeriod) > 8 ) ||
+					   (ieee->LinkDetectInfo.NumRxUnicastOkInPeriod > 2)) {
+						if (ieee->LeisurePSLeave)
+							ieee->LeisurePSLeave(dev);
+					}
+				}
+			}
+		}
+#endif
+		ieee->last_rx_ps_time = jiffies;
+		if (ieee->pHTInfo->bCurRxReorderEnable == false ||pTS == NULL || bToOtherSTA ){
+			for (i = 0; i<rxb->nr_subframes; i++) {
+				struct sk_buff *sub_skb = rxb->subframes[i];
+
+				if (sub_skb) {
+					/* convert hdr + possible LLC headers into Ethernet header */
+					ethertype = (sub_skb->data[6] << 8) | sub_skb->data[7];
+					if (sub_skb->len >= 8 &&
+							((memcmp(sub_skb->data, rfc1042_header, SNAP_SIZE) == 0 &&
+							  ethertype != ETH_P_AARP && ethertype != ETH_P_IPX) ||
+							 memcmp(sub_skb->data, bridge_tunnel_header, SNAP_SIZE) == 0)) {
+						/* remove RFC1042 or Bridge-Tunnel encapsulation and
+						 * replace EtherType */
+						skb_pull(sub_skb, SNAP_SIZE);
+						memcpy(skb_push(sub_skb, ETH_ALEN), src, ETH_ALEN);
+						memcpy(skb_push(sub_skb, ETH_ALEN), dst, ETH_ALEN);
+					} else {
+						u16 len;
+						/* Leave Ethernet header part of hdr and full payload */
+						len = htons(sub_skb->len);
+						memcpy(skb_push(sub_skb, 2), &len, 2);
+						memcpy(skb_push(sub_skb, ETH_ALEN), src, ETH_ALEN);
+						memcpy(skb_push(sub_skb, ETH_ALEN), dst, ETH_ALEN);
+					}
+
+					stats->rx_packets++;
+					stats->rx_bytes += sub_skb->len;
+
+					if (is_multicast_ether_addr(dst)) {
+						stats->multicast++;
+					}
+
+					/* Indicat the packets to upper layer */
+					memset(sub_skb->cb, 0, sizeof(sub_skb->cb));
+					sub_skb->protocol = eth_type_trans(sub_skb, dev);
+					sub_skb->dev = dev;
+					sub_skb->dev->stats.rx_packets++;
+					sub_skb->dev->stats.rx_bytes += sub_skb->len;
+#ifdef TCP_CSUM_OFFLOAD_RX
+					if ( rx_stats->tcp_csum_valid)
+						sub_skb->ip_summed = CHECKSUM_UNNECESSARY;
+					else
+						sub_skb->ip_summed = CHECKSUM_NONE;
+#else
+					sub_skb->ip_summed = CHECKSUM_NONE; /* 802.11 crc not sufficient */
+#endif
+
+					netif_rx(sub_skb);
+				}
+			}
+			kfree(rxb);
+			rxb = NULL;
+
+		}
+		else
+		{
+			RTLLIB_DEBUG(RTLLIB_DL_REORDER,"%s(): REORDER ENABLE AND PTS not NULL, and we will enter RxReorderIndicatePacket()\n",__func__);
+#ifdef TCP_CSUM_OFFLOAD_RX
+			rxb->tcp_csum_valid = rx_stats->tcp_csum_valid;
+#endif
+			RxReorderIndicatePacket(ieee, rxb, pTS, SeqNum);
+		}
+#ifndef JOHN_NOCPY
+	dev_kfree_skb(skb);
+#endif
+
+ rx_exit:
+#ifdef NOT_YET
+	if (sta)
+		hostap_handle_sta_release(sta);
+#endif
+	return 1;
+
+ rx_dropped:
+	if (rxb != NULL)
+	{
+		kfree(rxb);
+		rxb = NULL;
+	}
+	stats->rx_dropped++;
+
+	/* Returning 0 indicates to caller that we have not handled the SKB--
+	 * so it is still allocated and can be used again by underlying
+	 * hardware as a DMA target */
+	return 0;
+}
+#endif
+
+#define MGMT_FRAME_FIXED_PART_LENGTH            0x24
+
+static u8 qos_oui[QOS_OUI_LEN] = { 0x00, 0x50, 0xF2 };
+
+/*
+* Make ther structure we read from the beacon packet has
+* the right values
+*/
+static int rtllib_verify_qos_info(struct rtllib_qos_information_element
+                                     *info_element, int sub_type)
+{
+
+        if (info_element->qui_subtype != sub_type)
+                return -1;
+        if (memcmp(info_element->qui, qos_oui, QOS_OUI_LEN))
+                return -1;
+        if (info_element->qui_type != QOS_OUI_TYPE)
+                return -1;
+        if (info_element->version != QOS_VERSION_1)
+                return -1;
+
+        return 0;
+}
+
+
+/*
+ * Parse a QoS parameter element
+ */
+static int rtllib_read_qos_param_element(struct rtllib_qos_parameter_info
+                                            *element_param, struct rtllib_info_element
+                                            *info_element)
+{
+        int ret = 0;
+        u16 size = sizeof(struct rtllib_qos_parameter_info) - 2;
+
+        if ((info_element == NULL) || (element_param == NULL))
+                return -1;
+
+        if (info_element->id == QOS_ELEMENT_ID && info_element->len == size) {
+                memcpy(element_param->info_element.qui, info_element->data,
+                       info_element->len);
+                element_param->info_element.elementID = info_element->id;
+                element_param->info_element.length = info_element->len;
+        } else
+                ret = -1;
+        if (ret == 0)
+                ret = rtllib_verify_qos_info(&element_param->info_element,
+                                                QOS_OUI_PARAM_SUB_TYPE);
+        return ret;
+}
+
+/*
+ * Parse a QoS information element
+ */
+static int rtllib_read_qos_info_element(struct
+                                           rtllib_qos_information_element
+                                           *element_info, struct rtllib_info_element
+                                           *info_element)
+{
+        int ret = 0;
+        u16 size = sizeof(struct rtllib_qos_information_element) - 2;
+
+        if (element_info == NULL)
+                return -1;
+        if (info_element == NULL)
+                return -1;
+
+        if ((info_element->id == QOS_ELEMENT_ID) && (info_element->len == size)) {
+                memcpy(element_info->qui, info_element->data,
+                       info_element->len);
+                element_info->elementID = info_element->id;
+                element_info->length = info_element->len;
+        } else
+                ret = -1;
+
+        if (ret == 0)
+                ret = rtllib_verify_qos_info(element_info,
+                                                QOS_OUI_INFO_SUB_TYPE);
+        return ret;
+}
+
+
+/*
+ * Write QoS parameters from the ac parameters.
+ */
+static int rtllib_qos_convert_ac_to_parameters(struct rtllib_qos_parameter_info *param_elm,
+		struct rtllib_qos_data *qos_data)
+{
+        struct rtllib_qos_ac_parameter *ac_params;
+	struct rtllib_qos_parameters *qos_param = &(qos_data->parameters);
+        int rc = 0;
+        int i;
+	u8 aci;
+	u8 acm;
+
+	qos_data->wmm_acm = 0;
+        for (i = 0; i < QOS_QUEUE_NUM; i++) {
+                ac_params = &(param_elm->ac_params_record[i]);
+
+		aci = (ac_params->aci_aifsn & 0x60) >> 5;
+		acm = (ac_params->aci_aifsn & 0x10) >> 4;
+
+		if (aci >= QOS_QUEUE_NUM)
+			continue;
+		switch (aci) {
+			case 1:
+				/* BIT(0) | BIT(3) */
+				if (acm)
+					qos_data->wmm_acm |= (0x01<<0)|(0x01<<3);
+				break;
+			case 2:
+				/* BIT(4) | BIT(5) */
+				if (acm)
+					qos_data->wmm_acm |= (0x01<<4)|(0x01<<5);
+				break;
+			case 3:
+				/* BIT(6) | BIT(7) */
+				if (acm)
+					qos_data->wmm_acm |= (0x01<<6)|(0x01<<7);
+				break;
+			case 0:
+			default:
+				/* BIT(1) | BIT(2) */
+				if (acm)
+					qos_data->wmm_acm |= (0x01<<1)|(0x01<<2);
+				break;
+		}
+
+                qos_param->aifs[aci] = (ac_params->aci_aifsn) & 0x0f;
+
+		/* WMM spec P.11: The minimum value for AIFSN shall be 2 */
+                qos_param->aifs[aci] = (qos_param->aifs[aci] < 2) ? 2:qos_param->aifs[aci];
+
+                qos_param->cw_min[aci] = ac_params->ecw_min_max & 0x0F;
+
+                qos_param->cw_max[aci] = (ac_params->ecw_min_max & 0xF0) >> 4;
+
+                qos_param->flag[aci] =
+                    (ac_params->aci_aifsn & 0x10) ? 0x01 : 0x00;
+                qos_param->tx_op_limit[aci] = le16_to_cpu(ac_params->tx_op_limit);
+        }
+        return rc;
+}
+
+/*
+ * we have a generic data element which it may contain QoS information or
+ * parameters element. check the information element length to decide
+ * which type to read
+ */
+static int rtllib_parse_qos_info_param_IE(struct rtllib_info_element
+                                             *info_element,
+                                             struct rtllib_network *network)
+{
+        int rc = 0;
+        struct rtllib_qos_information_element qos_info_element;
+
+        rc = rtllib_read_qos_info_element(&qos_info_element, info_element);
+
+        if (rc == 0) {
+                network->qos_data.param_count = qos_info_element.ac_info & 0x0F;
+                network->flags |= NETWORK_HAS_QOS_INFORMATION;
+        } else {
+                struct rtllib_qos_parameter_info param_element;
+
+                rc = rtllib_read_qos_param_element(&param_element,
+                                                      info_element);
+                if (rc == 0) {
+                        rtllib_qos_convert_ac_to_parameters(&param_element,
+                                                               &(network->qos_data));
+                        network->flags |= NETWORK_HAS_QOS_PARAMETERS;
+                        network->qos_data.param_count =
+                            param_element.info_element.ac_info & 0x0F;
+                }
+        }
+
+        if (rc == 0) {
+                RTLLIB_DEBUG_QOS("QoS is supported\n");
+                network->qos_data.supported = 1;
+        }
+        return rc;
+}
+
+#ifdef CONFIG_RTLLIB_DEBUG
+#define MFIE_STRING(x) case MFIE_TYPE_ ##x: return #x
+
+static const char *get_info_element_string(u16 id)
+{
+        switch (id) {
+                MFIE_STRING(SSID);
+                MFIE_STRING(RATES);
+                MFIE_STRING(FH_SET);
+                MFIE_STRING(DS_SET);
+                MFIE_STRING(CF_SET);
+                MFIE_STRING(TIM);
+                MFIE_STRING(IBSS_SET);
+                MFIE_STRING(COUNTRY);
+                MFIE_STRING(HOP_PARAMS);
+                MFIE_STRING(HOP_TABLE);
+                MFIE_STRING(REQUEST);
+                MFIE_STRING(CHALLENGE);
+                MFIE_STRING(POWER_CONSTRAINT);
+                MFIE_STRING(POWER_CAPABILITY);
+                MFIE_STRING(TPC_REQUEST);
+                MFIE_STRING(TPC_REPORT);
+                MFIE_STRING(SUPP_CHANNELS);
+                MFIE_STRING(CSA);
+                MFIE_STRING(MEASURE_REQUEST);
+                MFIE_STRING(MEASURE_REPORT);
+                MFIE_STRING(QUIET);
+                MFIE_STRING(IBSS_DFS);
+                MFIE_STRING(RSN);
+                MFIE_STRING(RATES_EX);
+                MFIE_STRING(GENERIC);
+                MFIE_STRING(QOS_PARAMETER);
+        default:
+                return "UNKNOWN";
+        }
+}
+#endif
+
+#ifdef ENABLE_DOT11D
+static inline void rtllib_extract_country_ie(
+	struct rtllib_device *ieee,
+	struct rtllib_info_element *info_element,
+	struct rtllib_network *network,
+	u8 * addr2)
+{
+	if (IS_DOT11D_ENABLE(ieee)) {
+		if (info_element->len!= 0) {
+			memcpy(network->CountryIeBuf, info_element->data, info_element->len);
+			network->CountryIeLen = info_element->len;
+
+			if (!IS_COUNTRY_IE_VALID(ieee))
+			{
+				if ((rtllib_act_scanning(ieee,false) == true) && (ieee->FirstIe_InScan == 1))
+					printk("Received beacon ContryIE, SSID: <%s>\n",network->ssid);
+				Dot11d_UpdateCountryIe(ieee, addr2, info_element->len, info_element->data);
+			}
+		}
+
+		if (IS_EQUAL_CIE_SRC(ieee, addr2)) {
+			UPDATE_CIE_WATCHDOG(ieee);
+		}
+	}
+
+}
+#endif
+
+int rtllib_parse_info_param(struct rtllib_device *ieee,
+		struct rtllib_info_element *info_element,
+		u16 length,
+		struct rtllib_network *network,
+		struct rtllib_rx_stats *stats)
+{
+	u8 i;
+	short offset;
+        u16	tmp_htcap_len=0;
+	u16	tmp_htinfo_len=0;
+	u16 ht_realtek_agg_len=0;
+	u8  ht_realtek_agg_buf[MAX_IE_LEN];
+#ifdef CONFIG_RTLLIB_DEBUG
+	char rates_str[64];
+	char *p;
+#endif
+	while (length >= sizeof(*info_element)) {
+		if (sizeof(*info_element) + info_element->len > length) {
+			RTLLIB_DEBUG_MGMT("Info elem: parse failed: "
+					     "info_element->len + 2 > left : "
+					     "info_element->len+2=%zd left=%d, id=%d.\n",
+					     info_element->len +
+					     sizeof(*info_element),
+					     length, info_element->id);
+			/* We stop processing but don't return an error here
+			 * because some misbehaviour APs break this rule. ie.
+			 * Orinoco AP1000. */
+			break;
+		}
+
+		switch (info_element->id) {
+		case MFIE_TYPE_SSID:
+			if (rtllib_is_empty_essid(info_element->data,
+						     info_element->len)) {
+				network->flags |= NETWORK_EMPTY_ESSID;
+				break;
+			}
+
+			network->ssid_len = min(info_element->len,
+						(u8) IW_ESSID_MAX_SIZE);
+			memcpy(network->ssid, info_element->data, network->ssid_len);
+			if (network->ssid_len < IW_ESSID_MAX_SIZE)
+				memset(network->ssid + network->ssid_len, 0,
+				       IW_ESSID_MAX_SIZE - network->ssid_len);
+
+			RTLLIB_DEBUG_MGMT("MFIE_TYPE_SSID: '%s' len=%d.\n",
+					     network->ssid, network->ssid_len);
+			break;
+
+		case MFIE_TYPE_RATES:
+#ifdef CONFIG_RTLLIB_DEBUG
+			p = rates_str;
+#endif
+			network->rates_len = min(info_element->len,
+						 MAX_RATES_LENGTH);
+			for (i = 0; i < network->rates_len; i++) {
+				network->rates[i] = info_element->data[i];
+#ifdef CONFIG_RTLLIB_DEBUG
+				p += snprintf(p, sizeof(rates_str) -
+					      (p - rates_str), "%02X ",
+					      network->rates[i]);
+#endif
+				if (rtllib_is_ofdm_rate
+				    (info_element->data[i])) {
+					network->flags |= NETWORK_HAS_OFDM;
+					if (info_element->data[i] &
+					    RTLLIB_BASIC_RATE_MASK)
+						network->flags &=
+						    ~NETWORK_HAS_CCK;
+				}
+
+				if (rtllib_is_cck_rate
+				    (info_element->data[i])) {
+					network->flags |= NETWORK_HAS_CCK;
+				}
+			}
+
+			RTLLIB_DEBUG_MGMT("MFIE_TYPE_RATES: '%s' (%d)\n",
+					     rates_str, network->rates_len);
+			break;
+
+		case MFIE_TYPE_RATES_EX:
+#ifdef CONFIG_RTLLIB_DEBUG
+			p = rates_str;
+#endif
+			network->rates_ex_len = min(info_element->len,
+						    MAX_RATES_EX_LENGTH);
+			for (i = 0; i < network->rates_ex_len; i++) {
+				network->rates_ex[i] = info_element->data[i];
+#ifdef CONFIG_RTLLIB_DEBUG
+				p += snprintf(p, sizeof(rates_str) -
+					      (p - rates_str), "%02X ",
+					      network->rates[i]);
+#endif
+				if (rtllib_is_ofdm_rate
+				    (info_element->data[i])) {
+					network->flags |= NETWORK_HAS_OFDM;
+					if (info_element->data[i] &
+					    RTLLIB_BASIC_RATE_MASK)
+						network->flags &=
+						    ~NETWORK_HAS_CCK;
+				}
+			}
+
+			RTLLIB_DEBUG_MGMT("MFIE_TYPE_RATES_EX: '%s' (%d)\n",
+					     rates_str, network->rates_ex_len);
+			break;
+
+		case MFIE_TYPE_DS_SET:
+			RTLLIB_DEBUG_MGMT("MFIE_TYPE_DS_SET: %d\n",
+					     info_element->data[0]);
+			network->channel = info_element->data[0];
+			break;
+
+		case MFIE_TYPE_FH_SET:
+			RTLLIB_DEBUG_MGMT("MFIE_TYPE_FH_SET: ignored\n");
+			break;
+
+		case MFIE_TYPE_CF_SET:
+			RTLLIB_DEBUG_MGMT("MFIE_TYPE_CF_SET: ignored\n");
+			break;
+
+		case MFIE_TYPE_TIM:
+			if (info_element->len < 4)
+				break;
+
+			network->tim.tim_count = info_element->data[0];
+			network->tim.tim_period = info_element->data[1];
+
+                        network->dtim_period = info_element->data[1];
+                        if (ieee->state != RTLLIB_LINKED)
+                                break;
+			network->last_dtim_sta_time[0] = jiffies;
+                        network->last_dtim_sta_time[1] = stats->mac_time[1];
+
+                        network->dtim_data = RTLLIB_DTIM_VALID;
+
+
+                        if (info_element->data[2] & 1)
+                                network->dtim_data |= RTLLIB_DTIM_MBCAST;
+
+#if 1
+                        offset = (info_element->data[2] >> 1)*2;
+
+
+                        if (ieee->assoc_id < 8*offset ||
+                                ieee->assoc_id > 8*(offset + info_element->len -3))
+
+                                break;
+
+                        offset = (ieee->assoc_id / 8) - offset;
+                        if (info_element->data[3+offset] & (1<<(ieee->assoc_id%8)))
+                                network->dtim_data |= RTLLIB_DTIM_UCAST;
+#else
+			{
+				u16 numSta = 0;
+				u16 offset_byte = 0;
+				u16 offset_bit = 0;
+
+				numSta = (info_element->data[2] &0xFE)*8;
+
+				if (ieee->assoc_id < numSta ||
+						ieee->assoc_id > (numSta + (info_element->len -3)*8))
+					break;
+
+				offset = ieee->assoc_id - numSta;
+				offset_byte = offset / 8;
+				offset_bit = offset % 8;
+				if (info_element->data[3+offset_byte] & (0x01<<offset_bit))
+					network->dtim_data |= RTLLIB_DTIM_UCAST;
+			}
+#endif
+
+			network->listen_interval = network->dtim_period;
+			break;
+
+		case MFIE_TYPE_ERP:
+			network->erp_value = info_element->data[0];
+			network->flags |= NETWORK_HAS_ERP_VALUE;
+			RTLLIB_DEBUG_MGMT("MFIE_TYPE_ERP_SET: %d\n",
+					     network->erp_value);
+			break;
+		case MFIE_TYPE_IBSS_SET:
+			network->atim_window = info_element->data[0];
+			RTLLIB_DEBUG_MGMT("MFIE_TYPE_IBSS_SET: %d\n",
+					     network->atim_window);
+			break;
+
+		case MFIE_TYPE_CHALLENGE:
+			RTLLIB_DEBUG_MGMT("MFIE_TYPE_CHALLENGE: ignored\n");
+			break;
+
+		case MFIE_TYPE_GENERIC:
+			RTLLIB_DEBUG_MGMT("MFIE_TYPE_GENERIC: %d bytes\n",
+					     info_element->len);
+			if (!rtllib_parse_qos_info_param_IE(info_element,
+							       network))
+				break;
+			if (info_element->len >= 4 &&
+			    info_element->data[0] == 0x00 &&
+			    info_element->data[1] == 0x50 &&
+			    info_element->data[2] == 0xf2 &&
+			    info_element->data[3] == 0x01) {
+				network->wpa_ie_len = min(info_element->len + 2,
+							  MAX_WPA_IE_LEN);
+				memcpy(network->wpa_ie, info_element,
+				       network->wpa_ie_len);
+				break;
+			}
+                        if (info_element->len == 7 &&
+                            info_element->data[0] == 0x00 &&
+                            info_element->data[1] == 0xe0 &&
+                            info_element->data[2] == 0x4c &&
+                            info_element->data[3] == 0x01 &&
+                            info_element->data[4] == 0x02)
+                                network->Turbo_Enable = 1;
+
+			if (tmp_htcap_len == 0) {
+				if (info_element->len >= 4 &&
+				   info_element->data[0] == 0x00 &&
+				   info_element->data[1] == 0x90 &&
+				   info_element->data[2] == 0x4c &&
+				   info_element->data[3] == 0x033) {
+
+						tmp_htcap_len = min(info_element->len,(u8)MAX_IE_LEN);
+						if (tmp_htcap_len != 0){
+							network->bssht.bdHTSpecVer = HT_SPEC_VER_EWC;
+							network->bssht.bdHTCapLen = tmp_htcap_len > sizeof(network->bssht.bdHTCapBuf)?\
+								sizeof(network->bssht.bdHTCapBuf):tmp_htcap_len;
+							memcpy(network->bssht.bdHTCapBuf,info_element->data,network->bssht.bdHTCapLen);
+						}
+				}
+				if (tmp_htcap_len != 0){
+					network->bssht.bdSupportHT = true;
+					network->bssht.bdHT1R = ((((PHT_CAPABILITY_ELE)(network->bssht.bdHTCapBuf))->MCS[1]) == 0);
+				}else{
+					network->bssht.bdSupportHT = false;
+					network->bssht.bdHT1R = false;
+				}
+			}
+
+
+			if (tmp_htinfo_len == 0){
+				if (info_element->len >= 4 &&
+					info_element->data[0] == 0x00 &&
+					info_element->data[1] == 0x90 &&
+					info_element->data[2] == 0x4c &&
+					info_element->data[3] == 0x034){
+
+						tmp_htinfo_len = min(info_element->len,(u8)MAX_IE_LEN);
+						if (tmp_htinfo_len != 0){
+							network->bssht.bdHTSpecVer = HT_SPEC_VER_EWC;
+							if (tmp_htinfo_len){
+								network->bssht.bdHTInfoLen = tmp_htinfo_len > sizeof(network->bssht.bdHTInfoBuf)?\
+									sizeof(network->bssht.bdHTInfoBuf):tmp_htinfo_len;
+								memcpy(network->bssht.bdHTInfoBuf,info_element->data,network->bssht.bdHTInfoLen);
+							}
+
+						}
+
+				}
+			}
+
+			if (ieee->aggregation){
+				if (network->bssht.bdSupportHT){
+					if (info_element->len >= 4 &&
+						info_element->data[0] == 0x00 &&
+						info_element->data[1] == 0xe0 &&
+						info_element->data[2] == 0x4c &&
+						info_element->data[3] == 0x02){
+
+						ht_realtek_agg_len = min(info_element->len,(u8)MAX_IE_LEN);
+						memcpy(ht_realtek_agg_buf,info_element->data,info_element->len);
+
+					}
+					if (ht_realtek_agg_len >= 5){
+						network->realtek_cap_exit = true;
+						network->bssht.bdRT2RTAggregation = true;
+
+						if ((ht_realtek_agg_buf[4] == 1) && (ht_realtek_agg_buf[5] & 0x02))
+						network->bssht.bdRT2RTLongSlotTime = true;
+
+						if ((ht_realtek_agg_buf[4]==1) && (ht_realtek_agg_buf[5] & RT_HT_CAP_USE_92SE))
+						{
+							network->bssht.RT2RT_HT_Mode |= RT_HT_CAP_USE_92SE;
+						}
+					}
+				}
+				if (ht_realtek_agg_len >= 5){
+					if ((ht_realtek_agg_buf[5] & RT_HT_CAP_USE_SOFTAP))
+						network->bssht.RT2RT_HT_Mode |= RT_HT_CAP_USE_SOFTAP;
+				}
+			}
+
+			{
+				if ((info_element->len >= 3 &&
+					 info_element->data[0] == 0x00 &&
+					 info_element->data[1] == 0x05 &&
+					 info_element->data[2] == 0xb5) ||
+					 (info_element->len >= 3 &&
+					 info_element->data[0] == 0x00 &&
+					 info_element->data[1] == 0x0a &&
+					 info_element->data[2] == 0xf7) ||
+					 (info_element->len >= 3 &&
+					 info_element->data[0] == 0x00 &&
+					 info_element->data[1] == 0x10 &&
+					 info_element->data[2] == 0x18)){
+
+						network->broadcom_cap_exist = true;
+
+				}
+			}
+			if (info_element->len >= 3 &&
+				info_element->data[0] == 0x00 &&
+				info_element->data[1] == 0x0c &&
+				info_element->data[2] == 0x43)
+			{
+				network->ralink_cap_exist = true;
+			}
+			if ((info_element->len >= 3 &&
+				info_element->data[0] == 0x00 &&
+				info_element->data[1] == 0x03 &&
+				info_element->data[2] == 0x7f) ||
+				(info_element->len >= 3 &&
+				info_element->data[0] == 0x00 &&
+				info_element->data[1] == 0x13 &&
+				info_element->data[2] == 0x74))
+			{
+				network->atheros_cap_exist = true;
+			}
+
+			if ((info_element->len >= 3 &&
+				info_element->data[0] == 0x00 &&
+				info_element->data[1] == 0x50 &&
+				info_element->data[2] == 0x43) )
+				{
+					network->marvell_cap_exist = true;
+				}
+			if (info_element->len >= 3 &&
+				info_element->data[0] == 0x00 &&
+				info_element->data[1] == 0x40 &&
+				info_element->data[2] == 0x96)
+			{
+				network->cisco_cap_exist = true;
+			}
+
+
+			if (info_element->len >= 3 &&
+				info_element->data[0] == 0x00 &&
+				info_element->data[1] == 0x0a &&
+				info_element->data[2] == 0xf5)
+			{
+				network->airgo_cap_exist = true;
+			}
+
+			if (info_element->len > 4 &&
+				info_element->data[0] == 0x00 &&
+				info_element->data[1] == 0x40 &&
+				info_element->data[2] == 0x96 &&
+				info_element->data[3] == 0x01)
+			{
+				if (info_element->len == 6)
+				{
+					memcpy(network->CcxRmState, &info_element[4], 2);
+					if (network->CcxRmState[0] != 0)
+					{
+						network->bCcxRmEnable = true;
+					}
+					else
+						network->bCcxRmEnable = false;
+					network->MBssidMask = network->CcxRmState[1] & 0x07;
+					if (network->MBssidMask != 0)
+					{
+						network->bMBssidValid = true;
+						network->MBssidMask = 0xff << (network->MBssidMask);
+						memcpy(network->MBssid, network->bssid, ETH_ALEN);
+						network->MBssid[5] &= network->MBssidMask;
+					}
+					else
+					{
+						network->bMBssidValid = false;
+					}
+				}
+				else
+				{
+					network->bCcxRmEnable = false;
+				}
+			}
+			if (info_element->len > 4  &&
+				info_element->data[0] == 0x00 &&
+				info_element->data[1] == 0x40 &&
+				info_element->data[2] == 0x96 &&
+				info_element->data[3] == 0x03)
+			{
+				if (info_element->len == 5)
+				{
+					network->bWithCcxVerNum = true;
+					network->BssCcxVerNumber = info_element->data[4];
+				}
+				else
+				{
+					network->bWithCcxVerNum = false;
+					network->BssCcxVerNumber = 0;
+				}
+			}
+			if (info_element->len > 4  &&
+				info_element->data[0] == 0x00 &&
+				info_element->data[1] == 0x50 &&
+				info_element->data[2] == 0xf2 &&
+				info_element->data[3] == 0x04)
+			{
+				RTLLIB_DEBUG_MGMT("MFIE_TYPE_WZC: %d bytes\n",
+						     info_element->len);
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
+				network->wzc_ie_len = min(info_element->len+2,
+							  MAX_WZC_IE_LEN);
+				memcpy(network->wzc_ie, info_element,
+						network->wzc_ie_len);
+#endif
+			}
+			break;
+
+		case MFIE_TYPE_RSN:
+			RTLLIB_DEBUG_MGMT("MFIE_TYPE_RSN: %d bytes\n",
+					     info_element->len);
+			network->rsn_ie_len = min(info_element->len + 2,
+						  MAX_WPA_IE_LEN);
+			memcpy(network->rsn_ie, info_element,
+			       network->rsn_ie_len);
+			break;
+
+		case MFIE_TYPE_HT_CAP:
+			RTLLIB_DEBUG_SCAN("MFIE_TYPE_HT_CAP: %d bytes\n",
+					     info_element->len);
+			tmp_htcap_len = min(info_element->len,(u8)MAX_IE_LEN);
+			if (tmp_htcap_len != 0){
+				network->bssht.bdHTSpecVer = HT_SPEC_VER_EWC;
+				network->bssht.bdHTCapLen = tmp_htcap_len > sizeof(network->bssht.bdHTCapBuf)?\
+					sizeof(network->bssht.bdHTCapBuf):tmp_htcap_len;
+				memcpy(network->bssht.bdHTCapBuf,info_element->data,network->bssht.bdHTCapLen);
+
+				network->bssht.bdSupportHT = true;
+				network->bssht.bdHT1R = ((((PHT_CAPABILITY_ELE)(network->bssht.bdHTCapBuf))->MCS[1]) == 0);
+
+				network->bssht.bdBandWidth = (HT_CHANNEL_WIDTH)(((PHT_CAPABILITY_ELE)(network->bssht.bdHTCapBuf))->ChlWidth);
+			}
+			else{
+				network->bssht.bdSupportHT = false;
+				network->bssht.bdHT1R = false;
+				network->bssht.bdBandWidth = HT_CHANNEL_WIDTH_20 ;
+			}
+			break;
+
+
+		case MFIE_TYPE_HT_INFO:
+			RTLLIB_DEBUG_SCAN("MFIE_TYPE_HT_INFO: %d bytes\n",
+					     info_element->len);
+			tmp_htinfo_len = min(info_element->len,(u8)MAX_IE_LEN);
+			if (tmp_htinfo_len){
+				network->bssht.bdHTSpecVer = HT_SPEC_VER_IEEE;
+				network->bssht.bdHTInfoLen = tmp_htinfo_len > sizeof(network->bssht.bdHTInfoBuf)?\
+					sizeof(network->bssht.bdHTInfoBuf):tmp_htinfo_len;
+				memcpy(network->bssht.bdHTInfoBuf,info_element->data,network->bssht.bdHTInfoLen);
+			}
+			break;
+
+		case MFIE_TYPE_AIRONET:
+			RTLLIB_DEBUG_SCAN("MFIE_TYPE_AIRONET: %d bytes\n",
+					     info_element->len);
+			if (info_element->len >IE_CISCO_FLAG_POSITION)
+			{
+				network->bWithAironetIE = true;
+
+				if (	(info_element->data[IE_CISCO_FLAG_POSITION]&SUPPORT_CKIP_MIC)	||
+					(info_element->data[IE_CISCO_FLAG_POSITION]&SUPPORT_CKIP_PK)	)
+				{
+					network->bCkipSupported = true;
+				}
+				else
+				{
+					network->bCkipSupported = false;
+				}
+			}
+			else
+			{
+				network->bWithAironetIE = false;
+				network->bCkipSupported = false;
+			}
+			break;
+		case MFIE_TYPE_QOS_PARAMETER:
+			printk(KERN_ERR
+			       "QoS Error need to parse QOS_PARAMETER IE\n");
+			break;
+
+#ifdef ENABLE_DOT11D
+		case MFIE_TYPE_COUNTRY:
+			RTLLIB_DEBUG_SCAN("MFIE_TYPE_COUNTRY: %d bytes\n",
+					     info_element->len);
+			rtllib_extract_country_ie(ieee, info_element, network, network->bssid);
+			break;
+#endif
+/* TODO */
+		default:
+			RTLLIB_DEBUG_MGMT
+			    ("Unsupported info element: %s (%d)\n",
+			     get_info_element_string(info_element->id),
+			     info_element->id);
+			break;
+		}
+
+		length -= sizeof(*info_element) + info_element->len;
+		info_element =
+		    (struct rtllib_info_element *)&info_element->
+		    data[info_element->len];
+	}
+
+	if (!network->atheros_cap_exist && !network->broadcom_cap_exist &&
+		!network->cisco_cap_exist && !network->ralink_cap_exist && !network->bssht.bdRT2RTAggregation)
+	{
+		network->unknown_cap_exist = true;
+	}
+	else
+	{
+		network->unknown_cap_exist = false;
+	}
+	return 0;
+}
+
+static inline u8 rtllib_SignalStrengthTranslate(
+	u8  CurrSS
+	)
+{
+	u8 RetSS;
+
+	if (CurrSS >= 71 && CurrSS <= 100)
+	{
+		RetSS = 90 + ((CurrSS - 70) / 3);
+	}
+	else if (CurrSS >= 41 && CurrSS <= 70)
+	{
+		RetSS = 78 + ((CurrSS - 40) / 3);
+	}
+	else if (CurrSS >= 31 && CurrSS <= 40)
+	{
+		RetSS = 66 + (CurrSS - 30);
+	}
+	else if (CurrSS >= 21 && CurrSS <= 30)
+	{
+		RetSS = 54 + (CurrSS - 20);
+	}
+	else if (CurrSS >= 5 && CurrSS <= 20)
+	{
+		RetSS = 42 + (((CurrSS - 5) * 2) / 3);
+	}
+	else if (CurrSS == 4)
+	{
+		RetSS = 36;
+	}
+	else if (CurrSS == 3)
+	{
+		RetSS = 27;
+	}
+	else if (CurrSS == 2)
+	{
+		RetSS = 18;
+	}
+	else if (CurrSS == 1)
+	{
+		RetSS = 9;
+	}
+	else
+	{
+		RetSS = CurrSS;
+	}
+
+
+
+	return RetSS;
+}
+
+long rtllib_translate_todbm(u8 signal_strength_index	)
+{
+	long	signal_power;
+
+	signal_power = (long)((signal_strength_index + 1) >> 1);
+	signal_power -= 95;
+
+	return signal_power;
+}
+
+static inline int rtllib_network_init(
+	struct rtllib_device *ieee,
+	struct rtllib_probe_response *beacon,
+	struct rtllib_network *network,
+	struct rtllib_rx_stats *stats)
+{
+#ifdef CONFIG_RTLLIB_DEBUG
+#endif
+
+	/*
+        network->qos_data.active = 0;
+        network->qos_data.supported = 0;
+        network->qos_data.param_count = 0;
+        network->qos_data.old_param_count = 0;
+	*/
+	memset(&network->qos_data, 0, sizeof(struct rtllib_qos_data));
+
+	/* Pull out fixed field data */
+	memcpy(network->bssid, beacon->header.addr3, ETH_ALEN);
+	network->capability = le16_to_cpu(beacon->capability);
+	network->last_scanned = jiffies;
+	network->time_stamp[0] = le32_to_cpu(beacon->time_stamp[0]);
+	network->time_stamp[1] = le32_to_cpu(beacon->time_stamp[1]);
+	network->beacon_interval = le32_to_cpu(beacon->beacon_interval);
+	/* Where to pull this? beacon->listen_interval;*/
+	network->listen_interval = 0x0A;
+	network->rates_len = network->rates_ex_len = 0;
+	network->last_associate = 0;
+	network->ssid_len = 0;
+	network->hidden_ssid_len = 0;
+	memset(network->hidden_ssid, 0, sizeof(network->hidden_ssid));
+	network->flags = 0;
+	network->atim_window = 0;
+	network->erp_value = (network->capability & WLAN_CAPABILITY_IBSS) ?
+            0x3 : 0x0;
+	network->berp_info_valid = false;
+        network->broadcom_cap_exist = false;
+	network->ralink_cap_exist = false;
+	network->atheros_cap_exist = false;
+	network->cisco_cap_exist = false;
+	network->unknown_cap_exist = false;
+	network->realtek_cap_exit = false;
+	network->marvell_cap_exist = false;
+	network->airgo_cap_exist = false;
+	network->Turbo_Enable = 0;
+	network->SignalStrength = stats->SignalStrength;
+	network->RSSI = stats->SignalStrength;
+#ifdef ENABLE_DOT11D
+	network->CountryIeLen = 0;
+	memset(network->CountryIeBuf, 0, MAX_IE_LEN);
+#endif
+	HTInitializeBssDesc(&network->bssht);
+	if (stats->freq == RTLLIB_52GHZ_BAND) {
+		/* for A band (No DS info) */
+		network->channel = stats->received_channel;
+	} else
+		network->flags |= NETWORK_HAS_CCK;
+
+	network->wpa_ie_len = 0;
+	network->rsn_ie_len = 0;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
+	network->wzc_ie_len = 0;
+#endif
+
+        if (rtllib_parse_info_param(ieee,
+			beacon->info_element,
+			(stats->len - sizeof(*beacon)),
+			network,
+			stats))
+                return 1;
+
+	network->mode = 0;
+	if (stats->freq == RTLLIB_52GHZ_BAND)
+		network->mode = IEEE_A;
+	else {
+		if (network->flags & NETWORK_HAS_OFDM)
+			network->mode |= IEEE_G;
+		if (network->flags & NETWORK_HAS_CCK)
+			network->mode |= IEEE_B;
+	}
+
+	if (network->mode == 0) {
+		RTLLIB_DEBUG_SCAN("Filtered out '%s (" MAC_FMT ")' "
+				     "network.\n",
+				     escape_essid(network->ssid,
+						  network->ssid_len),
+				     MAC_ARG(network->bssid));
+		return 1;
+	}
+
+	if (network->bssht.bdSupportHT){
+		if (network->mode == IEEE_A)
+			network->mode = IEEE_N_5G;
+		else if (network->mode & (IEEE_G | IEEE_B))
+			network->mode = IEEE_N_24G;
+	}
+	if (rtllib_is_empty_essid(network->ssid, network->ssid_len))
+		network->flags |= NETWORK_EMPTY_ESSID;
+	stats->signal = 30 + (stats->SignalStrength * 70) / 100;
+	stats->noise = rtllib_translate_todbm((u8)(100-stats->signal)) -25;
+
+	memcpy(&network->stats, stats, sizeof(network->stats));
+
+	return 0;
+}
+
+static inline int is_same_network(struct rtllib_network *src,
+				  struct rtllib_network *dst, u8 ssidbroad)
+{
+	/* A network is only a duplicate if the channel, BSSID, ESSID
+	 * and the capability field (in particular IBSS and BSS) all match.
+	 * We treat all <hidden> with the same BSSID and channel
+	 * as one network */
+	return
+		(((src->ssid_len == dst->ssid_len) || (!ssidbroad)) &&
+		(src->channel == dst->channel) &&
+		!memcmp(src->bssid, dst->bssid, ETH_ALEN) &&
+		(!memcmp(src->ssid, dst->ssid, src->ssid_len) || (!ssidbroad)) &&
+		((src->capability & WLAN_CAPABILITY_IBSS) ==
+		(dst->capability & WLAN_CAPABILITY_IBSS)) &&
+		((src->capability & WLAN_CAPABILITY_ESS) ==
+		(dst->capability & WLAN_CAPABILITY_ESS)));
+}
+
+static inline void update_ibss_network(struct rtllib_network *dst,
+				  struct rtllib_network *src)
+{
+	memcpy(&dst->stats, &src->stats, sizeof(struct rtllib_rx_stats));
+	dst->last_scanned = jiffies;
+}
+
+
+static inline void update_network(struct rtllib_network *dst,
+				  struct rtllib_network *src)
+{
+	int qos_active;
+	u8 old_param;
+
+	memcpy(&dst->stats, &src->stats, sizeof(struct rtllib_rx_stats));
+	dst->capability = src->capability;
+	memcpy(dst->rates, src->rates, src->rates_len);
+	dst->rates_len = src->rates_len;
+	memcpy(dst->rates_ex, src->rates_ex, src->rates_ex_len);
+	dst->rates_ex_len = src->rates_ex_len;
+	if (src->ssid_len > 0)
+	{
+		if (dst->ssid_len == 0)
+		{
+			memset(dst->hidden_ssid, 0, sizeof(dst->hidden_ssid));
+			dst->hidden_ssid_len = src->ssid_len;
+			memcpy(dst->hidden_ssid, src->ssid, src->ssid_len);
+		}else{
+			memset(dst->ssid, 0, dst->ssid_len);
+			dst->ssid_len = src->ssid_len;
+			memcpy(dst->ssid, src->ssid, src->ssid_len);
+		}
+	}
+	dst->mode = src->mode;
+	dst->flags = src->flags;
+	dst->time_stamp[0] = src->time_stamp[0];
+	dst->time_stamp[1] = src->time_stamp[1];
+	if (src->flags & NETWORK_HAS_ERP_VALUE)
+	{
+		dst->erp_value = src->erp_value;
+		dst->berp_info_valid = src->berp_info_valid = true;
+	}
+	dst->beacon_interval = src->beacon_interval;
+	dst->listen_interval = src->listen_interval;
+	dst->atim_window = src->atim_window;
+	dst->dtim_period = src->dtim_period;
+	dst->dtim_data = src->dtim_data;
+	dst->last_dtim_sta_time[0] = src->last_dtim_sta_time[0];
+	dst->last_dtim_sta_time[1] = src->last_dtim_sta_time[1];
+	memcpy(&dst->tim, &src->tim, sizeof(struct rtllib_tim_parameters));
+
+        dst->bssht.bdSupportHT = src->bssht.bdSupportHT;
+	dst->bssht.bdRT2RTAggregation = src->bssht.bdRT2RTAggregation;
+	dst->bssht.bdHTCapLen= src->bssht.bdHTCapLen;
+	memcpy(dst->bssht.bdHTCapBuf,src->bssht.bdHTCapBuf,src->bssht.bdHTCapLen);
+	dst->bssht.bdHTInfoLen= src->bssht.bdHTInfoLen;
+	memcpy(dst->bssht.bdHTInfoBuf,src->bssht.bdHTInfoBuf,src->bssht.bdHTInfoLen);
+	dst->bssht.bdHTSpecVer = src->bssht.bdHTSpecVer;
+	dst->bssht.bdRT2RTLongSlotTime = src->bssht.bdRT2RTLongSlotTime;
+	dst->broadcom_cap_exist = src->broadcom_cap_exist;
+	dst->ralink_cap_exist = src->ralink_cap_exist;
+	dst->atheros_cap_exist = src->atheros_cap_exist;
+	dst->realtek_cap_exit = src->realtek_cap_exit;
+	dst->marvell_cap_exist = src->marvell_cap_exist;
+	dst->cisco_cap_exist = src->cisco_cap_exist;
+	dst->airgo_cap_exist = src->airgo_cap_exist;
+	dst->unknown_cap_exist = src->unknown_cap_exist;
+	memcpy(dst->wpa_ie, src->wpa_ie, src->wpa_ie_len);
+	dst->wpa_ie_len = src->wpa_ie_len;
+	memcpy(dst->rsn_ie, src->rsn_ie, src->rsn_ie_len);
+	dst->rsn_ie_len = src->rsn_ie_len;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
+	memcpy(dst->wzc_ie, src->wzc_ie, src->wzc_ie_len);
+	dst->wzc_ie_len = src->wzc_ie_len;
+#endif
+
+	dst->last_scanned = jiffies;
+	/* qos related parameters */
+	qos_active = dst->qos_data.active;
+	old_param = dst->qos_data.param_count;
+	dst->qos_data.supported = src->qos_data.supported;
+	if (dst->flags & NETWORK_HAS_QOS_PARAMETERS)
+		memcpy(&dst->qos_data, &src->qos_data, sizeof(struct rtllib_qos_data));
+	if (dst->qos_data.supported == 1) {
+		if (dst->ssid_len)
+			RTLLIB_DEBUG_QOS
+				("QoS the network %s is QoS supported\n",
+				dst->ssid);
+		else
+			RTLLIB_DEBUG_QOS
+				("QoS the network is QoS supported\n");
+	}
+	dst->qos_data.active = qos_active;
+	dst->qos_data.old_param_count = old_param;
+
+	/* dst->last_associate is not overwritten */
+	dst->wmm_info = src->wmm_info;
+	if (src->wmm_param[0].ac_aci_acm_aifsn|| \
+	   src->wmm_param[1].ac_aci_acm_aifsn|| \
+	   src->wmm_param[2].ac_aci_acm_aifsn|| \
+	   src->wmm_param[1].ac_aci_acm_aifsn) {
+	  memcpy(dst->wmm_param, src->wmm_param, WME_AC_PRAM_LEN);
+	}
+
+	dst->SignalStrength = src->SignalStrength;
+	dst->RSSI = src->RSSI;
+	dst->Turbo_Enable = src->Turbo_Enable;
+
+#ifdef ENABLE_DOT11D
+	dst->CountryIeLen = src->CountryIeLen;
+	memcpy(dst->CountryIeBuf, src->CountryIeBuf, src->CountryIeLen);
+#endif
+
+	dst->bWithAironetIE = src->bWithAironetIE;
+	dst->bCkipSupported = src->bCkipSupported;
+	memcpy(dst->CcxRmState,src->CcxRmState,2);
+	dst->bCcxRmEnable = src->bCcxRmEnable;
+	dst->MBssidMask = src->MBssidMask;
+	dst->bMBssidValid = src->bMBssidValid;
+	memcpy(dst->MBssid,src->MBssid,6);
+	dst->bWithCcxVerNum = src->bWithCcxVerNum;
+	dst->BssCcxVerNumber = src->BssCcxVerNumber;
+
+}
+static inline int is_beacon(__le16 fc)
+{
+	return (WLAN_FC_GET_STYPE(le16_to_cpu(fc)) == RTLLIB_STYPE_BEACON);
+}
+
+#if defined(RTL8192U) || defined(RTL8192SU) || defined(RTL8192SE)
+u8 AsocEntry_ComputeSum(u8 *paddr)
+{
+	u32 sum;
+
+	sum =	paddr[0]+
+			paddr[1]+
+			paddr[2]+
+			paddr[3]+
+			paddr[4]+
+			paddr[5];
+
+	return (u8)(sum % PEER_MAX_ASSOC);
+}
+u8 AsocEntry_AssignAvailableAID(struct rtllib_device *ieee, u8 *paddr)
+{
+	int		i;
+
+	for (i = 0; i < PEER_MAX_ASSOC; i++)
+	{
+		if (ieee->AvailableAIDTable[i] == 99)
+		{
+			ieee->AvailableAIDTable[i] = AsocEntry_ComputeSum(paddr);
+			return i+1;
+		}
+	}
+
+	return 1;
+}
+
+void InitStaInfo(struct rtllib_device *ieee,int index)
+{
+	int idx = index;
+	ieee->peer_assoc_list[idx]->StaDataRate = 0;
+	ieee->peer_assoc_list[idx]->StaSS = 0;
+	ieee->peer_assoc_list[idx]->RetryFrameCnt = 0;
+	ieee->peer_assoc_list[idx]->NoRetryFrameCnt = 0;
+	ieee->peer_assoc_list[idx]->LastRetryCnt = 0;
+	ieee->peer_assoc_list[idx]->LastNoRetryCnt = 0;
+	ieee->peer_assoc_list[idx]->AvgRetryRate = 0;
+	ieee->peer_assoc_list[idx]->LastRetryRate = 0;
+	ieee->peer_assoc_list[idx]->txRateIndex = 11;
+	ieee->peer_assoc_list[idx]->APDataRate = 0x2;
+	ieee->peer_assoc_list[idx]->ForcedDataRate = 0x2;
+
+}
+static u8 IsStaInfoExist(struct rtllib_device *ieee, u8 *addr)
+{
+	int k=0;
+	struct sta_info * psta = NULL;
+	u8 sta_idx = PEER_MAX_ASSOC;
+
+	for (k=0; k<PEER_MAX_ASSOC; k++)
+	{
+		psta = ieee->peer_assoc_list[k];
+		if (NULL != psta)
+		{
+			if (memcmp(addr, psta->macaddr, ETH_ALEN) == 0)
+			{
+				sta_idx = k;
+				break;
+			}
+		}
+	}
+	return sta_idx;
+}
+static u8 GetFreeStaInfoIdx(struct rtllib_device *ieee, u8 *addr)
+{
+	int k = 0;
+	while((ieee->peer_assoc_list[k] != NULL) && (k < PEER_MAX_ASSOC))
+		k++;
+	printk("%s: addr:"MAC_FMT" index: %d\n", __func__, MAC_ARG(addr), k);
+	return k;
+}
+struct sta_info *GetStaInfo(struct rtllib_device *ieee, u8 *addr)
+{
+	int k=0;
+	struct sta_info * psta = NULL;
+	struct sta_info * psta_find = NULL;
+
+	for (k=0; k<PEER_MAX_ASSOC; k++)
+	{
+		psta = ieee->peer_assoc_list[k];
+		if (NULL != psta)
+		{
+			if (memcmp(addr, psta->macaddr, ETH_ALEN) == 0)
+			{
+				psta_find = psta;
+				break;
+			}
+		}
+	}
+	return psta_find;
+}
+void DelStaInfoList(struct rtllib_device *ieee)
+{
+	int idx = 0;
+	struct sta_info * AsocEntry = NULL;
+
+	atomic_set(&ieee->AsocEntryNum, 0);
+	for (idx=0; idx<PEER_MAX_ASSOC; idx++){
+		AsocEntry = ieee->peer_assoc_list[idx];
+		if (NULL != AsocEntry){
+			kfree(AsocEntry);
+			ieee->peer_assoc_list[idx] = NULL;
+		}
+		ieee->AvailableAIDTable[idx] = 99;
+	}
+}
+void DelStaInfo(struct rtllib_device *ieee, u8 *addr)
+{
+	struct sta_info * psta = NULL;
+	int k=0;
+
+	for (k=0; k<PEER_MAX_ASSOC; k++)
+	{
+		psta = ieee->peer_assoc_list[k];
+		if (NULL != psta){
+			if (memcmp(addr, psta->macaddr, ETH_ALEN) == 0){
+				if (psta->aid > 0 && psta->aid-1 < PEER_MAX_ASSOC)
+					ieee->AvailableAIDTable[psta->aid-1] = 99;
+				else
+					printk("%s(): clear non-existing entry AID\n", __func__);
+
+				kfree(psta);
+				ieee->peer_assoc_list[k] = NULL;
+				atomic_dec(&ieee->AsocEntryNum);
+			}
+		}
+	}
+}
+void IbssAgeFunction(struct rtllib_device *ieee)
+{
+	struct sta_info*	AsocEntry = NULL;
+	int				idx;
+	unsigned long		CurrentTime;
+	signed long		TimeDifference;
+	struct rtllib_network *target;
+
+	CurrentTime = jiffies;
+
+	for (idx = 0; idx < PEER_MAX_ASSOC; idx++)
+	{
+		AsocEntry = ieee->peer_assoc_list[idx];
+		if (AsocEntry)
+		{
+			TimeDifference = jiffies_to_msecs(CurrentTime - AsocEntry->LastActiveTime);
+
+			if (TimeDifference > 20000)
+			{
+				printk("IbssAgeFunction(): "MAC_FMT" timeout\n", MAC_ARG(AsocEntry->macaddr));
+				kfree(AsocEntry);
+				ieee->peer_assoc_list[idx] = NULL;
+				atomic_dec(&ieee->AsocEntryNum);
+
+				if (atomic_read(&ieee->AsocEntryNum) == 0){
+
+					down(&ieee->wx_sem);
+					rtllib_stop_protocol(ieee,true);
+
+					list_for_each_entry(target, &ieee->network_list, list) {
+						if (is_same_network(target, &ieee->current_network,(target->ssid_len?1:0))){
+							printk("delete sta of previous Ad-hoc\n");
+							list_del(&target->list);
+							break;
+						}
+					}
+
+					rtllib_start_protocol(ieee);
+					up(&ieee->wx_sem);
+				}
+			}
+		}
+	}
+
+#ifdef TO_DO_LIST
+	if (AsocEntry_AnyStationAssociated(pMgntInfo)==false)
+		DrvIFIndicateDisassociation(Adapter, unspec_reason);
+
+	if (pMgntInfo->dot11CurrentWirelessMode == WIRELESS_MODE_G ||
+		(IS_WIRELESS_MODE_N_24G(Adapter) && pMgntInfo->pHTInfo->bCurSuppCCK)	)
+	{
+		if (nBModeStaCnt == 0)
+		{
+			pMgntInfo->bUseProtection = false;
+			ActUpdate_mCapInfo(Adapter, pMgntInfo->mCap);
+		}
+	}
+
+	if (IS_WIRELESS_MODE_N_24G(Adapter) || IS_WIRELESS_MODE_N_5G(Adapter) )
+	{
+		if (nLegacyStaCnt > 0)
+		{
+			pMgntInfo->pHTInfo->CurrentOpMode = HT_OPMODE_MIXED;
+		}
+		else
+		{
+			if ((pMgntInfo->pHTInfo->bCurBW40MHz) && (n20MHzStaCnt > 0))
+				pMgntInfo->pHTInfo->CurrentOpMode = HT_OPMODE_40MHZ_PROTECT;
+			else
+				pMgntInfo->pHTInfo->CurrentOpMode = HT_OPMODE_NO_PROTECT;
+
+		}
+	}
+
+	if (IS_WIRELESS_MODE_G(Adapter) ||
+		(IS_WIRELESS_MODE_N_24G(Adapter) && pMgntInfo->pHTInfo->bCurSuppCCK))
+	{
+		if (pMgntInfo->bUseProtection)
+		{
+			u8 CckRate[4] = { MGN_1M, MGN_2M, MGN_5_5M, MGN_11M };
+			OCTET_STRING osCckRate;
+			FillOctetString(osCckRate, CckRate, 4);
+			FilterSupportRate(pMgntInfo->mBrates, &osCckRate, false);
+			Adapter->HalFunc.SetHwRegHandler(Adapter, HW_VAR_BASIC_RATE, (pu1Byte)&osCckRate);
+		}
+		else
+		{
+			Adapter->HalFunc.SetHwRegHandler( Adapter, HW_VAR_BASIC_RATE, (pu1Byte)(&pMgntInfo->mBrates) );
+		}
+	}
+#endif
+}
+#endif
+
+static int IsPassiveChannel( struct rtllib_device *rtllib, u8 channel)
+{
+	if (MAX_CHANNEL_NUMBER < channel) {
+		printk("%s(): Invalid Channel\n", __func__);
+		return 0;
+	}
+
+	if (rtllib->active_channel_map[channel] == 2)
+		return 1;
+
+	return 0;
+}
+
+int IsLegalChannel( struct rtllib_device *rtllib, u8 channel)
+{
+	if (MAX_CHANNEL_NUMBER < channel) {
+		printk("%s(): Invalid Channel\n", __func__);
+		return 0;
+	}
+	if (rtllib->active_channel_map[channel] > 0)
+		return 1;
+
+	return 0;
+}
+
+
+static inline void rtllib_process_probe_response(
+	struct rtllib_device *ieee,
+	struct rtllib_probe_response *beacon,
+	struct rtllib_rx_stats *stats)
+{
+	struct rtllib_network *target;
+	struct rtllib_network *oldest = NULL;
+#ifdef CONFIG_RTLLIB_DEBUG
+	struct rtllib_info_element *info_element = &beacon->info_element[0];
+#endif
+	unsigned long flags;
+	short renew;
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,13))
+	struct rtllib_network *network = kzalloc(sizeof(struct rtllib_network), GFP_ATOMIC);
+#else
+	struct rtllib_network *network = kmalloc(sizeof(*network), GFP_ATOMIC);
+	memset(network,0,sizeof(*network));
+#endif
+
+	if (!network) {
+		return;
+	}
+
+	RTLLIB_DEBUG_SCAN(
+		"'%s' (" MAC_FMT "): %c%c%c%c %c%c%c%c-%c%c%c%c %c%c%c%c\n",
+		escape_essid(info_element->data, info_element->len),
+		MAC_ARG(beacon->header.addr3),
+		(beacon->capability & (1<<0xf)) ? '1' : '0',
+		(beacon->capability & (1<<0xe)) ? '1' : '0',
+		(beacon->capability & (1<<0xd)) ? '1' : '0',
+		(beacon->capability & (1<<0xc)) ? '1' : '0',
+		(beacon->capability & (1<<0xb)) ? '1' : '0',
+		(beacon->capability & (1<<0xa)) ? '1' : '0',
+		(beacon->capability & (1<<0x9)) ? '1' : '0',
+		(beacon->capability & (1<<0x8)) ? '1' : '0',
+		(beacon->capability & (1<<0x7)) ? '1' : '0',
+		(beacon->capability & (1<<0x6)) ? '1' : '0',
+		(beacon->capability & (1<<0x5)) ? '1' : '0',
+		(beacon->capability & (1<<0x4)) ? '1' : '0',
+		(beacon->capability & (1<<0x3)) ? '1' : '0',
+		(beacon->capability & (1<<0x2)) ? '1' : '0',
+		(beacon->capability & (1<<0x1)) ? '1' : '0',
+		(beacon->capability & (1<<0x0)) ? '1' : '0');
+
+	if (rtllib_network_init(ieee, beacon, network, stats)) {
+		RTLLIB_DEBUG_SCAN("Dropped '%s' (" MAC_FMT ") via %s.\n",
+				     escape_essid(info_element->data,
+						  info_element->len),
+				     MAC_ARG(beacon->header.addr3),
+				     WLAN_FC_GET_STYPE(beacon->header.frame_ctl) ==
+				     RTLLIB_STYPE_PROBE_RESP ?
+				     "PROBE RESPONSE" : "BEACON");
+		goto free_network;
+	}
+
+
+	if (!IsLegalChannel(ieee, network->channel))
+		goto free_network;
+
+	if (WLAN_FC_GET_STYPE(beacon->header.frame_ctl) == RTLLIB_STYPE_PROBE_RESP) {
+		if (IsPassiveChannel(ieee, network->channel)) {
+			printk("GetScanInfo(): For Global Domain, "
+			       "filter probe response at channel(%d).\n", network->channel);
+			goto free_network;
+		}
+	}
+
+	/* The network parsed correctly -- so now we scan our known networks
+	 * to see if we can find it in our list.
+	 *
+	 * NOTE:  This search is definitely not optimized.  Once its doing
+	 *        the "right thing" we'll optimize it for efficiency if
+	 *        necessary */
+
+	/* Search for this entry in the list and update it if it is
+	 * already there. */
+
+	spin_lock_irqsave(&ieee->lock, flags);
+#if defined(RTL8192U) || defined(RTL8192SU) || defined(RTL8192SE)
+	if (is_beacon(beacon->header.frame_ctl)){
+		if ((ieee->iw_mode == IW_MODE_ADHOC) && (ieee->state == RTLLIB_LINKED))
+		{
+			if ((network->ssid_len == ieee->current_network.ssid_len)
+				&& (!memcmp(network->ssid,ieee->current_network.ssid,ieee->current_network.ssid_len))
+				&& (network->channel == ieee->current_network.channel)
+				&& (ieee->current_network.channel > 0)
+				&& (ieee->current_network.channel <= 14))
+			{
+				if (!memcmp(ieee->current_network.bssid,network->bssid,6))
+				{
+					int idx = 0;
+					struct rtllib_hdr_3addr* header = NULL;
+					int idx_exist = 0;
+					if (timer_pending(&ieee->ibss_wait_timer))
+						del_timer_sync(&ieee->ibss_wait_timer);
+					header = (struct rtllib_hdr_3addr*)&(beacon->header);
+					idx_exist = IsStaInfoExist(ieee,header->addr2);
+					if (idx_exist >= PEER_MAX_ASSOC) {
+						idx = GetFreeStaInfoIdx(ieee, header->addr2);
+					} else {
+						ieee->peer_assoc_list[idx_exist]->LastActiveTime = jiffies;
+						goto no_alloc;
+					}
+					if (idx >= PEER_MAX_ASSOC - 1) {
+						printk("\n%s():ERR!!!Buffer overflow - could not append!!!",__func__);
+						goto free_network;
+					} else {
+						ieee->peer_assoc_list[idx] = (struct sta_info *)kmalloc(sizeof(struct sta_info), GFP_ATOMIC);
+						memset(ieee->peer_assoc_list[idx], 0, sizeof(struct sta_info));
+						ieee->peer_assoc_list[idx]->LastActiveTime = jiffies;
+						memcpy(ieee->peer_assoc_list[idx]->macaddr,header->addr2,ETH_ALEN);
+						ieee->peer_assoc_list[idx]->ratr_index = 8;
+						InitStaInfo(ieee,idx);
+						atomic_inc(&ieee->AsocEntryNum);
+						ieee->peer_assoc_list[idx]->aid = AsocEntry_AssignAvailableAID(ieee, ieee->peer_assoc_list[idx]->macaddr);
+						ieee->check_ht_cap(ieee->dev,ieee->peer_assoc_list[idx],network);
+						queue_delayed_work_rsl(ieee->wq, &ieee->update_assoc_sta_info_wq, 0);
+						ieee->Adhoc_InitRateAdaptive(ieee->dev,ieee->peer_assoc_list[idx]);
+					}
+				}
+			}
+		}
+	}
+	if (ieee->iw_mode == IW_MODE_ADHOC){
+		if ((network->ssid_len == ieee->current_network.ssid_len)
+			&& (!memcmp(network->ssid,ieee->current_network.ssid,ieee->current_network.ssid_len))
+			&& (network->capability & WLAN_CAPABILITY_IBSS)
+			&& (ieee->state == RTLLIB_LINKED_SCANNING))
+		{
+			if (memcmp(ieee->current_network.bssid,network->bssid,6))
+			{
+				printk("%s(): SSID matched but BSSID mismatched.\n",__func__);
+
+				ieee->TargetTsf = beacon->time_stamp[1];
+				ieee->TargetTsf <<= 32;
+				ieee->TargetTsf |= beacon->time_stamp[0];
+
+				ieee->CurrTsf = stats->TimeStampLow;
+
+				queue_delayed_work_rsl(ieee->wq, &ieee->check_tsf_wq, 0);
+			}
+		}
+	}
+#endif
+#if defined(RTL8192U) || defined(RTL8192SU) || defined(RTL8192SE)
+no_alloc:
+	if (ieee->iw_mode == IW_MODE_INFRA)
+#endif
+	{
+		if (is_same_network(&ieee->current_network, network, (network->ssid_len?1:0))) {
+			update_network(&ieee->current_network, network);
+			if ((ieee->current_network.mode == IEEE_N_24G || ieee->current_network.mode == IEEE_G)
+			&& ieee->current_network.berp_info_valid){
+			if (ieee->current_network.erp_value& ERP_UseProtection)
+				ieee->current_network.buseprotection = true;
+		else
+			ieee->current_network.buseprotection = false;
+		}
+		if (is_beacon(beacon->header.frame_ctl))
+		{
+				if (ieee->state >= RTLLIB_LINKED)
+					ieee->LinkDetectInfo.NumRecvBcnInPeriod++;
+			}
+		}
+	}
+#if defined(RTL8192U) || defined(RTL8192SU) || defined(RTL8192SE)
+	else if (ieee->iw_mode == IW_MODE_ADHOC)
+	{
+		if (is_same_network(&ieee->current_network, network, (network->ssid_len?1:0))) {
+			update_ibss_network(&ieee->current_network, network);
+		}
+	}
+#endif
+	list_for_each_entry(target, &ieee->network_list, list) {
+		if (is_same_network(target, network,(target->ssid_len?1:0)))
+			break;
+		if ((oldest == NULL) ||
+		    (target->last_scanned < oldest->last_scanned))
+			oldest = target;
+	}
+
+	/* If we didn't find a match, then get a new network slot to initialize
+	 * with this beacon's information */
+	if (&target->list == &ieee->network_list) {
+		if (list_empty(&ieee->network_free_list)) {
+			/* If there are no more slots, expire the oldest */
+			list_del(&oldest->list);
+			target = oldest;
+			RTLLIB_DEBUG_SCAN("Expired '%s' (" MAC_FMT ") from "
+					     "network list.\n",
+					     escape_essid(target->ssid,
+							  target->ssid_len),
+					     MAC_ARG(target->bssid));
+		} else {
+			/* Otherwise just pull from the free list */
+			target = list_entry(ieee->network_free_list.next,
+					    struct rtllib_network, list);
+			list_del(ieee->network_free_list.next);
+		}
+
+
+#ifdef CONFIG_RTLLIB_DEBUG
+		RTLLIB_DEBUG_SCAN("Adding '%s' (" MAC_FMT ") via %s.\n",
+				     escape_essid(network->ssid,
+						  network->ssid_len),
+				     MAC_ARG(network->bssid),
+				     WLAN_FC_GET_STYPE(beacon->header.frame_ctl) ==
+				     RTLLIB_STYPE_PROBE_RESP ?
+				     "PROBE RESPONSE" : "BEACON");
+#endif
+		memcpy(target, network, sizeof(*target));
+		list_add_tail(&target->list, &ieee->network_list);
+		if (ieee->softmac_features & IEEE_SOFTMAC_ASSOCIATE)
+			rtllib_softmac_new_net(ieee, network);
+	} else {
+		RTLLIB_DEBUG_SCAN("Updating '%s' (" MAC_FMT ") via %s.\n",
+				     escape_essid(target->ssid,
+						  target->ssid_len),
+				     MAC_ARG(target->bssid),
+				     WLAN_FC_GET_STYPE(beacon->header.frame_ctl) ==
+				     RTLLIB_STYPE_PROBE_RESP ?
+				     "PROBE RESPONSE" : "BEACON");
+
+		/* we have an entry and we are going to update it. But this entry may
+		 * be already expired. In this case we do the same as we found a new
+		 * net and call the new_net handler
+		 */
+		renew = !time_after(target->last_scanned + ieee->scan_age, jiffies);
+		if ((!target->ssid_len) &&
+			(((network->ssid_len > 0) && (target->hidden_ssid_len == 0))
+			|| ((ieee->current_network.ssid_len == network->ssid_len) &&
+			   (strncmp(ieee->current_network.ssid, network->ssid, network->ssid_len) == 0) &&
+			   (ieee->state == RTLLIB_NOLINK)))
+			) {
+			renew = 1;
+		}
+		update_network(target, network);
+		if (renew && (ieee->softmac_features & IEEE_SOFTMAC_ASSOCIATE))
+			rtllib_softmac_new_net(ieee, network);
+	}
+
+	spin_unlock_irqrestore(&ieee->lock, flags);
+	if (is_beacon(beacon->header.frame_ctl)&&is_same_network(&ieee->current_network, network, (network->ssid_len?1:0))&&\
+		(ieee->state == RTLLIB_LINKED)) {
+		if (ieee->handle_beacon != NULL) {
+			ieee->handle_beacon(ieee->dev,beacon,&ieee->current_network);
+		}
+	}
+free_network:
+	kfree(network);
+	return;
+}
+
+void rtllib_rx_mgt(struct rtllib_device *ieee,
+                      struct sk_buff *skb,
+		      struct rtllib_rx_stats *stats)
+{
+    struct rtllib_hdr_4addr *header = (struct rtllib_hdr_4addr *)skb->data ;
+    if (WLAN_FC_GET_STYPE(header->frame_ctl) != RTLLIB_STYPE_PROBE_RESP &&
+            WLAN_FC_GET_STYPE(header->frame_ctl) != RTLLIB_STYPE_BEACON)
+        ieee->last_rx_ps_time = jiffies;
+
+    switch (WLAN_FC_GET_STYPE(header->frame_ctl)) {
+
+        case RTLLIB_STYPE_BEACON:
+            RTLLIB_DEBUG_MGMT("received BEACON (%d)\n",
+                    WLAN_FC_GET_STYPE(header->frame_ctl));
+            RTLLIB_DEBUG_SCAN("Beacon\n");
+            rtllib_process_probe_response(
+                    ieee, (struct rtllib_probe_response *)header, stats);
+
+            if (ieee->sta_sleep || (ieee->ps != RTLLIB_PS_DISABLED &&
+                        ieee->iw_mode == IW_MODE_INFRA &&
+                        ieee->state == RTLLIB_LINKED))
+		tasklet_schedule(&ieee->ps_task);
+
+            break;
+
+        case RTLLIB_STYPE_PROBE_RESP:
+            RTLLIB_DEBUG_MGMT("received PROBE RESPONSE (%d)\n",
+                    WLAN_FC_GET_STYPE(header->frame_ctl));
+            RTLLIB_DEBUG_SCAN("Probe response\n");
+            rtllib_process_probe_response(
+                    ieee, (struct rtllib_probe_response *)header, stats);
+            break;
+        case RTLLIB_STYPE_PROBE_REQ:
+            RTLLIB_DEBUG_MGMT("received PROBE RESQUEST (%d)\n",
+                    WLAN_FC_GET_STYPE(header->frame_ctl));
+            RTLLIB_DEBUG_SCAN("Probe request\n");
+            if ((ieee->softmac_features & IEEE_SOFTMAC_PROBERS) &&
+                    ((ieee->iw_mode == IW_MODE_ADHOC ||
+                      ieee->iw_mode == IW_MODE_MASTER) &&
+                     ieee->state == RTLLIB_LINKED)){
+                rtllib_rx_probe_rq(ieee, skb);
+            }
+            break;
+    }
+
+}
