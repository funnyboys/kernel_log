commit b99692f4db0b3d42266c5b95a6b7860c35b596bb
Author: Derek Robson <robsonde@gmail.com>
Date:   Sun Feb 2 20:02:43 2020 +1300

    staging: rtl8192e: style fix - Prefer using '"%s...", __func__'
    
    Fixed checkpatch warnings, Prefer using '"%s...", __func__'
    
    Signed-off-by: Derek Robson <robsonde@gmail.com>
    Link: https://lore.kernel.org/r/20200202070243.112059-1-robsonde@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_tx.c b/drivers/staging/rtl8192e/rtllib_tx.c
index 8cddb2e12dc4..79d7ad7c0a4a 100644
--- a/drivers/staging/rtl8192e/rtllib_tx.c
+++ b/drivers/staging/rtl8192e/rtllib_tx.c
@@ -241,7 +241,7 @@ static int rtllib_classify(struct sk_buff *skb, u8 bIsAmsdu)
 		return 0;
 
 #ifdef VERBOSE_DEBUG
-	print_hex_dump_bytes("rtllib_classify(): ", DUMP_PREFIX_NONE, skb->data,
+	print_hex_dump_bytes("%s: ", __func__, DUMP_PREFIX_NONE, skb->data,
 			     skb->len);
 #endif
 	ip = ip_hdr(skb);

commit 18056f34c3b755f027a0923b0bb9d50a2e339caa
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Apr 2 12:31:58 2019 +0200

    staging: rtl8192e: add proper SPDX identifiers on files that did not have them.
    
    There were a few files for the rtl8192e driver that did not have SPDX
    identifiers on them, so fix that up.  At the same time, remove the "free
    form" text that specified the license of the file, as that is impossible
    for any tool to properly parse.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_tx.c b/drivers/staging/rtl8192e/rtllib_tx.c
index d314b2f602e4..8cddb2e12dc4 100644
--- a/drivers/staging/rtl8192e/rtllib_tx.c
+++ b/drivers/staging/rtl8192e/rtllib_tx.c
@@ -1,32 +1,16 @@
-/******************************************************************************
- *
+// SPDX-License-Identifier: GPL-2.0
+/*
  * Copyright(c) 2003 - 2004 Intel Corporation. All rights reserved.
  *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
  * Contact Information:
  * James P. Ketrenos <ipw2100-admin@linux.intel.com>
  * Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
  *
- *****************************************************************************
- *
  * Few modifications for Realtek's Wi-Fi drivers by
  * Andrea Merello <andrea.merello@gmail.com>
  *
  * A special thanks goes to Realtek for their support !
- *
- *****************************************************************************/
-
+ */
 #include <linux/compiler.h>
 #include <linux/errno.h>
 #include <linux/if_arp.h>

commit 67d412e44df5850522b7f9c2734e1c84ff89eaf7
Author: Davide Spataro <davide90.spataro@gmail.com>
Date:   Mon May 21 22:48:57 2018 +0200

    staging: rtl8192e: rtllib_tx: fix spelling issue.
    
    Fix a spelling problem. Issue found by checkpatch.pl.
    
    Signed-off-by: Davide Spataro <davide90.spataro@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_tx.c b/drivers/staging/rtl8192e/rtllib_tx.c
index fc88d47dea43..d314b2f602e4 100644
--- a/drivers/staging/rtl8192e/rtllib_tx.c
+++ b/drivers/staging/rtl8192e/rtllib_tx.c
@@ -578,7 +578,7 @@ static int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 		.seq_ctl = 0,
 		.qos_ctl = 0
 	};
-	int qos_actived = ieee->current_network.qos_data.active;
+	int qos_activated = ieee->current_network.qos_data.active;
 	u8 dest[ETH_ALEN];
 	u8 src[ETH_ALEN];
 	struct lib80211_crypt_data *crypt = NULL;
@@ -684,7 +684,7 @@ static int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 		else
 			fc = RTLLIB_FTYPE_DATA;
 
-		if (qos_actived)
+		if (qos_activated)
 			fc |= RTLLIB_STYPE_QOS_DATA;
 		else
 			fc |= RTLLIB_STYPE_DATA;
@@ -727,7 +727,7 @@ static int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 			qos_ctl = 0;
 		}
 
-		if (qos_actived) {
+		if (qos_activated) {
 			hdr_len = RTLLIB_3ADDR_LEN + 2;
 
 			/* in case we are a client verify acm is not set for this ac */
@@ -788,7 +788,7 @@ static int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 		txb->encrypted = encrypt;
 		txb->payload_size = cpu_to_le16(bytes);
 
-		if (qos_actived)
+		if (qos_activated)
 			txb->queue_index = UP2AC(skb->priority);
 		else
 			txb->queue_index = WME_AC_BE;
@@ -797,7 +797,7 @@ static int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 			skb_frag = txb->fragments[i];
 			tcb_desc = (struct cb_desc *)(skb_frag->cb +
 				    MAX_DEV_ADDR_SIZE);
-			if (qos_actived) {
+			if (qos_activated) {
 				skb_frag->priority = skb->priority;
 				tcb_desc->queue_index =  UP2AC(skb->priority);
 			} else {
@@ -831,7 +831,7 @@ static int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 				/* The last fragment has the remaining length */
 				bytes = bytes_last_frag;
 			}
-			if ((qos_actived) && (!bIsMulticast)) {
+			if ((qos_activated) && (!bIsMulticast)) {
 				frag_hdr->seq_ctl =
 					 cpu_to_le16(rtllib_query_seqnum(ieee, skb_frag,
 							     header.addr1));
@@ -866,7 +866,7 @@ static int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 				skb_put(skb_frag, 4);
 		}
 
-		if ((qos_actived) && (!bIsMulticast)) {
+		if ((qos_activated) && (!bIsMulticast)) {
 			if (ieee->seq_ctrl[UP2AC(skb->priority) + 1] == 0xFFF)
 				ieee->seq_ctrl[UP2AC(skb->priority) + 1] = 0;
 			else

commit 59ae1d127ac0ae404baf414c434ba2651b793f46
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Fri Jun 16 14:29:20 2017 +0200

    networking: introduce and use skb_put_data()
    
    A common pattern with skb_put() is to just want to memcpy()
    some data into the new space, introduce skb_put_data() for
    this.
    
    An spatch similar to the one for skb_put_zero() converts many
    of the places using it:
    
        @@
        identifier p, p2;
        expression len, skb, data;
        type t, t2;
        @@
        (
        -p = skb_put(skb, len);
        +p = skb_put_data(skb, data, len);
        |
        -p = (t)skb_put(skb, len);
        +p = skb_put_data(skb, data, len);
        )
        (
        p2 = (t2)p;
        -memcpy(p2, data, len);
        |
        -memcpy(p, data, len);
        )
    
        @@
        type t, t2;
        identifier p, p2;
        expression skb, data;
        @@
        t *p;
        ...
        (
        -p = skb_put(skb, sizeof(t));
        +p = skb_put_data(skb, data, sizeof(t));
        |
        -p = (t *)skb_put(skb, sizeof(t));
        +p = skb_put_data(skb, data, sizeof(t));
        )
        (
        p2 = (t2)p;
        -memcpy(p2, data, sizeof(*p));
        |
        -memcpy(p, data, sizeof(*p));
        )
    
        @@
        expression skb, len, data;
        @@
        -memcpy(skb_put(skb, len), data, len);
        +skb_put_data(skb, data, len);
    
    (again, manually post-processed to retain some comments)
    
    Reviewed-by: Stephen Hemminger <stephen@networkplumber.org>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/staging/rtl8192e/rtllib_tx.c b/drivers/staging/rtl8192e/rtllib_tx.c
index 78a3ad5b231f..fc88d47dea43 100644
--- a/drivers/staging/rtl8192e/rtllib_tx.c
+++ b/drivers/staging/rtl8192e/rtllib_tx.c
@@ -624,8 +624,7 @@ static int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 
 			txb->encrypted = 0;
 			txb->payload_size = cpu_to_le16(skb->len);
-			memcpy(skb_put(txb->fragments[0], skb->len), skb->data,
-			       skb->len);
+			skb_put_data(txb->fragments[0], skb->data, skb->len);
 
 			goto success;
 		}
@@ -818,9 +817,7 @@ static int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 			} else {
 				tcb_desc->bHwSec = 0;
 			}
-			frag_hdr = (struct rtllib_hdr_3addrqos *)
-				   skb_put(skb_frag, hdr_len);
-			memcpy(frag_hdr, &header, hdr_len);
+			frag_hdr = skb_put_data(skb_frag, &header, hdr_len);
 
 			/* If this is not the last fragment, then add the
 			 * MOREFRAGS bit to the frame control
@@ -852,7 +849,7 @@ static int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 				bytes -= SNAP_SIZE + sizeof(u16);
 			}
 
-			memcpy(skb_put(skb_frag, bytes), skb->data, bytes);
+			skb_put_data(skb_frag, skb->data, bytes);
 
 			/* Advance the SKB... */
 			skb_pull(skb, bytes);
@@ -895,8 +892,7 @@ static int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 
 		txb->encrypted = 0;
 		txb->payload_size = cpu_to_le16(skb->len);
-		memcpy(skb_put(txb->fragments[0], skb->len), skb->data,
-		       skb->len);
+		skb_put_data(txb->fragments[0], skb->data, skb->len);
 	}
 
  success:

commit 08e1416f9ce89e67bccae388ac85cfd51dcece38
Author: Darryl T. Agostinelli <dagostinelli@gmail.com>
Date:   Tue Sep 27 20:51:25 2016 -0500

    staging: rtl8192e: fixed use a blank line after function/struct/union/enum declarations
    
    fixed use a blank line after function/struct/union/enum declarations
    
    Signed-off-by: Darryl T. Agostinelli <dagostinelli@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_tx.c b/drivers/staging/rtl8192e/rtllib_tx.c
index 43ca90d7d8c3..78a3ad5b231f 100644
--- a/drivers/staging/rtl8192e/rtllib_tx.c
+++ b/drivers/staging/rtl8192e/rtllib_tx.c
@@ -983,6 +983,7 @@ static int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 	return 1;
 
 }
+
 int rtllib_xmit(struct sk_buff *skb, struct net_device *dev)
 {
 	memset(skb->cb, 0, sizeof(skb->cb));

commit ff2f3e0e05dfd0af15fec55c2502f1686a6389ce
Author: Darryl T. Agostinelli <dagostinelli@gmail.com>
Date:   Tue Sep 27 20:51:24 2016 -0500

    staging: rtl8192e: fixed statements should start on a tabstop
    
    fixed statements should start on a tabstop
    
    Signed-off-by: Darryl T. Agostinelli <dagostinelli@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_tx.c b/drivers/staging/rtl8192e/rtllib_tx.c
index 04fbc074e715..43ca90d7d8c3 100644
--- a/drivers/staging/rtl8192e/rtllib_tx.c
+++ b/drivers/staging/rtl8192e/rtllib_tx.c
@@ -731,17 +731,19 @@ static int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 		if (qos_actived) {
 			hdr_len = RTLLIB_3ADDR_LEN + 2;
 
-		/* in case we are a client verify acm is not set for this ac */
-		while (unlikely(ieee->wmm_acm & (0x01 << skb->priority))) {
-			netdev_info(ieee->dev, "skb->priority = %x\n",
-				    skb->priority);
-			if (wme_downgrade_ac(skb))
-				break;
-			netdev_info(ieee->dev, "converted skb->priority = %x\n",
-			       skb->priority);
-		 }
+			/* in case we are a client verify acm is not set for this ac */
+			while (unlikely(ieee->wmm_acm & (0x01 << skb->priority))) {
+				netdev_info(ieee->dev, "skb->priority = %x\n",
+						skb->priority);
+				if (wme_downgrade_ac(skb))
+					break;
+				netdev_info(ieee->dev, "converted skb->priority = %x\n",
+					   skb->priority);
+			}
+
 			qos_ctl |= skb->priority;
 			header.qos_ctl = cpu_to_le16(qos_ctl & RTLLIB_QOS_TID);
+
 		} else {
 			hdr_len = RTLLIB_3ADDR_LEN;
 		}

commit eb9eb87d0a4281691f3259bd661c5946596c7e51
Author: Darryl T. Agostinelli <dagostinelli@gmail.com>
Date:   Tue Sep 27 20:51:23 2016 -0500

    staging: rtl8192e: fixed block comments use * on subsequent lines
    
    fixed block comments use * on subsequent lines
    
    Signed-off-by: Darryl T. Agostinelli <dagostinelli@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_tx.c b/drivers/staging/rtl8192e/rtllib_tx.c
index 58fc70ec5f2f..04fbc074e715 100644
--- a/drivers/staging/rtl8192e/rtllib_tx.c
+++ b/drivers/staging/rtl8192e/rtllib_tx.c
@@ -1,31 +1,31 @@
 /******************************************************************************
-
-  Copyright(c) 2003 - 2004 Intel Corporation. All rights reserved.
-
-  This program is free software; you can redistribute it and/or modify it
-  under the terms of version 2 of the GNU General Public License as
-  published by the Free Software Foundation.
-
-  This program is distributed in the hope that it will be useful, but WITHOUT
-  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
-  more details.
-
-  The full GNU General Public License is included in this distribution in the
-  file called LICENSE.
-
-  Contact Information:
-  James P. Ketrenos <ipw2100-admin@linux.intel.com>
-  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
-
-******************************************************************************
-
-  Few modifications for Realtek's Wi-Fi drivers by
-  Andrea Merello <andrea.merello@gmail.com>
-
-  A special thanks goes to Realtek for their support !
-
-******************************************************************************/
+ *
+ * Copyright(c) 2003 - 2004 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * James P. Ketrenos <ipw2100-admin@linux.intel.com>
+ * Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
+ *
+ *****************************************************************************
+ *
+ * Few modifications for Realtek's Wi-Fi drivers by
+ * Andrea Merello <andrea.merello@gmail.com>
+ *
+ * A special thanks goes to Realtek for their support !
+ *
+ *****************************************************************************/
 
 #include <linux/compiler.h>
 #include <linux/errno.h>

commit ae6d07a5d11a6ee2153521077c4760e22bef886f
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Sun Sep 20 21:04:28 2015 +0200

    staging: rtl8192e: Fix FSF_MAILING_ADDRESS warnings
    
    Remove FSF address from licenses at the beginning of files.
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_tx.c b/drivers/staging/rtl8192e/rtllib_tx.c
index 07555243ae3f..58fc70ec5f2f 100644
--- a/drivers/staging/rtl8192e/rtllib_tx.c
+++ b/drivers/staging/rtl8192e/rtllib_tx.c
@@ -11,10 +11,6 @@
   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
   more details.
 
-  You should have received a copy of the GNU General Public License along with
-  this program; if not, write to the Free Software Foundation, Inc., 59
-  Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
   The full GNU General Public License is included in this distribution in the
   file called LICENSE.
 

commit 4c29207a96885b82175979c723a63de05d5fb2f9
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Sun Sep 20 21:04:27 2015 +0200

    staging: rtl8192e: Fix CONSTANT_COMPARISON warnings
    
    Remove yoda conditions where pointed by checkpatch.
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_tx.c b/drivers/staging/rtl8192e/rtllib_tx.c
index 6d5e29e933ff..07555243ae3f 100644
--- a/drivers/staging/rtl8192e/rtllib_tx.c
+++ b/drivers/staging/rtl8192e/rtllib_tx.c
@@ -635,10 +635,10 @@ static int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 		}
 
 		if (skb->len > 282) {
-			if (ETH_P_IP == ether_type) {
+			if (ether_type == ETH_P_IP) {
 				const struct iphdr *ip = (struct iphdr *)
 					((u8 *)skb->data+14);
-				if (IPPROTO_UDP == ip->protocol) {
+				if (ip->protocol == IPPROTO_UDP) {
 					struct udphdr *udp;
 
 					udp = (struct udphdr *)((u8 *)ip +
@@ -651,7 +651,7 @@ static int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 						ieee->LPSDelayCnt = 200;
 					}
 				}
-			} else if (ETH_P_ARP == ether_type) {
+			} else if (ether_type == ETH_P_ARP) {
 				netdev_info(ieee->dev,
 					    "=================>DHCP Protocol start tx ARP pkt!!\n");
 				bdhcp = true;

commit fc00af0cd0313f1446cf4ff9d536a2db216f8fb7
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Sun Sep 20 21:04:26 2015 +0200

    staging: rtl8192e: Fix SUSPECT_CODE_INDENT warnings
    
    Fix SUSPECT_CODE_INDENT warnings (indentation).
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_tx.c b/drivers/staging/rtl8192e/rtllib_tx.c
index b992e4612fd8..6d5e29e933ff 100644
--- a/drivers/staging/rtl8192e/rtllib_tx.c
+++ b/drivers/staging/rtl8192e/rtllib_tx.c
@@ -487,7 +487,7 @@ static void rtllib_query_protectionmode(struct rtllib_device *ieee,
 	if (ieee->current_network.capability & WLAN_CAPABILITY_SHORT_PREAMBLE)
 		tcb_desc->bUseShortPreamble = true;
 	if (ieee->iw_mode == IW_MODE_MASTER)
-			goto NO_PROTECTION;
+		goto NO_PROTECTION;
 	return;
 NO_PROTECTION:
 	tcb_desc->bRTSEnable	= false;

commit 511998ea5be18a0219151e30c92a5d47533d2c49
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Tue Jul 14 22:04:24 2015 +0200

    staging: rtl8192e: rtllib_tx: Make functions static
    
    Make as many functions as possible static in rtllib_tx.c.
    
    The following functions were affected:
    - rtllib_xmit_inter
    - rtllib_query_seqnum
    - rtllib_put_snap
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_tx.c b/drivers/staging/rtl8192e/rtllib_tx.c
index 517500c83d3e..b992e4612fd8 100644
--- a/drivers/staging/rtl8192e/rtllib_tx.c
+++ b/drivers/staging/rtl8192e/rtllib_tx.c
@@ -151,7 +151,7 @@
 static u8 P802_1H_OUI[P80211_OUI_LEN] = { 0x00, 0x00, 0xf8 };
 static u8 RFC1042_OUI[P80211_OUI_LEN] = { 0x00, 0x00, 0x00 };
 
-inline int rtllib_put_snap(u8 *data, u16 h_proto)
+static int rtllib_put_snap(u8 *data, u16 h_proto)
 {
 	struct rtllib_snap_hdr *snap;
 	u8 *oui;
@@ -514,8 +514,8 @@ static void rtllib_txrate_selectmode(struct rtllib_device *ieee,
 	}
 }
 
-u16 rtllib_query_seqnum(struct rtllib_device *ieee, struct sk_buff *skb,
-			u8 *dst)
+static u16 rtllib_query_seqnum(struct rtllib_device *ieee, struct sk_buff *skb,
+			       u8 *dst)
 {
 	u16 seqnum = 0;
 
@@ -565,7 +565,7 @@ static u8 rtllib_current_rate(struct rtllib_device *ieee)
 		return ieee->rate & 0x7F;
 }
 
-int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
+static int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 {
 	struct rtllib_device *ieee = (struct rtllib_device *)
 				     netdev_priv_rsl(dev);

commit e93c18c7236f3fb90e87c6239ed78ad2c2552dfd
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Tue Jul 14 22:04:09 2015 +0200

    staging: rtl8192e: Remove rtllib_stats structure
    
    Two remaining fields of rtllib_stats are only incremented, but
    never read.
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_tx.c b/drivers/staging/rtl8192e/rtllib_tx.c
index e99ea5e67ef9..517500c83d3e 100644
--- a/drivers/staging/rtl8192e/rtllib_tx.c
+++ b/drivers/staging/rtl8192e/rtllib_tx.c
@@ -205,7 +205,6 @@ int rtllib_encrypt_fragment(struct rtllib_device *ieee, struct sk_buff *frag,
 	if (res < 0) {
 		netdev_info(ieee->dev, "%s: Encryption failed: len=%d.\n",
 			    ieee->dev->name, frag->len);
-		ieee->ieee_stats.tx_discards++;
 		return -1;
 	}
 

commit 35e33b0468ab3b3f5b610bfa4fc9367a3b7c09a8
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Sun May 31 20:19:40 2015 +0200

    staging: rtl8192e: Fix LONG_LINE warnings
    
    Fix most of simple LONG_LINE warnings. None of the changes should affect
    behaviour of code, so several modifications are included in this patch:
    - Code is reindented where needed
    - Local variable names are compacted (priv -> p)
    - Unnecessary casts are removed
    - Nested ifs are replaced with logical and
    - a = b = c = d expressions are split
    - Replace if/then series with clamp_t()
    - Removed unneeded scopes
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_tx.c b/drivers/staging/rtl8192e/rtllib_tx.c
index 7047d2c61c23..e99ea5e67ef9 100644
--- a/drivers/staging/rtl8192e/rtllib_tx.c
+++ b/drivers/staging/rtl8192e/rtllib_tx.c
@@ -57,18 +57,19 @@
  *
  *
  * 802.11 frame_control for data frames - 2 bytes
- *      ,-----------------------------------------------------------------------------------------.
- * bits | 0  |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  8  |  9  |  a  |  b  |  c  |  d  |  e   |
- *      |----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|------|
- * val  | 0  |  0  |  0  |  1  |  x  |  0  |  0  |  0  |  1  |  0  |  x  |  x  |  x  |  x  |  x   |
- *      |----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|------|
- * desc | ^-ver-^  |  ^type-^  |  ^-----subtype-----^  | to  |from |more |retry| pwr |more |wep   |
- *      |          |           | x=0 data,x=1 data+ack | DS  | DS  |frag |     | mgm |data |      |
- *      '-----------------------------------------------------------------------------------------'
- *                                                   /\
- *                                                   |
- * 802.11 Data Frame                                 |
- *          ,--------- 'ctrl' expands to >-----------'
+ *      ,--------------------------------------------------------------------.
+ * bits | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |  9 |  a |  b  |  c  |  d  | e  |
+ *      |---|---|---|---|---|---|---|---|---|----|----|-----|-----|-----|----|
+ * val  | 0 | 0 | 0 | 1 | x | 0 | 0 | 0 | 1 |  0 |  x |  x  |  x  |  x  | x  |
+ *      |---|---|---|---|---|---|---|---|---|----|----|-----|-----|-----|----|
+ * desc |  ver  | type  |  ^-subtype-^  |to |from|more|retry| pwr |more |wep |
+ *      |       |       | x=0 data      |DS | DS |frag|     | mgm |data |    |
+ *      |       |       | x=1 data+ack  |   |    |    |     |     |     |    |
+ *      '--------------------------------------------------------------------'
+ *                                           /\
+ *                                           |
+ * 802.11 Data Frame                         |
+ *          ,--------- 'ctrl' expands to >---'
  *          |
  *       ,--'---,-------------------------------------------------------------.
  * Bytes |  2   |  2   |    6    |    6    |    6    |  2   | 0..2312 |   4  |
@@ -112,15 +113,15 @@
  *       `-----------------------------------------'
  * Total: 18 non-data bytes
  *
- * In the event that fragmentation is required, the incoming payload is split into
- * N parts of size ieee->fts.  The first fragment contains the SNAP header and the
- * remaining packets are just data.
+ * In the event that fragmentation is required, the incoming payload is split
+ * into N parts of size ieee->fts.  The first fragment contains the SNAP header
+ * and the remaining packets are just data.
  *
- * If encryption is enabled, each fragment payload size is reduced by enough space
- * to add the prefix and postfix (IV and ICV totalling 8 bytes in the case of WEP)
- * So if you have 1500 bytes of payload with ieee->fts set to 500 without
- * encryption it will take 3 frames.  With WEP it will take 4 frames as the
- * payload of each frame is reduced to 492 bytes.
+ * If encryption is enabled, each fragment payload size is reduced by enough
+ * space to add the prefix and postfix (IV and ICV totalling 8 bytes in
+ * the case of WEP) So if you have 1500 bytes of payload with ieee->fts set to
+ * 500 without encryption it will take 3 frames.  With WEP it will take 4 frames
+ * as the payload of each frame is reduced to 492 bytes.
  *
  * SKB visualization
  *

commit 7232141526e8c3702984bc5239e283b50c5f3d09
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Sun May 31 20:19:36 2015 +0200

    staging: rtl8192e: Remove RTLLIB_DEBUG_DATA()
    
    Use print_hex_dump_bytes() if VERBOSE_DEBUG is enabled.
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_tx.c b/drivers/staging/rtl8192e/rtllib_tx.c
index 8ef820d52c72..7047d2c61c23 100644
--- a/drivers/staging/rtl8192e/rtllib_tx.c
+++ b/drivers/staging/rtl8192e/rtllib_tx.c
@@ -260,7 +260,10 @@ static int rtllib_classify(struct sk_buff *skb, u8 bIsAmsdu)
 	if (eth->h_proto != htons(ETH_P_IP))
 		return 0;
 
-	RTLLIB_DEBUG_DATA(RTLLIB_DL_DATA, skb->data, skb->len);
+#ifdef VERBOSE_DEBUG
+	print_hex_dump_bytes("rtllib_classify(): ", DUMP_PREFIX_NONE, skb->data,
+			     skb->len);
+#endif
 	ip = ip_hdr(skb);
 	switch (ip->tos & 0xfc) {
 	case 0x20:

commit e77c752f3917c4d3cec864e3354c0a64fdeba03e
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Sun May 31 20:19:31 2015 +0200

    staging: rtl8192e: Remove RTLLIB_DEBUG_(FRAG|EAP|DROP|STATE|TX|RX)()
    
    Use netdev_dbg() instead.
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_tx.c b/drivers/staging/rtl8192e/rtllib_tx.c
index b09d5d00c27c..8ef820d52c72 100644
--- a/drivers/staging/rtl8192e/rtllib_tx.c
+++ b/drivers/staging/rtl8192e/rtllib_tx.c
@@ -670,8 +670,9 @@ int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 			struct eapol *eap = (struct eapol *)(skb->data +
 				sizeof(struct ethhdr) - SNAP_SIZE -
 				sizeof(u16));
-			RTLLIB_DEBUG_EAP("TX: IEEE 802.11 EAPOL frame: %s\n",
-				eap_get_type(eap->type));
+			netdev_dbg(ieee->dev,
+				   "TX: IEEE 802.11 EAPOL frame: %s\n",
+				   eap_get_type(eap->type));
 		}
 
 		/* Advance the SKB to the start of the payload */

commit b57ceb19aba7d40403ca985ec565db8db20f4331
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Sun May 31 20:19:22 2015 +0200

    staging: rtl8192e: Fix PREFER_ETHER_ADDR_COPY warnings
    
    Replace memcpy() with ether_addr_copy() where possible to make
    checkpatch.pl happy.
    Change was target tested (download 1Mb file over WPA2 network)
    with BUG trap for unaligned addresses in ether_addr_copy()
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_tx.c b/drivers/staging/rtl8192e/rtllib_tx.c
index b177d7b32198..b09d5d00c27c 100644
--- a/drivers/staging/rtl8192e/rtllib_tx.c
+++ b/drivers/staging/rtl8192e/rtllib_tx.c
@@ -609,8 +609,8 @@ int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 			goto success;
 		}
 		/* Save source and destination addresses */
-		memcpy(dest, skb->data, ETH_ALEN);
-		memcpy(src, skb->data+ETH_ALEN, ETH_ALEN);
+		ether_addr_copy(dest, skb->data);
+		ether_addr_copy(src, skb->data + ETH_ALEN);
 
 		memset(skb->cb, 0, sizeof(skb->cb));
 		ether_type = ntohs(((struct ethhdr *)skb->data)->h_proto);
@@ -695,22 +695,22 @@ int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 			/* To DS: Addr1 = BSSID, Addr2 = SA,
 			 * Addr3 = DA
 			 */
-			memcpy(&header.addr1, ieee->current_network.bssid,
-			       ETH_ALEN);
-			memcpy(&header.addr2, &src, ETH_ALEN);
+			ether_addr_copy(header.addr1,
+					ieee->current_network.bssid);
+			ether_addr_copy(header.addr2, src);
 			if (IsAmsdu)
-				memcpy(&header.addr3,
-				       ieee->current_network.bssid, ETH_ALEN);
+				ether_addr_copy(header.addr3,
+						ieee->current_network.bssid);
 			else
-				memcpy(&header.addr3, &dest, ETH_ALEN);
+				ether_addr_copy(header.addr3, dest);
 		} else if (ieee->iw_mode == IW_MODE_ADHOC) {
 			/* not From/To DS: Addr1 = DA, Addr2 = SA,
 			 * Addr3 = BSSID
 			 */
-			memcpy(&header.addr1, dest, ETH_ALEN);
-			memcpy(&header.addr2, src, ETH_ALEN);
-			memcpy(&header.addr3, ieee->current_network.bssid,
-			       ETH_ALEN);
+			ether_addr_copy(header.addr1, dest);
+			ether_addr_copy(header.addr2, src);
+			ether_addr_copy(header.addr3,
+					ieee->current_network.bssid);
 		}
 
 		bIsMulticast = is_multicast_ether_addr(header.addr1);

commit 06c111072892d3f5fed9d73d1becb59d3f33410b
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Sun May 31 20:19:21 2015 +0200

    staging: rtl8192e: Make ethernet addresses properly aligned
    
    Reorder ethernet addresses allocated on stack or in non-packed
    structures to keep them aligned(2).
    Use ETH_ALEN as array length in places where it was hardcoded to 6.
    
    Alignment verified using pahole where possible and target-tested
    with BUG_ON() trap in ether_addr_copy.
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_tx.c b/drivers/staging/rtl8192e/rtllib_tx.c
index 3b159638bba2..b177d7b32198 100644
--- a/drivers/staging/rtl8192e/rtllib_tx.c
+++ b/drivers/staging/rtl8192e/rtllib_tx.c
@@ -579,8 +579,9 @@ int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 		.seq_ctl = 0,
 		.qos_ctl = 0
 	};
-	u8 dest[ETH_ALEN], src[ETH_ALEN];
 	int qos_actived = ieee->current_network.qos_data.active;
+	u8 dest[ETH_ALEN];
+	u8 src[ETH_ALEN];
 	struct lib80211_crypt_data *crypt = NULL;
 	struct cb_desc *tcb_desc;
 	u8 bIsMulticast = false;

commit 14b40d92881533dca8b25647f105b9546433cda2
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Wed Apr 1 00:24:37 2015 +0200

    staging: rtl8192e: Comment cleanup (style/format)
    
    - Multiline comments use "network subsystem comment style"
    - Merge short multiline comments
    - Remove empty comments
    - Remove function name comment at the end of small (<1 screen) functions
    - Reformat 802.11 data frame format to use spaces and network format
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_tx.c b/drivers/staging/rtl8192e/rtllib_tx.c
index 2e1aab1230c5..3b159638bba2 100644
--- a/drivers/staging/rtl8192e/rtllib_tx.c
+++ b/drivers/staging/rtl8192e/rtllib_tx.c
@@ -53,102 +53,99 @@
 
 #include "rtllib.h"
 
-/*
-
-
-802.11 Data Frame
-
-
-802.11 frame_control for data frames - 2 bytes
-     ,-----------------------------------------------------------------------------------------.
-bits | 0  |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  8  |  9  |  a  |  b  |  c  |  d  |  e   |
-     |----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|------|
-val  | 0  |  0  |  0  |  1  |  x  |  0  |  0  |  0  |  1  |  0  |  x  |  x  |  x  |  x  |  x   |
-     |----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|------|
-desc | ^-ver-^  |  ^type-^  |  ^-----subtype-----^  | to  |from |more |retry| pwr |more |wep   |
-     |	  |	   | x=0 data,x=1 data+ack | DS  | DS  |frag |     | mgm |data |      |
-     '-----------------------------------------------------------------------------------------'
-						    /\
-						    |
-802.11 Data Frame				   |
-	   ,--------- 'ctrl' expands to >-----------'
-	  |
-      ,--'---,-------------------------------------------------------------.
-Bytes |  2   |  2   |    6    |    6    |    6    |  2   | 0..2312 |   4  |
-      |------|------|---------|---------|---------|------|---------|------|
-Desc. | ctrl | dura |  DA/RA  |   TA    |    SA   | Sequ |  Frame  |  fcs |
-      |      | tion | (BSSID) |	 |	 | ence |  data   |      |
-      `--------------------------------------------------|	 |------'
-Total: 28 non-data bytes				 `----.----'
-							      |
-       .- 'Frame data' expands to <---------------------------'
-       |
-       V
-      ,---------------------------------------------------.
-Bytes |  1   |  1   |    1    |    3     |  2   |  0-2304 |
-      |------|------|---------|----------|------|---------|
-Desc. | SNAP | SNAP | Control |Eth Tunnel| Type | IP      |
-      | DSAP | SSAP |	 |	  |      | Packet  |
-      | 0xAA | 0xAA |0x03 (UI)|0x00-00-F8|      |	 |
-      `-----------------------------------------|	 |
-Total: 8 non-data bytes			 `----.----'
-						     |
-       .- 'IP Packet' expands, if WEP enabled, to <--'
-       |
-       V
-      ,-----------------------.
-Bytes |  4  |   0-2296  |  4  |
-      |-----|-----------|-----|
-Desc. | IV  | Encrypted | ICV |
-      |     | IP Packet |     |
-      `-----------------------'
-Total: 8 non-data bytes
-
-
-802.3 Ethernet Data Frame
-
-      ,-----------------------------------------.
-Bytes |   6   |   6   |  2   |  Variable |   4  |
-      |-------|-------|------|-----------|------|
-Desc. | Dest. | Source| Type | IP Packet |  fcs |
-      |  MAC  |  MAC  |      |	   |      |
-      `-----------------------------------------'
-Total: 18 non-data bytes
-
-In the event that fragmentation is required, the incoming payload is split into
-N parts of size ieee->fts.  The first fragment contains the SNAP header and the
-remaining packets are just data.
-
-If encryption is enabled, each fragment payload size is reduced by enough space
-to add the prefix and postfix (IV and ICV totalling 8 bytes in the case of WEP)
-So if you have 1500 bytes of payload with ieee->fts set to 500 without
-encryption it will take 3 frames.  With WEP it will take 4 frames as the
-payload of each frame is reduced to 492 bytes.
-
-* SKB visualization
-*
-*  ,- skb->data
-* |
-* |    ETHERNET HEADER	,-<-- PAYLOAD
-* |			   |     14 bytes from skb->data
-* |  2 bytes for Type --> ,T. |     (sizeof ethhdr)
-* |		       | | |
-* |,-Dest.--. ,--Src.---. | | |
-* |  6 bytes| | 6 bytes | | | |
-* v	 | |	 | | | |
-* 0	 | v       1 | v | v	   2
-* 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
-*     ^     | ^	 | ^ |
-*     |     | |	 | | |
-*     |     | |	 | `T' <---- 2 bytes for Type
-*     |     | |	 |
-*     |     | '---SNAP--' <-------- 6 bytes for SNAP
-*     |     |
-*     `-IV--' <-------------------- 4 bytes for IV (WEP)
-*
-*      SNAP HEADER
-*
-*/
+/* 802.11 Data Frame
+ *
+ *
+ * 802.11 frame_control for data frames - 2 bytes
+ *      ,-----------------------------------------------------------------------------------------.
+ * bits | 0  |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  8  |  9  |  a  |  b  |  c  |  d  |  e   |
+ *      |----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|------|
+ * val  | 0  |  0  |  0  |  1  |  x  |  0  |  0  |  0  |  1  |  0  |  x  |  x  |  x  |  x  |  x   |
+ *      |----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|------|
+ * desc | ^-ver-^  |  ^type-^  |  ^-----subtype-----^  | to  |from |more |retry| pwr |more |wep   |
+ *      |          |           | x=0 data,x=1 data+ack | DS  | DS  |frag |     | mgm |data |      |
+ *      '-----------------------------------------------------------------------------------------'
+ *                                                   /\
+ *                                                   |
+ * 802.11 Data Frame                                 |
+ *          ,--------- 'ctrl' expands to >-----------'
+ *          |
+ *       ,--'---,-------------------------------------------------------------.
+ * Bytes |  2   |  2   |    6    |    6    |    6    |  2   | 0..2312 |   4  |
+ *       |------|------|---------|---------|---------|------|---------|------|
+ * Desc. | ctrl | dura |  DA/RA  |   TA    |    SA   | Sequ |  Frame  |  fcs |
+ *       |      | tion | (BSSID) |         |         | ence |  data   |      |
+ *       `--------------------------------------------------|         |------'
+ * Total: 28 non-data bytes                                 `----.----'
+ *                                                               |
+ *        .- 'Frame data' expands to <---------------------------'
+ *        |
+ *        V
+ *       ,---------------------------------------------------.
+ * Bytes |  1   |  1   |    1    |    3     |  2   |  0-2304 |
+ *       |------|------|---------|----------|------|---------|
+ * Desc. | SNAP | SNAP | Control |Eth Tunnel| Type | IP      |
+ *       | DSAP | SSAP |         |          |      | Packet  |
+ *       | 0xAA | 0xAA |0x03 (UI)|0x00-00-F8|      |         |
+ *       `-----------------------------------------|         |
+ * Total: 8 non-data bytes                         `----.----'
+ *                                                      |
+ *        .- 'IP Packet' expands, if WEP enabled, to <--'
+ *        |
+ *        V
+ *       ,-----------------------.
+ * Bytes |  4  |   0-2296  |  4  |
+ *       |-----|-----------|-----|
+ * Desc. | IV  | Encrypted | ICV |
+ *       |     | IP Packet |     |
+ *       `-----------------------'
+ * Total: 8 non-data bytes
+ *
+ *
+ * 802.3 Ethernet Data Frame
+ *
+ *       ,-----------------------------------------.
+ * Bytes |   6   |   6   |  2   |  Variable |   4  |
+ *       |-------|-------|------|-----------|------|
+ * Desc. | Dest. | Source| Type | IP Packet |  fcs |
+ *       |  MAC  |  MAC  |      |	   |      |
+ *       `-----------------------------------------'
+ * Total: 18 non-data bytes
+ *
+ * In the event that fragmentation is required, the incoming payload is split into
+ * N parts of size ieee->fts.  The first fragment contains the SNAP header and the
+ * remaining packets are just data.
+ *
+ * If encryption is enabled, each fragment payload size is reduced by enough space
+ * to add the prefix and postfix (IV and ICV totalling 8 bytes in the case of WEP)
+ * So if you have 1500 bytes of payload with ieee->fts set to 500 without
+ * encryption it will take 3 frames.  With WEP it will take 4 frames as the
+ * payload of each frame is reduced to 492 bytes.
+ *
+ * SKB visualization
+ *
+ * ,- skb->data
+ * |
+ * |    ETHERNET HEADER        ,-<-- PAYLOAD
+ * |                           |     14 bytes from skb->data
+ * |  2 bytes for Type --> ,T. |     (sizeof ethhdr)
+ * |                       | | |
+ * |,-Dest.--. ,--Src.---. | | |
+ * |  6 bytes| | 6 bytes | | | |
+ * v         | |         | | | |
+ * 0         | v       1 | v | v           2
+ * 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
+ *     ^     | ^         | ^ |
+ *     |     | |         | | |
+ *     |     | |         | `T' <---- 2 bytes for Type
+ *     |     | |         |
+ *     |     | '---SNAP--' <-------- 6 bytes for SNAP
+ *     |     |
+ *     `-IV--' <-------------------- 4 bytes for IV (WEP)
+ *
+ *      SNAP HEADER
+ *
+ */
 
 static u8 P802_1H_OUI[P80211_OUI_LEN] = { 0x00, 0x00, 0xf8 };
 static u8 RFC1042_OUI[P80211_OUI_LEN] = { 0x00, 0x00, 0x00 };
@@ -190,10 +187,12 @@ int rtllib_encrypt_fragment(struct rtllib_device *ieee, struct sk_buff *frag,
 		return -1;
 	}
 	/* To encrypt, frame format is:
-	 * IV (4 bytes), clear payload (including SNAP), ICV (4 bytes) */
+	 * IV (4 bytes), clear payload (including SNAP), ICV (4 bytes)
+	 */
 
 	/* Host-based IEEE 802.11 fragmentation for TX is not yet supported, so
-	 * call both MSDU and MPDU encryption functions from here. */
+	 * call both MSDU and MPDU encryption functions from here.
+	 */
 	atomic_inc(&crypt->refcnt);
 	res = 0;
 	if (crypt->ops->encrypt_msdu)
@@ -591,7 +590,8 @@ int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 	spin_lock_irqsave(&ieee->lock, flags);
 
 	/* If there is no driver handler to take the TXB, don't bother
-	 * creating it... */
+	 * creating it...
+	 */
 	if ((!ieee->hard_start_xmit && !(ieee->softmac_features &
 	   IEEE_SOFTMAC_TX_QUEUE)) ||
 	   ((!ieee->softmac_data_hard_start_xmit &&
@@ -692,7 +692,8 @@ int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 		if (ieee->iw_mode == IW_MODE_INFRA) {
 			fc |= RTLLIB_FCTL_TODS;
 			/* To DS: Addr1 = BSSID, Addr2 = SA,
-			Addr3 = DA */
+			 * Addr3 = DA
+			 */
 			memcpy(&header.addr1, ieee->current_network.bssid,
 			       ETH_ALEN);
 			memcpy(&header.addr2, &src, ETH_ALEN);
@@ -703,7 +704,8 @@ int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 				memcpy(&header.addr3, &dest, ETH_ALEN);
 		} else if (ieee->iw_mode == IW_MODE_ADHOC) {
 			/* not From/To DS: Addr1 = DA, Addr2 = SA,
-			Addr3 = BSSID */
+			 * Addr3 = BSSID
+			 */
 			memcpy(&header.addr1, dest, ETH_ALEN);
 			memcpy(&header.addr2, src, ETH_ALEN);
 			memcpy(&header.addr3, ieee->current_network.bssid,
@@ -715,7 +717,8 @@ int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 		header.frame_ctl = cpu_to_le16(fc);
 
 		/* Determine fragmentation size based on destination (multicast
-		* and broadcast are not fragmented) */
+		 * and broadcast are not fragmented)
+		 */
 		if (bIsMulticast) {
 			frag_size = MAX_FRAG_THRESHOLD;
 			qos_ctl |= QOS_CTL_NOTCONTAIN_ACK;
@@ -744,14 +747,16 @@ int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 		/* Determine amount of payload per fragment.  Regardless of if
 		 * this stack is providing the full 802.11 header, one will
 		 * eventually be affixed to this fragment -- so we must account
-		 * for it when determining the amount of payload space. */
+		 * for it when determining the amount of payload space.
+		 */
 		bytes_per_frag = frag_size - hdr_len;
 		if (ieee->config &
 		   (CFG_RTLLIB_COMPUTE_FCS | CFG_RTLLIB_RESERVE_FCS))
 			bytes_per_frag -= RTLLIB_FCS_LEN;
 
 		/* Each fragment may need to have room for encrypting
-		 * pre/postfix */
+		 * pre/postfix
+		 */
 		if (encrypt) {
 			bytes_per_frag -= crypt->ops->extra_mpdu_prefix_len +
 				crypt->ops->extra_mpdu_postfix_len +
@@ -759,7 +764,8 @@ int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 				crypt->ops->extra_msdu_postfix_len;
 		}
 		/* Number of fragments is the total bytes_per_frag /
-		* payload_per_fragment */
+		 * payload_per_fragment
+		 */
 		nr_frags = bytes / bytes_per_frag;
 		bytes_last_frag = bytes % bytes_per_frag;
 		if (bytes_last_frag)
@@ -769,7 +775,8 @@ int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 
 		/* When we allocate the TXB we allocate enough space for the
 		 * reserve and full fragment bytes (bytes_per_frag doesn't
-		 * include prefix, postfix, header, FCS, etc.) */
+		 * include prefix, postfix, header, FCS, etc.)
+		 */
 		txb = rtllib_alloc_txb(nr_frags, frag_size +
 				       ieee->tx_headroom, GFP_ATOMIC);
 		if (unlikely(!txb)) {
@@ -813,7 +820,8 @@ int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 			memcpy(frag_hdr, &header, hdr_len);
 
 			/* If this is not the last fragment, then add the
-			 * MOREFRAGS bit to the frame control */
+			 * MOREFRAGS bit to the frame control
+			 */
 			if (i != nr_frags - 1) {
 				frag_hdr->frame_ctl = cpu_to_le16(
 					fc | RTLLIB_FCTL_MOREFRAGS);
@@ -848,7 +856,8 @@ int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 
 			/* Encryption routine will move the header forward in
 			 * order to insert the IV between the header and the
-			 * payload */
+			 * payload
+			 */
 			if (encrypt)
 				rtllib_encrypt_fragment(ieee, skb_frag,
 							hdr_len);

commit 285b7c00e06b4fdd6e9ac63b9b8082508340f1ab
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Wed Apr 1 00:24:26 2015 +0200

    staging: rtl8192e: Fix UNNECESSARY_ELSE warning
    
    Fix checkpatch warnings 'else is not generally useful after a break or return'
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_tx.c b/drivers/staging/rtl8192e/rtllib_tx.c
index f6d0257e4c9b..2e1aab1230c5 100644
--- a/drivers/staging/rtl8192e/rtllib_tx.c
+++ b/drivers/staging/rtl8192e/rtllib_tx.c
@@ -413,6 +413,8 @@ static void rtllib_query_protectionmode(struct rtllib_device *ieee,
 					struct cb_desc *tcb_desc,
 					struct sk_buff *skb)
 {
+	struct rt_hi_throughput *pHTInfo;
+
 	tcb_desc->bRTSSTBC			= false;
 	tcb_desc->bRTSUseShortGI		= false;
 	tcb_desc->bCTSEnable			= false;
@@ -435,50 +437,50 @@ static void rtllib_query_protectionmode(struct rtllib_device *ieee,
 			tcb_desc->rts_rate = MGN_24M;
 		}
 		return;
-	} else {
-		struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
+	}
 
-		while (true) {
-			if (pHTInfo->IOTAction & HT_IOT_ACT_FORCED_CTS2SELF) {
-				tcb_desc->bCTSEnable	= true;
-				tcb_desc->rts_rate  =	MGN_24M;
-				tcb_desc->bRTSEnable = true;
-				break;
-			} else if (pHTInfo->IOTAction & (HT_IOT_ACT_FORCED_RTS |
-				   HT_IOT_ACT_PURE_N_MODE)) {
-				tcb_desc->bRTSEnable = true;
-				tcb_desc->rts_rate  =	MGN_24M;
-				break;
-			}
-			if (ieee->current_network.buseprotection) {
-				tcb_desc->bRTSEnable = true;
-				tcb_desc->bCTSEnable = true;
-				tcb_desc->rts_rate = MGN_24M;
-				break;
-			}
-			if (pHTInfo->bCurrentHTSupport  && pHTInfo->bEnableHT) {
-				u8 HTOpMode = pHTInfo->CurrentOpMode;
-
-				if ((pHTInfo->bCurBW40MHz && (HTOpMode == 2 ||
-				     HTOpMode == 3)) ||
-				     (!pHTInfo->bCurBW40MHz && HTOpMode == 3)) {
-					tcb_desc->rts_rate = MGN_24M;
-					tcb_desc->bRTSEnable = true;
-					break;
-				}
-			}
-			if (skb->len > ieee->rts) {
+	pHTInfo = ieee->pHTInfo;
+
+	while (true) {
+		if (pHTInfo->IOTAction & HT_IOT_ACT_FORCED_CTS2SELF) {
+			tcb_desc->bCTSEnable	= true;
+			tcb_desc->rts_rate  =	MGN_24M;
+			tcb_desc->bRTSEnable = true;
+			break;
+		} else if (pHTInfo->IOTAction & (HT_IOT_ACT_FORCED_RTS |
+			   HT_IOT_ACT_PURE_N_MODE)) {
+			tcb_desc->bRTSEnable = true;
+			tcb_desc->rts_rate  =	MGN_24M;
+			break;
+		}
+		if (ieee->current_network.buseprotection) {
+			tcb_desc->bRTSEnable = true;
+			tcb_desc->bCTSEnable = true;
+			tcb_desc->rts_rate = MGN_24M;
+			break;
+		}
+		if (pHTInfo->bCurrentHTSupport  && pHTInfo->bEnableHT) {
+			u8 HTOpMode = pHTInfo->CurrentOpMode;
+
+			if ((pHTInfo->bCurBW40MHz && (HTOpMode == 2 ||
+			     HTOpMode == 3)) ||
+			     (!pHTInfo->bCurBW40MHz && HTOpMode == 3)) {
 				tcb_desc->rts_rate = MGN_24M;
 				tcb_desc->bRTSEnable = true;
 				break;
 			}
-			if (tcb_desc->bAMPDUEnable) {
-				tcb_desc->rts_rate = MGN_24M;
-				tcb_desc->bRTSEnable = false;
-				break;
-			}
-			goto NO_PROTECTION;
 		}
+		if (skb->len > ieee->rts) {
+			tcb_desc->rts_rate = MGN_24M;
+			tcb_desc->bRTSEnable = true;
+			break;
+		}
+		if (tcb_desc->bAMPDUEnable) {
+			tcb_desc->rts_rate = MGN_24M;
+			tcb_desc->bRTSEnable = false;
+			break;
+		}
+		goto NO_PROTECTION;
 	}
 	if (ieee->current_network.capability & WLAN_CAPABILITY_SHORT_PREAMBLE)
 		tcb_desc->bUseShortPreamble = true;

commit a8f4f33a4f8e5bd0e6b46f29ac74082d0684d9e3
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Tue Mar 17 00:00:58 2015 +0100

    staging: rtl8192e: remove CURRENT_RATE macro
    
    CURRENT_RATE macro is used only once in driver. This patch removes it
    and adds rtllib_current_rate() static function in file using that macro
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_tx.c b/drivers/staging/rtl8192e/rtllib_tx.c
index 7c0af26f267e..f6d0257e4c9b 100644
--- a/drivers/staging/rtl8192e/rtllib_tx.c
+++ b/drivers/staging/rtl8192e/rtllib_tx.c
@@ -550,6 +550,17 @@ static int wme_downgrade_ac(struct sk_buff *skb)
 	}
 }
 
+static u8 rtllib_current_rate(struct rtllib_device *ieee)
+{
+	if (ieee->mode & IEEE_MODE_MASK)
+		return ieee->rate;
+
+	if (ieee->HTCurrentOperaRate)
+		return ieee->HTCurrentOperaRate;
+	else
+		return ieee->rate & 0x7F;
+}
+
 int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 {
 	struct rtllib_device *ieee = (struct rtllib_device *)
@@ -904,8 +915,7 @@ int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 			if (tcb_desc->bMulticast ||  tcb_desc->bBroadcast)
 				tcb_desc->data_rate = ieee->basic_rate;
 			else
-				tcb_desc->data_rate = CURRENT_RATE(ieee->mode,
-					ieee->rate, ieee->HTCurrentOperaRate);
+				tcb_desc->data_rate = rtllib_current_rate(ieee);
 
 			if (bdhcp) {
 				if (ieee->pHTInfo->IOTAction &

commit d69d20549be9e44b928d5f857898fe7432deeaac
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Tue Mar 17 00:00:52 2015 +0100

    staging: rtl8192e: fix coding style warnings (printk -> netdev_*)
    
    Use netdev_*, dev_* or pr_* instead of printk where possible.
    KERN_DEBUG messages are left intact as pr_dbg has different behaviour.
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_tx.c b/drivers/staging/rtl8192e/rtllib_tx.c
index 928cd4cf14bc..7c0af26f267e 100644
--- a/drivers/staging/rtl8192e/rtllib_tx.c
+++ b/drivers/staging/rtl8192e/rtllib_tx.c
@@ -185,7 +185,8 @@ int rtllib_encrypt_fragment(struct rtllib_device *ieee, struct sk_buff *frag,
 	crypt = ieee->crypt_info.crypt[ieee->crypt_info.tx_keyidx];
 
 	if (!(crypt && crypt->ops)) {
-		printk(KERN_INFO "=========>%s(), crypt is null\n", __func__);
+		netdev_info(ieee->dev, "=========>%s(), crypt is null\n",
+			    __func__);
 		return -1;
 	}
 	/* To encrypt, frame format is:
@@ -202,8 +203,8 @@ int rtllib_encrypt_fragment(struct rtllib_device *ieee, struct sk_buff *frag,
 
 	atomic_dec(&crypt->refcnt);
 	if (res < 0) {
-		printk(KERN_INFO "%s: Encryption failed: len=%d.\n",
-		       ieee->dev->name, frag->len);
+		netdev_info(ieee->dev, "%s: Encryption failed: len=%d.\n",
+			    ieee->dev->name, frag->len);
 		ieee->ieee_stats.tx_discards++;
 		return -1;
 	}
@@ -311,7 +312,7 @@ static void rtllib_tx_query_agg_cap(struct rtllib_device *ieee,
 	if (pHTInfo->bCurrentAMPDUEnable) {
 		if (!GetTs(ieee, (struct ts_common_info **)(&pTxTs), hdr->addr1,
 		    skb->priority, TX_DIR, true)) {
-			printk(KERN_INFO "%s: can't get TS\n", __func__);
+			netdev_info(ieee->dev, "%s: can't get TS\n", __func__);
 			return;
 		}
 		if (pTxTs->TxAdmittedBARecord.bValid == false) {
@@ -582,16 +583,15 @@ int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 	   IEEE_SOFTMAC_TX_QUEUE)) ||
 	   ((!ieee->softmac_data_hard_start_xmit &&
 	   (ieee->softmac_features & IEEE_SOFTMAC_TX_QUEUE)))) {
-		printk(KERN_WARNING "%s: No xmit handler.\n",
-		       ieee->dev->name);
+		netdev_warn(ieee->dev, "No xmit handler.\n");
 		goto success;
 	}
 
 
 	if (likely(ieee->raw_tx == 0)) {
 		if (unlikely(skb->len < SNAP_SIZE + sizeof(u16))) {
-			printk(KERN_WARNING "%s: skb too small (%d).\n",
-			ieee->dev->name, skb->len);
+			netdev_warn(ieee->dev, "skb too small (%d).\n",
+				    skb->len);
 			goto success;
 		}
 		/* Save source and destination addresses */
@@ -604,9 +604,8 @@ int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 		if (ieee->iw_mode == IW_MODE_MONITOR) {
 			txb = rtllib_alloc_txb(1, skb->len, GFP_ATOMIC);
 			if (unlikely(!txb)) {
-				printk(KERN_WARNING
-				       "%s: Could not allocate TXB\n",
-				ieee->dev->name);
+				netdev_warn(ieee->dev,
+					    "Could not allocate TXB\n");
 				goto failed;
 			}
 
@@ -636,8 +635,8 @@ int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 					}
 				}
 			} else if (ETH_P_ARP == ether_type) {
-				printk(KERN_INFO
-				       "=================>DHCP Protocol start tx ARP pkt!!\n");
+				netdev_info(ieee->dev,
+					    "=================>DHCP Protocol start tx ARP pkt!!\n");
 				bdhcp = true;
 				ieee->LPSDelayCnt =
 					 ieee->current_network.tim.tim_count;
@@ -717,10 +716,11 @@ int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 
 		/* in case we are a client verify acm is not set for this ac */
 		while (unlikely(ieee->wmm_acm & (0x01 << skb->priority))) {
-			printk(KERN_INFO "skb->priority = %x\n", skb->priority);
+			netdev_info(ieee->dev, "skb->priority = %x\n",
+				    skb->priority);
 			if (wme_downgrade_ac(skb))
 				break;
-			printk(KERN_INFO "converted skb->priority = %x\n",
+			netdev_info(ieee->dev, "converted skb->priority = %x\n",
 			       skb->priority);
 		 }
 			qos_ctl |= skb->priority;
@@ -760,8 +760,7 @@ int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 		txb = rtllib_alloc_txb(nr_frags, frag_size +
 				       ieee->tx_headroom, GFP_ATOMIC);
 		if (unlikely(!txb)) {
-			printk(KERN_WARNING "%s: Could not allocate TXB\n",
-			ieee->dev->name);
+			netdev_warn(ieee->dev, "Could not allocate TXB\n");
 			goto failed;
 		}
 		txb->encrypted = encrypt;
@@ -858,15 +857,14 @@ int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 		}
 	} else {
 		if (unlikely(skb->len < sizeof(struct rtllib_hdr_3addr))) {
-			printk(KERN_WARNING "%s: skb too small (%d).\n",
-			ieee->dev->name, skb->len);
+			netdev_warn(ieee->dev, "skb too small (%d).\n",
+				    skb->len);
 			goto success;
 		}
 
 		txb = rtllib_alloc_txb(1, skb->len, GFP_ATOMIC);
 		if (!txb) {
-			printk(KERN_WARNING "%s: Could not allocate TXB\n",
-			ieee->dev->name);
+			netdev_warn(ieee->dev, "Could not allocate TXB\n");
 			goto failed;
 		}
 

commit 0822339b52f6ea3f20b602362864f2a7ab9d3f7f
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Tue Mar 17 00:00:48 2015 +0100

    staging: rtl8192e: fix coding style issues (merge broken strings)
    
    Fix checkpatch.pl warnings:
    - 'WARNING: quoted string split across lines'
    - 'WARNING: break quoted strings at a space character'
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_tx.c b/drivers/staging/rtl8192e/rtllib_tx.c
index 4f68ffe41475..928cd4cf14bc 100644
--- a/drivers/staging/rtl8192e/rtllib_tx.c
+++ b/drivers/staging/rtl8192e/rtllib_tx.c
@@ -604,8 +604,8 @@ int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 		if (ieee->iw_mode == IW_MODE_MONITOR) {
 			txb = rtllib_alloc_txb(1, skb->len, GFP_ATOMIC);
 			if (unlikely(!txb)) {
-				printk(KERN_WARNING "%s: Could not allocate "
-				       "TXB\n",
+				printk(KERN_WARNING
+				       "%s: Could not allocate TXB\n",
 				ieee->dev->name);
 				goto failed;
 			}
@@ -636,8 +636,8 @@ int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 					}
 				}
 			} else if (ETH_P_ARP == ether_type) {
-				printk(KERN_INFO "=================>DHCP "
-				       "Protocol start tx ARP pkt!!\n");
+				printk(KERN_INFO
+				       "=================>DHCP Protocol start tx ARP pkt!!\n");
 				bdhcp = true;
 				ieee->LPSDelayCnt =
 					 ieee->current_network.tim.tim_count;

commit 66abf01f1dc18068ca2a8677706aedfac386471d
Author: Melike Yurtoglu <aysemelikeyurtoglu@gmail.com>
Date:   Wed Oct 1 00:21:54 2014 +0300

    staging: rtl8192e: Remove unneeded void return
    
    Fixes "void function return statements are not generally
    useful"checkpatch.pl warning
    
    Signed-off-by: Melike Yurtoglu <aysemelikeyurtoglu@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_tx.c b/drivers/staging/rtl8192e/rtllib_tx.c
index 41bb8c21144c..4f68ffe41475 100644
--- a/drivers/staging/rtl8192e/rtllib_tx.c
+++ b/drivers/staging/rtl8192e/rtllib_tx.c
@@ -354,7 +354,6 @@ static void rtllib_tx_query_agg_cap(struct rtllib_device *ieee,
 		tcb_desc->ampdu_factor = 0;
 		break;
 	}
-	return;
 }
 
 static void rtllib_qurey_ShortPreambleMode(struct rtllib_device *ieee,
@@ -366,7 +365,6 @@ static void rtllib_qurey_ShortPreambleMode(struct rtllib_device *ieee,
 	else if (ieee->current_network.capability &
 		 WLAN_CAPABILITY_SHORT_PREAMBLE)
 		tcb_desc->bUseShortPreamble = true;
-	return;
 }
 
 static void rtllib_query_HTCapShortGI(struct rtllib_device *ieee,
@@ -408,7 +406,6 @@ static void rtllib_query_BandwidthMode(struct rtllib_device *ieee,
 	if (pHTInfo->bCurBW40MHz && pHTInfo->bCurTxBW40MHz &&
 	    !ieee->bandwidth_auto_switch.bforced_tx20Mhz)
 		tcb_desc->bPacketBW = true;
-	return;
 }
 
 static void rtllib_query_protectionmode(struct rtllib_device *ieee,

commit 3a6b70c3f3558a2e47d2ca82752f0aed0f3c33c6
Author: Matthew Casey <mdcasey@chabloom.com>
Date:   Fri Aug 22 06:27:52 2014 -0400

    staging: rtl8192e: fixed coding style issues
    
    Fixed missing blank line after declarations issues
    
    Signed-off-by: Matthew Casey <mdcasey@chabloom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_tx.c b/drivers/staging/rtl8192e/rtllib_tx.c
index b7dd1539bbc4..41bb8c21144c 100644
--- a/drivers/staging/rtl8192e/rtllib_tx.c
+++ b/drivers/staging/rtl8192e/rtllib_tx.c
@@ -224,6 +224,7 @@ static struct rtllib_txb *rtllib_alloc_txb(int nr_frags, int txb_size,
 {
 	struct rtllib_txb *txb;
 	int i;
+
 	txb = kmalloc(sizeof(struct rtllib_txb) + (sizeof(u8 *) * nr_frags),
 		      gfp_mask);
 	if (!txb)
@@ -438,6 +439,7 @@ static void rtllib_query_protectionmode(struct rtllib_device *ieee,
 		return;
 	} else {
 		struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
+
 		while (true) {
 			if (pHTInfo->IOTAction & HT_IOT_ACT_FORCED_CTS2SELF) {
 				tcb_desc->bCTSEnable	= true;
@@ -458,6 +460,7 @@ static void rtllib_query_protectionmode(struct rtllib_device *ieee,
 			}
 			if (pHTInfo->bCurrentHTSupport  && pHTInfo->bEnableHT) {
 				u8 HTOpMode = pHTInfo->CurrentOpMode;
+
 				if ((pHTInfo->bCurBW40MHz && (HTOpMode == 2 ||
 				     HTOpMode == 3)) ||
 				     (!pHTInfo->bCurBW40MHz && HTOpMode == 3)) {
@@ -518,6 +521,7 @@ u16 rtllib_query_seqnum(struct rtllib_device *ieee, struct sk_buff *skb,
 		return 0;
 	if (IsQoSDataFrame(skb->data)) {
 		struct tx_ts_record *pTS = NULL;
+
 		if (!GetTs(ieee, (struct ts_common_info **)(&pTS), dst,
 		    skb->priority, TX_DIR, true))
 			return 0;

commit 9326c5ca0982f548cc08c0cffb14dcbd020f3d43
Author: Sean MacLennan <seanm@seanm.ca>
Date:   Wed May 28 11:19:00 2014 -0400

    staging: r8192e_pci: fix htons error
    
    A sparse error fixup removed a htons() which is required for the driver
    to function. This patch puts the htons() back and fixes the sparse
    warning correctly by changing the left side cast.
    
    Signed-off-by: Sean MacLennan <seanm@seanm.ca>
    Cc: stable <stable@vger.kernel.org> # 3.14
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_tx.c b/drivers/staging/rtl8192e/rtllib_tx.c
index 11d0a9d8ee59..b7dd1539bbc4 100644
--- a/drivers/staging/rtl8192e/rtllib_tx.c
+++ b/drivers/staging/rtl8192e/rtllib_tx.c
@@ -171,7 +171,7 @@ inline int rtllib_put_snap(u8 *data, u16 h_proto)
 	snap->oui[1] = oui[1];
 	snap->oui[2] = oui[2];
 
-	*(u16 *)(data + SNAP_SIZE) = h_proto;
+	*(__be16 *)(data + SNAP_SIZE) = htons(h_proto);
 
 	return SNAP_SIZE + sizeof(u16);
 }

commit 83efd52983b75ba976888a777df129b631e6ace5
Author: Monam Agarwal <monamagarwal123@gmail.com>
Date:   Fri Mar 7 02:39:44 2014 +0530

    Staging: rtl8192e: Fix Sparse Warning of invalid assignment in rtllib_tx.c
    
    This patch fixes following sparse warnings:
    drivers/staging/rtl8192e/rtllib_tx.c:942:45: warning: invalid assignment: +=
    drivers/staging/rtl8192e/rtllib_tx.c:942:45:    left side has type unsigned long
    drivers/staging/rtl8192e/rtllib_tx.c:942:45:    right side has type restricted __le16
    drivers/staging/rtl8192e/rtllib_tx.c:947:49: warning: invalid assignment: +=
    drivers/staging/rtl8192e/rtllib_tx.c:947:49:    left side has type unsigned long
    drivers/staging/rtl8192e/rtllib_tx.c:947:49:    right side has type restricted __le16
    
    Signed-off-by: Monam Agarwal <monamagarwal123@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_tx.c b/drivers/staging/rtl8192e/rtllib_tx.c
index 77964885b3f2..11d0a9d8ee59 100644
--- a/drivers/staging/rtl8192e/rtllib_tx.c
+++ b/drivers/staging/rtl8192e/rtllib_tx.c
@@ -939,12 +939,12 @@ int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 	if (txb) {
 		if (ieee->softmac_features & IEEE_SOFTMAC_TX_QUEUE) {
 			dev->stats.tx_packets++;
-			dev->stats.tx_bytes += txb->payload_size;
+			dev->stats.tx_bytes += le16_to_cpu(txb->payload_size);
 			rtllib_softmac_xmit(txb, ieee);
 		} else {
 			if ((*ieee->hard_start_xmit)(txb, dev) == 0) {
 				stats->tx_packets++;
-				stats->tx_bytes += txb->payload_size;
+				stats->tx_bytes += le16_to_cpu(txb->payload_size);
 				return 0;
 			}
 			rtllib_txb_free(txb);

commit 86005e169b35b3d276ff094c6142528acc1f0437
Author: Rashika Kheria <rashika.kheria@gmail.com>
Date:   Sat Nov 2 23:40:15 2013 +0530

    Staging: rtl8192e: Fix Sparse Warning of restricted __le16 degrades to integer in rtllib_tx.c
    
    This patch fixes the following sparse warning in rtllib_tx.c-
    warning: restricted __le16 degrades to integer
    
    Signed-off-by: Rashika Kheria <rashika.kheria@gmail.com>
    Reviewed-by: Josh Triplett <josh@joshtriplett.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_tx.c b/drivers/staging/rtl8192e/rtllib_tx.c
index 8ff03f8675e8..77964885b3f2 100644
--- a/drivers/staging/rtl8192e/rtllib_tx.c
+++ b/drivers/staging/rtl8192e/rtllib_tx.c
@@ -815,7 +815,7 @@ int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 					 cpu_to_le16(rtllib_query_seqnum(ieee, skb_frag,
 							     header.addr1));
 				frag_hdr->seq_ctl =
-					 cpu_to_le16(frag_hdr->seq_ctl<<4 | i);
+					 cpu_to_le16(le16_to_cpu(frag_hdr->seq_ctl)<<4 | i);
 			} else {
 				frag_hdr->seq_ctl =
 					 cpu_to_le16(ieee->seq_ctrl[0]<<4 | i);

commit 198e0d17c2f8081a8a1bb75d6047c7c89326fc66
Author: Rashika Kheria <rashika.kheria@gmail.com>
Date:   Sat Nov 2 23:39:22 2013 +0530

    Staging: rtl8192e: Fix incorrect type in assignment in rtllib_tx.c
    
    This patch fixes the following sparse warning in rtllib_tx.c-
    
    drivers/staging/rtl8192e/rtllib_tx.c:234:24: warning: incorrect type in assignment (different base types)
    drivers/staging/rtl8192e/rtllib_tx.c:234:24:    expected restricted __le16 [usertype] frag_size
    drivers/staging/rtl8192e/rtllib_tx.c:234:24:    got int [signed] txb_size
    drivers/staging/rtl8192e/rtllib_tx.c:613:43: warning: incorrect type in assignment (different base types)
    drivers/staging/rtl8192e/rtllib_tx.c:613:43:    expected restricted __le16 [usertype] payload_size
    drivers/staging/rtl8192e/rtllib_tx.c:613:43:    got unsigned int [unsigned] len
    drivers/staging/rtl8192e/rtllib_tx.c:767:35: warning: incorrect type in assignment (different base types)
    drivers/staging/rtl8192e/rtllib_tx.c:767:35:    expected restricted __le16 [usertype] payload_size
    drivers/staging/rtl8192e/rtllib_tx.c:767:35:    got int [signed] [assigned] bytes
    drivers/staging/rtl8192e/rtllib_tx.c:814:51: warning: incorrect type in assignment (different base types)
    drivers/staging/rtl8192e/rtllib_tx.c:814:51:    expected restricted __le16 [usertype] seq_ctl
    drivers/staging/rtl8192e/rtllib_tx.c:814:51:    got unsigned short
    drivers/staging/rtl8192e/rtllib_tx.c:174:36: warning: incorrect type in assignment (different base types)
    drivers/staging/rtl8192e/rtllib_tx.c:174:36:    expected unsigned short [unsigned] [short] [usertype] <noident>
    drivers/staging/rtl8192e/rtllib_tx.c:174:36:    got restricted __be16 [usertype] <noident>
    drivers/staging/rtl8192e/rtllib_tx.c:873:35: warning: incorrect type in assignment (different base types)
    drivers/staging/rtl8192e/rtllib_tx.c:873:35:    expected restricted __le16 [usertype] payload_size
    drivers/staging/rtl8192e/rtllib_tx.c:873:35:    got unsigned int [unsigned] len
    
    Signed-off-by: Rashika Kheria <rashika.kheria@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_tx.c b/drivers/staging/rtl8192e/rtllib_tx.c
index 3183627823fb..8ff03f8675e8 100644
--- a/drivers/staging/rtl8192e/rtllib_tx.c
+++ b/drivers/staging/rtl8192e/rtllib_tx.c
@@ -171,7 +171,7 @@ inline int rtllib_put_snap(u8 *data, u16 h_proto)
 	snap->oui[1] = oui[1];
 	snap->oui[2] = oui[2];
 
-	*(u16 *)(data + SNAP_SIZE) = htons(h_proto);
+	*(u16 *)(data + SNAP_SIZE) = h_proto;
 
 	return SNAP_SIZE + sizeof(u16);
 }
@@ -231,7 +231,7 @@ static struct rtllib_txb *rtllib_alloc_txb(int nr_frags, int txb_size,
 
 	memset(txb, 0, sizeof(struct rtllib_txb));
 	txb->nr_frags = nr_frags;
-	txb->frag_size = txb_size;
+	txb->frag_size = cpu_to_le16(txb_size);
 
 	for (i = 0; i < nr_frags; i++) {
 		txb->fragments[i] = dev_alloc_skb(txb_size);
@@ -610,7 +610,7 @@ int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 			}
 
 			txb->encrypted = 0;
-			txb->payload_size = skb->len;
+			txb->payload_size = cpu_to_le16(skb->len);
 			memcpy(skb_put(txb->fragments[0], skb->len), skb->data,
 			       skb->len);
 
@@ -764,7 +764,7 @@ int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 			goto failed;
 		}
 		txb->encrypted = encrypt;
-		txb->payload_size = bytes;
+		txb->payload_size = cpu_to_le16(bytes);
 
 		if (qos_actived)
 			txb->queue_index = UP2AC(skb->priority);
@@ -812,8 +812,8 @@ int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 			}
 			if ((qos_actived) && (!bIsMulticast)) {
 				frag_hdr->seq_ctl =
-					 rtllib_query_seqnum(ieee, skb_frag,
-							     header.addr1);
+					 cpu_to_le16(rtllib_query_seqnum(ieee, skb_frag,
+							     header.addr1));
 				frag_hdr->seq_ctl =
 					 cpu_to_le16(frag_hdr->seq_ctl<<4 | i);
 			} else {
@@ -870,7 +870,7 @@ int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 		}
 
 		txb->encrypted = 0;
-		txb->payload_size = skb->len;
+		txb->payload_size = cpu_to_le16(skb->len);
 		memcpy(skb_put(txb->fragments[0], skb->len), skb->data,
 		       skb->len);
 	}

commit 4bb01423ab05af02feaba04823ba6b852dbe5aa6
Author: Valentina Manea <valentina.manea.m@gmail.com>
Date:   Fri Oct 25 11:28:10 2013 +0300

    staging: rtl8192e: do not use comparisons on bool tests
    
    This patch fixes coccinelle errors regarding comparisons
    used in bool tests.
    
    Signed-off-by: Valentina Manea <valentina.manea.m@gmail.com>
    Reviewed-by: Lisa Nguyen <lisa@xenapiadmin.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_tx.c b/drivers/staging/rtl8192e/rtllib_tx.c
index 1cc6a9d5e8a3..3183627823fb 100644
--- a/drivers/staging/rtl8192e/rtllib_tx.c
+++ b/drivers/staging/rtl8192e/rtllib_tx.c
@@ -908,7 +908,7 @@ int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 				tcb_desc->data_rate = CURRENT_RATE(ieee->mode,
 					ieee->rate, ieee->HTCurrentOperaRate);
 
-			if (bdhcp == true) {
+			if (bdhcp) {
 				if (ieee->pHTInfo->IOTAction &
 				    HT_IOT_ACT_WA_IOT_Broadcom) {
 					tcb_desc->data_rate =

commit 559a4c318ca303880fc9f26d50711791c16ae2f3
Author: Andrea Merello <andrea.merello@gmail.com>
Date:   Mon Aug 26 13:53:30 2013 +0200

    staging: Update e-mail address for Andrea Merello
    
    A lot of files contain reference to my old e-mail address.
    Now I'm going not to read mail from it anymore, so update it
    with my current address everywhere.
    
    Signed-off-by: Andrea Merello <andrea.merello@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_tx.c b/drivers/staging/rtl8192e/rtllib_tx.c
index 759d7c7d78e5..1cc6a9d5e8a3 100644
--- a/drivers/staging/rtl8192e/rtllib_tx.c
+++ b/drivers/staging/rtl8192e/rtllib_tx.c
@@ -25,7 +25,7 @@
 ******************************************************************************
 
   Few modifications for Realtek's Wi-Fi drivers by
-  Andrea Merello <andreamrl@tiscali.it>
+  Andrea Merello <andrea.merello@gmail.com>
 
   A special thanks goes to Realtek for their support !
 

commit 4d0c8ee85994c862db7e5121de92cdb6cee5fa63
Author: Edgar Neukirchner <edgar.neukirchner@gmail.com>
Date:   Wed Oct 31 15:48:58 2012 +0100

    Staging: rtl8192e: rtllib_tx.c: fixed an asterisk coding style issue
    
    Fixed coding style issue
    
    Signed-off-by: Edgar Neukirchner <edgar.neukirchner@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_tx.c b/drivers/staging/rtl8192e/rtllib_tx.c
index 42900ee4825b..759d7c7d78e5 100644
--- a/drivers/staging/rtl8192e/rtllib_tx.c
+++ b/drivers/staging/rtl8192e/rtllib_tx.c
@@ -287,7 +287,7 @@ static void rtllib_tx_query_agg_cap(struct rtllib_device *ieee,
 {
 	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
 	struct tx_ts_record *pTxTs = NULL;
-	struct rtllib_hdr_1addr* hdr = (struct rtllib_hdr_1addr *)skb->data;
+	struct rtllib_hdr_1addr *hdr = (struct rtllib_hdr_1addr *)skb->data;
 
 	if (rtllib_act_scanning(ieee, false))
 		return;

commit 14fc42355f10199f39bc38dd2d3e9288a31e770c
Author: Joe Perches <joe@perches.com>
Date:   Tue May 8 10:11:56 2012 -0700

    staging: Remove test of is_broadcast with is_multicast
    
    A broadcast packet is a multicast packet, no need to test twice.
    
    Reorder one defective test in rtl_core of is_multi_ether_addr
    before is_broadcast_ether_addr as the is_multi returns true for
    broadcast frames.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_tx.c b/drivers/staging/rtl8192e/rtllib_tx.c
index f24aa00c533d..42900ee4825b 100644
--- a/drivers/staging/rtl8192e/rtllib_tx.c
+++ b/drivers/staging/rtl8192e/rtllib_tx.c
@@ -296,8 +296,7 @@ static void rtllib_tx_query_agg_cap(struct rtllib_device *ieee,
 		return;
 	if (!IsQoSDataFrame(skb->data))
 		return;
-	if (is_multicast_ether_addr(hdr->addr1) ||
-	    is_broadcast_ether_addr(hdr->addr1))
+	if (is_multicast_ether_addr(hdr->addr1))
 		return;
 
 	if (tcb_desc->bdhcp || ieee->CntAfterLink < 2)
@@ -515,7 +514,7 @@ u16 rtllib_query_seqnum(struct rtllib_device *ieee, struct sk_buff *skb,
 {
 	u16 seqnum = 0;
 
-	if (is_multicast_ether_addr(dst) || is_broadcast_ether_addr(dst))
+	if (is_multicast_ether_addr(dst))
 		return 0;
 	if (IsQoSDataFrame(skb->data)) {
 		struct tx_ts_record *pTS = NULL;
@@ -698,8 +697,7 @@ int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 			       ETH_ALEN);
 		}
 
-		bIsMulticast = is_broadcast_ether_addr(header.addr1) ||
-			       is_multicast_ether_addr(header.addr1);
+		bIsMulticast = is_multicast_ether_addr(header.addr1);
 
 		header.frame_ctl = cpu_to_le16(fc);
 

commit cd01712397ad428f443c05add5d7435e899c0ef1
Author: Justin P. Mattock <justinmattock@gmail.com>
Date:   Mon Apr 23 07:36:52 2012 -0700

    staging: rtl8192e: Fix typos.
    
    Signed-off-by: Justin P. Mattock <justinmattock@gmail.com>
    ACKed-by: Larry Finger <Larry.finger@lwfinger.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_tx.c b/drivers/staging/rtl8192e/rtllib_tx.c
index f451bfc27a86..f24aa00c533d 100644
--- a/drivers/staging/rtl8192e/rtllib_tx.c
+++ b/drivers/staging/rtl8192e/rtllib_tx.c
@@ -59,7 +59,7 @@
 802.11 Data Frame
 
 
-802.11 frame_contorl for data frames - 2 bytes
+802.11 frame_control for data frames - 2 bytes
      ,-----------------------------------------------------------------------------------------.
 bits | 0  |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  8  |  9  |  a  |  b  |  c  |  d  |  e   |
      |----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|------|
@@ -576,7 +576,7 @@ int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 
 	spin_lock_irqsave(&ieee->lock, flags);
 
-	/* If there is no driver handler to take the TXB, dont' bother
+	/* If there is no driver handler to take the TXB, don't bother
 	 * creating it... */
 	if ((!ieee->hard_start_xmit && !(ieee->softmac_features &
 	   IEEE_SOFTMAC_TX_QUEUE)) ||
@@ -738,7 +738,7 @@ int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 		   (CFG_RTLLIB_COMPUTE_FCS | CFG_RTLLIB_RESERVE_FCS))
 			bytes_per_frag -= RTLLIB_FCS_LEN;
 
-		/* Each fragment may need to have room for encryptiong
+		/* Each fragment may need to have room for encrypting
 		 * pre/postfix */
 		if (encrypt) {
 			bytes_per_frag -= crypt->ops->extra_mpdu_prefix_len +

commit 0ddcf5fdfac6bd80e153ee5c405bdfc9cb868b95
Author: Sean MacLennan <seanm@seanm.ca>
Date:   Mon Dec 19 23:21:41 2011 -0500

    staging/rtl8192e: Convert to lib80211_crypt_info
    
    Convert rtllib to use lib80211_crypt_info.
    
    Signed-off-by: Sean MacLennan <seanm@seanm.ca>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/rtl8192e/rtllib_tx.c b/drivers/staging/rtl8192e/rtllib_tx.c
index b038357b6175..f451bfc27a86 100644
--- a/drivers/staging/rtl8192e/rtllib_tx.c
+++ b/drivers/staging/rtl8192e/rtllib_tx.c
@@ -182,7 +182,7 @@ int rtllib_encrypt_fragment(struct rtllib_device *ieee, struct sk_buff *frag,
 	struct lib80211_crypt_data *crypt = NULL;
 	int res;
 
-	crypt = ieee->crypt[ieee->tx_keyidx];
+	crypt = ieee->crypt_info.crypt[ieee->crypt_info.tx_keyidx];
 
 	if (!(crypt && crypt->ops)) {
 		printk(KERN_INFO "=========>%s(), crypt is null\n", __func__);
@@ -645,7 +645,7 @@ int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 		}
 
 		skb->priority = rtllib_classify(skb, IsAmsdu);
-		crypt = ieee->crypt[ieee->tx_keyidx];
+		crypt = ieee->crypt_info.crypt[ieee->crypt_info.tx_keyidx];
 		encrypt = !(ether_type == ETH_P_PAE && ieee->ieee802_1x) &&
 			ieee->host_encrypt && crypt && crypt->ops;
 		if (!encrypt && ieee->ieee802_1x &&

commit 32c44cb5b9fdc6eaa445bd622008dd672a3dd1a7
Author: Sean MacLennan <seanm@seanm.ca>
Date:   Mon Dec 19 23:20:41 2011 -0500

    staging/rtl8192e: Convert to lib80211_crypt_data and lib80211_crypt_ops
    
    Convert rtllib_crypt_data to lib80211_crypt_data and
    rtllib_crypt_ops to lib80211_crypt_ops.
    
    This is almost a 1:1 replacement, only extra_prefix_len and
    extra_postfix_len changed.
    
    Signed-off-by: Sean MacLennan <seanm@seanm.ca>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/rtl8192e/rtllib_tx.c b/drivers/staging/rtl8192e/rtllib_tx.c
index b8135be96e47..b038357b6175 100644
--- a/drivers/staging/rtl8192e/rtllib_tx.c
+++ b/drivers/staging/rtl8192e/rtllib_tx.c
@@ -179,7 +179,7 @@ inline int rtllib_put_snap(u8 *data, u16 h_proto)
 int rtllib_encrypt_fragment(struct rtllib_device *ieee, struct sk_buff *frag,
 			    int hdr_len)
 {
-	struct rtllib_crypt_data *crypt = NULL;
+	struct lib80211_crypt_data *crypt = NULL;
 	int res;
 
 	crypt = ieee->crypt[ieee->tx_keyidx];
@@ -568,7 +568,7 @@ int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 	};
 	u8 dest[ETH_ALEN], src[ETH_ALEN];
 	int qos_actived = ieee->current_network.qos_data.active;
-	struct rtllib_crypt_data *crypt = NULL;
+	struct lib80211_crypt_data *crypt = NULL;
 	struct cb_desc *tcb_desc;
 	u8 bIsMulticast = false;
 	u8 IsAmsdu = false;
@@ -741,8 +741,10 @@ int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 		/* Each fragment may need to have room for encryptiong
 		 * pre/postfix */
 		if (encrypt) {
-			bytes_per_frag -= crypt->ops->extra_prefix_len +
-				crypt->ops->extra_postfix_len;
+			bytes_per_frag -= crypt->ops->extra_mpdu_prefix_len +
+				crypt->ops->extra_mpdu_postfix_len +
+				crypt->ops->extra_msdu_prefix_len +
+				crypt->ops->extra_msdu_postfix_len;
 		}
 		/* Number of fragments is the total bytes_per_frag /
 		* payload_per_fragment */
@@ -790,7 +792,8 @@ int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 				else
 					tcb_desc->bHwSec = 0;
 				skb_reserve(skb_frag,
-					    crypt->ops->extra_prefix_len);
+					    crypt->ops->extra_mpdu_prefix_len +
+					    crypt->ops->extra_msdu_prefix_len);
 			} else {
 				tcb_desc->bHwSec = 0;
 			}

commit e0ec8a67089762b29071e879388986ab7370d330
Author: Devendra Naga <devendra.aaru@gmail.com>
Date:   Tue Dec 13 01:49:29 2011 -0500

    staging: remove version.h includes in rtl8192e
    
    Signed-off-by: Devendra Naga <devendra.aaru@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/rtl8192e/rtllib_tx.c b/drivers/staging/rtl8192e/rtllib_tx.c
index eb3c47299836..b8135be96e47 100644
--- a/drivers/staging/rtl8192e/rtllib_tx.c
+++ b/drivers/staging/rtl8192e/rtllib_tx.c
@@ -46,7 +46,6 @@
 #include <linux/slab.h>
 #include <linux/tcp.h>
 #include <linux/types.h>
-#include <linux/version.h>
 #include <linux/wireless.h>
 #include <linux/etherdevice.h>
 #include <linux/uaccess.h>

commit 3b28499c5519e59fbe9c2dea49ece5a3665be787
Author: Sean MacLennan <seanm@seanm.ca>
Date:   Mon Nov 28 20:20:26 2011 -0500

    rtl8192e: Export symbols
    
    The rtl8192e driver had a natural split between the more generic
    rtllib code and the more specific rtl8192e code. This patch exports
    all the symbols needed by the r8192 specific code from the rtllib
    generic code.
    
    Signed-off-by: Sean MacLennan <seanm@seanm.ca>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/rtl8192e/rtllib_tx.c b/drivers/staging/rtl8192e/rtllib_tx.c
index 44e8006bc1af..eb3c47299836 100644
--- a/drivers/staging/rtl8192e/rtllib_tx.c
+++ b/drivers/staging/rtl8192e/rtllib_tx.c
@@ -965,3 +965,4 @@ int rtllib_xmit(struct sk_buff *skb, struct net_device *dev)
 	memset(skb->cb, 0, sizeof(skb->cb));
 	return rtllib_xmit_inter(skb, dev);
 }
+EXPORT_SYMBOL(rtllib_xmit);

commit ec0dc6beea5436c037707dc0f501cf07878a8e2a
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Thu Aug 25 14:07:04 2011 -0500

    staging: rtl8192e: Fix sparse (non-endian) messages - Part I
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/rtl8192e/rtllib_tx.c b/drivers/staging/rtl8192e/rtllib_tx.c
index f038aa930830..44e8006bc1af 100644
--- a/drivers/staging/rtl8192e/rtllib_tx.c
+++ b/drivers/staging/rtl8192e/rtllib_tx.c
@@ -220,8 +220,8 @@ void rtllib_txb_free(struct rtllib_txb *txb)
 	kfree(txb);
 }
 
-struct rtllib_txb *rtllib_alloc_txb(int nr_frags, int txb_size,
-				    int gfp_mask)
+static struct rtllib_txb *rtllib_alloc_txb(int nr_frags, int txb_size,
+					   gfp_t gfp_mask)
 {
 	struct rtllib_txb *txb;
 	int i;
@@ -251,8 +251,7 @@ struct rtllib_txb *rtllib_alloc_txb(int nr_frags, int txb_size,
 	return txb;
 }
 
-int
-rtllib_classify(struct sk_buff *skb, u8 bIsAmsdu)
+static int rtllib_classify(struct sk_buff *skb, u8 bIsAmsdu)
 {
 	struct ethhdr *eth;
 	struct iphdr *ip;
@@ -283,8 +282,9 @@ rtllib_classify(struct sk_buff *skb, u8 bIsAmsdu)
 	}
 }
 
-void rtllib_tx_query_agg_cap(struct rtllib_device *ieee, struct sk_buff *skb,
-			     struct cb_desc *tcb_desc)
+static void rtllib_tx_query_agg_cap(struct rtllib_device *ieee,
+				    struct sk_buff *skb,
+				    struct cb_desc *tcb_desc)
 {
 	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
 	struct tx_ts_record *pTxTs = NULL;
@@ -358,7 +358,7 @@ void rtllib_tx_query_agg_cap(struct rtllib_device *ieee, struct sk_buff *skb,
 	return;
 }
 
-extern void rtllib_qurey_ShortPreambleMode(struct rtllib_device *ieee,
+static void rtllib_qurey_ShortPreambleMode(struct rtllib_device *ieee,
 					   struct cb_desc *tcb_desc)
 {
 	tcb_desc->bUseShortPreamble = false;
@@ -370,7 +370,7 @@ extern void rtllib_qurey_ShortPreambleMode(struct rtllib_device *ieee,
 	return;
 }
 
-extern void rtllib_query_HTCapShortGI(struct rtllib_device *ieee,
+static void rtllib_query_HTCapShortGI(struct rtllib_device *ieee,
 				      struct cb_desc *tcb_desc)
 {
 	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
@@ -391,8 +391,8 @@ extern void rtllib_query_HTCapShortGI(struct rtllib_device *ieee,
 		tcb_desc->bUseShortGI = true;
 }
 
-void rtllib_query_BandwidthMode(struct rtllib_device *ieee,
-				struct cb_desc *tcb_desc)
+static void rtllib_query_BandwidthMode(struct rtllib_device *ieee,
+				       struct cb_desc *tcb_desc)
 {
 	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
 
@@ -412,8 +412,9 @@ void rtllib_query_BandwidthMode(struct rtllib_device *ieee,
 	return;
 }
 
-void rtllib_query_protectionmode(struct rtllib_device *ieee,
-				 struct cb_desc *tcb_desc, struct sk_buff *skb)
+static void rtllib_query_protectionmode(struct rtllib_device *ieee,
+					struct cb_desc *tcb_desc,
+					struct sk_buff *skb)
 {
 	tcb_desc->bRTSSTBC			= false;
 	tcb_desc->bRTSUseShortGI		= false;
@@ -494,8 +495,8 @@ void rtllib_query_protectionmode(struct rtllib_device *ieee,
 }
 
 
-void rtllib_txrate_selectmode(struct rtllib_device *ieee,
-			      struct cb_desc *tcb_desc)
+static void rtllib_txrate_selectmode(struct rtllib_device *ieee,
+				     struct cb_desc *tcb_desc)
 {
 	if (ieee->bTxDisableRateFallBack)
 		tcb_desc->bTxDisableRateFallBack = true;

commit f38d223b692742e77c70033d145245615c8f3aa5
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Thu Aug 25 11:48:28 2011 -0500

    staging: rtl8192e: Cleanup checkpatch -f warnings and errors - Part XVI
    
    This patch removes all the errors and most of the warnings generated by
    checkpatch -f for rtllib_softmac_tx.c..
    
        Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/rtl8192e/rtllib_tx.c b/drivers/staging/rtl8192e/rtllib_tx.c
index 134e69f4ee5b..f038aa930830 100644
--- a/drivers/staging/rtl8192e/rtllib_tx.c
+++ b/drivers/staging/rtl8192e/rtllib_tx.c
@@ -49,7 +49,7 @@
 #include <linux/version.h>
 #include <linux/wireless.h>
 #include <linux/etherdevice.h>
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
 #include <linux/if_vlan.h>
 
 #include "rtllib.h"
@@ -67,21 +67,21 @@ bits | 0  |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  8  |  9  |  a  |  b  |  c
 val  | 0  |  0  |  0  |  1  |  x  |  0  |  0  |  0  |  1  |  0  |  x  |  x  |  x  |  x  |  x   |
      |----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|------|
 desc | ^-ver-^  |  ^type-^  |  ^-----subtype-----^  | to  |from |more |retry| pwr |more |wep   |
-     |          |           | x=0 data,x=1 data+ack | DS  | DS  |frag |     | mgm |data |      |
+     |	  |	   | x=0 data,x=1 data+ack | DS  | DS  |frag |     | mgm |data |      |
      '-----------------------------------------------------------------------------------------'
-		                                    /\
-                                                    |
-802.11 Data Frame                                   |
-           ,--------- 'ctrl' expands to >-----------'
-          |
+						    /\
+						    |
+802.11 Data Frame				   |
+	   ,--------- 'ctrl' expands to >-----------'
+	  |
       ,--'---,-------------------------------------------------------------.
 Bytes |  2   |  2   |    6    |    6    |    6    |  2   | 0..2312 |   4  |
       |------|------|---------|---------|---------|------|---------|------|
 Desc. | ctrl | dura |  DA/RA  |   TA    |    SA   | Sequ |  Frame  |  fcs |
-      |      | tion | (BSSID) |         |         | ence |  data   |      |
-      `--------------------------------------------------|         |------'
-Total: 28 non-data bytes                                 `----.----'
-                                                              |
+      |      | tion | (BSSID) |	 |	 | ence |  data   |      |
+      `--------------------------------------------------|	 |------'
+Total: 28 non-data bytes				 `----.----'
+							      |
        .- 'Frame data' expands to <---------------------------'
        |
        V
@@ -89,11 +89,11 @@ Total: 28 non-data bytes                                 `----.----'
 Bytes |  1   |  1   |    1    |    3     |  2   |  0-2304 |
       |------|------|---------|----------|------|---------|
 Desc. | SNAP | SNAP | Control |Eth Tunnel| Type | IP      |
-      | DSAP | SSAP |         |          |      | Packet  |
-      | 0xAA | 0xAA |0x03 (UI)|0x00-00-F8|      |         |
-      `-----------------------------------------|         |
-Total: 8 non-data bytes                         `----.----'
-                                                     |
+      | DSAP | SSAP |	 |	  |      | Packet  |
+      | 0xAA | 0xAA |0x03 (UI)|0x00-00-F8|      |	 |
+      `-----------------------------------------|	 |
+Total: 8 non-data bytes			 `----.----'
+						     |
        .- 'IP Packet' expands, if WEP enabled, to <--'
        |
        V
@@ -112,7 +112,7 @@ Total: 8 non-data bytes
 Bytes |   6   |   6   |  2   |  Variable |   4  |
       |-------|-------|------|-----------|------|
 Desc. | Dest. | Source| Type | IP Packet |  fcs |
-      |  MAC  |  MAC  |      |           |      |
+      |  MAC  |  MAC  |      |	   |      |
       `-----------------------------------------'
 Total: 18 non-data bytes
 
@@ -130,19 +130,19 @@ payload of each frame is reduced to 492 bytes.
 *
 *  ,- skb->data
 * |
-* |    ETHERNET HEADER        ,-<-- PAYLOAD
-* |                           |     14 bytes from skb->data
+* |    ETHERNET HEADER	,-<-- PAYLOAD
+* |			   |     14 bytes from skb->data
 * |  2 bytes for Type --> ,T. |     (sizeof ethhdr)
-* |                       | | |
+* |		       | | |
 * |,-Dest.--. ,--Src.---. | | |
 * |  6 bytes| | 6 bytes | | | |
-* v         | |         | | | |
-* 0         | v       1 | v | v           2
+* v	 | |	 | | | |
+* 0	 | v       1 | v | v	   2
 * 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
-*     ^     | ^         | ^ |
-*     |     | |         | | |
-*     |     | |         | `T' <---- 2 bytes for Type
-*     |     | |         |
+*     ^     | ^	 | ^ |
+*     |     | |	 | | |
+*     |     | |	 | `T' <---- 2 bytes for Type
+*     |     | |	 |
 *     |     | '---SNAP--' <-------- 6 bytes for SNAP
 *     |     |
 *     `-IV--' <-------------------- 4 bytes for IV (WEP)
@@ -177,19 +177,16 @@ inline int rtllib_put_snap(u8 *data, u16 h_proto)
 	return SNAP_SIZE + sizeof(u16);
 }
 
-int rtllib_encrypt_fragment(
-	struct rtllib_device *ieee,
-	struct sk_buff *frag,
-	int hdr_len)
+int rtllib_encrypt_fragment(struct rtllib_device *ieee, struct sk_buff *frag,
+			    int hdr_len)
 {
-	struct rtllib_crypt_data* crypt = NULL;
+	struct rtllib_crypt_data *crypt = NULL;
 	int res;
 
 	crypt = ieee->crypt[ieee->tx_keyidx];
 
-	if (!(crypt && crypt->ops))
-	{
-		printk("=========>%s(), crypt is null\n", __func__);
+	if (!(crypt && crypt->ops)) {
+		printk(KERN_INFO "=========>%s(), crypt is null\n", __func__);
 		return -1;
 	}
 	/* To encrypt, frame format is:
@@ -216,20 +213,20 @@ int rtllib_encrypt_fragment(
 }
 
 
-void rtllib_txb_free(struct rtllib_txb *txb) {
+void rtllib_txb_free(struct rtllib_txb *txb)
+{
 	if (unlikely(!txb))
 		return;
 	kfree(txb);
 }
 
 struct rtllib_txb *rtllib_alloc_txb(int nr_frags, int txb_size,
-					  int gfp_mask)
+				    int gfp_mask)
 {
 	struct rtllib_txb *txb;
 	int i;
-	txb = kmalloc(
-		sizeof(struct rtllib_txb) + (sizeof(u8*) * nr_frags),
-		gfp_mask);
+	txb = kmalloc(sizeof(struct rtllib_txb) + (sizeof(u8 *) * nr_frags),
+		      gfp_mask);
 	if (!txb)
 		return NULL;
 
@@ -286,23 +283,25 @@ rtllib_classify(struct sk_buff *skb, u8 bIsAmsdu)
 	}
 }
 
-void rtllib_tx_query_agg_cap(struct rtllib_device* ieee, struct sk_buff* skb, struct cb_desc * tcb_desc)
+void rtllib_tx_query_agg_cap(struct rtllib_device *ieee, struct sk_buff *skb,
+			     struct cb_desc *tcb_desc)
 {
 	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
 	struct tx_ts_record *pTxTs = NULL;
-	struct rtllib_hdr_1addr* hdr = (struct rtllib_hdr_1addr*)skb->data;
+	struct rtllib_hdr_1addr* hdr = (struct rtllib_hdr_1addr *)skb->data;
 
-	if (rtllib_act_scanning(ieee,false))
+	if (rtllib_act_scanning(ieee, false))
 		return;
 
-	if (!pHTInfo->bCurrentHTSupport||!pHTInfo->bEnableHT)
+	if (!pHTInfo->bCurrentHTSupport || !pHTInfo->bEnableHT)
 		return;
 	if (!IsQoSDataFrame(skb->data))
 		return;
-	if (is_multicast_ether_addr(hdr->addr1) || is_broadcast_ether_addr(hdr->addr1))
+	if (is_multicast_ether_addr(hdr->addr1) ||
+	    is_broadcast_ether_addr(hdr->addr1))
 		return;
 
-	if (tcb_desc->bdhcp || ieee->CntAfterLink<2)
+	if (tcb_desc->bdhcp || ieee->CntAfterLink < 2)
 		return;
 
 	if (pHTInfo->IOTAction & HT_IOT_ACT_TX_NO_AGGREGATION)
@@ -310,22 +309,25 @@ void rtllib_tx_query_agg_cap(struct rtllib_device* ieee, struct sk_buff* skb, st
 
 	if (!ieee->GetNmodeSupportBySecCfg(ieee->dev))
 		return;
-	if (pHTInfo->bCurrentAMPDUEnable){
-		if (!GetTs(ieee, (struct ts_common_info **)(&pTxTs), hdr->addr1, skb->priority, TX_DIR, true)){
-			printk("%s: can't get TS\n", __func__);
+	if (pHTInfo->bCurrentAMPDUEnable) {
+		if (!GetTs(ieee, (struct ts_common_info **)(&pTxTs), hdr->addr1,
+		    skb->priority, TX_DIR, true)) {
+			printk(KERN_INFO "%s: can't get TS\n", __func__);
 			return;
 		}
-		if (pTxTs->TxAdmittedBARecord.bValid == false){
-			if (ieee->wpa_ie_len && (ieee->pairwise_key_type == KEY_TYPE_NA)) {
+		if (pTxTs->TxAdmittedBARecord.bValid == false) {
+			if (ieee->wpa_ie_len && (ieee->pairwise_key_type ==
+			    KEY_TYPE_NA)) {
 				;
-			} else if (tcb_desc->bdhcp == 1){
+			} else if (tcb_desc->bdhcp == 1) {
 				;
-			} else if (!pTxTs->bDisable_AddBa){
+			} else if (!pTxTs->bDisable_AddBa) {
 				TsStartAddBaProcess(ieee, pTxTs);
 			}
 			goto FORCED_AGG_SETTING;
 		} else if (pTxTs->bUsingBa == false) {
-			if (SN_LESS(pTxTs->TxAdmittedBARecord.BaStartSeqCtrl.field.SeqNum, (pTxTs->TxCurSeq+1)%4096))
+			if (SN_LESS(pTxTs->TxAdmittedBARecord.BaStartSeqCtrl.field.SeqNum,
+			   (pTxTs->TxCurSeq+1)%4096))
 				pTxTs->bUsingBa = true;
 			else
 				goto FORCED_AGG_SETTING;
@@ -338,81 +340,80 @@ void rtllib_tx_query_agg_cap(struct rtllib_device* ieee, struct sk_buff* skb, st
 	}
 FORCED_AGG_SETTING:
 	switch (pHTInfo->ForcedAMPDUMode) {
-		case HT_AGG_AUTO:
-			break;
-
-		case HT_AGG_FORCE_ENABLE:
-			tcb_desc->bAMPDUEnable = true;
-			tcb_desc->ampdu_density = pHTInfo->ForcedMPDUDensity;
-			tcb_desc->ampdu_factor = pHTInfo->ForcedAMPDUFactor;
-			break;
-
-		case HT_AGG_FORCE_DISABLE:
-			tcb_desc->bAMPDUEnable = false;
-			tcb_desc->ampdu_density = 0;
-			tcb_desc->ampdu_factor = 0;
-			break;
-
+	case HT_AGG_AUTO:
+		break;
+
+	case HT_AGG_FORCE_ENABLE:
+		tcb_desc->bAMPDUEnable = true;
+		tcb_desc->ampdu_density = pHTInfo->ForcedMPDUDensity;
+		tcb_desc->ampdu_factor = pHTInfo->ForcedAMPDUFactor;
+		break;
+
+	case HT_AGG_FORCE_DISABLE:
+		tcb_desc->bAMPDUEnable = false;
+		tcb_desc->ampdu_density = 0;
+		tcb_desc->ampdu_factor = 0;
+		break;
 	}
-		return;
+	return;
 }
 
-extern void rtllib_qurey_ShortPreambleMode(struct rtllib_device* ieee, struct cb_desc * tcb_desc)
+extern void rtllib_qurey_ShortPreambleMode(struct rtllib_device *ieee,
+					   struct cb_desc *tcb_desc)
 {
 	tcb_desc->bUseShortPreamble = false;
 	if (tcb_desc->data_rate == 2)
-	{
 		return;
-	}
-	else if (ieee->current_network.capability & WLAN_CAPABILITY_SHORT_PREAMBLE)
-	{
+	else if (ieee->current_network.capability &
+		 WLAN_CAPABILITY_SHORT_PREAMBLE)
 		tcb_desc->bUseShortPreamble = true;
-	}
 	return;
 }
 
-extern	void
-rtllib_query_HTCapShortGI(struct rtllib_device *ieee, struct cb_desc *tcb_desc)
+extern void rtllib_query_HTCapShortGI(struct rtllib_device *ieee,
+				      struct cb_desc *tcb_desc)
 {
 	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
 
 	tcb_desc->bUseShortGI		= false;
 
-	if (!pHTInfo->bCurrentHTSupport||!pHTInfo->bEnableHT)
+	if (!pHTInfo->bCurrentHTSupport || !pHTInfo->bEnableHT)
 		return;
 
-	if (pHTInfo->bForcedShortGI)
-	{
+	if (pHTInfo->bForcedShortGI) {
 		tcb_desc->bUseShortGI = true;
 		return;
 	}
 
-	if ((pHTInfo->bCurBW40MHz==true) && pHTInfo->bCurShortGI40MHz)
+	if ((pHTInfo->bCurBW40MHz == true) && pHTInfo->bCurShortGI40MHz)
 		tcb_desc->bUseShortGI = true;
-	else if ((pHTInfo->bCurBW40MHz==false) && pHTInfo->bCurShortGI20MHz)
+	else if ((pHTInfo->bCurBW40MHz == false) && pHTInfo->bCurShortGI20MHz)
 		tcb_desc->bUseShortGI = true;
 }
 
-void rtllib_query_BandwidthMode(struct rtllib_device* ieee, struct cb_desc *tcb_desc)
+void rtllib_query_BandwidthMode(struct rtllib_device *ieee,
+				struct cb_desc *tcb_desc)
 {
 	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
 
 	tcb_desc->bPacketBW = false;
 
-	if (!pHTInfo->bCurrentHTSupport||!pHTInfo->bEnableHT)
+	if (!pHTInfo->bCurrentHTSupport || !pHTInfo->bEnableHT)
 		return;
 
 	if (tcb_desc->bMulticast || tcb_desc->bBroadcast)
 		return;
 
-	if ((tcb_desc->data_rate & 0x80)==0)
+	if ((tcb_desc->data_rate & 0x80) == 0)
 		return;
-	if (pHTInfo->bCurBW40MHz && pHTInfo->bCurTxBW40MHz && !ieee->bandwidth_auto_switch.bforced_tx20Mhz)
+	if (pHTInfo->bCurBW40MHz && pHTInfo->bCurTxBW40MHz &&
+	    !ieee->bandwidth_auto_switch.bforced_tx20Mhz)
 		tcb_desc->bPacketBW = true;
 	return;
 }
 
-void rtllib_query_protectionmode(struct rtllib_device* ieee, struct cb_desc * tcb_desc, struct sk_buff* skb)
+void rtllib_query_protectionmode(struct rtllib_device *ieee,
+				 struct cb_desc *tcb_desc, struct sk_buff *skb)
 {
 	tcb_desc->bRTSSTBC			= false;
 	tcb_desc->bRTSUseShortGI		= false;
@@ -426,77 +427,58 @@ void rtllib_query_protectionmode(struct rtllib_device* ieee, struct cb_desc * tc
 	if (is_broadcast_ether_addr(skb->data+16))
 		return;
 
-	if (ieee->mode < IEEE_N_24G)
-	{
-		if (skb->len > ieee->rts)
-		{
+	if (ieee->mode < IEEE_N_24G) {
+		if (skb->len > ieee->rts) {
 			tcb_desc->bRTSEnable = true;
 			tcb_desc->rts_rate = MGN_24M;
-		}
-		else if (ieee->current_network.buseprotection)
-		{
+		} else if (ieee->current_network.buseprotection) {
 			tcb_desc->bRTSEnable = true;
 			tcb_desc->bCTSEnable = true;
 			tcb_desc->rts_rate = MGN_24M;
 		}
 		return;
-	}
-	else
-	{
+	} else {
 		struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
-		while (true)
-		{
-			if (pHTInfo->IOTAction & HT_IOT_ACT_FORCED_CTS2SELF)
-			{
+		while (true) {
+			if (pHTInfo->IOTAction & HT_IOT_ACT_FORCED_CTS2SELF) {
 				tcb_desc->bCTSEnable	= true;
 				tcb_desc->rts_rate  =	MGN_24M;
 				tcb_desc->bRTSEnable = true;
 				break;
-			}
-			else if (pHTInfo->IOTAction & (HT_IOT_ACT_FORCED_RTS|HT_IOT_ACT_PURE_N_MODE))
-			{
+			} else if (pHTInfo->IOTAction & (HT_IOT_ACT_FORCED_RTS |
+				   HT_IOT_ACT_PURE_N_MODE)) {
 				tcb_desc->bRTSEnable = true;
 				tcb_desc->rts_rate  =	MGN_24M;
 				break;
 			}
-			if (ieee->current_network.buseprotection)
-			{
+			if (ieee->current_network.buseprotection) {
 				tcb_desc->bRTSEnable = true;
 				tcb_desc->bCTSEnable = true;
 				tcb_desc->rts_rate = MGN_24M;
 				break;
 			}
-			if (pHTInfo->bCurrentHTSupport  && pHTInfo->bEnableHT)
-			{
+			if (pHTInfo->bCurrentHTSupport  && pHTInfo->bEnableHT) {
 				u8 HTOpMode = pHTInfo->CurrentOpMode;
-				if ((pHTInfo->bCurBW40MHz && (HTOpMode == 2 || HTOpMode == 3)) ||
-							(!pHTInfo->bCurBW40MHz && HTOpMode == 3) )
-				{
+				if ((pHTInfo->bCurBW40MHz && (HTOpMode == 2 ||
+				     HTOpMode == 3)) ||
+				     (!pHTInfo->bCurBW40MHz && HTOpMode == 3)) {
 					tcb_desc->rts_rate = MGN_24M;
 					tcb_desc->bRTSEnable = true;
 					break;
 				}
 			}
-			if (skb->len > ieee->rts)
-			{
+			if (skb->len > ieee->rts) {
 				tcb_desc->rts_rate = MGN_24M;
 				tcb_desc->bRTSEnable = true;
 				break;
 			}
-			if (tcb_desc->bAMPDUEnable)
-			{
+			if (tcb_desc->bAMPDUEnable) {
 				tcb_desc->rts_rate = MGN_24M;
 				tcb_desc->bRTSEnable = false;
 				break;
 			}
 			goto NO_PROTECTION;
 		}
-		}
-	if ( 0 )
-	{
-		tcb_desc->bCTSEnable	= true;
-		tcb_desc->rts_rate = MGN_24M;
-		tcb_desc->bRTSEnable	= true;
 	}
 	if (ieee->current_network.capability & WLAN_CAPABILITY_SHORT_PREAMBLE)
 		tcb_desc->bUseShortPreamble = true;
@@ -506,39 +488,40 @@ void rtllib_query_protectionmode(struct rtllib_device* ieee, struct cb_desc * tc
 NO_PROTECTION:
 	tcb_desc->bRTSEnable	= false;
 	tcb_desc->bCTSEnable	= false;
-	tcb_desc->rts_rate		= 0;
+	tcb_desc->rts_rate	= 0;
 	tcb_desc->RTSSC		= 0;
-	tcb_desc->bRTSBW		= false;
+	tcb_desc->bRTSBW	= false;
 }
 
 
-void rtllib_txrate_selectmode(struct rtllib_device* ieee, struct cb_desc * tcb_desc)
+void rtllib_txrate_selectmode(struct rtllib_device *ieee,
+			      struct cb_desc *tcb_desc)
 {
 	if (ieee->bTxDisableRateFallBack)
 		tcb_desc->bTxDisableRateFallBack = true;
 
 	if (ieee->bTxUseDriverAssingedRate)
 		tcb_desc->bTxUseDriverAssingedRate = true;
-	if (!tcb_desc->bTxDisableRateFallBack || !tcb_desc->bTxUseDriverAssingedRate)
-	{
-		if (ieee->iw_mode == IW_MODE_INFRA || ieee->iw_mode == IW_MODE_ADHOC)
+	if (!tcb_desc->bTxDisableRateFallBack ||
+	    !tcb_desc->bTxUseDriverAssingedRate) {
+		if (ieee->iw_mode == IW_MODE_INFRA ||
+		    ieee->iw_mode == IW_MODE_ADHOC)
 			tcb_desc->RATRIndex = 0;
 	}
 }
 
-u16 rtllib_query_seqnum(struct rtllib_device*ieee, struct sk_buff* skb, u8* dst)
+u16 rtllib_query_seqnum(struct rtllib_device *ieee, struct sk_buff *skb,
+			u8 *dst)
 {
 	u16 seqnum = 0;
 
 	if (is_multicast_ether_addr(dst) || is_broadcast_ether_addr(dst))
 		return 0;
-	if (IsQoSDataFrame(skb->data))
-	{
+	if (IsQoSDataFrame(skb->data)) {
 		struct tx_ts_record *pTS = NULL;
-		if (!GetTs(ieee, (struct ts_common_info **)(&pTS), dst, skb->priority, TX_DIR, true))
-		{
+		if (!GetTs(ieee, (struct ts_common_info **)(&pTS), dst,
+		    skb->priority, TX_DIR, true))
 			return 0;
-		}
 		seqnum = pTS->TxCurSeq;
 		pTS->TxCurSeq = (pTS->TxCurSeq+1)%4096;
 		return seqnum;
@@ -549,26 +532,27 @@ u16 rtllib_query_seqnum(struct rtllib_device*ieee, struct sk_buff* skb, u8* dst)
 static int wme_downgrade_ac(struct sk_buff *skb)
 {
 	switch (skb->priority) {
-		case 6:
-		case 7:
-			skb->priority = 5; /* VO -> VI */
-			return 0;
-		case 4:
-		case 5:
-			skb->priority = 3; /* VI -> BE */
-			return 0;
-		case 0:
-		case 3:
-			skb->priority = 1; /* BE -> BK */
-			return 0;
-		default:
-			return -1;
+	case 6:
+	case 7:
+		skb->priority = 5; /* VO -> VI */
+		return 0;
+	case 4:
+	case 5:
+		skb->priority = 3; /* VI -> BE */
+		return 0;
+	case 0:
+	case 3:
+		skb->priority = 1; /* BE -> BK */
+		return 0;
+	default:
+		return -1;
 	}
 }
 
 int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 {
-	struct rtllib_device *ieee = (struct rtllib_device *)netdev_priv_rsl(dev);
+	struct rtllib_device *ieee = (struct rtllib_device *)
+				     netdev_priv_rsl(dev);
 	struct rtllib_txb *txb = NULL;
 	struct rtllib_hdr_3addrqos *frag_hdr;
 	int i, bytes_per_frag, nr_frags, bytes_last_frag, frag_size;
@@ -584,25 +568,27 @@ int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 	};
 	u8 dest[ETH_ALEN], src[ETH_ALEN];
 	int qos_actived = ieee->current_network.qos_data.active;
-	struct rtllib_crypt_data* crypt = NULL;
+	struct rtllib_crypt_data *crypt = NULL;
 	struct cb_desc *tcb_desc;
 	u8 bIsMulticast = false;
 	u8 IsAmsdu = false;
+	bool	bdhcp = false;
 
-	bool	bdhcp =false;
 	spin_lock_irqsave(&ieee->lock, flags);
 
 	/* If there is no driver handler to take the TXB, dont' bother
 	 * creating it... */
-	if ((!ieee->hard_start_xmit && !(ieee->softmac_features & IEEE_SOFTMAC_TX_QUEUE))||
-	   ((!ieee->softmac_data_hard_start_xmit && (ieee->softmac_features & IEEE_SOFTMAC_TX_QUEUE)))) {
+	if ((!ieee->hard_start_xmit && !(ieee->softmac_features &
+	   IEEE_SOFTMAC_TX_QUEUE)) ||
+	   ((!ieee->softmac_data_hard_start_xmit &&
+	   (ieee->softmac_features & IEEE_SOFTMAC_TX_QUEUE)))) {
 		printk(KERN_WARNING "%s: No xmit handler.\n",
 		       ieee->dev->name);
 		goto success;
 	}
 
 
-	if (likely(ieee->raw_tx == 0)){
+	if (likely(ieee->raw_tx == 0)) {
 		if (unlikely(skb->len < SNAP_SIZE + sizeof(u16))) {
 			printk(KERN_WARNING "%s: skb too small (%d).\n",
 			ieee->dev->name, skb->len);
@@ -615,39 +601,46 @@ int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 		memset(skb->cb, 0, sizeof(skb->cb));
 		ether_type = ntohs(((struct ethhdr *)skb->data)->h_proto);
 
-		if (ieee->iw_mode == IW_MODE_MONITOR)
-		{
+		if (ieee->iw_mode == IW_MODE_MONITOR) {
 			txb = rtllib_alloc_txb(1, skb->len, GFP_ATOMIC);
 			if (unlikely(!txb)) {
-				printk(KERN_WARNING "%s: Could not allocate TXB\n",
+				printk(KERN_WARNING "%s: Could not allocate "
+				       "TXB\n",
 				ieee->dev->name);
 				goto failed;
 			}
 
 			txb->encrypted = 0;
 			txb->payload_size = skb->len;
-			memcpy(skb_put(txb->fragments[0],skb->len), skb->data, skb->len);
+			memcpy(skb_put(txb->fragments[0], skb->len), skb->data,
+			       skb->len);
 
 			goto success;
 		}
 
 		if (skb->len > 282) {
 			if (ETH_P_IP == ether_type) {
-				const struct iphdr *ip = (struct iphdr *)((u8 *)skb->data+14);
+				const struct iphdr *ip = (struct iphdr *)
+					((u8 *)skb->data+14);
 				if (IPPROTO_UDP == ip->protocol) {
-					struct udphdr *udp = (struct udphdr *)((u8 *)ip + (ip->ihl << 2));
-					if (((((u8 *)udp)[1] == 68) && (((u8 *)udp)[3] == 67)) ||
-					    ((((u8 *)udp)[1] == 67) && (((u8 *)udp)[3] == 68))) {
+					struct udphdr *udp;
+
+					udp = (struct udphdr *)((u8 *)ip +
+					      (ip->ihl << 2));
+					if (((((u8 *)udp)[1] == 68) &&
+					   (((u8 *)udp)[3] == 67)) ||
+					   ((((u8 *)udp)[1] == 67) &&
+					   (((u8 *)udp)[3] == 68))) {
 						bdhcp = true;
 						ieee->LPSDelayCnt = 200;
 					}
 				}
-			}else if (ETH_P_ARP == ether_type){
-				printk("=================>DHCP Protocol start tx ARP pkt!!\n");
+			} else if (ETH_P_ARP == ether_type) {
+				printk(KERN_INFO "=================>DHCP "
+				       "Protocol start tx ARP pkt!!\n");
 				bdhcp = true;
-				ieee->LPSDelayCnt = ieee->current_network.tim.tim_count;
-
-
+				ieee->LPSDelayCnt =
+					 ieee->current_network.tim.tim_count;
 			}
 		}
 
@@ -656,13 +649,14 @@ int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 		encrypt = !(ether_type == ETH_P_PAE && ieee->ieee802_1x) &&
 			ieee->host_encrypt && crypt && crypt->ops;
 		if (!encrypt && ieee->ieee802_1x &&
-		ieee->drop_unencrypted && ether_type != ETH_P_PAE) {
+		    ieee->drop_unencrypted && ether_type != ETH_P_PAE) {
 			stats->tx_dropped++;
 			goto success;
 		}
 		if (crypt && !encrypt && ether_type == ETH_P_PAE) {
 			struct eapol *eap = (struct eapol *)(skb->data +
-				sizeof(struct ethhdr) - SNAP_SIZE - sizeof(u16));
+				sizeof(struct ethhdr) - SNAP_SIZE -
+				sizeof(u16));
 			RTLLIB_DEBUG_EAP("TX: IEEE 802.11 EAPOL frame: %s\n",
 				eap_get_type(eap->type));
 		}
@@ -670,7 +664,7 @@ int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 		/* Advance the SKB to the start of the payload */
 		skb_pull(skb, sizeof(struct ethhdr));
 
-                /* Determine total amount of storage required for TXB packets */
+		/* Determine total amount of storage required for TXB packets */
 		bytes = skb->len + SNAP_SIZE + sizeof(u16);
 
 		if (encrypt)
@@ -687,10 +681,12 @@ int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 			fc |= RTLLIB_FCTL_TODS;
 			/* To DS: Addr1 = BSSID, Addr2 = SA,
 			Addr3 = DA */
-			memcpy(&header.addr1, ieee->current_network.bssid, ETH_ALEN);
+			memcpy(&header.addr1, ieee->current_network.bssid,
+			       ETH_ALEN);
 			memcpy(&header.addr2, &src, ETH_ALEN);
 			if (IsAmsdu)
-				memcpy(&header.addr3, ieee->current_network.bssid, ETH_ALEN);
+				memcpy(&header.addr3,
+				       ieee->current_network.bssid, ETH_ALEN);
 			else
 				memcpy(&header.addr3, &dest, ETH_ALEN);
 		} else if (ieee->iw_mode == IW_MODE_ADHOC) {
@@ -698,12 +694,14 @@ int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 			Addr3 = BSSID */
 			memcpy(&header.addr1, dest, ETH_ALEN);
 			memcpy(&header.addr2, src, ETH_ALEN);
-			memcpy(&header.addr3, ieee->current_network.bssid, ETH_ALEN);
+			memcpy(&header.addr3, ieee->current_network.bssid,
+			       ETH_ALEN);
 		}
 
-		bIsMulticast = is_broadcast_ether_addr(header.addr1) ||is_multicast_ether_addr(header.addr1);
+		bIsMulticast = is_broadcast_ether_addr(header.addr1) ||
+			       is_multicast_ether_addr(header.addr1);
 
-                header.frame_ctl = cpu_to_le16(fc);
+		header.frame_ctl = cpu_to_le16(fc);
 
 		/* Determine fragmentation size based on destination (multicast
 		* and broadcast are not fragmented) */
@@ -718,29 +716,30 @@ int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 		if (qos_actived) {
 			hdr_len = RTLLIB_3ADDR_LEN + 2;
 
-                    /* in case we are a client verify acm is not set for this ac */
-                    while (unlikely(ieee->wmm_acm & (0x01 << skb->priority))) {
-                        printk("skb->priority = %x\n", skb->priority);
-                        if (wme_downgrade_ac(skb)) {
-                            break;
-                        }
-                        printk("converted skb->priority = %x\n", skb->priority);
-                    }
-                    qos_ctl |= skb->priority;
-                    header.qos_ctl = cpu_to_le16(qos_ctl & RTLLIB_QOS_TID);
+		/* in case we are a client verify acm is not set for this ac */
+		while (unlikely(ieee->wmm_acm & (0x01 << skb->priority))) {
+			printk(KERN_INFO "skb->priority = %x\n", skb->priority);
+			if (wme_downgrade_ac(skb))
+				break;
+			printk(KERN_INFO "converted skb->priority = %x\n",
+			       skb->priority);
+		 }
+			qos_ctl |= skb->priority;
+			header.qos_ctl = cpu_to_le16(qos_ctl & RTLLIB_QOS_TID);
 		} else {
 			hdr_len = RTLLIB_3ADDR_LEN;
 		}
 		/* Determine amount of payload per fragment.  Regardless of if
-		* this stack is providing the full 802.11 header, one will
-		* eventually be affixed to this fragment -- so we must account for
-		* it when determining the amount of payload space. */
+		 * this stack is providing the full 802.11 header, one will
+		 * eventually be affixed to this fragment -- so we must account
+		 * for it when determining the amount of payload space. */
 		bytes_per_frag = frag_size - hdr_len;
 		if (ieee->config &
-		(CFG_RTLLIB_COMPUTE_FCS | CFG_RTLLIB_RESERVE_FCS))
+		   (CFG_RTLLIB_COMPUTE_FCS | CFG_RTLLIB_RESERVE_FCS))
 			bytes_per_frag -= RTLLIB_FCS_LEN;
 
-		/* Each fragment may need to have room for encryptiong pre/postfix */
+		/* Each fragment may need to have room for encryptiong
+		 * pre/postfix */
 		if (encrypt) {
 			bytes_per_frag -= crypt->ops->extra_prefix_len +
 				crypt->ops->extra_postfix_len;
@@ -754,10 +753,11 @@ int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 		else
 			bytes_last_frag = bytes_per_frag;
 
-		/* When we allocate the TXB we allocate enough space for the reserve
-		* and full fragment bytes (bytes_per_frag doesn't include prefix,
-		* postfix, header, FCS, etc.) */
-		txb = rtllib_alloc_txb(nr_frags, frag_size + ieee->tx_headroom, GFP_ATOMIC);
+		/* When we allocate the TXB we allocate enough space for the
+		 * reserve and full fragment bytes (bytes_per_frag doesn't
+		 * include prefix, postfix, header, FCS, etc.) */
+		txb = rtllib_alloc_txb(nr_frags, frag_size +
+				       ieee->tx_headroom, GFP_ATOMIC);
 		if (unlikely(!txb)) {
 			printk(KERN_WARNING "%s: Could not allocate TXB\n",
 			ieee->dev->name);
@@ -767,16 +767,15 @@ int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 		txb->payload_size = bytes;
 
 		if (qos_actived)
-		{
 			txb->queue_index = UP2AC(skb->priority);
-		} else {
-			txb->queue_index = WME_AC_BE;;
-		}
+		else
+			txb->queue_index = WME_AC_BE;
 
 		for (i = 0; i < nr_frags; i++) {
 			skb_frag = txb->fragments[i];
-			tcb_desc = (struct cb_desc *)(skb_frag->cb + MAX_DEV_ADDR_SIZE);
-			if (qos_actived){
+			tcb_desc = (struct cb_desc *)(skb_frag->cb +
+				    MAX_DEV_ADDR_SIZE);
+			if (qos_actived) {
 				skb_frag->priority = skb->priority;
 				tcb_desc->queue_index =  UP2AC(skb->priority);
 			} else {
@@ -785,41 +784,46 @@ int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 			}
 			skb_reserve(skb_frag, ieee->tx_headroom);
 
-			if (encrypt){
+			if (encrypt) {
 				if (ieee->hwsec_active)
 					tcb_desc->bHwSec = 1;
 				else
 					tcb_desc->bHwSec = 0;
-				skb_reserve(skb_frag, crypt->ops->extra_prefix_len);
+				skb_reserve(skb_frag,
+					    crypt->ops->extra_prefix_len);
 			} else {
 				tcb_desc->bHwSec = 0;
 			}
-			frag_hdr = (struct rtllib_hdr_3addrqos *)skb_put(skb_frag, hdr_len);
+			frag_hdr = (struct rtllib_hdr_3addrqos *)
+				   skb_put(skb_frag, hdr_len);
 			memcpy(frag_hdr, &header, hdr_len);
 
-			/* If this is not the last fragment, then add the MOREFRAGS
-			* bit to the frame control */
+			/* If this is not the last fragment, then add the
+			 * MOREFRAGS bit to the frame control */
 			if (i != nr_frags - 1) {
 				frag_hdr->frame_ctl = cpu_to_le16(
 					fc | RTLLIB_FCTL_MOREFRAGS);
 				bytes = bytes_per_frag;
 
 			} else {
-				/* The last fragment takes the remaining length */
+				/* The last fragment has the remaining length */
 				bytes = bytes_last_frag;
 			}
-			if ((qos_actived) && (!bIsMulticast))
-			{
-				frag_hdr->seq_ctl = rtllib_query_seqnum(ieee, skb_frag, header.addr1);
-				frag_hdr->seq_ctl = cpu_to_le16(frag_hdr->seq_ctl<<4 | i);
+			if ((qos_actived) && (!bIsMulticast)) {
+				frag_hdr->seq_ctl =
+					 rtllib_query_seqnum(ieee, skb_frag,
+							     header.addr1);
+				frag_hdr->seq_ctl =
+					 cpu_to_le16(frag_hdr->seq_ctl<<4 | i);
 			} else {
-				frag_hdr->seq_ctl = cpu_to_le16(ieee->seq_ctrl[0]<<4 | i);
+				frag_hdr->seq_ctl =
+					 cpu_to_le16(ieee->seq_ctrl[0]<<4 | i);
 			}
 			/* Put a SNAP header on the first fragment */
 			if (i == 0) {
 				rtllib_put_snap(
-					skb_put(skb_frag, SNAP_SIZE + sizeof(u16)),
-					ether_type);
+					skb_put(skb_frag, SNAP_SIZE +
+					sizeof(u16)), ether_type);
 				bytes -= SNAP_SIZE + sizeof(u16);
 			}
 
@@ -828,27 +832,29 @@ int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 			/* Advance the SKB... */
 			skb_pull(skb, bytes);
 
-			/* Encryption routine will move the header forward in order
-			* to insert the IV between the header and the payload */
+			/* Encryption routine will move the header forward in
+			 * order to insert the IV between the header and the
+			 * payload */
 			if (encrypt)
-				rtllib_encrypt_fragment(ieee, skb_frag, hdr_len);
+				rtllib_encrypt_fragment(ieee, skb_frag,
+							hdr_len);
 			if (ieee->config &
-			(CFG_RTLLIB_COMPUTE_FCS | CFG_RTLLIB_RESERVE_FCS))
+			   (CFG_RTLLIB_COMPUTE_FCS | CFG_RTLLIB_RESERVE_FCS))
 				skb_put(skb_frag, 4);
 		}
 
 		if ((qos_actived) && (!bIsMulticast)) {
-		  if (ieee->seq_ctrl[UP2AC(skb->priority) + 1] == 0xFFF)
-			ieee->seq_ctrl[UP2AC(skb->priority) + 1] = 0;
-		  else
-			ieee->seq_ctrl[UP2AC(skb->priority) + 1]++;
+			if (ieee->seq_ctrl[UP2AC(skb->priority) + 1] == 0xFFF)
+				ieee->seq_ctrl[UP2AC(skb->priority) + 1] = 0;
+			else
+				ieee->seq_ctrl[UP2AC(skb->priority) + 1]++;
 		} else {
-		  if (ieee->seq_ctrl[0] == 0xFFF)
-			ieee->seq_ctrl[0] = 0;
-		  else
-			ieee->seq_ctrl[0]++;
+			if (ieee->seq_ctrl[0] == 0xFFF)
+				ieee->seq_ctrl[0] = 0;
+			else
+					ieee->seq_ctrl[0]++;
 		}
-	}else{
+	} else {
 		if (unlikely(skb->len < sizeof(struct rtllib_hdr_3addr))) {
 			printk(KERN_WARNING "%s: skb too small (%d).\n",
 			ieee->dev->name, skb->len);
@@ -856,7 +862,7 @@ int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 		}
 
 		txb = rtllib_alloc_txb(1, skb->len, GFP_ATOMIC);
-		if (!txb){
+		if (!txb) {
 			printk(KERN_WARNING "%s: Could not allocate TXB\n",
 			ieee->dev->name);
 			goto failed;
@@ -864,22 +870,24 @@ int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 
 		txb->encrypted = 0;
 		txb->payload_size = skb->len;
-		memcpy(skb_put(txb->fragments[0],skb->len), skb->data, skb->len);
+		memcpy(skb_put(txb->fragments[0], skb->len), skb->data,
+		       skb->len);
 	}
 
  success:
-	if (txb)
-	{
-		struct cb_desc *tcb_desc = (struct cb_desc *)(txb->fragments[0]->cb + MAX_DEV_ADDR_SIZE);
+	if (txb) {
+		struct cb_desc *tcb_desc = (struct cb_desc *)
+				(txb->fragments[0]->cb + MAX_DEV_ADDR_SIZE);
 		tcb_desc->bTxEnableFwCalcDur = 1;
 		tcb_desc->priority = skb->priority;
 
 		if (ether_type == ETH_P_PAE) {
-			if (ieee->pHTInfo->IOTAction & HT_IOT_ACT_WA_IOT_Broadcom)
-			{
-				tcb_desc->data_rate = MgntQuery_TxRateExcludeCCKRates(ieee);
+			if (ieee->pHTInfo->IOTAction &
+			    HT_IOT_ACT_WA_IOT_Broadcom) {
+				tcb_desc->data_rate =
+					 MgntQuery_TxRateExcludeCCKRates(ieee);
 				tcb_desc->bTxDisableRateFallBack = false;
-			}else{
+			} else {
 				tcb_desc->data_rate = ieee->basic_rate;
 				tcb_desc->bTxDisableRateFallBack = 1;
 			}
@@ -893,17 +901,19 @@ int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 			if (is_broadcast_ether_addr(header.addr1))
 				tcb_desc->bBroadcast = 1;
 			rtllib_txrate_selectmode(ieee, tcb_desc);
-			if ( tcb_desc->bMulticast ||  tcb_desc->bBroadcast)
+			if (tcb_desc->bMulticast ||  tcb_desc->bBroadcast)
 				tcb_desc->data_rate = ieee->basic_rate;
 			else
-				tcb_desc->data_rate = CURRENT_RATE(ieee->mode, ieee->rate, ieee->HTCurrentOperaRate);
-
-			if (bdhcp == true){
-				if (ieee->pHTInfo->IOTAction & HT_IOT_ACT_WA_IOT_Broadcom)
-				{
-					tcb_desc->data_rate = MgntQuery_TxRateExcludeCCKRates(ieee);
+				tcb_desc->data_rate = CURRENT_RATE(ieee->mode,
+					ieee->rate, ieee->HTCurrentOperaRate);
+
+			if (bdhcp == true) {
+				if (ieee->pHTInfo->IOTAction &
+				    HT_IOT_ACT_WA_IOT_Broadcom) {
+					tcb_desc->data_rate =
+					   MgntQuery_TxRateExcludeCCKRates(ieee);
 					tcb_desc->bTxDisableRateFallBack = false;
-				}else{
+				} else {
 					tcb_desc->data_rate = MGN_1M;
 					tcb_desc->bTxDisableRateFallBack = 1;
 				}
@@ -915,20 +925,22 @@ int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 			}
 
 			rtllib_qurey_ShortPreambleMode(ieee, tcb_desc);
-			rtllib_tx_query_agg_cap(ieee, txb->fragments[0], tcb_desc);
+			rtllib_tx_query_agg_cap(ieee, txb->fragments[0],
+						tcb_desc);
 			rtllib_query_HTCapShortGI(ieee, tcb_desc);
 			rtllib_query_BandwidthMode(ieee, tcb_desc);
-			rtllib_query_protectionmode(ieee, tcb_desc, txb->fragments[0]);
+			rtllib_query_protectionmode(ieee, tcb_desc,
+						    txb->fragments[0]);
 		}
 	}
 	spin_unlock_irqrestore(&ieee->lock, flags);
 	dev_kfree_skb_any(skb);
 	if (txb) {
-		if (ieee->softmac_features & IEEE_SOFTMAC_TX_QUEUE){
+		if (ieee->softmac_features & IEEE_SOFTMAC_TX_QUEUE) {
 			dev->stats.tx_packets++;
 			dev->stats.tx_bytes += txb->payload_size;
 			rtllib_softmac_xmit(txb, ieee);
-		}else{
+		} else {
 			if ((*ieee->hard_start_xmit)(txb, dev) == 0) {
 				stats->tx_packets++;
 				stats->tx_bytes += txb->payload_size;

commit 8567829a6cfe13e2a8b366794fffa54e5fd06e9f
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Thu Aug 25 11:48:24 2011 -0500

    staging: rtl8192e: Cleanup checkpatch -f warnings and errors - Part XII
    
    This patch removes all the errors and most of the warnings generated by
    checkpatch -f.
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/rtl8192e/rtllib_tx.c b/drivers/staging/rtl8192e/rtllib_tx.c
index 7ccad8601821..134e69f4ee5b 100644
--- a/drivers/staging/rtl8192e/rtllib_tx.c
+++ b/drivers/staging/rtl8192e/rtllib_tx.c
@@ -286,7 +286,6 @@ rtllib_classify(struct sk_buff *skb, u8 bIsAmsdu)
 	}
 }
 
-#define SN_LESS(a, b)		(((a-b)&0x800)!=0)
 void rtllib_tx_query_agg_cap(struct rtllib_device* ieee, struct sk_buff* skb, struct cb_desc * tcb_desc)
 {
 	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;

commit 55dc4eb35f7c191db2767c887c158a8de0e6e4f7
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Thu Aug 25 11:48:13 2011 -0500

    staging: rtl8192e: Remove extraneous log message
    
    The driver logs all DHCP transactions and thus spams the logs.
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/rtl8192e/rtllib_tx.c b/drivers/staging/rtl8192e/rtllib_tx.c
index d03b5aa02cc9..7ccad8601821 100644
--- a/drivers/staging/rtl8192e/rtllib_tx.c
+++ b/drivers/staging/rtl8192e/rtllib_tx.c
@@ -632,15 +632,13 @@ int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 			goto success;
 		}
 
-		if (skb->len > 282){
+		if (skb->len > 282) {
 			if (ETH_P_IP == ether_type) {
 				const struct iphdr *ip = (struct iphdr *)((u8 *)skb->data+14);
 				if (IPPROTO_UDP == ip->protocol) {
 					struct udphdr *udp = (struct udphdr *)((u8 *)ip + (ip->ihl << 2));
 					if (((((u8 *)udp)[1] == 68) && (((u8 *)udp)[3] == 67)) ||
 					    ((((u8 *)udp)[1] == 67) && (((u8 *)udp)[3] == 68))) {
-						printk("DHCP pkt src port:%d, dest port:%d!!\n", ((u8 *)udp)[1],((u8 *)udp)[3]);
-
 						bdhcp = true;
 						ieee->LPSDelayCnt = 200;
 					}

commit 3b83db43ccbb26863f38caccc1e7fae370f31e57
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Tue Jul 19 00:01:29 2011 -0500

    staging: rtl8192e: Convert typedef cb_desc to struct cb_desc
    
    Remove typedef from struct.
    Rename struct.
    Rename uses.
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>

diff --git a/drivers/staging/rtl8192e/rtllib_tx.c b/drivers/staging/rtl8192e/rtllib_tx.c
index dd89b0bebec7..d03b5aa02cc9 100644
--- a/drivers/staging/rtl8192e/rtllib_tx.c
+++ b/drivers/staging/rtl8192e/rtllib_tx.c
@@ -287,7 +287,7 @@ rtllib_classify(struct sk_buff *skb, u8 bIsAmsdu)
 }
 
 #define SN_LESS(a, b)		(((a-b)&0x800)!=0)
-void rtllib_tx_query_agg_cap(struct rtllib_device* ieee, struct sk_buff* skb, cb_desc* tcb_desc)
+void rtllib_tx_query_agg_cap(struct rtllib_device* ieee, struct sk_buff* skb, struct cb_desc * tcb_desc)
 {
 	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
 	struct tx_ts_record *pTxTs = NULL;
@@ -358,7 +358,7 @@ void rtllib_tx_query_agg_cap(struct rtllib_device* ieee, struct sk_buff* skb, cb
 		return;
 }
 
-extern void rtllib_qurey_ShortPreambleMode(struct rtllib_device* ieee, cb_desc* tcb_desc)
+extern void rtllib_qurey_ShortPreambleMode(struct rtllib_device* ieee, struct cb_desc * tcb_desc)
 {
 	tcb_desc->bUseShortPreamble = false;
 	if (tcb_desc->data_rate == 2)
@@ -373,7 +373,7 @@ extern void rtllib_qurey_ShortPreambleMode(struct rtllib_device* ieee, cb_desc*
 }
 
 extern	void
-rtllib_query_HTCapShortGI(struct rtllib_device *ieee, cb_desc *tcb_desc)
+rtllib_query_HTCapShortGI(struct rtllib_device *ieee, struct cb_desc *tcb_desc)
 {
 	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
 
@@ -394,7 +394,7 @@ rtllib_query_HTCapShortGI(struct rtllib_device *ieee, cb_desc *tcb_desc)
 		tcb_desc->bUseShortGI = true;
 }
 
-void rtllib_query_BandwidthMode(struct rtllib_device* ieee, cb_desc *tcb_desc)
+void rtllib_query_BandwidthMode(struct rtllib_device* ieee, struct cb_desc *tcb_desc)
 {
 	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
 
@@ -413,7 +413,7 @@ void rtllib_query_BandwidthMode(struct rtllib_device* ieee, cb_desc *tcb_desc)
 	return;
 }
 
-void rtllib_query_protectionmode(struct rtllib_device* ieee, cb_desc* tcb_desc, struct sk_buff* skb)
+void rtllib_query_protectionmode(struct rtllib_device* ieee, struct cb_desc * tcb_desc, struct sk_buff* skb)
 {
 	tcb_desc->bRTSSTBC			= false;
 	tcb_desc->bRTSUseShortGI		= false;
@@ -513,7 +513,7 @@ void rtllib_query_protectionmode(struct rtllib_device* ieee, cb_desc* tcb_desc,
 }
 
 
-void rtllib_txrate_selectmode(struct rtllib_device* ieee, cb_desc* tcb_desc)
+void rtllib_txrate_selectmode(struct rtllib_device* ieee, struct cb_desc * tcb_desc)
 {
 	if (ieee->bTxDisableRateFallBack)
 		tcb_desc->bTxDisableRateFallBack = true;
@@ -586,7 +586,7 @@ int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 	u8 dest[ETH_ALEN], src[ETH_ALEN];
 	int qos_actived = ieee->current_network.qos_data.active;
 	struct rtllib_crypt_data* crypt = NULL;
-	cb_desc *tcb_desc;
+	struct cb_desc *tcb_desc;
 	u8 bIsMulticast = false;
 	u8 IsAmsdu = false;
 
@@ -778,7 +778,7 @@ int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 
 		for (i = 0; i < nr_frags; i++) {
 			skb_frag = txb->fragments[i];
-			tcb_desc = (cb_desc *)(skb_frag->cb + MAX_DEV_ADDR_SIZE);
+			tcb_desc = (struct cb_desc *)(skb_frag->cb + MAX_DEV_ADDR_SIZE);
 			if (qos_actived){
 				skb_frag->priority = skb->priority;
 				tcb_desc->queue_index =  UP2AC(skb->priority);
@@ -873,7 +873,7 @@ int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
  success:
 	if (txb)
 	{
-		cb_desc *tcb_desc = (cb_desc *)(txb->fragments[0]->cb + MAX_DEV_ADDR_SIZE);
+		struct cb_desc *tcb_desc = (struct cb_desc *)(txb->fragments[0]->cb + MAX_DEV_ADDR_SIZE);
 		tcb_desc->bTxEnableFwCalcDur = 1;
 		tcb_desc->priority = skb->priority;
 

commit 7796d93eae46054d5a3bb5411fde735801998dc5
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Mon Jul 18 20:22:19 2011 -0500

    staging: rtl8192e: Convert typedef RT_HIGH_THROUGHPUT to struct rt_hi_throughput
    
    Remove typedef from struct.
    Rename struct.
    Rename uses.
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>

diff --git a/drivers/staging/rtl8192e/rtllib_tx.c b/drivers/staging/rtl8192e/rtllib_tx.c
index dae5df4c732a..dd89b0bebec7 100644
--- a/drivers/staging/rtl8192e/rtllib_tx.c
+++ b/drivers/staging/rtl8192e/rtllib_tx.c
@@ -289,7 +289,7 @@ rtllib_classify(struct sk_buff *skb, u8 bIsAmsdu)
 #define SN_LESS(a, b)		(((a-b)&0x800)!=0)
 void rtllib_tx_query_agg_cap(struct rtllib_device* ieee, struct sk_buff* skb, cb_desc* tcb_desc)
 {
-	PRT_HIGH_THROUGHPUT	pHTInfo = ieee->pHTInfo;
+	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
 	struct tx_ts_record *pTxTs = NULL;
 	struct rtllib_hdr_1addr* hdr = (struct rtllib_hdr_1addr*)skb->data;
 
@@ -375,7 +375,7 @@ extern void rtllib_qurey_ShortPreambleMode(struct rtllib_device* ieee, cb_desc*
 extern	void
 rtllib_query_HTCapShortGI(struct rtllib_device *ieee, cb_desc *tcb_desc)
 {
-	PRT_HIGH_THROUGHPUT		pHTInfo = ieee->pHTInfo;
+	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
 
 	tcb_desc->bUseShortGI		= false;
 
@@ -396,7 +396,7 @@ rtllib_query_HTCapShortGI(struct rtllib_device *ieee, cb_desc *tcb_desc)
 
 void rtllib_query_BandwidthMode(struct rtllib_device* ieee, cb_desc *tcb_desc)
 {
-	PRT_HIGH_THROUGHPUT	pHTInfo = ieee->pHTInfo;
+	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
 
 	tcb_desc->bPacketBW = false;
 
@@ -444,7 +444,7 @@ void rtllib_query_protectionmode(struct rtllib_device* ieee, cb_desc* tcb_desc,
 	}
 	else
 	{
-		PRT_HIGH_THROUGHPUT pHTInfo = ieee->pHTInfo;
+		struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
 		while (true)
 		{
 			if (pHTInfo->IOTAction & HT_IOT_ACT_FORCED_CTS2SELF)

commit 74724de1c40192d74a213e615b945df8de935ca2
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Mon Jul 18 20:19:19 2011 -0500

    staging: rtl8192e: Convert typedef TS_COMMON_INFO to struct ts_common_info
    
    Remove typedef from struct.
    Rename struct.
    Rename uses.
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>

diff --git a/drivers/staging/rtl8192e/rtllib_tx.c b/drivers/staging/rtl8192e/rtllib_tx.c
index 09032594cfae..dae5df4c732a 100644
--- a/drivers/staging/rtl8192e/rtllib_tx.c
+++ b/drivers/staging/rtl8192e/rtllib_tx.c
@@ -312,7 +312,7 @@ void rtllib_tx_query_agg_cap(struct rtllib_device* ieee, struct sk_buff* skb, cb
 	if (!ieee->GetNmodeSupportBySecCfg(ieee->dev))
 		return;
 	if (pHTInfo->bCurrentAMPDUEnable){
-		if (!GetTs(ieee, (PTS_COMMON_INFO*)(&pTxTs), hdr->addr1, skb->priority, TX_DIR, true)){
+		if (!GetTs(ieee, (struct ts_common_info **)(&pTxTs), hdr->addr1, skb->priority, TX_DIR, true)){
 			printk("%s: can't get TS\n", __func__);
 			return;
 		}
@@ -536,7 +536,7 @@ u16 rtllib_query_seqnum(struct rtllib_device*ieee, struct sk_buff* skb, u8* dst)
 	if (IsQoSDataFrame(skb->data))
 	{
 		struct tx_ts_record *pTS = NULL;
-		if (!GetTs(ieee, (PTS_COMMON_INFO*)(&pTS), dst, skb->priority, TX_DIR, true))
+		if (!GetTs(ieee, (struct ts_common_info **)(&pTS), dst, skb->priority, TX_DIR, true))
 		{
 			return 0;
 		}

commit 60554f2bdb1579ca54631e99642025797f860eb7
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Mon Jul 18 20:10:03 2011 -0500

    staging: rtl8192e: Convert typedef TX_TS_RECORD to struct tx_ts_record
    
    Remove typedef from struct.
    Rename struct.
    Rename uses.
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>

diff --git a/drivers/staging/rtl8192e/rtllib_tx.c b/drivers/staging/rtl8192e/rtllib_tx.c
index 0a59720f9cbb..09032594cfae 100644
--- a/drivers/staging/rtl8192e/rtllib_tx.c
+++ b/drivers/staging/rtl8192e/rtllib_tx.c
@@ -290,7 +290,7 @@ rtllib_classify(struct sk_buff *skb, u8 bIsAmsdu)
 void rtllib_tx_query_agg_cap(struct rtllib_device* ieee, struct sk_buff* skb, cb_desc* tcb_desc)
 {
 	PRT_HIGH_THROUGHPUT	pHTInfo = ieee->pHTInfo;
-	PTX_TS_RECORD			pTxTs = NULL;
+	struct tx_ts_record *pTxTs = NULL;
 	struct rtllib_hdr_1addr* hdr = (struct rtllib_hdr_1addr*)skb->data;
 
 	if (rtllib_act_scanning(ieee,false))
@@ -535,7 +535,7 @@ u16 rtllib_query_seqnum(struct rtllib_device*ieee, struct sk_buff* skb, u8* dst)
 		return 0;
 	if (IsQoSDataFrame(skb->data))
 	{
-		PTX_TS_RECORD pTS = NULL;
+		struct tx_ts_record *pTS = NULL;
 		if (!GetTs(ieee, (PTS_COMMON_INFO*)(&pTS), dst, skb->priority, TX_DIR, true))
 		{
 			return 0;

commit 8cc638e95bcef31d5f8896bbe5ca06fd52fa7947
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Thu Jul 14 18:48:38 2011 -0500

    staging: rtl8192e: Remove ifdefs for CONFIG_RTLLIB_DEBUG
    
    This symbol is unconditionally defined in a header file, thus tests for it can be removed.
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>

diff --git a/drivers/staging/rtl8192e/rtllib_tx.c b/drivers/staging/rtl8192e/rtllib_tx.c
index ae9f7727ed3a..0a59720f9cbb 100644
--- a/drivers/staging/rtl8192e/rtllib_tx.c
+++ b/drivers/staging/rtl8192e/rtllib_tx.c
@@ -663,14 +663,12 @@ int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 			stats->tx_dropped++;
 			goto success;
 		}
-	#ifdef CONFIG_RTLLIB_DEBUG
 		if (crypt && !encrypt && ether_type == ETH_P_PAE) {
 			struct eapol *eap = (struct eapol *)(skb->data +
 				sizeof(struct ethhdr) - SNAP_SIZE - sizeof(u16));
 			RTLLIB_DEBUG_EAP("TX: IEEE 802.11 EAPOL frame: %s\n",
 				eap_get_type(eap->type));
 		}
-	#endif
 
 		/* Advance the SKB to the start of the payload */
 		skb_pull(skb, sizeof(struct ethhdr));

commit 69dbddce03e40650fb28fc5954c3ccd59a53d201
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Thu Jul 14 17:18:14 2011 -0500

    staging: rtl8192e: Remove dead code associated with CONFIG_RTLLIB_CRYPT_TKIP
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>

diff --git a/drivers/staging/rtl8192e/rtllib_tx.c b/drivers/staging/rtl8192e/rtllib_tx.c
index 0f724caaf6f8..ae9f7727ed3a 100644
--- a/drivers/staging/rtl8192e/rtllib_tx.c
+++ b/drivers/staging/rtl8192e/rtllib_tx.c
@@ -192,20 +192,6 @@ int rtllib_encrypt_fragment(
 		printk("=========>%s(), crypt is null\n", __func__);
 		return -1;
 	}
-#ifdef CONFIG_RTLLIB_CRYPT_TKIP
-	struct rtllib_hdr_1addr *header;
-
-	if (ieee->tkip_countermeasures &&
-	    crypt && crypt->ops && strcmp(crypt->ops->name, "TKIP") == 0) {
-		header = (struct rtllib_hdr_1addr *) frag->data;
-		if (net_ratelimit()) {
-			printk(KERN_DEBUG "%s: TKIP countermeasures: dropped "
-			       "TX packet to " MAC_FMT "\n",
-			       ieee->dev->name, MAC_ARG(header->addr1));
-		}
-		return -1;
-	}
-#endif
 	/* To encrypt, frame format is:
 	 * IV (4 bytes), clear payload (including SNAP), ICV (4 bytes) */
 

commit 6e2c538f8fbca87276a83eec5ac9212bbbfa13fa
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Wed Jul 13 21:58:46 2011 -0500

    staging: rtl8192e: Remove dead code associated with RTK_DMP_PLATFORM
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>

diff --git a/drivers/staging/rtl8192e/rtllib_tx.c b/drivers/staging/rtl8192e/rtllib_tx.c
index f93530e53afa..0f724caaf6f8 100644
--- a/drivers/staging/rtl8192e/rtllib_tx.c
+++ b/drivers/staging/rtl8192e/rtllib_tx.c
@@ -54,10 +54,6 @@
 
 #include "rtllib.h"
 
-#ifdef RTK_DMP_PLATFORM
-#include <linux/usb_setting.h>
-#endif
-
 /*
 
 

commit a97dc3afc0d1f33fb8fff8e57f3644b3d09bacd0
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Tue Jul 12 22:16:06 2011 -0500

    staging: rtl8192e: Remove dead code associated with USB_USE_ALIGNMENT
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>

diff --git a/drivers/staging/rtl8192e/rtllib_tx.c b/drivers/staging/rtl8192e/rtllib_tx.c
index 3aa6756f07af..f93530e53afa 100644
--- a/drivers/staging/rtl8192e/rtllib_tx.c
+++ b/drivers/staging/rtl8192e/rtllib_tx.c
@@ -243,10 +243,6 @@ void rtllib_txb_free(struct rtllib_txb *txb) {
 struct rtllib_txb *rtllib_alloc_txb(int nr_frags, int txb_size,
 					  int gfp_mask)
 {
-#ifdef USB_USE_ALIGNMENT
-	u32 Tmpaddr=0;
-	int alignment=0;
-#endif
 	struct rtllib_txb *txb;
 	int i;
 	txb = kmalloc(
@@ -260,20 +256,11 @@ struct rtllib_txb *rtllib_alloc_txb(int nr_frags, int txb_size,
 	txb->frag_size = txb_size;
 
 	for (i = 0; i < nr_frags; i++) {
-#ifdef USB_USE_ALIGNMENT
-		txb->fragments[i] = dev_alloc_skb(txb_size+USB_512B_ALIGNMENT_SIZE);
-#else
 		txb->fragments[i] = dev_alloc_skb(txb_size);
-#endif
 		if (unlikely(!txb->fragments[i])) {
 			i--;
 			break;
 		}
-#ifdef USB_USE_ALIGNMENT
-		Tmpaddr = (u32)(txb->fragments[i]->data);
-		alignment = Tmpaddr & 0x1ff;
-		skb_reserve(txb->fragments[i],(USB_512B_ALIGNMENT_SIZE - alignment));
-#endif
 		memset(txb->fragments[i]->cb, 0, sizeof(txb->fragments[i]->cb));
 	}
 	if (unlikely(i != nr_frags)) {

commit 15e7650e880b410d0a4c80aa586b5b2f96be3a61
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Tue Jul 12 22:04:11 2011 -0500

    staging: rtl8192e: Remove dead code involved with TO_DO_LIST
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>

diff --git a/drivers/staging/rtl8192e/rtllib_tx.c b/drivers/staging/rtl8192e/rtllib_tx.c
index 7662bf5bf3e7..3aa6756f07af 100644
--- a/drivers/staging/rtl8192e/rtllib_tx.c
+++ b/drivers/staging/rtl8192e/rtllib_tx.c
@@ -333,12 +333,6 @@ void rtllib_tx_query_agg_cap(struct rtllib_device* ieee, struct sk_buff* skb, cb
 		return;
 	if (is_multicast_ether_addr(hdr->addr1) || is_broadcast_ether_addr(hdr->addr1))
 		return;
-#ifdef TO_DO_LIST
-	if (pTcb->PacketLength >= 4096)
-		return;
-	if (!Adapter->HalFunc.GetNmodeSupportBySecCfgHandler(Adapter))
-		return;
-#endif
 
 	if (tcb_desc->bdhcp || ieee->CntAfterLink<2)
 		return;
@@ -552,22 +546,6 @@ void rtllib_query_protectionmode(struct rtllib_device* ieee, cb_desc* tcb_desc,
 
 void rtllib_txrate_selectmode(struct rtllib_device* ieee, cb_desc* tcb_desc)
 {
-#ifdef TO_DO_LIST
-	if (!IsDataFrame(pFrame))
-	{
-		pTcb->bTxDisableRateFallBack = true;
-		pTcb->bTxUseDriverAssingedRate = true;
-		pTcb->RATRIndex = 7;
-		return;
-	}
-
-	if (pMgntInfo->ForcedDataRate!= 0)
-	{
-		pTcb->bTxDisableRateFallBack = true;
-		pTcb->bTxUseDriverAssingedRate = true;
-		return;
-	}
-#endif
 	if (ieee->bTxDisableRateFallBack)
 		tcb_desc->bTxDisableRateFallBack = true;
 

commit 1e71e6d0cf764841cdf60dec4a40849ff41be75c
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Mon Jul 11 22:25:07 2011 -0500

    staging: rtl8192e: Remove dead code associated with RTL8192SE
    
    The vendor code will generate several different drivers. As the RTL8192SE
    is covered by a mac80211 driver in mainline, eliminate that code heere.
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>

diff --git a/drivers/staging/rtl8192e/rtllib_tx.c b/drivers/staging/rtl8192e/rtllib_tx.c
index 78b1707b12ae..7662bf5bf3e7 100644
--- a/drivers/staging/rtl8192e/rtllib_tx.c
+++ b/drivers/staging/rtl8192e/rtllib_tx.c
@@ -449,53 +449,7 @@ void rtllib_query_BandwidthMode(struct rtllib_device* ieee, cb_desc *tcb_desc)
 		tcb_desc->bPacketBW = true;
 	return;
 }
-#if defined(RTL8192U) || defined(RTL8192SU) || defined(RTL8192SE)
-extern void rtllib_ibss_query_HTCapShortGI(struct rtllib_device *ieee, cb_desc *tcb_desc,u8 is_peer_shortGI_40M,u8 is_peer_shortGI_20M)
-{
-	PRT_HIGH_THROUGHPUT		pHTInfo = ieee->pHTInfo;
-
-	tcb_desc->bUseShortGI		= false;
-
-	if (!pHTInfo->bCurrentHTSupport||!pHTInfo->bEnableHT || (ieee->iw_mode != IW_MODE_ADHOC))
-	{
-		return;
-	}
 
-	if (pHTInfo->bForcedShortGI)
-	{
-		tcb_desc->bUseShortGI = true;
-		return;
-	}
-	if ((pHTInfo->bCurBW40MHz==true) && is_peer_shortGI_40M)
-		tcb_desc->bUseShortGI = true;
-	else if ((pHTInfo->bCurBW40MHz==false) && is_peer_shortGI_20M)
-		tcb_desc->bUseShortGI = true;
-}
-void rtllib_ibss_query_BandwidthMode(struct rtllib_device* ieee, cb_desc *tcb_desc, u8 is_peer_40M)
-{
-	PRT_HIGH_THROUGHPUT	pHTInfo = ieee->pHTInfo;
-
-	tcb_desc->bPacketBW = false;
-
-	if (!pHTInfo->bCurrentHTSupport||!pHTInfo->bEnableHT || (ieee->iw_mode != IW_MODE_ADHOC))
-	{
-		return;
-	}
-
-	if (tcb_desc->bMulticast || tcb_desc->bBroadcast)
-	{
-		return;
-	}
-
-	if ((tcb_desc->data_rate & 0x80)==0)
-	{
-		return;
-	}
-	if (pHTInfo->bCurBW40MHz && is_peer_40M && !ieee->bandwidth_auto_switch.bforced_tx20Mhz)
-		tcb_desc->bPacketBW = true;
-	return;
-}
-#endif
 void rtllib_query_protectionmode(struct rtllib_device* ieee, cb_desc* tcb_desc, struct sk_buff* skb)
 {
 	tcb_desc->bRTSSTBC			= false;
@@ -596,11 +550,7 @@ void rtllib_query_protectionmode(struct rtllib_device* ieee, cb_desc* tcb_desc,
 }
 
 
-#if defined(RTL8192U) || defined(RTL8192SU) || defined(RTL8192SE)
-void rtllib_txrate_selectmode(struct rtllib_device* ieee, cb_desc* tcb_desc,struct sta_info *psta)
-#else
 void rtllib_txrate_selectmode(struct rtllib_device* ieee, cb_desc* tcb_desc)
-#endif
 {
 #ifdef TO_DO_LIST
 	if (!IsDataFrame(pFrame))
@@ -1000,62 +950,6 @@ int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 				tcb_desc->bMulticast = 1;
 			if (is_broadcast_ether_addr(header.addr1))
 				tcb_desc->bBroadcast = 1;
-#if defined(RTL8192U) || defined(RTL8192SU) || defined(RTL8192SE)
-			if ( tcb_desc->bMulticast ||  tcb_desc->bBroadcast){
-				rtllib_txrate_selectmode(ieee, tcb_desc, p_sta);
-				tcb_desc->data_rate = ieee->basic_rate;
-			}
-			else
-			{
-				if (ieee->iw_mode == IW_MODE_ADHOC)
-				{
-					u8 is_peer_shortGI_40M = 0;
-					u8 is_peer_shortGI_20M = 0;
-					u8 is_peer_BW_40M = 0;
-					p_sta = GetStaInfo(ieee, header.addr1);
-					if (NULL == p_sta)
-					{
-						rtllib_txrate_selectmode(ieee, tcb_desc, p_sta);
-						tcb_desc->data_rate = ieee->rate;
-					}
-					else
-					{
-						rtllib_txrate_selectmode(ieee, tcb_desc, p_sta);
-						tcb_desc->data_rate = CURRENT_RATE(p_sta->wireless_mode, p_sta->CurDataRate, p_sta->htinfo.HTHighestOperaRate);
-						is_peer_shortGI_40M = p_sta->htinfo.bCurShortGI40MHz;
-						is_peer_shortGI_20M = p_sta->htinfo.bCurShortGI20MHz;
-						is_peer_BW_40M = p_sta->htinfo.bCurTxBW40MHz;
-					}
-					rtllib_qurey_ShortPreambleMode(ieee, tcb_desc);
-					rtllib_tx_query_agg_cap(ieee, txb->fragments[0], tcb_desc);
-					rtllib_ibss_query_HTCapShortGI(ieee, tcb_desc,is_peer_shortGI_40M,is_peer_shortGI_20M);
-					rtllib_ibss_query_BandwidthMode(ieee, tcb_desc,is_peer_BW_40M);
-					rtllib_query_protectionmode(ieee, tcb_desc, txb->fragments[0]);
-				}
-				else {
-					rtllib_txrate_selectmode(ieee, tcb_desc, p_sta);
-					tcb_desc->data_rate = CURRENT_RATE(ieee->mode, ieee->rate, ieee->HTCurrentOperaRate);
-					if (bdhcp == true){
-						if (ieee->pHTInfo->IOTAction & HT_IOT_ACT_WA_IOT_Broadcom) {
-							tcb_desc->data_rate = MGN_1M;
-							tcb_desc->bTxDisableRateFallBack = false;
-						}else{
-							tcb_desc->data_rate = MGN_1M;
-							tcb_desc->bTxDisableRateFallBack = 1;
-						}
-
-						tcb_desc->RATRIndex = 7;
-						tcb_desc->bTxUseDriverAssingedRate = 1;
-						tcb_desc->bdhcp = 1;
-					}
-					rtllib_qurey_ShortPreambleMode(ieee, tcb_desc);
-					rtllib_tx_query_agg_cap(ieee, txb->fragments[0], tcb_desc);
-					rtllib_query_HTCapShortGI(ieee, tcb_desc);
-					rtllib_query_BandwidthMode(ieee, tcb_desc);
-					rtllib_query_protectionmode(ieee, tcb_desc, txb->fragments[0]);
-				}
-			}
-#else
 			rtllib_txrate_selectmode(ieee, tcb_desc);
 			if ( tcb_desc->bMulticast ||  tcb_desc->bBroadcast)
 				tcb_desc->data_rate = ieee->basic_rate;
@@ -1083,7 +977,6 @@ int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 			rtllib_query_HTCapShortGI(ieee, tcb_desc);
 			rtllib_query_BandwidthMode(ieee, tcb_desc);
 			rtllib_query_protectionmode(ieee, tcb_desc, txb->fragments[0]);
-#endif
 		}
 	}
 	spin_unlock_irqrestore(&ieee->lock, flags);

commit 4f6807e8d2e972393009830d305ecec2d80c0449
Author: Mike McCormack <mikem@ring3k.org>
Date:   Mon Jul 11 08:56:20 2011 +0900

    rtl8192e: Remove occurences of #if 1
    
    Signed-off-by: Mike McCormack <mikem@ring3k.org>

diff --git a/drivers/staging/rtl8192e/rtllib_tx.c b/drivers/staging/rtl8192e/rtllib_tx.c
index 3cc066eb530e..78b1707b12ae 100644
--- a/drivers/staging/rtl8192e/rtllib_tx.c
+++ b/drivers/staging/rtl8192e/rtllib_tx.c
@@ -978,7 +978,6 @@ int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
  success:
 	if (txb)
 	{
-#if 1
 		cb_desc *tcb_desc = (cb_desc *)(txb->fragments[0]->cb + MAX_DEV_ADDR_SIZE);
 		tcb_desc->bTxEnableFwCalcDur = 1;
 		tcb_desc->priority = skb->priority;
@@ -1086,7 +1085,6 @@ int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
 			rtllib_query_protectionmode(ieee, tcb_desc, txb->fragments[0]);
 #endif
 		}
-#endif
 	}
 	spin_unlock_irqrestore(&ieee->lock, flags);
 	dev_kfree_skb_any(skb);

commit 94a799425eee8225a1e3fbe5f473d2ef04002577
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Tue Aug 23 19:00:42 2011 -0500

    From: wlanfae <wlanfae@realtek.com>
    [PATCH 1/8] rtl8192e: Import new version of driver from realtek
    
    Signed-off-by: wlanfae <wlanfae@realtek.com>
    Signed-off-by: Mike McCormack <mikem@ring3k.org>
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
    ---

diff --git a/drivers/staging/rtl8192e/rtllib_tx.c b/drivers/staging/rtl8192e/rtllib_tx.c
new file mode 100644
index 000000000000..3cc066eb530e
--- /dev/null
+++ b/drivers/staging/rtl8192e/rtllib_tx.c
@@ -0,0 +1,1121 @@
+/******************************************************************************
+
+  Copyright(c) 2003 - 2004 Intel Corporation. All rights reserved.
+
+  This program is free software; you can redistribute it and/or modify it
+  under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but WITHOUT
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+  more details.
+
+  You should have received a copy of the GNU General Public License along with
+  this program; if not, write to the Free Software Foundation, Inc., 59
+  Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+  The full GNU General Public License is included in this distribution in the
+  file called LICENSE.
+
+  Contact Information:
+  James P. Ketrenos <ipw2100-admin@linux.intel.com>
+  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
+
+******************************************************************************
+
+  Few modifications for Realtek's Wi-Fi drivers by
+  Andrea Merello <andreamrl@tiscali.it>
+
+  A special thanks goes to Realtek for their support !
+
+******************************************************************************/
+
+#include <linux/compiler.h>
+#include <linux/errno.h>
+#include <linux/if_arp.h>
+#include <linux/in6.h>
+#include <linux/in.h>
+#include <linux/ip.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/netdevice.h>
+#include <linux/pci.h>
+#include <linux/proc_fs.h>
+#include <linux/skbuff.h>
+#include <linux/slab.h>
+#include <linux/tcp.h>
+#include <linux/types.h>
+#include <linux/version.h>
+#include <linux/wireless.h>
+#include <linux/etherdevice.h>
+#include <asm/uaccess.h>
+#include <linux/if_vlan.h>
+
+#include "rtllib.h"
+
+#ifdef RTK_DMP_PLATFORM
+#include <linux/usb_setting.h>
+#endif
+
+/*
+
+
+802.11 Data Frame
+
+
+802.11 frame_contorl for data frames - 2 bytes
+     ,-----------------------------------------------------------------------------------------.
+bits | 0  |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  8  |  9  |  a  |  b  |  c  |  d  |  e   |
+     |----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|------|
+val  | 0  |  0  |  0  |  1  |  x  |  0  |  0  |  0  |  1  |  0  |  x  |  x  |  x  |  x  |  x   |
+     |----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|------|
+desc | ^-ver-^  |  ^type-^  |  ^-----subtype-----^  | to  |from |more |retry| pwr |more |wep   |
+     |          |           | x=0 data,x=1 data+ack | DS  | DS  |frag |     | mgm |data |      |
+     '-----------------------------------------------------------------------------------------'
+		                                    /\
+                                                    |
+802.11 Data Frame                                   |
+           ,--------- 'ctrl' expands to >-----------'
+          |
+      ,--'---,-------------------------------------------------------------.
+Bytes |  2   |  2   |    6    |    6    |    6    |  2   | 0..2312 |   4  |
+      |------|------|---------|---------|---------|------|---------|------|
+Desc. | ctrl | dura |  DA/RA  |   TA    |    SA   | Sequ |  Frame  |  fcs |
+      |      | tion | (BSSID) |         |         | ence |  data   |      |
+      `--------------------------------------------------|         |------'
+Total: 28 non-data bytes                                 `----.----'
+                                                              |
+       .- 'Frame data' expands to <---------------------------'
+       |
+       V
+      ,---------------------------------------------------.
+Bytes |  1   |  1   |    1    |    3     |  2   |  0-2304 |
+      |------|------|---------|----------|------|---------|
+Desc. | SNAP | SNAP | Control |Eth Tunnel| Type | IP      |
+      | DSAP | SSAP |         |          |      | Packet  |
+      | 0xAA | 0xAA |0x03 (UI)|0x00-00-F8|      |         |
+      `-----------------------------------------|         |
+Total: 8 non-data bytes                         `----.----'
+                                                     |
+       .- 'IP Packet' expands, if WEP enabled, to <--'
+       |
+       V
+      ,-----------------------.
+Bytes |  4  |   0-2296  |  4  |
+      |-----|-----------|-----|
+Desc. | IV  | Encrypted | ICV |
+      |     | IP Packet |     |
+      `-----------------------'
+Total: 8 non-data bytes
+
+
+802.3 Ethernet Data Frame
+
+      ,-----------------------------------------.
+Bytes |   6   |   6   |  2   |  Variable |   4  |
+      |-------|-------|------|-----------|------|
+Desc. | Dest. | Source| Type | IP Packet |  fcs |
+      |  MAC  |  MAC  |      |           |      |
+      `-----------------------------------------'
+Total: 18 non-data bytes
+
+In the event that fragmentation is required, the incoming payload is split into
+N parts of size ieee->fts.  The first fragment contains the SNAP header and the
+remaining packets are just data.
+
+If encryption is enabled, each fragment payload size is reduced by enough space
+to add the prefix and postfix (IV and ICV totalling 8 bytes in the case of WEP)
+So if you have 1500 bytes of payload with ieee->fts set to 500 without
+encryption it will take 3 frames.  With WEP it will take 4 frames as the
+payload of each frame is reduced to 492 bytes.
+
+* SKB visualization
+*
+*  ,- skb->data
+* |
+* |    ETHERNET HEADER        ,-<-- PAYLOAD
+* |                           |     14 bytes from skb->data
+* |  2 bytes for Type --> ,T. |     (sizeof ethhdr)
+* |                       | | |
+* |,-Dest.--. ,--Src.---. | | |
+* |  6 bytes| | 6 bytes | | | |
+* v         | |         | | | |
+* 0         | v       1 | v | v           2
+* 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
+*     ^     | ^         | ^ |
+*     |     | |         | | |
+*     |     | |         | `T' <---- 2 bytes for Type
+*     |     | |         |
+*     |     | '---SNAP--' <-------- 6 bytes for SNAP
+*     |     |
+*     `-IV--' <-------------------- 4 bytes for IV (WEP)
+*
+*      SNAP HEADER
+*
+*/
+
+static u8 P802_1H_OUI[P80211_OUI_LEN] = { 0x00, 0x00, 0xf8 };
+static u8 RFC1042_OUI[P80211_OUI_LEN] = { 0x00, 0x00, 0x00 };
+
+inline int rtllib_put_snap(u8 *data, u16 h_proto)
+{
+	struct rtllib_snap_hdr *snap;
+	u8 *oui;
+
+	snap = (struct rtllib_snap_hdr *)data;
+	snap->dsap = 0xaa;
+	snap->ssap = 0xaa;
+	snap->ctrl = 0x03;
+
+	if (h_proto == 0x8137 || h_proto == 0x80f3)
+		oui = P802_1H_OUI;
+	else
+		oui = RFC1042_OUI;
+	snap->oui[0] = oui[0];
+	snap->oui[1] = oui[1];
+	snap->oui[2] = oui[2];
+
+	*(u16 *)(data + SNAP_SIZE) = htons(h_proto);
+
+	return SNAP_SIZE + sizeof(u16);
+}
+
+int rtllib_encrypt_fragment(
+	struct rtllib_device *ieee,
+	struct sk_buff *frag,
+	int hdr_len)
+{
+	struct rtllib_crypt_data* crypt = NULL;
+	int res;
+
+	crypt = ieee->crypt[ieee->tx_keyidx];
+
+	if (!(crypt && crypt->ops))
+	{
+		printk("=========>%s(), crypt is null\n", __func__);
+		return -1;
+	}
+#ifdef CONFIG_RTLLIB_CRYPT_TKIP
+	struct rtllib_hdr_1addr *header;
+
+	if (ieee->tkip_countermeasures &&
+	    crypt && crypt->ops && strcmp(crypt->ops->name, "TKIP") == 0) {
+		header = (struct rtllib_hdr_1addr *) frag->data;
+		if (net_ratelimit()) {
+			printk(KERN_DEBUG "%s: TKIP countermeasures: dropped "
+			       "TX packet to " MAC_FMT "\n",
+			       ieee->dev->name, MAC_ARG(header->addr1));
+		}
+		return -1;
+	}
+#endif
+	/* To encrypt, frame format is:
+	 * IV (4 bytes), clear payload (including SNAP), ICV (4 bytes) */
+
+	/* Host-based IEEE 802.11 fragmentation for TX is not yet supported, so
+	 * call both MSDU and MPDU encryption functions from here. */
+	atomic_inc(&crypt->refcnt);
+	res = 0;
+	if (crypt->ops->encrypt_msdu)
+		res = crypt->ops->encrypt_msdu(frag, hdr_len, crypt->priv);
+	if (res == 0 && crypt->ops->encrypt_mpdu)
+		res = crypt->ops->encrypt_mpdu(frag, hdr_len, crypt->priv);
+
+	atomic_dec(&crypt->refcnt);
+	if (res < 0) {
+		printk(KERN_INFO "%s: Encryption failed: len=%d.\n",
+		       ieee->dev->name, frag->len);
+		ieee->ieee_stats.tx_discards++;
+		return -1;
+	}
+
+	return 0;
+}
+
+
+void rtllib_txb_free(struct rtllib_txb *txb) {
+	if (unlikely(!txb))
+		return;
+	kfree(txb);
+}
+
+struct rtllib_txb *rtllib_alloc_txb(int nr_frags, int txb_size,
+					  int gfp_mask)
+{
+#ifdef USB_USE_ALIGNMENT
+	u32 Tmpaddr=0;
+	int alignment=0;
+#endif
+	struct rtllib_txb *txb;
+	int i;
+	txb = kmalloc(
+		sizeof(struct rtllib_txb) + (sizeof(u8*) * nr_frags),
+		gfp_mask);
+	if (!txb)
+		return NULL;
+
+	memset(txb, 0, sizeof(struct rtllib_txb));
+	txb->nr_frags = nr_frags;
+	txb->frag_size = txb_size;
+
+	for (i = 0; i < nr_frags; i++) {
+#ifdef USB_USE_ALIGNMENT
+		txb->fragments[i] = dev_alloc_skb(txb_size+USB_512B_ALIGNMENT_SIZE);
+#else
+		txb->fragments[i] = dev_alloc_skb(txb_size);
+#endif
+		if (unlikely(!txb->fragments[i])) {
+			i--;
+			break;
+		}
+#ifdef USB_USE_ALIGNMENT
+		Tmpaddr = (u32)(txb->fragments[i]->data);
+		alignment = Tmpaddr & 0x1ff;
+		skb_reserve(txb->fragments[i],(USB_512B_ALIGNMENT_SIZE - alignment));
+#endif
+		memset(txb->fragments[i]->cb, 0, sizeof(txb->fragments[i]->cb));
+	}
+	if (unlikely(i != nr_frags)) {
+		while (i >= 0)
+			dev_kfree_skb_any(txb->fragments[i--]);
+		kfree(txb);
+		return NULL;
+	}
+	return txb;
+}
+
+int
+rtllib_classify(struct sk_buff *skb, u8 bIsAmsdu)
+{
+	struct ethhdr *eth;
+	struct iphdr *ip;
+
+	eth = (struct ethhdr *)skb->data;
+	if (eth->h_proto != htons(ETH_P_IP))
+		return 0;
+
+	RTLLIB_DEBUG_DATA(RTLLIB_DL_DATA, skb->data, skb->len);
+	ip = ip_hdr(skb);
+	switch (ip->tos & 0xfc) {
+	case 0x20:
+		return 2;
+	case 0x40:
+		return 1;
+	case 0x60:
+		return 3;
+	case 0x80:
+		return 4;
+	case 0xa0:
+		return 5;
+	case 0xc0:
+		return 6;
+	case 0xe0:
+		return 7;
+	default:
+		return 0;
+	}
+}
+
+#define SN_LESS(a, b)		(((a-b)&0x800)!=0)
+void rtllib_tx_query_agg_cap(struct rtllib_device* ieee, struct sk_buff* skb, cb_desc* tcb_desc)
+{
+	PRT_HIGH_THROUGHPUT	pHTInfo = ieee->pHTInfo;
+	PTX_TS_RECORD			pTxTs = NULL;
+	struct rtllib_hdr_1addr* hdr = (struct rtllib_hdr_1addr*)skb->data;
+
+	if (rtllib_act_scanning(ieee,false))
+		return;
+
+	if (!pHTInfo->bCurrentHTSupport||!pHTInfo->bEnableHT)
+		return;
+	if (!IsQoSDataFrame(skb->data))
+		return;
+	if (is_multicast_ether_addr(hdr->addr1) || is_broadcast_ether_addr(hdr->addr1))
+		return;
+#ifdef TO_DO_LIST
+	if (pTcb->PacketLength >= 4096)
+		return;
+	if (!Adapter->HalFunc.GetNmodeSupportBySecCfgHandler(Adapter))
+		return;
+#endif
+
+	if (tcb_desc->bdhcp || ieee->CntAfterLink<2)
+		return;
+
+	if (pHTInfo->IOTAction & HT_IOT_ACT_TX_NO_AGGREGATION)
+		return;
+
+	if (!ieee->GetNmodeSupportBySecCfg(ieee->dev))
+		return;
+	if (pHTInfo->bCurrentAMPDUEnable){
+		if (!GetTs(ieee, (PTS_COMMON_INFO*)(&pTxTs), hdr->addr1, skb->priority, TX_DIR, true)){
+			printk("%s: can't get TS\n", __func__);
+			return;
+		}
+		if (pTxTs->TxAdmittedBARecord.bValid == false){
+			if (ieee->wpa_ie_len && (ieee->pairwise_key_type == KEY_TYPE_NA)) {
+				;
+			} else if (tcb_desc->bdhcp == 1){
+				;
+			} else if (!pTxTs->bDisable_AddBa){
+				TsStartAddBaProcess(ieee, pTxTs);
+			}
+			goto FORCED_AGG_SETTING;
+		} else if (pTxTs->bUsingBa == false) {
+			if (SN_LESS(pTxTs->TxAdmittedBARecord.BaStartSeqCtrl.field.SeqNum, (pTxTs->TxCurSeq+1)%4096))
+				pTxTs->bUsingBa = true;
+			else
+				goto FORCED_AGG_SETTING;
+		}
+		if (ieee->iw_mode == IW_MODE_INFRA) {
+			tcb_desc->bAMPDUEnable = true;
+			tcb_desc->ampdu_factor = pHTInfo->CurrentAMPDUFactor;
+			tcb_desc->ampdu_density = pHTInfo->CurrentMPDUDensity;
+		}
+	}
+FORCED_AGG_SETTING:
+	switch (pHTInfo->ForcedAMPDUMode) {
+		case HT_AGG_AUTO:
+			break;
+
+		case HT_AGG_FORCE_ENABLE:
+			tcb_desc->bAMPDUEnable = true;
+			tcb_desc->ampdu_density = pHTInfo->ForcedMPDUDensity;
+			tcb_desc->ampdu_factor = pHTInfo->ForcedAMPDUFactor;
+			break;
+
+		case HT_AGG_FORCE_DISABLE:
+			tcb_desc->bAMPDUEnable = false;
+			tcb_desc->ampdu_density = 0;
+			tcb_desc->ampdu_factor = 0;
+			break;
+
+	}
+		return;
+}
+
+extern void rtllib_qurey_ShortPreambleMode(struct rtllib_device* ieee, cb_desc* tcb_desc)
+{
+	tcb_desc->bUseShortPreamble = false;
+	if (tcb_desc->data_rate == 2)
+	{
+		return;
+	}
+	else if (ieee->current_network.capability & WLAN_CAPABILITY_SHORT_PREAMBLE)
+	{
+		tcb_desc->bUseShortPreamble = true;
+	}
+	return;
+}
+
+extern	void
+rtllib_query_HTCapShortGI(struct rtllib_device *ieee, cb_desc *tcb_desc)
+{
+	PRT_HIGH_THROUGHPUT		pHTInfo = ieee->pHTInfo;
+
+	tcb_desc->bUseShortGI		= false;
+
+	if (!pHTInfo->bCurrentHTSupport||!pHTInfo->bEnableHT)
+		return;
+
+	if (pHTInfo->bForcedShortGI)
+	{
+		tcb_desc->bUseShortGI = true;
+		return;
+	}
+
+	if ((pHTInfo->bCurBW40MHz==true) && pHTInfo->bCurShortGI40MHz)
+		tcb_desc->bUseShortGI = true;
+	else if ((pHTInfo->bCurBW40MHz==false) && pHTInfo->bCurShortGI20MHz)
+		tcb_desc->bUseShortGI = true;
+}
+
+void rtllib_query_BandwidthMode(struct rtllib_device* ieee, cb_desc *tcb_desc)
+{
+	PRT_HIGH_THROUGHPUT	pHTInfo = ieee->pHTInfo;
+
+	tcb_desc->bPacketBW = false;
+
+	if (!pHTInfo->bCurrentHTSupport||!pHTInfo->bEnableHT)
+		return;
+
+	if (tcb_desc->bMulticast || tcb_desc->bBroadcast)
+		return;
+
+	if ((tcb_desc->data_rate & 0x80)==0)
+		return;
+	if (pHTInfo->bCurBW40MHz && pHTInfo->bCurTxBW40MHz && !ieee->bandwidth_auto_switch.bforced_tx20Mhz)
+		tcb_desc->bPacketBW = true;
+	return;
+}
+#if defined(RTL8192U) || defined(RTL8192SU) || defined(RTL8192SE)
+extern void rtllib_ibss_query_HTCapShortGI(struct rtllib_device *ieee, cb_desc *tcb_desc,u8 is_peer_shortGI_40M,u8 is_peer_shortGI_20M)
+{
+	PRT_HIGH_THROUGHPUT		pHTInfo = ieee->pHTInfo;
+
+	tcb_desc->bUseShortGI		= false;
+
+	if (!pHTInfo->bCurrentHTSupport||!pHTInfo->bEnableHT || (ieee->iw_mode != IW_MODE_ADHOC))
+	{
+		return;
+	}
+
+	if (pHTInfo->bForcedShortGI)
+	{
+		tcb_desc->bUseShortGI = true;
+		return;
+	}
+	if ((pHTInfo->bCurBW40MHz==true) && is_peer_shortGI_40M)
+		tcb_desc->bUseShortGI = true;
+	else if ((pHTInfo->bCurBW40MHz==false) && is_peer_shortGI_20M)
+		tcb_desc->bUseShortGI = true;
+}
+void rtllib_ibss_query_BandwidthMode(struct rtllib_device* ieee, cb_desc *tcb_desc, u8 is_peer_40M)
+{
+	PRT_HIGH_THROUGHPUT	pHTInfo = ieee->pHTInfo;
+
+	tcb_desc->bPacketBW = false;
+
+	if (!pHTInfo->bCurrentHTSupport||!pHTInfo->bEnableHT || (ieee->iw_mode != IW_MODE_ADHOC))
+	{
+		return;
+	}
+
+	if (tcb_desc->bMulticast || tcb_desc->bBroadcast)
+	{
+		return;
+	}
+
+	if ((tcb_desc->data_rate & 0x80)==0)
+	{
+		return;
+	}
+	if (pHTInfo->bCurBW40MHz && is_peer_40M && !ieee->bandwidth_auto_switch.bforced_tx20Mhz)
+		tcb_desc->bPacketBW = true;
+	return;
+}
+#endif
+void rtllib_query_protectionmode(struct rtllib_device* ieee, cb_desc* tcb_desc, struct sk_buff* skb)
+{
+	tcb_desc->bRTSSTBC			= false;
+	tcb_desc->bRTSUseShortGI		= false;
+	tcb_desc->bCTSEnable			= false;
+	tcb_desc->RTSSC				= 0;
+	tcb_desc->bRTSBW			= false;
+
+	if (tcb_desc->bBroadcast || tcb_desc->bMulticast)
+		return;
+
+	if (is_broadcast_ether_addr(skb->data+16))
+		return;
+
+	if (ieee->mode < IEEE_N_24G)
+	{
+		if (skb->len > ieee->rts)
+		{
+			tcb_desc->bRTSEnable = true;
+			tcb_desc->rts_rate = MGN_24M;
+		}
+		else if (ieee->current_network.buseprotection)
+		{
+			tcb_desc->bRTSEnable = true;
+			tcb_desc->bCTSEnable = true;
+			tcb_desc->rts_rate = MGN_24M;
+		}
+		return;
+	}
+	else
+	{
+		PRT_HIGH_THROUGHPUT pHTInfo = ieee->pHTInfo;
+		while (true)
+		{
+			if (pHTInfo->IOTAction & HT_IOT_ACT_FORCED_CTS2SELF)
+			{
+				tcb_desc->bCTSEnable	= true;
+				tcb_desc->rts_rate  =	MGN_24M;
+				tcb_desc->bRTSEnable = true;
+				break;
+			}
+			else if (pHTInfo->IOTAction & (HT_IOT_ACT_FORCED_RTS|HT_IOT_ACT_PURE_N_MODE))
+			{
+				tcb_desc->bRTSEnable = true;
+				tcb_desc->rts_rate  =	MGN_24M;
+				break;
+			}
+			if (ieee->current_network.buseprotection)
+			{
+				tcb_desc->bRTSEnable = true;
+				tcb_desc->bCTSEnable = true;
+				tcb_desc->rts_rate = MGN_24M;
+				break;
+			}
+			if (pHTInfo->bCurrentHTSupport  && pHTInfo->bEnableHT)
+			{
+				u8 HTOpMode = pHTInfo->CurrentOpMode;
+				if ((pHTInfo->bCurBW40MHz && (HTOpMode == 2 || HTOpMode == 3)) ||
+							(!pHTInfo->bCurBW40MHz && HTOpMode == 3) )
+				{
+					tcb_desc->rts_rate = MGN_24M;
+					tcb_desc->bRTSEnable = true;
+					break;
+				}
+			}
+			if (skb->len > ieee->rts)
+			{
+				tcb_desc->rts_rate = MGN_24M;
+				tcb_desc->bRTSEnable = true;
+				break;
+			}
+			if (tcb_desc->bAMPDUEnable)
+			{
+				tcb_desc->rts_rate = MGN_24M;
+				tcb_desc->bRTSEnable = false;
+				break;
+			}
+			goto NO_PROTECTION;
+		}
+		}
+	if ( 0 )
+	{
+		tcb_desc->bCTSEnable	= true;
+		tcb_desc->rts_rate = MGN_24M;
+		tcb_desc->bRTSEnable	= true;
+	}
+	if (ieee->current_network.capability & WLAN_CAPABILITY_SHORT_PREAMBLE)
+		tcb_desc->bUseShortPreamble = true;
+	if (ieee->iw_mode == IW_MODE_MASTER)
+			goto NO_PROTECTION;
+	return;
+NO_PROTECTION:
+	tcb_desc->bRTSEnable	= false;
+	tcb_desc->bCTSEnable	= false;
+	tcb_desc->rts_rate		= 0;
+	tcb_desc->RTSSC		= 0;
+	tcb_desc->bRTSBW		= false;
+}
+
+
+#if defined(RTL8192U) || defined(RTL8192SU) || defined(RTL8192SE)
+void rtllib_txrate_selectmode(struct rtllib_device* ieee, cb_desc* tcb_desc,struct sta_info *psta)
+#else
+void rtllib_txrate_selectmode(struct rtllib_device* ieee, cb_desc* tcb_desc)
+#endif
+{
+#ifdef TO_DO_LIST
+	if (!IsDataFrame(pFrame))
+	{
+		pTcb->bTxDisableRateFallBack = true;
+		pTcb->bTxUseDriverAssingedRate = true;
+		pTcb->RATRIndex = 7;
+		return;
+	}
+
+	if (pMgntInfo->ForcedDataRate!= 0)
+	{
+		pTcb->bTxDisableRateFallBack = true;
+		pTcb->bTxUseDriverAssingedRate = true;
+		return;
+	}
+#endif
+	if (ieee->bTxDisableRateFallBack)
+		tcb_desc->bTxDisableRateFallBack = true;
+
+	if (ieee->bTxUseDriverAssingedRate)
+		tcb_desc->bTxUseDriverAssingedRate = true;
+	if (!tcb_desc->bTxDisableRateFallBack || !tcb_desc->bTxUseDriverAssingedRate)
+	{
+		if (ieee->iw_mode == IW_MODE_INFRA || ieee->iw_mode == IW_MODE_ADHOC)
+			tcb_desc->RATRIndex = 0;
+	}
+}
+
+u16 rtllib_query_seqnum(struct rtllib_device*ieee, struct sk_buff* skb, u8* dst)
+{
+	u16 seqnum = 0;
+
+	if (is_multicast_ether_addr(dst) || is_broadcast_ether_addr(dst))
+		return 0;
+	if (IsQoSDataFrame(skb->data))
+	{
+		PTX_TS_RECORD pTS = NULL;
+		if (!GetTs(ieee, (PTS_COMMON_INFO*)(&pTS), dst, skb->priority, TX_DIR, true))
+		{
+			return 0;
+		}
+		seqnum = pTS->TxCurSeq;
+		pTS->TxCurSeq = (pTS->TxCurSeq+1)%4096;
+		return seqnum;
+	}
+	return 0;
+}
+
+static int wme_downgrade_ac(struct sk_buff *skb)
+{
+	switch (skb->priority) {
+		case 6:
+		case 7:
+			skb->priority = 5; /* VO -> VI */
+			return 0;
+		case 4:
+		case 5:
+			skb->priority = 3; /* VI -> BE */
+			return 0;
+		case 0:
+		case 3:
+			skb->priority = 1; /* BE -> BK */
+			return 0;
+		default:
+			return -1;
+	}
+}
+
+int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)
+{
+	struct rtllib_device *ieee = (struct rtllib_device *)netdev_priv_rsl(dev);
+	struct rtllib_txb *txb = NULL;
+	struct rtllib_hdr_3addrqos *frag_hdr;
+	int i, bytes_per_frag, nr_frags, bytes_last_frag, frag_size;
+	unsigned long flags;
+	struct net_device_stats *stats = &ieee->stats;
+	int ether_type = 0, encrypt;
+	int bytes, fc, qos_ctl = 0, hdr_len;
+	struct sk_buff *skb_frag;
+	struct rtllib_hdr_3addrqos header = { /* Ensure zero initialized */
+		.duration_id = 0,
+		.seq_ctl = 0,
+		.qos_ctl = 0
+	};
+	u8 dest[ETH_ALEN], src[ETH_ALEN];
+	int qos_actived = ieee->current_network.qos_data.active;
+	struct rtllib_crypt_data* crypt = NULL;
+	cb_desc *tcb_desc;
+	u8 bIsMulticast = false;
+	u8 IsAmsdu = false;
+
+	bool	bdhcp =false;
+	spin_lock_irqsave(&ieee->lock, flags);
+
+	/* If there is no driver handler to take the TXB, dont' bother
+	 * creating it... */
+	if ((!ieee->hard_start_xmit && !(ieee->softmac_features & IEEE_SOFTMAC_TX_QUEUE))||
+	   ((!ieee->softmac_data_hard_start_xmit && (ieee->softmac_features & IEEE_SOFTMAC_TX_QUEUE)))) {
+		printk(KERN_WARNING "%s: No xmit handler.\n",
+		       ieee->dev->name);
+		goto success;
+	}
+
+
+	if (likely(ieee->raw_tx == 0)){
+		if (unlikely(skb->len < SNAP_SIZE + sizeof(u16))) {
+			printk(KERN_WARNING "%s: skb too small (%d).\n",
+			ieee->dev->name, skb->len);
+			goto success;
+		}
+		/* Save source and destination addresses */
+		memcpy(dest, skb->data, ETH_ALEN);
+		memcpy(src, skb->data+ETH_ALEN, ETH_ALEN);
+
+		memset(skb->cb, 0, sizeof(skb->cb));
+		ether_type = ntohs(((struct ethhdr *)skb->data)->h_proto);
+
+		if (ieee->iw_mode == IW_MODE_MONITOR)
+		{
+			txb = rtllib_alloc_txb(1, skb->len, GFP_ATOMIC);
+			if (unlikely(!txb)) {
+				printk(KERN_WARNING "%s: Could not allocate TXB\n",
+				ieee->dev->name);
+				goto failed;
+			}
+
+			txb->encrypted = 0;
+			txb->payload_size = skb->len;
+			memcpy(skb_put(txb->fragments[0],skb->len), skb->data, skb->len);
+
+			goto success;
+		}
+
+		if (skb->len > 282){
+			if (ETH_P_IP == ether_type) {
+				const struct iphdr *ip = (struct iphdr *)((u8 *)skb->data+14);
+				if (IPPROTO_UDP == ip->protocol) {
+					struct udphdr *udp = (struct udphdr *)((u8 *)ip + (ip->ihl << 2));
+					if (((((u8 *)udp)[1] == 68) && (((u8 *)udp)[3] == 67)) ||
+					    ((((u8 *)udp)[1] == 67) && (((u8 *)udp)[3] == 68))) {
+						printk("DHCP pkt src port:%d, dest port:%d!!\n", ((u8 *)udp)[1],((u8 *)udp)[3]);
+
+						bdhcp = true;
+						ieee->LPSDelayCnt = 200;
+					}
+				}
+			}else if (ETH_P_ARP == ether_type){
+				printk("=================>DHCP Protocol start tx ARP pkt!!\n");
+				bdhcp = true;
+				ieee->LPSDelayCnt = ieee->current_network.tim.tim_count;
+
+
+			}
+		}
+
+		skb->priority = rtllib_classify(skb, IsAmsdu);
+		crypt = ieee->crypt[ieee->tx_keyidx];
+		encrypt = !(ether_type == ETH_P_PAE && ieee->ieee802_1x) &&
+			ieee->host_encrypt && crypt && crypt->ops;
+		if (!encrypt && ieee->ieee802_1x &&
+		ieee->drop_unencrypted && ether_type != ETH_P_PAE) {
+			stats->tx_dropped++;
+			goto success;
+		}
+	#ifdef CONFIG_RTLLIB_DEBUG
+		if (crypt && !encrypt && ether_type == ETH_P_PAE) {
+			struct eapol *eap = (struct eapol *)(skb->data +
+				sizeof(struct ethhdr) - SNAP_SIZE - sizeof(u16));
+			RTLLIB_DEBUG_EAP("TX: IEEE 802.11 EAPOL frame: %s\n",
+				eap_get_type(eap->type));
+		}
+	#endif
+
+		/* Advance the SKB to the start of the payload */
+		skb_pull(skb, sizeof(struct ethhdr));
+
+                /* Determine total amount of storage required for TXB packets */
+		bytes = skb->len + SNAP_SIZE + sizeof(u16);
+
+		if (encrypt)
+			fc = RTLLIB_FTYPE_DATA | RTLLIB_FCTL_WEP;
+		else
+			fc = RTLLIB_FTYPE_DATA;
+
+		if (qos_actived)
+			fc |= RTLLIB_STYPE_QOS_DATA;
+		else
+			fc |= RTLLIB_STYPE_DATA;
+
+		if (ieee->iw_mode == IW_MODE_INFRA) {
+			fc |= RTLLIB_FCTL_TODS;
+			/* To DS: Addr1 = BSSID, Addr2 = SA,
+			Addr3 = DA */
+			memcpy(&header.addr1, ieee->current_network.bssid, ETH_ALEN);
+			memcpy(&header.addr2, &src, ETH_ALEN);
+			if (IsAmsdu)
+				memcpy(&header.addr3, ieee->current_network.bssid, ETH_ALEN);
+			else
+				memcpy(&header.addr3, &dest, ETH_ALEN);
+		} else if (ieee->iw_mode == IW_MODE_ADHOC) {
+			/* not From/To DS: Addr1 = DA, Addr2 = SA,
+			Addr3 = BSSID */
+			memcpy(&header.addr1, dest, ETH_ALEN);
+			memcpy(&header.addr2, src, ETH_ALEN);
+			memcpy(&header.addr3, ieee->current_network.bssid, ETH_ALEN);
+		}
+
+		bIsMulticast = is_broadcast_ether_addr(header.addr1) ||is_multicast_ether_addr(header.addr1);
+
+                header.frame_ctl = cpu_to_le16(fc);
+
+		/* Determine fragmentation size based on destination (multicast
+		* and broadcast are not fragmented) */
+		if (bIsMulticast) {
+			frag_size = MAX_FRAG_THRESHOLD;
+			qos_ctl |= QOS_CTL_NOTCONTAIN_ACK;
+		} else {
+			frag_size = ieee->fts;
+			qos_ctl = 0;
+		}
+
+		if (qos_actived) {
+			hdr_len = RTLLIB_3ADDR_LEN + 2;
+
+                    /* in case we are a client verify acm is not set for this ac */
+                    while (unlikely(ieee->wmm_acm & (0x01 << skb->priority))) {
+                        printk("skb->priority = %x\n", skb->priority);
+                        if (wme_downgrade_ac(skb)) {
+                            break;
+                        }
+                        printk("converted skb->priority = %x\n", skb->priority);
+                    }
+                    qos_ctl |= skb->priority;
+                    header.qos_ctl = cpu_to_le16(qos_ctl & RTLLIB_QOS_TID);
+		} else {
+			hdr_len = RTLLIB_3ADDR_LEN;
+		}
+		/* Determine amount of payload per fragment.  Regardless of if
+		* this stack is providing the full 802.11 header, one will
+		* eventually be affixed to this fragment -- so we must account for
+		* it when determining the amount of payload space. */
+		bytes_per_frag = frag_size - hdr_len;
+		if (ieee->config &
+		(CFG_RTLLIB_COMPUTE_FCS | CFG_RTLLIB_RESERVE_FCS))
+			bytes_per_frag -= RTLLIB_FCS_LEN;
+
+		/* Each fragment may need to have room for encryptiong pre/postfix */
+		if (encrypt) {
+			bytes_per_frag -= crypt->ops->extra_prefix_len +
+				crypt->ops->extra_postfix_len;
+		}
+		/* Number of fragments is the total bytes_per_frag /
+		* payload_per_fragment */
+		nr_frags = bytes / bytes_per_frag;
+		bytes_last_frag = bytes % bytes_per_frag;
+		if (bytes_last_frag)
+			nr_frags++;
+		else
+			bytes_last_frag = bytes_per_frag;
+
+		/* When we allocate the TXB we allocate enough space for the reserve
+		* and full fragment bytes (bytes_per_frag doesn't include prefix,
+		* postfix, header, FCS, etc.) */
+		txb = rtllib_alloc_txb(nr_frags, frag_size + ieee->tx_headroom, GFP_ATOMIC);
+		if (unlikely(!txb)) {
+			printk(KERN_WARNING "%s: Could not allocate TXB\n",
+			ieee->dev->name);
+			goto failed;
+		}
+		txb->encrypted = encrypt;
+		txb->payload_size = bytes;
+
+		if (qos_actived)
+		{
+			txb->queue_index = UP2AC(skb->priority);
+		} else {
+			txb->queue_index = WME_AC_BE;;
+		}
+
+		for (i = 0; i < nr_frags; i++) {
+			skb_frag = txb->fragments[i];
+			tcb_desc = (cb_desc *)(skb_frag->cb + MAX_DEV_ADDR_SIZE);
+			if (qos_actived){
+				skb_frag->priority = skb->priority;
+				tcb_desc->queue_index =  UP2AC(skb->priority);
+			} else {
+				skb_frag->priority = WME_AC_BE;
+				tcb_desc->queue_index = WME_AC_BE;
+			}
+			skb_reserve(skb_frag, ieee->tx_headroom);
+
+			if (encrypt){
+				if (ieee->hwsec_active)
+					tcb_desc->bHwSec = 1;
+				else
+					tcb_desc->bHwSec = 0;
+				skb_reserve(skb_frag, crypt->ops->extra_prefix_len);
+			} else {
+				tcb_desc->bHwSec = 0;
+			}
+			frag_hdr = (struct rtllib_hdr_3addrqos *)skb_put(skb_frag, hdr_len);
+			memcpy(frag_hdr, &header, hdr_len);
+
+			/* If this is not the last fragment, then add the MOREFRAGS
+			* bit to the frame control */
+			if (i != nr_frags - 1) {
+				frag_hdr->frame_ctl = cpu_to_le16(
+					fc | RTLLIB_FCTL_MOREFRAGS);
+				bytes = bytes_per_frag;
+
+			} else {
+				/* The last fragment takes the remaining length */
+				bytes = bytes_last_frag;
+			}
+			if ((qos_actived) && (!bIsMulticast))
+			{
+				frag_hdr->seq_ctl = rtllib_query_seqnum(ieee, skb_frag, header.addr1);
+				frag_hdr->seq_ctl = cpu_to_le16(frag_hdr->seq_ctl<<4 | i);
+			} else {
+				frag_hdr->seq_ctl = cpu_to_le16(ieee->seq_ctrl[0]<<4 | i);
+			}
+			/* Put a SNAP header on the first fragment */
+			if (i == 0) {
+				rtllib_put_snap(
+					skb_put(skb_frag, SNAP_SIZE + sizeof(u16)),
+					ether_type);
+				bytes -= SNAP_SIZE + sizeof(u16);
+			}
+
+			memcpy(skb_put(skb_frag, bytes), skb->data, bytes);
+
+			/* Advance the SKB... */
+			skb_pull(skb, bytes);
+
+			/* Encryption routine will move the header forward in order
+			* to insert the IV between the header and the payload */
+			if (encrypt)
+				rtllib_encrypt_fragment(ieee, skb_frag, hdr_len);
+			if (ieee->config &
+			(CFG_RTLLIB_COMPUTE_FCS | CFG_RTLLIB_RESERVE_FCS))
+				skb_put(skb_frag, 4);
+		}
+
+		if ((qos_actived) && (!bIsMulticast)) {
+		  if (ieee->seq_ctrl[UP2AC(skb->priority) + 1] == 0xFFF)
+			ieee->seq_ctrl[UP2AC(skb->priority) + 1] = 0;
+		  else
+			ieee->seq_ctrl[UP2AC(skb->priority) + 1]++;
+		} else {
+		  if (ieee->seq_ctrl[0] == 0xFFF)
+			ieee->seq_ctrl[0] = 0;
+		  else
+			ieee->seq_ctrl[0]++;
+		}
+	}else{
+		if (unlikely(skb->len < sizeof(struct rtllib_hdr_3addr))) {
+			printk(KERN_WARNING "%s: skb too small (%d).\n",
+			ieee->dev->name, skb->len);
+			goto success;
+		}
+
+		txb = rtllib_alloc_txb(1, skb->len, GFP_ATOMIC);
+		if (!txb){
+			printk(KERN_WARNING "%s: Could not allocate TXB\n",
+			ieee->dev->name);
+			goto failed;
+		}
+
+		txb->encrypted = 0;
+		txb->payload_size = skb->len;
+		memcpy(skb_put(txb->fragments[0],skb->len), skb->data, skb->len);
+	}
+
+ success:
+	if (txb)
+	{
+#if 1
+		cb_desc *tcb_desc = (cb_desc *)(txb->fragments[0]->cb + MAX_DEV_ADDR_SIZE);
+		tcb_desc->bTxEnableFwCalcDur = 1;
+		tcb_desc->priority = skb->priority;
+
+		if (ether_type == ETH_P_PAE) {
+			if (ieee->pHTInfo->IOTAction & HT_IOT_ACT_WA_IOT_Broadcom)
+			{
+				tcb_desc->data_rate = MgntQuery_TxRateExcludeCCKRates(ieee);
+				tcb_desc->bTxDisableRateFallBack = false;
+			}else{
+				tcb_desc->data_rate = ieee->basic_rate;
+				tcb_desc->bTxDisableRateFallBack = 1;
+			}
+
+
+			tcb_desc->RATRIndex = 7;
+			tcb_desc->bTxUseDriverAssingedRate = 1;
+		} else {
+			if (is_multicast_ether_addr(header.addr1))
+				tcb_desc->bMulticast = 1;
+			if (is_broadcast_ether_addr(header.addr1))
+				tcb_desc->bBroadcast = 1;
+#if defined(RTL8192U) || defined(RTL8192SU) || defined(RTL8192SE)
+			if ( tcb_desc->bMulticast ||  tcb_desc->bBroadcast){
+				rtllib_txrate_selectmode(ieee, tcb_desc, p_sta);
+				tcb_desc->data_rate = ieee->basic_rate;
+			}
+			else
+			{
+				if (ieee->iw_mode == IW_MODE_ADHOC)
+				{
+					u8 is_peer_shortGI_40M = 0;
+					u8 is_peer_shortGI_20M = 0;
+					u8 is_peer_BW_40M = 0;
+					p_sta = GetStaInfo(ieee, header.addr1);
+					if (NULL == p_sta)
+					{
+						rtllib_txrate_selectmode(ieee, tcb_desc, p_sta);
+						tcb_desc->data_rate = ieee->rate;
+					}
+					else
+					{
+						rtllib_txrate_selectmode(ieee, tcb_desc, p_sta);
+						tcb_desc->data_rate = CURRENT_RATE(p_sta->wireless_mode, p_sta->CurDataRate, p_sta->htinfo.HTHighestOperaRate);
+						is_peer_shortGI_40M = p_sta->htinfo.bCurShortGI40MHz;
+						is_peer_shortGI_20M = p_sta->htinfo.bCurShortGI20MHz;
+						is_peer_BW_40M = p_sta->htinfo.bCurTxBW40MHz;
+					}
+					rtllib_qurey_ShortPreambleMode(ieee, tcb_desc);
+					rtllib_tx_query_agg_cap(ieee, txb->fragments[0], tcb_desc);
+					rtllib_ibss_query_HTCapShortGI(ieee, tcb_desc,is_peer_shortGI_40M,is_peer_shortGI_20M);
+					rtllib_ibss_query_BandwidthMode(ieee, tcb_desc,is_peer_BW_40M);
+					rtllib_query_protectionmode(ieee, tcb_desc, txb->fragments[0]);
+				}
+				else {
+					rtllib_txrate_selectmode(ieee, tcb_desc, p_sta);
+					tcb_desc->data_rate = CURRENT_RATE(ieee->mode, ieee->rate, ieee->HTCurrentOperaRate);
+					if (bdhcp == true){
+						if (ieee->pHTInfo->IOTAction & HT_IOT_ACT_WA_IOT_Broadcom) {
+							tcb_desc->data_rate = MGN_1M;
+							tcb_desc->bTxDisableRateFallBack = false;
+						}else{
+							tcb_desc->data_rate = MGN_1M;
+							tcb_desc->bTxDisableRateFallBack = 1;
+						}
+
+						tcb_desc->RATRIndex = 7;
+						tcb_desc->bTxUseDriverAssingedRate = 1;
+						tcb_desc->bdhcp = 1;
+					}
+					rtllib_qurey_ShortPreambleMode(ieee, tcb_desc);
+					rtllib_tx_query_agg_cap(ieee, txb->fragments[0], tcb_desc);
+					rtllib_query_HTCapShortGI(ieee, tcb_desc);
+					rtllib_query_BandwidthMode(ieee, tcb_desc);
+					rtllib_query_protectionmode(ieee, tcb_desc, txb->fragments[0]);
+				}
+			}
+#else
+			rtllib_txrate_selectmode(ieee, tcb_desc);
+			if ( tcb_desc->bMulticast ||  tcb_desc->bBroadcast)
+				tcb_desc->data_rate = ieee->basic_rate;
+			else
+				tcb_desc->data_rate = CURRENT_RATE(ieee->mode, ieee->rate, ieee->HTCurrentOperaRate);
+
+			if (bdhcp == true){
+				if (ieee->pHTInfo->IOTAction & HT_IOT_ACT_WA_IOT_Broadcom)
+				{
+					tcb_desc->data_rate = MgntQuery_TxRateExcludeCCKRates(ieee);
+					tcb_desc->bTxDisableRateFallBack = false;
+				}else{
+					tcb_desc->data_rate = MGN_1M;
+					tcb_desc->bTxDisableRateFallBack = 1;
+				}
+
+
+				tcb_desc->RATRIndex = 7;
+				tcb_desc->bTxUseDriverAssingedRate = 1;
+				tcb_desc->bdhcp = 1;
+			}
+
+			rtllib_qurey_ShortPreambleMode(ieee, tcb_desc);
+			rtllib_tx_query_agg_cap(ieee, txb->fragments[0], tcb_desc);
+			rtllib_query_HTCapShortGI(ieee, tcb_desc);
+			rtllib_query_BandwidthMode(ieee, tcb_desc);
+			rtllib_query_protectionmode(ieee, tcb_desc, txb->fragments[0]);
+#endif
+		}
+#endif
+	}
+	spin_unlock_irqrestore(&ieee->lock, flags);
+	dev_kfree_skb_any(skb);
+	if (txb) {
+		if (ieee->softmac_features & IEEE_SOFTMAC_TX_QUEUE){
+			dev->stats.tx_packets++;
+			dev->stats.tx_bytes += txb->payload_size;
+			rtllib_softmac_xmit(txb, ieee);
+		}else{
+			if ((*ieee->hard_start_xmit)(txb, dev) == 0) {
+				stats->tx_packets++;
+				stats->tx_bytes += txb->payload_size;
+				return 0;
+			}
+			rtllib_txb_free(txb);
+		}
+	}
+
+	return 0;
+
+ failed:
+	spin_unlock_irqrestore(&ieee->lock, flags);
+	netif_stop_queue(dev);
+	stats->tx_errors++;
+	return 1;
+
+}
+int rtllib_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	memset(skb->cb, 0, sizeof(skb->cb));
+	return rtllib_xmit_inter(skb, dev);
+}
