commit 6cfed598480493d814414ce7e53027bd6fc45c49
Author: Kees Cook <keescook@chromium.org>
Date:   Fri Nov 15 09:28:28 2019 -0800

    staging: rtl*: Remove tasklet callback casts
    
    In order to make the entire kernel usable under Clang's Control Flow
    Integrity protections, function prototype casts need to be avoided
    because this will trip CFI checks at runtime (i.e. a mismatch between
    the caller's expected function prototype and the destination function's
    prototype). Many of these cases can be found with -Wcast-function-type,
    which found that the rtl wifi drivers had a bunch of needless function
    casts. Remove function casts for tasklet callbacks in the various drivers.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Link: https://lore.kernel.org/r/201911150926.2894A4F973@keescook
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index f2f7529e7c80..6e2f620afd14 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -2044,8 +2044,9 @@ static short rtllib_sta_ps_sleep(struct rtllib_device *ieee, u64 *time)
 
 }
 
-static inline void rtllib_sta_ps(struct rtllib_device *ieee)
+static inline void rtllib_sta_ps(unsigned long data)
 {
+	struct rtllib_device *ieee = (struct rtllib_device *)data;
 	u64 time;
 	short sleep;
 	unsigned long flags, flags2;
@@ -3027,9 +3028,7 @@ void rtllib_softmac_init(struct rtllib_device *ieee)
 	spin_lock_init(&ieee->mgmt_tx_lock);
 	spin_lock_init(&ieee->beacon_lock);
 
-	tasklet_init(&ieee->ps_task,
-	     (void(*)(unsigned long)) rtllib_sta_ps,
-	     (unsigned long)ieee);
+	tasklet_init(&ieee->ps_task, rtllib_sta_ps, (unsigned long)ieee);
 
 }
 

commit 36d042bd6865ada4fc5b14e2cb5fd325eeb248db
Author: Hariprasad Kelam <hariprasad.kelam@gmail.com>
Date:   Sun Aug 4 08:18:32 2019 +0530

    staging: rtl8192e: Make use kmemdup
    
    As kmemdup API does kmalloc + memcpy . We can make use of it instead of
    calling kmalloc and memcpy independetly.
    
    Signed-off-by: Hariprasad Kelam <hariprasad.kelam@gmail.com>
    Link: https://lore.kernel.org/r/20190804024832.GA14352@hari-Inspiron-1545
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index e29e8d6f4611..f2f7529e7c80 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -1382,15 +1382,10 @@ rtllib_association_req(struct rtllib_network *beacon,
 	ieee->assocreq_ies = NULL;
 	ies = &(hdr->info_element[0].id);
 	ieee->assocreq_ies_len = (skb->data + skb->len) - ies;
-	ieee->assocreq_ies = kmalloc(ieee->assocreq_ies_len, GFP_ATOMIC);
-	if (ieee->assocreq_ies)
-		memcpy(ieee->assocreq_ies, ies, ieee->assocreq_ies_len);
-	else {
-		netdev_info(ieee->dev,
-			    "%s()Warning: can't alloc memory for assocreq_ies\n",
-			    __func__);
+	ieee->assocreq_ies = kmemdup(ies, ieee->assocreq_ies_len, GFP_ATOMIC);
+	if (!ieee->assocreq_ies)
 		ieee->assocreq_ies_len = 0;
-	}
+
 	return skb;
 }
 
@@ -2259,17 +2254,12 @@ rtllib_rx_assoc_resp(struct rtllib_device *ieee, struct sk_buff *skb,
 			ieee->assocresp_ies = NULL;
 			ies = &(assoc_resp->info_element[0].id);
 			ieee->assocresp_ies_len = (skb->data + skb->len) - ies;
-			ieee->assocresp_ies = kmalloc(ieee->assocresp_ies_len,
+			ieee->assocresp_ies = kmemdup(ies,
+						      ieee->assocresp_ies_len,
 						      GFP_ATOMIC);
-			if (ieee->assocresp_ies)
-				memcpy(ieee->assocresp_ies, ies,
-				       ieee->assocresp_ies_len);
-			else {
-				netdev_info(ieee->dev,
-					    "%s()Warning: can't alloc memory for assocresp_ies\n",
-					    __func__);
+			if (!ieee->assocresp_ies)
 				ieee->assocresp_ies_len = 0;
-			}
+
 			rtllib_associate_complete(ieee);
 		} else {
 			/* aid could not been allocated */

commit 18056f34c3b755f027a0923b0bb9d50a2e339caa
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Apr 2 12:31:58 2019 +0200

    staging: rtl8192e: add proper SPDX identifiers on files that did not have them.
    
    There were a few files for the rtl8192e driver that did not have SPDX
    identifiers on them, so fix that up.  At the same time, remove the "free
    form" text that specified the license of the file, as that is impossible
    for any tool to properly parse.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index ee275857868f..e29e8d6f4611 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /* IEEE 802.11 SoftMAC layer
  * Copyright (c) 2005 Andrea Merello <andrea.merello@gmail.com>
  *
@@ -9,11 +10,7 @@
  *
  * WPA code stolen from the ipw2200 driver.
  * Copyright who own it's copyright.
- *
- * released under the GPL
  */
-
-
 #include "rtllib.h"
 
 #include <linux/random.h>

commit c40cac3b760e008d87e372caf638055887f417f2
Author: Himadri Pandya <himadri18.07@gmail.com>
Date:   Sun Feb 10 14:13:16 2019 +0530

    staging: rtl8192e: rename function DOT11D_ScanComplete to dot11d_scan_complete - style
    
    Rename function DOT11D_ScanComplete to dot11d_scan_complete to fix
    checkpatch warning: Avoid CamelCase.
    
    Signed-off-by: Himadri Pandya <himadri18.07@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 9752fda840d4..ee275857868f 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -564,7 +564,7 @@ static void rtllib_softmac_scan_syncro(struct rtllib_device *ieee, u8 is_mesh)
 
 	if (ieee->state >= RTLLIB_LINKED) {
 		if (IS_DOT11D_ENABLE(ieee))
-			DOT11D_ScanComplete(ieee);
+			dot11d_scan_complete(ieee);
 	}
 	mutex_unlock(&ieee->scan_mutex);
 
@@ -623,7 +623,7 @@ static void rtllib_softmac_scan_wq(void *data)
 
 out:
 	if (IS_DOT11D_ENABLE(ieee))
-		DOT11D_ScanComplete(ieee);
+		dot11d_scan_complete(ieee);
 	ieee->current_network.channel = last_channel;
 
 out1:

commit 8e9f5da2fd7d2c77ded0a1dbbc596d1cb75ca562
Author: Himadri Pandya <himadri18.07@gmail.com>
Date:   Sun Feb 10 14:13:14 2019 +0530

    staging: rtl8192e: rename function Dot11d_Reset to dot11d_reset - style
    
    Rename function Dot11d_Reset to dot11d_reset to fix checkpatch warning:
    Avoid CamelCase.
    
    Signed-off-by: Himadri Pandya <himadri18.07@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index f1023e21fb5c..9752fda840d4 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -2759,7 +2759,7 @@ void rtllib_disassociate(struct rtllib_device *ieee)
 	if (ieee->data_hard_stop)
 		ieee->data_hard_stop(ieee->dev);
 	if (IS_DOT11D_ENABLE(ieee))
-		Dot11d_Reset(ieee);
+		dot11d_reset(ieee);
 	ieee->state = RTLLIB_NOLINK;
 	ieee->is_set_key = false;
 	ieee->wap_set = 0;

commit a180ef30dafbc25e31d0743b163eea0e94b38607
Author: Himadri Pandya <himadri18.07@gmail.com>
Date:   Wed Feb 6 21:04:16 2019 +0530

    staging: rtl8192e: rename members of struct rtllib_device - style
    
    Rename following members of struct rtllib_device to fix checkpatch
    warning: Avoid CamelCase
            pDot11dInfo -> dot11d_info
            bGlobalDomain -> global_domain
            IbssStartChnl -> bss_start_channel
    
    Signed-off-by: Himadri Pandya <himadri18.07@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 9bff727032fc..f1023e21fb5c 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -2627,7 +2627,7 @@ static void rtllib_start_ibss_wq(void *data)
 	/* the network definitively is not here.. create a new cell */
 	if (ieee->state == RTLLIB_NOLINK) {
 		netdev_info(ieee->dev, "creating new IBSS cell\n");
-		ieee->current_network.channel = ieee->IbssStartChnl;
+		ieee->current_network.channel = ieee->bss_start_channel;
 		if (!ieee->wap_set)
 			eth_random_addr(ieee->current_network.bssid);
 
@@ -2719,7 +2719,7 @@ static void rtllib_start_bss(struct rtllib_device *ieee)
 	unsigned long flags;
 
 	if (IS_DOT11D_ENABLE(ieee) && !IS_COUNTRY_IE_VALID(ieee)) {
-		if (!ieee->bGlobalDomain)
+		if (!ieee->global_domain)
 			return;
 	}
 	/* check if we have already found the net we
@@ -2974,8 +2974,8 @@ void rtllib_softmac_init(struct rtllib_device *ieee)
 	ieee->state = RTLLIB_NOLINK;
 	for (i = 0; i < 5; i++)
 		ieee->seq_ctrl[i] = 0;
-	ieee->pDot11dInfo = kzalloc(sizeof(struct rt_dot11d_info), GFP_ATOMIC);
-	if (!ieee->pDot11dInfo)
+	ieee->dot11d_info = kzalloc(sizeof(struct rt_dot11d_info), GFP_ATOMIC);
+	if (!ieee->dot11d_info)
 		netdev_err(ieee->dev, "Can't alloc memory for DOT11D\n");
 	ieee->LinkDetectInfo.SlotIndex = 0;
 	ieee->LinkDetectInfo.SlotNum = 2;
@@ -3049,8 +3049,8 @@ void rtllib_softmac_init(struct rtllib_device *ieee)
 void rtllib_softmac_free(struct rtllib_device *ieee)
 {
 	mutex_lock(&ieee->wx_mutex);
-	kfree(ieee->pDot11dInfo);
-	ieee->pDot11dInfo = NULL;
+	kfree(ieee->dot11d_info);
+	ieee->dot11d_info = NULL;
 	del_timer_sync(&ieee->associate_timer);
 
 	cancel_delayed_work_sync(&ieee->associate_retry_wq);

commit 0fa82deb5af608effa7f5bcb670fb9151ee34f1d
Author: Michiel Schuurmans <michielschuurmans@gmail.com>
Date:   Sat Jan 26 18:31:21 2019 +0100

    Staging: rtl8192e: Replaced spaces with tab.
    
    Replaced the spaces with tabs as suggested by checkpatch.
    
    Signed-off-by: Michiel Schuurmans <michielschuurmans@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 287d0c11fa38..9bff727032fc 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -1688,8 +1688,8 @@ inline void rtllib_softmac_new_net(struct rtllib_device *ieee,
 				       ieee->current_network.ssid_len);
 				tmp_ssid_len = ieee->current_network.ssid_len;
 			}
- 			memcpy(&ieee->current_network, net,
- 			       sizeof(ieee->current_network));
+			memcpy(&ieee->current_network, net,
+				sizeof(ieee->current_network));
 			if (!ssidbroad) {
 				memcpy(ieee->current_network.ssid, tmp_ssid,
 				       tmp_ssid_len);

commit 86eac24dbb7b0acc8608a52d42bc18e85c78d7ff
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Mon Aug 27 13:46:45 2018 -0500

    staging: rtl8192e: Fix compiler warning from strncpy()
    
    When strncpy() is called with source and destination strings the same
    length, gcc 8 warns that there may be an unterminated string. This section
    is completely reworked to use the known lengths of the strings.
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 919231fec09c..287d0c11fa38 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -1680,19 +1680,19 @@ inline void rtllib_softmac_new_net(struct rtllib_device *ieee,
 		   (ssidbroad && !ssidset) || (!ssidbroad && ssidset))) ||
 		   (!apset && ssidset && ssidbroad && ssidmatch) ||
 		   (ieee->is_roaming && ssidset && ssidbroad && ssidmatch)) {
-			/* if the essid is hidden replace it with the
-			 * essid provided by the user.
+			/* Save the essid so that if it is hidden, it is
+			 * replaced with the essid provided by the user.
 			 */
 			if (!ssidbroad) {
-				strncpy(tmp_ssid, ieee->current_network.ssid,
-					IW_ESSID_MAX_SIZE);
+				memcpy(tmp_ssid, ieee->current_network.ssid,
+				       ieee->current_network.ssid_len);
 				tmp_ssid_len = ieee->current_network.ssid_len;
 			}
-			memcpy(&ieee->current_network, net,
-			       sizeof(struct rtllib_network));
+ 			memcpy(&ieee->current_network, net,
+ 			       sizeof(ieee->current_network));
 			if (!ssidbroad) {
-				strncpy(ieee->current_network.ssid, tmp_ssid,
-					IW_ESSID_MAX_SIZE);
+				memcpy(ieee->current_network.ssid, tmp_ssid,
+				       tmp_ssid_len);
 				ieee->current_network.ssid_len = tmp_ssid_len;
 			}
 			netdev_info(ieee->dev,

commit 783778e38e4adf9d3e1691151c0f408e8cae514a
Author: Colin Ian King <colin.king@canonical.com>
Date:   Sat Jan 20 22:21:40 2018 +0000

    staging: rtl8192e: remove two redundant assignments
    
    Clang detected two redundant assignments that can be safely removed.
    The first is the removal of the duplicated assignment to pointer 'hdr',
    this has already been initialized with the same value.  The second is
    the removal of the redundant initialization of variable 'timeout', this
    assigned value is never read and the variable is reassigned a new value
    a little later.
    
    Remove both redundant assignments, cleans up clang warnings:
    drivers/staging/rtl8192e/rtllib_rx.c:1305:27: warning: Value stored to
    'hdr' during its initialization is never read
    drivers/staging/rtl8192e/rtllib_softmac.c:1971:6: warning: Value stored
    to 'timeout' during its initialization is never read
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index c2b9ffba354a..919231fec09c 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -1968,7 +1968,7 @@ void rtllib_sta_ps_send_pspoll_frame(struct rtllib_device *ieee)
 
 static short rtllib_sta_ps_sleep(struct rtllib_device *ieee, u64 *time)
 {
-	int timeout = ieee->ps_timeout;
+	int timeout;
 	u8 dtim;
 	struct rt_pwr_save_ctrl *pPSC = &(ieee->PowerSaveControl);
 

commit 96bc1f2ae0171d1a24a5cedf6a0b0de8d1e8c406
Author: Kees Cook <keescook@chromium.org>
Date:   Mon Oct 16 16:24:50 2017 -0700

    staging: rtl8192e: Convert timers to use timer_setup()
    
    In preparation for unconditionally passing the struct timer_list pointer to
    all timer callbacks, switch to using the new timer_setup() and from_timer()
    to pass the timer pointer explicitly.
    
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Derek Robson <robsonde@gmail.com>
    Cc: Suniel Mahesh <suniel.spartan@gmail.com>
    Cc: Malcolm Priestley <tvboxspy@gmail.com>
    Cc: Gargi Sharma <gs051095@gmail.com>
    Cc: Julia Lawall <Julia.Lawall@lip6.fr>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Johannes Berg <johannes.berg@intel.com>
    Cc: Yamanappagouda Patil <goudapatilk@gmail.com>
    Cc: Georgiana Rodica Chelu <georgiana.chelu93@gmail.com>
    Cc: Colin Ian King <colin.king@canonical.com>
    Cc: Baoyou Xie <baoyou.xie@linaro.org>
    Cc: devel@driverdev.osuosl.org
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Derek Robson <robsonde@gmail.com>
    Cc: Suniel Mahesh <suniel.spartan@gmail.com>
    Cc: Malcolm Priestley <tvboxspy@gmail.com>
    Cc: Gargi Sharma <gs051095@gmail.com>
    Cc: Julia Lawall <Julia.Lawall@lip6.fr>
    Cc: Yamanappagouda Patil <goudapatilk@gmail.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Johannes Berg <johannes.berg@intel.com>
    Cc: Georgiana Rodica Chelu <georgiana.chelu93@gmail.com>
    Cc: Colin Ian King <colin.king@canonical.com>
    Cc: Baoyou Xie <baoyou.xie@linaro.org>
    Cc: devel@driverdev.osuosl.org
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 1e308dfd7f74..c2b9ffba354a 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -393,10 +393,10 @@ static void rtllib_send_beacon(struct rtllib_device *ieee)
 }
 
 
-static void rtllib_send_beacon_cb(unsigned long _ieee)
+static void rtllib_send_beacon_cb(struct timer_list *t)
 {
 	struct rtllib_device *ieee =
-		(struct rtllib_device *) _ieee;
+		from_timer(ieee, t, beacon_timer);
 	unsigned long flags;
 
 	spin_lock_irqsave(&ieee->beacon_lock, flags);
@@ -1427,9 +1427,11 @@ static void rtllib_associate_abort(struct rtllib_device *ieee)
 	spin_unlock_irqrestore(&ieee->lock, flags);
 }
 
-static void rtllib_associate_abort_cb(unsigned long dev)
+static void rtllib_associate_abort_cb(struct timer_list *t)
 {
-	rtllib_associate_abort((struct rtllib_device *) dev);
+	struct rtllib_device *dev = from_timer(dev, t, associate_timer);
+
+	rtllib_associate_abort(dev);
 }
 
 static void rtllib_associate_step1(struct rtllib_device *ieee, u8 *daddr)
@@ -3012,13 +3014,9 @@ void rtllib_softmac_init(struct rtllib_device *ieee)
 
 	ieee->tx_pending.txb = NULL;
 
-	setup_timer(&ieee->associate_timer,
-		    rtllib_associate_abort_cb,
-		    (unsigned long) ieee);
+	timer_setup(&ieee->associate_timer, rtllib_associate_abort_cb, 0);
 
-	setup_timer(&ieee->beacon_timer,
-		    rtllib_send_beacon_cb,
-		    (unsigned long) ieee);
+	timer_setup(&ieee->beacon_timer, rtllib_send_beacon_cb, 0);
 
 	INIT_DELAYED_WORK_RSL(&ieee->link_change_wq,
 			      (void *)rtllib_link_change_wq, ieee);

commit 1ce72e8ac57a999c2864249567fc313a0def60c9
Author: Colin Ian King <colin.king@canonical.com>
Date:   Fri Sep 22 16:20:18 2017 +0100

    staging: rtl8192e: make const array broadcast_addr static, reduces object code size
    
    Don't populate const array broadcast_addr on the stack, instead make it
    static. Makes the object code smaller by over 40 bytes:
    
    Before:
       text    data     bss     dec     hex filename
      63906    8248    1216   73370   11e9a rtllib_softmac.o
    
    After:
       text    data     bss     dec     hex filename
      63806    8304    1216   73326   11e6e rtllib_softmac.o
    
    (gcc 6.3.0, x86-64)
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index e4be85af31e7..1e308dfd7f74 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -2811,8 +2811,9 @@ static void rtllib_associate_retry_wq(void *data)
 
 static struct sk_buff *rtllib_get_beacon_(struct rtllib_device *ieee)
 {
-	const u8 broadcast_addr[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
-
+	static const u8 broadcast_addr[] = {
+		0xff, 0xff, 0xff, 0xff, 0xff, 0xff
+	};
 	struct sk_buff *skb;
 	struct rtllib_probe_response *b;
 

commit 5518b69b76680a4f2df96b1deca260059db0c2de
Merge: 8ad06e56dcbc 0e72582270c0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jul 5 12:31:59 2017 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net-next
    
    Pull networking updates from David Miller:
     "Reasonably busy this cycle, but perhaps not as busy as in the 4.12
      merge window:
    
       1) Several optimizations for UDP processing under high load from
          Paolo Abeni.
    
       2) Support pacing internally in TCP when using the sch_fq packet
          scheduler for this is not practical. From Eric Dumazet.
    
       3) Support mutliple filter chains per qdisc, from Jiri Pirko.
    
       4) Move to 1ms TCP timestamp clock, from Eric Dumazet.
    
       5) Add batch dequeueing to vhost_net, from Jason Wang.
    
       6) Flesh out more completely SCTP checksum offload support, from
          Davide Caratti.
    
       7) More plumbing of extended netlink ACKs, from David Ahern, Pablo
          Neira Ayuso, and Matthias Schiffer.
    
       8) Add devlink support to nfp driver, from Simon Horman.
    
       9) Add RTM_F_FIB_MATCH flag to RTM_GETROUTE queries, from Roopa
          Prabhu.
    
      10) Add stack depth tracking to BPF verifier and use this information
          in the various eBPF JITs. From Alexei Starovoitov.
    
      11) Support XDP on qed device VFs, from Yuval Mintz.
    
      12) Introduce BPF PROG ID for better introspection of installed BPF
          programs. From Martin KaFai Lau.
    
      13) Add bpf_set_hash helper for TC bpf programs, from Daniel Borkmann.
    
      14) For loads, allow narrower accesses in bpf verifier checking, from
          Yonghong Song.
    
      15) Support MIPS in the BPF selftests and samples infrastructure, the
          MIPS eBPF JIT will be merged in via the MIPS GIT tree. From David
          Daney.
    
      16) Support kernel based TLS, from Dave Watson and others.
    
      17) Remove completely DST garbage collection, from Wei Wang.
    
      18) Allow installing TCP MD5 rules using prefixes, from Ivan
          Delalande.
    
      19) Add XDP support to Intel i40e driver, from Björn Töpel
    
      20) Add support for TC flower offload in nfp driver, from Simon
          Horman, Pieter Jansen van Vuuren, Benjamin LaHaise, Jakub
          Kicinski, and Bert van Leeuwen.
    
      21) IPSEC offloading support in mlx5, from Ilan Tayari.
    
      22) Add HW PTP support to macb driver, from Rafal Ozieblo.
    
      23) Networking refcount_t conversions, From Elena Reshetova.
    
      24) Add sock_ops support to BPF, from Lawrence Brako. This is useful
          for tuning the TCP sockopt settings of a group of applications,
          currently via CGROUPs"
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/davem/net-next: (1899 commits)
      net: phy: dp83867: add workaround for incorrect RX_CTRL pin strap
      dt-bindings: phy: dp83867: provide a workaround for incorrect RX_CTRL pin strap
      cxgb4: Support for get_ts_info ethtool method
      cxgb4: Add PTP Hardware Clock (PHC) support
      cxgb4: time stamping interface for PTP
      nfp: default to chained metadata prepend format
      nfp: remove legacy MAC address lookup
      nfp: improve order of interfaces in breakout mode
      net: macb: remove extraneous return when MACB_EXT_DESC is defined
      bpf: add missing break in for the TCP_BPF_SNDCWND_CLAMP case
      bpf: fix return in load_bpf_file
      mpls: fix rtm policy in mpls_getroute
      net, ax25: convert ax25_cb.refcount from atomic_t to refcount_t
      net, ax25: convert ax25_route.refcount from atomic_t to refcount_t
      net, ax25: convert ax25_uid_assoc.refcount from atomic_t to refcount_t
      net, sctp: convert sctp_ep_common.refcnt from atomic_t to refcount_t
      net, sctp: convert sctp_transport.refcnt from atomic_t to refcount_t
      net, sctp: convert sctp_chunk.refcnt from atomic_t to refcount_t
      net, sctp: convert sctp_datamsg.refcnt from atomic_t to refcount_t
      net, sctp: convert sctp_auth_bytes.refcnt from atomic_t to refcount_t
      ...

commit 8ad33de53afedd064926c64f2ffa896c21e4bc28
Author: Colin Ian King <colin.king@canonical.com>
Date:   Tue Jun 27 15:23:26 2017 +0100

    staging: rtl8192e: fix spelling mistake: "respose" -> "response"
    
    Trivial fix to spelling mistake in netdev_info message and split
    line to clean up an checkpatch line too wide warning.
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index f629e99956b7..64b0034c9c37 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -2310,7 +2310,8 @@ static void rtllib_rx_auth_resp(struct rtllib_device *ieee, struct sk_buff *skb)
 	if (errcode) {
 		ieee->softmac_stats.rx_auth_rs_err++;
 		netdev_info(ieee->dev,
-			    "Authentication respose status code 0x%x", errcode);
+			    "Authentication response status code 0x%x",
+			    errcode);
 		rtllib_associate_abort(ieee);
 		return;
 	}

commit f0836fd2a683bafbf738672e429221e4e9a3d7a6
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Wed Jun 14 20:08:25 2017 +0100

    staging: rtl8192e: remove dead code rtllib_wpa_supplicant_ioctl
    
    Following removal of _rtl92e_ioctl this function along with associated
    macros, structure ieee_param and functions become dead code.
    
    Remove functions rtllib_wpa_enable, rtllib_wpa_assoc_frame, rtllib_wpa_mlme,
    rtllib_wpa_set_wpa_ie, rtllib_wpa_set_auth_algs, rtllib_wpa_set_param,
    rtllib_wpa_set_encryption and rtllib_wpa_supplicant_ioctl.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 776e99741431..f629e99956b7 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -3077,333 +3077,6 @@ void rtllib_softmac_free(struct rtllib_device *ieee)
 	tasklet_kill(&ieee->ps_task);
 }
 
-/********************************************************
- * Start of WPA code.				        *
- * this is stolen from the ipw2200 driver	        *
- ********************************************************/
-
-
-static int rtllib_wpa_enable(struct rtllib_device *ieee, int value)
-{
-	/* This is called when wpa_supplicant loads and closes the driver
-	 * interface.
-	 */
-	netdev_info(ieee->dev, "%s WPA\n", value ? "enabling" : "disabling");
-	ieee->wpa_enabled = value;
-	eth_zero_addr(ieee->ap_mac_addr);
-	return 0;
-}
-
-
-static void rtllib_wpa_assoc_frame(struct rtllib_device *ieee, char *wpa_ie,
-				   int wpa_ie_len)
-{
-	/* make sure WPA is enabled */
-	rtllib_wpa_enable(ieee, 1);
-
-	rtllib_disassociate(ieee);
-}
-
-
-static int rtllib_wpa_mlme(struct rtllib_device *ieee, int command, int reason)
-{
-
-	int ret = 0;
-
-	switch (command) {
-	case IEEE_MLME_STA_DEAUTH:
-		break;
-
-	case IEEE_MLME_STA_DISASSOC:
-		rtllib_disassociate(ieee);
-		break;
-
-	default:
-		netdev_info(ieee->dev, "Unknown MLME request: %d\n", command);
-		ret = -EOPNOTSUPP;
-	}
-
-	return ret;
-}
-
-
-static int rtllib_wpa_set_wpa_ie(struct rtllib_device *ieee,
-			      struct ieee_param *param, int plen)
-{
-	u8 *buf;
-
-	if (param->u.wpa_ie.len > MAX_WPA_IE_LEN ||
-	    (param->u.wpa_ie.len && param->u.wpa_ie.data == NULL))
-		return -EINVAL;
-
-	if (param->u.wpa_ie.len) {
-		buf = kmemdup(param->u.wpa_ie.data, param->u.wpa_ie.len,
-			      GFP_KERNEL);
-		if (buf == NULL)
-			return -ENOMEM;
-
-		kfree(ieee->wpa_ie);
-		ieee->wpa_ie = buf;
-		ieee->wpa_ie_len = param->u.wpa_ie.len;
-	} else {
-		kfree(ieee->wpa_ie);
-		ieee->wpa_ie = NULL;
-		ieee->wpa_ie_len = 0;
-	}
-
-	rtllib_wpa_assoc_frame(ieee, ieee->wpa_ie, ieee->wpa_ie_len);
-	return 0;
-}
-
-#define AUTH_ALG_OPEN_SYSTEM			0x1
-#define AUTH_ALG_SHARED_KEY			0x2
-#define AUTH_ALG_LEAP				0x4
-static int rtllib_wpa_set_auth_algs(struct rtllib_device *ieee, int value)
-{
-
-	struct rtllib_security sec = {
-		.flags = SEC_AUTH_MODE,
-	};
-
-	if (value & AUTH_ALG_SHARED_KEY) {
-		sec.auth_mode = WLAN_AUTH_SHARED_KEY;
-		ieee->open_wep = 0;
-		ieee->auth_mode = 1;
-	} else if (value & AUTH_ALG_OPEN_SYSTEM) {
-		sec.auth_mode = WLAN_AUTH_OPEN;
-		ieee->open_wep = 1;
-		ieee->auth_mode = 0;
-	} else if (value & AUTH_ALG_LEAP) {
-		sec.auth_mode = WLAN_AUTH_LEAP  >> 6;
-		ieee->open_wep = 1;
-		ieee->auth_mode = 2;
-	}
-
-
-	if (ieee->set_security)
-		ieee->set_security(ieee->dev, &sec);
-
-	return 0;
-}
-
-static int rtllib_wpa_set_param(struct rtllib_device *ieee, u8 name, u32 value)
-{
-	int ret = 0;
-	unsigned long flags;
-
-	switch (name) {
-	case IEEE_PARAM_WPA_ENABLED:
-		ret = rtllib_wpa_enable(ieee, value);
-		break;
-
-	case IEEE_PARAM_TKIP_COUNTERMEASURES:
-		ieee->tkip_countermeasures = value;
-		break;
-
-	case IEEE_PARAM_DROP_UNENCRYPTED:
-	{
-		/* HACK:
-		 *
-		 * wpa_supplicant calls set_wpa_enabled when the driver
-		 * is loaded and unloaded, regardless of if WPA is being
-		 * used.  No other calls are made which can be used to
-		 * determine if encryption will be used or not prior to
-		 * association being expected.  If encryption is not being
-		 * used, drop_unencrypted is set to false, else true -- we
-		 * can use this to determine if the CAP_PRIVACY_ON bit should
-		 * be set.
-		 */
-		struct rtllib_security sec = {
-			.flags = SEC_ENABLED,
-			.enabled = value,
-		};
-		ieee->drop_unencrypted = value;
-		/* We only change SEC_LEVEL for open mode. Others
-		 * are set by ipw_wpa_set_encryption.
-		 */
-		if (!value) {
-			sec.flags |= SEC_LEVEL;
-			sec.level = SEC_LEVEL_0;
-		} else {
-			sec.flags |= SEC_LEVEL;
-			sec.level = SEC_LEVEL_1;
-		}
-		if (ieee->set_security)
-			ieee->set_security(ieee->dev, &sec);
-		break;
-	}
-
-	case IEEE_PARAM_PRIVACY_INVOKED:
-		ieee->privacy_invoked = value;
-		break;
-
-	case IEEE_PARAM_AUTH_ALGS:
-		ret = rtllib_wpa_set_auth_algs(ieee, value);
-		break;
-
-	case IEEE_PARAM_IEEE_802_1X:
-		ieee->ieee802_1x = value;
-		break;
-	case IEEE_PARAM_WPAX_SELECT:
-		spin_lock_irqsave(&ieee->wpax_suitlist_lock, flags);
-		spin_unlock_irqrestore(&ieee->wpax_suitlist_lock, flags);
-		break;
-
-	default:
-		netdev_info(ieee->dev, "Unknown WPA param: %d\n", name);
-		ret = -EOPNOTSUPP;
-	}
-
-	return ret;
-}
-
-/* implementation borrowed from hostap driver */
-static int rtllib_wpa_set_encryption(struct rtllib_device *ieee,
-				  struct ieee_param *param, int param_len,
-				  u8 is_mesh)
-{
-	int ret = 0;
-	struct lib80211_crypto_ops *ops;
-	struct lib80211_crypt_data **crypt;
-
-	struct rtllib_security sec = {
-		.flags = 0,
-	};
-
-	param->u.crypt.err = 0;
-	param->u.crypt.alg[IEEE_CRYPT_ALG_NAME_LEN - 1] = '\0';
-
-	if (param_len !=
-	    (int) ((char *) param->u.crypt.key - (char *) param) +
-	    param->u.crypt.key_len) {
-		netdev_info(ieee->dev, "Len mismatch %d, %d\n", param_len,
-			    param->u.crypt.key_len);
-		return -EINVAL;
-	}
-	if (is_broadcast_ether_addr(param->sta_addr)) {
-		if (param->u.crypt.idx >= NUM_WEP_KEYS)
-			return -EINVAL;
-		crypt = &ieee->crypt_info.crypt[param->u.crypt.idx];
-	} else {
-		return -EINVAL;
-	}
-
-	if (strcmp(param->u.crypt.alg, "none") == 0) {
-		if (crypt) {
-			sec.enabled = 0;
-			sec.level = SEC_LEVEL_0;
-			sec.flags |= SEC_ENABLED | SEC_LEVEL;
-			lib80211_crypt_delayed_deinit(&ieee->crypt_info, crypt);
-		}
-		goto done;
-	}
-	sec.enabled = 1;
-	sec.flags |= SEC_ENABLED;
-
-	/* IPW HW cannot build TKIP MIC, host decryption still needed. */
-	if (!(ieee->host_encrypt || ieee->host_decrypt) &&
-	    strcmp(param->u.crypt.alg, "R-TKIP"))
-		goto skip_host_crypt;
-
-	ops = lib80211_get_crypto_ops(param->u.crypt.alg);
-	if (ops == NULL && strcmp(param->u.crypt.alg, "R-WEP") == 0) {
-		request_module("rtllib_crypt_wep");
-		ops = lib80211_get_crypto_ops(param->u.crypt.alg);
-	} else if (ops == NULL && strcmp(param->u.crypt.alg, "R-TKIP") == 0) {
-		request_module("rtllib_crypt_tkip");
-		ops = lib80211_get_crypto_ops(param->u.crypt.alg);
-	} else if (ops == NULL && strcmp(param->u.crypt.alg, "R-CCMP") == 0) {
-		request_module("rtllib_crypt_ccmp");
-		ops = lib80211_get_crypto_ops(param->u.crypt.alg);
-	}
-	if (ops == NULL) {
-		netdev_info(ieee->dev, "unknown crypto alg '%s'\n",
-			    param->u.crypt.alg);
-		param->u.crypt.err = IEEE_CRYPT_ERR_UNKNOWN_ALG;
-		ret = -EINVAL;
-		goto done;
-	}
-	if (*crypt == NULL || (*crypt)->ops != ops) {
-		struct lib80211_crypt_data *new_crypt;
-
-		lib80211_crypt_delayed_deinit(&ieee->crypt_info, crypt);
-
-		new_crypt = kzalloc(sizeof(*new_crypt), GFP_KERNEL);
-		if (new_crypt == NULL) {
-			ret = -ENOMEM;
-			goto done;
-		}
-		new_crypt->ops = ops;
-		if (new_crypt->ops && try_module_get(new_crypt->ops->owner))
-			new_crypt->priv =
-				new_crypt->ops->init(param->u.crypt.idx);
-
-		if (new_crypt->priv == NULL) {
-			kfree(new_crypt);
-			param->u.crypt.err = IEEE_CRYPT_ERR_CRYPT_INIT_FAILED;
-			ret = -EINVAL;
-			goto done;
-		}
-
-		*crypt = new_crypt;
-	}
-
-	if (param->u.crypt.key_len > 0 && (*crypt)->ops->set_key &&
-	    (*crypt)->ops->set_key(param->u.crypt.key,
-	    param->u.crypt.key_len, param->u.crypt.seq,
-	    (*crypt)->priv) < 0) {
-		netdev_info(ieee->dev, "key setting failed\n");
-		param->u.crypt.err = IEEE_CRYPT_ERR_KEY_SET_FAILED;
-		ret = -EINVAL;
-		goto done;
-	}
-
- skip_host_crypt:
-	if (param->u.crypt.set_tx) {
-		ieee->crypt_info.tx_keyidx = param->u.crypt.idx;
-		sec.active_key = param->u.crypt.idx;
-		sec.flags |= SEC_ACTIVE_KEY;
-	} else
-		sec.flags &= ~SEC_ACTIVE_KEY;
-
-	memcpy(sec.keys[param->u.crypt.idx],
-	       param->u.crypt.key,
-	       param->u.crypt.key_len);
-	sec.key_sizes[param->u.crypt.idx] = param->u.crypt.key_len;
-	sec.flags |= (1 << param->u.crypt.idx);
-
-	if (strcmp(param->u.crypt.alg, "R-WEP") == 0) {
-		sec.flags |= SEC_LEVEL;
-		sec.level = SEC_LEVEL_1;
-	} else if (strcmp(param->u.crypt.alg, "R-TKIP") == 0) {
-		sec.flags |= SEC_LEVEL;
-		sec.level = SEC_LEVEL_2;
-	} else if (strcmp(param->u.crypt.alg, "R-CCMP") == 0) {
-		sec.flags |= SEC_LEVEL;
-		sec.level = SEC_LEVEL_3;
-	}
- done:
-	if (ieee->set_security)
-		ieee->set_security(ieee->dev, &sec);
-
-	/* Do not reset port if card is in Managed mode since resetting will
-	 * generate new IEEE 802.11 authentication which may end up in looping
-	 * with IEEE 802.1X.  If your hardware requires a reset after WEP
-	 * configuration (for example... Prism2), implement the reset_port in
-	 * the callbacks structures used to initialize the 802.11 stack.
-	 */
-	if (ieee->reset_on_keychange &&
-	    ieee->iw_mode != IW_MODE_INFRA &&
-	    ieee->reset_port &&
-	    ieee->reset_port(ieee->dev)) {
-		netdev_info(ieee->dev, "reset_port failed\n");
-		param->u.crypt.err = IEEE_CRYPT_ERR_CARD_CONF_FAILED;
-		return -EINVAL;
-	}
-
-	return ret;
-}
-
 static inline struct sk_buff *
 rtllib_disauth_skb(struct rtllib_network *beacon,
 		   struct rtllib_device *ieee, u16 asRsn)
@@ -3502,62 +3175,6 @@ u8 rtllib_ap_sec_type(struct rtllib_device *ieee)
 	}
 }
 
-int rtllib_wpa_supplicant_ioctl(struct rtllib_device *ieee, struct iw_point *p,
-				u8 is_mesh)
-{
-	struct ieee_param *param;
-	int ret = 0;
-
-	mutex_lock(&ieee->wx_mutex);
-
-	if (p->length < sizeof(struct ieee_param) || !p->pointer) {
-		ret = -EINVAL;
-		goto out;
-	}
-
-	param = memdup_user(p->pointer, p->length);
-	if (IS_ERR(param)) {
-		ret = PTR_ERR(param);
-		goto out;
-	}
-
-	switch (param->cmd) {
-	case IEEE_CMD_SET_WPA_PARAM:
-		ret = rtllib_wpa_set_param(ieee, param->u.wpa_param.name,
-					param->u.wpa_param.value);
-		break;
-
-	case IEEE_CMD_SET_WPA_IE:
-		ret = rtllib_wpa_set_wpa_ie(ieee, param, p->length);
-		break;
-
-	case IEEE_CMD_SET_ENCRYPTION:
-		ret = rtllib_wpa_set_encryption(ieee, param, p->length, 0);
-		break;
-
-	case IEEE_CMD_MLME:
-		ret = rtllib_wpa_mlme(ieee, param->u.mlme.command,
-				   param->u.mlme.reason_code);
-		break;
-
-	default:
-		netdev_info(ieee->dev, "Unknown WPA supplicant request: %d\n",
-			    param->cmd);
-		ret = -EOPNOTSUPP;
-		break;
-	}
-
-	if (ret == 0 && copy_to_user(p->pointer, param, p->length))
-		ret = -EFAULT;
-
-	kfree(param);
-out:
-	mutex_unlock(&ieee->wx_mutex);
-
-	return ret;
-}
-EXPORT_SYMBOL(rtllib_wpa_supplicant_ioctl);
-
 static void rtllib_MgntDisconnectIBSS(struct rtllib_device *rtllib)
 {
 	u8	OpMode;

commit b952f4dff2751252db073c27c0f8a16a416a2ddc
Author: yuan linyu <Linyu.Yuan@alcatel-sbell.com.cn>
Date:   Sun Jun 18 22:52:04 2017 +0800

    net: manual clean code which call skb_put_[data:zero]
    
    Signed-off-by: yuan linyu <Linyu.Yuan@alcatel-sbell.com.cn>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 5f2751d4d464..09d2c8649171 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -1264,7 +1264,7 @@ rtllib_association_req(struct rtllib_network *beacon,
 	hdr->info_element[0].id = MFIE_TYPE_SSID;
 
 	hdr->info_element[0].len = beacon->ssid_len;
-	tag = skb_put_data(skb, beacon->ssid, beacon->ssid_len);
+	skb_put_data(skb, beacon->ssid, beacon->ssid_len);
 
 	tag = skb_put(skb, rate_len);
 
@@ -1340,7 +1340,7 @@ rtllib_association_req(struct rtllib_network *beacon,
 	}
 
 	if (wpa_ie_len) {
-		tag = skb_put_data(skb, ieee->wpa_ie, ieee->wpa_ie_len);
+		skb_put_data(skb, ieee->wpa_ie, ieee->wpa_ie_len);
 
 		if (PMKCacheIdx >= 0) {
 			tag = skb_put(skb, 18);
@@ -1356,12 +1356,13 @@ rtllib_association_req(struct rtllib_network *beacon,
 	}
 
 	if (wps_ie_len && ieee->wps_ie) {
-		tag = skb_put_data(skb, ieee->wps_ie, wps_ie_len);
+		skb_put_data(skb, ieee->wps_ie, wps_ie_len);
 	}
 
-	tag = skb_put(skb, turbo_info_len);
-	if (turbo_info_len)
+	if (turbo_info_len) {
+		tag = skb_put(skb, turbo_info_len);
 		rtllib_TURBO_Info(ieee, &tag);
+	}
 
 	if (ieee->pHTInfo->bCurrentHTSupport && ieee->pHTInfo->bEnableHT) {
 		if (ieee->pHTInfo->ePeerHTSpecVer == HT_SPEC_VER_EWC) {

commit 4df864c1d9afb46e2461a9f808d9f11a42d31bad
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Fri Jun 16 14:29:21 2017 +0200

    networking: make skb_put & friends return void pointers
    
    It seems like a historic accident that these return unsigned char *,
    and in many places that means casts are required, more often than not.
    
    Make these functions (skb_put, __skb_put and pskb_put) return void *
    and remove all the casts across the tree, adding a (u8 *) cast only
    where the unsigned char pointer was used directly, all done with the
    following spatch:
    
        @@
        expression SKB, LEN;
        typedef u8;
        identifier fn = { skb_put, __skb_put };
        @@
        - *(fn(SKB, LEN))
        + *(u8 *)fn(SKB, LEN)
    
        @@
        expression E, SKB, LEN;
        identifier fn = { skb_put, __skb_put };
        type T;
        @@
        - E = ((T *)(fn(SKB, LEN)))
        + E = fn(SKB, LEN)
    
    which actually doesn't cover pskb_put since there are only three
    users overall.
    
    A handful of stragglers were converted manually, notably a macro in
    drivers/isdn/i4l/isdn_bsdcomp.c and, oddly enough, one of the many
    instances in net/bluetooth/hci_sock.c. In the former file, I also
    had to fix one whitespace problem spatch introduced.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 60d07d0bb4eb..5f2751d4d464 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -351,8 +351,7 @@ static inline struct sk_buff *rtllib_probe_req(struct rtllib_device *ieee)
 
 	skb_reserve(skb, ieee->tx_headroom);
 
-	req = (struct rtllib_probe_request *) skb_put(skb,
-	      sizeof(struct rtllib_probe_request));
+	req = skb_put(skb, sizeof(struct rtllib_probe_request));
 	req->header.frame_ctl = cpu_to_le16(RTLLIB_STYPE_PROBE_REQ);
 	req->header.duration_id = 0;
 
@@ -360,7 +359,7 @@ static inline struct sk_buff *rtllib_probe_req(struct rtllib_device *ieee)
 	ether_addr_copy(req->header.addr2, ieee->dev->dev_addr);
 	eth_broadcast_addr(req->header.addr3);
 
-	tag = (u8 *) skb_put(skb, len + 2 + rate_len);
+	tag = skb_put(skb, len + 2 + rate_len);
 
 	*tag++ = MFIE_TYPE_SSID;
 	*tag++ = len;
@@ -789,8 +788,7 @@ rtllib_authentication_req(struct rtllib_network *beacon,
 
 	skb_reserve(skb, ieee->tx_headroom);
 
-	auth = (struct rtllib_authentication *)
-		skb_put(skb, sizeof(struct rtllib_authentication));
+	auth = skb_put(skb, sizeof(struct rtllib_authentication));
 
 	auth->header.frame_ctl = cpu_to_le16(RTLLIB_STYPE_AUTH);
 	if (challengelen)
@@ -889,8 +887,7 @@ static struct sk_buff *rtllib_probe_resp(struct rtllib_device *ieee,
 
 	skb_reserve(skb, ieee->tx_headroom);
 
-	beacon_buf = (struct rtllib_probe_response *) skb_put(skb,
-		     (beacon_size - ieee->tx_headroom));
+	beacon_buf = skb_put(skb, (beacon_size - ieee->tx_headroom));
 	ether_addr_copy(beacon_buf->header.addr1, dest);
 	ether_addr_copy(beacon_buf->header.addr2, ieee->dev->dev_addr);
 	ether_addr_copy(beacon_buf->header.addr3, ieee->current_network.bssid);
@@ -984,8 +981,7 @@ static struct sk_buff *rtllib_assoc_resp(struct rtllib_device *ieee, u8 *dest)
 
 	skb_reserve(skb, ieee->tx_headroom);
 
-	assoc = (struct rtllib_assoc_response_frame *)
-		skb_put(skb, sizeof(struct rtllib_assoc_response_frame));
+	assoc = skb_put(skb, sizeof(struct rtllib_assoc_response_frame));
 
 	assoc->header.frame_ctl = cpu_to_le16(RTLLIB_STYPE_ASSOC_RESP);
 	ether_addr_copy(assoc->header.addr1, dest);
@@ -1016,7 +1012,7 @@ static struct sk_buff *rtllib_assoc_resp(struct rtllib_device *ieee, u8 *dest)
 	else
 		ieee->assoc_id++;
 
-	tag = (u8 *) skb_put(skb, rate_len);
+	tag = skb_put(skb, rate_len);
 	rtllib_MFIE_Brate(ieee, &tag);
 	rtllib_MFIE_Grate(ieee, &tag);
 
@@ -1038,8 +1034,7 @@ static struct sk_buff *rtllib_auth_resp(struct rtllib_device *ieee, int status,
 
 	skb_reserve(skb, ieee->tx_headroom);
 
-	auth = (struct rtllib_authentication *)
-		skb_put(skb, sizeof(struct rtllib_authentication));
+	auth = skb_put(skb, sizeof(struct rtllib_authentication));
 
 	auth->status = cpu_to_le16(status);
 	auth->transaction = cpu_to_le16(2);
@@ -1065,8 +1060,7 @@ static struct sk_buff *rtllib_null_func(struct rtllib_device *ieee, short pwr)
 
 	skb_reserve(skb, ieee->tx_headroom);
 
-	hdr = (struct rtllib_hdr_3addr *)skb_put(skb,
-	      sizeof(struct rtllib_hdr_3addr));
+	hdr = skb_put(skb, sizeof(struct rtllib_hdr_3addr));
 
 	ether_addr_copy(hdr->addr1, ieee->current_network.bssid);
 	ether_addr_copy(hdr->addr2, ieee->dev->dev_addr);
@@ -1092,8 +1086,7 @@ static struct sk_buff *rtllib_pspoll_func(struct rtllib_device *ieee)
 
 	skb_reserve(skb, ieee->tx_headroom);
 
-	hdr = (struct rtllib_pspoll_hdr *)skb_put(skb,
-	      sizeof(struct rtllib_pspoll_hdr));
+	hdr = skb_put(skb, sizeof(struct rtllib_pspoll_hdr));
 
 	ether_addr_copy(hdr->bssid, ieee->current_network.bssid);
 	ether_addr_copy(hdr->ta, ieee->dev->dev_addr);
@@ -1243,8 +1236,7 @@ rtllib_association_req(struct rtllib_network *beacon,
 
 	skb_reserve(skb, ieee->tx_headroom);
 
-	hdr = (struct rtllib_assoc_request_frame *)
-		skb_put(skb, sizeof(struct rtllib_assoc_request_frame) + 2);
+	hdr = skb_put(skb, sizeof(struct rtllib_assoc_request_frame) + 2);
 
 
 	hdr->header.frame_ctl = cpu_to_le16(RTLLIB_STYPE_ASSOC_REQ);
@@ -3414,8 +3406,7 @@ rtllib_disauth_skb(struct rtllib_network *beacon,
 
 	skb_reserve(skb, ieee->tx_headroom);
 
-	disauth = (struct rtllib_disauth *) skb_put(skb,
-		  sizeof(struct rtllib_disauth));
+	disauth = skb_put(skb, sizeof(struct rtllib_disauth));
 	disauth->header.frame_ctl = cpu_to_le16(RTLLIB_STYPE_DEAUTH);
 	disauth->header.duration_id = 0;
 
@@ -3442,8 +3433,7 @@ rtllib_disassociate_skb(struct rtllib_network *beacon,
 
 	skb_reserve(skb, ieee->tx_headroom);
 
-	disass = (struct rtllib_disassoc *) skb_put(skb,
-					 sizeof(struct rtllib_disassoc));
+	disass = skb_put(skb, sizeof(struct rtllib_disassoc));
 	disass->header.frame_ctl = cpu_to_le16(RTLLIB_STYPE_DISASSOC);
 	disass->header.duration_id = 0;
 

commit 59ae1d127ac0ae404baf414c434ba2651b793f46
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Fri Jun 16 14:29:20 2017 +0200

    networking: introduce and use skb_put_data()
    
    A common pattern with skb_put() is to just want to memcpy()
    some data into the new space, introduce skb_put_data() for
    this.
    
    An spatch similar to the one for skb_put_zero() converts many
    of the places using it:
    
        @@
        identifier p, p2;
        expression len, skb, data;
        type t, t2;
        @@
        (
        -p = skb_put(skb, len);
        +p = skb_put_data(skb, data, len);
        |
        -p = (t)skb_put(skb, len);
        +p = skb_put_data(skb, data, len);
        )
        (
        p2 = (t2)p;
        -memcpy(p2, data, len);
        |
        -memcpy(p, data, len);
        )
    
        @@
        type t, t2;
        identifier p, p2;
        expression skb, data;
        @@
        t *p;
        ...
        (
        -p = skb_put(skb, sizeof(t));
        +p = skb_put_data(skb, data, sizeof(t));
        |
        -p = (t *)skb_put(skb, sizeof(t));
        +p = skb_put_data(skb, data, sizeof(t));
        )
        (
        p2 = (t2)p;
        -memcpy(p2, data, sizeof(*p));
        |
        -memcpy(p, data, sizeof(*p));
        )
    
        @@
        expression skb, len, data;
        @@
        -memcpy(skb_put(skb, len), data, len);
        +skb_put_data(skb, data, len);
    
    (again, manually post-processed to retain some comments)
    
    Reviewed-by: Stephen Hemminger <stephen@networkplumber.org>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index eeda17d6409b..60d07d0bb4eb 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -1272,8 +1272,7 @@ rtllib_association_req(struct rtllib_network *beacon,
 	hdr->info_element[0].id = MFIE_TYPE_SSID;
 
 	hdr->info_element[0].len = beacon->ssid_len;
-	tag = skb_put(skb, beacon->ssid_len);
-	memcpy(tag, beacon->ssid, beacon->ssid_len);
+	tag = skb_put_data(skb, beacon->ssid, beacon->ssid_len);
 
 	tag = skb_put(skb, rate_len);
 
@@ -1349,8 +1348,7 @@ rtllib_association_req(struct rtllib_network *beacon,
 	}
 
 	if (wpa_ie_len) {
-		tag = skb_put(skb, ieee->wpa_ie_len);
-		memcpy(tag, ieee->wpa_ie, ieee->wpa_ie_len);
+		tag = skb_put_data(skb, ieee->wpa_ie, ieee->wpa_ie_len);
 
 		if (PMKCacheIdx >= 0) {
 			tag = skb_put(skb, 18);
@@ -1366,8 +1364,7 @@ rtllib_association_req(struct rtllib_network *beacon,
 	}
 
 	if (wps_ie_len && ieee->wps_ie) {
-		tag = skb_put(skb, wps_ie_len);
-		memcpy(tag, ieee->wps_ie, wps_ie_len);
+		tag = skb_put_data(skb, ieee->wps_ie, wps_ie_len);
 	}
 
 	tag = skb_put(skb, turbo_info_len);

commit 95b80b30e1734946ab2e0412dce9c28079340d67
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sat May 13 17:41:20 2017 +0100

    staging: rtl8192e: Let user know mac address associated with.
    
    User cannot tell which mac address(BSIDD) associated with so add
    this to info message.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index eeda17d6409b..776e99741431 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -1525,7 +1525,8 @@ static void rtllib_associate_complete_wq(void *data)
 				     associate_complete_wq);
 	struct rt_pwr_save_ctrl *pPSC = &(ieee->PowerSaveControl);
 
-	netdev_info(ieee->dev, "Associated successfully\n");
+	netdev_info(ieee->dev, "Associated successfully with %pM\n",
+		    ieee->current_network.bssid);
 	if (!ieee->is_silent_reset) {
 		netdev_info(ieee->dev, "normal associate\n");
 		notify_wx_assoc_event(ieee);

commit 1393f1bc112d05b7229ca0667b66cad95d21b30c
Author: Colin Ian King <colin.king@canonical.com>
Date:   Thu Feb 9 11:37:54 2017 +0000

    Staging: rtl8192e: remove redundant null check on array alg
    
    u.crypt.alg is an array of u8 integers and hence the null check on
    this array is redundant and can be removed.
    
    Detected with CoverityScan, CID#146583 ("Array compared against 0")
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 1430ba27b049..eeda17d6409b 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -3365,23 +3365,21 @@ static int rtllib_wpa_set_encryption(struct rtllib_device *ieee,
 	} else
 		sec.flags &= ~SEC_ACTIVE_KEY;
 
-	if (param->u.crypt.alg != NULL) {
-		memcpy(sec.keys[param->u.crypt.idx],
-		       param->u.crypt.key,
-		       param->u.crypt.key_len);
-		sec.key_sizes[param->u.crypt.idx] = param->u.crypt.key_len;
-		sec.flags |= (1 << param->u.crypt.idx);
-
-		if (strcmp(param->u.crypt.alg, "R-WEP") == 0) {
-			sec.flags |= SEC_LEVEL;
-			sec.level = SEC_LEVEL_1;
-		} else if (strcmp(param->u.crypt.alg, "R-TKIP") == 0) {
-			sec.flags |= SEC_LEVEL;
-			sec.level = SEC_LEVEL_2;
-		} else if (strcmp(param->u.crypt.alg, "R-CCMP") == 0) {
-			sec.flags |= SEC_LEVEL;
-			sec.level = SEC_LEVEL_3;
-		}
+	memcpy(sec.keys[param->u.crypt.idx],
+	       param->u.crypt.key,
+	       param->u.crypt.key_len);
+	sec.key_sizes[param->u.crypt.idx] = param->u.crypt.key_len;
+	sec.flags |= (1 << param->u.crypt.idx);
+
+	if (strcmp(param->u.crypt.alg, "R-WEP") == 0) {
+		sec.flags |= SEC_LEVEL;
+		sec.level = SEC_LEVEL_1;
+	} else if (strcmp(param->u.crypt.alg, "R-TKIP") == 0) {
+		sec.flags |= SEC_LEVEL;
+		sec.level = SEC_LEVEL_2;
+	} else if (strcmp(param->u.crypt.alg, "R-CCMP") == 0) {
+		sec.flags |= SEC_LEVEL;
+		sec.level = SEC_LEVEL_3;
 	}
  done:
 	if (ieee->set_security)

commit 29f22246477e4a754a198eb842271c83bda7a93c
Author: Yamanappagouda Patil <goudapatilk@gmail.com>
Date:   Tue Nov 15 14:10:47 2016 +0530

    staging: rtl8192e: Added new line after declaration
    
    Fixed checkpatch.pl "Missing a blank line after declarations" warnings.
    
    Signed-off-by: Yamanappagouda Patil <goudapatilk@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index da74dc49b95e..1430ba27b049 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -1524,6 +1524,7 @@ static void rtllib_associate_complete_wq(void *data)
 				     struct rtllib_device,
 				     associate_complete_wq);
 	struct rt_pwr_save_ctrl *pPSC = &(ieee->PowerSaveControl);
+
 	netdev_info(ieee->dev, "Associated successfully\n");
 	if (!ieee->is_silent_reset) {
 		netdev_info(ieee->dev, "normal associate\n");

commit ec65ef8e8aa15126970a85348359a43a4c5c301a
Author: Baoyou Xie <baoyou.xie@linaro.org>
Date:   Sun Sep 4 14:33:35 2016 +0800

    Staging: rtl8192e: mark symbols static where possible
    
    We get a few warnings when building kernel with W=1:
    drivers/staging/rtl8192e/rtllib_softmac.c:279:13: warning: no previous declaration for 'softmac_ps_mgmt_xmit' [-Wmissing-declarations]
    drivers/staging/rtl8192e/rtllib_softmac.c:773:24: warning: no previous declaration for 'rtllib_authentication_req' [-Wmissing-declarations]
    ....
    
    In fact, these functions are only used in the file in which they are
    declared and don't need a declaration, but can be made static.
    
    In addition, some of these functions are declared in different files,
    it looks like that we need to clean the codes of this driver up,
    but we can repress these warnings first, then clean it up.
    
    so this patch marks these functions with 'static' now.
    
    Signed-off-by: Baoyou Xie <baoyou.xie@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index e84ffc825752..da74dc49b95e 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -276,8 +276,9 @@ inline void softmac_mgmt_xmit(struct sk_buff *skb, struct rtllib_device *ieee)
 	}
 }
 
-inline void softmac_ps_mgmt_xmit(struct sk_buff *skb,
-		struct rtllib_device *ieee)
+static inline void
+softmac_ps_mgmt_xmit(struct sk_buff *skb,
+		     struct rtllib_device *ieee)
 {
 	short single = ieee->softmac_features & IEEE_SOFTMAC_SINGLE_QUEUE;
 	struct rtllib_hdr_3addr  *header =
@@ -770,8 +771,10 @@ void rtllib_start_scan_syncro(struct rtllib_device *ieee, u8 is_mesh)
 }
 EXPORT_SYMBOL(rtllib_start_scan_syncro);
 
-inline struct sk_buff *rtllib_authentication_req(struct rtllib_network *beacon,
-	struct rtllib_device *ieee, int challengelen, u8 *daddr)
+static inline struct sk_buff *
+rtllib_authentication_req(struct rtllib_network *beacon,
+			  struct rtllib_device *ieee,
+			  int challengelen, u8 *daddr)
 {
 	struct sk_buff *skb;
 	struct rtllib_authentication *auth;
@@ -1130,7 +1133,7 @@ static void rtllib_resp_to_probe(struct rtllib_device *ieee, u8 *dest)
 }
 
 
-inline int SecIsInPMKIDList(struct rtllib_device *ieee, u8 *bssid)
+static inline int SecIsInPMKIDList(struct rtllib_device *ieee, u8 *bssid)
 {
 	int i = 0;
 
@@ -1146,8 +1149,9 @@ inline int SecIsInPMKIDList(struct rtllib_device *ieee, u8 *bssid)
 	return i;
 }
 
-inline struct sk_buff *rtllib_association_req(struct rtllib_network *beacon,
-					      struct rtllib_device *ieee)
+static inline struct sk_buff *
+rtllib_association_req(struct rtllib_network *beacon,
+		       struct rtllib_device *ieee)
 {
 	struct sk_buff *skb;
 	struct rtllib_assoc_request_frame *hdr;
@@ -2209,8 +2213,9 @@ static void rtllib_process_action(struct rtllib_device *ieee,
 	}
 }
 
-inline int rtllib_rx_assoc_resp(struct rtllib_device *ieee, struct sk_buff *skb,
-				struct rtllib_rx_stats *rx_stats)
+static inline int
+rtllib_rx_assoc_resp(struct rtllib_device *ieee, struct sk_buff *skb,
+		     struct rtllib_rx_stats *rx_stats)
 {
 	u16 errcode;
 	int aid;
@@ -2344,8 +2349,9 @@ static void rtllib_rx_auth_resp(struct rtllib_device *ieee, struct sk_buff *skb)
 	}
 }
 
-inline int rtllib_rx_auth(struct rtllib_device *ieee, struct sk_buff *skb,
-			  struct rtllib_rx_stats *rx_stats)
+static inline int
+rtllib_rx_auth(struct rtllib_device *ieee, struct sk_buff *skb,
+	       struct rtllib_rx_stats *rx_stats)
 {
 
 	if (ieee->softmac_features & IEEE_SOFTMAC_ASSOCIATE) {
@@ -2361,7 +2367,8 @@ inline int rtllib_rx_auth(struct rtllib_device *ieee, struct sk_buff *skb,
 	return 0;
 }
 
-inline int rtllib_rx_deauth(struct rtllib_device *ieee, struct sk_buff *skb)
+static inline int
+rtllib_rx_deauth(struct rtllib_device *ieee, struct sk_buff *skb)
 {
 	struct rtllib_hdr_3addr *header = (struct rtllib_hdr_3addr *) skb->data;
 	u16 frame_ctl;
@@ -3397,8 +3404,9 @@ static int rtllib_wpa_set_encryption(struct rtllib_device *ieee,
 	return ret;
 }
 
-inline struct sk_buff *rtllib_disauth_skb(struct rtllib_network *beacon,
-		struct rtllib_device *ieee, u16 asRsn)
+static inline struct sk_buff *
+rtllib_disauth_skb(struct rtllib_network *beacon,
+		   struct rtllib_device *ieee, u16 asRsn)
 {
 	struct sk_buff *skb;
 	struct rtllib_disauth *disauth;
@@ -3423,8 +3431,9 @@ inline struct sk_buff *rtllib_disauth_skb(struct rtllib_network *beacon,
 	return skb;
 }
 
-inline struct sk_buff *rtllib_disassociate_skb(struct rtllib_network *beacon,
-		struct rtllib_device *ieee, u16 asRsn)
+static inline struct sk_buff *
+rtllib_disassociate_skb(struct rtllib_network *beacon,
+			struct rtllib_device *ieee, u16 asRsn)
 {
 	struct sk_buff *skb;
 	struct rtllib_disassoc *disass;

commit 38bee763bd6d1f77ca3d10639e9bb3f1a1a53443
Author: Binoy Jayan <binoy.jayan@linaro.org>
Date:   Wed Jun 1 14:56:56 2016 +0530

    rtl8192e: Replace semaphore ips_sem with mutex
    
    The semaphore 'ips_sem' in the rtl8192e is a simple mutex, so it should
    be written as one. Semaphores are going away in the future.
    
    Signed-off-by: Binoy Jayan <binoy.jayan@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 858eae20a53f..e84ffc825752 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -3036,7 +3036,7 @@ void rtllib_softmac_init(struct rtllib_device *ieee)
 
 	mutex_init(&ieee->wx_mutex);
 	mutex_init(&ieee->scan_mutex);
-	sema_init(&ieee->ips_sem, 1);
+	mutex_init(&ieee->ips_mutex);
 
 	spin_lock_init(&ieee->mgmt_tx_lock);
 	spin_lock_init(&ieee->beacon_lock);

commit be10ceea4f0920975df35c23d50f8eed157ef72b
Author: Binoy Jayan <binoy.jayan@linaro.org>
Date:   Wed Jun 1 14:56:55 2016 +0530

    rtl8192e: Replace semaphore scan_sem with mutex
    
    The semaphore 'scan_sem' in the rtl8192e is a simple mutex, so it should
    be written as one. Semaphores are going away in the future.
    
    Signed-off-by: Binoy Jayan <binoy.jayan@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 901cc50a08d0..858eae20a53f 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -513,7 +513,7 @@ static void rtllib_softmac_scan_syncro(struct rtllib_device *ieee, u8 is_mesh)
 
 	ieee->be_scan_inprogress = true;
 
-	down(&ieee->scan_sem);
+	mutex_lock(&ieee->scan_mutex);
 
 	while (1) {
 		do {
@@ -566,7 +566,7 @@ static void rtllib_softmac_scan_syncro(struct rtllib_device *ieee, u8 is_mesh)
 		if (IS_DOT11D_ENABLE(ieee))
 			DOT11D_ScanComplete(ieee);
 	}
-	up(&ieee->scan_sem);
+	mutex_unlock(&ieee->scan_mutex);
 
 	ieee->be_scan_inprogress = false;
 
@@ -587,7 +587,7 @@ static void rtllib_softmac_scan_wq(void *data)
 	if (rtllib_act_scanning(ieee, true))
 		return;
 
-	down(&ieee->scan_sem);
+	mutex_lock(&ieee->scan_mutex);
 
 	if (ieee->eRFPowerState == eRfOff) {
 		netdev_info(ieee->dev,
@@ -618,7 +618,7 @@ static void rtllib_softmac_scan_wq(void *data)
 	schedule_delayed_work(&ieee->softmac_scan_wq,
 			      msecs_to_jiffies(RTLLIB_SOFTMAC_SCAN_TIME));
 
-	up(&ieee->scan_sem);
+	mutex_unlock(&ieee->scan_mutex);
 	return;
 
 out:
@@ -630,7 +630,7 @@ static void rtllib_softmac_scan_wq(void *data)
 	ieee->actscanning = false;
 	ieee->scan_watch_dog = 0;
 	ieee->scanning_continue = 0;
-	up(&ieee->scan_sem);
+	mutex_unlock(&ieee->scan_mutex);
 }
 
 
@@ -683,7 +683,7 @@ EXPORT_SYMBOL(rtllib_start_send_beacons);
 
 static void rtllib_softmac_stop_scan(struct rtllib_device *ieee)
 {
-	down(&ieee->scan_sem);
+	mutex_lock(&ieee->scan_mutex);
 	ieee->scan_watch_dog = 0;
 	if (ieee->scanning_continue == 1) {
 		ieee->scanning_continue = 0;
@@ -692,7 +692,7 @@ static void rtllib_softmac_stop_scan(struct rtllib_device *ieee)
 		cancel_delayed_work_sync(&ieee->softmac_scan_wq);
 	}
 
-	up(&ieee->scan_sem);
+	mutex_unlock(&ieee->scan_mutex);
 }
 
 void rtllib_stop_scan(struct rtllib_device *ieee)
@@ -3035,7 +3035,7 @@ void rtllib_softmac_init(struct rtllib_device *ieee)
 		      ieee);
 
 	mutex_init(&ieee->wx_mutex);
-	sema_init(&ieee->scan_sem, 1);
+	mutex_init(&ieee->scan_mutex);
 	sema_init(&ieee->ips_sem, 1);
 
 	spin_lock_init(&ieee->mgmt_tx_lock);

commit 9afa937047b5c3dca3ed0bb6361eac06073c3efa
Author: Binoy Jayan <binoy.jayan@linaro.org>
Date:   Wed Jun 1 14:56:52 2016 +0530

    rtl8192e: rtllib_device: Replace semaphore wx_sem with mutex
    
    The semaphore 'wx_sem' in the rtllib_device is a simple mutex,
    so it should be written as one. Semaphores are going away in the future.
    
    Signed-off-by: Binoy Jayan <binoy.jayan@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 62154e3f4463..901cc50a08d0 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -753,7 +753,7 @@ static void rtllib_start_scan(struct rtllib_device *ieee)
 	}
 }
 
-/* called with wx_sem held */
+/* called with wx_mutex held */
 void rtllib_start_scan_syncro(struct rtllib_device *ieee, u8 is_mesh)
 {
 	if (IS_DOT11D_ENABLE(ieee)) {
@@ -1590,7 +1590,7 @@ static void rtllib_associate_procedure_wq(void *data)
 	rtllib_stop_scan_syncro(ieee);
 	if (ieee->rtllib_ips_leave != NULL)
 		ieee->rtllib_ips_leave(ieee->dev);
-	down(&ieee->wx_sem);
+	mutex_lock(&ieee->wx_mutex);
 
 	if (ieee->data_hard_stop)
 		ieee->data_hard_stop(ieee->dev);
@@ -1605,14 +1605,14 @@ static void rtllib_associate_procedure_wq(void *data)
 			 __func__);
 		if (ieee->rtllib_ips_leave_wq != NULL)
 			ieee->rtllib_ips_leave_wq(ieee->dev);
-		up(&ieee->wx_sem);
+		mutex_unlock(&ieee->wx_mutex);
 		return;
 	}
 	ieee->associate_seq = 1;
 
 	rtllib_associate_step1(ieee, ieee->current_network.bssid);
 
-	up(&ieee->wx_sem);
+	mutex_unlock(&ieee->wx_mutex);
 }
 
 inline void rtllib_softmac_new_net(struct rtllib_device *ieee,
@@ -2582,16 +2582,16 @@ static void rtllib_start_ibss_wq(void *data)
 				     struct rtllib_device, start_ibss_wq);
 	/* iwconfig mode ad-hoc will schedule this and return
 	 * on the other hand this will block further iwconfig SET
-	 * operations because of the wx_sem hold.
+	 * operations because of the wx_mutex hold.
 	 * Anyway some most set operations set a flag to speed-up
 	 * (abort) this wq (when syncro scanning) before sleeping
-	 * on the semaphore
+	 * on the mutex
 	 */
 	if (!ieee->proto_started) {
 		netdev_info(ieee->dev, "==========oh driver down return\n");
 		return;
 	}
-	down(&ieee->wx_sem);
+	mutex_lock(&ieee->wx_mutex);
 
 	if (ieee->current_network.ssid_len == 0) {
 		strcpy(ieee->current_network.ssid, RTLLIB_DEFAULT_TX_ESSID);
@@ -2703,7 +2703,7 @@ static void rtllib_start_ibss_wq(void *data)
 
 	netif_carrier_on(ieee->dev);
 
-	up(&ieee->wx_sem);
+	mutex_unlock(&ieee->wx_mutex);
 }
 
 inline void rtllib_start_ibss(struct rtllib_device *ieee)
@@ -2711,7 +2711,7 @@ inline void rtllib_start_ibss(struct rtllib_device *ieee)
 	schedule_delayed_work(&ieee->start_ibss_wq, msecs_to_jiffies(150));
 }
 
-/* this is called only in user context, with wx_sem held */
+/* this is called only in user context, with wx_mutex held */
 static void rtllib_start_bss(struct rtllib_device *ieee)
 {
 	unsigned long flags;
@@ -2773,7 +2773,7 @@ static void rtllib_associate_retry_wq(void *data)
 				     struct rtllib_device, associate_retry_wq);
 	unsigned long flags;
 
-	down(&ieee->wx_sem);
+	mutex_lock(&ieee->wx_mutex);
 	if (!ieee->proto_started)
 		goto exit;
 
@@ -2806,7 +2806,7 @@ static void rtllib_associate_retry_wq(void *data)
 
 	ieee->beinretry = false;
 exit:
-	up(&ieee->wx_sem);
+	mutex_unlock(&ieee->wx_mutex);
 }
 
 static struct sk_buff *rtllib_get_beacon_(struct rtllib_device *ieee)
@@ -2853,9 +2853,9 @@ void rtllib_softmac_stop_protocol(struct rtllib_device *ieee, u8 mesh_flag,
 				  u8 shutdown)
 {
 	rtllib_stop_scan_syncro(ieee);
-	down(&ieee->wx_sem);
+	mutex_lock(&ieee->wx_mutex);
 	rtllib_stop_protocol(ieee, shutdown);
-	up(&ieee->wx_sem);
+	mutex_unlock(&ieee->wx_mutex);
 }
 EXPORT_SYMBOL(rtllib_softmac_stop_protocol);
 
@@ -2902,9 +2902,9 @@ void rtllib_stop_protocol(struct rtllib_device *ieee, u8 shutdown)
 
 void rtllib_softmac_start_protocol(struct rtllib_device *ieee, u8 mesh_flag)
 {
-	down(&ieee->wx_sem);
+	mutex_lock(&ieee->wx_mutex);
 	rtllib_start_protocol(ieee);
-	up(&ieee->wx_sem);
+	mutex_unlock(&ieee->wx_mutex);
 }
 EXPORT_SYMBOL(rtllib_softmac_start_protocol);
 
@@ -3034,7 +3034,7 @@ void rtllib_softmac_init(struct rtllib_device *ieee)
 	INIT_WORK_RSL(&ieee->wx_sync_scan_wq, (void *)rtllib_wx_sync_scan_wq,
 		      ieee);
 
-	sema_init(&ieee->wx_sem, 1);
+	mutex_init(&ieee->wx_mutex);
 	sema_init(&ieee->scan_sem, 1);
 	sema_init(&ieee->ips_sem, 1);
 
@@ -3049,7 +3049,7 @@ void rtllib_softmac_init(struct rtllib_device *ieee)
 
 void rtllib_softmac_free(struct rtllib_device *ieee)
 {
-	down(&ieee->wx_sem);
+	mutex_lock(&ieee->wx_mutex);
 	kfree(ieee->pDot11dInfo);
 	ieee->pDot11dInfo = NULL;
 	del_timer_sync(&ieee->associate_timer);
@@ -3064,7 +3064,7 @@ void rtllib_softmac_free(struct rtllib_device *ieee)
 	cancel_work_sync(&ieee->associate_complete_wq);
 	cancel_work_sync(&ieee->ips_leave_wq);
 	cancel_work_sync(&ieee->wx_sync_scan_wq);
-	up(&ieee->wx_sem);
+	mutex_unlock(&ieee->wx_mutex);
 	tasklet_kill(&ieee->ps_task);
 }
 
@@ -3499,7 +3499,7 @@ int rtllib_wpa_supplicant_ioctl(struct rtllib_device *ieee, struct iw_point *p,
 	struct ieee_param *param;
 	int ret = 0;
 
-	down(&ieee->wx_sem);
+	mutex_lock(&ieee->wx_mutex);
 
 	if (p->length < sizeof(struct ieee_param) || !p->pointer) {
 		ret = -EINVAL;
@@ -3543,7 +3543,7 @@ int rtllib_wpa_supplicant_ioctl(struct rtllib_device *ieee, struct iw_point *p,
 
 	kfree(param);
 out:
-	up(&ieee->wx_sem);
+	mutex_unlock(&ieee->wx_mutex);
 
 	return ret;
 }

commit 4d0e965732db6f7cce78e6b8f5d3073249004c3a
Author: Florian Westphal <fw@strlen.de>
Date:   Tue May 3 16:30:59 2016 +0200

    drivers: replace dev->trans_start accesses with dev_trans_start
    
    a trans_start struct member exists twice:
    - in struct net_device (legacy)
    - in struct netdev_queue
    
    Instead of open-coding dev->trans_start usage to obtain the current
    trans_start value, use dev_trans_start() instead.
    
    This is not exactly the same, as dev_trans_start also considers
    the trans_start values of the netdev queues owned by the device
    and provides the most recent one.
    
    For legacy devices this doesn't matter as dev_trans_start can cope
    with netdev trans_start values of 0 (they are ignored).
    
    This is a prerequisite to eventual removal of dev->trans_start.
    
    Cc: linux-rdma@vger.kernel.org
    Signed-off-by: Florian Westphal <fw@strlen.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index cfab715495ad..62154e3f4463 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -1991,7 +1991,7 @@ static short rtllib_sta_ps_sleep(struct rtllib_device *ieee, u64 *time)
 		return 2;
 
 	if (!time_after(jiffies,
-			ieee->dev->trans_start + msecs_to_jiffies(timeout)))
+			dev_trans_start(ieee->dev) + msecs_to_jiffies(timeout)))
 		return 0;
 	if (!time_after(jiffies,
 			ieee->last_rx_ps_time + msecs_to_jiffies(timeout)))

commit 372419776a023f7f0eede837cd866c2d544ba4a4
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Wed Mar 2 01:12:03 2016 +0530

    Staging: rtl8192e: Replace random_ether_addr with eth_random_addr
    
    The macro random_ether_addr is calling the function eth_random_addr.
    Therefore, the call to random_ether_addr can be replaced with
    eth_random_addr.
    Remove the wrapper function rtllib_randomize_cell and replace its
    call with eth_random_addr as it is wrapping random_ether_addr.
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index bbc44652769c..cfab715495ad 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -2537,12 +2537,6 @@ void rtllib_wake_all_queues(struct rtllib_device *ieee)
 	netif_tx_wake_all_queues(ieee->dev);
 }
 
-inline void rtllib_randomize_cell(struct rtllib_device *ieee)
-{
-
-	random_ether_addr(ieee->current_network.bssid);
-}
-
 /* called in user context only */
 static void rtllib_start_master_bss(struct rtllib_device *ieee)
 {
@@ -2633,7 +2627,7 @@ static void rtllib_start_ibss_wq(void *data)
 		netdev_info(ieee->dev, "creating new IBSS cell\n");
 		ieee->current_network.channel = ieee->IbssStartChnl;
 		if (!ieee->wap_set)
-			rtllib_randomize_cell(ieee);
+			eth_random_addr(ieee->current_network.bssid);
 
 		if (ieee->modulation & RTLLIB_CCK_MODULATION) {
 

commit 354605f4e6190ac2c80be5e1a1c7c80a2f7f30a1
Author: Amitoj Kaur Chawla <amitoj1606@gmail.com>
Date:   Sat Feb 20 15:36:26 2016 +0530

    staging: rtl8192e: Remove create_workqueue()
    
    With conccurency managed workqueues, use of dedicated workqueues can
    be replaced by system_wq. Drop wq by using system_wq.
    
    Since there are multiple work items per rtllib but they do not need to
    be ordered, increase of concurrency by switching to system_wq should
    not break anything.
    
    All work items are sync canceled on rtllib_stop_protocol() so it is
    guaranteed that no work is running when rtl92e_disable/reset/restart
    functions are called.
    
    Signed-off-by: Amitoj Kaur Chawla <amitoj1606@gmail.com>
    Acked-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 25b5b5e31612..bbc44652769c 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -615,8 +615,8 @@ static void rtllib_softmac_scan_wq(void *data)
 	if (ieee->active_channel_map[ieee->current_network.channel] == 1)
 		rtllib_send_probe_requests(ieee, 0);
 
-	queue_delayed_work_rsl(ieee->wq, &ieee->softmac_scan_wq,
-			       msecs_to_jiffies(RTLLIB_SOFTMAC_SCAN_TIME));
+	schedule_delayed_work(&ieee->softmac_scan_wq,
+			      msecs_to_jiffies(RTLLIB_SOFTMAC_SCAN_TIME));
 
 	up(&ieee->scan_sem);
 	return;
@@ -689,7 +689,7 @@ static void rtllib_softmac_stop_scan(struct rtllib_device *ieee)
 		ieee->scanning_continue = 0;
 		ieee->actscanning = false;
 
-		cancel_delayed_work(&ieee->softmac_scan_wq);
+		cancel_delayed_work_sync(&ieee->softmac_scan_wq);
 	}
 
 	up(&ieee->scan_sem);
@@ -745,8 +745,7 @@ static void rtllib_start_scan(struct rtllib_device *ieee)
 		if (ieee->scanning_continue == 0) {
 			ieee->actscanning = true;
 			ieee->scanning_continue = 1;
-			queue_delayed_work_rsl(ieee->wq,
-					       &ieee->softmac_scan_wq, 0);
+			schedule_delayed_work(&ieee->softmac_scan_wq, 0);
 		}
 	} else {
 		if (ieee->rtllib_start_hw_scan)
@@ -1428,8 +1427,8 @@ static void rtllib_associate_abort(struct rtllib_device *ieee)
 
 	ieee->state = RTLLIB_ASSOCIATING_RETRY;
 
-	queue_delayed_work_rsl(ieee->wq, &ieee->associate_retry_wq,
-			   RTLLIB_SOFTMAC_ASSOC_RETRY_TIME);
+	schedule_delayed_work(&ieee->associate_retry_wq,
+			      RTLLIB_SOFTMAC_ASSOC_RETRY_TIME);
 
 	spin_unlock_irqrestore(&ieee->lock, flags);
 }
@@ -1580,7 +1579,7 @@ static void rtllib_associate_complete(struct rtllib_device *ieee)
 	ieee->state = RTLLIB_LINKED;
 	rtllib_sta_send_associnfo(ieee);
 
-	queue_work_rsl(ieee->wq, &ieee->associate_complete_wq);
+	schedule_work(&ieee->associate_complete_wq);
 }
 
 static void rtllib_associate_procedure_wq(void *data)
@@ -1729,7 +1728,7 @@ inline void rtllib_softmac_new_net(struct rtllib_device *ieee,
 				if (ieee->LedControlHandler != NULL)
 					ieee->LedControlHandler(ieee->dev,
 							 LED_CTL_START_TO_LINK);
-				queue_delayed_work_rsl(ieee->wq,
+				schedule_delayed_work(
 					   &ieee->associate_procedure_wq, 0);
 			} else {
 				if (rtllib_is_54g(&ieee->current_network) &&
@@ -2283,7 +2282,7 @@ inline int rtllib_rx_assoc_resp(struct rtllib_device *ieee, struct sk_buff *skb,
 				    "Association response status code 0x%x\n",
 				    errcode);
 			if (ieee->AsocRetryCount < RT_ASOC_RETRY_LIMIT)
-				queue_delayed_work_rsl(ieee->wq,
+				schedule_delayed_work(
 					 &ieee->associate_procedure_wq, 0);
 			else
 				rtllib_associate_abort(ieee);
@@ -2393,7 +2392,7 @@ inline int rtllib_rx_deauth(struct rtllib_device *ieee, struct sk_buff *skb)
 
 		if (!(ieee->rtllib_ap_sec_type(ieee) &
 		    (SEC_ALG_CCMP|SEC_ALG_TKIP)))
-			queue_delayed_work_rsl(ieee->wq,
+			schedule_delayed_work(
 				       &ieee->associate_procedure_wq, 5);
 	}
 	return 0;
@@ -2715,8 +2714,7 @@ static void rtllib_start_ibss_wq(void *data)
 
 inline void rtllib_start_ibss(struct rtllib_device *ieee)
 {
-	queue_delayed_work_rsl(ieee->wq, &ieee->start_ibss_wq,
-			       msecs_to_jiffies(150));
+	schedule_delayed_work(&ieee->start_ibss_wq, msecs_to_jiffies(150));
 }
 
 /* this is called only in user context, with wx_sem held */
@@ -2770,7 +2768,7 @@ void rtllib_disassociate(struct rtllib_device *ieee)
 	ieee->is_set_key = false;
 	ieee->wap_set = 0;
 
-	queue_delayed_work_rsl(ieee->wq, &ieee->link_change_wq, 0);
+	schedule_delayed_work(&ieee->link_change_wq, 0);
 
 	notify_wx_assoc_event(ieee);
 }
@@ -2882,9 +2880,9 @@ void rtllib_stop_protocol(struct rtllib_device *ieee, u8 shutdown)
 
 	rtllib_stop_send_beacons(ieee);
 	del_timer_sync(&ieee->associate_timer);
-	cancel_delayed_work(&ieee->associate_retry_wq);
-	cancel_delayed_work(&ieee->start_ibss_wq);
-	cancel_delayed_work(&ieee->link_change_wq);
+	cancel_delayed_work_sync(&ieee->associate_retry_wq);
+	cancel_delayed_work_sync(&ieee->start_ibss_wq);
+	cancel_delayed_work_sync(&ieee->link_change_wq);
 	rtllib_stop_scan(ieee);
 
 	if (ieee->state <= RTLLIB_ASSOCIATING_AUTHENTICATED)
@@ -3027,9 +3025,6 @@ void rtllib_softmac_init(struct rtllib_device *ieee)
 		    rtllib_send_beacon_cb,
 		    (unsigned long) ieee);
 
-
-	ieee->wq = create_workqueue(DRV_NAME);
-
 	INIT_DELAYED_WORK_RSL(&ieee->link_change_wq,
 			      (void *)rtllib_link_change_wq, ieee);
 	INIT_DELAYED_WORK_RSL(&ieee->start_ibss_wq,
@@ -3065,8 +3060,16 @@ void rtllib_softmac_free(struct rtllib_device *ieee)
 	ieee->pDot11dInfo = NULL;
 	del_timer_sync(&ieee->associate_timer);
 
-	cancel_delayed_work(&ieee->associate_retry_wq);
-	destroy_workqueue(ieee->wq);
+	cancel_delayed_work_sync(&ieee->associate_retry_wq);
+	cancel_delayed_work_sync(&ieee->associate_procedure_wq);
+	cancel_delayed_work_sync(&ieee->softmac_scan_wq);
+	cancel_delayed_work_sync(&ieee->start_ibss_wq);
+	cancel_delayed_work_sync(&ieee->hw_wakeup_wq);
+	cancel_delayed_work_sync(&ieee->hw_sleep_wq);
+	cancel_delayed_work_sync(&ieee->link_change_wq);
+	cancel_work_sync(&ieee->associate_complete_wq);
+	cancel_work_sync(&ieee->ips_leave_wq);
+	cancel_work_sync(&ieee->wx_sync_scan_wq);
 	up(&ieee->wx_sem);
 	tasklet_kill(&ieee->ps_task);
 }

commit 7949be663f7d3693cde96bb65fc3cb3b981c5700
Author: Bhaktipriya Shridhar <bhaktipriya96@gmail.com>
Date:   Fri Feb 19 03:13:56 2016 +0530

    staging: rtl8192e: Drop useless initialisation
    
    Removed initialisation of a varible if it is immediately reassigned.
    
    Changes were made using Coccinelle.
    
    @@
    type T;
    constant C;
    expression e;
    identifier i;
    @@
    T i
    - = C
    ;
    i = e;
    
    Signed-off-by: Bhaktipriya Shridhar <bhaktipriya96@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 19c3bffef73c..25b5b5e31612 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -776,7 +776,7 @@ inline struct sk_buff *rtllib_authentication_req(struct rtllib_network *beacon,
 {
 	struct sk_buff *skb;
 	struct rtllib_authentication *auth;
-	int  len = 0;
+	int  len;
 
 	len = sizeof(struct rtllib_authentication) + challengelen +
 		     ieee->tx_headroom + 4;

commit 686f0c2301a762cf0fc73bd0cfaf62473ddc76d6
Author: Hari Prasath Gujulan Elango <hgujulan@visteon.com>
Date:   Mon Feb 8 04:44:13 2016 +0000

    staging: rtl8192e: prefer using eth_broadcast_addr()
    
    Prefer using the eth_broadcast_addr() instead of memset to broadcast
    address 0xFF to the array.
    
    Signed-off-by: Hari Prasath Gujulan Elango <hgujulan@visteon.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index acccf9b44b98..19c3bffef73c 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -355,9 +355,9 @@ static inline struct sk_buff *rtllib_probe_req(struct rtllib_device *ieee)
 	req->header.frame_ctl = cpu_to_le16(RTLLIB_STYPE_PROBE_REQ);
 	req->header.duration_id = 0;
 
-	memset(req->header.addr1, 0xff, ETH_ALEN);
+	eth_broadcast_addr(req->header.addr1);
 	ether_addr_copy(req->header.addr2, ieee->dev->dev_addr);
-	memset(req->header.addr3, 0xff, ETH_ALEN);
+	eth_broadcast_addr(req->header.addr3);
 
 	tag = (u8 *) skb_put(skb, len + 2 + rate_len);
 

commit 0bd35534933feceb7afb383ce7947f2841132c99
Author: Sean MacLennan <seanm@seanm.ca>
Date:   Sun Nov 15 19:51:43 2015 -0500

    staging:rtl8192e: Usage count off by one
    
    The rtllib driver is not calling try_module_get() when loading the
    encryption modules. Because of this, you can never remove the module
    once you have used it one (i.e. bring up the wireless interface).
    
    Signed-off-by: Sean MacLennan <seanm@seanm.ca>
    Tested-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index d0fedb0ff132..acccf9b44b98 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -3328,7 +3328,7 @@ static int rtllib_wpa_set_encryption(struct rtllib_device *ieee,
 			goto done;
 		}
 		new_crypt->ops = ops;
-		if (new_crypt->ops)
+		if (new_crypt->ops && try_module_get(new_crypt->ops->owner))
 			new_crypt->priv =
 				new_crypt->ops->init(param->u.crypt.idx);
 

commit bd60ac14db902ed8e5c7a769c85fc9005fd69c26
Author: Shivani Bhardwaj <shivanib134@gmail.com>
Date:   Wed Oct 14 23:46:05 2015 +0530

    Staging: rtl8192e: rtllib_softmac: Remove useless cast
    
    Explicit type conversion is not required to remove it.
    Semantic patch used:
    @@
    type T;
    T e;
    identifier x;
    @@
    
    * T x = (T)e;
    
    Signed-off-by: Shivani Bhardwaj <shivanib134@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 3bc4223fe347..d0fedb0ff132 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -1520,8 +1520,7 @@ static void rtllib_associate_complete_wq(void *data)
 				     container_of_work_rsl(data,
 				     struct rtllib_device,
 				     associate_complete_wq);
-	struct rt_pwr_save_ctrl *pPSC = (struct rt_pwr_save_ctrl *)
-					(&(ieee->PowerSaveControl));
+	struct rt_pwr_save_ctrl *pPSC = &(ieee->PowerSaveControl);
 	netdev_info(ieee->dev, "Associated successfully\n");
 	if (!ieee->is_silent_reset) {
 		netdev_info(ieee->dev, "normal associate\n");
@@ -1974,8 +1973,7 @@ static short rtllib_sta_ps_sleep(struct rtllib_device *ieee, u64 *time)
 {
 	int timeout = ieee->ps_timeout;
 	u8 dtim;
-	struct rt_pwr_save_ctrl *pPSC = (struct rt_pwr_save_ctrl *)
-					(&(ieee->PowerSaveControl));
+	struct rt_pwr_save_ctrl *pPSC = &(ieee->PowerSaveControl);
 
 	if (ieee->LPSDelayCnt) {
 		ieee->LPSDelayCnt--;

commit 4c29207a96885b82175979c723a63de05d5fb2f9
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Sun Sep 20 21:04:27 2015 +0200

    staging: rtl8192e: Fix CONSTANT_COMPARISON warnings
    
    Remove yoda conditions where pointed by checkpatch.
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 4fcd0b652a2d..3bc4223fe347 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -858,7 +858,7 @@ static struct sk_buff *rtllib_probe_resp(struct rtllib_device *ieee,
 
 	crypt = ieee->crypt_info.crypt[ieee->crypt_info.tx_keyidx];
 	encrypt = ieee->host_encrypt && crypt && crypt->ops &&
-		((0 == strcmp(crypt->ops->name, "R-WEP") || wpa_ie_len));
+		((strcmp(crypt->ops->name, "R-WEP") == 0 || wpa_ie_len));
 	if (ieee->pHTInfo->bCurrentHTSupport) {
 		tmp_ht_cap_buf = (u8 *) &(ieee->pHTInfo->SelfHTCap);
 		tmp_ht_cap_len = sizeof(ieee->pHTInfo->SelfHTCap);
@@ -1180,7 +1180,7 @@ inline struct sk_buff *rtllib_association_req(struct rtllib_network *beacon,
 	crypt = ieee->crypt_info.crypt[ieee->crypt_info.tx_keyidx];
 	if (crypt != NULL)
 		encrypt = ieee->host_encrypt && crypt && crypt->ops &&
-			  ((0 == strcmp(crypt->ops->name, "R-WEP") ||
+			  ((strcmp(crypt->ops->name, "R-WEP") == 0 ||
 			  wpa_ie_len));
 	else
 		encrypt = 0;
@@ -2229,7 +2229,7 @@ inline int rtllib_rx_assoc_resp(struct rtllib_device *ieee, struct sk_buff *skb,
 	     ieee->state == RTLLIB_ASSOCIATING_AUTHENTICATED &&
 	     (ieee->iw_mode == IW_MODE_INFRA)) {
 		errcode = assoc_parse(ieee, skb, &aid);
-		if (0 == errcode) {
+		if (!errcode) {
 			struct rtllib_network *network =
 				 kzalloc(sizeof(struct rtllib_network),
 				 GFP_ATOMIC);
@@ -3480,7 +3480,7 @@ u8 rtllib_ap_sec_type(struct rtllib_device *ieee)
 	crypt = ieee->crypt_info.crypt[ieee->crypt_info.tx_keyidx];
 	encrypt = (ieee->current_network.capability & WLAN_CAPABILITY_PRIVACY)
 		  || (ieee->host_encrypt && crypt && crypt->ops &&
-		  (0 == strcmp(crypt->ops->name, "R-WEP")));
+		  (strcmp(crypt->ops->name, "R-WEP") == 0));
 
 	/* simply judge  */
 	if (encrypt && (wpa_ie_len == 0)) {

commit fc00af0cd0313f1446cf4ff9d536a2db216f8fb7
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Sun Sep 20 21:04:26 2015 +0200

    staging: rtl8192e: Fix SUSPECT_CODE_INDENT warnings
    
    Fix SUSPECT_CODE_INDENT warnings (indentation).
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 1503cbb3574e..4fcd0b652a2d 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -709,7 +709,7 @@ EXPORT_SYMBOL(rtllib_stop_scan);
 void rtllib_stop_scan_syncro(struct rtllib_device *ieee)
 {
 	if (ieee->softmac_features & IEEE_SOFTMAC_SCAN) {
-			ieee->sync_scan_hurryup = 1;
+		ieee->sync_scan_hurryup = 1;
 	} else {
 		if (ieee->rtllib_stop_hw_scan)
 			ieee->rtllib_stop_hw_scan(ieee->dev);
@@ -2762,10 +2762,10 @@ void rtllib_disassociate(struct rtllib_device *ieee)
 {
 	netif_carrier_off(ieee->dev);
 	if (ieee->softmac_features & IEEE_SOFTMAC_TX_QUEUE)
-			rtllib_reset_queue(ieee);
+		rtllib_reset_queue(ieee);
 
 	if (ieee->data_hard_stop)
-			ieee->data_hard_stop(ieee->dev);
+		ieee->data_hard_stop(ieee->dev);
 	if (IS_DOT11D_ENABLE(ieee))
 		Dot11d_Reset(ieee);
 	ieee->state = RTLLIB_NOLINK;

commit 3e3148c51190d680b7cc2ebdc556e6ea27a93989
Author: Vaishali Thakkar <vthakkar1994@gmail.com>
Date:   Fri Jun 26 09:37:25 2015 +0530

    Staging: rtl8192e: Replace memset with eth_zero_addr
    
    Use eth_zero_addr to assign the zero address to the given address
    array instead of memset when second argument is address of zero.
    Note that the 6 in the third argument of memset appears to represent
    an ethernet address size (ETH_ALEN).
    
    The Coccinelle semantic patch that makes this change is as follows:
    
    // <smpl>
    @eth_zero_addr@
    expression e;
    @@
    
    -memset(e,0x00,6);
    +eth_zero_addr(e);
    // </smpl>
    
    Signed-off-by: Vaishali Thakkar <vthakkar1994@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 635a1c40c309..1503cbb3574e 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -3086,7 +3086,7 @@ static int rtllib_wpa_enable(struct rtllib_device *ieee, int value)
 	 */
 	netdev_info(ieee->dev, "%s WPA\n", value ? "enabling" : "disabling");
 	ieee->wpa_enabled = value;
-	memset(ieee->ap_mac_addr, 0, 6);
+	eth_zero_addr(ieee->ap_mac_addr);
 	return 0;
 }
 

commit 6957248f487e0eeecf7a23a34b08ee26c0c3a151
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Tue Jul 14 22:04:26 2015 +0200

    staging: rtl8192e: rtllib_softmac: Make functions static
    
    Make as many functions as possible static in rtllib_softmac.c.
    
    The following functions were affected:
    - rtllib_sta_wakeup
    - rtllib_TURBO_Info
    - rtllib_get_beacon_
    - rtllib_send_probe_requests
    - rtllib_update_active_chan_map
    - rtllib_softmac_scan_syncro
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index eac7f289d354..635a1c40c309 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -23,7 +23,10 @@
 #include <linux/ieee80211.h>
 #include "dot11d.h"
 
-short rtllib_is_54g(struct rtllib_network *net)
+static void rtllib_sta_wakeup(struct rtllib_device *ieee, short nl);
+
+
+static short rtllib_is_54g(struct rtllib_network *net)
 {
 	return (net->rates_ex_len > 0) || (net->rates_len > 4);
 }
@@ -107,7 +110,7 @@ static void rtllib_WMM_Info(struct rtllib_device *ieee, u8 **tag_p)
 	*tag_p = tag;
 }
 
-void rtllib_TURBO_Info(struct rtllib_device *ieee, u8 **tag_p)
+static void rtllib_TURBO_Info(struct rtllib_device *ieee, u8 **tag_p)
 {
 	u8 *tag = *tag_p;
 
@@ -369,7 +372,7 @@ static inline struct sk_buff *rtllib_probe_req(struct rtllib_device *ieee)
 	return skb;
 }
 
-struct sk_buff *rtllib_get_beacon_(struct rtllib_device *ieee);
+static struct sk_buff *rtllib_get_beacon_(struct rtllib_device *ieee);
 
 static void rtllib_send_beacon(struct rtllib_device *ieee)
 {
@@ -483,7 +486,7 @@ static void rtllib_send_probe(struct rtllib_device *ieee, u8 is_mesh)
 }
 
 
-void rtllib_send_probe_requests(struct rtllib_device *ieee, u8 is_mesh)
+static void rtllib_send_probe_requests(struct rtllib_device *ieee, u8 is_mesh)
 {
 	if (ieee->active_scan && (ieee->softmac_features &
 	    IEEE_SOFTMAC_PROBERQ)) {
@@ -492,7 +495,7 @@ void rtllib_send_probe_requests(struct rtllib_device *ieee, u8 is_mesh)
 	}
 }
 
-void rtllib_update_active_chan_map(struct rtllib_device *ieee)
+static void rtllib_update_active_chan_map(struct rtllib_device *ieee)
 {
 	memcpy(ieee->active_channel_map, GET_DOT11D_INFO(ieee)->channel_map,
 	       MAX_CHANNEL_NUMBER+1);
@@ -501,7 +504,7 @@ void rtllib_update_active_chan_map(struct rtllib_device *ieee)
 /* this performs syncro scan blocking the caller until all channels
  * in the allowed channel map has been checked.
  */
-void rtllib_softmac_scan_syncro(struct rtllib_device *ieee, u8 is_mesh)
+static void rtllib_softmac_scan_syncro(struct rtllib_device *ieee, u8 is_mesh)
 {
 	union iwreq_data wrqu;
 	short ch = 0;
@@ -1401,7 +1404,7 @@ inline struct sk_buff *rtllib_association_req(struct rtllib_network *beacon,
 	return skb;
 }
 
-void rtllib_associate_abort(struct rtllib_device *ieee)
+static void rtllib_associate_abort(struct rtllib_device *ieee)
 {
 	unsigned long flags;
 
@@ -1752,7 +1755,7 @@ inline void rtllib_softmac_new_net(struct rtllib_device *ieee,
 	}
 }
 
-void rtllib_softmac_check_all_nets(struct rtllib_device *ieee)
+static void rtllib_softmac_check_all_nets(struct rtllib_device *ieee)
 {
 	unsigned long flags;
 	struct rtllib_network *target;
@@ -2108,7 +2111,7 @@ static inline void rtllib_sta_ps(struct rtllib_device *ieee)
 
 }
 
-void rtllib_sta_wakeup(struct rtllib_device *ieee, short nl)
+static void rtllib_sta_wakeup(struct rtllib_device *ieee, short nl)
 {
 	if (ieee->sta_sleep == LPS_IS_WAKE) {
 		if (nl) {
@@ -2544,7 +2547,7 @@ inline void rtllib_randomize_cell(struct rtllib_device *ieee)
 }
 
 /* called in user context only */
-void rtllib_start_master_bss(struct rtllib_device *ieee)
+static void rtllib_start_master_bss(struct rtllib_device *ieee)
 {
 	ieee->assoc_id = 1;
 
@@ -2719,7 +2722,7 @@ inline void rtllib_start_ibss(struct rtllib_device *ieee)
 }
 
 /* this is called only in user context, with wx_sem held */
-void rtllib_start_bss(struct rtllib_device *ieee)
+static void rtllib_start_bss(struct rtllib_device *ieee)
 {
 	unsigned long flags;
 
@@ -2816,7 +2819,7 @@ static void rtllib_associate_retry_wq(void *data)
 	up(&ieee->wx_sem);
 }
 
-struct sk_buff *rtllib_get_beacon_(struct rtllib_device *ieee)
+static struct sk_buff *rtllib_get_beacon_(struct rtllib_device *ieee)
 {
 	const u8 broadcast_addr[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
 

commit 9efe891d01c3734ab05fdbd53dead3451fa03e29
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Tue Jul 14 22:04:05 2015 +0200

    staging: rtl8192e: Remove unused defines
    
    Remove most of unused defines (excluding phyreg/hw registers).
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index d320c31732f2..eac7f289d354 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -1511,7 +1511,6 @@ static void rtllib_associate_step2(struct rtllib_device *ieee)
 	}
 }
 
-#define CANCELLED  2
 static void rtllib_associate_complete_wq(void *data)
 {
 	struct rtllib_device *ieee = (struct rtllib_device *)

commit 2e59e40d5d63ff805c9a5299be8b8e5e299dc6b6
Author: Gnanachandran Dhanapal <gdhanapa@visteon.com>
Date:   Tue Jun 16 07:25:48 2015 +0000

    Staging: rtl8192e: Timer setup using macro rather assignment
    
    This patch shall replaces user defined timer setup function with
    standard timer setup macro. Also removes init_timer, because timer can
    be initialized in setup_timer macro as well.
    
    Signed-off-by: Gnanachandran Dhanapal <gdhanapa@visteon.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 444fac73a8a8..d320c31732f2 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -3019,11 +3019,11 @@ void rtllib_softmac_init(struct rtllib_device *ieee)
 
 	ieee->tx_pending.txb = NULL;
 
-	_setup_timer(&ieee->associate_timer,
+	setup_timer(&ieee->associate_timer,
 		    rtllib_associate_abort_cb,
 		    (unsigned long) ieee);
 
-	_setup_timer(&ieee->beacon_timer,
+	setup_timer(&ieee->beacon_timer,
 		    rtllib_send_beacon_cb,
 		    (unsigned long) ieee);
 

commit 47eae6ddd9cf12781cefe6ec458d791174cb59b9
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Mon Jun 15 21:06:10 2015 +0200

    staging: rtl8192e: Remove rtllib_device::agregation
    
    Variable is always true; Resolve condition where it is used
    (and change indentation of conditional expression).
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 3f4a932e2353..444fac73a8a8 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -3017,7 +3017,6 @@ void rtllib_softmac_init(struct rtllib_device *ieee)
 	ieee->is_set_key = false;
 	init_mgmt_queue(ieee);
 
-	ieee->aggregation = true;
 	ieee->tx_pending.txb = NULL;
 
 	_setup_timer(&ieee->associate_timer,

commit 0941f87fd52333ffd2abc8a09c3102392b1f7b0c
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Mon Jun 15 21:06:09 2015 +0200

    staging: rtl8192e: Remove softmac_hint11d_wq queue
    
    This queue is never used, and function handler is empty
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 6d1120547c1c..3f4a932e2353 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -492,10 +492,6 @@ void rtllib_send_probe_requests(struct rtllib_device *ieee, u8 is_mesh)
 	}
 }
 
-static void rtllib_softmac_hint11d_wq(void *data)
-{
-}
-
 void rtllib_update_active_chan_map(struct rtllib_device *ieee)
 {
 	memcpy(ieee->active_channel_map, GET_DOT11D_INFO(ieee)->channel_map,
@@ -3045,8 +3041,6 @@ void rtllib_softmac_init(struct rtllib_device *ieee)
 			      (void *)rtllib_associate_procedure_wq, ieee);
 	INIT_DELAYED_WORK_RSL(&ieee->softmac_scan_wq,
 			      (void *)rtllib_softmac_scan_wq, ieee);
-	INIT_DELAYED_WORK_RSL(&ieee->softmac_hint11d_wq,
-			      (void *)rtllib_softmac_hint11d_wq, ieee);
 	INIT_DELAYED_WORK_RSL(&ieee->associate_retry_wq,
 			      (void *)rtllib_associate_retry_wq, ieee);
 	INIT_WORK_RSL(&ieee->wx_sync_scan_wq, (void *)rtllib_wx_sync_scan_wq,

commit 48eb2b7ea64dff6e659181325a0e464994170e59
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Mon Jun 15 21:06:08 2015 +0200

    staging: rtl8192e: Remove unused rtllib_device members
    
    Delete several members of rtllib_device including
    their initializers if needed.
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index dc3fc129f7e8..6d1120547c1c 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -1715,7 +1715,6 @@ inline void rtllib_softmac_new_net(struct rtllib_device *ieee,
 			   !(ieee->softmac_features & IEEE_SOFTMAC_SCAN))
 				rtllib_stop_scan_syncro(ieee);
 
-			ieee->hwscan_ch_bk = ieee->current_network.channel;
 			HTResetIOTSetting(ieee->pHTInfo);
 			ieee->wmm_acm = 0;
 			if (ieee->iw_mode == IW_MODE_INFRA) {
@@ -3022,12 +3021,7 @@ void rtllib_softmac_init(struct rtllib_device *ieee)
 	ieee->is_set_key = false;
 	init_mgmt_queue(ieee);
 
-	ieee->sta_edca_param[0] = 0x0000A403;
-	ieee->sta_edca_param[1] = 0x0000A427;
-	ieee->sta_edca_param[2] = 0x005E4342;
-	ieee->sta_edca_param[3] = 0x002F3262;
 	ieee->aggregation = true;
-	ieee->enable_rx_imm_BA = true;
 	ieee->tx_pending.txb = NULL;
 
 	_setup_timer(&ieee->associate_timer,

commit 79b7d693d57bba56dcfb66e59189b98dbdc39ede
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Mon Jun 15 21:06:02 2015 +0200

    staging: rtl8192e: Remove rtllib_is_shortslot()
    
    This function was declared but never unused.
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index a1237729938f..dc3fc129f7e8 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -28,11 +28,6 @@ short rtllib_is_54g(struct rtllib_network *net)
 	return (net->rates_ex_len > 0) || (net->rates_len > 4);
 }
 
-short rtllib_is_shortslot(const struct rtllib_network *net)
-{
-	return net->capability & WLAN_CAPABILITY_SHORT_SLOT_TIME;
-}
-
 /* returns the total length needed for placing the RATE MFIE
  * tag and the EXTENDED RATE MFIE tag if needed.
  * It encludes two bytes per tag for the tag itself and its len

commit 4b2f218471a63214a5e1785421eb4cf9aae0ba1d
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Mon Jun 15 21:06:01 2015 +0200

    staging: rtl8192e: Remove rtllib_wake_queue()
    
    This function was declared but never unused.
    Also remove dequeue_mgmt() and rtllib_resume_tx() that are
    no longer used.
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 95e739eb057c..a1237729938f 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -147,21 +147,6 @@ static void enqueue_mgmt(struct rtllib_device *ieee, struct sk_buff *skb)
 
 }
 
-static struct sk_buff *dequeue_mgmt(struct rtllib_device *ieee)
-{
-	struct sk_buff *ret;
-
-	if (ieee->mgmt_queue_tail == ieee->mgmt_queue_head)
-		return NULL;
-
-	ret = ieee->mgmt_queue_ring[ieee->mgmt_queue_tail];
-
-	ieee->mgmt_queue_tail =
-		(ieee->mgmt_queue_tail+1) % MGMT_QUEUE_NUM;
-
-	return ret;
-}
-
 static void init_mgmt_queue(struct rtllib_device *ieee)
 {
 	ieee->mgmt_queue_tail = ieee->mgmt_queue_head = 0;
@@ -2532,30 +2517,6 @@ void rtllib_softmac_xmit(struct rtllib_txb *txb, struct rtllib_device *ieee)
 
 }
 
-/* called with ieee->lock acquired */
-static void rtllib_resume_tx(struct rtllib_device *ieee)
-{
-	int i;
-
-	for (i = ieee->tx_pending.frag; i < ieee->tx_pending.txb->nr_frags;
-	     i++) {
-
-		if (ieee->queue_stop) {
-			ieee->tx_pending.frag = i;
-			return;
-		}
-
-		ieee->softmac_data_hard_start_xmit(
-			ieee->tx_pending.txb->fragments[i],
-			ieee->dev, ieee->rate);
-		ieee->stats.tx_packets++;
-	}
-
-	rtllib_txb_free(ieee->tx_pending.txb);
-	ieee->tx_pending.txb = NULL;
-}
-
-
 void rtllib_reset_queue(struct rtllib_device *ieee)
 {
 	unsigned long flags;
@@ -2572,47 +2533,6 @@ void rtllib_reset_queue(struct rtllib_device *ieee)
 }
 EXPORT_SYMBOL(rtllib_reset_queue);
 
-void rtllib_wake_queue(struct rtllib_device *ieee)
-{
-
-	unsigned long flags;
-	struct sk_buff *skb;
-	struct rtllib_hdr_3addr  *header;
-
-	spin_lock_irqsave(&ieee->lock, flags);
-	if (!ieee->queue_stop)
-		goto exit;
-
-	ieee->queue_stop = 0;
-
-	if (ieee->softmac_features & IEEE_SOFTMAC_SINGLE_QUEUE) {
-		while (!ieee->queue_stop && (skb = dequeue_mgmt(ieee))) {
-
-			header = (struct rtllib_hdr_3addr  *) skb->data;
-
-			header->seq_ctl = cpu_to_le16(ieee->seq_ctrl[0] << 4);
-
-			if (ieee->seq_ctrl[0] == 0xFFF)
-				ieee->seq_ctrl[0] = 0;
-			else
-				ieee->seq_ctrl[0]++;
-
-			ieee->softmac_data_hard_start_xmit(skb, ieee->dev,
-							   ieee->basic_rate);
-		}
-	}
-	if (!ieee->queue_stop && ieee->tx_pending.txb)
-		rtllib_resume_tx(ieee);
-
-	if (!ieee->queue_stop && netif_queue_stopped(ieee->dev)) {
-		ieee->softmac_stats.swtxawake++;
-		netif_wake_queue(ieee->dev);
-	}
-
-exit:
-	spin_unlock_irqrestore(&ieee->lock, flags);
-}
-
 void rtllib_stop_all_queues(struct rtllib_device *ieee)
 {
 	unsigned int i;

commit f52598466088295caf013713a1472588731c094f
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Mon Jun 15 21:06:00 2015 +0200

    staging: rtl8192e: Remove rtllib_stop_queue()
    
    This function was declared but never unused.
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 7ce58e248f2d..95e739eb057c 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -2613,18 +2613,6 @@ void rtllib_wake_queue(struct rtllib_device *ieee)
 	spin_unlock_irqrestore(&ieee->lock, flags);
 }
 
-
-void rtllib_stop_queue(struct rtllib_device *ieee)
-{
-
-	if (!netif_queue_stopped(ieee->dev)) {
-		netif_stop_queue(ieee->dev);
-		ieee->softmac_stats.swtxstop++;
-	}
-	ieee->queue_stop = 1;
-
-}
-
 void rtllib_stop_all_queues(struct rtllib_device *ieee)
 {
 	unsigned int i;

commit fa70ae09e645da2312912570eba04160edff7835
Author: Gnanachandran Dhanapal <gdhanapa@visteon.com>
Date:   Tue Jun 9 14:47:49 2015 +0000

    Staging: rtl8192e: Casting correct Endianness
    
    Casting correct Endianness for __le16 variable used in assignment and
    condition check
    
    Signed-off-by: Gnanachandran Dhanapal <gdhanapa@visteon.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 9dce121d660e..7ce58e248f2d 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -1265,7 +1265,7 @@ inline struct sk_buff *rtllib_association_req(struct rtllib_network *beacon,
 		skb_put(skb, sizeof(struct rtllib_assoc_request_frame) + 2);
 
 
-	hdr->header.frame_ctl = RTLLIB_STYPE_ASSOC_REQ;
+	hdr->header.frame_ctl = cpu_to_le16(RTLLIB_STYPE_ASSOC_REQ);
 	hdr->header.duration_id = cpu_to_le16(37);
 	ether_addr_copy(hdr->header.addr1, beacon->bssid);
 	ether_addr_copy(hdr->header.addr2, ieee->dev->dev_addr);
@@ -2243,9 +2243,10 @@ inline int rtllib_rx_assoc_resp(struct rtllib_device *ieee, struct sk_buff *skb,
 	u8 *ies;
 	struct rtllib_assoc_response_frame *assoc_resp;
 	struct rtllib_hdr_3addr *header = (struct rtllib_hdr_3addr *) skb->data;
+	u16 frame_ctl = le16_to_cpu(header->frame_ctl);
 
 	netdev_dbg(ieee->dev, "received [RE]ASSOCIATION RESPONSE (%d)\n",
-		   WLAN_FC_GET_STYPE(header->frame_ctl));
+		   WLAN_FC_GET_STYPE(frame_ctl));
 
 	if ((ieee->softmac_features & IEEE_SOFTMAC_ASSOCIATE) &&
 	     ieee->state == RTLLIB_ASSOCIATING_AUTHENTICATED &&
@@ -2389,6 +2390,7 @@ inline int rtllib_rx_auth(struct rtllib_device *ieee, struct sk_buff *skb,
 inline int rtllib_rx_deauth(struct rtllib_device *ieee, struct sk_buff *skb)
 {
 	struct rtllib_hdr_3addr *header = (struct rtllib_hdr_3addr *) skb->data;
+	u16 frame_ctl;
 
 	if (memcmp(header->addr3, ieee->current_network.bssid, ETH_ALEN) != 0)
 		return 0;
@@ -2399,9 +2401,10 @@ inline int rtllib_rx_deauth(struct rtllib_device *ieee, struct sk_buff *skb)
 	if ((ieee->softmac_features & IEEE_SOFTMAC_ASSOCIATE) &&
 	    ieee->state == RTLLIB_LINKED &&
 	    (ieee->iw_mode == IW_MODE_INFRA)) {
+		frame_ctl = le16_to_cpu(header->frame_ctl);
 		netdev_info(ieee->dev,
 			    "==========>received disassoc/deauth(%x) frame, reason code:%x\n",
-			    WLAN_FC_GET_STYPE(header->frame_ctl),
+			    WLAN_FC_GET_STYPE(frame_ctl),
 			    ((struct rtllib_disassoc *)skb->data)->reason);
 		ieee->state = RTLLIB_ASSOCIATING;
 		ieee->softmac_stats.reassoc++;
@@ -2427,11 +2430,13 @@ inline int rtllib_rx_frame_softmac(struct rtllib_device *ieee,
 				   u16 stype)
 {
 	struct rtllib_hdr_3addr *header = (struct rtllib_hdr_3addr *) skb->data;
+	u16 frame_ctl;
 
 	if (!ieee->proto_started)
 		return 0;
 
-	switch (WLAN_FC_GET_STYPE(header->frame_ctl)) {
+	frame_ctl = le16_to_cpu(header->frame_ctl);
+	switch (WLAN_FC_GET_STYPE(frame_ctl)) {
 	case RTLLIB_STYPE_ASSOC_RESP:
 	case RTLLIB_STYPE_REASSOC_RESP:
 		if (rtllib_rx_assoc_resp(ieee, skb, rx_stats) == 1)

commit 35e33b0468ab3b3f5b610bfa4fc9367a3b7c09a8
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Sun May 31 20:19:40 2015 +0200

    staging: rtl8192e: Fix LONG_LINE warnings
    
    Fix most of simple LONG_LINE warnings. None of the changes should affect
    behaviour of code, so several modifications are included in this patch:
    - Code is reindented where needed
    - Local variable names are compacted (priv -> p)
    - Unnecessary casts are removed
    - Nested ifs are replaced with logical and
    - a = b = c = d expressions are split
    - Replace if/then series with clamp_t()
    - Removed unneeded scopes
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 9c83e3b14a39..9dce121d660e 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -272,9 +272,10 @@ inline void softmac_mgmt_xmit(struct sk_buff *skb, struct rtllib_device *ieee)
 			ieee->seq_ctrl[0]++;
 
 		/* check whether the managed packet queued greater than 5 */
-		if (!ieee->check_nic_enough_desc(ieee->dev, tcb_desc->queue_index) ||
-		    (skb_queue_len(&ieee->skb_waitQ[tcb_desc->queue_index]) != 0) ||
-		    (ieee->queue_stop)) {
+		if (!ieee->check_nic_enough_desc(ieee->dev,
+						 tcb_desc->queue_index) ||
+		    skb_queue_len(&ieee->skb_waitQ[tcb_desc->queue_index]) ||
+		    ieee->queue_stop) {
 			/* insert the skb packet to the management queue
 			 *
 			 * as for the completion function, it does not need
@@ -1483,7 +1484,8 @@ static void rtllib_associate_step1(struct rtllib_device *ieee, u8 *daddr)
 	}
 }
 
-static void rtllib_auth_challenge(struct rtllib_device *ieee, u8 *challenge, int chlen)
+static void rtllib_auth_challenge(struct rtllib_device *ieee, u8 *challenge,
+				  int chlen)
 {
 	u8 *c;
 	struct sk_buff *skb;
@@ -1740,7 +1742,7 @@ inline void rtllib_softmac_new_net(struct rtllib_device *ieee,
 				/* Join the network for the first time */
 				ieee->AsocRetryCount = 0;
 				if ((ieee->current_network.qos_data.supported == 1) &&
-				   ieee->current_network.bssht.bdSupportHT)
+				    ieee->current_network.bssht.bdSupportHT)
 					HTResetSelfAndSavePeerSetting(ieee,
 						 &(ieee->current_network));
 				else
@@ -1755,14 +1757,19 @@ inline void rtllib_softmac_new_net(struct rtllib_device *ieee,
 					   &ieee->associate_procedure_wq, 0);
 			} else {
 				if (rtllib_is_54g(&ieee->current_network) &&
-					(ieee->modulation & RTLLIB_OFDM_MODULATION)) {
+				    (ieee->modulation &
+				     RTLLIB_OFDM_MODULATION)) {
 					ieee->rate = 108;
-					ieee->SetWirelessMode(ieee->dev, IEEE_G);
-					netdev_info(ieee->dev, "Using G rates\n");
+					ieee->SetWirelessMode(ieee->dev,
+							      IEEE_G);
+					netdev_info(ieee->dev,
+						    "Using G rates\n");
 				} else {
 					ieee->rate = 22;
-					ieee->SetWirelessMode(ieee->dev, IEEE_B);
-					netdev_info(ieee->dev, "Using B rates\n");
+					ieee->SetWirelessMode(ieee->dev,
+							      IEEE_B);
+					netdev_info(ieee->dev,
+						    "Using B rates\n");
 				}
 				memset(ieee->dot11HTOperationalRateSet, 0, 16);
 				ieee->state = RTLLIB_LINKED;
@@ -2023,7 +2030,7 @@ static short rtllib_sta_ps_sleep(struct rtllib_device *ieee, u64 *time)
 		if (ieee->bAwakePktSent) {
 			pPSC->LPSAwakeIntvl = 1;
 		} else {
-			u8		MaxPeriod = 1;
+			u8 MaxPeriod = 1;
 
 			if (pPSC->LPSAwakeIntvl == 0)
 				pPSC->LPSAwakeIntvl = 1;
@@ -2194,7 +2201,8 @@ void rtllib_ps_tx_ack(struct rtllib_device *ieee, short success)
 }
 EXPORT_SYMBOL(rtllib_ps_tx_ack);
 
-static void rtllib_process_action(struct rtllib_device *ieee, struct sk_buff *skb)
+static void rtllib_process_action(struct rtllib_device *ieee,
+				  struct sk_buff *skb)
 {
 	struct rtllib_hdr_3addr *header = (struct rtllib_hdr_3addr *) skb->data;
 	u8 *act = rtllib_get_payload((struct rtllib_hdr *)header);
@@ -3674,8 +3682,8 @@ static void rtllib_MgntDisconnectIBSS(struct rtllib_device *rtllib)
 
 }
 
-static void rtllib_MlmeDisassociateRequest(struct rtllib_device *rtllib, u8 *asSta,
-				    u8 asRsn)
+static void rtllib_MlmeDisassociateRequest(struct rtllib_device *rtllib,
+					   u8 *asSta, u8 asRsn)
 {
 	u8 i;
 	u8	OpMode;

commit e9fea2ecb018e5ca4dad80ac36b34ba9c320415a
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Sun May 31 20:19:33 2015 +0200

    staging: rtl8192e: Remove RTLLIB_DEBUG_MGMT()
    
    - Use netdev_dbg() instead of RTLLIB_DEBUG_MGMT()
    - Remove RTLLIB_DEBUG_MGMT()
    - Pass net_device to auth_parse(), auth_rq_parse() and assoc_rq_parse()
    - Remove duplicated messages
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 4ce35259d5d6..9c83e3b14a39 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -1439,10 +1439,10 @@ void rtllib_associate_abort(struct rtllib_device *ieee)
 	 * with, so we retry or just get back to NO_LINK and scanning
 	 */
 	if (ieee->state == RTLLIB_ASSOCIATING_AUTHENTICATING) {
-		RTLLIB_DEBUG_MGMT("Authentication failed\n");
+		netdev_dbg(ieee->dev, "Authentication failed\n");
 		ieee->softmac_stats.no_auth_rs++;
 	} else {
-		RTLLIB_DEBUG_MGMT("Association failed\n");
+		netdev_dbg(ieee->dev, "Association failed\n");
 		ieee->softmac_stats.no_ass_rs++;
 	}
 
@@ -1464,7 +1464,7 @@ static void rtllib_associate_step1(struct rtllib_device *ieee, u8 *daddr)
 	struct rtllib_network *beacon = &ieee->current_network;
 	struct sk_buff *skb;
 
-	RTLLIB_DEBUG_MGMT("Stopping scan\n");
+	netdev_dbg(ieee->dev, "Stopping scan\n");
 
 	ieee->softmac_stats.tx_auth_rq++;
 
@@ -1474,7 +1474,7 @@ static void rtllib_associate_step1(struct rtllib_device *ieee, u8 *daddr)
 		rtllib_associate_abort(ieee);
 	else {
 		ieee->state = RTLLIB_ASSOCIATING_AUTHENTICATING;
-		RTLLIB_DEBUG_MGMT("Sending authentication request\n");
+		netdev_dbg(ieee->dev, "Sending authentication request\n");
 		softmac_mgmt_xmit(skb, ieee);
 		if (!timer_pending(&ieee->associate_timer)) {
 			ieee->associate_timer.expires = jiffies + (HZ / 2);
@@ -1502,7 +1502,8 @@ static void rtllib_auth_challenge(struct rtllib_device *ieee, u8 *challenge, int
 		*(c++) = chlen;
 		memcpy(c, challenge, chlen);
 
-		RTLLIB_DEBUG_MGMT("Sending authentication challenge response\n");
+		netdev_dbg(ieee->dev,
+			   "Sending authentication challenge response\n");
 
 		rtllib_encrypt_fragment(ieee, skb,
 					sizeof(struct rtllib_hdr_3addr));
@@ -1520,7 +1521,7 @@ static void rtllib_associate_step2(struct rtllib_device *ieee)
 
 	del_timer_sync(&ieee->associate_timer);
 
-	RTLLIB_DEBUG_MGMT("Sending association request\n");
+	netdev_dbg(ieee->dev, "Sending association request\n");
 
 	ieee->softmac_stats.tx_ass_rq++;
 	skb = rtllib_association_req(beacon, ieee);
@@ -1793,14 +1794,15 @@ void rtllib_softmac_check_all_nets(struct rtllib_device *ieee)
 	spin_unlock_irqrestore(&ieee->lock, flags);
 }
 
-static inline u16 auth_parse(struct sk_buff *skb, u8 **challenge, int *chlen)
+static inline u16 auth_parse(struct net_device *dev, struct sk_buff *skb,
+			     u8 **challenge, int *chlen)
 {
 	struct rtllib_authentication *a;
 	u8 *t;
 
 	if (skb->len <  (sizeof(struct rtllib_authentication) -
 	    sizeof(struct rtllib_info_element))) {
-		RTLLIB_DEBUG_MGMT("invalid len in auth resp: %d\n", skb->len);
+		netdev_dbg(dev, "invalid len in auth resp: %d\n", skb->len);
 		return 0xcafe;
 	}
 	*challenge = NULL;
@@ -1818,14 +1820,13 @@ static inline u16 auth_parse(struct sk_buff *skb, u8 **challenge, int *chlen)
 	return le16_to_cpu(a->status);
 }
 
-static int auth_rq_parse(struct sk_buff *skb, u8 *dest)
+static int auth_rq_parse(struct net_device *dev, struct sk_buff *skb, u8 *dest)
 {
 	struct rtllib_authentication *a;
 
 	if (skb->len <  (sizeof(struct rtllib_authentication) -
 	    sizeof(struct rtllib_info_element))) {
-		RTLLIB_DEBUG_MGMT("invalid len in auth request: %d\n",
-				  skb->len);
+		netdev_dbg(dev, "invalid len in auth request: %d\n", skb->len);
 		return -1;
 	}
 	a = (struct rtllib_authentication *) skb->data;
@@ -1884,14 +1885,13 @@ static short probe_rq_parse(struct rtllib_device *ieee, struct sk_buff *skb,
 	return !strncmp(ssid, ieee->current_network.ssid, ssidlen);
 }
 
-static int assoc_rq_parse(struct sk_buff *skb, u8 *dest)
+static int assoc_rq_parse(struct net_device *dev, struct sk_buff *skb, u8 *dest)
 {
 	struct rtllib_assoc_request_frame *a;
 
 	if (skb->len < (sizeof(struct rtllib_assoc_request_frame) -
 		sizeof(struct rtllib_info_element))) {
-
-		RTLLIB_DEBUG_MGMT("invalid len in auth request:%d\n", skb->len);
+		netdev_dbg(dev, "invalid len in auth request:%d\n", skb->len);
 		return -1;
 	}
 
@@ -1909,7 +1909,8 @@ static inline u16 assoc_parse(struct rtllib_device *ieee, struct sk_buff *skb,
 	u16 status_code;
 
 	if (skb->len <  sizeof(struct rtllib_assoc_response_frame)) {
-		RTLLIB_DEBUG_MGMT("invalid len in auth resp: %d\n", skb->len);
+		netdev_dbg(ieee->dev, "Invalid len in auth resp: %d\n",
+			   skb->len);
 		return 0xcafe;
 	}
 
@@ -1949,7 +1950,7 @@ static inline void rtllib_rx_auth_rq(struct rtllib_device *ieee,
 
 	ieee->softmac_stats.rx_auth_rq++;
 
-	status = auth_rq_parse(skb, dest);
+	status = auth_rq_parse(ieee->dev, skb, dest);
 	if (status != -1)
 		rtllib_resp_to_auth(ieee, status, dest);
 }
@@ -1961,7 +1962,7 @@ static inline void rtllib_rx_assoc_rq(struct rtllib_device *ieee,
 
 
 	ieee->softmac_stats.rx_ass_rq++;
-	if (assoc_rq_parse(skb, dest) != -1)
+	if (assoc_rq_parse(ieee->dev, skb, dest) != -1)
 		rtllib_resp_to_assoc_rq(ieee, dest);
 
 	netdev_info(ieee->dev, "New client associated: %pM\n", dest);
@@ -2235,8 +2236,8 @@ inline int rtllib_rx_assoc_resp(struct rtllib_device *ieee, struct sk_buff *skb,
 	struct rtllib_assoc_response_frame *assoc_resp;
 	struct rtllib_hdr_3addr *header = (struct rtllib_hdr_3addr *) skb->data;
 
-	RTLLIB_DEBUG_MGMT("received [RE]ASSOCIATION RESPONSE (%d)\n",
-			  WLAN_FC_GET_STYPE(header->frame_ctl));
+	netdev_dbg(ieee->dev, "received [RE]ASSOCIATION RESPONSE (%d)\n",
+		   WLAN_FC_GET_STYPE(header->frame_ctl));
 
 	if ((ieee->softmac_features & IEEE_SOFTMAC_ASSOCIATE) &&
 	     ieee->state == RTLLIB_ASSOCIATING_AUTHENTICATED &&
@@ -2297,9 +2298,6 @@ inline int rtllib_rx_assoc_resp(struct rtllib_device *ieee, struct sk_buff *skb,
 			netdev_info(ieee->dev,
 				    "Association response status code 0x%x\n",
 				    errcode);
-			RTLLIB_DEBUG_MGMT(
-				"Association response status code 0x%x\n",
-				errcode);
 			if (ieee->AsocRetryCount < RT_ASOC_RETRY_LIMIT)
 				queue_delayed_work_rsl(ieee->wq,
 					 &ieee->associate_procedure_wq, 0);
@@ -2317,13 +2315,10 @@ static void rtllib_rx_auth_resp(struct rtllib_device *ieee, struct sk_buff *skb)
 	int chlen = 0;
 	bool bSupportNmode = true, bHalfSupportNmode = false;
 
-	errcode = auth_parse(skb, &challenge, &chlen);
+	errcode = auth_parse(ieee->dev, skb, &challenge, &chlen);
 
 	if (errcode) {
 		ieee->softmac_stats.rx_auth_rs_err++;
-		RTLLIB_DEBUG_MGMT("Authentication respose status code 0x%x",
-				  errcode);
-
 		netdev_info(ieee->dev,
 			    "Authentication respose status code 0x%x", errcode);
 		rtllib_associate_abort(ieee);
@@ -2373,7 +2368,8 @@ inline int rtllib_rx_auth(struct rtllib_device *ieee, struct sk_buff *skb,
 	if (ieee->softmac_features & IEEE_SOFTMAC_ASSOCIATE) {
 		if (ieee->state == RTLLIB_ASSOCIATING_AUTHENTICATING &&
 		    (ieee->iw_mode == IW_MODE_INFRA)) {
-			RTLLIB_DEBUG_MGMT("Received authentication response");
+			netdev_dbg(ieee->dev,
+				   "Received authentication response");
 			rtllib_rx_auth_resp(ieee, skb);
 		} else if (ieee->iw_mode == IW_MODE_MASTER) {
 			rtllib_rx_auth_rq(ieee, skb);

commit 11e672c3e2d2a10189a6292678f5174597927076
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Sun May 31 20:19:26 2015 +0200

    staging: rtl8192e: Replace RTLLIB_DEBUG(DL_ERR) with netdev_*()
    
    Replace all RTLLIB_DEBUG(RTLLIB_DL_ERR, *) calls with netdev_err()
    for errors that really should be reported to user.
    Use netdev_warn() for the rest.
    Rephrase some of the messages to make them more readable/compact.
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 5d69f98bf355..4ce35259d5d6 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -2200,8 +2200,8 @@ static void rtllib_process_action(struct rtllib_device *ieee, struct sk_buff *sk
 	u8 category = 0;
 
 	if (act == NULL) {
-		RTLLIB_DEBUG(RTLLIB_DL_ERR,
-			     "error to get payload of action frame\n");
+		netdev_warn(ieee->dev,
+			    "Error getting payload of action frame\n");
 		return;
 	}
 
@@ -3074,7 +3074,7 @@ void rtllib_softmac_init(struct rtllib_device *ieee)
 		ieee->seq_ctrl[i] = 0;
 	ieee->pDot11dInfo = kzalloc(sizeof(struct rt_dot11d_info), GFP_ATOMIC);
 	if (!ieee->pDot11dInfo)
-		RTLLIB_DEBUG(RTLLIB_DL_ERR, "can't alloc memory for DOT11D\n");
+		netdev_err(ieee->dev, "Can't alloc memory for DOT11D\n");
 	ieee->LinkDetectInfo.SlotIndex = 0;
 	ieee->LinkDetectInfo.SlotNum = 2;
 	ieee->LinkDetectInfo.NumRecvBcnInPeriod = 0;

commit c2f8b4ab8c05398a08ec91c2958f62ebc55296f4
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Sun May 31 20:19:24 2015 +0200

    staging: rtl8192e: Replace memcmp() with ether_addr_equal()
    
    Use dedicated macro to compare ethernet addresses in probe_rq_parse().
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 2f562de10071..5d69f98bf355 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -1853,7 +1853,7 @@ static short probe_rq_parse(struct rtllib_device *ieee, struct sk_buff *skb,
 		return -1; /* corrupted */
 
 	bssid_match =
-	  (memcmp(header->addr3, ieee->current_network.bssid, ETH_ALEN) != 0) &&
+	  (!ether_addr_equal(header->addr3, ieee->current_network.bssid)) &&
 	  (!is_broadcast_ether_addr(header->addr3));
 	if (bssid_match)
 		return -1;

commit b57ceb19aba7d40403ca985ec565db8db20f4331
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Sun May 31 20:19:22 2015 +0200

    staging: rtl8192e: Fix PREFER_ETHER_ADDR_COPY warnings
    
    Replace memcpy() with ether_addr_copy() where possible to make
    checkpatch.pl happy.
    Change was target tested (download 1Mb file over WPA2 network)
    with BUG trap for unaligned addresses in ether_addr_copy()
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 051105d77a21..2f562de10071 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -372,7 +372,7 @@ static inline struct sk_buff *rtllib_probe_req(struct rtllib_device *ieee)
 	req->header.duration_id = 0;
 
 	memset(req->header.addr1, 0xff, ETH_ALEN);
-	memcpy(req->header.addr2, ieee->dev->dev_addr, ETH_ALEN);
+	ether_addr_copy(req->header.addr2, ieee->dev->dev_addr);
 	memset(req->header.addr3, 0xff, ETH_ALEN);
 
 	tag = (u8 *) skb_put(skb, len + 2 + rate_len);
@@ -815,9 +815,9 @@ inline struct sk_buff *rtllib_authentication_req(struct rtllib_network *beacon,
 		auth->header.frame_ctl |= cpu_to_le16(RTLLIB_FCTL_WEP);
 
 	auth->header.duration_id = cpu_to_le16(0x013a);
-	memcpy(auth->header.addr1, beacon->bssid, ETH_ALEN);
-	memcpy(auth->header.addr2, ieee->dev->dev_addr, ETH_ALEN);
-	memcpy(auth->header.addr3, beacon->bssid, ETH_ALEN);
+	ether_addr_copy(auth->header.addr1, beacon->bssid);
+	ether_addr_copy(auth->header.addr2, ieee->dev->dev_addr);
+	ether_addr_copy(auth->header.addr3, beacon->bssid);
 	if (ieee->auth_mode == 0)
 		auth->algorithm = WLAN_AUTH_OPEN;
 	else if (ieee->auth_mode == 1)
@@ -909,9 +909,9 @@ static struct sk_buff *rtllib_probe_resp(struct rtllib_device *ieee,
 
 	beacon_buf = (struct rtllib_probe_response *) skb_put(skb,
 		     (beacon_size - ieee->tx_headroom));
-	memcpy(beacon_buf->header.addr1, dest, ETH_ALEN);
-	memcpy(beacon_buf->header.addr2, ieee->dev->dev_addr, ETH_ALEN);
-	memcpy(beacon_buf->header.addr3, ieee->current_network.bssid, ETH_ALEN);
+	ether_addr_copy(beacon_buf->header.addr1, dest);
+	ether_addr_copy(beacon_buf->header.addr2, ieee->dev->dev_addr);
+	ether_addr_copy(beacon_buf->header.addr3, ieee->current_network.bssid);
 
 	beacon_buf->header.duration_id = 0;
 	beacon_buf->beacon_interval =
@@ -1006,9 +1006,9 @@ static struct sk_buff *rtllib_assoc_resp(struct rtllib_device *ieee, u8 *dest)
 		skb_put(skb, sizeof(struct rtllib_assoc_response_frame));
 
 	assoc->header.frame_ctl = cpu_to_le16(RTLLIB_STYPE_ASSOC_RESP);
-	memcpy(assoc->header.addr1, dest, ETH_ALEN);
-	memcpy(assoc->header.addr3, ieee->dev->dev_addr, ETH_ALEN);
-	memcpy(assoc->header.addr2, ieee->dev->dev_addr, ETH_ALEN);
+	ether_addr_copy(assoc->header.addr1, dest);
+	ether_addr_copy(assoc->header.addr3, ieee->dev->dev_addr);
+	ether_addr_copy(assoc->header.addr2, ieee->dev->dev_addr);
 	assoc->capability = cpu_to_le16(ieee->iw_mode == IW_MODE_MASTER ?
 		WLAN_CAPABILITY_ESS : WLAN_CAPABILITY_IBSS);
 
@@ -1063,9 +1063,9 @@ static struct sk_buff *rtllib_auth_resp(struct rtllib_device *ieee, int status,
 	auth->transaction = cpu_to_le16(2);
 	auth->algorithm = cpu_to_le16(WLAN_AUTH_OPEN);
 
-	memcpy(auth->header.addr3, ieee->dev->dev_addr, ETH_ALEN);
-	memcpy(auth->header.addr2, ieee->dev->dev_addr, ETH_ALEN);
-	memcpy(auth->header.addr1, dest, ETH_ALEN);
+	ether_addr_copy(auth->header.addr3, ieee->dev->dev_addr);
+	ether_addr_copy(auth->header.addr2, ieee->dev->dev_addr);
+	ether_addr_copy(auth->header.addr1, dest);
 	auth->header.frame_ctl = cpu_to_le16(RTLLIB_STYPE_AUTH);
 	return skb;
 
@@ -1086,9 +1086,9 @@ static struct sk_buff *rtllib_null_func(struct rtllib_device *ieee, short pwr)
 	hdr = (struct rtllib_hdr_3addr *)skb_put(skb,
 	      sizeof(struct rtllib_hdr_3addr));
 
-	memcpy(hdr->addr1, ieee->current_network.bssid, ETH_ALEN);
-	memcpy(hdr->addr2, ieee->dev->dev_addr, ETH_ALEN);
-	memcpy(hdr->addr3, ieee->current_network.bssid, ETH_ALEN);
+	ether_addr_copy(hdr->addr1, ieee->current_network.bssid);
+	ether_addr_copy(hdr->addr2, ieee->dev->dev_addr);
+	ether_addr_copy(hdr->addr3, ieee->current_network.bssid);
 
 	hdr->frame_ctl = cpu_to_le16(RTLLIB_FTYPE_DATA |
 		RTLLIB_STYPE_NULLFUNC | RTLLIB_FCTL_TODS |
@@ -1113,8 +1113,8 @@ static struct sk_buff *rtllib_pspoll_func(struct rtllib_device *ieee)
 	hdr = (struct rtllib_pspoll_hdr *)skb_put(skb,
 	      sizeof(struct rtllib_pspoll_hdr));
 
-	memcpy(hdr->bssid, ieee->current_network.bssid, ETH_ALEN);
-	memcpy(hdr->ta, ieee->dev->dev_addr, ETH_ALEN);
+	ether_addr_copy(hdr->bssid, ieee->current_network.bssid);
+	ether_addr_copy(hdr->ta, ieee->dev->dev_addr);
 
 	hdr->aid = cpu_to_le16(ieee->assoc_id | 0xc000);
 	hdr->frame_ctl = cpu_to_le16(RTLLIB_FTYPE_CTL | RTLLIB_STYPE_PSPOLL |
@@ -1266,11 +1266,11 @@ inline struct sk_buff *rtllib_association_req(struct rtllib_network *beacon,
 
 	hdr->header.frame_ctl = RTLLIB_STYPE_ASSOC_REQ;
 	hdr->header.duration_id = cpu_to_le16(37);
-	memcpy(hdr->header.addr1, beacon->bssid, ETH_ALEN);
-	memcpy(hdr->header.addr2, ieee->dev->dev_addr, ETH_ALEN);
-	memcpy(hdr->header.addr3, beacon->bssid, ETH_ALEN);
+	ether_addr_copy(hdr->header.addr1, beacon->bssid);
+	ether_addr_copy(hdr->header.addr2, ieee->dev->dev_addr);
+	ether_addr_copy(hdr->header.addr3, beacon->bssid);
 
-	memcpy(ieee->ap_mac_addr, beacon->bssid, ETH_ALEN);
+	ether_addr_copy(ieee->ap_mac_addr, beacon->bssid);
 
 	hdr->capability = cpu_to_le16(WLAN_CAPABILITY_ESS);
 	if (beacon->capability & WLAN_CAPABILITY_PRIVACY)
@@ -1830,7 +1830,7 @@ static int auth_rq_parse(struct sk_buff *skb, u8 *dest)
 	}
 	a = (struct rtllib_authentication *) skb->data;
 
-	memcpy(dest, a->header.addr2, ETH_ALEN);
+	ether_addr_copy(dest, a->header.addr2);
 
 	if (le16_to_cpu(a->algorithm) != WLAN_AUTH_OPEN)
 		return  WLAN_STATUS_NOT_SUPPORTED_AUTH_ALG;
@@ -1858,7 +1858,7 @@ static short probe_rq_parse(struct rtllib_device *ieee, struct sk_buff *skb,
 	if (bssid_match)
 		return -1;
 
-	memcpy(src, header->addr2, ETH_ALEN);
+	ether_addr_copy(src, header->addr2);
 
 	skbend = (u8 *)skb->data + skb->len;
 
@@ -1897,7 +1897,7 @@ static int assoc_rq_parse(struct sk_buff *skb, u8 *dest)
 
 	a = (struct rtllib_assoc_request_frame *) skb->data;
 
-	memcpy(dest, a->header.addr2, ETH_ALEN);
+	ether_addr_copy(dest, a->header.addr2);
 
 	return 0;
 }
@@ -2652,7 +2652,7 @@ void rtllib_start_master_bss(struct rtllib_device *ieee)
 		ieee->ssid_set = 1;
 	}
 
-	memcpy(ieee->current_network.bssid, ieee->dev->dev_addr, ETH_ALEN);
+	ether_addr_copy(ieee->current_network.bssid, ieee->dev->dev_addr);
 
 	ieee->set_chan(ieee->dev, ieee->current_network.channel);
 	ieee->state = RTLLIB_LINKED;
@@ -3519,9 +3519,9 @@ inline struct sk_buff *rtllib_disauth_skb(struct rtllib_network *beacon,
 	disauth->header.frame_ctl = cpu_to_le16(RTLLIB_STYPE_DEAUTH);
 	disauth->header.duration_id = 0;
 
-	memcpy(disauth->header.addr1, beacon->bssid, ETH_ALEN);
-	memcpy(disauth->header.addr2, ieee->dev->dev_addr, ETH_ALEN);
-	memcpy(disauth->header.addr3, beacon->bssid, ETH_ALEN);
+	ether_addr_copy(disauth->header.addr1, beacon->bssid);
+	ether_addr_copy(disauth->header.addr2, ieee->dev->dev_addr);
+	ether_addr_copy(disauth->header.addr3, beacon->bssid);
 
 	disauth->reason = cpu_to_le16(asRsn);
 	return skb;
@@ -3546,9 +3546,9 @@ inline struct sk_buff *rtllib_disassociate_skb(struct rtllib_network *beacon,
 	disass->header.frame_ctl = cpu_to_le16(RTLLIB_STYPE_DISASSOC);
 	disass->header.duration_id = 0;
 
-	memcpy(disass->header.addr1, beacon->bssid, ETH_ALEN);
-	memcpy(disass->header.addr2, ieee->dev->dev_addr, ETH_ALEN);
-	memcpy(disass->header.addr3, beacon->bssid, ETH_ALEN);
+	ether_addr_copy(disass->header.addr1, beacon->bssid);
+	ether_addr_copy(disass->header.addr2, ieee->dev->dev_addr);
+	ether_addr_copy(disass->header.addr3, beacon->bssid);
 
 	disass->reason = cpu_to_le16(asRsn);
 	return skb;

commit 06c111072892d3f5fed9d73d1becb59d3f33410b
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Sun May 31 20:19:21 2015 +0200

    staging: rtl8192e: Make ethernet addresses properly aligned
    
    Reorder ethernet addresses allocated on stack or in non-packed
    structures to keep them aligned(2).
    Use ETH_ALEN as array length in places where it was hardcoded to 6.
    
    Alignment verified using pahole where possible and target-tested
    with BUG_ON() trap in ether_addr_copy.
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index cd758feac88c..051105d77a21 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -1957,9 +1957,9 @@ static inline void rtllib_rx_auth_rq(struct rtllib_device *ieee,
 static inline void rtllib_rx_assoc_rq(struct rtllib_device *ieee,
 				      struct sk_buff *skb)
 {
-
 	u8 dest[ETH_ALEN];
 
+
 	ieee->softmac_stats.rx_ass_rq++;
 	if (assoc_rq_parse(skb, dest) != -1)
 		rtllib_resp_to_assoc_rq(ieee, dest);
@@ -2912,7 +2912,7 @@ static void rtllib_associate_retry_wq(void *data)
 
 struct sk_buff *rtllib_get_beacon_(struct rtllib_device *ieee)
 {
-	u8 broadcast_addr[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
+	const u8 broadcast_addr[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
 
 	struct sk_buff *skb;
 	struct rtllib_probe_response *b;

commit c7ddc288ebf2aee890828cec26b4fb889a246330
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Sun May 31 20:19:20 2015 +0200

    staging: rtl8192e: accept const MAC address
    
    Make set_swcam, setKey and rtllib_probe_resp parameter (MAC address)
    const.
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 98afd3b557c7..cd758feac88c 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -832,7 +832,8 @@ inline struct sk_buff *rtllib_authentication_req(struct rtllib_network *beacon,
 	return skb;
 }
 
-static struct sk_buff *rtllib_probe_resp(struct rtllib_device *ieee, u8 *dest)
+static struct sk_buff *rtllib_probe_resp(struct rtllib_device *ieee,
+					 const u8 *dest)
 {
 	u8 *tag;
 	int beacon_size;

commit 640f7d6938a12f8f3f304d5e5e8680ab3cb5c8a5
Author: Arno Tiemersma <arno.tiemersma@gmail.com>
Date:   Sat May 9 22:27:16 2015 +0200

    staging: rtl8192e: Change cpu_to_le16 to le16_to_cpu
    
    Since the function auth_parse returns a u16, and
    struct rtllib_authentication.status is defined as an __le16, it seems
    that
    
            return cpu_to_le16(a->status);
    
    should be
    
            return le16_to_cpu(a->status);
    
    This change silences the following sparse warnings:
    drivers/staging/rtl8192e/rtllib_softmac.c:1817:16:
     warning: cast from restricted __le16
    drivers/staging/rtl8192e/rtllib_softmac.c:1817:16:
     warning: incorrect type in return expression (different base types)
    drivers/staging/rtl8192e/rtllib_softmac.c:1817:16:
        expected unsigned short
    drivers/staging/rtl8192e/rtllib_softmac.c:1817:16:
        got restricted __le16 [usertype] <noident>
    
    Signed-off-by: Arno Tiemersma <arno.tiemersma@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 8f5e88b802c8..98afd3b557c7 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -1814,7 +1814,7 @@ static inline u16 auth_parse(struct sk_buff *skb, u8 **challenge, int *chlen)
 				return -ENOMEM;
 		}
 	}
-	return cpu_to_le16(a->status);
+	return le16_to_cpu(a->status);
 }
 
 static int auth_rq_parse(struct sk_buff *skb, u8 *dest)

commit acd442db059f63232566f72afb8f34848ff7e208
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Mon Apr 27 01:25:41 2015 -0400

    rtl8192e: delete local copy of iee80211 reason codes.
    
    This driver has a copy of the standard reason codes from the file
    <linux/ieee80211.h> but with slightly different name fields.
    
    Delete the local copy and remap the only two use cases onto the names
    used by the global implementation with the same values.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 23b7a4c3b699..8f5e88b802c8 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -20,6 +20,7 @@
 #include <linux/delay.h>
 #include <linux/uaccess.h>
 #include <linux/etherdevice.h>
+#include <linux/ieee80211.h>
 #include "dot11d.h"
 
 short rtllib_is_54g(struct rtllib_network *net)
@@ -2983,7 +2984,7 @@ void rtllib_stop_protocol(struct rtllib_device *ieee, u8 shutdown)
 
 	if (ieee->state == RTLLIB_LINKED) {
 		if (ieee->iw_mode == IW_MODE_INFRA)
-			SendDisassociation(ieee, 1, deauth_lv_ss);
+			SendDisassociation(ieee, 1, WLAN_REASON_DEAUTH_LEAVING);
 		rtllib_disassociate(ieee);
 	}
 

commit 14b40d92881533dca8b25647f105b9546433cda2
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Wed Apr 1 00:24:37 2015 +0200

    staging: rtl8192e: Comment cleanup (style/format)
    
    - Multiline comments use "network subsystem comment style"
    - Merge short multiline comments
    - Remove empty comments
    - Remove function name comment at the end of small (<1 screen) functions
    - Reformat 802.11 data frame format to use spaces and network format
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index c043d8cb6c8a..23b7a4c3b699 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -68,7 +68,8 @@ static void rtllib_MFIE_Brate(struct rtllib_device *ieee, u8 **tag_p)
 	}
 
 	/* We may add an option for custom rates that specific HW
-	 * might support */
+	 * might support
+	 */
 	*tag_p = tag;
 }
 
@@ -89,7 +90,8 @@ static void rtllib_MFIE_Grate(struct rtllib_device *ieee, u8 **tag_p)
 		*tag++ = RTLLIB_BASIC_RATE_MASK | RTLLIB_OFDM_RATE_54MB;
 	}
 	/* We may add an option for custom rates that specific HW might
-	 * support */
+	 * support
+	 */
 	*tag_p = tag;
 }
 
@@ -133,8 +135,7 @@ static void enqueue_mgmt(struct rtllib_device *ieee, struct sk_buff *skb)
 
 	nh = (ieee->mgmt_queue_head + 1) % MGMT_QUEUE_NUM;
 
-/*
- * if the queue is full but we have newer frames then
+/* if the queue is full but we have newer frames then
  * just overwrites the oldest.
  *
  * if (nh == ieee->mgmt_queue_tail)
@@ -273,10 +274,11 @@ inline void softmac_mgmt_xmit(struct sk_buff *skb, struct rtllib_device *ieee)
 		if (!ieee->check_nic_enough_desc(ieee->dev, tcb_desc->queue_index) ||
 		    (skb_queue_len(&ieee->skb_waitQ[tcb_desc->queue_index]) != 0) ||
 		    (ieee->queue_stop)) {
-			/* insert the skb packet to the management queue */
-			/* as for the completion function, it does not need
+			/* insert the skb packet to the management queue
+			 *
+			 * as for the completion function, it does not need
 			 * to check it any more.
-			 * */
+			 */
 			netdev_info(ieee->dev,
 			       "%s():insert to waitqueue, queue_index:%d!\n",
 			       __func__, tcb_desc->queue_index);
@@ -417,10 +419,7 @@ static void rtllib_send_beacon_cb(unsigned long _ieee)
 	spin_unlock_irqrestore(&ieee->beacon_lock, flags);
 }
 
-/*
- * Description:
- *	      Enable network monitor mode, all rx packets will be received.
- */
+/* Enables network monitor mode, all rx packets will be received. */
 void rtllib_EnableNetMonitorMode(struct net_device *dev,
 		bool bInitState)
 {
@@ -432,10 +431,8 @@ void rtllib_EnableNetMonitorMode(struct net_device *dev,
 }
 
 
-/*
- *      Description:
- *	      Disable network network monitor mode, only packets destinated to
- *	      us will be received.
+/* Disables network monitor mode. Only packets destinated to
+ * us will be received.
  */
 void rtllib_DisableNetMonitorMode(struct net_device *dev,
 		bool bInitState)
@@ -448,9 +445,7 @@ void rtllib_DisableNetMonitorMode(struct net_device *dev,
 }
 
 
-/*
- * Description:
- * This enables the specialized promiscuous mode required by Intel.
+/* Enables the specialized promiscuous mode required by Intel.
  * In this mode, Intel intends to hear traffics from/to other STAs in the
  * same BSS. Therefore we don't have to disable checking BSSID and we only need
  * to allow all dest. BUT: if we enable checking BSSID then we can't recv
@@ -474,10 +469,8 @@ void rtllib_EnableIntelPromiscuousMode(struct net_device *dev,
 EXPORT_SYMBOL(rtllib_EnableIntelPromiscuousMode);
 
 
-/*
- * Description:
- *	      This disables the specialized promiscuous mode required by Intel.
- *	      See MgntEnableIntelPromiscuousMode for detail.
+/* Disables the specialized promiscuous mode required by Intel.
+ * See MgntEnableIntelPromiscuousMode for detail.
  */
 void rtllib_DisableIntelPromiscuousMode(struct net_device *dev,
 		bool bInitState)
@@ -1709,8 +1702,8 @@ inline void rtllib_softmac_new_net(struct rtllib_device *ieee,
 		   (!apset && ssidset && ssidbroad && ssidmatch) ||
 		   (ieee->is_roaming && ssidset && ssidbroad && ssidmatch)) {
 			/* if the essid is hidden replace it with the
-			* essid provided by the user.
-			*/
+			 * essid provided by the user.
+			 */
 			if (!ssidbroad) {
 				strncpy(tmp_ssid, ieee->current_network.ssid,
 					IW_ESSID_MAX_SIZE);
@@ -2008,7 +2001,8 @@ static short rtllib_sta_ps_sleep(struct rtllib_device *ieee, u64 *time)
 	timeout = ieee->current_network.beacon_interval;
 	ieee->current_network.dtim_data = RTLLIB_DTIM_INVALID;
 	/* there's no need to nofity AP that I find you buffered
-	 * with broadcast packet */
+	 * with broadcast packet
+	 */
 	if (dtim & (RTLLIB_DTIM_UCAST & ieee->ps))
 		return 2;
 
@@ -2348,8 +2342,7 @@ static void rtllib_rx_auth_resp(struct rtllib_device *ieee, struct sk_buff *skb)
 				}
 			}
 		}
-		/* Dummy wirless mode setting to avoid
-		 * encryption issue */
+		/* Dummy wirless mode setting to avoid encryption issue */
 		if (bSupportNmode) {
 			ieee->SetWirelessMode(ieee->dev,
 					      ieee->current_network.mode);
@@ -2395,8 +2388,8 @@ inline int rtllib_rx_deauth(struct rtllib_device *ieee, struct sk_buff *skb)
 		return 0;
 
 	/* FIXME for now repeat all the association procedure
-	* both for disassociation and deauthentication
-	*/
+	 * both for disassociation and deauthentication
+	 */
 	if ((ieee->softmac_features & IEEE_SOFTMAC_ASSOCIATE) &&
 	    ieee->state == RTLLIB_LINKED &&
 	    (ieee->iw_mode == IW_MODE_INFRA)) {
@@ -2499,16 +2492,17 @@ void rtllib_softmac_xmit(struct rtllib_txb *txb, struct rtllib_device *ieee)
 		ieee->stats.multicast++;
 
 	/* if xmit available, just xmit it immediately, else just insert it to
-	 * the wait queue */
+	 * the wait queue
+	 */
 	for (i = 0; i < txb->nr_frags; i++) {
 		queue_len = skb_queue_len(&ieee->skb_waitQ[queue_index]);
 		if ((queue_len  != 0) ||
 		    (!ieee->check_nic_enough_desc(ieee->dev, queue_index)) ||
 		    (ieee->queue_stop)) {
-			/* insert the skb packet to the wait queue */
-			/* as for the completion function, it does not need
+			/* insert the skb packet to the wait queue
+			 * as for the completion function, it does not need
 			 * to check it any more.
-			 * */
+			 */
 			if (queue_len < 200)
 				skb_queue_tail(&ieee->skb_waitQ[queue_index],
 					       txb->fragments[i]);
@@ -2886,18 +2880,18 @@ static void rtllib_associate_retry_wq(void *data)
 		goto exit;
 
 	/* until we do not set the state to RTLLIB_NOLINK
-	* there are no possibility to have someone else trying
-	* to start an association procedure (we get here with
-	* ieee->state = RTLLIB_ASSOCIATING).
-	* When we set the state to RTLLIB_NOLINK it is possible
-	* that the RX path run an attempt to associate, but
-	* both rtllib_softmac_check_all_nets and the
-	* RX path works with ieee->lock held so there are no
-	* problems. If we are still disassociated then start a scan.
-	* the lock here is necessary to ensure no one try to start
-	* an association procedure when we have just checked the
-	* state and we are going to start the scan.
-	*/
+	 * there are no possibility to have someone else trying
+	 * to start an association procedure (we get here with
+	 * ieee->state = RTLLIB_ASSOCIATING).
+	 * When we set the state to RTLLIB_NOLINK it is possible
+	 * that the RX path run an attempt to associate, but
+	 * both rtllib_softmac_check_all_nets and the
+	 * RX path works with ieee->lock held so there are no
+	 * problems. If we are still disassociated then start a scan.
+	 * the lock here is necessary to ensure no one try to start
+	 * an association procedure when we have just checked the
+	 * state and we are going to start the scan.
+	 */
 	ieee->beinretry = true;
 	ieee->state = RTLLIB_NOLINK;
 
@@ -3185,7 +3179,8 @@ void rtllib_softmac_free(struct rtllib_device *ieee)
 static int rtllib_wpa_enable(struct rtllib_device *ieee, int value)
 {
 	/* This is called when wpa_supplicant loads and closes the driver
-	 * interface. */
+	 * interface.
+	 */
 	netdev_info(ieee->dev, "%s WPA\n", value ? "enabling" : "disabling");
 	ieee->wpa_enabled = value;
 	memset(ieee->ap_mac_addr, 0, 6);
@@ -3490,7 +3485,8 @@ static int rtllib_wpa_set_encryption(struct rtllib_device *ieee,
 	 * generate new IEEE 802.11 authentication which may end up in looping
 	 * with IEEE 802.1X.  If your hardware requires a reset after WEP
 	 * configuration (for example... Prism2), implement the reset_port in
-	 * the callbacks structures used to initialize the 802.11 stack. */
+	 * the callbacks structures used to initialize the 802.11 stack.
+	 */
 	if (ieee->reset_on_keychange &&
 	    ieee->iw_mode != IW_MODE_INFRA &&
 	    ieee->reset_port &&

commit e725fb6f814b290fbf967e475f2a136efca66986
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Wed Apr 1 00:24:36 2015 +0200

    staging: rtl8192e: Fix indentation in rtllib_rx_auth_resp()
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 9a4179cb926c..c043d8cb6c8a 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -2329,7 +2329,7 @@ static void rtllib_rx_auth_resp(struct rtllib_device *ieee, struct sk_buff *skb)
 				  errcode);
 
 		netdev_info(ieee->dev,
-				"Authentication respose status code 0x%x", errcode);
+			    "Authentication respose status code 0x%x", errcode);
 		rtllib_associate_abort(ieee);
 		return;
 	}
@@ -2337,8 +2337,7 @@ static void rtllib_rx_auth_resp(struct rtllib_device *ieee, struct sk_buff *skb)
 	if (ieee->open_wep || !challenge) {
 		ieee->state = RTLLIB_ASSOCIATING_AUTHENTICATED;
 		ieee->softmac_stats.rx_auth_rs_ok++;
-		if (!(ieee->pHTInfo->IOTAction &
-		    HT_IOT_ACT_PURE_N_MODE)) {
+		if (!(ieee->pHTInfo->IOTAction & HT_IOT_ACT_PURE_N_MODE)) {
 			if (!ieee->GetNmodeSupportBySecCfg(ieee->dev)) {
 				if (IsHTHalfNmodeAPs(ieee)) {
 					bSupportNmode = true;
@@ -2353,27 +2352,22 @@ static void rtllib_rx_auth_resp(struct rtllib_device *ieee, struct sk_buff *skb)
 		 * encryption issue */
 		if (bSupportNmode) {
 			ieee->SetWirelessMode(ieee->dev,
-			   ieee->current_network.mode);
+					      ieee->current_network.mode);
 		} else {
 			/*TODO*/
-			ieee->SetWirelessMode(ieee->dev,
-					      IEEE_G);
+			ieee->SetWirelessMode(ieee->dev, IEEE_G);
 		}
 
-		if (ieee->current_network.mode ==
-		    IEEE_N_24G && bHalfSupportNmode) {
-			netdev_info(ieee->dev,
-				    "======>enter half N mode\n");
-			ieee->bHalfWirelessN24GMode =
-						 true;
-		} else
-			ieee->bHalfWirelessN24GMode =
-						 false;
-
+		if ((ieee->current_network.mode == IEEE_N_24G) &&
+		    bHalfSupportNmode) {
+			netdev_info(ieee->dev, "======>enter half N mode\n");
+			ieee->bHalfWirelessN24GMode = true;
+		} else {
+			ieee->bHalfWirelessN24GMode = false;
+		}
 		rtllib_associate_step2(ieee);
 	} else {
-		rtllib_auth_challenge(ieee, challenge,
-				      chlen);
+		rtllib_auth_challenge(ieee, challenge,  chlen);
 	}
 }
 

commit f7567e20708ed4129ccec1a21c4c55b9725b66d0
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Wed Apr 1 00:24:35 2015 +0200

    staging: rtl8192e: Decrease nesting of rtllib_rx_auth_resp()
    
    Return from rtllib_rx_auth_resp() if auth_parse() fails.
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 9266bc647bc4..9a4179cb926c 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -2322,57 +2322,58 @@ static void rtllib_rx_auth_resp(struct rtllib_device *ieee, struct sk_buff *skb)
 	bool bSupportNmode = true, bHalfSupportNmode = false;
 
 	errcode = auth_parse(skb, &challenge, &chlen);
-	if (0 == errcode) {
-		if (ieee->open_wep || !challenge) {
-			ieee->state = RTLLIB_ASSOCIATING_AUTHENTICATED;
-			ieee->softmac_stats.rx_auth_rs_ok++;
-			if (!(ieee->pHTInfo->IOTAction &
-			    HT_IOT_ACT_PURE_N_MODE)) {
-				if (!ieee->GetNmodeSupportBySecCfg(ieee->dev)) {
-					if (IsHTHalfNmodeAPs(ieee)) {
-						bSupportNmode = true;
-						bHalfSupportNmode = true;
-					} else {
-						bSupportNmode = false;
-						bHalfSupportNmode = false;
-					}
-				}
-			}
-			/* Dummy wirless mode setting to avoid
-			 * encryption issue */
-			if (bSupportNmode) {
-				ieee->SetWirelessMode(ieee->dev,
-				   ieee->current_network.mode);
-			} else {
-				/*TODO*/
-				ieee->SetWirelessMode(ieee->dev,
-						      IEEE_G);
-			}
 
-			if (ieee->current_network.mode ==
-			    IEEE_N_24G && bHalfSupportNmode) {
-				netdev_info(ieee->dev,
-					    "======>enter half N mode\n");
-				ieee->bHalfWirelessN24GMode =
-							 true;
-			} else
-				ieee->bHalfWirelessN24GMode =
-							 false;
-
-			rtllib_associate_step2(ieee);
-		} else {
-			rtllib_auth_challenge(ieee, challenge,
-					      chlen);
-		}
-	} else {
+	if (errcode) {
 		ieee->softmac_stats.rx_auth_rs_err++;
 		RTLLIB_DEBUG_MGMT("Authentication respose status code 0x%x",
 				  errcode);
 
 		netdev_info(ieee->dev,
-			    "Authentication respose status code 0x%x",
-			    errcode);
+				"Authentication respose status code 0x%x", errcode);
 		rtllib_associate_abort(ieee);
+		return;
+	}
+
+	if (ieee->open_wep || !challenge) {
+		ieee->state = RTLLIB_ASSOCIATING_AUTHENTICATED;
+		ieee->softmac_stats.rx_auth_rs_ok++;
+		if (!(ieee->pHTInfo->IOTAction &
+		    HT_IOT_ACT_PURE_N_MODE)) {
+			if (!ieee->GetNmodeSupportBySecCfg(ieee->dev)) {
+				if (IsHTHalfNmodeAPs(ieee)) {
+					bSupportNmode = true;
+					bHalfSupportNmode = true;
+				} else {
+					bSupportNmode = false;
+					bHalfSupportNmode = false;
+				}
+			}
+		}
+		/* Dummy wirless mode setting to avoid
+		 * encryption issue */
+		if (bSupportNmode) {
+			ieee->SetWirelessMode(ieee->dev,
+			   ieee->current_network.mode);
+		} else {
+			/*TODO*/
+			ieee->SetWirelessMode(ieee->dev,
+					      IEEE_G);
+		}
+
+		if (ieee->current_network.mode ==
+		    IEEE_N_24G && bHalfSupportNmode) {
+			netdev_info(ieee->dev,
+				    "======>enter half N mode\n");
+			ieee->bHalfWirelessN24GMode =
+						 true;
+		} else
+			ieee->bHalfWirelessN24GMode =
+						 false;
+
+		rtllib_associate_step2(ieee);
+	} else {
+		rtllib_auth_challenge(ieee, challenge,
+				      chlen);
 	}
 }
 

commit e8f05b0b01ea1593c8cc6311704c227fb0d08b04
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Wed Apr 1 00:24:34 2015 +0200

    staging: rtl8192e: Divide rtllib_rx_auth()
    
    Move authentication response processing to rtllib_rx_auth_resp() function.
    No logic is affected.
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index d3fc5a45dbbc..9266bc647bc4 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -2314,73 +2314,77 @@ inline int rtllib_rx_assoc_resp(struct rtllib_device *ieee, struct sk_buff *skb,
 	return 0;
 }
 
-inline int rtllib_rx_auth(struct rtllib_device *ieee, struct sk_buff *skb,
-			  struct rtllib_rx_stats *rx_stats)
+static void rtllib_rx_auth_resp(struct rtllib_device *ieee, struct sk_buff *skb)
 {
 	u16 errcode;
 	u8 *challenge;
 	int chlen = 0;
 	bool bSupportNmode = true, bHalfSupportNmode = false;
 
-	if (ieee->softmac_features & IEEE_SOFTMAC_ASSOCIATE) {
-		if (ieee->state == RTLLIB_ASSOCIATING_AUTHENTICATING &&
-		    (ieee->iw_mode == IW_MODE_INFRA)) {
-			RTLLIB_DEBUG_MGMT("Received authentication response");
-
-			errcode = auth_parse(skb, &challenge, &chlen);
-			if (0 == errcode) {
-				if (ieee->open_wep || !challenge) {
-					ieee->state = RTLLIB_ASSOCIATING_AUTHENTICATED;
-					ieee->softmac_stats.rx_auth_rs_ok++;
-					if (!(ieee->pHTInfo->IOTAction &
-					    HT_IOT_ACT_PURE_N_MODE)) {
-						if (!ieee->GetNmodeSupportBySecCfg(ieee->dev)) {
-							if (IsHTHalfNmodeAPs(ieee)) {
-								bSupportNmode = true;
-								bHalfSupportNmode = true;
-							} else {
-								bSupportNmode = false;
-								bHalfSupportNmode = false;
-							}
-						}
-					}
-					/* Dummy wirless mode setting to avoid
-					 * encryption issue */
-					if (bSupportNmode) {
-						ieee->SetWirelessMode(ieee->dev,
-						   ieee->current_network.mode);
+	errcode = auth_parse(skb, &challenge, &chlen);
+	if (0 == errcode) {
+		if (ieee->open_wep || !challenge) {
+			ieee->state = RTLLIB_ASSOCIATING_AUTHENTICATED;
+			ieee->softmac_stats.rx_auth_rs_ok++;
+			if (!(ieee->pHTInfo->IOTAction &
+			    HT_IOT_ACT_PURE_N_MODE)) {
+				if (!ieee->GetNmodeSupportBySecCfg(ieee->dev)) {
+					if (IsHTHalfNmodeAPs(ieee)) {
+						bSupportNmode = true;
+						bHalfSupportNmode = true;
 					} else {
-						/*TODO*/
-						ieee->SetWirelessMode(ieee->dev,
-								      IEEE_G);
+						bSupportNmode = false;
+						bHalfSupportNmode = false;
 					}
-
-					if (ieee->current_network.mode ==
-					    IEEE_N_24G && bHalfSupportNmode) {
-						netdev_info(ieee->dev,
-							    "======>enter half N mode\n");
-						ieee->bHalfWirelessN24GMode =
-									 true;
-					} else
-						ieee->bHalfWirelessN24GMode =
-									 false;
-
-					rtllib_associate_step2(ieee);
-				} else {
-					rtllib_auth_challenge(ieee, challenge,
-							      chlen);
 				}
+			}
+			/* Dummy wirless mode setting to avoid
+			 * encryption issue */
+			if (bSupportNmode) {
+				ieee->SetWirelessMode(ieee->dev,
+				   ieee->current_network.mode);
 			} else {
-				ieee->softmac_stats.rx_auth_rs_err++;
-				RTLLIB_DEBUG_MGMT("Authentication respose status code 0x%x",
-						  errcode);
+				/*TODO*/
+				ieee->SetWirelessMode(ieee->dev,
+						      IEEE_G);
+			}
 
+			if (ieee->current_network.mode ==
+			    IEEE_N_24G && bHalfSupportNmode) {
 				netdev_info(ieee->dev,
-					    "Authentication respose status code 0x%x",
-					    errcode);
-				rtllib_associate_abort(ieee);
-			}
+					    "======>enter half N mode\n");
+				ieee->bHalfWirelessN24GMode =
+							 true;
+			} else
+				ieee->bHalfWirelessN24GMode =
+							 false;
+
+			rtllib_associate_step2(ieee);
+		} else {
+			rtllib_auth_challenge(ieee, challenge,
+					      chlen);
+		}
+	} else {
+		ieee->softmac_stats.rx_auth_rs_err++;
+		RTLLIB_DEBUG_MGMT("Authentication respose status code 0x%x",
+				  errcode);
+
+		netdev_info(ieee->dev,
+			    "Authentication respose status code 0x%x",
+			    errcode);
+		rtllib_associate_abort(ieee);
+	}
+}
 
+inline int rtllib_rx_auth(struct rtllib_device *ieee, struct sk_buff *skb,
+			  struct rtllib_rx_stats *rx_stats)
+{
+
+	if (ieee->softmac_features & IEEE_SOFTMAC_ASSOCIATE) {
+		if (ieee->state == RTLLIB_ASSOCIATING_AUTHENTICATING &&
+		    (ieee->iw_mode == IW_MODE_INFRA)) {
+			RTLLIB_DEBUG_MGMT("Received authentication response");
+			rtllib_rx_auth_resp(ieee, skb);
 		} else if (ieee->iw_mode == IW_MODE_MASTER) {
 			rtllib_rx_auth_rq(ieee, skb);
 		}

commit e2ac043118eed826444972bd81ab0bf70461a0fe
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Wed Apr 1 00:24:30 2015 +0200

    staging: rtl8192e: Fix LINE_CONTINUATIONS warning
    
    Fix 'Avoid unnecessary line continuations' checkpatch.pl warning
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 0f2ae3557bc8..d3fc5a45dbbc 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -2503,7 +2503,7 @@ void rtllib_softmac_xmit(struct rtllib_txb *txb, struct rtllib_device *ieee)
 	 * the wait queue */
 	for (i = 0; i < txb->nr_frags; i++) {
 		queue_len = skb_queue_len(&ieee->skb_waitQ[queue_index]);
-		if ((queue_len  != 0) ||\
+		if ((queue_len  != 0) ||
 		    (!ieee->check_nic_enough_desc(ieee->dev, queue_index)) ||
 		    (ieee->queue_stop)) {
 			/* insert the skb packet to the wait queue */

commit 0f0688b3ced6cf085a1bce52fb9984ecc8f39a45
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Wed Apr 1 00:24:27 2015 +0200

    staging: rtl8192e: Fix RETURN_VOID warnings
    
    Fix 'void function return statements are not generally useful'
    checkpatch.pl warnings
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 70bdf1fe91a4..0f2ae3557bc8 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -2228,7 +2228,6 @@ static void rtllib_process_action(struct rtllib_device *ieee, struct sk_buff *sk
 	default:
 		break;
 	}
-	return;
 }
 
 inline int rtllib_rx_assoc_resp(struct rtllib_device *ieee, struct sk_buff *skb,

commit 285b7c00e06b4fdd6e9ac63b9b8082508340f1ab
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Wed Apr 1 00:24:26 2015 +0200

    staging: rtl8192e: Fix UNNECESSARY_ELSE warning
    
    Fix checkpatch warnings 'else is not generally useful after a break or return'
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index f1f19fc2305c..70bdf1fe91a4 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -2540,13 +2540,12 @@ static void rtllib_resume_tx(struct rtllib_device *ieee)
 		if (ieee->queue_stop) {
 			ieee->tx_pending.frag = i;
 			return;
-		} else {
-
-			ieee->softmac_data_hard_start_xmit(
-				ieee->tx_pending.txb->fragments[i],
-				ieee->dev, ieee->rate);
-			ieee->stats.tx_packets++;
 		}
+
+		ieee->softmac_data_hard_start_xmit(
+			ieee->tx_pending.txb->fragments[i],
+			ieee->dev, ieee->rate);
+		ieee->stats.tx_packets++;
 	}
 
 	rtllib_txb_free(ieee->tx_pending.txb);

commit d69d20549be9e44b928d5f857898fe7432deeaac
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Tue Mar 17 00:00:52 2015 +0100

    staging: rtl8192e: fix coding style warnings (printk -> netdev_*)
    
    Use netdev_*, dev_* or pr_* instead of printk where possible.
    KERN_DEBUG messages are left intact as pr_dbg has different behaviour.
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index ec9689ad64ce..f1f19fc2305c 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -124,7 +124,7 @@ void rtllib_TURBO_Info(struct rtllib_device *ieee, u8 **tag_p)
 	*tag++ = 0x00;
 
 	*tag_p = tag;
-	printk(KERN_ALERT "This is enable turbo mode IE process\n");
+	netdev_alert(ieee->dev, "This is enable turbo mode IE process\n");
 }
 
 static void enqueue_mgmt(struct rtllib_device *ieee, struct sk_buff *skb)
@@ -188,7 +188,7 @@ MgntQuery_TxRateExcludeCCKRates(struct rtllib_device *ieee)
 
 	if (QueryRate == 0) {
 		QueryRate = 12;
-		printk(KERN_INFO "No BasicRate found!!\n");
+		netdev_info(ieee->dev, "No BasicRate found!!\n");
 	}
 	return QueryRate;
 }
@@ -277,7 +277,7 @@ inline void softmac_mgmt_xmit(struct sk_buff *skb, struct rtllib_device *ieee)
 			/* as for the completion function, it does not need
 			 * to check it any more.
 			 * */
-			printk(KERN_INFO
+			netdev_info(ieee->dev,
 			       "%s():insert to waitqueue, queue_index:%d!\n",
 			       __func__, tcb_desc->queue_index);
 			skb_queue_tail(&ieee->skb_waitQ[tcb_desc->queue_index],
@@ -426,7 +426,7 @@ void rtllib_EnableNetMonitorMode(struct net_device *dev,
 {
 	struct rtllib_device *ieee = netdev_priv_rsl(dev);
 
-	printk(KERN_INFO "========>Enter Monitor Mode\n");
+	netdev_info(dev, "========>Enter Monitor Mode\n");
 
 	ieee->AllowAllDestAddrHandler(dev, true, !bInitState);
 }
@@ -442,7 +442,7 @@ void rtllib_DisableNetMonitorMode(struct net_device *dev,
 {
 	struct rtllib_device *ieee = netdev_priv_rsl(dev);
 
-	printk(KERN_INFO "========>Exit Monitor Mode\n");
+	netdev_info(dev, "========>Exit Monitor Mode\n");
 
 	ieee->AllowAllDestAddrHandler(dev, false, !bInitState);
 }
@@ -463,7 +463,7 @@ void rtllib_EnableIntelPromiscuousMode(struct net_device *dev,
 
 	struct rtllib_device *ieee = netdev_priv_rsl(dev);
 
-	printk(KERN_INFO "========>Enter Intel Promiscuous Mode\n");
+	netdev_info(dev, "========>Enter Intel Promiscuous Mode\n");
 
 	ieee->AllowAllDestAddrHandler(dev, true, !bInitState);
 	ieee->SetHwRegHandler(dev, HW_VAR_CECHK_BSSID,
@@ -486,7 +486,7 @@ void rtllib_DisableIntelPromiscuousMode(struct net_device *dev,
 
 	struct rtllib_device *ieee = netdev_priv_rsl(dev);
 
-	printk(KERN_INFO "========>Exit Intel Promiscuous Mode\n");
+	netdev_info(dev, "========>Exit Intel Promiscuous Mode\n");
 
 	ieee->AllowAllDestAddrHandler(dev, false, !bInitState);
 	ieee->SetHwRegHandler(dev, HW_VAR_CECHK_BSSID,
@@ -570,7 +570,8 @@ void rtllib_softmac_scan_syncro(struct rtllib_device *ieee, u8 is_mesh)
 		if (ieee->state == RTLLIB_LINKED)
 			goto out;
 		if (ieee->sync_scan_hurryup) {
-			printk(KERN_INFO "============>sync_scan_hurryup out\n");
+			netdev_info(ieee->dev,
+				    "============>sync_scan_hurryup out\n");
 			goto out;
 		}
 
@@ -615,8 +616,9 @@ static void rtllib_softmac_scan_wq(void *data)
 	down(&ieee->scan_sem);
 
 	if (ieee->eRFPowerState == eRfOff) {
-		printk(KERN_INFO "======>%s():rf state is eRfOff, return\n",
-		       __func__);
+		netdev_info(ieee->dev,
+			    "======>%s():rf state is eRfOff, return\n",
+			    __func__);
 		goto out1;
 	}
 
@@ -1239,8 +1241,8 @@ inline struct sk_buff *rtllib_association_req(struct rtllib_network *beacon,
 	PMKCacheIdx = SecIsInPMKIDList(ieee, ieee->current_network.bssid);
 	if (PMKCacheIdx >= 0) {
 		wpa_ie_len += 18;
-		printk(KERN_INFO "[PMK cache]: WPA2 IE length: %x\n",
-		       wpa_ie_len);
+		netdev_info(ieee->dev, "[PMK cache]: WPA2 IE length: %x\n",
+			    wpa_ie_len);
 	}
 	len = sizeof(struct rtllib_assoc_request_frame) + 2
 		+ beacon->ssid_len
@@ -1419,9 +1421,9 @@ inline struct sk_buff *rtllib_association_req(struct rtllib_network *beacon,
 	if (ieee->assocreq_ies)
 		memcpy(ieee->assocreq_ies, ies, ieee->assocreq_ies_len);
 	else {
-		printk(KERN_INFO
-		       "%s()Warning: can't alloc memory for assocreq_ies\n",
-		       __func__);
+		netdev_info(ieee->dev,
+			    "%s()Warning: can't alloc memory for assocreq_ies\n",
+			    __func__);
 		ieee->assocreq_ies_len = 0;
 	}
 	return skb;
@@ -1544,9 +1546,9 @@ static void rtllib_associate_complete_wq(void *data)
 				     associate_complete_wq);
 	struct rt_pwr_save_ctrl *pPSC = (struct rt_pwr_save_ctrl *)
 					(&(ieee->PowerSaveControl));
-	printk(KERN_INFO "Associated successfully\n");
+	netdev_info(ieee->dev, "Associated successfully\n");
 	if (!ieee->is_silent_reset) {
-		printk(KERN_INFO "normal associate\n");
+		netdev_info(ieee->dev, "normal associate\n");
 		notify_wx_assoc_event(ieee);
 	}
 
@@ -1555,20 +1557,20 @@ static void rtllib_associate_complete_wq(void *data)
 	if (rtllib_is_54g(&ieee->current_network) &&
 	   (ieee->modulation & RTLLIB_OFDM_MODULATION)) {
 		ieee->rate = 108;
-		printk(KERN_INFO"Using G rates:%d\n", ieee->rate);
+		netdev_info(ieee->dev, "Using G rates:%d\n", ieee->rate);
 	} else {
 		ieee->rate = 22;
 		ieee->SetWirelessMode(ieee->dev, IEEE_B);
-		printk(KERN_INFO"Using B rates:%d\n", ieee->rate);
+		netdev_info(ieee->dev, "Using B rates:%d\n", ieee->rate);
 	}
 	if (ieee->pHTInfo->bCurrentHTSupport && ieee->pHTInfo->bEnableHT) {
-		printk(KERN_INFO "Successfully associated, ht enabled\n");
+		netdev_info(ieee->dev, "Successfully associated, ht enabled\n");
 		HTOnAssocRsp(ieee);
 	} else {
-		printk(KERN_INFO
-		       "Successfully associated, ht not enabled(%d, %d)\n",
-		       ieee->pHTInfo->bCurrentHTSupport,
-		       ieee->pHTInfo->bEnableHT);
+		netdev_info(ieee->dev,
+			    "Successfully associated, ht not enabled(%d, %d)\n",
+			    ieee->pHTInfo->bCurrentHTSupport,
+			    ieee->pHTInfo->bEnableHT);
 		memset(ieee->dot11HTOperationalRateSet, 0, 16);
 	}
 	ieee->LinkDetectInfo.SlotNum = 2 * (1 +
@@ -1583,7 +1585,7 @@ static void rtllib_associate_complete_wq(void *data)
 	ieee->link_change(ieee->dev);
 
 	if (ieee->is_silent_reset) {
-		printk(KERN_INFO "silent reset associate\n");
+		netdev_info(ieee->dev, "silent reset associate\n");
 		ieee->is_silent_reset = false;
 	}
 
@@ -1721,15 +1723,15 @@ inline void rtllib_softmac_new_net(struct rtllib_device *ieee,
 					IW_ESSID_MAX_SIZE);
 				ieee->current_network.ssid_len = tmp_ssid_len;
 			}
-			printk(KERN_INFO
-			       "Linking with %s,channel:%d, qos:%d, myHT:%d, networkHT:%d, mode:%x cur_net.flags:0x%x\n",
-			       ieee->current_network.ssid,
-			       ieee->current_network.channel,
-			       ieee->current_network.qos_data.supported,
-			       ieee->pHTInfo->bEnableHT,
-			       ieee->current_network.bssht.bdSupportHT,
-			       ieee->current_network.mode,
-			       ieee->current_network.flags);
+			netdev_info(ieee->dev,
+				    "Linking with %s,channel:%d, qos:%d, myHT:%d, networkHT:%d, mode:%x cur_net.flags:0x%x\n",
+				    ieee->current_network.ssid,
+				    ieee->current_network.channel,
+				    ieee->current_network.qos_data.supported,
+				    ieee->pHTInfo->bEnableHT,
+				    ieee->current_network.bssht.bdSupportHT,
+				    ieee->current_network.mode,
+				    ieee->current_network.flags);
 
 			if ((rtllib_act_scanning(ieee, false)) &&
 			   !(ieee->softmac_features & IEEE_SOFTMAC_SCAN))
@@ -1760,11 +1762,11 @@ inline void rtllib_softmac_new_net(struct rtllib_device *ieee,
 					(ieee->modulation & RTLLIB_OFDM_MODULATION)) {
 					ieee->rate = 108;
 					ieee->SetWirelessMode(ieee->dev, IEEE_G);
-					printk(KERN_INFO"Using G rates\n");
+					netdev_info(ieee->dev, "Using G rates\n");
 				} else {
 					ieee->rate = 22;
 					ieee->SetWirelessMode(ieee->dev, IEEE_B);
-					printk(KERN_INFO"Using B rates\n");
+					netdev_info(ieee->dev, "Using B rates\n");
 				}
 				memset(ieee->dot11HTOperationalRateSet, 0, 16);
 				ieee->state = RTLLIB_LINKED;
@@ -1967,7 +1969,7 @@ static inline void rtllib_rx_assoc_rq(struct rtllib_device *ieee,
 	if (assoc_rq_parse(skb, dest) != -1)
 		rtllib_resp_to_assoc_rq(ieee, dest);
 
-	printk(KERN_INFO"New client associated: %pM\n", dest);
+	netdev_info(ieee->dev, "New client associated: %pM\n", dest);
 }
 
 void rtllib_sta_ps_send_null_frame(struct rtllib_device *ieee, short pwr)
@@ -2288,17 +2290,18 @@ inline int rtllib_rx_assoc_resp(struct rtllib_device *ieee, struct sk_buff *skb,
 				memcpy(ieee->assocresp_ies, ies,
 				       ieee->assocresp_ies_len);
 			else {
-				printk(KERN_INFO
-				       "%s()Warning: can't alloc memory for assocresp_ies\n",
-				       __func__);
+				netdev_info(ieee->dev,
+					    "%s()Warning: can't alloc memory for assocresp_ies\n",
+					    __func__);
 				ieee->assocresp_ies_len = 0;
 			}
 			rtllib_associate_complete(ieee);
 		} else {
 			/* aid could not been allocated */
 			ieee->softmac_stats.rx_ass_err++;
-			printk(KERN_INFO "Association response status code 0x%x\n",
-				errcode);
+			netdev_info(ieee->dev,
+				    "Association response status code 0x%x\n",
+				    errcode);
 			RTLLIB_DEBUG_MGMT(
 				"Association response status code 0x%x\n",
 				errcode);
@@ -2355,8 +2358,8 @@ inline int rtllib_rx_auth(struct rtllib_device *ieee, struct sk_buff *skb,
 
 					if (ieee->current_network.mode ==
 					    IEEE_N_24G && bHalfSupportNmode) {
-						printk(KERN_INFO
-						       "======>enter half N mode\n");
+						netdev_info(ieee->dev,
+							    "======>enter half N mode\n");
 						ieee->bHalfWirelessN24GMode =
 									 true;
 					} else
@@ -2373,9 +2376,9 @@ inline int rtllib_rx_auth(struct rtllib_device *ieee, struct sk_buff *skb,
 				RTLLIB_DEBUG_MGMT("Authentication respose status code 0x%x",
 						  errcode);
 
-				printk(KERN_INFO
-				       "Authentication respose status code 0x%x",
-				       errcode);
+				netdev_info(ieee->dev,
+					    "Authentication respose status code 0x%x",
+					    errcode);
 				rtllib_associate_abort(ieee);
 			}
 
@@ -2399,10 +2402,10 @@ inline int rtllib_rx_deauth(struct rtllib_device *ieee, struct sk_buff *skb)
 	if ((ieee->softmac_features & IEEE_SOFTMAC_ASSOCIATE) &&
 	    ieee->state == RTLLIB_LINKED &&
 	    (ieee->iw_mode == IW_MODE_INFRA)) {
-		printk(KERN_INFO
-		       "==========>received disassoc/deauth(%x) frame, reason code:%x\n",
-		       WLAN_FC_GET_STYPE(header->frame_ctl),
-		       ((struct rtllib_disassoc *)skb->data)->reason);
+		netdev_info(ieee->dev,
+			    "==========>received disassoc/deauth(%x) frame, reason code:%x\n",
+			    WLAN_FC_GET_STYPE(header->frame_ctl),
+			    ((struct rtllib_disassoc *)skb->data)->reason);
 		ieee->state = RTLLIB_ASSOCIATING;
 		ieee->softmac_stats.reassoc++;
 		ieee->is_roaming = true;
@@ -2692,7 +2695,7 @@ static void rtllib_start_ibss_wq(void *data)
 	 * on the semaphore
 	 */
 	if (!ieee->proto_started) {
-		printk(KERN_INFO "==========oh driver down return\n");
+		netdev_info(ieee->dev, "==========oh driver down return\n");
 		return;
 	}
 	down(&ieee->wx_sem);
@@ -2728,7 +2731,7 @@ static void rtllib_start_ibss_wq(void *data)
 
 	/* the network definitively is not here.. create a new cell */
 	if (ieee->state == RTLLIB_NOLINK) {
-		printk(KERN_INFO "creating new IBSS cell\n");
+		netdev_info(ieee->dev, "creating new IBSS cell\n");
 		ieee->current_network.channel = ieee->IbssStartChnl;
 		if (!ieee->wap_set)
 			rtllib_randomize_cell(ieee);
@@ -2782,7 +2785,7 @@ static void rtllib_start_ibss_wq(void *data)
 		ieee->current_network.capability = WLAN_CAPABILITY_IBSS;
 	}
 
-	printk(KERN_INFO "%s(): ieee->mode = %d\n", __func__, ieee->mode);
+	netdev_info(ieee->dev, "%s(): ieee->mode = %d\n", __func__, ieee->mode);
 	if ((ieee->mode == IEEE_N_24G) || (ieee->mode == IEEE_N_5G))
 		HTUseDefaultSetting(ieee);
 	else
@@ -3186,7 +3189,7 @@ static int rtllib_wpa_enable(struct rtllib_device *ieee, int value)
 {
 	/* This is called when wpa_supplicant loads and closes the driver
 	 * interface. */
-	printk(KERN_INFO "%s WPA\n", value ? "enabling" : "disabling");
+	netdev_info(ieee->dev, "%s WPA\n", value ? "enabling" : "disabling");
 	ieee->wpa_enabled = value;
 	memset(ieee->ap_mac_addr, 0, 6);
 	return 0;
@@ -3217,7 +3220,7 @@ static int rtllib_wpa_mlme(struct rtllib_device *ieee, int command, int reason)
 		break;
 
 	default:
-		printk(KERN_INFO "Unknown MLME request: %d\n", command);
+		netdev_info(ieee->dev, "Unknown MLME request: %d\n", command);
 		ret = -EOPNOTSUPP;
 	}
 
@@ -3348,7 +3351,7 @@ static int rtllib_wpa_set_param(struct rtllib_device *ieee, u8 name, u32 value)
 		break;
 
 	default:
-		printk(KERN_INFO "Unknown WPA param: %d\n", name);
+		netdev_info(ieee->dev, "Unknown WPA param: %d\n", name);
 		ret = -EOPNOTSUPP;
 	}
 
@@ -3374,8 +3377,8 @@ static int rtllib_wpa_set_encryption(struct rtllib_device *ieee,
 	if (param_len !=
 	    (int) ((char *) param->u.crypt.key - (char *) param) +
 	    param->u.crypt.key_len) {
-		printk(KERN_INFO "Len mismatch %d, %d\n", param_len,
-			       param->u.crypt.key_len);
+		netdev_info(ieee->dev, "Len mismatch %d, %d\n", param_len,
+			    param->u.crypt.key_len);
 		return -EINVAL;
 	}
 	if (is_broadcast_ether_addr(param->sta_addr)) {
@@ -3415,8 +3418,8 @@ static int rtllib_wpa_set_encryption(struct rtllib_device *ieee,
 		ops = lib80211_get_crypto_ops(param->u.crypt.alg);
 	}
 	if (ops == NULL) {
-		printk(KERN_INFO "unknown crypto alg '%s'\n",
-		       param->u.crypt.alg);
+		netdev_info(ieee->dev, "unknown crypto alg '%s'\n",
+			    param->u.crypt.alg);
 		param->u.crypt.err = IEEE_CRYPT_ERR_UNKNOWN_ALG;
 		ret = -EINVAL;
 		goto done;
@@ -3450,7 +3453,7 @@ static int rtllib_wpa_set_encryption(struct rtllib_device *ieee,
 	    (*crypt)->ops->set_key(param->u.crypt.key,
 	    param->u.crypt.key_len, param->u.crypt.seq,
 	    (*crypt)->priv) < 0) {
-		printk(KERN_INFO "key setting failed\n");
+		netdev_info(ieee->dev, "key setting failed\n");
 		param->u.crypt.err = IEEE_CRYPT_ERR_KEY_SET_FAILED;
 		ret = -EINVAL;
 		goto done;
@@ -3495,7 +3498,7 @@ static int rtllib_wpa_set_encryption(struct rtllib_device *ieee,
 	    ieee->iw_mode != IW_MODE_INFRA &&
 	    ieee->reset_port &&
 	    ieee->reset_port(ieee->dev)) {
-		printk(KERN_INFO "reset_port failed\n");
+		netdev_info(ieee->dev, "reset_port failed\n");
 		param->u.crypt.err = IEEE_CRYPT_ERR_CARD_CONF_FAILED;
 		return -EINVAL;
 	}
@@ -3638,8 +3641,8 @@ int rtllib_wpa_supplicant_ioctl(struct rtllib_device *ieee, struct iw_point *p,
 		break;
 
 	default:
-		printk(KERN_INFO "Unknown WPA supplicant request: %d\n",
-		       param->cmd);
+		netdev_info(ieee->dev, "Unknown WPA supplicant request: %d\n",
+			    param->cmd);
 		ret = -EOPNOTSUPP;
 		break;
 	}
@@ -3753,8 +3756,8 @@ void notify_wx_assoc_event(struct rtllib_device *ieee)
 		       ETH_ALEN);
 	else {
 
-		printk(KERN_INFO "%s(): Tell user space disconnected\n",
-		       __func__);
+		netdev_info(ieee->dev, "%s(): Tell user space disconnected\n",
+			    __func__);
 		eth_zero_addr(wrqu.ap_addr.sa_data);
 	}
 	wireless_send_event(ieee->dev, SIOCGIWAP, &wrqu, NULL);

commit dc986e3ed39830df78a24e5053b3c05acd6f0527
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Tue Mar 17 00:00:49 2015 +0100

    staging: rtl8192e: fix coding style issues (spaces before semicolon)
    
    Fix checkpatch.pl warning 'space prohibited before semicolon'.
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 8005eed8bd55..ec9689ad64ce 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -1476,7 +1476,7 @@ static void rtllib_associate_step1(struct rtllib_device *ieee, u8 *daddr)
 	if (!skb)
 		rtllib_associate_abort(ieee);
 	else {
-		ieee->state = RTLLIB_ASSOCIATING_AUTHENTICATING ;
+		ieee->state = RTLLIB_ASSOCIATING_AUTHENTICATING;
 		RTLLIB_DEBUG_MGMT("Sending authentication request\n");
 		softmac_mgmt_xmit(skb, ieee);
 		if (!timer_pending(&ieee->associate_timer)) {

commit 0822339b52f6ea3f20b602362864f2a7ab9d3f7f
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Tue Mar 17 00:00:48 2015 +0100

    staging: rtl8192e: fix coding style issues (merge broken strings)
    
    Fix checkpatch.pl warnings:
    - 'WARNING: quoted string split across lines'
    - 'WARNING: break quoted strings at a space character'
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 392bdf513ae2..8005eed8bd55 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -277,8 +277,9 @@ inline void softmac_mgmt_xmit(struct sk_buff *skb, struct rtllib_device *ieee)
 			/* as for the completion function, it does not need
 			 * to check it any more.
 			 * */
-			printk(KERN_INFO "%s():insert to waitqueue, queue_index"
-			       ":%d!\n", __func__, tcb_desc->queue_index);
+			printk(KERN_INFO
+			       "%s():insert to waitqueue, queue_index:%d!\n",
+			       __func__, tcb_desc->queue_index);
 			skb_queue_tail(&ieee->skb_waitQ[tcb_desc->queue_index],
 				       skb);
 		} else {
@@ -1418,8 +1419,9 @@ inline struct sk_buff *rtllib_association_req(struct rtllib_network *beacon,
 	if (ieee->assocreq_ies)
 		memcpy(ieee->assocreq_ies, ies, ieee->assocreq_ies_len);
 	else {
-		printk(KERN_INFO "%s()Warning: can't alloc memory for assocreq"
-		       "_ies\n", __func__);
+		printk(KERN_INFO
+		       "%s()Warning: can't alloc memory for assocreq_ies\n",
+		       __func__);
 		ieee->assocreq_ies_len = 0;
 	}
 	return skb;
@@ -1503,8 +1505,7 @@ static void rtllib_auth_challenge(struct rtllib_device *ieee, u8 *challenge, int
 		*(c++) = chlen;
 		memcpy(c, challenge, chlen);
 
-		RTLLIB_DEBUG_MGMT("Sending authentication challenge "
-				  "response\n");
+		RTLLIB_DEBUG_MGMT("Sending authentication challenge response\n");
 
 		rtllib_encrypt_fragment(ieee, skb,
 					sizeof(struct rtllib_hdr_3addr));
@@ -1564,8 +1565,8 @@ static void rtllib_associate_complete_wq(void *data)
 		printk(KERN_INFO "Successfully associated, ht enabled\n");
 		HTOnAssocRsp(ieee);
 	} else {
-		printk(KERN_INFO "Successfully associated, ht not "
-		       "enabled(%d, %d)\n",
+		printk(KERN_INFO
+		       "Successfully associated, ht not enabled(%d, %d)\n",
 		       ieee->pHTInfo->bCurrentHTSupport,
 		       ieee->pHTInfo->bEnableHT);
 		memset(ieee->dot11HTOperationalRateSet, 0, 16);
@@ -1623,8 +1624,9 @@ static void rtllib_associate_procedure_wq(void *data)
 		 ieee->current_network.channel);
 	HTSetConnectBwMode(ieee, HT_CHANNEL_WIDTH_20, HT_EXTCHNL_OFFSET_NO_EXT);
 	if (ieee->eRFPowerState == eRfOff) {
-		RT_TRACE(COMP_DBG, "=============>%s():Rf state is eRfOff,"
-			 " schedule ipsleave wq again,return\n", __func__);
+		RT_TRACE(COMP_DBG,
+			 "=============>%s():Rf state is eRfOff, schedule ipsleave wq again,return\n",
+			 __func__);
 		if (ieee->rtllib_ips_leave_wq != NULL)
 			ieee->rtllib_ips_leave_wq(ieee->dev);
 		up(&ieee->wx_sem);
@@ -1719,9 +1721,9 @@ inline void rtllib_softmac_new_net(struct rtllib_device *ieee,
 					IW_ESSID_MAX_SIZE);
 				ieee->current_network.ssid_len = tmp_ssid_len;
 			}
-			printk(KERN_INFO"Linking with %s,channel:%d, qos:%d, "
-			       "myHT:%d, networkHT:%d, mode:%x cur_net.flags"
-			       ":0x%x\n", ieee->current_network.ssid,
+			printk(KERN_INFO
+			       "Linking with %s,channel:%d, qos:%d, myHT:%d, networkHT:%d, mode:%x cur_net.flags:0x%x\n",
+			       ieee->current_network.ssid,
 			       ieee->current_network.channel,
 			       ieee->current_network.qos_data.supported,
 			       ieee->pHTInfo->bEnableHT,
@@ -2083,10 +2085,9 @@ static inline void rtllib_sta_ps(struct rtllib_device *ieee)
 	if ((ieee->ps == RTLLIB_PS_DISABLED ||
 	     ieee->iw_mode != IW_MODE_INFRA ||
 	     ieee->state != RTLLIB_LINKED)) {
-		RT_TRACE(COMP_DBG, "=====>%s(): no need to ps,wake up!! "
-			 "ieee->ps is %d, ieee->iw_mode is %d, ieee->state"
-			 " is %d\n", __func__, ieee->ps, ieee->iw_mode,
-			  ieee->state);
+		RT_TRACE(COMP_DBG,
+			 "=====>%s(): no need to ps,wake up!! ieee->ps is %d, ieee->iw_mode is %d, ieee->state is %d\n",
+			 __func__, ieee->ps, ieee->iw_mode, ieee->state);
 		spin_lock_irqsave(&ieee->mgmt_tx_lock, flags2);
 		rtllib_sta_wakeup(ieee, 1);
 
@@ -2201,8 +2202,8 @@ static void rtllib_process_action(struct rtllib_device *ieee, struct sk_buff *sk
 	u8 category = 0;
 
 	if (act == NULL) {
-		RTLLIB_DEBUG(RTLLIB_DL_ERR, "error to get payload of "
-			     "action frame\n");
+		RTLLIB_DEBUG(RTLLIB_DL_ERR,
+			     "error to get payload of action frame\n");
 		return;
 	}
 
@@ -2287,8 +2288,9 @@ inline int rtllib_rx_assoc_resp(struct rtllib_device *ieee, struct sk_buff *skb,
 				memcpy(ieee->assocresp_ies, ies,
 				       ieee->assocresp_ies_len);
 			else {
-				printk(KERN_INFO "%s()Warning: can't alloc "
-				       "memory for assocresp_ies\n", __func__);
+				printk(KERN_INFO
+				       "%s()Warning: can't alloc memory for assocresp_ies\n",
+				       __func__);
 				ieee->assocresp_ies_len = 0;
 			}
 			rtllib_associate_complete(ieee);
@@ -2353,8 +2355,8 @@ inline int rtllib_rx_auth(struct rtllib_device *ieee, struct sk_buff *skb,
 
 					if (ieee->current_network.mode ==
 					    IEEE_N_24G && bHalfSupportNmode) {
-						printk(KERN_INFO "======>enter "
-						       "half N mode\n");
+						printk(KERN_INFO
+						       "======>enter half N mode\n");
 						ieee->bHalfWirelessN24GMode =
 									 true;
 					} else
@@ -2368,11 +2370,12 @@ inline int rtllib_rx_auth(struct rtllib_device *ieee, struct sk_buff *skb,
 				}
 			} else {
 				ieee->softmac_stats.rx_auth_rs_err++;
-				RTLLIB_DEBUG_MGMT("Authentication respose"
-						  " status code 0x%x", errcode);
+				RTLLIB_DEBUG_MGMT("Authentication respose status code 0x%x",
+						  errcode);
 
-				printk(KERN_INFO "Authentication respose "
-				       "status code 0x%x", errcode);
+				printk(KERN_INFO
+				       "Authentication respose status code 0x%x",
+				       errcode);
 				rtllib_associate_abort(ieee);
 			}
 
@@ -2396,8 +2399,8 @@ inline int rtllib_rx_deauth(struct rtllib_device *ieee, struct sk_buff *skb)
 	if ((ieee->softmac_features & IEEE_SOFTMAC_ASSOCIATE) &&
 	    ieee->state == RTLLIB_LINKED &&
 	    (ieee->iw_mode == IW_MODE_INFRA)) {
-		printk(KERN_INFO "==========>received disassoc/deauth(%x) "
-		       "frame, reason code:%x\n",
+		printk(KERN_INFO
+		       "==========>received disassoc/deauth(%x) frame, reason code:%x\n",
 		       WLAN_FC_GET_STYPE(header->frame_ctl),
 		       ((struct rtllib_disassoc *)skb->data)->reason);
 		ieee->state = RTLLIB_ASSOCIATING;

commit 26049b11cb4dbe92243c9db5fd35ce7711d9b6bc
Author: Supriya Karanth <iskaranth@gmail.com>
Date:   Fri Mar 13 16:58:41 2015 +0900

    staging: rtl8192e: remove break after return
    
    Remove "break" statement after a "return" statement as
    it does not get executed.
    
    Found by checkpatch.pl - break is not useful after a goto
    or return
    
    Signed-off-by: Supriya Karanth <iskaranth@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index bee4b4398f2f..392bdf513ae2 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -2452,7 +2452,6 @@ inline int rtllib_rx_frame_softmac(struct rtllib_device *ieee,
 		break;
 	default:
 		return -1;
-		break;
 	}
 	return 0;
 }

commit 8b9733c1ad884548ba6417fee239e54693719f41
Author: Vaishali Thakkar <vthakkar1994@gmail.com>
Date:   Wed Mar 11 13:51:36 2015 +0530

    Staging: rtl8192e: Eliminate use of MSECS macro
    
    Use msecs_to_jiffies instead of driver specific macro
    MSECS. This is done using Coccinelle and semantic
    patch used for this is as follows:
    
    @@expression t;@@
    
    - MSECS(t)
    + msecs_to_jiffies(t)
    
    Signed-off-by: Vaishali Thakkar <vthakkar1994@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index c246ef40c69e..bee4b4398f2f 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -401,7 +401,7 @@ static void rtllib_send_beacon(struct rtllib_device *ieee)
 
 	if (ieee->beacon_txing && ieee->ieee_up)
 		mod_timer(&ieee->beacon_timer, jiffies +
-			  (MSECS(ieee->current_network.beacon_interval - 5)));
+			  (msecs_to_jiffies(ieee->current_network.beacon_interval - 5)));
 }
 
 
@@ -639,7 +639,7 @@ static void rtllib_softmac_scan_wq(void *data)
 		rtllib_send_probe_requests(ieee, 0);
 
 	queue_delayed_work_rsl(ieee->wq, &ieee->softmac_scan_wq,
-			       MSECS(RTLLIB_SOFTMAC_SCAN_TIME));
+			       msecs_to_jiffies(RTLLIB_SOFTMAC_SCAN_TIME));
 
 	up(&ieee->scan_sem);
 	return;
@@ -2008,9 +2008,11 @@ static short rtllib_sta_ps_sleep(struct rtllib_device *ieee, u64 *time)
 	if (dtim & (RTLLIB_DTIM_UCAST & ieee->ps))
 		return 2;
 
-	if (!time_after(jiffies, ieee->dev->trans_start + MSECS(timeout)))
+	if (!time_after(jiffies,
+			ieee->dev->trans_start + msecs_to_jiffies(timeout)))
 		return 0;
-	if (!time_after(jiffies, ieee->last_rx_ps_time + MSECS(timeout)))
+	if (!time_after(jiffies,
+			ieee->last_rx_ps_time + msecs_to_jiffies(timeout)))
 		return 0;
 	if ((ieee->softmac_features & IEEE_SOFTMAC_SINGLE_QUEUE) &&
 	    (ieee->mgmt_queue_tail != ieee->mgmt_queue_head))
@@ -2060,7 +2062,7 @@ static short rtllib_sta_ps_sleep(struct rtllib_device *ieee, u64 *time)
 			}
 
 		*time = ieee->current_network.last_dtim_sta_time
-			+ MSECS(ieee->current_network.beacon_interval *
+			+ msecs_to_jiffies(ieee->current_network.beacon_interval *
 			LPSAwakeIntvl_tmp);
 	}
 	}
@@ -2808,7 +2810,8 @@ static void rtllib_start_ibss_wq(void *data)
 
 inline void rtllib_start_ibss(struct rtllib_device *ieee)
 {
-	queue_delayed_work_rsl(ieee->wq, &ieee->start_ibss_wq, MSECS(150));
+	queue_delayed_work_rsl(ieee->wq, &ieee->start_ibss_wq,
+			       msecs_to_jiffies(150));
 }
 
 /* this is called only in user context, with wx_sem held */

commit d272f9ddce1b77271e3ab449c99257b3fc1fb3be
Author: Navya Sri Nizamkari <navyasri.tech@gmail.com>
Date:   Tue Mar 10 17:58:07 2015 +0530

    staging: rtl8192e: Use kzalloc instead of kmalloc.
    
    This patch uses kzalloc instead of kmalloc function.
    A coccinelle script was used to make this change.
    
    Signed-off-by: Navya Sri Nizamkari <navyasri.tech@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 16aef7cf23b9..c246ef40c69e 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -3421,12 +3421,11 @@ static int rtllib_wpa_set_encryption(struct rtllib_device *ieee,
 
 		lib80211_crypt_delayed_deinit(&ieee->crypt_info, crypt);
 
-		new_crypt = kmalloc(sizeof(*new_crypt), GFP_KERNEL);
+		new_crypt = kzalloc(sizeof(*new_crypt), GFP_KERNEL);
 		if (new_crypt == NULL) {
 			ret = -ENOMEM;
 			goto done;
 		}
-		memset(new_crypt, 0, sizeof(struct lib80211_crypt_data));
 		new_crypt->ops = ops;
 		if (new_crypt->ops)
 			new_crypt->priv =

commit cdbaf3f67279e7ee531c1be6da53731461a74237
Author: Aya Mahfouz <mahfouz.saif.elyazal@gmail.com>
Date:   Tue Mar 3 16:03:35 2015 +0200

    staging: rtl8192e: replace memset(x,0,ETH_ALEN) by eth_zero_addr(x)
    
    eth_zero_addr() is a wrapper function for memset if 0 is going to
    be assigned to a mac address. The replacement was done by the
    following coccinelle script:
    
    @header@
    @@
    
    #include <linux/etherdevice.h>
    
    @eth_zero_addr@
    expression e;
    @@
    
    -memset(e,0,ETH_ALEN);
    +eth_zero_addr(e);
    
    @eth_broadcast_addr@
    identifier e;
    @@
    
    -memset(e,\(0xff\|0xFF\|255\),ETH_ALEN);
    +eth_broadcast_addr(e);
    
    @linux_header depends on !header && (eth_zero_addr || eth_broadcast_addr) @
    @@
    
    + #include <linux/etherdevice.h>
    +
    
    @special_header depends on !header && !linux_header && (eth_zero_addr || eth_broadcast_addr) @
    @@
    
    +
    + #include <linux/etherdevice.h>
    +
    
    @custom_header depends on !header && !linux_header && !special_header && (eth_zero_addr || eth_broadcast_addr) @
    @@
    
    +
    + #include <linux/etherdevice.h>
    
    Signed-off-by: Aya Mahfouz <mahfouz.saif.elyazal@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index d992a754e72d..16aef7cf23b9 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -3751,7 +3751,7 @@ void notify_wx_assoc_event(struct rtllib_device *ieee)
 
 		printk(KERN_INFO "%s(): Tell user space disconnected\n",
 		       __func__);
-		memset(wrqu.ap_addr.sa_data, 0, ETH_ALEN);
+		eth_zero_addr(wrqu.ap_addr.sa_data);
 	}
 	wireless_send_event(ieee->dev, SIOCGIWAP, &wrqu, NULL);
 }

commit 876e20d333c07b51b6452dbbd7f02c624b65e250
Author: Devendra Naga <devendra.aaru@gmail.com>
Date:   Sun Nov 23 22:12:20 2014 -0500

    staging: rtl8192e: add missing tasklet_kill on remove path
    
    The powersave tasklet is created in rtllib_softmac_init and
    it is not removed while unloading the module.
    
    Cc: Larry Finger <Larry.Finger@lwfinger.net>
    Signed-off-by: Devendra Naga <devendra.aaru@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index e970db474470..d992a754e72d 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -3168,6 +3168,7 @@ void rtllib_softmac_free(struct rtllib_device *ieee)
 	cancel_delayed_work(&ieee->associate_retry_wq);
 	destroy_workqueue(ieee->wq);
 	up(&ieee->wx_sem);
+	tasklet_kill(&ieee->ps_task);
 }
 
 /********************************************************

commit 16fc54ee26912d3f2450bc4832b19c943dbdff17
Author: Behan Webster <behanw@converseincode.com>
Date:   Wed Oct 29 15:42:23 2014 -0700

    staging, rtl8192e, LLVMLinux: Make static local in inline function const
    
    rtllib_association_req is a (large) inline function which defines 2 constant
    static arrays which aren't labelled as const. As a result clang complains with:
    
    non-constant static local variable in inline function may be different in
    different files
    [-Wstatic-local-in-inline]
      static u8       AironetIeOui[] = {0x00, 0x01, 0x66};
      ^
    The solution is making them "static const".
    
    However doing so requires dropping const when being used with struct
    octet_string. However the value is used in a const fashion thereafter, so no
    harm done.
    
    Signed-off-by: Behan Webster <behanw@converseincode.com>
    Suggested-by: Arnd Bergmann <arnd@arndb.de>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 089a058ad2ed..e970db474470 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -1311,7 +1311,7 @@ inline struct sk_buff *rtllib_association_req(struct rtllib_network *beacon,
 	}
 
 	if (beacon->bCkipSupported) {
-		static u8	AironetIeOui[] = {0x00, 0x01, 0x66};
+		static const u8 AironetIeOui[] = {0x00, 0x01, 0x66};
 		u8	CcxAironetBuf[30];
 		struct octet_string osCcxAironetIE;
 
@@ -1331,10 +1331,11 @@ inline struct sk_buff *rtllib_association_req(struct rtllib_network *beacon,
 	}
 
 	if (beacon->bCcxRmEnable) {
-		static u8 CcxRmCapBuf[] = {0x00, 0x40, 0x96, 0x01, 0x01, 0x00};
+		static const u8 CcxRmCapBuf[] = {0x00, 0x40, 0x96, 0x01, 0x01,
+			0x00};
 		struct octet_string osCcxRmCap;
 
-		osCcxRmCap.Octet = CcxRmCapBuf;
+		osCcxRmCap.Octet = (u8 *) CcxRmCapBuf;
 		osCcxRmCap.Length = sizeof(CcxRmCapBuf);
 		tag = skb_put(skb, ccxrm_ie_len);
 		*tag++ = MFIE_TYPE_GENERIC;

commit d82f0029e03d8512ac523ac2e4caa5cecb989570
Author: Behan Webster <behanw@converseincode.com>
Date:   Wed Oct 29 15:42:22 2014 -0700

    staging, rtl8192e, LLVMLinux: Remove unused prototype
    
    MgntQuery_MgntFrameTxRate is only used within rtllib_softmac.c, so it really
    should be static instead of extern.
    
    Since it is currently extern a warning is generated because a different
    function of the same name is defined staticlly in ieee80211_softmac.c
    
    Removing the incorrect extern declaration and defining the rtllib_softmac
    version of this routine static fixes the warning.
    
    Signed-off-by: Behan Webster <behanw@converseincode.com>
    Suggested-by: Arnd Bergmann <arnd@arndb.de>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 067a45ab97dd..089a058ad2ed 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -193,7 +193,7 @@ MgntQuery_TxRateExcludeCCKRates(struct rtllib_device *ieee)
 	return QueryRate;
 }
 
-u8 MgntQuery_MgntFrameTxRate(struct rtllib_device *ieee)
+static u8 MgntQuery_MgntFrameTxRate(struct rtllib_device *ieee)
 {
 	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
 	u8 rate;

commit 6d91857d4826b382b3fd4fad95f52713be646f96
Author: Behan Webster <behanw@converseincode.com>
Date:   Wed Oct 29 15:42:20 2014 -0700

    staging, rtl8192e, LLVMLinux: Change extern inline to static inline
    
    With compilers which follow the C99 standard (like modern versions of gcc and
    clang), "extern inline" does the opposite thing from older versions of gcc
    (emits code for an externally linkable version of the inline function).
    
    "static inline" does the intended behavior in all cases instead.
    
    Signed-off-by: Behan Webster <behanw@converseincode.com>
    Suggested-by: Arnd Bergmann <arnd@arndb.de>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index abb6729ae279..067a45ab97dd 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -343,7 +343,7 @@ inline void softmac_ps_mgmt_xmit(struct sk_buff *skb,
 	}
 }
 
-inline struct sk_buff *rtllib_probe_req(struct rtllib_device *ieee)
+static inline struct sk_buff *rtllib_probe_req(struct rtllib_device *ieee)
 {
 	unsigned int len, rate_len;
 	u8 *tag;

commit 92db2a276c6ad8ded8e1fea2329d4d00394f5ad4
Author: Mahati Chamarthy <mahati.chamarthy@gmail.com>
Date:   Mon Sep 22 01:21:48 2014 +0530

    Staging: rtl8192e: Fix else is not useful warning style
    
    This fixes the following checkpatch.pl warnings:
    WARNING: else is not generally useful after a break or return
    
    Signed-off-by: Mahati Chamarthy <mahati.chamarthy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index cbe1d354907a..abb6729ae279 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -1161,8 +1161,7 @@ inline int SecIsInPMKIDList(struct rtllib_device *ieee, u8 *bssid)
 		if ((ieee->PMKIDList[i].bUsed) &&
 		   (memcmp(ieee->PMKIDList[i].Bssid, bssid, ETH_ALEN) == 0))
 			break;
-		else
-			i++;
+		i++;
 	} while (i < NUM_PMKID_CACHE);
 
 	if (i == NUM_PMKID_CACHE)
@@ -2261,14 +2260,13 @@ inline int rtllib_rx_assoc_resp(struct rtllib_device *ieee, struct sk_buff *skb,
 							network, rx_stats)) {
 					kfree(network);
 					return 1;
-				} else {
-					memcpy(ieee->pHTInfo->PeerHTCapBuf,
-					       network->bssht.bdHTCapBuf,
-					       network->bssht.bdHTCapLen);
-					memcpy(ieee->pHTInfo->PeerHTInfoBuf,
-					       network->bssht.bdHTInfoBuf,
-					       network->bssht.bdHTInfoLen);
 				}
+				memcpy(ieee->pHTInfo->PeerHTCapBuf,
+				       network->bssht.bdHTCapBuf,
+				       network->bssht.bdHTCapLen);
+				memcpy(ieee->pHTInfo->PeerHTInfoBuf,
+				       network->bssht.bdHTInfoBuf,
+				       network->bssht.bdHTInfoLen);
 				if (ieee->handle_assoc_response != NULL)
 					ieee->handle_assoc_response(ieee->dev,
 						 (struct rtllib_assoc_response_frame *)header,

commit 3a6b70c3f3558a2e47d2ca82752f0aed0f3c33c6
Author: Matthew Casey <mdcasey@chabloom.com>
Date:   Fri Aug 22 06:27:52 2014 -0400

    staging: rtl8192e: fixed coding style issues
    
    Fixed missing blank line after declarations issues
    
    Signed-off-by: Matthew Casey <mdcasey@chabloom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 684ceed17232..cbe1d354907a 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -130,6 +130,7 @@ void rtllib_TURBO_Info(struct rtllib_device *ieee, u8 **tag_p)
 static void enqueue_mgmt(struct rtllib_device *ieee, struct sk_buff *skb)
 {
 	int nh;
+
 	nh = (ieee->mgmt_queue_head + 1) % MGMT_QUEUE_NUM;
 
 /*
@@ -222,6 +223,7 @@ inline void softmac_mgmt_xmit(struct sk_buff *skb, struct rtllib_device *ieee)
 		(struct rtllib_hdr_3addr  *) skb->data;
 
 	struct cb_desc *tcb_desc = (struct cb_desc *)(skb->cb + 8);
+
 	spin_lock_irqsave(&ieee->lock, flags);
 
 	/* called with 2nd param 0, no mgmt lock required */
@@ -387,6 +389,7 @@ struct sk_buff *rtllib_get_beacon_(struct rtllib_device *ieee);
 static void rtllib_send_beacon(struct rtllib_device *ieee)
 {
 	struct sk_buff *skb;
+
 	if (!ieee->ieee_up)
 		return;
 	skb = rtllib_get_beacon_(ieee);
@@ -495,6 +498,7 @@ EXPORT_SYMBOL(rtllib_DisableIntelPromiscuousMode);
 static void rtllib_send_probe(struct rtllib_device *ieee, u8 is_mesh)
 {
 	struct sk_buff *skb;
+
 	skb = rtllib_probe_req(ieee);
 	if (skb) {
 		softmac_mgmt_xmit(skb, ieee);
@@ -657,6 +661,7 @@ static void rtllib_softmac_scan_wq(void *data)
 static void rtllib_beacons_start(struct rtllib_device *ieee)
 {
 	unsigned long flags;
+
 	spin_lock_irqsave(&ieee->beacon_lock, flags);
 
 	ieee->beacon_txing = 1;
@@ -795,6 +800,7 @@ inline struct sk_buff *rtllib_authentication_req(struct rtllib_network *beacon,
 	struct sk_buff *skb;
 	struct rtllib_authentication *auth;
 	int  len = 0;
+
 	len = sizeof(struct rtllib_authentication) + challengelen +
 		     ieee->tx_headroom + 4;
 	skb = dev_alloc_skb(len);
@@ -1043,6 +1049,7 @@ static struct sk_buff *rtllib_auth_resp(struct rtllib_device *ieee, int status,
 	struct sk_buff *skb = NULL;
 	struct rtllib_authentication *auth;
 	int len = ieee->tx_headroom + sizeof(struct rtllib_authentication) + 1;
+
 	skb = dev_alloc_skb(len);
 	if (!skb)
 		return NULL;
@@ -1139,8 +1146,8 @@ static void rtllib_resp_to_auth(struct rtllib_device *ieee, int s, u8 *dest)
 
 static void rtllib_resp_to_probe(struct rtllib_device *ieee, u8 *dest)
 {
-
 	struct sk_buff *buf = rtllib_probe_resp(ieee, dest);
+
 	if (buf)
 		softmac_mgmt_xmit(buf, ieee);
 }
@@ -1192,6 +1199,7 @@ inline struct sk_buff *rtllib_association_req(struct rtllib_network *beacon,
 	unsigned int turbo_info_len = beacon->Turbo_Enable ? 9 : 0;
 
 	int len = 0;
+
 	crypt = ieee->crypt_info.crypt[ieee->crypt_info.tx_keyidx];
 	if (crypt != NULL)
 		encrypt = ieee->host_encrypt && crypt && crypt->ops &&
@@ -1339,6 +1347,7 @@ inline struct sk_buff *rtllib_association_req(struct rtllib_network *beacon,
 	if (beacon->BssCcxVerNumber >= 2) {
 		u8 CcxVerNumBuf[] = {0x00, 0x40, 0x96, 0x03, 0x00};
 		struct octet_string osCcxVerNum;
+
 		CcxVerNumBuf[4] = beacon->BssCcxVerNumber;
 		osCcxVerNum.Octet = CcxVerNumBuf;
 		osCcxVerNum.Length = sizeof(CcxVerNumBuf);
@@ -1418,8 +1427,8 @@ inline struct sk_buff *rtllib_association_req(struct rtllib_network *beacon,
 
 void rtllib_associate_abort(struct rtllib_device *ieee)
 {
-
 	unsigned long flags;
+
 	spin_lock_irqsave(&ieee->lock, flags);
 
 	ieee->associate_seq++;
@@ -1789,6 +1798,7 @@ static inline u16 auth_parse(struct sk_buff *skb, u8 **challenge, int *chlen)
 {
 	struct rtllib_authentication *a;
 	u8 *t;
+
 	if (skb->len <  (sizeof(struct rtllib_authentication) -
 	    sizeof(struct rtllib_info_element))) {
 		RTLLIB_DEBUG_MGMT("invalid len in auth resp: %d\n", skb->len);
@@ -1924,6 +1934,7 @@ static inline u16 assoc_parse(struct rtllib_device *ieee, struct sk_buff *skb,
 void rtllib_rx_probe_rq(struct rtllib_device *ieee, struct sk_buff *skb)
 {
 	u8 dest[ETH_ALEN];
+
 	ieee->softmac_stats.rx_probe_rq++;
 	if (probe_rq_parse(ieee, skb, dest) > 0) {
 		ieee->softmac_stats.tx_probe_rs++;
@@ -1936,6 +1947,7 @@ static inline void rtllib_rx_auth_rq(struct rtllib_device *ieee,
 {
 	u8 dest[ETH_ALEN];
 	int status;
+
 	ieee->softmac_stats.rx_auth_rq++;
 
 	status = auth_rq_parse(skb, dest);
@@ -2026,6 +2038,7 @@ static short rtllib_sta_ps_sleep(struct rtllib_device *ieee, u64 *time)
 			u8 LPSAwakeIntvl_tmp = 0;
 			u8 period = ieee->current_network.dtim_period;
 			u8 count = ieee->current_network.tim.tim_count;
+
 			if (count == 0) {
 				if (pPSC->LPSAwakeIntvl > period)
 					LPSAwakeIntvl_tmp = period +
@@ -2514,6 +2527,7 @@ void rtllib_softmac_xmit(struct rtllib_txb *txb, struct rtllib_device *ieee)
 static void rtllib_resume_tx(struct rtllib_device *ieee)
 {
 	int i;
+
 	for (i = ieee->tx_pending.frag; i < ieee->tx_pending.txb->nr_frags;
 	     i++) {
 
@@ -2606,6 +2620,7 @@ void rtllib_stop_queue(struct rtllib_device *ieee)
 void rtllib_stop_all_queues(struct rtllib_device *ieee)
 {
 	unsigned int i;
+
 	for (i = 0; i < ieee->dev->num_tx_queues; i++)
 		netdev_get_tx_queue(ieee->dev, i)->trans_start = jiffies;
 
@@ -2801,6 +2816,7 @@ inline void rtllib_start_ibss(struct rtllib_device *ieee)
 void rtllib_start_bss(struct rtllib_device *ieee)
 {
 	unsigned long flags;
+
 	if (IS_DOT11D_ENABLE(ieee) && !IS_COUNTRY_IE_VALID(ieee)) {
 		if (!ieee->bGlobalDomain)
 			return;
@@ -2900,6 +2916,7 @@ struct sk_buff *rtllib_get_beacon_(struct rtllib_device *ieee)
 
 	struct sk_buff *skb;
 	struct rtllib_probe_response *b;
+
 	skb = rtllib_probe_resp(ieee, broadcast_addr);
 
 	if (!skb)
@@ -3049,6 +3066,7 @@ void rtllib_start_protocol(struct rtllib_device *ieee)
 void rtllib_softmac_init(struct rtllib_device *ieee)
 {
 	int i;
+
 	memset(&ieee->current_network, 0, sizeof(struct rtllib_network));
 
 	ieee->state = RTLLIB_NOLINK;
@@ -3513,6 +3531,7 @@ inline struct sk_buff *rtllib_disassociate_skb(struct rtllib_network *beacon,
 	struct sk_buff *skb;
 	struct rtllib_disassoc *disass;
 	int len = sizeof(struct rtllib_disassoc) + ieee->tx_headroom;
+
 	skb = dev_alloc_skb(len);
 
 	if (!skb)

commit 4764ca981b040048766e4f39a45a4b9c5cecff9c
Author: Peter Senna Tschudin <peter.senna@gmail.com>
Date:   Mon May 26 16:08:50 2014 +0200

    drivers/staging: Remove useless return variables
    
    This patch remove variables that are initialized with a constant,
    are never updated, and are only used as parameter of return.
    Return the constant instead of using a variable.
    
    Verified by compilation only.
    
    The coccinelle script that find and fixes this issue is:
    // <smpl>
    @@
    type T;
    constant C;
    identifier ret;
    @@
    - T ret = C;
    ... when != ret
        when strict
    return
    - ret
    + C
    ;
    // </smpl>
    
    Signed-off-by: Peter Senna Tschudin <peter.senna@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index d65cba428941..684ceed17232 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -3239,7 +3239,6 @@ static int rtllib_wpa_set_auth_algs(struct rtllib_device *ieee, int value)
 	struct rtllib_security sec = {
 		.flags = SEC_AUTH_MODE,
 	};
-	int ret = 0;
 
 	if (value & AUTH_ALG_SHARED_KEY) {
 		sec.auth_mode = WLAN_AUTH_SHARED_KEY;
@@ -3259,7 +3258,7 @@ static int rtllib_wpa_set_auth_algs(struct rtllib_device *ieee, int value)
 	if (ieee->set_security)
 		ieee->set_security(ieee->dev, &sec);
 
-	return ret;
+	return 0;
 }
 
 static int rtllib_wpa_set_param(struct rtllib_device *ieee, u8 name, u32 value)

commit 430fb250902b7d563216077bc018108dd20cf8fa
Author: Masanari Iida <standby24x7@gmail.com>
Date:   Fri Apr 25 01:48:41 2014 +0900

    staging: rtl8192e: Fix typo in rtl8192e
    
    Fix spelling typo in comments within rtl8192e.
    
    Signed-off-by: Masanari Iida <standby24x7@gmail.com>
    Reviewed-by: James Cameron <quozl@laptop.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 4bf72bc1ba7b..d65cba428941 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -543,7 +543,7 @@ void rtllib_softmac_scan_syncro(struct rtllib_device *ieee, u8 is_mesh)
 				goto out; /* scan completed */
 		} while (!ieee->active_channel_map[ch]);
 
-		/* this fuction can be called in two situations
+		/* this function can be called in two situations
 		 * 1- We have switched to ad-hoc mode and we are
 		 *    performing a complete syncro scan before conclude
 		 *    there are no interesting cell and to create a

commit a0711c4da327de531a9f4af7a40d7043d06771b4
Author: Matthias Schoepe <matthias.schoepe@studium.uni-erlangen.de>
Date:   Thu Dec 26 20:23:32 2013 +0100

    Staging rtl8192e: Fixing checkpatch errors
    
    We fixed checkpatch errors of the following type:
            ERROR: "foo * bar" should be "foo *bar"
    
    The error was fixed in the following files of the rtl8192e staging driver:
            rtllib_softmac.c
            rtllib_rx.c
            rtllib_crypt.c
            rtllib.h
    
    There are no functional changes in this patch.
    
    Signed-off-by: Matthias Schoepe <matthias.schoepe@studium.uni-erlangen.de>
    Signed-off-by: Andreas Frembs <andreas.frembs@studium.uni-erlangen.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index eeec19cde229..4bf72bc1ba7b 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -1451,7 +1451,7 @@ static void rtllib_associate_abort_cb(unsigned long dev)
 	rtllib_associate_abort((struct rtllib_device *) dev);
 }
 
-static void rtllib_associate_step1(struct rtllib_device *ieee, u8 * daddr)
+static void rtllib_associate_step1(struct rtllib_device *ieee, u8 *daddr)
 {
 	struct rtllib_network *beacon = &ieee->current_network;
 	struct sk_buff *skb;
@@ -1785,7 +1785,7 @@ void rtllib_softmac_check_all_nets(struct rtllib_device *ieee)
 	spin_unlock_irqrestore(&ieee->lock, flags);
 }
 
-static inline u16 auth_parse(struct sk_buff *skb, u8** challenge, int *chlen)
+static inline u16 auth_parse(struct sk_buff *skb, u8 **challenge, int *chlen)
 {
 	struct rtllib_authentication *a;
 	u8 *t;

commit c5654c0bf9718816535e3df661777d697c7b926e
Author: Rashika Kheria <rashika.kheria@gmail.com>
Date:   Thu Nov 7 19:05:09 2013 +0530

    Staging: rtl8192e: Fix Sparse Warning for Static Declarations in rtllib_softmac.c
    
    This patch fixes the following Sparse warnings in rtllib_softmac.c-
    
    drivers/staging/rtl8192e/rtllib_softmac.c:3636:12: warning: symbol 'rtllib_MgntDisconnectIBSS' was not declared. Should it be static?
    drivers/staging/rtl8192e/rtllib_softmac.c:3661:13: warning: symbol 'rtllib_MlmeDisassociateRequest' was not declared. Should it be static?
    drivers/staging/rtl8192e/rtllib_softmac.c:3687:13: warning: symbol 'rtllib_MgntDisconnectAP' was not declared. Should it be static?
    
    Signed-off-by: Rashika Kheria <rashika.kheria@gmail.com>
    Reviewed-by: Peter P Waskiewicz Jr <peter.p.waskiewicz.jr@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 31cb858d978e..eeec19cde229 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -3633,7 +3633,7 @@ int rtllib_wpa_supplicant_ioctl(struct rtllib_device *ieee, struct iw_point *p,
 }
 EXPORT_SYMBOL(rtllib_wpa_supplicant_ioctl);
 
-void rtllib_MgntDisconnectIBSS(struct rtllib_device *rtllib)
+static void rtllib_MgntDisconnectIBSS(struct rtllib_device *rtllib)
 {
 	u8	OpMode;
 	u8	i;
@@ -3658,7 +3658,7 @@ void rtllib_MgntDisconnectIBSS(struct rtllib_device *rtllib)
 
 }
 
-void rtllib_MlmeDisassociateRequest(struct rtllib_device *rtllib, u8 *asSta,
+static void rtllib_MlmeDisassociateRequest(struct rtllib_device *rtllib, u8 *asSta,
 				    u8 asRsn)
 {
 	u8 i;
@@ -3684,7 +3684,7 @@ void rtllib_MlmeDisassociateRequest(struct rtllib_device *rtllib, u8 *asSta,
 
 }
 
-void
+static void
 rtllib_MgntDisconnectAP(
 	struct rtllib_device *rtllib,
 	u8 asRsn

commit 1830a6d840d7bcc9fa3e4ad07b405e3432cc5282
Author: Rashika Kheria <rashika.kheria@gmail.com>
Date:   Thu Nov 7 18:58:57 2013 +0530

    Staging: rtl8192e: Fix incorrect type in assignment in rtllib_softmac.c
    
    This patch fixes the following Sparse warning in rtllib_softmac.c-
    
    drivers/staging/rtl8192e/rtllib_softmac.c:298:12: warning: incorrect type in assignment (different base types)
    drivers/staging/rtl8192e/rtllib_softmac.c:298:12:    expected unsigned short [unsigned] [usertype] fc
    drivers/staging/rtl8192e/rtllib_softmac.c:298:12:    got restricted __le16 [usertype] frame_ctl
    
    drivers/staging/rtl8192e/rtllib_softmac.c:810:32: warning: incorrect type in assignment (different base types)
    drivers/staging/rtl8192e/rtllib_softmac.c:810:32:    expected restricted __le16 [usertype] frame_ctl
    drivers/staging/rtl8192e/rtllib_softmac.c:810:32:    got int
    
    drivers/staging/rtl8192e/rtllib_softmac.c:814:34: warning: incorrect type in assignment (different base types)
    drivers/staging/rtl8192e/rtllib_softmac.c:814:34:    expected restricted __le16 [usertype] duration_id
    drivers/staging/rtl8192e/rtllib_softmac.c:814:34:    got int
    
    drivers/staging/rtl8192e/rtllib_softmac.c:821:33: warning: incorrect type in assignment (different base types)
    drivers/staging/rtl8192e/rtllib_softmac.c:821:33:    expected restricted __le16 [usertype] algorithm
    drivers/staging/rtl8192e/rtllib_softmac.c:821:33:    got int
    
    drivers/staging/rtl8192e/rtllib_softmac.c:955:24: warning: incorrect type in assignment (different base types)
    drivers/staging/rtl8192e/rtllib_softmac.c:955:24:    expected unsigned short [unsigned] [usertype] val16
    drivers/staging/rtl8192e/rtllib_softmac.c:955:24:    got restricted __le16 [usertype] <noident>
    
    drivers/staging/rtl8192e/rtllib_softmac.c:1263:33: warning: incorrect type in assignment (different base types)
    drivers/staging/rtl8192e/rtllib_softmac.c:1263:33:    expected restricted __le16 [usertype] duration_id
    drivers/staging/rtl8192e/rtllib_softmac.c:1263:33:    got int
    
    drivers/staging/rtl8192e/rtllib_softmac.c:1282:30: warning: incorrect type in assignment (different base types)
    drivers/staging/rtl8192e/rtllib_softmac.c:1282:30:    expected restricted __le16 [usertype] listen_interval
    drivers/staging/rtl8192e/rtllib_softmac.c:1282:30:    got unsigned short [unsigned] [usertype] listen_interval
    
    Signed-off-by: Rashika Kheria <rashika.kheria@gmail.com>
    Reviewed-by: Peter P Waskiewicz Jr <peter.p.waskiewicz.jr@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 721ee254b820..31cb858d978e 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -295,7 +295,7 @@ inline void softmac_ps_mgmt_xmit(struct sk_buff *skb,
 	u16 fc, type, stype;
 	struct cb_desc *tcb_desc = (struct cb_desc *)(skb->cb + 8);
 
-	fc = header->frame_ctl;
+	fc = le16_to_cpu(header->frame_ctl);
 	type = WLAN_FC_GET_TYPE(fc);
 	stype = WLAN_FC_GET_STYPE(fc);
 
@@ -807,18 +807,18 @@ inline struct sk_buff *rtllib_authentication_req(struct rtllib_network *beacon,
 	auth = (struct rtllib_authentication *)
 		skb_put(skb, sizeof(struct rtllib_authentication));
 
-	auth->header.frame_ctl = RTLLIB_STYPE_AUTH;
+	auth->header.frame_ctl = cpu_to_le16(RTLLIB_STYPE_AUTH);
 	if (challengelen)
 		auth->header.frame_ctl |= cpu_to_le16(RTLLIB_FCTL_WEP);
 
-	auth->header.duration_id = 0x013a;
+	auth->header.duration_id = cpu_to_le16(0x013a);
 	memcpy(auth->header.addr1, beacon->bssid, ETH_ALEN);
 	memcpy(auth->header.addr2, ieee->dev->dev_addr, ETH_ALEN);
 	memcpy(auth->header.addr3, beacon->bssid, ETH_ALEN);
 	if (ieee->auth_mode == 0)
 		auth->algorithm = WLAN_AUTH_OPEN;
 	else if (ieee->auth_mode == 1)
-		auth->algorithm = WLAN_AUTH_SHARED_KEY;
+		auth->algorithm = cpu_to_le16(WLAN_AUTH_SHARED_KEY);
 	else if (ieee->auth_mode == 2)
 		auth->algorithm = WLAN_AUTH_OPEN;
 	auth->transaction = cpu_to_le16(ieee->associate_seq);
@@ -952,7 +952,7 @@ static struct sk_buff *rtllib_probe_resp(struct rtllib_device *ieee, u8 *dest)
 		u16 val16;
 		*(tag++) = MFIE_TYPE_IBSS_SET;
 		*(tag++) = 2;
-		 val16 = cpu_to_le16(ieee->current_network.atim_window);
+		val16 = ieee->current_network.atim_window;
 		memcpy((u8 *)tag, (u8 *)&val16, 2);
 		tag += 2;
 	}
@@ -1260,7 +1260,7 @@ inline struct sk_buff *rtllib_association_req(struct rtllib_network *beacon,
 
 
 	hdr->header.frame_ctl = RTLLIB_STYPE_ASSOC_REQ;
-	hdr->header.duration_id = 37;
+	hdr->header.duration_id = cpu_to_le16(37);
 	memcpy(hdr->header.addr1, beacon->bssid, ETH_ALEN);
 	memcpy(hdr->header.addr2, ieee->dev->dev_addr, ETH_ALEN);
 	memcpy(hdr->header.addr3, beacon->bssid, ETH_ALEN);
@@ -1279,7 +1279,7 @@ inline struct sk_buff *rtllib_association_req(struct rtllib_network *beacon,
 		hdr->capability |= cpu_to_le16(WLAN_CAPABILITY_SHORT_SLOT_TIME);
 
 
-	hdr->listen_interval = beacon->listen_interval;
+	hdr->listen_interval = cpu_to_le16(beacon->listen_interval);
 
 	hdr->info_element[0].id = MFIE_TYPE_SSID;
 

commit 7fe30a7d4af6a0cce07b6ca9dd2a624eead661d2
Author: Rashika Kheria <rashika.kheria@gmail.com>
Date:   Thu Nov 7 18:57:37 2013 +0530

    Staging: rtl8192e: Fix Sparse Warning of invalid assignment '|=' in rtllib_softmac.c
    
    This patch fixes the following Sparse warning in rtllib_softmac.c-
    
    drivers/staging/rtl8192e/rtllib_softmac.c:812:40: warning: invalid assignment: |=
    drivers/staging/rtl8192e/rtllib_softmac.c:812:40:    left side has  type restricted __le16
    drivers/staging/rtl8192e/rtllib_softmac.c:812:40:    right side has type int
    
    drivers/staging/rtl8192e/rtllib_softmac.c:924:17: warning: invalid assignment: |=
    drivers/staging/rtl8192e/rtllib_softmac.c:924:17:    left side has type restricted __le16
    drivers/staging/rtl8192e/rtllib_softmac.c:924:17:    right side has type int
    drivers/staging/rtl8192e/rtllib_softmac.c:924:17: error: cast from unknown type
    
    Signed-off-by: Rashika Kheria <rashika.kheria@gmail.com>
    Reviewed-by: Peter P Waskiewicz Jr <peter.p.waskiewicz.jr@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 0ad159f52d4c..721ee254b820 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -809,7 +809,7 @@ inline struct sk_buff *rtllib_authentication_req(struct rtllib_network *beacon,
 
 	auth->header.frame_ctl = RTLLIB_STYPE_AUTH;
 	if (challengelen)
-		auth->header.frame_ctl |= RTLLIB_FCTL_WEP;
+		auth->header.frame_ctl |= cpu_to_le16(RTLLIB_FCTL_WEP);
 
 	auth->header.duration_id = 0x013a;
 	memcpy(auth->header.addr1, beacon->bssid, ETH_ALEN);
@@ -921,8 +921,8 @@ static struct sk_buff *rtllib_probe_resp(struct rtllib_device *ieee, u8 *dest)
 
 	if (ieee->short_slot && (ieee->current_network.capability &
 	    WLAN_CAPABILITY_SHORT_SLOT_TIME))
-		cpu_to_le16((beacon_buf->capability |=
-				 WLAN_CAPABILITY_SHORT_SLOT_TIME));
+		beacon_buf->capability |=
+			cpu_to_le16(WLAN_CAPABILITY_SHORT_SLOT_TIME);
 
 	crypt = ieee->crypt_info.crypt[ieee->crypt_info.tx_keyidx];
 	if (encrypt)

commit f7df1918b5f4fe140baf1eda68ff0853774bbcd6
Author: Rashika Kheria <rashika.kheria@gmail.com>
Date:   Thu Nov 7 18:56:28 2013 +0530

    Staging: rtl8192e: Fix Sparse warning of restricted __le16 degrades to integer in rtllib_softmac.c
    
    This patch fixes the following Sparse warning in rtllib_softmac.c-
    drivers/staging/rtl8192e/rtllib_softmac.c:230:19: warning: restricted __le16 degrades to integer
    
    Signed-off-by: Rashika Kheria <rashika.kheria@gmail.com>
    Reviewed-by: Peter P Waskiewicz Jr <peter.p.waskiewicz.jr@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 933bd6deaca1..0ad159f52d4c 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -227,7 +227,7 @@ inline void softmac_mgmt_xmit(struct sk_buff *skb, struct rtllib_device *ieee)
 	/* called with 2nd param 0, no mgmt lock required */
 	rtllib_sta_wakeup(ieee, 0);
 
-	if (header->frame_ctl == RTLLIB_STYPE_BEACON)
+	if (le16_to_cpu(header->frame_ctl) == RTLLIB_STYPE_BEACON)
 		tcb_desc->queue_index = BEACON_QUEUE;
 	else
 		tcb_desc->queue_index = MGNT_QUEUE;

commit 014e4c27c68a3ec40b19fef6ae0431e639632531
Author: Valentina Manea <valentina.manea.m@gmail.com>
Date:   Tue Oct 29 20:58:48 2013 +0200

    staging: rtl8192e: use true and false for bool variables
    
    This patch fixes coccinelle errors for bool variables
    initialized with 1 or 0 instead of true and false.
    
    Signed-off-by: Valentina Manea <valentina.manea.m@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 671fb5ac5744..933bd6deaca1 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -705,7 +705,7 @@ static void rtllib_softmac_stop_scan(struct rtllib_device *ieee)
 	ieee->scan_watch_dog = 0;
 	if (ieee->scanning_continue == 1) {
 		ieee->scanning_continue = 0;
-		ieee->actscanning = 0;
+		ieee->actscanning = false;
 
 		cancel_delayed_work(&ieee->softmac_scan_wq);
 	}
@@ -1574,7 +1574,7 @@ static void rtllib_associate_complete_wq(void *data)
 
 	if (ieee->is_silent_reset) {
 		printk(KERN_INFO "silent reset associate\n");
-		ieee->is_silent_reset = 0;
+		ieee->is_silent_reset = false;
 	}
 
 	if (ieee->data_hard_resume)
@@ -3097,7 +3097,7 @@ void rtllib_softmac_init(struct rtllib_device *ieee)
 	ieee->sta_edca_param[2] = 0x005E4342;
 	ieee->sta_edca_param[3] = 0x002F3262;
 	ieee->aggregation = true;
-	ieee->enable_rx_imm_BA = 1;
+	ieee->enable_rx_imm_BA = true;
 	ieee->tx_pending.txb = NULL;
 
 	_setup_timer(&ieee->associate_timer,

commit 216249819ff9fac9ba9f2d06c26194669b42a94a
Author: Teodora Baluta <teobaluta@gmail.com>
Date:   Sat Oct 26 09:18:22 2013 +0300

    staging: rtl8192e: use memdup_user to simplify code
    
    Use memdup_user rather than duplicating its implementation. This patch
    fixes the following coccinelle warnings:
    
    drivers/staging/rtl8192e/rtl8192e/rtl_core.c:2598:8-15: WARNING opportunity for memdup_user
    drivers/staging/rtl8192e/rtllib_softmac.c:3594:9-16: WARNING opportunity for memdup_user
    
    Signed-off-by: Teodora Baluta <teobaluta@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index e74d24212a39..671fb5ac5744 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -3590,14 +3590,9 @@ int rtllib_wpa_supplicant_ioctl(struct rtllib_device *ieee, struct iw_point *p,
 		goto out;
 	}
 
-	param = kmalloc(p->length, GFP_KERNEL);
-	if (param == NULL) {
-		ret = -ENOMEM;
-		goto out;
-	}
-	if (copy_from_user(param, p->pointer, p->length)) {
-		kfree(param);
-		ret = -EFAULT;
+	param = memdup_user(p->pointer, p->length);
+	if (IS_ERR(param)) {
+		ret = PTR_ERR(param);
 		goto out;
 	}
 

commit 4bb01423ab05af02feaba04823ba6b852dbe5aa6
Author: Valentina Manea <valentina.manea.m@gmail.com>
Date:   Fri Oct 25 11:28:10 2013 +0300

    staging: rtl8192e: do not use comparisons on bool tests
    
    This patch fixes coccinelle errors regarding comparisons
    used in bool tests.
    
    Signed-off-by: Valentina Manea <valentina.manea.m@gmail.com>
    Reviewed-by: Lisa Nguyen <lisa@xenapiadmin.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 0cbf6f5593a3..e74d24212a39 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -604,7 +604,7 @@ static void rtllib_softmac_scan_wq(void *data)
 
 	if (!ieee->ieee_up)
 		return;
-	if (rtllib_act_scanning(ieee, true) == true)
+	if (rtllib_act_scanning(ieee, true))
 		return;
 
 	down(&ieee->scan_sem);
@@ -1202,7 +1202,7 @@ inline struct sk_buff *rtllib_association_req(struct rtllib_network *beacon,
 
 	if ((ieee->rtllib_ap_sec_type &&
 	    (ieee->rtllib_ap_sec_type(ieee) & SEC_ALG_TKIP)) ||
-	    (ieee->bForcedBgMode == true)) {
+	    ieee->bForcedBgMode) {
 		ieee->pHTInfo->bEnableHT = 0;
 		ieee->mode = WIRELESS_MODE_G;
 	}
@@ -1535,7 +1535,7 @@ static void rtllib_associate_complete_wq(void *data)
 	struct rt_pwr_save_ctrl *pPSC = (struct rt_pwr_save_ctrl *)
 					(&(ieee->PowerSaveControl));
 	printk(KERN_INFO "Associated successfully\n");
-	if (ieee->is_silent_reset == 0) {
+	if (!ieee->is_silent_reset) {
 		printk(KERN_INFO "normal associate\n");
 		notify_wx_assoc_event(ieee);
 	}
@@ -1572,7 +1572,7 @@ static void rtllib_associate_complete_wq(void *data)
 	pPSC->LpsIdleCount = 0;
 	ieee->link_change(ieee->dev);
 
-	if (ieee->is_silent_reset == 1) {
+	if (ieee->is_silent_reset) {
 		printk(KERN_INFO "silent reset associate\n");
 		ieee->is_silent_reset = 0;
 	}
@@ -2005,7 +2005,7 @@ static short rtllib_sta_ps_sleep(struct rtllib_device *ieee, u64 *time)
 		return 0;
 
 	if (time) {
-		if (ieee->bAwakePktSent == true) {
+		if (ieee->bAwakePktSent) {
 			pPSC->LPSAwakeIntvl = 1;
 		} else {
 			u8		MaxPeriod = 1;
@@ -2338,8 +2338,7 @@ inline int rtllib_rx_auth(struct rtllib_device *ieee, struct sk_buff *skb,
 					}
 
 					if (ieee->current_network.mode ==
-					    IEEE_N_24G &&
-					    bHalfSupportNmode == true) {
+					    IEEE_N_24G && bHalfSupportNmode) {
 						printk(KERN_INFO "======>enter "
 						       "half N mode\n");
 						ieee->bHalfWirelessN24GMode =

commit 559a4c318ca303880fc9f26d50711791c16ae2f3
Author: Andrea Merello <andrea.merello@gmail.com>
Date:   Mon Aug 26 13:53:30 2013 +0200

    staging: Update e-mail address for Andrea Merello
    
    A lot of files contain reference to my old e-mail address.
    Now I'm going not to read mail from it anymore, so update it
    with my current address everywhere.
    
    Signed-off-by: Andrea Merello <andrea.merello@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index aefffac556a6..0cbf6f5593a3 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -1,5 +1,5 @@
 /* IEEE 802.11 SoftMAC layer
- * Copyright (c) 2005 Andrea Merello <andreamrl@tiscali.it>
+ * Copyright (c) 2005 Andrea Merello <andrea.merello@gmail.com>
  *
  * Mostly extracted from the rtl8180-sa2400 driver for the
  * in-kernel generic ieee802.11 stack.

commit 6dea0da1fff9ec1fcfc989e13cde451d5e7604ce
Author: Hema Prathaban <hemaklnce@gmail.com>
Date:   Tue May 14 21:01:22 2013 +0530

    staging: rtl8192e: Use kmemdup for duplicating memory
    
    Instead of allocating memory (kmalloc) and copying (memcpy)
    from source, memory can be duplicated using kmemdup
    
    Signed-off-by: Hema Prathaban <hemaklnce@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 8af0b9902615..aefffac556a6 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -1801,10 +1801,9 @@ static inline u16 auth_parse(struct sk_buff *skb, u8** challenge, int *chlen)
 
 		if (*(t++) == MFIE_TYPE_CHALLENGE) {
 			*chlen = *(t++);
-			*challenge = kmalloc(*chlen, GFP_ATOMIC);
+			*challenge = kmemdup(t, *chlen, GFP_ATOMIC);
 			if (!*challenge)
 				return -ENOMEM;
-			memcpy(*challenge, t, *chlen);
 		}
 	}
 	return cpu_to_le16(a->status);

commit ae053253a7971b6c97ad570e0f373974ca6d7e06
Author: Hema Prathaban <hemaklnce@gmail.com>
Date:   Tue May 14 20:59:19 2013 +0530

    staging: rtl8192e: Fix potential null dereference
    
    check memory is allocated in '*challenge' before using it.
    
    Signed-off-by: Hema Prathaban <hemaklnce@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 4feecec8609c..8af0b9902615 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -1802,7 +1802,9 @@ static inline u16 auth_parse(struct sk_buff *skb, u8** challenge, int *chlen)
 		if (*(t++) == MFIE_TYPE_CHALLENGE) {
 			*chlen = *(t++);
 			*challenge = kmalloc(*chlen, GFP_ATOMIC);
-			memcpy(*challenge, t, *chlen);	/*TODO - check here*/
+			if (!*challenge)
+				return -ENOMEM;
+			memcpy(*challenge, t, *chlen);
 		}
 	}
 	return cpu_to_le16(a->status);

commit f2635894e8e786d7c93a21f24efb690981d15842
Author: Adam Buchbinder <adam.buchbinder@gmail.com>
Date:   Wed Sep 19 21:51:07 2012 -0400

    staging: Fix misspellings of "whether".
    
    "Whether" is spelled "wether" in several places. This fixes those that
    are in the staging tree.
    
    Signed-off-by: Adam Buchbinder <adam.buchbinder@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 99e907d46224..4feecec8609c 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -267,7 +267,7 @@ inline void softmac_mgmt_xmit(struct sk_buff *skb, struct rtllib_device *ieee)
 		else
 			ieee->seq_ctrl[0]++;
 
-		/* check wether the managed packet queued greater than 5 */
+		/* check whether the managed packet queued greater than 5 */
 		if (!ieee->check_nic_enough_desc(ieee->dev, tcb_desc->queue_index) ||
 		    (skb_queue_len(&ieee->skb_waitQ[tcb_desc->queue_index]) != 0) ||
 		    (ieee->queue_stop)) {

commit 71cd7913cb7b28aa6e7daee217339fc8c70f1a0b
Author: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
Date:   Tue Aug 21 16:38:45 2012 +0800

    staging: rtl8192e: using random_ether_addr() to generate random MAC
    
    Using random_ether_addr() to generate a random Ethernet
    address (MAC) that is not multicast and has the local
    assigned bit set. Not need to duplicating its implementation.
    
    spatch with a semantic match is used to found this problem.
    (http://coccinelle.lip6.fr/)
    
    Signed-off-by: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 8027ceb53c58..99e907d46224 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -2620,13 +2620,7 @@ void rtllib_wake_all_queues(struct rtllib_device *ieee)
 inline void rtllib_randomize_cell(struct rtllib_device *ieee)
 {
 
-	get_random_bytes(ieee->current_network.bssid, ETH_ALEN);
-
-	/* an IBSS cell address must have the two less significant
-	 * bits of the first byte = 2
-	 */
-	ieee->current_network.bssid[0] &= ~0x01;
-	ieee->current_network.bssid[0] |= 0x02;
+	random_ether_addr(ieee->current_network.bssid);
 }
 
 /* called in user context only */

commit b4797fef980664ea5923b24795ed365177d68525
Author: Devendra Naga <devendra.aaru@gmail.com>
Date:   Wed Sep 5 00:54:41 2012 +0530

    staging: rtl8192e: remove casting of returned pointer from kmalloc
    
    as per Documentation/CodingStyle we dont need to cast the return of
    kmalloc
    
    Signed-off-by: Devendra Naga <devendra.aaru@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 22a276410001..8027ceb53c58 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -3410,8 +3410,7 @@ static int rtllib_wpa_set_encryption(struct rtllib_device *ieee,
 
 		lib80211_crypt_delayed_deinit(&ieee->crypt_info, crypt);
 
-		new_crypt = (struct lib80211_crypt_data *)
-			kmalloc(sizeof(*new_crypt), GFP_KERNEL);
+		new_crypt = kmalloc(sizeof(*new_crypt), GFP_KERNEL);
 		if (new_crypt == NULL) {
 			ret = -ENOMEM;
 			goto done;

commit 0c43e56c3001fa4c55b01abf0d8a12bbc79aa148
Author: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
Date:   Sun Aug 26 09:04:23 2012 +0800

    staging: rtl8192e: use is_broadcast_ether_addr() instead of memcmp()
    
    Using is_broadcast_ether_addr() instead of directly use
    memcmp() to determine if the ethernet address is broadcast
    address.
    
    spatch with a semantic match is used to found this problem.
    (http://coccinelle.lip6.fr/)
    
    Signed-off-by: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 7c95518fb312..22a276410001 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -19,6 +19,7 @@
 #include <linux/random.h>
 #include <linux/delay.h>
 #include <linux/uaccess.h>
+#include <linux/etherdevice.h>
 #include "dot11d.h"
 
 short rtllib_is_54g(struct rtllib_network *net)
@@ -1843,7 +1844,7 @@ static short probe_rq_parse(struct rtllib_device *ieee, struct sk_buff *skb,
 
 	bssid_match =
 	  (memcmp(header->addr3, ieee->current_network.bssid, ETH_ALEN) != 0) &&
-	  (memcmp(header->addr3, "\xff\xff\xff\xff\xff\xff", ETH_ALEN) != 0);
+	  (!is_broadcast_ether_addr(header->addr3));
 	if (bssid_match)
 		return -1;
 
@@ -3361,9 +3362,7 @@ static int rtllib_wpa_set_encryption(struct rtllib_device *ieee,
 			       param->u.crypt.key_len);
 		return -EINVAL;
 	}
-	if (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&
-	    param->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&
-	    param->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff) {
+	if (is_broadcast_ether_addr(param->sta_addr)) {
 		if (param->u.crypt.idx >= NUM_WEP_KEYS)
 			return -EINVAL;
 		crypt = &ieee->crypt_info.crypt[param->u.crypt.idx];

commit db2c8da02a2175fe2d129aa55fb0b790ec07a1ac
Author: Masanari Iida <standby24x7@gmail.com>
Date:   Fri Aug 10 01:37:31 2012 +0900

    staging: rtl8192e: Fix typo in staging/rtl8192e
    
    Correct spelling typo in staging/rtl8192e.
    
    Signed-off-by: Masanari Iida <standby24x7@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index a21b4d91a596..7c95518fb312 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -1687,7 +1687,7 @@ inline void rtllib_softmac_new_net(struct rtllib_device *ieee,
 		 * if the network does broadcast and the user did set essid
 		 * check if essid match
 		 * if the ap is not set, check that the user set the bssid
-		 * and the network does bradcast and that those two bssid match
+		 * and the network does broadcast and that those two bssid match
 		 */
 		if ((apset && apmatch &&
 		   ((ssidset && ssidbroad && ssidmatch) ||
@@ -2442,7 +2442,7 @@ inline int rtllib_rx_frame_softmac(struct rtllib_device *ieee,
 	return 0;
 }
 
-/* following are for a simplier TX queue management.
+/* following are for a simpler TX queue management.
  * Instead of using netif_[stop/wake]_queue the driver
  * will use these two functions (plus a reset one), that
  * will internally use the kernel netif_* and takes

commit cd01712397ad428f443c05add5d7435e899c0ef1
Author: Justin P. Mattock <justinmattock@gmail.com>
Date:   Mon Apr 23 07:36:52 2012 -0700

    staging: rtl8192e: Fix typos.
    
    Signed-off-by: Justin P. Mattock <justinmattock@gmail.com>
    ACKed-by: Larry Finger <Larry.finger@lwfinger.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index ec98ed715beb..a21b4d91a596 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -31,7 +31,7 @@ short rtllib_is_shortslot(const struct rtllib_network *net)
 	return net->capability & WLAN_CAPABILITY_SHORT_SLOT_TIME;
 }
 
-/* returns the total length needed for pleacing the RATE MFIE
+/* returns the total length needed for placing the RATE MFIE
  * tag and the EXTENDED RATE MFIE tag if needed.
  * It encludes two bytes per tag for the tag itself and its len
  */
@@ -49,7 +49,7 @@ static unsigned int rtllib_MFIE_rate_len(struct rtllib_device *ieee)
 	return rate_len;
 }
 
-/* pleace the MFIE rate, tag to the memory (double) poined.
+/* place the MFIE rate, tag to the memory (double) pointed.
  * Then it updates the pointer so that
  * it points after the new MFIE tag added.
  */
@@ -557,7 +557,7 @@ void rtllib_softmac_scan_syncro(struct rtllib_device *ieee, u8 is_mesh)
 		 *    new network events, despite for updating the net list,
 		 *    but we are temporarly 'unlinked' as the driver shall
 		 *    not filter RX frames and the channel is changing.
-		 * So the only situation in witch are interested is to check
+		 * So the only situation in which are interested is to check
 		 * if the state become LINKED because of the #1 situation
 		 */
 
@@ -1681,7 +1681,7 @@ inline void rtllib_softmac_new_net(struct rtllib_device *ieee,
 
 		/* if the user set the AP check if match.
 		 * if the network does not broadcast essid we check the
-		 *	 user supplyed ANY essid
+		 *	 user supplied ANY essid
 		 * if the network does broadcast and the user does not set
 		 *	 essid it is OK
 		 * if the network does broadcast and the user did set essid
@@ -2444,16 +2444,16 @@ inline int rtllib_rx_frame_softmac(struct rtllib_device *ieee,
 
 /* following are for a simplier TX queue management.
  * Instead of using netif_[stop/wake]_queue the driver
- * will uses these two function (plus a reset one), that
- * will internally uses the kernel netif_* and takes
+ * will use these two functions (plus a reset one), that
+ * will internally use the kernel netif_* and takes
  * care of the ieee802.11 fragmentation.
  * So the driver receives a fragment per time and might
- * call the stop function when it want without take care
- * to have enought room to TX an entire packet.
- * This might be useful if each fragment need it's own
+ * call the stop function when it wants to not
+ * have enough room to TX an entire packet.
+ * This might be useful if each fragment needs it's own
  * descriptor, thus just keep a total free memory > than
- * the max fragmentation treshold is not enought.. If the
- * ieee802.11 stack passed a TXB struct then you needed
+ * the max fragmentation threshold is not enough.. If the
+ * ieee802.11 stack passed a TXB struct then you need
  * to keep N free descriptors where
  * N = MAX_PACKET_SIZE / MIN_FRAG_TRESHOLD
  * In this way you need just one and the 802.11 stack
@@ -2696,15 +2696,15 @@ static void rtllib_start_ibss_wq(void *data)
 	rtllib_softmac_check_all_nets(ieee);
 
 
-	/* if not then the state is not linked. Maybe the user swithced to
+	/* if not then the state is not linked. Maybe the user switched to
 	 * ad-hoc mode just after being in monitor mode, or just after
 	 * being very few time in managed mode (so the card have had no
 	 * time to scan all the chans..) or we have just run up the iface
 	 * after setting ad-hoc mode. So we have to give another try..
 	 * Here, in ibss mode, should be safe to do this without extra care
-	 * (in bss mode we had to make sure no-one tryed to associate when
+	 * (in bss mode we had to make sure no-one tried to associate when
 	 * we had just checked the ieee->state and we was going to start the
-	 * scan) beacause in ibss mode the rtllib_new_net function, when
+	 * scan) because in ibss mode the rtllib_new_net function, when
 	 * finds a good net, just set the ieee->state to RTLLIB_LINKED,
 	 * so, at worst, we waste a bit of time to initiate an unneeded syncro
 	 * scan, that will stop at the first round because it sees the state
@@ -2819,7 +2819,7 @@ void rtllib_start_bss(struct rtllib_device *ieee)
 
 	/* ensure no-one start an associating process (thus setting
 	 * the ieee->state to rtllib_ASSOCIATING) while we
-	 * have just cheked it and we are going to enable scan.
+	 * have just checked it and we are going to enable scan.
 	 * The rtllib_new_net function is always called with
 	 * lock held (from both rtllib_softmac_check_all_nets and
 	 * the rx path), so we cannot be in the middle of such function
@@ -2872,7 +2872,7 @@ static void rtllib_associate_retry_wq(void *data)
 
 	/* until we do not set the state to RTLLIB_NOLINK
 	* there are no possibility to have someone else trying
-	* to start an association procdure (we get here with
+	* to start an association procedure (we get here with
 	* ieee->state = RTLLIB_ASSOCIATING).
 	* When we set the state to RTLLIB_NOLINK it is possible
 	* that the RX path run an attempt to associate, but

commit ea9f10f2fd207bb70a730ee3b356f75bc00ff41d
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Fri Apr 20 14:45:37 2012 -0500

    staging: r8192e_pci: Change memcpy to memcmp
    
    Routine rtllib_MlmeDisassociateRequest() has a comparison of memcpy()
    with NULL, which makes no sense. Analysis of the code suggests that
    memcmp() was intended.
    
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index c5a15dba1bf5..ec98ed715beb 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -3679,8 +3679,7 @@ void rtllib_MlmeDisassociateRequest(struct rtllib_device *rtllib, u8 *asSta,
 
 	RemovePeerTS(rtllib, asSta);
 
-
-	if (memcpy(rtllib->current_network.bssid, asSta, 6) == NULL) {
+	if (memcmp(rtllib->current_network.bssid, asSta, 6) == 0) {
 		rtllib->state = RTLLIB_NOLINK;
 
 		for (i = 0; i < 6; i++)

commit 337503431ac94ab2651af63f40623aa7eccf263b
Author: Jesper Juhl <jj@chaosbits.net>
Date:   Mon Feb 13 00:15:02 2012 +0100

    Staging, rtl8192e, softmac: remove redundant memset and fix mem leak
    
    In drivers/staging/rtl8192e/rtllib_softmac.c::rtllib_rx_assoc_resp()
    we allocate memory for 'network' with kzalloc() and then proceed to
    zero the already zeroed mem we got from kzalloc() with
    memset(). That's redundant, so remove the memset()
    
    We also fail to kfree() the memory we allocated for 'network' if we do not enter
    
      if (ieee->current_network.qos_data.supported == 1) {
    
    and the variable then goes out of scope.
    
    To fix that I simply moved the kfree() that was inside that 'if'
    statement to instead be just after it. It then covers both the case
    where we take the branch and when we don't.
    
    Signed-off-by: Jesper Juhl <jj@chaosbits.net>
    Acked-by: Larry Finger <Larry.Finger@lwfinger.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 1637f1110991..c5a15dba1bf5 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -2234,7 +2234,6 @@ inline int rtllib_rx_assoc_resp(struct rtllib_device *ieee, struct sk_buff *skb,
 
 			if (!network)
 				return 1;
-			memset(network, 0, sizeof(*network));
 			ieee->state = RTLLIB_LINKED;
 			ieee->assoc_id = aid;
 			ieee->softmac_stats.rx_ass_ok++;
@@ -2259,8 +2258,8 @@ inline int rtllib_rx_assoc_resp(struct rtllib_device *ieee, struct sk_buff *skb,
 					ieee->handle_assoc_response(ieee->dev,
 						 (struct rtllib_assoc_response_frame *)header,
 						 network);
-				kfree(network);
 			}
+			kfree(network);
 
 			kfree(ieee->assocresp_ies);
 			ieee->assocresp_ies = NULL;

commit 3b148be0df8e45a0259d7e84001cf02e897af614
Author: Sean MacLennan <seanm@seanm.ca>
Date:   Mon Dec 19 23:23:08 2011 -0500

    staging/rtl8192e: Register against lib80211
    
    Convert rtllib from registering the crypt drivers against rtllib_crypt
    and instead register the against lib80211. The crypto functions have
    R- prepended (R-CCMP, R-TKIP, R-WEP) so they will not clash with the
    lib80211 versions.
    
    We cannot use the lib80211 crypt drivers since the rtl8192e has some
    hardware support that is not handled by the lib80211 crypt drivers.
    
    Signed-off-by: Sean MacLennan <seanm@seanm.ca>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 80d147693490..1637f1110991 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -873,7 +873,7 @@ static struct sk_buff *rtllib_probe_resp(struct rtllib_device *ieee, u8 *dest)
 
 	crypt = ieee->crypt_info.crypt[ieee->crypt_info.tx_keyidx];
 	encrypt = ieee->host_encrypt && crypt && crypt->ops &&
-		((0 == strcmp(crypt->ops->name, "WEP") || wpa_ie_len));
+		((0 == strcmp(crypt->ops->name, "R-WEP") || wpa_ie_len));
 	if (ieee->pHTInfo->bCurrentHTSupport) {
 		tmp_ht_cap_buf = (u8 *) &(ieee->pHTInfo->SelfHTCap);
 		tmp_ht_cap_len = sizeof(ieee->pHTInfo->SelfHTCap);
@@ -1194,7 +1194,7 @@ inline struct sk_buff *rtllib_association_req(struct rtllib_network *beacon,
 	crypt = ieee->crypt_info.crypt[ieee->crypt_info.tx_keyidx];
 	if (crypt != NULL)
 		encrypt = ieee->host_encrypt && crypt && crypt->ops &&
-			  ((0 == strcmp(crypt->ops->name, "WEP") ||
+			  ((0 == strcmp(crypt->ops->name, "R-WEP") ||
 			  wpa_ie_len));
 	else
 		encrypt = 0;
@@ -3377,7 +3377,7 @@ static int rtllib_wpa_set_encryption(struct rtllib_device *ieee,
 			sec.enabled = 0;
 			sec.level = SEC_LEVEL_0;
 			sec.flags |= SEC_ENABLED | SEC_LEVEL;
-			rtllib_crypt_delayed_deinit(&ieee->crypt_info, crypt);
+			lib80211_crypt_delayed_deinit(&ieee->crypt_info, crypt);
 		}
 		goto done;
 	}
@@ -3386,19 +3386,19 @@ static int rtllib_wpa_set_encryption(struct rtllib_device *ieee,
 
 	/* IPW HW cannot build TKIP MIC, host decryption still needed. */
 	if (!(ieee->host_encrypt || ieee->host_decrypt) &&
-	    strcmp(param->u.crypt.alg, "TKIP"))
+	    strcmp(param->u.crypt.alg, "R-TKIP"))
 		goto skip_host_crypt;
 
-	ops = rtllib_get_crypto_ops(param->u.crypt.alg);
-	if (ops == NULL && strcmp(param->u.crypt.alg, "WEP") == 0) {
+	ops = lib80211_get_crypto_ops(param->u.crypt.alg);
+	if (ops == NULL && strcmp(param->u.crypt.alg, "R-WEP") == 0) {
 		request_module("rtllib_crypt_wep");
-		ops = rtllib_get_crypto_ops(param->u.crypt.alg);
-	} else if (ops == NULL && strcmp(param->u.crypt.alg, "TKIP") == 0) {
+		ops = lib80211_get_crypto_ops(param->u.crypt.alg);
+	} else if (ops == NULL && strcmp(param->u.crypt.alg, "R-TKIP") == 0) {
 		request_module("rtllib_crypt_tkip");
-		ops = rtllib_get_crypto_ops(param->u.crypt.alg);
-	} else if (ops == NULL && strcmp(param->u.crypt.alg, "CCMP") == 0) {
+		ops = lib80211_get_crypto_ops(param->u.crypt.alg);
+	} else if (ops == NULL && strcmp(param->u.crypt.alg, "R-CCMP") == 0) {
 		request_module("rtllib_crypt_ccmp");
-		ops = rtllib_get_crypto_ops(param->u.crypt.alg);
+		ops = lib80211_get_crypto_ops(param->u.crypt.alg);
 	}
 	if (ops == NULL) {
 		printk(KERN_INFO "unknown crypto alg '%s'\n",
@@ -3410,7 +3410,7 @@ static int rtllib_wpa_set_encryption(struct rtllib_device *ieee,
 	if (*crypt == NULL || (*crypt)->ops != ops) {
 		struct lib80211_crypt_data *new_crypt;
 
-		rtllib_crypt_delayed_deinit(&ieee->crypt_info, crypt);
+		lib80211_crypt_delayed_deinit(&ieee->crypt_info, crypt);
 
 		new_crypt = (struct lib80211_crypt_data *)
 			kmalloc(sizeof(*new_crypt), GFP_KERNEL);
@@ -3459,13 +3459,13 @@ static int rtllib_wpa_set_encryption(struct rtllib_device *ieee,
 		sec.key_sizes[param->u.crypt.idx] = param->u.crypt.key_len;
 		sec.flags |= (1 << param->u.crypt.idx);
 
-		if (strcmp(param->u.crypt.alg, "WEP") == 0) {
+		if (strcmp(param->u.crypt.alg, "R-WEP") == 0) {
 			sec.flags |= SEC_LEVEL;
 			sec.level = SEC_LEVEL_1;
-		} else if (strcmp(param->u.crypt.alg, "TKIP") == 0) {
+		} else if (strcmp(param->u.crypt.alg, "R-TKIP") == 0) {
 			sec.flags |= SEC_LEVEL;
 			sec.level = SEC_LEVEL_2;
-		} else if (strcmp(param->u.crypt.alg, "CCMP") == 0) {
+		} else if (strcmp(param->u.crypt.alg, "R-CCMP") == 0) {
 			sec.flags |= SEC_LEVEL;
 			sec.level = SEC_LEVEL_3;
 		}
@@ -3568,7 +3568,7 @@ u8 rtllib_ap_sec_type(struct rtllib_device *ieee)
 	crypt = ieee->crypt_info.crypt[ieee->crypt_info.tx_keyidx];
 	encrypt = (ieee->current_network.capability & WLAN_CAPABILITY_PRIVACY)
 		  || (ieee->host_encrypt && crypt && crypt->ops &&
-		  (0 == strcmp(crypt->ops->name, "WEP")));
+		  (0 == strcmp(crypt->ops->name, "R-WEP")));
 
 	/* simply judge  */
 	if (encrypt && (wpa_ie_len == 0)) {

commit 0ddcf5fdfac6bd80e153ee5c405bdfc9cb868b95
Author: Sean MacLennan <seanm@seanm.ca>
Date:   Mon Dec 19 23:21:41 2011 -0500

    staging/rtl8192e: Convert to lib80211_crypt_info
    
    Convert rtllib to use lib80211_crypt_info.
    
    Signed-off-by: Sean MacLennan <seanm@seanm.ca>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 47c163b9e35d..80d147693490 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -871,7 +871,7 @@ static struct sk_buff *rtllib_probe_resp(struct rtllib_device *ieee, u8 *dest)
 	} else
 		erp_len = 0;
 
-	crypt = ieee->crypt[ieee->tx_keyidx];
+	crypt = ieee->crypt_info.crypt[ieee->crypt_info.tx_keyidx];
 	encrypt = ieee->host_encrypt && crypt && crypt->ops &&
 		((0 == strcmp(crypt->ops->name, "WEP") || wpa_ie_len));
 	if (ieee->pHTInfo->bCurrentHTSupport) {
@@ -923,7 +923,7 @@ static struct sk_buff *rtllib_probe_resp(struct rtllib_device *ieee, u8 *dest)
 		cpu_to_le16((beacon_buf->capability |=
 				 WLAN_CAPABILITY_SHORT_SLOT_TIME));
 
-	crypt = ieee->crypt[ieee->tx_keyidx];
+	crypt = ieee->crypt_info.crypt[ieee->crypt_info.tx_keyidx];
 	if (encrypt)
 		beacon_buf->capability |= cpu_to_le16(WLAN_CAPABILITY_PRIVACY);
 
@@ -1013,7 +1013,7 @@ static struct sk_buff *rtllib_assoc_resp(struct rtllib_device *ieee, u8 *dest)
 				 cpu_to_le16(WLAN_CAPABILITY_SHORT_SLOT_TIME);
 
 	if (ieee->host_encrypt)
-		crypt = ieee->crypt[ieee->tx_keyidx];
+		crypt = ieee->crypt_info.crypt[ieee->crypt_info.tx_keyidx];
 	else
 		crypt = NULL;
 
@@ -1191,7 +1191,7 @@ inline struct sk_buff *rtllib_association_req(struct rtllib_network *beacon,
 	unsigned int turbo_info_len = beacon->Turbo_Enable ? 9 : 0;
 
 	int len = 0;
-	crypt = ieee->crypt[ieee->tx_keyidx];
+	crypt = ieee->crypt_info.crypt[ieee->crypt_info.tx_keyidx];
 	if (crypt != NULL)
 		encrypt = ieee->host_encrypt && crypt && crypt->ops &&
 			  ((0 == strcmp(crypt->ops->name, "WEP") ||
@@ -3367,7 +3367,7 @@ static int rtllib_wpa_set_encryption(struct rtllib_device *ieee,
 	    param->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff) {
 		if (param->u.crypt.idx >= NUM_WEP_KEYS)
 			return -EINVAL;
-		crypt = &ieee->crypt[param->u.crypt.idx];
+		crypt = &ieee->crypt_info.crypt[param->u.crypt.idx];
 	} else {
 		return -EINVAL;
 	}
@@ -3377,7 +3377,7 @@ static int rtllib_wpa_set_encryption(struct rtllib_device *ieee,
 			sec.enabled = 0;
 			sec.level = SEC_LEVEL_0;
 			sec.flags |= SEC_ENABLED | SEC_LEVEL;
-			rtllib_crypt_delayed_deinit(ieee, crypt);
+			rtllib_crypt_delayed_deinit(&ieee->crypt_info, crypt);
 		}
 		goto done;
 	}
@@ -3410,7 +3410,7 @@ static int rtllib_wpa_set_encryption(struct rtllib_device *ieee,
 	if (*crypt == NULL || (*crypt)->ops != ops) {
 		struct lib80211_crypt_data *new_crypt;
 
-		rtllib_crypt_delayed_deinit(ieee, crypt);
+		rtllib_crypt_delayed_deinit(&ieee->crypt_info, crypt);
 
 		new_crypt = (struct lib80211_crypt_data *)
 			kmalloc(sizeof(*new_crypt), GFP_KERNEL);
@@ -3446,7 +3446,7 @@ static int rtllib_wpa_set_encryption(struct rtllib_device *ieee,
 
  skip_host_crypt:
 	if (param->u.crypt.set_tx) {
-		ieee->tx_keyidx = param->u.crypt.idx;
+		ieee->crypt_info.tx_keyidx = param->u.crypt.idx;
 		sec.active_key = param->u.crypt.idx;
 		sec.flags |= SEC_ACTIVE_KEY;
 	} else
@@ -3565,7 +3565,7 @@ u8 rtllib_ap_sec_type(struct rtllib_device *ieee)
 	struct lib80211_crypt_data *crypt;
 	int encrypt;
 
-	crypt = ieee->crypt[ieee->tx_keyidx];
+	crypt = ieee->crypt_info.crypt[ieee->crypt_info.tx_keyidx];
 	encrypt = (ieee->current_network.capability & WLAN_CAPABILITY_PRIVACY)
 		  || (ieee->host_encrypt && crypt && crypt->ops &&
 		  (0 == strcmp(crypt->ops->name, "WEP")));

commit 32c44cb5b9fdc6eaa445bd622008dd672a3dd1a7
Author: Sean MacLennan <seanm@seanm.ca>
Date:   Mon Dec 19 23:20:41 2011 -0500

    staging/rtl8192e: Convert to lib80211_crypt_data and lib80211_crypt_ops
    
    Convert rtllib_crypt_data to lib80211_crypt_data and
    rtllib_crypt_ops to lib80211_crypt_ops.
    
    This is almost a 1:1 replacement, only extra_prefix_len and
    extra_postfix_len changed.
    
    Signed-off-by: Sean MacLennan <seanm@seanm.ca>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 022bf40122e3..47c163b9e35d 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -836,7 +836,7 @@ static struct sk_buff *rtllib_probe_resp(struct rtllib_device *ieee, u8 *dest)
 	struct sk_buff *skb = NULL;
 	int encrypt;
 	int atim_len, erp_len;
-	struct rtllib_crypt_data *crypt;
+	struct lib80211_crypt_data *crypt;
 
 	char *ssid = ieee->current_network.ssid;
 	int ssid_len = ieee->current_network.ssid_len;
@@ -982,7 +982,7 @@ static struct sk_buff *rtllib_assoc_resp(struct rtllib_device *ieee, u8 *dest)
 	struct sk_buff *skb;
 	u8 *tag;
 
-	struct rtllib_crypt_data *crypt;
+	struct lib80211_crypt_data *crypt;
 	struct rtllib_assoc_response_frame *assoc;
 	short encrypt;
 
@@ -1178,7 +1178,7 @@ inline struct sk_buff *rtllib_association_req(struct rtllib_network *beacon,
 	unsigned int ckip_ie_len = 0;
 	unsigned int ccxrm_ie_len = 0;
 	unsigned int cxvernum_ie_len = 0;
-	struct rtllib_crypt_data *crypt;
+	struct lib80211_crypt_data *crypt;
 	int encrypt;
 	int	PMKCacheIdx;
 
@@ -3345,8 +3345,8 @@ static int rtllib_wpa_set_encryption(struct rtllib_device *ieee,
 				  u8 is_mesh)
 {
 	int ret = 0;
-	struct rtllib_crypto_ops *ops;
-	struct rtllib_crypt_data **crypt;
+	struct lib80211_crypto_ops *ops;
+	struct lib80211_crypt_data **crypt;
 
 	struct rtllib_security sec = {
 		.flags = 0,
@@ -3408,17 +3408,17 @@ static int rtllib_wpa_set_encryption(struct rtllib_device *ieee,
 		goto done;
 	}
 	if (*crypt == NULL || (*crypt)->ops != ops) {
-		struct rtllib_crypt_data *new_crypt;
+		struct lib80211_crypt_data *new_crypt;
 
 		rtllib_crypt_delayed_deinit(ieee, crypt);
 
-		new_crypt = (struct rtllib_crypt_data *)
+		new_crypt = (struct lib80211_crypt_data *)
 			kmalloc(sizeof(*new_crypt), GFP_KERNEL);
 		if (new_crypt == NULL) {
 			ret = -ENOMEM;
 			goto done;
 		}
-		memset(new_crypt, 0, sizeof(struct rtllib_crypt_data));
+		memset(new_crypt, 0, sizeof(struct lib80211_crypt_data));
 		new_crypt->ops = ops;
 		if (new_crypt->ops)
 			new_crypt->priv =
@@ -3562,7 +3562,7 @@ u8 rtllib_ap_sec_type(struct rtllib_device *ieee)
 	static u8 ccmp_ie[4] = {0x00, 0x50, 0xf2, 0x04};
 	static u8 ccmp_rsn_ie[4] = {0x00, 0x0f, 0xac, 0x04};
 	int wpa_ie_len = ieee->wpa_ie_len;
-	struct rtllib_crypt_data *crypt;
+	struct lib80211_crypt_data *crypt;
 	int encrypt;
 
 	crypt = ieee->crypt[ieee->tx_keyidx];

commit 184f1938b29310a0df4298b57a7241832cb0813c
Author: Sean MacLennan <seanm@seanm.ca>
Date:   Mon Dec 19 23:19:23 2011 -0500

    staging/rtl8192e: Add lib80211.h to rtllib.h
    
    Add lib80211.h header file to rtllib.h and get it compiling.
    
    Signed-off-by: Sean MacLennan <seanm@seanm.ca>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 44b466b60952..022bf40122e3 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -3365,7 +3365,7 @@ static int rtllib_wpa_set_encryption(struct rtllib_device *ieee,
 	if (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&
 	    param->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&
 	    param->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff) {
-		if (param->u.crypt.idx >= WEP_KEYS)
+		if (param->u.crypt.idx >= NUM_WEP_KEYS)
 			return -EINVAL;
 		crypt = &ieee->crypt[param->u.crypt.idx];
 	} else {

commit e0ec8a67089762b29071e879388986ab7370d330
Author: Devendra Naga <devendra.aaru@gmail.com>
Date:   Tue Dec 13 01:49:29 2011 -0500

    staging: remove version.h includes in rtl8192e
    
    Signed-off-by: Devendra Naga <devendra.aaru@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 8565365ad4cd..44b466b60952 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -18,7 +18,6 @@
 
 #include <linux/random.h>
 #include <linux/delay.h>
-#include <linux/version.h>
 #include <linux/uaccess.h>
 #include "dot11d.h"
 

commit 3b28499c5519e59fbe9c2dea49ece5a3665be787
Author: Sean MacLennan <seanm@seanm.ca>
Date:   Mon Nov 28 20:20:26 2011 -0500

    rtl8192e: Export symbols
    
    The rtl8192e driver had a natural split between the more generic
    rtllib code and the more specific rtl8192e code. This patch exports
    all the symbols needed by the r8192 specific code from the rtllib
    generic code.
    
    Signed-off-by: Sean MacLennan <seanm@seanm.ca>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 4ed65dc8933c..8565365ad4cd 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -467,6 +467,7 @@ void rtllib_EnableIntelPromiscuousMode(struct net_device *dev,
 
 	ieee->bNetPromiscuousMode = true;
 }
+EXPORT_SYMBOL(rtllib_EnableIntelPromiscuousMode);
 
 
 /*
@@ -489,6 +490,7 @@ void rtllib_DisableIntelPromiscuousMode(struct net_device *dev,
 
 	ieee->bNetPromiscuousMode = false;
 }
+EXPORT_SYMBOL(rtllib_DisableIntelPromiscuousMode);
 
 static void rtllib_send_probe(struct rtllib_device *ieee, u8 is_mesh)
 {
@@ -684,6 +686,7 @@ void rtllib_stop_send_beacons(struct rtllib_device *ieee)
 	if (ieee->softmac_features & IEEE_SOFTMAC_BEACONS)
 		rtllib_beacons_stop(ieee);
 }
+EXPORT_SYMBOL(rtllib_stop_send_beacons);
 
 
 void rtllib_start_send_beacons(struct rtllib_device *ieee)
@@ -693,6 +696,7 @@ void rtllib_start_send_beacons(struct rtllib_device *ieee)
 	if (ieee->softmac_features & IEEE_SOFTMAC_BEACONS)
 		rtllib_beacons_start(ieee);
 }
+EXPORT_SYMBOL(rtllib_start_send_beacons);
 
 
 static void rtllib_softmac_stop_scan(struct rtllib_device *ieee)
@@ -718,6 +722,7 @@ void rtllib_stop_scan(struct rtllib_device *ieee)
 			ieee->rtllib_stop_hw_scan(ieee->dev);
 	}
 }
+EXPORT_SYMBOL(rtllib_stop_scan);
 
 void rtllib_stop_scan_syncro(struct rtllib_device *ieee)
 {
@@ -728,6 +733,7 @@ void rtllib_stop_scan_syncro(struct rtllib_device *ieee)
 			ieee->rtllib_stop_hw_scan(ieee->dev);
 	}
 }
+EXPORT_SYMBOL(rtllib_stop_scan_syncro);
 
 bool rtllib_act_scanning(struct rtllib_device *ieee, bool sync_scan)
 {
@@ -740,6 +746,7 @@ bool rtllib_act_scanning(struct rtllib_device *ieee, bool sync_scan)
 		return test_bit(STATUS_SCANNING, &ieee->status);
 	}
 }
+EXPORT_SYMBOL(rtllib_act_scanning);
 
 /* called with ieee->lock held */
 static void rtllib_start_scan(struct rtllib_device *ieee)
@@ -780,6 +787,7 @@ void rtllib_start_scan_syncro(struct rtllib_device *ieee, u8 is_mesh)
 			ieee->rtllib_start_hw_scan(ieee->dev);
 	}
 }
+EXPORT_SYMBOL(rtllib_start_scan_syncro);
 
 inline struct sk_buff *rtllib_authentication_req(struct rtllib_network *beacon,
 	struct rtllib_device *ieee, int challengelen, u8 *daddr)
@@ -1955,6 +1963,7 @@ void rtllib_sta_ps_send_null_frame(struct rtllib_device *ieee, short pwr)
 	if (buf)
 		softmac_ps_mgmt_xmit(buf, ieee);
 }
+EXPORT_SYMBOL(rtllib_sta_ps_send_null_frame);
 
 void rtllib_sta_ps_send_pspoll_frame(struct rtllib_device *ieee)
 {
@@ -2167,6 +2176,7 @@ void rtllib_ps_tx_ack(struct rtllib_device *ieee, short success)
 	}
 	spin_unlock_irqrestore(&ieee->lock, flags);
 }
+EXPORT_SYMBOL(rtllib_ps_tx_ack);
 
 static void rtllib_process_action(struct rtllib_device *ieee, struct sk_buff *skb)
 {
@@ -2539,6 +2549,7 @@ void rtllib_reset_queue(struct rtllib_device *ieee)
 	spin_unlock_irqrestore(&ieee->lock, flags);
 
 }
+EXPORT_SYMBOL(rtllib_reset_queue);
 
 void rtllib_wake_queue(struct rtllib_device *ieee)
 {
@@ -2927,6 +2938,7 @@ struct sk_buff *rtllib_get_beacon(struct rtllib_device *ieee)
 
 	return skb;
 }
+EXPORT_SYMBOL(rtllib_get_beacon);
 
 void rtllib_softmac_stop_protocol(struct rtllib_device *ieee, u8 mesh_flag,
 				  u8 shutdown)
@@ -2936,6 +2948,7 @@ void rtllib_softmac_stop_protocol(struct rtllib_device *ieee, u8 mesh_flag,
 	rtllib_stop_protocol(ieee, shutdown);
 	up(&ieee->wx_sem);
 }
+EXPORT_SYMBOL(rtllib_softmac_stop_protocol);
 
 
 void rtllib_stop_protocol(struct rtllib_device *ieee, u8 shutdown)
@@ -2984,6 +2997,7 @@ void rtllib_softmac_start_protocol(struct rtllib_device *ieee, u8 mesh_flag)
 	rtllib_start_protocol(ieee);
 	up(&ieee->wx_sem);
 }
+EXPORT_SYMBOL(rtllib_softmac_start_protocol);
 
 void rtllib_start_protocol(struct rtllib_device *ieee)
 {
@@ -3632,6 +3646,7 @@ int rtllib_wpa_supplicant_ioctl(struct rtllib_device *ieee, struct iw_point *p,
 
 	return ret;
 }
+EXPORT_SYMBOL(rtllib_wpa_supplicant_ioctl);
 
 void rtllib_MgntDisconnectIBSS(struct rtllib_device *rtllib)
 {
@@ -3717,6 +3732,7 @@ bool rtllib_MgntDisconnect(struct rtllib_device *rtllib, u8 asRsn)
 
 	return true;
 }
+EXPORT_SYMBOL(rtllib_MgntDisconnect);
 
 void notify_wx_assoc_event(struct rtllib_device *ieee)
 {
@@ -3737,3 +3753,4 @@ void notify_wx_assoc_event(struct rtllib_device *ieee)
 	}
 	wireless_send_event(ieee->dev, SIOCGIWAP, &wrqu, NULL);
 }
+EXPORT_SYMBOL(notify_wx_assoc_event);

commit ea74fedced8235fb01fc317bcb8cd98d8aa71436
Author: Sean MacLennan <seanm@seanm.ca>
Date:   Mon Nov 28 20:19:33 2011 -0500

    rtl8192e: create generic rtllib_debug.h
    
    Rename rtl_debug.h to rtllib_debug.h. Source files should include
    rtllib.h if they are generic and rtl_core.h if they are r8192e
    specific. Files should never include both.
    
    Signed-off-by: Sean MacLennan <seanm@seanm.ca>
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index a326880888f7..4ed65dc8933c 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -15,7 +15,6 @@
 
 
 #include "rtllib.h"
-#include "rtl_core.h"
 
 #include <linux/random.h>
 #include <linux/delay.h>

commit d9317533c54836887d64bba973ae5c9c341b36a0
Author: Thomas Meyer <thomas@m3y3r.de>
Date:   Tue Nov 8 20:37:03 2011 +0100

    staging: rtl8192e: Use kmemdup rather than duplicating its implementation
    
     Use kmemdup rather than duplicating its implementation
    
     The semantic patch that makes this change is available
     in scripts/coccinelle/api/memdup.cocci.
    
     More information about semantic patching is available at
     http://coccinelle.lip6.fr/
    
    Signed-off-by: Thomas Meyer <thomas@m3y3r.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 30c3bca1c368..a326880888f7 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -3206,11 +3206,11 @@ static int rtllib_wpa_set_wpa_ie(struct rtllib_device *ieee,
 		return -EINVAL;
 
 	if (param->u.wpa_ie.len) {
-		buf = kmalloc(param->u.wpa_ie.len, GFP_KERNEL);
+		buf = kmemdup(param->u.wpa_ie.data, param->u.wpa_ie.len,
+			      GFP_KERNEL);
 		if (buf == NULL)
 			return -ENOMEM;
 
-		memcpy(buf, param->u.wpa_ie.data, param->u.wpa_ie.len);
 		kfree(ieee->wpa_ie);
 		ieee->wpa_ie = buf;
 		ieee->wpa_ie_len = param->u.wpa_ie.len;

commit 929fa2a42e75e0c6ded89c450bd0f668e32190d7
Author: Thomas Meyer <thomas@m3y3r.de>
Date:   Thu Nov 10 19:04:19 2011 +0100

    staging: rtl8192e: Use kzalloc rather than kmalloc v2
    
    Use kzalloc rather than kmalloc followed by memset with 0
    
    This considers some simple cases that are common and easy to validate
    Note in particular that there are no ...s in the rule, so all of the
    matched code has to be contiguous
    
    The semantic patch that makes this change is available
    in scripts/coccinelle/api/alloc/kzalloc-simple.cocci.
    
    Signed-off-by: Thomas Meyer <thomas@m3y3r.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index fa774cf7fc78..30c3bca1c368 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -3048,10 +3048,9 @@ void rtllib_softmac_init(struct rtllib_device *ieee)
 	ieee->state = RTLLIB_NOLINK;
 	for (i = 0; i < 5; i++)
 		ieee->seq_ctrl[i] = 0;
-	ieee->pDot11dInfo = kmalloc(sizeof(struct rt_dot11d_info), GFP_ATOMIC);
+	ieee->pDot11dInfo = kzalloc(sizeof(struct rt_dot11d_info), GFP_ATOMIC);
 	if (!ieee->pDot11dInfo)
 		RTLLIB_DEBUG(RTLLIB_DL_ERR, "can't alloc memory for DOT11D\n");
-	memset(ieee->pDot11dInfo, 0, sizeof(struct rt_dot11d_info));
 	ieee->LinkDetectInfo.SlotIndex = 0;
 	ieee->LinkDetectInfo.SlotNum = 2;
 	ieee->LinkDetectInfo.NumRecvBcnInPeriod = 0;

commit 6f03053b6810c7ca315afb30b31b63d9f5863faf
Author: Jesper Juhl <jj@chaosbits.net>
Date:   Mon Nov 7 00:21:26 2011 +0100

    rtl8192e: Don't copy huge struct by value (and make it const).
    
    rtllib_is_shortslot() takes one argument - a struct that's more than a
    kilobyte large. It should take a pointer instead of copying such a
    huge struct - and the argument might as well be declared 'const' now
    that we are at it, since it is not modified. This patch makes these
    changes.
    
    Signed-off-by: Jesper Juhl <jj@chaosbits.net>
    Acked-by: Larry Finger <Larry.Finger@lwfinger.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index b5086850f0de..fa774cf7fc78 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -28,9 +28,9 @@ short rtllib_is_54g(struct rtllib_network *net)
 	return (net->rates_ex_len > 0) || (net->rates_len > 4);
 }
 
-short rtllib_is_shortslot(struct rtllib_network net)
+short rtllib_is_shortslot(const struct rtllib_network *net)
 {
-	return net.capability & WLAN_CAPABILITY_SHORT_SLOT_TIME;
+	return net->capability & WLAN_CAPABILITY_SHORT_SLOT_TIME;
 }
 
 /* returns the total length needed for pleacing the RATE MFIE

commit d7613e535e9892ff12aa31b3c62f1be839546ff9
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Thu Sep 1 12:23:21 2011 -0500

    staging: rtl8192e: Fix various problems noted by smatch
    
    Smatch reports the following problems:
    
      CHECK   drivers/staging/rtl8192e/rtllib_softmac.c
    drivers/staging/rtl8192e/rtllib_softmac.c +3143 rtllib_softmac_free(4) info: redundant null check on ieee->pDot11dInfo calling kfree()
    
      CHECK   drivers/staging/rtl8192e/rtllib_module.c
    drivers/staging/rtl8192e/rtllib_module.c +198 free_rtllib(6) info: redundant null check on ieee->pHTInfo calling kfree()
    
      CHECK   drivers/staging/rtl8192e/rtl819x_TSProc.c
    drivers/staging/rtl8192e/rtl819x_TSProc.c +280 SearchAdmitTRStream(52) error: potential null derefence 'pRet'.
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index a420ed1a9479..b5086850f0de 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -3139,10 +3139,8 @@ void rtllib_softmac_init(struct rtllib_device *ieee)
 void rtllib_softmac_free(struct rtllib_device *ieee)
 {
 	down(&ieee->wx_sem);
-	if (NULL != ieee->pDot11dInfo) {
-		kfree(ieee->pDot11dInfo);
-		ieee->pDot11dInfo = NULL;
-	}
+	kfree(ieee->pDot11dInfo);
+	ieee->pDot11dInfo = NULL;
 	del_timer_sync(&ieee->associate_timer);
 
 	cancel_delayed_work(&ieee->associate_retry_wq);

commit ec0dc6beea5436c037707dc0f501cf07878a8e2a
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Thu Aug 25 14:07:04 2011 -0500

    staging: rtl8192e: Fix sparse (non-endian) messages - Part I
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index dd4dec8c53af..a420ed1a9479 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -23,15 +23,6 @@
 #include <linux/uaccess.h>
 #include "dot11d.h"
 
-u8 rsn_authen_cipher_suite[16][4] = {
-	{0x00, 0x0F, 0xAC, 0x00},
-	{0x00, 0x0F, 0xAC, 0x01},
-	{0x00, 0x0F, 0xAC, 0x02},
-	{0x00, 0x0F, 0xAC, 0x03},
-	{0x00, 0x0F, 0xAC, 0x04},
-	{0x00, 0x0F, 0xAC, 0x05},
-};
-
 short rtllib_is_54g(struct rtllib_network *net)
 {
 	return (net->rates_ex_len > 0) || (net->rates_len > 4);
@@ -46,7 +37,7 @@ short rtllib_is_shortslot(struct rtllib_network net)
  * tag and the EXTENDED RATE MFIE tag if needed.
  * It encludes two bytes per tag for the tag itself and its len
  */
-unsigned int rtllib_MFIE_rate_len(struct rtllib_device *ieee)
+static unsigned int rtllib_MFIE_rate_len(struct rtllib_device *ieee)
 {
 	unsigned int rate_len = 0;
 
@@ -64,7 +55,7 @@ unsigned int rtllib_MFIE_rate_len(struct rtllib_device *ieee)
  * Then it updates the pointer so that
  * it points after the new MFIE tag added.
  */
-void rtllib_MFIE_Brate(struct rtllib_device *ieee, u8 **tag_p)
+static void rtllib_MFIE_Brate(struct rtllib_device *ieee, u8 **tag_p)
 {
 	u8 *tag = *tag_p;
 
@@ -82,7 +73,7 @@ void rtllib_MFIE_Brate(struct rtllib_device *ieee, u8 **tag_p)
 	*tag_p = tag;
 }
 
-void rtllib_MFIE_Grate(struct rtllib_device *ieee, u8 **tag_p)
+static void rtllib_MFIE_Grate(struct rtllib_device *ieee, u8 **tag_p)
 {
 	u8 *tag = *tag_p;
 
@@ -103,7 +94,7 @@ void rtllib_MFIE_Grate(struct rtllib_device *ieee, u8 **tag_p)
 	*tag_p = tag;
 }
 
-void rtllib_WMM_Info(struct rtllib_device *ieee, u8 **tag_p)
+static void rtllib_WMM_Info(struct rtllib_device *ieee, u8 **tag_p)
 {
 	u8 *tag = *tag_p;
 
@@ -137,7 +128,7 @@ void rtllib_TURBO_Info(struct rtllib_device *ieee, u8 **tag_p)
 	printk(KERN_ALERT "This is enable turbo mode IE process\n");
 }
 
-void enqueue_mgmt(struct rtllib_device *ieee, struct sk_buff *skb)
+static void enqueue_mgmt(struct rtllib_device *ieee, struct sk_buff *skb)
 {
 	int nh;
 	nh = (ieee->mgmt_queue_head + 1) % MGMT_QUEUE_NUM;
@@ -154,7 +145,7 @@ void enqueue_mgmt(struct rtllib_device *ieee, struct sk_buff *skb)
 
 }
 
-struct sk_buff *dequeue_mgmt(struct rtllib_device *ieee)
+static struct sk_buff *dequeue_mgmt(struct rtllib_device *ieee)
 {
 	struct sk_buff *ret;
 
@@ -169,7 +160,7 @@ struct sk_buff *dequeue_mgmt(struct rtllib_device *ieee)
 	return ret;
 }
 
-void init_mgmt_queue(struct rtllib_device *ieee)
+static void init_mgmt_queue(struct rtllib_device *ieee)
 {
 	ieee->mgmt_queue_tail = ieee->mgmt_queue_head = 0;
 }
@@ -394,7 +385,7 @@ inline struct sk_buff *rtllib_probe_req(struct rtllib_device *ieee)
 
 struct sk_buff *rtllib_get_beacon_(struct rtllib_device *ieee);
 
-void rtllib_send_beacon(struct rtllib_device *ieee)
+static void rtllib_send_beacon(struct rtllib_device *ieee)
 {
 	struct sk_buff *skb;
 	if (!ieee->ieee_up)
@@ -412,7 +403,7 @@ void rtllib_send_beacon(struct rtllib_device *ieee)
 }
 
 
-void rtllib_send_beacon_cb(unsigned long _ieee)
+static void rtllib_send_beacon_cb(unsigned long _ieee)
 {
 	struct rtllib_device *ieee =
 		(struct rtllib_device *) _ieee;
@@ -500,7 +491,7 @@ void rtllib_DisableIntelPromiscuousMode(struct net_device *dev,
 	ieee->bNetPromiscuousMode = false;
 }
 
-void rtllib_send_probe(struct rtllib_device *ieee, u8 is_mesh)
+static void rtllib_send_probe(struct rtllib_device *ieee, u8 is_mesh)
 {
 	struct sk_buff *skb;
 	skb = rtllib_probe_req(ieee);
@@ -520,7 +511,7 @@ void rtllib_send_probe_requests(struct rtllib_device *ieee, u8 is_mesh)
 	}
 }
 
-void rtllib_softmac_hint11d_wq(void *data)
+static void rtllib_softmac_hint11d_wq(void *data)
 {
 }
 
@@ -602,7 +593,7 @@ void rtllib_softmac_scan_syncro(struct rtllib_device *ieee, u8 is_mesh)
 	wireless_send_event(ieee->dev, SIOCGIWSCAN, &wrqu, NULL);
 }
 
-void rtllib_softmac_scan_wq(void *data)
+static void rtllib_softmac_scan_wq(void *data)
 {
 	struct rtllib_device *ieee = container_of_dwork_rsl(data,
 				     struct rtllib_device, softmac_scan_wq);
@@ -662,7 +653,7 @@ void rtllib_softmac_scan_wq(void *data)
 
 
 
-void rtllib_beacons_start(struct rtllib_device *ieee)
+static void rtllib_beacons_start(struct rtllib_device *ieee)
 {
 	unsigned long flags;
 	spin_lock_irqsave(&ieee->beacon_lock, flags);
@@ -673,7 +664,7 @@ void rtllib_beacons_start(struct rtllib_device *ieee)
 	spin_unlock_irqrestore(&ieee->beacon_lock, flags);
 }
 
-void rtllib_beacons_stop(struct rtllib_device *ieee)
+static void rtllib_beacons_stop(struct rtllib_device *ieee)
 {
 	unsigned long flags;
 
@@ -705,7 +696,7 @@ void rtllib_start_send_beacons(struct rtllib_device *ieee)
 }
 
 
-void rtllib_softmac_stop_scan(struct rtllib_device *ieee)
+static void rtllib_softmac_stop_scan(struct rtllib_device *ieee)
 {
 	down(&ieee->scan_sem);
 	ieee->scan_watch_dog = 0;
@@ -752,7 +743,7 @@ bool rtllib_act_scanning(struct rtllib_device *ieee, bool sync_scan)
 }
 
 /* called with ieee->lock held */
-void rtllib_start_scan(struct rtllib_device *ieee)
+static void rtllib_start_scan(struct rtllib_device *ieee)
 {
 	RT_TRACE(COMP_DBG, "===>%s()\n", __func__);
 	if (ieee->rtllib_ips_leave_wq != NULL)
@@ -831,24 +822,6 @@ inline struct sk_buff *rtllib_authentication_req(struct rtllib_network *beacon,
 	return skb;
 }
 
-void constructWMMIE(u8 *wmmie, u8 *wmm_len, u8 oui_subtype)
-{
-	u8	szQoSOUI[] = {221, 0, 0x00, 0x50, 0xf2, 0x02, 0, 1};
-
-	if (oui_subtype == OUI_SUBTYPE_QOS_CAPABI) {
-		szQoSOUI[0] = 46;
-		szQoSOUI[1] = *wmm_len;
-		memcpy(wmmie, szQoSOUI, 3);
-		*wmm_len = 3;
-	} else {
-		szQoSOUI[1] = *wmm_len + 6;
-		szQoSOUI[6] = oui_subtype;
-		memcpy(wmmie, szQoSOUI, 8);
-		*(wmmie+8) = 0;
-		*wmm_len = 9;
-	}
-}
-
 static struct sk_buff *rtllib_probe_resp(struct rtllib_device *ieee, u8 *dest)
 {
 	u8 *tag;
@@ -998,7 +971,7 @@ static struct sk_buff *rtllib_probe_resp(struct rtllib_device *ieee, u8 *dest)
 	return skb;
 }
 
-struct sk_buff *rtllib_assoc_resp(struct rtllib_device *ieee, u8 *dest)
+static struct sk_buff *rtllib_assoc_resp(struct rtllib_device *ieee, u8 *dest)
 {
 	struct sk_buff *skb;
 	u8 *tag;
@@ -1057,7 +1030,7 @@ struct sk_buff *rtllib_assoc_resp(struct rtllib_device *ieee, u8 *dest)
 	return skb;
 }
 
-struct sk_buff *rtllib_auth_resp(struct rtllib_device *ieee, int status,
+static struct sk_buff *rtllib_auth_resp(struct rtllib_device *ieee, int status,
 				 u8 *dest)
 {
 	struct sk_buff *skb = NULL;
@@ -1087,7 +1060,7 @@ struct sk_buff *rtllib_auth_resp(struct rtllib_device *ieee, int status,
 
 }
 
-struct sk_buff *rtllib_null_func(struct rtllib_device *ieee, short pwr)
+static struct sk_buff *rtllib_null_func(struct rtllib_device *ieee, short pwr)
 {
 	struct sk_buff *skb;
 	struct rtllib_hdr_3addr *hdr;
@@ -1114,7 +1087,7 @@ struct sk_buff *rtllib_null_func(struct rtllib_device *ieee, short pwr)
 
 }
 
-struct sk_buff *rtllib_pspoll_func(struct rtllib_device *ieee)
+static struct sk_buff *rtllib_pspoll_func(struct rtllib_device *ieee)
 {
 	struct sk_buff *skb;
 	struct rtllib_pspoll_hdr *hdr;
@@ -1139,7 +1112,7 @@ struct sk_buff *rtllib_pspoll_func(struct rtllib_device *ieee)
 
 }
 
-void rtllib_resp_to_assoc_rq(struct rtllib_device *ieee, u8 *dest)
+static void rtllib_resp_to_assoc_rq(struct rtllib_device *ieee, u8 *dest)
 {
 	struct sk_buff *buf = rtllib_assoc_resp(ieee, dest);
 
@@ -1148,7 +1121,7 @@ void rtllib_resp_to_assoc_rq(struct rtllib_device *ieee, u8 *dest)
 }
 
 
-void rtllib_resp_to_auth(struct rtllib_device *ieee, int s, u8 *dest)
+static void rtllib_resp_to_auth(struct rtllib_device *ieee, int s, u8 *dest)
 {
 	struct sk_buff *buf = rtllib_auth_resp(ieee, s, dest);
 
@@ -1157,7 +1130,7 @@ void rtllib_resp_to_auth(struct rtllib_device *ieee, int s, u8 *dest)
 }
 
 
-void rtllib_resp_to_probe(struct rtllib_device *ieee, u8 *dest)
+static void rtllib_resp_to_probe(struct rtllib_device *ieee, u8 *dest)
 {
 
 	struct sk_buff *buf = rtllib_probe_resp(ieee, dest);
@@ -1466,12 +1439,12 @@ void rtllib_associate_abort(struct rtllib_device *ieee)
 	spin_unlock_irqrestore(&ieee->lock, flags);
 }
 
-void rtllib_associate_abort_cb(unsigned long dev)
+static void rtllib_associate_abort_cb(unsigned long dev)
 {
 	rtllib_associate_abort((struct rtllib_device *) dev);
 }
 
-void rtllib_associate_step1(struct rtllib_device *ieee, u8 * daddr)
+static void rtllib_associate_step1(struct rtllib_device *ieee, u8 * daddr)
 {
 	struct rtllib_network *beacon = &ieee->current_network;
 	struct sk_buff *skb;
@@ -1495,7 +1468,7 @@ void rtllib_associate_step1(struct rtllib_device *ieee, u8 * daddr)
 	}
 }
 
-void rtllib_auth_challenge(struct rtllib_device *ieee, u8 *challenge, int chlen)
+static void rtllib_auth_challenge(struct rtllib_device *ieee, u8 *challenge, int chlen)
 {
 	u8 *c;
 	struct sk_buff *skb;
@@ -1526,7 +1499,7 @@ void rtllib_auth_challenge(struct rtllib_device *ieee, u8 *challenge, int chlen)
 	kfree(challenge);
 }
 
-void rtllib_associate_step2(struct rtllib_device *ieee)
+static void rtllib_associate_step2(struct rtllib_device *ieee)
 {
 	struct sk_buff *skb;
 	struct rtllib_network *beacon = &ieee->current_network;
@@ -1546,7 +1519,7 @@ void rtllib_associate_step2(struct rtllib_device *ieee)
 }
 
 #define CANCELLED  2
-void rtllib_associate_complete_wq(void *data)
+static void rtllib_associate_complete_wq(void *data)
 {
 	struct rtllib_device *ieee = (struct rtllib_device *)
 				     container_of_work_rsl(data,
@@ -1606,7 +1579,7 @@ static void rtllib_sta_send_associnfo(struct rtllib_device *ieee)
 {
 }
 
-void rtllib_associate_complete(struct rtllib_device *ieee)
+static void rtllib_associate_complete(struct rtllib_device *ieee)
 {
 	del_timer_sync(&ieee->associate_timer);
 
@@ -1616,7 +1589,7 @@ void rtllib_associate_complete(struct rtllib_device *ieee)
 	queue_work_rsl(ieee->wq, &ieee->associate_complete_wq);
 }
 
-void rtllib_associate_procedure_wq(void *data)
+static void rtllib_associate_procedure_wq(void *data)
 {
 	struct rtllib_device *ieee = container_of_dwork_rsl(data,
 				     struct rtllib_device,
@@ -1828,7 +1801,7 @@ static inline u16 auth_parse(struct sk_buff *skb, u8** challenge, int *chlen)
 	return cpu_to_le16(a->status);
 }
 
-int auth_rq_parse(struct sk_buff *skb, u8 *dest)
+static int auth_rq_parse(struct sk_buff *skb, u8 *dest)
 {
 	struct rtllib_authentication *a;
 
@@ -1894,7 +1867,7 @@ static short probe_rq_parse(struct rtllib_device *ieee, struct sk_buff *skb,
 	return !strncmp(ssid, ieee->current_network.ssid, ssidlen);
 }
 
-int assoc_rq_parse(struct sk_buff *skb, u8 *dest)
+static int assoc_rq_parse(struct sk_buff *skb, u8 *dest)
 {
 	struct rtllib_assoc_request_frame *a;
 
@@ -2075,7 +2048,7 @@ static short rtllib_sta_ps_sleep(struct rtllib_device *ieee, u64 *time)
 
 }
 
-inline void rtllib_sta_ps(struct rtllib_device *ieee)
+static inline void rtllib_sta_ps(struct rtllib_device *ieee)
 {
 	u64 time;
 	short sleep;
@@ -2196,7 +2169,7 @@ void rtllib_ps_tx_ack(struct rtllib_device *ieee, short success)
 	spin_unlock_irqrestore(&ieee->lock, flags);
 }
 
-void rtllib_process_action(struct rtllib_device *ieee, struct sk_buff *skb)
+static void rtllib_process_action(struct rtllib_device *ieee, struct sk_buff *skb)
 {
 	struct rtllib_hdr_3addr *header = (struct rtllib_hdr_3addr *) skb->data;
 	u8 *act = rtllib_get_payload((struct rtllib_hdr *)header);
@@ -2530,7 +2503,7 @@ void rtllib_softmac_xmit(struct rtllib_txb *txb, struct rtllib_device *ieee)
 }
 
 /* called with ieee->lock acquired */
-void rtllib_resume_tx(struct rtllib_device *ieee)
+static void rtllib_resume_tx(struct rtllib_device *ieee)
 {
 	int i;
 	for (i = ieee->tx_pending.frag; i < ieee->tx_pending.txb->nr_frags;
@@ -2675,7 +2648,7 @@ void rtllib_start_master_bss(struct rtllib_device *ieee)
 	netif_carrier_on(ieee->dev);
 }
 
-void rtllib_start_monitor_mode(struct rtllib_device *ieee)
+static void rtllib_start_monitor_mode(struct rtllib_device *ieee)
 {
 	/* reset hardware status */
 	if (ieee->raw_tx) {
@@ -2686,7 +2659,7 @@ void rtllib_start_monitor_mode(struct rtllib_device *ieee)
 	}
 }
 
-void rtllib_start_ibss_wq(void *data)
+static void rtllib_start_ibss_wq(void *data)
 {
 	struct rtllib_device *ieee = container_of_dwork_rsl(data,
 				     struct rtllib_device, start_ibss_wq);
@@ -2850,7 +2823,7 @@ void rtllib_start_bss(struct rtllib_device *ieee)
 	spin_unlock_irqrestore(&ieee->lock, flags);
 }
 
-void rtllib_link_change_wq(void *data)
+static void rtllib_link_change_wq(void *data)
 {
 	struct rtllib_device *ieee = container_of_dwork_rsl(data,
 				     struct rtllib_device, link_change_wq);
@@ -2876,7 +2849,7 @@ void rtllib_disassociate(struct rtllib_device *ieee)
 	notify_wx_assoc_event(ieee);
 }
 
-void rtllib_associate_retry_wq(void *data)
+static void rtllib_associate_retry_wq(void *data)
 {
 	struct rtllib_device *ieee = container_of_dwork_rsl(data,
 				     struct rtllib_device, associate_retry_wq);
@@ -3194,8 +3167,8 @@ static int rtllib_wpa_enable(struct rtllib_device *ieee, int value)
 }
 
 
-void rtllib_wpa_assoc_frame(struct rtllib_device *ieee, char *wpa_ie,
-			    int wpa_ie_len)
+static void rtllib_wpa_assoc_frame(struct rtllib_device *ieee, char *wpa_ie,
+				   int wpa_ie_len)
 {
 	/* make sure WPA is enabled */
 	rtllib_wpa_enable(ieee, 1);
@@ -3698,7 +3671,7 @@ void rtllib_MlmeDisassociateRequest(struct rtllib_device *rtllib, u8 *asSta,
 	RemovePeerTS(rtllib, asSta);
 
 
-	if (memcpy(rtllib->current_network.bssid, asSta, 6) == 0) {
+	if (memcpy(rtllib->current_network.bssid, asSta, 6) == NULL) {
 		rtllib->state = RTLLIB_NOLINK;
 
 		for (i = 0; i < 6; i++)

commit ac50ddaaeeca4f649c53ce31175aa68d26420138
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Thu Aug 25 14:07:03 2011 -0500

    staging: rtl8192e: Remove MAC_FMT and MAC_ARG for %pM
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index fa0e2afd1ed1..dd4dec8c53af 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -1972,7 +1972,7 @@ static inline void rtllib_rx_assoc_rq(struct rtllib_device *ieee,
 	if (assoc_rq_parse(skb, dest) != -1)
 		rtllib_resp_to_assoc_rq(ieee, dest);
 
-	printk(KERN_INFO"New client associated: "MAC_FMT"\n", MAC_ARG(dest));
+	printk(KERN_INFO"New client associated: %pM\n", dest);
 }
 
 void rtllib_sta_ps_send_null_frame(struct rtllib_device *ieee, short pwr)

commit 9d92ece80d38a6fbf098bd924cf6db146c08f817
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Thu Aug 25 11:48:26 2011 -0500

    staging: rtl8192e: Cleanup checkpatch -f errors - Part XIV
    
    With this patch, all of the checkpatch errors are fixed; however, only
    some of the lines that are too long were fixed. To complete the fixing
    of these warnings, the file rtllib_softmac.c will need refactoring. In addition,
    some of the variables may need renaming. Those changes can be deferred.
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 29277d18f021..fa0e2afd1ed1 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -20,27 +20,26 @@
 #include <linux/random.h>
 #include <linux/delay.h>
 #include <linux/version.h>
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
 #include "dot11d.h"
 
-extern void _setup_timer( struct timer_list*, void*, unsigned long );
 u8 rsn_authen_cipher_suite[16][4] = {
-	{0x00,0x0F,0xAC,0x00},
-	{0x00,0x0F,0xAC,0x01},
-	{0x00,0x0F,0xAC,0x02},
-	{0x00,0x0F,0xAC,0x03},
-	{0x00,0x0F,0xAC,0x04},
-	{0x00,0x0F,0xAC,0x05},
+	{0x00, 0x0F, 0xAC, 0x00},
+	{0x00, 0x0F, 0xAC, 0x01},
+	{0x00, 0x0F, 0xAC, 0x02},
+	{0x00, 0x0F, 0xAC, 0x03},
+	{0x00, 0x0F, 0xAC, 0x04},
+	{0x00, 0x0F, 0xAC, 0x05},
 };
 
 short rtllib_is_54g(struct rtllib_network *net)
 {
-	return ((net->rates_ex_len > 0) || (net->rates_len > 4));
+	return (net->rates_ex_len > 0) || (net->rates_len > 4);
 }
 
 short rtllib_is_shortslot(struct rtllib_network net)
 {
-	return (net.capability & WLAN_CAPABILITY_SHORT_SLOT_TIME);
+	return net.capability & WLAN_CAPABILITY_SHORT_SLOT_TIME;
 }
 
 /* returns the total length needed for pleacing the RATE MFIE
@@ -69,7 +68,7 @@ void rtllib_MFIE_Brate(struct rtllib_device *ieee, u8 **tag_p)
 {
 	u8 *tag = *tag_p;
 
-	if (ieee->modulation & RTLLIB_CCK_MODULATION){
+	if (ieee->modulation & RTLLIB_CCK_MODULATION) {
 		*tag++ = MFIE_TYPE_RATES;
 		*tag++ = 4;
 		*tag++ = RTLLIB_BASIC_RATE_MASK | RTLLIB_CCK_RATE_1MB;
@@ -78,7 +77,8 @@ void rtllib_MFIE_Brate(struct rtllib_device *ieee, u8 **tag_p)
 		*tag++ = RTLLIB_BASIC_RATE_MASK | RTLLIB_CCK_RATE_11MB;
 	}
 
-	/* We may add an option for custom rates that specific HW might support */
+	/* We may add an option for custom rates that specific HW
+	 * might support */
 	*tag_p = tag;
 }
 
@@ -86,8 +86,7 @@ void rtllib_MFIE_Grate(struct rtllib_device *ieee, u8 **tag_p)
 {
 	u8 *tag = *tag_p;
 
-		if (ieee->modulation & RTLLIB_OFDM_MODULATION){
-
+	if (ieee->modulation & RTLLIB_OFDM_MODULATION) {
 		*tag++ = MFIE_TYPE_RATES_EX;
 		*tag++ = 8;
 		*tag++ = RTLLIB_BASIC_RATE_MASK | RTLLIB_OFDM_RATE_6MB;
@@ -98,14 +97,14 @@ void rtllib_MFIE_Grate(struct rtllib_device *ieee, u8 **tag_p)
 		*tag++ = RTLLIB_BASIC_RATE_MASK | RTLLIB_OFDM_RATE_36MB;
 		*tag++ = RTLLIB_BASIC_RATE_MASK | RTLLIB_OFDM_RATE_48MB;
 		*tag++ = RTLLIB_BASIC_RATE_MASK | RTLLIB_OFDM_RATE_54MB;
-
 	}
-
-	/* We may add an option for custom rates that specific HW might support */
+	/* We may add an option for custom rates that specific HW might
+	 * support */
 	*tag_p = tag;
 }
 
-void rtllib_WMM_Info(struct rtllib_device *ieee, u8 **tag_p) {
+void rtllib_WMM_Info(struct rtllib_device *ieee, u8 **tag_p)
+{
 	u8 *tag = *tag_p;
 
 	*tag++ = MFIE_TYPE_GENERIC;
@@ -120,17 +119,18 @@ void rtllib_WMM_Info(struct rtllib_device *ieee, u8 **tag_p) {
 	*tag_p = tag;
 }
 
-void rtllib_TURBO_Info(struct rtllib_device *ieee, u8 **tag_p) {
+void rtllib_TURBO_Info(struct rtllib_device *ieee, u8 **tag_p)
+{
 	u8 *tag = *tag_p;
 
-        *tag++ = MFIE_TYPE_GENERIC;
-        *tag++ = 7;
-        *tag++ = 0x00;
-        *tag++ = 0xe0;
-        *tag++ = 0x4c;
-        *tag++ = 0x01;
-        *tag++ = 0x02;
-        *tag++ = 0x11;
+	*tag++ = MFIE_TYPE_GENERIC;
+	*tag++ = 7;
+	*tag++ = 0x00;
+	*tag++ = 0xe0;
+	*tag++ = 0x4c;
+	*tag++ = 0x01;
+	*tag++ = 0x02;
+	*tag++ = 0x11;
 	*tag++ = 0x00;
 
 	*tag_p = tag;
@@ -140,7 +140,7 @@ void rtllib_TURBO_Info(struct rtllib_device *ieee, u8 **tag_p) {
 void enqueue_mgmt(struct rtllib_device *ieee, struct sk_buff *skb)
 {
 	int nh;
-	nh = (ieee->mgmt_queue_head +1) % MGMT_QUEUE_NUM;
+	nh = (ieee->mgmt_queue_head + 1) % MGMT_QUEUE_NUM;
 
 /*
  * if the queue is full but we have newer frames then
@@ -183,29 +183,21 @@ MgntQuery_TxRateExcludeCCKRates(struct rtllib_device *ieee)
 	u8	BasicRate;
 
 
-	for ( i = 0; i < ieee->current_network.rates_len; i++)
-	{
+	for (i = 0; i < ieee->current_network.rates_len; i++) {
 		BasicRate = ieee->current_network.rates[i]&0x7F;
-		if (!rtllib_is_cck_rate(BasicRate))
-		{
-			if (QueryRate == 0)
-			{
+		if (!rtllib_is_cck_rate(BasicRate)) {
+			if (QueryRate == 0) {
 				QueryRate = BasicRate;
-			}
-			else
-			{
+			} else {
 				if (BasicRate < QueryRate)
-				{
 					QueryRate = BasicRate;
-				}
 			}
 		}
 	}
 
-	if (QueryRate == 0)
-	{
+	if (QueryRate == 0) {
 		QueryRate = 12;
-		printk("No BasicRate found!!\n");
+		printk(KERN_INFO "No BasicRate found!!\n");
 	}
 	return QueryRate;
 }
@@ -220,10 +212,10 @@ u8 MgntQuery_MgntFrameTxRate(struct rtllib_device *ieee)
 	else
 		rate = ieee->basic_rate & 0x7f;
 
-	if (rate == 0){
-		if (ieee->mode == IEEE_A||
-		   ieee->mode== IEEE_N_5G||
-		   (ieee->mode== IEEE_N_24G&&!pHTInfo->bCurSuppCCK))
+	if (rate == 0) {
+		if (ieee->mode == IEEE_A ||
+		   ieee->mode == IEEE_N_5G ||
+		   (ieee->mode == IEEE_N_24G && !pHTInfo->bCurSuppCCK))
 			rate = 0x0c;
 		else
 			rate = 0x02;
@@ -232,21 +224,18 @@ u8 MgntQuery_MgntFrameTxRate(struct rtllib_device *ieee)
 	return rate;
 }
 
-
-void rtllib_sta_wakeup(struct rtllib_device *ieee, short nl);
-
 inline void softmac_mgmt_xmit(struct sk_buff *skb, struct rtllib_device *ieee)
 {
 	unsigned long flags;
 	short single = ieee->softmac_features & IEEE_SOFTMAC_SINGLE_QUEUE;
-	struct rtllib_hdr_3addr  *header=
+	struct rtllib_hdr_3addr  *header =
 		(struct rtllib_hdr_3addr  *) skb->data;
 
 	struct cb_desc *tcb_desc = (struct cb_desc *)(skb->cb + 8);
 	spin_lock_irqsave(&ieee->lock, flags);
 
 	/* called with 2nd param 0, no mgmt lock required */
-	rtllib_sta_wakeup(ieee,0);
+	rtllib_sta_wakeup(ieee, 0);
 
 	if (header->frame_ctl == RTLLIB_STYPE_BEACON)
 		tcb_desc->queue_index = BEACON_QUEUE;
@@ -261,9 +250,9 @@ inline void softmac_mgmt_xmit(struct sk_buff *skb, struct rtllib_device *ieee)
 	tcb_desc->bTxDisableRateFallBack = 1;
 	tcb_desc->bTxUseDriverAssingedRate = 1;
 	if (single) {
-		if (ieee->queue_stop){
-			enqueue_mgmt(ieee,skb);
-		}else{
+		if (ieee->queue_stop) {
+			enqueue_mgmt(ieee, skb);
+		} else {
 			header->seq_ctl = cpu_to_le16(ieee->seq_ctrl[0]<<4);
 
 			if (ieee->seq_ctrl[0] == 0xFFF)
@@ -272,11 +261,12 @@ inline void softmac_mgmt_xmit(struct sk_buff *skb, struct rtllib_device *ieee)
 				ieee->seq_ctrl[0]++;
 
 			/* avoid watchdog triggers */
-			ieee->softmac_data_hard_start_xmit(skb,ieee->dev,ieee->basic_rate);
+			ieee->softmac_data_hard_start_xmit(skb, ieee->dev,
+							   ieee->basic_rate);
 		}
 
 		spin_unlock_irqrestore(&ieee->lock, flags);
-	}else{
+	} else {
 		spin_unlock_irqrestore(&ieee->lock, flags);
 		spin_lock_irqsave(&ieee->mgmt_tx_lock, flags);
 
@@ -288,17 +278,19 @@ inline void softmac_mgmt_xmit(struct sk_buff *skb, struct rtllib_device *ieee)
 			ieee->seq_ctrl[0]++;
 
 		/* check wether the managed packet queued greater than 5 */
-		if (!ieee->check_nic_enough_desc(ieee->dev,tcb_desc->queue_index)||\
-				(skb_queue_len(&ieee->skb_waitQ[tcb_desc->queue_index]) != 0)||\
-				(ieee->queue_stop) ) {
+		if (!ieee->check_nic_enough_desc(ieee->dev, tcb_desc->queue_index) ||
+		    (skb_queue_len(&ieee->skb_waitQ[tcb_desc->queue_index]) != 0) ||
+		    (ieee->queue_stop)) {
 			/* insert the skb packet to the management queue */
 			/* as for the completion function, it does not need
 			 * to check it any more.
 			 * */
-			printk("%s():insert to waitqueue, queue_index:%d!\n",__func__,tcb_desc->queue_index);
-			skb_queue_tail(&ieee->skb_waitQ[tcb_desc->queue_index], skb);
+			printk(KERN_INFO "%s():insert to waitqueue, queue_index"
+			       ":%d!\n", __func__, tcb_desc->queue_index);
+			skb_queue_tail(&ieee->skb_waitQ[tcb_desc->queue_index],
+				       skb);
 		} else {
-			ieee->softmac_hard_start_xmit(skb,ieee->dev);
+			ieee->softmac_hard_start_xmit(skb, ieee->dev);
 		}
 		spin_unlock_irqrestore(&ieee->mgmt_tx_lock, flags);
 	}
@@ -310,7 +302,7 @@ inline void softmac_ps_mgmt_xmit(struct sk_buff *skb,
 	short single = ieee->softmac_features & IEEE_SOFTMAC_SINGLE_QUEUE;
 	struct rtllib_hdr_3addr  *header =
 		(struct rtllib_hdr_3addr  *) skb->data;
-	u16 fc,type,stype;
+	u16 fc, type, stype;
 	struct cb_desc *tcb_desc = (struct cb_desc *)(skb->cb + 8);
 
 	fc = header->frame_ctl;
@@ -342,7 +334,8 @@ inline void softmac_ps_mgmt_xmit(struct sk_buff *skb,
 
 		}
 		/* avoid watchdog triggers */
-		ieee->softmac_data_hard_start_xmit(skb,ieee->dev,ieee->basic_rate);
+		ieee->softmac_data_hard_start_xmit(skb, ieee->dev,
+						   ieee->basic_rate);
 
 	} else {
 		if (type != RTLLIB_FTYPE_CTL) {
@@ -353,14 +346,14 @@ inline void softmac_ps_mgmt_xmit(struct sk_buff *skb,
 			else
 				ieee->seq_ctrl[0]++;
 		}
-		ieee->softmac_hard_start_xmit(skb,ieee->dev);
+		ieee->softmac_hard_start_xmit(skb, ieee->dev);
 
 	}
 }
 
 inline struct sk_buff *rtllib_probe_req(struct rtllib_device *ieee)
 {
-	unsigned int len,rate_len;
+	unsigned int len, rate_len;
 	u8 *tag;
 	struct sk_buff *skb;
 	struct rtllib_probe_request *req;
@@ -377,7 +370,8 @@ inline struct sk_buff *rtllib_probe_req(struct rtllib_device *ieee)
 
 	skb_reserve(skb, ieee->tx_headroom);
 
-	req = (struct rtllib_probe_request *) skb_put(skb,sizeof(struct rtllib_probe_request));
+	req = (struct rtllib_probe_request *) skb_put(skb,
+	      sizeof(struct rtllib_probe_request));
 	req->header.frame_ctl = cpu_to_le16(RTLLIB_STYPE_PROBE_REQ);
 	req->header.duration_id = 0;
 
@@ -385,15 +379,15 @@ inline struct sk_buff *rtllib_probe_req(struct rtllib_device *ieee)
 	memcpy(req->header.addr2, ieee->dev->dev_addr, ETH_ALEN);
 	memset(req->header.addr3, 0xff, ETH_ALEN);
 
-	tag = (u8 *) skb_put(skb,len+2+rate_len);
+	tag = (u8 *) skb_put(skb, len + 2 + rate_len);
 
 	*tag++ = MFIE_TYPE_SSID;
 	*tag++ = len;
 	memcpy(tag, ieee->current_network.ssid, len);
 	tag += len;
 
-	rtllib_MFIE_Brate(ieee,&tag);
-	rtllib_MFIE_Grate(ieee,&tag);
+	rtllib_MFIE_Brate(ieee, &tag);
+	rtllib_MFIE_Grate(ieee, &tag);
 
 	return skb;
 }
@@ -407,14 +401,14 @@ void rtllib_send_beacon(struct rtllib_device *ieee)
 		return;
 	skb = rtllib_get_beacon_(ieee);
 
-	if (skb){
+	if (skb) {
 		softmac_mgmt_xmit(skb, ieee);
 		ieee->softmac_stats.tx_beacons++;
 	}
 
-	if (ieee->beacon_txing && ieee->ieee_up){
-		mod_timer(&ieee->beacon_timer,jiffies+(MSECS(ieee->current_network.beacon_interval-5)));
-	}
+	if (ieee->beacon_txing && ieee->ieee_up)
+		mod_timer(&ieee->beacon_timer, jiffies +
+			  (MSECS(ieee->current_network.beacon_interval - 5)));
 }
 
 
@@ -431,83 +425,86 @@ void rtllib_send_beacon_cb(unsigned long _ieee)
 
 /*
  * Description:
- *              Enable network monitor mode, all rx packets will be received.
+ *	      Enable network monitor mode, all rx packets will be received.
  */
-void rtllib_EnableNetMonitorMode(struct net_device* dev,
-                bool bInitState)
+void rtllib_EnableNetMonitorMode(struct net_device *dev,
+		bool bInitState)
 {
-        struct rtllib_device* ieee = netdev_priv_rsl(dev);
+	struct rtllib_device *ieee = netdev_priv_rsl(dev);
 
-        printk("========>Enter Monitor Mode\n");
+	printk(KERN_INFO "========>Enter Monitor Mode\n");
 
-        ieee->AllowAllDestAddrHandler(dev, true, !bInitState);
+	ieee->AllowAllDestAddrHandler(dev, true, !bInitState);
 }
 
 
 /*
  *      Description:
- *              Disable network network monitor mode, only packets destinated to
- *              us will be received.
+ *	      Disable network network monitor mode, only packets destinated to
+ *	      us will be received.
  */
-void rtllib_DisableNetMonitorMode(struct net_device* dev,
-                bool bInitState)
+void rtllib_DisableNetMonitorMode(struct net_device *dev,
+		bool bInitState)
 {
-	struct rtllib_device* ieee = netdev_priv_rsl(dev);
+	struct rtllib_device *ieee = netdev_priv_rsl(dev);
 
-        printk("========>Exit Monitor Mode\n");
+	printk(KERN_INFO "========>Exit Monitor Mode\n");
 
-        ieee->AllowAllDestAddrHandler(dev, false, !bInitState);
+	ieee->AllowAllDestAddrHandler(dev, false, !bInitState);
 }
 
 
 /*
  * Description:
- *              This enables the specialized promiscuous mode required by Intel.
- *              In this mode, Intel intends to hear traffics from/to other STAs in the same BSS.
- *              Therefore we don't have to disable checking BSSID and we only need to allow all dest.
- *              BUT: if we enable checking BSSID then we can't recv packets from other STA.
+ * This enables the specialized promiscuous mode required by Intel.
+ * In this mode, Intel intends to hear traffics from/to other STAs in the
+ * same BSS. Therefore we don't have to disable checking BSSID and we only need
+ * to allow all dest. BUT: if we enable checking BSSID then we can't recv
+ * packets from other STA.
  */
-void rtllib_EnableIntelPromiscuousMode(struct net_device* dev,
-                bool bInitState)
+void rtllib_EnableIntelPromiscuousMode(struct net_device *dev,
+		bool bInitState)
 {
-        bool bFilterOutNonAssociatedBSSID = false;
+	bool bFilterOutNonAssociatedBSSID = false;
 
-	struct rtllib_device* ieee = netdev_priv_rsl(dev);
+	struct rtllib_device *ieee = netdev_priv_rsl(dev);
 
-        printk("========>Enter Intel Promiscuous Mode\n");
+	printk(KERN_INFO "========>Enter Intel Promiscuous Mode\n");
 
-        ieee->AllowAllDestAddrHandler(dev, true, !bInitState);
-        ieee->SetHwRegHandler(dev, HW_VAR_CECHK_BSSID, (u8*)&bFilterOutNonAssociatedBSSID);
+	ieee->AllowAllDestAddrHandler(dev, true, !bInitState);
+	ieee->SetHwRegHandler(dev, HW_VAR_CECHK_BSSID,
+			     (u8 *)&bFilterOutNonAssociatedBSSID);
 
-        ieee->bNetPromiscuousMode = true;
+	ieee->bNetPromiscuousMode = true;
 }
 
 
 /*
  * Description:
- *              This disables the specialized promiscuous mode required by Intel.
- *              See MgntEnableIntelPromiscuousMode for detail.
+ *	      This disables the specialized promiscuous mode required by Intel.
+ *	      See MgntEnableIntelPromiscuousMode for detail.
  */
-void rtllib_DisableIntelPromiscuousMode(struct net_device* dev,
-                bool bInitState)
+void rtllib_DisableIntelPromiscuousMode(struct net_device *dev,
+		bool bInitState)
 {
-        bool bFilterOutNonAssociatedBSSID = true;
+	bool bFilterOutNonAssociatedBSSID = true;
 
-	struct rtllib_device* ieee = netdev_priv_rsl(dev);
+	struct rtllib_device *ieee = netdev_priv_rsl(dev);
 
-        printk("========>Exit Intel Promiscuous Mode\n");
+	printk(KERN_INFO "========>Exit Intel Promiscuous Mode\n");
 
-        ieee->AllowAllDestAddrHandler(dev, false, !bInitState);
-        ieee->SetHwRegHandler(dev, HW_VAR_CECHK_BSSID, (u8*)&bFilterOutNonAssociatedBSSID);
+	ieee->AllowAllDestAddrHandler(dev, false, !bInitState);
+	ieee->SetHwRegHandler(dev, HW_VAR_CECHK_BSSID,
+			     (u8 *)&bFilterOutNonAssociatedBSSID);
 
-        ieee->bNetPromiscuousMode = false;
+	ieee->bNetPromiscuousMode = false;
 }
 
 void rtllib_send_probe(struct rtllib_device *ieee, u8 is_mesh)
 {
 	struct sk_buff *skb;
 	skb = rtllib_probe_req(ieee);
-	if (skb){
+	if (skb) {
 		softmac_mgmt_xmit(skb, ieee);
 		ieee->softmac_stats.tx_probe_rq++;
 	}
@@ -529,7 +526,8 @@ void rtllib_softmac_hint11d_wq(void *data)
 
 void rtllib_update_active_chan_map(struct rtllib_device *ieee)
 {
-	memcpy(ieee->active_channel_map, GET_DOT11D_INFO(ieee)->channel_map, MAX_CHANNEL_NUMBER+1);
+	memcpy(ieee->active_channel_map, GET_DOT11D_INFO(ieee)->channel_map,
+	       MAX_CHANNEL_NUMBER+1);
 }
 
 /* this performs syncro scan blocking the caller until all channels
@@ -537,6 +535,7 @@ void rtllib_update_active_chan_map(struct rtllib_device *ieee)
  */
 void rtllib_softmac_scan_syncro(struct rtllib_device *ieee, u8 is_mesh)
 {
+	union iwreq_data wrqu;
 	short ch = 0;
 
 	rtllib_update_active_chan_map(ieee);
@@ -545,14 +544,12 @@ void rtllib_softmac_scan_syncro(struct rtllib_device *ieee, u8 is_mesh)
 
 	down(&ieee->scan_sem);
 
-	while(1)
-	{
-
+	while (1) {
 		do {
 			ch++;
 			if (ch > MAX_CHANNEL_NUMBER)
 				goto out; /* scan completed */
-		} while(!ieee->active_channel_map[ch]);
+		} while (!ieee->active_channel_map[ch]);
 
 		/* this fuction can be called in two situations
 		 * 1- We have switched to ad-hoc mode and we are
@@ -575,14 +572,14 @@ void rtllib_softmac_scan_syncro(struct rtllib_device *ieee, u8 is_mesh)
 
 		if (ieee->state == RTLLIB_LINKED)
 			goto out;
-		if (ieee->sync_scan_hurryup){
-			printk("============>sync_scan_hurryup out\n");
+		if (ieee->sync_scan_hurryup) {
+			printk(KERN_INFO "============>sync_scan_hurryup out\n");
 			goto out;
 		}
 
 		ieee->set_chan(ieee->dev, ch);
 		if (ieee->active_channel_map[ch] == 1)
-		rtllib_send_probe_requests(ieee, 0);
+			rtllib_send_probe_requests(ieee, 0);
 
 		/* this prevent excessive time wait when we
 		 * need to wait for a syncro scan to end..
@@ -593,7 +590,7 @@ void rtllib_softmac_scan_syncro(struct rtllib_device *ieee, u8 is_mesh)
 	ieee->actscanning = false;
 	ieee->sync_scan_hurryup = 0;
 
-	if (ieee->state >= RTLLIB_LINKED){
+	if (ieee->state >= RTLLIB_LINKED) {
 		if (IS_DOT11D_ENABLE(ieee))
 			DOT11D_ScanComplete(ieee);
 	}
@@ -601,53 +598,52 @@ void rtllib_softmac_scan_syncro(struct rtllib_device *ieee, u8 is_mesh)
 
 	ieee->be_scan_inprogress = false;
 
-	{
-	union iwreq_data wrqu;
 	memset(&wrqu, 0, sizeof(wrqu));
-	wireless_send_event(ieee->dev,SIOCGIWSCAN,&wrqu,NULL);
-	}
+	wireless_send_event(ieee->dev, SIOCGIWSCAN, &wrqu, NULL);
 }
 
 void rtllib_softmac_scan_wq(void *data)
 {
-	struct rtllib_device *ieee = container_of_dwork_rsl(data, struct rtllib_device, softmac_scan_wq);
+	struct rtllib_device *ieee = container_of_dwork_rsl(data,
+				     struct rtllib_device, softmac_scan_wq);
 	u8 last_channel = ieee->current_network.channel;
 
 	rtllib_update_active_chan_map(ieee);
 
 	if (!ieee->ieee_up)
 		return;
-	if (rtllib_act_scanning(ieee,true) == true)
+	if (rtllib_act_scanning(ieee, true) == true)
 		return;
 
 	down(&ieee->scan_sem);
 
-	if (ieee->eRFPowerState == eRfOff)
-	{
-		printk("======>%s():rf state is eRfOff, return\n",__func__);
+	if (ieee->eRFPowerState == eRfOff) {
+		printk(KERN_INFO "======>%s():rf state is eRfOff, return\n",
+		       __func__);
 		goto out1;
 	}
 
-	do{
+	do {
 		ieee->current_network.channel =
-			(ieee->current_network.channel + 1) % MAX_CHANNEL_NUMBER;
-		if (ieee->scan_watch_dog++ > MAX_CHANNEL_NUMBER)
-		{
+			(ieee->current_network.channel + 1) %
+			MAX_CHANNEL_NUMBER;
+		if (ieee->scan_watch_dog++ > MAX_CHANNEL_NUMBER) {
 			if (!ieee->active_channel_map[ieee->current_network.channel])
 				ieee->current_network.channel = 6;
 			goto out; /* no good chans */
 		}
-	} while(!ieee->active_channel_map[ieee->current_network.channel]);
+	} while (!ieee->active_channel_map[ieee->current_network.channel]);
 
-	if (ieee->scanning_continue == 0 )
+	if (ieee->scanning_continue == 0)
 		goto out;
 
 	ieee->set_chan(ieee->dev, ieee->current_network.channel);
 
 	if (ieee->active_channel_map[ieee->current_network.channel] == 1)
-	rtllib_send_probe_requests(ieee, 0);
+		rtllib_send_probe_requests(ieee, 0);
 
-	queue_delayed_work_rsl(ieee->wq, &ieee->softmac_scan_wq, MSECS(RTLLIB_SOFTMAC_SCAN_TIME));
+	queue_delayed_work_rsl(ieee->wq, &ieee->softmac_scan_wq,
+			       MSECS(RTLLIB_SOFTMAC_SCAN_TIME));
 
 	up(&ieee->scan_sem);
 	return;
@@ -669,24 +665,24 @@ void rtllib_softmac_scan_wq(void *data)
 void rtllib_beacons_start(struct rtllib_device *ieee)
 {
 	unsigned long flags;
-	spin_lock_irqsave(&ieee->beacon_lock,flags);
+	spin_lock_irqsave(&ieee->beacon_lock, flags);
 
 	ieee->beacon_txing = 1;
 	rtllib_send_beacon(ieee);
 
-	spin_unlock_irqrestore(&ieee->beacon_lock,flags);
+	spin_unlock_irqrestore(&ieee->beacon_lock, flags);
 }
 
 void rtllib_beacons_stop(struct rtllib_device *ieee)
 {
 	unsigned long flags;
 
-	spin_lock_irqsave(&ieee->beacon_lock,flags);
+	spin_lock_irqsave(&ieee->beacon_lock, flags);
 
 	ieee->beacon_txing = 0;
 	del_timer_sync(&ieee->beacon_timer);
 
-	spin_unlock_irqrestore(&ieee->beacon_lock,flags);
+	spin_unlock_irqrestore(&ieee->beacon_lock, flags);
 
 }
 
@@ -725,9 +721,9 @@ void rtllib_softmac_stop_scan(struct rtllib_device *ieee)
 
 void rtllib_stop_scan(struct rtllib_device *ieee)
 {
-	if (ieee->softmac_features & IEEE_SOFTMAC_SCAN){
+	if (ieee->softmac_features & IEEE_SOFTMAC_SCAN) {
 		rtllib_softmac_stop_scan(ieee);
-	}else{
+	} else {
 		if (ieee->rtllib_stop_hw_scan)
 			ieee->rtllib_stop_hw_scan(ieee->dev);
 	}
@@ -735,9 +731,9 @@ void rtllib_stop_scan(struct rtllib_device *ieee)
 
 void rtllib_stop_scan_syncro(struct rtllib_device *ieee)
 {
-	if (ieee->softmac_features & IEEE_SOFTMAC_SCAN){
+	if (ieee->softmac_features & IEEE_SOFTMAC_SCAN) {
 			ieee->sync_scan_hurryup = 1;
-	}else{
+	} else {
 		if (ieee->rtllib_stop_hw_scan)
 			ieee->rtllib_stop_hw_scan(ieee->dev);
 	}
@@ -745,13 +741,12 @@ void rtllib_stop_scan_syncro(struct rtllib_device *ieee)
 
 bool rtllib_act_scanning(struct rtllib_device *ieee, bool sync_scan)
 {
-	if (ieee->softmac_features & IEEE_SOFTMAC_SCAN){
-		if (sync_scan){
+	if (ieee->softmac_features & IEEE_SOFTMAC_SCAN) {
+		if (sync_scan)
 			return ieee->be_scan_inprogress;
-		}else{
-			return (ieee->actscanning ||ieee->be_scan_inprogress);
-		}
-	}else{
+		else
+			return ieee->actscanning || ieee->be_scan_inprogress;
+	} else {
 		return test_bit(STATUS_SCANNING, &ieee->status);
 	}
 }
@@ -759,61 +754,55 @@ bool rtllib_act_scanning(struct rtllib_device *ieee, bool sync_scan)
 /* called with ieee->lock held */
 void rtllib_start_scan(struct rtllib_device *ieee)
 {
-	RT_TRACE(COMP_DBG, "===>%s()\n",__func__);
+	RT_TRACE(COMP_DBG, "===>%s()\n", __func__);
 	if (ieee->rtllib_ips_leave_wq != NULL)
-	ieee->rtllib_ips_leave_wq(ieee->dev);
+		ieee->rtllib_ips_leave_wq(ieee->dev);
 
-
-	if (IS_DOT11D_ENABLE(ieee) )
-	{
+	if (IS_DOT11D_ENABLE(ieee)) {
 		if (IS_COUNTRY_IE_VALID(ieee))
-		{
 			RESET_CIE_WATCHDOG(ieee);
-		}
 	}
 	if (ieee->softmac_features & IEEE_SOFTMAC_SCAN) {
 		if (ieee->scanning_continue == 0) {
 			ieee->actscanning = true;
 			ieee->scanning_continue = 1;
-			queue_delayed_work_rsl(ieee->wq, &ieee->softmac_scan_wq, 0);
+			queue_delayed_work_rsl(ieee->wq,
+					       &ieee->softmac_scan_wq, 0);
 		}
 	} else {
 		if (ieee->rtllib_start_hw_scan)
 			ieee->rtllib_start_hw_scan(ieee->dev);
 	}
-
 }
 
 /* called with wx_sem held */
 void rtllib_start_scan_syncro(struct rtllib_device *ieee, u8 is_mesh)
 {
-	if (IS_DOT11D_ENABLE(ieee) )
-	{
+	if (IS_DOT11D_ENABLE(ieee)) {
 		if (IS_COUNTRY_IE_VALID(ieee))
-		{
 			RESET_CIE_WATCHDOG(ieee);
-		}
 	}
 	ieee->sync_scan_hurryup = 0;
-	if (ieee->softmac_features & IEEE_SOFTMAC_SCAN){
+	if (ieee->softmac_features & IEEE_SOFTMAC_SCAN) {
 		rtllib_softmac_scan_syncro(ieee, is_mesh);
-	}else{
+	} else {
 		if (ieee->rtllib_start_hw_scan)
 			ieee->rtllib_start_hw_scan(ieee->dev);
 	}
-
 }
 
 inline struct sk_buff *rtllib_authentication_req(struct rtllib_network *beacon,
-	struct rtllib_device *ieee, int challengelen,u8 * daddr)
+	struct rtllib_device *ieee, int challengelen, u8 *daddr)
 {
 	struct sk_buff *skb;
 	struct rtllib_authentication *auth;
 	int  len = 0;
-	len = sizeof(struct rtllib_authentication) + challengelen + ieee->tx_headroom + 4;
+	len = sizeof(struct rtllib_authentication) + challengelen +
+		     ieee->tx_headroom + 4;
 	skb = dev_alloc_skb(len);
 
-	if (!skb) return NULL;
+	if (!skb)
+		return NULL;
 
 	skb_reserve(skb, ieee->tx_headroom);
 
@@ -821,10 +810,11 @@ inline struct sk_buff *rtllib_authentication_req(struct rtllib_network *beacon,
 		skb_put(skb, sizeof(struct rtllib_authentication));
 
 	auth->header.frame_ctl = RTLLIB_STYPE_AUTH;
-	if (challengelen) auth->header.frame_ctl |= RTLLIB_FCTL_WEP;
+	if (challengelen)
+		auth->header.frame_ctl |= RTLLIB_FCTL_WEP;
 
 	auth->header.duration_id = 0x013a;
-		memcpy(auth->header.addr1, beacon->bssid, ETH_ALEN);
+	memcpy(auth->header.addr1, beacon->bssid, ETH_ALEN);
 	memcpy(auth->header.addr2, ieee->dev->dev_addr, ETH_ALEN);
 	memcpy(auth->header.addr3, beacon->bssid, ETH_ALEN);
 	if (ieee->auth_mode == 0)
@@ -839,22 +829,18 @@ inline struct sk_buff *rtllib_authentication_req(struct rtllib_network *beacon,
 	auth->status = cpu_to_le16(WLAN_STATUS_SUCCESS);
 
 	return skb;
-
 }
 
-void constructWMMIE(u8* wmmie, u8* wmm_len,u8 oui_subtype)
+void constructWMMIE(u8 *wmmie, u8 *wmm_len, u8 oui_subtype)
 {
-	u8	szQoSOUI[] ={221, 0, 0x00, 0x50, 0xf2, 0x02, 0, 1};
+	u8	szQoSOUI[] = {221, 0, 0x00, 0x50, 0xf2, 0x02, 0, 1};
 
-	if (oui_subtype == OUI_SUBTYPE_QOS_CAPABI)
-	{
+	if (oui_subtype == OUI_SUBTYPE_QOS_CAPABI) {
 		szQoSOUI[0] = 46;
 		szQoSOUI[1] = *wmm_len;
-		memcpy(wmmie,szQoSOUI,3);
+		memcpy(wmmie, szQoSOUI, 3);
 		*wmm_len = 3;
-	}
-	else
-	{
+	} else {
 		szQoSOUI[1] = *wmm_len + 6;
 		szQoSOUI[6] = oui_subtype;
 		memcpy(wmmie, szQoSOUI, 8);
@@ -863,15 +849,15 @@ void constructWMMIE(u8* wmmie, u8* wmm_len,u8 oui_subtype)
 	}
 }
 
-static struct sk_buff* rtllib_probe_resp(struct rtllib_device *ieee, u8 *dest)
+static struct sk_buff *rtllib_probe_resp(struct rtllib_device *ieee, u8 *dest)
 {
 	u8 *tag;
 	int beacon_size;
 	struct rtllib_probe_response *beacon_buf;
 	struct sk_buff *skb = NULL;
 	int encrypt;
-	int atim_len,erp_len;
-	struct rtllib_crypt_data* crypt;
+	int atim_len, erp_len;
+	struct rtllib_crypt_data *crypt;
 
 	char *ssid = ieee->current_network.ssid;
 	int ssid_len = ieee->current_network.ssid_len;
@@ -880,82 +866,83 @@ static struct sk_buff* rtllib_probe_resp(struct rtllib_device *ieee, u8 *dest)
 	int wpa_ie_len = ieee->wpa_ie_len;
 	u8 erpinfo_content = 0;
 
-	u8* tmp_ht_cap_buf = NULL;
+	u8 *tmp_ht_cap_buf = NULL;
 	u8 tmp_ht_cap_len = 0;
-	u8* tmp_ht_info_buf = NULL;
+	u8 *tmp_ht_info_buf = NULL;
 	u8 tmp_ht_info_len = 0;
 	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
-	u8* tmp_generic_ie_buf = NULL;
+	u8 *tmp_generic_ie_buf = NULL;
 	u8 tmp_generic_ie_len = 0;
 
 	if (rate_ex_len > 0)
-		rate_ex_len+=2;
+		rate_ex_len += 2;
 
 	if (ieee->current_network.capability & WLAN_CAPABILITY_IBSS)
 		atim_len = 4;
 	else
 		atim_len = 0;
 
-      if ((ieee->current_network.mode == IEEE_G)
-		||( ieee->current_network.mode == IEEE_N_24G && ieee->pHTInfo->bCurSuppCCK)) {
+	if ((ieee->current_network.mode == IEEE_G) ||
+	   (ieee->current_network.mode == IEEE_N_24G &&
+	   ieee->pHTInfo->bCurSuppCCK)) {
 		erp_len = 3;
 		erpinfo_content = 0;
 		if (ieee->current_network.buseprotection)
 			erpinfo_content |= ERP_UseProtection;
-	}
-	else
+	} else
 		erp_len = 0;
 
 	crypt = ieee->crypt[ieee->tx_keyidx];
 	encrypt = ieee->host_encrypt && crypt && crypt->ops &&
 		((0 == strcmp(crypt->ops->name, "WEP") || wpa_ie_len));
-	if (ieee->pHTInfo->bCurrentHTSupport){
-		tmp_ht_cap_buf =(u8*) &(ieee->pHTInfo->SelfHTCap);
+	if (ieee->pHTInfo->bCurrentHTSupport) {
+		tmp_ht_cap_buf = (u8 *) &(ieee->pHTInfo->SelfHTCap);
 		tmp_ht_cap_len = sizeof(ieee->pHTInfo->SelfHTCap);
-		tmp_ht_info_buf =(u8*) &(ieee->pHTInfo->SelfHTInfo);
+		tmp_ht_info_buf = (u8 *) &(ieee->pHTInfo->SelfHTInfo);
 		tmp_ht_info_len = sizeof(ieee->pHTInfo->SelfHTInfo);
-		HTConstructCapabilityElement(ieee, tmp_ht_cap_buf, &tmp_ht_cap_len,encrypt, false);
-		HTConstructInfoElement(ieee,tmp_ht_info_buf,&tmp_ht_info_len, encrypt);
+		HTConstructCapabilityElement(ieee, tmp_ht_cap_buf,
+					     &tmp_ht_cap_len, encrypt, false);
+		HTConstructInfoElement(ieee, tmp_ht_info_buf, &tmp_ht_info_len,
+				       encrypt);
 
-
-		if (pHTInfo->bRegRT2RTAggregation)
-		{
+		if (pHTInfo->bRegRT2RTAggregation) {
 			tmp_generic_ie_buf = ieee->pHTInfo->szRT2RTAggBuffer;
-			tmp_generic_ie_len = sizeof(ieee->pHTInfo->szRT2RTAggBuffer);
-			HTConstructRT2RTAggElement(ieee, tmp_generic_ie_buf, &tmp_generic_ie_len);
+			tmp_generic_ie_len =
+				 sizeof(ieee->pHTInfo->szRT2RTAggBuffer);
+			HTConstructRT2RTAggElement(ieee, tmp_generic_ie_buf,
+						   &tmp_generic_ie_len);
 		}
 	}
 
 	beacon_size = sizeof(struct rtllib_probe_response)+2+
-		ssid_len
-		+3
-		+rate_len
-		+rate_ex_len
-		+atim_len
-		+erp_len
-		+wpa_ie_len
-		+ieee->tx_headroom;
+		ssid_len + 3 + rate_len + rate_ex_len + atim_len + erp_len
+		+ wpa_ie_len + ieee->tx_headroom;
 	skb = dev_alloc_skb(beacon_size);
 	if (!skb)
 		return NULL;
 
 	skb_reserve(skb, ieee->tx_headroom);
 
-	beacon_buf = (struct rtllib_probe_response*) skb_put(skb, (beacon_size - ieee->tx_headroom));
-	memcpy (beacon_buf->header.addr1, dest,ETH_ALEN);
-	memcpy (beacon_buf->header.addr2, ieee->dev->dev_addr, ETH_ALEN);
-	memcpy (beacon_buf->header.addr3, ieee->current_network.bssid, ETH_ALEN);
+	beacon_buf = (struct rtllib_probe_response *) skb_put(skb,
+		     (beacon_size - ieee->tx_headroom));
+	memcpy(beacon_buf->header.addr1, dest, ETH_ALEN);
+	memcpy(beacon_buf->header.addr2, ieee->dev->dev_addr, ETH_ALEN);
+	memcpy(beacon_buf->header.addr3, ieee->current_network.bssid, ETH_ALEN);
 
 	beacon_buf->header.duration_id = 0;
 	beacon_buf->beacon_interval =
 		cpu_to_le16(ieee->current_network.beacon_interval);
 	beacon_buf->capability =
-		cpu_to_le16(ieee->current_network.capability & WLAN_CAPABILITY_IBSS);
+		cpu_to_le16(ieee->current_network.capability &
+		WLAN_CAPABILITY_IBSS);
 	beacon_buf->capability |=
-		cpu_to_le16(ieee->current_network.capability & WLAN_CAPABILITY_SHORT_PREAMBLE);
+		cpu_to_le16(ieee->current_network.capability &
+		WLAN_CAPABILITY_SHORT_PREAMBLE);
 
-	if (ieee->short_slot && (ieee->current_network.capability & WLAN_CAPABILITY_SHORT_SLOT_TIME))
-		cpu_to_le16((beacon_buf->capability |= WLAN_CAPABILITY_SHORT_SLOT_TIME));
+	if (ieee->short_slot && (ieee->current_network.capability &
+	    WLAN_CAPABILITY_SHORT_SLOT_TIME))
+		cpu_to_le16((beacon_buf->capability |=
+				 WLAN_CAPABILITY_SHORT_SLOT_TIME));
 
 	crypt = ieee->crypt[ieee->tx_keyidx];
 	if (encrypt)
@@ -966,7 +953,7 @@ static struct sk_buff* rtllib_probe_resp(struct rtllib_device *ieee, u8 *dest)
 	beacon_buf->info_element[0].id = MFIE_TYPE_SSID;
 	beacon_buf->info_element[0].len = ssid_len;
 
-	tag = (u8*) beacon_buf->info_element[0].data;
+	tag = (u8 *) beacon_buf->info_element[0].data;
 
 	memcpy(tag, ssid, ssid_len);
 
@@ -974,58 +961,55 @@ static struct sk_buff* rtllib_probe_resp(struct rtllib_device *ieee, u8 *dest)
 
 	*(tag++) = MFIE_TYPE_RATES;
 	*(tag++) = rate_len-2;
-	memcpy(tag,ieee->current_network.rates,rate_len-2);
-	tag+=rate_len-2;
+	memcpy(tag, ieee->current_network.rates, rate_len-2);
+	tag += rate_len-2;
 
 	*(tag++) = MFIE_TYPE_DS_SET;
 	*(tag++) = 1;
 	*(tag++) = ieee->current_network.channel;
 
-	if (atim_len){
-	u16 val16;
+	if (atim_len) {
+		u16 val16;
 		*(tag++) = MFIE_TYPE_IBSS_SET;
 		*(tag++) = 2;
 		 val16 = cpu_to_le16(ieee->current_network.atim_window);
 		memcpy((u8 *)tag, (u8 *)&val16, 2);
-		tag+=2;
+		tag += 2;
 	}
 
-	if (erp_len){
+	if (erp_len) {
 		*(tag++) = MFIE_TYPE_ERP;
 		*(tag++) = 1;
 		*(tag++) = erpinfo_content;
 	}
-	if (rate_ex_len){
+	if (rate_ex_len) {
 		*(tag++) = MFIE_TYPE_RATES_EX;
 		*(tag++) = rate_ex_len-2;
-		memcpy(tag,ieee->current_network.rates_ex,rate_ex_len-2);
-		tag+=rate_ex_len-2;
+		memcpy(tag, ieee->current_network.rates_ex, rate_ex_len-2);
+		tag += rate_ex_len-2;
 	}
 
-	if (wpa_ie_len)
-	{
+	if (wpa_ie_len) {
 		if (ieee->iw_mode == IW_MODE_ADHOC)
-		{
 			memcpy(&ieee->wpa_ie[14], &ieee->wpa_ie[8], 4);
-		}
 		memcpy(tag, ieee->wpa_ie, ieee->wpa_ie_len);
 		tag += ieee->wpa_ie_len;
 	}
-
 	return skb;
 }
 
-struct sk_buff* rtllib_assoc_resp(struct rtllib_device *ieee, u8 *dest)
+struct sk_buff *rtllib_assoc_resp(struct rtllib_device *ieee, u8 *dest)
 {
 	struct sk_buff *skb;
-	u8* tag;
+	u8 *tag;
 
-	struct rtllib_crypt_data* crypt;
+	struct rtllib_crypt_data *crypt;
 	struct rtllib_assoc_response_frame *assoc;
 	short encrypt;
 
 	unsigned int rate_len = rtllib_MFIE_rate_len(ieee);
-	int len = sizeof(struct rtllib_assoc_response_frame) + rate_len + ieee->tx_headroom;
+	int len = sizeof(struct rtllib_assoc_response_frame) + rate_len +
+		  ieee->tx_headroom;
 
 	skb = dev_alloc_skb(len);
 
@@ -1035,10 +1019,10 @@ struct sk_buff* rtllib_assoc_resp(struct rtllib_device *ieee, u8 *dest)
 	skb_reserve(skb, ieee->tx_headroom);
 
 	assoc = (struct rtllib_assoc_response_frame *)
-		skb_put(skb,sizeof(struct rtllib_assoc_response_frame));
+		skb_put(skb, sizeof(struct rtllib_assoc_response_frame));
 
 	assoc->header.frame_ctl = cpu_to_le16(RTLLIB_STYPE_ASSOC_RESP);
-	memcpy(assoc->header.addr1, dest,ETH_ALEN);
+	memcpy(assoc->header.addr1, dest, ETH_ALEN);
 	memcpy(assoc->header.addr3, ieee->dev->dev_addr, ETH_ALEN);
 	memcpy(assoc->header.addr2, ieee->dev->dev_addr, ETH_ALEN);
 	assoc->capability = cpu_to_le16(ieee->iw_mode == IW_MODE_MASTER ?
@@ -1046,14 +1030,15 @@ struct sk_buff* rtllib_assoc_resp(struct rtllib_device *ieee, u8 *dest)
 
 
 	if (ieee->short_slot)
-		assoc->capability |= cpu_to_le16(WLAN_CAPABILITY_SHORT_SLOT_TIME);
+		assoc->capability |=
+				 cpu_to_le16(WLAN_CAPABILITY_SHORT_SLOT_TIME);
 
 	if (ieee->host_encrypt)
 		crypt = ieee->crypt[ieee->tx_keyidx];
 	else
 		crypt = NULL;
 
-	encrypt = ( crypt && crypt->ops);
+	encrypt = (crypt && crypt->ops);
 
 	if (encrypt)
 		assoc->capability |= cpu_to_le16(WLAN_CAPABILITY_PRIVACY);
@@ -1061,22 +1046,23 @@ struct sk_buff* rtllib_assoc_resp(struct rtllib_device *ieee, u8 *dest)
 	assoc->status = 0;
 	assoc->aid = cpu_to_le16(ieee->assoc_id);
 	if (ieee->assoc_id == 0x2007)
-		ieee->assoc_id=0;
+		ieee->assoc_id = 0;
 	else
 		ieee->assoc_id++;
 
-	tag = (u8*) skb_put(skb, rate_len);
+	tag = (u8 *) skb_put(skb, rate_len);
 	rtllib_MFIE_Brate(ieee, &tag);
 	rtllib_MFIE_Grate(ieee, &tag);
 
 	return skb;
 }
 
-struct sk_buff* rtllib_auth_resp(struct rtllib_device *ieee,int status, u8 *dest)
+struct sk_buff *rtllib_auth_resp(struct rtllib_device *ieee, int status,
+				 u8 *dest)
 {
 	struct sk_buff *skb = NULL;
 	struct rtllib_authentication *auth;
-	int len = ieee->tx_headroom + sizeof(struct rtllib_authentication)+1;
+	int len = ieee->tx_headroom + sizeof(struct rtllib_authentication) + 1;
 	skb = dev_alloc_skb(len);
 	if (!skb)
 		return NULL;
@@ -1101,10 +1087,10 @@ struct sk_buff* rtllib_auth_resp(struct rtllib_device *ieee,int status, u8 *dest
 
 }
 
-struct sk_buff* rtllib_null_func(struct rtllib_device *ieee,short pwr)
+struct sk_buff *rtllib_null_func(struct rtllib_device *ieee, short pwr)
 {
 	struct sk_buff *skb;
-	struct rtllib_hdr_3addr* hdr;
+	struct rtllib_hdr_3addr *hdr;
 
 	skb = dev_alloc_skb(sizeof(struct rtllib_hdr_3addr)+ieee->tx_headroom);
 	if (!skb)
@@ -1112,7 +1098,8 @@ struct sk_buff* rtllib_null_func(struct rtllib_device *ieee,short pwr)
 
 	skb_reserve(skb, ieee->tx_headroom);
 
-	hdr = (struct rtllib_hdr_3addr*)skb_put(skb,sizeof(struct rtllib_hdr_3addr));
+	hdr = (struct rtllib_hdr_3addr *)skb_put(skb,
+	      sizeof(struct rtllib_hdr_3addr));
 
 	memcpy(hdr->addr1, ieee->current_network.bssid, ETH_ALEN);
 	memcpy(hdr->addr2, ieee->dev->dev_addr, ETH_ALEN);
@@ -1120,17 +1107,17 @@ struct sk_buff* rtllib_null_func(struct rtllib_device *ieee,short pwr)
 
 	hdr->frame_ctl = cpu_to_le16(RTLLIB_FTYPE_DATA |
 		RTLLIB_STYPE_NULLFUNC | RTLLIB_FCTL_TODS |
-		(pwr ? RTLLIB_FCTL_PM:0));
+		(pwr ? RTLLIB_FCTL_PM : 0));
 
 	return skb;
 
 
 }
 
-struct sk_buff* rtllib_pspoll_func(struct rtllib_device *ieee)
+struct sk_buff *rtllib_pspoll_func(struct rtllib_device *ieee)
 {
 	struct sk_buff *skb;
-	struct rtllib_pspoll_hdr* hdr;
+	struct rtllib_pspoll_hdr *hdr;
 
 	skb = dev_alloc_skb(sizeof(struct rtllib_pspoll_hdr)+ieee->tx_headroom);
 	if (!skb)
@@ -1138,19 +1125,21 @@ struct sk_buff* rtllib_pspoll_func(struct rtllib_device *ieee)
 
 	skb_reserve(skb, ieee->tx_headroom);
 
-	hdr = (struct rtllib_pspoll_hdr*)skb_put(skb,sizeof(struct rtllib_pspoll_hdr));
+	hdr = (struct rtllib_pspoll_hdr *)skb_put(skb,
+	      sizeof(struct rtllib_pspoll_hdr));
 
 	memcpy(hdr->bssid, ieee->current_network.bssid, ETH_ALEN);
 	memcpy(hdr->ta, ieee->dev->dev_addr, ETH_ALEN);
 
 	hdr->aid = cpu_to_le16(ieee->assoc_id | 0xc000);
-	hdr->frame_ctl = cpu_to_le16(RTLLIB_FTYPE_CTL |RTLLIB_STYPE_PSPOLL | RTLLIB_FCTL_PM);
+	hdr->frame_ctl = cpu_to_le16(RTLLIB_FTYPE_CTL | RTLLIB_STYPE_PSPOLL |
+			 RTLLIB_FCTL_PM);
 
 	return skb;
 
 }
 
-void rtllib_resp_to_assoc_rq(struct rtllib_device *ieee, u8* dest)
+void rtllib_resp_to_assoc_rq(struct rtllib_device *ieee, u8 *dest)
 {
 	struct sk_buff *buf = rtllib_assoc_resp(ieee, dest);
 
@@ -1159,7 +1148,7 @@ void rtllib_resp_to_assoc_rq(struct rtllib_device *ieee, u8* dest)
 }
 
 
-void rtllib_resp_to_auth(struct rtllib_device *ieee, int s, u8* dest)
+void rtllib_resp_to_auth(struct rtllib_device *ieee, int s, u8 *dest)
 {
 	struct sk_buff *buf = rtllib_auth_resp(ieee, s, dest);
 
@@ -1181,110 +1170,98 @@ inline int SecIsInPMKIDList(struct rtllib_device *ieee, u8 *bssid)
 {
 	int i = 0;
 
-	do
-	{
-		if ((ieee->PMKIDList[i].bUsed) && (memcmp(ieee->PMKIDList[i].Bssid, bssid, ETH_ALEN) == 0))
-		{
+	do {
+		if ((ieee->PMKIDList[i].bUsed) &&
+		   (memcmp(ieee->PMKIDList[i].Bssid, bssid, ETH_ALEN) == 0))
 			break;
-		}
 		else
-		{
 			i++;
-		}
 	} while (i < NUM_PMKID_CACHE);
 
 	if (i == NUM_PMKID_CACHE)
-	{
 		i = -1;
-	}
-	else
-	{
-	}
-
-	return (i);
-
+	return i;
 }
 
-
-inline struct sk_buff *rtllib_association_req(struct rtllib_network *beacon,struct rtllib_device *ieee)
+inline struct sk_buff *rtllib_association_req(struct rtllib_network *beacon,
+					      struct rtllib_device *ieee)
 {
 	struct sk_buff *skb;
-
 	struct rtllib_assoc_request_frame *hdr;
 	u8 *tag, *ies;
 	int i;
-	u8* ht_cap_buf = NULL;
-	u8 ht_cap_len=0;
-	u8* realtek_ie_buf=NULL;
-	u8 realtek_ie_len=0;
-	int wpa_ie_len= ieee->wpa_ie_len;
+	u8 *ht_cap_buf = NULL;
+	u8 ht_cap_len = 0;
+	u8 *realtek_ie_buf = NULL;
+	u8 realtek_ie_len = 0;
+	int wpa_ie_len = ieee->wpa_ie_len;
 	int wps_ie_len = ieee->wps_ie_len;
-	unsigned int ckip_ie_len=0;
-	unsigned int ccxrm_ie_len=0;
-	unsigned int cxvernum_ie_len=0;
-	struct rtllib_crypt_data* crypt;
+	unsigned int ckip_ie_len = 0;
+	unsigned int ccxrm_ie_len = 0;
+	unsigned int cxvernum_ie_len = 0;
+	struct rtllib_crypt_data *crypt;
 	int encrypt;
 	int	PMKCacheIdx;
 
-	unsigned int rate_len = (beacon->rates_len?(beacon->rates_len+2):0) + (beacon->rates_ex_len?(beacon->rates_ex_len)+2:0);
+	unsigned int rate_len = (beacon->rates_len ?
+				(beacon->rates_len + 2) : 0) +
+				(beacon->rates_ex_len ? (beacon->rates_ex_len) +
+				2 : 0);
 
-	unsigned int wmm_info_len = beacon->qos_data.supported?9:0;
-	unsigned int turbo_info_len = beacon->Turbo_Enable?9:0;
+	unsigned int wmm_info_len = beacon->qos_data.supported ? 9 : 0;
+	unsigned int turbo_info_len = beacon->Turbo_Enable ? 9 : 0;
 
 	int len = 0;
 	crypt = ieee->crypt[ieee->tx_keyidx];
-	if (crypt != NULL) {
-		encrypt = ieee->host_encrypt && crypt && crypt->ops && ((0 == strcmp(crypt->ops->name,"WEP") || wpa_ie_len));
-	} else {
+	if (crypt != NULL)
+		encrypt = ieee->host_encrypt && crypt && crypt->ops &&
+			  ((0 == strcmp(crypt->ops->name, "WEP") ||
+			  wpa_ie_len));
+	else
 		encrypt = 0;
-	}
 
-	if ((ieee->rtllib_ap_sec_type && (ieee->rtllib_ap_sec_type(ieee)&SEC_ALG_TKIP)) ||(ieee->bForcedBgMode == true))
-	{
+	if ((ieee->rtllib_ap_sec_type &&
+	    (ieee->rtllib_ap_sec_type(ieee) & SEC_ALG_TKIP)) ||
+	    (ieee->bForcedBgMode == true)) {
 		ieee->pHTInfo->bEnableHT = 0;
 		ieee->mode = WIRELESS_MODE_G;
 	}
 
-	if (ieee->pHTInfo->bCurrentHTSupport&&ieee->pHTInfo->bEnableHT)
-	{
-		ht_cap_buf = (u8*)&(ieee->pHTInfo->SelfHTCap);
+	if (ieee->pHTInfo->bCurrentHTSupport && ieee->pHTInfo->bEnableHT) {
+		ht_cap_buf = (u8 *)&(ieee->pHTInfo->SelfHTCap);
 		ht_cap_len = sizeof(ieee->pHTInfo->SelfHTCap);
-		HTConstructCapabilityElement(ieee, ht_cap_buf, &ht_cap_len, encrypt, true);
+		HTConstructCapabilityElement(ieee, ht_cap_buf, &ht_cap_len,
+					     encrypt, true);
 		if (ieee->pHTInfo->bCurrentRT2RTAggregation) {
 			realtek_ie_buf = ieee->pHTInfo->szRT2RTAggBuffer;
-			realtek_ie_len = sizeof( ieee->pHTInfo->szRT2RTAggBuffer);
-			HTConstructRT2RTAggElement(ieee, realtek_ie_buf, &realtek_ie_len);
-
+			realtek_ie_len =
+				 sizeof(ieee->pHTInfo->szRT2RTAggBuffer);
+			HTConstructRT2RTAggElement(ieee, realtek_ie_buf,
+						   &realtek_ie_len);
 		}
 	}
 
 	if (beacon->bCkipSupported)
-	{
 		ckip_ie_len = 30+2;
-	}
 	if (beacon->bCcxRmEnable)
-	{
 		ccxrm_ie_len = 6+2;
-	}
-	if ( beacon->BssCcxVerNumber >= 2 )
-	{
+	if (beacon->BssCcxVerNumber >= 2)
 		cxvernum_ie_len = 5+2;
-	}
 
 	PMKCacheIdx = SecIsInPMKIDList(ieee, ieee->current_network.bssid);
-	if (PMKCacheIdx >= 0)
-	{
+	if (PMKCacheIdx >= 0) {
 		wpa_ie_len += 18;
-		printk("[PMK cache]: WPA2 IE length: %x\n", wpa_ie_len);
+		printk(KERN_INFO "[PMK cache]: WPA2 IE length: %x\n",
+		       wpa_ie_len);
 	}
-	len = sizeof(struct rtllib_assoc_request_frame)+ 2
+	len = sizeof(struct rtllib_assoc_request_frame) + 2
 		+ beacon->ssid_len
 		+ rate_len
 		+ wpa_ie_len
 		+ wps_ie_len
 		+ wmm_info_len
 		+ turbo_info_len
-                + ht_cap_len
+		+ ht_cap_len
 		+ realtek_ie_len
 		+ ckip_ie_len
 		+ ccxrm_ie_len
@@ -1299,11 +1276,11 @@ inline struct sk_buff *rtllib_association_req(struct rtllib_network *beacon,stru
 	skb_reserve(skb, ieee->tx_headroom);
 
 	hdr = (struct rtllib_assoc_request_frame *)
-		skb_put(skb, sizeof(struct rtllib_assoc_request_frame)+2);
+		skb_put(skb, sizeof(struct rtllib_assoc_request_frame) + 2);
 
 
 	hdr->header.frame_ctl = RTLLIB_STYPE_ASSOC_REQ;
-	hdr->header.duration_id= 37;
+	hdr->header.duration_id = 37;
 	memcpy(hdr->header.addr1, beacon->bssid, ETH_ALEN);
 	memcpy(hdr->header.addr2, ieee->dev->dev_addr, ETH_ALEN);
 	memcpy(hdr->header.addr3, beacon->bssid, ETH_ALEN);
@@ -1311,13 +1288,14 @@ inline struct sk_buff *rtllib_association_req(struct rtllib_network *beacon,stru
 	memcpy(ieee->ap_mac_addr, beacon->bssid, ETH_ALEN);
 
 	hdr->capability = cpu_to_le16(WLAN_CAPABILITY_ESS);
-	if (beacon->capability & WLAN_CAPABILITY_PRIVACY )
+	if (beacon->capability & WLAN_CAPABILITY_PRIVACY)
 		hdr->capability |= cpu_to_le16(WLAN_CAPABILITY_PRIVACY);
 
 	if (beacon->capability & WLAN_CAPABILITY_SHORT_PREAMBLE)
 		hdr->capability |= cpu_to_le16(WLAN_CAPABILITY_SHORT_PREAMBLE);
 
-	if (ieee->short_slot && (beacon->capability&WLAN_CAPABILITY_SHORT_SLOT_TIME))
+	if (ieee->short_slot &&
+	   (beacon->capability&WLAN_CAPABILITY_SHORT_SLOT_TIME))
 		hdr->capability |= cpu_to_le16(WLAN_CAPABILITY_SHORT_SLOT_TIME);
 
 
@@ -1331,94 +1309,89 @@ inline struct sk_buff *rtllib_association_req(struct rtllib_network *beacon,stru
 
 	tag = skb_put(skb, rate_len);
 
-	if (beacon->rates_len){
+	if (beacon->rates_len) {
 		*tag++ = MFIE_TYPE_RATES;
 		*tag++ = beacon->rates_len;
-		for (i=0;i<beacon->rates_len;i++){
+		for (i = 0; i < beacon->rates_len; i++)
 			*tag++ = beacon->rates[i];
-		}
 	}
 
-	if (beacon->rates_ex_len){
+	if (beacon->rates_ex_len) {
 		*tag++ = MFIE_TYPE_RATES_EX;
 		*tag++ = beacon->rates_ex_len;
-		for (i=0;i<beacon->rates_ex_len;i++){
+		for (i = 0; i < beacon->rates_ex_len; i++)
 			*tag++ = beacon->rates_ex[i];
-		}
 	}
 
-	if ( beacon->bCkipSupported )
-	{
+	if (beacon->bCkipSupported) {
 		static u8	AironetIeOui[] = {0x00, 0x01, 0x66};
 		u8	CcxAironetBuf[30];
 		struct octet_string osCcxAironetIE;
 
-		memset(CcxAironetBuf, 0,30);
+		memset(CcxAironetBuf, 0, 30);
 		osCcxAironetIE.Octet = CcxAironetBuf;
 		osCcxAironetIE.Length = sizeof(CcxAironetBuf);
-		memcpy(osCcxAironetIE.Octet, AironetIeOui, sizeof(AironetIeOui));
+		memcpy(osCcxAironetIE.Octet, AironetIeOui,
+		       sizeof(AironetIeOui));
 
-		osCcxAironetIE.Octet[IE_CISCO_FLAG_POSITION] |=  (SUPPORT_CKIP_PK|SUPPORT_CKIP_MIC) ;
+		osCcxAironetIE.Octet[IE_CISCO_FLAG_POSITION] |=
+					 (SUPPORT_CKIP_PK|SUPPORT_CKIP_MIC);
 		tag = skb_put(skb, ckip_ie_len);
 		*tag++ = MFIE_TYPE_AIRONET;
 		*tag++ = osCcxAironetIE.Length;
-		memcpy(tag,osCcxAironetIE.Octet,osCcxAironetIE.Length);
+		memcpy(tag, osCcxAironetIE.Octet, osCcxAironetIE.Length);
 		tag += osCcxAironetIE.Length;
 	}
 
-	if (beacon->bCcxRmEnable)
-	{
+	if (beacon->bCcxRmEnable) {
 		static u8 CcxRmCapBuf[] = {0x00, 0x40, 0x96, 0x01, 0x01, 0x00};
 		struct octet_string osCcxRmCap;
 
 		osCcxRmCap.Octet = CcxRmCapBuf;
 		osCcxRmCap.Length = sizeof(CcxRmCapBuf);
-		tag = skb_put(skb,ccxrm_ie_len);
+		tag = skb_put(skb, ccxrm_ie_len);
 		*tag++ = MFIE_TYPE_GENERIC;
 		*tag++ = osCcxRmCap.Length;
-		memcpy(tag,osCcxRmCap.Octet,osCcxRmCap.Length);
+		memcpy(tag, osCcxRmCap.Octet, osCcxRmCap.Length);
 		tag += osCcxRmCap.Length;
 	}
 
-	if ( beacon->BssCcxVerNumber >= 2 )
-	{
-		u8			CcxVerNumBuf[] = {0x00, 0x40, 0x96, 0x03, 0x00};
+	if (beacon->BssCcxVerNumber >= 2) {
+		u8 CcxVerNumBuf[] = {0x00, 0x40, 0x96, 0x03, 0x00};
 		struct octet_string osCcxVerNum;
 		CcxVerNumBuf[4] = beacon->BssCcxVerNumber;
 		osCcxVerNum.Octet = CcxVerNumBuf;
 		osCcxVerNum.Length = sizeof(CcxVerNumBuf);
-		tag = skb_put(skb,cxvernum_ie_len);
+		tag = skb_put(skb, cxvernum_ie_len);
 		*tag++ = MFIE_TYPE_GENERIC;
 		*tag++ = osCcxVerNum.Length;
-		memcpy(tag,osCcxVerNum.Octet,osCcxVerNum.Length);
+		memcpy(tag, osCcxVerNum.Octet, osCcxVerNum.Length);
 		tag += osCcxVerNum.Length;
 	}
-	if (ieee->pHTInfo->bCurrentHTSupport&&ieee->pHTInfo->bEnableHT){
-		if (ieee->pHTInfo->ePeerHTSpecVer != HT_SPEC_VER_EWC)
-		{
+	if (ieee->pHTInfo->bCurrentHTSupport && ieee->pHTInfo->bEnableHT) {
+		if (ieee->pHTInfo->ePeerHTSpecVer != HT_SPEC_VER_EWC) {
 			tag = skb_put(skb, ht_cap_len);
 			*tag++ = MFIE_TYPE_HT_CAP;
 			*tag++ = ht_cap_len - 2;
-			memcpy(tag, ht_cap_buf,ht_cap_len -2);
-			tag += ht_cap_len -2;
+			memcpy(tag, ht_cap_buf, ht_cap_len - 2);
+			tag += ht_cap_len - 2;
 		}
 	}
 
-
-	if (wpa_ie_len){
+	if (wpa_ie_len) {
 		tag = skb_put(skb, ieee->wpa_ie_len);
 		memcpy(tag, ieee->wpa_ie, ieee->wpa_ie_len);
 
-		if (PMKCacheIdx >= 0)
-		{
+		if (PMKCacheIdx >= 0) {
 			tag = skb_put(skb, 18);
 			*tag = 1;
 			*(tag + 1) = 0;
-			memcpy((tag + 2), &ieee->PMKIDList[PMKCacheIdx].PMKID, 16);
+			memcpy((tag + 2), &ieee->PMKIDList[PMKCacheIdx].PMKID,
+			       16);
 		}
 	}
 	if (wmm_info_len) {
-		tag = skb_put(skb,wmm_info_len);
+		tag = skb_put(skb, wmm_info_len);
 		rtllib_WMM_Info(ieee, &tag);
 	}
 
@@ -1427,42 +1400,39 @@ inline struct sk_buff *rtllib_association_req(struct rtllib_network *beacon,stru
 		memcpy(tag, ieee->wps_ie, wps_ie_len);
 	}
 
-	tag = skb_put(skb,turbo_info_len);
-        if (turbo_info_len)
-                rtllib_TURBO_Info(ieee, &tag);
+	tag = skb_put(skb, turbo_info_len);
+	if (turbo_info_len)
+		rtllib_TURBO_Info(ieee, &tag);
 
-	if (ieee->pHTInfo->bCurrentHTSupport&&ieee->pHTInfo->bEnableHT){
-		if (ieee->pHTInfo->ePeerHTSpecVer == HT_SPEC_VER_EWC)
-		{
+	if (ieee->pHTInfo->bCurrentHTSupport && ieee->pHTInfo->bEnableHT) {
+		if (ieee->pHTInfo->ePeerHTSpecVer == HT_SPEC_VER_EWC) {
 			tag = skb_put(skb, ht_cap_len);
 			*tag++ = MFIE_TYPE_GENERIC;
 			*tag++ = ht_cap_len - 2;
-			memcpy(tag, ht_cap_buf,ht_cap_len - 2);
-			tag += ht_cap_len -2;
+			memcpy(tag, ht_cap_buf, ht_cap_len - 2);
+			tag += ht_cap_len - 2;
 		}
 
-		if (ieee->pHTInfo->bCurrentRT2RTAggregation){
+		if (ieee->pHTInfo->bCurrentRT2RTAggregation) {
 			tag = skb_put(skb, realtek_ie_len);
 			*tag++ = MFIE_TYPE_GENERIC;
 			*tag++ = realtek_ie_len - 2;
-			memcpy(tag, realtek_ie_buf,realtek_ie_len -2 );
+			memcpy(tag, realtek_ie_buf, realtek_ie_len - 2);
 		}
 	}
 
-	if (ieee->assocreq_ies){
-		kfree(ieee->assocreq_ies);
-		ieee->assocreq_ies = NULL;
-	}
+	kfree(ieee->assocreq_ies);
+	ieee->assocreq_ies = NULL;
 	ies = &(hdr->info_element[0].id);
 	ieee->assocreq_ies_len = (skb->data + skb->len) - ies;
 	ieee->assocreq_ies = kmalloc(ieee->assocreq_ies_len, GFP_ATOMIC);
 	if (ieee->assocreq_ies)
 		memcpy(ieee->assocreq_ies, ies, ieee->assocreq_ies_len);
-	else{
-		printk("%s()Warning: can't alloc memory for assocreq_ies\n", __func__);
+	else {
+		printk(KERN_INFO "%s()Warning: can't alloc memory for assocreq"
+		       "_ies\n", __func__);
 		ieee->assocreq_ies_len = 0;
 	}
-
 	return skb;
 }
 
@@ -1480,18 +1450,18 @@ void rtllib_associate_abort(struct rtllib_device *ieee)
 	 * Here we will check if there are good nets to associate
 	 * with, so we retry or just get back to NO_LINK and scanning
 	 */
-	if (ieee->state == RTLLIB_ASSOCIATING_AUTHENTICATING){
+	if (ieee->state == RTLLIB_ASSOCIATING_AUTHENTICATING) {
 		RTLLIB_DEBUG_MGMT("Authentication failed\n");
 		ieee->softmac_stats.no_auth_rs++;
-	}else{
+	} else {
 		RTLLIB_DEBUG_MGMT("Association failed\n");
 		ieee->softmac_stats.no_ass_rs++;
 	}
 
 	ieee->state = RTLLIB_ASSOCIATING_RETRY;
 
-	queue_delayed_work_rsl(ieee->wq, &ieee->associate_retry_wq, \
-                           RTLLIB_SOFTMAC_ASSOC_RETRY_TIME);
+	queue_delayed_work_rsl(ieee->wq, &ieee->associate_retry_wq,
+			   RTLLIB_SOFTMAC_ASSOC_RETRY_TIME);
 
 	spin_unlock_irqrestore(&ieee->lock, flags);
 }
@@ -1501,7 +1471,7 @@ void rtllib_associate_abort_cb(unsigned long dev)
 	rtllib_associate_abort((struct rtllib_device *) dev);
 }
 
-void rtllib_associate_step1(struct rtllib_device *ieee,u8 * daddr)
+void rtllib_associate_step1(struct rtllib_device *ieee, u8 * daddr)
 {
 	struct rtllib_network *beacon = &ieee->current_network;
 	struct sk_buff *skb;
@@ -1510,15 +1480,15 @@ void rtllib_associate_step1(struct rtllib_device *ieee,u8 * daddr)
 
 	ieee->softmac_stats.tx_auth_rq++;
 
-	skb=rtllib_authentication_req(beacon, ieee, 0,daddr);
+	skb = rtllib_authentication_req(beacon, ieee, 0, daddr);
 
 	if (!skb)
 		rtllib_associate_abort(ieee);
-	else{
+	else {
 		ieee->state = RTLLIB_ASSOCIATING_AUTHENTICATING ;
 		RTLLIB_DEBUG_MGMT("Sending authentication request\n");
 		softmac_mgmt_xmit(skb, ieee);
-		if (!timer_pending(&ieee->associate_timer)){
+		if (!timer_pending(&ieee->associate_timer)) {
 			ieee->associate_timer.expires = jiffies + (HZ / 2);
 			add_timer(&ieee->associate_timer);
 		}
@@ -1534,19 +1504,21 @@ void rtllib_auth_challenge(struct rtllib_device *ieee, u8 *challenge, int chlen)
 	ieee->associate_seq++;
 	ieee->softmac_stats.tx_auth_rq++;
 
-	skb = rtllib_authentication_req(beacon, ieee, chlen+2,beacon->bssid);
+	skb = rtllib_authentication_req(beacon, ieee, chlen + 2, beacon->bssid);
 
 	if (!skb)
 		rtllib_associate_abort(ieee);
-	else{
+	else {
 		c = skb_put(skb, chlen+2);
 		*(c++) = MFIE_TYPE_CHALLENGE;
 		*(c++) = chlen;
 		memcpy(c, challenge, chlen);
 
-		RTLLIB_DEBUG_MGMT("Sending authentication challenge response\n");
+		RTLLIB_DEBUG_MGMT("Sending authentication challenge "
+				  "response\n");
 
-		rtllib_encrypt_fragment(ieee, skb, sizeof(struct rtllib_hdr_3addr  ));
+		rtllib_encrypt_fragment(ieee, skb,
+					sizeof(struct rtllib_hdr_3addr));
 
 		softmac_mgmt_xmit(skb, ieee);
 		mod_timer(&ieee->associate_timer, jiffies + (HZ/2));
@@ -1556,7 +1528,7 @@ void rtllib_auth_challenge(struct rtllib_device *ieee, u8 *challenge, int chlen)
 
 void rtllib_associate_step2(struct rtllib_device *ieee)
 {
-	struct sk_buff* skb;
+	struct sk_buff *skb;
 	struct rtllib_network *beacon = &ieee->current_network;
 
 	del_timer_sync(&ieee->associate_timer);
@@ -1564,10 +1536,10 @@ void rtllib_associate_step2(struct rtllib_device *ieee)
 	RTLLIB_DEBUG_MGMT("Sending association request\n");
 
 	ieee->softmac_stats.tx_ass_rq++;
-	skb=rtllib_association_req(beacon, ieee);
+	skb = rtllib_association_req(beacon, ieee);
 	if (!skb)
 		rtllib_associate_abort(ieee);
-	else{
+	else {
 		softmac_mgmt_xmit(skb, ieee);
 		mod_timer(&ieee->associate_timer, jiffies + (HZ/2));
 	}
@@ -1576,48 +1548,54 @@ void rtllib_associate_step2(struct rtllib_device *ieee)
 #define CANCELLED  2
 void rtllib_associate_complete_wq(void *data)
 {
-	struct rtllib_device *ieee = (struct rtllib_device *)container_of_work_rsl(data, struct rtllib_device, associate_complete_wq);
-	struct rt_pwr_save_ctrl *pPSC = (struct rt_pwr_save_ctrl *)(&(ieee->PowerSaveControl));
+	struct rtllib_device *ieee = (struct rtllib_device *)
+				     container_of_work_rsl(data,
+				     struct rtllib_device,
+				     associate_complete_wq);
+	struct rt_pwr_save_ctrl *pPSC = (struct rt_pwr_save_ctrl *)
+					(&(ieee->PowerSaveControl));
 	printk(KERN_INFO "Associated successfully\n");
-	if (ieee->is_silent_reset == 0){
-            printk("normal associate\n");
-            notify_wx_assoc_event(ieee);
-        }
+	if (ieee->is_silent_reset == 0) {
+		printk(KERN_INFO "normal associate\n");
+		notify_wx_assoc_event(ieee);
+	}
 
 	netif_carrier_on(ieee->dev);
 	ieee->is_roaming = false;
 	if (rtllib_is_54g(&ieee->current_network) &&
-		(ieee->modulation & RTLLIB_OFDM_MODULATION)){
-
+	   (ieee->modulation & RTLLIB_OFDM_MODULATION)) {
 		ieee->rate = 108;
 		printk(KERN_INFO"Using G rates:%d\n", ieee->rate);
-	}else{
+	} else {
 		ieee->rate = 22;
 		ieee->SetWirelessMode(ieee->dev, IEEE_B);
 		printk(KERN_INFO"Using B rates:%d\n", ieee->rate);
 	}
-	if (ieee->pHTInfo->bCurrentHTSupport&&ieee->pHTInfo->bEnableHT)
-	{
-		printk("Successfully associated, ht enabled\n");
+	if (ieee->pHTInfo->bCurrentHTSupport && ieee->pHTInfo->bEnableHT) {
+		printk(KERN_INFO "Successfully associated, ht enabled\n");
 		HTOnAssocRsp(ieee);
 	} else {
-		printk("Successfully associated, ht not enabled(%d, %d)\n",
-				ieee->pHTInfo->bCurrentHTSupport, ieee->pHTInfo->bEnableHT);
+		printk(KERN_INFO "Successfully associated, ht not "
+		       "enabled(%d, %d)\n",
+		       ieee->pHTInfo->bCurrentHTSupport,
+		       ieee->pHTInfo->bEnableHT);
 		memset(ieee->dot11HTOperationalRateSet, 0, 16);
 	}
-	ieee->LinkDetectInfo.SlotNum = 2 * (1 + ieee->current_network.beacon_interval/500);
-	if (ieee->LinkDetectInfo.NumRecvBcnInPeriod==0||ieee->LinkDetectInfo.NumRecvDataInPeriod==0 )
-	{
+	ieee->LinkDetectInfo.SlotNum = 2 * (1 +
+				       ieee->current_network.beacon_interval /
+				       500);
+	if (ieee->LinkDetectInfo.NumRecvBcnInPeriod == 0 ||
+	    ieee->LinkDetectInfo.NumRecvDataInPeriod == 0) {
 		ieee->LinkDetectInfo.NumRecvBcnInPeriod = 1;
-		ieee->LinkDetectInfo.NumRecvDataInPeriod= 1;
+		ieee->LinkDetectInfo.NumRecvDataInPeriod = 1;
 	}
 	pPSC->LpsIdleCount = 0;
 	ieee->link_change(ieee->dev);
 
-        if (ieee->is_silent_reset == 1) {
-		printk("silent reset associate\n");
+	if (ieee->is_silent_reset == 1) {
+		printk(KERN_INFO "silent reset associate\n");
 		ieee->is_silent_reset = 0;
-        }
+	}
 
 	if (ieee->data_hard_resume)
 		ieee->data_hard_resume(ieee->dev);
@@ -1626,49 +1604,6 @@ void rtllib_associate_complete_wq(void *data)
 
 static void rtllib_sta_send_associnfo(struct rtllib_device *ieee)
 {
-	char *buf;
-	size_t len;
-	int i;
-	union iwreq_data wrqu;
-
-		return;
-
-
-	buf = kmalloc(50 + 2 * (ieee->assocreq_ies_len + ieee->assocresp_ies_len), GFP_ATOMIC);
-	if (!buf)
-		return;
-
-	len = sprintf(buf, "ASSOCINFO(");
-	if (ieee->assocreq_ies) {
-		len += sprintf(buf + len, "ReqIEs=");
-		for (i = 0; i < ieee->assocreq_ies_len; i++) {
-			len += sprintf(buf + len, "%02x", ieee->assocreq_ies[i]);
-		}
-	}
-	if (ieee->assocresp_ies) {
-		if (ieee->assocreq_ies)
-			len += sprintf(buf + len, " ");
-		len += sprintf(buf + len, "RespIEs=");
-		for (i = 0; i < ieee->assocresp_ies_len; i++) {
-			len += sprintf(buf + len, "%02x", ieee->assocresp_ies[i]);
-		}
-	}
-	len += sprintf(buf + len, ")");
-
-	if (len > IW_CUSTOM_MAX) {
-		len = sprintf(buf, "ASSOCRESPIE=");
-		for (i = 0; i < ieee->assocresp_ies_len; i++) {
-			len += sprintf(buf + len, "%02x", ieee->assocresp_ies[i]);
-		}
-	}
-
-	if (len <= IW_CUSTOM_MAX) {
-		memset(&wrqu, 0, sizeof(wrqu));
-		wrqu.data.length = len;
-		wireless_send_event(ieee->dev, IWEVCUSTOM, &wrqu, buf);
-	}
-
-	kfree(buf);
 }
 
 void rtllib_associate_complete(struct rtllib_device *ieee)
@@ -1683,7 +1618,9 @@ void rtllib_associate_complete(struct rtllib_device *ieee)
 
 void rtllib_associate_procedure_wq(void *data)
 {
-	struct rtllib_device *ieee = container_of_dwork_rsl(data, struct rtllib_device, associate_procedure_wq);
+	struct rtllib_device *ieee = container_of_dwork_rsl(data,
+				     struct rtllib_device,
+				     associate_procedure_wq);
 	rtllib_stop_scan_syncro(ieee);
 	if (ieee->rtllib_ips_leave != NULL)
 		ieee->rtllib_ips_leave(ieee->dev);
@@ -1693,11 +1630,12 @@ void rtllib_associate_procedure_wq(void *data)
 		ieee->data_hard_stop(ieee->dev);
 
 	rtllib_stop_scan(ieee);
-	RT_TRACE(COMP_DBG, "===>%s(), chan:%d\n", __func__, ieee->current_network.channel);
+	RT_TRACE(COMP_DBG, "===>%s(), chan:%d\n", __func__,
+		 ieee->current_network.channel);
 	HTSetConnectBwMode(ieee, HT_CHANNEL_WIDTH_20, HT_EXTCHNL_OFFSET_NO_EXT);
-	if (ieee->eRFPowerState == eRfOff)
-	{
-            RT_TRACE(COMP_DBG, "=============>%s():Rf state is eRfOff, schedule ipsleave wq again,return\n",__func__);
+	if (ieee->eRFPowerState == eRfOff) {
+		RT_TRACE(COMP_DBG, "=============>%s():Rf state is eRfOff,"
+			 " schedule ipsleave wq again,return\n", __func__);
 		if (ieee->rtllib_ips_leave_wq != NULL)
 			ieee->rtllib_ips_leave_wq(ieee->dev);
 		up(&ieee->wx_sem);
@@ -1710,12 +1648,13 @@ void rtllib_associate_procedure_wq(void *data)
 	up(&ieee->wx_sem);
 }
 
-inline void rtllib_softmac_new_net(struct rtllib_device *ieee, struct rtllib_network *net)
+inline void rtllib_softmac_new_net(struct rtllib_device *ieee,
+				   struct rtllib_network *net)
 {
-	u8 tmp_ssid[IW_ESSID_MAX_SIZE+1];
+	u8 tmp_ssid[IW_ESSID_MAX_SIZE + 1];
 	int tmp_ssid_len = 0;
 
-	short apset,ssidset,ssidbroad,apmatch,ssidmatch;
+	short apset, ssidset, ssidbroad, apmatch, ssidmatch;
 
 	/* we are interested in new new only if we are not associated
 	 * and we are not associating / authenticating
@@ -1723,103 +1662,124 @@ inline void rtllib_softmac_new_net(struct rtllib_device *ieee, struct rtllib_net
 	if (ieee->state != RTLLIB_NOLINK)
 		return;
 
-	if ((ieee->iw_mode == IW_MODE_INFRA) && !(net->capability & WLAN_CAPABILITY_ESS))
+	if ((ieee->iw_mode == IW_MODE_INFRA) && !(net->capability &
+	    WLAN_CAPABILITY_ESS))
 		return;
 
-	if ((ieee->iw_mode == IW_MODE_ADHOC) && !(net->capability & WLAN_CAPABILITY_IBSS))
+	if ((ieee->iw_mode == IW_MODE_ADHOC) && !(net->capability &
+	     WLAN_CAPABILITY_IBSS))
 		return;
 
-	if ((ieee->iw_mode == IW_MODE_ADHOC) && (net->channel > ieee->ibss_maxjoin_chal)) {
+	if ((ieee->iw_mode == IW_MODE_ADHOC) &&
+	    (net->channel > ieee->ibss_maxjoin_chal))
 		return;
-	}
-	if (ieee->iw_mode == IW_MODE_INFRA || ieee->iw_mode == IW_MODE_ADHOC)
-		{
+	if (ieee->iw_mode == IW_MODE_INFRA || ieee->iw_mode == IW_MODE_ADHOC) {
 		/* if the user specified the AP MAC, we need also the essid
 		 * This could be obtained by beacons or, if the network does not
 		 * broadcast it, it can be put manually.
 		 */
 		apset = ieee->wap_set;
 		ssidset = ieee->ssid_set;
-		ssidbroad =  !(net->ssid_len == 0 || net->ssid[0]== '\0');
-		apmatch = (memcmp(ieee->current_network.bssid, net->bssid, ETH_ALEN)==0);
-		if (!ssidbroad){
-			ssidmatch = (ieee->current_network.ssid_len == net->hidden_ssid_len)&&\
-					(!strncmp(ieee->current_network.ssid, net->hidden_ssid, net->hidden_ssid_len));
-			if (net->hidden_ssid_len > 0)
-                        {
-			        strncpy(net->ssid, net->hidden_ssid, net->hidden_ssid_len);
-			        net->ssid_len = net->hidden_ssid_len;
-                                ssidbroad = 1;
-                        }
-		}
-		else
-			ssidmatch = (ieee->current_network.ssid_len == net->ssid_len)&&\
-					(!strncmp(ieee->current_network.ssid, net->ssid, net->ssid_len));
-
-		if (	/* if the user set the AP check if match.
-		         * if the network does not broadcast essid we check the user supplyed ANY essid
-			 * if the network does broadcast and the user does not set essid it is OK
-			 * if the network does broadcast and the user did set essid chech if essid match
-			 */
-			( apset && apmatch &&
-				((ssidset && ssidbroad && ssidmatch) || (ssidbroad && !ssidset) || (!ssidbroad && ssidset)) )
-			/* if the ap is not set, check that the user set the bssid
-			 * and the network does bradcast and that those two bssid matches
-			 */
-			 ||  (!apset && ssidset && ssidbroad && ssidmatch) || (ieee->is_roaming && ssidset && ssidbroad && ssidmatch)
-			){
-				/* if the essid is hidden replace it with the
-				* essid provided by the user.
-				*/
-				if (!ssidbroad){
-					strncpy(tmp_ssid, ieee->current_network.ssid, IW_ESSID_MAX_SIZE);
-					tmp_ssid_len = ieee->current_network.ssid_len;
-				}
-				memcpy(&ieee->current_network, net, sizeof(struct rtllib_network));
-				if (!ssidbroad){
-					strncpy(ieee->current_network.ssid, tmp_ssid, IW_ESSID_MAX_SIZE);
-					ieee->current_network.ssid_len = tmp_ssid_len;
-				}
-				printk(KERN_INFO"Linking with %s,channel:%d, qos:%d, myHT:%d, networkHT:%d, mode:%x cur_net.flags:0x%x\n",ieee->current_network.ssid,ieee->current_network.channel, ieee->current_network.qos_data.supported, ieee->pHTInfo->bEnableHT, ieee->current_network.bssht.bdSupportHT, ieee->current_network.mode, ieee->current_network.flags);
-
-				if ((rtllib_act_scanning(ieee, false)) && !(ieee->softmac_features & IEEE_SOFTMAC_SCAN)){
-					rtllib_stop_scan_syncro(ieee);
-				}
-
-				ieee->hwscan_ch_bk = ieee->current_network.channel;
-				HTResetIOTSetting(ieee->pHTInfo);
-				ieee->wmm_acm = 0;
-				if (ieee->iw_mode == IW_MODE_INFRA) {
-					/* Join the network for the first time */
-					ieee->AsocRetryCount = 0;
-					if ((ieee->current_network.qos_data.supported == 1) &&
-					   ieee->current_network.bssht.bdSupportHT)
-						HTResetSelfAndSavePeerSetting(ieee, &(ieee->current_network));
-					else
-						ieee->pHTInfo->bCurrentHTSupport = false;
-
-					ieee->state = RTLLIB_ASSOCIATING;
-					if (ieee->LedControlHandler != NULL)
-					        ieee->LedControlHandler(ieee->dev, LED_CTL_START_TO_LINK);
-					queue_delayed_work_rsl(ieee->wq, &ieee->associate_procedure_wq, 0);
+		ssidbroad =  !(net->ssid_len == 0 || net->ssid[0] == '\0');
+		apmatch = (memcmp(ieee->current_network.bssid, net->bssid,
+				  ETH_ALEN) == 0);
+		if (!ssidbroad) {
+			ssidmatch = (ieee->current_network.ssid_len ==
+				    net->hidden_ssid_len) &&
+				    (!strncmp(ieee->current_network.ssid,
+				    net->hidden_ssid, net->hidden_ssid_len));
+			if (net->hidden_ssid_len > 0) {
+				strncpy(net->ssid, net->hidden_ssid,
+					net->hidden_ssid_len);
+				net->ssid_len = net->hidden_ssid_len;
+				ssidbroad = 1;
+			}
+		} else
+			ssidmatch =
+			   (ieee->current_network.ssid_len == net->ssid_len) &&
+			   (!strncmp(ieee->current_network.ssid, net->ssid,
+			   net->ssid_len));
+
+		/* if the user set the AP check if match.
+		 * if the network does not broadcast essid we check the
+		 *	 user supplyed ANY essid
+		 * if the network does broadcast and the user does not set
+		 *	 essid it is OK
+		 * if the network does broadcast and the user did set essid
+		 * check if essid match
+		 * if the ap is not set, check that the user set the bssid
+		 * and the network does bradcast and that those two bssid match
+		 */
+		if ((apset && apmatch &&
+		   ((ssidset && ssidbroad && ssidmatch) ||
+		   (ssidbroad && !ssidset) || (!ssidbroad && ssidset))) ||
+		   (!apset && ssidset && ssidbroad && ssidmatch) ||
+		   (ieee->is_roaming && ssidset && ssidbroad && ssidmatch)) {
+			/* if the essid is hidden replace it with the
+			* essid provided by the user.
+			*/
+			if (!ssidbroad) {
+				strncpy(tmp_ssid, ieee->current_network.ssid,
+					IW_ESSID_MAX_SIZE);
+				tmp_ssid_len = ieee->current_network.ssid_len;
+			}
+			memcpy(&ieee->current_network, net,
+			       sizeof(struct rtllib_network));
+			if (!ssidbroad) {
+				strncpy(ieee->current_network.ssid, tmp_ssid,
+					IW_ESSID_MAX_SIZE);
+				ieee->current_network.ssid_len = tmp_ssid_len;
+			}
+			printk(KERN_INFO"Linking with %s,channel:%d, qos:%d, "
+			       "myHT:%d, networkHT:%d, mode:%x cur_net.flags"
+			       ":0x%x\n", ieee->current_network.ssid,
+			       ieee->current_network.channel,
+			       ieee->current_network.qos_data.supported,
+			       ieee->pHTInfo->bEnableHT,
+			       ieee->current_network.bssht.bdSupportHT,
+			       ieee->current_network.mode,
+			       ieee->current_network.flags);
+
+			if ((rtllib_act_scanning(ieee, false)) &&
+			   !(ieee->softmac_features & IEEE_SOFTMAC_SCAN))
+				rtllib_stop_scan_syncro(ieee);
+
+			ieee->hwscan_ch_bk = ieee->current_network.channel;
+			HTResetIOTSetting(ieee->pHTInfo);
+			ieee->wmm_acm = 0;
+			if (ieee->iw_mode == IW_MODE_INFRA) {
+				/* Join the network for the first time */
+				ieee->AsocRetryCount = 0;
+				if ((ieee->current_network.qos_data.supported == 1) &&
+				   ieee->current_network.bssht.bdSupportHT)
+					HTResetSelfAndSavePeerSetting(ieee,
+						 &(ieee->current_network));
+				else
+					ieee->pHTInfo->bCurrentHTSupport =
+								 false;
+
+				ieee->state = RTLLIB_ASSOCIATING;
+				if (ieee->LedControlHandler != NULL)
+					ieee->LedControlHandler(ieee->dev,
+							 LED_CTL_START_TO_LINK);
+				queue_delayed_work_rsl(ieee->wq,
+					   &ieee->associate_procedure_wq, 0);
+			} else {
+				if (rtllib_is_54g(&ieee->current_network) &&
+					(ieee->modulation & RTLLIB_OFDM_MODULATION)) {
+					ieee->rate = 108;
+					ieee->SetWirelessMode(ieee->dev, IEEE_G);
+					printk(KERN_INFO"Using G rates\n");
 				} else {
-					if (rtllib_is_54g(&ieee->current_network) &&
-						(ieee->modulation & RTLLIB_OFDM_MODULATION)){
-						ieee->rate = 108;
-						ieee->SetWirelessMode(ieee->dev, IEEE_G);
-						printk(KERN_INFO"Using G rates\n");
-					}else{
-						ieee->rate = 22;
-						ieee->SetWirelessMode(ieee->dev, IEEE_B);
-						printk(KERN_INFO"Using B rates\n");
-					}
-					memset(ieee->dot11HTOperationalRateSet, 0, 16);
-					ieee->state = RTLLIB_LINKED;
+					ieee->rate = 22;
+					ieee->SetWirelessMode(ieee->dev, IEEE_B);
+					printk(KERN_INFO"Using B rates\n");
 				}
-
+				memset(ieee->dot11HTOperationalRateSet, 0, 16);
+				ieee->state = RTLLIB_LINKED;
+			}
 		}
 	}
-
 }
 
 void rtllib_softmac_check_all_nets(struct rtllib_device *ieee)
@@ -1838,51 +1798,49 @@ void rtllib_softmac_check_all_nets(struct rtllib_device *ieee)
 		if (ieee->state != RTLLIB_NOLINK)
 			break;
 
-		if (ieee->scan_age == 0 || time_after(target->last_scanned + ieee->scan_age, jiffies))
-		rtllib_softmac_new_net(ieee, target);
+		if (ieee->scan_age == 0 || time_after(target->last_scanned +
+		    ieee->scan_age, jiffies))
+			rtllib_softmac_new_net(ieee, target);
 	}
-
 	spin_unlock_irqrestore(&ieee->lock, flags);
-
 }
 
-
 static inline u16 auth_parse(struct sk_buff *skb, u8** challenge, int *chlen)
 {
 	struct rtllib_authentication *a;
 	u8 *t;
-	if (skb->len <  (sizeof(struct rtllib_authentication)-sizeof(struct rtllib_info_element))){
-		RTLLIB_DEBUG_MGMT("invalid len in auth resp: %d\n",skb->len);
+	if (skb->len <  (sizeof(struct rtllib_authentication) -
+	    sizeof(struct rtllib_info_element))) {
+		RTLLIB_DEBUG_MGMT("invalid len in auth resp: %d\n", skb->len);
 		return 0xcafe;
 	}
 	*challenge = NULL;
-	a = (struct rtllib_authentication*) skb->data;
-	if (skb->len > (sizeof(struct rtllib_authentication) +3)){
+	a = (struct rtllib_authentication *) skb->data;
+	if (skb->len > (sizeof(struct rtllib_authentication) + 3)) {
 		t = skb->data + sizeof(struct rtllib_authentication);
 
-		if (*(t++) == MFIE_TYPE_CHALLENGE){
+		if (*(t++) == MFIE_TYPE_CHALLENGE) {
 			*chlen = *(t++);
-			*challenge = (u8*)kmalloc(*chlen, GFP_ATOMIC);
-			memcpy(*challenge, t, *chlen);
+			*challenge = kmalloc(*chlen, GFP_ATOMIC);
+			memcpy(*challenge, t, *chlen);	/*TODO - check here*/
 		}
 	}
-
 	return cpu_to_le16(a->status);
-
 }
 
-
-int auth_rq_parse(struct sk_buff *skb,u8* dest)
+int auth_rq_parse(struct sk_buff *skb, u8 *dest)
 {
 	struct rtllib_authentication *a;
 
-	if (skb->len <  (sizeof(struct rtllib_authentication)-sizeof(struct rtllib_info_element))){
-		RTLLIB_DEBUG_MGMT("invalid len in auth request: %d\n",skb->len);
+	if (skb->len <  (sizeof(struct rtllib_authentication) -
+	    sizeof(struct rtllib_info_element))) {
+		RTLLIB_DEBUG_MGMT("invalid len in auth request: %d\n",
+				  skb->len);
 		return -1;
 	}
-	a = (struct rtllib_authentication*) skb->data;
+	a = (struct rtllib_authentication *) skb->data;
 
-	memcpy(dest,a->header.addr2, ETH_ALEN);
+	memcpy(dest, a->header.addr2, ETH_ALEN);
 
 	if (le16_to_cpu(a->algorithm) != WLAN_AUTH_OPEN)
 		return  WLAN_STATUS_NOT_SUPPORTED_AUTH_ALG;
@@ -1890,38 +1848,36 @@ int auth_rq_parse(struct sk_buff *skb,u8* dest)
 	return WLAN_STATUS_SUCCESS;
 }
 
-static short probe_rq_parse(struct rtllib_device *ieee, struct sk_buff *skb, u8 *src)
+static short probe_rq_parse(struct rtllib_device *ieee, struct sk_buff *skb,
+			    u8 *src)
 {
 	u8 *tag;
 	u8 *skbend;
-	u8 *ssid=NULL;
+	u8 *ssid = NULL;
 	u8 ssidlen = 0;
-
 	struct rtllib_hdr_3addr   *header =
 		(struct rtllib_hdr_3addr   *) skb->data;
+	bool bssid_match;
 
-	if (skb->len < sizeof (struct rtllib_hdr_3addr  ))
+	if (skb->len < sizeof(struct rtllib_hdr_3addr))
 		return -1; /* corrupted */
-        if ((memcmp(header->addr3,ieee->current_network.bssid,ETH_ALEN) != 0)&&
-                (memcmp(header->addr3,"\xff\xff\xff\xff\xff\xff",ETH_ALEN) != 0)) {
-            return -1;
-        }
 
-        if (memcmp(header->addr3,ieee->current_network.bssid,ETH_ALEN) == 0) {
-        }
+	bssid_match =
+	  (memcmp(header->addr3, ieee->current_network.bssid, ETH_ALEN) != 0) &&
+	  (memcmp(header->addr3, "\xff\xff\xff\xff\xff\xff", ETH_ALEN) != 0);
+	if (bssid_match)
+		return -1;
 
-        if (memcmp(header->addr3,"\xff\xff\xff\xff\xff\xff",ETH_ALEN) == 0) {
-        }
-	memcpy(src,header->addr2, ETH_ALEN);
+	memcpy(src, header->addr2, ETH_ALEN);
 
-	skbend = (u8*)skb->data + skb->len;
+	skbend = (u8 *)skb->data + skb->len;
 
-	tag = skb->data + sizeof (struct rtllib_hdr_3addr  );
+	tag = skb->data + sizeof(struct rtllib_hdr_3addr);
 
-	while (tag+1 < skbend){
-		if (*tag == 0){
-			ssid = tag+2;
-			ssidlen = *(tag+1);
+	while (tag + 1 < skbend) {
+		if (*tag == 0) {
+			ssid = tag + 2;
+			ssidlen = *(tag + 1);
 			break;
 		}
 		tag++; /* point to the len field */
@@ -1929,53 +1885,56 @@ static short probe_rq_parse(struct rtllib_device *ieee, struct sk_buff *skb, u8
 		tag++; /* point to the next tag */
 	}
 
-	if (ssidlen == 0) return 1;
+	if (ssidlen == 0)
+		return 1;
 
-	if (!ssid) return 1; /* ssid not found in tagged param */
-	return (!strncmp(ssid, ieee->current_network.ssid, ssidlen));
+	if (!ssid)
+		return 1; /* ssid not found in tagged param */
 
+	return !strncmp(ssid, ieee->current_network.ssid, ssidlen);
 }
 
-int assoc_rq_parse(struct sk_buff *skb,u8* dest)
+int assoc_rq_parse(struct sk_buff *skb, u8 *dest)
 {
 	struct rtllib_assoc_request_frame *a;
 
 	if (skb->len < (sizeof(struct rtllib_assoc_request_frame) -
 		sizeof(struct rtllib_info_element))) {
 
-		RTLLIB_DEBUG_MGMT("invalid len in auth request:%d \n", skb->len);
+		RTLLIB_DEBUG_MGMT("invalid len in auth request:%d\n", skb->len);
 		return -1;
 	}
 
-	a = (struct rtllib_assoc_request_frame*) skb->data;
+	a = (struct rtllib_assoc_request_frame *) skb->data;
 
-	memcpy(dest,a->header.addr2,ETH_ALEN);
+	memcpy(dest, a->header.addr2, ETH_ALEN);
 
 	return 0;
 }
 
-static inline u16 assoc_parse(struct rtllib_device *ieee, struct sk_buff *skb, int *aid)
+static inline u16 assoc_parse(struct rtllib_device *ieee, struct sk_buff *skb,
+			      int *aid)
 {
 	struct rtllib_assoc_response_frame *response_head;
 	u16 status_code;
 
-	if (skb->len <  sizeof(struct rtllib_assoc_response_frame)){
+	if (skb->len <  sizeof(struct rtllib_assoc_response_frame)) {
 		RTLLIB_DEBUG_MGMT("invalid len in auth resp: %d\n", skb->len);
 		return 0xcafe;
 	}
 
-	response_head = (struct rtllib_assoc_response_frame*) skb->data;
+	response_head = (struct rtllib_assoc_response_frame *) skb->data;
 	*aid = le16_to_cpu(response_head->aid) & 0x3fff;
 
 	status_code = le16_to_cpu(response_head->status);
-	if ((status_code==WLAN_STATUS_ASSOC_DENIED_RATES || \
-	   status_code==WLAN_STATUS_CAPS_UNSUPPORTED)&&
+	if ((status_code == WLAN_STATUS_ASSOC_DENIED_RATES ||
+	   status_code == WLAN_STATUS_CAPS_UNSUPPORTED) &&
 	   ((ieee->mode == IEEE_G) &&
-	    (ieee->current_network.mode == IEEE_N_24G) &&
-            (ieee->AsocRetryCount++ < (RT_ASOC_RETRY_LIMIT-1)))) {
-                 ieee->pHTInfo->IOTAction |= HT_IOT_ACT_PURE_N_MODE;
-	}else {
-		 ieee->AsocRetryCount = 0;
+	   (ieee->current_network.mode == IEEE_N_24G) &&
+	   (ieee->AsocRetryCount++ < (RT_ASOC_RETRY_LIMIT-1)))) {
+		ieee->pHTInfo->IOTAction |= HT_IOT_ACT_PURE_N_MODE;
+	} else {
+		ieee->AsocRetryCount = 0;
 	}
 
 	return le16_to_cpu(response_head->status);
@@ -1985,38 +1944,37 @@ void rtllib_rx_probe_rq(struct rtllib_device *ieee, struct sk_buff *skb)
 {
 	u8 dest[ETH_ALEN];
 	ieee->softmac_stats.rx_probe_rq++;
-	if (probe_rq_parse(ieee, skb, dest) > 0){
+	if (probe_rq_parse(ieee, skb, dest) > 0) {
 		ieee->softmac_stats.tx_probe_rs++;
 		rtllib_resp_to_probe(ieee, dest);
 	}
 }
 
-static inline void rtllib_rx_auth_rq(struct rtllib_device *ieee, struct sk_buff *skb)
+static inline void rtllib_rx_auth_rq(struct rtllib_device *ieee,
+				     struct sk_buff *skb)
 {
 	u8 dest[ETH_ALEN];
 	int status;
 	ieee->softmac_stats.rx_auth_rq++;
 
-	if ((status = auth_rq_parse(skb, dest))!= -1){
+	status = auth_rq_parse(skb, dest);
+	if (status != -1)
 		rtllib_resp_to_auth(ieee, status, dest);
-	}
-
 }
 
-static inline void rtllib_rx_assoc_rq(struct rtllib_device *ieee, struct sk_buff *skb)
+static inline void rtllib_rx_assoc_rq(struct rtllib_device *ieee,
+				      struct sk_buff *skb)
 {
 
 	u8 dest[ETH_ALEN];
 
 	ieee->softmac_stats.rx_ass_rq++;
-	if (assoc_rq_parse(skb,dest) != -1){
+	if (assoc_rq_parse(skb, dest) != -1)
 		rtllib_resp_to_assoc_rq(ieee, dest);
-	}
 
 	printk(KERN_INFO"New client associated: "MAC_FMT"\n", MAC_ARG(dest));
 }
 
-
 void rtllib_sta_ps_send_null_frame(struct rtllib_device *ieee, short pwr)
 {
 
@@ -2024,34 +1982,25 @@ void rtllib_sta_ps_send_null_frame(struct rtllib_device *ieee, short pwr)
 
 	if (buf)
 		softmac_ps_mgmt_xmit(buf, ieee);
-
 }
 
 void rtllib_sta_ps_send_pspoll_frame(struct rtllib_device *ieee)
 {
-
 	struct sk_buff *buf = rtllib_pspoll_func(ieee);
 
 	if (buf)
 		softmac_ps_mgmt_xmit(buf, ieee);
-
 }
 
 static short rtllib_sta_ps_sleep(struct rtllib_device *ieee, u64 *time)
 {
 	int timeout = ieee->ps_timeout;
 	u8 dtim;
-	struct rt_pwr_save_ctrl *pPSC = (struct rt_pwr_save_ctrl *)(&(ieee->PowerSaveControl));
-	/*if (ieee->ps == RTLLIB_PS_DISABLED ||
-		ieee->iw_mode != IW_MODE_INFRA ||
-		ieee->state != RTLLIB_LINKED)
-
-		return 0;
-	*/
+	struct rt_pwr_save_ctrl *pPSC = (struct rt_pwr_save_ctrl *)
+					(&(ieee->PowerSaveControl));
 
-	if (ieee->LPSDelayCnt)
-	{
-		ieee->LPSDelayCnt --;
+	if (ieee->LPSDelayCnt) {
+		ieee->LPSDelayCnt--;
 		return 0;
 	}
 
@@ -2060,21 +2009,20 @@ static short rtllib_sta_ps_sleep(struct rtllib_device *ieee, u64 *time)
 		return 0;
 	timeout = ieee->current_network.beacon_interval;
 	ieee->current_network.dtim_data = RTLLIB_DTIM_INVALID;
-	/* there's no need to nofity AP that I find you buffered with broadcast packet */
+	/* there's no need to nofity AP that I find you buffered
+	 * with broadcast packet */
 	if (dtim & (RTLLIB_DTIM_UCAST & ieee->ps))
 		return 2;
 
-	if (!time_after(jiffies, ieee->dev->trans_start + MSECS(timeout))){
+	if (!time_after(jiffies, ieee->dev->trans_start + MSECS(timeout)))
 		return 0;
-	}
-	if (!time_after(jiffies, ieee->last_rx_ps_time + MSECS(timeout))){
+	if (!time_after(jiffies, ieee->last_rx_ps_time + MSECS(timeout)))
 		return 0;
-	}
-	if ((ieee->softmac_features & IEEE_SOFTMAC_SINGLE_QUEUE ) &&
-		(ieee->mgmt_queue_tail != ieee->mgmt_queue_head))
+	if ((ieee->softmac_features & IEEE_SOFTMAC_SINGLE_QUEUE) &&
+	    (ieee->mgmt_queue_tail != ieee->mgmt_queue_head))
 		return 0;
 
-	if (time){
+	if (time) {
 		if (ieee->bAwakePktSent == true) {
 			pPSC->LPSAwakeIntvl = 1;
 		} else {
@@ -2088,27 +2036,37 @@ static short rtllib_sta_ps_sleep(struct rtllib_device *ieee, u64 *time)
 				MaxPeriod = ieee->current_network.dtim_period;
 			else
 				MaxPeriod = pPSC->RegMaxLPSAwakeIntvl;
-			pPSC->LPSAwakeIntvl = (pPSC->LPSAwakeIntvl >= MaxPeriod) ? MaxPeriod : (pPSC->LPSAwakeIntvl + 1);
+			pPSC->LPSAwakeIntvl = (pPSC->LPSAwakeIntvl >=
+					       MaxPeriod) ? MaxPeriod :
+					       (pPSC->LPSAwakeIntvl + 1);
 		}
 		{
 			u8 LPSAwakeIntvl_tmp = 0;
 			u8 period = ieee->current_network.dtim_period;
 			u8 count = ieee->current_network.tim.tim_count;
-			if (count == 0 ) {
+			if (count == 0) {
 				if (pPSC->LPSAwakeIntvl > period)
-					LPSAwakeIntvl_tmp = period + (pPSC->LPSAwakeIntvl - period) -((pPSC->LPSAwakeIntvl-period)%period);
+					LPSAwakeIntvl_tmp = period +
+						 (pPSC->LPSAwakeIntvl -
+						 period) -
+						 ((pPSC->LPSAwakeIntvl-period) %
+						 period);
 				else
 					LPSAwakeIntvl_tmp = pPSC->LPSAwakeIntvl;
 
 			} else {
-				if (pPSC->LPSAwakeIntvl > ieee->current_network.tim.tim_count)
-					LPSAwakeIntvl_tmp = count + (pPSC->LPSAwakeIntvl - count) -((pPSC->LPSAwakeIntvl-count)%period);
+				if (pPSC->LPSAwakeIntvl >
+				    ieee->current_network.tim.tim_count)
+					LPSAwakeIntvl_tmp = count +
+					(pPSC->LPSAwakeIntvl - count) -
+					((pPSC->LPSAwakeIntvl-count)%period);
 				else
 					LPSAwakeIntvl_tmp = pPSC->LPSAwakeIntvl;
 			}
 
 		*time = ieee->current_network.last_dtim_sta_time
-			+ MSECS(ieee->current_network.beacon_interval * LPSAwakeIntvl_tmp);
+			+ MSECS(ieee->current_network.beacon_interval *
+			LPSAwakeIntvl_tmp);
 	}
 	}
 
@@ -2119,45 +2077,38 @@ static short rtllib_sta_ps_sleep(struct rtllib_device *ieee, u64 *time)
 
 inline void rtllib_sta_ps(struct rtllib_device *ieee)
 {
-
 	u64 time;
 	short sleep;
-
-	unsigned long flags,flags2;
+	unsigned long flags, flags2;
 
 	spin_lock_irqsave(&ieee->lock, flags);
 
 	if ((ieee->ps == RTLLIB_PS_DISABLED ||
-		ieee->iw_mode != IW_MODE_INFRA ||
-		ieee->state != RTLLIB_LINKED)){
-
-		RT_TRACE(COMP_DBG, "=====>%s(): no need to ps,wake up!! ieee->ps is %d,ieee->iw_mode is %d,ieee->state is %d\n",
-			__func__,ieee->ps,ieee->iw_mode,ieee->state);
+	     ieee->iw_mode != IW_MODE_INFRA ||
+	     ieee->state != RTLLIB_LINKED)) {
+		RT_TRACE(COMP_DBG, "=====>%s(): no need to ps,wake up!! "
+			 "ieee->ps is %d, ieee->iw_mode is %d, ieee->state"
+			 " is %d\n", __func__, ieee->ps, ieee->iw_mode,
+			  ieee->state);
 		spin_lock_irqsave(&ieee->mgmt_tx_lock, flags2);
-
 		rtllib_sta_wakeup(ieee, 1);
 
 		spin_unlock_irqrestore(&ieee->mgmt_tx_lock, flags2);
 	}
-
 	sleep = rtllib_sta_ps_sleep(ieee, &time);
 	/* 2 wake, 1 sleep, 0 do nothing */
 	if (sleep == 0)
-	{
 		goto out;
-	}
-	if (sleep == 1){
-		if (ieee->sta_sleep == LPS_IS_SLEEP){
+	if (sleep == 1) {
+		if (ieee->sta_sleep == LPS_IS_SLEEP) {
 			ieee->enter_sleep_state(ieee->dev, time);
-		}
-
-		else if (ieee->sta_sleep == LPS_IS_WAKE){
+		} else if (ieee->sta_sleep == LPS_IS_WAKE) {
 			spin_lock_irqsave(&ieee->mgmt_tx_lock, flags2);
 
-			if (ieee->ps_is_queue_empty(ieee->dev)){
+			if (ieee->ps_is_queue_empty(ieee->dev)) {
 				ieee->sta_sleep = LPS_WAIT_NULL_DATA_SEND;
 				ieee->ack_tx_to_ieee = 1;
-				rtllib_sta_ps_send_null_frame(ieee,1);
+				rtllib_sta_ps_send_null_frame(ieee, 1);
 				ieee->ps_time = time;
 			}
 			spin_unlock_irqrestore(&ieee->mgmt_tx_lock, flags2);
@@ -2166,10 +2117,10 @@ inline void rtllib_sta_ps(struct rtllib_device *ieee)
 
 		ieee->bAwakePktSent = false;
 
-	}else if (sleep == 2){
+	} else if (sleep == 2) {
 		spin_lock_irqsave(&ieee->mgmt_tx_lock, flags2);
 
-		rtllib_sta_wakeup(ieee,1);
+		rtllib_sta_wakeup(ieee, 1);
 
 		spin_unlock_irqrestore(&ieee->mgmt_tx_lock, flags2);
 	}
@@ -2181,15 +2132,13 @@ inline void rtllib_sta_ps(struct rtllib_device *ieee)
 
 void rtllib_sta_wakeup(struct rtllib_device *ieee, short nl)
 {
-	if (ieee->sta_sleep == LPS_IS_WAKE){
-		if (nl){
-			if (ieee->pHTInfo->IOTAction & HT_IOT_ACT_NULL_DATA_POWER_SAVING)
-			{
+	if (ieee->sta_sleep == LPS_IS_WAKE) {
+		if (nl) {
+			if (ieee->pHTInfo->IOTAction &
+			    HT_IOT_ACT_NULL_DATA_POWER_SAVING) {
 				ieee->ack_tx_to_ieee = 1;
 				rtllib_sta_ps_send_null_frame(ieee, 0);
-			}
-			else
-			{
+			} else {
 				ieee->ack_tx_to_ieee = 1;
 				rtllib_sta_ps_send_pspoll_frame(ieee);
 			}
@@ -2200,19 +2149,12 @@ void rtllib_sta_wakeup(struct rtllib_device *ieee, short nl)
 
 	if (ieee->sta_sleep == LPS_IS_SLEEP)
 		ieee->sta_wake_up(ieee->dev);
-	if (nl){
-		/*
+	if (nl) {
+		if (ieee->pHTInfo->IOTAction &
+		    HT_IOT_ACT_NULL_DATA_POWER_SAVING) {
 			ieee->ack_tx_to_ieee = 1;
-			printk("%s(3): notify AP we are awaked ++++++++++ SendNullFunctionData\n", __func__);
 			rtllib_sta_ps_send_null_frame(ieee, 0);
-		*/
-		if (ieee->pHTInfo->IOTAction & HT_IOT_ACT_NULL_DATA_POWER_SAVING)
-		{
-			ieee->ack_tx_to_ieee = 1;
-			rtllib_sta_ps_send_null_frame(ieee, 0);
-		}
-		else
-		{
+		} else {
 			ieee->ack_tx_to_ieee = 1;
 			ieee->polling = true;
 			rtllib_sta_ps_send_pspoll_frame(ieee);
@@ -2226,13 +2168,13 @@ void rtllib_sta_wakeup(struct rtllib_device *ieee, short nl)
 
 void rtllib_ps_tx_ack(struct rtllib_device *ieee, short success)
 {
-	unsigned long flags,flags2;
+	unsigned long flags, flags2;
 
 	spin_lock_irqsave(&ieee->lock, flags);
 
-	if (ieee->sta_sleep == LPS_WAIT_NULL_DATA_SEND){
+	if (ieee->sta_sleep == LPS_WAIT_NULL_DATA_SEND) {
 		/* Null frame with PS bit set */
-		if (success){
+		if (success) {
 			ieee->sta_sleep = LPS_IS_SLEEP;
 			ieee->enter_sleep_state(ieee->dev, ieee->ps_time);
 		}
@@ -2241,199 +2183,208 @@ void rtllib_ps_tx_ack(struct rtllib_device *ieee, short success)
 		 */
 	} else {/* 21112005 - tx again null without PS bit if lost */
 
-		if ((ieee->sta_sleep == LPS_IS_WAKE) && !success){
+		if ((ieee->sta_sleep == LPS_IS_WAKE) && !success) {
 			spin_lock_irqsave(&ieee->mgmt_tx_lock, flags2);
-			if (ieee->pHTInfo->IOTAction & HT_IOT_ACT_NULL_DATA_POWER_SAVING)
-			{
+			if (ieee->pHTInfo->IOTAction &
+			    HT_IOT_ACT_NULL_DATA_POWER_SAVING)
 				rtllib_sta_ps_send_null_frame(ieee, 0);
-			}
 			else
-			{
 				rtllib_sta_ps_send_pspoll_frame(ieee);
-			}
 			spin_unlock_irqrestore(&ieee->mgmt_tx_lock, flags2);
 		}
 	}
 	spin_unlock_irqrestore(&ieee->lock, flags);
 }
 
-void rtllib_process_action(struct rtllib_device* ieee, struct sk_buff* skb)
+void rtllib_process_action(struct rtllib_device *ieee, struct sk_buff *skb)
 {
 	struct rtllib_hdr_3addr *header = (struct rtllib_hdr_3addr *) skb->data;
-	u8* act = rtllib_get_payload((struct rtllib_hdr *)header);
+	u8 *act = rtllib_get_payload((struct rtllib_hdr *)header);
 	u8 category = 0;
 
 	if (act == NULL) {
-		RTLLIB_DEBUG(RTLLIB_DL_ERR, "error to get payload of action frame\n");
+		RTLLIB_DEBUG(RTLLIB_DL_ERR, "error to get payload of "
+			     "action frame\n");
 		return;
 	}
 
 	category = *act;
-	act ++;
+	act++;
 	switch (category) {
-		case ACT_CAT_BA:
-			switch (*act) {
-				case ACT_ADDBAREQ:
-					rtllib_rx_ADDBAReq(ieee, skb);
-					break;
-				case ACT_ADDBARSP:
-					rtllib_rx_ADDBARsp(ieee, skb);
-					break;
-				case ACT_DELBA:
-					rtllib_rx_DELBA(ieee, skb);
-					break;
-			}
+	case ACT_CAT_BA:
+		switch (*act) {
+		case ACT_ADDBAREQ:
+			rtllib_rx_ADDBAReq(ieee, skb);
+			break;
+		case ACT_ADDBARSP:
+			rtllib_rx_ADDBARsp(ieee, skb);
 			break;
-		default:
+		case ACT_DELBA:
+			rtllib_rx_DELBA(ieee, skb);
 			break;
+		}
+		break;
+	default:
+		break;
 	}
 	return;
 }
 
-inline int rtllib_rx_assoc_resp(struct rtllib_device *ieee, struct sk_buff *skb, struct rtllib_rx_stats *rx_stats)
+inline int rtllib_rx_assoc_resp(struct rtllib_device *ieee, struct sk_buff *skb,
+				struct rtllib_rx_stats *rx_stats)
 {
 	u16 errcode;
 	int aid;
-	u8* ies;
+	u8 *ies;
 	struct rtllib_assoc_response_frame *assoc_resp;
 	struct rtllib_hdr_3addr *header = (struct rtllib_hdr_3addr *) skb->data;
 
 	RTLLIB_DEBUG_MGMT("received [RE]ASSOCIATION RESPONSE (%d)\n",
-					WLAN_FC_GET_STYPE(header->frame_ctl));
+			  WLAN_FC_GET_STYPE(header->frame_ctl));
 
 	if ((ieee->softmac_features & IEEE_SOFTMAC_ASSOCIATE) &&
-		ieee->state == RTLLIB_ASSOCIATING_AUTHENTICATED &&
-		(ieee->iw_mode == IW_MODE_INFRA))
-	{
-		if (0 == (errcode=assoc_parse(ieee,skb, &aid))){
-			struct rtllib_network *network = kzalloc(sizeof(struct rtllib_network), GFP_ATOMIC);
+	     ieee->state == RTLLIB_ASSOCIATING_AUTHENTICATED &&
+	     (ieee->iw_mode == IW_MODE_INFRA)) {
+		errcode = assoc_parse(ieee, skb, &aid);
+		if (0 == errcode) {
+			struct rtllib_network *network =
+				 kzalloc(sizeof(struct rtllib_network),
+				 GFP_ATOMIC);
 
 			if (!network)
 				return 1;
-			memset(network,0,sizeof(*network));
-			ieee->state=RTLLIB_LINKED;
+			memset(network, 0, sizeof(*network));
+			ieee->state = RTLLIB_LINKED;
 			ieee->assoc_id = aid;
 			ieee->softmac_stats.rx_ass_ok++;
 			/* station support qos */
-			/* Let the register setting defaultly with Legacy station */
-			assoc_resp = (struct rtllib_assoc_response_frame*)skb->data;
+			/* Let the register setting default with Legacy station */
+			assoc_resp = (struct rtllib_assoc_response_frame *)skb->data;
 			if (ieee->current_network.qos_data.supported == 1) {
-				if (rtllib_parse_info_param(ieee,assoc_resp->info_element,\
-							rx_stats->len - sizeof(*assoc_resp),\
-							network,rx_stats)){
+				if (rtllib_parse_info_param(ieee, assoc_resp->info_element,
+							rx_stats->len - sizeof(*assoc_resp),
+							network, rx_stats)) {
 					kfree(network);
 					return 1;
-				}
-				else
-				{
-					memcpy(ieee->pHTInfo->PeerHTCapBuf, network->bssht.bdHTCapBuf, network->bssht.bdHTCapLen);
-					memcpy(ieee->pHTInfo->PeerHTInfoBuf, network->bssht.bdHTInfoBuf, network->bssht.bdHTInfoLen);
+				} else {
+					memcpy(ieee->pHTInfo->PeerHTCapBuf,
+					       network->bssht.bdHTCapBuf,
+					       network->bssht.bdHTCapLen);
+					memcpy(ieee->pHTInfo->PeerHTInfoBuf,
+					       network->bssht.bdHTInfoBuf,
+					       network->bssht.bdHTInfoLen);
 				}
 				if (ieee->handle_assoc_response != NULL)
-					ieee->handle_assoc_response(ieee->dev, (struct rtllib_assoc_response_frame*)header, network);
+					ieee->handle_assoc_response(ieee->dev,
+						 (struct rtllib_assoc_response_frame *)header,
+						 network);
 				kfree(network);
 			}
 
-			if (ieee->assocresp_ies){
-				kfree(ieee->assocresp_ies);
-				ieee->assocresp_ies = NULL;
-			}
+			kfree(ieee->assocresp_ies);
+			ieee->assocresp_ies = NULL;
 			ies = &(assoc_resp->info_element[0].id);
 			ieee->assocresp_ies_len = (skb->data + skb->len) - ies;
-			ieee->assocresp_ies = kmalloc(ieee->assocresp_ies_len, GFP_ATOMIC);
+			ieee->assocresp_ies = kmalloc(ieee->assocresp_ies_len,
+						      GFP_ATOMIC);
 			if (ieee->assocresp_ies)
-				memcpy(ieee->assocresp_ies, ies, ieee->assocresp_ies_len);
-			else{
-				printk("%s()Warning: can't alloc memory for assocresp_ies\n", __func__);
+				memcpy(ieee->assocresp_ies, ies,
+				       ieee->assocresp_ies_len);
+			else {
+				printk(KERN_INFO "%s()Warning: can't alloc "
+				       "memory for assocresp_ies\n", __func__);
 				ieee->assocresp_ies_len = 0;
 			}
 			rtllib_associate_complete(ieee);
 		} else {
 			/* aid could not been allocated */
 			ieee->softmac_stats.rx_ass_err++;
-			printk(
-				"Association response status code 0x%x\n",
+			printk(KERN_INFO "Association response status code 0x%x\n",
 				errcode);
 			RTLLIB_DEBUG_MGMT(
 				"Association response status code 0x%x\n",
 				errcode);
-			if (ieee->AsocRetryCount < RT_ASOC_RETRY_LIMIT) {
-				queue_delayed_work_rsl(ieee->wq, &ieee->associate_procedure_wq, 0);
-			} else {
+			if (ieee->AsocRetryCount < RT_ASOC_RETRY_LIMIT)
+				queue_delayed_work_rsl(ieee->wq,
+					 &ieee->associate_procedure_wq, 0);
+			else
 				rtllib_associate_abort(ieee);
-			}
 		}
 	}
-
 	return 0;
 }
 
-inline int rtllib_rx_auth(struct rtllib_device *ieee, struct sk_buff *skb, struct rtllib_rx_stats *rx_stats)
+inline int rtllib_rx_auth(struct rtllib_device *ieee, struct sk_buff *skb,
+			  struct rtllib_rx_stats *rx_stats)
 {
 	u16 errcode;
-	u8* challenge;
-	int chlen=0;
+	u8 *challenge;
+	int chlen = 0;
 	bool bSupportNmode = true, bHalfSupportNmode = false;
 
-	if (ieee->softmac_features & IEEE_SOFTMAC_ASSOCIATE){
+	if (ieee->softmac_features & IEEE_SOFTMAC_ASSOCIATE) {
 		if (ieee->state == RTLLIB_ASSOCIATING_AUTHENTICATING &&
 		    (ieee->iw_mode == IW_MODE_INFRA)) {
 			RTLLIB_DEBUG_MGMT("Received authentication response");
 
-			if (0 == (errcode=auth_parse(skb, &challenge, &chlen))) {
-				if (ieee->open_wep || !challenge){
+			errcode = auth_parse(skb, &challenge, &chlen);
+			if (0 == errcode) {
+				if (ieee->open_wep || !challenge) {
 					ieee->state = RTLLIB_ASSOCIATING_AUTHENTICATED;
 					ieee->softmac_stats.rx_auth_rs_ok++;
-					if (!(ieee->pHTInfo->IOTAction&HT_IOT_ACT_PURE_N_MODE))
-					{
-						if (!ieee->GetNmodeSupportBySecCfg(ieee->dev))
-						{
-							if (IsHTHalfNmodeAPs(ieee))
-							{
+					if (!(ieee->pHTInfo->IOTAction &
+					    HT_IOT_ACT_PURE_N_MODE)) {
+						if (!ieee->GetNmodeSupportBySecCfg(ieee->dev)) {
+							if (IsHTHalfNmodeAPs(ieee)) {
 								bSupportNmode = true;
 								bHalfSupportNmode = true;
-							}
-							else
-							{
+							} else {
 								bSupportNmode = false;
 								bHalfSupportNmode = false;
 							}
 						}
 					}
-					/* Dummy wirless mode setting to avoid encryption issue */
+					/* Dummy wirless mode setting to avoid
+					 * encryption issue */
 					if (bSupportNmode) {
-						ieee->SetWirelessMode(ieee->dev, \
-							ieee->current_network.mode);
-					}else{
+						ieee->SetWirelessMode(ieee->dev,
+						   ieee->current_network.mode);
+					} else {
 						/*TODO*/
-						ieee->SetWirelessMode(ieee->dev, IEEE_G);
+						ieee->SetWirelessMode(ieee->dev,
+								      IEEE_G);
 					}
 
-					if (ieee->current_network.mode == IEEE_N_24G && bHalfSupportNmode == true)
-					{
-						printk("===============>entern half N mode\n");
-						ieee->bHalfWirelessN24GMode = true;
-					}
-					else
-						ieee->bHalfWirelessN24GMode = false;
+					if (ieee->current_network.mode ==
+					    IEEE_N_24G &&
+					    bHalfSupportNmode == true) {
+						printk(KERN_INFO "======>enter "
+						       "half N mode\n");
+						ieee->bHalfWirelessN24GMode =
+									 true;
+					} else
+						ieee->bHalfWirelessN24GMode =
+									 false;
 
 					rtllib_associate_step2(ieee);
-				}else{
-					rtllib_auth_challenge(ieee, challenge, chlen);
+				} else {
+					rtllib_auth_challenge(ieee, challenge,
+							      chlen);
 				}
-			}else{
+			} else {
 				ieee->softmac_stats.rx_auth_rs_err++;
-				RTLLIB_DEBUG_MGMT("Authentication respose status code 0x%x",errcode);
+				RTLLIB_DEBUG_MGMT("Authentication respose"
+						  " status code 0x%x", errcode);
 
-				printk("Authentication respose status code 0x%x",errcode);
+				printk(KERN_INFO "Authentication respose "
+				       "status code 0x%x", errcode);
 				rtllib_associate_abort(ieee);
 			}
 
-		}else if (ieee->iw_mode == IW_MODE_MASTER){
+		} else if (ieee->iw_mode == IW_MODE_MASTER) {
 			rtllib_rx_auth_rq(ieee, skb);
 		}
 	}
-
 	return 0;
 }
 
@@ -2453,7 +2404,7 @@ inline int rtllib_rx_deauth(struct rtllib_device *ieee, struct sk_buff *skb)
 		printk(KERN_INFO "==========>received disassoc/deauth(%x) "
 		       "frame, reason code:%x\n",
 		       WLAN_FC_GET_STYPE(header->frame_ctl),
-		       ((struct rtllib_disassoc*)skb->data)->reason);
+		       ((struct rtllib_disassoc *)skb->data)->reason);
 		ieee->state = RTLLIB_ASSOCIATING;
 		ieee->softmac_stats.reassoc++;
 		ieee->is_roaming = true;
@@ -2461,18 +2412,21 @@ inline int rtllib_rx_deauth(struct rtllib_device *ieee, struct sk_buff *skb)
 		rtllib_disassociate(ieee);
 		RemovePeerTS(ieee, header->addr2);
 		if (ieee->LedControlHandler != NULL)
-		        ieee->LedControlHandler(ieee->dev, LED_CTL_START_TO_LINK);
+			ieee->LedControlHandler(ieee->dev,
+						LED_CTL_START_TO_LINK);
 
-		if (!(ieee->rtllib_ap_sec_type(ieee)&(SEC_ALG_CCMP|SEC_ALG_TKIP)))
-		queue_delayed_work_rsl(ieee->wq, &ieee->associate_procedure_wq, 5);
+		if (!(ieee->rtllib_ap_sec_type(ieee) &
+		    (SEC_ALG_CCMP|SEC_ALG_TKIP)))
+			queue_delayed_work_rsl(ieee->wq,
+				       &ieee->associate_procedure_wq, 5);
 	}
-
 	return 0;
 }
 
-inline int rtllib_rx_frame_softmac(struct rtllib_device *ieee, struct sk_buff *skb,
-			struct rtllib_rx_stats *rx_stats, u16 type,
-			u16 stype)
+inline int rtllib_rx_frame_softmac(struct rtllib_device *ieee,
+				   struct sk_buff *skb,
+				   struct rtllib_rx_stats *rx_stats, u16 type,
+				   u16 stype)
 {
 	struct rtllib_hdr_3addr *header = (struct rtllib_hdr_3addr *) skb->data;
 
@@ -2480,44 +2434,31 @@ inline int rtllib_rx_frame_softmac(struct rtllib_device *ieee, struct sk_buff *s
 		return 0;
 
 	switch (WLAN_FC_GET_STYPE(header->frame_ctl)) {
-
-		case RTLLIB_STYPE_ASSOC_RESP:
-		case RTLLIB_STYPE_REASSOC_RESP:
-
-			if (rtllib_rx_assoc_resp(ieee, skb, rx_stats) == 1)
-				return 1;
-
-			break;
-
-		case RTLLIB_STYPE_ASSOC_REQ:
-		case RTLLIB_STYPE_REASSOC_REQ:
-
-			if ((ieee->softmac_features & IEEE_SOFTMAC_ASSOCIATE) &&
-				ieee->iw_mode == IW_MODE_MASTER)
-
-				rtllib_rx_assoc_rq(ieee, skb);
-			break;
-
-		case RTLLIB_STYPE_AUTH:
-
-			rtllib_rx_auth(ieee, skb, rx_stats);
-
-			break;
-		case RTLLIB_STYPE_DISASSOC:
-		case RTLLIB_STYPE_DEAUTH:
-
-			rtllib_rx_deauth(ieee, skb);
-
-			break;
-
-		case RTLLIB_STYPE_MANAGE_ACT:
-			rtllib_process_action(ieee,skb);
-			break;
-		default:
-			return -1;
-			break;
+	case RTLLIB_STYPE_ASSOC_RESP:
+	case RTLLIB_STYPE_REASSOC_RESP:
+		if (rtllib_rx_assoc_resp(ieee, skb, rx_stats) == 1)
+			return 1;
+		break;
+	case RTLLIB_STYPE_ASSOC_REQ:
+	case RTLLIB_STYPE_REASSOC_REQ:
+		if ((ieee->softmac_features & IEEE_SOFTMAC_ASSOCIATE) &&
+		     ieee->iw_mode == IW_MODE_MASTER)
+			rtllib_rx_assoc_rq(ieee, skb);
+		break;
+	case RTLLIB_STYPE_AUTH:
+		rtllib_rx_auth(ieee, skb, rx_stats);
+		break;
+	case RTLLIB_STYPE_DISASSOC:
+	case RTLLIB_STYPE_DEAUTH:
+		rtllib_rx_deauth(ieee, skb);
+		break;
+	case RTLLIB_STYPE_MANAGE_ACT:
+		rtllib_process_action(ieee, skb);
+		break;
+	default:
+		return -1;
+		break;
 	}
-
 	return 0;
 }
 
@@ -2548,43 +2489,43 @@ void rtllib_softmac_xmit(struct rtllib_txb *txb, struct rtllib_device *ieee)
 	struct cb_desc *tcb_desc = NULL;
 	unsigned long queue_len = 0;
 
-	spin_lock_irqsave(&ieee->lock,flags);
+	spin_lock_irqsave(&ieee->lock, flags);
 
 	/* called with 2nd parm 0, no tx mgmt lock required */
-	rtllib_sta_wakeup(ieee,0);
+	rtllib_sta_wakeup(ieee, 0);
 
 	/* update the tx status */
-	tcb_desc = (struct cb_desc *)(txb->fragments[0]->cb + MAX_DEV_ADDR_SIZE);
-	if (tcb_desc->bMulticast) {
+	tcb_desc = (struct cb_desc *)(txb->fragments[0]->cb +
+		   MAX_DEV_ADDR_SIZE);
+	if (tcb_desc->bMulticast)
 		ieee->stats.multicast++;
-	}
 
-	/* if xmit available, just xmit it immediately, else just insert it to the wait queue */
+	/* if xmit available, just xmit it immediately, else just insert it to
+	 * the wait queue */
 	for (i = 0; i < txb->nr_frags; i++) {
 		queue_len = skb_queue_len(&ieee->skb_waitQ[queue_index]);
 		if ((queue_len  != 0) ||\
-			(!ieee->check_nic_enough_desc(ieee->dev,queue_index))||\
-		       (ieee->queue_stop)) {
+		    (!ieee->check_nic_enough_desc(ieee->dev, queue_index)) ||
+		    (ieee->queue_stop)) {
 			/* insert the skb packet to the wait queue */
 			/* as for the completion function, it does not need
 			 * to check it any more.
 			 * */
 			if (queue_len < 200)
-			{
-				skb_queue_tail(&ieee->skb_waitQ[queue_index], txb->fragments[i]);
-			}else{
+				skb_queue_tail(&ieee->skb_waitQ[queue_index],
+					       txb->fragments[i]);
+			else
 				kfree_skb(txb->fragments[i]);
-			}
-		}else{
+		} else {
 			ieee->softmac_data_hard_start_xmit(
 					txb->fragments[i],
-					ieee->dev,ieee->rate);
+					ieee->dev, ieee->rate);
 		}
 	}
 
 	rtllib_txb_free(txb);
 
-	spin_unlock_irqrestore(&ieee->lock,flags);
+	spin_unlock_irqrestore(&ieee->lock, flags);
 
 }
 
@@ -2592,16 +2533,17 @@ void rtllib_softmac_xmit(struct rtllib_txb *txb, struct rtllib_device *ieee)
 void rtllib_resume_tx(struct rtllib_device *ieee)
 {
 	int i;
-	for (i = ieee->tx_pending.frag; i < ieee->tx_pending.txb->nr_frags; i++) {
+	for (i = ieee->tx_pending.frag; i < ieee->tx_pending.txb->nr_frags;
+	     i++) {
 
-		if (ieee->queue_stop){
+		if (ieee->queue_stop) {
 			ieee->tx_pending.frag = i;
 			return;
-		}else{
+		} else {
 
 			ieee->softmac_data_hard_start_xmit(
 				ieee->tx_pending.txb->fragments[i],
-				ieee->dev,ieee->rate);
+				ieee->dev, ieee->rate);
 			ieee->stats.tx_packets++;
 		}
 	}
@@ -2615,14 +2557,14 @@ void rtllib_reset_queue(struct rtllib_device *ieee)
 {
 	unsigned long flags;
 
-	spin_lock_irqsave(&ieee->lock,flags);
+	spin_lock_irqsave(&ieee->lock, flags);
 	init_mgmt_queue(ieee);
-	if (ieee->tx_pending.txb){
+	if (ieee->tx_pending.txb) {
 		rtllib_txb_free(ieee->tx_pending.txb);
 		ieee->tx_pending.txb = NULL;
 	}
 	ieee->queue_stop = 0;
-	spin_unlock_irqrestore(&ieee->lock,flags);
+	spin_unlock_irqrestore(&ieee->lock, flags);
 
 }
 
@@ -2633,13 +2575,14 @@ void rtllib_wake_queue(struct rtllib_device *ieee)
 	struct sk_buff *skb;
 	struct rtllib_hdr_3addr  *header;
 
-	spin_lock_irqsave(&ieee->lock,flags);
-	if (! ieee->queue_stop) goto exit;
+	spin_lock_irqsave(&ieee->lock, flags);
+	if (!ieee->queue_stop)
+		goto exit;
 
 	ieee->queue_stop = 0;
 
-	if (ieee->softmac_features & IEEE_SOFTMAC_SINGLE_QUEUE){
-		while (!ieee->queue_stop && (skb = dequeue_mgmt(ieee))){
+	if (ieee->softmac_features & IEEE_SOFTMAC_SINGLE_QUEUE) {
+		while (!ieee->queue_stop && (skb = dequeue_mgmt(ieee))) {
 
 			header = (struct rtllib_hdr_3addr  *) skb->data;
 
@@ -2650,26 +2593,27 @@ void rtllib_wake_queue(struct rtllib_device *ieee)
 			else
 				ieee->seq_ctrl[0]++;
 
-			ieee->softmac_data_hard_start_xmit(skb,ieee->dev,ieee->basic_rate);
+			ieee->softmac_data_hard_start_xmit(skb, ieee->dev,
+							   ieee->basic_rate);
 		}
 	}
 	if (!ieee->queue_stop && ieee->tx_pending.txb)
 		rtllib_resume_tx(ieee);
 
-	if (!ieee->queue_stop && netif_queue_stopped(ieee->dev)){
+	if (!ieee->queue_stop && netif_queue_stopped(ieee->dev)) {
 		ieee->softmac_stats.swtxawake++;
 		netif_wake_queue(ieee->dev);
 	}
 
-exit :
-	spin_unlock_irqrestore(&ieee->lock,flags);
+exit:
+	spin_unlock_irqrestore(&ieee->lock, flags);
 }
 
 
 void rtllib_stop_queue(struct rtllib_device *ieee)
 {
 
-	if (! netif_queue_stopped(ieee->dev)){
+	if (!netif_queue_stopped(ieee->dev)) {
 		netif_stop_queue(ieee->dev);
 		ieee->softmac_stats.swtxstop++;
 	}
@@ -2680,8 +2624,8 @@ void rtllib_stop_queue(struct rtllib_device *ieee)
 void rtllib_stop_all_queues(struct rtllib_device *ieee)
 {
 	unsigned int i;
-	for (i=0; i < ieee->dev->num_tx_queues; i++)
-                netdev_get_tx_queue(ieee->dev,i)->trans_start = jiffies;
+	for (i = 0; i < ieee->dev->num_tx_queues; i++)
+		netdev_get_tx_queue(ieee->dev, i)->trans_start = jiffies;
 
 	netif_tx_stop_all_queues(ieee->dev);
 }
@@ -2708,12 +2652,13 @@ void rtllib_start_master_bss(struct rtllib_device *ieee)
 {
 	ieee->assoc_id = 1;
 
-	if (ieee->current_network.ssid_len == 0){
+	if (ieee->current_network.ssid_len == 0) {
 		strncpy(ieee->current_network.ssid,
 			RTLLIB_DEFAULT_TX_ESSID,
 			IW_ESSID_MAX_SIZE);
 
-		ieee->current_network.ssid_len = strlen(RTLLIB_DEFAULT_TX_ESSID);
+		ieee->current_network.ssid_len =
+				 strlen(RTLLIB_DEFAULT_TX_ESSID);
 		ieee->ssid_set = 1;
 	}
 
@@ -2733,7 +2678,7 @@ void rtllib_start_master_bss(struct rtllib_device *ieee)
 void rtllib_start_monitor_mode(struct rtllib_device *ieee)
 {
 	/* reset hardware status */
-	if (ieee->raw_tx){
+	if (ieee->raw_tx) {
 		if (ieee->data_hard_resume)
 			ieee->data_hard_resume(ieee->dev);
 
@@ -2743,7 +2688,8 @@ void rtllib_start_monitor_mode(struct rtllib_device *ieee)
 
 void rtllib_start_ibss_wq(void *data)
 {
-	struct rtllib_device *ieee = container_of_dwork_rsl(data, struct rtllib_device, start_ibss_wq);
+	struct rtllib_device *ieee = container_of_dwork_rsl(data,
+				     struct rtllib_device, start_ibss_wq);
 	/* iwconfig mode ad-hoc will schedule this and return
 	 * on the other hand this will block further iwconfig SET
 	 * operations because of the wx_sem hold.
@@ -2751,14 +2697,14 @@ void rtllib_start_ibss_wq(void *data)
 	 * (abort) this wq (when syncro scanning) before sleeping
 	 * on the semaphore
 	 */
-	if (!ieee->proto_started){
-		printk("==========oh driver down return\n");
+	if (!ieee->proto_started) {
+		printk(KERN_INFO "==========oh driver down return\n");
 		return;
 	}
 	down(&ieee->wx_sem);
 
-	if (ieee->current_network.ssid_len == 0){
-		strcpy(ieee->current_network.ssid,RTLLIB_DEFAULT_TX_ESSID);
+	if (ieee->current_network.ssid_len == 0) {
+		strcpy(ieee->current_network.ssid, RTLLIB_DEFAULT_TX_ESSID);
 		ieee->current_network.ssid_len = strlen(RTLLIB_DEFAULT_TX_ESSID);
 		ieee->ssid_set = 1;
 	}
@@ -2787,47 +2733,50 @@ void rtllib_start_ibss_wq(void *data)
 		rtllib_start_scan_syncro(ieee, 0);
 
 	/* the network definitively is not here.. create a new cell */
-	if (ieee->state == RTLLIB_NOLINK){
-		printk("creating new IBSS cell\n");
+	if (ieee->state == RTLLIB_NOLINK) {
+		printk(KERN_INFO "creating new IBSS cell\n");
 		ieee->current_network.channel = ieee->IbssStartChnl;
 		if (!ieee->wap_set)
 			rtllib_randomize_cell(ieee);
 
-		if (ieee->modulation & RTLLIB_CCK_MODULATION){
+		if (ieee->modulation & RTLLIB_CCK_MODULATION) {
 
 			ieee->current_network.rates_len = 4;
 
-			ieee->current_network.rates[0] = RTLLIB_BASIC_RATE_MASK | RTLLIB_CCK_RATE_1MB;
-			ieee->current_network.rates[1] = RTLLIB_BASIC_RATE_MASK | RTLLIB_CCK_RATE_2MB;
-			ieee->current_network.rates[2] = RTLLIB_BASIC_RATE_MASK | RTLLIB_CCK_RATE_5MB;
-			ieee->current_network.rates[3] = RTLLIB_BASIC_RATE_MASK | RTLLIB_CCK_RATE_11MB;
+			ieee->current_network.rates[0] =
+				 RTLLIB_BASIC_RATE_MASK | RTLLIB_CCK_RATE_1MB;
+			ieee->current_network.rates[1] =
+				 RTLLIB_BASIC_RATE_MASK | RTLLIB_CCK_RATE_2MB;
+			ieee->current_network.rates[2] =
+				 RTLLIB_BASIC_RATE_MASK | RTLLIB_CCK_RATE_5MB;
+			ieee->current_network.rates[3] =
+				 RTLLIB_BASIC_RATE_MASK | RTLLIB_CCK_RATE_11MB;
 
-		}else
+		} else
 			ieee->current_network.rates_len = 0;
 
-		if (ieee->modulation & RTLLIB_OFDM_MODULATION){
+		if (ieee->modulation & RTLLIB_OFDM_MODULATION) {
 			ieee->current_network.rates_ex_len = 8;
 
-			/*ieee->current_network.rates_ex[0] = RTLLIB_BASIC_RATE_MASK | RTLLIB_OFDM_RATE_6MB;
-			ieee->current_network.rates_ex[1] = RTLLIB_BASIC_RATE_MASK | RTLLIB_OFDM_RATE_9MB;
-			ieee->current_network.rates_ex[2] = RTLLIB_BASIC_RATE_MASK | RTLLIB_OFDM_RATE_12MB;
-			ieee->current_network.rates_ex[3] = RTLLIB_BASIC_RATE_MASK | RTLLIB_OFDM_RATE_18MB;
-			ieee->current_network.rates_ex[4] = RTLLIB_BASIC_RATE_MASK | RTLLIB_OFDM_RATE_24MB;
-			ieee->current_network.rates_ex[5] = RTLLIB_BASIC_RATE_MASK | RTLLIB_OFDM_RATE_36MB;
-			ieee->current_network.rates_ex[6] = RTLLIB_BASIC_RATE_MASK | RTLLIB_OFDM_RATE_48MB;
-			ieee->current_network.rates_ex[7] = RTLLIB_BASIC_RATE_MASK | RTLLIB_OFDM_RATE_54MB;*/
-
-			ieee->current_network.rates_ex[0] = RTLLIB_OFDM_RATE_6MB;
-			ieee->current_network.rates_ex[1] = RTLLIB_OFDM_RATE_9MB;
-			ieee->current_network.rates_ex[2] = RTLLIB_OFDM_RATE_12MB;
-			ieee->current_network.rates_ex[3] = RTLLIB_OFDM_RATE_18MB;
-			ieee->current_network.rates_ex[4] = RTLLIB_OFDM_RATE_24MB;
-			ieee->current_network.rates_ex[5] = RTLLIB_OFDM_RATE_36MB;
-			ieee->current_network.rates_ex[6] = RTLLIB_OFDM_RATE_48MB;
-			ieee->current_network.rates_ex[7] = RTLLIB_OFDM_RATE_54MB;
+			ieee->current_network.rates_ex[0] =
+						 RTLLIB_OFDM_RATE_6MB;
+			ieee->current_network.rates_ex[1] =
+						 RTLLIB_OFDM_RATE_9MB;
+			ieee->current_network.rates_ex[2] =
+						 RTLLIB_OFDM_RATE_12MB;
+			ieee->current_network.rates_ex[3] =
+						 RTLLIB_OFDM_RATE_18MB;
+			ieee->current_network.rates_ex[4] =
+						 RTLLIB_OFDM_RATE_24MB;
+			ieee->current_network.rates_ex[5] =
+						 RTLLIB_OFDM_RATE_36MB;
+			ieee->current_network.rates_ex[6] =
+						 RTLLIB_OFDM_RATE_48MB;
+			ieee->current_network.rates_ex[7] =
+						 RTLLIB_OFDM_RATE_54MB;
 
 			ieee->rate = 108;
-		}else{
+		} else {
 			ieee->current_network.rates_ex_len = 0;
 			ieee->rate = 22;
 		}
@@ -2839,20 +2788,21 @@ void rtllib_start_ibss_wq(void *data)
 		ieee->current_network.capability = WLAN_CAPABILITY_IBSS;
 	}
 
-	printk("%s(): ieee->mode = %d\n", __func__, ieee->mode);
+	printk(KERN_INFO "%s(): ieee->mode = %d\n", __func__, ieee->mode);
 	if ((ieee->mode == IEEE_N_24G) || (ieee->mode == IEEE_N_5G))
 		HTUseDefaultSetting(ieee);
 	else
 		ieee->pHTInfo->bCurrentHTSupport = false;
 
-	ieee->SetHwRegHandler(ieee->dev, HW_VAR_MEDIA_STATUS, (u8 *)(&ieee->state));
+	ieee->SetHwRegHandler(ieee->dev, HW_VAR_MEDIA_STATUS,
+			      (u8 *)(&ieee->state));
 
 	ieee->state = RTLLIB_LINKED;
 	ieee->link_change(ieee->dev);
 
 	HTSetConnectBwMode(ieee, HT_CHANNEL_WIDTH_20, HT_EXTCHNL_OFFSET_NO_EXT);
 	if (ieee->LedControlHandler != NULL)
-	        ieee->LedControlHandler(ieee->dev,LED_CTL_LINK);
+		ieee->LedControlHandler(ieee->dev, LED_CTL_LINK);
 
 	rtllib_start_send_beacons(ieee);
 
@@ -2875,12 +2825,9 @@ inline void rtllib_start_ibss(struct rtllib_device *ieee)
 void rtllib_start_bss(struct rtllib_device *ieee)
 {
 	unsigned long flags;
-	if (IS_DOT11D_ENABLE(ieee) && !IS_COUNTRY_IE_VALID(ieee))
-	{
-		if (! ieee->bGlobalDomain)
-		{
+	if (IS_DOT11D_ENABLE(ieee) && !IS_COUNTRY_IE_VALID(ieee)) {
+		if (!ieee->bGlobalDomain)
 			return;
-		}
 	}
 	/* check if we have already found the net we
 	 * are interested in (if any).
@@ -2898,15 +2845,15 @@ void rtllib_start_bss(struct rtllib_device *ieee)
 	 */
 	spin_lock_irqsave(&ieee->lock, flags);
 
-	if (ieee->state == RTLLIB_NOLINK) {
+	if (ieee->state == RTLLIB_NOLINK)
 		rtllib_start_scan(ieee);
-	}
 	spin_unlock_irqrestore(&ieee->lock, flags);
 }
 
 void rtllib_link_change_wq(void *data)
 {
-	struct rtllib_device *ieee = container_of_dwork_rsl(data, struct rtllib_device, link_change_wq);
+	struct rtllib_device *ieee = container_of_dwork_rsl(data,
+				     struct rtllib_device, link_change_wq);
 	ieee->link_change(ieee->dev);
 }
 /* called only in userspace context */
@@ -2931,7 +2878,8 @@ void rtllib_disassociate(struct rtllib_device *ieee)
 
 void rtllib_associate_retry_wq(void *data)
 {
-	struct rtllib_device *ieee = container_of_dwork_rsl(data, struct rtllib_device, associate_retry_wq);
+	struct rtllib_device *ieee = container_of_dwork_rsl(data,
+				     struct rtllib_device, associate_retry_wq);
 	unsigned long flags;
 
 	down(&ieee->wx_sem);
@@ -2962,9 +2910,7 @@ void rtllib_associate_retry_wq(void *data)
 	spin_lock_irqsave(&ieee->lock, flags);
 
 	if (ieee->state == RTLLIB_NOLINK)
-	{
 		rtllib_start_scan(ieee);
-	}
 	spin_unlock_irqrestore(&ieee->lock, flags);
 
 	ieee->beinretry = false;
@@ -2974,7 +2920,7 @@ void rtllib_associate_retry_wq(void *data)
 
 struct sk_buff *rtllib_get_beacon_(struct rtllib_device *ieee)
 {
-	u8 broadcast_addr[] = {0xff,0xff,0xff,0xff,0xff,0xff};
+	u8 broadcast_addr[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
 
 	struct sk_buff *skb;
 	struct rtllib_probe_response *b;
@@ -3010,11 +2956,12 @@ struct sk_buff *rtllib_get_beacon(struct rtllib_device *ieee)
 	return skb;
 }
 
-void rtllib_softmac_stop_protocol(struct rtllib_device *ieee, u8 mesh_flag, u8 shutdown)
+void rtllib_softmac_stop_protocol(struct rtllib_device *ieee, u8 mesh_flag,
+				  u8 shutdown)
 {
 	rtllib_stop_scan_syncro(ieee);
 	down(&ieee->wx_sem);
-	rtllib_stop_protocol(ieee,shutdown);
+	rtllib_stop_protocol(ieee, shutdown);
 	up(&ieee->wx_sem);
 }
 
@@ -3024,8 +2971,8 @@ void rtllib_stop_protocol(struct rtllib_device *ieee, u8 shutdown)
 	if (!ieee->proto_started)
 		return;
 
-	if (shutdown){
-	ieee->proto_started = 0;
+	if (shutdown) {
+		ieee->proto_started = 0;
 		ieee->proto_stoppping = 1;
 		if (ieee->rtllib_ips_leave != NULL)
 			ieee->rtllib_ips_leave(ieee->dev);
@@ -3041,26 +2988,22 @@ void rtllib_stop_protocol(struct rtllib_device *ieee, u8 shutdown)
 	if (ieee->state <= RTLLIB_ASSOCIATING_AUTHENTICATED)
 		ieee->state = RTLLIB_NOLINK;
 
-	if (ieee->state == RTLLIB_LINKED){
+	if (ieee->state == RTLLIB_LINKED) {
 		if (ieee->iw_mode == IW_MODE_INFRA)
-			SendDisassociation(ieee,1,deauth_lv_ss);
+			SendDisassociation(ieee, 1, deauth_lv_ss);
 		rtllib_disassociate(ieee);
 	}
 
-	if (shutdown){
+	if (shutdown) {
 		RemoveAllTS(ieee);
 		ieee->proto_stoppping = 0;
 	}
-	if (ieee->assocreq_ies) {
-		kfree(ieee->assocreq_ies);
-		ieee->assocreq_ies = NULL;
-		ieee->assocreq_ies_len = 0;
-	}
-	if (ieee->assocresp_ies) {
-		kfree(ieee->assocresp_ies);
-		ieee->assocresp_ies = NULL;
-		ieee->assocresp_ies_len = 0;
-	}
+	kfree(ieee->assocreq_ies);
+	ieee->assocreq_ies = NULL;
+	ieee->assocreq_ies_len = 0;
+	kfree(ieee->assocresp_ies);
+	ieee->assocresp_ies = NULL;
+	ieee->assocresp_ies_len = 0;
 }
 
 void rtllib_softmac_start_protocol(struct rtllib_device *ieee, u8 mesh_flag)
@@ -3087,7 +3030,7 @@ void rtllib_start_protocol(struct rtllib_device *ieee)
 			ch++;
 			if (ch > MAX_CHANNEL_NUMBER)
 				return; /* no channel found */
-		} while(!ieee->active_channel_map[ch]);
+		} while (!ieee->active_channel_map[ch]);
 		ieee->current_network.channel = ch;
 	}
 
@@ -3130,20 +3073,19 @@ void rtllib_softmac_init(struct rtllib_device *ieee)
 	memset(&ieee->current_network, 0, sizeof(struct rtllib_network));
 
 	ieee->state = RTLLIB_NOLINK;
-	for (i = 0; i < 5; i++) {
-	  ieee->seq_ctrl[i] = 0;
-	}
+	for (i = 0; i < 5; i++)
+		ieee->seq_ctrl[i] = 0;
 	ieee->pDot11dInfo = kmalloc(sizeof(struct rt_dot11d_info), GFP_ATOMIC);
 	if (!ieee->pDot11dInfo)
 		RTLLIB_DEBUG(RTLLIB_DL_ERR, "can't alloc memory for DOT11D\n");
 	memset(ieee->pDot11dInfo, 0, sizeof(struct rt_dot11d_info));
 	ieee->LinkDetectInfo.SlotIndex = 0;
 	ieee->LinkDetectInfo.SlotNum = 2;
-	ieee->LinkDetectInfo.NumRecvBcnInPeriod=0;
-        ieee->LinkDetectInfo.NumRecvDataInPeriod=0;
-	ieee->LinkDetectInfo.NumTxOkInPeriod =0;
-	ieee->LinkDetectInfo.NumRxOkInPeriod =0;
-	ieee->LinkDetectInfo.NumRxUnicastOkInPeriod=0;
+	ieee->LinkDetectInfo.NumRecvBcnInPeriod = 0;
+	ieee->LinkDetectInfo.NumRecvDataInPeriod = 0;
+	ieee->LinkDetectInfo.NumTxOkInPeriod = 0;
+	ieee->LinkDetectInfo.NumRxOkInPeriod = 0;
+	ieee->LinkDetectInfo.NumRxUnicastOkInPeriod = 0;
 	ieee->bIsAggregateFrame = false;
 	ieee->assoc_id = 0;
 	ieee->queue_stop = 0;
@@ -3158,13 +3100,13 @@ void rtllib_softmac_init(struct rtllib_device *ieee)
 	ieee->ps = RTLLIB_PS_DISABLED;
 	ieee->sta_sleep = LPS_IS_WAKE;
 
-	ieee->Regdot11HTOperationalRateSet[0]= 0xff;
-	ieee->Regdot11HTOperationalRateSet[1]= 0xff;
-	ieee->Regdot11HTOperationalRateSet[4]= 0x01;
+	ieee->Regdot11HTOperationalRateSet[0] = 0xff;
+	ieee->Regdot11HTOperationalRateSet[1] = 0xff;
+	ieee->Regdot11HTOperationalRateSet[4] = 0x01;
 
-	ieee->Regdot11TxHTOperationalRateSet[0]= 0xff;
-	ieee->Regdot11TxHTOperationalRateSet[1]= 0xff;
-	ieee->Regdot11TxHTOperationalRateSet[4]= 0x01;
+	ieee->Regdot11TxHTOperationalRateSet[0] = 0xff;
+	ieee->Regdot11TxHTOperationalRateSet[1] = 0xff;
+	ieee->Regdot11TxHTOperationalRateSet[4] = 0x01;
 
 	ieee->FirstIe_InScan = false;
 	ieee->actscanning = false;
@@ -3191,18 +3133,26 @@ void rtllib_softmac_init(struct rtllib_device *ieee)
 
 	ieee->wq = create_workqueue(DRV_NAME);
 
-	INIT_DELAYED_WORK_RSL(&ieee->link_change_wq,(void*)rtllib_link_change_wq,ieee);
-	INIT_DELAYED_WORK_RSL(&ieee->start_ibss_wq,(void*)rtllib_start_ibss_wq,ieee);
-	INIT_WORK_RSL(&ieee->associate_complete_wq, (void*)rtllib_associate_complete_wq,ieee);
-	INIT_DELAYED_WORK_RSL(&ieee->associate_procedure_wq, (void*)rtllib_associate_procedure_wq,ieee);
-	INIT_DELAYED_WORK_RSL(&ieee->softmac_scan_wq,(void*)rtllib_softmac_scan_wq,ieee);
-	INIT_DELAYED_WORK_RSL(&ieee->softmac_hint11d_wq,(void*)rtllib_softmac_hint11d_wq,ieee);
-	INIT_DELAYED_WORK_RSL(&ieee->associate_retry_wq, (void*)rtllib_associate_retry_wq,ieee);
-	INIT_WORK_RSL(&ieee->wx_sync_scan_wq,(void*)rtllib_wx_sync_scan_wq,ieee);
+	INIT_DELAYED_WORK_RSL(&ieee->link_change_wq,
+			      (void *)rtllib_link_change_wq, ieee);
+	INIT_DELAYED_WORK_RSL(&ieee->start_ibss_wq,
+			      (void *)rtllib_start_ibss_wq, ieee);
+	INIT_WORK_RSL(&ieee->associate_complete_wq,
+		      (void *)rtllib_associate_complete_wq, ieee);
+	INIT_DELAYED_WORK_RSL(&ieee->associate_procedure_wq,
+			      (void *)rtllib_associate_procedure_wq, ieee);
+	INIT_DELAYED_WORK_RSL(&ieee->softmac_scan_wq,
+			      (void *)rtllib_softmac_scan_wq, ieee);
+	INIT_DELAYED_WORK_RSL(&ieee->softmac_hint11d_wq,
+			      (void *)rtllib_softmac_hint11d_wq, ieee);
+	INIT_DELAYED_WORK_RSL(&ieee->associate_retry_wq,
+			      (void *)rtllib_associate_retry_wq, ieee);
+	INIT_WORK_RSL(&ieee->wx_sync_scan_wq, (void *)rtllib_wx_sync_scan_wq,
+		      ieee);
 
 	sema_init(&ieee->wx_sem, 1);
 	sema_init(&ieee->scan_sem, 1);
-	sema_init(&ieee->ips_sem,1);
+	sema_init(&ieee->ips_sem, 1);
 
 	spin_lock_init(&ieee->mgmt_tx_lock);
 	spin_lock_init(&ieee->beacon_lock);
@@ -3216,8 +3166,7 @@ void rtllib_softmac_init(struct rtllib_device *ieee)
 void rtllib_softmac_free(struct rtllib_device *ieee)
 {
 	down(&ieee->wx_sem);
-	if (NULL != ieee->pDot11dInfo)
-	{
+	if (NULL != ieee->pDot11dInfo) {
 		kfree(ieee->pDot11dInfo);
 		ieee->pDot11dInfo = NULL;
 	}
@@ -3229,8 +3178,8 @@ void rtllib_softmac_free(struct rtllib_device *ieee)
 }
 
 /********************************************************
- * Start of WPA code.                                   *
- * this is stolen from the ipw2200 driver               *
+ * Start of WPA code.				        *
+ * this is stolen from the ipw2200 driver	        *
  ********************************************************/
 
 
@@ -3238,14 +3187,15 @@ static int rtllib_wpa_enable(struct rtllib_device *ieee, int value)
 {
 	/* This is called when wpa_supplicant loads and closes the driver
 	 * interface. */
-	printk("%s WPA\n",value ? "enabling" : "disabling");
+	printk(KERN_INFO "%s WPA\n", value ? "enabling" : "disabling");
 	ieee->wpa_enabled = value;
 	memset(ieee->ap_mac_addr, 0, 6);
 	return 0;
 }
 
 
-void rtllib_wpa_assoc_frame(struct rtllib_device *ieee, char *wpa_ie, int wpa_ie_len)
+void rtllib_wpa_assoc_frame(struct rtllib_device *ieee, char *wpa_ie,
+			    int wpa_ie_len)
 {
 	/* make sure WPA is enabled */
 	rtllib_wpa_enable(ieee, 1);
@@ -3268,7 +3218,7 @@ static int rtllib_wpa_mlme(struct rtllib_device *ieee, int command, int reason)
 		break;
 
 	default:
-		printk("Unknown MLME request: %d\n", command);
+		printk(KERN_INFO "Unknown MLME request: %d\n", command);
 		ret = -EOPNOTSUPP;
 	}
 
@@ -3319,12 +3269,11 @@ static int rtllib_wpa_set_auth_algs(struct rtllib_device *ieee, int value)
 		sec.auth_mode = WLAN_AUTH_SHARED_KEY;
 		ieee->open_wep = 0;
 		ieee->auth_mode = 1;
-	} else if (value & AUTH_ALG_OPEN_SYSTEM){
+	} else if (value & AUTH_ALG_OPEN_SYSTEM) {
 		sec.auth_mode = WLAN_AUTH_OPEN;
 		ieee->open_wep = 1;
 		ieee->auth_mode = 0;
-	}
-	else if (value & AUTH_ALG_LEAP){
+	} else if (value & AUTH_ALG_LEAP) {
 		sec.auth_mode = WLAN_AUTH_LEAP  >> 6;
 		ieee->open_wep = 1;
 		ieee->auth_mode = 2;
@@ -3339,7 +3288,7 @@ static int rtllib_wpa_set_auth_algs(struct rtllib_device *ieee, int value)
 
 static int rtllib_wpa_set_param(struct rtllib_device *ieee, u8 name, u32 value)
 {
-	int ret=0;
+	int ret = 0;
 	unsigned long flags;
 
 	switch (name) {
@@ -3348,11 +3297,11 @@ static int rtllib_wpa_set_param(struct rtllib_device *ieee, u8 name, u32 value)
 		break;
 
 	case IEEE_PARAM_TKIP_COUNTERMEASURES:
-		ieee->tkip_countermeasures=value;
+		ieee->tkip_countermeasures = value;
 		break;
 
-		case IEEE_PARAM_DROP_UNENCRYPTED:
-		{
+	case IEEE_PARAM_DROP_UNENCRYPTED:
+	{
 		/* HACK:
 		 *
 		 * wpa_supplicant calls set_wpa_enabled when the driver
@@ -3375,8 +3324,7 @@ static int rtllib_wpa_set_param(struct rtllib_device *ieee, u8 name, u32 value)
 		if (!value) {
 			sec.flags |= SEC_LEVEL;
 			sec.level = SEC_LEVEL_0;
-		}
-		else {
+		} else {
 			sec.flags |= SEC_LEVEL;
 			sec.level = SEC_LEVEL_1;
 		}
@@ -3386,7 +3334,7 @@ static int rtllib_wpa_set_param(struct rtllib_device *ieee, u8 name, u32 value)
 	}
 
 	case IEEE_PARAM_PRIVACY_INVOKED:
-		ieee->privacy_invoked=value;
+		ieee->privacy_invoked = value;
 		break;
 
 	case IEEE_PARAM_AUTH_ALGS:
@@ -3394,15 +3342,15 @@ static int rtllib_wpa_set_param(struct rtllib_device *ieee, u8 name, u32 value)
 		break;
 
 	case IEEE_PARAM_IEEE_802_1X:
-		ieee->ieee802_1x=value;
+		ieee->ieee802_1x = value;
 		break;
 	case IEEE_PARAM_WPAX_SELECT:
-		spin_lock_irqsave(&ieee->wpax_suitlist_lock,flags);
-		spin_unlock_irqrestore(&ieee->wpax_suitlist_lock,flags);
+		spin_lock_irqsave(&ieee->wpax_suitlist_lock, flags);
+		spin_unlock_irqrestore(&ieee->wpax_suitlist_lock, flags);
 		break;
 
 	default:
-		printk("Unknown WPA param: %d\n",name);
+		printk(KERN_INFO "Unknown WPA param: %d\n", name);
 		ret = -EOPNOTSUPP;
 	}
 
@@ -3411,7 +3359,8 @@ static int rtllib_wpa_set_param(struct rtllib_device *ieee, u8 name, u32 value)
 
 /* implementation borrowed from hostap driver */
 static int rtllib_wpa_set_encryption(struct rtllib_device *ieee,
-				  struct ieee_param *param, int param_len, u8 is_mesh)
+				  struct ieee_param *param, int param_len,
+				  u8 is_mesh)
 {
 	int ret = 0;
 	struct rtllib_crypto_ops *ops;
@@ -3427,7 +3376,7 @@ static int rtllib_wpa_set_encryption(struct rtllib_device *ieee,
 	if (param_len !=
 	    (int) ((char *) param->u.crypt.key - (char *) param) +
 	    param->u.crypt.key_len) {
-		printk("Len mismatch %d, %d\n", param_len,
+		printk(KERN_INFO "Len mismatch %d, %d\n", param_len,
 			       param->u.crypt.key_len);
 		return -EINVAL;
 	}
@@ -3470,7 +3419,8 @@ static int rtllib_wpa_set_encryption(struct rtllib_device *ieee,
 		ops = rtllib_get_crypto_ops(param->u.crypt.alg);
 	}
 	if (ops == NULL) {
-		printk("unknown crypto alg '%s'\n", param->u.crypt.alg);
+		printk(KERN_INFO "unknown crypto alg '%s'\n",
+		       param->u.crypt.alg);
 		param->u.crypt.err = IEEE_CRYPT_ERR_UNKNOWN_ALG;
 		ret = -EINVAL;
 		goto done;
@@ -3506,7 +3456,7 @@ static int rtllib_wpa_set_encryption(struct rtllib_device *ieee,
 	    (*crypt)->ops->set_key(param->u.crypt.key,
 	    param->u.crypt.key_len, param->u.crypt.seq,
 	    (*crypt)->priv) < 0) {
-		printk("key setting failed\n");
+		printk(KERN_INFO "key setting failed\n");
 		param->u.crypt.err = IEEE_CRYPT_ERR_KEY_SET_FAILED;
 		ret = -EINVAL;
 		goto done;
@@ -3551,7 +3501,7 @@ static int rtllib_wpa_set_encryption(struct rtllib_device *ieee,
 	    ieee->iw_mode != IW_MODE_INFRA &&
 	    ieee->reset_port &&
 	    ieee->reset_port(ieee->dev)) {
-		printk("reset_port failed\n");
+		printk(KERN_INFO "reset_port failed\n");
 		param->u.crypt.err = IEEE_CRYPT_ERR_CARD_CONF_FAILED;
 		return -EINVAL;
 	}
@@ -3559,7 +3509,7 @@ static int rtllib_wpa_set_encryption(struct rtllib_device *ieee,
 	return ret;
 }
 
-inline struct sk_buff *rtllib_disauth_skb( struct rtllib_network *beacon,
+inline struct sk_buff *rtllib_disauth_skb(struct rtllib_network *beacon,
 		struct rtllib_device *ieee, u16 asRsn)
 {
 	struct sk_buff *skb;
@@ -3567,13 +3517,13 @@ inline struct sk_buff *rtllib_disauth_skb( struct rtllib_network *beacon,
 	int len = sizeof(struct rtllib_disauth) + ieee->tx_headroom;
 
 	skb = dev_alloc_skb(len);
-	if (!skb) {
+	if (!skb)
 		return NULL;
-	}
 
 	skb_reserve(skb, ieee->tx_headroom);
 
-	disauth = (struct rtllib_disauth *) skb_put(skb,sizeof(struct rtllib_disauth));
+	disauth = (struct rtllib_disauth *) skb_put(skb,
+		  sizeof(struct rtllib_disauth));
 	disauth->header.frame_ctl = cpu_to_le16(RTLLIB_STYPE_DEAUTH);
 	disauth->header.duration_id = 0;
 
@@ -3585,7 +3535,7 @@ inline struct sk_buff *rtllib_disauth_skb( struct rtllib_network *beacon,
 	return skb;
 }
 
-inline struct sk_buff *rtllib_disassociate_skb( struct rtllib_network *beacon,
+inline struct sk_buff *rtllib_disassociate_skb(struct rtllib_network *beacon,
 		struct rtllib_device *ieee, u16 asRsn)
 {
 	struct sk_buff *skb;
@@ -3593,13 +3543,13 @@ inline struct sk_buff *rtllib_disassociate_skb( struct rtllib_network *beacon,
 	int len = sizeof(struct rtllib_disassoc) + ieee->tx_headroom;
 	skb = dev_alloc_skb(len);
 
-	if (!skb) {
+	if (!skb)
 		return NULL;
-	}
 
 	skb_reserve(skb, ieee->tx_headroom);
 
-	disass = (struct rtllib_disassoc *) skb_put(skb,sizeof(struct rtllib_disassoc));
+	disass = (struct rtllib_disassoc *) skb_put(skb,
+					 sizeof(struct rtllib_disassoc));
 	disass->header.frame_ctl = cpu_to_le16(RTLLIB_STYPE_DISASSOC);
 	disass->header.duration_id = 0;
 
@@ -3616,36 +3566,36 @@ void SendDisassociation(struct rtllib_device *ieee, bool deauth, u16 asRsn)
 	struct rtllib_network *beacon = &ieee->current_network;
 	struct sk_buff *skb;
 
-	if (deauth) {
-		skb = rtllib_disauth_skb(beacon,ieee,asRsn);
-	} else {
-		skb = rtllib_disassociate_skb(beacon,ieee,asRsn);
-	}
+	if (deauth)
+		skb = rtllib_disauth_skb(beacon, ieee, asRsn);
+	else
+		skb = rtllib_disassociate_skb(beacon, ieee, asRsn);
 
-	if (skb){
+	if (skb)
 		softmac_mgmt_xmit(skb, ieee);
-	}
 }
 
 u8 rtllib_ap_sec_type(struct rtllib_device *ieee)
 {
-	static u8 ccmp_ie[4] = {0x00,0x50,0xf2,0x04};
+	static u8 ccmp_ie[4] = {0x00, 0x50, 0xf2, 0x04};
 	static u8 ccmp_rsn_ie[4] = {0x00, 0x0f, 0xac, 0x04};
-	int wpa_ie_len= ieee->wpa_ie_len;
-	struct rtllib_crypt_data* crypt;
+	int wpa_ie_len = ieee->wpa_ie_len;
+	struct rtllib_crypt_data *crypt;
 	int encrypt;
 
 	crypt = ieee->crypt[ieee->tx_keyidx];
-	encrypt = (ieee->current_network.capability & WLAN_CAPABILITY_PRIVACY) ||\
-		  (ieee->host_encrypt && crypt && crypt->ops && \
-		   (0 == strcmp(crypt->ops->name,"WEP")));
+	encrypt = (ieee->current_network.capability & WLAN_CAPABILITY_PRIVACY)
+		  || (ieee->host_encrypt && crypt && crypt->ops &&
+		  (0 == strcmp(crypt->ops->name, "WEP")));
 
 	/* simply judge  */
 	if (encrypt && (wpa_ie_len == 0)) {
 		return SEC_ALG_WEP;
 	} else if ((wpa_ie_len != 0)) {
-		if (((ieee->wpa_ie[0] == 0xdd) && (!memcmp(&(ieee->wpa_ie[14]),ccmp_ie,4))) ||
-				((ieee->wpa_ie[0] == 0x30) && (!memcmp(&ieee->wpa_ie[10],ccmp_rsn_ie, 4))))
+		if (((ieee->wpa_ie[0] == 0xdd) &&
+		    (!memcmp(&(ieee->wpa_ie[14]), ccmp_ie, 4))) ||
+		    ((ieee->wpa_ie[0] == 0x30) &&
+		    (!memcmp(&ieee->wpa_ie[10], ccmp_rsn_ie, 4))))
 			return SEC_ALG_CCMP;
 		else
 			return SEC_ALG_TKIP;
@@ -3654,20 +3604,21 @@ u8 rtllib_ap_sec_type(struct rtllib_device *ieee)
 	}
 }
 
-int rtllib_wpa_supplicant_ioctl(struct rtllib_device *ieee, struct iw_point *p, u8 is_mesh)
+int rtllib_wpa_supplicant_ioctl(struct rtllib_device *ieee, struct iw_point *p,
+				u8 is_mesh)
 {
 	struct ieee_param *param;
-	int ret=0;
+	int ret = 0;
 
 	down(&ieee->wx_sem);
 
-	if (p->length < sizeof(struct ieee_param) || !p->pointer){
+	if (p->length < sizeof(struct ieee_param) || !p->pointer) {
 		ret = -EINVAL;
 		goto out;
 	}
 
-	param = (struct ieee_param *)kmalloc(p->length, GFP_KERNEL);
-	if (param == NULL){
+	param = kmalloc(p->length, GFP_KERNEL);
+	if (param == NULL) {
 		ret = -ENOMEM;
 		goto out;
 	}
@@ -3678,7 +3629,6 @@ int rtllib_wpa_supplicant_ioctl(struct rtllib_device *ieee, struct iw_point *p,
 	}
 
 	switch (param->cmd) {
-
 	case IEEE_CMD_SET_WPA_PARAM:
 		ret = rtllib_wpa_set_param(ieee, param->u.wpa_param.name,
 					param->u.wpa_param.value);
@@ -3698,7 +3648,8 @@ int rtllib_wpa_supplicant_ioctl(struct rtllib_device *ieee, struct iw_point *p,
 		break;
 
 	default:
-		printk("Unknown WPA supplicant request: %d\n",param->cmd);
+		printk(KERN_INFO "Unknown WPA supplicant request: %d\n",
+		       param->cmd);
 		ret = -EOPNOTSUPP;
 		break;
 	}
@@ -3713,8 +3664,7 @@ int rtllib_wpa_supplicant_ioctl(struct rtllib_device *ieee, struct iw_point *p,
 	return ret;
 }
 
-void
-rtllib_MgntDisconnectIBSS(struct rtllib_device* rtllib)
+void rtllib_MgntDisconnectIBSS(struct rtllib_device *rtllib)
 {
 	u8	OpMode;
 	u8	i;
@@ -3722,26 +3672,25 @@ rtllib_MgntDisconnectIBSS(struct rtllib_device* rtllib)
 
 	rtllib->state = RTLLIB_NOLINK;
 
-	for (i=0;i<6;i++)  rtllib->current_network.bssid[i]= 0x55;
+	for (i = 0; i < 6; i++)
+		rtllib->current_network.bssid[i] = 0x55;
 
 	rtllib->OpMode = RT_OP_MODE_NO_LINK;
-	rtllib->SetHwRegHandler(rtllib->dev, HW_VAR_BSSID, rtllib->current_network.bssid);
+	rtllib->SetHwRegHandler(rtllib->dev, HW_VAR_BSSID,
+				rtllib->current_network.bssid);
 	OpMode = RT_OP_MODE_NO_LINK;
 	rtllib->SetHwRegHandler(rtllib->dev, HW_VAR_MEDIA_STATUS, &OpMode);
 	rtllib_stop_send_beacons(rtllib);
 
 	bFilterOutNonAssociatedBSSID = false;
-	rtllib->SetHwRegHandler(rtllib->dev, HW_VAR_CECHK_BSSID, (u8*)(&bFilterOutNonAssociatedBSSID));
+	rtllib->SetHwRegHandler(rtllib->dev, HW_VAR_CECHK_BSSID,
+				(u8 *)(&bFilterOutNonAssociatedBSSID));
 	notify_wx_assoc_event(rtllib);
 
 }
 
-void
-rtllib_MlmeDisassociateRequest(
-	struct rtllib_device* rtllib,
-	u8*		asSta,
-	u8		asRsn
-	)
+void rtllib_MlmeDisassociateRequest(struct rtllib_device *rtllib, u8 *asSta,
+				    u8 asRsn)
 {
 	u8 i;
 	u8	OpMode;
@@ -3749,17 +3698,19 @@ rtllib_MlmeDisassociateRequest(
 	RemovePeerTS(rtllib, asSta);
 
 
-	if (memcpy(rtllib->current_network.bssid,asSta,6) == 0)
-	{
+	if (memcpy(rtllib->current_network.bssid, asSta, 6) == 0) {
 		rtllib->state = RTLLIB_NOLINK;
 
-		for (i=0;i<6;i++)  rtllib->current_network.bssid[i] = 0x22;
+		for (i = 0; i < 6; i++)
+			rtllib->current_network.bssid[i] = 0x22;
 		OpMode = RT_OP_MODE_NO_LINK;
 		rtllib->OpMode = RT_OP_MODE_NO_LINK;
-		rtllib->SetHwRegHandler(rtllib->dev, HW_VAR_MEDIA_STATUS, (u8 *)(&OpMode) );
+		rtllib->SetHwRegHandler(rtllib->dev, HW_VAR_MEDIA_STATUS,
+					(u8 *)(&OpMode));
 		rtllib_disassociate(rtllib);
 
-		rtllib->SetHwRegHandler(rtllib->dev, HW_VAR_BSSID, rtllib->current_network.bssid);
+		rtllib->SetHwRegHandler(rtllib->dev, HW_VAR_BSSID,
+					rtllib->current_network.bssid);
 
 	}
 
@@ -3767,40 +3718,31 @@ rtllib_MlmeDisassociateRequest(
 
 void
 rtllib_MgntDisconnectAP(
-	struct rtllib_device* rtllib,
+	struct rtllib_device *rtllib,
 	u8 asRsn
 )
 {
 	bool bFilterOutNonAssociatedBSSID = false;
 
 	bFilterOutNonAssociatedBSSID = false;
-	rtllib->SetHwRegHandler(rtllib->dev, HW_VAR_CECHK_BSSID, (u8*)(&bFilterOutNonAssociatedBSSID));
-	rtllib_MlmeDisassociateRequest( rtllib, rtllib->current_network.bssid, asRsn );
+	rtllib->SetHwRegHandler(rtllib->dev, HW_VAR_CECHK_BSSID,
+				(u8 *)(&bFilterOutNonAssociatedBSSID));
+	rtllib_MlmeDisassociateRequest(rtllib, rtllib->current_network.bssid,
+				       asRsn);
 
 	rtllib->state = RTLLIB_NOLINK;
 }
 
-bool
-rtllib_MgntDisconnect(
-	struct rtllib_device* rtllib,
-	u8 asRsn
-)
+bool rtllib_MgntDisconnect(struct rtllib_device *rtllib, u8 asRsn)
 {
 	if (rtllib->ps != RTLLIB_PS_DISABLED)
-	{
-                rtllib->sta_wake_up(rtllib->dev);
-	}
+		rtllib->sta_wake_up(rtllib->dev);
 
-	if ( rtllib->state == RTLLIB_LINKED )
-	{
-		if ( rtllib->iw_mode == IW_MODE_ADHOC )
-		{
+	if (rtllib->state == RTLLIB_LINKED) {
+		if (rtllib->iw_mode == IW_MODE_ADHOC)
 			rtllib_MgntDisconnectIBSS(rtllib);
-		}
-		if ( rtllib->iw_mode == IW_MODE_INFRA )
-		{
+		if (rtllib->iw_mode == IW_MODE_INFRA)
 			rtllib_MgntDisconnectAP(rtllib, asRsn);
-		}
 
 	}
 
@@ -3816,10 +3758,12 @@ void notify_wx_assoc_event(struct rtllib_device *ieee)
 
 	wrqu.ap_addr.sa_family = ARPHRD_ETHER;
 	if (ieee->state == RTLLIB_LINKED)
-		memcpy(wrqu.ap_addr.sa_data, ieee->current_network.bssid, ETH_ALEN);
-	else{
+		memcpy(wrqu.ap_addr.sa_data, ieee->current_network.bssid,
+		       ETH_ALEN);
+	else {
 
-		printk("%s(): Tell user space disconnected\n",__func__);
+		printk(KERN_INFO "%s(): Tell user space disconnected\n",
+		       __func__);
 		memset(wrqu.ap_addr.sa_data, 0, ETH_ALEN);
 	}
 	wireless_send_event(ieee->dev, SIOCGIWAP, &wrqu, NULL);

commit 0dd565069b21ae20f4916cf305b64268bb3f9d3f
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Thu Aug 25 11:48:12 2011 -0500

    staging: rtl8192e: Modify time handling
    
    In several places, the driver keeps times (in jiffies) in two 32-bit
    quantities. In the rtl8192_hw_to_sleep(), there is an error in the
    calculation of the difference between two 64-bit quantities. Rather
    than fix that error, I have converted to a single 64-bit number. That
    makes the code be much cleaner and clearer.
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 11433c61bdaf..29277d18f021 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -2037,7 +2037,7 @@ void rtllib_sta_ps_send_pspoll_frame(struct rtllib_device *ieee)
 
 }
 
-short rtllib_sta_ps_sleep(struct rtllib_device *ieee, u32 *time_h, u32 *time_l)
+static short rtllib_sta_ps_sleep(struct rtllib_device *ieee, u64 *time)
 {
 	int timeout = ieee->ps_timeout;
 	u8 dtim;
@@ -2074,7 +2074,7 @@ short rtllib_sta_ps_sleep(struct rtllib_device *ieee, u32 *time_h, u32 *time_l)
 		(ieee->mgmt_queue_tail != ieee->mgmt_queue_head))
 		return 0;
 
-	if (time_l){
+	if (time){
 		if (ieee->bAwakePktSent == true) {
 			pPSC->LPSAwakeIntvl = 1;
 		} else {
@@ -2107,17 +2107,11 @@ short rtllib_sta_ps_sleep(struct rtllib_device *ieee, u32 *time_h, u32 *time_l)
 					LPSAwakeIntvl_tmp = pPSC->LPSAwakeIntvl;
 			}
 
-		*time_l = ieee->current_network.last_dtim_sta_time[0]
+		*time = ieee->current_network.last_dtim_sta_time
 			+ MSECS(ieee->current_network.beacon_interval * LPSAwakeIntvl_tmp);
 	}
 	}
 
-	if (time_h) {
-		*time_h = ieee->current_network.last_dtim_sta_time[1];
-		if (time_l && *time_l < ieee->current_network.last_dtim_sta_time[0])
-			*time_h += 1;
-	}
-
 	return 1;
 
 
@@ -2126,7 +2120,7 @@ short rtllib_sta_ps_sleep(struct rtllib_device *ieee, u32 *time_h, u32 *time_l)
 inline void rtllib_sta_ps(struct rtllib_device *ieee)
 {
 
-	u32 th,tl;
+	u64 time;
 	short sleep;
 
 	unsigned long flags,flags2;
@@ -2146,7 +2140,7 @@ inline void rtllib_sta_ps(struct rtllib_device *ieee)
 		spin_unlock_irqrestore(&ieee->mgmt_tx_lock, flags2);
 	}
 
-	sleep = rtllib_sta_ps_sleep(ieee,&th, &tl);
+	sleep = rtllib_sta_ps_sleep(ieee, &time);
 	/* 2 wake, 1 sleep, 0 do nothing */
 	if (sleep == 0)
 	{
@@ -2154,7 +2148,7 @@ inline void rtllib_sta_ps(struct rtllib_device *ieee)
 	}
 	if (sleep == 1){
 		if (ieee->sta_sleep == LPS_IS_SLEEP){
-			ieee->enter_sleep_state(ieee->dev,th,tl);
+			ieee->enter_sleep_state(ieee->dev, time);
 		}
 
 		else if (ieee->sta_sleep == LPS_IS_WAKE){
@@ -2164,8 +2158,7 @@ inline void rtllib_sta_ps(struct rtllib_device *ieee)
 				ieee->sta_sleep = LPS_WAIT_NULL_DATA_SEND;
 				ieee->ack_tx_to_ieee = 1;
 				rtllib_sta_ps_send_null_frame(ieee,1);
-				ieee->ps_th = th;
-				ieee->ps_tl = tl;
+				ieee->ps_time = time;
 			}
 			spin_unlock_irqrestore(&ieee->mgmt_tx_lock, flags2);
 
@@ -2241,7 +2234,7 @@ void rtllib_ps_tx_ack(struct rtllib_device *ieee, short success)
 		/* Null frame with PS bit set */
 		if (success){
 			ieee->sta_sleep = LPS_IS_SLEEP;
-			ieee->enter_sleep_state(ieee->dev,ieee->ps_th,ieee->ps_tl);
+			ieee->enter_sleep_state(ieee->dev, ieee->ps_time);
 		}
 		/* if the card report not success we can't be sure the AP
 		 * has not RXed so we can't assume the AP believe us awake

commit 3b83db43ccbb26863f38caccc1e7fae370f31e57
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Tue Jul 19 00:01:29 2011 -0500

    staging: rtl8192e: Convert typedef cb_desc to struct cb_desc
    
    Remove typedef from struct.
    Rename struct.
    Rename uses.
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 64574acc0fdd..11433c61bdaf 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -242,7 +242,7 @@ inline void softmac_mgmt_xmit(struct sk_buff *skb, struct rtllib_device *ieee)
 	struct rtllib_hdr_3addr  *header=
 		(struct rtllib_hdr_3addr  *) skb->data;
 
-	cb_desc *tcb_desc = (cb_desc *)(skb->cb + 8);
+	struct cb_desc *tcb_desc = (struct cb_desc *)(skb->cb + 8);
 	spin_lock_irqsave(&ieee->lock, flags);
 
 	/* called with 2nd param 0, no mgmt lock required */
@@ -311,7 +311,7 @@ inline void softmac_ps_mgmt_xmit(struct sk_buff *skb,
 	struct rtllib_hdr_3addr  *header =
 		(struct rtllib_hdr_3addr  *) skb->data;
 	u16 fc,type,stype;
-	cb_desc *tcb_desc = (cb_desc *)(skb->cb + 8);
+	struct cb_desc *tcb_desc = (struct cb_desc *)(skb->cb + 8);
 
 	fc = header->frame_ctl;
 	type = WLAN_FC_GET_TYPE(fc);
@@ -2552,7 +2552,7 @@ void rtllib_softmac_xmit(struct rtllib_txb *txb, struct rtllib_device *ieee)
 	unsigned int queue_index = txb->queue_index;
 	unsigned long flags;
 	int  i;
-	cb_desc *tcb_desc = NULL;
+	struct cb_desc *tcb_desc = NULL;
 	unsigned long queue_len = 0;
 
 	spin_lock_irqsave(&ieee->lock,flags);
@@ -2561,7 +2561,7 @@ void rtllib_softmac_xmit(struct rtllib_txb *txb, struct rtllib_device *ieee)
 	rtllib_sta_wakeup(ieee,0);
 
 	/* update the tx status */
-	tcb_desc = (cb_desc *)(txb->fragments[0]->cb + MAX_DEV_ADDR_SIZE);
+	tcb_desc = (struct cb_desc *)(txb->fragments[0]->cb + MAX_DEV_ADDR_SIZE);
 	if (tcb_desc->bMulticast) {
 		ieee->stats.multicast++;
 	}

commit ca9900116fb3b758d226d08c1f5c792285941fb9
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Mon Jul 18 22:06:47 2011 -0500

    staging: rtl8192e: Convert typedef RT_POWER_SAVE_CONTROL to struct rt_pwr_save_ctrl
    
    Remove typedef from struct.
    Rename struct.
    Rename uses.
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 8cf42f0302f6..64574acc0fdd 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -1577,7 +1577,7 @@ void rtllib_associate_step2(struct rtllib_device *ieee)
 void rtllib_associate_complete_wq(void *data)
 {
 	struct rtllib_device *ieee = (struct rtllib_device *)container_of_work_rsl(data, struct rtllib_device, associate_complete_wq);
-	PRT_POWER_SAVE_CONTROL pPSC = (PRT_POWER_SAVE_CONTROL)(&(ieee->PowerSaveControl));
+	struct rt_pwr_save_ctrl *pPSC = (struct rt_pwr_save_ctrl *)(&(ieee->PowerSaveControl));
 	printk(KERN_INFO "Associated successfully\n");
 	if (ieee->is_silent_reset == 0){
             printk("normal associate\n");
@@ -2041,7 +2041,7 @@ short rtllib_sta_ps_sleep(struct rtllib_device *ieee, u32 *time_h, u32 *time_l)
 {
 	int timeout = ieee->ps_timeout;
 	u8 dtim;
-	PRT_POWER_SAVE_CONTROL	pPSC = (PRT_POWER_SAVE_CONTROL)(&(ieee->PowerSaveControl));
+	struct rt_pwr_save_ctrl *pPSC = (struct rt_pwr_save_ctrl *)(&(ieee->PowerSaveControl));
 	/*if (ieee->ps == RTLLIB_PS_DISABLED ||
 		ieee->iw_mode != IW_MODE_INFRA ||
 		ieee->state != RTLLIB_LINKED)

commit 8310b6c05c65dfe699dd62be5d71c246ddaefd96
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Mon Jul 18 21:57:13 2011 -0500

    staging: rtl8192e: Convert typedef OCTET_STRING to struct octet_string
    
    Remove typedef from struct.
    Rename struct.
    Rename uses.
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 7930a9637575..8cf42f0302f6 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -1351,7 +1351,7 @@ inline struct sk_buff *rtllib_association_req(struct rtllib_network *beacon,stru
 	{
 		static u8	AironetIeOui[] = {0x00, 0x01, 0x66};
 		u8	CcxAironetBuf[30];
-		OCTET_STRING	osCcxAironetIE;
+		struct octet_string osCcxAironetIE;
 
 		memset(CcxAironetBuf, 0,30);
 		osCcxAironetIE.Octet = CcxAironetBuf;
@@ -1369,7 +1369,7 @@ inline struct sk_buff *rtllib_association_req(struct rtllib_network *beacon,stru
 	if (beacon->bCcxRmEnable)
 	{
 		static u8 CcxRmCapBuf[] = {0x00, 0x40, 0x96, 0x01, 0x01, 0x00};
-		OCTET_STRING osCcxRmCap;
+		struct octet_string osCcxRmCap;
 
 		osCcxRmCap.Octet = CcxRmCapBuf;
 		osCcxRmCap.Length = sizeof(CcxRmCapBuf);
@@ -1383,7 +1383,7 @@ inline struct sk_buff *rtllib_association_req(struct rtllib_network *beacon,stru
 	if ( beacon->BssCcxVerNumber >= 2 )
 	{
 		u8			CcxVerNumBuf[] = {0x00, 0x40, 0x96, 0x03, 0x00};
-		OCTET_STRING	osCcxVerNum;
+		struct octet_string osCcxVerNum;
 		CcxVerNumBuf[4] = beacon->BssCcxVerNumber;
 		osCcxVerNum.Octet = CcxVerNumBuf;
 		osCcxVerNum.Length = sizeof(CcxVerNumBuf);

commit 7796d93eae46054d5a3bb5411fde735801998dc5
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Mon Jul 18 20:22:19 2011 -0500

    staging: rtl8192e: Convert typedef RT_HIGH_THROUGHPUT to struct rt_hi_throughput
    
    Remove typedef from struct.
    Rename struct.
    Rename uses.
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index e4fdcbd376d4..7930a9637575 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -212,7 +212,7 @@ MgntQuery_TxRateExcludeCCKRates(struct rtllib_device *ieee)
 
 u8 MgntQuery_MgntFrameTxRate(struct rtllib_device *ieee)
 {
-	PRT_HIGH_THROUGHPUT      pHTInfo = ieee->pHTInfo;
+	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
 	u8 rate;
 
 	if (pHTInfo->IOTAction & HT_IOT_ACT_MGNT_USE_CCK_6M)
@@ -884,7 +884,7 @@ static struct sk_buff* rtllib_probe_resp(struct rtllib_device *ieee, u8 *dest)
 	u8 tmp_ht_cap_len = 0;
 	u8* tmp_ht_info_buf = NULL;
 	u8 tmp_ht_info_len = 0;
-	PRT_HIGH_THROUGHPUT	pHTInfo = ieee->pHTInfo;
+	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
 	u8* tmp_generic_ie_buf = NULL;
 	u8 tmp_generic_ie_len = 0;
 

commit ce403a6ac41ff2e745ddb415d83275eaf2207082
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Thu Jul 14 10:19:49 2011 -0500

    staging: rtl8192e: Remove dead code associated with CUSTOMER_ID_INTEL_CMPC and CONFIG_CRDA
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 5f65b58286ce..e4fdcbd376d4 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -525,13 +525,6 @@ void rtllib_send_probe_requests(struct rtllib_device *ieee, u8 is_mesh)
 
 void rtllib_softmac_hint11d_wq(void *data)
 {
-#ifdef CONFIG_CRDA
-	struct rtllib_device *ieee = container_of_dwork_rsl(data, struct rtllib_device, softmac_hint11d_wq);
-	PRT_DOT11D_INFO pDot11dInfo = GET_DOT11D_INFO(ieee);
-	struct wireless_dev *wdev = &ieee->wdev;
-
-	regulatory_hint_11d(wdev->wiphy, pDot11dInfo->CountryIeBuf, pDot11dInfo->CountryIeLen);
-#endif
 }
 
 void rtllib_update_active_chan_map(struct rtllib_device *ieee)

commit d32ddcba9d67b7d647576df9f8f62934956c60b9
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Thu Jul 14 09:58:36 2011 -0500

    staging: rtl8192e: Remove dead code associated with FOR_ANDROID_X86 and FOR_MOBLIN
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 420ba4398bc1..5f65b58286ce 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -608,13 +608,11 @@ void rtllib_softmac_scan_syncro(struct rtllib_device *ieee, u8 is_mesh)
 
 	ieee->be_scan_inprogress = false;
 
-#ifndef FOR_MOBLIN
 	{
 	union iwreq_data wrqu;
 	memset(&wrqu, 0, sizeof(wrqu));
 	wireless_send_event(ieee->dev,SIOCGIWSCAN,&wrqu,NULL);
 	}
-#endif
 }
 
 void rtllib_softmac_scan_wq(void *data)
@@ -2942,10 +2940,7 @@ void rtllib_disassociate(struct rtllib_device *ieee)
 
 	queue_delayed_work_rsl(ieee->wq, &ieee->link_change_wq, 0);
 
-
-#ifndef FOR_ANDROID_X86
 	notify_wx_assoc_event(ieee);
-#endif
 }
 
 void rtllib_associate_retry_wq(void *data)

commit 07f432338accafb2002911a34309d822e168074a
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Wed Jul 13 22:05:57 2011 -0500

    staging: rtl8192e: Remove dead code associated with ADHOC_11N
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index a5267b246302..420ba4398bc1 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -2780,11 +2780,7 @@ void rtllib_start_ibss_wq(void *data)
 	}
 
 	ieee->state = RTLLIB_NOLINK;
-#ifdef ADHOC_11N
-	ieee->mode = IEEE_N_24G;
-#else
 	ieee->mode = IEEE_G;
-#endif
 	/* check if we have this cell in our network list */
 	rtllib_softmac_check_all_nets(ieee);
 

commit f1c22567693a8c01a0bda0e3e29243eff3e5f196
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Wed Jul 13 22:04:15 2011 -0500

    staging: rtl8192e: Remove dead code associated with WIFI_TEST
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index a0cd746778a7..a5267b246302 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -2585,11 +2585,7 @@ void rtllib_softmac_xmit(struct rtllib_txb *txb, struct rtllib_device *ieee)
 			/* as for the completion function, it does not need
 			 * to check it any more.
 			 * */
-#ifdef WIFI_TEST
-			if (1)
-#else
 			if (queue_len < 200)
-#endif
 			{
 				skb_queue_tail(&ieee->skb_waitQ[queue_index], txb->fragments[i]);
 			}else{

commit 6e2c538f8fbca87276a83eec5ac9212bbbfa13fa
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Wed Jul 13 21:58:46 2011 -0500

    staging: rtl8192e: Remove dead code associated with RTK_DMP_PLATFORM
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index b9b5a1053e5c..a0cd746778a7 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -23,9 +23,6 @@
 #include <asm/uaccess.h>
 #include "dot11d.h"
 
-#ifdef RTK_DMP_PLATFORM
-#include <linux/usb_setting.h>
-#endif
 extern void _setup_timer( struct timer_list*, void*, unsigned long );
 u8 rsn_authen_cipher_suite[16][4] = {
 	{0x00,0x0F,0xAC,0x00},
@@ -1634,9 +1631,6 @@ void rtllib_associate_complete_wq(void *data)
 	if (ieee->data_hard_resume)
 		ieee->data_hard_resume(ieee->dev);
 
-#ifdef RTK_DMP_PLATFORM
-	kobject_hotplug(&ieee->dev->class_dev.kobj, KOBJ_LINKUP);
-#endif
 }
 
 static void rtllib_sta_send_associnfo(struct rtllib_device *ieee)

commit 02525969666f1fe4718705d372afaafa9d12b612
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Wed Jul 13 18:50:46 2011 -0500

    staging: rtl8192e: Remove dead code associated with SUPPORT_USPD
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index b4279d7049ec..b9b5a1053e5c 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -119,15 +119,7 @@ void rtllib_WMM_Info(struct rtllib_device *ieee, u8 **tag_p) {
 	*tag++ = 0x02;
 	*tag++ = 0x00;
 	*tag++ = 0x01;
-#ifdef SUPPORT_USPD
-	if (ieee->current_network.wmm_info & 0x80) {
-		*tag++ = 0x0f|MAX_SP_Len;
-	} else {
-		*tag++ = MAX_SP_Len;
-	}
-#else
 	*tag++ = MAX_SP_Len;
-#endif
 	*tag_p = tag;
 }
 

commit bf474281e98171b7491a8b759491f400bd6b1863
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Wed Jul 13 09:43:35 2011 -0500

    staging: rtl8192e: Remove dead code associated with USB_TX_DRIVER_AGGREGATION_ENABLE
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 9d881f480ce0..b4279d7049ec 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -2591,11 +2591,7 @@ void rtllib_softmac_xmit(struct rtllib_txb *txb, struct rtllib_device *ieee)
 
 	/* if xmit available, just xmit it immediately, else just insert it to the wait queue */
 	for (i = 0; i < txb->nr_frags; i++) {
-#ifdef USB_TX_DRIVER_AGGREGATION_ENABLE
-		queue_len = skb_queue_len(&ieee->skb_drv_aggQ[queue_index]);
-#else
 		queue_len = skb_queue_len(&ieee->skb_waitQ[queue_index]);
-#endif
 		if ((queue_len  != 0) ||\
 			(!ieee->check_nic_enough_desc(ieee->dev,queue_index))||\
 		       (ieee->queue_stop)) {
@@ -2609,11 +2605,7 @@ void rtllib_softmac_xmit(struct rtllib_txb *txb, struct rtllib_device *ieee)
 			if (queue_len < 200)
 #endif
 			{
-#ifdef USB_TX_DRIVER_AGGREGATION_ENABLE
-				skb_queue_tail(&ieee->skb_drv_aggQ[queue_index], txb->fragments[i]);
-#else
 				skb_queue_tail(&ieee->skb_waitQ[queue_index], txb->fragments[i]);
-#endif
 			}else{
 				kfree_skb(txb->fragments[i]);
 			}

commit 2b259bd38fdfdf6a4103234172eafc13d7f774b6
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Wed Jul 13 09:35:45 2011 -0500

    staging: rtl8192e: Remove ifdefs that depend on ENABLE_DOT11D
    
    This configuration parameter is selected in the Makefile, thus the
    conditional code can be removed.
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 1d3504463543..9d881f480ce0 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -21,9 +21,7 @@
 #include <linux/delay.h>
 #include <linux/version.h>
 #include <asm/uaccess.h>
-#ifdef ENABLE_DOT11D
 #include "dot11d.h"
-#endif
 
 #ifdef RTK_DMP_PLATFORM
 #include <linux/usb_setting.h>
@@ -549,11 +547,7 @@ void rtllib_softmac_hint11d_wq(void *data)
 
 void rtllib_update_active_chan_map(struct rtllib_device *ieee)
 {
-#ifdef ENABLE_DOT11D
 	memcpy(ieee->active_channel_map, GET_DOT11D_INFO(ieee)->channel_map, MAX_CHANNEL_NUMBER+1);
-#else
-	memcpy(ieee->active_channel_map, ieee->channel_map, MAX_CHANNEL_NUMBER+1);
-#endif
 }
 
 /* this performs syncro scan blocking the caller until all channels
@@ -618,10 +612,8 @@ void rtllib_softmac_scan_syncro(struct rtllib_device *ieee, u8 is_mesh)
 	ieee->sync_scan_hurryup = 0;
 
 	if (ieee->state >= RTLLIB_LINKED){
-#ifdef ENABLE_DOT11D
 		if (IS_DOT11D_ENABLE(ieee))
 			DOT11D_ScanComplete(ieee);
-#endif
 	}
 	up(&ieee->scan_sem);
 
@@ -681,10 +673,8 @@ void rtllib_softmac_scan_wq(void *data)
 	return;
 
 out:
-#ifdef ENABLE_DOT11D
 	if (IS_DOT11D_ENABLE(ieee))
 		DOT11D_ScanComplete(ieee);
-#endif
 	ieee->current_network.channel = last_channel;
 
 out1:
@@ -794,7 +784,6 @@ void rtllib_start_scan(struct rtllib_device *ieee)
 	ieee->rtllib_ips_leave_wq(ieee->dev);
 
 
-#ifdef ENABLE_DOT11D
 	if (IS_DOT11D_ENABLE(ieee) )
 	{
 		if (IS_COUNTRY_IE_VALID(ieee))
@@ -802,7 +791,6 @@ void rtllib_start_scan(struct rtllib_device *ieee)
 			RESET_CIE_WATCHDOG(ieee);
 		}
 	}
-#endif
 	if (ieee->softmac_features & IEEE_SOFTMAC_SCAN) {
 		if (ieee->scanning_continue == 0) {
 			ieee->actscanning = true;
@@ -819,7 +807,6 @@ void rtllib_start_scan(struct rtllib_device *ieee)
 /* called with wx_sem held */
 void rtllib_start_scan_syncro(struct rtllib_device *ieee, u8 is_mesh)
 {
-#ifdef ENABLE_DOT11D
 	if (IS_DOT11D_ENABLE(ieee) )
 	{
 		if (IS_COUNTRY_IE_VALID(ieee))
@@ -827,7 +814,6 @@ void rtllib_start_scan_syncro(struct rtllib_device *ieee, u8 is_mesh)
 			RESET_CIE_WATCHDOG(ieee);
 		}
 	}
-#endif
 	ieee->sync_scan_hurryup = 0;
 	if (ieee->softmac_features & IEEE_SOFTMAC_SCAN){
 		rtllib_softmac_scan_syncro(ieee, is_mesh);
@@ -2935,7 +2921,6 @@ inline void rtllib_start_ibss(struct rtllib_device *ieee)
 void rtllib_start_bss(struct rtllib_device *ieee)
 {
 	unsigned long flags;
-#ifdef ENABLE_DOT11D
 	if (IS_DOT11D_ENABLE(ieee) && !IS_COUNTRY_IE_VALID(ieee))
 	{
 		if (! ieee->bGlobalDomain)
@@ -2943,7 +2928,6 @@ void rtllib_start_bss(struct rtllib_device *ieee)
 			return;
 		}
 	}
-#endif
 	/* check if we have already found the net we
 	 * are interested in (if any).
 	 * if not (we are disassociated and we are not
@@ -2980,10 +2964,8 @@ void rtllib_disassociate(struct rtllib_device *ieee)
 
 	if (ieee->data_hard_stop)
 			ieee->data_hard_stop(ieee->dev);
-#ifdef ENABLE_DOT11D
 	if (IS_DOT11D_ENABLE(ieee))
 		Dot11d_Reset(ieee);
-#endif
 	ieee->state = RTLLIB_NOLINK;
 	ieee->is_set_key = false;
 	ieee->wap_set = 0;
@@ -3200,12 +3182,10 @@ void rtllib_softmac_init(struct rtllib_device *ieee)
 	for (i = 0; i < 5; i++) {
 	  ieee->seq_ctrl[i] = 0;
 	}
-#ifdef ENABLE_DOT11D
 	ieee->pDot11dInfo = kmalloc(sizeof(struct rt_dot11d_info), GFP_ATOMIC);
 	if (!ieee->pDot11dInfo)
 		RTLLIB_DEBUG(RTLLIB_DL_ERR, "can't alloc memory for DOT11D\n");
 	memset(ieee->pDot11dInfo, 0, sizeof(struct rt_dot11d_info));
-#endif
 	ieee->LinkDetectInfo.SlotIndex = 0;
 	ieee->LinkDetectInfo.SlotNum = 2;
 	ieee->LinkDetectInfo.NumRecvBcnInPeriod=0;
@@ -3285,13 +3265,11 @@ void rtllib_softmac_init(struct rtllib_device *ieee)
 void rtllib_softmac_free(struct rtllib_device *ieee)
 {
 	down(&ieee->wx_sem);
-#ifdef ENABLE_DOT11D
 	if (NULL != ieee->pDot11dInfo)
 	{
 		kfree(ieee->pDot11dInfo);
 		ieee->pDot11dInfo = NULL;
 	}
-#endif
 	del_timer_sync(&ieee->associate_timer);
 
 	cancel_delayed_work(&ieee->associate_retry_wq);

commit e755463c216b76f07692a83c6cd7197fa31e5d89
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Wed Jul 13 00:13:20 2011 -0500

    staging: rtl8192e: Remove dead code from removal of ENABLE_TKIP11N
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 3cbfdeb6290e..1d3504463543 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -1273,11 +1273,7 @@ inline struct sk_buff *rtllib_association_req(struct rtllib_network *beacon,stru
 		encrypt = 0;
 	}
 
-#ifdef ENABLE_TKIP11N
-	if (ieee->bForcedBgMode == true)
-#else
 	if ((ieee->rtllib_ap_sec_type && (ieee->rtllib_ap_sec_type(ieee)&SEC_ALG_TKIP)) ||(ieee->bForcedBgMode == true))
-#endif
 	{
 		ieee->pHTInfo->bEnableHT = 0;
 		ieee->mode = WIRELESS_MODE_G;

commit 0e3b1830591d7d5460e2346cdb535d209de2cab9
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Tue Jul 12 22:30:01 2011 -0500

    staging: rtl8192e: Remove dead code associated with PF_SYNCTHREAD
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 281d51bdc54e..3cbfdeb6290e 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -3262,11 +3262,7 @@ void rtllib_softmac_init(struct rtllib_device *ieee)
 		    (unsigned long) ieee);
 
 
-#ifdef PF_SYNCTHREAD
-	ieee->wq = create_workqueue(DRV_NAME,0);
-#else
 	ieee->wq = create_workqueue(DRV_NAME);
-#endif
 
 	INIT_DELAYED_WORK_RSL(&ieee->link_change_wq,(void*)rtllib_link_change_wq,ieee);
 	INIT_DELAYED_WORK_RSL(&ieee->start_ibss_wq,(void*)rtllib_start_ibss_wq,ieee);

commit 4ebba6d6e34796bdc5ead494111fb19c619eb599
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Tue Jul 12 22:26:33 2011 -0500

    staging: rtl8192e: Remove dead code associated with COMPATIBLE_WITH_RALINK_MESH
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index a3a0397e10ff..281d51bdc54e 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -2561,11 +2561,6 @@ inline int rtllib_rx_frame_softmac(struct rtllib_device *ieee, struct sk_buff *s
 		case RTLLIB_STYPE_MANAGE_ACT:
 			rtllib_process_action(ieee,skb);
 			break;
-#ifdef COMPATIBLE_WITH_RALINK_MESH
-		case RTLLIB_STYPE_MESH_ACT:
-			rtllib_process_action_mesh(ieee,skb,rx_stats);
-			break;
-#endif
 		default:
 			return -1;
 			break;

commit a97dc3afc0d1f33fb8fff8e57f3644b3d09bacd0
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Tue Jul 12 22:16:06 2011 -0500

    staging: rtl8192e: Remove dead code associated with USB_USE_ALIGNMENT
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index b2244688725b..a3a0397e10ff 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -382,25 +382,12 @@ inline struct sk_buff *rtllib_probe_req(struct rtllib_device *ieee)
 
 	rate_len = rtllib_MFIE_rate_len(ieee);
 
-#ifdef USB_USE_ALIGNMENT
-        u32 Tmpaddr;
-        int alignment;
-        skb = dev_alloc_skb(sizeof(struct rtllib_probe_request) +
-                            2 + len + rate_len + ieee->tx_headroom + USB_512B_ALIGNMENT_SIZE);
-#else
 	skb = dev_alloc_skb(sizeof(struct rtllib_probe_request) +
 			    2 + len + rate_len + ieee->tx_headroom);
-#endif
 
 	if (!skb)
 		return NULL;
 
-#ifdef USB_USE_ALIGNMENT
-        Tmpaddr = (u32)skb->data;
-        alignment = Tmpaddr & 0x1ff;
-        skb_reserve(skb,(USB_512B_ALIGNMENT_SIZE - alignment));
-#endif
-
 	skb_reserve(skb, ieee->tx_headroom);
 
 	req = (struct rtllib_probe_request *) skb_put(skb,sizeof(struct rtllib_probe_request));
@@ -858,22 +845,10 @@ inline struct sk_buff *rtllib_authentication_req(struct rtllib_network *beacon,
 	struct rtllib_authentication *auth;
 	int  len = 0;
 	len = sizeof(struct rtllib_authentication) + challengelen + ieee->tx_headroom + 4;
-#ifdef USB_USE_ALIGNMENT
-        u32 Tmpaddr;
-        int alignment;
-        skb = dev_alloc_skb(len + USB_512B_ALIGNMENT_SIZE);
-#else
 	skb = dev_alloc_skb(len);
-#endif
 
 	if (!skb) return NULL;
 
-#ifdef USB_USE_ALIGNMENT
-        Tmpaddr = (u32)skb->data;
-        alignment = Tmpaddr & 0x1ff;
-        skb_reserve(skb,(USB_512B_ALIGNMENT_SIZE - alignment));
-#endif
-
 	skb_reserve(skb, ieee->tx_headroom);
 
 	auth = (struct rtllib_authentication *)
@@ -994,22 +969,10 @@ static struct sk_buff* rtllib_probe_resp(struct rtllib_device *ieee, u8 *dest)
 		+erp_len
 		+wpa_ie_len
 		+ieee->tx_headroom;
-#ifdef USB_USE_ALIGNMENT
-        u32 Tmpaddr=0;
-        int alignment=0;
-        skb = dev_alloc_skb(beacon_size + USB_512B_ALIGNMENT_SIZE);
-#else
 	skb = dev_alloc_skb(beacon_size);
-#endif
 	if (!skb)
 		return NULL;
 
-#ifdef USB_USE_ALIGNMENT
-        Tmpaddr = (u32)skb->data;
-        alignment = Tmpaddr & 0x1ff;
-        skb_reserve(skb,(USB_512B_ALIGNMENT_SIZE - alignment));
-#endif
-
 	skb_reserve(skb, ieee->tx_headroom);
 
 	beacon_buf = (struct rtllib_probe_response*) skb_put(skb, (beacon_size - ieee->tx_headroom));
@@ -1098,23 +1061,11 @@ struct sk_buff* rtllib_assoc_resp(struct rtllib_device *ieee, u8 *dest)
 	unsigned int rate_len = rtllib_MFIE_rate_len(ieee);
 	int len = sizeof(struct rtllib_assoc_response_frame) + rate_len + ieee->tx_headroom;
 
-#ifdef USB_USE_ALIGNMENT
-        u32 Tmpaddr=0;
-        int alignment=0;
-        skb = dev_alloc_skb(len + USB_512B_ALIGNMENT_SIZE);
-#else
 	skb = dev_alloc_skb(len);
-#endif
 
 	if (!skb)
 		return NULL;
 
-#ifdef USB_USE_ALIGNMENT
-        Tmpaddr = (u32)skb->data;
-        alignment = Tmpaddr & 0x1ff;
-        skb_reserve(skb,(USB_512B_ALIGNMENT_SIZE - alignment));
-#endif
-
 	skb_reserve(skb, ieee->tx_headroom);
 
 	assoc = (struct rtllib_assoc_response_frame *)
@@ -1160,24 +1111,12 @@ struct sk_buff* rtllib_auth_resp(struct rtllib_device *ieee,int status, u8 *dest
 	struct sk_buff *skb = NULL;
 	struct rtllib_authentication *auth;
 	int len = ieee->tx_headroom + sizeof(struct rtllib_authentication)+1;
-#ifdef USB_USE_ALIGNMENT
-        u32 Tmpaddr=0;
-        int alignment=0;
-        skb = dev_alloc_skb(len + USB_512B_ALIGNMENT_SIZE);
-#else
 	skb = dev_alloc_skb(len);
-#endif
 	if (!skb)
 		return NULL;
 
 	skb->len = sizeof(struct rtllib_authentication);
 
-#ifdef USB_USE_ALIGNMENT
-        Tmpaddr = (u32)skb->data;
-        alignment = Tmpaddr & 0x1ff;
-        skb_reserve(skb,(USB_512B_ALIGNMENT_SIZE - alignment));
-#endif
-
 	skb_reserve(skb, ieee->tx_headroom);
 
 	auth = (struct rtllib_authentication *)
@@ -1201,21 +1140,10 @@ struct sk_buff* rtllib_null_func(struct rtllib_device *ieee,short pwr)
 	struct sk_buff *skb;
 	struct rtllib_hdr_3addr* hdr;
 
-#ifdef USB_USE_ALIGNMENT
-        u32 Tmpaddr=0;
-        int alignment=0;
-        skb = dev_alloc_skb(sizeof(struct rtllib_hdr_3addr) + ieee->tx_headroom + USB_512B_ALIGNMENT_SIZE);
-#else
 	skb = dev_alloc_skb(sizeof(struct rtllib_hdr_3addr)+ieee->tx_headroom);
-#endif
 	if (!skb)
 		return NULL;
 
-#ifdef USB_USE_ALIGNMENT
-        Tmpaddr = (u32)skb->data;
-        alignment = Tmpaddr & 0x1ff;
-        skb_reserve(skb,(USB_512B_ALIGNMENT_SIZE - alignment));
-#endif
 	skb_reserve(skb, ieee->tx_headroom);
 
 	hdr = (struct rtllib_hdr_3addr*)skb_put(skb,sizeof(struct rtllib_hdr_3addr));
@@ -1238,21 +1166,10 @@ struct sk_buff* rtllib_pspoll_func(struct rtllib_device *ieee)
 	struct sk_buff *skb;
 	struct rtllib_pspoll_hdr* hdr;
 
-#ifdef USB_USE_ALIGNMENT
-        u32 Tmpaddr=0;
-        int alignment=0;
-        skb = dev_alloc_skb(sizeof(struct rtllib_pspoll_hdr) + ieee->tx_headroom + USB_512B_ALIGNMENT_SIZE);
-#else
 	skb = dev_alloc_skb(sizeof(struct rtllib_pspoll_hdr)+ieee->tx_headroom);
-#endif
 	if (!skb)
 		return NULL;
 
-#ifdef USB_USE_ALIGNMENT
-        Tmpaddr = (u32)skb->data;
-        alignment = Tmpaddr & 0x1ff;
-        skb_reserve(skb,(USB_512B_ALIGNMENT_SIZE - alignment));
-#endif
 	skb_reserve(skb, ieee->tx_headroom);
 
 	hdr = (struct rtllib_pspoll_hdr*)skb_put(skb,sizeof(struct rtllib_pspoll_hdr));
@@ -1412,23 +1329,11 @@ inline struct sk_buff *rtllib_association_req(struct rtllib_network *beacon,stru
 		+ cxvernum_ie_len
 		+ ieee->tx_headroom;
 
-#ifdef USB_USE_ALIGNMENT
-	u32 Tmpaddr=0;
-	int alignment=0;
-	skb = dev_alloc_skb(len + USB_512B_ALIGNMENT_SIZE);
-#else
 	skb = dev_alloc_skb(len);
-#endif
 
 	if (!skb)
 		return NULL;
 
-#ifdef USB_USE_ALIGNMENT
-        Tmpaddr = (u32)skb->data;
-        alignment = Tmpaddr & 0x1ff;
-        skb_reserve(skb,(USB_512B_ALIGNMENT_SIZE - alignment));
-#endif
-
 	skb_reserve(skb, ieee->tx_headroom);
 
 	hdr = (struct rtllib_assoc_request_frame *)
@@ -3743,24 +3648,13 @@ inline struct sk_buff *rtllib_disauth_skb( struct rtllib_network *beacon,
 {
 	struct sk_buff *skb;
 	struct rtllib_disauth *disauth;
-#ifdef USB_USE_ALIGNMENT
-        u32 Tmpaddr=0;
-        int alignment=0;
-	int len = sizeof(struct rtllib_disauth) + ieee->tx_headroom + USB_512B_ALIGNMENT_SIZE;
-#else
 	int len = sizeof(struct rtllib_disauth) + ieee->tx_headroom;
 
-#endif
 	skb = dev_alloc_skb(len);
 	if (!skb) {
 		return NULL;
 	}
 
-#ifdef USB_USE_ALIGNMENT
-        Tmpaddr = (u32)skb->data;
-        alignment = Tmpaddr & 0x1ff;
-        skb_reserve(skb,(USB_512B_ALIGNMENT_SIZE - alignment));
-#endif
 	skb_reserve(skb, ieee->tx_headroom);
 
 	disauth = (struct rtllib_disauth *) skb_put(skb,sizeof(struct rtllib_disauth));
@@ -3780,24 +3674,13 @@ inline struct sk_buff *rtllib_disassociate_skb( struct rtllib_network *beacon,
 {
 	struct sk_buff *skb;
 	struct rtllib_disassoc *disass;
-#ifdef USB_USE_ALIGNMENT
-        u32 Tmpaddr=0;
-        int alignment=0;
-	int len = sizeof(struct rtllib_disassoc) + ieee->tx_headroom + USB_512B_ALIGNMENT_SIZE;
-#else
 	int len = sizeof(struct rtllib_disassoc) + ieee->tx_headroom;
-#endif
 	skb = dev_alloc_skb(len);
 
 	if (!skb) {
 		return NULL;
 	}
 
-#ifdef USB_USE_ALIGNMENT
-        Tmpaddr = (u32)skb->data;
-        alignment = Tmpaddr & 0x1ff;
-        skb_reserve(skb,(USB_512B_ALIGNMENT_SIZE - alignment));
-#endif
 	skb_reserve(skb, ieee->tx_headroom);
 
 	disass = (struct rtllib_disassoc *) skb_put(skb,sizeof(struct rtllib_disassoc));

commit d064307a1a67c564caf69e1555d1aa62662217fb
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Tue Jul 12 22:08:32 2011 -0500

    staging: rtl8192e: Remove dead code involved with TO_DO
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 9f7227eb6d8e..b2244688725b 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -3974,15 +3974,6 @@ rtllib_MgntDisconnectAP(
 {
 	bool bFilterOutNonAssociatedBSSID = false;
 
-
-#ifdef TO_DO
-	if (   pMgntInfo->SecurityInfo.AuthMode > RT_802_11AuthModeAutoSwitch ||
-		(pMgntInfo->bAPSuportCCKM && pMgntInfo->bCCX8021xenable) )
-	{
-		SecClearAllKeys(rtllib->dev);
-		RT_TRACE(COMP_SEC, DBG_LOUD,("======>CCKM clear key..."))
-	}
-#endif
 	bFilterOutNonAssociatedBSSID = false;
 	rtllib->SetHwRegHandler(rtllib->dev, HW_VAR_CECHK_BSSID, (u8*)(&bFilterOutNonAssociatedBSSID));
 	rtllib_MlmeDisassociateRequest( rtllib, rtllib->current_network.bssid, asRsn );
@@ -4001,15 +3992,6 @@ rtllib_MgntDisconnect(
                 rtllib->sta_wake_up(rtllib->dev);
 	}
 
-#ifdef TO_DO
-	if (pMgntInfo->mActingAsAp)
-	{
-		RT_TRACE(COMP_MLME, DBG_LOUD, ("MgntDisconnect() ===> AP_DisassociateAllStation\n"));
-		AP_DisassociateAllStation(rtllib->dev, unspec_reason);
-		return true;
-	}
-#endif
-
 	if ( rtllib->state == RTLLIB_LINKED )
 	{
 		if ( rtllib->iw_mode == IW_MODE_ADHOC )

commit 15e7650e880b410d0a4c80aa586b5b2f96be3a61
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Tue Jul 12 22:04:11 2011 -0500

    staging: rtl8192e: Remove dead code involved with TO_DO_LIST
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index c9c5df4c9948..9f7227eb6d8e 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -4018,9 +4018,6 @@ rtllib_MgntDisconnect(
 		}
 		if ( rtllib->iw_mode == IW_MODE_INFRA )
 		{
-#ifdef TO_DO_LIST
-			SecClearAllKeys(Adapter);
-#endif
 			rtllib_MgntDisconnectAP(rtllib, asRsn);
 		}
 

commit 1e71e6d0cf764841cdf60dec4a40849ff41be75c
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Mon Jul 11 22:25:07 2011 -0500

    staging: rtl8192e: Remove dead code associated with RTL8192SE
    
    The vendor code will generate several different drivers. As the RTL8192SE
    is covered by a mac80211 driver in mainline, eliminate that code heere.
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index dadb5430bfab..c9c5df4c9948 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -1066,14 +1066,6 @@ static struct sk_buff* rtllib_probe_resp(struct rtllib_device *ieee, u8 *dest)
 		*(tag++) = 1;
 		*(tag++) = erpinfo_content;
 	}
-#if defined(RTL8192U) || defined(RTL8192SU) || defined(RTL8192SE)
-	if (tmp_ht_cap_len){
-		*(tag++) = MFIE_TYPE_HT_CAP;
-		*(tag++) = tmp_ht_cap_len - 2;
-		memcpy(tag, tmp_ht_cap_buf, tmp_ht_cap_len - 2);
-		tag += tmp_ht_cap_len - 2;
-	}
-#endif
 	if (rate_ex_len){
 		*(tag++) = MFIE_TYPE_RATES_EX;
 		*(tag++) = rate_ex_len-2;
@@ -1081,15 +1073,6 @@ static struct sk_buff* rtllib_probe_resp(struct rtllib_device *ieee, u8 *dest)
 		tag+=rate_ex_len-2;
 	}
 
-#if defined(RTL8192U) || defined(RTL8192SU) || defined(RTL8192SE)
-	if (tmp_ht_info_len){
-		*(tag++) = MFIE_TYPE_HT_INFO;
-		*(tag++) = tmp_ht_info_len - 2;
-		memcpy(tag, tmp_ht_info_buf, tmp_ht_info_len -2);
-		tag += tmp_ht_info_len - 2;
-	}
-#endif
-
 	if (wpa_ie_len)
 	{
 		if (ieee->iw_mode == IW_MODE_ADHOC)
@@ -1100,23 +1083,6 @@ static struct sk_buff* rtllib_probe_resp(struct rtllib_device *ieee, u8 *dest)
 		tag += ieee->wpa_ie_len;
 	}
 
-#if defined(RTL8192U) || defined(RTL8192SU) || defined(RTL8192SE)
-	if (tmp_generic_ie_len)
-	{
-		(*tag++) = 0xdd;
-		(*tag++) = tmp_generic_ie_len - 2;
-		memcpy(tag,tmp_generic_ie_buf,tmp_generic_ie_len -2);
-		tag += tmp_generic_ie_len -2;
-
-	}
-#endif
-
-#if defined(RTL8192U) || defined(RTL8192SU) || defined(RTL8192SE)
-	if (wmm_len) {
-		memcpy(tag,wmmie,wmm_len);
-		tag += wmm_len;
-	}
-#endif
 	return skb;
 }
 
@@ -2154,20 +2120,10 @@ static inline u16 assoc_parse(struct rtllib_device *ieee, struct sk_buff *skb, i
 void rtllib_rx_probe_rq(struct rtllib_device *ieee, struct sk_buff *skb)
 {
 	u8 dest[ETH_ALEN];
-#if defined(RTL8192U) || defined(RTL8192SU) || defined(RTL8192SE)
-	struct sta_info *psta = NULL;
-#endif
 	ieee->softmac_stats.rx_probe_rq++;
 	if (probe_rq_parse(ieee, skb, dest) > 0){
 		ieee->softmac_stats.tx_probe_rs++;
 		rtllib_resp_to_probe(ieee, dest);
-#if defined(RTL8192U) || defined(RTL8192SU) || defined(RTL8192SE)
-		if (ieee->iw_mode == IW_MODE_ADHOC){
-			psta = GetStaInfo(ieee, dest);
-			if (NULL != psta)
-				psta->LastActiveTime = jiffies;
-		}
-#endif
 	}
 }
 
@@ -3040,17 +2996,8 @@ void rtllib_start_ibss_wq(void *data)
 			ieee->rate = 22;
 		}
 
-#if defined(RTL8192U) || defined(RTL8192SU) || defined(RTL8192SE)
-#ifdef ADHOC_11N
-		ieee->current_network.qos_data.supported = 1;
-#else
-		ieee->current_network.qos_data.supported = 0;
-#endif
-		ieee->SetWirelessMode(ieee->dev, ieee->mode);
-#else
 		ieee->current_network.qos_data.supported = 0;
 		ieee->SetWirelessMode(ieee->dev, IEEE_G);
-#endif
 		ieee->current_network.mode = ieee->mode;
 		ieee->current_network.atim_window = 0;
 		ieee->current_network.capability = WLAN_CAPABILITY_IBSS;

commit 175159c537312f95150508655256645c8daa86a0
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Mon Jul 11 18:34:09 2011 -0500

    staging: rtl8192e: Remove code dependent on RTL8190P
    
    The vendor code can conditionally generate drivers for a number of
    devices. Remove any code that depends on RTL8190P being set.
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 1b2e6c44cd10..dadb5430bfab 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -4051,9 +4051,7 @@ rtllib_MgntDisconnect(
 {
 	if (rtllib->ps != RTLLIB_PS_DISABLED)
 	{
-#ifndef RTL8190P
                 rtllib->sta_wake_up(rtllib->dev);
-#endif
 	}
 
 #ifdef TO_DO

commit 4f6807e8d2e972393009830d305ecec2d80c0449
Author: Mike McCormack <mikem@ring3k.org>
Date:   Mon Jul 11 08:56:20 2011 +0900

    rtl8192e: Remove occurences of #if 1
    
    Signed-off-by: Mike McCormack <mikem@ring3k.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 3ac740a7c0d4..1b2e6c44cd10 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -2750,7 +2750,7 @@ void rtllib_softmac_xmit(struct rtllib_txb *txb, struct rtllib_device *ieee)
 	if (tcb_desc->bMulticast) {
 		ieee->stats.multicast++;
 	}
-#if 1
+
 	/* if xmit available, just xmit it immediately, else just insert it to the wait queue */
 	for (i = 0; i < txb->nr_frags; i++) {
 #ifdef USB_TX_DRIVER_AGGREGATION_ENABLE
@@ -2785,7 +2785,7 @@ void rtllib_softmac_xmit(struct rtllib_txb *txb, struct rtllib_device *ieee)
 					ieee->dev,ieee->rate);
 		}
 	}
-#endif
+
 	rtllib_txb_free(txb);
 
 	spin_unlock_irqrestore(&ieee->lock,flags);

commit cb76215448947ddcc133c4b1c2ff2d4a77e851e0
Author: Mike McCormack <mikem@ring3k.org>
Date:   Mon Jul 11 08:56:20 2011 +0900

    rtl8192e: Remove extra ifdefs
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
    Signed-off-by: Mike McCormack <mikem@ring3k.org>

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index a843de99ed3e..3ac740a7c0d4 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -754,21 +754,13 @@ void rtllib_start_send_beacons(struct rtllib_device *ieee)
 
 void rtllib_softmac_stop_scan(struct rtllib_device *ieee)
 {
-
-
 	down(&ieee->scan_sem);
 	ieee->scan_watch_dog = 0;
-	if (ieee->scanning_continue == 1){
+	if (ieee->scanning_continue == 1) {
 		ieee->scanning_continue = 0;
 		ieee->actscanning = 0;
 
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,40)
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,67)
 		cancel_delayed_work(&ieee->softmac_scan_wq);
-#endif
-#else
-		del_timer_sync(&ieee->scan_timer);
-#endif
 	}
 
 	up(&ieee->scan_sem);
@@ -837,18 +829,6 @@ void rtllib_start_scan(struct rtllib_device *ieee)
 
 }
 
-#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,5,40)
-void rtllib_softmac_scan_cb(unsigned long _dev)
-{
-	unsigned long flags;
-	struct rtllib_device *ieee = (struct rtllib_device *)_dev;
-
-	spin_lock_irqsave(&ieee->lock, flags);
-	rtllib_start_scan(ieee);
-	spin_unlock_irqrestore(&ieee->lock, flags);
-}
-#endif
-
 /* called with wx_sem held */
 void rtllib_start_scan_syncro(struct rtllib_device *ieee, u8 is_mesh)
 {
@@ -2903,28 +2883,16 @@ void rtllib_stop_queue(struct rtllib_device *ieee)
 
 void rtllib_stop_all_queues(struct rtllib_device *ieee)
 {
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,30)
 	unsigned int i;
 	for (i=0; i < ieee->dev->num_tx_queues; i++)
                 netdev_get_tx_queue(ieee->dev,i)->trans_start = jiffies;
-#else
-	ieee->dev->trans_start = jiffies;
-#endif
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,27)
-	netif_carrier_off(ieee->dev);
-#else
 	netif_tx_stop_all_queues(ieee->dev);
-#endif
 }
 
 void rtllib_wake_all_queues(struct rtllib_device *ieee)
 {
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,27)
-	netif_carrier_on(ieee->dev);
-#else
 	netif_tx_wake_all_queues(ieee->dev);
-#endif
 }
 
 inline void rtllib_randomize_cell(struct rtllib_device *ieee)
@@ -3436,11 +3404,6 @@ void rtllib_softmac_init(struct rtllib_device *ieee)
 	ieee->sta_edca_param[3] = 0x002F3262;
 	ieee->aggregation = true;
 	ieee->enable_rx_imm_BA = 1;
-#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,5,40)
-	_setup_timer(&ieee->scan_timer,
-		    rtllib_softmac_scan_cb,
-		    (unsigned long) ieee);
-#endif
 	ieee->tx_pending.txb = NULL;
 
 	_setup_timer(&ieee->associate_timer,
@@ -3451,18 +3414,11 @@ void rtllib_softmac_init(struct rtllib_device *ieee)
 		    rtllib_send_beacon_cb,
 		    (unsigned long) ieee);
 
-#if defined(RTL8192U) || defined(RTL8192SU) || defined(RTL8192SE)
-	_setup_timer(&ieee->ibss_wait_timer,
-		    rtllib_ibss_wait_timeout,
-		    (unsigned long) ieee);
-#endif
 
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 #ifdef PF_SYNCTHREAD
 	ieee->wq = create_workqueue(DRV_NAME,0);
 #else
 	ieee->wq = create_workqueue(DRV_NAME);
-#endif
 #endif
 
 	INIT_DELAYED_WORK_RSL(&ieee->link_change_wq,(void*)rtllib_link_change_wq,ieee);
@@ -3499,11 +3455,8 @@ void rtllib_softmac_free(struct rtllib_device *ieee)
 #endif
 	del_timer_sync(&ieee->associate_timer);
 
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 	cancel_delayed_work(&ieee->associate_retry_wq);
 	destroy_workqueue(ieee->wq);
-#endif
-
 	up(&ieee->wx_sem);
 }
 

commit 94a799425eee8225a1e3fbe5f473d2ef04002577
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Tue Aug 23 19:00:42 2011 -0500

    From: wlanfae <wlanfae@realtek.com>
    [PATCH 1/8] rtl8192e: Import new version of driver from realtek
    
    Signed-off-by: wlanfae <wlanfae@realtek.com>
    Signed-off-by: Mike McCormack <mikem@ring3k.org>
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
    ---

diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
new file mode 100644
index 000000000000..a843de99ed3e
--- /dev/null
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -0,0 +1,4150 @@
+/* IEEE 802.11 SoftMAC layer
+ * Copyright (c) 2005 Andrea Merello <andreamrl@tiscali.it>
+ *
+ * Mostly extracted from the rtl8180-sa2400 driver for the
+ * in-kernel generic ieee802.11 stack.
+ *
+ * Few lines might be stolen from other part of the rtllib
+ * stack. Copyright who own it's copyright
+ *
+ * WPA code stolen from the ipw2200 driver.
+ * Copyright who own it's copyright.
+ *
+ * released under the GPL
+ */
+
+
+#include "rtllib.h"
+#include "rtl_core.h"
+
+#include <linux/random.h>
+#include <linux/delay.h>
+#include <linux/version.h>
+#include <asm/uaccess.h>
+#ifdef ENABLE_DOT11D
+#include "dot11d.h"
+#endif
+
+#ifdef RTK_DMP_PLATFORM
+#include <linux/usb_setting.h>
+#endif
+extern void _setup_timer( struct timer_list*, void*, unsigned long );
+u8 rsn_authen_cipher_suite[16][4] = {
+	{0x00,0x0F,0xAC,0x00},
+	{0x00,0x0F,0xAC,0x01},
+	{0x00,0x0F,0xAC,0x02},
+	{0x00,0x0F,0xAC,0x03},
+	{0x00,0x0F,0xAC,0x04},
+	{0x00,0x0F,0xAC,0x05},
+};
+
+short rtllib_is_54g(struct rtllib_network *net)
+{
+	return ((net->rates_ex_len > 0) || (net->rates_len > 4));
+}
+
+short rtllib_is_shortslot(struct rtllib_network net)
+{
+	return (net.capability & WLAN_CAPABILITY_SHORT_SLOT_TIME);
+}
+
+/* returns the total length needed for pleacing the RATE MFIE
+ * tag and the EXTENDED RATE MFIE tag if needed.
+ * It encludes two bytes per tag for the tag itself and its len
+ */
+unsigned int rtllib_MFIE_rate_len(struct rtllib_device *ieee)
+{
+	unsigned int rate_len = 0;
+
+	if (ieee->modulation & RTLLIB_CCK_MODULATION)
+		rate_len = RTLLIB_CCK_RATE_LEN + 2;
+
+	if (ieee->modulation & RTLLIB_OFDM_MODULATION)
+
+		rate_len += RTLLIB_OFDM_RATE_LEN + 2;
+
+	return rate_len;
+}
+
+/* pleace the MFIE rate, tag to the memory (double) poined.
+ * Then it updates the pointer so that
+ * it points after the new MFIE tag added.
+ */
+void rtllib_MFIE_Brate(struct rtllib_device *ieee, u8 **tag_p)
+{
+	u8 *tag = *tag_p;
+
+	if (ieee->modulation & RTLLIB_CCK_MODULATION){
+		*tag++ = MFIE_TYPE_RATES;
+		*tag++ = 4;
+		*tag++ = RTLLIB_BASIC_RATE_MASK | RTLLIB_CCK_RATE_1MB;
+		*tag++ = RTLLIB_BASIC_RATE_MASK | RTLLIB_CCK_RATE_2MB;
+		*tag++ = RTLLIB_BASIC_RATE_MASK | RTLLIB_CCK_RATE_5MB;
+		*tag++ = RTLLIB_BASIC_RATE_MASK | RTLLIB_CCK_RATE_11MB;
+	}
+
+	/* We may add an option for custom rates that specific HW might support */
+	*tag_p = tag;
+}
+
+void rtllib_MFIE_Grate(struct rtllib_device *ieee, u8 **tag_p)
+{
+	u8 *tag = *tag_p;
+
+		if (ieee->modulation & RTLLIB_OFDM_MODULATION){
+
+		*tag++ = MFIE_TYPE_RATES_EX;
+		*tag++ = 8;
+		*tag++ = RTLLIB_BASIC_RATE_MASK | RTLLIB_OFDM_RATE_6MB;
+		*tag++ = RTLLIB_BASIC_RATE_MASK | RTLLIB_OFDM_RATE_9MB;
+		*tag++ = RTLLIB_BASIC_RATE_MASK | RTLLIB_OFDM_RATE_12MB;
+		*tag++ = RTLLIB_BASIC_RATE_MASK | RTLLIB_OFDM_RATE_18MB;
+		*tag++ = RTLLIB_BASIC_RATE_MASK | RTLLIB_OFDM_RATE_24MB;
+		*tag++ = RTLLIB_BASIC_RATE_MASK | RTLLIB_OFDM_RATE_36MB;
+		*tag++ = RTLLIB_BASIC_RATE_MASK | RTLLIB_OFDM_RATE_48MB;
+		*tag++ = RTLLIB_BASIC_RATE_MASK | RTLLIB_OFDM_RATE_54MB;
+
+	}
+
+	/* We may add an option for custom rates that specific HW might support */
+	*tag_p = tag;
+}
+
+void rtllib_WMM_Info(struct rtllib_device *ieee, u8 **tag_p) {
+	u8 *tag = *tag_p;
+
+	*tag++ = MFIE_TYPE_GENERIC;
+	*tag++ = 7;
+	*tag++ = 0x00;
+	*tag++ = 0x50;
+	*tag++ = 0xf2;
+	*tag++ = 0x02;
+	*tag++ = 0x00;
+	*tag++ = 0x01;
+#ifdef SUPPORT_USPD
+	if (ieee->current_network.wmm_info & 0x80) {
+		*tag++ = 0x0f|MAX_SP_Len;
+	} else {
+		*tag++ = MAX_SP_Len;
+	}
+#else
+	*tag++ = MAX_SP_Len;
+#endif
+	*tag_p = tag;
+}
+
+void rtllib_TURBO_Info(struct rtllib_device *ieee, u8 **tag_p) {
+	u8 *tag = *tag_p;
+
+        *tag++ = MFIE_TYPE_GENERIC;
+        *tag++ = 7;
+        *tag++ = 0x00;
+        *tag++ = 0xe0;
+        *tag++ = 0x4c;
+        *tag++ = 0x01;
+        *tag++ = 0x02;
+        *tag++ = 0x11;
+	*tag++ = 0x00;
+
+	*tag_p = tag;
+	printk(KERN_ALERT "This is enable turbo mode IE process\n");
+}
+
+void enqueue_mgmt(struct rtllib_device *ieee, struct sk_buff *skb)
+{
+	int nh;
+	nh = (ieee->mgmt_queue_head +1) % MGMT_QUEUE_NUM;
+
+/*
+ * if the queue is full but we have newer frames then
+ * just overwrites the oldest.
+ *
+ * if (nh == ieee->mgmt_queue_tail)
+ *		return -1;
+ */
+	ieee->mgmt_queue_head = nh;
+	ieee->mgmt_queue_ring[nh] = skb;
+
+}
+
+struct sk_buff *dequeue_mgmt(struct rtllib_device *ieee)
+{
+	struct sk_buff *ret;
+
+	if (ieee->mgmt_queue_tail == ieee->mgmt_queue_head)
+		return NULL;
+
+	ret = ieee->mgmt_queue_ring[ieee->mgmt_queue_tail];
+
+	ieee->mgmt_queue_tail =
+		(ieee->mgmt_queue_tail+1) % MGMT_QUEUE_NUM;
+
+	return ret;
+}
+
+void init_mgmt_queue(struct rtllib_device *ieee)
+{
+	ieee->mgmt_queue_tail = ieee->mgmt_queue_head = 0;
+}
+
+
+u8
+MgntQuery_TxRateExcludeCCKRates(struct rtllib_device *ieee)
+{
+	u16	i;
+	u8	QueryRate = 0;
+	u8	BasicRate;
+
+
+	for ( i = 0; i < ieee->current_network.rates_len; i++)
+	{
+		BasicRate = ieee->current_network.rates[i]&0x7F;
+		if (!rtllib_is_cck_rate(BasicRate))
+		{
+			if (QueryRate == 0)
+			{
+				QueryRate = BasicRate;
+			}
+			else
+			{
+				if (BasicRate < QueryRate)
+				{
+					QueryRate = BasicRate;
+				}
+			}
+		}
+	}
+
+	if (QueryRate == 0)
+	{
+		QueryRate = 12;
+		printk("No BasicRate found!!\n");
+	}
+	return QueryRate;
+}
+
+u8 MgntQuery_MgntFrameTxRate(struct rtllib_device *ieee)
+{
+	PRT_HIGH_THROUGHPUT      pHTInfo = ieee->pHTInfo;
+	u8 rate;
+
+	if (pHTInfo->IOTAction & HT_IOT_ACT_MGNT_USE_CCK_6M)
+		rate = 0x0c;
+	else
+		rate = ieee->basic_rate & 0x7f;
+
+	if (rate == 0){
+		if (ieee->mode == IEEE_A||
+		   ieee->mode== IEEE_N_5G||
+		   (ieee->mode== IEEE_N_24G&&!pHTInfo->bCurSuppCCK))
+			rate = 0x0c;
+		else
+			rate = 0x02;
+	}
+
+	return rate;
+}
+
+
+void rtllib_sta_wakeup(struct rtllib_device *ieee, short nl);
+
+inline void softmac_mgmt_xmit(struct sk_buff *skb, struct rtllib_device *ieee)
+{
+	unsigned long flags;
+	short single = ieee->softmac_features & IEEE_SOFTMAC_SINGLE_QUEUE;
+	struct rtllib_hdr_3addr  *header=
+		(struct rtllib_hdr_3addr  *) skb->data;
+
+	cb_desc *tcb_desc = (cb_desc *)(skb->cb + 8);
+	spin_lock_irqsave(&ieee->lock, flags);
+
+	/* called with 2nd param 0, no mgmt lock required */
+	rtllib_sta_wakeup(ieee,0);
+
+	if (header->frame_ctl == RTLLIB_STYPE_BEACON)
+		tcb_desc->queue_index = BEACON_QUEUE;
+	else
+		tcb_desc->queue_index = MGNT_QUEUE;
+
+	if (ieee->disable_mgnt_queue)
+		tcb_desc->queue_index = HIGH_QUEUE;
+
+	tcb_desc->data_rate = MgntQuery_MgntFrameTxRate(ieee);
+	tcb_desc->RATRIndex = 7;
+	tcb_desc->bTxDisableRateFallBack = 1;
+	tcb_desc->bTxUseDriverAssingedRate = 1;
+	if (single) {
+		if (ieee->queue_stop){
+			enqueue_mgmt(ieee,skb);
+		}else{
+			header->seq_ctl = cpu_to_le16(ieee->seq_ctrl[0]<<4);
+
+			if (ieee->seq_ctrl[0] == 0xFFF)
+				ieee->seq_ctrl[0] = 0;
+			else
+				ieee->seq_ctrl[0]++;
+
+			/* avoid watchdog triggers */
+			ieee->softmac_data_hard_start_xmit(skb,ieee->dev,ieee->basic_rate);
+		}
+
+		spin_unlock_irqrestore(&ieee->lock, flags);
+	}else{
+		spin_unlock_irqrestore(&ieee->lock, flags);
+		spin_lock_irqsave(&ieee->mgmt_tx_lock, flags);
+
+		header->seq_ctl = cpu_to_le16(ieee->seq_ctrl[0] << 4);
+
+		if (ieee->seq_ctrl[0] == 0xFFF)
+			ieee->seq_ctrl[0] = 0;
+		else
+			ieee->seq_ctrl[0]++;
+
+		/* check wether the managed packet queued greater than 5 */
+		if (!ieee->check_nic_enough_desc(ieee->dev,tcb_desc->queue_index)||\
+				(skb_queue_len(&ieee->skb_waitQ[tcb_desc->queue_index]) != 0)||\
+				(ieee->queue_stop) ) {
+			/* insert the skb packet to the management queue */
+			/* as for the completion function, it does not need
+			 * to check it any more.
+			 * */
+			printk("%s():insert to waitqueue, queue_index:%d!\n",__func__,tcb_desc->queue_index);
+			skb_queue_tail(&ieee->skb_waitQ[tcb_desc->queue_index], skb);
+		} else {
+			ieee->softmac_hard_start_xmit(skb,ieee->dev);
+		}
+		spin_unlock_irqrestore(&ieee->mgmt_tx_lock, flags);
+	}
+}
+
+inline void softmac_ps_mgmt_xmit(struct sk_buff *skb,
+		struct rtllib_device *ieee)
+{
+	short single = ieee->softmac_features & IEEE_SOFTMAC_SINGLE_QUEUE;
+	struct rtllib_hdr_3addr  *header =
+		(struct rtllib_hdr_3addr  *) skb->data;
+	u16 fc,type,stype;
+	cb_desc *tcb_desc = (cb_desc *)(skb->cb + 8);
+
+	fc = header->frame_ctl;
+	type = WLAN_FC_GET_TYPE(fc);
+	stype = WLAN_FC_GET_STYPE(fc);
+
+
+	if (stype != RTLLIB_STYPE_PSPOLL)
+		tcb_desc->queue_index = MGNT_QUEUE;
+	else
+		tcb_desc->queue_index = HIGH_QUEUE;
+
+	if (ieee->disable_mgnt_queue)
+		tcb_desc->queue_index = HIGH_QUEUE;
+
+
+	tcb_desc->data_rate = MgntQuery_MgntFrameTxRate(ieee);
+	tcb_desc->RATRIndex = 7;
+	tcb_desc->bTxDisableRateFallBack = 1;
+	tcb_desc->bTxUseDriverAssingedRate = 1;
+	if (single) {
+		if (type != RTLLIB_FTYPE_CTL) {
+			header->seq_ctl = cpu_to_le16(ieee->seq_ctrl[0] << 4);
+
+			if (ieee->seq_ctrl[0] == 0xFFF)
+				ieee->seq_ctrl[0] = 0;
+			else
+				ieee->seq_ctrl[0]++;
+
+		}
+		/* avoid watchdog triggers */
+		ieee->softmac_data_hard_start_xmit(skb,ieee->dev,ieee->basic_rate);
+
+	} else {
+		if (type != RTLLIB_FTYPE_CTL) {
+			header->seq_ctl = cpu_to_le16(ieee->seq_ctrl[0] << 4);
+
+			if (ieee->seq_ctrl[0] == 0xFFF)
+				ieee->seq_ctrl[0] = 0;
+			else
+				ieee->seq_ctrl[0]++;
+		}
+		ieee->softmac_hard_start_xmit(skb,ieee->dev);
+
+	}
+}
+
+inline struct sk_buff *rtllib_probe_req(struct rtllib_device *ieee)
+{
+	unsigned int len,rate_len;
+	u8 *tag;
+	struct sk_buff *skb;
+	struct rtllib_probe_request *req;
+
+	len = ieee->current_network.ssid_len;
+
+	rate_len = rtllib_MFIE_rate_len(ieee);
+
+#ifdef USB_USE_ALIGNMENT
+        u32 Tmpaddr;
+        int alignment;
+        skb = dev_alloc_skb(sizeof(struct rtllib_probe_request) +
+                            2 + len + rate_len + ieee->tx_headroom + USB_512B_ALIGNMENT_SIZE);
+#else
+	skb = dev_alloc_skb(sizeof(struct rtllib_probe_request) +
+			    2 + len + rate_len + ieee->tx_headroom);
+#endif
+
+	if (!skb)
+		return NULL;
+
+#ifdef USB_USE_ALIGNMENT
+        Tmpaddr = (u32)skb->data;
+        alignment = Tmpaddr & 0x1ff;
+        skb_reserve(skb,(USB_512B_ALIGNMENT_SIZE - alignment));
+#endif
+
+	skb_reserve(skb, ieee->tx_headroom);
+
+	req = (struct rtllib_probe_request *) skb_put(skb,sizeof(struct rtllib_probe_request));
+	req->header.frame_ctl = cpu_to_le16(RTLLIB_STYPE_PROBE_REQ);
+	req->header.duration_id = 0;
+
+	memset(req->header.addr1, 0xff, ETH_ALEN);
+	memcpy(req->header.addr2, ieee->dev->dev_addr, ETH_ALEN);
+	memset(req->header.addr3, 0xff, ETH_ALEN);
+
+	tag = (u8 *) skb_put(skb,len+2+rate_len);
+
+	*tag++ = MFIE_TYPE_SSID;
+	*tag++ = len;
+	memcpy(tag, ieee->current_network.ssid, len);
+	tag += len;
+
+	rtllib_MFIE_Brate(ieee,&tag);
+	rtllib_MFIE_Grate(ieee,&tag);
+
+	return skb;
+}
+
+struct sk_buff *rtllib_get_beacon_(struct rtllib_device *ieee);
+
+void rtllib_send_beacon(struct rtllib_device *ieee)
+{
+	struct sk_buff *skb;
+	if (!ieee->ieee_up)
+		return;
+	skb = rtllib_get_beacon_(ieee);
+
+	if (skb){
+		softmac_mgmt_xmit(skb, ieee);
+		ieee->softmac_stats.tx_beacons++;
+	}
+
+	if (ieee->beacon_txing && ieee->ieee_up){
+		mod_timer(&ieee->beacon_timer,jiffies+(MSECS(ieee->current_network.beacon_interval-5)));
+	}
+}
+
+
+void rtllib_send_beacon_cb(unsigned long _ieee)
+{
+	struct rtllib_device *ieee =
+		(struct rtllib_device *) _ieee;
+	unsigned long flags;
+
+	spin_lock_irqsave(&ieee->beacon_lock, flags);
+	rtllib_send_beacon(ieee);
+	spin_unlock_irqrestore(&ieee->beacon_lock, flags);
+}
+
+/*
+ * Description:
+ *              Enable network monitor mode, all rx packets will be received.
+ */
+void rtllib_EnableNetMonitorMode(struct net_device* dev,
+                bool bInitState)
+{
+        struct rtllib_device* ieee = netdev_priv_rsl(dev);
+
+        printk("========>Enter Monitor Mode\n");
+
+        ieee->AllowAllDestAddrHandler(dev, true, !bInitState);
+}
+
+
+/*
+ *      Description:
+ *              Disable network network monitor mode, only packets destinated to
+ *              us will be received.
+ */
+void rtllib_DisableNetMonitorMode(struct net_device* dev,
+                bool bInitState)
+{
+	struct rtllib_device* ieee = netdev_priv_rsl(dev);
+
+        printk("========>Exit Monitor Mode\n");
+
+        ieee->AllowAllDestAddrHandler(dev, false, !bInitState);
+}
+
+
+/*
+ * Description:
+ *              This enables the specialized promiscuous mode required by Intel.
+ *              In this mode, Intel intends to hear traffics from/to other STAs in the same BSS.
+ *              Therefore we don't have to disable checking BSSID and we only need to allow all dest.
+ *              BUT: if we enable checking BSSID then we can't recv packets from other STA.
+ */
+void rtllib_EnableIntelPromiscuousMode(struct net_device* dev,
+                bool bInitState)
+{
+        bool bFilterOutNonAssociatedBSSID = false;
+
+	struct rtllib_device* ieee = netdev_priv_rsl(dev);
+
+        printk("========>Enter Intel Promiscuous Mode\n");
+
+        ieee->AllowAllDestAddrHandler(dev, true, !bInitState);
+        ieee->SetHwRegHandler(dev, HW_VAR_CECHK_BSSID, (u8*)&bFilterOutNonAssociatedBSSID);
+
+        ieee->bNetPromiscuousMode = true;
+}
+
+
+/*
+ * Description:
+ *              This disables the specialized promiscuous mode required by Intel.
+ *              See MgntEnableIntelPromiscuousMode for detail.
+ */
+void rtllib_DisableIntelPromiscuousMode(struct net_device* dev,
+                bool bInitState)
+{
+        bool bFilterOutNonAssociatedBSSID = true;
+
+	struct rtllib_device* ieee = netdev_priv_rsl(dev);
+
+        printk("========>Exit Intel Promiscuous Mode\n");
+
+        ieee->AllowAllDestAddrHandler(dev, false, !bInitState);
+        ieee->SetHwRegHandler(dev, HW_VAR_CECHK_BSSID, (u8*)&bFilterOutNonAssociatedBSSID);
+
+        ieee->bNetPromiscuousMode = false;
+}
+
+void rtllib_send_probe(struct rtllib_device *ieee, u8 is_mesh)
+{
+	struct sk_buff *skb;
+	skb = rtllib_probe_req(ieee);
+	if (skb){
+		softmac_mgmt_xmit(skb, ieee);
+		ieee->softmac_stats.tx_probe_rq++;
+	}
+}
+
+
+void rtllib_send_probe_requests(struct rtllib_device *ieee, u8 is_mesh)
+{
+	if (ieee->active_scan && (ieee->softmac_features &
+	    IEEE_SOFTMAC_PROBERQ)) {
+		rtllib_send_probe(ieee, 0);
+		rtllib_send_probe(ieee, 0);
+	}
+}
+
+void rtllib_softmac_hint11d_wq(void *data)
+{
+#ifdef CONFIG_CRDA
+	struct rtllib_device *ieee = container_of_dwork_rsl(data, struct rtllib_device, softmac_hint11d_wq);
+	PRT_DOT11D_INFO pDot11dInfo = GET_DOT11D_INFO(ieee);
+	struct wireless_dev *wdev = &ieee->wdev;
+
+	regulatory_hint_11d(wdev->wiphy, pDot11dInfo->CountryIeBuf, pDot11dInfo->CountryIeLen);
+#endif
+}
+
+void rtllib_update_active_chan_map(struct rtllib_device *ieee)
+{
+#ifdef ENABLE_DOT11D
+	memcpy(ieee->active_channel_map, GET_DOT11D_INFO(ieee)->channel_map, MAX_CHANNEL_NUMBER+1);
+#else
+	memcpy(ieee->active_channel_map, ieee->channel_map, MAX_CHANNEL_NUMBER+1);
+#endif
+}
+
+/* this performs syncro scan blocking the caller until all channels
+ * in the allowed channel map has been checked.
+ */
+void rtllib_softmac_scan_syncro(struct rtllib_device *ieee, u8 is_mesh)
+{
+	short ch = 0;
+
+	rtllib_update_active_chan_map(ieee);
+
+	ieee->be_scan_inprogress = true;
+
+	down(&ieee->scan_sem);
+
+	while(1)
+	{
+
+		do {
+			ch++;
+			if (ch > MAX_CHANNEL_NUMBER)
+				goto out; /* scan completed */
+		} while(!ieee->active_channel_map[ch]);
+
+		/* this fuction can be called in two situations
+		 * 1- We have switched to ad-hoc mode and we are
+		 *    performing a complete syncro scan before conclude
+		 *    there are no interesting cell and to create a
+		 *    new one. In this case the link state is
+		 *    RTLLIB_NOLINK until we found an interesting cell.
+		 *    If so the ieee8021_new_net, called by the RX path
+		 *    will set the state to RTLLIB_LINKED, so we stop
+		 *    scanning
+		 * 2- We are linked and the root uses run iwlist scan.
+		 *    So we switch to RTLLIB_LINKED_SCANNING to remember
+		 *    that we are still logically linked (not interested in
+		 *    new network events, despite for updating the net list,
+		 *    but we are temporarly 'unlinked' as the driver shall
+		 *    not filter RX frames and the channel is changing.
+		 * So the only situation in witch are interested is to check
+		 * if the state become LINKED because of the #1 situation
+		 */
+
+		if (ieee->state == RTLLIB_LINKED)
+			goto out;
+		if (ieee->sync_scan_hurryup){
+			printk("============>sync_scan_hurryup out\n");
+			goto out;
+		}
+
+		ieee->set_chan(ieee->dev, ch);
+		if (ieee->active_channel_map[ch] == 1)
+		rtllib_send_probe_requests(ieee, 0);
+
+		/* this prevent excessive time wait when we
+		 * need to wait for a syncro scan to end..
+		 */
+		msleep_interruptible_rsl(RTLLIB_SOFTMAC_SCAN_TIME);
+	}
+out:
+	ieee->actscanning = false;
+	ieee->sync_scan_hurryup = 0;
+
+	if (ieee->state >= RTLLIB_LINKED){
+#ifdef ENABLE_DOT11D
+		if (IS_DOT11D_ENABLE(ieee))
+			DOT11D_ScanComplete(ieee);
+#endif
+	}
+	up(&ieee->scan_sem);
+
+	ieee->be_scan_inprogress = false;
+
+#ifndef FOR_MOBLIN
+	{
+	union iwreq_data wrqu;
+	memset(&wrqu, 0, sizeof(wrqu));
+	wireless_send_event(ieee->dev,SIOCGIWSCAN,&wrqu,NULL);
+	}
+#endif
+}
+
+void rtllib_softmac_scan_wq(void *data)
+{
+	struct rtllib_device *ieee = container_of_dwork_rsl(data, struct rtllib_device, softmac_scan_wq);
+	u8 last_channel = ieee->current_network.channel;
+
+	rtllib_update_active_chan_map(ieee);
+
+	if (!ieee->ieee_up)
+		return;
+	if (rtllib_act_scanning(ieee,true) == true)
+		return;
+
+	down(&ieee->scan_sem);
+
+	if (ieee->eRFPowerState == eRfOff)
+	{
+		printk("======>%s():rf state is eRfOff, return\n",__func__);
+		goto out1;
+	}
+
+	do{
+		ieee->current_network.channel =
+			(ieee->current_network.channel + 1) % MAX_CHANNEL_NUMBER;
+		if (ieee->scan_watch_dog++ > MAX_CHANNEL_NUMBER)
+		{
+			if (!ieee->active_channel_map[ieee->current_network.channel])
+				ieee->current_network.channel = 6;
+			goto out; /* no good chans */
+		}
+	} while(!ieee->active_channel_map[ieee->current_network.channel]);
+
+	if (ieee->scanning_continue == 0 )
+		goto out;
+
+	ieee->set_chan(ieee->dev, ieee->current_network.channel);
+
+	if (ieee->active_channel_map[ieee->current_network.channel] == 1)
+	rtllib_send_probe_requests(ieee, 0);
+
+	queue_delayed_work_rsl(ieee->wq, &ieee->softmac_scan_wq, MSECS(RTLLIB_SOFTMAC_SCAN_TIME));
+
+	up(&ieee->scan_sem);
+	return;
+
+out:
+#ifdef ENABLE_DOT11D
+	if (IS_DOT11D_ENABLE(ieee))
+		DOT11D_ScanComplete(ieee);
+#endif
+	ieee->current_network.channel = last_channel;
+
+out1:
+	ieee->actscanning = false;
+	ieee->scan_watch_dog = 0;
+	ieee->scanning_continue = 0;
+	up(&ieee->scan_sem);
+}
+
+
+
+void rtllib_beacons_start(struct rtllib_device *ieee)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&ieee->beacon_lock,flags);
+
+	ieee->beacon_txing = 1;
+	rtllib_send_beacon(ieee);
+
+	spin_unlock_irqrestore(&ieee->beacon_lock,flags);
+}
+
+void rtllib_beacons_stop(struct rtllib_device *ieee)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&ieee->beacon_lock,flags);
+
+	ieee->beacon_txing = 0;
+	del_timer_sync(&ieee->beacon_timer);
+
+	spin_unlock_irqrestore(&ieee->beacon_lock,flags);
+
+}
+
+
+void rtllib_stop_send_beacons(struct rtllib_device *ieee)
+{
+	if (ieee->stop_send_beacons)
+		ieee->stop_send_beacons(ieee->dev);
+	if (ieee->softmac_features & IEEE_SOFTMAC_BEACONS)
+		rtllib_beacons_stop(ieee);
+}
+
+
+void rtllib_start_send_beacons(struct rtllib_device *ieee)
+{
+	if (ieee->start_send_beacons)
+		ieee->start_send_beacons(ieee->dev);
+	if (ieee->softmac_features & IEEE_SOFTMAC_BEACONS)
+		rtllib_beacons_start(ieee);
+}
+
+
+void rtllib_softmac_stop_scan(struct rtllib_device *ieee)
+{
+
+
+	down(&ieee->scan_sem);
+	ieee->scan_watch_dog = 0;
+	if (ieee->scanning_continue == 1){
+		ieee->scanning_continue = 0;
+		ieee->actscanning = 0;
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,40)
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,67)
+		cancel_delayed_work(&ieee->softmac_scan_wq);
+#endif
+#else
+		del_timer_sync(&ieee->scan_timer);
+#endif
+	}
+
+	up(&ieee->scan_sem);
+}
+
+void rtllib_stop_scan(struct rtllib_device *ieee)
+{
+	if (ieee->softmac_features & IEEE_SOFTMAC_SCAN){
+		rtllib_softmac_stop_scan(ieee);
+	}else{
+		if (ieee->rtllib_stop_hw_scan)
+			ieee->rtllib_stop_hw_scan(ieee->dev);
+	}
+}
+
+void rtllib_stop_scan_syncro(struct rtllib_device *ieee)
+{
+	if (ieee->softmac_features & IEEE_SOFTMAC_SCAN){
+			ieee->sync_scan_hurryup = 1;
+	}else{
+		if (ieee->rtllib_stop_hw_scan)
+			ieee->rtllib_stop_hw_scan(ieee->dev);
+	}
+}
+
+bool rtllib_act_scanning(struct rtllib_device *ieee, bool sync_scan)
+{
+	if (ieee->softmac_features & IEEE_SOFTMAC_SCAN){
+		if (sync_scan){
+			return ieee->be_scan_inprogress;
+		}else{
+			return (ieee->actscanning ||ieee->be_scan_inprogress);
+		}
+	}else{
+		return test_bit(STATUS_SCANNING, &ieee->status);
+	}
+}
+
+/* called with ieee->lock held */
+void rtllib_start_scan(struct rtllib_device *ieee)
+{
+	RT_TRACE(COMP_DBG, "===>%s()\n",__func__);
+	if (ieee->rtllib_ips_leave_wq != NULL)
+	ieee->rtllib_ips_leave_wq(ieee->dev);
+
+
+#ifdef ENABLE_DOT11D
+	if (IS_DOT11D_ENABLE(ieee) )
+	{
+		if (IS_COUNTRY_IE_VALID(ieee))
+		{
+			RESET_CIE_WATCHDOG(ieee);
+		}
+	}
+#endif
+	if (ieee->softmac_features & IEEE_SOFTMAC_SCAN) {
+		if (ieee->scanning_continue == 0) {
+			ieee->actscanning = true;
+			ieee->scanning_continue = 1;
+			queue_delayed_work_rsl(ieee->wq, &ieee->softmac_scan_wq, 0);
+		}
+	} else {
+		if (ieee->rtllib_start_hw_scan)
+			ieee->rtllib_start_hw_scan(ieee->dev);
+	}
+
+}
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,5,40)
+void rtllib_softmac_scan_cb(unsigned long _dev)
+{
+	unsigned long flags;
+	struct rtllib_device *ieee = (struct rtllib_device *)_dev;
+
+	spin_lock_irqsave(&ieee->lock, flags);
+	rtllib_start_scan(ieee);
+	spin_unlock_irqrestore(&ieee->lock, flags);
+}
+#endif
+
+/* called with wx_sem held */
+void rtllib_start_scan_syncro(struct rtllib_device *ieee, u8 is_mesh)
+{
+#ifdef ENABLE_DOT11D
+	if (IS_DOT11D_ENABLE(ieee) )
+	{
+		if (IS_COUNTRY_IE_VALID(ieee))
+		{
+			RESET_CIE_WATCHDOG(ieee);
+		}
+	}
+#endif
+	ieee->sync_scan_hurryup = 0;
+	if (ieee->softmac_features & IEEE_SOFTMAC_SCAN){
+		rtllib_softmac_scan_syncro(ieee, is_mesh);
+	}else{
+		if (ieee->rtllib_start_hw_scan)
+			ieee->rtllib_start_hw_scan(ieee->dev);
+	}
+
+}
+
+inline struct sk_buff *rtllib_authentication_req(struct rtllib_network *beacon,
+	struct rtllib_device *ieee, int challengelen,u8 * daddr)
+{
+	struct sk_buff *skb;
+	struct rtllib_authentication *auth;
+	int  len = 0;
+	len = sizeof(struct rtllib_authentication) + challengelen + ieee->tx_headroom + 4;
+#ifdef USB_USE_ALIGNMENT
+        u32 Tmpaddr;
+        int alignment;
+        skb = dev_alloc_skb(len + USB_512B_ALIGNMENT_SIZE);
+#else
+	skb = dev_alloc_skb(len);
+#endif
+
+	if (!skb) return NULL;
+
+#ifdef USB_USE_ALIGNMENT
+        Tmpaddr = (u32)skb->data;
+        alignment = Tmpaddr & 0x1ff;
+        skb_reserve(skb,(USB_512B_ALIGNMENT_SIZE - alignment));
+#endif
+
+	skb_reserve(skb, ieee->tx_headroom);
+
+	auth = (struct rtllib_authentication *)
+		skb_put(skb, sizeof(struct rtllib_authentication));
+
+	auth->header.frame_ctl = RTLLIB_STYPE_AUTH;
+	if (challengelen) auth->header.frame_ctl |= RTLLIB_FCTL_WEP;
+
+	auth->header.duration_id = 0x013a;
+		memcpy(auth->header.addr1, beacon->bssid, ETH_ALEN);
+	memcpy(auth->header.addr2, ieee->dev->dev_addr, ETH_ALEN);
+	memcpy(auth->header.addr3, beacon->bssid, ETH_ALEN);
+	if (ieee->auth_mode == 0)
+		auth->algorithm = WLAN_AUTH_OPEN;
+	else if (ieee->auth_mode == 1)
+		auth->algorithm = WLAN_AUTH_SHARED_KEY;
+	else if (ieee->auth_mode == 2)
+		auth->algorithm = WLAN_AUTH_OPEN;
+	auth->transaction = cpu_to_le16(ieee->associate_seq);
+	ieee->associate_seq++;
+
+	auth->status = cpu_to_le16(WLAN_STATUS_SUCCESS);
+
+	return skb;
+
+}
+
+void constructWMMIE(u8* wmmie, u8* wmm_len,u8 oui_subtype)
+{
+	u8	szQoSOUI[] ={221, 0, 0x00, 0x50, 0xf2, 0x02, 0, 1};
+
+	if (oui_subtype == OUI_SUBTYPE_QOS_CAPABI)
+	{
+		szQoSOUI[0] = 46;
+		szQoSOUI[1] = *wmm_len;
+		memcpy(wmmie,szQoSOUI,3);
+		*wmm_len = 3;
+	}
+	else
+	{
+		szQoSOUI[1] = *wmm_len + 6;
+		szQoSOUI[6] = oui_subtype;
+		memcpy(wmmie, szQoSOUI, 8);
+		*(wmmie+8) = 0;
+		*wmm_len = 9;
+	}
+}
+
+static struct sk_buff* rtllib_probe_resp(struct rtllib_device *ieee, u8 *dest)
+{
+	u8 *tag;
+	int beacon_size;
+	struct rtllib_probe_response *beacon_buf;
+	struct sk_buff *skb = NULL;
+	int encrypt;
+	int atim_len,erp_len;
+	struct rtllib_crypt_data* crypt;
+
+	char *ssid = ieee->current_network.ssid;
+	int ssid_len = ieee->current_network.ssid_len;
+	int rate_len = ieee->current_network.rates_len+2;
+	int rate_ex_len = ieee->current_network.rates_ex_len;
+	int wpa_ie_len = ieee->wpa_ie_len;
+	u8 erpinfo_content = 0;
+
+	u8* tmp_ht_cap_buf = NULL;
+	u8 tmp_ht_cap_len = 0;
+	u8* tmp_ht_info_buf = NULL;
+	u8 tmp_ht_info_len = 0;
+	PRT_HIGH_THROUGHPUT	pHTInfo = ieee->pHTInfo;
+	u8* tmp_generic_ie_buf = NULL;
+	u8 tmp_generic_ie_len = 0;
+
+	if (rate_ex_len > 0)
+		rate_ex_len+=2;
+
+	if (ieee->current_network.capability & WLAN_CAPABILITY_IBSS)
+		atim_len = 4;
+	else
+		atim_len = 0;
+
+      if ((ieee->current_network.mode == IEEE_G)
+		||( ieee->current_network.mode == IEEE_N_24G && ieee->pHTInfo->bCurSuppCCK)) {
+		erp_len = 3;
+		erpinfo_content = 0;
+		if (ieee->current_network.buseprotection)
+			erpinfo_content |= ERP_UseProtection;
+	}
+	else
+		erp_len = 0;
+
+	crypt = ieee->crypt[ieee->tx_keyidx];
+	encrypt = ieee->host_encrypt && crypt && crypt->ops &&
+		((0 == strcmp(crypt->ops->name, "WEP") || wpa_ie_len));
+	if (ieee->pHTInfo->bCurrentHTSupport){
+		tmp_ht_cap_buf =(u8*) &(ieee->pHTInfo->SelfHTCap);
+		tmp_ht_cap_len = sizeof(ieee->pHTInfo->SelfHTCap);
+		tmp_ht_info_buf =(u8*) &(ieee->pHTInfo->SelfHTInfo);
+		tmp_ht_info_len = sizeof(ieee->pHTInfo->SelfHTInfo);
+		HTConstructCapabilityElement(ieee, tmp_ht_cap_buf, &tmp_ht_cap_len,encrypt, false);
+		HTConstructInfoElement(ieee,tmp_ht_info_buf,&tmp_ht_info_len, encrypt);
+
+
+		if (pHTInfo->bRegRT2RTAggregation)
+		{
+			tmp_generic_ie_buf = ieee->pHTInfo->szRT2RTAggBuffer;
+			tmp_generic_ie_len = sizeof(ieee->pHTInfo->szRT2RTAggBuffer);
+			HTConstructRT2RTAggElement(ieee, tmp_generic_ie_buf, &tmp_generic_ie_len);
+		}
+	}
+
+	beacon_size = sizeof(struct rtllib_probe_response)+2+
+		ssid_len
+		+3
+		+rate_len
+		+rate_ex_len
+		+atim_len
+		+erp_len
+		+wpa_ie_len
+		+ieee->tx_headroom;
+#ifdef USB_USE_ALIGNMENT
+        u32 Tmpaddr=0;
+        int alignment=0;
+        skb = dev_alloc_skb(beacon_size + USB_512B_ALIGNMENT_SIZE);
+#else
+	skb = dev_alloc_skb(beacon_size);
+#endif
+	if (!skb)
+		return NULL;
+
+#ifdef USB_USE_ALIGNMENT
+        Tmpaddr = (u32)skb->data;
+        alignment = Tmpaddr & 0x1ff;
+        skb_reserve(skb,(USB_512B_ALIGNMENT_SIZE - alignment));
+#endif
+
+	skb_reserve(skb, ieee->tx_headroom);
+
+	beacon_buf = (struct rtllib_probe_response*) skb_put(skb, (beacon_size - ieee->tx_headroom));
+	memcpy (beacon_buf->header.addr1, dest,ETH_ALEN);
+	memcpy (beacon_buf->header.addr2, ieee->dev->dev_addr, ETH_ALEN);
+	memcpy (beacon_buf->header.addr3, ieee->current_network.bssid, ETH_ALEN);
+
+	beacon_buf->header.duration_id = 0;
+	beacon_buf->beacon_interval =
+		cpu_to_le16(ieee->current_network.beacon_interval);
+	beacon_buf->capability =
+		cpu_to_le16(ieee->current_network.capability & WLAN_CAPABILITY_IBSS);
+	beacon_buf->capability |=
+		cpu_to_le16(ieee->current_network.capability & WLAN_CAPABILITY_SHORT_PREAMBLE);
+
+	if (ieee->short_slot && (ieee->current_network.capability & WLAN_CAPABILITY_SHORT_SLOT_TIME))
+		cpu_to_le16((beacon_buf->capability |= WLAN_CAPABILITY_SHORT_SLOT_TIME));
+
+	crypt = ieee->crypt[ieee->tx_keyidx];
+	if (encrypt)
+		beacon_buf->capability |= cpu_to_le16(WLAN_CAPABILITY_PRIVACY);
+
+
+	beacon_buf->header.frame_ctl = cpu_to_le16(RTLLIB_STYPE_PROBE_RESP);
+	beacon_buf->info_element[0].id = MFIE_TYPE_SSID;
+	beacon_buf->info_element[0].len = ssid_len;
+
+	tag = (u8*) beacon_buf->info_element[0].data;
+
+	memcpy(tag, ssid, ssid_len);
+
+	tag += ssid_len;
+
+	*(tag++) = MFIE_TYPE_RATES;
+	*(tag++) = rate_len-2;
+	memcpy(tag,ieee->current_network.rates,rate_len-2);
+	tag+=rate_len-2;
+
+	*(tag++) = MFIE_TYPE_DS_SET;
+	*(tag++) = 1;
+	*(tag++) = ieee->current_network.channel;
+
+	if (atim_len){
+	u16 val16;
+		*(tag++) = MFIE_TYPE_IBSS_SET;
+		*(tag++) = 2;
+		 val16 = cpu_to_le16(ieee->current_network.atim_window);
+		memcpy((u8 *)tag, (u8 *)&val16, 2);
+		tag+=2;
+	}
+
+	if (erp_len){
+		*(tag++) = MFIE_TYPE_ERP;
+		*(tag++) = 1;
+		*(tag++) = erpinfo_content;
+	}
+#if defined(RTL8192U) || defined(RTL8192SU) || defined(RTL8192SE)
+	if (tmp_ht_cap_len){
+		*(tag++) = MFIE_TYPE_HT_CAP;
+		*(tag++) = tmp_ht_cap_len - 2;
+		memcpy(tag, tmp_ht_cap_buf, tmp_ht_cap_len - 2);
+		tag += tmp_ht_cap_len - 2;
+	}
+#endif
+	if (rate_ex_len){
+		*(tag++) = MFIE_TYPE_RATES_EX;
+		*(tag++) = rate_ex_len-2;
+		memcpy(tag,ieee->current_network.rates_ex,rate_ex_len-2);
+		tag+=rate_ex_len-2;
+	}
+
+#if defined(RTL8192U) || defined(RTL8192SU) || defined(RTL8192SE)
+	if (tmp_ht_info_len){
+		*(tag++) = MFIE_TYPE_HT_INFO;
+		*(tag++) = tmp_ht_info_len - 2;
+		memcpy(tag, tmp_ht_info_buf, tmp_ht_info_len -2);
+		tag += tmp_ht_info_len - 2;
+	}
+#endif
+
+	if (wpa_ie_len)
+	{
+		if (ieee->iw_mode == IW_MODE_ADHOC)
+		{
+			memcpy(&ieee->wpa_ie[14], &ieee->wpa_ie[8], 4);
+		}
+		memcpy(tag, ieee->wpa_ie, ieee->wpa_ie_len);
+		tag += ieee->wpa_ie_len;
+	}
+
+#if defined(RTL8192U) || defined(RTL8192SU) || defined(RTL8192SE)
+	if (tmp_generic_ie_len)
+	{
+		(*tag++) = 0xdd;
+		(*tag++) = tmp_generic_ie_len - 2;
+		memcpy(tag,tmp_generic_ie_buf,tmp_generic_ie_len -2);
+		tag += tmp_generic_ie_len -2;
+
+	}
+#endif
+
+#if defined(RTL8192U) || defined(RTL8192SU) || defined(RTL8192SE)
+	if (wmm_len) {
+		memcpy(tag,wmmie,wmm_len);
+		tag += wmm_len;
+	}
+#endif
+	return skb;
+}
+
+struct sk_buff* rtllib_assoc_resp(struct rtllib_device *ieee, u8 *dest)
+{
+	struct sk_buff *skb;
+	u8* tag;
+
+	struct rtllib_crypt_data* crypt;
+	struct rtllib_assoc_response_frame *assoc;
+	short encrypt;
+
+	unsigned int rate_len = rtllib_MFIE_rate_len(ieee);
+	int len = sizeof(struct rtllib_assoc_response_frame) + rate_len + ieee->tx_headroom;
+
+#ifdef USB_USE_ALIGNMENT
+        u32 Tmpaddr=0;
+        int alignment=0;
+        skb = dev_alloc_skb(len + USB_512B_ALIGNMENT_SIZE);
+#else
+	skb = dev_alloc_skb(len);
+#endif
+
+	if (!skb)
+		return NULL;
+
+#ifdef USB_USE_ALIGNMENT
+        Tmpaddr = (u32)skb->data;
+        alignment = Tmpaddr & 0x1ff;
+        skb_reserve(skb,(USB_512B_ALIGNMENT_SIZE - alignment));
+#endif
+
+	skb_reserve(skb, ieee->tx_headroom);
+
+	assoc = (struct rtllib_assoc_response_frame *)
+		skb_put(skb,sizeof(struct rtllib_assoc_response_frame));
+
+	assoc->header.frame_ctl = cpu_to_le16(RTLLIB_STYPE_ASSOC_RESP);
+	memcpy(assoc->header.addr1, dest,ETH_ALEN);
+	memcpy(assoc->header.addr3, ieee->dev->dev_addr, ETH_ALEN);
+	memcpy(assoc->header.addr2, ieee->dev->dev_addr, ETH_ALEN);
+	assoc->capability = cpu_to_le16(ieee->iw_mode == IW_MODE_MASTER ?
+		WLAN_CAPABILITY_ESS : WLAN_CAPABILITY_IBSS);
+
+
+	if (ieee->short_slot)
+		assoc->capability |= cpu_to_le16(WLAN_CAPABILITY_SHORT_SLOT_TIME);
+
+	if (ieee->host_encrypt)
+		crypt = ieee->crypt[ieee->tx_keyidx];
+	else
+		crypt = NULL;
+
+	encrypt = ( crypt && crypt->ops);
+
+	if (encrypt)
+		assoc->capability |= cpu_to_le16(WLAN_CAPABILITY_PRIVACY);
+
+	assoc->status = 0;
+	assoc->aid = cpu_to_le16(ieee->assoc_id);
+	if (ieee->assoc_id == 0x2007)
+		ieee->assoc_id=0;
+	else
+		ieee->assoc_id++;
+
+	tag = (u8*) skb_put(skb, rate_len);
+	rtllib_MFIE_Brate(ieee, &tag);
+	rtllib_MFIE_Grate(ieee, &tag);
+
+	return skb;
+}
+
+struct sk_buff* rtllib_auth_resp(struct rtllib_device *ieee,int status, u8 *dest)
+{
+	struct sk_buff *skb = NULL;
+	struct rtllib_authentication *auth;
+	int len = ieee->tx_headroom + sizeof(struct rtllib_authentication)+1;
+#ifdef USB_USE_ALIGNMENT
+        u32 Tmpaddr=0;
+        int alignment=0;
+        skb = dev_alloc_skb(len + USB_512B_ALIGNMENT_SIZE);
+#else
+	skb = dev_alloc_skb(len);
+#endif
+	if (!skb)
+		return NULL;
+
+	skb->len = sizeof(struct rtllib_authentication);
+
+#ifdef USB_USE_ALIGNMENT
+        Tmpaddr = (u32)skb->data;
+        alignment = Tmpaddr & 0x1ff;
+        skb_reserve(skb,(USB_512B_ALIGNMENT_SIZE - alignment));
+#endif
+
+	skb_reserve(skb, ieee->tx_headroom);
+
+	auth = (struct rtllib_authentication *)
+		skb_put(skb, sizeof(struct rtllib_authentication));
+
+	auth->status = cpu_to_le16(status);
+	auth->transaction = cpu_to_le16(2);
+	auth->algorithm = cpu_to_le16(WLAN_AUTH_OPEN);
+
+	memcpy(auth->header.addr3, ieee->dev->dev_addr, ETH_ALEN);
+	memcpy(auth->header.addr2, ieee->dev->dev_addr, ETH_ALEN);
+	memcpy(auth->header.addr1, dest, ETH_ALEN);
+	auth->header.frame_ctl = cpu_to_le16(RTLLIB_STYPE_AUTH);
+	return skb;
+
+
+}
+
+struct sk_buff* rtllib_null_func(struct rtllib_device *ieee,short pwr)
+{
+	struct sk_buff *skb;
+	struct rtllib_hdr_3addr* hdr;
+
+#ifdef USB_USE_ALIGNMENT
+        u32 Tmpaddr=0;
+        int alignment=0;
+        skb = dev_alloc_skb(sizeof(struct rtllib_hdr_3addr) + ieee->tx_headroom + USB_512B_ALIGNMENT_SIZE);
+#else
+	skb = dev_alloc_skb(sizeof(struct rtllib_hdr_3addr)+ieee->tx_headroom);
+#endif
+	if (!skb)
+		return NULL;
+
+#ifdef USB_USE_ALIGNMENT
+        Tmpaddr = (u32)skb->data;
+        alignment = Tmpaddr & 0x1ff;
+        skb_reserve(skb,(USB_512B_ALIGNMENT_SIZE - alignment));
+#endif
+	skb_reserve(skb, ieee->tx_headroom);
+
+	hdr = (struct rtllib_hdr_3addr*)skb_put(skb,sizeof(struct rtllib_hdr_3addr));
+
+	memcpy(hdr->addr1, ieee->current_network.bssid, ETH_ALEN);
+	memcpy(hdr->addr2, ieee->dev->dev_addr, ETH_ALEN);
+	memcpy(hdr->addr3, ieee->current_network.bssid, ETH_ALEN);
+
+	hdr->frame_ctl = cpu_to_le16(RTLLIB_FTYPE_DATA |
+		RTLLIB_STYPE_NULLFUNC | RTLLIB_FCTL_TODS |
+		(pwr ? RTLLIB_FCTL_PM:0));
+
+	return skb;
+
+
+}
+
+struct sk_buff* rtllib_pspoll_func(struct rtllib_device *ieee)
+{
+	struct sk_buff *skb;
+	struct rtllib_pspoll_hdr* hdr;
+
+#ifdef USB_USE_ALIGNMENT
+        u32 Tmpaddr=0;
+        int alignment=0;
+        skb = dev_alloc_skb(sizeof(struct rtllib_pspoll_hdr) + ieee->tx_headroom + USB_512B_ALIGNMENT_SIZE);
+#else
+	skb = dev_alloc_skb(sizeof(struct rtllib_pspoll_hdr)+ieee->tx_headroom);
+#endif
+	if (!skb)
+		return NULL;
+
+#ifdef USB_USE_ALIGNMENT
+        Tmpaddr = (u32)skb->data;
+        alignment = Tmpaddr & 0x1ff;
+        skb_reserve(skb,(USB_512B_ALIGNMENT_SIZE - alignment));
+#endif
+	skb_reserve(skb, ieee->tx_headroom);
+
+	hdr = (struct rtllib_pspoll_hdr*)skb_put(skb,sizeof(struct rtllib_pspoll_hdr));
+
+	memcpy(hdr->bssid, ieee->current_network.bssid, ETH_ALEN);
+	memcpy(hdr->ta, ieee->dev->dev_addr, ETH_ALEN);
+
+	hdr->aid = cpu_to_le16(ieee->assoc_id | 0xc000);
+	hdr->frame_ctl = cpu_to_le16(RTLLIB_FTYPE_CTL |RTLLIB_STYPE_PSPOLL | RTLLIB_FCTL_PM);
+
+	return skb;
+
+}
+
+void rtllib_resp_to_assoc_rq(struct rtllib_device *ieee, u8* dest)
+{
+	struct sk_buff *buf = rtllib_assoc_resp(ieee, dest);
+
+	if (buf)
+		softmac_mgmt_xmit(buf, ieee);
+}
+
+
+void rtllib_resp_to_auth(struct rtllib_device *ieee, int s, u8* dest)
+{
+	struct sk_buff *buf = rtllib_auth_resp(ieee, s, dest);
+
+	if (buf)
+		softmac_mgmt_xmit(buf, ieee);
+}
+
+
+void rtllib_resp_to_probe(struct rtllib_device *ieee, u8 *dest)
+{
+
+	struct sk_buff *buf = rtllib_probe_resp(ieee, dest);
+	if (buf)
+		softmac_mgmt_xmit(buf, ieee);
+}
+
+
+inline int SecIsInPMKIDList(struct rtllib_device *ieee, u8 *bssid)
+{
+	int i = 0;
+
+	do
+	{
+		if ((ieee->PMKIDList[i].bUsed) && (memcmp(ieee->PMKIDList[i].Bssid, bssid, ETH_ALEN) == 0))
+		{
+			break;
+		}
+		else
+		{
+			i++;
+		}
+	} while (i < NUM_PMKID_CACHE);
+
+	if (i == NUM_PMKID_CACHE)
+	{
+		i = -1;
+	}
+	else
+	{
+	}
+
+	return (i);
+
+}
+
+
+inline struct sk_buff *rtllib_association_req(struct rtllib_network *beacon,struct rtllib_device *ieee)
+{
+	struct sk_buff *skb;
+
+	struct rtllib_assoc_request_frame *hdr;
+	u8 *tag, *ies;
+	int i;
+	u8* ht_cap_buf = NULL;
+	u8 ht_cap_len=0;
+	u8* realtek_ie_buf=NULL;
+	u8 realtek_ie_len=0;
+	int wpa_ie_len= ieee->wpa_ie_len;
+	int wps_ie_len = ieee->wps_ie_len;
+	unsigned int ckip_ie_len=0;
+	unsigned int ccxrm_ie_len=0;
+	unsigned int cxvernum_ie_len=0;
+	struct rtllib_crypt_data* crypt;
+	int encrypt;
+	int	PMKCacheIdx;
+
+	unsigned int rate_len = (beacon->rates_len?(beacon->rates_len+2):0) + (beacon->rates_ex_len?(beacon->rates_ex_len)+2:0);
+
+	unsigned int wmm_info_len = beacon->qos_data.supported?9:0;
+	unsigned int turbo_info_len = beacon->Turbo_Enable?9:0;
+
+	int len = 0;
+	crypt = ieee->crypt[ieee->tx_keyidx];
+	if (crypt != NULL) {
+		encrypt = ieee->host_encrypt && crypt && crypt->ops && ((0 == strcmp(crypt->ops->name,"WEP") || wpa_ie_len));
+	} else {
+		encrypt = 0;
+	}
+
+#ifdef ENABLE_TKIP11N
+	if (ieee->bForcedBgMode == true)
+#else
+	if ((ieee->rtllib_ap_sec_type && (ieee->rtllib_ap_sec_type(ieee)&SEC_ALG_TKIP)) ||(ieee->bForcedBgMode == true))
+#endif
+	{
+		ieee->pHTInfo->bEnableHT = 0;
+		ieee->mode = WIRELESS_MODE_G;
+	}
+
+	if (ieee->pHTInfo->bCurrentHTSupport&&ieee->pHTInfo->bEnableHT)
+	{
+		ht_cap_buf = (u8*)&(ieee->pHTInfo->SelfHTCap);
+		ht_cap_len = sizeof(ieee->pHTInfo->SelfHTCap);
+		HTConstructCapabilityElement(ieee, ht_cap_buf, &ht_cap_len, encrypt, true);
+		if (ieee->pHTInfo->bCurrentRT2RTAggregation) {
+			realtek_ie_buf = ieee->pHTInfo->szRT2RTAggBuffer;
+			realtek_ie_len = sizeof( ieee->pHTInfo->szRT2RTAggBuffer);
+			HTConstructRT2RTAggElement(ieee, realtek_ie_buf, &realtek_ie_len);
+
+		}
+	}
+
+	if (beacon->bCkipSupported)
+	{
+		ckip_ie_len = 30+2;
+	}
+	if (beacon->bCcxRmEnable)
+	{
+		ccxrm_ie_len = 6+2;
+	}
+	if ( beacon->BssCcxVerNumber >= 2 )
+	{
+		cxvernum_ie_len = 5+2;
+	}
+
+	PMKCacheIdx = SecIsInPMKIDList(ieee, ieee->current_network.bssid);
+	if (PMKCacheIdx >= 0)
+	{
+		wpa_ie_len += 18;
+		printk("[PMK cache]: WPA2 IE length: %x\n", wpa_ie_len);
+	}
+	len = sizeof(struct rtllib_assoc_request_frame)+ 2
+		+ beacon->ssid_len
+		+ rate_len
+		+ wpa_ie_len
+		+ wps_ie_len
+		+ wmm_info_len
+		+ turbo_info_len
+                + ht_cap_len
+		+ realtek_ie_len
+		+ ckip_ie_len
+		+ ccxrm_ie_len
+		+ cxvernum_ie_len
+		+ ieee->tx_headroom;
+
+#ifdef USB_USE_ALIGNMENT
+	u32 Tmpaddr=0;
+	int alignment=0;
+	skb = dev_alloc_skb(len + USB_512B_ALIGNMENT_SIZE);
+#else
+	skb = dev_alloc_skb(len);
+#endif
+
+	if (!skb)
+		return NULL;
+
+#ifdef USB_USE_ALIGNMENT
+        Tmpaddr = (u32)skb->data;
+        alignment = Tmpaddr & 0x1ff;
+        skb_reserve(skb,(USB_512B_ALIGNMENT_SIZE - alignment));
+#endif
+
+	skb_reserve(skb, ieee->tx_headroom);
+
+	hdr = (struct rtllib_assoc_request_frame *)
+		skb_put(skb, sizeof(struct rtllib_assoc_request_frame)+2);
+
+
+	hdr->header.frame_ctl = RTLLIB_STYPE_ASSOC_REQ;
+	hdr->header.duration_id= 37;
+	memcpy(hdr->header.addr1, beacon->bssid, ETH_ALEN);
+	memcpy(hdr->header.addr2, ieee->dev->dev_addr, ETH_ALEN);
+	memcpy(hdr->header.addr3, beacon->bssid, ETH_ALEN);
+
+	memcpy(ieee->ap_mac_addr, beacon->bssid, ETH_ALEN);
+
+	hdr->capability = cpu_to_le16(WLAN_CAPABILITY_ESS);
+	if (beacon->capability & WLAN_CAPABILITY_PRIVACY )
+		hdr->capability |= cpu_to_le16(WLAN_CAPABILITY_PRIVACY);
+
+	if (beacon->capability & WLAN_CAPABILITY_SHORT_PREAMBLE)
+		hdr->capability |= cpu_to_le16(WLAN_CAPABILITY_SHORT_PREAMBLE);
+
+	if (ieee->short_slot && (beacon->capability&WLAN_CAPABILITY_SHORT_SLOT_TIME))
+		hdr->capability |= cpu_to_le16(WLAN_CAPABILITY_SHORT_SLOT_TIME);
+
+
+	hdr->listen_interval = beacon->listen_interval;
+
+	hdr->info_element[0].id = MFIE_TYPE_SSID;
+
+	hdr->info_element[0].len = beacon->ssid_len;
+	tag = skb_put(skb, beacon->ssid_len);
+	memcpy(tag, beacon->ssid, beacon->ssid_len);
+
+	tag = skb_put(skb, rate_len);
+
+	if (beacon->rates_len){
+		*tag++ = MFIE_TYPE_RATES;
+		*tag++ = beacon->rates_len;
+		for (i=0;i<beacon->rates_len;i++){
+			*tag++ = beacon->rates[i];
+		}
+	}
+
+	if (beacon->rates_ex_len){
+		*tag++ = MFIE_TYPE_RATES_EX;
+		*tag++ = beacon->rates_ex_len;
+		for (i=0;i<beacon->rates_ex_len;i++){
+			*tag++ = beacon->rates_ex[i];
+		}
+	}
+
+	if ( beacon->bCkipSupported )
+	{
+		static u8	AironetIeOui[] = {0x00, 0x01, 0x66};
+		u8	CcxAironetBuf[30];
+		OCTET_STRING	osCcxAironetIE;
+
+		memset(CcxAironetBuf, 0,30);
+		osCcxAironetIE.Octet = CcxAironetBuf;
+		osCcxAironetIE.Length = sizeof(CcxAironetBuf);
+		memcpy(osCcxAironetIE.Octet, AironetIeOui, sizeof(AironetIeOui));
+
+		osCcxAironetIE.Octet[IE_CISCO_FLAG_POSITION] |=  (SUPPORT_CKIP_PK|SUPPORT_CKIP_MIC) ;
+		tag = skb_put(skb, ckip_ie_len);
+		*tag++ = MFIE_TYPE_AIRONET;
+		*tag++ = osCcxAironetIE.Length;
+		memcpy(tag,osCcxAironetIE.Octet,osCcxAironetIE.Length);
+		tag += osCcxAironetIE.Length;
+	}
+
+	if (beacon->bCcxRmEnable)
+	{
+		static u8 CcxRmCapBuf[] = {0x00, 0x40, 0x96, 0x01, 0x01, 0x00};
+		OCTET_STRING osCcxRmCap;
+
+		osCcxRmCap.Octet = CcxRmCapBuf;
+		osCcxRmCap.Length = sizeof(CcxRmCapBuf);
+		tag = skb_put(skb,ccxrm_ie_len);
+		*tag++ = MFIE_TYPE_GENERIC;
+		*tag++ = osCcxRmCap.Length;
+		memcpy(tag,osCcxRmCap.Octet,osCcxRmCap.Length);
+		tag += osCcxRmCap.Length;
+	}
+
+	if ( beacon->BssCcxVerNumber >= 2 )
+	{
+		u8			CcxVerNumBuf[] = {0x00, 0x40, 0x96, 0x03, 0x00};
+		OCTET_STRING	osCcxVerNum;
+		CcxVerNumBuf[4] = beacon->BssCcxVerNumber;
+		osCcxVerNum.Octet = CcxVerNumBuf;
+		osCcxVerNum.Length = sizeof(CcxVerNumBuf);
+		tag = skb_put(skb,cxvernum_ie_len);
+		*tag++ = MFIE_TYPE_GENERIC;
+		*tag++ = osCcxVerNum.Length;
+		memcpy(tag,osCcxVerNum.Octet,osCcxVerNum.Length);
+		tag += osCcxVerNum.Length;
+	}
+	if (ieee->pHTInfo->bCurrentHTSupport&&ieee->pHTInfo->bEnableHT){
+		if (ieee->pHTInfo->ePeerHTSpecVer != HT_SPEC_VER_EWC)
+		{
+			tag = skb_put(skb, ht_cap_len);
+			*tag++ = MFIE_TYPE_HT_CAP;
+			*tag++ = ht_cap_len - 2;
+			memcpy(tag, ht_cap_buf,ht_cap_len -2);
+			tag += ht_cap_len -2;
+		}
+	}
+
+
+	if (wpa_ie_len){
+		tag = skb_put(skb, ieee->wpa_ie_len);
+		memcpy(tag, ieee->wpa_ie, ieee->wpa_ie_len);
+
+		if (PMKCacheIdx >= 0)
+		{
+			tag = skb_put(skb, 18);
+			*tag = 1;
+			*(tag + 1) = 0;
+			memcpy((tag + 2), &ieee->PMKIDList[PMKCacheIdx].PMKID, 16);
+		}
+	}
+	if (wmm_info_len) {
+		tag = skb_put(skb,wmm_info_len);
+		rtllib_WMM_Info(ieee, &tag);
+	}
+
+	if (wps_ie_len && ieee->wps_ie) {
+		tag = skb_put(skb, wps_ie_len);
+		memcpy(tag, ieee->wps_ie, wps_ie_len);
+	}
+
+	tag = skb_put(skb,turbo_info_len);
+        if (turbo_info_len)
+                rtllib_TURBO_Info(ieee, &tag);
+
+	if (ieee->pHTInfo->bCurrentHTSupport&&ieee->pHTInfo->bEnableHT){
+		if (ieee->pHTInfo->ePeerHTSpecVer == HT_SPEC_VER_EWC)
+		{
+			tag = skb_put(skb, ht_cap_len);
+			*tag++ = MFIE_TYPE_GENERIC;
+			*tag++ = ht_cap_len - 2;
+			memcpy(tag, ht_cap_buf,ht_cap_len - 2);
+			tag += ht_cap_len -2;
+		}
+
+		if (ieee->pHTInfo->bCurrentRT2RTAggregation){
+			tag = skb_put(skb, realtek_ie_len);
+			*tag++ = MFIE_TYPE_GENERIC;
+			*tag++ = realtek_ie_len - 2;
+			memcpy(tag, realtek_ie_buf,realtek_ie_len -2 );
+		}
+	}
+
+	if (ieee->assocreq_ies){
+		kfree(ieee->assocreq_ies);
+		ieee->assocreq_ies = NULL;
+	}
+	ies = &(hdr->info_element[0].id);
+	ieee->assocreq_ies_len = (skb->data + skb->len) - ies;
+	ieee->assocreq_ies = kmalloc(ieee->assocreq_ies_len, GFP_ATOMIC);
+	if (ieee->assocreq_ies)
+		memcpy(ieee->assocreq_ies, ies, ieee->assocreq_ies_len);
+	else{
+		printk("%s()Warning: can't alloc memory for assocreq_ies\n", __func__);
+		ieee->assocreq_ies_len = 0;
+	}
+
+	return skb;
+}
+
+void rtllib_associate_abort(struct rtllib_device *ieee)
+{
+
+	unsigned long flags;
+	spin_lock_irqsave(&ieee->lock, flags);
+
+	ieee->associate_seq++;
+
+	/* don't scan, and avoid to have the RX path possibily
+	 * try again to associate. Even do not react to AUTH or
+	 * ASSOC response. Just wait for the retry wq to be scheduled.
+	 * Here we will check if there are good nets to associate
+	 * with, so we retry or just get back to NO_LINK and scanning
+	 */
+	if (ieee->state == RTLLIB_ASSOCIATING_AUTHENTICATING){
+		RTLLIB_DEBUG_MGMT("Authentication failed\n");
+		ieee->softmac_stats.no_auth_rs++;
+	}else{
+		RTLLIB_DEBUG_MGMT("Association failed\n");
+		ieee->softmac_stats.no_ass_rs++;
+	}
+
+	ieee->state = RTLLIB_ASSOCIATING_RETRY;
+
+	queue_delayed_work_rsl(ieee->wq, &ieee->associate_retry_wq, \
+                           RTLLIB_SOFTMAC_ASSOC_RETRY_TIME);
+
+	spin_unlock_irqrestore(&ieee->lock, flags);
+}
+
+void rtllib_associate_abort_cb(unsigned long dev)
+{
+	rtllib_associate_abort((struct rtllib_device *) dev);
+}
+
+void rtllib_associate_step1(struct rtllib_device *ieee,u8 * daddr)
+{
+	struct rtllib_network *beacon = &ieee->current_network;
+	struct sk_buff *skb;
+
+	RTLLIB_DEBUG_MGMT("Stopping scan\n");
+
+	ieee->softmac_stats.tx_auth_rq++;
+
+	skb=rtllib_authentication_req(beacon, ieee, 0,daddr);
+
+	if (!skb)
+		rtllib_associate_abort(ieee);
+	else{
+		ieee->state = RTLLIB_ASSOCIATING_AUTHENTICATING ;
+		RTLLIB_DEBUG_MGMT("Sending authentication request\n");
+		softmac_mgmt_xmit(skb, ieee);
+		if (!timer_pending(&ieee->associate_timer)){
+			ieee->associate_timer.expires = jiffies + (HZ / 2);
+			add_timer(&ieee->associate_timer);
+		}
+	}
+}
+
+void rtllib_auth_challenge(struct rtllib_device *ieee, u8 *challenge, int chlen)
+{
+	u8 *c;
+	struct sk_buff *skb;
+	struct rtllib_network *beacon = &ieee->current_network;
+
+	ieee->associate_seq++;
+	ieee->softmac_stats.tx_auth_rq++;
+
+	skb = rtllib_authentication_req(beacon, ieee, chlen+2,beacon->bssid);
+
+	if (!skb)
+		rtllib_associate_abort(ieee);
+	else{
+		c = skb_put(skb, chlen+2);
+		*(c++) = MFIE_TYPE_CHALLENGE;
+		*(c++) = chlen;
+		memcpy(c, challenge, chlen);
+
+		RTLLIB_DEBUG_MGMT("Sending authentication challenge response\n");
+
+		rtllib_encrypt_fragment(ieee, skb, sizeof(struct rtllib_hdr_3addr  ));
+
+		softmac_mgmt_xmit(skb, ieee);
+		mod_timer(&ieee->associate_timer, jiffies + (HZ/2));
+	}
+	kfree(challenge);
+}
+
+void rtllib_associate_step2(struct rtllib_device *ieee)
+{
+	struct sk_buff* skb;
+	struct rtllib_network *beacon = &ieee->current_network;
+
+	del_timer_sync(&ieee->associate_timer);
+
+	RTLLIB_DEBUG_MGMT("Sending association request\n");
+
+	ieee->softmac_stats.tx_ass_rq++;
+	skb=rtllib_association_req(beacon, ieee);
+	if (!skb)
+		rtllib_associate_abort(ieee);
+	else{
+		softmac_mgmt_xmit(skb, ieee);
+		mod_timer(&ieee->associate_timer, jiffies + (HZ/2));
+	}
+}
+
+#define CANCELLED  2
+void rtllib_associate_complete_wq(void *data)
+{
+	struct rtllib_device *ieee = (struct rtllib_device *)container_of_work_rsl(data, struct rtllib_device, associate_complete_wq);
+	PRT_POWER_SAVE_CONTROL pPSC = (PRT_POWER_SAVE_CONTROL)(&(ieee->PowerSaveControl));
+	printk(KERN_INFO "Associated successfully\n");
+	if (ieee->is_silent_reset == 0){
+            printk("normal associate\n");
+            notify_wx_assoc_event(ieee);
+        }
+
+	netif_carrier_on(ieee->dev);
+	ieee->is_roaming = false;
+	if (rtllib_is_54g(&ieee->current_network) &&
+		(ieee->modulation & RTLLIB_OFDM_MODULATION)){
+
+		ieee->rate = 108;
+		printk(KERN_INFO"Using G rates:%d\n", ieee->rate);
+	}else{
+		ieee->rate = 22;
+		ieee->SetWirelessMode(ieee->dev, IEEE_B);
+		printk(KERN_INFO"Using B rates:%d\n", ieee->rate);
+	}
+	if (ieee->pHTInfo->bCurrentHTSupport&&ieee->pHTInfo->bEnableHT)
+	{
+		printk("Successfully associated, ht enabled\n");
+		HTOnAssocRsp(ieee);
+	} else {
+		printk("Successfully associated, ht not enabled(%d, %d)\n",
+				ieee->pHTInfo->bCurrentHTSupport, ieee->pHTInfo->bEnableHT);
+		memset(ieee->dot11HTOperationalRateSet, 0, 16);
+	}
+	ieee->LinkDetectInfo.SlotNum = 2 * (1 + ieee->current_network.beacon_interval/500);
+	if (ieee->LinkDetectInfo.NumRecvBcnInPeriod==0||ieee->LinkDetectInfo.NumRecvDataInPeriod==0 )
+	{
+		ieee->LinkDetectInfo.NumRecvBcnInPeriod = 1;
+		ieee->LinkDetectInfo.NumRecvDataInPeriod= 1;
+	}
+	pPSC->LpsIdleCount = 0;
+	ieee->link_change(ieee->dev);
+
+        if (ieee->is_silent_reset == 1) {
+		printk("silent reset associate\n");
+		ieee->is_silent_reset = 0;
+        }
+
+	if (ieee->data_hard_resume)
+		ieee->data_hard_resume(ieee->dev);
+
+#ifdef RTK_DMP_PLATFORM
+	kobject_hotplug(&ieee->dev->class_dev.kobj, KOBJ_LINKUP);
+#endif
+}
+
+static void rtllib_sta_send_associnfo(struct rtllib_device *ieee)
+{
+	char *buf;
+	size_t len;
+	int i;
+	union iwreq_data wrqu;
+
+		return;
+
+
+	buf = kmalloc(50 + 2 * (ieee->assocreq_ies_len + ieee->assocresp_ies_len), GFP_ATOMIC);
+	if (!buf)
+		return;
+
+	len = sprintf(buf, "ASSOCINFO(");
+	if (ieee->assocreq_ies) {
+		len += sprintf(buf + len, "ReqIEs=");
+		for (i = 0; i < ieee->assocreq_ies_len; i++) {
+			len += sprintf(buf + len, "%02x", ieee->assocreq_ies[i]);
+		}
+	}
+	if (ieee->assocresp_ies) {
+		if (ieee->assocreq_ies)
+			len += sprintf(buf + len, " ");
+		len += sprintf(buf + len, "RespIEs=");
+		for (i = 0; i < ieee->assocresp_ies_len; i++) {
+			len += sprintf(buf + len, "%02x", ieee->assocresp_ies[i]);
+		}
+	}
+	len += sprintf(buf + len, ")");
+
+	if (len > IW_CUSTOM_MAX) {
+		len = sprintf(buf, "ASSOCRESPIE=");
+		for (i = 0; i < ieee->assocresp_ies_len; i++) {
+			len += sprintf(buf + len, "%02x", ieee->assocresp_ies[i]);
+		}
+	}
+
+	if (len <= IW_CUSTOM_MAX) {
+		memset(&wrqu, 0, sizeof(wrqu));
+		wrqu.data.length = len;
+		wireless_send_event(ieee->dev, IWEVCUSTOM, &wrqu, buf);
+	}
+
+	kfree(buf);
+}
+
+void rtllib_associate_complete(struct rtllib_device *ieee)
+{
+	del_timer_sync(&ieee->associate_timer);
+
+	ieee->state = RTLLIB_LINKED;
+	rtllib_sta_send_associnfo(ieee);
+
+	queue_work_rsl(ieee->wq, &ieee->associate_complete_wq);
+}
+
+void rtllib_associate_procedure_wq(void *data)
+{
+	struct rtllib_device *ieee = container_of_dwork_rsl(data, struct rtllib_device, associate_procedure_wq);
+	rtllib_stop_scan_syncro(ieee);
+	if (ieee->rtllib_ips_leave != NULL)
+		ieee->rtllib_ips_leave(ieee->dev);
+	down(&ieee->wx_sem);
+
+	if (ieee->data_hard_stop)
+		ieee->data_hard_stop(ieee->dev);
+
+	rtllib_stop_scan(ieee);
+	RT_TRACE(COMP_DBG, "===>%s(), chan:%d\n", __func__, ieee->current_network.channel);
+	HTSetConnectBwMode(ieee, HT_CHANNEL_WIDTH_20, HT_EXTCHNL_OFFSET_NO_EXT);
+	if (ieee->eRFPowerState == eRfOff)
+	{
+            RT_TRACE(COMP_DBG, "=============>%s():Rf state is eRfOff, schedule ipsleave wq again,return\n",__func__);
+		if (ieee->rtllib_ips_leave_wq != NULL)
+			ieee->rtllib_ips_leave_wq(ieee->dev);
+		up(&ieee->wx_sem);
+		return;
+	}
+	ieee->associate_seq = 1;
+
+	rtllib_associate_step1(ieee, ieee->current_network.bssid);
+
+	up(&ieee->wx_sem);
+}
+
+inline void rtllib_softmac_new_net(struct rtllib_device *ieee, struct rtllib_network *net)
+{
+	u8 tmp_ssid[IW_ESSID_MAX_SIZE+1];
+	int tmp_ssid_len = 0;
+
+	short apset,ssidset,ssidbroad,apmatch,ssidmatch;
+
+	/* we are interested in new new only if we are not associated
+	 * and we are not associating / authenticating
+	 */
+	if (ieee->state != RTLLIB_NOLINK)
+		return;
+
+	if ((ieee->iw_mode == IW_MODE_INFRA) && !(net->capability & WLAN_CAPABILITY_ESS))
+		return;
+
+	if ((ieee->iw_mode == IW_MODE_ADHOC) && !(net->capability & WLAN_CAPABILITY_IBSS))
+		return;
+
+	if ((ieee->iw_mode == IW_MODE_ADHOC) && (net->channel > ieee->ibss_maxjoin_chal)) {
+		return;
+	}
+	if (ieee->iw_mode == IW_MODE_INFRA || ieee->iw_mode == IW_MODE_ADHOC)
+		{
+		/* if the user specified the AP MAC, we need also the essid
+		 * This could be obtained by beacons or, if the network does not
+		 * broadcast it, it can be put manually.
+		 */
+		apset = ieee->wap_set;
+		ssidset = ieee->ssid_set;
+		ssidbroad =  !(net->ssid_len == 0 || net->ssid[0]== '\0');
+		apmatch = (memcmp(ieee->current_network.bssid, net->bssid, ETH_ALEN)==0);
+		if (!ssidbroad){
+			ssidmatch = (ieee->current_network.ssid_len == net->hidden_ssid_len)&&\
+					(!strncmp(ieee->current_network.ssid, net->hidden_ssid, net->hidden_ssid_len));
+			if (net->hidden_ssid_len > 0)
+                        {
+			        strncpy(net->ssid, net->hidden_ssid, net->hidden_ssid_len);
+			        net->ssid_len = net->hidden_ssid_len;
+                                ssidbroad = 1;
+                        }
+		}
+		else
+			ssidmatch = (ieee->current_network.ssid_len == net->ssid_len)&&\
+					(!strncmp(ieee->current_network.ssid, net->ssid, net->ssid_len));
+
+		if (	/* if the user set the AP check if match.
+		         * if the network does not broadcast essid we check the user supplyed ANY essid
+			 * if the network does broadcast and the user does not set essid it is OK
+			 * if the network does broadcast and the user did set essid chech if essid match
+			 */
+			( apset && apmatch &&
+				((ssidset && ssidbroad && ssidmatch) || (ssidbroad && !ssidset) || (!ssidbroad && ssidset)) )
+			/* if the ap is not set, check that the user set the bssid
+			 * and the network does bradcast and that those two bssid matches
+			 */
+			 ||  (!apset && ssidset && ssidbroad && ssidmatch) || (ieee->is_roaming && ssidset && ssidbroad && ssidmatch)
+			){
+				/* if the essid is hidden replace it with the
+				* essid provided by the user.
+				*/
+				if (!ssidbroad){
+					strncpy(tmp_ssid, ieee->current_network.ssid, IW_ESSID_MAX_SIZE);
+					tmp_ssid_len = ieee->current_network.ssid_len;
+				}
+				memcpy(&ieee->current_network, net, sizeof(struct rtllib_network));
+				if (!ssidbroad){
+					strncpy(ieee->current_network.ssid, tmp_ssid, IW_ESSID_MAX_SIZE);
+					ieee->current_network.ssid_len = tmp_ssid_len;
+				}
+				printk(KERN_INFO"Linking with %s,channel:%d, qos:%d, myHT:%d, networkHT:%d, mode:%x cur_net.flags:0x%x\n",ieee->current_network.ssid,ieee->current_network.channel, ieee->current_network.qos_data.supported, ieee->pHTInfo->bEnableHT, ieee->current_network.bssht.bdSupportHT, ieee->current_network.mode, ieee->current_network.flags);
+
+				if ((rtllib_act_scanning(ieee, false)) && !(ieee->softmac_features & IEEE_SOFTMAC_SCAN)){
+					rtllib_stop_scan_syncro(ieee);
+				}
+
+				ieee->hwscan_ch_bk = ieee->current_network.channel;
+				HTResetIOTSetting(ieee->pHTInfo);
+				ieee->wmm_acm = 0;
+				if (ieee->iw_mode == IW_MODE_INFRA) {
+					/* Join the network for the first time */
+					ieee->AsocRetryCount = 0;
+					if ((ieee->current_network.qos_data.supported == 1) &&
+					   ieee->current_network.bssht.bdSupportHT)
+						HTResetSelfAndSavePeerSetting(ieee, &(ieee->current_network));
+					else
+						ieee->pHTInfo->bCurrentHTSupport = false;
+
+					ieee->state = RTLLIB_ASSOCIATING;
+					if (ieee->LedControlHandler != NULL)
+					        ieee->LedControlHandler(ieee->dev, LED_CTL_START_TO_LINK);
+					queue_delayed_work_rsl(ieee->wq, &ieee->associate_procedure_wq, 0);
+				} else {
+					if (rtllib_is_54g(&ieee->current_network) &&
+						(ieee->modulation & RTLLIB_OFDM_MODULATION)){
+						ieee->rate = 108;
+						ieee->SetWirelessMode(ieee->dev, IEEE_G);
+						printk(KERN_INFO"Using G rates\n");
+					}else{
+						ieee->rate = 22;
+						ieee->SetWirelessMode(ieee->dev, IEEE_B);
+						printk(KERN_INFO"Using B rates\n");
+					}
+					memset(ieee->dot11HTOperationalRateSet, 0, 16);
+					ieee->state = RTLLIB_LINKED;
+				}
+
+		}
+	}
+
+}
+
+void rtllib_softmac_check_all_nets(struct rtllib_device *ieee)
+{
+	unsigned long flags;
+	struct rtllib_network *target;
+
+	spin_lock_irqsave(&ieee->lock, flags);
+
+	list_for_each_entry(target, &ieee->network_list, list) {
+
+		/* if the state become different that NOLINK means
+		 * we had found what we are searching for
+		 */
+
+		if (ieee->state != RTLLIB_NOLINK)
+			break;
+
+		if (ieee->scan_age == 0 || time_after(target->last_scanned + ieee->scan_age, jiffies))
+		rtllib_softmac_new_net(ieee, target);
+	}
+
+	spin_unlock_irqrestore(&ieee->lock, flags);
+
+}
+
+
+static inline u16 auth_parse(struct sk_buff *skb, u8** challenge, int *chlen)
+{
+	struct rtllib_authentication *a;
+	u8 *t;
+	if (skb->len <  (sizeof(struct rtllib_authentication)-sizeof(struct rtllib_info_element))){
+		RTLLIB_DEBUG_MGMT("invalid len in auth resp: %d\n",skb->len);
+		return 0xcafe;
+	}
+	*challenge = NULL;
+	a = (struct rtllib_authentication*) skb->data;
+	if (skb->len > (sizeof(struct rtllib_authentication) +3)){
+		t = skb->data + sizeof(struct rtllib_authentication);
+
+		if (*(t++) == MFIE_TYPE_CHALLENGE){
+			*chlen = *(t++);
+			*challenge = (u8*)kmalloc(*chlen, GFP_ATOMIC);
+			memcpy(*challenge, t, *chlen);
+		}
+	}
+
+	return cpu_to_le16(a->status);
+
+}
+
+
+int auth_rq_parse(struct sk_buff *skb,u8* dest)
+{
+	struct rtllib_authentication *a;
+
+	if (skb->len <  (sizeof(struct rtllib_authentication)-sizeof(struct rtllib_info_element))){
+		RTLLIB_DEBUG_MGMT("invalid len in auth request: %d\n",skb->len);
+		return -1;
+	}
+	a = (struct rtllib_authentication*) skb->data;
+
+	memcpy(dest,a->header.addr2, ETH_ALEN);
+
+	if (le16_to_cpu(a->algorithm) != WLAN_AUTH_OPEN)
+		return  WLAN_STATUS_NOT_SUPPORTED_AUTH_ALG;
+
+	return WLAN_STATUS_SUCCESS;
+}
+
+static short probe_rq_parse(struct rtllib_device *ieee, struct sk_buff *skb, u8 *src)
+{
+	u8 *tag;
+	u8 *skbend;
+	u8 *ssid=NULL;
+	u8 ssidlen = 0;
+
+	struct rtllib_hdr_3addr   *header =
+		(struct rtllib_hdr_3addr   *) skb->data;
+
+	if (skb->len < sizeof (struct rtllib_hdr_3addr  ))
+		return -1; /* corrupted */
+        if ((memcmp(header->addr3,ieee->current_network.bssid,ETH_ALEN) != 0)&&
+                (memcmp(header->addr3,"\xff\xff\xff\xff\xff\xff",ETH_ALEN) != 0)) {
+            return -1;
+        }
+
+        if (memcmp(header->addr3,ieee->current_network.bssid,ETH_ALEN) == 0) {
+        }
+
+        if (memcmp(header->addr3,"\xff\xff\xff\xff\xff\xff",ETH_ALEN) == 0) {
+        }
+	memcpy(src,header->addr2, ETH_ALEN);
+
+	skbend = (u8*)skb->data + skb->len;
+
+	tag = skb->data + sizeof (struct rtllib_hdr_3addr  );
+
+	while (tag+1 < skbend){
+		if (*tag == 0){
+			ssid = tag+2;
+			ssidlen = *(tag+1);
+			break;
+		}
+		tag++; /* point to the len field */
+		tag = tag + *(tag); /* point to the last data byte of the tag */
+		tag++; /* point to the next tag */
+	}
+
+	if (ssidlen == 0) return 1;
+
+	if (!ssid) return 1; /* ssid not found in tagged param */
+	return (!strncmp(ssid, ieee->current_network.ssid, ssidlen));
+
+}
+
+int assoc_rq_parse(struct sk_buff *skb,u8* dest)
+{
+	struct rtllib_assoc_request_frame *a;
+
+	if (skb->len < (sizeof(struct rtllib_assoc_request_frame) -
+		sizeof(struct rtllib_info_element))) {
+
+		RTLLIB_DEBUG_MGMT("invalid len in auth request:%d \n", skb->len);
+		return -1;
+	}
+
+	a = (struct rtllib_assoc_request_frame*) skb->data;
+
+	memcpy(dest,a->header.addr2,ETH_ALEN);
+
+	return 0;
+}
+
+static inline u16 assoc_parse(struct rtllib_device *ieee, struct sk_buff *skb, int *aid)
+{
+	struct rtllib_assoc_response_frame *response_head;
+	u16 status_code;
+
+	if (skb->len <  sizeof(struct rtllib_assoc_response_frame)){
+		RTLLIB_DEBUG_MGMT("invalid len in auth resp: %d\n", skb->len);
+		return 0xcafe;
+	}
+
+	response_head = (struct rtllib_assoc_response_frame*) skb->data;
+	*aid = le16_to_cpu(response_head->aid) & 0x3fff;
+
+	status_code = le16_to_cpu(response_head->status);
+	if ((status_code==WLAN_STATUS_ASSOC_DENIED_RATES || \
+	   status_code==WLAN_STATUS_CAPS_UNSUPPORTED)&&
+	   ((ieee->mode == IEEE_G) &&
+	    (ieee->current_network.mode == IEEE_N_24G) &&
+            (ieee->AsocRetryCount++ < (RT_ASOC_RETRY_LIMIT-1)))) {
+                 ieee->pHTInfo->IOTAction |= HT_IOT_ACT_PURE_N_MODE;
+	}else {
+		 ieee->AsocRetryCount = 0;
+	}
+
+	return le16_to_cpu(response_head->status);
+}
+
+void rtllib_rx_probe_rq(struct rtllib_device *ieee, struct sk_buff *skb)
+{
+	u8 dest[ETH_ALEN];
+#if defined(RTL8192U) || defined(RTL8192SU) || defined(RTL8192SE)
+	struct sta_info *psta = NULL;
+#endif
+	ieee->softmac_stats.rx_probe_rq++;
+	if (probe_rq_parse(ieee, skb, dest) > 0){
+		ieee->softmac_stats.tx_probe_rs++;
+		rtllib_resp_to_probe(ieee, dest);
+#if defined(RTL8192U) || defined(RTL8192SU) || defined(RTL8192SE)
+		if (ieee->iw_mode == IW_MODE_ADHOC){
+			psta = GetStaInfo(ieee, dest);
+			if (NULL != psta)
+				psta->LastActiveTime = jiffies;
+		}
+#endif
+	}
+}
+
+static inline void rtllib_rx_auth_rq(struct rtllib_device *ieee, struct sk_buff *skb)
+{
+	u8 dest[ETH_ALEN];
+	int status;
+	ieee->softmac_stats.rx_auth_rq++;
+
+	if ((status = auth_rq_parse(skb, dest))!= -1){
+		rtllib_resp_to_auth(ieee, status, dest);
+	}
+
+}
+
+static inline void rtllib_rx_assoc_rq(struct rtllib_device *ieee, struct sk_buff *skb)
+{
+
+	u8 dest[ETH_ALEN];
+
+	ieee->softmac_stats.rx_ass_rq++;
+	if (assoc_rq_parse(skb,dest) != -1){
+		rtllib_resp_to_assoc_rq(ieee, dest);
+	}
+
+	printk(KERN_INFO"New client associated: "MAC_FMT"\n", MAC_ARG(dest));
+}
+
+
+void rtllib_sta_ps_send_null_frame(struct rtllib_device *ieee, short pwr)
+{
+
+	struct sk_buff *buf = rtllib_null_func(ieee, pwr);
+
+	if (buf)
+		softmac_ps_mgmt_xmit(buf, ieee);
+
+}
+
+void rtllib_sta_ps_send_pspoll_frame(struct rtllib_device *ieee)
+{
+
+	struct sk_buff *buf = rtllib_pspoll_func(ieee);
+
+	if (buf)
+		softmac_ps_mgmt_xmit(buf, ieee);
+
+}
+
+short rtllib_sta_ps_sleep(struct rtllib_device *ieee, u32 *time_h, u32 *time_l)
+{
+	int timeout = ieee->ps_timeout;
+	u8 dtim;
+	PRT_POWER_SAVE_CONTROL	pPSC = (PRT_POWER_SAVE_CONTROL)(&(ieee->PowerSaveControl));
+	/*if (ieee->ps == RTLLIB_PS_DISABLED ||
+		ieee->iw_mode != IW_MODE_INFRA ||
+		ieee->state != RTLLIB_LINKED)
+
+		return 0;
+	*/
+
+	if (ieee->LPSDelayCnt)
+	{
+		ieee->LPSDelayCnt --;
+		return 0;
+	}
+
+	dtim = ieee->current_network.dtim_data;
+	if (!(dtim & RTLLIB_DTIM_VALID))
+		return 0;
+	timeout = ieee->current_network.beacon_interval;
+	ieee->current_network.dtim_data = RTLLIB_DTIM_INVALID;
+	/* there's no need to nofity AP that I find you buffered with broadcast packet */
+	if (dtim & (RTLLIB_DTIM_UCAST & ieee->ps))
+		return 2;
+
+	if (!time_after(jiffies, ieee->dev->trans_start + MSECS(timeout))){
+		return 0;
+	}
+	if (!time_after(jiffies, ieee->last_rx_ps_time + MSECS(timeout))){
+		return 0;
+	}
+	if ((ieee->softmac_features & IEEE_SOFTMAC_SINGLE_QUEUE ) &&
+		(ieee->mgmt_queue_tail != ieee->mgmt_queue_head))
+		return 0;
+
+	if (time_l){
+		if (ieee->bAwakePktSent == true) {
+			pPSC->LPSAwakeIntvl = 1;
+		} else {
+			u8		MaxPeriod = 1;
+
+			if (pPSC->LPSAwakeIntvl == 0)
+				pPSC->LPSAwakeIntvl = 1;
+			if (pPSC->RegMaxLPSAwakeIntvl == 0)
+				MaxPeriod = 1;
+			else if (pPSC->RegMaxLPSAwakeIntvl == 0xFF)
+				MaxPeriod = ieee->current_network.dtim_period;
+			else
+				MaxPeriod = pPSC->RegMaxLPSAwakeIntvl;
+			pPSC->LPSAwakeIntvl = (pPSC->LPSAwakeIntvl >= MaxPeriod) ? MaxPeriod : (pPSC->LPSAwakeIntvl + 1);
+		}
+		{
+			u8 LPSAwakeIntvl_tmp = 0;
+			u8 period = ieee->current_network.dtim_period;
+			u8 count = ieee->current_network.tim.tim_count;
+			if (count == 0 ) {
+				if (pPSC->LPSAwakeIntvl > period)
+					LPSAwakeIntvl_tmp = period + (pPSC->LPSAwakeIntvl - period) -((pPSC->LPSAwakeIntvl-period)%period);
+				else
+					LPSAwakeIntvl_tmp = pPSC->LPSAwakeIntvl;
+
+			} else {
+				if (pPSC->LPSAwakeIntvl > ieee->current_network.tim.tim_count)
+					LPSAwakeIntvl_tmp = count + (pPSC->LPSAwakeIntvl - count) -((pPSC->LPSAwakeIntvl-count)%period);
+				else
+					LPSAwakeIntvl_tmp = pPSC->LPSAwakeIntvl;
+			}
+
+		*time_l = ieee->current_network.last_dtim_sta_time[0]
+			+ MSECS(ieee->current_network.beacon_interval * LPSAwakeIntvl_tmp);
+	}
+	}
+
+	if (time_h) {
+		*time_h = ieee->current_network.last_dtim_sta_time[1];
+		if (time_l && *time_l < ieee->current_network.last_dtim_sta_time[0])
+			*time_h += 1;
+	}
+
+	return 1;
+
+
+}
+
+inline void rtllib_sta_ps(struct rtllib_device *ieee)
+{
+
+	u32 th,tl;
+	short sleep;
+
+	unsigned long flags,flags2;
+
+	spin_lock_irqsave(&ieee->lock, flags);
+
+	if ((ieee->ps == RTLLIB_PS_DISABLED ||
+		ieee->iw_mode != IW_MODE_INFRA ||
+		ieee->state != RTLLIB_LINKED)){
+
+		RT_TRACE(COMP_DBG, "=====>%s(): no need to ps,wake up!! ieee->ps is %d,ieee->iw_mode is %d,ieee->state is %d\n",
+			__func__,ieee->ps,ieee->iw_mode,ieee->state);
+		spin_lock_irqsave(&ieee->mgmt_tx_lock, flags2);
+
+		rtllib_sta_wakeup(ieee, 1);
+
+		spin_unlock_irqrestore(&ieee->mgmt_tx_lock, flags2);
+	}
+
+	sleep = rtllib_sta_ps_sleep(ieee,&th, &tl);
+	/* 2 wake, 1 sleep, 0 do nothing */
+	if (sleep == 0)
+	{
+		goto out;
+	}
+	if (sleep == 1){
+		if (ieee->sta_sleep == LPS_IS_SLEEP){
+			ieee->enter_sleep_state(ieee->dev,th,tl);
+		}
+
+		else if (ieee->sta_sleep == LPS_IS_WAKE){
+			spin_lock_irqsave(&ieee->mgmt_tx_lock, flags2);
+
+			if (ieee->ps_is_queue_empty(ieee->dev)){
+				ieee->sta_sleep = LPS_WAIT_NULL_DATA_SEND;
+				ieee->ack_tx_to_ieee = 1;
+				rtllib_sta_ps_send_null_frame(ieee,1);
+				ieee->ps_th = th;
+				ieee->ps_tl = tl;
+			}
+			spin_unlock_irqrestore(&ieee->mgmt_tx_lock, flags2);
+
+		}
+
+		ieee->bAwakePktSent = false;
+
+	}else if (sleep == 2){
+		spin_lock_irqsave(&ieee->mgmt_tx_lock, flags2);
+
+		rtllib_sta_wakeup(ieee,1);
+
+		spin_unlock_irqrestore(&ieee->mgmt_tx_lock, flags2);
+	}
+
+out:
+	spin_unlock_irqrestore(&ieee->lock, flags);
+
+}
+
+void rtllib_sta_wakeup(struct rtllib_device *ieee, short nl)
+{
+	if (ieee->sta_sleep == LPS_IS_WAKE){
+		if (nl){
+			if (ieee->pHTInfo->IOTAction & HT_IOT_ACT_NULL_DATA_POWER_SAVING)
+			{
+				ieee->ack_tx_to_ieee = 1;
+				rtllib_sta_ps_send_null_frame(ieee, 0);
+			}
+			else
+			{
+				ieee->ack_tx_to_ieee = 1;
+				rtllib_sta_ps_send_pspoll_frame(ieee);
+			}
+		}
+		return;
+
+	}
+
+	if (ieee->sta_sleep == LPS_IS_SLEEP)
+		ieee->sta_wake_up(ieee->dev);
+	if (nl){
+		/*
+			ieee->ack_tx_to_ieee = 1;
+			printk("%s(3): notify AP we are awaked ++++++++++ SendNullFunctionData\n", __func__);
+			rtllib_sta_ps_send_null_frame(ieee, 0);
+		*/
+		if (ieee->pHTInfo->IOTAction & HT_IOT_ACT_NULL_DATA_POWER_SAVING)
+		{
+			ieee->ack_tx_to_ieee = 1;
+			rtllib_sta_ps_send_null_frame(ieee, 0);
+		}
+		else
+		{
+			ieee->ack_tx_to_ieee = 1;
+			ieee->polling = true;
+			rtllib_sta_ps_send_pspoll_frame(ieee);
+		}
+
+	} else {
+		ieee->sta_sleep = LPS_IS_WAKE;
+		ieee->polling = false;
+	}
+}
+
+void rtllib_ps_tx_ack(struct rtllib_device *ieee, short success)
+{
+	unsigned long flags,flags2;
+
+	spin_lock_irqsave(&ieee->lock, flags);
+
+	if (ieee->sta_sleep == LPS_WAIT_NULL_DATA_SEND){
+		/* Null frame with PS bit set */
+		if (success){
+			ieee->sta_sleep = LPS_IS_SLEEP;
+			ieee->enter_sleep_state(ieee->dev,ieee->ps_th,ieee->ps_tl);
+		}
+		/* if the card report not success we can't be sure the AP
+		 * has not RXed so we can't assume the AP believe us awake
+		 */
+	} else {/* 21112005 - tx again null without PS bit if lost */
+
+		if ((ieee->sta_sleep == LPS_IS_WAKE) && !success){
+			spin_lock_irqsave(&ieee->mgmt_tx_lock, flags2);
+			if (ieee->pHTInfo->IOTAction & HT_IOT_ACT_NULL_DATA_POWER_SAVING)
+			{
+				rtllib_sta_ps_send_null_frame(ieee, 0);
+			}
+			else
+			{
+				rtllib_sta_ps_send_pspoll_frame(ieee);
+			}
+			spin_unlock_irqrestore(&ieee->mgmt_tx_lock, flags2);
+		}
+	}
+	spin_unlock_irqrestore(&ieee->lock, flags);
+}
+
+void rtllib_process_action(struct rtllib_device* ieee, struct sk_buff* skb)
+{
+	struct rtllib_hdr_3addr *header = (struct rtllib_hdr_3addr *) skb->data;
+	u8* act = rtllib_get_payload((struct rtllib_hdr *)header);
+	u8 category = 0;
+
+	if (act == NULL) {
+		RTLLIB_DEBUG(RTLLIB_DL_ERR, "error to get payload of action frame\n");
+		return;
+	}
+
+	category = *act;
+	act ++;
+	switch (category) {
+		case ACT_CAT_BA:
+			switch (*act) {
+				case ACT_ADDBAREQ:
+					rtllib_rx_ADDBAReq(ieee, skb);
+					break;
+				case ACT_ADDBARSP:
+					rtllib_rx_ADDBARsp(ieee, skb);
+					break;
+				case ACT_DELBA:
+					rtllib_rx_DELBA(ieee, skb);
+					break;
+			}
+			break;
+		default:
+			break;
+	}
+	return;
+}
+
+inline int rtllib_rx_assoc_resp(struct rtllib_device *ieee, struct sk_buff *skb, struct rtllib_rx_stats *rx_stats)
+{
+	u16 errcode;
+	int aid;
+	u8* ies;
+	struct rtllib_assoc_response_frame *assoc_resp;
+	struct rtllib_hdr_3addr *header = (struct rtllib_hdr_3addr *) skb->data;
+
+	RTLLIB_DEBUG_MGMT("received [RE]ASSOCIATION RESPONSE (%d)\n",
+					WLAN_FC_GET_STYPE(header->frame_ctl));
+
+	if ((ieee->softmac_features & IEEE_SOFTMAC_ASSOCIATE) &&
+		ieee->state == RTLLIB_ASSOCIATING_AUTHENTICATED &&
+		(ieee->iw_mode == IW_MODE_INFRA))
+	{
+		if (0 == (errcode=assoc_parse(ieee,skb, &aid))){
+			struct rtllib_network *network = kzalloc(sizeof(struct rtllib_network), GFP_ATOMIC);
+
+			if (!network)
+				return 1;
+			memset(network,0,sizeof(*network));
+			ieee->state=RTLLIB_LINKED;
+			ieee->assoc_id = aid;
+			ieee->softmac_stats.rx_ass_ok++;
+			/* station support qos */
+			/* Let the register setting defaultly with Legacy station */
+			assoc_resp = (struct rtllib_assoc_response_frame*)skb->data;
+			if (ieee->current_network.qos_data.supported == 1) {
+				if (rtllib_parse_info_param(ieee,assoc_resp->info_element,\
+							rx_stats->len - sizeof(*assoc_resp),\
+							network,rx_stats)){
+					kfree(network);
+					return 1;
+				}
+				else
+				{
+					memcpy(ieee->pHTInfo->PeerHTCapBuf, network->bssht.bdHTCapBuf, network->bssht.bdHTCapLen);
+					memcpy(ieee->pHTInfo->PeerHTInfoBuf, network->bssht.bdHTInfoBuf, network->bssht.bdHTInfoLen);
+				}
+				if (ieee->handle_assoc_response != NULL)
+					ieee->handle_assoc_response(ieee->dev, (struct rtllib_assoc_response_frame*)header, network);
+				kfree(network);
+			}
+
+			if (ieee->assocresp_ies){
+				kfree(ieee->assocresp_ies);
+				ieee->assocresp_ies = NULL;
+			}
+			ies = &(assoc_resp->info_element[0].id);
+			ieee->assocresp_ies_len = (skb->data + skb->len) - ies;
+			ieee->assocresp_ies = kmalloc(ieee->assocresp_ies_len, GFP_ATOMIC);
+			if (ieee->assocresp_ies)
+				memcpy(ieee->assocresp_ies, ies, ieee->assocresp_ies_len);
+			else{
+				printk("%s()Warning: can't alloc memory for assocresp_ies\n", __func__);
+				ieee->assocresp_ies_len = 0;
+			}
+			rtllib_associate_complete(ieee);
+		} else {
+			/* aid could not been allocated */
+			ieee->softmac_stats.rx_ass_err++;
+			printk(
+				"Association response status code 0x%x\n",
+				errcode);
+			RTLLIB_DEBUG_MGMT(
+				"Association response status code 0x%x\n",
+				errcode);
+			if (ieee->AsocRetryCount < RT_ASOC_RETRY_LIMIT) {
+				queue_delayed_work_rsl(ieee->wq, &ieee->associate_procedure_wq, 0);
+			} else {
+				rtllib_associate_abort(ieee);
+			}
+		}
+	}
+
+	return 0;
+}
+
+inline int rtllib_rx_auth(struct rtllib_device *ieee, struct sk_buff *skb, struct rtllib_rx_stats *rx_stats)
+{
+	u16 errcode;
+	u8* challenge;
+	int chlen=0;
+	bool bSupportNmode = true, bHalfSupportNmode = false;
+
+	if (ieee->softmac_features & IEEE_SOFTMAC_ASSOCIATE){
+		if (ieee->state == RTLLIB_ASSOCIATING_AUTHENTICATING &&
+		    (ieee->iw_mode == IW_MODE_INFRA)) {
+			RTLLIB_DEBUG_MGMT("Received authentication response");
+
+			if (0 == (errcode=auth_parse(skb, &challenge, &chlen))) {
+				if (ieee->open_wep || !challenge){
+					ieee->state = RTLLIB_ASSOCIATING_AUTHENTICATED;
+					ieee->softmac_stats.rx_auth_rs_ok++;
+					if (!(ieee->pHTInfo->IOTAction&HT_IOT_ACT_PURE_N_MODE))
+					{
+						if (!ieee->GetNmodeSupportBySecCfg(ieee->dev))
+						{
+							if (IsHTHalfNmodeAPs(ieee))
+							{
+								bSupportNmode = true;
+								bHalfSupportNmode = true;
+							}
+							else
+							{
+								bSupportNmode = false;
+								bHalfSupportNmode = false;
+							}
+						}
+					}
+					/* Dummy wirless mode setting to avoid encryption issue */
+					if (bSupportNmode) {
+						ieee->SetWirelessMode(ieee->dev, \
+							ieee->current_network.mode);
+					}else{
+						/*TODO*/
+						ieee->SetWirelessMode(ieee->dev, IEEE_G);
+					}
+
+					if (ieee->current_network.mode == IEEE_N_24G && bHalfSupportNmode == true)
+					{
+						printk("===============>entern half N mode\n");
+						ieee->bHalfWirelessN24GMode = true;
+					}
+					else
+						ieee->bHalfWirelessN24GMode = false;
+
+					rtllib_associate_step2(ieee);
+				}else{
+					rtllib_auth_challenge(ieee, challenge, chlen);
+				}
+			}else{
+				ieee->softmac_stats.rx_auth_rs_err++;
+				RTLLIB_DEBUG_MGMT("Authentication respose status code 0x%x",errcode);
+
+				printk("Authentication respose status code 0x%x",errcode);
+				rtllib_associate_abort(ieee);
+			}
+
+		}else if (ieee->iw_mode == IW_MODE_MASTER){
+			rtllib_rx_auth_rq(ieee, skb);
+		}
+	}
+
+	return 0;
+}
+
+inline int rtllib_rx_deauth(struct rtllib_device *ieee, struct sk_buff *skb)
+{
+	struct rtllib_hdr_3addr *header = (struct rtllib_hdr_3addr *) skb->data;
+
+	if (memcmp(header->addr3, ieee->current_network.bssid, ETH_ALEN) != 0)
+		return 0;
+
+	/* FIXME for now repeat all the association procedure
+	* both for disassociation and deauthentication
+	*/
+	if ((ieee->softmac_features & IEEE_SOFTMAC_ASSOCIATE) &&
+	    ieee->state == RTLLIB_LINKED &&
+	    (ieee->iw_mode == IW_MODE_INFRA)) {
+		printk(KERN_INFO "==========>received disassoc/deauth(%x) "
+		       "frame, reason code:%x\n",
+		       WLAN_FC_GET_STYPE(header->frame_ctl),
+		       ((struct rtllib_disassoc*)skb->data)->reason);
+		ieee->state = RTLLIB_ASSOCIATING;
+		ieee->softmac_stats.reassoc++;
+		ieee->is_roaming = true;
+		ieee->LinkDetectInfo.bBusyTraffic = false;
+		rtllib_disassociate(ieee);
+		RemovePeerTS(ieee, header->addr2);
+		if (ieee->LedControlHandler != NULL)
+		        ieee->LedControlHandler(ieee->dev, LED_CTL_START_TO_LINK);
+
+		if (!(ieee->rtllib_ap_sec_type(ieee)&(SEC_ALG_CCMP|SEC_ALG_TKIP)))
+		queue_delayed_work_rsl(ieee->wq, &ieee->associate_procedure_wq, 5);
+	}
+
+	return 0;
+}
+
+inline int rtllib_rx_frame_softmac(struct rtllib_device *ieee, struct sk_buff *skb,
+			struct rtllib_rx_stats *rx_stats, u16 type,
+			u16 stype)
+{
+	struct rtllib_hdr_3addr *header = (struct rtllib_hdr_3addr *) skb->data;
+
+	if (!ieee->proto_started)
+		return 0;
+
+	switch (WLAN_FC_GET_STYPE(header->frame_ctl)) {
+
+		case RTLLIB_STYPE_ASSOC_RESP:
+		case RTLLIB_STYPE_REASSOC_RESP:
+
+			if (rtllib_rx_assoc_resp(ieee, skb, rx_stats) == 1)
+				return 1;
+
+			break;
+
+		case RTLLIB_STYPE_ASSOC_REQ:
+		case RTLLIB_STYPE_REASSOC_REQ:
+
+			if ((ieee->softmac_features & IEEE_SOFTMAC_ASSOCIATE) &&
+				ieee->iw_mode == IW_MODE_MASTER)
+
+				rtllib_rx_assoc_rq(ieee, skb);
+			break;
+
+		case RTLLIB_STYPE_AUTH:
+
+			rtllib_rx_auth(ieee, skb, rx_stats);
+
+			break;
+		case RTLLIB_STYPE_DISASSOC:
+		case RTLLIB_STYPE_DEAUTH:
+
+			rtllib_rx_deauth(ieee, skb);
+
+			break;
+
+		case RTLLIB_STYPE_MANAGE_ACT:
+			rtllib_process_action(ieee,skb);
+			break;
+#ifdef COMPATIBLE_WITH_RALINK_MESH
+		case RTLLIB_STYPE_MESH_ACT:
+			rtllib_process_action_mesh(ieee,skb,rx_stats);
+			break;
+#endif
+		default:
+			return -1;
+			break;
+	}
+
+	return 0;
+}
+
+/* following are for a simplier TX queue management.
+ * Instead of using netif_[stop/wake]_queue the driver
+ * will uses these two function (plus a reset one), that
+ * will internally uses the kernel netif_* and takes
+ * care of the ieee802.11 fragmentation.
+ * So the driver receives a fragment per time and might
+ * call the stop function when it want without take care
+ * to have enought room to TX an entire packet.
+ * This might be useful if each fragment need it's own
+ * descriptor, thus just keep a total free memory > than
+ * the max fragmentation treshold is not enought.. If the
+ * ieee802.11 stack passed a TXB struct then you needed
+ * to keep N free descriptors where
+ * N = MAX_PACKET_SIZE / MIN_FRAG_TRESHOLD
+ * In this way you need just one and the 802.11 stack
+ * will take care of buffering fragments and pass them to
+ * to the driver later, when it wakes the queue.
+ */
+void rtllib_softmac_xmit(struct rtllib_txb *txb, struct rtllib_device *ieee)
+{
+
+	unsigned int queue_index = txb->queue_index;
+	unsigned long flags;
+	int  i;
+	cb_desc *tcb_desc = NULL;
+	unsigned long queue_len = 0;
+
+	spin_lock_irqsave(&ieee->lock,flags);
+
+	/* called with 2nd parm 0, no tx mgmt lock required */
+	rtllib_sta_wakeup(ieee,0);
+
+	/* update the tx status */
+	tcb_desc = (cb_desc *)(txb->fragments[0]->cb + MAX_DEV_ADDR_SIZE);
+	if (tcb_desc->bMulticast) {
+		ieee->stats.multicast++;
+	}
+#if 1
+	/* if xmit available, just xmit it immediately, else just insert it to the wait queue */
+	for (i = 0; i < txb->nr_frags; i++) {
+#ifdef USB_TX_DRIVER_AGGREGATION_ENABLE
+		queue_len = skb_queue_len(&ieee->skb_drv_aggQ[queue_index]);
+#else
+		queue_len = skb_queue_len(&ieee->skb_waitQ[queue_index]);
+#endif
+		if ((queue_len  != 0) ||\
+			(!ieee->check_nic_enough_desc(ieee->dev,queue_index))||\
+		       (ieee->queue_stop)) {
+			/* insert the skb packet to the wait queue */
+			/* as for the completion function, it does not need
+			 * to check it any more.
+			 * */
+#ifdef WIFI_TEST
+			if (1)
+#else
+			if (queue_len < 200)
+#endif
+			{
+#ifdef USB_TX_DRIVER_AGGREGATION_ENABLE
+				skb_queue_tail(&ieee->skb_drv_aggQ[queue_index], txb->fragments[i]);
+#else
+				skb_queue_tail(&ieee->skb_waitQ[queue_index], txb->fragments[i]);
+#endif
+			}else{
+				kfree_skb(txb->fragments[i]);
+			}
+		}else{
+			ieee->softmac_data_hard_start_xmit(
+					txb->fragments[i],
+					ieee->dev,ieee->rate);
+		}
+	}
+#endif
+	rtllib_txb_free(txb);
+
+	spin_unlock_irqrestore(&ieee->lock,flags);
+
+}
+
+/* called with ieee->lock acquired */
+void rtllib_resume_tx(struct rtllib_device *ieee)
+{
+	int i;
+	for (i = ieee->tx_pending.frag; i < ieee->tx_pending.txb->nr_frags; i++) {
+
+		if (ieee->queue_stop){
+			ieee->tx_pending.frag = i;
+			return;
+		}else{
+
+			ieee->softmac_data_hard_start_xmit(
+				ieee->tx_pending.txb->fragments[i],
+				ieee->dev,ieee->rate);
+			ieee->stats.tx_packets++;
+		}
+	}
+
+	rtllib_txb_free(ieee->tx_pending.txb);
+	ieee->tx_pending.txb = NULL;
+}
+
+
+void rtllib_reset_queue(struct rtllib_device *ieee)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&ieee->lock,flags);
+	init_mgmt_queue(ieee);
+	if (ieee->tx_pending.txb){
+		rtllib_txb_free(ieee->tx_pending.txb);
+		ieee->tx_pending.txb = NULL;
+	}
+	ieee->queue_stop = 0;
+	spin_unlock_irqrestore(&ieee->lock,flags);
+
+}
+
+void rtllib_wake_queue(struct rtllib_device *ieee)
+{
+
+	unsigned long flags;
+	struct sk_buff *skb;
+	struct rtllib_hdr_3addr  *header;
+
+	spin_lock_irqsave(&ieee->lock,flags);
+	if (! ieee->queue_stop) goto exit;
+
+	ieee->queue_stop = 0;
+
+	if (ieee->softmac_features & IEEE_SOFTMAC_SINGLE_QUEUE){
+		while (!ieee->queue_stop && (skb = dequeue_mgmt(ieee))){
+
+			header = (struct rtllib_hdr_3addr  *) skb->data;
+
+			header->seq_ctl = cpu_to_le16(ieee->seq_ctrl[0] << 4);
+
+			if (ieee->seq_ctrl[0] == 0xFFF)
+				ieee->seq_ctrl[0] = 0;
+			else
+				ieee->seq_ctrl[0]++;
+
+			ieee->softmac_data_hard_start_xmit(skb,ieee->dev,ieee->basic_rate);
+		}
+	}
+	if (!ieee->queue_stop && ieee->tx_pending.txb)
+		rtllib_resume_tx(ieee);
+
+	if (!ieee->queue_stop && netif_queue_stopped(ieee->dev)){
+		ieee->softmac_stats.swtxawake++;
+		netif_wake_queue(ieee->dev);
+	}
+
+exit :
+	spin_unlock_irqrestore(&ieee->lock,flags);
+}
+
+
+void rtllib_stop_queue(struct rtllib_device *ieee)
+{
+
+	if (! netif_queue_stopped(ieee->dev)){
+		netif_stop_queue(ieee->dev);
+		ieee->softmac_stats.swtxstop++;
+	}
+	ieee->queue_stop = 1;
+
+}
+
+void rtllib_stop_all_queues(struct rtllib_device *ieee)
+{
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,30)
+	unsigned int i;
+	for (i=0; i < ieee->dev->num_tx_queues; i++)
+                netdev_get_tx_queue(ieee->dev,i)->trans_start = jiffies;
+#else
+	ieee->dev->trans_start = jiffies;
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,27)
+	netif_carrier_off(ieee->dev);
+#else
+	netif_tx_stop_all_queues(ieee->dev);
+#endif
+}
+
+void rtllib_wake_all_queues(struct rtllib_device *ieee)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,27)
+	netif_carrier_on(ieee->dev);
+#else
+	netif_tx_wake_all_queues(ieee->dev);
+#endif
+}
+
+inline void rtllib_randomize_cell(struct rtllib_device *ieee)
+{
+
+	get_random_bytes(ieee->current_network.bssid, ETH_ALEN);
+
+	/* an IBSS cell address must have the two less significant
+	 * bits of the first byte = 2
+	 */
+	ieee->current_network.bssid[0] &= ~0x01;
+	ieee->current_network.bssid[0] |= 0x02;
+}
+
+/* called in user context only */
+void rtllib_start_master_bss(struct rtllib_device *ieee)
+{
+	ieee->assoc_id = 1;
+
+	if (ieee->current_network.ssid_len == 0){
+		strncpy(ieee->current_network.ssid,
+			RTLLIB_DEFAULT_TX_ESSID,
+			IW_ESSID_MAX_SIZE);
+
+		ieee->current_network.ssid_len = strlen(RTLLIB_DEFAULT_TX_ESSID);
+		ieee->ssid_set = 1;
+	}
+
+	memcpy(ieee->current_network.bssid, ieee->dev->dev_addr, ETH_ALEN);
+
+	ieee->set_chan(ieee->dev, ieee->current_network.channel);
+	ieee->state = RTLLIB_LINKED;
+	ieee->link_change(ieee->dev);
+	notify_wx_assoc_event(ieee);
+
+	if (ieee->data_hard_resume)
+		ieee->data_hard_resume(ieee->dev);
+
+	netif_carrier_on(ieee->dev);
+}
+
+void rtllib_start_monitor_mode(struct rtllib_device *ieee)
+{
+	/* reset hardware status */
+	if (ieee->raw_tx){
+		if (ieee->data_hard_resume)
+			ieee->data_hard_resume(ieee->dev);
+
+		netif_carrier_on(ieee->dev);
+	}
+}
+
+void rtllib_start_ibss_wq(void *data)
+{
+	struct rtllib_device *ieee = container_of_dwork_rsl(data, struct rtllib_device, start_ibss_wq);
+	/* iwconfig mode ad-hoc will schedule this and return
+	 * on the other hand this will block further iwconfig SET
+	 * operations because of the wx_sem hold.
+	 * Anyway some most set operations set a flag to speed-up
+	 * (abort) this wq (when syncro scanning) before sleeping
+	 * on the semaphore
+	 */
+	if (!ieee->proto_started){
+		printk("==========oh driver down return\n");
+		return;
+	}
+	down(&ieee->wx_sem);
+
+	if (ieee->current_network.ssid_len == 0){
+		strcpy(ieee->current_network.ssid,RTLLIB_DEFAULT_TX_ESSID);
+		ieee->current_network.ssid_len = strlen(RTLLIB_DEFAULT_TX_ESSID);
+		ieee->ssid_set = 1;
+	}
+
+	ieee->state = RTLLIB_NOLINK;
+#ifdef ADHOC_11N
+	ieee->mode = IEEE_N_24G;
+#else
+	ieee->mode = IEEE_G;
+#endif
+	/* check if we have this cell in our network list */
+	rtllib_softmac_check_all_nets(ieee);
+
+
+	/* if not then the state is not linked. Maybe the user swithced to
+	 * ad-hoc mode just after being in monitor mode, or just after
+	 * being very few time in managed mode (so the card have had no
+	 * time to scan all the chans..) or we have just run up the iface
+	 * after setting ad-hoc mode. So we have to give another try..
+	 * Here, in ibss mode, should be safe to do this without extra care
+	 * (in bss mode we had to make sure no-one tryed to associate when
+	 * we had just checked the ieee->state and we was going to start the
+	 * scan) beacause in ibss mode the rtllib_new_net function, when
+	 * finds a good net, just set the ieee->state to RTLLIB_LINKED,
+	 * so, at worst, we waste a bit of time to initiate an unneeded syncro
+	 * scan, that will stop at the first round because it sees the state
+	 * associated.
+	 */
+	if (ieee->state == RTLLIB_NOLINK)
+		rtllib_start_scan_syncro(ieee, 0);
+
+	/* the network definitively is not here.. create a new cell */
+	if (ieee->state == RTLLIB_NOLINK){
+		printk("creating new IBSS cell\n");
+		ieee->current_network.channel = ieee->IbssStartChnl;
+		if (!ieee->wap_set)
+			rtllib_randomize_cell(ieee);
+
+		if (ieee->modulation & RTLLIB_CCK_MODULATION){
+
+			ieee->current_network.rates_len = 4;
+
+			ieee->current_network.rates[0] = RTLLIB_BASIC_RATE_MASK | RTLLIB_CCK_RATE_1MB;
+			ieee->current_network.rates[1] = RTLLIB_BASIC_RATE_MASK | RTLLIB_CCK_RATE_2MB;
+			ieee->current_network.rates[2] = RTLLIB_BASIC_RATE_MASK | RTLLIB_CCK_RATE_5MB;
+			ieee->current_network.rates[3] = RTLLIB_BASIC_RATE_MASK | RTLLIB_CCK_RATE_11MB;
+
+		}else
+			ieee->current_network.rates_len = 0;
+
+		if (ieee->modulation & RTLLIB_OFDM_MODULATION){
+			ieee->current_network.rates_ex_len = 8;
+
+			/*ieee->current_network.rates_ex[0] = RTLLIB_BASIC_RATE_MASK | RTLLIB_OFDM_RATE_6MB;
+			ieee->current_network.rates_ex[1] = RTLLIB_BASIC_RATE_MASK | RTLLIB_OFDM_RATE_9MB;
+			ieee->current_network.rates_ex[2] = RTLLIB_BASIC_RATE_MASK | RTLLIB_OFDM_RATE_12MB;
+			ieee->current_network.rates_ex[3] = RTLLIB_BASIC_RATE_MASK | RTLLIB_OFDM_RATE_18MB;
+			ieee->current_network.rates_ex[4] = RTLLIB_BASIC_RATE_MASK | RTLLIB_OFDM_RATE_24MB;
+			ieee->current_network.rates_ex[5] = RTLLIB_BASIC_RATE_MASK | RTLLIB_OFDM_RATE_36MB;
+			ieee->current_network.rates_ex[6] = RTLLIB_BASIC_RATE_MASK | RTLLIB_OFDM_RATE_48MB;
+			ieee->current_network.rates_ex[7] = RTLLIB_BASIC_RATE_MASK | RTLLIB_OFDM_RATE_54MB;*/
+
+			ieee->current_network.rates_ex[0] = RTLLIB_OFDM_RATE_6MB;
+			ieee->current_network.rates_ex[1] = RTLLIB_OFDM_RATE_9MB;
+			ieee->current_network.rates_ex[2] = RTLLIB_OFDM_RATE_12MB;
+			ieee->current_network.rates_ex[3] = RTLLIB_OFDM_RATE_18MB;
+			ieee->current_network.rates_ex[4] = RTLLIB_OFDM_RATE_24MB;
+			ieee->current_network.rates_ex[5] = RTLLIB_OFDM_RATE_36MB;
+			ieee->current_network.rates_ex[6] = RTLLIB_OFDM_RATE_48MB;
+			ieee->current_network.rates_ex[7] = RTLLIB_OFDM_RATE_54MB;
+
+			ieee->rate = 108;
+		}else{
+			ieee->current_network.rates_ex_len = 0;
+			ieee->rate = 22;
+		}
+
+#if defined(RTL8192U) || defined(RTL8192SU) || defined(RTL8192SE)
+#ifdef ADHOC_11N
+		ieee->current_network.qos_data.supported = 1;
+#else
+		ieee->current_network.qos_data.supported = 0;
+#endif
+		ieee->SetWirelessMode(ieee->dev, ieee->mode);
+#else
+		ieee->current_network.qos_data.supported = 0;
+		ieee->SetWirelessMode(ieee->dev, IEEE_G);
+#endif
+		ieee->current_network.mode = ieee->mode;
+		ieee->current_network.atim_window = 0;
+		ieee->current_network.capability = WLAN_CAPABILITY_IBSS;
+	}
+
+	printk("%s(): ieee->mode = %d\n", __func__, ieee->mode);
+	if ((ieee->mode == IEEE_N_24G) || (ieee->mode == IEEE_N_5G))
+		HTUseDefaultSetting(ieee);
+	else
+		ieee->pHTInfo->bCurrentHTSupport = false;
+
+	ieee->SetHwRegHandler(ieee->dev, HW_VAR_MEDIA_STATUS, (u8 *)(&ieee->state));
+
+	ieee->state = RTLLIB_LINKED;
+	ieee->link_change(ieee->dev);
+
+	HTSetConnectBwMode(ieee, HT_CHANNEL_WIDTH_20, HT_EXTCHNL_OFFSET_NO_EXT);
+	if (ieee->LedControlHandler != NULL)
+	        ieee->LedControlHandler(ieee->dev,LED_CTL_LINK);
+
+	rtllib_start_send_beacons(ieee);
+
+	notify_wx_assoc_event(ieee);
+
+	if (ieee->data_hard_resume)
+		ieee->data_hard_resume(ieee->dev);
+
+	netif_carrier_on(ieee->dev);
+
+	up(&ieee->wx_sem);
+}
+
+inline void rtllib_start_ibss(struct rtllib_device *ieee)
+{
+	queue_delayed_work_rsl(ieee->wq, &ieee->start_ibss_wq, MSECS(150));
+}
+
+/* this is called only in user context, with wx_sem held */
+void rtllib_start_bss(struct rtllib_device *ieee)
+{
+	unsigned long flags;
+#ifdef ENABLE_DOT11D
+	if (IS_DOT11D_ENABLE(ieee) && !IS_COUNTRY_IE_VALID(ieee))
+	{
+		if (! ieee->bGlobalDomain)
+		{
+			return;
+		}
+	}
+#endif
+	/* check if we have already found the net we
+	 * are interested in (if any).
+	 * if not (we are disassociated and we are not
+	 * in associating / authenticating phase) start the background scanning.
+	 */
+	rtllib_softmac_check_all_nets(ieee);
+
+	/* ensure no-one start an associating process (thus setting
+	 * the ieee->state to rtllib_ASSOCIATING) while we
+	 * have just cheked it and we are going to enable scan.
+	 * The rtllib_new_net function is always called with
+	 * lock held (from both rtllib_softmac_check_all_nets and
+	 * the rx path), so we cannot be in the middle of such function
+	 */
+	spin_lock_irqsave(&ieee->lock, flags);
+
+	if (ieee->state == RTLLIB_NOLINK) {
+		rtllib_start_scan(ieee);
+	}
+	spin_unlock_irqrestore(&ieee->lock, flags);
+}
+
+void rtllib_link_change_wq(void *data)
+{
+	struct rtllib_device *ieee = container_of_dwork_rsl(data, struct rtllib_device, link_change_wq);
+	ieee->link_change(ieee->dev);
+}
+/* called only in userspace context */
+void rtllib_disassociate(struct rtllib_device *ieee)
+{
+	netif_carrier_off(ieee->dev);
+	if (ieee->softmac_features & IEEE_SOFTMAC_TX_QUEUE)
+			rtllib_reset_queue(ieee);
+
+	if (ieee->data_hard_stop)
+			ieee->data_hard_stop(ieee->dev);
+#ifdef ENABLE_DOT11D
+	if (IS_DOT11D_ENABLE(ieee))
+		Dot11d_Reset(ieee);
+#endif
+	ieee->state = RTLLIB_NOLINK;
+	ieee->is_set_key = false;
+	ieee->wap_set = 0;
+
+	queue_delayed_work_rsl(ieee->wq, &ieee->link_change_wq, 0);
+
+
+#ifndef FOR_ANDROID_X86
+	notify_wx_assoc_event(ieee);
+#endif
+}
+
+void rtllib_associate_retry_wq(void *data)
+{
+	struct rtllib_device *ieee = container_of_dwork_rsl(data, struct rtllib_device, associate_retry_wq);
+	unsigned long flags;
+
+	down(&ieee->wx_sem);
+	if (!ieee->proto_started)
+		goto exit;
+
+	if (ieee->state != RTLLIB_ASSOCIATING_RETRY)
+		goto exit;
+
+	/* until we do not set the state to RTLLIB_NOLINK
+	* there are no possibility to have someone else trying
+	* to start an association procdure (we get here with
+	* ieee->state = RTLLIB_ASSOCIATING).
+	* When we set the state to RTLLIB_NOLINK it is possible
+	* that the RX path run an attempt to associate, but
+	* both rtllib_softmac_check_all_nets and the
+	* RX path works with ieee->lock held so there are no
+	* problems. If we are still disassociated then start a scan.
+	* the lock here is necessary to ensure no one try to start
+	* an association procedure when we have just checked the
+	* state and we are going to start the scan.
+	*/
+	ieee->beinretry = true;
+	ieee->state = RTLLIB_NOLINK;
+
+	rtllib_softmac_check_all_nets(ieee);
+
+	spin_lock_irqsave(&ieee->lock, flags);
+
+	if (ieee->state == RTLLIB_NOLINK)
+	{
+		rtllib_start_scan(ieee);
+	}
+	spin_unlock_irqrestore(&ieee->lock, flags);
+
+	ieee->beinretry = false;
+exit:
+	up(&ieee->wx_sem);
+}
+
+struct sk_buff *rtllib_get_beacon_(struct rtllib_device *ieee)
+{
+	u8 broadcast_addr[] = {0xff,0xff,0xff,0xff,0xff,0xff};
+
+	struct sk_buff *skb;
+	struct rtllib_probe_response *b;
+	skb = rtllib_probe_resp(ieee, broadcast_addr);
+
+	if (!skb)
+		return NULL;
+
+	b = (struct rtllib_probe_response *) skb->data;
+	b->header.frame_ctl = cpu_to_le16(RTLLIB_STYPE_BEACON);
+
+	return skb;
+
+}
+
+struct sk_buff *rtllib_get_beacon(struct rtllib_device *ieee)
+{
+	struct sk_buff *skb;
+	struct rtllib_probe_response *b;
+
+	skb = rtllib_get_beacon_(ieee);
+	if (!skb)
+		return NULL;
+
+	b = (struct rtllib_probe_response *) skb->data;
+	b->header.seq_ctl = cpu_to_le16(ieee->seq_ctrl[0] << 4);
+
+	if (ieee->seq_ctrl[0] == 0xFFF)
+		ieee->seq_ctrl[0] = 0;
+	else
+		ieee->seq_ctrl[0]++;
+
+	return skb;
+}
+
+void rtllib_softmac_stop_protocol(struct rtllib_device *ieee, u8 mesh_flag, u8 shutdown)
+{
+	rtllib_stop_scan_syncro(ieee);
+	down(&ieee->wx_sem);
+	rtllib_stop_protocol(ieee,shutdown);
+	up(&ieee->wx_sem);
+}
+
+
+void rtllib_stop_protocol(struct rtllib_device *ieee, u8 shutdown)
+{
+	if (!ieee->proto_started)
+		return;
+
+	if (shutdown){
+	ieee->proto_started = 0;
+		ieee->proto_stoppping = 1;
+		if (ieee->rtllib_ips_leave != NULL)
+			ieee->rtllib_ips_leave(ieee->dev);
+	}
+
+	rtllib_stop_send_beacons(ieee);
+	del_timer_sync(&ieee->associate_timer);
+	cancel_delayed_work(&ieee->associate_retry_wq);
+	cancel_delayed_work(&ieee->start_ibss_wq);
+	cancel_delayed_work(&ieee->link_change_wq);
+	rtllib_stop_scan(ieee);
+
+	if (ieee->state <= RTLLIB_ASSOCIATING_AUTHENTICATED)
+		ieee->state = RTLLIB_NOLINK;
+
+	if (ieee->state == RTLLIB_LINKED){
+		if (ieee->iw_mode == IW_MODE_INFRA)
+			SendDisassociation(ieee,1,deauth_lv_ss);
+		rtllib_disassociate(ieee);
+	}
+
+	if (shutdown){
+		RemoveAllTS(ieee);
+		ieee->proto_stoppping = 0;
+	}
+	if (ieee->assocreq_ies) {
+		kfree(ieee->assocreq_ies);
+		ieee->assocreq_ies = NULL;
+		ieee->assocreq_ies_len = 0;
+	}
+	if (ieee->assocresp_ies) {
+		kfree(ieee->assocresp_ies);
+		ieee->assocresp_ies = NULL;
+		ieee->assocresp_ies_len = 0;
+	}
+}
+
+void rtllib_softmac_start_protocol(struct rtllib_device *ieee, u8 mesh_flag)
+{
+	down(&ieee->wx_sem);
+	rtllib_start_protocol(ieee);
+	up(&ieee->wx_sem);
+}
+
+void rtllib_start_protocol(struct rtllib_device *ieee)
+{
+	short ch = 0;
+	int i = 0;
+
+	rtllib_update_active_chan_map(ieee);
+
+	if (ieee->proto_started)
+		return;
+
+	ieee->proto_started = 1;
+
+	if (ieee->current_network.channel == 0) {
+		do {
+			ch++;
+			if (ch > MAX_CHANNEL_NUMBER)
+				return; /* no channel found */
+		} while(!ieee->active_channel_map[ch]);
+		ieee->current_network.channel = ch;
+	}
+
+	if (ieee->current_network.beacon_interval == 0)
+		ieee->current_network.beacon_interval = 100;
+
+	for (i = 0; i < 17; i++) {
+		ieee->last_rxseq_num[i] = -1;
+		ieee->last_rxfrag_num[i] = -1;
+		ieee->last_packet_time[i] = 0;
+	}
+
+	if (ieee->UpdateBeaconInterruptHandler)
+		ieee->UpdateBeaconInterruptHandler(ieee->dev, false);
+
+	ieee->wmm_acm = 0;
+	/* if the user set the MAC of the ad-hoc cell and then
+	 * switch to managed mode, shall we  make sure that association
+	 * attempts does not fail just because the user provide the essid
+	 * and the nic is still checking for the AP MAC ??
+	 */
+	if (ieee->iw_mode == IW_MODE_INFRA) {
+		rtllib_start_bss(ieee);
+	} else if (ieee->iw_mode == IW_MODE_ADHOC) {
+		if (ieee->UpdateBeaconInterruptHandler)
+			ieee->UpdateBeaconInterruptHandler(ieee->dev, true);
+
+		rtllib_start_ibss(ieee);
+
+	} else if (ieee->iw_mode == IW_MODE_MASTER) {
+		rtllib_start_master_bss(ieee);
+	} else if (ieee->iw_mode == IW_MODE_MONITOR) {
+		rtllib_start_monitor_mode(ieee);
+	}
+}
+
+void rtllib_softmac_init(struct rtllib_device *ieee)
+{
+	int i;
+	memset(&ieee->current_network, 0, sizeof(struct rtllib_network));
+
+	ieee->state = RTLLIB_NOLINK;
+	for (i = 0; i < 5; i++) {
+	  ieee->seq_ctrl[i] = 0;
+	}
+#ifdef ENABLE_DOT11D
+	ieee->pDot11dInfo = kmalloc(sizeof(struct rt_dot11d_info), GFP_ATOMIC);
+	if (!ieee->pDot11dInfo)
+		RTLLIB_DEBUG(RTLLIB_DL_ERR, "can't alloc memory for DOT11D\n");
+	memset(ieee->pDot11dInfo, 0, sizeof(struct rt_dot11d_info));
+#endif
+	ieee->LinkDetectInfo.SlotIndex = 0;
+	ieee->LinkDetectInfo.SlotNum = 2;
+	ieee->LinkDetectInfo.NumRecvBcnInPeriod=0;
+        ieee->LinkDetectInfo.NumRecvDataInPeriod=0;
+	ieee->LinkDetectInfo.NumTxOkInPeriod =0;
+	ieee->LinkDetectInfo.NumRxOkInPeriod =0;
+	ieee->LinkDetectInfo.NumRxUnicastOkInPeriod=0;
+	ieee->bIsAggregateFrame = false;
+	ieee->assoc_id = 0;
+	ieee->queue_stop = 0;
+	ieee->scanning_continue = 0;
+	ieee->softmac_features = 0;
+	ieee->wap_set = 0;
+	ieee->ssid_set = 0;
+	ieee->proto_started = 0;
+	ieee->proto_stoppping = 0;
+	ieee->basic_rate = RTLLIB_DEFAULT_BASIC_RATE;
+	ieee->rate = 22;
+	ieee->ps = RTLLIB_PS_DISABLED;
+	ieee->sta_sleep = LPS_IS_WAKE;
+
+	ieee->Regdot11HTOperationalRateSet[0]= 0xff;
+	ieee->Regdot11HTOperationalRateSet[1]= 0xff;
+	ieee->Regdot11HTOperationalRateSet[4]= 0x01;
+
+	ieee->Regdot11TxHTOperationalRateSet[0]= 0xff;
+	ieee->Regdot11TxHTOperationalRateSet[1]= 0xff;
+	ieee->Regdot11TxHTOperationalRateSet[4]= 0x01;
+
+	ieee->FirstIe_InScan = false;
+	ieee->actscanning = false;
+	ieee->beinretry = false;
+	ieee->is_set_key = false;
+	init_mgmt_queue(ieee);
+
+	ieee->sta_edca_param[0] = 0x0000A403;
+	ieee->sta_edca_param[1] = 0x0000A427;
+	ieee->sta_edca_param[2] = 0x005E4342;
+	ieee->sta_edca_param[3] = 0x002F3262;
+	ieee->aggregation = true;
+	ieee->enable_rx_imm_BA = 1;
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,5,40)
+	_setup_timer(&ieee->scan_timer,
+		    rtllib_softmac_scan_cb,
+		    (unsigned long) ieee);
+#endif
+	ieee->tx_pending.txb = NULL;
+
+	_setup_timer(&ieee->associate_timer,
+		    rtllib_associate_abort_cb,
+		    (unsigned long) ieee);
+
+	_setup_timer(&ieee->beacon_timer,
+		    rtllib_send_beacon_cb,
+		    (unsigned long) ieee);
+
+#if defined(RTL8192U) || defined(RTL8192SU) || defined(RTL8192SE)
+	_setup_timer(&ieee->ibss_wait_timer,
+		    rtllib_ibss_wait_timeout,
+		    (unsigned long) ieee);
+#endif
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
+#ifdef PF_SYNCTHREAD
+	ieee->wq = create_workqueue(DRV_NAME,0);
+#else
+	ieee->wq = create_workqueue(DRV_NAME);
+#endif
+#endif
+
+	INIT_DELAYED_WORK_RSL(&ieee->link_change_wq,(void*)rtllib_link_change_wq,ieee);
+	INIT_DELAYED_WORK_RSL(&ieee->start_ibss_wq,(void*)rtllib_start_ibss_wq,ieee);
+	INIT_WORK_RSL(&ieee->associate_complete_wq, (void*)rtllib_associate_complete_wq,ieee);
+	INIT_DELAYED_WORK_RSL(&ieee->associate_procedure_wq, (void*)rtllib_associate_procedure_wq,ieee);
+	INIT_DELAYED_WORK_RSL(&ieee->softmac_scan_wq,(void*)rtllib_softmac_scan_wq,ieee);
+	INIT_DELAYED_WORK_RSL(&ieee->softmac_hint11d_wq,(void*)rtllib_softmac_hint11d_wq,ieee);
+	INIT_DELAYED_WORK_RSL(&ieee->associate_retry_wq, (void*)rtllib_associate_retry_wq,ieee);
+	INIT_WORK_RSL(&ieee->wx_sync_scan_wq,(void*)rtllib_wx_sync_scan_wq,ieee);
+
+	sema_init(&ieee->wx_sem, 1);
+	sema_init(&ieee->scan_sem, 1);
+	sema_init(&ieee->ips_sem,1);
+
+	spin_lock_init(&ieee->mgmt_tx_lock);
+	spin_lock_init(&ieee->beacon_lock);
+
+	tasklet_init(&ieee->ps_task,
+	     (void(*)(unsigned long)) rtllib_sta_ps,
+	     (unsigned long)ieee);
+
+}
+
+void rtllib_softmac_free(struct rtllib_device *ieee)
+{
+	down(&ieee->wx_sem);
+#ifdef ENABLE_DOT11D
+	if (NULL != ieee->pDot11dInfo)
+	{
+		kfree(ieee->pDot11dInfo);
+		ieee->pDot11dInfo = NULL;
+	}
+#endif
+	del_timer_sync(&ieee->associate_timer);
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
+	cancel_delayed_work(&ieee->associate_retry_wq);
+	destroy_workqueue(ieee->wq);
+#endif
+
+	up(&ieee->wx_sem);
+}
+
+/********************************************************
+ * Start of WPA code.                                   *
+ * this is stolen from the ipw2200 driver               *
+ ********************************************************/
+
+
+static int rtllib_wpa_enable(struct rtllib_device *ieee, int value)
+{
+	/* This is called when wpa_supplicant loads and closes the driver
+	 * interface. */
+	printk("%s WPA\n",value ? "enabling" : "disabling");
+	ieee->wpa_enabled = value;
+	memset(ieee->ap_mac_addr, 0, 6);
+	return 0;
+}
+
+
+void rtllib_wpa_assoc_frame(struct rtllib_device *ieee, char *wpa_ie, int wpa_ie_len)
+{
+	/* make sure WPA is enabled */
+	rtllib_wpa_enable(ieee, 1);
+
+	rtllib_disassociate(ieee);
+}
+
+
+static int rtllib_wpa_mlme(struct rtllib_device *ieee, int command, int reason)
+{
+
+	int ret = 0;
+
+	switch (command) {
+	case IEEE_MLME_STA_DEAUTH:
+		break;
+
+	case IEEE_MLME_STA_DISASSOC:
+		rtllib_disassociate(ieee);
+		break;
+
+	default:
+		printk("Unknown MLME request: %d\n", command);
+		ret = -EOPNOTSUPP;
+	}
+
+	return ret;
+}
+
+
+static int rtllib_wpa_set_wpa_ie(struct rtllib_device *ieee,
+			      struct ieee_param *param, int plen)
+{
+	u8 *buf;
+
+	if (param->u.wpa_ie.len > MAX_WPA_IE_LEN ||
+	    (param->u.wpa_ie.len && param->u.wpa_ie.data == NULL))
+		return -EINVAL;
+
+	if (param->u.wpa_ie.len) {
+		buf = kmalloc(param->u.wpa_ie.len, GFP_KERNEL);
+		if (buf == NULL)
+			return -ENOMEM;
+
+		memcpy(buf, param->u.wpa_ie.data, param->u.wpa_ie.len);
+		kfree(ieee->wpa_ie);
+		ieee->wpa_ie = buf;
+		ieee->wpa_ie_len = param->u.wpa_ie.len;
+	} else {
+		kfree(ieee->wpa_ie);
+		ieee->wpa_ie = NULL;
+		ieee->wpa_ie_len = 0;
+	}
+
+	rtllib_wpa_assoc_frame(ieee, ieee->wpa_ie, ieee->wpa_ie_len);
+	return 0;
+}
+
+#define AUTH_ALG_OPEN_SYSTEM			0x1
+#define AUTH_ALG_SHARED_KEY			0x2
+#define AUTH_ALG_LEAP				0x4
+static int rtllib_wpa_set_auth_algs(struct rtllib_device *ieee, int value)
+{
+
+	struct rtllib_security sec = {
+		.flags = SEC_AUTH_MODE,
+	};
+	int ret = 0;
+
+	if (value & AUTH_ALG_SHARED_KEY) {
+		sec.auth_mode = WLAN_AUTH_SHARED_KEY;
+		ieee->open_wep = 0;
+		ieee->auth_mode = 1;
+	} else if (value & AUTH_ALG_OPEN_SYSTEM){
+		sec.auth_mode = WLAN_AUTH_OPEN;
+		ieee->open_wep = 1;
+		ieee->auth_mode = 0;
+	}
+	else if (value & AUTH_ALG_LEAP){
+		sec.auth_mode = WLAN_AUTH_LEAP  >> 6;
+		ieee->open_wep = 1;
+		ieee->auth_mode = 2;
+	}
+
+
+	if (ieee->set_security)
+		ieee->set_security(ieee->dev, &sec);
+
+	return ret;
+}
+
+static int rtllib_wpa_set_param(struct rtllib_device *ieee, u8 name, u32 value)
+{
+	int ret=0;
+	unsigned long flags;
+
+	switch (name) {
+	case IEEE_PARAM_WPA_ENABLED:
+		ret = rtllib_wpa_enable(ieee, value);
+		break;
+
+	case IEEE_PARAM_TKIP_COUNTERMEASURES:
+		ieee->tkip_countermeasures=value;
+		break;
+
+		case IEEE_PARAM_DROP_UNENCRYPTED:
+		{
+		/* HACK:
+		 *
+		 * wpa_supplicant calls set_wpa_enabled when the driver
+		 * is loaded and unloaded, regardless of if WPA is being
+		 * used.  No other calls are made which can be used to
+		 * determine if encryption will be used or not prior to
+		 * association being expected.  If encryption is not being
+		 * used, drop_unencrypted is set to false, else true -- we
+		 * can use this to determine if the CAP_PRIVACY_ON bit should
+		 * be set.
+		 */
+		struct rtllib_security sec = {
+			.flags = SEC_ENABLED,
+			.enabled = value,
+		};
+		ieee->drop_unencrypted = value;
+		/* We only change SEC_LEVEL for open mode. Others
+		 * are set by ipw_wpa_set_encryption.
+		 */
+		if (!value) {
+			sec.flags |= SEC_LEVEL;
+			sec.level = SEC_LEVEL_0;
+		}
+		else {
+			sec.flags |= SEC_LEVEL;
+			sec.level = SEC_LEVEL_1;
+		}
+		if (ieee->set_security)
+			ieee->set_security(ieee->dev, &sec);
+		break;
+	}
+
+	case IEEE_PARAM_PRIVACY_INVOKED:
+		ieee->privacy_invoked=value;
+		break;
+
+	case IEEE_PARAM_AUTH_ALGS:
+		ret = rtllib_wpa_set_auth_algs(ieee, value);
+		break;
+
+	case IEEE_PARAM_IEEE_802_1X:
+		ieee->ieee802_1x=value;
+		break;
+	case IEEE_PARAM_WPAX_SELECT:
+		spin_lock_irqsave(&ieee->wpax_suitlist_lock,flags);
+		spin_unlock_irqrestore(&ieee->wpax_suitlist_lock,flags);
+		break;
+
+	default:
+		printk("Unknown WPA param: %d\n",name);
+		ret = -EOPNOTSUPP;
+	}
+
+	return ret;
+}
+
+/* implementation borrowed from hostap driver */
+static int rtllib_wpa_set_encryption(struct rtllib_device *ieee,
+				  struct ieee_param *param, int param_len, u8 is_mesh)
+{
+	int ret = 0;
+	struct rtllib_crypto_ops *ops;
+	struct rtllib_crypt_data **crypt;
+
+	struct rtllib_security sec = {
+		.flags = 0,
+	};
+
+	param->u.crypt.err = 0;
+	param->u.crypt.alg[IEEE_CRYPT_ALG_NAME_LEN - 1] = '\0';
+
+	if (param_len !=
+	    (int) ((char *) param->u.crypt.key - (char *) param) +
+	    param->u.crypt.key_len) {
+		printk("Len mismatch %d, %d\n", param_len,
+			       param->u.crypt.key_len);
+		return -EINVAL;
+	}
+	if (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&
+	    param->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&
+	    param->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff) {
+		if (param->u.crypt.idx >= WEP_KEYS)
+			return -EINVAL;
+		crypt = &ieee->crypt[param->u.crypt.idx];
+	} else {
+		return -EINVAL;
+	}
+
+	if (strcmp(param->u.crypt.alg, "none") == 0) {
+		if (crypt) {
+			sec.enabled = 0;
+			sec.level = SEC_LEVEL_0;
+			sec.flags |= SEC_ENABLED | SEC_LEVEL;
+			rtllib_crypt_delayed_deinit(ieee, crypt);
+		}
+		goto done;
+	}
+	sec.enabled = 1;
+	sec.flags |= SEC_ENABLED;
+
+	/* IPW HW cannot build TKIP MIC, host decryption still needed. */
+	if (!(ieee->host_encrypt || ieee->host_decrypt) &&
+	    strcmp(param->u.crypt.alg, "TKIP"))
+		goto skip_host_crypt;
+
+	ops = rtllib_get_crypto_ops(param->u.crypt.alg);
+	if (ops == NULL && strcmp(param->u.crypt.alg, "WEP") == 0) {
+		request_module("rtllib_crypt_wep");
+		ops = rtllib_get_crypto_ops(param->u.crypt.alg);
+	} else if (ops == NULL && strcmp(param->u.crypt.alg, "TKIP") == 0) {
+		request_module("rtllib_crypt_tkip");
+		ops = rtllib_get_crypto_ops(param->u.crypt.alg);
+	} else if (ops == NULL && strcmp(param->u.crypt.alg, "CCMP") == 0) {
+		request_module("rtllib_crypt_ccmp");
+		ops = rtllib_get_crypto_ops(param->u.crypt.alg);
+	}
+	if (ops == NULL) {
+		printk("unknown crypto alg '%s'\n", param->u.crypt.alg);
+		param->u.crypt.err = IEEE_CRYPT_ERR_UNKNOWN_ALG;
+		ret = -EINVAL;
+		goto done;
+	}
+	if (*crypt == NULL || (*crypt)->ops != ops) {
+		struct rtllib_crypt_data *new_crypt;
+
+		rtllib_crypt_delayed_deinit(ieee, crypt);
+
+		new_crypt = (struct rtllib_crypt_data *)
+			kmalloc(sizeof(*new_crypt), GFP_KERNEL);
+		if (new_crypt == NULL) {
+			ret = -ENOMEM;
+			goto done;
+		}
+		memset(new_crypt, 0, sizeof(struct rtllib_crypt_data));
+		new_crypt->ops = ops;
+		if (new_crypt->ops)
+			new_crypt->priv =
+				new_crypt->ops->init(param->u.crypt.idx);
+
+		if (new_crypt->priv == NULL) {
+			kfree(new_crypt);
+			param->u.crypt.err = IEEE_CRYPT_ERR_CRYPT_INIT_FAILED;
+			ret = -EINVAL;
+			goto done;
+		}
+
+		*crypt = new_crypt;
+	}
+
+	if (param->u.crypt.key_len > 0 && (*crypt)->ops->set_key &&
+	    (*crypt)->ops->set_key(param->u.crypt.key,
+	    param->u.crypt.key_len, param->u.crypt.seq,
+	    (*crypt)->priv) < 0) {
+		printk("key setting failed\n");
+		param->u.crypt.err = IEEE_CRYPT_ERR_KEY_SET_FAILED;
+		ret = -EINVAL;
+		goto done;
+	}
+
+ skip_host_crypt:
+	if (param->u.crypt.set_tx) {
+		ieee->tx_keyidx = param->u.crypt.idx;
+		sec.active_key = param->u.crypt.idx;
+		sec.flags |= SEC_ACTIVE_KEY;
+	} else
+		sec.flags &= ~SEC_ACTIVE_KEY;
+
+	if (param->u.crypt.alg != NULL) {
+		memcpy(sec.keys[param->u.crypt.idx],
+		       param->u.crypt.key,
+		       param->u.crypt.key_len);
+		sec.key_sizes[param->u.crypt.idx] = param->u.crypt.key_len;
+		sec.flags |= (1 << param->u.crypt.idx);
+
+		if (strcmp(param->u.crypt.alg, "WEP") == 0) {
+			sec.flags |= SEC_LEVEL;
+			sec.level = SEC_LEVEL_1;
+		} else if (strcmp(param->u.crypt.alg, "TKIP") == 0) {
+			sec.flags |= SEC_LEVEL;
+			sec.level = SEC_LEVEL_2;
+		} else if (strcmp(param->u.crypt.alg, "CCMP") == 0) {
+			sec.flags |= SEC_LEVEL;
+			sec.level = SEC_LEVEL_3;
+		}
+	}
+ done:
+	if (ieee->set_security)
+		ieee->set_security(ieee->dev, &sec);
+
+	/* Do not reset port if card is in Managed mode since resetting will
+	 * generate new IEEE 802.11 authentication which may end up in looping
+	 * with IEEE 802.1X.  If your hardware requires a reset after WEP
+	 * configuration (for example... Prism2), implement the reset_port in
+	 * the callbacks structures used to initialize the 802.11 stack. */
+	if (ieee->reset_on_keychange &&
+	    ieee->iw_mode != IW_MODE_INFRA &&
+	    ieee->reset_port &&
+	    ieee->reset_port(ieee->dev)) {
+		printk("reset_port failed\n");
+		param->u.crypt.err = IEEE_CRYPT_ERR_CARD_CONF_FAILED;
+		return -EINVAL;
+	}
+
+	return ret;
+}
+
+inline struct sk_buff *rtllib_disauth_skb( struct rtllib_network *beacon,
+		struct rtllib_device *ieee, u16 asRsn)
+{
+	struct sk_buff *skb;
+	struct rtllib_disauth *disauth;
+#ifdef USB_USE_ALIGNMENT
+        u32 Tmpaddr=0;
+        int alignment=0;
+	int len = sizeof(struct rtllib_disauth) + ieee->tx_headroom + USB_512B_ALIGNMENT_SIZE;
+#else
+	int len = sizeof(struct rtllib_disauth) + ieee->tx_headroom;
+
+#endif
+	skb = dev_alloc_skb(len);
+	if (!skb) {
+		return NULL;
+	}
+
+#ifdef USB_USE_ALIGNMENT
+        Tmpaddr = (u32)skb->data;
+        alignment = Tmpaddr & 0x1ff;
+        skb_reserve(skb,(USB_512B_ALIGNMENT_SIZE - alignment));
+#endif
+	skb_reserve(skb, ieee->tx_headroom);
+
+	disauth = (struct rtllib_disauth *) skb_put(skb,sizeof(struct rtllib_disauth));
+	disauth->header.frame_ctl = cpu_to_le16(RTLLIB_STYPE_DEAUTH);
+	disauth->header.duration_id = 0;
+
+	memcpy(disauth->header.addr1, beacon->bssid, ETH_ALEN);
+	memcpy(disauth->header.addr2, ieee->dev->dev_addr, ETH_ALEN);
+	memcpy(disauth->header.addr3, beacon->bssid, ETH_ALEN);
+
+	disauth->reason = cpu_to_le16(asRsn);
+	return skb;
+}
+
+inline struct sk_buff *rtllib_disassociate_skb( struct rtllib_network *beacon,
+		struct rtllib_device *ieee, u16 asRsn)
+{
+	struct sk_buff *skb;
+	struct rtllib_disassoc *disass;
+#ifdef USB_USE_ALIGNMENT
+        u32 Tmpaddr=0;
+        int alignment=0;
+	int len = sizeof(struct rtllib_disassoc) + ieee->tx_headroom + USB_512B_ALIGNMENT_SIZE;
+#else
+	int len = sizeof(struct rtllib_disassoc) + ieee->tx_headroom;
+#endif
+	skb = dev_alloc_skb(len);
+
+	if (!skb) {
+		return NULL;
+	}
+
+#ifdef USB_USE_ALIGNMENT
+        Tmpaddr = (u32)skb->data;
+        alignment = Tmpaddr & 0x1ff;
+        skb_reserve(skb,(USB_512B_ALIGNMENT_SIZE - alignment));
+#endif
+	skb_reserve(skb, ieee->tx_headroom);
+
+	disass = (struct rtllib_disassoc *) skb_put(skb,sizeof(struct rtllib_disassoc));
+	disass->header.frame_ctl = cpu_to_le16(RTLLIB_STYPE_DISASSOC);
+	disass->header.duration_id = 0;
+
+	memcpy(disass->header.addr1, beacon->bssid, ETH_ALEN);
+	memcpy(disass->header.addr2, ieee->dev->dev_addr, ETH_ALEN);
+	memcpy(disass->header.addr3, beacon->bssid, ETH_ALEN);
+
+	disass->reason = cpu_to_le16(asRsn);
+	return skb;
+}
+
+void SendDisassociation(struct rtllib_device *ieee, bool deauth, u16 asRsn)
+{
+	struct rtllib_network *beacon = &ieee->current_network;
+	struct sk_buff *skb;
+
+	if (deauth) {
+		skb = rtllib_disauth_skb(beacon,ieee,asRsn);
+	} else {
+		skb = rtllib_disassociate_skb(beacon,ieee,asRsn);
+	}
+
+	if (skb){
+		softmac_mgmt_xmit(skb, ieee);
+	}
+}
+
+u8 rtllib_ap_sec_type(struct rtllib_device *ieee)
+{
+	static u8 ccmp_ie[4] = {0x00,0x50,0xf2,0x04};
+	static u8 ccmp_rsn_ie[4] = {0x00, 0x0f, 0xac, 0x04};
+	int wpa_ie_len= ieee->wpa_ie_len;
+	struct rtllib_crypt_data* crypt;
+	int encrypt;
+
+	crypt = ieee->crypt[ieee->tx_keyidx];
+	encrypt = (ieee->current_network.capability & WLAN_CAPABILITY_PRIVACY) ||\
+		  (ieee->host_encrypt && crypt && crypt->ops && \
+		   (0 == strcmp(crypt->ops->name,"WEP")));
+
+	/* simply judge  */
+	if (encrypt && (wpa_ie_len == 0)) {
+		return SEC_ALG_WEP;
+	} else if ((wpa_ie_len != 0)) {
+		if (((ieee->wpa_ie[0] == 0xdd) && (!memcmp(&(ieee->wpa_ie[14]),ccmp_ie,4))) ||
+				((ieee->wpa_ie[0] == 0x30) && (!memcmp(&ieee->wpa_ie[10],ccmp_rsn_ie, 4))))
+			return SEC_ALG_CCMP;
+		else
+			return SEC_ALG_TKIP;
+	} else {
+		return SEC_ALG_NONE;
+	}
+}
+
+int rtllib_wpa_supplicant_ioctl(struct rtllib_device *ieee, struct iw_point *p, u8 is_mesh)
+{
+	struct ieee_param *param;
+	int ret=0;
+
+	down(&ieee->wx_sem);
+
+	if (p->length < sizeof(struct ieee_param) || !p->pointer){
+		ret = -EINVAL;
+		goto out;
+	}
+
+	param = (struct ieee_param *)kmalloc(p->length, GFP_KERNEL);
+	if (param == NULL){
+		ret = -ENOMEM;
+		goto out;
+	}
+	if (copy_from_user(param, p->pointer, p->length)) {
+		kfree(param);
+		ret = -EFAULT;
+		goto out;
+	}
+
+	switch (param->cmd) {
+
+	case IEEE_CMD_SET_WPA_PARAM:
+		ret = rtllib_wpa_set_param(ieee, param->u.wpa_param.name,
+					param->u.wpa_param.value);
+		break;
+
+	case IEEE_CMD_SET_WPA_IE:
+		ret = rtllib_wpa_set_wpa_ie(ieee, param, p->length);
+		break;
+
+	case IEEE_CMD_SET_ENCRYPTION:
+		ret = rtllib_wpa_set_encryption(ieee, param, p->length, 0);
+		break;
+
+	case IEEE_CMD_MLME:
+		ret = rtllib_wpa_mlme(ieee, param->u.mlme.command,
+				   param->u.mlme.reason_code);
+		break;
+
+	default:
+		printk("Unknown WPA supplicant request: %d\n",param->cmd);
+		ret = -EOPNOTSUPP;
+		break;
+	}
+
+	if (ret == 0 && copy_to_user(p->pointer, param, p->length))
+		ret = -EFAULT;
+
+	kfree(param);
+out:
+	up(&ieee->wx_sem);
+
+	return ret;
+}
+
+void
+rtllib_MgntDisconnectIBSS(struct rtllib_device* rtllib)
+{
+	u8	OpMode;
+	u8	i;
+	bool	bFilterOutNonAssociatedBSSID = false;
+
+	rtllib->state = RTLLIB_NOLINK;
+
+	for (i=0;i<6;i++)  rtllib->current_network.bssid[i]= 0x55;
+
+	rtllib->OpMode = RT_OP_MODE_NO_LINK;
+	rtllib->SetHwRegHandler(rtllib->dev, HW_VAR_BSSID, rtllib->current_network.bssid);
+	OpMode = RT_OP_MODE_NO_LINK;
+	rtllib->SetHwRegHandler(rtllib->dev, HW_VAR_MEDIA_STATUS, &OpMode);
+	rtllib_stop_send_beacons(rtllib);
+
+	bFilterOutNonAssociatedBSSID = false;
+	rtllib->SetHwRegHandler(rtllib->dev, HW_VAR_CECHK_BSSID, (u8*)(&bFilterOutNonAssociatedBSSID));
+	notify_wx_assoc_event(rtllib);
+
+}
+
+void
+rtllib_MlmeDisassociateRequest(
+	struct rtllib_device* rtllib,
+	u8*		asSta,
+	u8		asRsn
+	)
+{
+	u8 i;
+	u8	OpMode;
+
+	RemovePeerTS(rtllib, asSta);
+
+
+	if (memcpy(rtllib->current_network.bssid,asSta,6) == 0)
+	{
+		rtllib->state = RTLLIB_NOLINK;
+
+		for (i=0;i<6;i++)  rtllib->current_network.bssid[i] = 0x22;
+		OpMode = RT_OP_MODE_NO_LINK;
+		rtllib->OpMode = RT_OP_MODE_NO_LINK;
+		rtllib->SetHwRegHandler(rtllib->dev, HW_VAR_MEDIA_STATUS, (u8 *)(&OpMode) );
+		rtllib_disassociate(rtllib);
+
+		rtllib->SetHwRegHandler(rtllib->dev, HW_VAR_BSSID, rtllib->current_network.bssid);
+
+	}
+
+}
+
+void
+rtllib_MgntDisconnectAP(
+	struct rtllib_device* rtllib,
+	u8 asRsn
+)
+{
+	bool bFilterOutNonAssociatedBSSID = false;
+
+
+#ifdef TO_DO
+	if (   pMgntInfo->SecurityInfo.AuthMode > RT_802_11AuthModeAutoSwitch ||
+		(pMgntInfo->bAPSuportCCKM && pMgntInfo->bCCX8021xenable) )
+	{
+		SecClearAllKeys(rtllib->dev);
+		RT_TRACE(COMP_SEC, DBG_LOUD,("======>CCKM clear key..."))
+	}
+#endif
+	bFilterOutNonAssociatedBSSID = false;
+	rtllib->SetHwRegHandler(rtllib->dev, HW_VAR_CECHK_BSSID, (u8*)(&bFilterOutNonAssociatedBSSID));
+	rtllib_MlmeDisassociateRequest( rtllib, rtllib->current_network.bssid, asRsn );
+
+	rtllib->state = RTLLIB_NOLINK;
+}
+
+bool
+rtllib_MgntDisconnect(
+	struct rtllib_device* rtllib,
+	u8 asRsn
+)
+{
+	if (rtllib->ps != RTLLIB_PS_DISABLED)
+	{
+#ifndef RTL8190P
+                rtllib->sta_wake_up(rtllib->dev);
+#endif
+	}
+
+#ifdef TO_DO
+	if (pMgntInfo->mActingAsAp)
+	{
+		RT_TRACE(COMP_MLME, DBG_LOUD, ("MgntDisconnect() ===> AP_DisassociateAllStation\n"));
+		AP_DisassociateAllStation(rtllib->dev, unspec_reason);
+		return true;
+	}
+#endif
+
+	if ( rtllib->state == RTLLIB_LINKED )
+	{
+		if ( rtllib->iw_mode == IW_MODE_ADHOC )
+		{
+			rtllib_MgntDisconnectIBSS(rtllib);
+		}
+		if ( rtllib->iw_mode == IW_MODE_INFRA )
+		{
+#ifdef TO_DO_LIST
+			SecClearAllKeys(Adapter);
+#endif
+			rtllib_MgntDisconnectAP(rtllib, asRsn);
+		}
+
+	}
+
+	return true;
+}
+
+void notify_wx_assoc_event(struct rtllib_device *ieee)
+{
+	union iwreq_data wrqu;
+
+	if (ieee->cannot_notify)
+		return;
+
+	wrqu.ap_addr.sa_family = ARPHRD_ETHER;
+	if (ieee->state == RTLLIB_LINKED)
+		memcpy(wrqu.ap_addr.sa_data, ieee->current_network.bssid, ETH_ALEN);
+	else{
+
+		printk("%s(): Tell user space disconnected\n",__func__);
+		memset(wrqu.ap_addr.sa_data, 0, ETH_ALEN);
+	}
+	wireless_send_event(ieee->dev, SIOCGIWAP, &wrqu, NULL);
+}
