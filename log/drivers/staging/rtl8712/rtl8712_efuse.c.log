commit fbcfbf653636a4afe1ac5d477b755c327c2d2a10
Author: Nishka Dasgupta <nishkadg.linux@gmail.com>
Date:   Thu Jun 20 17:22:56 2019 +0530

    staging: rtl8712: rtl8712_efuse.c: Remove leading p from variable names
    
    Remove leading 'p' from the name of the pointer variable padapter.
    Issue found with Coccinelle.
    
    Signed-off-by: Nishka Dasgupta <nishkadg.linux@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8712/rtl8712_efuse.c b/drivers/staging/rtl8712/rtl8712_efuse.c
index 00babd011a62..4f3b54a7c3be 100644
--- a/drivers/staging/rtl8712/rtl8712_efuse.c
+++ b/drivers/staging/rtl8712/rtl8712_efuse.c
@@ -23,7 +23,7 @@
 /* reserve 3 bytes for HW stop read */
 static int efuse_available_max_size = EFUSE_MAX_SIZE - 3 /*0x1FD*/;
 
-static void efuse_reg_ctrl(struct _adapter *padapter, u8 bPowerOn)
+static void efuse_reg_ctrl(struct _adapter *adapter, u8 bPowerOn)
 {
 	u8 tmpu8 = 0;
 
@@ -31,53 +31,53 @@ static void efuse_reg_ctrl(struct _adapter *padapter, u8 bPowerOn)
 		/* -----------------e-fuse pwr & clk reg ctrl ---------------
 		 * Enable LDOE25 Macro Block
 		 */
-		tmpu8 = r8712_read8(padapter, EFUSE_TEST + 3);
+		tmpu8 = r8712_read8(adapter, EFUSE_TEST + 3);
 		tmpu8 |= 0x80;
-		r8712_write8(padapter, EFUSE_TEST + 3, tmpu8);
+		r8712_write8(adapter, EFUSE_TEST + 3, tmpu8);
 		msleep(20); /* for some platform , need some delay time */
 		/* Change Efuse Clock for write action to 40MHZ */
-		r8712_write8(padapter, EFUSE_CLK_CTRL, 0x03);
+		r8712_write8(adapter, EFUSE_CLK_CTRL, 0x03);
 		msleep(20); /* for some platform , need some delay time */
 	} else {
 		/* -----------------e-fuse pwr & clk reg ctrl -----------------
 		 * Disable LDOE25 Macro Block
 		 */
-		tmpu8 = r8712_read8(padapter, EFUSE_TEST + 3);
+		tmpu8 = r8712_read8(adapter, EFUSE_TEST + 3);
 		tmpu8 &= 0x7F;
-		r8712_write8(padapter, EFUSE_TEST + 3, tmpu8);
+		r8712_write8(adapter, EFUSE_TEST + 3, tmpu8);
 		/* Change Efuse Clock for write action to 500K */
-		r8712_write8(padapter, EFUSE_CLK_CTRL, 0x02);
+		r8712_write8(adapter, EFUSE_CLK_CTRL, 0x02);
 	}
 }
 
 /*
  * Before write E-Fuse, this function must be called.
  */
-u8 r8712_efuse_reg_init(struct _adapter *padapter)
+u8 r8712_efuse_reg_init(struct _adapter *adapter)
 {
 	return true;
 }
 
-void r8712_efuse_reg_uninit(struct _adapter *padapter)
+void r8712_efuse_reg_uninit(struct _adapter *adapter)
 {
-	efuse_reg_ctrl(padapter, false);
+	efuse_reg_ctrl(adapter, false);
 }
 
-static u8 efuse_one_byte_read(struct _adapter *padapter, u16 addr, u8 *data)
+static u8 efuse_one_byte_read(struct _adapter *adapter, u16 addr, u8 *data)
 {
 	u8 tmpidx = 0, bResult;
 
 	/* -----------------e-fuse reg ctrl --------------------------------- */
-	r8712_write8(padapter, EFUSE_CTRL + 1, (u8)(addr & 0xFF)); /* address */
-	r8712_write8(padapter, EFUSE_CTRL + 2, ((u8)((addr >> 8) & 0x03)) |
-	       (r8712_read8(padapter, EFUSE_CTRL + 2) & 0xFC));
-	r8712_write8(padapter, EFUSE_CTRL + 3, 0x72); /* read cmd */
+	r8712_write8(adapter, EFUSE_CTRL + 1, (u8)(addr & 0xFF)); /* address */
+	r8712_write8(adapter, EFUSE_CTRL + 2, ((u8)((addr >> 8) & 0x03)) |
+	       (r8712_read8(adapter, EFUSE_CTRL + 2) & 0xFC));
+	r8712_write8(adapter, EFUSE_CTRL + 3, 0x72); /* read cmd */
 	/* wait for complete */
-	while (!(0x80 & r8712_read8(padapter, EFUSE_CTRL + 3)) &&
+	while (!(0x80 & r8712_read8(adapter, EFUSE_CTRL + 3)) &&
 	       (tmpidx < 100))
 		tmpidx++;
 	if (tmpidx < 100) {
-		*data = r8712_read8(padapter, EFUSE_CTRL);
+		*data = r8712_read8(adapter, EFUSE_CTRL);
 		bResult = true;
 	} else {
 		*data = 0xff;
@@ -86,18 +86,18 @@ static u8 efuse_one_byte_read(struct _adapter *padapter, u16 addr, u8 *data)
 	return bResult;
 }
 
-static u8 efuse_one_byte_write(struct _adapter *padapter, u16 addr, u8 data)
+static u8 efuse_one_byte_write(struct _adapter *adapter, u16 addr, u8 data)
 {
 	u8 tmpidx = 0, bResult;
 
 	/* -----------------e-fuse reg ctrl -------------------------------- */
-	r8712_write8(padapter, EFUSE_CTRL + 1, (u8)(addr & 0xFF)); /* address */
-	r8712_write8(padapter, EFUSE_CTRL + 2, ((u8)((addr >> 8) & 0x03)) |
-	       (r8712_read8(padapter, EFUSE_CTRL + 2) & 0xFC));
-	r8712_write8(padapter, EFUSE_CTRL, data); /* data */
-	r8712_write8(padapter, EFUSE_CTRL + 3, 0xF2); /* write cmd */
+	r8712_write8(adapter, EFUSE_CTRL + 1, (u8)(addr & 0xFF)); /* address */
+	r8712_write8(adapter, EFUSE_CTRL + 2, ((u8)((addr >> 8) & 0x03)) |
+	       (r8712_read8(adapter, EFUSE_CTRL + 2) & 0xFC));
+	r8712_write8(adapter, EFUSE_CTRL, data); /* data */
+	r8712_write8(adapter, EFUSE_CTRL + 3, 0xF2); /* write cmd */
 	/* wait for complete */
-	while ((0x80 &  r8712_read8(padapter, EFUSE_CTRL + 3)) &&
+	while ((0x80 &  r8712_read8(adapter, EFUSE_CTRL + 3)) &&
 	       (tmpidx < 100))
 		tmpidx++;
 	if (tmpidx < 100)
@@ -107,32 +107,32 @@ static u8 efuse_one_byte_write(struct _adapter *padapter, u16 addr, u8 data)
 	return bResult;
 }
 
-static u8 efuse_one_byte_rw(struct _adapter *padapter, u8 bRead, u16 addr,
+static u8 efuse_one_byte_rw(struct _adapter *adapter, u8 bRead, u16 addr,
 			    u8 *data)
 {
 	u8 tmpidx = 0, tmpv8 = 0, bResult;
 
 	/* -----------------e-fuse reg ctrl --------------------------------- */
-	r8712_write8(padapter, EFUSE_CTRL + 1, (u8)(addr & 0xFF)); /* address */
+	r8712_write8(adapter, EFUSE_CTRL + 1, (u8)(addr & 0xFF)); /* address */
 	tmpv8 = ((u8)((addr >> 8) & 0x03)) |
-		 (r8712_read8(padapter, EFUSE_CTRL + 2) & 0xFC);
-	r8712_write8(padapter, EFUSE_CTRL + 2, tmpv8);
+		 (r8712_read8(adapter, EFUSE_CTRL + 2) & 0xFC);
+	r8712_write8(adapter, EFUSE_CTRL + 2, tmpv8);
 	if (bRead) {
-		r8712_write8(padapter, EFUSE_CTRL + 3,  0x72); /* read cmd */
-		while (!(0x80 & r8712_read8(padapter, EFUSE_CTRL + 3)) &&
+		r8712_write8(adapter, EFUSE_CTRL + 3,  0x72); /* read cmd */
+		while (!(0x80 & r8712_read8(adapter, EFUSE_CTRL + 3)) &&
 		       (tmpidx < 100))
 			tmpidx++;
 		if (tmpidx < 100) {
-			*data = r8712_read8(padapter, EFUSE_CTRL);
+			*data = r8712_read8(adapter, EFUSE_CTRL);
 			bResult = true;
 		} else {
 			*data = 0;
 			bResult = false;
 		}
 	} else {
-		r8712_write8(padapter, EFUSE_CTRL, *data); /* data */
-		r8712_write8(padapter, EFUSE_CTRL + 3, 0xF2); /* write cmd */
-		while ((0x80 & r8712_read8(padapter, EFUSE_CTRL + 3)) &&
+		r8712_write8(adapter, EFUSE_CTRL, *data); /* data */
+		r8712_write8(adapter, EFUSE_CTRL + 3, 0xF2); /* write cmd */
+		while ((0x80 & r8712_read8(adapter, EFUSE_CTRL + 3)) &&
 		       (tmpidx < 100))
 			tmpidx++;
 		if (tmpidx < 100)
@@ -143,12 +143,12 @@ static u8 efuse_one_byte_rw(struct _adapter *padapter, u8 bRead, u16 addr,
 	return bResult;
 }
 
-static u8 efuse_is_empty(struct _adapter *padapter, u8 *empty)
+static u8 efuse_is_empty(struct _adapter *adapter, u8 *empty)
 {
 	u8 value, ret = true;
 
 	/* read one byte to check if E-Fuse is empty */
-	if (efuse_one_byte_rw(padapter, true, 0, &value)) {
+	if (efuse_one_byte_rw(adapter, true, 0, &value)) {
 		if (value == 0xFF)
 			*empty = true;
 		else
@@ -159,7 +159,7 @@ static u8 efuse_is_empty(struct _adapter *padapter, u8 *empty)
 	return ret;
 }
 
-void r8712_efuse_change_max_size(struct _adapter *padapter)
+void r8712_efuse_change_max_size(struct _adapter *adapter)
 {
 	u16 pre_pg_data_saddr = 0x1FB;
 	u16 i;
@@ -167,7 +167,7 @@ void r8712_efuse_change_max_size(struct _adapter *padapter)
 	u8 pre_pg_data[5];
 
 	for (i = 0; i < pre_pg_data_size; i++)
-		efuse_one_byte_read(padapter, pre_pg_data_saddr + i,
+		efuse_one_byte_read(adapter, pre_pg_data_saddr + i,
 				    &pre_pg_data[i]);
 	if ((pre_pg_data[0] == 0x03) && (pre_pg_data[1] == 0x00) &&
 	    (pre_pg_data[2] == 0x00) && (pre_pg_data[3] == 0x00) &&
@@ -175,7 +175,7 @@ void r8712_efuse_change_max_size(struct _adapter *padapter)
 		efuse_available_max_size -= pre_pg_data_size;
 }
 
-int r8712_efuse_get_max_size(struct _adapter *padapter)
+int r8712_efuse_get_max_size(struct _adapter *adapter)
 {
 	return	efuse_available_max_size;
 }
@@ -206,14 +206,14 @@ static void pgpacket_copy_data(const u8 word_en, const u8 *sourdata,
 	}
 }
 
-u16 r8712_efuse_get_current_size(struct _adapter *padapter)
+u16 r8712_efuse_get_current_size(struct _adapter *adapter)
 {
 	int bContinual = true;
 	u16 efuse_addr = 0;
 	u8 hworden = 0;
 	u8 efuse_data, word_cnts = 0;
 
-	while (bContinual && efuse_one_byte_read(padapter, efuse_addr,
+	while (bContinual && efuse_one_byte_read(adapter, efuse_addr,
 	       &efuse_data) && (efuse_addr < efuse_available_max_size)) {
 		if (efuse_data != 0xFF) {
 			hworden =  efuse_data & 0x0F;
@@ -227,7 +227,7 @@ u16 r8712_efuse_get_current_size(struct _adapter *padapter)
 	return efuse_addr;
 }
 
-u8 r8712_efuse_pg_packet_read(struct _adapter *padapter, u8 offset, u8 *data)
+u8 r8712_efuse_pg_packet_read(struct _adapter *adapter, u8 offset, u8 *data)
 {
 	u8 hoffset = 0, hworden = 0, word_cnts = 0;
 	u16 efuse_addr = 0;
@@ -242,7 +242,7 @@ u8 r8712_efuse_pg_packet_read(struct _adapter *padapter, u8 offset, u8 *data)
 		return false;
 	memset(data, 0xFF, sizeof(u8) * PGPKT_DATA_SIZE);
 	while (efuse_addr < efuse_available_max_size) {
-		if (efuse_one_byte_read(padapter, efuse_addr, &efuse_data)) {
+		if (efuse_one_byte_read(adapter, efuse_addr, &efuse_data)) {
 			if (efuse_data == 0xFF)
 				break;
 			hoffset = (efuse_data >> 4) & 0x0F;
@@ -252,7 +252,7 @@ u8 r8712_efuse_pg_packet_read(struct _adapter *padapter, u8 offset, u8 *data)
 				memset(tmpdata, 0xFF, PGPKT_DATA_SIZE);
 				for (tmpidx = 0; tmpidx < word_cnts * 2;
 				     tmpidx++) {
-					if (efuse_one_byte_read(padapter,
+					if (efuse_one_byte_read(adapter,
 					    efuse_addr + 1 + tmpidx,
 					    &efuse_data)) {
 						tmpdata[tmpidx] = efuse_data;
@@ -271,7 +271,7 @@ u8 r8712_efuse_pg_packet_read(struct _adapter *padapter, u8 offset, u8 *data)
 	return ret;
 }
 
-static u8 fix_header(struct _adapter *padapter, u8 header, u16 header_addr)
+static u8 fix_header(struct _adapter *adapter, u8 header, u16 header_addr)
 {
 	struct PGPKT_STRUCT pkt;
 	u8 offset, word_en, value;
@@ -287,7 +287,7 @@ static u8 fix_header(struct _adapter *padapter, u8 header, u16 header_addr)
 	/* retrieve original data */
 	addr = 0;
 	while (addr < header_addr) {
-		if (!efuse_one_byte_read(padapter, addr++, &value)) {
+		if (!efuse_one_byte_read(adapter, addr++, &value)) {
 			ret = false;
 			break;
 		}
@@ -301,13 +301,13 @@ static u8 fix_header(struct _adapter *padapter, u8 header, u16 header_addr)
 			if (BIT(i) & word_en) {
 				if (BIT(i) & pkt.word_en) {
 					if (efuse_one_byte_read(
-							padapter, addr,
+							adapter, addr,
 							&value))
 						pkt.data[i * 2] = value;
 					else
 						return false;
 					if (efuse_one_byte_read(
-							padapter,
+							adapter,
 							addr + 1,
 							&value))
 						pkt.data[i * 2 + 1] =
@@ -325,24 +325,24 @@ static u8 fix_header(struct _adapter *padapter, u8 header, u16 header_addr)
 	/* fill original data */
 	for (i = 0; i < PGPKG_MAX_WORDS; i++) {
 		if (BIT(i) & pkt.word_en) {
-			efuse_one_byte_write(padapter, addr, pkt.data[i * 2]);
-			efuse_one_byte_write(padapter, addr + 1,
+			efuse_one_byte_write(adapter, addr, pkt.data[i * 2]);
+			efuse_one_byte_write(adapter, addr + 1,
 					     pkt.data[i * 2 + 1]);
 			/* additional check */
-			if (!efuse_one_byte_read(padapter, addr, &value)) {
+			if (!efuse_one_byte_read(adapter, addr, &value)) {
 				ret = false;
 			} else if (pkt.data[i * 2] != value) {
 				ret = false;
 				if (value == 0xFF) /* write again */
-					efuse_one_byte_write(padapter, addr,
+					efuse_one_byte_write(adapter, addr,
 							     pkt.data[i * 2]);
 			}
-			if (!efuse_one_byte_read(padapter, addr + 1, &value)) {
+			if (!efuse_one_byte_read(adapter, addr + 1, &value)) {
 				ret = false;
 			} else if (pkt.data[i * 2 + 1] != value) {
 				ret = false;
 				if (value == 0xFF) /* write again */
-					efuse_one_byte_write(padapter, addr + 1,
+					efuse_one_byte_write(adapter, addr + 1,
 							     pkt.data[i * 2 +
 								      1]);
 			}
@@ -352,7 +352,7 @@ static u8 fix_header(struct _adapter *padapter, u8 header, u16 header_addr)
 	return ret;
 }
 
-u8 r8712_efuse_pg_packet_write(struct _adapter *padapter, const u8 offset,
+u8 r8712_efuse_pg_packet_write(struct _adapter *adapter, const u8 offset,
 			       const u8 word_en, const u8 *data)
 {
 	u8 pg_header = 0;
@@ -363,7 +363,7 @@ u8 r8712_efuse_pg_packet_write(struct _adapter *padapter, const u8 offset,
 	u8 bResult = true;
 
 	/* check if E-Fuse Clock Enable and E-Fuse Clock is 40M */
-	efuse_data = r8712_read8(padapter, EFUSE_CLK_CTRL);
+	efuse_data = r8712_read8(adapter, EFUSE_CLK_CTRL);
 	if (efuse_data != 0x03)
 		return false;
 	pg_header = MAKE_EFUSE_HEADER(offset, word_en);
@@ -371,15 +371,15 @@ u8 r8712_efuse_pg_packet_write(struct _adapter *padapter, const u8 offset,
 	repeat_times = 0;
 	efuse_addr = 0;
 	while (efuse_addr < efuse_available_max_size) {
-		curr_size = r8712_efuse_get_current_size(padapter);
+		curr_size = r8712_efuse_get_current_size(adapter);
 		if ((curr_size + 1 + target_word_cnts * 2) >
 		     efuse_available_max_size)
 			return false; /*target_word_cnts + pg header(1 byte)*/
 		efuse_addr = curr_size; /* current size is also the last addr*/
-		efuse_one_byte_write(padapter, efuse_addr, pg_header); /*hdr*/
+		efuse_one_byte_write(adapter, efuse_addr, pg_header); /*hdr*/
 		sub_repeat = 0;
 		/* check if what we read is what we write */
-		while (!efuse_one_byte_read(padapter, efuse_addr,
+		while (!efuse_one_byte_read(adapter, efuse_addr,
 					    &efuse_data)) {
 			if (++sub_repeat > _REPEAT_THRESHOLD_) {
 				bResult = false; /* continue to blind write */
@@ -394,10 +394,10 @@ u8 r8712_efuse_pg_packet_write(struct _adapter *padapter, const u8 offset,
 			/* go to next address */
 			efuse_addr++;
 			for (i = 0; i < target_word_cnts * 2; i++) {
-				efuse_one_byte_write(padapter,
+				efuse_one_byte_write(adapter,
 						     efuse_addr + i,
 						     *(data + i));
-				if (!efuse_one_byte_read(padapter,
+				if (!efuse_one_byte_read(adapter,
 							 efuse_addr + i,
 							 &efuse_data))
 					bResult = false;
@@ -411,7 +411,7 @@ u8 r8712_efuse_pg_packet_write(struct _adapter *padapter, const u8 offset,
 		if (efuse_data == 0xFF)
 			return bResult; /* nothing damaged. */
 		/* call rescue procedure */
-		if (!fix_header(padapter, efuse_data, efuse_addr))
+		if (!fix_header(adapter, efuse_data, efuse_addr))
 			return false; /* rescue fail */
 
 		if (++repeat_times > _REPEAT_THRESHOLD_) /* fail */
@@ -421,7 +421,7 @@ u8 r8712_efuse_pg_packet_write(struct _adapter *padapter, const u8 offset,
 	return bResult;
 }
 
-u8 r8712_efuse_access(struct _adapter *padapter, u8 bRead, u16 start_addr,
+u8 r8712_efuse_access(struct _adapter *adapter, u8 bRead, u16 start_addr,
 		      u16 cnts, u8 *data)
 {
 	int i;
@@ -432,7 +432,7 @@ u8 r8712_efuse_access(struct _adapter *padapter, u8 bRead, u16 start_addr,
 	if (!bRead && ((start_addr + cnts) >
 	   efuse_available_max_size))
 		return false;
-	if (!bRead && !r8712_efuse_reg_init(padapter))
+	if (!bRead && !r8712_efuse_reg_init(adapter))
 		return false;
 	/* -----------------e-fuse one byte read / write ---------------------*/
 	for (i = 0; i < cnts; i++) {
@@ -440,17 +440,17 @@ u8 r8712_efuse_access(struct _adapter *padapter, u8 bRead, u16 start_addr,
 			res = false;
 			break;
 		}
-		res = efuse_one_byte_rw(padapter, bRead, start_addr + i,
+		res = efuse_one_byte_rw(adapter, bRead, start_addr + i,
 					data + i);
 		if (!bRead && !res)
 			break;
 	}
 	if (!bRead)
-		r8712_efuse_reg_uninit(padapter);
+		r8712_efuse_reg_uninit(adapter);
 	return res;
 }
 
-u8 r8712_efuse_map_read(struct _adapter *padapter, u16 addr, u16 cnts, u8 *data)
+u8 r8712_efuse_map_read(struct _adapter *adapter, u16 addr, u16 cnts, u8 *data)
 {
 	u8 offset, ret = true;
 	u8 pktdata[PGPKT_DATA_SIZE];
@@ -458,13 +458,13 @@ u8 r8712_efuse_map_read(struct _adapter *padapter, u16 addr, u16 cnts, u8 *data)
 
 	if ((addr + cnts) > EFUSE_MAP_MAX_SIZE)
 		return false;
-	if (efuse_is_empty(padapter, &offset) && offset) {
+	if (efuse_is_empty(adapter, &offset) && offset) {
 		for (i = 0; i < cnts; i++)
 			data[i] = 0xFF;
 		return ret;
 	}
 	offset = (addr >> 3) & 0xF;
-	ret = r8712_efuse_pg_packet_read(padapter, offset, pktdata);
+	ret = r8712_efuse_pg_packet_read(adapter, offset, pktdata);
 	i = addr & 0x7;	/* pktdata index */
 	idx = 0;	/* data index */
 
@@ -475,14 +475,14 @@ u8 r8712_efuse_map_read(struct _adapter *padapter, u16 addr, u16 cnts, u8 *data)
 				return ret;
 		}
 		offset++;
-		if (!r8712_efuse_pg_packet_read(padapter, offset, pktdata))
+		if (!r8712_efuse_pg_packet_read(adapter, offset, pktdata))
 			ret = false;
 		i = 0;
 	} while (1);
 	return ret;
 }
 
-u8 r8712_efuse_map_write(struct _adapter *padapter, u16 addr, u16 cnts,
+u8 r8712_efuse_map_write(struct _adapter *adapter, u16 addr, u16 cnts,
 			 u8 *data)
 {
 	u8 offset, word_en, empty;
@@ -492,10 +492,10 @@ u8 r8712_efuse_map_write(struct _adapter *padapter, u16 addr, u16 cnts,
 	if ((addr + cnts) > EFUSE_MAP_MAX_SIZE)
 		return false;
 	/* check if E-Fuse Clock Enable and E-Fuse Clock is 40M */
-	empty = r8712_read8(padapter, EFUSE_CLK_CTRL);
+	empty = r8712_read8(adapter, EFUSE_CLK_CTRL);
 	if (empty != 0x03)
 		return false;
-	if (efuse_is_empty(padapter, &empty)) {
+	if (efuse_is_empty(adapter, &empty)) {
 		if (empty)
 			memset(pktdata, 0xFF, PGPKT_DATA_SIZE);
 	} else {
@@ -503,7 +503,7 @@ u8 r8712_efuse_map_write(struct _adapter *padapter, u16 addr, u16 cnts,
 	}
 	offset = (addr >> 3) & 0xF;
 	if (!empty)
-		if (!r8712_efuse_pg_packet_read(padapter, offset, pktdata))
+		if (!r8712_efuse_pg_packet_read(adapter, offset, pktdata))
 			return false;
 	word_en = 0xF;
 	memset(newdata, 0xFF, PGPKT_DATA_SIZE);
@@ -546,14 +546,14 @@ u8 r8712_efuse_map_write(struct _adapter *padapter, u16 addr, u16 cnts,
 		}
 
 		if (word_en != 0xF)
-			if (!r8712_efuse_pg_packet_write(padapter, offset,
+			if (!r8712_efuse_pg_packet_write(adapter, offset,
 							 word_en, newdata))
 				return false;
 		if (idx == cnts)
 			break;
 		offset++;
 		if (!empty)
-			if (!r8712_efuse_pg_packet_read(padapter, offset,
+			if (!r8712_efuse_pg_packet_read(adapter, offset,
 							pktdata))
 				return false;
 		i = 0;

commit f916e23f56a8b061450c52da5c28c5b2d62c11f1
Author: Payal Kshirsagar <payal.s.kshirsagar.98@gmail.com>
Date:   Thu Mar 21 20:09:08 2019 +0530

    staging: rtl8712: alignment should match open parenthesis
    
    Align code to the open parenthesis to fix the alignment issue.
    
    Signed-off-by: Payal Kshirsagar <payal.s.kshirsagar.98@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8712/rtl8712_efuse.c b/drivers/staging/rtl8712/rtl8712_efuse.c
index 39eb74374d0b..00babd011a62 100644
--- a/drivers/staging/rtl8712/rtl8712_efuse.c
+++ b/drivers/staging/rtl8712/rtl8712_efuse.c
@@ -353,7 +353,7 @@ static u8 fix_header(struct _adapter *padapter, u8 header, u16 header_addr)
 }
 
 u8 r8712_efuse_pg_packet_write(struct _adapter *padapter, const u8 offset,
-			 const u8 word_en, const u8 *data)
+			       const u8 word_en, const u8 *data)
 {
 	u8 pg_header = 0;
 	u16 efuse_addr = 0, curr_size = 0;
@@ -441,7 +441,7 @@ u8 r8712_efuse_access(struct _adapter *padapter, u8 bRead, u16 start_addr,
 			break;
 		}
 		res = efuse_one_byte_rw(padapter, bRead, start_addr + i,
-		      data + i);
+					data + i);
 		if (!bRead && !res)
 			break;
 	}
@@ -554,7 +554,7 @@ u8 r8712_efuse_map_write(struct _adapter *padapter, u16 addr, u16 cnts,
 		offset++;
 		if (!empty)
 			if (!r8712_efuse_pg_packet_read(padapter, offset,
-			    pktdata))
+							pktdata))
 				return false;
 		i = 0;
 		j = 0;

commit 585f22691dcda2a0ab197072f3a14f0b5684adfc
Author: YueHaibing <yuehaibing@huawei.com>
Date:   Mon Jan 21 07:53:13 2019 +0000

    staging: rtl8712: drop pointless static qualifier in r8712_efuse_pg_packet_write()
    
    There is no need to have the 'intrepeat_times' variable static since new
    value always be assigned before use it.
    
    Signed-off-by: YueHaibing <yuehaibing@huawei.com>
    Acked-by: Larry Finger <Larry.Finger@lwfinger.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8712/rtl8712_efuse.c b/drivers/staging/rtl8712/rtl8712_efuse.c
index 8bc45ffd3029..39eb74374d0b 100644
--- a/drivers/staging/rtl8712/rtl8712_efuse.c
+++ b/drivers/staging/rtl8712/rtl8712_efuse.c
@@ -358,7 +358,7 @@ u8 r8712_efuse_pg_packet_write(struct _adapter *padapter, const u8 offset,
 	u8 pg_header = 0;
 	u16 efuse_addr = 0, curr_size = 0;
 	u8 efuse_data, target_word_cnts = 0;
-	static int repeat_times;
+	int repeat_times;
 	int sub_repeat;
 	u8 bResult = true;
 

commit e24c1f8658c94c8d74f6d9f36066a6c573117e85
Author: Michael Straube <straube.linux@gmail.com>
Date:   Wed Oct 3 16:17:16 2018 +0200

    staging: rtl8712: add SPDX identifiers
    
    This satisfies a checkpatch warning and is the preferred
    method for notating the license.
    
    The SPDX identifier is a legally binding shorthand, which
    can be used instead of the full boiler plate text.
    
    Signed-off-by: Michael Straube <straube.linux@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8712/rtl8712_efuse.c b/drivers/staging/rtl8712/rtl8712_efuse.c
index d90213eb5e20..8bc45ffd3029 100644
--- a/drivers/staging/rtl8712/rtl8712_efuse.c
+++ b/drivers/staging/rtl8712/rtl8712_efuse.c
@@ -1,22 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * rtl8712_efuse.c
  *
  * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
  * Linux device driver for RTL8192SU
  *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
  * Modifications for inclusion into the Linux staging tree are
  * Copyright(c) 2010 Larry Finger. All rights reserved.
  *

commit 1e1858cb60b22b7f9a1dc67c741c569bae65ec3f
Author: Arushi Singhal <arushisinghal19971997@gmail.com>
Date:   Fri Jul 7 11:11:36 2017 +0530

    staging: rtl8712: fix "Alignment match open parenthesis"
    
    Fix checkpatch issues: "CHECK: Alignment should match open parenthesis".
    
    Signed-off-by: Arushi Singhal <arushisinghal19971997@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8712/rtl8712_efuse.c b/drivers/staging/rtl8712/rtl8712_efuse.c
index 205298e23656..d90213eb5e20 100644
--- a/drivers/staging/rtl8712/rtl8712_efuse.c
+++ b/drivers/staging/rtl8712/rtl8712_efuse.c
@@ -347,7 +347,7 @@ static u8 fix_header(struct _adapter *padapter, u8 header, u16 header_addr)
 				ret = false;
 				if (value == 0xFF) /* write again */
 					efuse_one_byte_write(padapter, addr,
-							pkt.data[i * 2]);
+							     pkt.data[i * 2]);
 			}
 			if (!efuse_one_byte_read(padapter, addr + 1, &value)) {
 				ret = false;

commit c43fcdd4434b7afef7f37bdad1c51b877cffc4ce
Author: Sandhya Bankar <bankarsandhya512@gmail.com>
Date:   Tue Sep 20 14:31:50 2016 +0530

    Staging: rtl8712: rtl8712_efuse: Use !x instead of x == NULL.
    
    Use !x instead of x == NULL. This patch was found by checkpatch.
    
    Signed-off-by: Sandhya Bankar <bankarsandhya512@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8712/rtl8712_efuse.c b/drivers/staging/rtl8712/rtl8712_efuse.c
index 76f60ba5ee9b..205298e23656 100644
--- a/drivers/staging/rtl8712/rtl8712_efuse.c
+++ b/drivers/staging/rtl8712/rtl8712_efuse.c
@@ -248,7 +248,7 @@ u8 r8712_efuse_pg_packet_read(struct _adapter *padapter, u8 offset, u8 *data)
 	u8 tmpdata[PGPKT_DATA_SIZE];
 	u8 ret = true;
 
-	if (data == NULL)
+	if (!data)
 		return false;
 	if (offset > 0x0f)
 		return false;

commit f7099ad7bd35c56795fb50f5026b7040abac62da
Author: Rakhi Sharma <rakhish1994@gmail.com>
Date:   Sat Feb 13 10:54:20 2016 +0530

    staging: rtl8712: Fixed a comparision coding style warning.
    
    WARNING: Comparisons should place the constant on the right side of the test
    Fixed this warning by placing the constant on right side.
    
    Signed-off-by: Rakhi Sharma <rakhish1994@gmail.com>-
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8712/rtl8712_efuse.c b/drivers/staging/rtl8712/rtl8712_efuse.c
index eaa93fbb95a3..76f60ba5ee9b 100644
--- a/drivers/staging/rtl8712/rtl8712_efuse.c
+++ b/drivers/staging/rtl8712/rtl8712_efuse.c
@@ -161,7 +161,7 @@ static u8 efuse_is_empty(struct _adapter *padapter, u8 *empty)
 
 	/* read one byte to check if E-Fuse is empty */
 	if (efuse_one_byte_rw(padapter, true, 0, &value)) {
-		if (0xFF == value)
+		if (value == 0xFF)
 			*empty = true;
 		else
 			*empty = false;
@@ -345,7 +345,7 @@ static u8 fix_header(struct _adapter *padapter, u8 header, u16 header_addr)
 				ret = false;
 			} else if (pkt.data[i * 2] != value) {
 				ret = false;
-				if (0xFF == value) /* write again */
+				if (value == 0xFF) /* write again */
 					efuse_one_byte_write(padapter, addr,
 							pkt.data[i * 2]);
 			}
@@ -353,7 +353,7 @@ static u8 fix_header(struct _adapter *padapter, u8 header, u16 header_addr)
 				ret = false;
 			} else if (pkt.data[i * 2 + 1] != value) {
 				ret = false;
-				if (0xFF == value) /* write again */
+				if (value == 0xFF) /* write again */
 					efuse_one_byte_write(padapter, addr + 1,
 							     pkt.data[i * 2 +
 								      1]);
@@ -420,7 +420,7 @@ u8 r8712_efuse_pg_packet_write(struct _adapter *padapter, const u8 offset,
 		}
 		/* write header fail */
 		bResult = false;
-		if (0xFF == efuse_data)
+		if (efuse_data == 0xFF)
 			return bResult; /* nothing damaged. */
 		/* call rescue procedure */
 		if (!fix_header(padapter, efuse_data, efuse_addr))

commit 4ef2de5ae0377bc88c1f5021c3797db3c62bc384
Author: Luis de Bethencourt <luisbg@osg.samsung.com>
Date:   Mon Oct 19 18:16:01 2015 +0100

    staging: rtl8712: spaces preferred around operands
    
    Clean up all instances of checkpatch.pl checks:
    CHECK: spaces preferred around that '+'
    (and other operands)
    
    Signed-off-by: Luis de Bethencourt <luisbg@osg.samsung.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8712/rtl8712_efuse.c b/drivers/staging/rtl8712/rtl8712_efuse.c
index 4dcc82632326..eaa93fbb95a3 100644
--- a/drivers/staging/rtl8712/rtl8712_efuse.c
+++ b/drivers/staging/rtl8712/rtl8712_efuse.c
@@ -80,12 +80,13 @@ static u8 efuse_one_byte_read(struct _adapter *padapter, u16 addr, u8 *data)
 	u8 tmpidx = 0, bResult;
 
 	/* -----------------e-fuse reg ctrl --------------------------------- */
-	r8712_write8(padapter, EFUSE_CTRL+1, (u8)(addr&0xFF)); /* address */
-	r8712_write8(padapter, EFUSE_CTRL+2, ((u8)((addr>>8)&0x03)) |
-	       (r8712_read8(padapter, EFUSE_CTRL+2)&0xFC));
-	r8712_write8(padapter, EFUSE_CTRL+3, 0x72); /* read cmd */
+	r8712_write8(padapter, EFUSE_CTRL + 1, (u8)(addr & 0xFF)); /* address */
+	r8712_write8(padapter, EFUSE_CTRL + 2, ((u8)((addr >> 8) & 0x03)) |
+	       (r8712_read8(padapter, EFUSE_CTRL + 2) & 0xFC));
+	r8712_write8(padapter, EFUSE_CTRL + 3, 0x72); /* read cmd */
 	/* wait for complete */
-	while (!(0x80 & r8712_read8(padapter, EFUSE_CTRL+3)) && (tmpidx < 100))
+	while (!(0x80 & r8712_read8(padapter, EFUSE_CTRL + 3)) &&
+	       (tmpidx < 100))
 		tmpidx++;
 	if (tmpidx < 100) {
 		*data = r8712_read8(padapter, EFUSE_CTRL);
@@ -102,13 +103,14 @@ static u8 efuse_one_byte_write(struct _adapter *padapter, u16 addr, u8 data)
 	u8 tmpidx = 0, bResult;
 
 	/* -----------------e-fuse reg ctrl -------------------------------- */
-	r8712_write8(padapter, EFUSE_CTRL+1, (u8)(addr&0xFF)); /* address */
-	r8712_write8(padapter, EFUSE_CTRL+2, ((u8)((addr>>8)&0x03)) |
-	       (r8712_read8(padapter, EFUSE_CTRL+2)&0xFC));
+	r8712_write8(padapter, EFUSE_CTRL + 1, (u8)(addr & 0xFF)); /* address */
+	r8712_write8(padapter, EFUSE_CTRL + 2, ((u8)((addr >> 8) & 0x03)) |
+	       (r8712_read8(padapter, EFUSE_CTRL + 2) & 0xFC));
 	r8712_write8(padapter, EFUSE_CTRL, data); /* data */
-	r8712_write8(padapter, EFUSE_CTRL+3, 0xF2); /* write cmd */
+	r8712_write8(padapter, EFUSE_CTRL + 3, 0xF2); /* write cmd */
 	/* wait for complete */
-	while ((0x80 &  r8712_read8(padapter, EFUSE_CTRL+3)) && (tmpidx < 100))
+	while ((0x80 &  r8712_read8(padapter, EFUSE_CTRL + 3)) &&
+	       (tmpidx < 100))
 		tmpidx++;
 	if (tmpidx < 100)
 		bResult = true;
@@ -123,13 +125,13 @@ static u8 efuse_one_byte_rw(struct _adapter *padapter, u8 bRead, u16 addr,
 	u8 tmpidx = 0, tmpv8 = 0, bResult;
 
 	/* -----------------e-fuse reg ctrl --------------------------------- */
-	r8712_write8(padapter, EFUSE_CTRL+1, (u8)(addr&0xFF)); /* address */
+	r8712_write8(padapter, EFUSE_CTRL + 1, (u8)(addr & 0xFF)); /* address */
 	tmpv8 = ((u8)((addr >> 8) & 0x03)) |
 		 (r8712_read8(padapter, EFUSE_CTRL + 2) & 0xFC);
-	r8712_write8(padapter, EFUSE_CTRL+2, tmpv8);
+	r8712_write8(padapter, EFUSE_CTRL + 2, tmpv8);
 	if (bRead) {
-		r8712_write8(padapter, EFUSE_CTRL+3,  0x72); /* read cmd */
-		while (!(0x80 & r8712_read8(padapter, EFUSE_CTRL+3)) &&
+		r8712_write8(padapter, EFUSE_CTRL + 3,  0x72); /* read cmd */
+		while (!(0x80 & r8712_read8(padapter, EFUSE_CTRL + 3)) &&
 		       (tmpidx < 100))
 			tmpidx++;
 		if (tmpidx < 100) {
@@ -141,8 +143,8 @@ static u8 efuse_one_byte_rw(struct _adapter *padapter, u8 bRead, u16 addr,
 		}
 	} else {
 		r8712_write8(padapter, EFUSE_CTRL, *data); /* data */
-		r8712_write8(padapter, EFUSE_CTRL+3, 0xF2); /* write cmd */
-		while ((0x80 & r8712_read8(padapter, EFUSE_CTRL+3)) &&
+		r8712_write8(padapter, EFUSE_CTRL + 3, 0xF2); /* write cmd */
+		while ((0x80 & r8712_read8(padapter, EFUSE_CTRL + 3)) &&
 		       (tmpidx < 100))
 			tmpidx++;
 		if (tmpidx < 100)
@@ -208,7 +210,7 @@ static void pgpacket_copy_data(const u8 word_en, const u8 *sourdata,
 	u8 word_idx, byte_idx;
 
 	for (word_idx = 0; word_idx < PGPKG_MAX_WORDS; word_idx++) {
-		if (!(word_en&BIT(word_idx))) {
+		if (!(word_en & BIT(word_idx))) {
 			byte_idx = word_idx * 2;
 			targetdata[byte_idx] = sourdata[tmpindex++];
 			targetdata[byte_idx + 1] = sourdata[tmpindex++];
@@ -250,7 +252,7 @@ u8 r8712_efuse_pg_packet_read(struct _adapter *padapter, u8 offset, u8 *data)
 		return false;
 	if (offset > 0x0f)
 		return false;
-	memset(data, 0xFF, sizeof(u8)*PGPKT_DATA_SIZE);
+	memset(data, 0xFF, sizeof(u8) * PGPKT_DATA_SIZE);
 	while (efuse_addr < efuse_available_max_size) {
 		if (efuse_one_byte_read(padapter, efuse_addr, &efuse_data)) {
 			if (efuse_data == 0xFF)
@@ -263,7 +265,8 @@ u8 r8712_efuse_pg_packet_read(struct _adapter *padapter, u8 offset, u8 *data)
 				for (tmpidx = 0; tmpidx < word_cnts * 2;
 				     tmpidx++) {
 					if (efuse_one_byte_read(padapter,
-					    efuse_addr+1+tmpidx, &efuse_data)) {
+					    efuse_addr + 1 + tmpidx,
+					    &efuse_data)) {
 						tmpdata[tmpidx] = efuse_data;
 					} else {
 						ret = false;
@@ -271,7 +274,7 @@ u8 r8712_efuse_pg_packet_read(struct _adapter *padapter, u8 offset, u8 *data)
 				}
 				pgpacket_copy_data(hworden, tmpdata, data);
 			}
-			efuse_addr += 1 + (word_cnts*2);
+			efuse_addr += 1 + (word_cnts * 2);
 		} else {
 			ret = false;
 			break;
@@ -303,7 +306,7 @@ static u8 fix_header(struct _adapter *padapter, u8 header, u16 header_addr)
 		offset = GET_EFUSE_OFFSET(value);
 		word_en = GET_EFUSE_WORD_EN(value);
 		if (pkt.offset != offset) {
-			addr += calculate_word_cnts(word_en)*2;
+			addr += calculate_word_cnts(word_en) * 2;
 			continue;
 		}
 		for (i = 0; i < PGPKG_MAX_WORDS; i++) {
@@ -312,14 +315,14 @@ static u8 fix_header(struct _adapter *padapter, u8 header, u16 header_addr)
 					if (efuse_one_byte_read(
 							padapter, addr,
 							&value))
-						pkt.data[i*2] = value;
+						pkt.data[i * 2] = value;
 					else
 						return false;
 					if (efuse_one_byte_read(
 							padapter,
 							addr + 1,
 							&value))
-						pkt.data[i*2 + 1] =
+						pkt.data[i * 2 + 1] =
 							value;
 					else
 						return false;
@@ -334,25 +337,26 @@ static u8 fix_header(struct _adapter *padapter, u8 header, u16 header_addr)
 	/* fill original data */
 	for (i = 0; i < PGPKG_MAX_WORDS; i++) {
 		if (BIT(i) & pkt.word_en) {
-			efuse_one_byte_write(padapter, addr, pkt.data[i*2]);
-			efuse_one_byte_write(padapter, addr+1,
-					pkt.data[i*2 + 1]);
+			efuse_one_byte_write(padapter, addr, pkt.data[i * 2]);
+			efuse_one_byte_write(padapter, addr + 1,
+					     pkt.data[i * 2 + 1]);
 			/* additional check */
 			if (!efuse_one_byte_read(padapter, addr, &value)) {
 				ret = false;
-			} else if (pkt.data[i*2] != value) {
+			} else if (pkt.data[i * 2] != value) {
 				ret = false;
 				if (0xFF == value) /* write again */
 					efuse_one_byte_write(padapter, addr,
 							pkt.data[i * 2]);
 			}
-			if (!efuse_one_byte_read(padapter, addr+1, &value)) {
+			if (!efuse_one_byte_read(padapter, addr + 1, &value)) {
 				ret = false;
-			} else if (pkt.data[i*2 + 1] != value) {
+			} else if (pkt.data[i * 2 + 1] != value) {
 				ret = false;
 				if (0xFF == value) /* write again */
-					efuse_one_byte_write(padapter, addr+1,
-							pkt.data[i*2 + 1]);
+					efuse_one_byte_write(padapter, addr + 1,
+							     pkt.data[i * 2 +
+								      1]);
 			}
 		}
 		addr += 2;
@@ -401,7 +405,7 @@ u8 r8712_efuse_pg_packet_write(struct _adapter *padapter, const u8 offset,
 
 			/* go to next address */
 			efuse_addr++;
-			for (i = 0; i < target_word_cnts*2; i++) {
+			for (i = 0; i < target_word_cnts * 2; i++) {
 				efuse_one_byte_write(padapter,
 						     efuse_addr + i,
 						     *(data + i));
@@ -409,7 +413,7 @@ u8 r8712_efuse_pg_packet_write(struct _adapter *padapter, const u8 offset,
 							 efuse_addr + i,
 							 &efuse_data))
 					bResult = false;
-				else if (*(data+i) != efuse_data) /* fail */
+				else if (*(data + i) != efuse_data) /* fail */
 					bResult = false;
 			}
 			break;
@@ -541,8 +545,8 @@ u8 r8712_efuse_map_write(struct _adapter *padapter, u16 addr, u16 cnts,
 				break;
 			}
 
-			if ((data[idx] != pktdata[i]) || (data[idx+1] !=
-			     pktdata[i+1])) {
+			if ((data[idx] != pktdata[i]) || (data[idx + 1] !=
+			     pktdata[i + 1])) {
 				word_en &= ~BIT(i >> 1);
 				newdata[j++] = data[idx];
 				newdata[j++] = data[idx + 1];

commit 168a2c10288d78f1e8504d132f59bb407f4fb9a6
Author: Luis de Bethencourt <luisbg@osg.samsung.com>
Date:   Mon Oct 19 18:15:29 2015 +0100

    staging: rtl8712: braces should be used on all arms
    
    Fix all instances of the following checkpatch.pl check:
    CHECK: braces {} should be used on all arms of this statement
    
    Signed-off-by: Luis de Bethencourt <luisbg@osg.samsung.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8712/rtl8712_efuse.c b/drivers/staging/rtl8712/rtl8712_efuse.c
index 13d4b8dcf073..4dcc82632326 100644
--- a/drivers/staging/rtl8712/rtl8712_efuse.c
+++ b/drivers/staging/rtl8712/rtl8712_efuse.c
@@ -163,8 +163,9 @@ static u8 efuse_is_empty(struct _adapter *padapter, u8 *empty)
 			*empty = true;
 		else
 			*empty = false;
-	} else
+	} else {
 		ret = false;
+	}
 	return ret;
 }
 
@@ -229,8 +230,9 @@ u16 r8712_efuse_get_current_size(struct _adapter *padapter)
 			word_cnts = calculate_word_cnts(hworden);
 			/* read next header */
 			efuse_addr = efuse_addr + (word_cnts * 2) + 1;
-		} else
+		} else {
 			bContinual = false;
+		}
 	}
 	return efuse_addr;
 }
@@ -263,8 +265,9 @@ u8 r8712_efuse_pg_packet_read(struct _adapter *padapter, u8 offset, u8 *data)
 					if (efuse_one_byte_read(padapter,
 					    efuse_addr+1+tmpidx, &efuse_data)) {
 						tmpdata[tmpidx] = efuse_data;
-					} else
+					} else {
 						ret = false;
+					}
 				}
 				pgpacket_copy_data(hworden, tmpdata, data);
 			}
@@ -335,17 +338,17 @@ static u8 fix_header(struct _adapter *padapter, u8 header, u16 header_addr)
 			efuse_one_byte_write(padapter, addr+1,
 					pkt.data[i*2 + 1]);
 			/* additional check */
-			if (!efuse_one_byte_read(padapter, addr, &value))
+			if (!efuse_one_byte_read(padapter, addr, &value)) {
 				ret = false;
-			else if (pkt.data[i*2] != value) {
+			} else if (pkt.data[i*2] != value) {
 				ret = false;
 				if (0xFF == value) /* write again */
 					efuse_one_byte_write(padapter, addr,
 							pkt.data[i * 2]);
 			}
-			if (!efuse_one_byte_read(padapter, addr+1, &value))
+			if (!efuse_one_byte_read(padapter, addr+1, &value)) {
 				ret = false;
-			else if (pkt.data[i*2 + 1] != value) {
+			} else if (pkt.data[i*2 + 1] != value) {
 				ret = false;
 				if (0xFF == value) /* write again */
 					efuse_one_byte_write(padapter, addr+1,
@@ -503,8 +506,9 @@ u8 r8712_efuse_map_write(struct _adapter *padapter, u16 addr, u16 cnts,
 	if (efuse_is_empty(padapter, &empty)) {
 		if (empty)
 			memset(pktdata, 0xFF, PGPKT_DATA_SIZE);
-	} else
+	} else {
 		return false;
+	}
 	offset = (addr >> 3) & 0xF;
 	if (!empty)
 		if (!r8712_efuse_pg_packet_read(padapter, offset, pktdata))

commit 1ca96884b12dd2d57e0339d9f4a29e4888edc0e2
Author: Luis de Bethencourt <luisbg@osg.samsung.com>
Date:   Mon Oct 19 18:14:29 2015 +0100

    staging: rtl8712: Remove boolean comparisons
    
    Boolean tests do not need explicit comparison to true or false.
    
    Signed-off-by: Luis de Bethencourt <luisbg@osg.samsung.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8712/rtl8712_efuse.c b/drivers/staging/rtl8712/rtl8712_efuse.c
index d95716999498..13d4b8dcf073 100644
--- a/drivers/staging/rtl8712/rtl8712_efuse.c
+++ b/drivers/staging/rtl8712/rtl8712_efuse.c
@@ -39,7 +39,7 @@ static void efuse_reg_ctrl(struct _adapter *padapter, u8 bPowerOn)
 {
 	u8 tmpu8 = 0;
 
-	if (true == bPowerOn) {
+	if (bPowerOn) {
 		/* -----------------e-fuse pwr & clk reg ctrl ---------------
 		 * Enable LDOE25 Macro Block
 		 */
@@ -127,7 +127,7 @@ static u8 efuse_one_byte_rw(struct _adapter *padapter, u8 bRead, u16 addr,
 	tmpv8 = ((u8)((addr >> 8) & 0x03)) |
 		 (r8712_read8(padapter, EFUSE_CTRL + 2) & 0xFC);
 	r8712_write8(padapter, EFUSE_CTRL+2, tmpv8);
-	if (true == bRead) {
+	if (bRead) {
 		r8712_write8(padapter, EFUSE_CTRL+3,  0x72); /* read cmd */
 		while (!(0x80 & r8712_read8(padapter, EFUSE_CTRL+3)) &&
 		       (tmpidx < 100))
@@ -158,7 +158,7 @@ static u8 efuse_is_empty(struct _adapter *padapter, u8 *empty)
 	u8 value, ret = true;
 
 	/* read one byte to check if E-Fuse is empty */
-	if (efuse_one_byte_rw(padapter, true, 0, &value) == true) {
+	if (efuse_one_byte_rw(padapter, true, 0, &value)) {
 		if (0xFF == value)
 			*empty = true;
 		else
@@ -250,8 +250,7 @@ u8 r8712_efuse_pg_packet_read(struct _adapter *padapter, u8 offset, u8 *data)
 		return false;
 	memset(data, 0xFF, sizeof(u8)*PGPKT_DATA_SIZE);
 	while (efuse_addr < efuse_available_max_size) {
-		if (efuse_one_byte_read(padapter, efuse_addr, &efuse_data) ==
-		    true) {
+		if (efuse_one_byte_read(padapter, efuse_addr, &efuse_data)) {
 			if (efuse_data == 0xFF)
 				break;
 			hoffset = (efuse_data >> 4) & 0x0F;
@@ -262,8 +261,7 @@ u8 r8712_efuse_pg_packet_read(struct _adapter *padapter, u8 offset, u8 *data)
 				for (tmpidx = 0; tmpidx < word_cnts * 2;
 				     tmpidx++) {
 					if (efuse_one_byte_read(padapter,
-					    efuse_addr+1+tmpidx, &efuse_data) ==
-					     true) {
+					    efuse_addr+1+tmpidx, &efuse_data)) {
 						tmpdata[tmpidx] = efuse_data;
 					} else
 						ret = false;
@@ -295,7 +293,7 @@ static u8 fix_header(struct _adapter *padapter, u8 header, u16 header_addr)
 	/* retrieve original data */
 	addr = 0;
 	while (addr < header_addr) {
-		if (efuse_one_byte_read(padapter, addr++, &value) == false) {
+		if (!efuse_one_byte_read(padapter, addr++, &value)) {
 			ret = false;
 			break;
 		}
@@ -310,14 +308,14 @@ static u8 fix_header(struct _adapter *padapter, u8 header, u16 header_addr)
 				if (BIT(i) & pkt.word_en) {
 					if (efuse_one_byte_read(
 							padapter, addr,
-							&value) == true)
+							&value))
 						pkt.data[i*2] = value;
 					else
 						return false;
 					if (efuse_one_byte_read(
 							padapter,
 							addr + 1,
-							&value) == true)
+							&value))
 						pkt.data[i*2 + 1] =
 							value;
 					else
@@ -337,8 +335,7 @@ static u8 fix_header(struct _adapter *padapter, u8 header, u16 header_addr)
 			efuse_one_byte_write(padapter, addr+1,
 					pkt.data[i*2 + 1]);
 			/* additional check */
-			if (efuse_one_byte_read(padapter, addr, &value)
-				== false)
+			if (!efuse_one_byte_read(padapter, addr, &value))
 				ret = false;
 			else if (pkt.data[i*2] != value) {
 				ret = false;
@@ -346,8 +343,7 @@ static u8 fix_header(struct _adapter *padapter, u8 header, u16 header_addr)
 					efuse_one_byte_write(padapter, addr,
 							pkt.data[i * 2]);
 			}
-			if (efuse_one_byte_read(padapter, addr+1, &value) ==
-				false)
+			if (!efuse_one_byte_read(padapter, addr+1, &value))
 				ret = false;
 			else if (pkt.data[i*2 + 1] != value) {
 				ret = false;
@@ -388,8 +384,8 @@ u8 r8712_efuse_pg_packet_write(struct _adapter *padapter, const u8 offset,
 		efuse_one_byte_write(padapter, efuse_addr, pg_header); /*hdr*/
 		sub_repeat = 0;
 		/* check if what we read is what we write */
-		while (efuse_one_byte_read(padapter, efuse_addr,
-					   &efuse_data) == false) {
+		while (!efuse_one_byte_read(padapter, efuse_addr,
+					    &efuse_data)) {
 			if (++sub_repeat > _REPEAT_THRESHOLD_) {
 				bResult = false; /* continue to blind write */
 				break; /* continue to blind write */
@@ -406,8 +402,9 @@ u8 r8712_efuse_pg_packet_write(struct _adapter *padapter, const u8 offset,
 				efuse_one_byte_write(padapter,
 						     efuse_addr + i,
 						     *(data + i));
-				if (efuse_one_byte_read(padapter,
-				    efuse_addr + i, &efuse_data) == false)
+				if (!efuse_one_byte_read(padapter,
+							 efuse_addr + i,
+							 &efuse_data))
 					bResult = false;
 				else if (*(data+i) != efuse_data) /* fail */
 					bResult = false;
@@ -437,10 +434,10 @@ u8 r8712_efuse_access(struct _adapter *padapter, u8 bRead, u16 start_addr,
 
 	if (start_addr > EFUSE_MAX_SIZE)
 		return false;
-	if ((bRead == false) && ((start_addr + cnts) >
+	if (!bRead && ((start_addr + cnts) >
 	   efuse_available_max_size))
 		return false;
-	if ((false == bRead) && (r8712_efuse_reg_init(padapter) == false))
+	if (!bRead && !r8712_efuse_reg_init(padapter))
 		return false;
 	/* -----------------e-fuse one byte read / write ---------------------*/
 	for (i = 0; i < cnts; i++) {
@@ -450,10 +447,10 @@ u8 r8712_efuse_access(struct _adapter *padapter, u8 bRead, u16 start_addr,
 		}
 		res = efuse_one_byte_rw(padapter, bRead, start_addr + i,
 		      data + i);
-		if ((false == bRead) && (false == res))
+		if (!bRead && !res)
 			break;
 	}
-	if (false == bRead)
+	if (!bRead)
 		r8712_efuse_reg_uninit(padapter);
 	return res;
 }
@@ -466,8 +463,7 @@ u8 r8712_efuse_map_read(struct _adapter *padapter, u16 addr, u16 cnts, u8 *data)
 
 	if ((addr + cnts) > EFUSE_MAP_MAX_SIZE)
 		return false;
-	if ((efuse_is_empty(padapter, &offset) == true) && (offset ==
-	     true)) {
+	if (efuse_is_empty(padapter, &offset) && offset) {
 		for (i = 0; i < cnts; i++)
 			data[i] = 0xFF;
 		return ret;
@@ -504,13 +500,13 @@ u8 r8712_efuse_map_write(struct _adapter *padapter, u16 addr, u16 cnts,
 	empty = r8712_read8(padapter, EFUSE_CLK_CTRL);
 	if (empty != 0x03)
 		return false;
-	if (efuse_is_empty(padapter, &empty) == true) {
-		if (true == empty)
+	if (efuse_is_empty(padapter, &empty)) {
+		if (empty)
 			memset(pktdata, 0xFF, PGPKT_DATA_SIZE);
 	} else
 		return false;
 	offset = (addr >> 3) & 0xF;
-	if (empty == false)
+	if (!empty)
 		if (!r8712_efuse_pg_packet_read(padapter, offset, pktdata))
 			return false;
 	word_en = 0xF;
@@ -554,13 +550,13 @@ u8 r8712_efuse_map_write(struct _adapter *padapter, u16 addr, u16 cnts,
 		}
 
 		if (word_en != 0xF)
-			if (r8712_efuse_pg_packet_write(padapter, offset,
-			    word_en, newdata) == false)
+			if (!r8712_efuse_pg_packet_write(padapter, offset,
+							 word_en, newdata))
 				return false;
 		if (idx == cnts)
 			break;
 		offset++;
-		if (empty == false)
+		if (!empty)
 			if (!r8712_efuse_pg_packet_read(padapter, offset,
 			    pktdata))
 				return false;

commit e29d3ebcda3ebc0193fb98c53c6c3ca6fa2fc030
Author: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
Date:   Mon Oct 27 17:42:25 2014 +0530

    staging: rtl8712: remove unused variables
    
    unused variables are removed. These variables were only assigned some
    values and after that they were never being used. So they are safe to
    be removed , and it has been build tested.
    
    I left a call to r8712_read32(padapter, TCR) and
    r8712_read8(padapter, SDIO_HCPWM) .
    
    r8712_read32() and r8712_read8() is ultimately calling usb_read32()
    and usb_read8() respectively. and they are again calling
    r8712_usbctrl_vendorreq().
    this r8712_usbctrl_vendorreq() is communicating through the usb bus
    and is sending and receiving the control msg.
    
    Signed-off-by: Sudip Mukherjee <sudip@vectorindia.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8712/rtl8712_efuse.c b/drivers/staging/rtl8712/rtl8712_efuse.c
index 97b78392e6c8..d95716999498 100644
--- a/drivers/staging/rtl8712/rtl8712_efuse.c
+++ b/drivers/staging/rtl8712/rtl8712_efuse.c
@@ -219,13 +219,12 @@ u16 r8712_efuse_get_current_size(struct _adapter *padapter)
 {
 	int bContinual = true;
 	u16 efuse_addr = 0;
-	u8 hoffset = 0, hworden = 0;
+	u8 hworden = 0;
 	u8 efuse_data, word_cnts = 0;
 
 	while (bContinual && efuse_one_byte_read(padapter, efuse_addr,
 	       &efuse_data) && (efuse_addr < efuse_available_max_size)) {
 		if (efuse_data != 0xFF) {
-			hoffset = (efuse_data >> 4) & 0x0F;
 			hworden =  efuse_data & 0x0F;
 			word_cnts = calculate_word_cnts(hworden);
 			/* read next header */

commit a15522c0a4208ce076f093668e9658a7b08c20b1
Author: Serguey Parkhomovsky <xindigo@gmail.com>
Date:   Tue Oct 7 20:42:45 2014 -0700

    staging: rtl8712: fix unnecessary elses after return/break in rtl8712_efuse.c
    
    This patch fixes two unnecessary else conditions that were found by checkpatch.pl.
    
    Signed-off-by: Serguey Parkhomovsky <sergueyparkhomovsky@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8712/rtl8712_efuse.c b/drivers/staging/rtl8712/rtl8712_efuse.c
index c9eeb4270ab9..97b78392e6c8 100644
--- a/drivers/staging/rtl8712/rtl8712_efuse.c
+++ b/drivers/staging/rtl8712/rtl8712_efuse.c
@@ -414,19 +414,18 @@ u8 r8712_efuse_pg_packet_write(struct _adapter *padapter, const u8 offset,
 					bResult = false;
 			}
 			break;
-		} else { /* write header fail */
-			bResult = false;
-			if (0xFF == efuse_data)
-				return bResult; /* nothing damaged. */
-			/* call rescue procedure */
-			if (fix_header(padapter, efuse_data, efuse_addr) ==
-			    false)
-				return false; /* rescue fail */
-
-			if (++repeat_times > _REPEAT_THRESHOLD_) /* fail */
-				break;
-			/* otherwise, take another risk... */
 		}
+		/* write header fail */
+		bResult = false;
+		if (0xFF == efuse_data)
+			return bResult; /* nothing damaged. */
+		/* call rescue procedure */
+		if (!fix_header(padapter, efuse_data, efuse_addr))
+			return false; /* rescue fail */
+
+		if (++repeat_times > _REPEAT_THRESHOLD_) /* fail */
+			break;
+		/* otherwise, take another risk... */
 	}
 	return bResult;
 }
@@ -541,15 +540,16 @@ u8 r8712_efuse_map_write(struct _adapter *padapter, u16 addr, u16 cnts,
 				}
 				idx++;
 				break;
-			} else {
-				if ((data[idx] != pktdata[i]) || (data[idx+1] !=
-				     pktdata[i+1])) {
-					word_en &= ~BIT(i >> 1);
-					newdata[j++] = data[idx];
-					newdata[j++] = data[idx + 1];
-				}
-				idx += 2;
 			}
+
+			if ((data[idx] != pktdata[i]) || (data[idx+1] !=
+			     pktdata[i+1])) {
+				word_en &= ~BIT(i >> 1);
+				newdata[j++] = data[idx];
+				newdata[j++] = data[idx + 1];
+			}
+			idx += 2;
+
 			if (idx == cnts)
 				break;
 		}

commit 77e73e8c90aded3215ecb4d05b9c91ec94349b61
Author: Thomas Cort <linuxgeek@gmail.com>
Date:   Tue Oct 1 11:26:55 2013 -0400

    Staging: rtl8712: fix spaces before semicolons
    
    Resolve all of the 'WARNING: space prohibited before semicolon'
    checkpatch warnings for rtl8712.
    
    Signed-off-by: Thomas Cort <linuxgeek@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8712/rtl8712_efuse.c b/drivers/staging/rtl8712/rtl8712_efuse.c
index 377fca905801..c9eeb4270ab9 100644
--- a/drivers/staging/rtl8712/rtl8712_efuse.c
+++ b/drivers/staging/rtl8712/rtl8712_efuse.c
@@ -231,7 +231,7 @@ u16 r8712_efuse_get_current_size(struct _adapter *padapter)
 			/* read next header */
 			efuse_addr = efuse_addr + (word_cnts * 2) + 1;
 		} else
-			bContinual = false ;
+			bContinual = false;
 	}
 	return efuse_addr;
 }

commit be10ac2b961e348919ce09d2b88471116d865087
Author: Justin P. Mattock <justinmattock@gmail.com>
Date:   Mon May 7 07:38:22 2012 -0700

    staging: rtl8712: Fix typos.
    
    Signed-off-by: Justin P. Mattock <justinmattock@gmail.com>
    Acked-by: Larry Finger <Larry.Finger@lwfinger.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8712/rtl8712_efuse.c b/drivers/staging/rtl8712/rtl8712_efuse.c
index b08e9a25c9c5..377fca905801 100644
--- a/drivers/staging/rtl8712/rtl8712_efuse.c
+++ b/drivers/staging/rtl8712/rtl8712_efuse.c
@@ -417,7 +417,7 @@ u8 r8712_efuse_pg_packet_write(struct _adapter *padapter, const u8 offset,
 		} else { /* write header fail */
 			bResult = false;
 			if (0xFF == efuse_data)
-				return bResult; /* not thing damaged. */
+				return bResult; /* nothing damaged. */
 			/* call rescue procedure */
 			if (fix_header(padapter, efuse_data, efuse_addr) ==
 			    false)

commit 0aeb623d376c05a8618bf10418b9a0cb2b43e944
Author: Ali Bahar <ali@internetdog.org>
Date:   Sun Sep 4 03:14:17 2011 +0800

    staging: r8712u: Merging Realtek's latest (v2.6.6). Rework efuse data handling.
    
    Rework efuse data handling.
    
    Signed-off-by: Ali Bahar <ali@internetDog.org>
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/rtl8712/rtl8712_efuse.c b/drivers/staging/rtl8712/rtl8712_efuse.c
index 1dc12b7a2f52..b08e9a25c9c5 100644
--- a/drivers/staging/rtl8712/rtl8712_efuse.c
+++ b/drivers/staging/rtl8712/rtl8712_efuse.c
@@ -307,21 +307,25 @@ static u8 fix_header(struct _adapter *padapter, u8 header, u16 header_addr)
 			continue;
 		}
 		for (i = 0; i < PGPKG_MAX_WORDS; i++) {
-			if (BIT(i) & word_en)
-				continue;
-			if (!(BIT(i) & pkt.word_en)) {
-				if (efuse_one_byte_read(padapter, addr,
-				    &value) == true)
-					pkt.data[i*2] = value;
-				else
-					return false;
-				if (efuse_one_byte_read(padapter, addr + 1,
-				    &value) == true)
-					pkt.data[i*2 + 1] = value;
-				else
-					return false;
+			if (BIT(i) & word_en) {
+				if (BIT(i) & pkt.word_en) {
+					if (efuse_one_byte_read(
+							padapter, addr,
+							&value) == true)
+						pkt.data[i*2] = value;
+					else
+						return false;
+					if (efuse_one_byte_read(
+							padapter,
+							addr + 1,
+							&value) == true)
+						pkt.data[i*2 + 1] =
+							value;
+					else
+						return false;
+				}
+				addr += 2;
 			}
-			addr += 2;
 		}
 	}
 	if (addr != header_addr)
@@ -329,26 +333,29 @@ static u8 fix_header(struct _adapter *padapter, u8 header, u16 header_addr)
 	addr++;
 	/* fill original data */
 	for (i = 0; i < PGPKG_MAX_WORDS; i++) {
-		if (BIT(i) & pkt.word_en)
-			continue;
-		efuse_one_byte_write(padapter, addr, pkt.data[i*2]);
-		efuse_one_byte_write(padapter, addr+1, pkt.data[i*2 + 1]);
-		/* additional check */
-		if (efuse_one_byte_read(padapter, addr, &value) == false)
-			ret = false;
-		else if (pkt.data[i*2] != value) {
-			ret = false;
-			if (0xFF == value) /* write again */
-				efuse_one_byte_write(padapter, addr,
-						     pkt.data[i * 2]);
-		}
-		if (efuse_one_byte_read(padapter, addr+1, &value) == false)
-			ret = false;
-		else if (pkt.data[i*2 + 1] != value) {
-			ret = false;
-			if (0xFF == value) /* write again */
-				efuse_one_byte_write(padapter, addr+1,
-						     pkt.data[i*2 + 1]);
+		if (BIT(i) & pkt.word_en) {
+			efuse_one_byte_write(padapter, addr, pkt.data[i*2]);
+			efuse_one_byte_write(padapter, addr+1,
+					pkt.data[i*2 + 1]);
+			/* additional check */
+			if (efuse_one_byte_read(padapter, addr, &value)
+				== false)
+				ret = false;
+			else if (pkt.data[i*2] != value) {
+				ret = false;
+				if (0xFF == value) /* write again */
+					efuse_one_byte_write(padapter, addr,
+							pkt.data[i * 2]);
+			}
+			if (efuse_one_byte_read(padapter, addr+1, &value) ==
+				false)
+				ret = false;
+			else if (pkt.data[i*2 + 1] != value) {
+				ret = false;
+				if (0xFF == value) /* write again */
+					efuse_one_byte_write(padapter, addr+1,
+							pkt.data[i*2 + 1]);
+			}
 		}
 		addr += 2;
 	}

commit 859171ca92f2865453b4b2e17bf679c67044a833
Author: Joe Perches <joe@perches.com>
Date:   Sun Nov 14 19:04:48 2010 -0800

    drivers/staging: Remove unnecessary semicolons
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/rtl8712/rtl8712_efuse.c b/drivers/staging/rtl8712/rtl8712_efuse.c
index 9730ae1c58d5..1dc12b7a2f52 100644
--- a/drivers/staging/rtl8712/rtl8712_efuse.c
+++ b/drivers/staging/rtl8712/rtl8712_efuse.c
@@ -428,7 +428,7 @@ u8 r8712_efuse_access(struct _adapter *padapter, u8 bRead, u16 start_addr,
 		      u16 cnts, u8 *data)
 {
 	int i;
-	u8 res = true;;
+	u8 res = true;
 
 	if (start_addr > EFUSE_MAX_SIZE)
 		return false;

commit 2865d42c78a9121caad52cb02d1fbb7f5cdbc4ef
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Fri Aug 20 10:15:30 2010 -0500

    staging: r8712u: Add the new driver to the mainline kernel
    
    This code is for a completely new version of the Realtek 8192 USB devices
    such as the D-Link DWA-130. The Realtek code, which was originally for
    Linux, Windows XP and Windows CE, has been stripped of all code not needed
    for Linux. In addition, only one additional configuration variable, which
    enables AP mode, remains.
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
    Signed-off-by: Florian Schilhabel <florian.c.schilhabel@googlemail.com>
    Tested-by: Frederic Leroy <fredo@starox.org>

diff --git a/drivers/staging/rtl8712/rtl8712_efuse.c b/drivers/staging/rtl8712/rtl8712_efuse.c
new file mode 100644
index 000000000000..9730ae1c58d5
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl8712_efuse.c
@@ -0,0 +1,568 @@
+/*
+ * rtl8712_efuse.c
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ * Linux device driver for RTL8192SU
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>.
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+
+#define _RTL8712_EFUSE_C_
+
+#include "osdep_service.h"
+#include "drv_types.h"
+#include "rtl8712_efuse.h"
+
+/* reserve 3 bytes for HW stop read */
+static int efuse_available_max_size = EFUSE_MAX_SIZE - 3 /*0x1FD*/;
+
+static void efuse_reg_ctrl(struct _adapter *padapter, u8 bPowerOn)
+{
+	u8 tmpu8 = 0;
+
+	if (true == bPowerOn) {
+		/* -----------------e-fuse pwr & clk reg ctrl ---------------
+		 * Enable LDOE25 Macro Block
+		 */
+		tmpu8 = r8712_read8(padapter, EFUSE_TEST + 3);
+		tmpu8 |= 0x80;
+		r8712_write8(padapter, EFUSE_TEST + 3, tmpu8);
+		msleep(20); /* for some platform , need some delay time */
+		/* Change Efuse Clock for write action to 40MHZ */
+		r8712_write8(padapter, EFUSE_CLK_CTRL, 0x03);
+		msleep(20); /* for some platform , need some delay time */
+	} else {
+		/* -----------------e-fuse pwr & clk reg ctrl -----------------
+		 * Disable LDOE25 Macro Block
+		 */
+		tmpu8 = r8712_read8(padapter, EFUSE_TEST + 3);
+		tmpu8 &= 0x7F;
+		r8712_write8(padapter, EFUSE_TEST + 3, tmpu8);
+		/* Change Efuse Clock for write action to 500K */
+		r8712_write8(padapter, EFUSE_CLK_CTRL, 0x02);
+	}
+}
+
+/*
+ * Before write E-Fuse, this function must be called.
+ */
+u8 r8712_efuse_reg_init(struct _adapter *padapter)
+{
+	return true;
+}
+
+void r8712_efuse_reg_uninit(struct _adapter *padapter)
+{
+	efuse_reg_ctrl(padapter, false);
+}
+
+static u8 efuse_one_byte_read(struct _adapter *padapter, u16 addr, u8 *data)
+{
+	u8 tmpidx = 0, bResult;
+
+	/* -----------------e-fuse reg ctrl --------------------------------- */
+	r8712_write8(padapter, EFUSE_CTRL+1, (u8)(addr&0xFF)); /* address */
+	r8712_write8(padapter, EFUSE_CTRL+2, ((u8)((addr>>8)&0x03)) |
+	       (r8712_read8(padapter, EFUSE_CTRL+2)&0xFC));
+	r8712_write8(padapter, EFUSE_CTRL+3, 0x72); /* read cmd */
+	/* wait for complete */
+	while (!(0x80 & r8712_read8(padapter, EFUSE_CTRL+3)) && (tmpidx < 100))
+		tmpidx++;
+	if (tmpidx < 100) {
+		*data = r8712_read8(padapter, EFUSE_CTRL);
+		bResult = true;
+	} else {
+		*data = 0xff;
+		bResult = false;
+	}
+	return bResult;
+}
+
+static u8 efuse_one_byte_write(struct _adapter *padapter, u16 addr, u8 data)
+{
+	u8 tmpidx = 0, bResult;
+
+	/* -----------------e-fuse reg ctrl -------------------------------- */
+	r8712_write8(padapter, EFUSE_CTRL+1, (u8)(addr&0xFF)); /* address */
+	r8712_write8(padapter, EFUSE_CTRL+2, ((u8)((addr>>8)&0x03)) |
+	       (r8712_read8(padapter, EFUSE_CTRL+2)&0xFC));
+	r8712_write8(padapter, EFUSE_CTRL, data); /* data */
+	r8712_write8(padapter, EFUSE_CTRL+3, 0xF2); /* write cmd */
+	/* wait for complete */
+	while ((0x80 &  r8712_read8(padapter, EFUSE_CTRL+3)) && (tmpidx < 100))
+		tmpidx++;
+	if (tmpidx < 100)
+		bResult = true;
+	else
+		bResult = false;
+	return bResult;
+}
+
+static u8 efuse_one_byte_rw(struct _adapter *padapter, u8 bRead, u16 addr,
+			    u8 *data)
+{
+	u8 tmpidx = 0, tmpv8 = 0, bResult;
+
+	/* -----------------e-fuse reg ctrl --------------------------------- */
+	r8712_write8(padapter, EFUSE_CTRL+1, (u8)(addr&0xFF)); /* address */
+	tmpv8 = ((u8)((addr >> 8) & 0x03)) |
+		 (r8712_read8(padapter, EFUSE_CTRL + 2) & 0xFC);
+	r8712_write8(padapter, EFUSE_CTRL+2, tmpv8);
+	if (true == bRead) {
+		r8712_write8(padapter, EFUSE_CTRL+3,  0x72); /* read cmd */
+		while (!(0x80 & r8712_read8(padapter, EFUSE_CTRL+3)) &&
+		       (tmpidx < 100))
+			tmpidx++;
+		if (tmpidx < 100) {
+			*data = r8712_read8(padapter, EFUSE_CTRL);
+			bResult = true;
+		} else {
+			*data = 0;
+			bResult = false;
+		}
+	} else {
+		r8712_write8(padapter, EFUSE_CTRL, *data); /* data */
+		r8712_write8(padapter, EFUSE_CTRL+3, 0xF2); /* write cmd */
+		while ((0x80 & r8712_read8(padapter, EFUSE_CTRL+3)) &&
+		       (tmpidx < 100))
+			tmpidx++;
+		if (tmpidx < 100)
+			bResult = true;
+		else
+			bResult = false;
+	}
+	return bResult;
+}
+
+static u8 efuse_is_empty(struct _adapter *padapter, u8 *empty)
+{
+	u8 value, ret = true;
+
+	/* read one byte to check if E-Fuse is empty */
+	if (efuse_one_byte_rw(padapter, true, 0, &value) == true) {
+		if (0xFF == value)
+			*empty = true;
+		else
+			*empty = false;
+	} else
+		ret = false;
+	return ret;
+}
+
+void r8712_efuse_change_max_size(struct _adapter *padapter)
+{
+	u16 pre_pg_data_saddr = 0x1FB;
+	u16 i;
+	u16 pre_pg_data_size = 5;
+	u8 pre_pg_data[5];
+
+	for (i = 0; i < pre_pg_data_size; i++)
+		efuse_one_byte_read(padapter, pre_pg_data_saddr + i,
+				    &pre_pg_data[i]);
+	if ((pre_pg_data[0] == 0x03) && (pre_pg_data[1] == 0x00) &&
+	    (pre_pg_data[2] == 0x00) && (pre_pg_data[3] == 0x00) &&
+	    (pre_pg_data[4] == 0x0C))
+		efuse_available_max_size -= pre_pg_data_size;
+}
+
+int r8712_efuse_get_max_size(struct _adapter *padapter)
+{
+	return	efuse_available_max_size;
+}
+
+static u8 calculate_word_cnts(const u8 word_en)
+{
+	u8 word_cnts = 0;
+	u8 word_idx;
+
+	for (word_idx = 0; word_idx < PGPKG_MAX_WORDS; word_idx++)
+		if (!(word_en & BIT(word_idx)))
+			word_cnts++; /* 0 : write enable */
+	return word_cnts;
+}
+
+static void pgpacket_copy_data(const u8 word_en, const u8 *sourdata,
+			       u8 *targetdata)
+{
+	u8 tmpindex = 0;
+	u8 word_idx, byte_idx;
+
+	for (word_idx = 0; word_idx < PGPKG_MAX_WORDS; word_idx++) {
+		if (!(word_en&BIT(word_idx))) {
+			byte_idx = word_idx * 2;
+			targetdata[byte_idx] = sourdata[tmpindex++];
+			targetdata[byte_idx + 1] = sourdata[tmpindex++];
+		}
+	}
+}
+
+u16 r8712_efuse_get_current_size(struct _adapter *padapter)
+{
+	int bContinual = true;
+	u16 efuse_addr = 0;
+	u8 hoffset = 0, hworden = 0;
+	u8 efuse_data, word_cnts = 0;
+
+	while (bContinual && efuse_one_byte_read(padapter, efuse_addr,
+	       &efuse_data) && (efuse_addr < efuse_available_max_size)) {
+		if (efuse_data != 0xFF) {
+			hoffset = (efuse_data >> 4) & 0x0F;
+			hworden =  efuse_data & 0x0F;
+			word_cnts = calculate_word_cnts(hworden);
+			/* read next header */
+			efuse_addr = efuse_addr + (word_cnts * 2) + 1;
+		} else
+			bContinual = false ;
+	}
+	return efuse_addr;
+}
+
+u8 r8712_efuse_pg_packet_read(struct _adapter *padapter, u8 offset, u8 *data)
+{
+	u8 hoffset = 0, hworden = 0, word_cnts = 0;
+	u16 efuse_addr = 0;
+	u8 efuse_data;
+	u8 tmpidx = 0;
+	u8 tmpdata[PGPKT_DATA_SIZE];
+	u8 ret = true;
+
+	if (data == NULL)
+		return false;
+	if (offset > 0x0f)
+		return false;
+	memset(data, 0xFF, sizeof(u8)*PGPKT_DATA_SIZE);
+	while (efuse_addr < efuse_available_max_size) {
+		if (efuse_one_byte_read(padapter, efuse_addr, &efuse_data) ==
+		    true) {
+			if (efuse_data == 0xFF)
+				break;
+			hoffset = (efuse_data >> 4) & 0x0F;
+			hworden =  efuse_data & 0x0F;
+			word_cnts = calculate_word_cnts(hworden);
+			if (hoffset == offset) {
+				memset(tmpdata, 0xFF, PGPKT_DATA_SIZE);
+				for (tmpidx = 0; tmpidx < word_cnts * 2;
+				     tmpidx++) {
+					if (efuse_one_byte_read(padapter,
+					    efuse_addr+1+tmpidx, &efuse_data) ==
+					     true) {
+						tmpdata[tmpidx] = efuse_data;
+					} else
+						ret = false;
+				}
+				pgpacket_copy_data(hworden, tmpdata, data);
+			}
+			efuse_addr += 1 + (word_cnts*2);
+		} else {
+			ret = false;
+			break;
+		}
+	}
+	return ret;
+}
+
+static u8 fix_header(struct _adapter *padapter, u8 header, u16 header_addr)
+{
+	struct PGPKT_STRUCT pkt;
+	u8 offset, word_en, value;
+	u16 addr;
+	int i;
+	u8 ret = true;
+
+	pkt.offset = GET_EFUSE_OFFSET(header);
+	pkt.word_en = GET_EFUSE_WORD_EN(header);
+	addr = header_addr + 1 + calculate_word_cnts(pkt.word_en) * 2;
+	if (addr > efuse_available_max_size)
+		return false;
+	/* retrieve original data */
+	addr = 0;
+	while (addr < header_addr) {
+		if (efuse_one_byte_read(padapter, addr++, &value) == false) {
+			ret = false;
+			break;
+		}
+		offset = GET_EFUSE_OFFSET(value);
+		word_en = GET_EFUSE_WORD_EN(value);
+		if (pkt.offset != offset) {
+			addr += calculate_word_cnts(word_en)*2;
+			continue;
+		}
+		for (i = 0; i < PGPKG_MAX_WORDS; i++) {
+			if (BIT(i) & word_en)
+				continue;
+			if (!(BIT(i) & pkt.word_en)) {
+				if (efuse_one_byte_read(padapter, addr,
+				    &value) == true)
+					pkt.data[i*2] = value;
+				else
+					return false;
+				if (efuse_one_byte_read(padapter, addr + 1,
+				    &value) == true)
+					pkt.data[i*2 + 1] = value;
+				else
+					return false;
+			}
+			addr += 2;
+		}
+	}
+	if (addr != header_addr)
+		return false;
+	addr++;
+	/* fill original data */
+	for (i = 0; i < PGPKG_MAX_WORDS; i++) {
+		if (BIT(i) & pkt.word_en)
+			continue;
+		efuse_one_byte_write(padapter, addr, pkt.data[i*2]);
+		efuse_one_byte_write(padapter, addr+1, pkt.data[i*2 + 1]);
+		/* additional check */
+		if (efuse_one_byte_read(padapter, addr, &value) == false)
+			ret = false;
+		else if (pkt.data[i*2] != value) {
+			ret = false;
+			if (0xFF == value) /* write again */
+				efuse_one_byte_write(padapter, addr,
+						     pkt.data[i * 2]);
+		}
+		if (efuse_one_byte_read(padapter, addr+1, &value) == false)
+			ret = false;
+		else if (pkt.data[i*2 + 1] != value) {
+			ret = false;
+			if (0xFF == value) /* write again */
+				efuse_one_byte_write(padapter, addr+1,
+						     pkt.data[i*2 + 1]);
+		}
+		addr += 2;
+	}
+	return ret;
+}
+
+u8 r8712_efuse_pg_packet_write(struct _adapter *padapter, const u8 offset,
+			 const u8 word_en, const u8 *data)
+{
+	u8 pg_header = 0;
+	u16 efuse_addr = 0, curr_size = 0;
+	u8 efuse_data, target_word_cnts = 0;
+	static int repeat_times;
+	int sub_repeat;
+	u8 bResult = true;
+
+	/* check if E-Fuse Clock Enable and E-Fuse Clock is 40M */
+	efuse_data = r8712_read8(padapter, EFUSE_CLK_CTRL);
+	if (efuse_data != 0x03)
+		return false;
+	pg_header = MAKE_EFUSE_HEADER(offset, word_en);
+	target_word_cnts = calculate_word_cnts(word_en);
+	repeat_times = 0;
+	efuse_addr = 0;
+	while (efuse_addr < efuse_available_max_size) {
+		curr_size = r8712_efuse_get_current_size(padapter);
+		if ((curr_size + 1 + target_word_cnts * 2) >
+		     efuse_available_max_size)
+			return false; /*target_word_cnts + pg header(1 byte)*/
+		efuse_addr = curr_size; /* current size is also the last addr*/
+		efuse_one_byte_write(padapter, efuse_addr, pg_header); /*hdr*/
+		sub_repeat = 0;
+		/* check if what we read is what we write */
+		while (efuse_one_byte_read(padapter, efuse_addr,
+					   &efuse_data) == false) {
+			if (++sub_repeat > _REPEAT_THRESHOLD_) {
+				bResult = false; /* continue to blind write */
+				break; /* continue to blind write */
+			}
+		}
+		if ((sub_repeat > _REPEAT_THRESHOLD_) ||
+		    (pg_header == efuse_data)) {
+			/* write header ok OR can't check header(creep) */
+			u8 i;
+
+			/* go to next address */
+			efuse_addr++;
+			for (i = 0; i < target_word_cnts*2; i++) {
+				efuse_one_byte_write(padapter,
+						     efuse_addr + i,
+						     *(data + i));
+				if (efuse_one_byte_read(padapter,
+				    efuse_addr + i, &efuse_data) == false)
+					bResult = false;
+				else if (*(data+i) != efuse_data) /* fail */
+					bResult = false;
+			}
+			break;
+		} else { /* write header fail */
+			bResult = false;
+			if (0xFF == efuse_data)
+				return bResult; /* not thing damaged. */
+			/* call rescue procedure */
+			if (fix_header(padapter, efuse_data, efuse_addr) ==
+			    false)
+				return false; /* rescue fail */
+
+			if (++repeat_times > _REPEAT_THRESHOLD_) /* fail */
+				break;
+			/* otherwise, take another risk... */
+		}
+	}
+	return bResult;
+}
+
+u8 r8712_efuse_access(struct _adapter *padapter, u8 bRead, u16 start_addr,
+		      u16 cnts, u8 *data)
+{
+	int i;
+	u8 res = true;;
+
+	if (start_addr > EFUSE_MAX_SIZE)
+		return false;
+	if ((bRead == false) && ((start_addr + cnts) >
+	   efuse_available_max_size))
+		return false;
+	if ((false == bRead) && (r8712_efuse_reg_init(padapter) == false))
+		return false;
+	/* -----------------e-fuse one byte read / write ---------------------*/
+	for (i = 0; i < cnts; i++) {
+		if ((start_addr + i) > EFUSE_MAX_SIZE) {
+			res = false;
+			break;
+		}
+		res = efuse_one_byte_rw(padapter, bRead, start_addr + i,
+		      data + i);
+		if ((false == bRead) && (false == res))
+			break;
+	}
+	if (false == bRead)
+		r8712_efuse_reg_uninit(padapter);
+	return res;
+}
+
+u8 r8712_efuse_map_read(struct _adapter *padapter, u16 addr, u16 cnts, u8 *data)
+{
+	u8 offset, ret = true;
+	u8 pktdata[PGPKT_DATA_SIZE];
+	int i, idx;
+
+	if ((addr + cnts) > EFUSE_MAP_MAX_SIZE)
+		return false;
+	if ((efuse_is_empty(padapter, &offset) == true) && (offset ==
+	     true)) {
+		for (i = 0; i < cnts; i++)
+			data[i] = 0xFF;
+		return ret;
+	}
+	offset = (addr >> 3) & 0xF;
+	ret = r8712_efuse_pg_packet_read(padapter, offset, pktdata);
+	i = addr & 0x7;	/* pktdata index */
+	idx = 0;	/* data index */
+
+	do {
+		for (; i < PGPKT_DATA_SIZE; i++) {
+			data[idx++] = pktdata[i];
+			if (idx == cnts)
+				return ret;
+		}
+		offset++;
+		if (!r8712_efuse_pg_packet_read(padapter, offset, pktdata))
+			ret = false;
+		i = 0;
+	} while (1);
+	return ret;
+}
+
+u8 r8712_efuse_map_write(struct _adapter *padapter, u16 addr, u16 cnts,
+			 u8 *data)
+{
+	u8 offset, word_en, empty;
+	u8 pktdata[PGPKT_DATA_SIZE], newdata[PGPKT_DATA_SIZE];
+	int i, j, idx;
+
+	if ((addr + cnts) > EFUSE_MAP_MAX_SIZE)
+		return false;
+	/* check if E-Fuse Clock Enable and E-Fuse Clock is 40M */
+	empty = r8712_read8(padapter, EFUSE_CLK_CTRL);
+	if (empty != 0x03)
+		return false;
+	if (efuse_is_empty(padapter, &empty) == true) {
+		if (true == empty)
+			memset(pktdata, 0xFF, PGPKT_DATA_SIZE);
+	} else
+		return false;
+	offset = (addr >> 3) & 0xF;
+	if (empty == false)
+		if (!r8712_efuse_pg_packet_read(padapter, offset, pktdata))
+			return false;
+	word_en = 0xF;
+	memset(newdata, 0xFF, PGPKT_DATA_SIZE);
+	i = addr & 0x7;	/* pktdata index */
+	j = 0;		/* newdata index */
+	idx = 0;	/* data index */
+
+	if (i & 0x1) {
+		/*  odd start */
+		if (data[idx] != pktdata[i]) {
+			word_en &= ~BIT(i >> 1);
+			newdata[j++] = pktdata[i - 1];
+			newdata[j++] = data[idx];
+		}
+		i++;
+		idx++;
+	}
+	do {
+		for (; i < PGPKT_DATA_SIZE; i += 2) {
+			if ((cnts - idx) == 1) {
+				if (data[idx] != pktdata[i]) {
+					word_en &= ~BIT(i >> 1);
+					newdata[j++] = data[idx];
+					newdata[j++] = pktdata[1 + 1];
+				}
+				idx++;
+				break;
+			} else {
+				if ((data[idx] != pktdata[i]) || (data[idx+1] !=
+				     pktdata[i+1])) {
+					word_en &= ~BIT(i >> 1);
+					newdata[j++] = data[idx];
+					newdata[j++] = data[idx + 1];
+				}
+				idx += 2;
+			}
+			if (idx == cnts)
+				break;
+		}
+
+		if (word_en != 0xF)
+			if (r8712_efuse_pg_packet_write(padapter, offset,
+			    word_en, newdata) == false)
+				return false;
+		if (idx == cnts)
+			break;
+		offset++;
+		if (empty == false)
+			if (!r8712_efuse_pg_packet_read(padapter, offset,
+			    pktdata))
+				return false;
+		i = 0;
+		j = 0;
+		word_en = 0xF;
+		memset(newdata, 0xFF, PGPKT_DATA_SIZE);
+	} while (1);
+
+	return true;
+}
