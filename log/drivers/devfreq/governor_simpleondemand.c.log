commit 3a1ec2e8d8a9f5535f11dd3772a212434743e4f2
Author: Chanwoo Choi <cw00.choi@samsung.com>
Date:   Wed Jan 29 13:24:18 2020 +0900

    PM / devfreq: Change to DEVFREQ_GOV_UPDATE_INTERVAL event name
    
    DEVFREQ_GOV_INTERVAL event indicates that update the interval
    for polling mode of devfreq device. But, this event name doesn't
    specify exactly what to do.
    
    Change DEVFREQ_GOV_INTERVAL event name to DEVFREQ_GOV_UPDATE_INTERVAL
    which specifies what to do by event name.
    
    And modify the function name to DEVFREQ_GOV_UPDATE_INTERVAL
    with 'devfreq_' prefix + verb + object as following:
    - devfreq_interval_update -> devfreq_updatee_interval
    
    Reviewed-by: Lukasz Luba <lukasz.luba@arm.com>
    Signed-off-by: Chanwoo Choi <cw00.choi@samsung.com>

diff --git a/drivers/devfreq/governor_simpleondemand.c b/drivers/devfreq/governor_simpleondemand.c
index 3d809f228619..1b314e1df028 100644
--- a/drivers/devfreq/governor_simpleondemand.c
+++ b/drivers/devfreq/governor_simpleondemand.c
@@ -96,8 +96,8 @@ static int devfreq_simple_ondemand_handler(struct devfreq *devfreq,
 		devfreq_monitor_stop(devfreq);
 		break;
 
-	case DEVFREQ_GOV_INTERVAL:
-		devfreq_interval_update(devfreq, (unsigned int *)data);
+	case DEVFREQ_GOV_UPDATE_INTERVAL:
+		devfreq_update_interval(devfreq, (unsigned int *)data);
 		break;
 
 	case DEVFREQ_GOV_SUSPEND:

commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/devfreq/governor_simpleondemand.c b/drivers/devfreq/governor_simpleondemand.c
index c0417f0e081e..3d809f228619 100644
--- a/drivers/devfreq/governor_simpleondemand.c
+++ b/drivers/devfreq/governor_simpleondemand.c
@@ -1,12 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  *  linux/drivers/devfreq/governor_simpleondemand.c
  *
  *  Copyright (C) 2011 Samsung Electronics
  *	MyungJoo Ham <myungjoo.ham@samsung.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 
 #include <linux/errno.h>

commit 6ff66e2a008337b8a005fd0ae2037bed716262cc
Author: Matthias Kaehlcke <mka@chromium.org>
Date:   Fri Aug 3 13:05:10 2018 -0700

    PM / devfreq: Don't adjust to user limits in governors
    
    Several governors use the user space limits df->min/max_freq to adjust
    the target frequency. This is not necessary, since update_devfreq()
    already takes care of this. Instead the governor can request the available
    min/max frequency by setting the target frequency to DEVFREQ_MIN/MAX_FREQ
    and let update_devfreq() take care of any adjustments.
    
    Signed-off-by: Matthias Kaehlcke <mka@chromium.org>
    Reviewed-by: Brian Norris <briannorris@chromium.org>
    Reviewed-by: Chanwoo Choi <cw00.choi@samsung.com>
    Signed-off-by: MyungJoo Ham <myungjoo.ham@samsung.com>

diff --git a/drivers/devfreq/governor_simpleondemand.c b/drivers/devfreq/governor_simpleondemand.c
index 28e0f2de7100..c0417f0e081e 100644
--- a/drivers/devfreq/governor_simpleondemand.c
+++ b/drivers/devfreq/governor_simpleondemand.c
@@ -27,7 +27,6 @@ static int devfreq_simple_ondemand_func(struct devfreq *df,
 	unsigned int dfso_upthreshold = DFSO_UPTHRESHOLD;
 	unsigned int dfso_downdifferential = DFSO_DOWNDIFFERENCTIAL;
 	struct devfreq_simple_ondemand_data *data = df->data;
-	unsigned long max = (df->max_freq) ? df->max_freq : UINT_MAX;
 
 	err = devfreq_update_stats(df);
 	if (err)
@@ -47,7 +46,7 @@ static int devfreq_simple_ondemand_func(struct devfreq *df,
 
 	/* Assume MAX if it is going to be divided by zero */
 	if (stat->total_time == 0) {
-		*freq = max;
+		*freq = DEVFREQ_MAX_FREQ;
 		return 0;
 	}
 
@@ -60,13 +59,13 @@ static int devfreq_simple_ondemand_func(struct devfreq *df,
 	/* Set MAX if it's busy enough */
 	if (stat->busy_time * 100 >
 	    stat->total_time * dfso_upthreshold) {
-		*freq = max;
+		*freq = DEVFREQ_MAX_FREQ;
 		return 0;
 	}
 
 	/* Set MAX if we do not know the initial frequency */
 	if (stat->current_frequency == 0) {
-		*freq = max;
+		*freq = DEVFREQ_MAX_FREQ;
 		return 0;
 	}
 
@@ -85,11 +84,6 @@ static int devfreq_simple_ondemand_func(struct devfreq *df,
 	b = div_u64(b, (dfso_upthreshold - dfso_downdifferential / 2));
 	*freq = (unsigned long) b;
 
-	if (df->min_freq && *freq < df->min_freq)
-		*freq = df->min_freq;
-	if (df->max_freq && *freq > df->max_freq)
-		*freq = df->max_freq;
-
 	return 0;
 }
 

commit aa7c352f9841ab3fee5bf1de127a45e6310124a6
Author: Chanwoo Choi <cw00.choi@samsung.com>
Date:   Mon Oct 23 10:32:12 2017 +0900

    PM / devfreq: Define the constant governor name
    
    Prior to that, the devfreq device uses the governor name when adding
    the itself. In order to prevent the mistake used the wrong governor name,
    this patch defines the governor name as a constant and then uses them
    instead of using the string directly.
    
    Signed-off-by: Chanwoo Choi <cw00.choi@samsung.com>
    Signed-off-by: MyungJoo Ham <myungjoo.ham@samsung.com>
    Cc: Kukjin Kim <kgene@kernel.org>
    Cc: Krzysztof Kozlowski <krzk@kernel.org>
    Cc: linux-samsung-soc@vger.kernel.org
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: linux-kernel@vger.kernel.org

diff --git a/drivers/devfreq/governor_simpleondemand.c b/drivers/devfreq/governor_simpleondemand.c
index ae72ba5e78df..28e0f2de7100 100644
--- a/drivers/devfreq/governor_simpleondemand.c
+++ b/drivers/devfreq/governor_simpleondemand.c
@@ -125,7 +125,7 @@ static int devfreq_simple_ondemand_handler(struct devfreq *devfreq,
 }
 
 static struct devfreq_governor devfreq_simple_ondemand = {
-	.name = "simple_ondemand",
+	.name = DEVFREQ_GOV_SIMPLE_ONDEMAND,
 	.get_target_freq = devfreq_simple_ondemand_func,
 	.event_handler = devfreq_simple_ondemand_handler,
 };

commit 08e75e754a6d9838e490b74551d19fc04d0fd6f9
Author: Javi Merino <javi.merino@arm.com>
Date:   Fri Aug 14 18:56:56 2015 +0100

    PM / devfreq: cache the last call to get_dev_status()
    
    The return value of get_dev_status() can be reused.  Cache it so that
    other parts of the kernel can reuse it instead of having to call the
    same function again.
    
    Cc: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: Javi Merino <javi.merino@arm.com>
    Signed-off-by: MyungJoo Ham <myungjoo.ham@samsung.com>

diff --git a/drivers/devfreq/governor_simpleondemand.c b/drivers/devfreq/governor_simpleondemand.c
index 0720ba84ca92..ae72ba5e78df 100644
--- a/drivers/devfreq/governor_simpleondemand.c
+++ b/drivers/devfreq/governor_simpleondemand.c
@@ -21,17 +21,20 @@
 static int devfreq_simple_ondemand_func(struct devfreq *df,
 					unsigned long *freq)
 {
-	struct devfreq_dev_status stat;
-	int err = df->profile->get_dev_status(df->dev.parent, &stat);
+	int err;
+	struct devfreq_dev_status *stat;
 	unsigned long long a, b;
 	unsigned int dfso_upthreshold = DFSO_UPTHRESHOLD;
 	unsigned int dfso_downdifferential = DFSO_DOWNDIFFERENCTIAL;
 	struct devfreq_simple_ondemand_data *data = df->data;
 	unsigned long max = (df->max_freq) ? df->max_freq : UINT_MAX;
 
+	err = devfreq_update_stats(df);
 	if (err)
 		return err;
 
+	stat = &df->last_status;
+
 	if (data) {
 		if (data->upthreshold)
 			dfso_upthreshold = data->upthreshold;
@@ -43,41 +46,41 @@ static int devfreq_simple_ondemand_func(struct devfreq *df,
 		return -EINVAL;
 
 	/* Assume MAX if it is going to be divided by zero */
-	if (stat.total_time == 0) {
+	if (stat->total_time == 0) {
 		*freq = max;
 		return 0;
 	}
 
 	/* Prevent overflow */
-	if (stat.busy_time >= (1 << 24) || stat.total_time >= (1 << 24)) {
-		stat.busy_time >>= 7;
-		stat.total_time >>= 7;
+	if (stat->busy_time >= (1 << 24) || stat->total_time >= (1 << 24)) {
+		stat->busy_time >>= 7;
+		stat->total_time >>= 7;
 	}
 
 	/* Set MAX if it's busy enough */
-	if (stat.busy_time * 100 >
-	    stat.total_time * dfso_upthreshold) {
+	if (stat->busy_time * 100 >
+	    stat->total_time * dfso_upthreshold) {
 		*freq = max;
 		return 0;
 	}
 
 	/* Set MAX if we do not know the initial frequency */
-	if (stat.current_frequency == 0) {
+	if (stat->current_frequency == 0) {
 		*freq = max;
 		return 0;
 	}
 
 	/* Keep the current frequency */
-	if (stat.busy_time * 100 >
-	    stat.total_time * (dfso_upthreshold - dfso_downdifferential)) {
-		*freq = stat.current_frequency;
+	if (stat->busy_time * 100 >
+	    stat->total_time * (dfso_upthreshold - dfso_downdifferential)) {
+		*freq = stat->current_frequency;
 		return 0;
 	}
 
 	/* Set the desired frequency based on the load */
-	a = stat.busy_time;
-	a *= stat.current_frequency;
-	b = div_u64(a, stat.total_time);
+	a = stat->busy_time;
+	a *= stat->current_frequency;
+	b = div_u64(a, stat->total_time);
 	b *= 100;
 	b = div_u64(b, (dfso_upthreshold - dfso_downdifferential / 2));
 	*freq = (unsigned long) b;

commit eff607fdb1f787da1fedf46ab6e64adc2afd1c5a
Author: Nishanth Menon <nm@ti.com>
Date:   Mon Oct 29 15:01:46 2012 -0500

    PM / devfreq: governors: add GPL module license and allow module build
    
    Add GPL module license and remove the static build
    restrictions for building governors. This allows governors now
    to be loaded on a need basis and reloaded independently of kernel
    build
    
    Cc: Rajagopal Venkat <rajagopal.venkat@linaro.org>
    Cc: MyungJoo Ham <myungjoo.ham@samsung.com>
    Cc: Kyungmin Park <kyungmin.park@samsung.com>
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Cc: Kevin Hilman <khilman@ti.com>
    Cc: linux-pm@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org
    
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Acked-by: MyungJoo Ham <myungjoo.ham@samsung.com>
    Signed-off-by: MyungJoo Ham <myungjoo.ham@samsung.com>

diff --git a/drivers/devfreq/governor_simpleondemand.c b/drivers/devfreq/governor_simpleondemand.c
index a870a24bb56b..0720ba84ca92 100644
--- a/drivers/devfreq/governor_simpleondemand.c
+++ b/drivers/devfreq/governor_simpleondemand.c
@@ -10,6 +10,7 @@
  */
 
 #include <linux/errno.h>
+#include <linux/module.h>
 #include <linux/devfreq.h>
 #include <linux/math64.h>
 #include "governor.h"
@@ -143,3 +144,4 @@ static void __exit devfreq_simple_ondemand_exit(void)
 	return;
 }
 module_exit(devfreq_simple_ondemand_exit);
+MODULE_LICENSE("GPL");

commit 1b5c1be2c88e8445a20fa1929e26c37e7ca8c926
Author: Nishanth Menon <nm@ti.com>
Date:   Mon Oct 29 15:01:45 2012 -0500

    PM / devfreq: map devfreq drivers to governor using name
    
    Allow devfreq drivers to register a preferred governor name
    and when the devfreq governor loads itself at a later point
    required drivers are managed appropriately, at the time of
    unload of a devfreq governor, stop managing those drivers
    as well.
    
    Since the governor structures do not need to be exposed
    anymore, remove the definitions and make them static
    
    NOTE: devfreq_list_lock is now used to protect governor
    start and stop - as this allows us to protect governors and
    devfreq with the proper dependencies as needed.
    
    As part of this change, change the registration of exynos
    bus driver to request for ondemand using the governor name.
    
    Cc: Rajagopal Venkat <rajagopal.venkat@linaro.org>
    Cc: MyungJoo Ham <myungjoo.ham@samsung.com>
    Cc: Kyungmin Park <kyungmin.park@samsung.com>
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Cc: Kevin Hilman <khilman@ti.com>
    Cc: linux-pm@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org
    
    Signed-off-by: Nishanth Menon <nm@ti.com>
    [Merge conflict resolved by MyungJoo Ham]
    Signed-off-by: MyungJoo Ham <myungjoo.ham@samsung.com>

diff --git a/drivers/devfreq/governor_simpleondemand.c b/drivers/devfreq/governor_simpleondemand.c
index 85f9ed531b1e..a870a24bb56b 100644
--- a/drivers/devfreq/governor_simpleondemand.c
+++ b/drivers/devfreq/governor_simpleondemand.c
@@ -120,7 +120,7 @@ static int devfreq_simple_ondemand_handler(struct devfreq *devfreq,
 	return 0;
 }
 
-const struct devfreq_governor devfreq_simple_ondemand = {
+static struct devfreq_governor devfreq_simple_ondemand = {
 	.name = "simple_ondemand",
 	.get_target_freq = devfreq_simple_ondemand_func,
 	.event_handler = devfreq_simple_ondemand_handler,

commit 83116e66a232184f733ecf09a41817cf893ede98
Author: Nishanth Menon <nm@ti.com>
Date:   Mon Oct 29 15:01:44 2012 -0500

    PM / devfreq: register governors with devfreq framework
    
    With the new registration functions, governors can be now
    registered with devfreq framework.
    
    NOTE: generates 'discards qualifiers from pointer target type'
    build warnings, which the next patche in this series fixes
    
    Cc: Rajagopal Venkat <rajagopal.venkat@linaro.org>
    Cc: MyungJoo Ham <myungjoo.ham@samsung.com>
    Cc: Kyungmin Park <kyungmin.park@samsung.com>
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Cc: Kevin Hilman <khilman@ti.com>
    Cc: linux-pm@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org
    
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Acked-by: MyungJoo Ham <myungjoo.ham@samsung.com>
    Signed-off-by: MyungJoo Ham <myungjoo.ham@samsung.com>

diff --git a/drivers/devfreq/governor_simpleondemand.c b/drivers/devfreq/governor_simpleondemand.c
index b5cf0fb24efe..85f9ed531b1e 100644
--- a/drivers/devfreq/governor_simpleondemand.c
+++ b/drivers/devfreq/governor_simpleondemand.c
@@ -125,3 +125,21 @@ const struct devfreq_governor devfreq_simple_ondemand = {
 	.get_target_freq = devfreq_simple_ondemand_func,
 	.event_handler = devfreq_simple_ondemand_handler,
 };
+
+static int __init devfreq_simple_ondemand_init(void)
+{
+	return devfreq_add_governor(&devfreq_simple_ondemand);
+}
+subsys_initcall(devfreq_simple_ondemand_init);
+
+static void __exit devfreq_simple_ondemand_exit(void)
+{
+	int ret;
+
+	ret = devfreq_remove_governor(&devfreq_simple_ondemand);
+	if (ret)
+		pr_err("%s: failed remove governor %d\n", __func__, ret);
+
+	return;
+}
+module_exit(devfreq_simple_ondemand_exit);

commit 206c30cfeb7c05dfb9fdfd81b1deb933627e43c1
Author: Rajagopal Venkat <rajagopal.venkat@linaro.org>
Date:   Fri Oct 26 01:50:18 2012 +0200

    PM / devfreq: Add suspend and resume apis
    
    Add devfreq suspend/resume apis for devfreq users. This patch
    supports suspend and resume of devfreq load monitoring, required
    for devices which can idle.
    
    Signed-off-by: Rajagopal Venkat <rajagopal.venkat@linaro.org>
    Acked-by: MyungJoo Ham <myungjoo.ham@samsung.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/devfreq/governor_simpleondemand.c b/drivers/devfreq/governor_simpleondemand.c
index 3716a659122b..b5cf0fb24efe 100644
--- a/drivers/devfreq/governor_simpleondemand.c
+++ b/drivers/devfreq/governor_simpleondemand.c
@@ -104,6 +104,15 @@ static int devfreq_simple_ondemand_handler(struct devfreq *devfreq,
 	case DEVFREQ_GOV_INTERVAL:
 		devfreq_interval_update(devfreq, (unsigned int *)data);
 		break;
+
+	case DEVFREQ_GOV_SUSPEND:
+		devfreq_monitor_suspend(devfreq);
+		break;
+
+	case DEVFREQ_GOV_RESUME:
+		devfreq_monitor_resume(devfreq);
+		break;
+
 	default:
 		break;
 	}

commit 7e6fdd4bad033fa2d73716377b184fa975b0d985
Author: Rajagopal Venkat <rajagopal.venkat@linaro.org>
Date:   Fri Oct 26 01:50:09 2012 +0200

    PM / devfreq: Core updates to support devices which can idle
    
    Prepare devfreq core framework to support devices which
    can idle. When device idleness is detected perhaps through
    runtime-pm, need some mechanism to suspend devfreq load
    monitoring and resume back when device is online. Present
    code continues monitoring unless device is removed from
    devfreq core.
    
    This patch introduces following design changes,
    
     - use per device work instead of global work to monitor device
       load. This enables suspend/resume of device devfreq and
       reduces monitoring code complexity.
     - decouple delayed work based load monitoring logic from core
       by introducing helpers functions to be used by governors. This
       provides flexibility for governors either to use delayed work
       based monitoring functions or to implement their own mechanism.
     - devfreq core interacts with governors via events to perform
       specific actions. These events include start/stop devfreq.
       This sets ground for adding suspend/resume events.
    
    The devfreq apis are not modified and are kept intact.
    
    Signed-off-by: Rajagopal Venkat <rajagopal.venkat@linaro.org>
    Acked-by: MyungJoo Ham <myungjoo.ham@samsung.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/devfreq/governor_simpleondemand.c b/drivers/devfreq/governor_simpleondemand.c
index a2e3eae79011..3716a659122b 100644
--- a/drivers/devfreq/governor_simpleondemand.c
+++ b/drivers/devfreq/governor_simpleondemand.c
@@ -12,6 +12,7 @@
 #include <linux/errno.h>
 #include <linux/devfreq.h>
 #include <linux/math64.h>
+#include "governor.h"
 
 /* Default constants for DevFreq-Simple-Ondemand (DFSO) */
 #define DFSO_UPTHRESHOLD	(90)
@@ -88,7 +89,30 @@ static int devfreq_simple_ondemand_func(struct devfreq *df,
 	return 0;
 }
 
+static int devfreq_simple_ondemand_handler(struct devfreq *devfreq,
+				unsigned int event, void *data)
+{
+	switch (event) {
+	case DEVFREQ_GOV_START:
+		devfreq_monitor_start(devfreq);
+		break;
+
+	case DEVFREQ_GOV_STOP:
+		devfreq_monitor_stop(devfreq);
+		break;
+
+	case DEVFREQ_GOV_INTERVAL:
+		devfreq_interval_update(devfreq, (unsigned int *)data);
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
 const struct devfreq_governor devfreq_simple_ondemand = {
 	.name = "simple_ondemand",
 	.get_target_freq = devfreq_simple_ondemand_func,
+	.event_handler = devfreq_simple_ondemand_handler,
 };

commit 6530b9dea1b7f33eaf79ba625e3a99f2455f3eb1
Author: MyungJoo Ham <myungjoo.ham@samsung.com>
Date:   Fri Dec 9 16:42:19 2011 +0900

    PM / devfreq: add min/max_freq limit requested by users.
    
    The frequency requested to devfreq device driver from devfreq governors
    is restricted by min_freq and max_freq input.
    
    Signed-off-by: MyungJoo Ham <myungjoo.ham@samsung.com>
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>

diff --git a/drivers/devfreq/governor_simpleondemand.c b/drivers/devfreq/governor_simpleondemand.c
index efad8dcf9028..a2e3eae79011 100644
--- a/drivers/devfreq/governor_simpleondemand.c
+++ b/drivers/devfreq/governor_simpleondemand.c
@@ -25,6 +25,7 @@ static int devfreq_simple_ondemand_func(struct devfreq *df,
 	unsigned int dfso_upthreshold = DFSO_UPTHRESHOLD;
 	unsigned int dfso_downdifferential = DFSO_DOWNDIFFERENCTIAL;
 	struct devfreq_simple_ondemand_data *data = df->data;
+	unsigned long max = (df->max_freq) ? df->max_freq : UINT_MAX;
 
 	if (err)
 		return err;
@@ -41,7 +42,7 @@ static int devfreq_simple_ondemand_func(struct devfreq *df,
 
 	/* Assume MAX if it is going to be divided by zero */
 	if (stat.total_time == 0) {
-		*freq = UINT_MAX;
+		*freq = max;
 		return 0;
 	}
 
@@ -54,13 +55,13 @@ static int devfreq_simple_ondemand_func(struct devfreq *df,
 	/* Set MAX if it's busy enough */
 	if (stat.busy_time * 100 >
 	    stat.total_time * dfso_upthreshold) {
-		*freq = UINT_MAX;
+		*freq = max;
 		return 0;
 	}
 
 	/* Set MAX if we do not know the initial frequency */
 	if (stat.current_frequency == 0) {
-		*freq = UINT_MAX;
+		*freq = max;
 		return 0;
 	}
 
@@ -79,6 +80,11 @@ static int devfreq_simple_ondemand_func(struct devfreq *df,
 	b = div_u64(b, (dfso_upthreshold - dfso_downdifferential / 2));
 	*freq = (unsigned long) b;
 
+	if (df->min_freq && *freq < df->min_freq)
+		*freq = df->min_freq;
+	if (df->max_freq && *freq > df->max_freq)
+		*freq = df->max_freq;
+
 	return 0;
 }
 

commit ce26c5bb9569d8b826f01b8620fc16d8da6821e9
Author: MyungJoo Ham <myungjoo.ham@samsung.com>
Date:   Sun Oct 2 00:19:34 2011 +0200

    PM / devfreq: Add basic governors
    
    Four cpufreq-like governors are provided as examples.
    
    powersave: use the lowest frequency possible. The user (device) should
    set the polling_ms as 0 because polling is useless for this governor.
    
    performance: use the highest freqeuncy possible. The user (device)
    should set the polling_ms as 0 because polling is useless for this
    governor.
    
    userspace: use the user specified frequency stored at
    devfreq.user_set_freq. With sysfs support in the following patch, a user
    may set the value with the sysfs interface.
    
    simple_ondemand: simplified version of cpufreq's ondemand governor.
    
    When a user updates OPP entries (enable/disable/add), OPP framework
    automatically notifies devfreq to update operating frequency
    accordingly. Thus, devfreq users (device drivers) do not need to update
    devfreq manually with OPP entry updates or set polling_ms for powersave
    , performance, userspace, or any other "static" governors.
    
    Note that these are given only as basic examples for governors and any
    devices with devfreq may implement their own governors with the drivers
    and use them.
    
    Signed-off-by: MyungJoo Ham <myungjoo.ham@samsung.com>
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Reviewed-by: Mike Turquette <mturquette@ti.com>
    Acked-by: Kevin Hilman <khilman@ti.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/devfreq/governor_simpleondemand.c b/drivers/devfreq/governor_simpleondemand.c
new file mode 100644
index 000000000000..efad8dcf9028
--- /dev/null
+++ b/drivers/devfreq/governor_simpleondemand.c
@@ -0,0 +1,88 @@
+/*
+ *  linux/drivers/devfreq/governor_simpleondemand.c
+ *
+ *  Copyright (C) 2011 Samsung Electronics
+ *	MyungJoo Ham <myungjoo.ham@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/errno.h>
+#include <linux/devfreq.h>
+#include <linux/math64.h>
+
+/* Default constants for DevFreq-Simple-Ondemand (DFSO) */
+#define DFSO_UPTHRESHOLD	(90)
+#define DFSO_DOWNDIFFERENCTIAL	(5)
+static int devfreq_simple_ondemand_func(struct devfreq *df,
+					unsigned long *freq)
+{
+	struct devfreq_dev_status stat;
+	int err = df->profile->get_dev_status(df->dev.parent, &stat);
+	unsigned long long a, b;
+	unsigned int dfso_upthreshold = DFSO_UPTHRESHOLD;
+	unsigned int dfso_downdifferential = DFSO_DOWNDIFFERENCTIAL;
+	struct devfreq_simple_ondemand_data *data = df->data;
+
+	if (err)
+		return err;
+
+	if (data) {
+		if (data->upthreshold)
+			dfso_upthreshold = data->upthreshold;
+		if (data->downdifferential)
+			dfso_downdifferential = data->downdifferential;
+	}
+	if (dfso_upthreshold > 100 ||
+	    dfso_upthreshold < dfso_downdifferential)
+		return -EINVAL;
+
+	/* Assume MAX if it is going to be divided by zero */
+	if (stat.total_time == 0) {
+		*freq = UINT_MAX;
+		return 0;
+	}
+
+	/* Prevent overflow */
+	if (stat.busy_time >= (1 << 24) || stat.total_time >= (1 << 24)) {
+		stat.busy_time >>= 7;
+		stat.total_time >>= 7;
+	}
+
+	/* Set MAX if it's busy enough */
+	if (stat.busy_time * 100 >
+	    stat.total_time * dfso_upthreshold) {
+		*freq = UINT_MAX;
+		return 0;
+	}
+
+	/* Set MAX if we do not know the initial frequency */
+	if (stat.current_frequency == 0) {
+		*freq = UINT_MAX;
+		return 0;
+	}
+
+	/* Keep the current frequency */
+	if (stat.busy_time * 100 >
+	    stat.total_time * (dfso_upthreshold - dfso_downdifferential)) {
+		*freq = stat.current_frequency;
+		return 0;
+	}
+
+	/* Set the desired frequency based on the load */
+	a = stat.busy_time;
+	a *= stat.current_frequency;
+	b = div_u64(a, stat.total_time);
+	b *= 100;
+	b = div_u64(b, (dfso_upthreshold - dfso_downdifferential / 2));
+	*freq = (unsigned long) b;
+
+	return 0;
+}
+
+const struct devfreq_governor devfreq_simple_ondemand = {
+	.name = "simple_ondemand",
+	.get_target_freq = devfreq_simple_ondemand_func,
+};
