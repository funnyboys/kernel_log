commit 60541fb62438c6abd821874cfc3a24d280d1cbbf
Merge: a238ac2d6aa5 e13762abf38e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jul 17 09:43:13 2020 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/hid/hid into master
    
    Pull HID fixes from Jiri Kosina:
    
     - linked list race condition fix in hid-steam driver from Rodrigo Rivas
       Costa
    
     - assorted deviceID-specific quirks and other small cosmetic cleanups
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/hid/hid:
      HID: logitech-hidpp: avoid repeated "multiplier = " log messages
      HID: logitech: Use HIDPP_RECEIVER_INDEX instead of 0xff
      HID: quirks: Ignore Simply Automated UPB PIM
      HID: apple: Disable Fn-key key-re-mapping on clone keyboards
      MAINTAINERS: update uhid and hid-wiimote entry
      HID: steam: fixes race in handling device list.
      HID: magicmouse: do not set up autorepeat
      HID: alps: support devices with report id 2
      HID: quirks: Always poll Obins Anne Pro 2 keyboard
      HID: i2c-hid: add Mediacom FlexBook edge13 to descriptor override

commit aa3c439c144f0a465ed1f28f11c772886fb02b35
Author: Caiyuan Xie <caiyuan.xie@cn.alps.com>
Date:   Fri May 22 05:06:10 2020 -0400

    HID: alps: support devices with report id 2
    
    Add support for devices which that have reports with id == 2
    
    Signed-off-by: Caiyuan Xie <caiyuan.xie@cn.alps.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-alps.c b/drivers/hid/hid-alps.c
index b2ad319a74b9..d33f5abc8f64 100644
--- a/drivers/hid/hid-alps.c
+++ b/drivers/hid/hid-alps.c
@@ -25,6 +25,7 @@
 
 #define U1_MOUSE_REPORT_ID			0x01 /* Mouse data ReportID */
 #define U1_ABSOLUTE_REPORT_ID		0x03 /* Absolute data ReportID */
+#define U1_ABSOLUTE_REPORT_ID_SECD  0x02 /* FW-PTP Absolute data ReportID */
 #define U1_FEATURE_REPORT_ID		0x05 /* Feature ReportID */
 #define U1_SP_ABSOLUTE_REPORT_ID	0x06 /* Feature ReportID */
 
@@ -368,6 +369,7 @@ static int u1_raw_event(struct alps_dev *hdata, u8 *data, int size)
 	case U1_FEATURE_REPORT_ID:
 		break;
 	case U1_ABSOLUTE_REPORT_ID:
+	case U1_ABSOLUTE_REPORT_ID_SECD:
 		for (i = 0; i < hdata->max_fingers; i++) {
 			u8 *contact = &data[i * 5];
 

commit 49f13b0921aaef0d5519358fd9fcc237c1c9124a
Merge: 09102704c674 751ad34fbad7
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jun 10 13:51:47 2020 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/dtor/input
    
    Pull input updates from Dmitry Torokhov:
    
     - a new driver for the Azoteq IQS269A capacitive touch controller
    
     - a new driver for the Cypress CY8CTMA140 touchscreen
    
     - updates to Elan and ft5x06 touchscreen drivers
    
     - assorted driver fixes
    
     - msm-vibrator has been removed as we have a more generic solution
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/dtor/input: (28 commits)
      Input: adi - work around module name confict
      Input: iqs269a - add missing I2C dependency
      Input: elants - refactor elants_i2c_execute_command()
      Input: elants - override touchscreen info with DT properties
      Input: elants - remove unused axes
      Input: add support for Azoteq IQS269A
      dt-bindings: input: Add bindings for Azoteq IQS269A
      Input: imx_sc_key - use devm_add_action_or_reset() to handle all cleanups
      Input: remove msm-vibrator driver
      dt-bindings: Input: remove msm-vibrator
      Input: elants_i2c - provide an attribute to show calibration count
      Input: introduce input_mt_report_slot_inactive()
      dt-bindings: input: touchscreen: elants_i2c: convert to YAML
      Input: add driver for the Cypress CY8CTMA140 touchscreen
      dt-bindings: touchscreen: Add CY8CTMA140 bindings
      Input: edt-ft5x06 - prefer asynchronous probe
      Input: edt-ft5x06 - improve power management operations
      Input: edt-ft5x06 - move parameter restore into helper
      Input: edt-ft5x06 - fix get_default register write access
      Input: atkbd - receive and use physcode->keycode mapping from FW
      ...

commit 5fc70e350edd30fb22d2f9b4e6d680c5471890ff
Author: Jiada Wang <jiada_wang@mentor.com>
Date:   Mon May 11 13:12:13 2020 -0700

    Input: introduce input_mt_report_slot_inactive()
    
    input_mt_report_slot_state() ignores "tool" argument when the slot is
    closed, which has caused a bit of confusion. Let's introduce
    input_mt_report_slot_inactive() to report inactive slot state.
    
    Suggested-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Jiada Wang <jiada_wang@mentor.com>
    Link: https://lore.kernel.org/r/20200508055656.96389-2-jiada_wang@mentor.com
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/hid/hid-alps.c b/drivers/hid/hid-alps.c
index fa704153cb00..28588f74425e 100644
--- a/drivers/hid/hid-alps.c
+++ b/drivers/hid/hid-alps.c
@@ -387,8 +387,7 @@ static int u1_raw_event(struct alps_dev *hdata, u8 *data, int size)
 				input_report_abs(hdata->input,
 					ABS_MT_PRESSURE, z);
 			} else {
-				input_mt_report_slot_state(hdata->input,
-					MT_TOOL_FINGER, 0);
+				input_mt_report_slot_inactive(hdata->input);
 			}
 		}
 

commit 185af3e775b693f773d9a4b5a8c3cda69fc8ca0f
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Wed Apr 15 14:51:42 2020 +0200

    HID: alps: ALPS_1657 is too specific; use U1_UNICORN_LEGACY instead
    
    HID_DEVICE_ID_ALPS_1657 PID is too specific, as there are many other
    ALPS hardware IDs using this particular touchpad.
    
    Rename the identifier to HID_DEVICE_ID_ALPS_U1_UNICORN_LEGACY in order
    to describe reality better.
    
    Fixes: 640e403b1fd24 ("HID: alps: Add AUI1657 device ID")
    Reported-by: Xiaojian Cao <xiaojian.cao@cn.alps.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-alps.c b/drivers/hid/hid-alps.c
index c2a2bd528890..b2ad319a74b9 100644
--- a/drivers/hid/hid-alps.c
+++ b/drivers/hid/hid-alps.c
@@ -802,7 +802,7 @@ static int alps_probe(struct hid_device *hdev, const struct hid_device_id *id)
 		break;
 	case HID_DEVICE_ID_ALPS_U1_DUAL:
 	case HID_DEVICE_ID_ALPS_U1:
-	case HID_DEVICE_ID_ALPS_1657:
+	case HID_DEVICE_ID_ALPS_U1_UNICORN_LEGACY:
 		data->dev_type = U1;
 		break;
 	default:

commit 640e403b1fd24e7f31ac6f29f0b6a21d285ed729
Author: Artem Borisov <dedsa2002@gmail.com>
Date:   Mon Apr 6 03:55:15 2020 +0400

    HID: alps: Add AUI1657 device ID
    
    This device is used on Lenovo V130-15IKB variants and uses
    the same registers as U1.
    
    Signed-off-by: Artem Borisov <dedsa2002@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-alps.c b/drivers/hid/hid-alps.c
index fa704153cb00..c2a2bd528890 100644
--- a/drivers/hid/hid-alps.c
+++ b/drivers/hid/hid-alps.c
@@ -802,6 +802,7 @@ static int alps_probe(struct hid_device *hdev, const struct hid_device_id *id)
 		break;
 	case HID_DEVICE_ID_ALPS_U1_DUAL:
 	case HID_DEVICE_ID_ALPS_U1:
+	case HID_DEVICE_ID_ALPS_1657:
 		data->dev_type = U1;
 		break;
 	default:

commit 8d2e77b39b8fecb794e19cd006a12f90b14dd077
Author: Christophe JAILLET <christophe.jaillet@wanadoo.fr>
Date:   Wed Dec 4 04:35:25 2019 +0100

    HID: alps: Fix an error handling path in 'alps_input_configured()'
    
    They are issues:
       - if 'input_allocate_device()' fails and return NULL, there is no need
         to free anything and 'input_free_device()' call is a no-op. It can
         be axed.
       - 'ret' is known to be 0 at this point, so we must set it to a
         meaningful value before returning
    
    Fixes: 2562756dde55 ("HID: add Alps I2C HID Touchpad-Stick support")
    Signed-off-by: Christophe JAILLET <christophe.jaillet@wanadoo.fr>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-alps.c b/drivers/hid/hid-alps.c
index ae79a7c66737..fa704153cb00 100644
--- a/drivers/hid/hid-alps.c
+++ b/drivers/hid/hid-alps.c
@@ -730,7 +730,7 @@ static int alps_input_configured(struct hid_device *hdev, struct hid_input *hi)
 	if (data->has_sp) {
 		input2 = input_allocate_device();
 		if (!input2) {
-			input_free_device(input2);
+			ret = -ENOMEM;
 			goto exit;
 		}
 

commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hid/hid-alps.c b/drivers/hid/hid-alps.c
index 3cd7229b6e54..ae79a7c66737 100644
--- a/drivers/hid/hid-alps.c
+++ b/drivers/hid/hid-alps.c
@@ -1,10 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *  Copyright (c) 2016 Masaki Ota <masaki.ota@jp.alps.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the Free
- * Software Foundation; either version 2 of the License, or (at your option)
- * any later version.
  */
 
 #include <linux/kernel.h>

commit 7dd8db68949a7acc5bd528ee0ecb8f8720f49921
Author: Benjamin Tissoires <benjamin.tissoires@redhat.com>
Date:   Fri Oct 12 16:05:25 2018 +0200

    HID: alps: allow incoming reports when only the trackstick is opened
    
    If userspace only reads the trackstick node, and no one is listening to
    the touchpad nor the hidraw node then, the device is not powered on.
    
    Add open/close callbacks to allow users to disable the touchpad in Gnome
    while keeping the trackstick active.
    
    Link: https://bugzilla.redhat.com/show_bug.cgi?id=1559632
    Link: https://gitlab.gnome.org/GNOME/mutter/issues/128
    Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-alps.c b/drivers/hid/hid-alps.c
index aec253b44156..3cd7229b6e54 100644
--- a/drivers/hid/hid-alps.c
+++ b/drivers/hid/hid-alps.c
@@ -660,6 +660,20 @@ static int T4_init(struct hid_device *hdev, struct alps_dev *pri_data)
 	return ret;
 }
 
+static int alps_sp_open(struct input_dev *dev)
+{
+	struct hid_device *hid = input_get_drvdata(dev);
+
+	return hid_hw_open(hid);
+}
+
+static void alps_sp_close(struct input_dev *dev)
+{
+	struct hid_device *hid = input_get_drvdata(dev);
+
+	hid_hw_close(hid);
+}
+
 static int alps_input_configured(struct hid_device *hdev, struct hid_input *hi)
 {
 	struct alps_dev *data = hid_get_drvdata(hdev);
@@ -733,6 +747,10 @@ static int alps_input_configured(struct hid_device *hdev, struct hid_input *hi)
 		input2->id.version = input->id.version;
 		input2->dev.parent = input->dev.parent;
 
+		input_set_drvdata(input2, hdev);
+		input2->open = alps_sp_open;
+		input2->close = alps_sp_close;
+
 		__set_bit(EV_KEY, input2->evbit);
 		data->sp_btn_cnt = (data->sp_btn_info & 0x0F);
 		for (i = 0; i < data->sp_btn_cnt; i++)

commit a317e559574b2af62095b39792d168cb98cb2561
Author: Christophe JAILLET <christophe.jaillet@wanadoo.fr>
Date:   Mon Mar 19 21:53:29 2018 +0100

    HID: alps: Fix some style in 't4_read_write_register()'
    
    Better indent the code to improve readability.
    
    Signed-off-by: Christophe JAILLET <christophe.jaillet@wanadoo.fr>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-alps.c b/drivers/hid/hid-alps.c
index b7091507c33f..aec253b44156 100644
--- a/drivers/hid/hid-alps.c
+++ b/drivers/hid/hid-alps.c
@@ -223,20 +223,20 @@ static int t4_read_write_register(struct hid_device *hdev, u32 address,
 
 		if (*(u32 *)&readbuf[6] != address) {
 			dev_err(&hdev->dev, "read register address error (%x,%x)\n",
-			*(u32 *)&readbuf[6], address);
+				*(u32 *)&readbuf[6], address);
 			goto exit_readbuf;
 		}
 
 		if (*(u16 *)&readbuf[10] != 1) {
 			dev_err(&hdev->dev, "read register size error (%x)\n",
-			*(u16 *)&readbuf[10]);
+				*(u16 *)&readbuf[10]);
 			goto exit_readbuf;
 		}
 
 		check_sum = t4_calc_check_sum(readbuf, 6, 7);
 		if (*(u16 *)&readbuf[13] != check_sum) {
 			dev_err(&hdev->dev, "read register checksum error (%x,%x)\n",
-			*(u16 *)&readbuf[13], check_sum);
+				*(u16 *)&readbuf[13], check_sum);
 			goto exit_readbuf;
 		}
 

commit 69934012f394d1db11c3c0c781fd88b6ae447dbe
Author: Christophe JAILLET <christophe.jaillet@wanadoo.fr>
Date:   Mon Mar 19 21:53:28 2018 +0100

    HID: alps: Check errors returned by 't4_read_write_register()'
    
    If only the first 't4_read_write_register()' call fails, the error code
    will be overwritten and lost.
    Directly report the error instead.
    
    While at it, log some errors if 't4_read_write_register()' fails, as done
    in the rest of the driver.
    
    Signed-off-by: Christophe JAILLET <christophe.jaillet@wanadoo.fr>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-alps.c b/drivers/hid/hid-alps.c
index fe8a0624d5e4..b7091507c33f 100644
--- a/drivers/hid/hid-alps.c
+++ b/drivers/hid/hid-alps.c
@@ -460,17 +460,35 @@ static int __maybe_unused alps_post_reset(struct hid_device *hdev)
 	case T4:
 		ret = t4_read_write_register(hdev, T4_PRM_FEED_CONFIG_1,
 			NULL, T4_I2C_ABS, false);
+		if (ret < 0) {
+			dev_err(&hdev->dev, "failed T4_PRM_FEED_CONFIG_1 (%d)\n",
+				ret);
+			goto exit;
+		}
+
 		ret = t4_read_write_register(hdev, T4_PRM_FEED_CONFIG_4,
 			NULL, T4_FEEDCFG4_ADVANCED_ABS_ENABLE, false);
+		if (ret < 0) {
+			dev_err(&hdev->dev, "failed T4_PRM_FEED_CONFIG_4 (%d)\n",
+				ret);
+			goto exit;
+		}
 		break;
 	case U1:
 		ret = u1_read_write_register(hdev,
 			ADDRESS_U1_DEV_CTRL_1, NULL,
 			U1_TP_ABS_MODE | U1_SP_ABS_MODE, false);
+		if (ret < 0) {
+			dev_err(&hdev->dev, "failed to change TP mode (%d)\n",
+				ret);
+			goto exit;
+		}
 		break;
 	default:
 		break;
 	}
+
+exit:
 	return ret;
 }
 

commit edb6cb3d7c9026d1a3bdfde9f74ed6c807285206
Author: Christophe JAILLET <christophe.jaillet@wanadoo.fr>
Date:   Mon Mar 19 21:53:27 2018 +0100

    HID: alps: Save a memory allocation in 't4_read_write_register()' when writing data
    
    if 'read_flag' is false, there is no need to allocate and free memory.
    We can simply avoid the memory allocation and pass NULL to kfree.
    
    Signed-off-by: Christophe JAILLET <christophe.jaillet@wanadoo.fr>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-alps.c b/drivers/hid/hid-alps.c
index 925396fdf0d9..fe8a0624d5e4 100644
--- a/drivers/hid/hid-alps.c
+++ b/drivers/hid/hid-alps.c
@@ -171,7 +171,7 @@ static int t4_read_write_register(struct hid_device *hdev, u32 address,
 	int ret;
 	u16 check_sum;
 	u8 *input;
-	u8 *readbuf;
+	u8 *readbuf = NULL;
 
 	input = kzalloc(T4_FEATURE_REPORT_LEN, GFP_KERNEL);
 	if (!input)
@@ -204,8 +204,8 @@ static int t4_read_write_register(struct hid_device *hdev, u32 address,
 		goto exit;
 	}
 
-	readbuf = kzalloc(T4_FEATURE_REPORT_LEN, GFP_KERNEL);
 	if (read_flag) {
+		readbuf = kzalloc(T4_FEATURE_REPORT_LEN, GFP_KERNEL);
 		if (!readbuf) {
 			ret = -ENOMEM;
 			goto exit;

commit 605f077290a594c75a952ad3b78e53d68c1895ae
Author: Christophe JAILLET <christophe.jaillet@wanadoo.fr>
Date:   Mon Mar 19 21:53:26 2018 +0100

    HID: alps: Report an error if we receive invalid data in 't4_read_write_register()'
    
    If the data received is not what is expected, we should return an error.
    
    Otherwise, we return 0 or a positive value which will be interpreted as
    success, but '*read_val' has not been updated.
    
    Fixes: 73196ebe134d ("HID: alps: add support for Alps T4 Touchpad device")
    Signed-off-by: Christophe JAILLET <christophe.jaillet@wanadoo.fr>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-alps.c b/drivers/hid/hid-alps.c
index b1eeb4839bfc..925396fdf0d9 100644
--- a/drivers/hid/hid-alps.c
+++ b/drivers/hid/hid-alps.c
@@ -219,6 +219,8 @@ static int t4_read_write_register(struct hid_device *hdev, u32 address,
 			goto exit_readbuf;
 		}
 
+		ret = -EINVAL;
+
 		if (*(u32 *)&readbuf[6] != address) {
 			dev_err(&hdev->dev, "read register address error (%x,%x)\n",
 			*(u32 *)&readbuf[6], address);

commit 287b8e11972f934052f4ed0751df465a5e84b69c
Author: Masaki Ota <masaki.ota@jp.alps.com>
Date:   Fri Oct 6 11:53:18 2017 +0900

    HID: alps: add new U1 device ID
    
    Add new U1 device Product ID This device is used on HP Elite book x360 series.
    
    [jkosina@suse.cz: update changelog]
    Signed-off-by: Masaki Ota <masaki.ota@jp.alps.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-alps.c b/drivers/hid/hid-alps.c
index 5ae2cba8fe76..b1eeb4839bfc 100644
--- a/drivers/hid/hid-alps.c
+++ b/drivers/hid/hid-alps.c
@@ -767,6 +767,7 @@ static int alps_probe(struct hid_device *hdev, const struct hid_device_id *id)
 		data->dev_type = T4;
 		break;
 	case HID_DEVICE_ID_ALPS_U1_DUAL:
+	case HID_DEVICE_ID_ALPS_U1:
 		data->dev_type = U1;
 		break;
 	default:
@@ -790,6 +791,8 @@ static void alps_remove(struct hid_device *hdev)
 static const struct hid_device_id alps_id[] = {
 	{ HID_DEVICE(HID_BUS_ANY, HID_GROUP_ANY,
 		USB_VENDOR_ID_ALPS_JP, HID_DEVICE_ID_ALPS_U1_DUAL) },
+	{ HID_DEVICE(HID_BUS_ANY, HID_GROUP_ANY,
+		USB_VENDOR_ID_ALPS_JP, HID_DEVICE_ID_ALPS_U1) },
 	{ HID_DEVICE(HID_BUS_ANY, HID_GROUP_ANY,
 		USB_VENDOR_ID_ALPS_JP, HID_DEVICE_ID_ALPS_T4_BTNLESS) },
 	{ }

commit 73196ebe134d11a68a2e27814c489d685cfc8b03
Author: Masaki Ota <masaki.ota@jp.alps.com>
Date:   Fri Oct 6 11:53:17 2017 +0900

    HID: alps: add support for Alps T4 Touchpad device
    
    - Define T4 device specification value for support T4 device.
    
    - Creeate "t4_contact_data" and "t4_input_report" structure for decoding and
      storing T4-specific data
    
    - Create "t4_calc_check_sum()" function for calculating checksum value to send
      to the device. T4 needs to send this value when reading or writing device
      address value.
    
    - Create "t4_read_write_register()" function for reading and writing device
      address value.
    
    - Create "t4_raw_event()" function for decodin XYZ, palm and button data.
    
    - Replace "MAX_TOUCHES" fixed variable to "max_fingers" variable.
    
    - Add T4 devuce product ID. (0x120C)
    
    T4 device is used on HP EliteBook 1000 series and Zbook Stduio
    
    [jkosina@suse.cz: rewrite changelog]
    Signed-off-by: Masaki Ota <masaki.ota@jp.alps.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-alps.c b/drivers/hid/hid-alps.c
index 4c323b58e009..5ae2cba8fe76 100644
--- a/drivers/hid/hid-alps.c
+++ b/drivers/hid/hid-alps.c
@@ -52,8 +52,30 @@
 #define ADDRESS_U1_PAD_BTN		0x00800052
 #define ADDRESS_U1_SP_BTN		0x0080009F
 
+#define T4_INPUT_REPORT_LEN			sizeof(struct t4_input_report)
+#define T4_FEATURE_REPORT_LEN		T4_INPUT_REPORT_LEN
+#define T4_FEATURE_REPORT_ID		7
+#define T4_CMD_REGISTER_READ			0x08
+#define T4_CMD_REGISTER_WRITE			0x07
+
+#define T4_ADDRESS_BASE				0xC2C0
+#define PRM_SYS_CONFIG_1			(T4_ADDRESS_BASE + 0x0002)
+#define T4_PRM_FEED_CONFIG_1		(T4_ADDRESS_BASE + 0x0004)
+#define T4_PRM_FEED_CONFIG_4		(T4_ADDRESS_BASE + 0x001A)
+#define T4_PRM_ID_CONFIG_3			(T4_ADDRESS_BASE + 0x00B0)
+
+
+#define T4_FEEDCFG4_ADVANCED_ABS_ENABLE			0x01
+#define T4_I2C_ABS	0x78
+
+#define T4_COUNT_PER_ELECTRODE		256
 #define MAX_TOUCHES	5
 
+enum dev_num {
+	U1,
+	T4,
+	UNKNOWN,
+};
 /**
  * struct u1_data
  *
@@ -74,11 +96,12 @@
  * @btn_cnt: number of buttons
  * @sp_btn_cnt: number of stick buttons
  */
-struct u1_dev {
+struct alps_dev {
 	struct input_dev *input;
 	struct input_dev *input2;
 	struct hid_device *hdev;
 
+	enum dev_num dev_type;
 	u8  max_fingers;
 	u8  has_sp;
 	u8	sp_btn_info;
@@ -92,6 +115,141 @@ struct u1_dev {
 	u32	sp_btn_cnt;
 };
 
+struct t4_contact_data {
+	u8  palm;
+	u8	x_lo;
+	u8	x_hi;
+	u8	y_lo;
+	u8	y_hi;
+};
+
+struct t4_input_report {
+	u8  reportID;
+	u8  numContacts;
+	struct t4_contact_data contact[5];
+	u8  button;
+	u8  track[5];
+	u8  zx[5], zy[5];
+	u8  palmTime[5];
+	u8  kilroy;
+	u16 timeStamp;
+};
+
+static u16 t4_calc_check_sum(u8 *buffer,
+		unsigned long offset, unsigned long length)
+{
+	u16 sum1 = 0xFF, sum2 = 0xFF;
+	unsigned long i = 0;
+
+	if (offset + length >= 50)
+		return 0;
+
+	while (length > 0) {
+		u32 tlen = length > 20 ? 20 : length;
+
+		length -= tlen;
+
+		do {
+			sum1 += buffer[offset + i];
+			sum2 += sum1;
+			i++;
+		} while (--tlen > 0);
+
+		sum1 = (sum1 & 0xFF) + (sum1 >> 8);
+		sum2 = (sum2 & 0xFF) + (sum2 >> 8);
+	}
+
+	sum1 = (sum1 & 0xFF) + (sum1 >> 8);
+	sum2 = (sum2 & 0xFF) + (sum2 >> 8);
+
+	return(sum2 << 8 | sum1);
+}
+
+static int t4_read_write_register(struct hid_device *hdev, u32 address,
+	u8 *read_val, u8 write_val, bool read_flag)
+{
+	int ret;
+	u16 check_sum;
+	u8 *input;
+	u8 *readbuf;
+
+	input = kzalloc(T4_FEATURE_REPORT_LEN, GFP_KERNEL);
+	if (!input)
+		return -ENOMEM;
+
+	input[0] = T4_FEATURE_REPORT_ID;
+	if (read_flag) {
+		input[1] = T4_CMD_REGISTER_READ;
+		input[8] = 0x00;
+	} else {
+		input[1] = T4_CMD_REGISTER_WRITE;
+		input[8] = write_val;
+	}
+	put_unaligned_le32(address, input + 2);
+	input[6] = 1;
+	input[7] = 0;
+
+	/* Calculate the checksum */
+	check_sum = t4_calc_check_sum(input, 1, 8);
+	input[9] = (u8)check_sum;
+	input[10] = (u8)(check_sum >> 8);
+	input[11] = 0;
+
+	ret = hid_hw_raw_request(hdev, T4_FEATURE_REPORT_ID, input,
+			T4_FEATURE_REPORT_LEN,
+			HID_FEATURE_REPORT, HID_REQ_SET_REPORT);
+
+	if (ret < 0) {
+		dev_err(&hdev->dev, "failed to read command (%d)\n", ret);
+		goto exit;
+	}
+
+	readbuf = kzalloc(T4_FEATURE_REPORT_LEN, GFP_KERNEL);
+	if (read_flag) {
+		if (!readbuf) {
+			ret = -ENOMEM;
+			goto exit;
+		}
+
+		ret = hid_hw_raw_request(hdev, T4_FEATURE_REPORT_ID, readbuf,
+				T4_FEATURE_REPORT_LEN,
+				HID_FEATURE_REPORT, HID_REQ_GET_REPORT);
+		if (ret < 0) {
+			dev_err(&hdev->dev, "failed read register (%d)\n", ret);
+			goto exit_readbuf;
+		}
+
+		if (*(u32 *)&readbuf[6] != address) {
+			dev_err(&hdev->dev, "read register address error (%x,%x)\n",
+			*(u32 *)&readbuf[6], address);
+			goto exit_readbuf;
+		}
+
+		if (*(u16 *)&readbuf[10] != 1) {
+			dev_err(&hdev->dev, "read register size error (%x)\n",
+			*(u16 *)&readbuf[10]);
+			goto exit_readbuf;
+		}
+
+		check_sum = t4_calc_check_sum(readbuf, 6, 7);
+		if (*(u16 *)&readbuf[13] != check_sum) {
+			dev_err(&hdev->dev, "read register checksum error (%x,%x)\n",
+			*(u16 *)&readbuf[13], check_sum);
+			goto exit_readbuf;
+		}
+
+		*read_val = readbuf[12];
+	}
+
+	ret = 0;
+
+exit_readbuf:
+	kfree(readbuf);
+exit:
+	kfree(input);
+	return ret;
+}
+
 static int u1_read_write_register(struct hid_device *hdev, u32 address,
 	u8 *read_val, u8 write_val, bool read_flag)
 {
@@ -159,21 +317,60 @@ static int u1_read_write_register(struct hid_device *hdev, u32 address,
 	return ret;
 }
 
-static int alps_raw_event(struct hid_device *hdev,
-		struct hid_report *report, u8 *data, int size)
+static int t4_raw_event(struct alps_dev *hdata, u8 *data, int size)
+{
+	unsigned int x, y, z;
+	int i;
+	struct t4_input_report *p_report = (struct t4_input_report *)data;
+
+	if (!data)
+		return 0;
+	for (i = 0; i < hdata->max_fingers; i++) {
+		x = p_report->contact[i].x_hi << 8 | p_report->contact[i].x_lo;
+		y = p_report->contact[i].y_hi << 8 | p_report->contact[i].y_lo;
+		y = hdata->y_max - y + hdata->y_min;
+		z = (p_report->contact[i].palm < 0x80 &&
+			p_report->contact[i].palm > 0) * 62;
+		if (x == 0xffff) {
+			x = 0;
+			y = 0;
+			z = 0;
+		}
+		input_mt_slot(hdata->input, i);
+
+		input_mt_report_slot_state(hdata->input,
+			MT_TOOL_FINGER, z != 0);
+
+		if (!z)
+			continue;
+
+		input_report_abs(hdata->input, ABS_MT_POSITION_X, x);
+		input_report_abs(hdata->input, ABS_MT_POSITION_Y, y);
+		input_report_abs(hdata->input, ABS_MT_PRESSURE, z);
+	}
+	input_mt_sync_frame(hdata->input);
+
+	input_report_key(hdata->input, BTN_LEFT, p_report->button);
+
+	input_sync(hdata->input);
+	return 1;
+}
+
+static int u1_raw_event(struct alps_dev *hdata, u8 *data, int size)
 {
 	unsigned int x, y, z;
 	int i;
 	short sp_x, sp_y;
-	struct u1_dev *hdata = hid_get_drvdata(hdev);
 
+	if (!data)
+		return 0;
 	switch (data[0]) {
 	case U1_MOUSE_REPORT_ID:
 		break;
 	case U1_FEATURE_REPORT_ID:
 		break;
 	case U1_ABSOLUTE_REPORT_ID:
-		for (i = 0; i < MAX_TOUCHES; i++) {
+		for (i = 0; i < hdata->max_fingers; i++) {
 			u8 *contact = &data[i * 5];
 
 			x = get_unaligned_le16(contact + 3);
@@ -235,21 +432,52 @@ static int alps_raw_event(struct hid_device *hdev,
 	return 0;
 }
 
-#ifdef CONFIG_PM
-static int alps_post_reset(struct hid_device *hdev)
+static int alps_raw_event(struct hid_device *hdev,
+		struct hid_report *report, u8 *data, int size)
 {
-	return u1_read_write_register(hdev, ADDRESS_U1_DEV_CTRL_1,
-				NULL, U1_TP_ABS_MODE | U1_SP_ABS_MODE, false);
+	int ret = 0;
+	struct alps_dev *hdata = hid_get_drvdata(hdev);
+
+	switch (hdev->product) {
+	case HID_PRODUCT_ID_T4_BTNLESS:
+		ret = t4_raw_event(hdata, data, size);
+		break;
+	default:
+		ret = u1_raw_event(hdata, data, size);
+		break;
+	}
+	return ret;
 }
 
-static int alps_post_resume(struct hid_device *hdev)
+static int __maybe_unused alps_post_reset(struct hid_device *hdev)
 {
-	return u1_read_write_register(hdev, ADDRESS_U1_DEV_CTRL_1,
-				NULL, U1_TP_ABS_MODE | U1_SP_ABS_MODE, false);
+	int ret = -1;
+	struct alps_dev *data = hid_get_drvdata(hdev);
+
+	switch (data->dev_type) {
+	case T4:
+		ret = t4_read_write_register(hdev, T4_PRM_FEED_CONFIG_1,
+			NULL, T4_I2C_ABS, false);
+		ret = t4_read_write_register(hdev, T4_PRM_FEED_CONFIG_4,
+			NULL, T4_FEEDCFG4_ADVANCED_ABS_ENABLE, false);
+		break;
+	case U1:
+		ret = u1_read_write_register(hdev,
+			ADDRESS_U1_DEV_CTRL_1, NULL,
+			U1_TP_ABS_MODE | U1_SP_ABS_MODE, false);
+		break;
+	default:
+		break;
+	}
+	return ret;
+}
+
+static int __maybe_unused alps_post_resume(struct hid_device *hdev)
+{
+	return alps_post_reset(hdev);
 }
-#endif /* CONFIG_PM */
 
-static int u1_init(struct hid_device *hdev, struct u1_dev *pri_data)
+static int u1_init(struct hid_device *hdev, struct alps_dev *pri_data)
 {
 	int ret;
 	u8 tmp, dev_ctrl, sen_line_num_x, sen_line_num_y;
@@ -361,9 +589,60 @@ static int u1_init(struct hid_device *hdev, struct u1_dev *pri_data)
 	return ret;
 }
 
+static int T4_init(struct hid_device *hdev, struct alps_dev *pri_data)
+{
+	int ret;
+	u8 tmp, sen_line_num_x, sen_line_num_y;
+
+	ret = t4_read_write_register(hdev, T4_PRM_ID_CONFIG_3, &tmp, 0, true);
+	if (ret < 0) {
+		dev_err(&hdev->dev, "failed T4_PRM_ID_CONFIG_3 (%d)\n", ret);
+		goto exit;
+	}
+	sen_line_num_x = 16 + ((tmp & 0x0F)  | (tmp & 0x08 ? 0xF0 : 0));
+	sen_line_num_y = 12 + (((tmp & 0xF0) >> 4)  | (tmp & 0x80 ? 0xF0 : 0));
+
+	pri_data->x_max = sen_line_num_x * T4_COUNT_PER_ELECTRODE;
+	pri_data->x_min = T4_COUNT_PER_ELECTRODE;
+	pri_data->y_max = sen_line_num_y * T4_COUNT_PER_ELECTRODE;
+	pri_data->y_min = T4_COUNT_PER_ELECTRODE;
+	pri_data->x_active_len_mm = pri_data->y_active_len_mm = 0;
+	pri_data->btn_cnt = 1;
+
+	ret = t4_read_write_register(hdev, PRM_SYS_CONFIG_1, &tmp, 0, true);
+	if (ret < 0) {
+		dev_err(&hdev->dev, "failed PRM_SYS_CONFIG_1 (%d)\n", ret);
+		goto exit;
+	}
+	tmp |= 0x02;
+	ret = t4_read_write_register(hdev, PRM_SYS_CONFIG_1, NULL, tmp, false);
+	if (ret < 0) {
+		dev_err(&hdev->dev, "failed PRM_SYS_CONFIG_1 (%d)\n", ret);
+		goto exit;
+	}
+
+	ret = t4_read_write_register(hdev, T4_PRM_FEED_CONFIG_1,
+					NULL, T4_I2C_ABS, false);
+	if (ret < 0) {
+		dev_err(&hdev->dev, "failed T4_PRM_FEED_CONFIG_1 (%d)\n", ret);
+		goto exit;
+	}
+
+	ret = t4_read_write_register(hdev, T4_PRM_FEED_CONFIG_4, NULL,
+				T4_FEEDCFG4_ADVANCED_ABS_ENABLE, false);
+	if (ret < 0) {
+		dev_err(&hdev->dev, "failed T4_PRM_FEED_CONFIG_4 (%d)\n", ret);
+		goto exit;
+	}
+	pri_data->max_fingers = 5;
+	pri_data->has_sp = 0;
+exit:
+	return ret;
+}
+
 static int alps_input_configured(struct hid_device *hdev, struct hid_input *hi)
 {
-	struct u1_dev *data = hid_get_drvdata(hdev);
+	struct alps_dev *data = hid_get_drvdata(hdev);
 	struct input_dev *input = hi->input, *input2;
 	int ret;
 	int res_x, res_y, i;
@@ -377,8 +656,16 @@ static int alps_input_configured(struct hid_device *hdev, struct hid_input *hi)
 
 	/* Allow incoming hid reports */
 	hid_device_io_start(hdev);
-
-	ret = u1_init(hdev, data);
+	switch (data->dev_type) {
+	case T4:
+		ret = T4_init(hdev, data);
+		break;
+	case U1:
+		ret = u1_init(hdev, data);
+		break;
+	default:
+		break;
+	}
 
 	if (ret)
 		goto exit;
@@ -458,10 +745,9 @@ static int alps_input_mapping(struct hid_device *hdev,
 
 static int alps_probe(struct hid_device *hdev, const struct hid_device_id *id)
 {
-	struct u1_dev *data = NULL;
+	struct alps_dev *data = NULL;
 	int ret;
-
-	data = devm_kzalloc(&hdev->dev, sizeof(struct u1_dev), GFP_KERNEL);
+	data = devm_kzalloc(&hdev->dev, sizeof(struct alps_dev), GFP_KERNEL);
 	if (!data)
 		return -ENOMEM;
 
@@ -476,6 +762,17 @@ static int alps_probe(struct hid_device *hdev, const struct hid_device_id *id)
 		return ret;
 	}
 
+	switch (hdev->product) {
+	case HID_DEVICE_ID_ALPS_T4_BTNLESS:
+		data->dev_type = T4;
+		break;
+	case HID_DEVICE_ID_ALPS_U1_DUAL:
+		data->dev_type = U1;
+		break;
+	default:
+		data->dev_type = UNKNOWN;
+	}
+
 	ret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);
 	if (ret) {
 		hid_err(hdev, "hw start failed\n");
@@ -493,6 +790,8 @@ static void alps_remove(struct hid_device *hdev)
 static const struct hid_device_id alps_id[] = {
 	{ HID_DEVICE(HID_BUS_ANY, HID_GROUP_ANY,
 		USB_VENDOR_ID_ALPS_JP, HID_DEVICE_ID_ALPS_U1_DUAL) },
+	{ HID_DEVICE(HID_BUS_ANY, HID_GROUP_ANY,
+		USB_VENDOR_ID_ALPS_JP, HID_DEVICE_ID_ALPS_T4_BTNLESS) },
 	{ }
 };
 MODULE_DEVICE_TABLE(hid, alps_id);

commit 5992262d59ccbfaa86ea8b10122653429685b3f9
Author: Masaki Ota <masaki.ota@jp.alps.com>
Date:   Fri Oct 6 11:53:16 2017 +0900

    HID: alps: remove variables local to u1_init() from the device struct
    
    Move dev_ctrl, dev_type, sen_line_num_x, sen_line_num_y, pitch_x, pitch_y,
    resolution, btn_info from u1_dev structure to "u1_init()", because these
    variables are only used in there.
    
    [jkosina@suse.cz: rewrite changelog]
    Signed-off-by: Masaki Ota <masaki.ota@jp.alps.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-alps.c b/drivers/hid/hid-alps.c
index 201fe175cba3..4c323b58e009 100644
--- a/drivers/hid/hid-alps.c
+++ b/drivers/hid/hid-alps.c
@@ -61,14 +61,10 @@
  * @input2: pointer to the kernel input2 device
  * @hdev: pointer to the struct hid_device
  *
- * @dev_ctrl: device control parameter
  * @dev_type: device type
- * @sen_line_num_x: number of sensor line of X
- * @sen_line_num_y: number of sensor line of Y
- * @pitch_x: sensor pitch of X
- * @pitch_y: sensor pitch of Y
- * @resolution: resolution
- * @btn_info: button information
+ * @max_fingers: total number of fingers
+ * @has_sp: boolean of sp existense
+ * @sp_btn_info: button information
  * @x_active_len_mm: active area length of X (mm)
  * @y_active_len_mm: active area length of Y (mm)
  * @x_max: maximum x coordinate value
@@ -77,22 +73,14 @@
  * @y_min: minimum y coordinate value
  * @btn_cnt: number of buttons
  * @sp_btn_cnt: number of stick buttons
- * @has_sp: boolean of sp existense
- * @max_fingers: total number of fingers
  */
 struct u1_dev {
 	struct input_dev *input;
 	struct input_dev *input2;
 	struct hid_device *hdev;
 
-	u8	dev_ctrl;
-	u8	dev_type;
-	u8	sen_line_num_x;
-	u8	sen_line_num_y;
-	u8	pitch_x;
-	u8	pitch_y;
-	u8	resolution;
-	u8	btn_info;
+	u8  max_fingers;
+	u8  has_sp;
 	u8	sp_btn_info;
 	u32	x_active_len_mm;
 	u32	y_active_len_mm;
@@ -102,8 +90,6 @@ struct u1_dev {
 	u32	y_min;
 	u32	btn_cnt;
 	u32	sp_btn_cnt;
-	u8	has_sp;
-	u8	max_fingers;
 };
 
 static int u1_read_write_register(struct hid_device *hdev, u32 address,
@@ -266,78 +252,80 @@ static int alps_post_resume(struct hid_device *hdev)
 static int u1_init(struct hid_device *hdev, struct u1_dev *pri_data)
 {
 	int ret;
+	u8 tmp, dev_ctrl, sen_line_num_x, sen_line_num_y;
+	u8 pitch_x, pitch_y, resolution;
 
 	/* Device initialization */
 	ret = u1_read_write_register(hdev, ADDRESS_U1_DEV_CTRL_1,
-			&pri_data->dev_ctrl, 0, true);
+			&dev_ctrl, 0, true);
 	if (ret < 0) {
 		dev_err(&hdev->dev, "failed U1_DEV_CTRL_1 (%d)\n", ret);
 		goto exit;
 	}
 
-	pri_data->dev_ctrl &= ~U1_DISABLE_DEV;
-	pri_data->dev_ctrl |= U1_TP_ABS_MODE;
+	dev_ctrl &= ~U1_DISABLE_DEV;
+	dev_ctrl |= U1_TP_ABS_MODE;
 	ret = u1_read_write_register(hdev, ADDRESS_U1_DEV_CTRL_1,
-			NULL, pri_data->dev_ctrl, false);
+			NULL, dev_ctrl, false);
 	if (ret < 0) {
 		dev_err(&hdev->dev, "failed to change TP mode (%d)\n", ret);
 		goto exit;
 	}
 
 	ret = u1_read_write_register(hdev, ADDRESS_U1_NUM_SENS_X,
-			&pri_data->sen_line_num_x, 0, true);
+			&sen_line_num_x, 0, true);
 	if (ret < 0) {
 		dev_err(&hdev->dev, "failed U1_NUM_SENS_X (%d)\n", ret);
 		goto exit;
 	}
 
 	ret = u1_read_write_register(hdev, ADDRESS_U1_NUM_SENS_Y,
-			&pri_data->sen_line_num_y, 0, true);
+			&sen_line_num_y, 0, true);
 		if (ret < 0) {
 		dev_err(&hdev->dev, "failed U1_NUM_SENS_Y (%d)\n", ret);
 		goto exit;
 	}
 
 	ret = u1_read_write_register(hdev, ADDRESS_U1_PITCH_SENS_X,
-			&pri_data->pitch_x, 0, true);
+			&pitch_x, 0, true);
 	if (ret < 0) {
 		dev_err(&hdev->dev, "failed U1_PITCH_SENS_X (%d)\n", ret);
 		goto exit;
 	}
 
 	ret = u1_read_write_register(hdev, ADDRESS_U1_PITCH_SENS_Y,
-			&pri_data->pitch_y, 0, true);
+			&pitch_y, 0, true);
 	if (ret < 0) {
 		dev_err(&hdev->dev, "failed U1_PITCH_SENS_Y (%d)\n", ret);
 		goto exit;
 	}
 
 	ret = u1_read_write_register(hdev, ADDRESS_U1_RESO_DWN_ABS,
-		&pri_data->resolution, 0, true);
+		&resolution, 0, true);
 	if (ret < 0) {
 		dev_err(&hdev->dev, "failed U1_RESO_DWN_ABS (%d)\n", ret);
 		goto exit;
 	}
 	pri_data->x_active_len_mm =
-		(pri_data->pitch_x * (pri_data->sen_line_num_x - 1)) / 10;
+		(pitch_x * (sen_line_num_x - 1)) / 10;
 	pri_data->y_active_len_mm =
-		(pri_data->pitch_y * (pri_data->sen_line_num_y - 1)) / 10;
+		(pitch_y * (sen_line_num_y - 1)) / 10;
 
 	pri_data->x_max =
-		(pri_data->resolution << 2) * (pri_data->sen_line_num_x - 1);
+		(resolution << 2) * (sen_line_num_x - 1);
 	pri_data->x_min = 1;
 	pri_data->y_max =
-		(pri_data->resolution << 2) * (pri_data->sen_line_num_y - 1);
+		(resolution << 2) * (sen_line_num_y - 1);
 	pri_data->y_min = 1;
 
 	ret = u1_read_write_register(hdev, ADDRESS_U1_PAD_BTN,
-			&pri_data->btn_info, 0, true);
+			&tmp, 0, true);
 	if (ret < 0) {
 		dev_err(&hdev->dev, "failed U1_PAD_BTN (%d)\n", ret);
 		goto exit;
 	}
-	if ((pri_data->btn_info & 0x0F) == (pri_data->btn_info & 0xF0) >> 4) {
-		pri_data->btn_cnt = (pri_data->btn_info & 0x0F);
+	if ((tmp & 0x0F) == (tmp & 0xF0) >> 4) {
+		pri_data->btn_cnt = (tmp & 0x0F);
 	} else {
 		/* Button pad */
 		pri_data->btn_cnt = 1;
@@ -346,16 +334,15 @@ static int u1_init(struct hid_device *hdev, struct u1_dev *pri_data)
 	pri_data->has_sp = 0;
 	/* Check StickPointer device */
 	ret = u1_read_write_register(hdev, ADDRESS_U1_DEVICE_TYP,
-			&pri_data->dev_type, 0, true);
+			&tmp, 0, true);
 	if (ret < 0) {
 		dev_err(&hdev->dev, "failed U1_DEVICE_TYP (%d)\n", ret);
 		goto exit;
 	}
-
-	if (pri_data->dev_type & U1_DEVTYPE_SP_SUPPORT) {
-		pri_data->dev_ctrl |= U1_SP_ABS_MODE;
+	if (tmp & U1_DEVTYPE_SP_SUPPORT) {
+		dev_ctrl |= U1_SP_ABS_MODE;
 		ret = u1_read_write_register(hdev, ADDRESS_U1_DEV_CTRL_1,
-			NULL, pri_data->dev_ctrl, false);
+			NULL, dev_ctrl, false);
 		if (ret < 0) {
 			dev_err(&hdev->dev, "failed SP mode (%d)\n", ret);
 			goto exit;

commit c7083d3f53482e8a2a6ee1238fbedfa7dbea7b3c
Author: Masaki Ota <masaki.ota@jp.alps.com>
Date:   Fri Oct 6 11:53:15 2017 +0900

    HID: alps: properly handle max_fingers and minimum on X and Y axis
    
    Create x_min, y_min and max_fingers variables for set correct XY minimum value
    and the number of max finger on each devices.
    
    [jkosina@suse.cz: update shortlog]
    Signed-off-by: Masaki Ota <masaki.ota@jp.alps.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-alps.c b/drivers/hid/hid-alps.c
index c4ea5c6c9be9..201fe175cba3 100644
--- a/drivers/hid/hid-alps.c
+++ b/drivers/hid/hid-alps.c
@@ -73,9 +73,12 @@
  * @y_active_len_mm: active area length of Y (mm)
  * @x_max: maximum x coordinate value
  * @y_max: maximum y coordinate value
+ * @x_min: minimum x coordinate value
+ * @y_min: minimum y coordinate value
  * @btn_cnt: number of buttons
  * @sp_btn_cnt: number of stick buttons
  * @has_sp: boolean of sp existense
+ * @max_fingers: total number of fingers
  */
 struct u1_dev {
 	struct input_dev *input;
@@ -95,9 +98,12 @@ struct u1_dev {
 	u32	y_active_len_mm;
 	u32	x_max;
 	u32	y_max;
+	u32	x_min;
+	u32	y_min;
 	u32	btn_cnt;
 	u32	sp_btn_cnt;
 	u8	has_sp;
+	u8	max_fingers;
 };
 
 static int u1_read_write_register(struct hid_device *hdev, u32 address,
@@ -319,8 +325,10 @@ static int u1_init(struct hid_device *hdev, struct u1_dev *pri_data)
 
 	pri_data->x_max =
 		(pri_data->resolution << 2) * (pri_data->sen_line_num_x - 1);
+	pri_data->x_min = 1;
 	pri_data->y_max =
 		(pri_data->resolution << 2) * (pri_data->sen_line_num_y - 1);
+	pri_data->y_min = 1;
 
 	ret = u1_read_write_register(hdev, ADDRESS_U1_PAD_BTN,
 			&pri_data->btn_info, 0, true);
@@ -328,6 +336,12 @@ static int u1_init(struct hid_device *hdev, struct u1_dev *pri_data)
 		dev_err(&hdev->dev, "failed U1_PAD_BTN (%d)\n", ret);
 		goto exit;
 	}
+	if ((pri_data->btn_info & 0x0F) == (pri_data->btn_info & 0xF0) >> 4) {
+		pri_data->btn_cnt = (pri_data->btn_info & 0x0F);
+	} else {
+		/* Button pad */
+		pri_data->btn_cnt = 1;
+	}
 
 	pri_data->has_sp = 0;
 	/* Check StickPointer device */
@@ -355,7 +369,7 @@ static int u1_init(struct hid_device *hdev, struct u1_dev *pri_data)
 		}
 		pri_data->has_sp = 1;
 	}
-
+	pri_data->max_fingers = 5;
 exit:
 	return ret;
 }
@@ -383,8 +397,10 @@ static int alps_input_configured(struct hid_device *hdev, struct hid_input *hi)
 		goto exit;
 
 	__set_bit(EV_ABS, input->evbit);
-	input_set_abs_params(input, ABS_MT_POSITION_X, 1, data->x_max, 0, 0);
-	input_set_abs_params(input, ABS_MT_POSITION_Y, 1, data->y_max, 0, 0);
+	input_set_abs_params(input, ABS_MT_POSITION_X,
+						data->x_min, data->x_max, 0, 0);
+	input_set_abs_params(input, ABS_MT_POSITION_Y,
+						data->y_min, data->y_max, 0, 0);
 
 	if (data->x_active_len_mm && data->y_active_len_mm) {
 		res_x = (data->x_max - 1) / data->x_active_len_mm;
@@ -396,26 +412,21 @@ static int alps_input_configured(struct hid_device *hdev, struct hid_input *hi)
 
 	input_set_abs_params(input, ABS_MT_PRESSURE, 0, 64, 0, 0);
 
-	input_mt_init_slots(input, MAX_TOUCHES, INPUT_MT_POINTER);
+	input_mt_init_slots(input, data->max_fingers, INPUT_MT_POINTER);
 
 	__set_bit(EV_KEY, input->evbit);
-	if ((data->btn_info & 0x0F) == (data->btn_info & 0xF0) >> 4) {
-		data->btn_cnt = (data->btn_info & 0x0F);
-	} else {
-		/* Button pad */
-		data->btn_cnt = 1;
+
+	if (data->btn_cnt == 1)
 		__set_bit(INPUT_PROP_BUTTONPAD, input->propbit);
-	}
 
 	for (i = 0; i < data->btn_cnt; i++)
 		__set_bit(BTN_LEFT + i, input->keybit);
 
-
 	/* Stick device initialization */
 	if (data->has_sp) {
 		input2 = input_allocate_device();
 		if (!input2) {
-			ret = -ENOMEM;
+			input_free_device(input2);
 			goto exit;
 		}
 
@@ -439,8 +450,7 @@ static int alps_input_configured(struct hid_device *hdev, struct hid_input *hi)
 		__set_bit(INPUT_PROP_POINTER, input2->propbit);
 		__set_bit(INPUT_PROP_POINTING_STICK, input2->propbit);
 
-		ret = input_register_device(data->input2);
-		if (ret) {
+		if (input_register_device(data->input2)) {
 			input_free_device(input2);
 			goto exit;
 		}

commit 5d8c720d3b74413cc62d5015f23f57a51dc06112
Author: Masaki Ota <masaki.ota@jp.alps.com>
Date:   Fri Oct 6 11:53:14 2017 +0900

    HID: alps: Separate U1 device code
    
    Create 'static int u1_init()' and factor out U1 device initialization code from
    main initialization and introduce per-device 'has_sp' flag.
    
    [jkosina@suse.cz: rewrite changelog]
    Signed-off-by: Masaki Ota <masaki.ota@jp.alps.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-alps.c b/drivers/hid/hid-alps.c
index 519bfcf9eaf0..c4ea5c6c9be9 100644
--- a/drivers/hid/hid-alps.c
+++ b/drivers/hid/hid-alps.c
@@ -75,6 +75,7 @@
  * @y_max: maximum y coordinate value
  * @btn_cnt: number of buttons
  * @sp_btn_cnt: number of stick buttons
+ * @has_sp: boolean of sp existense
  */
 struct u1_dev {
 	struct input_dev *input;
@@ -96,6 +97,7 @@ struct u1_dev {
 	u32	y_max;
 	u32	btn_cnt;
 	u32	sp_btn_cnt;
+	u8	has_sp;
 };
 
 static int u1_read_write_register(struct hid_device *hdev, u32 address,
@@ -255,99 +257,130 @@ static int alps_post_resume(struct hid_device *hdev)
 }
 #endif /* CONFIG_PM */
 
-static int alps_input_configured(struct hid_device *hdev, struct hid_input *hi)
+static int u1_init(struct hid_device *hdev, struct u1_dev *pri_data)
 {
-	struct u1_dev *data = hid_get_drvdata(hdev);
-	struct input_dev *input = hi->input, *input2;
 	int ret;
-	int res_x, res_y, i;
-
-	data->input = input;
-
-	hid_dbg(hdev, "Opening low level driver\n");
-	ret = hid_hw_open(hdev);
-	if (ret)
-		return ret;
-
-	/* Allow incoming hid reports */
-	hid_device_io_start(hdev);
 
 	/* Device initialization */
 	ret = u1_read_write_register(hdev, ADDRESS_U1_DEV_CTRL_1,
-			&data->dev_ctrl, 0, true);
+			&pri_data->dev_ctrl, 0, true);
 	if (ret < 0) {
 		dev_err(&hdev->dev, "failed U1_DEV_CTRL_1 (%d)\n", ret);
 		goto exit;
 	}
 
-	data->dev_ctrl &= ~U1_DISABLE_DEV;
-	data->dev_ctrl |= U1_TP_ABS_MODE;
+	pri_data->dev_ctrl &= ~U1_DISABLE_DEV;
+	pri_data->dev_ctrl |= U1_TP_ABS_MODE;
 	ret = u1_read_write_register(hdev, ADDRESS_U1_DEV_CTRL_1,
-			NULL, data->dev_ctrl, false);
+			NULL, pri_data->dev_ctrl, false);
 	if (ret < 0) {
 		dev_err(&hdev->dev, "failed to change TP mode (%d)\n", ret);
 		goto exit;
 	}
 
 	ret = u1_read_write_register(hdev, ADDRESS_U1_NUM_SENS_X,
-			&data->sen_line_num_x, 0, true);
+			&pri_data->sen_line_num_x, 0, true);
 	if (ret < 0) {
 		dev_err(&hdev->dev, "failed U1_NUM_SENS_X (%d)\n", ret);
 		goto exit;
 	}
 
 	ret = u1_read_write_register(hdev, ADDRESS_U1_NUM_SENS_Y,
-			&data->sen_line_num_y, 0, true);
+			&pri_data->sen_line_num_y, 0, true);
 		if (ret < 0) {
 		dev_err(&hdev->dev, "failed U1_NUM_SENS_Y (%d)\n", ret);
 		goto exit;
 	}
 
 	ret = u1_read_write_register(hdev, ADDRESS_U1_PITCH_SENS_X,
-			&data->pitch_x, 0, true);
+			&pri_data->pitch_x, 0, true);
 	if (ret < 0) {
 		dev_err(&hdev->dev, "failed U1_PITCH_SENS_X (%d)\n", ret);
 		goto exit;
 	}
 
 	ret = u1_read_write_register(hdev, ADDRESS_U1_PITCH_SENS_Y,
-			&data->pitch_y, 0, true);
+			&pri_data->pitch_y, 0, true);
 	if (ret < 0) {
 		dev_err(&hdev->dev, "failed U1_PITCH_SENS_Y (%d)\n", ret);
 		goto exit;
 	}
 
 	ret = u1_read_write_register(hdev, ADDRESS_U1_RESO_DWN_ABS,
-		&data->resolution, 0, true);
+		&pri_data->resolution, 0, true);
 	if (ret < 0) {
 		dev_err(&hdev->dev, "failed U1_RESO_DWN_ABS (%d)\n", ret);
 		goto exit;
 	}
+	pri_data->x_active_len_mm =
+		(pri_data->pitch_x * (pri_data->sen_line_num_x - 1)) / 10;
+	pri_data->y_active_len_mm =
+		(pri_data->pitch_y * (pri_data->sen_line_num_y - 1)) / 10;
+
+	pri_data->x_max =
+		(pri_data->resolution << 2) * (pri_data->sen_line_num_x - 1);
+	pri_data->y_max =
+		(pri_data->resolution << 2) * (pri_data->sen_line_num_y - 1);
 
 	ret = u1_read_write_register(hdev, ADDRESS_U1_PAD_BTN,
-			&data->btn_info, 0, true);
+			&pri_data->btn_info, 0, true);
 	if (ret < 0) {
 		dev_err(&hdev->dev, "failed U1_PAD_BTN (%d)\n", ret);
 		goto exit;
 	}
 
+	pri_data->has_sp = 0;
 	/* Check StickPointer device */
 	ret = u1_read_write_register(hdev, ADDRESS_U1_DEVICE_TYP,
-			&data->dev_type, 0, true);
+			&pri_data->dev_type, 0, true);
 	if (ret < 0) {
 		dev_err(&hdev->dev, "failed U1_DEVICE_TYP (%d)\n", ret);
 		goto exit;
 	}
 
-	data->x_active_len_mm =
-		(data->pitch_x * (data->sen_line_num_x - 1)) / 10;
-	data->y_active_len_mm =
-		(data->pitch_y * (data->sen_line_num_y - 1)) / 10;
+	if (pri_data->dev_type & U1_DEVTYPE_SP_SUPPORT) {
+		pri_data->dev_ctrl |= U1_SP_ABS_MODE;
+		ret = u1_read_write_register(hdev, ADDRESS_U1_DEV_CTRL_1,
+			NULL, pri_data->dev_ctrl, false);
+		if (ret < 0) {
+			dev_err(&hdev->dev, "failed SP mode (%d)\n", ret);
+			goto exit;
+		}
+
+		ret = u1_read_write_register(hdev, ADDRESS_U1_SP_BTN,
+			&pri_data->sp_btn_info, 0, true);
+		if (ret < 0) {
+			dev_err(&hdev->dev, "failed U1_SP_BTN (%d)\n", ret);
+			goto exit;
+		}
+		pri_data->has_sp = 1;
+	}
 
-	data->x_max =
-		(data->resolution << 2) * (data->sen_line_num_x - 1);
-	data->y_max =
-		(data->resolution << 2) * (data->sen_line_num_y - 1);
+exit:
+	return ret;
+}
+
+static int alps_input_configured(struct hid_device *hdev, struct hid_input *hi)
+{
+	struct u1_dev *data = hid_get_drvdata(hdev);
+	struct input_dev *input = hi->input, *input2;
+	int ret;
+	int res_x, res_y, i;
+
+	data->input = input;
+
+	hid_dbg(hdev, "Opening low level driver\n");
+	ret = hid_hw_open(hdev);
+	if (ret)
+		return ret;
+
+	/* Allow incoming hid reports */
+	hid_device_io_start(hdev);
+
+	ret = u1_init(hdev, data);
+
+	if (ret)
+		goto exit;
 
 	__set_bit(EV_ABS, input->evbit);
 	input_set_abs_params(input, ABS_MT_POSITION_X, 1, data->x_max, 0, 0);
@@ -379,8 +412,7 @@ static int alps_input_configured(struct hid_device *hdev, struct hid_input *hi)
 
 
 	/* Stick device initialization */
-	if (data->dev_type & U1_DEVTYPE_SP_SUPPORT) {
-
+	if (data->has_sp) {
 		input2 = input_allocate_device();
 		if (!input2) {
 			ret = -ENOMEM;
@@ -388,24 +420,6 @@ static int alps_input_configured(struct hid_device *hdev, struct hid_input *hi)
 		}
 
 		data->input2 = input2;
-
-		data->dev_ctrl |= U1_SP_ABS_MODE;
-		ret = u1_read_write_register(hdev, ADDRESS_U1_DEV_CTRL_1,
-			NULL, data->dev_ctrl, false);
-		if (ret < 0) {
-			dev_err(&hdev->dev, "failed SP mode (%d)\n", ret);
-			input_free_device(input2);
-			goto exit;
-		}
-
-		ret = u1_read_write_register(hdev, ADDRESS_U1_SP_BTN,
-			&data->sp_btn_info, 0, true);
-		if (ret < 0) {
-			dev_err(&hdev->dev, "failed U1_SP_BTN (%d)\n", ret);
-			input_free_device(input2);
-			goto exit;
-		}
-
 		input2->phys = input->phys;
 		input2->name = "DualPoint Stick";
 		input2->id.bustype = BUS_I2C;

commit ce6abcf83bf451159f421fe4f928147a882ec9da
Author: Masaki Ota <masaki.ota@jp.alps.com>
Date:   Fri Oct 6 11:53:13 2017 +0900

    HID: alps: delete unnecessary struct u1_dev devInfo
    
    Delete "struct u1_dev devInfo" structure, because u1_dev structure is already
    declared as "struct u1_dev *data".
    
    [jkosina@suse.cz: rewrite changelog]
    Signed-off-by: Masaki Ota <masaki.ota@jp.alps.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-alps.c b/drivers/hid/hid-alps.c
index ed9c0ea5b026..519bfcf9eaf0 100644
--- a/drivers/hid/hid-alps.c
+++ b/drivers/hid/hid-alps.c
@@ -259,7 +259,6 @@ static int alps_input_configured(struct hid_device *hdev, struct hid_input *hi)
 {
 	struct u1_dev *data = hid_get_drvdata(hdev);
 	struct input_dev *input = hi->input, *input2;
-	struct u1_dev devInfo;
 	int ret;
 	int res_x, res_y, i;
 
@@ -275,58 +274,58 @@ static int alps_input_configured(struct hid_device *hdev, struct hid_input *hi)
 
 	/* Device initialization */
 	ret = u1_read_write_register(hdev, ADDRESS_U1_DEV_CTRL_1,
-			&devInfo.dev_ctrl, 0, true);
+			&data->dev_ctrl, 0, true);
 	if (ret < 0) {
 		dev_err(&hdev->dev, "failed U1_DEV_CTRL_1 (%d)\n", ret);
 		goto exit;
 	}
 
-	devInfo.dev_ctrl &= ~U1_DISABLE_DEV;
-	devInfo.dev_ctrl |= U1_TP_ABS_MODE;
+	data->dev_ctrl &= ~U1_DISABLE_DEV;
+	data->dev_ctrl |= U1_TP_ABS_MODE;
 	ret = u1_read_write_register(hdev, ADDRESS_U1_DEV_CTRL_1,
-			NULL, devInfo.dev_ctrl, false);
+			NULL, data->dev_ctrl, false);
 	if (ret < 0) {
 		dev_err(&hdev->dev, "failed to change TP mode (%d)\n", ret);
 		goto exit;
 	}
 
 	ret = u1_read_write_register(hdev, ADDRESS_U1_NUM_SENS_X,
-			&devInfo.sen_line_num_x, 0, true);
+			&data->sen_line_num_x, 0, true);
 	if (ret < 0) {
 		dev_err(&hdev->dev, "failed U1_NUM_SENS_X (%d)\n", ret);
 		goto exit;
 	}
 
 	ret = u1_read_write_register(hdev, ADDRESS_U1_NUM_SENS_Y,
-			&devInfo.sen_line_num_y, 0, true);
+			&data->sen_line_num_y, 0, true);
 		if (ret < 0) {
 		dev_err(&hdev->dev, "failed U1_NUM_SENS_Y (%d)\n", ret);
 		goto exit;
 	}
 
 	ret = u1_read_write_register(hdev, ADDRESS_U1_PITCH_SENS_X,
-			&devInfo.pitch_x, 0, true);
+			&data->pitch_x, 0, true);
 	if (ret < 0) {
 		dev_err(&hdev->dev, "failed U1_PITCH_SENS_X (%d)\n", ret);
 		goto exit;
 	}
 
 	ret = u1_read_write_register(hdev, ADDRESS_U1_PITCH_SENS_Y,
-			&devInfo.pitch_y, 0, true);
+			&data->pitch_y, 0, true);
 	if (ret < 0) {
 		dev_err(&hdev->dev, "failed U1_PITCH_SENS_Y (%d)\n", ret);
 		goto exit;
 	}
 
 	ret = u1_read_write_register(hdev, ADDRESS_U1_RESO_DWN_ABS,
-		&devInfo.resolution, 0, true);
+		&data->resolution, 0, true);
 	if (ret < 0) {
 		dev_err(&hdev->dev, "failed U1_RESO_DWN_ABS (%d)\n", ret);
 		goto exit;
 	}
 
 	ret = u1_read_write_register(hdev, ADDRESS_U1_PAD_BTN,
-			&devInfo.btn_info, 0, true);
+			&data->btn_info, 0, true);
 	if (ret < 0) {
 		dev_err(&hdev->dev, "failed U1_PAD_BTN (%d)\n", ret);
 		goto exit;
@@ -334,29 +333,29 @@ static int alps_input_configured(struct hid_device *hdev, struct hid_input *hi)
 
 	/* Check StickPointer device */
 	ret = u1_read_write_register(hdev, ADDRESS_U1_DEVICE_TYP,
-			&devInfo.dev_type, 0, true);
+			&data->dev_type, 0, true);
 	if (ret < 0) {
 		dev_err(&hdev->dev, "failed U1_DEVICE_TYP (%d)\n", ret);
 		goto exit;
 	}
 
-	devInfo.x_active_len_mm =
-		(devInfo.pitch_x * (devInfo.sen_line_num_x - 1)) / 10;
-	devInfo.y_active_len_mm =
-		(devInfo.pitch_y * (devInfo.sen_line_num_y - 1)) / 10;
+	data->x_active_len_mm =
+		(data->pitch_x * (data->sen_line_num_x - 1)) / 10;
+	data->y_active_len_mm =
+		(data->pitch_y * (data->sen_line_num_y - 1)) / 10;
 
-	devInfo.x_max =
-		(devInfo.resolution << 2) * (devInfo.sen_line_num_x - 1);
-	devInfo.y_max =
-		(devInfo.resolution << 2) * (devInfo.sen_line_num_y - 1);
+	data->x_max =
+		(data->resolution << 2) * (data->sen_line_num_x - 1);
+	data->y_max =
+		(data->resolution << 2) * (data->sen_line_num_y - 1);
 
 	__set_bit(EV_ABS, input->evbit);
-	input_set_abs_params(input, ABS_MT_POSITION_X, 1, devInfo.x_max, 0, 0);
-	input_set_abs_params(input, ABS_MT_POSITION_Y, 1, devInfo.y_max, 0, 0);
+	input_set_abs_params(input, ABS_MT_POSITION_X, 1, data->x_max, 0, 0);
+	input_set_abs_params(input, ABS_MT_POSITION_Y, 1, data->y_max, 0, 0);
 
-	if (devInfo.x_active_len_mm && devInfo.y_active_len_mm) {
-		res_x = (devInfo.x_max - 1) / devInfo.x_active_len_mm;
-		res_y = (devInfo.y_max - 1) / devInfo.y_active_len_mm;
+	if (data->x_active_len_mm && data->y_active_len_mm) {
+		res_x = (data->x_max - 1) / data->x_active_len_mm;
+		res_y = (data->y_max - 1) / data->y_active_len_mm;
 
 		input_abs_set_res(input, ABS_MT_POSITION_X, res_x);
 		input_abs_set_res(input, ABS_MT_POSITION_Y, res_y);
@@ -367,20 +366,20 @@ static int alps_input_configured(struct hid_device *hdev, struct hid_input *hi)
 	input_mt_init_slots(input, MAX_TOUCHES, INPUT_MT_POINTER);
 
 	__set_bit(EV_KEY, input->evbit);
-	if ((devInfo.btn_info & 0x0F) == (devInfo.btn_info & 0xF0) >> 4) {
-		devInfo.btn_cnt = (devInfo.btn_info & 0x0F);
+	if ((data->btn_info & 0x0F) == (data->btn_info & 0xF0) >> 4) {
+		data->btn_cnt = (data->btn_info & 0x0F);
 	} else {
 		/* Button pad */
-		devInfo.btn_cnt = 1;
+		data->btn_cnt = 1;
 		__set_bit(INPUT_PROP_BUTTONPAD, input->propbit);
 	}
 
-	for (i = 0; i < devInfo.btn_cnt; i++)
+	for (i = 0; i < data->btn_cnt; i++)
 		__set_bit(BTN_LEFT + i, input->keybit);
 
 
 	/* Stick device initialization */
-	if (devInfo.dev_type & U1_DEVTYPE_SP_SUPPORT) {
+	if (data->dev_type & U1_DEVTYPE_SP_SUPPORT) {
 
 		input2 = input_allocate_device();
 		if (!input2) {
@@ -390,9 +389,9 @@ static int alps_input_configured(struct hid_device *hdev, struct hid_input *hi)
 
 		data->input2 = input2;
 
-		devInfo.dev_ctrl |= U1_SP_ABS_MODE;
+		data->dev_ctrl |= U1_SP_ABS_MODE;
 		ret = u1_read_write_register(hdev, ADDRESS_U1_DEV_CTRL_1,
-			NULL, devInfo.dev_ctrl, false);
+			NULL, data->dev_ctrl, false);
 		if (ret < 0) {
 			dev_err(&hdev->dev, "failed SP mode (%d)\n", ret);
 			input_free_device(input2);
@@ -400,7 +399,7 @@ static int alps_input_configured(struct hid_device *hdev, struct hid_input *hi)
 		}
 
 		ret = u1_read_write_register(hdev, ADDRESS_U1_SP_BTN,
-			&devInfo.sp_btn_info, 0, true);
+			&data->sp_btn_info, 0, true);
 		if (ret < 0) {
 			dev_err(&hdev->dev, "failed U1_SP_BTN (%d)\n", ret);
 			input_free_device(input2);
@@ -416,8 +415,8 @@ static int alps_input_configured(struct hid_device *hdev, struct hid_input *hi)
 		input2->dev.parent = input->dev.parent;
 
 		__set_bit(EV_KEY, input2->evbit);
-		devInfo.sp_btn_cnt = (devInfo.sp_btn_info & 0x0F);
-		for (i = 0; i < devInfo.sp_btn_cnt; i++)
+		data->sp_btn_cnt = (data->sp_btn_info & 0x0F);
+		for (i = 0; i < data->sp_btn_cnt; i++)
 			__set_bit(BTN_LEFT + i, input2->keybit);
 
 		__set_bit(EV_REL, input2->evbit);

commit 179023e6af0c608ffb505821223f5580853ef6b8
Merge: 04fd4cb0b098 9a54cf462d6f 52dc085a50c6 814cb72e25af 3202bb7fb021 f777a3a7bd44 c4425c8f26aa 6c3f70ac7c6b 1924e05e6014
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Fri Oct 7 09:59:48 2016 +0200

    Merge branches 'for-4.8/upstream-fixes', 'for-4.9/alps', 'for-4.9/hid-input', 'for-4.9/intel-ish', 'for-4.9/kye-uclogic-waltop-fixes', 'for-4.9/logitech', 'for-4.9/sony', 'for-4.9/upstream' and 'for-4.9/wacom' into for-linus

commit 9a54cf462d6f3c383a5a4f5fe15c020a03db44e6
Author: Masaki Ota <012nexus@gmail.com>
Date:   Tue Sep 27 14:04:37 2016 +0900

    HID: alps: fix multitouch cursor issue
    
    Issue reproduction procedure:
    
    1. three or more fingers put on Touchpad.
    2. release fingers from Touchpad.
    3. move the cursor by one finger.
    4. the cursor does not move.
    
    Cause:
    
    We do not notify multi fingers state correctly to input subsystem.  For
    example, when three fingers release from Touchpad, fingers state is 3 -> 0. It
    needs to notify first, second and third finger's releasing state.
    
    Fix this by not breaking out on z axis and move x,y,z input handling
    code to the correct place so that it's in fact per-finger.
    
    [jkosina@suse.cz: reword changelog]
    Signed-off-by: Masaki Ota <masaki.ota@jp.alps.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-alps.c b/drivers/hid/hid-alps.c
index 048befde295a..610df92837bb 100644
--- a/drivers/hid/hid-alps.c
+++ b/drivers/hid/hid-alps.c
@@ -190,16 +190,16 @@ static int alps_raw_event(struct hid_device *hdev,
 			if (z != 0) {
 				input_mt_report_slot_state(hdata->input,
 					MT_TOOL_FINGER, 1);
+				input_report_abs(hdata->input,
+					ABS_MT_POSITION_X, x);
+				input_report_abs(hdata->input,
+					ABS_MT_POSITION_Y, y);
+				input_report_abs(hdata->input,
+					ABS_MT_PRESSURE, z);
 			} else {
 				input_mt_report_slot_state(hdata->input,
 					MT_TOOL_FINGER, 0);
-				break;
 			}
-
-			input_report_abs(hdata->input, ABS_MT_POSITION_X, x);
-			input_report_abs(hdata->input, ABS_MT_POSITION_Y, y);
-			input_report_abs(hdata->input, ABS_MT_PRESSURE, z);
-
 		}
 
 		input_mt_sync_frame(hdata->input);

commit 46a41b512f6800b531e94bdf5f1ca0e226492d91
Author: Wei Yongjun <weiyongjun1@huawei.com>
Date:   Wed Sep 21 15:12:05 2016 +0000

    HID: alps: fix error return code in alps_input_configured()
    
    Fix to return a negative error code from the error handling
    case instead of 0, as done elsewhere in this function.
    
    While at it, remove redundant input_free_device(NULL) call.
    
    [jkosina@suse.cz: ammend changelog]
    Signed-off-by: Wei Yongjun <weiyongjun1@huawei.com>
    Reviewed-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-alps.c b/drivers/hid/hid-alps.c
index 048befde295a..0c18d473a5d8 100644
--- a/drivers/hid/hid-alps.c
+++ b/drivers/hid/hid-alps.c
@@ -383,7 +383,7 @@ static int alps_input_configured(struct hid_device *hdev, struct hid_input *hi)
 
 		input2 = input_allocate_device();
 		if (!input2) {
-			input_free_device(input2);
+			ret = -ENOMEM;
 			goto exit;
 		}
 
@@ -425,7 +425,8 @@ static int alps_input_configured(struct hid_device *hdev, struct hid_input *hi)
 		__set_bit(INPUT_PROP_POINTER, input2->propbit);
 		__set_bit(INPUT_PROP_POINTING_STICK, input2->propbit);
 
-		if (input_register_device(data->input2)) {
+		ret = input_register_device(data->input2);
+		if (ret) {
 			input_free_device(input2);
 			goto exit;
 		}

commit 04fd4cb0b098789725d04e9d4a7e7dda373b1121
Author: Kai-Heng Feng <kai.heng.feng@canonical.com>
Date:   Mon Sep 19 15:41:39 2016 +0800

    HID: alps: fix stick device not working after resume
    
    The stick device does not work after resume, add U1_SP_ABS_MODE flag can
    make the device work after resume.
    
    This has been discovered by pure guesswork, based on how the existing code uses
    U1_TP_ABS_MODE flag on both initialization and resume.
    
    I also tested the the patch on an ALPS touchpad without stick device, did not
    notice any side effect on suspend/resume, so I made the U1_SP_ABS_MODE flag
    mandatory.
    
    [jkosina@suse.cz: made changelog more verbose]
    Signed-off-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-alps.c b/drivers/hid/hid-alps.c
index 2808da9ed9c8..afc847fb2b06 100644
--- a/drivers/hid/hid-alps.c
+++ b/drivers/hid/hid-alps.c
@@ -245,13 +245,13 @@ static int alps_raw_event(struct hid_device *hdev,
 static int alps_post_reset(struct hid_device *hdev)
 {
 	return u1_read_write_register(hdev, ADDRESS_U1_DEV_CTRL_1,
-				NULL, U1_TP_ABS_MODE, false);
+				NULL, U1_TP_ABS_MODE | U1_SP_ABS_MODE, false);
 }
 
 static int alps_post_resume(struct hid_device *hdev)
 {
 	return u1_read_write_register(hdev, ADDRESS_U1_DEV_CTRL_1,
-				NULL, U1_TP_ABS_MODE, false);
+				NULL, U1_TP_ABS_MODE | U1_SP_ABS_MODE, false);
 }
 #endif /* CONFIG_PM */
 

commit 7ee2eaa3641827a9ecdffa190cde31846024d2e3
Author: Axel Lin <axel.lin@ingics.com>
Date:   Sun Sep 11 12:09:01 2016 +0800

    HID: alps: Fix memory leak
    
    A kfree(readbuf) call was missed if hid_hw_raw_request() fails, fix it.
    Also avoid mixing direct return with goto in the error paths.
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Reviewed-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-alps.c b/drivers/hid/hid-alps.c
index 048befde295a..2808da9ed9c8 100644
--- a/drivers/hid/hid-alps.c
+++ b/drivers/hid/hid-alps.c
@@ -139,8 +139,8 @@ static int u1_read_write_register(struct hid_device *hdev, u32 address,
 	if (read_flag) {
 		readbuf = kzalloc(U1_FEATURE_REPORT_LEN, GFP_KERNEL);
 		if (!readbuf) {
-			kfree(input);
-			return -ENOMEM;
+			ret = -ENOMEM;
+			goto exit;
 		}
 
 		ret = hid_hw_raw_request(hdev, U1_FEATURE_REPORT_ID, readbuf,
@@ -149,6 +149,7 @@ static int u1_read_write_register(struct hid_device *hdev, u32 address,
 
 		if (ret < 0) {
 			dev_err(&hdev->dev, "failed read register (%d)\n", ret);
+			kfree(readbuf);
 			goto exit;
 		}
 

commit 819d64e51d6260f8f7ef352cf42fc1ea67a0f7db
Author: Masaki Ota <masaki.ota@jp.alps.com>
Date:   Wed Jun 22 13:11:08 2016 +0900

    HID: alps: a few cleanups
    
    Remove an unnecessary codes.
    Change input_ivent() function to appropriate function.
    Add the device ID of "HID_DEVICE_ID_ALPS_U1_DUAL".
    
    [jkosina@suse.cz: removed unnecessary bitshifts of values passed
     input_report_key() as spotted by Dmitry]
    Signed-off-by: Masaki Ota <masaki.ota@jp.alps.com>
    Reviewed-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-alps.c b/drivers/hid/hid-alps.c
index ff64c92906a6..048befde295a 100644
--- a/drivers/hid/hid-alps.c
+++ b/drivers/hid/hid-alps.c
@@ -98,8 +98,6 @@ struct u1_dev {
 	u32	sp_btn_cnt;
 };
 
-static struct u1_dev *priv;
-
 static int u1_read_write_register(struct hid_device *hdev, u32 address,
 	u8 *read_val, u8 write_val, bool read_flag)
 {
@@ -108,16 +106,10 @@ static int u1_read_write_register(struct hid_device *hdev, u32 address,
 	u8 *input;
 	u8 *readbuf;
 
-	input = kzalloc(sizeof(u8)*U1_FEATURE_REPORT_LEN, GFP_KERNEL);
+	input = kzalloc(U1_FEATURE_REPORT_LEN, GFP_KERNEL);
 	if (!input)
 		return -ENOMEM;
 
-	readbuf = kzalloc(sizeof(u8)*U1_FEATURE_REPORT_LEN, GFP_KERNEL);
-	if (!readbuf) {
-		kfree(input);
-		return -ENOMEM;
-	}
-
 	input[0] = U1_FEATURE_REPORT_ID;
 	if (read_flag) {
 		input[1] = U1_CMD_REGISTER_READ;
@@ -136,8 +128,8 @@ static int u1_read_write_register(struct hid_device *hdev, u32 address,
 
 	input[7] = check_sum;
 	ret = hid_hw_raw_request(hdev, U1_FEATURE_REPORT_ID, input,
-			sizeof(u8)*U1_FEATURE_REPORT_LEN, HID_FEATURE_REPORT,
-			HID_REQ_SET_REPORT);
+			U1_FEATURE_REPORT_LEN,
+			HID_FEATURE_REPORT, HID_REQ_SET_REPORT);
 
 	if (ret < 0) {
 		dev_err(&hdev->dev, "failed to read command (%d)\n", ret);
@@ -145,8 +137,14 @@ static int u1_read_write_register(struct hid_device *hdev, u32 address,
 	}
 
 	if (read_flag) {
+		readbuf = kzalloc(U1_FEATURE_REPORT_LEN, GFP_KERNEL);
+		if (!readbuf) {
+			kfree(input);
+			return -ENOMEM;
+		}
+
 		ret = hid_hw_raw_request(hdev, U1_FEATURE_REPORT_ID, readbuf,
-				sizeof(u8)*U1_FEATURE_REPORT_LEN,
+				U1_FEATURE_REPORT_LEN,
 				HID_FEATURE_REPORT, HID_REQ_GET_REPORT);
 
 		if (ret < 0) {
@@ -155,24 +153,23 @@ static int u1_read_write_register(struct hid_device *hdev, u32 address,
 		}
 
 		*read_val = readbuf[6];
+
+		kfree(readbuf);
 	}
 
-	kfree(input);
-	kfree(readbuf);
-	return 0;
+	ret = 0;
 
 exit:
 	kfree(input);
-	kfree(readbuf);
 	return ret;
 }
 
 static int alps_raw_event(struct hid_device *hdev,
 		struct hid_report *report, u8 *data, int size)
 {
-	int x[MAX_TOUCHES], y[MAX_TOUCHES], z[MAX_TOUCHES];
-	int i, left, right, middle;
-	short sp_x, sp_y, sp_z;
+	unsigned int x, y, z;
+	int i;
+	short sp_x, sp_y;
 	struct u1_dev *hdata = hid_get_drvdata(hdev);
 
 	switch (data[0]) {
@@ -182,16 +179,15 @@ static int alps_raw_event(struct hid_device *hdev,
 		break;
 	case U1_ABSOLUTE_REPORT_ID:
 		for (i = 0; i < MAX_TOUCHES; i++) {
-			x[i] = (data[3+(5*i)] | (data[4+(5*i)] << 8));
-			y[i] = (data[5+(5*i)] | (data[6+(5*i)] << 8));
-			z[i] = data[7+(5*i)] & 0x7F;
-			left = data[1] & 0x1;
-			right = (data[1] & 0x2) >> 1;
-			middle = (data[1] & 0x4) >> 2;
+			u8 *contact = &data[i * 5];
+
+			x = get_unaligned_le16(contact + 3);
+			y = get_unaligned_le16(contact + 5);
+			z = contact[7] & 0x7F;
 
 			input_mt_slot(hdata->input, i);
 
-			if (z[i] != 0) {
+			if (z != 0) {
 				input_mt_report_slot_state(hdata->input,
 					MT_TOOL_FINGER, 1);
 			} else {
@@ -200,42 +196,43 @@ static int alps_raw_event(struct hid_device *hdev,
 				break;
 			}
 
-			input_event(hdata->input, EV_ABS,
-				ABS_MT_POSITION_X, x[i]);
-			input_event(hdata->input, EV_ABS,
-				ABS_MT_POSITION_Y, y[i]);
-			input_event(hdata->input, EV_ABS,
-				ABS_MT_PRESSURE, z[i]);
+			input_report_abs(hdata->input, ABS_MT_POSITION_X, x);
+			input_report_abs(hdata->input, ABS_MT_POSITION_Y, y);
+			input_report_abs(hdata->input, ABS_MT_PRESSURE, z);
+
 		}
 
 		input_mt_sync_frame(hdata->input);
-		input_sync(hdata->input);
 
-		input_event(hdata->input, EV_KEY, BTN_LEFT, left);
-		input_event(hdata->input, EV_KEY, BTN_RIGHT, right);
-		input_event(hdata->input, EV_KEY, BTN_MIDDLE, middle);
+		input_report_key(hdata->input, BTN_LEFT,
+			data[1] & 0x1);
+		input_report_key(hdata->input, BTN_RIGHT,
+			(data[1] & 0x2));
+		input_report_key(hdata->input, BTN_MIDDLE,
+			(data[1] & 0x4));
+
+		input_sync(hdata->input);
 
 		return 1;
 
 	case U1_SP_ABSOLUTE_REPORT_ID:
-		sp_x = (data[2] | (data[3] << 8));
-		sp_y = (data[4] | (data[5] << 8));
-		sp_z = (data[6] | data[7]) & 0x7FFF;
-		left = data[1] & 0x1;
-		right = (data[1] & 0x2) >> 1;
-		middle = (data[1] & 0x4) >> 2;
+		sp_x = get_unaligned_le16(data+2);
+		sp_y = get_unaligned_le16(data+4);
 
 		sp_x = sp_x / 8;
 		sp_y = sp_y / 8;
 
-		input_event(priv->input2, EV_REL, REL_X, sp_x);
-		input_event(priv->input2, EV_REL, REL_Y, sp_y);
+		input_report_rel(hdata->input2, REL_X, sp_x);
+		input_report_rel(hdata->input2, REL_Y, sp_y);
 
-		input_event(priv->input2, EV_KEY, BTN_LEFT, left);
-		input_event(priv->input2, EV_KEY, BTN_RIGHT, right);
-		input_event(priv->input2, EV_KEY, BTN_MIDDLE, middle);
+		input_report_key(hdata->input2, BTN_LEFT,
+			data[1] & 0x1);
+		input_report_key(hdata->input2, BTN_RIGHT,
+			(data[1] & 0x2));
+		input_report_key(hdata->input2, BTN_MIDDLE,
+			(data[1] & 0x4));
 
-		input_sync(priv->input2);
+		input_sync(hdata->input2);
 
 		return 1;
 	}
@@ -265,15 +262,6 @@ static int alps_input_configured(struct hid_device *hdev, struct hid_input *hi)
 	int ret;
 	int res_x, res_y, i;
 
-	/* Check device product ID */
-	switch (hdev->product) {
-	case HID_PRODUCT_ID_U1:
-	case HID_PRODUCT_ID_U1_DUAL:
-		break;
-	default:
-		return 0;
-	}
-
 	data->input = input;
 
 	hid_dbg(hdev, "Opening low level driver\n");
@@ -393,20 +381,13 @@ static int alps_input_configured(struct hid_device *hdev, struct hid_input *hi)
 	/* Stick device initialization */
 	if (devInfo.dev_type & U1_DEVTYPE_SP_SUPPORT) {
 
-		priv = kzalloc(sizeof(struct u1_dev), GFP_KERNEL);
-		if (!priv) {
-			hid_device_io_stop(hdev);
-			hid_hw_close(hdev);
-			return -ENOMEM;
-		}
-
 		input2 = input_allocate_device();
 		if (!input2) {
 			input_free_device(input2);
 			goto exit;
 		}
 
-		priv->input2 = input2;
+		data->input2 = input2;
 
 		devInfo.dev_ctrl |= U1_SP_ABS_MODE;
 		ret = u1_read_write_register(hdev, ADDRESS_U1_DEV_CTRL_1,
@@ -444,7 +425,7 @@ static int alps_input_configured(struct hid_device *hdev, struct hid_input *hi)
 		__set_bit(INPUT_PROP_POINTER, input2->propbit);
 		__set_bit(INPUT_PROP_POINTING_STICK, input2->propbit);
 
-		if (input_register_device(priv->input2)) {
+		if (input_register_device(data->input2)) {
 			input_free_device(input2);
 			goto exit;
 		}
@@ -495,12 +476,11 @@ static int alps_probe(struct hid_device *hdev, const struct hid_device_id *id)
 static void alps_remove(struct hid_device *hdev)
 {
 	hid_hw_stop(hdev);
-	kfree(priv);
 }
 
 static const struct hid_device_id alps_id[] = {
 	{ HID_DEVICE(HID_BUS_ANY, HID_GROUP_ANY,
-		USB_VENDOR_ID_ALPS_JP, HID_ANY_ID) },
+		USB_VENDOR_ID_ALPS_JP, HID_DEVICE_ID_ALPS_U1_DUAL) },
 	{ }
 };
 MODULE_DEVICE_TABLE(hid, alps_id);

commit 63b3a7d0f933ebf25961e602c2eb11d658fef912
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Mon Jun 20 11:16:18 2016 +0200

    HID: alps: pass correct sizes to hid_hw_raw_request()
    
    Calculating size of the report as sizeof(pointer) always passess the length
    corresponding to the pointer type, not the underlying data report.
    
    Reported-by: kbuild test robot <fengguang.wu@intel.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-alps.c b/drivers/hid/hid-alps.c
index 098bce621c6c..ff64c92906a6 100644
--- a/drivers/hid/hid-alps.c
+++ b/drivers/hid/hid-alps.c
@@ -136,7 +136,8 @@ static int u1_read_write_register(struct hid_device *hdev, u32 address,
 
 	input[7] = check_sum;
 	ret = hid_hw_raw_request(hdev, U1_FEATURE_REPORT_ID, input,
-			sizeof(input), HID_FEATURE_REPORT, HID_REQ_SET_REPORT);
+			sizeof(u8)*U1_FEATURE_REPORT_LEN, HID_FEATURE_REPORT,
+			HID_REQ_SET_REPORT);
 
 	if (ret < 0) {
 		dev_err(&hdev->dev, "failed to read command (%d)\n", ret);
@@ -145,8 +146,8 @@ static int u1_read_write_register(struct hid_device *hdev, u32 address,
 
 	if (read_flag) {
 		ret = hid_hw_raw_request(hdev, U1_FEATURE_REPORT_ID, readbuf,
-				sizeof(readbuf), HID_FEATURE_REPORT,
-				HID_REQ_GET_REPORT);
+				sizeof(u8)*U1_FEATURE_REPORT_LEN,
+				HID_FEATURE_REPORT, HID_REQ_GET_REPORT);
 
 		if (ret < 0) {
 			dev_err(&hdev->dev, "failed read register (%d)\n", ret);

commit 41f61ecc501ca970ae8d9955c57405dc4abfab5a
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Fri Jun 17 23:15:04 2016 +0200

    HID: alps: struct u1_dev *priv is internal to the driver
    
    ... and therefore should be marked static.
    
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-alps.c b/drivers/hid/hid-alps.c
index b79c318987a3..098bce621c6c 100644
--- a/drivers/hid/hid-alps.c
+++ b/drivers/hid/hid-alps.c
@@ -98,7 +98,7 @@ struct u1_dev {
 	u32	sp_btn_cnt;
 };
 
-struct u1_dev *priv;
+static struct u1_dev *priv;
 
 static int u1_read_write_register(struct hid_device *hdev, u32 address,
 	u8 *read_val, u8 write_val, bool read_flag)

commit 2562756dde550901c224e3805102bdfc17e7d13a
Author: Masaki Ota <masaki.ota@jp.alps.com>
Date:   Thu Jun 16 18:45:57 2016 +0900

    HID: add Alps I2C HID Touchpad-Stick support
    
    Add support Alps I2C HID Touchpad and Stick device.
    
    Signed-off-by: Masaki Ota <masaki.ota@jp.alps.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-alps.c b/drivers/hid/hid-alps.c
new file mode 100644
index 000000000000..b79c318987a3
--- /dev/null
+++ b/drivers/hid/hid-alps.c
@@ -0,0 +1,525 @@
+/*
+ *  Copyright (c) 2016 Masaki Ota <masaki.ota@jp.alps.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/hid.h>
+#include <linux/input.h>
+#include <linux/input/mt.h>
+#include <linux/module.h>
+#include <asm/unaligned.h>
+#include "hid-ids.h"
+
+/* ALPS Device Product ID */
+#define HID_PRODUCT_ID_T3_BTNLESS	0xD0C0
+#define HID_PRODUCT_ID_COSMO		0x1202
+#define HID_PRODUCT_ID_U1_PTP_1		0x1207
+#define HID_PRODUCT_ID_U1			0x1209
+#define HID_PRODUCT_ID_U1_PTP_2		0x120A
+#define HID_PRODUCT_ID_U1_DUAL		0x120B
+#define HID_PRODUCT_ID_T4_BTNLESS	0x120C
+
+#define DEV_SINGLEPOINT				0x01
+#define DEV_DUALPOINT				0x02
+
+#define U1_MOUSE_REPORT_ID			0x01 /* Mouse data ReportID */
+#define U1_ABSOLUTE_REPORT_ID		0x03 /* Absolute data ReportID */
+#define U1_FEATURE_REPORT_ID		0x05 /* Feature ReportID */
+#define U1_SP_ABSOLUTE_REPORT_ID	0x06 /* Feature ReportID */
+
+#define U1_FEATURE_REPORT_LEN		0x08 /* Feature Report Length */
+#define U1_FEATURE_REPORT_LEN_ALL	0x0A
+#define U1_CMD_REGISTER_READ		0xD1
+#define U1_CMD_REGISTER_WRITE		0xD2
+
+#define	U1_DEVTYPE_SP_SUPPORT		0x10 /* SP Support */
+#define	U1_DISABLE_DEV				0x01
+#define U1_TP_ABS_MODE				0x02
+#define	U1_SP_ABS_MODE				0x80
+
+#define ADDRESS_U1_DEV_CTRL_1	0x00800040
+#define ADDRESS_U1_DEVICE_TYP	0x00800043
+#define ADDRESS_U1_NUM_SENS_X	0x00800047
+#define ADDRESS_U1_NUM_SENS_Y	0x00800048
+#define ADDRESS_U1_PITCH_SENS_X	0x00800049
+#define ADDRESS_U1_PITCH_SENS_Y	0x0080004A
+#define ADDRESS_U1_RESO_DWN_ABS 0x0080004E
+#define ADDRESS_U1_PAD_BTN		0x00800052
+#define ADDRESS_U1_SP_BTN		0x0080009F
+
+#define MAX_TOUCHES	5
+
+/**
+ * struct u1_data
+ *
+ * @input: pointer to the kernel input device
+ * @input2: pointer to the kernel input2 device
+ * @hdev: pointer to the struct hid_device
+ *
+ * @dev_ctrl: device control parameter
+ * @dev_type: device type
+ * @sen_line_num_x: number of sensor line of X
+ * @sen_line_num_y: number of sensor line of Y
+ * @pitch_x: sensor pitch of X
+ * @pitch_y: sensor pitch of Y
+ * @resolution: resolution
+ * @btn_info: button information
+ * @x_active_len_mm: active area length of X (mm)
+ * @y_active_len_mm: active area length of Y (mm)
+ * @x_max: maximum x coordinate value
+ * @y_max: maximum y coordinate value
+ * @btn_cnt: number of buttons
+ * @sp_btn_cnt: number of stick buttons
+ */
+struct u1_dev {
+	struct input_dev *input;
+	struct input_dev *input2;
+	struct hid_device *hdev;
+
+	u8	dev_ctrl;
+	u8	dev_type;
+	u8	sen_line_num_x;
+	u8	sen_line_num_y;
+	u8	pitch_x;
+	u8	pitch_y;
+	u8	resolution;
+	u8	btn_info;
+	u8	sp_btn_info;
+	u32	x_active_len_mm;
+	u32	y_active_len_mm;
+	u32	x_max;
+	u32	y_max;
+	u32	btn_cnt;
+	u32	sp_btn_cnt;
+};
+
+struct u1_dev *priv;
+
+static int u1_read_write_register(struct hid_device *hdev, u32 address,
+	u8 *read_val, u8 write_val, bool read_flag)
+{
+	int ret, i;
+	u8 check_sum;
+	u8 *input;
+	u8 *readbuf;
+
+	input = kzalloc(sizeof(u8)*U1_FEATURE_REPORT_LEN, GFP_KERNEL);
+	if (!input)
+		return -ENOMEM;
+
+	readbuf = kzalloc(sizeof(u8)*U1_FEATURE_REPORT_LEN, GFP_KERNEL);
+	if (!readbuf) {
+		kfree(input);
+		return -ENOMEM;
+	}
+
+	input[0] = U1_FEATURE_REPORT_ID;
+	if (read_flag) {
+		input[1] = U1_CMD_REGISTER_READ;
+		input[6] = 0x00;
+	} else {
+		input[1] = U1_CMD_REGISTER_WRITE;
+		input[6] = write_val;
+	}
+
+	put_unaligned_le32(address, input + 2);
+
+	/* Calculate the checksum */
+	check_sum = U1_FEATURE_REPORT_LEN_ALL;
+	for (i = 0; i < U1_FEATURE_REPORT_LEN - 1; i++)
+		check_sum += input[i];
+
+	input[7] = check_sum;
+	ret = hid_hw_raw_request(hdev, U1_FEATURE_REPORT_ID, input,
+			sizeof(input), HID_FEATURE_REPORT, HID_REQ_SET_REPORT);
+
+	if (ret < 0) {
+		dev_err(&hdev->dev, "failed to read command (%d)\n", ret);
+		goto exit;
+	}
+
+	if (read_flag) {
+		ret = hid_hw_raw_request(hdev, U1_FEATURE_REPORT_ID, readbuf,
+				sizeof(readbuf), HID_FEATURE_REPORT,
+				HID_REQ_GET_REPORT);
+
+		if (ret < 0) {
+			dev_err(&hdev->dev, "failed read register (%d)\n", ret);
+			goto exit;
+		}
+
+		*read_val = readbuf[6];
+	}
+
+	kfree(input);
+	kfree(readbuf);
+	return 0;
+
+exit:
+	kfree(input);
+	kfree(readbuf);
+	return ret;
+}
+
+static int alps_raw_event(struct hid_device *hdev,
+		struct hid_report *report, u8 *data, int size)
+{
+	int x[MAX_TOUCHES], y[MAX_TOUCHES], z[MAX_TOUCHES];
+	int i, left, right, middle;
+	short sp_x, sp_y, sp_z;
+	struct u1_dev *hdata = hid_get_drvdata(hdev);
+
+	switch (data[0]) {
+	case U1_MOUSE_REPORT_ID:
+		break;
+	case U1_FEATURE_REPORT_ID:
+		break;
+	case U1_ABSOLUTE_REPORT_ID:
+		for (i = 0; i < MAX_TOUCHES; i++) {
+			x[i] = (data[3+(5*i)] | (data[4+(5*i)] << 8));
+			y[i] = (data[5+(5*i)] | (data[6+(5*i)] << 8));
+			z[i] = data[7+(5*i)] & 0x7F;
+			left = data[1] & 0x1;
+			right = (data[1] & 0x2) >> 1;
+			middle = (data[1] & 0x4) >> 2;
+
+			input_mt_slot(hdata->input, i);
+
+			if (z[i] != 0) {
+				input_mt_report_slot_state(hdata->input,
+					MT_TOOL_FINGER, 1);
+			} else {
+				input_mt_report_slot_state(hdata->input,
+					MT_TOOL_FINGER, 0);
+				break;
+			}
+
+			input_event(hdata->input, EV_ABS,
+				ABS_MT_POSITION_X, x[i]);
+			input_event(hdata->input, EV_ABS,
+				ABS_MT_POSITION_Y, y[i]);
+			input_event(hdata->input, EV_ABS,
+				ABS_MT_PRESSURE, z[i]);
+		}
+
+		input_mt_sync_frame(hdata->input);
+		input_sync(hdata->input);
+
+		input_event(hdata->input, EV_KEY, BTN_LEFT, left);
+		input_event(hdata->input, EV_KEY, BTN_RIGHT, right);
+		input_event(hdata->input, EV_KEY, BTN_MIDDLE, middle);
+
+		return 1;
+
+	case U1_SP_ABSOLUTE_REPORT_ID:
+		sp_x = (data[2] | (data[3] << 8));
+		sp_y = (data[4] | (data[5] << 8));
+		sp_z = (data[6] | data[7]) & 0x7FFF;
+		left = data[1] & 0x1;
+		right = (data[1] & 0x2) >> 1;
+		middle = (data[1] & 0x4) >> 2;
+
+		sp_x = sp_x / 8;
+		sp_y = sp_y / 8;
+
+		input_event(priv->input2, EV_REL, REL_X, sp_x);
+		input_event(priv->input2, EV_REL, REL_Y, sp_y);
+
+		input_event(priv->input2, EV_KEY, BTN_LEFT, left);
+		input_event(priv->input2, EV_KEY, BTN_RIGHT, right);
+		input_event(priv->input2, EV_KEY, BTN_MIDDLE, middle);
+
+		input_sync(priv->input2);
+
+		return 1;
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int alps_post_reset(struct hid_device *hdev)
+{
+	return u1_read_write_register(hdev, ADDRESS_U1_DEV_CTRL_1,
+				NULL, U1_TP_ABS_MODE, false);
+}
+
+static int alps_post_resume(struct hid_device *hdev)
+{
+	return u1_read_write_register(hdev, ADDRESS_U1_DEV_CTRL_1,
+				NULL, U1_TP_ABS_MODE, false);
+}
+#endif /* CONFIG_PM */
+
+static int alps_input_configured(struct hid_device *hdev, struct hid_input *hi)
+{
+	struct u1_dev *data = hid_get_drvdata(hdev);
+	struct input_dev *input = hi->input, *input2;
+	struct u1_dev devInfo;
+	int ret;
+	int res_x, res_y, i;
+
+	/* Check device product ID */
+	switch (hdev->product) {
+	case HID_PRODUCT_ID_U1:
+	case HID_PRODUCT_ID_U1_DUAL:
+		break;
+	default:
+		return 0;
+	}
+
+	data->input = input;
+
+	hid_dbg(hdev, "Opening low level driver\n");
+	ret = hid_hw_open(hdev);
+	if (ret)
+		return ret;
+
+	/* Allow incoming hid reports */
+	hid_device_io_start(hdev);
+
+	/* Device initialization */
+	ret = u1_read_write_register(hdev, ADDRESS_U1_DEV_CTRL_1,
+			&devInfo.dev_ctrl, 0, true);
+	if (ret < 0) {
+		dev_err(&hdev->dev, "failed U1_DEV_CTRL_1 (%d)\n", ret);
+		goto exit;
+	}
+
+	devInfo.dev_ctrl &= ~U1_DISABLE_DEV;
+	devInfo.dev_ctrl |= U1_TP_ABS_MODE;
+	ret = u1_read_write_register(hdev, ADDRESS_U1_DEV_CTRL_1,
+			NULL, devInfo.dev_ctrl, false);
+	if (ret < 0) {
+		dev_err(&hdev->dev, "failed to change TP mode (%d)\n", ret);
+		goto exit;
+	}
+
+	ret = u1_read_write_register(hdev, ADDRESS_U1_NUM_SENS_X,
+			&devInfo.sen_line_num_x, 0, true);
+	if (ret < 0) {
+		dev_err(&hdev->dev, "failed U1_NUM_SENS_X (%d)\n", ret);
+		goto exit;
+	}
+
+	ret = u1_read_write_register(hdev, ADDRESS_U1_NUM_SENS_Y,
+			&devInfo.sen_line_num_y, 0, true);
+		if (ret < 0) {
+		dev_err(&hdev->dev, "failed U1_NUM_SENS_Y (%d)\n", ret);
+		goto exit;
+	}
+
+	ret = u1_read_write_register(hdev, ADDRESS_U1_PITCH_SENS_X,
+			&devInfo.pitch_x, 0, true);
+	if (ret < 0) {
+		dev_err(&hdev->dev, "failed U1_PITCH_SENS_X (%d)\n", ret);
+		goto exit;
+	}
+
+	ret = u1_read_write_register(hdev, ADDRESS_U1_PITCH_SENS_Y,
+			&devInfo.pitch_y, 0, true);
+	if (ret < 0) {
+		dev_err(&hdev->dev, "failed U1_PITCH_SENS_Y (%d)\n", ret);
+		goto exit;
+	}
+
+	ret = u1_read_write_register(hdev, ADDRESS_U1_RESO_DWN_ABS,
+		&devInfo.resolution, 0, true);
+	if (ret < 0) {
+		dev_err(&hdev->dev, "failed U1_RESO_DWN_ABS (%d)\n", ret);
+		goto exit;
+	}
+
+	ret = u1_read_write_register(hdev, ADDRESS_U1_PAD_BTN,
+			&devInfo.btn_info, 0, true);
+	if (ret < 0) {
+		dev_err(&hdev->dev, "failed U1_PAD_BTN (%d)\n", ret);
+		goto exit;
+	}
+
+	/* Check StickPointer device */
+	ret = u1_read_write_register(hdev, ADDRESS_U1_DEVICE_TYP,
+			&devInfo.dev_type, 0, true);
+	if (ret < 0) {
+		dev_err(&hdev->dev, "failed U1_DEVICE_TYP (%d)\n", ret);
+		goto exit;
+	}
+
+	devInfo.x_active_len_mm =
+		(devInfo.pitch_x * (devInfo.sen_line_num_x - 1)) / 10;
+	devInfo.y_active_len_mm =
+		(devInfo.pitch_y * (devInfo.sen_line_num_y - 1)) / 10;
+
+	devInfo.x_max =
+		(devInfo.resolution << 2) * (devInfo.sen_line_num_x - 1);
+	devInfo.y_max =
+		(devInfo.resolution << 2) * (devInfo.sen_line_num_y - 1);
+
+	__set_bit(EV_ABS, input->evbit);
+	input_set_abs_params(input, ABS_MT_POSITION_X, 1, devInfo.x_max, 0, 0);
+	input_set_abs_params(input, ABS_MT_POSITION_Y, 1, devInfo.y_max, 0, 0);
+
+	if (devInfo.x_active_len_mm && devInfo.y_active_len_mm) {
+		res_x = (devInfo.x_max - 1) / devInfo.x_active_len_mm;
+		res_y = (devInfo.y_max - 1) / devInfo.y_active_len_mm;
+
+		input_abs_set_res(input, ABS_MT_POSITION_X, res_x);
+		input_abs_set_res(input, ABS_MT_POSITION_Y, res_y);
+	}
+
+	input_set_abs_params(input, ABS_MT_PRESSURE, 0, 64, 0, 0);
+
+	input_mt_init_slots(input, MAX_TOUCHES, INPUT_MT_POINTER);
+
+	__set_bit(EV_KEY, input->evbit);
+	if ((devInfo.btn_info & 0x0F) == (devInfo.btn_info & 0xF0) >> 4) {
+		devInfo.btn_cnt = (devInfo.btn_info & 0x0F);
+	} else {
+		/* Button pad */
+		devInfo.btn_cnt = 1;
+		__set_bit(INPUT_PROP_BUTTONPAD, input->propbit);
+	}
+
+	for (i = 0; i < devInfo.btn_cnt; i++)
+		__set_bit(BTN_LEFT + i, input->keybit);
+
+
+	/* Stick device initialization */
+	if (devInfo.dev_type & U1_DEVTYPE_SP_SUPPORT) {
+
+		priv = kzalloc(sizeof(struct u1_dev), GFP_KERNEL);
+		if (!priv) {
+			hid_device_io_stop(hdev);
+			hid_hw_close(hdev);
+			return -ENOMEM;
+		}
+
+		input2 = input_allocate_device();
+		if (!input2) {
+			input_free_device(input2);
+			goto exit;
+		}
+
+		priv->input2 = input2;
+
+		devInfo.dev_ctrl |= U1_SP_ABS_MODE;
+		ret = u1_read_write_register(hdev, ADDRESS_U1_DEV_CTRL_1,
+			NULL, devInfo.dev_ctrl, false);
+		if (ret < 0) {
+			dev_err(&hdev->dev, "failed SP mode (%d)\n", ret);
+			input_free_device(input2);
+			goto exit;
+		}
+
+		ret = u1_read_write_register(hdev, ADDRESS_U1_SP_BTN,
+			&devInfo.sp_btn_info, 0, true);
+		if (ret < 0) {
+			dev_err(&hdev->dev, "failed U1_SP_BTN (%d)\n", ret);
+			input_free_device(input2);
+			goto exit;
+		}
+
+		input2->phys = input->phys;
+		input2->name = "DualPoint Stick";
+		input2->id.bustype = BUS_I2C;
+		input2->id.vendor  = input->id.vendor;
+		input2->id.product = input->id.product;
+		input2->id.version = input->id.version;
+		input2->dev.parent = input->dev.parent;
+
+		__set_bit(EV_KEY, input2->evbit);
+		devInfo.sp_btn_cnt = (devInfo.sp_btn_info & 0x0F);
+		for (i = 0; i < devInfo.sp_btn_cnt; i++)
+			__set_bit(BTN_LEFT + i, input2->keybit);
+
+		__set_bit(EV_REL, input2->evbit);
+		__set_bit(REL_X, input2->relbit);
+		__set_bit(REL_Y, input2->relbit);
+		__set_bit(INPUT_PROP_POINTER, input2->propbit);
+		__set_bit(INPUT_PROP_POINTING_STICK, input2->propbit);
+
+		if (input_register_device(priv->input2)) {
+			input_free_device(input2);
+			goto exit;
+		}
+	}
+
+exit:
+	hid_device_io_stop(hdev);
+	hid_hw_close(hdev);
+	return ret;
+}
+
+static int alps_input_mapping(struct hid_device *hdev,
+		struct hid_input *hi, struct hid_field *field,
+		struct hid_usage *usage, unsigned long **bit, int *max)
+{
+	return -1;
+}
+
+static int alps_probe(struct hid_device *hdev, const struct hid_device_id *id)
+{
+	struct u1_dev *data = NULL;
+	int ret;
+
+	data = devm_kzalloc(&hdev->dev, sizeof(struct u1_dev), GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	data->hdev = hdev;
+	hid_set_drvdata(hdev, data);
+
+	hdev->quirks |= HID_QUIRK_NO_INIT_REPORTS;
+
+	ret = hid_parse(hdev);
+	if (ret) {
+		hid_err(hdev, "parse failed\n");
+		return ret;
+	}
+
+	ret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);
+	if (ret) {
+		hid_err(hdev, "hw start failed\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static void alps_remove(struct hid_device *hdev)
+{
+	hid_hw_stop(hdev);
+	kfree(priv);
+}
+
+static const struct hid_device_id alps_id[] = {
+	{ HID_DEVICE(HID_BUS_ANY, HID_GROUP_ANY,
+		USB_VENDOR_ID_ALPS_JP, HID_ANY_ID) },
+	{ }
+};
+MODULE_DEVICE_TABLE(hid, alps_id);
+
+static struct hid_driver alps_driver = {
+	.name = "hid-alps",
+	.id_table		= alps_id,
+	.probe			= alps_probe,
+	.remove			= alps_remove,
+	.raw_event		= alps_raw_event,
+	.input_mapping		= alps_input_mapping,
+	.input_configured	= alps_input_configured,
+#ifdef CONFIG_PM
+	.resume			= alps_post_resume,
+	.reset_resume		= alps_post_reset,
+#endif
+};
+
+module_hid_driver(alps_driver);
+
+MODULE_AUTHOR("Masaki Ota <masaki.ota@jp.alps.com>");
+MODULE_DESCRIPTION("ALPS HID driver");
+MODULE_LICENSE("GPL");
