commit 4f3882177240a1f55e45a3d241d3121341bead78
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Sat Dec 7 13:05:18 2019 -0800

    HID: hid-input: clear unmapped usages
    
    We should not be leaving half-mapped usages with potentially invalid
    keycodes, as that may confuse hidinput_find_key() when the key is located
    by index, which may end up feeding way too large keycode into the VT
    keyboard handler and cause OOB write there:
    
    BUG: KASAN: global-out-of-bounds in clear_bit include/asm-generic/bitops-instrumented.h:56 [inline]
    BUG: KASAN: global-out-of-bounds in kbd_keycode drivers/tty/vt/keyboard.c:1411 [inline]
    BUG: KASAN: global-out-of-bounds in kbd_event+0xe6b/0x3790 drivers/tty/vt/keyboard.c:1495
    Write of size 8 at addr ffffffff89a1b2d8 by task syz-executor108/1722
    ...
     kbd_keycode drivers/tty/vt/keyboard.c:1411 [inline]
     kbd_event+0xe6b/0x3790 drivers/tty/vt/keyboard.c:1495
     input_to_handler+0x3b6/0x4c0 drivers/input/input.c:118
     input_pass_values.part.0+0x2e3/0x720 drivers/input/input.c:145
     input_pass_values drivers/input/input.c:949 [inline]
     input_set_keycode+0x290/0x320 drivers/input/input.c:954
     evdev_handle_set_keycode_v2+0xc4/0x120 drivers/input/evdev.c:882
     evdev_do_ioctl drivers/input/evdev.c:1150 [inline]
    
    Cc: stable@vger.kernel.org
    Reported-by: syzbot+19340dff067c2d3835c0@syzkaller.appspotmail.com
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Tested-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 63855f275a38..dea9cc65bf80 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -1132,9 +1132,15 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 	}
 
 mapped:
-	if (device->driver->input_mapped && device->driver->input_mapped(device,
-				hidinput, field, usage, &bit, &max) < 0)
-		goto ignore;
+	if (device->driver->input_mapped &&
+	    device->driver->input_mapped(device, hidinput, field, usage,
+					 &bit, &max) < 0) {
+		/*
+		 * The driver indicated that no further generic handling
+		 * of the usage is desired.
+		 */
+		return;
+	}
 
 	set_bit(usage->type, input->evbit);
 
@@ -1215,9 +1221,11 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 		set_bit(MSC_SCAN, input->mscbit);
 	}
 
-ignore:
 	return;
 
+ignore:
+	usage->type = 0;
+	usage->code = 0;
 }
 
 static void hidinput_handle_scroll(struct hid_usage *usage,

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index abdb01879caa..63855f275a38 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *  Copyright (c) 2000-2001 Vojtech Pavlik
  *  Copyright (c) 2006-2010 Jiri Kosina
@@ -6,19 +7,6 @@
  */
 
 /*
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
  *
  * Should you need to contact me, the author, you can do so either by
  * e-mail - mail your message to <vojtech@ucw.cz>, or by paper mail:

commit 0aed4b28187078565cafbfe86b62f941d580d840
Merge: a3958f5e13e2 14e0c7317ed5
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon May 13 15:21:48 2019 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/dtor/input
    
    Pull input updates from Dmitry Torokhov:
     "A few new drivers:
    
       - driver for Azoteq IQS550/572/525 touch controllers
    
       - driver for Microchip AT42QT1050 keys
    
       - driver for GPIO controllable vibrators
    
       - support for GT5663 in Goodix driver
    
      ... along with miscellaneous driver fixes"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/dtor/input:
      Input: libps2 - mark expected switch fall-through
      Input: qt1050 - add Microchip AT42QT1050 support
      Input: add support for Azoteq IQS550/572/525
      Input: add a driver for GPIO controllable vibrators
      Input: synaptics-rmi4 - fix enum_fmt
      Input: synaptics-rmi4 - fill initial format
      HID: input: add mapping for KEY_KBD_LAYOUT_NEXT
      Input: add KEY_KBD_LAYOUT_NEXT
      Input: hyperv-keyboard - add module description
      Input: olpc_apsp - depend on ARCH_MMP
      Input: sun4i-a10-lradc-keys - add support for A83T
      Input: snvs_pwrkey - use dev_pm_set_wake_irq() to simplify code
      Input: lpc32xx-key - add clocks property and fix DT binding example
      Input: i8042 - signal wakeup from atkbd/psmouse
      Input: goodix - add GT5663 CTP support
      Input: goodix - add regulators suppot
      Input: evdev - use struct_size() in kzalloc() and vzalloc()
      Input: edt-ft5x06 - convert to use SPDX identifier
      Input: edt-ft5x06 - enable ACPI enumeration

commit 14e0c7317ed58bcd15af5c3d09818ee0f2e3984c
Merge: 3a349763cf11 0981949da8f7
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Fri May 10 11:40:35 2019 -0700

    Merge branch 'next' into for-linus
    
    Prepare input updates for 5.2 merge window.

commit b4dd05dee0dbd16afdbba83b698a7110c687be2d
Merge: 80104bb06b17 63b6f0b827d6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue May 7 08:52:04 2019 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/hid/hid
    
    Pull HID updates from Jiri Kosina:
    
     - support for U2F Zero device, from Andrej Shadura
    
     - logitech-dj has historically been treating devices behind
       non-unifying receivers as generic devices, using the HID emulation in
       the receiver. That had several shortcomings (special keys handling,
       battery level monitoring, etc). The driver has been reworked to
       enumarate (and directly communicate with) the devices behind the
       receiver, to avoid the (too) generic HID implementation in the
       receiver itself. All the work done by Benjamin Tissoires and Hans de
       Goede.
    
     - restructuring of intel-ish driver in order to allow for multiple
       clients of the ISH implementation, from Srinivas Pandruvada
    
     - several other smaller fixes and assorted device ID additions
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/hid/hid: (68 commits)
      HID: logitech-dj: fix spelling in printk
      HID: input: fix assignment of .value
      HID: input: make sure the wheel high resolution multiplier is set
      HID: logitech-dj: add usbhid dependency in Kconfig
      HID: logitech-hidpp: add support for HID++ 1.0 consumer keys reports
      HID: logitech-hidpp: add support for HID++ 1.0 extra mouse buttons reports
      HID: logitech-hidpp: add support for HID++ 1.0 wheel reports
      HID: logitech-hidpp: make hidpp10_set_register_bit a bit more generic
      HID: logitech-hidpp: add input_device ptr to struct hidpp_device
      HID: logitech-hidpp: do not hardcode very long report length
      HID: logitech-hidpp: handle devices attached to 27MHz wireless receivers
      HID: logitech-hidpp: use RAP instead of FAP to get the protocol version
      HID: logitech-hidpp: remove unused origin_is_hid_core function parameter
      HID: logitech-hidpp: remove double assignment from __hidpp_send_report
      HID: logitech-hidpp: do not make failure to get the name fatal
      HID: logitech-hidpp: ignore very-short or empty names
      HID: logitech-hidpp: make .probe usbhid capable
      HID: logitech-hidpp: allow non HID++ devices to be handled by this module
      HID: logitech-dj: add support for Logitech Bluetooth Mini-Receiver
      HID: logitech-dj: make appending of the HID++ descriptors conditional
      ...

commit bd21d847924845175fed9756d560cd1c4669f2c5
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Thu Apr 25 09:21:13 2019 -0700

    HID: input: add mapping for KEY_KBD_LAYOUT_NEXT
    
    HUTRR56 defined a new usage code on consumer page to cycle through
    set of keyboard layouts, let's add this mapping.
    
    Acked-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index d6fab5798487..757fb1bf4cfd 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -1023,6 +1023,8 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 		case 0x28b: map_key_clear(KEY_FORWARDMAIL);	break;
 		case 0x28c: map_key_clear(KEY_SEND);		break;
 
+		case 0x29d: map_key_clear(KEY_KBD_LAYOUT_NEXT);	break;
+
 		case 0x2c7: map_key_clear(KEY_KBDINPUTASSIST_PREV);		break;
 		case 0x2c8: map_key_clear(KEY_KBDINPUTASSIST_NEXT);		break;
 		case 0x2c9: map_key_clear(KEY_KBDINPUTASSIST_PREVGROUP);		break;

commit 39b3c3a5fbc5d744114e497d35bf0c12f798c134
Author: Benjamin Tissoires <benjamin.tissoires@redhat.com>
Date:   Thu Apr 18 09:47:41 2019 +0200

    HID: input: fix assignment of .value
    
    The value field is actually an array of .maxfield. We should assign the
    correct number to the correct usage.
    
    Not that we never encounter a device that requires this ATM, but better
    have the proper code path.
    
    Fixes: 2dc702c991e377 ("HID: input: use the Resolution Multiplier for
           high-resolution scrolling")
    Cc: stable@vger.kernel.org  # v5.0+
    Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index fadf76f0a386..6dd0294e1133 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -1580,7 +1580,7 @@ static bool __hidinput_change_resolution_multipliers(struct hid_device *hid,
 			if (usage->hid != HID_GD_RESOLUTION_MULTIPLIER)
 				continue;
 
-			*report->field[i]->value = value;
+			report->field[i]->value[j] = value;
 			update_needed = true;
 		}
 	}

commit d43c17ead879ba7c076dc2f5fd80cd76047c9ff4
Author: Benjamin Tissoires <benjamin.tissoires@redhat.com>
Date:   Wed Apr 3 16:20:20 2019 +0200

    HID: input: make sure the wheel high resolution multiplier is set
    
    Some old mice have a tendency to not accept the high resolution multiplier.
    They reply with a -EPIPE which was previously ignored.
    
    Force the call to resolution multiplier to be synchronous and actually
    check for the answer. If this fails, consider the mouse like a normal one.
    
    Fixes: 2dc702c991e377 ("HID: input: use the Resolution Multiplier for
           high-resolution scrolling")
    Link: https://bugzilla.redhat.com/show_bug.cgi?id=1700071
    Reported-and-tested-by: James Feeney <james@nurealm.net>
    Cc: stable@vger.kernel.org  # v5.0+
    Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 1fce0076e7dc..fadf76f0a386 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -1542,52 +1542,71 @@ static void hidinput_close(struct input_dev *dev)
 	hid_hw_close(hid);
 }
 
-static void hidinput_change_resolution_multipliers(struct hid_device *hid)
+static bool __hidinput_change_resolution_multipliers(struct hid_device *hid,
+		struct hid_report *report, bool use_logical_max)
 {
-	struct hid_report_enum *rep_enum;
-	struct hid_report *rep;
 	struct hid_usage *usage;
+	bool update_needed = false;
 	int i, j;
 
-	rep_enum = &hid->report_enum[HID_FEATURE_REPORT];
-	list_for_each_entry(rep, &rep_enum->report_list, list) {
-		bool update_needed = false;
+	if (report->maxfield == 0)
+		return false;
 
-		if (rep->maxfield == 0)
-			continue;
+	/*
+	 * If we have more than one feature within this report we
+	 * need to fill in the bits from the others before we can
+	 * overwrite the ones for the Resolution Multiplier.
+	 */
+	if (report->maxfield > 1) {
+		hid_hw_request(hid, report, HID_REQ_GET_REPORT);
+		hid_hw_wait(hid);
+	}
 
-		/*
-		 * If we have more than one feature within this report we
-		 * need to fill in the bits from the others before we can
-		 * overwrite the ones for the Resolution Multiplier.
+	for (i = 0; i < report->maxfield; i++) {
+		__s32 value = use_logical_max ?
+			      report->field[i]->logical_maximum :
+			      report->field[i]->logical_minimum;
+
+		/* There is no good reason for a Resolution
+		 * Multiplier to have a count other than 1.
+		 * Ignore that case.
 		 */
-		if (rep->maxfield > 1) {
-			hid_hw_request(hid, rep, HID_REQ_GET_REPORT);
-			hid_hw_wait(hid);
-		}
+		if (report->field[i]->report_count != 1)
+			continue;
 
-		for (i = 0; i < rep->maxfield; i++) {
-			__s32 logical_max = rep->field[i]->logical_maximum;
+		for (j = 0; j < report->field[i]->maxusage; j++) {
+			usage = &report->field[i]->usage[j];
 
-			/* There is no good reason for a Resolution
-			 * Multiplier to have a count other than 1.
-			 * Ignore that case.
-			 */
-			if (rep->field[i]->report_count != 1)
+			if (usage->hid != HID_GD_RESOLUTION_MULTIPLIER)
 				continue;
 
-			for (j = 0; j < rep->field[i]->maxusage; j++) {
-				usage = &rep->field[i]->usage[j];
+			*report->field[i]->value = value;
+			update_needed = true;
+		}
+	}
+
+	return update_needed;
+}
 
-				if (usage->hid != HID_GD_RESOLUTION_MULTIPLIER)
-					continue;
+static void hidinput_change_resolution_multipliers(struct hid_device *hid)
+{
+	struct hid_report_enum *rep_enum;
+	struct hid_report *rep;
+	int ret;
 
-				*rep->field[i]->value = logical_max;
-				update_needed = true;
+	rep_enum = &hid->report_enum[HID_FEATURE_REPORT];
+	list_for_each_entry(rep, &rep_enum->report_list, list) {
+		bool update_needed = __hidinput_change_resolution_multipliers(hid,
+								     rep, true);
+
+		if (update_needed) {
+			ret = __hid_request(hid, rep, HID_REQ_SET_REPORT);
+			if (ret) {
+				__hidinput_change_resolution_multipliers(hid,
+								    rep, false);
+				return;
 			}
 		}
-		if (update_needed)
-			hid_hw_request(hid, rep, HID_REQ_SET_REPORT);
 	}
 
 	/* refresh our structs */

commit 240206fcab661afe9bed72e8704cef1d6e83e338
Merge: 6d906f998179 bf2a7ca39fd3
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Apr 19 10:28:27 2019 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/dtor/input
    
    Pull input updates from Dmitry Torokhov:
    
     - several new key mappings for HID
    
     - a host of new ACPI IDs used to identify Elan touchpads in Lenovo
       laptops
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/dtor/input:
      Input: snvs_pwrkey - initialize necessary driver data before enabling IRQ
      HID: input: add mapping for "Toggle Display" key
      HID: input: add mapping for "Full Screen" key
      HID: input: add mapping for keyboard Brightness Up/Down/Toggle keys
      HID: input: add mapping for Expose/Overview key
      HID: input: fix mapping of aspect ratio key
      [media] doc-rst: switch to new names for Full Screen/Aspect keys
      Input: document meanings of KEY_SCREEN and KEY_ZOOM
      Input: elan_i2c - add hardware ID for multiple Lenovo laptops

commit ce856634af8cda3490947df8ac1ef5843e6356af
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Tue Apr 2 09:57:13 2019 -0700

    HID: input: add mapping for Assistant key
    
    According to HUTRR89 usage 0x1cb from the consumer page was assigned to
    allow launching desktop-aware assistant application, so let's add the
    mapping.
    
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index b10b1922c5bd..1fce0076e7dc 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -998,6 +998,7 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 		case 0x1b8: map_key_clear(KEY_VIDEO);		break;
 		case 0x1bc: map_key_clear(KEY_MESSENGER);	break;
 		case 0x1bd: map_key_clear(KEY_INFO);		break;
+		case 0x1cb: map_key_clear(KEY_ASSISTANT);	break;
 		case 0x201: map_key_clear(KEY_NEW);		break;
 		case 0x202: map_key_clear(KEY_OPEN);		break;
 		case 0x203: map_key_clear(KEY_CLOSE);		break;

commit c01908a14bf735b871170092807c618bb9dae654
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Fri Jan 18 14:35:45 2019 -0800

    HID: input: add mapping for "Toggle Display" key
    
    According to HUT 1.12 usage 0xb5 from the generic desktop page is reserved
    for switching between external and internal display, so let's add the
    mapping.
    
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index ecb1b6f26853..da76358cde06 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -677,6 +677,14 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 			break;
 		}
 
+		if ((usage->hid & 0xf0) == 0xb0) {	/* SC - Display */
+			switch (usage->hid & 0xf) {
+			case 0x05: map_key_clear(KEY_SWITCHVIDEOMODE); break;
+			default: goto ignore;
+			}
+			break;
+		}
+
 		/*
 		 * Some lazy vendors declare 255 usages for System Control,
 		 * leading to the creation of ABS_X|Y axis and too many others.

commit afbbaa1bc0011d28f7604f9a7f0532f997c6f45e
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Fri Jan 18 14:20:27 2019 -0800

    HID: input: add mapping for "Full Screen" key
    
    According to HUT 1.12 usage 0x232 from the consumer page is reserved for
    switching application between full screen and windowed mode, so let's add
    the mapping.
    
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index cebe8a8cce2e..ecb1b6f26853 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -1014,6 +1014,7 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 		case 0x22d: map_key_clear(KEY_ZOOMIN);		break;
 		case 0x22e: map_key_clear(KEY_ZOOMOUT);		break;
 		case 0x22f: map_key_clear(KEY_ZOOMRESET);	break;
+		case 0x232: map_key_clear(KEY_FULL_SCREEN);	break;
 		case 0x233: map_key_clear(KEY_SCROLLUP);	break;
 		case 0x234: map_key_clear(KEY_SCROLLDOWN);	break;
 		case 0x238: map_rel(REL_HWHEEL);		break;

commit 7975a1d6a7afeb3eb61c971a153d24dd8fa032f3
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Fri Jan 18 14:05:52 2019 -0800

    HID: input: add mapping for keyboard Brightness Up/Down/Toggle keys
    
    According to HUTRR73 usages 0x79, 0x7a and 0x7c from the consumer page
    correspond to Brightness Up/Down/Toggle keys, so let's add the mappings.
    
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 5f800e7b04f2..cebe8a8cce2e 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -900,6 +900,10 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 		case 0x074: map_key_clear(KEY_BRIGHTNESS_MAX);		break;
 		case 0x075: map_key_clear(KEY_BRIGHTNESS_AUTO);		break;
 
+		case 0x079: map_key_clear(KEY_KBDILLUMUP);	break;
+		case 0x07a: map_key_clear(KEY_KBDILLUMDOWN);	break;
+		case 0x07c: map_key_clear(KEY_KBDILLUMTOGGLE);	break;
+
 		case 0x082: map_key_clear(KEY_VIDEO_NEXT);	break;
 		case 0x083: map_key_clear(KEY_LAST);		break;
 		case 0x084: map_key_clear(KEY_ENTER);		break;

commit 96dd86871e1fffbc39e4fa61c9c75ec54ee9af0f
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Fri Jan 18 13:59:08 2019 -0800

    HID: input: add mapping for Expose/Overview key
    
    According to HUTRR77 usage 0x29f from the consumer page is reserved for
    the Desktop application to present all running userâ€™s application windows.
    Linux defines KEY_SCALE to request Compiz Scale (Expose) mode, so let's
    add the mapping.
    
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index def58c6aa835..5f800e7b04f2 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -1030,6 +1030,8 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 		case 0x2cb: map_key_clear(KEY_KBDINPUTASSIST_ACCEPT);	break;
 		case 0x2cc: map_key_clear(KEY_KBDINPUTASSIST_CANCEL);	break;
 
+		case 0x29f: map_key_clear(KEY_SCALE);		break;
+
 		default: map_key_clear(KEY_UNKNOWN);
 		}
 		break;

commit f7b3d85aa7a31a90c3ef5b0992604db339a615ab
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Fri Jan 18 13:44:23 2019 -0800

    HID: input: fix mapping of aspect ratio key
    
    According to HUTRR37 usage 0x6d from the consumer usage page corresponds
    to action that selects the next available supported aspect ratio option
    on a device which outputs or displays video. However KEY_ZOOM means
    activate "Full Screen" mode, KEY_ASPECT_RATIO should be used instead.
    
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index d6fab5798487..def58c6aa835 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -891,7 +891,7 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 		case 0x06a: map_key_clear(KEY_GREEN);		break;
 		case 0x06b: map_key_clear(KEY_BLUE);		break;
 		case 0x06c: map_key_clear(KEY_YELLOW);		break;
-		case 0x06d: map_key_clear(KEY_ZOOM);		break;
+		case 0x06d: map_key_clear(KEY_ASPECT_RATIO);	break;
 
 		case 0x06f: map_key_clear(KEY_BRIGHTNESSUP);		break;
 		case 0x070: map_key_clear(KEY_BRIGHTNESSDOWN);		break;

commit a767ffea05d2737f6542cd78458a84a157fa216d
Author: NOGUCHI Hiroshi <drvlabo@gmail.com>
Date:   Tue Jan 29 13:31:05 2019 +0900

    HID: Add ASUS T100CHI keyboard dock battery quirks
    
    Add ASUS Transbook T100CHI/T90CHI keyboard dock into battery quirk list, in
    order to add specific implementation in hid-asus.
    
    Signed-off-by: NOGUCHI Hiroshi <drvlabo@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 59a5608b8dc0..b10b1922c5bd 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -328,6 +328,9 @@ static const struct hid_device_id hid_battery_quirks[] = {
 	{ HID_USB_DEVICE(USB_VENDOR_ID_SYMBOL,
 		USB_DEVICE_ID_SYMBOL_SCANNER_3),
 	  HID_BATTERY_QUIRK_IGNORE },
+	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_ASUSTEK,
+		USB_DEVICE_ID_ASUSTEK_T100CHI_KEYBOARD),
+	  HID_BATTERY_QUIRK_IGNORE },
 	{}
 };
 

commit 2dc702c991e3774af9d7ce410eef410ca9e2357e
Author: Peter Hutterer <peter.hutterer@who-t.net>
Date:   Wed Dec 5 10:42:24 2018 +1000

    HID: input: use the Resolution Multiplier for high-resolution scrolling
    
    Windows uses a magic number of 120 for a wheel click. High-resolution
    scroll wheels are supposed to use a fraction of 120 to signal smaller
    scroll steps. This is implemented by the Resolution Multiplier in the
    device itself.
    
    If the multiplier is present in the report descriptor, set it to the
    logical max and then use the resolution multiplier to calculate the
    high-resolution events. This is the recommendation by Microsoft, see
    http://msdn.microsoft.com/en-us/windows/hardware/gg487477.aspx
    
    Note that all mice encountered so far have a logical min/max of 0/1, so
    it's a binary "yes or no" to high-res scrolling anyway.
    
    To make userspace simpler, always enable the REL_WHEEL_HI_RES bit. Where
    the device doesn't support high-resolution scrolling, the value for the
    high-res data will simply be a multiple of 120 every time. For userspace,
    if REL_WHEEL_HI_RES is available that is the one to be used.
    
    Potential side-effect: a device with a Resolution Multiplier applying to
    other Input items will have those items set to the logical max as well.
    This cannot easily be worked around but it is doubtful such devices exist.
    
    Signed-off-by: Peter Hutterer <peter.hutterer@who-t.net>
    Verified-by: Harry Cutts <hcutts@chromium.org>
    Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index d6fab5798487..59a5608b8dc0 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -712,7 +712,15 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 				map_abs_clear(usage->hid & 0xf);
 			break;
 
-		case HID_GD_SLIDER: case HID_GD_DIAL: case HID_GD_WHEEL:
+		case HID_GD_WHEEL:
+			if (field->flags & HID_MAIN_ITEM_RELATIVE) {
+				set_bit(REL_WHEEL, input->relbit);
+				map_rel(REL_WHEEL_HI_RES);
+			} else {
+				map_abs(usage->hid & 0xf);
+			}
+			break;
+		case HID_GD_SLIDER: case HID_GD_DIAL:
 			if (field->flags & HID_MAIN_ITEM_RELATIVE)
 				map_rel(usage->hid & 0xf);
 			else
@@ -1012,7 +1020,10 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 		case 0x22f: map_key_clear(KEY_ZOOMRESET);	break;
 		case 0x233: map_key_clear(KEY_SCROLLUP);	break;
 		case 0x234: map_key_clear(KEY_SCROLLDOWN);	break;
-		case 0x238: map_rel(REL_HWHEEL);		break;
+		case 0x238: /* AC Pan */
+			set_bit(REL_HWHEEL, input->relbit);
+			map_rel(REL_HWHEEL_HI_RES);
+			break;
 		case 0x23d: map_key_clear(KEY_EDIT);		break;
 		case 0x25f: map_key_clear(KEY_CANCEL);		break;
 		case 0x269: map_key_clear(KEY_INSERT);		break;
@@ -1200,6 +1211,38 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 
 }
 
+static void hidinput_handle_scroll(struct hid_usage *usage,
+				   struct input_dev *input,
+				   __s32 value)
+{
+	int code;
+	int hi_res, lo_res;
+
+	if (value == 0)
+		return;
+
+	if (usage->code == REL_WHEEL_HI_RES)
+		code = REL_WHEEL;
+	else
+		code = REL_HWHEEL;
+
+	/*
+	 * Windows reports one wheel click as value 120. Where a high-res
+	 * scroll wheel is present, a fraction of 120 is reported instead.
+	 * Our REL_WHEEL_HI_RES axis does the same because all HW must
+	 * adhere to the 120 expectation.
+	 */
+	hi_res = value * 120/usage->resolution_multiplier;
+
+	usage->wheel_accumulated += hi_res;
+	lo_res = usage->wheel_accumulated/120;
+	if (lo_res)
+		usage->wheel_accumulated -= lo_res * 120;
+
+	input_event(input, EV_REL, code, lo_res);
+	input_event(input, EV_REL, usage->code, hi_res);
+}
+
 void hidinput_hid_event(struct hid_device *hid, struct hid_field *field, struct hid_usage *usage, __s32 value)
 {
 	struct input_dev *input;
@@ -1262,6 +1305,12 @@ void hidinput_hid_event(struct hid_device *hid, struct hid_field *field, struct
 	if ((usage->type == EV_KEY) && (usage->code == 0)) /* Key 0 is "unassigned", not KEY_UNKNOWN */
 		return;
 
+	if ((usage->type == EV_REL) && (usage->code == REL_WHEEL_HI_RES ||
+					usage->code == REL_HWHEEL_HI_RES)) {
+		hidinput_handle_scroll(usage, input, value);
+		return;
+	}
+
 	if ((usage->type == EV_ABS) && (field->flags & HID_MAIN_ITEM_RELATIVE) &&
 			(usage->code == ABS_VOLUME)) {
 		int count = abs(value);
@@ -1489,6 +1538,58 @@ static void hidinput_close(struct input_dev *dev)
 	hid_hw_close(hid);
 }
 
+static void hidinput_change_resolution_multipliers(struct hid_device *hid)
+{
+	struct hid_report_enum *rep_enum;
+	struct hid_report *rep;
+	struct hid_usage *usage;
+	int i, j;
+
+	rep_enum = &hid->report_enum[HID_FEATURE_REPORT];
+	list_for_each_entry(rep, &rep_enum->report_list, list) {
+		bool update_needed = false;
+
+		if (rep->maxfield == 0)
+			continue;
+
+		/*
+		 * If we have more than one feature within this report we
+		 * need to fill in the bits from the others before we can
+		 * overwrite the ones for the Resolution Multiplier.
+		 */
+		if (rep->maxfield > 1) {
+			hid_hw_request(hid, rep, HID_REQ_GET_REPORT);
+			hid_hw_wait(hid);
+		}
+
+		for (i = 0; i < rep->maxfield; i++) {
+			__s32 logical_max = rep->field[i]->logical_maximum;
+
+			/* There is no good reason for a Resolution
+			 * Multiplier to have a count other than 1.
+			 * Ignore that case.
+			 */
+			if (rep->field[i]->report_count != 1)
+				continue;
+
+			for (j = 0; j < rep->field[i]->maxusage; j++) {
+				usage = &rep->field[i]->usage[j];
+
+				if (usage->hid != HID_GD_RESOLUTION_MULTIPLIER)
+					continue;
+
+				*rep->field[i]->value = logical_max;
+				update_needed = true;
+			}
+		}
+		if (update_needed)
+			hid_hw_request(hid, rep, HID_REQ_SET_REPORT);
+	}
+
+	/* refresh our structs */
+	hid_setup_resolution_multiplier(hid);
+}
+
 static void report_features(struct hid_device *hid)
 {
 	struct hid_driver *drv = hid->driver;
@@ -1782,6 +1883,8 @@ int hidinput_connect(struct hid_device *hid, unsigned int force)
 		}
 	}
 
+	hidinput_change_resolution_multipliers(hid);
+
 	list_for_each_entry_safe(hidinput, next, &hid->inputs, list) {
 		if (drv->input_configured &&
 		    drv->input_configured(hid, hidinput))
@@ -1840,4 +1943,3 @@ void hidinput_disconnect(struct hid_device *hid)
 	cancel_work_sync(&hid->led_work);
 }
 EXPORT_SYMBOL_GPL(hidinput_disconnect);
-

commit f1539a0c2545d7bd82e451bd1464f2a820f55de4
Author: Benjamin Tissoires <benjamin.tissoires@redhat.com>
Date:   Wed Nov 21 16:27:11 2018 +0100

    Revert "HID: input: Create a utility class for counting scroll events"
    
    This reverts commit 1ff2e1a44e02d4bdbb9be67c7d9acc240a67141f.
    
    It turns out the current API is not that compatible with
    some Microsoft mice, so better start again from scratch.
    
    Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Acked-by: Harry Cutts <hcutts@chromium.org>
    Acked-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Acked-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 28ee2ed88a1a..d6fab5798487 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -1841,48 +1841,3 @@ void hidinput_disconnect(struct hid_device *hid)
 }
 EXPORT_SYMBOL_GPL(hidinput_disconnect);
 
-/**
- * hid_scroll_counter_handle_scroll() - Send high- and low-resolution scroll
- *                                      events given a high-resolution wheel
- *                                      movement.
- * @counter: a hid_scroll_counter struct describing the wheel.
- * @hi_res_value: the movement of the wheel, in the mouse's high-resolution
- *                units.
- *
- * Given a high-resolution movement, this function converts the movement into
- * microns and emits high-resolution scroll events for the input device. It also
- * uses the multiplier from &struct hid_scroll_counter to emit low-resolution
- * scroll events when appropriate for backwards-compatibility with userspace
- * input libraries.
- */
-void hid_scroll_counter_handle_scroll(struct hid_scroll_counter *counter,
-				      int hi_res_value)
-{
-	int low_res_scroll_amount;
-	/* Some wheels will rest 7/8ths of a notch from the previous notch
-	 * after slow movement, so we want the threshold for low-res events to
-	 * be in the middle of the notches (e.g. after 4/8ths) as opposed to on
-	 * the notches themselves (8/8ths).
-	 */
-	int threshold = counter->resolution_multiplier / 2;
-
-	input_report_rel(counter->dev, REL_WHEEL_HI_RES,
-			 hi_res_value * counter->microns_per_hi_res_unit);
-
-	counter->remainder += hi_res_value;
-	if (abs(counter->remainder) >= threshold) {
-		/* Add (or subtract) 1 because we want to trigger when the wheel
-		 * is half-way to the next notch (i.e. scroll 1 notch after a
-		 * 1/2 notch movement, 2 notches after a 1 1/2 notch movement,
-		 * etc.).
-		 */
-		low_res_scroll_amount =
-			counter->remainder / counter->resolution_multiplier
-			+ (hi_res_value > 0 ? 1 : -1);
-		input_report_rel(counter->dev, REL_WHEEL,
-				 low_res_scroll_amount);
-		counter->remainder -=
-			low_res_scroll_amount * counter->resolution_multiplier;
-	}
-}
-EXPORT_SYMBOL_GPL(hid_scroll_counter_handle_scroll);

commit e2b95b27196cc90f37016d79432fb2af3f9c9291
Author: Benjamin Tissoires <benjamin.tissoires@redhat.com>
Date:   Wed Nov 21 16:27:06 2018 +0100

    Revert "HID: input: simplify/fix high-res scroll event handling"
    
    This reverts commit 044ee890286153a1aefb40cb8b6659921aecb38b.
    
    It turns out the current API is not that compatible with
    some Microsoft mice, so better start again from scratch.
    
    Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Acked-by: Harry Cutts <hcutts@chromium.org>
    Acked-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Acked-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 44ea8e7c71a9..28ee2ed88a1a 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -1858,30 +1858,31 @@ EXPORT_SYMBOL_GPL(hidinput_disconnect);
 void hid_scroll_counter_handle_scroll(struct hid_scroll_counter *counter,
 				      int hi_res_value)
 {
-	int low_res_value, remainder, multiplier;
+	int low_res_scroll_amount;
+	/* Some wheels will rest 7/8ths of a notch from the previous notch
+	 * after slow movement, so we want the threshold for low-res events to
+	 * be in the middle of the notches (e.g. after 4/8ths) as opposed to on
+	 * the notches themselves (8/8ths).
+	 */
+	int threshold = counter->resolution_multiplier / 2;
 
 	input_report_rel(counter->dev, REL_WHEEL_HI_RES,
 			 hi_res_value * counter->microns_per_hi_res_unit);
 
-	/*
-	 * Update the low-res remainder with the high-res value,
-	 * but reset if the direction has changed.
-	 */
-	remainder = counter->remainder;
-	if ((remainder ^ hi_res_value) < 0)
-		remainder = 0;
-	remainder += hi_res_value;
-
-	/*
-	 * Then just use the resolution multiplier to see if
-	 * we should send a low-res (aka regular wheel) event.
-	 */
-	multiplier = counter->resolution_multiplier;
-	low_res_value = remainder / multiplier;
-	remainder -= low_res_value * multiplier;
-	counter->remainder = remainder;
-
-	if (low_res_value)
-		input_report_rel(counter->dev, REL_WHEEL, low_res_value);
+	counter->remainder += hi_res_value;
+	if (abs(counter->remainder) >= threshold) {
+		/* Add (or subtract) 1 because we want to trigger when the wheel
+		 * is half-way to the next notch (i.e. scroll 1 notch after a
+		 * 1/2 notch movement, 2 notches after a 1 1/2 notch movement,
+		 * etc.).
+		 */
+		low_res_scroll_amount =
+			counter->remainder / counter->resolution_multiplier
+			+ (hi_res_value > 0 ? 1 : -1);
+		input_report_rel(counter->dev, REL_WHEEL,
+				 low_res_scroll_amount);
+		counter->remainder -=
+			low_res_scroll_amount * counter->resolution_multiplier;
+	}
 }
 EXPORT_SYMBOL_GPL(hid_scroll_counter_handle_scroll);

commit 0fd791841a6d67af1155a9c3de54dea51220721e
Author: Benson Leung <bleung@chromium.org>
Date:   Thu Nov 8 15:59:21 2018 -0800

    HID: input: Ignore battery reported by Symbol DS4308
    
    The Motorola/Zebra Symbol DS4308-HD is a handheld USB barcode scanner
    which does not have a battery, but reports one anyway that always has
    capacity 2.
    
    Let's apply the IGNORE quirk to prevent it from being treated like a
    power supply so that userspaces don't get confused that this
    accessory is almost out of power and warn the user that they need to charge
    their wired barcode scanner.
    
    Reported here: https://bugs.chromium.org/p/chromium/issues/detail?id=804720
    
    Signed-off-by: Benson Leung <bleung@chromium.org>
    Reviewed-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index a2f74e6adc70..44ea8e7c71a9 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -325,6 +325,9 @@ static const struct hid_device_id hid_battery_quirks[] = {
 	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_ELECOM,
 		USB_DEVICE_ID_ELECOM_BM084),
 	  HID_BATTERY_QUIRK_IGNORE },
+	{ HID_USB_DEVICE(USB_VENDOR_ID_SYMBOL,
+		USB_DEVICE_ID_SYMBOL_SCANNER_3),
+	  HID_BATTERY_QUIRK_IGNORE },
 	{}
 };
 

commit 044ee890286153a1aefb40cb8b6659921aecb38b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Oct 29 11:25:24 2018 -0700

    HID: input: simplify/fix high-res scroll event handling
    
    Commit 1ff2e1a44e02 ("HID: input: Create a utility class for counting
    scroll events") created the helper function
    
        hid_scroll_counter_handle_scroll()
    
    to handle high-res scroll events and also expose them as regular wheel
    events.
    
    But the resulting algorithm was unstable, and causes scrolling to be
    very unreliable.  When you hit the half-way mark of the highres
    multiplier, small highres movements will incorrectly translate into big
    traditional wheel movements, causing odd jitters.
    
    Simplify the code and make the output stable.
    
    NOTE! I'm pretty sure this will need further tweaking.  But this at
    least turns a unusable mouse wheel on my Logitech MX Anywhere 2S into
    a usable one.
    
    Cc: Jiri Kosina <jikos@kernel.org>
    Cc: Harry Cutts <hcutts@chromium.org>
    Cc: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Cc: Peter Hutterer <peter.hutterer@who-t.net>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 567c3bf64515..a2f74e6adc70 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -1855,31 +1855,30 @@ EXPORT_SYMBOL_GPL(hidinput_disconnect);
 void hid_scroll_counter_handle_scroll(struct hid_scroll_counter *counter,
 				      int hi_res_value)
 {
-	int low_res_scroll_amount;
-	/* Some wheels will rest 7/8ths of a notch from the previous notch
-	 * after slow movement, so we want the threshold for low-res events to
-	 * be in the middle of the notches (e.g. after 4/8ths) as opposed to on
-	 * the notches themselves (8/8ths).
-	 */
-	int threshold = counter->resolution_multiplier / 2;
+	int low_res_value, remainder, multiplier;
 
 	input_report_rel(counter->dev, REL_WHEEL_HI_RES,
 			 hi_res_value * counter->microns_per_hi_res_unit);
 
-	counter->remainder += hi_res_value;
-	if (abs(counter->remainder) >= threshold) {
-		/* Add (or subtract) 1 because we want to trigger when the wheel
-		 * is half-way to the next notch (i.e. scroll 1 notch after a
-		 * 1/2 notch movement, 2 notches after a 1 1/2 notch movement,
-		 * etc.).
-		 */
-		low_res_scroll_amount =
-			counter->remainder / counter->resolution_multiplier
-			+ (hi_res_value > 0 ? 1 : -1);
-		input_report_rel(counter->dev, REL_WHEEL,
-				 low_res_scroll_amount);
-		counter->remainder -=
-			low_res_scroll_amount * counter->resolution_multiplier;
-	}
+	/*
+	 * Update the low-res remainder with the high-res value,
+	 * but reset if the direction has changed.
+	 */
+	remainder = counter->remainder;
+	if ((remainder ^ hi_res_value) < 0)
+		remainder = 0;
+	remainder += hi_res_value;
+
+	/*
+	 * Then just use the resolution multiplier to see if
+	 * we should send a low-res (aka regular wheel) event.
+	 */
+	multiplier = counter->resolution_multiplier;
+	low_res_value = remainder / multiplier;
+	remainder -= low_res_value * multiplier;
+	counter->remainder = remainder;
+
+	if (low_res_value)
+		input_report_rel(counter->dev, REL_WHEEL, low_res_value);
 }
 EXPORT_SYMBOL_GPL(hid_scroll_counter_handle_scroll);

commit 276e722761a1c7903fbfb065420fd1850b00f1dd
Merge: 4e7be68e8d0f d9ca1c990a7f
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Tue Oct 23 13:35:22 2018 +0200

    Merge branch 'for-4.20/logitech-highres' into for-linus
    
    High-resolution support for hid-logitech

commit d93af50ed68c0f079fa10491c6bd56daf74d601b
Merge: 037ad063f797 8473a93d1ba5
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Tue Oct 23 13:17:27 2018 +0200

    Merge branch 'for-4.20/core' into for-linus
    
    Fixes and new features for driver core. Highlights:
    
    - maximum global item tag report size gets increased to 256
    - improved INPUT_PROP reporting for Digitizer devices

commit 8473a93d1ba5385f63a128a285702ccc1d3ae2cc
Author: Tatsunosuke Tobita <junkpainting@gmail.com>
Date:   Wed Aug 8 09:31:43 2018 +0900

    HID: input: Set INPUT_PROP_-property for HID_UP_DIGITIZERS
    
    Some system may want to know if a detected digitizer device is either an
    integrated or an external device.  In order to distinguish such condition,
    setting either INPUT_PROP_DIRECT or INPUT_PROP_POINTER is required,
    checking the member, "application", in "hid_field" structure.
    
    Signed-off-by: Tatsunosuke Tobita <tobita.tatsunosuke@wacom.co.jp>
    Reviewed-by: Ping Cheng <ping.cheng@wacom.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 83755ba33ef4..42c1a4c2a978 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -758,6 +758,11 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 		break;
 
 	case HID_UP_DIGITIZER:
+		if ((field->application & 0xff) == 0x01) /* Digitizer */
+			__set_bit(INPUT_PROP_POINTER, input->propbit);
+		else if ((field->application & 0xff) == 0x02) /* Pen */
+			__set_bit(INPUT_PROP_DIRECT, input->propbit);
+
 		switch (usage->hid & 0xff) {
 		case 0x00: /* Undefined */
 			goto ignore;

commit 1ff2e1a44e02d4bdbb9be67c7d9acc240a67141f
Author: Harry Cutts <hcutts@chromium.org>
Date:   Thu Aug 30 14:56:19 2018 -0700

    HID: input: Create a utility class for counting scroll events
    
    To avoid code duplication, this class counts high-resolution scroll
    movements and emits the legacy low-resolution events when appropriate.
    Drivers should be able to create one instance for each scroll wheel that
    they need to handle.
    
    Signed-off-by: Harry Cutts <hcutts@chromium.org>
    Reviewed-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 4e94ea3e280a..6e84e7b9afcb 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -1826,3 +1826,48 @@ void hidinput_disconnect(struct hid_device *hid)
 }
 EXPORT_SYMBOL_GPL(hidinput_disconnect);
 
+/**
+ * hid_scroll_counter_handle_scroll() - Send high- and low-resolution scroll
+ *                                      events given a high-resolution wheel
+ *                                      movement.
+ * @counter: a hid_scroll_counter struct describing the wheel.
+ * @hi_res_value: the movement of the wheel, in the mouse's high-resolution
+ *                units.
+ *
+ * Given a high-resolution movement, this function converts the movement into
+ * microns and emits high-resolution scroll events for the input device. It also
+ * uses the multiplier from &struct hid_scroll_counter to emit low-resolution
+ * scroll events when appropriate for backwards-compatibility with userspace
+ * input libraries.
+ */
+void hid_scroll_counter_handle_scroll(struct hid_scroll_counter *counter,
+				      int hi_res_value)
+{
+	int low_res_scroll_amount;
+	/* Some wheels will rest 7/8ths of a notch from the previous notch
+	 * after slow movement, so we want the threshold for low-res events to
+	 * be in the middle of the notches (e.g. after 4/8ths) as opposed to on
+	 * the notches themselves (8/8ths).
+	 */
+	int threshold = counter->resolution_multiplier / 2;
+
+	input_report_rel(counter->dev, REL_WHEEL_HI_RES,
+			 hi_res_value * counter->microns_per_hi_res_unit);
+
+	counter->remainder += hi_res_value;
+	if (abs(counter->remainder) >= threshold) {
+		/* Add (or subtract) 1 because we want to trigger when the wheel
+		 * is half-way to the next notch (i.e. scroll 1 notch after a
+		 * 1/2 notch movement, 2 notches after a 1 1/2 notch movement,
+		 * etc.).
+		 */
+		low_res_scroll_amount =
+			counter->remainder / counter->resolution_multiplier
+			+ (hi_res_value > 0 ? 1 : -1);
+		input_report_rel(counter->dev, REL_WHEEL,
+				 low_res_scroll_amount);
+		counter->remainder -=
+			low_res_scroll_amount * counter->resolution_multiplier;
+	}
+}
+EXPORT_SYMBOL_GPL(hid_scroll_counter_handle_scroll);

commit d7065620b89fcc183caa6fa6ea36de5e01211137
Author: Benjamin Tissoires <benjamin.tissoires@redhat.com>
Date:   Tue Sep 4 15:31:13 2018 +0200

    HID: input: do not append a suffix if the name already has it
    
    Or it creates some weird input names like:
    "MI Dongle MI Wireless Mouse Mouse"
    
    Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 4e94ea3e280a..83755ba33ef4 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -1516,6 +1516,7 @@ static struct hid_input *hidinput_allocate(struct hid_device *hid,
 	struct hid_input *hidinput = kzalloc(sizeof(*hidinput), GFP_KERNEL);
 	struct input_dev *input_dev = input_allocate_device();
 	const char *suffix = NULL;
+	size_t suffix_len, name_len;
 
 	if (!hidinput || !input_dev)
 		goto fail;
@@ -1559,10 +1560,15 @@ static struct hid_input *hidinput_allocate(struct hid_device *hid,
 	}
 
 	if (suffix) {
-		hidinput->name = kasprintf(GFP_KERNEL, "%s %s",
-					   hid->name, suffix);
-		if (!hidinput->name)
-			goto fail;
+		name_len = strlen(hid->name);
+		suffix_len = strlen(suffix);
+		if ((name_len < suffix_len) ||
+		    strcmp(hid->name + name_len - suffix_len, suffix)) {
+			hidinput->name = kasprintf(GFP_KERNEL, "%s %s",
+						   hid->name, suffix);
+			if (!hidinput->name)
+				goto fail;
+		}
 	}
 
 	input_set_drvdata(input_dev, hid);

commit 0d6c3011409135ea84e2a231b013a22017ff999a
Author: Benjamin Tissoires <benjamin.tissoires@redhat.com>
Date:   Tue Sep 4 15:31:14 2018 +0200

    HID: core: fix grouping by application
    
    commit f07b3c1da92d ("HID: generic: create one input report per
    application type") was effectively the same as MULTI_INPUT:
    hidinput->report was never set, so hidinput_match_application()
    always returned null.
    
    Fix that by testing against the real application.
    
    Note that this breaks some old eGalax touchscreens that expect MULTI_INPUT
    instead of HID_QUIRK_INPUT_PER_APP. Enable this quirk for backward
    compatibility on all non-Win8 touchscreens.
    
    link: https://bugzilla.kernel.org/show_bug.cgi?id=200847
    link: https://bugzilla.kernel.org/show_bug.cgi?id=200849
    link: https://bugs.archlinux.org/task/59699
    link: https://github.com/NixOS/nixpkgs/issues/45165
    
    Cc: stable@vger.kernel.org # v4.18+
    Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index ac201817a2dd..a481eaf39e88 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -1582,6 +1582,7 @@ static struct hid_input *hidinput_allocate(struct hid_device *hid,
 	input_dev->dev.parent = &hid->dev;
 
 	hidinput->input = input_dev;
+	hidinput->application = application;
 	list_add_tail(&hidinput->list, &hid->inputs);
 
 	INIT_LIST_HEAD(&hidinput->reports);
@@ -1677,8 +1678,7 @@ static struct hid_input *hidinput_match_application(struct hid_report *report)
 	struct hid_input *hidinput;
 
 	list_for_each_entry(hidinput, &hid->inputs, list) {
-		if (hidinput->report &&
-		    hidinput->report->application == report->application)
+		if (hidinput->application == report->application)
 			return hidinput;
 	}
 

commit e38c0ac55ee67cf3626cfbc2283f8873dc44d370
Author: Stefan Agner <stefan@agner.ch>
Date:   Tue Aug 28 13:29:55 2018 +0200

    HID: input: fix leaking custom input node name
    
    Make sure to free the custom input node name on disconnect.
    
    Cc: stable@vger.kernel.org # v4.18+
    Fixes: c554bb045511 ("HID: input: append a suffix matching the application")
    Signed-off-by: Stefan Agner <stefan@agner.ch>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 4e94ea3e280a..ac201817a2dd 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -1815,6 +1815,7 @@ void hidinput_disconnect(struct hid_device *hid)
 			input_unregister_device(hidinput->input);
 		else
 			input_free_device(hidinput->input);
+		kfree(hidinput->name);
 		kfree(hidinput);
 	}
 

commit ba6b055e0f3b4ff4942e4ab273260affcfad9bff
Author: Benjamin Tissoires <benjamin.tissoires@redhat.com>
Date:   Fri Jul 13 16:13:49 2018 +0200

    HID: input: enable Totem on the Dell Canvas 27
    
    The Dell Canvas 27 has a tool that can be put on the surface and acts
    as a dial. The firmware processes the detection of the tool and forward
    regular HID reports with X, Y, Azimuth, rotation, width/height.
    
    The firmware also exports Contact ID, Countact Count which may hint that
    several totems can be used at the same time (the FW only supports one).
    
    We can tell that MT_TOOL_DIAL will be reported by setting the min/max
    of ABS_MT_TOOL_TYPE to MT_TOOL_DIAL.
    
    This tool is aimed at being used by the system and not the applications,
    so the user space processing should not go through the regular touch
    inputs.
    We set INPUT_PROP_DIRECT which applies ID_INPUT_TOUCHSCREEN to this new
    type of devices, but we will counter this for the time being with the
    special udev hwdb entry mentioned above.
    
    Link: https://bugzilla.redhat.com/show_bug.cgi?id=1511846
    
    Acked-by: Peter Hutterer <peter.hutterer@who-t.net>
    Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index ab93dd5927c3..4e94ea3e280a 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -1550,6 +1550,9 @@ static struct hid_input *hidinput_allocate(struct hid_device *hid,
 		case HID_GD_WIRELESS_RADIO_CTLS:
 			suffix = "Wireless Radio Control";
 			break;
+		case HID_GD_SYSTEM_MULTIAXIS:
+			suffix = "System Multi Axis";
+			break;
 		default:
 			break;
 		}

commit 25721aefe1d0b0d604d66fb5912fb383ce56c6ac
Merge: 72d0beb4d6d4 abb36fe691b2
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Fri Jun 8 10:25:50 2018 +0200

    Merge branch 'for-4.18/multitouch' into for-linus
    
    - improvement of duplicate usage handling in hid-input from Benjamin Tissoires
    - Win 8.1 precisioun touchpad spec implementation from Benjamin Tissoires

commit c554bb045511bd6b498b6a61cffa48e473853703
Author: Benjamin Tissoires <benjamin.tissoires@redhat.com>
Date:   Tue Apr 24 10:04:34 2018 +0200

    HID: input: append a suffix matching the application
    
    Given that we create one input node per application, we should name
    the input node accordingly to not lose userspace.
    
    Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 7463ee2a1df2..fea6d4898f15 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -1500,15 +1500,56 @@ static void report_features(struct hid_device *hid)
 		}
 }
 
-static struct hid_input *hidinput_allocate(struct hid_device *hid)
+static struct hid_input *hidinput_allocate(struct hid_device *hid,
+					   unsigned int application)
 {
 	struct hid_input *hidinput = kzalloc(sizeof(*hidinput), GFP_KERNEL);
 	struct input_dev *input_dev = input_allocate_device();
-	if (!hidinput || !input_dev) {
-		kfree(hidinput);
-		input_free_device(input_dev);
-		hid_err(hid, "Out of memory during hid input probe\n");
-		return NULL;
+	const char *suffix = NULL;
+
+	if (!hidinput || !input_dev)
+		goto fail;
+
+	if ((hid->quirks & HID_QUIRK_INPUT_PER_APP) &&
+	    hid->maxapplication > 1) {
+		switch (application) {
+		case HID_GD_KEYBOARD:
+			suffix = "Keyboard";
+			break;
+		case HID_GD_KEYPAD:
+			suffix = "Keypad";
+			break;
+		case HID_GD_MOUSE:
+			suffix = "Mouse";
+			break;
+		case HID_DG_STYLUS:
+			suffix = "Pen";
+			break;
+		case HID_DG_TOUCHSCREEN:
+			suffix = "Touchscreen";
+			break;
+		case HID_DG_TOUCHPAD:
+			suffix = "Touchpad";
+			break;
+		case HID_GD_SYSTEM_CONTROL:
+			suffix = "System Control";
+			break;
+		case HID_CP_CONSUMER_CONTROL:
+			suffix = "Consumer Control";
+			break;
+		case HID_GD_WIRELESS_RADIO_CTLS:
+			suffix = "Wireless Radio Control";
+			break;
+		default:
+			break;
+		}
+	}
+
+	if (suffix) {
+		hidinput->name = kasprintf(GFP_KERNEL, "%s %s",
+					   hid->name, suffix);
+		if (!hidinput->name)
+			goto fail;
 	}
 
 	input_set_drvdata(input_dev, hid);
@@ -1518,7 +1559,7 @@ static struct hid_input *hidinput_allocate(struct hid_device *hid)
 	input_dev->setkeycode = hidinput_setkeycode;
 	input_dev->getkeycode = hidinput_getkeycode;
 
-	input_dev->name = hid->name;
+	input_dev->name = hidinput->name ? hidinput->name : hid->name;
 	input_dev->phys = hid->phys;
 	input_dev->uniq = hid->uniq;
 	input_dev->id.bustype = hid->bus;
@@ -1533,6 +1574,12 @@ static struct hid_input *hidinput_allocate(struct hid_device *hid)
 	INIT_LIST_HEAD(&hidinput->reports);
 
 	return hidinput;
+
+fail:
+	kfree(hidinput);
+	input_free_device(input_dev);
+	hid_err(hid, "Out of memory during hid input probe\n");
+	return NULL;
 }
 
 static bool hidinput_has_been_populated(struct hid_input *hidinput)
@@ -1578,6 +1625,7 @@ static void hidinput_cleanup_hidinput(struct hid_device *hid,
 
 	list_del(&hidinput->list);
 	input_free_device(hidinput->input);
+	kfree(hidinput->name);
 
 	for (k = HID_INPUT_REPORT; k <= HID_OUTPUT_REPORT; k++) {
 		if (k == HID_OUTPUT_REPORT &&
@@ -1646,6 +1694,7 @@ int hidinput_connect(struct hid_device *hid, unsigned int force)
 	struct hid_driver *drv = hid->driver;
 	struct hid_report *report;
 	struct hid_input *next, *hidinput = NULL;
+	unsigned int application;
 	int i, k;
 
 	INIT_LIST_HEAD(&hid->inputs);
@@ -1678,6 +1727,8 @@ int hidinput_connect(struct hid_device *hid, unsigned int force)
 			if (!report->maxfield)
 				continue;
 
+			application = report->application;
+
 			/*
 			 * Find the previous hidinput report attached
 			 * to this report id.
@@ -1689,7 +1740,7 @@ int hidinput_connect(struct hid_device *hid, unsigned int force)
 				hidinput = hidinput_match_application(report);
 
 			if (!hidinput) {
-				hidinput = hidinput_allocate(hid);
+				hidinput = hidinput_allocate(hid, application);
 				if (!hidinput)
 					goto out_unwind;
 			}

commit f07b3c1da92db108662f99417a212fc1eddc44d1
Author: Benjamin Tissoires <benjamin.tissoires@redhat.com>
Date:   Tue Apr 24 10:04:33 2018 +0200

    HID: generic: create one input report per application type
    
    It is not a good idea to try to fit all types of applications in the
    same input report. There are a lot of devices that are needing
    the quirk HID_MULTI_INPUT but this quirk doesn't match the actual HID
    description as it is based on the report ID.
    
    Given that most devices with MULTI_INPUT I can think of split nicely
    the devices inputs into application, it is a good thing to split the
    devices by default based on this assumption.
    
    Also make hid-multitouch following this rule, to not have to deal
    with too many input created.
    
    While we are at it, fix some checkpatch complaints about converting
    'unsigned' to 'unsigned int'.
    
    Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index fd1c4fe70327..7463ee2a1df2 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -1610,6 +1610,20 @@ static struct hid_input *hidinput_match(struct hid_report *report)
 	return NULL;
 }
 
+static struct hid_input *hidinput_match_application(struct hid_report *report)
+{
+	struct hid_device *hid = report->device;
+	struct hid_input *hidinput;
+
+	list_for_each_entry(hidinput, &hid->inputs, list) {
+		if (hidinput->report &&
+		    hidinput->report->application == report->application)
+			return hidinput;
+	}
+
+	return NULL;
+}
+
 static inline void hidinput_configure_usages(struct hid_input *hidinput,
 					     struct hid_report *report)
 {
@@ -1670,6 +1684,9 @@ int hidinput_connect(struct hid_device *hid, unsigned int force)
 			 */
 			if (hid->quirks & HID_QUIRK_MULTI_INPUT)
 				hidinput = hidinput_match(report);
+			else if (hid->maxapplication > 1 &&
+				 (hid->quirks & HID_QUIRK_INPUT_PER_APP))
+				hidinput = hidinput_match_application(report);
 
 			if (!hidinput) {
 				hidinput = hidinput_allocate(hid);

commit e1b63c0148a7f8edf1691770ec0527fe86fb6ab8
Author: Benjamin Tissoires <benjamin.tissoires@redhat.com>
Date:   Tue Apr 24 10:04:32 2018 +0200

    HID: store the full list of reports in the hidinput
    
    We were only storing the report in case of QUIRK_MULTI_INPUT.
    It is interesting for the upcoming  HID_QUIRK_INPUT_PER_APP to also
    store the full list of reports that are attached to it.
    
    We need the full list because a device (Advanced Silicon has some)
    might want to use a different report ID for the Input reports and
    the Output reports. Storing the full list allows the drivers to
    have all the data.
    
    Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 04056773102e..fd1c4fe70327 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -1526,9 +1526,12 @@ static struct hid_input *hidinput_allocate(struct hid_device *hid)
 	input_dev->id.product = hid->product;
 	input_dev->id.version = hid->version;
 	input_dev->dev.parent = &hid->dev;
+
 	hidinput->input = input_dev;
 	list_add_tail(&hidinput->list, &hid->inputs);
 
+	INIT_LIST_HEAD(&hidinput->reports);
+
 	return hidinput;
 }
 
@@ -1678,6 +1681,9 @@ int hidinput_connect(struct hid_device *hid, unsigned int force)
 
 			if (hid->quirks & HID_QUIRK_MULTI_INPUT)
 				hidinput->report = report;
+
+			list_add_tail(&report->hidinput_list,
+				      &hidinput->reports);
 		}
 	}
 

commit 190d7f02ce8ef6774a69d3ec18c288c8a9601a4e
Author: Benjamin Tissoires <benjamin.tissoires@redhat.com>
Date:   Fri Dec 8 15:28:18 2017 +0100

    HID: input: do not increment usages when a duplicate is found
    
    This is something that bothered us from a long time. When hid-input
    doesn't know how to map a usage, it uses *_MISC. But there is something
    else which increments the usage if the evdev code is already used.
    
    This leads to few issues:
    - some devices may have their ABS_X mapped to ABS_Y if they export a bad
      set of usages (see the DragonRise joysticks IIRC -> fixed in a specific
      HID driver)
    - *_MISC + N might (will) conflict with other defined axes (my Logitech
      H800 exports some multitouch axes because of that)
    - this prevents to freely add some new evdev usages, because "hey, my
      headset will now report ABS_COFFEE, and it's not coffee capable".
    
    So let's try to kill this nonsense, and hope we won't break too many
    devices.
    
    I my headset case, the ABS_MISC axes are created because of some
    proprietary usages, so we might not break that many devices.
    
    For backward compatibility, a quirk HID_QUIRK_INCREMENT_USAGE_ON_DUPLICATE
    is created and can be applied to any device that needs this behavior.
    
    Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Acked-by: Peter Hutterer <peter.hutterer@who-t.net>
    Acked-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 6836a856c243..04056773102e 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -1100,8 +1100,31 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 
 	set_bit(usage->type, input->evbit);
 
-	while (usage->code <= max && test_and_set_bit(usage->code, bit))
-		usage->code = find_next_zero_bit(bit, max + 1, usage->code);
+	/*
+	 * This part is *really* controversial:
+	 * - HID aims at being generic so we should do our best to export
+	 *   all incoming events
+	 * - HID describes what events are, so there is no reason for ABS_X
+	 *   to be mapped to ABS_Y
+	 * - HID is using *_MISC+N as a default value, but nothing prevents
+	 *   *_MISC+N to overwrite a legitimate even, which confuses userspace
+	 *   (for instance ABS_MISC + 7 is ABS_MT_SLOT, which has a different
+	 *   processing)
+	 *
+	 * If devices still want to use this (at their own risk), they will
+	 * have to use the quirk HID_QUIRK_INCREMENT_USAGE_ON_DUPLICATE, but
+	 * the default should be a reliable mapping.
+	 */
+	while (usage->code <= max && test_and_set_bit(usage->code, bit)) {
+		if (device->quirks & HID_QUIRK_INCREMENT_USAGE_ON_DUPLICATE) {
+			usage->code = find_next_zero_bit(bit,
+							 max + 1,
+							 usage->code);
+		} else {
+			device->status |= HID_STAT_DUP_DETECTED;
+			goto ignore;
+		}
+	}
 
 	if (usage->code > max)
 		goto ignore;
@@ -1611,6 +1634,8 @@ int hidinput_connect(struct hid_device *hid, unsigned int force)
 	INIT_LIST_HEAD(&hid->inputs);
 	INIT_WORK(&hid->led_work, hidinput_led_worker);
 
+	hid->status &= ~HID_STAT_DUP_DETECTED;
+
 	if (!force) {
 		for (i = 0; i < hid->maxcollection; i++) {
 			struct hid_collection *col = &hid->collection[i];
@@ -1677,6 +1702,10 @@ int hidinput_connect(struct hid_device *hid, unsigned int force)
 		goto out_unwind;
 	}
 
+	if (hid->status & HID_STAT_DUP_DETECTED)
+		hid_dbg(hid,
+			"Some usages could not be mapped, please use HID_QUIRK_INCREMENT_USAGE_ON_DUPLICATE if this is legitimate.\n");
+
 	return 0;
 
 out_unwind:

commit 2e210bbb7429cdcf1a1a3ad00c1bf98bd9bf2452
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Tue Apr 3 10:52:20 2018 -0700

    HID: input: fix battery level reporting on BT mice
    
    The commit 581c4484769e ("HID: input: map digitizer battery usage")
    assumed that devices having input (qas opposed to feature) report for
    battery strength would report the data on their own, without the need to
    be polled by the kernel; unfortunately it is not so. Many wireless mice
    do not send unsolicited reports with battery strength data and have to
    be polled explicitly. As a complication, stylus devices on digitizers
    are not normally connected to the base and thus can not be polled - the
    base can only determine battery strength in the stylus when it is in
    proximity.
    
    To solve this issue, we add a special flag that tells the kernel
    to avoid polling the device (and expect unsolicited reports) and set it
    when report field with physical usage of digitizer stylus (HID_DG_STYLUS).
    Unless this flag is set, and we have not seen the unsolicited reports,
    the kernel will attempt to poll the device when userspace attempts to
    read "capacity" and "state" attributes of power_supply object
    corresponding to the devices battery.
    
    Fixes: 581c4484769e ("HID: input: map digitizer battery usage")
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=198095
    Cc: stable@vger.kernel.org
    Reported-and-tested-by: Martin van Es <martin@mrvanes.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 6836a856c243..930652c25120 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -387,7 +387,8 @@ static int hidinput_get_battery_property(struct power_supply *psy,
 		break;
 
 	case POWER_SUPPLY_PROP_CAPACITY:
-		if (dev->battery_report_type == HID_FEATURE_REPORT) {
+		if (dev->battery_status != HID_BATTERY_REPORTED &&
+		    !dev->battery_avoid_query) {
 			value = hidinput_query_battery_capacity(dev);
 			if (value < 0)
 				return value;
@@ -403,17 +404,17 @@ static int hidinput_get_battery_property(struct power_supply *psy,
 		break;
 
 	case POWER_SUPPLY_PROP_STATUS:
-		if (!dev->battery_reported &&
-		    dev->battery_report_type == HID_FEATURE_REPORT) {
+		if (dev->battery_status != HID_BATTERY_REPORTED &&
+		    !dev->battery_avoid_query) {
 			value = hidinput_query_battery_capacity(dev);
 			if (value < 0)
 				return value;
 
 			dev->battery_capacity = value;
-			dev->battery_reported = true;
+			dev->battery_status = HID_BATTERY_QUERIED;
 		}
 
-		if (!dev->battery_reported)
+		if (dev->battery_status == HID_BATTERY_UNKNOWN)
 			val->intval = POWER_SUPPLY_STATUS_UNKNOWN;
 		else if (dev->battery_capacity == 100)
 			val->intval = POWER_SUPPLY_STATUS_FULL;
@@ -486,6 +487,14 @@ static int hidinput_setup_battery(struct hid_device *dev, unsigned report_type,
 	dev->battery_report_type = report_type;
 	dev->battery_report_id = field->report->id;
 
+	/*
+	 * Stylus is normally not connected to the device and thus we
+	 * can't query the device and get meaningful battery strength.
+	 * We have to wait for the device to report it on its own.
+	 */
+	dev->battery_avoid_query = report_type == HID_INPUT_REPORT &&
+				   field->physical == HID_DG_STYLUS;
+
 	dev->battery = power_supply_register(&dev->dev, psy_desc, &psy_cfg);
 	if (IS_ERR(dev->battery)) {
 		error = PTR_ERR(dev->battery);
@@ -530,9 +539,10 @@ static void hidinput_update_battery(struct hid_device *dev, int value)
 
 	capacity = hidinput_scale_battery_capacity(dev, value);
 
-	if (!dev->battery_reported || capacity != dev->battery_capacity) {
+	if (dev->battery_status != HID_BATTERY_REPORTED ||
+	    capacity != dev->battery_capacity) {
 		dev->battery_capacity = capacity;
-		dev->battery_reported = true;
+		dev->battery_status = HID_BATTERY_REPORTED;
 		power_supply_changed(dev->battery);
 	}
 }

commit af73686e7bfe49fbbccc099995be8c78ce5bfe9a
Merge: f73fee743b5c 2904e68ff2ce
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Thu Apr 5 13:19:57 2018 +0200

    Merge branch 'for-4.17/multitouch' into for-linus
    
    Pull Razer Blade Stealth support improvement and a few generic cleanups

commit 39335d1cbb8fb3260ac5f18fbcc45beb690e5ebd
Author: Benjamin Tissoires <benjamin.tissoires@redhat.com>
Date:   Tue Mar 20 12:04:49 2018 +0100

    HID: core: remove the need for HID_QUIRK_NO_EMPTY_INPUT
    
    There is no real point of registering an empty input node.
    This should be default, but given some drivers need the blank input
    node to set it up during input_configured, we need to postpone
    the check for hidinput_has_been_populated().
    
    Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Acked-by: Peter Hutterer <peter.hutterer@who-t.net>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 04d01b57d94c..b237b5590227 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -1656,16 +1656,16 @@ int hidinput_connect(struct hid_device *hid, unsigned int force)
 	}
 
 	list_for_each_entry_safe(hidinput, next, &hid->inputs, list) {
-		if ((hid->quirks & HID_QUIRK_NO_EMPTY_INPUT) &&
-		    !hidinput_has_been_populated(hidinput)) {
+		if (drv->input_configured &&
+		    drv->input_configured(hid, hidinput))
+			goto out_unwind;
+
+		if (!hidinput_has_been_populated(hidinput)) {
 			/* no need to register an input device not populated */
 			hidinput_cleanup_hidinput(hid, hidinput);
 			continue;
 		}
 
-		if (drv->input_configured &&
-		    drv->input_configured(hid, hidinput))
-			goto out_unwind;
 		if (input_register_device(hidinput->input))
 			goto out_unwind;
 		hidinput->registered = true;

commit 3064a03b94e60388f0955fcc29f3e8a978d28f75
Author: Aaron Ma <aaron.ma@canonical.com>
Date:   Sat Feb 3 23:57:15 2018 +0800

    HID: Fix hid_report_len usage
    
    Follow the change of return type u32 of hid_report_len,
    fix all the types of variables those get the return value of
    hid_report_len to u32, and all other code already uses u32.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Aaron Ma <aaron.ma@canonical.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 04d01b57d94c..d86398755b0d 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -1368,7 +1368,8 @@ static void hidinput_led_worker(struct work_struct *work)
 					      led_work);
 	struct hid_field *field;
 	struct hid_report *report;
-	int len, ret;
+	int ret;
+	u32 len;
 	__u8 *buf;
 
 	field = hidinput_get_led_field(hid);

commit 654c192a72ffa7e415a9f58a4f4c5f4368b754e7
Author: Ping Cheng <pinglinux@gmail.com>
Date:   Tue Oct 3 15:05:41 2017 -0700

    HID: hid-input: Add eraser usage to hidinput_configure_usage
    
    Some tablets report eraser usage to indicate the eraser tool tip
    is touching the surface. But, hidinput_configure_usage didn't
    support the usage, which led it falls into default as ABS_MISC.
    
    Signed-off-by: Ping Cheng <ping.cheng@wacom.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 199f6a01fc62..04d01b57d94c 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -797,6 +797,15 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 			map_key_clear(BTN_STYLUS);
 			break;
 
+		case 0x45: /* ERASER */
+			/*
+			 * This event is reported when eraser tip touches the surface.
+			 * Actual eraser (BTN_TOOL_RUBBER) is set by Invert usage when
+			 * tool gets in proximity.
+			 */
+			map_key_clear(BTN_TOUCH);
+			break;
+
 		case 0x46: /* TabletPick */
 		case 0x5a: /* SecondaryBarrelSwitch */
 			map_key_clear(BTN_STYLUS2);

commit 0152b29c89650654abf4f0e96bbf2566b85ae55d
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Thu Aug 10 12:47:56 2017 -0700

    HID: input: throttle battery uevents
    
    The power_supply subsystem tends to emit uevent every time
    power_supply_changed() is called, so we should call this API only when battery
    strength reported by the device is actually different from the previous
    readings, otherwise we'll drown the system in uevents.
    
    Fixes: 581c4484769e ("HID: input: map digitizer battery usage")
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 27d8442b017d..199f6a01fc62 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -520,15 +520,21 @@ static void hidinput_cleanup_battery(struct hid_device *dev)
 
 static void hidinput_update_battery(struct hid_device *dev, int value)
 {
+	int capacity;
+
 	if (!dev->battery)
 		return;
 
 	if (value == 0 || value < dev->battery_min || value > dev->battery_max)
 		return;
 
-	dev->battery_capacity = hidinput_scale_battery_capacity(dev, value);
-	dev->battery_reported = true;
-	power_supply_changed(dev->battery);
+	capacity = hidinput_scale_battery_capacity(dev, value);
+
+	if (!dev->battery_reported || capacity != dev->battery_capacity) {
+		dev->battery_capacity = capacity;
+		dev->battery_reported = true;
+		power_supply_changed(dev->battery);
+	}
 }
 #else  /* !CONFIG_HID_BATTERY_STRENGTH */
 static int hidinput_setup_battery(struct hid_device *dev, unsigned report_type,

commit 0922386538f9da8f242b1d52b5538bf9b8ddded5
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Tue Aug 1 15:38:02 2017 -0700

    HID: input: optionally use device id in battery name
    
    Manufacturers do not always populate serial number in their devices, so
    let's fall back to device ID when forming the battery device name. As a
    result, batteries in devices without serial number will be named like
    this:
    
            hid-0018:2D1F:510E.0001-battery
    
    (as opposed to hid--battery for the first one, and failing to create
    batteries for the subsequent ones).
    
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 2158ec766dd5..27d8442b017d 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -456,7 +456,9 @@ static int hidinput_setup_battery(struct hid_device *dev, unsigned report_type,
 	if (!psy_desc)
 		return -ENOMEM;
 
-	psy_desc->name = kasprintf(GFP_KERNEL, "hid-%s-battery", dev->uniq);
+	psy_desc->name = kasprintf(GFP_KERNEL, "hid-%s-battery",
+				   strlen(dev->uniq) ?
+					dev->uniq : dev_name(&dev->dev));
 	if (!psy_desc->name) {
 		error = -ENOMEM;
 		goto err_free_mem;

commit 581c4484769e692eade761c17c22549aaefe6749
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Tue Aug 1 15:38:01 2017 -0700

    HID: input: map digitizer battery usage
    
    We already mapped battery strength reports from the generic device
    control page, but we did not update capacity from input reports, nor we
    mapped the battery strength report from the digitizer page, so let's
    implement this now.
    
    Batteries driven by the input reports will now start in "unknown" state,
    and will get updated once we receive first report containing battery
    strength from the device.
    
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index ccdff1ee1f0c..2158ec766dd5 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -340,13 +340,45 @@ static unsigned find_battery_quirk(struct hid_device *hdev)
 	return quirks;
 }
 
+static int hidinput_scale_battery_capacity(struct hid_device *dev,
+					   int value)
+{
+	if (dev->battery_min < dev->battery_max &&
+	    value >= dev->battery_min && value <= dev->battery_max)
+		value = ((value - dev->battery_min) * 100) /
+			(dev->battery_max - dev->battery_min);
+
+	return value;
+}
+
+static int hidinput_query_battery_capacity(struct hid_device *dev)
+{
+	u8 *buf;
+	int ret;
+
+	buf = kmalloc(2, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	ret = hid_hw_raw_request(dev, dev->battery_report_id, buf, 2,
+				 dev->battery_report_type, HID_REQ_GET_REPORT);
+	if (ret != 2) {
+		kfree(buf);
+		return -ENODATA;
+	}
+
+	ret = hidinput_scale_battery_capacity(dev, buf[1]);
+	kfree(buf);
+	return ret;
+}
+
 static int hidinput_get_battery_property(struct power_supply *psy,
 					 enum power_supply_property prop,
 					 union power_supply_propval *val)
 {
 	struct hid_device *dev = power_supply_get_drvdata(psy);
+	int value;
 	int ret = 0;
-	__u8 *buf;
 
 	switch (prop) {
 	case POWER_SUPPLY_PROP_PRESENT:
@@ -355,29 +387,15 @@ static int hidinput_get_battery_property(struct power_supply *psy,
 		break;
 
 	case POWER_SUPPLY_PROP_CAPACITY:
-
-		buf = kmalloc(2 * sizeof(__u8), GFP_KERNEL);
-		if (!buf) {
-			ret = -ENOMEM;
-			break;
-		}
-		ret = hid_hw_raw_request(dev, dev->battery_report_id, buf, 2,
-					 dev->battery_report_type,
-					 HID_REQ_GET_REPORT);
-
-		if (ret != 2) {
-			ret = -ENODATA;
-			kfree(buf);
-			break;
+		if (dev->battery_report_type == HID_FEATURE_REPORT) {
+			value = hidinput_query_battery_capacity(dev);
+			if (value < 0)
+				return value;
+		} else  {
+			value = dev->battery_capacity;
 		}
-		ret = 0;
 
-		if (dev->battery_min < dev->battery_max &&
-		    buf[1] >= dev->battery_min &&
-		    buf[1] <= dev->battery_max)
-			val->intval = (100 * (buf[1] - dev->battery_min)) /
-				(dev->battery_max - dev->battery_min);
-		kfree(buf);
+		val->intval = value;
 		break;
 
 	case POWER_SUPPLY_PROP_MODEL_NAME:
@@ -385,7 +403,22 @@ static int hidinput_get_battery_property(struct power_supply *psy,
 		break;
 
 	case POWER_SUPPLY_PROP_STATUS:
-		val->intval = POWER_SUPPLY_STATUS_DISCHARGING;
+		if (!dev->battery_reported &&
+		    dev->battery_report_type == HID_FEATURE_REPORT) {
+			value = hidinput_query_battery_capacity(dev);
+			if (value < 0)
+				return value;
+
+			dev->battery_capacity = value;
+			dev->battery_reported = true;
+		}
+
+		if (!dev->battery_reported)
+			val->intval = POWER_SUPPLY_STATUS_UNKNOWN;
+		else if (dev->battery_capacity == 100)
+			val->intval = POWER_SUPPLY_STATUS_FULL;
+		else
+			val->intval = POWER_SUPPLY_STATUS_DISCHARGING;
 		break;
 
 	case POWER_SUPPLY_PROP_SCOPE:
@@ -400,18 +433,16 @@ static int hidinput_get_battery_property(struct power_supply *psy,
 	return ret;
 }
 
-static bool hidinput_setup_battery(struct hid_device *dev, unsigned report_type, struct hid_field *field)
+static int hidinput_setup_battery(struct hid_device *dev, unsigned report_type, struct hid_field *field)
 {
-	struct power_supply_desc *psy_desc = NULL;
+	struct power_supply_desc *psy_desc;
 	struct power_supply_config psy_cfg = { .drv_data = dev, };
 	unsigned quirks;
 	s32 min, max;
+	int error;
 
-	if (field->usage->hid != HID_DC_BATTERYSTRENGTH)
-		return false;	/* no match */
-
-	if (dev->battery != NULL)
-		goto out;	/* already initialized? */
+	if (dev->battery)
+		return 0;	/* already initialized? */
 
 	quirks = find_battery_quirk(dev);
 
@@ -419,16 +450,16 @@ static bool hidinput_setup_battery(struct hid_device *dev, unsigned report_type,
 		dev->bus, dev->vendor, dev->product, dev->version, quirks);
 
 	if (quirks & HID_BATTERY_QUIRK_IGNORE)
-		goto out;
+		return 0;
 
 	psy_desc = kzalloc(sizeof(*psy_desc), GFP_KERNEL);
-	if (psy_desc == NULL)
-		goto out;
+	if (!psy_desc)
+		return -ENOMEM;
 
 	psy_desc->name = kasprintf(GFP_KERNEL, "hid-%s-battery", dev->uniq);
-	if (psy_desc->name == NULL) {
-		kfree(psy_desc);
-		goto out;
+	if (!psy_desc->name) {
+		error = -ENOMEM;
+		goto err_free_mem;
 	}
 
 	psy_desc->type = POWER_SUPPLY_TYPE_BATTERY;
@@ -455,17 +486,20 @@ static bool hidinput_setup_battery(struct hid_device *dev, unsigned report_type,
 
 	dev->battery = power_supply_register(&dev->dev, psy_desc, &psy_cfg);
 	if (IS_ERR(dev->battery)) {
-		hid_warn(dev, "can't register power supply: %ld\n",
-				PTR_ERR(dev->battery));
-		kfree(psy_desc->name);
-		kfree(psy_desc);
-		dev->battery = NULL;
-	} else {
-		power_supply_powers(dev->battery, &dev->dev);
+		error = PTR_ERR(dev->battery);
+		hid_warn(dev, "can't register power supply: %d\n", error);
+		goto err_free_name;
 	}
 
-out:
-	return true;
+	power_supply_powers(dev->battery, &dev->dev);
+	return 0;
+
+err_free_name:
+	kfree(psy_desc->name);
+err_free_mem:
+	kfree(psy_desc);
+	dev->battery = NULL;
+	return error;
 }
 
 static void hidinput_cleanup_battery(struct hid_device *dev)
@@ -481,16 +515,33 @@ static void hidinput_cleanup_battery(struct hid_device *dev)
 	kfree(psy_desc);
 	dev->battery = NULL;
 }
+
+static void hidinput_update_battery(struct hid_device *dev, int value)
+{
+	if (!dev->battery)
+		return;
+
+	if (value == 0 || value < dev->battery_min || value > dev->battery_max)
+		return;
+
+	dev->battery_capacity = hidinput_scale_battery_capacity(dev, value);
+	dev->battery_reported = true;
+	power_supply_changed(dev->battery);
+}
 #else  /* !CONFIG_HID_BATTERY_STRENGTH */
-static bool hidinput_setup_battery(struct hid_device *dev, unsigned report_type,
-				   struct hid_field *field)
+static int hidinput_setup_battery(struct hid_device *dev, unsigned report_type,
+				  struct hid_field *field)
 {
-	return false;
+	return 0;
 }
 
 static void hidinput_cleanup_battery(struct hid_device *dev)
 {
 }
+
+static void hidinput_update_battery(struct hid_device *dev, int value)
+{
+}
 #endif	/* CONFIG_HID_BATTERY_STRENGTH */
 
 static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_field *field,
@@ -710,6 +761,11 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 			}
 			break;
 
+		case 0x3b: /* Battery Strength */
+			hidinput_setup_battery(device, HID_INPUT_REPORT, field);
+			usage->type = EV_PWR;
+			goto ignore;
+
 		case 0x3c: /* Invert */
 			map_key_clear(BTN_TOOL_RUBBER);
 			break;
@@ -944,11 +1000,13 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 		break;
 
 	case HID_UP_GENDEVCTRLS:
-		if (hidinput_setup_battery(device, HID_INPUT_REPORT, field))
+		switch (usage->hid) {
+		case HID_DC_BATTERYSTRENGTH:
+			hidinput_setup_battery(device, HID_INPUT_REPORT, field);
+			usage->type = EV_PWR;
 			goto ignore;
-		else
-			goto unknown;
-		break;
+		}
+		goto unknown;
 
 	case HID_UP_HPVENDOR:	/* Reported on a Dutch layout HP5308 */
 		set_bit(EV_REP, input->evbit);
@@ -1031,7 +1089,6 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 	if (usage->code > max)
 		goto ignore;
 
-
 	if (usage->type == EV_ABS) {
 
 		int a = field->logical_minimum;
@@ -1090,14 +1147,19 @@ void hidinput_hid_event(struct hid_device *hid, struct hid_field *field, struct
 	struct input_dev *input;
 	unsigned *quirks = &hid->quirks;
 
-	if (!field->hidinput)
+	if (!usage->type)
 		return;
 
-	input = field->hidinput->input;
+	if (usage->type == EV_PWR) {
+		hidinput_update_battery(hid, value);
+		return;
+	}
 
-	if (!usage->type)
+	if (!field->hidinput)
 		return;
 
+	input = field->hidinput->input;
+
 	if (usage->hat_min < usage->hat_max || usage->hat_dir) {
 		int hat_dir = usage->hat_dir;
 		if (!hat_dir)
@@ -1373,6 +1435,7 @@ static void report_features(struct hid_device *hid)
 	struct hid_driver *drv = hid->driver;
 	struct hid_report_enum *rep_enum;
 	struct hid_report *rep;
+	struct hid_usage *usage;
 	int i, j;
 
 	rep_enum = &hid->report_enum[HID_FEATURE_REPORT];
@@ -1383,12 +1446,15 @@ static void report_features(struct hid_device *hid)
 				continue;
 
 			for (j = 0; j < rep->field[i]->maxusage; j++) {
+				usage = &rep->field[i]->usage[j];
+
 				/* Verify if Battery Strength feature is available */
-				hidinput_setup_battery(hid, HID_FEATURE_REPORT, rep->field[i]);
+				if (usage->hid == HID_DC_BATTERYSTRENGTH)
+					hidinput_setup_battery(hid, HID_FEATURE_REPORT,
+							       rep->field[i]);
 
 				if (drv->feature_mapping)
-					drv->feature_mapping(hid, rep->field[i],
-							     rep->field[i]->usage + j);
+					drv->feature_mapping(hid, rep->field[i], usage);
 			}
 		}
 }

commit 6e7edabfc6a8ac5dce8c55363a7bb1576fc9348f
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Thu May 11 19:11:11 2017 +0200

    HID: Microsoft Win8 Wireless Radio Controls cleanup
    
    Use a better URL for the HUTRR40 Radio HID Usages documentation and use the
    HID_GD_WIRELESS_RADIO_CTLS define rather then hardcoding a check for
    0x0001000c.
    
    Fixes: 61df56bef9 ("HID: Add mapping for Microsoft Win8 Wireless Radio Controls extensions")
    Suggested-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 412040b11268..ccdff1ee1f0c 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -658,7 +658,7 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 
 		case HID_GD_RFKILL_BTN:
 			/* MS wireless radio ctl extension, also check CA */
-			if (field->application == 0x0001000c) {
+			if (field->application == HID_GD_WIRELESS_RADIO_CTLS) {
 				map_key_clear(KEY_RFKILL);
 				/* We need to simulate the btn release */
 				field->flags |= HID_MAIN_ITEM_RELATIVE;

commit 61df56bef97e1708bfbc006b307b00834ad61fe8
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Wed May 10 17:12:52 2017 +0200

    HID: Add mapping for Microsoft Win8 Wireless Radio Controls extensions
    
    Microsoft has defined some extra HUT codes for the Generic Desktop Page
    for Wireless Radio controls, see:
    
    https://docs.microsoft.com/en-us/windows-hardware/drivers/hid/airplane-mode-radio-management
    https://web.archive.org/web/20170509144631/https://docs.microsoft.com/en-us/windows-hardware/drivers/hid/airplane-mode-radio-management
    
    I've 3 2-in-1 keyboard docks: Dell Venue Pro 11 keyboard dock,
    HP pavilion x2 keyboard dock and a PEAQ C1010 keyboard dock which have
    a wireless radio toggle hotkey, which uses the 0x000100c6 HUT code
    defined in these extensions.
    
    This commit adds a mapping for this key, this makes the rfkill toggle
    hotkey work on the Dell Venue Pro 11 and HP Pavilion X2 keyboards,
    the PEAQ C1010 keyboard does generate events for the 0x000100c6 HUT
    code when pressed, but the reported value is always 0.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Reviewed-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index a1ebdd7d4d4d..412040b11268 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -656,6 +656,15 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 		case HID_GD_START:	map_key_clear(BTN_START);	break;
 		case HID_GD_SELECT:	map_key_clear(BTN_SELECT);	break;
 
+		case HID_GD_RFKILL_BTN:
+			/* MS wireless radio ctl extension, also check CA */
+			if (field->application == 0x0001000c) {
+				map_key_clear(KEY_RFKILL);
+				/* We need to simulate the btn release */
+				field->flags |= HID_MAIN_ITEM_RELATIVE;
+				break;
+			}
+
 		default: goto unknown;
 		}
 

commit c3883fe06488a483658ba5d849b70e49bee15e7c
Author: Tomasz Kramkowski <tk@the-tk.com>
Date:   Tue Mar 14 13:29:13 2017 +0000

    HID: clamp input to logical range if no null state
    
    This patch fixes an issue in drivers/hid/hid-input.c where values
    outside of the logical range are not clamped when "null state" bit of
    the input control is not set.
    
    This was discussed on the lists [1] and this change stems from the fact
    due to the ambiguity of the HID specification it might be appropriate to
    follow Microsoft's own interpretation of the specification. As noted in
    Microsoft's documentation [2] in the section titled "Required HID usages
    for digitizers" it is noted that values reported outside the logical
    range "will be considered as invalid data and the value will be changed
    to the nearest boundary value (logical min/max)."
    
    This patch fixes an issue where the (1292:4745) Innomedia INNEX
    GENESIS/ATARI reports out of range values for its X and Y axis of the
    DPad which, due to the null state bit being unset, are forwarded to
    userspace as is. Now these values will get clamped to the logical range
    before being forwarded to userspace. This device was also used to test
    this patch.
    
    This patch expands on commit 3f3752705dbd ("HID: reject input outside
    logical range only if null state is set").
    
    [1]: http://lkml.kernel.org/r/20170307131036.GA853@gaia.local
    [2]: https://msdn.microsoft.com/en-us/library/windows/hardware/dn672278(v=vs.85).asp
    
    Signed-off-by: Tomasz Kramkowski <tk@the-tk.com>
    Acked-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index cf8256aac2bd..a1ebdd7d4d4d 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -1150,19 +1150,26 @@ void hidinput_hid_event(struct hid_device *hid, struct hid_field *field, struct
 
 	/*
 	 * Ignore out-of-range values as per HID specification,
-	 * section 5.10 and 6.2.25.
+	 * section 5.10 and 6.2.25, when NULL state bit is present.
+	 * When it's not, clamp the value to match Microsoft's input
+	 * driver as mentioned in "Required HID usages for digitizers":
+	 * https://msdn.microsoft.com/en-us/library/windows/hardware/dn672278(v=vs.85).asp
 	 *
 	 * The logical_minimum < logical_maximum check is done so that we
 	 * don't unintentionally discard values sent by devices which
 	 * don't specify logical min and max.
 	 */
 	if ((field->flags & HID_MAIN_ITEM_VARIABLE) &&
-	    (field->flags & HID_MAIN_ITEM_NULL_STATE) &&
-	    (field->logical_minimum < field->logical_maximum) &&
-	    (value < field->logical_minimum ||
-	     value > field->logical_maximum)) {
-		dbg_hid("Ignoring out-of-range value %x\n", value);
-		return;
+	    (field->logical_minimum < field->logical_maximum)) {
+		if (field->flags & HID_MAIN_ITEM_NULL_STATE &&
+		    (value < field->logical_minimum ||
+		     value > field->logical_maximum)) {
+			dbg_hid("Ignoring out-of-range value %x\n", value);
+			return;
+		}
+		value = clamp(value,
+			      field->logical_minimum,
+			      field->logical_maximum);
 	}
 
 	/*

commit 3f3752705dbd50b66b66ad7b4d54fe33d2f746ed
Author: Valtteri HeikkilÃ¤ <rnd@nic.fi>
Date:   Tue Feb 14 23:14:32 2017 +0000

    HID: reject input outside logical range only if null state is set
    
    This patch fixes an issue in drivers/hid/hid-input.c where USB HID
    control null state flag is not checked upon rejecting inputs outside
    logical minimum-maximum range. The check should be made according to USB
    HID specification 1.11, section 6.2.2.5, p.31. The fix will resolve
    issues with some game controllers, such as:
    https://bugzilla.kernel.org/show_bug.cgi?id=68621
    
    [tk@the-tk.com: shortened and fixed spelling in commit message]
    Signed-off-by: Valtteri HeikkilÃ¤ <rnd@nic.fi>
    Signed-off-by: Tomasz Kramkowski <tk@the-tk.com>
    Acked-By: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index d05f903c7614..cf8256aac2bd 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -1157,6 +1157,7 @@ void hidinput_hid_event(struct hid_device *hid, struct hid_field *field, struct
 	 * don't specify logical min and max.
 	 */
 	if ((field->flags & HID_MAIN_ITEM_VARIABLE) &&
+	    (field->flags & HID_MAIN_ITEM_NULL_STATE) &&
 	    (field->logical_minimum < field->logical_maximum) &&
 	    (value < field->logical_minimum ||
 	     value > field->logical_maximum)) {

commit 96e132ebc0a162c643e0e6e6f1f85c3be3355715
Merge: 9ce12d8be12c 13c28b029708 8cd16166b000 608ad1848b41 f8690450f3d0 b897f6db3ae2 594312b88b0f de66a1a04c25 9c5dcd723171 c60fa555b11b c9cfb2aca265
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Wed Dec 14 10:12:26 2016 +0100

    Merge branches 'for-4.10/asus', 'for-4.10/cp2112', 'for-4.10/i2c-hid-nopower', 'for-4.10/intel-ish', 'for-4.10/mayflash', 'for-4.10/microsoft-surface-3', 'for-4.10/multitouch', 'for-4.10/sony', 'for-4.10/udraw-ps3', 'for-4.10/upstream' and 'for-4.10/wacom/generic' into for-linus

commit 72d19459d7919f966594576bb042d15a451f27ea
Author: Benjamin Tissoires <benjamin.tissoires@redhat.com>
Date:   Fri Nov 25 14:27:21 2016 +0100

    HID: input: rework HID_QUIRK_MULTI_INPUT
    
    The purpose of HID_QUIRK_MULTI_INPUT is to have an input device per
    report id. This is useful when the HID device presents several HID
    collections of different device types.
    
    The current implementation of hid-input creates one input node per id per
    type (input or output). This is problematic for the LEDs of a keyboard as
    they are often set through an output report. The current code creates
    one input node with all the keyboard keys, and one other with only the
    LEDs.
    
    To solve this, we use a two-passes way:
    - first, we initialize all input nodes and associate one per report id
    - then, we register all the input nodes
    
    Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index fb9ace1cef8b..55db58459531 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -1468,6 +1468,31 @@ static void hidinput_cleanup_hidinput(struct hid_device *hid,
 	kfree(hidinput);
 }
 
+static struct hid_input *hidinput_match(struct hid_report *report)
+{
+	struct hid_device *hid = report->device;
+	struct hid_input *hidinput;
+
+	list_for_each_entry(hidinput, &hid->inputs, list) {
+		if (hidinput->report &&
+		    hidinput->report->id == report->id)
+			return hidinput;
+	}
+
+	return NULL;
+}
+
+static inline void hidinput_configure_usages(struct hid_input *hidinput,
+					     struct hid_report *report)
+{
+	int i, j;
+
+	for (i = 0; i < report->maxfield; i++)
+		for (j = 0; j < report->field[i]->maxusage; j++)
+			hidinput_configure_usage(hidinput, report->field[i],
+						 report->field[i]->usage + j);
+}
+
 /*
  * Register the input device; print a message.
  * Configure the input layer interface
@@ -1478,8 +1503,8 @@ int hidinput_connect(struct hid_device *hid, unsigned int force)
 {
 	struct hid_driver *drv = hid->driver;
 	struct hid_report *report;
-	struct hid_input *hidinput = NULL;
-	int i, j, k;
+	struct hid_input *next, *hidinput = NULL;
+	int i, k;
 
 	INIT_LIST_HEAD(&hid->inputs);
 	INIT_WORK(&hid->led_work, hidinput_led_worker);
@@ -1509,43 +1534,40 @@ int hidinput_connect(struct hid_device *hid, unsigned int force)
 			if (!report->maxfield)
 				continue;
 
+			/*
+			 * Find the previous hidinput report attached
+			 * to this report id.
+			 */
+			if (hid->quirks & HID_QUIRK_MULTI_INPUT)
+				hidinput = hidinput_match(report);
+
 			if (!hidinput) {
 				hidinput = hidinput_allocate(hid);
 				if (!hidinput)
 					goto out_unwind;
 			}
 
-			for (i = 0; i < report->maxfield; i++)
-				for (j = 0; j < report->field[i]->maxusage; j++)
-					hidinput_configure_usage(hidinput, report->field[i],
-								 report->field[i]->usage + j);
-
-			if ((hid->quirks & HID_QUIRK_NO_EMPTY_INPUT) &&
-			    !hidinput_has_been_populated(hidinput))
-				continue;
+			hidinput_configure_usages(hidinput, report);
 
-			if (hid->quirks & HID_QUIRK_MULTI_INPUT) {
-				/* This will leave hidinput NULL, so that it
-				 * allocates another one if we have more inputs on
-				 * the same interface. Some devices (e.g. Happ's
-				 * UGCI) cram a lot of unrelated inputs into the
-				 * same interface. */
+			if (hid->quirks & HID_QUIRK_MULTI_INPUT)
 				hidinput->report = report;
-				if (drv->input_configured &&
-				    drv->input_configured(hid, hidinput))
-					goto out_cleanup;
-				if (input_register_device(hidinput->input))
-					goto out_cleanup;
-				hidinput = NULL;
-			}
 		}
 	}
 
-	if (hidinput && (hid->quirks & HID_QUIRK_NO_EMPTY_INPUT) &&
-	    !hidinput_has_been_populated(hidinput)) {
-		/* no need to register an input device not populated */
-		hidinput_cleanup_hidinput(hid, hidinput);
-		hidinput = NULL;
+	list_for_each_entry_safe(hidinput, next, &hid->inputs, list) {
+		if ((hid->quirks & HID_QUIRK_NO_EMPTY_INPUT) &&
+		    !hidinput_has_been_populated(hidinput)) {
+			/* no need to register an input device not populated */
+			hidinput_cleanup_hidinput(hid, hidinput);
+			continue;
+		}
+
+		if (drv->input_configured &&
+		    drv->input_configured(hid, hidinput))
+			goto out_unwind;
+		if (input_register_device(hidinput->input))
+			goto out_unwind;
+		hidinput->registered = true;
 	}
 
 	if (list_empty(&hid->inputs)) {
@@ -1553,20 +1575,8 @@ int hidinput_connect(struct hid_device *hid, unsigned int force)
 		goto out_unwind;
 	}
 
-	if (hidinput) {
-		if (drv->input_configured &&
-		    drv->input_configured(hid, hidinput))
-			goto out_cleanup;
-		if (input_register_device(hidinput->input))
-			goto out_cleanup;
-	}
-
 	return 0;
 
-out_cleanup:
-	list_del(&hidinput->list);
-	input_free_device(hidinput->input);
-	kfree(hidinput);
 out_unwind:
 	/* unwind the ones we already registered */
 	hidinput_disconnect(hid);
@@ -1583,7 +1593,10 @@ void hidinput_disconnect(struct hid_device *hid)
 
 	list_for_each_entry_safe(hidinput, next, &hid->inputs, list) {
 		list_del(&hidinput->list);
-		input_unregister_device(hidinput->input);
+		if (hidinput->registered)
+			input_unregister_device(hidinput->input);
+		else
+			input_free_device(hidinput->input);
 		kfree(hidinput);
 	}
 

commit c0bf57411b6b03dd72d4d20f362ba1ca72244834
Author: Jason Gerecke <killertofu@gmail.com>
Date:   Wed Oct 19 18:03:54 2016 -0700

    HID: input: Recognize ABS_WHEEL in hidinput_calc_abs_res
    
    The "Steering" usage (HID_UP_SIMULATION | 0xc8) is defined in HUT 1.12 as
    follows:
    
    "A steering wheel is a single degree-of-freedom device that rotates about
    an axis. The zero position is always the neutral or 'straight ahead'
    position, with positive values turning clockwise and negative values
    turning counterclockwise. If the Coordinate Values Wrap attribute is
    set, the steering wheel can be turned past 360 degrees."
    
    The hidinput_configure_usage function canonically maps this usage to the
    ABS_WHEEL axis, but hidinput_calc_abs_res does not recognize this axis
    as one for which it can calculate a resolution. This effectively prevents
    wheels from being assigned a proper resolution that userspace can use
    to determine the precise angle of input.
    
    This commit adds ABS_WHEEL as a rotational axis to hidinput_calc_abs_res.
    
    Signed-off-by: Jason Gerecke <jason.gerecke@wacom.com>
    Reviewed-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index fb9ace1cef8b..c4e935b5fe74 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -253,6 +253,7 @@ __s32 hidinput_calc_abs_res(const struct hid_field *field, __u16 code)
 	case ABS_RX:
 	case ABS_RY:
 	case ABS_RZ:
+	case ABS_WHEEL:
 	case ABS_TILT_X:
 	case ABS_TILT_Y:
 		if (field->unit == 0x14) {		/* If degrees */

commit 179023e6af0c608ffb505821223f5580853ef6b8
Merge: 04fd4cb0b098 9a54cf462d6f 52dc085a50c6 814cb72e25af 3202bb7fb021 f777a3a7bd44 c4425c8f26aa 6c3f70ac7c6b 1924e05e6014
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Fri Oct 7 09:59:48 2016 +0200

    Merge branches 'for-4.8/upstream-fixes', 'for-4.9/alps', 'for-4.9/hid-input', 'for-4.9/intel-ish', 'for-4.9/kye-uclogic-waltop-fixes', 'for-4.9/logitech', 'for-4.9/sony', 'for-4.9/upstream' and 'for-4.9/wacom' into for-linus

commit 1989dada7ce07848196991c9ebf25ff9c5f14d4e
Author: Benjamin Tissoires <benjamin.tissoires@redhat.com>
Date:   Tue Sep 13 11:52:37 2016 +0200

    HID: input: ignore System Control application usages if not System Controls
    
    Microsoft is reusing its report descriptor again and again, and part of it
    looks like this:
    
    0x05, 0x01,                    // Usage Page (Generic Desktop)        299
    0x09, 0x80,                    // Usage (System Control)              301
    0xa1, 0x01,                    // Collection (Application)            303
    0x85, 0x03,                    //  Report ID (3)                      305
    0x19, 0x00,                    //  Usage Minimum (0)                  307
    0x29, 0xff,                    //  Usage Maximum (255)                309
    0x15, 0x00,                    //  Logical Minimum (0)                311
    0x26, 0xff, 0x00,              //  Logical Maximum (255)              313
    0x81, 0x00,                    //  Input (Data,Arr,Abs)               316
    0xc0,                          // End Collection                      318
    
    While there is nothing wrong in term of processing, we do however blindly
    map the full usage range (it's an array) from 0x00 to 0xff, which creates
    some interesting axis, like ABS_X|Y, and a bunch of ABS_MISC + n.
    
    While libinput and other stacks don't care that much (we can detect them),
    joydev is very happy and attaches itself to the mouse or keyboard.
    
    The problem is that joydev now handles the device as a joystick, but given
    that we have a HID array, it sets all the ABS_* values to 0. And in its
    world, 0 means -32767 (minimum value), which sends spurious events to games
    (think Steam).
    
    It looks like hid-microsoft tries to tackle the very same problem with its
    .report_fixup callback. But fixing the report descriptor is an endless task
    and is quite obfuscated.
    
    So take the hammer, and decide that if the application is meant to be
    System Control, any other usage not in the System Control range should
    be ignored.
    
    Link: https://bugzilla.redhat.com/show_bug.cgi?id=1325354
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=28912
    Link: https://github.com/ValveSoftware/steam-for-linux/issues/3384
    Link: https://bugzilla.redhat.com/show_bug.cgi?id=1325354
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=37982
    
    Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index bcfaf32d9e5e..058919d5b2bb 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -604,6 +604,15 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 			break;
 		}
 
+		/*
+		 * Some lazy vendors declare 255 usages for System Control,
+		 * leading to the creation of ABS_X|Y axis and too many others.
+		 * It wouldn't be a problem if joydev doesn't consider the
+		 * device as a joystick then.
+		 */
+		if (field->application == HID_GD_SYSTEM_CONTROL)
+			goto ignore;
+
 		if ((usage->hid & 0xf0) == 0x90) {	/* D-pad */
 			switch (usage->hid) {
 			case HID_GD_UP:	   usage->hat_dir = 1; break;

commit 08fc94733211f94755dd15028fb0a0129310fb5d
Author: AceLan Kao <acelan.kao@canonical.com>
Date:   Thu Aug 4 10:26:20 2016 +0800

    HID: input: add mic mute key on HP slim keyboard
    
    Add MIC mute key which is found on HP Business Slim Keyboard
    
    T:  Bus=02 Lev=01 Prnt=01 Port=00 Cnt=01 Dev#= 23 Spd=1.5 MxCh= 0
    D:  Ver= 2.00 Cls=00(>ifc ) Sub=00 Prot=00 MxPS= 8 #Cfgs=  1
    P:  Vendor=03f0 ProdID=2f4a Rev=00.10
    S:  Manufacturer=Chicony
    S:  Product=HP Business Slim Keyboard
    C:  #Ifs= 2 Cfg#= 1 Atr=a0 MxPwr=100mA
    I:  If#= 0 Alt= 0 #EPs= 1 Cls=03(HID  ) Sub=01 Prot=01 Driver=usbhid
    I:  If#= 1 Alt= 0 #EPs= 1 Cls=03(HID  ) Sub=00 Prot=00 Driver=usbhid
    
    Signed-off-by: AceLan Kao <acelan.kao@canonical.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index bcfaf32d9e5e..d51c43b0be34 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -953,6 +953,7 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 	case HID_UP_HPVENDOR2:
 		set_bit(EV_REP, input->evbit);
 		switch (usage->hid & HID_USAGE) {
+		case 0x001: map_key_clear(KEY_MICMUTE);		break;
 		case 0x003: map_key_clear(KEY_BRIGHTNESSDOWN);	break;
 		case 0x004: map_key_clear(KEY_BRIGHTNESSUP);	break;
 		default:    goto ignore;

commit 83f1bfd6f57c422da70d1e296df1becc35c868be
Merge: 76833559eb9d 64bebefcf319 2cf83833fc9c 5d9374cf5f66 6cf2e31bea14 5f008c98598b 73e7d63efb4d b71b5578a84d 7775fb929d95 0bbfe28ad0fd
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Thu Jan 14 16:11:06 2016 +0100

    Merge branches 'for-4.4/upstream-fixes', 'for-4.5/async-suspend', 'for-4.5/container-of-cleanups', 'for-4.5/core', 'for-4.5/i2c-hid', 'for-4.5/logitech', 'for-4.5/multitouch', 'for-4.5/sony', 'for-4.5/upstream' and 'for-4.5/wacom' into for-linus

commit 5d9374cf5f66ebe38007bccf0b4adc14f0013663
Author: Alexander E. Patrakov <patrakov@gmail.com>
Date:   Mon Dec 14 17:42:26 2015 +0500

    HID: input: ignore the battery in OKLICK Laser BTmouse
    
    This mouse, when asked about the battery, ceases to report movements and
    clicks. So just don't ask.
    
    Signed-off-by: Alexander E. Patrakov <patrakov@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 2ba6bf69b7d0..0869faef1308 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -303,6 +303,7 @@ static enum power_supply_property hidinput_battery_props[] = {
 
 #define HID_BATTERY_QUIRK_PERCENT	(1 << 0) /* always reports percent */
 #define HID_BATTERY_QUIRK_FEATURE	(1 << 1) /* ask for feature report */
+#define HID_BATTERY_QUIRK_IGNORE	(1 << 2) /* completely ignore the battery */
 
 static const struct hid_device_id hid_battery_quirks[] = {
 	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE,
@@ -320,6 +321,9 @@ static const struct hid_device_id hid_battery_quirks[] = {
 	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE,
 		USB_DEVICE_ID_APPLE_ALU_WIRELESS_ANSI),
 	  HID_BATTERY_QUIRK_PERCENT | HID_BATTERY_QUIRK_FEATURE },
+	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_ELECOM,
+		USB_DEVICE_ID_ELECOM_BM084),
+	  HID_BATTERY_QUIRK_IGNORE },
 	{}
 };
 
@@ -408,6 +412,14 @@ static bool hidinput_setup_battery(struct hid_device *dev, unsigned report_type,
 	if (dev->battery != NULL)
 		goto out;	/* already initialized? */
 
+	quirks = find_battery_quirk(dev);
+
+	hid_dbg(dev, "device %x:%x:%x %d quirks %d\n",
+		dev->bus, dev->vendor, dev->product, dev->version, quirks);
+
+	if (quirks & HID_BATTERY_QUIRK_IGNORE)
+		goto out;
+
 	psy_desc = kzalloc(sizeof(*psy_desc), GFP_KERNEL);
 	if (psy_desc == NULL)
 		goto out;
@@ -424,11 +436,6 @@ static bool hidinput_setup_battery(struct hid_device *dev, unsigned report_type,
 	psy_desc->use_for_apm = 0;
 	psy_desc->get_property = hidinput_get_battery_property;
 
-	quirks = find_battery_quirk(dev);
-
-	hid_dbg(dev, "device %x:%x:%x %d quirks %d\n",
-		dev->bus, dev->vendor, dev->product, dev->version, quirks);
-
 	min = field->logical_minimum;
 	max = field->logical_maximum;
 

commit b466c1dd73d5303a313fb0c962e4eb5879bc1336
Author: Simon Wood <simon@mungewell.org>
Date:   Thu Nov 19 16:42:14 2015 -0700

    HID: Add vendor specific usage pages for Logitech G920
    
    The Logitech G920 uses a couple of vendor specific usage pages,
    which results in incorrect number of axis/buttons being detected.
    
    This patch adds these pages to the 'ignore' list.
    
    Reported-by: Elias Vanderstuyft <elias.vds@gmail.com>
    Signed-off-by: Simon Wood <simon@mungewell.org>
    Reviewed-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 2ba6bf69b7d0..f4eeb6bcb9ac 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -960,6 +960,10 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 		goto ignore;
 
 	case HID_UP_LOGIVENDOR:
+		/* intentional fallback */
+	case HID_UP_LOGIVENDOR2:
+		/* intentional fallback */
+	case HID_UP_LOGIVENDOR3:
 		goto ignore;
 
 	case HID_UP_PID:

commit 9154301a47b33bdc273d8254c407792524367558
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Tue Sep 29 15:52:59 2015 -0700

    HID: hid-input: allow input_configured callback return errors
    
    When configuring input device via input_configured callback we may
    encounter errors (for example input_mt_init_slots() may fail). Instead
    of continuing with half-initialized input device let's allow driver
    indicate failures.
    
    Signed-off-by: Jaikumar Ganesh <jaikumarg@android.com>
    Signed-off-by: Arve HjÃ¸nnevÃ¥g <arve@android.com>
    Reviewed-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Reviewed-by: David Herrmann <dh.herrmann@gmail.com>
    Acked-by: Nikolai Kondrashov <Nikolai.Kondrashov@redhat.com>
    Acked-by: Andrew Duggan <aduggan@synaptics.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 53aeaf6252c7..2ba6bf69b7d0 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -1510,8 +1510,9 @@ int hidinput_connect(struct hid_device *hid, unsigned int force)
 				 * UGCI) cram a lot of unrelated inputs into the
 				 * same interface. */
 				hidinput->report = report;
-				if (drv->input_configured)
-					drv->input_configured(hid, hidinput);
+				if (drv->input_configured &&
+				    drv->input_configured(hid, hidinput))
+					goto out_cleanup;
 				if (input_register_device(hidinput->input))
 					goto out_cleanup;
 				hidinput = NULL;
@@ -1532,8 +1533,9 @@ int hidinput_connect(struct hid_device *hid, unsigned int force)
 	}
 
 	if (hidinput) {
-		if (drv->input_configured)
-			drv->input_configured(hid, hidinput);
+		if (drv->input_configured &&
+		    drv->input_configured(hid, hidinput))
+			goto out_cleanup;
 		if (input_register_device(hidinput->input))
 			goto out_cleanup;
 	}

commit 3e097d1271ecdff2f251a54ddfc5eaa1f9821e96
Merge: 0be017120b80 c9b57724b38d
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Tue Sep 1 15:23:13 2015 +0200

    Merge branches 'for-4.2/upstream-fixes-devm-fixed' and 'for-4.3/upstream' into for-linus

commit 0621809e37936e7c2b3eac9165cf2aad7f9189eb
Author: Krzysztof Kozlowski <k.kozlowski@samsung.com>
Date:   Mon Aug 3 14:57:30 2015 +0900

    HID: hid-input: Fix accessing freed memory during device disconnect
    
    During unbinding the driver was dereferencing a pointer to memory
    already freed by power_supply_unregister().
    
    Driver was freeing its internal description of battery through pointers
    stored in power_supply structure. However, because the core owns the
    power supply instance, after calling power_supply_unregister() this
    memory is freed and the driver cannot access these members.
    
    Fix this by storing the pointer to internal description of battery in a
    local variable before calling power_supply_unregister(), so the pointer
    remains valid.
    
    Signed-off-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Reported-by: H.J. Lu <hjl.tools@gmail.com>
    Fixes: 297d716f6260 ("power_supply: Change ownership from driver to core")
    Cc: <stable@vger.kernel.org>
    Reviewed-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.com>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 3511bbaba505..e3c63640df73 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -462,12 +462,15 @@ static bool hidinput_setup_battery(struct hid_device *dev, unsigned report_type,
 
 static void hidinput_cleanup_battery(struct hid_device *dev)
 {
+	const struct power_supply_desc *psy_desc;
+
 	if (!dev->battery)
 		return;
 
+	psy_desc = dev->battery->desc;
 	power_supply_unregister(dev->battery);
-	kfree(dev->battery->desc->name);
-	kfree(dev->battery->desc);
+	kfree(psy_desc->name);
+	kfree(psy_desc);
 	dev->battery = NULL;
 }
 #else  /* !CONFIG_HID_BATTERY_STRENGTH */

commit 3eb4351af42bd8b6de20daab07b204a85c35248f
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Thu Jul 9 14:33:21 2015 -0700

    HID: input: call input_sync() when automatically releasing a key
    
    We need to emit EV_SYN/SYN_REPORT between key press and release, otherwise
    userspace is allowed to "swallow" the event.
    
    [jkosina@suse.com: Dmitry says that he's observing this behavior with
     Plantronics headset]
    
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.com>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 3511bbaba505..14aebe483219 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -1163,8 +1163,11 @@ void hidinput_hid_event(struct hid_device *hid, struct hid_field *field, struct
 
 	input_event(input, usage->type, usage->code, value);
 
-	if ((field->flags & HID_MAIN_ITEM_RELATIVE) && (usage->type == EV_KEY))
+	if ((field->flags & HID_MAIN_ITEM_RELATIVE) &&
+	    usage->type == EV_KEY && value) {
+		input_sync(input);
 		input_event(input, usage->type, usage->code, 0);
+	}
 }
 
 void hidinput_report_event(struct hid_device *hid, struct hid_report *report)

commit 323ddaa84f003a0c1d49f3ce5d106bc3cef070d5
Author: James C Boyd <jcboyd.dev@gmail.com>
Date:   Wed May 27 17:09:08 2015 -0500

    HID: hid-input: Fix coding style issue
    
    This line is too long; split it up.
    
    Signed-off-by: James C Boyd <jcboyd.dev@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index abf4fc612618..3511bbaba505 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -1157,7 +1157,8 @@ void hidinput_hid_event(struct hid_device *hid, struct hid_field *field, struct
 		return;
 
 	/* report the usage code as scancode if the key status has changed */
-	if (usage->type == EV_KEY && (!test_bit(usage->code, input->key)) == value)
+	if (usage->type == EV_KEY &&
+	    (!test_bit(usage->code, input->key)) == value)
 		input_event(input, EV_MSC, MSC_SCAN, usage->hid);
 
 	input_event(input, usage->type, usage->code, value);

commit 2c54c86a674979e2bd9dc3663d329ee56368a218
Author: James C Boyd <jcboyd.dev@gmail.com>
Date:   Wed May 27 17:09:07 2015 -0500

    HID: hid-input: Simplify conditional expression
    
    There are too many bangs in this conditional; therefore
    remove them while still maintaining the same logic.
    
    Signed-off-by: James C Boyd <jcboyd.dev@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 714b75891ec0..abf4fc612618 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -1157,7 +1157,7 @@ void hidinput_hid_event(struct hid_device *hid, struct hid_field *field, struct
 		return;
 
 	/* report the usage code as scancode if the key status has changed */
-	if (usage->type == EV_KEY && (!!test_bit(usage->code, input->key)) != value)
+	if (usage->type == EV_KEY && (!test_bit(usage->code, input->key)) == value)
 		input_event(input, EV_MSC, MSC_SCAN, usage->hid);
 
 	input_event(input, usage->type, usage->code, value);

commit 09a5c34e8d6b05663ec4c3d22b1fbd9fec89aaf9
Author: James C Boyd <jcboyd.dev@gmail.com>
Date:   Wed May 27 17:09:06 2015 -0500

    HID: hid-input: Add parentheses to quell gcc warning
    
    GCC reports a -Wlogical-not-parentheses warning here; therefore
    add parentheses to shut it up and to express our intent more.
    
    Signed-off-by: James C Boyd <jcboyd.dev@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 008e89bf6f3c..714b75891ec0 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -1157,7 +1157,7 @@ void hidinput_hid_event(struct hid_device *hid, struct hid_field *field, struct
 		return;
 
 	/* report the usage code as scancode if the key status has changed */
-	if (usage->type == EV_KEY && !!test_bit(usage->code, input->key) != value)
+	if (usage->type == EV_KEY && (!!test_bit(usage->code, input->key)) != value)
 		input_event(input, EV_MSC, MSC_SCAN, usage->hid);
 
 	input_event(input, usage->type, usage->code, value);

commit 8de29a35dc840a05e451ad035bcb06e21ccf605f
Merge: 31f7dc796998 2e455c27bddb
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Apr 14 08:25:26 2015 -0800

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/hid
    
    Pull HID updates from Jiri Kosina:
    
     - quite a few firmware fixes for RMI driver by Andrew Duggan
    
     - huion and uclogic drivers have been substantially overlaping in
       functionality laterly.  This redundancy is fixed by hid-huion driver
       being merged into hid-uclogic; work done by Benjamin Tissoires and
       Nikolai Kondrashov
    
     - i2c-hid now supports ACPI GPIO interrupts; patch from Mika Westerberg
    
     - Some of the quirks, that got separated into individual drivers, have
       historically had EXPERT dependency.  As HID subsystem matured (as
       well as the individual drivers), this made less and less sense.  This
       dependency is now being removed by patch from Jean Delvare
    
     - Logitech lg4ff driver received a couple of improvements for mode
       switching, by Michal MalÃ½
    
     - multitouch driver now supports clickpads, patches by Benjamin
       Tissoires and Seth Forshee
    
     - hid-sensor framework received a substantial update; namely support
       for Custom and Generic pages is being added; work done by Srinivas
       Pandruvada
    
     - wacom driver received substantial update; it now supports
       i2c-conntected devices (Mika Westerberg), Bamboo PADs are now
       properly supported (Benjamin Tissoires), much improved battery
       reporting (Jason Gerecke) and pen proximity cleanups (Ping Cheng)
    
     - small assorted fixes and device ID additions
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/hid: (68 commits)
      HID: sensor: Update document for custom sensor
      HID: sensor: Custom and Generic sensor support
      HID: debug: fix error handling in hid_debug_events_read()
      Input - mt: Fix input_mt_get_slot_by_key
      HID: logitech-hidpp: fix error return code
      HID: wacom: Add support for Cintiq 13HD Touch
      HID: logitech-hidpp: add a module parameter to keep firmware gestures
      HID: usbhid: yet another mouse with ALWAYS_POLL
      HID: usbhid: more mice with ALWAYS_POLL
      HID: wacom: set stylus_in_proximity before checking touch_down
      HID: wacom: use wacom_wac_finger_count_touches to set touch_down
      HID: wacom: remove hardcoded WACOM_QUIRK_MULTI_INPUT
      HID: pidff: effect can't be NULL
      HID: add quirk for PIXART OEM mouse used by HP
      HID: add HP OEM mouse to quirk ALWAYS_POLL
      HID: wacom: ask for a in-prox report when it was missed
      HID: hid-sensor-hub: Fix sparse warning
      HID: hid-sensor-hub: fix attribute read for logical usage id
      HID: plantronics: fix Kconfig default
      HID: pidff: support more than one concurrent effect
      ...

commit fbea947c7d122f4704001fac2a96b617f767037a
Author: Krzysztof Kozlowski <k.kozlowski@samsung.com>
Date:   Mon Mar 23 16:34:51 2015 +0100

    HID: input: Fix NULL pointer dereference when power_supply_register fails
    
    Do not call power_supply_powers() if power_supply_register() failed
    earlier. This fixes possible NULL pointer dereference by
    power_supply_powers() in such case.
    
    Signed-off-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Acked-by: Jiri Kosina <jkosina@suse.cz>
    Signed-off-by: Sebastian Reichel <sre@kernel.org>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 5d5a8c42645f..32c2da49bd5b 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -452,10 +452,10 @@ static bool hidinput_setup_battery(struct hid_device *dev, unsigned report_type,
 		kfree(psy_desc->name);
 		kfree(psy_desc);
 		dev->battery = NULL;
+	} else {
+		power_supply_powers(dev->battery, &dev->dev);
 	}
 
-	power_supply_powers(dev->battery, &dev->dev);
-
 out:
 	return true;
 }

commit 297d716f6260cc9421d971b124ca196b957ee458
Author: Krzysztof Kozlowski <k.kozlowski@samsung.com>
Date:   Thu Mar 12 08:44:11 2015 +0100

    power_supply: Change ownership from driver to core
    
    Change the ownership of power_supply structure from each driver
    implementing the class to the power supply core.
    
    The patch changes power_supply_register() function thus all drivers
    implementing power supply class are adjusted.
    
    Each driver provides the implementation of power supply. However it
    should not be the owner of power supply class instance because it is
    exposed by core to other subsystems with power_supply_get_by_name().
    These other subsystems have no knowledge when the driver will unregister
    the power supply. This leads to several issues when driver is unbound -
    mostly because user of power supply accesses freed memory.
    
    Instead let the core own the instance of struct 'power_supply'.  Other
    users of this power supply will still access valid memory because it
    will be freed when device reference count reaches 0. Currently this
    means "it will leak" but power_supply_put() call in next patches will
    solve it.
    
    This solves invalid memory references in following race condition
    scenario:
    
    Thread 1: charger manager
    Thread 2: power supply driver, used by charger manager
    
    THREAD 1 (charger manager)         THREAD 2 (power supply driver)
    ==========================         ==============================
    psy = power_supply_get_by_name()
                                       Driver unbind, .remove
                                         power_supply_unregister()
                                         Device fully removed
    psy->get_property()
    
    The 'get_property' call is executed in invalid context because the driver was
    unbound and struct 'power_supply' memory was freed.
    
    This could be observed easily with charger manager driver (here compiled
    with max17040 fuel gauge):
    
    $ cat /sys/devices/virtual/power_supply/cm-battery/capacity &
    $ echo "1-0036" > /sys/bus/i2c/drivers/max17040/unbind
    [   55.725123] Unable to handle kernel NULL pointer dereference at virtual address 00000000
    [   55.732584] pgd = d98d4000
    [   55.734060] [00000000] *pgd=5afa2831, *pte=00000000, *ppte=00000000
    [   55.740318] Internal error: Oops: 80000007 [#1] PREEMPT SMP ARM
    [   55.746210] Modules linked in:
    [   55.749259] CPU: 1 PID: 2936 Comm: cat Tainted: G        W       3.19.0-rc1-next-20141226-00048-gf79f475f3c44-dirty #1496
    [   55.760190] Hardware name: SAMSUNG EXYNOS (Flattened Device Tree)
    [   55.766270] task: d9b76f00 ti: daf54000 task.ti: daf54000
    [   55.771647] PC is at 0x0
    [   55.774182] LR is at charger_get_property+0x2f4/0x36c
    [   55.779201] pc : [<00000000>]    lr : [<c034b0b4>]    psr: 60000013
    [   55.779201] sp : daf55e90  ip : 00000003  fp : 00000000
    [   55.790657] r10: 00000000  r9 : c06e2878  r8 : d9b26c68
    [   55.795865] r7 : dad81610  r6 : daec7410  r5 : daf55ebc  r4 : 00000000
    [   55.802367] r3 : 00000000  r2 : daf55ebc  r1 : 0000002a  r0 : d9b26c68
    [   55.808879] Flags: nZCv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment user
    [   55.815994] Control: 10c5387d  Table: 598d406a  DAC: 00000015
    [   55.821723] Process cat (pid: 2936, stack limit = 0xdaf54210)
    [   55.827451] Stack: (0xdaf55e90 to 0xdaf56000)
    [   55.831795] 5e80:                                     60000013 c01459c4 0000002a c06f8ef8
    [   55.839956] 5ea0: db651000 c06f8ef8 daebac00 c04cb668 daebac08 c0346864 00000000 c01459c4
    [   55.848115] 5ec0: d99eaa80 c06f8ef8 00000fff 00001000 db651000 c027f25c c027f240 d99eaa80
    [   55.856274] 5ee0: d9a06c00 c0146218 daf55f18 00001000 d99eaa80 db4c18c0 00000001 00000001
    [   55.864468] 5f00: daf55f80 c0144c78 c0144c54 c0107f90 00015000 d99eaab0 00000000 00000000
    [   55.872603] 5f20: 000051c7 00000000 db4c18c0 c04a9370 00015000 00001000 daf55f80 00001000
    [   55.880763] 5f40: daf54000 00015000 00000000 c00e53dc db4c18c0 c00e548c 0000000d 00008124
    [   55.888937] 5f60: 00000001 00000000 00000000 db4c18c0 db4c18c0 00001000 00015000 c00e5550
    [   55.897099] 5f80: 00000000 00000000 00001000 00001000 00015000 00000003 00000003 c000f364
    [   55.905239] 5fa0: 00000000 c000f1a0 00001000 00015000 00000003 00015000 00001000 0001333c
    [   55.913399] 5fc0: 00001000 00015000 00000003 00000003 00000002 00000000 00000000 00000000
    [   55.921560] 5fe0: 7fffe000 be999850 0000a225 b6f3c19c 60000010 00000003 00000000 00000000
    [   55.929744] [<c034b0b4>] (charger_get_property) from [<c0346864>] (power_supply_show_property+0x48/0x20c)
    [   55.939286] [<c0346864>] (power_supply_show_property) from [<c027f25c>] (dev_attr_show+0x1c/0x48)
    [   55.948130] [<c027f25c>] (dev_attr_show) from [<c0146218>] (sysfs_kf_seq_show+0x84/0x104)
    [   55.956298] [<c0146218>] (sysfs_kf_seq_show) from [<c0144c78>] (kernfs_seq_show+0x24/0x28)
    [   55.964536] [<c0144c78>] (kernfs_seq_show) from [<c0107f90>] (seq_read+0x1b0/0x484)
    [   55.972172] [<c0107f90>] (seq_read) from [<c00e53dc>] (__vfs_read+0x18/0x4c)
    [   55.979188] [<c00e53dc>] (__vfs_read) from [<c00e548c>] (vfs_read+0x7c/0x100)
    [   55.986304] [<c00e548c>] (vfs_read) from [<c00e5550>] (SyS_read+0x40/0x8c)
    [   55.993164] [<c00e5550>] (SyS_read) from [<c000f1a0>] (ret_fast_syscall+0x0/0x48)
    [   56.000626] Code: bad PC value
    [   56.011652] ---[ end trace 7b64343fbdae8ef1 ]---
    
    Signed-off-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Reviewed-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    
    [for the nvec part]
    Reviewed-by: Marc Dietrich <marvin24@gmx.de>
    
    [for compal-laptop.c]
    Acked-by: Darren Hart <dvhart@linux.intel.com>
    
    [for the mfd part]
    Acked-by: Lee Jones <lee.jones@linaro.org>
    
    [for the hid part]
    Acked-by: Jiri Kosina <jkosina@suse.cz>
    
    [for the acpi part]
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    
    Signed-off-by: Sebastian Reichel <sre@kernel.org>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 6182265a6571..5d5a8c42645f 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -339,7 +339,7 @@ static int hidinput_get_battery_property(struct power_supply *psy,
 					 enum power_supply_property prop,
 					 union power_supply_propval *val)
 {
-	struct hid_device *dev = container_of(psy, struct hid_device, battery);
+	struct hid_device *dev = power_supply_get_drvdata(psy);
 	int ret = 0;
 	__u8 *buf;
 
@@ -397,26 +397,32 @@ static int hidinput_get_battery_property(struct power_supply *psy,
 
 static bool hidinput_setup_battery(struct hid_device *dev, unsigned report_type, struct hid_field *field)
 {
-	struct power_supply *battery = &dev->battery;
-	int ret;
+	struct power_supply_desc *psy_desc = NULL;
+	struct power_supply_config psy_cfg = { .drv_data = dev, };
 	unsigned quirks;
 	s32 min, max;
 
 	if (field->usage->hid != HID_DC_BATTERYSTRENGTH)
 		return false;	/* no match */
 
-	if (battery->name != NULL)
+	if (dev->battery != NULL)
 		goto out;	/* already initialized? */
 
-	battery->name = kasprintf(GFP_KERNEL, "hid-%s-battery", dev->uniq);
-	if (battery->name == NULL)
+	psy_desc = kzalloc(sizeof(*psy_desc), GFP_KERNEL);
+	if (psy_desc == NULL)
 		goto out;
 
-	battery->type = POWER_SUPPLY_TYPE_BATTERY;
-	battery->properties = hidinput_battery_props;
-	battery->num_properties = ARRAY_SIZE(hidinput_battery_props);
-	battery->use_for_apm = 0;
-	battery->get_property = hidinput_get_battery_property;
+	psy_desc->name = kasprintf(GFP_KERNEL, "hid-%s-battery", dev->uniq);
+	if (psy_desc->name == NULL) {
+		kfree(psy_desc);
+		goto out;
+	}
+
+	psy_desc->type = POWER_SUPPLY_TYPE_BATTERY;
+	psy_desc->properties = hidinput_battery_props;
+	psy_desc->num_properties = ARRAY_SIZE(hidinput_battery_props);
+	psy_desc->use_for_apm = 0;
+	psy_desc->get_property = hidinput_get_battery_property;
 
 	quirks = find_battery_quirk(dev);
 
@@ -439,14 +445,16 @@ static bool hidinput_setup_battery(struct hid_device *dev, unsigned report_type,
 	dev->battery_report_type = report_type;
 	dev->battery_report_id = field->report->id;
 
-	ret = power_supply_register(&dev->dev, battery, NULL);
-	if (ret != 0) {
-		hid_warn(dev, "can't register power supply: %d\n", ret);
-		kfree(battery->name);
-		battery->name = NULL;
+	dev->battery = power_supply_register(&dev->dev, psy_desc, &psy_cfg);
+	if (IS_ERR(dev->battery)) {
+		hid_warn(dev, "can't register power supply: %ld\n",
+				PTR_ERR(dev->battery));
+		kfree(psy_desc->name);
+		kfree(psy_desc);
+		dev->battery = NULL;
 	}
 
-	power_supply_powers(battery, &dev->dev);
+	power_supply_powers(dev->battery, &dev->dev);
 
 out:
 	return true;
@@ -454,12 +462,13 @@ static bool hidinput_setup_battery(struct hid_device *dev, unsigned report_type,
 
 static void hidinput_cleanup_battery(struct hid_device *dev)
 {
-	if (!dev->battery.name)
+	if (!dev->battery)
 		return;
 
-	power_supply_unregister(&dev->battery);
-	kfree(dev->battery.name);
-	dev->battery.name = NULL;
+	power_supply_unregister(dev->battery);
+	kfree(dev->battery->desc->name);
+	kfree(dev->battery->desc);
+	dev->battery = NULL;
 }
 #else  /* !CONFIG_HID_BATTERY_STRENGTH */
 static bool hidinput_setup_battery(struct hid_device *dev, unsigned report_type,

commit 2dc9215d7c94f7f9f34ccf8b1710ad73d82f6216
Author: Krzysztof Kozlowski <k.kozlowski@samsung.com>
Date:   Thu Mar 12 08:44:02 2015 +0100

    power_supply: Move run-time configuration to separate structure
    
    Add new structure 'power_supply_config' for holding run-time
    initialization data like of_node, supplies and private driver data.
    
    The power_supply_register() function is changed so all power supply
    drivers need updating.
    
    When registering the power supply this new 'power_supply_config' should be
    used instead of directly initializing 'struct power_supply'. This allows
    changing the ownership of power_supply structure from driver to the
    power supply core in next patches.
    
    When a driver does not use of_node or supplies then it should use NULL
    as config. If driver uses of_node or supplies then it should allocate
    config on stack and initialize it with proper values.
    
    Signed-off-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Reviewed-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    
    [for the nvec part]
    Reviewed-by: Marc Dietrich <marvin24@gmx.de>
    
    [for drivers/platform/x86/compal-laptop.c]
    Reviewed-by: Darren Hart <dvhart@linux.intel.com>
    
    [for drivers/hid/*]
    Reviewed-by: Jiri Kosina <jkosina@suse.cz>
    
    Signed-off-by: Sebastian Reichel <sre@kernel.org>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 052869d0ab78..6182265a6571 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -439,7 +439,7 @@ static bool hidinput_setup_battery(struct hid_device *dev, unsigned report_type,
 	dev->battery_report_type = report_type;
 	dev->battery_report_id = field->report->id;
 
-	ret = power_supply_register(&dev->dev, battery);
+	ret = power_supply_register(&dev->dev, battery, NULL);
 	if (ret != 0) {
 		hid_warn(dev, "can't register power supply: %d\n", ret);
 		kfree(battery->name);

commit f3dddf2432e3123ef34b470129295641f7513d26
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Wed Mar 4 14:10:26 2015 -0800

    HID: map telephony usage page
    
    Currently HID code maps usages from telephony page into BTN_0, BTN_1, etc
    keys which get interpreted by mousedev and userspace as left/right/middle
    button clicks, which is not really helpful.
    
    This change adds mappings for usages that have corresponding input event
    definitions, and leaves the rest unmapped. This can be changed when
    there are userspace consumers for more telephony usages.
    
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 052869d0ab78..19603efc8fa2 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -711,6 +711,29 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 		}
 		break;
 
+	case HID_UP_TELEPHONY:
+		switch (usage->hid & HID_USAGE) {
+		case 0x2f: map_key_clear(KEY_MICMUTE);		break;
+		case 0xb0: map_key_clear(KEY_NUMERIC_0);	break;
+		case 0xb1: map_key_clear(KEY_NUMERIC_1);	break;
+		case 0xb2: map_key_clear(KEY_NUMERIC_2);	break;
+		case 0xb3: map_key_clear(KEY_NUMERIC_3);	break;
+		case 0xb4: map_key_clear(KEY_NUMERIC_4);	break;
+		case 0xb5: map_key_clear(KEY_NUMERIC_5);	break;
+		case 0xb6: map_key_clear(KEY_NUMERIC_6);	break;
+		case 0xb7: map_key_clear(KEY_NUMERIC_7);	break;
+		case 0xb8: map_key_clear(KEY_NUMERIC_8);	break;
+		case 0xb9: map_key_clear(KEY_NUMERIC_9);	break;
+		case 0xba: map_key_clear(KEY_NUMERIC_STAR);	break;
+		case 0xbb: map_key_clear(KEY_NUMERIC_POUND);	break;
+		case 0xbc: map_key_clear(KEY_NUMERIC_A);	break;
+		case 0xbd: map_key_clear(KEY_NUMERIC_B);	break;
+		case 0xbe: map_key_clear(KEY_NUMERIC_C);	break;
+		case 0xbf: map_key_clear(KEY_NUMERIC_D);	break;
+		default: goto ignore;
+		}
+		break;
+
 	case HID_UP_CONSUMER:	/* USB HUT v1.12, pages 75-84 */
 		switch (usage->hid & HID_USAGE) {
 		case 0x000: goto ignore;

commit 988b7fb0bfc215476c3a0a623b442cd0e29ce4c0
Merge: a8c8316b1159 cbd366bea2b8 52cd7785f3cd 94eefa271323 2f1cec3250e3 e9287099ba65 afd700d93396 500d4160abe9
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Mon Feb 9 11:17:45 2015 +0100

    Merge branches 'for-3.19/upstream-fixes', 'for-3.20/apple', 'for-3.20/betop', 'for-3.20/lenovo', 'for-3.20/logitech', 'for-3.20/rmi', 'for-3.20/upstream' and 'for-3.20/wacom' into for-linus

commit 8e7b341037db1835ee6eea64663013cbfcf33575
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Tue Jan 6 22:34:19 2015 +0100

    HID: fixup the conflicting keyboard mappings quirk
    
    The ignore check that got added in 6ce901eb61 ("HID: input: fix confusion
    on conflicting mappings") needs to properly check for VARIABLE reports
    as well (ARRAY reports should be ignored), otherwise legitimate keyboards
    might break.
    
    Cc: <stable@vger.kernel.org>
    Fixes: 6ce901eb61 ("HID: input: fix confusion on conflicting mappings")
    Reported-by: Fredrik Hallenberg <megahallon@gmail.com>
    Reported-by: David Herrmann <dh.herrmann@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 84b6899ef3fd..a758900318ff 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -1113,6 +1113,7 @@ void hidinput_hid_event(struct hid_device *hid, struct hid_field *field, struct
 	 */
 	if (!(field->flags & (HID_MAIN_ITEM_RELATIVE |
 	                      HID_MAIN_ITEM_BUFFERED_BYTE)) &&
+			      (field->flags & HID_MAIN_ITEM_VARIABLE) &&
 	    usage->usage_index < field->maxusage &&
 	    value == field->value[usage->usage_index])
 		return;

commit cbd366bea2b8513bc0fc1c9e8832cb0ab221d6d5
Author: Ross Skaliotis <rskaliotis@gmail.com>
Date:   Sat Dec 20 19:01:35 2014 -0500

    HID: apple: fix battery support for the 2009 ANSI wireless keyboard
    
    Enabled quirks necessary for correct battery capacity reporting. Cleaned up
    surrounding style.
    
    Signed-off-by: Ross Skaliotis <rskaliotis@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index e0a0f06ac5ef..146da4346b78 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -306,10 +306,13 @@ static enum power_supply_property hidinput_battery_props[] = {
 
 static const struct hid_device_id hid_battery_quirks[] = {
 	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE,
-			USB_DEVICE_ID_APPLE_ALU_WIRELESS_2009_ISO),
-	HID_BATTERY_QUIRK_PERCENT | HID_BATTERY_QUIRK_FEATURE },
+		USB_DEVICE_ID_APPLE_ALU_WIRELESS_2009_ISO),
+	  HID_BATTERY_QUIRK_PERCENT | HID_BATTERY_QUIRK_FEATURE },
+	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE,
+		USB_DEVICE_ID_APPLE_ALU_WIRELESS_2009_ANSI),
+	  HID_BATTERY_QUIRK_PERCENT | HID_BATTERY_QUIRK_FEATURE },
 	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE,
-			       USB_DEVICE_ID_APPLE_ALU_WIRELESS_2011_ANSI),
+		USB_DEVICE_ID_APPLE_ALU_WIRELESS_2011_ANSI),
 	  HID_BATTERY_QUIRK_PERCENT | HID_BATTERY_QUIRK_FEATURE },
 	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE,
 		USB_DEVICE_ID_APPLE_ALU_WIRELESS_ANSI),

commit 6ce901eb61aa30ba8565c62049ee80c90728ef14
Author: David Herrmann <dh.herrmann@gmail.com>
Date:   Mon Dec 29 15:21:26 2014 +0100

    HID: input: fix confusion on conflicting mappings
    
    On an PC-101/103/104 keyboard (American layout) the 'Enter' key and its
    neighbours look like this:
    
               +---+ +---+ +-------+
               | 1 | | 2 | |   5   |
               +---+ +---+ +-------+
                 +---+ +-----------+
                 | 3 | |     4     |
                 +---+ +-----------+
    
    On a PC-102/105 keyboard (European layout) it looks like this:
    
               +---+ +---+ +-------+
               | 1 | | 2 | |       |
               +---+ +---+ +-+  4  |
                 +---+ +---+ |     |
                 | 3 | | 5 | |     |
                 +---+ +---+ +-----+
    
    (Note that the number of keys is the same, but key '5' is moved down and
     the shape of key '4' is changed. Keys '1' to '3' are exactly the same.)
    
    The keys 1-4 report the same scan-code in HID in both layouts, even though
    the keysym they produce is usually different depending on the XKB-keymap
    used by user-space.
    However, key '5' (US 'backslash'/'pipe') reports 0x31 for the upper layout
    and 0x32 for the lower layout, as defined by the HID spec. This is highly
    confusing as the linux-input API uses a single keycode for both.
    
    So far, this was never a problem as there never has been a keyboard with
    both of those keys present at the same time. It would have to look
    something like this:
    
               +---+ +---+ +-------+
               | 1 | | 2 | |  x31  |
               +---+ +---+ +-------+
                 +---+ +---+ +-----+
                 | 3 | |x32| |  4  |
                 +---+ +---+ +-----+
    
    HID can represent such a keyboard, but the linux-input API cannot.
    Furthermore, any user-space mapping would be confused by this and,
    luckily, no-one ever produced such hardware.
    
    Now, the HID input layer fixed this mess by mapping both 0x31 and 0x32 to
    the same keycode (KEY_BACKSLASH==0x2b). As only one of both physical keys
    is present on a hardware, this works just fine.
    
    Lets introduce hardware-vendors into this:
    ------------------------------------------
    
    Unfortunately, it seems way to expensive to produce a different device for
    American and European layouts. Therefore, hardware-vendors put both keys,
    (0x31 and 0x32) on the same keyboard, but only one of them is hooked up
    to the physical button, the other one is 'dead'.
    This means, they can use the same hardware, with a different button-layout
    and automatically produce the correct HID events for American *and*
    European layouts. This is unproblematic for normal keyboards, as the
    'dead' key will never report any KEY-DOWN events. But RollOver keyboards
    send the whole matrix on each key-event, allowing n-key roll-over mode.
    This means, we get a 0x31 and 0x32 event on each key-press. One of them
    will always be 0, the other reports the real state. As we map both to the
    same keycode, we will get spurious key-events, even though the real
    key-state never changed.
    
    The easiest way would be to blacklist 'dead' keys and never handle those.
    We could simply read the 'country' tag of USB devices and blacklist either
    key according to the layout. But... hardware vendors... want the same
    device for all countries and thus many of them set 'country' to 0 for all
    devices. Meh..
    
    So we have to deal with this properly. As we cannot know which of the keys
    is 'dead', we either need a heuristic and track those keys, or we simply
    make use of our value-tracking for HID fields. We simply ignore HID events
    for absolute data if the data didn't change. As HID tracks events on the
    HID level, we haven't done the keycode translation, yet. Therefore, the
    'dead' key is tracked independently of the real key, therefore, any events
    on it will be ignored.
    
    This patch simply discards any HID events for absolute data if it didn't
    change compared to the last report. We need to ignore relative and
    buffered-byte reports for obvious reasons. But those cannot be affected by
    this bug, so we're fine.
    
    Preferably, we'd do this filtering on the HID-core level. But this might
    break a lot of custom drivers, if they do not follow the HID specs.
    Therefore, we do this late in hid-input just before we inject it into the
    input layer (which does the exact same filtering, but on the keycode
    level).
    
    If this turns out to break some devices, we might have to limit filtering
    to EV_KEY events. But lets try to do the Right Thing first, and properly
    filter any absolute data that didn't change.
    
    This patch is tagged for 'stable' as it fixes a lot of n-key RollOver
    hardware. We might wanna wait with backporting for a while, before we know
    it doesn't break anything else, though.
    
    Cc: <stable@vger.kernel.org>
    Reported-by: Adam Goode <adam@spicenitz.org>
    Reported-by: Fredrik Hallenberg <megahallon@gmail.com>
    Tested-by: Fredrik Hallenberg <megahallon@gmail.com>
    Signed-off-by: David Herrmann <dh.herrmann@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index e0a0f06ac5ef..84b6899ef3fd 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -1101,6 +1101,22 @@ void hidinput_hid_event(struct hid_device *hid, struct hid_field *field, struct
 		return;
 	}
 
+	/*
+	 * Ignore reports for absolute data if the data didn't change. This is
+	 * not only an optimization but also fixes 'dead' key reports. Some
+	 * RollOver implementations for localized keys (like BACKSLASH/PIPE; HID
+	 * 0x31 and 0x32) report multiple keys, even though a localized keyboard
+	 * can only have one of them physically available. The 'dead' keys
+	 * report constant 0. As all map to the same keycode, they'd confuse
+	 * the input layer. If we filter the 'dead' keys on the HID level, we
+	 * skip the keycode translation and only forward real events.
+	 */
+	if (!(field->flags & (HID_MAIN_ITEM_RELATIVE |
+	                      HID_MAIN_ITEM_BUFFERED_BYTE)) &&
+	    usage->usage_index < field->maxusage &&
+	    value == field->value[usage->usage_index])
+		return;
+
 	/* report the usage code as scancode if the key status has changed */
 	if (usage->type == EV_KEY && !!test_bit(usage->code, input->key) != value)
 		input_event(input, EV_MSC, MSC_SCAN, usage->hid);

commit da940db41dcf8c04166f711646df2f35376010aa
Author: Karl Relton <karllinuxtest.relton@ntlworld.com>
Date:   Tue Dec 16 15:37:22 2014 +0000

    HID: add battery quirk for USB_DEVICE_ID_APPLE_ALU_WIRELESS_2011_ISO keyboard
    
    Apple bluetooth wireless keyboard (sold in UK) has always reported zero
    for battery strength no matter what condition the batteries are actually
    in. With this patch applied (applying same quirk as other Apple
    keyboards), the battery strength is now correctly reported.
    
    Signed-off-by: Karl Relton <karllinuxtest.relton@ntlworld.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index e0a0f06ac5ef..9505605b6e22 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -311,6 +311,9 @@ static const struct hid_device_id hid_battery_quirks[] = {
 	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE,
 			       USB_DEVICE_ID_APPLE_ALU_WIRELESS_2011_ANSI),
 	  HID_BATTERY_QUIRK_PERCENT | HID_BATTERY_QUIRK_FEATURE },
+	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE,
+			       USB_DEVICE_ID_APPLE_ALU_WIRELESS_2011_ISO),
+	  HID_BATTERY_QUIRK_PERCENT | HID_BATTERY_QUIRK_FEATURE },
 	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE,
 		USB_DEVICE_ID_APPLE_ALU_WIRELESS_ANSI),
 	  HID_BATTERY_QUIRK_PERCENT | HID_BATTERY_QUIRK_FEATURE },

commit 019e129f9b2d582e5901c0594427cb4026daa413
Merge: 3ee420ba2e7f dabb05c6670e 6296f4a8eb86 c87d92b30208 f486d9dbcc8b be3b16341d5c a45c30ec5934 cabd9b5f1fc3 68a49e51a4a9 601a22f37914
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Fri Dec 12 11:15:33 2014 +0100

    Merge branches 'for-3.19/hid-report-len', 'for-3.19/i2c-hid', 'for-3.19/lenovo', 'for-3.19/logitech', 'for-3.19/microsoft', 'for-3.19/plantronics', 'for-3.19/rmi', 'for-3.19/sony' and 'for-3.19/wacom' into for-linus

commit 3ee420ba2e7fa074a668e30c2d0f4abd317e4927
Merge: a32c99e7ab84 d1c7e29e8d27 7bb9d6436511
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Fri Dec 12 11:09:23 2014 +0100

    Merge branches 'for-3.18/upstream-fixes' and 'for-3.19/upstream' into for-linus
    
    Conflicts:
            drivers/hid/hid-input.c

commit dabb05c6670e6e4415d7b56cd5864a5dbd90207f
Author: Mathieu Magnaudet <mathieu.magnaudet@gmail.com>
Date:   Thu Nov 27 16:02:36 2014 +0100

    HID: make hid_report_len as a static inline function in hid.h
    
    In several hid drivers it is necessary to calculate the length of an
    hid_report. This patch exports the existing static function hid_report_len of
    hid-core.c as an inline function in hid.h
    
    Signed-off-by: Mathieu Magnaudet <mathieu.magnaudet@enac.fr>
    Reviewed-by: Benjamin Tissoires <benjamin.tissoires@gmail.com>
    Reviewed-by: David Herrmann <dh.herrmann@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 725f22ca47fc..1e95f4df4146 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -1215,7 +1215,7 @@ static void hidinput_led_worker(struct work_struct *work)
 		return hid->ll_driver->request(hid, report, HID_REQ_SET_REPORT);
 
 	/* fall back to generic raw-output-report */
-	len = ((report->size - 1) >> 3) + 1 + (report->id > 0);
+	len = hid_report_len(report);
 	buf = hid_alloc_report_buf(report, GFP_KERNEL);
 	if (!buf)
 		return;

commit 5989a55a4c9aafba8b152c6bf52244510c2b88b9
Author: Jason Gerecke <killertofu@gmail.com>
Date:   Tue Sep 23 11:09:28 2014 -0700

    HID: input: Fix TransducerSerialNumber implementation
    
    The commit which introduced TransducerSerialNumber (368c966) is missing
    two crucial implementation details. Firstly, the commit does not set the
    type/code/bit/max fields as expected later down the code which can cause
    the driver to crash when a tablet with this usage is connected. Secondly,
    the call to 'set_bit' causes MSC_PULSELED to be sent instead of the
    expected MSC_SERIAL. This commit addreses both issues.
    
    Signed-off-by: Jason Gerecke <jason.gerecke@wacom.com>
    Reviewed-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Reviewed-by: Ping Cheng <pingc@wacom.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 56c6c30f2c7d..725f22ca47fc 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -695,7 +695,10 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 			break;
 
 		case 0x5b: /* TransducerSerialNumber */
-			set_bit(MSC_SERIAL, input->mscbit);
+			usage->type = EV_MSC;
+			usage->code = MSC_SERIAL;
+			bit = input->mscbit;
+			max = MSC_MAX;
 			break;
 
 		default:  goto unknown;

commit afdb5cce979b7d3100d58bdce70c8be6093a8915
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Tue Oct 21 23:11:00 2014 +0200

    HID: input: Map unknown consumer page codes to KEY_UNKNOWN
    
    Currently unknown consumer page codes are ignored, which means that they cannot
    later be mapped from userspace using udev / hwdb. Map them to KEY_UNKNOWN, so
    that userspace can remap them for keyboards which make up their own consumer
    page codes.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 2df7fddbd119..7ea582be9c9a 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -862,7 +862,7 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 		case 0x28b: map_key_clear(KEY_FORWARDMAIL);	break;
 		case 0x28c: map_key_clear(KEY_SEND);		break;
 
-		default:    goto ignore;
+		default: map_key_clear(KEY_UNKNOWN);
 		}
 		break;
 

commit f974008f07a62171a9dede08250c9a35c2b2b986
Author: Olivier Gay <ogay@logitech.com>
Date:   Sat Oct 18 01:53:39 2014 +0200

    HID: add keyboard input assist hid usages
    
    Add keyboard input assist controls usages from approved
    hid usage table request HUTTR42:
    http://www.usb.org/developers/hidpage/HUTRR42c.pdf
    
    Signed-off-by: Olivier Gay <ogay@logitech.com>
    Acked-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 2df7fddbd119..56c6c30f2c7d 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -862,6 +862,13 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 		case 0x28b: map_key_clear(KEY_FORWARDMAIL);	break;
 		case 0x28c: map_key_clear(KEY_SEND);		break;
 
+		case 0x2c7: map_key_clear(KEY_KBDINPUTASSIST_PREV);		break;
+		case 0x2c8: map_key_clear(KEY_KBDINPUTASSIST_NEXT);		break;
+		case 0x2c9: map_key_clear(KEY_KBDINPUTASSIST_PREVGROUP);		break;
+		case 0x2ca: map_key_clear(KEY_KBDINPUTASSIST_NEXTGROUP);		break;
+		case 0x2cb: map_key_clear(KEY_KBDINPUTASSIST_ACCEPT);	break;
+		case 0x2cc: map_key_clear(KEY_KBDINPUTASSIST_CANCEL);	break;
+
 		default:    goto ignore;
 		}
 		break;

commit 79346d620e9de87912de73337f6df8b7f9a46888
Author: Benjamin Tissoires <benjamin.tissoires@redhat.com>
Date:   Mon Aug 25 13:07:10 2014 -0400

    HID: input: force generic axis to be mapped to their user space axis
    
    Atmel 840B digitizer presents a stylus interface which reports twice
    the X coordinate and then twice the Y coordinate. In its current
    implementation, hid-input assign the first X to X, then the second to Y,
    then the first Y to Z, then the second one to RX.
    
    This is wrong, and X should always be mapped to X, no matter what.
    A solution consists in forcing X, Y, Z, RX, RY, RZ to be mapped to their
    correct user space counter part.
    
    Reported-by: Ã‰ric Brunet <Eric.Brunet@lps.ens.fr>
    Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 2619f7f4517a..2df7fddbd119 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -599,6 +599,12 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 		/* These usage IDs map directly to the usage codes. */
 		case HID_GD_X: case HID_GD_Y: case HID_GD_Z:
 		case HID_GD_RX: case HID_GD_RY: case HID_GD_RZ:
+			if (field->flags & HID_MAIN_ITEM_RELATIVE)
+				map_rel(usage->hid & 0xf);
+			else
+				map_abs_clear(usage->hid & 0xf);
+			break;
+
 		case HID_GD_SLIDER: case HID_GD_DIAL: case HID_GD_WHEEL:
 			if (field->flags & HID_MAIN_ITEM_RELATIVE)
 				map_rel(usage->hid & 0xf);

commit 368c96640d10a145da5f258f2d2833668d4f3629
Author: Ping Cheng <pinglinux@gmail.com>
Date:   Mon Jun 2 17:19:52 2014 -0700

    HID: core: add two new usages for digitizer
    
    On Feb 17, 2014, two new usages are approved to HID usage Table 18 -
    Digitizer Page:
    
    5A      Secondary Barrel Switch         MC      16.4
    5B      Transducer Serial Number        SV      16.3.1
    
    This patch adds relevant definitions to hid/input. It also removes
    outdated comments in hid.h.
    
    Signed-off-by: Ping Cheng <pingc@wacom.com>
    Reviewed-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 9f2076acffb1..2619f7f4517a 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -684,9 +684,14 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 			break;
 
 		case 0x46: /* TabletPick */
+		case 0x5a: /* SecondaryBarrelSwitch */
 			map_key_clear(BTN_STYLUS2);
 			break;
 
+		case 0x5b: /* TransducerSerialNumber */
+			set_bit(MSC_SERIAL, input->mscbit);
+			break;
+
 		default:  goto unknown;
 		}
 		break;

commit f362e690e5530dd8ace289da991bda558731678e
Author: Olivier Gay <ogay@logitech.com>
Date:   Fri Apr 25 20:26:44 2014 +0200

    HID: add missing hid usages
    
    Add some missing hid usages from consumer page, add
    some display brightness control usages from approved hid usage
    table request HUTTR41:
    http://www.usb.org/developers/hidpage/HUTRR41.pdf
    and add voice command usage from approved request HUTTR45:
    http://www.usb.org/developers/hidpage/Voice_Command_Usage.pdf
    
    [jkosina@suse.cz: removed KEY_BRIGHTNESS_TOGGLE / KEY_DISPLAYTOGGLE
     conflict from hid-debug.c]
    
    Signed-off-by: Olivier Gay <ogay@logitech.com>
    Signed-off-by: Mathieu Meisser <mmeisser@logitech.com>
    Acked-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index e7e8b19a9284..9f2076acffb1 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -721,6 +721,13 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 		case 0x06c: map_key_clear(KEY_YELLOW);		break;
 		case 0x06d: map_key_clear(KEY_ZOOM);		break;
 
+		case 0x06f: map_key_clear(KEY_BRIGHTNESSUP);		break;
+		case 0x070: map_key_clear(KEY_BRIGHTNESSDOWN);		break;
+		case 0x072: map_key_clear(KEY_BRIGHTNESS_TOGGLE);	break;
+		case 0x073: map_key_clear(KEY_BRIGHTNESS_MIN);		break;
+		case 0x074: map_key_clear(KEY_BRIGHTNESS_MAX);		break;
+		case 0x075: map_key_clear(KEY_BRIGHTNESS_AUTO);		break;
+
 		case 0x082: map_key_clear(KEY_VIDEO_NEXT);	break;
 		case 0x083: map_key_clear(KEY_LAST);		break;
 		case 0x084: map_key_clear(KEY_ENTER);		break;
@@ -761,6 +768,7 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 		case 0x0bf: map_key_clear(KEY_SLOW);		break;
 
 		case 0x0cd: map_key_clear(KEY_PLAYPAUSE);	break;
+		case 0x0cf: map_key_clear(KEY_VOICECOMMAND);	break;
 		case 0x0e0: map_abs_clear(ABS_VOLUME);		break;
 		case 0x0e2: map_key_clear(KEY_MUTE);		break;
 		case 0x0e5: map_key_clear(KEY_BASSBOOST);	break;
@@ -768,6 +776,7 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 		case 0x0ea: map_key_clear(KEY_VOLUMEDOWN);	break;
 		case 0x0f5: map_key_clear(KEY_SLOW);		break;
 
+		case 0x181: map_key_clear(KEY_BUTTONCONFIG);	break;
 		case 0x182: map_key_clear(KEY_BOOKMARKS);	break;
 		case 0x183: map_key_clear(KEY_CONFIG);		break;
 		case 0x184: map_key_clear(KEY_WORDPROCESSOR);	break;
@@ -781,6 +790,8 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 		case 0x18c: map_key_clear(KEY_VOICEMAIL);	break;
 		case 0x18d: map_key_clear(KEY_ADDRESSBOOK);	break;
 		case 0x18e: map_key_clear(KEY_CALENDAR);	break;
+		case 0x18f: map_key_clear(KEY_TASKMANAGER);	break;
+		case 0x190: map_key_clear(KEY_JOURNAL);		break;
 		case 0x191: map_key_clear(KEY_FINANCE);		break;
 		case 0x192: map_key_clear(KEY_CALC);		break;
 		case 0x193: map_key_clear(KEY_PLAYER);		break;
@@ -789,12 +800,15 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 		case 0x199: map_key_clear(KEY_CHAT);		break;
 		case 0x19c: map_key_clear(KEY_LOGOFF);		break;
 		case 0x19e: map_key_clear(KEY_COFFEE);		break;
+		case 0x19f: map_key_clear(KEY_CONTROLPANEL);		break;
+		case 0x1a2: map_key_clear(KEY_APPSELECT);		break;
 		case 0x1a3: map_key_clear(KEY_NEXT);		break;
 		case 0x1a4: map_key_clear(KEY_PREVIOUS);	break;
 		case 0x1a6: map_key_clear(KEY_HELP);		break;
 		case 0x1a7: map_key_clear(KEY_DOCUMENTS);	break;
 		case 0x1ab: map_key_clear(KEY_SPELLCHECK);	break;
 		case 0x1ae: map_key_clear(KEY_KEYBOARD);	break;
+		case 0x1b1: map_key_clear(KEY_SCREENSAVER);		break;
 		case 0x1b4: map_key_clear(KEY_FILE);		break;
 		case 0x1b6: map_key_clear(KEY_IMAGES);		break;
 		case 0x1b7: map_key_clear(KEY_AUDIO);		break;

commit 6cf8c85f8bc320ca0273c5261cc13ee1491d7b92
Merge: ded75664d1a7 34e75dca4e63
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Tue Apr 1 19:06:41 2014 +0200

    Merge branch 'for-3.15/microsoft' into for-linus
    
    Conflicts:
            drivers/hid/hid-core.c

commit ad295b6d5739ab24880a31be403bbc8fab62e177
Merge: ba04a57b4acd c3d77fab51f4
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Tue Apr 1 19:05:09 2014 +0200

    Merge branch 'for-3.15/hid-core-ll-transport-cleanup' into for-linus
    
    Conflicts:
            drivers/hid/hid-ids.h
            drivers/hid/hid-sony.c
            drivers/hid/i2c-hid/i2c-hid.c

commit 3c86726cfe38952f0366f86acfbbb025813ec1c2
Author: Benjamin Tissoires <benjamin.tissoires@redhat.com>
Date:   Thu Feb 20 15:24:49 2014 -0500

    HID: make .raw_request mandatory
    
    SET_REPORT and GET_REPORT are mandatory in the HID specification.
    Make the corresponding API in hid-core mandatory too, which removes the
    need to test against it in some various places.
    
    Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Reviewed-by: David Herrmann <dh.herrmann@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 310b96779e8e..f5aef792f13b 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -1266,9 +1266,7 @@ static struct hid_input *hidinput_allocate(struct hid_device *hid)
 	}
 
 	input_set_drvdata(input_dev, hid);
-	if (hid->ll_driver->request || hid->ll_driver->output_report ||
-	    hid->ll_driver->raw_request)
-		input_dev->event = hidinput_input_event;
+	input_dev->event = hidinput_input_event;
 	input_dev->open = hidinput_open;
 	input_dev->close = hidinput_close;
 	input_dev->setkeycode = hidinput_setkeycode;

commit 2ebaebcf31096f83401c850393e93bc8f28db0e9
Author: Benjamin Tissoires <benjamin.tissoires@redhat.com>
Date:   Thu Feb 20 15:24:48 2014 -0500

    HID: input: hid-input remove hid_output_raw_report call
    
    hid_output_raw_report() is not a ll_driver callback and should not be used.
    To keep the same code path than before, we are forced to play with the
    different hid_hw_* calls: if the usb or i2c device does not support
    direct output reports, then we will rely on the SET_REPORT HID call.
    
    Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Reviewed-by: David Herrmann <dh.herrmann@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 15959fbae268..310b96779e8e 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -1150,7 +1150,7 @@ static void hidinput_led_worker(struct work_struct *work)
 					      led_work);
 	struct hid_field *field;
 	struct hid_report *report;
-	int len;
+	int len, ret;
 	__u8 *buf;
 
 	field = hidinput_get_led_field(hid);
@@ -1184,7 +1184,10 @@ static void hidinput_led_worker(struct work_struct *work)
 
 	hid_output_report(report, buf);
 	/* synchronous output report */
-	hid_output_raw_report(hid, buf, len, HID_OUTPUT_REPORT);
+	ret = hid_hw_output_report(hid, buf, len);
+	if (ret == -ENOSYS)
+		hid_hw_raw_request(hid, report->id, buf, len, HID_OUTPUT_REPORT,
+				HID_REQ_SET_REPORT);
 	kfree(buf);
 }
 
@@ -1263,7 +1266,8 @@ static struct hid_input *hidinput_allocate(struct hid_device *hid)
 	}
 
 	input_set_drvdata(input_dev, hid);
-	if (hid->ll_driver->request || hid->hid_output_raw_report)
+	if (hid->ll_driver->request || hid->ll_driver->output_report ||
+	    hid->ll_driver->raw_request)
 		input_dev->event = hidinput_input_event;
 	input_dev->open = hidinput_open;
 	input_dev->close = hidinput_close;

commit 7e845d46b13e7730a3720e978c28117ce422edf9
Author: Benjamin Tissoires <benjamin.tissoires@redhat.com>
Date:   Wed Feb 5 16:33:23 2014 -0500

    HID: introduce helper to access hid_output_raw_report()
    
    Add a helper to access hdev->hid_output_raw_report().
    
    To convert the drivers, use the following snippets:
    
    for i in drivers/hid/*.c
    do
      sed -i.bak "s/[^ \t]*->hid_output_raw_report(/hid_output_raw_report(/g" $i
    done
    
    Then manually fix for checkpatch.pl
    
    Reviewed-by: David Herrmann <dh.herrmann@gmail.com>
    Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 5bd17b256856..15959fbae268 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -1184,7 +1184,7 @@ static void hidinput_led_worker(struct work_struct *work)
 
 	hid_output_report(report, buf);
 	/* synchronous output report */
-	hid->hid_output_raw_report(hid, buf, len, HID_OUTPUT_REPORT);
+	hid_output_raw_report(hid, buf, len, HID_OUTPUT_REPORT);
 	kfree(buf);
 }
 

commit cafebc058bf86e63fff5354864781d3de11e41d3
Author: Benjamin Tissoires <benjamin.tissoires@redhat.com>
Date:   Wed Feb 5 16:33:22 2014 -0500

    HID: remove hid_get_raw_report in struct hid_device
    
    dev->hid_get_raw_report(X) and hid_hw_raw_request(X, HID_REQ_GET_REPORT)
    are strictly equivalent. Switch the hid subsystem to the hid_hw notation
    and remove the field .hid_get_raw_report in struct hid_device.
    
    Reviewed-by: David Herrmann <dh.herrmann@gmail.com>
    Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index e5bb3c378292..5bd17b256856 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -350,9 +350,9 @@ static int hidinput_get_battery_property(struct power_supply *psy,
 			ret = -ENOMEM;
 			break;
 		}
-		ret = dev->hid_get_raw_report(dev, dev->battery_report_id,
-					      buf, 2,
-					      dev->battery_report_type);
+		ret = hid_hw_raw_request(dev, dev->battery_report_id, buf, 2,
+					 dev->battery_report_type,
+					 HID_REQ_GET_REPORT);
 
 		if (ret != 2) {
 			ret = -ENODATA;

commit b40272e4d0e6d07a0bf9409e5f95d622422cd73d
Author: Benjamin Tissoires <benjamin.tissoires@redhat.com>
Date:   Wed Feb 5 16:33:19 2014 -0500

    HID: remove hidinput_input_event handler
    
    All the different transport drivers use now the generic event handling
    in hid-input. We can remove the handler definitively now.
    
    Reviewed-by: David Herrmann <dh.herrmann@gmail.com>
    Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index d50e7313b171..e5bb3c378292 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -1263,9 +1263,7 @@ static struct hid_input *hidinput_allocate(struct hid_device *hid)
 	}
 
 	input_set_drvdata(input_dev, hid);
-	if (hid->ll_driver->hidinput_input_event)
-		input_dev->event = hid->ll_driver->hidinput_input_event;
-	else if (hid->ll_driver->request || hid->hid_output_raw_report)
+	if (hid->ll_driver->request || hid->hid_output_raw_report)
 		input_dev->event = hidinput_input_event;
 	input_dev->open = hidinput_open;
 	input_dev->close = hidinput_close;

commit 5820e4d4ae17c0994c93d0537bd1a184267f3cae
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Wed Jan 29 17:57:41 2014 +0100

    HID: Add some missing HUT mappings
    
    Add mapping for "AL Next Task/Application", "AL Previous Task/Application"
    and "AL File Browser" buttons, as found on the Microsoft Office keyboard.
    
    Note that there already is a mapping for "AL Local Machine Browser" to
    KEY_FILE. Unless we ever encounter a device with both that should not be
    a problem.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index d50e7313b171..1f0d49c6feef 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -789,10 +789,13 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 		case 0x199: map_key_clear(KEY_CHAT);		break;
 		case 0x19c: map_key_clear(KEY_LOGOFF);		break;
 		case 0x19e: map_key_clear(KEY_COFFEE);		break;
+		case 0x1a3: map_key_clear(KEY_NEXT);		break;
+		case 0x1a4: map_key_clear(KEY_PREVIOUS);	break;
 		case 0x1a6: map_key_clear(KEY_HELP);		break;
 		case 0x1a7: map_key_clear(KEY_DOCUMENTS);	break;
 		case 0x1ab: map_key_clear(KEY_SPELLCHECK);	break;
 		case 0x1ae: map_key_clear(KEY_KEYBOARD);	break;
+		case 0x1b4: map_key_clear(KEY_FILE);		break;
 		case 0x1b6: map_key_clear(KEY_IMAGES);		break;
 		case 0x1b7: map_key_clear(KEY_AUDIO);		break;
 		case 0x1b8: map_key_clear(KEY_VIDEO);		break;

commit 9d27f43274e4889249dc42ca1a3989dd75c5edaf
Author: Benjamin Tissoires <benjamin.tissoires@redhat.com>
Date:   Sat Feb 1 23:23:10 2014 -0500

    HID: fix buffer allocations
    
    When using hid_output_report(), the buffer should be allocated by hid_alloc_report_buf(),
    not a custom malloc.
    
    Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index d50e7313b171..a713e6211419 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -1178,7 +1178,7 @@ static void hidinput_led_worker(struct work_struct *work)
 
 	/* fall back to generic raw-output-report */
 	len = ((report->size - 1) >> 3) + 1 + (report->id > 0);
-	buf = kmalloc(len, GFP_KERNEL);
+	buf = hid_alloc_report_buf(report, GFP_KERNEL);
 	if (!buf)
 		return;
 

commit bbe3175408cde792fbaa5bd1e41e430ea9e4fb4f
Author: Benjamin Tissoires <benjamin.tissoires@redhat.com>
Date:   Thu Dec 19 11:05:13 2013 -0500

    HID: input: fix input sysfs path for hid devices
    
    we used to set the parent of the input device as the parent of
    the hid bus. This was introduced when we created hid as a real bus, and
    to keep backward compatibility. Now, it's time to proper set the parent
    so that sysfs has an idea of which input device is attached to
    which hid device.
    
    Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    David Herrmann <dh.herrmann@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index d97f2323af57..d50e7313b171 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -1279,7 +1279,7 @@ static struct hid_input *hidinput_allocate(struct hid_device *hid)
 	input_dev->id.vendor  = hid->vendor;
 	input_dev->id.product = hid->product;
 	input_dev->id.version = hid->version;
-	input_dev->dev.parent = hid->dev.parent;
+	input_dev->dev.parent = &hid->dev;
 	hidinput->input = input_dev;
 	list_add_tail(&hidinput->list, &hid->inputs);
 

commit ad0e669b922c7790182cf19f8015b30e23ad9499
Author: Nikolai Kondrashov <spbnick@gmail.com>
Date:   Sun Oct 13 15:09:52 2013 +0300

    HID: Fix unit exponent parsing again
    
    Revert some changes done in 774638386826621c984ab6994439f474709cac5e.
    
    Revert all changes done in hidinput_calc_abs_res as it mistakingly used
    "Unit" item exponent nibbles to affect resolution value. This wasn't
    breaking resolution calculation of relevant axes of any existing
    devices, though, as they have only one dimension to their units and thus
    1 in the corresponding nible.
    
    Revert to reading "Unit Exponent" item value as a signed integer in
    hid_parser_global to fix reading specification-complying values. This
    fixes resolution calculation of devices complying to the HID standard,
    including Huion, KYE, Waltop and UC-Logic graphics tablets which have
    their report descriptors fixed by the drivers.
    
    Explanations follow.
    
    There are two "unit exponents" in HID specification and it is important
    not to mix them. One is the global "Unit Exponent" item and another is
    nibble values in the global "Unit" item. See 6.2.2.7 Global Items.
    
    The "Unit Exponent" value is just a signed integer and is used to scale
    the integer resolution unit values, so fractions can be expressed.
    
    The nibbles of "Unit" value are used to select the unit system (nibble
    0), and presence of a particular basic unit type in the unit formula and
    its *exponent* (or power, nibbles 1-6). And yes, the latter is in two
    complement and zero means absence of the unit type.
    
    Taking the representation example of (integer) joules from the
    specification:
    
    [mass(grams)][length(centimeters)^2][time(seconds)^-2] * 10^-7
    
    the "Unit Exponent" would be -7 (or 0xF9, if stored as a byte) and the
    "Unit" value would be 0xE121, signifying:
    
    Nibble  Part        Value   Meaning
    -----   ----        -----   -------
    0       System      1       SI Linear
    1       Length      2       Centimeters^2
    2       Mass        1       Grams
    3       Time        -2      Seconds^-2
    
    To give the resolution in e.g. hundredth of joules the "Unit Exponent"
    item value should have been -9.
    
    See also the examples of "Unit" values for some common units in the same
    chapter.
    
    However, there is a common misunderstanding about the "Unit Exponent"
    value encoding, where it is assumed to be stored the same as nibbles in
    "Unit" item. This is most likely due to the specification being a bit
    vague and overloading the term "unit exponent". This also was and still
    is proliferated by the official "HID Descriptor Tool", which makes this
    mistake and stores "Unit Exponent" as such. This format is also
    mentioned in books such as "USB Complete" and in Microsoft's hardware
    design guides.
    
    As a result many devices currently on the market use this encoding and
    so the driver should support them.
    
    Signed-off-by: Nikolai Kondrashov <spbnick@gmail.com>
    Acked-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 8741d953dcc8..d97f2323af57 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -192,6 +192,7 @@ static int hidinput_setkeycode(struct input_dev *dev,
 	return -EINVAL;
 }
 
+
 /**
  * hidinput_calc_abs_res - calculate an absolute axis resolution
  * @field: the HID report field to calculate resolution for
@@ -234,23 +235,17 @@ __s32 hidinput_calc_abs_res(const struct hid_field *field, __u16 code)
 	case ABS_MT_TOOL_Y:
 	case ABS_MT_TOUCH_MAJOR:
 	case ABS_MT_TOUCH_MINOR:
-		if (field->unit & 0xffffff00)		/* Not a length */
-			return 0;
-		unit_exponent += hid_snto32(field->unit >> 4, 4) - 1;
-		switch (field->unit & 0xf) {
-		case 0x1:				/* If centimeters */
+		if (field->unit == 0x11) {		/* If centimeters */
 			/* Convert to millimeters */
 			unit_exponent += 1;
-			break;
-		case 0x3:				/* If inches */
+		} else if (field->unit == 0x13) {	/* If inches */
 			/* Convert to millimeters */
 			prev = physical_extents;
 			physical_extents *= 254;
 			if (physical_extents < prev)
 				return 0;
 			unit_exponent -= 1;
-			break;
-		default:
+		} else {
 			return 0;
 		}
 		break;

commit cc6b54aa54bf40b762cab45a9fc8aa81653146eb
Author: Benjamin Tissoires <benjamin.tissoires@redhat.com>
Date:   Wed Sep 11 21:56:57 2013 +0200

    HID: validate feature and input report details
    
    When dealing with usage_index, be sure to properly use unsigned instead of
    int to avoid overflows.
    
    When working on report fields, always validate that their report_counts are
    in bounds.
    Without this, a HID device could report a malicious feature report that
    could trick the driver into a heap overflow:
    
    [  634.885003] usb 1-1: New USB device found, idVendor=0596, idProduct=0500
    ...
    [  676.469629] BUG kmalloc-192 (Tainted: G        W   ): Redzone overwritten
    
    CVE-2013-2897
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Acked-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index b420f4a0fd28..8741d953dcc8 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -485,6 +485,10 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 	if (field->flags & HID_MAIN_ITEM_CONSTANT)
 		goto ignore;
 
+	/* Ignore if report count is out of bounds. */
+	if (field->report_count < 1)
+		goto ignore;
+
 	/* only LED usages are supported in output fields */
 	if (field->report_type == HID_OUTPUT_REPORT &&
 			(usage->hid & HID_USAGE_PAGE) != HID_UP_LED) {
@@ -1236,7 +1240,11 @@ static void report_features(struct hid_device *hid)
 
 	rep_enum = &hid->report_enum[HID_FEATURE_REPORT];
 	list_for_each_entry(rep, &rep_enum->report_list, list)
-		for (i = 0; i < rep->maxfield; i++)
+		for (i = 0; i < rep->maxfield; i++) {
+			/* Ignore if report count is out of bounds. */
+			if (rep->field[i]->report_count < 1)
+				continue;
+
 			for (j = 0; j < rep->field[i]->maxusage; j++) {
 				/* Verify if Battery Strength feature is available */
 				hidinput_setup_battery(hid, HID_FEATURE_REPORT, rep->field[i]);
@@ -1245,6 +1253,7 @@ static void report_features(struct hid_device *hid)
 					drv->feature_mapping(hid, rep->field[i],
 							     rep->field[i]->usage + j);
 			}
+		}
 }
 
 static struct hid_input *hidinput_allocate(struct hid_device *hid)

commit 63faf15dba4a7d6fb18ed5c45670a152d0c5330b
Merge: 75ba899e9521 3d7d248cf484 ddf7540e9c3a 595e9276ce68 50c9d75b6f01 f5e4e7fdd576 27f1d2f9acf2 95f712662d96
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Fri Sep 6 11:58:37 2013 +0200

    Merge branches 'for-3.12/devm', 'for-3.12/i2c-hid', 'for-3.12/i2c-hid-dt', 'for-3.12/logitech', 'for-3.12/multitouch-win8', 'for-3.12/trasnport-driver-cleanup', 'for-3.12/uhid', 'for-3.12/upstream' and 'for-3.12/wiimote' into for-linus

commit 6c2794a2984f4c17a58117a68703cc7640f01c5a
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Mon Sep 2 13:43:00 2013 +0200

    HID: battery: don't do DMA from stack
    
    Instead of using data from stack for DMA in hidinput_get_battery_property(),
    allocate the buffer dynamically.
    
    Cc: stable@kernel.org
    Reported-by: Richard Ryniker <ryniker@alum.mit.edu>
    Reported-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 7480799e535c..3fc4034a4367 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -340,7 +340,7 @@ static int hidinput_get_battery_property(struct power_supply *psy,
 {
 	struct hid_device *dev = container_of(psy, struct hid_device, battery);
 	int ret = 0;
-	__u8 buf[2] = {};
+	__u8 *buf;
 
 	switch (prop) {
 	case POWER_SUPPLY_PROP_PRESENT:
@@ -349,12 +349,19 @@ static int hidinput_get_battery_property(struct power_supply *psy,
 		break;
 
 	case POWER_SUPPLY_PROP_CAPACITY:
+
+		buf = kmalloc(2 * sizeof(__u8), GFP_KERNEL);
+		if (!buf) {
+			ret = -ENOMEM;
+			break;
+		}
 		ret = dev->hid_get_raw_report(dev, dev->battery_report_id,
-					      buf, sizeof(buf),
+					      buf, 2,
 					      dev->battery_report_type);
 
 		if (ret != 2) {
 			ret = -ENODATA;
+			kfree(buf);
 			break;
 		}
 		ret = 0;
@@ -364,6 +371,7 @@ static int hidinput_get_battery_property(struct power_supply *psy,
 		    buf[1] <= dev->battery_max)
 			val->intval = (100 * (buf[1] - dev->battery_min)) /
 				(dev->battery_max - dev->battery_min);
+		kfree(buf);
 		break;
 
 	case POWER_SUPPLY_PROP_MODEL_NAME:

commit 50c9d75b6f01a337aab728511bc1d2a0a3d7b800
Author: David Herrmann <dh.herrmann@gmail.com>
Date:   Mon Jul 15 19:10:12 2013 +0200

    HID: input: generic hidinput_input_event handler
    
    The hidinput_input_event() callback converts input events written from
    userspace into HID reports and sends them to the device. We currently
    implement this in every HID transport driver, even though most of them do
    the same.
    
    This provides a generic hidinput_input_event() implementation which is
    mostly copied from usbhid. It uses a delayed worker to allow multiple LED
    events to be collected into a single output event.
    We use the custom ->request() transport driver callback to allow drivers
    to adjust the outgoing report and handle the request asynchronously. If no
    custom ->request() callback is available, we fall back to the generic raw
    output report handler (which is synchronous).
    
    Drivers can still provide custom hidinput_input_event() handlers (see
    logitech-dj) if the generic implementation doesn't fit their needs.
    
    Signed-off-by: David Herrmann <dh.herrmann@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 7480799e535c..308eee8fc7c3 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -1137,6 +1137,74 @@ unsigned int hidinput_count_leds(struct hid_device *hid)
 }
 EXPORT_SYMBOL_GPL(hidinput_count_leds);
 
+static void hidinput_led_worker(struct work_struct *work)
+{
+	struct hid_device *hid = container_of(work, struct hid_device,
+					      led_work);
+	struct hid_field *field;
+	struct hid_report *report;
+	int len;
+	__u8 *buf;
+
+	field = hidinput_get_led_field(hid);
+	if (!field)
+		return;
+
+	/*
+	 * field->report is accessed unlocked regarding HID core. So there might
+	 * be another incoming SET-LED request from user-space, which changes
+	 * the LED state while we assemble our outgoing buffer. However, this
+	 * doesn't matter as hid_output_report() correctly converts it into a
+	 * boolean value no matter what information is currently set on the LED
+	 * field (even garbage). So the remote device will always get a valid
+	 * request.
+	 * And in case we send a wrong value, a next led worker is spawned
+	 * for every SET-LED request so the following worker will send the
+	 * correct value, guaranteed!
+	 */
+
+	report = field->report;
+
+	/* use custom SET_REPORT request if possible (asynchronous) */
+	if (hid->ll_driver->request)
+		return hid->ll_driver->request(hid, report, HID_REQ_SET_REPORT);
+
+	/* fall back to generic raw-output-report */
+	len = ((report->size - 1) >> 3) + 1 + (report->id > 0);
+	buf = kmalloc(len, GFP_KERNEL);
+	if (!buf)
+		return;
+
+	hid_output_report(report, buf);
+	/* synchronous output report */
+	hid->hid_output_raw_report(hid, buf, len, HID_OUTPUT_REPORT);
+	kfree(buf);
+}
+
+static int hidinput_input_event(struct input_dev *dev, unsigned int type,
+				unsigned int code, int value)
+{
+	struct hid_device *hid = input_get_drvdata(dev);
+	struct hid_field *field;
+	int offset;
+
+	if (type == EV_FF)
+		return input_ff_event(dev, type, code, value);
+
+	if (type != EV_LED)
+		return -1;
+
+	if ((offset = hidinput_find_field(hid, type, code, &field)) == -1) {
+		hid_warn(dev, "event field not found\n");
+		return -1;
+	}
+
+	hid_set_field(field, offset, value);
+
+	schedule_work(&hid->led_work);
+	return 0;
+}
+
 static int hidinput_open(struct input_dev *dev)
 {
 	struct hid_device *hid = input_get_drvdata(dev);
@@ -1183,7 +1251,10 @@ static struct hid_input *hidinput_allocate(struct hid_device *hid)
 	}
 
 	input_set_drvdata(input_dev, hid);
-	input_dev->event = hid->ll_driver->hidinput_input_event;
+	if (hid->ll_driver->hidinput_input_event)
+		input_dev->event = hid->ll_driver->hidinput_input_event;
+	else if (hid->ll_driver->request || hid->hid_output_raw_report)
+		input_dev->event = hidinput_input_event;
 	input_dev->open = hidinput_open;
 	input_dev->close = hidinput_close;
 	input_dev->setkeycode = hidinput_setkeycode;
@@ -1278,6 +1349,7 @@ int hidinput_connect(struct hid_device *hid, unsigned int force)
 	int i, j, k;
 
 	INIT_LIST_HEAD(&hid->inputs);
+	INIT_WORK(&hid->led_work, hidinput_led_worker);
 
 	if (!force) {
 		for (i = 0; i < hid->maxcollection; i++) {
@@ -1379,6 +1451,12 @@ void hidinput_disconnect(struct hid_device *hid)
 		input_unregister_device(hidinput->input);
 		kfree(hidinput);
 	}
+
+	/* led_work is spawned by input_dev callbacks, but doesn't access the
+	 * parent input_dev at all. Once all input devices are removed, we
+	 * know that led_work will never get restarted, so we can cancel it
+	 * synchronously and are safe. */
+	cancel_work_sync(&hid->led_work);
 }
 EXPORT_SYMBOL_GPL(hidinput_disconnect);
 

commit 08ec2dcc3527a20c619aca2fb36f800908256bac
Merge: db58316892a5 adb91aef9f99 078328da5d5d 3685c18e17f1
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Thu Jul 4 15:02:26 2013 +0200

    Merge branches 'for-3.11/multitouch', 'for-3.11/sony' and 'for-3.11/upstream' into for-linus
    
    Conflicts:
            drivers/hid/hid-core.c

commit a688393bd3fb27690a77f7ae8607b4969039bac5
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Wed Jun 19 23:52:11 2013 +0200

    HID: explain out-of-range check better
    
    Extend the comment explaining the condition for discarding
    out-of-range values to clarify the cases in which devices don't
    provide any logical min/max.
    
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 82130cf724e4..9aeca6023617 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -1042,7 +1042,11 @@ void hidinput_hid_event(struct hid_device *hid, struct hid_field *field, struct
 
 	/*
 	 * Ignore out-of-range values as per HID specification,
-	 * section 5.10 and 6.2.25
+	 * section 5.10 and 6.2.25.
+	 *
+	 * The logical_minimum < logical_maximum check is done so that we
+	 * don't unintentionally discard values sent by devices which
+	 * don't specify logical min and max.
 	 */
 	if ((field->flags & HID_MAIN_ITEM_VARIABLE) &&
 	    (field->logical_minimum < field->logical_maximum) &&

commit 6f1891d01956cad406d2af8ed2e9cef6108bfc5e
Author: Benjamin Tissoires <benjamin.tissoires@redhat.com>
Date:   Wed Jun 19 17:49:05 2013 +0200

    HID: fix false positive out of range values
    
    Commit 6da7066906e977d42104a859c490f5f9a300488c introduced in 3.3
    "HID: ignore absolute values which don't fit between logical min and max"
    prevents some Posiflex touch screen to work because they do not provide
    logical min and max for their buttons.
    Thus, logical min and max are at 0, discarding the buttons events, and
    preventing the device to report appropriate X Y.
    
    Adding a check on "min < max" solves the problem.
    
    Reported-by: Jan Kandziora <jjj@gmx.de>
    Tested-by: Jan Kandziora <jjj@gmx.de>
    Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 945b8158ec4c..82130cf724e4 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -1045,6 +1045,7 @@ void hidinput_hid_event(struct hid_device *hid, struct hid_field *field, struct
 	 * section 5.10 and 6.2.25
 	 */
 	if ((field->flags & HID_MAIN_ITEM_VARIABLE) &&
+	    (field->logical_minimum < field->logical_maximum) &&
 	    (value < field->logical_minimum ||
 	     value > field->logical_maximum)) {
 		dbg_hid("Ignoring out-of-range value %x\n", value);

commit d0a934b764c67b4bf626f5b7cf725a6e3066afd2
Author: David Herrmann <dh.herrmann@gmail.com>
Date:   Mon May 13 17:01:30 2013 +0200

    HID: input: return ENODATA if reading battery attrs fails
    
    power_supply core has the bad habit of calling our battery callbacks
    from within power_supply_register(). Furthermore, if the callbacks
    fail with an unhandled error code, it will skip any uevent that it
    might currently process.
    So if HID-core registers battery devices, an "add" uevent is generated
    and the battery callbacks are called. These will gracefully fail due
    to timeouts as they might still hold locks on event processing. One
    could argue that this should be fixed in power_supply core, but the
    least we can do is to signal ENODATA so power_supply core will just
    skip the property and continue with the uevent.
    
    This fixes a bug where "add" and "remove" uevents are skipped for
    battery devices. upower is unable to track these devices and currently
    needs to ignore them.
    
    This patch also overwrites any other error code. I cannot see any reason
    why we should forward protocol- or I/O-errors to the power_supply core.
    We handle these errors in hid_ll_driver later, anyway, so just skip
    them. power_supply core cannot do anything useful with them, anyway,
    and we avoid skipping important uevents and confusing user-space.
    
    Thanks a lot to Daniel Nicoletti for pushing and investigating
    on this.
    
    Cc: Jiri Kosina <jkosina@suse.cz>
    Cc: Anton Vorontsov <cbou@mail.ru>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Reported-by: Daniel Nicoletti <dantti12@gmail.com>
    Signed-off-by: David Herrmann <dh.herrmann@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 945b8158ec4c..c526a3ccbe5b 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -354,10 +354,10 @@ static int hidinput_get_battery_property(struct power_supply *psy,
 					      dev->battery_report_type);
 
 		if (ret != 2) {
-			if (ret >= 0)
-				ret = -EINVAL;
+			ret = -ENODATA;
 			break;
 		}
+		ret = 0;
 
 		if (dev->battery_min < dev->battery_max &&
 		    buf[1] >= dev->battery_min &&

commit 4f22decf9b6329acfe59091c5cba6b378b9b31db
Author: Benjamin Tissoires <benjamin.tissoires@redhat.com>
Date:   Fri Mar 22 18:38:28 2013 +0100

    HID: input: don't register unmapped input devices
    
    There is no need to register an input device containing no events.
    This allows drivers using the quirk MULTI_INPUT to register one input
    per report effectively used.
    
    For backward compatibility, we need to add a quirk to request
    this behavior.
    
    Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 21b196c394b1..945b8158ec4c 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -1198,6 +1198,67 @@ static struct hid_input *hidinput_allocate(struct hid_device *hid)
 	return hidinput;
 }
 
+static bool hidinput_has_been_populated(struct hid_input *hidinput)
+{
+	int i;
+	unsigned long r = 0;
+
+	for (i = 0; i < BITS_TO_LONGS(EV_CNT); i++)
+		r |= hidinput->input->evbit[i];
+
+	for (i = 0; i < BITS_TO_LONGS(KEY_CNT); i++)
+		r |= hidinput->input->keybit[i];
+
+	for (i = 0; i < BITS_TO_LONGS(REL_CNT); i++)
+		r |= hidinput->input->relbit[i];
+
+	for (i = 0; i < BITS_TO_LONGS(ABS_CNT); i++)
+		r |= hidinput->input->absbit[i];
+
+	for (i = 0; i < BITS_TO_LONGS(MSC_CNT); i++)
+		r |= hidinput->input->mscbit[i];
+
+	for (i = 0; i < BITS_TO_LONGS(LED_CNT); i++)
+		r |= hidinput->input->ledbit[i];
+
+	for (i = 0; i < BITS_TO_LONGS(SND_CNT); i++)
+		r |= hidinput->input->sndbit[i];
+
+	for (i = 0; i < BITS_TO_LONGS(FF_CNT); i++)
+		r |= hidinput->input->ffbit[i];
+
+	for (i = 0; i < BITS_TO_LONGS(SW_CNT); i++)
+		r |= hidinput->input->swbit[i];
+
+	return !!r;
+}
+
+static void hidinput_cleanup_hidinput(struct hid_device *hid,
+		struct hid_input *hidinput)
+{
+	struct hid_report *report;
+	int i, k;
+
+	list_del(&hidinput->list);
+	input_free_device(hidinput->input);
+
+	for (k = HID_INPUT_REPORT; k <= HID_OUTPUT_REPORT; k++) {
+		if (k == HID_OUTPUT_REPORT &&
+			hid->quirks & HID_QUIRK_SKIP_OUTPUT_REPORTS)
+			continue;
+
+		list_for_each_entry(report, &hid->report_enum[k].report_list,
+				    list) {
+
+			for (i = 0; i < report->maxfield; i++)
+				if (report->field[i]->hidinput == hidinput)
+					report->field[i]->hidinput = NULL;
+		}
+	}
+
+	kfree(hidinput);
+}
+
 /*
  * Register the input device; print a message.
  * Configure the input layer interface
@@ -1249,6 +1310,10 @@ int hidinput_connect(struct hid_device *hid, unsigned int force)
 					hidinput_configure_usage(hidinput, report->field[i],
 								 report->field[i]->usage + j);
 
+			if ((hid->quirks & HID_QUIRK_NO_EMPTY_INPUT) &&
+			    !hidinput_has_been_populated(hidinput))
+				continue;
+
 			if (hid->quirks & HID_QUIRK_MULTI_INPUT) {
 				/* This will leave hidinput NULL, so that it
 				 * allocates another one if we have more inputs on
@@ -1265,6 +1330,18 @@ int hidinput_connect(struct hid_device *hid, unsigned int force)
 		}
 	}
 
+	if (hidinput && (hid->quirks & HID_QUIRK_NO_EMPTY_INPUT) &&
+	    !hidinput_has_been_populated(hidinput)) {
+		/* no need to register an input device not populated */
+		hidinput_cleanup_hidinput(hid, hidinput);
+		hidinput = NULL;
+	}
+
+	if (list_empty(&hid->inputs)) {
+		hid_err(hid, "No inputs registered, leaving\n");
+		goto out_unwind;
+	}
+
 	if (hidinput) {
 		if (drv->input_configured)
 			drv->input_configured(hid, hidinput);

commit 818b930bc15077fc00ff16bb22c5df1857f05afa
Merge: f9af7b9edccb b5531318f18b 7a7d6d9c5fcd 1b42fc4a2889 955dca354c3c 68fd32b8228a 4529eefad087
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Wed Dec 12 21:41:55 2012 +0100

    Merge branches 'for-3.7/upstream-fixes', 'for-3.8/hidraw', 'for-3.8/i2c-hid', 'for-3.8/multitouch', 'for-3.8/roccat', 'for-3.8/sensors' and 'for-3.8/upstream' into for-linus
    
    Conflicts:
            drivers/hid/hid-core.c

commit ae751fa82dd8e5a79932d6b55742e7e298afd733
Author: Benjamin Tissoires <benjamin.tissoires@gmail.com>
Date:   Fri Nov 23 16:31:24 2012 +0100

    HID: hid-input: factorize hid_input allocation
    
    This just refactors the allocation of hid_input.
    No semantic changes.
    
    Signed-off-by: Benjamin Tissoires <benjamin.tissoires@gmail.com>
    Reviewed-by: Henrik Rydberg <rydberg@euromail.se>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 0887b52f804b..97c08c5d0973 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -1154,6 +1154,38 @@ static void report_features(struct hid_device *hid)
 			}
 }
 
+static struct hid_input *hidinput_allocate(struct hid_device *hid)
+{
+	struct hid_input *hidinput = kzalloc(sizeof(*hidinput), GFP_KERNEL);
+	struct input_dev *input_dev = input_allocate_device();
+	if (!hidinput || !input_dev) {
+		kfree(hidinput);
+		input_free_device(input_dev);
+		hid_err(hid, "Out of memory during hid input probe\n");
+		return NULL;
+	}
+
+	input_set_drvdata(input_dev, hid);
+	input_dev->event = hid->ll_driver->hidinput_input_event;
+	input_dev->open = hidinput_open;
+	input_dev->close = hidinput_close;
+	input_dev->setkeycode = hidinput_setkeycode;
+	input_dev->getkeycode = hidinput_getkeycode;
+
+	input_dev->name = hid->name;
+	input_dev->phys = hid->phys;
+	input_dev->uniq = hid->uniq;
+	input_dev->id.bustype = hid->bus;
+	input_dev->id.vendor  = hid->vendor;
+	input_dev->id.product = hid->product;
+	input_dev->id.version = hid->version;
+	input_dev->dev.parent = hid->dev.parent;
+	hidinput->input = input_dev;
+	list_add_tail(&hidinput->list, &hid->inputs);
+
+	return hidinput;
+}
+
 /*
  * Register the input device; print a message.
  * Configure the input layer interface
@@ -1165,7 +1197,6 @@ int hidinput_connect(struct hid_device *hid, unsigned int force)
 	struct hid_driver *drv = hid->driver;
 	struct hid_report *report;
 	struct hid_input *hidinput = NULL;
-	struct input_dev *input_dev;
 	int i, j, k;
 
 	INIT_LIST_HEAD(&hid->inputs);
@@ -1196,33 +1227,9 @@ int hidinput_connect(struct hid_device *hid, unsigned int force)
 				continue;
 
 			if (!hidinput) {
-				hidinput = kzalloc(sizeof(*hidinput), GFP_KERNEL);
-				input_dev = input_allocate_device();
-				if (!hidinput || !input_dev) {
-					kfree(hidinput);
-					input_free_device(input_dev);
-					hid_err(hid, "Out of memory during hid input probe\n");
+				hidinput = hidinput_allocate(hid);
+				if (!hidinput)
 					goto out_unwind;
-				}
-
-				input_set_drvdata(input_dev, hid);
-				input_dev->event =
-					hid->ll_driver->hidinput_input_event;
-				input_dev->open = hidinput_open;
-				input_dev->close = hidinput_close;
-				input_dev->setkeycode = hidinput_setkeycode;
-				input_dev->getkeycode = hidinput_getkeycode;
-
-				input_dev->name = hid->name;
-				input_dev->phys = hid->phys;
-				input_dev->uniq = hid->uniq;
-				input_dev->id.bustype = hid->bus;
-				input_dev->id.vendor  = hid->vendor;
-				input_dev->id.product = hid->product;
-				input_dev->id.version = hid->version;
-				input_dev->dev.parent = hid->dev.parent;
-				hidinput->input = input_dev;
-				list_add_tail(&hidinput->list, &hid->inputs);
 			}
 
 			for (i = 0; i < report->maxfield; i++)

commit 4cc8541782140e9ccbece5c8ac367fbf659b16d9
Author: Ortwin GlÃ¼ck <odi@odi.ch>
Date:   Sun Nov 25 15:08:34 2012 +0100

    HID: add battery quirk for Apple 2009_ISO keyboard
    
    Support battery capacity on another Apple wireless keyboard.
    
    Signed-off-by: Ortwin GlÃ¼ck <odi@odi.ch>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 10248cf548fc..0887b52f804b 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -298,6 +298,9 @@ static enum power_supply_property hidinput_battery_props[] = {
 #define HID_BATTERY_QUIRK_FEATURE	(1 << 1) /* ask for feature report */
 
 static const struct hid_device_id hid_battery_quirks[] = {
+	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE,
+			USB_DEVICE_ID_APPLE_ALU_WIRELESS_2009_ISO),
+	HID_BATTERY_QUIRK_PERCENT | HID_BATTERY_QUIRK_FEATURE },
 	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE,
 			       USB_DEVICE_ID_APPLE_ALU_WIRELESS_2011_ANSI),
 	  HID_BATTERY_QUIRK_PERCENT | HID_BATTERY_QUIRK_FEATURE },

commit 774638386826621c984ab6994439f474709cac5e
Author: Benjamin Tissoires <benjamin.tissoires@gmail.com>
Date:   Wed Nov 14 16:59:15 2012 +0100

    HID: fix unit exponent parsing
    
    HID spec details special values for the HID field unit exponent.
    Basically, the range [0x8..0xf] correspond to [-8..-1], so this is
    a standard two's complement on a half-byte.
    
    Signed-off-by: Benjamin Tissoires <benjamin.tissoires@gmail.com>
    Acked-by: Jiri Kosina <jkosina@suse.cz>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 1b0adc3f7803..007a9433bfa7 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -192,7 +192,6 @@ static int hidinput_setkeycode(struct input_dev *dev,
 	return -EINVAL;
 }
 
-
 /**
  * hidinput_calc_abs_res - calculate an absolute axis resolution
  * @field: the HID report field to calculate resolution for
@@ -235,17 +234,23 @@ __s32 hidinput_calc_abs_res(const struct hid_field *field, __u16 code)
 	case ABS_MT_TOOL_Y:
 	case ABS_MT_TOUCH_MAJOR:
 	case ABS_MT_TOUCH_MINOR:
-		if (field->unit == 0x11) {		/* If centimeters */
+		if (field->unit & 0xffffff00)		/* Not a length */
+			return 0;
+		unit_exponent += hid_snto32(field->unit >> 4, 4) - 1;
+		switch (field->unit & 0xf) {
+		case 0x1:				/* If centimeters */
 			/* Convert to millimeters */
 			unit_exponent += 1;
-		} else if (field->unit == 0x13) {	/* If inches */
+			break;
+		case 0x3:				/* If inches */
 			/* Convert to millimeters */
 			prev = physical_extents;
 			physical_extents *= 254;
 			if (physical_extents < prev)
 				return 0;
 			unit_exponent -= 1;
-		} else {
+			break;
+		default:
 			return 0;
 		}
 		break;

commit ccdd699411b77c463022ebac311eb4a06ca56db4
Author: Benjamin Tissoires <benjamin.tissoires@gmail.com>
Date:   Wed Nov 14 16:59:14 2012 +0100

    HID: round return value of hidinput_calc_abs_res
    
    hidinput_calc_abs_res should return the closest int in the division
    instead of the floor.
    On a device with a logical_max of 3008 and a physical_max of 255mm,
    previous implementation gave a resolution of 11 instead of 12.
    With 11, user-space computes a physical size of 273.5mm and the
    round_closest results gives 250.6mm.
    The old implementation introduced an error of 2cm in this example.
    
    Signed-off-by: Benjamin Tissoires <benjamin.tissoires@gmail.com>
    Acked-by: Jiri Kosina <jkosina@suse.cz>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index d1ec571bdb3b..1b0adc3f7803 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -287,7 +287,7 @@ __s32 hidinput_calc_abs_res(const struct hid_field *field, __u16 code)
 	}
 
 	/* Calculate resolution */
-	return logical_extents / physical_extents;
+	return DIV_ROUND_CLOSEST(logical_extents, physical_extents);
 }
 EXPORT_SYMBOL_GPL(hidinput_calc_abs_res);
 

commit 37cf6e6fc34e2fca4e7c565697e7cd5c317bc316
Author: Benjamin Tissoires <benjamin.tissoires@gmail.com>
Date:   Wed Nov 14 16:59:13 2012 +0100

    HID: export hidinput_calc_abs_res
    
    Exporting the function allows us to calculate the resolution in third
    party drivers like hid-multitouch.
    This patch also complete the function with additional valid axes.
    
    Signed-off-by: Benjamin Tissoires <benjamin.tissoires@gmail.com>
    Acked-by: Jiri Kosina <jkosina@suse.cz>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index d917c0d53685..d1ec571bdb3b 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -208,7 +208,7 @@ static int hidinput_setkeycode(struct input_dev *dev,
  * Only exponent 1 length units are processed. Centimeters and inches are
  * converted to millimeters. Degrees are converted to radians.
  */
-static __s32 hidinput_calc_abs_res(const struct hid_field *field, __u16 code)
+__s32 hidinput_calc_abs_res(const struct hid_field *field, __u16 code)
 {
 	__s32 unit_exponent = field->unit_exponent;
 	__s32 logical_extents = field->logical_maximum -
@@ -229,6 +229,12 @@ static __s32 hidinput_calc_abs_res(const struct hid_field *field, __u16 code)
 	case ABS_X:
 	case ABS_Y:
 	case ABS_Z:
+	case ABS_MT_POSITION_X:
+	case ABS_MT_POSITION_Y:
+	case ABS_MT_TOOL_X:
+	case ABS_MT_TOOL_Y:
+	case ABS_MT_TOUCH_MAJOR:
+	case ABS_MT_TOUCH_MINOR:
 		if (field->unit == 0x11) {		/* If centimeters */
 			/* Convert to millimeters */
 			unit_exponent += 1;
@@ -283,6 +289,7 @@ static __s32 hidinput_calc_abs_res(const struct hid_field *field, __u16 code)
 	/* Calculate resolution */
 	return logical_extents / physical_extents;
 }
+EXPORT_SYMBOL_GPL(hidinput_calc_abs_res);
 
 #ifdef CONFIG_HID_BATTERY_STRENGTH
 static enum power_supply_property hidinput_battery_props[] = {

commit f8e86d054686d9090549476ea2394aa04c614a93
Author: Ingo Ruhnke <grumbel@gmail.com>
Date:   Mon Oct 29 14:29:30 2012 +0100

    HID: fix incorrect handling of devices with high button count
    
    Button names for USB gamepads are currently assigned incorrectly, as the evdev
    code assigned to buttons is "BTN_GAMEPAD + code", which on devices with more
    then 16 buttons bleeds over into button names reserved for graphic tablets
    (BTN_TOOL_PEN, etc.). This causes problems further down the line as the device
    are now no longer detected as joystick. This patch fixes that by assigning
    buttons outside the range to BTN_TRIGGER_HAPPY (as is already the case for USB
    joysticks).
    
    Furthermore this patch corrects the assignment to BTN_TRIGGER_HAPPY, as
    currently the first button over 16 is assigned to BTN_TRIGGER_HAPPY17 (i.e.
    BTN_TRIGGER_HAPPY+0x10) not BTN_TRIGGER_HAPPY.
    
    Signed-off-by: Ingo Ruhnke <grumbel@gmail.com>
    Acked-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index d917c0d53685..10248cf548fc 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -502,9 +502,14 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 				if (code <= 0xf)
 					code += BTN_JOYSTICK;
 				else
-					code += BTN_TRIGGER_HAPPY;
+					code += BTN_TRIGGER_HAPPY - 0x10;
+				break;
+		case HID_GD_GAMEPAD:
+				if (code <= 0xf)
+					code += BTN_GAMEPAD;
+				else
+					code += BTN_TRIGGER_HAPPY - 0x10;
 				break;
-		case HID_GD_GAMEPAD:  code += BTN_GAMEPAD; break;
 		default:
 			switch (field->physical) {
 			case HID_GD_MOUSE:

commit 9ebf3d7687192923e3d44fdbcd8d9f8375053fb8
Author: Henrik Rydberg <rydberg@euromail.se>
Date:   Mon Jul 30 13:28:18 2012 +0200

    HID: Add an input configured notification callback
    
    A hid device may create several input devices, and a driver may need
    to prepare or finalize the configuration per input device. Currently,
    there is no sane way for a driver to know when a device has been
    configured. This patch adds a callback providing that information.
    
    Reviewed-and-tested-by: Benjamin Tissoires <benjamin.tissoires@enac.fr>
    Tested-by: Ping Cheng <pingc@wacom.com>
    Acked-by: Jiri Kosina <jkosina@suse.cz>
    Signed-off-by: Henrik Rydberg <rydberg@euromail.se>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 811bfad64609..d917c0d53685 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -1154,6 +1154,7 @@ static void report_features(struct hid_device *hid)
 
 int hidinput_connect(struct hid_device *hid, unsigned int force)
 {
+	struct hid_driver *drv = hid->driver;
 	struct hid_report *report;
 	struct hid_input *hidinput = NULL;
 	struct input_dev *input_dev;
@@ -1228,6 +1229,8 @@ int hidinput_connect(struct hid_device *hid, unsigned int force)
 				 * UGCI) cram a lot of unrelated inputs into the
 				 * same interface. */
 				hidinput->report = report;
+				if (drv->input_configured)
+					drv->input_configured(hid, hidinput);
 				if (input_register_device(hidinput->input))
 					goto out_cleanup;
 				hidinput = NULL;
@@ -1235,8 +1238,12 @@ int hidinput_connect(struct hid_device *hid, unsigned int force)
 		}
 	}
 
-	if (hidinput && input_register_device(hidinput->input))
-		goto out_cleanup;
+	if (hidinput) {
+		if (drv->input_configured)
+			drv->input_configured(hid, hidinput);
+		if (input_register_device(hidinput->input))
+			goto out_cleanup;
+	}
 
 	return 0;
 

commit 929bd380b7aec9f9553b6509af86cdba25e334b8
Merge: b94e3c94aae0 a6d1bc1d5fb0 82d069822fea 11a5c818ae2b eb055fd0560b 2d8767bb4215
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Tue Jul 24 13:39:00 2012 +0200

    Merge branches 'hidraw', 'magicmouse', 'multitouch', 'roccat', 'suspend-fixes' and 'upstream' into for-linus

commit 929578ab0339fe42bb3ceeaa2e6607189cddf70b
Author: Keng-Yu Lin <kengyu@canonical.com>
Date:   Fri Jul 6 18:06:11 2012 +0800

    HID: Add suport for the brightness control keys on HP keyboards
    
    The keys are found on the keyboards bundled with HP All-In-One machines
    with USB VID/PID of 04ca:004d and 04f2:1061.
    
    Signed-off-by: Keng-Yu Lin <kengyu@canonical.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 132b0019365e..879443bf410f 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -834,6 +834,15 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 		}
 		break;
 
+	case HID_UP_HPVENDOR2:
+		set_bit(EV_REP, input->evbit);
+		switch (usage->hid & HID_USAGE) {
+		case 0x003: map_key_clear(KEY_BRIGHTNESSDOWN);	break;
+		case 0x004: map_key_clear(KEY_BRIGHTNESSUP);	break;
+		default:    goto ignore;
+		}
+		break;
+
 	case HID_UP_MSVENDOR:
 		goto ignore;
 

commit 0c47935c5b5cd4916cf1c1ed4a2894807f7bcc3e
Author: Daniel Nicoletti <dantti12@gmail.com>
Date:   Wed Jul 4 10:20:31 2012 -0300

    HID: add battery quirk for Apple Wireless ANSI
    
    Add USB_DEVICE_ID_APPLE_ALU_WIRELESS_ANSI, to the quirk list since it report
    wrong feature type and wrong percentage range.
    
    Signed-off-by: Daniel Nicoletti <dantti12@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 132b0019365e..5301006f6c15 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -301,6 +301,9 @@ static const struct hid_device_id hid_battery_quirks[] = {
 	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE,
 			       USB_DEVICE_ID_APPLE_ALU_WIRELESS_2011_ANSI),
 	  HID_BATTERY_QUIRK_PERCENT | HID_BATTERY_QUIRK_FEATURE },
+	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE,
+		USB_DEVICE_ID_APPLE_ALU_WIRELESS_ANSI),
+	  HID_BATTERY_QUIRK_PERCENT | HID_BATTERY_QUIRK_FEATURE },
 	{}
 };
 

commit 99ce58ddc4eadec8c35d9a1d64ff57703fdcfacc
Merge: 56ccd186f183 44d27f7dfedd 4e52b538e31d ed1379492578
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Tue May 22 11:33:42 2012 +0200

    Merge branches 'upstream-fixes', 'wacom' and 'waltop' into for-linus
    
    Conflicts:
            drivers/hid/hid-core.c

commit 4fa3a5837b8427faab9b064b1948795eb77b9f8d
Author: Henrik Rydberg <rydberg@euromail.se>
Date:   Tue May 1 08:40:01 2012 +0200

    HID: hid-multitouch: Switch to device groups
    
    Switch the driver over to device group handling.  By adding the
    HID_GROUP_MULTITOUCH group to hid-core, hid-generic will no longer
    match multitouch devices.  By adding the HID_GROUP_MULTITOUCH entry to
    the device list, hid-multitouch will match all unknown multitouch
    devices, and udev will automatically load the module.
    
    Since HID_QUIRK_MULTITOUCH never gets set, the special quirks handling
    can be removed.  Since all HID MT devices have HID_DG_CONTACTID, they
    can be removed from the hid_have_special_driver list.
    
    With this patch, the unknown device ids are no longer NULL, so the code
    is modified to check for the generic entry instead.
    
    Signed-off-by: Henrik Rydberg <rydberg@euromail.se>
    Acked-by: Benjamin Tissoires <benjamin.tissoires@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 002781c5a616..7b43186b022c 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -638,10 +638,6 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 			map_key_clear(BTN_STYLUS2);
 			break;
 
-		case 0x51: /* ContactID */
-			device->quirks |= HID_QUIRK_MULTITOUCH;
-			goto unknown;
-
 		default:  goto unknown;
 		}
 		break;
@@ -1208,13 +1204,6 @@ int hidinput_connect(struct hid_device *hid, unsigned int force)
 		}
 	}
 
-	if (hid->quirks & HID_QUIRK_MULTITOUCH) {
-		/* generic hid does not know how to handle multitouch devices */
-		if (hidinput)
-			goto out_cleanup;
-		goto out_unwind;
-	}
-
 	if (hidinput && input_register_device(hidinput->input))
 		goto out_cleanup;
 

commit b73b2da0353d15b712b27b1aed3c50856bdfc341
Author: Nikolai Kondrashov <spbnick@gmail.com>
Date:   Tue Mar 20 16:01:32 2012 +0200

    HID: hid-input: Add digitizer tilt usage support
    
    Add digitizer X Tilt and Y Tilt usage support along with resolution calculation.
    
    Signed-off-by: Nikolai Kondrashov <spbnick@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 002781c5a616..22d8ce6d5a59 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -225,7 +225,10 @@ static __s32 hidinput_calc_abs_res(const struct hid_field *field, __u16 code)
 	 * Verify and convert units.
 	 * See HID specification v1.11 6.2.2.7 Global Items for unit decoding
 	 */
-	if (code == ABS_X || code == ABS_Y || code == ABS_Z) {
+	switch (code) {
+	case ABS_X:
+	case ABS_Y:
+	case ABS_Z:
 		if (field->unit == 0x11) {		/* If centimeters */
 			/* Convert to millimeters */
 			unit_exponent += 1;
@@ -239,7 +242,13 @@ static __s32 hidinput_calc_abs_res(const struct hid_field *field, __u16 code)
 		} else {
 			return 0;
 		}
-	} else if (code == ABS_RX || code == ABS_RY || code == ABS_RZ) {
+		break;
+
+	case ABS_RX:
+	case ABS_RY:
+	case ABS_RZ:
+	case ABS_TILT_X:
+	case ABS_TILT_Y:
 		if (field->unit == 0x14) {		/* If degrees */
 			/* Convert to radians */
 			prev = logical_extents;
@@ -250,7 +259,9 @@ static __s32 hidinput_calc_abs_res(const struct hid_field *field, __u16 code)
 		} else if (field->unit != 0x12) {	/* If not radians */
 			return 0;
 		}
-	} else {
+		break;
+
+	default:
 		return 0;
 	}
 
@@ -623,6 +634,14 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 			map_key_clear(BTN_TOOL_RUBBER);
 			break;
 
+		case 0x3d: /* X Tilt */
+			map_abs_clear(ABS_TILT_X);
+			break;
+
+		case 0x3e: /* Y Tilt */
+			map_abs_clear(ABS_TILT_Y);
+			break;
+
 		case 0x33: /* Touch */
 		case 0x42: /* TipSwitch */
 		case 0x43: /* TipSwitch2 */

commit 3abee3526d381e33a391362b01dc8b17d377076d
Merge: 550cf00dbc8e 45d9c273b262 765031668fb2 9e87f22ac635
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Tue Mar 20 13:04:25 2012 +0100

    Merge branches 'battery-scope', 'logitech' and 'multitouch' into for-linus

commit 883e0e366209067e690356e58e19bb2e6693b839
Author: Nikolai Kondrashov <spbnick@gmail.com>
Date:   Fri Mar 2 22:13:58 2012 +0200

    HID: hid-input: allow array fields out of range
    
    Allow array field values out of range as per HID 1.11 specification,
    section 6.2.25:
    
            Rather than returning a single bit for each button in the group, an
            array returns an index in each field that corresponds to the pressed
            button (like keyboard scan codes). An out-of range value in and array
            field is considered no controls asserted.
    
    Apparently, "and" above is a typo and should be "an".
    
    This fixes at least Waltop tablet pen clicks - otherwise BTN_TOUCH is never
    released.
    
    The relevant part of Waltop tablet report descriptors is this:
    
            0x09, 0x42,         /*          Usage (Tip Switch),         */
            0x09, 0x44,         /*          Usage (Barrel Switch),      */
            0x09, 0x46,         /*          Usage (Tablet Pick),        */
            0x15, 0x01,         /*          Logical Minimum (1),        */
            0x25, 0x03,         /*          Logical Maximum (3),        */
            0x75, 0x04,         /*          Report Size (4),            */
            0x95, 0x01,         /*          Report Count (1),           */
            0x80,               /*          Input,                      */
    
    This is a regression fix for commit b4b583d ("HID: be more strict when
    ignoring out-of-range fields").
    
    Signed-off-by: Nikolai Kondrashov <spbnick@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 9333d692a786..627850a54d34 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -986,8 +986,13 @@ void hidinput_hid_event(struct hid_device *hid, struct hid_field *field, struct
 		return;
 	}
 
-	/* Ignore out-of-range values as per HID specification, section 5.10 */
-	if (value < field->logical_minimum || value > field->logical_maximum) {
+	/*
+	 * Ignore out-of-range values as per HID specification,
+	 * section 5.10 and 6.2.25
+	 */
+	if ((field->flags & HID_MAIN_ITEM_VARIABLE) &&
+	    (value < field->logical_minimum ||
+	     value > field->logical_maximum)) {
 		dbg_hid("Ignoring out-of-range value %x\n", value);
 		return;
 	}

commit 45d9c273b262cde84bb6bb3fc02c01d07da76936
Author: Jeremy Fitzhardinge <jeremy@goop.org>
Date:   Wed Dec 7 17:31:43 2011 -0800

    HID: hid-input/battery: set scope and powered device for HID battery
    
    Set the battery's power supply scope to "Device" and point the power
    supply to the powered device.
    
    Signed-off-by: Jeremy Fitzhardinge <jeremy@goop.org>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 9333d692a786..af0200f061c0 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -279,7 +279,8 @@ static enum power_supply_property hidinput_battery_props[] = {
 	POWER_SUPPLY_PROP_ONLINE,
 	POWER_SUPPLY_PROP_CAPACITY,
 	POWER_SUPPLY_PROP_MODEL_NAME,
-	POWER_SUPPLY_PROP_STATUS
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_SCOPE,
 };
 
 #define HID_BATTERY_QUIRK_PERCENT	(1 << 0) /* always reports percent */
@@ -344,6 +345,10 @@ static int hidinput_get_battery_property(struct power_supply *psy,
 		val->intval = POWER_SUPPLY_STATUS_DISCHARGING;
 		break;
 
+	case POWER_SUPPLY_PROP_SCOPE:
+		val->intval = POWER_SUPPLY_SCOPE_DEVICE;
+		break;
+
 	default:
 		ret = -EINVAL;
 		break;
@@ -403,6 +408,8 @@ static bool hidinput_setup_battery(struct hid_device *dev, unsigned report_type,
 		battery->name = NULL;
 	}
 
+	power_supply_powers(battery, &dev->dev);
+
 out:
 	return true;
 }

commit 420174afdc7023c000e5b5b1b6fe9e028470c713
Merge: e0273728564a 652aa6a9ac4a
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Mon Jan 9 11:24:59 2012 +0100

    Merge branch 'hid-battery' of git://git.kernel.org/pub/scm/linux/kernel/git/jeremy/xen into for-linus

commit 652aa6a9ac4a5f8d3e1fa3f6466646519e83c01e
Author: Jeremy Fitzhardinge <jeremy@goop.org>
Date:   Fri Dec 9 00:10:28 2011 -0800

    hid-input/battery: add FEATURE quirk
    
    Apple keyboards require a FEATURE report to query the battery state,
    even though they list as an input.  Without this, it returns an error.
    
    Signed-off-by: Jeremy Fitzhardinge <jeremy@goop.org>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 48785db10e87..0f1250d10ea1 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -283,12 +283,12 @@ static enum power_supply_property hidinput_battery_props[] = {
 };
 
 #define HID_BATTERY_QUIRK_PERCENT	(1 << 0) /* always reports percent */
+#define HID_BATTERY_QUIRK_FEATURE	(1 << 1) /* ask for feature report */
 
 static const struct hid_device_id hid_battery_quirks[] = {
-	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_MAGICMOUSE),
-	  HID_BATTERY_QUIRK_PERCENT },
-	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_MAGICTRACKPAD),
-	  HID_BATTERY_QUIRK_PERCENT },
+	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE,
+			       USB_DEVICE_ID_APPLE_ALU_WIRELESS_2011_ANSI),
+	  HID_BATTERY_QUIRK_PERCENT | HID_BATTERY_QUIRK_FEATURE },
 	{}
 };
 
@@ -310,7 +310,6 @@ static int hidinput_get_battery_property(struct power_supply *psy,
 {
 	struct hid_device *dev = container_of(psy, struct hid_device, battery);
 	int ret = 0;
-	int ret_rep;
 	__u8 buf[2] = {};
 
 	switch (prop) {
@@ -320,11 +319,13 @@ static int hidinput_get_battery_property(struct power_supply *psy,
 		break;
 
 	case POWER_SUPPLY_PROP_CAPACITY:
-		ret_rep = dev->hid_get_raw_report(dev, dev->battery_report_id,
-						  buf, sizeof(buf),
-						  dev->battery_report_type);
-		if (ret_rep != 2) {
-			ret = -EINVAL;
+		ret = dev->hid_get_raw_report(dev, dev->battery_report_id,
+					      buf, sizeof(buf),
+					      dev->battery_report_type);
+
+		if (ret != 2) {
+			if (ret >= 0)
+				ret = -EINVAL;
 			break;
 		}
 
@@ -376,6 +377,9 @@ static bool hidinput_setup_battery(struct hid_device *dev, unsigned report_type,
 
 	quirks = find_battery_quirk(dev);
 
+	hid_dbg(dev, "device %x:%x:%x %d quirks %d\n",
+		dev->bus, dev->vendor, dev->product, dev->version, quirks);
+
 	min = field->logical_minimum;
 	max = field->logical_maximum;
 
@@ -384,6 +388,9 @@ static bool hidinput_setup_battery(struct hid_device *dev, unsigned report_type,
 		max = 100;
 	}
 
+	if (quirks & HID_BATTERY_QUIRK_FEATURE)
+		report_type = HID_FEATURE_REPORT;
+
 	dev->battery_min = min;
 	dev->battery_max = max;
 	dev->battery_report_type = report_type;

commit ce63920b395f1476e2d28cca16a56919289f0b62
Author: Jeremy Fitzhardinge <jeremy@goop.org>
Date:   Fri Dec 2 21:57:50 2011 -0800

    hid-input/battery: remove battery_val
    
    hidinput_get_battery_property() now directly polls the device for the
    current battery strength, so there's no need for battery_val, or the
    code to set it on the input event path.
    
    Signed-off-by: Jeremy Fitzhardinge <jeremy@goop.org>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index ceade58b8027..48785db10e87 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -917,14 +917,6 @@ void hidinput_hid_event(struct hid_device *hid, struct hid_field *field, struct
 
 	input = field->hidinput->input;
 
-#ifdef CONFIG_HID_BATTERY_STRENGTH
-	if (usage->hid == HID_DC_BATTERYSTRENGTH) {
-		hid->battery_val = value;
-		hid_dbg(hid, "battery value is %d (range %d-%d)\n",
-			value, hid->battery_min, hid->battery_max);
-		return;
-	}
-#endif
 	if (!usage->type)
 		return;
 

commit b3ca3839f344aa469e6f53c8bbb633e5ab9b96c8
Author: Jeremy Fitzhardinge <jeremy@goop.org>
Date:   Fri Dec 2 19:06:10 2011 -0800

    hid-input/battery: power-supply type really *is* a battery
    
    It just isn't a battery which is powering the computer.  upower needs
    a more nuanced understanding of this.
    
    Signed-off-by: Jeremy Fitzhardinge <jeremy@goop.org>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 771ff5df5742..ceade58b8027 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -368,7 +368,7 @@ static bool hidinput_setup_battery(struct hid_device *dev, unsigned report_type,
 	if (battery->name == NULL)
 		goto out;
 
-	battery->type = POWER_SUPPLY_TYPE_USB;
+	battery->type = POWER_SUPPLY_TYPE_BATTERY;
 	battery->properties = hidinput_battery_props;
 	battery->num_properties = ARRAY_SIZE(hidinput_battery_props);
 	battery->use_for_apm = 0;

commit 2f2e3f6d7a24e7fceb0fef514767025cddb64dc2
Author: Jeremy Fitzhardinge <jeremy@goop.org>
Date:   Fri Dec 2 19:05:07 2011 -0800

    hid-input/battery: make the battery setup common for INPUTs and FEATUREs
    
    Signed-off-by: Jeremy Fitzhardinge <jeremy@goop.org>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index f5c3efcdcb02..771ff5df5742 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -351,20 +351,22 @@ static int hidinput_get_battery_property(struct power_supply *psy,
 	return ret;
 }
 
-static void hidinput_setup_battery(struct hid_device *dev,
-				   unsigned report_type, unsigned report_id,
-				   s32 min, s32 max)
+static bool hidinput_setup_battery(struct hid_device *dev, unsigned report_type, struct hid_field *field)
 {
 	struct power_supply *battery = &dev->battery;
 	int ret;
 	unsigned quirks;
+	s32 min, max;
+
+	if (field->usage->hid != HID_DC_BATTERYSTRENGTH)
+		return false;	/* no match */
 
 	if (battery->name != NULL)
-		return;		/* already initialized? */
+		goto out;	/* already initialized? */
 
 	battery->name = kasprintf(GFP_KERNEL, "hid-%s-battery", dev->uniq);
 	if (battery->name == NULL)
-		return;
+		goto out;
 
 	battery->type = POWER_SUPPLY_TYPE_USB;
 	battery->properties = hidinput_battery_props;
@@ -374,6 +376,9 @@ static void hidinput_setup_battery(struct hid_device *dev,
 
 	quirks = find_battery_quirk(dev);
 
+	min = field->logical_minimum;
+	max = field->logical_maximum;
+
 	if (quirks & HID_BATTERY_QUIRK_PERCENT) {
 		min = 0;
 		max = 100;
@@ -382,7 +387,7 @@ static void hidinput_setup_battery(struct hid_device *dev,
 	dev->battery_min = min;
 	dev->battery_max = max;
 	dev->battery_report_type = report_type;
-	dev->battery_report_id = report_id;
+	dev->battery_report_id = field->report->id;
 
 	ret = power_supply_register(&dev->dev, battery);
 	if (ret != 0) {
@@ -390,6 +395,9 @@ static void hidinput_setup_battery(struct hid_device *dev,
 		kfree(battery->name);
 		battery->name = NULL;
 	}
+
+out:
+	return true;
 }
 
 static void hidinput_cleanup_battery(struct hid_device *dev)
@@ -402,10 +410,10 @@ static void hidinput_cleanup_battery(struct hid_device *dev)
 	dev->battery.name = NULL;
 }
 #else  /* !CONFIG_HID_BATTERY_STRENGTH */
-static void hidinput_setup_battery(struct hid_device *dev,
-				   unsigned report_type, unsigned report_id,
-				   s32 min, s32 max)
+static bool hidinput_setup_battery(struct hid_device *dev, unsigned report_type,
+				   struct hid_field *field)
 {
+	return false;
 }
 
 static void hidinput_cleanup_battery(struct hid_device *dev)
@@ -772,14 +780,9 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 		break;
 
 	case HID_UP_GENDEVCTRLS:
-		if ((usage->hid & HID_USAGE) == 0x20) {	/* Battery Strength */
-			hidinput_setup_battery(device,
-					       HID_INPUT_REPORT,
-					       field->report->id,
-					       field->logical_minimum,
-					       field->logical_maximum);
+		if (hidinput_setup_battery(device, HID_INPUT_REPORT, field))
 			goto ignore;
-		} else
+		else
 			goto unknown;
 		break;
 
@@ -1055,13 +1058,7 @@ static void report_features(struct hid_device *hid)
 		for (i = 0; i < rep->maxfield; i++)
 			for (j = 0; j < rep->field[i]->maxusage; j++) {
 				/* Verify if Battery Strength feature is available */
-				if (((rep->field[i]->usage + j)->hid & HID_USAGE_PAGE) == HID_UP_GENDEVCTRLS &&
-					((rep->field[i]->usage + j)->hid & HID_USAGE) == 0x20) {
-					hidinput_setup_battery(hid,
-							       HID_FEATURE_REPORT, rep->id,
-							       rep->field[i]->logical_minimum,
-							       rep->field[i]->logical_maximum);
-				}
+				hidinput_setup_battery(hid, HID_FEATURE_REPORT, rep->field[i]);
 
 				if (drv->feature_mapping)
 					drv->feature_mapping(hid, rep->field[i],

commit fb8ac91b4dccbdda0ad51d499079d05143783ba4
Author: Jeremy Fitzhardinge <jeremy@goop.org>
Date:   Fri Dec 2 11:18:45 2011 -0800

    hid-input/battery: deal with both FEATURE and INPUT report batteries
    
    Some devices seem to report batteries as FEATUREs, others as INPUTs.
    
    Signed-off-by: Jeremy Fitzhardinge <jeremy@goop.org>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 69dec476883a..f5c3efcdcb02 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -312,7 +312,6 @@ static int hidinput_get_battery_property(struct power_supply *psy,
 	int ret = 0;
 	int ret_rep;
 	__u8 buf[2] = {};
-	unsigned char report_number = dev->battery_report_id;
 
 	switch (prop) {
 	case POWER_SUPPLY_PROP_PRESENT:
@@ -321,8 +320,9 @@ static int hidinput_get_battery_property(struct power_supply *psy,
 		break;
 
 	case POWER_SUPPLY_PROP_CAPACITY:
-		ret_rep = dev->hid_get_raw_report(dev, report_number,
-						  buf, sizeof(buf), HID_FEATURE_REPORT);
+		ret_rep = dev->hid_get_raw_report(dev, dev->battery_report_id,
+						  buf, sizeof(buf),
+						  dev->battery_report_type);
 		if (ret_rep != 2) {
 			ret = -EINVAL;
 			break;
@@ -351,7 +351,9 @@ static int hidinput_get_battery_property(struct power_supply *psy,
 	return ret;
 }
 
-static void hidinput_setup_battery(struct hid_device *dev, unsigned id, s32 min, s32 max)
+static void hidinput_setup_battery(struct hid_device *dev,
+				   unsigned report_type, unsigned report_id,
+				   s32 min, s32 max)
 {
 	struct power_supply *battery = &dev->battery;
 	int ret;
@@ -379,7 +381,8 @@ static void hidinput_setup_battery(struct hid_device *dev, unsigned id, s32 min,
 
 	dev->battery_min = min;
 	dev->battery_max = max;
-	dev->battery_report_id = id;
+	dev->battery_report_type = report_type;
+	dev->battery_report_id = report_id;
 
 	ret = power_supply_register(&dev->dev, battery);
 	if (ret != 0) {
@@ -399,7 +402,9 @@ static void hidinput_cleanup_battery(struct hid_device *dev)
 	dev->battery.name = NULL;
 }
 #else  /* !CONFIG_HID_BATTERY_STRENGTH */
-static void hidinput_setup_battery(struct hid_device *dev, unsigned id, s32 min, s32 max)
+static void hidinput_setup_battery(struct hid_device *dev,
+				   unsigned report_type, unsigned report_id,
+				   s32 min, s32 max)
 {
 }
 
@@ -769,6 +774,7 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 	case HID_UP_GENDEVCTRLS:
 		if ((usage->hid & HID_USAGE) == 0x20) {	/* Battery Strength */
 			hidinput_setup_battery(device,
+					       HID_INPUT_REPORT,
 					       field->report->id,
 					       field->logical_minimum,
 					       field->logical_maximum);
@@ -1052,7 +1058,7 @@ static void report_features(struct hid_device *hid)
 				if (((rep->field[i]->usage + j)->hid & HID_USAGE_PAGE) == HID_UP_GENDEVCTRLS &&
 					((rep->field[i]->usage + j)->hid & HID_USAGE) == 0x20) {
 					hidinput_setup_battery(hid,
-							       rep->id,
+							       HID_FEATURE_REPORT, rep->id,
 							       rep->field[i]->logical_minimum,
 							       rep->field[i]->logical_maximum);
 				}

commit bbc21cfd55858d7c3e55bfaa91fa934b0b13ad4d
Author: Jeremy Fitzhardinge <jeremy@goop.org>
Date:   Fri Dec 2 11:12:36 2011 -0800

    hid-input/battery: add quirks for battery
    
    Some devices always report percentage, despite having 0/255 as their
    min/max, so add a quirk for them.
    
    Signed-off-by: Jeremy Fitzhardinge <jeremy@goop.org>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index b108ce71583f..69dec476883a 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -32,6 +32,8 @@
 #include <linux/hid.h>
 #include <linux/hid-debug.h>
 
+#include "hid-ids.h"
+
 #define unk	KEY_UNKNOWN
 
 static const unsigned char hid_keyboard[256] = {
@@ -280,6 +282,28 @@ static enum power_supply_property hidinput_battery_props[] = {
 	POWER_SUPPLY_PROP_STATUS
 };
 
+#define HID_BATTERY_QUIRK_PERCENT	(1 << 0) /* always reports percent */
+
+static const struct hid_device_id hid_battery_quirks[] = {
+	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_MAGICMOUSE),
+	  HID_BATTERY_QUIRK_PERCENT },
+	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_MAGICTRACKPAD),
+	  HID_BATTERY_QUIRK_PERCENT },
+	{}
+};
+
+static unsigned find_battery_quirk(struct hid_device *hdev)
+{
+	unsigned quirks = 0;
+	const struct hid_device_id *match;
+
+	match = hid_match_id(hdev, hid_battery_quirks);
+	if (match != NULL)
+		quirks = match->driver_data;
+
+	return quirks;
+}
+
 static int hidinput_get_battery_property(struct power_supply *psy,
 					 enum power_supply_property prop,
 					 union power_supply_propval *val)
@@ -304,10 +328,11 @@ static int hidinput_get_battery_property(struct power_supply *psy,
 			break;
 		}
 
-		/* store the returned value */
-		/* I'm not calculating this using the logical_minimum and maximum */
-		/* because my device returns 0-100 even though the min and max are 0-255 */
-		val->intval = buf[1];
+		if (dev->battery_min < dev->battery_max &&
+		    buf[1] >= dev->battery_min &&
+		    buf[1] <= dev->battery_max)
+			val->intval = (100 * (buf[1] - dev->battery_min)) /
+				(dev->battery_max - dev->battery_min);
 		break;
 
 	case POWER_SUPPLY_PROP_MODEL_NAME:
@@ -330,6 +355,7 @@ static void hidinput_setup_battery(struct hid_device *dev, unsigned id, s32 min,
 {
 	struct power_supply *battery = &dev->battery;
 	int ret;
+	unsigned quirks;
 
 	if (battery->name != NULL)
 		return;		/* already initialized? */
@@ -344,6 +370,13 @@ static void hidinput_setup_battery(struct hid_device *dev, unsigned id, s32 min,
 	battery->use_for_apm = 0;
 	battery->get_property = hidinput_get_battery_property;
 
+	quirks = find_battery_quirk(dev);
+
+	if (quirks & HID_BATTERY_QUIRK_PERCENT) {
+		min = 0;
+		max = 100;
+	}
+
 	dev->battery_min = min;
 	dev->battery_max = max;
 	dev->battery_report_id = id;

commit ef5251993c3597a88b893fe22ee830092dff35f9
Author: Jeremy Fitzhardinge <jeremy@goop.org>
Date:   Fri Dec 2 10:04:04 2011 -0800

    hid-input/battery: remove apparently redundant kmalloc
    
    Signed-off-by: Jeremy Fitzhardinge <jeremy@goop.org>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 8fac47cf42f1..b108ce71583f 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -287,7 +287,7 @@ static int hidinput_get_battery_property(struct power_supply *psy,
 	struct hid_device *dev = container_of(psy, struct hid_device, battery);
 	int ret = 0;
 	int ret_rep;
-	__u8 *buf = NULL;
+	__u8 buf[2] = {};
 	unsigned char report_number = dev->battery_report_id;
 
 	switch (prop) {
@@ -297,14 +297,8 @@ static int hidinput_get_battery_property(struct power_supply *psy,
 		break;
 
 	case POWER_SUPPLY_PROP_CAPACITY:
-		buf = kmalloc(2 * sizeof(__u8), GFP_KERNEL);
-		if (!buf) {
-			ret = -ENOMEM;
-			break;
-		}
-
-		memset(buf, 0, sizeof(buf));
-		ret_rep = dev->hid_get_raw_report(dev, report_number, buf, sizeof(buf), HID_FEATURE_REPORT);
+		ret_rep = dev->hid_get_raw_report(dev, report_number,
+						  buf, sizeof(buf), HID_FEATURE_REPORT);
 		if (ret_rep != 2) {
 			ret = -EINVAL;
 			break;
@@ -329,9 +323,6 @@ static int hidinput_get_battery_property(struct power_supply *psy,
 		break;
 	}
 
-	if (buf) {
-		kfree(buf);
-	}
 	return ret;
 }
 

commit c5a92aa3eb7425da68797a820d208edad36551f7
Author: Daniel Nicoletti <dantti12@gmail.com>
Date:   Fri Dec 2 03:52:22 2011 -0200

    hid-input: add support for HID devices reporting Battery Strength
    
    I've sent an email earlier asking for help with a GetFeature code, and now I
    have a second patch on top of Jeremy's to provide the battery functionality
    for devices that support reporting it.
    
    If I understood correctly when talking to Jeremy he said his device
    never actually reported the status as an input event (sorry if I didn't
    understand it correctly), and after reading HID specs I believe it's
    really because it was meant to be probed, I have an Apple Keyboard and
    Magic Trackpad both bluetooth batteries operated, so using PacketLogger
    I saw that Mac OSX always ask the battery status using the so called
    GetFeature.
    
    What my patch does is basically:
    - store the report id that matches the battery_strength
    - setup the battery if 0x6.0x20 is found, even if that is reported as a feature
      (as it was meant to be but only the MagicTrackpad does)
    - when upower or someone access /sys/class/power_supply/hid-*/capacity it
      will probe the device and return it's status.
    
    It works great for both devices, but I have two concerns:
    - the report_features function has a duplicated code
    - it would be nice if it was possible for specific drivers to provide their own
      probe as there might be some strange devices... (but maybe it's
    already possible)
    
    I've talked to the upower dev and he fixed it to be able to show the
    right percentage.
    
    Here how the uevent file (in /sys/class/power_supply/hid-*/) looks like:
    POWER_SUPPLY_NAME=hid-00:22:41:D9:18:E7-battery
    POWER_SUPPLY_PRESENT=1
    POWER_SUPPLY_ONLINE=1
    POWER_SUPPLY_CAPACITY=66
    POWER_SUPPLY_MODEL_NAME=MacAdminâ€™s keyboard
    POWER_SUPPLY_STATUS=Discharging
    
    POWER_SUPPLY_NAME=hid-70:CD:60:F5:FF:3F-battery
    POWER_SUPPLY_PRESENT=1
    POWER_SUPPLY_ONLINE=1
    POWER_SUPPLY_CAPACITY=62
    POWER_SUPPLY_MODEL_NAME=nexxâ€™s Trackpad
    POWER_SUPPLY_STATUS=Discharging
    
    Signed-off-by: Daniel Nicoletti <dantti12@gmail.com>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index b9b8c75a6f9a..8fac47cf42f1 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -277,6 +277,7 @@ static enum power_supply_property hidinput_battery_props[] = {
 	POWER_SUPPLY_PROP_ONLINE,
 	POWER_SUPPLY_PROP_CAPACITY,
 	POWER_SUPPLY_PROP_MODEL_NAME,
+	POWER_SUPPLY_PROP_STATUS
 };
 
 static int hidinput_get_battery_property(struct power_supply *psy,
@@ -285,6 +286,9 @@ static int hidinput_get_battery_property(struct power_supply *psy,
 {
 	struct hid_device *dev = container_of(psy, struct hid_device, battery);
 	int ret = 0;
+	int ret_rep;
+	__u8 *buf = NULL;
+	unsigned char report_number = dev->battery_report_id;
 
 	switch (prop) {
 	case POWER_SUPPLY_PROP_PRESENT:
@@ -293,28 +297,45 @@ static int hidinput_get_battery_property(struct power_supply *psy,
 		break;
 
 	case POWER_SUPPLY_PROP_CAPACITY:
-		if (dev->battery_min < dev->battery_max &&
-		    dev->battery_val >= dev->battery_min &&
-		    dev->battery_val <= dev->battery_max)
-			val->intval = (100 * (dev->battery_val - dev->battery_min)) /
-				(dev->battery_max - dev->battery_min);
-		else
+		buf = kmalloc(2 * sizeof(__u8), GFP_KERNEL);
+		if (!buf) {
+			ret = -ENOMEM;
+			break;
+		}
+
+		memset(buf, 0, sizeof(buf));
+		ret_rep = dev->hid_get_raw_report(dev, report_number, buf, sizeof(buf), HID_FEATURE_REPORT);
+		if (ret_rep != 2) {
 			ret = -EINVAL;
+			break;
+		}
+
+		/* store the returned value */
+		/* I'm not calculating this using the logical_minimum and maximum */
+		/* because my device returns 0-100 even though the min and max are 0-255 */
+		val->intval = buf[1];
 		break;
 
 	case POWER_SUPPLY_PROP_MODEL_NAME:
 		val->strval = dev->name;
 		break;
 
+	case POWER_SUPPLY_PROP_STATUS:
+		val->intval = POWER_SUPPLY_STATUS_DISCHARGING;
+		break;
+
 	default:
 		ret = -EINVAL;
 		break;
 	}
 
+	if (buf) {
+		kfree(buf);
+	}
 	return ret;
 }
 
-static void hidinput_setup_battery(struct hid_device *dev, s32 min, s32 max)
+static void hidinput_setup_battery(struct hid_device *dev, unsigned id, s32 min, s32 max)
 {
 	struct power_supply *battery = &dev->battery;
 	int ret;
@@ -326,7 +347,7 @@ static void hidinput_setup_battery(struct hid_device *dev, s32 min, s32 max)
 	if (battery->name == NULL)
 		return;
 
-	battery->type = POWER_SUPPLY_TYPE_BATTERY;
+	battery->type = POWER_SUPPLY_TYPE_USB;
 	battery->properties = hidinput_battery_props;
 	battery->num_properties = ARRAY_SIZE(hidinput_battery_props);
 	battery->use_for_apm = 0;
@@ -334,6 +355,7 @@ static void hidinput_setup_battery(struct hid_device *dev, s32 min, s32 max)
 
 	dev->battery_min = min;
 	dev->battery_max = max;
+	dev->battery_report_id = id;
 
 	ret = power_supply_register(&dev->dev, battery);
 	if (ret != 0) {
@@ -353,7 +375,7 @@ static void hidinput_cleanup_battery(struct hid_device *dev)
 	dev->battery.name = NULL;
 }
 #else  /* !CONFIG_HID_BATTERY_STRENGTH */
-static void hidinput_setup_battery(struct hid_device *dev, s32 min, s32 max)
+static void hidinput_setup_battery(struct hid_device *dev, unsigned id, s32 min, s32 max)
 {
 }
 
@@ -723,6 +745,7 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 	case HID_UP_GENDEVCTRLS:
 		if ((usage->hid & HID_USAGE) == 0x20) {	/* Battery Strength */
 			hidinput_setup_battery(device,
+					       field->report->id,
 					       field->logical_minimum,
 					       field->logical_maximum);
 			goto ignore;
@@ -997,15 +1020,23 @@ static void report_features(struct hid_device *hid)
 	struct hid_report *rep;
 	int i, j;
 
-	if (!drv->feature_mapping)
-		return;
-
 	rep_enum = &hid->report_enum[HID_FEATURE_REPORT];
 	list_for_each_entry(rep, &rep_enum->report_list, list)
 		for (i = 0; i < rep->maxfield; i++)
-			for (j = 0; j < rep->field[i]->maxusage; j++)
-				drv->feature_mapping(hid, rep->field[i],
-						     rep->field[i]->usage + j);
+			for (j = 0; j < rep->field[i]->maxusage; j++) {
+				/* Verify if Battery Strength feature is available */
+				if (((rep->field[i]->usage + j)->hid & HID_USAGE_PAGE) == HID_UP_GENDEVCTRLS &&
+					((rep->field[i]->usage + j)->hid & HID_USAGE) == 0x20) {
+					hidinput_setup_battery(hid,
+							       rep->id,
+							       rep->field[i]->logical_minimum,
+							       rep->field[i]->logical_maximum);
+				}
+
+				if (drv->feature_mapping)
+					drv->feature_mapping(hid, rep->field[i],
+							     rep->field[i]->usage + j);
+			}
 }
 
 /*

commit 4371ea8202e98c8ef77ca887de3b19affbb3498f
Author: Daniel Kurtz <djkurtz@chromium.org>
Date:   Thu Nov 17 19:23:50 2011 +0800

    HID: usbhid: defer LED setting to a workqueue
    
    Defer LED setting action to a workqueue.
    This is more likely to send all LED change events in a single URB.
    
    Signed-off-by: Daniel Kurtz <djkurtz@chromium.org>
    Acked-by: Oliver Neukum <oneukum@suse.de>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index b9b8c75a6f9a..c6ee632bfd68 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -976,6 +976,48 @@ int hidinput_find_field(struct hid_device *hid, unsigned int type, unsigned int
 }
 EXPORT_SYMBOL_GPL(hidinput_find_field);
 
+struct hid_field *hidinput_get_led_field(struct hid_device *hid)
+{
+	struct hid_report *report;
+	struct hid_field *field;
+	int i, j;
+
+	list_for_each_entry(report,
+			    &hid->report_enum[HID_OUTPUT_REPORT].report_list,
+			    list) {
+		for (i = 0; i < report->maxfield; i++) {
+			field = report->field[i];
+			for (j = 0; j < field->maxusage; j++)
+				if (field->usage[j].type == EV_LED)
+					return field;
+		}
+	}
+	return NULL;
+}
+EXPORT_SYMBOL_GPL(hidinput_get_led_field);
+
+unsigned int hidinput_count_leds(struct hid_device *hid)
+{
+	struct hid_report *report;
+	struct hid_field *field;
+	int i, j;
+	unsigned int count = 0;
+
+	list_for_each_entry(report,
+			    &hid->report_enum[HID_OUTPUT_REPORT].report_list,
+			    list) {
+		for (i = 0; i < report->maxfield; i++) {
+			field = report->field[i];
+			for (j = 0; j < field->maxusage; j++)
+				if (field->usage[j].type == EV_LED &&
+				    field->value[j])
+					count += 1;
+		}
+	}
+	return count;
+}
+EXPORT_SYMBOL_GPL(hidinput_count_leds);
+
 static int hidinput_open(struct input_dev *dev)
 {
 	struct hid_device *hid = input_get_drvdata(dev);

commit 672007957846c3d556165bab635a9c9b855261fa
Author: Jeremy Fitzhardinge <jeremy@goop.org>
Date:   Wed Nov 30 14:42:04 2011 +0100

    HID: hid-input: fix compile for !HID_BATTERY_STRENGTH
    
    As reported by Stephen Rothwell:
    drivers/hid/hid-input.c: In function 'hidinput_hid_event':
    drivers/hid/hid-input.c:865:6: error: 'struct hid_device' has no member
    named 'battery_val'
    drivers/hid/hid-input.c:866:3: error: 'struct hid_device' has no member
    named 'battery_min'
    drivers/hid/hid-input.c:866:3: error: 'struct hid_device' has no member
    named 'battery_max'
    
    Signed-off-by: Jeremy Fitzhardinge <jeremy@goop.org>
    Reported-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 2d96b782b203..b9b8c75a6f9a 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -861,13 +861,14 @@ void hidinput_hid_event(struct hid_device *hid, struct hid_field *field, struct
 
 	input = field->hidinput->input;
 
+#ifdef CONFIG_HID_BATTERY_STRENGTH
 	if (usage->hid == HID_DC_BATTERYSTRENGTH) {
 		hid->battery_val = value;
 		hid_dbg(hid, "battery value is %d (range %d-%d)\n",
 			value, hid->battery_min, hid->battery_max);
 		return;
 	}
-
+#endif
 	if (!usage->type)
 		return;
 

commit 4f5ca836bef3dd3eb602152d5d712a513998264e
Author: Jeremy Fitzhardinge <jeremy@goop.org>
Date:   Wed Nov 23 00:49:14 2011 -0800

    HID: hid-input: add support for HID devices reporting Battery Strength
    
    Some HID devices, such as my Bluetooth mouse, report their battery
    strength as an event.  Rather than passing it through as a strange
    absolute input event, this patch registers it with the power_supply
    subsystem as a battery, so that the device's Battery Strength can be
    reported to usermode.
    
    The battery appears in sysfs names
    /sys/class/power_supply/hid-<UNIQ>-battery, and it is a child of the
    battery-containing device, so it should be clear what it's the battery of.
    
    Unfortunately on my current Fedora 16 system, while the battery does
    appear in the UI, it is listed as a Laptop Battery with 0% charge (since
    it ignores the "capacity" property of the battery and instead computes
    it from the "energy*" fields, which we can't supply given the limited
    information contained within the HID Report).
    
    Still, this patch is the first step.
    
    Signed-off-by: Jeremy Fitzhardinge <jeremy@goop.org>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 6e3252651ce3..2d96b782b203 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -271,6 +271,97 @@ static __s32 hidinput_calc_abs_res(const struct hid_field *field, __u16 code)
 	return logical_extents / physical_extents;
 }
 
+#ifdef CONFIG_HID_BATTERY_STRENGTH
+static enum power_supply_property hidinput_battery_props[] = {
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_ONLINE,
+	POWER_SUPPLY_PROP_CAPACITY,
+	POWER_SUPPLY_PROP_MODEL_NAME,
+};
+
+static int hidinput_get_battery_property(struct power_supply *psy,
+					 enum power_supply_property prop,
+					 union power_supply_propval *val)
+{
+	struct hid_device *dev = container_of(psy, struct hid_device, battery);
+	int ret = 0;
+
+	switch (prop) {
+	case POWER_SUPPLY_PROP_PRESENT:
+	case POWER_SUPPLY_PROP_ONLINE:
+		val->intval = 1;
+		break;
+
+	case POWER_SUPPLY_PROP_CAPACITY:
+		if (dev->battery_min < dev->battery_max &&
+		    dev->battery_val >= dev->battery_min &&
+		    dev->battery_val <= dev->battery_max)
+			val->intval = (100 * (dev->battery_val - dev->battery_min)) /
+				(dev->battery_max - dev->battery_min);
+		else
+			ret = -EINVAL;
+		break;
+
+	case POWER_SUPPLY_PROP_MODEL_NAME:
+		val->strval = dev->name;
+		break;
+
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+static void hidinput_setup_battery(struct hid_device *dev, s32 min, s32 max)
+{
+	struct power_supply *battery = &dev->battery;
+	int ret;
+
+	if (battery->name != NULL)
+		return;		/* already initialized? */
+
+	battery->name = kasprintf(GFP_KERNEL, "hid-%s-battery", dev->uniq);
+	if (battery->name == NULL)
+		return;
+
+	battery->type = POWER_SUPPLY_TYPE_BATTERY;
+	battery->properties = hidinput_battery_props;
+	battery->num_properties = ARRAY_SIZE(hidinput_battery_props);
+	battery->use_for_apm = 0;
+	battery->get_property = hidinput_get_battery_property;
+
+	dev->battery_min = min;
+	dev->battery_max = max;
+
+	ret = power_supply_register(&dev->dev, battery);
+	if (ret != 0) {
+		hid_warn(dev, "can't register power supply: %d\n", ret);
+		kfree(battery->name);
+		battery->name = NULL;
+	}
+}
+
+static void hidinput_cleanup_battery(struct hid_device *dev)
+{
+	if (!dev->battery.name)
+		return;
+
+	power_supply_unregister(&dev->battery);
+	kfree(dev->battery.name);
+	dev->battery.name = NULL;
+}
+#else  /* !CONFIG_HID_BATTERY_STRENGTH */
+static void hidinput_setup_battery(struct hid_device *dev, s32 min, s32 max)
+{
+}
+
+static void hidinput_cleanup_battery(struct hid_device *dev)
+{
+}
+#endif	/* CONFIG_HID_BATTERY_STRENGTH */
+
 static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_field *field,
 				     struct hid_usage *usage)
 {
@@ -629,6 +720,16 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 		}
 		break;
 
+	case HID_UP_GENDEVCTRLS:
+		if ((usage->hid & HID_USAGE) == 0x20) {	/* Battery Strength */
+			hidinput_setup_battery(device,
+					       field->logical_minimum,
+					       field->logical_maximum);
+			goto ignore;
+		} else
+			goto unknown;
+		break;
+
 	case HID_UP_HPVENDOR:	/* Reported on a Dutch layout HP5308 */
 		set_bit(EV_REP, input->evbit);
 		switch (usage->hid & HID_USAGE) {
@@ -760,6 +861,13 @@ void hidinput_hid_event(struct hid_device *hid, struct hid_field *field, struct
 
 	input = field->hidinput->input;
 
+	if (usage->hid == HID_DC_BATTERYSTRENGTH) {
+		hid->battery_val = value;
+		hid_dbg(hid, "battery value is %d (range %d-%d)\n",
+			value, hid->battery_min, hid->battery_max);
+		return;
+	}
+
 	if (!usage->type)
 		return;
 
@@ -1016,6 +1124,8 @@ void hidinput_disconnect(struct hid_device *hid)
 {
 	struct hid_input *hidinput, *next;
 
+	hidinput_cleanup_battery(hid);
+
 	list_for_each_entry_safe(hidinput, next, &hid->inputs, list) {
 		list_del(&hidinput->list);
 		input_unregister_device(hidinput->input);

commit b4b583d4e9a5ff28c4a150bb25a4fff5cd4dfbbd
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Mon Oct 31 16:26:22 2011 +0100

    HID: be more strict when ignoring out-of-range fields
    
    HID 1.11 specification, section 5.10 tells us:
    
            HID class devices support the ability to ignore selected fields in a
            report at run- time. This is accomplished by declaring bit field in a
            report that is capable of containing a range of values larger than
            those actually generated by the control. If the host or the device
            receives an out-of-range value then the current value for the
            respective control will not be modified.
    
    So we shouldn't be restricted to EV_ABS only.
    
    Reported-by: Denilson Figueiredo de SÃ¡ <denilsonsa@gmail.com>
    Tested-by: Denilson Figueiredo de SÃ¡ <denilsonsa@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index b7b0d55c0ede..6e3252651ce3 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -822,9 +822,8 @@ void hidinput_hid_event(struct hid_device *hid, struct hid_field *field, struct
 		return;
 	}
 
-	/* Ignore absolute values that are out of bounds */
-	if ((usage->type == EV_ABS && (value < field->logical_minimum ||
-					value > field->logical_maximum))) {
+	/* Ignore out-of-range values as per HID specification, section 5.10 */
+	if (value < field->logical_minimum || value > field->logical_maximum) {
 		dbg_hid("Ignoring out-of-range value %x\n", value);
 		return;
 	}

commit 6da7066906e977d42104a859c490f5f9a300488c
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Fri Oct 28 18:15:02 2011 +0200

    HID: ignore absolute values which don't fit between logical min and max
    
    Linux should ignore values outside logical min/max range, as they are not
    meaningful. This is what at least some of other OSes do, and it also makes
    sense (currently the value gets misinterpreted larger up the stack).
    
    Reported-by: Denilson Figueiredo de SÃ¡ <denilsonsa@gmail.com>
    Tested-by: Denilson Figueiredo de SÃ¡ <denilsonsa@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index f333139d1a48..b7b0d55c0ede 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -822,6 +822,13 @@ void hidinput_hid_event(struct hid_device *hid, struct hid_field *field, struct
 		return;
 	}
 
+	/* Ignore absolute values that are out of bounds */
+	if ((usage->type == EV_ABS && (value < field->logical_minimum ||
+					value > field->logical_maximum))) {
+		dbg_hid("Ignoring out-of-range value %x\n", value);
+		return;
+	}
+
 	/* report the usage code as scancode if the key status has changed */
 	if (usage->type == EV_KEY && !!test_bit(usage->code, input->key) != value)
 		input_event(input, EV_MSC, MSC_SCAN, usage->hid);

commit b77c3920e90e96103e4f41442999402925fe5f73
Author: Benjamin Tissoires <benjamin.tissoires@gmail.com>
Date:   Wed Sep 21 16:56:54 2011 +0200

    HID: add autodetection of multitouch devices
    
    As mentioned by http://www.microsoft.com/whdc/device/input/DigitizerDrvs_touch.mspx
    multitouch devices are those that have the input report HID_CONTACTID.
    
    This patch detects this and unloads the generic-usb driver.
    
    Signed-off-by: Benjamin Tissoires <benjamin.tissoires@enac.fr>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 6559e2e3364e..f333139d1a48 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -474,6 +474,10 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 			map_key_clear(BTN_STYLUS2);
 			break;
 
+		case 0x51: /* ContactID */
+			device->quirks |= HID_QUIRK_MULTITOUCH;
+			goto unknown;
+
 		default:  goto unknown;
 		}
 		break;
@@ -978,6 +982,13 @@ int hidinput_connect(struct hid_device *hid, unsigned int force)
 		}
 	}
 
+	if (hid->quirks & HID_QUIRK_MULTITOUCH) {
+		/* generic hid does not know how to handle multitouch devices */
+		if (hidinput)
+			goto out_cleanup;
+		goto out_unwind;
+	}
+
 	if (hidinput && input_register_device(hidinput->input))
 		goto out_cleanup;
 

commit 437f3b199c437e2a9ac01b9ab733c78e5fc7c720
Author: Jarod Wilson <jarod@redhat.com>
Date:   Tue Apr 19 15:28:30 2011 -0400

    HID: assorted usage updates from hut 1.12
    
    I've got a Tivo Slide bluetooth remote/dongle, which uses a fair number
    of hid usages that aren't currently mapped in hid-input.c. I'd initially
    written additions to hid-input.c with just this device in mind,
    including some bits that were specific to the device. This go around,
    I'm looking at adding/correcting as many generic HID usages from the HID
    Usage Tables, version 1.12, as I can -- which also serves to enable all
    but four of the buttons on the Tivo Slide remote[*].
    
    Outside of fixing the obviously incorrect mapping of 0xc 0x45 from
    KEY_RADIO to KEY_RIGHT, and making use of the new KEY_IMAGES (just added
    in 2.6.39-rc4) for AL Image Browser instead of KEY_MEDIA, these are
    purely additions, and thus should have no negative impact on any already
    functional HID devices. Most of the added mappings seemed to be
    perfectly logical to me, but there were a few that were mapped on more
    of an "I think this makes the most sense" basis.
    
    [*] I'll handle the last four tivo buttons via an hid-tivo.c follow-up.
    
    CC: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    CC: Jiri Kosina <jkosina@suse.cz>
    Signed-off-by: Jarod Wilson <jarod@redhat.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 33dde8724e02..6559e2e3364e 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -44,11 +44,11 @@ static const unsigned char hid_keyboard[256] = {
 	 72, 73, 82, 83, 86,127,116,117,183,184,185,186,187,188,189,190,
 	191,192,193,194,134,138,130,132,128,129,131,137,133,135,136,113,
 	115,114,unk,unk,unk,121,unk, 89, 93,124, 92, 94, 95,unk,unk,unk,
-	122,123, 90, 91, 85,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,
+	122,123, 90, 91, 85,unk,unk,unk,unk,unk,unk,unk,111,unk,unk,unk,
 	unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,
 	unk,unk,unk,unk,unk,unk,179,180,unk,unk,unk,unk,unk,unk,unk,unk,
 	unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,
-	unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,
+	unk,unk,unk,unk,unk,unk,unk,unk,111,unk,unk,unk,unk,unk,unk,unk,
 	 29, 42, 56,125, 97, 54,100,126,164,166,165,163,161,115,114,113,
 	150,158,159,128,136,177,178,176,142,152,173,140,unk,unk,unk,unk
 };
@@ -357,6 +357,18 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 			case 0x1: map_key_clear(KEY_POWER);  break;
 			case 0x2: map_key_clear(KEY_SLEEP);  break;
 			case 0x3: map_key_clear(KEY_WAKEUP); break;
+			case 0x4: map_key_clear(KEY_CONTEXT_MENU); break;
+			case 0x5: map_key_clear(KEY_MENU); break;
+			case 0x6: map_key_clear(KEY_PROG1); break;
+			case 0x7: map_key_clear(KEY_HELP); break;
+			case 0x8: map_key_clear(KEY_EXIT); break;
+			case 0x9: map_key_clear(KEY_SELECT); break;
+			case 0xa: map_key_clear(KEY_RIGHT); break;
+			case 0xb: map_key_clear(KEY_LEFT); break;
+			case 0xc: map_key_clear(KEY_UP); break;
+			case 0xd: map_key_clear(KEY_DOWN); break;
+			case 0xe: map_key_clear(KEY_POWER2); break;
+			case 0xf: map_key_clear(KEY_RESTART); break;
 			default: goto unknown;
 			}
 			break;
@@ -466,16 +478,39 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 		}
 		break;
 
-	case HID_UP_CONSUMER:	/* USB HUT v1.1, pages 56-62 */
+	case HID_UP_CONSUMER:	/* USB HUT v1.12, pages 75-84 */
 		switch (usage->hid & HID_USAGE) {
 		case 0x000: goto ignore;
+		case 0x030: map_key_clear(KEY_POWER);		break;
+		case 0x031: map_key_clear(KEY_RESTART);		break;
+		case 0x032: map_key_clear(KEY_SLEEP);		break;
 		case 0x034: map_key_clear(KEY_SLEEP);		break;
+		case 0x035: map_key_clear(KEY_KBDILLUMTOGGLE);	break;
 		case 0x036: map_key_clear(BTN_MISC);		break;
 
-		case 0x040: map_key_clear(KEY_MENU);		break;
-		case 0x045: map_key_clear(KEY_RADIO);		break;
-
+		case 0x040: map_key_clear(KEY_MENU);		break; /* Menu */
+		case 0x041: map_key_clear(KEY_SELECT);		break; /* Menu Pick */
+		case 0x042: map_key_clear(KEY_UP);		break; /* Menu Up */
+		case 0x043: map_key_clear(KEY_DOWN);		break; /* Menu Down */
+		case 0x044: map_key_clear(KEY_LEFT);		break; /* Menu Left */
+		case 0x045: map_key_clear(KEY_RIGHT);		break; /* Menu Right */
+		case 0x046: map_key_clear(KEY_ESC);		break; /* Menu Escape */
+		case 0x047: map_key_clear(KEY_KPPLUS);		break; /* Menu Value Increase */
+		case 0x048: map_key_clear(KEY_KPMINUS);		break; /* Menu Value Decrease */
+
+		case 0x060: map_key_clear(KEY_INFO);		break; /* Data On Screen */
+		case 0x061: map_key_clear(KEY_SUBTITLE);	break; /* Closed Caption */
+		case 0x063: map_key_clear(KEY_VCR);		break; /* VCR/TV */
+		case 0x065: map_key_clear(KEY_CAMERA);		break; /* Snapshot */
+		case 0x069: map_key_clear(KEY_RED);		break;
+		case 0x06a: map_key_clear(KEY_GREEN);		break;
+		case 0x06b: map_key_clear(KEY_BLUE);		break;
+		case 0x06c: map_key_clear(KEY_YELLOW);		break;
+		case 0x06d: map_key_clear(KEY_ZOOM);		break;
+
+		case 0x082: map_key_clear(KEY_VIDEO_NEXT);	break;
 		case 0x083: map_key_clear(KEY_LAST);		break;
+		case 0x084: map_key_clear(KEY_ENTER);		break;
 		case 0x088: map_key_clear(KEY_PC);		break;
 		case 0x089: map_key_clear(KEY_TV);		break;
 		case 0x08a: map_key_clear(KEY_WWW);		break;
@@ -509,6 +544,8 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 		case 0x0b7: map_key_clear(KEY_STOPCD);		break;
 		case 0x0b8: map_key_clear(KEY_EJECTCD);		break;
 		case 0x0bc: map_key_clear(KEY_MEDIA_REPEAT);	break;
+		case 0x0b9: map_key_clear(KEY_SHUFFLE);		break;
+		case 0x0bf: map_key_clear(KEY_SLOW);		break;
 
 		case 0x0cd: map_key_clear(KEY_PLAYPAUSE);	break;
 		case 0x0e0: map_abs_clear(ABS_VOLUME);		break;
@@ -516,6 +553,7 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 		case 0x0e5: map_key_clear(KEY_BASSBOOST);	break;
 		case 0x0e9: map_key_clear(KEY_VOLUMEUP);	break;
 		case 0x0ea: map_key_clear(KEY_VOLUMEDOWN);	break;
+		case 0x0f5: map_key_clear(KEY_SLOW);		break;
 
 		case 0x182: map_key_clear(KEY_BOOKMARKS);	break;
 		case 0x183: map_key_clear(KEY_CONFIG);		break;
@@ -532,6 +570,7 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 		case 0x18e: map_key_clear(KEY_CALENDAR);	break;
 		case 0x191: map_key_clear(KEY_FINANCE);		break;
 		case 0x192: map_key_clear(KEY_CALC);		break;
+		case 0x193: map_key_clear(KEY_PLAYER);		break;
 		case 0x194: map_key_clear(KEY_FILE);		break;
 		case 0x196: map_key_clear(KEY_WWW);		break;
 		case 0x199: map_key_clear(KEY_CHAT);		break;
@@ -540,8 +579,10 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 		case 0x1a6: map_key_clear(KEY_HELP);		break;
 		case 0x1a7: map_key_clear(KEY_DOCUMENTS);	break;
 		case 0x1ab: map_key_clear(KEY_SPELLCHECK);	break;
-		case 0x1b6: map_key_clear(KEY_MEDIA);		break;
-		case 0x1b7: map_key_clear(KEY_SOUND);		break;
+		case 0x1ae: map_key_clear(KEY_KEYBOARD);	break;
+		case 0x1b6: map_key_clear(KEY_IMAGES);		break;
+		case 0x1b7: map_key_clear(KEY_AUDIO);		break;
+		case 0x1b8: map_key_clear(KEY_VIDEO);		break;
 		case 0x1bc: map_key_clear(KEY_MESSENGER);	break;
 		case 0x1bd: map_key_clear(KEY_INFO);		break;
 		case 0x201: map_key_clear(KEY_NEW);		break;
@@ -570,7 +611,10 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 		case 0x233: map_key_clear(KEY_SCROLLUP);	break;
 		case 0x234: map_key_clear(KEY_SCROLLDOWN);	break;
 		case 0x238: map_rel(REL_HWHEEL);		break;
+		case 0x23d: map_key_clear(KEY_EDIT);		break;
 		case 0x25f: map_key_clear(KEY_CANCEL);		break;
+		case 0x269: map_key_clear(KEY_INSERT);		break;
+		case 0x26a: map_key_clear(KEY_DELETE);		break;
 		case 0x279: map_key_clear(KEY_REDO);		break;
 
 		case 0x289: map_key_clear(KEY_REPLY);		break;

commit a952baa034ae7c2e4a66932005cbc7ebbccfe28d
Merge: 5bab188a3167 97eb3f24352e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Mar 19 22:27:06 2011 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/dtor/input
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/dtor/input: (64 commits)
      Input: tsc2005 - remove 'disable' sysfs attribute
      Input: tsc2005 - add open/close
      Input: tsc2005 - handle read errors from SPI layer
      Input: tsc2005 - do not rearm timer in hardirq handler
      Input: tsc2005 - don't use work for 'pen up' handling
      Input: tsc2005 - do not use 0 in place of NULL
      Input: tsc2005 - use true/false for boolean variables
      Input: tsc2005 - hide selftest attribute if we can't reset
      Input: tsc2005 - rework driver initialization code
      Input: tsc2005 - set up bus type in input device
      Input: tsc2005 - set up parent device
      Input: tsc2005 - clear driver data after unbinding
      Input: tsc2005 - add module description
      Input: tsc2005 - remove driver banner message
      Input: tsc2005 - remove incorrect module alias
      Input: tsc2005 - convert to using dev_pm_ops
      Input: tsc2005 - use spi_get/set_drvdata()
      Input: introduce tsc2005 driver
      Input: xen-kbdfront - move to drivers/input/misc
      Input: xen-kbdfront - add grant reference for shared page
      ...

commit 65b06194c9c9f41bc07ac6a6d42edb4b9e43fea4
Merge: b4a65f4ef59b 0ff1731a1ae5 4875ac114d8b 7b2a64c96ad5 61c29f5b1856 0ae43810976b 5623a24a8081
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Thu Mar 17 14:31:46 2011 +0100

    Merge branches 'dragonrise', 'hidraw-feature', 'multitouch', 'ntrig', 'roccat', 'upstream' and 'upstream-fixes' into for-linus

commit f635bd11c8d332d917fb9a4cad3071b2357d5b2a
Author: Henrik Rydberg <rydberg@euromail.se>
Date:   Thu Feb 24 19:30:59 2011 +0100

    HID: Do not create input devices for feature reports
    
    When the multi input quirk is set, there is a new input device
    created for every feature report. Since the idea is to present
    features per hid device, not per input device, revert back to
    the original report loop and change the feature_mapping() callback
    to not take the input device as argument.
    
    Signed-off-by: Henrik Rydberg <rydberg@euromail.se>
    Tested-by: Benjamin Tissoires <benjmain.tissoires@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 7f552bfad32c..ebcc02a1c1c9 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -290,14 +290,6 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 		goto ignore;
 	}
 
-	if (field->report_type == HID_FEATURE_REPORT) {
-		if (device->driver->feature_mapping) {
-			device->driver->feature_mapping(device, hidinput, field,
-				usage);
-		}
-		goto ignore;
-	}
-
 	if (device->driver->input_mapping) {
 		int ret = device->driver->input_mapping(device, hidinput, field,
 				usage, &bit, &max);
@@ -835,6 +827,24 @@ static void hidinput_close(struct input_dev *dev)
 	hid_hw_close(hid);
 }
 
+static void report_features(struct hid_device *hid)
+{
+	struct hid_driver *drv = hid->driver;
+	struct hid_report_enum *rep_enum;
+	struct hid_report *rep;
+	int i, j;
+
+	if (!drv->feature_mapping)
+		return;
+
+	rep_enum = &hid->report_enum[HID_FEATURE_REPORT];
+	list_for_each_entry(rep, &rep_enum->report_list, list)
+		for (i = 0; i < rep->maxfield; i++)
+			for (j = 0; j < rep->field[i]->maxusage; j++)
+				drv->feature_mapping(hid, rep->field[i],
+						     rep->field[i]->usage + j);
+}
+
 /*
  * Register the input device; print a message.
  * Configure the input layer interface
@@ -863,7 +873,9 @@ int hidinput_connect(struct hid_device *hid, unsigned int force)
 			return -1;
 	}
 
-	for (k = HID_INPUT_REPORT; k <= HID_FEATURE_REPORT; k++) {
+	report_features(hid);
+
+	for (k = HID_INPUT_REPORT; k <= HID_OUTPUT_REPORT; k++) {
 		if (k == HID_OUTPUT_REPORT &&
 			hid->quirks & HID_QUIRK_SKIP_OUTPUT_REPORTS)
 			continue;

commit d9236303d0b7ba8bbaeb6adbbf088c3fe2a9ab9e
Author: Benjamin Tissoires <benjamin.tissoires@enac.fr>
Date:   Tue Feb 15 15:41:10 2011 +0100

    HID: kernel oops in out_cleanup in function hidinput_connect
    
    Goto out_cleanup infers a kernel oops: hidinput_disconnect calls
    input_unregister_driver to all members of hid->inputs.
    However, hidinput already has been added to hid->inputs even
    though input_register_device was not called.
    
    Signed-off-by: Benjamin Tissoires <benjamin.tissoires@enac.fr>
    Reviewed-by: Dmitry Torokhov <dtor@mail.ru>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 7f552bfad32c..f53911dcdc2d 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -928,6 +928,7 @@ int hidinput_connect(struct hid_device *hid, unsigned int force)
 	return 0;
 
 out_cleanup:
+	list_del(&hidinput->list);
 	input_free_device(hidinput->input);
 	kfree(hidinput);
 out_unwind:

commit aebd636bd60e2dda0ebc907dd5f7f4a45174411c
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Mon Jan 31 21:06:39 2011 -0800

    Input: switch completely over to the new versions of get/setkeycode
    
    All users of old style get/setkeycode methids have been converted so
    it is time to retire them.
    
    Acked-by: Mauro Carvalho Chehab <mchehab@redhat.com>
    Acked-by: Jiri Kosina <jkosina@suse.cz>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 7f552bfad32c..ba2aeea2cbf9 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -888,8 +888,8 @@ int hidinput_connect(struct hid_device *hid, unsigned int force)
 					hid->ll_driver->hidinput_input_event;
 				input_dev->open = hidinput_open;
 				input_dev->close = hidinput_close;
-				input_dev->setkeycode_new = hidinput_setkeycode;
-				input_dev->getkeycode_new = hidinput_getkeycode;
+				input_dev->setkeycode = hidinput_setkeycode;
+				input_dev->getkeycode = hidinput_getkeycode;
 
 				input_dev->name = hid->name;
 				input_dev->phys = hid->phys;

commit 8f685fbda43deccd130d192c9fcef1444649eaca
Merge: d24450e2075b 2d93666e7066
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jan 13 09:58:38 2011 -0800

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/hid
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/hid:
      HID: hid-multitouch: minor fixes based on additional review
      HID: Switch turbox/mosart touchscreen to hid-mosart
      HID: add Add Cando touch screen 10.1-inch product id
      HID: hid-mulitouch: add support for the 'Sensing Win7-TwoFinger'
      HID: hid-multitouch: add support for Cypress TrueTouch panels
      HID: hid-multitouch: support for PixCir-based panels
      HID: set HID_MAX_FIELD at 128
      HID: add feature_mapping callback

commit 0d2689c0f054f6a8bf3115d6386bd9c2d65dc44b
Author: Benjamin Tissoires <benjamin.tissoires@enac.fr>
Date:   Fri Jan 7 23:44:32 2011 +0100

    HID: add feature_mapping callback
    
    Currently hid doesn't export the features it knows to the specific modules.
    Some information can be really important in such features: MosArt and
    Cypress devices are by default not in a multitouch mode.
    We have to send the value 2 on the right feature.
    
    This patch exports to the module the features report so they can find the
    right feature to set up the correct mode.
    
    Signed-off-by: Benjamin Tissoires <benjamin.tissoires@enac.fr>
    Acked-by: Henrik Rydberg <rydberg@euromail.se>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index d8d372bae3cc..8703b2cd27ca 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -290,6 +290,14 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 		goto ignore;
 	}
 
+	if (field->report_type == HID_FEATURE_REPORT) {
+		if (device->driver->feature_mapping) {
+			device->driver->feature_mapping(device, hidinput, field,
+				usage);
+		}
+		goto ignore;
+	}
+
 	if (device->driver->input_mapping) {
 		int ret = device->driver->input_mapping(device, hidinput, field,
 				usage, &bit, &max);
@@ -839,7 +847,6 @@ int hidinput_connect(struct hid_device *hid, unsigned int force)
 	struct hid_input *hidinput = NULL;
 	struct input_dev *input_dev;
 	int i, j, k;
-	int max_report_type = HID_OUTPUT_REPORT;
 
 	INIT_LIST_HEAD(&hid->inputs);
 
@@ -856,10 +863,11 @@ int hidinput_connect(struct hid_device *hid, unsigned int force)
 			return -1;
 	}
 
-	if (hid->quirks & HID_QUIRK_SKIP_OUTPUT_REPORTS)
-		max_report_type = HID_INPUT_REPORT;
+	for (k = HID_INPUT_REPORT; k <= HID_FEATURE_REPORT; k++) {
+		if (k == HID_OUTPUT_REPORT &&
+			hid->quirks & HID_QUIRK_SKIP_OUTPUT_REPORTS)
+			continue;
 
-	for (k = HID_INPUT_REPORT; k <= max_report_type; k++)
 		list_for_each_entry(report, &hid->report_enum[k].report_list, list) {
 
 			if (!report->maxfield)
@@ -912,6 +920,7 @@ int hidinput_connect(struct hid_device *hid, unsigned int force)
 				hidinput = NULL;
 			}
 		}
+	}
 
 	if (hidinput && input_register_device(hidinput->input))
 		goto out_cleanup;

commit 1874542d952bbea01997191aee868b472555fd9a
Author: Florian Fainelli <ffainelli@freebox.fr>
Date:   Tue Dec 14 11:56:56 2010 +0100

    HID: replace offsets values with their corresponding BTN_* defines
    
    Instead of using magic values, use their corresponding BTN_* defines
    from linux/input.h.
    
    Signed-off-by: Florian Fainelli <ffainelli@freebox.fr>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index c0757821b1fc..e60fdb88101f 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -319,21 +319,21 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 
 		switch (field->application) {
 		case HID_GD_MOUSE:
-		case HID_GD_POINTER:  code += 0x110; break;
+		case HID_GD_POINTER:  code += BTN_MOUSE; break;
 		case HID_GD_JOYSTICK:
 				if (code <= 0xf)
 					code += BTN_JOYSTICK;
 				else
 					code += BTN_TRIGGER_HAPPY;
 				break;
-		case HID_GD_GAMEPAD:  code += 0x130; break;
+		case HID_GD_GAMEPAD:  code += BTN_GAMEPAD; break;
 		default:
 			switch (field->physical) {
 			case HID_GD_MOUSE:
-			case HID_GD_POINTER:  code += 0x110; break;
-			case HID_GD_JOYSTICK: code += 0x120; break;
-			case HID_GD_GAMEPAD:  code += 0x130; break;
-			default:              code += 0x100;
+			case HID_GD_POINTER:  code += BTN_MOUSE; break;
+			case HID_GD_JOYSTICK: code += BTN_JOYSTICK; break;
+			case HID_GD_GAMEPAD:  code += BTN_GAMEPAD; break;
+			default:              code += BTN_MISC;
 			}
 		}
 

commit 2ade0c1d9d93b7642212657ef76f4a1e30233711
Merge: 504499f22c08 6313e3c21743
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Fri Dec 10 15:19:18 2010 +0100

    Merge branch 'master' into upstream

commit 4291ee305e9bb0699504a66f0e2b7aefcf0512a5
Author: Joe Perches <joe@perches.com>
Date:   Thu Dec 9 19:29:03 2010 -0800

    HID: Add and use hid_<level>: dev_<level> equivalents
    
    Neaten current uses of dev_<level> by adding and using
    hid specific hid_<level> macros.
    
    Convert existing uses of dev_<level> uses to hid_<level>.
    Convert hid-pidff printk uses to hid_<level>.
    
    Remove err_hid and use hid_err instead.
    
    Add missing newlines to logging messages where necessary.
    Coalesce format strings.
    
    Add and use pr_fmt(fmt) KBUILD_MODNAME ": " fmt
    
    Other miscellaneous changes:
    
    Add const struct hid_device * argument to hid-core functions
    extract() and implement() so hid_<level> can be used by them.
    Fix bad indentation in hid-core hid_input_field function
    that calls extract() function above.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index b718f7144ce1..a1a2206714fc 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -826,7 +826,7 @@ int hidinput_connect(struct hid_device *hid, unsigned int force)
 				if (!hidinput || !input_dev) {
 					kfree(hidinput);
 					input_free_device(input_dev);
-					err_hid("Out of memory during hid input probe");
+					hid_err(hid, "Out of memory during hid input probe\n");
 					goto out_unwind;
 				}
 

commit 5bea7660bba973dc5e8e9d92b11fb1dd5b524ebf
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Tue Dec 7 23:02:48 2010 -0800

    HID: add hid_hw_open/close/power() handlers
    
    Instead of exposing the guts of hid->ll_driver relationship to HID
    sub-drivers provide these helpers to encapsulate the details.
    
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 834ef47b76d6..b718f7144ce1 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -772,14 +772,14 @@ static int hidinput_open(struct input_dev *dev)
 {
 	struct hid_device *hid = input_get_drvdata(dev);
 
-	return hid->ll_driver->open(hid);
+	return hid_hw_open(hid);
 }
 
 static void hidinput_close(struct input_dev *dev)
 {
 	struct hid_device *hid = input_get_drvdata(dev);
 
-	hid->ll_driver->close(hid);
+	hid_hw_close(hid);
 }
 
 /*

commit 59e57c622c3502346e8f930421ebc482d639520c
Merge: 33dd94ae1ccb 83ed79c561da
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Dec 2 17:40:04 2010 -0800

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/hid
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/hid:
      HID: length resolution should be reported units/mm
      HID: add support for F430 Force Feedback Wheel
      HID: egalax: Use kzalloc
      HID: Remove KERN_DEBUG from dbg_hid use
    
    Manually fixed trivial conflict in drivers/hid/hid-input.c (due to
    removal of KERN_DEBUG from dbg_hid use clashing with new keycode
    interface switch)

commit 83ed79c561da20019cb24944f535530d73b2d615
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Thu Dec 2 11:49:06 2010 +0100

    HID: length resolution should be reported units/mm
    
    Input ABI requires reporting resolution on main axes in units per
    millimeter, not units per inch, so we need to convert accordingly.
    
    Tested-by: Nikolai Kondrashov <spbnick@gmail.com>
    Acked-by: Nikolai Kondrashov <spbnick@gmail.com>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 76e1f64e9765..30af8760174b 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -162,8 +162,8 @@ static int hidinput_setkeycode(struct input_dev *dev,
  *
  * as seen in the HID specification v1.11 6.2.2.7 Global Items.
  *
- * Only exponent 1 length units are processed. Centimeters are converted to
- * inches. Degrees are converted to radians.
+ * Only exponent 1 length units are processed. Centimeters and inches are
+ * converted to millimeters. Degrees are converted to radians.
  */
 static __s32 hidinput_calc_abs_res(const struct hid_field *field, __u16 code)
 {
@@ -184,13 +184,16 @@ static __s32 hidinput_calc_abs_res(const struct hid_field *field, __u16 code)
 	 */
 	if (code == ABS_X || code == ABS_Y || code == ABS_Z) {
 		if (field->unit == 0x11) {		/* If centimeters */
-			/* Convert to inches */
-			prev = logical_extents;
-			logical_extents *= 254;
-			if (logical_extents < prev)
+			/* Convert to millimeters */
+			unit_exponent += 1;
+		} else if (field->unit == 0x13) {	/* If inches */
+			/* Convert to millimeters */
+			prev = physical_extents;
+			physical_extents *= 254;
+			if (physical_extents < prev)
 				return 0;
-			unit_exponent += 2;
-		} else if (field->unit != 0x13) {	/* If not inches */
+			unit_exponent -= 1;
+		} else {
 			return 0;
 		}
 	} else if (code == ABS_RX || code == ABS_RY || code == ABS_RZ) {

commit 587d145200f26758940099fbbc301fdd43d3f391
Author: Joe Perches <joe@perches.com>
Date:   Mon Oct 25 19:44:21 2010 -0700

    HID: Remove KERN_DEBUG from dbg_hid use
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 834ef47b76d6..76e1f64e9765 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -136,7 +136,8 @@ static int hidinput_setkeycode(struct input_dev *dev,
 
 		clear_bit(old_keycode, dev->keybit);
 		set_bit(usage->code, dev->keybit);
-		dbg_hid(KERN_DEBUG "Assigned keycode %d to HID usage code %x\n", keycode, scancode);
+		dbg_hid("Assigned keycode %d to HID usage code %x\n",
+				keycode, scancode);
 		/* Set the keybit for the old keycode if the old keycode is used
 		 * by another key */
 		if (hidinput_find_key (hid, 0, old_keycode))

commit 3a99c6319064af3f2e18eb929f638d555dbf7a62
Merge: 1dfd166e93f9 49327ad2bbba
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Oct 25 07:59:01 2010 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/dtor/input
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/dtor/input: (75 commits)
      Input: wacom - specify Cinitq supported tools
      Input: ab8500-ponkey - fix IRQ freeing in error path
      Input: adp5588-keys - use more obvious i2c_device_id name string
      Input: ad7877 - switch to using threaded IRQ
      Input: ad7877 - use attribute group to control visibility of attributes
      Input: serio - add support for PS2Mult multiplexer protocol
      Input: wacom - properly enable runtime PM
      Input: ad7877 - filter events where pressure is beyond the maximum
      Input: ad7877 - implement EV_KEY:BTN_TOUCH reporting
      Input: ad7877 - implement specified chip select behavior
      Input: hp680_ts_input - use cancel_delayed_work_sync()
      Input: mousedev - correct lockdep annotation
      Input: ads7846 - switch to using threaded IRQ
      Input: serio - support multiple child devices per single parent
      Input: synaptics - simplify pass-through port handling
      Input: add ROHM BU21013 touch panel controller support
      Input: omap4-keypad - wake-up on events & long presses
      Input: omap4-keypad - fix interrupt line configuration
      Input: omap4-keypad - SYSCONFIG register configuration
      Input: omap4-keypad - use platform device helpers
      ...

commit 8b66a16f25f819bb1f132f075c5c01a288776cf8
Merge: bbd128b5acae 41fa92302be7
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Sat Oct 23 22:49:32 2010 +0200

    Merge branch 'uc-logic' into for-linus
    
    Conflicts:
            drivers/hid/hid-ids.h
            drivers/hid/hid-lg.c
            drivers/hid/usbhid/hid-quirks.c

commit bbd128b5acae85b2ef346e95cc5a729ac5252f19
Merge: c3d9d74336c1 48216fbdad6c f51661105c3c 2c6118e43040 921990b7046a 0277873c0515 d2b570a5d451
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Sat Oct 23 22:47:38 2010 +0200

    Merge branches '3m', 'egalax', 'logitech', 'magicmouse', 'ntrig' and 'roccat' into for-linus

commit 4ea6e4ffb4acdaaf9ba7687dbd84ae36e26cef9e
Author: Nikolai Kondrashov <spbnick@gmail.com>
Date:   Wed Sep 15 14:51:14 2010 +0400

    HID: add absolute axis resolution calculation
    
    Add absolute axis resolution calculation to the core HID layer, according to HID
    specification v1.11 6.2.2.7 Global Items. Only exponent 1 length units for
    X/Y/Z/RX/RY/RZ axis are supported for now.
    
    Signed-off-by: Nikolai Kondrashov <spbnick@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 6c03dcc5760a..8e733b6eae27 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -149,6 +149,83 @@ static int hidinput_setkeycode(struct input_dev *dev,
 }
 
 
+/**
+ * hidinput_calc_abs_res - calculate an absolute axis resolution
+ * @field: the HID report field to calculate resolution for
+ * @code: axis code
+ *
+ * The formula is:
+ *                         (logical_maximum - logical_minimum)
+ * resolution = ----------------------------------------------------------
+ *              (physical_maximum - physical_minimum) * 10 ^ unit_exponent
+ *
+ * as seen in the HID specification v1.11 6.2.2.7 Global Items.
+ *
+ * Only exponent 1 length units are processed. Centimeters are converted to
+ * inches. Degrees are converted to radians.
+ */
+static __s32 hidinput_calc_abs_res(const struct hid_field *field, __u16 code)
+{
+	__s32 unit_exponent = field->unit_exponent;
+	__s32 logical_extents = field->logical_maximum -
+					field->logical_minimum;
+	__s32 physical_extents = field->physical_maximum -
+					field->physical_minimum;
+	__s32 prev;
+
+	/* Check if the extents are sane */
+	if (logical_extents <= 0 || physical_extents <= 0)
+		return 0;
+
+	/*
+	 * Verify and convert units.
+	 * See HID specification v1.11 6.2.2.7 Global Items for unit decoding
+	 */
+	if (code == ABS_X || code == ABS_Y || code == ABS_Z) {
+		if (field->unit == 0x11) {		/* If centimeters */
+			/* Convert to inches */
+			prev = logical_extents;
+			logical_extents *= 254;
+			if (logical_extents < prev)
+				return 0;
+			unit_exponent += 2;
+		} else if (field->unit != 0x13) {	/* If not inches */
+			return 0;
+		}
+	} else if (code == ABS_RX || code == ABS_RY || code == ABS_RZ) {
+		if (field->unit == 0x14) {		/* If degrees */
+			/* Convert to radians */
+			prev = logical_extents;
+			logical_extents *= 573;
+			if (logical_extents < prev)
+				return 0;
+			unit_exponent += 1;
+		} else if (field->unit != 0x12) {	/* If not radians */
+			return 0;
+		}
+	} else {
+		return 0;
+	}
+
+	/* Apply negative unit exponent */
+	for (; unit_exponent < 0; unit_exponent++) {
+		prev = logical_extents;
+		logical_extents *= 10;
+		if (logical_extents < prev)
+			return 0;
+	}
+	/* Apply positive unit exponent */
+	for (; unit_exponent > 0; unit_exponent--) {
+		prev = physical_extents;
+		physical_extents *= 10;
+		if (physical_extents < prev)
+			return 0;
+	}
+
+	/* Calculate resolution */
+	return logical_extents / physical_extents;
+}
+
 static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_field *field,
 				     struct hid_usage *usage)
 {
@@ -537,6 +614,9 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 			input_set_abs_params(input, usage->code, a, b, (b - a) >> 8, (b - a) >> 4);
 		else	input_set_abs_params(input, usage->code, a, b, 0, 0);
 
+		input_abs_set_res(input, usage->code,
+				  hidinput_calc_abs_res(field, usage->code));
+
 		/* use a larger default input buffer for MT devices */
 		if (usage->code == ABS_MT_POSITION_X && input->hint_events_per_packet == 0)
 			input_set_events_per_packet(input, 60);

commit 24750f3e469bef81a96c0036cd4700df5fb48925
Author: Henrik Rydberg <rydberg@thabit.(none)>
Date:   Tue Aug 24 10:54:44 2010 +0200

    HID: Add a hid quirk for input sync override
    
    As of lately, HID devices which send per-frame data split over several
    HID reports have started to emerge. This patch adds a quirk which
    allows the HID driver to take over the input layer synchronization,
    and hence the control of the frame boundary.
    
    Signed-off-by: Henrik Rydberg <rydberg@euromail.se>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 6c03dcc5760a..b186f6d0feba 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -659,6 +659,9 @@ void hidinput_report_event(struct hid_device *hid, struct hid_report *report)
 {
 	struct hid_input *hidinput;
 
+	if (hid->quirks & HID_QUIRK_NO_INPUT_SYNC)
+		return;
+
 	list_for_each_entry(hidinput, &hid->inputs, list)
 		input_sync(hidinput->input);
 }

commit f5854fad395b93071292bff27c0121b6e32215e0
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Wed Sep 15 19:36:56 2010 -0700

    Input: hid-input - allow mapping unknown usages
    
    Currently HID layer only allows to remap keycodes for known usages,
    and responds with -EINVAL when user tries to map new usage code.
    This precludes us form relying on udev/keymap for establishing correct
    mappings and forces us to write dummy HID drivers responsible only for
    setting up keymaps.
    
    Let's allow remapping not only usages that have been set up as keys
    (usage->type == EV_KEY) but also yet-unmapped usages (usage->type == 0).
    
    Acked-by: Jarod Wilson <jarod@redhat.com>
    Acked-by: Jiri Kosina <jkosina@suse.cz>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index b12c07e64fbd..04121beed358 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -77,7 +77,10 @@ static bool match_scancode(struct hid_usage *usage,
 static bool match_keycode(struct hid_usage *usage,
 			  unsigned int cur_idx, unsigned int keycode)
 {
-	return usage->code == keycode;
+	/*
+	 * We should exclude unmapped usages when doing lookup by keycode.
+	 */
+	return (usage->type == EV_KEY && usage->code == keycode);
 }
 
 static bool match_index(struct hid_usage *usage,
@@ -103,7 +106,7 @@ static struct hid_usage *hidinput_find_key(struct hid_device *hid,
 			for (i = 0; i < report->maxfield; i++) {
 				for (j = 0; j < report->field[i]->maxusage; j++) {
 					usage = report->field[i]->usage + j;
-					if (usage->type == EV_KEY) {
+					if (usage->type == EV_KEY || usage->type == 0) {
 						if (match(usage, cur_idx, value)) {
 							if (usage_idx)
 								*usage_idx = cur_idx;
@@ -144,7 +147,8 @@ static int hidinput_getkeycode(struct input_dev *dev,
 
 	usage = hidinput_locate_usage(hid, ke, &index);
 	if (usage) {
-		ke->keycode = usage->code;
+		ke->keycode = usage->type == EV_KEY ?
+				usage->code : KEY_RESERVED;
 		ke->index = index;
 		scancode = usage->hid & (HID_USAGE_PAGE | HID_USAGE);
 		ke->len = sizeof(scancode);
@@ -164,7 +168,8 @@ static int hidinput_setkeycode(struct input_dev *dev,
 
 	usage = hidinput_locate_usage(hid, ke, NULL);
 	if (usage) {
-		*old_keycode = usage->code;
+		*old_keycode = usage->type == EV_KEY ?
+				usage->code : KEY_RESERVED;
 		usage->code = ke->keycode;
 
 		clear_bit(*old_keycode, dev->keybit);

commit a0bf0ea809ba0a7621e191ec4cab5775d502ef7e
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Thu Sep 9 21:57:17 2010 -0700

    Input: hid-input - switch to using new keycode interface
    
    Switch HID code to use new style of getkeycode and setkeycode
    methods to allow retrieving and setting keycodes not only by
    their scancodes but also by index.
    
    Acked-by: Jiri Kosina <jkosina@suse.cz>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 6c03dcc5760a..b12c07e64fbd 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -68,39 +68,49 @@ static const struct {
 #define map_key_clear(c)	hid_map_usage_clear(hidinput, usage, &bit, \
 		&max, EV_KEY, (c))
 
-static inline int match_scancode(unsigned int code, unsigned int scancode)
+static bool match_scancode(struct hid_usage *usage,
+			   unsigned int cur_idx, unsigned int scancode)
 {
-	if (scancode == 0)
-		return 1;
-
-	return (code & (HID_USAGE_PAGE | HID_USAGE)) == scancode;
+	return (usage->hid & (HID_USAGE_PAGE | HID_USAGE)) == scancode;
 }
 
-static inline int match_keycode(unsigned int code, unsigned int keycode)
+static bool match_keycode(struct hid_usage *usage,
+			  unsigned int cur_idx, unsigned int keycode)
 {
-	if (keycode == 0)
-		return 1;
+	return usage->code == keycode;
+}
 
-	return code == keycode;
+static bool match_index(struct hid_usage *usage,
+			unsigned int cur_idx, unsigned int idx)
+{
+	return cur_idx == idx;
 }
 
+typedef bool (*hid_usage_cmp_t)(struct hid_usage *usage,
+				unsigned int cur_idx, unsigned int val);
+
 static struct hid_usage *hidinput_find_key(struct hid_device *hid,
-					   unsigned int scancode,
-					   unsigned int keycode)
+					   hid_usage_cmp_t match,
+					   unsigned int value,
+					   unsigned int *usage_idx)
 {
-	int i, j, k;
+	unsigned int i, j, k, cur_idx = 0;
 	struct hid_report *report;
 	struct hid_usage *usage;
 
 	for (k = HID_INPUT_REPORT; k <= HID_OUTPUT_REPORT; k++) {
 		list_for_each_entry(report, &hid->report_enum[k].report_list, list) {
 			for (i = 0; i < report->maxfield; i++) {
-				for ( j = 0; j < report->field[i]->maxusage; j++) {
+				for (j = 0; j < report->field[i]->maxusage; j++) {
 					usage = report->field[i]->usage + j;
-					if (usage->type == EV_KEY &&
-						match_scancode(usage->hid, scancode) &&
-						match_keycode(usage->code, keycode))
-						return usage;
+					if (usage->type == EV_KEY) {
+						if (match(usage, cur_idx, value)) {
+							if (usage_idx)
+								*usage_idx = cur_idx;
+							return usage;
+						}
+						cur_idx++;
+					}
 				}
 			}
 		}
@@ -108,39 +118,66 @@ static struct hid_usage *hidinput_find_key(struct hid_device *hid,
 	return NULL;
 }
 
+static struct hid_usage *hidinput_locate_usage(struct hid_device *hid,
+					const struct input_keymap_entry *ke,
+					unsigned int *index)
+{
+	struct hid_usage *usage;
+	unsigned int scancode;
+
+	if (ke->flags & INPUT_KEYMAP_BY_INDEX)
+		usage = hidinput_find_key(hid, match_index, ke->index, index);
+	else if (input_scancode_to_scalar(ke, &scancode) == 0)
+		usage = hidinput_find_key(hid, match_scancode, scancode, index);
+	else
+		usage = NULL;
+
+	return usage;
+}
+
 static int hidinput_getkeycode(struct input_dev *dev,
-			       unsigned int scancode, unsigned int *keycode)
+			       struct input_keymap_entry *ke)
 {
 	struct hid_device *hid = input_get_drvdata(dev);
 	struct hid_usage *usage;
+	unsigned int scancode, index;
 
-	usage = hidinput_find_key(hid, scancode, 0);
+	usage = hidinput_locate_usage(hid, ke, &index);
 	if (usage) {
-		*keycode = usage->code;
+		ke->keycode = usage->code;
+		ke->index = index;
+		scancode = usage->hid & (HID_USAGE_PAGE | HID_USAGE);
+		ke->len = sizeof(scancode);
+		memcpy(ke->scancode, &scancode, sizeof(scancode));
 		return 0;
 	}
+
 	return -EINVAL;
 }
 
 static int hidinput_setkeycode(struct input_dev *dev,
-			       unsigned int scancode, unsigned int keycode)
+			       const struct input_keymap_entry *ke,
+			       unsigned int *old_keycode)
 {
 	struct hid_device *hid = input_get_drvdata(dev);
 	struct hid_usage *usage;
-	int old_keycode;
 
-	usage = hidinput_find_key(hid, scancode, 0);
+	usage = hidinput_locate_usage(hid, ke, NULL);
 	if (usage) {
-		old_keycode = usage->code;
-		usage->code = keycode;
+		*old_keycode = usage->code;
+		usage->code = ke->keycode;
 
-		clear_bit(old_keycode, dev->keybit);
+		clear_bit(*old_keycode, dev->keybit);
 		set_bit(usage->code, dev->keybit);
-		dbg_hid(KERN_DEBUG "Assigned keycode %d to HID usage code %x\n", keycode, scancode);
-		/* Set the keybit for the old keycode if the old keycode is used
-		 * by another key */
-		if (hidinput_find_key (hid, 0, old_keycode))
-			set_bit(old_keycode, dev->keybit);
+		dbg_hid(KERN_DEBUG "Assigned keycode %d to HID usage code %x\n",
+			usage->code, usage->hid);
+
+		/*
+		 * Set the keybit for the old keycode if the old keycode is used
+		 * by another key
+		 */
+		if (hidinput_find_key(hid, match_keycode, *old_keycode, NULL))
+			set_bit(*old_keycode, dev->keybit);
 
 		return 0;
 	}
@@ -748,8 +785,8 @@ int hidinput_connect(struct hid_device *hid, unsigned int force)
 					hid->ll_driver->hidinput_input_event;
 				input_dev->open = hidinput_open;
 				input_dev->close = hidinput_close;
-				input_dev->setkeycode = hidinput_setkeycode;
-				input_dev->getkeycode = hidinput_getkeycode;
+				input_dev->setkeycode_new = hidinput_setkeycode;
+				input_dev->getkeycode_new = hidinput_getkeycode;
 
 				input_dev->name = hid->name;
 				input_dev->phys = hid->phys;

commit 50b6369767f65c39de3d7ca17842ebc6c52888b8
Author: Nikolai Kondrashov <spbnick@gmail.com>
Date:   Fri Aug 6 23:03:07 2010 +0400

    HID: Add Tablet Pick -> BTN_STYLUS2 mapping
    
    Many tablet input drivers use BTN_STYLUS2 code to report a second
    tablet stylus button. Yet, the generic HID input driver doesn't map it.
    Apparently, because there is no corresponding usage in the HID Usage Tables.
    
    This patch selects a compromise usage - "Tablet Pick" (0x46) to be mapped to
    BTN_STYLUS2. Some tablets use "Eraser" usage, but mapping it to a button
    wouldn't be entirely correct, because the specification says it may be "a
    pressure quantity".
    
    Signed-off-by: Nikolai Kondrashov <spbnick@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 6c03dcc5760a..0c2908f2dbe3 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -336,6 +336,10 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 			map_key_clear(BTN_STYLUS);
 			break;
 
+		case 0x46: /* TabletPick */
+			map_key_clear(BTN_STYLUS2);
+			break;
+
 		default:  goto unknown;
 		}
 		break;

commit 5cf65713f87775c548e3eb48dbafa32e12f28000
Merge: b7c8e55db714 9f17d516416c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Aug 4 15:23:49 2010 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/hid
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/hid: (30 commits)
      Revert "HID: add support for the Wacom Intuos 4 wireless"
      HID: fix up Kconfig entry for ACRUX driver
      HID: add ACRUX game controller force feedback support
      HID: Force input registration for "VEC footpedal"
      HID: add HID_QUIRK_HIDINPUT_FORCE
      HID: hid-input.c: indentation fixes
      HID: hiddev: use usb_find_interface, get rid of BKL
      HID: ignore digitizer usage Undefined (0x00)
      HID: Add support for Conceptronic CLLRCMCE
      HID: hid-ids.h: Whitespace fixup, align using TABs
      HID: picolcd: implement refcounting of framebuffer
      HID: picolcd: do not reallocate memory on depth change
      HID: picolcd: Add minimal palette required by fbcon on 8bpp
      HID: magicmouse: Correct parsing of large X and Y motions.
      HID: magicmouse: report last touch up
      HID: picolcd: fix deferred_io init/cleanup to fb ordering
      HID: hid-ids.h: keep vendor ids in alphabetical order
      HID: add proper support for Elecom BM084 bluetooth mouse
      HID: magicmouse: enable horizontal scrolling
      HID: magicmouse: add param for scroll speed
      ...

commit ada8c7973b65865cf0436b73898e32992860012a
Merge: 35d03a0d9b22 7d876c05fa6c 0b3fa399bef0 70c7c9c4438f
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Wed Aug 4 15:31:13 2010 +0200

    Merge branches 'magicmouse', 'roccat' and 'vec-pedal' into for-linus
    
    Conflicts:
            drivers/hid/hid-ids.h

commit fc99f22c5de2177431cada350417ac6e353380c7
Author: Daniel Mack <daniel@caiaq.de>
Date:   Mon Jul 12 19:28:26 2010 +0200

    HID: hid-input.c: indentation fixes
    
    Signed-off-by: Daniel Mack <daniel@caiaq.de>
    Cc: Jiri Kosina <jkosina@suse.cz>
    Cc: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 7a0d2e4661a1..36c214877f77 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -199,11 +199,11 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 		case HID_GD_MOUSE:
 		case HID_GD_POINTER:  code += 0x110; break;
 		case HID_GD_JOYSTICK:
-				      if (code <= 0xf)
-					      code += BTN_JOYSTICK;
-				      else
-					      code += BTN_TRIGGER_HAPPY;
-				      break;
+				if (code <= 0xf)
+					code += BTN_JOYSTICK;
+				else
+					code += BTN_TRIGGER_HAPPY;
+				break;
 		case HID_GD_GAMEPAD:  code += 0x130; break;
 		default:
 			switch (field->physical) {
@@ -480,7 +480,7 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 
 	case HID_UP_LOGIVENDOR:
 		goto ignore;
-	
+
 	case HID_UP_PID:
 		switch (usage->hid & HID_USAGE) {
 		case 0xa4: map_key_clear(BTN_DEAD);	break;
@@ -586,9 +586,9 @@ void hidinput_hid_event(struct hid_device *hid, struct hid_field *field, struct
 			hat_dir = (value - usage->hat_min) * 8 / (usage->hat_max - usage->hat_min + 1) + 1;
 		if (hat_dir < 0 || hat_dir > 8) hat_dir = 0;
 		input_event(input, usage->type, usage->code    , hid_hat_to_axis[hat_dir].x);
-                input_event(input, usage->type, usage->code + 1, hid_hat_to_axis[hat_dir].y);
-                return;
-        }
+		input_event(input, usage->type, usage->code + 1, hid_hat_to_axis[hat_dir].y);
+		return;
+	}
 
 	if (usage->hid == (HID_UP_DIGITIZER | 0x003c)) { /* Invert */
 		*quirks = value ? (*quirks | HID_QUIRK_INVERT) : (*quirks & ~HID_QUIRK_INVERT);

commit 8c8b01c38a70661d663175d355fdea85ca082272
Author: Forest Bond <forest@alittletooquiet.net>
Date:   Tue Jul 13 23:50:57 2010 +0200

    HID: ignore digitizer usage Undefined (0x00)
    
    SMART Technologies has recommended this change to fix a problem reported
    with SMART Board series interactive whiteboards.
    
    A description of the device-specific symptom follows:
    
      When the board is connected my mouse bounces up to the top left corner.
    
    Bjorn has tested this fix with model SB680.
    
    Tested-by: Bjorn Behrendt <bbehrendt@msjvermont.org>
    Signed-off-by: Forest Bond <forest@alittletooquiet.net>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 7a0d2e4661a1..6b10e5afe770 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -301,6 +301,9 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 
 	case HID_UP_DIGITIZER:
 		switch (usage->hid & 0xff) {
+		case 0x00: /* Undefined */
+			goto ignore;
+
 		case 0x30: /* TipPressure */
 			if (!test_bit(BTN_TOUCH, input->keybit)) {
 				device->quirks |= HID_QUIRK_NOTOUCH;

commit 6967b4d9de4a7cf3b00cd9a93981d3206d75a1d8
Author: Henrik Rydberg <rydberg@euromail.se>
Date:   Wed Jun 23 09:31:37 2010 -0700

    Input: hid-input - use a larger event buffer for MT devices
    
    The MT devices produce a lot of data. Tell the underlying input device
    approximately how many events will be sent per synchronization, to allow
    for better buffering. The number is a template based on continuously
    reporting details for each finger on a single hand.
    
    Signed-off-by: Henrik Rydberg <rydberg@euromail.se>
    Acked-by: Jiri Kosina <jkosina@suse.cz>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 7a0d2e4661a1..69d152e16a6a 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -534,6 +534,9 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 			input_set_abs_params(input, usage->code, a, b, (b - a) >> 8, (b - a) >> 4);
 		else	input_set_abs_params(input, usage->code, a, b, 0, 0);
 
+		/* use a larger default input buffer for MT devices */
+		if (usage->code == ABS_MT_POSITION_X && input->hint_events_per_packet == 0)
+			input_set_events_per_packet(input, 60);
 	}
 
 	if (usage->type == EV_ABS &&

commit 58b939959d228681208ba997595411fddc860849
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Mon Mar 8 22:37:10 2010 -0800

    Input: scancode in get/set_keycodes should be unsigned
    
    The HID layer has some scan codes of the form 0xffbc0000 for logitech
    devices which do not work if scancode is typed as signed int, so we need
    to switch to unsigned it instead. While at it keycode being signed does
    not make much sense either.
    
    Acked-by: MÃ¡rton NÃ©meth <nm127@freemail.hu>
    Acked-by: Matthew Garrett <mjg@redhat.com>
    Acked-by: Jiri Kosina <jkosina@suse.cz>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 79d9edd0bdfa..7a0d2e4661a1 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -68,22 +68,25 @@ static const struct {
 #define map_key_clear(c)	hid_map_usage_clear(hidinput, usage, &bit, \
 		&max, EV_KEY, (c))
 
-static inline int match_scancode(int code, int scancode)
+static inline int match_scancode(unsigned int code, unsigned int scancode)
 {
 	if (scancode == 0)
 		return 1;
-	return ((code & (HID_USAGE_PAGE | HID_USAGE)) == scancode);
+
+	return (code & (HID_USAGE_PAGE | HID_USAGE)) == scancode;
 }
 
-static inline int match_keycode(int code, int keycode)
+static inline int match_keycode(unsigned int code, unsigned int keycode)
 {
 	if (keycode == 0)
 		return 1;
-	return (code == keycode);
+
+	return code == keycode;
 }
 
 static struct hid_usage *hidinput_find_key(struct hid_device *hid,
-		int scancode, int keycode)
+					   unsigned int scancode,
+					   unsigned int keycode)
 {
 	int i, j, k;
 	struct hid_report *report;
@@ -105,8 +108,8 @@ static struct hid_usage *hidinput_find_key(struct hid_device *hid,
 	return NULL;
 }
 
-static int hidinput_getkeycode(struct input_dev *dev, int scancode,
-				int *keycode)
+static int hidinput_getkeycode(struct input_dev *dev,
+			       unsigned int scancode, unsigned int *keycode)
 {
 	struct hid_device *hid = input_get_drvdata(dev);
 	struct hid_usage *usage;
@@ -119,16 +122,13 @@ static int hidinput_getkeycode(struct input_dev *dev, int scancode,
 	return -EINVAL;
 }
 
-static int hidinput_setkeycode(struct input_dev *dev, int scancode,
-				int keycode)
+static int hidinput_setkeycode(struct input_dev *dev,
+			       unsigned int scancode, unsigned int keycode)
 {
 	struct hid_device *hid = input_get_drvdata(dev);
 	struct hid_usage *usage;
 	int old_keycode;
 
-	if (keycode < 0 || keycode > KEY_MAX)
-		return -EINVAL;
-
 	usage = hidinput_find_key(hid, scancode, 0);
 	if (usage) {
 		old_keycode = usage->code;

commit 7f978b9bf535cbbd1ae8d9fbdd7c4f60ab38f260
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Wed Feb 17 09:36:35 2010 +0100

    HID: extend mask for BUTTON usage page
    
    Now that joystick button usages can expand over 15 buttons, we
    have to properly mask out the code from hid usage to cover the
    whole 0xffff available space.
    
    Reported-by: Stefan Bader <stefan.bader@canonical.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index a01a1b0de1c3..79d9edd0bdfa 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -193,7 +193,7 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 		break;
 
 	case HID_UP_BUTTON:
-		code = ((usage->hid - 1) & 0xf);
+		code = ((usage->hid - 1) & HID_USAGE);
 
 		switch (field->application) {
 		case HID_GD_MOUSE:

commit 0690535d6bcec5eb28573824df5c8a49ec85b696
Author: Leo P White <lpw25@cam.ac.uk>
Date:   Mon Feb 8 13:02:05 2010 +0000

    HID: add mapping for "AL Network Chat" usage
    
    Adding a mapping for the 'AL Network Chat' usage from the 'Consumer' usage
    page (USB HID Usage Tables v1.11). This usage is used by some keyboards for
    a multimedia key.
    
    Signed-off-by: Leo P White <lpw25@cam.ac.uk>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 8430d626511c..a01a1b0de1c3 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -405,6 +405,7 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 		case 0x192: map_key_clear(KEY_CALC);		break;
 		case 0x194: map_key_clear(KEY_FILE);		break;
 		case 0x196: map_key_clear(KEY_WWW);		break;
+		case 0x199: map_key_clear(KEY_CHAT);		break;
 		case 0x19c: map_key_clear(KEY_LOGOFF);		break;
 		case 0x19e: map_key_clear(KEY_COFFEE);		break;
 		case 0x1a6: map_key_clear(KEY_HELP);		break;

commit 7d39e849912f0c3c8c6fc94be7bf7d120b1ee0ba
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Tue Feb 2 20:46:34 2010 +0100

    HID: update copyright
    
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index dad7aae9c975..8430d626511c 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -1,6 +1,6 @@
 /*
  *  Copyright (c) 2000-2001 Vojtech Pavlik
- *  Copyright (c) 2006-2007 Jiri Kosina
+ *  Copyright (c) 2006-2010 Jiri Kosina
  *
  *  HID to Linux Input mapping
  */

commit cf2f765f1896064e34c6f0f2ef896ff058dd5c06
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Mon Jan 4 12:20:56 2010 +0100

    HID: handle joysticks with large number of buttons
    
    Current HID code doesn't properly handle HID joysticks which have
    larger number of buttons than what fits into current range reserved
    for BTN_JOYSTICK.
    
    One such joystick reported to not work properly is Saitek X52 Pro
    Flight System.
    
    We can't extend the range to fit more buttons in, because of backwards
    compatibility reasons.
    
    Therefore this patch introduces a new BTN_TRIGGER_HAPPY range, and
    uses these to map the buttons which are over BTN_JOYSTICK limit.
    
    Acked-by: Dmitry Torokhov <dmitry.torokhov@gmail.com> [for the input.h part]
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 5862b0f3b55d..dad7aae9c975 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -198,7 +198,12 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 		switch (field->application) {
 		case HID_GD_MOUSE:
 		case HID_GD_POINTER:  code += 0x110; break;
-		case HID_GD_JOYSTICK: code += 0x120; break;
+		case HID_GD_JOYSTICK:
+				      if (code <= 0xf)
+					      code += BTN_JOYSTICK;
+				      else
+					      code += BTN_TRIGGER_HAPPY;
+				      break;
 		case HID_GD_GAMEPAD:  code += 0x130; break;
 		default:
 			switch (field->physical) {

commit a635f9dd83f3382577f4544a96df12356e951a40
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Fri Jun 12 15:20:55 2009 +0200

    HID: use debugfs for report dumping descriptor
    
    It is a little bit inconvenient for people who have some non-standard
    HID hardware (usually violating the HID specification) to have to
    recompile kernel with CONFIG_HID_DEBUG to be able to see kernel's perspective
    of the HID report descriptor and observe the parsed events. Plus the messages
    are then mixed up inconveniently with the rest of the dmesg stuff.
    
    This patch implements /sys/kernel/debug/hid/<device>/rdesc file, which
    represents the kernel's view of report descriptor (both the raw report
    descriptor data and parsed contents).
    
    With all the device-specific debug data being available through debugfs, there
    is no need for keeping CONFIG_HID_DEBUG, as the 'debug' parameter to the
    hid module will now only output only driver-specific debugging options, which has
    absolutely minimal memory footprint, just a few error messages and one global
    flag (hid_debug).
    
    We use the current set of output formatting functions. The ones that need to be
    used both for one-shot rdesc seq_file and also for continuous flow of data
    (individual reports, as being sent by the device) distinguish according to the
    passed seq_file parameter, and if it is NULL, it still output to kernel ringbuffer,
    otherwise the corresponding seq_file is used for output.
    
    The format of the output is preserved.
    
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 7f183b7147e1..5862b0f3b55d 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -159,17 +159,12 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 
 	field->hidinput = hidinput;
 
-	dbg_hid("Mapping: ");
-	hid_resolv_usage(usage->hid);
-	dbg_hid_line(" ---> ");
-
 	if (field->flags & HID_MAIN_ITEM_CONSTANT)
 		goto ignore;
 
 	/* only LED usages are supported in output fields */
 	if (field->report_type == HID_OUTPUT_REPORT &&
 			(usage->hid & HID_USAGE_PAGE) != HID_UP_LED) {
-		dbg_hid_line(" [non-LED output field] ");
 		goto ignore;
 	}
 
@@ -561,15 +556,9 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 		set_bit(MSC_SCAN, input->mscbit);
 	}
 
-	hid_resolv_event(usage->type, usage->code);
-
-	dbg_hid_line("\n");
-
-	return;
-
 ignore:
-	dbg_hid_line("IGNORED\n");
 	return;
+
 }
 
 void hidinput_hid_event(struct hid_device *hid, struct hid_field *field, struct hid_usage *usage, __s32 value)

commit 93c10132a7ac160df3175b53f7ee857625412165
Author: Jiri Slaby <jirislaby@gmail.com>
Date:   Fri Jun 27 00:04:24 2008 +0200

    HID: move connect quirks
    
    Move connecting from usbhid to the hid layer and fix also hidp in
    that manner.
    This removes all the ignore/force hidinput/hiddev connecting quirks.
    
    Signed-off-by: Jiri Slaby <jirislaby@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 0a68935c20b8..7f183b7147e1 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -700,7 +700,7 @@ static void hidinput_close(struct input_dev *dev)
  * Read all reports and initialize the absolute field values.
  */
 
-int hidinput_connect(struct hid_device *hid)
+int hidinput_connect(struct hid_device *hid, unsigned int force)
 {
 	struct hid_report *report;
 	struct hid_input *hidinput = NULL;
@@ -708,19 +708,20 @@ int hidinput_connect(struct hid_device *hid)
 	int i, j, k;
 	int max_report_type = HID_OUTPUT_REPORT;
 
-	if (hid->quirks & HID_QUIRK_IGNORE_HIDINPUT)
-		return -1;
-
 	INIT_LIST_HEAD(&hid->inputs);
 
-	for (i = 0; i < hid->maxcollection; i++)
-		if (hid->collection[i].type == HID_COLLECTION_APPLICATION ||
-		    hid->collection[i].type == HID_COLLECTION_PHYSICAL)
-			if (IS_INPUT_APPLICATION(hid->collection[i].usage))
-				break;
+	if (!force) {
+		for (i = 0; i < hid->maxcollection; i++) {
+			struct hid_collection *col = &hid->collection[i];
+			if (col->type == HID_COLLECTION_APPLICATION ||
+					col->type == HID_COLLECTION_PHYSICAL)
+				if (IS_INPUT_APPLICATION(col->usage))
+					break;
+		}
 
-	if (i == hid->maxcollection && (hid->quirks & HID_QUIRK_HIDINPUT) == 0)
-		return -1;
+		if (i == hid->maxcollection)
+			return -1;
+	}
 
 	if (hid->quirks & HID_QUIRK_SKIP_OUTPUT_REPORTS)
 		max_report_type = HID_INPUT_REPORT;

commit 3715ade981d524f9bb3b851a1eb81d3604a873bc
Author: Jiri Slaby <jirislaby@gmail.com>
Date:   Thu Jul 31 11:09:37 2008 +0200

    HID: remove hid-input-quirks
    
    Remove the file since these is no user now.
    
    Signed-off-by: Jiri Slaby <jirislaby@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 1d2d0827820c..0a68935c20b8 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -154,7 +154,7 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 {
 	struct input_dev *input = hidinput->input;
 	struct hid_device *device = input_get_drvdata(input);
-	int max = 0, code, ret;
+	int max = 0, code;
 	unsigned long *bit = NULL;
 
 	field->hidinput = hidinput;
@@ -173,11 +173,6 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 		goto ignore;
 	}
 
-	/* handle input mappings for quirky devices */
-	ret = hidinput_mapping_quirks(usage, hidinput, &bit, &max);
-	if (ret)
-		goto mapped;
-
 	if (device->driver->input_mapping) {
 		int ret = device->driver->input_mapping(device, hidinput, field,
 				usage, &bit, &max);
@@ -590,10 +585,6 @@ void hidinput_hid_event(struct hid_device *hid, struct hid_field *field, struct
 	if (!usage->type)
 		return;
 
-	/* handle input events for quirky devices */
-	if (hidinput_event_quirks(hid, field, usage, value))
-		return;
-
 	if (usage->hat_min < usage->hat_max || usage->hat_dir) {
 		int hat_dir = usage->hat_dir;
 		if (!hat_dir)

commit 14a21cd459f97e3b3cc4fcde48fc5bcdb81d097e
Author: Jiri Slaby <jirislaby@gmail.com>
Date:   Mon Jun 23 23:31:09 2008 +0200

    HID: move a4tech quirks
    
    Signed-off-by: Jiri Slaby <jirislaby@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index f1df25ab0baa..1d2d0827820c 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -515,15 +515,6 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 				hidinput, field, usage, &bit, &max) < 0)
 		goto ignore;
 
-	if ((device->quirks & (HID_QUIRK_2WHEEL_MOUSE_HACK_7 |
-			HID_QUIRK_2WHEEL_MOUSE_HACK_B8)) && (usage->type == EV_REL) &&
-			(usage->code == REL_WHEEL))
-		set_bit(REL_HWHEEL, bit);
-
-	if ((device->quirks & HID_QUIRK_2WHEEL_MOUSE_HACK_7) &&
-			(usage->hid == 0x00090007))
-		goto ignore;
-
 	set_bit(usage->type, input->evbit);
 
 	while (usage->code <= max && test_and_set_bit(usage->code, bit))

commit 0f2213208f8da51bcb665309e3468f000489c04f
Author: Jiri Slaby <jirislaby@gmail.com>
Date:   Mon Jun 23 22:54:08 2008 +0200

    HID: move cypress quirks
    
    Signed-off-by: Jiri Slaby <jirislaby@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index a6223bc5c734..f1df25ab0baa 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -515,13 +515,13 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 				hidinput, field, usage, &bit, &max) < 0)
 		goto ignore;
 
-	if ((device->quirks & (HID_QUIRK_2WHEEL_MOUSE_HACK_7 | HID_QUIRK_2WHEEL_MOUSE_HACK_5 |
+	if ((device->quirks & (HID_QUIRK_2WHEEL_MOUSE_HACK_7 |
 			HID_QUIRK_2WHEEL_MOUSE_HACK_B8)) && (usage->type == EV_REL) &&
 			(usage->code == REL_WHEEL))
 		set_bit(REL_HWHEEL, bit);
 
-	if (((device->quirks & HID_QUIRK_2WHEEL_MOUSE_HACK_5) && (usage->hid == 0x00090005))
-		|| ((device->quirks & HID_QUIRK_2WHEEL_MOUSE_HACK_7) && (usage->hid == 0x00090007)))
+	if ((device->quirks & HID_QUIRK_2WHEEL_MOUSE_HACK_7) &&
+			(usage->hid == 0x00090007))
 		goto ignore;
 
 	set_bit(usage->type, input->evbit);

commit 880d29f109428be1d027adf919a7457d8fe41fd3
Author: Jiri Slaby <jirislaby@gmail.com>
Date:   Wed Jun 18 23:55:41 2008 +0200

    HID: indent switches/cases
    
    Bring switch and cases into coding style and save thus some
    indentation to make the code tighter.
    
    Signed-off-by: Jiri Slaby <jirislaby@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 76ddf23f1965..a6223bc5c734 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -188,343 +188,326 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 	}
 
 	switch (usage->hid & HID_USAGE_PAGE) {
+	case HID_UP_UNDEFINED:
+		goto ignore;
 
-		case HID_UP_UNDEFINED:
-			goto ignore;
-
-		case HID_UP_KEYBOARD:
+	case HID_UP_KEYBOARD:
+		set_bit(EV_REP, input->evbit);
 
-			set_bit(EV_REP, input->evbit);
+		if ((usage->hid & HID_USAGE) < 256) {
+			if (!hid_keyboard[usage->hid & HID_USAGE]) goto ignore;
+			map_key_clear(hid_keyboard[usage->hid & HID_USAGE]);
+		} else
+			map_key(KEY_UNKNOWN);
 
-			if ((usage->hid & HID_USAGE) < 256) {
-				if (!hid_keyboard[usage->hid & HID_USAGE]) goto ignore;
-				map_key_clear(hid_keyboard[usage->hid & HID_USAGE]);
-			} else
-				map_key(KEY_UNKNOWN);
+		break;
 
-			break;
+	case HID_UP_BUTTON:
+		code = ((usage->hid - 1) & 0xf);
 
-		case HID_UP_BUTTON:
-
-			code = ((usage->hid - 1) & 0xf);
-
-			switch (field->application) {
-				case HID_GD_MOUSE:
-				case HID_GD_POINTER:  code += 0x110; break;
-				case HID_GD_JOYSTICK: code += 0x120; break;
-				case HID_GD_GAMEPAD:  code += 0x130; break;
-				default:
-					switch (field->physical) {
-						case HID_GD_MOUSE:
-						case HID_GD_POINTER:  code += 0x110; break;
-						case HID_GD_JOYSTICK: code += 0x120; break;
-						case HID_GD_GAMEPAD:  code += 0x130; break;
-						default:              code += 0x100;
-					}
+		switch (field->application) {
+		case HID_GD_MOUSE:
+		case HID_GD_POINTER:  code += 0x110; break;
+		case HID_GD_JOYSTICK: code += 0x120; break;
+		case HID_GD_GAMEPAD:  code += 0x130; break;
+		default:
+			switch (field->physical) {
+			case HID_GD_MOUSE:
+			case HID_GD_POINTER:  code += 0x110; break;
+			case HID_GD_JOYSTICK: code += 0x120; break;
+			case HID_GD_GAMEPAD:  code += 0x130; break;
+			default:              code += 0x100;
 			}
+		}
 
-			map_key(code);
-			break;
-
-
-		case HID_UP_SIMULATION:
-
-			switch (usage->hid & 0xffff) {
-				case 0xba: map_abs(ABS_RUDDER);   break;
-				case 0xbb: map_abs(ABS_THROTTLE); break;
-				case 0xc4: map_abs(ABS_GAS);      break;
-				case 0xc5: map_abs(ABS_BRAKE);    break;
-				case 0xc8: map_abs(ABS_WHEEL);    break;
-				default:   goto ignore;
+		map_key(code);
+		break;
+
+	case HID_UP_SIMULATION:
+		switch (usage->hid & 0xffff) {
+		case 0xba: map_abs(ABS_RUDDER);   break;
+		case 0xbb: map_abs(ABS_THROTTLE); break;
+		case 0xc4: map_abs(ABS_GAS);      break;
+		case 0xc5: map_abs(ABS_BRAKE);    break;
+		case 0xc8: map_abs(ABS_WHEEL);    break;
+		default:   goto ignore;
+		}
+		break;
+
+	case HID_UP_GENDESK:
+		if ((usage->hid & 0xf0) == 0x80) {	/* SystemControl */
+			switch (usage->hid & 0xf) {
+			case 0x1: map_key_clear(KEY_POWER);  break;
+			case 0x2: map_key_clear(KEY_SLEEP);  break;
+			case 0x3: map_key_clear(KEY_WAKEUP); break;
+			default: goto unknown;
 			}
 			break;
+		}
 
-		case HID_UP_GENDESK:
-
-			if ((usage->hid & 0xf0) == 0x80) {	/* SystemControl */
-				switch (usage->hid & 0xf) {
-					case 0x1: map_key_clear(KEY_POWER);  break;
-					case 0x2: map_key_clear(KEY_SLEEP);  break;
-					case 0x3: map_key_clear(KEY_WAKEUP); break;
-					default: goto unknown;
-				}
-				break;
-			}
-
-			if ((usage->hid & 0xf0) == 0x90) {	/* D-pad */
-				switch (usage->hid) {
-					case HID_GD_UP:	   usage->hat_dir = 1; break;
-					case HID_GD_DOWN:  usage->hat_dir = 5; break;
-					case HID_GD_RIGHT: usage->hat_dir = 3; break;
-					case HID_GD_LEFT:  usage->hat_dir = 7; break;
-					default: goto unknown;
-				}
-				if (field->dpad) {
-					map_abs(field->dpad);
-					goto ignore;
-				}
-				map_abs(ABS_HAT0X);
-				break;
-			}
-
+		if ((usage->hid & 0xf0) == 0x90) {	/* D-pad */
 			switch (usage->hid) {
-
-				/* These usage IDs map directly to the usage codes. */
-				case HID_GD_X: case HID_GD_Y: case HID_GD_Z:
-				case HID_GD_RX: case HID_GD_RY: case HID_GD_RZ:
-				case HID_GD_SLIDER: case HID_GD_DIAL: case HID_GD_WHEEL:
-					if (field->flags & HID_MAIN_ITEM_RELATIVE)
-						map_rel(usage->hid & 0xf);
-					else
-						map_abs(usage->hid & 0xf);
-					break;
-
-				case HID_GD_HATSWITCH:
-					usage->hat_min = field->logical_minimum;
-					usage->hat_max = field->logical_maximum;
-					map_abs(ABS_HAT0X);
-					break;
-
-				case HID_GD_START:	map_key_clear(BTN_START);	break;
-				case HID_GD_SELECT:	map_key_clear(BTN_SELECT);	break;
-
-				default: goto unknown;
+			case HID_GD_UP:	   usage->hat_dir = 1; break;
+			case HID_GD_DOWN:  usage->hat_dir = 5; break;
+			case HID_GD_RIGHT: usage->hat_dir = 3; break;
+			case HID_GD_LEFT:  usage->hat_dir = 7; break;
+			default: goto unknown;
 			}
-
-			break;
-
-		case HID_UP_LED:
-
-			switch (usage->hid & 0xffff) {                        /* HID-Value:                   */
-				case 0x01:  map_led (LED_NUML);     break;    /*   "Num Lock"                 */
-				case 0x02:  map_led (LED_CAPSL);    break;    /*   "Caps Lock"                */
-				case 0x03:  map_led (LED_SCROLLL);  break;    /*   "Scroll Lock"              */
-				case 0x04:  map_led (LED_COMPOSE);  break;    /*   "Compose"                  */
-				case 0x05:  map_led (LED_KANA);     break;    /*   "Kana"                     */
-				case 0x27:  map_led (LED_SLEEP);    break;    /*   "Stand-By"                 */
-				case 0x4c:  map_led (LED_SUSPEND);  break;    /*   "System Suspend"           */
-				case 0x09:  map_led (LED_MUTE);     break;    /*   "Mute"                     */
-				case 0x4b:  map_led (LED_MISC);     break;    /*   "Generic Indicator"        */
-				case 0x19:  map_led (LED_MAIL);     break;    /*   "Message Waiting"          */
-				case 0x4d:  map_led (LED_CHARGING); break;    /*   "External Power Connected" */
-
-				default: goto ignore;
+			if (field->dpad) {
+				map_abs(field->dpad);
+				goto ignore;
 			}
+			map_abs(ABS_HAT0X);
 			break;
+		}
 
-		case HID_UP_DIGITIZER:
-
-			switch (usage->hid & 0xff) {
-
-				case 0x30: /* TipPressure */
-					if (!test_bit(BTN_TOUCH, input->keybit)) {
-						device->quirks |= HID_QUIRK_NOTOUCH;
-						set_bit(EV_KEY, input->evbit);
-						set_bit(BTN_TOUCH, input->keybit);
-					}
-
-					map_abs_clear(ABS_PRESSURE);
-					break;
-
-				case 0x32: /* InRange */
-					switch (field->physical & 0xff) {
-						case 0x21: map_key(BTN_TOOL_MOUSE); break;
-						case 0x22: map_key(BTN_TOOL_FINGER); break;
-						default: map_key(BTN_TOOL_PEN); break;
-					}
-					break;
+		switch (usage->hid) {
+		/* These usage IDs map directly to the usage codes. */
+		case HID_GD_X: case HID_GD_Y: case HID_GD_Z:
+		case HID_GD_RX: case HID_GD_RY: case HID_GD_RZ:
+		case HID_GD_SLIDER: case HID_GD_DIAL: case HID_GD_WHEEL:
+			if (field->flags & HID_MAIN_ITEM_RELATIVE)
+				map_rel(usage->hid & 0xf);
+			else
+				map_abs(usage->hid & 0xf);
+			break;
 
-				case 0x3c: /* Invert */
-					map_key_clear(BTN_TOOL_RUBBER);
-					break;
+		case HID_GD_HATSWITCH:
+			usage->hat_min = field->logical_minimum;
+			usage->hat_max = field->logical_maximum;
+			map_abs(ABS_HAT0X);
+			break;
 
-				case 0x33: /* Touch */
-				case 0x42: /* TipSwitch */
-				case 0x43: /* TipSwitch2 */
-					device->quirks &= ~HID_QUIRK_NOTOUCH;
-					map_key_clear(BTN_TOUCH);
-					break;
+		case HID_GD_START:	map_key_clear(BTN_START);	break;
+		case HID_GD_SELECT:	map_key_clear(BTN_SELECT);	break;
 
-				case 0x44: /* BarrelSwitch */
-					map_key_clear(BTN_STYLUS);
-					break;
+		default: goto unknown;
+		}
 
-				default:  goto unknown;
+		break;
+
+	case HID_UP_LED:
+		switch (usage->hid & 0xffff) {		      /* HID-Value:                   */
+		case 0x01:  map_led (LED_NUML);     break;    /*   "Num Lock"                 */
+		case 0x02:  map_led (LED_CAPSL);    break;    /*   "Caps Lock"                */
+		case 0x03:  map_led (LED_SCROLLL);  break;    /*   "Scroll Lock"              */
+		case 0x04:  map_led (LED_COMPOSE);  break;    /*   "Compose"                  */
+		case 0x05:  map_led (LED_KANA);     break;    /*   "Kana"                     */
+		case 0x27:  map_led (LED_SLEEP);    break;    /*   "Stand-By"                 */
+		case 0x4c:  map_led (LED_SUSPEND);  break;    /*   "System Suspend"           */
+		case 0x09:  map_led (LED_MUTE);     break;    /*   "Mute"                     */
+		case 0x4b:  map_led (LED_MISC);     break;    /*   "Generic Indicator"        */
+		case 0x19:  map_led (LED_MAIL);     break;    /*   "Message Waiting"          */
+		case 0x4d:  map_led (LED_CHARGING); break;    /*   "External Power Connected" */
+
+		default: goto ignore;
+		}
+		break;
+
+	case HID_UP_DIGITIZER:
+		switch (usage->hid & 0xff) {
+		case 0x30: /* TipPressure */
+			if (!test_bit(BTN_TOUCH, input->keybit)) {
+				device->quirks |= HID_QUIRK_NOTOUCH;
+				set_bit(EV_KEY, input->evbit);
+				set_bit(BTN_TOUCH, input->keybit);
 			}
+			map_abs_clear(ABS_PRESSURE);
 			break;
 
-		case HID_UP_CONSUMER:	/* USB HUT v1.1, pages 56-62 */
-
-			switch (usage->hid & HID_USAGE) {
-				case 0x000: goto ignore;
-				case 0x034: map_key_clear(KEY_SLEEP);		break;
-				case 0x036: map_key_clear(BTN_MISC);		break;
-
-				case 0x040: map_key_clear(KEY_MENU);		break;
-				case 0x045: map_key_clear(KEY_RADIO);		break;
-
-				case 0x083: map_key_clear(KEY_LAST);		break;
-				case 0x088: map_key_clear(KEY_PC);		break;
-				case 0x089: map_key_clear(KEY_TV);		break;
-				case 0x08a: map_key_clear(KEY_WWW);		break;
-				case 0x08b: map_key_clear(KEY_DVD);		break;
-				case 0x08c: map_key_clear(KEY_PHONE);		break;
-				case 0x08d: map_key_clear(KEY_PROGRAM);		break;
-				case 0x08e: map_key_clear(KEY_VIDEOPHONE);	break;
-				case 0x08f: map_key_clear(KEY_GAMES);		break;
-				case 0x090: map_key_clear(KEY_MEMO);		break;
-				case 0x091: map_key_clear(KEY_CD);		break;
-				case 0x092: map_key_clear(KEY_VCR);		break;
-				case 0x093: map_key_clear(KEY_TUNER);		break;
-				case 0x094: map_key_clear(KEY_EXIT);		break;
-				case 0x095: map_key_clear(KEY_HELP);		break;
-				case 0x096: map_key_clear(KEY_TAPE);		break;
-				case 0x097: map_key_clear(KEY_TV2);		break;
-				case 0x098: map_key_clear(KEY_SAT);		break;
-				case 0x09a: map_key_clear(KEY_PVR);		break;
-
-				case 0x09c: map_key_clear(KEY_CHANNELUP);	break;
-				case 0x09d: map_key_clear(KEY_CHANNELDOWN);	break;
-				case 0x0a0: map_key_clear(KEY_VCR2);		break;
-
-				case 0x0b0: map_key_clear(KEY_PLAY);		break;
-				case 0x0b1: map_key_clear(KEY_PAUSE);		break;
-				case 0x0b2: map_key_clear(KEY_RECORD);		break;
-				case 0x0b3: map_key_clear(KEY_FASTFORWARD);	break;
-				case 0x0b4: map_key_clear(KEY_REWIND);		break;
-				case 0x0b5: map_key_clear(KEY_NEXTSONG);	break;
-				case 0x0b6: map_key_clear(KEY_PREVIOUSSONG);	break;
-				case 0x0b7: map_key_clear(KEY_STOPCD);		break;
-				case 0x0b8: map_key_clear(KEY_EJECTCD);		break;
-				case 0x0bc: map_key_clear(KEY_MEDIA_REPEAT);	break;
-
-				case 0x0cd: map_key_clear(KEY_PLAYPAUSE);	break;
-			        case 0x0e0: map_abs_clear(ABS_VOLUME);		break;
-				case 0x0e2: map_key_clear(KEY_MUTE);		break;
-				case 0x0e5: map_key_clear(KEY_BASSBOOST);	break;
-				case 0x0e9: map_key_clear(KEY_VOLUMEUP);	break;
-				case 0x0ea: map_key_clear(KEY_VOLUMEDOWN);	break;
-
-				case 0x182: map_key_clear(KEY_BOOKMARKS);	break;
-				case 0x183: map_key_clear(KEY_CONFIG);		break;
-				case 0x184: map_key_clear(KEY_WORDPROCESSOR);	break;
-				case 0x185: map_key_clear(KEY_EDITOR);		break;
-				case 0x186: map_key_clear(KEY_SPREADSHEET);	break;
-				case 0x187: map_key_clear(KEY_GRAPHICSEDITOR);	break;
-				case 0x188: map_key_clear(KEY_PRESENTATION);	break;
-				case 0x189: map_key_clear(KEY_DATABASE);	break;
-				case 0x18a: map_key_clear(KEY_MAIL);		break;
-				case 0x18b: map_key_clear(KEY_NEWS);		break;
-				case 0x18c: map_key_clear(KEY_VOICEMAIL);	break;
-				case 0x18d: map_key_clear(KEY_ADDRESSBOOK);	break;
-				case 0x18e: map_key_clear(KEY_CALENDAR);	break;
-				case 0x191: map_key_clear(KEY_FINANCE);		break;
-				case 0x192: map_key_clear(KEY_CALC);		break;
-				case 0x194: map_key_clear(KEY_FILE);		break;
-				case 0x196: map_key_clear(KEY_WWW);		break;
-				case 0x19c: map_key_clear(KEY_LOGOFF);		break;
-				case 0x19e: map_key_clear(KEY_COFFEE);		break;
-				case 0x1a6: map_key_clear(KEY_HELP);		break;
-				case 0x1a7: map_key_clear(KEY_DOCUMENTS);	break;
-				case 0x1ab: map_key_clear(KEY_SPELLCHECK);	break;
-				case 0x1b6: map_key_clear(KEY_MEDIA);		break;
-				case 0x1b7: map_key_clear(KEY_SOUND);		break;
-				case 0x1bc: map_key_clear(KEY_MESSENGER);	break;
-				case 0x1bd: map_key_clear(KEY_INFO);		break;
-				case 0x201: map_key_clear(KEY_NEW);		break;
-				case 0x202: map_key_clear(KEY_OPEN);		break;
-				case 0x203: map_key_clear(KEY_CLOSE);		break;
-				case 0x204: map_key_clear(KEY_EXIT);		break;
-				case 0x207: map_key_clear(KEY_SAVE);		break;
-				case 0x208: map_key_clear(KEY_PRINT);		break;
-				case 0x209: map_key_clear(KEY_PROPS);		break;
-				case 0x21a: map_key_clear(KEY_UNDO);		break;
-				case 0x21b: map_key_clear(KEY_COPY);		break;
-				case 0x21c: map_key_clear(KEY_CUT);		break;
-				case 0x21d: map_key_clear(KEY_PASTE);		break;
-				case 0x21f: map_key_clear(KEY_FIND);		break;
-				case 0x221: map_key_clear(KEY_SEARCH);		break;
-				case 0x222: map_key_clear(KEY_GOTO);		break;
-				case 0x223: map_key_clear(KEY_HOMEPAGE);	break;
-				case 0x224: map_key_clear(KEY_BACK);		break;
-				case 0x225: map_key_clear(KEY_FORWARD);		break;
-				case 0x226: map_key_clear(KEY_STOP);		break;
-				case 0x227: map_key_clear(KEY_REFRESH);		break;
-				case 0x22a: map_key_clear(KEY_BOOKMARKS);	break;
-				case 0x22d: map_key_clear(KEY_ZOOMIN);		break;
-				case 0x22e: map_key_clear(KEY_ZOOMOUT);		break;
-				case 0x22f: map_key_clear(KEY_ZOOMRESET);	break;
-				case 0x233: map_key_clear(KEY_SCROLLUP);	break;
-				case 0x234: map_key_clear(KEY_SCROLLDOWN);	break;
-				case 0x238: map_rel(REL_HWHEEL);		break;
-				case 0x25f: map_key_clear(KEY_CANCEL);		break;
-				case 0x279: map_key_clear(KEY_REDO);		break;
-
-				case 0x289: map_key_clear(KEY_REPLY);		break;
-				case 0x28b: map_key_clear(KEY_FORWARDMAIL);	break;
-				case 0x28c: map_key_clear(KEY_SEND);		break;
-
-				default:    goto ignore;
+		case 0x32: /* InRange */
+			switch (field->physical & 0xff) {
+			case 0x21: map_key(BTN_TOOL_MOUSE); break;
+			case 0x22: map_key(BTN_TOOL_FINGER); break;
+			default: map_key(BTN_TOOL_PEN); break;
 			}
 			break;
 
-		case HID_UP_HPVENDOR:	/* Reported on a Dutch layout HP5308 */
-
-			set_bit(EV_REP, input->evbit);
-			switch (usage->hid & HID_USAGE) {
-			        case 0x021: map_key_clear(KEY_PRINT);           break;
-				case 0x070: map_key_clear(KEY_HP);		break;
-				case 0x071: map_key_clear(KEY_CAMERA);		break;
-				case 0x072: map_key_clear(KEY_SOUND);		break;
-				case 0x073: map_key_clear(KEY_QUESTION);	break;
-				case 0x080: map_key_clear(KEY_EMAIL);		break;
-				case 0x081: map_key_clear(KEY_CHAT);		break;
-				case 0x082: map_key_clear(KEY_SEARCH);		break;
-				case 0x083: map_key_clear(KEY_CONNECT);	        break;
-				case 0x084: map_key_clear(KEY_FINANCE);		break;
-				case 0x085: map_key_clear(KEY_SPORT);		break;
-				case 0x086: map_key_clear(KEY_SHOP);	        break;
-				default:    goto ignore;
-			}
+		case 0x3c: /* Invert */
+			map_key_clear(BTN_TOOL_RUBBER);
 			break;
 
-		case HID_UP_MSVENDOR:
-
-			goto ignore;
+		case 0x33: /* Touch */
+		case 0x42: /* TipSwitch */
+		case 0x43: /* TipSwitch2 */
+			device->quirks &= ~HID_QUIRK_NOTOUCH;
+			map_key_clear(BTN_TOUCH);
+			break;
 
-		case HID_UP_CUSTOM: /* Reported on Logitech and Apple USB keyboards */
+		case 0x44: /* BarrelSwitch */
+			map_key_clear(BTN_STYLUS);
+			break;
 
-			set_bit(EV_REP, input->evbit);
-			goto ignore;
+		default:  goto unknown;
+		}
+		break;
+
+	case HID_UP_CONSUMER:	/* USB HUT v1.1, pages 56-62 */
+		switch (usage->hid & HID_USAGE) {
+		case 0x000: goto ignore;
+		case 0x034: map_key_clear(KEY_SLEEP);		break;
+		case 0x036: map_key_clear(BTN_MISC);		break;
+
+		case 0x040: map_key_clear(KEY_MENU);		break;
+		case 0x045: map_key_clear(KEY_RADIO);		break;
+
+		case 0x083: map_key_clear(KEY_LAST);		break;
+		case 0x088: map_key_clear(KEY_PC);		break;
+		case 0x089: map_key_clear(KEY_TV);		break;
+		case 0x08a: map_key_clear(KEY_WWW);		break;
+		case 0x08b: map_key_clear(KEY_DVD);		break;
+		case 0x08c: map_key_clear(KEY_PHONE);		break;
+		case 0x08d: map_key_clear(KEY_PROGRAM);		break;
+		case 0x08e: map_key_clear(KEY_VIDEOPHONE);	break;
+		case 0x08f: map_key_clear(KEY_GAMES);		break;
+		case 0x090: map_key_clear(KEY_MEMO);		break;
+		case 0x091: map_key_clear(KEY_CD);		break;
+		case 0x092: map_key_clear(KEY_VCR);		break;
+		case 0x093: map_key_clear(KEY_TUNER);		break;
+		case 0x094: map_key_clear(KEY_EXIT);		break;
+		case 0x095: map_key_clear(KEY_HELP);		break;
+		case 0x096: map_key_clear(KEY_TAPE);		break;
+		case 0x097: map_key_clear(KEY_TV2);		break;
+		case 0x098: map_key_clear(KEY_SAT);		break;
+		case 0x09a: map_key_clear(KEY_PVR);		break;
+
+		case 0x09c: map_key_clear(KEY_CHANNELUP);	break;
+		case 0x09d: map_key_clear(KEY_CHANNELDOWN);	break;
+		case 0x0a0: map_key_clear(KEY_VCR2);		break;
+
+		case 0x0b0: map_key_clear(KEY_PLAY);		break;
+		case 0x0b1: map_key_clear(KEY_PAUSE);		break;
+		case 0x0b2: map_key_clear(KEY_RECORD);		break;
+		case 0x0b3: map_key_clear(KEY_FASTFORWARD);	break;
+		case 0x0b4: map_key_clear(KEY_REWIND);		break;
+		case 0x0b5: map_key_clear(KEY_NEXTSONG);	break;
+		case 0x0b6: map_key_clear(KEY_PREVIOUSSONG);	break;
+		case 0x0b7: map_key_clear(KEY_STOPCD);		break;
+		case 0x0b8: map_key_clear(KEY_EJECTCD);		break;
+		case 0x0bc: map_key_clear(KEY_MEDIA_REPEAT);	break;
+
+		case 0x0cd: map_key_clear(KEY_PLAYPAUSE);	break;
+		case 0x0e0: map_abs_clear(ABS_VOLUME);		break;
+		case 0x0e2: map_key_clear(KEY_MUTE);		break;
+		case 0x0e5: map_key_clear(KEY_BASSBOOST);	break;
+		case 0x0e9: map_key_clear(KEY_VOLUMEUP);	break;
+		case 0x0ea: map_key_clear(KEY_VOLUMEDOWN);	break;
+
+		case 0x182: map_key_clear(KEY_BOOKMARKS);	break;
+		case 0x183: map_key_clear(KEY_CONFIG);		break;
+		case 0x184: map_key_clear(KEY_WORDPROCESSOR);	break;
+		case 0x185: map_key_clear(KEY_EDITOR);		break;
+		case 0x186: map_key_clear(KEY_SPREADSHEET);	break;
+		case 0x187: map_key_clear(KEY_GRAPHICSEDITOR);	break;
+		case 0x188: map_key_clear(KEY_PRESENTATION);	break;
+		case 0x189: map_key_clear(KEY_DATABASE);	break;
+		case 0x18a: map_key_clear(KEY_MAIL);		break;
+		case 0x18b: map_key_clear(KEY_NEWS);		break;
+		case 0x18c: map_key_clear(KEY_VOICEMAIL);	break;
+		case 0x18d: map_key_clear(KEY_ADDRESSBOOK);	break;
+		case 0x18e: map_key_clear(KEY_CALENDAR);	break;
+		case 0x191: map_key_clear(KEY_FINANCE);		break;
+		case 0x192: map_key_clear(KEY_CALC);		break;
+		case 0x194: map_key_clear(KEY_FILE);		break;
+		case 0x196: map_key_clear(KEY_WWW);		break;
+		case 0x19c: map_key_clear(KEY_LOGOFF);		break;
+		case 0x19e: map_key_clear(KEY_COFFEE);		break;
+		case 0x1a6: map_key_clear(KEY_HELP);		break;
+		case 0x1a7: map_key_clear(KEY_DOCUMENTS);	break;
+		case 0x1ab: map_key_clear(KEY_SPELLCHECK);	break;
+		case 0x1b6: map_key_clear(KEY_MEDIA);		break;
+		case 0x1b7: map_key_clear(KEY_SOUND);		break;
+		case 0x1bc: map_key_clear(KEY_MESSENGER);	break;
+		case 0x1bd: map_key_clear(KEY_INFO);		break;
+		case 0x201: map_key_clear(KEY_NEW);		break;
+		case 0x202: map_key_clear(KEY_OPEN);		break;
+		case 0x203: map_key_clear(KEY_CLOSE);		break;
+		case 0x204: map_key_clear(KEY_EXIT);		break;
+		case 0x207: map_key_clear(KEY_SAVE);		break;
+		case 0x208: map_key_clear(KEY_PRINT);		break;
+		case 0x209: map_key_clear(KEY_PROPS);		break;
+		case 0x21a: map_key_clear(KEY_UNDO);		break;
+		case 0x21b: map_key_clear(KEY_COPY);		break;
+		case 0x21c: map_key_clear(KEY_CUT);		break;
+		case 0x21d: map_key_clear(KEY_PASTE);		break;
+		case 0x21f: map_key_clear(KEY_FIND);		break;
+		case 0x221: map_key_clear(KEY_SEARCH);		break;
+		case 0x222: map_key_clear(KEY_GOTO);		break;
+		case 0x223: map_key_clear(KEY_HOMEPAGE);	break;
+		case 0x224: map_key_clear(KEY_BACK);		break;
+		case 0x225: map_key_clear(KEY_FORWARD);		break;
+		case 0x226: map_key_clear(KEY_STOP);		break;
+		case 0x227: map_key_clear(KEY_REFRESH);		break;
+		case 0x22a: map_key_clear(KEY_BOOKMARKS);	break;
+		case 0x22d: map_key_clear(KEY_ZOOMIN);		break;
+		case 0x22e: map_key_clear(KEY_ZOOMOUT);		break;
+		case 0x22f: map_key_clear(KEY_ZOOMRESET);	break;
+		case 0x233: map_key_clear(KEY_SCROLLUP);	break;
+		case 0x234: map_key_clear(KEY_SCROLLDOWN);	break;
+		case 0x238: map_rel(REL_HWHEEL);		break;
+		case 0x25f: map_key_clear(KEY_CANCEL);		break;
+		case 0x279: map_key_clear(KEY_REDO);		break;
+
+		case 0x289: map_key_clear(KEY_REPLY);		break;
+		case 0x28b: map_key_clear(KEY_FORWARDMAIL);	break;
+		case 0x28c: map_key_clear(KEY_SEND);		break;
+
+		default:    goto ignore;
+		}
+		break;
+
+	case HID_UP_HPVENDOR:	/* Reported on a Dutch layout HP5308 */
+		set_bit(EV_REP, input->evbit);
+		switch (usage->hid & HID_USAGE) {
+		case 0x021: map_key_clear(KEY_PRINT);           break;
+		case 0x070: map_key_clear(KEY_HP);		break;
+		case 0x071: map_key_clear(KEY_CAMERA);		break;
+		case 0x072: map_key_clear(KEY_SOUND);		break;
+		case 0x073: map_key_clear(KEY_QUESTION);	break;
+		case 0x080: map_key_clear(KEY_EMAIL);		break;
+		case 0x081: map_key_clear(KEY_CHAT);		break;
+		case 0x082: map_key_clear(KEY_SEARCH);		break;
+		case 0x083: map_key_clear(KEY_CONNECT);	        break;
+		case 0x084: map_key_clear(KEY_FINANCE);		break;
+		case 0x085: map_key_clear(KEY_SPORT);		break;
+		case 0x086: map_key_clear(KEY_SHOP);	        break;
+		default:    goto ignore;
+		}
+		break;
 
-		case HID_UP_LOGIVENDOR:
+	case HID_UP_MSVENDOR:
+		goto ignore;
 
-			goto ignore;
-		
-		case HID_UP_PID:
+	case HID_UP_CUSTOM: /* Reported on Logitech and Apple USB keyboards */
+		set_bit(EV_REP, input->evbit);
+		goto ignore;
 
-			switch(usage->hid & HID_USAGE) {
-				case 0xa4: map_key_clear(BTN_DEAD);	break;
-				default: goto ignore;
-			}
-			break;
+	case HID_UP_LOGIVENDOR:
+		goto ignore;
+	
+	case HID_UP_PID:
+		switch (usage->hid & HID_USAGE) {
+		case 0xa4: map_key_clear(BTN_DEAD);	break;
+		default: goto ignore;
+		}
+		break;
 
-		default:
-		unknown:
-			if (field->report_size == 1) {
-				if (field->report->type == HID_OUTPUT_REPORT) {
-					map_led(LED_MISC);
-					break;
-				}
-				map_key(BTN_MISC);
-				break;
-			}
-			if (field->flags & HID_MAIN_ITEM_RELATIVE) {
-				map_rel(REL_MISC);
+	default:
+	unknown:
+		if (field->report_size == 1) {
+			if (field->report->type == HID_OUTPUT_REPORT) {
+				map_led(LED_MISC);
 				break;
 			}
-			map_abs(ABS_MISC);
+			map_key(BTN_MISC);
 			break;
+		}
+		if (field->flags & HID_MAIN_ITEM_RELATIVE) {
+			map_rel(REL_MISC);
+			break;
+		}
+		map_abs(ABS_MISC);
+		break;
 	}
 
 mapped:

commit 8c19a51591d06f5226499972567f528cf6066bb7
Author: Jiri Slaby <jirislaby@gmail.com>
Date:   Wed Jun 18 23:36:49 2008 +0200

    HID: move apple quirks
    
    Move them from the core code to a separate driver.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 4f2bac010f59..76ddf23f1965 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -32,11 +32,6 @@
 #include <linux/hid.h>
 #include <linux/hid-debug.h>
 
-static int hid_apple_fnmode = 1;
-module_param_named(pb_fnmode, hid_apple_fnmode, int, 0644);
-MODULE_PARM_DESC(pb_fnmode,
-		"Mode of fn key on Apple keyboards (0 = disabled, 1 = fkeyslast, 2 = fkeysfirst)");
-
 #define unk	KEY_UNKNOWN
 
 static const unsigned char hid_keyboard[256] = {
@@ -73,202 +68,6 @@ static const struct {
 #define map_key_clear(c)	hid_map_usage_clear(hidinput, usage, &bit, \
 		&max, EV_KEY, (c))
 
-#ifdef CONFIG_USB_HIDINPUT_POWERBOOK
-
-struct hidinput_key_translation {
-	u16 from;
-	u16 to;
-	u8 flags;
-};
-
-#define APPLE_FLAG_FKEY 0x01
-
-static struct hidinput_key_translation apple_fn_keys[] = {
-	{ KEY_BACKSPACE, KEY_DELETE },
-	{ KEY_F1,       KEY_BRIGHTNESSDOWN, APPLE_FLAG_FKEY },
-	{ KEY_F2,       KEY_BRIGHTNESSUP,   APPLE_FLAG_FKEY },
-	{ KEY_F3,       KEY_FN_F5,          APPLE_FLAG_FKEY }, /* Exposé */
-	{ KEY_F4,       KEY_FN_F4,          APPLE_FLAG_FKEY }, /* Dashboard */
-	{ KEY_F5,       KEY_KBDILLUMDOWN,   APPLE_FLAG_FKEY },
-	{ KEY_F6,       KEY_KBDILLUMUP,     APPLE_FLAG_FKEY },
-	{ KEY_F7,       KEY_PREVIOUSSONG,   APPLE_FLAG_FKEY },
-	{ KEY_F8,       KEY_PLAYPAUSE,      APPLE_FLAG_FKEY },
-	{ KEY_F9,       KEY_NEXTSONG,       APPLE_FLAG_FKEY },
-	{ KEY_F10,      KEY_MUTE,           APPLE_FLAG_FKEY },
-	{ KEY_F11,      KEY_VOLUMEDOWN,     APPLE_FLAG_FKEY },
-	{ KEY_F12,      KEY_VOLUMEUP,       APPLE_FLAG_FKEY },
-	{ KEY_UP,       KEY_PAGEUP },
-	{ KEY_DOWN,     KEY_PAGEDOWN },
-	{ KEY_LEFT,     KEY_HOME },
-	{ KEY_RIGHT,    KEY_END },
-	{ }
-};
-
-static struct hidinput_key_translation powerbook_fn_keys[] = {
-	{ KEY_BACKSPACE, KEY_DELETE },
-	{ KEY_F1,       KEY_BRIGHTNESSDOWN,     APPLE_FLAG_FKEY },
-	{ KEY_F2,       KEY_BRIGHTNESSUP,       APPLE_FLAG_FKEY },
-	{ KEY_F3,       KEY_MUTE,               APPLE_FLAG_FKEY },
-	{ KEY_F4,       KEY_VOLUMEDOWN,         APPLE_FLAG_FKEY },
-	{ KEY_F5,       KEY_VOLUMEUP,           APPLE_FLAG_FKEY },
-	{ KEY_F6,       KEY_NUMLOCK,            APPLE_FLAG_FKEY },
-	{ KEY_F7,       KEY_SWITCHVIDEOMODE,    APPLE_FLAG_FKEY },
-	{ KEY_F8,       KEY_KBDILLUMTOGGLE,     APPLE_FLAG_FKEY },
-	{ KEY_F9,       KEY_KBDILLUMDOWN,       APPLE_FLAG_FKEY },
-	{ KEY_F10,      KEY_KBDILLUMUP,         APPLE_FLAG_FKEY },
-	{ KEY_UP,       KEY_PAGEUP },
-	{ KEY_DOWN,     KEY_PAGEDOWN },
-	{ KEY_LEFT,     KEY_HOME },
-	{ KEY_RIGHT,    KEY_END },
-	{ }
-};
-
-static struct hidinput_key_translation powerbook_numlock_keys[] = {
-	{ KEY_J,        KEY_KP1 },
-	{ KEY_K,        KEY_KP2 },
-	{ KEY_L,        KEY_KP3 },
-	{ KEY_U,        KEY_KP4 },
-	{ KEY_I,        KEY_KP5 },
-	{ KEY_O,        KEY_KP6 },
-	{ KEY_7,        KEY_KP7 },
-	{ KEY_8,        KEY_KP8 },
-	{ KEY_9,        KEY_KP9 },
-	{ KEY_M,        KEY_KP0 },
-	{ KEY_DOT,      KEY_KPDOT },
-	{ KEY_SLASH,    KEY_KPPLUS },
-	{ KEY_SEMICOLON, KEY_KPMINUS },
-	{ KEY_P,        KEY_KPASTERISK },
-	{ KEY_MINUS,    KEY_KPEQUAL },
-	{ KEY_0,        KEY_KPSLASH },
-	{ KEY_F6,       KEY_NUMLOCK },
-	{ KEY_KPENTER,  KEY_KPENTER },
-	{ KEY_BACKSPACE, KEY_BACKSPACE },
-	{ }
-};
-
-static struct hidinput_key_translation apple_iso_keyboard[] = {
-	{ KEY_GRAVE,    KEY_102ND },
-	{ KEY_102ND,    KEY_GRAVE },
-	{ }
-};
-
-static struct hidinput_key_translation *find_translation(struct hidinput_key_translation *table, u16 from)
-{
-	struct hidinput_key_translation *trans;
-
-	/* Look for the translation */
-	for (trans = table; trans->from; trans++)
-		if (trans->from == from)
-			return trans;
-
-	return NULL;
-}
-
-int hidinput_apple_event(struct hid_device *hid, struct input_dev *input,
-		struct hid_usage *usage, __s32 value)
-{
-	struct hidinput_key_translation *trans;
-
-	if (usage->code == KEY_FN) {
-		if (value) hid->quirks |=  HID_QUIRK_APPLE_FN_ON;
-		else       hid->quirks &= ~HID_QUIRK_APPLE_FN_ON;
-
-		input_event(input, usage->type, usage->code, value);
-
-		return 1;
-	}
-
-	if (hid_apple_fnmode) {
-		int do_translate;
-
-		trans = find_translation((hid->product < 0x220 ||
-					  hid->product >= 0x300) ?
-					 powerbook_fn_keys : apple_fn_keys,
-					 usage->code);
-		if (trans) {
-			if (test_bit(usage->code, hid->apple_pressed_fn))
-				do_translate = 1;
-			else if (trans->flags & APPLE_FLAG_FKEY)
-				do_translate =
-					(hid_apple_fnmode == 2 &&  (hid->quirks & HID_QUIRK_APPLE_FN_ON)) ||
-					(hid_apple_fnmode == 1 && !(hid->quirks & HID_QUIRK_APPLE_FN_ON));
-			else
-				do_translate = (hid->quirks & HID_QUIRK_APPLE_FN_ON);
-
-			if (do_translate) {
-				if (value)
-					set_bit(usage->code, hid->apple_pressed_fn);
-				else
-					clear_bit(usage->code, hid->apple_pressed_fn);
-
-				input_event(input, usage->type, trans->to, value);
-
-				return 1;
-			}
-		}
-
-		if (hid->quirks & HID_QUIRK_APPLE_NUMLOCK_EMULATION && (
-				test_bit(usage->code, hid->pb_pressed_numlock) ||
-				test_bit(LED_NUML, input->led))) {
-			trans = find_translation(powerbook_numlock_keys, usage->code);
-
-			if (trans) {
-				if (value)
-					set_bit(usage->code, hid->pb_pressed_numlock);
-				else
-					clear_bit(usage->code, hid->pb_pressed_numlock);
-
-				input_event(input, usage->type, trans->to, value);
-			}
-
-			return 1;
-		}
-	}
-
-	if (hid->quirks & HID_QUIRK_APPLE_ISO_KEYBOARD) {
-		trans = find_translation(apple_iso_keyboard, usage->code);
-		if (trans) {
-			input_event(input, usage->type, trans->to, value);
-			return 1;
-		}
-	}
-
-	return 0;
-}
-
-static void hidinput_apple_setup(struct input_dev *input)
-{
-	struct hidinput_key_translation *trans;
-
-	set_bit(KEY_NUMLOCK, input->keybit);
-
-	/* Enable all needed keys */
-	for (trans = apple_fn_keys; trans->from; trans++)
-		set_bit(trans->to, input->keybit);
-
-	for (trans = powerbook_fn_keys; trans->from; trans++)
-		set_bit(trans->to, input->keybit);
-
-	for (trans = powerbook_numlock_keys; trans->from; trans++)
-		set_bit(trans->to, input->keybit);
-
-	for (trans = apple_iso_keyboard; trans->from; trans++)
-		set_bit(trans->to, input->keybit);
-
-}
-#else
-inline int hidinput_apple_event(struct hid_device *hid,
-				       struct input_dev *input,
-				       struct hid_usage *usage, __s32 value)
-{
-	return 0;
-}
-
-static inline void hidinput_apple_setup(struct input_dev *input)
-{
-}
-#endif
-
 static inline int match_scancode(int code, int scancode)
 {
 	if (scancode == 0)
@@ -696,16 +495,7 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 		case HID_UP_CUSTOM: /* Reported on Logitech and Apple USB keyboards */
 
 			set_bit(EV_REP, input->evbit);
-			switch(usage->hid & HID_USAGE) {
-				case 0x003:
-					/* The fn key on Apple USB keyboards */
-					map_key_clear(KEY_FN);
-					hidinput_apple_setup(input);
-					break;
-
-				default:    goto ignore;
-			}
-			break;
+			goto ignore;
 
 		case HID_UP_LOGIVENDOR:
 
@@ -742,15 +532,6 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 				hidinput, field, usage, &bit, &max) < 0)
 		goto ignore;
 
-	if (device->quirks & HID_QUIRK_MIGHTYMOUSE) {
-		if (usage->hid == HID_GD_Z)
-			map_rel(REL_HWHEEL);
-		else if (usage->code == BTN_1)
-			map_key(BTN_2);
-		else if (usage->code == BTN_2)
-			map_key(BTN_1);
-	}
-
 	if ((device->quirks & (HID_QUIRK_2WHEEL_MOUSE_HACK_7 | HID_QUIRK_2WHEEL_MOUSE_HACK_5 |
 			HID_QUIRK_2WHEEL_MOUSE_HACK_B8)) && (usage->type == EV_REL) &&
 			(usage->code == REL_WHEEL))

commit 5f22a7992349c5ca3842190be52d5e9a1dd7adf4
Author: Jiri Slaby <jirislaby@gmail.com>
Date:   Fri May 16 11:49:19 2008 +0200

    HID: move logitech quirks
    
    Move them from the core and input code to a separate driver.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index be2c7a8ad254..4f2bac010f59 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -58,19 +58,6 @@ static const unsigned char hid_keyboard[256] = {
 	150,158,159,128,136,177,178,176,142,152,173,140,unk,unk,unk,unk
 };
 
-/* extended mapping for certain Logitech hardware (Logitech cordless desktop LX500) */
-#define LOGITECH_EXPANDED_KEYMAP_SIZE 80
-static int logitech_expanded_keymap[LOGITECH_EXPANDED_KEYMAP_SIZE] = {
-	  0,216,  0,213,175,156,  0,  0,  0,  0,
-	144,  0,  0,  0,  0,  0,  0,  0,  0,212,
-	174,167,152,161,112,  0,  0,  0,154,  0,
-	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-	  0,  0,  0,  0,  0,183,184,185,186,187,
-	188,189,190,191,192,193,194,  0,  0,  0
-};
-
 static const struct {
 	__s32 x;
 	__s32 y;
@@ -437,21 +424,6 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 					}
 			}
 
-			/* Special handling for Logitech Cordless Desktop */
-			if (field->application != HID_GD_MOUSE) {
-				if (device->quirks & HID_QUIRK_LOGITECH_EXPANDED_KEYMAP) {
-					int hid = usage->hid & HID_USAGE;
-					if (hid < LOGITECH_EXPANDED_KEYMAP_SIZE && logitech_expanded_keymap[hid] != 0)
-						code = logitech_expanded_keymap[hid];
-				}
-			} else {
-				if (device->quirks & HID_QUIRK_LOGITECH_IGNORE_DOUBLED_WHEEL) {
-					int hid = usage->hid & HID_USAGE;
-					if (hid == 7 || hid == 8)
-						goto ignore;
-				}
-			}
-
 			map_key(code);
 			break;
 
@@ -788,18 +760,8 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 		|| ((device->quirks & HID_QUIRK_2WHEEL_MOUSE_HACK_7) && (usage->hid == 0x00090007)))
 		goto ignore;
 
-	if ((device->quirks & HID_QUIRK_BAD_RELATIVE_KEYS) &&
-		usage->type == EV_KEY && (field->flags & HID_MAIN_ITEM_RELATIVE))
-		field->flags &= ~HID_MAIN_ITEM_RELATIVE;
-
 	set_bit(usage->type, input->evbit);
 
-	if (device->quirks & HID_QUIRK_DUPLICATE_USAGES &&
-			(usage->type == EV_KEY ||
-			 usage->type == EV_REL ||
-			 usage->type == EV_ABS))
-		clear_bit(usage->code, bit);
-
 	while (usage->code <= max && test_and_set_bit(usage->code, bit))
 		usage->code = find_next_zero_bit(bit, max + 1, usage->code);
 

commit 022e8c4d08b3b06361594b60412db0242035c4b4
Author: Jiri Slaby <jirislaby@gmail.com>
Date:   Fri May 16 11:49:18 2008 +0200

    HID: move usage input mapping to hid.h
    
    This mapping are currently used on 2 placces and will be needed by more
    quirk drivers, so move them to hid.h to allow them to use it.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 9fa7239ab310..be2c7a8ad254 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -76,13 +76,15 @@ static const struct {
 	__s32 y;
 }  hid_hat_to_axis[] = {{ 0, 0}, { 0,-1}, { 1,-1}, { 1, 0}, { 1, 1}, { 0, 1}, {-1, 1}, {-1, 0}, {-1,-1}};
 
-#define map_abs(c)	do { usage->code = c; usage->type = EV_ABS; bit = input->absbit; max = ABS_MAX; } while (0)
-#define map_rel(c)	do { usage->code = c; usage->type = EV_REL; bit = input->relbit; max = REL_MAX; } while (0)
-#define map_key(c)	do { usage->code = c; usage->type = EV_KEY; bit = input->keybit; max = KEY_MAX; } while (0)
-#define map_led(c)	do { usage->code = c; usage->type = EV_LED; bit = input->ledbit; max = LED_MAX; } while (0)
+#define map_abs(c)	hid_map_usage(hidinput, usage, &bit, &max, EV_ABS, (c))
+#define map_rel(c)	hid_map_usage(hidinput, usage, &bit, &max, EV_REL, (c))
+#define map_key(c)	hid_map_usage(hidinput, usage, &bit, &max, EV_KEY, (c))
+#define map_led(c)	hid_map_usage(hidinput, usage, &bit, &max, EV_LED, (c))
 
-#define map_abs_clear(c)	do { map_abs(c); clear_bit(c, bit); } while (0)
-#define map_key_clear(c)	do { map_key(c); clear_bit(c, bit); } while (0)
+#define map_abs_clear(c)	hid_map_usage_clear(hidinput, usage, &bit, \
+		&max, EV_ABS, (c))
+#define map_key_clear(c)	hid_map_usage_clear(hidinput, usage, &bit, \
+		&max, EV_KEY, (c))
 
 #ifdef CONFIG_USB_HIDINPUT_POWERBOOK
 
@@ -386,7 +388,7 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 	}
 
 	/* handle input mappings for quirky devices */
-	ret = hidinput_mapping_quirks(usage, input, &bit, &max);
+	ret = hidinput_mapping_quirks(usage, hidinput, &bit, &max);
 	if (ret)
 		goto mapped;
 

commit c500c9714011edab021591340042787722db9cf0
Author: Jiri Slaby <jirislaby@gmail.com>
Date:   Fri May 16 11:49:16 2008 +0200

    HID: hid, make parsing event driven
    
    Next step for complete hid bus, this patch includes:
    - call parser either from probe or from hid-core if there is no probe.
    - add ll_driver structure and centralize some stuff there (open, close...)
    - split and merge usb_hid_configure and hid_probe into several functions
      to allow hooks/fixes between them
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 4ae5603804e7..9fa7239ab310 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -390,6 +390,15 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 	if (ret)
 		goto mapped;
 
+	if (device->driver->input_mapping) {
+		int ret = device->driver->input_mapping(device, hidinput, field,
+				usage, &bit, &max);
+		if (ret > 0)
+			goto mapped;
+		if (ret < 0)
+			goto ignore;
+	}
+
 	switch (usage->hid & HID_USAGE_PAGE) {
 
 		case HID_UP_UNDEFINED:
@@ -755,6 +764,10 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 	}
 
 mapped:
+	if (device->driver->input_mapped && device->driver->input_mapped(device,
+				hidinput, field, usage, &bit, &max) < 0)
+		goto ignore;
+
 	if (device->quirks & HID_QUIRK_MIGHTYMOUSE) {
 		if (usage->hid == HID_GD_Z)
 			map_rel(REL_HWHEEL);
@@ -961,14 +974,14 @@ static int hidinput_open(struct input_dev *dev)
 {
 	struct hid_device *hid = input_get_drvdata(dev);
 
-	return hid->hid_open(hid);
+	return hid->ll_driver->open(hid);
 }
 
 static void hidinput_close(struct input_dev *dev)
 {
 	struct hid_device *hid = input_get_drvdata(dev);
 
-	hid->hid_close(hid);
+	hid->ll_driver->close(hid);
 }
 
 /*
@@ -1019,7 +1032,8 @@ int hidinput_connect(struct hid_device *hid)
 				}
 
 				input_set_drvdata(input_dev, hid);
-				input_dev->event = hid->hidinput_input_event;
+				input_dev->event =
+					hid->ll_driver->hidinput_input_event;
 				input_dev->open = hidinput_open;
 				input_dev->close = hidinput_close;
 				input_dev->setkeycode = hidinput_setkeycode;

commit 85cdaf524b7ddab627e7d15405693f2511ef7505
Author: Jiri Slaby <jirislaby@gmail.com>
Date:   Fri May 16 11:49:15 2008 +0200

    HID: make a bus from hid code
    
    Make a bus from hid core. This is the first step for converting all the
    quirks and separate almost-drivers into real drivers attached to this bus.
    
    It's implemented to change behaviour in very tiny manner, so that no driver
    needs to be changed this time.
    
    Also add generic drivers for both usb and bt into usbhid or hidp
    respectively which will bind all non-blacklisted device. Those blacklisted
    will be either grabbed by special drivers or by nobody if they are broken at
    the very rude base.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 1b2e8dc3398d..4ae5603804e7 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -1032,7 +1032,7 @@ int hidinput_connect(struct hid_device *hid)
 				input_dev->id.vendor  = hid->vendor;
 				input_dev->id.product = hid->product;
 				input_dev->id.version = hid->version;
-				input_dev->dev.parent = hid->dev;
+				input_dev->dev.parent = hid->dev.parent;
 				hidinput->input = input_dev;
 				list_add_tail(&hidinput->list, &hid->inputs);
 			}

commit 6a250778c79d6d14db9ed8e1f86f7b934e2bf3dc
Author: Henrik Rydberg <rydberg@euromail.se>
Date:   Tue Jul 22 15:54:05 2008 +0200

    HID: apple_fn_keys F5 and F6
    
    In drivers/hid/hid-input.c, the apple_fn_keys translation table
    contains no entries for the F5 and F6 keys. This patch maps the F5 and
    F6 keys to KBDILLUMDOWN and KBDILLUMUP, respektively, which make them
    work as keyboard backlight control keys.
    
    Signed-off-by: Henrik Rydberg <rydberg@euromail.se>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 0ef778aee990..1b2e8dc3398d 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -100,6 +100,8 @@ static struct hidinput_key_translation apple_fn_keys[] = {
 	{ KEY_F2,       KEY_BRIGHTNESSUP,   APPLE_FLAG_FKEY },
 	{ KEY_F3,       KEY_FN_F5,          APPLE_FLAG_FKEY }, /* Exposé */
 	{ KEY_F4,       KEY_FN_F4,          APPLE_FLAG_FKEY }, /* Dashboard */
+	{ KEY_F5,       KEY_KBDILLUMDOWN,   APPLE_FLAG_FKEY },
+	{ KEY_F6,       KEY_KBDILLUMUP,     APPLE_FLAG_FKEY },
 	{ KEY_F7,       KEY_PREVIOUSSONG,   APPLE_FLAG_FKEY },
 	{ KEY_F8,       KEY_PLAYPAUSE,      APPLE_FLAG_FKEY },
 	{ KEY_F9,       KEY_NEXTSONG,       APPLE_FLAG_FKEY },

commit 094403ce3ec30e9819b1526134a948a1c92d1421
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Fri Jul 4 12:48:20 2008 -0400

    HID: Add mapping of new KEY_MEDIA_REPEAT keycode
    
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 5c52a20ad344..0ef778aee990 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -612,6 +612,7 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 				case 0x0b6: map_key_clear(KEY_PREVIOUSSONG);	break;
 				case 0x0b7: map_key_clear(KEY_STOPCD);		break;
 				case 0x0b8: map_key_clear(KEY_EJECTCD);		break;
+				case 0x0bc: map_key_clear(KEY_MEDIA_REPEAT);	break;
 
 				case 0x0cd: map_key_clear(KEY_PLAYPAUSE);	break;
 			        case 0x0e0: map_abs_clear(ABS_VOLUME);		break;

commit f8dea7a3d47ee7c857965b22e33229e7de410a88
Author: Adrian Bunk <bunk@kernel.org>
Date:   Tue May 20 01:31:25 2008 +0200

    HID: remove CVS keywords
    
    This patch removes CVS keywords that weren't updated for a long time
    from comments.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 452b94dd7401..5c52a20ad344 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -1,6 +1,4 @@
 /*
- * $Id: hid-input.c,v 1.2 2002/04/23 00:59:25 rdamazio Exp $
- *
  *  Copyright (c) 2000-2001 Vojtech Pavlik
  *  Copyright (c) 2006-2007 Jiri Kosina
  *

commit 6e7045990f35ef9250804b3fd85e855b8c2aaeb6
Author: Diego 'Flameeyes' Petteno <flameeyes@gmail.com>
Date:   Mon May 5 16:20:50 2008 +0200

    HID: split Numlock emulation quirk from HID_QUIRK_APPLE_HAS_FN.
    
    Since 2.6.25 the HID_QUIRK_APPLE_HAS_FN quirk is enabled even for
    non-laptop Apple keyboards of the Aluminium series. The USB version of
    these don't need Numlock emulation, like the laptop (and Aluminium
    Wireless) do, as they have a proper keypad.
    
    This patch splits the Numlock emulation for Apple keyboards in a
    different quirk flag, so that it can be enabled for all the keyboards
    but the Aluminium USB ones.
    
    If the Numlock emulation is enabled for Aluminium USB keyboards, the
    JKL and UIO keys become the numeric pad, and the rest of the keyboard
    is disabled, included the key used to disable Numlock.
    
    Additionally, these keyboard should not have a Numlock at all, as the
    Numlock key is instead replaced by the 'Clear' key as usual for Apple
    USB keyboards.
    
    Signed-off-by: Diego 'Flameeyes' Petteno <flameeyes@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index c3eb3f13e2ca..452b94dd7401 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -218,8 +218,9 @@ int hidinput_apple_event(struct hid_device *hid, struct input_dev *input,
 			}
 		}
 
-		if (test_bit(usage->code, hid->pb_pressed_numlock) ||
-				test_bit(LED_NUML, input->led)) {
+		if (hid->quirks & HID_QUIRK_APPLE_NUMLOCK_EMULATION && (
+				test_bit(usage->code, hid->pb_pressed_numlock) ||
+				test_bit(LED_NUML, input->led))) {
 			trans = find_translation(powerbook_numlock_keys, usage->code);
 
 			if (trans) {

commit 07146648bc6ea8b1530644c8a41bef55f1b2d952
Author: Michael Hanselmann <linux-kernel@hansmi.ch>
Date:   Mon Mar 17 22:23:52 2008 +0100

    HID: update key codes for Apple aluminium
    
    F5 and F6 have no second function printed on them. Thus their definitions have
    been removed from the table.
    
    KEY_CYCLEWINDOWS doesn't name the function of Mac OS X' Expose properly and
    because we couldn't find a better key code, we decided to use KEY_FN_F4
    instead.
    
    We also changed KEY_BACK and KEY_FORWARD, which apply to browser functions, to
    KEY_PREVIOUSSONG and KEY_NEXTSONG, since the keys are intended to control a
    music player.
    
    Signed-off-by: Michael Hanselmann <linux-kernel@hansmi.ch>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 5a38fb27d69f..c3eb3f13e2ca 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -98,18 +98,16 @@ struct hidinput_key_translation {
 
 static struct hidinput_key_translation apple_fn_keys[] = {
 	{ KEY_BACKSPACE, KEY_DELETE },
-	{ KEY_F1,       KEY_BRIGHTNESSDOWN,     APPLE_FLAG_FKEY },
-	{ KEY_F2,       KEY_BRIGHTNESSUP,       APPLE_FLAG_FKEY },
-	{ KEY_F3,       KEY_CYCLEWINDOWS,       APPLE_FLAG_FKEY }, /* ExposÃ© */
-	{ KEY_F4,       KEY_FN_F4,              APPLE_FLAG_FKEY }, /* Dashboard */
-	{ KEY_F5,       KEY_FN_F5 },
-	{ KEY_F6,       KEY_FN_F6 },
-	{ KEY_F7,       KEY_BACK,               APPLE_FLAG_FKEY },
-	{ KEY_F8,       KEY_PLAYPAUSE,          APPLE_FLAG_FKEY },
-	{ KEY_F9,       KEY_FORWARD,            APPLE_FLAG_FKEY },
-	{ KEY_F10,      KEY_MUTE,               APPLE_FLAG_FKEY },
-	{ KEY_F11,      KEY_VOLUMEDOWN,         APPLE_FLAG_FKEY },
-	{ KEY_F12,      KEY_VOLUMEUP,           APPLE_FLAG_FKEY },
+	{ KEY_F1,       KEY_BRIGHTNESSDOWN, APPLE_FLAG_FKEY },
+	{ KEY_F2,       KEY_BRIGHTNESSUP,   APPLE_FLAG_FKEY },
+	{ KEY_F3,       KEY_FN_F5,          APPLE_FLAG_FKEY }, /* Exposé */
+	{ KEY_F4,       KEY_FN_F4,          APPLE_FLAG_FKEY }, /* Dashboard */
+	{ KEY_F7,       KEY_PREVIOUSSONG,   APPLE_FLAG_FKEY },
+	{ KEY_F8,       KEY_PLAYPAUSE,      APPLE_FLAG_FKEY },
+	{ KEY_F9,       KEY_NEXTSONG,       APPLE_FLAG_FKEY },
+	{ KEY_F10,      KEY_MUTE,           APPLE_FLAG_FKEY },
+	{ KEY_F11,      KEY_VOLUMEDOWN,     APPLE_FLAG_FKEY },
+	{ KEY_F12,      KEY_VOLUMEUP,       APPLE_FLAG_FKEY },
 	{ KEY_UP,       KEY_PAGEUP },
 	{ KEY_DOWN,     KEY_PAGEDOWN },
 	{ KEY_LEFT,     KEY_HOME },

commit 5906a0448208024d140e1ee0e65f9168a405fb94
Author: Tobias Mueller <Tobias_Mueller@twam.info>
Date:   Wed Feb 13 17:08:04 2008 +0100

    HID: add USB IDs for MacBook 3rd generation
    
    Add support for Macbook 3rd generation special mappings.
    
    Signed-off-by: Tobias Mueller <Tobias_Mueller@twam.info>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 43342785110c..5a38fb27d69f 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -97,6 +97,7 @@ struct hidinput_key_translation {
 #define APPLE_FLAG_FKEY 0x01
 
 static struct hidinput_key_translation apple_fn_keys[] = {
+	{ KEY_BACKSPACE, KEY_DELETE },
 	{ KEY_F1,       KEY_BRIGHTNESSDOWN,     APPLE_FLAG_FKEY },
 	{ KEY_F2,       KEY_BRIGHTNESSUP,       APPLE_FLAG_FKEY },
 	{ KEY_F3,       KEY_CYCLEWINDOWS,       APPLE_FLAG_FKEY }, /* ExposÃ© */
@@ -109,6 +110,10 @@ static struct hidinput_key_translation apple_fn_keys[] = {
 	{ KEY_F10,      KEY_MUTE,               APPLE_FLAG_FKEY },
 	{ KEY_F11,      KEY_VOLUMEDOWN,         APPLE_FLAG_FKEY },
 	{ KEY_F12,      KEY_VOLUMEUP,           APPLE_FLAG_FKEY },
+	{ KEY_UP,       KEY_PAGEUP },
+	{ KEY_DOWN,     KEY_PAGEDOWN },
+	{ KEY_LEFT,     KEY_HOME },
+	{ KEY_RIGHT,    KEY_END },
 	{ }
 };
 

commit 68a1f2cc8676f22a6fd49f344f99e326eb7f5117
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Thu Feb 7 16:48:46 2008 +0100

    HID: fix processing of event quirks
    
    The old code (before move) stopped further processing of the
    event after it has been already processed by the quirk handler.
    
    The new code didn't propagate the return value properly, and
    therefore the processing always proceeded, which was wrong.
    
    This patch fixes it. Pointed out in kernel.org bugzilla #9842
    
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 5325d98b4328..43342785110c 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -854,7 +854,8 @@ void hidinput_hid_event(struct hid_device *hid, struct hid_field *field, struct
 		return;
 
 	/* handle input events for quirky devices */
-	hidinput_event_quirks(hid, field, usage, value);
+	if (hidinput_event_quirks(hid, field, usage, value))
+		return;
 
 	if (usage->hat_min < usage->hat_max || usage->hat_dir) {
 		int hat_dir = usage->hat_dir;

commit 70d215c4a7dfbddc138a2dd726d8f80f3e6d2622
Author: Fengguang Wu <wfg@mail.ustc.edu.cn>
Date:   Fri Dec 7 16:35:14 2007 +0800

    HID: the `bit' in hidinput_mapping_quirks() is an out parameter
    
    Fix a panic, by changing
            hidinput_mapping_quirks(,, unsigned long *bit,)
    to
            hidinput_mapping_quirks(,, unsigned long **bit,)
    
    The `bit' in this function is an out parameter.
    
    Signed-off-by: Fengguang Wu <wfg@mail.ustc.edu.cn>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index aeb018e31bfc..5325d98b4328 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -382,7 +382,7 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 	}
 
 	/* handle input mappings for quirky devices */
-	ret = hidinput_mapping_quirks(usage, input, bit, &max);
+	ret = hidinput_mapping_quirks(usage, input, &bit, &max);
 	if (ret)
 		goto mapped;
 

commit 87bc2aa9933afc032a93490e1642918121e7470b
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Fri Nov 23 13:16:02 2007 +0100

    HID: separate hid-input event quirks from generic code
    
    This patch separates also the hid-input quirks that have to be
    applied at the time the event occurs, so that the generic code
    handling HUT-compliant devices is not messed up by them too much.
    
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 3d448037c82f..aeb018e31bfc 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -86,11 +86,6 @@ static const struct {
 #define map_abs_clear(c)	do { map_abs(c); clear_bit(c, bit); } while (0)
 #define map_key_clear(c)	do { map_key(c); clear_bit(c, bit); } while (0)
 
-/* hardware needing special handling due to colliding MSVENDOR page usages */
-#define IS_CHICONY_TACTICAL_PAD(x) (x->vendor == 0x04f2 && device->product == 0x0418)
-#define IS_MS_KB(x) (x->vendor == 0x045e && (x->product == 0x00db || x->product == 0x00f9))
-#define IS_MS_PRESENTER_8000(x) (x->vendor == 0x045e && x->product == 0x0713)
-
 #ifdef CONFIG_USB_HIDINPUT_POWERBOOK
 
 struct hidinput_key_translation {
@@ -177,7 +172,7 @@ static struct hidinput_key_translation *find_translation(struct hidinput_key_tra
 	return NULL;
 }
 
-static int hidinput_apple_event(struct hid_device *hid, struct input_dev *input,
+int hidinput_apple_event(struct hid_device *hid, struct input_dev *input,
 		struct hid_usage *usage, __s32 value)
 {
 	struct hidinput_key_translation *trans;
@@ -269,7 +264,7 @@ static void hidinput_apple_setup(struct input_dev *input)
 
 }
 #else
-static inline int hidinput_apple_event(struct hid_device *hid,
+inline int hidinput_apple_event(struct hid_device *hid,
 				       struct input_dev *input,
 				       struct hid_usage *usage, __s32 value)
 {
@@ -386,6 +381,7 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 		goto ignore;
 	}
 
+	/* handle input mappings for quirky devices */
 	ret = hidinput_mapping_quirks(usage, input, bit, &max);
 	if (ret)
 		goto mapped;
@@ -857,38 +853,8 @@ void hidinput_hid_event(struct hid_device *hid, struct hid_field *field, struct
 	if (!usage->type)
 		return;
 
-	if (((hid->quirks & HID_QUIRK_2WHEEL_MOUSE_HACK_5) && (usage->hid == 0x00090005))
-		|| ((hid->quirks & HID_QUIRK_2WHEEL_MOUSE_HACK_7) && (usage->hid == 0x00090007))) {
-		if (value) hid->quirks |=  HID_QUIRK_2WHEEL_MOUSE_HACK_ON;
-		else       hid->quirks &= ~HID_QUIRK_2WHEEL_MOUSE_HACK_ON;
-		return;
-	}
-
-	if ((hid->quirks & HID_QUIRK_2WHEEL_MOUSE_HACK_B8) &&
-			(usage->type == EV_REL) &&
-			(usage->code == REL_WHEEL)) {
-		hid->delayed_value = value;
-		return;
-	}
-
-	if ((hid->quirks & HID_QUIRK_2WHEEL_MOUSE_HACK_B8) &&
-			(usage->hid == 0x000100b8)) {
-		input_event(input, EV_REL, value ? REL_HWHEEL : REL_WHEEL, hid->delayed_value);
-		return;
-	}
-
-	if ((hid->quirks & HID_QUIRK_INVERT_HWHEEL) && (usage->code == REL_HWHEEL)) {
-		input_event(input, usage->type, usage->code, -value);
-		return;
-	}
-
-	if ((hid->quirks & HID_QUIRK_2WHEEL_MOUSE_HACK_ON) && (usage->code == REL_WHEEL)) {
-		input_event(input, usage->type, REL_HWHEEL, value);
-		return;
-	}
-
-	if ((hid->quirks & HID_QUIRK_APPLE_HAS_FN) && hidinput_apple_event(hid, input, usage, value))
-		return;
+	/* handle input events for quirky devices */
+	hidinput_event_quirks(hid, field, usage, value);
 
 	if (usage->hat_min < usage->hat_max || usage->hat_dir) {
 		int hat_dir = usage->hat_dir;
@@ -949,25 +915,6 @@ void hidinput_hid_event(struct hid_device *hid, struct hid_field *field, struct
 		return;
 	}
 
-	/* Handling MS keyboards special buttons */
-	if (IS_MS_KB(hid) && usage->hid == (HID_UP_MSVENDOR | 0xff05)) {
-		int key = 0;
-		static int last_key = 0;
-		switch (value) {
-			case 0x01: key = KEY_F14; break;
-			case 0x02: key = KEY_F15; break;
-			case 0x04: key = KEY_F16; break;
-			case 0x08: key = KEY_F17; break;
-			case 0x10: key = KEY_F18; break;
-			default: break;
-		}
-		if (key) {
-			input_event(input, usage->type, key, 1);
-			last_key = key;
-		} else {
-			input_event(input, usage->type, last_key, 0);
-		}
-	}
 	/* report the usage code as scancode if the key status has changed */
 	if (usage->type == EV_KEY && !!test_bit(usage->code, input->key) != value)
 		input_event(input, EV_MSC, MSC_SCAN, usage->hid);

commit 10bd065facb2594bd508597ef464d401b212f379
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Thu Nov 22 15:18:18 2007 +0100

    HID: refactor mapping to input subsystem for quirky devices
    
    Currently, the handling of mapping between hid and input for devices
    that don't conform to HUT 1.12 specification is very messy -- no per-device
    handling, no blacklists, conditions on idVendor and idProduct placed
    all over the code.
    
    This patch moves all the device-specific input mapping to a separate
    file, and introduces a blacklist-style handling for non-standard
    device-specific mappings.
    
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 0da29cf43713..3d448037c82f 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -367,7 +367,7 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 {
 	struct input_dev *input = hidinput->input;
 	struct hid_device *device = input_get_drvdata(input);
-	int max = 0, code;
+	int max = 0, code, ret;
 	unsigned long *bit = NULL;
 
 	field->hidinput = hidinput;
@@ -386,6 +386,10 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 		goto ignore;
 	}
 
+	ret = hidinput_mapping_quirks(usage, input, bit, &max);
+	if (ret)
+		goto mapped;
+
 	switch (usage->hid & HID_USAGE_PAGE) {
 
 		case HID_UP_UNDEFINED:
@@ -573,14 +577,6 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 				case 0x000: goto ignore;
 				case 0x034: map_key_clear(KEY_SLEEP);		break;
 				case 0x036: map_key_clear(BTN_MISC);		break;
-				/*
-				 * The next three are reported by Belkin wireless
-				 * keyboard (1020:0006). These values are "reserved"
-				 * in HUT 1.12.
-				 */
-				case 0x03a: map_key_clear(KEY_SOUND);           break;
-				case 0x03b: map_key_clear(KEY_CAMERA);          break;
-				case 0x03c: map_key_clear(KEY_DOCUMENTS);       break;
 
 				case 0x040: map_key_clear(KEY_MENU);		break;
 				case 0x045: map_key_clear(KEY_RADIO);		break;
@@ -626,16 +622,6 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 				case 0x0e9: map_key_clear(KEY_VOLUMEUP);	break;
 				case 0x0ea: map_key_clear(KEY_VOLUMEDOWN);	break;
 
-				/* reserved in HUT 1.12. Reported on Petalynx remote */
-				case 0x0f6: map_key_clear(KEY_NEXT);		break;
-				case 0x0fa: map_key_clear(KEY_BACK);		break;
-
-				/* reserved in HUT 1.12. Reported on Genius KB29E */
-				case 0x156: map_key_clear(KEY_WORDPROCESSOR);	break;
-				case 0x157: map_key_clear(KEY_SPREADSHEET);	break;
-				case 0x158: map_key_clear(KEY_PRESENTATION);	break;
-				case 0x15c: map_key_clear(KEY_STOP);		break;
-
 				case 0x182: map_key_clear(KEY_BOOKMARKS);	break;
 				case 0x183: map_key_clear(KEY_CONFIG);		break;
 				case 0x184: map_key_clear(KEY_WORDPROCESSOR);	break;
@@ -695,51 +681,6 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 				case 0x28b: map_key_clear(KEY_FORWARDMAIL);	break;
 				case 0x28c: map_key_clear(KEY_SEND);		break;
 
-				/* Reported on a Cherry Cymotion keyboard */
-				case 0x301: map_key_clear(KEY_PROG1);		break;
-				case 0x302: map_key_clear(KEY_PROG2);		break;
-				case 0x303: map_key_clear(KEY_PROG3);		break;
-
-				/* Reported on certain Logitech wireless keyboards */
-				case 0x1001: map_key_clear(KEY_MESSENGER);	break;
-				case 0x1003: map_key_clear(KEY_SOUND);		break;
-				case 0x1004: map_key_clear(KEY_VIDEO);		break;
-				case 0x1005: map_key_clear(KEY_AUDIO);		break;
-				case 0x100a: map_key_clear(KEY_DOCUMENTS);	break;
-				case 0x1011: map_key_clear(KEY_PREVIOUSSONG);	break;
-				case 0x1012: map_key_clear(KEY_NEXTSONG);	break;
-				case 0x1013: map_key_clear(KEY_CAMERA);		break;
-				case 0x1014: map_key_clear(KEY_MESSENGER);	break;
-				case 0x1015: map_key_clear(KEY_RECORD);		break;
-				case 0x1016: map_key_clear(KEY_PLAYER);		break;
-				case 0x1017: map_key_clear(KEY_EJECTCD);	break;
-				case 0x1018: map_key_clear(KEY_MEDIA);          break;
-				case 0x1019: map_key_clear(KEY_PROG1);		break;
-				case 0x101a: map_key_clear(KEY_PROG2);		break;
-				case 0x101b: map_key_clear(KEY_PROG3);		break;
-				case 0x101f: map_key_clear(KEY_ZOOMIN);		break;
-				case 0x1020: map_key_clear(KEY_ZOOMOUT);	break;
-				case 0x1021: map_key_clear(KEY_ZOOMRESET);	break;
-				case 0x1023: map_key_clear(KEY_CLOSE);		break;
-				case 0x1027: map_key_clear(KEY_MENU);           break;
-				/* this one is marked as 'Rotate' */
-				case 0x1028: map_key_clear(KEY_ANGLE);		break;
-				case 0x1029: map_key_clear(KEY_SHUFFLE);	break;
-				case 0x102a: map_key_clear(KEY_BACK);           break;
-				case 0x102b: map_key_clear(KEY_CYCLEWINDOWS);   break;
-				case 0x1041: map_key_clear(KEY_BATTERY);	break;
-				case 0x1042: map_key_clear(KEY_WORDPROCESSOR);	break;
-				case 0x1043: map_key_clear(KEY_SPREADSHEET);	break;
-				case 0x1044: map_key_clear(KEY_PRESENTATION);	break;
-				case 0x1045: map_key_clear(KEY_UNDO);		break;
-				case 0x1046: map_key_clear(KEY_REDO);		break;
-				case 0x1047: map_key_clear(KEY_PRINT);		break;
-				case 0x1048: map_key_clear(KEY_SAVE);		break;
-				case 0x1049: map_key_clear(KEY_PROG1);		break;
-				case 0x104a: map_key_clear(KEY_PROG2);		break;
-				case 0x104b: map_key_clear(KEY_PROG3);		break;
-				case 0x104c: map_key_clear(KEY_PROG4);		break;
-
 				default:    goto ignore;
 			}
 			break;
@@ -766,65 +707,7 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 
 		case HID_UP_MSVENDOR:
 
-			/* Unfortunately, there are multiple devices which
-			 * emit usages from MSVENDOR page that require different
-			 * handling. If this list grows too much in the future,
-			 * more general handling will have to be introduced here
-			 * (i.e. another blacklist).
-			 */
-
-			/* Chicony Chicony KU-0418 tactical pad */
-			if (IS_CHICONY_TACTICAL_PAD(device)) {
-				set_bit(EV_REP, input->evbit);
-				switch(usage->hid & HID_USAGE) {
-					case 0xff01: map_key_clear(BTN_1);		break;
-					case 0xff02: map_key_clear(BTN_2);		break;
-					case 0xff03: map_key_clear(BTN_3);		break;
-					case 0xff04: map_key_clear(BTN_4);		break;
-					case 0xff05: map_key_clear(BTN_5);		break;
-					case 0xff06: map_key_clear(BTN_6);		break;
-					case 0xff07: map_key_clear(BTN_7);		break;
-					case 0xff08: map_key_clear(BTN_8);		break;
-					case 0xff09: map_key_clear(BTN_9);		break;
-					case 0xff0a: map_key_clear(BTN_A);		break;
-					case 0xff0b: map_key_clear(BTN_B);		break;
-					default:    goto ignore;
-				}
-
-			/* Microsoft Natural Ergonomic Keyboard 4000 */
-			} else if (IS_MS_KB(device)) {
-				switch(usage->hid & HID_USAGE) {
-					case 0xfd06:
-						map_key_clear(KEY_CHAT);
-						break;
-					case 0xfd07:
-						map_key_clear(KEY_PHONE);
-						break;
-					case 0xff05:
-						set_bit(EV_REP, input->evbit);
-						map_key_clear(KEY_F13);
-						set_bit(KEY_F14, input->keybit);
-						set_bit(KEY_F15, input->keybit);
-						set_bit(KEY_F16, input->keybit);
-						set_bit(KEY_F17, input->keybit);
-						set_bit(KEY_F18, input->keybit);
-					default:	goto ignore;
-				}
-
-			/* Microsoft Wireless Notebook Presenter Mouse 8000 */
-			} else if (IS_MS_PRESENTER_8000(device)) {
-				set_bit(EV_REP, input->evbit);
-				switch(usage->hid & HID_USAGE) {
-					/* Useful mappings of bottom-side keys for presentations */
-					case 0xfd08: map_key_clear(KEY_RIGHT);		break;
-					case 0xfd09: map_key_clear(KEY_LEFT);		break;
-					case 0xfd0b: map_key_clear(KEY_PAUSE);		break;
-					case 0xfd0f: map_key_clear(KEY_F5);		break;
-					default:    goto ignore;
-				}
-			} else
-				goto ignore;
-			break;
+			goto ignore;
 
 		case HID_UP_CUSTOM: /* Reported on Logitech and Apple USB keyboards */
 
@@ -841,38 +724,9 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 			break;
 
 		case HID_UP_LOGIVENDOR:
-			set_bit(EV_REP, input->evbit);
-			switch(usage->hid & HID_USAGE) {
-				/* Reported on Logitech Ultra X Media Remote */
-				case 0x004: map_key_clear(KEY_AGAIN);		break;
-				case 0x00d: map_key_clear(KEY_HOME);		break;
-				case 0x024: map_key_clear(KEY_SHUFFLE);		break;
-				case 0x025: map_key_clear(KEY_TV);		break;
-				case 0x026: map_key_clear(KEY_MENU);		break;
-				case 0x031: map_key_clear(KEY_AUDIO);		break;
-				case 0x032: map_key_clear(KEY_TEXT);		break;
-				case 0x033: map_key_clear(KEY_LAST);		break;
-				case 0x047: map_key_clear(KEY_MP3);		break;
-				case 0x048: map_key_clear(KEY_DVD);		break;
-				case 0x049: map_key_clear(KEY_MEDIA);		break;
-				case 0x04a: map_key_clear(KEY_VIDEO);		break;
-				case 0x04b: map_key_clear(KEY_ANGLE);		break;
-				case 0x04c: map_key_clear(KEY_LANGUAGE);	break;
-				case 0x04d: map_key_clear(KEY_SUBTITLE);	break;
-				case 0x051: map_key_clear(KEY_RED);		break;
-				case 0x052: map_key_clear(KEY_CLOSE);		break;
-
-				/* Reported on Petalynx Maxter remote */
-				case 0x05a: map_key_clear(KEY_TEXT);		break;
-				case 0x05b: map_key_clear(KEY_RED);		break;
-				case 0x05c: map_key_clear(KEY_GREEN);		break;
-				case 0x05d: map_key_clear(KEY_YELLOW);		break;
-				case 0x05e: map_key_clear(KEY_BLUE);		break;
-
-				default:    goto ignore;
-			}
-			break;
 
+			goto ignore;
+		
 		case HID_UP_PID:
 
 			switch(usage->hid & HID_USAGE) {
@@ -899,6 +753,7 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 			break;
 	}
 
+mapped:
 	if (device->quirks & HID_QUIRK_MIGHTYMOUSE) {
 		if (usage->hid == HID_GD_Z)
 			map_rel(REL_HWHEEL);

commit af9e0eacdc072ba28fd139b90de27023d9cb0598
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Wed Nov 14 12:13:26 2007 +0100

    HID: add full support for Genius KB-29E
    
    Genius KB-29E has broken report descriptor, which causes some of the
    Consumer usages to appear incorrectly as Button usages. We fix it by
    fixing the report descriptor before it is being parsed.
    
    Also a few of the keys violate the HUT standard, so they need a special
    handling. They currently fall into "Reserved" range as per HUT 1.12.
    
    Reported-by: Szekeres Istvan <szekeres@iii.hu>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index de270b16bde3..0da29cf43713 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -630,6 +630,12 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 				case 0x0f6: map_key_clear(KEY_NEXT);		break;
 				case 0x0fa: map_key_clear(KEY_BACK);		break;
 
+				/* reserved in HUT 1.12. Reported on Genius KB29E */
+				case 0x156: map_key_clear(KEY_WORDPROCESSOR);	break;
+				case 0x157: map_key_clear(KEY_SPREADSHEET);	break;
+				case 0x158: map_key_clear(KEY_PRESENTATION);	break;
+				case 0x15c: map_key_clear(KEY_STOP);		break;
+
 				case 0x182: map_key_clear(KEY_BOOKMARKS);	break;
 				case 0x183: map_key_clear(KEY_CONFIG);		break;
 				case 0x184: map_key_clear(KEY_WORDPROCESSOR);	break;

commit c80e5ffac0579499ca28444155118ffcdd9b8d7e
Author: Pavel Troller <patrol@sinus.cz>
Date:   Mon Oct 29 11:13:46 2007 +0100

    HID: Implement horizontal wheel handling for A4 Tech X5-005D
    
    This mouse distinguishes horizontal wheel from vertical by a special "pseudo
    event" GenericDesktop.00b8, with values of 0 for vertical and 8 for horizontal
    wheel. Because this event is supplied by the parser too late, we need to delay
    a wheel event, wait for this one and send either REL_WHEEL or REL_HWHEEL to
    input depending on the event value.
    
    Signed-off-by: Pavel Troller <patrol@sinus.cz>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 8c4c908177fa..de270b16bde3 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -902,9 +902,10 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 			map_key(BTN_1);
 	}
 
-	if ((device->quirks & (HID_QUIRK_2WHEEL_MOUSE_HACK_7 | HID_QUIRK_2WHEEL_MOUSE_HACK_5)) &&
-		 (usage->type == EV_REL) && (usage->code == REL_WHEEL))
-			set_bit(REL_HWHEEL, bit);
+	if ((device->quirks & (HID_QUIRK_2WHEEL_MOUSE_HACK_7 | HID_QUIRK_2WHEEL_MOUSE_HACK_5 |
+			HID_QUIRK_2WHEEL_MOUSE_HACK_B8)) && (usage->type == EV_REL) &&
+			(usage->code == REL_WHEEL))
+		set_bit(REL_HWHEEL, bit);
 
 	if (((device->quirks & HID_QUIRK_2WHEEL_MOUSE_HACK_5) && (usage->hid == 0x00090005))
 		|| ((device->quirks & HID_QUIRK_2WHEEL_MOUSE_HACK_7) && (usage->hid == 0x00090007)))
@@ -1002,6 +1003,19 @@ void hidinput_hid_event(struct hid_device *hid, struct hid_field *field, struct
 		return;
 	}
 
+	if ((hid->quirks & HID_QUIRK_2WHEEL_MOUSE_HACK_B8) &&
+			(usage->type == EV_REL) &&
+			(usage->code == REL_WHEEL)) {
+		hid->delayed_value = value;
+		return;
+	}
+
+	if ((hid->quirks & HID_QUIRK_2WHEEL_MOUSE_HACK_B8) &&
+			(usage->hid == 0x000100b8)) {
+		input_event(input, EV_REL, value ? REL_HWHEEL : REL_WHEEL, hid->delayed_value);
+		return;
+	}
+
 	if ((hid->quirks & HID_QUIRK_INVERT_HWHEEL) && (usage->code == REL_HWHEEL)) {
 		input_event(input, usage->type, usage->code, -value);
 		return;

commit a45d82d19a6c2a717bcc33cff243199b77fa0082
Author: Michel Daenzer <michel@tungstengraphics.com>
Date:   Wed Oct 24 16:30:37 2007 +0200

    HID: Add support for Apple aluminum USB keyboards.
    
    Reuse the existing quirks for Apple laptop USB keyboards.
    
    Signed-off-by: Michel Daenzer <michel@tungstengraphics.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 85803f183fcc..8c4c908177fa 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -101,6 +101,22 @@ struct hidinput_key_translation {
 
 #define APPLE_FLAG_FKEY 0x01
 
+static struct hidinput_key_translation apple_fn_keys[] = {
+	{ KEY_F1,       KEY_BRIGHTNESSDOWN,     APPLE_FLAG_FKEY },
+	{ KEY_F2,       KEY_BRIGHTNESSUP,       APPLE_FLAG_FKEY },
+	{ KEY_F3,       KEY_CYCLEWINDOWS,       APPLE_FLAG_FKEY }, /* ExposÃ© */
+	{ KEY_F4,       KEY_FN_F4,              APPLE_FLAG_FKEY }, /* Dashboard */
+	{ KEY_F5,       KEY_FN_F5 },
+	{ KEY_F6,       KEY_FN_F6 },
+	{ KEY_F7,       KEY_BACK,               APPLE_FLAG_FKEY },
+	{ KEY_F8,       KEY_PLAYPAUSE,          APPLE_FLAG_FKEY },
+	{ KEY_F9,       KEY_FORWARD,            APPLE_FLAG_FKEY },
+	{ KEY_F10,      KEY_MUTE,               APPLE_FLAG_FKEY },
+	{ KEY_F11,      KEY_VOLUMEDOWN,         APPLE_FLAG_FKEY },
+	{ KEY_F12,      KEY_VOLUMEUP,           APPLE_FLAG_FKEY },
+	{ }
+};
+
 static struct hidinput_key_translation powerbook_fn_keys[] = {
 	{ KEY_BACKSPACE, KEY_DELETE },
 	{ KEY_F1,       KEY_BRIGHTNESSDOWN,     APPLE_FLAG_FKEY },
@@ -178,7 +194,10 @@ static int hidinput_apple_event(struct hid_device *hid, struct input_dev *input,
 	if (hid_apple_fnmode) {
 		int do_translate;
 
-		trans = find_translation(powerbook_fn_keys, usage->code);
+		trans = find_translation((hid->product < 0x220 ||
+					  hid->product >= 0x300) ?
+					 powerbook_fn_keys : apple_fn_keys,
+					 usage->code);
 		if (trans) {
 			if (test_bit(usage->code, hid->apple_pressed_fn))
 				do_translate = 1;
@@ -236,6 +255,9 @@ static void hidinput_apple_setup(struct input_dev *input)
 	set_bit(KEY_NUMLOCK, input->keybit);
 
 	/* Enable all needed keys */
+	for (trans = apple_fn_keys; trans->from; trans++)
+		set_bit(trans->to, input->keybit);
+
 	for (trans = powerbook_fn_keys; trans->from; trans++)
 		set_bit(trans->to, input->keybit);
 

commit 81e1a875505f2963f4d22f7e7ade39d764755f9b
Author: Michel Daenzer <michel@tungstengraphics.com>
Date:   Wed Oct 24 16:30:34 2007 +0200

    HID: Rename some code identifiers from PowerBook specific to Apple generic
    
    Preserve identifiers exposed in build and run time configuration though in
    order not to break existing configurations.
    
    This is in preparation for adding support for Apple aluminum USB keyboards.
    
    Signed-off-by: Michel Daenzer <michel@tungstengraphics.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 3a18ec45a71f..85803f183fcc 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -34,10 +34,10 @@
 #include <linux/hid.h>
 #include <linux/hid-debug.h>
 
-static int hid_pb_fnmode = 1;
-module_param_named(pb_fnmode, hid_pb_fnmode, int, 0644);
+static int hid_apple_fnmode = 1;
+module_param_named(pb_fnmode, hid_apple_fnmode, int, 0644);
 MODULE_PARM_DESC(pb_fnmode,
-		"Mode of fn key on PowerBooks (0 = disabled, 1 = fkeyslast, 2 = fkeysfirst)");
+		"Mode of fn key on Apple keyboards (0 = disabled, 1 = fkeyslast, 2 = fkeysfirst)");
 
 #define unk	KEY_UNKNOWN
 
@@ -99,20 +99,20 @@ struct hidinput_key_translation {
 	u8 flags;
 };
 
-#define POWERBOOK_FLAG_FKEY 0x01
+#define APPLE_FLAG_FKEY 0x01
 
 static struct hidinput_key_translation powerbook_fn_keys[] = {
 	{ KEY_BACKSPACE, KEY_DELETE },
-	{ KEY_F1,       KEY_BRIGHTNESSDOWN,     POWERBOOK_FLAG_FKEY },
-	{ KEY_F2,       KEY_BRIGHTNESSUP,       POWERBOOK_FLAG_FKEY },
-	{ KEY_F3,       KEY_MUTE,               POWERBOOK_FLAG_FKEY },
-	{ KEY_F4,       KEY_VOLUMEDOWN,         POWERBOOK_FLAG_FKEY },
-	{ KEY_F5,       KEY_VOLUMEUP,           POWERBOOK_FLAG_FKEY },
-	{ KEY_F6,       KEY_NUMLOCK,            POWERBOOK_FLAG_FKEY },
-	{ KEY_F7,       KEY_SWITCHVIDEOMODE,    POWERBOOK_FLAG_FKEY },
-	{ KEY_F8,       KEY_KBDILLUMTOGGLE,     POWERBOOK_FLAG_FKEY },
-	{ KEY_F9,       KEY_KBDILLUMDOWN,       POWERBOOK_FLAG_FKEY },
-	{ KEY_F10,      KEY_KBDILLUMUP,         POWERBOOK_FLAG_FKEY },
+	{ KEY_F1,       KEY_BRIGHTNESSDOWN,     APPLE_FLAG_FKEY },
+	{ KEY_F2,       KEY_BRIGHTNESSUP,       APPLE_FLAG_FKEY },
+	{ KEY_F3,       KEY_MUTE,               APPLE_FLAG_FKEY },
+	{ KEY_F4,       KEY_VOLUMEDOWN,         APPLE_FLAG_FKEY },
+	{ KEY_F5,       KEY_VOLUMEUP,           APPLE_FLAG_FKEY },
+	{ KEY_F6,       KEY_NUMLOCK,            APPLE_FLAG_FKEY },
+	{ KEY_F7,       KEY_SWITCHVIDEOMODE,    APPLE_FLAG_FKEY },
+	{ KEY_F8,       KEY_KBDILLUMTOGGLE,     APPLE_FLAG_FKEY },
+	{ KEY_F9,       KEY_KBDILLUMDOWN,       APPLE_FLAG_FKEY },
+	{ KEY_F10,      KEY_KBDILLUMUP,         APPLE_FLAG_FKEY },
 	{ KEY_UP,       KEY_PAGEUP },
 	{ KEY_DOWN,     KEY_PAGEDOWN },
 	{ KEY_LEFT,     KEY_HOME },
@@ -143,7 +143,7 @@ static struct hidinput_key_translation powerbook_numlock_keys[] = {
 	{ }
 };
 
-static struct hidinput_key_translation powerbook_iso_keyboard[] = {
+static struct hidinput_key_translation apple_iso_keyboard[] = {
 	{ KEY_GRAVE,    KEY_102ND },
 	{ KEY_102ND,    KEY_GRAVE },
 	{ }
@@ -161,39 +161,39 @@ static struct hidinput_key_translation *find_translation(struct hidinput_key_tra
 	return NULL;
 }
 
-static int hidinput_pb_event(struct hid_device *hid, struct input_dev *input,
+static int hidinput_apple_event(struct hid_device *hid, struct input_dev *input,
 		struct hid_usage *usage, __s32 value)
 {
 	struct hidinput_key_translation *trans;
 
 	if (usage->code == KEY_FN) {
-		if (value) hid->quirks |=  HID_QUIRK_POWERBOOK_FN_ON;
-		else       hid->quirks &= ~HID_QUIRK_POWERBOOK_FN_ON;
+		if (value) hid->quirks |=  HID_QUIRK_APPLE_FN_ON;
+		else       hid->quirks &= ~HID_QUIRK_APPLE_FN_ON;
 
 		input_event(input, usage->type, usage->code, value);
 
 		return 1;
 	}
 
-	if (hid_pb_fnmode) {
+	if (hid_apple_fnmode) {
 		int do_translate;
 
 		trans = find_translation(powerbook_fn_keys, usage->code);
 		if (trans) {
-			if (test_bit(usage->code, hid->pb_pressed_fn))
+			if (test_bit(usage->code, hid->apple_pressed_fn))
 				do_translate = 1;
-			else if (trans->flags & POWERBOOK_FLAG_FKEY)
+			else if (trans->flags & APPLE_FLAG_FKEY)
 				do_translate =
-					(hid_pb_fnmode == 2 &&  (hid->quirks & HID_QUIRK_POWERBOOK_FN_ON)) ||
-					(hid_pb_fnmode == 1 && !(hid->quirks & HID_QUIRK_POWERBOOK_FN_ON));
+					(hid_apple_fnmode == 2 &&  (hid->quirks & HID_QUIRK_APPLE_FN_ON)) ||
+					(hid_apple_fnmode == 1 && !(hid->quirks & HID_QUIRK_APPLE_FN_ON));
 			else
-				do_translate = (hid->quirks & HID_QUIRK_POWERBOOK_FN_ON);
+				do_translate = (hid->quirks & HID_QUIRK_APPLE_FN_ON);
 
 			if (do_translate) {
 				if (value)
-					set_bit(usage->code, hid->pb_pressed_fn);
+					set_bit(usage->code, hid->apple_pressed_fn);
 				else
-					clear_bit(usage->code, hid->pb_pressed_fn);
+					clear_bit(usage->code, hid->apple_pressed_fn);
 
 				input_event(input, usage->type, trans->to, value);
 
@@ -218,8 +218,8 @@ static int hidinput_pb_event(struct hid_device *hid, struct input_dev *input,
 		}
 	}
 
-	if (hid->quirks & HID_QUIRK_POWERBOOK_ISO_KEYBOARD) {
-		trans = find_translation(powerbook_iso_keyboard, usage->code);
+	if (hid->quirks & HID_QUIRK_APPLE_ISO_KEYBOARD) {
+		trans = find_translation(apple_iso_keyboard, usage->code);
 		if (trans) {
 			input_event(input, usage->type, trans->to, value);
 			return 1;
@@ -229,7 +229,7 @@ static int hidinput_pb_event(struct hid_device *hid, struct input_dev *input,
 	return 0;
 }
 
-static void hidinput_pb_setup(struct input_dev *input)
+static void hidinput_apple_setup(struct input_dev *input)
 {
 	struct hidinput_key_translation *trans;
 
@@ -242,18 +242,19 @@ static void hidinput_pb_setup(struct input_dev *input)
 	for (trans = powerbook_numlock_keys; trans->from; trans++)
 		set_bit(trans->to, input->keybit);
 
-	for (trans = powerbook_iso_keyboard; trans->from; trans++)
+	for (trans = apple_iso_keyboard; trans->from; trans++)
 		set_bit(trans->to, input->keybit);
 
 }
 #else
-static inline int hidinput_pb_event(struct hid_device *hid, struct input_dev *input,
-		struct hid_usage *usage, __s32 value)
+static inline int hidinput_apple_event(struct hid_device *hid,
+				       struct input_dev *input,
+				       struct hid_usage *usage, __s32 value)
 {
 	return 0;
 }
 
-static inline void hidinput_pb_setup(struct input_dev *input)
+static inline void hidinput_apple_setup(struct input_dev *input)
 {
 }
 #endif
@@ -797,14 +798,14 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 				goto ignore;
 			break;
 
-		case HID_UP_CUSTOM: /* Reported on Logitech and Powerbook USB keyboards */
+		case HID_UP_CUSTOM: /* Reported on Logitech and Apple USB keyboards */
 
 			set_bit(EV_REP, input->evbit);
 			switch(usage->hid & HID_USAGE) {
 				case 0x003:
-					/* The fn key on Apple PowerBooks */
+					/* The fn key on Apple USB keyboards */
 					map_key_clear(KEY_FN);
-					hidinput_pb_setup(input);
+					hidinput_apple_setup(input);
 					break;
 
 				default:    goto ignore;
@@ -989,7 +990,7 @@ void hidinput_hid_event(struct hid_device *hid, struct hid_field *field, struct
 		return;
 	}
 
-	if ((hid->quirks & HID_QUIRK_POWERBOOK_HAS_FN) && hidinput_pb_event(hid, input, usage, value))
+	if ((hid->quirks & HID_QUIRK_APPLE_HAS_FN) && hidinput_apple_event(hid, input, usage, value))
 		return;
 
 	if (usage->hat_min < usage->hat_max || usage->hat_dir) {

commit 3c684c8cd4d1a81004daa21f7ad3dad5119916e3
Author: Jan Kiszka <jan.kiszka@siemens.com>
Date:   Wed Oct 24 16:24:22 2007 +0200

    HID: Map MS Presenter 8000 bottom-side buttons
    
    The MS Presenter 8000 bluetooth mouse is a "dual-use" device: If you
    press a button on the top, you can turn it around and find special keys
    on the other side, useful for presentations. This patch maps those three
    bottom-keys that are not already detected to the intended functions. The
    magic bottom on the top is mapped to F5 when we switch from mouse to
    presenter mode in order to activate the presentation mode in the related
    software (e.g. OpenOffice).
    
    Signed-off-by: Jan Kiszka <jan.kiszka@siemens.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 0b27da7d7497..3a18ec45a71f 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -89,6 +89,7 @@ static const struct {
 /* hardware needing special handling due to colliding MSVENDOR page usages */
 #define IS_CHICONY_TACTICAL_PAD(x) (x->vendor == 0x04f2 && device->product == 0x0418)
 #define IS_MS_KB(x) (x->vendor == 0x045e && (x->product == 0x00db || x->product == 0x00f9))
+#define IS_MS_PRESENTER_8000(x) (x->vendor == 0x045e && x->product == 0x0713)
 
 #ifdef CONFIG_USB_HIDINPUT_POWERBOOK
 
@@ -780,9 +781,20 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 						set_bit(KEY_F18, input->keybit);
 					default:	goto ignore;
 				}
-			} else {
+
+			/* Microsoft Wireless Notebook Presenter Mouse 8000 */
+			} else if (IS_MS_PRESENTER_8000(device)) {
+				set_bit(EV_REP, input->evbit);
+				switch(usage->hid & HID_USAGE) {
+					/* Useful mappings of bottom-side keys for presentations */
+					case 0xfd08: map_key_clear(KEY_RIGHT);		break;
+					case 0xfd09: map_key_clear(KEY_LEFT);		break;
+					case 0xfd0b: map_key_clear(KEY_PAUSE);		break;
+					case 0xfd0f: map_key_clear(KEY_F5);		break;
+					default:    goto ignore;
+				}
+			} else
 				goto ignore;
-			}
 			break;
 
 		case HID_UP_CUSTOM: /* Reported on Logitech and Powerbook USB keyboards */

commit f202df600c4485d406aa033ce793d3e78f5ff1e0
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Wed Oct 31 12:33:26 2007 +0100

    HID: Don't access input_dev->private directly
    
    input_{get|set}_drvdata() helpers should be used instead.
    
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 71eb7693e453..0b27da7d7497 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -297,7 +297,7 @@ static struct hid_usage *hidinput_find_key(struct hid_device *hid,
 static int hidinput_getkeycode(struct input_dev *dev, int scancode,
 				int *keycode)
 {
-	struct hid_device *hid = dev->private;
+	struct hid_device *hid = input_get_drvdata(dev);
 	struct hid_usage *usage;
 
 	usage = hidinput_find_key(hid, scancode, 0);
@@ -311,7 +311,7 @@ static int hidinput_getkeycode(struct input_dev *dev, int scancode,
 static int hidinput_setkeycode(struct input_dev *dev, int scancode,
 				int keycode)
 {
-	struct hid_device *hid = dev->private;
+	struct hid_device *hid = input_get_drvdata(dev);
 	struct hid_usage *usage;
 	int old_keycode;
 

commit 368d290ba2a66338303b5d3998b182e404a9eb38
Author: Dirk Hohndel <hohndel@linux.intel.com>
Date:   Tue Oct 30 13:02:44 2007 +0100

    HID: fix hidinput_connect ignoring retval from input_register_device
    
    hidinput_connect() ignores retval from input_register_device(). Fix it
    by properly undoing all the registrations that have been already done,
    and return error.
    
    Signed-off-by: Dirk Hohndel <hohndel@linux.intel.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index dd332f28e08c..71eb7693e453 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -1152,7 +1152,7 @@ int hidinput_connect(struct hid_device *hid)
 					kfree(hidinput);
 					input_free_device(input_dev);
 					err_hid("Out of memory during hid input probe");
-					return -1;
+					goto out_unwind;
 				}
 
 				input_set_drvdata(input_dev, hid);
@@ -1186,15 +1186,25 @@ int hidinput_connect(struct hid_device *hid)
 				 * UGCI) cram a lot of unrelated inputs into the
 				 * same interface. */
 				hidinput->report = report;
-				input_register_device(hidinput->input);
+				if (input_register_device(hidinput->input))
+					goto out_cleanup;
 				hidinput = NULL;
 			}
 		}
 
-	if (hidinput)
-		input_register_device(hidinput->input);
+	if (hidinput && input_register_device(hidinput->input))
+		goto out_cleanup;
 
 	return 0;
+
+out_cleanup:
+	input_free_device(hidinput->input);
+	kfree(hidinput);
+out_unwind:
+	/* unwind the ones we already registered */
+	hidinput_disconnect(hid);
+
+	return -1;
 }
 EXPORT_SYMBOL_GPL(hidinput_connect);
 

commit b4482a4b2e2ff5ed96d8d16d72e83e75064062c5
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Sun Oct 14 19:35:40 2007 +0100

    more trivial signedness fixes in drivers
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 0c3e12c1794c..dd332f28e08c 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -950,7 +950,7 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 void hidinput_hid_event(struct hid_device *hid, struct hid_field *field, struct hid_usage *usage, __s32 value)
 {
 	struct input_dev *input;
-	int *quirks = &hid->quirks;
+	unsigned *quirks = &hid->quirks;
 
 	if (!field->hidinput)
 		return;

commit 3cc5f916050be1d1910c5dd5732110b0a8f27ac8
Author: Khelben Blackstaff <eye.of.the.8eholder@gmail.com>
Date:   Thu Oct 4 10:35:41 2007 +0200

    HID: add support for Microsoft Wireless Laser Keyboard 6000
    
    This keyboard emits a few usages that are not handled properly by
    hid-input.
    
    Changed IS_MS_NEK4K macro to IS_MS_KB to reflect the addition
    of another keyboard.
    
    Signed-off-by: Khelben Blackstaff <eye.of.the.8eholder@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 8be28d205d6d..0c3e12c1794c 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -88,7 +88,7 @@ static const struct {
 
 /* hardware needing special handling due to colliding MSVENDOR page usages */
 #define IS_CHICONY_TACTICAL_PAD(x) (x->vendor == 0x04f2 && device->product == 0x0418)
-#define IS_MS_NEK4K(x) (x->vendor == 0x045e && x->product == 0x00db)
+#define IS_MS_KB(x) (x->vendor == 0x045e && (x->product == 0x00db || x->product == 0x00f9))
 
 #ifdef CONFIG_USB_HIDINPUT_POWERBOOK
 
@@ -606,6 +606,7 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 				case 0x0f6: map_key_clear(KEY_NEXT);		break;
 				case 0x0fa: map_key_clear(KEY_BACK);		break;
 
+				case 0x182: map_key_clear(KEY_BOOKMARKS);	break;
 				case 0x183: map_key_clear(KEY_CONFIG);		break;
 				case 0x184: map_key_clear(KEY_WORDPROCESSOR);	break;
 				case 0x185: map_key_clear(KEY_EDITOR);		break;
@@ -622,10 +623,13 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 				case 0x192: map_key_clear(KEY_CALC);		break;
 				case 0x194: map_key_clear(KEY_FILE);		break;
 				case 0x196: map_key_clear(KEY_WWW);		break;
+				case 0x19c: map_key_clear(KEY_LOGOFF);		break;
 				case 0x19e: map_key_clear(KEY_COFFEE);		break;
 				case 0x1a6: map_key_clear(KEY_HELP);		break;
 				case 0x1a7: map_key_clear(KEY_DOCUMENTS);	break;
 				case 0x1ab: map_key_clear(KEY_SPELLCHECK);	break;
+				case 0x1b6: map_key_clear(KEY_MEDIA);		break;
+				case 0x1b7: map_key_clear(KEY_SOUND);		break;
 				case 0x1bc: map_key_clear(KEY_MESSENGER);	break;
 				case 0x1bd: map_key_clear(KEY_INFO);		break;
 				case 0x201: map_key_clear(KEY_NEW);		break;
@@ -758,8 +762,14 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 				}
 
 			/* Microsoft Natural Ergonomic Keyboard 4000 */
-			} else if (IS_MS_NEK4K(device)) {
+			} else if (IS_MS_KB(device)) {
 				switch(usage->hid & HID_USAGE) {
+					case 0xfd06:
+						map_key_clear(KEY_CHAT);
+						break;
+					case 0xfd07:
+						map_key_clear(KEY_PHONE);
+						break;
 					case 0xff05:
 						set_bit(EV_REP, input->evbit);
 						map_key_clear(KEY_F13);
@@ -1029,8 +1039,8 @@ void hidinput_hid_event(struct hid_device *hid, struct hid_field *field, struct
 		return;
 	}
 
-	/* Handling MS NEK4K special buttons */
-	if (IS_MS_NEK4K(hid) && usage->hid == (HID_UP_MSVENDOR | 0xff05)) {
+	/* Handling MS keyboards special buttons */
+	if (IS_MS_KB(hid) && usage->hid == (HID_UP_MSVENDOR | 0xff05)) {
 		int key = 0;
 		static int last_key = 0;
 		switch (value) {

commit f14d5d206cf84357a7072ddb2bbc7d3454639f11
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Tue Sep 25 16:32:08 2007 +0200

    HID: fix input mapping for Microsoft Ergonomic Keyboard
    
    Special keys 1-5 on Microsoft Ergonomic Keyboard were mistakenly
    mapped to buttons, which doesn't make a lot of sense. Fix this
    mapping to KEY_F{13,18}.
    
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index bd5a29fe85fc..8be28d205d6d 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -762,12 +762,12 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 				switch(usage->hid & HID_USAGE) {
 					case 0xff05:
 						set_bit(EV_REP, input->evbit);
-						map_key_clear(BTN_0);
-						set_bit(BTN_1, input->keybit);
-						set_bit(BTN_2, input->keybit);
-						set_bit(BTN_3, input->keybit);
-						set_bit(BTN_4, input->keybit);
-						set_bit(BTN_5, input->keybit);
+						map_key_clear(KEY_F13);
+						set_bit(KEY_F14, input->keybit);
+						set_bit(KEY_F15, input->keybit);
+						set_bit(KEY_F16, input->keybit);
+						set_bit(KEY_F17, input->keybit);
+						set_bit(KEY_F18, input->keybit);
 					default:	goto ignore;
 				}
 			} else {
@@ -1034,11 +1034,11 @@ void hidinput_hid_event(struct hid_device *hid, struct hid_field *field, struct
 		int key = 0;
 		static int last_key = 0;
 		switch (value) {
-			case 0x01: key = BTN_1; break;
-			case 0x02: key = BTN_2; break;
-			case 0x04: key = BTN_3; break;
-			case 0x08: key = BTN_4; break;
-			case 0x10: key = BTN_5; break;
+			case 0x01: key = KEY_F14; break;
+			case 0x02: key = KEY_F15; break;
+			case 0x04: key = KEY_F16; break;
+			case 0x08: key = KEY_F17; break;
+			case 0x10: key = KEY_F18; break;
 			default: break;
 		}
 		if (key) {

commit 0ce91cf9ce23127932e8b5241d8a7d2bf62df017
Author: Stelian Pop <stelian@popies.net>
Date:   Tue Sep 11 23:34:55 2007 +0200

    HID: enable hiddev for the SantaRosa MacBookPro IR receiver
    
    The infrared remote receiver found in the SantaRosa MacBookPro
    laptops (MacBookPro3,1) need to be forced to expose a HIDDEV
    interface (instead of HIDINPUT) so that lirc can access it using
    the 'macmini' driver.
    
    The patch below adds the required quirk for forcing the HIDDEV
    interface to be activated (HID_QUIRK_HIDDEV) and introduces a new
    quirk which forces the HIDINPUT interface to be ignored
    (HID_QUIRK_IGNORE_HIDINPUT).
    
    Note that Apple calls this receiver 'IRController4' (info taken
    from Apple's driver Info.plist). Older Mac{Book,Mini,Pro}s seem
    to all use the 'IRController1' device (USB id 05ac:8240) which
    doesn't need those quirks.
    
    Signed-off-by: Stelian Pop <stelian@popies.net>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 36be431888fb..bd5a29fe85fc 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -1112,6 +1112,9 @@ int hidinput_connect(struct hid_device *hid)
 	int i, j, k;
 	int max_report_type = HID_OUTPUT_REPORT;
 
+	if (hid->quirks & HID_QUIRK_IGNORE_HIDINPUT)
+		return -1;
+
 	INIT_LIST_HEAD(&hid->inputs);
 
 	for (i = 0; i < hid->maxcollection; i++)

commit c01d50d181f074a60bf3ed54eb055ce1679afb98
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Mon Aug 20 12:13:34 2007 +0200

    HID: Report usage codes of keys as EV_MSC scancode events
    
    Current HID layer does not report usage codes to the input layer. This feature
    was previously removed, because it caused unnecessary storm of events in cases
    of positioning devices, etc.
    
    This patch adds reporting of usage codes as EV_MSC events only for key events.
    We issue the EV_MSC event only if the state of the key corresponding to the
    given code has changed, so that we don't report usages that are sent in every
    report even if the state hasn't changed (for example Shift/Caps Lock/...
    states as sent by various keyboards).
    
    This functionality is required at least by KeyTouch in order to provide
    convenient means for remapping the usage codes.
    
    Cc: Marvin Raaijmakers <marvin.nospam@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index f80b57142cd4..36be431888fb 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -921,6 +921,11 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 		set_bit(KEY_VOLUMEDOWN, input->keybit);
 	}
 
+	if (usage->type == EV_KEY) {
+		set_bit(EV_MSC, input->evbit);
+		set_bit(MSC_SCAN, input->mscbit);
+	}
+
 	hid_resolv_event(usage->type, usage->code);
 
 	dbg_hid_line("\n");
@@ -1043,6 +1048,9 @@ void hidinput_hid_event(struct hid_device *hid, struct hid_field *field, struct
 			input_event(input, usage->type, last_key, 0);
 		}
 	}
+	/* report the usage code as scancode if the key status has changed */
+	if (usage->type == EV_KEY && !!test_bit(usage->code, input->key) != value)
+		input_event(input, EV_MSC, MSC_SCAN, usage->hid);
 
 	input_event(input, usage->type, usage->code, value);
 

commit 82eb121989c06e3de33b56ade1fa52c9e86c014e
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Sat Aug 11 23:39:42 2007 +0200

    HID: ignore all non-LED usages in output fields in hid-input
    
    We have to ignore all non-LED usages in output fields if the
    report descriptor of the device specifies any. If we don't do
    so, the devices which contain the same usages both in input and
    output reports with different parameters will mess things up. In
    hid-input, we currently care only for the input usages, with exception
    for LEDs. All other output usages should be properly handled by
    appropriate force-feedback driver.
    
    Fixes auto-calibration for Saitek Cyborg Evo Force joystick.
    
    Reported-by: Renato Golin <rengolin@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index de8dbec6aae5..f80b57142cd4 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -355,6 +355,13 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 	if (field->flags & HID_MAIN_ITEM_CONSTANT)
 		goto ignore;
 
+	/* only LED usages are supported in output fields */
+	if (field->report_type == HID_OUTPUT_REPORT &&
+			(usage->hid & HID_USAGE_PAGE) != HID_UP_LED) {
+		dbg_hid_line(" [non-LED output field] ");
+		goto ignore;
+	}
+
 	switch (usage->hid & HID_USAGE_PAGE) {
 
 		case HID_UP_UNDEFINED:

commit 77b296629d6e938e68de40195a9d500f209f6d10
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Thu Aug 9 14:04:56 2007 +0200

    HID: fix whitespace damage
    
    Fixes some trivial whitespace damage in hid-input.c
    
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 00f326012a31..de8dbec6aae5 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -299,7 +299,7 @@ static int hidinput_getkeycode(struct input_dev *dev, int scancode,
 {
 	struct hid_device *hid = dev->private;
 	struct hid_usage *usage;
-	
+
 	usage = hidinput_find_key(hid, scancode, 0);
 	if (usage) {
 		*keycode = usage->code;
@@ -314,15 +314,15 @@ static int hidinput_setkeycode(struct input_dev *dev, int scancode,
 	struct hid_device *hid = dev->private;
 	struct hid_usage *usage;
 	int old_keycode;
-	
+
 	if (keycode < 0 || keycode > KEY_MAX)
 		return -EINVAL;
-	
+
 	usage = hidinput_find_key(hid, scancode, 0);
 	if (usage) {
 		old_keycode = usage->code;
 		usage->code = keycode;
-		
+
 		clear_bit(old_keycode, dev->keybit);
 		set_bit(usage->code, dev->keybit);
 		dbg_hid(KERN_DEBUG "Assigned keycode %d to HID usage code %x\n", keycode, scancode);
@@ -330,10 +330,10 @@ static int hidinput_setkeycode(struct input_dev *dev, int scancode,
 		 * by another key */
 		if (hidinput_find_key (hid, 0, old_keycode))
 			set_bit(old_keycode, dev->keybit);
-		
+
 		return 0;
 	}
-	
+
 	return -EINVAL;
 }
 

commit 1fe8736da695c2b14961438c73d5600538bd92d9
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Thu Aug 9 13:24:11 2007 +0200

    HID: add support for Microsoft Natural Ergonomic Keyboard 4000
    
    This keyboard emits a few usages that are not handled properly by
    hid-input.
    
    The usages from MSVENDOR page are colliding with Chicony Tactical
    Pad device, so we have to distinguish in runtime. Ugly ...
    
    Also, the buttons 1-5 have to be handled in a non-standard way,
    as they are emitted by the keyboard in a bitfield-like fashion, but
    the field is not presented as bit-field by the keyboard. The keys can't
    be pressed simultaneously, so the handling we have is correct.
    
    This patch also extends hid_keyboard[] with KPLeftParenthesis and
    KPRightParenthesis as defined by Keyboard page in HUT 1.12. The
    corresponding usages are also emitted by this keyboard.
    
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 8edbd30cf795..00f326012a31 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -53,7 +53,7 @@ static const unsigned char hid_keyboard[256] = {
 	115,114,unk,unk,unk,121,unk, 89, 93,124, 92, 94, 95,unk,unk,unk,
 	122,123, 90, 91, 85,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,
 	unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,
-	unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,
+	unk,unk,unk,unk,unk,unk,179,180,unk,unk,unk,unk,unk,unk,unk,unk,
 	unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,
 	unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,
 	 29, 42, 56,125, 97, 54,100,126,164,166,165,163,161,115,114,113,
@@ -86,6 +86,10 @@ static const struct {
 #define map_abs_clear(c)	do { map_abs(c); clear_bit(c, bit); } while (0)
 #define map_key_clear(c)	do { map_key(c); clear_bit(c, bit); } while (0)
 
+/* hardware needing special handling due to colliding MSVENDOR page usages */
+#define IS_CHICONY_TACTICAL_PAD(x) (x->vendor == 0x04f2 && device->product == 0x0418)
+#define IS_MS_NEK4K(x) (x->vendor == 0x045e && x->product == 0x00db)
+
 #ifdef CONFIG_USB_HIDINPUT_POWERBOOK
 
 struct hidinput_key_translation {
@@ -614,6 +618,7 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 				case 0x19e: map_key_clear(KEY_COFFEE);		break;
 				case 0x1a6: map_key_clear(KEY_HELP);		break;
 				case 0x1a7: map_key_clear(KEY_DOCUMENTS);	break;
+				case 0x1ab: map_key_clear(KEY_SPELLCHECK);	break;
 				case 0x1bc: map_key_clear(KEY_MESSENGER);	break;
 				case 0x1bd: map_key_clear(KEY_INFO);		break;
 				case 0x201: map_key_clear(KEY_NEW);		break;
@@ -720,8 +725,15 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 
 		case HID_UP_MSVENDOR:
 
-			/* special case - Chicony Chicony KU-0418 tactical pad */
-			if (device->vendor == 0x04f2 && device->product == 0x0418) {
+			/* Unfortunately, there are multiple devices which
+			 * emit usages from MSVENDOR page that require different
+			 * handling. If this list grows too much in the future,
+			 * more general handling will have to be introduced here
+			 * (i.e. another blacklist).
+			 */
+
+			/* Chicony Chicony KU-0418 tactical pad */
+			if (IS_CHICONY_TACTICAL_PAD(device)) {
 				set_bit(EV_REP, input->evbit);
 				switch(usage->hid & HID_USAGE) {
 					case 0xff01: map_key_clear(BTN_1);		break;
@@ -737,6 +749,20 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 					case 0xff0b: map_key_clear(BTN_B);		break;
 					default:    goto ignore;
 				}
+
+			/* Microsoft Natural Ergonomic Keyboard 4000 */
+			} else if (IS_MS_NEK4K(device)) {
+				switch(usage->hid & HID_USAGE) {
+					case 0xff05:
+						set_bit(EV_REP, input->evbit);
+						map_key_clear(BTN_0);
+						set_bit(BTN_1, input->keybit);
+						set_bit(BTN_2, input->keybit);
+						set_bit(BTN_3, input->keybit);
+						set_bit(BTN_4, input->keybit);
+						set_bit(BTN_5, input->keybit);
+					default:	goto ignore;
+				}
 			} else {
 				goto ignore;
 			}
@@ -991,6 +1017,26 @@ void hidinput_hid_event(struct hid_device *hid, struct hid_field *field, struct
 		return;
 	}
 
+	/* Handling MS NEK4K special buttons */
+	if (IS_MS_NEK4K(hid) && usage->hid == (HID_UP_MSVENDOR | 0xff05)) {
+		int key = 0;
+		static int last_key = 0;
+		switch (value) {
+			case 0x01: key = BTN_1; break;
+			case 0x02: key = BTN_2; break;
+			case 0x04: key = BTN_3; break;
+			case 0x08: key = BTN_4; break;
+			case 0x10: key = BTN_5; break;
+			default: break;
+		}
+		if (key) {
+			input_event(input, usage->type, key, 1);
+			last_key = key;
+		} else {
+			input_event(input, usage->type, last_key, 0);
+		}
+	}
+
 	input_event(input, usage->type, usage->code, value);
 
 	if ((field->flags & HID_MAIN_ITEM_RELATIVE) && (usage->type == EV_KEY))

commit feb485d4010e450183bd422d90c0d0f6be98f932
Merge: 58037eb961f8 2c1d8aea2ca7
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Mon Jul 9 14:23:37 2007 +0200

    Merge branches 'debug-module-param' and 'upstream' into for-linus

commit 2c1d8aea2ca76df1b1de2aed23e3ceda2a044ed1
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Wed Jul 4 16:45:59 2007 +0200

    HID: handle cases of volume knobs generating relative values
    
    There are some devices (for example Dell Multimedia Keyboard SK-8135) that have
    a volume control knob which generates relative events instead of absolute.
    hid-input maps them to ABS_VOLUME. HUT pages don't restrict volume to absolute
    values.
    
    Adding REL_VOLUME doesn't seem feasible, nothing knows how to handle it. This
    patch translates relative ABS_VOLUME events into appropriate number of series
    of VOLUME_UP or VOLUME_DOWN events respectively, so that userspace sees the
    correct values in the end.
    
    kernel.org bugzilla 5233
    
    Reported-by: Jochen Eisinger <jochen@penguin-breeder.org>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 60de16a83c3e..bf7e307503cc 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -882,6 +882,16 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 			field->dpad = usage->code;
 	}
 
+	/* for those devices which produce Consumer volume usage as relative,
+	 * we emulate pressing volumeup/volumedown appropriate number of times
+	 * in hidinput_hid_event()
+	 */
+	if ((usage->type == EV_ABS) && (field->flags & HID_MAIN_ITEM_RELATIVE) &&
+			(usage->code == ABS_VOLUME)) {
+		set_bit(KEY_VOLUMEUP, input->keybit);
+		set_bit(KEY_VOLUMEDOWN, input->keybit);
+	}
+
 	hid_resolv_event(usage->type, usage->code);
 #ifdef CONFIG_HID_DEBUG
 	printk("\n");
@@ -972,6 +982,21 @@ void hidinput_hid_event(struct hid_device *hid, struct hid_field *field, struct
 	if ((usage->type == EV_KEY) && (usage->code == 0)) /* Key 0 is "unassigned", not KEY_UNKNOWN */
 		return;
 
+	if ((usage->type == EV_ABS) && (field->flags & HID_MAIN_ITEM_RELATIVE) &&
+			(usage->code == ABS_VOLUME)) {
+		int count = abs(value);
+		int direction = value > 0 ? KEY_VOLUMEUP : KEY_VOLUMEDOWN;
+		int i;
+
+		for (i = 0; i < count; i++) {
+			input_event(input, EV_KEY, direction, 1);
+			input_sync(input);
+			input_event(input, EV_KEY, direction, 0);
+			input_sync(input);
+		}
+		return;
+	}
+
 	input_event(input, usage->type, usage->code, value);
 
 	if ((field->flags & HID_MAIN_ITEM_RELATIVE) && (usage->type == EV_KEY))

commit 5f9c464aaa1ba3a773c47004e98eb1f3aa2ab2a4
Author: Ryo Dairiki <ryo-dairiki@users.sourceforge.net>
Date:   Mon Jun 25 10:31:12 2007 +0200

    HID: support for logitech cordless desktop LX500 special mapping
    
    This keyboard has wireless mouse which has left, middle, right buttons and
    2-dimensional scrolling wheel.  Unfornetuly, this wheel reports side scrolling
    events and 11 or 12 button events at the same time.
    
    I've wrote a patch to fix this mapping.  I'm not sure if this mapping is proper
    for buttons, because , for example, there is no entry for "burn cd" in input.h.
    
    The patch also supress 11 and 12 button events from mouse when you scroll the
    wheel left and right.  With this patch, only side scrolling events are
    reported.  (This mouse has only 4 buttons and 2D wheel. There is no such
    buttons like 11 and 12.)
    
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 1b8b33341408..60de16a83c3e 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -60,6 +60,19 @@ static const unsigned char hid_keyboard[256] = {
 	150,158,159,128,136,177,178,176,142,152,173,140,unk,unk,unk,unk
 };
 
+/* extended mapping for certain Logitech hardware (Logitech cordless desktop LX500) */
+#define LOGITECH_EXPANDED_KEYMAP_SIZE 80
+static int logitech_expanded_keymap[LOGITECH_EXPANDED_KEYMAP_SIZE] = {
+	  0,216,  0,213,175,156,  0,  0,  0,  0,
+	144,  0,  0,  0,  0,  0,  0,  0,  0,212,
+	174,167,152,161,112,  0,  0,  0,154,  0,
+	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+	  0,  0,  0,  0,  0,183,184,185,186,187,
+	188,189,190,191,192,193,194,  0,  0,  0
+};
+
 static const struct {
 	__s32 x;
 	__s32 y;
@@ -378,6 +391,21 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 					}
 			}
 
+			/* Special handling for Logitech Cordless Desktop */
+			if (field->application != HID_GD_MOUSE) {
+				if (device->quirks & HID_QUIRK_LOGITECH_EXPANDED_KEYMAP) {
+					int hid = usage->hid & HID_USAGE;
+					if (hid < LOGITECH_EXPANDED_KEYMAP_SIZE && logitech_expanded_keymap[hid] != 0)
+						code = logitech_expanded_keymap[hid];
+				}
+			} else {
+				if (device->quirks & HID_QUIRK_LOGITECH_IGNORE_DOUBLED_WHEEL) {
+					int hid = usage->hid & HID_USAGE;
+					if (hid == 7 || hid == 8)
+						goto ignore;
+				}
+			}
+
 			map_key(code);
 			break;
 

commit 92d9e6e607eb7f8f1d2a43935f45cf300cf6fdf8
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Mon Jun 18 13:30:11 2007 +0200

    HID: support for Petalynx Maxter remote control
    
    Petalynx Maxter remote control [1] 0x18b1/0x0037 emits 0xfa and 0xfc from
    consumer page (reserved in HUT 1.12) for back and more keys. It also emits
    a few usages from LOGIVENDOR page, which need adding.
    
    Also, this device has broken report descriptor - the reported maximum is too
    low - it doesn't contain the range for 'back' and 'more' keys, so we need to
    bump it up before the report descriptor is being parsed.
    
    Besides all this, it also requires NOGET quirk.
    
    This patch does so.
    
    [1] http://www.elmak.pl/index.php?option=com_phpshop&page=shop.browse&category_id=14&ext=opis&lang=en
    
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 6cb884638fda..1b8b33341408 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -566,6 +566,11 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 				case 0x0e5: map_key_clear(KEY_BASSBOOST);	break;
 				case 0x0e9: map_key_clear(KEY_VOLUMEUP);	break;
 				case 0x0ea: map_key_clear(KEY_VOLUMEDOWN);	break;
+
+				/* reserved in HUT 1.12. Reported on Petalynx remote */
+				case 0x0f6: map_key_clear(KEY_NEXT);		break;
+				case 0x0fa: map_key_clear(KEY_BACK);		break;
+
 				case 0x183: map_key_clear(KEY_CONFIG);		break;
 				case 0x184: map_key_clear(KEY_WORDPROCESSOR);	break;
 				case 0x185: map_key_clear(KEY_EDITOR);		break;
@@ -727,10 +732,10 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 			}
 			break;
 
-		case HID_UP_LOGIVENDOR: /* Reported on Logitech Ultra X Media Remote */
-
+		case HID_UP_LOGIVENDOR:
 			set_bit(EV_REP, input->evbit);
 			switch(usage->hid & HID_USAGE) {
+				/* Reported on Logitech Ultra X Media Remote */
 				case 0x004: map_key_clear(KEY_AGAIN);		break;
 				case 0x00d: map_key_clear(KEY_HOME);		break;
 				case 0x024: map_key_clear(KEY_SHUFFLE);		break;
@@ -748,6 +753,14 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 				case 0x04d: map_key_clear(KEY_SUBTITLE);	break;
 				case 0x051: map_key_clear(KEY_RED);		break;
 				case 0x052: map_key_clear(KEY_CLOSE);		break;
+
+				/* Reported on Petalynx Maxter remote */
+				case 0x05a: map_key_clear(KEY_TEXT);		break;
+				case 0x05b: map_key_clear(KEY_RED);		break;
+				case 0x05c: map_key_clear(KEY_GREEN);		break;
+				case 0x05d: map_key_clear(KEY_YELLOW);		break;
+				case 0x05e: map_key_clear(KEY_BLUE);		break;
+
 				default:    goto ignore;
 			}
 			break;

commit 5fce620c0c7caa9e8d9588e8dcc66c52c456851a
Author: Hans de Goede <j.w.r.degoede@hhs.nl>
Date:   Tue Jun 12 22:04:32 2007 +0200

    HID: fix mismatch between hid-input HUT find/search mapping and the HUT
    
    When comparing usb vs ps2 / testing the keycodes generated for the easy access
    keys on my trust (microsoft compatible) keyboard. I noticed the search key
    generated the keycode for find when connected through USB. This lead me to
    check the consumer page mappings in hid-input.c . And it turns out the the
    mapping for ID 0x221 deviates from the HUT standard document:
    http://www.usb.org/developers/devclass_docs/Hut1_12.pdf
    
    Currently it is incorrectly mapped to find, whereas it should be mapped to
    search. I also added missing bindings for ID 0x21f, the real find and for
    0x222, goto.
    
    Signed-off-by: Hans de Goede <j.w.r.degoede@hhs.nl>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 70bf54167083..6cb884638fda 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -598,7 +598,9 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 				case 0x21b: map_key_clear(KEY_COPY);		break;
 				case 0x21c: map_key_clear(KEY_CUT);		break;
 				case 0x21d: map_key_clear(KEY_PASTE);		break;
-				case 0x221: map_key_clear(KEY_FIND);		break;
+				case 0x21f: map_key_clear(KEY_FIND);		break;
+				case 0x221: map_key_clear(KEY_SEARCH);		break;
+				case 0x222: map_key_clear(KEY_GOTO);		break;
 				case 0x223: map_key_clear(KEY_HOMEPAGE);	break;
 				case 0x224: map_key_clear(KEY_BACK);		break;
 				case 0x225: map_key_clear(KEY_FORWARD);		break;

commit defd208681b721dbf2b69347cca5302d60246405
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Sat May 19 16:28:04 2007 +0200

    HID: force hid-input for Microsoft SideWinder GameVoice device
    
    Microsoft SideWinder GameVoice driver is a trivial device with a few buttons
    (0x09 HID usage) and an audio connector, which just forwards the audio input
    into oridinary sound card present in the computer.
    
    Despite this fact, the only interface of this device reports itself as a
    Telephony/Headset type of HID device. This is apparently incorrect - the device
    itself doesn't provide any audio/telephony functionality. This is achieved in
    userland application which only needs to receive the button events from the HID
    driver.
    
    This patch establishes a new quirk which forces hid-input to claim a device it
    will otherwise leave untouched.
    
    Reported-by: Tomas Carnecky <tom@dbservice.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index ce6d7644e6a1..70bf54167083 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -997,7 +997,7 @@ int hidinput_connect(struct hid_device *hid)
 			if (IS_INPUT_APPLICATION(hid->collection[i].usage))
 				break;
 
-	if (i == hid->maxcollection)
+	if (i == hid->maxcollection && (hid->quirks & HID_QUIRK_HIDINPUT) == 0)
 		return -1;
 
 	if (hid->quirks & HID_QUIRK_SKIP_OUTPUT_REPORTS)

commit cb1d93c98c49e268918e35e45e5c407fc4dc4e9f
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Mon May 14 10:20:29 2007 +0200

    HID: input mapping for Chicony KU-0418 tactical pad
    
    Chicony KU-0418 (aka Saitek PZ08AU gaming keyboard) has a separate
    "tactical pad" with 11 non-functional buttons - they generate usage
    codes from 0xff00 (MSVENDOR) usage page. Special case handling for
    this keyboard added, so no later clash with MSVENDOR mappings is going
    to occur.
    
    Pointed out in bugzilla #7352
    
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 7f817897b178..ce6d7644e6a1 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -688,7 +688,28 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 			break;
 
 		case HID_UP_MSVENDOR:
-			goto ignore;
+
+			/* special case - Chicony Chicony KU-0418 tactical pad */
+			if (device->vendor == 0x04f2 && device->product == 0x0418) {
+				set_bit(EV_REP, input->evbit);
+				switch(usage->hid & HID_USAGE) {
+					case 0xff01: map_key_clear(BTN_1);		break;
+					case 0xff02: map_key_clear(BTN_2);		break;
+					case 0xff03: map_key_clear(BTN_3);		break;
+					case 0xff04: map_key_clear(BTN_4);		break;
+					case 0xff05: map_key_clear(BTN_5);		break;
+					case 0xff06: map_key_clear(BTN_6);		break;
+					case 0xff07: map_key_clear(BTN_7);		break;
+					case 0xff08: map_key_clear(BTN_8);		break;
+					case 0xff09: map_key_clear(BTN_9);		break;
+					case 0xff0a: map_key_clear(BTN_A);		break;
+					case 0xff0b: map_key_clear(BTN_B);		break;
+					default:    goto ignore;
+				}
+			} else {
+				goto ignore;
+			}
+			break;
 
 		case HID_UP_CUSTOM: /* Reported on Logitech and Powerbook USB keyboards */
 

commit 58037eb961f859607b161c50d9d4ecb374de1e8f
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Wed May 30 15:07:13 2007 +0200

    HID: make debugging output runtime-configurable
    
    There have been many reports recently about broken HID devices, the
    diagnosis of which required users to recompile their kernels in order
    to be able to provide debugging output needed for coding a quirk for
    a particular device.
    
    This patch makes CONFIG_HID_DEBUG default y if !EMBEDDED and makes it
    possible to control debugging output produced by HID code by supplying
    'debug=1' module parameter.
    
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 7f817897b178..38595d3935ce 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -308,9 +308,7 @@ static int hidinput_setkeycode(struct input_dev *dev, int scancode,
 		
 		clear_bit(old_keycode, dev->keybit);
 		set_bit(usage->code, dev->keybit);
-#ifdef CONFIG_HID_DEBUG
-		printk (KERN_DEBUG "Assigned keycode %d to HID usage code %x\n", keycode, scancode);
-#endif
+		dbg_hid(KERN_DEBUG "Assigned keycode %d to HID usage code %x\n", keycode, scancode);
 		/* Set the keybit for the old keycode if the old keycode is used
 		 * by another key */
 		if (hidinput_find_key (hid, 0, old_keycode))
@@ -333,11 +331,9 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 
 	field->hidinput = hidinput;
 
-#ifdef CONFIG_HID_DEBUG
-	printk(KERN_DEBUG "Mapping: ");
+	dbg_hid("Mapping: ");
 	hid_resolv_usage(usage->hid);
-	printk(" ---> ");
-#endif
+	dbg_hid_line(" ---> ");
 
 	if (field->flags & HID_MAIN_ITEM_CONSTANT)
 		goto ignore;
@@ -819,15 +815,13 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 	}
 
 	hid_resolv_event(usage->type, usage->code);
-#ifdef CONFIG_HID_DEBUG
-	printk("\n");
-#endif
+
+	dbg_hid_line("\n");
+
 	return;
 
 ignore:
-#ifdef CONFIG_HID_DEBUG
-	printk("IGNORED\n");
-#endif
+	dbg_hid_line("IGNORED\n");
 	return;
 }
 
@@ -896,12 +890,12 @@ void hidinput_hid_event(struct hid_device *hid, struct hid_field *field, struct
 	}
 
 	if (usage->hid == (HID_UP_PID | 0x83UL)) { /* Simultaneous Effects Max */
-		dbg("Maximum Effects - %d",value);
+		dbg_hid("Maximum Effects - %d\n",value);
 		return;
 	}
 
 	if (usage->hid == (HID_UP_PID | 0x7fUL)) {
-		dbg("PID Pool Report\n");
+		dbg_hid("PID Pool Report\n");
 		return;
 	}
 
@@ -994,7 +988,7 @@ int hidinput_connect(struct hid_device *hid)
 				if (!hidinput || !input_dev) {
 					kfree(hidinput);
 					input_free_device(input_dev);
-					err("Out of memory during hid input probe");
+					err_hid("Out of memory during hid input probe");
 					return -1;
 				}
 

commit fe7ba31feadcc2cdb7749a8ed14960f989cbd021
Author: Marvin Raaijmakers <marvin.raaijmakers@gmail.com>
Date:   Wed May 9 10:57:20 2007 +0200

    HID: add hooks for getkeycode() and setkeycode() methods
    
    Provide hooks for getkeycode() and setkeycode() methods to
    input_dev.
    
    Signed-off-by: Marvin Raaijmakers <marvin.raaijmakers@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index a87b059f866f..7f817897b178 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -240,6 +240,89 @@ static inline void hidinput_pb_setup(struct input_dev *input)
 }
 #endif
 
+static inline int match_scancode(int code, int scancode)
+{
+	if (scancode == 0)
+		return 1;
+	return ((code & (HID_USAGE_PAGE | HID_USAGE)) == scancode);
+}
+
+static inline int match_keycode(int code, int keycode)
+{
+	if (keycode == 0)
+		return 1;
+	return (code == keycode);
+}
+
+static struct hid_usage *hidinput_find_key(struct hid_device *hid,
+		int scancode, int keycode)
+{
+	int i, j, k;
+	struct hid_report *report;
+	struct hid_usage *usage;
+
+	for (k = HID_INPUT_REPORT; k <= HID_OUTPUT_REPORT; k++) {
+		list_for_each_entry(report, &hid->report_enum[k].report_list, list) {
+			for (i = 0; i < report->maxfield; i++) {
+				for ( j = 0; j < report->field[i]->maxusage; j++) {
+					usage = report->field[i]->usage + j;
+					if (usage->type == EV_KEY &&
+						match_scancode(usage->hid, scancode) &&
+						match_keycode(usage->code, keycode))
+						return usage;
+				}
+			}
+		}
+	}
+	return NULL;
+}
+
+static int hidinput_getkeycode(struct input_dev *dev, int scancode,
+				int *keycode)
+{
+	struct hid_device *hid = dev->private;
+	struct hid_usage *usage;
+	
+	usage = hidinput_find_key(hid, scancode, 0);
+	if (usage) {
+		*keycode = usage->code;
+		return 0;
+	}
+	return -EINVAL;
+}
+
+static int hidinput_setkeycode(struct input_dev *dev, int scancode,
+				int keycode)
+{
+	struct hid_device *hid = dev->private;
+	struct hid_usage *usage;
+	int old_keycode;
+	
+	if (keycode < 0 || keycode > KEY_MAX)
+		return -EINVAL;
+	
+	usage = hidinput_find_key(hid, scancode, 0);
+	if (usage) {
+		old_keycode = usage->code;
+		usage->code = keycode;
+		
+		clear_bit(old_keycode, dev->keybit);
+		set_bit(usage->code, dev->keybit);
+#ifdef CONFIG_HID_DEBUG
+		printk (KERN_DEBUG "Assigned keycode %d to HID usage code %x\n", keycode, scancode);
+#endif
+		/* Set the keybit for the old keycode if the old keycode is used
+		 * by another key */
+		if (hidinput_find_key (hid, 0, old_keycode))
+			set_bit(old_keycode, dev->keybit);
+		
+		return 0;
+	}
+	
+	return -EINVAL;
+}
+
+
 static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_field *field,
 				     struct hid_usage *usage)
 {
@@ -919,6 +1002,8 @@ int hidinput_connect(struct hid_device *hid)
 				input_dev->event = hid->hidinput_input_event;
 				input_dev->open = hidinput_open;
 				input_dev->close = hidinput_close;
+				input_dev->setkeycode = hidinput_setkeycode;
+				input_dev->getkeycode = hidinput_getkeycode;
 
 				input_dev->name = hid->name;
 				input_dev->phys = hid->phys;

commit e071298589418076ef0a9813677f2d7032b65baa
Author: Dmitry Torokhov <dtor@insightbb.com>
Date:   Wed May 9 10:17:31 2007 +0200

    HID: switch to using input_dev->dev.parent
    
    In preparation for struct class_device -> struct device input
    core conversion switch to using input_dev->dev.parent when
    specifying device position in sysfs tree.
    
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 52de9a914a82..a87b059f866f 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -244,7 +244,7 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 				     struct hid_usage *usage)
 {
 	struct input_dev *input = hidinput->input;
-	struct hid_device *device = input->private;
+	struct hid_device *device = input_get_drvdata(input);
 	int max = 0, code;
 	unsigned long *bit = NULL;
 
@@ -859,13 +859,15 @@ EXPORT_SYMBOL_GPL(hidinput_find_field);
 
 static int hidinput_open(struct input_dev *dev)
 {
-	struct hid_device *hid = dev->private;
+	struct hid_device *hid = input_get_drvdata(dev);
+
 	return hid->hid_open(hid);
 }
 
 static void hidinput_close(struct input_dev *dev)
 {
-	struct hid_device *hid = dev->private;
+	struct hid_device *hid = input_get_drvdata(dev);
+
 	hid->hid_close(hid);
 }
 
@@ -913,7 +915,7 @@ int hidinput_connect(struct hid_device *hid)
 					return -1;
 				}
 
-				input_dev->private = hid;
+				input_set_drvdata(input_dev, hid);
 				input_dev->event = hid->hidinput_input_event;
 				input_dev->open = hidinput_open;
 				input_dev->close = hidinput_close;
@@ -925,7 +927,7 @@ int hidinput_connect(struct hid_device *hid)
 				input_dev->id.vendor  = hid->vendor;
 				input_dev->id.product = hid->product;
 				input_dev->id.version = hid->version;
-				input_dev->cdev.dev = hid->dev;
+				input_dev->dev.parent = hid->dev;
 				hidinput->input = input_dev;
 				list_add_tail(&hidinput->list, &hid->inputs);
 			}

commit 529fa5473123a9e81e711a92e46fba732c4264ed
Author: Charles Pillar <pillarama@gmail.com>
Date:   Thu May 3 17:30:12 2007 +0200

    HID: add input mappings for non-working keys on Logitech S510 remote
    
    HID-input mapping for non-working S510 remote control buttons.
    
    Signed-off-by: Charles Pillar <pillarama@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index a19b65ed3119..52de9a914a82 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -553,6 +553,7 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 				case 0x1015: map_key_clear(KEY_RECORD);		break;
 				case 0x1016: map_key_clear(KEY_PLAYER);		break;
 				case 0x1017: map_key_clear(KEY_EJECTCD);	break;
+				case 0x1018: map_key_clear(KEY_MEDIA);          break;
 				case 0x1019: map_key_clear(KEY_PROG1);		break;
 				case 0x101a: map_key_clear(KEY_PROG2);		break;
 				case 0x101b: map_key_clear(KEY_PROG3);		break;
@@ -560,9 +561,12 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 				case 0x1020: map_key_clear(KEY_ZOOMOUT);	break;
 				case 0x1021: map_key_clear(KEY_ZOOMRESET);	break;
 				case 0x1023: map_key_clear(KEY_CLOSE);		break;
+				case 0x1027: map_key_clear(KEY_MENU);           break;
 				/* this one is marked as 'Rotate' */
 				case 0x1028: map_key_clear(KEY_ANGLE);		break;
 				case 0x1029: map_key_clear(KEY_SHUFFLE);	break;
+				case 0x102a: map_key_clear(KEY_BACK);           break;
+				case 0x102b: map_key_clear(KEY_CYCLEWINDOWS);   break;
 				case 0x1041: map_key_clear(KEY_BATTERY);	break;
 				case 0x1042: map_key_clear(KEY_WORDPROCESSOR);	break;
 				case 0x1043: map_key_clear(KEY_SPREADSHEET);	break;

commit 85cbea3952135ecad4b47cb6cc57e25279129e2d
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Thu Apr 5 12:23:09 2007 +0200

    USB HID: Logitech MX3000 keyboard needs report descriptor quirk
    
    Logitech MX3000 contains report descriptor which doesn't cover usages
    above 0x28c, but emits such usages. Report descriptor needs fixing
    in the very same way as with receivers shipped with S510 keyboards.
    
    This patch also adds a few mappings for multimedia keys that S510 didn't
    emit.
    
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 220e5a8381c4..a19b65ed3119 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -540,10 +540,26 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 				case 0x302: map_key_clear(KEY_PROG2);		break;
 				case 0x303: map_key_clear(KEY_PROG3);		break;
 
-				/* Reported on Logitech S510 wireless keyboard */
+				/* Reported on certain Logitech wireless keyboards */
+				case 0x1001: map_key_clear(KEY_MESSENGER);	break;
+				case 0x1003: map_key_clear(KEY_SOUND);		break;
+				case 0x1004: map_key_clear(KEY_VIDEO);		break;
+				case 0x1005: map_key_clear(KEY_AUDIO);		break;
+				case 0x100a: map_key_clear(KEY_DOCUMENTS);	break;
+				case 0x1011: map_key_clear(KEY_PREVIOUSSONG);	break;
+				case 0x1012: map_key_clear(KEY_NEXTSONG);	break;
+				case 0x1013: map_key_clear(KEY_CAMERA);		break;
+				case 0x1014: map_key_clear(KEY_MESSENGER);	break;
+				case 0x1015: map_key_clear(KEY_RECORD);		break;
+				case 0x1016: map_key_clear(KEY_PLAYER);		break;
+				case 0x1017: map_key_clear(KEY_EJECTCD);	break;
+				case 0x1019: map_key_clear(KEY_PROG1);		break;
+				case 0x101a: map_key_clear(KEY_PROG2);		break;
+				case 0x101b: map_key_clear(KEY_PROG3);		break;
 				case 0x101f: map_key_clear(KEY_ZOOMIN);		break;
 				case 0x1020: map_key_clear(KEY_ZOOMOUT);	break;
 				case 0x1021: map_key_clear(KEY_ZOOMRESET);	break;
+				case 0x1023: map_key_clear(KEY_CLOSE);		break;
 				/* this one is marked as 'Rotate' */
 				case 0x1028: map_key_clear(KEY_ANGLE);		break;
 				case 0x1029: map_key_clear(KEY_SHUFFLE);	break;

commit daa0bc902c8e9476673b47d3b59c9bb922843563
Author: Chris Clayton <chris2553@googlemail.com>
Date:   Sun Apr 1 23:07:55 2007 +0200

    HID: enable dead keys on a belkin wireless keyboard
    
    Belkin Wireless keyboard, model number F8E849KYBD, USB ID 1020:0006,
    FCCID: K7SF8E849KYBD emits usages 0x03a-0x03c from Consumer usage page.
    As of HUT v1.12, these are marked as reserved. If any conflict arises
    later, the mapping could be made conditional on VID/PID.
    
    Signed-off-by: Chris Clayton <chris2553@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index c8434023ba65..220e5a8381c4 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -431,6 +431,15 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 				case 0x000: goto ignore;
 				case 0x034: map_key_clear(KEY_SLEEP);		break;
 				case 0x036: map_key_clear(BTN_MISC);		break;
+				/*
+				 * The next three are reported by Belkin wireless
+				 * keyboard (1020:0006). These values are "reserved"
+				 * in HUT 1.12.
+				 */
+				case 0x03a: map_key_clear(KEY_SOUND);           break;
+				case 0x03b: map_key_clear(KEY_CAMERA);          break;
+				case 0x03c: map_key_clear(KEY_DOCUMENTS);       break;
+
 				case 0x040: map_key_clear(KEY_MENU);		break;
 				case 0x045: map_key_clear(KEY_RADIO);		break;
 

commit 25914662b7e86f8cf8abdde0497e7fe8bdddf2ae
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Thu Mar 1 09:54:44 2007 +0100

    HID: fix Logitech DiNovo Edge touchwheel and Logic3 /SpectraVideo middle button
    
    Dongle shipped with Logitech DiNovo Edge (0x046d/0xc714) behaves in a weird
    non-standard way - it contains multiple reports with the same usage, which
    results in remapping of GenericDesktop.X and GenericDesktop.Y usages to
    GenericDesktop.Z and GenericDesktop.RX respectively, thus rendering the
    touchwheel unusable.
    
    The commit 35068976916fdef82d6e69ef1f8c9a1c47732759 solved this
    in a way that it didn't remap certain usages. This however breaks
    (at least) middle button of Logic3 / SpectraVideo (0x1267/0x0210),
    which in contrary requires the remapping.
    
    To make both of the harware work, allow remapping of these usages again,
    and introduce a quirk for Logitech DiNovo Edge "touchwheel" instead - we
    disable remapping for key, abs and rel events only for this hardware.
    
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index eeba66513997..c8434023ba65 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -71,7 +71,6 @@ static const struct {
 #define map_led(c)	do { usage->code = c; usage->type = EV_LED; bit = input->ledbit; max = LED_MAX; } while (0)
 
 #define map_abs_clear(c)	do { map_abs(c); clear_bit(c, bit); } while (0)
-#define map_rel_clear(c)	do { map_rel(c); clear_bit(c, bit); } while (0)
 #define map_key_clear(c)	do { map_key(c); clear_bit(c, bit); } while (0)
 
 #ifdef CONFIG_USB_HIDINPUT_POWERBOOK
@@ -296,7 +295,7 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 					}
 			}
 
-			map_key_clear(code);
+			map_key(code);
 			break;
 
 
@@ -347,9 +346,9 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 				case HID_GD_RX: case HID_GD_RY: case HID_GD_RZ:
 				case HID_GD_SLIDER: case HID_GD_DIAL: case HID_GD_WHEEL:
 					if (field->flags & HID_MAIN_ITEM_RELATIVE)
-						map_rel_clear(usage->hid & 0xf);
+						map_rel(usage->hid & 0xf);
 					else
-						map_abs_clear(usage->hid & 0xf);
+						map_abs(usage->hid & 0xf);
 					break;
 
 				case HID_GD_HATSWITCH:
@@ -519,7 +518,7 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 				case 0x22f: map_key_clear(KEY_ZOOMRESET);	break;
 				case 0x233: map_key_clear(KEY_SCROLLUP);	break;
 				case 0x234: map_key_clear(KEY_SCROLLDOWN);	break;
-				case 0x238: map_rel_clear(REL_HWHEEL);		break;
+				case 0x238: map_rel(REL_HWHEEL);		break;
 				case 0x25f: map_key_clear(KEY_CANCEL);		break;
 				case 0x279: map_key_clear(KEY_REDO);		break;
 
@@ -667,6 +666,12 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 
 	set_bit(usage->type, input->evbit);
 
+	if (device->quirks & HID_QUIRK_DUPLICATE_USAGES &&
+			(usage->type == EV_KEY ||
+			 usage->type == EV_REL ||
+			 usage->type == EV_ABS))
+		clear_bit(usage->code, bit);
+
 	while (usage->code <= max && test_and_set_bit(usage->code, bit))
 		usage->code = find_next_zero_bit(bit, max + 1, usage->code);
 

commit b55fd23ccdf32f969a7b4180c6e52d62d8e99972
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Wed Feb 21 19:27:49 2007 +0100

    HID: fix broken Logitech S510 keyboard report descriptor; make extra keys work
    
    This patch makes extra keys (F1-F12 in special mode, zooming, rotate, shuffle)
    on Logitech S510 keyboard work.
    
    Logitech S510 keyboard sends in report no. 3 keys which are far above the
    logical maximum described in descriptor for given report.
    
    This patch introduces a HID quirk for this wireless USB receiver/keyboard
    in order to fix the report descriptor before it's being parsed - the logical
    maximum and the number of usages is bumped up to 0x104d). The values are in the
    "Reserved" area of consumer HUT, so HID_MAX_USAGE had to be changed too.
    
    In addition to proper extracting of  the values from report descriptor, proper
    HID-input mapping is introduced for them.
    
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 25d180a24fc4..eeba66513997 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -2,7 +2,7 @@
  * $Id: hid-input.c,v 1.2 2002/04/23 00:59:25 rdamazio Exp $
  *
  *  Copyright (c) 2000-2001 Vojtech Pavlik
- *  Copyright (c) 2006 Jiri Kosina
+ *  Copyright (c) 2006-2007 Jiri Kosina
  *
  *  HID to Linux Input mapping
  */
@@ -532,6 +532,26 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 				case 0x302: map_key_clear(KEY_PROG2);		break;
 				case 0x303: map_key_clear(KEY_PROG3);		break;
 
+				/* Reported on Logitech S510 wireless keyboard */
+				case 0x101f: map_key_clear(KEY_ZOOMIN);		break;
+				case 0x1020: map_key_clear(KEY_ZOOMOUT);	break;
+				case 0x1021: map_key_clear(KEY_ZOOMRESET);	break;
+				/* this one is marked as 'Rotate' */
+				case 0x1028: map_key_clear(KEY_ANGLE);		break;
+				case 0x1029: map_key_clear(KEY_SHUFFLE);	break;
+				case 0x1041: map_key_clear(KEY_BATTERY);	break;
+				case 0x1042: map_key_clear(KEY_WORDPROCESSOR);	break;
+				case 0x1043: map_key_clear(KEY_SPREADSHEET);	break;
+				case 0x1044: map_key_clear(KEY_PRESENTATION);	break;
+				case 0x1045: map_key_clear(KEY_UNDO);		break;
+				case 0x1046: map_key_clear(KEY_REDO);		break;
+				case 0x1047: map_key_clear(KEY_PRINT);		break;
+				case 0x1048: map_key_clear(KEY_SAVE);		break;
+				case 0x1049: map_key_clear(KEY_PROG1);		break;
+				case 0x104a: map_key_clear(KEY_PROG2);		break;
+				case 0x104b: map_key_clear(KEY_PROG3);		break;
+				case 0x104c: map_key_clear(KEY_PROG4);		break;
+
 				default:    goto ignore;
 			}
 			break;

commit dd64c151b978dc78ed535433d930c75b5c15deeb
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Tue Jan 30 16:02:24 2007 +0100

    HID: move away from DEBUG defines in favor of CONFIG_HID_DEBUG
    
    CONFIG_INPUT_DEBUG is non-existent option, so remove anything depending
    on it.
    
    Also, as we have new CONFIG_HID_DEBUG, this should be used on places
    where ifdef DEBUG was used before.
    
    Suggested by Adrian Bunk.
    
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 4824b19b8646..25d180a24fc4 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -31,8 +31,6 @@
 #include <linux/slab.h>
 #include <linux/kernel.h>
 
-#undef DEBUG
-
 #include <linux/hid.h>
 #include <linux/hid-debug.h>
 
@@ -253,7 +251,7 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 
 	field->hidinput = hidinput;
 
-#ifdef DEBUG
+#ifdef CONFIG_HID_DEBUG
 	printk(KERN_DEBUG "Mapping: ");
 	hid_resolv_usage(usage->hid);
 	printk(" ---> ");
@@ -690,7 +688,7 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 	return;
 
 ignore:
-#ifdef DEBUG
+#ifdef CONFIG_HID_DEBUG
 	printk("IGNORED\n");
 #endif
 	return;

commit 7c379146005d277982acde02da44c773de5e7e5a
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Wed Jan 24 11:54:19 2007 +0100

    HID: API - fix leftovers of hidinput API in USB HID
    
    hidinput_{open,close}() functions do not belong to usbhid, but
    to the generic HID layer. Move them, and fix hooks in struct
    hid_device, so that now the callbacks are done to transport-specific
    _open() functions, but not input_open() functions.
    
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index ae298c4bfcbd..4824b19b8646 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -805,6 +805,18 @@ int hidinput_find_field(struct hid_device *hid, unsigned int type, unsigned int
 }
 EXPORT_SYMBOL_GPL(hidinput_find_field);
 
+static int hidinput_open(struct input_dev *dev)
+{
+	struct hid_device *hid = dev->private;
+	return hid->hid_open(hid);
+}
+
+static void hidinput_close(struct input_dev *dev)
+{
+	struct hid_device *hid = dev->private;
+	hid->hid_close(hid);
+}
+
 /*
  * Register the input device; print a message.
  * Configure the input layer interface
@@ -851,8 +863,8 @@ int hidinput_connect(struct hid_device *hid)
 
 				input_dev->private = hid;
 				input_dev->event = hid->hidinput_input_event;
-				input_dev->open = hid->hidinput_open;
-				input_dev->close = hid->hidinput_close;
+				input_dev->open = hidinput_open;
+				input_dev->close = hidinput_close;
 
 				input_dev->name = hid->name;
 				input_dev->phys = hid->phys;

commit c080d89ad91e98fec0e8fc5f448a1ad899bd85c7
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Thu Jan 25 11:43:31 2007 +0100

    HID: hid debug from hid-debug.h to hid layer
    
    hid-debug.h contains a lot of code, and should not therefore
    be a header.
    
    This patch moves the code to generic hid layer as .c source, and
    introduces CONFIG_HID_DEBUG to conditionally compile it, instead
    of playing with #define DEBUG and including hid-debug.h.
    
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 33b1126f5e5d..ae298c4bfcbd 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -34,6 +34,7 @@
 #undef DEBUG
 
 #include <linux/hid.h>
+#include <linux/hid-debug.h>
 
 static int hid_pb_fnmode = 1;
 module_param_named(pb_fnmode, hid_pb_fnmode, int, 0644);
@@ -254,7 +255,7 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 
 #ifdef DEBUG
 	printk(KERN_DEBUG "Mapping: ");
-	resolv_usage(usage->hid);
+	hid_resolv_usage(usage->hid);
 	printk(" ---> ");
 #endif
 
@@ -682,8 +683,8 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 			field->dpad = usage->code;
 	}
 
-#ifdef DEBUG
-	resolv_event(usage->type, usage->code);
+	hid_resolv_event(usage->type, usage->code);
+#ifdef CONFIG_HID_DEBUG
 	printk("\n");
 #endif
 	return;

commit 5556feae1c4e1cf2021b5fb2ef99973125de2250
Author: Anssi Hannula <anssi.hannula@gmail.com>
Date:   Thu Jan 11 16:51:17 2007 +0200

    hid: quirk for multi-input devices with unneeded output reports
    
    Add new quirk HID_QUIRK_SKIP_OUTPUT_REPORTS to skip output reports
    when enumerating reports on a hid-input device. Add this quirk and
    HID_QUIRK_MULTI_INPUT to 0810:0001.
    
    PantherLord Twin USB Joystick, 0810:0001 has separate input reports
    for 2 distinct game controllers in the same interface, so it needs
    HID_QUIRK_MULTI_INPUT. However, the device also contains one output
    report per controller which is used to control the force feedback
    function, and we do not want those to appear as separate input
    devices as well. The simplest approach seems to be to add a quirk to
    skip output reports on 0810:0001, and allow the force feedback
    driver to handle those.
    
    Signed-off-by: Anssi Hannula <anssi.hannula@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index c7a6833f6821..33b1126f5e5d 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -816,6 +816,7 @@ int hidinput_connect(struct hid_device *hid)
 	struct hid_input *hidinput = NULL;
 	struct input_dev *input_dev;
 	int i, j, k;
+	int max_report_type = HID_OUTPUT_REPORT;
 
 	INIT_LIST_HEAD(&hid->inputs);
 
@@ -828,7 +829,10 @@ int hidinput_connect(struct hid_device *hid)
 	if (i == hid->maxcollection)
 		return -1;
 
-	for (k = HID_INPUT_REPORT; k <= HID_OUTPUT_REPORT; k++)
+	if (hid->quirks & HID_QUIRK_SKIP_OUTPUT_REPORTS)
+		max_report_type = HID_INPUT_REPORT;
+
+	for (k = HID_INPUT_REPORT; k <= max_report_type; k++)
 		list_for_each_entry(report, &hid->report_enum[k].report_list, list) {
 
 			if (!report->maxfield)

commit 76398f9667e8369023ed5f4847fb59e9da8b6968
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Mon Jan 29 12:44:41 2007 +0100

    HID: fix pb_fnmode and move it to generic HID
    
    The apple powerbook people are used to switch the pb_fnmode
    setting at runtime through writing to sysfs, altering the
    module parameter value. This was broken for them in 2.6.20-rc1
    when generic HID layer was introduced, as the pb_fnmode flag
    was made per-hiddevice, instead of global variable.
    
    This patch moves the pb_fnmode module parameter from usbhid module
    to hid module, but apart from that retains backward compatibility
    with respect to changing the mode through sysfs.
    
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 981fcf01d41b..c7a6833f6821 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -35,6 +35,11 @@
 
 #include <linux/hid.h>
 
+static int hid_pb_fnmode = 1;
+module_param_named(pb_fnmode, hid_pb_fnmode, int, 0644);
+MODULE_PARM_DESC(pb_fnmode,
+		"Mode of fn key on PowerBooks (0 = disabled, 1 = fkeyslast, 2 = fkeysfirst)");
+
 #define unk	KEY_UNKNOWN
 
 static const unsigned char hid_keyboard[256] = {
@@ -154,7 +159,7 @@ static int hidinput_pb_event(struct hid_device *hid, struct input_dev *input,
 		return 1;
 	}
 
-	if (hid->pb_fnmode) {
+	if (hid_pb_fnmode) {
 		int do_translate;
 
 		trans = find_translation(powerbook_fn_keys, usage->code);
@@ -163,8 +168,8 @@ static int hidinput_pb_event(struct hid_device *hid, struct input_dev *input,
 				do_translate = 1;
 			else if (trans->flags & POWERBOOK_FLAG_FKEY)
 				do_translate =
-					(hid->pb_fnmode == 2 &&  (hid->quirks & HID_QUIRK_POWERBOOK_FN_ON)) ||
-					(hid->pb_fnmode == 1 && !(hid->quirks & HID_QUIRK_POWERBOOK_FN_ON));
+					(hid_pb_fnmode == 2 &&  (hid->quirks & HID_QUIRK_POWERBOOK_FN_ON)) ||
+					(hid_pb_fnmode == 1 && !(hid->quirks & HID_QUIRK_POWERBOOK_FN_ON));
 			else
 				do_translate = (hid->quirks & HID_QUIRK_POWERBOOK_FN_ON);
 

commit 8eda232e226b97c8f2fcbc5f672135247c1ee348
Author: Simon Bennett <simon@levanta.com>
Date:   Wed Jan 24 10:27:20 2007 +0100

    HID: fix hid-input mapping for Firefly Mini Remote Control
    
    Patch adds entries to the HID consumer page for the Firefly
    Mini IR remote control
    
    Signed-off-by: Simon Bennett <simon@levanta.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 9cf591a1bda3..981fcf01d41b 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -431,6 +431,7 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 				case 0x040: map_key_clear(KEY_MENU);		break;
 				case 0x045: map_key_clear(KEY_RADIO);		break;
 
+				case 0x083: map_key_clear(KEY_LAST);		break;
 				case 0x088: map_key_clear(KEY_PC);		break;
 				case 0x089: map_key_clear(KEY_TV);		break;
 				case 0x08a: map_key_clear(KEY_WWW);		break;
@@ -448,6 +449,7 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 				case 0x096: map_key_clear(KEY_TAPE);		break;
 				case 0x097: map_key_clear(KEY_TV2);		break;
 				case 0x098: map_key_clear(KEY_SAT);		break;
+				case 0x09a: map_key_clear(KEY_PVR);		break;
 
 				case 0x09c: map_key_clear(KEY_CHANNELUP);	break;
 				case 0x09d: map_key_clear(KEY_CHANNELDOWN);	break;

commit 1f3ab013336e76687441462961000157c8980bb8
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Tue Jan 16 00:30:42 2007 +0100

    HID: hid/hid-input.c doesn't need to include linux/usb/input.h
    
    There is no reason for generic hid-input.c to include usb-specific
    input.h.
    
    As a sideeffect, this also fixes warning of redefinition of dbg()
    macro, when hid-input.c is compiled with DEBUG (as there is a clash
    between dbg() from hid.h and usb/input.h).
    
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 95b9573c5f93..9cf591a1bda3 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -30,7 +30,6 @@
 #include <linux/module.h>
 #include <linux/slab.h>
 #include <linux/kernel.h>
-#include <linux/usb/input.h>
 
 #undef DEBUG
 

commit d4ae650a904612ffb7edd3f28b69b022988d2466
Author: Simon Budig <simon@budig.de>
Date:   Mon Jan 15 17:28:47 2007 +0100

    HID: proper LED-mapping for SpaceNavigator
    
    This change introduces a mapping for LED indicators between the HID
    specification and the Linux input subsystem. The previous code properly
    mapped the LEDs relevant for Keyboards, but garbeled the remaining ones.
    With this change all LED enums from the input system get mapped to more
    or less equivalent LED numbers from the HID specification.
    
    This patch also ensures that the unused bits in a HID report to the
    device are zeroed out. This makes the 3Dconnexion SpaceNavigator fully
    usable with the linux input system.
    
    Signed-off-by: Simon Budig <simon@budig.de>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 28689e3eb552..95b9573c5f93 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -364,9 +364,22 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 			break;
 
 		case HID_UP_LED:
-			if (((usage->hid - 1) & 0xffff) >= LED_MAX)
-				goto ignore;
-			map_led((usage->hid - 1) & 0xffff);
+
+			switch (usage->hid & 0xffff) {                        /* HID-Value:                   */
+				case 0x01:  map_led (LED_NUML);     break;    /*   "Num Lock"                 */
+				case 0x02:  map_led (LED_CAPSL);    break;    /*   "Caps Lock"                */
+				case 0x03:  map_led (LED_SCROLLL);  break;    /*   "Scroll Lock"              */
+				case 0x04:  map_led (LED_COMPOSE);  break;    /*   "Compose"                  */
+				case 0x05:  map_led (LED_KANA);     break;    /*   "Kana"                     */
+				case 0x27:  map_led (LED_SLEEP);    break;    /*   "Stand-By"                 */
+				case 0x4c:  map_led (LED_SUSPEND);  break;    /*   "System Suspend"           */
+				case 0x09:  map_led (LED_MUTE);     break;    /*   "Mute"                     */
+				case 0x4b:  map_led (LED_MISC);     break;    /*   "Generic Indicator"        */
+				case 0x19:  map_led (LED_MAIL);     break;    /*   "Message Waiting"          */
+				case 0x4d:  map_led (LED_CHARGING); break;    /*   "External Power Connected" */
+
+				default: goto ignore;
+			}
 			break;
 
 		case HID_UP_DIGITIZER:

commit 35068976916fdef82d6e69ef1f8c9a1c47732759
Author: Adrian Drzewiecki <adriand@drze.net>
Date:   Sat Jan 6 12:37:26 2007 +0100

    HID: fix mappings for DiNovo Edge Keyboard - Logitech USB BT receiver
    
    This patch fixes mappings for the Logitech USB BT receiver that
    ships along with Logitech's DiNovo Edge keyboard. Without these
    changes, the "touchwheel" does not work as intended (a mouse)
    
    Signed-off-by: Adrian Drzewiecki <adriand@drze.net>
    Acked-by: Vojtech Pavlik <vojtech@suse.cz>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 998638020ea0..28689e3eb552 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -68,6 +68,7 @@ static const struct {
 #define map_led(c)	do { usage->code = c; usage->type = EV_LED; bit = input->ledbit; max = LED_MAX; } while (0)
 
 #define map_abs_clear(c)	do { map_abs(c); clear_bit(c, bit); } while (0)
+#define map_rel_clear(c)	do { map_rel(c); clear_bit(c, bit); } while (0)
 #define map_key_clear(c)	do { map_key(c); clear_bit(c, bit); } while (0)
 
 #ifdef CONFIG_USB_HIDINPUT_POWERBOOK
@@ -292,7 +293,7 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 					}
 			}
 
-			map_key(code);
+			map_key_clear(code);
 			break;
 
 
@@ -343,9 +344,9 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 				case HID_GD_RX: case HID_GD_RY: case HID_GD_RZ:
 				case HID_GD_SLIDER: case HID_GD_DIAL: case HID_GD_WHEEL:
 					if (field->flags & HID_MAIN_ITEM_RELATIVE)
-						map_rel(usage->hid & 0xf);
+						map_rel_clear(usage->hid & 0xf);
 					else
-						map_abs(usage->hid & 0xf);
+						map_abs_clear(usage->hid & 0xf);
 					break;
 
 				case HID_GD_HATSWITCH:
@@ -500,7 +501,7 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 				case 0x22f: map_key_clear(KEY_ZOOMRESET);	break;
 				case 0x233: map_key_clear(KEY_SCROLLUP);	break;
 				case 0x234: map_key_clear(KEY_SCROLLDOWN);	break;
-				case 0x238: map_rel(REL_HWHEEL);		break;
+				case 0x238: map_rel_clear(REL_HWHEEL);		break;
 				case 0x25f: map_key_clear(KEY_CANCEL);		break;
 				case 0x279: map_key_clear(KEY_REDO);		break;
 

commit 1c1e40b5ad6e345feba69bc612db006efccf4cdc
Author: Florian Festi <ffesti@redhat.com>
Date:   Thu Dec 14 11:59:11 2006 +0100

    input/hid: Supporting more keys from the HUT Consumer Page
    
    On USB keyboards lots of hot/internet keys are not working. This patch
    adds support for a number of keys from the USB HID Usage Table
    (http://www.usb.org/developers/devclass_docs/Hut1_12.pdf).
    
    It also adds several new key codes. Most of them are used on real world
    keyboards I know. I added some others (KEY_+ EDITOR, GRAPHICSEDITOR, DATABASE,
    NEWS, VOICEMAIL, VIDEOPHONE) to avoid "holes".
    
    I also added KEY_ZOOMRESET as it is possible to have a inet keyboard and a
    remote control  in parallel and it makes sense to have them behave differently.
    
    Signed-off-by: Florian Festi <ffesti@redhat.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 14cdf09316ce..998638020ea0 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -415,12 +415,31 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 				case 0x000: goto ignore;
 				case 0x034: map_key_clear(KEY_SLEEP);		break;
 				case 0x036: map_key_clear(BTN_MISC);		break;
+				case 0x040: map_key_clear(KEY_MENU);		break;
 				case 0x045: map_key_clear(KEY_RADIO);		break;
+
+				case 0x088: map_key_clear(KEY_PC);		break;
+				case 0x089: map_key_clear(KEY_TV);		break;
 				case 0x08a: map_key_clear(KEY_WWW);		break;
+				case 0x08b: map_key_clear(KEY_DVD);		break;
+				case 0x08c: map_key_clear(KEY_PHONE);		break;
 				case 0x08d: map_key_clear(KEY_PROGRAM);		break;
+				case 0x08e: map_key_clear(KEY_VIDEOPHONE);	break;
+				case 0x08f: map_key_clear(KEY_GAMES);		break;
+				case 0x090: map_key_clear(KEY_MEMO);		break;
+				case 0x091: map_key_clear(KEY_CD);		break;
+				case 0x092: map_key_clear(KEY_VCR);		break;
+				case 0x093: map_key_clear(KEY_TUNER);		break;
+				case 0x094: map_key_clear(KEY_EXIT);		break;
 				case 0x095: map_key_clear(KEY_HELP);		break;
+				case 0x096: map_key_clear(KEY_TAPE);		break;
+				case 0x097: map_key_clear(KEY_TV2);		break;
+				case 0x098: map_key_clear(KEY_SAT);		break;
+
 				case 0x09c: map_key_clear(KEY_CHANNELUP);	break;
 				case 0x09d: map_key_clear(KEY_CHANNELDOWN);	break;
+				case 0x0a0: map_key_clear(KEY_VCR2);		break;
+
 				case 0x0b0: map_key_clear(KEY_PLAY);		break;
 				case 0x0b1: map_key_clear(KEY_PAUSE);		break;
 				case 0x0b2: map_key_clear(KEY_RECORD);		break;
@@ -430,6 +449,7 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 				case 0x0b6: map_key_clear(KEY_PREVIOUSSONG);	break;
 				case 0x0b7: map_key_clear(KEY_STOPCD);		break;
 				case 0x0b8: map_key_clear(KEY_EJECTCD);		break;
+
 				case 0x0cd: map_key_clear(KEY_PLAYPAUSE);	break;
 			        case 0x0e0: map_abs_clear(ABS_VOLUME);		break;
 				case 0x0e2: map_key_clear(KEY_MUTE);		break;
@@ -437,11 +457,30 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 				case 0x0e9: map_key_clear(KEY_VOLUMEUP);	break;
 				case 0x0ea: map_key_clear(KEY_VOLUMEDOWN);	break;
 				case 0x183: map_key_clear(KEY_CONFIG);		break;
+				case 0x184: map_key_clear(KEY_WORDPROCESSOR);	break;
+				case 0x185: map_key_clear(KEY_EDITOR);		break;
+				case 0x186: map_key_clear(KEY_SPREADSHEET);	break;
+				case 0x187: map_key_clear(KEY_GRAPHICSEDITOR);	break;
+				case 0x188: map_key_clear(KEY_PRESENTATION);	break;
+				case 0x189: map_key_clear(KEY_DATABASE);	break;
 				case 0x18a: map_key_clear(KEY_MAIL);		break;
+				case 0x18b: map_key_clear(KEY_NEWS);		break;
+				case 0x18c: map_key_clear(KEY_VOICEMAIL);	break;
+				case 0x18d: map_key_clear(KEY_ADDRESSBOOK);	break;
+				case 0x18e: map_key_clear(KEY_CALENDAR);	break;
+				case 0x191: map_key_clear(KEY_FINANCE);		break;
 				case 0x192: map_key_clear(KEY_CALC);		break;
 				case 0x194: map_key_clear(KEY_FILE);		break;
+				case 0x196: map_key_clear(KEY_WWW);		break;
+				case 0x19e: map_key_clear(KEY_COFFEE);		break;
+				case 0x1a6: map_key_clear(KEY_HELP);		break;
 				case 0x1a7: map_key_clear(KEY_DOCUMENTS);	break;
+				case 0x1bc: map_key_clear(KEY_MESSENGER);	break;
+				case 0x1bd: map_key_clear(KEY_INFO);		break;
 				case 0x201: map_key_clear(KEY_NEW);		break;
+				case 0x202: map_key_clear(KEY_OPEN);		break;
+				case 0x203: map_key_clear(KEY_CLOSE);		break;
+				case 0x204: map_key_clear(KEY_EXIT);		break;
 				case 0x207: map_key_clear(KEY_SAVE);		break;
 				case 0x208: map_key_clear(KEY_PRINT);		break;
 				case 0x209: map_key_clear(KEY_PROPS);		break;
@@ -456,10 +495,15 @@ static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_fiel
 				case 0x226: map_key_clear(KEY_STOP);		break;
 				case 0x227: map_key_clear(KEY_REFRESH);		break;
 				case 0x22a: map_key_clear(KEY_BOOKMARKS);	break;
+				case 0x22d: map_key_clear(KEY_ZOOMIN);		break;
+				case 0x22e: map_key_clear(KEY_ZOOMOUT);		break;
+				case 0x22f: map_key_clear(KEY_ZOOMRESET);	break;
 				case 0x233: map_key_clear(KEY_SCROLLUP);	break;
 				case 0x234: map_key_clear(KEY_SCROLLDOWN);	break;
 				case 0x238: map_rel(REL_HWHEEL);		break;
+				case 0x25f: map_key_clear(KEY_CANCEL);		break;
 				case 0x279: map_key_clear(KEY_REDO);		break;
+
 				case 0x289: map_key_clear(KEY_REPLY);		break;
 				case 0x28b: map_key_clear(KEY_FORWARDMAIL);	break;
 				case 0x28c: map_key_clear(KEY_SEND);		break;

commit 4c2ae844b5ef85fd4b571c9c91ac48afa6ef2dfc
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Fri Dec 8 18:41:22 2006 +0100

    [PATCH] Generic HID layer - pb_fnmode
    
    pb_fnmode parameter has to be passed to usbhid, both for compatibility reasons
    and also because it logically belongs there.
    
    Also removes empty hid-input.c file in drivers/usb/input.
    
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Cc: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index e542ef971c46..14cdf09316ce 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -128,12 +128,6 @@ static struct hidinput_key_translation powerbook_iso_keyboard[] = {
 	{ }
 };
 
-
-static int usbhid_pb_fnmode = 1;
-module_param_named(pb_fnmode, usbhid_pb_fnmode, int, 0644);
-MODULE_PARM_DESC(pb_fnmode,
-		"Mode of fn key on PowerBooks (0 = disabled, 1 = fkeyslast, 2 = fkeysfirst)");
-
 static struct hidinput_key_translation *find_translation(struct hidinput_key_translation *table, u16 from)
 {
 	struct hidinput_key_translation *trans;
@@ -160,7 +154,7 @@ static int hidinput_pb_event(struct hid_device *hid, struct input_dev *input,
 		return 1;
 	}
 
-	if (usbhid_pb_fnmode) {
+	if (hid->pb_fnmode) {
 		int do_translate;
 
 		trans = find_translation(powerbook_fn_keys, usage->code);
@@ -169,8 +163,8 @@ static int hidinput_pb_event(struct hid_device *hid, struct input_dev *input,
 				do_translate = 1;
 			else if (trans->flags & POWERBOOK_FLAG_FKEY)
 				do_translate =
-					(usbhid_pb_fnmode == 2 &&  (hid->quirks & HID_QUIRK_POWERBOOK_FN_ON)) ||
-					(usbhid_pb_fnmode == 1 && !(hid->quirks & HID_QUIRK_POWERBOOK_FN_ON));
+					(hid->pb_fnmode == 2 &&  (hid->quirks & HID_QUIRK_POWERBOOK_FN_ON)) ||
+					(hid->pb_fnmode == 1 && !(hid->quirks & HID_QUIRK_POWERBOOK_FN_ON));
 			else
 				do_translate = (hid->quirks & HID_QUIRK_POWERBOOK_FN_ON);
 

commit 4916b3a57fc94664677d439b911b8aaf86c7ec23
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Fri Dec 8 18:41:03 2006 +0100

    [PATCH] Generic HID layer - USB API
    
    - 'dev' in struct hid_device changed from struct usb_device to
      struct device and fixed all the users
    - renamed functions which are part of USB HID API from 'hid_*' to
      'usbhid_*'
    - force feedback initialization moved from common part into USB-specific
      driver
    - added usbhid.h header for USB HID API users
    - removed USB-specific fields from struct hid_device and moved them
      to new usbhid_device, which is pointed to by hid_device->driver_data
    - fixed all USB users to use this new structure
    
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Cc: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 6d3d80ba9582..e542ef971c46 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -798,8 +798,7 @@ int hidinput_connect(struct hid_device *hid)
 				input_dev->id.vendor  = hid->vendor;
 				input_dev->id.product = hid->product;
 				input_dev->id.version = hid->version;
-				input_dev->cdev.dev = &hid->intf->dev;
-
+				input_dev->cdev.dev = hid->dev;
 				hidinput->input = input_dev;
 				list_add_tail(&hidinput->list, &hid->inputs);
 			}
@@ -821,13 +820,8 @@ int hidinput_connect(struct hid_device *hid)
 			}
 		}
 
-	/* This only gets called when we are a single-input (most of the
-	 * time). IOW, not a HID_QUIRK_MULTI_INPUT. The hid_ff_init() is
-	 * only useful in this case, and not for multi-input quirks. */
-	if (hidinput) {
-		hid_ff_init(hid);
+	if (hidinput)
 		input_register_device(hidinput->input);
-	}
 
 	return 0;
 }

commit 229695e51efc4ed5e04ab471c82591d0f432909d
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Fri Dec 8 18:40:53 2006 +0100

    [PATCH] Generic HID layer - API
    
    - fixed generic API (added neccessary EXPORT_SYMBOL, fixed hid.h to provide correct
      prototypes)
    - extended hid_device with open/close/event function pointers to driver-specific
      functions
    - added driver specific driver_data to hid_device
    
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Cc: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index d459005062e0..6d3d80ba9582 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -727,8 +727,9 @@ void hidinput_report_event(struct hid_device *hid, struct hid_report *report)
 	list_for_each_entry(hidinput, &hid->inputs, list)
 		input_sync(hidinput->input);
 }
+EXPORT_SYMBOL_GPL(hidinput_report_event);
 
-static int hidinput_find_field(struct hid_device *hid, unsigned int type, unsigned int code, struct hid_field **field)
+int hidinput_find_field(struct hid_device *hid, unsigned int type, unsigned int code, struct hid_field **field)
 {
 	struct hid_report *report;
 	int i, j;
@@ -743,6 +744,7 @@ static int hidinput_find_field(struct hid_device *hid, unsigned int type, unsign
 	}
 	return -1;
 }
+EXPORT_SYMBOL_GPL(hidinput_find_field);
 
 /*
  * Register the input device; print a message.
@@ -752,7 +754,6 @@ static int hidinput_find_field(struct hid_device *hid, unsigned int type, unsign
 
 int hidinput_connect(struct hid_device *hid)
 {
-	struct usb_device *dev = hid->dev;
 	struct hid_report *report;
 	struct hid_input *hidinput = NULL;
 	struct input_dev *input_dev;
@@ -786,14 +787,17 @@ int hidinput_connect(struct hid_device *hid)
 				}
 
 				input_dev->private = hid;
-				input_dev->event = hidinput_input_event;
-				input_dev->open = hidinput_open;
-				input_dev->close = hidinput_close;
+				input_dev->event = hid->hidinput_input_event;
+				input_dev->open = hid->hidinput_open;
+				input_dev->close = hid->hidinput_close;
 
 				input_dev->name = hid->name;
 				input_dev->phys = hid->phys;
 				input_dev->uniq = hid->uniq;
-				usb_to_input_id(dev, &input_dev->id);
+				input_dev->id.bustype = hid->bus;
+				input_dev->id.vendor  = hid->vendor;
+				input_dev->id.product = hid->product;
+				input_dev->id.version = hid->version;
 				input_dev->cdev.dev = &hid->intf->dev;
 
 				hidinput->input = input_dev;
@@ -827,6 +831,7 @@ int hidinput_connect(struct hid_device *hid)
 
 	return 0;
 }
+EXPORT_SYMBOL_GPL(hidinput_connect);
 
 void hidinput_disconnect(struct hid_device *hid)
 {
@@ -838,3 +843,5 @@ void hidinput_disconnect(struct hid_device *hid)
 		kfree(hidinput);
 	}
 }
+EXPORT_SYMBOL_GPL(hidinput_disconnect);
+

commit dde5845a529ff753364a6d1aea61180946270bfa
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Fri Dec 8 18:40:44 2006 +0100

    [PATCH] Generic HID layer - code split
    
    The "big main" split of USB HID code into generic HID code and
    USB-transport specific HID handling.
    
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Cc: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
new file mode 100644
index 000000000000..d459005062e0
--- /dev/null
+++ b/drivers/hid/hid-input.c
@@ -0,0 +1,840 @@
+/*
+ * $Id: hid-input.c,v 1.2 2002/04/23 00:59:25 rdamazio Exp $
+ *
+ *  Copyright (c) 2000-2001 Vojtech Pavlik
+ *  Copyright (c) 2006 Jiri Kosina
+ *
+ *  HID to Linux Input mapping
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * Should you need to contact me, the author, you can do so either by
+ * e-mail - mail your message to <vojtech@ucw.cz>, or by paper mail:
+ * Vojtech Pavlik, Simunkova 1594, Prague 8, 182 00 Czech Republic
+ */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/kernel.h>
+#include <linux/usb/input.h>
+
+#undef DEBUG
+
+#include <linux/hid.h>
+
+#define unk	KEY_UNKNOWN
+
+static const unsigned char hid_keyboard[256] = {
+	  0,  0,  0,  0, 30, 48, 46, 32, 18, 33, 34, 35, 23, 36, 37, 38,
+	 50, 49, 24, 25, 16, 19, 31, 20, 22, 47, 17, 45, 21, 44,  2,  3,
+	  4,  5,  6,  7,  8,  9, 10, 11, 28,  1, 14, 15, 57, 12, 13, 26,
+	 27, 43, 43, 39, 40, 41, 51, 52, 53, 58, 59, 60, 61, 62, 63, 64,
+	 65, 66, 67, 68, 87, 88, 99, 70,119,110,102,104,111,107,109,106,
+	105,108,103, 69, 98, 55, 74, 78, 96, 79, 80, 81, 75, 76, 77, 71,
+	 72, 73, 82, 83, 86,127,116,117,183,184,185,186,187,188,189,190,
+	191,192,193,194,134,138,130,132,128,129,131,137,133,135,136,113,
+	115,114,unk,unk,unk,121,unk, 89, 93,124, 92, 94, 95,unk,unk,unk,
+	122,123, 90, 91, 85,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,
+	unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,
+	unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,
+	unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,
+	unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,
+	 29, 42, 56,125, 97, 54,100,126,164,166,165,163,161,115,114,113,
+	150,158,159,128,136,177,178,176,142,152,173,140,unk,unk,unk,unk
+};
+
+static const struct {
+	__s32 x;
+	__s32 y;
+}  hid_hat_to_axis[] = {{ 0, 0}, { 0,-1}, { 1,-1}, { 1, 0}, { 1, 1}, { 0, 1}, {-1, 1}, {-1, 0}, {-1,-1}};
+
+#define map_abs(c)	do { usage->code = c; usage->type = EV_ABS; bit = input->absbit; max = ABS_MAX; } while (0)
+#define map_rel(c)	do { usage->code = c; usage->type = EV_REL; bit = input->relbit; max = REL_MAX; } while (0)
+#define map_key(c)	do { usage->code = c; usage->type = EV_KEY; bit = input->keybit; max = KEY_MAX; } while (0)
+#define map_led(c)	do { usage->code = c; usage->type = EV_LED; bit = input->ledbit; max = LED_MAX; } while (0)
+
+#define map_abs_clear(c)	do { map_abs(c); clear_bit(c, bit); } while (0)
+#define map_key_clear(c)	do { map_key(c); clear_bit(c, bit); } while (0)
+
+#ifdef CONFIG_USB_HIDINPUT_POWERBOOK
+
+struct hidinput_key_translation {
+	u16 from;
+	u16 to;
+	u8 flags;
+};
+
+#define POWERBOOK_FLAG_FKEY 0x01
+
+static struct hidinput_key_translation powerbook_fn_keys[] = {
+	{ KEY_BACKSPACE, KEY_DELETE },
+	{ KEY_F1,       KEY_BRIGHTNESSDOWN,     POWERBOOK_FLAG_FKEY },
+	{ KEY_F2,       KEY_BRIGHTNESSUP,       POWERBOOK_FLAG_FKEY },
+	{ KEY_F3,       KEY_MUTE,               POWERBOOK_FLAG_FKEY },
+	{ KEY_F4,       KEY_VOLUMEDOWN,         POWERBOOK_FLAG_FKEY },
+	{ KEY_F5,       KEY_VOLUMEUP,           POWERBOOK_FLAG_FKEY },
+	{ KEY_F6,       KEY_NUMLOCK,            POWERBOOK_FLAG_FKEY },
+	{ KEY_F7,       KEY_SWITCHVIDEOMODE,    POWERBOOK_FLAG_FKEY },
+	{ KEY_F8,       KEY_KBDILLUMTOGGLE,     POWERBOOK_FLAG_FKEY },
+	{ KEY_F9,       KEY_KBDILLUMDOWN,       POWERBOOK_FLAG_FKEY },
+	{ KEY_F10,      KEY_KBDILLUMUP,         POWERBOOK_FLAG_FKEY },
+	{ KEY_UP,       KEY_PAGEUP },
+	{ KEY_DOWN,     KEY_PAGEDOWN },
+	{ KEY_LEFT,     KEY_HOME },
+	{ KEY_RIGHT,    KEY_END },
+	{ }
+};
+
+static struct hidinput_key_translation powerbook_numlock_keys[] = {
+	{ KEY_J,        KEY_KP1 },
+	{ KEY_K,        KEY_KP2 },
+	{ KEY_L,        KEY_KP3 },
+	{ KEY_U,        KEY_KP4 },
+	{ KEY_I,        KEY_KP5 },
+	{ KEY_O,        KEY_KP6 },
+	{ KEY_7,        KEY_KP7 },
+	{ KEY_8,        KEY_KP8 },
+	{ KEY_9,        KEY_KP9 },
+	{ KEY_M,        KEY_KP0 },
+	{ KEY_DOT,      KEY_KPDOT },
+	{ KEY_SLASH,    KEY_KPPLUS },
+	{ KEY_SEMICOLON, KEY_KPMINUS },
+	{ KEY_P,        KEY_KPASTERISK },
+	{ KEY_MINUS,    KEY_KPEQUAL },
+	{ KEY_0,        KEY_KPSLASH },
+	{ KEY_F6,       KEY_NUMLOCK },
+	{ KEY_KPENTER,  KEY_KPENTER },
+	{ KEY_BACKSPACE, KEY_BACKSPACE },
+	{ }
+};
+
+static struct hidinput_key_translation powerbook_iso_keyboard[] = {
+	{ KEY_GRAVE,    KEY_102ND },
+	{ KEY_102ND,    KEY_GRAVE },
+	{ }
+};
+
+
+static int usbhid_pb_fnmode = 1;
+module_param_named(pb_fnmode, usbhid_pb_fnmode, int, 0644);
+MODULE_PARM_DESC(pb_fnmode,
+		"Mode of fn key on PowerBooks (0 = disabled, 1 = fkeyslast, 2 = fkeysfirst)");
+
+static struct hidinput_key_translation *find_translation(struct hidinput_key_translation *table, u16 from)
+{
+	struct hidinput_key_translation *trans;
+
+	/* Look for the translation */
+	for (trans = table; trans->from; trans++)
+		if (trans->from == from)
+			return trans;
+
+	return NULL;
+}
+
+static int hidinput_pb_event(struct hid_device *hid, struct input_dev *input,
+		struct hid_usage *usage, __s32 value)
+{
+	struct hidinput_key_translation *trans;
+
+	if (usage->code == KEY_FN) {
+		if (value) hid->quirks |=  HID_QUIRK_POWERBOOK_FN_ON;
+		else       hid->quirks &= ~HID_QUIRK_POWERBOOK_FN_ON;
+
+		input_event(input, usage->type, usage->code, value);
+
+		return 1;
+	}
+
+	if (usbhid_pb_fnmode) {
+		int do_translate;
+
+		trans = find_translation(powerbook_fn_keys, usage->code);
+		if (trans) {
+			if (test_bit(usage->code, hid->pb_pressed_fn))
+				do_translate = 1;
+			else if (trans->flags & POWERBOOK_FLAG_FKEY)
+				do_translate =
+					(usbhid_pb_fnmode == 2 &&  (hid->quirks & HID_QUIRK_POWERBOOK_FN_ON)) ||
+					(usbhid_pb_fnmode == 1 && !(hid->quirks & HID_QUIRK_POWERBOOK_FN_ON));
+			else
+				do_translate = (hid->quirks & HID_QUIRK_POWERBOOK_FN_ON);
+
+			if (do_translate) {
+				if (value)
+					set_bit(usage->code, hid->pb_pressed_fn);
+				else
+					clear_bit(usage->code, hid->pb_pressed_fn);
+
+				input_event(input, usage->type, trans->to, value);
+
+				return 1;
+			}
+		}
+
+		if (test_bit(usage->code, hid->pb_pressed_numlock) ||
+				test_bit(LED_NUML, input->led)) {
+			trans = find_translation(powerbook_numlock_keys, usage->code);
+
+			if (trans) {
+				if (value)
+					set_bit(usage->code, hid->pb_pressed_numlock);
+				else
+					clear_bit(usage->code, hid->pb_pressed_numlock);
+
+				input_event(input, usage->type, trans->to, value);
+			}
+
+			return 1;
+		}
+	}
+
+	if (hid->quirks & HID_QUIRK_POWERBOOK_ISO_KEYBOARD) {
+		trans = find_translation(powerbook_iso_keyboard, usage->code);
+		if (trans) {
+			input_event(input, usage->type, trans->to, value);
+			return 1;
+		}
+	}
+
+	return 0;
+}
+
+static void hidinput_pb_setup(struct input_dev *input)
+{
+	struct hidinput_key_translation *trans;
+
+	set_bit(KEY_NUMLOCK, input->keybit);
+
+	/* Enable all needed keys */
+	for (trans = powerbook_fn_keys; trans->from; trans++)
+		set_bit(trans->to, input->keybit);
+
+	for (trans = powerbook_numlock_keys; trans->from; trans++)
+		set_bit(trans->to, input->keybit);
+
+	for (trans = powerbook_iso_keyboard; trans->from; trans++)
+		set_bit(trans->to, input->keybit);
+
+}
+#else
+static inline int hidinput_pb_event(struct hid_device *hid, struct input_dev *input,
+		struct hid_usage *usage, __s32 value)
+{
+	return 0;
+}
+
+static inline void hidinput_pb_setup(struct input_dev *input)
+{
+}
+#endif
+
+static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_field *field,
+				     struct hid_usage *usage)
+{
+	struct input_dev *input = hidinput->input;
+	struct hid_device *device = input->private;
+	int max = 0, code;
+	unsigned long *bit = NULL;
+
+	field->hidinput = hidinput;
+
+#ifdef DEBUG
+	printk(KERN_DEBUG "Mapping: ");
+	resolv_usage(usage->hid);
+	printk(" ---> ");
+#endif
+
+	if (field->flags & HID_MAIN_ITEM_CONSTANT)
+		goto ignore;
+
+	switch (usage->hid & HID_USAGE_PAGE) {
+
+		case HID_UP_UNDEFINED:
+			goto ignore;
+
+		case HID_UP_KEYBOARD:
+
+			set_bit(EV_REP, input->evbit);
+
+			if ((usage->hid & HID_USAGE) < 256) {
+				if (!hid_keyboard[usage->hid & HID_USAGE]) goto ignore;
+				map_key_clear(hid_keyboard[usage->hid & HID_USAGE]);
+			} else
+				map_key(KEY_UNKNOWN);
+
+			break;
+
+		case HID_UP_BUTTON:
+
+			code = ((usage->hid - 1) & 0xf);
+
+			switch (field->application) {
+				case HID_GD_MOUSE:
+				case HID_GD_POINTER:  code += 0x110; break;
+				case HID_GD_JOYSTICK: code += 0x120; break;
+				case HID_GD_GAMEPAD:  code += 0x130; break;
+				default:
+					switch (field->physical) {
+						case HID_GD_MOUSE:
+						case HID_GD_POINTER:  code += 0x110; break;
+						case HID_GD_JOYSTICK: code += 0x120; break;
+						case HID_GD_GAMEPAD:  code += 0x130; break;
+						default:              code += 0x100;
+					}
+			}
+
+			map_key(code);
+			break;
+
+
+		case HID_UP_SIMULATION:
+
+			switch (usage->hid & 0xffff) {
+				case 0xba: map_abs(ABS_RUDDER);   break;
+				case 0xbb: map_abs(ABS_THROTTLE); break;
+				case 0xc4: map_abs(ABS_GAS);      break;
+				case 0xc5: map_abs(ABS_BRAKE);    break;
+				case 0xc8: map_abs(ABS_WHEEL);    break;
+				default:   goto ignore;
+			}
+			break;
+
+		case HID_UP_GENDESK:
+
+			if ((usage->hid & 0xf0) == 0x80) {	/* SystemControl */
+				switch (usage->hid & 0xf) {
+					case 0x1: map_key_clear(KEY_POWER);  break;
+					case 0x2: map_key_clear(KEY_SLEEP);  break;
+					case 0x3: map_key_clear(KEY_WAKEUP); break;
+					default: goto unknown;
+				}
+				break;
+			}
+
+			if ((usage->hid & 0xf0) == 0x90) {	/* D-pad */
+				switch (usage->hid) {
+					case HID_GD_UP:	   usage->hat_dir = 1; break;
+					case HID_GD_DOWN:  usage->hat_dir = 5; break;
+					case HID_GD_RIGHT: usage->hat_dir = 3; break;
+					case HID_GD_LEFT:  usage->hat_dir = 7; break;
+					default: goto unknown;
+				}
+				if (field->dpad) {
+					map_abs(field->dpad);
+					goto ignore;
+				}
+				map_abs(ABS_HAT0X);
+				break;
+			}
+
+			switch (usage->hid) {
+
+				/* These usage IDs map directly to the usage codes. */
+				case HID_GD_X: case HID_GD_Y: case HID_GD_Z:
+				case HID_GD_RX: case HID_GD_RY: case HID_GD_RZ:
+				case HID_GD_SLIDER: case HID_GD_DIAL: case HID_GD_WHEEL:
+					if (field->flags & HID_MAIN_ITEM_RELATIVE)
+						map_rel(usage->hid & 0xf);
+					else
+						map_abs(usage->hid & 0xf);
+					break;
+
+				case HID_GD_HATSWITCH:
+					usage->hat_min = field->logical_minimum;
+					usage->hat_max = field->logical_maximum;
+					map_abs(ABS_HAT0X);
+					break;
+
+				case HID_GD_START:	map_key_clear(BTN_START);	break;
+				case HID_GD_SELECT:	map_key_clear(BTN_SELECT);	break;
+
+				default: goto unknown;
+			}
+
+			break;
+
+		case HID_UP_LED:
+			if (((usage->hid - 1) & 0xffff) >= LED_MAX)
+				goto ignore;
+			map_led((usage->hid - 1) & 0xffff);
+			break;
+
+		case HID_UP_DIGITIZER:
+
+			switch (usage->hid & 0xff) {
+
+				case 0x30: /* TipPressure */
+					if (!test_bit(BTN_TOUCH, input->keybit)) {
+						device->quirks |= HID_QUIRK_NOTOUCH;
+						set_bit(EV_KEY, input->evbit);
+						set_bit(BTN_TOUCH, input->keybit);
+					}
+
+					map_abs_clear(ABS_PRESSURE);
+					break;
+
+				case 0x32: /* InRange */
+					switch (field->physical & 0xff) {
+						case 0x21: map_key(BTN_TOOL_MOUSE); break;
+						case 0x22: map_key(BTN_TOOL_FINGER); break;
+						default: map_key(BTN_TOOL_PEN); break;
+					}
+					break;
+
+				case 0x3c: /* Invert */
+					map_key_clear(BTN_TOOL_RUBBER);
+					break;
+
+				case 0x33: /* Touch */
+				case 0x42: /* TipSwitch */
+				case 0x43: /* TipSwitch2 */
+					device->quirks &= ~HID_QUIRK_NOTOUCH;
+					map_key_clear(BTN_TOUCH);
+					break;
+
+				case 0x44: /* BarrelSwitch */
+					map_key_clear(BTN_STYLUS);
+					break;
+
+				default:  goto unknown;
+			}
+			break;
+
+		case HID_UP_CONSUMER:	/* USB HUT v1.1, pages 56-62 */
+
+			switch (usage->hid & HID_USAGE) {
+				case 0x000: goto ignore;
+				case 0x034: map_key_clear(KEY_SLEEP);		break;
+				case 0x036: map_key_clear(BTN_MISC);		break;
+				case 0x045: map_key_clear(KEY_RADIO);		break;
+				case 0x08a: map_key_clear(KEY_WWW);		break;
+				case 0x08d: map_key_clear(KEY_PROGRAM);		break;
+				case 0x095: map_key_clear(KEY_HELP);		break;
+				case 0x09c: map_key_clear(KEY_CHANNELUP);	break;
+				case 0x09d: map_key_clear(KEY_CHANNELDOWN);	break;
+				case 0x0b0: map_key_clear(KEY_PLAY);		break;
+				case 0x0b1: map_key_clear(KEY_PAUSE);		break;
+				case 0x0b2: map_key_clear(KEY_RECORD);		break;
+				case 0x0b3: map_key_clear(KEY_FASTFORWARD);	break;
+				case 0x0b4: map_key_clear(KEY_REWIND);		break;
+				case 0x0b5: map_key_clear(KEY_NEXTSONG);	break;
+				case 0x0b6: map_key_clear(KEY_PREVIOUSSONG);	break;
+				case 0x0b7: map_key_clear(KEY_STOPCD);		break;
+				case 0x0b8: map_key_clear(KEY_EJECTCD);		break;
+				case 0x0cd: map_key_clear(KEY_PLAYPAUSE);	break;
+			        case 0x0e0: map_abs_clear(ABS_VOLUME);		break;
+				case 0x0e2: map_key_clear(KEY_MUTE);		break;
+				case 0x0e5: map_key_clear(KEY_BASSBOOST);	break;
+				case 0x0e9: map_key_clear(KEY_VOLUMEUP);	break;
+				case 0x0ea: map_key_clear(KEY_VOLUMEDOWN);	break;
+				case 0x183: map_key_clear(KEY_CONFIG);		break;
+				case 0x18a: map_key_clear(KEY_MAIL);		break;
+				case 0x192: map_key_clear(KEY_CALC);		break;
+				case 0x194: map_key_clear(KEY_FILE);		break;
+				case 0x1a7: map_key_clear(KEY_DOCUMENTS);	break;
+				case 0x201: map_key_clear(KEY_NEW);		break;
+				case 0x207: map_key_clear(KEY_SAVE);		break;
+				case 0x208: map_key_clear(KEY_PRINT);		break;
+				case 0x209: map_key_clear(KEY_PROPS);		break;
+				case 0x21a: map_key_clear(KEY_UNDO);		break;
+				case 0x21b: map_key_clear(KEY_COPY);		break;
+				case 0x21c: map_key_clear(KEY_CUT);		break;
+				case 0x21d: map_key_clear(KEY_PASTE);		break;
+				case 0x221: map_key_clear(KEY_FIND);		break;
+				case 0x223: map_key_clear(KEY_HOMEPAGE);	break;
+				case 0x224: map_key_clear(KEY_BACK);		break;
+				case 0x225: map_key_clear(KEY_FORWARD);		break;
+				case 0x226: map_key_clear(KEY_STOP);		break;
+				case 0x227: map_key_clear(KEY_REFRESH);		break;
+				case 0x22a: map_key_clear(KEY_BOOKMARKS);	break;
+				case 0x233: map_key_clear(KEY_SCROLLUP);	break;
+				case 0x234: map_key_clear(KEY_SCROLLDOWN);	break;
+				case 0x238: map_rel(REL_HWHEEL);		break;
+				case 0x279: map_key_clear(KEY_REDO);		break;
+				case 0x289: map_key_clear(KEY_REPLY);		break;
+				case 0x28b: map_key_clear(KEY_FORWARDMAIL);	break;
+				case 0x28c: map_key_clear(KEY_SEND);		break;
+
+				/* Reported on a Cherry Cymotion keyboard */
+				case 0x301: map_key_clear(KEY_PROG1);		break;
+				case 0x302: map_key_clear(KEY_PROG2);		break;
+				case 0x303: map_key_clear(KEY_PROG3);		break;
+
+				default:    goto ignore;
+			}
+			break;
+
+		case HID_UP_HPVENDOR:	/* Reported on a Dutch layout HP5308 */
+
+			set_bit(EV_REP, input->evbit);
+			switch (usage->hid & HID_USAGE) {
+			        case 0x021: map_key_clear(KEY_PRINT);           break;
+				case 0x070: map_key_clear(KEY_HP);		break;
+				case 0x071: map_key_clear(KEY_CAMERA);		break;
+				case 0x072: map_key_clear(KEY_SOUND);		break;
+				case 0x073: map_key_clear(KEY_QUESTION);	break;
+				case 0x080: map_key_clear(KEY_EMAIL);		break;
+				case 0x081: map_key_clear(KEY_CHAT);		break;
+				case 0x082: map_key_clear(KEY_SEARCH);		break;
+				case 0x083: map_key_clear(KEY_CONNECT);	        break;
+				case 0x084: map_key_clear(KEY_FINANCE);		break;
+				case 0x085: map_key_clear(KEY_SPORT);		break;
+				case 0x086: map_key_clear(KEY_SHOP);	        break;
+				default:    goto ignore;
+			}
+			break;
+
+		case HID_UP_MSVENDOR:
+			goto ignore;
+
+		case HID_UP_CUSTOM: /* Reported on Logitech and Powerbook USB keyboards */
+
+			set_bit(EV_REP, input->evbit);
+			switch(usage->hid & HID_USAGE) {
+				case 0x003:
+					/* The fn key on Apple PowerBooks */
+					map_key_clear(KEY_FN);
+					hidinput_pb_setup(input);
+					break;
+
+				default:    goto ignore;
+			}
+			break;
+
+		case HID_UP_LOGIVENDOR: /* Reported on Logitech Ultra X Media Remote */
+
+			set_bit(EV_REP, input->evbit);
+			switch(usage->hid & HID_USAGE) {
+				case 0x004: map_key_clear(KEY_AGAIN);		break;
+				case 0x00d: map_key_clear(KEY_HOME);		break;
+				case 0x024: map_key_clear(KEY_SHUFFLE);		break;
+				case 0x025: map_key_clear(KEY_TV);		break;
+				case 0x026: map_key_clear(KEY_MENU);		break;
+				case 0x031: map_key_clear(KEY_AUDIO);		break;
+				case 0x032: map_key_clear(KEY_TEXT);		break;
+				case 0x033: map_key_clear(KEY_LAST);		break;
+				case 0x047: map_key_clear(KEY_MP3);		break;
+				case 0x048: map_key_clear(KEY_DVD);		break;
+				case 0x049: map_key_clear(KEY_MEDIA);		break;
+				case 0x04a: map_key_clear(KEY_VIDEO);		break;
+				case 0x04b: map_key_clear(KEY_ANGLE);		break;
+				case 0x04c: map_key_clear(KEY_LANGUAGE);	break;
+				case 0x04d: map_key_clear(KEY_SUBTITLE);	break;
+				case 0x051: map_key_clear(KEY_RED);		break;
+				case 0x052: map_key_clear(KEY_CLOSE);		break;
+				default:    goto ignore;
+			}
+			break;
+
+		case HID_UP_PID:
+
+			switch(usage->hid & HID_USAGE) {
+				case 0xa4: map_key_clear(BTN_DEAD);	break;
+				default: goto ignore;
+			}
+			break;
+
+		default:
+		unknown:
+			if (field->report_size == 1) {
+				if (field->report->type == HID_OUTPUT_REPORT) {
+					map_led(LED_MISC);
+					break;
+				}
+				map_key(BTN_MISC);
+				break;
+			}
+			if (field->flags & HID_MAIN_ITEM_RELATIVE) {
+				map_rel(REL_MISC);
+				break;
+			}
+			map_abs(ABS_MISC);
+			break;
+	}
+
+	if (device->quirks & HID_QUIRK_MIGHTYMOUSE) {
+		if (usage->hid == HID_GD_Z)
+			map_rel(REL_HWHEEL);
+		else if (usage->code == BTN_1)
+			map_key(BTN_2);
+		else if (usage->code == BTN_2)
+			map_key(BTN_1);
+	}
+
+	if ((device->quirks & (HID_QUIRK_2WHEEL_MOUSE_HACK_7 | HID_QUIRK_2WHEEL_MOUSE_HACK_5)) &&
+		 (usage->type == EV_REL) && (usage->code == REL_WHEEL))
+			set_bit(REL_HWHEEL, bit);
+
+	if (((device->quirks & HID_QUIRK_2WHEEL_MOUSE_HACK_5) && (usage->hid == 0x00090005))
+		|| ((device->quirks & HID_QUIRK_2WHEEL_MOUSE_HACK_7) && (usage->hid == 0x00090007)))
+		goto ignore;
+
+	if ((device->quirks & HID_QUIRK_BAD_RELATIVE_KEYS) &&
+		usage->type == EV_KEY && (field->flags & HID_MAIN_ITEM_RELATIVE))
+		field->flags &= ~HID_MAIN_ITEM_RELATIVE;
+
+	set_bit(usage->type, input->evbit);
+
+	while (usage->code <= max && test_and_set_bit(usage->code, bit))
+		usage->code = find_next_zero_bit(bit, max + 1, usage->code);
+
+	if (usage->code > max)
+		goto ignore;
+
+
+	if (usage->type == EV_ABS) {
+
+		int a = field->logical_minimum;
+		int b = field->logical_maximum;
+
+		if ((device->quirks & HID_QUIRK_BADPAD) && (usage->code == ABS_X || usage->code == ABS_Y)) {
+			a = field->logical_minimum = 0;
+			b = field->logical_maximum = 255;
+		}
+
+		if (field->application == HID_GD_GAMEPAD || field->application == HID_GD_JOYSTICK)
+			input_set_abs_params(input, usage->code, a, b, (b - a) >> 8, (b - a) >> 4);
+		else	input_set_abs_params(input, usage->code, a, b, 0, 0);
+
+	}
+
+	if (usage->type == EV_ABS &&
+	    (usage->hat_min < usage->hat_max || usage->hat_dir)) {
+		int i;
+		for (i = usage->code; i < usage->code + 2 && i <= max; i++) {
+			input_set_abs_params(input, i, -1, 1, 0, 0);
+			set_bit(i, input->absbit);
+		}
+		if (usage->hat_dir && !field->dpad)
+			field->dpad = usage->code;
+	}
+
+#ifdef DEBUG
+	resolv_event(usage->type, usage->code);
+	printk("\n");
+#endif
+	return;
+
+ignore:
+#ifdef DEBUG
+	printk("IGNORED\n");
+#endif
+	return;
+}
+
+void hidinput_hid_event(struct hid_device *hid, struct hid_field *field, struct hid_usage *usage, __s32 value)
+{
+	struct input_dev *input;
+	int *quirks = &hid->quirks;
+
+	if (!field->hidinput)
+		return;
+
+	input = field->hidinput->input;
+
+	if (!usage->type)
+		return;
+
+	if (((hid->quirks & HID_QUIRK_2WHEEL_MOUSE_HACK_5) && (usage->hid == 0x00090005))
+		|| ((hid->quirks & HID_QUIRK_2WHEEL_MOUSE_HACK_7) && (usage->hid == 0x00090007))) {
+		if (value) hid->quirks |=  HID_QUIRK_2WHEEL_MOUSE_HACK_ON;
+		else       hid->quirks &= ~HID_QUIRK_2WHEEL_MOUSE_HACK_ON;
+		return;
+	}
+
+	if ((hid->quirks & HID_QUIRK_INVERT_HWHEEL) && (usage->code == REL_HWHEEL)) {
+		input_event(input, usage->type, usage->code, -value);
+		return;
+	}
+
+	if ((hid->quirks & HID_QUIRK_2WHEEL_MOUSE_HACK_ON) && (usage->code == REL_WHEEL)) {
+		input_event(input, usage->type, REL_HWHEEL, value);
+		return;
+	}
+
+	if ((hid->quirks & HID_QUIRK_POWERBOOK_HAS_FN) && hidinput_pb_event(hid, input, usage, value))
+		return;
+
+	if (usage->hat_min < usage->hat_max || usage->hat_dir) {
+		int hat_dir = usage->hat_dir;
+		if (!hat_dir)
+			hat_dir = (value - usage->hat_min) * 8 / (usage->hat_max - usage->hat_min + 1) + 1;
+		if (hat_dir < 0 || hat_dir > 8) hat_dir = 0;
+		input_event(input, usage->type, usage->code    , hid_hat_to_axis[hat_dir].x);
+                input_event(input, usage->type, usage->code + 1, hid_hat_to_axis[hat_dir].y);
+                return;
+        }
+
+	if (usage->hid == (HID_UP_DIGITIZER | 0x003c)) { /* Invert */
+		*quirks = value ? (*quirks | HID_QUIRK_INVERT) : (*quirks & ~HID_QUIRK_INVERT);
+		return;
+	}
+
+	if (usage->hid == (HID_UP_DIGITIZER | 0x0032)) { /* InRange */
+		if (value) {
+			input_event(input, usage->type, (*quirks & HID_QUIRK_INVERT) ? BTN_TOOL_RUBBER : usage->code, 1);
+			return;
+		}
+		input_event(input, usage->type, usage->code, 0);
+		input_event(input, usage->type, BTN_TOOL_RUBBER, 0);
+		return;
+	}
+
+	if (usage->hid == (HID_UP_DIGITIZER | 0x0030) && (*quirks & HID_QUIRK_NOTOUCH)) { /* Pressure */
+		int a = field->logical_minimum;
+		int b = field->logical_maximum;
+		input_event(input, EV_KEY, BTN_TOUCH, value > a + ((b - a) >> 3));
+	}
+
+	if (usage->hid == (HID_UP_PID | 0x83UL)) { /* Simultaneous Effects Max */
+		dbg("Maximum Effects - %d",value);
+		return;
+	}
+
+	if (usage->hid == (HID_UP_PID | 0x7fUL)) {
+		dbg("PID Pool Report\n");
+		return;
+	}
+
+	if ((usage->type == EV_KEY) && (usage->code == 0)) /* Key 0 is "unassigned", not KEY_UNKNOWN */
+		return;
+
+	input_event(input, usage->type, usage->code, value);
+
+	if ((field->flags & HID_MAIN_ITEM_RELATIVE) && (usage->type == EV_KEY))
+		input_event(input, usage->type, usage->code, 0);
+}
+
+void hidinput_report_event(struct hid_device *hid, struct hid_report *report)
+{
+	struct hid_input *hidinput;
+
+	list_for_each_entry(hidinput, &hid->inputs, list)
+		input_sync(hidinput->input);
+}
+
+static int hidinput_find_field(struct hid_device *hid, unsigned int type, unsigned int code, struct hid_field **field)
+{
+	struct hid_report *report;
+	int i, j;
+
+	list_for_each_entry(report, &hid->report_enum[HID_OUTPUT_REPORT].report_list, list) {
+		for (i = 0; i < report->maxfield; i++) {
+			*field = report->field[i];
+			for (j = 0; j < (*field)->maxusage; j++)
+				if ((*field)->usage[j].type == type && (*field)->usage[j].code == code)
+					return j;
+		}
+	}
+	return -1;
+}
+
+/*
+ * Register the input device; print a message.
+ * Configure the input layer interface
+ * Read all reports and initialize the absolute field values.
+ */
+
+int hidinput_connect(struct hid_device *hid)
+{
+	struct usb_device *dev = hid->dev;
+	struct hid_report *report;
+	struct hid_input *hidinput = NULL;
+	struct input_dev *input_dev;
+	int i, j, k;
+
+	INIT_LIST_HEAD(&hid->inputs);
+
+	for (i = 0; i < hid->maxcollection; i++)
+		if (hid->collection[i].type == HID_COLLECTION_APPLICATION ||
+		    hid->collection[i].type == HID_COLLECTION_PHYSICAL)
+			if (IS_INPUT_APPLICATION(hid->collection[i].usage))
+				break;
+
+	if (i == hid->maxcollection)
+		return -1;
+
+	for (k = HID_INPUT_REPORT; k <= HID_OUTPUT_REPORT; k++)
+		list_for_each_entry(report, &hid->report_enum[k].report_list, list) {
+
+			if (!report->maxfield)
+				continue;
+
+			if (!hidinput) {
+				hidinput = kzalloc(sizeof(*hidinput), GFP_KERNEL);
+				input_dev = input_allocate_device();
+				if (!hidinput || !input_dev) {
+					kfree(hidinput);
+					input_free_device(input_dev);
+					err("Out of memory during hid input probe");
+					return -1;
+				}
+
+				input_dev->private = hid;
+				input_dev->event = hidinput_input_event;
+				input_dev->open = hidinput_open;
+				input_dev->close = hidinput_close;
+
+				input_dev->name = hid->name;
+				input_dev->phys = hid->phys;
+				input_dev->uniq = hid->uniq;
+				usb_to_input_id(dev, &input_dev->id);
+				input_dev->cdev.dev = &hid->intf->dev;
+
+				hidinput->input = input_dev;
+				list_add_tail(&hidinput->list, &hid->inputs);
+			}
+
+			for (i = 0; i < report->maxfield; i++)
+				for (j = 0; j < report->field[i]->maxusage; j++)
+					hidinput_configure_usage(hidinput, report->field[i],
+								 report->field[i]->usage + j);
+
+			if (hid->quirks & HID_QUIRK_MULTI_INPUT) {
+				/* This will leave hidinput NULL, so that it
+				 * allocates another one if we have more inputs on
+				 * the same interface. Some devices (e.g. Happ's
+				 * UGCI) cram a lot of unrelated inputs into the
+				 * same interface. */
+				hidinput->report = report;
+				input_register_device(hidinput->input);
+				hidinput = NULL;
+			}
+		}
+
+	/* This only gets called when we are a single-input (most of the
+	 * time). IOW, not a HID_QUIRK_MULTI_INPUT. The hid_ff_init() is
+	 * only useful in this case, and not for multi-input quirks. */
+	if (hidinput) {
+		hid_ff_init(hid);
+		input_register_device(hidinput->input);
+	}
+
+	return 0;
+}
+
+void hidinput_disconnect(struct hid_device *hid)
+{
+	struct hid_input *hidinput, *next;
+
+	list_for_each_entry_safe(hidinput, next, &hid->inputs, list) {
+		list_del(&hidinput->list);
+		input_unregister_device(hidinput->input);
+		kfree(hidinput);
+	}
+}
