commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hid/hid-roccat-arvo.c b/drivers/hid/hid-roccat-arvo.c
index 329c5d1270f9..ffcd444ae2ba 100644
--- a/drivers/hid/hid-roccat-arvo.c
+++ b/drivers/hid/hid-roccat-arvo.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Roccat Arvo driver for Linux
  *
@@ -5,10 +6,6 @@
  */
 
 /*
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the Free
- * Software Foundation; either version 2 of the License, or (at your option)
- * any later version.
  */
 
 /*

commit 2cf83833fc9cff04c50e402260b724b3f001d737
Author: Geliang Tang <geliangtang@163.com>
Date:   Sun Dec 27 17:25:24 2015 +0800

    HID: use kobj_to_dev()
    
    Use kobj_to_dev() instead of open-coding it.
    
    Signed-off-by: Geliang Tang <geliangtang@163.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-roccat-arvo.c b/drivers/hid/hid-roccat-arvo.c
index 1948208fe038..329c5d1270f9 100644
--- a/drivers/hid/hid-roccat-arvo.c
+++ b/drivers/hid/hid-roccat-arvo.c
@@ -191,8 +191,7 @@ static ssize_t arvo_sysfs_write(struct file *fp,
 		struct kobject *kobj, void const *buf,
 		loff_t off, size_t count, size_t real_size, uint command)
 {
-	struct device *dev =
-			container_of(kobj, struct device, kobj)->parent->parent;
+	struct device *dev = kobj_to_dev(kobj)->parent->parent;
 	struct arvo_device *arvo = hid_get_drvdata(dev_get_drvdata(dev));
 	struct usb_device *usb_dev = interface_to_usbdev(to_usb_interface(dev));
 	int retval;
@@ -211,8 +210,7 @@ static ssize_t arvo_sysfs_read(struct file *fp,
 		struct kobject *kobj, void *buf, loff_t off,
 		size_t count, size_t real_size, uint command)
 {
-	struct device *dev =
-			container_of(kobj, struct device, kobj)->parent->parent;
+	struct device *dev = kobj_to_dev(kobj)->parent->parent;
 	struct arvo_device *arvo = hid_get_drvdata(dev_get_drvdata(dev));
 	struct usb_device *usb_dev = interface_to_usbdev(to_usb_interface(dev));
 	int retval;

commit 22e04f6b4b04a8afe9af9239224591d06ba3b24d
Merge: ec0ad7308021 4e5a494e4b4b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Sep 6 09:30:36 2013 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/hid
    
    Pull HID updates from Jiri Kosina:
     "Highlights:
    
       - conversion of HID subsystem to use devm-based resource management,
         from Benjamin Tissoires
    
       - i2c-hid support for DT bindings, from Benjamin Tissoires
    
       - much improved support for Win8-multitouch devices, from Benjamin
         Tissoires
    
       - cleanup of core code using common hidinput_input_event(), from
         David Herrmann
    
       - fix for bug in implement() access to the bit stream (causing oops)
         that has been present in the code for ages, but devices that are
         able to trigger it have started to appear only now, from Jiri
         Kosina
    
       - fixes for CVE-2013-2899, CVE-2013-2898, CVE-2013-2896,
         CVE-2013-2892, CVE-2013-2888 (all triggerable only by specially
         crafted malicious HW devices plugged into the system), from Kees
         Cook
    
       - hidraw oops fix, from Manoj Chourasia
    
       - various smaller fixes here and there, support for a bunch of new
         devices by various contributors"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/hid: (53 commits)
      HID: MAINTAINERS: add roccat drivers
      HID: hid-sensor-hub: change kmalloc + memcpy by kmemdup
      HID: hid-sensor-hub: move to devm_kzalloc
      HID: hid-sensor-hub: fix indentation accross the code
      HID: move HID_REPORT_TYPES closer to the report-definitions
      HID: check for NULL field when setting values
      HID: picolcd_core: validate output report details
      HID: sensor-hub: validate feature report details
      HID: ntrig: validate feature report details
      HID: pantherlord: validate output report details
      HID: hid-wiimote: print small buffers via %*phC
      HID: uhid: improve uhid example client
      HID: Correct the USB IDs for the new Macbook Air 6
      HID: wiimote: add support for Guitar-Hero guitars
      HID: wiimote: add support for Guitar-Hero drums
      Input: introduce BTN/ABS bits for drums and guitars
      HID: battery: don't do DMA from stack
      HID: roccat: add support for KonePureOptical v2
      HID: picolcd: Prevent NULL pointer dereference on _remove()
      HID: usbhid: quirk for N-Trig DuoSense Touch Screen
      ...

commit e0a00d86000729caf3a3e60732723183ebb6b144
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Aug 19 21:40:26 2013 -0700

    hid: roccat-arvo: convert class code to use bin_attrs in groups
    
    Now that attribute groups support binary attributes, use them instead of
    the dev_bin_attrs field in struct class, as that is going away soon.
    
    Cc: Jiri Kosina <jkosina@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hid/hid-roccat-arvo.c b/drivers/hid/hid-roccat-arvo.c
index 98bb89e0d91b..eed7f52084c5 100644
--- a/drivers/hid/hid-roccat-arvo.c
+++ b/drivers/hid/hid-roccat-arvo.c
@@ -237,6 +237,8 @@ static ssize_t arvo_sysfs_write_button(struct file *fp,
 	return arvo_sysfs_write(fp, kobj, buf, off, count,
 			sizeof(struct arvo_button), ARVO_COMMAND_BUTTON);
 }
+static BIN_ATTR(button, 0220, NULL, arvo_sysfs_write_button,
+		sizeof(struct arvo_button));
 
 static ssize_t arvo_sysfs_read_info(struct file *fp,
 		struct kobject *kobj, struct bin_attribute *attr, char *buf,
@@ -245,6 +247,8 @@ static ssize_t arvo_sysfs_read_info(struct file *fp,
 	return arvo_sysfs_read(fp, kobj, buf, off, count,
 			sizeof(struct arvo_info), ARVO_COMMAND_INFO);
 }
+static BIN_ATTR(info, 0440, arvo_sysfs_read_info, NULL,
+		sizeof(struct arvo_info));
 
 static struct attribute *arvo_attrs[] = {
 	&dev_attr_mode_key.attr,
@@ -252,20 +256,21 @@ static struct attribute *arvo_attrs[] = {
 	&dev_attr_actual_profile.attr,
 	NULL,
 };
-ATTRIBUTE_GROUPS(arvo);
-
-static struct bin_attribute arvo_bin_attributes[] = {
-	{
-		.attr = { .name = "button", .mode = 0220 },
-		.size = sizeof(struct arvo_button),
-		.write = arvo_sysfs_write_button
-	},
-	{
-		.attr = { .name = "info", .mode = 0440 },
-		.size = sizeof(struct arvo_info),
-		.read = arvo_sysfs_read_info
-	},
-	__ATTR_NULL
+
+static struct bin_attribute *arvo_bin_attributes[] = {
+	&bin_attr_button,
+	&bin_attr_info,
+	NULL,
+};
+
+static const struct attribute_group arvo_group = {
+	.attrs = arvo_attrs,
+	.bin_attrs = arvo_bin_attributes,
+};
+
+static const struct attribute_group *arvo_groups[] = {
+	&arvo_group,
+	NULL,
 };
 
 static int arvo_init_arvo_device_struct(struct usb_device *usb_dev,
@@ -434,7 +439,6 @@ static int __init arvo_init(void)
 	if (IS_ERR(arvo_class))
 		return PTR_ERR(arvo_class);
 	arvo_class->dev_groups = arvo_groups;
-	arvo_class->dev_bin_attrs = arvo_bin_attributes;
 
 	retval = hid_register_driver(&arvo_driver);
 	if (retval)

commit 46a58c44c173d3cbfa53931fbb7ad069ef59f190
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Jul 24 15:05:11 2013 -0700

    HID: roccat: convert class code to use dev_groups
    
    The dev_attrs field of struct class is going away soon, dev_groups
    should be used instead.  This converts the roccat class code to use the
    correct field.
    
    Cc: Jiri Kosina <jkosina@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hid/hid-roccat-arvo.c b/drivers/hid/hid-roccat-arvo.c
index 327f9b8ed1f4..98bb89e0d91b 100644
--- a/drivers/hid/hid-roccat-arvo.c
+++ b/drivers/hid/hid-roccat-arvo.c
@@ -75,6 +75,8 @@ static ssize_t arvo_sysfs_set_mode_key(struct device *dev,
 
 	return size;
 }
+static DEVICE_ATTR(mode_key, 0660,
+		   arvo_sysfs_show_mode_key, arvo_sysfs_set_mode_key);
 
 static ssize_t arvo_sysfs_show_key_mask(struct device *dev,
 		struct device_attribute *attr, char *buf)
@@ -123,6 +125,8 @@ static ssize_t arvo_sysfs_set_key_mask(struct device *dev,
 
 	return size;
 }
+static DEVICE_ATTR(key_mask, 0660,
+		   arvo_sysfs_show_key_mask, arvo_sysfs_set_key_mask);
 
 /* retval is 1-5 on success, < 0 on error */
 static int arvo_get_actual_profile(struct usb_device *usb_dev)
@@ -179,6 +183,9 @@ static ssize_t arvo_sysfs_set_actual_profile(struct device *dev,
 	mutex_unlock(&arvo->arvo_lock);
 	return retval;
 }
+static DEVICE_ATTR(actual_profile, 0660,
+		   arvo_sysfs_show_actual_profile,
+		   arvo_sysfs_set_actual_profile);
 
 static ssize_t arvo_sysfs_write(struct file *fp,
 		struct kobject *kobj, void const *buf,
@@ -239,17 +246,13 @@ static ssize_t arvo_sysfs_read_info(struct file *fp,
 			sizeof(struct arvo_info), ARVO_COMMAND_INFO);
 }
 
-
-static struct device_attribute arvo_attributes[] = {
-	__ATTR(mode_key, 0660,
-			arvo_sysfs_show_mode_key, arvo_sysfs_set_mode_key),
-	__ATTR(key_mask, 0660,
-			arvo_sysfs_show_key_mask, arvo_sysfs_set_key_mask),
-	__ATTR(actual_profile, 0660,
-			arvo_sysfs_show_actual_profile,
-			arvo_sysfs_set_actual_profile),
-	__ATTR_NULL
+static struct attribute *arvo_attrs[] = {
+	&dev_attr_mode_key.attr,
+	&dev_attr_key_mask.attr,
+	&dev_attr_actual_profile.attr,
+	NULL,
 };
+ATTRIBUTE_GROUPS(arvo);
 
 static struct bin_attribute arvo_bin_attributes[] = {
 	{
@@ -430,7 +433,7 @@ static int __init arvo_init(void)
 	arvo_class = class_create(THIS_MODULE, "arvo");
 	if (IS_ERR(arvo_class))
 		return PTR_ERR(arvo_class);
-	arvo_class->dev_attrs = arvo_attributes;
+	arvo_class->dev_groups = arvo_groups;
 	arvo_class->dev_bin_attrs = arvo_bin_attributes;
 
 	retval = hid_register_driver(&arvo_driver);

commit dfc450b55d6b9215da27c5dc2c5f3ca1865575a6
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Fri Jul 19 15:53:16 2013 +0900

    HID: replace strict_strtoul() with kstrtoul()
    
    The usage of strict_strtoul() is not preferred, because
    strict_strtoul() is obsolete. Thus, kstrtoul() should be
    used.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-roccat-arvo.c b/drivers/hid/hid-roccat-arvo.c
index 327f9b8ed1f4..071ee9e2fd9f 100644
--- a/drivers/hid/hid-roccat-arvo.c
+++ b/drivers/hid/hid-roccat-arvo.c
@@ -59,7 +59,7 @@ static ssize_t arvo_sysfs_set_mode_key(struct device *dev,
 	unsigned long state;
 	int retval;
 
-	retval = strict_strtoul(buf, 10, &state);
+	retval = kstrtoul(buf, 10, &state);
 	if (retval)
 		return retval;
 
@@ -107,7 +107,7 @@ static ssize_t arvo_sysfs_set_key_mask(struct device *dev,
 	unsigned long key_mask;
 	int retval;
 
-	retval = strict_strtoul(buf, 10, &key_mask);
+	retval = kstrtoul(buf, 10, &key_mask);
 	if (retval)
 		return retval;
 
@@ -159,7 +159,7 @@ static ssize_t arvo_sysfs_set_actual_profile(struct device *dev,
 	unsigned long profile;
 	int retval;
 
-	retval = strict_strtoul(buf, 10, &profile);
+	retval = kstrtoul(buf, 10, &profile);
 	if (retval)
 		return retval;
 

commit 7392d73be2b3c907d65126f072c313215e1907b3
Author: Stefan Achatz <erazor_de@users.sourceforge.net>
Date:   Sun May 20 22:45:04 2012 +0200

    HID: roccat: rename roccat_common functions to roccat_common2
    
    Did this to illustrate my understanding of the firmware generations:
    Valo and Kone were 1st generation
    Arvo was externaly developed and lies in the middle
    All others until now are considered 2nd generation
    
    Signed-off-by: Stefan Achatz <erazor_de@users.sourceforge.net>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-roccat-arvo.c b/drivers/hid/hid-roccat-arvo.c
index 093bfad00b02..327f9b8ed1f4 100644
--- a/drivers/hid/hid-roccat-arvo.c
+++ b/drivers/hid/hid-roccat-arvo.c
@@ -39,7 +39,7 @@ static ssize_t arvo_sysfs_show_mode_key(struct device *dev,
 	int retval;
 
 	mutex_lock(&arvo->arvo_lock);
-	retval = roccat_common_receive(usb_dev, ARVO_COMMAND_MODE_KEY,
+	retval = roccat_common2_receive(usb_dev, ARVO_COMMAND_MODE_KEY,
 			&temp_buf, sizeof(struct arvo_mode_key));
 	mutex_unlock(&arvo->arvo_lock);
 	if (retval)
@@ -67,7 +67,7 @@ static ssize_t arvo_sysfs_set_mode_key(struct device *dev,
 	temp_buf.state = state;
 
 	mutex_lock(&arvo->arvo_lock);
-	retval = roccat_common_send(usb_dev, ARVO_COMMAND_MODE_KEY,
+	retval = roccat_common2_send(usb_dev, ARVO_COMMAND_MODE_KEY,
 			&temp_buf, sizeof(struct arvo_mode_key));
 	mutex_unlock(&arvo->arvo_lock);
 	if (retval)
@@ -87,7 +87,7 @@ static ssize_t arvo_sysfs_show_key_mask(struct device *dev,
 	int retval;
 
 	mutex_lock(&arvo->arvo_lock);
-	retval = roccat_common_receive(usb_dev, ARVO_COMMAND_KEY_MASK,
+	retval = roccat_common2_receive(usb_dev, ARVO_COMMAND_KEY_MASK,
 			&temp_buf, sizeof(struct arvo_key_mask));
 	mutex_unlock(&arvo->arvo_lock);
 	if (retval)
@@ -115,7 +115,7 @@ static ssize_t arvo_sysfs_set_key_mask(struct device *dev,
 	temp_buf.key_mask = key_mask;
 
 	mutex_lock(&arvo->arvo_lock);
-	retval = roccat_common_send(usb_dev, ARVO_COMMAND_KEY_MASK,
+	retval = roccat_common2_send(usb_dev, ARVO_COMMAND_KEY_MASK,
 			&temp_buf, sizeof(struct arvo_key_mask));
 	mutex_unlock(&arvo->arvo_lock);
 	if (retval)
@@ -130,7 +130,7 @@ static int arvo_get_actual_profile(struct usb_device *usb_dev)
 	struct arvo_actual_profile temp_buf;
 	int retval;
 
-	retval = roccat_common_receive(usb_dev, ARVO_COMMAND_ACTUAL_PROFILE,
+	retval = roccat_common2_receive(usb_dev, ARVO_COMMAND_ACTUAL_PROFILE,
 			&temp_buf, sizeof(struct arvo_actual_profile));
 
 	if (retval)
@@ -170,7 +170,7 @@ static ssize_t arvo_sysfs_set_actual_profile(struct device *dev,
 	temp_buf.actual_profile = profile;
 
 	mutex_lock(&arvo->arvo_lock);
-	retval = roccat_common_send(usb_dev, ARVO_COMMAND_ACTUAL_PROFILE,
+	retval = roccat_common2_send(usb_dev, ARVO_COMMAND_ACTUAL_PROFILE,
 			&temp_buf, sizeof(struct arvo_actual_profile));
 	if (!retval) {
 		arvo->actual_profile = profile;
@@ -194,7 +194,7 @@ static ssize_t arvo_sysfs_write(struct file *fp,
 		return -EINVAL;
 
 	mutex_lock(&arvo->arvo_lock);
-	retval = roccat_common_send(usb_dev, command, buf, real_size);
+	retval = roccat_common2_send(usb_dev, command, buf, real_size);
 	mutex_unlock(&arvo->arvo_lock);
 
 	return (retval ? retval : real_size);
@@ -217,7 +217,7 @@ static ssize_t arvo_sysfs_read(struct file *fp,
 		return -EINVAL;
 
 	mutex_lock(&arvo->arvo_lock);
-	retval = roccat_common_receive(usb_dev, command, buf, real_size);
+	retval = roccat_common2_receive(usb_dev, command, buf, real_size);
 	mutex_unlock(&arvo->arvo_lock);
 
 	return (retval ? retval : real_size);

commit 901e64dbdb5998b9248c372a401c921bbdf662f6
Author: Stefan Achatz <erazor_de@users.sourceforge.net>
Date:   Sun Jun 12 10:02:44 2011 +0200

    HID: roccat: fix NULL pointer dereference, add range checks
    
    On rare occassions raw events can be triggered before drvdata gets set up
    which leads to NULL pointer dereferences. This was only observed with pyra on
    2.6.39, but is fixed for all devices now to play it save.
    kovaplus returned wrong actual values when profile change was initiated from host.
    Added range checks for setting actual profile on all devices.
    
    Signed-off-by: Stefan Achatz <erazor_de@users.sourceforge.net>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-roccat-arvo.c b/drivers/hid/hid-roccat-arvo.c
index 610536606195..093bfad00b02 100644
--- a/drivers/hid/hid-roccat-arvo.c
+++ b/drivers/hid/hid-roccat-arvo.c
@@ -163,6 +163,9 @@ static ssize_t arvo_sysfs_set_actual_profile(struct device *dev,
 	if (retval)
 		return retval;
 
+	if (profile < 1 || profile > 5)
+		return -EINVAL;
+
 	temp_buf.command = ARVO_COMMAND_ACTUAL_PROFILE;
 	temp_buf.actual_profile = profile;
 
@@ -399,7 +402,7 @@ static int arvo_raw_event(struct hid_device *hdev,
 	if (size != 3)
 		return 0;
 
-	if (arvo->roccat_claimed)
+	if (arvo && arvo->roccat_claimed)
 		arvo_report_to_chrdev(arvo, data);
 
 	return 0;

commit 1edd5b42a6631b1b1f147e9018e309bde8d96a05
Author: Stefan Achatz <erazor_de@users.sourceforge.net>
Date:   Wed Jun 1 15:54:17 2011 +0200

    HID: roccat: correction and cleanup of HID feature reports
    
    Removed analog feature report enums and modified code in roccat_common
    to reflect this. Non standard conform Kone got its own copy of the old
    code. That helps extracting more generalizations for newer devices.
    
    Signed-off-by: Stefan Achatz <erazor_de@users.sourceforge.net>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-roccat-arvo.c b/drivers/hid/hid-roccat-arvo.c
index 2307471d96dc..610536606195 100644
--- a/drivers/hid/hid-roccat-arvo.c
+++ b/drivers/hid/hid-roccat-arvo.c
@@ -39,7 +39,7 @@ static ssize_t arvo_sysfs_show_mode_key(struct device *dev,
 	int retval;
 
 	mutex_lock(&arvo->arvo_lock);
-	retval = roccat_common_receive(usb_dev, ARVO_USB_COMMAND_MODE_KEY,
+	retval = roccat_common_receive(usb_dev, ARVO_COMMAND_MODE_KEY,
 			&temp_buf, sizeof(struct arvo_mode_key));
 	mutex_unlock(&arvo->arvo_lock);
 	if (retval)
@@ -67,7 +67,7 @@ static ssize_t arvo_sysfs_set_mode_key(struct device *dev,
 	temp_buf.state = state;
 
 	mutex_lock(&arvo->arvo_lock);
-	retval = roccat_common_send(usb_dev, ARVO_USB_COMMAND_MODE_KEY,
+	retval = roccat_common_send(usb_dev, ARVO_COMMAND_MODE_KEY,
 			&temp_buf, sizeof(struct arvo_mode_key));
 	mutex_unlock(&arvo->arvo_lock);
 	if (retval)
@@ -87,7 +87,7 @@ static ssize_t arvo_sysfs_show_key_mask(struct device *dev,
 	int retval;
 
 	mutex_lock(&arvo->arvo_lock);
-	retval = roccat_common_receive(usb_dev, ARVO_USB_COMMAND_KEY_MASK,
+	retval = roccat_common_receive(usb_dev, ARVO_COMMAND_KEY_MASK,
 			&temp_buf, sizeof(struct arvo_key_mask));
 	mutex_unlock(&arvo->arvo_lock);
 	if (retval)
@@ -115,7 +115,7 @@ static ssize_t arvo_sysfs_set_key_mask(struct device *dev,
 	temp_buf.key_mask = key_mask;
 
 	mutex_lock(&arvo->arvo_lock);
-	retval = roccat_common_send(usb_dev, ARVO_USB_COMMAND_KEY_MASK,
+	retval = roccat_common_send(usb_dev, ARVO_COMMAND_KEY_MASK,
 			&temp_buf, sizeof(struct arvo_key_mask));
 	mutex_unlock(&arvo->arvo_lock);
 	if (retval)
@@ -130,7 +130,7 @@ static int arvo_get_actual_profile(struct usb_device *usb_dev)
 	struct arvo_actual_profile temp_buf;
 	int retval;
 
-	retval = roccat_common_receive(usb_dev, ARVO_USB_COMMAND_ACTUAL_PROFILE,
+	retval = roccat_common_receive(usb_dev, ARVO_COMMAND_ACTUAL_PROFILE,
 			&temp_buf, sizeof(struct arvo_actual_profile));
 
 	if (retval)
@@ -167,7 +167,7 @@ static ssize_t arvo_sysfs_set_actual_profile(struct device *dev,
 	temp_buf.actual_profile = profile;
 
 	mutex_lock(&arvo->arvo_lock);
-	retval = roccat_common_send(usb_dev, ARVO_USB_COMMAND_ACTUAL_PROFILE,
+	retval = roccat_common_send(usb_dev, ARVO_COMMAND_ACTUAL_PROFILE,
 			&temp_buf, sizeof(struct arvo_actual_profile));
 	if (!retval) {
 		arvo->actual_profile = profile;
@@ -225,7 +225,7 @@ static ssize_t arvo_sysfs_write_button(struct file *fp,
 		loff_t off, size_t count)
 {
 	return arvo_sysfs_write(fp, kobj, buf, off, count,
-			sizeof(struct arvo_button), ARVO_USB_COMMAND_BUTTON);
+			sizeof(struct arvo_button), ARVO_COMMAND_BUTTON);
 }
 
 static ssize_t arvo_sysfs_read_info(struct file *fp,
@@ -233,7 +233,7 @@ static ssize_t arvo_sysfs_read_info(struct file *fp,
 		loff_t off, size_t count)
 {
 	return arvo_sysfs_read(fp, kobj, buf, off, count,
-			sizeof(struct arvo_info), ARVO_USB_COMMAND_INFO);
+			sizeof(struct arvo_info), ARVO_COMMAND_INFO);
 }
 
 

commit 5dc0c9835fb96c75c8dbf657393764bd0abbac04
Author: Stefan Achatz <erazor_de@users.sourceforge.net>
Date:   Thu Feb 3 16:14:43 2011 +0100

    HID: roccat: Rename header roccat.h -> hid-roccat.h
    
    It was desired that the header roccat.h should be named hid-roccat.h
    
    Signed-off-by: Stefan Achatz <erazor_de@users.sourceforge.net>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-roccat-arvo.c b/drivers/hid/hid-roccat-arvo.c
index 75f532f4d4cc..2307471d96dc 100644
--- a/drivers/hid/hid-roccat-arvo.c
+++ b/drivers/hid/hid-roccat-arvo.c
@@ -21,7 +21,7 @@
 #include <linux/hid.h>
 #include <linux/module.h>
 #include <linux/slab.h>
-#include <linux/roccat.h>
+#include <linux/hid-roccat.h>
 #include "hid-ids.h"
 #include "hid-roccat-common.h"
 #include "hid-roccat-arvo.h"

commit 74b643dac475e29f53f4132d2349ec1dba3c9e44
Author: Stefan Achatz <erazor_de@users.sourceforge.net>
Date:   Sun Jan 30 13:38:27 2011 +0100

    HID: roccat: Fix NULL pointer dereference when unloading module
    
    Class was destroyed before starting the unregistering driver chain.
    Disconnecting a device from roccat chardev in this process then
    raised a NULL pointer dereference.
    Fixed this by destroying class after unregistering driver.
    
    Signed-off-by: Stefan Achatz <erazor_de@users.sourceforge.net>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-roccat-arvo.c b/drivers/hid/hid-roccat-arvo.c
index 7b9a992611bc..75f532f4d4cc 100644
--- a/drivers/hid/hid-roccat-arvo.c
+++ b/drivers/hid/hid-roccat-arvo.c
@@ -438,8 +438,8 @@ static int __init arvo_init(void)
 
 static void __exit arvo_exit(void)
 {
-	class_destroy(arvo_class);
 	hid_unregister_driver(&arvo_driver);
+	class_destroy(arvo_class);
 }
 
 module_init(arvo_init);

commit 8211e46004518c977f70f2661da961d5ba617399
Author: Stefan Achatz <erazor_de@users.sourceforge.net>
Date:   Sun Jan 30 13:38:25 2011 +0100

    HID: roccat: Add ioctl command to retreive report size from chardev
    
    Roccat chardev was reworked to support only a defined report size per
    device and this can be retreived by an ioctl now to enable future changes
    in report definitions.
    Header was moved/renamed from drivers/hid to include/linux for accessibility.
    
    Signed-off-by: Stefan Achatz <erazor_de@users.sourceforge.net>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-roccat-arvo.c b/drivers/hid/hid-roccat-arvo.c
index d72ee4186d11..7b9a992611bc 100644
--- a/drivers/hid/hid-roccat-arvo.c
+++ b/drivers/hid/hid-roccat-arvo.c
@@ -21,8 +21,8 @@
 #include <linux/hid.h>
 #include <linux/module.h>
 #include <linux/slab.h>
+#include <linux/roccat.h>
 #include "hid-ids.h"
-#include "hid-roccat.h"
 #include "hid-roccat-common.h"
 #include "hid-roccat-arvo.h"
 
@@ -303,7 +303,8 @@ static int arvo_init_specials(struct hid_device *hdev)
 		goto exit_free;
 	}
 
-	retval = roccat_connect(arvo_class, hdev);
+	retval = roccat_connect(arvo_class, hdev,
+			sizeof(struct arvo_roccat_report));
 	if (retval < 0) {
 		hid_err(hdev, "couldn't init char dev\n");
 	} else {
@@ -386,8 +387,8 @@ static void arvo_report_to_chrdev(struct arvo_device const *arvo,
 	else
 		roccat_report.action = ARVO_ROCCAT_REPORT_ACTION_RELEASE;
 
-	roccat_report_event(arvo->chrdev_minor, (uint8_t const *)&roccat_report,
-			sizeof(struct arvo_roccat_report));
+	roccat_report_event(arvo->chrdev_minor,
+			(uint8_t const *)&roccat_report);
 }
 
 static int arvo_raw_event(struct hid_device *hdev,

commit 5772f63613ce0a6777e82a7e8fb553e49da27719
Author: Stefan Achatz <erazor_de@users.sourceforge.net>
Date:   Sun Jan 30 13:38:23 2011 +0100

    HID: roccat: Introduce module hid-roccat-common
    
    Module hid-roccat-common contains functions used by roccat device driver
    modules to reduce code duplication.
    At the moment it contains just two wrapper methods for usb_control_msg
    that ensure that the buffer used for transfer is dma capable which wasn't
    the case before.
    The kconfig option is not visible to the user but will be selected by the
    device specific drivers.
    
    Signed-off-by: Stefan Achatz <erazor_de@users.sourceforge.net>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-roccat-arvo.c b/drivers/hid/hid-roccat-arvo.c
index ebf3c15f1a7e..d72ee4186d11 100644
--- a/drivers/hid/hid-roccat-arvo.c
+++ b/drivers/hid/hid-roccat-arvo.c
@@ -19,41 +19,15 @@
 #include <linux/device.h>
 #include <linux/input.h>
 #include <linux/hid.h>
-#include <linux/usb.h>
 #include <linux/module.h>
 #include <linux/slab.h>
 #include "hid-ids.h"
 #include "hid-roccat.h"
+#include "hid-roccat-common.h"
 #include "hid-roccat-arvo.h"
 
 static struct class *arvo_class;
 
-static int arvo_receive(struct usb_device *usb_dev, uint usb_command,
-		void *buf, uint size)
-{
-	int len;
-
-	len = usb_control_msg(usb_dev, usb_rcvctrlpipe(usb_dev, 0),
-			USB_REQ_CLEAR_FEATURE,
-			USB_TYPE_CLASS | USB_RECIP_INTERFACE | USB_DIR_IN,
-			usb_command, 0, buf, size, USB_CTRL_SET_TIMEOUT);
-
-	return (len != size) ? -EIO : 0;
-}
-
-static int arvo_send(struct usb_device *usb_dev, uint usb_command,
-		void const *buf, uint size)
-{
-	int len;
-
-	len = usb_control_msg(usb_dev, usb_sndctrlpipe(usb_dev, 0),
-			USB_REQ_SET_CONFIGURATION,
-			USB_TYPE_CLASS | USB_RECIP_INTERFACE | USB_DIR_OUT,
-			usb_command, 0, (void *)buf, size, USB_CTRL_SET_TIMEOUT);
-
-	return (len != size) ? -EIO : 0;
-}
-
 static ssize_t arvo_sysfs_show_mode_key(struct device *dev,
 		struct device_attribute *attr, char *buf)
 {
@@ -61,24 +35,17 @@ static ssize_t arvo_sysfs_show_mode_key(struct device *dev,
 			hid_get_drvdata(dev_get_drvdata(dev->parent->parent));
 	struct usb_device *usb_dev =
 			interface_to_usbdev(to_usb_interface(dev->parent->parent));
-	struct arvo_mode_key *temp_buf;
+	struct arvo_mode_key temp_buf;
 	int retval;
 
-	temp_buf = kmalloc(sizeof(struct arvo_mode_key), GFP_KERNEL);
-	if (!temp_buf)
-		return -ENOMEM;
-
 	mutex_lock(&arvo->arvo_lock);
-	retval = arvo_receive(usb_dev, ARVO_USB_COMMAND_MODE_KEY,
-			temp_buf, sizeof(struct arvo_mode_key));
+	retval = roccat_common_receive(usb_dev, ARVO_USB_COMMAND_MODE_KEY,
+			&temp_buf, sizeof(struct arvo_mode_key));
 	mutex_unlock(&arvo->arvo_lock);
 	if (retval)
-		goto out;
+		return retval;
 
-	retval = snprintf(buf, PAGE_SIZE, "%d\n", temp_buf->state);
-out:
-	kfree(temp_buf);
-	return retval;
+	return snprintf(buf, PAGE_SIZE, "%d\n", temp_buf.state);
 }
 
 static ssize_t arvo_sysfs_set_mode_key(struct device *dev,
@@ -88,32 +55,25 @@ static ssize_t arvo_sysfs_set_mode_key(struct device *dev,
 			hid_get_drvdata(dev_get_drvdata(dev->parent->parent));
 	struct usb_device *usb_dev =
 			interface_to_usbdev(to_usb_interface(dev->parent->parent));
-	struct arvo_mode_key *temp_buf;
+	struct arvo_mode_key temp_buf;
 	unsigned long state;
 	int retval;
 
-	temp_buf = kmalloc(sizeof(struct arvo_mode_key), GFP_KERNEL);
-	if (!temp_buf)
-		return -ENOMEM;
-
 	retval = strict_strtoul(buf, 10, &state);
 	if (retval)
-		goto out;
+		return retval;
 
-	temp_buf->command = ARVO_COMMAND_MODE_KEY;
-	temp_buf->state = state;
+	temp_buf.command = ARVO_COMMAND_MODE_KEY;
+	temp_buf.state = state;
 
 	mutex_lock(&arvo->arvo_lock);
-	retval = arvo_send(usb_dev, ARVO_USB_COMMAND_MODE_KEY,
-			temp_buf, sizeof(struct arvo_mode_key));
+	retval = roccat_common_send(usb_dev, ARVO_USB_COMMAND_MODE_KEY,
+			&temp_buf, sizeof(struct arvo_mode_key));
 	mutex_unlock(&arvo->arvo_lock);
 	if (retval)
-		goto out;
+		return retval;
 
-	retval = size;
-out:
-	kfree(temp_buf);
-	return retval;
+	return size;
 }
 
 static ssize_t arvo_sysfs_show_key_mask(struct device *dev,
@@ -123,24 +83,17 @@ static ssize_t arvo_sysfs_show_key_mask(struct device *dev,
 			hid_get_drvdata(dev_get_drvdata(dev->parent->parent));
 	struct usb_device *usb_dev =
 			interface_to_usbdev(to_usb_interface(dev->parent->parent));
-	struct arvo_key_mask *temp_buf;
+	struct arvo_key_mask temp_buf;
 	int retval;
 
-	temp_buf = kmalloc(sizeof(struct arvo_key_mask), GFP_KERNEL);
-	if (!temp_buf)
-		return -ENOMEM;
-
 	mutex_lock(&arvo->arvo_lock);
-	retval = arvo_receive(usb_dev, ARVO_USB_COMMAND_KEY_MASK,
-			temp_buf, sizeof(struct arvo_key_mask));
+	retval = roccat_common_receive(usb_dev, ARVO_USB_COMMAND_KEY_MASK,
+			&temp_buf, sizeof(struct arvo_key_mask));
 	mutex_unlock(&arvo->arvo_lock);
 	if (retval)
-		goto out;
+		return retval;
 
-	retval = snprintf(buf, PAGE_SIZE, "%d\n", temp_buf->key_mask);
-out:
-	kfree(temp_buf);
-	return retval;
+	return snprintf(buf, PAGE_SIZE, "%d\n", temp_buf.key_mask);
 }
 
 static ssize_t arvo_sysfs_set_key_mask(struct device *dev,
@@ -150,52 +103,40 @@ static ssize_t arvo_sysfs_set_key_mask(struct device *dev,
 			hid_get_drvdata(dev_get_drvdata(dev->parent->parent));
 	struct usb_device *usb_dev =
 			interface_to_usbdev(to_usb_interface(dev->parent->parent));
-	struct arvo_key_mask *temp_buf;
+	struct arvo_key_mask temp_buf;
 	unsigned long key_mask;
 	int retval;
 
-	temp_buf = kmalloc(sizeof(struct arvo_key_mask), GFP_KERNEL);
-	if (!temp_buf)
-		return -ENOMEM;
-
 	retval = strict_strtoul(buf, 10, &key_mask);
 	if (retval)
-		goto out;
+		return retval;
 
-	temp_buf->command = ARVO_COMMAND_KEY_MASK;
-	temp_buf->key_mask = key_mask;
+	temp_buf.command = ARVO_COMMAND_KEY_MASK;
+	temp_buf.key_mask = key_mask;
 
 	mutex_lock(&arvo->arvo_lock);
-	retval = arvo_send(usb_dev, ARVO_USB_COMMAND_KEY_MASK,
-			temp_buf, sizeof(struct arvo_key_mask));
+	retval = roccat_common_send(usb_dev, ARVO_USB_COMMAND_KEY_MASK,
+			&temp_buf, sizeof(struct arvo_key_mask));
 	mutex_unlock(&arvo->arvo_lock);
 	if (retval)
-		goto out;
+		return retval;
 
-	retval = size;
-out:
-	kfree(temp_buf);
-	return retval;
+	return size;
 }
 
 /* retval is 1-5 on success, < 0 on error */
 static int arvo_get_actual_profile(struct usb_device *usb_dev)
 {
-	struct arvo_actual_profile *temp_buf;
+	struct arvo_actual_profile temp_buf;
 	int retval;
 
-	temp_buf = kmalloc(sizeof(struct arvo_actual_profile), GFP_KERNEL);
-	if (!temp_buf)
-		return -ENOMEM;
-
-	retval = arvo_receive(usb_dev, ARVO_USB_COMMAND_ACTUAL_PROFILE,
-			temp_buf, sizeof(struct arvo_actual_profile));
+	retval = roccat_common_receive(usb_dev, ARVO_USB_COMMAND_ACTUAL_PROFILE,
+			&temp_buf, sizeof(struct arvo_actual_profile));
 
-	if (!retval)
-		retval = temp_buf->actual_profile;
+	if (retval)
+		return retval;
 
-	kfree(temp_buf);
-	return retval;
+	return temp_buf.actual_profile;
 }
 
 static ssize_t arvo_sysfs_show_actual_profile(struct device *dev,
@@ -214,32 +155,25 @@ static ssize_t arvo_sysfs_set_actual_profile(struct device *dev,
 			hid_get_drvdata(dev_get_drvdata(dev->parent->parent));
 	struct usb_device *usb_dev =
 			interface_to_usbdev(to_usb_interface(dev->parent->parent));
-	struct arvo_actual_profile *temp_buf;
+	struct arvo_actual_profile temp_buf;
 	unsigned long profile;
 	int retval;
 
-	temp_buf = kmalloc(sizeof(struct arvo_actual_profile), GFP_KERNEL);
-	if (!temp_buf)
-		return -ENOMEM;
-
 	retval = strict_strtoul(buf, 10, &profile);
 	if (retval)
-		goto out;
+		return retval;
 
-	temp_buf->command = ARVO_COMMAND_ACTUAL_PROFILE;
-	temp_buf->actual_profile = profile;
+	temp_buf.command = ARVO_COMMAND_ACTUAL_PROFILE;
+	temp_buf.actual_profile = profile;
 
 	mutex_lock(&arvo->arvo_lock);
-	retval = arvo_send(usb_dev, ARVO_USB_COMMAND_ACTUAL_PROFILE,
-			temp_buf, sizeof(struct arvo_actual_profile));
+	retval = roccat_common_send(usb_dev, ARVO_USB_COMMAND_ACTUAL_PROFILE,
+			&temp_buf, sizeof(struct arvo_actual_profile));
 	if (!retval) {
 		arvo->actual_profile = profile;
 		retval = size;
 	}
 	mutex_unlock(&arvo->arvo_lock);
-
-out:
-	kfree(temp_buf);
 	return retval;
 }
 
@@ -257,7 +191,7 @@ static ssize_t arvo_sysfs_write(struct file *fp,
 		return -EINVAL;
 
 	mutex_lock(&arvo->arvo_lock);
-	retval = arvo_send(usb_dev, command, buf, real_size);
+	retval = roccat_common_send(usb_dev, command, buf, real_size);
 	mutex_unlock(&arvo->arvo_lock);
 
 	return (retval ? retval : real_size);
@@ -280,7 +214,7 @@ static ssize_t arvo_sysfs_read(struct file *fp,
 		return -EINVAL;
 
 	mutex_lock(&arvo->arvo_lock);
-	retval = arvo_receive(usb_dev, command, buf, real_size);
+	retval = roccat_common_receive(usb_dev, command, buf, real_size);
 	mutex_unlock(&arvo->arvo_lock);
 
 	return (retval ? retval : real_size);

commit a28764ef80dd5aef657f810a9c295ccda421c823
Author: Stefan Achatz <erazor_de@users.sourceforge.net>
Date:   Sun Jan 30 13:38:21 2011 +0100

    HID: roccat: Use new hid_err macros
    
    Using the new hid_err macros instead of dev_err.
    
    Signed-off-by: Stefan Achatz <erazor_de@users.sourceforge.net>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-roccat-arvo.c b/drivers/hid/hid-roccat-arvo.c
index 8facbd3efd72..ebf3c15f1a7e 100644
--- a/drivers/hid/hid-roccat-arvo.c
+++ b/drivers/hid/hid-roccat-arvo.c
@@ -358,21 +358,20 @@ static int arvo_init_specials(struct hid_device *hdev)
 
 	arvo = kzalloc(sizeof(*arvo), GFP_KERNEL);
 	if (!arvo) {
-		dev_err(&hdev->dev, "can't alloc device descriptor\n");
+		hid_err(hdev, "can't alloc device descriptor\n");
 		return -ENOMEM;
 	}
 	hid_set_drvdata(hdev, arvo);
 
 	retval = arvo_init_arvo_device_struct(usb_dev, arvo);
 	if (retval) {
-		dev_err(&hdev->dev,
-				"couldn't init struct arvo_device\n");
+		hid_err(hdev, "couldn't init struct arvo_device\n");
 		goto exit_free;
 	}
 
 	retval = roccat_connect(arvo_class, hdev);
 	if (retval < 0) {
-		dev_err(&hdev->dev, "couldn't init char dev\n");
+		hid_err(hdev, "couldn't init char dev\n");
 	} else {
 		arvo->chrdev_minor = retval;
 		arvo->roccat_claimed = 1;
@@ -406,19 +405,19 @@ static int arvo_probe(struct hid_device *hdev,
 
 	retval = hid_parse(hdev);
 	if (retval) {
-		dev_err(&hdev->dev, "parse failed\n");
+		hid_err(hdev, "parse failed\n");
 		goto exit;
 	}
 
 	retval = hid_hw_start(hdev, HID_CONNECT_DEFAULT);
 	if (retval) {
-		dev_err(&hdev->dev, "hw start failed\n");
+		hid_err(hdev, "hw start failed\n");
 		goto exit;
 	}
 
 	retval = arvo_init_specials(hdev);
 	if (retval) {
-		dev_err(&hdev->dev, "couldn't install keyboard\n");
+		hid_err(hdev, "couldn't install keyboard\n");
 		goto exit_stop;
 	}
 

commit e68cc603b063416c85f3e408184219fb71d4a9ff
Author: Stefan Achatz <erazor_de@users.sourceforge.net>
Date:   Thu Jan 6 09:00:34 2011 +0100

    HID: roccat: Add support for Roccat Arvo keyboard
    
    This patch add support for Roccat Arvo keyboard. Arvo has 5 additional
    configurable buttons and the ability to deactivate certain keys.
    Userland tools can soon be found at http://sourceforge.net/projects/roccat
    
    Signed-off-by: Stefan Achatz <erazor_de@users.sourceforge.net>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-roccat-arvo.c b/drivers/hid/hid-roccat-arvo.c
new file mode 100644
index 000000000000..8facbd3efd72
--- /dev/null
+++ b/drivers/hid/hid-roccat-arvo.c
@@ -0,0 +1,516 @@
+/*
+ * Roccat Arvo driver for Linux
+ *
+ * Copyright (c) 2011 Stefan Achatz <erazor_de@users.sourceforge.net>
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ */
+
+/*
+ * Roccat Arvo is a gamer keyboard with 5 macro keys that can be configured in
+ * 5 profiles.
+ */
+
+#include <linux/device.h>
+#include <linux/input.h>
+#include <linux/hid.h>
+#include <linux/usb.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include "hid-ids.h"
+#include "hid-roccat.h"
+#include "hid-roccat-arvo.h"
+
+static struct class *arvo_class;
+
+static int arvo_receive(struct usb_device *usb_dev, uint usb_command,
+		void *buf, uint size)
+{
+	int len;
+
+	len = usb_control_msg(usb_dev, usb_rcvctrlpipe(usb_dev, 0),
+			USB_REQ_CLEAR_FEATURE,
+			USB_TYPE_CLASS | USB_RECIP_INTERFACE | USB_DIR_IN,
+			usb_command, 0, buf, size, USB_CTRL_SET_TIMEOUT);
+
+	return (len != size) ? -EIO : 0;
+}
+
+static int arvo_send(struct usb_device *usb_dev, uint usb_command,
+		void const *buf, uint size)
+{
+	int len;
+
+	len = usb_control_msg(usb_dev, usb_sndctrlpipe(usb_dev, 0),
+			USB_REQ_SET_CONFIGURATION,
+			USB_TYPE_CLASS | USB_RECIP_INTERFACE | USB_DIR_OUT,
+			usb_command, 0, (void *)buf, size, USB_CTRL_SET_TIMEOUT);
+
+	return (len != size) ? -EIO : 0;
+}
+
+static ssize_t arvo_sysfs_show_mode_key(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct arvo_device *arvo =
+			hid_get_drvdata(dev_get_drvdata(dev->parent->parent));
+	struct usb_device *usb_dev =
+			interface_to_usbdev(to_usb_interface(dev->parent->parent));
+	struct arvo_mode_key *temp_buf;
+	int retval;
+
+	temp_buf = kmalloc(sizeof(struct arvo_mode_key), GFP_KERNEL);
+	if (!temp_buf)
+		return -ENOMEM;
+
+	mutex_lock(&arvo->arvo_lock);
+	retval = arvo_receive(usb_dev, ARVO_USB_COMMAND_MODE_KEY,
+			temp_buf, sizeof(struct arvo_mode_key));
+	mutex_unlock(&arvo->arvo_lock);
+	if (retval)
+		goto out;
+
+	retval = snprintf(buf, PAGE_SIZE, "%d\n", temp_buf->state);
+out:
+	kfree(temp_buf);
+	return retval;
+}
+
+static ssize_t arvo_sysfs_set_mode_key(struct device *dev,
+		struct device_attribute *attr, char const *buf, size_t size)
+{
+	struct arvo_device *arvo =
+			hid_get_drvdata(dev_get_drvdata(dev->parent->parent));
+	struct usb_device *usb_dev =
+			interface_to_usbdev(to_usb_interface(dev->parent->parent));
+	struct arvo_mode_key *temp_buf;
+	unsigned long state;
+	int retval;
+
+	temp_buf = kmalloc(sizeof(struct arvo_mode_key), GFP_KERNEL);
+	if (!temp_buf)
+		return -ENOMEM;
+
+	retval = strict_strtoul(buf, 10, &state);
+	if (retval)
+		goto out;
+
+	temp_buf->command = ARVO_COMMAND_MODE_KEY;
+	temp_buf->state = state;
+
+	mutex_lock(&arvo->arvo_lock);
+	retval = arvo_send(usb_dev, ARVO_USB_COMMAND_MODE_KEY,
+			temp_buf, sizeof(struct arvo_mode_key));
+	mutex_unlock(&arvo->arvo_lock);
+	if (retval)
+		goto out;
+
+	retval = size;
+out:
+	kfree(temp_buf);
+	return retval;
+}
+
+static ssize_t arvo_sysfs_show_key_mask(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct arvo_device *arvo =
+			hid_get_drvdata(dev_get_drvdata(dev->parent->parent));
+	struct usb_device *usb_dev =
+			interface_to_usbdev(to_usb_interface(dev->parent->parent));
+	struct arvo_key_mask *temp_buf;
+	int retval;
+
+	temp_buf = kmalloc(sizeof(struct arvo_key_mask), GFP_KERNEL);
+	if (!temp_buf)
+		return -ENOMEM;
+
+	mutex_lock(&arvo->arvo_lock);
+	retval = arvo_receive(usb_dev, ARVO_USB_COMMAND_KEY_MASK,
+			temp_buf, sizeof(struct arvo_key_mask));
+	mutex_unlock(&arvo->arvo_lock);
+	if (retval)
+		goto out;
+
+	retval = snprintf(buf, PAGE_SIZE, "%d\n", temp_buf->key_mask);
+out:
+	kfree(temp_buf);
+	return retval;
+}
+
+static ssize_t arvo_sysfs_set_key_mask(struct device *dev,
+		struct device_attribute *attr, char const *buf, size_t size)
+{
+	struct arvo_device *arvo =
+			hid_get_drvdata(dev_get_drvdata(dev->parent->parent));
+	struct usb_device *usb_dev =
+			interface_to_usbdev(to_usb_interface(dev->parent->parent));
+	struct arvo_key_mask *temp_buf;
+	unsigned long key_mask;
+	int retval;
+
+	temp_buf = kmalloc(sizeof(struct arvo_key_mask), GFP_KERNEL);
+	if (!temp_buf)
+		return -ENOMEM;
+
+	retval = strict_strtoul(buf, 10, &key_mask);
+	if (retval)
+		goto out;
+
+	temp_buf->command = ARVO_COMMAND_KEY_MASK;
+	temp_buf->key_mask = key_mask;
+
+	mutex_lock(&arvo->arvo_lock);
+	retval = arvo_send(usb_dev, ARVO_USB_COMMAND_KEY_MASK,
+			temp_buf, sizeof(struct arvo_key_mask));
+	mutex_unlock(&arvo->arvo_lock);
+	if (retval)
+		goto out;
+
+	retval = size;
+out:
+	kfree(temp_buf);
+	return retval;
+}
+
+/* retval is 1-5 on success, < 0 on error */
+static int arvo_get_actual_profile(struct usb_device *usb_dev)
+{
+	struct arvo_actual_profile *temp_buf;
+	int retval;
+
+	temp_buf = kmalloc(sizeof(struct arvo_actual_profile), GFP_KERNEL);
+	if (!temp_buf)
+		return -ENOMEM;
+
+	retval = arvo_receive(usb_dev, ARVO_USB_COMMAND_ACTUAL_PROFILE,
+			temp_buf, sizeof(struct arvo_actual_profile));
+
+	if (!retval)
+		retval = temp_buf->actual_profile;
+
+	kfree(temp_buf);
+	return retval;
+}
+
+static ssize_t arvo_sysfs_show_actual_profile(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct arvo_device *arvo =
+			hid_get_drvdata(dev_get_drvdata(dev->parent->parent));
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", arvo->actual_profile);
+}
+
+static ssize_t arvo_sysfs_set_actual_profile(struct device *dev,
+		struct device_attribute *attr, char const *buf, size_t size)
+{
+	struct arvo_device *arvo =
+			hid_get_drvdata(dev_get_drvdata(dev->parent->parent));
+	struct usb_device *usb_dev =
+			interface_to_usbdev(to_usb_interface(dev->parent->parent));
+	struct arvo_actual_profile *temp_buf;
+	unsigned long profile;
+	int retval;
+
+	temp_buf = kmalloc(sizeof(struct arvo_actual_profile), GFP_KERNEL);
+	if (!temp_buf)
+		return -ENOMEM;
+
+	retval = strict_strtoul(buf, 10, &profile);
+	if (retval)
+		goto out;
+
+	temp_buf->command = ARVO_COMMAND_ACTUAL_PROFILE;
+	temp_buf->actual_profile = profile;
+
+	mutex_lock(&arvo->arvo_lock);
+	retval = arvo_send(usb_dev, ARVO_USB_COMMAND_ACTUAL_PROFILE,
+			temp_buf, sizeof(struct arvo_actual_profile));
+	if (!retval) {
+		arvo->actual_profile = profile;
+		retval = size;
+	}
+	mutex_unlock(&arvo->arvo_lock);
+
+out:
+	kfree(temp_buf);
+	return retval;
+}
+
+static ssize_t arvo_sysfs_write(struct file *fp,
+		struct kobject *kobj, void const *buf,
+		loff_t off, size_t count, size_t real_size, uint command)
+{
+	struct device *dev =
+			container_of(kobj, struct device, kobj)->parent->parent;
+	struct arvo_device *arvo = hid_get_drvdata(dev_get_drvdata(dev));
+	struct usb_device *usb_dev = interface_to_usbdev(to_usb_interface(dev));
+	int retval;
+
+	if (off != 0 || count != real_size)
+		return -EINVAL;
+
+	mutex_lock(&arvo->arvo_lock);
+	retval = arvo_send(usb_dev, command, buf, real_size);
+	mutex_unlock(&arvo->arvo_lock);
+
+	return (retval ? retval : real_size);
+}
+
+static ssize_t arvo_sysfs_read(struct file *fp,
+		struct kobject *kobj, void *buf, loff_t off,
+		size_t count, size_t real_size, uint command)
+{
+	struct device *dev =
+			container_of(kobj, struct device, kobj)->parent->parent;
+	struct arvo_device *arvo = hid_get_drvdata(dev_get_drvdata(dev));
+	struct usb_device *usb_dev = interface_to_usbdev(to_usb_interface(dev));
+	int retval;
+
+	if (off >= real_size)
+		return 0;
+
+	if (off != 0 || count != real_size)
+		return -EINVAL;
+
+	mutex_lock(&arvo->arvo_lock);
+	retval = arvo_receive(usb_dev, command, buf, real_size);
+	mutex_unlock(&arvo->arvo_lock);
+
+	return (retval ? retval : real_size);
+}
+
+static ssize_t arvo_sysfs_write_button(struct file *fp,
+		struct kobject *kobj, struct bin_attribute *attr, char *buf,
+		loff_t off, size_t count)
+{
+	return arvo_sysfs_write(fp, kobj, buf, off, count,
+			sizeof(struct arvo_button), ARVO_USB_COMMAND_BUTTON);
+}
+
+static ssize_t arvo_sysfs_read_info(struct file *fp,
+		struct kobject *kobj, struct bin_attribute *attr, char *buf,
+		loff_t off, size_t count)
+{
+	return arvo_sysfs_read(fp, kobj, buf, off, count,
+			sizeof(struct arvo_info), ARVO_USB_COMMAND_INFO);
+}
+
+
+static struct device_attribute arvo_attributes[] = {
+	__ATTR(mode_key, 0660,
+			arvo_sysfs_show_mode_key, arvo_sysfs_set_mode_key),
+	__ATTR(key_mask, 0660,
+			arvo_sysfs_show_key_mask, arvo_sysfs_set_key_mask),
+	__ATTR(actual_profile, 0660,
+			arvo_sysfs_show_actual_profile,
+			arvo_sysfs_set_actual_profile),
+	__ATTR_NULL
+};
+
+static struct bin_attribute arvo_bin_attributes[] = {
+	{
+		.attr = { .name = "button", .mode = 0220 },
+		.size = sizeof(struct arvo_button),
+		.write = arvo_sysfs_write_button
+	},
+	{
+		.attr = { .name = "info", .mode = 0440 },
+		.size = sizeof(struct arvo_info),
+		.read = arvo_sysfs_read_info
+	},
+	__ATTR_NULL
+};
+
+static int arvo_init_arvo_device_struct(struct usb_device *usb_dev,
+		struct arvo_device *arvo)
+{
+	int retval;
+
+	mutex_init(&arvo->arvo_lock);
+
+	retval = arvo_get_actual_profile(usb_dev);
+	if (retval < 0)
+		return retval;
+	arvo->actual_profile = retval;
+
+	return 0;
+}
+
+static int arvo_init_specials(struct hid_device *hdev)
+{
+	struct usb_interface *intf = to_usb_interface(hdev->dev.parent);
+	struct usb_device *usb_dev = interface_to_usbdev(intf);
+	struct arvo_device *arvo;
+	int retval;
+
+	if (intf->cur_altsetting->desc.bInterfaceProtocol
+			== USB_INTERFACE_PROTOCOL_KEYBOARD) {
+		hid_set_drvdata(hdev, NULL);
+		return 0;
+	}
+
+	arvo = kzalloc(sizeof(*arvo), GFP_KERNEL);
+	if (!arvo) {
+		dev_err(&hdev->dev, "can't alloc device descriptor\n");
+		return -ENOMEM;
+	}
+	hid_set_drvdata(hdev, arvo);
+
+	retval = arvo_init_arvo_device_struct(usb_dev, arvo);
+	if (retval) {
+		dev_err(&hdev->dev,
+				"couldn't init struct arvo_device\n");
+		goto exit_free;
+	}
+
+	retval = roccat_connect(arvo_class, hdev);
+	if (retval < 0) {
+		dev_err(&hdev->dev, "couldn't init char dev\n");
+	} else {
+		arvo->chrdev_minor = retval;
+		arvo->roccat_claimed = 1;
+	}
+
+	return 0;
+exit_free:
+	kfree(arvo);
+	return retval;
+}
+
+static void arvo_remove_specials(struct hid_device *hdev)
+{
+	struct usb_interface *intf = to_usb_interface(hdev->dev.parent);
+	struct arvo_device *arvo;
+
+	if (intf->cur_altsetting->desc.bInterfaceProtocol
+			== USB_INTERFACE_PROTOCOL_KEYBOARD)
+		return;
+
+	arvo = hid_get_drvdata(hdev);
+	if (arvo->roccat_claimed)
+		roccat_disconnect(arvo->chrdev_minor);
+	kfree(arvo);
+}
+
+static int arvo_probe(struct hid_device *hdev,
+		const struct hid_device_id *id)
+{
+	int retval;
+
+	retval = hid_parse(hdev);
+	if (retval) {
+		dev_err(&hdev->dev, "parse failed\n");
+		goto exit;
+	}
+
+	retval = hid_hw_start(hdev, HID_CONNECT_DEFAULT);
+	if (retval) {
+		dev_err(&hdev->dev, "hw start failed\n");
+		goto exit;
+	}
+
+	retval = arvo_init_specials(hdev);
+	if (retval) {
+		dev_err(&hdev->dev, "couldn't install keyboard\n");
+		goto exit_stop;
+	}
+
+	return 0;
+
+exit_stop:
+	hid_hw_stop(hdev);
+exit:
+	return retval;
+}
+
+static void arvo_remove(struct hid_device *hdev)
+{
+	arvo_remove_specials(hdev);
+	hid_hw_stop(hdev);
+}
+
+static void arvo_report_to_chrdev(struct arvo_device const *arvo,
+		u8 const *data)
+{
+	struct arvo_special_report const *special_report;
+	struct arvo_roccat_report roccat_report;
+
+	special_report = (struct arvo_special_report const *)data;
+
+	roccat_report.profile = arvo->actual_profile;
+	roccat_report.button = special_report->event &
+			ARVO_SPECIAL_REPORT_EVENT_MASK_BUTTON;
+	if ((special_report->event & ARVO_SPECIAL_REPORT_EVENT_MASK_ACTION) ==
+			ARVO_SPECIAL_REPORT_EVENT_ACTION_PRESS)
+		roccat_report.action = ARVO_ROCCAT_REPORT_ACTION_PRESS;
+	else
+		roccat_report.action = ARVO_ROCCAT_REPORT_ACTION_RELEASE;
+
+	roccat_report_event(arvo->chrdev_minor, (uint8_t const *)&roccat_report,
+			sizeof(struct arvo_roccat_report));
+}
+
+static int arvo_raw_event(struct hid_device *hdev,
+		struct hid_report *report, u8 *data, int size)
+{
+	struct arvo_device *arvo = hid_get_drvdata(hdev);
+
+	if (size != 3)
+		return 0;
+
+	if (arvo->roccat_claimed)
+		arvo_report_to_chrdev(arvo, data);
+
+	return 0;
+}
+
+static const struct hid_device_id arvo_devices[] = {
+	{ HID_USB_DEVICE(USB_VENDOR_ID_ROCCAT, USB_DEVICE_ID_ROCCAT_ARVO) },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(hid, arvo_devices);
+
+static struct hid_driver arvo_driver = {
+	.name = "arvo",
+	.id_table = arvo_devices,
+	.probe = arvo_probe,
+	.remove = arvo_remove,
+	.raw_event = arvo_raw_event
+};
+
+static int __init arvo_init(void)
+{
+	int retval;
+
+	arvo_class = class_create(THIS_MODULE, "arvo");
+	if (IS_ERR(arvo_class))
+		return PTR_ERR(arvo_class);
+	arvo_class->dev_attrs = arvo_attributes;
+	arvo_class->dev_bin_attrs = arvo_bin_attributes;
+
+	retval = hid_register_driver(&arvo_driver);
+	if (retval)
+		class_destroy(arvo_class);
+	return retval;
+}
+
+static void __exit arvo_exit(void)
+{
+	class_destroy(arvo_class);
+	hid_unregister_driver(&arvo_driver);
+}
+
+module_init(arvo_init);
+module_exit(arvo_exit);
+
+MODULE_AUTHOR("Stefan Achatz");
+MODULE_DESCRIPTION("USB Roccat Arvo driver");
+MODULE_LICENSE("GPL v2");
