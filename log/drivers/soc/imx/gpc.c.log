commit e0ea2d11f8a08ba7066ff897e16c5217215d1e68
Author: Lucas Stach <l.stach@pengutronix.de>
Date:   Fri Mar 13 11:09:12 2020 +0100

    soc: imx: gpc: fix power up sequencing
    
    Currently we wait only until the PGC inverts the isolation setting
    before disabling the peripheral clocks. This doesn't ensure that the
    reset is properly propagated through the peripheral devices in the
    power domain.
    
    Wait until the PGC signals that the power up request is done and
    wait a bit for resets to propagate before disabling the clocks.
    
    Signed-off-by: Lucas Stach <l.stach@pengutronix.de>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/drivers/soc/imx/gpc.c b/drivers/soc/imx/gpc.c
index 98b9d9a902ae..90a8b2c0676f 100644
--- a/drivers/soc/imx/gpc.c
+++ b/drivers/soc/imx/gpc.c
@@ -87,8 +87,8 @@ static int imx6_pm_domain_power_off(struct generic_pm_domain *genpd)
 static int imx6_pm_domain_power_on(struct generic_pm_domain *genpd)
 {
 	struct imx_pm_domain *pd = to_imx_pm_domain(genpd);
-	int i, ret, sw, sw2iso;
-	u32 val;
+	int i, ret;
+	u32 val, req;
 
 	if (pd->supply) {
 		ret = regulator_enable(pd->supply);
@@ -107,17 +107,18 @@ static int imx6_pm_domain_power_on(struct generic_pm_domain *genpd)
 	regmap_update_bits(pd->regmap, pd->reg_offs + GPC_PGC_CTRL_OFFS,
 			   0x1, 0x1);
 
-	/* Read ISO and ISO2SW power up delays */
-	regmap_read(pd->regmap, pd->reg_offs + GPC_PGC_PUPSCR_OFFS, &val);
-	sw = val & 0x3f;
-	sw2iso = (val >> 8) & 0x3f;
-
 	/* Request GPC to power up domain */
-	val = BIT(pd->cntr_pdn_bit + 1);
-	regmap_update_bits(pd->regmap, GPC_CNTR, val, val);
+	req = BIT(pd->cntr_pdn_bit + 1);
+	regmap_update_bits(pd->regmap, GPC_CNTR, req, req);
 
-	/* Wait ISO + ISO2SW IPG clock cycles */
-	udelay(DIV_ROUND_UP(sw + sw2iso, pd->ipg_rate_mhz));
+	/* Wait for the PGC to handle the request */
+	ret = regmap_read_poll_timeout(pd->regmap, GPC_CNTR, val, !(val & req),
+				       1, 50);
+	if (ret)
+		pr_err("powerup request on domain %s timed out\n", genpd->name);
+
+	/* Wait for reset to propagate through peripherals */
+	usleep_range(5, 10);
 
 	/* Disable reset clocks for all devices in the domain */
 	for (i = 0; i < pd->num_clks; i++)
@@ -343,6 +344,7 @@ static const struct regmap_config imx_gpc_regmap_config = {
 	.rd_table = &access_table,
 	.wr_table = &access_table,
 	.max_register = 0x2ac,
+	.fast_io = true,
 };
 
 static struct generic_pm_domain *imx_gpc_onecell_domains[] = {

commit 96ed1044fa98ea9e164fc1e679cad61575bf4f32
Author: Ben Dooks <ben.dooks@codethink.co.uk>
Date:   Tue Oct 15 15:09:09 2019 +0100

    soc: imx: gpc: fix initialiser format
    
    Make the initialiers in imx_gpc_domains C99 format to fix the
    following sparse warnings:
    
    drivers/soc/imx/gpc.c:252:30: warning: obsolete array initializer, use C99 syntax
    drivers/soc/imx/gpc.c:258:29: warning: obsolete array initializer, use C99 syntax
    drivers/soc/imx/gpc.c:269:34: warning: obsolete array initializer, use C99 syntax
    drivers/soc/imx/gpc.c:278:30: warning: obsolete array initializer, use C99 syntax
    
    Signed-off-by: Ben Dooks <ben.dooks@codethink.co.uk>
    Reviewed-by: Lucas Stach <l.stach@pengutronix.de>
    Fixes: b0682d485f12 ("soc: imx: gpc: use GPC_PGC_DOMAIN_* indexes")
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/drivers/soc/imx/gpc.c b/drivers/soc/imx/gpc.c
index d9231bd3c691..98b9d9a902ae 100644
--- a/drivers/soc/imx/gpc.c
+++ b/drivers/soc/imx/gpc.c
@@ -249,13 +249,13 @@ static struct genpd_power_state imx6_pm_domain_pu_state = {
 };
 
 static struct imx_pm_domain imx_gpc_domains[] = {
-	[GPC_PGC_DOMAIN_ARM] {
+	[GPC_PGC_DOMAIN_ARM] = {
 		.base = {
 			.name = "ARM",
 			.flags = GENPD_FLAG_ALWAYS_ON,
 		},
 	},
-	[GPC_PGC_DOMAIN_PU] {
+	[GPC_PGC_DOMAIN_PU] = {
 		.base = {
 			.name = "PU",
 			.power_off = imx6_pm_domain_power_off,
@@ -266,7 +266,7 @@ static struct imx_pm_domain imx_gpc_domains[] = {
 		.reg_offs = 0x260,
 		.cntr_pdn_bit = 0,
 	},
-	[GPC_PGC_DOMAIN_DISPLAY] {
+	[GPC_PGC_DOMAIN_DISPLAY] = {
 		.base = {
 			.name = "DISPLAY",
 			.power_off = imx6_pm_domain_power_off,
@@ -275,7 +275,7 @@ static struct imx_pm_domain imx_gpc_domains[] = {
 		.reg_offs = 0x240,
 		.cntr_pdn_bit = 4,
 	},
-	[GPC_PGC_DOMAIN_PCI] {
+	[GPC_PGC_DOMAIN_PCI] = {
 		.base = {
 			.name = "PCI",
 			.power_off = imx6_pm_domain_power_off,

commit dc413a90edbe715bebebe859dc072ef73d490d70
Merge: e8a1d7011711 80d0c6492442
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu May 16 09:19:14 2019 -0700

    Merge tag 'armsoc-drivers' of git://git.kernel.org/pub/scm/linux/kernel/git/soc/soc
    
    Pull ARM SoC-related driver updates from Olof Johansson:
     "Various driver updates for platforms and a couple of the small driver
      subsystems we merge through our tree:
    
      Among the larger pieces:
    
       - Power management improvements for TI am335x and am437x (RTC
         suspend/wake)
    
       - Misc new additions for Amlogic (socinfo updates)
    
       - ZynqMP FPGA manager
    
       - Nvidia improvements for reset/powergate handling
    
       - PMIC wrapper for Mediatek MT8516
    
       - Misc fixes/improvements for ARM SCMI, TEE, NXP i.MX SCU drivers"
    
    * tag 'armsoc-drivers' of git://git.kernel.org/pub/scm/linux/kernel/git/soc/soc: (57 commits)
      soc: aspeed: fix Kconfig
      soc: add aspeed folder and misc drivers
      spi: zynqmp: Fix build break
      soc: imx: Add generic i.MX8 SoC driver
      MAINTAINERS: Update email for Qualcomm SoC maintainer
      memory: tegra: Fix a typos for "fdcdwr2" mc client
      Revert "ARM: tegra: Restore memory arbitration on resume from LP1 on Tegra30+"
      memory: tegra: Replace readl-writel with mc_readl-mc_writel
      memory: tegra: Fix integer overflow on tick value calculation
      memory: tegra: Fix missed registers values latching
      ARM: tegra: cpuidle: Handle tick broadcasting within cpuidle core on Tegra20/30
      optee: allow to work without static shared memory
      soc/tegra: pmc: Move powergate initialisation to probe
      soc/tegra: pmc: Remove reset sysfs entries on error
      soc/tegra: pmc: Fix reset sources and levels
      soc: amlogic: meson-gx-pwrc-vpu: Add support for G12A
      soc: amlogic: meson-gx-pwrc-vpu: Fix power on/off register bitmask
      fpga manager: Adding FPGA Manager support for Xilinx zynqmp
      dt-bindings: fpga: Add bindings for ZynqMP fpga driver
      firmware: xilinx: Add fpga API's
      ...

commit 8d5d766f00726efd0abd2e7835b0e538fe4ad6e4
Author: Leonard Crestez <leonard.crestez@nxp.com>
Date:   Tue Apr 30 15:06:12 2019 +0000

    soc: imx: gpc: Use GENPD_FLAG_RPM_ALWAYS_ON for ERR009619
    
    This allows PU domain to be turned off in suspend and save power.
    
    Signed-off-by: Leonard Crestez <leonard.crestez@nxp.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/soc/imx/gpc.c b/drivers/soc/imx/gpc.c
index 7d14a4b4e82a..29b43651c261 100644
--- a/drivers/soc/imx/gpc.c
+++ b/drivers/soc/imx/gpc.c
@@ -431,10 +431,19 @@ static int imx_gpc_probe(struct platform_device *pdev)
 		return ret;
 	}
 
-	/* Disable PU power down in normal operation if ERR009619 is present */
+	/*
+	 * Disable PU power down by runtime PM if ERR009619 is present.
+	 *
+	 * The PRE clock will be paused for several cycles when turning on the
+	 * PU domain LDO from power down state. If PRE is in use at that time,
+	 * the IPU/PRG cannot get the correct display data from the PRE.
+	 *
+	 * This is not a concern when the whole system enters suspend state, so
+	 * it's safe to power down PU in this case.
+	 */
 	if (of_id_data->err009619_present)
 		imx_gpc_domains[GPC_PGC_DOMAIN_PU].base.flags |=
-				GENPD_FLAG_ALWAYS_ON;
+				GENPD_FLAG_RPM_ALWAYS_ON;
 
 	/* Keep DISP always on if ERR006287 is present */
 	if (of_id_data->err006287_present)

commit ccc1de31ab54bbf3e9fe2df1f562ea92d8fe8e44
Author: Anson Huang <anson.huang@nxp.com>
Date:   Mon Apr 1 06:07:08 2019 +0000

    soc: imx: gpc: use devm_platform_ioremap_resource() to simplify code
    
    Use the new helper devm_platform_ioremap_resource() which wraps the
    platform_get_resource() and devm_ioremap_resource() together, to
    simplify the code.
    
    Signed-off-by: Anson Huang <Anson.Huang@nxp.com>
    Reviewed-by: Mukesh Ojha <mojha@codeaurora.org>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/drivers/soc/imx/gpc.c b/drivers/soc/imx/gpc.c
index 7d14a4b4e82a..a8f1e47ce698 100644
--- a/drivers/soc/imx/gpc.c
+++ b/drivers/soc/imx/gpc.c
@@ -406,7 +406,6 @@ static int imx_gpc_probe(struct platform_device *pdev)
 	const struct imx_gpc_dt_data *of_id_data = of_id->data;
 	struct device_node *pgc_node;
 	struct regmap *regmap;
-	struct resource *res;
 	void __iomem *base;
 	int ret;
 
@@ -417,8 +416,7 @@ static int imx_gpc_probe(struct platform_device *pdev)
 	    !pgc_node)
 		return 0;
 
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	base = devm_ioremap_resource(&pdev->dev, res);
+	base = devm_platform_ioremap_resource(pdev, 0);
 	if (IS_ERR(base))
 		return PTR_ERR(base);
 

commit b6444cf5fa607469d9a14edef2edad32773f4514
Author: Leonard Crestez <leonard.crestez@nxp.com>
Date:   Mon Oct 8 18:06:19 2018 +0000

    soc: imx: gpc: Increase GPC_CLK_MAX to 7
    
    The DISPLAY power domain on imx6sx has 7 clocks.
    
    Signed-off-by: Leonard Crestez <leonard.crestez@nxp.com>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/drivers/soc/imx/gpc.c b/drivers/soc/imx/gpc.c
index aa3729ecaa9e..7d14a4b4e82a 100644
--- a/drivers/soc/imx/gpc.c
+++ b/drivers/soc/imx/gpc.c
@@ -35,7 +35,7 @@
 #define GPU_VPU_PUP_REQ		BIT(1)
 #define GPU_VPU_PDN_REQ		BIT(0)
 
-#define GPC_CLK_MAX		6
+#define GPC_CLK_MAX		7
 
 #define PGC_DOMAIN_FLAG_NO_PD		BIT(0)
 

commit 2fe761d18adaf62686254fa273773efa6b1da9c0
Author: Fabio Estevam <fabio.estevam@nxp.com>
Date:   Tue Sep 18 14:48:13 2018 -0300

    soc: imx: gpc: Switch to SPDX identifier
    
    Adopt the SPDX license identifier headers to ease license compliance
    management.
    
    Signed-off-by: Fabio Estevam <fabio.estevam@nxp.com>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/drivers/soc/imx/gpc.c b/drivers/soc/imx/gpc.c
index c1d0ffdac6dd..aa3729ecaa9e 100644
--- a/drivers/soc/imx/gpc.c
+++ b/drivers/soc/imx/gpc.c
@@ -1,13 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * Copyright 2015-2017 Pengutronix, Lucas Stach <kernel@pengutronix.de>
  * Copyright 2011-2013 Freescale Semiconductor, Inc.
- *
- * The code contained herein is licensed under the GNU General Public
- * License. You may obtain a copy of the GNU General Public License
- * Version 2 or later at the following locations:
- *
- * http://www.opensource.org/licenses/gpl-license.html
- * http://www.gnu.org/copyleft/gpl.html
  */
 
 #include <linux/clk.h>

commit b0682d485f12a720a066ec65f00510df3532e160
Author: Sven Schmitt <Sven.Schmitt@mixed-mode.de>
Date:   Tue Jul 24 09:46:07 2018 +0000

    soc: imx: gpc: use GPC_PGC_DOMAIN_* indexes
    
    Use GPC_PGC_DOMAIN_* indexes consistent.
    
    Signed-off-by: Sven Schmitt <sven.schmitt@mixed-mode.de>
    Reviewed-by: Leonard Crestez <leonard.crestez@nxp.com>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/drivers/soc/imx/gpc.c b/drivers/soc/imx/gpc.c
index d160fc2a7b7a..c1d0ffdac6dd 100644
--- a/drivers/soc/imx/gpc.c
+++ b/drivers/soc/imx/gpc.c
@@ -247,6 +247,7 @@ builtin_platform_driver(imx_pgc_power_domain_driver)
 #define GPC_PGC_DOMAIN_ARM	0
 #define GPC_PGC_DOMAIN_PU	1
 #define GPC_PGC_DOMAIN_DISPLAY	2
+#define GPC_PGC_DOMAIN_PCI	3
 
 static struct genpd_power_state imx6_pm_domain_pu_state = {
 	.power_off_latency_ns = 25000,
@@ -254,12 +255,13 @@ static struct genpd_power_state imx6_pm_domain_pu_state = {
 };
 
 static struct imx_pm_domain imx_gpc_domains[] = {
-	{
+	[GPC_PGC_DOMAIN_ARM] {
 		.base = {
 			.name = "ARM",
 			.flags = GENPD_FLAG_ALWAYS_ON,
 		},
-	}, {
+	},
+	[GPC_PGC_DOMAIN_PU] {
 		.base = {
 			.name = "PU",
 			.power_off = imx6_pm_domain_power_off,
@@ -269,7 +271,8 @@ static struct imx_pm_domain imx_gpc_domains[] = {
 		},
 		.reg_offs = 0x260,
 		.cntr_pdn_bit = 0,
-	}, {
+	},
+	[GPC_PGC_DOMAIN_DISPLAY] {
 		.base = {
 			.name = "DISPLAY",
 			.power_off = imx6_pm_domain_power_off,
@@ -277,7 +280,8 @@ static struct imx_pm_domain imx_gpc_domains[] = {
 		},
 		.reg_offs = 0x240,
 		.cntr_pdn_bit = 4,
-	}, {
+	},
+	[GPC_PGC_DOMAIN_PCI] {
 		.base = {
 			.name = "PCI",
 			.power_off = imx6_pm_domain_power_off,
@@ -348,8 +352,8 @@ static const struct regmap_config imx_gpc_regmap_config = {
 };
 
 static struct generic_pm_domain *imx_gpc_onecell_domains[] = {
-	&imx_gpc_domains[0].base,
-	&imx_gpc_domains[1].base,
+	&imx_gpc_domains[GPC_PGC_DOMAIN_ARM].base,
+	&imx_gpc_domains[GPC_PGC_DOMAIN_PU].base,
 };
 
 static struct genpd_onecell_data imx_gpc_onecell_data = {

commit 9f4d61d531e0efc9c3283963ae5ef7e314579191
Author: Sven Schmitt <Sven.Schmitt@mixed-mode.de>
Date:   Tue Jul 24 09:46:03 2018 +0000

    soc: imx: gpc: fix PDN delay
    
    imx6_pm_domain_power_off() reads iso and iso2sw from GPC_PGC_PUPSCR_OFFS
    which stores the power up delays.
    So use GPC_PGC_PDNSCR_OFFS for the correct delays.
    
    Signed-off-by: Sven Schmitt <sven.schmitt@mixed-mode.de>
    Reviewed-by: Leonard Crestez <leonard.crestez@nxp.com>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/drivers/soc/imx/gpc.c b/drivers/soc/imx/gpc.c
index b3da635970ea..d160fc2a7b7a 100644
--- a/drivers/soc/imx/gpc.c
+++ b/drivers/soc/imx/gpc.c
@@ -69,7 +69,7 @@ static int imx6_pm_domain_power_off(struct generic_pm_domain *genpd)
 	u32 val;
 
 	/* Read ISO and ISO2SW power down delays */
-	regmap_read(pd->regmap, pd->reg_offs + GPC_PGC_PUPSCR_OFFS, &val);
+	regmap_read(pd->regmap, pd->reg_offs + GPC_PGC_PDNSCR_OFFS, &val);
 	iso = val & 0x3f;
 	iso2sw = (val >> 8) & 0x3f;
 

commit f3ea496213819c80ce9c49a9b65f9261da713d11
Merge: 9e259f9352d5 29ed45fff058
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Aug 23 13:52:46 2018 -0700

    Merge tag 'armsoc-drivers' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC driver updates from Olof Johansson:
     "Some of the larger changes this merge window:
    
       - Removal of drivers for Exynos5440, a Samsung SoC that never saw
         widespread use.
    
       - Uniphier support for USB3 and SPI reset handling
    
       - Syste control and SRAM drivers and bindings for Allwinner platforms
    
       - Qualcomm AOSS (Always-on subsystem) reset controller drivers
    
       - Raspberry Pi hwmon driver for voltage
    
       - Mediatek pwrap (pmic) support for MT6797 SoC"
    
    * tag 'armsoc-drivers' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (52 commits)
      drivers/firmware: psci_checker: stash and use topology_core_cpumask for hotplug tests
      soc: fsl: cleanup Kconfig menu
      soc: fsl: dpio: Convert DPIO documentation to .rst
      staging: fsl-mc: Remove remaining files
      staging: fsl-mc: Move DPIO from staging to drivers/soc/fsl
      staging: fsl-dpaa2: eth: move generic FD defines to DPIO
      soc: fsl: qe: gpio: Add qe_gpio_set_multiple
      usb: host: exynos: Remove support for Exynos5440
      clk: samsung: Remove support for Exynos5440
      soc: sunxi: Add the A13, A23 and H3 system control compatibles
      reset: uniphier: add reset control support for SPI
      cpufreq: exynos: Remove support for Exynos5440
      ata: ahci-platform: Remove support for Exynos5440
      soc: imx6qp: Use GENPD_FLAG_ALWAYS_ON for PU errata
      soc: mediatek: pwrap: add mt6351 driver for mt6797 SoCs
      soc: mediatek: pwrap: add pwrap driver for mt6797 SoCs
      soc: mediatek: pwrap: fix cipher init setting error
      dt-bindings: pwrap: mediatek: add pwrap support for MT6797
      reset: uniphier: add USB3 core reset control
      dt-bindings: reset: uniphier: add USB3 core reset support
      ...

commit 17bc3432e39d10ff50a090a37bbdabfca69467c5
Merge: 9b7c19e96ced 1689cac5b32a 27dceb81f445 55f2503c3b69 231f94150011 818489e511a3
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Aug 14 09:48:10 2018 +0200

    Merge branches 'pm-core', 'pm-domains', 'pm-sleep', 'acpi-pm' and 'pm-cpuidle'
    
    Merge changes in the PM core, system-wide PM infrastructure, generic
    power domains (genpd) framework, ACPI PM infrastructure and cpuidle
    for 4.19.
    
    * pm-core:
      driver core: Add flag to autoremove device link on supplier unbind
      driver core: Rename flag AUTOREMOVE to AUTOREMOVE_CONSUMER
    
    * pm-domains:
      PM / Domains: Introduce dev_pm_domain_attach_by_name()
      PM / Domains: Introduce option to attach a device by name to genpd
      PM / Domains: dt: Add a power-domain-names property
    
    * pm-sleep:
      PM / reboot: Eliminate race between reboot and suspend
      PM / hibernate: Mark expected switch fall-through
      x86/power/hibernate_64: Remove VLA usage
      PM / hibernate: cast PAGE_SIZE to int when comparing with error code
    
    * acpi-pm:
      ACPI / PM: save NVS memory for ASUS 1025C laptop
      ACPI / PM: Default to s2idle in all machines supporting LP S0
    
    * pm-cpuidle:
      ARM: cpuidle: silence error on driver registration failure

commit de2d9b5284bcb5c159c5882ac69f6bfd4dec7c67
Author: Anson Huang <Anson.Huang@nxp.com>
Date:   Tue Jul 17 11:28:46 2018 +0800

    soc: imx: gpc: restrict register range for regmap access
    
    GPC registers are NOT continuous, some registers are
    reserved and accessing them from userspace will trigger
    external abort, add regmap register access table to
    avoid below abort:
    
    root@imx6slevk:~# cat /sys/kernel/debug/regmap/20dc000.gpc/registers
    [  108.480477] Unhandled fault: imprecise external abort (0x1406) at 0xb6db5004
    [  108.487985] pgd = 42b54bfd
    [  108.490741] [b6db5004] *pgd=ba1b7831
    [  108.494386] Internal error: : 1406 [#1] SMP ARM
    [  108.498943] Modules linked in:
    [  108.502043] CPU: 0 PID: 389 Comm: cat Not tainted 4.18.0-rc1-00074-gc9f1f60-dirty #482
    [  108.509982] Hardware name: Freescale i.MX6 SoloLite (Device Tree)
    [  108.516123] PC is at regmap_mmio_read32le+0x20/0x24
    [  108.521031] LR is at regmap_mmio_read+0x40/0x60
    [  108.525586] pc : [<c059cf74>]    lr : [<c059d1ac>]    psr: 20060093
    [  108.531875] sp : eccf1d98  ip : eccf1da8  fp : eccf1da4
    [  108.537122] r10: ec2d3800  r9 : eccf1f60  r8 : ecfc0000
    [  108.542370] r7 : eccf1e2c  r6 : eccf1e2c  r5 : 00000028  r4 : ec338e00
    [  108.548920] r3 : 00000000  r2 : eccf1e2c  r1 : f0980028  r0 : 00000000
    [  108.555474] Flags: nzCv  IRQs off  FIQs on  Mode SVC_32  ISA ARM  Segment none
    [  108.562720] Control: 10c5387d  Table: acf4004a  DAC: 00000051
    [  108.568491] Process cat (pid: 389, stack limit = 0xd4318a65)
    [  108.574174] Stack: (0xeccf1d98 to 0xeccf2000)
    
    Fixes: 721cabf6c660 ("soc: imx: move PGC handling to a new GPC driver")
    Signed-off-by: Anson Huang <Anson.Huang@nxp.com>
    Reviewed-by: Fabio Estevam <fabio.estevam@nxp.com>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/drivers/soc/imx/gpc.c b/drivers/soc/imx/gpc.c
index 32f0748fd067..0097a939487f 100644
--- a/drivers/soc/imx/gpc.c
+++ b/drivers/soc/imx/gpc.c
@@ -27,9 +27,16 @@
 #define GPC_PGC_SW2ISO_SHIFT	0x8
 #define GPC_PGC_SW_SHIFT	0x0
 
+#define GPC_PGC_PCI_PDN		0x200
+#define GPC_PGC_PCI_SR		0x20c
+
 #define GPC_PGC_GPU_PDN		0x260
 #define GPC_PGC_GPU_PUPSCR	0x264
 #define GPC_PGC_GPU_PDNSCR	0x268
+#define GPC_PGC_GPU_SR		0x26c
+
+#define GPC_PGC_DISP_PDN	0x240
+#define GPC_PGC_DISP_SR		0x24c
 
 #define GPU_VPU_PUP_REQ		BIT(1)
 #define GPU_VPU_PDN_REQ		BIT(0)
@@ -318,10 +325,24 @@ static const struct of_device_id imx_gpc_dt_ids[] = {
 	{ }
 };
 
+static const struct regmap_range yes_ranges[] = {
+	regmap_reg_range(GPC_CNTR, GPC_CNTR),
+	regmap_reg_range(GPC_PGC_PCI_PDN, GPC_PGC_PCI_SR),
+	regmap_reg_range(GPC_PGC_GPU_PDN, GPC_PGC_GPU_SR),
+	regmap_reg_range(GPC_PGC_DISP_PDN, GPC_PGC_DISP_SR),
+};
+
+static const struct regmap_access_table access_table = {
+	.yes_ranges	= yes_ranges,
+	.n_yes_ranges	= ARRAY_SIZE(yes_ranges),
+};
+
 static const struct regmap_config imx_gpc_regmap_config = {
 	.reg_bits = 32,
 	.val_bits = 32,
 	.reg_stride = 4,
+	.rd_table = &access_table,
+	.wr_table = &access_table,
 	.max_register = 0x2ac,
 };
 

commit 69c04aee3482415cff52061a3ccad4943662e81d
Author: Leonard Crestez <leonard.crestez@nxp.com>
Date:   Fri Jul 13 13:01:15 2018 +0300

    soc: imx6qp: Use GENPD_FLAG_ALWAYS_ON for PU errata
    
    This is functionally identical but simpler and slightly faster.
    
    The PU domain is turned on at boot time and never turned off. In the
    current implementation the pm core will repeatedly call power_off when
    the domain is unused and get -EBUSY back. If the domain is marked as
    "always on" instead the pm core won't even attempt to turn it off.
    
    In theory on 6qp it is safe to turn PU off in suspend, however that is
    best accomplished with a new core flag.
    
    Signed-off-by: Leonard Crestez <leonard.crestez@nxp.com>
    Reviewed-by: Lucas Stach <l.stach@pengutronix.de>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/drivers/soc/imx/gpc.c b/drivers/soc/imx/gpc.c
index 13ff983f8b69..403f3f2f43bd 100644
--- a/drivers/soc/imx/gpc.c
+++ b/drivers/soc/imx/gpc.c
@@ -47,7 +47,6 @@ struct imx_pm_domain {
 	unsigned int reg_offs;
 	signed char cntr_pdn_bit;
 	unsigned int ipg_rate_mhz;
-	unsigned int flags;
 };
 
 static inline struct imx_pm_domain *
@@ -62,9 +61,6 @@ static int imx6_pm_domain_power_off(struct generic_pm_domain *genpd)
 	int iso, iso2sw;
 	u32 val;
 
-	if (pd->flags & PGC_DOMAIN_FLAG_NO_PD)
-		return -EBUSY;
-
 	/* Read ISO and ISO2SW power down delays */
 	regmap_read(pd->regmap, pd->reg_offs + GPC_PGC_PUPSCR_OFFS, &val);
 	iso = val & 0x3f;
@@ -418,8 +414,8 @@ static int imx_gpc_probe(struct platform_device *pdev)
 
 	/* Disable PU power down in normal operation if ERR009619 is present */
 	if (of_id_data->err009619_present)
-		imx_gpc_domains[GPC_PGC_DOMAIN_PU].flags |=
-				PGC_DOMAIN_FLAG_NO_PD;
+		imx_gpc_domains[GPC_PGC_DOMAIN_PU].base.flags |=
+				GENPD_FLAG_ALWAYS_ON;
 
 	/* Keep DISP always on if ERR006287 is present */
 	if (of_id_data->err006287_present)

commit 5507ec5126df5cad778af22b13fc8c278ad977ea
Author: Leonard Crestez <leonard.crestez@nxp.com>
Date:   Wed Jul 11 15:11:16 2018 +0300

    soc: imx: gpc: Disable 6sl display power gating for ERR006287
    
    The imx6sl chip errata document describes ERR006287 like this:
    
    > Upon resuming from power gating, the modules in the display power domain
    (eLCDIF, EPDC, PXP and SPDC) might fail to perform register reads
    correctly.
    
    > When the modules listed above are used, do not use power gating on the
    display power domain.
    
    Link: https://www.nxp.com/docs/en/errata/IMX6SLCE.pdf#page=62
    
    Handle this in the safest possible way by keeping the DISP domain
    always-on.
    
    Signed-off-by: Leonard Crestez <leonard.crestez@nxp.com>
    Reviewed-by: Lucas Stach <l.stach@pengutronix.de>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/drivers/soc/imx/gpc.c b/drivers/soc/imx/gpc.c
index 32f0748fd067..13ff983f8b69 100644
--- a/drivers/soc/imx/gpc.c
+++ b/drivers/soc/imx/gpc.c
@@ -288,26 +288,31 @@ static struct imx_pm_domain imx_gpc_domains[] = {
 struct imx_gpc_dt_data {
 	int num_domains;
 	bool err009619_present;
+	bool err006287_present;
 };
 
 static const struct imx_gpc_dt_data imx6q_dt_data = {
 	.num_domains = 2,
 	.err009619_present = false,
+	.err006287_present = false,
 };
 
 static const struct imx_gpc_dt_data imx6qp_dt_data = {
 	.num_domains = 2,
 	.err009619_present = true,
+	.err006287_present = false,
 };
 
 static const struct imx_gpc_dt_data imx6sl_dt_data = {
 	.num_domains = 3,
 	.err009619_present = false,
+	.err006287_present = true,
 };
 
 static const struct imx_gpc_dt_data imx6sx_dt_data = {
 	.num_domains = 4,
 	.err009619_present = false,
+	.err006287_present = false,
 };
 
 static const struct of_device_id imx_gpc_dt_ids[] = {
@@ -416,6 +421,11 @@ static int imx_gpc_probe(struct platform_device *pdev)
 		imx_gpc_domains[GPC_PGC_DOMAIN_PU].flags |=
 				PGC_DOMAIN_FLAG_NO_PD;
 
+	/* Keep DISP always on if ERR006287 is present */
+	if (of_id_data->err006287_present)
+		imx_gpc_domains[GPC_PGC_DOMAIN_DISPLAY].base.flags |=
+				GENPD_FLAG_ALWAYS_ON;
+
 	if (!pgc_node) {
 		ret = imx_gpc_old_dt_init(&pdev->dev, regmap,
 					  of_id_data->num_domains);

commit e88728f46cfbb59cc7e7acf1d230c05ec093764e
Author: Vivek Gautam <vivek.gautam@codeaurora.org>
Date:   Wed Jun 27 18:20:55 2018 +0530

    driver core: Rename flag AUTOREMOVE to AUTOREMOVE_CONSUMER
    
    Now that we want to add another flag to autoremove the device link
    on supplier unbind, it's fair to rename the existing flag from
    DL_FLAG_AUTOREMOVE to DL_FLAG_AUTOREMOVE_CONSUMER so that we can
    add similar flag for supplier later.
    And, while we are touching device.h, fix a doc build warning.
    
    Signed-off-by: Vivek Gautam <vivek.gautam@codeaurora.org>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/soc/imx/gpc.c b/drivers/soc/imx/gpc.c
index 32f0748fd067..aa9e65bc965e 100644
--- a/drivers/soc/imx/gpc.c
+++ b/drivers/soc/imx/gpc.c
@@ -202,7 +202,7 @@ static int imx_pgc_power_domain_probe(struct platform_device *pdev)
 			goto genpd_err;
 	}
 
-	device_link_add(dev, dev->parent, DL_FLAG_AUTOREMOVE);
+	device_link_add(dev, dev->parent, DL_FLAG_AUTOREMOVE_CONSUMER);
 
 	return 0;
 

commit f54e714cfc53b9164d1206f9ee49042195532a51
Author: Andrey Smirnov <andrew.smirnov@gmail.com>
Date:   Tue Apr 10 11:32:10 2018 -0700

    soc: imx: gpc: Do not pass static memory as platform data
    
    Platform device core assumes the ownership of dev.platform_data as
    well as that it is dynamically allocated and it will try to kfree it
    as a part of platform_device_release(). Change the code to use
    platform_device_add_data() instead of a pointer to a static memory to
    avoid causing a BUG() when calling platform_device_put().
    
    The problem can be reproduced by artificially enabling the error path
    of platform_device_add() call (around line 452).
    
    Cc: Stefan Agner <stefan@agner.ch>
    Cc: Lucas Stach <l.stach@pengutronix.de>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Andrey Smirnov <andrew.smirnov@gmail.com>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/drivers/soc/imx/gpc.c b/drivers/soc/imx/gpc.c
index c4d35f32af8d..32f0748fd067 100644
--- a/drivers/soc/imx/gpc.c
+++ b/drivers/soc/imx/gpc.c
@@ -443,17 +443,25 @@ static int imx_gpc_probe(struct platform_device *pdev)
 			if (domain_index >= of_id_data->num_domains)
 				continue;
 
-			domain = &imx_gpc_domains[domain_index];
-			domain->regmap = regmap;
-			domain->ipg_rate_mhz = ipg_rate_mhz;
-
 			pd_pdev = platform_device_alloc("imx-pgc-power-domain",
 							domain_index);
 			if (!pd_pdev) {
 				of_node_put(np);
 				return -ENOMEM;
 			}
-			pd_pdev->dev.platform_data = domain;
+
+			ret = platform_device_add_data(pd_pdev,
+						       &imx_gpc_domains[domain_index],
+						       sizeof(imx_gpc_domains[domain_index]));
+			if (ret) {
+				platform_device_put(pd_pdev);
+				of_node_put(np);
+				return ret;
+			}
+			domain = pd_pdev->dev.platform_data;
+			domain->regmap = regmap;
+			domain->ipg_rate_mhz = ipg_rate_mhz;
+
 			pd_pdev->dev.parent = &pdev->dev;
 			pd_pdev->dev.of_node = np;
 

commit 3bea9c5885d923ab6b231c55f2bf6acaf648e316
Merge: 697a3a873c2c f40a1e3705be
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu Mar 15 16:23:33 2018 +0100

    Merge tag 'imx-drivers-4.17' of ssh://gitolite.kernel.org/pub/scm/linux/kernel/git/shawnguo/linux into next/drivers
    
    Pull "i.MX drivers update for 4.17" from Shawn Guo:
    
     - Set GENPD_FLAG_ALWAYS_ON flag for ARM power domain to avoid incorrect
       power state in sysfs pm_genpd_summary output.
    
    * tag 'imx-drivers-4.17' of ssh://gitolite.kernel.org/pub/scm/linux/kernel/git/shawnguo/linux:
      soc: imx: gpc: ARM power domain should be always-on

commit 97ace515f01439d4cf6e898b4094040dc12d36e7
Merge: b5e792f11ada 8f148f32926c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Feb 28 16:11:04 2018 -0800

    Merge tag 'armsoc-fixes' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC fixes from Arnd Bergmann:
     "This is the first set of bugfixes for ARM SoCs, fixing a couple of
      stability problems, mostly on TI OMAP and Rockchips platforms:
    
       - OMAP2 hwmod clocks must be enabled in the correct order
    
       - OMAP3 Wakeup from resume through PRM IRQ was unreliable
    
       - one regression on OMAP5 caused by a kexec fix
    
       - Rockchip ethernet needs some settings for stable operation on
         Rock64
    
       - Rockchip based Chrombook Plus needs another clock setting for
         stable display suspend/resume
    
       - Rockchip based phyCORE-RK3288 was able to run at an invalid CPU
         clock frequency
    
       - Rockchip MMC link was sometimes unreliable
    
       - multiple fixes to avoid crashes in the Broadcom STB DPFE driver
    
      Other minor changes include:
    
       - Devicetree fixes for incorrect hardware description (rockchip,
         omap, Gemini, amlogic)
    
       - some MAINTAINER file updates to correct email and git addresses
    
       - some fixes addressing 'make W=1' dtc warnings (broadcom, amlogic,
         cavium, qualcomm, hisilicon, zx)
    
       - fixes for LTO-compilation (orion, davinci, clps711x)
    
       - one fix for an incorrect Kconfig errata selection
    
       - a memory leak in the OMAP timer driver
    
       - a kernel data leak in OMAP1 debugfs files"
    
    * tag 'armsoc-fixes' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (38 commits)
      MAINTAINERS: update entries for ARM/STM32
      ARM: dts: bcm283x: Move arm-pmu out of soc node
      ARM: dts: bcm283x: Fix unit address of local_intc
      ARM: dts: NSP: Fix amount of RAM on BCM958625HR
      ARM: dts: Set D-Link DNS-313 SATA to muxmode 0
      ARM: omap2: set CONFIG_LIRC=y in defconfig
      ARM: dts: imx6dl: Include correct dtsi file for Engicam i.CoreM6 DualLite/Solo RQS
      memory: brcmstb: dpfe: support new way of passing data from the DCPU
      memory: brcmstb: dpfe: fix type declaration of variable "ret"
      memory: brcmstb: dpfe: properly mask vendor error bits
      ARM: BCM: dts: Remove leading 0x and 0s from bindings notation
      ARM: orion: fix orion_ge00_switch_board_info initialization
      ARM: davinci: mark spi_board_info arrays as const
      ARM: clps711x: mark clps711x_compat as const
      arm: zx: dts: Remove leading 0x and 0s from bindings notation
      arm64: dts: Remove leading 0x and 0s from bindings notation
      arm64: dts: cavium: fix PCI bus dtc warnings
      MAINTAINERS: ARM: at91: update my email address
      soc: imx: gpc: de-register power domains only if initialized
      ARM: dts: rockchip: Fix DWMMC clocks
      ...

commit ed7158bae41044ff696e9aafd5ada46d391a5a2e
Author: Ingo Molnar <mingo@kernel.org>
Date:   Thu Feb 22 10:54:55 2018 +0100

    treewide/trivial: Remove ';;$' typo noise
    
    On lkml suggestions were made to split up such trivial typo fixes into per subsystem
    patches:
    
      --- a/arch/x86/boot/compressed/eboot.c
      +++ b/arch/x86/boot/compressed/eboot.c
      @@ -439,7 +439,7 @@ setup_uga32(void **uga_handle, unsigned long size, u32 *width, u32 *height)
              struct efi_uga_draw_protocol *uga = NULL, *first_uga;
              efi_guid_t uga_proto = EFI_UGA_PROTOCOL_GUID;
              unsigned long nr_ugas;
      -       u32 *handles = (u32 *)uga_handle;;
      +       u32 *handles = (u32 *)uga_handle;
              efi_status_t status = EFI_INVALID_PARAMETER;
              int i;
    
    This patch is the result of the following script:
    
      $ sed -i 's/;;$/;/g' $(git grep -E ';;$'  | grep "\.[ch]:"  | grep -vwE 'for|ia64' | cut -d: -f1 | sort | uniq)
    
    ... followed by manual review to make sure it's all good.
    
    Splitting this up is just crazy talk, let's get over with this and just do it.
    
    Reported-by: Pavel Machek <pavel@ucw.cz>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/soc/imx/gpc.c b/drivers/soc/imx/gpc.c
index 53f7275d6cbd..cfb42f5eccb2 100644
--- a/drivers/soc/imx/gpc.c
+++ b/drivers/soc/imx/gpc.c
@@ -348,7 +348,7 @@ static int imx_gpc_old_dt_init(struct device *dev, struct regmap *regmap,
 		if (i == 1) {
 			domain->supply = devm_regulator_get(dev, "pu");
 			if (IS_ERR(domain->supply))
-				return PTR_ERR(domain->supply);;
+				return PTR_ERR(domain->supply);
 
 			ret = imx_pgc_get_clocks(dev, domain);
 			if (ret)

commit 7801c545e706674aeed40256eb806ad37b18ad71
Author: Stefan Agner <stefan@agner.ch>
Date:   Sun Jan 7 14:49:05 2018 +0100

    soc: imx: gpc: de-register power domains only if initialized
    
    If power domain information are missing in the device tree, no
    power domains get initialized. However, imx_gpc_remove tries to
    remove power domains always in the old DT binding case. Only
    remove power domains when imx_gpc_probe initialized them in
    first place.
    
    Fixes: 721cabf6c660 ("soc: imx: move PGC handling to a new GPC driver")
    Signed-off-by: Stefan Agner <stefan@agner.ch>
    Reviewed-by: Lucas Stach <l.stach@pengutronix.de>
    Reviewed-by: Fabio Estevam <fabio.estevam@nxp.com>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/drivers/soc/imx/gpc.c b/drivers/soc/imx/gpc.c
index 53f7275d6cbd..62bb724726d9 100644
--- a/drivers/soc/imx/gpc.c
+++ b/drivers/soc/imx/gpc.c
@@ -470,13 +470,21 @@ static int imx_gpc_probe(struct platform_device *pdev)
 
 static int imx_gpc_remove(struct platform_device *pdev)
 {
+	struct device_node *pgc_node;
 	int ret;
 
+	pgc_node = of_get_child_by_name(pdev->dev.of_node, "pgc");
+
+	/* bail out if DT too old and doesn't provide the necessary info */
+	if (!of_property_read_bool(pdev->dev.of_node, "#power-domain-cells") &&
+	    !pgc_node)
+		return 0;
+
 	/*
 	 * If the old DT binding is used the toplevel driver needs to
 	 * de-register the power domains
 	 */
-	if (!of_get_child_by_name(pdev->dev.of_node, "pgc")) {
+	if (!pgc_node) {
 		of_genpd_del_provider(pdev->dev.of_node);
 
 		ret = pm_genpd_remove(&imx_gpc_domains[GPC_PGC_DOMAIN_PU].base);

commit f40a1e3705be23e845fbeec66acf3a6582524145
Author: Anson Huang <Anson.Huang@nxp.com>
Date:   Wed Jan 24 00:42:13 2018 +0800

    soc: imx: gpc: ARM power domain should be always-on
    
    ARM power domain does NOT support runtime off, always-on
    flag should be set to avoid incorrect power state in
    pm_genpd_summary:
    
    Before:
    
    root@imx6qpdlsolox:~# cat /sys/kernel/debug/pm_genpd/pm_genpd_summary
    domain                          status          slaves
        /device                                             runtime status
    ----------------------------------------------------------------------
    ARM                             off-0
    
    After:
    
    root@imx6qpdlsolox:~# cat /sys/kernel/debug/pm_genpd/pm_genpd_summary
    domain                          status          slaves
        /device                                             runtime status
    ----------------------------------------------------------------------
    ARM                             on
    
    Signed-off-by: Anson Huang <Anson.Huang@nxp.com>
    Reviewed-by: Lucas Stach <l.stach@pengutronix.de>
    Acked-by: Dong Aisheng <aisheng.dong@nxp.com>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/drivers/soc/imx/gpc.c b/drivers/soc/imx/gpc.c
index 53f7275d6cbd..6cafa9b60bc6 100644
--- a/drivers/soc/imx/gpc.c
+++ b/drivers/soc/imx/gpc.c
@@ -254,6 +254,7 @@ static struct imx_pm_domain imx_gpc_domains[] = {
 	{
 		.base = {
 			.name = "ARM",
+			.flags = GENPD_FLAG_ALWAYS_ON,
 		},
 	}, {
 		.base = {

commit cfabb7921ccbede2968e5049d433ba3d0e0950af
Author: Fabio Estevam <fabio.estevam@nxp.com>
Date:   Fri Dec 15 00:24:57 2017 -0200

    soc: imx: gpc: Add i.MX6SX PCI power domain
    
    i.MX6SX has a PCI power domain in PGC. Add support for it.
    
    Signed-off-by: Fabio Estevam <fabio.estevam@nxp.com>
    Acked-by: Lucas Stach <l.stach@pengutronix.de>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/drivers/soc/imx/gpc.c b/drivers/soc/imx/gpc.c
index 47e7aa963dbb..53f7275d6cbd 100644
--- a/drivers/soc/imx/gpc.c
+++ b/drivers/soc/imx/gpc.c
@@ -273,7 +273,15 @@ static struct imx_pm_domain imx_gpc_domains[] = {
 		},
 		.reg_offs = 0x240,
 		.cntr_pdn_bit = 4,
-	}
+	}, {
+		.base = {
+			.name = "PCI",
+			.power_off = imx6_pm_domain_power_off,
+			.power_on = imx6_pm_domain_power_on,
+		},
+		.reg_offs = 0x200,
+		.cntr_pdn_bit = 6,
+	},
 };
 
 struct imx_gpc_dt_data {
@@ -296,10 +304,16 @@ static const struct imx_gpc_dt_data imx6sl_dt_data = {
 	.err009619_present = false,
 };
 
+static const struct imx_gpc_dt_data imx6sx_dt_data = {
+	.num_domains = 4,
+	.err009619_present = false,
+};
+
 static const struct of_device_id imx_gpc_dt_ids[] = {
 	{ .compatible = "fsl,imx6q-gpc", .data = &imx6q_dt_data },
 	{ .compatible = "fsl,imx6qp-gpc", .data = &imx6qp_dt_data },
 	{ .compatible = "fsl,imx6sl-gpc", .data = &imx6sl_dt_data },
+	{ .compatible = "fsl,imx6sx-gpc", .data = &imx6sx_dt_data },
 	{ }
 };
 

commit 44c43c98213fb123819c67c128a5d6c9a9a12280
Author: Lucas Stach <l.stach@pengutronix.de>
Date:   Wed Apr 5 15:19:09 2017 +0200

    soc: imx: gpc: add workaround for i.MX6QP to the GPC PD driver
    
    On i.MX6QP, due to hardware erratum ERR009619, the PRE clocks may be
    stalled during the power up sequencing of the PU power domain. As this
    may lead to a complete loss of display output, the recommended
    workaround is to keep the PU domain enabled during normal system
    operation.
    
    Implement this by rejecting the domain power down request on the
    affected SoC.
    
    Signed-off-by: Lucas Stach <l.stach@pengutronix.de>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/drivers/soc/imx/gpc.c b/drivers/soc/imx/gpc.c
index d4ebb325b558..47e7aa963dbb 100644
--- a/drivers/soc/imx/gpc.c
+++ b/drivers/soc/imx/gpc.c
@@ -36,6 +36,8 @@
 
 #define GPC_CLK_MAX		6
 
+#define PGC_DOMAIN_FLAG_NO_PD		BIT(0)
+
 struct imx_pm_domain {
 	struct generic_pm_domain base;
 	struct regmap *regmap;
@@ -45,6 +47,7 @@ struct imx_pm_domain {
 	unsigned int reg_offs;
 	signed char cntr_pdn_bit;
 	unsigned int ipg_rate_mhz;
+	unsigned int flags;
 };
 
 static inline struct imx_pm_domain *
@@ -59,6 +62,9 @@ static int imx6_pm_domain_power_off(struct generic_pm_domain *genpd)
 	int iso, iso2sw;
 	u32 val;
 
+	if (pd->flags & PGC_DOMAIN_FLAG_NO_PD)
+		return -EBUSY;
+
 	/* Read ISO and ISO2SW power down delays */
 	regmap_read(pd->regmap, pd->reg_offs + GPC_PGC_PUPSCR_OFFS, &val);
 	iso = val & 0x3f;
@@ -272,18 +278,27 @@ static struct imx_pm_domain imx_gpc_domains[] = {
 
 struct imx_gpc_dt_data {
 	int num_domains;
+	bool err009619_present;
 };
 
 static const struct imx_gpc_dt_data imx6q_dt_data = {
 	.num_domains = 2,
+	.err009619_present = false,
+};
+
+static const struct imx_gpc_dt_data imx6qp_dt_data = {
+	.num_domains = 2,
+	.err009619_present = true,
 };
 
 static const struct imx_gpc_dt_data imx6sl_dt_data = {
 	.num_domains = 3,
+	.err009619_present = false,
 };
 
 static const struct of_device_id imx_gpc_dt_ids[] = {
 	{ .compatible = "fsl,imx6q-gpc", .data = &imx6q_dt_data },
+	{ .compatible = "fsl,imx6qp-gpc", .data = &imx6qp_dt_data },
 	{ .compatible = "fsl,imx6sl-gpc", .data = &imx6sl_dt_data },
 	{ }
 };
@@ -381,6 +396,11 @@ static int imx_gpc_probe(struct platform_device *pdev)
 		return ret;
 	}
 
+	/* Disable PU power down in normal operation if ERR009619 is present */
+	if (of_id_data->err009619_present)
+		imx_gpc_domains[GPC_PGC_DOMAIN_PU].flags |=
+				PGC_DOMAIN_FLAG_NO_PD;
+
 	if (!pgc_node) {
 		ret = imx_gpc_old_dt_init(&pdev->dev, regmap,
 					  of_id_data->num_domains);

commit 7c42af783ab817f40a8cfb9aef05b6fb92b780b3
Author: Lucas Stach <l.stach@pengutronix.de>
Date:   Wed Apr 5 15:19:07 2017 +0200

    soc: imx: gpc: add defines for domain index
    
    Makes referencing a specfic domain in the driver code
    less error prone.
    
    Signed-off-by: Lucas Stach <l.stach@pengutronix.de>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/drivers/soc/imx/gpc.c b/drivers/soc/imx/gpc.c
index 4294287e5f6c..d4ebb325b558 100644
--- a/drivers/soc/imx/gpc.c
+++ b/drivers/soc/imx/gpc.c
@@ -235,6 +235,10 @@ static struct platform_driver imx_pgc_power_domain_driver = {
 };
 builtin_platform_driver(imx_pgc_power_domain_driver)
 
+#define GPC_PGC_DOMAIN_ARM	0
+#define GPC_PGC_DOMAIN_PU	1
+#define GPC_PGC_DOMAIN_DISPLAY	2
+
 static struct genpd_power_state imx6_pm_domain_pu_state = {
 	.power_off_latency_ns = 25000,
 	.power_on_latency_ns = 2000000,
@@ -340,7 +344,7 @@ static int imx_gpc_old_dt_init(struct device *dev, struct regmap *regmap,
 genpd_err:
 	for (i = 0; i < num_domains; i++)
 		pm_genpd_remove(&imx_gpc_domains[i].base);
-	imx_pgc_put_clocks(&imx_gpc_domains[1]);
+	imx_pgc_put_clocks(&imx_gpc_domains[GPC_PGC_DOMAIN_PU]);
 clk_err:
 	return ret;
 }
@@ -441,12 +445,12 @@ static int imx_gpc_remove(struct platform_device *pdev)
 	if (!of_get_child_by_name(pdev->dev.of_node, "pgc")) {
 		of_genpd_del_provider(pdev->dev.of_node);
 
-		ret = pm_genpd_remove(&imx_gpc_domains[1].base);
+		ret = pm_genpd_remove(&imx_gpc_domains[GPC_PGC_DOMAIN_PU].base);
 		if (ret)
 			return ret;
-		imx_pgc_put_clocks(&imx_gpc_domains[1]);
+		imx_pgc_put_clocks(&imx_gpc_domains[GPC_PGC_DOMAIN_PU]);
 
-		ret = pm_genpd_remove(&imx_gpc_domains[0].base);
+		ret = pm_genpd_remove(&imx_gpc_domains[GPC_PGC_DOMAIN_ARM].base);
 		if (ret)
 			return ret;
 	}

commit bd01f064af2a5de4293c5401e01de5a6f951f4a5
Author: Dong Aisheng <aisheng.dong@nxp.com>
Date:   Thu Mar 23 12:53:25 2017 +0800

    soc: imx: gpc: remove unnecessary readable_reg callback
    
    It is not really necessary to provide the current .readable_reg
    implementation as we know what we're doing in our driver
    and the regmap core has already done the partial check for
    available maximum regs.
    
    Acked-by: Lucas Stach <l.stach@pengutronix.de>
    Signed-off-by: Dong Aisheng <aisheng.dong@nxp.com>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/drivers/soc/imx/gpc.c b/drivers/soc/imx/gpc.c
index 3c612487e0fd..4294287e5f6c 100644
--- a/drivers/soc/imx/gpc.c
+++ b/drivers/soc/imx/gpc.c
@@ -284,18 +284,10 @@ static const struct of_device_id imx_gpc_dt_ids[] = {
 	{ }
 };
 
-static bool imx_gpc_readable_reg(struct device *dev, unsigned int reg)
-{
-	return (reg % 4 == 0) && (reg <= 0x2ac);
-}
-
 static const struct regmap_config imx_gpc_regmap_config = {
 	.reg_bits = 32,
 	.val_bits = 32,
 	.reg_stride = 4,
-
-	.readable_reg = imx_gpc_readable_reg,
-
 	.max_register = 0x2ac,
 };
 

commit fbb0b4402a7132cd11cc3e63b12f543654bd1785
Author: Dong Aisheng <aisheng.dong@nxp.com>
Date:   Thu Mar 23 12:53:23 2017 +0800

    soc: imx: gpc: keep PGC_X_CTRL name align with reference manual
    
    Instead of GPC_PGC_PDN_OFFS, naming it as GPC_PGC_CTRL_OFFS which is
    defined in reference manual for better reading.
    
    Reviewed-by: Lucas Stach <l.stach@pengutronix.de>
    Signed-off-by: Dong Aisheng <aisheng.dong@nxp.com>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/drivers/soc/imx/gpc.c b/drivers/soc/imx/gpc.c
index afb02f9cc231..3c612487e0fd 100644
--- a/drivers/soc/imx/gpc.c
+++ b/drivers/soc/imx/gpc.c
@@ -21,7 +21,7 @@
 
 #define GPC_CNTR		0x000
 
-#define GPC_PGC_PDN_OFFS	0x0
+#define GPC_PGC_CTRL_OFFS	0x0
 #define GPC_PGC_PUPSCR_OFFS	0x4
 #define GPC_PGC_PDNSCR_OFFS	0x8
 #define GPC_PGC_SW2ISO_SHIFT	0x8
@@ -65,7 +65,7 @@ static int imx6_pm_domain_power_off(struct generic_pm_domain *genpd)
 	iso2sw = (val >> 8) & 0x3f;
 
 	/* Gate off domain when powered down */
-	regmap_update_bits(pd->regmap, pd->reg_offs + GPC_PGC_PDN_OFFS,
+	regmap_update_bits(pd->regmap, pd->reg_offs + GPC_PGC_CTRL_OFFS,
 			   0x1, 0x1);
 
 	/* Request GPC to power down domain */
@@ -101,7 +101,7 @@ static int imx6_pm_domain_power_on(struct generic_pm_domain *genpd)
 		clk_prepare_enable(pd->clk[i]);
 
 	/* Gate off domain when powered down */
-	regmap_update_bits(pd->regmap, pd->reg_offs + GPC_PGC_PDN_OFFS,
+	regmap_update_bits(pd->regmap, pd->reg_offs + GPC_PGC_CTRL_OFFS,
 			   0x1, 0x1);
 
 	/* Read ISO and ISO2SW power up delays */

commit 6e6e339cc185fdd27d476764637b5b3b6738cf04
Author: Dong Aisheng <aisheng.dong@nxp.com>
Date:   Thu Mar 23 12:53:22 2017 +0800

    soc: imx: gpc: fix comment when power up domain
    
    The correct comment should be power up domain.
    
    Reviewed-by: Lucas Stach <l.stach@pengutronix.de>
    Signed-off-by: Dong Aisheng <aisheng.dong@nxp.com>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/drivers/soc/imx/gpc.c b/drivers/soc/imx/gpc.c
index 9a2354ea48c9..afb02f9cc231 100644
--- a/drivers/soc/imx/gpc.c
+++ b/drivers/soc/imx/gpc.c
@@ -104,7 +104,7 @@ static int imx6_pm_domain_power_on(struct generic_pm_domain *genpd)
 	regmap_update_bits(pd->regmap, pd->reg_offs + GPC_PGC_PDN_OFFS,
 			   0x1, 0x1);
 
-	/* Read ISO and ISO2SW power down delays */
+	/* Read ISO and ISO2SW power up delays */
 	regmap_read(pd->regmap, pd->reg_offs + GPC_PGC_PUPSCR_OFFS, &val);
 	sw = val & 0x3f;
 	sw2iso = (val >> 8) & 0x3f;

commit 5a42d1198901a13ff46e1d13b91a338d74224dbe
Author: Dong Aisheng <aisheng.dong@nxp.com>
Date:   Thu Mar 23 12:53:21 2017 +0800

    soc: imx: gpc: fix imx6sl gpc power domain regression
    
    Commit 721cabf6c660 ("soc: imx: move PGC handling to a new GPC driver")
    broke the MX6SL GPC power domain support.
    It always got the following error:
    [    1.248364] imx-gpc 20dc000.gpc: could not find pgc DT node
    This patch adds back the legecy support.
    
    Fixes: 721cabf6c660 ("soc: imx: move PGC handling to a new GPC driver")
    Signed-off-by: Dong Aisheng <aisheng.dong@nxp.com>
    Reviewed-by: Lucas Stach <l.stach@pengutronix.de>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/drivers/soc/imx/gpc.c b/drivers/soc/imx/gpc.c
index ba6e7ab2c240..9a2354ea48c9 100644
--- a/drivers/soc/imx/gpc.c
+++ b/drivers/soc/imx/gpc.c
@@ -309,12 +309,13 @@ static struct genpd_onecell_data imx_gpc_onecell_data = {
 	.num_domains = 2,
 };
 
-static int imx_gpc_old_dt_init(struct device *dev, struct regmap *regmap)
+static int imx_gpc_old_dt_init(struct device *dev, struct regmap *regmap,
+			       unsigned int num_domains)
 {
 	struct imx_pm_domain *domain;
 	int i, ret;
 
-	for (i = 0; i < 2; i++) {
+	for (i = 0; i < num_domains; i++) {
 		domain = &imx_gpc_domains[i];
 		domain->regmap = regmap;
 		domain->ipg_rate_mhz = 66;
@@ -332,7 +333,7 @@ static int imx_gpc_old_dt_init(struct device *dev, struct regmap *regmap)
 		}
 	}
 
-	for (i = 0; i < 2; i++)
+	for (i = 0; i < num_domains; i++)
 		pm_genpd_init(&imx_gpc_domains[i].base, NULL, false);
 
 	if (IS_ENABLED(CONFIG_PM_GENERIC_DOMAINS)) {
@@ -345,7 +346,7 @@ static int imx_gpc_old_dt_init(struct device *dev, struct regmap *regmap)
 	return 0;
 
 genpd_err:
-	for (i = 0; i < 2; i++)
+	for (i = 0; i < num_domains; i++)
 		pm_genpd_remove(&imx_gpc_domains[i].base);
 	imx_pgc_put_clocks(&imx_gpc_domains[1]);
 clk_err:
@@ -385,13 +386,8 @@ static int imx_gpc_probe(struct platform_device *pdev)
 	}
 
 	if (!pgc_node) {
-		/* old DT layout is only supported for mx6q aka 2 domains */
-		if (of_id_data->num_domains != 2) {
-			dev_err(&pdev->dev, "could not find pgc DT node\n");
-			return -ENODEV;
-		}
-
-		ret = imx_gpc_old_dt_init(&pdev->dev, regmap);
+		ret = imx_gpc_old_dt_init(&pdev->dev, regmap,
+					  of_id_data->num_domains);
 		if (ret)
 			return ret;
 	} else {

commit 15c3de4e188b567ab60dbff674002a7f4380af6a
Author: Dong Aisheng <aisheng.dong@nxp.com>
Date:   Thu Mar 23 12:53:20 2017 +0800

    soc: imx: gpc: fix domain_index sanity check issue
    
    ARRAY_SIZE(imx_gpc_domains) represents all power domains supported
    by different SoCs. Driver should use SoC specific of_id_data->num_domains
    instead to do power domain index sanity check.
    e.g. MX6Q supports two power domains while MX6SL supports three.
    
    Fixes: 721cabf6c660 ("soc: imx: move PGC handling to a new GPC driver")
    Acked-by: Lucas Stach <l.stach@pengutronix.de>
    Signed-off-by: Dong Aisheng <aisheng.dong@nxp.com>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/drivers/soc/imx/gpc.c b/drivers/soc/imx/gpc.c
index 7e6a672bf5f4..ba6e7ab2c240 100644
--- a/drivers/soc/imx/gpc.c
+++ b/drivers/soc/imx/gpc.c
@@ -413,7 +413,7 @@ static int imx_gpc_probe(struct platform_device *pdev)
 				of_node_put(np);
 				return ret;
 			}
-			if (domain_index >= ARRAY_SIZE(imx_gpc_domains))
+			if (domain_index >= of_id_data->num_domains)
 				continue;
 
 			domain = &imx_gpc_domains[domain_index];

commit 3a317f523570adfc9c5bf6d65dc4f831dada97b9
Author: Dong Aisheng <aisheng.dong@nxp.com>
Date:   Thu Mar 23 12:53:19 2017 +0800

    soc: imx: gpc: fix the wrong using of regmap cache
    
    Without providing the proper reg_defaults, the regmap registers first
    read out may be always 0 if enabling cache, which results in the
    following issue we met.
    e.g. During driver probe in imx6_pm_domain_power_on():
    regmap_read(pd->regmap, pd->reg_offs + GPC_PGC_PUPSCR_OFFS, &val);
    The PGC_PUPSCR register val is always 0 but it's actually 0xf01 in HW.
    
    Since GPC registers are tightly related to CPU bring up and may be
    changed in bootloader, we don't want to provide defaults.
    And the cache really does not save too much for GPC module.
    
    Therefore, simply disable cache to fix the issue and make life easy.
    
    Reviewed-by: Lucas Stach <l.stach@pengutronix.de>
    Fixes: 721cabf6c660 ("soc: imx: move PGC handling to a new GPC driver")
    Signed-off-by: Dong Aisheng <aisheng.dong@nxp.com>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/drivers/soc/imx/gpc.c b/drivers/soc/imx/gpc.c
index c9bfdfd783d0..7e6a672bf5f4 100644
--- a/drivers/soc/imx/gpc.c
+++ b/drivers/soc/imx/gpc.c
@@ -289,22 +289,12 @@ static bool imx_gpc_readable_reg(struct device *dev, unsigned int reg)
 	return (reg % 4 == 0) && (reg <= 0x2ac);
 }
 
-static bool imx_gpc_volatile_reg(struct device *dev, unsigned int reg)
-{
-	if (reg == GPC_CNTR)
-		return true;
-
-	return false;
-}
-
 static const struct regmap_config imx_gpc_regmap_config = {
-	.cache_type = REGCACHE_FLAT,
 	.reg_bits = 32,
 	.val_bits = 32,
 	.reg_stride = 4,
 
 	.readable_reg = imx_gpc_readable_reg,
-	.volatile_reg = imx_gpc_volatile_reg,
 
 	.max_register = 0x2ac,
 };

commit 55b0baa2542f1dbaf33989eab5a26a23a8aca345
Author: Dong Aisheng <aisheng.dong@nxp.com>
Date:   Thu Mar 23 12:53:18 2017 +0800

    soc: imx: gpc: fix gpc clk get error handling
    
    We got a following kernel crash once supplying one more IPG
    clock in GPC node in devicetree. The original error handling of
    clocks get is a bit wrong that when reaching the maximum clock
    get error, the index 'i' is already GPC_CLK_MAX which can't be used
    as the array index for clk_put operations.
    
    [    3.000110] imx-gpc 20dc000.gpc: more than 6 clocks
    [    3.005141] Unable to handle kernel NULL pointer dereference at virtual address 00000000
    [    3.013487] pgd = c0004000
    [    3.016300] [00000000] *pgd=00000000
    [    3.020060] Internal error: Oops: 805 [#1] SMP ARM
    [    3.024957] Modules linked in:
    [    3.028122] CPU: 0 PID: 1 Comm: swapper/0 Tainted: G        W       4.11.0-rc1-00056-g813791b-dirty #1140
    [    3.037801] Hardware name: Freescale i.MX6 Quad/DualLite (Device Tree)
    [    3.044435] task: ef298000 task.stack: ef294000
    [    3.049080] PC is at __clk_put+0x38/0xec
    [    3.053103] LR is at 0x7f54ce9a
    [    3.056345] pc : [<c0537984>]    lr : [<7f54ce9a>]    psr: 60000013
    [    3.056345] sp : ef295d48  ip : c8a582b2  fp : ef295d64
    [    3.068026] r10: ee9fc400  r9 : 00000000  r8 : ef398c10
    [    3.073354] r7 : ef398c10  r6 : c1071264  r5 : c10710f0  r4 : eea5be80
    [    3.079986] r3 : 00000000  r2 : 00000000  r1 : 00000100  r0 : 00000001
    [    3.086621] Flags: nZCv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment none
    [    3.093863] Control: 10c5387d  Table: 1000404a  DAC: 00000051
    [    3.099712] Process swapper/0 (pid: 1, stack limit = 0xef294210)
    [    3.105823] Stack: (0xef295d48 to 0xef296000)
    ...
    [    3.292660] Backtrace:
    [    3.295222] [<c053794c>] (__clk_put) from [<c0531028>] (clk_put+0x18/0x1c)
    [    3.302206]  r6:c1071264 r5:c10710f0 r4:c107124c r3:00000001
    [    3.307977] [<c0531010>] (clk_put) from [<c0546ba0>] (imx_pgc_get_clocks+0x64/0x78)
    [    3.315747] [<c0546b3c>] (imx_pgc_get_clocks) from [<c0547124>] (imx_gpc_probe+0x204/0x31c)
    [    3.324209]  r7:00000000 r6:c1070eb0 r5:00000001 r4:ef398c00
    [    3.329980] [<c0546f20>] (imx_gpc_probe) from [<c05e65f0>] (platform_drv_probe+0x5c/0xc0)
    [    3.338270]  r10:c0f00608 r9:00000000 r8:00000000 r7:fffffdfb r6:c1070f20 r5:ef398c10
    [    3.346207]  r4:ef398c10
    [    3.348849] [<c05e6594>] (platform_drv_probe) from [<c05e4250>] (driver_probe_device+0x214/0x2ec)
    [    3.357835]  r7:c1070f20 r6:00000000 r5:c18cea74 r4:ef398c10
    [    3.363607] [<c05e403c>] (driver_probe_device) from [<c05e43ec>] (__driver_attach+0xc4/0xc8)
    [    3.372159]  r9:c0f8b858 r8:c0f8b850 r7:00000000 r6:ef398c44 r5:c1070f20 r4:ef398c10
    [    3.380017] [<c05e4328>] (__driver_attach) from [<c05e21fc>] (bus_for_each_dev+0x7c/0xb0)
    [    3.388304]  r6:c05e4328 r5:c1070f20 r4:00000000 r3:00000000
    [    3.394074] [<c05e2180>] (bus_for_each_dev) from [<c05e3bc4>] (driver_attach+0x28/0x30)
    [    3.402188]  r6:c107f3e8 r5:eea5be00 r4:c1070f20
    [    3.406913] [<c05e3b9c>] (driver_attach) from [<c05e3740>] (bus_add_driver+0x19c/0x224)
    [    3.415034] [<c05e35a4>] (bus_add_driver) from [<c05e52fc>] (driver_register+0x88/0x108)
    [    3.423235]  r7:c10e1000 r6:00000000 r5:c0f57d2c r4:c1070f20
    [    3.429004] [<c05e5274>] (driver_register) from [<c05e6534>] (__platform_driver_register+0x40/0x54)
    [    3.438160]  r5:c0f57d2c r4:00000006
    [    3.441846] [<c05e64f4>] (__platform_driver_register) from [<c0f57d44>] (imx_gpc_driver_init+0x18/0x20)
    [    3.451360] [<c0f57d2c>] (imx_gpc_driver_init) from [<c010200c>] (do_one_initcall+0x4c/0x180)
    [    3.460008] [<c0101fc0>] (do_one_initcall) from [<c0f00e40>] (kernel_init_freeable+0x130/0x1f8)
    [    3.468820]  r9:c0f8b858 r8:c0f8b850 r6:c0fc2414 r5:c10e1000 r4:00000006
    [    3.475637] [<c0f00d10>] (kernel_init_freeable) from [<c0ae6aec>] (kernel_init+0x18/0x124)
    [    3.484014]  r10:00000000 r9:00000000 r8:00000000 r7:00000000 r6:00000000 r5:c0ae6ad4
    [    3.491951]  r4:00000000
    [    3.494590] [<c0ae6ad4>] (kernel_init) from [<c01088d0>] (ret_from_fork+0x14/0x24)
    [    3.502267]  r4:00000000 r3:ef294000
    [    3.505947] Code: e5943014 e5942018 e3530000 e3a01c01 (e5823000)
    [    3.512215] ---[ end trace 375f9f2a5ddeff3c ]---
    [    3.517036] Kernel panic - not syncing: Attempted to kill init! exitcode=0x0000000b
    
    Cc: Lucas Stach <l.stach@pengutronix.de>
    Fixes: 721cabf6c660 ("soc: imx: move PGC handling to a new GPC driver")
    Signed-off-by: Dong Aisheng <aisheng.dong@nxp.com>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/drivers/soc/imx/gpc.c b/drivers/soc/imx/gpc.c
index 1e9b3b81f466..c9bfdfd783d0 100644
--- a/drivers/soc/imx/gpc.c
+++ b/drivers/soc/imx/gpc.c
@@ -143,7 +143,7 @@ static int imx_pgc_get_clocks(struct device *dev, struct imx_pm_domain *domain)
 	return 0;
 
 clk_err:
-	for (; i >= 0; i--)
+	while (i--)
 		clk_put(domain->clk[i]);
 
 	return ret;

commit 721cabf6c6600dbe689ee2782bc087270e97e652
Author: Lucas Stach <l.stach@pengutronix.de>
Date:   Fri Feb 17 20:02:44 2017 +0100

    soc: imx: move PGC handling to a new GPC driver
    
    This is an almost complete re-write of the previous GPC power gating control
    code found in the IMX architecture code. It supports both the old and the new
    DT binding, allowing more domains to be added later and generally makes the
    driver easier to extend, while keeping compatibility with existing DTBs.
    
    As the result, all functionality regarding the power gating controller
    gets removed from the IMX architecture GPC driver.  It keeps only the
    IRQ controller code in the architecture, as this is closely coupled to
    the CPU idle implementation.
    
    Signed-off-by: Lucas Stach <l.stach@pengutronix.de>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/drivers/soc/imx/gpc.c b/drivers/soc/imx/gpc.c
new file mode 100644
index 000000000000..1e9b3b81f466
--- /dev/null
+++ b/drivers/soc/imx/gpc.c
@@ -0,0 +1,487 @@
+/*
+ * Copyright 2015-2017 Pengutronix, Lucas Stach <kernel@pengutronix.de>
+ * Copyright 2011-2013 Freescale Semiconductor, Inc.
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/pm_domain.h>
+#include <linux/regmap.h>
+#include <linux/regulator/consumer.h>
+
+#define GPC_CNTR		0x000
+
+#define GPC_PGC_PDN_OFFS	0x0
+#define GPC_PGC_PUPSCR_OFFS	0x4
+#define GPC_PGC_PDNSCR_OFFS	0x8
+#define GPC_PGC_SW2ISO_SHIFT	0x8
+#define GPC_PGC_SW_SHIFT	0x0
+
+#define GPC_PGC_GPU_PDN		0x260
+#define GPC_PGC_GPU_PUPSCR	0x264
+#define GPC_PGC_GPU_PDNSCR	0x268
+
+#define GPU_VPU_PUP_REQ		BIT(1)
+#define GPU_VPU_PDN_REQ		BIT(0)
+
+#define GPC_CLK_MAX		6
+
+struct imx_pm_domain {
+	struct generic_pm_domain base;
+	struct regmap *regmap;
+	struct regulator *supply;
+	struct clk *clk[GPC_CLK_MAX];
+	int num_clks;
+	unsigned int reg_offs;
+	signed char cntr_pdn_bit;
+	unsigned int ipg_rate_mhz;
+};
+
+static inline struct imx_pm_domain *
+to_imx_pm_domain(struct generic_pm_domain *genpd)
+{
+	return container_of(genpd, struct imx_pm_domain, base);
+}
+
+static int imx6_pm_domain_power_off(struct generic_pm_domain *genpd)
+{
+	struct imx_pm_domain *pd = to_imx_pm_domain(genpd);
+	int iso, iso2sw;
+	u32 val;
+
+	/* Read ISO and ISO2SW power down delays */
+	regmap_read(pd->regmap, pd->reg_offs + GPC_PGC_PUPSCR_OFFS, &val);
+	iso = val & 0x3f;
+	iso2sw = (val >> 8) & 0x3f;
+
+	/* Gate off domain when powered down */
+	regmap_update_bits(pd->regmap, pd->reg_offs + GPC_PGC_PDN_OFFS,
+			   0x1, 0x1);
+
+	/* Request GPC to power down domain */
+	val = BIT(pd->cntr_pdn_bit);
+	regmap_update_bits(pd->regmap, GPC_CNTR, val, val);
+
+	/* Wait ISO + ISO2SW IPG clock cycles */
+	udelay(DIV_ROUND_UP(iso + iso2sw, pd->ipg_rate_mhz));
+
+	if (pd->supply)
+		regulator_disable(pd->supply);
+
+	return 0;
+}
+
+static int imx6_pm_domain_power_on(struct generic_pm_domain *genpd)
+{
+	struct imx_pm_domain *pd = to_imx_pm_domain(genpd);
+	int i, ret, sw, sw2iso;
+	u32 val;
+
+	if (pd->supply) {
+		ret = regulator_enable(pd->supply);
+		if (ret) {
+			pr_err("%s: failed to enable regulator: %d\n",
+			       __func__, ret);
+			return ret;
+		}
+	}
+
+	/* Enable reset clocks for all devices in the domain */
+	for (i = 0; i < pd->num_clks; i++)
+		clk_prepare_enable(pd->clk[i]);
+
+	/* Gate off domain when powered down */
+	regmap_update_bits(pd->regmap, pd->reg_offs + GPC_PGC_PDN_OFFS,
+			   0x1, 0x1);
+
+	/* Read ISO and ISO2SW power down delays */
+	regmap_read(pd->regmap, pd->reg_offs + GPC_PGC_PUPSCR_OFFS, &val);
+	sw = val & 0x3f;
+	sw2iso = (val >> 8) & 0x3f;
+
+	/* Request GPC to power up domain */
+	val = BIT(pd->cntr_pdn_bit + 1);
+	regmap_update_bits(pd->regmap, GPC_CNTR, val, val);
+
+	/* Wait ISO + ISO2SW IPG clock cycles */
+	udelay(DIV_ROUND_UP(sw + sw2iso, pd->ipg_rate_mhz));
+
+	/* Disable reset clocks for all devices in the domain */
+	for (i = 0; i < pd->num_clks; i++)
+		clk_disable_unprepare(pd->clk[i]);
+
+	return 0;
+}
+
+static int imx_pgc_get_clocks(struct device *dev, struct imx_pm_domain *domain)
+{
+	int i, ret;
+
+	for (i = 0; ; i++) {
+		struct clk *clk = of_clk_get(dev->of_node, i);
+		if (IS_ERR(clk))
+			break;
+		if (i >= GPC_CLK_MAX) {
+			dev_err(dev, "more than %d clocks\n", GPC_CLK_MAX);
+			ret = -EINVAL;
+			goto clk_err;
+		}
+		domain->clk[i] = clk;
+	}
+	domain->num_clks = i;
+
+	return 0;
+
+clk_err:
+	for (; i >= 0; i--)
+		clk_put(domain->clk[i]);
+
+	return ret;
+}
+
+static void imx_pgc_put_clocks(struct imx_pm_domain *domain)
+{
+	int i;
+
+	for (i = domain->num_clks - 1; i >= 0; i--)
+		clk_put(domain->clk[i]);
+}
+
+static int imx_pgc_parse_dt(struct device *dev, struct imx_pm_domain *domain)
+{
+	/* try to get the domain supply regulator */
+	domain->supply = devm_regulator_get_optional(dev, "power");
+	if (IS_ERR(domain->supply)) {
+		if (PTR_ERR(domain->supply) == -ENODEV)
+			domain->supply = NULL;
+		else
+			return PTR_ERR(domain->supply);
+	}
+
+	/* try to get all clocks needed for reset propagation */
+	return imx_pgc_get_clocks(dev, domain);
+}
+
+static int imx_pgc_power_domain_probe(struct platform_device *pdev)
+{
+	struct imx_pm_domain *domain = pdev->dev.platform_data;
+	struct device *dev = &pdev->dev;
+	int ret;
+
+	/* if this PD is associated with a DT node try to parse it */
+	if (dev->of_node) {
+		ret = imx_pgc_parse_dt(dev, domain);
+		if (ret)
+			return ret;
+	}
+
+	/* initially power on the domain */
+	if (domain->base.power_on)
+		domain->base.power_on(&domain->base);
+
+	if (IS_ENABLED(CONFIG_PM_GENERIC_DOMAINS)) {
+		pm_genpd_init(&domain->base, NULL, false);
+		ret = of_genpd_add_provider_simple(dev->of_node, &domain->base);
+		if (ret)
+			goto genpd_err;
+	}
+
+	device_link_add(dev, dev->parent, DL_FLAG_AUTOREMOVE);
+
+	return 0;
+
+genpd_err:
+	pm_genpd_remove(&domain->base);
+	imx_pgc_put_clocks(domain);
+
+	return ret;
+}
+
+static int imx_pgc_power_domain_remove(struct platform_device *pdev)
+{
+	struct imx_pm_domain *domain = pdev->dev.platform_data;
+
+	if (IS_ENABLED(CONFIG_PM_GENERIC_DOMAINS)) {
+		of_genpd_del_provider(pdev->dev.of_node);
+		pm_genpd_remove(&domain->base);
+		imx_pgc_put_clocks(domain);
+	}
+
+	return 0;
+}
+
+static const struct platform_device_id imx_pgc_power_domain_id[] = {
+	{ "imx-pgc-power-domain"},
+	{ },
+};
+
+static struct platform_driver imx_pgc_power_domain_driver = {
+	.driver = {
+		.name = "imx-pgc-pd",
+	},
+	.probe = imx_pgc_power_domain_probe,
+	.remove = imx_pgc_power_domain_remove,
+	.id_table = imx_pgc_power_domain_id,
+};
+builtin_platform_driver(imx_pgc_power_domain_driver)
+
+static struct genpd_power_state imx6_pm_domain_pu_state = {
+	.power_off_latency_ns = 25000,
+	.power_on_latency_ns = 2000000,
+};
+
+static struct imx_pm_domain imx_gpc_domains[] = {
+	{
+		.base = {
+			.name = "ARM",
+		},
+	}, {
+		.base = {
+			.name = "PU",
+			.power_off = imx6_pm_domain_power_off,
+			.power_on = imx6_pm_domain_power_on,
+			.states = &imx6_pm_domain_pu_state,
+			.state_count = 1,
+		},
+		.reg_offs = 0x260,
+		.cntr_pdn_bit = 0,
+	}, {
+		.base = {
+			.name = "DISPLAY",
+			.power_off = imx6_pm_domain_power_off,
+			.power_on = imx6_pm_domain_power_on,
+		},
+		.reg_offs = 0x240,
+		.cntr_pdn_bit = 4,
+	}
+};
+
+struct imx_gpc_dt_data {
+	int num_domains;
+};
+
+static const struct imx_gpc_dt_data imx6q_dt_data = {
+	.num_domains = 2,
+};
+
+static const struct imx_gpc_dt_data imx6sl_dt_data = {
+	.num_domains = 3,
+};
+
+static const struct of_device_id imx_gpc_dt_ids[] = {
+	{ .compatible = "fsl,imx6q-gpc", .data = &imx6q_dt_data },
+	{ .compatible = "fsl,imx6sl-gpc", .data = &imx6sl_dt_data },
+	{ }
+};
+
+static bool imx_gpc_readable_reg(struct device *dev, unsigned int reg)
+{
+	return (reg % 4 == 0) && (reg <= 0x2ac);
+}
+
+static bool imx_gpc_volatile_reg(struct device *dev, unsigned int reg)
+{
+	if (reg == GPC_CNTR)
+		return true;
+
+	return false;
+}
+
+static const struct regmap_config imx_gpc_regmap_config = {
+	.cache_type = REGCACHE_FLAT,
+	.reg_bits = 32,
+	.val_bits = 32,
+	.reg_stride = 4,
+
+	.readable_reg = imx_gpc_readable_reg,
+	.volatile_reg = imx_gpc_volatile_reg,
+
+	.max_register = 0x2ac,
+};
+
+static struct generic_pm_domain *imx_gpc_onecell_domains[] = {
+	&imx_gpc_domains[0].base,
+	&imx_gpc_domains[1].base,
+};
+
+static struct genpd_onecell_data imx_gpc_onecell_data = {
+	.domains = imx_gpc_onecell_domains,
+	.num_domains = 2,
+};
+
+static int imx_gpc_old_dt_init(struct device *dev, struct regmap *regmap)
+{
+	struct imx_pm_domain *domain;
+	int i, ret;
+
+	for (i = 0; i < 2; i++) {
+		domain = &imx_gpc_domains[i];
+		domain->regmap = regmap;
+		domain->ipg_rate_mhz = 66;
+
+		if (i == 1) {
+			domain->supply = devm_regulator_get(dev, "pu");
+			if (IS_ERR(domain->supply))
+				return PTR_ERR(domain->supply);;
+
+			ret = imx_pgc_get_clocks(dev, domain);
+			if (ret)
+				goto clk_err;
+
+			domain->base.power_on(&domain->base);
+		}
+	}
+
+	for (i = 0; i < 2; i++)
+		pm_genpd_init(&imx_gpc_domains[i].base, NULL, false);
+
+	if (IS_ENABLED(CONFIG_PM_GENERIC_DOMAINS)) {
+		ret = of_genpd_add_provider_onecell(dev->of_node,
+						    &imx_gpc_onecell_data);
+		if (ret)
+			goto genpd_err;
+	}
+
+	return 0;
+
+genpd_err:
+	for (i = 0; i < 2; i++)
+		pm_genpd_remove(&imx_gpc_domains[i].base);
+	imx_pgc_put_clocks(&imx_gpc_domains[1]);
+clk_err:
+	return ret;
+}
+
+static int imx_gpc_probe(struct platform_device *pdev)
+{
+	const struct of_device_id *of_id =
+			of_match_device(imx_gpc_dt_ids, &pdev->dev);
+	const struct imx_gpc_dt_data *of_id_data = of_id->data;
+	struct device_node *pgc_node;
+	struct regmap *regmap;
+	struct resource *res;
+	void __iomem *base;
+	int ret;
+
+	pgc_node = of_get_child_by_name(pdev->dev.of_node, "pgc");
+
+	/* bail out if DT too old and doesn't provide the necessary info */
+	if (!of_property_read_bool(pdev->dev.of_node, "#power-domain-cells") &&
+	    !pgc_node)
+		return 0;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(base))
+		return PTR_ERR(base);
+
+	regmap = devm_regmap_init_mmio_clk(&pdev->dev, NULL, base,
+					   &imx_gpc_regmap_config);
+	if (IS_ERR(regmap)) {
+		ret = PTR_ERR(regmap);
+		dev_err(&pdev->dev, "failed to init regmap: %d\n",
+			ret);
+		return ret;
+	}
+
+	if (!pgc_node) {
+		/* old DT layout is only supported for mx6q aka 2 domains */
+		if (of_id_data->num_domains != 2) {
+			dev_err(&pdev->dev, "could not find pgc DT node\n");
+			return -ENODEV;
+		}
+
+		ret = imx_gpc_old_dt_init(&pdev->dev, regmap);
+		if (ret)
+			return ret;
+	} else {
+		struct imx_pm_domain *domain;
+		struct platform_device *pd_pdev;
+		struct device_node *np;
+		struct clk *ipg_clk;
+		unsigned int ipg_rate_mhz;
+		int domain_index;
+
+		ipg_clk = devm_clk_get(&pdev->dev, "ipg");
+		if (IS_ERR(ipg_clk))
+			return PTR_ERR(ipg_clk);
+		ipg_rate_mhz = clk_get_rate(ipg_clk) / 1000000;
+
+		for_each_child_of_node(pgc_node, np) {
+			ret = of_property_read_u32(np, "reg", &domain_index);
+			if (ret) {
+				of_node_put(np);
+				return ret;
+			}
+			if (domain_index >= ARRAY_SIZE(imx_gpc_domains))
+				continue;
+
+			domain = &imx_gpc_domains[domain_index];
+			domain->regmap = regmap;
+			domain->ipg_rate_mhz = ipg_rate_mhz;
+
+			pd_pdev = platform_device_alloc("imx-pgc-power-domain",
+							domain_index);
+			if (!pd_pdev) {
+				of_node_put(np);
+				return -ENOMEM;
+			}
+			pd_pdev->dev.platform_data = domain;
+			pd_pdev->dev.parent = &pdev->dev;
+			pd_pdev->dev.of_node = np;
+
+			ret = platform_device_add(pd_pdev);
+			if (ret) {
+				platform_device_put(pd_pdev);
+				of_node_put(np);
+				return ret;
+			}
+		}
+	}
+
+	return 0;
+}
+
+static int imx_gpc_remove(struct platform_device *pdev)
+{
+	int ret;
+
+	/*
+	 * If the old DT binding is used the toplevel driver needs to
+	 * de-register the power domains
+	 */
+	if (!of_get_child_by_name(pdev->dev.of_node, "pgc")) {
+		of_genpd_del_provider(pdev->dev.of_node);
+
+		ret = pm_genpd_remove(&imx_gpc_domains[1].base);
+		if (ret)
+			return ret;
+		imx_pgc_put_clocks(&imx_gpc_domains[1]);
+
+		ret = pm_genpd_remove(&imx_gpc_domains[0].base);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+static struct platform_driver imx_gpc_driver = {
+	.driver = {
+		.name = "imx-gpc",
+		.of_match_table = imx_gpc_dt_ids,
+	},
+	.probe = imx_gpc_probe,
+	.remove = imx_gpc_remove,
+};
+builtin_platform_driver(imx_gpc_driver)
