commit f10e58a5d20e1cf3a39a842da92c9dd0c3c23849
Author: Leonard Crestez <leonard.crestez@nxp.com>
Date:   Thu Feb 20 18:29:39 2020 +0200

    soc: imx-scu: Align imx sc msg structs to 4
    
    The imx SC api strongly assumes that messages are composed out of
    4-bytes words but some of our message structs have odd sizeofs.
    
    This produces many oopses with CONFIG_KASAN=y.
    
    Fix by marking with __aligned(4).
    
    Fixes: 73feb4d0f8f1 ("soc: imx-scu: Add SoC UID(unique identifier) support")
    Signed-off-by: Leonard Crestez <leonard.crestez@nxp.com>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/drivers/soc/imx/soc-imx-scu.c b/drivers/soc/imx/soc-imx-scu.c
index fb70b8a3f7c5..20d37eaeb5f2 100644
--- a/drivers/soc/imx/soc-imx-scu.c
+++ b/drivers/soc/imx/soc-imx-scu.c
@@ -25,7 +25,7 @@ struct imx_sc_msg_misc_get_soc_id {
 			u32 id;
 		} resp;
 	} data;
-} __packed;
+} __packed __aligned(4);
 
 struct imx_sc_msg_misc_get_soc_uid {
 	struct imx_sc_rpc_msg hdr;

commit ec939e4c94bd3ef2fd4f34c15f8aaf79bd0c5ee1
Merge: 38206c24ab09 3f6939aec712
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Dec 5 11:43:31 2019 -0800

    Merge tag 'armsoc-drivers' of git://git.kernel.org/pub/scm/linux/kernel/git/soc/soc
    
    Pull ARM SoC driver updates from Olof Johansson:
     "Various driver updates for platforms:
    
       - A larger set of work on Tegra 2/3 around memory controller and
         regulator features, some fuse cleanups, etc..
    
       - MMP platform drivers, in particular for USB PHY, and other smaller
         additions.
    
       - Samsung Exynos 5422 driver for DMC (dynamic memory configuration),
         and ASV (adaptive voltage), allowing the platform to run at more
         optimal operating points.
    
       - Misc refactorings and support for RZ/G2N and R8A774B1 from Renesas
    
       - Clock/reset control driver for TI/OMAP
    
       - Meson-A1 reset controller support
    
       - Qualcomm sdm845 and sda845 SoC IDs for socinfo"
    
    * tag 'armsoc-drivers' of git://git.kernel.org/pub/scm/linux/kernel/git/soc/soc: (150 commits)
      firmware: arm_scmi: Fix doorbell ring logic for !CONFIG_64BIT
      soc: fsl: add RCPM driver
      dt-bindings: fsl: rcpm: Add 'little-endian' and update Chassis definition
      memory: tegra: Consolidate registers definition into common header
      memory: tegra: Ensure timing control debug features are disabled
      memory: tegra: Introduce Tegra30 EMC driver
      memory: tegra: Do not handle error from wait_for_completion_timeout()
      memory: tegra: Increase handshake timeout on Tegra20
      memory: tegra: Print a brief info message about EMC timings
      memory: tegra: Pre-configure debug register on Tegra20
      memory: tegra: Include io.h instead of iopoll.h
      memory: tegra: Adapt for Tegra20 clock driver changes
      memory: tegra: Don't set EMC rate to maximum on probe for Tegra20
      memory: tegra: Add gr2d and gr3d to DRM IOMMU group
      memory: tegra: Set DMA mask based on supported address bits
      soc: at91: Add Atmel SFR SN (Serial Number) support
      memory: atmel-ebi: switch to SPDX license identifiers
      memory: atmel-ebi: move NUM_CS definition inside EBI driver
      soc: mediatek: Refactor bus protection control
      soc: mediatek: Refactor sram control
      ...

commit 7ae399b7d009c7348b9451ac41cd49671b31cf3a
Author: Anson Huang <Anson.Huang@nxp.com>
Date:   Fri Oct 25 14:56:23 2019 +0800

    soc: imx-scu: Using existing serial_number instead of UID
    
    The soc_device_attribute structure already contains a serial_number
    attribute to show SoC's unique ID, just use it to show SoC's unique
    ID instead of creating a new file called soc_uid.
    
    Signed-off-by: Anson Huang <Anson.Huang@nxp.com>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/drivers/soc/imx/soc-imx-scu.c b/drivers/soc/imx/soc-imx-scu.c
index 50831ebf126a..f2eace5b50fe 100644
--- a/drivers/soc/imx/soc-imx-scu.c
+++ b/drivers/soc/imx/soc-imx-scu.c
@@ -33,12 +33,10 @@ struct imx_sc_msg_misc_get_soc_uid {
 	u32 uid_high;
 } __packed;
 
-static ssize_t soc_uid_show(struct device *dev,
-			    struct device_attribute *attr, char *buf)
+static int imx_scu_soc_uid(u64 *soc_uid)
 {
 	struct imx_sc_msg_misc_get_soc_uid msg;
 	struct imx_sc_rpc_msg *hdr = &msg.hdr;
-	u64 soc_uid;
 	int ret;
 
 	hdr->ver = IMX_SC_RPC_VERSION;
@@ -52,15 +50,13 @@ static ssize_t soc_uid_show(struct device *dev,
 		return ret;
 	}
 
-	soc_uid = msg.uid_high;
-	soc_uid <<= 32;
-	soc_uid |= msg.uid_low;
+	*soc_uid = msg.uid_high;
+	*soc_uid <<= 32;
+	*soc_uid |= msg.uid_low;
 
-	return sprintf(buf, "%016llX\n", soc_uid);
+	return 0;
 }
 
-static DEVICE_ATTR_RO(soc_uid);
-
 static int imx_scu_soc_id(void)
 {
 	struct imx_sc_msg_misc_get_soc_id msg;
@@ -89,6 +85,7 @@ static int imx_scu_soc_probe(struct platform_device *pdev)
 	struct soc_device_attribute *soc_dev_attr;
 	struct soc_device *soc_dev;
 	int id, ret;
+	u64 uid = 0;
 	u32 val;
 
 	ret = imx_scu_get_handle(&soc_ipc_handle);
@@ -112,6 +109,10 @@ static int imx_scu_soc_probe(struct platform_device *pdev)
 	if (id < 0)
 		return -EINVAL;
 
+	ret = imx_scu_soc_uid(&uid);
+	if (ret < 0)
+		return -EINVAL;
+
 	/* format soc_id value passed from SCU firmware */
 	val = id & 0x1f;
 	soc_dev_attr->soc_id = kasprintf(GFP_KERNEL, "0x%x", val);
@@ -130,19 +131,22 @@ static int imx_scu_soc_probe(struct platform_device *pdev)
 		goto free_soc_id;
 	}
 
+	soc_dev_attr->serial_number = kasprintf(GFP_KERNEL, "%016llX", uid);
+	if (!soc_dev_attr->serial_number) {
+		ret = -ENOMEM;
+		goto free_revision;
+	}
+
 	soc_dev = soc_device_register(soc_dev_attr);
 	if (IS_ERR(soc_dev)) {
 		ret = PTR_ERR(soc_dev);
-		goto free_revision;
+		goto free_serial_number;
 	}
 
-	ret = device_create_file(soc_device_to_device(soc_dev),
-				 &dev_attr_soc_uid);
-	if (ret)
-		goto free_revision;
-
 	return 0;
 
+free_serial_number:
+	kfree(soc_dev_attr->serial_number);
 free_revision:
 	kfree(soc_dev_attr->revision);
 free_soc_id:

commit 30ca9b04747ea865cbb5a7d05e10ef0a3761bf19
Author: Anson Huang <Anson.Huang@nxp.com>
Date:   Wed Sep 4 15:13:14 2019 -0400

    soc: imx: imx-scu: Getting UID from SCU should have response
    
    The SCU firmware API for getting UID should have response,
    otherwise, the message stored in function stack could be
    released and then the response data received from SCU will be
    stored into that released stack and cause kernel NULL pointer
    dump.
    
    Fixes: 73feb4d0f8f1 ("soc: imx-scu: Add SoC UID(unique identifier) support")
    Signed-off-by: Anson Huang <Anson.Huang@nxp.com>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/drivers/soc/imx/soc-imx-scu.c b/drivers/soc/imx/soc-imx-scu.c
index 50831ebf126a..c68882eb80f7 100644
--- a/drivers/soc/imx/soc-imx-scu.c
+++ b/drivers/soc/imx/soc-imx-scu.c
@@ -46,7 +46,7 @@ static ssize_t soc_uid_show(struct device *dev,
 	hdr->func = IMX_SC_MISC_FUNC_UNIQUE_ID;
 	hdr->size = 1;
 
-	ret = imx_scu_call_rpc(soc_ipc_handle, &msg, false);
+	ret = imx_scu_call_rpc(soc_ipc_handle, &msg, true);
 	if (ret) {
 		pr_err("%s: get soc uid failed, ret %d\n", __func__, ret);
 		return ret;

commit 73feb4d0f8f14c5102bd46ce2255ff55d3d52db7
Author: Anson Huang <Anson.Huang@nxp.com>
Date:   Tue Jul 2 15:45:45 2019 +0800

    soc: imx-scu: Add SoC UID(unique identifier) support
    
    Add i.MX SCU SoC's UID(unique identifier) support, user
    can read it from sysfs:
    
    root@imx8qxpmek:~# cat /sys/devices/soc0/soc_uid
    7B64280B57AC1898
    
    Signed-off-by: Anson Huang <Anson.Huang@nxp.com>
    Reviewed-by: Daniel Baluta <daniel.baluta@nxp.com>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/drivers/soc/imx/soc-imx-scu.c b/drivers/soc/imx/soc-imx-scu.c
index 676f612f6488..50831ebf126a 100644
--- a/drivers/soc/imx/soc-imx-scu.c
+++ b/drivers/soc/imx/soc-imx-scu.c
@@ -27,6 +27,40 @@ struct imx_sc_msg_misc_get_soc_id {
 	} data;
 } __packed;
 
+struct imx_sc_msg_misc_get_soc_uid {
+	struct imx_sc_rpc_msg hdr;
+	u32 uid_low;
+	u32 uid_high;
+} __packed;
+
+static ssize_t soc_uid_show(struct device *dev,
+			    struct device_attribute *attr, char *buf)
+{
+	struct imx_sc_msg_misc_get_soc_uid msg;
+	struct imx_sc_rpc_msg *hdr = &msg.hdr;
+	u64 soc_uid;
+	int ret;
+
+	hdr->ver = IMX_SC_RPC_VERSION;
+	hdr->svc = IMX_SC_RPC_SVC_MISC;
+	hdr->func = IMX_SC_MISC_FUNC_UNIQUE_ID;
+	hdr->size = 1;
+
+	ret = imx_scu_call_rpc(soc_ipc_handle, &msg, false);
+	if (ret) {
+		pr_err("%s: get soc uid failed, ret %d\n", __func__, ret);
+		return ret;
+	}
+
+	soc_uid = msg.uid_high;
+	soc_uid <<= 32;
+	soc_uid |= msg.uid_low;
+
+	return sprintf(buf, "%016llX\n", soc_uid);
+}
+
+static DEVICE_ATTR_RO(soc_uid);
+
 static int imx_scu_soc_id(void)
 {
 	struct imx_sc_msg_misc_get_soc_id msg;
@@ -102,6 +136,11 @@ static int imx_scu_soc_probe(struct platform_device *pdev)
 		goto free_revision;
 	}
 
+	ret = device_create_file(soc_device_to_device(soc_dev),
+				 &dev_attr_soc_uid);
+	if (ret)
+		goto free_revision;
+
 	return 0;
 
 free_revision:

commit 15f5276a2fb1ad70d7a8e6321dd751c3d081e422
Author: Anson Huang <anson.huang@nxp.com>
Date:   Fri May 24 01:52:36 2019 +0000

    soc: imx: Add SCU SoC info driver support
    
    Add i.MX SCU SoC info driver to support i.MX8QXP SoC, introduce
    driver dependency into Kconfig as CONFIG_IMX_SCU must be
    selected to support i.MX SCU SoC driver, also need to use
    platform driver model to make sure IMX_SCU driver is probed
    before i.MX SCU SoC driver.
    
    With this patch, SoC info can be read from sysfs:
    
    i.mx8qxp-mek# cat /sys/devices/soc0/family
    Freescale i.MX
    
    i.mx8qxp-mek# cat /sys/devices/soc0/soc_id
    0x2
    
    i.mx8qxp-mek# cat /sys/devices/soc0/machine
    Freescale i.MX8QXP MEK
    
    i.mx8qxp-mek# cat /sys/devices/soc0/revision
    1.1
    
    Signed-off-by: Anson Huang <Anson.Huang@nxp.com>
    Reviewed-by: Abel Vesa <abel.vesa@nxp.com>
    Reviewed-by: Dong Aisheng <aisheng.dong@nxp.com>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/drivers/soc/imx/soc-imx-scu.c b/drivers/soc/imx/soc-imx-scu.c
new file mode 100644
index 000000000000..676f612f6488
--- /dev/null
+++ b/drivers/soc/imx/soc-imx-scu.c
@@ -0,0 +1,144 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright 2019 NXP.
+ */
+
+#include <dt-bindings/firmware/imx/rsrc.h>
+#include <linux/firmware/imx/sci.h>
+#include <linux/slab.h>
+#include <linux/sys_soc.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+
+#define IMX_SCU_SOC_DRIVER_NAME		"imx-scu-soc"
+
+static struct imx_sc_ipc *soc_ipc_handle;
+
+struct imx_sc_msg_misc_get_soc_id {
+	struct imx_sc_rpc_msg hdr;
+	union {
+		struct {
+			u32 control;
+			u16 resource;
+		} __packed req;
+		struct {
+			u32 id;
+		} resp;
+	} data;
+} __packed;
+
+static int imx_scu_soc_id(void)
+{
+	struct imx_sc_msg_misc_get_soc_id msg;
+	struct imx_sc_rpc_msg *hdr = &msg.hdr;
+	int ret;
+
+	hdr->ver = IMX_SC_RPC_VERSION;
+	hdr->svc = IMX_SC_RPC_SVC_MISC;
+	hdr->func = IMX_SC_MISC_FUNC_GET_CONTROL;
+	hdr->size = 3;
+
+	msg.data.req.control = IMX_SC_C_ID;
+	msg.data.req.resource = IMX_SC_R_SYSTEM;
+
+	ret = imx_scu_call_rpc(soc_ipc_handle, &msg, true);
+	if (ret) {
+		pr_err("%s: get soc info failed, ret %d\n", __func__, ret);
+		return ret;
+	}
+
+	return msg.data.resp.id;
+}
+
+static int imx_scu_soc_probe(struct platform_device *pdev)
+{
+	struct soc_device_attribute *soc_dev_attr;
+	struct soc_device *soc_dev;
+	int id, ret;
+	u32 val;
+
+	ret = imx_scu_get_handle(&soc_ipc_handle);
+	if (ret)
+		return ret;
+
+	soc_dev_attr = devm_kzalloc(&pdev->dev, sizeof(*soc_dev_attr),
+				    GFP_KERNEL);
+	if (!soc_dev_attr)
+		return -ENOMEM;
+
+	soc_dev_attr->family = "Freescale i.MX";
+
+	ret = of_property_read_string(of_root,
+				      "model",
+				      &soc_dev_attr->machine);
+	if (ret)
+		return ret;
+
+	id = imx_scu_soc_id();
+	if (id < 0)
+		return -EINVAL;
+
+	/* format soc_id value passed from SCU firmware */
+	val = id & 0x1f;
+	soc_dev_attr->soc_id = kasprintf(GFP_KERNEL, "0x%x", val);
+	if (!soc_dev_attr->soc_id)
+		return -ENOMEM;
+
+	/* format revision value passed from SCU firmware */
+	val = (id >> 5) & 0xf;
+	val = (((val >> 2) + 1) << 4) | (val & 0x3);
+	soc_dev_attr->revision = kasprintf(GFP_KERNEL,
+					   "%d.%d",
+					   (val >> 4) & 0xf,
+					   val & 0xf);
+	if (!soc_dev_attr->revision) {
+		ret = -ENOMEM;
+		goto free_soc_id;
+	}
+
+	soc_dev = soc_device_register(soc_dev_attr);
+	if (IS_ERR(soc_dev)) {
+		ret = PTR_ERR(soc_dev);
+		goto free_revision;
+	}
+
+	return 0;
+
+free_revision:
+	kfree(soc_dev_attr->revision);
+free_soc_id:
+	kfree(soc_dev_attr->soc_id);
+	return ret;
+}
+
+static struct platform_driver imx_scu_soc_driver = {
+	.driver = {
+		.name = IMX_SCU_SOC_DRIVER_NAME,
+	},
+	.probe = imx_scu_soc_probe,
+};
+
+static int __init imx_scu_soc_init(void)
+{
+	struct platform_device *pdev;
+	struct device_node *np;
+	int ret;
+
+	np = of_find_compatible_node(NULL, NULL, "fsl,imx-scu");
+	if (!np)
+		return -ENODEV;
+
+	of_node_put(np);
+
+	ret = platform_driver_register(&imx_scu_soc_driver);
+	if (ret)
+		return ret;
+
+	pdev = platform_device_register_simple(IMX_SCU_SOC_DRIVER_NAME,
+					       -1, NULL, 0);
+	if (IS_ERR(pdev))
+		platform_driver_unregister(&imx_scu_soc_driver);
+
+	return PTR_ERR_OR_ZERO(pdev);
+}
+device_initcall(imx_scu_soc_init);
