commit 704887278b3fb6e72ef767e56fbae4129e567c48
Author: Stephen Boyd <swboyd@chromium.org>
Date:   Thu Apr 16 17:06:45 2020 -0700

    soc: qcom: cmd-db: Properly endian swap the slv_id for debugfs
    
    Read the slv_id properly by making sure the 16-bit number is endian
    swapped from little endian to CPU native before we read it to figure out
    what to print for the human readable name. Otherwise we may just show
    that all the elements in the cmd-db are "Unknown" which isn't right.
    
    Reviewed-by: Guenter Roeck <linux@roeck-us.net>
    Reported-by: kbuild test robot <lkp@intel.com>
    Cc: Lina Iyer <ilina@codeaurora.org>
    Signed-off-by: Stephen Boyd <swboyd@chromium.org>
    Link: https://lore.kernel.org/r/20200417000645.234693-1-swboyd@chromium.org
    Signed-off-by: Bjorn Andersson <bjorn.andersson@linaro.org>

diff --git a/drivers/soc/qcom/cmd-db.c b/drivers/soc/qcom/cmd-db.c
index 4f8b739c6485..fc5610603b17 100644
--- a/drivers/soc/qcom/cmd-db.c
+++ b/drivers/soc/qcom/cmd-db.c
@@ -254,7 +254,7 @@ static int cmd_db_debugfs_dump(struct seq_file *seq, void *p)
 		if (!rsc->slv_id)
 			break;
 
-		switch (rsc->slv_id) {
+		switch (le16_to_cpu(rsc->slv_id)) {
 		case CMD_DB_HW_ARC:
 			name = "ARC";
 			break;

commit 3adaf26e7b01691eeee4086b7ac70c7750ff126e
Author: Stephen Boyd <swboyd@chromium.org>
Date:   Wed Apr 15 12:29:16 2020 -0700

    soc: qcom: cmd-db: Use 5 digits for printing address
    
    The top few bits aren't relevant to pad out because they're always zero.
    Let's just print 5 digits instead of 8 so that it's a little shorter and
    more readable.
    
    Reviewed-by: Lina Iyer <ilina@codeaurora.org>
    Suggested-by: Lina Iyer <ilina@codeaurora.org>
    Signed-off-by: Stephen Boyd <swboyd@chromium.org>
    Link: https://lore.kernel.org/r/20200415192916.78339-1-swboyd@chromium.org
    Signed-off-by: Bjorn Andersson <bjorn.andersson@linaro.org>

diff --git a/drivers/soc/qcom/cmd-db.c b/drivers/soc/qcom/cmd-db.c
index 57382b64f1da..4f8b739c6485 100644
--- a/drivers/soc/qcom/cmd-db.c
+++ b/drivers/soc/qcom/cmd-db.c
@@ -278,7 +278,7 @@ static int cmd_db_debugfs_dump(struct seq_file *seq, void *p)
 
 		ent = rsc_to_entry_header(rsc);
 		for (j = 0; j < le16_to_cpu(rsc->cnt); j++, ent++) {
-			seq_printf(seq, "0x%08x: %*pEp", le32_to_cpu(ent->addr),
+			seq_printf(seq, "0x%05x: %*pEp", le32_to_cpu(ent->addr),
 				   (int)sizeof(ent->id), ent->id);
 
 			len = le16_to_cpu(ent->len);

commit 9d6ba921acf43bf1894564eb3d51ced2145e0147
Author: Stephen Boyd <swboyd@chromium.org>
Date:   Tue Apr 14 23:20:33 2020 -0700

    soc: qcom: cmd-db: Cast sizeof() to int to silence field width warning
    
    We pass the result of sizeof() here to tell the printk format specifier
    how many bytes to print. That expects an int though and sizeof() isn't
    that type. Cast to int to silence this warning:
    
    drivers/soc/qcom/cmd-db.c: In function 'cmd_db_debugfs_dump':
    drivers/soc/qcom/cmd-db.c:281:30: warning: field width specifier '*' expects argument of type 'int', but argument 4 has type 'long unsigned int' [-Wformat=]
    
    Reviewed-by: Guenter Roeck <linux@roeck-us.net>
    Fixes: d6815c5c43d4 ("soc: qcom: cmd-db: Add debugfs dumping file")
    Reported-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Stephen Boyd <swboyd@chromium.org>
    Link: https://lore.kernel.org/r/20200415062033.66406-1-swboyd@chromium.org
    Signed-off-by: Bjorn Andersson <bjorn.andersson@linaro.org>

diff --git a/drivers/soc/qcom/cmd-db.c b/drivers/soc/qcom/cmd-db.c
index 8b2b7357b6da..57382b64f1da 100644
--- a/drivers/soc/qcom/cmd-db.c
+++ b/drivers/soc/qcom/cmd-db.c
@@ -279,7 +279,7 @@ static int cmd_db_debugfs_dump(struct seq_file *seq, void *p)
 		ent = rsc_to_entry_header(rsc);
 		for (j = 0; j < le16_to_cpu(rsc->cnt); j++, ent++) {
 			seq_printf(seq, "0x%08x: %*pEp", le32_to_cpu(ent->addr),
-				   sizeof(ent->id), ent->id);
+				   (int)sizeof(ent->id), ent->id);
 
 			len = le16_to_cpu(ent->len);
 			if (len) {

commit d6815c5c43d4f9d18e557d27fd27ae8d9cfd450c
Author: Stephen Boyd <swboyd@chromium.org>
Date:   Mon Mar 9 11:57:04 2020 -0700

    soc: qcom: cmd-db: Add debugfs dumping file
    
    It's useful for kernel devs to understand what resources and data is
    stored inside command db. Add a file in debugufs called 'cmd-db' to dump
    the memory contents and strings for resources along with their
    addresses. E.g.
    
     Command DB DUMP
     Slave ARC (v16.0)
     -------------------------
     0x00030000: cx.lvl [00 00 10 00 40 00 80 00 c0 00 00 01 80 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00]
     0x00030004: cx.tmr
     0x00030010: mx.lvl [00 00 10 00 00 01 80 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00]
     0x00030014: mx.tmr
    
    Cc: Lina Iyer <ilina@codeaurora.org>
    Cc: Maulik Shah <mkshah@codeaurora.org>
    Signed-off-by: Stephen Boyd <swboyd@chromium.org>
    Link: https://lore.kernel.org/r/20200309185704.2491-1-swboyd@chromium.org
    Signed-off-by: Bjorn Andersson <bjorn.andersson@linaro.org>

diff --git a/drivers/soc/qcom/cmd-db.c b/drivers/soc/qcom/cmd-db.c
index f6c3d17b05c7..8b2b7357b6da 100644
--- a/drivers/soc/qcom/cmd-db.c
+++ b/drivers/soc/qcom/cmd-db.c
@@ -1,12 +1,13 @@
 /* SPDX-License-Identifier: GPL-2.0 */
 /* Copyright (c) 2016-2018, The Linux Foundation. All rights reserved. */
 
+#include <linux/debugfs.h>
 #include <linux/kernel.h>
 #include <linux/of.h>
 #include <linux/of_address.h>
-#include <linux/of_platform.h>
 #include <linux/of_reserved_mem.h>
 #include <linux/platform_device.h>
+#include <linux/seq_file.h>
 #include <linux/types.h>
 
 #include <soc/qcom/cmd-db.h>
@@ -236,6 +237,77 @@ enum cmd_db_hw_type cmd_db_read_slave_id(const char *id)
 }
 EXPORT_SYMBOL(cmd_db_read_slave_id);
 
+#ifdef CONFIG_DEBUG_FS
+static int cmd_db_debugfs_dump(struct seq_file *seq, void *p)
+{
+	int i, j;
+	const struct rsc_hdr *rsc;
+	const struct entry_header *ent;
+	const char *name;
+	u16 len, version;
+	u8 major, minor;
+
+	seq_puts(seq, "Command DB DUMP\n");
+
+	for (i = 0; i < MAX_SLV_ID; i++) {
+		rsc = &cmd_db_header->header[i];
+		if (!rsc->slv_id)
+			break;
+
+		switch (rsc->slv_id) {
+		case CMD_DB_HW_ARC:
+			name = "ARC";
+			break;
+		case CMD_DB_HW_VRM:
+			name = "VRM";
+			break;
+		case CMD_DB_HW_BCM:
+			name = "BCM";
+			break;
+		default:
+			name = "Unknown";
+			break;
+		}
+
+		version = le16_to_cpu(rsc->version);
+		major = version >> 8;
+		minor = version;
+
+		seq_printf(seq, "Slave %s (v%u.%u)\n", name, major, minor);
+		seq_puts(seq, "-------------------------\n");
+
+		ent = rsc_to_entry_header(rsc);
+		for (j = 0; j < le16_to_cpu(rsc->cnt); j++, ent++) {
+			seq_printf(seq, "0x%08x: %*pEp", le32_to_cpu(ent->addr),
+				   sizeof(ent->id), ent->id);
+
+			len = le16_to_cpu(ent->len);
+			if (len) {
+				seq_printf(seq, " [%*ph]",
+					   len, rsc_offset(rsc, ent));
+			}
+			seq_putc(seq, '\n');
+		}
+	}
+
+	return 0;
+}
+
+static int open_cmd_db_debugfs(struct inode *inode, struct file *file)
+{
+	return single_open(file, cmd_db_debugfs_dump, inode->i_private);
+}
+#endif
+
+static const struct file_operations cmd_db_debugfs_ops = {
+#ifdef CONFIG_DEBUG_FS
+	.open = open_cmd_db_debugfs,
+#endif
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
+};
+
 static int cmd_db_dev_probe(struct platform_device *pdev)
 {
 	struct reserved_mem *rmem;
@@ -259,12 +331,14 @@ static int cmd_db_dev_probe(struct platform_device *pdev)
 		return -EINVAL;
 	}
 
+	debugfs_create_file("cmd-db", 0400, NULL, NULL, &cmd_db_debugfs_ops);
+
 	return 0;
 }
 
 static const struct of_device_id cmd_db_match_table[] = {
 	{ .compatible = "qcom,cmd-db" },
-	{ },
+	{ }
 };
 
 static struct platform_driver cmd_db_dev_driver = {

commit 93b260528020792032e50725383f27a27897bb0f
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu Feb 28 08:48:49 2019 +0300

    soc: qcom: cmd-db: Fix an error code in cmd_db_dev_probe()
    
    The memremap() function doesn't return error pointers, it returns NULL.
    This code is returning "ret = PTR_ERR(NULL);" which is success, but it
    should return -ENOMEM.
    
    Fixes: 312416d9171a ("drivers: qcom: add command DB driver")
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Bjorn Andersson <bjorn.andersson@linaro.org>
    Signed-off-by: Andy Gross <andy.gross@linaro.org>

diff --git a/drivers/soc/qcom/cmd-db.c b/drivers/soc/qcom/cmd-db.c
index c701b3b010f1..f6c3d17b05c7 100644
--- a/drivers/soc/qcom/cmd-db.c
+++ b/drivers/soc/qcom/cmd-db.c
@@ -248,8 +248,8 @@ static int cmd_db_dev_probe(struct platform_device *pdev)
 	}
 
 	cmd_db_header = memremap(rmem->base, rmem->size, MEMREMAP_WB);
-	if (IS_ERR_OR_NULL(cmd_db_header)) {
-		ret = PTR_ERR(cmd_db_header);
+	if (!cmd_db_header) {
+		ret = -ENOMEM;
 		cmd_db_header = NULL;
 		return ret;
 	}

commit ed3cafa79ea756be653d22087c017af95ea78a49
Author: Stephen Boyd <swboyd@chromium.org>
Date:   Wed Sep 26 11:02:34 2018 -0700

    soc: qcom: cmd-db: Stop memcpy()ing in cmd_db_read_aux_data()
    
    Let's change the function signature to return the pointer to memory or
    an error pointer on failure, and take an argument that lets us return
    the size of the aux data read. This way we can remove the
    cmd_db_read_aux_data_len() API entirely and also get rid of the memcpy
    operation from cmd_db to the caller. Updating the only user of this code
    shows that making this change allows us to remove a function and put the
    lookup where the user is.
    
    Cc: Mahesh Sivasubramanian <msivasub@codeaurora.org>
    Cc: Lina Iyer <ilina@codeaurora.org>
    Cc: Bjorn Andersson <bjorn.andersson@linaro.org>
    Cc: Evan Green <evgreen@chromium.org>
    Cc: Jordan Crouse <jcrouse@codeaurora.org>
    Cc: Rob Clark <robdclark@gmail.com>
    Signed-off-by: Stephen Boyd <swboyd@chromium.org>
    Signed-off-by: Andy Gross <andy.gross@linaro.org>

diff --git a/drivers/soc/qcom/cmd-db.c b/drivers/soc/qcom/cmd-db.c
index 5c9cc6824891..c701b3b010f1 100644
--- a/drivers/soc/qcom/cmd-db.c
+++ b/drivers/soc/qcom/cmd-db.c
@@ -192,55 +192,28 @@ EXPORT_SYMBOL(cmd_db_read_addr);
 /**
  * cmd_db_read_aux_data() - Query command db for aux data.
  *
- *  @id: Resource to retrieve AUX Data on.
- *  @data: Data buffer to copy returned aux data to. Returns size on NULL
- *  @len: Caller provides size of data buffer passed in.
+ *  @id: Resource to retrieve AUX Data on
+ *  @len: size of data buffer returned
  *
- *  Return: size of data on success, errno otherwise
+ *  Return: pointer to data on success, error pointer otherwise
  */
-int cmd_db_read_aux_data(const char *id, u8 *data, size_t len)
+const void *cmd_db_read_aux_data(const char *id, size_t *len)
 {
 	int ret;
 	const struct entry_header *ent;
 	const struct rsc_hdr *rsc_hdr;
-	u16 ent_len;
-
-	if (!data)
-		return -EINVAL;
 
 	ret = cmd_db_get_header(id, &ent, &rsc_hdr);
 	if (ret)
-		return ret;
-
-	ent_len = le16_to_cpu(ent->len);
-	if (len < ent_len)
-		return -EINVAL;
+		return ERR_PTR(ret);
 
-	len = min_t(u16, ent_len, len);
-	memcpy(data, rsc_offset(rsc_hdr, ent), len);
+	if (len)
+		*len = le16_to_cpu(ent->len);
 
-	return len;
+	return rsc_offset(rsc_hdr, ent);
 }
 EXPORT_SYMBOL(cmd_db_read_aux_data);
 
-/**
- * cmd_db_read_aux_data_len - Get the length of the auxiliary data stored in DB.
- *
- * @id: Resource to retrieve AUX Data.
- *
- * Return: size on success, 0 on error
- */
-size_t cmd_db_read_aux_data_len(const char *id)
-{
-	int ret;
-	const struct entry_header *ent;
-
-	ret = cmd_db_get_header(id, &ent, NULL);
-
-	return ret < 0 ? 0 : le16_to_cpu(ent->len);
-}
-EXPORT_SYMBOL(cmd_db_read_aux_data_len);
-
 /**
  * cmd_db_read_slave_id - Get the slave ID for a given resource address
  *

commit 84fa36eb30f2e02ebf07a22fea2550a7a3938bec
Author: Stephen Boyd <swboyd@chromium.org>
Date:   Wed Sep 26 11:02:33 2018 -0700

    soc: qcom: cmd-db: Remove memcpy()ing from cmd_db_get_header()
    
    The cmd_db_get_header() function is a static local function that doesn't
    need to copy anything from one place to another. Instead, it can just
    point into the region by returning pointers to what we're looking for.
    If we do that, we should mark what we're returning as const so that code
    can't modify cmd-db without an obvious cast.
    
    Cc: Mahesh Sivasubramanian <msivasub@codeaurora.org>
    Cc: Lina Iyer <ilina@codeaurora.org>
    Cc: Bjorn Andersson <bjorn.andersson@linaro.org>
    Cc: Evan Green <evgreen@chromium.org>
    Signed-off-by: Stephen Boyd <swboyd@chromium.org>
    Signed-off-by: Andy Gross <andy.gross@linaro.org>

diff --git a/drivers/soc/qcom/cmd-db.c b/drivers/soc/qcom/cmd-db.c
index a6f646295f06..5c9cc6824891 100644
--- a/drivers/soc/qcom/cmd-db.c
+++ b/drivers/soc/qcom/cmd-db.c
@@ -101,8 +101,7 @@ static bool cmd_db_magic_matches(const struct cmd_db_header *header)
 
 static struct cmd_db_header *cmd_db_header;
 
-
-static inline void *rsc_to_entry_header(struct rsc_hdr *hdr)
+static inline const void *rsc_to_entry_header(const struct rsc_hdr *hdr)
 {
 	u16 offset = le16_to_cpu(hdr->header_offset);
 
@@ -110,7 +109,7 @@ static inline void *rsc_to_entry_header(struct rsc_hdr *hdr)
 }
 
 static inline void *
-rsc_offset(struct rsc_hdr *hdr, struct entry_header *ent)
+rsc_offset(const struct rsc_hdr *hdr, const struct entry_header *ent)
 {
 	u16 offset = le16_to_cpu(hdr->data_offset);
 	u16 loffset = le16_to_cpu(ent->offset);
@@ -134,11 +133,11 @@ int cmd_db_ready(void)
 }
 EXPORT_SYMBOL(cmd_db_ready);
 
-static int cmd_db_get_header(const char *id, struct entry_header *eh,
-			     struct rsc_hdr *rh)
+static int cmd_db_get_header(const char *id, const struct entry_header **eh,
+			     const struct rsc_hdr **rh)
 {
-	struct rsc_hdr *rsc_hdr;
-	struct entry_header *ent;
+	const struct rsc_hdr *rsc_hdr;
+	const struct entry_header *ent;
 	int ret, i, j;
 	u8 query[8];
 
@@ -146,9 +145,6 @@ static int cmd_db_get_header(const char *id, struct entry_header *eh,
 	if (ret)
 		return ret;
 
-	if (!eh || !rh)
-		return -EINVAL;
-
 	/* Pad out query string to same length as in DB */
 	strncpy(query, id, sizeof(query));
 
@@ -159,14 +155,13 @@ static int cmd_db_get_header(const char *id, struct entry_header *eh,
 
 		ent = rsc_to_entry_header(rsc_hdr);
 		for (j = 0; j < le16_to_cpu(rsc_hdr->cnt); j++, ent++) {
-			if (memcmp(ent->id, query, sizeof(ent->id)) == 0)
-				break;
-		}
-
-		if (j < le16_to_cpu(rsc_hdr->cnt)) {
-			memcpy(eh, ent, sizeof(*ent));
-			memcpy(rh, rsc_hdr, sizeof(*rh));
-			return 0;
+			if (memcmp(ent->id, query, sizeof(ent->id)) == 0) {
+				if (eh)
+					*eh = ent;
+				if (rh)
+					*rh = rsc_hdr;
+				return 0;
+			}
 		}
 	}
 
@@ -186,12 +181,11 @@ static int cmd_db_get_header(const char *id, struct entry_header *eh,
 u32 cmd_db_read_addr(const char *id)
 {
 	int ret;
-	struct entry_header ent;
-	struct rsc_hdr rsc_hdr;
+	const struct entry_header *ent;
 
-	ret = cmd_db_get_header(id, &ent, &rsc_hdr);
+	ret = cmd_db_get_header(id, &ent, NULL);
 
-	return ret < 0 ? 0 : le32_to_cpu(ent.addr);
+	return ret < 0 ? 0 : le32_to_cpu(ent->addr);
 }
 EXPORT_SYMBOL(cmd_db_read_addr);
 
@@ -207,8 +201,8 @@ EXPORT_SYMBOL(cmd_db_read_addr);
 int cmd_db_read_aux_data(const char *id, u8 *data, size_t len)
 {
 	int ret;
-	struct entry_header ent;
-	struct rsc_hdr rsc_hdr;
+	const struct entry_header *ent;
+	const struct rsc_hdr *rsc_hdr;
 	u16 ent_len;
 
 	if (!data)
@@ -218,12 +212,12 @@ int cmd_db_read_aux_data(const char *id, u8 *data, size_t len)
 	if (ret)
 		return ret;
 
-	ent_len = le16_to_cpu(ent.len);
+	ent_len = le16_to_cpu(ent->len);
 	if (len < ent_len)
 		return -EINVAL;
 
 	len = min_t(u16, ent_len, len);
-	memcpy(data, rsc_offset(&rsc_hdr, &ent), len);
+	memcpy(data, rsc_offset(rsc_hdr, ent), len);
 
 	return len;
 }
@@ -239,12 +233,11 @@ EXPORT_SYMBOL(cmd_db_read_aux_data);
 size_t cmd_db_read_aux_data_len(const char *id)
 {
 	int ret;
-	struct entry_header ent;
-	struct rsc_hdr rsc_hdr;
+	const struct entry_header *ent;
 
-	ret = cmd_db_get_header(id, &ent, &rsc_hdr);
+	ret = cmd_db_get_header(id, &ent, NULL);
 
-	return ret < 0 ? 0 : le16_to_cpu(ent.len);
+	return ret < 0 ? 0 : le16_to_cpu(ent->len);
 }
 EXPORT_SYMBOL(cmd_db_read_aux_data_len);
 
@@ -258,15 +251,14 @@ EXPORT_SYMBOL(cmd_db_read_aux_data_len);
 enum cmd_db_hw_type cmd_db_read_slave_id(const char *id)
 {
 	int ret;
-	struct entry_header ent;
-	struct rsc_hdr rsc_hdr;
+	const struct entry_header *ent;
 	u32 addr;
 
-	ret = cmd_db_get_header(id, &ent, &rsc_hdr);
+	ret = cmd_db_get_header(id, &ent, NULL);
 	if (ret < 0)
 		return CMD_DB_HW_INVALID;
 
-	addr = le32_to_cpu(ent.addr);
+	addr = le32_to_cpu(ent->addr);
 	return (addr >> SLAVE_ID_SHIFT) & SLAVE_ID_MASK;
 }
 EXPORT_SYMBOL(cmd_db_read_slave_id);

commit 36b0aefdee6e203f3130d7444bf5103139ecbe25
Author: Stephen Boyd <swboyd@chromium.org>
Date:   Thu Apr 19 11:29:24 2018 -0700

    soc: qcom: cmd-db: Make endian-agnostic
    
    This driver deals with memory that is stored in little-endian format.
    Update the structures with the proper little-endian types and then
    do the proper conversions when reading the fields. Note that we compare
    the ids with a memcmp() because we already pad out the string 'id' field
    to exactly 8 bytes with the strncpy() onto the stack.
    
    Cc: Mahesh Sivasubramanian <msivasub@codeaurora.org>
    Cc: Lina Iyer <ilina@codeaurora.org>
    Cc: Bjorn Andersson <bjorn.andersson@linaro.org>
    Cc: Evan Green <evgreen@chromium.org>
    Signed-off-by: Stephen Boyd <swboyd@chromium.org>
    Signed-off-by: Andy Gross <andy.gross@linaro.org>

diff --git a/drivers/soc/qcom/cmd-db.c b/drivers/soc/qcom/cmd-db.c
index b5172049f608..a6f646295f06 100644
--- a/drivers/soc/qcom/cmd-db.c
+++ b/drivers/soc/qcom/cmd-db.c
@@ -13,18 +13,9 @@
 
 #define NUM_PRIORITY		2
 #define MAX_SLV_ID		8
-#define CMD_DB_MAGIC		0x0C0330DBUL
 #define SLAVE_ID_MASK		0x7
 #define SLAVE_ID_SHIFT		16
 
-#define ENTRY_HEADER(hdr)	((void *)cmd_db_header +	\
-				sizeof(*cmd_db_header) +	\
-				hdr->header_offset)
-
-#define RSC_OFFSET(hdr, ent)	((void *)cmd_db_header +	\
-				sizeof(*cmd_db_header) +	\
-				hdr.data_offset + ent.offset)
-
 /**
  * struct entry_header: header for each entry in cmddb
  *
@@ -35,11 +26,11 @@
  * @offset: offset from :@data_offset, start of the data
  */
 struct entry_header {
-	u64 id;
-	u32 priority[NUM_PRIORITY];
-	u32 addr;
-	u16 len;
-	u16 offset;
+	u8 id[8];
+	__le32 priority[NUM_PRIORITY];
+	__le32 addr;
+	__le16 len;
+	__le16 offset;
 };
 
 /**
@@ -53,30 +44,30 @@ struct entry_header {
  * @reserved: reserved for future use.
  */
 struct rsc_hdr {
-	u16 slv_id;
-	u16 header_offset;
-	u16 data_offset;
-	u16 cnt;
-	u16 version;
-	u16 reserved[3];
+	__le16 slv_id;
+	__le16 header_offset;
+	__le16 data_offset;
+	__le16 cnt;
+	__le16 version;
+	__le16 reserved[3];
 };
 
 /**
  * struct cmd_db_header: The DB header information
  *
  * @version: The cmd db version
- * @magic_number: constant expected in the database
+ * @magic: constant expected in the database
  * @header: array of resources
  * @checksum: checksum for the header. Unused.
  * @reserved: reserved memory
  * @data: driver specific data
  */
 struct cmd_db_header {
-	u32 version;
-	u32 magic_num;
+	__le32 version;
+	u8 magic[4];
 	struct rsc_hdr header[MAX_SLV_ID];
-	u32 checksum;
-	u32 reserved;
+	__le32 checksum;
+	__le32 reserved;
 	u8 data[];
 };
 
@@ -99,8 +90,34 @@ struct cmd_db_header {
  * h/w accelerator and request a resource state.
  */
 
+static const u8 CMD_DB_MAGIC[] = { 0xdb, 0x30, 0x03, 0x0c };
+
+static bool cmd_db_magic_matches(const struct cmd_db_header *header)
+{
+	const u8 *magic = header->magic;
+
+	return memcmp(magic, CMD_DB_MAGIC, ARRAY_SIZE(CMD_DB_MAGIC)) == 0;
+}
+
 static struct cmd_db_header *cmd_db_header;
 
+
+static inline void *rsc_to_entry_header(struct rsc_hdr *hdr)
+{
+	u16 offset = le16_to_cpu(hdr->header_offset);
+
+	return cmd_db_header->data + offset;
+}
+
+static inline void *
+rsc_offset(struct rsc_hdr *hdr, struct entry_header *ent)
+{
+	u16 offset = le16_to_cpu(hdr->data_offset);
+	u16 loffset = le16_to_cpu(ent->offset);
+
+	return cmd_db_header->data + offset + loffset;
+}
+
 /**
  * cmd_db_ready - Indicates if command DB is available
  *
@@ -110,29 +127,20 @@ int cmd_db_ready(void)
 {
 	if (cmd_db_header == NULL)
 		return -EPROBE_DEFER;
-	else if (cmd_db_header->magic_num != CMD_DB_MAGIC)
+	else if (!cmd_db_magic_matches(cmd_db_header))
 		return -EINVAL;
 
 	return 0;
 }
 EXPORT_SYMBOL(cmd_db_ready);
 
-static u64 cmd_db_get_u64_id(const char *id)
-{
-	u64 rsc_id = 0;
-	u8 *ch = (u8 *)&rsc_id;
-
-	strncpy(ch, id, min(strlen(id), sizeof(rsc_id)));
-
-	return rsc_id;
-}
-
-static int cmd_db_get_header(u64 query, struct entry_header *eh,
+static int cmd_db_get_header(const char *id, struct entry_header *eh,
 			     struct rsc_hdr *rh)
 {
 	struct rsc_hdr *rsc_hdr;
 	struct entry_header *ent;
 	int ret, i, j;
+	u8 query[8];
 
 	ret = cmd_db_ready();
 	if (ret)
@@ -141,18 +149,21 @@ static int cmd_db_get_header(u64 query, struct entry_header *eh,
 	if (!eh || !rh)
 		return -EINVAL;
 
+	/* Pad out query string to same length as in DB */
+	strncpy(query, id, sizeof(query));
+
 	for (i = 0; i < MAX_SLV_ID; i++) {
 		rsc_hdr = &cmd_db_header->header[i];
 		if (!rsc_hdr->slv_id)
 			break;
 
-		ent = ENTRY_HEADER(rsc_hdr);
-		for (j = 0; j < rsc_hdr->cnt; j++, ent++) {
-			if (ent->id == query)
+		ent = rsc_to_entry_header(rsc_hdr);
+		for (j = 0; j < le16_to_cpu(rsc_hdr->cnt); j++, ent++) {
+			if (memcmp(ent->id, query, sizeof(ent->id)) == 0)
 				break;
 		}
 
-		if (j < rsc_hdr->cnt) {
+		if (j < le16_to_cpu(rsc_hdr->cnt)) {
 			memcpy(eh, ent, sizeof(*ent));
 			memcpy(rh, rsc_hdr, sizeof(*rh));
 			return 0;
@@ -162,15 +173,6 @@ static int cmd_db_get_header(u64 query, struct entry_header *eh,
 	return -ENODEV;
 }
 
-static int cmd_db_get_header_by_rsc_id(const char *id,
-				       struct entry_header *ent_hdr,
-				       struct rsc_hdr *rsc_hdr)
-{
-	u64 rsc_id = cmd_db_get_u64_id(id);
-
-	return cmd_db_get_header(rsc_id, ent_hdr, rsc_hdr);
-}
-
 /**
  * cmd_db_read_addr() - Query command db for resource id address.
  *
@@ -187,9 +189,9 @@ u32 cmd_db_read_addr(const char *id)
 	struct entry_header ent;
 	struct rsc_hdr rsc_hdr;
 
-	ret = cmd_db_get_header_by_rsc_id(id, &ent, &rsc_hdr);
+	ret = cmd_db_get_header(id, &ent, &rsc_hdr);
 
-	return ret < 0 ? 0 : ent.addr;
+	return ret < 0 ? 0 : le32_to_cpu(ent.addr);
 }
 EXPORT_SYMBOL(cmd_db_read_addr);
 
@@ -207,19 +209,21 @@ int cmd_db_read_aux_data(const char *id, u8 *data, size_t len)
 	int ret;
 	struct entry_header ent;
 	struct rsc_hdr rsc_hdr;
+	u16 ent_len;
 
 	if (!data)
 		return -EINVAL;
 
-	ret = cmd_db_get_header_by_rsc_id(id, &ent, &rsc_hdr);
+	ret = cmd_db_get_header(id, &ent, &rsc_hdr);
 	if (ret)
 		return ret;
 
-	if (len < ent.len)
+	ent_len = le16_to_cpu(ent.len);
+	if (len < ent_len)
 		return -EINVAL;
 
-	len = min_t(u16, ent.len, len);
-	memcpy(data, RSC_OFFSET(rsc_hdr, ent), len);
+	len = min_t(u16, ent_len, len);
+	memcpy(data, rsc_offset(&rsc_hdr, &ent), len);
 
 	return len;
 }
@@ -238,9 +242,9 @@ size_t cmd_db_read_aux_data_len(const char *id)
 	struct entry_header ent;
 	struct rsc_hdr rsc_hdr;
 
-	ret = cmd_db_get_header_by_rsc_id(id, &ent, &rsc_hdr);
+	ret = cmd_db_get_header(id, &ent, &rsc_hdr);
 
-	return ret < 0 ? 0 : ent.len;
+	return ret < 0 ? 0 : le16_to_cpu(ent.len);
 }
 EXPORT_SYMBOL(cmd_db_read_aux_data_len);
 
@@ -256,11 +260,14 @@ enum cmd_db_hw_type cmd_db_read_slave_id(const char *id)
 	int ret;
 	struct entry_header ent;
 	struct rsc_hdr rsc_hdr;
+	u32 addr;
 
-	ret = cmd_db_get_header_by_rsc_id(id, &ent, &rsc_hdr);
+	ret = cmd_db_get_header(id, &ent, &rsc_hdr);
+	if (ret < 0)
+		return CMD_DB_HW_INVALID;
 
-	return ret < 0 ? CMD_DB_HW_INVALID :
-		       (ent.addr >> SLAVE_ID_SHIFT) & SLAVE_ID_MASK;
+	addr = le32_to_cpu(ent.addr);
+	return (addr >> SLAVE_ID_SHIFT) & SLAVE_ID_MASK;
 }
 EXPORT_SYMBOL(cmd_db_read_slave_id);
 
@@ -282,7 +289,7 @@ static int cmd_db_dev_probe(struct platform_device *pdev)
 		return ret;
 	}
 
-	if (cmd_db_header->magic_num != CMD_DB_MAGIC) {
+	if (!cmd_db_magic_matches(cmd_db_header)) {
 		dev_err(&pdev->dev, "Invalid Command DB Magic\n");
 		return -EINVAL;
 	}

commit 312416d9171a1460b7ed8d182b5b540c910ce80d
Author: Mahesh Sivasubramanian <msivasub@codeaurora.org>
Date:   Tue Apr 10 11:57:23 2018 -0600

    drivers: qcom: add command DB driver
    
    Command DB is a simple database in the shared memory of QCOM SoCs, that
    provides information regarding shared resources. Some shared resources
    in the SoC have properties that are probed dynamically at boot by the
    remote processor. The information pertaining to the SoC and the platform
    are made available in the shared memory. Drivers can query this
    information using predefined strings.
    
    Signed-off-by: Mahesh Sivasubramanian <msivasub@codeaurora.org>
    Signed-off-by: Lina Iyer <ilina@codeaurora.org>
    Reviewed-by: Bjorn Andersson <bjorn.andersson@linaro.org>
    Reviewed-by: Stephen Boyd <swboyd@chromium.org>
    Signed-off-by: Andy Gross <andy.gross@linaro.org>

diff --git a/drivers/soc/qcom/cmd-db.c b/drivers/soc/qcom/cmd-db.c
new file mode 100644
index 000000000000..b5172049f608
--- /dev/null
+++ b/drivers/soc/qcom/cmd-db.c
@@ -0,0 +1,310 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (c) 2016-2018, The Linux Foundation. All rights reserved. */
+
+#include <linux/kernel.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_platform.h>
+#include <linux/of_reserved_mem.h>
+#include <linux/platform_device.h>
+#include <linux/types.h>
+
+#include <soc/qcom/cmd-db.h>
+
+#define NUM_PRIORITY		2
+#define MAX_SLV_ID		8
+#define CMD_DB_MAGIC		0x0C0330DBUL
+#define SLAVE_ID_MASK		0x7
+#define SLAVE_ID_SHIFT		16
+
+#define ENTRY_HEADER(hdr)	((void *)cmd_db_header +	\
+				sizeof(*cmd_db_header) +	\
+				hdr->header_offset)
+
+#define RSC_OFFSET(hdr, ent)	((void *)cmd_db_header +	\
+				sizeof(*cmd_db_header) +	\
+				hdr.data_offset + ent.offset)
+
+/**
+ * struct entry_header: header for each entry in cmddb
+ *
+ * @id: resource's identifier
+ * @priority: unused
+ * @addr: the address of the resource
+ * @len: length of the data
+ * @offset: offset from :@data_offset, start of the data
+ */
+struct entry_header {
+	u64 id;
+	u32 priority[NUM_PRIORITY];
+	u32 addr;
+	u16 len;
+	u16 offset;
+};
+
+/**
+ * struct rsc_hdr: resource header information
+ *
+ * @slv_id: id for the resource
+ * @header_offset: entry's header at offset from the end of the cmd_db_header
+ * @data_offset: entry's data at offset from the end of the cmd_db_header
+ * @cnt: number of entries for HW type
+ * @version: MSB is major, LSB is minor
+ * @reserved: reserved for future use.
+ */
+struct rsc_hdr {
+	u16 slv_id;
+	u16 header_offset;
+	u16 data_offset;
+	u16 cnt;
+	u16 version;
+	u16 reserved[3];
+};
+
+/**
+ * struct cmd_db_header: The DB header information
+ *
+ * @version: The cmd db version
+ * @magic_number: constant expected in the database
+ * @header: array of resources
+ * @checksum: checksum for the header. Unused.
+ * @reserved: reserved memory
+ * @data: driver specific data
+ */
+struct cmd_db_header {
+	u32 version;
+	u32 magic_num;
+	struct rsc_hdr header[MAX_SLV_ID];
+	u32 checksum;
+	u32 reserved;
+	u8 data[];
+};
+
+/**
+ * DOC: Description of the Command DB database.
+ *
+ * At the start of the command DB memory is the cmd_db_header structure.
+ * The cmd_db_header holds the version, checksum, magic key as well as an
+ * array for header for each slave (depicted by the rsc_header). Each h/w
+ * based accelerator is a 'slave' (shared resource) and has slave id indicating
+ * the type of accelerator. The rsc_header is the header for such individual
+ * slaves of a given type. The entries for each of these slaves begin at the
+ * rsc_hdr.header_offset. In addition each slave could have auxiliary data
+ * that may be needed by the driver. The data for the slave starts at the
+ * entry_header.offset to the location pointed to by the rsc_hdr.data_offset.
+ *
+ * Drivers have a stringified key to a slave/resource. They can query the slave
+ * information and get the slave id and the auxiliary data and the length of the
+ * data. Using this information, they can format the request to be sent to the
+ * h/w accelerator and request a resource state.
+ */
+
+static struct cmd_db_header *cmd_db_header;
+
+/**
+ * cmd_db_ready - Indicates if command DB is available
+ *
+ * Return: 0 on success, errno otherwise
+ */
+int cmd_db_ready(void)
+{
+	if (cmd_db_header == NULL)
+		return -EPROBE_DEFER;
+	else if (cmd_db_header->magic_num != CMD_DB_MAGIC)
+		return -EINVAL;
+
+	return 0;
+}
+EXPORT_SYMBOL(cmd_db_ready);
+
+static u64 cmd_db_get_u64_id(const char *id)
+{
+	u64 rsc_id = 0;
+	u8 *ch = (u8 *)&rsc_id;
+
+	strncpy(ch, id, min(strlen(id), sizeof(rsc_id)));
+
+	return rsc_id;
+}
+
+static int cmd_db_get_header(u64 query, struct entry_header *eh,
+			     struct rsc_hdr *rh)
+{
+	struct rsc_hdr *rsc_hdr;
+	struct entry_header *ent;
+	int ret, i, j;
+
+	ret = cmd_db_ready();
+	if (ret)
+		return ret;
+
+	if (!eh || !rh)
+		return -EINVAL;
+
+	for (i = 0; i < MAX_SLV_ID; i++) {
+		rsc_hdr = &cmd_db_header->header[i];
+		if (!rsc_hdr->slv_id)
+			break;
+
+		ent = ENTRY_HEADER(rsc_hdr);
+		for (j = 0; j < rsc_hdr->cnt; j++, ent++) {
+			if (ent->id == query)
+				break;
+		}
+
+		if (j < rsc_hdr->cnt) {
+			memcpy(eh, ent, sizeof(*ent));
+			memcpy(rh, rsc_hdr, sizeof(*rh));
+			return 0;
+		}
+	}
+
+	return -ENODEV;
+}
+
+static int cmd_db_get_header_by_rsc_id(const char *id,
+				       struct entry_header *ent_hdr,
+				       struct rsc_hdr *rsc_hdr)
+{
+	u64 rsc_id = cmd_db_get_u64_id(id);
+
+	return cmd_db_get_header(rsc_id, ent_hdr, rsc_hdr);
+}
+
+/**
+ * cmd_db_read_addr() - Query command db for resource id address.
+ *
+ * @id: resource id to query for address
+ *
+ * Return: resource address on success, 0 on error
+ *
+ * This is used to retrieve resource address based on resource
+ * id.
+ */
+u32 cmd_db_read_addr(const char *id)
+{
+	int ret;
+	struct entry_header ent;
+	struct rsc_hdr rsc_hdr;
+
+	ret = cmd_db_get_header_by_rsc_id(id, &ent, &rsc_hdr);
+
+	return ret < 0 ? 0 : ent.addr;
+}
+EXPORT_SYMBOL(cmd_db_read_addr);
+
+/**
+ * cmd_db_read_aux_data() - Query command db for aux data.
+ *
+ *  @id: Resource to retrieve AUX Data on.
+ *  @data: Data buffer to copy returned aux data to. Returns size on NULL
+ *  @len: Caller provides size of data buffer passed in.
+ *
+ *  Return: size of data on success, errno otherwise
+ */
+int cmd_db_read_aux_data(const char *id, u8 *data, size_t len)
+{
+	int ret;
+	struct entry_header ent;
+	struct rsc_hdr rsc_hdr;
+
+	if (!data)
+		return -EINVAL;
+
+	ret = cmd_db_get_header_by_rsc_id(id, &ent, &rsc_hdr);
+	if (ret)
+		return ret;
+
+	if (len < ent.len)
+		return -EINVAL;
+
+	len = min_t(u16, ent.len, len);
+	memcpy(data, RSC_OFFSET(rsc_hdr, ent), len);
+
+	return len;
+}
+EXPORT_SYMBOL(cmd_db_read_aux_data);
+
+/**
+ * cmd_db_read_aux_data_len - Get the length of the auxiliary data stored in DB.
+ *
+ * @id: Resource to retrieve AUX Data.
+ *
+ * Return: size on success, 0 on error
+ */
+size_t cmd_db_read_aux_data_len(const char *id)
+{
+	int ret;
+	struct entry_header ent;
+	struct rsc_hdr rsc_hdr;
+
+	ret = cmd_db_get_header_by_rsc_id(id, &ent, &rsc_hdr);
+
+	return ret < 0 ? 0 : ent.len;
+}
+EXPORT_SYMBOL(cmd_db_read_aux_data_len);
+
+/**
+ * cmd_db_read_slave_id - Get the slave ID for a given resource address
+ *
+ * @id: Resource id to query the DB for version
+ *
+ * Return: cmd_db_hw_type enum on success, CMD_DB_HW_INVALID on error
+ */
+enum cmd_db_hw_type cmd_db_read_slave_id(const char *id)
+{
+	int ret;
+	struct entry_header ent;
+	struct rsc_hdr rsc_hdr;
+
+	ret = cmd_db_get_header_by_rsc_id(id, &ent, &rsc_hdr);
+
+	return ret < 0 ? CMD_DB_HW_INVALID :
+		       (ent.addr >> SLAVE_ID_SHIFT) & SLAVE_ID_MASK;
+}
+EXPORT_SYMBOL(cmd_db_read_slave_id);
+
+static int cmd_db_dev_probe(struct platform_device *pdev)
+{
+	struct reserved_mem *rmem;
+	int ret = 0;
+
+	rmem = of_reserved_mem_lookup(pdev->dev.of_node);
+	if (!rmem) {
+		dev_err(&pdev->dev, "failed to acquire memory region\n");
+		return -EINVAL;
+	}
+
+	cmd_db_header = memremap(rmem->base, rmem->size, MEMREMAP_WB);
+	if (IS_ERR_OR_NULL(cmd_db_header)) {
+		ret = PTR_ERR(cmd_db_header);
+		cmd_db_header = NULL;
+		return ret;
+	}
+
+	if (cmd_db_header->magic_num != CMD_DB_MAGIC) {
+		dev_err(&pdev->dev, "Invalid Command DB Magic\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static const struct of_device_id cmd_db_match_table[] = {
+	{ .compatible = "qcom,cmd-db" },
+	{ },
+};
+
+static struct platform_driver cmd_db_dev_driver = {
+	.probe  = cmd_db_dev_probe,
+	.driver = {
+		   .name = "cmd-db",
+		   .of_match_table = cmd_db_match_table,
+	},
+};
+
+static int __init cmd_db_device_init(void)
+{
+	return platform_driver_register(&cmd_db_dev_driver);
+}
+arch_initcall(cmd_db_device_init);
