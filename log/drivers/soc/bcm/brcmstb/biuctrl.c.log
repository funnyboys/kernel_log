commit add427c49e92c78519d0ff1728ea66d9e52f1fc9
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Sun Apr 7 14:40:50 2019 -0700

    soc: bcm: brcmstb: biuctrl: Update programming for 7211
    
    Add a matching entry for 7211 which can be programmed with the same
    BIUCTRL settings as other Brahma-B53 based SoCs. While at it, rename the
    function to include a72 in the name to reflect this applies to both
    types of 64-bit capable CPUs that we support (Brahma-B53 and
    Cortex-A72).
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>

diff --git a/drivers/soc/bcm/brcmstb/biuctrl.c b/drivers/soc/bcm/brcmstb/biuctrl.c
index d766577bc5d4..61731e01f94b 100644
--- a/drivers/soc/bcm/brcmstb/biuctrl.c
+++ b/drivers/soc/bcm/brcmstb/biuctrl.c
@@ -107,7 +107,8 @@ static int __init mcp_write_pairing_set(void)
 	return 0;
 }
 
-static const u32 b53_mach_compat[] = {
+static const u32 a72_b53_mach_compat[] = {
+	0x7211,
 	0x7216,
 	0x7255,
 	0x7260,
@@ -116,19 +117,19 @@ static const u32 b53_mach_compat[] = {
 	0x7278,
 };
 
-static void __init mcp_b53_set(void)
+static void __init mcp_a72_b53_set(void)
 {
 	unsigned int i;
 	u32 reg;
 
 	reg = brcmstb_get_family_id();
 
-	for (i = 0; i < ARRAY_SIZE(b53_mach_compat); i++) {
-		if (BRCM_ID(reg) == b53_mach_compat[i])
+	for (i = 0; i < ARRAY_SIZE(a72_b53_mach_compat); i++) {
+		if (BRCM_ID(reg) == a72_b53_mach_compat[i])
 			break;
 	}
 
-	if (i == ARRAY_SIZE(b53_mach_compat))
+	if (i == ARRAY_SIZE(a72_b53_mach_compat))
 		return;
 
 	/* Set all 3 MCP interfaces to 8 credits */
@@ -261,7 +262,7 @@ static int __init brcmstb_biuctrl_init(void)
 		return ret;
 	}
 
-	mcp_b53_set();
+	mcp_a72_b53_set();
 #ifdef CONFIG_PM_SLEEP
 	register_syscore_ops(&brcmstb_cpu_credit_syscore_ops);
 #endif

commit ea1e84d1bd3c0845f814f06d08005bb9cd6da700
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Mon Apr 1 20:03:32 2019 -0700

    soc: bcm: brcmstb: biuctrl: Update layout for A72 on 7211
    
    The BIUCTRL layout is a little different on 7211 which is equipped with
    a Cortex-A72, account for those register offset differences. We will
    match 7211 specifically in a subsequent commit.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>

diff --git a/drivers/soc/bcm/brcmstb/biuctrl.c b/drivers/soc/bcm/brcmstb/biuctrl.c
index 978cf52be664..d766577bc5d4 100644
--- a/drivers/soc/bcm/brcmstb/biuctrl.c
+++ b/drivers/soc/bcm/brcmstb/biuctrl.c
@@ -76,6 +76,12 @@ static const int b53_cpubiuctrl_regs[] = {
 	[CPU_WRITEBACK_CTRL_REG] = 0x22c,
 };
 
+static const int a72_cpubiuctrl_regs[] = {
+	[CPU_CREDIT_REG] = 0x18,
+	[CPU_MCP_FLOW_REG] = 0x1c,
+	[CPU_WRITEBACK_CTRL_REG] = 0x20,
+};
+
 #define NUM_CPU_BIUCTRL_REGS	3
 
 static int __init mcp_write_pairing_set(void)
@@ -183,6 +189,8 @@ static int __init setup_hifcpubiuctrl_regs(struct device_node *np)
 		cpubiuctrl_regs = b15_cpubiuctrl_regs;
 	else if (of_device_is_compatible(cpu_dn, "brcm,brahma-b53"))
 		cpubiuctrl_regs = b53_cpubiuctrl_regs;
+	else if (of_device_is_compatible(cpu_dn, "arm,cortex-a72"))
+		cpubiuctrl_regs = a72_cpubiuctrl_regs;
 	else {
 		pr_err("unsupported CPU\n");
 		ret = -EINVAL;

commit b2f91a39cfba5af101e95c2348b7932539e293b7
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Tue Dec 10 15:05:26 2019 -0800

    soc: bcm: brcmstb: biuctrl: Tune interface for 7255 and 7216
    
    7255 and 7216 are some of the latest chips that were produced and
    support the full register range configuration for the BIU, add the two
    entries to get the expected programming.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>

diff --git a/drivers/soc/bcm/brcmstb/biuctrl.c b/drivers/soc/bcm/brcmstb/biuctrl.c
index 6be975392590..978cf52be664 100644
--- a/drivers/soc/bcm/brcmstb/biuctrl.c
+++ b/drivers/soc/bcm/brcmstb/biuctrl.c
@@ -102,6 +102,8 @@ static int __init mcp_write_pairing_set(void)
 }
 
 static const u32 b53_mach_compat[] = {
+	0x7216,
+	0x7255,
 	0x7260,
 	0x7268,
 	0x7271,

commit 3098f5eb906b9e66b0a0b79b75d612261a6a7108
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Tue Dec 10 14:57:58 2019 -0800

    soc: bcm: brcmstb: biuctrl: Tune 7260 BIU interface
    
    7260A0 and B0 are both supported, and 7260A0 has a small difference in
    that it does not support the write-back control register, which is why
    we have a different array of registers. Update the comment above
    b53_cpubiuctrl_no_wb_regs to denote that difference.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>

diff --git a/drivers/soc/bcm/brcmstb/biuctrl.c b/drivers/soc/bcm/brcmstb/biuctrl.c
index d326915e0f40..6be975392590 100644
--- a/drivers/soc/bcm/brcmstb/biuctrl.c
+++ b/drivers/soc/bcm/brcmstb/biuctrl.c
@@ -63,7 +63,7 @@ static const int b15_cpubiuctrl_regs[] = {
 	[CPU_WRITEBACK_CTRL_REG] = -1,
 };
 
-/* Odd cases, e.g: 7260 */
+/* Odd cases, e.g: 7260A0 */
 static const int b53_cpubiuctrl_no_wb_regs[] = {
 	[CPU_CREDIT_REG] = 0x0b0,
 	[CPU_MCP_FLOW_REG] = 0x0b4,
@@ -102,6 +102,7 @@ static int __init mcp_write_pairing_set(void)
 }
 
 static const u32 b53_mach_compat[] = {
+	0x7260,
 	0x7268,
 	0x7271,
 	0x7278,
@@ -157,6 +158,7 @@ static void __init mcp_b53_set(void)
 static int __init setup_hifcpubiuctrl_regs(struct device_node *np)
 {
 	struct device_node *cpu_dn;
+	u32 family_id;
 	int ret = 0;
 
 	cpubiuctrl_base = of_iomap(np, 0);
@@ -185,7 +187,8 @@ static int __init setup_hifcpubiuctrl_regs(struct device_node *np)
 	}
 	of_node_put(cpu_dn);
 
-	if (BRCM_ID(brcmstb_get_family_id()) == 0x7260)
+	family_id = brcmstb_get_family_id();
+	if (BRCM_ID(family_id) == 0x7260 && BRCM_REV(family_id) == 0)
 		cpubiuctrl_regs = b53_cpubiuctrl_no_wb_regs;
 out:
 	of_node_put(np);

commit c1d6f4adf46592e825b77c43408cd929a80e9aba
Merge: 9e0babf2c06c 6b23af0783a5
Author: Olof Johansson <olof@lixom.net>
Date:   Sun Jun 16 13:24:59 2019 -0700

    Merge tag 'arm-soc/for-5.2/drivers-fixes' of https://github.com/Broadcom/stblinux into fixes
    
    This pull request contains Broadcom ARM/ARM64/MIPS SoCs device drivers
    fixes for 5.2-rc1, please pull the following:
    
    - Florian fixes the biuctrl driver not to create an error condition/path
      upon unsupported CPU and also fixes the biuctrl driver writes to used
      a data barrier which is necessary given the HW block design
    
    * tag 'arm-soc/for-5.2/drivers-fixes' of https://github.com/Broadcom/stblinux:
      soc: bcm: brcmstb: biuctrl: Register writes require a barrier
      soc: brcmstb: Fix error path for unsupported CPUs
    
    Signed-off-by: Olof Johansson <olof@lixom.net>

commit 1802d0beecafe581ad584634ba92f8a471d8a63a
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:21 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 174
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation this program is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 655 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070034.575739538@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/soc/bcm/brcmstb/biuctrl.c b/drivers/soc/bcm/brcmstb/biuctrl.c
index 6d89ebf13b8a..b3dbdb365749 100644
--- a/drivers/soc/bcm/brcmstb/biuctrl.c
+++ b/drivers/soc/bcm/brcmstb/biuctrl.c
@@ -1,16 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Broadcom STB SoCs Bus Unit Interface controls
  *
  * Copyright (C) 2015, Broadcom Corporation
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
  */
 
 #define pr_fmt(fmt)	"brcmstb: " KBUILD_MODNAME ": " fmt

commit 6b23af0783a54efb348f0bd781b7850636023dbb
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Fri Apr 12 10:15:26 2019 -0700

    soc: bcm: brcmstb: biuctrl: Register writes require a barrier
    
    The BIUCTRL register writes require that a data barrier be inserted
    after comitting the write to the register for the block to latch in the
    recently written values. Reads have no such requirement and are not
    changed.
    
    Fixes: 34642650e5bc ("soc: Move brcmstb to bcm/brcmstb")
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>

diff --git a/drivers/soc/bcm/brcmstb/biuctrl.c b/drivers/soc/bcm/brcmstb/biuctrl.c
index c16273b31b94..20b63bee5b09 100644
--- a/drivers/soc/bcm/brcmstb/biuctrl.c
+++ b/drivers/soc/bcm/brcmstb/biuctrl.c
@@ -56,7 +56,7 @@ static inline void cbc_writel(u32 val, int reg)
 	if (offset == -1)
 		return;
 
-	writel_relaxed(val,  cpubiuctrl_base + offset);
+	writel(val, cpubiuctrl_base + offset);
 }
 
 enum cpubiuctrl_regs {

commit 490cad5a3ad6ef0bfd3168a5063140b982f3b22a
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Sun Apr 7 14:19:07 2019 -0700

    soc: brcmstb: Fix error path for unsupported CPUs
    
    In case setup_hifcpubiuctrl_regs() returns an error, because of e.g:
    an unsupported CPU type, just catch that error and return instead of
    blindly continuing with the initialization. This fixes a NULL pointer
    de-reference with the code continuing without having a proper array of
    registers to use.
    
    Fixes: 22f7a9116eba ("soc: brcmstb: Correct CPU_CREDIT_REG offset for Brahma-B53 CPUs")
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>

diff --git a/drivers/soc/bcm/brcmstb/biuctrl.c b/drivers/soc/bcm/brcmstb/biuctrl.c
index 6d89ebf13b8a..c16273b31b94 100644
--- a/drivers/soc/bcm/brcmstb/biuctrl.c
+++ b/drivers/soc/bcm/brcmstb/biuctrl.c
@@ -246,7 +246,9 @@ static int __init brcmstb_biuctrl_init(void)
 	if (!np)
 		return 0;
 
-	setup_hifcpubiuctrl_regs(np);
+	ret = setup_hifcpubiuctrl_regs(np);
+	if (ret)
+		return ret;
 
 	ret = mcp_write_pairing_set();
 	if (ret) {

commit a78182980a2a0045d5971a656248a62d62237234
Author: Sudeep Holla <sudeep.holla@arm.com>
Date:   Fri Jan 12 13:08:14 2018 -0800

    soc: brcmstb: biuctrl: exit without warning on non brcmstb platforms
    
    Currently if this driver is included, we get the following warning
    on any platforms irrespective of whether it's brcmstb platform or not.
    "
     brcmstb: biuctrl: missing BIU control node
     brcmstb: biuctrl: MCP: Unable to disable write pairing!
    "
    
    This patch allows to exit early without any warning messages on non
    brcmstb platforms as it's meaningless for them.
    
    Cc: Brian Norris <computersforpeace@gmail.com>
    Cc: Gregory Fong <gregory.0xf0@gmail.com>
    Cc: Florian Fainelli <f.fainelli@gmail.com>
    Cc: bcm-kernel-feedback-list@broadcom.com
    Fixes: f780429adfbc ("soc: brcmstb: biuctrl: Move to early_initcall")
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>
    [florian: Add fixes tag, make initcall non fatal]
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/drivers/soc/bcm/brcmstb/biuctrl.c b/drivers/soc/bcm/brcmstb/biuctrl.c
index 2b23ae7b5e9b..6d89ebf13b8a 100644
--- a/drivers/soc/bcm/brcmstb/biuctrl.c
+++ b/drivers/soc/bcm/brcmstb/biuctrl.c
@@ -162,17 +162,11 @@ static void __init mcp_b53_set(void)
 	cbc_writel(reg, CPU_WRITEBACK_CTRL_REG);
 }
 
-static int __init setup_hifcpubiuctrl_regs(void)
+static int __init setup_hifcpubiuctrl_regs(struct device_node *np)
 {
-	struct device_node *np, *cpu_dn;
+	struct device_node *cpu_dn;
 	int ret = 0;
 
-	np = of_find_compatible_node(NULL, NULL, "brcm,brcmstb-cpu-biu-ctrl");
-	if (!np) {
-		pr_err("missing BIU control node\n");
-		return -ENODEV;
-	}
-
 	cpubiuctrl_base = of_iomap(np, 0);
 	if (!cpubiuctrl_base) {
 		pr_err("failed to remap BIU control base\n");
@@ -242,9 +236,17 @@ static struct syscore_ops brcmstb_cpu_credit_syscore_ops = {
 
 static int __init brcmstb_biuctrl_init(void)
 {
+	struct device_node *np;
 	int ret;
 
-	setup_hifcpubiuctrl_regs();
+	/* We might be running on a multi-platform kernel, don't make this a
+	 * fatal error, just bail out early
+	 */
+	np = of_find_compatible_node(NULL, NULL, "brcm,brcmstb-cpu-biu-ctrl");
+	if (!np)
+		return 0;
+
+	setup_hifcpubiuctrl_regs(np);
 
 	ret = mcp_write_pairing_set();
 	if (ret) {

commit f780429adfbc222a4d8a227a2a550ba627c7338b
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Tue Apr 11 17:26:11 2017 -0700

    soc: brcmstb: biuctrl: Move to early_initcall
    
    Being called during early_initcall() is early enough that it occurs
    before SMP initialization, which is all we care about for the Bus
    Interface Unit configuration.
    
    This solves lack of BIU initialization on ARM64 platforms where we do
    not have an anchor where to put the BIU initialization (since there are
    no machine descriptors).
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>

diff --git a/drivers/soc/bcm/brcmstb/biuctrl.c b/drivers/soc/bcm/brcmstb/biuctrl.c
index dd45bbfe64dd..2b23ae7b5e9b 100644
--- a/drivers/soc/bcm/brcmstb/biuctrl.c
+++ b/drivers/soc/bcm/brcmstb/biuctrl.c
@@ -240,7 +240,7 @@ static struct syscore_ops brcmstb_cpu_credit_syscore_ops = {
 #endif
 
 
-void __init brcmstb_biuctrl_init(void)
+static int __init brcmstb_biuctrl_init(void)
 {
 	int ret;
 
@@ -249,11 +249,13 @@ void __init brcmstb_biuctrl_init(void)
 	ret = mcp_write_pairing_set();
 	if (ret) {
 		pr_err("MCP: Unable to disable write pairing!\n");
-		return;
+		return ret;
 	}
 
 	mcp_b53_set();
 #ifdef CONFIG_PM_SLEEP
 	register_syscore_ops(&brcmstb_cpu_credit_syscore_ops);
 #endif
+	return 0;
 }
+early_initcall(brcmstb_biuctrl_init);

commit b4b32e321639859738e0226f42e05ed0f7e2fc64
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Mon Feb 27 17:35:03 2017 -0800

    soc: brcmstb: biuctrl: Fine tune B53 MCP interface settings
    
    In order to achieve expected MCP bus throughput on 3 particular chips:
    7268, 7271 and 7278, do the appropriate programming of the MCP
    interface: increase number of MCP write credits, turn on write-back
    throttling when present.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>

diff --git a/drivers/soc/bcm/brcmstb/biuctrl.c b/drivers/soc/bcm/brcmstb/biuctrl.c
index d498f9db01ab..dd45bbfe64dd 100644
--- a/drivers/soc/bcm/brcmstb/biuctrl.c
+++ b/drivers/soc/bcm/brcmstb/biuctrl.c
@@ -22,6 +22,18 @@
 #include <linux/soc/brcmstb/brcmstb.h>
 
 #define  CPU_CREDIT_REG_MCPx_WR_PAIRING_EN_MASK	0x70000000
+#define CPU_CREDIT_REG_MCPx_READ_CRED_MASK	0xf
+#define CPU_CREDIT_REG_MCPx_WRITE_CRED_MASK	0xf
+#define CPU_CREDIT_REG_MCPx_READ_CRED_SHIFT(x)	((x) * 8)
+#define CPU_CREDIT_REG_MCPx_WRITE_CRED_SHIFT(x)	(((x) * 8) + 4)
+
+#define CPU_MCP_FLOW_REG_MCPx_RDBUFF_CRED_SHIFT(x)	((x) * 8)
+#define CPU_MCP_FLOW_REG_MCPx_RDBUFF_CRED_MASK		0xff
+
+#define CPU_WRITEBACK_CTRL_REG_WB_THROTTLE_THRESHOLD_MASK	0xf
+#define CPU_WRITEBACK_CTRL_REG_WB_THROTTLE_TIMEOUT_MASK		0xf
+#define CPU_WRITEBACK_CTRL_REG_WB_THROTTLE_TIMEOUT_SHIFT	4
+#define CPU_WRITEBACK_CTRL_REG_WB_THROTTLE_ENABLE		BIT(8)
 
 static void __iomem *cpubiuctrl_base;
 static bool mcp_wr_pairing_en;
@@ -59,6 +71,13 @@ static const int b15_cpubiuctrl_regs[] = {
 	[CPU_WRITEBACK_CTRL_REG] = -1,
 };
 
+/* Odd cases, e.g: 7260 */
+static const int b53_cpubiuctrl_no_wb_regs[] = {
+	[CPU_CREDIT_REG] = 0x0b0,
+	[CPU_MCP_FLOW_REG] = 0x0b4,
+	[CPU_WRITEBACK_CTRL_REG] = -1,
+};
+
 static const int b53_cpubiuctrl_regs[] = {
 	[CPU_CREDIT_REG] = 0x0b0,
 	[CPU_MCP_FLOW_REG] = 0x0b4,
@@ -90,6 +109,59 @@ static int __init mcp_write_pairing_set(void)
 	return 0;
 }
 
+static const u32 b53_mach_compat[] = {
+	0x7268,
+	0x7271,
+	0x7278,
+};
+
+static void __init mcp_b53_set(void)
+{
+	unsigned int i;
+	u32 reg;
+
+	reg = brcmstb_get_family_id();
+
+	for (i = 0; i < ARRAY_SIZE(b53_mach_compat); i++) {
+		if (BRCM_ID(reg) == b53_mach_compat[i])
+			break;
+	}
+
+	if (i == ARRAY_SIZE(b53_mach_compat))
+		return;
+
+	/* Set all 3 MCP interfaces to 8 credits */
+	reg = cbc_readl(CPU_CREDIT_REG);
+	for (i = 0; i < 3; i++) {
+		reg &= ~(CPU_CREDIT_REG_MCPx_WRITE_CRED_MASK <<
+			 CPU_CREDIT_REG_MCPx_WRITE_CRED_SHIFT(i));
+		reg &= ~(CPU_CREDIT_REG_MCPx_READ_CRED_MASK <<
+			 CPU_CREDIT_REG_MCPx_READ_CRED_SHIFT(i));
+		reg |= 8 << CPU_CREDIT_REG_MCPx_WRITE_CRED_SHIFT(i);
+		reg |= 8 << CPU_CREDIT_REG_MCPx_READ_CRED_SHIFT(i);
+	}
+	cbc_writel(reg, CPU_CREDIT_REG);
+
+	/* Max out the number of in-flight Jwords reads on the MCP interface */
+	reg = cbc_readl(CPU_MCP_FLOW_REG);
+	for (i = 0; i < 3; i++)
+		reg |= CPU_MCP_FLOW_REG_MCPx_RDBUFF_CRED_MASK <<
+			CPU_MCP_FLOW_REG_MCPx_RDBUFF_CRED_SHIFT(i);
+	cbc_writel(reg, CPU_MCP_FLOW_REG);
+
+	/* Enable writeback throttling, set timeout to 128 cycles, 256 cycles
+	 * threshold
+	 */
+	reg = cbc_readl(CPU_WRITEBACK_CTRL_REG);
+	reg |= CPU_WRITEBACK_CTRL_REG_WB_THROTTLE_ENABLE;
+	reg &= ~CPU_WRITEBACK_CTRL_REG_WB_THROTTLE_THRESHOLD_MASK;
+	reg &= ~(CPU_WRITEBACK_CTRL_REG_WB_THROTTLE_TIMEOUT_MASK <<
+		 CPU_WRITEBACK_CTRL_REG_WB_THROTTLE_TIMEOUT_SHIFT);
+	reg |= 8;
+	reg |= 7 << CPU_WRITEBACK_CTRL_REG_WB_THROTTLE_TIMEOUT_SHIFT;
+	cbc_writel(reg, CPU_WRITEBACK_CTRL_REG);
+}
+
 static int __init setup_hifcpubiuctrl_regs(void)
 {
 	struct device_node *np, *cpu_dn;
@@ -126,6 +198,9 @@ static int __init setup_hifcpubiuctrl_regs(void)
 		ret = -EINVAL;
 	}
 	of_node_put(cpu_dn);
+
+	if (BRCM_ID(brcmstb_get_family_id()) == 0x7260)
+		cpubiuctrl_regs = b53_cpubiuctrl_no_wb_regs;
 out:
 	of_node_put(np);
 	return ret;
@@ -177,6 +252,7 @@ void __init brcmstb_biuctrl_init(void)
 		return;
 	}
 
+	mcp_b53_set();
 #ifdef CONFIG_PM_SLEEP
 	register_syscore_ops(&brcmstb_cpu_credit_syscore_ops);
 #endif

commit 6451d644b8f3d7188778bac60e3543274b41ae30
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Mon Feb 27 16:40:05 2017 -0800

    soc: brcmstb: biuctrl: Wire-up new registers
    
    Add definitions for B53 systems register: CPU_MCP_FLOW_REG and
    CPU_WRITEBACK_CTRL_REG. These register will be saved and restored
    accordingly.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>

diff --git a/drivers/soc/bcm/brcmstb/biuctrl.c b/drivers/soc/bcm/brcmstb/biuctrl.c
index 16cbfc2e953a..d498f9db01ab 100644
--- a/drivers/soc/bcm/brcmstb/biuctrl.c
+++ b/drivers/soc/bcm/brcmstb/biuctrl.c
@@ -49,17 +49,23 @@ static inline void cbc_writel(u32 val, int reg)
 
 enum cpubiuctrl_regs {
 	CPU_CREDIT_REG = 0,
+	CPU_MCP_FLOW_REG,
+	CPU_WRITEBACK_CTRL_REG
 };
 
 static const int b15_cpubiuctrl_regs[] = {
 	[CPU_CREDIT_REG] = 0x184,
+	[CPU_MCP_FLOW_REG] = -1,
+	[CPU_WRITEBACK_CTRL_REG] = -1,
 };
 
 static const int b53_cpubiuctrl_regs[] = {
 	[CPU_CREDIT_REG] = 0x0b0,
+	[CPU_MCP_FLOW_REG] = 0x0b4,
+	[CPU_WRITEBACK_CTRL_REG] = 0x22c,
 };
 
-#define NUM_CPU_BIUCTRL_REGS	1
+#define NUM_CPU_BIUCTRL_REGS	3
 
 static int __init mcp_write_pairing_set(void)
 {

commit 584e55d543d86ebbc0ddb28f55619292e6eb308a
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Mon Feb 27 16:36:17 2017 -0800

    soc: brcmstb: biuctrl: Prepare for saving/restoring other registers
    
    In preparation for saving/restoring additional registers required on
    some newer platforms (7268, 7271, 7278), migrate the code to use enums
    and helper functions to access registers.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>

diff --git a/drivers/soc/bcm/brcmstb/biuctrl.c b/drivers/soc/bcm/brcmstb/biuctrl.c
index e8322e663831..16cbfc2e953a 100644
--- a/drivers/soc/bcm/brcmstb/biuctrl.c
+++ b/drivers/soc/bcm/brcmstb/biuctrl.c
@@ -21,13 +21,45 @@
 #include <linux/syscore_ops.h>
 #include <linux/soc/brcmstb/brcmstb.h>
 
-#define B15_CPU_CREDIT_REG_OFFSET		0x184
-#define B53_CPU_CREDIT_REG_OFFSET		0x0b0
 #define  CPU_CREDIT_REG_MCPx_WR_PAIRING_EN_MASK	0x70000000
 
 static void __iomem *cpubiuctrl_base;
 static bool mcp_wr_pairing_en;
-static unsigned int cpu_credit_reg_offset;
+static const int *cpubiuctrl_regs;
+
+static inline u32 cbc_readl(int reg)
+{
+	int offset = cpubiuctrl_regs[reg];
+
+	if (offset == -1)
+		return (u32)-1;
+
+	return readl_relaxed(cpubiuctrl_base + offset);
+}
+
+static inline void cbc_writel(u32 val, int reg)
+{
+	int offset = cpubiuctrl_regs[reg];
+
+	if (offset == -1)
+		return;
+
+	writel_relaxed(val,  cpubiuctrl_base + offset);
+}
+
+enum cpubiuctrl_regs {
+	CPU_CREDIT_REG = 0,
+};
+
+static const int b15_cpubiuctrl_regs[] = {
+	[CPU_CREDIT_REG] = 0x184,
+};
+
+static const int b53_cpubiuctrl_regs[] = {
+	[CPU_CREDIT_REG] = 0x0b0,
+};
+
+#define NUM_CPU_BIUCTRL_REGS	1
 
 static int __init mcp_write_pairing_set(void)
 {
@@ -36,15 +68,15 @@ static int __init mcp_write_pairing_set(void)
 	if (!cpubiuctrl_base)
 		return -1;
 
-	creds = readl_relaxed(cpubiuctrl_base + cpu_credit_reg_offset);
+	creds = cbc_readl(CPU_CREDIT_REG);
 	if (mcp_wr_pairing_en) {
 		pr_info("MCP: Enabling write pairing\n");
-		writel_relaxed(creds | CPU_CREDIT_REG_MCPx_WR_PAIRING_EN_MASK,
-			     cpubiuctrl_base + cpu_credit_reg_offset);
+		cbc_writel(creds | CPU_CREDIT_REG_MCPx_WR_PAIRING_EN_MASK,
+			   CPU_CREDIT_REG);
 	} else if (creds & CPU_CREDIT_REG_MCPx_WR_PAIRING_EN_MASK) {
 		pr_info("MCP: Disabling write pairing\n");
-		writel_relaxed(creds & ~CPU_CREDIT_REG_MCPx_WR_PAIRING_EN_MASK,
-				cpubiuctrl_base + cpu_credit_reg_offset);
+		cbc_writel(creds & ~CPU_CREDIT_REG_MCPx_WR_PAIRING_EN_MASK,
+			   CPU_CREDIT_REG);
 	} else {
 		pr_info("MCP: Write pairing already disabled\n");
 	}
@@ -80,9 +112,9 @@ static int __init setup_hifcpubiuctrl_regs(void)
 	}
 
 	if (of_device_is_compatible(cpu_dn, "brcm,brahma-b15"))
-		cpu_credit_reg_offset = B15_CPU_CREDIT_REG_OFFSET;
+		cpubiuctrl_regs = b15_cpubiuctrl_regs;
 	else if (of_device_is_compatible(cpu_dn, "brcm,brahma-b53"))
-		cpu_credit_reg_offset = B53_CPU_CREDIT_REG_OFFSET;
+		cpubiuctrl_regs = b53_cpubiuctrl_regs;
 	else {
 		pr_err("unsupported CPU\n");
 		ret = -EINVAL;
@@ -94,21 +126,30 @@ static int __init setup_hifcpubiuctrl_regs(void)
 }
 
 #ifdef CONFIG_PM_SLEEP
-static u32 cpu_credit_reg_dump;  /* for save/restore */
+static u32 cpubiuctrl_reg_save[NUM_CPU_BIUCTRL_REGS];
 
 static int brcmstb_cpu_credit_reg_suspend(void)
 {
-	if (cpubiuctrl_base)
-		cpu_credit_reg_dump =
-			readl_relaxed(cpubiuctrl_base + cpu_credit_reg_offset);
+	unsigned int i;
+
+	if (!cpubiuctrl_base)
+		return 0;
+
+	for (i = 0; i < NUM_CPU_BIUCTRL_REGS; i++)
+		cpubiuctrl_reg_save[i] = cbc_readl(i);
+
 	return 0;
 }
 
 static void brcmstb_cpu_credit_reg_resume(void)
 {
-	if (cpubiuctrl_base)
-		writel_relaxed(cpu_credit_reg_dump,
-				cpubiuctrl_base + cpu_credit_reg_offset);
+	unsigned int i;
+
+	if (!cpubiuctrl_base)
+		return;
+
+	for (i = 0; i < NUM_CPU_BIUCTRL_REGS; i++)
+		cbc_writel(cpubiuctrl_reg_save[i], i);
 }
 
 static struct syscore_ops brcmstb_cpu_credit_syscore_ops = {

commit 22f7a9116eba9a5f16341706f83b9e09098b15f9
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Tue Jan 31 14:54:00 2017 -0800

    soc: brcmstb: Correct CPU_CREDIT_REG offset for Brahma-B53 CPUs
    
    On Broadcom Brahma-B53 CPUs, the CPU_CREDIT_REG offset got moved to
    0x0b0 instead of 0x184, correct this such that we correcty
    enable/disable write-pairing for these chips.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>

diff --git a/drivers/soc/bcm/brcmstb/biuctrl.c b/drivers/soc/bcm/brcmstb/biuctrl.c
index c3c548fcaa8c..e8322e663831 100644
--- a/drivers/soc/bcm/brcmstb/biuctrl.c
+++ b/drivers/soc/bcm/brcmstb/biuctrl.c
@@ -21,12 +21,13 @@
 #include <linux/syscore_ops.h>
 #include <linux/soc/brcmstb/brcmstb.h>
 
-#define CPU_CREDIT_REG_OFFSET			0x184
+#define B15_CPU_CREDIT_REG_OFFSET		0x184
+#define B53_CPU_CREDIT_REG_OFFSET		0x0b0
 #define  CPU_CREDIT_REG_MCPx_WR_PAIRING_EN_MASK	0x70000000
 
 static void __iomem *cpubiuctrl_base;
 static bool mcp_wr_pairing_en;
-static unsigned int cpu_credit_reg_offset = CPU_CREDIT_REG_OFFSET;
+static unsigned int cpu_credit_reg_offset;
 
 static int __init mcp_write_pairing_set(void)
 {
@@ -53,7 +54,7 @@ static int __init mcp_write_pairing_set(void)
 
 static int __init setup_hifcpubiuctrl_regs(void)
 {
-	struct device_node *np;
+	struct device_node *np, *cpu_dn;
 	int ret = 0;
 
 	np = of_find_compatible_node(NULL, NULL, "brcm,brcmstb-cpu-biu-ctrl");
@@ -70,6 +71,23 @@ static int __init setup_hifcpubiuctrl_regs(void)
 	}
 
 	mcp_wr_pairing_en = of_property_read_bool(np, "brcm,write-pairing");
+
+	cpu_dn = of_get_cpu_node(0, NULL);
+	if (!cpu_dn) {
+		pr_err("failed to obtain CPU device node\n");
+		ret = -ENODEV;
+		goto out;
+	}
+
+	if (of_device_is_compatible(cpu_dn, "brcm,brahma-b15"))
+		cpu_credit_reg_offset = B15_CPU_CREDIT_REG_OFFSET;
+	else if (of_device_is_compatible(cpu_dn, "brcm,brahma-b53"))
+		cpu_credit_reg_offset = B53_CPU_CREDIT_REG_OFFSET;
+	else {
+		pr_err("unsupported CPU\n");
+		ret = -EINVAL;
+	}
+	of_node_put(cpu_dn);
 out:
 	of_node_put(np);
 	return ret;

commit 9257091cf6df707b64989f15c1e2d4311d694ad3
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Tue Jan 31 14:47:45 2017 -0800

    soc: brcmstb: Make CPU credit offset more parameterized
    
    In preparation for fixing and changing values in the CPU_CREDIT_REG
    register for B53-based systems, make the offset parameterized.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>

diff --git a/drivers/soc/bcm/brcmstb/biuctrl.c b/drivers/soc/bcm/brcmstb/biuctrl.c
index 3c39415d484f..c3c548fcaa8c 100644
--- a/drivers/soc/bcm/brcmstb/biuctrl.c
+++ b/drivers/soc/bcm/brcmstb/biuctrl.c
@@ -26,6 +26,7 @@
 
 static void __iomem *cpubiuctrl_base;
 static bool mcp_wr_pairing_en;
+static unsigned int cpu_credit_reg_offset = CPU_CREDIT_REG_OFFSET;
 
 static int __init mcp_write_pairing_set(void)
 {
@@ -34,15 +35,15 @@ static int __init mcp_write_pairing_set(void)
 	if (!cpubiuctrl_base)
 		return -1;
 
-	creds = readl_relaxed(cpubiuctrl_base + CPU_CREDIT_REG_OFFSET);
+	creds = readl_relaxed(cpubiuctrl_base + cpu_credit_reg_offset);
 	if (mcp_wr_pairing_en) {
 		pr_info("MCP: Enabling write pairing\n");
 		writel_relaxed(creds | CPU_CREDIT_REG_MCPx_WR_PAIRING_EN_MASK,
-			     cpubiuctrl_base + CPU_CREDIT_REG_OFFSET);
+			     cpubiuctrl_base + cpu_credit_reg_offset);
 	} else if (creds & CPU_CREDIT_REG_MCPx_WR_PAIRING_EN_MASK) {
 		pr_info("MCP: Disabling write pairing\n");
 		writel_relaxed(creds & ~CPU_CREDIT_REG_MCPx_WR_PAIRING_EN_MASK,
-				cpubiuctrl_base + CPU_CREDIT_REG_OFFSET);
+				cpubiuctrl_base + cpu_credit_reg_offset);
 	} else {
 		pr_info("MCP: Write pairing already disabled\n");
 	}
@@ -81,7 +82,7 @@ static int brcmstb_cpu_credit_reg_suspend(void)
 {
 	if (cpubiuctrl_base)
 		cpu_credit_reg_dump =
-			readl_relaxed(cpubiuctrl_base + CPU_CREDIT_REG_OFFSET);
+			readl_relaxed(cpubiuctrl_base + cpu_credit_reg_offset);
 	return 0;
 }
 
@@ -89,7 +90,7 @@ static void brcmstb_cpu_credit_reg_resume(void)
 {
 	if (cpubiuctrl_base)
 		writel_relaxed(cpu_credit_reg_dump,
-				cpubiuctrl_base + CPU_CREDIT_REG_OFFSET);
+				cpubiuctrl_base + cpu_credit_reg_offset);
 }
 
 static struct syscore_ops brcmstb_cpu_credit_syscore_ops = {

commit a536bcc931ed5c047100c3a28f521283749d3b9a
Author: Ben Dooks <ben.dooks@codethink.co.uk>
Date:   Tue Jun 7 18:54:54 2016 +0100

    soc: brcmstb: fix warning from missing include
    
    The brcmstb_biuctrl_init() is defined in the soc specific header
    file, but wasn't included in the driver file. Fix the following
    warning by including <linux/soc/brcmstb/brcmstb.h> in the driver:
    
    drivers/soc/brcmstb/biuctrl.c:101:13: warning: symbol 'brcmstb_biuctrl_init' was not declared. Should it be static?
    
    Signed-off-by: Ben Dooks <ben.dooks@codethink.co.uk>
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>

diff --git a/drivers/soc/bcm/brcmstb/biuctrl.c b/drivers/soc/bcm/brcmstb/biuctrl.c
index 9049c076f9a1..3c39415d484f 100644
--- a/drivers/soc/bcm/brcmstb/biuctrl.c
+++ b/drivers/soc/bcm/brcmstb/biuctrl.c
@@ -19,6 +19,7 @@
 #include <linux/io.h>
 #include <linux/of_address.h>
 #include <linux/syscore_ops.h>
+#include <linux/soc/brcmstb/brcmstb.h>
 
 #define CPU_CREDIT_REG_OFFSET			0x184
 #define  CPU_CREDIT_REG_MCPx_WR_PAIRING_EN_MASK	0x70000000

commit 34642650e5bc052674b982433631fcc619237225
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Fri May 20 11:35:57 2016 -0700

    soc: Move brcmstb to bcm/brcmstb
    
    Unify the different Broadcom SoCs directory and have everybody live
    under drivers/soc/bcm/*.
    
    Acked-by: Scott Branden <scott.branden@broadcom.com>
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>

diff --git a/drivers/soc/bcm/brcmstb/biuctrl.c b/drivers/soc/bcm/brcmstb/biuctrl.c
new file mode 100644
index 000000000000..9049c076f9a1
--- /dev/null
+++ b/drivers/soc/bcm/brcmstb/biuctrl.c
@@ -0,0 +1,116 @@
+/*
+ * Broadcom STB SoCs Bus Unit Interface controls
+ *
+ * Copyright (C) 2015, Broadcom Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#define pr_fmt(fmt)	"brcmstb: " KBUILD_MODNAME ": " fmt
+
+#include <linux/kernel.h>
+#include <linux/io.h>
+#include <linux/of_address.h>
+#include <linux/syscore_ops.h>
+
+#define CPU_CREDIT_REG_OFFSET			0x184
+#define  CPU_CREDIT_REG_MCPx_WR_PAIRING_EN_MASK	0x70000000
+
+static void __iomem *cpubiuctrl_base;
+static bool mcp_wr_pairing_en;
+
+static int __init mcp_write_pairing_set(void)
+{
+	u32 creds = 0;
+
+	if (!cpubiuctrl_base)
+		return -1;
+
+	creds = readl_relaxed(cpubiuctrl_base + CPU_CREDIT_REG_OFFSET);
+	if (mcp_wr_pairing_en) {
+		pr_info("MCP: Enabling write pairing\n");
+		writel_relaxed(creds | CPU_CREDIT_REG_MCPx_WR_PAIRING_EN_MASK,
+			     cpubiuctrl_base + CPU_CREDIT_REG_OFFSET);
+	} else if (creds & CPU_CREDIT_REG_MCPx_WR_PAIRING_EN_MASK) {
+		pr_info("MCP: Disabling write pairing\n");
+		writel_relaxed(creds & ~CPU_CREDIT_REG_MCPx_WR_PAIRING_EN_MASK,
+				cpubiuctrl_base + CPU_CREDIT_REG_OFFSET);
+	} else {
+		pr_info("MCP: Write pairing already disabled\n");
+	}
+
+	return 0;
+}
+
+static int __init setup_hifcpubiuctrl_regs(void)
+{
+	struct device_node *np;
+	int ret = 0;
+
+	np = of_find_compatible_node(NULL, NULL, "brcm,brcmstb-cpu-biu-ctrl");
+	if (!np) {
+		pr_err("missing BIU control node\n");
+		return -ENODEV;
+	}
+
+	cpubiuctrl_base = of_iomap(np, 0);
+	if (!cpubiuctrl_base) {
+		pr_err("failed to remap BIU control base\n");
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	mcp_wr_pairing_en = of_property_read_bool(np, "brcm,write-pairing");
+out:
+	of_node_put(np);
+	return ret;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static u32 cpu_credit_reg_dump;  /* for save/restore */
+
+static int brcmstb_cpu_credit_reg_suspend(void)
+{
+	if (cpubiuctrl_base)
+		cpu_credit_reg_dump =
+			readl_relaxed(cpubiuctrl_base + CPU_CREDIT_REG_OFFSET);
+	return 0;
+}
+
+static void brcmstb_cpu_credit_reg_resume(void)
+{
+	if (cpubiuctrl_base)
+		writel_relaxed(cpu_credit_reg_dump,
+				cpubiuctrl_base + CPU_CREDIT_REG_OFFSET);
+}
+
+static struct syscore_ops brcmstb_cpu_credit_syscore_ops = {
+	.suspend = brcmstb_cpu_credit_reg_suspend,
+	.resume = brcmstb_cpu_credit_reg_resume,
+};
+#endif
+
+
+void __init brcmstb_biuctrl_init(void)
+{
+	int ret;
+
+	setup_hifcpubiuctrl_regs();
+
+	ret = mcp_write_pairing_set();
+	if (ret) {
+		pr_err("MCP: Unable to disable write pairing!\n");
+		return;
+	}
+
+#ifdef CONFIG_PM_SLEEP
+	register_syscore_ops(&brcmstb_cpu_credit_syscore_ops);
+#endif
+}
