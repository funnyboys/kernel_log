commit 1802d0beecafe581ad584634ba92f8a471d8a63a
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:21 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 174
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation this program is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 655 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070034.575739538@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/soc/bcm/brcmstb/common.c b/drivers/soc/bcm/brcmstb/common.c
index bf9123f727e8..d33a383701dd 100644
--- a/drivers/soc/bcm/brcmstb/common.c
+++ b/drivers/soc/bcm/brcmstb/common.c
@@ -1,15 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Copyright © 2014 NVIDIA Corporation
  * Copyright © 2015 Broadcom Corporation
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
  */
 
 #include <linux/io.h>

commit 1861a7f07e02292830a1ca256328d370deefea30
Author: Yangtao Li <tiny.windzz@gmail.com>
Date:   Sat Nov 24 09:52:23 2018 -0500

    soc: bcm: brcmstb: Don't leak device tree node reference
    
    of_find_node_by_path() acquires a reference to the node returned by it
    and that reference needs to be dropped by its caller. soc_is_brcmstb()
    doesn't do that, so fix it.
    
    [treding: slightly rewrite to avoid inline comparison]
    
    Fixes: d52fad262041 ("soc: add stubs for brcmstb SoC's")
    Signed-off-by: Yangtao Li <tiny.windzz@gmail.com>
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>

diff --git a/drivers/soc/bcm/brcmstb/common.c b/drivers/soc/bcm/brcmstb/common.c
index 14185451901d..bf9123f727e8 100644
--- a/drivers/soc/bcm/brcmstb/common.c
+++ b/drivers/soc/bcm/brcmstb/common.c
@@ -31,13 +31,17 @@ static const struct of_device_id brcmstb_machine_match[] = {
 
 bool soc_is_brcmstb(void)
 {
+	const struct of_device_id *match;
 	struct device_node *root;
 
 	root = of_find_node_by_path("/");
 	if (!root)
 		return false;
 
-	return of_match_node(brcmstb_machine_match, root) != NULL;
+	match = of_match_node(brcmstb_machine_match, root);
+	of_node_put(root);
+
+	return match != NULL;
 }
 
 u32 brcmstb_get_family_id(void)

commit c5b40c315a8671da99b35ace2484d6fa11a18ab9
Author: Thierry Reding <treding@nvidia.com>
Date:   Fri Jan 12 13:08:15 2018 -0800

    soc: bcm: brcmstb: Be multi-platform compatible
    
    We were making a bunch of wrong assumptions that turned out to blow out
    on non-Broadcom STB platforms:
    
    - we would return -ENODEV from brcmstb_soc_device_early_init() if we
      could not find the sun_top_ctrl device node, this is not an error
      in the context of a multi-platform kernel
    - we would still try to register the Broadcom STB SoC device, even if we
      are not running on such a platform
    
    While at it, also fix the sun_top_ctrl device_node leaks while we change
    the flow of brcmstb_soc_device_init() and
    brcmstb_soc_device_early_init().
    
    Fixes: f780429adfbc ("soc: brcmstb: biuctrl: Move to early_initcall")
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    [florian: Combine all of Thierry's patch in one go for easier review]
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/drivers/soc/bcm/brcmstb/common.c b/drivers/soc/bcm/brcmstb/common.c
index 781ada62d0a3..14185451901d 100644
--- a/drivers/soc/bcm/brcmstb/common.c
+++ b/drivers/soc/bcm/brcmstb/common.c
@@ -70,30 +70,49 @@ static int __init brcmstb_soc_device_early_init(void)
 {
 	struct device_node *sun_top_ctrl;
 	void __iomem *sun_top_ctrl_base;
+	int ret = 0;
 
+	/* We could be on a multi-platform kernel, don't make this fatal but
+	 * bail out early
+	 */
 	sun_top_ctrl = of_find_matching_node(NULL, sun_top_ctrl_match);
 	if (!sun_top_ctrl)
-		return -ENODEV;
+		return ret;
 
 	sun_top_ctrl_base = of_iomap(sun_top_ctrl, 0);
-	if (!sun_top_ctrl_base)
-		return -ENODEV;
+	if (!sun_top_ctrl_base) {
+		ret = -ENODEV;
+		goto out;
+	}
 
 	family_id = readl(sun_top_ctrl_base);
 	product_id = readl(sun_top_ctrl_base + 0x4);
 	iounmap(sun_top_ctrl_base);
-	return 0;
+out:
+	of_node_put(sun_top_ctrl);
+	return ret;
 }
 early_initcall(brcmstb_soc_device_early_init);
 
 static int __init brcmstb_soc_device_init(void)
 {
 	struct soc_device_attribute *soc_dev_attr;
+	struct device_node *sun_top_ctrl;
 	struct soc_device *soc_dev;
+	int ret = 0;
+
+	/* We could be on a multi-platform kernel, don't make this fatal but
+	 * bail out early
+	 */
+	sun_top_ctrl = of_find_matching_node(NULL, sun_top_ctrl_match);
+	if (!sun_top_ctrl)
+		return ret;
 
 	soc_dev_attr = kzalloc(sizeof(*soc_dev_attr), GFP_KERNEL);
-	if (!soc_dev_attr)
-		return -ENOMEM;
+	if (!soc_dev_attr) {
+		ret = -ENOMEM;
+		goto out;
+	}
 
 	soc_dev_attr->family = kasprintf(GFP_KERNEL, "%x",
 					 family_id >> 28 ?
@@ -111,9 +130,10 @@ static int __init brcmstb_soc_device_init(void)
 		kfree(soc_dev_attr->soc_id);
 		kfree(soc_dev_attr->revision);
 		kfree(soc_dev_attr);
-		return -ENOMEM;
+		ret = -ENOMEM;
 	}
-
-	return 0;
+out:
+	of_node_put(sun_top_ctrl);
+	return ret;
 }
 arch_initcall(brcmstb_soc_device_init);

commit c90801664e0a7e80dfd502a4cef8452dc203ce1f
Author: Olof Johansson <olof@lixom.net>
Date:   Fri Jan 12 10:29:43 2018 -0800

    Revert "soc: brcmstb: Only register SoC device on STB platforms"
    
    This reverts commit 23a0d847992997000ca2223a19111ee778fbea63.
    
    Patch has issues that's being addressed by the Florian and he will
    follow up with a new patch to address the original issue.
    
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/drivers/soc/bcm/brcmstb/common.c b/drivers/soc/bcm/brcmstb/common.c
index 4fe1cb73b39a..781ada62d0a3 100644
--- a/drivers/soc/bcm/brcmstb/common.c
+++ b/drivers/soc/bcm/brcmstb/common.c
@@ -89,13 +89,8 @@ early_initcall(brcmstb_soc_device_early_init);
 static int __init brcmstb_soc_device_init(void)
 {
 	struct soc_device_attribute *soc_dev_attr;
-	struct device_node *sun_top_ctrl;
 	struct soc_device *soc_dev;
 
-	sun_top_ctrl = of_find_matching_node(NULL, sun_top_ctrl_match);
-	if (!sun_top_ctrl)
-		return -ENODEV;
-
 	soc_dev_attr = kzalloc(sizeof(*soc_dev_attr), GFP_KERNEL);
 	if (!soc_dev_attr)
 		return -ENOMEM;

commit 23a0d847992997000ca2223a19111ee778fbea63
Author: Thierry Reding <treding@nvidia.com>
Date:   Tue Jan 9 15:54:09 2018 +0100

    soc: brcmstb: Only register SoC device on STB platforms
    
    After moving the SoC device initialization to an early initcall in
    commit f780429adfbc ("soc: brcmstb: biuctrl: Move to early_initcall"),
    the Broadcom STB SoC device is registered on all platforms if support
    for the device is enabled in the kernel configuration.
    
    This causes an additional SoC device to appear on platforms that already
    register a native one. In case of Tegra the STB SoC device is registered
    as soc0 (with totally meaningless content in the sysfs attributes) and
    causes various scripts and programs to fail because they don't know how
    to parse that data.
    
    To fix this, duplicate the check from brcmstb_soc_device_early_init()
    that already prevents the code from doing anything nonsensical on non-
    STB platforms.
    
    Fixes: f780429adfbc ("soc: brcmstb: biuctrl: Move to early_initcall")
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/drivers/soc/bcm/brcmstb/common.c b/drivers/soc/bcm/brcmstb/common.c
index 781ada62d0a3..4fe1cb73b39a 100644
--- a/drivers/soc/bcm/brcmstb/common.c
+++ b/drivers/soc/bcm/brcmstb/common.c
@@ -89,8 +89,13 @@ early_initcall(brcmstb_soc_device_early_init);
 static int __init brcmstb_soc_device_init(void)
 {
 	struct soc_device_attribute *soc_dev_attr;
+	struct device_node *sun_top_ctrl;
 	struct soc_device *soc_dev;
 
+	sun_top_ctrl = of_find_matching_node(NULL, sun_top_ctrl_match);
+	if (!sun_top_ctrl)
+		return -ENODEV;
+
 	soc_dev_attr = kzalloc(sizeof(*soc_dev_attr), GFP_KERNEL);
 	if (!soc_dev_attr)
 		return -ENOMEM;

commit 5d4567ec3bacf058cdf8e67695759e0d137cf095
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Wed Nov 29 10:54:16 2017 -0800

    soc: brcmstb: Split initialization
    
    We may need access to family_id and product_id fairly early on boot for
    other parts of the code (e.g: biuctrl.c), so split the initialization
    between an early_init() and an arch_initcall() which allows us to do
    that.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>

diff --git a/drivers/soc/bcm/brcmstb/common.c b/drivers/soc/bcm/brcmstb/common.c
index a71730da6385..781ada62d0a3 100644
--- a/drivers/soc/bcm/brcmstb/common.c
+++ b/drivers/soc/bcm/brcmstb/common.c
@@ -66,13 +66,10 @@ static const struct of_device_id sun_top_ctrl_match[] = {
 	{ }
 };
 
-static int __init brcmstb_soc_device_init(void)
+static int __init brcmstb_soc_device_early_init(void)
 {
-	struct soc_device_attribute *soc_dev_attr;
-	struct soc_device *soc_dev;
 	struct device_node *sun_top_ctrl;
 	void __iomem *sun_top_ctrl_base;
-	int ret = 0;
 
 	sun_top_ctrl = of_find_matching_node(NULL, sun_top_ctrl_match);
 	if (!sun_top_ctrl)
@@ -84,12 +81,19 @@ static int __init brcmstb_soc_device_init(void)
 
 	family_id = readl(sun_top_ctrl_base);
 	product_id = readl(sun_top_ctrl_base + 0x4);
+	iounmap(sun_top_ctrl_base);
+	return 0;
+}
+early_initcall(brcmstb_soc_device_early_init);
+
+static int __init brcmstb_soc_device_init(void)
+{
+	struct soc_device_attribute *soc_dev_attr;
+	struct soc_device *soc_dev;
 
 	soc_dev_attr = kzalloc(sizeof(*soc_dev_attr), GFP_KERNEL);
-	if (!soc_dev_attr) {
-		ret = -ENOMEM;
-		goto out;
-	}
+	if (!soc_dev_attr)
+		return -ENOMEM;
 
 	soc_dev_attr->family = kasprintf(GFP_KERNEL, "%x",
 					 family_id >> 28 ?
@@ -107,14 +111,9 @@ static int __init brcmstb_soc_device_init(void)
 		kfree(soc_dev_attr->soc_id);
 		kfree(soc_dev_attr->revision);
 		kfree(soc_dev_attr);
-		ret = -ENODEV;
-		goto out;
+		return -ENOMEM;
 	}
 
 	return 0;
-
-out:
-	iounmap(sun_top_ctrl_base);
-	return ret;
 }
 arch_initcall(brcmstb_soc_device_init);

commit 7f20333fe76780af19ee0d8d2dc6d04d35aa88d2
Author: Al Cooper <alcooperx@gmail.com>
Date:   Fri Sep 22 15:33:59 2017 -0400

    soc: brcmstb: Add Product ID and Family ID helper functions
    
    Add Product ID and Family ID helper functions for brcmstb soc.
    
    Signed-off-by: Al Cooper <alcooperx@gmail.com>
    Acked-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>

diff --git a/drivers/soc/bcm/brcmstb/common.c b/drivers/soc/bcm/brcmstb/common.c
index 22e98a90468c..a71730da6385 100644
--- a/drivers/soc/bcm/brcmstb/common.c
+++ b/drivers/soc/bcm/brcmstb/common.c
@@ -40,6 +40,18 @@ bool soc_is_brcmstb(void)
 	return of_match_node(brcmstb_machine_match, root) != NULL;
 }
 
+u32 brcmstb_get_family_id(void)
+{
+	return family_id;
+}
+EXPORT_SYMBOL(brcmstb_get_family_id);
+
+u32 brcmstb_get_product_id(void)
+{
+	return product_id;
+}
+EXPORT_SYMBOL(brcmstb_get_product_id);
+
 static const struct of_device_id sun_top_ctrl_match[] = {
 	{ .compatible = "brcm,bcm7125-sun-top-ctrl", },
 	{ .compatible = "brcm,bcm7346-sun-top-ctrl", },

commit 31d848aa1d85530770f0bdf1b61a042335d340ad
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Wed Apr 19 09:58:23 2017 -0700

    soc: bcm: brcmstb: Correctly match 7435 SoC
    
    Remove the duplicate brcm,bcm7425-sun-top-ctrl compatible string and
    replace it with brcm,bcm7435-sun-top-ctrl which was intended.
    
    Fixes: bd0faf08dc7f ("soc: bcm: brcmstb: Match additional compatible strings")
    Reported-by: Andreas Oberritter <obi@saftware.de>
    Acked-by: Gregory Fong <gregory.0xf0@gmail.com>
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>

diff --git a/drivers/soc/bcm/brcmstb/common.c b/drivers/soc/bcm/brcmstb/common.c
index b6195fdf0d00..22e98a90468c 100644
--- a/drivers/soc/bcm/brcmstb/common.c
+++ b/drivers/soc/bcm/brcmstb/common.c
@@ -49,7 +49,7 @@ static const struct of_device_id sun_top_ctrl_match[] = {
 	{ .compatible = "brcm,bcm7420-sun-top-ctrl", },
 	{ .compatible = "brcm,bcm7425-sun-top-ctrl", },
 	{ .compatible = "brcm,bcm7429-sun-top-ctrl", },
-	{ .compatible = "brcm,bcm7425-sun-top-ctrl", },
+	{ .compatible = "brcm,bcm7435-sun-top-ctrl", },
 	{ .compatible = "brcm,brcmstb-sun-top-ctrl", },
 	{ }
 };

commit bd0faf08dc7fcb3e555b35f556c9012b3c93de3b
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Tue Feb 14 16:41:57 2017 -0800

    soc: bcm: brcmstb: Match additional compatible strings
    
    Match all known sun-top-ctrl compatible strings from our MIPS chips
    counterparts. This allows us to properly report the SoC information to
    user-space through our SoC driver.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>

diff --git a/drivers/soc/bcm/brcmstb/common.c b/drivers/soc/bcm/brcmstb/common.c
index 94e7335553f4..b6195fdf0d00 100644
--- a/drivers/soc/bcm/brcmstb/common.c
+++ b/drivers/soc/bcm/brcmstb/common.c
@@ -41,6 +41,15 @@ bool soc_is_brcmstb(void)
 }
 
 static const struct of_device_id sun_top_ctrl_match[] = {
+	{ .compatible = "brcm,bcm7125-sun-top-ctrl", },
+	{ .compatible = "brcm,bcm7346-sun-top-ctrl", },
+	{ .compatible = "brcm,bcm7358-sun-top-ctrl", },
+	{ .compatible = "brcm,bcm7360-sun-top-ctrl", },
+	{ .compatible = "brcm,bcm7362-sun-top-ctrl", },
+	{ .compatible = "brcm,bcm7420-sun-top-ctrl", },
+	{ .compatible = "brcm,bcm7425-sun-top-ctrl", },
+	{ .compatible = "brcm,bcm7429-sun-top-ctrl", },
+	{ .compatible = "brcm,bcm7425-sun-top-ctrl", },
 	{ .compatible = "brcm,brcmstb-sun-top-ctrl", },
 	{ }
 };

commit 34642650e5bc052674b982433631fcc619237225
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Fri May 20 11:35:57 2016 -0700

    soc: Move brcmstb to bcm/brcmstb
    
    Unify the different Broadcom SoCs directory and have everybody live
    under drivers/soc/bcm/*.
    
    Acked-by: Scott Branden <scott.branden@broadcom.com>
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>

diff --git a/drivers/soc/bcm/brcmstb/common.c b/drivers/soc/bcm/brcmstb/common.c
new file mode 100644
index 000000000000..94e7335553f4
--- /dev/null
+++ b/drivers/soc/bcm/brcmstb/common.c
@@ -0,0 +1,99 @@
+/*
+ * Copyright © 2014 NVIDIA Corporation
+ * Copyright © 2015 Broadcom Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/slab.h>
+#include <linux/soc/brcmstb/brcmstb.h>
+#include <linux/sys_soc.h>
+
+#include <soc/brcmstb/common.h>
+
+static u32 family_id;
+static u32 product_id;
+
+static const struct of_device_id brcmstb_machine_match[] = {
+	{ .compatible = "brcm,brcmstb", },
+	{ }
+};
+
+bool soc_is_brcmstb(void)
+{
+	struct device_node *root;
+
+	root = of_find_node_by_path("/");
+	if (!root)
+		return false;
+
+	return of_match_node(brcmstb_machine_match, root) != NULL;
+}
+
+static const struct of_device_id sun_top_ctrl_match[] = {
+	{ .compatible = "brcm,brcmstb-sun-top-ctrl", },
+	{ }
+};
+
+static int __init brcmstb_soc_device_init(void)
+{
+	struct soc_device_attribute *soc_dev_attr;
+	struct soc_device *soc_dev;
+	struct device_node *sun_top_ctrl;
+	void __iomem *sun_top_ctrl_base;
+	int ret = 0;
+
+	sun_top_ctrl = of_find_matching_node(NULL, sun_top_ctrl_match);
+	if (!sun_top_ctrl)
+		return -ENODEV;
+
+	sun_top_ctrl_base = of_iomap(sun_top_ctrl, 0);
+	if (!sun_top_ctrl_base)
+		return -ENODEV;
+
+	family_id = readl(sun_top_ctrl_base);
+	product_id = readl(sun_top_ctrl_base + 0x4);
+
+	soc_dev_attr = kzalloc(sizeof(*soc_dev_attr), GFP_KERNEL);
+	if (!soc_dev_attr) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	soc_dev_attr->family = kasprintf(GFP_KERNEL, "%x",
+					 family_id >> 28 ?
+					 family_id >> 16 : family_id >> 8);
+	soc_dev_attr->soc_id = kasprintf(GFP_KERNEL, "%x",
+					 product_id >> 28 ?
+					 product_id >> 16 : product_id >> 8);
+	soc_dev_attr->revision = kasprintf(GFP_KERNEL, "%c%d",
+					 ((product_id & 0xf0) >> 4) + 'A',
+					   product_id & 0xf);
+
+	soc_dev = soc_device_register(soc_dev_attr);
+	if (IS_ERR(soc_dev)) {
+		kfree(soc_dev_attr->family);
+		kfree(soc_dev_attr->soc_id);
+		kfree(soc_dev_attr->revision);
+		kfree(soc_dev_attr);
+		ret = -ENODEV;
+		goto out;
+	}
+
+	return 0;
+
+out:
+	iounmap(sun_top_ctrl_base);
+	return ret;
+}
+arch_initcall(brcmstb_soc_device_init);
