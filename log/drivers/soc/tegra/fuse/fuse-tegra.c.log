commit 37558ac85c197a5ff776b7b2f53046877f2bd4ee
Author: Jon Hunter <jonathanh@nvidia.com>
Date:   Fri Apr 17 13:40:46 2020 +0100

    soc/tegra: fuse: Update the SoC revision attribute to display a name
    
    Currently the SoC revision attribute for Tegra devices displays the
    value of the enum associated with a particular revision. This is not
    very useful because to obtain the actual revision you need to
    use the tegra_revision enumeration to translate the value.
    
    It is more meaningful to display a name for the revision, such as
    'A01', than the enumarated value and therefore, update the revision
    attribute to display a name. This change does alter the ABI, which
    is unfortunate, but this is more meaningful and maintable.
    
    Signed-off-by: Jon Hunter <jonathanh@nvidia.com>
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/drivers/soc/tegra/fuse/fuse-tegra.c b/drivers/soc/tegra/fuse/fuse-tegra.c
index db65ddb6a5d2..d1f8dd0289e6 100644
--- a/drivers/soc/tegra/fuse/fuse-tegra.c
+++ b/drivers/soc/tegra/fuse/fuse-tegra.c
@@ -363,7 +363,8 @@ struct device * __init tegra_soc_device_register(void)
 		return NULL;
 
 	attr->family = kasprintf(GFP_KERNEL, "Tegra");
-	attr->revision = kasprintf(GFP_KERNEL, "%d", tegra_sku_info.revision);
+	attr->revision = kasprintf(GFP_KERNEL, "%s",
+		tegra_revision_name[tegra_sku_info.revision]);
 	attr->soc_id = kasprintf(GFP_KERNEL, "%u", tegra_get_chip_id());
 	attr->custom_attr_group = fuse->soc->soc_attr_group;
 

commit 379ac9eb1fe94cc40173b83fda1ee8d611a756e9
Author: Jon Hunter <jonathanh@nvidia.com>
Date:   Fri Apr 17 13:39:48 2020 +0100

    soc/tegra: fuse: Add custom SoC attributes
    
    Add a custom SoC attribute for Tegra to expose the HIDREV register
    fields to userspace via the sysfs. This register provides additional
    details about the type of device (eg, silicon, FPGA, etc) as well as
    revision. Exposing this information is useful for identifying the
    exact device revision and device type.
    
    For Tegra devices up until Tegra186, the majorrev and minorrev fields of
    the HIDREV register are used to determine the device revision and device
    type. For Tegra194, the majorrev and minorrev fields only determine the
    revision. Starting with Tegra194, there is an additional field,
    pre_si_platform (which occupies bits 20-23), that now determines device
    type. Therefore, for all Tegra devices, add a custom SoC attribute for
    the majorrev and minorrev fields and for Tegra194 add an additional
    attribute for the pre_si_platform field.
    
    Signed-off-by: Jon Hunter <jonathanh@nvidia.com>
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/drivers/soc/tegra/fuse/fuse-tegra.c b/drivers/soc/tegra/fuse/fuse-tegra.c
index 802717b9f6a3..db65ddb6a5d2 100644
--- a/drivers/soc/tegra/fuse/fuse-tegra.c
+++ b/drivers/soc/tegra/fuse/fuse-tegra.c
@@ -300,6 +300,59 @@ static void tegra_enable_fuse_clk(void __iomem *base)
 	writel(reg, base + 0x14);
 }
 
+static ssize_t major_show(struct device *dev, struct device_attribute *attr,
+			     char *buf)
+{
+	return sprintf(buf, "%d\n", tegra_get_major_rev());
+}
+
+static DEVICE_ATTR_RO(major);
+
+static ssize_t minor_show(struct device *dev, struct device_attribute *attr,
+			     char *buf)
+{
+	return sprintf(buf, "%d\n", tegra_get_minor_rev());
+}
+
+static DEVICE_ATTR_RO(minor);
+
+static struct attribute *tegra_soc_attr[] = {
+	&dev_attr_major.attr,
+	&dev_attr_minor.attr,
+	NULL,
+};
+
+const struct attribute_group tegra_soc_attr_group = {
+	.attrs = tegra_soc_attr,
+};
+
+#ifdef CONFIG_ARCH_TEGRA_194_SOC
+static ssize_t platform_show(struct device *dev, struct device_attribute *attr,
+			     char *buf)
+{
+	/*
+	 * Displays the value in the 'pre_si_platform' field of the HIDREV
+	 * register for Tegra194 devices. A value of 0 indicates that the
+	 * platform type is silicon and all other non-zero values indicate
+	 * the type of simulation platform is being used.
+	 */
+	return sprintf(buf, "%d\n", (tegra_read_chipid() >> 20) & 0xf);
+}
+
+static DEVICE_ATTR_RO(platform);
+
+static struct attribute *tegra194_soc_attr[] = {
+	&dev_attr_major.attr,
+	&dev_attr_minor.attr,
+	&dev_attr_platform.attr,
+	NULL,
+};
+
+const struct attribute_group tegra194_soc_attr_group = {
+	.attrs = tegra194_soc_attr,
+};
+#endif
+
 struct device * __init tegra_soc_device_register(void)
 {
 	struct soc_device_attribute *attr;
@@ -312,6 +365,7 @@ struct device * __init tegra_soc_device_register(void)
 	attr->family = kasprintf(GFP_KERNEL, "Tegra");
 	attr->revision = kasprintf(GFP_KERNEL, "%d", tegra_sku_info.revision);
 	attr->soc_id = kasprintf(GFP_KERNEL, "%u", tegra_get_chip_id());
+	attr->custom_attr_group = fuse->soc->soc_attr_group;
 
 	dev = soc_device_register(attr);
 	if (IS_ERR(dev)) {

commit eab3540562fb44f830e09492374fcc69a283ce47
Merge: 1afa9c3b7c9b 88b4750151a2
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Feb 8 14:04:19 2020 -0800

    Merge tag 'armsoc-drivers' of git://git.kernel.org/pub/scm/linux/kernel/git/soc/soc
    
    Pull ARM SoC-related driver updates from Olof Johansson:
     "Various driver updates for platforms:
    
       - Nvidia: Fuse support for Tegra194, continued memory controller
         pieces for Tegra30
    
       - NXP/FSL: Refactorings of QuickEngine drivers to support
         ARM/ARM64/PPC
    
       - NXP/FSL: i.MX8MP SoC driver pieces
    
       - TI Keystone: ring accelerator driver
    
       - Qualcomm: SCM driver cleanup/refactoring + support for new SoCs.
    
       - Xilinx ZynqMP: feature checking interface for firmware. Mailbox
         communication for power management
    
       - Overall support patch set for cpuidle on more complex hierarchies
         (PSCI-based)
    
      and misc cleanups, refactorings of Marvell, TI, other platforms"
    
    * tag 'armsoc-drivers' of git://git.kernel.org/pub/scm/linux/kernel/git/soc/soc: (166 commits)
      drivers: soc: xilinx: Use mailbox IPI callback
      dt-bindings: power: reset: xilinx: Add bindings for ipi mailbox
      drivers: soc: ti: knav_qmss_queue: Pass lockdep expression to RCU lists
      MAINTAINERS: Add brcmstb PCIe controller entry
      soc/tegra: fuse: Unmap registers once they are not needed anymore
      soc/tegra: fuse: Correct straps' address for older Tegra124 device trees
      soc/tegra: fuse: Warn if straps are not ready
      soc/tegra: fuse: Cache values of straps and Chip ID registers
      memory: tegra30-emc: Correct error message for timed out auto calibration
      memory: tegra30-emc: Firm up hardware programming sequence
      memory: tegra30-emc: Firm up suspend/resume sequence
      soc/tegra: regulators: Do nothing if voltage is unchanged
      memory: tegra: Correct reset value of xusb_hostr
      soc/tegra: fuse: Add APB DMA dependency for Tegra20
      bus: tegra-aconnect: Remove PM_CLK dependency
      dt-bindings: mediatek: add MT6765 power dt-bindings
      soc: mediatek: cmdq: delete not used define
      memory: tegra: Add support for the Tegra194 memory controller
      memory: tegra: Only include support for enabled SoCs
      memory: tegra: Support DVFS on Tegra186 and later
      ...

commit 3979a4c6263397eb03c4e8995938607f4f6ba0de
Author: JC Kuo <jckuo@nvidia.com>
Date:   Fri Jan 3 16:30:17 2020 +0800

    soc/tegra: fuse: Add Tegra194 support
    
    This commit adds Tegra194 fuse/apbmisc support.
    
    Signed-off-by: JC Kuo <jckuo@nvidia.com>
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/drivers/soc/tegra/fuse/fuse-tegra.c b/drivers/soc/tegra/fuse/fuse-tegra.c
index 4d719d4b8d5a..110cc00717bc 100644
--- a/drivers/soc/tegra/fuse/fuse-tegra.c
+++ b/drivers/soc/tegra/fuse/fuse-tegra.c
@@ -49,6 +49,9 @@ static struct tegra_fuse *fuse = &(struct tegra_fuse) {
 };
 
 static const struct of_device_id tegra_fuse_match[] = {
+#ifdef CONFIG_ARCH_TEGRA_194_SOC
+	{ .compatible = "nvidia,tegra194-efuse", .data = &tegra194_fuse_soc },
+#endif
 #ifdef CONFIG_ARCH_TEGRA_186_SOC
 	{ .compatible = "nvidia,tegra186-efuse", .data = &tegra186_fuse_soc },
 #endif

commit 4bdc0d676a643140bdf17dbf7eafedee3d496a3c
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Jan 6 09:43:50 2020 +0100

    remove ioremap_nocache and devm_ioremap_nocache
    
    ioremap has provided non-cached semantics by default since the Linux 2.6
    days, so remove the additional ioremap_nocache interface.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/drivers/soc/tegra/fuse/fuse-tegra.c b/drivers/soc/tegra/fuse/fuse-tegra.c
index 4d719d4b8d5a..606abbe55bba 100644
--- a/drivers/soc/tegra/fuse/fuse-tegra.c
+++ b/drivers/soc/tegra/fuse/fuse-tegra.c
@@ -408,7 +408,7 @@ static int __init tegra_init_fuse(void)
 		}
 	}
 
-	fuse->base = ioremap_nocache(regs.start, resource_size(&regs));
+	fuse->base = ioremap(regs.start, resource_size(&regs));
 	if (!fuse->base) {
 		pr_err("failed to map FUSE registers\n");
 		return -ENXIO;

commit 9f94fadd75d34acec19c164ffb1b60c66d72f898
Author: Thierry Reding <treding@nvidia.com>
Date:   Tue Aug 20 16:01:04 2019 +0200

    soc/tegra: fuse: Register cell lookups for compatibility
    
    Typically nvmem cells would be stored in device tree. However, for
    compatibility with device trees that don't contain nvmem cell
    definitions, register lookups for cells currently used by consumers.
    This allows the consumers to use the same API to query cells from the
    device tree or using the legacy mechanism.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/drivers/soc/tegra/fuse/fuse-tegra.c b/drivers/soc/tegra/fuse/fuse-tegra.c
index cbe3d6f19074..4d719d4b8d5a 100644
--- a/drivers/soc/tegra/fuse/fuse-tegra.c
+++ b/drivers/soc/tegra/fuse/fuse-tegra.c
@@ -423,6 +423,15 @@ static int __init tegra_init_fuse(void)
 	pr_debug("Tegra CPU Speedo ID %d, SoC Speedo ID %d\n",
 		 tegra_sku_info.cpu_speedo_id, tegra_sku_info.soc_speedo_id);
 
+	if (fuse->soc->lookups) {
+		size_t size = sizeof(*fuse->lookups) * fuse->soc->num_lookups;
+
+		fuse->lookups = kmemdup(fuse->soc->lookups, size, GFP_KERNEL);
+		if (!fuse->lookups)
+			return -ENOMEM;
+
+		nvmem_add_cell_lookups(fuse->lookups, fuse->soc->num_lookups);
+	}
 
 	return 0;
 }

commit f4619c7f68ba02f8357a9d42340a6dc8a229268d
Author: Thierry Reding <treding@nvidia.com>
Date:   Tue Aug 20 15:59:49 2019 +0200

    soc/tegra: fuse: Add cell information
    
    Create nvmem cells for all the fuses currently used by consumers.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/drivers/soc/tegra/fuse/fuse-tegra.c b/drivers/soc/tegra/fuse/fuse-tegra.c
index 430a47963a57..cbe3d6f19074 100644
--- a/drivers/soc/tegra/fuse/fuse-tegra.c
+++ b/drivers/soc/tegra/fuse/fuse-tegra.c
@@ -86,6 +86,94 @@ static int tegra_fuse_read(void *priv, unsigned int offset, void *value,
 	return 0;
 }
 
+static const struct nvmem_cell_info tegra_fuse_cells[] = {
+	{
+		.name = "tsensor-cpu1",
+		.offset = 0x084,
+		.bytes = 4,
+		.bit_offset = 0,
+		.nbits = 32,
+	}, {
+		.name = "tsensor-cpu2",
+		.offset = 0x088,
+		.bytes = 4,
+		.bit_offset = 0,
+		.nbits = 32,
+	}, {
+		.name = "tsensor-cpu0",
+		.offset = 0x098,
+		.bytes = 4,
+		.bit_offset = 0,
+		.nbits = 32,
+	}, {
+		.name = "xusb-pad-calibration",
+		.offset = 0x0f0,
+		.bytes = 4,
+		.bit_offset = 0,
+		.nbits = 32,
+	}, {
+		.name = "tsensor-cpu3",
+		.offset = 0x12c,
+		.bytes = 4,
+		.bit_offset = 0,
+		.nbits = 32,
+	}, {
+		.name = "sata-calibration",
+		.offset = 0x124,
+		.bytes = 1,
+		.bit_offset = 0,
+		.nbits = 2,
+	}, {
+		.name = "tsensor-gpu",
+		.offset = 0x154,
+		.bytes = 4,
+		.bit_offset = 0,
+		.nbits = 32,
+	}, {
+		.name = "tsensor-mem0",
+		.offset = 0x158,
+		.bytes = 4,
+		.bit_offset = 0,
+		.nbits = 32,
+	}, {
+		.name = "tsensor-mem1",
+		.offset = 0x15c,
+		.bytes = 4,
+		.bit_offset = 0,
+		.nbits = 32,
+	}, {
+		.name = "tsensor-pllx",
+		.offset = 0x160,
+		.bytes = 4,
+		.bit_offset = 0,
+		.nbits = 32,
+	}, {
+		.name = "tsensor-common",
+		.offset = 0x180,
+		.bytes = 4,
+		.bit_offset = 0,
+		.nbits = 32,
+	}, {
+		.name = "tsensor-realignment",
+		.offset = 0x1fc,
+		.bytes = 4,
+		.bit_offset = 0,
+		.nbits = 32,
+	}, {
+		.name = "gpu-calibration",
+		.offset = 0x204,
+		.bytes = 4,
+		.bit_offset = 0,
+		.nbits = 32,
+	}, {
+		.name = "xusb-pad-calibration-ext",
+		.offset = 0x250,
+		.bytes = 4,
+		.bit_offset = 0,
+		.nbits = 32,
+	},
+};
+
 static int tegra_fuse_probe(struct platform_device *pdev)
 {
 	void __iomem *base = fuse->base;
@@ -127,6 +215,8 @@ static int tegra_fuse_probe(struct platform_device *pdev)
 	nvmem.name = "fuse";
 	nvmem.id = -1;
 	nvmem.owner = THIS_MODULE;
+	nvmem.cells = tegra_fuse_cells;
+	nvmem.ncells = ARRAY_SIZE(tegra_fuse_cells);
 	nvmem.type = NVMEM_TYPE_OTP;
 	nvmem.read_only = true;
 	nvmem.root_only = true;

commit 96ee12b2a203167ffda7ac4a444418ca53df056d
Author: Thierry Reding <treding@nvidia.com>
Date:   Tue Aug 20 15:57:16 2019 +0200

    soc/tegra: fuse: Implement nvmem device
    
    The nvmem framework provides a generic infrastructure and API to access
    the type of information stored in fuses such as the Tegra FUSE block.
    
    Implement an nvmem device that can be used to access the information in
    a more generic way to decouple consumers from the custom Tegra API and
    to add a more formal way of creating the dependency between the FUSE
    device and the consumers.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/drivers/soc/tegra/fuse/fuse-tegra.c b/drivers/soc/tegra/fuse/fuse-tegra.c
index db516a2a3807..430a47963a57 100644
--- a/drivers/soc/tegra/fuse/fuse-tegra.c
+++ b/drivers/soc/tegra/fuse/fuse-tegra.c
@@ -8,6 +8,8 @@
 #include <linux/kobject.h>
 #include <linux/init.h>
 #include <linux/io.h>
+#include <linux/nvmem-consumer.h>
+#include <linux/nvmem-provider.h>
 #include <linux/of.h>
 #include <linux/of_address.h>
 #include <linux/platform_device.h>
@@ -31,50 +33,6 @@ static const char *tegra_revision_name[TEGRA_REVISION_MAX] = {
 	[TEGRA_REVISION_A04]     = "A04",
 };
 
-static u8 fuse_readb(struct tegra_fuse *fuse, unsigned int offset)
-{
-	u32 val;
-
-	val = fuse->read(fuse, round_down(offset, 4));
-	val >>= (offset % 4) * 8;
-	val &= 0xff;
-
-	return val;
-}
-
-static ssize_t fuse_read(struct file *fd, struct kobject *kobj,
-			 struct bin_attribute *attr, char *buf,
-			 loff_t pos, size_t size)
-{
-	struct device *dev = kobj_to_dev(kobj);
-	struct tegra_fuse *fuse = dev_get_drvdata(dev);
-	int i;
-
-	if (pos < 0 || pos >= attr->size)
-		return 0;
-
-	if (size > attr->size - pos)
-		size = attr->size - pos;
-
-	for (i = 0; i < size; i++)
-		buf[i] = fuse_readb(fuse, pos + i);
-
-	return i;
-}
-
-static struct bin_attribute fuse_bin_attr = {
-	.attr = { .name = "fuse", .mode = S_IRUGO, },
-	.read = fuse_read,
-};
-
-static int tegra_fuse_create_sysfs(struct device *dev, unsigned int size,
-				   const struct tegra_fuse_info *info)
-{
-	fuse_bin_attr.size = size;
-
-	return device_create_bin_file(dev, &fuse_bin_attr);
-}
-
 static const struct of_device_id car_match[] __initconst = {
 	{ .compatible = "nvidia,tegra20-car", },
 	{ .compatible = "nvidia,tegra30-car", },
@@ -115,9 +73,23 @@ static const struct of_device_id tegra_fuse_match[] = {
 	{ /* sentinel */ }
 };
 
+static int tegra_fuse_read(void *priv, unsigned int offset, void *value,
+			   size_t bytes)
+{
+	unsigned int count = bytes / 4, i;
+	struct tegra_fuse *fuse = priv;
+	u32 *buffer = value;
+
+	for (i = 0; i < count; i++)
+		buffer[i] = fuse->read(fuse, offset + i * 4);
+
+	return 0;
+}
+
 static int tegra_fuse_probe(struct platform_device *pdev)
 {
 	void __iomem *base = fuse->base;
+	struct nvmem_config nvmem;
 	struct resource *res;
 	int err;
 
@@ -150,9 +122,25 @@ static int tegra_fuse_probe(struct platform_device *pdev)
 			goto restore;
 	}
 
-	if (tegra_fuse_create_sysfs(&pdev->dev, fuse->soc->info->size,
-				    fuse->soc->info)) {
-		err = -ENODEV;
+	memset(&nvmem, 0, sizeof(nvmem));
+	nvmem.dev = &pdev->dev;
+	nvmem.name = "fuse";
+	nvmem.id = -1;
+	nvmem.owner = THIS_MODULE;
+	nvmem.type = NVMEM_TYPE_OTP;
+	nvmem.read_only = true;
+	nvmem.root_only = true;
+	nvmem.reg_read = tegra_fuse_read;
+	nvmem.size = fuse->soc->info->size;
+	nvmem.word_size = 4;
+	nvmem.stride = 4;
+	nvmem.priv = fuse;
+
+	fuse->nvmem = devm_nvmem_register(&pdev->dev, &nvmem);
+	if (IS_ERR(fuse->nvmem)) {
+		err = PTR_ERR(fuse->nvmem);
+		dev_err(&pdev->dev, "failed to register NVMEM device: %d\n",
+			err);
 		goto restore;
 	}
 

commit 9f1022b8bd14ce937ca56174a97a1ce475c07693
Author: Thierry Reding <treding@nvidia.com>
Date:   Tue Aug 20 15:53:44 2019 +0200

    soc/tegra: fuse: Restore base on sysfs failure
    
    Make sure to also restore the register base address on sysfs
    registration failure.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/drivers/soc/tegra/fuse/fuse-tegra.c b/drivers/soc/tegra/fuse/fuse-tegra.c
index 58996c6ea767..db516a2a3807 100644
--- a/drivers/soc/tegra/fuse/fuse-tegra.c
+++ b/drivers/soc/tegra/fuse/fuse-tegra.c
@@ -146,20 +146,24 @@ static int tegra_fuse_probe(struct platform_device *pdev)
 
 	if (fuse->soc->probe) {
 		err = fuse->soc->probe(fuse);
-		if (err < 0) {
-			fuse->base = base;
-			return err;
-		}
+		if (err < 0)
+			goto restore;
 	}
 
 	if (tegra_fuse_create_sysfs(&pdev->dev, fuse->soc->info->size,
-				    fuse->soc->info))
-		return -ENODEV;
+				    fuse->soc->info)) {
+		err = -ENODEV;
+		goto restore;
+	}
 
 	/* release the early I/O memory mapping */
 	iounmap(base);
 
 	return 0;
+
+restore:
+	fuse->base = base;
+	return err;
 }
 
 static struct platform_driver tegra_fuse_driver = {

commit 0a728e0bda7c14921723362af86b0ba30e5d6c79
Author: Nagarjuna Kristam <nkristam@nvidia.com>
Date:   Tue Sep 3 16:26:52 2019 +0530

    soc/tegra: fuse: Add FUSE clock check in tegra_fuse_readl()
    
    tegra_fuse_readl() can be called from drivers at any time. If this API
    is called before tegra_fuse_probe(), we end up enabling the clock before
    it is registered. Add a check for the FUSE clock in tegra_fuse_readl()
    and propagate any errors.
    
    Signed-off-by: Nagarjuna Kristam <nkristam@nvidia.com>
    Acked-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/drivers/soc/tegra/fuse/fuse-tegra.c b/drivers/soc/tegra/fuse/fuse-tegra.c
index 3eb44e65b326..58996c6ea767 100644
--- a/drivers/soc/tegra/fuse/fuse-tegra.c
+++ b/drivers/soc/tegra/fuse/fuse-tegra.c
@@ -186,9 +186,12 @@ u32 __init tegra_fuse_read_early(unsigned int offset)
 
 int tegra_fuse_readl(unsigned long offset, u32 *value)
 {
-	if (!fuse->read)
+	if (!fuse->read || !fuse->clk)
 		return -EPROBE_DEFER;
 
+	if (IS_ERR(fuse->clk))
+		return PTR_ERR(fuse->clk);
+
 	*value = fuse->read(fuse, offset);
 
 	return 0;

commit 761d3d22fb74232d2a5a2899358ff1bab94d6fa0
Merge: 09c4e038d4b1 7ac13f6dcbd5
Author: Olof Johansson <olof@lixom.net>
Date:   Tue Jun 25 05:42:42 2019 -0700

    Merge tag 'tegra-for-5.3-soc' of git://git.kernel.org/pub/scm/linux/kernel/git/tegra/linux into arm/drivers
    
    soc: tegra: Changes for v5.3-rc1
    
    This contains a set of minor fixes and cleanups for core Tegra drivers.
    
    * tag 'tegra-for-5.3-soc' of git://git.kernel.org/pub/scm/linux/kernel/git/tegra/linux:
      soc/tegra: Select pinctrl for Tegra194
      soc/tegra: fuse: Do not log error message on deferred probe
      soc/tegra: pmc: Add comments clarifying wake events
      soc/tegra: pmc: Avoid crash for non-wake IRQs
      soc/tegra: pmc: Fail to allocate more than one wake IRQ
    
    Signed-off-by: Olof Johansson <olof@lixom.net>

commit f0b2835f05c3ff05816b5717b9a920d82954938a
Author: Thierry Reding <treding@nvidia.com>
Date:   Tue Jun 4 17:38:38 2019 +0200

    soc/tegra: fuse: Do not log error message on deferred probe
    
    Recent changes have made it much more probable that clocks are not
    available yet when the FUSE driver is first probed. However, that is a
    situation that the driver can cope with just fine.
    
    To avoid confusion, don't output an error when this happens.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/drivers/soc/tegra/fuse/fuse-tegra.c b/drivers/soc/tegra/fuse/fuse-tegra.c
index 51625703399e..e075cad57cff 100644
--- a/drivers/soc/tegra/fuse/fuse-tegra.c
+++ b/drivers/soc/tegra/fuse/fuse-tegra.c
@@ -145,8 +145,10 @@ static int tegra_fuse_probe(struct platform_device *pdev)
 
 	fuse->clk = devm_clk_get(&pdev->dev, "fuse");
 	if (IS_ERR(fuse->clk)) {
-		dev_err(&pdev->dev, "failed to get FUSE clock: %ld",
-			PTR_ERR(fuse->clk));
+		if (PTR_ERR(fuse->clk) != -EPROBE_DEFER)
+			dev_err(&pdev->dev, "failed to get FUSE clock: %ld",
+				PTR_ERR(fuse->clk));
+
 		fuse->base = base;
 		return PTR_ERR(fuse->clk);
 	}

commit 9952f6918daa4ab5fc81307a9f90e31a4df3b200
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue May 28 10:10:04 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 201
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms and conditions of the gnu general public license
      version 2 as published by the free software foundation this program
      is distributed in the hope it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details you should have received a copy of the gnu general
      public license along with this program if not see http www gnu org
      licenses
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 228 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Steve Winslow <swinslow@gmail.com>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190528171438.107155473@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/soc/tegra/fuse/fuse-tegra.c b/drivers/soc/tegra/fuse/fuse-tegra.c
index 51625703399e..9b84bcc356d0 100644
--- a/drivers/soc/tegra/fuse/fuse-tegra.c
+++ b/drivers/soc/tegra/fuse/fuse-tegra.c
@@ -1,18 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Copyright (c) 2013-2014, NVIDIA CORPORATION.  All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- *
  */
 
 #include <linux/clk.h>

commit 51294bf6b9e897d595466dcda5a3f2751906a200
Author: Timo Alho <talho@nvidia.com>
Date:   Sun Dec 30 17:58:08 2018 +0200

    soc/tegra: fuse: Fix illegal free of IO base address
    
    On cases where device tree entries for fuse and clock provider are in
    different order, fuse driver needs to defer probing. This leads to
    freeing incorrect IO base address as the fuse->base variable gets
    overwritten once during first probe invocation. This leads to the
    following spew during boot:
    
    [    3.082285] Trying to vfree() nonexistent vm area (00000000cfe8fd94)
    [    3.082308] WARNING: CPU: 5 PID: 126 at /hdd/l4t/kernel/stable/mm/vmalloc.c:1511 __vunmap+0xcc/0xd8
    [    3.082318] Modules linked in:
    [    3.082330] CPU: 5 PID: 126 Comm: kworker/5:1 Tainted: G S                4.19.7-tegra-gce119d3 #1
    [    3.082340] Hardware name: quill (DT)
    [    3.082353] Workqueue: events deferred_probe_work_func
    [    3.082364] pstate: 40000005 (nZcv daif -PAN -UAO)
    [    3.082372] pc : __vunmap+0xcc/0xd8
    [    3.082379] lr : __vunmap+0xcc/0xd8
    [    3.082385] sp : ffff00000a1d3b60
    [    3.082391] x29: ffff00000a1d3b60 x28: 0000000000000000
    [    3.082402] x27: 0000000000000000 x26: ffff000008e8b610
    [    3.082413] x25: 0000000000000000 x24: 0000000000000009
    [    3.082423] x23: ffff000009221a90 x22: ffff000009f6d000
    [    3.082432] x21: 0000000000000000 x20: 0000000000000000
    [    3.082442] x19: ffff000009f6d000 x18: ffffffffffffffff
    [    3.082452] x17: 0000000000000000 x16: 0000000000000000
    [    3.082462] x15: ffff0000091396c8 x14: 0720072007200720
    [    3.082471] x13: 0720072007200720 x12: 0720072907340739
    [    3.082481] x11: 0764076607380765 x10: 0766076307300730
    [    3.082491] x9 : 0730073007300730 x8 : 0730073007280720
    [    3.082501] x7 : 0761076507720761 x6 : 0000000000000102
    [    3.082510] x5 : 0000000000000000 x4 : 0000000000000000
    [    3.082519] x3 : ffffffffffffffff x2 : ffff000009150ff8
    [    3.082528] x1 : 3d95b1429fff5200 x0 : 0000000000000000
    [    3.082538] Call trace:
    [    3.082545]  __vunmap+0xcc/0xd8
    [    3.082552]  vunmap+0x24/0x30
    [    3.082561]  __iounmap+0x2c/0x38
    [    3.082569]  tegra_fuse_probe+0xc8/0x118
    [    3.082577]  platform_drv_probe+0x50/0xa0
    [    3.082585]  really_probe+0x1b0/0x288
    [    3.082593]  driver_probe_device+0x58/0x100
    [    3.082601]  __device_attach_driver+0x98/0xf0
    [    3.082609]  bus_for_each_drv+0x64/0xc8
    [    3.082616]  __device_attach+0xd8/0x130
    [    3.082624]  device_initial_probe+0x10/0x18
    [    3.082631]  bus_probe_device+0x90/0x98
    [    3.082638]  deferred_probe_work_func+0x74/0xb0
    [    3.082649]  process_one_work+0x1e0/0x318
    [    3.082656]  worker_thread+0x228/0x450
    [    3.082664]  kthread+0x128/0x130
    [    3.082672]  ret_from_fork+0x10/0x18
    [    3.082678] ---[ end trace 0810fe6ba772c1c7 ]---
    
    Fix this by retaining the value of fuse->base until driver has
    successfully probed.
    
    Signed-off-by: Timo Alho <talho@nvidia.com>
    Acked-by: Jon Hunter <jonathanh@nvidia.com>
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/drivers/soc/tegra/fuse/fuse-tegra.c b/drivers/soc/tegra/fuse/fuse-tegra.c
index a33ee8ef8b6b..51625703399e 100644
--- a/drivers/soc/tegra/fuse/fuse-tegra.c
+++ b/drivers/soc/tegra/fuse/fuse-tegra.c
@@ -137,13 +137,17 @@ static int tegra_fuse_probe(struct platform_device *pdev)
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	fuse->phys = res->start;
 	fuse->base = devm_ioremap_resource(&pdev->dev, res);
-	if (IS_ERR(fuse->base))
-		return PTR_ERR(fuse->base);
+	if (IS_ERR(fuse->base)) {
+		err = PTR_ERR(fuse->base);
+		fuse->base = base;
+		return err;
+	}
 
 	fuse->clk = devm_clk_get(&pdev->dev, "fuse");
 	if (IS_ERR(fuse->clk)) {
 		dev_err(&pdev->dev, "failed to get FUSE clock: %ld",
 			PTR_ERR(fuse->clk));
+		fuse->base = base;
 		return PTR_ERR(fuse->clk);
 	}
 
@@ -152,8 +156,10 @@ static int tegra_fuse_probe(struct platform_device *pdev)
 
 	if (fuse->soc->probe) {
 		err = fuse->soc->probe(fuse);
-		if (err < 0)
+		if (err < 0) {
+			fuse->base = base;
 			return err;
+		}
 	}
 
 	if (tegra_fuse_create_sysfs(&pdev->dev, fuse->soc->info->size,

commit 55a042b3f68fc8c68adf4333ff74c4d3de796589
Author: Dmitry Osipenko <digetx@gmail.com>
Date:   Fri Oct 20 01:08:03 2017 +0300

    soc/tegra: fuse: Fix reading registers using DMA on Tegra20
    
    FUSE driver doesn't configure DMA channel properly, because of it DMA
    transfer is never issued and tegra20_fuse_read() always return 0x0.
    
    Signed-off-by: Dmitry Osipenko <digetx@gmail.com>
    Acked-by: Jon Hunter <jonathanh@nvidia.com>
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/drivers/soc/tegra/fuse/fuse-tegra.c b/drivers/soc/tegra/fuse/fuse-tegra.c
index d7ccfee51b1a..a33ee8ef8b6b 100644
--- a/drivers/soc/tegra/fuse/fuse-tegra.c
+++ b/drivers/soc/tegra/fuse/fuse-tegra.c
@@ -135,6 +135,7 @@ static int tegra_fuse_probe(struct platform_device *pdev)
 
 	/* take over the memory region from the early initialization */
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	fuse->phys = res->start;
 	fuse->base = devm_ioremap_resource(&pdev->dev, res);
 	if (IS_ERR(fuse->base))
 		return PTR_ERR(fuse->base);

commit 83468fe259bf827f350b118f25bce99dc0bdf597
Author: Timo Alho <talho@nvidia.com>
Date:   Mon Mar 6 15:47:20 2017 +0200

    soc/tegra: fuse: Add Tegra186 support
    
    Tegra210 and Tegra186 are mostly compatible from a fuses point of view.
    However, speedo support is implemented in the BPMP firmware, hence the
    implementation needs to be skipped in the fuses driver.
    
    Signed-off-by: Timo Alho <talho@nvidia.com>
    Reviewed-by: Mikko Perttunen <mperttunen@nvidia.com>
    [treding@nvidia.com: reword commit message]
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/drivers/soc/tegra/fuse/fuse-tegra.c b/drivers/soc/tegra/fuse/fuse-tegra.c
index b7c552e3133c..d7ccfee51b1a 100644
--- a/drivers/soc/tegra/fuse/fuse-tegra.c
+++ b/drivers/soc/tegra/fuse/fuse-tegra.c
@@ -103,6 +103,9 @@ static struct tegra_fuse *fuse = &(struct tegra_fuse) {
 };
 
 static const struct of_device_id tegra_fuse_match[] = {
+#ifdef CONFIG_ARCH_TEGRA_186_SOC
+	{ .compatible = "nvidia,tegra186-efuse", .data = &tegra186_fuse_soc },
+#endif
 #ifdef CONFIG_ARCH_TEGRA_210_SOC
 	{ .compatible = "nvidia,tegra210-efuse", .data = &tegra210_fuse_soc },
 #endif

commit 9261b43e70b79106deca8f734a5217134ce68f3d
Author: Thierry Reding <treding@nvidia.com>
Date:   Wed Aug 23 11:25:09 2017 +0200

    soc/tegra: fuse: Add missing semi-colon
    
    Commit 8a46828e623c ("soc/tegra: Register SoC device") added a new
    initcall, but forgot to terminate the line with a semi-colon. Some
    recent versions of GCC seem to report this as an error.
    
    Fixes: 8a46828e623c ("soc/tegra: Register SoC device")
    Reported-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/drivers/soc/tegra/fuse/fuse-tegra.c b/drivers/soc/tegra/fuse/fuse-tegra.c
index be003d04383f..b7c552e3133c 100644
--- a/drivers/soc/tegra/fuse/fuse-tegra.c
+++ b/drivers/soc/tegra/fuse/fuse-tegra.c
@@ -364,5 +364,5 @@ static int __init tegra_init_soc(void)
 
 	return 0;
 }
-device_initcall(tegra_init_soc)
+device_initcall(tegra_init_soc);
 #endif

commit 226cff485c803ac0f3a6bc52b9b638eb2c41181c
Author: Thierry Reding <treding@nvidia.com>
Date:   Wed Aug 23 11:25:08 2017 +0200

    soc/tegra: Restrict SoC device registration to Tegra
    
    Commit 8a46828e623c ("soc/tegra: Register SoC device") added an initcall
    to register the SoC device on Tegra. However, that code is unrestricted
    and will run on all platforms, causing unwanted warnings.
    
    Fix this by first checking that we're running on hardware that supports
    the fuses block that we use to provide SoC information.
    
    Fixes: 8a46828e623c ("soc/tegra: Register SoC device")
    Reported-by: Sudeep Holla <sudeep.holla@arm.com>
    Tested-by: Sudeep Holla <sudeep.holla@arm.com>
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/drivers/soc/tegra/fuse/fuse-tegra.c b/drivers/soc/tegra/fuse/fuse-tegra.c
index e4f78de8f95f..be003d04383f 100644
--- a/drivers/soc/tegra/fuse/fuse-tegra.c
+++ b/drivers/soc/tegra/fuse/fuse-tegra.c
@@ -346,8 +346,16 @@ early_initcall(tegra_init_fuse);
 #ifdef CONFIG_ARM64
 static int __init tegra_init_soc(void)
 {
+	struct device_node *np;
 	struct device *soc;
 
+	/* make sure we're running on Tegra */
+	np = of_find_matching_node(NULL, tegra_fuse_match);
+	if (!np)
+		return 0;
+
+	of_node_put(np);
+
 	soc = tegra_soc_device_register();
 	if (IS_ERR(soc)) {
 		pr_err("failed to register SoC device: %ld\n", PTR_ERR(soc));

commit 27a0342ac162bf2ba30c288cfb7b72eabed38d8b
Author: Thierry Reding <treding@nvidia.com>
Date:   Thu Aug 17 16:42:17 2017 +0200

    soc/tegra: Register SoC device
    
    Move this code from arch/arm/mach-tegra and make it common among 32-bit
    and 64-bit Tegra SoCs. This is slightly complicated by the fact that on
    32-bit Tegra, the SoC device is used as the parent for all devices that
    are instantiated from device tree.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/drivers/soc/tegra/fuse/fuse-tegra.c b/drivers/soc/tegra/fuse/fuse-tegra.c
index 7413f60fa855..e4f78de8f95f 100644
--- a/drivers/soc/tegra/fuse/fuse-tegra.c
+++ b/drivers/soc/tegra/fuse/fuse-tegra.c
@@ -19,10 +19,12 @@
 #include <linux/device.h>
 #include <linux/kobject.h>
 #include <linux/init.h>
-#include <linux/platform_device.h>
+#include <linux/io.h>
 #include <linux/of.h>
 #include <linux/of_address.h>
-#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/sys_soc.h>
 
 #include <soc/tegra/common.h>
 #include <soc/tegra/fuse.h>
@@ -210,6 +212,31 @@ static void tegra_enable_fuse_clk(void __iomem *base)
 	writel(reg, base + 0x14);
 }
 
+struct device * __init tegra_soc_device_register(void)
+{
+	struct soc_device_attribute *attr;
+	struct soc_device *dev;
+
+	attr = kzalloc(sizeof(*attr), GFP_KERNEL);
+	if (!attr)
+		return NULL;
+
+	attr->family = kasprintf(GFP_KERNEL, "Tegra");
+	attr->revision = kasprintf(GFP_KERNEL, "%d", tegra_sku_info.revision);
+	attr->soc_id = kasprintf(GFP_KERNEL, "%u", tegra_get_chip_id());
+
+	dev = soc_device_register(attr);
+	if (IS_ERR(dev)) {
+		kfree(attr->soc_id);
+		kfree(attr->revision);
+		kfree(attr->family);
+		kfree(attr);
+		return ERR_CAST(dev);
+	}
+
+	return soc_device_to_device(dev);
+}
+
 static int __init tegra_init_fuse(void)
 {
 	const struct of_device_id *match;
@@ -311,6 +338,23 @@ static int __init tegra_init_fuse(void)
 	pr_debug("Tegra CPU Speedo ID %d, SoC Speedo ID %d\n",
 		 tegra_sku_info.cpu_speedo_id, tegra_sku_info.soc_speedo_id);
 
+
 	return 0;
 }
 early_initcall(tegra_init_fuse);
+
+#ifdef CONFIG_ARM64
+static int __init tegra_init_soc(void)
+{
+	struct device *soc;
+
+	soc = tegra_soc_device_register();
+	if (IS_ERR(soc)) {
+		pr_err("failed to register SoC device: %ld\n", PTR_ERR(soc));
+		return PTR_ERR(soc);
+	}
+
+	return 0;
+}
+device_initcall(tegra_init_soc)
+#endif

commit 1859217bec83ebd1b4a220df396905a87285129b
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Sun Nov 13 14:03:01 2016 -0500

    soc: tegra: make fuse-tegra explicitly non-modular
    
    The Makefiles currently controlling compilation of this code is:
    
    drivers/soc/tegra/Makefile:obj-y += fuse/
    drivers/soc/tegra/fuse/Makefile:obj-y += fuse-tegra.o
    
    ...meaning that it currently is not being built as a module by anyone.
    
    Lets remove the couple traces of modularity so that when reading the
    driver there is no doubt it is builtin-only.
    
    Since module_platform_driver() uses the same init level priority as
    builtin_platform_driver() the init ordering remains unchanged with
    this commit.
    
    Cc: Stephen Warren <swarren@wwwdotorg.org>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Cc: Alexandre Courbot <gnurou@gmail.com>
    Cc: linux-tegra@vger.kernel.org
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/drivers/soc/tegra/fuse/fuse-tegra.c b/drivers/soc/tegra/fuse/fuse-tegra.c
index de2c1bfe28b5..7413f60fa855 100644
--- a/drivers/soc/tegra/fuse/fuse-tegra.c
+++ b/drivers/soc/tegra/fuse/fuse-tegra.c
@@ -18,7 +18,7 @@
 #include <linux/clk.h>
 #include <linux/device.h>
 #include <linux/kobject.h>
-#include <linux/module.h>
+#include <linux/init.h>
 #include <linux/platform_device.h>
 #include <linux/of.h>
 #include <linux/of_address.h>
@@ -168,7 +168,7 @@ static struct platform_driver tegra_fuse_driver = {
 	},
 	.probe = tegra_fuse_probe,
 };
-module_platform_driver(tegra_fuse_driver);
+builtin_platform_driver(tegra_fuse_driver);
 
 bool __init tegra_fuse_read_spare(unsigned int spare)
 {

commit 03b3f4c8b76180ba5bd800c57a7efdb142c2341d
Author: Thierry Reding <treding@nvidia.com>
Date:   Mon Mar 23 14:44:08 2015 +0100

    soc/tegra: fuse: Rename core_* to soc_*
    
    There's a mixture of core_* and soc_* prefixes for variables storing
    information related to the VDD_CORE rail. Choose one (soc_*) and use it
    more consistently.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/drivers/soc/tegra/fuse/fuse-tegra.c b/drivers/soc/tegra/fuse/fuse-tegra.c
index 5a0846474cb4..de2c1bfe28b5 100644
--- a/drivers/soc/tegra/fuse/fuse-tegra.c
+++ b/drivers/soc/tegra/fuse/fuse-tegra.c
@@ -304,12 +304,12 @@ static int __init tegra_init_fuse(void)
 
 	fuse->soc->init(fuse);
 
-	pr_info("Tegra Revision: %s SKU: %d CPU Process: %d Core Process: %d\n",
+	pr_info("Tegra Revision: %s SKU: %d CPU Process: %d SoC Process: %d\n",
 		tegra_revision_name[tegra_sku_info.revision],
 		tegra_sku_info.sku_id, tegra_sku_info.cpu_process_id,
-		tegra_sku_info.core_process_id);
-	pr_debug("Tegra CPU Speedo ID %d, Soc Speedo ID %d\n",
-		tegra_sku_info.cpu_speedo_id, tegra_sku_info.soc_speedo_id);
+		tegra_sku_info.soc_process_id);
+	pr_debug("Tegra CPU Speedo ID %d, SoC Speedo ID %d\n",
+		 tegra_sku_info.cpu_speedo_id, tegra_sku_info.soc_speedo_id);
 
 	return 0;
 }

commit 0dc5a0d836751099f2e08deec28f56ec881925dd
Author: Thierry Reding <treding@nvidia.com>
Date:   Wed Apr 29 16:55:57 2015 +0200

    soc/tegra: fuse: Add Tegra210 support
    
    Add Tegra210 support to the fuses driver and add Tegra210-specific
    speedo definitions.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/drivers/soc/tegra/fuse/fuse-tegra.c b/drivers/soc/tegra/fuse/fuse-tegra.c
index 407d7e359381..5a0846474cb4 100644
--- a/drivers/soc/tegra/fuse/fuse-tegra.c
+++ b/drivers/soc/tegra/fuse/fuse-tegra.c
@@ -91,6 +91,7 @@ static const struct of_device_id car_match[] __initconst = {
 	{ .compatible = "nvidia,tegra114-car", },
 	{ .compatible = "nvidia,tegra124-car", },
 	{ .compatible = "nvidia,tegra132-car", },
+	{ .compatible = "nvidia,tegra210-car", },
 	{},
 };
 
@@ -100,6 +101,9 @@ static struct tegra_fuse *fuse = &(struct tegra_fuse) {
 };
 
 static const struct of_device_id tegra_fuse_match[] = {
+#ifdef CONFIG_ARCH_TEGRA_210_SOC
+	{ .compatible = "nvidia,tegra210-efuse", .data = &tegra210_fuse_soc },
+#endif
 #ifdef CONFIG_ARCH_TEGRA_132_SOC
 	{ .compatible = "nvidia,tegra132-efuse", .data = &tegra124_fuse_soc },
 #endif

commit 7e939de1b2bb26496e4967e5346619700245e7c0
Author: Thierry Reding <treding@nvidia.com>
Date:   Wed Apr 29 16:54:04 2015 +0200

    soc/tegra: fuse: Unify Tegra20 and Tegra30 drivers
    
    Unifying the drivers makes it easier to restrict the legacy probing
    paths to 32-bit ARM. This in turn will come in handy as support for
    new 64-bit ARM SoCs is added.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/drivers/soc/tegra/fuse/fuse-tegra.c b/drivers/soc/tegra/fuse/fuse-tegra.c
index c0d660f1aaac..407d7e359381 100644
--- a/drivers/soc/tegra/fuse/fuse-tegra.c
+++ b/drivers/soc/tegra/fuse/fuse-tegra.c
@@ -15,9 +15,10 @@
  *
  */
 
+#include <linux/clk.h>
 #include <linux/device.h>
 #include <linux/kobject.h>
-#include <linux/kernel.h>
+#include <linux/module.h>
 #include <linux/platform_device.h>
 #include <linux/of.h>
 #include <linux/of_address.h>
@@ -28,8 +29,6 @@
 
 #include "fuse.h"
 
-static u32 (*fuse_readl)(const unsigned int offset);
-static int fuse_size;
 struct tegra_sku_info tegra_sku_info;
 EXPORT_SYMBOL(tegra_sku_info);
 
@@ -42,11 +41,11 @@ static const char *tegra_revision_name[TEGRA_REVISION_MAX] = {
 	[TEGRA_REVISION_A04]     = "A04",
 };
 
-static u8 fuse_readb(const unsigned int offset)
+static u8 fuse_readb(struct tegra_fuse *fuse, unsigned int offset)
 {
 	u32 val;
 
-	val = fuse_readl(round_down(offset, 4));
+	val = fuse->read(fuse, round_down(offset, 4));
 	val >>= (offset % 4) * 8;
 	val &= 0xff;
 
@@ -54,19 +53,21 @@ static u8 fuse_readb(const unsigned int offset)
 }
 
 static ssize_t fuse_read(struct file *fd, struct kobject *kobj,
-			struct bin_attribute *attr, char *buf,
-			loff_t pos, size_t size)
+			 struct bin_attribute *attr, char *buf,
+			 loff_t pos, size_t size)
 {
+	struct device *dev = kobj_to_dev(kobj);
+	struct tegra_fuse *fuse = dev_get_drvdata(dev);
 	int i;
 
-	if (pos < 0 || pos >= fuse_size)
+	if (pos < 0 || pos >= attr->size)
 		return 0;
 
-	if (size > fuse_size - pos)
-		size = fuse_size - pos;
+	if (size > attr->size - pos)
+		size = attr->size - pos;
 
 	for (i = 0; i < size; i++)
-		buf[i] = fuse_readb(pos + i);
+		buf[i] = fuse_readb(fuse, pos + i);
 
 	return i;
 }
@@ -76,6 +77,14 @@ static struct bin_attribute fuse_bin_attr = {
 	.read = fuse_read,
 };
 
+static int tegra_fuse_create_sysfs(struct device *dev, unsigned int size,
+				   const struct tegra_fuse_info *info)
+{
+	fuse_bin_attr.size = size;
+
+	return device_create_bin_file(dev, &fuse_bin_attr);
+}
+
 static const struct of_device_id car_match[] __initconst = {
 	{ .compatible = "nvidia,tegra20-car", },
 	{ .compatible = "nvidia,tegra30-car", },
@@ -85,73 +94,211 @@ static const struct of_device_id car_match[] __initconst = {
 	{},
 };
 
-static void tegra_enable_fuse_clk(void __iomem *base)
+static struct tegra_fuse *fuse = &(struct tegra_fuse) {
+	.base = NULL,
+	.soc = NULL,
+};
+
+static const struct of_device_id tegra_fuse_match[] = {
+#ifdef CONFIG_ARCH_TEGRA_132_SOC
+	{ .compatible = "nvidia,tegra132-efuse", .data = &tegra124_fuse_soc },
+#endif
+#ifdef CONFIG_ARCH_TEGRA_124_SOC
+	{ .compatible = "nvidia,tegra124-efuse", .data = &tegra124_fuse_soc },
+#endif
+#ifdef CONFIG_ARCH_TEGRA_114_SOC
+	{ .compatible = "nvidia,tegra114-efuse", .data = &tegra114_fuse_soc },
+#endif
+#ifdef CONFIG_ARCH_TEGRA_3x_SOC
+	{ .compatible = "nvidia,tegra30-efuse", .data = &tegra30_fuse_soc },
+#endif
+#ifdef CONFIG_ARCH_TEGRA_2x_SOC
+	{ .compatible = "nvidia,tegra20-efuse", .data = &tegra20_fuse_soc },
+#endif
+	{ /* sentinel */ }
+};
+
+static int tegra_fuse_probe(struct platform_device *pdev)
 {
-	u32 reg;
+	void __iomem *base = fuse->base;
+	struct resource *res;
+	int err;
+
+	/* take over the memory region from the early initialization */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	fuse->base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(fuse->base))
+		return PTR_ERR(fuse->base);
+
+	fuse->clk = devm_clk_get(&pdev->dev, "fuse");
+	if (IS_ERR(fuse->clk)) {
+		dev_err(&pdev->dev, "failed to get FUSE clock: %ld",
+			PTR_ERR(fuse->clk));
+		return PTR_ERR(fuse->clk);
+	}
 
-	reg = readl_relaxed(base + 0x48);
-	reg |= 1 << 28;
-	writel(reg, base + 0x48);
+	platform_set_drvdata(pdev, fuse);
+	fuse->dev = &pdev->dev;
 
-	/*
-	 * Enable FUSE clock. This needs to be hardcoded because the clock
-	 * subsystem is not active during early boot.
-	 */
-	reg = readl(base + 0x14);
-	reg |= 1 << 7;
-	writel(reg, base + 0x14);
+	if (fuse->soc->probe) {
+		err = fuse->soc->probe(fuse);
+		if (err < 0)
+			return err;
+	}
+
+	if (tegra_fuse_create_sysfs(&pdev->dev, fuse->soc->info->size,
+				    fuse->soc->info))
+		return -ENODEV;
+
+	/* release the early I/O memory mapping */
+	iounmap(base);
+
+	return 0;
+}
+
+static struct platform_driver tegra_fuse_driver = {
+	.driver = {
+		.name = "tegra-fuse",
+		.of_match_table = tegra_fuse_match,
+		.suppress_bind_attrs = true,
+	},
+	.probe = tegra_fuse_probe,
+};
+module_platform_driver(tegra_fuse_driver);
+
+bool __init tegra_fuse_read_spare(unsigned int spare)
+{
+	unsigned int offset = fuse->soc->info->spare + spare * 4;
+
+	return fuse->read_early(fuse, offset) & 1;
+}
+
+u32 __init tegra_fuse_read_early(unsigned int offset)
+{
+	return fuse->read_early(fuse, offset);
 }
 
 int tegra_fuse_readl(unsigned long offset, u32 *value)
 {
-	if (!fuse_readl)
+	if (!fuse->read)
 		return -EPROBE_DEFER;
 
-	*value = fuse_readl(offset);
+	*value = fuse->read(fuse, offset);
 
 	return 0;
 }
 EXPORT_SYMBOL(tegra_fuse_readl);
 
-int tegra_fuse_create_sysfs(struct device *dev, int size,
-		     u32 (*readl)(const unsigned int offset))
+static void tegra_enable_fuse_clk(void __iomem *base)
 {
-	if (fuse_size)
-		return -ENODEV;
-
-	fuse_bin_attr.size = size;
-	fuse_bin_attr.read = fuse_read;
+	u32 reg;
 
-	fuse_size = size;
-	fuse_readl = readl;
+	reg = readl_relaxed(base + 0x48);
+	reg |= 1 << 28;
+	writel(reg, base + 0x48);
 
-	return device_create_bin_file(dev, &fuse_bin_attr);
+	/*
+	 * Enable FUSE clock. This needs to be hardcoded because the clock
+	 * subsystem is not active during early boot.
+	 */
+	reg = readl(base + 0x14);
+	reg |= 1 << 7;
+	writel(reg, base + 0x14);
 }
 
 static int __init tegra_init_fuse(void)
 {
+	const struct of_device_id *match;
 	struct device_node *np;
-	void __iomem *car_base;
-
-	if (!soc_is_tegra())
-		return 0;
+	struct resource regs;
 
 	tegra_init_apbmisc();
 
-	np = of_find_matching_node(NULL, car_match);
-	car_base = of_iomap(np, 0);
-	if (car_base) {
-		tegra_enable_fuse_clk(car_base);
-		iounmap(car_base);
+	np = of_find_matching_node_and_match(NULL, tegra_fuse_match, &match);
+	if (!np) {
+		/*
+		 * Fall back to legacy initialization for 32-bit ARM only. All
+		 * 64-bit ARM device tree files for Tegra are required to have
+		 * a FUSE node.
+		 *
+		 * This is for backwards-compatibility with old device trees
+		 * that didn't contain a FUSE node.
+		 */
+		if (IS_ENABLED(CONFIG_ARM) && soc_is_tegra()) {
+			u8 chip = tegra_get_chip_id();
+
+			regs.start = 0x7000f800;
+			regs.end = 0x7000fbff;
+			regs.flags = IORESOURCE_MEM;
+
+			switch (chip) {
+#ifdef CONFIG_ARCH_TEGRA_2x_SOC
+			case TEGRA20:
+				fuse->soc = &tegra20_fuse_soc;
+				break;
+#endif
+
+#ifdef CONFIG_ARCH_TEGRA_3x_SOC
+			case TEGRA30:
+				fuse->soc = &tegra30_fuse_soc;
+				break;
+#endif
+
+#ifdef CONFIG_ARCH_TEGRA_114_SOC
+			case TEGRA114:
+				fuse->soc = &tegra114_fuse_soc;
+				break;
+#endif
+
+#ifdef CONFIG_ARCH_TEGRA_124_SOC
+			case TEGRA124:
+				fuse->soc = &tegra124_fuse_soc;
+				break;
+#endif
+
+			default:
+				pr_warn("Unsupported SoC: %02x\n", chip);
+				break;
+			}
+		} else {
+			/*
+			 * At this point we're not running on Tegra, so play
+			 * nice with multi-platform kernels.
+			 */
+			return 0;
+		}
 	} else {
-		pr_err("Could not enable fuse clk. ioremap tegra car failed.\n");
+		/*
+		 * Extract information from the device tree if we've found a
+		 * matching node.
+		 */
+		if (of_address_to_resource(np, 0, &regs) < 0) {
+			pr_err("failed to get FUSE register\n");
+			return -ENXIO;
+		}
+
+		fuse->soc = match->data;
+	}
+
+	np = of_find_matching_node(NULL, car_match);
+	if (np) {
+		void __iomem *base = of_iomap(np, 0);
+		if (base) {
+			tegra_enable_fuse_clk(base);
+			iounmap(base);
+		} else {
+			pr_err("failed to map clock registers\n");
+			return -ENXIO;
+		}
+	}
+
+	fuse->base = ioremap_nocache(regs.start, resource_size(&regs));
+	if (!fuse->base) {
+		pr_err("failed to map FUSE registers\n");
 		return -ENXIO;
 	}
 
-	if (tegra_get_chip_id() == TEGRA20)
-		tegra20_init_fuse_early();
-	else
-		tegra30_init_fuse_early();
+	fuse->soc->init(fuse);
 
 	pr_info("Tegra Revision: %s SKU: %d CPU Process: %d Core Process: %d\n",
 		tegra_revision_name[tegra_sku_info.revision],

commit 9b07eb0537fb5f4d5fed1c2466febf59170f2b2e
Author: Thierry Reding <treding@nvidia.com>
Date:   Fri Jan 9 11:49:33 2015 +0100

    soc/tegra: fuse: Add Tegra132 support
    
    Tegra132 is very similar to Tegra124 from a peripheral point of view and
    uses the same fuse controller.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/drivers/soc/tegra/fuse/fuse-tegra.c b/drivers/soc/tegra/fuse/fuse-tegra.c
index 011a3363c265..c0d660f1aaac 100644
--- a/drivers/soc/tegra/fuse/fuse-tegra.c
+++ b/drivers/soc/tegra/fuse/fuse-tegra.c
@@ -81,6 +81,7 @@ static const struct of_device_id car_match[] __initconst = {
 	{ .compatible = "nvidia,tegra30-car", },
 	{ .compatible = "nvidia,tegra114-car", },
 	{ .compatible = "nvidia,tegra124-car", },
+	{ .compatible = "nvidia,tegra132-car", },
 	{},
 };
 

commit f9fc36618bcbca276d24738b07234d3601d1b17a
Author: Vince Hsu <vinceh@nvidia.com>
Date:   Tue Dec 2 12:50:32 2014 +0800

    soc/tegra: fuse: export tegra_sku_info
    
    Some Tegra drivers might be compiled as kernel modules, and they need the
    fuse information for initialization. One example is the GK20A Nouveau
    driver. It needs the GPU speedo value to calculate frequency-voltage
    table. So export the tegra_sku_info.
    
    Signed-off-by: Vince Hsu <vinceh@nvidia.com>
    Acked-by: Alexandre Courbot <acourbot@nvidia.com>
    Acked-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/soc/tegra/fuse/fuse-tegra.c b/drivers/soc/tegra/fuse/fuse-tegra.c
index 11a5043959dc..011a3363c265 100644
--- a/drivers/soc/tegra/fuse/fuse-tegra.c
+++ b/drivers/soc/tegra/fuse/fuse-tegra.c
@@ -31,6 +31,7 @@
 static u32 (*fuse_readl)(const unsigned int offset);
 static int fuse_size;
 struct tegra_sku_info tegra_sku_info;
+EXPORT_SYMBOL(tegra_sku_info);
 
 static const char *tegra_revision_name[TEGRA_REVISION_MAX] = {
 	[TEGRA_REVISION_UNKNOWN] = "unknown",

commit 24fa5af81059af90c723bec6aacc3cd2b2809d14
Author: Thierry Reding <treding@nvidia.com>
Date:   Fri Jul 11 11:13:30 2014 +0200

    soc/tegra: fuse: Set up in early initcall
    
    Rather than rely on explicit initialization order called from SoC setup
    code, use a plain initcall and rely on initcall ordering to take care of
    dependencies.
    
    This driver exposes some functionality (querying the chip ID) needed at
    very early stages of the boot process. An early initcall is good enough
    provided that some of the dependencies are deferred to later stages. To
    make sure any abuses are easily caught, output a warning message if the
    chip ID is queried while it can't be read yet.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/drivers/soc/tegra/fuse/fuse-tegra.c b/drivers/soc/tegra/fuse/fuse-tegra.c
index 03742edcfe83..11a5043959dc 100644
--- a/drivers/soc/tegra/fuse/fuse-tegra.c
+++ b/drivers/soc/tegra/fuse/fuse-tegra.c
@@ -23,6 +23,7 @@
 #include <linux/of_address.h>
 #include <linux/io.h>
 
+#include <soc/tegra/common.h>
 #include <soc/tegra/fuse.h>
 
 #include "fuse.h"
@@ -125,11 +126,14 @@ int tegra_fuse_create_sysfs(struct device *dev, int size,
 	return device_create_bin_file(dev, &fuse_bin_attr);
 }
 
-void __init tegra_init_fuse(void)
+static int __init tegra_init_fuse(void)
 {
 	struct device_node *np;
 	void __iomem *car_base;
 
+	if (!soc_is_tegra())
+		return 0;
+
 	tegra_init_apbmisc();
 
 	np = of_find_matching_node(NULL, car_match);
@@ -139,7 +143,7 @@ void __init tegra_init_fuse(void)
 		iounmap(car_base);
 	} else {
 		pr_err("Could not enable fuse clk. ioremap tegra car failed.\n");
-		return;
+		return -ENXIO;
 	}
 
 	if (tegra_get_chip_id() == TEGRA20)
@@ -153,4 +157,7 @@ void __init tegra_init_fuse(void)
 		tegra_sku_info.core_process_id);
 	pr_debug("Tegra CPU Speedo ID %d, Soc Speedo ID %d\n",
 		tegra_sku_info.cpu_speedo_id, tegra_sku_info.soc_speedo_id);
+
+	return 0;
 }
+early_initcall(tegra_init_fuse);

commit 783c8f4c84451bc444e314a71b447239c6ef6fd9
Author: Peter De Schrijver <pdeschrijver@nvidia.com>
Date:   Thu Jun 12 18:36:37 2014 +0300

    soc/tegra: Add efuse driver for Tegra
    
    Implement fuse driver for Tegra20, Tegra30, Tegra114 and Tegra124. This
    replaces functionality previously provided in arch/arm/mach-tegra, which
    is removed in this patch.
    
    While at it, move the only user of the global tegra_revision variable
    over to tegra_sku_info.revision and export tegra_fuse_readl() to allow
    drivers to read calibration fuses.
    
    Signed-off-by: Peter De Schrijver <pdeschrijver@nvidia.com>
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/drivers/soc/tegra/fuse/fuse-tegra.c b/drivers/soc/tegra/fuse/fuse-tegra.c
new file mode 100644
index 000000000000..03742edcfe83
--- /dev/null
+++ b/drivers/soc/tegra/fuse/fuse-tegra.c
@@ -0,0 +1,156 @@
+/*
+ * Copyright (c) 2013-2014, NVIDIA CORPORATION.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <linux/device.h>
+#include <linux/kobject.h>
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/io.h>
+
+#include <soc/tegra/fuse.h>
+
+#include "fuse.h"
+
+static u32 (*fuse_readl)(const unsigned int offset);
+static int fuse_size;
+struct tegra_sku_info tegra_sku_info;
+
+static const char *tegra_revision_name[TEGRA_REVISION_MAX] = {
+	[TEGRA_REVISION_UNKNOWN] = "unknown",
+	[TEGRA_REVISION_A01]     = "A01",
+	[TEGRA_REVISION_A02]     = "A02",
+	[TEGRA_REVISION_A03]     = "A03",
+	[TEGRA_REVISION_A03p]    = "A03 prime",
+	[TEGRA_REVISION_A04]     = "A04",
+};
+
+static u8 fuse_readb(const unsigned int offset)
+{
+	u32 val;
+
+	val = fuse_readl(round_down(offset, 4));
+	val >>= (offset % 4) * 8;
+	val &= 0xff;
+
+	return val;
+}
+
+static ssize_t fuse_read(struct file *fd, struct kobject *kobj,
+			struct bin_attribute *attr, char *buf,
+			loff_t pos, size_t size)
+{
+	int i;
+
+	if (pos < 0 || pos >= fuse_size)
+		return 0;
+
+	if (size > fuse_size - pos)
+		size = fuse_size - pos;
+
+	for (i = 0; i < size; i++)
+		buf[i] = fuse_readb(pos + i);
+
+	return i;
+}
+
+static struct bin_attribute fuse_bin_attr = {
+	.attr = { .name = "fuse", .mode = S_IRUGO, },
+	.read = fuse_read,
+};
+
+static const struct of_device_id car_match[] __initconst = {
+	{ .compatible = "nvidia,tegra20-car", },
+	{ .compatible = "nvidia,tegra30-car", },
+	{ .compatible = "nvidia,tegra114-car", },
+	{ .compatible = "nvidia,tegra124-car", },
+	{},
+};
+
+static void tegra_enable_fuse_clk(void __iomem *base)
+{
+	u32 reg;
+
+	reg = readl_relaxed(base + 0x48);
+	reg |= 1 << 28;
+	writel(reg, base + 0x48);
+
+	/*
+	 * Enable FUSE clock. This needs to be hardcoded because the clock
+	 * subsystem is not active during early boot.
+	 */
+	reg = readl(base + 0x14);
+	reg |= 1 << 7;
+	writel(reg, base + 0x14);
+}
+
+int tegra_fuse_readl(unsigned long offset, u32 *value)
+{
+	if (!fuse_readl)
+		return -EPROBE_DEFER;
+
+	*value = fuse_readl(offset);
+
+	return 0;
+}
+EXPORT_SYMBOL(tegra_fuse_readl);
+
+int tegra_fuse_create_sysfs(struct device *dev, int size,
+		     u32 (*readl)(const unsigned int offset))
+{
+	if (fuse_size)
+		return -ENODEV;
+
+	fuse_bin_attr.size = size;
+	fuse_bin_attr.read = fuse_read;
+
+	fuse_size = size;
+	fuse_readl = readl;
+
+	return device_create_bin_file(dev, &fuse_bin_attr);
+}
+
+void __init tegra_init_fuse(void)
+{
+	struct device_node *np;
+	void __iomem *car_base;
+
+	tegra_init_apbmisc();
+
+	np = of_find_matching_node(NULL, car_match);
+	car_base = of_iomap(np, 0);
+	if (car_base) {
+		tegra_enable_fuse_clk(car_base);
+		iounmap(car_base);
+	} else {
+		pr_err("Could not enable fuse clk. ioremap tegra car failed.\n");
+		return;
+	}
+
+	if (tegra_get_chip_id() == TEGRA20)
+		tegra20_init_fuse_early();
+	else
+		tegra30_init_fuse_early();
+
+	pr_info("Tegra Revision: %s SKU: %d CPU Process: %d Core Process: %d\n",
+		tegra_revision_name[tegra_sku_info.revision],
+		tegra_sku_info.sku_id, tegra_sku_info.cpu_process_id,
+		tegra_sku_info.core_process_id);
+	pr_debug("Tegra CPU Speedo ID %d, Soc Speedo ID %d\n",
+		tegra_sku_info.cpu_speedo_id, tegra_sku_info.soc_speedo_id);
+}
