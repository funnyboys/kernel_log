commit f877a18c08fa6674364e469f318a3069c68204d2
Merge: 84c1e51d7df8 a2b9d4eadb77
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri May 15 16:09:24 2020 +0200

    Merge tag 'fpga-for-5.8' of git://git.kernel.org/pub/scm/linux/kernel/git/mdf/linux-fpga into char-misc-next
    
    Moritz writes:
    
    FPGA Manager changes for 5.8
    
    Here's the first set of changes for the 5.8-rc1 merge window.
    
    Dominic's change adds support for accessing AFU regions with gdb.
    Gustavo's change is a cleanup patch regarding variable lenght arrays.
    Richard's changes update dt-bindings and add support for stratix and agilex.
    Sergiu's changes update spi transfers with the new delay field.
    Xu's change addresses an issue with a wrong return value.
    Shubhrajyoti's change makes the Zynq FPGA driver return -EPROBE_DEFER on
    check of devm_clk_get failure.
    Xu's change for DFL enables multiple opens.
    
    All of these patches have been reviewed, have appropriate Acked-by's and
    have been in the last few linux-next releases without issues.
    
    Signed-off-by: Moritz Fischer <mdf@kernel.org>
    
    * tag 'fpga-for-5.8' of git://git.kernel.org/pub/scm/linux/kernel/git/mdf/linux-fpga:
      fpga: dfl: afu: support debug access to memory-mapped afu regions
      fpga: dfl.h: Replace zero-length array with flexible-array member
      arm64: dts: agilex: correct service layer driver's compatible value
      dt-bindings, firmware: add compatible value Intel Stratix10 service layer binding
      fpga: stratix10-soc: add compatible property value for intel agilex
      arm64: dts: agilex: correct FPGA manager driver's compatible value
      dt-bindings: fpga: add compatible value to Stratix10 SoC FPGA manager binding
      fpga: machxo2-spi: Use new structure for SPI transfer delays
      fpga: ice40-spi: Use new structure for SPI transfer delays
      fpga: dfl: support multiple opens on feature device node.

commit 5a53881580f90a5e4404954af16a5646ee9d7842
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Thu Mar 19 16:21:53 2020 -0500

    fpga: dfl.h: Replace zero-length array with flexible-array member
    
    The current codebase makes use of the zero-length array language
    extension to the C90 standard, but the preferred mechanism to declare
    variable-length types such as these ones is a flexible array member[1][2],
    introduced in C99:
    
    struct foo {
            int stuff;
            struct boo array[];
    };
    
    By making use of the mechanism above, we will get a compiler warning
    in case the flexible array does not occur last in the structure, which
    will help us prevent some kind of undefined behavior bugs from being
    inadvertently introduced[3] to the codebase from now on.
    
    Also, notice that, dynamic memory allocations won't be affected by
    this change:
    
    "Flexible array members have incomplete type, and so the sizeof operator
    may not be applied. As a quirk of the original implementation of
    zero-length arrays, sizeof evaluates to zero."[1]
    
    This issue was found with the help of Coccinelle.
    
    [1] https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html
    [2] https://github.com/KSPP/linux/issues/21
    [3] commit 76497732932f ("cxgb3/l2t: Fix undefined behaviour")
    
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Signed-off-by: Moritz Fischer <mdf@kernel.org>

diff --git a/drivers/fpga/dfl.h b/drivers/fpga/dfl.h
index 4a9a33cd9979..74784d3cfe7c 100644
--- a/drivers/fpga/dfl.h
+++ b/drivers/fpga/dfl.h
@@ -235,7 +235,7 @@ struct dfl_feature_platform_data {
 	int open_count;
 	void *private;
 	int num;
-	struct dfl_feature features[0];
+	struct dfl_feature features[];
 };
 
 static inline

commit b6862193ca12e4bce6a18f31bb36eaa6d801b377
Author: Xu Yilun <yilun.xu@intel.com>
Date:   Mon Nov 18 13:20:41 2019 +0800

    fpga: dfl: support multiple opens on feature device node.
    
    Each DFL functional block, e.g. AFU (Accelerated Function Unit) and FME
    (FPGA Management Engine), could implement more than one function within
    its region, but current driver only allows one user application to access
    it by exclusive open on device node. So this is not convenient and
    flexible for userspace applications, as they have to combine lots of
    different functions into one single application.
    
    This patch removes the limitation here to allow multiple opens to each
    feature device node for AFU and FME from userspace applications. If user
    still needs exclusive access to these device node, O_EXCL flag must be
    issued together with open.
    
    Signed-off-by: Wu Hao <hao.wu@intel.com>
    Signed-off-by: Xu Yilun <yilun.xu@intel.com>
    Signed-off-by: Moritz Fischer <mdf@kernel.org>

diff --git a/drivers/fpga/dfl.h b/drivers/fpga/dfl.h
index 9f0e656de720..4a9a33cd9979 100644
--- a/drivers/fpga/dfl.h
+++ b/drivers/fpga/dfl.h
@@ -205,8 +205,6 @@ struct dfl_feature {
 	const struct dfl_feature_ops *ops;
 };
 
-#define DEV_STATUS_IN_USE	0
-
 #define FEATURE_DEV_ID_UNUSED	(-1)
 
 /**
@@ -219,8 +217,9 @@ struct dfl_feature {
  * @dfl_cdev: ptr to container device.
  * @id: id used for this feature device.
  * @disable_count: count for port disable.
+ * @excl_open: set on feature device exclusive open.
+ * @open_count: count for feature device open.
  * @num: number for sub features.
- * @dev_status: dev status (e.g. DEV_STATUS_IN_USE).
  * @private: ptr to feature dev private data.
  * @features: sub features of this feature dev.
  */
@@ -232,26 +231,46 @@ struct dfl_feature_platform_data {
 	struct dfl_fpga_cdev *dfl_cdev;
 	int id;
 	unsigned int disable_count;
-	unsigned long dev_status;
+	bool excl_open;
+	int open_count;
 	void *private;
 	int num;
 	struct dfl_feature features[0];
 };
 
 static inline
-int dfl_feature_dev_use_begin(struct dfl_feature_platform_data *pdata)
+int dfl_feature_dev_use_begin(struct dfl_feature_platform_data *pdata,
+			      bool excl)
 {
-	/* Test and set IN_USE flags to ensure file is exclusively used */
-	if (test_and_set_bit_lock(DEV_STATUS_IN_USE, &pdata->dev_status))
+	if (pdata->excl_open)
 		return -EBUSY;
 
+	if (excl) {
+		if (pdata->open_count)
+			return -EBUSY;
+
+		pdata->excl_open = true;
+	}
+	pdata->open_count++;
+
 	return 0;
 }
 
 static inline
 void dfl_feature_dev_use_end(struct dfl_feature_platform_data *pdata)
 {
-	clear_bit_unlock(DEV_STATUS_IN_USE, &pdata->dev_status);
+	pdata->excl_open = false;
+
+	if (WARN_ON(pdata->open_count <= 0))
+		return;
+
+	pdata->open_count--;
+}
+
+static inline
+int dfl_feature_dev_use_count(struct dfl_feature_platform_data *pdata)
+{
+	return pdata->open_count;
 }
 
 static inline

commit 724142f8c42a7b01dbf9738eb00d7addbad6f862
Author: Wu Hao <hao.wu@intel.com>
Date:   Mon Apr 27 09:06:23 2020 +0800

    fpga: dfl: fme: add performance reporting support
    
    This patch adds support for performance reporting private feature
    for FPGA Management Engine (FME). Now it supports several different
    performance counters, including 'basic', 'cache', 'fabric', 'vtd'
    and 'vtd_sip'. It allows user to use standard linux tools to access
    these performance counters.
    
    e.g. List all events by "perf list"
    
      perf list | grep fme
    
      dfl_fme0/cache_read_hit/                     [Kernel PMU event]
      dfl_fme0/cache_read_miss/                    [Kernel PMU event]
      ...
    
      dfl_fme0/fab_mmio_read/                      [Kernel PMU event]
      dfl_fme0/fab_mmio_write/                     [Kernel PMU event]
      ...
    
      dfl_fme0/fab_port_mmio_read,portid=?/        [Kernel PMU event]
      dfl_fme0/fab_port_mmio_write,portid=?/       [Kernel PMU event]
      ...
    
      dfl_fme0/vtd_port_devtlb_1g_fill,portid=?/   [Kernel PMU event]
      dfl_fme0/vtd_port_devtlb_2m_fill,portid=?/   [Kernel PMU event]
      ...
    
      dfl_fme0/vtd_sip_iotlb_1g_hit/               [Kernel PMU event]
      dfl_fme0/vtd_sip_iotlb_1g_miss/              [Kernel PMU event]
      ...
    
      dfl_fme0/clock                               [Kernel PMU event]
      ...
    
    e.g. check increased counter value after run one application using
    "perf stat" command.
    
     perf stat -e dfl_fme0/fab_mmio_read/,dfl_fme0/fab_mmio_write/ ./test
    
     Performance counter stats for './test':
    
                     1      dfl_fme0/fab_mmio_read/
                     2      dfl_fme0/fab_mmio_write/
    
           1.009496520 seconds time elapsed
    
    Please note that fabric counters support both fab_* and fab_port_*, but
    actually they are sharing one set of performance counters in hardware.
    If user wants to monitor overall data events on fab_* then fab_port_*
    can't be supported at the same time, see example below:
    
    perf stat -e dfl_fme0/fab_mmio_read/,dfl_fme0/fab_port_mmio_write,portid=0/
    
     Performance counter stats for 'system wide':
    
                     0      dfl_fme0/fab_mmio_read/
       <not supported>      dfl_fme0/fab_port_mmio_write,portid=0/
    
           2.141064085 seconds time elapsed
    
    Signed-off-by: Luwei Kang <luwei.kang@intel.com>
    Signed-off-by: Xu Yilun <yilun.xu@intel.com>
    Signed-off-by: Wu Hao <hao.wu@intel.com>
    Link: https://lore.kernel.org/r/1587949583-12058-3-git-send-email-hao.wu@intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/fpga/dfl.h b/drivers/fpga/dfl.h
index 9f0e656de720..d312678a9aca 100644
--- a/drivers/fpga/dfl.h
+++ b/drivers/fpga/dfl.h
@@ -197,12 +197,14 @@ struct dfl_feature_driver {
  *		    feature dev (platform device)'s reources.
  * @ioaddr: mapped mmio resource address.
  * @ops: ops of this sub feature.
+ * @priv: priv data of this feature.
  */
 struct dfl_feature {
 	u64 id;
 	int resource_index;
 	void __iomem *ioaddr;
 	const struct dfl_feature_ops *ops;
+	void *priv;
 };
 
 #define DEV_STATUS_IN_USE	0

commit f09991adfb3454530598586424ece3082e95fb0b
Author: Wu Hao <hao.wu@intel.com>
Date:   Mon Aug 12 10:49:59 2019 +0800

    fpga: dfl: afu: add userclock sysfs interfaces.
    
    This patch introduces userclock sysfs interfaces for AFU, user
    could use these interfaces for clock setting to AFU.
    
    Please note that, this is only working for port header feature
    with revision 0, for later revisions, userclock setting is moved
    to a separated private feature, so one revision sysfs interface
    is exposed to userspace application for this purpose too.
    
    Signed-off-by: Ananda Ravuri <ananda.ravuri@intel.com>
    Signed-off-by: Russ Weight <russell.h.weight@intel.com>
    Signed-off-by: Xu Yilun <yilun.xu@intel.com>
    Signed-off-by: Wu Hao <hao.wu@intel.com>
    Acked-by: Alan Tull <atull@kernel.org>
    Signed-off-by: Moritz Fischer <mdf@kernel.org>

diff --git a/drivers/fpga/dfl.h b/drivers/fpga/dfl.h
index 856ea4ebc445..9f0e656de720 100644
--- a/drivers/fpga/dfl.h
+++ b/drivers/fpga/dfl.h
@@ -120,6 +120,10 @@
 #define PORT_HDR_CAP		0x30
 #define PORT_HDR_CTRL		0x38
 #define PORT_HDR_STS		0x40
+#define PORT_HDR_USRCLK_CMD0	0x50
+#define PORT_HDR_USRCLK_CMD1	0x58
+#define PORT_HDR_USRCLK_STS0	0x60
+#define PORT_HDR_USRCLK_STS1	0x68
 
 /* Port Capability Register Bitfield */
 #define PORT_CAP_PORT_NUM	GENMASK_ULL(1, 0)	/* ID of this port */
@@ -355,6 +359,11 @@ static inline bool dfl_feature_is_port(void __iomem *base)
 		(FIELD_GET(DFH_ID, v) == DFH_ID_FIU_PORT);
 }
 
+static inline u8 dfl_feature_revision(void __iomem *base)
+{
+	return (u8)FIELD_GET(DFH_REVISION, readq(base + DFH));
+}
+
 /**
  * struct dfl_fpga_enum_info - DFL FPGA enumeration information
  *

commit 15bbb300fcef4e62e4f6063cc29e698796027b98
Author: Wu Hao <hao.wu@intel.com>
Date:   Sun Aug 4 18:20:15 2019 +0800

    fpga: dfl: add id_table for dfl private feature driver
    
    This patch adds id_table for each dfl private feature driver,
    it allows to reuse same private feature driver to match and support
    multiple dfl private features.
    
    Signed-off-by: Xu Yilun <yilun.xu@intel.com>
    Signed-off-by: Wu Hao <hao.wu@intel.com>
    Acked-by: Moritz Fischer <mdf@kernel.org>
    Acked-by: Alan Tull <atull@kernel.org>
    Signed-off-by: Moritz Fischer <mdf@kernel.org>
    Link: https://lore.kernel.org/r/1564914022-3710-6-git-send-email-hao.wu@intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/fpga/dfl.h b/drivers/fpga/dfl.h
index 6625d73bade8..856ea4ebc445 100644
--- a/drivers/fpga/dfl.h
+++ b/drivers/fpga/dfl.h
@@ -30,8 +30,8 @@
 /* plus one for fme device */
 #define MAX_DFL_FEATURE_DEV_NUM    (MAX_DFL_FPGA_PORT_NUM + 1)
 
-/* Reserved 0x0 for Header Group Register and 0xff for AFU */
-#define FEATURE_ID_FIU_HEADER		0x0
+/* Reserved 0xfe for Header Group Register and 0xff for AFU */
+#define FEATURE_ID_FIU_HEADER		0xfe
 #define FEATURE_ID_AFU			0xff
 
 #define FME_FEATURE_ID_HEADER		FEATURE_ID_FIU_HEADER
@@ -165,13 +165,22 @@ void dfl_fpga_port_ops_put(struct dfl_fpga_port_ops *ops);
 int dfl_fpga_check_port_id(struct platform_device *pdev, void *pport_id);
 
 /**
- * struct dfl_feature_driver - sub feature's driver
+ * struct dfl_feature_id - dfl private feature id
  *
- * @id: sub feature id.
- * @ops: ops of this sub feature.
+ * @id: unique dfl private feature id.
  */
-struct dfl_feature_driver {
+struct dfl_feature_id {
 	u64 id;
+};
+
+/**
+ * struct dfl_feature_driver - dfl private feature driver
+ *
+ * @id_table: id_table for dfl private features supported by this driver.
+ * @ops: ops of this dfl private feature driver.
+ */
+struct dfl_feature_driver {
+	const struct dfl_feature_id *id_table;
 	const struct dfl_feature_ops *ops;
 };
 

commit d2ad5ac1cda7c30c9ded04d0e21aba528f1f96ec
Author: Wu Hao <hao.wu@intel.com>
Date:   Sun Aug 4 18:20:13 2019 +0800

    fpga: dfl: afu: add AFU state related sysfs interfaces
    
    This patch introduces more sysfs interfaces for Accelerated
    Function Unit (AFU). These interfaces allow users to read
    current AFU Power State (APx), read / clear AFU Power (APx)
    events which are sticky to identify transient APx state,
    and manage AFU's LTR (latency tolerance reporting).
    
    Signed-off-by: Ananda Ravuri <ananda.ravuri@intel.com>
    Signed-off-by: Xu Yilun <yilun.xu@intel.com>
    Signed-off-by: Wu Hao <hao.wu@intel.com>
    Acked-by: Alan Tull <atull@kernel.org>
    Signed-off-by: Moritz Fischer <mdf@kernel.org>
    Link: https://lore.kernel.org/r/1564914022-3710-4-git-send-email-hao.wu@intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/fpga/dfl.h b/drivers/fpga/dfl.h
index b3f2f53a75d3..6625d73bade8 100644
--- a/drivers/fpga/dfl.h
+++ b/drivers/fpga/dfl.h
@@ -119,6 +119,7 @@
 #define PORT_HDR_NEXT_AFU	NEXT_AFU
 #define PORT_HDR_CAP		0x30
 #define PORT_HDR_CTRL		0x38
+#define PORT_HDR_STS		0x40
 
 /* Port Capability Register Bitfield */
 #define PORT_CAP_PORT_NUM	GENMASK_ULL(1, 0)	/* ID of this port */
@@ -130,6 +131,16 @@
 /* Latency tolerance reporting. '1' >= 40us, '0' < 40us.*/
 #define PORT_CTRL_LATENCY	BIT_ULL(2)
 #define PORT_CTRL_SFTRST_ACK	BIT_ULL(4)		/* HW ack for reset */
+
+/* Port Status Register Bitfield */
+#define PORT_STS_AP2_EVT	BIT_ULL(13)		/* AP2 event detected */
+#define PORT_STS_AP1_EVT	BIT_ULL(12)		/* AP1 event detected */
+#define PORT_STS_PWR_STATE	GENMASK_ULL(11, 8)	/* AFU power states */
+#define PORT_STS_PWR_STATE_NORM 0
+#define PORT_STS_PWR_STATE_AP1	1			/* 50% throttling */
+#define PORT_STS_PWR_STATE_AP2	2			/* 90% throttling */
+#define PORT_STS_PWR_STATE_AP6	6			/* 100% throttling */
+
 /**
  * struct dfl_fpga_port_ops - port ops
  *

commit bdd4f307956ae7c80a831aed67b0ddd131537481
Author: Wu Hao <hao.wu@intel.com>
Date:   Sun Aug 4 18:20:12 2019 +0800

    fpga: dfl: pci: enable SRIOV support.
    
    This patch enables the standard sriov support. It allows user to
    enable SRIOV (and VFs), then user could pass through accelerators
    (VFs) into virtual machine or use VFs directly in host.
    
    Signed-off-by: Zhang Yi Z <yi.z.zhang@intel.com>
    Signed-off-by: Xu Yilun <yilun.xu@intel.com>
    Signed-off-by: Wu Hao <hao.wu@intel.com>
    Acked-by: Alan Tull <atull@kernel.org>
    Acked-by: Moritz Fischer <mdf@kernel.org>
    Signed-off-by: Moritz Fischer <mdf@kernel.org>
    Link: https://lore.kernel.org/r/1564914022-3710-3-git-send-email-hao.wu@intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/fpga/dfl.h b/drivers/fpga/dfl.h
index 6f7855e57869..b3f2f53a75d3 100644
--- a/drivers/fpga/dfl.h
+++ b/drivers/fpga/dfl.h
@@ -416,5 +416,6 @@ dfl_fpga_cdev_find_port(struct dfl_fpga_cdev *cdev, void *data,
 
 int dfl_fpga_cdev_release_port(struct dfl_fpga_cdev *cdev, int port_id);
 int dfl_fpga_cdev_assign_port(struct dfl_fpga_cdev *cdev, int port_id);
-
+void dfl_fpga_cdev_config_ports_pf(struct dfl_fpga_cdev *cdev);
+int dfl_fpga_cdev_config_ports_vf(struct dfl_fpga_cdev *cdev, int num_vf);
 #endif /* __FPGA_DFL_H */

commit 69bb18ddfc4331ba1dea9db811caf93e95726408
Author: Wu Hao <hao.wu@intel.com>
Date:   Sun Aug 4 18:20:11 2019 +0800

    fpga: dfl: fme: add DFL_FPGA_FME_PORT_RELEASE/ASSIGN ioctl support.
    
    In order to support virtualization usage via PCIe SRIOV, this patch
    adds two ioctls under FPGA Management Engine (FME) to release and
    assign back the port device. In order to safely turn Port from PF
    into VF and enable PCIe SRIOV, it requires user to invoke this
    PORT_RELEASE ioctl to release port firstly to remove userspace
    interfaces, and then configure the PF/VF access register in FME.
    After disable SRIOV, it requires user to invoke this PORT_ASSIGN
    ioctl to attach the port back to PF.
    
     Ioctl interfaces:
     * DFL_FPGA_FME_PORT_RELEASE
       Release platform device of given port, it deletes port platform
       device to remove related userspace interfaces on PF. After this
       function, then it's safe to configure PF/VF access mode to VF,
       and enable VFs via SRIOV.
    
     * DFL_FPGA_FME_PORT_ASSIGN
       Assign platform device of given port back to PF. After configure
       PF/VF access mode to PF, this ioctl adds port platform device
       back to re-enable related userspace interfaces on PF.
    
    Signed-off-by: Zhang Yi Z <yi.z.zhang@intel.com>
    Signed-off-by: Xu Yilun <yilun.xu@intel.com>
    Signed-off-by: Wu Hao <hao.wu@intel.com>
    Acked-by: Alan Tull <atull@kernel.org>
    Acked-by: Moritz Fischer <mdf@kernel.org>
    Signed-off-by: Moritz Fischer <mdf@kernel.org>
    Link: https://lore.kernel.org/r/1564914022-3710-2-git-send-email-hao.wu@intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/fpga/dfl.h b/drivers/fpga/dfl.h
index a8b869e9e5b7..6f7855e57869 100644
--- a/drivers/fpga/dfl.h
+++ b/drivers/fpga/dfl.h
@@ -183,6 +183,8 @@ struct dfl_feature {
 
 #define DEV_STATUS_IN_USE	0
 
+#define FEATURE_DEV_ID_UNUSED	(-1)
+
 /**
  * struct dfl_feature_platform_data - platform data for feature devices
  *
@@ -191,6 +193,7 @@ struct dfl_feature {
  * @cdev: cdev of feature dev.
  * @dev: ptr to platform device linked with this platform data.
  * @dfl_cdev: ptr to container device.
+ * @id: id used for this feature device.
  * @disable_count: count for port disable.
  * @num: number for sub features.
  * @dev_status: dev status (e.g. DEV_STATUS_IN_USE).
@@ -203,6 +206,7 @@ struct dfl_feature_platform_data {
 	struct cdev cdev;
 	struct platform_device *dev;
 	struct dfl_fpga_cdev *dfl_cdev;
+	int id;
 	unsigned int disable_count;
 	unsigned long dev_status;
 	void *private;
@@ -373,6 +377,7 @@ void dfl_fpga_enum_info_free(struct dfl_fpga_enum_info *info);
  * @fme_dev: FME feature device under this container device.
  * @lock: mutex lock to protect the port device list.
  * @port_dev_list: list of all port feature devices under this container device.
+ * @released_port_num: released port number under this container device.
  */
 struct dfl_fpga_cdev {
 	struct device *parent;
@@ -380,6 +385,7 @@ struct dfl_fpga_cdev {
 	struct device *fme_dev;
 	struct mutex lock;
 	struct list_head port_dev_list;
+	int released_port_num;
 };
 
 struct dfl_fpga_cdev *
@@ -407,4 +413,8 @@ dfl_fpga_cdev_find_port(struct dfl_fpga_cdev *cdev, void *data,
 
 	return pdev;
 }
+
+int dfl_fpga_cdev_release_port(struct dfl_fpga_cdev *cdev, int port_id);
+int dfl_fpga_cdev_assign_port(struct dfl_fpga_cdev *cdev, int port_id);
+
 #endif /* __FPGA_DFL_H */

commit d06b004b99c960828523e581a3b7d109dfc1329b
Author: Wu Hao <hao.wu@intel.com>
Date:   Sat Jun 30 08:53:18 2018 +0800

    fpga: dfl: add dfl_fpga_check_port_id function.
    
    This patch adds one common function in DFL framework. It uses
    port_ops get_id callback to get port id and compare it with given
    value. This function could be used as match function of the
    dfl_fpga_cdev_find_port function.
    
    Signed-off-by: Wu Hao <hao.wu@intel.com>
    Acked-by: Alan Tull <atull@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/fpga/dfl.h b/drivers/fpga/dfl.h
index 654e0f694a5f..a8b869e9e5b7 100644
--- a/drivers/fpga/dfl.h
+++ b/drivers/fpga/dfl.h
@@ -151,6 +151,7 @@ void dfl_fpga_port_ops_add(struct dfl_fpga_port_ops *ops);
 void dfl_fpga_port_ops_del(struct dfl_fpga_port_ops *ops);
 struct dfl_fpga_port_ops *dfl_fpga_port_ops_get(struct platform_device *pdev);
 void dfl_fpga_port_ops_put(struct dfl_fpga_port_ops *ops);
+int dfl_fpga_check_port_id(struct platform_device *pdev, void *pport_id);
 
 /**
  * struct dfl_feature_driver - sub feature's driver

commit 6e8fd6e493bfca83021cc6a8fd86d7f69bd14fc6
Author: Wu Hao <hao.wu@intel.com>
Date:   Sat Jun 30 08:53:17 2018 +0800

    fpga: dfl: add dfl_fpga_port_ops support.
    
    In some cases, other DFL driver modules may need to access some port
    operations, e.g. disable / enable port for partial reconfiguration in
    FME module. In order to avoid dependency between port and FME modules,
    this patch introduces the dfl_fpga_port_ops support in DFL framework.
    A global dfl_fpga_port_ops list is added in the DFL framework, and
    it allows other DFL modules to use these port operations registered
    to this list, even in virtualization case, the port platform device
    is turned into VF / guest VM and hidden in host, the registered
    port_ops is still usable. It resolves the dependency issues between
    modules, but once get port ops API returns a valid port ops, that
    means related port driver module has been module_get to prevent from
    unexpected unload, and put port ops API must be invoked after use.
    
    These APIs introduced by this patch is listed below:
     * dfl_fpga_port_ops_add
       add one port ops to the global list.
    
     * dfl_fpga_port_ops_del
       del one port ops from the global list.
    
     * dfl_fpga_port_ops_get / dfl_fpga_port_ops_put
       get/put the port ops before/after use.
    
    Signed-off-by: Wu Hao <hao.wu@intel.com>
    Acked-by: Alan Tull <atull@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/fpga/dfl.h b/drivers/fpga/dfl.h
index 14d4731c13b0..654e0f694a5f 100644
--- a/drivers/fpga/dfl.h
+++ b/drivers/fpga/dfl.h
@@ -130,6 +130,27 @@
 /* Latency tolerance reporting. '1' >= 40us, '0' < 40us.*/
 #define PORT_CTRL_LATENCY	BIT_ULL(2)
 #define PORT_CTRL_SFTRST_ACK	BIT_ULL(4)		/* HW ack for reset */
+/**
+ * struct dfl_fpga_port_ops - port ops
+ *
+ * @name: name of this port ops, to match with port platform device.
+ * @owner: pointer to the module which owns this port ops.
+ * @node: node to link port ops to global list.
+ * @get_id: get port id from hardware.
+ * @enable_set: enable/disable the port.
+ */
+struct dfl_fpga_port_ops {
+	const char *name;
+	struct module *owner;
+	struct list_head node;
+	int (*get_id)(struct platform_device *pdev);
+	int (*enable_set)(struct platform_device *pdev, bool enable);
+};
+
+void dfl_fpga_port_ops_add(struct dfl_fpga_port_ops *ops);
+void dfl_fpga_port_ops_del(struct dfl_fpga_port_ops *ops);
+struct dfl_fpga_port_ops *dfl_fpga_port_ops_get(struct platform_device *pdev);
+void dfl_fpga_port_ops_put(struct dfl_fpga_port_ops *ops);
 
 /**
  * struct dfl_feature_driver - sub feature's driver

commit 5b57d02a2f94bb04c6b36932412f7f3b1bb38518
Author: Xiao Guangrong <guangrong.xiao@linux.intel.com>
Date:   Sat Jun 30 08:53:16 2018 +0800

    fpga: dfl: add feature device infrastructure
    
    This patch abstracts the common operations of the sub features and defines
    the feature_ops data structure, including init, uinit and ioctl function
    pointers. And this patch adds some common helper functions for FME and AFU
    drivers, e.g. dfl_feature_dev_use_begin/end which are used to ensure
    exclusive usage of the feature device file.
    
    Signed-off-by: Tim Whisonant <tim.whisonant@intel.com>
    Signed-off-by: Enno Luebbers <enno.luebbers@intel.com>
    Signed-off-by: Shiva Rao <shiva.rao@intel.com>
    Signed-off-by: Christopher Rauer <christopher.rauer@intel.com>
    Signed-off-by: Kang Luwei <luwei.kang@intel.com>
    Signed-off-by: Zhang Yi <yi.z.zhang@intel.com>
    Signed-off-by: Xiao Guangrong <guangrong.xiao@linux.intel.com>
    Signed-off-by: Wu Hao <hao.wu@intel.com>
    Acked-by: Alan Tull <atull@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/fpga/dfl.h b/drivers/fpga/dfl.h
index b4f65250a29c..14d4731c13b0 100644
--- a/drivers/fpga/dfl.h
+++ b/drivers/fpga/dfl.h
@@ -131,6 +131,17 @@
 #define PORT_CTRL_LATENCY	BIT_ULL(2)
 #define PORT_CTRL_SFTRST_ACK	BIT_ULL(4)		/* HW ack for reset */
 
+/**
+ * struct dfl_feature_driver - sub feature's driver
+ *
+ * @id: sub feature id.
+ * @ops: ops of this sub feature.
+ */
+struct dfl_feature_driver {
+	u64 id;
+	const struct dfl_feature_ops *ops;
+};
+
 /**
  * struct dfl_feature - sub feature of the feature devices
  *
@@ -139,13 +150,17 @@
  *		    this index is used to find its mmio resource from the
  *		    feature dev (platform device)'s reources.
  * @ioaddr: mapped mmio resource address.
+ * @ops: ops of this sub feature.
  */
 struct dfl_feature {
 	u64 id;
 	int resource_index;
 	void __iomem *ioaddr;
+	const struct dfl_feature_ops *ops;
 };
 
+#define DEV_STATUS_IN_USE	0
+
 /**
  * struct dfl_feature_platform_data - platform data for feature devices
  *
@@ -156,6 +171,8 @@ struct dfl_feature {
  * @dfl_cdev: ptr to container device.
  * @disable_count: count for port disable.
  * @num: number for sub features.
+ * @dev_status: dev status (e.g. DEV_STATUS_IN_USE).
+ * @private: ptr to feature dev private data.
  * @features: sub features of this feature dev.
  */
 struct dfl_feature_platform_data {
@@ -165,11 +182,49 @@ struct dfl_feature_platform_data {
 	struct platform_device *dev;
 	struct dfl_fpga_cdev *dfl_cdev;
 	unsigned int disable_count;
-
+	unsigned long dev_status;
+	void *private;
 	int num;
 	struct dfl_feature features[0];
 };
 
+static inline
+int dfl_feature_dev_use_begin(struct dfl_feature_platform_data *pdata)
+{
+	/* Test and set IN_USE flags to ensure file is exclusively used */
+	if (test_and_set_bit_lock(DEV_STATUS_IN_USE, &pdata->dev_status))
+		return -EBUSY;
+
+	return 0;
+}
+
+static inline
+void dfl_feature_dev_use_end(struct dfl_feature_platform_data *pdata)
+{
+	clear_bit_unlock(DEV_STATUS_IN_USE, &pdata->dev_status);
+}
+
+static inline
+void dfl_fpga_pdata_set_private(struct dfl_feature_platform_data *pdata,
+				void *private)
+{
+	pdata->private = private;
+}
+
+static inline
+void *dfl_fpga_pdata_get_private(struct dfl_feature_platform_data *pdata)
+{
+	return pdata->private;
+}
+
+struct dfl_feature_ops {
+	int (*init)(struct platform_device *pdev, struct dfl_feature *feature);
+	void (*uinit)(struct platform_device *pdev,
+		      struct dfl_feature *feature);
+	long (*ioctl)(struct platform_device *pdev, struct dfl_feature *feature,
+		      unsigned int cmd, unsigned long arg);
+};
+
 #define DFL_FPGA_FEATURE_DEV_FME		"dfl-fme"
 #define DFL_FPGA_FEATURE_DEV_PORT		"dfl-port"
 
@@ -179,11 +234,25 @@ static inline int dfl_feature_platform_data_size(const int num)
 		num * sizeof(struct dfl_feature);
 }
 
+void dfl_fpga_dev_feature_uinit(struct platform_device *pdev);
+int dfl_fpga_dev_feature_init(struct platform_device *pdev,
+			      struct dfl_feature_driver *feature_drvs);
+
 int dfl_fpga_dev_ops_register(struct platform_device *pdev,
 			      const struct file_operations *fops,
 			      struct module *owner);
 void dfl_fpga_dev_ops_unregister(struct platform_device *pdev);
 
+static inline
+struct platform_device *dfl_fpga_inode_to_feature_dev(struct inode *inode)
+{
+	struct dfl_feature_platform_data *pdata;
+
+	pdata = container_of(inode->i_cdev, struct dfl_feature_platform_data,
+			     cdev);
+	return pdata->dev;
+}
+
 #define dfl_fpga_dev_for_each_feature(pdata, feature)			    \
 	for ((feature) = (pdata)->features;				    \
 	   (feature) < (pdata)->features + (pdata)->num; (feature)++)
@@ -213,6 +282,17 @@ void __iomem *dfl_get_feature_ioaddr_by_id(struct device *dev, u64 id)
 	return NULL;
 }
 
+static inline bool is_dfl_feature_present(struct device *dev, u64 id)
+{
+	return !!dfl_get_feature_ioaddr_by_id(dev, id);
+}
+
+static inline
+struct device *dfl_fpga_pdata_to_parent(struct dfl_feature_platform_data *pdata)
+{
+	return pdata->dev->dev.parent->parent;
+}
+
 static inline bool dfl_feature_is_fme(void __iomem *base)
 {
 	u64 v = readq(base + DFH);

commit 5d56e117001996766c3dab5767663b0c43b76639
Author: Wu Hao <hao.wu@intel.com>
Date:   Sat Jun 30 08:53:15 2018 +0800

    fpga: dfl: add dfl_fpga_cdev_find_port
    
    For feature devices, we need a method to find the port dedicated
    to the device. This patch adds a function dfl_fpga_cdev_find_port
    for this purpose. e.g. FPGA Management Engine (FME) Partial
    Reconfiguration sub feature, it uses this function to find
    dedicated port on the device for PR function implementation.
    
    Signed-off-by: Tim Whisonant <tim.whisonant@intel.com>
    Signed-off-by: Enno Luebbers <enno.luebbers@intel.com>
    Signed-off-by: Shiva Rao <shiva.rao@intel.com>
    Signed-off-by: Christopher Rauer <christopher.rauer@intel.com>
    Signed-off-by: Xiao Guangrong <guangrong.xiao@linux.intel.com>
    Signed-off-by: Wu Hao <hao.wu@intel.com>
    Acked-by: Alan Tull <atull@kernel.org>
    Acked-by: Moritz Fischer <mdf@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/fpga/dfl.h b/drivers/fpga/dfl.h
index 66c2ade5a06b..b4f65250a29c 100644
--- a/drivers/fpga/dfl.h
+++ b/drivers/fpga/dfl.h
@@ -284,4 +284,25 @@ struct dfl_fpga_cdev *
 dfl_fpga_feature_devs_enumerate(struct dfl_fpga_enum_info *info);
 void dfl_fpga_feature_devs_remove(struct dfl_fpga_cdev *cdev);
 
+/*
+ * need to drop the device reference with put_device() after use port platform
+ * device returned by __dfl_fpga_cdev_find_port and dfl_fpga_cdev_find_port
+ * functions.
+ */
+struct platform_device *
+__dfl_fpga_cdev_find_port(struct dfl_fpga_cdev *cdev, void *data,
+			  int (*match)(struct platform_device *, void *));
+
+static inline struct platform_device *
+dfl_fpga_cdev_find_port(struct dfl_fpga_cdev *cdev, void *data,
+			int (*match)(struct platform_device *, void *))
+{
+	struct platform_device *pdev;
+
+	mutex_lock(&cdev->lock);
+	pdev = __dfl_fpga_cdev_find_port(cdev, data, match);
+	mutex_unlock(&cdev->lock);
+
+	return pdev;
+}
 #endif /* __FPGA_DFL_H */

commit b16c5147dc3b1a03405f58f6864b56f29ab7aaf9
Author: Wu Hao <hao.wu@intel.com>
Date:   Sat Jun 30 08:53:14 2018 +0800

    fpga: dfl: add chardev support for feature devices
    
    For feature devices drivers, both the FPGA Management Engine (FME) and
    Accelerated Function Unit (AFU) driver need to expose user interfaces via
    the device file, for example, mmap and ioctls.
    
    This patch adds chardev support in the dfl driver for feature devices,
    FME and AFU. It reserves the chardev regions for FME and AFU and provide
    interfaces for FME and AFU driver to register their device file operations.
    
    Signed-off-by: Tim Whisonant <tim.whisonant@intel.com>
    Signed-off-by: Enno Luebbers <enno.luebbers@intel.com>
    Signed-off-by: Shiva Rao <shiva.rao@intel.com>
    Signed-off-by: Christopher Rauer <christopher.rauer@intel.com>
    Signed-off-by: Zhang Yi <yi.z.zhang@intel.com>
    Signed-off-by: Xiao Guangrong <guangrong.xiao@linux.intel.com>
    Signed-off-by: Wu Hao <hao.wu@intel.com>
    Acked-by: Alan Tull <atull@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/fpga/dfl.h b/drivers/fpga/dfl.h
index 47ecb3bb6f61..66c2ade5a06b 100644
--- a/drivers/fpga/dfl.h
+++ b/drivers/fpga/dfl.h
@@ -15,6 +15,7 @@
 #define __FPGA_DFL_H
 
 #include <linux/bitfield.h>
+#include <linux/cdev.h>
 #include <linux/delay.h>
 #include <linux/fs.h>
 #include <linux/iopoll.h>
@@ -150,6 +151,7 @@ struct dfl_feature {
  *
  * @node: node to link feature devs to container device's port_dev_list.
  * @lock: mutex to protect platform data.
+ * @cdev: cdev of feature dev.
  * @dev: ptr to platform device linked with this platform data.
  * @dfl_cdev: ptr to container device.
  * @disable_count: count for port disable.
@@ -159,6 +161,7 @@ struct dfl_feature {
 struct dfl_feature_platform_data {
 	struct list_head node;
 	struct mutex lock;
+	struct cdev cdev;
 	struct platform_device *dev;
 	struct dfl_fpga_cdev *dfl_cdev;
 	unsigned int disable_count;
@@ -176,6 +179,11 @@ static inline int dfl_feature_platform_data_size(const int num)
 		num * sizeof(struct dfl_feature);
 }
 
+int dfl_fpga_dev_ops_register(struct platform_device *pdev,
+			      const struct file_operations *fops,
+			      struct module *owner);
+void dfl_fpga_dev_ops_unregister(struct platform_device *pdev);
+
 #define dfl_fpga_dev_for_each_feature(pdata, feature)			    \
 	for ((feature) = (pdata)->features;				    \
 	   (feature) < (pdata)->features + (pdata)->num; (feature)++)

commit 543be3d8c999b30e1e1c05d30c1ea3f2d922340b
Author: Wu Hao <hao.wu@intel.com>
Date:   Sat Jun 30 08:53:13 2018 +0800

    fpga: add device feature list support
    
    Device Feature List (DFL) defines a feature list structure that creates
    a linked list of feature headers within the MMIO space to provide an
    extensible way of adding features. This patch introduces a kernel module
    to provide basic infrastructure to support FPGA devices which implement
    the Device Feature List.
    
    Usually there will be different features and their sub features linked into
    the DFL. This code provides common APIs for feature enumeration, it creates
    a container device (FPGA base region), walks through the DFLs and creates
    platform devices for feature devices (Currently it only supports two
    different feature devices, FPGA Management Engine (FME) and Port which
    the Accelerator Function Unit (AFU) connected to). In order to enumerate
    the DFLs, the common APIs required low level driver to provide necessary
    enumeration information (e.g. address for each device feature list for
    given device) and fill it to the dfl_fpga_enum_info data structure. Please
    refer to below description for APIs added for enumeration.
    
    Functions for enumeration information preparation:
     *dfl_fpga_enum_info_alloc
       allocate enumeration information data structure.
    
     *dfl_fpga_enum_info_add_dfl
       add a device feature list to dfl_fpga_enum_info data structure.
    
     *dfl_fpga_enum_info_free
       free dfl_fpga_enum_info data structure and related resources.
    
    Functions for feature device enumeration:
     *dfl_fpga_feature_devs_enumerate
       enumerate feature devices and return container device.
    
     *dfl_fpga_feature_devs_remove
       remove feature devices under given container device.
    
    Signed-off-by: Tim Whisonant <tim.whisonant@intel.com>
    Signed-off-by: Enno Luebbers <enno.luebbers@intel.com>
    Signed-off-by: Shiva Rao <shiva.rao@intel.com>
    Signed-off-by: Christopher Rauer <christopher.rauer@intel.com>
    Signed-off-by: Zhang Yi <yi.z.zhang@intel.com>
    Signed-off-by: Xiao Guangrong <guangrong.xiao@linux.intel.com>
    Signed-off-by: Wu Hao <hao.wu@intel.com>
    Acked-by: Alan Tull <atull@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/fpga/dfl.h b/drivers/fpga/dfl.h
new file mode 100644
index 000000000000..47ecb3bb6f61
--- /dev/null
+++ b/drivers/fpga/dfl.h
@@ -0,0 +1,279 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Driver Header File for FPGA Device Feature List (DFL) Support
+ *
+ * Copyright (C) 2017-2018 Intel Corporation, Inc.
+ *
+ * Authors:
+ *   Kang Luwei <luwei.kang@intel.com>
+ *   Zhang Yi <yi.z.zhang@intel.com>
+ *   Wu Hao <hao.wu@intel.com>
+ *   Xiao Guangrong <guangrong.xiao@linux.intel.com>
+ */
+
+#ifndef __FPGA_DFL_H
+#define __FPGA_DFL_H
+
+#include <linux/bitfield.h>
+#include <linux/delay.h>
+#include <linux/fs.h>
+#include <linux/iopoll.h>
+#include <linux/io-64-nonatomic-lo-hi.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/uuid.h>
+#include <linux/fpga/fpga-region.h>
+
+/* maximum supported number of ports */
+#define MAX_DFL_FPGA_PORT_NUM 4
+/* plus one for fme device */
+#define MAX_DFL_FEATURE_DEV_NUM    (MAX_DFL_FPGA_PORT_NUM + 1)
+
+/* Reserved 0x0 for Header Group Register and 0xff for AFU */
+#define FEATURE_ID_FIU_HEADER		0x0
+#define FEATURE_ID_AFU			0xff
+
+#define FME_FEATURE_ID_HEADER		FEATURE_ID_FIU_HEADER
+#define FME_FEATURE_ID_THERMAL_MGMT	0x1
+#define FME_FEATURE_ID_POWER_MGMT	0x2
+#define FME_FEATURE_ID_GLOBAL_IPERF	0x3
+#define FME_FEATURE_ID_GLOBAL_ERR	0x4
+#define FME_FEATURE_ID_PR_MGMT		0x5
+#define FME_FEATURE_ID_HSSI		0x6
+#define FME_FEATURE_ID_GLOBAL_DPERF	0x7
+
+#define PORT_FEATURE_ID_HEADER		FEATURE_ID_FIU_HEADER
+#define PORT_FEATURE_ID_AFU		FEATURE_ID_AFU
+#define PORT_FEATURE_ID_ERROR		0x10
+#define PORT_FEATURE_ID_UMSG		0x11
+#define PORT_FEATURE_ID_UINT		0x12
+#define PORT_FEATURE_ID_STP		0x13
+
+/*
+ * Device Feature Header Register Set
+ *
+ * For FIUs, they all have DFH + GUID + NEXT_AFU as common header registers.
+ * For AFUs, they have DFH + GUID as common header registers.
+ * For private features, they only have DFH register as common header.
+ */
+#define DFH			0x0
+#define GUID_L			0x8
+#define GUID_H			0x10
+#define NEXT_AFU		0x18
+
+#define DFH_SIZE		0x8
+
+/* Device Feature Header Register Bitfield */
+#define DFH_ID			GENMASK_ULL(11, 0)	/* Feature ID */
+#define DFH_ID_FIU_FME		0
+#define DFH_ID_FIU_PORT		1
+#define DFH_REVISION		GENMASK_ULL(15, 12)	/* Feature revision */
+#define DFH_NEXT_HDR_OFST	GENMASK_ULL(39, 16)	/* Offset to next DFH */
+#define DFH_EOL			BIT_ULL(40)		/* End of list */
+#define DFH_TYPE		GENMASK_ULL(63, 60)	/* Feature type */
+#define DFH_TYPE_AFU		1
+#define DFH_TYPE_PRIVATE	3
+#define DFH_TYPE_FIU		4
+
+/* Next AFU Register Bitfield */
+#define NEXT_AFU_NEXT_DFH_OFST	GENMASK_ULL(23, 0)	/* Offset to next AFU */
+
+/* FME Header Register Set */
+#define FME_HDR_DFH		DFH
+#define FME_HDR_GUID_L		GUID_L
+#define FME_HDR_GUID_H		GUID_H
+#define FME_HDR_NEXT_AFU	NEXT_AFU
+#define FME_HDR_CAP		0x30
+#define FME_HDR_PORT_OFST(n)	(0x38 + ((n) * 0x8))
+#define FME_HDR_BITSTREAM_ID	0x60
+#define FME_HDR_BITSTREAM_MD	0x68
+
+/* FME Fab Capability Register Bitfield */
+#define FME_CAP_FABRIC_VERID	GENMASK_ULL(7, 0)	/* Fabric version ID */
+#define FME_CAP_SOCKET_ID	BIT_ULL(8)		/* Socket ID */
+#define FME_CAP_PCIE0_LINK_AVL	BIT_ULL(12)		/* PCIE0 Link */
+#define FME_CAP_PCIE1_LINK_AVL	BIT_ULL(13)		/* PCIE1 Link */
+#define FME_CAP_COHR_LINK_AVL	BIT_ULL(14)		/* Coherent Link */
+#define FME_CAP_IOMMU_AVL	BIT_ULL(16)		/* IOMMU available */
+#define FME_CAP_NUM_PORTS	GENMASK_ULL(19, 17)	/* Number of ports */
+#define FME_CAP_ADDR_WIDTH	GENMASK_ULL(29, 24)	/* Address bus width */
+#define FME_CAP_CACHE_SIZE	GENMASK_ULL(43, 32)	/* cache size in KB */
+#define FME_CAP_CACHE_ASSOC	GENMASK_ULL(47, 44)	/* Associativity */
+
+/* FME Port Offset Register Bitfield */
+/* Offset to port device feature header */
+#define FME_PORT_OFST_DFH_OFST	GENMASK_ULL(23, 0)
+/* PCI Bar ID for this port */
+#define FME_PORT_OFST_BAR_ID	GENMASK_ULL(34, 32)
+/* AFU MMIO access permission. 1 - VF, 0 - PF. */
+#define FME_PORT_OFST_ACC_CTRL	BIT_ULL(55)
+#define FME_PORT_OFST_ACC_PF	0
+#define FME_PORT_OFST_ACC_VF	1
+#define FME_PORT_OFST_IMP	BIT_ULL(60)
+
+/* PORT Header Register Set */
+#define PORT_HDR_DFH		DFH
+#define PORT_HDR_GUID_L		GUID_L
+#define PORT_HDR_GUID_H		GUID_H
+#define PORT_HDR_NEXT_AFU	NEXT_AFU
+#define PORT_HDR_CAP		0x30
+#define PORT_HDR_CTRL		0x38
+
+/* Port Capability Register Bitfield */
+#define PORT_CAP_PORT_NUM	GENMASK_ULL(1, 0)	/* ID of this port */
+#define PORT_CAP_MMIO_SIZE	GENMASK_ULL(23, 8)	/* MMIO size in KB */
+#define PORT_CAP_SUPP_INT_NUM	GENMASK_ULL(35, 32)	/* Interrupts num */
+
+/* Port Control Register Bitfield */
+#define PORT_CTRL_SFTRST	BIT_ULL(0)		/* Port soft reset */
+/* Latency tolerance reporting. '1' >= 40us, '0' < 40us.*/
+#define PORT_CTRL_LATENCY	BIT_ULL(2)
+#define PORT_CTRL_SFTRST_ACK	BIT_ULL(4)		/* HW ack for reset */
+
+/**
+ * struct dfl_feature - sub feature of the feature devices
+ *
+ * @id: sub feature id.
+ * @resource_index: each sub feature has one mmio resource for its registers.
+ *		    this index is used to find its mmio resource from the
+ *		    feature dev (platform device)'s reources.
+ * @ioaddr: mapped mmio resource address.
+ */
+struct dfl_feature {
+	u64 id;
+	int resource_index;
+	void __iomem *ioaddr;
+};
+
+/**
+ * struct dfl_feature_platform_data - platform data for feature devices
+ *
+ * @node: node to link feature devs to container device's port_dev_list.
+ * @lock: mutex to protect platform data.
+ * @dev: ptr to platform device linked with this platform data.
+ * @dfl_cdev: ptr to container device.
+ * @disable_count: count for port disable.
+ * @num: number for sub features.
+ * @features: sub features of this feature dev.
+ */
+struct dfl_feature_platform_data {
+	struct list_head node;
+	struct mutex lock;
+	struct platform_device *dev;
+	struct dfl_fpga_cdev *dfl_cdev;
+	unsigned int disable_count;
+
+	int num;
+	struct dfl_feature features[0];
+};
+
+#define DFL_FPGA_FEATURE_DEV_FME		"dfl-fme"
+#define DFL_FPGA_FEATURE_DEV_PORT		"dfl-port"
+
+static inline int dfl_feature_platform_data_size(const int num)
+{
+	return sizeof(struct dfl_feature_platform_data) +
+		num * sizeof(struct dfl_feature);
+}
+
+#define dfl_fpga_dev_for_each_feature(pdata, feature)			    \
+	for ((feature) = (pdata)->features;				    \
+	   (feature) < (pdata)->features + (pdata)->num; (feature)++)
+
+static inline
+struct dfl_feature *dfl_get_feature_by_id(struct device *dev, u64 id)
+{
+	struct dfl_feature_platform_data *pdata = dev_get_platdata(dev);
+	struct dfl_feature *feature;
+
+	dfl_fpga_dev_for_each_feature(pdata, feature)
+		if (feature->id == id)
+			return feature;
+
+	return NULL;
+}
+
+static inline
+void __iomem *dfl_get_feature_ioaddr_by_id(struct device *dev, u64 id)
+{
+	struct dfl_feature *feature = dfl_get_feature_by_id(dev, id);
+
+	if (feature && feature->ioaddr)
+		return feature->ioaddr;
+
+	WARN_ON(1);
+	return NULL;
+}
+
+static inline bool dfl_feature_is_fme(void __iomem *base)
+{
+	u64 v = readq(base + DFH);
+
+	return (FIELD_GET(DFH_TYPE, v) == DFH_TYPE_FIU) &&
+		(FIELD_GET(DFH_ID, v) == DFH_ID_FIU_FME);
+}
+
+static inline bool dfl_feature_is_port(void __iomem *base)
+{
+	u64 v = readq(base + DFH);
+
+	return (FIELD_GET(DFH_TYPE, v) == DFH_TYPE_FIU) &&
+		(FIELD_GET(DFH_ID, v) == DFH_ID_FIU_PORT);
+}
+
+/**
+ * struct dfl_fpga_enum_info - DFL FPGA enumeration information
+ *
+ * @dev: parent device.
+ * @dfls: list of device feature lists.
+ */
+struct dfl_fpga_enum_info {
+	struct device *dev;
+	struct list_head dfls;
+};
+
+/**
+ * struct dfl_fpga_enum_dfl - DFL FPGA enumeration device feature list info
+ *
+ * @start: base address of this device feature list.
+ * @len: size of this device feature list.
+ * @ioaddr: mapped base address of this device feature list.
+ * @node: node in list of device feature lists.
+ */
+struct dfl_fpga_enum_dfl {
+	resource_size_t start;
+	resource_size_t len;
+
+	void __iomem *ioaddr;
+
+	struct list_head node;
+};
+
+struct dfl_fpga_enum_info *dfl_fpga_enum_info_alloc(struct device *dev);
+int dfl_fpga_enum_info_add_dfl(struct dfl_fpga_enum_info *info,
+			       resource_size_t start, resource_size_t len,
+			       void __iomem *ioaddr);
+void dfl_fpga_enum_info_free(struct dfl_fpga_enum_info *info);
+
+/**
+ * struct dfl_fpga_cdev - container device of DFL based FPGA
+ *
+ * @parent: parent device of this container device.
+ * @region: base fpga region.
+ * @fme_dev: FME feature device under this container device.
+ * @lock: mutex lock to protect the port device list.
+ * @port_dev_list: list of all port feature devices under this container device.
+ */
+struct dfl_fpga_cdev {
+	struct device *parent;
+	struct fpga_region *region;
+	struct device *fme_dev;
+	struct mutex lock;
+	struct list_head port_dev_list;
+};
+
+struct dfl_fpga_cdev *
+dfl_fpga_feature_devs_enumerate(struct dfl_fpga_enum_info *info);
+void dfl_fpga_feature_devs_remove(struct dfl_fpga_cdev *cdev);
+
+#endif /* __FPGA_DFL_H */
