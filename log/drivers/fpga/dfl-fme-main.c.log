commit f877a18c08fa6674364e469f318a3069c68204d2
Merge: 84c1e51d7df8 a2b9d4eadb77
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri May 15 16:09:24 2020 +0200

    Merge tag 'fpga-for-5.8' of git://git.kernel.org/pub/scm/linux/kernel/git/mdf/linux-fpga into char-misc-next
    
    Moritz writes:
    
    FPGA Manager changes for 5.8
    
    Here's the first set of changes for the 5.8-rc1 merge window.
    
    Dominic's change adds support for accessing AFU regions with gdb.
    Gustavo's change is a cleanup patch regarding variable lenght arrays.
    Richard's changes update dt-bindings and add support for stratix and agilex.
    Sergiu's changes update spi transfers with the new delay field.
    Xu's change addresses an issue with a wrong return value.
    Shubhrajyoti's change makes the Zynq FPGA driver return -EPROBE_DEFER on
    check of devm_clk_get failure.
    Xu's change for DFL enables multiple opens.
    
    All of these patches have been reviewed, have appropriate Acked-by's and
    have been in the last few linux-next releases without issues.
    
    Signed-off-by: Moritz Fischer <mdf@kernel.org>
    
    * tag 'fpga-for-5.8' of git://git.kernel.org/pub/scm/linux/kernel/git/mdf/linux-fpga:
      fpga: dfl: afu: support debug access to memory-mapped afu regions
      fpga: dfl.h: Replace zero-length array with flexible-array member
      arm64: dts: agilex: correct service layer driver's compatible value
      dt-bindings, firmware: add compatible value Intel Stratix10 service layer binding
      fpga: stratix10-soc: add compatible property value for intel agilex
      arm64: dts: agilex: correct FPGA manager driver's compatible value
      dt-bindings: fpga: add compatible value to Stratix10 SoC FPGA manager binding
      fpga: machxo2-spi: Use new structure for SPI transfer delays
      fpga: ice40-spi: Use new structure for SPI transfer delays
      fpga: dfl: support multiple opens on feature device node.

commit b6862193ca12e4bce6a18f31bb36eaa6d801b377
Author: Xu Yilun <yilun.xu@intel.com>
Date:   Mon Nov 18 13:20:41 2019 +0800

    fpga: dfl: support multiple opens on feature device node.
    
    Each DFL functional block, e.g. AFU (Accelerated Function Unit) and FME
    (FPGA Management Engine), could implement more than one function within
    its region, but current driver only allows one user application to access
    it by exclusive open on device node. So this is not convenient and
    flexible for userspace applications, as they have to combine lots of
    different functions into one single application.
    
    This patch removes the limitation here to allow multiple opens to each
    feature device node for AFU and FME from userspace applications. If user
    still needs exclusive access to these device node, O_EXCL flag must be
    issued together with open.
    
    Signed-off-by: Wu Hao <hao.wu@intel.com>
    Signed-off-by: Xu Yilun <yilun.xu@intel.com>
    Signed-off-by: Moritz Fischer <mdf@kernel.org>

diff --git a/drivers/fpga/dfl-fme-main.c b/drivers/fpga/dfl-fme-main.c
index 1d4690c99268..56d720c1af39 100644
--- a/drivers/fpga/dfl-fme-main.c
+++ b/drivers/fpga/dfl-fme-main.c
@@ -600,14 +600,16 @@ static int fme_open(struct inode *inode, struct file *filp)
 	if (WARN_ON(!pdata))
 		return -ENODEV;
 
-	ret = dfl_feature_dev_use_begin(pdata);
-	if (ret)
-		return ret;
-
-	dev_dbg(&fdev->dev, "Device File Open\n");
-	filp->private_data = pdata;
+	mutex_lock(&pdata->lock);
+	ret = dfl_feature_dev_use_begin(pdata, filp->f_flags & O_EXCL);
+	if (!ret) {
+		dev_dbg(&fdev->dev, "Device File Opened %d Times\n",
+			dfl_feature_dev_use_count(pdata));
+		filp->private_data = pdata;
+	}
+	mutex_unlock(&pdata->lock);
 
-	return 0;
+	return ret;
 }
 
 static int fme_release(struct inode *inode, struct file *filp)
@@ -616,7 +618,10 @@ static int fme_release(struct inode *inode, struct file *filp)
 	struct platform_device *pdev = pdata->dev;
 
 	dev_dbg(&pdev->dev, "Device File Release\n");
+
+	mutex_lock(&pdata->lock);
 	dfl_feature_dev_use_end(pdata);
+	mutex_unlock(&pdata->lock);
 
 	return 0;
 }

commit 724142f8c42a7b01dbf9738eb00d7addbad6f862
Author: Wu Hao <hao.wu@intel.com>
Date:   Mon Apr 27 09:06:23 2020 +0800

    fpga: dfl: fme: add performance reporting support
    
    This patch adds support for performance reporting private feature
    for FPGA Management Engine (FME). Now it supports several different
    performance counters, including 'basic', 'cache', 'fabric', 'vtd'
    and 'vtd_sip'. It allows user to use standard linux tools to access
    these performance counters.
    
    e.g. List all events by "perf list"
    
      perf list | grep fme
    
      dfl_fme0/cache_read_hit/                     [Kernel PMU event]
      dfl_fme0/cache_read_miss/                    [Kernel PMU event]
      ...
    
      dfl_fme0/fab_mmio_read/                      [Kernel PMU event]
      dfl_fme0/fab_mmio_write/                     [Kernel PMU event]
      ...
    
      dfl_fme0/fab_port_mmio_read,portid=?/        [Kernel PMU event]
      dfl_fme0/fab_port_mmio_write,portid=?/       [Kernel PMU event]
      ...
    
      dfl_fme0/vtd_port_devtlb_1g_fill,portid=?/   [Kernel PMU event]
      dfl_fme0/vtd_port_devtlb_2m_fill,portid=?/   [Kernel PMU event]
      ...
    
      dfl_fme0/vtd_sip_iotlb_1g_hit/               [Kernel PMU event]
      dfl_fme0/vtd_sip_iotlb_1g_miss/              [Kernel PMU event]
      ...
    
      dfl_fme0/clock                               [Kernel PMU event]
      ...
    
    e.g. check increased counter value after run one application using
    "perf stat" command.
    
     perf stat -e dfl_fme0/fab_mmio_read/,dfl_fme0/fab_mmio_write/ ./test
    
     Performance counter stats for './test':
    
                     1      dfl_fme0/fab_mmio_read/
                     2      dfl_fme0/fab_mmio_write/
    
           1.009496520 seconds time elapsed
    
    Please note that fabric counters support both fab_* and fab_port_*, but
    actually they are sharing one set of performance counters in hardware.
    If user wants to monitor overall data events on fab_* then fab_port_*
    can't be supported at the same time, see example below:
    
    perf stat -e dfl_fme0/fab_mmio_read/,dfl_fme0/fab_port_mmio_write,portid=0/
    
     Performance counter stats for 'system wide':
    
                     0      dfl_fme0/fab_mmio_read/
       <not supported>      dfl_fme0/fab_port_mmio_write,portid=0/
    
           2.141064085 seconds time elapsed
    
    Signed-off-by: Luwei Kang <luwei.kang@intel.com>
    Signed-off-by: Xu Yilun <yilun.xu@intel.com>
    Signed-off-by: Wu Hao <hao.wu@intel.com>
    Link: https://lore.kernel.org/r/1587949583-12058-3-git-send-email-hao.wu@intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/fpga/dfl-fme-main.c b/drivers/fpga/dfl-fme-main.c
index 1d4690c99268..353305629a0e 100644
--- a/drivers/fpga/dfl-fme-main.c
+++ b/drivers/fpga/dfl-fme-main.c
@@ -579,6 +579,10 @@ static struct dfl_feature_driver fme_feature_drvs[] = {
 		.id_table = fme_power_mgmt_id_table,
 		.ops = &fme_power_mgmt_ops,
 	},
+	{
+		.id_table = fme_perf_id_table,
+		.ops = &fme_perf_ops,
+	},
 	{
 		.ops = NULL,
 	},

commit 8082c51ac34d05258ac80de47eab1a5d727bb5d2
Author: yu kuai <yukuai3@huawei.com>
Date:   Thu Dec 26 20:16:38 2019 +0800

    fpga: dfl: fme: remove set but not used variable 'fme'
    
    Fixes gcc '-Wunused-but-set-variable' warning:
    
    drivers/fpga/dfl-fme-main.c: In function ‘fme_dev_destroy’:
    drivers/fpga/dfl-fme-main.c:678:18: warning: variable ‘fme’ set but not
    used [-Wunused-but-set-variable]
    
    It is never used and so can be removed.
    
    Acked-by: Wu Hao <hao.wu@intel.com>
    Signed-off-by: yu kuai <yukuai3@huawei.com>
    Signed-off-by: Moritz Fischer <mdf@kernel.org>

diff --git a/drivers/fpga/dfl-fme-main.c b/drivers/fpga/dfl-fme-main.c
index 7c930e6b314d..1d4690c99268 100644
--- a/drivers/fpga/dfl-fme-main.c
+++ b/drivers/fpga/dfl-fme-main.c
@@ -675,10 +675,8 @@ static int fme_dev_init(struct platform_device *pdev)
 static void fme_dev_destroy(struct platform_device *pdev)
 {
 	struct dfl_feature_platform_data *pdata = dev_get_platdata(&pdev->dev);
-	struct dfl_fme *fme;
 
 	mutex_lock(&pdata->lock);
-	fme = dfl_fpga_pdata_get_private(pdata);
 	dfl_fpga_pdata_set_private(pdata, NULL);
 	mutex_unlock(&pdata->lock);
 }

commit fddc9fcbe69a502d84adf0bad5e2c6c80823838c
Author: Wu Hao <hao.wu@intel.com>
Date:   Mon Oct 14 13:42:03 2019 +0800

    fpga: dfl: fme: add power management support
    
    This patch adds support for power management private feature under
    FPGA Management Engine (FME). This private feature driver registers
    a hwmon for power (power1_input), thresholds information, e.g.
    (power1_max / crit / max_alarm / crit_alarm) and also read-only sysfs
    interfaces for other power management information. For configuration,
    user could write threshold values via above power1_max / crit sysfs
    interface under hwmon too.
    
    Signed-off-by: Luwei Kang <luwei.kang@intel.com>
    Signed-off-by: Xu Yilun <yilun.xu@intel.com>
    Signed-off-by: Wu Hao <hao.wu@intel.com>
    Acked-by: Guenter Roeck <linux@roeck-us.net>
    Reviewed-by: Moritz Fischer <mdf@kernel.org>
    Signed-off-by: Moritz Fischer <mdf@kernel.org>

diff --git a/drivers/fpga/dfl-fme-main.c b/drivers/fpga/dfl-fme-main.c
index 752d71c1748e..7c930e6b314d 100644
--- a/drivers/fpga/dfl-fme-main.c
+++ b/drivers/fpga/dfl-fme-main.c
@@ -355,6 +355,209 @@ static const struct dfl_feature_ops fme_thermal_mgmt_ops = {
 	.init = fme_thermal_mgmt_init,
 };
 
+#define FME_PWR_STATUS		0x8
+#define FME_LATENCY_TOLERANCE	BIT_ULL(18)
+#define PWR_CONSUMED		GENMASK_ULL(17, 0)
+
+#define FME_PWR_THRESHOLD	0x10
+#define PWR_THRESHOLD1		GENMASK_ULL(6, 0)	/* in Watts */
+#define PWR_THRESHOLD2		GENMASK_ULL(14, 8)	/* in Watts */
+#define PWR_THRESHOLD_MAX	0x7f			/* in Watts */
+#define PWR_THRESHOLD1_STATUS	BIT_ULL(16)
+#define PWR_THRESHOLD2_STATUS	BIT_ULL(17)
+
+#define FME_PWR_XEON_LIMIT	0x18
+#define XEON_PWR_LIMIT		GENMASK_ULL(14, 0)	/* in 0.1 Watts */
+#define XEON_PWR_EN		BIT_ULL(15)
+#define FME_PWR_FPGA_LIMIT	0x20
+#define FPGA_PWR_LIMIT		GENMASK_ULL(14, 0)	/* in 0.1 Watts */
+#define FPGA_PWR_EN		BIT_ULL(15)
+
+static int power_hwmon_read(struct device *dev, enum hwmon_sensor_types type,
+			    u32 attr, int channel, long *val)
+{
+	struct dfl_feature *feature = dev_get_drvdata(dev);
+	u64 v;
+
+	switch (attr) {
+	case hwmon_power_input:
+		v = readq(feature->ioaddr + FME_PWR_STATUS);
+		*val = (long)(FIELD_GET(PWR_CONSUMED, v) * 1000000);
+		break;
+	case hwmon_power_max:
+		v = readq(feature->ioaddr + FME_PWR_THRESHOLD);
+		*val = (long)(FIELD_GET(PWR_THRESHOLD1, v) * 1000000);
+		break;
+	case hwmon_power_crit:
+		v = readq(feature->ioaddr + FME_PWR_THRESHOLD);
+		*val = (long)(FIELD_GET(PWR_THRESHOLD2, v) * 1000000);
+		break;
+	case hwmon_power_max_alarm:
+		v = readq(feature->ioaddr + FME_PWR_THRESHOLD);
+		*val = (long)FIELD_GET(PWR_THRESHOLD1_STATUS, v);
+		break;
+	case hwmon_power_crit_alarm:
+		v = readq(feature->ioaddr + FME_PWR_THRESHOLD);
+		*val = (long)FIELD_GET(PWR_THRESHOLD2_STATUS, v);
+		break;
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	return 0;
+}
+
+static int power_hwmon_write(struct device *dev, enum hwmon_sensor_types type,
+			     u32 attr, int channel, long val)
+{
+	struct dfl_feature_platform_data *pdata = dev_get_platdata(dev->parent);
+	struct dfl_feature *feature = dev_get_drvdata(dev);
+	int ret = 0;
+	u64 v;
+
+	val = clamp_val(val / 1000000, 0, PWR_THRESHOLD_MAX);
+
+	mutex_lock(&pdata->lock);
+
+	switch (attr) {
+	case hwmon_power_max:
+		v = readq(feature->ioaddr + FME_PWR_THRESHOLD);
+		v &= ~PWR_THRESHOLD1;
+		v |= FIELD_PREP(PWR_THRESHOLD1, val);
+		writeq(v, feature->ioaddr + FME_PWR_THRESHOLD);
+		break;
+	case hwmon_power_crit:
+		v = readq(feature->ioaddr + FME_PWR_THRESHOLD);
+		v &= ~PWR_THRESHOLD2;
+		v |= FIELD_PREP(PWR_THRESHOLD2, val);
+		writeq(v, feature->ioaddr + FME_PWR_THRESHOLD);
+		break;
+	default:
+		ret = -EOPNOTSUPP;
+		break;
+	}
+
+	mutex_unlock(&pdata->lock);
+
+	return ret;
+}
+
+static umode_t power_hwmon_attrs_visible(const void *drvdata,
+					 enum hwmon_sensor_types type,
+					 u32 attr, int channel)
+{
+	switch (attr) {
+	case hwmon_power_input:
+	case hwmon_power_max_alarm:
+	case hwmon_power_crit_alarm:
+		return 0444;
+	case hwmon_power_max:
+	case hwmon_power_crit:
+		return 0644;
+	}
+
+	return 0;
+}
+
+static const struct hwmon_ops power_hwmon_ops = {
+	.is_visible = power_hwmon_attrs_visible,
+	.read = power_hwmon_read,
+	.write = power_hwmon_write,
+};
+
+static const struct hwmon_channel_info *power_hwmon_info[] = {
+	HWMON_CHANNEL_INFO(power, HWMON_P_INPUT |
+				  HWMON_P_MAX   | HWMON_P_MAX_ALARM |
+				  HWMON_P_CRIT  | HWMON_P_CRIT_ALARM),
+	NULL
+};
+
+static const struct hwmon_chip_info power_hwmon_chip_info = {
+	.ops = &power_hwmon_ops,
+	.info = power_hwmon_info,
+};
+
+static ssize_t power1_xeon_limit_show(struct device *dev,
+				      struct device_attribute *attr, char *buf)
+{
+	struct dfl_feature *feature = dev_get_drvdata(dev);
+	u16 xeon_limit = 0;
+	u64 v;
+
+	v = readq(feature->ioaddr + FME_PWR_XEON_LIMIT);
+
+	if (FIELD_GET(XEON_PWR_EN, v))
+		xeon_limit = FIELD_GET(XEON_PWR_LIMIT, v);
+
+	return sprintf(buf, "%u\n", xeon_limit * 100000);
+}
+
+static ssize_t power1_fpga_limit_show(struct device *dev,
+				      struct device_attribute *attr, char *buf)
+{
+	struct dfl_feature *feature = dev_get_drvdata(dev);
+	u16 fpga_limit = 0;
+	u64 v;
+
+	v = readq(feature->ioaddr + FME_PWR_FPGA_LIMIT);
+
+	if (FIELD_GET(FPGA_PWR_EN, v))
+		fpga_limit = FIELD_GET(FPGA_PWR_LIMIT, v);
+
+	return sprintf(buf, "%u\n", fpga_limit * 100000);
+}
+
+static ssize_t power1_ltr_show(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	struct dfl_feature *feature = dev_get_drvdata(dev);
+	u64 v;
+
+	v = readq(feature->ioaddr + FME_PWR_STATUS);
+
+	return sprintf(buf, "%u\n",
+		       (unsigned int)FIELD_GET(FME_LATENCY_TOLERANCE, v));
+}
+
+static DEVICE_ATTR_RO(power1_xeon_limit);
+static DEVICE_ATTR_RO(power1_fpga_limit);
+static DEVICE_ATTR_RO(power1_ltr);
+
+static struct attribute *power_extra_attrs[] = {
+	&dev_attr_power1_xeon_limit.attr,
+	&dev_attr_power1_fpga_limit.attr,
+	&dev_attr_power1_ltr.attr,
+	NULL
+};
+
+ATTRIBUTE_GROUPS(power_extra);
+
+static int fme_power_mgmt_init(struct platform_device *pdev,
+			       struct dfl_feature *feature)
+{
+	struct device *hwmon;
+
+	hwmon = devm_hwmon_device_register_with_info(&pdev->dev,
+						     "dfl_fme_power", feature,
+						     &power_hwmon_chip_info,
+						     power_extra_groups);
+	if (IS_ERR(hwmon)) {
+		dev_err(&pdev->dev, "Fail to register power hwmon\n");
+		return PTR_ERR(hwmon);
+	}
+
+	return 0;
+}
+
+static const struct dfl_feature_id fme_power_mgmt_id_table[] = {
+	{.id = FME_FEATURE_ID_POWER_MGMT,},
+	{0,}
+};
+
+static const struct dfl_feature_ops fme_power_mgmt_ops = {
+	.init = fme_power_mgmt_init,
+};
+
 static struct dfl_feature_driver fme_feature_drvs[] = {
 	{
 		.id_table = fme_hdr_id_table,
@@ -372,6 +575,10 @@ static struct dfl_feature_driver fme_feature_drvs[] = {
 		.id_table = fme_thermal_mgmt_id_table,
 		.ops = &fme_thermal_mgmt_ops,
 	},
+	{
+		.id_table = fme_power_mgmt_id_table,
+		.ops = &fme_power_mgmt_ops,
+	},
 	{
 		.ops = NULL,
 	},

commit 4284c65a9fda9d31f45209062f1b7f9bb438fc04
Author: Wu Hao <hao.wu@intel.com>
Date:   Mon Oct 14 13:42:02 2019 +0800

    fpga: dfl: fme: add thermal management support
    
    This patch adds support to thermal management private feature for DFL
    FPGA Management Engine (FME). This private feature driver registers
    a hwmon for thermal/temperature monitoring (hwmon temp1_input).
    If hardware automatic throttling is supported by this hardware, then
    driver also exposes sysfs interfaces under hwmon for thresholds
    (temp1_max/ crit/ emergency), threshold alarms (temp1_max_alarm/
    temp1_crit_alarm) and throttling policy (temp1_max_policy).
    
    Signed-off-by: Luwei Kang <luwei.kang@intel.com>
    Signed-off-by: Russ Weight <russell.h.weight@intel.com>
    Signed-off-by: Xu Yilun <yilun.xu@intel.com>
    Signed-off-by: Wu Hao <hao.wu@intel.com>
    Acked-by: Guenter Roeck <linux@roeck-us.net>
    Reviewed-by: Moritz Fischer <mdf@kernel.org>
    Signed-off-by: Moritz Fischer <mdf@kernel.org>

diff --git a/drivers/fpga/dfl-fme-main.c b/drivers/fpga/dfl-fme-main.c
index 4d78e182878f..752d71c1748e 100644
--- a/drivers/fpga/dfl-fme-main.c
+++ b/drivers/fpga/dfl-fme-main.c
@@ -14,6 +14,8 @@
  *   Henry Mitchel <henry.mitchel@intel.com>
  */
 
+#include <linux/hwmon.h>
+#include <linux/hwmon-sysfs.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/uaccess.h>
@@ -181,6 +183,178 @@ static const struct dfl_feature_ops fme_hdr_ops = {
 	.ioctl = fme_hdr_ioctl,
 };
 
+#define FME_THERM_THRESHOLD	0x8
+#define TEMP_THRESHOLD1		GENMASK_ULL(6, 0)
+#define TEMP_THRESHOLD1_EN	BIT_ULL(7)
+#define TEMP_THRESHOLD2		GENMASK_ULL(14, 8)
+#define TEMP_THRESHOLD2_EN	BIT_ULL(15)
+#define TRIP_THRESHOLD		GENMASK_ULL(30, 24)
+#define TEMP_THRESHOLD1_STATUS	BIT_ULL(32)		/* threshold1 reached */
+#define TEMP_THRESHOLD2_STATUS	BIT_ULL(33)		/* threshold2 reached */
+/* threshold1 policy: 0 - AP2 (90% throttle) / 1 - AP1 (50% throttle) */
+#define TEMP_THRESHOLD1_POLICY	BIT_ULL(44)
+
+#define FME_THERM_RDSENSOR_FMT1	0x10
+#define FPGA_TEMPERATURE	GENMASK_ULL(6, 0)
+
+#define FME_THERM_CAP		0x20
+#define THERM_NO_THROTTLE	BIT_ULL(0)
+
+#define MD_PRE_DEG
+
+static bool fme_thermal_throttle_support(void __iomem *base)
+{
+	u64 v = readq(base + FME_THERM_CAP);
+
+	return FIELD_GET(THERM_NO_THROTTLE, v) ? false : true;
+}
+
+static umode_t thermal_hwmon_attrs_visible(const void *drvdata,
+					   enum hwmon_sensor_types type,
+					   u32 attr, int channel)
+{
+	const struct dfl_feature *feature = drvdata;
+
+	/* temperature is always supported, and check hardware cap for others */
+	if (attr == hwmon_temp_input)
+		return 0444;
+
+	return fme_thermal_throttle_support(feature->ioaddr) ? 0444 : 0;
+}
+
+static int thermal_hwmon_read(struct device *dev, enum hwmon_sensor_types type,
+			      u32 attr, int channel, long *val)
+{
+	struct dfl_feature *feature = dev_get_drvdata(dev);
+	u64 v;
+
+	switch (attr) {
+	case hwmon_temp_input:
+		v = readq(feature->ioaddr + FME_THERM_RDSENSOR_FMT1);
+		*val = (long)(FIELD_GET(FPGA_TEMPERATURE, v) * 1000);
+		break;
+	case hwmon_temp_max:
+		v = readq(feature->ioaddr + FME_THERM_THRESHOLD);
+		*val = (long)(FIELD_GET(TEMP_THRESHOLD1, v) * 1000);
+		break;
+	case hwmon_temp_crit:
+		v = readq(feature->ioaddr + FME_THERM_THRESHOLD);
+		*val = (long)(FIELD_GET(TEMP_THRESHOLD2, v) * 1000);
+		break;
+	case hwmon_temp_emergency:
+		v = readq(feature->ioaddr + FME_THERM_THRESHOLD);
+		*val = (long)(FIELD_GET(TRIP_THRESHOLD, v) * 1000);
+		break;
+	case hwmon_temp_max_alarm:
+		v = readq(feature->ioaddr + FME_THERM_THRESHOLD);
+		*val = (long)FIELD_GET(TEMP_THRESHOLD1_STATUS, v);
+		break;
+	case hwmon_temp_crit_alarm:
+		v = readq(feature->ioaddr + FME_THERM_THRESHOLD);
+		*val = (long)FIELD_GET(TEMP_THRESHOLD2_STATUS, v);
+		break;
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	return 0;
+}
+
+static const struct hwmon_ops thermal_hwmon_ops = {
+	.is_visible = thermal_hwmon_attrs_visible,
+	.read = thermal_hwmon_read,
+};
+
+static const struct hwmon_channel_info *thermal_hwmon_info[] = {
+	HWMON_CHANNEL_INFO(temp, HWMON_T_INPUT | HWMON_T_EMERGENCY |
+				 HWMON_T_MAX   | HWMON_T_MAX_ALARM |
+				 HWMON_T_CRIT  | HWMON_T_CRIT_ALARM),
+	NULL
+};
+
+static const struct hwmon_chip_info thermal_hwmon_chip_info = {
+	.ops = &thermal_hwmon_ops,
+	.info = thermal_hwmon_info,
+};
+
+static ssize_t temp1_max_policy_show(struct device *dev,
+				     struct device_attribute *attr, char *buf)
+{
+	struct dfl_feature *feature = dev_get_drvdata(dev);
+	u64 v;
+
+	v = readq(feature->ioaddr + FME_THERM_THRESHOLD);
+
+	return sprintf(buf, "%u\n",
+		       (unsigned int)FIELD_GET(TEMP_THRESHOLD1_POLICY, v));
+}
+
+static DEVICE_ATTR_RO(temp1_max_policy);
+
+static struct attribute *thermal_extra_attrs[] = {
+	&dev_attr_temp1_max_policy.attr,
+	NULL,
+};
+
+static umode_t thermal_extra_attrs_visible(struct kobject *kobj,
+					   struct attribute *attr, int index)
+{
+	struct device *dev = kobj_to_dev(kobj);
+	struct dfl_feature *feature = dev_get_drvdata(dev);
+
+	return fme_thermal_throttle_support(feature->ioaddr) ? attr->mode : 0;
+}
+
+static const struct attribute_group thermal_extra_group = {
+	.attrs		= thermal_extra_attrs,
+	.is_visible	= thermal_extra_attrs_visible,
+};
+__ATTRIBUTE_GROUPS(thermal_extra);
+
+static int fme_thermal_mgmt_init(struct platform_device *pdev,
+				 struct dfl_feature *feature)
+{
+	struct device *hwmon;
+
+	/*
+	 * create hwmon to allow userspace monitoring temperature and other
+	 * threshold information.
+	 *
+	 * temp1_input      -> FPGA device temperature
+	 * temp1_max        -> hardware threshold 1 -> 50% or 90% throttling
+	 * temp1_crit       -> hardware threshold 2 -> 100% throttling
+	 * temp1_emergency  -> hardware trip_threshold to shutdown FPGA
+	 * temp1_max_alarm  -> hardware threshold 1 alarm
+	 * temp1_crit_alarm -> hardware threshold 2 alarm
+	 *
+	 * create device specific sysfs interfaces, e.g. read temp1_max_policy
+	 * to understand the actual hardware throttling action (50% vs 90%).
+	 *
+	 * If hardware doesn't support automatic throttling per thresholds,
+	 * then all above sysfs interfaces are not visible except temp1_input
+	 * for temperature.
+	 */
+	hwmon = devm_hwmon_device_register_with_info(&pdev->dev,
+						     "dfl_fme_thermal", feature,
+						     &thermal_hwmon_chip_info,
+						     thermal_extra_groups);
+	if (IS_ERR(hwmon)) {
+		dev_err(&pdev->dev, "Fail to register thermal hwmon\n");
+		return PTR_ERR(hwmon);
+	}
+
+	return 0;
+}
+
+static const struct dfl_feature_id fme_thermal_mgmt_id_table[] = {
+	{.id = FME_FEATURE_ID_THERMAL_MGMT,},
+	{0,}
+};
+
+static const struct dfl_feature_ops fme_thermal_mgmt_ops = {
+	.init = fme_thermal_mgmt_init,
+};
+
 static struct dfl_feature_driver fme_feature_drvs[] = {
 	{
 		.id_table = fme_hdr_id_table,
@@ -194,6 +368,10 @@ static struct dfl_feature_driver fme_feature_drvs[] = {
 		.id_table = fme_global_err_id_table,
 		.ops = &fme_global_err_ops,
 	},
+	{
+		.id_table = fme_thermal_mgmt_id_table,
+		.ops = &fme_thermal_mgmt_ops,
+	},
 	{
 		.ops = NULL,
 	},

commit cb3c2c47e3b8068e5d46ad829318cd077406fc9d
Author: Wu Hao <hao.wu@intel.com>
Date:   Mon Aug 12 10:50:03 2019 +0800

    fpga: dfl: fme: add global error reporting support
    
    This patch adds support for global error reporting for FPGA
    Management Engine (FME), it introduces sysfs interfaces to
    report different error detected by the hardware, and allow
    user to clear errors or inject error for testing purpose.
    
    Signed-off-by: Luwei Kang <luwei.kang@intel.com>
    Signed-off-by: Ananda Ravuri <ananda.ravuri@intel.com>
    Signed-off-by: Xu Yilun <yilun.xu@intel.com>
    Signed-off-by: Wu Hao <hao.wu@intel.com>
    Acked-by: Alan Tull <atull@kernel.org>
    Signed-off-by: Moritz Fischer <mdf@kernel.org>

diff --git a/drivers/fpga/dfl-fme-main.c b/drivers/fpga/dfl-fme-main.c
index bf8114d4d875..4d78e182878f 100644
--- a/drivers/fpga/dfl-fme-main.c
+++ b/drivers/fpga/dfl-fme-main.c
@@ -127,7 +127,10 @@ static struct attribute *fme_hdr_attrs[] = {
 	&dev_attr_socket_id.attr,
 	NULL,
 };
-ATTRIBUTE_GROUPS(fme_hdr);
+
+static const struct attribute_group fme_hdr_group = {
+	.attrs = fme_hdr_attrs,
+};
 
 static long fme_hdr_ioctl_release_port(struct dfl_feature_platform_data *pdata,
 				       unsigned long arg)
@@ -187,6 +190,10 @@ static struct dfl_feature_driver fme_feature_drvs[] = {
 		.id_table = fme_pr_mgmt_id_table,
 		.ops = &fme_pr_mgmt_ops,
 	},
+	{
+		.id_table = fme_global_err_id_table,
+		.ops = &fme_global_err_ops,
+	},
 	{
 		.ops = NULL,
 	},
@@ -333,10 +340,16 @@ static int fme_remove(struct platform_device *pdev)
 	return 0;
 }
 
+static const struct attribute_group *fme_dev_groups[] = {
+	&fme_hdr_group,
+	&fme_global_err_group,
+	NULL
+};
+
 static struct platform_driver fme_driver = {
 	.driver	= {
 		.name       = DFL_FPGA_FEATURE_DEV_FME,
-		.dev_groups = fme_hdr_groups,
+		.dev_groups = fme_dev_groups,
 	},
 	.probe   = fme_probe,
 	.remove  = fme_remove,

commit 084c3ff1b1d29300e5117f145ec6104ed2fd6b46
Author: Wu Hao <hao.wu@intel.com>
Date:   Mon Aug 12 10:49:57 2019 +0800

    fpga: dfl: fme: convert platform_driver to use dev_groups
    
    This patch takes advantage of driver core which helps to create
    and remove sysfs attribute files, so there is no need to register
    sysfs entries manually in dfl-fme platform river code.
    
    Signed-off-by: Wu Hao <hao.wu@intel.com>
    Acked-by: Moritz Fischer <mdf@kernel.org>
    Signed-off-by: Moritz Fischer <mdf@kernel.org>

diff --git a/drivers/fpga/dfl-fme-main.c b/drivers/fpga/dfl-fme-main.c
index f033f1cfd3ed..bf8114d4d875 100644
--- a/drivers/fpga/dfl-fme-main.c
+++ b/drivers/fpga/dfl-fme-main.c
@@ -129,30 +129,6 @@ static struct attribute *fme_hdr_attrs[] = {
 };
 ATTRIBUTE_GROUPS(fme_hdr);
 
-static int fme_hdr_init(struct platform_device *pdev,
-			struct dfl_feature *feature)
-{
-	void __iomem *base = feature->ioaddr;
-	int ret;
-
-	dev_dbg(&pdev->dev, "FME HDR Init.\n");
-	dev_dbg(&pdev->dev, "FME cap %llx.\n",
-		(unsigned long long)readq(base + FME_HDR_CAP));
-
-	ret = device_add_groups(&pdev->dev, fme_hdr_groups);
-	if (ret)
-		return ret;
-
-	return 0;
-}
-
-static void fme_hdr_uinit(struct platform_device *pdev,
-			  struct dfl_feature *feature)
-{
-	dev_dbg(&pdev->dev, "FME HDR UInit.\n");
-	device_remove_groups(&pdev->dev, fme_hdr_groups);
-}
-
 static long fme_hdr_ioctl_release_port(struct dfl_feature_platform_data *pdata,
 				       unsigned long arg)
 {
@@ -199,8 +175,6 @@ static const struct dfl_feature_id fme_hdr_id_table[] = {
 };
 
 static const struct dfl_feature_ops fme_hdr_ops = {
-	.init = fme_hdr_init,
-	.uinit = fme_hdr_uinit,
 	.ioctl = fme_hdr_ioctl,
 };
 
@@ -361,7 +335,8 @@ static int fme_remove(struct platform_device *pdev)
 
 static struct platform_driver fme_driver = {
 	.driver	= {
-		.name    = DFL_FPGA_FEATURE_DEV_FME,
+		.name       = DFL_FPGA_FEATURE_DEV_FME,
+		.dev_groups = fme_hdr_groups,
 	},
 	.probe   = fme_probe,
 	.remove  = fme_remove,

commit 52eb6d31a1c2e85a3eaf08ab599c9ad58c890c28
Author: Wu Hao <hao.wu@intel.com>
Date:   Sun Aug 4 18:20:20 2019 +0800

    fpga: dfl: fme: add capability sysfs interfaces
    
    This patch adds 3 read-only sysfs interfaces for FPGA Management Engine
    (FME) block for capabilities including cache_size, fabric_version and
    socket_id.
    
    Signed-off-by: Luwei Kang <luwei.kang@intel.com>
    Signed-off-by: Xu Yilun <yilun.xu@intel.com>
    Signed-off-by: Wu Hao <hao.wu@intel.com>
    Acked-by: Alan Tull <atull@kernel.org>
    Signed-off-by: Moritz Fischer <mdf@kernel.org>
    Link: https://lore.kernel.org/r/1564914022-3710-11-git-send-email-hao.wu@intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/fpga/dfl-fme-main.c b/drivers/fpga/dfl-fme-main.c
index 5fdce548f821..f033f1cfd3ed 100644
--- a/drivers/fpga/dfl-fme-main.c
+++ b/drivers/fpga/dfl-fme-main.c
@@ -73,10 +73,58 @@ static ssize_t bitstream_metadata_show(struct device *dev,
 }
 static DEVICE_ATTR_RO(bitstream_metadata);
 
+static ssize_t cache_size_show(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	void __iomem *base;
+	u64 v;
+
+	base = dfl_get_feature_ioaddr_by_id(dev, FME_FEATURE_ID_HEADER);
+
+	v = readq(base + FME_HDR_CAP);
+
+	return sprintf(buf, "%u\n",
+		       (unsigned int)FIELD_GET(FME_CAP_CACHE_SIZE, v));
+}
+static DEVICE_ATTR_RO(cache_size);
+
+static ssize_t fabric_version_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	void __iomem *base;
+	u64 v;
+
+	base = dfl_get_feature_ioaddr_by_id(dev, FME_FEATURE_ID_HEADER);
+
+	v = readq(base + FME_HDR_CAP);
+
+	return sprintf(buf, "%u\n",
+		       (unsigned int)FIELD_GET(FME_CAP_FABRIC_VERID, v));
+}
+static DEVICE_ATTR_RO(fabric_version);
+
+static ssize_t socket_id_show(struct device *dev,
+			      struct device_attribute *attr, char *buf)
+{
+	void __iomem *base;
+	u64 v;
+
+	base = dfl_get_feature_ioaddr_by_id(dev, FME_FEATURE_ID_HEADER);
+
+	v = readq(base + FME_HDR_CAP);
+
+	return sprintf(buf, "%u\n",
+		       (unsigned int)FIELD_GET(FME_CAP_SOCKET_ID, v));
+}
+static DEVICE_ATTR_RO(socket_id);
+
 static struct attribute *fme_hdr_attrs[] = {
 	&dev_attr_ports_num.attr,
 	&dev_attr_bitstream_id.attr,
 	&dev_attr_bitstream_metadata.attr,
+	&dev_attr_cache_size.attr,
+	&dev_attr_fabric_version.attr,
+	&dev_attr_socket_id.attr,
 	NULL,
 };
 ATTRIBUTE_GROUPS(fme_hdr);

commit 15bbb300fcef4e62e4f6063cc29e698796027b98
Author: Wu Hao <hao.wu@intel.com>
Date:   Sun Aug 4 18:20:15 2019 +0800

    fpga: dfl: add id_table for dfl private feature driver
    
    This patch adds id_table for each dfl private feature driver,
    it allows to reuse same private feature driver to match and support
    multiple dfl private features.
    
    Signed-off-by: Xu Yilun <yilun.xu@intel.com>
    Signed-off-by: Wu Hao <hao.wu@intel.com>
    Acked-by: Moritz Fischer <mdf@kernel.org>
    Acked-by: Alan Tull <atull@kernel.org>
    Signed-off-by: Moritz Fischer <mdf@kernel.org>
    Link: https://lore.kernel.org/r/1564914022-3710-6-git-send-email-hao.wu@intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/fpga/dfl-fme-main.c b/drivers/fpga/dfl-fme-main.c
index dfea2dee78c3..5fdce548f821 100644
--- a/drivers/fpga/dfl-fme-main.c
+++ b/drivers/fpga/dfl-fme-main.c
@@ -145,6 +145,11 @@ static long fme_hdr_ioctl(struct platform_device *pdev,
 	return -ENODEV;
 }
 
+static const struct dfl_feature_id fme_hdr_id_table[] = {
+	{.id = FME_FEATURE_ID_HEADER,},
+	{0,}
+};
+
 static const struct dfl_feature_ops fme_hdr_ops = {
 	.init = fme_hdr_init,
 	.uinit = fme_hdr_uinit,
@@ -153,12 +158,12 @@ static const struct dfl_feature_ops fme_hdr_ops = {
 
 static struct dfl_feature_driver fme_feature_drvs[] = {
 	{
-		.id = FME_FEATURE_ID_HEADER,
+		.id_table = fme_hdr_id_table,
 		.ops = &fme_hdr_ops,
 	},
 	{
-		.id = FME_FEATURE_ID_PR_MGMT,
-		.ops = &pr_mgmt_ops,
+		.id_table = fme_pr_mgmt_id_table,
+		.ops = &fme_pr_mgmt_ops,
 	},
 	{
 		.ops = NULL,

commit 69bb18ddfc4331ba1dea9db811caf93e95726408
Author: Wu Hao <hao.wu@intel.com>
Date:   Sun Aug 4 18:20:11 2019 +0800

    fpga: dfl: fme: add DFL_FPGA_FME_PORT_RELEASE/ASSIGN ioctl support.
    
    In order to support virtualization usage via PCIe SRIOV, this patch
    adds two ioctls under FPGA Management Engine (FME) to release and
    assign back the port device. In order to safely turn Port from PF
    into VF and enable PCIe SRIOV, it requires user to invoke this
    PORT_RELEASE ioctl to release port firstly to remove userspace
    interfaces, and then configure the PF/VF access register in FME.
    After disable SRIOV, it requires user to invoke this PORT_ASSIGN
    ioctl to attach the port back to PF.
    
     Ioctl interfaces:
     * DFL_FPGA_FME_PORT_RELEASE
       Release platform device of given port, it deletes port platform
       device to remove related userspace interfaces on PF. After this
       function, then it's safe to configure PF/VF access mode to VF,
       and enable VFs via SRIOV.
    
     * DFL_FPGA_FME_PORT_ASSIGN
       Assign platform device of given port back to PF. After configure
       PF/VF access mode to PF, this ioctl adds port platform device
       back to re-enable related userspace interfaces on PF.
    
    Signed-off-by: Zhang Yi Z <yi.z.zhang@intel.com>
    Signed-off-by: Xu Yilun <yilun.xu@intel.com>
    Signed-off-by: Wu Hao <hao.wu@intel.com>
    Acked-by: Alan Tull <atull@kernel.org>
    Acked-by: Moritz Fischer <mdf@kernel.org>
    Signed-off-by: Moritz Fischer <mdf@kernel.org>
    Link: https://lore.kernel.org/r/1564914022-3710-2-git-send-email-hao.wu@intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/fpga/dfl-fme-main.c b/drivers/fpga/dfl-fme-main.c
index 0be4635583d5..dfea2dee78c3 100644
--- a/drivers/fpga/dfl-fme-main.c
+++ b/drivers/fpga/dfl-fme-main.c
@@ -16,6 +16,7 @@
 
 #include <linux/kernel.h>
 #include <linux/module.h>
+#include <linux/uaccess.h>
 #include <linux/fpga-dfl.h>
 
 #include "dfl.h"
@@ -104,9 +105,50 @@ static void fme_hdr_uinit(struct platform_device *pdev,
 	device_remove_groups(&pdev->dev, fme_hdr_groups);
 }
 
+static long fme_hdr_ioctl_release_port(struct dfl_feature_platform_data *pdata,
+				       unsigned long arg)
+{
+	struct dfl_fpga_cdev *cdev = pdata->dfl_cdev;
+	int port_id;
+
+	if (get_user(port_id, (int __user *)arg))
+		return -EFAULT;
+
+	return dfl_fpga_cdev_release_port(cdev, port_id);
+}
+
+static long fme_hdr_ioctl_assign_port(struct dfl_feature_platform_data *pdata,
+				      unsigned long arg)
+{
+	struct dfl_fpga_cdev *cdev = pdata->dfl_cdev;
+	int port_id;
+
+	if (get_user(port_id, (int __user *)arg))
+		return -EFAULT;
+
+	return dfl_fpga_cdev_assign_port(cdev, port_id);
+}
+
+static long fme_hdr_ioctl(struct platform_device *pdev,
+			  struct dfl_feature *feature,
+			  unsigned int cmd, unsigned long arg)
+{
+	struct dfl_feature_platform_data *pdata = dev_get_platdata(&pdev->dev);
+
+	switch (cmd) {
+	case DFL_FPGA_FME_PORT_RELEASE:
+		return fme_hdr_ioctl_release_port(pdata, arg);
+	case DFL_FPGA_FME_PORT_ASSIGN:
+		return fme_hdr_ioctl_assign_port(pdata, arg);
+	}
+
+	return -ENODEV;
+}
+
 static const struct dfl_feature_ops fme_hdr_ops = {
 	.init = fme_hdr_init,
 	.uinit = fme_hdr_uinit,
+	.ioctl = fme_hdr_ioctl,
 };
 
 static struct dfl_feature_driver fme_feature_drvs[] = {

commit dcfecd4d7a551906595351a26e1db91774b8563d
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Jul 4 07:56:45 2019 +0200

    fpga: dfl: use driver core functions, not sysfs ones.
    
    This is a driver, do not call "raw" sysfs functions, instead call driver
    core ones.  Specifically convert the use of sysfs_create_files() and
    sysfs_remove_files() to use device_add_groups() and
    device_remove_groups()
    
    Cc: Wu Hao <hao.wu@intel.com>
    Cc: Alan Tull <atull@kernel.org>
    Cc: Moritz Fischer <mdf@kernel.org>
    Cc: linux-fpga@vger.kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Link: https://lore.kernel.org/r/20190704055645.GA15471@kroah.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/fpga/dfl-fme-main.c b/drivers/fpga/dfl-fme-main.c
index 086ad2420ade..0be4635583d5 100644
--- a/drivers/fpga/dfl-fme-main.c
+++ b/drivers/fpga/dfl-fme-main.c
@@ -72,12 +72,13 @@ static ssize_t bitstream_metadata_show(struct device *dev,
 }
 static DEVICE_ATTR_RO(bitstream_metadata);
 
-static const struct attribute *fme_hdr_attrs[] = {
+static struct attribute *fme_hdr_attrs[] = {
 	&dev_attr_ports_num.attr,
 	&dev_attr_bitstream_id.attr,
 	&dev_attr_bitstream_metadata.attr,
 	NULL,
 };
+ATTRIBUTE_GROUPS(fme_hdr);
 
 static int fme_hdr_init(struct platform_device *pdev,
 			struct dfl_feature *feature)
@@ -89,7 +90,7 @@ static int fme_hdr_init(struct platform_device *pdev,
 	dev_dbg(&pdev->dev, "FME cap %llx.\n",
 		(unsigned long long)readq(base + FME_HDR_CAP));
 
-	ret = sysfs_create_files(&pdev->dev.kobj, fme_hdr_attrs);
+	ret = device_add_groups(&pdev->dev, fme_hdr_groups);
 	if (ret)
 		return ret;
 
@@ -100,7 +101,7 @@ static void fme_hdr_uinit(struct platform_device *pdev,
 			  struct dfl_feature *feature)
 {
 	dev_dbg(&pdev->dev, "FME HDR UInit.\n");
-	sysfs_remove_files(&pdev->dev.kobj, fme_hdr_attrs);
+	device_remove_groups(&pdev->dev, fme_hdr_groups);
 }
 
 static const struct dfl_feature_ops fme_hdr_ops = {

commit 29de76240e861d52b75405166337e94184f1875d
Author: Kang Luwei <luwei.kang@intel.com>
Date:   Sat Jun 30 08:53:24 2018 +0800

    fpga: dfl: fme: add partial reconfiguration sub feature support
    
    Partial Reconfiguration (PR) is the most important function for FME. It
    allows reconfiguration for given Port/Accelerated Function Unit (AFU).
    
    It creates platform devices for fpga-mgr, fpga-regions and fpga-bridges,
    and invokes fpga-region's interface (fpga_region_program_fpga) for PR
    operation once PR request received via ioctl. Below user space interface
    is exposed by this sub feature.
    
    Ioctl interface:
    * DFL_FPGA_FME_PORT_PR
      Do partial reconfiguration per information from userspace, including
      target port(AFU), buffer size and address info. It returns error code
      to userspace if failed. For detailed PR error information, user needs
      to read fpga-mgr's status sysfs interface.
    
    Signed-off-by: Tim Whisonant <tim.whisonant@intel.com>
    Signed-off-by: Enno Luebbers <enno.luebbers@intel.com>
    Signed-off-by: Shiva Rao <shiva.rao@intel.com>
    Signed-off-by: Christopher Rauer <christopher.rauer@intel.com>
    Signed-off-by: Kang Luwei <luwei.kang@intel.com>
    Signed-off-by: Xiao Guangrong <guangrong.xiao@linux.intel.com>
    Signed-off-by: Wu Hao <hao.wu@intel.com>
    Acked-by: Alan Tull <atull@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/fpga/dfl-fme-main.c b/drivers/fpga/dfl-fme-main.c
index c83ff88e3bbb..086ad2420ade 100644
--- a/drivers/fpga/dfl-fme-main.c
+++ b/drivers/fpga/dfl-fme-main.c
@@ -19,6 +19,7 @@
 #include <linux/fpga-dfl.h>
 
 #include "dfl.h"
+#include "dfl-fme.h"
 
 static ssize_t ports_num_show(struct device *dev,
 			      struct device_attribute *attr, char *buf)
@@ -112,6 +113,10 @@ static struct dfl_feature_driver fme_feature_drvs[] = {
 		.id = FME_FEATURE_ID_HEADER,
 		.ops = &fme_hdr_ops,
 	},
+	{
+		.id = FME_FEATURE_ID_PR_MGMT,
+		.ops = &pr_mgmt_ops,
+	},
 	{
 		.ops = NULL,
 	},
@@ -187,6 +192,35 @@ static long fme_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 	return -EINVAL;
 }
 
+static int fme_dev_init(struct platform_device *pdev)
+{
+	struct dfl_feature_platform_data *pdata = dev_get_platdata(&pdev->dev);
+	struct dfl_fme *fme;
+
+	fme = devm_kzalloc(&pdev->dev, sizeof(*fme), GFP_KERNEL);
+	if (!fme)
+		return -ENOMEM;
+
+	fme->pdata = pdata;
+
+	mutex_lock(&pdata->lock);
+	dfl_fpga_pdata_set_private(pdata, fme);
+	mutex_unlock(&pdata->lock);
+
+	return 0;
+}
+
+static void fme_dev_destroy(struct platform_device *pdev)
+{
+	struct dfl_feature_platform_data *pdata = dev_get_platdata(&pdev->dev);
+	struct dfl_fme *fme;
+
+	mutex_lock(&pdata->lock);
+	fme = dfl_fpga_pdata_get_private(pdata);
+	dfl_fpga_pdata_set_private(pdata, NULL);
+	mutex_unlock(&pdata->lock);
+}
+
 static const struct file_operations fme_fops = {
 	.owner		= THIS_MODULE,
 	.open		= fme_open,
@@ -198,10 +232,14 @@ static int fme_probe(struct platform_device *pdev)
 {
 	int ret;
 
-	ret = dfl_fpga_dev_feature_init(pdev, fme_feature_drvs);
+	ret = fme_dev_init(pdev);
 	if (ret)
 		goto exit;
 
+	ret = dfl_fpga_dev_feature_init(pdev, fme_feature_drvs);
+	if (ret)
+		goto dev_destroy;
+
 	ret = dfl_fpga_dev_ops_register(pdev, &fme_fops, THIS_MODULE);
 	if (ret)
 		goto feature_uinit;
@@ -210,6 +248,8 @@ static int fme_probe(struct platform_device *pdev)
 
 feature_uinit:
 	dfl_fpga_dev_feature_uinit(pdev);
+dev_destroy:
+	fme_dev_destroy(pdev);
 exit:
 	return ret;
 }
@@ -218,6 +258,7 @@ static int fme_remove(struct platform_device *pdev)
 {
 	dfl_fpga_dev_ops_unregister(pdev);
 	dfl_fpga_dev_feature_uinit(pdev);
+	fme_dev_destroy(pdev);
 
 	return 0;
 }

commit 620e1902f6fe57ddacdabd9e33fadbd290be9652
Author: Wu Hao <hao.wu@intel.com>
Date:   Sat Jun 30 08:53:23 2018 +0800

    fpga: dfl: fme: add DFL_FPGA_GET_API_VERSION/CHECK_EXTENSION ioctls support
    
    DFL_FPGA_GET_API_VERSION and DFL_FPGA_CHECK_EXTENSION ioctls are common
    ones which need to be supported by all feature devices drivers including
    FME and AFU. Userspace application can use these ioctl interfaces to get
    the API info and check if specific extension is supported or not in
    current driver.
    
    This patch implements above 2 ioctls in FPGA Management Engine (FME)
    driver.
    
    Signed-off-by: Tim Whisonant <tim.whisonant@intel.com>
    Signed-off-by: Enno Luebbers <enno.luebbers@intel.com>
    Signed-off-by: Shiva Rao <shiva.rao@intel.com>
    Signed-off-by: Christopher Rauer <christopher.rauer@intel.com>
    Signed-off-by: Xiao Guangrong <guangrong.xiao@linux.intel.com>
    Signed-off-by: Wu Hao <hao.wu@intel.com>
    Acked-by: Alan Tull <atull@kernel.org>
    Acked-by: Moritz Fischer <mdf@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/fpga/dfl-fme-main.c b/drivers/fpga/dfl-fme-main.c
index c23c56fe3f4b..c83ff88e3bbb 100644
--- a/drivers/fpga/dfl-fme-main.c
+++ b/drivers/fpga/dfl-fme-main.c
@@ -16,6 +16,7 @@
 
 #include <linux/kernel.h>
 #include <linux/module.h>
+#include <linux/fpga-dfl.h>
 
 #include "dfl.h"
 
@@ -116,6 +117,13 @@ static struct dfl_feature_driver fme_feature_drvs[] = {
 	},
 };
 
+static long fme_ioctl_check_extension(struct dfl_feature_platform_data *pdata,
+				      unsigned long arg)
+{
+	/* No extension support for now */
+	return 0;
+}
+
 static int fme_open(struct inode *inode, struct file *filp)
 {
 	struct platform_device *fdev = dfl_fpga_inode_to_feature_dev(inode);
@@ -156,6 +164,10 @@ static long fme_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 	dev_dbg(&pdev->dev, "%s cmd 0x%x\n", __func__, cmd);
 
 	switch (cmd) {
+	case DFL_FPGA_GET_API_VERSION:
+		return DFL_FPGA_API_VERSION;
+	case DFL_FPGA_CHECK_EXTENSION:
+		return fme_ioctl_check_extension(pdata, arg);
 	default:
 		/*
 		 * Let sub-feature's ioctl function to handle the cmd.

commit 0a27ff24d59662b1ca8b3f7721a965918f115074
Author: Kang Luwei <luwei.kang@intel.com>
Date:   Sat Jun 30 08:53:22 2018 +0800

    fpga: dfl: fme: add header sub feature support
    
    The Header Register set is always present for FPGA Management Engine (FME),
    this patch implements init and uinit function for header sub feature and
    introduces several read-only sysfs interfaces for the capability and
    status.
    
    Sysfs interfaces:
    * /sys/class/fpga_region/<regionX>/<dfl-fme.x>/ports_num
      Read-only. Number of ports implemented
    
    * /sys/class/fpga_region/<regionX>/<dfl-fme.x>/bitstream_id
      Read-only. Bitstream (static FPGA region) identifier number. It contains
      the detailed version and other information of this static FPGA region.
    
    * /sys/class/fpga_region/<regionX>/<dfl-fme.x>/bitstream_metadata
      Read-only. Bitstream (static FPGA region) meta data. It contains the
      synthesis date, seed and other information of this static FPGA region.
    
    Signed-off-by: Tim Whisonant <tim.whisonant@intel.com>
    Signed-off-by: Enno Luebbers <enno.luebbers@intel.com>
    Signed-off-by: Shiva Rao <shiva.rao@intel.com>
    Signed-off-by: Christopher Rauer <christopher.rauer@intel.com>
    Signed-off-by: Kang Luwei <luwei.kang@intel.com>
    Signed-off-by: Xiao Guangrong <guangrong.xiao@linux.intel.com>
    Signed-off-by: Wu Hao <hao.wu@intel.com>
    Acked-by: Alan Tull <atull@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/fpga/dfl-fme-main.c b/drivers/fpga/dfl-fme-main.c
index bdcfe951d939..c23c56fe3f4b 100644
--- a/drivers/fpga/dfl-fme-main.c
+++ b/drivers/fpga/dfl-fme-main.c
@@ -19,10 +19,77 @@
 
 #include "dfl.h"
 
+static ssize_t ports_num_show(struct device *dev,
+			      struct device_attribute *attr, char *buf)
+{
+	void __iomem *base;
+	u64 v;
+
+	base = dfl_get_feature_ioaddr_by_id(dev, FME_FEATURE_ID_HEADER);
+
+	v = readq(base + FME_HDR_CAP);
+
+	return scnprintf(buf, PAGE_SIZE, "%u\n",
+			 (unsigned int)FIELD_GET(FME_CAP_NUM_PORTS, v));
+}
+static DEVICE_ATTR_RO(ports_num);
+
+/*
+ * Bitstream (static FPGA region) identifier number. It contains the
+ * detailed version and other information of this static FPGA region.
+ */
+static ssize_t bitstream_id_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	void __iomem *base;
+	u64 v;
+
+	base = dfl_get_feature_ioaddr_by_id(dev, FME_FEATURE_ID_HEADER);
+
+	v = readq(base + FME_HDR_BITSTREAM_ID);
+
+	return scnprintf(buf, PAGE_SIZE, "0x%llx\n", (unsigned long long)v);
+}
+static DEVICE_ATTR_RO(bitstream_id);
+
+/*
+ * Bitstream (static FPGA region) meta data. It contains the synthesis
+ * date, seed and other information of this static FPGA region.
+ */
+static ssize_t bitstream_metadata_show(struct device *dev,
+				       struct device_attribute *attr, char *buf)
+{
+	void __iomem *base;
+	u64 v;
+
+	base = dfl_get_feature_ioaddr_by_id(dev, FME_FEATURE_ID_HEADER);
+
+	v = readq(base + FME_HDR_BITSTREAM_MD);
+
+	return scnprintf(buf, PAGE_SIZE, "0x%llx\n", (unsigned long long)v);
+}
+static DEVICE_ATTR_RO(bitstream_metadata);
+
+static const struct attribute *fme_hdr_attrs[] = {
+	&dev_attr_ports_num.attr,
+	&dev_attr_bitstream_id.attr,
+	&dev_attr_bitstream_metadata.attr,
+	NULL,
+};
+
 static int fme_hdr_init(struct platform_device *pdev,
 			struct dfl_feature *feature)
 {
+	void __iomem *base = feature->ioaddr;
+	int ret;
+
 	dev_dbg(&pdev->dev, "FME HDR Init.\n");
+	dev_dbg(&pdev->dev, "FME cap %llx.\n",
+		(unsigned long long)readq(base + FME_HDR_CAP));
+
+	ret = sysfs_create_files(&pdev->dev.kobj, fme_hdr_attrs);
+	if (ret)
+		return ret;
 
 	return 0;
 }
@@ -31,6 +98,7 @@ static void fme_hdr_uinit(struct platform_device *pdev,
 			  struct dfl_feature *feature)
 {
 	dev_dbg(&pdev->dev, "FME HDR UInit.\n");
+	sysfs_remove_files(&pdev->dev.kobj, fme_hdr_attrs);
 }
 
 static const struct dfl_feature_ops fme_hdr_ops = {

commit 322ddebe54ae2b18c86a3bffb2b76bc5e67762ac
Author: Kang Luwei <luwei.kang@intel.com>
Date:   Sat Jun 30 08:53:21 2018 +0800

    fpga: dfl: add FPGA Management Engine driver basic framework
    
    The FPGA Management Engine (FME) provides power, thermal management,
    performance counters, partial reconfiguration and other functions. For each
    function, it is packaged into a private feature linked to the FME feature
    device in the 'Device Feature List'. It's a platform device created by
    DFL framework.
    
    This patch adds the basic framework of FME platform driver. It defines
    sub feature drivers to handle the different sub features, including init,
    uinit and ioctl. It also registers the file operations for the device file.
    
    Signed-off-by: Tim Whisonant <tim.whisonant@intel.com>
    Signed-off-by: Enno Luebbers <enno.luebbers@intel.com>
    Signed-off-by: Shiva Rao <shiva.rao@intel.com>
    Signed-off-by: Christopher Rauer <christopher.rauer@intel.com>
    Signed-off-by: Kang Luwei <luwei.kang@intel.com>
    Signed-off-by: Xiao Guangrong <guangrong.xiao@linux.intel.com>
    Signed-off-by: Wu Hao <hao.wu@intel.com>
    Acked-by: Alan Tull <atull@kernel.org>
    Acked-by: Moritz Fischer <mdf@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/fpga/dfl-fme-main.c b/drivers/fpga/dfl-fme-main.c
new file mode 100644
index 000000000000..bdcfe951d939
--- /dev/null
+++ b/drivers/fpga/dfl-fme-main.c
@@ -0,0 +1,158 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Driver for FPGA Management Engine (FME)
+ *
+ * Copyright (C) 2017-2018 Intel Corporation, Inc.
+ *
+ * Authors:
+ *   Kang Luwei <luwei.kang@intel.com>
+ *   Xiao Guangrong <guangrong.xiao@linux.intel.com>
+ *   Joseph Grecco <joe.grecco@intel.com>
+ *   Enno Luebbers <enno.luebbers@intel.com>
+ *   Tim Whisonant <tim.whisonant@intel.com>
+ *   Ananda Ravuri <ananda.ravuri@intel.com>
+ *   Henry Mitchel <henry.mitchel@intel.com>
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+
+#include "dfl.h"
+
+static int fme_hdr_init(struct platform_device *pdev,
+			struct dfl_feature *feature)
+{
+	dev_dbg(&pdev->dev, "FME HDR Init.\n");
+
+	return 0;
+}
+
+static void fme_hdr_uinit(struct platform_device *pdev,
+			  struct dfl_feature *feature)
+{
+	dev_dbg(&pdev->dev, "FME HDR UInit.\n");
+}
+
+static const struct dfl_feature_ops fme_hdr_ops = {
+	.init = fme_hdr_init,
+	.uinit = fme_hdr_uinit,
+};
+
+static struct dfl_feature_driver fme_feature_drvs[] = {
+	{
+		.id = FME_FEATURE_ID_HEADER,
+		.ops = &fme_hdr_ops,
+	},
+	{
+		.ops = NULL,
+	},
+};
+
+static int fme_open(struct inode *inode, struct file *filp)
+{
+	struct platform_device *fdev = dfl_fpga_inode_to_feature_dev(inode);
+	struct dfl_feature_platform_data *pdata = dev_get_platdata(&fdev->dev);
+	int ret;
+
+	if (WARN_ON(!pdata))
+		return -ENODEV;
+
+	ret = dfl_feature_dev_use_begin(pdata);
+	if (ret)
+		return ret;
+
+	dev_dbg(&fdev->dev, "Device File Open\n");
+	filp->private_data = pdata;
+
+	return 0;
+}
+
+static int fme_release(struct inode *inode, struct file *filp)
+{
+	struct dfl_feature_platform_data *pdata = filp->private_data;
+	struct platform_device *pdev = pdata->dev;
+
+	dev_dbg(&pdev->dev, "Device File Release\n");
+	dfl_feature_dev_use_end(pdata);
+
+	return 0;
+}
+
+static long fme_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	struct dfl_feature_platform_data *pdata = filp->private_data;
+	struct platform_device *pdev = pdata->dev;
+	struct dfl_feature *f;
+	long ret;
+
+	dev_dbg(&pdev->dev, "%s cmd 0x%x\n", __func__, cmd);
+
+	switch (cmd) {
+	default:
+		/*
+		 * Let sub-feature's ioctl function to handle the cmd.
+		 * Sub-feature's ioctl returns -ENODEV when cmd is not
+		 * handled in this sub feature, and returns 0 or other
+		 * error code if cmd is handled.
+		 */
+		dfl_fpga_dev_for_each_feature(pdata, f) {
+			if (f->ops && f->ops->ioctl) {
+				ret = f->ops->ioctl(pdev, f, cmd, arg);
+				if (ret != -ENODEV)
+					return ret;
+			}
+		}
+	}
+
+	return -EINVAL;
+}
+
+static const struct file_operations fme_fops = {
+	.owner		= THIS_MODULE,
+	.open		= fme_open,
+	.release	= fme_release,
+	.unlocked_ioctl = fme_ioctl,
+};
+
+static int fme_probe(struct platform_device *pdev)
+{
+	int ret;
+
+	ret = dfl_fpga_dev_feature_init(pdev, fme_feature_drvs);
+	if (ret)
+		goto exit;
+
+	ret = dfl_fpga_dev_ops_register(pdev, &fme_fops, THIS_MODULE);
+	if (ret)
+		goto feature_uinit;
+
+	return 0;
+
+feature_uinit:
+	dfl_fpga_dev_feature_uinit(pdev);
+exit:
+	return ret;
+}
+
+static int fme_remove(struct platform_device *pdev)
+{
+	dfl_fpga_dev_ops_unregister(pdev);
+	dfl_fpga_dev_feature_uinit(pdev);
+
+	return 0;
+}
+
+static struct platform_driver fme_driver = {
+	.driver	= {
+		.name    = DFL_FPGA_FEATURE_DEV_FME,
+	},
+	.probe   = fme_probe,
+	.remove  = fme_remove,
+};
+
+module_platform_driver(fme_driver);
+
+MODULE_DESCRIPTION("FPGA Management Engine driver");
+MODULE_AUTHOR("Intel Corporation");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:dfl-fme");
