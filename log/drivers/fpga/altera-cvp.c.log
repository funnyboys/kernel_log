commit e58915179f3f4a839ea3b9aeae1c1e13e98e33b1
Author: Thor Thayer <thor.thayer@linux.intel.com>
Date:   Mon Aug 19 15:48:08 2019 -0500

    fpga: altera-cvp: Add Stratix10 (V2) Support
    
    Add Stratix10 specific functions that use a credit mechanism
    to throttle data to the CvP FIFOs. Add a private structure
    with function pointers for V1 vs V2 functions.
    
    Signed-off-by: Thor Thayer <thor.thayer@linux.intel.com>
    Signed-off-by: Moritz Fischer <mdf@kernel.org>

diff --git a/drivers/fpga/altera-cvp.c b/drivers/fpga/altera-cvp.c
index 3b8386fd32e7..4e0edb60bfba 100644
--- a/drivers/fpga/altera-cvp.c
+++ b/drivers/fpga/altera-cvp.c
@@ -43,16 +43,34 @@
 #define VSE_CVP_PROG_CTRL		0x2c	/* 32bit */
 #define VSE_CVP_PROG_CTRL_CONFIG	BIT(0)
 #define VSE_CVP_PROG_CTRL_START_XFER	BIT(1)
+#define VSE_CVP_PROG_CTRL_MASK		GENMASK(1, 0)
 
 #define VSE_UNCOR_ERR_STATUS		0x34	/* 32bit */
 #define VSE_UNCOR_ERR_CVP_CFG_ERR	BIT(5)	/* CVP_CONFIG_ERROR_LATCHED */
 
+#define V1_VSEC_OFFSET			0x200	/* Vendor Specific Offset V1 */
+/* V2 Defines */
+#define VSE_CVP_TX_CREDITS		0x49	/* 8bit */
+
+#define V2_CREDIT_TIMEOUT_US		20000
+#define V2_CHECK_CREDIT_US		10
+#define V2_POLL_TIMEOUT_US		1000000
+#define V2_USER_TIMEOUT_US		500000
+
+#define V1_POLL_TIMEOUT_US		10
+
 #define DRV_NAME		"altera-cvp"
 #define ALTERA_CVP_MGR_NAME	"Altera CvP FPGA Manager"
 
+/* Write block sizes */
+#define ALTERA_CVP_V1_SIZE	4
+#define ALTERA_CVP_V2_SIZE	4096
+
 /* Optional CvP config error status check for debugging */
 static bool altera_cvp_chkcfg;
 
+struct cvp_priv;
+
 struct altera_cvp_conf {
 	struct fpga_manager	*mgr;
 	struct pci_dev		*pci_dev;
@@ -61,9 +79,27 @@ struct altera_cvp_conf {
 					      u32 data);
 	char			mgr_name[64];
 	u8			numclks;
+	u32			sent_packets;
 	u32			vsec_offset;
+	const struct cvp_priv	*priv;
 };
 
+struct cvp_priv {
+	void	(*switch_clk)(struct altera_cvp_conf *conf);
+	int	(*clear_state)(struct altera_cvp_conf *conf);
+	int	(*wait_credit)(struct fpga_manager *mgr, u32 blocks);
+	size_t	block_size;
+	int	poll_time_us;
+	int	user_time_us;
+};
+
+static int altera_read_config_byte(struct altera_cvp_conf *conf,
+				   int where, u8 *val)
+{
+	return pci_read_config_byte(conf->pci_dev, conf->vsec_offset + where,
+				    val);
+}
+
 static int altera_read_config_dword(struct altera_cvp_conf *conf,
 				    int where, u32 *val)
 {
@@ -159,6 +195,73 @@ static int altera_cvp_chk_error(struct fpga_manager *mgr, size_t bytes)
 	return 0;
 }
 
+/*
+ * CvP Version2 Functions
+ * Recent Intel FPGAs use a credit mechanism to throttle incoming
+ * bitstreams and a different method of clearing the state.
+ */
+
+static int altera_cvp_v2_clear_state(struct altera_cvp_conf *conf)
+{
+	u32 val;
+	int ret;
+
+	/* Clear the START_XFER and CVP_CONFIG bits */
+	ret = altera_read_config_dword(conf, VSE_CVP_PROG_CTRL, &val);
+	if (ret) {
+		dev_err(&conf->pci_dev->dev,
+			"Error reading CVP Program Control Register\n");
+		return ret;
+	}
+
+	val &= ~VSE_CVP_PROG_CTRL_MASK;
+	ret = altera_write_config_dword(conf, VSE_CVP_PROG_CTRL, val);
+	if (ret) {
+		dev_err(&conf->pci_dev->dev,
+			"Error writing CVP Program Control Register\n");
+		return ret;
+	}
+
+	return altera_cvp_wait_status(conf, VSE_CVP_STATUS_CFG_RDY, 0,
+				      conf->priv->poll_time_us);
+}
+
+static int altera_cvp_v2_wait_for_credit(struct fpga_manager *mgr,
+					 u32 blocks)
+{
+	u32 timeout = V2_CREDIT_TIMEOUT_US / V2_CHECK_CREDIT_US;
+	struct altera_cvp_conf *conf = mgr->priv;
+	int ret;
+	u8 val;
+
+	do {
+		ret = altera_read_config_byte(conf, VSE_CVP_TX_CREDITS, &val);
+		if (ret) {
+			dev_err(&conf->pci_dev->dev,
+				"Error reading CVP Credit Register\n");
+			return ret;
+		}
+
+		/* Return if there is space in FIFO */
+		if (val - (u8)conf->sent_packets)
+			return 0;
+
+		ret = altera_cvp_chk_error(mgr, blocks * ALTERA_CVP_V2_SIZE);
+		if (ret) {
+			dev_err(&conf->pci_dev->dev,
+				"CE Bit error credit reg[0x%x]:sent[0x%x]\n",
+				val, conf->sent_packets);
+			return -EAGAIN;
+		}
+
+		/* Limit the check credit byte traffic */
+		usleep_range(V2_CHECK_CREDIT_US, V2_CHECK_CREDIT_US + 1);
+	} while (timeout--);
+
+	dev_err(&conf->pci_dev->dev, "Timeout waiting for credit\n");
+	return -ETIMEDOUT;
+}
+
 static int altera_cvp_send_block(struct altera_cvp_conf *conf,
 				 const u32 *data, size_t len)
 {
@@ -200,10 +303,12 @@ static int altera_cvp_teardown(struct fpga_manager *mgr,
 	 * - set CVP_NUMCLKS to 1 and then issue CVP_DUMMY_WR dummy
 	 *   writes to the HIP
 	 */
-	altera_cvp_dummy_write(conf); /* from CVP clock to internal clock */
+	if (conf->priv->switch_clk)
+		conf->priv->switch_clk(conf);
 
 	/* STEP 15 - poll CVP_CONFIG_READY bit for 0 with 10us timeout */
-	ret = altera_cvp_wait_status(conf, VSE_CVP_STATUS_CFG_RDY, 0, 10);
+	ret = altera_cvp_wait_status(conf, VSE_CVP_STATUS_CFG_RDY, 0,
+				     conf->priv->poll_time_us);
 	if (ret)
 		dev_err(&mgr->dev, "CFG_RDY == 0 timeout\n");
 
@@ -265,7 +370,18 @@ static int altera_cvp_write_init(struct fpga_manager *mgr,
 	 * STEP 3
 	 * - set CVP_NUMCLKS to 1 and issue CVP_DUMMY_WR dummy writes to the HIP
 	 */
-	altera_cvp_dummy_write(conf);
+	if (conf->priv->switch_clk)
+		conf->priv->switch_clk(conf);
+
+	if (conf->priv->clear_state) {
+		ret = conf->priv->clear_state(conf);
+		if (ret) {
+			dev_err(&mgr->dev, "Problem clearing out state\n");
+			return ret;
+		}
+	}
+
+	conf->sent_packets = 0;
 
 	/* STEP 4 - set CVP_CONFIG bit */
 	altera_read_config_dword(conf, VSE_CVP_PROG_CTRL, &val);
@@ -273,9 +389,10 @@ static int altera_cvp_write_init(struct fpga_manager *mgr,
 	val |= VSE_CVP_PROG_CTRL_CONFIG;
 	altera_write_config_dword(conf, VSE_CVP_PROG_CTRL, val);
 
-	/* STEP 5 - poll CVP_CONFIG READY for 1 with 10us timeout */
+	/* STEP 5 - poll CVP_CONFIG READY for 1 with timeout */
 	ret = altera_cvp_wait_status(conf, VSE_CVP_STATUS_CFG_RDY,
-				     VSE_CVP_STATUS_CFG_RDY, 10);
+				     VSE_CVP_STATUS_CFG_RDY,
+				     conf->priv->poll_time_us);
 	if (ret) {
 		dev_warn(&mgr->dev, "CFG_RDY == 1 timeout\n");
 		return ret;
@@ -285,7 +402,16 @@ static int altera_cvp_write_init(struct fpga_manager *mgr,
 	 * STEP 6
 	 * - set CVP_NUMCLKS to 1 and issue CVP_DUMMY_WR dummy writes to the HIP
 	 */
-	altera_cvp_dummy_write(conf);
+	if (conf->priv->switch_clk)
+		conf->priv->switch_clk(conf);
+
+	if (altera_cvp_chkcfg) {
+		ret = altera_cvp_chk_error(mgr, 0);
+		if (ret) {
+			dev_warn(&mgr->dev, "CFG_RDY == 1 timeout\n");
+			return ret;
+		}
+	}
 
 	/* STEP 7 - set START_XFER */
 	altera_read_config_dword(conf, VSE_CVP_PROG_CTRL, &val);
@@ -293,11 +419,12 @@ static int altera_cvp_write_init(struct fpga_manager *mgr,
 	altera_write_config_dword(conf, VSE_CVP_PROG_CTRL, val);
 
 	/* STEP 8 - start transfer (set CVP_NUMCLKS for bitstream) */
-	altera_read_config_dword(conf, VSE_CVP_MODE_CTRL, &val);
-	val &= ~VSE_CVP_MODE_CTRL_NUMCLKS_MASK;
-	val |= conf->numclks << VSE_CVP_MODE_CTRL_NUMCLKS_OFF;
-	altera_write_config_dword(conf, VSE_CVP_MODE_CTRL, val);
-
+	if (conf->priv->switch_clk) {
+		altera_read_config_dword(conf, VSE_CVP_MODE_CTRL, &val);
+		val &= ~VSE_CVP_MODE_CTRL_NUMCLKS_MASK;
+		val |= conf->numclks << VSE_CVP_MODE_CTRL_NUMCLKS_OFF;
+		altera_write_config_dword(conf, VSE_CVP_MODE_CTRL, val);
+	}
 	return 0;
 }
 
@@ -315,11 +442,22 @@ static int altera_cvp_write(struct fpga_manager *mgr, const char *buf,
 	done = 0;
 
 	while (remaining) {
-		len = min(sizeof(u32), remaining);
+		/* Use credit throttling if available */
+		if (conf->priv->wait_credit) {
+			status = conf->priv->wait_credit(mgr, done);
+			if (status) {
+				dev_err(&conf->pci_dev->dev,
+					"Wait Credit ERR: 0x%x\n", status);
+				return status;
+			}
+		}
+
+		len = min(conf->priv->block_size, remaining);
 		altera_cvp_send_block(conf, data, len);
-		data++;
+		data += len / sizeof(u32);
 		done += len;
 		remaining -= len;
+		conf->sent_packets++;
 
 		/*
 		 * STEP 10 (optional) and STEP 11
@@ -369,7 +507,8 @@ static int altera_cvp_write_complete(struct fpga_manager *mgr,
 
 	/* STEP 18 - poll PLD_CLK_IN_USE and USER_MODE bits */
 	mask = VSE_CVP_STATUS_PLD_CLK_IN_USE | VSE_CVP_STATUS_USERMODE;
-	ret = altera_cvp_wait_status(conf, mask, mask, TIMEOUT_US);
+	ret = altera_cvp_wait_status(conf, mask, mask,
+				     conf->priv->user_time_us);
 	if (ret)
 		dev_err(&mgr->dev, "PLD_CLK_IN_USE|USERMODE timeout\n");
 
@@ -383,6 +522,21 @@ static const struct fpga_manager_ops altera_cvp_ops = {
 	.write_complete	= altera_cvp_write_complete,
 };
 
+static const struct cvp_priv cvp_priv_v1 = {
+	.switch_clk	= altera_cvp_dummy_write,
+	.block_size	= ALTERA_CVP_V1_SIZE,
+	.poll_time_us	= V1_POLL_TIMEOUT_US,
+	.user_time_us	= TIMEOUT_US,
+};
+
+static const struct cvp_priv cvp_priv_v2 = {
+	.clear_state	= altera_cvp_v2_clear_state,
+	.wait_credit	= altera_cvp_v2_wait_for_credit,
+	.block_size	= ALTERA_CVP_V2_SIZE,
+	.poll_time_us	= V2_POLL_TIMEOUT_US,
+	.user_time_us	= V2_USER_TIMEOUT_US,
+};
+
 static ssize_t chkcfg_show(struct device_driver *dev, char *buf)
 {
 	return snprintf(buf, 3, "%d\n", altera_cvp_chkcfg);
@@ -484,6 +638,11 @@ static int altera_cvp_probe(struct pci_dev *pdev,
 	conf->pci_dev = pdev;
 	conf->write_data = altera_cvp_write_data_iomem;
 
+	if (conf->vsec_offset == V1_VSEC_OFFSET)
+		conf->priv = &cvp_priv_v1;
+	else
+		conf->priv = &cvp_priv_v2;
+
 	conf->map = pci_iomap(pdev, CVP_BAR, 0);
 	if (!conf->map) {
 		dev_warn(&pdev->dev, "Mapping CVP BAR failed\n");

commit d2083d040a95b923a217377dd51c27d57eecf5e6
Author: Thor Thayer <thor.thayer@linux.intel.com>
Date:   Mon Aug 19 15:48:07 2019 -0500

    fpga: altera-cvp: Preparation for V2 parts.
    
    In preparation for adding newer V2 parts that use a FIFO,
    reorganize altera_cvp_chk_error() and change the write
    function to block based.
    V2 parts have a block size matching the FIFO while older
    V1 parts write a 32 bit word at a time.
    
    Signed-off-by: Thor Thayer <thor.thayer@linux.intel.com>
    Signed-off-by: Moritz Fischer <mdf@kernel.org>

diff --git a/drivers/fpga/altera-cvp.c b/drivers/fpga/altera-cvp.c
index 9df2073331cb..3b8386fd32e7 100644
--- a/drivers/fpga/altera-cvp.c
+++ b/drivers/fpga/altera-cvp.c
@@ -143,6 +143,42 @@ static int altera_cvp_wait_status(struct altera_cvp_conf *conf, u32 status_mask,
 	return -ETIMEDOUT;
 }
 
+static int altera_cvp_chk_error(struct fpga_manager *mgr, size_t bytes)
+{
+	struct altera_cvp_conf *conf = mgr->priv;
+	u32 val;
+	int ret;
+
+	/* STEP 10 (optional) - check CVP_CONFIG_ERROR flag */
+	ret = altera_read_config_dword(conf, VSE_CVP_STATUS, &val);
+	if (ret || (val & VSE_CVP_STATUS_CFG_ERR)) {
+		dev_err(&mgr->dev, "CVP_CONFIG_ERROR after %zu bytes!\n",
+			bytes);
+		return -EPROTO;
+	}
+	return 0;
+}
+
+static int altera_cvp_send_block(struct altera_cvp_conf *conf,
+				 const u32 *data, size_t len)
+{
+	u32 mask, words = len / sizeof(u32);
+	int i, remainder;
+
+	for (i = 0; i < words; i++)
+		conf->write_data(conf, *data++);
+
+	/* write up to 3 trailing bytes, if any */
+	remainder = len % sizeof(u32);
+	if (remainder) {
+		mask = BIT(remainder * 8) - 1;
+		if (mask)
+			conf->write_data(conf, *data & mask);
+	}
+
+	return 0;
+}
+
 static int altera_cvp_teardown(struct fpga_manager *mgr,
 			       struct fpga_image_info *info)
 {
@@ -265,39 +301,25 @@ static int altera_cvp_write_init(struct fpga_manager *mgr,
 	return 0;
 }
 
-static inline int altera_cvp_chk_error(struct fpga_manager *mgr, size_t bytes)
-{
-	struct altera_cvp_conf *conf = mgr->priv;
-	u32 val;
-
-	/* STEP 10 (optional) - check CVP_CONFIG_ERROR flag */
-	altera_read_config_dword(conf, VSE_CVP_STATUS, &val);
-	if (val & VSE_CVP_STATUS_CFG_ERR) {
-		dev_err(&mgr->dev, "CVP_CONFIG_ERROR after %zu bytes!\n",
-			bytes);
-		return -EPROTO;
-	}
-	return 0;
-}
-
 static int altera_cvp_write(struct fpga_manager *mgr, const char *buf,
 			    size_t count)
 {
 	struct altera_cvp_conf *conf = mgr->priv;
+	size_t done, remaining, len;
 	const u32 *data;
-	size_t done, remaining;
 	int status = 0;
-	u32 mask;
 
 	/* STEP 9 - write 32-bit data from RBF file to CVP data register */
 	data = (u32 *)buf;
 	remaining = count;
 	done = 0;
 
-	while (remaining >= 4) {
-		conf->write_data(conf, *data++);
-		done += 4;
-		remaining -= 4;
+	while (remaining) {
+		len = min(sizeof(u32), remaining);
+		altera_cvp_send_block(conf, data, len);
+		data++;
+		done += len;
+		remaining -= len;
 
 		/*
 		 * STEP 10 (optional) and STEP 11
@@ -315,11 +337,6 @@ static int altera_cvp_write(struct fpga_manager *mgr, const char *buf,
 		}
 	}
 
-	/* write up to 3 trailing bytes, if any */
-	mask = BIT(remaining * 8) - 1;
-	if (mask)
-		conf->write_data(conf, *data & mask);
-
 	if (altera_cvp_chkcfg)
 		status = altera_cvp_chk_error(mgr, count);
 

commit eb12511f0d47b4da58cc9fc1e93362081fa3331b
Author: Thor Thayer <thor.thayer@linux.intel.com>
Date:   Mon Aug 19 15:48:06 2019 -0500

    fpga: altera-cvp: Discover Vendor Specific offset
    
    Newer Intel FPGAs have different Vendor Specific offsets than
    legacy parts. Use PCI discovery to find the CvP registers.
    Since the register positions remain the same, change the hard
    coded address to a more flexible way of indexing registers
    from the offset.
    Adding new PCI read and write abstraction functions to
    handle the offset (altera_read_config_dword() and
    altera_write_config_dword()).
    
    Signed-off-by: Thor Thayer <thor.thayer@linux.intel.com>
    Signed-off-by: Moritz Fischer <mdf@kernel.org>

diff --git a/drivers/fpga/altera-cvp.c b/drivers/fpga/altera-cvp.c
index 53b963071c7b..9df2073331cb 100644
--- a/drivers/fpga/altera-cvp.c
+++ b/drivers/fpga/altera-cvp.c
@@ -22,10 +22,10 @@
 #define TIMEOUT_US	2000	/* CVP STATUS timeout for USERMODE polling */
 
 /* Vendor Specific Extended Capability Registers */
-#define VSE_PCIE_EXT_CAP_ID		0x200
+#define VSE_PCIE_EXT_CAP_ID		0x0
 #define VSE_PCIE_EXT_CAP_ID_VAL		0x000b	/* 16bit */
 
-#define VSE_CVP_STATUS			0x21c	/* 32bit */
+#define VSE_CVP_STATUS			0x1c	/* 32bit */
 #define VSE_CVP_STATUS_CFG_RDY		BIT(18)	/* CVP_CONFIG_READY */
 #define VSE_CVP_STATUS_CFG_ERR		BIT(19)	/* CVP_CONFIG_ERROR */
 #define VSE_CVP_STATUS_CVP_EN		BIT(20)	/* ctrl block is enabling CVP */
@@ -33,18 +33,18 @@
 #define VSE_CVP_STATUS_CFG_DONE		BIT(23)	/* CVP_CONFIG_DONE */
 #define VSE_CVP_STATUS_PLD_CLK_IN_USE	BIT(24)	/* PLD_CLK_IN_USE */
 
-#define VSE_CVP_MODE_CTRL		0x220	/* 32bit */
+#define VSE_CVP_MODE_CTRL		0x20	/* 32bit */
 #define VSE_CVP_MODE_CTRL_CVP_MODE	BIT(0)	/* CVP (1) or normal mode (0) */
 #define VSE_CVP_MODE_CTRL_HIP_CLK_SEL	BIT(1) /* PMA (1) or fabric clock (0) */
 #define VSE_CVP_MODE_CTRL_NUMCLKS_OFF	8	/* NUMCLKS bits offset */
 #define VSE_CVP_MODE_CTRL_NUMCLKS_MASK	GENMASK(15, 8)
 
-#define VSE_CVP_DATA			0x228	/* 32bit */
-#define VSE_CVP_PROG_CTRL		0x22c	/* 32bit */
+#define VSE_CVP_DATA			0x28	/* 32bit */
+#define VSE_CVP_PROG_CTRL		0x2c	/* 32bit */
 #define VSE_CVP_PROG_CTRL_CONFIG	BIT(0)
 #define VSE_CVP_PROG_CTRL_START_XFER	BIT(1)
 
-#define VSE_UNCOR_ERR_STATUS		0x234	/* 32bit */
+#define VSE_UNCOR_ERR_STATUS		0x34	/* 32bit */
 #define VSE_UNCOR_ERR_CVP_CFG_ERR	BIT(5)	/* CVP_CONFIG_ERROR_LATCHED */
 
 #define DRV_NAME		"altera-cvp"
@@ -61,14 +61,29 @@ struct altera_cvp_conf {
 					      u32 data);
 	char			mgr_name[64];
 	u8			numclks;
+	u32			vsec_offset;
 };
 
+static int altera_read_config_dword(struct altera_cvp_conf *conf,
+				    int where, u32 *val)
+{
+	return pci_read_config_dword(conf->pci_dev, conf->vsec_offset + where,
+				     val);
+}
+
+static int altera_write_config_dword(struct altera_cvp_conf *conf,
+				     int where, u32 val)
+{
+	return pci_write_config_dword(conf->pci_dev, conf->vsec_offset + where,
+				      val);
+}
+
 static enum fpga_mgr_states altera_cvp_state(struct fpga_manager *mgr)
 {
 	struct altera_cvp_conf *conf = mgr->priv;
 	u32 status;
 
-	pci_read_config_dword(conf->pci_dev, VSE_CVP_STATUS, &status);
+	altera_read_config_dword(conf, VSE_CVP_STATUS, &status);
 
 	if (status & VSE_CVP_STATUS_CFG_DONE)
 		return FPGA_MGR_STATE_OPERATING;
@@ -86,7 +101,8 @@ static void altera_cvp_write_data_iomem(struct altera_cvp_conf *conf, u32 val)
 
 static void altera_cvp_write_data_config(struct altera_cvp_conf *conf, u32 val)
 {
-	pci_write_config_dword(conf->pci_dev, VSE_CVP_DATA, val);
+	pci_write_config_dword(conf->pci_dev, conf->vsec_offset + VSE_CVP_DATA,
+			       val);
 }
 
 /* switches between CvP clock and internal clock */
@@ -96,10 +112,10 @@ static void altera_cvp_dummy_write(struct altera_cvp_conf *conf)
 	u32 val;
 
 	/* set 1 CVP clock cycle for every CVP Data Register Write */
-	pci_read_config_dword(conf->pci_dev, VSE_CVP_MODE_CTRL, &val);
+	altera_read_config_dword(conf, VSE_CVP_MODE_CTRL, &val);
 	val &= ~VSE_CVP_MODE_CTRL_NUMCLKS_MASK;
 	val |= 1 << VSE_CVP_MODE_CTRL_NUMCLKS_OFF;
-	pci_write_config_dword(conf->pci_dev, VSE_CVP_MODE_CTRL, val);
+	altera_write_config_dword(conf, VSE_CVP_MODE_CTRL, val);
 
 	for (i = 0; i < CVP_DUMMY_WR; i++)
 		conf->write_data(conf, 0); /* dummy data, could be any value */
@@ -116,7 +132,7 @@ static int altera_cvp_wait_status(struct altera_cvp_conf *conf, u32 status_mask,
 		retries++;
 
 	do {
-		pci_read_config_dword(conf->pci_dev, VSE_CVP_STATUS, &val);
+		altera_read_config_dword(conf, VSE_CVP_STATUS, &val);
 		if ((val & status_mask) == status_val)
 			return 0;
 
@@ -131,18 +147,17 @@ static int altera_cvp_teardown(struct fpga_manager *mgr,
 			       struct fpga_image_info *info)
 {
 	struct altera_cvp_conf *conf = mgr->priv;
-	struct pci_dev *pdev = conf->pci_dev;
 	int ret;
 	u32 val;
 
 	/* STEP 12 - reset START_XFER bit */
-	pci_read_config_dword(pdev, VSE_CVP_PROG_CTRL, &val);
+	altera_read_config_dword(conf, VSE_CVP_PROG_CTRL, &val);
 	val &= ~VSE_CVP_PROG_CTRL_START_XFER;
-	pci_write_config_dword(pdev, VSE_CVP_PROG_CTRL, val);
+	altera_write_config_dword(conf, VSE_CVP_PROG_CTRL, val);
 
 	/* STEP 13 - reset CVP_CONFIG bit */
 	val &= ~VSE_CVP_PROG_CTRL_CONFIG;
-	pci_write_config_dword(pdev, VSE_CVP_PROG_CTRL, val);
+	altera_write_config_dword(conf, VSE_CVP_PROG_CTRL, val);
 
 	/*
 	 * STEP 14
@@ -164,7 +179,6 @@ static int altera_cvp_write_init(struct fpga_manager *mgr,
 				 const char *buf, size_t count)
 {
 	struct altera_cvp_conf *conf = mgr->priv;
-	struct pci_dev *pdev = conf->pci_dev;
 	u32 iflags, val;
 	int ret;
 
@@ -184,7 +198,7 @@ static int altera_cvp_write_init(struct fpga_manager *mgr,
 		conf->numclks = 1; /* for uncompressed and unencrypted images */
 
 	/* STEP 1 - read CVP status and check CVP_EN flag */
-	pci_read_config_dword(pdev, VSE_CVP_STATUS, &val);
+	altera_read_config_dword(conf, VSE_CVP_STATUS, &val);
 	if (!(val & VSE_CVP_STATUS_CVP_EN)) {
 		dev_err(&mgr->dev, "CVP mode off: 0x%04x\n", val);
 		return -ENODEV;
@@ -202,14 +216,14 @@ static int altera_cvp_write_init(struct fpga_manager *mgr,
 	 * - set HIP_CLK_SEL and CVP_MODE (must be set in the order mentioned)
 	 */
 	/* switch from fabric to PMA clock */
-	pci_read_config_dword(pdev, VSE_CVP_MODE_CTRL, &val);
+	altera_read_config_dword(conf, VSE_CVP_MODE_CTRL, &val);
 	val |= VSE_CVP_MODE_CTRL_HIP_CLK_SEL;
-	pci_write_config_dword(pdev, VSE_CVP_MODE_CTRL, val);
+	altera_write_config_dword(conf, VSE_CVP_MODE_CTRL, val);
 
 	/* set CVP mode */
-	pci_read_config_dword(pdev, VSE_CVP_MODE_CTRL, &val);
+	altera_read_config_dword(conf, VSE_CVP_MODE_CTRL, &val);
 	val |= VSE_CVP_MODE_CTRL_CVP_MODE;
-	pci_write_config_dword(pdev, VSE_CVP_MODE_CTRL, val);
+	altera_write_config_dword(conf, VSE_CVP_MODE_CTRL, val);
 
 	/*
 	 * STEP 3
@@ -218,10 +232,10 @@ static int altera_cvp_write_init(struct fpga_manager *mgr,
 	altera_cvp_dummy_write(conf);
 
 	/* STEP 4 - set CVP_CONFIG bit */
-	pci_read_config_dword(pdev, VSE_CVP_PROG_CTRL, &val);
+	altera_read_config_dword(conf, VSE_CVP_PROG_CTRL, &val);
 	/* request control block to begin transfer using CVP */
 	val |= VSE_CVP_PROG_CTRL_CONFIG;
-	pci_write_config_dword(pdev, VSE_CVP_PROG_CTRL, val);
+	altera_write_config_dword(conf, VSE_CVP_PROG_CTRL, val);
 
 	/* STEP 5 - poll CVP_CONFIG READY for 1 with 10us timeout */
 	ret = altera_cvp_wait_status(conf, VSE_CVP_STATUS_CFG_RDY,
@@ -238,15 +252,15 @@ static int altera_cvp_write_init(struct fpga_manager *mgr,
 	altera_cvp_dummy_write(conf);
 
 	/* STEP 7 - set START_XFER */
-	pci_read_config_dword(pdev, VSE_CVP_PROG_CTRL, &val);
+	altera_read_config_dword(conf, VSE_CVP_PROG_CTRL, &val);
 	val |= VSE_CVP_PROG_CTRL_START_XFER;
-	pci_write_config_dword(pdev, VSE_CVP_PROG_CTRL, val);
+	altera_write_config_dword(conf, VSE_CVP_PROG_CTRL, val);
 
 	/* STEP 8 - start transfer (set CVP_NUMCLKS for bitstream) */
-	pci_read_config_dword(pdev, VSE_CVP_MODE_CTRL, &val);
+	altera_read_config_dword(conf, VSE_CVP_MODE_CTRL, &val);
 	val &= ~VSE_CVP_MODE_CTRL_NUMCLKS_MASK;
 	val |= conf->numclks << VSE_CVP_MODE_CTRL_NUMCLKS_OFF;
-	pci_write_config_dword(pdev, VSE_CVP_MODE_CTRL, val);
+	altera_write_config_dword(conf, VSE_CVP_MODE_CTRL, val);
 
 	return 0;
 }
@@ -257,7 +271,7 @@ static inline int altera_cvp_chk_error(struct fpga_manager *mgr, size_t bytes)
 	u32 val;
 
 	/* STEP 10 (optional) - check CVP_CONFIG_ERROR flag */
-	pci_read_config_dword(conf->pci_dev, VSE_CVP_STATUS, &val);
+	altera_read_config_dword(conf, VSE_CVP_STATUS, &val);
 	if (val & VSE_CVP_STATUS_CFG_ERR) {
 		dev_err(&mgr->dev, "CVP_CONFIG_ERROR after %zu bytes!\n",
 			bytes);
@@ -316,27 +330,25 @@ static int altera_cvp_write_complete(struct fpga_manager *mgr,
 				     struct fpga_image_info *info)
 {
 	struct altera_cvp_conf *conf = mgr->priv;
-	struct pci_dev *pdev = conf->pci_dev;
+	u32 mask, val;
 	int ret;
-	u32 mask;
-	u32 val;
 
 	ret = altera_cvp_teardown(mgr, info);
 	if (ret)
 		return ret;
 
 	/* STEP 16 - check CVP_CONFIG_ERROR_LATCHED bit */
-	pci_read_config_dword(pdev, VSE_UNCOR_ERR_STATUS, &val);
+	altera_read_config_dword(conf, VSE_UNCOR_ERR_STATUS, &val);
 	if (val & VSE_UNCOR_ERR_CVP_CFG_ERR) {
 		dev_err(&mgr->dev, "detected CVP_CONFIG_ERROR_LATCHED!\n");
 		return -EPROTO;
 	}
 
 	/* STEP 17 - reset CVP_MODE and HIP_CLK_SEL bit */
-	pci_read_config_dword(pdev, VSE_CVP_MODE_CTRL, &val);
+	altera_read_config_dword(conf, VSE_CVP_MODE_CTRL, &val);
 	val &= ~VSE_CVP_MODE_CTRL_HIP_CLK_SEL;
 	val &= ~VSE_CVP_MODE_CTRL_CVP_MODE;
-	pci_write_config_dword(pdev, VSE_CVP_MODE_CTRL, val);
+	altera_write_config_dword(conf, VSE_CVP_MODE_CTRL, val);
 
 	/* STEP 18 - poll PLD_CLK_IN_USE and USER_MODE bits */
 	mask = VSE_CVP_STATUS_PLD_CLK_IN_USE | VSE_CVP_STATUS_USERMODE;
@@ -395,22 +407,29 @@ static int altera_cvp_probe(struct pci_dev *pdev,
 {
 	struct altera_cvp_conf *conf;
 	struct fpga_manager *mgr;
+	int ret, offset;
 	u16 cmd, val;
 	u32 regval;
-	int ret;
+
+	/* Discover the Vendor Specific Offset for this device */
+	offset = pci_find_next_ext_capability(pdev, 0, PCI_EXT_CAP_ID_VNDR);
+	if (!offset) {
+		dev_err(&pdev->dev, "No Vendor Specific Offset.\n");
+		return -ENODEV;
+	}
 
 	/*
 	 * First check if this is the expected FPGA device. PCI config
 	 * space access works without enabling the PCI device, memory
 	 * space access is enabled further down.
 	 */
-	pci_read_config_word(pdev, VSE_PCIE_EXT_CAP_ID, &val);
+	pci_read_config_word(pdev, offset + VSE_PCIE_EXT_CAP_ID, &val);
 	if (val != VSE_PCIE_EXT_CAP_ID_VAL) {
 		dev_err(&pdev->dev, "Wrong EXT_CAP_ID value 0x%x\n", val);
 		return -ENODEV;
 	}
 
-	pci_read_config_dword(pdev, VSE_CVP_STATUS, &regval);
+	pci_read_config_dword(pdev, offset + VSE_CVP_STATUS, &regval);
 	if (!(regval & VSE_CVP_STATUS_CVP_EN)) {
 		dev_err(&pdev->dev,
 			"CVP is disabled for this device: CVP_STATUS Reg 0x%x\n",
@@ -422,6 +441,8 @@ static int altera_cvp_probe(struct pci_dev *pdev,
 	if (!conf)
 		return -ENOMEM;
 
+	conf->vsec_offset = offset;
+
 	/*
 	 * Enable memory BAR access. We cannot use pci_enable_device() here
 	 * because it will make the driver unusable with FPGA devices that

commit 998c1de56dac7ff6bad4f810259cc25c7d6d2843
Author: Carlos A Petry <capetry.dev@gmail.com>
Date:   Wed Nov 7 23:13:12 2018 -0200

    fpga: altera-cvp: Fix function definition argument
    
    Fix the following checkpatch warning:
    WARNING: function definition argument 'struct altera_cvp_conf *'
    
    Signed-off-by: Carlos A Petry <capetry.dev@gmail.com>
    Signed-off-by: Moritz Fischer <mdf@kernel.org>

diff --git a/drivers/fpga/altera-cvp.c b/drivers/fpga/altera-cvp.c
index 770915fb97f9..53b963071c7b 100644
--- a/drivers/fpga/altera-cvp.c
+++ b/drivers/fpga/altera-cvp.c
@@ -57,7 +57,8 @@ struct altera_cvp_conf {
 	struct fpga_manager	*mgr;
 	struct pci_dev		*pci_dev;
 	void __iomem		*map;
-	void			(*write_data)(struct altera_cvp_conf *, u32);
+	void			(*write_data)(struct altera_cvp_conf *conf,
+					      u32 data);
 	char			mgr_name[64];
 	u8			numclks;
 };

commit 8e8e69d67e5fad1a1edf97acebd649a6c8f1febd
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 07:17:59 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 285
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation version 2 of the license this program
      is distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 100 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190529141900.918357685@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/fpga/altera-cvp.c b/drivers/fpga/altera-cvp.c
index 35c3aa5792e2..770915fb97f9 100644
--- a/drivers/fpga/altera-cvp.c
+++ b/drivers/fpga/altera-cvp.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * FPGA Manager Driver for Altera Arria/Cyclone/Stratix CvP
  *
@@ -5,15 +6,6 @@
  *
  * Anatolij Gustschin <agust@denx.de>
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; version 2 of the License.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
  * Manage Altera FPGA firmware using PCIe CvP.
  * Firmware must be in binary "rbf" format.
  */

commit 30522a951f9d02f261d0697c35cb42205b1fae17
Author: Anatolij Gustschin <agust@denx.de>
Date:   Mon Nov 26 11:35:27 2018 -0600

    fpga: altera-cvp: fix probing for multiple FPGAs on the bus
    
    Currently registering CvP managers works only for first probed CvP
    device, for all other devices it is refused due to duplicated chkcfg
    sysfs entry:
    
    fpga_manager fpga3: Altera CvP FPGA Manager @0000:0c:00.0 registered
    sysfs: cannot create duplicate filename '/bus/pci/drivers/altera-cvp/chkcfg'
    CPU: 0 PID: 3808 Comm: bash Tainted: G           O      4.19.0-custom+ #5
    Call Trace:
      dump_stack+0x46/0x5b
      sysfs_warn_dup+0x53/0x60
      sysfs_add_file_mode_ns+0x16d/0x180
      sysfs_create_file_ns+0x51/0x60
      altera_cvp_probe+0x16f/0x2a0 [altera_cvp]
      local_pci_probe+0x3f/0xa0
      ? pci_match_device+0xb1/0xf0
      pci_device_probe+0x116/0x170
      really_probe+0x21b/0x2c0
      driver_probe_device+0x4b/0xe0
      bind_store+0xcb/0x130
      kernfs_fop_write+0xfd/0x180
      __vfs_write+0x21/0x150
      ? selinux_file_permission+0xdc/0x130
      vfs_write+0xa8/0x1a0
      ? find_vma+0xd/0x60
      ksys_write+0x3d/0x90
      do_syscall_64+0x44/0xf0
      entry_SYSCALL_64_after_hwframe+0x44/0xa9
      ...
     altera-cvp 0000:0c:00.0: Can't create sysfs chkcfg file
     fpga_manager fpga3: fpga_mgr_unregister Altera CvP FPGA Manager @0000:0c:00.0
    
    Move chkcfg creation to module init as suggested by Alan.
    
    Signed-off-by: Anatolij Gustschin <agust@denx.de>
    Acked-by: Alan Tull <atull@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/fpga/altera-cvp.c b/drivers/fpga/altera-cvp.c
index 73950851e404..35c3aa5792e2 100644
--- a/drivers/fpga/altera-cvp.c
+++ b/drivers/fpga/altera-cvp.c
@@ -475,14 +475,6 @@ static int altera_cvp_probe(struct pci_dev *pdev,
 	if (ret)
 		goto err_unmap;
 
-	ret = driver_create_file(&altera_cvp_driver.driver,
-				 &driver_attr_chkcfg);
-	if (ret) {
-		dev_err(&pdev->dev, "Can't create sysfs chkcfg file\n");
-		fpga_mgr_unregister(mgr);
-		goto err_unmap;
-	}
-
 	return 0;
 
 err_unmap:
@@ -501,7 +493,6 @@ static void altera_cvp_remove(struct pci_dev *pdev)
 	struct altera_cvp_conf *conf = mgr->priv;
 	u16 cmd;
 
-	driver_remove_file(&altera_cvp_driver.driver, &driver_attr_chkcfg);
 	fpga_mgr_unregister(mgr);
 	if (conf->map)
 		pci_iounmap(pdev, conf->map);
@@ -511,7 +502,30 @@ static void altera_cvp_remove(struct pci_dev *pdev)
 	pci_write_config_word(pdev, PCI_COMMAND, cmd);
 }
 
-module_pci_driver(altera_cvp_driver);
+static int __init altera_cvp_init(void)
+{
+	int ret;
+
+	ret = pci_register_driver(&altera_cvp_driver);
+	if (ret)
+		return ret;
+
+	ret = driver_create_file(&altera_cvp_driver.driver,
+				 &driver_attr_chkcfg);
+	if (ret)
+		pr_warn("Can't create sysfs chkcfg file\n");
+
+	return 0;
+}
+
+static void __exit altera_cvp_exit(void)
+{
+	driver_remove_file(&altera_cvp_driver.driver, &driver_attr_chkcfg);
+	pci_unregister_driver(&altera_cvp_driver);
+}
+
+module_init(altera_cvp_init);
+module_exit(altera_cvp_exit);
 
 MODULE_LICENSE("GPL v2");
 MODULE_AUTHOR("Anatolij Gustschin <agust@denx.de>");

commit 68f60538daa4bc3da5d0764d46f391916fba20fd
Author: Andreas Puhm <puhm@oregano.at>
Date:   Wed Nov 7 11:51:47 2018 -0600

    fpga: altera-cvp: Fix registration for CvP incapable devices
    
    The probe function needs to verify the CvP enable bit in order to
    properly determine if FPGA Manager functionality can be safely
    enabled.
    
    Fixes: 34d1dc17ce97 ("fpga manager: Add Altera CvP driver")
    Signed-off-by: Andreas Puhm <puhm@oregano.at>
    Signed-off-by: Anatolij Gustschin <agust@denx.de>
    Reviewed-by: Moritz Fischer <mdf@kernel.org>
    Acked-by: Alan Tull <atull@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/fpga/altera-cvp.c b/drivers/fpga/altera-cvp.c
index 144fa2a4d4cc..73950851e404 100644
--- a/drivers/fpga/altera-cvp.c
+++ b/drivers/fpga/altera-cvp.c
@@ -403,6 +403,7 @@ static int altera_cvp_probe(struct pci_dev *pdev,
 	struct altera_cvp_conf *conf;
 	struct fpga_manager *mgr;
 	u16 cmd, val;
+	u32 regval;
 	int ret;
 
 	/*
@@ -416,6 +417,14 @@ static int altera_cvp_probe(struct pci_dev *pdev,
 		return -ENODEV;
 	}
 
+	pci_read_config_dword(pdev, VSE_CVP_STATUS, &regval);
+	if (!(regval & VSE_CVP_STATUS_CVP_EN)) {
+		dev_err(&pdev->dev,
+			"CVP is disabled for this device: CVP_STATUS Reg 0x%x\n",
+			regval);
+		return -ENODEV;
+	}
+
 	conf = devm_kzalloc(&pdev->dev, sizeof(*conf), GFP_KERNEL);
 	if (!conf)
 		return -ENOMEM;

commit 187fade88ca0ff2df9d360ca751d948d73db7095
Author: Anatolij Gustschin <agust@denx.de>
Date:   Wed Nov 7 11:51:45 2018 -0600

    fpga: altera-cvp: fix 'bad IO access' on x86_64
    
    If mapping the CvP BAR fails, we still can configure the FPGA via
    PCI config space access. In this case the iomap pointer is NULL.
    On x86_64, passing NULL address to pci_iounmap() generates
    "Bad IO access at port 0x0" output with stack call trace. Fix it.
    
    Signed-off-by: Anatolij Gustschin <agust@denx.de>
    Acked-by: Alan Tull <atull@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/fpga/altera-cvp.c b/drivers/fpga/altera-cvp.c
index 610a1558e0ed..144fa2a4d4cc 100644
--- a/drivers/fpga/altera-cvp.c
+++ b/drivers/fpga/altera-cvp.c
@@ -477,7 +477,8 @@ static int altera_cvp_probe(struct pci_dev *pdev,
 	return 0;
 
 err_unmap:
-	pci_iounmap(pdev, conf->map);
+	if (conf->map)
+		pci_iounmap(pdev, conf->map);
 	pci_release_region(pdev, CVP_BAR);
 err_disable:
 	cmd &= ~PCI_COMMAND_MEMORY;
@@ -493,7 +494,8 @@ static void altera_cvp_remove(struct pci_dev *pdev)
 
 	driver_remove_file(&altera_cvp_driver.driver, &driver_attr_chkcfg);
 	fpga_mgr_unregister(mgr);
-	pci_iounmap(pdev, conf->map);
+	if (conf->map)
+		pci_iounmap(pdev, conf->map);
 	pci_release_region(pdev, CVP_BAR);
 	pci_read_config_word(pdev, PCI_COMMAND, &cmd);
 	cmd &= ~PCI_COMMAND_MEMORY;

commit 084181fe8cc7472695b907f0018f4cd00934cb12
Author: Alan Tull <atull@kernel.org>
Date:   Mon Oct 15 17:20:01 2018 -0500

    fpga: mgr: add devm_fpga_mgr_create
    
    Add devm_fpga_mgr_create() which is the managed
    version of fpga_mgr_create().
    
    Change current FPGA manager drivers to use
    devm_fpga_mgr_create()
    
    Signed-off-by: Alan Tull <atull@kernel.org>
    Suggested-by: Federico Vaga <federico.vaga@cern.ch>
    Acked-by: Moritz Fischer <mdf@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/fpga/altera-cvp.c b/drivers/fpga/altera-cvp.c
index 7fa793672a7a..610a1558e0ed 100644
--- a/drivers/fpga/altera-cvp.c
+++ b/drivers/fpga/altera-cvp.c
@@ -453,8 +453,8 @@ static int altera_cvp_probe(struct pci_dev *pdev,
 	snprintf(conf->mgr_name, sizeof(conf->mgr_name), "%s @%s",
 		 ALTERA_CVP_MGR_NAME, pci_name(pdev));
 
-	mgr = fpga_mgr_create(&pdev->dev, conf->mgr_name,
-			      &altera_cvp_ops, conf);
+	mgr = devm_fpga_mgr_create(&pdev->dev, conf->mgr_name,
+				   &altera_cvp_ops, conf);
 	if (!mgr) {
 		ret = -ENOMEM;
 		goto err_unmap;
@@ -463,10 +463,8 @@ static int altera_cvp_probe(struct pci_dev *pdev,
 	pci_set_drvdata(pdev, mgr);
 
 	ret = fpga_mgr_register(mgr);
-	if (ret) {
-		fpga_mgr_free(mgr);
+	if (ret)
 		goto err_unmap;
-	}
 
 	ret = driver_create_file(&altera_cvp_driver.driver,
 				 &driver_attr_chkcfg);

commit 122c5770cff2c1df1a2384b68285be2812cd72c1
Author: Christophe Jaillet <christophe.jaillet@wanadoo.fr>
Date:   Wed Jun 27 20:56:18 2018 -0500

    fpga: altera-cvp: Fix an error handling path in 'altera_cvp_probe()'
    
    If 'fpga_mgr_create()' fails, we should release some resources, as done
    in the other error handling path of the function.
    
    Fixes: 7085e2a94f7d ("fpga: manager: change api, don't use drvdata")
    Signed-off-by: Christophe JAILLET <christophe.jaillet@wanadoo.fr>
    Reviewed-by: Moritz Fischer <mdf@kernel.org>
    Acked-by: Alan Tull <atull@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/fpga/altera-cvp.c b/drivers/fpga/altera-cvp.c
index dd4edd8f22ce..7fa793672a7a 100644
--- a/drivers/fpga/altera-cvp.c
+++ b/drivers/fpga/altera-cvp.c
@@ -455,8 +455,10 @@ static int altera_cvp_probe(struct pci_dev *pdev,
 
 	mgr = fpga_mgr_create(&pdev->dev, conf->mgr_name,
 			      &altera_cvp_ops, conf);
-	if (!mgr)
-		return -ENOMEM;
+	if (!mgr) {
+		ret = -ENOMEM;
+		goto err_unmap;
+	}
 
 	pci_set_drvdata(pdev, mgr);
 

commit 7085e2a94f7df5f419e3cfb2fe809ce6564e9629
Author: Alan Tull <atull@kernel.org>
Date:   Wed May 16 18:49:55 2018 -0500

    fpga: manager: change api, don't use drvdata
    
    Change fpga_mgr_register to not set or use drvdata.  This supports
    the case where a PCIe device has more than one manager.
    
    Add fpga_mgr_create/free functions.  Change fpga_mgr_register and
    fpga_mgr_unregister functions to take the mgr struct as their only
    parameter.
    
      struct fpga_manager *fpga_mgr_create(struct device *dev,
                    const char *name,
                    const struct fpga_manager_ops *mops,
                    void *priv);
      void fpga_mgr_free(struct fpga_manager *mgr);
      int fpga_mgr_register(struct fpga_manager *mgr);
      void fpga_mgr_unregister(struct fpga_manager *mgr);
    
    Update the drivers that call fpga_mgr_register with the new API.
    
    Signed-off-by: Alan Tull <atull@kernel.org>
    [Moritz: Fixup whitespace issue]
    Reported-by: Jiuyue Ma <majiuyue@huawei.com>
    Signed-off-by: Moritz Fischer <mdf@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/fpga/altera-cvp.c b/drivers/fpga/altera-cvp.c
index 77b04e4b3254..dd4edd8f22ce 100644
--- a/drivers/fpga/altera-cvp.c
+++ b/drivers/fpga/altera-cvp.c
@@ -401,6 +401,7 @@ static int altera_cvp_probe(struct pci_dev *pdev,
 			    const struct pci_device_id *dev_id)
 {
 	struct altera_cvp_conf *conf;
+	struct fpga_manager *mgr;
 	u16 cmd, val;
 	int ret;
 
@@ -452,16 +453,24 @@ static int altera_cvp_probe(struct pci_dev *pdev,
 	snprintf(conf->mgr_name, sizeof(conf->mgr_name), "%s @%s",
 		 ALTERA_CVP_MGR_NAME, pci_name(pdev));
 
-	ret = fpga_mgr_register(&pdev->dev, conf->mgr_name,
-				&altera_cvp_ops, conf);
-	if (ret)
+	mgr = fpga_mgr_create(&pdev->dev, conf->mgr_name,
+			      &altera_cvp_ops, conf);
+	if (!mgr)
+		return -ENOMEM;
+
+	pci_set_drvdata(pdev, mgr);
+
+	ret = fpga_mgr_register(mgr);
+	if (ret) {
+		fpga_mgr_free(mgr);
 		goto err_unmap;
+	}
 
 	ret = driver_create_file(&altera_cvp_driver.driver,
 				 &driver_attr_chkcfg);
 	if (ret) {
 		dev_err(&pdev->dev, "Can't create sysfs chkcfg file\n");
-		fpga_mgr_unregister(&pdev->dev);
+		fpga_mgr_unregister(mgr);
 		goto err_unmap;
 	}
 
@@ -483,7 +492,7 @@ static void altera_cvp_remove(struct pci_dev *pdev)
 	u16 cmd;
 
 	driver_remove_file(&altera_cvp_driver.driver, &driver_attr_chkcfg);
-	fpga_mgr_unregister(&pdev->dev);
+	fpga_mgr_unregister(mgr);
 	pci_iounmap(pdev, conf->map);
 	pci_release_region(pdev, CVP_BAR);
 	pci_read_config_word(pdev, PCI_COMMAND, &cmd);

commit c4ccc893ce2ab819171f797e8b2c702cc87cb84a
Author: Johannes Thumshirn <jthumshirn@suse.de>
Date:   Mon Mar 12 10:41:18 2018 +0100

    PCI: Add Altera vendor ID
    
    Add the Altera PCI Vendor id to pci_ids.h and remove the private
    definitions from xillybus_pcie.c and altera-cvp.c.
    
    Signed-off-by: Johannes Thumshirn <jthumshirn@suse.de>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Eli Billauer <eli.billauer@gmail.com>
    Cc: Anatolij Gustschin <agust@denx.de>
    Acked-by: Eli Billauer <eli.billauer@gmail.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/fpga/altera-cvp.c b/drivers/fpga/altera-cvp.c
index 00e73d28077c..77b04e4b3254 100644
--- a/drivers/fpga/altera-cvp.c
+++ b/drivers/fpga/altera-cvp.c
@@ -384,8 +384,6 @@ static int altera_cvp_probe(struct pci_dev *pdev,
 			    const struct pci_device_id *dev_id);
 static void altera_cvp_remove(struct pci_dev *pdev);
 
-#define PCI_VENDOR_ID_ALTERA	0x1172
-
 static struct pci_device_id altera_cvp_id_tbl[] = {
 	{ PCI_VDEVICE(ALTERA, PCI_ANY_ID) },
 	{ }

commit 55e001aabb826c96f09e0a440bdcbce620189dbc
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Sep 18 12:17:36 2017 +0200

    fpga: altera-cvp: remove DRIVER_ATTR() usage
    
    It's better to be explicit and use the DRIVER_ATTR_RW() macro when
    defining a driver's sysfs file.
    
    This is part of a series to drop DRIVER_ATTR() from the tree entirely.
    
    Cc: linux-fpga@vger.kernel.org
    Reviewed-by: Moritz Fischer <mdf@kernel.org>
    Acked-by: Alan Tull <atull@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/fpga/altera-cvp.c b/drivers/fpga/altera-cvp.c
index 08629ee69d11..00e73d28077c 100644
--- a/drivers/fpga/altera-cvp.c
+++ b/drivers/fpga/altera-cvp.c
@@ -361,12 +361,12 @@ static const struct fpga_manager_ops altera_cvp_ops = {
 	.write_complete	= altera_cvp_write_complete,
 };
 
-static ssize_t show_chkcfg(struct device_driver *dev, char *buf)
+static ssize_t chkcfg_show(struct device_driver *dev, char *buf)
 {
 	return snprintf(buf, 3, "%d\n", altera_cvp_chkcfg);
 }
 
-static ssize_t store_chkcfg(struct device_driver *drv, const char *buf,
+static ssize_t chkcfg_store(struct device_driver *drv, const char *buf,
 			    size_t count)
 {
 	int ret;
@@ -378,7 +378,7 @@ static ssize_t store_chkcfg(struct device_driver *drv, const char *buf,
 	return count;
 }
 
-static DRIVER_ATTR(chkcfg, 0600, show_chkcfg, store_chkcfg);
+static DRIVER_ATTR_RW(chkcfg);
 
 static int altera_cvp_probe(struct pci_dev *pdev,
 			    const struct pci_device_id *dev_id);

commit 34d1dc17ce978ae76e676d401b48fe9d004aa948
Author: Anatolij Gustschin <agust@denx.de>
Date:   Wed Jun 14 10:36:35 2017 -0500

    fpga manager: Add Altera CvP driver
    
    Add FPGA manager driver for loading Arria-V/Cyclone-V/Stratix-V
    and Arria-10 FPGAs via CvP.
    
    Signed-off-by: Anatolij Gustschin <agust@denx.de>
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Signed-off-by: Alan Tull <atull@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/fpga/altera-cvp.c b/drivers/fpga/altera-cvp.c
new file mode 100644
index 000000000000..08629ee69d11
--- /dev/null
+++ b/drivers/fpga/altera-cvp.c
@@ -0,0 +1,500 @@
+/*
+ * FPGA Manager Driver for Altera Arria/Cyclone/Stratix CvP
+ *
+ * Copyright (C) 2017 DENX Software Engineering
+ *
+ * Anatolij Gustschin <agust@denx.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * Manage Altera FPGA firmware using PCIe CvP.
+ * Firmware must be in binary "rbf" format.
+ */
+
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/fpga/fpga-mgr.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/sizes.h>
+
+#define CVP_BAR		0	/* BAR used for data transfer in memory mode */
+#define CVP_DUMMY_WR	244	/* dummy writes to clear CvP state machine */
+#define TIMEOUT_US	2000	/* CVP STATUS timeout for USERMODE polling */
+
+/* Vendor Specific Extended Capability Registers */
+#define VSE_PCIE_EXT_CAP_ID		0x200
+#define VSE_PCIE_EXT_CAP_ID_VAL		0x000b	/* 16bit */
+
+#define VSE_CVP_STATUS			0x21c	/* 32bit */
+#define VSE_CVP_STATUS_CFG_RDY		BIT(18)	/* CVP_CONFIG_READY */
+#define VSE_CVP_STATUS_CFG_ERR		BIT(19)	/* CVP_CONFIG_ERROR */
+#define VSE_CVP_STATUS_CVP_EN		BIT(20)	/* ctrl block is enabling CVP */
+#define VSE_CVP_STATUS_USERMODE		BIT(21)	/* USERMODE */
+#define VSE_CVP_STATUS_CFG_DONE		BIT(23)	/* CVP_CONFIG_DONE */
+#define VSE_CVP_STATUS_PLD_CLK_IN_USE	BIT(24)	/* PLD_CLK_IN_USE */
+
+#define VSE_CVP_MODE_CTRL		0x220	/* 32bit */
+#define VSE_CVP_MODE_CTRL_CVP_MODE	BIT(0)	/* CVP (1) or normal mode (0) */
+#define VSE_CVP_MODE_CTRL_HIP_CLK_SEL	BIT(1) /* PMA (1) or fabric clock (0) */
+#define VSE_CVP_MODE_CTRL_NUMCLKS_OFF	8	/* NUMCLKS bits offset */
+#define VSE_CVP_MODE_CTRL_NUMCLKS_MASK	GENMASK(15, 8)
+
+#define VSE_CVP_DATA			0x228	/* 32bit */
+#define VSE_CVP_PROG_CTRL		0x22c	/* 32bit */
+#define VSE_CVP_PROG_CTRL_CONFIG	BIT(0)
+#define VSE_CVP_PROG_CTRL_START_XFER	BIT(1)
+
+#define VSE_UNCOR_ERR_STATUS		0x234	/* 32bit */
+#define VSE_UNCOR_ERR_CVP_CFG_ERR	BIT(5)	/* CVP_CONFIG_ERROR_LATCHED */
+
+#define DRV_NAME		"altera-cvp"
+#define ALTERA_CVP_MGR_NAME	"Altera CvP FPGA Manager"
+
+/* Optional CvP config error status check for debugging */
+static bool altera_cvp_chkcfg;
+
+struct altera_cvp_conf {
+	struct fpga_manager	*mgr;
+	struct pci_dev		*pci_dev;
+	void __iomem		*map;
+	void			(*write_data)(struct altera_cvp_conf *, u32);
+	char			mgr_name[64];
+	u8			numclks;
+};
+
+static enum fpga_mgr_states altera_cvp_state(struct fpga_manager *mgr)
+{
+	struct altera_cvp_conf *conf = mgr->priv;
+	u32 status;
+
+	pci_read_config_dword(conf->pci_dev, VSE_CVP_STATUS, &status);
+
+	if (status & VSE_CVP_STATUS_CFG_DONE)
+		return FPGA_MGR_STATE_OPERATING;
+
+	if (status & VSE_CVP_STATUS_CVP_EN)
+		return FPGA_MGR_STATE_POWER_UP;
+
+	return FPGA_MGR_STATE_UNKNOWN;
+}
+
+static void altera_cvp_write_data_iomem(struct altera_cvp_conf *conf, u32 val)
+{
+	writel(val, conf->map);
+}
+
+static void altera_cvp_write_data_config(struct altera_cvp_conf *conf, u32 val)
+{
+	pci_write_config_dword(conf->pci_dev, VSE_CVP_DATA, val);
+}
+
+/* switches between CvP clock and internal clock */
+static void altera_cvp_dummy_write(struct altera_cvp_conf *conf)
+{
+	unsigned int i;
+	u32 val;
+
+	/* set 1 CVP clock cycle for every CVP Data Register Write */
+	pci_read_config_dword(conf->pci_dev, VSE_CVP_MODE_CTRL, &val);
+	val &= ~VSE_CVP_MODE_CTRL_NUMCLKS_MASK;
+	val |= 1 << VSE_CVP_MODE_CTRL_NUMCLKS_OFF;
+	pci_write_config_dword(conf->pci_dev, VSE_CVP_MODE_CTRL, val);
+
+	for (i = 0; i < CVP_DUMMY_WR; i++)
+		conf->write_data(conf, 0); /* dummy data, could be any value */
+}
+
+static int altera_cvp_wait_status(struct altera_cvp_conf *conf, u32 status_mask,
+				  u32 status_val, int timeout_us)
+{
+	unsigned int retries;
+	u32 val;
+
+	retries = timeout_us / 10;
+	if (timeout_us % 10)
+		retries++;
+
+	do {
+		pci_read_config_dword(conf->pci_dev, VSE_CVP_STATUS, &val);
+		if ((val & status_mask) == status_val)
+			return 0;
+
+		/* use small usleep value to re-check and break early */
+		usleep_range(10, 11);
+	} while (--retries);
+
+	return -ETIMEDOUT;
+}
+
+static int altera_cvp_teardown(struct fpga_manager *mgr,
+			       struct fpga_image_info *info)
+{
+	struct altera_cvp_conf *conf = mgr->priv;
+	struct pci_dev *pdev = conf->pci_dev;
+	int ret;
+	u32 val;
+
+	/* STEP 12 - reset START_XFER bit */
+	pci_read_config_dword(pdev, VSE_CVP_PROG_CTRL, &val);
+	val &= ~VSE_CVP_PROG_CTRL_START_XFER;
+	pci_write_config_dword(pdev, VSE_CVP_PROG_CTRL, val);
+
+	/* STEP 13 - reset CVP_CONFIG bit */
+	val &= ~VSE_CVP_PROG_CTRL_CONFIG;
+	pci_write_config_dword(pdev, VSE_CVP_PROG_CTRL, val);
+
+	/*
+	 * STEP 14
+	 * - set CVP_NUMCLKS to 1 and then issue CVP_DUMMY_WR dummy
+	 *   writes to the HIP
+	 */
+	altera_cvp_dummy_write(conf); /* from CVP clock to internal clock */
+
+	/* STEP 15 - poll CVP_CONFIG_READY bit for 0 with 10us timeout */
+	ret = altera_cvp_wait_status(conf, VSE_CVP_STATUS_CFG_RDY, 0, 10);
+	if (ret)
+		dev_err(&mgr->dev, "CFG_RDY == 0 timeout\n");
+
+	return ret;
+}
+
+static int altera_cvp_write_init(struct fpga_manager *mgr,
+				 struct fpga_image_info *info,
+				 const char *buf, size_t count)
+{
+	struct altera_cvp_conf *conf = mgr->priv;
+	struct pci_dev *pdev = conf->pci_dev;
+	u32 iflags, val;
+	int ret;
+
+	iflags = info ? info->flags : 0;
+
+	if (iflags & FPGA_MGR_PARTIAL_RECONFIG) {
+		dev_err(&mgr->dev, "Partial reconfiguration not supported.\n");
+		return -EINVAL;
+	}
+
+	/* Determine allowed clock to data ratio */
+	if (iflags & FPGA_MGR_COMPRESSED_BITSTREAM)
+		conf->numclks = 8; /* ratio for all compressed images */
+	else if (iflags & FPGA_MGR_ENCRYPTED_BITSTREAM)
+		conf->numclks = 4; /* for uncompressed and encrypted images */
+	else
+		conf->numclks = 1; /* for uncompressed and unencrypted images */
+
+	/* STEP 1 - read CVP status and check CVP_EN flag */
+	pci_read_config_dword(pdev, VSE_CVP_STATUS, &val);
+	if (!(val & VSE_CVP_STATUS_CVP_EN)) {
+		dev_err(&mgr->dev, "CVP mode off: 0x%04x\n", val);
+		return -ENODEV;
+	}
+
+	if (val & VSE_CVP_STATUS_CFG_RDY) {
+		dev_warn(&mgr->dev, "CvP already started, teardown first\n");
+		ret = altera_cvp_teardown(mgr, info);
+		if (ret)
+			return ret;
+	}
+
+	/*
+	 * STEP 2
+	 * - set HIP_CLK_SEL and CVP_MODE (must be set in the order mentioned)
+	 */
+	/* switch from fabric to PMA clock */
+	pci_read_config_dword(pdev, VSE_CVP_MODE_CTRL, &val);
+	val |= VSE_CVP_MODE_CTRL_HIP_CLK_SEL;
+	pci_write_config_dword(pdev, VSE_CVP_MODE_CTRL, val);
+
+	/* set CVP mode */
+	pci_read_config_dword(pdev, VSE_CVP_MODE_CTRL, &val);
+	val |= VSE_CVP_MODE_CTRL_CVP_MODE;
+	pci_write_config_dword(pdev, VSE_CVP_MODE_CTRL, val);
+
+	/*
+	 * STEP 3
+	 * - set CVP_NUMCLKS to 1 and issue CVP_DUMMY_WR dummy writes to the HIP
+	 */
+	altera_cvp_dummy_write(conf);
+
+	/* STEP 4 - set CVP_CONFIG bit */
+	pci_read_config_dword(pdev, VSE_CVP_PROG_CTRL, &val);
+	/* request control block to begin transfer using CVP */
+	val |= VSE_CVP_PROG_CTRL_CONFIG;
+	pci_write_config_dword(pdev, VSE_CVP_PROG_CTRL, val);
+
+	/* STEP 5 - poll CVP_CONFIG READY for 1 with 10us timeout */
+	ret = altera_cvp_wait_status(conf, VSE_CVP_STATUS_CFG_RDY,
+				     VSE_CVP_STATUS_CFG_RDY, 10);
+	if (ret) {
+		dev_warn(&mgr->dev, "CFG_RDY == 1 timeout\n");
+		return ret;
+	}
+
+	/*
+	 * STEP 6
+	 * - set CVP_NUMCLKS to 1 and issue CVP_DUMMY_WR dummy writes to the HIP
+	 */
+	altera_cvp_dummy_write(conf);
+
+	/* STEP 7 - set START_XFER */
+	pci_read_config_dword(pdev, VSE_CVP_PROG_CTRL, &val);
+	val |= VSE_CVP_PROG_CTRL_START_XFER;
+	pci_write_config_dword(pdev, VSE_CVP_PROG_CTRL, val);
+
+	/* STEP 8 - start transfer (set CVP_NUMCLKS for bitstream) */
+	pci_read_config_dword(pdev, VSE_CVP_MODE_CTRL, &val);
+	val &= ~VSE_CVP_MODE_CTRL_NUMCLKS_MASK;
+	val |= conf->numclks << VSE_CVP_MODE_CTRL_NUMCLKS_OFF;
+	pci_write_config_dword(pdev, VSE_CVP_MODE_CTRL, val);
+
+	return 0;
+}
+
+static inline int altera_cvp_chk_error(struct fpga_manager *mgr, size_t bytes)
+{
+	struct altera_cvp_conf *conf = mgr->priv;
+	u32 val;
+
+	/* STEP 10 (optional) - check CVP_CONFIG_ERROR flag */
+	pci_read_config_dword(conf->pci_dev, VSE_CVP_STATUS, &val);
+	if (val & VSE_CVP_STATUS_CFG_ERR) {
+		dev_err(&mgr->dev, "CVP_CONFIG_ERROR after %zu bytes!\n",
+			bytes);
+		return -EPROTO;
+	}
+	return 0;
+}
+
+static int altera_cvp_write(struct fpga_manager *mgr, const char *buf,
+			    size_t count)
+{
+	struct altera_cvp_conf *conf = mgr->priv;
+	const u32 *data;
+	size_t done, remaining;
+	int status = 0;
+	u32 mask;
+
+	/* STEP 9 - write 32-bit data from RBF file to CVP data register */
+	data = (u32 *)buf;
+	remaining = count;
+	done = 0;
+
+	while (remaining >= 4) {
+		conf->write_data(conf, *data++);
+		done += 4;
+		remaining -= 4;
+
+		/*
+		 * STEP 10 (optional) and STEP 11
+		 * - check error flag
+		 * - loop until data transfer completed
+		 * Config images can be huge (more than 40 MiB), so
+		 * only check after a new 4k data block has been written.
+		 * This reduces the number of checks and speeds up the
+		 * configuration process.
+		 */
+		if (altera_cvp_chkcfg && !(done % SZ_4K)) {
+			status = altera_cvp_chk_error(mgr, done);
+			if (status < 0)
+				return status;
+		}
+	}
+
+	/* write up to 3 trailing bytes, if any */
+	mask = BIT(remaining * 8) - 1;
+	if (mask)
+		conf->write_data(conf, *data & mask);
+
+	if (altera_cvp_chkcfg)
+		status = altera_cvp_chk_error(mgr, count);
+
+	return status;
+}
+
+static int altera_cvp_write_complete(struct fpga_manager *mgr,
+				     struct fpga_image_info *info)
+{
+	struct altera_cvp_conf *conf = mgr->priv;
+	struct pci_dev *pdev = conf->pci_dev;
+	int ret;
+	u32 mask;
+	u32 val;
+
+	ret = altera_cvp_teardown(mgr, info);
+	if (ret)
+		return ret;
+
+	/* STEP 16 - check CVP_CONFIG_ERROR_LATCHED bit */
+	pci_read_config_dword(pdev, VSE_UNCOR_ERR_STATUS, &val);
+	if (val & VSE_UNCOR_ERR_CVP_CFG_ERR) {
+		dev_err(&mgr->dev, "detected CVP_CONFIG_ERROR_LATCHED!\n");
+		return -EPROTO;
+	}
+
+	/* STEP 17 - reset CVP_MODE and HIP_CLK_SEL bit */
+	pci_read_config_dword(pdev, VSE_CVP_MODE_CTRL, &val);
+	val &= ~VSE_CVP_MODE_CTRL_HIP_CLK_SEL;
+	val &= ~VSE_CVP_MODE_CTRL_CVP_MODE;
+	pci_write_config_dword(pdev, VSE_CVP_MODE_CTRL, val);
+
+	/* STEP 18 - poll PLD_CLK_IN_USE and USER_MODE bits */
+	mask = VSE_CVP_STATUS_PLD_CLK_IN_USE | VSE_CVP_STATUS_USERMODE;
+	ret = altera_cvp_wait_status(conf, mask, mask, TIMEOUT_US);
+	if (ret)
+		dev_err(&mgr->dev, "PLD_CLK_IN_USE|USERMODE timeout\n");
+
+	return ret;
+}
+
+static const struct fpga_manager_ops altera_cvp_ops = {
+	.state		= altera_cvp_state,
+	.write_init	= altera_cvp_write_init,
+	.write		= altera_cvp_write,
+	.write_complete	= altera_cvp_write_complete,
+};
+
+static ssize_t show_chkcfg(struct device_driver *dev, char *buf)
+{
+	return snprintf(buf, 3, "%d\n", altera_cvp_chkcfg);
+}
+
+static ssize_t store_chkcfg(struct device_driver *drv, const char *buf,
+			    size_t count)
+{
+	int ret;
+
+	ret = kstrtobool(buf, &altera_cvp_chkcfg);
+	if (ret)
+		return ret;
+
+	return count;
+}
+
+static DRIVER_ATTR(chkcfg, 0600, show_chkcfg, store_chkcfg);
+
+static int altera_cvp_probe(struct pci_dev *pdev,
+			    const struct pci_device_id *dev_id);
+static void altera_cvp_remove(struct pci_dev *pdev);
+
+#define PCI_VENDOR_ID_ALTERA	0x1172
+
+static struct pci_device_id altera_cvp_id_tbl[] = {
+	{ PCI_VDEVICE(ALTERA, PCI_ANY_ID) },
+	{ }
+};
+MODULE_DEVICE_TABLE(pci, altera_cvp_id_tbl);
+
+static struct pci_driver altera_cvp_driver = {
+	.name   = DRV_NAME,
+	.id_table = altera_cvp_id_tbl,
+	.probe  = altera_cvp_probe,
+	.remove = altera_cvp_remove,
+};
+
+static int altera_cvp_probe(struct pci_dev *pdev,
+			    const struct pci_device_id *dev_id)
+{
+	struct altera_cvp_conf *conf;
+	u16 cmd, val;
+	int ret;
+
+	/*
+	 * First check if this is the expected FPGA device. PCI config
+	 * space access works without enabling the PCI device, memory
+	 * space access is enabled further down.
+	 */
+	pci_read_config_word(pdev, VSE_PCIE_EXT_CAP_ID, &val);
+	if (val != VSE_PCIE_EXT_CAP_ID_VAL) {
+		dev_err(&pdev->dev, "Wrong EXT_CAP_ID value 0x%x\n", val);
+		return -ENODEV;
+	}
+
+	conf = devm_kzalloc(&pdev->dev, sizeof(*conf), GFP_KERNEL);
+	if (!conf)
+		return -ENOMEM;
+
+	/*
+	 * Enable memory BAR access. We cannot use pci_enable_device() here
+	 * because it will make the driver unusable with FPGA devices that
+	 * have additional big IOMEM resources (e.g. 4GiB BARs) on 32-bit
+	 * platform. Such BARs will not have an assigned address range and
+	 * pci_enable_device() will fail, complaining about not claimed BAR,
+	 * even if the concerned BAR is not needed for FPGA configuration
+	 * at all. Thus, enable the device via PCI config space command.
+	 */
+	pci_read_config_word(pdev, PCI_COMMAND, &cmd);
+	if (!(cmd & PCI_COMMAND_MEMORY)) {
+		cmd |= PCI_COMMAND_MEMORY;
+		pci_write_config_word(pdev, PCI_COMMAND, cmd);
+	}
+
+	ret = pci_request_region(pdev, CVP_BAR, "CVP");
+	if (ret) {
+		dev_err(&pdev->dev, "Requesting CVP BAR region failed\n");
+		goto err_disable;
+	}
+
+	conf->pci_dev = pdev;
+	conf->write_data = altera_cvp_write_data_iomem;
+
+	conf->map = pci_iomap(pdev, CVP_BAR, 0);
+	if (!conf->map) {
+		dev_warn(&pdev->dev, "Mapping CVP BAR failed\n");
+		conf->write_data = altera_cvp_write_data_config;
+	}
+
+	snprintf(conf->mgr_name, sizeof(conf->mgr_name), "%s @%s",
+		 ALTERA_CVP_MGR_NAME, pci_name(pdev));
+
+	ret = fpga_mgr_register(&pdev->dev, conf->mgr_name,
+				&altera_cvp_ops, conf);
+	if (ret)
+		goto err_unmap;
+
+	ret = driver_create_file(&altera_cvp_driver.driver,
+				 &driver_attr_chkcfg);
+	if (ret) {
+		dev_err(&pdev->dev, "Can't create sysfs chkcfg file\n");
+		fpga_mgr_unregister(&pdev->dev);
+		goto err_unmap;
+	}
+
+	return 0;
+
+err_unmap:
+	pci_iounmap(pdev, conf->map);
+	pci_release_region(pdev, CVP_BAR);
+err_disable:
+	cmd &= ~PCI_COMMAND_MEMORY;
+	pci_write_config_word(pdev, PCI_COMMAND, cmd);
+	return ret;
+}
+
+static void altera_cvp_remove(struct pci_dev *pdev)
+{
+	struct fpga_manager *mgr = pci_get_drvdata(pdev);
+	struct altera_cvp_conf *conf = mgr->priv;
+	u16 cmd;
+
+	driver_remove_file(&altera_cvp_driver.driver, &driver_attr_chkcfg);
+	fpga_mgr_unregister(&pdev->dev);
+	pci_iounmap(pdev, conf->map);
+	pci_release_region(pdev, CVP_BAR);
+	pci_read_config_word(pdev, PCI_COMMAND, &cmd);
+	cmd &= ~PCI_COMMAND_MEMORY;
+	pci_write_config_word(pdev, PCI_COMMAND, cmd);
+}
+
+module_pci_driver(altera_cvp_driver);
+
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Anatolij Gustschin <agust@denx.de>");
+MODULE_DESCRIPTION("Module to load Altera FPGA over CvP");
