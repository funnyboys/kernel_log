commit ac2ae48efad76e524cb77934ae5c5649520f0037
Author: Alexandre Belloni <alexandre.belloni@bootlin.com>
Date:   Tue Apr 9 21:59:45 2019 +0200

    rtc: ab3100: convert to SPDX identifier
    
    Use SPDX-License-Identifier instead of the custom license line.
    
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@bootlin.com>

diff --git a/drivers/rtc/rtc-ab3100.c b/drivers/rtc/rtc-ab3100.c
index ecf3f1494c13..2ed6def90975 100644
--- a/drivers/rtc/rtc-ab3100.c
+++ b/drivers/rtc/rtc-ab3100.c
@@ -1,6 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Copyright (C) 2007-2009 ST-Ericsson AB
- * License terms: GNU General Public License (GPL) version 2
  * RTC clock driver for the AB3100 Analog Baseband Chip
  * Author: Linus Walleij <linus.walleij@stericsson.com>
  */

commit 0dca027bb859e42feac3a196a14c81fee34d9824
Author: Alexandre Belloni <alexandre.belloni@bootlin.com>
Date:   Tue Apr 9 21:59:44 2019 +0200

    rtc: ab3100: use .set_time
    
    Use .set_time instead of the deprecated .set_mmss64.
    
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@bootlin.com>

diff --git a/drivers/rtc/rtc-ab3100.c b/drivers/rtc/rtc-ab3100.c
index f73a3707b897..ecf3f1494c13 100644
--- a/drivers/rtc/rtc-ab3100.c
+++ b/drivers/rtc/rtc-ab3100.c
@@ -43,12 +43,12 @@
 /*
  * RTC clock functions and device struct declaration
  */
-static int ab3100_rtc_set_mmss(struct device *dev, time64_t secs)
+static int ab3100_rtc_set_time(struct device *dev, struct rtc_time *tm)
 {
 	u8 regs[] = {AB3100_TI0, AB3100_TI1, AB3100_TI2,
 		     AB3100_TI3, AB3100_TI4, AB3100_TI5};
 	unsigned char buf[6];
-	u64 hw_counter = secs * AB3100_RTC_CLOCK_RATE * 2;
+	u64 hw_counter = rtc_tm_to_time64(tm) * AB3100_RTC_CLOCK_RATE * 2;
 	int err = 0;
 	int i;
 
@@ -192,7 +192,7 @@ static int ab3100_rtc_irq_enable(struct device *dev, unsigned int enabled)
 
 static const struct rtc_class_ops ab3100_rtc_ops = {
 	.read_time	= ab3100_rtc_read_time,
-	.set_mmss64	= ab3100_rtc_set_mmss,
+	.set_time	= ab3100_rtc_set_time,
 	.read_alarm	= ab3100_rtc_read_alarm,
 	.set_alarm	= ab3100_rtc_set_alarm,
 	.alarm_irq_enable = ab3100_rtc_irq_enable,

commit 386b5941a0dd18dda24b459a421ddc51d5fb0371
Author: Alexandre Belloni <alexandre.belloni@bootlin.com>
Date:   Tue Apr 9 21:59:43 2019 +0200

    rtc: ab3100: set range
    
    The ab3100 has a 48bit counter running at 65536 Hz (despite one of the
    comment). The max value is then (2^48 - 1)/2^16 == 2^32 - 1.
    
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@bootlin.com>

diff --git a/drivers/rtc/rtc-ab3100.c b/drivers/rtc/rtc-ab3100.c
index 821ff52a2222..f73a3707b897 100644
--- a/drivers/rtc/rtc-ab3100.c
+++ b/drivers/rtc/rtc-ab3100.c
@@ -228,15 +228,17 @@ static int __init ab3100_rtc_probe(struct platform_device *pdev)
 		/* Ignore any error on this write */
 	}
 
-	rtc = devm_rtc_device_register(&pdev->dev, "ab3100-rtc",
-					&ab3100_rtc_ops, THIS_MODULE);
-	if (IS_ERR(rtc)) {
-		err = PTR_ERR(rtc);
-		return err;
-	}
+	rtc = devm_rtc_allocate_device(&pdev->dev);
+	if (IS_ERR(rtc))
+		return PTR_ERR(rtc);
+
+	rtc->ops = &ab3100_rtc_ops;
+	/* 48bit counter at (AB3100_RTC_CLOCK_RATE * 2) */
+	rtc->range_max = U32_MAX;
+
 	platform_set_drvdata(pdev, rtc);
 
-	return 0;
+	return rtc_register_device(rtc);
 }
 
 static struct platform_driver ab3100_rtc_driver = {

commit 146d21bd9dc167d75bed4c0fdfe790db7565e99b
Author: Alexandre Belloni <alexandre.belloni@bootlin.com>
Date:   Mon Feb 19 16:23:55 2018 +0100

    rtc: stop validating rtc_time after rtc_time64_to_tm
    
    rtc_time64_to_tm never generates an invalid tm. It is not necessary to
    validate it.
    
    Signed-off-by: Alexandre Belloni <alexandre.belloni@bootlin.com>

diff --git a/drivers/rtc/rtc-ab3100.c b/drivers/rtc/rtc-ab3100.c
index 9b725c553058..821ff52a2222 100644
--- a/drivers/rtc/rtc-ab3100.c
+++ b/drivers/rtc/rtc-ab3100.c
@@ -106,7 +106,7 @@ static int ab3100_rtc_read_time(struct device *dev, struct rtc_time *tm)
 
 	rtc_time64_to_tm(time, tm);
 
-	return rtc_valid_tm(tm);
+	return 0;
 }
 
 static int ab3100_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alarm)

commit 5c7e11bc66647f2e4bc95de9b4302fff6d612f3a
Author: Xunlei Pang <pang.xunlei@linaro.org>
Date:   Wed Apr 1 20:34:29 2015 -0700

    drivers/rtc/ab3100: Update driver to address y2038/y2106 issues
    
    This driver has a number of y2038/y2106 issues.
    
    This patch resolves them by:
    
      - Replacing rtc_tm_to_time() with rtc_tm_to_time64()
      - Replacing rtc_time_to_tm() with rtc_time64_to_tm()
      - Changing ab3100_rtc_set_mmss() to use rtc_class_ops's set_mmss64()
    
    After this patch, the driver should not have any remaining
    y2038/y2106 issues.
    
    Signed-off-by: Xunlei Pang <pang.xunlei@linaro.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Acked-by: Alessandro Zummo <a.zummo@towertech.it>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/1427945681-29972-10-git-send-email-john.stultz@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/rtc/rtc-ab3100.c b/drivers/rtc/rtc-ab3100.c
index 1d0340fdb820..9b725c553058 100644
--- a/drivers/rtc/rtc-ab3100.c
+++ b/drivers/rtc/rtc-ab3100.c
@@ -43,21 +43,21 @@
 /*
  * RTC clock functions and device struct declaration
  */
-static int ab3100_rtc_set_mmss(struct device *dev, unsigned long secs)
+static int ab3100_rtc_set_mmss(struct device *dev, time64_t secs)
 {
 	u8 regs[] = {AB3100_TI0, AB3100_TI1, AB3100_TI2,
 		     AB3100_TI3, AB3100_TI4, AB3100_TI5};
 	unsigned char buf[6];
-	u64 fat_time = (u64) secs * AB3100_RTC_CLOCK_RATE * 2;
+	u64 hw_counter = secs * AB3100_RTC_CLOCK_RATE * 2;
 	int err = 0;
 	int i;
 
-	buf[0] = (fat_time) & 0xFF;
-	buf[1] = (fat_time >> 8) & 0xFF;
-	buf[2] = (fat_time >> 16) & 0xFF;
-	buf[3] = (fat_time >> 24) & 0xFF;
-	buf[4] = (fat_time >> 32) & 0xFF;
-	buf[5] = (fat_time >> 40) & 0xFF;
+	buf[0] = (hw_counter) & 0xFF;
+	buf[1] = (hw_counter >> 8) & 0xFF;
+	buf[2] = (hw_counter >> 16) & 0xFF;
+	buf[3] = (hw_counter >> 24) & 0xFF;
+	buf[4] = (hw_counter >> 32) & 0xFF;
+	buf[5] = (hw_counter >> 40) & 0xFF;
 
 	for (i = 0; i < 6; i++) {
 		err = abx500_set_register_interruptible(dev, 0,
@@ -75,7 +75,7 @@ static int ab3100_rtc_set_mmss(struct device *dev, unsigned long secs)
 
 static int ab3100_rtc_read_time(struct device *dev, struct rtc_time *tm)
 {
-	unsigned long time;
+	time64_t time;
 	u8 rtcval;
 	int err;
 
@@ -88,7 +88,7 @@ static int ab3100_rtc_read_time(struct device *dev, struct rtc_time *tm)
 		dev_info(dev, "clock not set (lost power)");
 		return -EINVAL;
 	} else {
-		u64 fat_time;
+		u64 hw_counter;
 		u8 buf[6];
 
 		/* Read out time registers */
@@ -98,22 +98,21 @@ static int ab3100_rtc_read_time(struct device *dev, struct rtc_time *tm)
 		if (err != 0)
 			return err;
 
-		fat_time = ((u64) buf[5] << 40) | ((u64) buf[4] << 32) |
+		hw_counter = ((u64) buf[5] << 40) | ((u64) buf[4] << 32) |
 			((u64) buf[3] << 24) | ((u64) buf[2] << 16) |
 			((u64) buf[1] << 8) | (u64) buf[0];
-		time = (unsigned long) (fat_time /
-					(u64) (AB3100_RTC_CLOCK_RATE * 2));
+		time = hw_counter / (u64) (AB3100_RTC_CLOCK_RATE * 2);
 	}
 
-	rtc_time_to_tm(time, tm);
+	rtc_time64_to_tm(time, tm);
 
 	return rtc_valid_tm(tm);
 }
 
 static int ab3100_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alarm)
 {
-	unsigned long time;
-	u64 fat_time;
+	time64_t time;
+	u64 hw_counter;
 	u8 buf[6];
 	u8 rtcval;
 	int err;
@@ -134,11 +133,11 @@ static int ab3100_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alarm)
 						     AB3100_AL0, buf, 4);
 	if (err)
 		return err;
-	fat_time = ((u64) buf[3] << 40) | ((u64) buf[2] << 32) |
+	hw_counter = ((u64) buf[3] << 40) | ((u64) buf[2] << 32) |
 		((u64) buf[1] << 24) | ((u64) buf[0] << 16);
-	time = (unsigned long) (fat_time / (u64) (AB3100_RTC_CLOCK_RATE * 2));
+	time = hw_counter / (u64) (AB3100_RTC_CLOCK_RATE * 2);
 
-	rtc_time_to_tm(time, &alarm->time);
+	rtc_time64_to_tm(time, &alarm->time);
 
 	return rtc_valid_tm(&alarm->time);
 }
@@ -147,17 +146,17 @@ static int ab3100_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alarm)
 {
 	u8 regs[] = {AB3100_AL0, AB3100_AL1, AB3100_AL2, AB3100_AL3};
 	unsigned char buf[4];
-	unsigned long secs;
-	u64 fat_time;
+	time64_t secs;
+	u64 hw_counter;
 	int err;
 	int i;
 
-	rtc_tm_to_time(&alarm->time, &secs);
-	fat_time = (u64) secs * AB3100_RTC_CLOCK_RATE * 2;
-	buf[0] = (fat_time >> 16) & 0xFF;
-	buf[1] = (fat_time >> 24) & 0xFF;
-	buf[2] = (fat_time >> 32) & 0xFF;
-	buf[3] = (fat_time >> 40) & 0xFF;
+	secs = rtc_tm_to_time64(&alarm->time);
+	hw_counter = secs * AB3100_RTC_CLOCK_RATE * 2;
+	buf[0] = (hw_counter >> 16) & 0xFF;
+	buf[1] = (hw_counter >> 24) & 0xFF;
+	buf[2] = (hw_counter >> 32) & 0xFF;
+	buf[3] = (hw_counter >> 40) & 0xFF;
 
 	/* Set the alarm */
 	for (i = 0; i < 4; i++) {
@@ -193,7 +192,7 @@ static int ab3100_rtc_irq_enable(struct device *dev, unsigned int enabled)
 
 static const struct rtc_class_ops ab3100_rtc_ops = {
 	.read_time	= ab3100_rtc_read_time,
-	.set_mmss	= ab3100_rtc_set_mmss,
+	.set_mmss64	= ab3100_rtc_set_mmss,
 	.read_alarm	= ab3100_rtc_read_alarm,
 	.set_alarm	= ab3100_rtc_set_alarm,
 	.alarm_irq_enable = ab3100_rtc_irq_enable,

commit 0929ae376ef32591a5f13870a703efc2901bfab9
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Mon Oct 20 16:21:31 2014 +0200

    rtc: drop owner assignment from platform_drivers
    
    A platform_driver does not need to set an owner, it will be populated by the
    driver core.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/rtc/rtc-ab3100.c b/drivers/rtc/rtc-ab3100.c
index ff435343ba9f..1d0340fdb820 100644
--- a/drivers/rtc/rtc-ab3100.c
+++ b/drivers/rtc/rtc-ab3100.c
@@ -243,7 +243,6 @@ static int __init ab3100_rtc_probe(struct platform_device *pdev)
 static struct platform_driver ab3100_rtc_driver = {
 	.driver = {
 		.name = "ab3100-rtc",
-		.owner = THIS_MODULE,
 	},
 };
 

commit a2c0b85945e75901906d0aa82ef9a0bea96f85ce
Author: Sachin Kamat <sachin.kamat@linaro.org>
Date:   Wed Jul 3 15:06:59 2013 -0700

    drivers/rtc/rtc-ab3100.c: remove empty function
    
    After the switch to devm_ functions and the removal of
    rtc_device_unregister(), the 'remove' function does not do anything.
    Delete it.
    
    Signed-off-by: Sachin Kamat <sachin.kamat@linaro.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/rtc/rtc-ab3100.c b/drivers/rtc/rtc-ab3100.c
index 572208d67688..ff435343ba9f 100644
--- a/drivers/rtc/rtc-ab3100.c
+++ b/drivers/rtc/rtc-ab3100.c
@@ -240,17 +240,11 @@ static int __init ab3100_rtc_probe(struct platform_device *pdev)
 	return 0;
 }
 
-static int __exit ab3100_rtc_remove(struct platform_device *pdev)
-{
-	return 0;
-}
-
 static struct platform_driver ab3100_rtc_driver = {
 	.driver = {
 		.name = "ab3100-rtc",
 		.owner = THIS_MODULE,
 	},
-	.remove	 = __exit_p(ab3100_rtc_remove),
 };
 
 module_platform_driver_probe(ab3100_rtc_driver, ab3100_rtc_probe);

commit 0ffb0c065707123ae19b3a8b37a3662261c421b5
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Wed Jul 3 15:06:09 2013 -0700

    rtc: rtc-ab3100: remove unnecessary platform_set_drvdata()
    
    The driver core clears the driver data to NULL after device_release or
    on probe failure, since commit 0998d063100 ("device-core: Ensure drvdata
    = NULL when no driver is bound").  Thus, it is not needed to manually
    clear the device driver data to NULL.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Cc: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/rtc/rtc-ab3100.c b/drivers/rtc/rtc-ab3100.c
index 47a4f2c4d30e..572208d67688 100644
--- a/drivers/rtc/rtc-ab3100.c
+++ b/drivers/rtc/rtc-ab3100.c
@@ -242,7 +242,6 @@ static int __init ab3100_rtc_probe(struct platform_device *pdev)
 
 static int __exit ab3100_rtc_remove(struct platform_device *pdev)
 {
-	platform_set_drvdata(pdev, NULL);
 	return 0;
 }
 

commit ef886c4d75f0872424f61815662dd37e84b2d34e
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Mon Apr 29 16:19:30 2013 -0700

    rtc: rtc-ab3100: use devm_rtc_device_register()
    
    devm_rtc_device_register() is device managed and makes cleanup paths
    simpler.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/rtc/rtc-ab3100.c b/drivers/rtc/rtc-ab3100.c
index c2f12d370009..47a4f2c4d30e 100644
--- a/drivers/rtc/rtc-ab3100.c
+++ b/drivers/rtc/rtc-ab3100.c
@@ -229,8 +229,8 @@ static int __init ab3100_rtc_probe(struct platform_device *pdev)
 		/* Ignore any error on this write */
 	}
 
-	rtc = rtc_device_register("ab3100-rtc", &pdev->dev, &ab3100_rtc_ops,
-				  THIS_MODULE);
+	rtc = devm_rtc_device_register(&pdev->dev, "ab3100-rtc",
+					&ab3100_rtc_ops, THIS_MODULE);
 	if (IS_ERR(rtc)) {
 		err = PTR_ERR(rtc);
 		return err;
@@ -242,9 +242,6 @@ static int __init ab3100_rtc_probe(struct platform_device *pdev)
 
 static int __exit ab3100_rtc_remove(struct platform_device *pdev)
 {
-	struct rtc_device *rtc = platform_get_drvdata(pdev);
-
-	rtc_device_unregister(rtc);
 	platform_set_drvdata(pdev, NULL);
 	return 0;
 }

commit fb34a8120446593d24dcd29e0b2c7bdac8e8ac6a
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Mon Apr 29 16:18:34 2013 -0700

    rtc: rtc-ab3100: use module_platform_driver_probe()
    
    Use module_platform_driver_probe() macro which makes the code smaller and
    simpler.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/rtc/rtc-ab3100.c b/drivers/rtc/rtc-ab3100.c
index 261a07e0fb24..c2f12d370009 100644
--- a/drivers/rtc/rtc-ab3100.c
+++ b/drivers/rtc/rtc-ab3100.c
@@ -257,19 +257,7 @@ static struct platform_driver ab3100_rtc_driver = {
 	.remove	 = __exit_p(ab3100_rtc_remove),
 };
 
-static int __init ab3100_rtc_init(void)
-{
-	return platform_driver_probe(&ab3100_rtc_driver,
-				     ab3100_rtc_probe);
-}
-
-static void __exit ab3100_rtc_exit(void)
-{
-	platform_driver_unregister(&ab3100_rtc_driver);
-}
-
-module_init(ab3100_rtc_init);
-module_exit(ab3100_rtc_exit);
+module_platform_driver_probe(ab3100_rtc_driver, ab3100_rtc_probe);
 
 MODULE_AUTHOR("Linus Walleij <linus.walleij@stericsson.com>");
 MODULE_DESCRIPTION("AB3100 RTC Driver");

commit eba93fcc34d6c4387ce8fbb53bb7b685f91f3343
Author: Axel Lin <axel.lin@gmail.com>
Date:   Wed Sep 22 13:04:59 2010 -0700

    drivers/rtc/rtc-ab3100.c: add missing platform_set_drvdata() in ab3100_rtc_probe()
    
    Otherwise, calling platform_get_drvdata() in ab3100_rtc_remove() returns
    NULL.
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Acked-by:Wan ZongShun <mcuos.com@gmail.com>
    Acked-by: Linus Walleij <linus.walleij@stericsson.com>
    Cc: Alessandro Zummo <a.zummo@towertech.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/rtc/rtc-ab3100.c b/drivers/rtc/rtc-ab3100.c
index d26780ea254b..261a07e0fb24 100644
--- a/drivers/rtc/rtc-ab3100.c
+++ b/drivers/rtc/rtc-ab3100.c
@@ -235,6 +235,7 @@ static int __init ab3100_rtc_probe(struct platform_device *pdev)
 		err = PTR_ERR(rtc);
 		return err;
 	}
+	platform_set_drvdata(pdev, rtc);
 
 	return 0;
 }
@@ -244,6 +245,7 @@ static int __exit ab3100_rtc_remove(struct platform_device *pdev)
 	struct rtc_device *rtc = platform_get_drvdata(pdev);
 
 	rtc_device_unregister(rtc);
+	platform_set_drvdata(pdev, NULL);
 	return 0;
 }
 

commit fa661258a27aa74aaf741882053d195291cefb75
Author: Mattias Wallin <mattias.wallin@stericsson.com>
Date:   Sat May 1 18:26:20 2010 +0200

    mfd: AB3100 register access change to abx500 API
    
    The interface for the AB3100 is changed to make way for the
    ABX500 family of chips: AB3550, AB5500 and future ST-Ericsson
    Analog Baseband chips. The register access functions are moved
    out to a separate struct abx500_ops. In this way the interface
    is moved from the implementation and the sub functionality drivers
    can keep their interface intact when chip infrastructure and
    communication mechanisms changes. We also define the AB3550
    device IDs and the AB3550 platform data struct and convert
    the catenated 32bit event to an array of 3 x 8bits.
    
    Signed-off-by: Mattias Wallin <mattias.wallin@stericsson.com>
    Signed-off-by: Linus Walleij <linus.walleij@stericsson.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/rtc/rtc-ab3100.c b/drivers/rtc/rtc-ab3100.c
index b46b85d581b0..d26780ea254b 100644
--- a/drivers/rtc/rtc-ab3100.c
+++ b/drivers/rtc/rtc-ab3100.c
@@ -45,7 +45,6 @@
  */
 static int ab3100_rtc_set_mmss(struct device *dev, unsigned long secs)
 {
-	struct ab3100 *ab3100_data = dev_get_drvdata(dev);
 	u8 regs[] = {AB3100_TI0, AB3100_TI1, AB3100_TI2,
 		     AB3100_TI3, AB3100_TI4, AB3100_TI5};
 	unsigned char buf[6];
@@ -61,27 +60,26 @@ static int ab3100_rtc_set_mmss(struct device *dev, unsigned long secs)
 	buf[5] = (fat_time >> 40) & 0xFF;
 
 	for (i = 0; i < 6; i++) {
-		err = ab3100_set_register_interruptible(ab3100_data,
+		err = abx500_set_register_interruptible(dev, 0,
 							regs[i], buf[i]);
 		if (err)
 			return err;
 	}
 
 	/* Set the flag to mark that the clock is now set */
-	return ab3100_mask_and_set_register_interruptible(ab3100_data,
+	return abx500_mask_and_set_register_interruptible(dev, 0,
 							  AB3100_RTC,
-							  0xFE, 0x01);
+							  0x01, 0x01);
 
 }
 
 static int ab3100_rtc_read_time(struct device *dev, struct rtc_time *tm)
 {
-	struct ab3100 *ab3100_data = dev_get_drvdata(dev);
 	unsigned long time;
 	u8 rtcval;
 	int err;
 
-	err = ab3100_get_register_interruptible(ab3100_data,
+	err = abx500_get_register_interruptible(dev, 0,
 						AB3100_RTC, &rtcval);
 	if (err)
 		return err;
@@ -94,7 +92,7 @@ static int ab3100_rtc_read_time(struct device *dev, struct rtc_time *tm)
 		u8 buf[6];
 
 		/* Read out time registers */
-		err = ab3100_get_register_page_interruptible(ab3100_data,
+		err = abx500_get_register_page_interruptible(dev, 0,
 							     AB3100_TI0,
 							     buf, 6);
 		if (err != 0)
@@ -114,7 +112,6 @@ static int ab3100_rtc_read_time(struct device *dev, struct rtc_time *tm)
 
 static int ab3100_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alarm)
 {
-	struct ab3100 *ab3100_data = dev_get_drvdata(dev);
 	unsigned long time;
 	u64 fat_time;
 	u8 buf[6];
@@ -122,7 +119,7 @@ static int ab3100_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alarm)
 	int err;
 
 	/* Figure out if alarm is enabled or not */
-	err = ab3100_get_register_interruptible(ab3100_data,
+	err = abx500_get_register_interruptible(dev, 0,
 						AB3100_RTC, &rtcval);
 	if (err)
 		return err;
@@ -133,7 +130,7 @@ static int ab3100_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alarm)
 	/* No idea how this could be represented */
 	alarm->pending = 0;
 	/* Read out alarm registers, only 4 bytes */
-	err = ab3100_get_register_page_interruptible(ab3100_data,
+	err = abx500_get_register_page_interruptible(dev, 0,
 						     AB3100_AL0, buf, 4);
 	if (err)
 		return err;
@@ -148,7 +145,6 @@ static int ab3100_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alarm)
 
 static int ab3100_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alarm)
 {
-	struct ab3100 *ab3100_data = dev_get_drvdata(dev);
 	u8 regs[] = {AB3100_AL0, AB3100_AL1, AB3100_AL2, AB3100_AL3};
 	unsigned char buf[4];
 	unsigned long secs;
@@ -165,21 +161,19 @@ static int ab3100_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alarm)
 
 	/* Set the alarm */
 	for (i = 0; i < 4; i++) {
-		err = ab3100_set_register_interruptible(ab3100_data,
+		err = abx500_set_register_interruptible(dev, 0,
 							regs[i], buf[i]);
 		if (err)
 			return err;
 	}
 	/* Then enable the alarm */
-	return ab3100_mask_and_set_register_interruptible(ab3100_data,
-							  AB3100_RTC, ~(1 << 2),
+	return abx500_mask_and_set_register_interruptible(dev, 0,
+							  AB3100_RTC, (1 << 2),
 							  alarm->enabled << 2);
 }
 
 static int ab3100_rtc_irq_enable(struct device *dev, unsigned int enabled)
 {
-	struct ab3100 *ab3100_data = dev_get_drvdata(dev);
-
 	/*
 	 * It's not possible to enable/disable the alarm IRQ for this RTC.
 	 * It does not actually trigger any IRQ: instead its only function is
@@ -188,12 +182,12 @@ static int ab3100_rtc_irq_enable(struct device *dev, unsigned int enabled)
 	 * and need to be handled there instead.
 	 */
 	if (enabled)
-		return ab3100_mask_and_set_register_interruptible(ab3100_data,
-						    AB3100_RTC, ~(1 << 2),
+		return abx500_mask_and_set_register_interruptible(dev, 0,
+						    AB3100_RTC, (1 << 2),
 						    1 << 2);
 	else
-		return ab3100_mask_and_set_register_interruptible(ab3100_data,
-						    AB3100_RTC, ~(1 << 2),
+		return abx500_mask_and_set_register_interruptible(dev, 0,
+						    AB3100_RTC, (1 << 2),
 						    0);
 }
 
@@ -210,10 +204,9 @@ static int __init ab3100_rtc_probe(struct platform_device *pdev)
 	int err;
 	u8 regval;
 	struct rtc_device *rtc;
-	struct ab3100 *ab3100_data = platform_get_drvdata(pdev);
 
 	/* The first RTC register needs special treatment */
-	err = ab3100_get_register_interruptible(ab3100_data,
+	err = abx500_get_register_interruptible(&pdev->dev, 0,
 						AB3100_RTC, &regval);
 	if (err) {
 		dev_err(&pdev->dev, "unable to read RTC register\n");
@@ -231,7 +224,7 @@ static int __init ab3100_rtc_probe(struct platform_device *pdev)
 		 * This bit remains until RTC power is lost.
 		 */
 		regval = 1 | RTC_SETTING;
-		err = ab3100_set_register_interruptible(ab3100_data,
+		err = abx500_set_register_interruptible(&pdev->dev, 0,
 							AB3100_RTC, regval);
 		/* Ignore any error on this write */
 	}

commit 812f9e9d424dde9ccb35975c0281edb6f8543735
Author: Linus Walleij <linus.walleij@stericsson.com>
Date:   Sat May 1 18:26:07 2010 +0200

    mfd: Renamed ab3100.h to abx500.h
    
    The goal here is to make way for a more general interface for the
    analog baseband chips ab3100 ab3550 ab550 and future chips.
    
    This patch have been divided into two parts since both changing name
    and content of a file is not recommended in git.
    
    Signed-off-by: Mattias Wallin <mattias.wallin@stericsson.com>
    Signed-off-by: Linus Walleij <linus.walleij@stericsson.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/rtc/rtc-ab3100.c b/drivers/rtc/rtc-ab3100.c
index 4704aac2b5af..b46b85d581b0 100644
--- a/drivers/rtc/rtc-ab3100.c
+++ b/drivers/rtc/rtc-ab3100.c
@@ -9,7 +9,7 @@
 #include <linux/init.h>
 #include <linux/platform_device.h>
 #include <linux/rtc.h>
-#include <linux/mfd/ab3100.h>
+#include <linux/mfd/abx500.h>
 
 /* Clock rate in Hz */
 #define AB3100_RTC_CLOCK_RATE	32768

commit bd207cfb0011389d55827b3f3181c60e8c3c7148
Author: Linus Walleij <linus.walleij@stericsson.com>
Date:   Sun Aug 30 23:49:04 2009 +0200

    rtc: AB3100 RTC support
    
    This adds support for the RTC found inside the AB3100 Mixed Signal chip.
    The symbols used for communicating with the chip is found in the
    mfd/ab3100-core.c driver that also provides the platform device.
    
    Signed-off-by: Linus Walleij <linus.walleij@stericsson.com>
    Acked-by: Alessandro Zummo <alessandro.zummo@towertech.it>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/rtc/rtc-ab3100.c b/drivers/rtc/rtc-ab3100.c
new file mode 100644
index 000000000000..4704aac2b5af
--- /dev/null
+++ b/drivers/rtc/rtc-ab3100.c
@@ -0,0 +1,281 @@
+/*
+ * Copyright (C) 2007-2009 ST-Ericsson AB
+ * License terms: GNU General Public License (GPL) version 2
+ * RTC clock driver for the AB3100 Analog Baseband Chip
+ * Author: Linus Walleij <linus.walleij@stericsson.com>
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/rtc.h>
+#include <linux/mfd/ab3100.h>
+
+/* Clock rate in Hz */
+#define AB3100_RTC_CLOCK_RATE	32768
+
+/*
+ * The AB3100 RTC registers. These are the same for
+ * AB3000 and AB3100.
+ * Control register:
+ * Bit 0: RTC Monitor cleared=0, active=1, if you set it
+ *        to 1 it remains active until RTC power is lost.
+ * Bit 1: 32 kHz Oscillator, 0 = on, 1 = bypass
+ * Bit 2: Alarm on, 0 = off, 1 = on
+ * Bit 3: 32 kHz buffer disabling, 0 = enabled, 1 = disabled
+ */
+#define AB3100_RTC		0x53
+/* default setting, buffer disabled, alarm on */
+#define RTC_SETTING		0x30
+/* Alarm when AL0-AL3 == TI0-TI3  */
+#define AB3100_AL0		0x56
+#define AB3100_AL1		0x57
+#define AB3100_AL2		0x58
+#define AB3100_AL3		0x59
+/* This 48-bit register that counts up at 32768 Hz */
+#define AB3100_TI0		0x5a
+#define AB3100_TI1		0x5b
+#define AB3100_TI2		0x5c
+#define AB3100_TI3		0x5d
+#define AB3100_TI4		0x5e
+#define AB3100_TI5		0x5f
+
+/*
+ * RTC clock functions and device struct declaration
+ */
+static int ab3100_rtc_set_mmss(struct device *dev, unsigned long secs)
+{
+	struct ab3100 *ab3100_data = dev_get_drvdata(dev);
+	u8 regs[] = {AB3100_TI0, AB3100_TI1, AB3100_TI2,
+		     AB3100_TI3, AB3100_TI4, AB3100_TI5};
+	unsigned char buf[6];
+	u64 fat_time = (u64) secs * AB3100_RTC_CLOCK_RATE * 2;
+	int err = 0;
+	int i;
+
+	buf[0] = (fat_time) & 0xFF;
+	buf[1] = (fat_time >> 8) & 0xFF;
+	buf[2] = (fat_time >> 16) & 0xFF;
+	buf[3] = (fat_time >> 24) & 0xFF;
+	buf[4] = (fat_time >> 32) & 0xFF;
+	buf[5] = (fat_time >> 40) & 0xFF;
+
+	for (i = 0; i < 6; i++) {
+		err = ab3100_set_register_interruptible(ab3100_data,
+							regs[i], buf[i]);
+		if (err)
+			return err;
+	}
+
+	/* Set the flag to mark that the clock is now set */
+	return ab3100_mask_and_set_register_interruptible(ab3100_data,
+							  AB3100_RTC,
+							  0xFE, 0x01);
+
+}
+
+static int ab3100_rtc_read_time(struct device *dev, struct rtc_time *tm)
+{
+	struct ab3100 *ab3100_data = dev_get_drvdata(dev);
+	unsigned long time;
+	u8 rtcval;
+	int err;
+
+	err = ab3100_get_register_interruptible(ab3100_data,
+						AB3100_RTC, &rtcval);
+	if (err)
+		return err;
+
+	if (!(rtcval & 0x01)) {
+		dev_info(dev, "clock not set (lost power)");
+		return -EINVAL;
+	} else {
+		u64 fat_time;
+		u8 buf[6];
+
+		/* Read out time registers */
+		err = ab3100_get_register_page_interruptible(ab3100_data,
+							     AB3100_TI0,
+							     buf, 6);
+		if (err != 0)
+			return err;
+
+		fat_time = ((u64) buf[5] << 40) | ((u64) buf[4] << 32) |
+			((u64) buf[3] << 24) | ((u64) buf[2] << 16) |
+			((u64) buf[1] << 8) | (u64) buf[0];
+		time = (unsigned long) (fat_time /
+					(u64) (AB3100_RTC_CLOCK_RATE * 2));
+	}
+
+	rtc_time_to_tm(time, tm);
+
+	return rtc_valid_tm(tm);
+}
+
+static int ab3100_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alarm)
+{
+	struct ab3100 *ab3100_data = dev_get_drvdata(dev);
+	unsigned long time;
+	u64 fat_time;
+	u8 buf[6];
+	u8 rtcval;
+	int err;
+
+	/* Figure out if alarm is enabled or not */
+	err = ab3100_get_register_interruptible(ab3100_data,
+						AB3100_RTC, &rtcval);
+	if (err)
+		return err;
+	if (rtcval & 0x04)
+		alarm->enabled = 1;
+	else
+		alarm->enabled = 0;
+	/* No idea how this could be represented */
+	alarm->pending = 0;
+	/* Read out alarm registers, only 4 bytes */
+	err = ab3100_get_register_page_interruptible(ab3100_data,
+						     AB3100_AL0, buf, 4);
+	if (err)
+		return err;
+	fat_time = ((u64) buf[3] << 40) | ((u64) buf[2] << 32) |
+		((u64) buf[1] << 24) | ((u64) buf[0] << 16);
+	time = (unsigned long) (fat_time / (u64) (AB3100_RTC_CLOCK_RATE * 2));
+
+	rtc_time_to_tm(time, &alarm->time);
+
+	return rtc_valid_tm(&alarm->time);
+}
+
+static int ab3100_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alarm)
+{
+	struct ab3100 *ab3100_data = dev_get_drvdata(dev);
+	u8 regs[] = {AB3100_AL0, AB3100_AL1, AB3100_AL2, AB3100_AL3};
+	unsigned char buf[4];
+	unsigned long secs;
+	u64 fat_time;
+	int err;
+	int i;
+
+	rtc_tm_to_time(&alarm->time, &secs);
+	fat_time = (u64) secs * AB3100_RTC_CLOCK_RATE * 2;
+	buf[0] = (fat_time >> 16) & 0xFF;
+	buf[1] = (fat_time >> 24) & 0xFF;
+	buf[2] = (fat_time >> 32) & 0xFF;
+	buf[3] = (fat_time >> 40) & 0xFF;
+
+	/* Set the alarm */
+	for (i = 0; i < 4; i++) {
+		err = ab3100_set_register_interruptible(ab3100_data,
+							regs[i], buf[i]);
+		if (err)
+			return err;
+	}
+	/* Then enable the alarm */
+	return ab3100_mask_and_set_register_interruptible(ab3100_data,
+							  AB3100_RTC, ~(1 << 2),
+							  alarm->enabled << 2);
+}
+
+static int ab3100_rtc_irq_enable(struct device *dev, unsigned int enabled)
+{
+	struct ab3100 *ab3100_data = dev_get_drvdata(dev);
+
+	/*
+	 * It's not possible to enable/disable the alarm IRQ for this RTC.
+	 * It does not actually trigger any IRQ: instead its only function is
+	 * to power up the system, if it wasn't on. This will manifest as
+	 * a "power up cause" in the AB3100 power driver (battery charging etc)
+	 * and need to be handled there instead.
+	 */
+	if (enabled)
+		return ab3100_mask_and_set_register_interruptible(ab3100_data,
+						    AB3100_RTC, ~(1 << 2),
+						    1 << 2);
+	else
+		return ab3100_mask_and_set_register_interruptible(ab3100_data,
+						    AB3100_RTC, ~(1 << 2),
+						    0);
+}
+
+static const struct rtc_class_ops ab3100_rtc_ops = {
+	.read_time	= ab3100_rtc_read_time,
+	.set_mmss	= ab3100_rtc_set_mmss,
+	.read_alarm	= ab3100_rtc_read_alarm,
+	.set_alarm	= ab3100_rtc_set_alarm,
+	.alarm_irq_enable = ab3100_rtc_irq_enable,
+};
+
+static int __init ab3100_rtc_probe(struct platform_device *pdev)
+{
+	int err;
+	u8 regval;
+	struct rtc_device *rtc;
+	struct ab3100 *ab3100_data = platform_get_drvdata(pdev);
+
+	/* The first RTC register needs special treatment */
+	err = ab3100_get_register_interruptible(ab3100_data,
+						AB3100_RTC, &regval);
+	if (err) {
+		dev_err(&pdev->dev, "unable to read RTC register\n");
+		return -ENODEV;
+	}
+
+	if ((regval & 0xFE) != RTC_SETTING) {
+		dev_warn(&pdev->dev, "not default value in RTC reg 0x%x\n",
+			 regval);
+	}
+
+	if ((regval & 1) == 0) {
+		/*
+		 * Set bit to detect power loss.
+		 * This bit remains until RTC power is lost.
+		 */
+		regval = 1 | RTC_SETTING;
+		err = ab3100_set_register_interruptible(ab3100_data,
+							AB3100_RTC, regval);
+		/* Ignore any error on this write */
+	}
+
+	rtc = rtc_device_register("ab3100-rtc", &pdev->dev, &ab3100_rtc_ops,
+				  THIS_MODULE);
+	if (IS_ERR(rtc)) {
+		err = PTR_ERR(rtc);
+		return err;
+	}
+
+	return 0;
+}
+
+static int __exit ab3100_rtc_remove(struct platform_device *pdev)
+{
+	struct rtc_device *rtc = platform_get_drvdata(pdev);
+
+	rtc_device_unregister(rtc);
+	return 0;
+}
+
+static struct platform_driver ab3100_rtc_driver = {
+	.driver = {
+		.name = "ab3100-rtc",
+		.owner = THIS_MODULE,
+	},
+	.remove	 = __exit_p(ab3100_rtc_remove),
+};
+
+static int __init ab3100_rtc_init(void)
+{
+	return platform_driver_probe(&ab3100_rtc_driver,
+				     ab3100_rtc_probe);
+}
+
+static void __exit ab3100_rtc_exit(void)
+{
+	platform_driver_unregister(&ab3100_rtc_driver);
+}
+
+module_init(ab3100_rtc_init);
+module_exit(ab3100_rtc_exit);
+
+MODULE_AUTHOR("Linus Walleij <linus.walleij@stericsson.com>");
+MODULE_DESCRIPTION("AB3100 RTC Driver");
+MODULE_LICENSE("GPL");
