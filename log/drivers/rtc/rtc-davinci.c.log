commit 6a5bbad5869132ca1d0ada05fd0c6278d7450928
Author: Alexandre Belloni <alexandre.belloni@bootlin.com>
Date:   Thu Mar 5 22:50:22 2020 +0100

    rtc: davinci: remove useless error handling
    
    convertfromdays and convert2days never return errors, stop handling non
    existent errors.
    
    Link: https://lore.kernel.org/r/20200305215022.32533-4-alexandre.belloni@bootlin.com
    Signed-off-by: Alexandre Belloni <alexandre.belloni@bootlin.com>

diff --git a/drivers/rtc/rtc-davinci.c b/drivers/rtc/rtc-davinci.c
index 55d826dafe1d..73f87a17cdf3 100644
--- a/drivers/rtc/rtc-davinci.c
+++ b/drivers/rtc/rtc-davinci.c
@@ -227,7 +227,7 @@ davinci_rtc_ioctl(struct device *dev, unsigned int cmd, unsigned long arg)
 	return ret;
 }
 
-static int convertfromdays(u16 days, struct rtc_time *tm)
+static void convertfromdays(u16 days, struct rtc_time *tm)
 {
 	int tmp_days, year, mon;
 
@@ -250,10 +250,9 @@ static int convertfromdays(u16 days, struct rtc_time *tm)
 			break;
 		}
 	}
-	return 0;
 }
 
-static int convert2days(u16 *days, struct rtc_time *tm)
+static void convert2days(u16 *days, struct rtc_time *tm)
 {
 	int i;
 	*days = 0;
@@ -262,8 +261,6 @@ static int convert2days(u16 *days, struct rtc_time *tm)
 		*days += rtc_year_days(1, 12, i);
 
 	*days += rtc_year_days(tm->tm_mday, tm->tm_mon, 1900 + tm->tm_year);
-
-	return 0;
 }
 
 static int davinci_rtc_read_time(struct device *dev, struct rtc_time *tm)
@@ -296,8 +293,7 @@ static int davinci_rtc_read_time(struct device *dev, struct rtc_time *tm)
 	days <<= 8;
 	days |= day0;
 
-	if (convertfromdays(days, tm) < 0)
-		return -EINVAL;
+	convertfromdays(days, tm);
 
 	return 0;
 }
@@ -391,8 +387,7 @@ static int davinci_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alm)
 	days <<= 8;
 	days |= day0;
 
-	if (convertfromdays(days, &alm->time) < 0)
-		return -EINVAL;
+	convertfromdays(days, &alm->time);
 
 	alm->pending = !!(rtcss_read(davinci_rtc,
 			  PRTCSS_RTC_CCTRL) &

commit b6d8f589204802ec531a9de69abd8563f4640d30
Author: Alexandre Belloni <alexandre.belloni@bootlin.com>
Date:   Thu Mar 5 22:50:21 2020 +0100

    rtc: davinci: let the core handle rtc range
    
    Let the core handle offsetting and windowing the RTC range.
    
    This rtc has hours, minutes, seconds and 16bit days. As the driver has the
    RTC epoch set to year 2000, this means that the end of the range is 2^16
    days minus one second later. This is Sun Jun  6 23:59:59 UTC 2179. This
    is better than the currently set year 2099.
    
    Link: https://lore.kernel.org/r/20200305215022.32533-3-alexandre.belloni@bootlin.com
    Signed-off-by: Alexandre Belloni <alexandre.belloni@bootlin.com>

diff --git a/drivers/rtc/rtc-davinci.c b/drivers/rtc/rtc-davinci.c
index 3043ffea8f7c..55d826dafe1d 100644
--- a/drivers/rtc/rtc-davinci.c
+++ b/drivers/rtc/rtc-davinci.c
@@ -258,10 +258,6 @@ static int convert2days(u16 *days, struct rtc_time *tm)
 	int i;
 	*days = 0;
 
-	/* epoch == 1900 */
-	if (tm->tm_year < 100 || tm->tm_year > 199)
-		return -EINVAL;
-
 	for (i = 2000; i < 1900 + tm->tm_year; i++)
 		*days += rtc_year_days(1, 12, i);
 
@@ -313,8 +309,7 @@ static int davinci_rtc_set_time(struct device *dev, struct rtc_time *tm)
 	u8 rtc_cctrl;
 	unsigned long flags;
 
-	if (convert2days(&days, tm) < 0)
-		return -EINVAL;
+	convert2days(&days, tm);
 
 	spin_lock_irqsave(&davinci_rtc_lock, flags);
 
@@ -413,8 +408,7 @@ static int davinci_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alm)
 	unsigned long flags;
 	u16 days;
 
-	if (convert2days(&days, &alm->time) < 0)
-		return -EINVAL;
+	convert2days(&days, &alm->time);
 
 	spin_lock_irqsave(&davinci_rtc_lock, flags);
 
@@ -469,6 +463,8 @@ static int __init davinci_rtc_probe(struct platform_device *pdev)
 		return PTR_ERR(davinci_rtc->rtc);
 
 	davinci_rtc->rtc->ops = &davinci_rtc_ops;
+	davinci_rtc->rtc->range_min = RTC_TIMESTAMP_BEGIN_2000;
+	davinci_rtc->rtc->range_max = RTC_TIMESTAMP_BEGIN_2000 + (1 << 16) * 86400ULL - 1;
 
 	rtcif_write(davinci_rtc, PRTCIF_INTFLG_RTCSS, PRTCIF_INTFLG);
 	rtcif_write(davinci_rtc, 0, PRTCIF_INTEN);

commit dc924ce9a1848cf5c86c878f0df16c725788e8d3
Author: Alexandre Belloni <alexandre.belloni@bootlin.com>
Date:   Thu Mar 5 22:50:20 2020 +0100

    rtc: davinci: remove useless 24h alarm handling
    
    The code handling invalid alarms meaning the alarm is in the next 24 hours
    is not necessary since commit f8245c26886c ("rtc: remove "RTC_ALM_SET mode"
    bugs") which actually predates this driver. Since then, .set_alarm is never
    called with an invalid alarm and this handling is not necessary in the
    driver.
    
    Link: https://lore.kernel.org/r/20200305215022.32533-2-alexandre.belloni@bootlin.com
    Signed-off-by: Alexandre Belloni <alexandre.belloni@bootlin.com>

diff --git a/drivers/rtc/rtc-davinci.c b/drivers/rtc/rtc-davinci.c
index d620d147c604..3043ffea8f7c 100644
--- a/drivers/rtc/rtc-davinci.c
+++ b/drivers/rtc/rtc-davinci.c
@@ -413,27 +413,6 @@ static int davinci_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alm)
 	unsigned long flags;
 	u16 days;
 
-	if (alm->time.tm_mday <= 0 && alm->time.tm_mon < 0
-	    && alm->time.tm_year < 0) {
-		struct rtc_time tm;
-		unsigned long now, then;
-
-		davinci_rtc_read_time(dev, &tm);
-		rtc_tm_to_time(&tm, &now);
-
-		alm->time.tm_mday = tm.tm_mday;
-		alm->time.tm_mon = tm.tm_mon;
-		alm->time.tm_year = tm.tm_year;
-		rtc_tm_to_time(&alm->time, &then);
-
-		if (then < now) {
-			rtc_time_to_tm(now + 24 * 60 * 60, &tm);
-			alm->time.tm_mday = tm.tm_mday;
-			alm->time.tm_mon = tm.tm_mon;
-			alm->time.tm_year = tm.tm_year;
-		}
-	}
-
 	if (convert2days(&days, &alm->time) < 0)
 		return -EINVAL;
 

commit b1c67e0b07c5613bb7e2ad20eee9a6e5d1504fd1
Author: Alexandre Belloni <alexandre.belloni@bootlin.com>
Date:   Thu Mar 5 22:50:19 2020 +0100

    rtc: davinci: convert to devm_rtc_allocate_device
    
    This allows further improvement of the driver. Also remove the unnecessary
    error string as the core will already display error messages.
    
    Link: https://lore.kernel.org/r/20200305215022.32533-1-alexandre.belloni@bootlin.com
    Signed-off-by: Alexandre Belloni <alexandre.belloni@bootlin.com>

diff --git a/drivers/rtc/rtc-davinci.c b/drivers/rtc/rtc-davinci.c
index 390b7351e0fe..d620d147c604 100644
--- a/drivers/rtc/rtc-davinci.c
+++ b/drivers/rtc/rtc-davinci.c
@@ -485,13 +485,11 @@ static int __init davinci_rtc_probe(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, davinci_rtc);
 
-	davinci_rtc->rtc = devm_rtc_device_register(&pdev->dev, pdev->name,
-				    &davinci_rtc_ops, THIS_MODULE);
-	if (IS_ERR(davinci_rtc->rtc)) {
-		dev_err(dev, "unable to register RTC device, err %d\n",
-				ret);
+	davinci_rtc->rtc = devm_rtc_allocate_device(&pdev->dev);
+	if (IS_ERR(davinci_rtc->rtc))
 		return PTR_ERR(davinci_rtc->rtc);
-	}
+
+	davinci_rtc->rtc->ops = &davinci_rtc_ops;
 
 	rtcif_write(davinci_rtc, PRTCIF_INTFLG_RTCSS, PRTCIF_INTFLG);
 	rtcif_write(davinci_rtc, 0, PRTCIF_INTEN);
@@ -516,7 +514,7 @@ static int __init davinci_rtc_probe(struct platform_device *pdev)
 
 	device_init_wakeup(&pdev->dev, 0);
 
-	return 0;
+	return rtc_register_device(davinci_rtc->rtc);
 }
 
 static int __exit davinci_rtc_remove(struct platform_device *pdev)

commit 09ef18bcd5ac6c2213cedd20f4f8cad08bbe3d74
Author: YueHaibing <yuehaibing@huawei.com>
Date:   Sun Oct 6 18:29:20 2019 +0800

    rtc: use devm_platform_ioremap_resource() to simplify code
    
    Use devm_platform_ioremap_resource() to simplify the code a bit.
    This is detected by coccinelle.
    
    Signed-off-by: YueHaibing <yuehaibing@huawei.com>
    Link: https://lore.kernel.org/r/20191006102953.57536-2-yuehaibing@huawei.com
    Link: https://lore.kernel.org/r/20191006102953.57536-3-yuehaibing@huawei.com
    Link: https://lore.kernel.org/r/20191006102953.57536-4-yuehaibing@huawei.com
    Link: https://lore.kernel.org/r/20191006102953.57536-5-yuehaibing@huawei.com
    Link: https://lore.kernel.org/r/20191006102953.57536-6-yuehaibing@huawei.com
    Link: https://lore.kernel.org/r/20191006102953.57536-7-yuehaibing@huawei.com
    Link: https://lore.kernel.org/r/20191006102953.57536-8-yuehaibing@huawei.com
    Link: https://lore.kernel.org/r/20191006102953.57536-9-yuehaibing@huawei.com
    Link: https://lore.kernel.org/r/20191006102953.57536-10-yuehaibing@huawei.com
    Link: https://lore.kernel.org/r/20191006102953.57536-11-yuehaibing@huawei.com
    Link: https://lore.kernel.org/r/20191006102953.57536-12-yuehaibing@huawei.com
    Link: https://lore.kernel.org/r/20191006102953.57536-13-yuehaibing@huawei.com
    Link: https://lore.kernel.org/r/20191006102953.57536-14-yuehaibing@huawei.com
    Link: https://lore.kernel.org/r/20191006102953.57536-15-yuehaibing@huawei.com
    Link: https://lore.kernel.org/r/20191006102953.57536-16-yuehaibing@huawei.com
    Link: https://lore.kernel.org/r/20191006102953.57536-17-yuehaibing@huawei.com
    Link: https://lore.kernel.org/r/20191006102953.57536-18-yuehaibing@huawei.com
    Link: https://lore.kernel.org/r/20191006102953.57536-19-yuehaibing@huawei.com
    Link: https://lore.kernel.org/r/20191006102953.57536-20-yuehaibing@huawei.com
    Link: https://lore.kernel.org/r/20191006102953.57536-21-yuehaibing@huawei.com
    Link: https://lore.kernel.org/r/20191006102953.57536-22-yuehaibing@huawei.com
    Link: https://lore.kernel.org/r/20191006102953.57536-23-yuehaibing@huawei.com
    Link: https://lore.kernel.org/r/20191006102953.57536-24-yuehaibing@huawei.com
    Link: https://lore.kernel.org/r/20191006102953.57536-25-yuehaibing@huawei.com
    Link: https://lore.kernel.org/r/20191006102953.57536-26-yuehaibing@huawei.com
    Link: https://lore.kernel.org/r/20191006102953.57536-27-yuehaibing@huawei.com
    Link: https://lore.kernel.org/r/20191006102953.57536-28-yuehaibing@huawei.com
    Link: https://lore.kernel.org/r/20191006102953.57536-29-yuehaibing@huawei.com
    Link: https://lore.kernel.org/r/20191006102953.57536-30-yuehaibing@huawei.com
    Link: https://lore.kernel.org/r/20191006102953.57536-31-yuehaibing@huawei.com
    Link: https://lore.kernel.org/r/20191006102953.57536-32-yuehaibing@huawei.com
    Link: https://lore.kernel.org/r/20191006102953.57536-33-yuehaibing@huawei.com
    Link: https://lore.kernel.org/r/20191006102953.57536-34-yuehaibing@huawei.com
    Link: https://lore.kernel.org/r/20191006102953.57536-35-yuehaibing@huawei.com
    Signed-off-by: Alexandre Belloni <alexandre.belloni@bootlin.com>

diff --git a/drivers/rtc/rtc-davinci.c b/drivers/rtc/rtc-davinci.c
index d8e0db2e7fc6..390b7351e0fe 100644
--- a/drivers/rtc/rtc-davinci.c
+++ b/drivers/rtc/rtc-davinci.c
@@ -469,7 +469,6 @@ static int __init davinci_rtc_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
 	struct davinci_rtc *davinci_rtc;
-	struct resource *res;
 	int ret = 0;
 
 	davinci_rtc = devm_kzalloc(&pdev->dev, sizeof(struct davinci_rtc), GFP_KERNEL);
@@ -480,8 +479,7 @@ static int __init davinci_rtc_probe(struct platform_device *pdev)
 	if (davinci_rtc->irq < 0)
 		return davinci_rtc->irq;
 
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	davinci_rtc->base = devm_ioremap_resource(dev, res);
+	davinci_rtc->base = devm_platform_ioremap_resource(pdev, 0);
 	if (IS_ERR(davinci_rtc->base))
 		return PTR_ERR(davinci_rtc->base);
 

commit faac910201e9beb66530bd8c3fe8a02d907ee2a9
Author: Stephen Boyd <swboyd@chromium.org>
Date:   Tue Jul 30 11:15:39 2019 -0700

    rtc: Remove dev_err() usage after platform_get_irq()
    
    We don't need dev_err() messages when platform_get_irq() fails now that
    platform_get_irq() prints an error message itself when something goes
    wrong. Let's remove these prints with a simple semantic patch.
    
    // <smpl>
    @@
    expression ret;
    struct platform_device *E;
    @@
    
    ret =
    (
    platform_get_irq(E, ...)
    |
    platform_get_irq_byname(E, ...)
    );
    
    if ( \( ret < 0 \| ret <= 0 \) )
    {
    (
    -if (ret != -EPROBE_DEFER)
    -{ ...
    -dev_err(...);
    -... }
    |
    ...
    -dev_err(...);
    )
    ...
    }
    // </smpl>
    
    While we're here, remove braces on if statements that only have one
    statement (manually).
    
    Cc: Alessandro Zummo <a.zummo@towertech.it>
    Cc: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Cc: linux-rtc@vger.kernel.org
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Stephen Boyd <swboyd@chromium.org>
    Link: https://lore.kernel.org/r/20190730181557.90391-40-swboyd@chromium.org
    Signed-off-by: Alexandre Belloni <alexandre.belloni@bootlin.com>

diff --git a/drivers/rtc/rtc-davinci.c b/drivers/rtc/rtc-davinci.c
index fcb71bf4d492..d8e0db2e7fc6 100644
--- a/drivers/rtc/rtc-davinci.c
+++ b/drivers/rtc/rtc-davinci.c
@@ -477,10 +477,8 @@ static int __init davinci_rtc_probe(struct platform_device *pdev)
 		return -ENOMEM;
 
 	davinci_rtc->irq = platform_get_irq(pdev, 0);
-	if (davinci_rtc->irq < 0) {
-		dev_err(dev, "no RTC irq\n");
+	if (davinci_rtc->irq < 0)
 		return davinci_rtc->irq;
-	}
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	davinci_rtc->base = devm_ioremap_resource(dev, res);

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/rtc/rtc-davinci.c b/drivers/rtc/rtc-davinci.c
index caf35567e14c..fcb71bf4d492 100644
--- a/drivers/rtc/rtc-davinci.c
+++ b/drivers/rtc/rtc-davinci.c
@@ -1,23 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * DaVinci Power Management and Real Time Clock Driver for TI platforms
  *
  * Copyright (C) 2009 Texas Instruments, Inc
  *
  * Author: Miguel Aguilar <miguel.aguilar@ridgerun.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
  */
 #include <linux/kernel.h>
 #include <linux/init.h>

commit 34c7b3ac4ccb6a972f81a4102c8ef216ca1fb155
Author: Julia Lawall <julia.lawall@lip6.fr>
Date:   Wed Aug 31 10:05:25 2016 +0200

    rtc: constify rtc_class_ops structures
    
    Check for rtc_class_ops structures that are only passed to
    devm_rtc_device_register, rtc_device_register,
    platform_device_register_data, all of which declare the corresponding
    parameter as const.  Declare rtc_class_ops structures that have these
    properties as const.
    
    The semantic patch that makes this change is as follows:
    (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @r disable optional_qualifier@
    identifier i;
    position p;
    @@
    static struct rtc_class_ops i@p = { ... };
    
    @ok@
    identifier r.i;
    expression e1,e2,e3,e4;
    position p;
    @@
    (
    devm_rtc_device_register(e1,e2,&i@p,e3)
    |
    rtc_device_register(e1,e2,&i@p,e3)
    |
    platform_device_register_data(e1,e2,e3,&i@p,e4)
    )
    
    @bad@
    position p != {r.p,ok.p};
    identifier r.i;
    @@
    i@p
    
    @depends on !bad disable optional_qualifier@
    identifier r.i;
    @@
    static
    +const
     struct rtc_class_ops i = { ... };
    // </smpl>
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Acked-by: Baruch Siach <baruch@tkos.co.il>
    Acked-by: Hans Ulli Kroll <ulli.kroll@googlemail.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>

diff --git a/drivers/rtc/rtc-davinci.c b/drivers/rtc/rtc-davinci.c
index dba60c1dfce2..caf35567e14c 100644
--- a/drivers/rtc/rtc-davinci.c
+++ b/drivers/rtc/rtc-davinci.c
@@ -469,7 +469,7 @@ static int davinci_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alm)
 	return 0;
 }
 
-static struct rtc_class_ops davinci_rtc_ops = {
+static const struct rtc_class_ops davinci_rtc_ops = {
 	.ioctl			= davinci_rtc_ioctl,
 	.read_time		= davinci_rtc_read_time,
 	.set_time		= davinci_rtc_set_time,

commit d2c92705c54c9c24f2b8be57b968ad21a30412e5
Author: Uwe Kleine-König <uwe@kleine-koenig.org>
Date:   Mon Jul 11 10:05:27 2016 +0200

    rtc: explicitly set tm_sec = 0 for drivers with minute accurancy
    
    Since all time members of the alarm data is initialized to -1 the drivers
    are responsible to set the tm_sec member to 0.
    
    Fixes: d68778b80dd7 ("rtc: initialize output parameter for read alarm to "uninitialized"")
    Signed-off-by: Uwe Kleine-König <uwe@kleine-koenig.org>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>

diff --git a/drivers/rtc/rtc-davinci.c b/drivers/rtc/rtc-davinci.c
index c5432bf64e1c..dba60c1dfce2 100644
--- a/drivers/rtc/rtc-davinci.c
+++ b/drivers/rtc/rtc-davinci.c
@@ -388,6 +388,8 @@ static int davinci_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alm)
 	u8 day0, day1;
 	unsigned long flags;
 
+	alm->time.tm_sec = 0;
+
 	spin_lock_irqsave(&davinci_rtc_lock, flags);
 
 	davinci_rtcss_calendar_wait(davinci_rtc);

commit dbb812b141f3bf3dbea75353da799da3d3373d53
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Oct 12 15:14:05 2015 +0200

    rtc: davinci: remove incorrect reference to probe function
    
    The davinci rtc driver uses the module_platform_driver_probe()
    helper to call the probe function and mark it as __init, but
    it also puts a reference into its davinci_rtc_driver function.
    
    This will crash if we ever get a deferred probe and the probe
    function is called again after the init section has been removed.
    kbuild warns about this:
    
    WARNING: vmlinux.o(.data+0x1aa2b4): Section mismatch in reference from the variable davinci_rtc_driver to the function .init.text:davinci_rtc_probe()
    The variable davinci_rtc_driver references
    the function __init davinci_rtc_probe()
    
    This patch removes the .probe callback from the platform driver,
    which avoids those problems.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>

diff --git a/drivers/rtc/rtc-davinci.c b/drivers/rtc/rtc-davinci.c
index c84f46168a52..c5432bf64e1c 100644
--- a/drivers/rtc/rtc-davinci.c
+++ b/drivers/rtc/rtc-davinci.c
@@ -546,7 +546,6 @@ static int __exit davinci_rtc_remove(struct platform_device *pdev)
 }
 
 static struct platform_driver davinci_rtc_driver = {
-	.probe		= davinci_rtc_probe,
 	.remove		= __exit_p(davinci_rtc_remove),
 	.driver		= {
 		.name = "rtc_davinci",

commit 0929ae376ef32591a5f13870a703efc2901bfab9
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Mon Oct 20 16:21:31 2014 +0200

    rtc: drop owner assignment from platform_drivers
    
    A platform_driver does not need to set an owner, it will be populated by the
    driver core.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/rtc/rtc-davinci.c b/drivers/rtc/rtc-davinci.c
index c0a3b59f65a2..c84f46168a52 100644
--- a/drivers/rtc/rtc-davinci.c
+++ b/drivers/rtc/rtc-davinci.c
@@ -550,7 +550,6 @@ static struct platform_driver davinci_rtc_driver = {
 	.remove		= __exit_p(davinci_rtc_remove),
 	.driver		= {
 		.name = "rtc_davinci",
-		.owner = THIS_MODULE,
 	},
 };
 

commit 1e6789f6e2e2b1645527d08832bfb95982da17ff
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Thu Apr 3 14:49:48 2014 -0700

    rtc: rtc-davinci: use devm_ioremap_resource()
    
    Use devm_ioremap_resource() in order to make the code simpler, and
    remove redundant return value check of platform_get_resource() because
    the value is checked by devm_ioremap_resource().
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Cc: Kevin Hilman <khilman@linaro.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/rtc/rtc-davinci.c b/drivers/rtc/rtc-davinci.c
index 1f3495e4e634..c0a3b59f65a2 100644
--- a/drivers/rtc/rtc-davinci.c
+++ b/drivers/rtc/rtc-davinci.c
@@ -119,8 +119,6 @@ static DEFINE_SPINLOCK(davinci_rtc_lock);
 struct davinci_rtc {
 	struct rtc_device		*rtc;
 	void __iomem			*base;
-	resource_size_t			pbase;
-	size_t				base_size;
 	int				irq;
 };
 
@@ -482,7 +480,7 @@ static int __init davinci_rtc_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
 	struct davinci_rtc *davinci_rtc;
-	struct resource *res, *mem;
+	struct resource *res;
 	int ret = 0;
 
 	davinci_rtc = devm_kzalloc(&pdev->dev, sizeof(struct davinci_rtc), GFP_KERNEL);
@@ -496,28 +494,9 @@ static int __init davinci_rtc_probe(struct platform_device *pdev)
 	}
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!res) {
-		dev_err(dev, "no mem resource\n");
-		return -EINVAL;
-	}
-
-	davinci_rtc->pbase = res->start;
-	davinci_rtc->base_size = resource_size(res);
-
-	mem = devm_request_mem_region(dev, davinci_rtc->pbase,
-				davinci_rtc->base_size, pdev->name);
-	if (!mem) {
-		dev_err(dev, "RTC registers at %08x are not free\n",
-			davinci_rtc->pbase);
-		return -EBUSY;
-	}
-
-	davinci_rtc->base = devm_ioremap(dev, davinci_rtc->pbase,
-					davinci_rtc->base_size);
-	if (!davinci_rtc->base) {
-		dev_err(dev, "unable to ioremap MEM resource\n");
-		return -ENOMEM;
-	}
+	davinci_rtc->base = devm_ioremap_resource(dev, res);
+	if (IS_ERR(davinci_rtc->base))
+		return PTR_ERR(davinci_rtc->base);
 
 	platform_set_drvdata(pdev, davinci_rtc);
 

commit a3080fa7ec028dca0ac24399e19292bcf4feaf6c
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Thu Apr 3 14:49:39 2014 -0700

    rtc: rtc-davinci: remove unnecessary OOM messages
    
    The site-specific OOM messages are unnecessary, because they duplicate
    the MM subsystem generic OOM message.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/rtc/rtc-davinci.c b/drivers/rtc/rtc-davinci.c
index 24677ef8c39a..1f3495e4e634 100644
--- a/drivers/rtc/rtc-davinci.c
+++ b/drivers/rtc/rtc-davinci.c
@@ -486,10 +486,8 @@ static int __init davinci_rtc_probe(struct platform_device *pdev)
 	int ret = 0;
 
 	davinci_rtc = devm_kzalloc(&pdev->dev, sizeof(struct davinci_rtc), GFP_KERNEL);
-	if (!davinci_rtc) {
-		dev_dbg(dev, "could not allocate memory for private data\n");
+	if (!davinci_rtc)
 		return -ENOMEM;
-	}
 
 	davinci_rtc->irq = platform_get_irq(pdev, 0);
 	if (davinci_rtc->irq < 0) {

commit 438831fc6ee66a34f27522ef3f0f9eac4b4da8bc
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Wed Jul 3 15:06:19 2013 -0700

    rtc: rtc-davinci: remove unnecessary platform_set_drvdata()
    
    The driver core clears the driver data to NULL after device_release or
    on probe failure, since commit 0998d063100 ("device-core: Ensure drvdata
    = NULL when no driver is bound").  Thus, it is not needed to manually
    clear the device driver data to NULL.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/rtc/rtc-davinci.c b/drivers/rtc/rtc-davinci.c
index be5fc32d3cd7..24677ef8c39a 100644
--- a/drivers/rtc/rtc-davinci.c
+++ b/drivers/rtc/rtc-davinci.c
@@ -526,10 +526,9 @@ static int __init davinci_rtc_probe(struct platform_device *pdev)
 	davinci_rtc->rtc = devm_rtc_device_register(&pdev->dev, pdev->name,
 				    &davinci_rtc_ops, THIS_MODULE);
 	if (IS_ERR(davinci_rtc->rtc)) {
-		ret = PTR_ERR(davinci_rtc->rtc);
 		dev_err(dev, "unable to register RTC device, err %d\n",
 				ret);
-		goto fail1;
+		return PTR_ERR(davinci_rtc->rtc);
 	}
 
 	rtcif_write(davinci_rtc, PRTCIF_INTFLG_RTCSS, PRTCIF_INTFLG);
@@ -543,7 +542,7 @@ static int __init davinci_rtc_probe(struct platform_device *pdev)
 			  0, "davinci_rtc", davinci_rtc);
 	if (ret < 0) {
 		dev_err(dev, "unable to register davinci RTC interrupt\n");
-		goto fail1;
+		return ret;
 	}
 
 	/* Enable interrupts */
@@ -556,10 +555,6 @@ static int __init davinci_rtc_probe(struct platform_device *pdev)
 	device_init_wakeup(&pdev->dev, 0);
 
 	return 0;
-
-fail1:
-	platform_set_drvdata(pdev, NULL);
-	return ret;
 }
 
 static int __exit davinci_rtc_remove(struct platform_device *pdev)
@@ -570,8 +565,6 @@ static int __exit davinci_rtc_remove(struct platform_device *pdev)
 
 	rtcif_write(davinci_rtc, 0, PRTCIF_INTEN);
 
-	platform_set_drvdata(pdev, NULL);
-
 	return 0;
 }
 

commit 48c48180de5a1292c5ce40d6ad8fc21e7d1c86a8
Author: Sachin Kamat <sachin.kamat@linaro.org>
Date:   Wed Jul 3 15:05:46 2013 -0700

    drivers/rtc/rtc-davinci.c: fix whitespace warning
    
    Silences the following warning:
      WARNING: please, no space before tabs
    
    Signed-off-by: Sachin Kamat <sachin.kamat@linaro.org>
    Cc: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/rtc/rtc-davinci.c b/drivers/rtc/rtc-davinci.c
index a55048c3e26f..be5fc32d3cd7 100644
--- a/drivers/rtc/rtc-davinci.c
+++ b/drivers/rtc/rtc-davinci.c
@@ -117,7 +117,7 @@
 static DEFINE_SPINLOCK(davinci_rtc_lock);
 
 struct davinci_rtc {
-	struct rtc_device 		*rtc;
+	struct rtc_device		*rtc;
 	void __iomem			*base;
 	resource_size_t			pbase;
 	size_t				base_size;

commit 8ae236b8c97fc65fd586fa6993184d2890b7016b
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Mon Apr 29 16:18:58 2013 -0700

    rtc: rtc-davinci: use devm_rtc_device_register()
    
    devm_rtc_device_register() is device managed and makes cleanup
    paths simpler.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/rtc/rtc-davinci.c b/drivers/rtc/rtc-davinci.c
index 1b0f932266eb..a55048c3e26f 100644
--- a/drivers/rtc/rtc-davinci.c
+++ b/drivers/rtc/rtc-davinci.c
@@ -523,7 +523,7 @@ static int __init davinci_rtc_probe(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, davinci_rtc);
 
-	davinci_rtc->rtc = rtc_device_register(pdev->name, &pdev->dev,
+	davinci_rtc->rtc = devm_rtc_device_register(&pdev->dev, pdev->name,
 				    &davinci_rtc_ops, THIS_MODULE);
 	if (IS_ERR(davinci_rtc->rtc)) {
 		ret = PTR_ERR(davinci_rtc->rtc);
@@ -543,7 +543,7 @@ static int __init davinci_rtc_probe(struct platform_device *pdev)
 			  0, "davinci_rtc", davinci_rtc);
 	if (ret < 0) {
 		dev_err(dev, "unable to register davinci RTC interrupt\n");
-		goto fail2;
+		goto fail1;
 	}
 
 	/* Enable interrupts */
@@ -557,8 +557,6 @@ static int __init davinci_rtc_probe(struct platform_device *pdev)
 
 	return 0;
 
-fail2:
-	rtc_device_unregister(davinci_rtc->rtc);
 fail1:
 	platform_set_drvdata(pdev, NULL);
 	return ret;
@@ -572,8 +570,6 @@ static int __exit davinci_rtc_remove(struct platform_device *pdev)
 
 	rtcif_write(davinci_rtc, 0, PRTCIF_INTEN);
 
-	rtc_device_unregister(davinci_rtc->rtc);
-
 	platform_set_drvdata(pdev, NULL);
 
 	return 0;

commit ce14a0261802e2758439c30dadac78f764c1fe16
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Mon Apr 29 16:18:38 2013 -0700

    rtc: rtc-davinci: use module_platform_driver_probe()
    
    Use module_platform_driver_probe() macro which makes the code smaller and
    simpler.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/rtc/rtc-davinci.c b/drivers/rtc/rtc-davinci.c
index db877e02f2a2..1b0f932266eb 100644
--- a/drivers/rtc/rtc-davinci.c
+++ b/drivers/rtc/rtc-davinci.c
@@ -588,17 +588,7 @@ static struct platform_driver davinci_rtc_driver = {
 	},
 };
 
-static int __init rtc_init(void)
-{
-	return platform_driver_probe(&davinci_rtc_driver, davinci_rtc_probe);
-}
-module_init(rtc_init);
-
-static void __exit rtc_exit(void)
-{
-	platform_driver_unregister(&davinci_rtc_driver);
-}
-module_exit(rtc_exit);
+module_platform_driver_probe(davinci_rtc_driver, davinci_rtc_probe);
 
 MODULE_AUTHOR("Miguel Aguilar <miguel.aguilar@ridgerun.com>");
 MODULE_DESCRIPTION("Texas Instruments DaVinci PRTC Driver");

commit 5149c0359f1db846d97223206d271c06ef176049
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Mon Apr 29 16:18:22 2013 -0700

    rtc: rtc-davinci: add __exit annotation
    
    When platform_driver_probe() is used, bind/unbind via sysfs is disabled.
    Thus, __init/__exit annotations can be added to probe()/remove().
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/rtc/rtc-davinci.c b/drivers/rtc/rtc-davinci.c
index 56b73089bb29..db877e02f2a2 100644
--- a/drivers/rtc/rtc-davinci.c
+++ b/drivers/rtc/rtc-davinci.c
@@ -564,7 +564,7 @@ static int __init davinci_rtc_probe(struct platform_device *pdev)
 	return ret;
 }
 
-static int davinci_rtc_remove(struct platform_device *pdev)
+static int __exit davinci_rtc_remove(struct platform_device *pdev)
 {
 	struct davinci_rtc *davinci_rtc = platform_get_drvdata(pdev);
 
@@ -581,7 +581,7 @@ static int davinci_rtc_remove(struct platform_device *pdev)
 
 static struct platform_driver davinci_rtc_driver = {
 	.probe		= davinci_rtc_probe,
-	.remove		= davinci_rtc_remove,
+	.remove		= __exit_p(davinci_rtc_remove),
 	.driver		= {
 		.name = "rtc_davinci",
 		.owner = THIS_MODULE,

commit a47a376f1c025e23e836c0376813c0424de665c2
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Thu Feb 21 16:45:45 2013 -0800

    rtc: rtc-davinci: use devm_*() functions
    
    Use devm_*() functions to make cleanup paths more simple.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/rtc/rtc-davinci.c b/drivers/rtc/rtc-davinci.c
index 5f7982f7c1b5..56b73089bb29 100644
--- a/drivers/rtc/rtc-davinci.c
+++ b/drivers/rtc/rtc-davinci.c
@@ -506,19 +506,19 @@ static int __init davinci_rtc_probe(struct platform_device *pdev)
 	davinci_rtc->pbase = res->start;
 	davinci_rtc->base_size = resource_size(res);
 
-	mem = request_mem_region(davinci_rtc->pbase, davinci_rtc->base_size,
-				 pdev->name);
+	mem = devm_request_mem_region(dev, davinci_rtc->pbase,
+				davinci_rtc->base_size, pdev->name);
 	if (!mem) {
 		dev_err(dev, "RTC registers at %08x are not free\n",
 			davinci_rtc->pbase);
 		return -EBUSY;
 	}
 
-	davinci_rtc->base = ioremap(davinci_rtc->pbase, davinci_rtc->base_size);
+	davinci_rtc->base = devm_ioremap(dev, davinci_rtc->pbase,
+					davinci_rtc->base_size);
 	if (!davinci_rtc->base) {
 		dev_err(dev, "unable to ioremap MEM resource\n");
-		ret = -ENOMEM;
-		goto fail2;
+		return -ENOMEM;
 	}
 
 	platform_set_drvdata(pdev, davinci_rtc);
@@ -529,7 +529,7 @@ static int __init davinci_rtc_probe(struct platform_device *pdev)
 		ret = PTR_ERR(davinci_rtc->rtc);
 		dev_err(dev, "unable to register RTC device, err %d\n",
 				ret);
-		goto fail3;
+		goto fail1;
 	}
 
 	rtcif_write(davinci_rtc, PRTCIF_INTFLG_RTCSS, PRTCIF_INTFLG);
@@ -539,11 +539,11 @@ static int __init davinci_rtc_probe(struct platform_device *pdev)
 	rtcss_write(davinci_rtc, 0, PRTCSS_RTC_CTRL);
 	rtcss_write(davinci_rtc, 0, PRTCSS_RTC_CCTRL);
 
-	ret = request_irq(davinci_rtc->irq, davinci_rtc_interrupt,
+	ret = devm_request_irq(dev, davinci_rtc->irq, davinci_rtc_interrupt,
 			  0, "davinci_rtc", davinci_rtc);
 	if (ret < 0) {
 		dev_err(dev, "unable to register davinci RTC interrupt\n");
-		goto fail4;
+		goto fail2;
 	}
 
 	/* Enable interrupts */
@@ -557,13 +557,10 @@ static int __init davinci_rtc_probe(struct platform_device *pdev)
 
 	return 0;
 
-fail4:
+fail2:
 	rtc_device_unregister(davinci_rtc->rtc);
-fail3:
+fail1:
 	platform_set_drvdata(pdev, NULL);
-	iounmap(davinci_rtc->base);
-fail2:
-	release_mem_region(davinci_rtc->pbase, davinci_rtc->base_size);
 	return ret;
 }
 
@@ -575,13 +572,8 @@ static int davinci_rtc_remove(struct platform_device *pdev)
 
 	rtcif_write(davinci_rtc, 0, PRTCIF_INTEN);
 
-	free_irq(davinci_rtc->irq, davinci_rtc);
-
 	rtc_device_unregister(davinci_rtc->rtc);
 
-	iounmap(davinci_rtc->base);
-	release_mem_region(davinci_rtc->pbase, davinci_rtc->base_size);
-
 	platform_set_drvdata(pdev, NULL);
 
 	return 0;

commit 5a167f4543e45d45c5672a5cd6cb8ba5ddf4f3ea
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Dec 21 13:09:38 2012 -0800

    Drivers: rtc: remove __dev* attributes.
    
    CONFIG_HOTPLUG is going away as an option.  As a result, the __dev*
    markings need to be removed.
    
    This change removes the use of __devinit, __devexit_p, __devinitdata,
    __devinitconst, and __devexit from these drivers.
    
    Based on patches originally written by Bill Pemberton, but redone by me
    in order to handle some of the coding style issues better, by hand.
    
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Alessandro Zummo <a.zummo@towertech.it>
    Cc: Srinidhi Kasagar <srinidhi.kasagar@stericsson.com>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Mike Frysinger <vapier.adi@gmail.com>
    Cc: Wan ZongShun <mcuos.com@gmail.com>
    Cc: Guan Xuetao <gxt@mprc.pku.edu.cn>
    Cc: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/rtc/rtc-davinci.c b/drivers/rtc/rtc-davinci.c
index 07cd03eae606..5f7982f7c1b5 100644
--- a/drivers/rtc/rtc-davinci.c
+++ b/drivers/rtc/rtc-davinci.c
@@ -567,7 +567,7 @@ static int __init davinci_rtc_probe(struct platform_device *pdev)
 	return ret;
 }
 
-static int __devexit davinci_rtc_remove(struct platform_device *pdev)
+static int davinci_rtc_remove(struct platform_device *pdev)
 {
 	struct davinci_rtc *davinci_rtc = platform_get_drvdata(pdev);
 
@@ -589,7 +589,7 @@ static int __devexit davinci_rtc_remove(struct platform_device *pdev)
 
 static struct platform_driver davinci_rtc_driver = {
 	.probe		= davinci_rtc_probe,
-	.remove		= __devexit_p(davinci_rtc_remove),
+	.remove		= davinci_rtc_remove,
 	.driver		= {
 		.name = "rtc_davinci",
 		.owner = THIS_MODULE,

commit f288cf416ec22de3c5bc18148b6f7620aa32409b
Author: Devendra Naga <devendra.aaru@gmail.com>
Date:   Mon Dec 17 16:02:41 2012 -0800

    rtc: rtc-davinci: use devm_kzalloc()
    
    Use devm_kzalloc() and remove the error path free and the unload free as
    devm functions take care of freeing resources.
    
    Signed-off-by: Devendra Naga <devendra.aaru@gmail.com>
    Cc: Alessandro Zummo <a.zummo@towertech.it>
    Cc: Miguel Aguilar <miguel.aguilar@ridgerun.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/rtc/rtc-davinci.c b/drivers/rtc/rtc-davinci.c
index fd95316743c9..07cd03eae606 100644
--- a/drivers/rtc/rtc-davinci.c
+++ b/drivers/rtc/rtc-davinci.c
@@ -485,7 +485,7 @@ static int __init davinci_rtc_probe(struct platform_device *pdev)
 	struct resource *res, *mem;
 	int ret = 0;
 
-	davinci_rtc = kzalloc(sizeof(struct davinci_rtc), GFP_KERNEL);
+	davinci_rtc = devm_kzalloc(&pdev->dev, sizeof(struct davinci_rtc), GFP_KERNEL);
 	if (!davinci_rtc) {
 		dev_dbg(dev, "could not allocate memory for private data\n");
 		return -ENOMEM;
@@ -494,15 +494,13 @@ static int __init davinci_rtc_probe(struct platform_device *pdev)
 	davinci_rtc->irq = platform_get_irq(pdev, 0);
 	if (davinci_rtc->irq < 0) {
 		dev_err(dev, "no RTC irq\n");
-		ret = davinci_rtc->irq;
-		goto fail1;
+		return davinci_rtc->irq;
 	}
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!res) {
 		dev_err(dev, "no mem resource\n");
-		ret = -EINVAL;
-		goto fail1;
+		return -EINVAL;
 	}
 
 	davinci_rtc->pbase = res->start;
@@ -513,8 +511,7 @@ static int __init davinci_rtc_probe(struct platform_device *pdev)
 	if (!mem) {
 		dev_err(dev, "RTC registers at %08x are not free\n",
 			davinci_rtc->pbase);
-		ret = -EBUSY;
-		goto fail1;
+		return -EBUSY;
 	}
 
 	davinci_rtc->base = ioremap(davinci_rtc->pbase, davinci_rtc->base_size);
@@ -567,9 +564,6 @@ static int __init davinci_rtc_probe(struct platform_device *pdev)
 	iounmap(davinci_rtc->base);
 fail2:
 	release_mem_region(davinci_rtc->pbase, davinci_rtc->base_size);
-fail1:
-	kfree(davinci_rtc);
-
 	return ret;
 }
 
@@ -590,8 +584,6 @@ static int __devexit davinci_rtc_remove(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, NULL);
 
-	kfree(davinci_rtc);
-
 	return 0;
 }
 

commit 9ed39bf931cbd95b30755dcb1ad724fe05565c3f
Author: Devendra Naga <devendra.aaru@gmail.com>
Date:   Mon Dec 17 16:02:39 2012 -0800

    rtc: rtc-davinci: return correct error code if rtc_device_register() fails
    
    rtc_device_register() returns a pointer containing error code in case
    of error.  Use that in the error return.
    
    Signed-off-by: Devendra Naga <devendra.aaru@gmail.com>
    Cc: Alessandro Zummo <a.zummo@towertech.it>
    Cc: Miguel Aguilar <miguel.aguilar@ridgerun.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/rtc/rtc-davinci.c b/drivers/rtc/rtc-davinci.c
index 14c2109dbaa3..fd95316743c9 100644
--- a/drivers/rtc/rtc-davinci.c
+++ b/drivers/rtc/rtc-davinci.c
@@ -529,8 +529,9 @@ static int __init davinci_rtc_probe(struct platform_device *pdev)
 	davinci_rtc->rtc = rtc_device_register(pdev->name, &pdev->dev,
 				    &davinci_rtc_ops, THIS_MODULE);
 	if (IS_ERR(davinci_rtc->rtc)) {
-		dev_err(dev, "unable to register RTC device, err %ld\n",
-				PTR_ERR(davinci_rtc->rtc));
+		ret = PTR_ERR(davinci_rtc->rtc);
+		dev_err(dev, "unable to register RTC device, err %d\n",
+				ret);
 		goto fail3;
 	}
 

commit 2f6e5f9458646263d3d9ffadd5e11e3d8d15a7d0
Author: Yong Zhang <yong.zhang0@gmail.com>
Date:   Fri Mar 23 15:02:34 2012 -0700

    drivers/rtc: remove IRQF_DISABLED
    
    Since commit e58aa3d2d0cc ("genirq: run irq handlers with interrupts
    disabled") we run all interrupt handlers with interrupts disabled and we
    even check and yell when an interrupt handler returns with interrupts
    enabled - see commit b738a50a2026 ("genirq: warn when handler enables
    interrupts").
    
    So now this flag is a NOOP and can be removed.
    
    Signed-off-by: Yong Zhang <yong.zhang0@gmail.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Wan ZongShun <mcuos.com@gmail.com>
    Cc: Alessandro Zummo <a.zummo@towertech.it>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/rtc/rtc-davinci.c b/drivers/rtc/rtc-davinci.c
index 755e1fe914af..14c2109dbaa3 100644
--- a/drivers/rtc/rtc-davinci.c
+++ b/drivers/rtc/rtc-davinci.c
@@ -542,7 +542,7 @@ static int __init davinci_rtc_probe(struct platform_device *pdev)
 	rtcss_write(davinci_rtc, 0, PRTCSS_RTC_CCTRL);
 
 	ret = request_irq(davinci_rtc->irq, davinci_rtc_interrupt,
-			  IRQF_DISABLED, "davinci_rtc", davinci_rtc);
+			  0, "davinci_rtc", davinci_rtc);
 	if (ret < 0) {
 		dev_err(dev, "unable to register davinci RTC interrupt\n");
 		goto fail4;

commit f4e708ae8e5f3eb98f4c53036c0a470717bbc709
Author: Wolfram Sang <w.sang@pengutronix.de>
Date:   Thu May 5 11:46:14 2011 +0200

    rtc: davinci: Initialize drvdata before registering device
    
    Commit f44f7f96a20 ("RTC: Initialize kernel state from RTC") uncovered
    an issue in a number of RTC drivers, where the drivers call
    rtc_device_register before initializing the device or platform drvdata.
    
    This frequently results in null pointer dereferences when the
    rtc_device_register immediately makes use of the rtc device, calling
    rtc_read_alarm.
    
    The solution is to ensure the drvdata is initialized prior to registering
    the rtc device.
    
    CC: Alessandro Zummo <a.zummo@towertech.it>
    CC: Thomas Gleixner <tglx@linutronix.de>
    CC: rtc-linux@googlegroups.com
    Signed-off-by: Wolfram Sang <w.sang@pengutronix.de>
    [fixed up commit log -jstultz]
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/drivers/rtc/rtc-davinci.c b/drivers/rtc/rtc-davinci.c
index 8d46838dff8a..755e1fe914af 100644
--- a/drivers/rtc/rtc-davinci.c
+++ b/drivers/rtc/rtc-davinci.c
@@ -524,6 +524,8 @@ static int __init davinci_rtc_probe(struct platform_device *pdev)
 		goto fail2;
 	}
 
+	platform_set_drvdata(pdev, davinci_rtc);
+
 	davinci_rtc->rtc = rtc_device_register(pdev->name, &pdev->dev,
 				    &davinci_rtc_ops, THIS_MODULE);
 	if (IS_ERR(davinci_rtc->rtc)) {
@@ -553,8 +555,6 @@ static int __init davinci_rtc_probe(struct platform_device *pdev)
 
 	rtcss_write(davinci_rtc, PRTCSS_RTC_CCTRL_CAEN, PRTCSS_RTC_CCTRL);
 
-	platform_set_drvdata(pdev, davinci_rtc);
-
 	device_init_wakeup(&pdev->dev, 0);
 
 	return 0;
@@ -562,6 +562,7 @@ static int __init davinci_rtc_probe(struct platform_device *pdev)
 fail4:
 	rtc_device_unregister(davinci_rtc->rtc);
 fail3:
+	platform_set_drvdata(pdev, NULL);
 	iounmap(davinci_rtc->base);
 fail2:
 	release_mem_region(davinci_rtc->pbase, davinci_rtc->base_size);

commit e428c6a2772bcf6b022baf7c8267cca3634c0c3e
Author: John Stultz <john.stultz@linaro.org>
Date:   Fri Feb 4 16:16:12 2011 -0800

    RTC: Clean out UIE icotl implementations
    
    With the generic RTC rework, the UIE mode irqs are handled
    in the generic layer, and only hardware specific ioctls
    get passed down to the rtc driver layer.
    
    So this patch removes the UIE mode ioctl handling in the rtc
    driver layer, which never get used.
    
    CC: Thomas Gleixner <tglx@linutronix.de>
    CC: Alessandro Zummo <a.zummo@towertech.it>
    CC: Marcelo Roberto Jimenez <mroberto@cpti.cetuc.puc-rio.br>
    CC: rtc-linux@googlegroups.com
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/drivers/rtc/rtc-davinci.c b/drivers/rtc/rtc-davinci.c
index dfd98a235ad1..8d46838dff8a 100644
--- a/drivers/rtc/rtc-davinci.c
+++ b/drivers/rtc/rtc-davinci.c
@@ -231,10 +231,6 @@ davinci_rtc_ioctl(struct device *dev, unsigned int cmd, unsigned long arg)
 	case RTC_WIE_OFF:
 		rtc_ctrl &= ~PRTCSS_RTC_CTRL_WEN;
 		break;
-	case RTC_UIE_OFF:
-	case RTC_UIE_ON:
-		ret = -ENOTTY;
-		break;
 	default:
 		ret = -ENOIOCTLCMD;
 	}

commit 696160fec162601d06940862b5b3aa4460344c1b
Author: John Stultz <john.stultz@linaro.org>
Date:   Thu Feb 3 12:02:07 2011 -0800

    RTC: Cleanup rtc_class_ops->irq_set_freq()
    
    With the generic rtc code now emulating PIE mode irqs via an
    hrtimer, no one calls the rtc_class_ops->irq_set_freq call.
    
    This patch removes the hook and deletes the driver functions
    if no one else calls them.
    
    CC: Thomas Gleixner <tglx@linutronix.de>
    CC: Alessandro Zummo <a.zummo@towertech.it>
    CC: Marcelo Roberto Jimenez <mroberto@cpti.cetuc.puc-rio.br>
    CC: rtc-linux@googlegroups.com
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/drivers/rtc/rtc-davinci.c b/drivers/rtc/rtc-davinci.c
index 92da73d40e13..dfd98a235ad1 100644
--- a/drivers/rtc/rtc-davinci.c
+++ b/drivers/rtc/rtc-davinci.c
@@ -473,22 +473,6 @@ static int davinci_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alm)
 	return 0;
 }
 
-static int davinci_rtc_irq_set_freq(struct device *dev, int freq)
-{
-	struct davinci_rtc *davinci_rtc = dev_get_drvdata(dev);
-	unsigned long flags;
-	u16 tmr_counter = (0x8000 >> (ffs(freq) - 1));
-
-	spin_lock_irqsave(&davinci_rtc_lock, flags);
-
-	rtcss_write(davinci_rtc, tmr_counter & 0xFF, PRTCSS_RTC_TMR0);
-	rtcss_write(davinci_rtc, (tmr_counter & 0xFF00) >> 8, PRTCSS_RTC_TMR1);
-
-	spin_unlock_irqrestore(&davinci_rtc_lock, flags);
-
-	return 0;
-}
-
 static struct rtc_class_ops davinci_rtc_ops = {
 	.ioctl			= davinci_rtc_ioctl,
 	.read_time		= davinci_rtc_read_time,
@@ -496,7 +480,6 @@ static struct rtc_class_ops davinci_rtc_ops = {
 	.alarm_irq_enable	= davinci_rtc_alarm_irq_enable,
 	.read_alarm		= davinci_rtc_read_alarm,
 	.set_alarm		= davinci_rtc_set_alarm,
-	.irq_set_freq		= davinci_rtc_irq_set_freq,
 };
 
 static int __init davinci_rtc_probe(struct platform_device *pdev)

commit 80d4bb515b78f38738f3378fd1be6039063ab040
Author: John Stultz <john.stultz@linaro.org>
Date:   Thu Feb 3 11:34:50 2011 -0800

    RTC: Cleanup rtc_class_ops->irq_set_state
    
    With PIE mode interrupts now emulated in generic code via an hrtimer,
    no one calls rtc_class_ops->irq_set_state(), so this patch removes it
    along with driver implementations.
    
    CC: Thomas Gleixner <tglx@linutronix.de>
    CC: Alessandro Zummo <a.zummo@towertech.it>
    CC: Marcelo Roberto Jimenez <mroberto@cpti.cetuc.puc-rio.br>
    CC: rtc-linux@googlegroups.com
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/drivers/rtc/rtc-davinci.c b/drivers/rtc/rtc-davinci.c
index 34647fc1ee98..92da73d40e13 100644
--- a/drivers/rtc/rtc-davinci.c
+++ b/drivers/rtc/rtc-davinci.c
@@ -473,39 +473,6 @@ static int davinci_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alm)
 	return 0;
 }
 
-static int davinci_rtc_irq_set_state(struct device *dev, int enabled)
-{
-	struct davinci_rtc *davinci_rtc = dev_get_drvdata(dev);
-	unsigned long flags;
-	u8 rtc_ctrl;
-
-	spin_lock_irqsave(&davinci_rtc_lock, flags);
-
-	rtc_ctrl = rtcss_read(davinci_rtc, PRTCSS_RTC_CTRL);
-
-	if (enabled) {
-		while (rtcss_read(davinci_rtc, PRTCSS_RTC_CTRL)
-		       & PRTCSS_RTC_CTRL_WDTBUS)
-			cpu_relax();
-
-		rtc_ctrl |= PRTCSS_RTC_CTRL_TE;
-		rtcss_write(davinci_rtc, rtc_ctrl, PRTCSS_RTC_CTRL);
-
-		rtcss_write(davinci_rtc, 0x0, PRTCSS_RTC_CLKC_CNT);
-
-		rtc_ctrl |= PRTCSS_RTC_CTRL_TIEN |
-			    PRTCSS_RTC_CTRL_TMMD |
-			    PRTCSS_RTC_CTRL_TMRFLG;
-	} else
-		rtc_ctrl &= ~PRTCSS_RTC_CTRL_TIEN;
-
-	rtcss_write(davinci_rtc, rtc_ctrl, PRTCSS_RTC_CTRL);
-
-	spin_unlock_irqrestore(&davinci_rtc_lock, flags);
-
-	return 0;
-}
-
 static int davinci_rtc_irq_set_freq(struct device *dev, int freq)
 {
 	struct davinci_rtc *davinci_rtc = dev_get_drvdata(dev);
@@ -529,7 +496,6 @@ static struct rtc_class_ops davinci_rtc_ops = {
 	.alarm_irq_enable	= davinci_rtc_alarm_irq_enable,
 	.read_alarm		= davinci_rtc_read_alarm,
 	.set_alarm		= davinci_rtc_set_alarm,
-	.irq_set_state		= davinci_rtc_irq_set_state,
 	.irq_set_freq		= davinci_rtc_irq_set_freq,
 };
 

commit f244f31a0d31402c2c1b1950108e0013353cc3f3
Author: Tejun Heo <tj@kernel.org>
Date:   Tue Mar 30 02:52:36 2010 +0900

    davinci: update gfp/slab.h includes
    
    Implicit slab.h inclusion via percpu.h is about to go away.  Make sure
    gfp.h or slab.h is included as necessary.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Stephen Rothwell <sfr@canb.auug.org.au>
    Cc: Kevin Hilman <khilman@deeprootsystems.com>
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>

diff --git a/drivers/rtc/rtc-davinci.c b/drivers/rtc/rtc-davinci.c
index 92a8f6cacda9..34647fc1ee98 100644
--- a/drivers/rtc/rtc-davinci.c
+++ b/drivers/rtc/rtc-davinci.c
@@ -29,6 +29,7 @@
 #include <linux/bcd.h>
 #include <linux/platform_device.h>
 #include <linux/io.h>
+#include <linux/slab.h>
 
 /*
  * The DaVinci RTC is a simple RTC with the following

commit 8ecf6c54d44c535b2296319aa58567ea9a1db026
Author: Miguel Aguilar <miguel.aguilar@ridgerun.com>
Date:   Thu Nov 5 08:51:34 2009 -0600

    RTC: DaVinci RTC driver
    
    This driver features:
    
    * Alarm support.
    * Periodic interrupt by using a timer include into the RTC module.
    * The update interrupt is not supported by this RTC module.
    
    This driver was tested on a DM365 EVM by using the rtc-test application
    from the Documentation/rtc.txt.
    
    Signed-off-by: Miguel Aguilar <miguel.aguilar@ridgerun.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>
    Acked-by: Alessandro Zummo <a.zummo@towertech.it>

diff --git a/drivers/rtc/rtc-davinci.c b/drivers/rtc/rtc-davinci.c
new file mode 100644
index 000000000000..92a8f6cacda9
--- /dev/null
+++ b/drivers/rtc/rtc-davinci.c
@@ -0,0 +1,673 @@
+/*
+ * DaVinci Power Management and Real Time Clock Driver for TI platforms
+ *
+ * Copyright (C) 2009 Texas Instruments, Inc
+ *
+ * Author: Miguel Aguilar <miguel.aguilar@ridgerun.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/ioport.h>
+#include <linux/delay.h>
+#include <linux/spinlock.h>
+#include <linux/rtc.h>
+#include <linux/bcd.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+
+/*
+ * The DaVinci RTC is a simple RTC with the following
+ * Sec: 0 - 59 : BCD count
+ * Min: 0 - 59 : BCD count
+ * Hour: 0 - 23 : BCD count
+ * Day: 0 - 0x7FFF(32767) : Binary count ( Over 89 years )
+ */
+
+/* PRTC interface registers */
+#define DAVINCI_PRTCIF_PID		0x00
+#define PRTCIF_CTLR			0x04
+#define PRTCIF_LDATA			0x08
+#define PRTCIF_UDATA			0x0C
+#define PRTCIF_INTEN			0x10
+#define PRTCIF_INTFLG			0x14
+
+/* PRTCIF_CTLR bit fields */
+#define PRTCIF_CTLR_BUSY		BIT(31)
+#define PRTCIF_CTLR_SIZE		BIT(25)
+#define PRTCIF_CTLR_DIR			BIT(24)
+#define PRTCIF_CTLR_BENU_MSB		BIT(23)
+#define PRTCIF_CTLR_BENU_3RD_BYTE	BIT(22)
+#define PRTCIF_CTLR_BENU_2ND_BYTE	BIT(21)
+#define PRTCIF_CTLR_BENU_LSB		BIT(20)
+#define PRTCIF_CTLR_BENU_MASK		(0x00F00000)
+#define PRTCIF_CTLR_BENL_MSB		BIT(19)
+#define PRTCIF_CTLR_BENL_3RD_BYTE	BIT(18)
+#define PRTCIF_CTLR_BENL_2ND_BYTE	BIT(17)
+#define PRTCIF_CTLR_BENL_LSB		BIT(16)
+#define PRTCIF_CTLR_BENL_MASK		(0x000F0000)
+
+/* PRTCIF_INTEN bit fields */
+#define PRTCIF_INTEN_RTCSS		BIT(1)
+#define PRTCIF_INTEN_RTCIF		BIT(0)
+#define PRTCIF_INTEN_MASK		(PRTCIF_INTEN_RTCSS \
+					| PRTCIF_INTEN_RTCIF)
+
+/* PRTCIF_INTFLG bit fields */
+#define PRTCIF_INTFLG_RTCSS		BIT(1)
+#define PRTCIF_INTFLG_RTCIF		BIT(0)
+#define PRTCIF_INTFLG_MASK		(PRTCIF_INTFLG_RTCSS \
+					| PRTCIF_INTFLG_RTCIF)
+
+/* PRTC subsystem registers */
+#define PRTCSS_RTC_INTC_EXTENA1		(0x0C)
+#define PRTCSS_RTC_CTRL			(0x10)
+#define PRTCSS_RTC_WDT			(0x11)
+#define PRTCSS_RTC_TMR0			(0x12)
+#define PRTCSS_RTC_TMR1			(0x13)
+#define PRTCSS_RTC_CCTRL		(0x14)
+#define PRTCSS_RTC_SEC			(0x15)
+#define PRTCSS_RTC_MIN			(0x16)
+#define PRTCSS_RTC_HOUR			(0x17)
+#define PRTCSS_RTC_DAY0			(0x18)
+#define PRTCSS_RTC_DAY1			(0x19)
+#define PRTCSS_RTC_AMIN			(0x1A)
+#define PRTCSS_RTC_AHOUR		(0x1B)
+#define PRTCSS_RTC_ADAY0		(0x1C)
+#define PRTCSS_RTC_ADAY1		(0x1D)
+#define PRTCSS_RTC_CLKC_CNT		(0x20)
+
+/* PRTCSS_RTC_INTC_EXTENA1 */
+#define PRTCSS_RTC_INTC_EXTENA1_MASK	(0x07)
+
+/* PRTCSS_RTC_CTRL bit fields */
+#define PRTCSS_RTC_CTRL_WDTBUS		BIT(7)
+#define PRTCSS_RTC_CTRL_WEN		BIT(6)
+#define PRTCSS_RTC_CTRL_WDRT		BIT(5)
+#define PRTCSS_RTC_CTRL_WDTFLG		BIT(4)
+#define PRTCSS_RTC_CTRL_TE		BIT(3)
+#define PRTCSS_RTC_CTRL_TIEN		BIT(2)
+#define PRTCSS_RTC_CTRL_TMRFLG		BIT(1)
+#define PRTCSS_RTC_CTRL_TMMD		BIT(0)
+
+/* PRTCSS_RTC_CCTRL bit fields */
+#define PRTCSS_RTC_CCTRL_CALBUSY	BIT(7)
+#define PRTCSS_RTC_CCTRL_DAEN		BIT(5)
+#define PRTCSS_RTC_CCTRL_HAEN		BIT(4)
+#define PRTCSS_RTC_CCTRL_MAEN		BIT(3)
+#define PRTCSS_RTC_CCTRL_ALMFLG		BIT(2)
+#define PRTCSS_RTC_CCTRL_AIEN		BIT(1)
+#define PRTCSS_RTC_CCTRL_CAEN		BIT(0)
+
+static DEFINE_SPINLOCK(davinci_rtc_lock);
+
+struct davinci_rtc {
+	struct rtc_device 		*rtc;
+	void __iomem			*base;
+	resource_size_t			pbase;
+	size_t				base_size;
+	int				irq;
+};
+
+static inline void rtcif_write(struct davinci_rtc *davinci_rtc,
+			       u32 val, u32 addr)
+{
+	writel(val, davinci_rtc->base + addr);
+}
+
+static inline u32 rtcif_read(struct davinci_rtc *davinci_rtc, u32 addr)
+{
+	return readl(davinci_rtc->base + addr);
+}
+
+static inline void rtcif_wait(struct davinci_rtc *davinci_rtc)
+{
+	while (rtcif_read(davinci_rtc, PRTCIF_CTLR) & PRTCIF_CTLR_BUSY)
+		cpu_relax();
+}
+
+static inline void rtcss_write(struct davinci_rtc *davinci_rtc,
+			       unsigned long val, u8 addr)
+{
+	rtcif_wait(davinci_rtc);
+
+	rtcif_write(davinci_rtc, PRTCIF_CTLR_BENL_LSB | addr, PRTCIF_CTLR);
+	rtcif_write(davinci_rtc, val, PRTCIF_LDATA);
+
+	rtcif_wait(davinci_rtc);
+}
+
+static inline u8 rtcss_read(struct davinci_rtc *davinci_rtc, u8 addr)
+{
+	rtcif_wait(davinci_rtc);
+
+	rtcif_write(davinci_rtc, PRTCIF_CTLR_DIR | PRTCIF_CTLR_BENL_LSB | addr,
+		    PRTCIF_CTLR);
+
+	rtcif_wait(davinci_rtc);
+
+	return rtcif_read(davinci_rtc, PRTCIF_LDATA);
+}
+
+static inline void davinci_rtcss_calendar_wait(struct davinci_rtc *davinci_rtc)
+{
+	while (rtcss_read(davinci_rtc, PRTCSS_RTC_CCTRL) &
+	       PRTCSS_RTC_CCTRL_CALBUSY)
+		cpu_relax();
+}
+
+static irqreturn_t davinci_rtc_interrupt(int irq, void *class_dev)
+{
+	struct davinci_rtc *davinci_rtc = class_dev;
+	unsigned long events = 0;
+	u32 irq_flg;
+	u8 alm_irq, tmr_irq;
+	u8 rtc_ctrl, rtc_cctrl;
+	int ret = IRQ_NONE;
+
+	irq_flg = rtcif_read(davinci_rtc, PRTCIF_INTFLG) &
+		  PRTCIF_INTFLG_RTCSS;
+
+	alm_irq = rtcss_read(davinci_rtc, PRTCSS_RTC_CCTRL) &
+		  PRTCSS_RTC_CCTRL_ALMFLG;
+
+	tmr_irq = rtcss_read(davinci_rtc, PRTCSS_RTC_CTRL) &
+		  PRTCSS_RTC_CTRL_TMRFLG;
+
+	if (irq_flg) {
+		if (alm_irq) {
+			events |= RTC_IRQF | RTC_AF;
+			rtc_cctrl = rtcss_read(davinci_rtc, PRTCSS_RTC_CCTRL);
+			rtc_cctrl |=  PRTCSS_RTC_CCTRL_ALMFLG;
+			rtcss_write(davinci_rtc, rtc_cctrl, PRTCSS_RTC_CCTRL);
+		} else if (tmr_irq) {
+			events |= RTC_IRQF | RTC_PF;
+			rtc_ctrl = rtcss_read(davinci_rtc, PRTCSS_RTC_CTRL);
+			rtc_ctrl |=  PRTCSS_RTC_CTRL_TMRFLG;
+			rtcss_write(davinci_rtc, rtc_ctrl, PRTCSS_RTC_CTRL);
+		}
+
+		rtcif_write(davinci_rtc, PRTCIF_INTFLG_RTCSS,
+				    PRTCIF_INTFLG);
+		rtc_update_irq(davinci_rtc->rtc, 1, events);
+
+		ret = IRQ_HANDLED;
+	}
+
+	return ret;
+}
+
+static int
+davinci_rtc_ioctl(struct device *dev, unsigned int cmd, unsigned long arg)
+{
+	struct davinci_rtc *davinci_rtc = dev_get_drvdata(dev);
+	u8 rtc_ctrl;
+	unsigned long flags;
+	int ret = 0;
+
+	spin_lock_irqsave(&davinci_rtc_lock, flags);
+
+	rtc_ctrl = rtcss_read(davinci_rtc, PRTCSS_RTC_CTRL);
+
+	switch (cmd) {
+	case RTC_WIE_ON:
+		rtc_ctrl |= PRTCSS_RTC_CTRL_WEN | PRTCSS_RTC_CTRL_WDTFLG;
+		break;
+	case RTC_WIE_OFF:
+		rtc_ctrl &= ~PRTCSS_RTC_CTRL_WEN;
+		break;
+	case RTC_UIE_OFF:
+	case RTC_UIE_ON:
+		ret = -ENOTTY;
+		break;
+	default:
+		ret = -ENOIOCTLCMD;
+	}
+
+	rtcss_write(davinci_rtc, rtc_ctrl, PRTCSS_RTC_CTRL);
+
+	spin_unlock_irqrestore(&davinci_rtc_lock, flags);
+
+	return ret;
+}
+
+static int convertfromdays(u16 days, struct rtc_time *tm)
+{
+	int tmp_days, year, mon;
+
+	for (year = 2000;; year++) {
+		tmp_days = rtc_year_days(1, 12, year);
+		if (days >= tmp_days)
+			days -= tmp_days;
+		else {
+			for (mon = 0;; mon++) {
+				tmp_days = rtc_month_days(mon, year);
+				if (days >= tmp_days) {
+					days -= tmp_days;
+				} else {
+					tm->tm_year = year - 1900;
+					tm->tm_mon = mon;
+					tm->tm_mday = days + 1;
+					break;
+				}
+			}
+			break;
+		}
+	}
+	return 0;
+}
+
+static int convert2days(u16 *days, struct rtc_time *tm)
+{
+	int i;
+	*days = 0;
+
+	/* epoch == 1900 */
+	if (tm->tm_year < 100 || tm->tm_year > 199)
+		return -EINVAL;
+
+	for (i = 2000; i < 1900 + tm->tm_year; i++)
+		*days += rtc_year_days(1, 12, i);
+
+	*days += rtc_year_days(tm->tm_mday, tm->tm_mon, 1900 + tm->tm_year);
+
+	return 0;
+}
+
+static int davinci_rtc_read_time(struct device *dev, struct rtc_time *tm)
+{
+	struct davinci_rtc *davinci_rtc = dev_get_drvdata(dev);
+	u16 days = 0;
+	u8 day0, day1;
+	unsigned long flags;
+
+	spin_lock_irqsave(&davinci_rtc_lock, flags);
+
+	davinci_rtcss_calendar_wait(davinci_rtc);
+	tm->tm_sec = bcd2bin(rtcss_read(davinci_rtc, PRTCSS_RTC_SEC));
+
+	davinci_rtcss_calendar_wait(davinci_rtc);
+	tm->tm_min = bcd2bin(rtcss_read(davinci_rtc, PRTCSS_RTC_MIN));
+
+	davinci_rtcss_calendar_wait(davinci_rtc);
+	tm->tm_hour = bcd2bin(rtcss_read(davinci_rtc, PRTCSS_RTC_HOUR));
+
+	davinci_rtcss_calendar_wait(davinci_rtc);
+	day0 = rtcss_read(davinci_rtc, PRTCSS_RTC_DAY0);
+
+	davinci_rtcss_calendar_wait(davinci_rtc);
+	day1 = rtcss_read(davinci_rtc, PRTCSS_RTC_DAY1);
+
+	spin_unlock_irqrestore(&davinci_rtc_lock, flags);
+
+	days |= day1;
+	days <<= 8;
+	days |= day0;
+
+	if (convertfromdays(days, tm) < 0)
+		return -EINVAL;
+
+	return 0;
+}
+
+static int davinci_rtc_set_time(struct device *dev, struct rtc_time *tm)
+{
+	struct davinci_rtc *davinci_rtc = dev_get_drvdata(dev);
+	u16 days;
+	u8 rtc_cctrl;
+	unsigned long flags;
+
+	if (convert2days(&days, tm) < 0)
+		return -EINVAL;
+
+	spin_lock_irqsave(&davinci_rtc_lock, flags);
+
+	davinci_rtcss_calendar_wait(davinci_rtc);
+	rtcss_write(davinci_rtc, bin2bcd(tm->tm_sec), PRTCSS_RTC_SEC);
+
+	davinci_rtcss_calendar_wait(davinci_rtc);
+	rtcss_write(davinci_rtc, bin2bcd(tm->tm_min), PRTCSS_RTC_MIN);
+
+	davinci_rtcss_calendar_wait(davinci_rtc);
+	rtcss_write(davinci_rtc, bin2bcd(tm->tm_hour), PRTCSS_RTC_HOUR);
+
+	davinci_rtcss_calendar_wait(davinci_rtc);
+	rtcss_write(davinci_rtc, days & 0xFF, PRTCSS_RTC_DAY0);
+
+	davinci_rtcss_calendar_wait(davinci_rtc);
+	rtcss_write(davinci_rtc, (days & 0xFF00) >> 8, PRTCSS_RTC_DAY1);
+
+	rtc_cctrl = rtcss_read(davinci_rtc, PRTCSS_RTC_CCTRL);
+	rtc_cctrl |= PRTCSS_RTC_CCTRL_CAEN;
+	rtcss_write(davinci_rtc, rtc_cctrl, PRTCSS_RTC_CCTRL);
+
+	spin_unlock_irqrestore(&davinci_rtc_lock, flags);
+
+	return 0;
+}
+
+static int davinci_rtc_alarm_irq_enable(struct device *dev,
+					unsigned int enabled)
+{
+	struct davinci_rtc *davinci_rtc = dev_get_drvdata(dev);
+	unsigned long flags;
+	u8 rtc_cctrl = rtcss_read(davinci_rtc, PRTCSS_RTC_CCTRL);
+
+	spin_lock_irqsave(&davinci_rtc_lock, flags);
+
+	if (enabled)
+		rtc_cctrl |= PRTCSS_RTC_CCTRL_DAEN |
+			     PRTCSS_RTC_CCTRL_HAEN |
+			     PRTCSS_RTC_CCTRL_MAEN |
+			     PRTCSS_RTC_CCTRL_ALMFLG |
+			     PRTCSS_RTC_CCTRL_AIEN;
+	else
+		rtc_cctrl &= ~PRTCSS_RTC_CCTRL_AIEN;
+
+	davinci_rtcss_calendar_wait(davinci_rtc);
+	rtcss_write(davinci_rtc, rtc_cctrl, PRTCSS_RTC_CCTRL);
+
+	spin_unlock_irqrestore(&davinci_rtc_lock, flags);
+
+	return 0;
+}
+
+static int davinci_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alm)
+{
+	struct davinci_rtc *davinci_rtc = dev_get_drvdata(dev);
+	u16 days = 0;
+	u8 day0, day1;
+	unsigned long flags;
+
+	spin_lock_irqsave(&davinci_rtc_lock, flags);
+
+	davinci_rtcss_calendar_wait(davinci_rtc);
+	alm->time.tm_min = bcd2bin(rtcss_read(davinci_rtc, PRTCSS_RTC_AMIN));
+
+	davinci_rtcss_calendar_wait(davinci_rtc);
+	alm->time.tm_hour = bcd2bin(rtcss_read(davinci_rtc, PRTCSS_RTC_AHOUR));
+
+	davinci_rtcss_calendar_wait(davinci_rtc);
+	day0 = rtcss_read(davinci_rtc, PRTCSS_RTC_ADAY0);
+
+	davinci_rtcss_calendar_wait(davinci_rtc);
+	day1 = rtcss_read(davinci_rtc, PRTCSS_RTC_ADAY1);
+
+	spin_unlock_irqrestore(&davinci_rtc_lock, flags);
+	days |= day1;
+	days <<= 8;
+	days |= day0;
+
+	if (convertfromdays(days, &alm->time) < 0)
+		return -EINVAL;
+
+	alm->pending = !!(rtcss_read(davinci_rtc,
+			  PRTCSS_RTC_CCTRL) &
+			PRTCSS_RTC_CCTRL_AIEN);
+	alm->enabled = alm->pending && device_may_wakeup(dev);
+
+	return 0;
+}
+
+static int davinci_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alm)
+{
+	struct davinci_rtc *davinci_rtc = dev_get_drvdata(dev);
+	unsigned long flags;
+	u16 days;
+
+	if (alm->time.tm_mday <= 0 && alm->time.tm_mon < 0
+	    && alm->time.tm_year < 0) {
+		struct rtc_time tm;
+		unsigned long now, then;
+
+		davinci_rtc_read_time(dev, &tm);
+		rtc_tm_to_time(&tm, &now);
+
+		alm->time.tm_mday = tm.tm_mday;
+		alm->time.tm_mon = tm.tm_mon;
+		alm->time.tm_year = tm.tm_year;
+		rtc_tm_to_time(&alm->time, &then);
+
+		if (then < now) {
+			rtc_time_to_tm(now + 24 * 60 * 60, &tm);
+			alm->time.tm_mday = tm.tm_mday;
+			alm->time.tm_mon = tm.tm_mon;
+			alm->time.tm_year = tm.tm_year;
+		}
+	}
+
+	if (convert2days(&days, &alm->time) < 0)
+		return -EINVAL;
+
+	spin_lock_irqsave(&davinci_rtc_lock, flags);
+
+	davinci_rtcss_calendar_wait(davinci_rtc);
+	rtcss_write(davinci_rtc, bin2bcd(alm->time.tm_min), PRTCSS_RTC_AMIN);
+
+	davinci_rtcss_calendar_wait(davinci_rtc);
+	rtcss_write(davinci_rtc, bin2bcd(alm->time.tm_hour), PRTCSS_RTC_AHOUR);
+
+	davinci_rtcss_calendar_wait(davinci_rtc);
+	rtcss_write(davinci_rtc, days & 0xFF, PRTCSS_RTC_ADAY0);
+
+	davinci_rtcss_calendar_wait(davinci_rtc);
+	rtcss_write(davinci_rtc, (days & 0xFF00) >> 8, PRTCSS_RTC_ADAY1);
+
+	spin_unlock_irqrestore(&davinci_rtc_lock, flags);
+
+	return 0;
+}
+
+static int davinci_rtc_irq_set_state(struct device *dev, int enabled)
+{
+	struct davinci_rtc *davinci_rtc = dev_get_drvdata(dev);
+	unsigned long flags;
+	u8 rtc_ctrl;
+
+	spin_lock_irqsave(&davinci_rtc_lock, flags);
+
+	rtc_ctrl = rtcss_read(davinci_rtc, PRTCSS_RTC_CTRL);
+
+	if (enabled) {
+		while (rtcss_read(davinci_rtc, PRTCSS_RTC_CTRL)
+		       & PRTCSS_RTC_CTRL_WDTBUS)
+			cpu_relax();
+
+		rtc_ctrl |= PRTCSS_RTC_CTRL_TE;
+		rtcss_write(davinci_rtc, rtc_ctrl, PRTCSS_RTC_CTRL);
+
+		rtcss_write(davinci_rtc, 0x0, PRTCSS_RTC_CLKC_CNT);
+
+		rtc_ctrl |= PRTCSS_RTC_CTRL_TIEN |
+			    PRTCSS_RTC_CTRL_TMMD |
+			    PRTCSS_RTC_CTRL_TMRFLG;
+	} else
+		rtc_ctrl &= ~PRTCSS_RTC_CTRL_TIEN;
+
+	rtcss_write(davinci_rtc, rtc_ctrl, PRTCSS_RTC_CTRL);
+
+	spin_unlock_irqrestore(&davinci_rtc_lock, flags);
+
+	return 0;
+}
+
+static int davinci_rtc_irq_set_freq(struct device *dev, int freq)
+{
+	struct davinci_rtc *davinci_rtc = dev_get_drvdata(dev);
+	unsigned long flags;
+	u16 tmr_counter = (0x8000 >> (ffs(freq) - 1));
+
+	spin_lock_irqsave(&davinci_rtc_lock, flags);
+
+	rtcss_write(davinci_rtc, tmr_counter & 0xFF, PRTCSS_RTC_TMR0);
+	rtcss_write(davinci_rtc, (tmr_counter & 0xFF00) >> 8, PRTCSS_RTC_TMR1);
+
+	spin_unlock_irqrestore(&davinci_rtc_lock, flags);
+
+	return 0;
+}
+
+static struct rtc_class_ops davinci_rtc_ops = {
+	.ioctl			= davinci_rtc_ioctl,
+	.read_time		= davinci_rtc_read_time,
+	.set_time		= davinci_rtc_set_time,
+	.alarm_irq_enable	= davinci_rtc_alarm_irq_enable,
+	.read_alarm		= davinci_rtc_read_alarm,
+	.set_alarm		= davinci_rtc_set_alarm,
+	.irq_set_state		= davinci_rtc_irq_set_state,
+	.irq_set_freq		= davinci_rtc_irq_set_freq,
+};
+
+static int __init davinci_rtc_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct davinci_rtc *davinci_rtc;
+	struct resource *res, *mem;
+	int ret = 0;
+
+	davinci_rtc = kzalloc(sizeof(struct davinci_rtc), GFP_KERNEL);
+	if (!davinci_rtc) {
+		dev_dbg(dev, "could not allocate memory for private data\n");
+		return -ENOMEM;
+	}
+
+	davinci_rtc->irq = platform_get_irq(pdev, 0);
+	if (davinci_rtc->irq < 0) {
+		dev_err(dev, "no RTC irq\n");
+		ret = davinci_rtc->irq;
+		goto fail1;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(dev, "no mem resource\n");
+		ret = -EINVAL;
+		goto fail1;
+	}
+
+	davinci_rtc->pbase = res->start;
+	davinci_rtc->base_size = resource_size(res);
+
+	mem = request_mem_region(davinci_rtc->pbase, davinci_rtc->base_size,
+				 pdev->name);
+	if (!mem) {
+		dev_err(dev, "RTC registers at %08x are not free\n",
+			davinci_rtc->pbase);
+		ret = -EBUSY;
+		goto fail1;
+	}
+
+	davinci_rtc->base = ioremap(davinci_rtc->pbase, davinci_rtc->base_size);
+	if (!davinci_rtc->base) {
+		dev_err(dev, "unable to ioremap MEM resource\n");
+		ret = -ENOMEM;
+		goto fail2;
+	}
+
+	davinci_rtc->rtc = rtc_device_register(pdev->name, &pdev->dev,
+				    &davinci_rtc_ops, THIS_MODULE);
+	if (IS_ERR(davinci_rtc->rtc)) {
+		dev_err(dev, "unable to register RTC device, err %ld\n",
+				PTR_ERR(davinci_rtc->rtc));
+		goto fail3;
+	}
+
+	rtcif_write(davinci_rtc, PRTCIF_INTFLG_RTCSS, PRTCIF_INTFLG);
+	rtcif_write(davinci_rtc, 0, PRTCIF_INTEN);
+	rtcss_write(davinci_rtc, 0, PRTCSS_RTC_INTC_EXTENA1);
+
+	rtcss_write(davinci_rtc, 0, PRTCSS_RTC_CTRL);
+	rtcss_write(davinci_rtc, 0, PRTCSS_RTC_CCTRL);
+
+	ret = request_irq(davinci_rtc->irq, davinci_rtc_interrupt,
+			  IRQF_DISABLED, "davinci_rtc", davinci_rtc);
+	if (ret < 0) {
+		dev_err(dev, "unable to register davinci RTC interrupt\n");
+		goto fail4;
+	}
+
+	/* Enable interrupts */
+	rtcif_write(davinci_rtc, PRTCIF_INTEN_RTCSS, PRTCIF_INTEN);
+	rtcss_write(davinci_rtc, PRTCSS_RTC_INTC_EXTENA1_MASK,
+			    PRTCSS_RTC_INTC_EXTENA1);
+
+	rtcss_write(davinci_rtc, PRTCSS_RTC_CCTRL_CAEN, PRTCSS_RTC_CCTRL);
+
+	platform_set_drvdata(pdev, davinci_rtc);
+
+	device_init_wakeup(&pdev->dev, 0);
+
+	return 0;
+
+fail4:
+	rtc_device_unregister(davinci_rtc->rtc);
+fail3:
+	iounmap(davinci_rtc->base);
+fail2:
+	release_mem_region(davinci_rtc->pbase, davinci_rtc->base_size);
+fail1:
+	kfree(davinci_rtc);
+
+	return ret;
+}
+
+static int __devexit davinci_rtc_remove(struct platform_device *pdev)
+{
+	struct davinci_rtc *davinci_rtc = platform_get_drvdata(pdev);
+
+	device_init_wakeup(&pdev->dev, 0);
+
+	rtcif_write(davinci_rtc, 0, PRTCIF_INTEN);
+
+	free_irq(davinci_rtc->irq, davinci_rtc);
+
+	rtc_device_unregister(davinci_rtc->rtc);
+
+	iounmap(davinci_rtc->base);
+	release_mem_region(davinci_rtc->pbase, davinci_rtc->base_size);
+
+	platform_set_drvdata(pdev, NULL);
+
+	kfree(davinci_rtc);
+
+	return 0;
+}
+
+static struct platform_driver davinci_rtc_driver = {
+	.probe		= davinci_rtc_probe,
+	.remove		= __devexit_p(davinci_rtc_remove),
+	.driver		= {
+		.name = "rtc_davinci",
+		.owner = THIS_MODULE,
+	},
+};
+
+static int __init rtc_init(void)
+{
+	return platform_driver_probe(&davinci_rtc_driver, davinci_rtc_probe);
+}
+module_init(rtc_init);
+
+static void __exit rtc_exit(void)
+{
+	platform_driver_unregister(&davinci_rtc_driver);
+}
+module_exit(rtc_exit);
+
+MODULE_AUTHOR("Miguel Aguilar <miguel.aguilar@ridgerun.com>");
+MODULE_DESCRIPTION("Texas Instruments DaVinci PRTC Driver");
+MODULE_LICENSE("GPL");
