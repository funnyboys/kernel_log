commit c8ff5841a90bdd99f28f7062c99b3058005c1c32
Author: Alexandre Belloni <alexandre.belloni@bootlin.com>
Date:   Fri Mar 6 01:58:09 2020 +0100

    rtc: pl031: switch to rtc_time64_to_tm/rtc_tm_to_time64
    
    Call the 64bit versions of rtc_tm time conversion to allow extending
    support after 2106 and properly supporting the STv2 range.
    
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Link: https://lore.kernel.org/r/20200306005809.38530-3-alexandre.belloni@bootlin.com
    Signed-off-by: Alexandre Belloni <alexandre.belloni@bootlin.com>

diff --git a/drivers/rtc/rtc-pl031.c b/drivers/rtc/rtc-pl031.c
index 07dc0f264100..40d7450a1ce4 100644
--- a/drivers/rtc/rtc-pl031.c
+++ b/drivers/rtc/rtc-pl031.c
@@ -125,11 +125,9 @@ static int pl031_stv2_tm_to_time(struct device *dev,
 		return -EINVAL;
 	} else if (wday == -1) {
 		/* wday is not provided, calculate it here */
-		unsigned long time;
 		struct rtc_time calc_tm;
 
-		rtc_tm_to_time(tm, &time);
-		rtc_time_to_tm(time, &calc_tm);
+		rtc_time64_to_tm(rtc_tm_to_time64(tm), &calc_tm);
 		wday = calc_tm.tm_wday;
 	}
 
@@ -246,30 +244,25 @@ static int pl031_read_time(struct device *dev, struct rtc_time *tm)
 {
 	struct pl031_local *ldata = dev_get_drvdata(dev);
 
-	rtc_time_to_tm(readl(ldata->base + RTC_DR), tm);
+	rtc_time64_to_tm(readl(ldata->base + RTC_DR), tm);
 
 	return 0;
 }
 
 static int pl031_set_time(struct device *dev, struct rtc_time *tm)
 {
-	unsigned long time;
 	struct pl031_local *ldata = dev_get_drvdata(dev);
-	int ret;
 
-	ret = rtc_tm_to_time(tm, &time);
-
-	if (ret == 0)
-		writel(time, ldata->base + RTC_LR);
+	writel(rtc_tm_to_time64(tm), ldata->base + RTC_LR);
 
-	return ret;
+	return 0;
 }
 
 static int pl031_read_alarm(struct device *dev, struct rtc_wkalrm *alarm)
 {
 	struct pl031_local *ldata = dev_get_drvdata(dev);
 
-	rtc_time_to_tm(readl(ldata->base + RTC_MR), &alarm->time);
+	rtc_time64_to_tm(readl(ldata->base + RTC_MR), &alarm->time);
 
 	alarm->pending = readl(ldata->base + RTC_RIS) & RTC_BIT_AI;
 	alarm->enabled = readl(ldata->base + RTC_IMSC) & RTC_BIT_AI;
@@ -280,16 +273,10 @@ static int pl031_read_alarm(struct device *dev, struct rtc_wkalrm *alarm)
 static int pl031_set_alarm(struct device *dev, struct rtc_wkalrm *alarm)
 {
 	struct pl031_local *ldata = dev_get_drvdata(dev);
-	unsigned long time;
-	int ret;
 
-	ret = rtc_tm_to_time(&alarm->time, &time);
-	if (ret == 0) {
-		writel(time, ldata->base + RTC_MR);
-		pl031_alarm_irq_enable(dev, alarm->enabled);
-	}
+	writel(rtc_tm_to_time64(&alarm->time), ldata->base + RTC_MR);
 
-	return ret;
+	return 0;
 }
 
 static int pl031_remove(struct amba_device *adev)

commit 03f2a0e45f395bc34b0a44105bc7e935bfd40c27
Author: Alexandre Belloni <alexandre.belloni@bootlin.com>
Date:   Fri Mar 6 01:58:08 2020 +0100

    rtc: pl031: set range
    
    The PL031 and ST v1 RTC are 32bit seconds counters. STv2 is a BCD RTC
    apparently going from 0000 to 9999, hopefully handling the leap days
    properly until then.
    
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Link: https://lore.kernel.org/r/20200306005809.38530-2-alexandre.belloni@bootlin.com
    Signed-off-by: Alexandre Belloni <alexandre.belloni@bootlin.com>

diff --git a/drivers/rtc/rtc-pl031.c b/drivers/rtc/rtc-pl031.c
index 2e8e019a6e4c..07dc0f264100 100644
--- a/drivers/rtc/rtc-pl031.c
+++ b/drivers/rtc/rtc-pl031.c
@@ -80,6 +80,8 @@ struct pl031_vendor_data {
 	bool clockwatch;
 	bool st_weekday;
 	unsigned long irqflags;
+	time64_t range_min;
+	timeu64_t range_max;
 };
 
 struct pl031_local {
@@ -375,6 +377,8 @@ static int pl031_probe(struct amba_device *adev, const struct amba_id *id)
 		return PTR_ERR(ldata->rtc);
 
 	ldata->rtc->ops = ops;
+	ldata->rtc->range_min = vendor->range_min;
+	ldata->rtc->range_max = vendor->range_max;
 
 	ret = rtc_register_device(ldata->rtc);
 	if (ret)
@@ -405,6 +409,7 @@ static struct pl031_vendor_data arm_pl031 = {
 		.set_alarm = pl031_set_alarm,
 		.alarm_irq_enable = pl031_alarm_irq_enable,
 	},
+	.range_max = U32_MAX,
 };
 
 /* The First ST derivative */
@@ -418,6 +423,7 @@ static struct pl031_vendor_data stv1_pl031 = {
 	},
 	.clockwatch = true,
 	.st_weekday = true,
+	.range_max = U32_MAX,
 };
 
 /* And the second ST derivative */
@@ -438,6 +444,8 @@ static struct pl031_vendor_data stv2_pl031 = {
 	 * remove IRQF_COND_SUSPEND
 	 */
 	.irqflags = IRQF_SHARED | IRQF_COND_SUSPEND,
+	.range_min = RTC_TIMESTAMP_BEGIN_0000,
+	.range_max = RTC_TIMESTAMP_END_9999,
 };
 
 static const struct amba_id pl031_ids[] = {

commit 61c9fbff9d62e1de214f15c0f9c692a81430f4ff
Author: Alexandre Belloni <alexandre.belloni@bootlin.com>
Date:   Fri Mar 6 01:58:07 2020 +0100

    rtc: pl031: remove useless invalid alarm handling
    
    The core will never pass an invalid alarm to .set_alarm, it is not
    necessary to check for its validity.
    
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Link: https://lore.kernel.org/r/20200306005809.38530-1-alexandre.belloni@bootlin.com
    Signed-off-by: Alexandre Belloni <alexandre.belloni@bootlin.com>

diff --git a/drivers/rtc/rtc-pl031.c b/drivers/rtc/rtc-pl031.c
index 180caebbd355..2e8e019a6e4c 100644
--- a/drivers/rtc/rtc-pl031.c
+++ b/drivers/rtc/rtc-pl031.c
@@ -210,17 +210,13 @@ static int pl031_stv2_set_alarm(struct device *dev, struct rtc_wkalrm *alarm)
 	unsigned long bcd_year;
 	int ret;
 
-	/* At the moment, we can only deal with non-wildcarded alarm times. */
-	ret = rtc_valid_tm(&alarm->time);
+	ret = pl031_stv2_tm_to_time(dev, &alarm->time,
+				    &time, &bcd_year);
 	if (ret == 0) {
-		ret = pl031_stv2_tm_to_time(dev, &alarm->time,
-					    &time, &bcd_year);
-		if (ret == 0) {
-			writel(bcd_year, ldata->base + RTC_YMR);
-			writel(time, ldata->base + RTC_MR);
+		writel(bcd_year, ldata->base + RTC_YMR);
+		writel(time, ldata->base + RTC_MR);
 
-			pl031_alarm_irq_enable(dev, alarm->enabled);
-		}
+		pl031_alarm_irq_enable(dev, alarm->enabled);
 	}
 
 	return ret;
@@ -285,14 +281,10 @@ static int pl031_set_alarm(struct device *dev, struct rtc_wkalrm *alarm)
 	unsigned long time;
 	int ret;
 
-	/* At the moment, we can only deal with non-wildcarded alarm times. */
-	ret = rtc_valid_tm(&alarm->time);
+	ret = rtc_tm_to_time(&alarm->time, &time);
 	if (ret == 0) {
-		ret = rtc_tm_to_time(&alarm->time, &time);
-		if (ret == 0) {
-			writel(time, ldata->base + RTC_MR);
-			pl031_alarm_irq_enable(dev, alarm->enabled);
-		}
+		writel(time, ldata->base + RTC_MR);
+		pl031_alarm_irq_enable(dev, alarm->enabled);
 	}
 
 	return ret;

commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/rtc/rtc-pl031.c b/drivers/rtc/rtc-pl031.c
index 30943d200c5e..180caebbd355 100644
--- a/drivers/rtc/rtc-pl031.c
+++ b/drivers/rtc/rtc-pl031.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * drivers/rtc/rtc-pl031.c
  *
@@ -9,11 +10,6 @@
  *
  * Author: Mian Yousaf Kaukab <mian.yousaf.kaukab@stericsson.com>
  * Copyright 2010 (c) ST-Ericsson AB
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
  */
 #include <linux/module.h>
 #include <linux/rtc.h>

commit b7aff107f34f007f32f45136c9a935912a481d32
Author: Alexandre Belloni <alexandre.belloni@bootlin.com>
Date:   Sun Sep 9 22:38:48 2018 +0200

    rtc: pl031: switch to devm_rtc_allocate_device/rtc_register_device
    
    Switch to devm_rtc_allocate_device to simplify the erro and driver removal
    paths.
    
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@bootlin.com>

diff --git a/drivers/rtc/rtc-pl031.c b/drivers/rtc/rtc-pl031.c
index 82eb7da2c478..30943d200c5e 100644
--- a/drivers/rtc/rtc-pl031.c
+++ b/drivers/rtc/rtc-pl031.c
@@ -310,7 +310,6 @@ static int pl031_remove(struct amba_device *adev)
 	device_init_wakeup(&adev->dev, false);
 	if (adev->irq[0])
 		free_irq(adev->irq[0], ldata);
-	rtc_device_unregister(ldata->rtc);
 	amba_release_regions(adev);
 
 	return 0;
@@ -383,24 +382,25 @@ static int pl031_probe(struct amba_device *adev, const struct amba_id *id)
 	}
 
 	device_init_wakeup(&adev->dev, true);
-	ldata->rtc = rtc_device_register("pl031", &adev->dev, ops,
-					THIS_MODULE);
-	if (IS_ERR(ldata->rtc)) {
-		ret = PTR_ERR(ldata->rtc);
+	ldata->rtc = devm_rtc_allocate_device(&adev->dev);
+	if (IS_ERR(ldata->rtc))
+		return PTR_ERR(ldata->rtc);
+
+	ldata->rtc->ops = ops;
+
+	ret = rtc_register_device(ldata->rtc);
+	if (ret)
 		goto out;
-	}
 
 	if (adev->irq[0]) {
 		ret = request_irq(adev->irq[0], pl031_interrupt,
 				  vendor->irqflags, "rtc-pl031", ldata);
 		if (ret)
-			goto out_no_irq;
+			goto out;
 		dev_pm_set_wake_irq(&adev->dev, adev->irq[0]);
 	}
 	return 0;
 
-out_no_irq:
-	rtc_device_unregister(ldata->rtc);
 out:
 	amba_release_regions(adev);
 err_req:

commit 5b64a2965dfdfca8039e93303c64e2b15c19ff0c
Author: Russell King <rmk+kernel@armlinux.org.uk>
Date:   Fri Sep 29 11:22:15 2017 +0100

    rtc: pl031: make interrupt optional
    
    On some platforms, the interrupt for the PL031 is optional.  Avoid
    trying to claim the interrupt if it's not specified.
    
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>

diff --git a/drivers/rtc/rtc-pl031.c b/drivers/rtc/rtc-pl031.c
index 64c77ec1b4ea..82eb7da2c478 100644
--- a/drivers/rtc/rtc-pl031.c
+++ b/drivers/rtc/rtc-pl031.c
@@ -308,7 +308,8 @@ static int pl031_remove(struct amba_device *adev)
 
 	dev_pm_clear_wake_irq(&adev->dev);
 	device_init_wakeup(&adev->dev, false);
-	free_irq(adev->irq[0], ldata);
+	if (adev->irq[0])
+		free_irq(adev->irq[0], ldata);
 	rtc_device_unregister(ldata->rtc);
 	amba_release_regions(adev);
 
@@ -389,12 +390,13 @@ static int pl031_probe(struct amba_device *adev, const struct amba_id *id)
 		goto out;
 	}
 
-	if (request_irq(adev->irq[0], pl031_interrupt,
-			vendor->irqflags, "rtc-pl031", ldata)) {
-		ret = -EIO;
-		goto out_no_irq;
+	if (adev->irq[0]) {
+		ret = request_irq(adev->irq[0], pl031_interrupt,
+				  vendor->irqflags, "rtc-pl031", ldata);
+		if (ret)
+			goto out_no_irq;
+		dev_pm_set_wake_irq(&adev->dev, adev->irq[0]);
 	}
-	dev_pm_set_wake_irq(&adev->dev, adev->irq[0]);
 	return 0;
 
 out_no_irq:

commit b86f581f8cdbec3655d400ad952c2203a74edde1
Author: Russell King <rmk+kernel@armlinux.org.uk>
Date:   Fri Sep 29 11:22:10 2017 +0100

    rtc: pl031: avoid exposing alarm if no interrupt
    
    If the RTC has no interrupt, there is little point in exposing the RTC
    alarm capabilities, as it can't be used as a wakeup source nor can it
    deliver an event to userspace.
    
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>

diff --git a/drivers/rtc/rtc-pl031.c b/drivers/rtc/rtc-pl031.c
index 777da06d53ee..64c77ec1b4ea 100644
--- a/drivers/rtc/rtc-pl031.c
+++ b/drivers/rtc/rtc-pl031.c
@@ -320,7 +320,7 @@ static int pl031_probe(struct amba_device *adev, const struct amba_id *id)
 	int ret;
 	struct pl031_local *ldata;
 	struct pl031_vendor_data *vendor = id->data;
-	struct rtc_class_ops *ops = &vendor->ops;
+	struct rtc_class_ops *ops;
 	unsigned long time, data;
 
 	ret = amba_request_regions(adev, NULL);
@@ -329,12 +329,14 @@ static int pl031_probe(struct amba_device *adev, const struct amba_id *id)
 
 	ldata = devm_kzalloc(&adev->dev, sizeof(struct pl031_local),
 			     GFP_KERNEL);
-	if (!ldata) {
+	ops = devm_kmemdup(&adev->dev, &vendor->ops, sizeof(vendor->ops),
+			   GFP_KERNEL);
+	if (!ldata || !ops) {
 		ret = -ENOMEM;
 		goto out;
 	}
-	ldata->vendor = vendor;
 
+	ldata->vendor = vendor;
 	ldata->base = devm_ioremap(&adev->dev, adev->res.start,
 				   resource_size(&adev->res));
 	if (!ldata->base) {
@@ -372,6 +374,13 @@ static int pl031_probe(struct amba_device *adev, const struct amba_id *id)
 		}
 	}
 
+	if (!adev->irq[0]) {
+		/* When there's no interrupt, no point in exposing the alarm */
+		ops->read_alarm = NULL;
+		ops->set_alarm = NULL;
+		ops->alarm_irq_enable = NULL;
+	}
+
 	device_init_wakeup(&adev->dev, true);
 	ldata->rtc = rtc_device_register("pl031", &adev->dev, ops,
 					THIS_MODULE);

commit 273c868e85a56481ccb34822be2033dbe63248fb
Author: Russell King <rmk+kernel@armlinux.org.uk>
Date:   Fri Sep 29 11:22:05 2017 +0100

    rtc: pl031: use devm_* for allocating memory and mapping resource
    
    Use the devm_* APIs for allocating memory and mapping the memory in
    the probe function to relieve the driver from having to deal with
    this in the cleanup paths.
    
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>

diff --git a/drivers/rtc/rtc-pl031.c b/drivers/rtc/rtc-pl031.c
index 0d87b90b1903..777da06d53ee 100644
--- a/drivers/rtc/rtc-pl031.c
+++ b/drivers/rtc/rtc-pl031.c
@@ -310,8 +310,6 @@ static int pl031_remove(struct amba_device *adev)
 	device_init_wakeup(&adev->dev, false);
 	free_irq(adev->irq[0], ldata);
 	rtc_device_unregister(ldata->rtc);
-	iounmap(ldata->base);
-	kfree(ldata);
 	amba_release_regions(adev);
 
 	return 0;
@@ -329,18 +327,19 @@ static int pl031_probe(struct amba_device *adev, const struct amba_id *id)
 	if (ret)
 		goto err_req;
 
-	ldata = kzalloc(sizeof(struct pl031_local), GFP_KERNEL);
+	ldata = devm_kzalloc(&adev->dev, sizeof(struct pl031_local),
+			     GFP_KERNEL);
 	if (!ldata) {
 		ret = -ENOMEM;
 		goto out;
 	}
 	ldata->vendor = vendor;
 
-	ldata->base = ioremap(adev->res.start, resource_size(&adev->res));
-
+	ldata->base = devm_ioremap(&adev->dev, adev->res.start,
+				   resource_size(&adev->res));
 	if (!ldata->base) {
 		ret = -ENOMEM;
-		goto out_no_remap;
+		goto out;
 	}
 
 	amba_set_drvdata(adev, ldata);
@@ -378,7 +377,7 @@ static int pl031_probe(struct amba_device *adev, const struct amba_id *id)
 					THIS_MODULE);
 	if (IS_ERR(ldata->rtc)) {
 		ret = PTR_ERR(ldata->rtc);
-		goto out_no_rtc;
+		goto out;
 	}
 
 	if (request_irq(adev->irq[0], pl031_interrupt,
@@ -391,10 +390,6 @@ static int pl031_probe(struct amba_device *adev, const struct amba_id *id)
 
 out_no_irq:
 	rtc_device_unregister(ldata->rtc);
-out_no_rtc:
-	iounmap(ldata->base);
-out_no_remap:
-	kfree(ldata);
 out:
 	amba_release_regions(adev);
 err_req:

commit eb508b36d549d96a7ddcf1fe0656cdd86b038fe5
Author: Russell King <rmk+kernel@armlinux.org.uk>
Date:   Fri Sep 29 11:22:00 2017 +0100

    rtc: pl031: constify amba_ids
    
    The AMBA device IDs should be marked const.  Make that so.
    
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>

diff --git a/drivers/rtc/rtc-pl031.c b/drivers/rtc/rtc-pl031.c
index e1687e19c59f..0d87b90b1903 100644
--- a/drivers/rtc/rtc-pl031.c
+++ b/drivers/rtc/rtc-pl031.c
@@ -446,7 +446,7 @@ static struct pl031_vendor_data stv2_pl031 = {
 	.irqflags = IRQF_SHARED | IRQF_COND_SUSPEND,
 };
 
-static struct amba_id pl031_ids[] = {
+static const struct amba_id pl031_ids[] = {
 	{
 		.id = 0x00041031,
 		.mask = 0x000fffff,

commit eff6dd41c2240f49e562b89d50ed3e86485cc4ad
Author: Sudeep Holla <Sudeep.Holla@arm.com>
Date:   Mon Sep 21 16:46:57 2015 +0100

    rtc: pl031: remove misuse of IRQF_NO_SUSPEND flag
    
    The IRQF_NO_SUSPEND flag is used to identify the interrupts that should
    be left enabled so as to allow them to work as expected during the
    suspend-resume cycle, but doesn't guarantee that it will wake the system
    from a suspended state, enable_irq_wake is recommended to be used for
    the wakeup.
    
    This patch removes the use of IRQF_NO_SUSPEND flags and uses newly
    introduce PM wakeup APIs dev_pm_{set,clear}_wake_irq.
    
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Alessandro Zummo <a.zummo@towertech.it>
    Cc: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Cc: rtc-linux@googlegroups.com
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>

diff --git a/drivers/rtc/rtc-pl031.c b/drivers/rtc/rtc-pl031.c
index 41dcb7ddb906..e1687e19c59f 100644
--- a/drivers/rtc/rtc-pl031.c
+++ b/drivers/rtc/rtc-pl031.c
@@ -23,6 +23,7 @@
 #include <linux/io.h>
 #include <linux/bcd.h>
 #include <linux/delay.h>
+#include <linux/pm_wakeirq.h>
 #include <linux/slab.h>
 
 /*
@@ -305,6 +306,8 @@ static int pl031_remove(struct amba_device *adev)
 {
 	struct pl031_local *ldata = dev_get_drvdata(&adev->dev);
 
+	dev_pm_clear_wake_irq(&adev->dev);
+	device_init_wakeup(&adev->dev, false);
 	free_irq(adev->irq[0], ldata);
 	rtc_device_unregister(ldata->rtc);
 	iounmap(ldata->base);
@@ -370,7 +373,7 @@ static int pl031_probe(struct amba_device *adev, const struct amba_id *id)
 		}
 	}
 
-	device_init_wakeup(&adev->dev, 1);
+	device_init_wakeup(&adev->dev, true);
 	ldata->rtc = rtc_device_register("pl031", &adev->dev, ops,
 					THIS_MODULE);
 	if (IS_ERR(ldata->rtc)) {
@@ -383,7 +386,7 @@ static int pl031_probe(struct amba_device *adev, const struct amba_id *id)
 		ret = -EIO;
 		goto out_no_irq;
 	}
-
+	dev_pm_set_wake_irq(&adev->dev, adev->irq[0]);
 	return 0;
 
 out_no_irq:
@@ -408,7 +411,6 @@ static struct pl031_vendor_data arm_pl031 = {
 		.set_alarm = pl031_set_alarm,
 		.alarm_irq_enable = pl031_alarm_irq_enable,
 	},
-	.irqflags = IRQF_NO_SUSPEND,
 };
 
 /* The First ST derivative */
@@ -422,7 +424,6 @@ static struct pl031_vendor_data stv1_pl031 = {
 	},
 	.clockwatch = true,
 	.st_weekday = true,
-	.irqflags = IRQF_NO_SUSPEND,
 };
 
 /* And the second ST derivative */
@@ -439,8 +440,10 @@ static struct pl031_vendor_data stv2_pl031 = {
 	/*
 	 * This variant shares the IRQ with another block and must not
 	 * suspend that IRQ line.
+	 * TODO check if it shares with IRQF_NO_SUSPEND user, else we can
+	 * remove IRQF_COND_SUSPEND
 	 */
-	.irqflags = IRQF_SHARED | IRQF_NO_SUSPEND,
+	.irqflags = IRQF_SHARED | IRQF_COND_SUSPEND,
 };
 
 static struct amba_id pl031_ids[] = {

commit 27675ef03c0535158b77af76591920fe041ebf14
Author: Leo Yan <leo.yan@linaro.org>
Date:   Wed Jul 29 14:13:40 2015 +0800

    rtc: pl031: fix typo for author email
    
    The email address missed character ">", so add it.
    
    Signed-off-by: Leo Yan <leo.yan@linaro.org>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>

diff --git a/drivers/rtc/rtc-pl031.c b/drivers/rtc/rtc-pl031.c
index 99181fff88fd..41dcb7ddb906 100644
--- a/drivers/rtc/rtc-pl031.c
+++ b/drivers/rtc/rtc-pl031.c
@@ -476,6 +476,6 @@ static struct amba_driver pl031_driver = {
 
 module_amba_driver(pl031_driver);
 
-MODULE_AUTHOR("Deepak Saxena <dsaxena@plexity.net");
+MODULE_AUTHOR("Deepak Saxena <dsaxena@plexity.net>");
 MODULE_DESCRIPTION("ARM AMBA PL031 RTC Driver");
 MODULE_LICENSE("GPL");

commit a2726061920f43f594e03236d694c71f77adc6a2
Author: Michal Simek <michal.simek@xilinx.com>
Date:   Tue Nov 12 15:11:00 2013 -0800

    drivers/rtc/rtc-pl03x.c: remove unnecessary amba_set_drvdata()
    
    Driver core clears the driver data to NULL after device_release or on
    probe failure, so just remove it from here.
    
    The relevant driver core change was commit 0998d0631001 ("device-core:
    Ensure drvdata = NULL when no driver is bound").
    
    Signed-off-by: Michal Simek <michal.simek@xilinx.com>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/rtc/rtc-pl031.c b/drivers/rtc/rtc-pl031.c
index e3b25712b659..99181fff88fd 100644
--- a/drivers/rtc/rtc-pl031.c
+++ b/drivers/rtc/rtc-pl031.c
@@ -305,7 +305,6 @@ static int pl031_remove(struct amba_device *adev)
 {
 	struct pl031_local *ldata = dev_get_drvdata(&adev->dev);
 
-	amba_set_drvdata(adev, NULL);
 	free_irq(adev->irq[0], ldata);
 	rtc_device_unregister(ldata->rtc);
 	iounmap(ldata->base);
@@ -391,7 +390,6 @@ static int pl031_probe(struct amba_device *adev, const struct amba_id *id)
 	rtc_device_unregister(ldata->rtc);
 out_no_rtc:
 	iounmap(ldata->base);
-	amba_set_drvdata(adev, NULL);
 out_no_remap:
 	kfree(ldata);
 out:

commit 07783397c6e3757de805bda5e1139a9e47aa7d74
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Sep 17 11:20:21 2013 -0700

    rtc: rtc-pl031: Set wakeup flag prior to registering rtcdev
    
    In some recent testing, I noticed the CLOCK_REALTIME_ALARM clockid
    wasn't functioning on my vexpress qemu environment. Looking into it
    I noticed the pl031 rtc driver doesn't set the wakeup flag on the
    device until after registering the device with the RTC subsystem.
    
    This causes the alarmtimer subsystem to not see the pl031 driver
    as a valid backing device, and that resuls in alarm clockids
    getting ENOTSUPP errors.
    
    Thus be sure to set the wakeup flag on the device prior to
    registering the rtcdev so the pl031 rtc driver can be used as
    the backing alarmtimer device.
    
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Alessandro Zummo <a.zummo@towertech.it>
    Cc: "Jon Medhurst (Tixy)" <tixy@linaro.org>
    Cc: linux-arm-kernel@lists.infradead.org
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/drivers/rtc/rtc-pl031.c b/drivers/rtc/rtc-pl031.c
index 0f0609b1aa2c..e3b25712b659 100644
--- a/drivers/rtc/rtc-pl031.c
+++ b/drivers/rtc/rtc-pl031.c
@@ -371,6 +371,7 @@ static int pl031_probe(struct amba_device *adev, const struct amba_id *id)
 		}
 	}
 
+	device_init_wakeup(&adev->dev, 1);
 	ldata->rtc = rtc_device_register("pl031", &adev->dev, ops,
 					THIS_MODULE);
 	if (IS_ERR(ldata->rtc)) {
@@ -384,8 +385,6 @@ static int pl031_probe(struct amba_device *adev, const struct amba_id *id)
 		goto out_no_irq;
 	}
 
-	device_init_wakeup(&adev->dev, 1);
-
 	return 0;
 
 out_no_irq:

commit cac29af6bd6bc5c53499f39ef1eade193295b2f1
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Fri May 24 15:55:26 2013 -0700

    drivers/rtc/rtc-pl031.c: pass correct pointer to free_irq()
    
    free_irq() expects the same pointer that was passed to request_irq(),
    otherwise the IRQ is not freed.
    
    The issue was found using the following coccinelle script:
    
      <smpl>
      @r1@
      type T;
      T devid;
      @@
      request_irq(..., devid)
    
      @r2@
      type r1.T;
      T devid;
      position p;
      @@
      free_irq@p(..., devid)
    
      @@
      position p != r2.p;
      @@
      *free_irq@p(...)
      </smpl>
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Cc: Srinidhi Kasagar <srinidhi.kasagar@stericsson.com>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/rtc/rtc-pl031.c b/drivers/rtc/rtc-pl031.c
index 8900ea784817..0f0609b1aa2c 100644
--- a/drivers/rtc/rtc-pl031.c
+++ b/drivers/rtc/rtc-pl031.c
@@ -306,7 +306,7 @@ static int pl031_remove(struct amba_device *adev)
 	struct pl031_local *ldata = dev_get_drvdata(&adev->dev);
 
 	amba_set_drvdata(adev, NULL);
-	free_irq(adev->irq[0], ldata->rtc);
+	free_irq(adev->irq[0], ldata);
 	rtc_device_unregister(ldata->rtc);
 	iounmap(ldata->base);
 	kfree(ldata);

commit b06eef45cab7231f59b23d98ce78c090896b6103
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Thu Feb 21 16:44:54 2013 -0800

    drivers/rtc/rtc-pl031.c: add wakeup support
    
    Mark the pl031 as wake-up capable so that rtcwake and suspend test can work.
    
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Cc: Srinidhi Kasagar <srinidhi.kasagar@stericsson.com>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Alessandro Zummo <a.zummo@towertech.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/rtc/rtc-pl031.c b/drivers/rtc/rtc-pl031.c
index 81c5077feff3..8900ea784817 100644
--- a/drivers/rtc/rtc-pl031.c
+++ b/drivers/rtc/rtc-pl031.c
@@ -384,6 +384,8 @@ static int pl031_probe(struct amba_device *adev, const struct amba_id *id)
 		goto out_no_irq;
 	}
 
+	device_init_wakeup(&adev->dev, 1);
+
 	return 0;
 
 out_no_irq:

commit 3399cfb5df9594495b876d1843a7165f77366b2b
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Feb 12 13:46:19 2013 -0800

    drivers/rtc/rtc-pl031.c: restore ST variant functionality
    
    Commit e7e034e18a0a ("drivers/rtc/rtc-pl031.c: fix the missing operation
    on enable") accidentally broke the ST variants of PL031.
    
    The bit that is being poked as "clockwatch" enable bit for the ST
    variants does the work of bit 0 on this variant.  Bit 0 is used for a
    clock divider on the ST variants, and setting it to 1 will affect
    timekeeping in a very bad way.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Haojian Zhuang <haojian.zhuang@gmail.com>
    Cc: Mian Yousaf KAUKAB <mian.yousaf.kaukab@stericsson.com>
    Cc: Srinidhi Kasagar <srinidhi.kasagar@stericsson.com>
    Cc: Alessandro Zummo <a.zummo@towertech.it>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/rtc/rtc-pl031.c b/drivers/rtc/rtc-pl031.c
index 10c1a3454e48..81c5077feff3 100644
--- a/drivers/rtc/rtc-pl031.c
+++ b/drivers/rtc/rtc-pl031.c
@@ -350,7 +350,9 @@ static int pl031_probe(struct amba_device *adev, const struct amba_id *id)
 	/* Enable the clockwatch on ST Variants */
 	if (vendor->clockwatch)
 		data |= RTC_CR_CWEN;
-	writel(data | RTC_CR_EN, ldata->base + RTC_CR);
+	else
+		data |= RTC_CR_EN;
+	writel(data, ldata->base + RTC_CR);
 
 	/*
 	 * On ST PL031 variants, the RTC reset value does not provide correct

commit e7e034e18a0ab6bafb2425c3242cac311164f4d6
Author: Haojian Zhuang <haojian.zhuang@linaro.org>
Date:   Mon Feb 4 14:28:54 2013 -0800

    drivers/rtc/rtc-pl031.c: fix the missing operation on enable
    
    The RTC control register should be enabled in the process of
    initializing.
    
    Without this patch, I failed to enable RTC in Hisilicon Hi3620 SoC.  The
    register mapping section in RTC is always read as zero.  So I doubt that
    ST guys may already enable this register in bootloader.  So they won't
    meet this issue.
    
    Signed-off-by: Haojian Zhuang <haojian.zhuang@linaro.org>
    Cc: Srinidhi Kasagar <srinidhi.kasagar@stericsson.com>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Alessandro Zummo <a.zummo@towertech.it>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/rtc/rtc-pl031.c b/drivers/rtc/rtc-pl031.c
index 08378e3cc21c..10c1a3454e48 100644
--- a/drivers/rtc/rtc-pl031.c
+++ b/drivers/rtc/rtc-pl031.c
@@ -44,6 +44,7 @@
 #define RTC_YMR		0x34	/* Year match register */
 #define RTC_YLR		0x38	/* Year data load register */
 
+#define RTC_CR_EN	(1 << 0)	/* counter enable bit */
 #define RTC_CR_CWEN	(1 << 26)	/* Clockwatch enable bit */
 
 #define RTC_TCR_EN	(1 << 1) /* Periodic timer enable bit */
@@ -320,7 +321,7 @@ static int pl031_probe(struct amba_device *adev, const struct amba_id *id)
 	struct pl031_local *ldata;
 	struct pl031_vendor_data *vendor = id->data;
 	struct rtc_class_ops *ops = &vendor->ops;
-	unsigned long time;
+	unsigned long time, data;
 
 	ret = amba_request_regions(adev, NULL);
 	if (ret)
@@ -345,10 +346,11 @@ static int pl031_probe(struct amba_device *adev, const struct amba_id *id)
 	dev_dbg(&adev->dev, "designer ID = 0x%02x\n", amba_manf(adev));
 	dev_dbg(&adev->dev, "revision = 0x%01x\n", amba_rev(adev));
 
+	data = readl(ldata->base + RTC_CR);
 	/* Enable the clockwatch on ST Variants */
 	if (vendor->clockwatch)
-		writel(readl(ldata->base + RTC_CR) | RTC_CR_CWEN,
-		       ldata->base + RTC_CR);
+		data |= RTC_CR_CWEN;
+	writel(data | RTC_CR_EN, ldata->base + RTC_CR);
 
 	/*
 	 * On ST PL031 variants, the RTC reset value does not provide correct

commit 559a6fc0508392a665a26d93db9ff875bfdc6540
Author: Mattias Wallin <mattias.wallin@stericsson.com>
Date:   Mon Jul 30 14:41:39 2012 -0700

    rtc: pl031: fix up IRQ flags
    
    The pl031 interrupt is shared between the timer part and the clockwatch
    part of the same HW block on the ux500, so mark it IRQF_SHARED on this
    variant.
    
    This patch also adds the IRQF_NO_SUSPEND flag to the rtc irq on all
    variants as we don't want this pretty important IRQ to be disabled in
    suspend.
    
    Signed-off-by: Mattias Wallin <mattias.wallin@stericsson.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Reviewed-by: Rickard Andersson <rickard.andersson@stericsson.com>
    Reviewed-by: Jonas Aberg <jonas.aberg@stericsson.com>
    Cc: Alessandro Zummo <a.zummo@towertech.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/rtc/rtc-pl031.c b/drivers/rtc/rtc-pl031.c
index e66afb816d61..08378e3cc21c 100644
--- a/drivers/rtc/rtc-pl031.c
+++ b/drivers/rtc/rtc-pl031.c
@@ -75,11 +75,13 @@
  *	clockwatch function
  * @st_weekday: if this is an ST Microelectronics silicon version that need
  *	the weekday fix
+ * @irqflags: special IRQ flags per variant
  */
 struct pl031_vendor_data {
 	struct rtc_class_ops ops;
 	bool clockwatch;
 	bool st_weekday;
+	unsigned long irqflags;
 };
 
 struct pl031_local {
@@ -373,7 +375,7 @@ static int pl031_probe(struct amba_device *adev, const struct amba_id *id)
 	}
 
 	if (request_irq(adev->irq[0], pl031_interrupt,
-			0, "rtc-pl031", ldata)) {
+			vendor->irqflags, "rtc-pl031", ldata)) {
 		ret = -EIO;
 		goto out_no_irq;
 	}
@@ -403,6 +405,7 @@ static struct pl031_vendor_data arm_pl031 = {
 		.set_alarm = pl031_set_alarm,
 		.alarm_irq_enable = pl031_alarm_irq_enable,
 	},
+	.irqflags = IRQF_NO_SUSPEND,
 };
 
 /* The First ST derivative */
@@ -416,6 +419,7 @@ static struct pl031_vendor_data stv1_pl031 = {
 	},
 	.clockwatch = true,
 	.st_weekday = true,
+	.irqflags = IRQF_NO_SUSPEND,
 };
 
 /* And the second ST derivative */
@@ -429,6 +433,11 @@ static struct pl031_vendor_data stv2_pl031 = {
 	},
 	.clockwatch = true,
 	.st_weekday = true,
+	/*
+	 * This variant shares the IRQ with another block and must not
+	 * suspend that IRQ line.
+	 */
+	.irqflags = IRQF_SHARED | IRQF_NO_SUSPEND,
 };
 
 static struct amba_id pl031_ids[] = {

commit 1bb457fc9268bb75156af8db78b72a4463baaec4
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Mon Jul 30 14:41:36 2012 -0700

    rtc: pl031: use per-vendor variables for special init
    
    Instead of hard-checking for certain vendor codes, follow the pattern of
    other AMBA (PrimeCell) drivers and use variables in the vendor data.
    Get rid of the locally cached vendor and hardware revision since we
    already have the nice vendor data variable in the state.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Cc: Alessandro Zummo <a.zummo@towertech.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/rtc/rtc-pl031.c b/drivers/rtc/rtc-pl031.c
index 575fbbf966db..e66afb816d61 100644
--- a/drivers/rtc/rtc-pl031.c
+++ b/drivers/rtc/rtc-pl031.c
@@ -71,17 +71,21 @@
 /**
  * struct pl031_vendor_data - per-vendor variations
  * @ops: the vendor-specific operations used on this silicon version
+ * @clockwatch: if this is an ST Microelectronics silicon version with a
+ *	clockwatch function
+ * @st_weekday: if this is an ST Microelectronics silicon version that need
+ *	the weekday fix
  */
 struct pl031_vendor_data {
 	struct rtc_class_ops ops;
+	bool clockwatch;
+	bool st_weekday;
 };
 
 struct pl031_local {
 	struct pl031_vendor_data *vendor;
 	struct rtc_device *rtc;
 	void __iomem *base;
-	u8 hw_designer;
-	u8 hw_revision:4;
 };
 
 static int pl031_alarm_irq_enable(struct device *dev,
@@ -336,14 +340,11 @@ static int pl031_probe(struct amba_device *adev, const struct amba_id *id)
 
 	amba_set_drvdata(adev, ldata);
 
-	ldata->hw_designer = amba_manf(adev);
-	ldata->hw_revision = amba_rev(adev);
-
-	dev_dbg(&adev->dev, "designer ID = 0x%02x\n", ldata->hw_designer);
-	dev_dbg(&adev->dev, "revision = 0x%01x\n", ldata->hw_revision);
+	dev_dbg(&adev->dev, "designer ID = 0x%02x\n", amba_manf(adev));
+	dev_dbg(&adev->dev, "revision = 0x%01x\n", amba_rev(adev));
 
 	/* Enable the clockwatch on ST Variants */
-	if (ldata->hw_designer == AMBA_VENDOR_ST)
+	if (vendor->clockwatch)
 		writel(readl(ldata->base + RTC_CR) | RTC_CR_CWEN,
 		       ldata->base + RTC_CR);
 
@@ -351,7 +352,7 @@ static int pl031_probe(struct amba_device *adev, const struct amba_id *id)
 	 * On ST PL031 variants, the RTC reset value does not provide correct
 	 * weekday for 2000-01-01. Correct the erroneous sunday to saturday.
 	 */
-	if (ldata->hw_designer == AMBA_VENDOR_ST) {
+	if (vendor->st_weekday) {
 		if (readl(ldata->base + RTC_YDR) == 0x2000) {
 			time = readl(ldata->base + RTC_DR);
 			if ((time &
@@ -413,6 +414,8 @@ static struct pl031_vendor_data stv1_pl031 = {
 		.set_alarm = pl031_set_alarm,
 		.alarm_irq_enable = pl031_alarm_irq_enable,
 	},
+	.clockwatch = true,
+	.st_weekday = true,
 };
 
 /* And the second ST derivative */
@@ -424,6 +427,8 @@ static struct pl031_vendor_data stv2_pl031 = {
 		.set_alarm = pl031_stv2_set_alarm,
 		.alarm_irq_enable = pl031_alarm_irq_enable,
 	},
+	.clockwatch = true,
+	.st_weekday = true,
 };
 
 static struct amba_id pl031_ids[] = {

commit aff05ed5d103524bd69bd9d7b621c5c8a6c63198
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Mon Jul 30 14:41:34 2012 -0700

    rtc: pl031: encapsulate per-vendor ops
    
    Move the per-vendor operations for this RTC into a encapsulating struct so
    we can have more per-vendor variables than just the ops.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Cc: Alessandro Zummo <a.zummo@towertech.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/rtc/rtc-pl031.c b/drivers/rtc/rtc-pl031.c
index cc0533994f6e..575fbbf966db 100644
--- a/drivers/rtc/rtc-pl031.c
+++ b/drivers/rtc/rtc-pl031.c
@@ -68,7 +68,16 @@
 
 #define RTC_TIMER_FREQ 32768
 
+/**
+ * struct pl031_vendor_data - per-vendor variations
+ * @ops: the vendor-specific operations used on this silicon version
+ */
+struct pl031_vendor_data {
+	struct rtc_class_ops ops;
+};
+
 struct pl031_local {
+	struct pl031_vendor_data *vendor;
 	struct rtc_device *rtc;
 	void __iomem *base;
 	u8 hw_designer;
@@ -303,7 +312,8 @@ static int pl031_probe(struct amba_device *adev, const struct amba_id *id)
 {
 	int ret;
 	struct pl031_local *ldata;
-	struct rtc_class_ops *ops = id->data;
+	struct pl031_vendor_data *vendor = id->data;
+	struct rtc_class_ops *ops = &vendor->ops;
 	unsigned long time;
 
 	ret = amba_request_regions(adev, NULL);
@@ -315,6 +325,7 @@ static int pl031_probe(struct amba_device *adev, const struct amba_id *id)
 		ret = -ENOMEM;
 		goto out;
 	}
+	ldata->vendor = vendor;
 
 	ldata->base = ioremap(adev->res.start, resource_size(&adev->res));
 
@@ -383,48 +394,54 @@ static int pl031_probe(struct amba_device *adev, const struct amba_id *id)
 }
 
 /* Operations for the original ARM version */
-static struct rtc_class_ops arm_pl031_ops = {
-	.read_time = pl031_read_time,
-	.set_time = pl031_set_time,
-	.read_alarm = pl031_read_alarm,
-	.set_alarm = pl031_set_alarm,
-	.alarm_irq_enable = pl031_alarm_irq_enable,
+static struct pl031_vendor_data arm_pl031 = {
+	.ops = {
+		.read_time = pl031_read_time,
+		.set_time = pl031_set_time,
+		.read_alarm = pl031_read_alarm,
+		.set_alarm = pl031_set_alarm,
+		.alarm_irq_enable = pl031_alarm_irq_enable,
+	},
 };
 
 /* The First ST derivative */
-static struct rtc_class_ops stv1_pl031_ops = {
-	.read_time = pl031_read_time,
-	.set_time = pl031_set_time,
-	.read_alarm = pl031_read_alarm,
-	.set_alarm = pl031_set_alarm,
-	.alarm_irq_enable = pl031_alarm_irq_enable,
+static struct pl031_vendor_data stv1_pl031 = {
+	.ops = {
+		.read_time = pl031_read_time,
+		.set_time = pl031_set_time,
+		.read_alarm = pl031_read_alarm,
+		.set_alarm = pl031_set_alarm,
+		.alarm_irq_enable = pl031_alarm_irq_enable,
+	},
 };
 
 /* And the second ST derivative */
-static struct rtc_class_ops stv2_pl031_ops = {
-	.read_time = pl031_stv2_read_time,
-	.set_time = pl031_stv2_set_time,
-	.read_alarm = pl031_stv2_read_alarm,
-	.set_alarm = pl031_stv2_set_alarm,
-	.alarm_irq_enable = pl031_alarm_irq_enable,
+static struct pl031_vendor_data stv2_pl031 = {
+	.ops = {
+		.read_time = pl031_stv2_read_time,
+		.set_time = pl031_stv2_set_time,
+		.read_alarm = pl031_stv2_read_alarm,
+		.set_alarm = pl031_stv2_set_alarm,
+		.alarm_irq_enable = pl031_alarm_irq_enable,
+	},
 };
 
 static struct amba_id pl031_ids[] = {
 	{
 		.id = 0x00041031,
 		.mask = 0x000fffff,
-		.data = &arm_pl031_ops,
+		.data = &arm_pl031,
 	},
 	/* ST Micro variants */
 	{
 		.id = 0x00180031,
 		.mask = 0x00ffffff,
-		.data = &stv1_pl031_ops,
+		.data = &stv1_pl031,
 	},
 	{
 		.id = 0x00280031,
 		.mask = 0x00ffffff,
-		.data = &stv2_pl031_ops,
+		.data = &stv2_pl031,
 	},
 	{0, 0},
 };

commit ac2dee5984bc78c8ff1893142f7322320d2baf05
Author: Rajkumar Kasirajan <rajkumar.kasirajan@stericsson.com>
Date:   Tue May 29 15:07:40 2012 -0700

    drivers/rtc/rtc-pl031.c: remove RTC timer interrupt handling
    
    Remove RTT interrupt handling, since PIE mode interrupts are now better
    emulated in generic code via an hrtimer we have no need for this, and
    there is no codepath in the driver that enables these periodic interrupts
    anyway.
    
    Signed-off-by: Rajkumar Kasirajan <rajkumar.kasirajan@stericsson.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Cc: Mattias Wallin <mattias.wallin@stericsson.com>
    Cc: Alessandro Zummo <a.zummo@towertech.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/rtc/rtc-pl031.c b/drivers/rtc/rtc-pl031.c
index f027c063fb20..cc0533994f6e 100644
--- a/drivers/rtc/rtc-pl031.c
+++ b/drivers/rtc/rtc-pl031.c
@@ -220,17 +220,9 @@ static irqreturn_t pl031_interrupt(int irq, void *dev_id)
 	unsigned long events = 0;
 
 	rtcmis = readl(ldata->base + RTC_MIS);
-	if (rtcmis) {
-		writel(rtcmis, ldata->base + RTC_ICR);
-
-		if (rtcmis & RTC_BIT_AI)
-			events |= (RTC_AF | RTC_IRQF);
-
-		/* Timer interrupt is only available in ST variants */
-		if ((rtcmis & RTC_BIT_PI) &&
-			(ldata->hw_designer == AMBA_VENDOR_ST))
-			events |= (RTC_PF | RTC_IRQF);
-
+	if (rtcmis & RTC_BIT_AI) {
+		writel(RTC_BIT_AI, ldata->base + RTC_ICR);
+		events |= (RTC_AF | RTC_IRQF);
 		rtc_update_irq(ldata->rtc, 1, events);
 
 		return IRQ_HANDLED;

commit c0a5f4a05af588a0f9951f8d24e2564b09501918
Author: Rajkumar Kasirajan <rajkumar.kasirajan@stericsson.com>
Date:   Thu May 17 17:03:24 2012 -0700

    drivers/rtc/rtc-pl031.c: configure correct wday for 2000-01-01
    
    The reset date of the ST Micro version of PL031 is 2000-01-01.  The
    correct weekday for 2000-01-01 is saturday, but pl031 is initialized to
    sunday.  This may lead to alarm malfunction, so configure the correct
    wday if RTC_DR indicates reset.
    
    Signed-off-by: Rajkumar Kasirajan <rajkumar.kasirajan@stericsson.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Cc: Mattias Wallin <mattias.wallin@stericsson.com>
    Cc: Alessandro Zummo <a.zummo@towertech.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/rtc/rtc-pl031.c b/drivers/rtc/rtc-pl031.c
index 684ef4bbfce4..f027c063fb20 100644
--- a/drivers/rtc/rtc-pl031.c
+++ b/drivers/rtc/rtc-pl031.c
@@ -312,6 +312,7 @@ static int pl031_probe(struct amba_device *adev, const struct amba_id *id)
 	int ret;
 	struct pl031_local *ldata;
 	struct rtc_class_ops *ops = id->data;
+	unsigned long time;
 
 	ret = amba_request_regions(adev, NULL);
 	if (ret)
@@ -343,6 +344,23 @@ static int pl031_probe(struct amba_device *adev, const struct amba_id *id)
 		writel(readl(ldata->base + RTC_CR) | RTC_CR_CWEN,
 		       ldata->base + RTC_CR);
 
+	/*
+	 * On ST PL031 variants, the RTC reset value does not provide correct
+	 * weekday for 2000-01-01. Correct the erroneous sunday to saturday.
+	 */
+	if (ldata->hw_designer == AMBA_VENDOR_ST) {
+		if (readl(ldata->base + RTC_YDR) == 0x2000) {
+			time = readl(ldata->base + RTC_DR);
+			if ((time &
+			     (RTC_MON_MASK | RTC_MDAY_MASK | RTC_WDAY_MASK))
+			    == 0x02120000) {
+				time = time | (0x7 << RTC_WDAY_SHIFT);
+				writel(0x2000, ldata->base + RTC_YLR);
+				writel(time, ldata->base + RTC_LR);
+			}
+		}
+	}
+
 	ldata->rtc = rtc_device_register("pl031", &adev->dev, ops,
 					THIS_MODULE);
 	if (IS_ERR(ldata->rtc)) {

commit 2f3972168353d355854d6381f1f360ce83b723e5
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Thu Apr 12 12:49:16 2012 -0700

    drivers/rtc/rtc-pl031.c: enable clock on all ST variants
    
    The ST variants of the PL031 all require bit 26 in the control register
    to be set before they work properly.  Discovered this when testing on
    the Nomadik board where it would suprisingly just stand still.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Cc: Mian Yousaf Kaukab <mian.yousaf.kaukab@stericsson.com>
    Cc: Alessandro Rubini <rubini@unipv.it>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/rtc/rtc-pl031.c b/drivers/rtc/rtc-pl031.c
index 692de7360e94..684ef4bbfce4 100644
--- a/drivers/rtc/rtc-pl031.c
+++ b/drivers/rtc/rtc-pl031.c
@@ -339,8 +339,7 @@ static int pl031_probe(struct amba_device *adev, const struct amba_id *id)
 	dev_dbg(&adev->dev, "revision = 0x%01x\n", ldata->hw_revision);
 
 	/* Enable the clockwatch on ST Variants */
-	if ((ldata->hw_designer == AMBA_VENDOR_ST) &&
-	    (ldata->hw_revision > 1))
+	if (ldata->hw_designer == AMBA_VENDOR_ST)
 		writel(readl(ldata->base + RTC_CR) | RTC_CR_CWEN,
 		       ldata->base + RTC_CR);
 

commit 0d19eac12031680dc5f5402921fb0c388e42f619
Merge: 56c10bf82c10 bba1594d348b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Mar 23 17:36:29 2012 -0700

    Merge branch 'amba' of git://git.linaro.org/people/rmk/linux-arm
    
    Pull #2 ARM updates from Russell King:
     "Further ARM AMBA primecell updates which aren't included directly in
      the previous commit.  I wanted to keep these separate as they're
      touching stuff outside arch/arm/."
    
    * 'amba' of git://git.linaro.org/people/rmk/linux-arm:
      ARM: 7362/1: AMBA: Add module_amba_driver() helper macro for amba_driver
      ARM: 7335/1: mach-u300: do away with MMC config files
      ARM: 7280/1: mmc: mmci: Cache MMCICLOCK and MMCIPOWER register
      ARM: 7309/1: realview: fix unconnected interrupts on EB11MP
      ARM: 7230/1: mmc: mmci: Fix PIO read for small SDIO packets
      ARM: 7227/1: mmc: mmci: Prepare for SDIO before setting up DMA job
      ARM: 7223/1: mmc: mmci: Fixup use of runtime PM and use autosuspend
      ARM: 7221/1: mmc: mmci: Change from using legacy suspend
      ARM: 7219/1: mmc: mmci: Change vdd_handler to a generic ios_handler
      ARM: 7218/1: mmc: mmci: Provide option to configure bus signal direction
      ARM: 7217/1: mmc: mmci: Put power register deviations in variant data
      ARM: 7216/1: mmc: mmci: Do not release spinlock in request_end
      ARM: 7215/1: mmc: mmci: Increase max_segs from 16 to 128

commit 2f6e5f9458646263d3d9ffadd5e11e3d8d15a7d0
Author: Yong Zhang <yong.zhang0@gmail.com>
Date:   Fri Mar 23 15:02:34 2012 -0700

    drivers/rtc: remove IRQF_DISABLED
    
    Since commit e58aa3d2d0cc ("genirq: run irq handlers with interrupts
    disabled") we run all interrupt handlers with interrupts disabled and we
    even check and yell when an interrupt handler returns with interrupts
    enabled - see commit b738a50a2026 ("genirq: warn when handler enables
    interrupts").
    
    So now this flag is a NOOP and can be removed.
    
    Signed-off-by: Yong Zhang <yong.zhang0@gmail.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Wan ZongShun <mcuos.com@gmail.com>
    Cc: Alessandro Zummo <a.zummo@towertech.it>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/rtc/rtc-pl031.c b/drivers/rtc/rtc-pl031.c
index a952c8de1dd7..3a470e291282 100644
--- a/drivers/rtc/rtc-pl031.c
+++ b/drivers/rtc/rtc-pl031.c
@@ -352,7 +352,7 @@ static int pl031_probe(struct amba_device *adev, const struct amba_id *id)
 	}
 
 	if (request_irq(adev->irq[0], pl031_interrupt,
-			IRQF_DISABLED, "rtc-pl031", ldata)) {
+			0, "rtc-pl031", ldata)) {
 		ret = -EIO;
 		goto out_no_irq;
 	}

commit 9e5ed094c89e55fbf11d2e81d60be98eb12346c0
Author: viresh kumar <viresh.kumar@st.com>
Date:   Thu Mar 15 10:40:38 2012 +0100

    ARM: 7362/1: AMBA: Add module_amba_driver() helper macro for amba_driver
    
    For simple modules that contain a single amba_driver without any
    additional setup code then ends up being a block of duplicated
    boilerplate. This patch adds a new macro, module_amba_driver(),
    which replaces the module_init()/module_exit() registrations with
    template functions.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@st.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/rtc/rtc-pl031.c b/drivers/rtc/rtc-pl031.c
index a952c8de1dd7..359e2c53c545 100644
--- a/drivers/rtc/rtc-pl031.c
+++ b/drivers/rtc/rtc-pl031.c
@@ -431,18 +431,7 @@ static struct amba_driver pl031_driver = {
 	.remove = pl031_remove,
 };
 
-static int __init pl031_init(void)
-{
-	return amba_driver_register(&pl031_driver);
-}
-
-static void __exit pl031_exit(void)
-{
-	amba_driver_unregister(&pl031_driver);
-}
-
-module_init(pl031_init);
-module_exit(pl031_exit);
+module_amba_driver(pl031_driver);
 
 MODULE_AUTHOR("Deepak Saxena <dsaxena@plexity.net");
 MODULE_DESCRIPTION("ARM AMBA PL031 RTC Driver");

commit f5feac2a333b2813a78d5d8749fa0a97cb26acee
Author: Dave Martin <dave.martin@linaro.org>
Date:   Wed Oct 5 15:15:22 2011 +0100

    rtc: pl031: Enable module alias autogeneration for AMBA drivers
    
    Signed-off-by: Dave Martin <dave.martin@linaro.org>

diff --git a/drivers/rtc/rtc-pl031.c b/drivers/rtc/rtc-pl031.c
index ff1b84bd9bb5..a952c8de1dd7 100644
--- a/drivers/rtc/rtc-pl031.c
+++ b/drivers/rtc/rtc-pl031.c
@@ -420,6 +420,8 @@ static struct amba_id pl031_ids[] = {
 	{0, 0},
 };
 
+MODULE_DEVICE_TABLE(amba, pl031_ids);
+
 static struct amba_driver pl031_driver = {
 	.drv = {
 		.name = "rtc-pl031",

commit 6d7ed21d17e640b120b902a314143e5ef4917a70
Merge: ec0afc9311ad bafc8205dc7b 9c9585e0e96f bfddc1c325d1
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Mar 17 18:48:35 2011 -0700

    Merge branches 'defcfg', 'drivers' and 'cyberpro-next' of master.kernel.org:/home/rmk/linux-2.6-arm
    
    * 'defcfg' of master.kernel.org:/home/rmk/linux-2.6-arm:
      ARM: 6647/1: add Versatile Express defconfig
      ARM: 6644/1: mach-ux500: update the U8500 defconfig
    
    * 'drivers' of master.kernel.org:/home/rmk/linux-2.6-arm:
      ARM: 6764/1: pl011: factor out FIFO to TTY code
      ARM: 6763/1: pl011: add optional RX DMA to PL011 v2
      ARM: 6758/1: amba: support pm ops
      ARM: amba: make amba_driver id_table const
      ARM: amba: make internal ID table handling const
      ARM: amba: make probe() functions take const id tables
      ARM: 6662/1: amba: make amba_bustype non-static
      ARM: mmci: add dmaengine-based DMA support
      ARM: mmci: no need for separate host->data_xfered
      ARM: mmci: avoid unnecessary switch to data available PIO interrupts
      ARM: mmci: no need to call flush_dcache_page() with sg_miter API
      ARM: mmci: avoid reporting too many completed bytes on fifo overrun
      ALSA: AACI: make fifo variables more explanitory
      ALSA: AACI: no need to call snd_pcm_period_elapsed() for each period
      ALSA: AACI: use snd_pcm_lib_period_bytes()
      ALSA: AACI: clean up AACI announcement printk
      ALSA: AACI: fix channel mask selection
      ALSA: AACI: fix number of channels for record
      ALSA: AACI: fix multiple IRQ claiming
    
    * 'cyberpro-next' of master.kernel.org:/home/rmk/linux-2.6-arm:
      VIDEO: cyberpro: remove unused cyber2000fb_get_fb_var()
      VIDEO: cyberpro: remove useless function extreg pointers
      VIDEO: cyberpro: update handling of device structures
      VIDEO: cyberpro: add support for video capture I2C
      VIDEO: cyberpro: make 'reg_b0_lock' always present
      VIDEO: cyberpro: add I2C support
      VIDEO: cyberpro: select lowest multipler/divisor for PLL

commit 696160fec162601d06940862b5b3aa4460344c1b
Author: John Stultz <john.stultz@linaro.org>
Date:   Thu Feb 3 12:02:07 2011 -0800

    RTC: Cleanup rtc_class_ops->irq_set_freq()
    
    With the generic rtc code now emulating PIE mode irqs via an
    hrtimer, no one calls the rtc_class_ops->irq_set_freq call.
    
    This patch removes the hook and deletes the driver functions
    if no one else calls them.
    
    CC: Thomas Gleixner <tglx@linutronix.de>
    CC: Alessandro Zummo <a.zummo@towertech.it>
    CC: Marcelo Roberto Jimenez <mroberto@cpti.cetuc.puc-rio.br>
    CC: rtc-linux@googlegroups.com
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/drivers/rtc/rtc-pl031.c b/drivers/rtc/rtc-pl031.c
index 0e7c15b24c1c..d829ea63c4fb 100644
--- a/drivers/rtc/rtc-pl031.c
+++ b/drivers/rtc/rtc-pl031.c
@@ -293,25 +293,6 @@ static int pl031_set_alarm(struct device *dev, struct rtc_wkalrm *alarm)
 	return ret;
 }
 
-static int pl031_irq_set_freq(struct device *dev, int freq)
-{
-	struct pl031_local *ldata = dev_get_drvdata(dev);
-
-	/* Cant set timer if it is already enabled */
-	if (readl(ldata->base + RTC_TCR) & RTC_TCR_EN) {
-		dev_err(dev, "can't change frequency while timer enabled\n");
-		return -EINVAL;
-	}
-
-	/* If self start bit in RTC_TCR is set timer will start here,
-	 * but we never set that bit. Instead we start the timer when
-	 * set_state is called with enabled == 1.
-	 */
-	writel(RTC_TIMER_FREQ / freq, ldata->base + RTC_TLR);
-
-	return 0;
-}
-
 static int pl031_remove(struct amba_device *adev)
 {
 	struct pl031_local *ldata = dev_get_drvdata(&adev->dev);
@@ -408,7 +389,6 @@ static struct rtc_class_ops stv1_pl031_ops = {
 	.read_alarm = pl031_read_alarm,
 	.set_alarm = pl031_set_alarm,
 	.alarm_irq_enable = pl031_alarm_irq_enable,
-	.irq_set_freq = pl031_irq_set_freq,
 };
 
 /* And the second ST derivative */
@@ -418,7 +398,6 @@ static struct rtc_class_ops stv2_pl031_ops = {
 	.read_alarm = pl031_stv2_read_alarm,
 	.set_alarm = pl031_stv2_set_alarm,
 	.alarm_irq_enable = pl031_alarm_irq_enable,
-	.irq_set_freq = pl031_irq_set_freq,
 };
 
 static struct amba_id pl031_ids[] = {

commit 80d4bb515b78f38738f3378fd1be6039063ab040
Author: John Stultz <john.stultz@linaro.org>
Date:   Thu Feb 3 11:34:50 2011 -0800

    RTC: Cleanup rtc_class_ops->irq_set_state
    
    With PIE mode interrupts now emulated in generic code via an hrtimer,
    no one calls rtc_class_ops->irq_set_state(), so this patch removes it
    along with driver implementations.
    
    CC: Thomas Gleixner <tglx@linutronix.de>
    CC: Alessandro Zummo <a.zummo@towertech.it>
    CC: Marcelo Roberto Jimenez <mroberto@cpti.cetuc.puc-rio.br>
    CC: rtc-linux@googlegroups.com
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/drivers/rtc/rtc-pl031.c b/drivers/rtc/rtc-pl031.c
index b7a6690e5b35..0e7c15b24c1c 100644
--- a/drivers/rtc/rtc-pl031.c
+++ b/drivers/rtc/rtc-pl031.c
@@ -293,38 +293,6 @@ static int pl031_set_alarm(struct device *dev, struct rtc_wkalrm *alarm)
 	return ret;
 }
 
-/* Periodic interrupt is only available in ST variants. */
-static int pl031_irq_set_state(struct device *dev, int enabled)
-{
-	struct pl031_local *ldata = dev_get_drvdata(dev);
-
-	if (enabled == 1) {
-		/* Clear any pending timer interrupt. */
-		writel(RTC_BIT_PI, ldata->base + RTC_ICR);
-
-		writel(readl(ldata->base + RTC_IMSC) | RTC_BIT_PI,
-			ldata->base + RTC_IMSC);
-
-		/* Now start the timer */
-		writel(readl(ldata->base + RTC_TCR) | RTC_TCR_EN,
-			ldata->base + RTC_TCR);
-
-	} else {
-		writel(readl(ldata->base + RTC_IMSC) & (~RTC_BIT_PI),
-			ldata->base + RTC_IMSC);
-
-		/* Also stop the timer */
-		writel(readl(ldata->base + RTC_TCR) & (~RTC_TCR_EN),
-			ldata->base + RTC_TCR);
-	}
-	/* Wait at least 1 RTC32 clock cycle to ensure next access
-	 * to RTC_TCR will succeed.
-	 */
-	udelay(40);
-
-	return 0;
-}
-
 static int pl031_irq_set_freq(struct device *dev, int freq)
 {
 	struct pl031_local *ldata = dev_get_drvdata(dev);
@@ -440,7 +408,6 @@ static struct rtc_class_ops stv1_pl031_ops = {
 	.read_alarm = pl031_read_alarm,
 	.set_alarm = pl031_set_alarm,
 	.alarm_irq_enable = pl031_alarm_irq_enable,
-	.irq_set_state = pl031_irq_set_state,
 	.irq_set_freq = pl031_irq_set_freq,
 };
 
@@ -451,7 +418,6 @@ static struct rtc_class_ops stv2_pl031_ops = {
 	.read_alarm = pl031_stv2_read_alarm,
 	.set_alarm = pl031_stv2_set_alarm,
 	.alarm_irq_enable = pl031_alarm_irq_enable,
-	.irq_set_state = pl031_irq_set_state,
 	.irq_set_freq = pl031_irq_set_freq,
 };
 

commit aa25afad2ca60d19457849ea75e9c31236f4e174
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sat Feb 19 15:55:00 2011 +0000

    ARM: amba: make probe() functions take const id tables
    
    Make Primecell driver probe functions take a const pointer to their
    ID tables.  Drivers should never modify their ID tables in their
    probe handler.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/rtc/rtc-pl031.c b/drivers/rtc/rtc-pl031.c
index b7a6690e5b35..6568f4b37e19 100644
--- a/drivers/rtc/rtc-pl031.c
+++ b/drivers/rtc/rtc-pl031.c
@@ -358,7 +358,7 @@ static int pl031_remove(struct amba_device *adev)
 	return 0;
 }
 
-static int pl031_probe(struct amba_device *adev, struct amba_id *id)
+static int pl031_probe(struct amba_device *adev, const struct amba_id *id)
 {
 	int ret;
 	struct pl031_local *ldata;

commit 47016434257b90445113eed1c5b8b57eb2d35330
Author: Linus Walleij <linus.walleij@stericsson.com>
Date:   Thu Sep 9 16:38:04 2010 -0700

    drivers/rtc/rtc-pl031.c: do not mark PL031 IRQ as shared
    
    It was a mistake to mark the PL031 IRQ as shared (for the U8500),
    we misread the datasheet. Get rid of this.
    
    Signed-off-by: Linus Walleij <linus.walleij@stericsson.com>
    Cc: Jonas Aberg <jonas.aberg@stericsson.com>
    Cc: Mian Yousaf Kaukab <mian.yousaf.kaukab@stericsson.com>
    Acked-by: Alessandro Zummo <a.zummo@towertech.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/rtc/rtc-pl031.c b/drivers/rtc/rtc-pl031.c
index 6c418fe7f288..b7a6690e5b35 100644
--- a/drivers/rtc/rtc-pl031.c
+++ b/drivers/rtc/rtc-pl031.c
@@ -403,7 +403,7 @@ static int pl031_probe(struct amba_device *adev, struct amba_id *id)
 	}
 
 	if (request_irq(adev->irq[0], pl031_interrupt,
-			IRQF_DISABLED | IRQF_SHARED, "rtc-pl031", ldata)) {
+			IRQF_DISABLED, "rtc-pl031", ldata)) {
 		ret = -EIO;
 		goto out_no_irq;
 	}

commit 8e58f5778b975d14010b7318fac71e1daac9aabc
Author: Huang Weiyi <weiyi.huang@gmail.com>
Date:   Tue Aug 10 18:02:12 2010 -0700

    drivers/rtc/rtc-pl031.c: remove unused #include <linux/version.h>
    
    Signed-off-by: Huang Weiyi <weiyi.huang@gmail.com>
    Acked-by: Wan ZongShun <mcuos.com@gmail.com>
    Cc: Alessandro Zummo <a.zummo@towertech.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/rtc/rtc-pl031.c b/drivers/rtc/rtc-pl031.c
index 71bbefc3544e..6c418fe7f288 100644
--- a/drivers/rtc/rtc-pl031.c
+++ b/drivers/rtc/rtc-pl031.c
@@ -23,7 +23,6 @@
 #include <linux/io.h>
 #include <linux/bcd.h>
 #include <linux/delay.h>
-#include <linux/version.h>
 #include <linux/slab.h>
 
 /*

commit 2c39c9e149f45ec15a6985cb06ec8f6d904bb35e
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Tue Jul 27 08:50:16 2010 +0100

    ARM: Fix section build warnings for AMBA drivers
    
    Found in the Versatile build:
    
    WARNING: drivers/built-in.o(.data+0x14c): Section mismatch in reference from the variable pl061_gpio_driver to the (unknown reference) .init.data:(unknown)
    The variable pl061_gpio_driver references
    the (unknown reference) __initdata (unknown)
    
    WARNING: drivers/built-in.o(.data+0x40f8): Section mismatch in reference from the variable pl011_driver to the (unknown reference) .init.data:(unknown)
    The variable pl011_driver references
    the (unknown reference) __initdata (unknown)
    
    WARNING: drivers/built-in.o(.data+0x5ab4): Section mismatch in reference from the variable pl031_driver to the (unknown reference) .init.data:(unknown)
    The variable pl031_driver references
    the (unknown reference) __initdata (unknown)
    
    Basically, amba_id structures must not be __initdata.  Also fix:
    
    WARNING: drivers/built-in.o(.data+0x138): Section mismatch in reference from the variable pl061_gpio_driver to the function .init.text:pl061_probe()
    The variable pl061_gpio_driver references
    the function __init pl061_probe()
    
    which is an incorrectly annotated probe function.  Fix it to reflect
    the other AMBA bus probe functions by removing the __init attributation.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/rtc/rtc-pl031.c b/drivers/rtc/rtc-pl031.c
index 3587d9922f28..71bbefc3544e 100644
--- a/drivers/rtc/rtc-pl031.c
+++ b/drivers/rtc/rtc-pl031.c
@@ -456,7 +456,7 @@ static struct rtc_class_ops stv2_pl031_ops = {
 	.irq_set_freq = pl031_irq_set_freq,
 };
 
-static struct amba_id pl031_ids[] __initdata = {
+static struct amba_id pl031_ids[] = {
 	{
 		.id = 0x00041031,
 		.mask = 0x000fffff,

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/rtc/rtc-pl031.c b/drivers/rtc/rtc-pl031.c
index c256aacfa954..3587d9922f28 100644
--- a/drivers/rtc/rtc-pl031.c
+++ b/drivers/rtc/rtc-pl031.c
@@ -24,6 +24,7 @@
 #include <linux/bcd.h>
 #include <linux/delay.h>
 #include <linux/version.h>
+#include <linux/slab.h>
 
 /*
  * Register definitions

commit c72881e8377ca713427486add16fc63256f0231b
Author: Linus Walleij <linus.walleij@stericsson.com>
Date:   Thu Feb 4 12:50:13 2010 +0100

    ARM: 5914/1: Modify PL031 for Nomadik and U8500 v2
    
    This extends the existing PrimeCell PL031 driver with support for
    the ST Microelectronics and ST-Ericsson derivatives, in a first
    and second version as used on the Nomadik and U8500 platforms.
    It also rids the old ioctl() alarm on/off functions in favor of
    the new .alarm_irq_enable field of the RTC class ops.
    
    Signed-off-by: Linus Walleij <linus.walleij@stericsson.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/rtc/rtc-pl031.c b/drivers/rtc/rtc-pl031.c
index 0264b117893b..c256aacfa954 100644
--- a/drivers/rtc/rtc-pl031.c
+++ b/drivers/rtc/rtc-pl031.c
@@ -7,6 +7,9 @@
  *
  * Copyright 2006 (c) MontaVista Software, Inc.
  *
+ * Author: Mian Yousaf Kaukab <mian.yousaf.kaukab@stericsson.com>
+ * Copyright 2010 (c) ST-Ericsson AB
+ *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
  * as published by the Free Software Foundation; either version
@@ -18,6 +21,9 @@
 #include <linux/interrupt.h>
 #include <linux/amba/bus.h>
 #include <linux/io.h>
+#include <linux/bcd.h>
+#include <linux/delay.h>
+#include <linux/version.h>
 
 /*
  * Register definitions
@@ -30,35 +36,207 @@
 #define	RTC_RIS		0x14	/* Raw interrupt status register */
 #define	RTC_MIS		0x18	/* Masked interrupt status register */
 #define	RTC_ICR		0x1c	/* Interrupt clear register */
+/* ST variants have additional timer functionality */
+#define RTC_TDR		0x20	/* Timer data read register */
+#define RTC_TLR		0x24	/* Timer data load register */
+#define RTC_TCR		0x28	/* Timer control register */
+#define RTC_YDR		0x30	/* Year data read register */
+#define RTC_YMR		0x34	/* Year match register */
+#define RTC_YLR		0x38	/* Year data load register */
+
+#define RTC_CR_CWEN	(1 << 26)	/* Clockwatch enable bit */
+
+#define RTC_TCR_EN	(1 << 1) /* Periodic timer enable bit */
+
+/* Common bit definitions for Interrupt status and control registers */
+#define RTC_BIT_AI	(1 << 0) /* Alarm interrupt bit */
+#define RTC_BIT_PI	(1 << 1) /* Periodic interrupt bit. ST variants only. */
+
+/* Common bit definations for ST v2 for reading/writing time */
+#define RTC_SEC_SHIFT 0
+#define RTC_SEC_MASK (0x3F << RTC_SEC_SHIFT) /* Second [0-59] */
+#define RTC_MIN_SHIFT 6
+#define RTC_MIN_MASK (0x3F << RTC_MIN_SHIFT) /* Minute [0-59] */
+#define RTC_HOUR_SHIFT 12
+#define RTC_HOUR_MASK (0x1F << RTC_HOUR_SHIFT) /* Hour [0-23] */
+#define RTC_WDAY_SHIFT 17
+#define RTC_WDAY_MASK (0x7 << RTC_WDAY_SHIFT) /* Day of Week [1-7] 1=Sunday */
+#define RTC_MDAY_SHIFT 20
+#define RTC_MDAY_MASK (0x1F << RTC_MDAY_SHIFT) /* Day of Month [1-31] */
+#define RTC_MON_SHIFT 25
+#define RTC_MON_MASK (0xF << RTC_MON_SHIFT) /* Month [1-12] 1=January */
+
+#define RTC_TIMER_FREQ 32768
 
 struct pl031_local {
 	struct rtc_device *rtc;
 	void __iomem *base;
+	u8 hw_designer;
+	u8 hw_revision:4;
 };
 
-static irqreturn_t pl031_interrupt(int irq, void *dev_id)
+static int pl031_alarm_irq_enable(struct device *dev,
+	unsigned int enabled)
+{
+	struct pl031_local *ldata = dev_get_drvdata(dev);
+	unsigned long imsc;
+
+	/* Clear any pending alarm interrupts. */
+	writel(RTC_BIT_AI, ldata->base + RTC_ICR);
+
+	imsc = readl(ldata->base + RTC_IMSC);
+
+	if (enabled == 1)
+		writel(imsc | RTC_BIT_AI, ldata->base + RTC_IMSC);
+	else
+		writel(imsc & ~RTC_BIT_AI, ldata->base + RTC_IMSC);
+
+	return 0;
+}
+
+/*
+ * Convert Gregorian date to ST v2 RTC format.
+ */
+static int pl031_stv2_tm_to_time(struct device *dev,
+				 struct rtc_time *tm, unsigned long *st_time,
+	unsigned long *bcd_year)
+{
+	int year = tm->tm_year + 1900;
+	int wday = tm->tm_wday;
+
+	/* wday masking is not working in hardware so wday must be valid */
+	if (wday < -1 || wday > 6) {
+		dev_err(dev, "invalid wday value %d\n", tm->tm_wday);
+		return -EINVAL;
+	} else if (wday == -1) {
+		/* wday is not provided, calculate it here */
+		unsigned long time;
+		struct rtc_time calc_tm;
+
+		rtc_tm_to_time(tm, &time);
+		rtc_time_to_tm(time, &calc_tm);
+		wday = calc_tm.tm_wday;
+	}
+
+	*bcd_year = (bin2bcd(year % 100) | bin2bcd(year / 100) << 8);
+
+	*st_time = ((tm->tm_mon + 1) << RTC_MON_SHIFT)
+			|	(tm->tm_mday << RTC_MDAY_SHIFT)
+			|	((wday + 1) << RTC_WDAY_SHIFT)
+			|	(tm->tm_hour << RTC_HOUR_SHIFT)
+			|	(tm->tm_min << RTC_MIN_SHIFT)
+			|	(tm->tm_sec << RTC_SEC_SHIFT);
+
+	return 0;
+}
+
+/*
+ * Convert ST v2 RTC format to Gregorian date.
+ */
+static int pl031_stv2_time_to_tm(unsigned long st_time, unsigned long bcd_year,
+	struct rtc_time *tm)
+{
+	tm->tm_year = bcd2bin(bcd_year) + (bcd2bin(bcd_year >> 8) * 100);
+	tm->tm_mon  = ((st_time & RTC_MON_MASK) >> RTC_MON_SHIFT) - 1;
+	tm->tm_mday = ((st_time & RTC_MDAY_MASK) >> RTC_MDAY_SHIFT);
+	tm->tm_wday = ((st_time & RTC_WDAY_MASK) >> RTC_WDAY_SHIFT) - 1;
+	tm->tm_hour = ((st_time & RTC_HOUR_MASK) >> RTC_HOUR_SHIFT);
+	tm->tm_min  = ((st_time & RTC_MIN_MASK) >> RTC_MIN_SHIFT);
+	tm->tm_sec  = ((st_time & RTC_SEC_MASK) >> RTC_SEC_SHIFT);
+
+	tm->tm_yday = rtc_year_days(tm->tm_mday, tm->tm_mon, tm->tm_year);
+	tm->tm_year -= 1900;
+
+	return 0;
+}
+
+static int pl031_stv2_read_time(struct device *dev, struct rtc_time *tm)
+{
+	struct pl031_local *ldata = dev_get_drvdata(dev);
+
+	pl031_stv2_time_to_tm(readl(ldata->base + RTC_DR),
+			readl(ldata->base + RTC_YDR), tm);
+
+	return 0;
+}
+
+static int pl031_stv2_set_time(struct device *dev, struct rtc_time *tm)
+{
+	unsigned long time;
+	unsigned long bcd_year;
+	struct pl031_local *ldata = dev_get_drvdata(dev);
+	int ret;
+
+	ret = pl031_stv2_tm_to_time(dev, tm, &time, &bcd_year);
+	if (ret == 0) {
+		writel(bcd_year, ldata->base + RTC_YLR);
+		writel(time, ldata->base + RTC_LR);
+	}
+
+	return ret;
+}
+
+static int pl031_stv2_read_alarm(struct device *dev, struct rtc_wkalrm *alarm)
 {
-	struct rtc_device *rtc = dev_id;
+	struct pl031_local *ldata = dev_get_drvdata(dev);
+	int ret;
 
-	rtc_update_irq(rtc, 1, RTC_AF);
+	ret = pl031_stv2_time_to_tm(readl(ldata->base + RTC_MR),
+			readl(ldata->base + RTC_YMR), &alarm->time);
 
-	return IRQ_HANDLED;
+	alarm->pending = readl(ldata->base + RTC_RIS) & RTC_BIT_AI;
+	alarm->enabled = readl(ldata->base + RTC_IMSC) & RTC_BIT_AI;
+
+	return ret;
 }
 
-static int pl031_ioctl(struct device *dev, unsigned int cmd, unsigned long arg)
+static int pl031_stv2_set_alarm(struct device *dev, struct rtc_wkalrm *alarm)
 {
 	struct pl031_local *ldata = dev_get_drvdata(dev);
+	unsigned long time;
+	unsigned long bcd_year;
+	int ret;
+
+	/* At the moment, we can only deal with non-wildcarded alarm times. */
+	ret = rtc_valid_tm(&alarm->time);
+	if (ret == 0) {
+		ret = pl031_stv2_tm_to_time(dev, &alarm->time,
+					    &time, &bcd_year);
+		if (ret == 0) {
+			writel(bcd_year, ldata->base + RTC_YMR);
+			writel(time, ldata->base + RTC_MR);
+
+			pl031_alarm_irq_enable(dev, alarm->enabled);
+		}
+	}
+
+	return ret;
+}
+
+static irqreturn_t pl031_interrupt(int irq, void *dev_id)
+{
+	struct pl031_local *ldata = dev_id;
+	unsigned long rtcmis;
+	unsigned long events = 0;
+
+	rtcmis = readl(ldata->base + RTC_MIS);
+	if (rtcmis) {
+		writel(rtcmis, ldata->base + RTC_ICR);
+
+		if (rtcmis & RTC_BIT_AI)
+			events |= (RTC_AF | RTC_IRQF);
+
+		/* Timer interrupt is only available in ST variants */
+		if ((rtcmis & RTC_BIT_PI) &&
+			(ldata->hw_designer == AMBA_VENDOR_ST))
+			events |= (RTC_PF | RTC_IRQF);
+
+		rtc_update_irq(ldata->rtc, 1, events);
 
-	switch (cmd) {
-	case RTC_AIE_OFF:
-		writel(1, ldata->base + RTC_MIS);
-		return 0;
-	case RTC_AIE_ON:
-		writel(0, ldata->base + RTC_MIS);
-		return 0;
+		return IRQ_HANDLED;
 	}
 
-	return -ENOIOCTLCMD;
+	return IRQ_NONE;
 }
 
 static int pl031_read_time(struct device *dev, struct rtc_time *tm)
@@ -74,11 +252,14 @@ static int pl031_set_time(struct device *dev, struct rtc_time *tm)
 {
 	unsigned long time;
 	struct pl031_local *ldata = dev_get_drvdata(dev);
+	int ret;
 
-	rtc_tm_to_time(tm, &time);
-	writel(time, ldata->base + RTC_LR);
+	ret = rtc_tm_to_time(tm, &time);
 
-	return 0;
+	if (ret == 0)
+		writel(time, ldata->base + RTC_LR);
+
+	return ret;
 }
 
 static int pl031_read_alarm(struct device *dev, struct rtc_wkalrm *alarm)
@@ -86,8 +267,9 @@ static int pl031_read_alarm(struct device *dev, struct rtc_wkalrm *alarm)
 	struct pl031_local *ldata = dev_get_drvdata(dev);
 
 	rtc_time_to_tm(readl(ldata->base + RTC_MR), &alarm->time);
-	alarm->pending = readl(ldata->base + RTC_RIS);
-	alarm->enabled = readl(ldata->base + RTC_IMSC);
+
+	alarm->pending = readl(ldata->base + RTC_RIS) & RTC_BIT_AI;
+	alarm->enabled = readl(ldata->base + RTC_IMSC) & RTC_BIT_AI;
 
 	return 0;
 }
@@ -96,22 +278,71 @@ static int pl031_set_alarm(struct device *dev, struct rtc_wkalrm *alarm)
 {
 	struct pl031_local *ldata = dev_get_drvdata(dev);
 	unsigned long time;
+	int ret;
+
+	/* At the moment, we can only deal with non-wildcarded alarm times. */
+	ret = rtc_valid_tm(&alarm->time);
+	if (ret == 0) {
+		ret = rtc_tm_to_time(&alarm->time, &time);
+		if (ret == 0) {
+			writel(time, ldata->base + RTC_MR);
+			pl031_alarm_irq_enable(dev, alarm->enabled);
+		}
+	}
+
+	return ret;
+}
+
+/* Periodic interrupt is only available in ST variants. */
+static int pl031_irq_set_state(struct device *dev, int enabled)
+{
+	struct pl031_local *ldata = dev_get_drvdata(dev);
+
+	if (enabled == 1) {
+		/* Clear any pending timer interrupt. */
+		writel(RTC_BIT_PI, ldata->base + RTC_ICR);
+
+		writel(readl(ldata->base + RTC_IMSC) | RTC_BIT_PI,
+			ldata->base + RTC_IMSC);
 
-	rtc_tm_to_time(&alarm->time, &time);
+		/* Now start the timer */
+		writel(readl(ldata->base + RTC_TCR) | RTC_TCR_EN,
+			ldata->base + RTC_TCR);
 
-	writel(time, ldata->base + RTC_MR);
-	writel(!alarm->enabled, ldata->base + RTC_MIS);
+	} else {
+		writel(readl(ldata->base + RTC_IMSC) & (~RTC_BIT_PI),
+			ldata->base + RTC_IMSC);
+
+		/* Also stop the timer */
+		writel(readl(ldata->base + RTC_TCR) & (~RTC_TCR_EN),
+			ldata->base + RTC_TCR);
+	}
+	/* Wait at least 1 RTC32 clock cycle to ensure next access
+	 * to RTC_TCR will succeed.
+	 */
+	udelay(40);
 
 	return 0;
 }
 
-static const struct rtc_class_ops pl031_ops = {
-	.ioctl = pl031_ioctl,
-	.read_time = pl031_read_time,
-	.set_time = pl031_set_time,
-	.read_alarm = pl031_read_alarm,
-	.set_alarm = pl031_set_alarm,
-};
+static int pl031_irq_set_freq(struct device *dev, int freq)
+{
+	struct pl031_local *ldata = dev_get_drvdata(dev);
+
+	/* Cant set timer if it is already enabled */
+	if (readl(ldata->base + RTC_TCR) & RTC_TCR_EN) {
+		dev_err(dev, "can't change frequency while timer enabled\n");
+		return -EINVAL;
+	}
+
+	/* If self start bit in RTC_TCR is set timer will start here,
+	 * but we never set that bit. Instead we start the timer when
+	 * set_state is called with enabled == 1.
+	 */
+	writel(RTC_TIMER_FREQ / freq, ldata->base + RTC_TLR);
+
+	return 0;
+}
 
 static int pl031_remove(struct amba_device *adev)
 {
@@ -131,18 +362,20 @@ static int pl031_probe(struct amba_device *adev, struct amba_id *id)
 {
 	int ret;
 	struct pl031_local *ldata;
+	struct rtc_class_ops *ops = id->data;
 
 	ret = amba_request_regions(adev, NULL);
 	if (ret)
 		goto err_req;
 
-	ldata = kmalloc(sizeof(struct pl031_local), GFP_KERNEL);
+	ldata = kzalloc(sizeof(struct pl031_local), GFP_KERNEL);
 	if (!ldata) {
 		ret = -ENOMEM;
 		goto out;
 	}
 
 	ldata->base = ioremap(adev->res.start, resource_size(&adev->res));
+
 	if (!ldata->base) {
 		ret = -ENOMEM;
 		goto out_no_remap;
@@ -150,24 +383,36 @@ static int pl031_probe(struct amba_device *adev, struct amba_id *id)
 
 	amba_set_drvdata(adev, ldata);
 
-	if (request_irq(adev->irq[0], pl031_interrupt, IRQF_DISABLED,
-			"rtc-pl031", ldata->rtc)) {
-		ret = -EIO;
-		goto out_no_irq;
-	}
+	ldata->hw_designer = amba_manf(adev);
+	ldata->hw_revision = amba_rev(adev);
+
+	dev_dbg(&adev->dev, "designer ID = 0x%02x\n", ldata->hw_designer);
+	dev_dbg(&adev->dev, "revision = 0x%01x\n", ldata->hw_revision);
 
-	ldata->rtc = rtc_device_register("pl031", &adev->dev, &pl031_ops,
-					 THIS_MODULE);
+	/* Enable the clockwatch on ST Variants */
+	if ((ldata->hw_designer == AMBA_VENDOR_ST) &&
+	    (ldata->hw_revision > 1))
+		writel(readl(ldata->base + RTC_CR) | RTC_CR_CWEN,
+		       ldata->base + RTC_CR);
+
+	ldata->rtc = rtc_device_register("pl031", &adev->dev, ops,
+					THIS_MODULE);
 	if (IS_ERR(ldata->rtc)) {
 		ret = PTR_ERR(ldata->rtc);
 		goto out_no_rtc;
 	}
 
+	if (request_irq(adev->irq[0], pl031_interrupt,
+			IRQF_DISABLED | IRQF_SHARED, "rtc-pl031", ldata)) {
+		ret = -EIO;
+		goto out_no_irq;
+	}
+
 	return 0;
 
-out_no_rtc:
-	free_irq(adev->irq[0], ldata->rtc);
 out_no_irq:
+	rtc_device_unregister(ldata->rtc);
+out_no_rtc:
 	iounmap(ldata->base);
 	amba_set_drvdata(adev, NULL);
 out_no_remap:
@@ -175,13 +420,57 @@ static int pl031_probe(struct amba_device *adev, struct amba_id *id)
 out:
 	amba_release_regions(adev);
 err_req:
+
 	return ret;
 }
 
+/* Operations for the original ARM version */
+static struct rtc_class_ops arm_pl031_ops = {
+	.read_time = pl031_read_time,
+	.set_time = pl031_set_time,
+	.read_alarm = pl031_read_alarm,
+	.set_alarm = pl031_set_alarm,
+	.alarm_irq_enable = pl031_alarm_irq_enable,
+};
+
+/* The First ST derivative */
+static struct rtc_class_ops stv1_pl031_ops = {
+	.read_time = pl031_read_time,
+	.set_time = pl031_set_time,
+	.read_alarm = pl031_read_alarm,
+	.set_alarm = pl031_set_alarm,
+	.alarm_irq_enable = pl031_alarm_irq_enable,
+	.irq_set_state = pl031_irq_set_state,
+	.irq_set_freq = pl031_irq_set_freq,
+};
+
+/* And the second ST derivative */
+static struct rtc_class_ops stv2_pl031_ops = {
+	.read_time = pl031_stv2_read_time,
+	.set_time = pl031_stv2_set_time,
+	.read_alarm = pl031_stv2_read_alarm,
+	.set_alarm = pl031_stv2_set_alarm,
+	.alarm_irq_enable = pl031_alarm_irq_enable,
+	.irq_set_state = pl031_irq_set_state,
+	.irq_set_freq = pl031_irq_set_freq,
+};
+
 static struct amba_id pl031_ids[] __initdata = {
 	{
 		.id = 0x00041031,
 		.mask = 0x000fffff,
+		.data = &arm_pl031_ops,
+	},
+	/* ST Micro variants */
+	{
+		.id = 0x00180031,
+		.mask = 0x00ffffff,
+		.data = &stv1_pl031_ops,
+	},
+	{
+		.id = 0x00280031,
+		.mask = 0x00ffffff,
+		.data = &stv2_pl031_ops,
 	},
 	{0, 0},
 };

commit 2934d6a859b70e57c729644e169a4fdf8c1c290c
Author: Linus Walleij <linus.walleij@stericsson.com>
Date:   Tue Dec 15 16:46:13 2009 -0800

    rtc: remove __raw_* accessors from PL031 RTC
    
    This switches __raw_[read|write]l() for plain [read|write]l in the PL031
    RTC driver.  The sister driver for PL030 use the simple accessors as most
    PrimeCell drivers.
    
    Signed-off-by: Linus Walleij <linus.walleij@stericsson.com>
    Signed-off-by: Alessandro Zummo <a.zummo@towertech.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/rtc/rtc-pl031.c b/drivers/rtc/rtc-pl031.c
index f41873f98f66..0264b117893b 100644
--- a/drivers/rtc/rtc-pl031.c
+++ b/drivers/rtc/rtc-pl031.c
@@ -51,10 +51,10 @@ static int pl031_ioctl(struct device *dev, unsigned int cmd, unsigned long arg)
 
 	switch (cmd) {
 	case RTC_AIE_OFF:
-		__raw_writel(1, ldata->base + RTC_MIS);
+		writel(1, ldata->base + RTC_MIS);
 		return 0;
 	case RTC_AIE_ON:
-		__raw_writel(0, ldata->base + RTC_MIS);
+		writel(0, ldata->base + RTC_MIS);
 		return 0;
 	}
 
@@ -65,7 +65,7 @@ static int pl031_read_time(struct device *dev, struct rtc_time *tm)
 {
 	struct pl031_local *ldata = dev_get_drvdata(dev);
 
-	rtc_time_to_tm(__raw_readl(ldata->base + RTC_DR), tm);
+	rtc_time_to_tm(readl(ldata->base + RTC_DR), tm);
 
 	return 0;
 }
@@ -76,7 +76,7 @@ static int pl031_set_time(struct device *dev, struct rtc_time *tm)
 	struct pl031_local *ldata = dev_get_drvdata(dev);
 
 	rtc_tm_to_time(tm, &time);
-	__raw_writel(time, ldata->base + RTC_LR);
+	writel(time, ldata->base + RTC_LR);
 
 	return 0;
 }
@@ -85,9 +85,9 @@ static int pl031_read_alarm(struct device *dev, struct rtc_wkalrm *alarm)
 {
 	struct pl031_local *ldata = dev_get_drvdata(dev);
 
-	rtc_time_to_tm(__raw_readl(ldata->base + RTC_MR), &alarm->time);
-	alarm->pending = __raw_readl(ldata->base + RTC_RIS);
-	alarm->enabled = __raw_readl(ldata->base + RTC_IMSC);
+	rtc_time_to_tm(readl(ldata->base + RTC_MR), &alarm->time);
+	alarm->pending = readl(ldata->base + RTC_RIS);
+	alarm->enabled = readl(ldata->base + RTC_IMSC);
 
 	return 0;
 }
@@ -99,8 +99,8 @@ static int pl031_set_alarm(struct device *dev, struct rtc_wkalrm *alarm)
 
 	rtc_tm_to_time(&alarm->time, &time);
 
-	__raw_writel(time, ldata->base + RTC_MR);
-	__raw_writel(!alarm->enabled, ldata->base + RTC_MIS);
+	writel(time, ldata->base + RTC_MR);
+	writel(!alarm->enabled, ldata->base + RTC_MIS);
 
 	return 0;
 }
@@ -180,8 +180,9 @@ static int pl031_probe(struct amba_device *adev, struct amba_id *id)
 
 static struct amba_id pl031_ids[] __initdata = {
 	{
-		 .id = 0x00041031,
-	 	.mask = 0x000fffff, },
+		.id = 0x00041031,
+		.mask = 0x000fffff,
+	},
 	{0, 0},
 };
 

commit dc890c2dcd63a90de68ee5f0253eefbb89d725f0
Author: Linus Walleij <linus.walleij@stericsson.com>
Date:   Sun Jun 7 23:27:31 2009 +0100

    [ARM] 5544/1: Trust PrimeCell resource sizes
    
    I found the PrimeCell/AMBA Bus drivers distrusting the resource
    passed in as part of the struct amba_device abstraction. This
    patch removes all hard coded resource sizes found in the PrimeCell
    drivers and move the responsibility of this definition back to
    the platform/board device definition, which already exist and
    appear to be correct for all in-tree users of these drivers.
    We do this using the resource_size() inline function which was
    also replicated in the only driver using the resource size, so
    that has been changed too. The KMI_SIZE was left in kmi.h in case
    someone likes it. Test-compiled against Versatile and Integrator
    defconfigs, seems to work but I don't posess these boards and
    cannot test them.
    
    Signed-off-by: Linus Walleij <linus.walleij@stericsson.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/rtc/rtc-pl031.c b/drivers/rtc/rtc-pl031.c
index 451fc13784d1..f41873f98f66 100644
--- a/drivers/rtc/rtc-pl031.c
+++ b/drivers/rtc/rtc-pl031.c
@@ -142,8 +142,7 @@ static int pl031_probe(struct amba_device *adev, struct amba_id *id)
 		goto out;
 	}
 
-	ldata->base = ioremap(adev->res.start,
-			      adev->res.end - adev->res.start + 1);
+	ldata->base = ioremap(adev->res.start, resource_size(&adev->res));
 	if (!ldata->base) {
 		ret = -ENOMEM;
 		goto out_no_remap;

commit 03fbdb15c14e9746c63168e3ff2c64b9c8336d33
Author: Alessandro Rubini <rubini@gnudd.com>
Date:   Wed May 20 22:39:08 2009 +0100

    [ARM] 5519/1: amba probe: pass "struct amba_id *" instead of void *
    
    The second argument of the probe method points to the amba_id
    structure, so it's better passed with the correct type. None of the
    current in-tree drivers uses the pointer, so they have only been
    checked for a clean compile.
    
    Change suggested by Russell King.
    
    Signed-off-by: Alessandro Rubini <rubini@unipv.it>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/rtc/rtc-pl031.c b/drivers/rtc/rtc-pl031.c
index 333eec689d2f..451fc13784d1 100644
--- a/drivers/rtc/rtc-pl031.c
+++ b/drivers/rtc/rtc-pl031.c
@@ -127,7 +127,7 @@ static int pl031_remove(struct amba_device *adev)
 	return 0;
 }
 
-static int pl031_probe(struct amba_device *adev, void *id)
+static int pl031_probe(struct amba_device *adev, struct amba_id *id)
 {
 	int ret;
 	struct pl031_local *ldata;

commit f841a487d4dff35386e989768ec03a86a376bfde
Author: David Brownell <dbrownell@users.sourceforge.net>
Date:   Wed Oct 15 22:02:59 2008 -0700

    rtc: remove some NOP open/release methods
    
    Remove NOP methods from rtc-pl030 and rtc-pl031 drivers;
    this is pure wasted code.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Cc: Alessandro Zummo <a.zummo@towertech.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/rtc/rtc-pl031.c b/drivers/rtc/rtc-pl031.c
index 08b4610ec5a6..333eec689d2f 100644
--- a/drivers/rtc/rtc-pl031.c
+++ b/drivers/rtc/rtc-pl031.c
@@ -45,18 +45,6 @@ static irqreturn_t pl031_interrupt(int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
-static int pl031_open(struct device *dev)
-{
-	/*
-	 * We request IRQ in pl031_probe, so nothing to do here...
-	 */
-	return 0;
-}
-
-static void pl031_release(struct device *dev)
-{
-}
-
 static int pl031_ioctl(struct device *dev, unsigned int cmd, unsigned long arg)
 {
 	struct pl031_local *ldata = dev_get_drvdata(dev);
@@ -118,8 +106,6 @@ static int pl031_set_alarm(struct device *dev, struct rtc_wkalrm *alarm)
 }
 
 static const struct rtc_class_ops pl031_ops = {
-	.open = pl031_open,
-	.release = pl031_release,
 	.ioctl = pl031_ioctl,
 	.read_time = pl031_read_time,
 	.set_time = pl031_set_time,

commit 2dba8518b7761aee3ba757b298efa15dd34eff18
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sun Apr 20 12:08:04 2008 +0100

    [RTC] rtc-pl031: use proper resources, use proper apis, clean up includes
    
    Clean up PL031 RTC includes, make driver use proper resource checking,
    and use amba bus specific accessors.
    
    Acked-by: Alessandro Zummo <a.zummo@towertech.it>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/rtc/rtc-pl031.c b/drivers/rtc/rtc-pl031.c
index 2fd49edcc712..08b4610ec5a6 100644
--- a/drivers/rtc/rtc-pl031.c
+++ b/drivers/rtc/rtc-pl031.c
@@ -12,23 +12,12 @@
  * as published by the Free Software Foundation; either version
  * 2 of the License, or (at your option) any later version.
  */
-
-#include <linux/platform_device.h>
 #include <linux/module.h>
 #include <linux/rtc.h>
 #include <linux/init.h>
-#include <linux/fs.h>
 #include <linux/interrupt.h>
-#include <linux/string.h>
-#include <linux/pm.h>
-#include <linux/bitops.h>
-
 #include <linux/amba/bus.h>
-
-#include <asm/io.h>
-#include <asm/hardware.h>
-#include <asm/irq.h>
-#include <asm/rtc.h>
+#include <linux/io.h>
 
 /*
  * Register definitions
@@ -142,13 +131,12 @@ static int pl031_remove(struct amba_device *adev)
 {
 	struct pl031_local *ldata = dev_get_drvdata(&adev->dev);
 
-	if (ldata) {
-		dev_set_drvdata(&adev->dev, NULL);
-		free_irq(adev->irq[0], ldata->rtc);
-		rtc_device_unregister(ldata->rtc);
-		iounmap(ldata->base);
-		kfree(ldata);
-	}
+	amba_set_drvdata(adev, NULL);
+	free_irq(adev->irq[0], ldata->rtc);
+	rtc_device_unregister(ldata->rtc);
+	iounmap(ldata->base);
+	kfree(ldata);
+	amba_release_regions(adev);
 
 	return 0;
 }
@@ -158,13 +146,15 @@ static int pl031_probe(struct amba_device *adev, void *id)
 	int ret;
 	struct pl031_local *ldata;
 
+	ret = amba_request_regions(adev, NULL);
+	if (ret)
+		goto err_req;
 
 	ldata = kmalloc(sizeof(struct pl031_local), GFP_KERNEL);
 	if (!ldata) {
 		ret = -ENOMEM;
 		goto out;
 	}
-	dev_set_drvdata(&adev->dev, ldata);
 
 	ldata->base = ioremap(adev->res.start,
 			      adev->res.end - adev->res.start + 1);
@@ -173,6 +163,8 @@ static int pl031_probe(struct amba_device *adev, void *id)
 		goto out_no_remap;
 	}
 
+	amba_set_drvdata(adev, ldata);
+
 	if (request_irq(adev->irq[0], pl031_interrupt, IRQF_DISABLED,
 			"rtc-pl031", ldata->rtc)) {
 		ret = -EIO;
@@ -192,10 +184,12 @@ static int pl031_probe(struct amba_device *adev, void *id)
 	free_irq(adev->irq[0], ldata->rtc);
 out_no_irq:
 	iounmap(ldata->base);
+	amba_set_drvdata(adev, NULL);
 out_no_remap:
-	dev_set_drvdata(&adev->dev, NULL);
 	kfree(ldata);
 out:
+	amba_release_regions(adev);
+err_req:
 	return ret;
 }
 

commit 1977f032722c27ee3730284582fd3991ad9ac81b
Author: Jiri Slaby <jirislaby@gmail.com>
Date:   Thu Oct 18 23:40:25 2007 -0700

    remove asm/bitops.h includes
    
    remove asm/bitops.h includes
    
    including asm/bitops directly may cause compile errors. don't include it
    and include linux/bitops instead. next patch will deny including asm header
    directly.
    
    Cc: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Jiri Slaby <jirislaby@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/rtc/rtc-pl031.c b/drivers/rtc/rtc-pl031.c
index e4bf68ca96f7..2fd49edcc712 100644
--- a/drivers/rtc/rtc-pl031.c
+++ b/drivers/rtc/rtc-pl031.c
@@ -21,11 +21,11 @@
 #include <linux/interrupt.h>
 #include <linux/string.h>
 #include <linux/pm.h>
+#include <linux/bitops.h>
 
 #include <linux/amba/bus.h>
 
 #include <asm/io.h>
-#include <asm/bitops.h>
 #include <asm/hardware.h>
 #include <asm/irq.h>
 #include <asm/rtc.h>

commit ab6a2d70d18edc7a716ef3127b9e13382faec98c
Author: David Brownell <david-b@pacbell.net>
Date:   Tue May 8 00:33:30 2007 -0700

    rtc: rtc interfaces don't use class_device
    
    This patch removes class_device from the programming interface that the RTC
    framework exposes to the rest of the kernel.  Now an rtc_device is passed,
    which is more type-safe and streamlines all the relevant code.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Acked-By: Alessandro Zummo <a.zummo@towertech.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/rtc/rtc-pl031.c b/drivers/rtc/rtc-pl031.c
index f13daa9fecaa..e4bf68ca96f7 100644
--- a/drivers/rtc/rtc-pl031.c
+++ b/drivers/rtc/rtc-pl031.c
@@ -51,7 +51,7 @@ static irqreturn_t pl031_interrupt(int irq, void *dev_id)
 {
 	struct rtc_device *rtc = dev_id;
 
-	rtc_update_irq(&rtc->class_dev, 1, RTC_AF);
+	rtc_update_irq(rtc, 1, RTC_AF);
 
 	return IRQ_HANDLED;
 }

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/drivers/rtc/rtc-pl031.c b/drivers/rtc/rtc-pl031.c
index 739d1a6e14eb..f13daa9fecaa 100644
--- a/drivers/rtc/rtc-pl031.c
+++ b/drivers/rtc/rtc-pl031.c
@@ -47,7 +47,7 @@ struct pl031_local {
 	void __iomem *base;
 };
 
-static irqreturn_t pl031_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t pl031_interrupt(int irq, void *dev_id)
 {
 	struct rtc_device *rtc = dev_id;
 

commit ff8371ac9a5a55c956991fed8e5f58640c7a32f3
Author: David Brownell <david-b@pacbell.net>
Date:   Sat Sep 30 23:28:17 2006 -0700

    [PATCH] constify rtc_class_ops: update drivers
    
    Update RTC framework so that drivers can constify their method tables, moving
    them from ".data" to ".rodata".  Then update the drivers.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Cc: Alessandro Zummo <a.zummo@towertech.it>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/rtc/rtc-pl031.c b/drivers/rtc/rtc-pl031.c
index d6d1c5726b0e..739d1a6e14eb 100644
--- a/drivers/rtc/rtc-pl031.c
+++ b/drivers/rtc/rtc-pl031.c
@@ -128,7 +128,7 @@ static int pl031_set_alarm(struct device *dev, struct rtc_wkalrm *alarm)
 	return 0;
 }
 
-static struct rtc_class_ops pl031_ops = {
+static const struct rtc_class_ops pl031_ops = {
 	.open = pl031_open,
 	.release = pl031_release,
 	.ioctl = pl031_ioctl,

commit dace145374b8e39aeb920304c358ab5e220341ab
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jul 1 19:29:38 2006 -0700

    [PATCH] irq-flags: misc drivers: Use the new IRQF_ constants
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/rtc/rtc-pl031.c b/drivers/rtc/rtc-pl031.c
index ee538632660b..d6d1c5726b0e 100644
--- a/drivers/rtc/rtc-pl031.c
+++ b/drivers/rtc/rtc-pl031.c
@@ -173,7 +173,7 @@ static int pl031_probe(struct amba_device *adev, void *id)
 		goto out_no_remap;
 	}
 
-	if (request_irq(adev->irq[0], pl031_interrupt, SA_INTERRUPT,
+	if (request_irq(adev->irq[0], pl031_interrupt, IRQF_DISABLED,
 			"rtc-pl031", ldata->rtc)) {
 		ret = -EIO;
 		goto out_no_irq;

commit 8ae6e163c1b637e1cb125613726ffbd31ca44fdf
Author: Deepak Saxena <dsaxena@plexity.net>
Date:   Sun Jun 25 05:47:38 2006 -0700

    [PATCH] Add driver for ARM AMBA PL031 RTC
    
    Add a driver for the ARM PL031 RTC found on some ARM SOCs.  The driver is
    fairly trivial as the RTC only provides a read/write and alarm capability.
    
    [akpm@osdl.org: compile fix]
    Signed-off-by: Deepak <dsaxena@plexity.net>
    Acked-by: Alessandro Zummo <a.zummo@towertech.it>
    Cc: Russell King <rmk@arm.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/rtc/rtc-pl031.c b/drivers/rtc/rtc-pl031.c
new file mode 100644
index 000000000000..ee538632660b
--- /dev/null
+++ b/drivers/rtc/rtc-pl031.c
@@ -0,0 +1,233 @@
+/*
+ * drivers/rtc/rtc-pl031.c
+ *
+ * Real Time Clock interface for ARM AMBA PrimeCell 031 RTC
+ *
+ * Author: Deepak Saxena <dsaxena@plexity.net>
+ *
+ * Copyright 2006 (c) MontaVista Software, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/module.h>
+#include <linux/rtc.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/interrupt.h>
+#include <linux/string.h>
+#include <linux/pm.h>
+
+#include <linux/amba/bus.h>
+
+#include <asm/io.h>
+#include <asm/bitops.h>
+#include <asm/hardware.h>
+#include <asm/irq.h>
+#include <asm/rtc.h>
+
+/*
+ * Register definitions
+ */
+#define	RTC_DR		0x00	/* Data read register */
+#define	RTC_MR		0x04	/* Match register */
+#define	RTC_LR		0x08	/* Data load register */
+#define	RTC_CR		0x0c	/* Control register */
+#define	RTC_IMSC	0x10	/* Interrupt mask and set register */
+#define	RTC_RIS		0x14	/* Raw interrupt status register */
+#define	RTC_MIS		0x18	/* Masked interrupt status register */
+#define	RTC_ICR		0x1c	/* Interrupt clear register */
+
+struct pl031_local {
+	struct rtc_device *rtc;
+	void __iomem *base;
+};
+
+static irqreturn_t pl031_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct rtc_device *rtc = dev_id;
+
+	rtc_update_irq(&rtc->class_dev, 1, RTC_AF);
+
+	return IRQ_HANDLED;
+}
+
+static int pl031_open(struct device *dev)
+{
+	/*
+	 * We request IRQ in pl031_probe, so nothing to do here...
+	 */
+	return 0;
+}
+
+static void pl031_release(struct device *dev)
+{
+}
+
+static int pl031_ioctl(struct device *dev, unsigned int cmd, unsigned long arg)
+{
+	struct pl031_local *ldata = dev_get_drvdata(dev);
+
+	switch (cmd) {
+	case RTC_AIE_OFF:
+		__raw_writel(1, ldata->base + RTC_MIS);
+		return 0;
+	case RTC_AIE_ON:
+		__raw_writel(0, ldata->base + RTC_MIS);
+		return 0;
+	}
+
+	return -ENOIOCTLCMD;
+}
+
+static int pl031_read_time(struct device *dev, struct rtc_time *tm)
+{
+	struct pl031_local *ldata = dev_get_drvdata(dev);
+
+	rtc_time_to_tm(__raw_readl(ldata->base + RTC_DR), tm);
+
+	return 0;
+}
+
+static int pl031_set_time(struct device *dev, struct rtc_time *tm)
+{
+	unsigned long time;
+	struct pl031_local *ldata = dev_get_drvdata(dev);
+
+	rtc_tm_to_time(tm, &time);
+	__raw_writel(time, ldata->base + RTC_LR);
+
+	return 0;
+}
+
+static int pl031_read_alarm(struct device *dev, struct rtc_wkalrm *alarm)
+{
+	struct pl031_local *ldata = dev_get_drvdata(dev);
+
+	rtc_time_to_tm(__raw_readl(ldata->base + RTC_MR), &alarm->time);
+	alarm->pending = __raw_readl(ldata->base + RTC_RIS);
+	alarm->enabled = __raw_readl(ldata->base + RTC_IMSC);
+
+	return 0;
+}
+
+static int pl031_set_alarm(struct device *dev, struct rtc_wkalrm *alarm)
+{
+	struct pl031_local *ldata = dev_get_drvdata(dev);
+	unsigned long time;
+
+	rtc_tm_to_time(&alarm->time, &time);
+
+	__raw_writel(time, ldata->base + RTC_MR);
+	__raw_writel(!alarm->enabled, ldata->base + RTC_MIS);
+
+	return 0;
+}
+
+static struct rtc_class_ops pl031_ops = {
+	.open = pl031_open,
+	.release = pl031_release,
+	.ioctl = pl031_ioctl,
+	.read_time = pl031_read_time,
+	.set_time = pl031_set_time,
+	.read_alarm = pl031_read_alarm,
+	.set_alarm = pl031_set_alarm,
+};
+
+static int pl031_remove(struct amba_device *adev)
+{
+	struct pl031_local *ldata = dev_get_drvdata(&adev->dev);
+
+	if (ldata) {
+		dev_set_drvdata(&adev->dev, NULL);
+		free_irq(adev->irq[0], ldata->rtc);
+		rtc_device_unregister(ldata->rtc);
+		iounmap(ldata->base);
+		kfree(ldata);
+	}
+
+	return 0;
+}
+
+static int pl031_probe(struct amba_device *adev, void *id)
+{
+	int ret;
+	struct pl031_local *ldata;
+
+
+	ldata = kmalloc(sizeof(struct pl031_local), GFP_KERNEL);
+	if (!ldata) {
+		ret = -ENOMEM;
+		goto out;
+	}
+	dev_set_drvdata(&adev->dev, ldata);
+
+	ldata->base = ioremap(adev->res.start,
+			      adev->res.end - adev->res.start + 1);
+	if (!ldata->base) {
+		ret = -ENOMEM;
+		goto out_no_remap;
+	}
+
+	if (request_irq(adev->irq[0], pl031_interrupt, SA_INTERRUPT,
+			"rtc-pl031", ldata->rtc)) {
+		ret = -EIO;
+		goto out_no_irq;
+	}
+
+	ldata->rtc = rtc_device_register("pl031", &adev->dev, &pl031_ops,
+					 THIS_MODULE);
+	if (IS_ERR(ldata->rtc)) {
+		ret = PTR_ERR(ldata->rtc);
+		goto out_no_rtc;
+	}
+
+	return 0;
+
+out_no_rtc:
+	free_irq(adev->irq[0], ldata->rtc);
+out_no_irq:
+	iounmap(ldata->base);
+out_no_remap:
+	dev_set_drvdata(&adev->dev, NULL);
+	kfree(ldata);
+out:
+	return ret;
+}
+
+static struct amba_id pl031_ids[] __initdata = {
+	{
+		 .id = 0x00041031,
+	 	.mask = 0x000fffff, },
+	{0, 0},
+};
+
+static struct amba_driver pl031_driver = {
+	.drv = {
+		.name = "rtc-pl031",
+	},
+	.id_table = pl031_ids,
+	.probe = pl031_probe,
+	.remove = pl031_remove,
+};
+
+static int __init pl031_init(void)
+{
+	return amba_driver_register(&pl031_driver);
+}
+
+static void __exit pl031_exit(void)
+{
+	amba_driver_unregister(&pl031_driver);
+}
+
+module_init(pl031_init);
+module_exit(pl031_exit);
+
+MODULE_AUTHOR("Deepak Saxena <dsaxena@plexity.net");
+MODULE_DESCRIPTION("ARM AMBA PL031 RTC Driver");
+MODULE_LICENSE("GPL");
