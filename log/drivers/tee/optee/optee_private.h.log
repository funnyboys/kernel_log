commit 9c92ab61914157664a2fbdf926df0eb937838e45
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 07:17:56 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 282
    
    Based on 1 normalized pattern(s):
    
      this software is licensed under the terms of the gnu general public
      license version 2 as published by the free software foundation and
      may be copied distributed and modified under those terms this
      program is distributed in the hope that it will be useful but
      without any warranty without even the implied warranty of
      merchantability or fitness for a particular purpose see the gnu
      general public license for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 285 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190529141900.642774971@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tee/optee/optee_private.h b/drivers/tee/optee/optee_private.h
index a5e84afd5013..d9c5037b4e03 100644
--- a/drivers/tee/optee/optee_private.h
+++ b/drivers/tee/optee/optee_private.h
@@ -1,15 +1,6 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * Copyright (c) 2015, Linaro Limited
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
  */
 
 #ifndef OPTEE_PRIVATE_H

commit c3fa24af92445c419c19df5981ab4e41a3ae3361
Author: Sumit Garg <sumit.garg@linaro.org>
Date:   Tue Jan 29 11:19:37 2019 +0530

    tee: optee: add TEE bus device enumeration support
    
    OP-TEE provides a pseudo TA to enumerate TAs which can act as devices/
    services for TEE bus. So implement device enumeration using invoke
    function: PTA_CMD_GET_DEVICES provided by pseudo TA to fetch array of
    device UUIDs. Also register these enumerated devices with TEE bus as
    "optee-clntX" device.
    
    Signed-off-by: Sumit Garg <sumit.garg@linaro.org>
    Reviewed-by: Daniel Thompson <daniel.thompson@linaro.org>
    [jw: fix optee_enumerate_devices() with no devices found]
    Signed-off-by: Jens Wiklander <jens.wiklander@linaro.org>

diff --git a/drivers/tee/optee/optee_private.h b/drivers/tee/optee/optee_private.h
index 35e79386c556..a5e84afd5013 100644
--- a/drivers/tee/optee/optee_private.h
+++ b/drivers/tee/optee/optee_private.h
@@ -28,6 +28,7 @@
 #define TEEC_ERROR_BAD_PARAMETERS	0xFFFF0006
 #define TEEC_ERROR_COMMUNICATION	0xFFFF000E
 #define TEEC_ERROR_OUT_OF_MEMORY	0xFFFF000C
+#define TEEC_ERROR_SHORT_BUFFER		0xFFFF0010
 
 #define TEEC_ORIGIN_COMMS		0x00000002
 
@@ -181,6 +182,8 @@ void optee_free_pages_list(void *array, size_t num_entries);
 void optee_fill_pages_list(u64 *dst, struct page **pages, int num_pages,
 			   size_t page_offset);
 
+int optee_enumerate_devices(void);
+
 /*
  * Small helpers
  */

commit ffdc98c4f25b1f4fb96cd9190917b53a760f3fec
Merge: be60566ea9b0 2490cdf6435b
Author: Olof Johansson <olof@lixom.net>
Date:   Thu Jan 11 18:05:06 2018 -0800

    Merge tag 'tee-drv-dynamic-shm+fixes-for-v4.16' of https://git.linaro.org/people/jens.wiklander/linux-tee into next/drivers
    
    This pull request updates the previous tee-drv-dynamic-shm-for-v4.16 pull
    request with five new patches fixing review comments and errors.
    
    Apart from three small fixes there's two larger patches that in the end
    checks that memory to be registered really is normal cached memory.
    
    * tag 'tee-drv-dynamic-shm+fixes-for-v4.16' of https://git.linaro.org/people/jens.wiklander/linux-tee:
      tee: shm: Potential NULL dereference calling tee_shm_register()
      tee: shm: don't put_page on null shm->pages
      tee: shm: make function __tee_shm_alloc static
      tee: optee: check type of registered shared memory
      tee: add start argument to shm_register callback
    
    Signed-off-by: Olof Johansson <olof@lixom.net>

commit 95ffe4ca43877eea176d7e95aa0d38bbdc3d2903
Author: Jens Wiklander <jens.wiklander@linaro.org>
Date:   Thu Dec 28 10:08:00 2017 +0100

    tee: add start argument to shm_register callback
    
    Adds a start argument to the shm_register callback to allow the callback
    to check memory type of the passed pages.
    
    Signed-off-by: Jens Wiklander <jens.wiklander@linaro.org>

diff --git a/drivers/tee/optee/optee_private.h b/drivers/tee/optee/optee_private.h
index de7962ebc1b6..f04930879762 100644
--- a/drivers/tee/optee/optee_private.h
+++ b/drivers/tee/optee/optee_private.h
@@ -173,11 +173,13 @@ void optee_enable_shm_cache(struct optee *optee);
 void optee_disable_shm_cache(struct optee *optee);
 
 int optee_shm_register(struct tee_context *ctx, struct tee_shm *shm,
-		       struct page **pages, size_t num_pages);
+		       struct page **pages, size_t num_pages,
+		       unsigned long start);
 int optee_shm_unregister(struct tee_context *ctx, struct tee_shm *shm);
 
 int optee_shm_register_supp(struct tee_context *ctx, struct tee_shm *shm,
-			    struct page **pages, size_t num_pages);
+			    struct page **pages, size_t num_pages,
+			    unsigned long start);
 int optee_shm_unregister_supp(struct tee_context *ctx, struct tee_shm *shm);
 
 int optee_from_msg_param(struct tee_param *params, size_t num_params,

commit bad19e0d0460564a067f901b6848c0cc0c403c52
Merge: f9988fbb93c8 ef8e08d24ca8
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu Dec 21 17:23:52 2017 +0100

    Merge tag 'tee-drv-dynamic-shm-for-v4.16' of https://git.linaro.org/people/jens.wiklander/linux-tee into next/drivers
    
    Pull "tee dynamic shm for v4.16" from Jens Wiklander:
    
    This pull request enables dynamic shared memory support in the TEE
    subsystem as a whole and in OP-TEE in particular.
    
    Global Platform TEE specification [1] allows client applications
    to register part of own memory as a shared buffer between
    application and TEE. This allows fast zero-copy communication between
    TEE and REE. But current implementation of TEE in Linux does not support
    this feature.
    
    Also, current implementation of OP-TEE transport uses fixed size
    pre-shared buffer for all communications with OP-TEE OS. This is okay
    in the most use cases. But this prevents use of OP-TEE in virtualized
    environments, because:
     a) We can't share the same buffer between different virtual machines
     b) Physically contiguous memory as seen by VM can be non-contiguous
        in reality (and as seen by OP-TEE OS) due to second stage of
        MMU translation.
     c) Size of this pre-shared buffer is limited.
    
    So, first part of this pull request adds generic register/unregister
    interface to tee subsystem. The second part adds necessary features into
    OP-TEE driver, so it can use not only static pre-shared buffer, but
    whole RAM to communicate with OP-TEE OS.
    
    This change is backwards compatible allowing older secure world or
    user space to work with newer kernels and vice versa.
    
    [1] https://www.globalplatform.org/specificationsdevice.asp
    
    * tag 'tee-drv-dynamic-shm-for-v4.16' of https://git.linaro.org/people/jens.wiklander/linux-tee:
      tee: shm: inline tee_shm_get_id()
      tee: use reference counting for tee_context
      tee: optee: enable dynamic SHM support
      tee: optee: add optee-specific shared pool implementation
      tee: optee: store OP-TEE capabilities in private data
      tee: optee: add registered buffers handling into RPC calls
      tee: optee: add registered shared parameters handling
      tee: optee: add shared buffer registration functions
      tee: optee: add page list manipulation functions
      tee: optee: Update protocol definitions
      tee: shm: add page accessor functions
      tee: shm: add accessors for buffer size and page offset
      tee: add register user memory
      tee: flexible shared memory pool creation

commit d885cc5e0759fc19badadddb60a64344b551469b
Author: Volodymyr Babchuk <vlad.babchuk@gmail.com>
Date:   Wed Nov 29 14:48:34 2017 +0200

    tee: optee: store OP-TEE capabilities in private data
    
    Those capabilities will be used in subsequent patches.
    
    Signed-off-by: Volodymyr Babchuk <vlad.babchuk@gmail.com>
    Signed-off-by: Jens Wiklander <jens.wiklander@linaro.org>

diff --git a/drivers/tee/optee/optee_private.h b/drivers/tee/optee/optee_private.h
index 61a0052f6a54..de7962ebc1b6 100644
--- a/drivers/tee/optee/optee_private.h
+++ b/drivers/tee/optee/optee_private.h
@@ -96,6 +96,8 @@ struct optee_supp {
  * @supp:		supplicant synchronization struct for RPC to supplicant
  * @pool:		shared memory pool
  * @memremaped_shm	virtual address of memory in shared memory pool
+ * @sec_caps:		secure world capabilities defined by
+ *			OPTEE_SMC_SEC_CAP_* in optee_smc.h
  */
 struct optee {
 	struct tee_device *supp_teedev;
@@ -106,6 +108,7 @@ struct optee {
 	struct optee_supp supp;
 	struct tee_shm_pool *pool;
 	void *memremaped_shm;
+	u32 sec_caps;
 };
 
 struct optee_session {

commit 53a107c812de3dd74707458aa751eb457718ff9e
Author: Volodymyr Babchuk <vlad.babchuk@gmail.com>
Date:   Wed Nov 29 14:48:33 2017 +0200

    tee: optee: add registered buffers handling into RPC calls
    
    With latest changes to OP-TEE we can use any buffers as a shared memory.
    Thus, it is possible for supplicant to provide part of own memory
    when OP-TEE asks to allocate a shared buffer.
    
    This patch adds support for such feature into RPC handling code.
    Now when OP-TEE asks supplicant to allocate shared buffer, supplicant
    can use TEE_IOC_SHM_REGISTER to provide such buffer. RPC handler is
    aware of this, so it will pass list of allocated pages to OP-TEE.
    
    Signed-off-by: Volodymyr Babchuk <vlad.babchuk@gmail.com>
    [jw: fix parenthesis alignment in free_pages_list()]
    Signed-off-by: Jens Wiklander <jens.wiklander@linaro.org>

diff --git a/drivers/tee/optee/optee_private.h b/drivers/tee/optee/optee_private.h
index d7bc77d95022..61a0052f6a54 100644
--- a/drivers/tee/optee/optee_private.h
+++ b/drivers/tee/optee/optee_private.h
@@ -130,7 +130,16 @@ struct optee_rpc_param {
 	u32	a7;
 };
 
-void optee_handle_rpc(struct tee_context *ctx, struct optee_rpc_param *param);
+/* Holds context that is preserved during one STD call */
+struct optee_call_ctx {
+	/* information about pages list used in last allocation */
+	void *pages_list;
+	size_t num_entries;
+};
+
+void optee_handle_rpc(struct tee_context *ctx, struct optee_rpc_param *param,
+		      struct optee_call_ctx *call_ctx);
+void optee_rpc_finalize_call(struct optee_call_ctx *call_ctx);
 
 void optee_wait_queue_init(struct optee_wait_queue *wq);
 void optee_wait_queue_exit(struct optee_wait_queue *wq);
@@ -164,6 +173,10 @@ int optee_shm_register(struct tee_context *ctx, struct tee_shm *shm,
 		       struct page **pages, size_t num_pages);
 int optee_shm_unregister(struct tee_context *ctx, struct tee_shm *shm);
 
+int optee_shm_register_supp(struct tee_context *ctx, struct tee_shm *shm,
+			    struct page **pages, size_t num_pages);
+int optee_shm_unregister_supp(struct tee_context *ctx, struct tee_shm *shm);
+
 int optee_from_msg_param(struct tee_param *params, size_t num_params,
 			 const struct optee_msg_param *msg_params);
 int optee_to_msg_param(struct optee_msg_param *msg_params, size_t num_params,

commit 06ca79179c4e00efe53cfe43456f1586f944f04f
Author: Volodymyr Babchuk <vlad.babchuk@gmail.com>
Date:   Wed Nov 29 14:48:31 2017 +0200

    tee: optee: add shared buffer registration functions
    
    This change adds ops for shm_(un)register functions in tee interface.
    Client application can use these functions to (un)register an own shared
    buffer in OP-TEE address space. This allows zero copy data sharing between
    Normal and Secure Worlds.
    
    Please note that while those functions were added to optee code,
    it does not report to userspace that those functions are available.
    OP-TEE code does not set TEE_GEN_CAP_REG_MEM flag. This flag will be
    enabled only after all other features of dynamic shared memory will be
    implemented in subsequent patches. Of course user can ignore presence of
    TEE_GEN_CAP_REG_MEM flag and try do call those functions. This is okay,
    driver will register shared buffer in OP-TEE, but any attempts to use
    this shared buffer will fail.
    
    Signed-off-by: Volodymyr Babchuk <vlad.babchuk@gmail.com>
    Signed-off-by: Jens Wiklander <jens.wiklander@linaro.org>

diff --git a/drivers/tee/optee/optee_private.h b/drivers/tee/optee/optee_private.h
index b63213d09d68..d7bc77d95022 100644
--- a/drivers/tee/optee/optee_private.h
+++ b/drivers/tee/optee/optee_private.h
@@ -160,6 +160,10 @@ int optee_cancel_req(struct tee_context *ctx, u32 cancel_id, u32 session);
 void optee_enable_shm_cache(struct optee *optee);
 void optee_disable_shm_cache(struct optee *optee);
 
+int optee_shm_register(struct tee_context *ctx, struct tee_shm *shm,
+		       struct page **pages, size_t num_pages);
+int optee_shm_unregister(struct tee_context *ctx, struct tee_shm *shm);
+
 int optee_from_msg_param(struct tee_param *params, size_t num_params,
 			 const struct optee_msg_param *msg_params);
 int optee_to_msg_param(struct optee_msg_param *msg_params, size_t num_params,

commit 3bb48ba5cd60f9685aa8f1ccd9b14a72e237c13f
Author: Volodymyr Babchuk <vlad.babchuk@gmail.com>
Date:   Wed Nov 29 14:48:30 2017 +0200

    tee: optee: add page list manipulation functions
    
    These functions will be used to pass information about shared
    buffers to OP-TEE. ABI between Linux and OP-TEE is defined
    in optee_msg.h and optee_smc.h.
    
    optee_msg.h defines OPTEE_MSG_ATTR_NONCONTIG attribute
    for shared memory references and describes how such references
    should be passed. Note that it uses 64-bit page addresses even
    on 32 bit systems. This is done to support LPAE and to unify
    interface.
    
    Signed-off-by: Volodymyr Babchuk <vlad.babchuk@gmail.com>
    [jw: replacing uint64_t with u64 in optee_fill_pages_list()]
    Signed-off-by: Jens Wiklander <jens.wiklander@linaro.org>

diff --git a/drivers/tee/optee/optee_private.h b/drivers/tee/optee/optee_private.h
index c374cd594314..b63213d09d68 100644
--- a/drivers/tee/optee/optee_private.h
+++ b/drivers/tee/optee/optee_private.h
@@ -165,6 +165,11 @@ int optee_from_msg_param(struct tee_param *params, size_t num_params,
 int optee_to_msg_param(struct optee_msg_param *msg_params, size_t num_params,
 		       const struct tee_param *params);
 
+u64 *optee_allocate_pages_list(size_t num_entries);
+void optee_free_pages_list(void *array, size_t num_entries);
+void optee_fill_pages_list(u64 *dst, struct page **pages, int num_pages,
+			   size_t page_offset);
+
 /*
  * Small helpers
  */

commit 1647a5ac175490d7dac2e74532e85b6197fc74e9
Author: Jens Wiklander <jens.wiklander@linaro.org>
Date:   Fri Dec 23 13:13:39 2016 +0100

    optee: support asynchronous supplicant requests
    
    Adds support for asynchronous supplicant requests, meaning that the
    supplicant can process several requests in parallel or block in a
    request for some time.
    
    Acked-by: Etienne Carriere <etienne.carriere@linaro.org>
    Tested-by: Etienne Carriere <etienne.carriere@linaro.org> (b2260 pager=y/n)
    Signed-off-by: Jens Wiklander <jens.wiklander@linaro.org>

diff --git a/drivers/tee/optee/optee_private.h b/drivers/tee/optee/optee_private.h
index c374cd594314..3e7da187acbe 100644
--- a/drivers/tee/optee/optee_private.h
+++ b/drivers/tee/optee/optee_private.h
@@ -53,36 +53,24 @@ struct optee_wait_queue {
  * @ctx			the context of current connected supplicant.
  *			if !NULL the supplicant device is available for use,
  *			else busy
- * @ctx_mutex:		held while accessing @ctx
- * @func:		supplicant function id to call
- * @ret:		call return value
- * @num_params:		number of elements in @param
- * @param:		parameters for @func
- * @req_posted:		if true, a request has been posted to the supplicant
- * @supp_next_send:	if true, next step is for supplicant to send response
- * @thrd_mutex:		held by the thread doing a request to supplicant
- * @supp_mutex:		held by supplicant while operating on this struct
- * @data_to_supp:	supplicant is waiting on this for next request
- * @data_from_supp:	requesting thread is waiting on this to get the result
+ * @mutex:		held while accessing content of this struct
+ * @req_id:		current request id if supplicant is doing synchronous
+ *			communication, else -1
+ * @reqs:		queued request not yet retrieved by supplicant
+ * @idr:		IDR holding all requests currently being processed
+ *			by supplicant
+ * @reqs_c:		completion used by supplicant when waiting for a
+ *			request to be queued.
  */
 struct optee_supp {
+	/* Serializes access to this struct */
+	struct mutex mutex;
 	struct tee_context *ctx;
-	/* Serializes access of ctx */
-	struct mutex ctx_mutex;
-
-	u32 func;
-	u32 ret;
-	size_t num_params;
-	struct tee_param *param;
-
-	bool req_posted;
-	bool supp_next_send;
-	/* Serializes access to this struct for requesting thread */
-	struct mutex thrd_mutex;
-	/* Serializes access to this struct for supplicant threads */
-	struct mutex supp_mutex;
-	struct completion data_to_supp;
-	struct completion data_from_supp;
+
+	int req_id;
+	struct list_head reqs;
+	struct idr idr;
+	struct completion reqs_c;
 };
 
 /**
@@ -142,6 +130,7 @@ int optee_supp_read(struct tee_context *ctx, void __user *buf, size_t len);
 int optee_supp_write(struct tee_context *ctx, void __user *buf, size_t len);
 void optee_supp_init(struct optee_supp *supp);
 void optee_supp_uninit(struct optee_supp *supp);
+void optee_supp_release(struct optee_supp *supp);
 
 int optee_supp_recv(struct tee_context *ctx, u32 *func, u32 *num_params,
 		    struct tee_param *param);

commit 4fb0a5eb364d239722e745c02aef0dbd4e0f1ad2
Author: Jens Wiklander <jens.wiklander@linaro.org>
Date:   Tue Apr 14 14:33:20 2015 +0200

    tee: add OP-TEE driver
    
    Adds a OP-TEE driver which also can be compiled as a loadable module.
    
    * Targets ARM and ARM64
    * Supports using reserved memory from OP-TEE as shared memory
    * Probes OP-TEE version using SMCs
    * Accepts requests on privileged and unprivileged device
    * Uses OPTEE message protocol version 2 to communicate with secure world
    
    Acked-by: Andreas Dannenberg <dannenberg@ti.com>
    Tested-by: Jerome Forissier <jerome.forissier@linaro.org> (HiKey)
    Tested-by: Volodymyr Babchuk <vlad.babchuk@gmail.com> (RCAR H3)
    Tested-by: Scott Branden <scott.branden@broadcom.com>
    Reviewed-by: Javier Gonz√°lez <javier@javigon.com>
    Signed-off-by: Jens Wiklander <jens.wiklander@linaro.org>

diff --git a/drivers/tee/optee/optee_private.h b/drivers/tee/optee/optee_private.h
new file mode 100644
index 000000000000..c374cd594314
--- /dev/null
+++ b/drivers/tee/optee/optee_private.h
@@ -0,0 +1,183 @@
+/*
+ * Copyright (c) 2015, Linaro Limited
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef OPTEE_PRIVATE_H
+#define OPTEE_PRIVATE_H
+
+#include <linux/arm-smccc.h>
+#include <linux/semaphore.h>
+#include <linux/tee_drv.h>
+#include <linux/types.h>
+#include "optee_msg.h"
+
+#define OPTEE_MAX_ARG_SIZE	1024
+
+/* Some Global Platform error codes used in this driver */
+#define TEEC_SUCCESS			0x00000000
+#define TEEC_ERROR_BAD_PARAMETERS	0xFFFF0006
+#define TEEC_ERROR_COMMUNICATION	0xFFFF000E
+#define TEEC_ERROR_OUT_OF_MEMORY	0xFFFF000C
+
+#define TEEC_ORIGIN_COMMS		0x00000002
+
+typedef void (optee_invoke_fn)(unsigned long, unsigned long, unsigned long,
+				unsigned long, unsigned long, unsigned long,
+				unsigned long, unsigned long,
+				struct arm_smccc_res *);
+
+struct optee_call_queue {
+	/* Serializes access to this struct */
+	struct mutex mutex;
+	struct list_head waiters;
+};
+
+struct optee_wait_queue {
+	/* Serializes access to this struct */
+	struct mutex mu;
+	struct list_head db;
+};
+
+/**
+ * struct optee_supp - supplicant synchronization struct
+ * @ctx			the context of current connected supplicant.
+ *			if !NULL the supplicant device is available for use,
+ *			else busy
+ * @ctx_mutex:		held while accessing @ctx
+ * @func:		supplicant function id to call
+ * @ret:		call return value
+ * @num_params:		number of elements in @param
+ * @param:		parameters for @func
+ * @req_posted:		if true, a request has been posted to the supplicant
+ * @supp_next_send:	if true, next step is for supplicant to send response
+ * @thrd_mutex:		held by the thread doing a request to supplicant
+ * @supp_mutex:		held by supplicant while operating on this struct
+ * @data_to_supp:	supplicant is waiting on this for next request
+ * @data_from_supp:	requesting thread is waiting on this to get the result
+ */
+struct optee_supp {
+	struct tee_context *ctx;
+	/* Serializes access of ctx */
+	struct mutex ctx_mutex;
+
+	u32 func;
+	u32 ret;
+	size_t num_params;
+	struct tee_param *param;
+
+	bool req_posted;
+	bool supp_next_send;
+	/* Serializes access to this struct for requesting thread */
+	struct mutex thrd_mutex;
+	/* Serializes access to this struct for supplicant threads */
+	struct mutex supp_mutex;
+	struct completion data_to_supp;
+	struct completion data_from_supp;
+};
+
+/**
+ * struct optee - main service struct
+ * @supp_teedev:	supplicant device
+ * @teedev:		client device
+ * @invoke_fn:		function to issue smc or hvc
+ * @call_queue:		queue of threads waiting to call @invoke_fn
+ * @wait_queue:		queue of threads from secure world waiting for a
+ *			secure world sync object
+ * @supp:		supplicant synchronization struct for RPC to supplicant
+ * @pool:		shared memory pool
+ * @memremaped_shm	virtual address of memory in shared memory pool
+ */
+struct optee {
+	struct tee_device *supp_teedev;
+	struct tee_device *teedev;
+	optee_invoke_fn *invoke_fn;
+	struct optee_call_queue call_queue;
+	struct optee_wait_queue wait_queue;
+	struct optee_supp supp;
+	struct tee_shm_pool *pool;
+	void *memremaped_shm;
+};
+
+struct optee_session {
+	struct list_head list_node;
+	u32 session_id;
+};
+
+struct optee_context_data {
+	/* Serializes access to this struct */
+	struct mutex mutex;
+	struct list_head sess_list;
+};
+
+struct optee_rpc_param {
+	u32	a0;
+	u32	a1;
+	u32	a2;
+	u32	a3;
+	u32	a4;
+	u32	a5;
+	u32	a6;
+	u32	a7;
+};
+
+void optee_handle_rpc(struct tee_context *ctx, struct optee_rpc_param *param);
+
+void optee_wait_queue_init(struct optee_wait_queue *wq);
+void optee_wait_queue_exit(struct optee_wait_queue *wq);
+
+u32 optee_supp_thrd_req(struct tee_context *ctx, u32 func, size_t num_params,
+			struct tee_param *param);
+
+int optee_supp_read(struct tee_context *ctx, void __user *buf, size_t len);
+int optee_supp_write(struct tee_context *ctx, void __user *buf, size_t len);
+void optee_supp_init(struct optee_supp *supp);
+void optee_supp_uninit(struct optee_supp *supp);
+
+int optee_supp_recv(struct tee_context *ctx, u32 *func, u32 *num_params,
+		    struct tee_param *param);
+int optee_supp_send(struct tee_context *ctx, u32 ret, u32 num_params,
+		    struct tee_param *param);
+
+u32 optee_do_call_with_arg(struct tee_context *ctx, phys_addr_t parg);
+int optee_open_session(struct tee_context *ctx,
+		       struct tee_ioctl_open_session_arg *arg,
+		       struct tee_param *param);
+int optee_close_session(struct tee_context *ctx, u32 session);
+int optee_invoke_func(struct tee_context *ctx, struct tee_ioctl_invoke_arg *arg,
+		      struct tee_param *param);
+int optee_cancel_req(struct tee_context *ctx, u32 cancel_id, u32 session);
+
+void optee_enable_shm_cache(struct optee *optee);
+void optee_disable_shm_cache(struct optee *optee);
+
+int optee_from_msg_param(struct tee_param *params, size_t num_params,
+			 const struct optee_msg_param *msg_params);
+int optee_to_msg_param(struct optee_msg_param *msg_params, size_t num_params,
+		       const struct tee_param *params);
+
+/*
+ * Small helpers
+ */
+
+static inline void *reg_pair_to_ptr(u32 reg0, u32 reg1)
+{
+	return (void *)(unsigned long)(((u64)reg0 << 32) | reg1);
+}
+
+static inline void reg_pair_from_64(u32 *reg0, u32 *reg1, u64 val)
+{
+	*reg0 = val >> 32;
+	*reg1 = val;
+}
+
+#endif /*OPTEE_PRIVATE_H*/
