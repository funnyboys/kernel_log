commit 74ba9207e1adf1966c57450340534ae9742d00af
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 20 09:19:02 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 61
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      675 mass ave cambridge ma 02139 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 441 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Michael Ellerman <mpe@ellerman.id.au> (powerpc)
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190520071858.739733335@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/sbus/char/openprom.c b/drivers/sbus/char/openprom.c
index 050879a2ddef..30b9751aad30 100644
--- a/drivers/sbus/char/openprom.c
+++ b/drivers/sbus/char/openprom.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Linux/SPARC PROM Configuration Driver
  * Copyright (C) 1996 Thomas K. Dyas (tdyas@noc.rutgers.edu)
@@ -14,20 +15,6 @@
  * sanity's sake.
  */
 
-/* This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. 
- */
 
 #include <linux/module.h>
 #include <linux/kernel.h>

commit df58f37b5d8f883fb18ba85e8d9a624154879832
Author: Rob Herring <robh@kernel.org>
Date:   Wed Aug 29 15:03:37 2018 -0500

    sbus: Use of_get_child_by_name helper
    
    Use the of_get_child_by_name() helper instead of open coding searching
    for the '/options' node. This removes directly accessing the name
    pointer as well.
    
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: sparclinux@vger.kernel.org
    Signed-off-by: Rob Herring <robh@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/sbus/char/openprom.c b/drivers/sbus/char/openprom.c
index 7b31f19ade83..050879a2ddef 100644
--- a/drivers/sbus/char/openprom.c
+++ b/drivers/sbus/char/openprom.c
@@ -715,22 +715,13 @@ static struct miscdevice openprom_dev = {
 
 static int __init openprom_init(void)
 {
-	struct device_node *dp;
 	int err;
 
 	err = misc_register(&openprom_dev);
 	if (err)
 		return err;
 
-	dp = of_find_node_by_path("/");
-	dp = dp->child;
-	while (dp) {
-		if (!strcmp(dp->name, "options"))
-			break;
-		dp = dp->sibling;
-	}
-	options_node = dp;
-
+	options_node = of_get_child_by_name(of_find_node_by_path("/"), "options");
 	if (!options_node) {
 		misc_deregister(&openprom_dev);
 		return -EIO;

commit c792373294449c9eaf776ac6947c45367d31dd8a
Author: Sinan Kaya <okaya@codeaurora.org>
Date:   Tue Dec 19 00:37:56 2017 -0500

    openprom: Deprecate pci_get_bus_and_slot()
    
    pci_get_bus_and_slot() is restrictive such that it assumes domain=0 as
    where a PCI device is present. This restricts the device drivers to be
    reused for other domain numbers.
    
    Getting ready to remove pci_get_bus_and_slot() function in favor of
    pci_get_domain_bus_and_slot().
    
    Hard-coding the domain as 0 since domain information is not available.
    
    Signed-off-by: Sinan Kaya <okaya@codeaurora.org>
    Signed-off-by: Bjorn Helgaas <helgaas@kernel.org>
    Acked-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/sbus/char/openprom.c b/drivers/sbus/char/openprom.c
index 2c2e6a3b4c7e..7b31f19ade83 100644
--- a/drivers/sbus/char/openprom.c
+++ b/drivers/sbus/char/openprom.c
@@ -251,8 +251,9 @@ static int oprompci2node(void __user *argp, struct device_node *dp, struct openp
 		struct pci_dev *pdev;
 		struct device_node *dp;
 
-		pdev = pci_get_bus_and_slot (((int *) op->oprom_array)[0],
-				      ((int *) op->oprom_array)[1]);
+		pdev = pci_get_domain_bus_and_slot(0,
+						((int *) op->oprom_array)[0],
+						((int *) op->oprom_array)[1]);
 
 		dp = pci_device_to_OF_node(pdev);
 		data->current_node = dp;

commit 7c0f6ba682b9c7632072ffbedf8d328c8f3c42ba
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Dec 24 11:46:01 2016 -0800

    Replace <asm/uaccess.h> with <linux/uaccess.h> globally
    
    This was entirely automated, using the script by Al:
    
      PATT='^[[:blank:]]*#[[:blank:]]*include[[:blank:]]*<asm/uaccess.h>'
      sed -i -e "s!$PATT!#include <linux/uaccess.h>!" \
            $(git grep -l "$PATT"|grep -v ^include/linux/uaccess.h)
    
    to do the replacement at the end of the merge window.
    
    Requested-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/sbus/char/openprom.c b/drivers/sbus/char/openprom.c
index 4612691c6619..2c2e6a3b4c7e 100644
--- a/drivers/sbus/char/openprom.c
+++ b/drivers/sbus/char/openprom.c
@@ -40,7 +40,7 @@
 #include <linux/fs.h>
 #include <asm/oplib.h>
 #include <asm/prom.h>
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
 #include <asm/openpromio.h>
 #ifdef CONFIG_PCI
 #include <linux/pci.h>

commit 21916a4a2973ab1684e921689ef8a48a6626ac4c
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sun Apr 24 15:24:33 2016 +0200

    openprom: fix warning
    
    Fix following warnings:
    openprom.c:510:2: warning: 'tmp' may be used uninitialized in this function [-Wmaybe-uninitialized]
    openprom.c:503:3: warning: 'str' may be used uninitialized in this function [-Wmaybe-uninitialized]
    openprom.c:459:8: warning: 'str' may be used uninitialized in this function [-Wmaybe-uninitialized]
    openprom.c:422:7: warning: 'str' may be used uninitialized in this function [-Wmaybe-uninitialized]
    
    Fixed by introducing PTR_ERR etc.
    This simplified the code as a nice side effect.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/sbus/char/openprom.c b/drivers/sbus/char/openprom.c
index e077ebd89319..4612691c6619 100644
--- a/drivers/sbus/char/openprom.c
+++ b/drivers/sbus/char/openprom.c
@@ -383,20 +383,12 @@ static struct device_node *get_node(phandle n, DATA *data)
 }
 
 /* Copy in a whole string from userspace into kernelspace. */
-static int copyin_string(char __user *user, size_t len, char **ptr)
+static char * copyin_string(char __user *user, size_t len)
 {
-	char *tmp;
-
 	if ((ssize_t)len < 0 || (ssize_t)(len + 1) < 0)
-		return -EINVAL;
-
-	tmp = memdup_user_nul(user, len);
-	if (IS_ERR(tmp))
-		return PTR_ERR(tmp);
+		return ERR_PTR(-EINVAL);
 
-	*ptr = tmp;
-
-	return 0;
+	return memdup_user_nul(user, len);
 }
 
 /*
@@ -415,9 +407,9 @@ static int opiocget(void __user *argp, DATA *data)
 
 	dp = get_node(op.op_nodeid, data);
 
-	err = copyin_string(op.op_name, op.op_namelen, &str);
-	if (err)
-		return err;
+	str = copyin_string(op.op_name, op.op_namelen);
+	if (IS_ERR(str))
+		return PTR_ERR(str);
 
 	pval = of_get_property(dp, str, &len);
 	err = 0;
@@ -440,7 +432,7 @@ static int opiocnextprop(void __user *argp, DATA *data)
 	struct device_node *dp;
 	struct property *prop;
 	char *str;
-	int err, len;
+	int len;
 
 	if (copy_from_user(&op, argp, sizeof(op)))
 		return -EFAULT;
@@ -449,9 +441,9 @@ static int opiocnextprop(void __user *argp, DATA *data)
 	if (!dp)
 		return -EINVAL;
 
-	err = copyin_string(op.op_name, op.op_namelen, &str);
-	if (err)
-		return err;
+	str = copyin_string(op.op_name, op.op_namelen);
+	if (IS_ERR(str))
+		return PTR_ERR(str);
 
 	if (str[0] == '\0') {
 		prop = dp->properties;
@@ -494,14 +486,14 @@ static int opiocset(void __user *argp, DATA *data)
 	if (!dp)
 		return -EINVAL;
 
-	err = copyin_string(op.op_name, op.op_namelen, &str);
-	if (err)
-		return err;
+	str = copyin_string(op.op_name, op.op_namelen);
+	if (IS_ERR(str))
+		return PTR_ERR(str);
 
-	err = copyin_string(op.op_buf, op.op_buflen, &tmp);
-	if (err) {
+	tmp = copyin_string(op.op_buf, op.op_buflen);
+	if (IS_ERR(tmp)) {
 		kfree(str);
-		return err;
+		return PTR_ERR(tmp);
 	}
 
 	err = of_set_property(dp, str, tmp, op.op_buflen);

commit 16e5c1fc36040e592128a164499bc25eb138a80f
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Dec 24 00:06:05 2015 -0500

    convert a bunch of open-coded instances of memdup_user_nul()
    
    A _lot_ of ->write() instances were open-coding it; some are
    converted to memdup_user_nul(), a lot more remain...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/sbus/char/openprom.c b/drivers/sbus/char/openprom.c
index 5843288f64bc..e077ebd89319 100644
--- a/drivers/sbus/char/openprom.c
+++ b/drivers/sbus/char/openprom.c
@@ -390,16 +390,9 @@ static int copyin_string(char __user *user, size_t len, char **ptr)
 	if ((ssize_t)len < 0 || (ssize_t)(len + 1) < 0)
 		return -EINVAL;
 
-	tmp = kmalloc(len + 1, GFP_KERNEL);
-	if (!tmp)
-		return -ENOMEM;
-
-	if (copy_from_user(tmp, user, len)) {
-		kfree(tmp);
-		return -EFAULT;
-	}
-
-	tmp[len] = '\0';
+	tmp = memdup_user_nul(user, len);
+	if (IS_ERR(tmp))
+		return PTR_ERR(tmp);
 
 	*ptr = tmp;
 

commit da201161662b8ee9c8d7bd8cc50ce3cb3366d400
Author: Peter Senna Tschudin <peter.senna@gmail.com>
Date:   Wed Sep 12 07:03:12 2012 +0000

    drivers/sbus/char: removes unnecessary semicolon
    
    removes unnecessary semicolon
    
    Found by Coccinelle: http://coccinelle.lip6.fr/
    
    Signed-off-by: Peter Senna Tschudin <peter.senna@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/sbus/char/openprom.c b/drivers/sbus/char/openprom.c
index 2236aea3ca2f..5843288f64bc 100644
--- a/drivers/sbus/char/openprom.c
+++ b/drivers/sbus/char/openprom.c
@@ -222,7 +222,7 @@ static int opromnext(void __user *argp, unsigned int cmd, struct device_node *dp
 		case OPROMSETCUR:
 		default:
 			break;
-		};
+		}
 	} else {
 		/* Sibling of node zero is the root node.  */
 		if (cmd != OPROMNEXT)
@@ -588,7 +588,7 @@ static int openprom_bsd_ioctl(struct file * file,
 	default:
 		err = -EINVAL;
 		break;
-	};
+	}
 	mutex_unlock(&openprom_mutex);
 
 	return err;

commit 9ffc93f203c18a70623f21950f1dd473c9ec48cd
Author: David Howells <dhowells@redhat.com>
Date:   Wed Mar 28 18:30:03 2012 +0100

    Remove all #inclusions of asm/system.h
    
    Remove all #inclusions of asm/system.h preparatory to splitting and killing
    it.  Performed with the following command:
    
    perl -p -i -e 's!^#\s*include\s*<asm/system[.]h>.*\n!!' `grep -Irl '^#\s*include\s*<asm/system[.]h>' *`
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/drivers/sbus/char/openprom.c b/drivers/sbus/char/openprom.c
index 8d6e508222b8..2236aea3ca2f 100644
--- a/drivers/sbus/char/openprom.c
+++ b/drivers/sbus/char/openprom.c
@@ -40,7 +40,6 @@
 #include <linux/fs.h>
 #include <asm/oplib.h>
 #include <asm/prom.h>
-#include <asm/system.h>
 #include <asm/uaccess.h>
 #include <asm/openpromio.h>
 #ifdef CONFIG_PCI

commit a3108ca2323dec0f6321c3f7706cdaed51f694ea
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Jul 20 23:36:39 2010 -0700

    sbus: autoconvert trivial BKL users to private mutex
    
    All these files use the big kernel lock in a trivial
    way to serialize their private file operations,
    typically resulting from an earlier semi-automatic
    pushdown from VFS.
    
    None of these drivers appears to want to lock against
    other code, and they all use the BKL as the top-level
    lock in their file operations, meaning that there
    is no lock-order inversion problem.
    
    Consequently, we can remove the BKL completely,
    replacing it with a per-file mutex in every case.
    Using a scripted approach means we can avoid
    typos.
    
    file=$1
    name=$2
    if grep -q lock_kernel ${file} ; then
        if grep -q 'include.*linux.mutex.h' ${file} ; then
                sed -i '/include.*<linux\/smp_lock.h>/d' ${file}
        else
                sed -i 's/include.*<linux\/smp_lock.h>.*$/include <linux\/mutex.h>/g' ${file}
        fi
        sed -i ${file} \
            -e "/^#include.*linux.mutex.h/,$ {
                    1,/^\(static\|int\|long\)/ {
                         /^\(static\|int\|long\)/istatic DEFINE_MUTEX(${name}_mutex);
    
    } }"  \
        -e "s/\(un\)*lock_kernel\>[ ]*()/mutex_\1lock(\&${name}_mutex)/g" \
        -e '/[      ]*cycle_kernel_lock();/d'
    else
        sed -i -e '/include.*\<smp_lock.h\>/d' ${file}  \
                    -e '/cycle_kernel_lock()/d'
    fi
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/sbus/char/openprom.c b/drivers/sbus/char/openprom.c
index aacbe14e2e7a..8d6e508222b8 100644
--- a/drivers/sbus/char/openprom.c
+++ b/drivers/sbus/char/openprom.c
@@ -33,7 +33,7 @@
 #include <linux/kernel.h>
 #include <linux/errno.h>
 #include <linux/slab.h>
-#include <linux/smp_lock.h>
+#include <linux/mutex.h>
 #include <linux/string.h>
 #include <linux/miscdevice.h>
 #include <linux/init.h>
@@ -61,6 +61,7 @@ typedef struct openprom_private_data
 } DATA;
 
 /* ID of the PROM node containing all of the EEPROM options. */
+static DEFINE_MUTEX(openprom_mutex);
 static struct device_node *options_node;
 
 /*
@@ -316,7 +317,7 @@ static long openprom_sunos_ioctl(struct file * file,
 	if (bufsize < 0)
 		return bufsize;
 
-	lock_kernel();
+	mutex_lock(&openprom_mutex);
 
 	switch (cmd) {
 	case OPROMGETOPT:
@@ -367,7 +368,7 @@ static long openprom_sunos_ioctl(struct file * file,
 	}
 
 	kfree(opp);
-	unlock_kernel();
+	mutex_unlock(&openprom_mutex);
 
 	return error;
 }
@@ -558,7 +559,7 @@ static int openprom_bsd_ioctl(struct file * file,
 	void __user *argp = (void __user *)arg;
 	int err;
 
-	lock_kernel();
+	mutex_lock(&openprom_mutex);
 	switch (cmd) {
 	case OPIOCGET:
 		err = opiocget(argp, data);
@@ -589,7 +590,7 @@ static int openprom_bsd_ioctl(struct file * file,
 		err = -EINVAL;
 		break;
 	};
-	unlock_kernel();
+	mutex_unlock(&openprom_mutex);
 
 	return err;
 }
@@ -697,11 +698,11 @@ static int openprom_open(struct inode * inode, struct file * file)
 	if (!data)
 		return -ENOMEM;
 
-	lock_kernel();
+	mutex_lock(&openprom_mutex);
 	data->current_node = of_find_node_by_path("/");
 	data->lastnode = data->current_node;
 	file->private_data = (void *) data;
-	unlock_kernel();
+	mutex_unlock(&openprom_mutex);
 
 	return 0;
 }

commit 33cfe65a786cf3d048688b932f41df937282a7bb
Author: Joe Perches <joe@perches.com>
Date:   Mon Jul 12 21:16:04 2010 -0700

    drivers/sbus: Remove unnecessary casts of private_data
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/sbus/char/openprom.c b/drivers/sbus/char/openprom.c
index d53e62ab09da..aacbe14e2e7a 100644
--- a/drivers/sbus/char/openprom.c
+++ b/drivers/sbus/char/openprom.c
@@ -554,7 +554,7 @@ static int opiocgetnext(unsigned int cmd, void __user *argp)
 static int openprom_bsd_ioctl(struct file * file,
 			      unsigned int cmd, unsigned long arg)
 {
-	DATA *data = (DATA *) file->private_data;
+	DATA *data = file->private_data;
 	void __user *argp = (void __user *)arg;
 	int err;
 
@@ -601,7 +601,7 @@ static int openprom_bsd_ioctl(struct file * file,
 static long openprom_ioctl(struct file * file,
 			   unsigned int cmd, unsigned long arg)
 {
-	DATA *data = (DATA *) file->private_data;
+	DATA *data = file->private_data;
 
 	switch (cmd) {
 	case OPROMGETOPT:

commit 55929332c92e5d34d65a8f784604c92677ea3e15
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Apr 27 00:24:05 2010 +0200

    drivers: Push down BKL into various drivers
    
    These are the last remaining device drivers using
    the ->ioctl file operation in the drivers directory
    (except from v4l drivers).
    
    [fweisbec: drop i8k pushdown as it has been done from
    procfs pushdown branch already]
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>

diff --git a/drivers/sbus/char/openprom.c b/drivers/sbus/char/openprom.c
index fc2f676e984d..d53e62ab09da 100644
--- a/drivers/sbus/char/openprom.c
+++ b/drivers/sbus/char/openprom.c
@@ -298,9 +298,9 @@ static int opromgetbootargs(void __user *argp, struct openpromio *op, int bufsiz
 /*
  *	SunOS and Solaris /dev/openprom ioctl calls.
  */
-static int openprom_sunos_ioctl(struct inode * inode, struct file * file,
-				unsigned int cmd, unsigned long arg,
-				struct device_node *dp)
+static long openprom_sunos_ioctl(struct file * file,
+				 unsigned int cmd, unsigned long arg,
+				 struct device_node *dp)
 {
 	DATA *data = file->private_data;
 	struct openpromio *opp = NULL;
@@ -316,6 +316,8 @@ static int openprom_sunos_ioctl(struct inode * inode, struct file * file,
 	if (bufsize < 0)
 		return bufsize;
 
+	lock_kernel();
+
 	switch (cmd) {
 	case OPROMGETOPT:
 	case OPROMGETPROP:
@@ -365,6 +367,8 @@ static int openprom_sunos_ioctl(struct inode * inode, struct file * file,
 	}
 
 	kfree(opp);
+	unlock_kernel();
+
 	return error;
 }
 
@@ -547,13 +551,14 @@ static int opiocgetnext(unsigned int cmd, void __user *argp)
 	return 0;
 }
 
-static int openprom_bsd_ioctl(struct inode * inode, struct file * file,
+static int openprom_bsd_ioctl(struct file * file,
 			      unsigned int cmd, unsigned long arg)
 {
 	DATA *data = (DATA *) file->private_data;
 	void __user *argp = (void __user *)arg;
 	int err;
 
+	lock_kernel();
 	switch (cmd) {
 	case OPIOCGET:
 		err = opiocget(argp, data);
@@ -570,10 +575,10 @@ static int openprom_bsd_ioctl(struct inode * inode, struct file * file,
 	case OPIOCGETOPTNODE:
 		BUILD_BUG_ON(sizeof(phandle) != sizeof(int));
 
+		err = 0;
 		if (copy_to_user(argp, &options_node->phandle, sizeof(phandle)))
-			return -EFAULT;
-
-		return 0;
+			err = -EFAULT;
+		break;
 
 	case OPIOCGETNEXT:
 	case OPIOCGETCHILD:
@@ -581,9 +586,10 @@ static int openprom_bsd_ioctl(struct inode * inode, struct file * file,
 		break;
 
 	default:
-		return -EINVAL;
-
+		err = -EINVAL;
+		break;
 	};
+	unlock_kernel();
 
 	return err;
 }
@@ -592,8 +598,8 @@ static int openprom_bsd_ioctl(struct inode * inode, struct file * file,
 /*
  *	Handoff control to the correct ioctl handler.
  */
-static int openprom_ioctl(struct inode * inode, struct file * file,
-			  unsigned int cmd, unsigned long arg)
+static long openprom_ioctl(struct file * file,
+			   unsigned int cmd, unsigned long arg)
 {
 	DATA *data = (DATA *) file->private_data;
 
@@ -602,14 +608,14 @@ static int openprom_ioctl(struct inode * inode, struct file * file,
 	case OPROMNXTOPT:
 		if ((file->f_mode & FMODE_READ) == 0)
 			return -EPERM;
-		return openprom_sunos_ioctl(inode, file, cmd, arg,
+		return openprom_sunos_ioctl(file, cmd, arg,
 					    options_node);
 
 	case OPROMSETOPT:
 	case OPROMSETOPT2:
 		if ((file->f_mode & FMODE_WRITE) == 0)
 			return -EPERM;
-		return openprom_sunos_ioctl(inode, file, cmd, arg,
+		return openprom_sunos_ioctl(file, cmd, arg,
 					    options_node);
 
 	case OPROMNEXT:
@@ -618,7 +624,7 @@ static int openprom_ioctl(struct inode * inode, struct file * file,
 	case OPROMNXTPROP:
 		if ((file->f_mode & FMODE_READ) == 0)
 			return -EPERM;
-		return openprom_sunos_ioctl(inode, file, cmd, arg,
+		return openprom_sunos_ioctl(file, cmd, arg,
 					    data->current_node);
 
 	case OPROMU2P:
@@ -630,7 +636,7 @@ static int openprom_ioctl(struct inode * inode, struct file * file,
 	case OPROMPATH2NODE:
 		if ((file->f_mode & FMODE_READ) == 0)
 			return -EPERM;
-		return openprom_sunos_ioctl(inode, file, cmd, arg, NULL);
+		return openprom_sunos_ioctl(file, cmd, arg, NULL);
 
 	case OPIOCGET:
 	case OPIOCNEXTPROP:
@@ -639,12 +645,12 @@ static int openprom_ioctl(struct inode * inode, struct file * file,
 	case OPIOCGETCHILD:
 		if ((file->f_mode & FMODE_READ) == 0)
 			return -EBADF;
-		return openprom_bsd_ioctl(inode,file,cmd,arg);
+		return openprom_bsd_ioctl(file,cmd,arg);
 
 	case OPIOCSET:
 		if ((file->f_mode & FMODE_WRITE) == 0)
 			return -EBADF;
-		return openprom_bsd_ioctl(inode,file,cmd,arg);
+		return openprom_bsd_ioctl(file,cmd,arg);
 
 	default:
 		return -EINVAL;
@@ -676,7 +682,7 @@ static long openprom_compat_ioctl(struct file *file, unsigned int cmd,
 	case OPROMSETCUR:
 	case OPROMPCI2NODE:
 	case OPROMPATH2NODE:
-		rval = openprom_ioctl(file->f_path.dentry->d_inode, file, cmd, arg);
+		rval = openprom_ioctl(file, cmd, arg);
 		break;
 	}
 
@@ -709,7 +715,7 @@ static int openprom_release(struct inode * inode, struct file * file)
 static const struct file_operations openprom_fops = {
 	.owner =	THIS_MODULE,
 	.llseek =	no_llseek,
-	.ioctl =	openprom_ioctl,
+	.unlocked_ioctl = openprom_ioctl,
 	.compat_ioctl =	openprom_compat_ioctl,
 	.open =		openprom_open,
 	.release =	openprom_release,

commit 6016a363f6b56b46b24655bcfc0499b715851cf3
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Thu Jan 28 14:06:53 2010 -0700

    of: unify phandle name in struct device_node
    
    In struct device_node, the phandle is named 'linux_phandle' for PowerPC
    and MicroBlaze, and 'node' for SPARC.  There is no good reason for the
    difference, it is just an artifact of the code diverging over a couple
    of years.  This patch renames both to simply .phandle.
    
    Note: the .node also existed in PowerPC/MicroBlaze, but the only user
    seems to be arch/powerpc/platforms/powermac/pfunc_core.c.  It doesn't
    look like the assignment between .linux_phandle and .node is
    significantly different enough to warrant the separate code paths
    unless ibm,phandle properties actually appear in Apple device trees.
    
    I think it is safe to eliminate the old .node property and use
    phandle everywhere.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Acked-by: David S. Miller <davem@davemloft.net>
    Tested-by: Wolfram Sang <w.sang@pengutronix.de>
    Acked-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/drivers/sbus/char/openprom.c b/drivers/sbus/char/openprom.c
index 75ac19b1192f..fc2f676e984d 100644
--- a/drivers/sbus/char/openprom.c
+++ b/drivers/sbus/char/openprom.c
@@ -233,7 +233,7 @@ static int opromnext(void __user *argp, unsigned int cmd, struct device_node *dp
 
 	ph = 0;
 	if (dp)
-		ph = dp->node;
+		ph = dp->phandle;
 
 	data->current_node = dp;
 	*((int *) op->oprom_array) = ph;
@@ -256,7 +256,7 @@ static int oprompci2node(void __user *argp, struct device_node *dp, struct openp
 
 		dp = pci_device_to_OF_node(pdev);
 		data->current_node = dp;
-		*((int *)op->oprom_array) = dp->node;
+		*((int *)op->oprom_array) = dp->phandle;
 		op->oprom_size = sizeof(int);
 		err = copyout(argp, op, bufsize + sizeof(int));
 
@@ -273,7 +273,7 @@ static int oprompath2node(void __user *argp, struct device_node *dp, struct open
 
 	dp = of_find_node_by_path(op->oprom_array);
 	if (dp)
-		ph = dp->node;
+		ph = dp->phandle;
 	data->current_node = dp;
 	*((int *)op->oprom_array) = ph;
 	op->oprom_size = sizeof(int);
@@ -540,7 +540,7 @@ static int opiocgetnext(unsigned int cmd, void __user *argp)
 		}
 	}
 	if (dp)
-		nd = dp->node;
+		nd = dp->phandle;
 	if (copy_to_user(argp, &nd, sizeof(phandle)))
 		return -EFAULT;
 
@@ -570,7 +570,7 @@ static int openprom_bsd_ioctl(struct inode * inode, struct file * file,
 	case OPIOCGETOPTNODE:
 		BUILD_BUG_ON(sizeof(phandle) != sizeof(int));
 
-		if (copy_to_user(argp, &options_node->node, sizeof(phandle)))
+		if (copy_to_user(argp, &options_node->phandle, sizeof(phandle)))
 			return -EFAULT;
 
 		return 0;

commit 32e5897da1fc5180aa817c81e6aca74a8f6b6957
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Jun 16 03:46:54 2009 -0700

    openprom: Squelch useless GCC warning.
    
    drivers/sbus/char/openprom.c: In function ‘openprom_sunos_ioctl’:
    drivers/sbus/char/openprom.c:306: warning: ‘opp’ may be used uninitialized in this function
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/sbus/char/openprom.c b/drivers/sbus/char/openprom.c
index 124f660a0383..75ac19b1192f 100644
--- a/drivers/sbus/char/openprom.c
+++ b/drivers/sbus/char/openprom.c
@@ -303,7 +303,7 @@ static int openprom_sunos_ioctl(struct inode * inode, struct file * file,
 				struct device_node *dp)
 {
 	DATA *data = file->private_data;
-	struct openpromio *opp;
+	struct openpromio *opp = NULL;
 	int bufsize, error = 0;
 	static int cnt;
 	void __user *argp = (void __user *)arg;

commit 1c339eb183bb48095feaa46057ac4f4f0603dbf9
Author: Scott James Remnant <scott@canonical.com>
Date:   Fri Mar 13 14:30:08 2009 -0700

    sbus: Auto-load openprom module when device opened.
    
    The openprom module is missing the char-major-10-139 alias that would
    cause it to be auto-loaded when a device of that type is opened.  This
    patch adds the alias.
    
    Signed-off-by: Scott James Remnant <scott@canonical.com>
    Signed-off-by: Tim Gardner <tim.gardner@canonical.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/sbus/char/openprom.c b/drivers/sbus/char/openprom.c
index 29dc735e1a20..124f660a0383 100644
--- a/drivers/sbus/char/openprom.c
+++ b/drivers/sbus/char/openprom.c
@@ -51,6 +51,7 @@ MODULE_AUTHOR("Thomas K. Dyas (tdyas@noc.rutgers.edu) and Eddie C. Dost  (ecd@sk
 MODULE_DESCRIPTION("OPENPROM Configuration Driver");
 MODULE_LICENSE("GPL");
 MODULE_VERSION("1.0");
+MODULE_ALIAS_MISCDEV(SUN_OPENPROM_MINOR);
 
 /* Private data kept by the driver for each descriptor. */
 typedef struct openprom_private_data

commit 7bcc3209be82d69361a944c57caeb548b35c7f04
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue May 20 19:16:29 2008 +0200

    openprom: BKL pushdown
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/drivers/sbus/char/openprom.c b/drivers/sbus/char/openprom.c
index fbfeb89a6f32..29dc735e1a20 100644
--- a/drivers/sbus/char/openprom.c
+++ b/drivers/sbus/char/openprom.c
@@ -33,6 +33,7 @@
 #include <linux/kernel.h>
 #include <linux/errno.h>
 #include <linux/slab.h>
+#include <linux/smp_lock.h>
 #include <linux/string.h>
 #include <linux/miscdevice.h>
 #include <linux/init.h>
@@ -689,9 +690,11 @@ static int openprom_open(struct inode * inode, struct file * file)
 	if (!data)
 		return -ENOMEM;
 
+	lock_kernel();
 	data->current_node = of_find_node_by_path("/");
 	data->lastnode = data->current_node;
 	file->private_data = (void *) data;
+	unlock_kernel();
 
 	return 0;
 }

commit fa449bd602c8871da48e6dbadfa0faaf4d33d32e
Author: David S. Miller <davem@sunset.davemloft.net>
Date:   Wed Apr 25 16:01:51 2007 -0700

    [OPENPROM]: Use pci_device_to_OF_node().
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/sbus/char/openprom.c b/drivers/sbus/char/openprom.c
index aec3b9f991f6..fbfeb89a6f32 100644
--- a/drivers/sbus/char/openprom.c
+++ b/drivers/sbus/char/openprom.c
@@ -44,7 +44,6 @@
 #include <asm/openpromio.h>
 #ifdef CONFIG_PCI
 #include <linux/pci.h>
-#include <asm/pbm.h>
 #endif
 
 MODULE_AUTHOR("Thomas K. Dyas (tdyas@noc.rutgers.edu) and Eddie C. Dost  (ecd@skynet.be)");
@@ -248,18 +247,17 @@ static int oprompci2node(void __user *argp, struct device_node *dp, struct openp
 	if (bufsize >= 2*sizeof(int)) {
 #ifdef CONFIG_PCI
 		struct pci_dev *pdev;
-		struct pcidev_cookie *pcp;
+		struct device_node *dp;
+
 		pdev = pci_get_bus_and_slot (((int *) op->oprom_array)[0],
 				      ((int *) op->oprom_array)[1]);
 
-		pcp = pdev->sysdata;
-		if (pcp != NULL) {
-			dp = pcp->prom_node;
-			data->current_node = dp;
-			*((int *)op->oprom_array) = dp->node;
-			op->oprom_size = sizeof(int);
-			err = copyout(argp, op, bufsize + sizeof(int));
-		}
+		dp = pci_device_to_OF_node(pdev);
+		data->current_node = dp;
+		*((int *)op->oprom_array) = dp->node;
+		op->oprom_size = sizeof(int);
+		err = copyout(argp, op, bufsize + sizeof(int));
+
 		pci_dev_put(pdev);
 #endif
 	}

commit ccf0dec6fcadb4e1c877b9bafb031a6bdb7112b9
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Thu Mar 29 00:49:54 2007 -0700

    [SPARC/64] constify of_get_property return: drivers
    
    The only unfortunate bit here is that the name field of struct map_info
    is not const, so for now we put a cast on the assignment of it.
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/sbus/char/openprom.c b/drivers/sbus/char/openprom.c
index 5041c9dfbe3b..aec3b9f991f6 100644
--- a/drivers/sbus/char/openprom.c
+++ b/drivers/sbus/char/openprom.c
@@ -141,7 +141,7 @@ static int copyout(void __user *info, struct openpromio *opp, int len)
 
 static int opromgetprop(void __user *argp, struct device_node *dp, struct openpromio *op, int bufsize)
 {
-	void *pval;
+	const void *pval;
 	int len;
 
 	if (!dp ||
@@ -410,7 +410,7 @@ static int opiocget(void __user *argp, DATA *data)
 	struct opiocdesc op;
 	struct device_node *dp;
 	char *str;
-	void *pval;
+	const void *pval;
 	int err, len;
 
 	if (copy_from_user(&op, argp, sizeof(op)))

commit 7e9f33461521180ef2c148c0b77eeb412d18ffae
Author: Alan Cox <alan@redhat.com>
Date:   Mon Apr 23 22:50:53 2007 -0700

    [SPARC] openprom: Switch to ref counting PCI API
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/sbus/char/openprom.c b/drivers/sbus/char/openprom.c
index eec28c142a59..5041c9dfbe3b 100644
--- a/drivers/sbus/char/openprom.c
+++ b/drivers/sbus/char/openprom.c
@@ -249,7 +249,7 @@ static int oprompci2node(void __user *argp, struct device_node *dp, struct openp
 #ifdef CONFIG_PCI
 		struct pci_dev *pdev;
 		struct pcidev_cookie *pcp;
-		pdev = pci_find_slot (((int *) op->oprom_array)[0],
+		pdev = pci_get_bus_and_slot (((int *) op->oprom_array)[0],
 				      ((int *) op->oprom_array)[1]);
 
 		pcp = pdev->sysdata;
@@ -260,6 +260,7 @@ static int oprompci2node(void __user *argp, struct device_node *dp, struct openp
 			op->oprom_size = sizeof(int);
 			err = copyout(argp, op, bufsize + sizeof(int));
 		}
+		pci_dev_put(pdev);
 #endif
 	}
 

commit cd354f1ae75e6466a7e31b727faede57a1f89ca5
Author: Tim Schmielau <tim@physik3.uni-rostock.de>
Date:   Wed Feb 14 00:33:14 2007 -0800

    [PATCH] remove many unneeded #includes of sched.h
    
    After Al Viro (finally) succeeded in removing the sched.h #include in module.h
    recently, it makes sense again to remove other superfluous sched.h includes.
    There are quite a lot of files which include it but don't actually need
    anything defined in there.  Presumably these includes were once needed for
    macros that used to live in sched.h, but moved to other header files in the
    course of cleaning it up.
    
    To ease the pain, this time I did not fiddle with any header files and only
    removed #includes from .c-files, which tend to cause less trouble.
    
    Compile tested against 2.6.20-rc2 and 2.6.20-rc2-mm2 (with offsets) on alpha,
    arm, i386, ia64, mips, powerpc, and x86_64 with allnoconfig, defconfig,
    allmodconfig, and allyesconfig as well as a few randconfigs on x86_64 and all
    configs in arch/arm/configs on arm.  I also checked that no new warnings were
    introduced by the patch (actually, some warnings are removed that were emitted
    by unnecessarily included header files).
    
    Signed-off-by: Tim Schmielau <tim@physik3.uni-rostock.de>
    Acked-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/sbus/char/openprom.c b/drivers/sbus/char/openprom.c
index e8776230782b..eec28c142a59 100644
--- a/drivers/sbus/char/openprom.c
+++ b/drivers/sbus/char/openprom.c
@@ -31,7 +31,6 @@
 
 #include <linux/module.h>
 #include <linux/kernel.h>
-#include <linux/sched.h>
 #include <linux/errno.h>
 #include <linux/slab.h>
 #include <linux/string.h>

commit 00977a59b951207d38380c75f03a36829950265c
Author: Arjan van de Ven <arjan@linux.intel.com>
Date:   Mon Feb 12 00:55:34 2007 -0800

    [PATCH] mark struct file_operations const 6
    
    Many struct file_operations in the kernel can be "const".  Marking them const
    moves these to the .rodata section, which avoids false sharing with potential
    dirty data.  In addition it'll catch accidental writes at compile time to
    these shared resources.
    
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/sbus/char/openprom.c b/drivers/sbus/char/openprom.c
index 4e2a0e2dcc2e..e8776230782b 100644
--- a/drivers/sbus/char/openprom.c
+++ b/drivers/sbus/char/openprom.c
@@ -704,7 +704,7 @@ static int openprom_release(struct inode * inode, struct file * file)
 	return 0;
 }
 
-static struct file_operations openprom_fops = {
+static const struct file_operations openprom_fops = {
 	.owner =	THIS_MODULE,
 	.llseek =	no_llseek,
 	.ioctl =	openprom_ioctl,

commit 7fa95f726aba6033d7baffcfda484c31b8cfe153
Author: Josef Sipek <jsipek@fsl.cs.sunysb.edu>
Date:   Fri Dec 8 02:37:36 2006 -0800

    [PATCH] struct path: convert sbus
    
    Signed-off-by: Josef Sipek <jsipek@fsl.cs.sunysb.edu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/sbus/char/openprom.c b/drivers/sbus/char/openprom.c
index 81ba2d71cee2..4e2a0e2dcc2e 100644
--- a/drivers/sbus/char/openprom.c
+++ b/drivers/sbus/char/openprom.c
@@ -676,7 +676,7 @@ static long openprom_compat_ioctl(struct file *file, unsigned int cmd,
 	case OPROMSETCUR:
 	case OPROMPCI2NODE:
 	case OPROMPATH2NODE:
-		rval = openprom_ioctl(file->f_dentry->d_inode, file, cmd, arg);
+		rval = openprom_ioctl(file->f_path.dentry->d_inode, file, cmd, arg);
 		break;
 	}
 

commit a6ded1b0605376e18a17cb01977819bcf2677cdc
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Tue Oct 10 22:48:17 2006 +0100

    [PATCH] openprom NULL noise removal
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Acked-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/sbus/char/openprom.c b/drivers/sbus/char/openprom.c
index 2f698763ba5d..81ba2d71cee2 100644
--- a/drivers/sbus/char/openprom.c
+++ b/drivers/sbus/char/openprom.c
@@ -630,7 +630,7 @@ static int openprom_ioctl(struct inode * inode, struct file * file,
 	case OPROMPATH2NODE:
 		if ((file->f_mode & FMODE_READ) == 0)
 			return -EPERM;
-		return openprom_sunos_ioctl(inode, file, cmd, arg, 0);
+		return openprom_sunos_ioctl(inode, file, cmd, arg, NULL);
 
 	case OPIOCGET:
 	case OPIOCNEXTPROP:

commit b9b64e6e89fc5a6ef220747115c5b7764614ca3f
Author: David S. Miller <davem@sunset.davemloft.net>
Date:   Mon Sep 18 01:47:13 2006 -0700

    [OPENPROMIO]: Handle current_node being NULL correctly.
    
    If the user tries to traverse to the next node of the
    last node, we get NULL in current_node and a zero phandle
    returned.  That's fine, but if the user tries to obtain
    properties in that state, we try to dereference a NULL
    pointer in the downcall to the of_*() routines.
    
    So protect against that.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/sbus/char/openprom.c b/drivers/sbus/char/openprom.c
index 293bb2fdb1d5..2f698763ba5d 100644
--- a/drivers/sbus/char/openprom.c
+++ b/drivers/sbus/char/openprom.c
@@ -145,8 +145,9 @@ static int opromgetprop(void __user *argp, struct device_node *dp, struct openpr
 	void *pval;
 	int len;
 
-	pval = of_get_property(dp, op->oprom_array, &len);
-	if (!pval || len <= 0 || len > bufsize)
+	if (!dp ||
+	    !(pval = of_get_property(dp, op->oprom_array, &len)) ||
+	    len <= 0 || len > bufsize)
 		return copyout(argp, op, sizeof(int));
 
 	memcpy(op->oprom_array, pval, len);
@@ -161,6 +162,8 @@ static int opromnxtprop(void __user *argp, struct device_node *dp, struct openpr
 	struct property *prop;
 	int len;
 
+	if (!dp)
+		return copyout(argp, op, sizeof(int));
 	if (op->oprom_array[0] == '\0') {
 		prop = dp->properties;
 		if (!prop)
@@ -266,9 +269,13 @@ static int oprompci2node(void __user *argp, struct device_node *dp, struct openp
 
 static int oprompath2node(void __user *argp, struct device_node *dp, struct openpromio *op, int bufsize, DATA *data)
 {
+	phandle ph = 0;
+
 	dp = of_find_node_by_path(op->oprom_array);
+	if (dp)
+		ph = dp->node;
 	data->current_node = dp;
-	*((int *)op->oprom_array) = dp->node;
+	*((int *)op->oprom_array) = ph;
 	op->oprom_size = sizeof(int);
 
 	return copyout(argp, op, bufsize + sizeof(int));

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jörn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jörn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/drivers/sbus/char/openprom.c b/drivers/sbus/char/openprom.c
index d7e4bb41bd79..293bb2fdb1d5 100644
--- a/drivers/sbus/char/openprom.c
+++ b/drivers/sbus/char/openprom.c
@@ -29,7 +29,6 @@
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. 
  */
 
-#include <linux/config.h>
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/sched.h>

commit 8e48aec714f1faf581949f23ae0e3d6e2317433b
Author: David S. Miller <davem@davemloft.net>
Date:   Sun Jun 25 23:19:30 2006 -0700

    [OPENPROM]: Rewrite driver to use in-kernel device tree.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/sbus/char/openprom.c b/drivers/sbus/char/openprom.c
index cf5b476b5496..d7e4bb41bd79 100644
--- a/drivers/sbus/char/openprom.c
+++ b/drivers/sbus/char/openprom.c
@@ -29,8 +29,6 @@
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. 
  */
 
-#define PROMLIB_INTERNAL
-
 #include <linux/config.h>
 #include <linux/module.h>
 #include <linux/kernel.h>
@@ -39,10 +37,10 @@
 #include <linux/slab.h>
 #include <linux/string.h>
 #include <linux/miscdevice.h>
-#include <linux/smp_lock.h>
 #include <linux/init.h>
 #include <linux/fs.h>
 #include <asm/oplib.h>
+#include <asm/prom.h>
 #include <asm/system.h>
 #include <asm/uaccess.h>
 #include <asm/openpromio.h>
@@ -51,15 +49,20 @@
 #include <asm/pbm.h>
 #endif
 
+MODULE_AUTHOR("Thomas K. Dyas (tdyas@noc.rutgers.edu) and Eddie C. Dost  (ecd@skynet.be)");
+MODULE_DESCRIPTION("OPENPROM Configuration Driver");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("1.0");
+
 /* Private data kept by the driver for each descriptor. */
 typedef struct openprom_private_data
 {
-	int current_node;	/* Current node for SunOS ioctls. */
-	int lastnode;		/* Last valid node used by BSD ioctls. */
+	struct device_node *current_node; /* Current node for SunOS ioctls. */
+	struct device_node *lastnode; /* Last valid node used by BSD ioctls. */
 } DATA;
 
 /* ID of the PROM node containing all of the EEPROM options. */
-static int options_node = 0;
+static struct device_node *options_node;
 
 /*
  * Copy an openpromio structure into kernel space from user space.
@@ -87,9 +90,8 @@ static int copyin(struct openpromio __user *info, struct openpromio **opp_p)
 	if (bufsize > OPROMMAXPARAM)
 		bufsize = OPROMMAXPARAM;
 
-	if (!(*opp_p = kmalloc(sizeof(int) + bufsize + 1, GFP_KERNEL)))
+	if (!(*opp_p = kzalloc(sizeof(int) + bufsize + 1, GFP_KERNEL)))
 		return -ENOMEM;
-	memset(*opp_p, 0, sizeof(int) + bufsize + 1);
 
 	if (copy_from_user(&(*opp_p)->oprom_array,
 			   &info->oprom_array, bufsize)) {
@@ -107,10 +109,9 @@ static int getstrings(struct openpromio __user *info, struct openpromio **opp_p)
 	if (!info || !opp_p)
 		return -EFAULT;
 
-	if (!(*opp_p = kmalloc(sizeof(int) + OPROMMAXPARAM + 1, GFP_KERNEL)))
+	if (!(*opp_p = kzalloc(sizeof(int) + OPROMMAXPARAM + 1, GFP_KERNEL)))
 		return -ENOMEM;
 
-	memset(*opp_p, 0, sizeof(int) + OPROMMAXPARAM + 1);
 	(*opp_p)->oprom_size = 0;
 
 	n = bufsize = 0;
@@ -140,16 +141,164 @@ static int copyout(void __user *info, struct openpromio *opp, int len)
 	return 0;
 }
 
+static int opromgetprop(void __user *argp, struct device_node *dp, struct openpromio *op, int bufsize)
+{
+	void *pval;
+	int len;
+
+	pval = of_get_property(dp, op->oprom_array, &len);
+	if (!pval || len <= 0 || len > bufsize)
+		return copyout(argp, op, sizeof(int));
+
+	memcpy(op->oprom_array, pval, len);
+	op->oprom_array[len] = '\0';
+	op->oprom_size = len;
+
+	return copyout(argp, op, sizeof(int) + bufsize);
+}
+
+static int opromnxtprop(void __user *argp, struct device_node *dp, struct openpromio *op, int bufsize)
+{
+	struct property *prop;
+	int len;
+
+	if (op->oprom_array[0] == '\0') {
+		prop = dp->properties;
+		if (!prop)
+			return copyout(argp, op, sizeof(int));
+		len = strlen(prop->name);
+	} else {
+		prop = of_find_property(dp, op->oprom_array, NULL);
+
+		if (!prop ||
+		    !prop->next ||
+		    (len = strlen(prop->next->name)) + 1 > bufsize)
+			return copyout(argp, op, sizeof(int));
+
+		prop = prop->next;
+	}
+
+	memcpy(op->oprom_array, prop->name, len);
+	op->oprom_array[len] = '\0';
+	op->oprom_size = ++len;
+
+	return copyout(argp, op, sizeof(int) + bufsize);
+}
+
+static int opromsetopt(struct device_node *dp, struct openpromio *op, int bufsize)
+{
+	char *buf = op->oprom_array + strlen(op->oprom_array) + 1;
+	int len = op->oprom_array + bufsize - buf;
+
+	return of_set_property(options_node, op->oprom_array, buf, len);
+}
+
+static int opromnext(void __user *argp, unsigned int cmd, struct device_node *dp, struct openpromio *op, int bufsize, DATA *data)
+{
+	phandle ph;
+
+	BUILD_BUG_ON(sizeof(phandle) != sizeof(int));
+
+	if (bufsize < sizeof(phandle))
+		return -EINVAL;
+
+	ph = *((int *) op->oprom_array);
+	if (ph) {
+		dp = of_find_node_by_phandle(ph);
+		if (!dp)
+			return -EINVAL;
+
+		switch (cmd) {
+		case OPROMNEXT:
+			dp = dp->sibling;
+			break;
+
+		case OPROMCHILD:
+			dp = dp->child;
+			break;
+
+		case OPROMSETCUR:
+		default:
+			break;
+		};
+	} else {
+		/* Sibling of node zero is the root node.  */
+		if (cmd != OPROMNEXT)
+			return -EINVAL;
+
+		dp = of_find_node_by_path("/");
+	}
+
+	ph = 0;
+	if (dp)
+		ph = dp->node;
+
+	data->current_node = dp;
+	*((int *) op->oprom_array) = ph;
+	op->oprom_size = sizeof(phandle);
+
+	return copyout(argp, op, bufsize + sizeof(int));
+}
+
+static int oprompci2node(void __user *argp, struct device_node *dp, struct openpromio *op, int bufsize, DATA *data)
+{
+	int err = -EINVAL;
+
+	if (bufsize >= 2*sizeof(int)) {
+#ifdef CONFIG_PCI
+		struct pci_dev *pdev;
+		struct pcidev_cookie *pcp;
+		pdev = pci_find_slot (((int *) op->oprom_array)[0],
+				      ((int *) op->oprom_array)[1]);
+
+		pcp = pdev->sysdata;
+		if (pcp != NULL) {
+			dp = pcp->prom_node;
+			data->current_node = dp;
+			*((int *)op->oprom_array) = dp->node;
+			op->oprom_size = sizeof(int);
+			err = copyout(argp, op, bufsize + sizeof(int));
+		}
+#endif
+	}
+
+	return err;
+}
+
+static int oprompath2node(void __user *argp, struct device_node *dp, struct openpromio *op, int bufsize, DATA *data)
+{
+	dp = of_find_node_by_path(op->oprom_array);
+	data->current_node = dp;
+	*((int *)op->oprom_array) = dp->node;
+	op->oprom_size = sizeof(int);
+
+	return copyout(argp, op, bufsize + sizeof(int));
+}
+
+static int opromgetbootargs(void __user *argp, struct openpromio *op, int bufsize)
+{
+	char *buf = saved_command_line;
+	int len = strlen(buf);
+
+	if (len > bufsize)
+		return -EINVAL;
+
+	strcpy(op->oprom_array, buf);
+	op->oprom_size = len;
+
+	return copyout(argp, op, bufsize + sizeof(int));
+}
+
 /*
  *	SunOS and Solaris /dev/openprom ioctl calls.
  */
 static int openprom_sunos_ioctl(struct inode * inode, struct file * file,
-				unsigned int cmd, unsigned long arg, int node)
+				unsigned int cmd, unsigned long arg,
+				struct device_node *dp)
 {
-	DATA *data = (DATA *) file->private_data;
-	char buffer[OPROMMAXPARAM+1], *buf;
+	DATA *data = file->private_data;
 	struct openpromio *opp;
-	int bufsize, len, error = 0;
+	int bufsize, error = 0;
 	static int cnt;
 	void __user *argp = (void __user *)arg;
 
@@ -164,119 +313,35 @@ static int openprom_sunos_ioctl(struct inode * inode, struct file * file,
 	switch (cmd) {
 	case OPROMGETOPT:
 	case OPROMGETPROP:
-		len = prom_getproplen(node, opp->oprom_array);
-
-		if (len <= 0 || len > bufsize) {
-			error = copyout(argp, opp, sizeof(int));
-			break;
-		}
-
-		len = prom_getproperty(node, opp->oprom_array, buffer, bufsize);
-
-		memcpy(opp->oprom_array, buffer, len);
-		opp->oprom_array[len] = '\0';
-		opp->oprom_size = len;
-
-		error = copyout(argp, opp, sizeof(int) + bufsize);
+		error = opromgetprop(argp, dp, opp, bufsize);
 		break;
 
 	case OPROMNXTOPT:
 	case OPROMNXTPROP:
-		buf = prom_nextprop(node, opp->oprom_array, buffer);
-
-		len = strlen(buf);
-		if (len == 0 || len + 1 > bufsize) {
-			error = copyout(argp, opp, sizeof(int));
-			break;
-		}
-
-		memcpy(opp->oprom_array, buf, len);
-		opp->oprom_array[len] = '\0';
-		opp->oprom_size = ++len;
-
-		error = copyout(argp, opp, sizeof(int) + bufsize);
+		error = opromnxtprop(argp, dp, opp, bufsize);
 		break;
 
 	case OPROMSETOPT:
 	case OPROMSETOPT2:
-		buf = opp->oprom_array + strlen(opp->oprom_array) + 1;
-		len = opp->oprom_array + bufsize - buf;
-
-		error = prom_setprop(options_node, opp->oprom_array,
-				     buf, len);
-
-		if (error < 0)
-			error = -EINVAL;
+		error = opromsetopt(dp, opp, bufsize);
 		break;
 
 	case OPROMNEXT:
 	case OPROMCHILD:
 	case OPROMSETCUR:
-		if (bufsize < sizeof(int)) {
-			error = -EINVAL;
-			break;
-		}
-
-		node = *((int *) opp->oprom_array);
-
-		switch (cmd) {
-		case OPROMNEXT: node = __prom_getsibling(node); break;
-		case OPROMCHILD: node = __prom_getchild(node); break;
-		case OPROMSETCUR: break;
-		}
-
-		data->current_node = node;
-		*((int *)opp->oprom_array) = node;
-		opp->oprom_size = sizeof(int);
-
-		error = copyout(argp, opp, bufsize + sizeof(int));
+		error = opromnext(argp, cmd, dp, opp, bufsize, data);
 		break;
 
 	case OPROMPCI2NODE:
-		error = -EINVAL;
-
-		if (bufsize >= 2*sizeof(int)) {
-#ifdef CONFIG_PCI
-			struct pci_dev *pdev;
-			struct pcidev_cookie *pcp;
-			pdev = pci_find_slot (((int *) opp->oprom_array)[0],
-					      ((int *) opp->oprom_array)[1]);
-
-			pcp = pdev->sysdata;
-			if (pcp != NULL) {
-				node = pcp->prom_node->node;
-				data->current_node = node;
-				*((int *)opp->oprom_array) = node;
-				opp->oprom_size = sizeof(int);
-				error = copyout(argp, opp, bufsize + sizeof(int));
-			}
-#endif
-		}
+		error = oprompci2node(argp, dp, opp, bufsize, data);
 		break;
 
 	case OPROMPATH2NODE:
-		node = prom_finddevice(opp->oprom_array);
-		data->current_node = node;
-		*((int *)opp->oprom_array) = node;
-		opp->oprom_size = sizeof(int);
-
-		error = copyout(argp, opp, bufsize + sizeof(int));
+		error = oprompath2node(argp, dp, opp, bufsize, data);
 		break;
 
 	case OPROMGETBOOTARGS:
-		buf = saved_command_line;
-
-		len = strlen(buf);
-
-		if (len > bufsize) {
-			error = -EINVAL;
-			break;
-		}
-
-		strcpy(opp->oprom_array, buf);
-		opp->oprom_size = len;
-
-		error = copyout(argp, opp, bufsize + sizeof(int));
+		error = opromgetbootargs(argp, opp, bufsize);
 		break;
 
 	case OPROMU2P:
@@ -297,25 +362,14 @@ static int openprom_sunos_ioctl(struct inode * inode, struct file * file,
 	return error;
 }
 
-
-/* Return nonzero if a specific node is in the PROM device tree. */
-static int intree(int root, int node)
+static struct device_node *get_node(phandle n, DATA *data)
 {
-	for (; root != 0; root = prom_getsibling(root))
-		if (root == node || intree(prom_getchild(root),node))
-			return 1;
-	return 0;
-}
+	struct device_node *dp = of_find_node_by_phandle(n);
 
-/* Return nonzero if a specific node is "valid". */
-static int goodnode(int n, DATA *data)
-{
-	if (n == data->lastnode || n == prom_root_node || n == options_node)
-		return 1;
-	if (n == 0 || n == -1 || !intree(prom_root_node,n))
-		return 0;
-	data->lastnode = n;
-	return 1;
+	if (dp)
+		data->lastnode = dp;
+
+	return dp;
 }
 
 /* Copy in a whole string from userspace into kernelspace. */
@@ -330,7 +384,7 @@ static int copyin_string(char __user *user, size_t len, char **ptr)
 	if (!tmp)
 		return -ENOMEM;
 
-	if(copy_from_user(tmp, user, len)) {
+	if (copy_from_user(tmp, user, len)) {
 		kfree(tmp);
 		return -EFAULT;
 	}
@@ -345,162 +399,187 @@ static int copyin_string(char __user *user, size_t len, char **ptr)
 /*
  *	NetBSD /dev/openprom ioctl calls.
  */
-static int openprom_bsd_ioctl(struct inode * inode, struct file * file,
-			      unsigned int cmd, unsigned long arg)
+static int opiocget(void __user *argp, DATA *data)
 {
-	DATA *data = (DATA *) file->private_data;
-	void __user *argp = (void __user *)arg;
 	struct opiocdesc op;
-	int error, node, len;
-	char *str, *tmp;
-	char buffer[64];
-	static int cnt;
-
-	switch (cmd) {
-	case OPIOCGET:
-		if (copy_from_user(&op, argp, sizeof(op)))
-			return -EFAULT;
-
-		if (!goodnode(op.op_nodeid,data))
-			return -EINVAL;
+	struct device_node *dp;
+	char *str;
+	void *pval;
+	int err, len;
 
-		error = copyin_string(op.op_name, op.op_namelen, &str);
-		if (error)
-			return error;
+	if (copy_from_user(&op, argp, sizeof(op)))
+		return -EFAULT;
 
-		len = prom_getproplen(op.op_nodeid,str);
+	dp = get_node(op.op_nodeid, data);
 
-		if (len > op.op_buflen) {
-			kfree(str);
-			return -ENOMEM;
-		}
+	err = copyin_string(op.op_name, op.op_namelen, &str);
+	if (err)
+		return err;
 
+	pval = of_get_property(dp, str, &len);
+	err = 0;
+	if (!pval || len > op.op_buflen) {
+		err = -EINVAL;
+	} else {
 		op.op_buflen = len;
+		if (copy_to_user(argp, &op, sizeof(op)) ||
+		    copy_to_user(op.op_buf, pval, len))
+			err = -EFAULT;
+	}
+	kfree(str);
 
-		if (len <= 0) {
-			kfree(str);
-			/* Verified by the above copy_from_user */
-			if (__copy_to_user(argp, &op,
-				       sizeof(op)))
-				return -EFAULT;
-			return 0;
-		}
+	return err;
+}
 
-		tmp = kmalloc(len + 1, GFP_KERNEL);
-		if (!tmp) {
-			kfree(str);
-			return -ENOMEM;
-		}
+static int opiocnextprop(void __user *argp, DATA *data)
+{
+	struct opiocdesc op;
+	struct device_node *dp;
+	struct property *prop;
+	char *str;
+	int err, len;
 
-		cnt = prom_getproperty(op.op_nodeid, str, tmp, len);
-		if (cnt <= 0) {
-			error = -EINVAL;
-		} else {
-			tmp[len] = '\0';
+	if (copy_from_user(&op, argp, sizeof(op)))
+		return -EFAULT;
 
-			if (__copy_to_user(argp, &op, sizeof(op)) != 0 ||
-			    copy_to_user(op.op_buf, tmp, len) != 0)
-				error = -EFAULT;
-		}
+	dp = get_node(op.op_nodeid, data);
+	if (!dp)
+		return -EINVAL;
 
-		kfree(tmp);
-		kfree(str);
+	err = copyin_string(op.op_name, op.op_namelen, &str);
+	if (err)
+		return err;
 
-		return error;
+	if (str[0] == '\0') {
+		prop = dp->properties;
+	} else {
+		prop = of_find_property(dp, str, NULL);
+		if (prop)
+			prop = prop->next;
+	}
+	kfree(str);
 
-	case OPIOCNEXTPROP:
-		if (copy_from_user(&op, argp, sizeof(op)))
-			return -EFAULT;
+	if (!prop)
+		len = 0;
+	else
+		len = prop->length;
 
-		if (!goodnode(op.op_nodeid,data))
-			return -EINVAL;
+	if (len > op.op_buflen)
+		len = op.op_buflen;
 
-		error = copyin_string(op.op_name, op.op_namelen, &str);
-		if (error)
-			return error;
+	if (copy_to_user(argp, &op, sizeof(op)))
+		return -EFAULT;
 
-		tmp = prom_nextprop(op.op_nodeid,str,buffer);
+	if (len &&
+	    copy_to_user(op.op_buf, prop->value, len))
+		return -EFAULT;
 
-		if (tmp) {
-			len = strlen(tmp);
-			if (len > op.op_buflen)
-				len = op.op_buflen;
-			else
-				op.op_buflen = len;
-		} else {
-			len = op.op_buflen = 0;
-		}
+	return 0;
+}
 
-		if (!access_ok(VERIFY_WRITE, argp, sizeof(op))) {
-			kfree(str);
-			return -EFAULT;
-		}
+static int opiocset(void __user *argp, DATA *data)
+{
+	struct opiocdesc op;
+	struct device_node *dp;
+	char *str, *tmp;
+	int err;
 
-		if (!access_ok(VERIFY_WRITE, op.op_buf, len)) {
-			kfree(str);
-			return -EFAULT;
-		}
+	if (copy_from_user(&op, argp, sizeof(op)))
+		return -EFAULT;
+
+	dp = get_node(op.op_nodeid, data);
+	if (!dp)
+		return -EINVAL;
 
-		error = __copy_to_user(argp, &op, sizeof(op));
-		if (!error) error = __copy_to_user(op.op_buf, tmp, len);
+	err = copyin_string(op.op_name, op.op_namelen, &str);
+	if (err)
+		return err;
 
+	err = copyin_string(op.op_buf, op.op_buflen, &tmp);
+	if (err) {
 		kfree(str);
+		return err;
+	}
 
-		return error;
+	err = of_set_property(dp, str, tmp, op.op_buflen);
 
-	case OPIOCSET:
-		if (copy_from_user(&op, argp, sizeof(op)))
-			return -EFAULT;
+	kfree(str);
+	kfree(tmp);
 
-		if (!goodnode(op.op_nodeid,data))
-			return -EINVAL;
+	return err;
+}
 
-		error = copyin_string(op.op_name, op.op_namelen, &str);
-		if (error)
-			return error;
+static int opiocgetnext(unsigned int cmd, void __user *argp)
+{
+	struct device_node *dp;
+	phandle nd;
 
-		error = copyin_string(op.op_buf, op.op_buflen, &tmp);
-		if (error) {
-			kfree(str);
-			return error;
-		}
+	BUILD_BUG_ON(sizeof(phandle) != sizeof(int));
 
-		len = prom_setprop(op.op_nodeid,str,tmp,op.op_buflen+1);
+	if (copy_from_user(&nd, argp, sizeof(phandle)))
+		return -EFAULT;
 
-		if (len != op.op_buflen)
+	if (nd == 0) {
+		if (cmd != OPIOCGETNEXT)
 			return -EINVAL;
+		dp = of_find_node_by_path("/");
+	} else {
+		dp = of_find_node_by_phandle(nd);
+		nd = 0;
+		if (dp) {
+			if (cmd == OPIOCGETNEXT)
+				dp = dp->sibling;
+			else
+				dp = dp->child;
+		}
+	}
+	if (dp)
+		nd = dp->node;
+	if (copy_to_user(argp, &nd, sizeof(phandle)))
+		return -EFAULT;
 
-		kfree(str);
-		kfree(tmp);
+	return 0;
+}
 
-		return 0;
+static int openprom_bsd_ioctl(struct inode * inode, struct file * file,
+			      unsigned int cmd, unsigned long arg)
+{
+	DATA *data = (DATA *) file->private_data;
+	void __user *argp = (void __user *)arg;
+	int err;
 
-	case OPIOCGETOPTNODE:
-		if (copy_to_user(argp, &options_node, sizeof(int)))
-			return -EFAULT;
-		return 0;
+	switch (cmd) {
+	case OPIOCGET:
+		err = opiocget(argp, data);
+		break;
 
-	case OPIOCGETNEXT:
-	case OPIOCGETCHILD:
-		if (copy_from_user(&node, argp, sizeof(int)))
-			return -EFAULT;
+	case OPIOCNEXTPROP:
+		err = opiocnextprop(argp, data);
+		break;
 
-		if (cmd == OPIOCGETNEXT)
-			node = __prom_getsibling(node);
-		else
-			node = __prom_getchild(node);
+	case OPIOCSET:
+		err = opiocset(argp, data);
+		break;
+
+	case OPIOCGETOPTNODE:
+		BUILD_BUG_ON(sizeof(phandle) != sizeof(int));
 
-		if (__copy_to_user(argp, &node, sizeof(int)))
+		if (copy_to_user(argp, &options_node->node, sizeof(phandle)))
 			return -EFAULT;
 
 		return 0;
 
+	case OPIOCGETNEXT:
+	case OPIOCGETCHILD:
+		err = opiocgetnext(cmd, argp);
+		break;
+
 	default:
-		if (cnt++ < 10)
-			printk(KERN_INFO "openprom_bsd_ioctl: cmd 0x%X\n", cmd);
 		return -EINVAL;
 
-	}
+	};
+
+	return err;
 }
 
 
@@ -511,7 +590,6 @@ static int openprom_ioctl(struct inode * inode, struct file * file,
 			  unsigned int cmd, unsigned long arg)
 {
 	DATA *data = (DATA *) file->private_data;
-	static int cnt;
 
 	switch (cmd) {
 	case OPROMGETOPT:
@@ -563,10 +641,8 @@ static int openprom_ioctl(struct inode * inode, struct file * file,
 		return openprom_bsd_ioctl(inode,file,cmd,arg);
 
 	default:
-		if (cnt++ < 10)
-			printk("openprom_ioctl: cmd 0x%X, arg 0x%lX\n", cmd, arg);
 		return -EINVAL;
-	}
+	};
 }
 
 static long openprom_compat_ioctl(struct file *file, unsigned int cmd,
@@ -594,9 +670,7 @@ static long openprom_compat_ioctl(struct file *file, unsigned int cmd,
 	case OPROMSETCUR:
 	case OPROMPCI2NODE:
 	case OPROMPATH2NODE:
-		lock_kernel();
 		rval = openprom_ioctl(file->f_dentry->d_inode, file, cmd, arg);
-		lock_kernel();
 		break;
 	}
 
@@ -607,13 +681,13 @@ static int openprom_open(struct inode * inode, struct file * file)
 {
 	DATA *data;
 
-	data = (DATA *) kmalloc(sizeof(DATA), GFP_KERNEL);
+	data = kmalloc(sizeof(DATA), GFP_KERNEL);
 	if (!data)
 		return -ENOMEM;
 
-	data->current_node = prom_root_node;
-	data->lastnode = prom_root_node;
-	file->private_data = (void *)data;
+	data->current_node = of_find_node_by_path("/");
+	data->lastnode = data->current_node;
+	file->private_data = (void *) data;
 
 	return 0;
 }
@@ -634,24 +708,30 @@ static struct file_operations openprom_fops = {
 };
 
 static struct miscdevice openprom_dev = {
-	SUN_OPENPROM_MINOR, "openprom", &openprom_fops
+	.minor		= SUN_OPENPROM_MINOR,
+	.name		= "openprom",
+	.fops		= &openprom_fops,
 };
 
 static int __init openprom_init(void)
 {
-	int error;
+	struct device_node *dp;
+	int err;
 
-	error = misc_register(&openprom_dev);
-	if (error) {
-		printk(KERN_ERR "openprom: unable to get misc minor\n");
-		return error;
-	}
+	err = misc_register(&openprom_dev);
+	if (err)
+		return err;
 
-	options_node = prom_getchild(prom_root_node);
-	options_node = prom_searchsiblings(options_node,"options");
+	dp = of_find_node_by_path("/");
+	dp = dp->child;
+	while (dp) {
+		if (!strcmp(dp->name, "options"))
+			break;
+		dp = dp->sibling;
+	}
+	options_node = dp;
 
-	if (options_node == 0 || options_node == -1) {
-		printk(KERN_ERR "openprom: unable to find options node\n");
+	if (!options_node) {
 		misc_deregister(&openprom_dev);
 		return -EIO;
 	}
@@ -666,4 +746,3 @@ static void __exit openprom_cleanup(void)
 
 module_init(openprom_init);
 module_exit(openprom_cleanup);
-MODULE_LICENSE("GPL");

commit de8d28b16f5614aeb12bb69c8f9a38578b8d3ada
Author: David S. Miller <davem@sunset.davemloft.net>
Date:   Thu Jun 22 16:18:54 2006 -0700

    [SPARC64]: Convert sparc64 PCI layer to in-kernel device tree.
    
    One thing this change pointed out was that we really should
    pull the "get 'local-mac-address' property" logic into a helper
    function all the network drivers can call.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/sbus/char/openprom.c b/drivers/sbus/char/openprom.c
index 239e108b8ed1..cf5b476b5496 100644
--- a/drivers/sbus/char/openprom.c
+++ b/drivers/sbus/char/openprom.c
@@ -243,8 +243,8 @@ static int openprom_sunos_ioctl(struct inode * inode, struct file * file,
 					      ((int *) opp->oprom_array)[1]);
 
 			pcp = pdev->sysdata;
-			if (pcp != NULL && pcp->prom_node != -1 && pcp->prom_node) {
-				node = pcp->prom_node;
+			if (pcp != NULL) {
+				node = pcp->prom_node->node;
 				data->current_node = node;
 				*((int *)opp->oprom_array) = node;
 				opp->oprom_size = sizeof(int);

commit 586152560ae8df2a9babf1a8b667d7a145cb8208
Author: Martin Habets <errandir_news@mph.eclipse.co.uk>
Date:   Fri May 12 12:53:59 2006 -0700

    [SPARC]: Fix warning on prom_getproperty in openprom.c
    
    Signed-off-by: Martin Habets <errandir_news@mph.eclipse.co.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/sbus/char/openprom.c b/drivers/sbus/char/openprom.c
index 383a95f34a0d..239e108b8ed1 100644
--- a/drivers/sbus/char/openprom.c
+++ b/drivers/sbus/char/openprom.c
@@ -392,13 +392,16 @@ static int openprom_bsd_ioctl(struct inode * inode, struct file * file,
 			return -ENOMEM;
 		}
 
-		prom_getproperty(op.op_nodeid, str, tmp, len);
-
-		tmp[len] = '\0';
+		cnt = prom_getproperty(op.op_nodeid, str, tmp, len);
+		if (cnt <= 0) {
+			error = -EINVAL;
+		} else {
+			tmp[len] = '\0';
 
-		if (__copy_to_user(argp, &op, sizeof(op)) != 0
-		    || copy_to_user(op.op_buf, tmp, len) != 0)
-			error = -EFAULT;
+			if (__copy_to_user(argp, &op, sizeof(op)) != 0 ||
+			    copy_to_user(op.op_buf, tmp, len) != 0)
+				error = -EFAULT;
+		}
 
 		kfree(tmp);
 		kfree(str);

commit d5a858bc148fe97996af9cf685cc124b70519adf
Author: David S. Miller <davem@sunset.davemloft.net>
Date:   Tue Nov 8 10:00:13 2005 -0800

    [SPARC]: Missing compat_ioctl hookup in openprom driver.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/sbus/char/openprom.c b/drivers/sbus/char/openprom.c
index 5028ac214326..383a95f34a0d 100644
--- a/drivers/sbus/char/openprom.c
+++ b/drivers/sbus/char/openprom.c
@@ -596,6 +596,8 @@ static long openprom_compat_ioctl(struct file *file, unsigned int cmd,
 		lock_kernel();
 		break;
 	}
+
+	return rval;
 }
 
 static int openprom_open(struct inode * inode, struct file * file)
@@ -623,6 +625,7 @@ static struct file_operations openprom_fops = {
 	.owner =	THIS_MODULE,
 	.llseek =	no_llseek,
 	.ioctl =	openprom_ioctl,
+	.compat_ioctl =	openprom_compat_ioctl,
 	.open =		openprom_open,
 	.release =	openprom_release,
 };

commit b31023fc24e5c39d246e9c6fc75dba1a2902c1d6
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Nov 7 14:12:47 2005 -0800

    [SPARC] openprom: implement ->compat_ioctl
    
    implement a compat_ioctl handle in the driver instead of having table
    entries in sparc64 ioctl32.c (I plan to get rid of the arch ioctl32.c
    file eventually)
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/sbus/char/openprom.c b/drivers/sbus/char/openprom.c
index 58ed33749571..5028ac214326 100644
--- a/drivers/sbus/char/openprom.c
+++ b/drivers/sbus/char/openprom.c
@@ -39,6 +39,7 @@
 #include <linux/slab.h>
 #include <linux/string.h>
 #include <linux/miscdevice.h>
+#include <linux/smp_lock.h>
 #include <linux/init.h>
 #include <linux/fs.h>
 #include <asm/oplib.h>
@@ -565,6 +566,38 @@ static int openprom_ioctl(struct inode * inode, struct file * file,
 	}
 }
 
+static long openprom_compat_ioctl(struct file *file, unsigned int cmd,
+		unsigned long arg)
+{
+	long rval = -ENOTTY;
+
+	/*
+	 * SunOS/Solaris only, the NetBSD one's have embedded pointers in
+	 * the arg which we'd need to clean up...
+	 */
+	switch (cmd) {
+	case OPROMGETOPT:
+	case OPROMSETOPT:
+	case OPROMNXTOPT:
+	case OPROMSETOPT2:
+	case OPROMNEXT:
+	case OPROMCHILD:
+	case OPROMGETPROP:
+	case OPROMNXTPROP:
+	case OPROMU2P:
+	case OPROMGETCONS:
+	case OPROMGETFBNAME:
+	case OPROMGETBOOTARGS:
+	case OPROMSETCUR:
+	case OPROMPCI2NODE:
+	case OPROMPATH2NODE:
+		lock_kernel();
+		rval = openprom_ioctl(file->f_dentry->d_inode, file, cmd, arg);
+		lock_kernel();
+		break;
+	}
+}
+
 static int openprom_open(struct inode * inode, struct file * file)
 {
 	DATA *data;

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/sbus/char/openprom.c b/drivers/sbus/char/openprom.c
new file mode 100644
index 000000000000..58ed33749571
--- /dev/null
+++ b/drivers/sbus/char/openprom.c
@@ -0,0 +1,630 @@
+/*
+ * Linux/SPARC PROM Configuration Driver
+ * Copyright (C) 1996 Thomas K. Dyas (tdyas@noc.rutgers.edu)
+ * Copyright (C) 1996 Eddie C. Dost  (ecd@skynet.be)
+ *
+ * This character device driver allows user programs to access the
+ * PROM device tree. It is compatible with the SunOS /dev/openprom
+ * driver and the NetBSD /dev/openprom driver. The SunOS eeprom
+ * utility works without any modifications.
+ *
+ * The driver uses a minor number under the misc device major. The
+ * file read/write mode determines the type of access to the PROM.
+ * Interrupts are disabled whenever the driver calls into the PROM for
+ * sanity's sake.
+ */
+
+/* This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. 
+ */
+
+#define PROMLIB_INTERNAL
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/miscdevice.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <asm/oplib.h>
+#include <asm/system.h>
+#include <asm/uaccess.h>
+#include <asm/openpromio.h>
+#ifdef CONFIG_PCI
+#include <linux/pci.h>
+#include <asm/pbm.h>
+#endif
+
+/* Private data kept by the driver for each descriptor. */
+typedef struct openprom_private_data
+{
+	int current_node;	/* Current node for SunOS ioctls. */
+	int lastnode;		/* Last valid node used by BSD ioctls. */
+} DATA;
+
+/* ID of the PROM node containing all of the EEPROM options. */
+static int options_node = 0;
+
+/*
+ * Copy an openpromio structure into kernel space from user space.
+ * This routine does error checking to make sure that all memory
+ * accesses are within bounds. A pointer to the allocated openpromio
+ * structure will be placed in "*opp_p". Return value is the length
+ * of the user supplied buffer.
+ */
+static int copyin(struct openpromio __user *info, struct openpromio **opp_p)
+{
+	unsigned int bufsize;
+
+	if (!info || !opp_p)
+		return -EFAULT;
+
+	if (get_user(bufsize, &info->oprom_size))
+		return -EFAULT;
+
+	if (bufsize == 0)
+		return -EINVAL;
+
+	/* If the bufsize is too large, just limit it.
+	 * Fix from Jason Rappleye.
+	 */
+	if (bufsize > OPROMMAXPARAM)
+		bufsize = OPROMMAXPARAM;
+
+	if (!(*opp_p = kmalloc(sizeof(int) + bufsize + 1, GFP_KERNEL)))
+		return -ENOMEM;
+	memset(*opp_p, 0, sizeof(int) + bufsize + 1);
+
+	if (copy_from_user(&(*opp_p)->oprom_array,
+			   &info->oprom_array, bufsize)) {
+		kfree(*opp_p);
+		return -EFAULT;
+	}
+	return bufsize;
+}
+
+static int getstrings(struct openpromio __user *info, struct openpromio **opp_p)
+{
+	int n, bufsize;
+	char c;
+
+	if (!info || !opp_p)
+		return -EFAULT;
+
+	if (!(*opp_p = kmalloc(sizeof(int) + OPROMMAXPARAM + 1, GFP_KERNEL)))
+		return -ENOMEM;
+
+	memset(*opp_p, 0, sizeof(int) + OPROMMAXPARAM + 1);
+	(*opp_p)->oprom_size = 0;
+
+	n = bufsize = 0;
+	while ((n < 2) && (bufsize < OPROMMAXPARAM)) {
+		if (get_user(c, &info->oprom_array[bufsize])) {
+			kfree(*opp_p);
+			return -EFAULT;
+		}
+		if (c == '\0')
+			n++;
+		(*opp_p)->oprom_array[bufsize++] = c;
+	}
+	if (!n) {
+		kfree(*opp_p);
+		return -EINVAL;
+	}
+	return bufsize;
+}
+
+/*
+ * Copy an openpromio structure in kernel space back to user space.
+ */
+static int copyout(void __user *info, struct openpromio *opp, int len)
+{
+	if (copy_to_user(info, opp, len))
+		return -EFAULT;
+	return 0;
+}
+
+/*
+ *	SunOS and Solaris /dev/openprom ioctl calls.
+ */
+static int openprom_sunos_ioctl(struct inode * inode, struct file * file,
+				unsigned int cmd, unsigned long arg, int node)
+{
+	DATA *data = (DATA *) file->private_data;
+	char buffer[OPROMMAXPARAM+1], *buf;
+	struct openpromio *opp;
+	int bufsize, len, error = 0;
+	static int cnt;
+	void __user *argp = (void __user *)arg;
+
+	if (cmd == OPROMSETOPT)
+		bufsize = getstrings(argp, &opp);
+	else
+		bufsize = copyin(argp, &opp);
+
+	if (bufsize < 0)
+		return bufsize;
+
+	switch (cmd) {
+	case OPROMGETOPT:
+	case OPROMGETPROP:
+		len = prom_getproplen(node, opp->oprom_array);
+
+		if (len <= 0 || len > bufsize) {
+			error = copyout(argp, opp, sizeof(int));
+			break;
+		}
+
+		len = prom_getproperty(node, opp->oprom_array, buffer, bufsize);
+
+		memcpy(opp->oprom_array, buffer, len);
+		opp->oprom_array[len] = '\0';
+		opp->oprom_size = len;
+
+		error = copyout(argp, opp, sizeof(int) + bufsize);
+		break;
+
+	case OPROMNXTOPT:
+	case OPROMNXTPROP:
+		buf = prom_nextprop(node, opp->oprom_array, buffer);
+
+		len = strlen(buf);
+		if (len == 0 || len + 1 > bufsize) {
+			error = copyout(argp, opp, sizeof(int));
+			break;
+		}
+
+		memcpy(opp->oprom_array, buf, len);
+		opp->oprom_array[len] = '\0';
+		opp->oprom_size = ++len;
+
+		error = copyout(argp, opp, sizeof(int) + bufsize);
+		break;
+
+	case OPROMSETOPT:
+	case OPROMSETOPT2:
+		buf = opp->oprom_array + strlen(opp->oprom_array) + 1;
+		len = opp->oprom_array + bufsize - buf;
+
+		error = prom_setprop(options_node, opp->oprom_array,
+				     buf, len);
+
+		if (error < 0)
+			error = -EINVAL;
+		break;
+
+	case OPROMNEXT:
+	case OPROMCHILD:
+	case OPROMSETCUR:
+		if (bufsize < sizeof(int)) {
+			error = -EINVAL;
+			break;
+		}
+
+		node = *((int *) opp->oprom_array);
+
+		switch (cmd) {
+		case OPROMNEXT: node = __prom_getsibling(node); break;
+		case OPROMCHILD: node = __prom_getchild(node); break;
+		case OPROMSETCUR: break;
+		}
+
+		data->current_node = node;
+		*((int *)opp->oprom_array) = node;
+		opp->oprom_size = sizeof(int);
+
+		error = copyout(argp, opp, bufsize + sizeof(int));
+		break;
+
+	case OPROMPCI2NODE:
+		error = -EINVAL;
+
+		if (bufsize >= 2*sizeof(int)) {
+#ifdef CONFIG_PCI
+			struct pci_dev *pdev;
+			struct pcidev_cookie *pcp;
+			pdev = pci_find_slot (((int *) opp->oprom_array)[0],
+					      ((int *) opp->oprom_array)[1]);
+
+			pcp = pdev->sysdata;
+			if (pcp != NULL && pcp->prom_node != -1 && pcp->prom_node) {
+				node = pcp->prom_node;
+				data->current_node = node;
+				*((int *)opp->oprom_array) = node;
+				opp->oprom_size = sizeof(int);
+				error = copyout(argp, opp, bufsize + sizeof(int));
+			}
+#endif
+		}
+		break;
+
+	case OPROMPATH2NODE:
+		node = prom_finddevice(opp->oprom_array);
+		data->current_node = node;
+		*((int *)opp->oprom_array) = node;
+		opp->oprom_size = sizeof(int);
+
+		error = copyout(argp, opp, bufsize + sizeof(int));
+		break;
+
+	case OPROMGETBOOTARGS:
+		buf = saved_command_line;
+
+		len = strlen(buf);
+
+		if (len > bufsize) {
+			error = -EINVAL;
+			break;
+		}
+
+		strcpy(opp->oprom_array, buf);
+		opp->oprom_size = len;
+
+		error = copyout(argp, opp, bufsize + sizeof(int));
+		break;
+
+	case OPROMU2P:
+	case OPROMGETCONS:
+	case OPROMGETFBNAME:
+		if (cnt++ < 10)
+			printk(KERN_INFO "openprom_sunos_ioctl: unimplemented ioctl\n");
+		error = -EINVAL;
+		break;
+	default:
+		if (cnt++ < 10)
+			printk(KERN_INFO "openprom_sunos_ioctl: cmd 0x%X, arg 0x%lX\n", cmd, arg);
+		error = -EINVAL;
+		break;
+	}
+
+	kfree(opp);
+	return error;
+}
+
+
+/* Return nonzero if a specific node is in the PROM device tree. */
+static int intree(int root, int node)
+{
+	for (; root != 0; root = prom_getsibling(root))
+		if (root == node || intree(prom_getchild(root),node))
+			return 1;
+	return 0;
+}
+
+/* Return nonzero if a specific node is "valid". */
+static int goodnode(int n, DATA *data)
+{
+	if (n == data->lastnode || n == prom_root_node || n == options_node)
+		return 1;
+	if (n == 0 || n == -1 || !intree(prom_root_node,n))
+		return 0;
+	data->lastnode = n;
+	return 1;
+}
+
+/* Copy in a whole string from userspace into kernelspace. */
+static int copyin_string(char __user *user, size_t len, char **ptr)
+{
+	char *tmp;
+
+	if ((ssize_t)len < 0 || (ssize_t)(len + 1) < 0)
+		return -EINVAL;
+
+	tmp = kmalloc(len + 1, GFP_KERNEL);
+	if (!tmp)
+		return -ENOMEM;
+
+	if(copy_from_user(tmp, user, len)) {
+		kfree(tmp);
+		return -EFAULT;
+	}
+
+	tmp[len] = '\0';
+
+	*ptr = tmp;
+
+	return 0;
+}
+
+/*
+ *	NetBSD /dev/openprom ioctl calls.
+ */
+static int openprom_bsd_ioctl(struct inode * inode, struct file * file,
+			      unsigned int cmd, unsigned long arg)
+{
+	DATA *data = (DATA *) file->private_data;
+	void __user *argp = (void __user *)arg;
+	struct opiocdesc op;
+	int error, node, len;
+	char *str, *tmp;
+	char buffer[64];
+	static int cnt;
+
+	switch (cmd) {
+	case OPIOCGET:
+		if (copy_from_user(&op, argp, sizeof(op)))
+			return -EFAULT;
+
+		if (!goodnode(op.op_nodeid,data))
+			return -EINVAL;
+
+		error = copyin_string(op.op_name, op.op_namelen, &str);
+		if (error)
+			return error;
+
+		len = prom_getproplen(op.op_nodeid,str);
+
+		if (len > op.op_buflen) {
+			kfree(str);
+			return -ENOMEM;
+		}
+
+		op.op_buflen = len;
+
+		if (len <= 0) {
+			kfree(str);
+			/* Verified by the above copy_from_user */
+			if (__copy_to_user(argp, &op,
+				       sizeof(op)))
+				return -EFAULT;
+			return 0;
+		}
+
+		tmp = kmalloc(len + 1, GFP_KERNEL);
+		if (!tmp) {
+			kfree(str);
+			return -ENOMEM;
+		}
+
+		prom_getproperty(op.op_nodeid, str, tmp, len);
+
+		tmp[len] = '\0';
+
+		if (__copy_to_user(argp, &op, sizeof(op)) != 0
+		    || copy_to_user(op.op_buf, tmp, len) != 0)
+			error = -EFAULT;
+
+		kfree(tmp);
+		kfree(str);
+
+		return error;
+
+	case OPIOCNEXTPROP:
+		if (copy_from_user(&op, argp, sizeof(op)))
+			return -EFAULT;
+
+		if (!goodnode(op.op_nodeid,data))
+			return -EINVAL;
+
+		error = copyin_string(op.op_name, op.op_namelen, &str);
+		if (error)
+			return error;
+
+		tmp = prom_nextprop(op.op_nodeid,str,buffer);
+
+		if (tmp) {
+			len = strlen(tmp);
+			if (len > op.op_buflen)
+				len = op.op_buflen;
+			else
+				op.op_buflen = len;
+		} else {
+			len = op.op_buflen = 0;
+		}
+
+		if (!access_ok(VERIFY_WRITE, argp, sizeof(op))) {
+			kfree(str);
+			return -EFAULT;
+		}
+
+		if (!access_ok(VERIFY_WRITE, op.op_buf, len)) {
+			kfree(str);
+			return -EFAULT;
+		}
+
+		error = __copy_to_user(argp, &op, sizeof(op));
+		if (!error) error = __copy_to_user(op.op_buf, tmp, len);
+
+		kfree(str);
+
+		return error;
+
+	case OPIOCSET:
+		if (copy_from_user(&op, argp, sizeof(op)))
+			return -EFAULT;
+
+		if (!goodnode(op.op_nodeid,data))
+			return -EINVAL;
+
+		error = copyin_string(op.op_name, op.op_namelen, &str);
+		if (error)
+			return error;
+
+		error = copyin_string(op.op_buf, op.op_buflen, &tmp);
+		if (error) {
+			kfree(str);
+			return error;
+		}
+
+		len = prom_setprop(op.op_nodeid,str,tmp,op.op_buflen+1);
+
+		if (len != op.op_buflen)
+			return -EINVAL;
+
+		kfree(str);
+		kfree(tmp);
+
+		return 0;
+
+	case OPIOCGETOPTNODE:
+		if (copy_to_user(argp, &options_node, sizeof(int)))
+			return -EFAULT;
+		return 0;
+
+	case OPIOCGETNEXT:
+	case OPIOCGETCHILD:
+		if (copy_from_user(&node, argp, sizeof(int)))
+			return -EFAULT;
+
+		if (cmd == OPIOCGETNEXT)
+			node = __prom_getsibling(node);
+		else
+			node = __prom_getchild(node);
+
+		if (__copy_to_user(argp, &node, sizeof(int)))
+			return -EFAULT;
+
+		return 0;
+
+	default:
+		if (cnt++ < 10)
+			printk(KERN_INFO "openprom_bsd_ioctl: cmd 0x%X\n", cmd);
+		return -EINVAL;
+
+	}
+}
+
+
+/*
+ *	Handoff control to the correct ioctl handler.
+ */
+static int openprom_ioctl(struct inode * inode, struct file * file,
+			  unsigned int cmd, unsigned long arg)
+{
+	DATA *data = (DATA *) file->private_data;
+	static int cnt;
+
+	switch (cmd) {
+	case OPROMGETOPT:
+	case OPROMNXTOPT:
+		if ((file->f_mode & FMODE_READ) == 0)
+			return -EPERM;
+		return openprom_sunos_ioctl(inode, file, cmd, arg,
+					    options_node);
+
+	case OPROMSETOPT:
+	case OPROMSETOPT2:
+		if ((file->f_mode & FMODE_WRITE) == 0)
+			return -EPERM;
+		return openprom_sunos_ioctl(inode, file, cmd, arg,
+					    options_node);
+
+	case OPROMNEXT:
+	case OPROMCHILD:
+	case OPROMGETPROP:
+	case OPROMNXTPROP:
+		if ((file->f_mode & FMODE_READ) == 0)
+			return -EPERM;
+		return openprom_sunos_ioctl(inode, file, cmd, arg,
+					    data->current_node);
+
+	case OPROMU2P:
+	case OPROMGETCONS:
+	case OPROMGETFBNAME:
+	case OPROMGETBOOTARGS:
+	case OPROMSETCUR:
+	case OPROMPCI2NODE:
+	case OPROMPATH2NODE:
+		if ((file->f_mode & FMODE_READ) == 0)
+			return -EPERM;
+		return openprom_sunos_ioctl(inode, file, cmd, arg, 0);
+
+	case OPIOCGET:
+	case OPIOCNEXTPROP:
+	case OPIOCGETOPTNODE:
+	case OPIOCGETNEXT:
+	case OPIOCGETCHILD:
+		if ((file->f_mode & FMODE_READ) == 0)
+			return -EBADF;
+		return openprom_bsd_ioctl(inode,file,cmd,arg);
+
+	case OPIOCSET:
+		if ((file->f_mode & FMODE_WRITE) == 0)
+			return -EBADF;
+		return openprom_bsd_ioctl(inode,file,cmd,arg);
+
+	default:
+		if (cnt++ < 10)
+			printk("openprom_ioctl: cmd 0x%X, arg 0x%lX\n", cmd, arg);
+		return -EINVAL;
+	}
+}
+
+static int openprom_open(struct inode * inode, struct file * file)
+{
+	DATA *data;
+
+	data = (DATA *) kmalloc(sizeof(DATA), GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	data->current_node = prom_root_node;
+	data->lastnode = prom_root_node;
+	file->private_data = (void *)data;
+
+	return 0;
+}
+
+static int openprom_release(struct inode * inode, struct file * file)
+{
+	kfree(file->private_data);
+	return 0;
+}
+
+static struct file_operations openprom_fops = {
+	.owner =	THIS_MODULE,
+	.llseek =	no_llseek,
+	.ioctl =	openprom_ioctl,
+	.open =		openprom_open,
+	.release =	openprom_release,
+};
+
+static struct miscdevice openprom_dev = {
+	SUN_OPENPROM_MINOR, "openprom", &openprom_fops
+};
+
+static int __init openprom_init(void)
+{
+	int error;
+
+	error = misc_register(&openprom_dev);
+	if (error) {
+		printk(KERN_ERR "openprom: unable to get misc minor\n");
+		return error;
+	}
+
+	options_node = prom_getchild(prom_root_node);
+	options_node = prom_searchsiblings(options_node,"options");
+
+	if (options_node == 0 || options_node == -1) {
+		printk(KERN_ERR "openprom: unable to find options node\n");
+		misc_deregister(&openprom_dev);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static void __exit openprom_cleanup(void)
+{
+	misc_deregister(&openprom_dev);
+}
+
+module_init(openprom_init);
+module_exit(openprom_cleanup);
+MODULE_LICENSE("GPL");
