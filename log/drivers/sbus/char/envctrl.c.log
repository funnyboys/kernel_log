commit 6ce6ae7c178b95f83ca0e15bd2ac961425a3af5c
Author: Zhenzhong Duan <zhenzhong.duan@gmail.com>
Date:   Wed Mar 11 15:16:53 2020 +0800

    misc: cleanup minor number definitions in c file into miscdevice.h
    
    HWRNG_MINOR and RNG_MISCDEV_MINOR are duplicate definitions, use
    unified HWRNG_MINOR instead and moved into miscdevice.h
    
    ANSLCD_MINOR and LCD_MINOR are duplicate definitions, use unified
    LCD_MINOR instead and moved into miscdevice.h
    
    MISCDEV_MINOR is renamed to PXA3XX_GCU_MINOR and moved into
    miscdevice.h
    
    Other definitions are just moved without any change.
    
    Link: https://lore.kernel.org/lkml/20200120221323.GJ15860@mit.edu/t/
    Suggested-by: Arnd Bergmann <arnd@arndb.de>
    Build-tested-by: Willy TARREAU <wtarreau@haproxy.com>
    Build-tested-by: Miguel Ojeda <miguel.ojeda.sandonis@gmail.com>
    Signed-off-by: Zhenzhong Duan <zhenzhong.duan@gmail.com>
    Acked-by: Miguel Ojeda <miguel.ojeda.sandonis@gmail.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Herbert Xu <herbert@gondor.apana.org.au>
    Link: https://lore.kernel.org/r/20200311071654.335-2-zhenzhong.duan@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/sbus/char/envctrl.c b/drivers/sbus/char/envctrl.c
index 12d66aa61ede..843e830b5f87 100644
--- a/drivers/sbus/char/envctrl.c
+++ b/drivers/sbus/char/envctrl.c
@@ -37,8 +37,6 @@
 #define DRIVER_NAME	"envctrl"
 #define PFX		DRIVER_NAME ": "
 
-#define ENVCTRL_MINOR	162
-
 #define PCF8584_ADDRESS	0x55
 
 #define CONTROL_PIN	0x80

commit 1832f2d8ff69138aa70d3cb3b4ea3c2058e73aea
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Sep 11 21:59:08 2018 +0200

    compat_ioctl: move more drivers to compat_ptr_ioctl
    
    The .ioctl and .compat_ioctl file operations have the same prototype so
    they can both point to the same function, which works great almost all
    the time when all the commands are compatible.
    
    One exception is the s390 architecture, where a compat pointer is only
    31 bit wide, and converting it into a 64-bit pointer requires calling
    compat_ptr(). Most drivers here will never run in s390, but since we now
    have a generic helper for it, it's easy enough to use it consistently.
    
    I double-checked all these drivers to ensure that all ioctl arguments
    are used as pointers or are ignored, but are not interpreted as integer
    values.
    
    Acked-by: Jason Gunthorpe <jgg@mellanox.com>
    Acked-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Acked-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: David Sterba <dsterba@suse.com>
    Acked-by: Darren Hart (VMware) <dvhart@infradead.org>
    Acked-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
    Acked-by: Bjorn Andersson <bjorn.andersson@linaro.org>
    Acked-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/drivers/sbus/char/envctrl.c b/drivers/sbus/char/envctrl.c
index a63d5e402ff2..12d66aa61ede 100644
--- a/drivers/sbus/char/envctrl.c
+++ b/drivers/sbus/char/envctrl.c
@@ -715,9 +715,7 @@ static const struct file_operations envctrl_fops = {
 	.owner =		THIS_MODULE,
 	.read =			envctrl_read,
 	.unlocked_ioctl =	envctrl_ioctl,
-#ifdef CONFIG_COMPAT
-	.compat_ioctl =		envctrl_ioctl,
-#endif
+	.compat_ioctl =		compat_ptr_ioctl,
 	.open =			envctrl_open,
 	.release =		envctrl_release,
 	.llseek =		noop_llseek,

commit 09c434b8a0047c69e48499de0107de312901e798
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 13:08:20 2019 +0100

    treewide: Add SPDX license identifier for more missed files
    
    Add SPDX license identifiers to all files which:
    
     - Have no license information of any form
    
     - Have MODULE_LICENCE("GPL*") inside which was used in the initial
       scan/conversion to ignore the file
    
    These files fall under the project license, GPL v2 only. The resulting SPDX
    license identifier is:
    
      GPL-2.0-only
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/sbus/char/envctrl.c b/drivers/sbus/char/envctrl.c
index 1a6e7224017c..a63d5e402ff2 100644
--- a/drivers/sbus/char/envctrl.c
+++ b/drivers/sbus/char/envctrl.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /* envctrl.c: Temperature and Fan monitoring on Machines providing it.
  *
  * Copyright (C) 1998  Eddie C. Dost  (ecd@skynet.be)

commit c2f1f3e0e17d94ab0c66d83e669492cb9e9a3698
Merge: 9830afca9273 c23b8e7acea3
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Dec 26 10:32:18 2018 -0800

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/sparc-next
    
    Pull sparc updates from David Miller:
    
     - Automatic system call table generation, from Firoz Khan.
    
     - Clean up accesses to the OF device names by using full_name instead
       of path_component_name.
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/davem/sparc-next:
      ALSA: sparc: Use of_node_name_eq for node name comparisons
      sbus: Use of_node_name_eq for node name comparisons
      sparc: generate uapi header and system call table files
      sparc: add system call table generation support
      sparc: add __NR_syscalls along with NR_syscalls
      sparc: move __IGNORE* entries to non uapi header
      sparc: Use DT node full_name instead of name for resources
      sparc: Remove unused leon_trans_init
      sparc: Use device_type helpers to access the node type
      sparc: Use of_node_name_eq for node name comparisons
      sparc: Convert to using %pOFn instead of device_node.name
      sparc: prom: use property "name" directly to construct node names
      of: Drop full path from full_name for PDT systems
      sparc: Convert to using %pOF instead of full_name
      fs/openpromfs: Use of_node_name_eq for node name comparisons
      fs/openpromfs: use full_name instead of path_component_name

commit 91abe6b2237f4ff92aec250c7e79765376f17b0b
Author: Rob Herring <robh@kernel.org>
Date:   Wed Dec 5 13:50:38 2018 -0600

    sbus: Use of_node_name_eq for node name comparisons
    
    Convert string compares of DT node names to use of_node_name_eq helper
    instead. This removes direct access to the node name pointer.
    
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: sparclinux@vger.kernel.org
    Signed-off-by: Rob Herring <robh@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/sbus/char/envctrl.c b/drivers/sbus/char/envctrl.c
index 56e962a01493..08b7d25c1136 100644
--- a/drivers/sbus/char/envctrl.c
+++ b/drivers/sbus/char/envctrl.c
@@ -906,7 +906,7 @@ static void envctrl_init_i2c_child(struct device_node *dp,
 		int len;
 
 		root_node = of_find_node_by_path("/");
-		if (!strcmp(root_node->name, "SUNW,UltraSPARC-IIi-cEngine")) {
+		if (of_node_name_eq(root_node, "SUNW,UltraSPARC-IIi-cEngine")) {
 			for (len = 0; len < PCF8584_MAX_CHANNELS; ++len) {
 				pchild->mon_type[len] = ENVCTRL_NOMON;
 			}
@@ -1037,10 +1037,10 @@ static int envctrl_probe(struct platform_device *op)
 	index = 0;
 	dp = op->dev.of_node->child;
 	while (dp) {
-		if (!strcmp(dp->name, "gpio")) {
+		if (of_node_name_eq(dp, "gpio")) {
 			i2c_childlist[index].i2ctype = I2C_GPIO;
 			envctrl_init_i2c_child(dp, &(i2c_childlist[index++]));
-		} else if (!strcmp(dp->name, "adc")) {
+		} else if (of_node_name_eq(dp, "adc")) {
 			i2c_childlist[index].i2ctype = I2C_ADC;
 			envctrl_init_i2c_child(dp, &(i2c_childlist[index++]));
 		}

commit 6bd520ab7cf69486ea81fd3cdfd2d5a390ad1100
Author: Yangtao Li <tiny.windzz@gmail.com>
Date:   Tue Nov 20 08:38:26 2018 -0500

    drivers/sbus/char: add of_node_put()
    
    use of_node_put() to release the refcount.
    
    Signed-off-by: Yangtao Li <tiny.windzz@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/sbus/char/envctrl.c b/drivers/sbus/char/envctrl.c
index 56e962a01493..b8481927bfe4 100644
--- a/drivers/sbus/char/envctrl.c
+++ b/drivers/sbus/char/envctrl.c
@@ -910,8 +910,10 @@ static void envctrl_init_i2c_child(struct device_node *dp,
 			for (len = 0; len < PCF8584_MAX_CHANNELS; ++len) {
 				pchild->mon_type[len] = ENVCTRL_NOMON;
 			}
+			of_node_put(root_node);
 			return;
 		}
+		of_node_put(root_node);
 	}
 
 	/* Get the monitor channels. */

commit 7c0f6ba682b9c7632072ffbedf8d328c8f3c42ba
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Dec 24 11:46:01 2016 -0800

    Replace <asm/uaccess.h> with <linux/uaccess.h> globally
    
    This was entirely automated, using the script by Al:
    
      PATT='^[[:blank:]]*#[[:blank:]]*include[[:blank:]]*<asm/uaccess.h>'
      sed -i -e "s!$PATT!#include <linux/uaccess.h>!" \
            $(git grep -l "$PATT"|grep -v ^include/linux/uaccess.h)
    
    to do the replacement at the end of the merge window.
    
    Requested-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/sbus/char/envctrl.c b/drivers/sbus/char/envctrl.c
index 5609b602c54d..56e962a01493 100644
--- a/drivers/sbus/char/envctrl.c
+++ b/drivers/sbus/char/envctrl.c
@@ -29,7 +29,7 @@
 #include <linux/of.h>
 #include <linux/of_device.h>
 
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
 #include <asm/envctrl.h>
 #include <asm/io.h>
 

commit 7975a9b7323d5a47e5b651bac810f3271e7156df
Author: Joel Stanley <joel@jms.id.au>
Date:   Wed Apr 15 16:16:50 2015 -0700

    drivers/sbus/char/envctrl.c: ignore orderly_poweroff return value
    
    orderly_poweroff() unconditionally returns 0, so remove the dead code that
    checks the return value.
    
    A future patch will change the return type to void.
    
    Signed-off-by: Joel Stanley <joel@jms.id.au>
    Acked-by: David S. Miller <davem@davemloft.net>
    Cc: Fabian Frederick <fabf@skynet.be>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Cc: Jeremy Kerr <jk@ozlabs.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/sbus/char/envctrl.c b/drivers/sbus/char/envctrl.c
index e244cf3d9ec8..5609b602c54d 100644
--- a/drivers/sbus/char/envctrl.c
+++ b/drivers/sbus/char/envctrl.c
@@ -970,18 +970,13 @@ static struct i2c_child_t *envctrl_get_i2c_child(unsigned char mon_type)
 static void envctrl_do_shutdown(void)
 {
 	static int inprog = 0;
-	int ret;
 
 	if (inprog != 0)
 		return;
 
 	inprog = 1;
 	printk(KERN_CRIT "kenvctrld: WARNING: Shutting down the system now.\n");
-	ret = orderly_poweroff(true);
-	if (ret < 0) {
-		printk(KERN_CRIT "kenvctrld: WARNING: system shutdown failed!\n"); 
-		inprog = 0;  /* unlikely to succeed, but we could try again */
-	}
+	orderly_poweroff(true);
 }
 
 static struct task_struct *kenvctrld_task;

commit 7cafb31ca4e85fa4c522cecf917e86e258cfbcaa
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Mon Oct 20 16:21:32 2014 +0200

    sbus: char: drop owner assignment from platform_drivers
    
    A platform_driver does not need to set an owner, it will be populated by the
    driver core.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/sbus/char/envctrl.c b/drivers/sbus/char/envctrl.c
index af15a2fdab5e..e244cf3d9ec8 100644
--- a/drivers/sbus/char/envctrl.c
+++ b/drivers/sbus/char/envctrl.c
@@ -1130,7 +1130,6 @@ MODULE_DEVICE_TABLE(of, envctrl_match);
 static struct platform_driver envctrl_driver = {
 	.driver = {
 		.name = DRIVER_NAME,
-		.owner = THIS_MODULE,
 		.of_match_table = envctrl_match,
 	},
 	.probe		= envctrl_probe,

commit 8b2abcbc5ef1c135b03c7009f98350dbad2fe293
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Mon Jan 6 15:25:39 2014 -0500

    sparc: delete non-required instances of include <linux/init.h>
    
    None of these files are actually using any __init type directives
    and hence don't need to include <linux/init.h>.  Most are just a
    left over from __devinit and __cpuinit removal, or simply due to
    code getting copied from one driver to the next.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/sbus/char/envctrl.c b/drivers/sbus/char/envctrl.c
index ddbe5a9e713d..af15a2fdab5e 100644
--- a/drivers/sbus/char/envctrl.c
+++ b/drivers/sbus/char/envctrl.c
@@ -19,7 +19,6 @@
  */
 
 #include <linux/module.h>
-#include <linux/init.h>
 #include <linux/kthread.h>
 #include <linux/delay.h>
 #include <linux/ioport.h>

commit 082a2004db27e16ee9a5b1234e6ab219ea29d693
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Dec 21 13:24:23 2012 -0800

    Drivers: sbus: remove __dev* attributes.
    
    CONFIG_HOTPLUG is going away as an option.  As a result, the __dev*
    markings need to be removed.
    
    This change removes the use of __devinit, __devexit_p, and __devexit
    from these drivers.
    
    Based on patches originally written by Bill Pemberton, but redone by me
    in order to handle some of the coding style issues better, by hand.
    
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Peter Senna Tschudin <peter.senna@gmail.com>
    Cc: David Howells <dhowells@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/sbus/char/envctrl.c b/drivers/sbus/char/envctrl.c
index 0bc18569f9c0..ddbe5a9e713d 100644
--- a/drivers/sbus/char/envctrl.c
+++ b/drivers/sbus/char/envctrl.c
@@ -1028,7 +1028,7 @@ static int kenvctrld(void *__unused)
 	return 0;
 }
 
-static int __devinit envctrl_probe(struct platform_device *op)
+static int envctrl_probe(struct platform_device *op)
 {
 	struct device_node *dp;
 	int index, err;
@@ -1104,7 +1104,7 @@ static int __devinit envctrl_probe(struct platform_device *op)
 	return err;
 }
 
-static int __devexit envctrl_remove(struct platform_device *op)
+static int envctrl_remove(struct platform_device *op)
 {
 	int index;
 
@@ -1135,7 +1135,7 @@ static struct platform_driver envctrl_driver = {
 		.of_match_table = envctrl_match,
 	},
 	.probe		= envctrl_probe,
-	.remove		= __devexit_p(envctrl_remove),
+	.remove		= envctrl_remove,
 };
 
 module_platform_driver(envctrl_driver);

commit da201161662b8ee9c8d7bd8cc50ce3cb3366d400
Author: Peter Senna Tschudin <peter.senna@gmail.com>
Date:   Wed Sep 12 07:03:12 2012 +0000

    drivers/sbus/char: removes unnecessary semicolon
    
    removes unnecessary semicolon
    
    Found by Coccinelle: http://coccinelle.lip6.fr/
    
    Signed-off-by: Peter Senna Tschudin <peter.senna@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/sbus/char/envctrl.c b/drivers/sbus/char/envctrl.c
index 339fd6f65eda..0bc18569f9c0 100644
--- a/drivers/sbus/char/envctrl.c
+++ b/drivers/sbus/char/envctrl.c
@@ -353,7 +353,7 @@ static int envctrl_i2c_data_translate(unsigned char data, int translate_type,
 
 	default:
 		break;
-	};
+	}
 
 	return len;
 }
@@ -644,7 +644,7 @@ envctrl_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)
 	default:
 		break;
 
-	};
+	}
 
 	return ret;
 }
@@ -687,7 +687,7 @@ envctrl_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 
 	default:
 		return -EINVAL;
-	};
+	}
 
 	return 0;
 }
@@ -947,7 +947,7 @@ static void envctrl_init_i2c_child(struct device_node *dp,
 
 		default:
 			break;
-		};
+		}
 	}
 }
 

commit dbf2b92d54e73e4a2524b90d29bd498ecc4aa593
Author: Axel Lin <axel.lin@gmail.com>
Date:   Sat Nov 26 19:04:25 2011 +0000

    sbus: convert drivers/sbus/char/* to use module_platform_driver()
    
    This patch converts the drivers in drivers/sbus/char/* to use the
    module_platform_driver() macro which makes the code smaller and a bit
    simpler.
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/sbus/char/envctrl.c b/drivers/sbus/char/envctrl.c
index be7b4e56154f..339fd6f65eda 100644
--- a/drivers/sbus/char/envctrl.c
+++ b/drivers/sbus/char/envctrl.c
@@ -1138,16 +1138,6 @@ static struct platform_driver envctrl_driver = {
 	.remove		= __devexit_p(envctrl_remove),
 };
 
-static int __init envctrl_init(void)
-{
-	return platform_driver_register(&envctrl_driver);
-}
-
-static void __exit envctrl_exit(void)
-{
-	platform_driver_unregister(&envctrl_driver);
-}
+module_platform_driver(envctrl_driver);
 
-module_init(envctrl_init);
-module_exit(envctrl_exit);
 MODULE_LICENSE("GPL");

commit 4ebb24f707187196937607c60810d42f7112d7aa
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Tue Feb 22 20:01:33 2011 -0700

    dt/sparc: Eliminate users of of_platform_{,un}register_driver
    
    Get rid of old users of of_platform_driver in arch/sparc.  Most
    of_platform_driver users can be converted to use the platform_bus
    directly.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/sbus/char/envctrl.c b/drivers/sbus/char/envctrl.c
index 8ce414e39489..be7b4e56154f 100644
--- a/drivers/sbus/char/envctrl.c
+++ b/drivers/sbus/char/envctrl.c
@@ -1028,8 +1028,7 @@ static int kenvctrld(void *__unused)
 	return 0;
 }
 
-static int __devinit envctrl_probe(struct platform_device *op,
-				   const struct of_device_id *match)
+static int __devinit envctrl_probe(struct platform_device *op)
 {
 	struct device_node *dp;
 	int index, err;
@@ -1129,7 +1128,7 @@ static const struct of_device_id envctrl_match[] = {
 };
 MODULE_DEVICE_TABLE(of, envctrl_match);
 
-static struct of_platform_driver envctrl_driver = {
+static struct platform_driver envctrl_driver = {
 	.driver = {
 		.name = DRIVER_NAME,
 		.owner = THIS_MODULE,
@@ -1141,12 +1140,12 @@ static struct of_platform_driver envctrl_driver = {
 
 static int __init envctrl_init(void)
 {
-	return of_register_platform_driver(&envctrl_driver);
+	return platform_driver_register(&envctrl_driver);
 }
 
 static void __exit envctrl_exit(void)
 {
-	of_unregister_platform_driver(&envctrl_driver);
+	platform_driver_unregister(&envctrl_driver);
 }
 
 module_init(envctrl_init);

commit 6038f373a3dc1f1c26496e60b6c40b164716f07e
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Sun Aug 15 18:52:59 2010 +0200

    llseek: automatically add .llseek fop
    
    All file_operations should get a .llseek operation so we can make
    nonseekable_open the default for future file operations without a
    .llseek pointer.
    
    The three cases that we can automatically detect are no_llseek, seq_lseek
    and default_llseek. For cases where we can we can automatically prove that
    the file offset is always ignored, we use noop_llseek, which maintains
    the current behavior of not returning an error from a seek.
    
    New drivers should normally not use noop_llseek but instead use no_llseek
    and call nonseekable_open at open time.  Existing drivers can be converted
    to do the same when the maintainer knows for certain that no user code
    relies on calling seek on the device file.
    
    The generated code is often incorrectly indented and right now contains
    comments that clarify for each added line why a specific variant was
    chosen. In the version that gets submitted upstream, the comments will
    be gone and I will manually fix the indentation, because there does not
    seem to be a way to do that using coccinelle.
    
    Some amount of new code is currently sitting in linux-next that should get
    the same modifications, which I will do at the end of the merge window.
    
    Many thanks to Julia Lawall for helping me learn to write a semantic
    patch that does all this.
    
    ===== begin semantic patch =====
    // This adds an llseek= method to all file operations,
    // as a preparation for making no_llseek the default.
    //
    // The rules are
    // - use no_llseek explicitly if we do nonseekable_open
    // - use seq_lseek for sequential files
    // - use default_llseek if we know we access f_pos
    // - use noop_llseek if we know we don't access f_pos,
    //   but we still want to allow users to call lseek
    //
    @ open1 exists @
    identifier nested_open;
    @@
    nested_open(...)
    {
    <+...
    nonseekable_open(...)
    ...+>
    }
    
    @ open exists@
    identifier open_f;
    identifier i, f;
    identifier open1.nested_open;
    @@
    int open_f(struct inode *i, struct file *f)
    {
    <+...
    (
    nonseekable_open(...)
    |
    nested_open(...)
    )
    ...+>
    }
    
    @ read disable optional_qualifier exists @
    identifier read_f;
    identifier f, p, s, off;
    type ssize_t, size_t, loff_t;
    expression E;
    identifier func;
    @@
    ssize_t read_f(struct file *f, char *p, size_t s, loff_t *off)
    {
    <+...
    (
       *off = E
    |
       *off += E
    |
       func(..., off, ...)
    |
       E = *off
    )
    ...+>
    }
    
    @ read_no_fpos disable optional_qualifier exists @
    identifier read_f;
    identifier f, p, s, off;
    type ssize_t, size_t, loff_t;
    @@
    ssize_t read_f(struct file *f, char *p, size_t s, loff_t *off)
    {
    ... when != off
    }
    
    @ write @
    identifier write_f;
    identifier f, p, s, off;
    type ssize_t, size_t, loff_t;
    expression E;
    identifier func;
    @@
    ssize_t write_f(struct file *f, const char *p, size_t s, loff_t *off)
    {
    <+...
    (
      *off = E
    |
      *off += E
    |
      func(..., off, ...)
    |
      E = *off
    )
    ...+>
    }
    
    @ write_no_fpos @
    identifier write_f;
    identifier f, p, s, off;
    type ssize_t, size_t, loff_t;
    @@
    ssize_t write_f(struct file *f, const char *p, size_t s, loff_t *off)
    {
    ... when != off
    }
    
    @ fops0 @
    identifier fops;
    @@
    struct file_operations fops = {
     ...
    };
    
    @ has_llseek depends on fops0 @
    identifier fops0.fops;
    identifier llseek_f;
    @@
    struct file_operations fops = {
    ...
     .llseek = llseek_f,
    ...
    };
    
    @ has_read depends on fops0 @
    identifier fops0.fops;
    identifier read_f;
    @@
    struct file_operations fops = {
    ...
     .read = read_f,
    ...
    };
    
    @ has_write depends on fops0 @
    identifier fops0.fops;
    identifier write_f;
    @@
    struct file_operations fops = {
    ...
     .write = write_f,
    ...
    };
    
    @ has_open depends on fops0 @
    identifier fops0.fops;
    identifier open_f;
    @@
    struct file_operations fops = {
    ...
     .open = open_f,
    ...
    };
    
    // use no_llseek if we call nonseekable_open
    ////////////////////////////////////////////
    @ nonseekable1 depends on !has_llseek && has_open @
    identifier fops0.fops;
    identifier nso ~= "nonseekable_open";
    @@
    struct file_operations fops = {
    ...  .open = nso, ...
    +.llseek = no_llseek, /* nonseekable */
    };
    
    @ nonseekable2 depends on !has_llseek @
    identifier fops0.fops;
    identifier open.open_f;
    @@
    struct file_operations fops = {
    ...  .open = open_f, ...
    +.llseek = no_llseek, /* open uses nonseekable */
    };
    
    // use seq_lseek for sequential files
    /////////////////////////////////////
    @ seq depends on !has_llseek @
    identifier fops0.fops;
    identifier sr ~= "seq_read";
    @@
    struct file_operations fops = {
    ...  .read = sr, ...
    +.llseek = seq_lseek, /* we have seq_read */
    };
    
    // use default_llseek if there is a readdir
    ///////////////////////////////////////////
    @ fops1 depends on !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier readdir_e;
    @@
    // any other fop is used that changes pos
    struct file_operations fops = {
    ... .readdir = readdir_e, ...
    +.llseek = default_llseek, /* readdir is present */
    };
    
    // use default_llseek if at least one of read/write touches f_pos
    /////////////////////////////////////////////////////////////////
    @ fops2 depends on !fops1 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier read.read_f;
    @@
    // read fops use offset
    struct file_operations fops = {
    ... .read = read_f, ...
    +.llseek = default_llseek, /* read accesses f_pos */
    };
    
    @ fops3 depends on !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier write.write_f;
    @@
    // write fops use offset
    struct file_operations fops = {
    ... .write = write_f, ...
    +       .llseek = default_llseek, /* write accesses f_pos */
    };
    
    // Use noop_llseek if neither read nor write accesses f_pos
    ///////////////////////////////////////////////////////////
    
    @ fops4 depends on !fops1 && !fops2 && !fops3 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier read_no_fpos.read_f;
    identifier write_no_fpos.write_f;
    @@
    // write fops use offset
    struct file_operations fops = {
    ...
     .write = write_f,
     .read = read_f,
    ...
    +.llseek = noop_llseek, /* read and write both use no f_pos */
    };
    
    @ depends on has_write && !has_read && !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier write_no_fpos.write_f;
    @@
    struct file_operations fops = {
    ... .write = write_f, ...
    +.llseek = noop_llseek, /* write uses no f_pos */
    };
    
    @ depends on has_read && !has_write && !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier read_no_fpos.read_f;
    @@
    struct file_operations fops = {
    ... .read = read_f, ...
    +.llseek = noop_llseek, /* read uses no f_pos */
    };
    
    @ depends on !has_read && !has_write && !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    @@
    struct file_operations fops = {
    ...
    +.llseek = noop_llseek, /* no read or write fn */
    };
    ===== End semantic patch =====
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Cc: Julia Lawall <julia@diku.dk>
    Cc: Christoph Hellwig <hch@infradead.org>

diff --git a/drivers/sbus/char/envctrl.c b/drivers/sbus/char/envctrl.c
index 078e5f4520ef..8ce414e39489 100644
--- a/drivers/sbus/char/envctrl.c
+++ b/drivers/sbus/char/envctrl.c
@@ -720,6 +720,7 @@ static const struct file_operations envctrl_fops = {
 #endif
 	.open =			envctrl_open,
 	.release =		envctrl_release,
+	.llseek =		noop_llseek,
 };	
 
 static struct miscdevice envctrl_dev = {

commit 2dc11581376829303b98eadb2de253bee065a56a
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Fri Aug 6 09:25:50 2010 -0600

    of/device: Replace struct of_device with struct platform_device
    
    of_device is just an alias for platform_device, so remove it entirely.  Also
    replace to_of_device() with to_platform_device() and update comment blocks.
    
    This patch was initially generated from the following semantic patch, and then
    edited by hand to pick up the bits that coccinelle didn't catch.
    
    @@
    @@
    -struct of_device
    +struct platform_device
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Reviewed-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/sbus/char/envctrl.c b/drivers/sbus/char/envctrl.c
index 3c27f45e2b6d..078e5f4520ef 100644
--- a/drivers/sbus/char/envctrl.c
+++ b/drivers/sbus/char/envctrl.c
@@ -1027,7 +1027,7 @@ static int kenvctrld(void *__unused)
 	return 0;
 }
 
-static int __devinit envctrl_probe(struct of_device *op,
+static int __devinit envctrl_probe(struct platform_device *op,
 				   const struct of_device_id *match)
 {
 	struct device_node *dp;
@@ -1104,7 +1104,7 @@ static int __devinit envctrl_probe(struct of_device *op,
 	return err;
 }
 
-static int __devexit envctrl_remove(struct of_device *op)
+static int __devexit envctrl_remove(struct platform_device *op)
 {
 	int index;
 

commit 03c0c29aff7e56b722eb6c47eace222b140d0377
Merge: c60c6a96b7bb 7fb8f881c54b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Aug 5 15:57:35 2010 -0700

    Merge branch 'next-devicetree' of git://git.secretlab.ca/git/linux-2.6
    
    * 'next-devicetree' of git://git.secretlab.ca/git/linux-2.6: (63 commits)
      of/platform: Register of_platform_drivers with an "of:" prefix
      of/address: Clean up function declarations
      of/spi: call of_register_spi_devices() from spi core code
      of: Provide default of_node_to_nid() implementation.
      of/device: Make of_device_make_bus_id() usable by other code.
      of/irq: Fix endian issues in parsing interrupt specifiers
      of: Fix phandle endian issues
      of/flattree: fix of_flat_dt_is_compatible() to match the full compatible string
      of: remove of_default_bus_ids
      of: make of_find_device_by_node generic
      microblaze: remove references to of_device and to_of_device
      sparc: remove references to of_device and to_of_device
      powerpc: remove references to of_device and to_of_device
      of/device: Replace of_device with platform_device in includes and core code
      of/device: Protect against binding of_platform_drivers to non-OF devices
      of: remove asm/of_device.h
      of: remove asm/of_platform.h
      of/platform: remove all of_bus_type and of_platform_bus_type references
      of: Merge of_platform_bus_type with platform_bus_type
      drivercore/of: Add OF style matching to platform bus
      ...
    
    Fix up trivial conflicts in arch/microblaze/kernel/Makefile due to just
    some obj-y removals by the devicetree branch, while the microblaze
    updates added a new file.

commit 1ab1d63a85cee2545272f63a7644e9f855cb65d0
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Thu Jun 24 15:14:37 2010 -0600

    of/platform: remove all of_bus_type and of_platform_bus_type references
    
    Both of_bus_type and of_platform_bus_type are just #define aliases
    for the platform bus.  This patch removes all references to them and
    switches to the of_register_platform_driver()/of_unregister_platform_driver()
    API for registering.
    
    Subsequent patches will convert each user of of_register_platform_driver()
    into plain platform_drivers without the of_platform_driver shim.  At which
    point the of_register_platform_driver()/of_unregister_platform_driver()
    functions can be removed.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Acked-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/sbus/char/envctrl.c b/drivers/sbus/char/envctrl.c
index c8166ecf5276..2c76f700265b 100644
--- a/drivers/sbus/char/envctrl.c
+++ b/drivers/sbus/char/envctrl.c
@@ -1142,12 +1142,12 @@ static struct of_platform_driver envctrl_driver = {
 
 static int __init envctrl_init(void)
 {
-	return of_register_driver(&envctrl_driver, &of_bus_type);
+	return of_register_platform_driver(&envctrl_driver);
 }
 
 static void __exit envctrl_exit(void)
 {
-	of_unregister_driver(&envctrl_driver);
+	of_unregister_platform_driver(&envctrl_driver);
 }
 
 module_init(envctrl_init);

commit a3108ca2323dec0f6321c3f7706cdaed51f694ea
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Jul 20 23:36:39 2010 -0700

    sbus: autoconvert trivial BKL users to private mutex
    
    All these files use the big kernel lock in a trivial
    way to serialize their private file operations,
    typically resulting from an earlier semi-automatic
    pushdown from VFS.
    
    None of these drivers appears to want to lock against
    other code, and they all use the BKL as the top-level
    lock in their file operations, meaning that there
    is no lock-order inversion problem.
    
    Consequently, we can remove the BKL completely,
    replacing it with a per-file mutex in every case.
    Using a scripted approach means we can avoid
    typos.
    
    file=$1
    name=$2
    if grep -q lock_kernel ${file} ; then
        if grep -q 'include.*linux.mutex.h' ${file} ; then
                sed -i '/include.*<linux\/smp_lock.h>/d' ${file}
        else
                sed -i 's/include.*<linux\/smp_lock.h>.*$/include <linux\/mutex.h>/g' ${file}
        fi
        sed -i ${file} \
            -e "/^#include.*linux.mutex.h/,$ {
                    1,/^\(static\|int\|long\)/ {
                         /^\(static\|int\|long\)/istatic DEFINE_MUTEX(${name}_mutex);
    
    } }"  \
        -e "s/\(un\)*lock_kernel\>[ ]*()/mutex_\1lock(\&${name}_mutex)/g" \
        -e '/[      ]*cycle_kernel_lock();/d'
    else
        sed -i -e '/include.*\<smp_lock.h\>/d' ${file}  \
                    -e '/cycle_kernel_lock()/d'
    fi
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/sbus/char/envctrl.c b/drivers/sbus/char/envctrl.c
index c8166ecf5276..bd0bbc621351 100644
--- a/drivers/sbus/char/envctrl.c
+++ b/drivers/sbus/char/envctrl.c
@@ -27,7 +27,6 @@
 #include <linux/kmod.h>
 #include <linux/reboot.h>
 #include <linux/slab.h>
-#include <linux/smp_lock.h>
 #include <linux/of.h>
 #include <linux/of_device.h>
 
@@ -699,7 +698,6 @@ envctrl_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 static int
 envctrl_open(struct inode *inode, struct file *file)
 {
-	cycle_kernel_lock();
 	file->private_data = NULL;
 	return 0;
 }

commit 4018294b53d1dae026880e45f174c1cc63b5d435
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Tue Apr 13 16:13:02 2010 -0700

    of: Remove duplicate fields from of_platform_driver
    
    .name, .match_table and .owner are duplicated in both of_platform_driver
    and device_driver.  This patch is a removes the extra copies from struct
    of_platform_driver and converts all users to the device_driver members.
    
    This patch is a pretty mechanical change.  The usage model doesn't change
    and if any drivers have been missed, or if anything has been fixed up
    incorrectly, then it will fail with a compile time error, and the fixup
    will be trivial.  This patch looks big and scary because it touches so
    many files, but it should be pretty safe.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Acked-by: Sean MacLennan <smaclennan@pikatech.com>

diff --git a/drivers/sbus/char/envctrl.c b/drivers/sbus/char/envctrl.c
index a5fe20faf4f7..c8166ecf5276 100644
--- a/drivers/sbus/char/envctrl.c
+++ b/drivers/sbus/char/envctrl.c
@@ -1131,8 +1131,11 @@ static const struct of_device_id envctrl_match[] = {
 MODULE_DEVICE_TABLE(of, envctrl_match);
 
 static struct of_platform_driver envctrl_driver = {
-	.name		= DRIVER_NAME,
-	.match_table	= envctrl_match,
+	.driver = {
+		.name = DRIVER_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = envctrl_match,
+	},
 	.probe		= envctrl_probe,
 	.remove		= __devexit_p(envctrl_remove),
 };

commit 61c7a080a5a061c976988fd4b844dfb468dda255
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Tue Apr 13 16:12:29 2010 -0700

    of: Always use 'struct device.of_node' to get device node pointer.
    
    The following structure elements duplicate the information in
    'struct device.of_node' and so are being eliminated.  This patch
    makes all readers of these elements use device.of_node instead.
    
    (struct of_device *)->node
    (struct dev_archdata *)->prom_node (sparc)
    (struct dev_archdata *)->of_node (powerpc & microblaze)
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/sbus/char/envctrl.c b/drivers/sbus/char/envctrl.c
index c6e2eff19409..a5fe20faf4f7 100644
--- a/drivers/sbus/char/envctrl.c
+++ b/drivers/sbus/char/envctrl.c
@@ -1043,7 +1043,7 @@ static int __devinit envctrl_probe(struct of_device *op,
 		return -ENOMEM;
 
 	index = 0;
-	dp = op->node->child;
+	dp = op->dev.of_node->child;
 	while (dp) {
 		if (!strcmp(dp->name, "gpio")) {
 			i2c_childlist[index].i2ctype = I2C_GPIO;

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/sbus/char/envctrl.c b/drivers/sbus/char/envctrl.c
index aa2b60a868ba..c6e2eff19409 100644
--- a/drivers/sbus/char/envctrl.c
+++ b/drivers/sbus/char/envctrl.c
@@ -26,6 +26,7 @@
 #include <linux/miscdevice.h>
 #include <linux/kmod.h>
 #include <linux/reboot.h>
+#include <linux/slab.h>
 #include <linux/smp_lock.h>
 #include <linux/of.h>
 #include <linux/of_device.h>

commit af901ca181d92aac3a7dc265144a9081a86d8f39
Author: André Goddard Rosa <andre.goddard@gmail.com>
Date:   Sat Nov 14 13:09:05 2009 -0200

    tree-wide: fix assorted typos all over the place
    
    That is "success", "unknown", "through", "performance", "[re|un]mapping"
    , "access", "default", "reasonable", "[con]currently", "temperature"
    , "channel", "[un]used", "application", "example","hierarchy", "therefore"
    , "[over|under]flow", "contiguous", "threshold", "enough" and others.
    
    Signed-off-by: André Goddard Rosa <andre.goddard@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/sbus/char/envctrl.c b/drivers/sbus/char/envctrl.c
index 58e583b61e60..aa2b60a868ba 100644
--- a/drivers/sbus/char/envctrl.c
+++ b/drivers/sbus/char/envctrl.c
@@ -92,11 +92,11 @@
 #define ENVCTRL_CPUTEMP_MON			1    /* cpu temperature monitor */
 #define ENVCTRL_CPUVOLTAGE_MON	  	2    /* voltage monitor         */
 #define ENVCTRL_FANSTAT_MON  		3    /* fan status monitor      */
-#define ENVCTRL_ETHERTEMP_MON		4    /* ethernet temperarture */
+#define ENVCTRL_ETHERTEMP_MON		4    /* ethernet temperature */
 					     /* monitor                     */
 #define ENVCTRL_VOLTAGESTAT_MON	  	5    /* voltage status monitor  */
 #define ENVCTRL_MTHRBDTEMP_MON		6    /* motherboard temperature */
-#define ENVCTRL_SCSITEMP_MON		7    /* scsi temperarture */
+#define ENVCTRL_SCSITEMP_MON		7    /* scsi temperature */
 #define ENVCTRL_GLOBALADDR_MON		8    /* global address */
 
 /* Child device type.

commit fd098316ef533e8441576f020ead4beab93154ce
Author: David S. Miller <davem@davemloft.net>
Date:   Sun Aug 31 01:23:17 2008 -0700

    sparc: Annotate of_device_id arrays with const or __initdata.
    
    As suggested by Stephen Rothwell.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/sbus/char/envctrl.c b/drivers/sbus/char/envctrl.c
index ea8c35cbffd3..58e583b61e60 100644
--- a/drivers/sbus/char/envctrl.c
+++ b/drivers/sbus/char/envctrl.c
@@ -1120,7 +1120,7 @@ static int __devexit envctrl_remove(struct of_device *op)
 	return 0;
 }
 
-static struct of_device_id envctrl_match[] = {
+static const struct of_device_id envctrl_match[] = {
 	{
 		.name = "i2c",
 		.compatible = "i2cpcf,8584",

commit 6b8c90f24e24505f97efaef1a46572d6b45929b9
Author: David S. Miller <davem@davemloft.net>
Date:   Fri Aug 29 21:05:15 2008 -0700

    envctrl: Convert to pure OF driver.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/sbus/char/envctrl.c b/drivers/sbus/char/envctrl.c
index a408402426f8..ea8c35cbffd3 100644
--- a/drivers/sbus/char/envctrl.c
+++ b/drivers/sbus/char/envctrl.c
@@ -1,5 +1,4 @@
-/* $Id: envctrl.c,v 1.25 2002/01/15 09:01:26 davem Exp $
- * envctrl.c: Temperature and Fan monitoring on Machines providing it.
+/* envctrl.c: Temperature and Fan monitoring on Machines providing it.
  *
  * Copyright (C) 1998  Eddie C. Dost  (ecd@skynet.be)
  * Copyright (C) 2000  Vinh Truong    (vinh.truong@eng.sun.com)
@@ -28,12 +27,16 @@
 #include <linux/kmod.h>
 #include <linux/reboot.h>
 #include <linux/smp_lock.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
 
-#include <asm/ebus.h>
 #include <asm/uaccess.h>
 #include <asm/envctrl.h>
 #include <asm/io.h>
 
+#define DRIVER_NAME	"envctrl"
+#define PFX		DRIVER_NAME ": "
+
 #define ENVCTRL_MINOR	162
 
 #define PCF8584_ADDRESS	0x55
@@ -193,7 +196,7 @@ static void envtrl_i2c_test_pin(void)
 	} 
 
 	if (limit <= 0)
-		printk(KERN_INFO "envctrl: Pin status will not clear.\n");
+		printk(KERN_INFO PFX "Pin status will not clear.\n");
 }
 
 /* Function Description: Test busy bit.
@@ -211,7 +214,7 @@ static void envctrl_i2c_test_bb(void)
 	} 
 
 	if (limit <= 0)
-		printk(KERN_INFO "envctrl: Busy bit will not clear.\n");
+		printk(KERN_INFO PFX "Busy bit will not clear.\n");
 }
 
 /* Function Description: Send the address for a read access.
@@ -858,11 +861,10 @@ static void envctrl_init_voltage_status(struct i2c_child_t *pchild)
 /* Function Description: Initialize i2c child device.
  * Return: None.
  */
-static void envctrl_init_i2c_child(struct linux_ebus_child *edev_child,
+static void envctrl_init_i2c_child(struct device_node *dp,
 				   struct i2c_child_t *pchild)
 {
 	int len, i, tbls_size = 0;
-	struct device_node *dp = edev_child->prom_node;
 	const void *pval;
 
 	/* Get device address. */
@@ -882,12 +884,12 @@ static void envctrl_init_i2c_child(struct linux_ebus_child *edev_child,
 
                 pchild->tables = kmalloc(tbls_size, GFP_KERNEL);
 		if (pchild->tables == NULL){
-			printk("envctrl: Failed to allocate table.\n");
+			printk(KERN_ERR PFX "Failed to allocate table.\n");
 			return;
 		}
 		pval = of_get_property(dp, "tables", &len);
                 if (!pval || len <= 0) {
-			printk("envctrl: Failed to get table.\n");
+			printk(KERN_ERR PFX "Failed to get table.\n");
 			return;
 		}
 		memcpy(pchild->tables, pval, len);
@@ -993,14 +995,14 @@ static int kenvctrld(void *__unused)
 	struct i2c_child_t *cputemp;
 
 	if (NULL == (cputemp = envctrl_get_i2c_child(ENVCTRL_CPUTEMP_MON))) {
-		printk(KERN_ERR 
-		       "envctrl: kenvctrld unable to monitor CPU temp-- exiting\n");
+		printk(KERN_ERR  PFX
+		       "kenvctrld unable to monitor CPU temp-- exiting\n");
 		return -ENODEV;
 	}
 
 	poll_interval = 5000; /* TODO env_mon_interval */
 
-	printk(KERN_INFO "envctrl: %s starting...\n", current->comm);
+	printk(KERN_INFO PFX "%s starting...\n", current->comm);
 	for (;;) {
 		msleep_interruptible(poll_interval);
 
@@ -1022,54 +1024,35 @@ static int kenvctrld(void *__unused)
 			}
 		}
 	}
-	printk(KERN_INFO "envctrl: %s exiting...\n", current->comm);
+	printk(KERN_INFO PFX "%s exiting...\n", current->comm);
 	return 0;
 }
 
-static int __init envctrl_init(void)
+static int __devinit envctrl_probe(struct of_device *op,
+				   const struct of_device_id *match)
 {
-	struct linux_ebus *ebus = NULL;
-	struct linux_ebus_device *edev = NULL;
-	struct linux_ebus_child *edev_child = NULL;
-	int err, i = 0;
-
-	for_each_ebus(ebus) {
-		for_each_ebusdev(edev, ebus) {
-			if (!strcmp(edev->prom_node->name, "bbc")) {
-				/* If we find a boot-bus controller node,
-				 * then this envctrl driver is not for us.
-				 */
-				return -ENODEV;
-			}
-		}
-	}
+	struct device_node *dp;
+	int index, err;
 
-	/* Traverse through ebus and ebus device list for i2c device and
-	 * adc and gpio nodes.
-	 */
-	for_each_ebus(ebus) {
-		for_each_ebusdev(edev, ebus) {
-			if (!strcmp(edev->prom_node->name, "i2c")) {
-				i2c = ioremap(edev->resource[0].start, 0x2);
-				for_each_edevchild(edev, edev_child) {
-					if (!strcmp("gpio", edev_child->prom_node->name)) {
-						i2c_childlist[i].i2ctype = I2C_GPIO;
-						envctrl_init_i2c_child(edev_child, &(i2c_childlist[i++]));
-					}
-					if (!strcmp("adc", edev_child->prom_node->name)) {
-						i2c_childlist[i].i2ctype = I2C_ADC;
-						envctrl_init_i2c_child(edev_child, &(i2c_childlist[i++]));
-					}
-				}
-				goto done;
-			}
+	if (i2c)
+		return -EINVAL;
+
+	i2c = of_ioremap(&op->resource[0], 0, 0x2, DRIVER_NAME);
+	if (!i2c)
+		return -ENOMEM;
+
+	index = 0;
+	dp = op->node->child;
+	while (dp) {
+		if (!strcmp(dp->name, "gpio")) {
+			i2c_childlist[index].i2ctype = I2C_GPIO;
+			envctrl_init_i2c_child(dp, &(i2c_childlist[index++]));
+		} else if (!strcmp(dp->name, "adc")) {
+			i2c_childlist[index].i2ctype = I2C_ADC;
+			envctrl_init_i2c_child(dp, &(i2c_childlist[index++]));
 		}
-	}
 
-done:
-	if (!edev) {
-		printk("envctrl: I2C device not found.\n");
-		return -ENODEV;
+		dp = dp->sibling;
 	}
 
 	/* Set device address. */
@@ -1087,7 +1070,7 @@ static int __init envctrl_init(void)
 	/* Register the device as a minor miscellaneous device. */
 	err = misc_register(&envctrl_dev);
 	if (err) {
-		printk("envctrl: Unable to get misc minor %d\n",
+		printk(KERN_ERR PFX "Unable to get misc minor %d\n",
 		       envctrl_dev.minor);
 		goto out_iounmap;
 	}
@@ -1096,12 +1079,12 @@ static int __init envctrl_init(void)
 	 * a next child device, so we decrement before reverse-traversal of
 	 * child devices.
 	 */
-	printk("envctrl: initialized ");
-	for (--i; i >= 0; --i) {
+	printk(KERN_INFO PFX "Initialized ");
+	for (--index; index >= 0; --index) {
 		printk("[%s 0x%lx]%s", 
-			(I2C_ADC == i2c_childlist[i].i2ctype) ? ("adc") : 
-			((I2C_GPIO == i2c_childlist[i].i2ctype) ? ("gpio") : ("unknown")), 
-			i2c_childlist[i].addr, (0 == i) ? ("\n") : (" "));
+			(I2C_ADC == i2c_childlist[index].i2ctype) ? "adc" : 
+			((I2C_GPIO == i2c_childlist[index].i2ctype) ? "gpio" : "unknown"), 
+			i2c_childlist[index].addr, (0 == index) ? "\n" : " ");
 	}
 
 	kenvctrld_task = kthread_run(kenvctrld, NULL, "kenvctrld");
@@ -1115,26 +1098,54 @@ static int __init envctrl_init(void)
 out_deregister:
 	misc_deregister(&envctrl_dev);
 out_iounmap:
-	iounmap(i2c);
-	for (i = 0; i < ENVCTRL_MAX_CPU * 2; i++)
-		kfree(i2c_childlist[i].tables);
+	of_iounmap(&op->resource[0], i2c, 0x2);
+	for (index = 0; index < ENVCTRL_MAX_CPU * 2; index++)
+		kfree(i2c_childlist[index].tables);
 
 	return err;
 }
 
-static void __exit envctrl_cleanup(void)
+static int __devexit envctrl_remove(struct of_device *op)
 {
-	int i;
+	int index;
 
 	kthread_stop(kenvctrld_task);
 
-	iounmap(i2c);
+	of_iounmap(&op->resource[0], i2c, 0x2);
 	misc_deregister(&envctrl_dev);
 
-	for (i = 0; i < ENVCTRL_MAX_CPU * 2; i++)
-		kfree(i2c_childlist[i].tables);
+	for (index = 0; index < ENVCTRL_MAX_CPU * 2; index++)
+		kfree(i2c_childlist[index].tables);
+
+	return 0;
+}
+
+static struct of_device_id envctrl_match[] = {
+	{
+		.name = "i2c",
+		.compatible = "i2cpcf,8584",
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, envctrl_match);
+
+static struct of_platform_driver envctrl_driver = {
+	.name		= DRIVER_NAME,
+	.match_table	= envctrl_match,
+	.probe		= envctrl_probe,
+	.remove		= __devexit_p(envctrl_remove),
+};
+
+static int __init envctrl_init(void)
+{
+	return of_register_driver(&envctrl_driver, &of_bus_type);
+}
+
+static void __exit envctrl_exit(void)
+{
+	of_unregister_driver(&envctrl_driver);
 }
 
 module_init(envctrl_init);
-module_exit(envctrl_cleanup);
+module_exit(envctrl_exit);
 MODULE_LICENSE("GPL");

commit 1d17bf0c08569e7aefd27df0179065fb955588c4
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue May 20 19:15:53 2008 +0200

    envctrl: BKL pushdown
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/drivers/sbus/char/envctrl.c b/drivers/sbus/char/envctrl.c
index dadabef116b6..a408402426f8 100644
--- a/drivers/sbus/char/envctrl.c
+++ b/drivers/sbus/char/envctrl.c
@@ -27,6 +27,7 @@
 #include <linux/miscdevice.h>
 #include <linux/kmod.h>
 #include <linux/reboot.h>
+#include <linux/smp_lock.h>
 
 #include <asm/ebus.h>
 #include <asm/uaccess.h>
@@ -694,6 +695,7 @@ envctrl_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 static int
 envctrl_open(struct inode *inode, struct file *file)
 {
+	cycle_kernel_lock();
 	file->private_data = NULL;
 	return 0;
 }

commit 10a0a8d4e3f6bf2d077f94344441909abe670f5a
Author: Jeremy Fitzhardinge <jeremy@xensource.com>
Date:   Tue Jul 17 18:37:02 2007 -0700

    Add common orderly_poweroff()
    
    Various pieces of code around the kernel want to be able to trigger an
    orderly poweroff.  This pulls them together into a single
    implementation.
    
    By default the poweroff command is /sbin/poweroff, but it can be set
    via sysctl: kernel/poweroff_cmd.  This is split at whitespace, so it
    can include command-line arguments.
    
    This patch replaces four other instances of invoking either "poweroff"
    or "shutdown -h now": two sbus drivers, and acpi thermal
    management.
    
    sparc64 has its own "powerd"; still need to determine whether it should
    be replaced by orderly_poweroff().
    
    Signed-off-by: Jeremy Fitzhardinge <jeremy@xensource.com>
    Acked-by: Len Brown <lenb@kernel.org>
    Signed-off-by: Chris Wright <chrisw@sous-sol.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Randy Dunlap <randy.dunlap@oracle.com>
    Cc: Andi Kleen <ak@suse.de>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: David S. Miller <davem@davemloft.net>

diff --git a/drivers/sbus/char/envctrl.c b/drivers/sbus/char/envctrl.c
index 8328acab47fd..dadabef116b6 100644
--- a/drivers/sbus/char/envctrl.c
+++ b/drivers/sbus/char/envctrl.c
@@ -26,6 +26,7 @@
 #include <linux/ioport.h>
 #include <linux/miscdevice.h>
 #include <linux/kmod.h>
+#include <linux/reboot.h>
 
 #include <asm/ebus.h>
 #include <asm/uaccess.h>
@@ -966,10 +967,6 @@ static struct i2c_child_t *envctrl_get_i2c_child(unsigned char mon_type)
 static void envctrl_do_shutdown(void)
 {
 	static int inprog = 0;
-	static char *envp[] = {	
-		"HOME=/", "TERM=linux", "PATH=/sbin:/usr/sbin:/bin:/usr/bin", NULL };
-	char *argv[] = { 
-		"/sbin/shutdown", "-h", "now", NULL };	
 	int ret;
 
 	if (inprog != 0)
@@ -977,7 +974,7 @@ static void envctrl_do_shutdown(void)
 
 	inprog = 1;
 	printk(KERN_CRIT "kenvctrld: WARNING: Shutting down the system now.\n");
-	ret = call_usermodehelper("/sbin/shutdown", argv, envp, 0);
+	ret = orderly_poweroff(true);
 	if (ret < 0) {
 		printk(KERN_CRIT "kenvctrld: WARNING: system shutdown failed!\n"); 
 		inprog = 0;  /* unlikely to succeed, but we could try again */

commit e1a39fbb029fce40150d9163d39a68e2b76cd0b5
Author: David S. Miller <davem@sunset.davemloft.net>
Date:   Fri May 11 16:34:35 2007 -0700

    [SPARC64]: envctrl.c needs asm/io.h
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/sbus/char/envctrl.c b/drivers/sbus/char/envctrl.c
index f2be2ead8742..8328acab47fd 100644
--- a/drivers/sbus/char/envctrl.c
+++ b/drivers/sbus/char/envctrl.c
@@ -30,6 +30,7 @@
 #include <asm/ebus.h>
 #include <asm/uaccess.h>
 #include <asm/envctrl.h>
+#include <asm/io.h>
 
 #define ENVCTRL_MINOR	162
 

commit ccf0dec6fcadb4e1c877b9bafb031a6bdb7112b9
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Thu Mar 29 00:49:54 2007 -0700

    [SPARC/64] constify of_get_property return: drivers
    
    The only unfortunate bit here is that the name field of struct map_info
    is not const, so for now we put a cast on the assignment of it.
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/sbus/char/envctrl.c b/drivers/sbus/char/envctrl.c
index 2cea4f5d2084..f2be2ead8742 100644
--- a/drivers/sbus/char/envctrl.c
+++ b/drivers/sbus/char/envctrl.c
@@ -726,7 +726,7 @@ static struct miscdevice envctrl_dev = {
  * Return: None.
  */
 static void envctrl_set_mon(struct i2c_child_t *pchild,
-			    char *chnl_desc,
+			    const char *chnl_desc,
 			    int chnl_no)
 {
 	/* Firmware only has temperature type.  It does not distinguish
@@ -763,8 +763,8 @@ static void envctrl_set_mon(struct i2c_child_t *pchild,
 static void envctrl_init_adc(struct i2c_child_t *pchild, struct device_node *dp)
 {
 	int i = 0, len;
-	char *pos;
-	unsigned int *pval;
+	const char *pos;
+	const unsigned int *pval;
 
 	/* Firmware describe channels into a stream separated by a '\0'. */
 	pos = of_get_property(dp, "channels-description", &len);
@@ -859,7 +859,7 @@ static void envctrl_init_i2c_child(struct linux_ebus_child *edev_child,
 {
 	int len, i, tbls_size = 0;
 	struct device_node *dp = edev_child->prom_node;
-	void *pval;
+	const void *pval;
 
 	/* Get device address. */
 	pval = of_get_property(dp, "reg", &len);

commit 00977a59b951207d38380c75f03a36829950265c
Author: Arjan van de Ven <arjan@linux.intel.com>
Date:   Mon Feb 12 00:55:34 2007 -0800

    [PATCH] mark struct file_operations const 6
    
    Many struct file_operations in the kernel can be "const".  Marking them const
    moves these to the .rodata section, which avoids false sharing with potential
    dirty data.  In addition it'll catch accidental writes at compile time to
    these shared resources.
    
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/sbus/char/envctrl.c b/drivers/sbus/char/envctrl.c
index fff4660cdf96..2cea4f5d2084 100644
--- a/drivers/sbus/char/envctrl.c
+++ b/drivers/sbus/char/envctrl.c
@@ -705,7 +705,7 @@ envctrl_release(struct inode *inode, struct file *file)
 	return 0;
 }
 
-static struct file_operations envctrl_fops = {
+static const struct file_operations envctrl_fops = {
 	.owner =		THIS_MODULE,
 	.read =			envctrl_read,
 	.unlocked_ioctl =	envctrl_ioctl,

commit 872ec6484720e7ddfebb8e15c232fa7ca158ef2e
Author: David S. Miller <davem@sunset.davemloft.net>
Date:   Tue Oct 17 19:19:08 2006 -0700

    [SPARC] {bbc_,}envctrl: Use call_usermodehelper().
    
    We should not be calling kernel_execve() directly and this
    causes module build failures because kernel_execve() is not
    exported to modules.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/sbus/char/envctrl.c b/drivers/sbus/char/envctrl.c
index 6b6a855f3795..fff4660cdf96 100644
--- a/drivers/sbus/char/envctrl.c
+++ b/drivers/sbus/char/envctrl.c
@@ -25,7 +25,7 @@
 #include <linux/delay.h>
 #include <linux/ioport.h>
 #include <linux/miscdevice.h>
-#include <linux/syscalls.h>
+#include <linux/kmod.h>
 
 #include <asm/ebus.h>
 #include <asm/uaccess.h>
@@ -976,7 +976,7 @@ static void envctrl_do_shutdown(void)
 
 	inprog = 1;
 	printk(KERN_CRIT "kenvctrld: WARNING: Shutting down the system now.\n");
-	ret = kernel_execve("/sbin/shutdown", argv, envp);
+	ret = call_usermodehelper("/sbin/shutdown", argv, envp, 0);
 	if (ret < 0) {
 		printk(KERN_CRIT "kenvctrld: WARNING: system shutdown failed!\n"); 
 		inprog = 0;  /* unlikely to succeed, but we could try again */

commit 1baaf0b424fe611a99cf3e2e59e84df0561d679a
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Thu Oct 12 19:07:59 2006 +0100

    [PATCH] more kernel_execve() fallout (sbus)
    
    drivers/sbus/char stuff using kernel_execve() needs linux/syscalls.h
    now; includes trimmed, while we are at it.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/sbus/char/envctrl.c b/drivers/sbus/char/envctrl.c
index 728a133d0fc5..6b6a855f3795 100644
--- a/drivers/sbus/char/envctrl.c
+++ b/drivers/sbus/char/envctrl.c
@@ -20,16 +20,12 @@
  */
 
 #include <linux/module.h>
-#include <linux/sched.h>
+#include <linux/init.h>
 #include <linux/kthread.h>
-#include <linux/errno.h>
 #include <linux/delay.h>
 #include <linux/ioport.h>
-#include <linux/init.h>
 #include <linux/miscdevice.h>
-#include <linux/mm.h>
-#include <linux/slab.h>
-#include <linux/kernel.h>
+#include <linux/syscalls.h>
 
 #include <asm/ebus.h>
 #include <asm/uaccess.h>

commit 3db03b4afb3ecd66a0399b8ba57742ca953b0ecd
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Oct 2 02:18:31 2006 -0700

    [PATCH] rename the provided execve functions to kernel_execve
    
    Some architectures provide an execve function that does not set errno, but
    instead returns the result code directly.  Rename these to kernel_execve to
    get the right semantics there.  Moreover, there is no reasone for any of these
    architectures to still provide __KERNEL_SYSCALLS__ or _syscallN macros, so
    remove these right away.
    
    [akpm@osdl.org: build fix]
    [bunk@stusta.de: build fix]
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Cc: Andi Kleen <ak@muc.de>
    Acked-by: Paul Mackerras <paulus@samba.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Richard Henderson <rth@twiddle.net>
    Cc: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
    Cc: Russell King <rmk@arm.linux.org.uk>
    Cc: Ian Molton <spyro@f2s.com>
    Cc: Mikael Starvik <starvik@axis.com>
    Cc: David Howells <dhowells@redhat.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Cc: Hirokazu Takata <takata.hirokazu@renesas.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Kyle McMartin <kyle@mcmartin.ca>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Cc: Kazumoto Kojima <kkojima@rr.iij4u.or.jp>
    Cc: Richard Curnow <rc@rc0.org.uk>
    Cc: William Lee Irwin III <wli@holomorphy.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Jeff Dike <jdike@addtoit.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Cc: Miles Bader <uclinux-v850@lsi.nec.co.jp>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: "Luck, Tony" <tony.luck@intel.com>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/sbus/char/envctrl.c b/drivers/sbus/char/envctrl.c
index 063e676a3ac0..728a133d0fc5 100644
--- a/drivers/sbus/char/envctrl.c
+++ b/drivers/sbus/char/envctrl.c
@@ -19,9 +19,6 @@
  *              Daniele Bellucci <bellucda@tiscali.it>
  */
 
-#define __KERNEL_SYSCALLS__
-static int errno;
-
 #include <linux/module.h>
 #include <linux/sched.h>
 #include <linux/kthread.h>
@@ -976,13 +973,15 @@ static void envctrl_do_shutdown(void)
 		"HOME=/", "TERM=linux", "PATH=/sbin:/usr/sbin:/bin:/usr/bin", NULL };
 	char *argv[] = { 
 		"/sbin/shutdown", "-h", "now", NULL };	
+	int ret;
 
 	if (inprog != 0)
 		return;
 
 	inprog = 1;
 	printk(KERN_CRIT "kenvctrld: WARNING: Shutting down the system now.\n");
-	if (0 > execve("/sbin/shutdown", argv, envp)) {
+	ret = kernel_execve("/sbin/shutdown", argv, envp);
+	if (ret < 0) {
 		printk(KERN_CRIT "kenvctrld: WARNING: system shutdown failed!\n"); 
 		inprog = 0;  /* unlikely to succeed, but we could try again */
 	}

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jörn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jörn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/drivers/sbus/char/envctrl.c b/drivers/sbus/char/envctrl.c
index cf97e9efe9b6..063e676a3ac0 100644
--- a/drivers/sbus/char/envctrl.c
+++ b/drivers/sbus/char/envctrl.c
@@ -22,7 +22,6 @@
 #define __KERNEL_SYSCALLS__
 static int errno;
 
-#include <linux/config.h>
 #include <linux/module.h>
 #include <linux/sched.h>
 #include <linux/kthread.h>

commit 690c8fd31f1e35985d0f35772fde514da59ec9d1
Author: David S. Miller <davem@sunset.davemloft.net>
Date:   Thu Jun 22 19:12:03 2006 -0700

    [SPARC64]: Use in-kernel PROM tree for EBUS and ISA.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/sbus/char/envctrl.c b/drivers/sbus/char/envctrl.c
index 19e8eddf887a..cf97e9efe9b6 100644
--- a/drivers/sbus/char/envctrl.c
+++ b/drivers/sbus/char/envctrl.c
@@ -768,16 +768,14 @@ static void envctrl_set_mon(struct i2c_child_t *pchild,
  *                       decoding tables, monitor type, optional properties.
  * Return: None.
  */
-static void envctrl_init_adc(struct i2c_child_t *pchild, int node)
+static void envctrl_init_adc(struct i2c_child_t *pchild, struct device_node *dp)
 {
-	char chnls_desc[CHANNEL_DESC_SZ];
 	int i = 0, len;
-	char *pos = chnls_desc;
+	char *pos;
+	unsigned int *pval;
 
 	/* Firmware describe channels into a stream separated by a '\0'. */
-	len = prom_getproperty(node, "channels-description", chnls_desc,
-			       CHANNEL_DESC_SZ);
-	chnls_desc[CHANNEL_DESC_SZ - 1] = '\0';
+	pos = of_get_property(dp, "channels-description", &len);
 
 	while (len > 0) {
 		int l = strlen(pos) + 1;
@@ -787,10 +785,13 @@ static void envctrl_init_adc(struct i2c_child_t *pchild, int node)
 	}
 
 	/* Get optional properties. */
-        len = prom_getproperty(node, "warning-temp", (char *)&warning_temperature,
-			       sizeof(warning_temperature));
-        len = prom_getproperty(node, "shutdown-temp", (char *)&shutdown_temperature,
-			       sizeof(shutdown_temperature));
+	pval = of_get_property(dp, "warning-temp", NULL);
+	if (pval)
+		warning_temperature = *pval;
+
+	pval = of_get_property(dp, "shutdown-temp", NULL);
+	if (pval)
+		shutdown_temperature = *pval;
 }
 
 /* Function Description: Initialize child device monitoring fan status.
@@ -864,21 +865,18 @@ static void envctrl_init_voltage_status(struct i2c_child_t *pchild)
 static void envctrl_init_i2c_child(struct linux_ebus_child *edev_child,
 				   struct i2c_child_t *pchild)
 {
-	int node, len, i, tbls_size = 0;
-
-	node = edev_child->prom_node;
+	int len, i, tbls_size = 0;
+	struct device_node *dp = edev_child->prom_node;
+	void *pval;
 
 	/* Get device address. */
-	len = prom_getproperty(node, "reg",
-			       (char *) &(pchild->addr),
-			       sizeof(pchild->addr));
+	pval = of_get_property(dp, "reg", &len);
+	memcpy(&pchild->addr, pval, len);
 
 	/* Get tables property.  Read firmware temperature tables. */
-	len = prom_getproperty(node, "translation",
-			       (char *) pchild->tblprop_array,
-			       (PCF8584_MAX_CHANNELS *
-				sizeof(struct pcf8584_tblprop)));
-	if (len > 0) {
+	pval = of_get_property(dp, "translation", &len);
+	if (pval && len > 0) {
+		memcpy(pchild->tblprop_array, pval, len);
                 pchild->total_tbls = len / sizeof(struct pcf8584_tblprop);
 		for (i = 0; i < pchild->total_tbls; i++) {
 			if ((pchild->tblprop_array[i].size + pchild->tblprop_array[i].offset) > tbls_size) {
@@ -891,12 +889,12 @@ static void envctrl_init_i2c_child(struct linux_ebus_child *edev_child,
 			printk("envctrl: Failed to allocate table.\n");
 			return;
 		}
-                len = prom_getproperty(node, "tables",
-				       (char *) pchild->tables, tbls_size);
-                if (len <= 0) {
+		pval = of_get_property(dp, "tables", &len);
+                if (!pval || len <= 0) {
 			printk("envctrl: Failed to get table.\n");
 			return;
 		}
+		memcpy(pchild->tables, pval, len);
 	}
 
 	/* SPARCengine ASM Reference Manual (ref. SMI doc 805-7581-04)
@@ -907,12 +905,11 @@ static void envctrl_init_i2c_child(struct linux_ebus_child *edev_child,
 	 * 'NULL' monitor type.
 	 */
 	if (ENVCTRL_CPCI_IGNORED_NODE == pchild->addr) {
+		struct device_node *root_node;
 		int len;
-		char prop[56];
 
-		len = prom_getproperty(prom_root_node, "name", prop, sizeof(prop));
-		if (0 < len && (0 == strncmp(prop, "SUNW,UltraSPARC-IIi-cEngine", len)))
-		{
+		root_node = of_find_node_by_path("/");
+		if (!strcmp(root_node->name, "SUNW,UltraSPARC-IIi-cEngine")) {
 			for (len = 0; len < PCF8584_MAX_CHANNELS; ++len) {
 				pchild->mon_type[len] = ENVCTRL_NOMON;
 			}
@@ -921,16 +918,14 @@ static void envctrl_init_i2c_child(struct linux_ebus_child *edev_child,
 	}
 
 	/* Get the monitor channels. */
-	len = prom_getproperty(node, "channels-in-use",
-			       (char *) pchild->chnl_array,
-			       (PCF8584_MAX_CHANNELS *
-				sizeof(struct pcf8584_channel)));
+	pval = of_get_property(dp, "channels-in-use", &len);
+	memcpy(pchild->chnl_array, pval, len);
 	pchild->total_chnls = len / sizeof(struct pcf8584_channel);
 
 	for (i = 0; i < pchild->total_chnls; i++) {
 		switch (pchild->chnl_array[i].type) {
 		case PCF8584_TEMP_TYPE:
-			envctrl_init_adc(pchild, node);
+			envctrl_init_adc(pchild, dp);
 			break;
 
 		case PCF8584_GLOBALADDR_TYPE:
@@ -945,7 +940,7 @@ static void envctrl_init_i2c_child(struct linux_ebus_child *edev_child,
 
 		case PCF8584_VOLTAGE_TYPE:
 			if (pchild->i2ctype == I2C_ADC) {
-				envctrl_init_adc(pchild,node);
+				envctrl_init_adc(pchild,dp);
 			} else {
 				envctrl_init_voltage_status(pchild);
 			}
@@ -1046,7 +1041,7 @@ static int __init envctrl_init(void)
 
 	for_each_ebus(ebus) {
 		for_each_ebusdev(edev, ebus) {
-			if (!strcmp(edev->prom_name, "bbc")) {
+			if (!strcmp(edev->prom_node->name, "bbc")) {
 				/* If we find a boot-bus controller node,
 				 * then this envctrl driver is not for us.
 				 */
@@ -1060,14 +1055,14 @@ static int __init envctrl_init(void)
 	 */
 	for_each_ebus(ebus) {
 		for_each_ebusdev(edev, ebus) {
-			if (!strcmp(edev->prom_name, "i2c")) {
+			if (!strcmp(edev->prom_node->name, "i2c")) {
 				i2c = ioremap(edev->resource[0].start, 0x2);
 				for_each_edevchild(edev, edev_child) {
-					if (!strcmp("gpio", edev_child->prom_name)) {
+					if (!strcmp("gpio", edev_child->prom_node->name)) {
 						i2c_childlist[i].i2ctype = I2C_GPIO;
 						envctrl_init_i2c_child(edev_child, &(i2c_childlist[i++]));
 					}
-					if (!strcmp("adc", edev_child->prom_name)) {
+					if (!strcmp("adc", edev_child->prom_node->name)) {
 						i2c_childlist[i].i2ctype = I2C_ADC;
 						envctrl_init_i2c_child(edev_child, &(i2c_childlist[i++]));
 					}

commit 1928f8e541245eae933f8c95b64b2bc3683f9661
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Nov 7 14:12:34 2005 -0800

    [SPARC] envctrl: implement ->unlocked_ioctl and ->compat_ioctl
    
    all the ioctls in the driver are 32bit compat clean and don't need BKL,
    so we can switch it to ->unlocked_ioctl and ->compat_ioctl trivially.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/sbus/char/envctrl.c b/drivers/sbus/char/envctrl.c
index ba56762b05f6..19e8eddf887a 100644
--- a/drivers/sbus/char/envctrl.c
+++ b/drivers/sbus/char/envctrl.c
@@ -654,9 +654,8 @@ envctrl_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)
 /* Function Description: Command what to read.  Mapped to user ioctl().
  * Return: Gives 0 for implemented commands, -EINVAL otherwise.
  */
-static int
-envctrl_ioctl(struct inode *inode, struct file *file,
-	      unsigned int cmd, unsigned long arg)
+static long
+envctrl_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 {
 	char __user *infobuf;
 
@@ -715,11 +714,14 @@ envctrl_release(struct inode *inode, struct file *file)
 }
 
 static struct file_operations envctrl_fops = {
-	.owner =	THIS_MODULE,
-	.read =		envctrl_read,
-	.ioctl =	envctrl_ioctl,
-	.open =		envctrl_open,
-	.release =	envctrl_release,
+	.owner =		THIS_MODULE,
+	.read =			envctrl_read,
+	.unlocked_ioctl =	envctrl_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl =		envctrl_ioctl,
+#endif
+	.open =			envctrl_open,
+	.release =		envctrl_release,
 };	
 
 static struct miscdevice envctrl_dev = {

commit 6044ec8882c726e325017bd948aa0cd94ad33abc
Author: Jesper Juhl <jesper.juhl@gmail.com>
Date:   Mon Nov 7 01:01:32 2005 -0800

    [PATCH] kfree cleanup: misc remaining drivers
    
    This is the remaining misc drivers/ part of the big kfree cleanup patch.
    
    Remove pointless checks for NULL prior to calling kfree() in misc files in
    drivers/.
    
    Signed-off-by: Jesper Juhl <jesper.juhl@gmail.com>
    Acked-by: Aristeu Sergio Rozanski Filho <aris@cathedrallabs.org>
    Acked-by: Roland Dreier <rolandd@cisco.com>
    Acked-by: Pierre Ossman <drzeus@drzeus.cx>
    Acked-by: Jean Delvare <khali@linux-fr.org>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Acked-by: Len Brown <len.brown@intel.com>
    Acked-by: "Antonino A. Daplas" <adaplas@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/sbus/char/envctrl.c b/drivers/sbus/char/envctrl.c
index b0cc3c2588fd..ba56762b05f6 100644
--- a/drivers/sbus/char/envctrl.c
+++ b/drivers/sbus/char/envctrl.c
@@ -1125,10 +1125,9 @@ static int __init envctrl_init(void)
 	misc_deregister(&envctrl_dev);
 out_iounmap:
 	iounmap(i2c);
-	for (i = 0; i < ENVCTRL_MAX_CPU * 2; i++) {
-		if (i2c_childlist[i].tables)
-			kfree(i2c_childlist[i].tables);
-	}
+	for (i = 0; i < ENVCTRL_MAX_CPU * 2; i++)
+		kfree(i2c_childlist[i].tables);
+
 	return err;
 }
 
@@ -1141,10 +1140,8 @@ static void __exit envctrl_cleanup(void)
 	iounmap(i2c);
 	misc_deregister(&envctrl_dev);
 
-	for (i = 0; i < ENVCTRL_MAX_CPU * 2; i++) {
-		if (i2c_childlist[i].tables)
-			kfree(i2c_childlist[i].tables);
-	}
+	for (i = 0; i < ENVCTRL_MAX_CPU * 2; i++)
+		kfree(i2c_childlist[i].tables);
 }
 
 module_init(envctrl_init);

commit 0aaaa028297a0e2aed9671419a11d8e17510cb51
Author: viro@ZenIV.linux.org.uk <viro@ZenIV.linux.org.uk>
Date:   Fri Sep 9 22:09:08 2005 +0100

    [PATCH] envctrl fixes
    
    envctrl doesn't need unistd.h; moreover, since it declares errno static
    gcc4 gets very unhappy about including unistd.h.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/sbus/char/envctrl.c b/drivers/sbus/char/envctrl.c
index d765cc1bf060..b0cc3c2588fd 100644
--- a/drivers/sbus/char/envctrl.c
+++ b/drivers/sbus/char/envctrl.c
@@ -20,6 +20,7 @@
  */
 
 #define __KERNEL_SYSCALLS__
+static int errno;
 
 #include <linux/config.h>
 #include <linux/module.h>
@@ -38,9 +39,6 @@
 #include <asm/uaccess.h>
 #include <asm/envctrl.h>
 
-static int errno;
-#include <asm/unistd.h>
-
 #define ENVCTRL_MINOR	162
 
 #define PCF8584_ADDRESS	0x55

commit 38c1844b3120e04b7f5bb9c18ebbc19883d1e1d6
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Aug 9 14:43:14 2005 -0700

    [SPARC]: envctrl: ERR_PTR() --> PTR_ERR()
    
    Fix thinko in Christoph's changes.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/sbus/char/envctrl.c b/drivers/sbus/char/envctrl.c
index 1247f81a3278..d765cc1bf060 100644
--- a/drivers/sbus/char/envctrl.c
+++ b/drivers/sbus/char/envctrl.c
@@ -1117,7 +1117,7 @@ static int __init envctrl_init(void)
 
 	kenvctrld_task = kthread_run(kenvctrld, NULL, "kenvctrld");
 	if (IS_ERR(kenvctrld_task)) {
-		err = ERR_PTR(kenvctrld_task);
+		err = PTR_ERR(kenvctrld_task);
 		goto out_deregister;
 	}
 

commit 4875ccdb304775e9fd830f644643a1513357e043
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Aug 9 14:39:10 2005 -0700

    [SPARC]: remove ifdef CONFIG_PCI from envctrl.c
    
    The driver already depends on CONFIG_PCI in Kconfig.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/sbus/char/envctrl.c b/drivers/sbus/char/envctrl.c
index e103b12f9efe..1247f81a3278 100644
--- a/drivers/sbus/char/envctrl.c
+++ b/drivers/sbus/char/envctrl.c
@@ -1039,7 +1039,6 @@ static int kenvctrld(void *__unused)
 
 static int __init envctrl_init(void)
 {
-#ifdef CONFIG_PCI
 	struct linux_ebus *ebus = NULL;
 	struct linux_ebus_device *edev = NULL;
 	struct linux_ebus_child *edev_child = NULL;
@@ -1133,9 +1132,6 @@ static int __init envctrl_init(void)
 			kfree(i2c_childlist[i].tables);
 	}
 	return err;
-#else
-	return -ENODEV;
-#endif
 }
 
 static void __exit envctrl_cleanup(void)

commit 218b29e0c3995ee15782de55ad1dd74cce1a728d
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Aug 9 12:30:07 2005 -0700

    [SPARC]: Use kthread infrastructure in envctrl
    
    envctrl currently uses very odd ways to stop a thread, using various
    things that should be exposed to drivers at all.
    
    This patch (which is untested as I don't have sparc hardware) switches
    it to use the proper kthread infrastructure.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/sbus/char/envctrl.c b/drivers/sbus/char/envctrl.c
index 9a8c572554f5..e103b12f9efe 100644
--- a/drivers/sbus/char/envctrl.c
+++ b/drivers/sbus/char/envctrl.c
@@ -24,6 +24,7 @@
 #include <linux/config.h>
 #include <linux/module.h>
 #include <linux/sched.h>
+#include <linux/kthread.h>
 #include <linux/errno.h>
 #include <linux/delay.h>
 #include <linux/ioport.h>
@@ -1010,16 +1011,13 @@ static int kenvctrld(void *__unused)
 
 	poll_interval = 5000; /* TODO env_mon_interval */
 
-	daemonize("kenvctrld");
-	allow_signal(SIGKILL);
-
-	kenvctrld_task = current;
-
 	printk(KERN_INFO "envctrl: %s starting...\n", current->comm);
 	for (;;) {
-		if(msleep_interruptible(poll_interval))
-			break;
+		msleep_interruptible(poll_interval);
 
+		if (kthread_should_stop())
+			break;
+		
 		for (whichcpu = 0; whichcpu < ENVCTRL_MAX_CPU; ++whichcpu) {
 			if (0 < envctrl_read_cpu_info(whichcpu, cputemp,
 						      ENVCTRL_CPUTEMP_MON,
@@ -1118,9 +1116,11 @@ static int __init envctrl_init(void)
 			i2c_childlist[i].addr, (0 == i) ? ("\n") : (" "));
 	}
 
-	err = kernel_thread(kenvctrld, NULL, CLONE_FS | CLONE_FILES);
-	if (err < 0)
+	kenvctrld_task = kthread_run(kenvctrld, NULL, "kenvctrld");
+	if (IS_ERR(kenvctrld_task)) {
+		err = ERR_PTR(kenvctrld_task);
 		goto out_deregister;
+	}
 
 	return 0;
 
@@ -1142,28 +1142,7 @@ static void __exit envctrl_cleanup(void)
 {
 	int i;
 
-	if (NULL != kenvctrld_task) {
-		force_sig(SIGKILL, kenvctrld_task);
-		for (;;) {
-			struct task_struct *p;
-			int found = 0;
-
-			read_lock(&tasklist_lock);
-			for_each_process(p) {
-				if (p == kenvctrld_task) {
-					found = 1;
-					break;
-				}
-			}
-			read_unlock(&tasklist_lock);
-
-			if (!found)
-				break;
-
-			msleep(1000);
-		}
-		kenvctrld_task = NULL;
-	}
+	kthread_stop(kenvctrld_task);
 
 	iounmap(i2c);
 	misc_deregister(&envctrl_dev);

commit 4b502421aac89c8d4e61ecc89a70065a33305a0b
Author: David S. Miller <davem@davemloft.net>
Date:   Sun Jul 24 19:35:08 2005 -0700

    [SPARC]: Fix __KERNEL_SYSCALLS__ defining in envctrl.c and bbc_envctrl.c
    
    It needs to happen before any header includes because nowadays
    some things implicitly include asm/unistd.h which ends up being
    before the __KERNEL_SYSCALLS__ define gets done.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/sbus/char/envctrl.c b/drivers/sbus/char/envctrl.c
index 0c7cd7e7e2e5..9a8c572554f5 100644
--- a/drivers/sbus/char/envctrl.c
+++ b/drivers/sbus/char/envctrl.c
@@ -19,6 +19,8 @@
  *              Daniele Bellucci <bellucda@tiscali.it>
  */
 
+#define __KERNEL_SYSCALLS__
+
 #include <linux/config.h>
 #include <linux/module.h>
 #include <linux/sched.h>
@@ -35,7 +37,6 @@
 #include <asm/uaccess.h>
 #include <asm/envctrl.h>
 
-#define __KERNEL_SYSCALLS__
 static int errno;
 #include <asm/unistd.h>
 

commit cb39d263e751f9cca8055bcacfe5ec863dfe2705
Author: Nishanth Aravamudan <nacc@us.ibm.com>
Date:   Sun Jul 24 19:34:33 2005 -0700

    [SPARC]: sbus/envctrl: replace schedule_timeout() with msleep_interruptible()
    
    Use msleep_interruptible() instead of schedule_timeout() to guarantee
    the task delays as expected. Change the units of poll_interval to
    msecs as it is only used in this delay.
    
    Signed-off-by: Nishanth Aravamudan <nacc@us.ibm.com>
    Signed-off-by: Domen Puncer <domen@coderock.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/sbus/char/envctrl.c b/drivers/sbus/char/envctrl.c
index f6ed35b24f43..0c7cd7e7e2e5 100644
--- a/drivers/sbus/char/envctrl.c
+++ b/drivers/sbus/char/envctrl.c
@@ -1007,7 +1007,7 @@ static int kenvctrld(void *__unused)
 		return -ENODEV;
 	}
 
-	poll_interval = 5 * HZ; /* TODO env_mon_interval */
+	poll_interval = 5000; /* TODO env_mon_interval */
 
 	daemonize("kenvctrld");
 	allow_signal(SIGKILL);
@@ -1016,10 +1016,7 @@ static int kenvctrld(void *__unused)
 
 	printk(KERN_INFO "envctrl: %s starting...\n", current->comm);
 	for (;;) {
-		current->state = TASK_INTERRUPTIBLE;
-		schedule_timeout(poll_interval);
-
-		if(signal_pending(current))
+		if(msleep_interruptible(poll_interval))
 			break;
 
 		for (whichcpu = 0; whichcpu < ENVCTRL_MAX_CPU; ++whichcpu) {

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/sbus/char/envctrl.c b/drivers/sbus/char/envctrl.c
new file mode 100644
index 000000000000..f6ed35b24f43
--- /dev/null
+++ b/drivers/sbus/char/envctrl.c
@@ -0,0 +1,1181 @@
+/* $Id: envctrl.c,v 1.25 2002/01/15 09:01:26 davem Exp $
+ * envctrl.c: Temperature and Fan monitoring on Machines providing it.
+ *
+ * Copyright (C) 1998  Eddie C. Dost  (ecd@skynet.be)
+ * Copyright (C) 2000  Vinh Truong    (vinh.truong@eng.sun.com)
+ * VT - The implementation is to support Sun Microelectronics (SME) platform
+ *      environment monitoring.  SME platforms use pcf8584 as the i2c bus 
+ *      controller to access pcf8591 (8-bit A/D and D/A converter) and 
+ *      pcf8571 (256 x 8-bit static low-voltage RAM with I2C-bus interface).
+ *      At board level, it follows SME Firmware I2C Specification. Reference:
+ * 	http://www-eu2.semiconductors.com/pip/PCF8584P
+ * 	http://www-eu2.semiconductors.com/pip/PCF8574AP
+ * 	http://www-eu2.semiconductors.com/pip/PCF8591P
+ *
+ * EB - Added support for CP1500 Global Address and PS/Voltage monitoring.
+ * 		Eric Brower <ebrower@usa.net>
+ *
+ * DB - Audit every copy_to_user in envctrl_read.
+ *              Daniele Bellucci <bellucda@tiscali.it>
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <linux/miscdevice.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/kernel.h>
+
+#include <asm/ebus.h>
+#include <asm/uaccess.h>
+#include <asm/envctrl.h>
+
+#define __KERNEL_SYSCALLS__
+static int errno;
+#include <asm/unistd.h>
+
+#define ENVCTRL_MINOR	162
+
+#define PCF8584_ADDRESS	0x55
+
+#define CONTROL_PIN	0x80
+#define CONTROL_ES0	0x40
+#define CONTROL_ES1	0x20
+#define CONTROL_ES2	0x10
+#define CONTROL_ENI	0x08
+#define CONTROL_STA	0x04
+#define CONTROL_STO	0x02
+#define CONTROL_ACK	0x01
+
+#define STATUS_PIN	0x80
+#define STATUS_STS	0x20
+#define STATUS_BER	0x10
+#define STATUS_LRB	0x08
+#define STATUS_AD0	0x08
+#define STATUS_AAB	0x04
+#define STATUS_LAB	0x02
+#define STATUS_BB	0x01
+
+/*
+ * CLK Mode Register.
+ */
+#define BUS_CLK_90	0x00
+#define BUS_CLK_45	0x01
+#define BUS_CLK_11	0x02
+#define BUS_CLK_1_5	0x03
+
+#define CLK_3		0x00
+#define CLK_4_43	0x10
+#define CLK_6		0x14
+#define CLK_8		0x18
+#define CLK_12		0x1c
+
+#define OBD_SEND_START	0xc5    /* value to generate I2c_bus START condition */
+#define OBD_SEND_STOP 	0xc3    /* value to generate I2c_bus STOP condition */
+
+/* Monitor type of i2c child device.
+ * Firmware definitions.
+ */
+#define PCF8584_MAX_CHANNELS            8
+#define PCF8584_GLOBALADDR_TYPE			6  /* global address monitor */
+#define PCF8584_FANSTAT_TYPE            3  /* fan status monitor */
+#define PCF8584_VOLTAGE_TYPE            2  /* voltage monitor    */
+#define PCF8584_TEMP_TYPE	        	1  /* temperature monitor*/
+
+/* Monitor type of i2c child device.
+ * Driver definitions.
+ */
+#define ENVCTRL_NOMON				0
+#define ENVCTRL_CPUTEMP_MON			1    /* cpu temperature monitor */
+#define ENVCTRL_CPUVOLTAGE_MON	  	2    /* voltage monitor         */
+#define ENVCTRL_FANSTAT_MON  		3    /* fan status monitor      */
+#define ENVCTRL_ETHERTEMP_MON		4    /* ethernet temperarture */
+					     /* monitor                     */
+#define ENVCTRL_VOLTAGESTAT_MON	  	5    /* voltage status monitor  */
+#define ENVCTRL_MTHRBDTEMP_MON		6    /* motherboard temperature */
+#define ENVCTRL_SCSITEMP_MON		7    /* scsi temperarture */
+#define ENVCTRL_GLOBALADDR_MON		8    /* global address */
+
+/* Child device type.
+ * Driver definitions.
+ */
+#define I2C_ADC				0    /* pcf8591 */
+#define I2C_GPIO			1    /* pcf8571 */
+
+/* Data read from child device may need to decode
+ * through a data table and a scale.
+ * Translation type as defined by firmware.
+ */
+#define ENVCTRL_TRANSLATE_NO		0
+#define ENVCTRL_TRANSLATE_PARTIAL	1
+#define ENVCTRL_TRANSLATE_COMBINED	2
+#define ENVCTRL_TRANSLATE_FULL		3     /* table[data] */
+#define ENVCTRL_TRANSLATE_SCALE		4     /* table[data]/scale */
+
+/* Driver miscellaneous definitions. */
+#define ENVCTRL_MAX_CPU			4
+#define CHANNEL_DESC_SZ			256
+
+/* Mask values for combined GlobalAddress/PowerStatus node */
+#define ENVCTRL_GLOBALADDR_ADDR_MASK 	0x1F
+#define ENVCTRL_GLOBALADDR_PSTAT_MASK	0x60
+
+/* Node 0x70 ignored on CompactPCI CP1400/1500 platforms 
+ * (see envctrl_init_i2c_child)
+ */
+#define ENVCTRL_CPCI_IGNORED_NODE		0x70
+
+#define PCF8584_DATA	0x00
+#define PCF8584_CSR	0x01
+
+/* Each child device can be monitored by up to PCF8584_MAX_CHANNELS.
+ * Property of a port or channel as defined by the firmware.
+ */
+struct pcf8584_channel {
+        unsigned char chnl_no;
+        unsigned char io_direction;
+        unsigned char type;
+        unsigned char last;
+};
+
+/* Each child device may have one or more tables of bytes to help decode
+ * data. Table property as defined by the firmware.
+ */ 
+struct pcf8584_tblprop {
+        unsigned int type;
+        unsigned int scale;  
+        unsigned int offset; /* offset from the beginning of the table */
+        unsigned int size;
+};
+
+/* i2c child */
+struct i2c_child_t {
+	/* Either ADC or GPIO. */
+	unsigned char i2ctype;
+        unsigned long addr;    
+        struct pcf8584_channel chnl_array[PCF8584_MAX_CHANNELS];
+
+	/* Channel info. */ 
+	unsigned int total_chnls;	/* Number of monitor channels. */
+	unsigned char fan_mask;		/* Byte mask for fan status channels. */
+	unsigned char voltage_mask;	/* Byte mask for voltage status channels. */
+        struct pcf8584_tblprop tblprop_array[PCF8584_MAX_CHANNELS];
+
+	/* Properties of all monitor channels. */
+	unsigned int total_tbls;	/* Number of monitor tables. */
+        char *tables;			/* Pointer to table(s). */
+	char chnls_desc[CHANNEL_DESC_SZ]; /* Channel description. */
+	char mon_type[PCF8584_MAX_CHANNELS];
+};
+
+static void __iomem *i2c;
+static struct i2c_child_t i2c_childlist[ENVCTRL_MAX_CPU*2];
+static unsigned char chnls_mask[] = { 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80 };
+static unsigned int warning_temperature = 0;
+static unsigned int shutdown_temperature = 0;
+static char read_cpu;
+
+/* Forward declarations. */
+static struct i2c_child_t *envctrl_get_i2c_child(unsigned char);
+
+/* Function Description: Test the PIN bit (Pending Interrupt Not) 
+ * 			 to test when serial transmission is completed .
+ * Return : None.
+ */
+static void envtrl_i2c_test_pin(void)
+{
+	int limit = 1000000;
+
+	while (--limit > 0) {
+		if (!(readb(i2c + PCF8584_CSR) & STATUS_PIN)) 
+			break;
+		udelay(1);
+	} 
+
+	if (limit <= 0)
+		printk(KERN_INFO "envctrl: Pin status will not clear.\n");
+}
+
+/* Function Description: Test busy bit.
+ * Return : None.
+ */
+static void envctrl_i2c_test_bb(void)
+{
+	int limit = 1000000;
+
+	while (--limit > 0) {
+		/* Busy bit 0 means busy. */
+		if (readb(i2c + PCF8584_CSR) & STATUS_BB)
+			break;
+		udelay(1);
+	} 
+
+	if (limit <= 0)
+		printk(KERN_INFO "envctrl: Busy bit will not clear.\n");
+}
+
+/* Function Description: Send the address for a read access.
+ * Return : 0 if not acknowledged, otherwise acknowledged.
+ */
+static int envctrl_i2c_read_addr(unsigned char addr)
+{
+	envctrl_i2c_test_bb();
+
+	/* Load address. */
+	writeb(addr + 1, i2c + PCF8584_DATA);
+
+	envctrl_i2c_test_bb();
+
+	writeb(OBD_SEND_START, i2c + PCF8584_CSR);
+
+	/* Wait for PIN. */
+	envtrl_i2c_test_pin();
+
+	/* CSR 0 means acknowledged. */
+	if (!(readb(i2c + PCF8584_CSR) & STATUS_LRB)) {
+		return readb(i2c + PCF8584_DATA);
+	} else {
+		writeb(OBD_SEND_STOP, i2c + PCF8584_CSR);
+		return 0;
+	}
+}
+
+/* Function Description: Send the address for write mode.  
+ * Return : None.
+ */
+static void envctrl_i2c_write_addr(unsigned char addr)
+{
+	envctrl_i2c_test_bb();
+	writeb(addr, i2c + PCF8584_DATA);
+
+	/* Generate Start condition. */
+	writeb(OBD_SEND_START, i2c + PCF8584_CSR);
+}
+
+/* Function Description: Read 1 byte of data from addr 
+ *			 set by envctrl_i2c_read_addr() 
+ * Return : Data from address set by envctrl_i2c_read_addr().
+ */
+static unsigned char envctrl_i2c_read_data(void)
+{
+	envtrl_i2c_test_pin();
+	writeb(CONTROL_ES0, i2c + PCF8584_CSR);  /* Send neg ack. */
+	return readb(i2c + PCF8584_DATA);
+}
+
+/* Function Description: Instruct the device which port to read data from.  
+ * Return : None.
+ */
+static void envctrl_i2c_write_data(unsigned char port)
+{
+	envtrl_i2c_test_pin();
+	writeb(port, i2c + PCF8584_DATA);
+}
+
+/* Function Description: Generate Stop condition after last byte is sent.
+ * Return : None.
+ */
+static void envctrl_i2c_stop(void)
+{
+	envtrl_i2c_test_pin();
+	writeb(OBD_SEND_STOP, i2c + PCF8584_CSR);
+}
+
+/* Function Description: Read adc device.
+ * Return : Data at address and port.
+ */
+static unsigned char envctrl_i2c_read_8591(unsigned char addr, unsigned char port)
+{
+	/* Send address. */
+	envctrl_i2c_write_addr(addr);
+
+	/* Setup port to read. */
+	envctrl_i2c_write_data(port);
+	envctrl_i2c_stop();
+
+	/* Read port. */
+	envctrl_i2c_read_addr(addr);
+
+	/* Do a single byte read and send stop. */
+	envctrl_i2c_read_data();
+	envctrl_i2c_stop();
+
+	return readb(i2c + PCF8584_DATA);
+}
+
+/* Function Description: Read gpio device.
+ * Return : Data at address.
+ */
+static unsigned char envctrl_i2c_read_8574(unsigned char addr)
+{
+	unsigned char rd;
+
+	envctrl_i2c_read_addr(addr);
+
+	/* Do a single byte read and send stop. */
+	rd = envctrl_i2c_read_data();
+	envctrl_i2c_stop();
+	return rd;
+}
+
+/* Function Description: Decode data read from an adc device using firmware
+ *                       table.
+ * Return: Number of read bytes. Data is stored in bufdata in ascii format.
+ */
+static int envctrl_i2c_data_translate(unsigned char data, int translate_type,
+				      int scale, char *tbl, char *bufdata)
+{
+	int len = 0;
+
+	switch (translate_type) {
+	case ENVCTRL_TRANSLATE_NO:
+		/* No decode necessary. */
+		len = 1;
+		bufdata[0] = data;
+		break;
+
+	case ENVCTRL_TRANSLATE_FULL:
+		/* Decode this way: data = table[data]. */
+		len = 1;
+		bufdata[0] = tbl[data];
+		break;
+
+	case ENVCTRL_TRANSLATE_SCALE:
+		/* Decode this way: data = table[data]/scale */
+		sprintf(bufdata,"%d ", (tbl[data] * 10) / (scale));
+		len = strlen(bufdata);
+		bufdata[len - 1] = bufdata[len - 2];
+		bufdata[len - 2] = '.';
+		break;
+
+	default:
+		break;
+	};
+
+	return len;
+}
+
+/* Function Description: Read cpu-related data such as cpu temperature, voltage.
+ * Return: Number of read bytes. Data is stored in bufdata in ascii format.
+ */
+static int envctrl_read_cpu_info(int cpu, struct i2c_child_t *pchild,
+				 char mon_type, unsigned char *bufdata)
+{
+	unsigned char data;
+	int i;
+	char *tbl, j = -1;
+
+	/* Find the right monitor type and channel. */
+	for (i = 0; i < PCF8584_MAX_CHANNELS; i++) {
+		if (pchild->mon_type[i] == mon_type) {
+			if (++j == cpu) {
+				break;
+			}
+		}
+	}
+
+	if (j != cpu)
+		return 0;
+
+        /* Read data from address and port. */
+	data = envctrl_i2c_read_8591((unsigned char)pchild->addr,
+				     (unsigned char)pchild->chnl_array[i].chnl_no);
+
+	/* Find decoding table. */
+	tbl = pchild->tables + pchild->tblprop_array[i].offset;
+
+	return envctrl_i2c_data_translate(data, pchild->tblprop_array[i].type,
+					  pchild->tblprop_array[i].scale,
+					  tbl, bufdata);
+}
+
+/* Function Description: Read noncpu-related data such as motherboard 
+ *                       temperature.
+ * Return: Number of read bytes. Data is stored in bufdata in ascii format.
+ */
+static int envctrl_read_noncpu_info(struct i2c_child_t *pchild,
+				    char mon_type, unsigned char *bufdata)
+{
+	unsigned char data;
+	int i;
+	char *tbl = NULL;
+
+	for (i = 0; i < PCF8584_MAX_CHANNELS; i++) {
+		if (pchild->mon_type[i] == mon_type)
+			break;
+	}
+
+	if (i >= PCF8584_MAX_CHANNELS)
+		return 0;
+
+        /* Read data from address and port. */
+	data = envctrl_i2c_read_8591((unsigned char)pchild->addr,
+				     (unsigned char)pchild->chnl_array[i].chnl_no);
+
+	/* Find decoding table. */
+	tbl = pchild->tables + pchild->tblprop_array[i].offset;
+
+	return envctrl_i2c_data_translate(data, pchild->tblprop_array[i].type,
+					  pchild->tblprop_array[i].scale,
+					  tbl, bufdata);
+}
+
+/* Function Description: Read fan status.
+ * Return : Always 1 byte. Status stored in bufdata.
+ */
+static int envctrl_i2c_fan_status(struct i2c_child_t *pchild,
+				  unsigned char data,
+				  char *bufdata)
+{
+	unsigned char tmp, ret = 0;
+	int i, j = 0;
+
+	tmp = data & pchild->fan_mask;
+
+	if (tmp == pchild->fan_mask) {
+		/* All bits are on. All fans are functioning. */
+		ret = ENVCTRL_ALL_FANS_GOOD;
+	} else if (tmp == 0) {
+		/* No bits are on. No fans are functioning. */
+		ret = ENVCTRL_ALL_FANS_BAD;
+	} else {
+		/* Go through all channels, mark 'on' the matched bits.
+		 * Notice that fan_mask may have discontiguous bits but
+		 * return mask are always contiguous. For example if we
+		 * monitor 4 fans at channels 0,1,2,4, the return mask
+		 * should be 00010000 if only fan at channel 4 is working.
+		 */
+		for (i = 0; i < PCF8584_MAX_CHANNELS;i++) {
+			if (pchild->fan_mask & chnls_mask[i]) {
+				if (!(chnls_mask[i] & tmp))
+					ret |= chnls_mask[j];
+
+				j++;
+			}
+		}
+	}
+
+	bufdata[0] = ret;
+	return 1;
+}
+
+/* Function Description: Read global addressing line.
+ * Return : Always 1 byte. Status stored in bufdata.
+ */
+static int envctrl_i2c_globaladdr(struct i2c_child_t *pchild,
+				  unsigned char data,
+				  char *bufdata)
+{
+	/* Translatation table is not necessary, as global
+	 * addr is the integer value of the GA# bits.
+	 *
+	 * NOTE: MSB is documented as zero, but I see it as '1' always....
+	 *
+	 * -----------------------------------------------
+	 * | 0 | FAL | DEG | GA4 | GA3 | GA2 | GA1 | GA0 |
+	 * -----------------------------------------------
+	 * GA0 - GA4	integer value of Global Address (backplane slot#)
+	 * DEG			0 = cPCI Power supply output is starting to degrade
+	 * 				1 = cPCI Power supply output is OK
+	 * FAL			0 = cPCI Power supply has failed
+	 * 				1 = cPCI Power supply output is OK
+	 */
+	bufdata[0] = (data & ENVCTRL_GLOBALADDR_ADDR_MASK);
+	return 1;
+}
+
+/* Function Description: Read standard voltage and power supply status.
+ * Return : Always 1 byte. Status stored in bufdata.
+ */
+static unsigned char envctrl_i2c_voltage_status(struct i2c_child_t *pchild,
+						unsigned char data,
+						char *bufdata)
+{
+	unsigned char tmp, ret = 0;
+	int i, j = 0;
+
+	tmp = data & pchild->voltage_mask;
+
+	/* Two channels are used to monitor voltage and power supply. */
+	if (tmp == pchild->voltage_mask) {
+		/* All bits are on. Voltage and power supply are okay. */
+		ret = ENVCTRL_VOLTAGE_POWERSUPPLY_GOOD;
+	} else if (tmp == 0) {
+		/* All bits are off. Voltage and power supply are bad */
+		ret = ENVCTRL_VOLTAGE_POWERSUPPLY_BAD;
+	} else {
+		/* Either voltage or power supply has problem. */
+		for (i = 0; i < PCF8584_MAX_CHANNELS; i++) {
+			if (pchild->voltage_mask & chnls_mask[i]) {
+				j++;
+
+				/* Break out when there is a mismatch. */
+				if (!(chnls_mask[i] & tmp))
+					break; 
+			}
+		}
+
+		/* Make a wish that hardware will always use the
+		 * first channel for voltage and the second for
+		 * power supply.
+		 */
+		if (j == 1)
+			ret = ENVCTRL_VOLTAGE_BAD;
+		else
+			ret = ENVCTRL_POWERSUPPLY_BAD;
+	}
+
+	bufdata[0] = ret;
+	return 1;
+}
+
+/* Function Description: Read a byte from /dev/envctrl. Mapped to user read().
+ * Return: Number of read bytes. 0 for error.
+ */
+static ssize_t
+envctrl_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)
+{
+	struct i2c_child_t *pchild;
+	unsigned char data[10];
+	int ret = 0;
+
+	/* Get the type of read as decided in ioctl() call.
+	 * Find the appropriate i2c child.
+	 * Get the data and put back to the user buffer.
+	 */
+
+	switch ((int)(long)file->private_data) {
+	case ENVCTRL_RD_WARNING_TEMPERATURE:
+		if (warning_temperature == 0)
+			return 0;
+
+		data[0] = (unsigned char)(warning_temperature);
+		ret = 1;
+		if (copy_to_user(buf, data, ret))
+			ret = -EFAULT;
+		break;
+
+	case ENVCTRL_RD_SHUTDOWN_TEMPERATURE:
+		if (shutdown_temperature == 0)
+			return 0;
+
+		data[0] = (unsigned char)(shutdown_temperature);
+		ret = 1;
+		if (copy_to_user(buf, data, ret))
+			ret = -EFAULT;
+		break;
+
+	case ENVCTRL_RD_MTHRBD_TEMPERATURE:
+		if (!(pchild = envctrl_get_i2c_child(ENVCTRL_MTHRBDTEMP_MON)))
+			return 0;
+		ret = envctrl_read_noncpu_info(pchild, ENVCTRL_MTHRBDTEMP_MON, data);
+		if (copy_to_user(buf, data, ret))
+			ret = -EFAULT;
+		break;
+
+	case ENVCTRL_RD_CPU_TEMPERATURE:
+		if (!(pchild = envctrl_get_i2c_child(ENVCTRL_CPUTEMP_MON)))
+			return 0;
+		ret = envctrl_read_cpu_info(read_cpu, pchild, ENVCTRL_CPUTEMP_MON, data);
+
+		/* Reset cpu to the default cpu0. */
+		if (copy_to_user(buf, data, ret))
+			ret = -EFAULT;
+		break;
+
+	case ENVCTRL_RD_CPU_VOLTAGE:
+		if (!(pchild = envctrl_get_i2c_child(ENVCTRL_CPUVOLTAGE_MON)))
+			return 0;
+		ret = envctrl_read_cpu_info(read_cpu, pchild, ENVCTRL_CPUVOLTAGE_MON, data);
+
+		/* Reset cpu to the default cpu0. */
+		if (copy_to_user(buf, data, ret))
+			ret = -EFAULT;
+		break;
+
+	case ENVCTRL_RD_SCSI_TEMPERATURE:
+		if (!(pchild = envctrl_get_i2c_child(ENVCTRL_SCSITEMP_MON)))
+			return 0;
+		ret = envctrl_read_noncpu_info(pchild, ENVCTRL_SCSITEMP_MON, data);
+		if (copy_to_user(buf, data, ret))
+			ret = -EFAULT;
+		break;
+
+	case ENVCTRL_RD_ETHERNET_TEMPERATURE:
+		if (!(pchild = envctrl_get_i2c_child(ENVCTRL_ETHERTEMP_MON)))
+			return 0;
+		ret = envctrl_read_noncpu_info(pchild, ENVCTRL_ETHERTEMP_MON, data);
+		if (copy_to_user(buf, data, ret))
+			ret = -EFAULT;
+		break;
+
+	case ENVCTRL_RD_FAN_STATUS:
+		if (!(pchild = envctrl_get_i2c_child(ENVCTRL_FANSTAT_MON)))
+			return 0;
+		data[0] = envctrl_i2c_read_8574(pchild->addr);
+		ret = envctrl_i2c_fan_status(pchild,data[0], data);
+		if (copy_to_user(buf, data, ret))
+			ret = -EFAULT;
+		break;
+	
+	case ENVCTRL_RD_GLOBALADDRESS:
+		if (!(pchild = envctrl_get_i2c_child(ENVCTRL_GLOBALADDR_MON)))
+			return 0;
+		data[0] = envctrl_i2c_read_8574(pchild->addr);
+		ret = envctrl_i2c_globaladdr(pchild, data[0], data);
+		if (copy_to_user(buf, data, ret))
+			ret = -EFAULT;
+		break;
+
+	case ENVCTRL_RD_VOLTAGE_STATUS:
+		if (!(pchild = envctrl_get_i2c_child(ENVCTRL_VOLTAGESTAT_MON)))
+			/* If voltage monitor not present, check for CPCI equivalent */
+			if (!(pchild = envctrl_get_i2c_child(ENVCTRL_GLOBALADDR_MON)))
+				return 0;
+		data[0] = envctrl_i2c_read_8574(pchild->addr);
+		ret = envctrl_i2c_voltage_status(pchild, data[0], data);
+		if (copy_to_user(buf, data, ret))
+			ret = -EFAULT;
+		break;
+
+	default:
+		break;
+
+	};
+
+	return ret;
+}
+
+/* Function Description: Command what to read.  Mapped to user ioctl().
+ * Return: Gives 0 for implemented commands, -EINVAL otherwise.
+ */
+static int
+envctrl_ioctl(struct inode *inode, struct file *file,
+	      unsigned int cmd, unsigned long arg)
+{
+	char __user *infobuf;
+
+	switch (cmd) {
+	case ENVCTRL_RD_WARNING_TEMPERATURE:
+	case ENVCTRL_RD_SHUTDOWN_TEMPERATURE:
+	case ENVCTRL_RD_MTHRBD_TEMPERATURE:
+	case ENVCTRL_RD_FAN_STATUS:
+	case ENVCTRL_RD_VOLTAGE_STATUS:
+	case ENVCTRL_RD_ETHERNET_TEMPERATURE:
+	case ENVCTRL_RD_SCSI_TEMPERATURE:
+	case ENVCTRL_RD_GLOBALADDRESS:
+		file->private_data = (void *)(long)cmd;
+		break;
+
+	case ENVCTRL_RD_CPU_TEMPERATURE:
+	case ENVCTRL_RD_CPU_VOLTAGE:
+		/* Check to see if application passes in any cpu number,
+		 * the default is cpu0.
+		 */
+		infobuf = (char __user *) arg;
+		if (infobuf == NULL) {
+			read_cpu = 0;
+		}else {
+			get_user(read_cpu, infobuf);
+		}
+
+		/* Save the command for use when reading. */
+		file->private_data = (void *)(long)cmd;
+		break;
+
+	default:
+		return -EINVAL;
+	};
+
+	return 0;
+}
+
+/* Function Description: open device. Mapped to user open().
+ * Return: Always 0.
+ */
+static int
+envctrl_open(struct inode *inode, struct file *file)
+{
+	file->private_data = NULL;
+	return 0;
+}
+
+/* Function Description: Open device. Mapped to user close().
+ * Return: Always 0.
+ */
+static int
+envctrl_release(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static struct file_operations envctrl_fops = {
+	.owner =	THIS_MODULE,
+	.read =		envctrl_read,
+	.ioctl =	envctrl_ioctl,
+	.open =		envctrl_open,
+	.release =	envctrl_release,
+};	
+
+static struct miscdevice envctrl_dev = {
+	ENVCTRL_MINOR,
+	"envctrl",
+	&envctrl_fops
+};
+
+/* Function Description: Set monitor type based on firmware description.
+ * Return: None.
+ */
+static void envctrl_set_mon(struct i2c_child_t *pchild,
+			    char *chnl_desc,
+			    int chnl_no)
+{
+	/* Firmware only has temperature type.  It does not distinguish
+	 * different kinds of temperatures.  We use channel description
+	 * to disinguish them.
+	 */
+	if (!(strcmp(chnl_desc,"temp,cpu")) ||
+	    !(strcmp(chnl_desc,"temp,cpu0")) ||
+	    !(strcmp(chnl_desc,"temp,cpu1")) ||
+	    !(strcmp(chnl_desc,"temp,cpu2")) ||
+	    !(strcmp(chnl_desc,"temp,cpu3")))
+		pchild->mon_type[chnl_no] = ENVCTRL_CPUTEMP_MON;
+
+	if (!(strcmp(chnl_desc,"vddcore,cpu0")) ||
+	    !(strcmp(chnl_desc,"vddcore,cpu1")) ||
+	    !(strcmp(chnl_desc,"vddcore,cpu2")) ||
+	    !(strcmp(chnl_desc,"vddcore,cpu3")))
+		pchild->mon_type[chnl_no] = ENVCTRL_CPUVOLTAGE_MON;
+
+	if (!(strcmp(chnl_desc,"temp,motherboard")))
+		pchild->mon_type[chnl_no] = ENVCTRL_MTHRBDTEMP_MON;
+
+	if (!(strcmp(chnl_desc,"temp,scsi")))
+		pchild->mon_type[chnl_no] = ENVCTRL_SCSITEMP_MON;
+
+	if (!(strcmp(chnl_desc,"temp,ethernet")))
+		pchild->mon_type[chnl_no] = ENVCTRL_ETHERTEMP_MON;
+}
+
+/* Function Description: Initialize monitor channel with channel desc,
+ *                       decoding tables, monitor type, optional properties.
+ * Return: None.
+ */
+static void envctrl_init_adc(struct i2c_child_t *pchild, int node)
+{
+	char chnls_desc[CHANNEL_DESC_SZ];
+	int i = 0, len;
+	char *pos = chnls_desc;
+
+	/* Firmware describe channels into a stream separated by a '\0'. */
+	len = prom_getproperty(node, "channels-description", chnls_desc,
+			       CHANNEL_DESC_SZ);
+	chnls_desc[CHANNEL_DESC_SZ - 1] = '\0';
+
+	while (len > 0) {
+		int l = strlen(pos) + 1;
+		envctrl_set_mon(pchild, pos, i++);
+		len -= l;
+		pos += l;
+	}
+
+	/* Get optional properties. */
+        len = prom_getproperty(node, "warning-temp", (char *)&warning_temperature,
+			       sizeof(warning_temperature));
+        len = prom_getproperty(node, "shutdown-temp", (char *)&shutdown_temperature,
+			       sizeof(shutdown_temperature));
+}
+
+/* Function Description: Initialize child device monitoring fan status.
+ * Return: None.
+ */
+static void envctrl_init_fanstat(struct i2c_child_t *pchild)
+{
+	int i;
+
+	/* Go through all channels and set up the mask. */
+	for (i = 0; i < pchild->total_chnls; i++)
+		pchild->fan_mask |= chnls_mask[(pchild->chnl_array[i]).chnl_no];
+
+	/* We only need to know if this child has fan status monitored.
+	 * We don't care which channels since we have the mask already.
+	 */
+	pchild->mon_type[0] = ENVCTRL_FANSTAT_MON;
+}
+
+/* Function Description: Initialize child device for global addressing line.
+ * Return: None.
+ */
+static void envctrl_init_globaladdr(struct i2c_child_t *pchild)
+{
+	int i;
+
+	/* Voltage/PowerSupply monitoring is piggybacked 
+	 * with Global Address on CompactPCI.  See comments
+	 * within envctrl_i2c_globaladdr for bit assignments.
+	 *
+	 * The mask is created here by assigning mask bits to each
+	 * bit position that represents PCF8584_VOLTAGE_TYPE data.
+	 * Channel numbers are not consecutive within the globaladdr
+	 * node (why?), so we use the actual counter value as chnls_mask
+	 * index instead of the chnl_array[x].chnl_no value.
+	 *
+	 * NOTE: This loop could be replaced with a constant representing
+	 * a mask of bits 5&6 (ENVCTRL_GLOBALADDR_PSTAT_MASK).
+	 */
+	for (i = 0; i < pchild->total_chnls; i++) {
+		if (PCF8584_VOLTAGE_TYPE == pchild->chnl_array[i].type) {
+			pchild->voltage_mask |= chnls_mask[i];
+		}
+	}
+
+	/* We only need to know if this child has global addressing 
+	 * line monitored.  We don't care which channels since we know 
+	 * the mask already (ENVCTRL_GLOBALADDR_ADDR_MASK).
+	 */
+	pchild->mon_type[0] = ENVCTRL_GLOBALADDR_MON;
+}
+
+/* Initialize child device monitoring voltage status. */
+static void envctrl_init_voltage_status(struct i2c_child_t *pchild)
+{
+	int i;
+
+	/* Go through all channels and set up the mask. */
+	for (i = 0; i < pchild->total_chnls; i++)
+		pchild->voltage_mask |= chnls_mask[(pchild->chnl_array[i]).chnl_no];
+
+	/* We only need to know if this child has voltage status monitored.
+	 * We don't care which channels since we have the mask already.
+	 */
+	pchild->mon_type[0] = ENVCTRL_VOLTAGESTAT_MON;
+}
+
+/* Function Description: Initialize i2c child device.
+ * Return: None.
+ */
+static void envctrl_init_i2c_child(struct linux_ebus_child *edev_child,
+				   struct i2c_child_t *pchild)
+{
+	int node, len, i, tbls_size = 0;
+
+	node = edev_child->prom_node;
+
+	/* Get device address. */
+	len = prom_getproperty(node, "reg",
+			       (char *) &(pchild->addr),
+			       sizeof(pchild->addr));
+
+	/* Get tables property.  Read firmware temperature tables. */
+	len = prom_getproperty(node, "translation",
+			       (char *) pchild->tblprop_array,
+			       (PCF8584_MAX_CHANNELS *
+				sizeof(struct pcf8584_tblprop)));
+	if (len > 0) {
+                pchild->total_tbls = len / sizeof(struct pcf8584_tblprop);
+		for (i = 0; i < pchild->total_tbls; i++) {
+			if ((pchild->tblprop_array[i].size + pchild->tblprop_array[i].offset) > tbls_size) {
+				tbls_size = pchild->tblprop_array[i].size + pchild->tblprop_array[i].offset;
+			}
+		}
+
+                pchild->tables = kmalloc(tbls_size, GFP_KERNEL);
+		if (pchild->tables == NULL){
+			printk("envctrl: Failed to allocate table.\n");
+			return;
+		}
+                len = prom_getproperty(node, "tables",
+				       (char *) pchild->tables, tbls_size);
+                if (len <= 0) {
+			printk("envctrl: Failed to get table.\n");
+			return;
+		}
+	}
+
+	/* SPARCengine ASM Reference Manual (ref. SMI doc 805-7581-04)
+	 * sections 2.5, 3.5, 4.5 state node 0x70 for CP1400/1500 is
+	 * "For Factory Use Only."
+	 *
+	 * We ignore the node on these platforms by assigning the
+	 * 'NULL' monitor type.
+	 */
+	if (ENVCTRL_CPCI_IGNORED_NODE == pchild->addr) {
+		int len;
+		char prop[56];
+
+		len = prom_getproperty(prom_root_node, "name", prop, sizeof(prop));
+		if (0 < len && (0 == strncmp(prop, "SUNW,UltraSPARC-IIi-cEngine", len)))
+		{
+			for (len = 0; len < PCF8584_MAX_CHANNELS; ++len) {
+				pchild->mon_type[len] = ENVCTRL_NOMON;
+			}
+			return;
+		}
+	}
+
+	/* Get the monitor channels. */
+	len = prom_getproperty(node, "channels-in-use",
+			       (char *) pchild->chnl_array,
+			       (PCF8584_MAX_CHANNELS *
+				sizeof(struct pcf8584_channel)));
+	pchild->total_chnls = len / sizeof(struct pcf8584_channel);
+
+	for (i = 0; i < pchild->total_chnls; i++) {
+		switch (pchild->chnl_array[i].type) {
+		case PCF8584_TEMP_TYPE:
+			envctrl_init_adc(pchild, node);
+			break;
+
+		case PCF8584_GLOBALADDR_TYPE:
+			envctrl_init_globaladdr(pchild);
+			i = pchild->total_chnls;
+			break;
+
+		case PCF8584_FANSTAT_TYPE:
+			envctrl_init_fanstat(pchild);
+			i = pchild->total_chnls;
+			break;
+
+		case PCF8584_VOLTAGE_TYPE:
+			if (pchild->i2ctype == I2C_ADC) {
+				envctrl_init_adc(pchild,node);
+			} else {
+				envctrl_init_voltage_status(pchild);
+			}
+			i = pchild->total_chnls;
+			break;
+
+		default:
+			break;
+		};
+	}
+}
+
+/* Function Description: Search the child device list for a device.
+ * Return : The i2c child if found. NULL otherwise.
+ */
+static struct i2c_child_t *envctrl_get_i2c_child(unsigned char mon_type)
+{
+	int i, j;
+
+	for (i = 0; i < ENVCTRL_MAX_CPU*2; i++) {
+		for (j = 0; j < PCF8584_MAX_CHANNELS; j++) {
+			if (i2c_childlist[i].mon_type[j] == mon_type) {
+				return (struct i2c_child_t *)(&(i2c_childlist[i]));
+			}
+		}
+	}
+	return NULL;
+}
+
+static void envctrl_do_shutdown(void)
+{
+	static int inprog = 0;
+	static char *envp[] = {	
+		"HOME=/", "TERM=linux", "PATH=/sbin:/usr/sbin:/bin:/usr/bin", NULL };
+	char *argv[] = { 
+		"/sbin/shutdown", "-h", "now", NULL };	
+
+	if (inprog != 0)
+		return;
+
+	inprog = 1;
+	printk(KERN_CRIT "kenvctrld: WARNING: Shutting down the system now.\n");
+	if (0 > execve("/sbin/shutdown", argv, envp)) {
+		printk(KERN_CRIT "kenvctrld: WARNING: system shutdown failed!\n"); 
+		inprog = 0;  /* unlikely to succeed, but we could try again */
+	}
+}
+
+static struct task_struct *kenvctrld_task;
+
+static int kenvctrld(void *__unused)
+{
+	int poll_interval;
+	int whichcpu;
+	char tempbuf[10];
+	struct i2c_child_t *cputemp;
+
+	if (NULL == (cputemp = envctrl_get_i2c_child(ENVCTRL_CPUTEMP_MON))) {
+		printk(KERN_ERR 
+		       "envctrl: kenvctrld unable to monitor CPU temp-- exiting\n");
+		return -ENODEV;
+	}
+
+	poll_interval = 5 * HZ; /* TODO env_mon_interval */
+
+	daemonize("kenvctrld");
+	allow_signal(SIGKILL);
+
+	kenvctrld_task = current;
+
+	printk(KERN_INFO "envctrl: %s starting...\n", current->comm);
+	for (;;) {
+		current->state = TASK_INTERRUPTIBLE;
+		schedule_timeout(poll_interval);
+
+		if(signal_pending(current))
+			break;
+
+		for (whichcpu = 0; whichcpu < ENVCTRL_MAX_CPU; ++whichcpu) {
+			if (0 < envctrl_read_cpu_info(whichcpu, cputemp,
+						      ENVCTRL_CPUTEMP_MON,
+						      tempbuf)) {
+				if (tempbuf[0] >= shutdown_temperature) {
+					printk(KERN_CRIT 
+						"%s: WARNING: CPU%i temperature %i C meets or exceeds "\
+						"shutdown threshold %i C\n", 
+						current->comm, whichcpu, 
+						tempbuf[0], shutdown_temperature);
+					envctrl_do_shutdown();
+				}
+			}
+		}
+	}
+	printk(KERN_INFO "envctrl: %s exiting...\n", current->comm);
+	return 0;
+}
+
+static int __init envctrl_init(void)
+{
+#ifdef CONFIG_PCI
+	struct linux_ebus *ebus = NULL;
+	struct linux_ebus_device *edev = NULL;
+	struct linux_ebus_child *edev_child = NULL;
+	int err, i = 0;
+
+	for_each_ebus(ebus) {
+		for_each_ebusdev(edev, ebus) {
+			if (!strcmp(edev->prom_name, "bbc")) {
+				/* If we find a boot-bus controller node,
+				 * then this envctrl driver is not for us.
+				 */
+				return -ENODEV;
+			}
+		}
+	}
+
+	/* Traverse through ebus and ebus device list for i2c device and
+	 * adc and gpio nodes.
+	 */
+	for_each_ebus(ebus) {
+		for_each_ebusdev(edev, ebus) {
+			if (!strcmp(edev->prom_name, "i2c")) {
+				i2c = ioremap(edev->resource[0].start, 0x2);
+				for_each_edevchild(edev, edev_child) {
+					if (!strcmp("gpio", edev_child->prom_name)) {
+						i2c_childlist[i].i2ctype = I2C_GPIO;
+						envctrl_init_i2c_child(edev_child, &(i2c_childlist[i++]));
+					}
+					if (!strcmp("adc", edev_child->prom_name)) {
+						i2c_childlist[i].i2ctype = I2C_ADC;
+						envctrl_init_i2c_child(edev_child, &(i2c_childlist[i++]));
+					}
+				}
+				goto done;
+			}
+		}
+	}
+
+done:
+	if (!edev) {
+		printk("envctrl: I2C device not found.\n");
+		return -ENODEV;
+	}
+
+	/* Set device address. */
+	writeb(CONTROL_PIN, i2c + PCF8584_CSR);
+	writeb(PCF8584_ADDRESS, i2c + PCF8584_DATA);
+
+	/* Set system clock and SCL frequencies. */ 
+	writeb(CONTROL_PIN | CONTROL_ES1, i2c + PCF8584_CSR);
+	writeb(CLK_4_43 | BUS_CLK_90, i2c + PCF8584_DATA);
+
+	/* Enable serial interface. */
+	writeb(CONTROL_PIN | CONTROL_ES0 | CONTROL_ACK, i2c + PCF8584_CSR);
+	udelay(200);
+
+	/* Register the device as a minor miscellaneous device. */
+	err = misc_register(&envctrl_dev);
+	if (err) {
+		printk("envctrl: Unable to get misc minor %d\n",
+		       envctrl_dev.minor);
+		goto out_iounmap;
+	}
+
+	/* Note above traversal routine post-incremented 'i' to accommodate 
+	 * a next child device, so we decrement before reverse-traversal of
+	 * child devices.
+	 */
+	printk("envctrl: initialized ");
+	for (--i; i >= 0; --i) {
+		printk("[%s 0x%lx]%s", 
+			(I2C_ADC == i2c_childlist[i].i2ctype) ? ("adc") : 
+			((I2C_GPIO == i2c_childlist[i].i2ctype) ? ("gpio") : ("unknown")), 
+			i2c_childlist[i].addr, (0 == i) ? ("\n") : (" "));
+	}
+
+	err = kernel_thread(kenvctrld, NULL, CLONE_FS | CLONE_FILES);
+	if (err < 0)
+		goto out_deregister;
+
+	return 0;
+
+out_deregister:
+	misc_deregister(&envctrl_dev);
+out_iounmap:
+	iounmap(i2c);
+	for (i = 0; i < ENVCTRL_MAX_CPU * 2; i++) {
+		if (i2c_childlist[i].tables)
+			kfree(i2c_childlist[i].tables);
+	}
+	return err;
+#else
+	return -ENODEV;
+#endif
+}
+
+static void __exit envctrl_cleanup(void)
+{
+	int i;
+
+	if (NULL != kenvctrld_task) {
+		force_sig(SIGKILL, kenvctrld_task);
+		for (;;) {
+			struct task_struct *p;
+			int found = 0;
+
+			read_lock(&tasklist_lock);
+			for_each_process(p) {
+				if (p == kenvctrld_task) {
+					found = 1;
+					break;
+				}
+			}
+			read_unlock(&tasklist_lock);
+
+			if (!found)
+				break;
+
+			msleep(1000);
+		}
+		kenvctrld_task = NULL;
+	}
+
+	iounmap(i2c);
+	misc_deregister(&envctrl_dev);
+
+	for (i = 0; i < ENVCTRL_MAX_CPU * 2; i++) {
+		if (i2c_childlist[i].tables)
+			kfree(i2c_childlist[i].tables);
+	}
+}
+
+module_init(envctrl_init);
+module_exit(envctrl_cleanup);
+MODULE_LICENSE("GPL");
