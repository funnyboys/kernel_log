commit 09c434b8a0047c69e48499de0107de312901e798
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 13:08:20 2019 +0100

    treewide: Add SPDX license identifier for more missed files
    
    Add SPDX license identifiers to all files which:
    
     - Have no license information of any form
    
     - Have MODULE_LICENCE("GPL*") inside which was used in the initial
       scan/conversion to ignore the file
    
    These files fall under the project license, GPL v2 only. The resulting SPDX
    license identifier is:
    
      GPL-2.0-only
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/sbus/char/bbc_i2c.c b/drivers/sbus/char/bbc_i2c.c
index 129967ad345d..537e55cd038d 100644
--- a/drivers/sbus/char/bbc_i2c.c
+++ b/drivers/sbus/char/bbc_i2c.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /* bbc_i2c.c: I2C low-level driver for BBC device on UltraSPARC-III
  *            platforms.
  *

commit 7cafb31ca4e85fa4c522cecf917e86e258cfbcaa
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Mon Oct 20 16:21:32 2014 +0200

    sbus: char: drop owner assignment from platform_drivers
    
    A platform_driver does not need to set an owner, it will be populated by the
    driver core.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/sbus/char/bbc_i2c.c b/drivers/sbus/char/bbc_i2c.c
index 812b5f0361b6..129967ad345d 100644
--- a/drivers/sbus/char/bbc_i2c.c
+++ b/drivers/sbus/char/bbc_i2c.c
@@ -413,7 +413,6 @@ MODULE_DEVICE_TABLE(of, bbc_i2c_match);
 static struct platform_driver bbc_i2c_driver = {
 	.driver = {
 		.name = "bbc_i2c",
-		.owner = THIS_MODULE,
 		.of_match_table = bbc_i2c_match,
 	},
 	.probe		= bbc_i2c_probe,

commit 5cdceab3d5e02eb69ea0f5d8fa9181800baf6f77
Author: Christopher Alexander Tobias Schulze <cat.schulze@alice-dsl.net>
Date:   Sun Aug 3 15:44:52 2014 +0200

    bbc-i2c: Fix BBC I2C envctrl on SunBlade 2000
    
    Fix regression in bbc i2c temperature and fan control on some Sun systems
    that causes the driver to refuse to load due to the bbc_i2c_bussel resource not
    being present on the (second) i2c bus where the temperature sensors and fan
    control are located. (The check for the number of resources was removed when
    the driver was ported to a pure OF driver in mid 2008.)
    
    Signed-off-by: Christopher Alexander Tobias Schulze <cat.schulze@alice-dsl.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/sbus/char/bbc_i2c.c b/drivers/sbus/char/bbc_i2c.c
index c7763e482eb2..812b5f0361b6 100644
--- a/drivers/sbus/char/bbc_i2c.c
+++ b/drivers/sbus/char/bbc_i2c.c
@@ -300,13 +300,18 @@ static struct bbc_i2c_bus * attach_one_i2c(struct platform_device *op, int index
 	if (!bp)
 		return NULL;
 
+	INIT_LIST_HEAD(&bp->temps);
+	INIT_LIST_HEAD(&bp->fans);
+
 	bp->i2c_control_regs = of_ioremap(&op->resource[0], 0, 0x2, "bbc_i2c_regs");
 	if (!bp->i2c_control_regs)
 		goto fail;
 
-	bp->i2c_bussel_reg = of_ioremap(&op->resource[1], 0, 0x1, "bbc_i2c_bussel");
-	if (!bp->i2c_bussel_reg)
-		goto fail;
+	if (op->num_resources == 2) {
+		bp->i2c_bussel_reg = of_ioremap(&op->resource[1], 0, 0x1, "bbc_i2c_bussel");
+		if (!bp->i2c_bussel_reg)
+			goto fail;
+	}
 
 	bp->waiting = 0;
 	init_waitqueue_head(&bp->wq);

commit 8b2abcbc5ef1c135b03c7009f98350dbad2fe293
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Mon Jan 6 15:25:39 2014 -0500

    sparc: delete non-required instances of include <linux/init.h>
    
    None of these files are actually using any __init type directives
    and hence don't need to include <linux/init.h>.  Most are just a
    left over from __devinit and __cpuinit removal, or simply due to
    code getting copied from one driver to the next.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/sbus/char/bbc_i2c.c b/drivers/sbus/char/bbc_i2c.c
index c1441ed282eb..c7763e482eb2 100644
--- a/drivers/sbus/char/bbc_i2c.c
+++ b/drivers/sbus/char/bbc_i2c.c
@@ -11,7 +11,6 @@
 #include <linux/sched.h>
 #include <linux/wait.h>
 #include <linux/delay.h>
-#include <linux/init.h>
 #include <linux/interrupt.h>
 #include <linux/of.h>
 #include <linux/of_device.h>

commit 6e51f857303d02770d5f3ff8f0436487168d0230
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sat Mar 30 11:44:24 2013 +0000

    bbc_i2c: fix section mismatch warning
    
    Fix following warning:
    
    WARNING: drivers/sbus/char/bbc.o(.text+0x674): Section mismatch in reference from the function bbc_i2c_probe() to the function .init.text:T.463()
    The function bbc_i2c_probe() references the function __init T.463().
    This is often because bbc_i2c_probe lacks a __init
    annotation or the annotation of T.463 is wrong.
    
    bbc_i2c_probe() referenced the inlined attach_one_i2c().
    As probe may be called after init drop __init annotations
    on all functions used by bbc_i2c_probe()
    
    The warning was seen with a sparc64 defconfig build
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/sbus/char/bbc_i2c.c b/drivers/sbus/char/bbc_i2c.c
index 1a9d1e3ce64c..c1441ed282eb 100644
--- a/drivers/sbus/char/bbc_i2c.c
+++ b/drivers/sbus/char/bbc_i2c.c
@@ -282,7 +282,7 @@ static irqreturn_t bbc_i2c_interrupt(int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
-static void __init reset_one_i2c(struct bbc_i2c_bus *bp)
+static void reset_one_i2c(struct bbc_i2c_bus *bp)
 {
 	writeb(I2C_PCF_PIN, bp->i2c_control_regs + 0x0);
 	writeb(bp->own, bp->i2c_control_regs + 0x1);
@@ -291,7 +291,7 @@ static void __init reset_one_i2c(struct bbc_i2c_bus *bp)
 	writeb(I2C_PCF_IDLE, bp->i2c_control_regs + 0x0);
 }
 
-static struct bbc_i2c_bus * __init attach_one_i2c(struct platform_device *op, int index)
+static struct bbc_i2c_bus * attach_one_i2c(struct platform_device *op, int index)
 {
 	struct bbc_i2c_bus *bp;
 	struct device_node *dp;

commit 082a2004db27e16ee9a5b1234e6ab219ea29d693
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Dec 21 13:24:23 2012 -0800

    Drivers: sbus: remove __dev* attributes.
    
    CONFIG_HOTPLUG is going away as an option.  As a result, the __dev*
    markings need to be removed.
    
    This change removes the use of __devinit, __devexit_p, and __devexit
    from these drivers.
    
    Based on patches originally written by Bill Pemberton, but redone by me
    in order to handle some of the coding style issues better, by hand.
    
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Peter Senna Tschudin <peter.senna@gmail.com>
    Cc: David Howells <dhowells@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/sbus/char/bbc_i2c.c b/drivers/sbus/char/bbc_i2c.c
index 542668292900..1a9d1e3ce64c 100644
--- a/drivers/sbus/char/bbc_i2c.c
+++ b/drivers/sbus/char/bbc_i2c.c
@@ -355,7 +355,7 @@ static struct bbc_i2c_bus * __init attach_one_i2c(struct platform_device *op, in
 extern int bbc_envctrl_init(struct bbc_i2c_bus *bp);
 extern void bbc_envctrl_cleanup(struct bbc_i2c_bus *bp);
 
-static int __devinit bbc_i2c_probe(struct platform_device *op)
+static int bbc_i2c_probe(struct platform_device *op)
 {
 	struct bbc_i2c_bus *bp;
 	int err, index = 0;
@@ -379,7 +379,7 @@ static int __devinit bbc_i2c_probe(struct platform_device *op)
 	return err;
 }
 
-static int __devexit bbc_i2c_remove(struct platform_device *op)
+static int bbc_i2c_remove(struct platform_device *op)
 {
 	struct bbc_i2c_bus *bp = dev_get_drvdata(&op->dev);
 
@@ -413,7 +413,7 @@ static struct platform_driver bbc_i2c_driver = {
 		.of_match_table = bbc_i2c_match,
 	},
 	.probe		= bbc_i2c_probe,
-	.remove		= __devexit_p(bbc_i2c_remove),
+	.remove		= bbc_i2c_remove,
 };
 
 module_platform_driver(bbc_i2c_driver);

commit dbf2b92d54e73e4a2524b90d29bd498ecc4aa593
Author: Axel Lin <axel.lin@gmail.com>
Date:   Sat Nov 26 19:04:25 2011 +0000

    sbus: convert drivers/sbus/char/* to use module_platform_driver()
    
    This patch converts the drivers in drivers/sbus/char/* to use the
    module_platform_driver() macro which makes the code smaller and a bit
    simpler.
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/sbus/char/bbc_i2c.c b/drivers/sbus/char/bbc_i2c.c
index a0d1399577cc..542668292900 100644
--- a/drivers/sbus/char/bbc_i2c.c
+++ b/drivers/sbus/char/bbc_i2c.c
@@ -416,17 +416,6 @@ static struct platform_driver bbc_i2c_driver = {
 	.remove		= __devexit_p(bbc_i2c_remove),
 };
 
-static int __init bbc_i2c_init(void)
-{
-	return platform_driver_register(&bbc_i2c_driver);
-}
-
-static void __exit bbc_i2c_exit(void)
-{
-	platform_driver_unregister(&bbc_i2c_driver);
-}
-
-module_init(bbc_i2c_init);
-module_exit(bbc_i2c_exit);
+module_platform_driver(bbc_i2c_driver);
 
 MODULE_LICENSE("GPL");

commit e410471029ba99e85af5e2a1e7e747c7b4de2bc3
Author: Axel Lin <axel.lin@gmail.com>
Date:   Mon Nov 21 21:42:20 2011 +0000

    bbc_i2c: Remove unneeded err variable
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/sbus/char/bbc_i2c.c b/drivers/sbus/char/bbc_i2c.c
index 5f94d22c491e..a0d1399577cc 100644
--- a/drivers/sbus/char/bbc_i2c.c
+++ b/drivers/sbus/char/bbc_i2c.c
@@ -233,13 +233,9 @@ int bbc_i2c_write_buf(struct bbc_i2c_client *client,
 	int ret = 0;
 
 	while (len > 0) {
-		int err = bbc_i2c_writeb(client, *buf, off);
-
-		if (err < 0) {
-			ret = err;
+		ret = bbc_i2c_writeb(client, *buf, off);
+		if (ret < 0)
 			break;
-		}
-
 		len--;
 		buf++;
 		off++;
@@ -253,11 +249,9 @@ int bbc_i2c_read_buf(struct bbc_i2c_client *client,
 	int ret = 0;
 
 	while (len > 0) {
-		int err = bbc_i2c_readb(client, buf, off);
-		if (err < 0) {
-			ret = err;
+		ret = bbc_i2c_readb(client, buf, off);
+		if (ret < 0)
 			break;
-		}
 		len--;
 		buf++;
 		off++;

commit 4ebb24f707187196937607c60810d42f7112d7aa
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Tue Feb 22 20:01:33 2011 -0700

    dt/sparc: Eliminate users of of_platform_{,un}register_driver
    
    Get rid of old users of of_platform_driver in arch/sparc.  Most
    of_platform_driver users can be converted to use the platform_bus
    directly.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/sbus/char/bbc_i2c.c b/drivers/sbus/char/bbc_i2c.c
index 614a5e114a19..5f94d22c491e 100644
--- a/drivers/sbus/char/bbc_i2c.c
+++ b/drivers/sbus/char/bbc_i2c.c
@@ -361,8 +361,7 @@ static struct bbc_i2c_bus * __init attach_one_i2c(struct platform_device *op, in
 extern int bbc_envctrl_init(struct bbc_i2c_bus *bp);
 extern void bbc_envctrl_cleanup(struct bbc_i2c_bus *bp);
 
-static int __devinit bbc_i2c_probe(struct platform_device *op,
-				   const struct of_device_id *match)
+static int __devinit bbc_i2c_probe(struct platform_device *op)
 {
 	struct bbc_i2c_bus *bp;
 	int err, index = 0;
@@ -413,7 +412,7 @@ static const struct of_device_id bbc_i2c_match[] = {
 };
 MODULE_DEVICE_TABLE(of, bbc_i2c_match);
 
-static struct of_platform_driver bbc_i2c_driver = {
+static struct platform_driver bbc_i2c_driver = {
 	.driver = {
 		.name = "bbc_i2c",
 		.owner = THIS_MODULE,
@@ -425,12 +424,12 @@ static struct of_platform_driver bbc_i2c_driver = {
 
 static int __init bbc_i2c_init(void)
 {
-	return of_register_platform_driver(&bbc_i2c_driver);
+	return platform_driver_register(&bbc_i2c_driver);
 }
 
 static void __exit bbc_i2c_exit(void)
 {
-	of_unregister_platform_driver(&bbc_i2c_driver);
+	platform_driver_unregister(&bbc_i2c_driver);
 }
 
 module_init(bbc_i2c_init);

commit 2dc11581376829303b98eadb2de253bee065a56a
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Fri Aug 6 09:25:50 2010 -0600

    of/device: Replace struct of_device with struct platform_device
    
    of_device is just an alias for platform_device, so remove it entirely.  Also
    replace to_of_device() with to_platform_device() and update comment blocks.
    
    This patch was initially generated from the following semantic patch, and then
    edited by hand to pick up the bits that coccinelle didn't catch.
    
    @@
    @@
    -struct of_device
    +struct platform_device
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Reviewed-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/sbus/char/bbc_i2c.c b/drivers/sbus/char/bbc_i2c.c
index 3e89c313e98d..614a5e114a19 100644
--- a/drivers/sbus/char/bbc_i2c.c
+++ b/drivers/sbus/char/bbc_i2c.c
@@ -51,7 +51,7 @@
  * The second controller also connects to the smartcard reader, if present.
  */
 
-static void set_device_claimage(struct bbc_i2c_bus *bp, struct of_device *op, int val)
+static void set_device_claimage(struct bbc_i2c_bus *bp, struct platform_device *op, int val)
 {
 	int i;
 
@@ -66,9 +66,9 @@ static void set_device_claimage(struct bbc_i2c_bus *bp, struct of_device *op, in
 #define claim_device(BP,ECHILD)		set_device_claimage(BP,ECHILD,1)
 #define release_device(BP,ECHILD)	set_device_claimage(BP,ECHILD,0)
 
-struct of_device *bbc_i2c_getdev(struct bbc_i2c_bus *bp, int index)
+struct platform_device *bbc_i2c_getdev(struct bbc_i2c_bus *bp, int index)
 {
-	struct of_device *op = NULL;
+	struct platform_device *op = NULL;
 	int curidx = 0, i;
 
 	for (i = 0; i < NUM_CHILDREN; i++) {
@@ -86,7 +86,7 @@ struct of_device *bbc_i2c_getdev(struct bbc_i2c_bus *bp, int index)
 	return NULL;
 }
 
-struct bbc_i2c_client *bbc_i2c_attach(struct bbc_i2c_bus *bp, struct of_device *op)
+struct bbc_i2c_client *bbc_i2c_attach(struct bbc_i2c_bus *bp, struct platform_device *op)
 {
 	struct bbc_i2c_client *client;
 	const u32 *reg;
@@ -114,7 +114,7 @@ struct bbc_i2c_client *bbc_i2c_attach(struct bbc_i2c_bus *bp, struct of_device *
 void bbc_i2c_detach(struct bbc_i2c_client *client)
 {
 	struct bbc_i2c_bus *bp = client->bp;
-	struct of_device *op = client->op;
+	struct platform_device *op = client->op;
 
 	release_device(bp, op);
 	kfree(client);
@@ -297,7 +297,7 @@ static void __init reset_one_i2c(struct bbc_i2c_bus *bp)
 	writeb(I2C_PCF_IDLE, bp->i2c_control_regs + 0x0);
 }
 
-static struct bbc_i2c_bus * __init attach_one_i2c(struct of_device *op, int index)
+static struct bbc_i2c_bus * __init attach_one_i2c(struct platform_device *op, int index)
 {
 	struct bbc_i2c_bus *bp;
 	struct device_node *dp;
@@ -330,7 +330,7 @@ static struct bbc_i2c_bus * __init attach_one_i2c(struct of_device *op, int inde
 	for (dp = op->dev.of_node->child;
 	     dp && entry < 8;
 	     dp = dp->sibling, entry++) {
-		struct of_device *child_op;
+		struct platform_device *child_op;
 
 		child_op = of_find_device_by_node(dp);
 		bp->devs[entry].device = child_op;
@@ -361,7 +361,7 @@ static struct bbc_i2c_bus * __init attach_one_i2c(struct of_device *op, int inde
 extern int bbc_envctrl_init(struct bbc_i2c_bus *bp);
 extern void bbc_envctrl_cleanup(struct bbc_i2c_bus *bp);
 
-static int __devinit bbc_i2c_probe(struct of_device *op,
+static int __devinit bbc_i2c_probe(struct platform_device *op,
 				   const struct of_device_id *match)
 {
 	struct bbc_i2c_bus *bp;
@@ -386,7 +386,7 @@ static int __devinit bbc_i2c_probe(struct of_device *op,
 	return err;
 }
 
-static int __devexit bbc_i2c_remove(struct of_device *op)
+static int __devexit bbc_i2c_remove(struct platform_device *op)
 {
 	struct bbc_i2c_bus *bp = dev_get_drvdata(&op->dev);
 

commit 1ab1d63a85cee2545272f63a7644e9f855cb65d0
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Thu Jun 24 15:14:37 2010 -0600

    of/platform: remove all of_bus_type and of_platform_bus_type references
    
    Both of_bus_type and of_platform_bus_type are just #define aliases
    for the platform bus.  This patch removes all references to them and
    switches to the of_register_platform_driver()/of_unregister_platform_driver()
    API for registering.
    
    Subsequent patches will convert each user of of_register_platform_driver()
    into plain platform_drivers without the of_platform_driver shim.  At which
    point the of_register_platform_driver()/of_unregister_platform_driver()
    functions can be removed.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Acked-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/sbus/char/bbc_i2c.c b/drivers/sbus/char/bbc_i2c.c
index 40d7a1fc69af..3e89c313e98d 100644
--- a/drivers/sbus/char/bbc_i2c.c
+++ b/drivers/sbus/char/bbc_i2c.c
@@ -425,12 +425,12 @@ static struct of_platform_driver bbc_i2c_driver = {
 
 static int __init bbc_i2c_init(void)
 {
-	return of_register_driver(&bbc_i2c_driver, &of_bus_type);
+	return of_register_platform_driver(&bbc_i2c_driver);
 }
 
 static void __exit bbc_i2c_exit(void)
 {
-	of_unregister_driver(&bbc_i2c_driver);
+	of_unregister_platform_driver(&bbc_i2c_driver);
 }
 
 module_init(bbc_i2c_init);

commit 1636f8ac2b08410df4766449f7c86b912443cd99
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Fri Jun 18 11:09:58 2010 -0600

    sparc/of: Move of_device fields into struct pdev_archdata
    
    This patch moves SPARC architecture specific data members out of
    struct of_device and into the pdev_archdata structure.  The reason
    for this change is to unify the struct of_device definition amongst
    all the architectures.  It also remvoes the .sysdata, .slot, .portid
    and .clock_freq properties because they aren't actually used by
    anything.
    
    A subsequent patch will replace struct of_device entirely with struct
    platform_device and the of_platform support code will share common
    routines with the platform bus (but the bus instances themselves can
    remain separate).
    
    This patch also adds 'struct resources *resource' and num_resources
    to match the fields defined in struct platform_device.  After this
    change, 'struct platform_device' can be used as a drop-in replacement
    for 'struct of_platform'.
    
    This change is in preparation for merging the of_platform_bus_type
    with the platform_bus_type.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Acked-by: David S. Miller <davem@davemloft.net>
    Cc: Stephen Rothwell <sfr@canb.auug.org.au>

diff --git a/drivers/sbus/char/bbc_i2c.c b/drivers/sbus/char/bbc_i2c.c
index 8bfdd63a1fcb..40d7a1fc69af 100644
--- a/drivers/sbus/char/bbc_i2c.c
+++ b/drivers/sbus/char/bbc_i2c.c
@@ -317,7 +317,7 @@ static struct bbc_i2c_bus * __init attach_one_i2c(struct of_device *op, int inde
 
 	bp->waiting = 0;
 	init_waitqueue_head(&bp->wq);
-	if (request_irq(op->irqs[0], bbc_i2c_interrupt,
+	if (request_irq(op->archdata.irqs[0], bbc_i2c_interrupt,
 			IRQF_SHARED, "bbc_i2c", bp))
 		goto fail;
 
@@ -373,7 +373,7 @@ static int __devinit bbc_i2c_probe(struct of_device *op,
 
 	err = bbc_envctrl_init(bp);
 	if (err) {
-		free_irq(op->irqs[0], bp);
+		free_irq(op->archdata.irqs[0], bp);
 		if (bp->i2c_bussel_reg)
 			of_iounmap(&op->resource[0], bp->i2c_bussel_reg, 1);
 		if (bp->i2c_control_regs)
@@ -392,7 +392,7 @@ static int __devexit bbc_i2c_remove(struct of_device *op)
 
 	bbc_envctrl_cleanup(bp);
 
-	free_irq(op->irqs[0], bp);
+	free_irq(op->archdata.irqs[0], bp);
 
 	if (bp->i2c_bussel_reg)
 		of_iounmap(&op->resource[0], bp->i2c_bussel_reg, 1);

commit 4018294b53d1dae026880e45f174c1cc63b5d435
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Tue Apr 13 16:13:02 2010 -0700

    of: Remove duplicate fields from of_platform_driver
    
    .name, .match_table and .owner are duplicated in both of_platform_driver
    and device_driver.  This patch is a removes the extra copies from struct
    of_platform_driver and converts all users to the device_driver members.
    
    This patch is a pretty mechanical change.  The usage model doesn't change
    and if any drivers have been missed, or if anything has been fixed up
    incorrectly, then it will fail with a compile time error, and the fixup
    will be trivial.  This patch looks big and scary because it touches so
    many files, but it should be pretty safe.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Acked-by: Sean MacLennan <smaclennan@pikatech.com>

diff --git a/drivers/sbus/char/bbc_i2c.c b/drivers/sbus/char/bbc_i2c.c
index 1543ac32b79b..8bfdd63a1fcb 100644
--- a/drivers/sbus/char/bbc_i2c.c
+++ b/drivers/sbus/char/bbc_i2c.c
@@ -414,8 +414,11 @@ static const struct of_device_id bbc_i2c_match[] = {
 MODULE_DEVICE_TABLE(of, bbc_i2c_match);
 
 static struct of_platform_driver bbc_i2c_driver = {
-	.name		= "bbc_i2c",
-	.match_table	= bbc_i2c_match,
+	.driver = {
+		.name = "bbc_i2c",
+		.owner = THIS_MODULE,
+		.of_match_table = bbc_i2c_match,
+	},
 	.probe		= bbc_i2c_probe,
 	.remove		= __devexit_p(bbc_i2c_remove),
 };

commit 61c7a080a5a061c976988fd4b844dfb468dda255
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Tue Apr 13 16:12:29 2010 -0700

    of: Always use 'struct device.of_node' to get device node pointer.
    
    The following structure elements duplicate the information in
    'struct device.of_node' and so are being eliminated.  This patch
    makes all readers of these elements use device.of_node instead.
    
    (struct of_device *)->node
    (struct dev_archdata *)->prom_node (sparc)
    (struct dev_archdata *)->of_node (powerpc & microblaze)
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/sbus/char/bbc_i2c.c b/drivers/sbus/char/bbc_i2c.c
index 7e30e5f6e032..1543ac32b79b 100644
--- a/drivers/sbus/char/bbc_i2c.c
+++ b/drivers/sbus/char/bbc_i2c.c
@@ -97,7 +97,7 @@ struct bbc_i2c_client *bbc_i2c_attach(struct bbc_i2c_bus *bp, struct of_device *
 	client->bp = bp;
 	client->op = op;
 
-	reg = of_get_property(op->node, "reg", NULL);
+	reg = of_get_property(op->dev.of_node, "reg", NULL);
 	if (!reg) {
 		kfree(client);
 		return NULL;
@@ -327,7 +327,7 @@ static struct bbc_i2c_bus * __init attach_one_i2c(struct of_device *op, int inde
 	spin_lock_init(&bp->lock);
 
 	entry = 0;
-	for (dp = op->node->child;
+	for (dp = op->dev.of_node->child;
 	     dp && entry < 8;
 	     dp = dp->sibling, entry++) {
 		struct of_device *child_op;

commit f4c13638185c91a269c63fcfb980d89180cf43a1
Author: Roel Kluin <roel.kluin@gmail.com>
Date:   Wed Mar 4 00:19:28 2009 -0800

    sparc64: wait_event_interruptible_timeout may return -ERESTARTSYS
    
    wait_event_interruptible_timeout may return -ERESTARTSYS.
    
    Signed-off-by: Roel Kluin <roel.kluin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/sbus/char/bbc_i2c.c b/drivers/sbus/char/bbc_i2c.c
index f08e169ba1b5..7e30e5f6e032 100644
--- a/drivers/sbus/char/bbc_i2c.c
+++ b/drivers/sbus/char/bbc_i2c.c
@@ -129,7 +129,7 @@ static int wait_for_pin(struct bbc_i2c_bus *bp, u8 *status)
 	bp->waiting = 1;
 	add_wait_queue(&bp->wq, &wait);
 	while (limit-- > 0) {
-		unsigned long val;
+		long val;
 
 		val = wait_event_interruptible_timeout(
 				bp->wq,

commit 33b07db9f38fe73b3895f8d4db8fdee03e3afec3
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Dec 1 07:55:14 2008 -0800

    Revert "of_platform_driver noise on sparce"
    
    This reverts commit e669dae6141ff97d3c7566207f5de3b487dcf837, since it
    is incomplete, and clashes with fuller patches and the sparc 32/64
    unification effort.
    
    Requested-by: David Miller <davem@davemloft.net>
    Acked-by: Al Viro <viro@ZenIV.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/sbus/char/bbc_i2c.c b/drivers/sbus/char/bbc_i2c.c
index 054f5dd58931..f08e169ba1b5 100644
--- a/drivers/sbus/char/bbc_i2c.c
+++ b/drivers/sbus/char/bbc_i2c.c
@@ -361,7 +361,7 @@ static struct bbc_i2c_bus * __init attach_one_i2c(struct of_device *op, int inde
 extern int bbc_envctrl_init(struct bbc_i2c_bus *bp);
 extern void bbc_envctrl_cleanup(struct bbc_i2c_bus *bp);
 
-static int __init bbc_i2c_probe(struct of_device *op,
+static int __devinit bbc_i2c_probe(struct of_device *op,
 				   const struct of_device_id *match)
 {
 	struct bbc_i2c_bus *bp;
@@ -386,7 +386,7 @@ static int __init bbc_i2c_probe(struct of_device *op,
 	return err;
 }
 
-static int __exit bbc_i2c_remove(struct of_device *op)
+static int __devexit bbc_i2c_remove(struct of_device *op)
 {
 	struct bbc_i2c_bus *bp = dev_get_drvdata(&op->dev);
 
@@ -417,7 +417,7 @@ static struct of_platform_driver bbc_i2c_driver = {
 	.name		= "bbc_i2c",
 	.match_table	= bbc_i2c_match,
 	.probe		= bbc_i2c_probe,
-	.remove		= __exit_p(bbc_i2c_remove),
+	.remove		= __devexit_p(bbc_i2c_remove),
 };
 
 static int __init bbc_i2c_init(void)

commit e669dae6141ff97d3c7566207f5de3b487dcf837
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Sat Nov 22 17:35:04 2008 +0000

    of_platform_driver noise on sparce
    
    switch to __init for those; unlike powerpc sparc has no hotplug support
    for that stuff and their ->probe() tends to call __init functions while
    being declared __devinit.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/sbus/char/bbc_i2c.c b/drivers/sbus/char/bbc_i2c.c
index f08e169ba1b5..054f5dd58931 100644
--- a/drivers/sbus/char/bbc_i2c.c
+++ b/drivers/sbus/char/bbc_i2c.c
@@ -361,7 +361,7 @@ static struct bbc_i2c_bus * __init attach_one_i2c(struct of_device *op, int inde
 extern int bbc_envctrl_init(struct bbc_i2c_bus *bp);
 extern void bbc_envctrl_cleanup(struct bbc_i2c_bus *bp);
 
-static int __devinit bbc_i2c_probe(struct of_device *op,
+static int __init bbc_i2c_probe(struct of_device *op,
 				   const struct of_device_id *match)
 {
 	struct bbc_i2c_bus *bp;
@@ -386,7 +386,7 @@ static int __devinit bbc_i2c_probe(struct of_device *op,
 	return err;
 }
 
-static int __devexit bbc_i2c_remove(struct of_device *op)
+static int __exit bbc_i2c_remove(struct of_device *op)
 {
 	struct bbc_i2c_bus *bp = dev_get_drvdata(&op->dev);
 
@@ -417,7 +417,7 @@ static struct of_platform_driver bbc_i2c_driver = {
 	.name		= "bbc_i2c",
 	.match_table	= bbc_i2c_match,
 	.probe		= bbc_i2c_probe,
-	.remove		= __devexit_p(bbc_i2c_remove),
+	.remove		= __exit_p(bbc_i2c_remove),
 };
 
 static int __init bbc_i2c_init(void)

commit fd098316ef533e8441576f020ead4beab93154ce
Author: David S. Miller <davem@davemloft.net>
Date:   Sun Aug 31 01:23:17 2008 -0700

    sparc: Annotate of_device_id arrays with const or __initdata.
    
    As suggested by Stephen Rothwell.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/sbus/char/bbc_i2c.c b/drivers/sbus/char/bbc_i2c.c
index af7f4af6c5fb..f08e169ba1b5 100644
--- a/drivers/sbus/char/bbc_i2c.c
+++ b/drivers/sbus/char/bbc_i2c.c
@@ -404,7 +404,7 @@ static int __devexit bbc_i2c_remove(struct of_device *op)
 	return 0;
 }
 
-static struct of_device_id bbc_i2c_match[] = {
+static const struct of_device_id bbc_i2c_match[] = {
 	{
 		.name = "i2c",
 		.compatible = "SUNW,bbc-i2c",

commit e21e245bcd9d5244735799387d14421789b20557
Author: David S. Miller <davem@davemloft.net>
Date:   Fri Aug 29 22:34:14 2008 -0700

    bbc_i2c: Convert to pure OF driver.
    
    This thing was a mess, who wrote this junk? :)
    
    Luckily we'll soon have nice generic I2C layer drivers for this PCF
    based I2C stuff on sparc64.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/sbus/char/bbc_i2c.c b/drivers/sbus/char/bbc_i2c.c
index ac8ef2ce07fb..af7f4af6c5fb 100644
--- a/drivers/sbus/char/bbc_i2c.c
+++ b/drivers/sbus/char/bbc_i2c.c
@@ -1,8 +1,7 @@
-/* $Id: bbc_i2c.c,v 1.2 2001/04/02 09:59:08 davem Exp $
- * bbc_i2c.c: I2C low-level driver for BBC device on UltraSPARC-III
+/* bbc_i2c.c: I2C low-level driver for BBC device on UltraSPARC-III
  *            platforms.
  *
- * Copyright (C) 2001 David S. Miller (davem@redhat.com)
+ * Copyright (C) 2001, 2008 David S. Miller (davem@davemloft.net)
  */
 
 #include <linux/module.h>
@@ -14,9 +13,8 @@
 #include <linux/delay.h>
 #include <linux/init.h>
 #include <linux/interrupt.h>
-#include <asm/oplib.h>
-#include <asm/ebus.h>
-#include <asm/spitfire.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
 #include <asm/bbc.h>
 #include <asm/io.h>
 
@@ -53,54 +51,12 @@
  * The second controller also connects to the smartcard reader, if present.
  */
 
-#define NUM_CHILDREN	8
-struct bbc_i2c_bus {
-	struct bbc_i2c_bus		*next;
-	int				index;
-	spinlock_t			lock;
-	void				__iomem *i2c_bussel_reg;
-	void				__iomem *i2c_control_regs;
-	unsigned char			own, clock;
-
-	wait_queue_head_t		wq;
-	volatile int			waiting;
-
-	struct linux_ebus_device	*bus_edev;
-	struct {
-		struct linux_ebus_child	*device;
-		int			client_claimed;
-	} devs[NUM_CHILDREN];
-};
-
-static struct bbc_i2c_bus *all_bbc_i2c;
-
-struct bbc_i2c_client {
-	struct bbc_i2c_bus	*bp;
-	struct linux_ebus_child	*echild;
-	int			bus;
-	int			address;
-};
-
-static int find_device(struct bbc_i2c_bus *bp, struct linux_ebus_child *echild)
+static void set_device_claimage(struct bbc_i2c_bus *bp, struct of_device *op, int val)
 {
 	int i;
 
 	for (i = 0; i < NUM_CHILDREN; i++) {
-		if (bp->devs[i].device == echild) {
-			if (bp->devs[i].client_claimed)
-				return 0;
-			return 1;
-		}
-	}
-	return 0;
-}
-
-static void set_device_claimage(struct bbc_i2c_bus *bp, struct linux_ebus_child *echild, int val)
-{
-	int i;
-
-	for (i = 0; i < NUM_CHILDREN; i++) {
-		if (bp->devs[i].device == echild) {
+		if (bp->devs[i].device == op) {
 			bp->devs[i].client_claimed = val;
 			return;
 		}
@@ -110,61 +66,47 @@ static void set_device_claimage(struct bbc_i2c_bus *bp, struct linux_ebus_child
 #define claim_device(BP,ECHILD)		set_device_claimage(BP,ECHILD,1)
 #define release_device(BP,ECHILD)	set_device_claimage(BP,ECHILD,0)
 
-static struct bbc_i2c_bus *find_bus_for_device(struct linux_ebus_child *echild)
+struct of_device *bbc_i2c_getdev(struct bbc_i2c_bus *bp, int index)
 {
-	struct bbc_i2c_bus *bp = all_bbc_i2c;
+	struct of_device *op = NULL;
+	int curidx = 0, i;
 
-	while (bp != NULL) {
-		if (find_device(bp, echild) != 0)
+	for (i = 0; i < NUM_CHILDREN; i++) {
+		if (!(op = bp->devs[i].device))
 			break;
-		bp = bp->next;
+		if (curidx == index)
+			goto out;
+		op = NULL;
+		curidx++;
 	}
 
-	return bp;
-}
-
-struct linux_ebus_child *bbc_i2c_getdev(int index)
-{
-	struct bbc_i2c_bus *bp = all_bbc_i2c;
-	struct linux_ebus_child *echild = NULL;
-	int curidx = 0;
-
-	while (bp != NULL) {
-		struct bbc_i2c_bus *next = bp->next;
-		int i;
-
-		for (i = 0; i < NUM_CHILDREN; i++) {
-			if (!(echild = bp->devs[i].device))
-				break;
-			if (curidx == index)
-				goto out;
-			echild = NULL;
-			curidx++;
-		}
-		bp = next;
-	}
 out:
 	if (curidx == index)
-		return echild;
+		return op;
 	return NULL;
 }
 
-struct bbc_i2c_client *bbc_i2c_attach(struct linux_ebus_child *echild)
+struct bbc_i2c_client *bbc_i2c_attach(struct bbc_i2c_bus *bp, struct of_device *op)
 {
-	struct bbc_i2c_bus *bp = find_bus_for_device(echild);
 	struct bbc_i2c_client *client;
+	const u32 *reg;
 
-	if (!bp)
-		return NULL;
 	client = kzalloc(sizeof(*client), GFP_KERNEL);
 	if (!client)
 		return NULL;
 	client->bp = bp;
-	client->echild = echild;
-	client->bus = echild->resource[0].start;
-	client->address = echild->resource[1].start;
+	client->op = op;
+
+	reg = of_get_property(op->node, "reg", NULL);
+	if (!reg) {
+		kfree(client);
+		return NULL;
+	}
 
-	claim_device(bp, echild);
+	client->bus = reg[0];
+	client->address = reg[1];
+
+	claim_device(bp, op);
 
 	return client;
 }
@@ -172,9 +114,9 @@ struct bbc_i2c_client *bbc_i2c_attach(struct linux_ebus_child *echild)
 void bbc_i2c_detach(struct bbc_i2c_client *client)
 {
 	struct bbc_i2c_bus *bp = client->bp;
-	struct linux_ebus_child *echild = client->echild;
+	struct of_device *op = client->op;
 
-	release_device(bp, echild);
+	release_device(bp, op);
 	kfree(client);
 }
 
@@ -355,44 +297,43 @@ static void __init reset_one_i2c(struct bbc_i2c_bus *bp)
 	writeb(I2C_PCF_IDLE, bp->i2c_control_regs + 0x0);
 }
 
-static int __init attach_one_i2c(struct linux_ebus_device *edev, int index)
+static struct bbc_i2c_bus * __init attach_one_i2c(struct of_device *op, int index)
 {
 	struct bbc_i2c_bus *bp;
-	struct linux_ebus_child *echild;
+	struct device_node *dp;
 	int entry;
 
 	bp = kzalloc(sizeof(*bp), GFP_KERNEL);
 	if (!bp)
-		return -ENOMEM;
+		return NULL;
 
-	bp->i2c_control_regs = ioremap(edev->resource[0].start, 0x2);
+	bp->i2c_control_regs = of_ioremap(&op->resource[0], 0, 0x2, "bbc_i2c_regs");
 	if (!bp->i2c_control_regs)
 		goto fail;
 
-	if (edev->num_addrs == 2) {
-		bp->i2c_bussel_reg = ioremap(edev->resource[1].start, 0x1);
-		if (!bp->i2c_bussel_reg)
-			goto fail;
-	}
+	bp->i2c_bussel_reg = of_ioremap(&op->resource[1], 0, 0x1, "bbc_i2c_bussel");
+	if (!bp->i2c_bussel_reg)
+		goto fail;
 
 	bp->waiting = 0;
 	init_waitqueue_head(&bp->wq);
-	if (request_irq(edev->irqs[0], bbc_i2c_interrupt,
+	if (request_irq(op->irqs[0], bbc_i2c_interrupt,
 			IRQF_SHARED, "bbc_i2c", bp))
 		goto fail;
 
 	bp->index = index;
-	bp->bus_edev = edev;
+	bp->op = op;
 
 	spin_lock_init(&bp->lock);
-	bp->next = all_bbc_i2c;
-	all_bbc_i2c = bp;
 
 	entry = 0;
-	for (echild = edev->children;
-	     echild && entry < 8;
-	     echild = echild->next, entry++) {
-		bp->devs[entry].device = echild;
+	for (dp = op->node->child;
+	     dp && entry < 8;
+	     dp = dp->sibling, entry++) {
+		struct of_device *child_op;
+
+		child_op = of_find_device_by_node(dp);
+		bp->devs[entry].device = child_op;
 		bp->devs[entry].client_claimed = 0;
 	}
 
@@ -406,86 +347,90 @@ static int __init attach_one_i2c(struct linux_ebus_device *edev, int index)
 
 	reset_one_i2c(bp);
 
-	return 0;
+	return bp;
 
 fail:
 	if (bp->i2c_bussel_reg)
-		iounmap(bp->i2c_bussel_reg);
+		of_iounmap(&op->resource[1], bp->i2c_bussel_reg, 1);
 	if (bp->i2c_control_regs)
-		iounmap(bp->i2c_control_regs);
+		of_iounmap(&op->resource[0], bp->i2c_control_regs, 2);
 	kfree(bp);
-	return -EINVAL;
-}
-
-static int __init bbc_present(void)
-{
-	struct linux_ebus *ebus = NULL;
-	struct linux_ebus_device *edev = NULL;
-
-	for_each_ebus(ebus) {
-		for_each_ebusdev(edev, ebus) {
-			if (!strcmp(edev->prom_node->name, "bbc"))
-				return 1;
-		}
-	}
-	return 0;
+	return NULL;
 }
 
-extern int bbc_envctrl_init(void);
-extern void bbc_envctrl_cleanup(void);
-static void bbc_i2c_cleanup(void);
+extern int bbc_envctrl_init(struct bbc_i2c_bus *bp);
+extern void bbc_envctrl_cleanup(struct bbc_i2c_bus *bp);
 
-static int __init bbc_i2c_init(void)
+static int __devinit bbc_i2c_probe(struct of_device *op,
+				   const struct of_device_id *match)
 {
-	struct linux_ebus *ebus = NULL;
-	struct linux_ebus_device *edev = NULL;
+	struct bbc_i2c_bus *bp;
 	int err, index = 0;
 
-	if ((tlb_type != cheetah && tlb_type != cheetah_plus) ||
-	    !bbc_present())
-		return -ENODEV;
+	bp = attach_one_i2c(op, index);
+	if (!bp)
+		return -EINVAL;
 
-	for_each_ebus(ebus) {
-		for_each_ebusdev(edev, ebus) {
-			if (!strcmp(edev->prom_node->name, "i2c")) {
-				if (!attach_one_i2c(edev, index))
-					index++;
-			}
-		}
+	err = bbc_envctrl_init(bp);
+	if (err) {
+		free_irq(op->irqs[0], bp);
+		if (bp->i2c_bussel_reg)
+			of_iounmap(&op->resource[0], bp->i2c_bussel_reg, 1);
+		if (bp->i2c_control_regs)
+			of_iounmap(&op->resource[1], bp->i2c_control_regs, 2);
+		kfree(bp);
+	} else {
+		dev_set_drvdata(&op->dev, bp);
 	}
 
-	if (!index)
-		return -ENODEV;
-
-	err = bbc_envctrl_init();
-	if (err)
-		bbc_i2c_cleanup();
 	return err;
 }
 
-static void bbc_i2c_cleanup(void)
+static int __devexit bbc_i2c_remove(struct of_device *op)
 {
-	struct bbc_i2c_bus *bp = all_bbc_i2c;
+	struct bbc_i2c_bus *bp = dev_get_drvdata(&op->dev);
+
+	bbc_envctrl_cleanup(bp);
+
+	free_irq(op->irqs[0], bp);
 
-	bbc_envctrl_cleanup();
+	if (bp->i2c_bussel_reg)
+		of_iounmap(&op->resource[0], bp->i2c_bussel_reg, 1);
+	if (bp->i2c_control_regs)
+		of_iounmap(&op->resource[1], bp->i2c_control_regs, 2);
 
-	while (bp != NULL) {
-		struct bbc_i2c_bus *next = bp->next;
+	kfree(bp);
 
-		free_irq(bp->bus_edev->irqs[0], bp);
+	return 0;
+}
 
-		if (bp->i2c_bussel_reg)
-			iounmap(bp->i2c_bussel_reg);
-		if (bp->i2c_control_regs)
-			iounmap(bp->i2c_control_regs);
+static struct of_device_id bbc_i2c_match[] = {
+	{
+		.name = "i2c",
+		.compatible = "SUNW,bbc-i2c",
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, bbc_i2c_match);
 
-		kfree(bp);
+static struct of_platform_driver bbc_i2c_driver = {
+	.name		= "bbc_i2c",
+	.match_table	= bbc_i2c_match,
+	.probe		= bbc_i2c_probe,
+	.remove		= __devexit_p(bbc_i2c_remove),
+};
 
-		bp = next;
-	}
-	all_bbc_i2c = NULL;
+static int __init bbc_i2c_init(void)
+{
+	return of_register_driver(&bbc_i2c_driver, &of_bus_type);
+}
+
+static void __exit bbc_i2c_exit(void)
+{
+	of_unregister_driver(&bbc_i2c_driver);
 }
 
 module_init(bbc_i2c_init);
-module_exit(bbc_i2c_cleanup);
+module_exit(bbc_i2c_exit);
+
 MODULE_LICENSE("GPL");

commit 50aa485e1abb7566ce68418c7bbc6a6b454f9039
Author: Mariusz Kozlowski <m.kozlowski@tuxland.pl>
Date:   Tue Jul 31 14:04:57 2007 -0700

    [BBC_I2C]: kmalloc + memset conversion to kzalloc
    
    Signed-off-by: Mariusz Kozlowski <m.kozlowski@tuxland.pl>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/sbus/char/bbc_i2c.c b/drivers/sbus/char/bbc_i2c.c
index fbadd4d761f3..ac8ef2ce07fb 100644
--- a/drivers/sbus/char/bbc_i2c.c
+++ b/drivers/sbus/char/bbc_i2c.c
@@ -357,13 +357,13 @@ static void __init reset_one_i2c(struct bbc_i2c_bus *bp)
 
 static int __init attach_one_i2c(struct linux_ebus_device *edev, int index)
 {
-	struct bbc_i2c_bus *bp = kmalloc(sizeof(*bp), GFP_KERNEL);
+	struct bbc_i2c_bus *bp;
 	struct linux_ebus_child *echild;
 	int entry;
 
+	bp = kzalloc(sizeof(*bp), GFP_KERNEL);
 	if (!bp)
 		return -ENOMEM;
-	memset(bp, 0, sizeof(*bp));
 
 	bp->i2c_control_regs = ioremap(edev->resource[0].start, 0x2);
 	if (!bp->i2c_control_regs)

commit dd00cc486ab1c17049a535413d1751ef3482141c
Author: Yoann Padioleau <padator@wanadoo.fr>
Date:   Thu Jul 19 01:49:03 2007 -0700

    some kmalloc/memset ->kzalloc (tree wide)
    
    Transform some calls to kmalloc/memset to a single kzalloc (or kcalloc).
    
    Here is a short excerpt of the semantic patch performing
    this transformation:
    
    @@
    type T2;
    expression x;
    identifier f,fld;
    expression E;
    expression E1,E2;
    expression e1,e2,e3,y;
    statement S;
    @@
    
     x =
    - kmalloc
    + kzalloc
      (E1,E2)
      ...  when != \(x->fld=E;\|y=f(...,x,...);\|f(...,x,...);\|x=E;\|while(...) S\|for(e1;e2;e3) S\)
    - memset((T2)x,0,E1);
    
    @@
    expression E1,E2,E3;
    @@
    
    - kzalloc(E1 * E2,E3)
    + kcalloc(E1,E2,E3)
    
    [akpm@linux-foundation.org: get kcalloc args the right way around]
    Signed-off-by: Yoann Padioleau <padator@wanadoo.fr>
    Cc: Richard Henderson <rth@twiddle.net>
    Cc: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
    Acked-by: Russell King <rmk@arm.linux.org.uk>
    Cc: Bryan Wu <bryan.wu@analog.com>
    Acked-by: Jiri Slaby <jirislaby@gmail.com>
    Cc: Dave Airlie <airlied@linux.ie>
    Acked-by: Roland Dreier <rolandd@cisco.com>
    Cc: Jiri Kosina <jkosina@suse.cz>
    Acked-by: Dmitry Torokhov <dtor@mail.ru>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Acked-by: Mauro Carvalho Chehab <mchehab@infradead.org>
    Acked-by: Pierre Ossman <drzeus-list@drzeus.cx>
    Cc: Jeff Garzik <jeff@garzik.org>
    Cc: "David S. Miller" <davem@davemloft.net>
    Acked-by: Greg KH <greg@kroah.com>
    Cc: James Bottomley <James.Bottomley@steeleye.com>
    Cc: "Antonino A. Daplas" <adaplas@pol.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/sbus/char/bbc_i2c.c b/drivers/sbus/char/bbc_i2c.c
index 178155bf9db6..fbadd4d761f3 100644
--- a/drivers/sbus/char/bbc_i2c.c
+++ b/drivers/sbus/char/bbc_i2c.c
@@ -156,10 +156,9 @@ struct bbc_i2c_client *bbc_i2c_attach(struct linux_ebus_child *echild)
 
 	if (!bp)
 		return NULL;
-	client = kmalloc(sizeof(*client), GFP_KERNEL);
+	client = kzalloc(sizeof(*client), GFP_KERNEL);
 	if (!client)
 		return NULL;
-	memset(client, 0, sizeof(*client));
 	client->bp = bp;
 	client->echild = echild;
 	client->bus = echild->resource[0].start;

commit 4b5dff76a70cb1d8b935b8b93fe0df0bbe66640d
Author: David S. Miller <davem@sunset.davemloft.net>
Date:   Sun May 13 22:22:13 2007 -0700

    [SPARC] SBUS: bbc_i2c.c needs asm/io.h
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/sbus/char/bbc_i2c.c b/drivers/sbus/char/bbc_i2c.c
index 8410587348f1..178155bf9db6 100644
--- a/drivers/sbus/char/bbc_i2c.c
+++ b/drivers/sbus/char/bbc_i2c.c
@@ -18,6 +18,7 @@
 #include <asm/ebus.h>
 #include <asm/spitfire.h>
 #include <asm/bbc.h>
+#include <asm/io.h>
 
 #include "bbc_i2c.h"
 

commit 3b36fb8471f8639d565b69c9a456a3ef9413df59
Author: David S. Miller <davem@sunset.davemloft.net>
Date:   Mon Feb 26 10:11:35 2007 -0800

    [SPARC64] bbc_i2c: Fix kenvctrld eating %100 cpu.
    
    Based almost entirely upon a patch by Joerg Friedrich
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/sbus/char/bbc_i2c.c b/drivers/sbus/char/bbc_i2c.c
index 22631f8b9b48..8410587348f1 100644
--- a/drivers/sbus/char/bbc_i2c.c
+++ b/drivers/sbus/char/bbc_i2c.c
@@ -187,19 +187,20 @@ static int wait_for_pin(struct bbc_i2c_bus *bp, u8 *status)
 	bp->waiting = 1;
 	add_wait_queue(&bp->wq, &wait);
 	while (limit-- > 0) {
-		u8 val;
-
-		set_current_state(TASK_INTERRUPTIBLE);
-		*status = val = readb(bp->i2c_control_regs + 0);
-		if ((val & I2C_PCF_PIN) == 0) {
+		unsigned long val;
+
+		val = wait_event_interruptible_timeout(
+				bp->wq,
+				(((*status = readb(bp->i2c_control_regs + 0))
+				  & I2C_PCF_PIN) == 0),
+				msecs_to_jiffies(250));
+		if (val > 0) {
 			ret = 0;
 			break;
 		}
-		msleep_interruptible(250);
 	}
 	remove_wait_queue(&bp->wq, &wait);
 	bp->waiting = 0;
-	current->state = TASK_RUNNING;
 
 	return ret;
 }
@@ -340,7 +341,7 @@ static irqreturn_t bbc_i2c_interrupt(int irq, void *dev_id)
 	 */
 	if (bp->waiting &&
 	    !(readb(bp->i2c_control_regs + 0x0) & I2C_PCF_PIN))
-		wake_up(&bp->wq);
+		wake_up_interruptible(&bp->wq);
 
 	return IRQ_HANDLED;
 }

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/drivers/sbus/char/bbc_i2c.c b/drivers/sbus/char/bbc_i2c.c
index 7186235594f9..22631f8b9b48 100644
--- a/drivers/sbus/char/bbc_i2c.c
+++ b/drivers/sbus/char/bbc_i2c.c
@@ -331,7 +331,7 @@ EXPORT_SYMBOL(bbc_i2c_readb);
 EXPORT_SYMBOL(bbc_i2c_write_buf);
 EXPORT_SYMBOL(bbc_i2c_read_buf);
 
-static irqreturn_t bbc_i2c_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t bbc_i2c_interrupt(int irq, void *dev_id)
 {
 	struct bbc_i2c_bus *bp = dev_id;
 

commit dace145374b8e39aeb920304c358ab5e220341ab
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jul 1 19:29:38 2006 -0700

    [PATCH] irq-flags: misc drivers: Use the new IRQF_ constants
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/sbus/char/bbc_i2c.c b/drivers/sbus/char/bbc_i2c.c
index 73634371393b..7186235594f9 100644
--- a/drivers/sbus/char/bbc_i2c.c
+++ b/drivers/sbus/char/bbc_i2c.c
@@ -377,7 +377,7 @@ static int __init attach_one_i2c(struct linux_ebus_device *edev, int index)
 	bp->waiting = 0;
 	init_waitqueue_head(&bp->wq);
 	if (request_irq(edev->irqs[0], bbc_i2c_interrupt,
-			SA_SHIRQ, "bbc_i2c", bp))
+			IRQF_SHARED, "bbc_i2c", bp))
 		goto fail;
 
 	bp->index = index;

commit 690c8fd31f1e35985d0f35772fde514da59ec9d1
Author: David S. Miller <davem@sunset.davemloft.net>
Date:   Thu Jun 22 19:12:03 2006 -0700

    [SPARC64]: Use in-kernel PROM tree for EBUS and ISA.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/sbus/char/bbc_i2c.c b/drivers/sbus/char/bbc_i2c.c
index 3e156e005f2e..73634371393b 100644
--- a/drivers/sbus/char/bbc_i2c.c
+++ b/drivers/sbus/char/bbc_i2c.c
@@ -423,7 +423,7 @@ static int __init bbc_present(void)
 
 	for_each_ebus(ebus) {
 		for_each_ebusdev(edev, ebus) {
-			if (!strcmp(edev->prom_name, "bbc"))
+			if (!strcmp(edev->prom_node->name, "bbc"))
 				return 1;
 		}
 	}
@@ -446,7 +446,7 @@ static int __init bbc_i2c_init(void)
 
 	for_each_ebus(ebus) {
 		for_each_ebusdev(edev, ebus) {
-			if (!strcmp(edev->prom_name, "i2c")) {
+			if (!strcmp(edev->prom_node->name, "i2c")) {
 				if (!attach_one_i2c(edev, index))
 					index++;
 			}

commit b5e7ae5dd034c2c0ed75c31fca04a805097817bc
Author: David S. Miller <davem@sunset.davemloft.net>
Date:   Fri Mar 17 13:23:56 2006 -0800

    [SPARC64] bbc_i2c: Fix cpu check and add missing module license.
    
    Should allow cheetah_plus cpu types and don't taint
    the kernel.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/sbus/char/bbc_i2c.c b/drivers/sbus/char/bbc_i2c.c
index 1c8b612d8234..3e156e005f2e 100644
--- a/drivers/sbus/char/bbc_i2c.c
+++ b/drivers/sbus/char/bbc_i2c.c
@@ -440,7 +440,8 @@ static int __init bbc_i2c_init(void)
 	struct linux_ebus_device *edev = NULL;
 	int err, index = 0;
 
-	if (tlb_type != cheetah || !bbc_present())
+	if ((tlb_type != cheetah && tlb_type != cheetah_plus) ||
+	    !bbc_present())
 		return -ENODEV;
 
 	for_each_ebus(ebus) {
@@ -486,3 +487,4 @@ static void bbc_i2c_cleanup(void)
 
 module_init(bbc_i2c_init);
 module_exit(bbc_i2c_cleanup);
+MODULE_LICENSE("GPL");

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/sbus/char/bbc_i2c.c b/drivers/sbus/char/bbc_i2c.c
new file mode 100644
index 000000000000..1c8b612d8234
--- /dev/null
+++ b/drivers/sbus/char/bbc_i2c.c
@@ -0,0 +1,488 @@
+/* $Id: bbc_i2c.c,v 1.2 2001/04/02 09:59:08 davem Exp $
+ * bbc_i2c.c: I2C low-level driver for BBC device on UltraSPARC-III
+ *            platforms.
+ *
+ * Copyright (C) 2001 David S. Miller (davem@redhat.com)
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/slab.h>
+#include <linux/sched.h>
+#include <linux/wait.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <asm/oplib.h>
+#include <asm/ebus.h>
+#include <asm/spitfire.h>
+#include <asm/bbc.h>
+
+#include "bbc_i2c.h"
+
+/* Convert this driver to use i2c bus layer someday... */
+#define I2C_PCF_PIN	0x80
+#define I2C_PCF_ESO	0x40
+#define I2C_PCF_ES1	0x20
+#define I2C_PCF_ES2	0x10
+#define I2C_PCF_ENI	0x08
+#define I2C_PCF_STA	0x04
+#define I2C_PCF_STO	0x02
+#define I2C_PCF_ACK	0x01
+
+#define I2C_PCF_START    (I2C_PCF_PIN | I2C_PCF_ESO | I2C_PCF_ENI | I2C_PCF_STA | I2C_PCF_ACK)
+#define I2C_PCF_STOP     (I2C_PCF_PIN | I2C_PCF_ESO | I2C_PCF_STO | I2C_PCF_ACK)
+#define I2C_PCF_REPSTART (              I2C_PCF_ESO | I2C_PCF_STA | I2C_PCF_ACK)
+#define I2C_PCF_IDLE     (I2C_PCF_PIN | I2C_PCF_ESO               | I2C_PCF_ACK)
+
+#define I2C_PCF_INI 0x40   /* 1 if not initialized */
+#define I2C_PCF_STS 0x20
+#define I2C_PCF_BER 0x10
+#define I2C_PCF_AD0 0x08
+#define I2C_PCF_LRB 0x08
+#define I2C_PCF_AAS 0x04
+#define I2C_PCF_LAB 0x02
+#define I2C_PCF_BB  0x01
+
+/* The BBC devices have two I2C controllers.  The first I2C controller
+ * connects mainly to configuration proms (NVRAM, cpu configuration,
+ * dimm types, etc.).  Whereas the second I2C controller connects to
+ * environmental control devices such as fans and temperature sensors.
+ * The second controller also connects to the smartcard reader, if present.
+ */
+
+#define NUM_CHILDREN	8
+struct bbc_i2c_bus {
+	struct bbc_i2c_bus		*next;
+	int				index;
+	spinlock_t			lock;
+	void				__iomem *i2c_bussel_reg;
+	void				__iomem *i2c_control_regs;
+	unsigned char			own, clock;
+
+	wait_queue_head_t		wq;
+	volatile int			waiting;
+
+	struct linux_ebus_device	*bus_edev;
+	struct {
+		struct linux_ebus_child	*device;
+		int			client_claimed;
+	} devs[NUM_CHILDREN];
+};
+
+static struct bbc_i2c_bus *all_bbc_i2c;
+
+struct bbc_i2c_client {
+	struct bbc_i2c_bus	*bp;
+	struct linux_ebus_child	*echild;
+	int			bus;
+	int			address;
+};
+
+static int find_device(struct bbc_i2c_bus *bp, struct linux_ebus_child *echild)
+{
+	int i;
+
+	for (i = 0; i < NUM_CHILDREN; i++) {
+		if (bp->devs[i].device == echild) {
+			if (bp->devs[i].client_claimed)
+				return 0;
+			return 1;
+		}
+	}
+	return 0;
+}
+
+static void set_device_claimage(struct bbc_i2c_bus *bp, struct linux_ebus_child *echild, int val)
+{
+	int i;
+
+	for (i = 0; i < NUM_CHILDREN; i++) {
+		if (bp->devs[i].device == echild) {
+			bp->devs[i].client_claimed = val;
+			return;
+		}
+	}
+}
+
+#define claim_device(BP,ECHILD)		set_device_claimage(BP,ECHILD,1)
+#define release_device(BP,ECHILD)	set_device_claimage(BP,ECHILD,0)
+
+static struct bbc_i2c_bus *find_bus_for_device(struct linux_ebus_child *echild)
+{
+	struct bbc_i2c_bus *bp = all_bbc_i2c;
+
+	while (bp != NULL) {
+		if (find_device(bp, echild) != 0)
+			break;
+		bp = bp->next;
+	}
+
+	return bp;
+}
+
+struct linux_ebus_child *bbc_i2c_getdev(int index)
+{
+	struct bbc_i2c_bus *bp = all_bbc_i2c;
+	struct linux_ebus_child *echild = NULL;
+	int curidx = 0;
+
+	while (bp != NULL) {
+		struct bbc_i2c_bus *next = bp->next;
+		int i;
+
+		for (i = 0; i < NUM_CHILDREN; i++) {
+			if (!(echild = bp->devs[i].device))
+				break;
+			if (curidx == index)
+				goto out;
+			echild = NULL;
+			curidx++;
+		}
+		bp = next;
+	}
+out:
+	if (curidx == index)
+		return echild;
+	return NULL;
+}
+
+struct bbc_i2c_client *bbc_i2c_attach(struct linux_ebus_child *echild)
+{
+	struct bbc_i2c_bus *bp = find_bus_for_device(echild);
+	struct bbc_i2c_client *client;
+
+	if (!bp)
+		return NULL;
+	client = kmalloc(sizeof(*client), GFP_KERNEL);
+	if (!client)
+		return NULL;
+	memset(client, 0, sizeof(*client));
+	client->bp = bp;
+	client->echild = echild;
+	client->bus = echild->resource[0].start;
+	client->address = echild->resource[1].start;
+
+	claim_device(bp, echild);
+
+	return client;
+}
+
+void bbc_i2c_detach(struct bbc_i2c_client *client)
+{
+	struct bbc_i2c_bus *bp = client->bp;
+	struct linux_ebus_child *echild = client->echild;
+
+	release_device(bp, echild);
+	kfree(client);
+}
+
+static int wait_for_pin(struct bbc_i2c_bus *bp, u8 *status)
+{
+	DECLARE_WAITQUEUE(wait, current);
+	int limit = 32;
+	int ret = 1;
+
+	bp->waiting = 1;
+	add_wait_queue(&bp->wq, &wait);
+	while (limit-- > 0) {
+		u8 val;
+
+		set_current_state(TASK_INTERRUPTIBLE);
+		*status = val = readb(bp->i2c_control_regs + 0);
+		if ((val & I2C_PCF_PIN) == 0) {
+			ret = 0;
+			break;
+		}
+		msleep_interruptible(250);
+	}
+	remove_wait_queue(&bp->wq, &wait);
+	bp->waiting = 0;
+	current->state = TASK_RUNNING;
+
+	return ret;
+}
+
+int bbc_i2c_writeb(struct bbc_i2c_client *client, unsigned char val, int off)
+{
+	struct bbc_i2c_bus *bp = client->bp;
+	int address = client->address;
+	u8 status;
+	int ret = -1;
+
+	if (bp->i2c_bussel_reg != NULL)
+		writeb(client->bus, bp->i2c_bussel_reg);
+
+	writeb(address, bp->i2c_control_regs + 0x1);
+	writeb(I2C_PCF_START, bp->i2c_control_regs + 0x0);
+	if (wait_for_pin(bp, &status))
+		goto out;
+
+	writeb(off, bp->i2c_control_regs + 0x1);
+	if (wait_for_pin(bp, &status) ||
+	    (status & I2C_PCF_LRB) != 0)
+		goto out;
+
+	writeb(val, bp->i2c_control_regs + 0x1);
+	if (wait_for_pin(bp, &status))
+		goto out;
+
+	ret = 0;
+
+out:
+	writeb(I2C_PCF_STOP, bp->i2c_control_regs + 0x0);
+	return ret;
+}
+
+int bbc_i2c_readb(struct bbc_i2c_client *client, unsigned char *byte, int off)
+{
+	struct bbc_i2c_bus *bp = client->bp;
+	unsigned char address = client->address, status;
+	int ret = -1;
+
+	if (bp->i2c_bussel_reg != NULL)
+		writeb(client->bus, bp->i2c_bussel_reg);
+
+	writeb(address, bp->i2c_control_regs + 0x1);
+	writeb(I2C_PCF_START, bp->i2c_control_regs + 0x0);
+	if (wait_for_pin(bp, &status))
+		goto out;
+
+	writeb(off, bp->i2c_control_regs + 0x1);
+	if (wait_for_pin(bp, &status) ||
+	    (status & I2C_PCF_LRB) != 0)
+		goto out;
+
+	writeb(I2C_PCF_STOP, bp->i2c_control_regs + 0x0);
+
+	address |= 0x1; /* READ */
+
+	writeb(address, bp->i2c_control_regs + 0x1);
+	writeb(I2C_PCF_START, bp->i2c_control_regs + 0x0);
+	if (wait_for_pin(bp, &status))
+		goto out;
+
+	/* Set PIN back to one so the device sends the first
+	 * byte.
+	 */
+	(void) readb(bp->i2c_control_regs + 0x1);
+	if (wait_for_pin(bp, &status))
+		goto out;
+
+	writeb(I2C_PCF_ESO | I2C_PCF_ENI, bp->i2c_control_regs + 0x0);
+	*byte = readb(bp->i2c_control_regs + 0x1);
+	if (wait_for_pin(bp, &status))
+		goto out;
+
+	ret = 0;
+
+out:
+	writeb(I2C_PCF_STOP, bp->i2c_control_regs + 0x0);
+	(void) readb(bp->i2c_control_regs + 0x1);
+
+	return ret;
+}
+
+int bbc_i2c_write_buf(struct bbc_i2c_client *client,
+		      char *buf, int len, int off)
+{
+	int ret = 0;
+
+	while (len > 0) {
+		int err = bbc_i2c_writeb(client, *buf, off);
+
+		if (err < 0) {
+			ret = err;
+			break;
+		}
+
+		len--;
+		buf++;
+		off++;
+	}
+	return ret;
+}
+
+int bbc_i2c_read_buf(struct bbc_i2c_client *client,
+		     char *buf, int len, int off)
+{
+	int ret = 0;
+
+	while (len > 0) {
+		int err = bbc_i2c_readb(client, buf, off);
+		if (err < 0) {
+			ret = err;
+			break;
+		}
+		len--;
+		buf++;
+		off++;
+	}
+
+	return ret;
+}
+
+EXPORT_SYMBOL(bbc_i2c_getdev);
+EXPORT_SYMBOL(bbc_i2c_attach);
+EXPORT_SYMBOL(bbc_i2c_detach);
+EXPORT_SYMBOL(bbc_i2c_writeb);
+EXPORT_SYMBOL(bbc_i2c_readb);
+EXPORT_SYMBOL(bbc_i2c_write_buf);
+EXPORT_SYMBOL(bbc_i2c_read_buf);
+
+static irqreturn_t bbc_i2c_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct bbc_i2c_bus *bp = dev_id;
+
+	/* PIN going from set to clear is the only event which
+	 * makes the i2c assert an interrupt.
+	 */
+	if (bp->waiting &&
+	    !(readb(bp->i2c_control_regs + 0x0) & I2C_PCF_PIN))
+		wake_up(&bp->wq);
+
+	return IRQ_HANDLED;
+}
+
+static void __init reset_one_i2c(struct bbc_i2c_bus *bp)
+{
+	writeb(I2C_PCF_PIN, bp->i2c_control_regs + 0x0);
+	writeb(bp->own, bp->i2c_control_regs + 0x1);
+	writeb(I2C_PCF_PIN | I2C_PCF_ES1, bp->i2c_control_regs + 0x0);
+	writeb(bp->clock, bp->i2c_control_regs + 0x1);
+	writeb(I2C_PCF_IDLE, bp->i2c_control_regs + 0x0);
+}
+
+static int __init attach_one_i2c(struct linux_ebus_device *edev, int index)
+{
+	struct bbc_i2c_bus *bp = kmalloc(sizeof(*bp), GFP_KERNEL);
+	struct linux_ebus_child *echild;
+	int entry;
+
+	if (!bp)
+		return -ENOMEM;
+	memset(bp, 0, sizeof(*bp));
+
+	bp->i2c_control_regs = ioremap(edev->resource[0].start, 0x2);
+	if (!bp->i2c_control_regs)
+		goto fail;
+
+	if (edev->num_addrs == 2) {
+		bp->i2c_bussel_reg = ioremap(edev->resource[1].start, 0x1);
+		if (!bp->i2c_bussel_reg)
+			goto fail;
+	}
+
+	bp->waiting = 0;
+	init_waitqueue_head(&bp->wq);
+	if (request_irq(edev->irqs[0], bbc_i2c_interrupt,
+			SA_SHIRQ, "bbc_i2c", bp))
+		goto fail;
+
+	bp->index = index;
+	bp->bus_edev = edev;
+
+	spin_lock_init(&bp->lock);
+	bp->next = all_bbc_i2c;
+	all_bbc_i2c = bp;
+
+	entry = 0;
+	for (echild = edev->children;
+	     echild && entry < 8;
+	     echild = echild->next, entry++) {
+		bp->devs[entry].device = echild;
+		bp->devs[entry].client_claimed = 0;
+	}
+
+	writeb(I2C_PCF_PIN, bp->i2c_control_regs + 0x0);
+	bp->own = readb(bp->i2c_control_regs + 0x01);
+	writeb(I2C_PCF_PIN | I2C_PCF_ES1, bp->i2c_control_regs + 0x0);
+	bp->clock = readb(bp->i2c_control_regs + 0x01);
+
+	printk(KERN_INFO "i2c-%d: Regs at %p, %d devices, own %02x, clock %02x.\n",
+	       bp->index, bp->i2c_control_regs, entry, bp->own, bp->clock);
+
+	reset_one_i2c(bp);
+
+	return 0;
+
+fail:
+	if (bp->i2c_bussel_reg)
+		iounmap(bp->i2c_bussel_reg);
+	if (bp->i2c_control_regs)
+		iounmap(bp->i2c_control_regs);
+	kfree(bp);
+	return -EINVAL;
+}
+
+static int __init bbc_present(void)
+{
+	struct linux_ebus *ebus = NULL;
+	struct linux_ebus_device *edev = NULL;
+
+	for_each_ebus(ebus) {
+		for_each_ebusdev(edev, ebus) {
+			if (!strcmp(edev->prom_name, "bbc"))
+				return 1;
+		}
+	}
+	return 0;
+}
+
+extern int bbc_envctrl_init(void);
+extern void bbc_envctrl_cleanup(void);
+static void bbc_i2c_cleanup(void);
+
+static int __init bbc_i2c_init(void)
+{
+	struct linux_ebus *ebus = NULL;
+	struct linux_ebus_device *edev = NULL;
+	int err, index = 0;
+
+	if (tlb_type != cheetah || !bbc_present())
+		return -ENODEV;
+
+	for_each_ebus(ebus) {
+		for_each_ebusdev(edev, ebus) {
+			if (!strcmp(edev->prom_name, "i2c")) {
+				if (!attach_one_i2c(edev, index))
+					index++;
+			}
+		}
+	}
+
+	if (!index)
+		return -ENODEV;
+
+	err = bbc_envctrl_init();
+	if (err)
+		bbc_i2c_cleanup();
+	return err;
+}
+
+static void bbc_i2c_cleanup(void)
+{
+	struct bbc_i2c_bus *bp = all_bbc_i2c;
+
+	bbc_envctrl_cleanup();
+
+	while (bp != NULL) {
+		struct bbc_i2c_bus *next = bp->next;
+
+		free_irq(bp->bus_edev->irqs[0], bp);
+
+		if (bp->i2c_bussel_reg)
+			iounmap(bp->i2c_bussel_reg);
+		if (bp->i2c_control_regs)
+			iounmap(bp->i2c_control_regs);
+
+		kfree(bp);
+
+		bp = next;
+	}
+	all_bbc_i2c = NULL;
+}
+
+module_init(bbc_i2c_init);
+module_exit(bbc_i2c_cleanup);
