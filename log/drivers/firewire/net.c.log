commit c305c6ae79e2ce20c22660ceda94f0d86d639a82
Author: Eric Dumazet <edumazet@google.com>
Date:   Thu Nov 7 18:29:11 2019 -0800

    net: add annotations on hh->hh_len lockless accesses
    
    KCSAN reported a data-race [1]
    
    While we can use READ_ONCE() on the read sides,
    we need to make sure hh->hh_len is written last.
    
    [1]
    
    BUG: KCSAN: data-race in eth_header_cache / neigh_resolve_output
    
    write to 0xffff8880b9dedcb8 of 4 bytes by task 29760 on cpu 0:
     eth_header_cache+0xa9/0xd0 net/ethernet/eth.c:247
     neigh_hh_init net/core/neighbour.c:1463 [inline]
     neigh_resolve_output net/core/neighbour.c:1480 [inline]
     neigh_resolve_output+0x415/0x470 net/core/neighbour.c:1470
     neigh_output include/net/neighbour.h:511 [inline]
     ip6_finish_output2+0x7a2/0xec0 net/ipv6/ip6_output.c:116
     __ip6_finish_output net/ipv6/ip6_output.c:142 [inline]
     __ip6_finish_output+0x2d7/0x330 net/ipv6/ip6_output.c:127
     ip6_finish_output+0x41/0x160 net/ipv6/ip6_output.c:152
     NF_HOOK_COND include/linux/netfilter.h:294 [inline]
     ip6_output+0xf2/0x280 net/ipv6/ip6_output.c:175
     dst_output include/net/dst.h:436 [inline]
     NF_HOOK include/linux/netfilter.h:305 [inline]
     ndisc_send_skb+0x459/0x5f0 net/ipv6/ndisc.c:505
     ndisc_send_ns+0x207/0x430 net/ipv6/ndisc.c:647
     rt6_probe_deferred+0x98/0xf0 net/ipv6/route.c:615
     process_one_work+0x3d4/0x890 kernel/workqueue.c:2269
     worker_thread+0xa0/0x800 kernel/workqueue.c:2415
     kthread+0x1d4/0x200 drivers/block/aoe/aoecmd.c:1253
     ret_from_fork+0x1f/0x30 arch/x86/entry/entry_64.S:352
    
    read to 0xffff8880b9dedcb8 of 4 bytes by task 29572 on cpu 1:
     neigh_resolve_output net/core/neighbour.c:1479 [inline]
     neigh_resolve_output+0x113/0x470 net/core/neighbour.c:1470
     neigh_output include/net/neighbour.h:511 [inline]
     ip6_finish_output2+0x7a2/0xec0 net/ipv6/ip6_output.c:116
     __ip6_finish_output net/ipv6/ip6_output.c:142 [inline]
     __ip6_finish_output+0x2d7/0x330 net/ipv6/ip6_output.c:127
     ip6_finish_output+0x41/0x160 net/ipv6/ip6_output.c:152
     NF_HOOK_COND include/linux/netfilter.h:294 [inline]
     ip6_output+0xf2/0x280 net/ipv6/ip6_output.c:175
     dst_output include/net/dst.h:436 [inline]
     NF_HOOK include/linux/netfilter.h:305 [inline]
     ndisc_send_skb+0x459/0x5f0 net/ipv6/ndisc.c:505
     ndisc_send_ns+0x207/0x430 net/ipv6/ndisc.c:647
     rt6_probe_deferred+0x98/0xf0 net/ipv6/route.c:615
     process_one_work+0x3d4/0x890 kernel/workqueue.c:2269
     worker_thread+0xa0/0x800 kernel/workqueue.c:2415
     kthread+0x1d4/0x200 drivers/block/aoe/aoecmd.c:1253
     ret_from_fork+0x1f/0x30 arch/x86/entry/entry_64.S:352
    
    Reported by Kernel Concurrency Sanitizer on:
    CPU: 1 PID: 29572 Comm: kworker/1:4 Not tainted 5.4.0-rc6+ #0
    Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011
    Workqueue: events rt6_probe_deferred
    
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Reported-by: syzbot <syzkaller@googlegroups.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index b132ab9ad607..715e491dfbc3 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -250,7 +250,11 @@ static int fwnet_header_cache(const struct neighbour *neigh,
 	h = (struct fwnet_header *)((u8 *)hh->hh_data + HH_DATA_OFF(sizeof(*h)));
 	h->h_proto = type;
 	memcpy(h->h_dest, neigh->ha, net->addr_len);
-	hh->hh_len = FWNET_HLEN;
+
+	/* Pairs with the READ_ONCE() in neigh_resolve_output(),
+	 * neigh_hh_output() and neigh_update_hhs().
+	 */
+	smp_store_release(&hh->hh_len, FWNET_HLEN);
 
 	return 0;
 }

commit 09c434b8a0047c69e48499de0107de312901e798
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 13:08:20 2019 +0100

    treewide: Add SPDX license identifier for more missed files
    
    Add SPDX license identifiers to all files which:
    
     - Have no license information of any form
    
     - Have MODULE_LICENCE("GPL*") inside which was used in the initial
       scan/conversion to ignore the file
    
    These files fall under the project license, GPL v2 only. The resulting SPDX
    license identifier is:
    
      GPL-2.0-only
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index 82ba110d9d1a..b132ab9ad607 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * IPv4 over IEEE 1394, per RFC 2734
  * IPv6 over IEEE 1394, per RFC 3146

commit 6da2ec56059c3c7a7e5f729e6349e74ace1e5c57
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Jun 12 13:55:00 2018 -0700

    treewide: kmalloc() -> kmalloc_array()
    
    The kmalloc() function has a 2-factor argument form, kmalloc_array(). This
    patch replaces cases of:
    
            kmalloc(a * b, gfp)
    
    with:
            kmalloc_array(a * b, gfp)
    
    as well as handling cases of:
    
            kmalloc(a * b * c, gfp)
    
    with:
    
            kmalloc(array3_size(a, b, c), gfp)
    
    as it's slightly less ugly than:
    
            kmalloc_array(array_size(a, b), c, gfp)
    
    This does, however, attempt to ignore constant size factors like:
    
            kmalloc(4 * 1024, gfp)
    
    though any constants defined via macros get caught up in the conversion.
    
    Any factors with a sizeof() of "unsigned char", "char", and "u8" were
    dropped, since they're redundant.
    
    The tools/ directory was manually excluded, since it has its own
    implementation of kmalloc().
    
    The Coccinelle script used for this was:
    
    // Fix redundant parens around sizeof().
    @@
    type TYPE;
    expression THING, E;
    @@
    
    (
      kmalloc(
    -       (sizeof(TYPE)) * E
    +       sizeof(TYPE) * E
      , ...)
    |
      kmalloc(
    -       (sizeof(THING)) * E
    +       sizeof(THING) * E
      , ...)
    )
    
    // Drop single-byte sizes and redundant parens.
    @@
    expression COUNT;
    typedef u8;
    typedef __u8;
    @@
    
    (
      kmalloc(
    -       sizeof(u8) * (COUNT)
    +       COUNT
      , ...)
    |
      kmalloc(
    -       sizeof(__u8) * (COUNT)
    +       COUNT
      , ...)
    |
      kmalloc(
    -       sizeof(char) * (COUNT)
    +       COUNT
      , ...)
    |
      kmalloc(
    -       sizeof(unsigned char) * (COUNT)
    +       COUNT
      , ...)
    |
      kmalloc(
    -       sizeof(u8) * COUNT
    +       COUNT
      , ...)
    |
      kmalloc(
    -       sizeof(__u8) * COUNT
    +       COUNT
      , ...)
    |
      kmalloc(
    -       sizeof(char) * COUNT
    +       COUNT
      , ...)
    |
      kmalloc(
    -       sizeof(unsigned char) * COUNT
    +       COUNT
      , ...)
    )
    
    // 2-factor product with sizeof(type/expression) and identifier or constant.
    @@
    type TYPE;
    expression THING;
    identifier COUNT_ID;
    constant COUNT_CONST;
    @@
    
    (
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(TYPE) * (COUNT_ID)
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(TYPE) * COUNT_ID
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(TYPE) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(TYPE) * COUNT_CONST
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(THING) * (COUNT_ID)
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(THING) * COUNT_ID
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(THING) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(THING)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(THING) * COUNT_CONST
    +       COUNT_CONST, sizeof(THING)
      , ...)
    )
    
    // 2-factor product, only identifiers.
    @@
    identifier SIZE, COUNT;
    @@
    
    - kmalloc
    + kmalloc_array
      (
    -       SIZE * COUNT
    +       COUNT, SIZE
      , ...)
    
    // 3-factor product with 1 sizeof(type) or sizeof(expression), with
    // redundant parens removed.
    @@
    expression THING;
    identifier STRIDE, COUNT;
    type TYPE;
    @@
    
    (
      kmalloc(
    -       sizeof(TYPE) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kmalloc(
    -       sizeof(TYPE) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kmalloc(
    -       sizeof(TYPE) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kmalloc(
    -       sizeof(TYPE) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kmalloc(
    -       sizeof(THING) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kmalloc(
    -       sizeof(THING) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kmalloc(
    -       sizeof(THING) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kmalloc(
    -       sizeof(THING) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    )
    
    // 3-factor product with 2 sizeof(variable), with redundant parens removed.
    @@
    expression THING1, THING2;
    identifier COUNT;
    type TYPE1, TYPE2;
    @@
    
    (
      kmalloc(
    -       sizeof(TYPE1) * sizeof(TYPE2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      kmalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      kmalloc(
    -       sizeof(THING1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      kmalloc(
    -       sizeof(THING1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      kmalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    |
      kmalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    )
    
    // 3-factor product, only identifiers, with redundant parens removed.
    @@
    identifier STRIDE, SIZE, COUNT;
    @@
    
    (
      kmalloc(
    -       (COUNT) * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kmalloc(
    -       COUNT * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kmalloc(
    -       COUNT * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kmalloc(
    -       (COUNT) * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kmalloc(
    -       COUNT * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kmalloc(
    -       (COUNT) * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kmalloc(
    -       (COUNT) * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kmalloc(
    -       COUNT * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    )
    
    // Any remaining multi-factor products, first at least 3-factor products,
    // when they're not all constants...
    @@
    expression E1, E2, E3;
    constant C1, C2, C3;
    @@
    
    (
      kmalloc(C1 * C2 * C3, ...)
    |
      kmalloc(
    -       (E1) * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kmalloc(
    -       (E1) * (E2) * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kmalloc(
    -       (E1) * (E2) * (E3)
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kmalloc(
    -       E1 * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    )
    
    // And then all remaining 2 factors products when they're not all constants,
    // keeping sizeof() as the second factor argument.
    @@
    expression THING, E1, E2;
    type TYPE;
    constant C1, C2, C3;
    @@
    
    (
      kmalloc(sizeof(THING) * C2, ...)
    |
      kmalloc(sizeof(TYPE) * C2, ...)
    |
      kmalloc(C1 * C2 * C3, ...)
    |
      kmalloc(C1 * C2, ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(TYPE) * (E2)
    +       E2, sizeof(TYPE)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(TYPE) * E2
    +       E2, sizeof(TYPE)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(THING) * (E2)
    +       E2, sizeof(THING)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(THING) * E2
    +       E2, sizeof(THING)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       (E1) * E2
    +       E1, E2
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       (E1) * (E2)
    +       E1, E2
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       E1 * E2
    +       E1, E2
      , ...)
    )
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index 60e75e6d9104..82ba110d9d1a 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -1121,7 +1121,7 @@ static int fwnet_broadcast_start(struct fwnet_device *dev)
 	max_receive = 1U << (dev->card->max_receive + 1);
 	num_packets = (FWNET_ISO_PAGE_COUNT * PAGE_SIZE) / max_receive;
 
-	ptrptr = kmalloc(sizeof(void *) * num_packets, GFP_KERNEL);
+	ptrptr = kmalloc_array(num_packets, sizeof(void *), GFP_KERNEL);
 	if (!ptrptr) {
 		retval = -ENOMEM;
 		goto failed;

commit 4adf7bf7bbaefe71133305193c25d32863115dda
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Wed Nov 2 21:09:44 2016 +0100

    firewire: net: max MTU off by one
    
    The latest max_mtu patch missed that datagram_size is actually one less
    than the datagram's Total Length.
    
    Fixes: 357f4aae859b ("firewire: net: really fix maximum possible MTU")
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index 242359c2d1f1..60e75e6d9104 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -1480,9 +1480,14 @@ static int fwnet_probe(struct fw_unit *unit,
 		goto out;
 	dev->local_fifo = dev->handler.offset;
 
+	/*
+	 * default MTU: RFC 2734 cl. 4, RFC 3146 cl. 4
+	 * maximum MTU: RFC 2734 cl. 4.2, fragment encapsulation header's
+	 *              maximum possible datagram_size + 1 = 0xfff + 1
+	 */
 	net->mtu = 1500U;
 	net->min_mtu = ETH_MIN_MTU;
-	net->max_mtu = 0xfff;
+	net->max_mtu = 4096U;
 
 	/* Set our hardware address while we're at it */
 	ha = (union fwnet_hwaddr *)net->dev_addr;

commit d58ff35122847a83ba55394e2ae3a1527b6febf5
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Fri Jun 16 14:29:23 2017 +0200

    networking: make skb_push & __skb_push return void pointers
    
    It seems like a historic accident that these return unsigned char *,
    and in many places that means casts are required, more often than not.
    
    Make these functions return void * and remove all the casts across
    the tree, adding a (u8 *) cast only where the unsigned char pointer
    was used directly, all done with the following spatch:
    
        @@
        expression SKB, LEN;
        typedef u8;
        identifier fn = { skb_push, __skb_push, skb_push_rcsum };
        @@
        - *(fn(SKB, LEN))
        + *(u8 *)fn(SKB, LEN)
    
        @@
        expression E, SKB, LEN;
        identifier fn = { skb_push, __skb_push, skb_push_rcsum };
        type T;
        @@
        - E = ((T *)(fn(SKB, LEN)))
        + E = fn(SKB, LEN)
    
        @@
        expression SKB, LEN;
        identifier fn = { skb_push, __skb_push, skb_push_rcsum };
        @@
        - fn(SKB, LEN)[0]
        + *(u8 *)fn(SKB, LEN)
    
    Note that the last part there converts from push(...)[0] to the
    more idiomatic *(u8 *)push(...).
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index d5040bbd34e8..242359c2d1f1 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -219,7 +219,7 @@ static int fwnet_header_create(struct sk_buff *skb, struct net_device *net,
 {
 	struct fwnet_header *h;
 
-	h = (struct fwnet_header *)skb_push(skb, sizeof(*h));
+	h = skb_push(skb, sizeof(*h));
 	put_unaligned_be16(type, &h->h_proto);
 
 	if (net->flags & (IFF_LOOPBACK | IFF_NOARP)) {
@@ -961,16 +961,14 @@ static int fwnet_send_packet(struct fwnet_packet_task *ptask)
 	tx_len = ptask->max_payload;
 	switch (fwnet_get_hdr_lf(&ptask->hdr)) {
 	case RFC2374_HDR_UNFRAG:
-		bufhdr = (struct rfc2734_header *)
-				skb_push(ptask->skb, RFC2374_UNFRAG_HDR_SIZE);
+		bufhdr = skb_push(ptask->skb, RFC2374_UNFRAG_HDR_SIZE);
 		put_unaligned_be32(ptask->hdr.w0, &bufhdr->w0);
 		break;
 
 	case RFC2374_HDR_FIRSTFRAG:
 	case RFC2374_HDR_INTFRAG:
 	case RFC2374_HDR_LASTFRAG:
-		bufhdr = (struct rfc2734_header *)
-				skb_push(ptask->skb, RFC2374_FRAG_HDR_SIZE);
+		bufhdr = skb_push(ptask->skb, RFC2374_FRAG_HDR_SIZE);
 		put_unaligned_be32(ptask->hdr.w0, &bufhdr->w0);
 		put_unaligned_be32(ptask->hdr.w1, &bufhdr->w1);
 		break;

commit 59ae1d127ac0ae404baf414c434ba2651b793f46
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Fri Jun 16 14:29:20 2017 +0200

    networking: introduce and use skb_put_data()
    
    A common pattern with skb_put() is to just want to memcpy()
    some data into the new space, introduce skb_put_data() for
    this.
    
    An spatch similar to the one for skb_put_zero() converts many
    of the places using it:
    
        @@
        identifier p, p2;
        expression len, skb, data;
        type t, t2;
        @@
        (
        -p = skb_put(skb, len);
        +p = skb_put_data(skb, data, len);
        |
        -p = (t)skb_put(skb, len);
        +p = skb_put_data(skb, data, len);
        )
        (
        p2 = (t2)p;
        -memcpy(p2, data, len);
        |
        -memcpy(p, data, len);
        )
    
        @@
        type t, t2;
        identifier p, p2;
        expression skb, data;
        @@
        t *p;
        ...
        (
        -p = skb_put(skb, sizeof(t));
        +p = skb_put_data(skb, data, sizeof(t));
        |
        -p = (t *)skb_put(skb, sizeof(t));
        +p = skb_put_data(skb, data, sizeof(t));
        )
        (
        p2 = (t2)p;
        -memcpy(p2, data, sizeof(*p));
        |
        -memcpy(p, data, sizeof(*p));
        )
    
        @@
        expression skb, len, data;
        @@
        -memcpy(skb_put(skb, len), data, len);
        +skb_put_data(skb, data, len);
    
    (again, manually post-processed to retain some comments)
    
    Reviewed-by: Stephen Hemminger <stephen@networkplumber.org>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index 5d3640264f2d..d5040bbd34e8 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -600,7 +600,7 @@ static int fwnet_incoming_packet(struct fwnet_device *dev, __be32 *buf, int len,
 			return -ENOMEM;
 		}
 		skb_reserve(skb, LL_RESERVED_SPACE(net));
-		memcpy(skb_put(skb, len), buf, len);
+		skb_put_data(skb, buf, len);
 
 		return fwnet_finish_incoming_packet(net, skb, source_node_id,
 						    is_broadcast, ether_type);

commit bb598c1b8c9bf56981927dcb8c0dc34b8ff95342
Merge: eb2ca35f1814 e76d21c40bd6
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Nov 15 10:54:36 2016 -0500

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    Several cases of bug fixes in 'net' overlapping other changes in
    'net-next-.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit e9300a4b7bbae83af1f7703938c94cf6dc6d308f
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sun Oct 30 17:32:01 2016 +0100

    firewire: net: fix fragmented datagram_size off-by-one
    
    RFC 2734 defines the datagram_size field in fragment encapsulation
    headers thus:
    
        datagram_size:  The encoded size of the entire IP datagram.  The
        value of datagram_size [...] SHALL be one less than the value of
        Total Length in the datagram's IP header (see STD 5, RFC 791).
    
    Accordingly, the eth1394 driver of Linux 2.6.36 and older set and got
    this field with a -/+1 offset:
    
        ether1394_tx() /* transmit */
            ether1394_encapsulate_prep()
                hdr->ff.dg_size = dg_size - 1;
    
        ether1394_data_handler() /* receive */
            if (hdr->common.lf == ETH1394_HDR_LF_FF)
                dg_size = hdr->ff.dg_size + 1;
            else
                dg_size = hdr->sf.dg_size + 1;
    
    Likewise, I observe OS X 10.4 and Windows XP Pro SP3 to transmit 1500
    byte sized datagrams in fragments with datagram_size=1499 if link
    fragmentation is required.
    
    Only firewire-net sets and gets datagram_size without this offset.  The
    result is lacking interoperability of firewire-net with OS X, Windows
    XP, and presumably Linux' eth1394.  (I did not test with the latter.)
    For example, FTP data transfers to a Linux firewire-net box with max_rec
    smaller than the 1500 bytes MTU
      - from OS X fail entirely,
      - from Win XP start out with a bunch of fragmented datagrams which
        time out, then continue with unfragmented datagrams because Win XP
        temporarily reduces the MTU to 576 bytes.
    
    So let's fix firewire-net's datagram_size accessors.
    
    Note that firewire-net thereby loses interoperability with unpatched
    firewire-net, but only if link fragmentation is employed.  (This happens
    with large broadcast datagrams, and with large datagrams on several
    FireWire CardBus cards with smaller max_rec than equivalent PCI cards,
    and it can be worked around by setting a small enough MTU.)
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index cbaa8d776d83..15475892af0c 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -73,13 +73,13 @@ struct rfc2734_header {
 
 #define fwnet_get_hdr_lf(h)		(((h)->w0 & 0xc0000000) >> 30)
 #define fwnet_get_hdr_ether_type(h)	(((h)->w0 & 0x0000ffff))
-#define fwnet_get_hdr_dg_size(h)	(((h)->w0 & 0x0fff0000) >> 16)
+#define fwnet_get_hdr_dg_size(h)	((((h)->w0 & 0x0fff0000) >> 16) + 1)
 #define fwnet_get_hdr_fg_off(h)		(((h)->w0 & 0x00000fff))
 #define fwnet_get_hdr_dgl(h)		(((h)->w1 & 0xffff0000) >> 16)
 
-#define fwnet_set_hdr_lf(lf)		((lf)  << 30)
+#define fwnet_set_hdr_lf(lf)		((lf) << 30)
 #define fwnet_set_hdr_ether_type(et)	(et)
-#define fwnet_set_hdr_dg_size(dgs)	((dgs) << 16)
+#define fwnet_set_hdr_dg_size(dgs)	(((dgs) - 1) << 16)
 #define fwnet_set_hdr_fg_off(fgo)	(fgo)
 
 #define fwnet_set_hdr_dgl(dgl)		((dgl) << 16)
@@ -622,7 +622,7 @@ static int fwnet_incoming_packet(struct fwnet_device *dev, __be32 *buf, int len,
 		fg_off = fwnet_get_hdr_fg_off(&hdr);
 	}
 	datagram_label = fwnet_get_hdr_dgl(&hdr);
-	dg_size = fwnet_get_hdr_dg_size(&hdr); /* ??? + 1 */
+	dg_size = fwnet_get_hdr_dg_size(&hdr);
 
 	if (fg_off + len > dg_size)
 		return 0;

commit 667121ace9dbafb368618dbabcf07901c962ddac
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sat Oct 29 21:28:18 2016 +0200

    firewire: net: guard against rx buffer overflows
    
    The IP-over-1394 driver firewire-net lacked input validation when
    handling incoming fragmented datagrams.  A maliciously formed fragment
    with a respectively large datagram_offset would cause a memcpy past the
    datagram buffer.
    
    So, drop any packets carrying a fragment with offset + length larger
    than datagram_size.
    
    In addition, ensure that
      - GASP header, unfragmented encapsulation header, or fragment
        encapsulation header actually exists before we access it,
      - the encapsulated datagram or fragment is of nonzero size.
    
    Reported-by: Eyal Itkin <eyal.itkin@gmail.com>
    Reviewed-by: Eyal Itkin <eyal.itkin@gmail.com>
    Fixes: CVE 2016-8633
    Cc: stable@vger.kernel.org
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index 309311b1faae..cbaa8d776d83 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -578,6 +578,9 @@ static int fwnet_incoming_packet(struct fwnet_device *dev, __be32 *buf, int len,
 	int retval;
 	u16 ether_type;
 
+	if (len <= RFC2374_UNFRAG_HDR_SIZE)
+		return 0;
+
 	hdr.w0 = be32_to_cpu(buf[0]);
 	lf = fwnet_get_hdr_lf(&hdr);
 	if (lf == RFC2374_HDR_UNFRAG) {
@@ -602,7 +605,12 @@ static int fwnet_incoming_packet(struct fwnet_device *dev, __be32 *buf, int len,
 		return fwnet_finish_incoming_packet(net, skb, source_node_id,
 						    is_broadcast, ether_type);
 	}
+
 	/* A datagram fragment has been received, now the fun begins. */
+
+	if (len <= RFC2374_FRAG_HDR_SIZE)
+		return 0;
+
 	hdr.w1 = ntohl(buf[1]);
 	buf += 2;
 	len -= RFC2374_FRAG_HDR_SIZE;
@@ -616,6 +624,9 @@ static int fwnet_incoming_packet(struct fwnet_device *dev, __be32 *buf, int len,
 	datagram_label = fwnet_get_hdr_dgl(&hdr);
 	dg_size = fwnet_get_hdr_dg_size(&hdr); /* ??? + 1 */
 
+	if (fg_off + len > dg_size)
+		return 0;
+
 	spin_lock_irqsave(&dev->lock, flags);
 
 	peer = fwnet_peer_find_by_node_id(dev, source_node_id, generation);
@@ -722,6 +733,22 @@ static void fwnet_receive_packet(struct fw_card *card, struct fw_request *r,
 	fw_send_response(card, r, rcode);
 }
 
+static int gasp_source_id(__be32 *p)
+{
+	return be32_to_cpu(p[0]) >> 16;
+}
+
+static u32 gasp_specifier_id(__be32 *p)
+{
+	return (be32_to_cpu(p[0]) & 0xffff) << 8 |
+	       (be32_to_cpu(p[1]) & 0xff000000) >> 24;
+}
+
+static u32 gasp_version(__be32 *p)
+{
+	return be32_to_cpu(p[1]) & 0xffffff;
+}
+
 static void fwnet_receive_broadcast(struct fw_iso_context *context,
 		u32 cycle, size_t header_length, void *header, void *data)
 {
@@ -731,9 +758,6 @@ static void fwnet_receive_broadcast(struct fw_iso_context *context,
 	__be32 *buf_ptr;
 	int retval;
 	u32 length;
-	u16 source_node_id;
-	u32 specifier_id;
-	u32 ver;
 	unsigned long offset;
 	unsigned long flags;
 
@@ -750,22 +774,17 @@ static void fwnet_receive_broadcast(struct fw_iso_context *context,
 
 	spin_unlock_irqrestore(&dev->lock, flags);
 
-	specifier_id =    (be32_to_cpu(buf_ptr[0]) & 0xffff) << 8
-			| (be32_to_cpu(buf_ptr[1]) & 0xff000000) >> 24;
-	ver = be32_to_cpu(buf_ptr[1]) & 0xffffff;
-	source_node_id = be32_to_cpu(buf_ptr[0]) >> 16;
-
-	if (specifier_id == IANA_SPECIFIER_ID &&
-	    (ver == RFC2734_SW_VERSION
+	if (length > IEEE1394_GASP_HDR_SIZE &&
+	    gasp_specifier_id(buf_ptr) == IANA_SPECIFIER_ID &&
+	    (gasp_version(buf_ptr) == RFC2734_SW_VERSION
 #if IS_ENABLED(CONFIG_IPV6)
-	     || ver == RFC3146_SW_VERSION
+	     || gasp_version(buf_ptr) == RFC3146_SW_VERSION
 #endif
-	    )) {
-		buf_ptr += 2;
-		length -= IEEE1394_GASP_HDR_SIZE;
-		fwnet_incoming_packet(dev, buf_ptr, length, source_node_id,
+	    ))
+		fwnet_incoming_packet(dev, buf_ptr + 2,
+				      length - IEEE1394_GASP_HDR_SIZE,
+				      gasp_source_id(buf_ptr),
 				      context->card->generation, true);
-	}
 
 	packet.payload_length = dev->rcv_buffer_size;
 	packet.interrupt = 1;

commit 357f4aae859b5d74554b0ccbb18556f1df4166c3
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sat Oct 29 22:16:58 2016 +0200

    firewire: net: really fix maximum possible MTU
    
    The maximum unicast datagram size /without/ link fragmentation is
    4096 - 4 = 4092 (max IEEE 1394 async payload size at >= S800 bus speed,
    minus unfragmented encapssulation header).  Max broadcast datagram size
    without fragmentation is 8 bytes less than that (due to GASP header).
    
    The maximum datagram size /with/ link fragmentation is 0xfff = 4095
    for unicast and broadcast.  This is because the RFC 2734 fragment
    encapsulation header field for datagram size is only 12 bits wide.
    
    Fixes: 5d48f00d836a('firewire: net: fix maximum possible MTU')
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index 03715e7d9d92..363fc5ec1a4e 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -1465,7 +1465,7 @@ static int fwnet_probe(struct fw_unit *unit,
 
 	net->mtu = 1500U;
 	net->min_mtu = ETH_MIN_MTU;
-	net->max_mtu = ETH_MAX_MTU;
+	net->max_mtu = 0xfff;
 
 	/* Set our hardware address while we're at it */
 	ha = (union fwnet_hwaddr *)net->dev_addr;

commit 89ab88b01bacc5bfc338693da3925504757e7844
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sun Oct 23 16:30:56 2016 +0200

    firewire: net: set initial MTU = 1500 unconditionally, fix IPv6 on some CardBus cards
    
    firewire-net, like the older eth1394 driver, reduced the initial MTU to
    less than 1500 octets if the local link layer controller's asynchronous
    packet reception limit was lower.
    
    This is bogus, since this reception limit does not have anything to do
    with the transmission limit.  Neither did this reduction affect the TX
    path positively, nor could it prevent link fragmentation at the RX path.
    
    Many FireWire CardBus cards have a max_rec of 9, causing an initial MTU
    of 1024 - 16 = 1008.  RFC 2734 and RFC 3146 allow a minimum max_rec = 8,
    which would result in an initial MTU of 512 - 16 = 496.  On such cards,
    IPv6 could only be employed if the MTU was manually increased to 1280 or
    more, i.e. IPv6 would not work without intervention from userland.
    
    We now always initialize the MTU to 1500, which is the default according
    to RFC 2734 and RFC 3146.
    
    On a VIA VT6316 based CardBus card which was affected by this, changing
    the MTU from 1008 to 1500 also increases TX bandwidth by 6 %.
    RX remains unaffected.
    
    CC: netdev@vger.kernel.org
    CC: linux1394-devel@lists.sourceforge.net
    CC: Jarod Wilson <jarod@redhat.com>
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index 99379542b263..03715e7d9d92 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -1463,13 +1463,7 @@ static int fwnet_probe(struct fw_unit *unit,
 		goto out;
 	dev->local_fifo = dev->handler.offset;
 
-	/*
-	 * Use the RFC 2734 default 1500 octets or the maximum payload
-	 * as initial MTU
-	 */
-	net->mtu = min(1500U,
-		       (1U << (card->max_receive + 1))
-		       - RFC2374_FRAG_HDR_SIZE - IEEE1394_GASP_HDR_SIZE);
+	net->mtu = 1500U;
 	net->min_mtu = ETH_MIN_MTU;
 	net->max_mtu = ETH_MAX_MTU;
 

commit 5d48f00d836a628c695c6e3f96881d73641f6a2f
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sun Oct 23 16:29:03 2016 +0200

    firewire: net: fix maximum possible MTU
    
    Commit b3e3893e1253 ("net: use core MTU range checking in misc drivers")
    mistakenly introduced an upper limit for firewire-net's MTU based on the
    local link layer controller's reception capability.  Revert this.  Neither
    RFC 2734 nor our implementation impose any particular upper limit.
    
    Actually, to be on the safe side and to make the code explicit, set
    ETH_MAX_MTU = 65535 as upper limit now.
    
    (I replaced sizeof(struct rfc2734_header) by the equivalent
    RFC2374_FRAG_HDR_SIZE in order to avoid distracting long/int conversions.)
    
    Fixes: b3e3893e1253('net: use core MTU range checking in misc drivers')
    CC: netdev@vger.kernel.org
    CC: linux1394-devel@lists.sourceforge.net
    CC: Jarod Wilson <jarod@redhat.com>
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>
    Acked-by: Jarod Wilson <jarod@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index 8430222151fc..99379542b263 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -1467,10 +1467,11 @@ static int fwnet_probe(struct fw_unit *unit,
 	 * Use the RFC 2734 default 1500 octets or the maximum payload
 	 * as initial MTU
 	 */
-	net->max_mtu = (1 << (card->max_receive + 1))
-		       - sizeof(struct rfc2734_header) - IEEE1394_GASP_HDR_SIZE;
-	net->mtu = min(1500U, net->max_mtu);
+	net->mtu = min(1500U,
+		       (1U << (card->max_receive + 1))
+		       - RFC2374_FRAG_HDR_SIZE - IEEE1394_GASP_HDR_SIZE);
 	net->min_mtu = ETH_MIN_MTU;
+	net->max_mtu = ETH_MAX_MTU;
 
 	/* Set our hardware address while we're at it */
 	ha = (union fwnet_hwaddr *)net->dev_addr;

commit b3e3893e1253692c3d2b8e8ebd5a26183ed30443
Author: Jarod Wilson <jarod@redhat.com>
Date:   Thu Oct 20 13:55:22 2016 -0400

    net: use core MTU range checking in misc drivers
    
    firewire-net:
    - set min/max_mtu
    - remove fwnet_change_mtu
    
    nes:
    - set max_mtu
    - clean up nes_netdev_change_mtu
    
    xpnet:
    - set min/max_mtu
    - remove xpnet_dev_change_mtu
    
    hippi:
    - set min/max_mtu
    - remove hippi_change_mtu
    
    batman-adv:
    - set max_mtu
    - remove batadv_interface_change_mtu
    - initialization is a little async, not 100% certain that max_mtu is set
      in the optimal place, don't have hardware to test with
    
    rionet:
    - set min/max_mtu
    - remove rionet_change_mtu
    
    slip:
    - set min/max_mtu
    - streamline sl_change_mtu
    
    um/net_kern:
    - remove pointless ndo_change_mtu
    
    hsi/clients/ssi_protocol:
    - use core MTU range checking
    - remove now redundant ssip_pn_set_mtu
    
    ipoib:
    - set a default max MTU value
    - Note: ipoib's actual max MTU can vary, depending on if the device is in
      connected mode or not, so we'll just set the max_mtu value to the max
      possible, and let the ndo_change_mtu function continue to validate any new
      MTU change requests with checks for CM or not. Note that ipoib has no
      min_mtu set, and thus, the network core's mtu > 0 check is the only lower
      bounds here.
    
    mptlan:
    - use net core MTU range checking
    - remove now redundant mpt_lan_change_mtu
    
    fddi:
    - min_mtu = 21, max_mtu = 4470
    - remove now redundant fddi_change_mtu (including export)
    
    fjes:
    - min_mtu = 8192, max_mtu = 65536
    - The max_mtu value is actually one over IP_MAX_MTU here, but the idea is to
      get past the core net MTU range checks so fjes_change_mtu can validate a
      new MTU against what it supports (see fjes_support_mtu in fjes_hw.c)
    
    hsr:
    - min_mtu = 0 (calls ether_setup, max_mtu is 1500)
    
    f_phonet:
    - min_mtu = 6, max_mtu = 65541
    
    u_ether:
    - min_mtu = 14, max_mtu = 15412
    
    phonet/pep-gprs:
    - min_mtu = 576, max_mtu = 65530
    - remove redundant gprs_set_mtu
    
    CC: netdev@vger.kernel.org
    CC: linux-rdma@vger.kernel.org
    CC: Stefan Richter <stefanr@s5r6.in-berlin.de>
    CC: Faisal Latif <faisal.latif@intel.com>
    CC: linux-rdma@vger.kernel.org
    CC: Cliff Whickman <cpw@sgi.com>
    CC: Robin Holt <robinmholt@gmail.com>
    CC: Jes Sorensen <jes@trained-monkey.org>
    CC: Marek Lindner <mareklindner@neomailbox.ch>
    CC: Simon Wunderlich <sw@simonwunderlich.de>
    CC: Antonio Quartulli <a@unstable.cc>
    CC: Sathya Prakash <sathya.prakash@broadcom.com>
    CC: Chaitra P B <chaitra.basappa@broadcom.com>
    CC: Suganath Prabu Subramani <suganath-prabu.subramani@broadcom.com>
    CC: MPT-FusionLinux.pdl@broadcom.com
    CC: Sebastian Reichel <sre@kernel.org>
    CC: Felipe Balbi <balbi@kernel.org>
    CC: Arvid Brodin <arvid.brodin@alten.se>
    CC: Remi Denis-Courmont <courmisch@gmail.com>
    Signed-off-by: Jarod Wilson <jarod@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index 309311b1faae..8430222151fc 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -1349,15 +1349,6 @@ static netdev_tx_t fwnet_tx(struct sk_buff *skb, struct net_device *net)
 	return NETDEV_TX_OK;
 }
 
-static int fwnet_change_mtu(struct net_device *net, int new_mtu)
-{
-	if (new_mtu < 68)
-		return -EINVAL;
-
-	net->mtu = new_mtu;
-	return 0;
-}
-
 static const struct ethtool_ops fwnet_ethtool_ops = {
 	.get_link	= ethtool_op_get_link,
 };
@@ -1366,7 +1357,6 @@ static const struct net_device_ops fwnet_netdev_ops = {
 	.ndo_open       = fwnet_open,
 	.ndo_stop	= fwnet_stop,
 	.ndo_start_xmit = fwnet_tx,
-	.ndo_change_mtu = fwnet_change_mtu,
 };
 
 static void fwnet_init_dev(struct net_device *net)
@@ -1435,7 +1425,6 @@ static int fwnet_probe(struct fw_unit *unit,
 	struct net_device *net;
 	bool allocated_netdev = false;
 	struct fwnet_device *dev;
-	unsigned max_mtu;
 	int ret;
 	union fwnet_hwaddr *ha;
 
@@ -1478,9 +1467,10 @@ static int fwnet_probe(struct fw_unit *unit,
 	 * Use the RFC 2734 default 1500 octets or the maximum payload
 	 * as initial MTU
 	 */
-	max_mtu = (1 << (card->max_receive + 1))
-		  - sizeof(struct rfc2734_header) - IEEE1394_GASP_HDR_SIZE;
-	net->mtu = min(1500U, max_mtu);
+	net->max_mtu = (1 << (card->max_receive + 1))
+		       - sizeof(struct rfc2734_header) - IEEE1394_GASP_HDR_SIZE;
+	net->mtu = min(1500U, net->max_mtu);
+	net->min_mtu = ETH_MIN_MTU;
 
 	/* Set our hardware address while we're at it */
 	ha = (union fwnet_hwaddr *)net->dev_addr;

commit 860e9538a9482bb84589f7d0718a7e6d0a944d58
Author: Florian Westphal <fw@strlen.de>
Date:   Tue May 3 16:33:13 2016 +0200

    treewide: replace dev->trans_start update with helper
    
    Replace all trans_start updates with netif_trans_update helper.
    change was done via spatch:
    
    struct net_device *d;
    @@
    - d->trans_start = jiffies
    + netif_trans_update(d)
    
    Compile tested only.
    
    Cc: user-mode-linux-devel@lists.sourceforge.net
    Cc: linux-xtensa@linux-xtensa.org
    Cc: linux1394-devel@lists.sourceforge.net
    Cc: linux-rdma@vger.kernel.org
    Cc: netdev@vger.kernel.org
    Cc: MPT-FusionLinux.pdl@broadcom.com
    Cc: linux-scsi@vger.kernel.org
    Cc: linux-can@vger.kernel.org
    Cc: linux-parisc@vger.kernel.org
    Cc: linux-omap@vger.kernel.org
    Cc: linux-hams@vger.kernel.org
    Cc: linux-usb@vger.kernel.org
    Cc: linux-wireless@vger.kernel.org
    Cc: linux-s390@vger.kernel.org
    Cc: devel@driverdev.osuosl.org
    Cc: b.a.t.m.a.n@lists.open-mesh.org
    Cc: linux-bluetooth@vger.kernel.org
    Signed-off-by: Florian Westphal <fw@strlen.de>
    Acked-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Acked-by: Mugunthan V N <mugunthanvnm@ti.com>
    Acked-by: Antonio Quartulli <a@unstable.cc>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index f4ea80d602f7..309311b1faae 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -1023,7 +1023,7 @@ static int fwnet_send_packet(struct fwnet_packet_task *ptask)
 
 	spin_unlock_irqrestore(&dev->lock, flags);
 
-	dev->netdev->trans_start = jiffies;
+	netif_trans_update(dev->netdev);
  out:
 	if (free)
 		fwnet_free_ptask(ptask);

commit d476059e77d1af48453a58f9de1e36f2eaff6450
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Mon Mar 2 00:11:09 2015 -0600

    net: Kill dev_rebuild_header
    
    Now that there are no more users kill dev_rebuild_header and all of it's
    implementations.
    
    This is long overdue.
    
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index 2c68da1ceeee..f4ea80d602f7 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -237,18 +237,6 @@ static int fwnet_header_create(struct sk_buff *skb, struct net_device *net,
 	return -net->hard_header_len;
 }
 
-static int fwnet_header_rebuild(struct sk_buff *skb)
-{
-	struct fwnet_header *h = (struct fwnet_header *)skb->data;
-
-	if (get_unaligned_be16(&h->h_proto) == ETH_P_IP)
-		return arp_find((unsigned char *)&h->h_dest, skb);
-
-	dev_notice(&skb->dev->dev, "unable to resolve type %04x addresses\n",
-		   be16_to_cpu(h->h_proto));
-	return 0;
-}
-
 static int fwnet_header_cache(const struct neighbour *neigh,
 			      struct hh_cache *hh, __be16 type)
 {
@@ -282,7 +270,6 @@ static int fwnet_header_parse(const struct sk_buff *skb, unsigned char *haddr)
 
 static const struct header_ops fwnet_header_ops = {
 	.create         = fwnet_header_create,
-	.rebuild        = fwnet_header_rebuild,
 	.cache		= fwnet_header_cache,
 	.cache_update	= fwnet_header_cache_update,
 	.parse          = fwnet_header_parse,

commit c835a677331495cf137a7f8a023463afd9f032f8
Author: Tom Gundersen <teg@jklm.no>
Date:   Mon Jul 14 16:37:24 2014 +0200

    net: set name_assign_type in alloc_netdev()
    
    Extend alloc_netdev{,_mq{,s}}() to take name_assign_type as argument, and convert
    all users to pass NET_NAME_UNKNOWN.
    
    Coccinelle patch:
    
    @@
    expression sizeof_priv, name, setup, txqs, rxqs, count;
    @@
    
    (
    -alloc_netdev_mqs(sizeof_priv, name, setup, txqs, rxqs)
    +alloc_netdev_mqs(sizeof_priv, name, NET_NAME_UNKNOWN, setup, txqs, rxqs)
    |
    -alloc_netdev_mq(sizeof_priv, name, setup, count)
    +alloc_netdev_mq(sizeof_priv, name, NET_NAME_UNKNOWN, setup, count)
    |
    -alloc_netdev(sizeof_priv, name, setup)
    +alloc_netdev(sizeof_priv, name, NET_NAME_UNKNOWN, setup)
    )
    
    v9: move comments here from the wrong commit
    
    Signed-off-by: Tom Gundersen <teg@jklm.no>
    Reviewed-by: David Herrmann <dh.herrmann@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index c3986452194d..2c68da1ceeee 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -1460,7 +1460,8 @@ static int fwnet_probe(struct fw_unit *unit,
 		goto have_dev;
 	}
 
-	net = alloc_netdev(sizeof(*dev), "firewire%d", fwnet_init_dev);
+	net = alloc_netdev(sizeof(*dev), "firewire%d", NET_NAME_UNKNOWN,
+			   fwnet_init_dev);
 	if (net == NULL) {
 		mutex_unlock(&fwnet_device_mutex);
 		return -ENOMEM;

commit 1118f8d048dd595efbadf05e8bca4e19684ffb4d
Author: Daeseok Youn <daeseok.youn@gmail.com>
Date:   Tue Apr 29 18:49:47 2014 +0900

    firewire: net: fix NULL derefencing in fwnet_probe()
    
    "dev" and "net" are NULL when alloc_netdev() is failed.
    So just unlock and return an error.
    
    Signed-off-by: Daeseok Youn <daeseok.youn@gmail.com>
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index 4af0a7bad7f2..c3986452194d 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -1462,8 +1462,8 @@ static int fwnet_probe(struct fw_unit *unit,
 
 	net = alloc_netdev(sizeof(*dev), "firewire%d", fwnet_init_dev);
 	if (net == NULL) {
-		ret = -ENOMEM;
-		goto out;
+		mutex_unlock(&fwnet_device_mutex);
+		return -ENOMEM;
 	}
 
 	allocated_netdev = true;

commit 8987583366ae9e03c306c2b7d73bdb952df1d08d
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Tue Feb 18 22:25:15 2014 +0100

    firewire: net: fix use after free
    
    Commit 8408dc1c14c1 "firewire: net: use dev_printk API" introduced a
    use-after-free in a failure path.  fwnet_transmit_packet_failed(ptask)
    may free ptask, then the dev_err() call dereferenced it.  The fix is
    straightforward; simply reorder the two calls.
    
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Cc: stable@vger.kernel.org # v3.4+
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index 6b895986dc22..4af0a7bad7f2 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -929,8 +929,6 @@ static void fwnet_write_complete(struct fw_card *card, int rcode,
 	if (rcode == RCODE_COMPLETE) {
 		fwnet_transmit_packet_done(ptask);
 	} else {
-		fwnet_transmit_packet_failed(ptask);
-
 		if (printk_timed_ratelimit(&j,  1000) || rcode != last_rcode) {
 			dev_err(&ptask->dev->netdev->dev,
 				"fwnet_write_complete failed: %x (skipped %d)\n",
@@ -938,8 +936,10 @@ static void fwnet_write_complete(struct fw_card *card, int rcode,
 
 			errors_skipped = 0;
 			last_rcode = rcode;
-		} else
+		} else {
 			errors_skipped++;
+		}
+		fwnet_transmit_packet_failed(ptask);
 	}
 }
 

commit 94a87157cde95d38b9cdf1116e4f0fd93f6d25df
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sun Jun 9 18:15:00 2013 +0200

    firewire: introduce fw_driver.probe and .remove methods
    
    FireWire upper layer drivers are converted from generic
        struct driver.probe() and .remove()
    to bus-specific
        struct fw_driver.probe() and .remove().
    
    The new .probe() adds a const struct ieee1394_device_id *id argument,
    indicating the entry in the driver's device identifiers table which
    matched the fw_unit to be probed.  This new argument is used by the
    snd-firewire-speakers driver to look up device-specific parameters and
    methods.  There is at least one other FireWire audio driver currently in
    development in which this will be useful too.
    
    The new .remove() drops the unused error return code.
    
    Although all in-tree drivers are being converted to the new methods,
    support for the old methods is left in place in this commit.  This
    allows public developer trees to merge this commit and then move to the
    new fw_driver methods.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>
    Acked-by: Clemens Ladisch <clemens@ladisch.de> (for sound/firewire/)
    Cc: Peter Hurley <peter@hurleysoftware.com> (for drivers/staging/fwserial/)

diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index 815b0fcbe918..6b895986dc22 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -1440,9 +1440,9 @@ static int fwnet_add_peer(struct fwnet_device *dev,
 	return 0;
 }
 
-static int fwnet_probe(struct device *_dev)
+static int fwnet_probe(struct fw_unit *unit,
+		       const struct ieee1394_device_id *id)
 {
-	struct fw_unit *unit = fw_unit(_dev);
 	struct fw_device *device = fw_parent_device(unit);
 	struct fw_card *card = device->card;
 	struct net_device *net;
@@ -1526,6 +1526,24 @@ static int fwnet_probe(struct device *_dev)
 	return ret;
 }
 
+/*
+ * FIXME abort partially sent fragmented datagrams,
+ * discard partially received fragmented datagrams
+ */
+static void fwnet_update(struct fw_unit *unit)
+{
+	struct fw_device *device = fw_parent_device(unit);
+	struct fwnet_peer *peer = dev_get_drvdata(&unit->device);
+	int generation;
+
+	generation = device->generation;
+
+	spin_lock_irq(&peer->dev->lock);
+	peer->node_id    = device->node_id;
+	peer->generation = generation;
+	spin_unlock_irq(&peer->dev->lock);
+}
+
 static void fwnet_remove_peer(struct fwnet_peer *peer, struct fwnet_device *dev)
 {
 	struct fwnet_partial_datagram *pd, *pd_next;
@@ -1542,9 +1560,9 @@ static void fwnet_remove_peer(struct fwnet_peer *peer, struct fwnet_device *dev)
 	kfree(peer);
 }
 
-static int fwnet_remove(struct device *_dev)
+static void fwnet_remove(struct fw_unit *unit)
 {
-	struct fwnet_peer *peer = dev_get_drvdata(_dev);
+	struct fwnet_peer *peer = dev_get_drvdata(&unit->device);
 	struct fwnet_device *dev = peer->dev;
 	struct net_device *net;
 	int i;
@@ -1569,26 +1587,6 @@ static int fwnet_remove(struct device *_dev)
 	}
 
 	mutex_unlock(&fwnet_device_mutex);
-
-	return 0;
-}
-
-/*
- * FIXME abort partially sent fragmented datagrams,
- * discard partially received fragmented datagrams
- */
-static void fwnet_update(struct fw_unit *unit)
-{
-	struct fw_device *device = fw_parent_device(unit);
-	struct fwnet_peer *peer = dev_get_drvdata(&unit->device);
-	int generation;
-
-	generation = device->generation;
-
-	spin_lock_irq(&peer->dev->lock);
-	peer->node_id    = device->node_id;
-	peer->generation = generation;
-	spin_unlock_irq(&peer->dev->lock);
 }
 
 static const struct ieee1394_device_id fwnet_id_table[] = {
@@ -1614,10 +1612,10 @@ static struct fw_driver fwnet_driver = {
 		.owner  = THIS_MODULE,
 		.name   = KBUILD_MODNAME,
 		.bus    = &fw_bus_type,
-		.probe  = fwnet_probe,
-		.remove = fwnet_remove,
 	},
+	.probe    = fwnet_probe,
 	.update   = fwnet_update,
+	.remove   = fwnet_remove,
 	.id_table = fwnet_id_table,
 };
 

commit f78089e87e576f91396a5d428d14b552178dfb17
Merge: 7462543abb87 6fe9efb9c9fb
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu May 9 10:11:48 2013 -0700

    Merge tag 'firewire-updates' of git://git.kernel.org/pub/scm/linux/kernel/git/ieee1394/linux1394
    
    Pull firewure updates from Stefan Richter:
      - fix controller removal when controller is in suspended state
      - fix video reception on VIA VT6306 with gstreamer, MythTV, and maybe dv4l
      - fix a startup issue with Agere/LSI FW643-e2
      - error logging improvements and other small updates
    
    * tag 'firewire-updates' of git://git.kernel.org/pub/scm/linux/kernel/git/ieee1394/linux1394:
      firewire: ohci: dump_stack() for PHY regs read/write failures
      firewire: ohci: Improve bus reset error messages
      firewire: ohci: Alias dev_* log functions
      firewire: ohci: Fix 'failed to read phy reg' on FW643 rev8
      firewire: ohci: fix VIA VT6306 video reception
      firewire: ohci: Check LPS before register access on pci removal
      firewire: ohci: Fix double free_irq()
      firewire: remove unnecessary alloc/OOM messages
      firewire: sbp2: replace BUG_ON by WARN_ON
      firewire: core: remove an always false test
      firewire: Remove two unneeded checks for macros

commit cfb0c9d1ffbf930a4a852f178b161c522b21b0ab
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sun Mar 24 17:32:00 2013 +0100

    firewire: remove unnecessary alloc/OOM messages
    
    These are redundant to log messages from the mm core.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index 2b27bff2591a..75c1133e437c 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -368,10 +368,8 @@ static struct fwnet_fragment_info *fwnet_frag_new(
 	}
 
 	new = kmalloc(sizeof(*new), GFP_ATOMIC);
-	if (!new) {
-		dev_err(&pd->skb->dev->dev, "out of memory\n");
+	if (!new)
 		return NULL;
-	}
 
 	new->offset = offset;
 	new->len = len;
@@ -414,8 +412,6 @@ static struct fwnet_partial_datagram *fwnet_pd_new(struct net_device *net,
 fail_w_new:
 	kfree(new);
 fail:
-	dev_err(&net->dev, "out of memory\n");
-
 	return NULL;
 }
 
@@ -692,7 +688,6 @@ static int fwnet_incoming_packet(struct fwnet_device *dev, __be32 *buf, int len,
 
 		skb = dev_alloc_skb(len + LL_RESERVED_SPACE(net));
 		if (unlikely(!skb)) {
-			dev_err(&net->dev, "out of memory\n");
 			net->stats.rx_dropped++;
 
 			return -ENOMEM;

commit e5c5d22e8dcf7c2d430336cbf8e180bd38e8daf1
Author: Simon Horman <horms@verge.net.au>
Date:   Thu Mar 28 13:38:25 2013 +0900

    net: add ETH_P_802_3_MIN
    
    Add a new constant ETH_P_802_3_MIN, the minimum ethernet type for
    an 802.3 frame. Frames with a lower value in the ethernet type field
    are Ethernet II.
    
    Also update all the users of this value that David Miller and
    I could find to use the new constant.
    
    Also correct a bug in util.c. The comparison with ETH_P_802_3_MIN
    should be >= not >.
    
    As suggested by Jesse Gross.
    
    Compile tested only.
    
    Cc: David Miller <davem@davemloft.net>
    Cc: Jesse Gross <jesse@nicira.com>
    Cc: Karsten Keil <isdn@linux-pingi.de>
    Cc: John W. Linville <linville@tuxdriver.com>
    Cc: Johannes Berg <johannes@sipsolutions.net>
    Cc: Bart De Schuymer <bart.de.schuymer@pandora.be>
    Cc: Stephen Hemminger <stephen@networkplumber.org>
    Cc: Patrick McHardy <kaber@trash.net>
    Cc: Marcel Holtmann <marcel@holtmann.org>
    Cc: Gustavo Padovan <gustavo@padovan.org>
    Cc: Johan Hedberg <johan.hedberg@gmail.com>
    Cc: linux-bluetooth@vger.kernel.org
    Cc: netfilter-devel@vger.kernel.org
    Cc: bridge@lists.linux-foundation.org
    Cc: linux-wireless@vger.kernel.org
    Cc: linux1394-devel@lists.sourceforge.net
    Cc: linux-media@vger.kernel.org
    Cc: netdev@vger.kernel.org
    Cc: dev@openvswitch.org
    Acked-by: Mauro Carvalho Chehab <mchehab@redhat.com>
    Acked-by: Stefan Richter <stefanr@s5r6.in-berlin.de>
    Signed-off-by: Simon Horman <horms@verge.net.au>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index 56796330a162..4d565365e476 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -547,7 +547,7 @@ static int fwnet_finish_incoming_packet(struct net_device *net,
 			if (memcmp(eth->h_dest, net->dev_addr, net->addr_len))
 				skb->pkt_type = PACKET_OTHERHOST;
 		}
-		if (ntohs(eth->h_proto) >= 1536) {
+		if (ntohs(eth->h_proto) >= ETH_P_802_3_MIN) {
 			protocol = eth->h_proto;
 		} else {
 			rawp = (u16 *)skb->data;

commit cb6bf35502d53364d15737295bc64f804c4587ce
Author: YOSHIFUJI Hideaki /  <yoshfuji@linux-ipv6.org>
Date:   Mon Mar 25 08:26:24 2013 +0000

    firewire net, ipv6: IPv6 over Firewire (RFC3146) support.
    
    Signed-off-by: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index 790017eb5051..56796330a162 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -1,5 +1,6 @@
 /*
  * IPv4 over IEEE 1394, per RFC 2734
+ * IPv6 over IEEE 1394, per RFC 3146
  *
  * Copyright (C) 2009 Jay Fenlason <fenlason@redhat.com>
  *
@@ -46,6 +47,7 @@
 
 #define IANA_SPECIFIER_ID		0x00005eU
 #define RFC2734_SW_VERSION		0x000001U
+#define RFC3146_SW_VERSION		0x000002U
 
 #define IEEE1394_GASP_HDR_SIZE	8
 
@@ -505,6 +507,9 @@ static int fwnet_finish_incoming_packet(struct net_device *net,
 	switch (ether_type) {
 	case ETH_P_ARP:
 	case ETH_P_IP:
+#if IS_ENABLED(CONFIG_IPV6)
+	case ETH_P_IPV6:
+#endif
 		break;
 	default:
 		goto err;
@@ -768,7 +773,12 @@ static void fwnet_receive_broadcast(struct fw_iso_context *context,
 	ver = be32_to_cpu(buf_ptr[1]) & 0xffffff;
 	source_node_id = be32_to_cpu(buf_ptr[0]) >> 16;
 
-	if (specifier_id == IANA_SPECIFIER_ID && ver == RFC2734_SW_VERSION) {
+	if (specifier_id == IANA_SPECIFIER_ID &&
+	    (ver == RFC2734_SW_VERSION
+#if IS_ENABLED(CONFIG_IPV6)
+	     || ver == RFC3146_SW_VERSION
+#endif
+	    )) {
 		buf_ptr += 2;
 		length -= IEEE1394_GASP_HDR_SIZE;
 		fwnet_incoming_packet(dev, buf_ptr, length, source_node_id,
@@ -971,16 +981,27 @@ static int fwnet_send_packet(struct fwnet_packet_task *ptask)
 		u8 *p;
 		int generation;
 		int node_id;
+		unsigned int sw_version;
 
 		/* ptask->generation may not have been set yet */
 		generation = dev->card->generation;
 		smp_rmb();
 		node_id = dev->card->node_id;
 
+		switch (ptask->skb->protocol) {
+		default:
+			sw_version = RFC2734_SW_VERSION;
+			break;
+#if IS_ENABLED(CONFIG_IPV6)
+		case htons(ETH_P_IPV6):
+			sw_version = RFC3146_SW_VERSION;
+#endif
+		}
+
 		p = skb_push(ptask->skb, IEEE1394_GASP_HDR_SIZE);
 		put_unaligned_be32(node_id << 16 | IANA_SPECIFIER_ID >> 8, p);
 		put_unaligned_be32((IANA_SPECIFIER_ID & 0xff) << 24
-						| RFC2734_SW_VERSION, &p[4]);
+						| sw_version, &p[4]);
 
 		/* We should not transmit if broadcast_channel.valid == 0. */
 		fw_send_request(dev->card, &ptask->transaction,
@@ -1248,6 +1269,9 @@ static netdev_tx_t fwnet_tx(struct sk_buff *skb, struct net_device *net)
 	switch (proto) {
 	case htons(ETH_P_ARP):
 	case htons(ETH_P_IP):
+#if IS_ENABLED(CONFIG_IPV6)
+	case htons(ETH_P_IPV6):
+#endif
 		break;
 	default:
 		goto fail;
@@ -1490,7 +1514,7 @@ static int fwnet_probe(struct device *_dev)
 		goto out;
 
 	list_add_tail(&dev->dev_link, &fwnet_device_list);
-	dev_notice(&net->dev, "IPv4 over IEEE 1394 on card %s\n",
+	dev_notice(&net->dev, "IP over IEEE 1394 on card %s\n",
 		   dev_name(card->device));
  have_dev:
 	ret = fwnet_add_peer(dev, unit, device);
@@ -1579,6 +1603,14 @@ static const struct ieee1394_device_id fwnet_id_table[] = {
 		.specifier_id = IANA_SPECIFIER_ID,
 		.version      = RFC2734_SW_VERSION,
 	},
+#if IS_ENABLED(CONFIG_IPV6)
+	{
+		.match_flags  = IEEE1394_MATCH_SPECIFIER_ID |
+				IEEE1394_MATCH_VERSION,
+		.specifier_id = IANA_SPECIFIER_ID,
+		.version      = RFC3146_SW_VERSION,
+	},
+#endif
 	{ }
 };
 
@@ -1616,6 +1648,30 @@ static struct fw_descriptor rfc2374_unit_directory = {
 	.data   = rfc2374_unit_directory_data
 };
 
+#if IS_ENABLED(CONFIG_IPV6)
+static const u32 rfc3146_unit_directory_data[] = {
+	0x00040000,	/* directory_length		*/
+	0x1200005e,	/* unit_specifier_id: IANA	*/
+	0x81000003,	/* textual descriptor offset	*/
+	0x13000002,	/* unit_sw_version: RFC 3146	*/
+	0x81000005,	/* textual descriptor offset	*/
+	0x00030000,	/* descriptor_length		*/
+	0x00000000,	/* text				*/
+	0x00000000,	/* minimal ASCII, en		*/
+	0x49414e41,	/* I A N A			*/
+	0x00030000,	/* descriptor_length		*/
+	0x00000000,	/* text				*/
+	0x00000000,	/* minimal ASCII, en		*/
+	0x49507636,	/* I P v 6			*/
+};
+
+static struct fw_descriptor rfc3146_unit_directory = {
+	.length = ARRAY_SIZE(rfc3146_unit_directory_data),
+	.key    = (CSR_DIRECTORY | CSR_UNIT) << 24,
+	.data   = rfc3146_unit_directory_data
+};
+#endif
+
 static int __init fwnet_init(void)
 {
 	int err;
@@ -1624,11 +1680,17 @@ static int __init fwnet_init(void)
 	if (err)
 		return err;
 
+#if IS_ENABLED(CONFIG_IPV6)
+	err = fw_core_add_descriptor(&rfc3146_unit_directory);
+	if (err)
+		goto out;
+#endif
+
 	fwnet_packet_task_cache = kmem_cache_create("packet_task",
 			sizeof(struct fwnet_packet_task), 0, 0, NULL);
 	if (!fwnet_packet_task_cache) {
 		err = -ENOMEM;
-		goto out;
+		goto out2;
 	}
 
 	err = driver_register(&fwnet_driver.driver);
@@ -1636,7 +1698,11 @@ static int __init fwnet_init(void)
 		return 0;
 
 	kmem_cache_destroy(fwnet_packet_task_cache);
+out2:
+#if IS_ENABLED(CONFIG_IPV6)
+	fw_core_remove_descriptor(&rfc3146_unit_directory);
 out:
+#endif
 	fw_core_remove_descriptor(&rfc2374_unit_directory);
 
 	return err;
@@ -1647,11 +1713,14 @@ static void __exit fwnet_cleanup(void)
 {
 	driver_unregister(&fwnet_driver.driver);
 	kmem_cache_destroy(fwnet_packet_task_cache);
+#if IS_ENABLED(CONFIG_IPV6)
+	fw_core_remove_descriptor(&rfc3146_unit_directory);
+#endif
 	fw_core_remove_descriptor(&rfc2374_unit_directory);
 }
 module_exit(fwnet_cleanup);
 
 MODULE_AUTHOR("Jay Fenlason <fenlason@redhat.com>");
-MODULE_DESCRIPTION("IPv4 over IEEE1394 as per RFC 2734");
+MODULE_DESCRIPTION("IP over IEEE1394 as per RFC 2734/3146");
 MODULE_LICENSE("GPL");
 MODULE_DEVICE_TABLE(ieee1394, fwnet_id_table);

commit 6752c8db8e0cfedb44ba62806dd15b383ed64000
Author: YOSHIFUJI Hideaki /  <yoshfuji@linux-ipv6.org>
Date:   Mon Mar 25 08:26:16 2013 +0000

    firewire net, ipv4 arp: Extend hardware address and remove driver-level packet inspection.
    
    Inspection of upper layer protocol is considered harmful, especially
    if it is about ARP or other stateful upper layer protocol; driver
    cannot (and should not) have full state of them.
    
    IPv4 over Firewire module used to inspect ARP (both in sending path
    and in receiving path), and record peer's GUID, max packet size, max
    speed and fifo address.  This patch removes such inspection by extending
    our "hardware address" definition to include other information as well:
    max packet size, max speed and fifo.  By doing this, The neighbour
    module in networking subsystem can cache them.
    
    Note: As we have started ignoring sspd and max_rec in ARP/NDP, those
          information will not be used in the driver when sending.
    
    When a packet is being sent, the IP layer fills our pseudo header with
    the extended "hardware address", including GUID and fifo.  The driver
    can look-up node-id (the real but rather volatile low-level address)
    by GUID, and then the module can send the packet to the wire using
    parameters provided in the extendedn hardware address.
    
    This approach is realistic because IP over IEEE1394 (RFC2734) and IPv6
    over IEEE1394 (RFC3146) share same "hardware address" format
    in their address resolution protocols.
    
    Here, extended "hardware address" is defined as follows:
    
    union fwnet_hwaddr {
            u8 u[16];
            struct {
                    __be64 uniq_id;         /* EUI-64                       */
                    u8 max_rec;             /* max packet size              */
                    u8 sspd;                /* max speed                    */
                    __be16 fifo_hi;         /* hi 16bits of FIFO addr       */
                    __be32 fifo_lo;         /* lo 32bits of FIFO addr       */
            } __packed uc;
    };
    
    Note that Hardware address is declared as union, so that we can map full
    IP address into this, when implementing MCAP (Multicast Cannel Allocation
    Protocol) for IPv6, but IP and ARP subsystem do not need to know this
    format in detail.
    
    One difference between original ARP (RFC826) and 1394 ARP (RFC2734)
    is that 1394 ARP Request/Reply do not contain the target hardware address
    field (aka ar$tha).  This difference is handled in the ARP subsystem.
    
    CC: Stephan Gatzka <stephan.gatzka@gmail.com>
    Signed-off-by: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index cb8aa865ff88..790017eb5051 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -28,6 +28,7 @@
 
 #include <asm/unaligned.h>
 #include <net/arp.h>
+#include <net/firewire.h>
 
 /* rx limits */
 #define FWNET_MAX_FRAGMENTS		30 /* arbitrary, > TX queue depth */
@@ -57,33 +58,6 @@
 #define RFC2374_HDR_LASTFRAG	2	/* last fragment	*/
 #define RFC2374_HDR_INTFRAG	3	/* interior fragment	*/
 
-#define RFC2734_HW_ADDR_LEN	16
-
-struct rfc2734_arp {
-	__be16 hw_type;		/* 0x0018	*/
-	__be16 proto_type;	/* 0x0806       */
-	u8 hw_addr_len;		/* 16		*/
-	u8 ip_addr_len;		/* 4		*/
-	__be16 opcode;		/* ARP Opcode	*/
-	/* Above is exactly the same format as struct arphdr */
-
-	__be64 s_uniq_id;	/* Sender's 64bit EUI			*/
-	u8 max_rec;		/* Sender's max packet size		*/
-	u8 sspd;		/* Sender's max speed			*/
-	__be16 fifo_hi;		/* hi 16bits of sender's FIFO addr	*/
-	__be32 fifo_lo;		/* lo 32bits of sender's FIFO addr	*/
-	__be32 sip;		/* Sender's IP Address			*/
-	__be32 tip;		/* IP Address of requested hw addr	*/
-} __packed;
-
-/* This header format is specific to this driver implementation. */
-#define FWNET_ALEN	8
-#define FWNET_HLEN	10
-struct fwnet_header {
-	u8 h_dest[FWNET_ALEN];	/* destination address */
-	__be16 h_proto;		/* packet type ID field */
-} __packed;
-
 static bool fwnet_hwaddr_is_multicast(u8 *ha)
 {
 	return !!(*ha & 1);
@@ -196,8 +170,6 @@ struct fwnet_peer {
 	struct list_head peer_link;
 	struct fwnet_device *dev;
 	u64 guid;
-	u64 fifo;
-	__be32 ip;
 
 	/* guarded by dev->lock */
 	struct list_head pd_list; /* received partial datagrams */
@@ -226,6 +198,15 @@ struct fwnet_packet_task {
 	u8 enqueued;
 };
 
+/*
+ * Get fifo address embedded in hwaddr
+ */
+static __u64 fwnet_hwaddr_fifo(union fwnet_hwaddr *ha)
+{
+	return (u64)get_unaligned_be16(&ha->uc.fifo_hi) << 32
+	       | get_unaligned_be32(&ha->uc.fifo_lo);
+}
+
 /*
  * saddr == NULL means use device source address.
  * daddr == NULL means leave destination address (eg unresolved arp).
@@ -518,7 +499,6 @@ static int fwnet_finish_incoming_packet(struct net_device *net,
 					bool is_broadcast, u16 ether_type)
 {
 	struct fwnet_device *dev;
-	static const __be64 broadcast_hw = cpu_to_be64(~0ULL);
 	int status;
 	__be64 guid;
 
@@ -537,76 +517,11 @@ static int fwnet_finish_incoming_packet(struct net_device *net,
 
 	/*
 	 * Parse the encapsulation header. This actually does the job of
-	 * converting to an ethernet frame header, as well as arp
-	 * conversion if needed. ARP conversion is easier in this
-	 * direction, since we are using ethernet as our backend.
-	 */
-	/*
-	 * If this is an ARP packet, convert it. First, we want to make
-	 * use of some of the fields, since they tell us a little bit
-	 * about the sending machine.
+	 * converting to an ethernet-like pseudo frame header.
 	 */
-	if (ether_type == ETH_P_ARP) {
-		struct rfc2734_arp *arp1394;
-		struct arphdr *arp;
-		unsigned char *arp_ptr;
-		u64 fifo_addr;
-		u64 peer_guid;
-		struct fwnet_peer *peer;
-		unsigned long flags;
-
-		arp1394   = (struct rfc2734_arp *)skb->data;
-		arp       = (struct arphdr *)skb->data;
-		arp_ptr   = (unsigned char *)(arp + 1);
-		peer_guid = get_unaligned_be64(&arp1394->s_uniq_id);
-		fifo_addr = (u64)get_unaligned_be16(&arp1394->fifo_hi) << 32
-				| get_unaligned_be32(&arp1394->fifo_lo);
-
-		spin_lock_irqsave(&dev->lock, flags);
-		peer = fwnet_peer_find_by_guid(dev, peer_guid);
-		if (peer) {
-			peer->fifo = fifo_addr;
-			peer->ip = arp1394->sip;
-		}
-		spin_unlock_irqrestore(&dev->lock, flags);
-
-		if (!peer) {
-			dev_notice(&net->dev,
-				   "no peer for ARP packet from %016llx\n",
-				   (unsigned long long)peer_guid);
-			goto no_peer;
-		}
-
-		/*
-		 * Now that we're done with the 1394 specific stuff, we'll
-		 * need to alter some of the data.  Believe it or not, all
-		 * that needs to be done is sender_IP_address needs to be
-		 * moved, the destination hardware address get stuffed
-		 * in and the hardware address length set to 8.
-		 *
-		 * IMPORTANT: The code below overwrites 1394 specific data
-		 * needed above so keep the munging of the data for the
-		 * higher level IP stack last.
-		 */
-
-		arp->ar_hln = 8;
-		/* skip over sender unique id */
-		arp_ptr += arp->ar_hln;
-		/* move sender IP addr */
-		put_unaligned(arp1394->sip, (u32 *)arp_ptr);
-		/* skip over sender IP addr */
-		arp_ptr += arp->ar_pln;
-
-		if (arp->ar_op == htons(ARPOP_REQUEST))
-			memset(arp_ptr, 0, sizeof(u64));
-		else
-			memcpy(arp_ptr, net->dev_addr, sizeof(u64));
-	}
-
-	/* Now add the ethernet header. */
 	guid = cpu_to_be64(dev->card->guid);
 	if (dev_hard_header(skb, net, ether_type,
-			   is_broadcast ? &broadcast_hw : &guid,
+			   is_broadcast ? net->broadcast : net->dev_addr,
 			   NULL, skb->len) >= 0) {
 		struct fwnet_header *eth;
 		u16 *rawp;
@@ -649,7 +564,6 @@ static int fwnet_finish_incoming_packet(struct net_device *net,
 
 	return 0;
 
- no_peer:
  err:
 	net->stats.rx_errors++;
 	net->stats.rx_dropped++;
@@ -1355,11 +1269,12 @@ static netdev_tx_t fwnet_tx(struct sk_buff *skb, struct net_device *net)
 		ptask->dest_node   = IEEE1394_ALL_NODES;
 		ptask->speed       = SCODE_100;
 	} else {
-		__be64 guid = get_unaligned((__be64 *)hdr_buf.h_dest);
+		union fwnet_hwaddr *ha = (union fwnet_hwaddr *)hdr_buf.h_dest;
+		__be64 guid = get_unaligned(&ha->uc.uniq_id);
 		u8 generation;
 
 		peer = fwnet_peer_find_by_guid(dev, be64_to_cpu(guid));
-		if (!peer || peer->fifo == FWNET_NO_FIFO_ADDR)
+		if (!peer)
 			goto fail;
 
 		generation         = peer->generation;
@@ -1367,32 +1282,12 @@ static netdev_tx_t fwnet_tx(struct sk_buff *skb, struct net_device *net)
 		max_payload        = peer->max_payload;
 		datagram_label_ptr = &peer->datagram_label;
 
-		ptask->fifo_addr   = peer->fifo;
+		ptask->fifo_addr   = fwnet_hwaddr_fifo(ha);
 		ptask->generation  = generation;
 		ptask->dest_node   = dest_node;
 		ptask->speed       = peer->speed;
 	}
 
-	/* If this is an ARP packet, convert it */
-	if (proto == htons(ETH_P_ARP)) {
-		struct arphdr *arp = (struct arphdr *)skb->data;
-		unsigned char *arp_ptr = (unsigned char *)(arp + 1);
-		struct rfc2734_arp *arp1394 = (struct rfc2734_arp *)skb->data;
-		__be32 ipaddr;
-
-		ipaddr = get_unaligned((__be32 *)(arp_ptr + FWNET_ALEN));
-
-		arp1394->hw_addr_len    = RFC2734_HW_ADDR_LEN;
-		arp1394->max_rec        = dev->card->max_receive;
-		arp1394->sspd		= dev->card->link_speed;
-
-		put_unaligned_be16(dev->local_fifo >> 32,
-				   &arp1394->fifo_hi);
-		put_unaligned_be32(dev->local_fifo & 0xffffffff,
-				   &arp1394->fifo_lo);
-		put_unaligned(ipaddr, &arp1394->sip);
-	}
-
 	ptask->hdr.w0 = 0;
 	ptask->hdr.w1 = 0;
 	ptask->skb = skb;
@@ -1507,8 +1402,6 @@ static int fwnet_add_peer(struct fwnet_device *dev,
 
 	peer->dev = dev;
 	peer->guid = (u64)device->config_rom[3] << 32 | device->config_rom[4];
-	peer->fifo = FWNET_NO_FIFO_ADDR;
-	peer->ip = 0;
 	INIT_LIST_HEAD(&peer->pd_list);
 	peer->pdg_size = 0;
 	peer->datagram_label = 0;
@@ -1538,6 +1431,7 @@ static int fwnet_probe(struct device *_dev)
 	struct fwnet_device *dev;
 	unsigned max_mtu;
 	int ret;
+	union fwnet_hwaddr *ha;
 
 	mutex_lock(&fwnet_device_mutex);
 
@@ -1582,8 +1476,15 @@ static int fwnet_probe(struct device *_dev)
 	net->mtu = min(1500U, max_mtu);
 
 	/* Set our hardware address while we're at it */
-	put_unaligned_be64(card->guid, net->dev_addr);
-	put_unaligned_be64(~0ULL, net->broadcast);
+	ha = (union fwnet_hwaddr *)net->dev_addr;
+	put_unaligned_be64(card->guid, &ha->uc.uniq_id);
+	ha->uc.max_rec = dev->card->max_receive;
+	ha->uc.sspd = dev->card->link_speed;
+	put_unaligned_be16(dev->local_fifo >> 32, &ha->uc.fifo_hi);
+	put_unaligned_be32(dev->local_fifo & 0xffffffff, &ha->uc.fifo_lo);
+
+	memset(net->broadcast, -1, net->addr_len);
+
 	ret = register_netdev(net);
 	if (ret)
 		goto out;
@@ -1632,8 +1533,6 @@ static int fwnet_remove(struct device *_dev)
 	mutex_lock(&fwnet_device_mutex);
 
 	net = dev->netdev;
-	if (net && peer->ip)
-		arp_invalidate(net, peer->ip);
 
 	fwnet_remove_peer(peer, dev);
 

commit 61a7839a19c157d11930fe69697a4c90884bf7c4
Author: YOSHIFUJI Hideaki /  <yoshfuji@linux-ipv6.org>
Date:   Mon Mar 25 08:26:08 2013 +0000

    firewire net: Ignore spd and max_payload advertised by ARP.
    
    Stefan Richter <stefanr@s5r6.in-berlin.de> says:
    | As far as I can tell, it would be best to ignore max_rec and sspd from ARP
    | and NDP but keep using the respective information from firewire-core
    | instead (handed over by fwnet_probe()).
    |
    | Why?  As I noted earlier, RFC 2734:1999 and RFC 3146:2001 were apparently
    | written with a too simplistic notion of IEEE 1394 bus topology, resulting
    | in max_rec and sspd in ARP-1394 and NDP-1394 to be useless, IMO.
    |
    | Consider a bus like this:
    |
    |     A ---- B ==== C
    |
    | A, B, C are all IP-over-1394 capable nodes.  ---- is an S400 cable hop,
    | and ==== is an S800 cable hop.
    |
    | In case of unicasts or multicasts in which node A is involved as
    | transmitter or receiver, as well as in case of broadcasts, the speeds
    | S100, S200, S400 work and speed S400 is optimal.
    |
    | In case of anything else, IOW in case of unicasts or multicasts in which
    | only nodes B and C are involved, the speeds S100, S200, S400, S800 work
    | and speed S800 is optimal.
    |
    | Clearly, node A should indicate sspd = S400 in its ARP or NDP packets.
    | But which sspd should nodes B and C set there?  Maybe they set S400, which
    | would work but would waste half of the available bandwidth in the second
    | case.  Or maybe they set S800, which is OK in the second case but would
    | prohibit any communication with node A if blindly taken for correct.
    |
    | On the other hand, firewire-core *always* gives us the correct and optimum
    | peer-to-peer speed and asynchronous packet payload, no matter how simple
    | or complex the bus topology is and no matter in which temporal order nodes
    | join the bus and are discovered.
    
    CC: Stefan Richter <stefanr@s5r6.in-berlin.de>
    Signed-off-by: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index 72536e7fe95c..cb8aa865ff88 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -552,8 +552,6 @@ static int fwnet_finish_incoming_packet(struct net_device *net,
 		unsigned char *arp_ptr;
 		u64 fifo_addr;
 		u64 peer_guid;
-		unsigned sspd;
-		u16 max_payload;
 		struct fwnet_peer *peer;
 		unsigned long flags;
 
@@ -564,24 +562,10 @@ static int fwnet_finish_incoming_packet(struct net_device *net,
 		fifo_addr = (u64)get_unaligned_be16(&arp1394->fifo_hi) << 32
 				| get_unaligned_be32(&arp1394->fifo_lo);
 
-		sspd = arp1394->sspd;
-		/* Sanity check.  OS X 10.3 PPC reportedly sends 131. */
-		if (sspd > SCODE_3200) {
-			dev_notice(&net->dev, "sspd %x out of range\n", sspd);
-			sspd = SCODE_3200;
-		}
-		max_payload = fwnet_max_payload(arp1394->max_rec, sspd);
-
 		spin_lock_irqsave(&dev->lock, flags);
 		peer = fwnet_peer_find_by_guid(dev, peer_guid);
 		if (peer) {
 			peer->fifo = fifo_addr;
-
-			if (peer->speed > sspd)
-				peer->speed = sspd;
-			if (peer->max_payload > max_payload)
-				peer->max_payload = max_payload;
-
 			peer->ip = arp1394->sip;
 		}
 		spin_unlock_irqrestore(&dev->lock, flags);

commit 382c4b4090b7394d079c199ba053a378c6cd45b8
Author: YOSHIFUJI Hideaki /  <yoshfuji@linux-ipv6.org>
Date:   Mon Mar 25 08:25:57 2013 +0000

    firewire net: Allocate address handler before registering net_device.
    
    Allocate FIFO address before registering net_device.
    This is preparation to change the pseudo hardware address format
    for firewire devices to include the offset of the FIFO for receipt
    of unicast datagrams, instead of mangling ARP/NDP messages in the
    driver layer.
    
    Signed-off-by: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index 7c2e16a1db4f..72536e7fe95c 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -1286,13 +1286,9 @@ static int fwnet_open(struct net_device *net)
 	struct fwnet_device *dev = netdev_priv(net);
 	int ret;
 
-	ret = fwnet_fifo_start(dev);
-	if (ret)
-		return ret;
-
 	ret = fwnet_broadcast_start(dev);
 	if (ret)
-		goto out;
+		return ret;
 
 	netif_start_queue(net);
 
@@ -1301,9 +1297,6 @@ static int fwnet_open(struct net_device *net)
 	spin_unlock_irq(&dev->lock);
 
 	return 0;
-out:
-	fwnet_fifo_stop(dev);
-	return ret;
 }
 
 /* ifdown */
@@ -1312,9 +1305,7 @@ static int fwnet_stop(struct net_device *net)
 	struct fwnet_device *dev = netdev_priv(net);
 
 	netif_stop_queue(net);
-
 	fwnet_broadcast_stop(dev);
-	fwnet_fifo_stop(dev);
 
 	return 0;
 }
@@ -1593,6 +1584,11 @@ static int fwnet_probe(struct device *_dev)
 	dev->card = card;
 	dev->netdev = net;
 
+	ret = fwnet_fifo_start(dev);
+	if (ret < 0)
+		goto out;
+	dev->local_fifo = dev->handler.offset;
+
 	/*
 	 * Use the RFC 2734 default 1500 octets or the maximum payload
 	 * as initial MTU
@@ -1616,10 +1612,10 @@ static int fwnet_probe(struct device *_dev)
 	if (ret && allocated_netdev) {
 		unregister_netdev(net);
 		list_del(&dev->dev_link);
-	}
  out:
-	if (ret && allocated_netdev)
+		fwnet_fifo_stop(dev);
 		free_netdev(net);
+	}
 
 	mutex_unlock(&fwnet_device_mutex);
 
@@ -1660,6 +1656,8 @@ static int fwnet_remove(struct device *_dev)
 	if (list_empty(&dev->peer_list)) {
 		unregister_netdev(net);
 
+		fwnet_fifo_stop(dev);
+
 		for (i = 0; dev->queued_datagrams && i < 5; i++)
 			ssleep(1);
 		WARN_ON(dev->queued_datagrams);

commit 021b97e469714b31b9e808c91b49543a8766c342
Author: YOSHIFUJI Hideaki /  <yoshfuji@linux-ipv6.org>
Date:   Mon Mar 25 08:25:48 2013 +0000

    firewire net: Send L2 multicast via GASP.
    
    Send L2 multicast packet via GASP (Global asynchronous stream packet) by
    seeing the multicast bit in the L2 hardware address, not by seeing upper-
    layer protocol address.
    
    Signed-off-by: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index d438c5be8c21..7c2e16a1db4f 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -84,6 +84,11 @@ struct fwnet_header {
 	__be16 h_proto;		/* packet type ID field */
 } __packed;
 
+static bool fwnet_hwaddr_is_multicast(u8 *ha)
+{
+	return !!(*ha & 1);
+}
+
 /* IPv4 and IPv6 encapsulation header */
 struct rfc2734_header {
 	u32 w0;
@@ -626,7 +631,7 @@ static int fwnet_finish_incoming_packet(struct net_device *net,
 		skb_reset_mac_header(skb);
 		skb_pull(skb, sizeof(*eth));
 		eth = (struct fwnet_header *)skb_mac_header(skb);
-		if (*eth->h_dest & 1) {
+		if (fwnet_hwaddr_is_multicast(eth->h_dest)) {
 			if (memcmp(eth->h_dest, net->broadcast,
 				   net->addr_len) == 0)
 				skb->pkt_type = PACKET_BROADCAST;
@@ -1366,10 +1371,7 @@ static netdev_tx_t fwnet_tx(struct sk_buff *skb, struct net_device *net)
 	 * Set the transmission type for the packet.  ARP packets and IP
 	 * broadcast packets are sent via GASP.
 	 */
-	if (memcmp(hdr_buf.h_dest, net->broadcast, FWNET_ALEN) == 0
-	    || proto == htons(ETH_P_ARP)
-	    || (proto == htons(ETH_P_IP)
-		&& IN_MULTICAST(ntohl(ip_hdr(skb)->daddr)))) {
+	if (fwnet_hwaddr_is_multicast(hdr_buf.h_dest)) {
 		max_payload        = dev->broadcast_xmt_max_payload;
 		datagram_label_ptr = &dev->broadcast_xmt_datagramlabel;
 

commit 18406d7e42a67d7b3a3b3ed17be6626a51d8c715
Author: YOSHIFUJI Hideaki /  <yoshfuji@linux-ipv6.org>
Date:   Mon Mar 25 08:25:38 2013 +0000

    firewire net: Accept IPv4 and ARP only.
    
    Signed-off-by: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index c1898adeb900..d438c5be8c21 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -517,6 +517,14 @@ static int fwnet_finish_incoming_packet(struct net_device *net,
 	int status;
 	__be64 guid;
 
+	switch (ether_type) {
+	case ETH_P_ARP:
+	case ETH_P_IP:
+		break;
+	default:
+		goto err;
+	}
+
 	dev = netdev_priv(net);
 	/* Write metadata, and then pass to the receive level */
 	skb->dev = net;
@@ -653,6 +661,7 @@ static int fwnet_finish_incoming_packet(struct net_device *net,
 	return 0;
 
  no_peer:
+ err:
 	net->stats.rx_errors++;
 	net->stats.rx_dropped++;
 
@@ -1340,9 +1349,17 @@ static netdev_tx_t fwnet_tx(struct sk_buff *skb, struct net_device *net)
 	 * We might need to rebuild the header on tx failure.
 	 */
 	memcpy(&hdr_buf, skb->data, sizeof(hdr_buf));
-	skb_pull(skb, sizeof(hdr_buf));
-
 	proto = hdr_buf.h_proto;
+
+	switch (proto) {
+	case htons(ETH_P_ARP):
+	case htons(ETH_P_IP):
+		break;
+	default:
+		goto fail;
+	}
+
+	skb_pull(skb, sizeof(hdr_buf));
 	dg_size = skb->len;
 
 	/*

commit 8559e7f0694e3fb192aab00a495be5a510afc8c3
Author: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
Date:   Fri Mar 8 10:45:57 2013 +0900

    firewire net: Release broadcast/fifo resources on ifdown.
    
    Since those resources are allocated on ifup, relsase them on ifdown.
    
    Signed-off-by: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index ca41446d62f4..c1898adeb900 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -1295,9 +1295,12 @@ static int fwnet_open(struct net_device *net)
 /* ifdown */
 static int fwnet_stop(struct net_device *net)
 {
+	struct fwnet_device *dev = netdev_priv(net);
+
 	netif_stop_queue(net);
 
-	/* Deallocate iso context for use by other applications? */
+	fwnet_broadcast_stop(dev);
+	fwnet_fifo_stop(dev);
 
 	return 0;
 }
@@ -1638,9 +1641,6 @@ static int fwnet_remove(struct device *_dev)
 	if (list_empty(&dev->peer_list)) {
 		unregister_netdev(net);
 
-		fwnet_fifo_stop(dev);
-		fwnet_broadcast_stop(dev);
-
 		for (i = 0; dev->queued_datagrams && i < 5; i++)
 			ssleep(1);
 		WARN_ON(dev->queued_datagrams);

commit 111534cd7a376b75e72ddea0c6d00ec956ce3343
Author: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
Date:   Fri Mar 8 10:45:50 2013 +0900

    firewire net: Introduce fwnet_broadcast_stop() to destroy broadcast resources.
    
    Signed-off-by: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index 21210fb94762..ca41446d62f4 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -1146,6 +1146,32 @@ static int fwnet_fifo_start(struct fwnet_device *dev)
 	return 0;
 }
 
+static void __fwnet_broadcast_stop(struct fwnet_device *dev)
+{
+	unsigned u;
+
+	if (dev->broadcast_state != FWNET_BROADCAST_ERROR) {
+		for (u = 0; u < FWNET_ISO_PAGE_COUNT; u++)
+			kunmap(dev->broadcast_rcv_buffer.pages[u]);
+		fw_iso_buffer_destroy(&dev->broadcast_rcv_buffer, dev->card);
+	}
+	if (dev->broadcast_rcv_context) {
+		fw_iso_context_destroy(dev->broadcast_rcv_context);
+		dev->broadcast_rcv_context = NULL;
+	}
+	kfree(dev->broadcast_rcv_buffer_ptrs);
+	dev->broadcast_rcv_buffer_ptrs = NULL;
+	dev->broadcast_state = FWNET_BROADCAST_ERROR;
+}
+
+static void fwnet_broadcast_stop(struct fwnet_device *dev)
+{
+	if (dev->broadcast_state == FWNET_BROADCAST_ERROR)
+		return;
+	fw_iso_context_stop(dev->broadcast_rcv_context);
+	__fwnet_broadcast_stop(dev);
+}
+
 static int fwnet_broadcast_start(struct fwnet_device *dev)
 {
 	struct fw_iso_context *context;
@@ -1166,7 +1192,7 @@ static int fwnet_broadcast_start(struct fwnet_device *dev)
 	ptrptr = kmalloc(sizeof(void *) * num_packets, GFP_KERNEL);
 	if (!ptrptr) {
 		retval = -ENOMEM;
-		goto failed_ptrs_alloc;
+		goto failed;
 	}
 	dev->broadcast_rcv_buffer_ptrs = ptrptr;
 
@@ -1176,13 +1202,15 @@ static int fwnet_broadcast_start(struct fwnet_device *dev)
 					fwnet_receive_broadcast, dev);
 	if (IS_ERR(context)) {
 		retval = PTR_ERR(context);
-		goto failed_context_create;
+		goto failed;
 	}
 
 	retval = fw_iso_buffer_init(&dev->broadcast_rcv_buffer, dev->card,
 				    FWNET_ISO_PAGE_COUNT, DMA_FROM_DEVICE);
 	if (retval < 0)
-		goto failed_buffer_init;
+		goto failed;
+
+	dev->broadcast_state = FWNET_BROADCAST_STOPPED;
 
 	for (u = 0; u < FWNET_ISO_PAGE_COUNT; u++) {
 		void *ptr;
@@ -1206,7 +1234,7 @@ static int fwnet_broadcast_start(struct fwnet_device *dev)
 		retval = fw_iso_context_queue(context, &packet,
 				&dev->broadcast_rcv_buffer, offset);
 		if (retval < 0)
-			goto failed_rcv_queue;
+			goto failed;
 
 		offset += max_receive;
 	}
@@ -1216,7 +1244,7 @@ static int fwnet_broadcast_start(struct fwnet_device *dev)
 	retval = fw_iso_context_start(context, -1, 0,
 			FW_ISO_CONTEXT_MATCH_ALL_TAGS); /* ??? sync */
 	if (retval < 0)
-		goto failed_rcv_queue;
+		goto failed;
 
 	/* FIXME: adjust it according to the min. speed of all known peers? */
 	dev->broadcast_xmt_max_payload = IEEE1394_MAX_PAYLOAD_S100
@@ -1225,18 +1253,8 @@ static int fwnet_broadcast_start(struct fwnet_device *dev)
 
 	return 0;
 
- failed_rcv_queue:
-	for (u = 0; u < FWNET_ISO_PAGE_COUNT; u++)
-		kunmap(dev->broadcast_rcv_buffer.pages[u]);
-	fw_iso_buffer_destroy(&dev->broadcast_rcv_buffer, dev->card);
- failed_buffer_init:
-	fw_iso_context_destroy(context);
-	dev->broadcast_rcv_context = NULL;
- failed_context_create:
-	kfree(dev->broadcast_rcv_buffer_ptrs);
-	dev->broadcast_rcv_buffer_ptrs = NULL;
- failed_ptrs_alloc:
-
+ failed:
+	__fwnet_broadcast_stop(dev);
 	return retval;
 }
 
@@ -1621,22 +1639,8 @@ static int fwnet_remove(struct device *_dev)
 		unregister_netdev(net);
 
 		fwnet_fifo_stop(dev);
-		if (dev->broadcast_rcv_context) {
-			unsigned u;
-
-			fw_iso_context_stop(dev->broadcast_rcv_context);
+		fwnet_broadcast_stop(dev);
 
-			for (u = 0; u < FWNET_ISO_PAGE_COUNT; u++)
-				kunmap(dev->broadcast_rcv_buffer.pages[u]);
-
-			fw_iso_buffer_destroy(&dev->broadcast_rcv_buffer,
-					      dev->card);
-			fw_iso_context_destroy(dev->broadcast_rcv_context);
-			dev->broadcast_rcv_context = NULL;
-			kfree(dev->broadcast_rcv_buffer_ptrs);
-			dev->broadcast_rcv_buffer_ptrs = NULL;
-			dev->broadcast_state = FWNET_BROADCAST_ERROR;
-		}
 		for (i = 0; dev->queued_datagrams && i < 5; i++)
 			ssleep(1);
 		WARN_ON(dev->queued_datagrams);

commit eac31d58ca2818e3fdc7a6e78fa1b56965f604e9
Author: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
Date:   Fri Mar 8 10:43:55 2013 +0900

    firewire net: Allocate dev->broadcast_rcv_buffer_ptrs early.
    
    Signed-off-by: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index 0dc2fdf00562..21210fb94762 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -1163,6 +1163,13 @@ static int fwnet_broadcast_start(struct fwnet_device *dev)
 	max_receive = 1U << (dev->card->max_receive + 1);
 	num_packets = (FWNET_ISO_PAGE_COUNT * PAGE_SIZE) / max_receive;
 
+	ptrptr = kmalloc(sizeof(void *) * num_packets, GFP_KERNEL);
+	if (!ptrptr) {
+		retval = -ENOMEM;
+		goto failed_ptrs_alloc;
+	}
+	dev->broadcast_rcv_buffer_ptrs = ptrptr;
+
 	context = fw_iso_context_create(dev->card, FW_ISO_CONTEXT_RECEIVE,
 					IEEE1394_BROADCAST_CHANNEL,
 					dev->card->link_speed, 8,
@@ -1177,13 +1184,6 @@ static int fwnet_broadcast_start(struct fwnet_device *dev)
 	if (retval < 0)
 		goto failed_buffer_init;
 
-	ptrptr = kmalloc(sizeof(void *) * num_packets, GFP_KERNEL);
-	if (!ptrptr) {
-		retval = -ENOMEM;
-		goto failed_ptrs_alloc;
-	}
-
-	dev->broadcast_rcv_buffer_ptrs = ptrptr;
 	for (u = 0; u < FWNET_ISO_PAGE_COUNT; u++) {
 		void *ptr;
 		unsigned v;
@@ -1226,16 +1226,16 @@ static int fwnet_broadcast_start(struct fwnet_device *dev)
 	return 0;
 
  failed_rcv_queue:
-	kfree(dev->broadcast_rcv_buffer_ptrs);
-	dev->broadcast_rcv_buffer_ptrs = NULL;
 	for (u = 0; u < FWNET_ISO_PAGE_COUNT; u++)
 		kunmap(dev->broadcast_rcv_buffer.pages[u]);
- failed_ptrs_alloc:
 	fw_iso_buffer_destroy(&dev->broadcast_rcv_buffer, dev->card);
  failed_buffer_init:
 	fw_iso_context_destroy(context);
 	dev->broadcast_rcv_context = NULL;
  failed_context_create:
+	kfree(dev->broadcast_rcv_buffer_ptrs);
+	dev->broadcast_rcv_buffer_ptrs = NULL;
+ failed_ptrs_alloc:
 
 	return retval;
 }
@@ -1626,8 +1626,6 @@ static int fwnet_remove(struct device *_dev)
 
 			fw_iso_context_stop(dev->broadcast_rcv_context);
 
-			kfree(dev->broadcast_rcv_buffer_ptrs);
-			dev->broadcast_rcv_buffer_ptrs = NULL;
 			for (u = 0; u < FWNET_ISO_PAGE_COUNT; u++)
 				kunmap(dev->broadcast_rcv_buffer.pages[u]);
 
@@ -1635,6 +1633,8 @@ static int fwnet_remove(struct device *_dev)
 					      dev->card);
 			fw_iso_context_destroy(dev->broadcast_rcv_context);
 			dev->broadcast_rcv_context = NULL;
+			kfree(dev->broadcast_rcv_buffer_ptrs);
+			dev->broadcast_rcv_buffer_ptrs = NULL;
 			dev->broadcast_state = FWNET_BROADCAST_ERROR;
 		}
 		for (i = 0; dev->queued_datagrams && i < 5; i++)

commit d9d2b484e0006d51591c3b9594e9d5f73b1a8d08
Author: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
Date:   Fri Mar 8 10:43:37 2013 +0900

    firewire net: Fix leakage of kmap for broadcast receive buffer.
    
    Signed-off-by: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index d8cb6ac31044..0dc2fdf00562 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -1228,6 +1228,8 @@ static int fwnet_broadcast_start(struct fwnet_device *dev)
  failed_rcv_queue:
 	kfree(dev->broadcast_rcv_buffer_ptrs);
 	dev->broadcast_rcv_buffer_ptrs = NULL;
+	for (u = 0; u < FWNET_ISO_PAGE_COUNT; u++)
+		kunmap(dev->broadcast_rcv_buffer.pages[u]);
  failed_ptrs_alloc:
 	fw_iso_buffer_destroy(&dev->broadcast_rcv_buffer, dev->card);
  failed_buffer_init:
@@ -1620,10 +1622,15 @@ static int fwnet_remove(struct device *_dev)
 
 		fwnet_fifo_stop(dev);
 		if (dev->broadcast_rcv_context) {
+			unsigned u;
+
 			fw_iso_context_stop(dev->broadcast_rcv_context);
 
 			kfree(dev->broadcast_rcv_buffer_ptrs);
 			dev->broadcast_rcv_buffer_ptrs = NULL;
+			for (u = 0; u < FWNET_ISO_PAGE_COUNT; u++)
+				kunmap(dev->broadcast_rcv_buffer.pages[u]);
+
 			fw_iso_buffer_destroy(&dev->broadcast_rcv_buffer,
 					      dev->card);
 			fw_iso_context_destroy(dev->broadcast_rcv_context);

commit f2090594dd28c033e0a9a267240ffca6d5afbd84
Author: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
Date:   Fri Mar 8 10:43:25 2013 +0900

    firewire net: Omit checking dev->broadcast_rcv_context in fwnet_broadcast_start().
    
    dev->broadcast_rcv_context is always non-NULL if dev->broadcast_state is
    not FWNET_BROADCAST_ERROR.
    
    Signed-off-by: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index efed4a65fb06..d8cb6ac31044 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -1154,6 +1154,7 @@ static int fwnet_broadcast_start(struct fwnet_device *dev)
 	unsigned max_receive;
 	struct fw_iso_packet packet;
 	unsigned long offset;
+	void **ptrptr;
 	unsigned u;
 
 	if (dev->broadcast_state != FWNET_BROADCAST_ERROR)
@@ -1162,42 +1163,36 @@ static int fwnet_broadcast_start(struct fwnet_device *dev)
 	max_receive = 1U << (dev->card->max_receive + 1);
 	num_packets = (FWNET_ISO_PAGE_COUNT * PAGE_SIZE) / max_receive;
 
-	if (!dev->broadcast_rcv_context) {
-		void **ptrptr;
-
-		context = fw_iso_context_create(dev->card,
-		    FW_ISO_CONTEXT_RECEIVE, IEEE1394_BROADCAST_CHANNEL,
-		    dev->card->link_speed, 8, fwnet_receive_broadcast, dev);
-		if (IS_ERR(context)) {
-			retval = PTR_ERR(context);
-			goto failed_context_create;
-		}
+	context = fw_iso_context_create(dev->card, FW_ISO_CONTEXT_RECEIVE,
+					IEEE1394_BROADCAST_CHANNEL,
+					dev->card->link_speed, 8,
+					fwnet_receive_broadcast, dev);
+	if (IS_ERR(context)) {
+		retval = PTR_ERR(context);
+		goto failed_context_create;
+	}
 
-		retval = fw_iso_buffer_init(&dev->broadcast_rcv_buffer,
-		    dev->card, FWNET_ISO_PAGE_COUNT, DMA_FROM_DEVICE);
-		if (retval < 0)
-			goto failed_buffer_init;
+	retval = fw_iso_buffer_init(&dev->broadcast_rcv_buffer, dev->card,
+				    FWNET_ISO_PAGE_COUNT, DMA_FROM_DEVICE);
+	if (retval < 0)
+		goto failed_buffer_init;
 
-		ptrptr = kmalloc(sizeof(void *) * num_packets, GFP_KERNEL);
-		if (!ptrptr) {
-			retval = -ENOMEM;
-			goto failed_ptrs_alloc;
-		}
+	ptrptr = kmalloc(sizeof(void *) * num_packets, GFP_KERNEL);
+	if (!ptrptr) {
+		retval = -ENOMEM;
+		goto failed_ptrs_alloc;
+	}
 
-		dev->broadcast_rcv_buffer_ptrs = ptrptr;
-		for (u = 0; u < FWNET_ISO_PAGE_COUNT; u++) {
-			void *ptr;
-			unsigned v;
+	dev->broadcast_rcv_buffer_ptrs = ptrptr;
+	for (u = 0; u < FWNET_ISO_PAGE_COUNT; u++) {
+		void *ptr;
+		unsigned v;
 
-			ptr = kmap(dev->broadcast_rcv_buffer.pages[u]);
-			for (v = 0; v < num_packets / FWNET_ISO_PAGE_COUNT; v++)
-				*ptrptr++ = (void *)
-						((char *)ptr + v * max_receive);
-		}
-		dev->broadcast_rcv_context = context;
-	} else {
-		context = dev->broadcast_rcv_context;
+		ptr = kmap(dev->broadcast_rcv_buffer.pages[u]);
+		for (v = 0; v < num_packets / FWNET_ISO_PAGE_COUNT; v++)
+			*ptrptr++ = (void *) ((char *)ptr + v * max_receive);
 	}
+	dev->broadcast_rcv_context = context;
 
 	packet.payload_length = max_receive;
 	packet.interrupt = 1;

commit f60bac4bc9f8c6b20b27a2be210a69e2f256f0a5
Author: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
Date:   Fri Mar 8 10:42:59 2013 +0900

    firewire net: Clear dev->broadcast_rcv_context and dev->broadcast_state after destruction of context.
    
    Clear dev->broadcast_rcv_context to NULL and set dev->broadcast_state
    to FWNET_BROADCAST_ERROR after descruction of broadcast context.
    
    Signed-off-by: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index d9b2105f22a0..efed4a65fb06 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -1626,11 +1626,14 @@ static int fwnet_remove(struct device *_dev)
 		fwnet_fifo_stop(dev);
 		if (dev->broadcast_rcv_context) {
 			fw_iso_context_stop(dev->broadcast_rcv_context);
+
 			kfree(dev->broadcast_rcv_buffer_ptrs);
 			dev->broadcast_rcv_buffer_ptrs = NULL;
 			fw_iso_buffer_destroy(&dev->broadcast_rcv_buffer,
 					      dev->card);
 			fw_iso_context_destroy(dev->broadcast_rcv_context);
+			dev->broadcast_rcv_context = NULL;
+			dev->broadcast_state = FWNET_BROADCAST_ERROR;
 		}
 		for (i = 0; dev->queued_datagrams && i < 5; i++)
 			ssleep(1);

commit 48a8406f5bd5cb49e1c03777ed19638de2628882
Author: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
Date:   Fri Mar 8 10:42:50 2013 +0900

    firewire net: Fix memory leakage in fwnet_remove().
    
    Signed-off-by: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index 9a2634ad6426..d9b2105f22a0 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -1626,6 +1626,8 @@ static int fwnet_remove(struct device *_dev)
 		fwnet_fifo_stop(dev);
 		if (dev->broadcast_rcv_context) {
 			fw_iso_context_stop(dev->broadcast_rcv_context);
+			kfree(dev->broadcast_rcv_buffer_ptrs);
+			dev->broadcast_rcv_buffer_ptrs = NULL;
 			fw_iso_buffer_destroy(&dev->broadcast_rcv_buffer,
 					      dev->card);
 			fw_iso_context_destroy(dev->broadcast_rcv_context);

commit 2fbd8dfee1dc50407eaf72e30333cf8ce1bba2cb
Author: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
Date:   Fri Mar 8 10:43:14 2013 +0900

    firewire net: Check dev->broadcast_state inside fwnet_broadcast_start().
    
    Signed-off-by: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index fbd07ebd3f5f..9a2634ad6426 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -1156,6 +1156,9 @@ static int fwnet_broadcast_start(struct fwnet_device *dev)
 	unsigned long offset;
 	unsigned u;
 
+	if (dev->broadcast_state != FWNET_BROADCAST_ERROR)
+		return 0;
+
 	max_receive = 1U << (dev->card->max_receive + 1);
 	num_packets = (FWNET_ISO_PAGE_COUNT * PAGE_SIZE) / max_receive;
 
@@ -1258,11 +1261,10 @@ static int fwnet_open(struct net_device *net)
 	if (ret)
 		return ret;
 
-	if (dev->broadcast_state == FWNET_BROADCAST_ERROR) {
-		ret = fwnet_broadcast_start(dev);
-		if (ret)
-			goto out;
-	}
+	ret = fwnet_broadcast_start(dev);
+	if (ret)
+		goto out;
+
 	netif_start_queue(net);
 
 	spin_lock_irq(&dev->lock);

commit b9a8871ac2aab0cc87190f1ab870785b32cc24aa
Author: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
Date:   Fri Mar 8 10:42:38 2013 +0900

    firewire net: Setup broadcast and local fifo independently.
    
    Signed-off-by: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index 96f6ee5bffd4..fbd07ebd3f5f 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -1156,10 +1156,6 @@ static int fwnet_broadcast_start(struct fwnet_device *dev)
 	unsigned long offset;
 	unsigned u;
 
-	retval = fwnet_fifo_start(dev);
-	if (retval < 0)
-		goto failed_initial;
-
 	max_receive = 1U << (dev->card->max_receive + 1);
 	num_packets = (FWNET_ISO_PAGE_COUNT * PAGE_SIZE) / max_receive;
 
@@ -1240,8 +1236,6 @@ static int fwnet_broadcast_start(struct fwnet_device *dev)
 	fw_iso_context_destroy(context);
 	dev->broadcast_rcv_context = NULL;
  failed_context_create:
-	fwnet_fifo_stop(dev);
- failed_initial:
 
 	return retval;
 }
@@ -1260,10 +1254,14 @@ static int fwnet_open(struct net_device *net)
 	struct fwnet_device *dev = netdev_priv(net);
 	int ret;
 
+	ret = fwnet_fifo_start(dev);
+	if (ret)
+		return ret;
+
 	if (dev->broadcast_state == FWNET_BROADCAST_ERROR) {
 		ret = fwnet_broadcast_start(dev);
 		if (ret)
-			return ret;
+			goto out;
 	}
 	netif_start_queue(net);
 
@@ -1272,6 +1270,9 @@ static int fwnet_open(struct net_device *net)
 	spin_unlock_irq(&dev->lock);
 
 	return 0;
+out:
+	fwnet_fifo_stop(dev);
+	return ret;
 }
 
 /* ifdown */

commit 9d39c90abc6766f875d2855a1a73c43b6ffa09c0
Author: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
Date:   Fri Mar 8 10:42:26 2013 +0900

    firewire net: Introduce fwnet_fifo_{start, stop}() helpers.
    
    Signed-off-by: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index a7a0e8277147..96f6ee5bffd4 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -1116,6 +1116,36 @@ static int fwnet_send_packet(struct fwnet_packet_task *ptask)
 	return 0;
 }
 
+static void fwnet_fifo_stop(struct fwnet_device *dev)
+{
+	if (dev->local_fifo == FWNET_NO_FIFO_ADDR)
+		return;
+
+	fw_core_remove_address_handler(&dev->handler);
+	dev->local_fifo = FWNET_NO_FIFO_ADDR;
+}
+
+static int fwnet_fifo_start(struct fwnet_device *dev)
+{
+	int retval;
+
+	if (dev->local_fifo != FWNET_NO_FIFO_ADDR)
+		return 0;
+
+	dev->handler.length = 4096;
+	dev->handler.address_callback = fwnet_receive_packet;
+	dev->handler.callback_data = dev;
+
+	retval = fw_core_add_address_handler(&dev->handler,
+					     &fw_high_memory_region);
+	if (retval < 0)
+		return retval;
+
+	dev->local_fifo = dev->handler.offset;
+
+	return 0;
+}
+
 static int fwnet_broadcast_start(struct fwnet_device *dev)
 {
 	struct fw_iso_context *context;
@@ -1126,18 +1156,9 @@ static int fwnet_broadcast_start(struct fwnet_device *dev)
 	unsigned long offset;
 	unsigned u;
 
-	if (dev->local_fifo == FWNET_NO_FIFO_ADDR) {
-		dev->handler.length = 4096;
-		dev->handler.address_callback = fwnet_receive_packet;
-		dev->handler.callback_data = dev;
-
-		retval = fw_core_add_address_handler(&dev->handler,
-					&fw_high_memory_region);
-		if (retval < 0)
-			goto failed_initial;
-
-		dev->local_fifo = dev->handler.offset;
-	}
+	retval = fwnet_fifo_start(dev);
+	if (retval < 0)
+		goto failed_initial;
 
 	max_receive = 1U << (dev->card->max_receive + 1);
 	num_packets = (FWNET_ISO_PAGE_COUNT * PAGE_SIZE) / max_receive;
@@ -1219,8 +1240,7 @@ static int fwnet_broadcast_start(struct fwnet_device *dev)
 	fw_iso_context_destroy(context);
 	dev->broadcast_rcv_context = NULL;
  failed_context_create:
-	fw_core_remove_address_handler(&dev->handler);
-	dev->local_fifo = FWNET_NO_FIFO_ADDR;
+	fwnet_fifo_stop(dev);
  failed_initial:
 
 	return retval;
@@ -1600,8 +1620,7 @@ static int fwnet_remove(struct device *_dev)
 	if (list_empty(&dev->peer_list)) {
 		unregister_netdev(net);
 
-		if (dev->local_fifo != FWNET_NO_FIFO_ADDR)
-			fw_core_remove_address_handler(&dev->handler);
+		fwnet_fifo_stop(dev);
 		if (dev->broadcast_rcv_context) {
 			fw_iso_context_stop(dev->broadcast_rcv_context);
 			fw_iso_buffer_destroy(&dev->broadcast_rcv_buffer,

commit 5104a03d7d0ef4b0222155f2fa6902bf727b1005
Author: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
Date:   Fri Mar 8 10:42:07 2013 +0900

    firewire net: No need to reset dev->local_fifo after failure of fw_core_add_address_handler().
    
    fwnet_broadcast_start() try to register address handler at first
    if it was not registered yet; dev->local_fifo ==
    FWNET_NO_FIFO_ADDR.
    
    Since dev->local_info not changed if fw_core_add_address_hander()
    has failed, we do not need to set dev->local_info to
    FWNET_NO_FIFO_ADDR.
    
    Signed-off-by: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index 2b27bff2591a..a7a0e8277147 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -1220,8 +1220,8 @@ static int fwnet_broadcast_start(struct fwnet_device *dev)
 	dev->broadcast_rcv_context = NULL;
  failed_context_create:
 	fw_core_remove_address_handler(&dev->handler);
- failed_initial:
 	dev->local_fifo = FWNET_NO_FIFO_ADDR;
+ failed_initial:
 
 	return retval;
 }

commit 825863408a1670035e7105368cbfe8b126290ba1
Author: YOSHIFUJI Hideaki /  <yoshfuji@linux-ipv6.org>
Date:   Sat Jan 19 22:03:07 2013 +0000

    firewire net: Use LL_RESERVED_SPACE(), HH_DATA_OFF().
    
    Signed-off-by: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index df6a1caea7b6..2b27bff2591a 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -270,7 +270,7 @@ static int fwnet_header_cache(const struct neighbour *neigh,
 	if (type == cpu_to_be16(ETH_P_802_3))
 		return -1;
 	net = neigh->dev;
-	h = (struct fwnet_header *)((u8 *)hh->hh_data + 16 - sizeof(*h));
+	h = (struct fwnet_header *)((u8 *)hh->hh_data + HH_DATA_OFF(sizeof(*h)));
 	h->h_proto = type;
 	memcpy(h->h_dest, neigh->ha, net->addr_len);
 	hh->hh_len = FWNET_HLEN;
@@ -282,7 +282,7 @@ static int fwnet_header_cache(const struct neighbour *neigh,
 static void fwnet_header_cache_update(struct hh_cache *hh,
 		const struct net_device *net, const unsigned char *haddr)
 {
-	memcpy((u8 *)hh->hh_data + 16 - FWNET_HLEN, haddr, net->addr_len);
+	memcpy((u8 *)hh->hh_data + HH_DATA_OFF(FWNET_HLEN), haddr, net->addr_len);
 }
 
 static int fwnet_header_parse(const struct sk_buff *skb, unsigned char *haddr)
@@ -398,11 +398,11 @@ static struct fwnet_partial_datagram *fwnet_pd_new(struct net_device *net,
 
 	new->datagram_label = datagram_label;
 	new->datagram_size = dg_size;
-	new->skb = dev_alloc_skb(dg_size + net->hard_header_len + 15);
+	new->skb = dev_alloc_skb(dg_size + LL_RESERVED_SPACE(net));
 	if (new->skb == NULL)
 		goto fail_w_fi;
 
-	skb_reserve(new->skb, (net->hard_header_len + 15) & ~15);
+	skb_reserve(new->skb, LL_RESERVED_SPACE(net));
 	new->pbuf = skb_put(new->skb, dg_size);
 	memcpy(new->pbuf + frag_off, frag_buf, frag_len);
 	list_add_tail(&new->pd_link, &peer->pd_list);
@@ -690,14 +690,14 @@ static int fwnet_incoming_packet(struct fwnet_device *dev, __be32 *buf, int len,
 		buf++;
 		len -= RFC2374_UNFRAG_HDR_SIZE;
 
-		skb = dev_alloc_skb(len + net->hard_header_len + 15);
+		skb = dev_alloc_skb(len + LL_RESERVED_SPACE(net));
 		if (unlikely(!skb)) {
 			dev_err(&net->dev, "out of memory\n");
 			net->stats.rx_dropped++;
 
 			return -ENOMEM;
 		}
-		skb_reserve(skb, (net->hard_header_len + 15) & ~15);
+		skb_reserve(skb, LL_RESERVED_SPACE(net));
 		memcpy(skb_put(skb, len), buf, len);
 
 		return fwnet_finish_incoming_packet(net, skb, source_node_id,

commit b577d7e2ad50cfbf43b648e34128a5c231cc5236
Author: YOSHIFUJI Hideaki /  <yoshfuji@linux-ipv6.org>
Date:   Sat Jan 19 21:43:40 2013 +0000

    firewire net: Ensure checksumming in upper layer.
    
    It is wrong to set skb->ip_summed to CHECKSUM_UNNECESSARY unless
    the device has already checked it.
    
    Signed-off-by: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index e7a711f53a6f..df6a1caea7b6 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -520,7 +520,7 @@ static int fwnet_finish_incoming_packet(struct net_device *net,
 	dev = netdev_priv(net);
 	/* Write metadata, and then pass to the receive level */
 	skb->dev = net;
-	skb->ip_summed = CHECKSUM_UNNECESSARY;  /* don't check it */
+	skb->ip_summed = CHECKSUM_NONE;
 
 	/*
 	 * Parse the encapsulation header. This actually does the job of

commit db2cad2f55078e90f84960b84b721291efa83d36
Author: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
Date:   Mon Dec 3 08:11:17 2012 -0500

    firewire: net: remove unused variable in fwnet_receive_broadcast()
    
    The variable card is initialized but never used
    otherwise, so remove the unused variable.
    
    Signed-off-by: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index 638e1f71284a..e7a711f53a6f 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -828,7 +828,6 @@ static void fwnet_receive_broadcast(struct fw_iso_context *context,
 {
 	struct fwnet_device *dev;
 	struct fw_iso_packet packet;
-	struct fw_card *card;
 	__be16 *hdr_ptr;
 	__be32 *buf_ptr;
 	int retval;
@@ -840,7 +839,6 @@ static void fwnet_receive_broadcast(struct fw_iso_context *context,
 	unsigned long flags;
 
 	dev = data;
-	card = dev->card;
 	hdr_ptr = header;
 	length = be16_to_cpup(hdr_ptr);
 

commit 9d2373420900a39f5212a3b289331aa3535b1000
Author: Stephan Gatzka <stephan.gatzka@gmail.com>
Date:   Wed Nov 28 20:04:32 2012 +0100

    firewire: net: Fix handling of fragmented multicast/broadcast packets.
    
    This patch fixes both the transmit and receive portion of sending
    fragmented mutlicast and broadcast packets.
    
    The transmit section was broken because the offset for INTFRAG and
    LASTFRAG packets were just miscalculated by IEEE1394_GASP_HDR_SIZE (which
    was reserved with skb_push() in fwnet_send_packet).
    
    The receive section was broken because in fwnet_incoming_packet is a call
    to fwnet_peer_find_by_node_id(). Called with generation == -1 it will
    not find a peer and the partial datagrams are associated to a peer.
    
    [Stefan R:  The fix to use context->card->generation is not perfect.
    It relies on the IR tasklet which processes packets from the prior bus
    generation to run before the self-ID-complete worklet which sets the
    current card generation.  Alas, there is no simple way of a race-free
    implementation.  Let's do it this way for now.]
    
    Signed-off-by: Stephan Gatzka <stephan.gatzka@gmail.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index 08c674957af8..638e1f71284a 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -861,8 +861,8 @@ static void fwnet_receive_broadcast(struct fw_iso_context *context,
 	if (specifier_id == IANA_SPECIFIER_ID && ver == RFC2734_SW_VERSION) {
 		buf_ptr += 2;
 		length -= IEEE1394_GASP_HDR_SIZE;
-		fwnet_incoming_packet(dev, buf_ptr, length,
-				      source_node_id, -1, true);
+		fwnet_incoming_packet(dev, buf_ptr, length, source_node_id,
+				      context->card->generation, true);
 	}
 
 	packet.payload_length = dev->rcv_buffer_size;
@@ -958,7 +958,12 @@ static void fwnet_transmit_packet_done(struct fwnet_packet_task *ptask)
 			break;
 		}
 
-		skb_pull(skb, ptask->max_payload);
+		if (ptask->dest_node == IEEE1394_ALL_NODES) {
+			skb_pull(skb,
+				 ptask->max_payload + IEEE1394_GASP_HDR_SIZE);
+		} else {
+			skb_pull(skb, ptask->max_payload);
+		}
 		if (ptask->outstanding_pkts > 1) {
 			fwnet_make_sf_hdr(&ptask->hdr, RFC2374_HDR_INTFRAG,
 					  dg_size, fg_off, datagram_label);
@@ -1062,7 +1067,7 @@ static int fwnet_send_packet(struct fwnet_packet_task *ptask)
 		smp_rmb();
 		node_id = dev->card->node_id;
 
-		p = skb_push(ptask->skb, 8);
+		p = skb_push(ptask->skb, IEEE1394_GASP_HDR_SIZE);
 		put_unaligned_be32(node_id << 16 | IANA_SPECIFIER_ID >> 8, p);
 		put_unaligned_be32((IANA_SPECIFIER_ID & 0xff) << 24
 						| RFC2734_SW_VERSION, &p[4]);

commit 8408dc1c14c113face77f6f967af98f76999989f
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sun Feb 19 12:48:36 2012 +0100

    firewire: net: use dev_printk API
    
    Change the log line prefix from "firewire_net: " to "net firewire0: "
    etc. for the case that several RFC 2734 interfaces are being used in the
    same machine.
    
    Note, the netdev_printk API is not very useful to firewire-net.
    netdev_notice(net, "abc\n") would result in irritating messages like
    "firewire_ohci 0000:0a:00.0: firewire0: abc".  Nor would a dev_printk on
    the fw_unit.device to which firewire-net is being bound be useful,
    because there are generally multiple ones of those per interface (from
    all RFC 2734 peers on the bus, the local node being only one of them).
    
    In the initialization message of each interface, log the PCI device
    name of the card which is parent of the netdevice instead of the GUID
    of the peer which was semi-randomly used to establish the netdevice.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index fa305187f468..08c674957af8 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -256,8 +256,8 @@ static int fwnet_header_rebuild(struct sk_buff *skb)
 	if (get_unaligned_be16(&h->h_proto) == ETH_P_IP)
 		return arp_find((unsigned char *)&h->h_dest, skb);
 
-	fw_notify("%s: unable to resolve type %04x addresses\n",
-		  skb->dev->name, be16_to_cpu(h->h_proto));
+	dev_notice(&skb->dev->dev, "unable to resolve type %04x addresses\n",
+		   be16_to_cpu(h->h_proto));
 	return 0;
 }
 
@@ -369,7 +369,7 @@ static struct fwnet_fragment_info *fwnet_frag_new(
 
 	new = kmalloc(sizeof(*new), GFP_ATOMIC);
 	if (!new) {
-		fw_error("out of memory\n");
+		dev_err(&pd->skb->dev->dev, "out of memory\n");
 		return NULL;
 	}
 
@@ -414,7 +414,7 @@ static struct fwnet_partial_datagram *fwnet_pd_new(struct net_device *net,
 fail_w_new:
 	kfree(new);
 fail:
-	fw_error("out of memory\n");
+	dev_err(&net->dev, "out of memory\n");
 
 	return NULL;
 }
@@ -554,7 +554,7 @@ static int fwnet_finish_incoming_packet(struct net_device *net,
 		sspd = arp1394->sspd;
 		/* Sanity check.  OS X 10.3 PPC reportedly sends 131. */
 		if (sspd > SCODE_3200) {
-			fw_notify("sspd %x out of range\n", sspd);
+			dev_notice(&net->dev, "sspd %x out of range\n", sspd);
 			sspd = SCODE_3200;
 		}
 		max_payload = fwnet_max_payload(arp1394->max_rec, sspd);
@@ -574,8 +574,9 @@ static int fwnet_finish_incoming_packet(struct net_device *net,
 		spin_unlock_irqrestore(&dev->lock, flags);
 
 		if (!peer) {
-			fw_notify("No peer for ARP packet from %016llx\n",
-				  (unsigned long long)peer_guid);
+			dev_notice(&net->dev,
+				   "no peer for ARP packet from %016llx\n",
+				   (unsigned long long)peer_guid);
 			goto no_peer;
 		}
 
@@ -691,7 +692,7 @@ static int fwnet_incoming_packet(struct fwnet_device *dev, __be32 *buf, int len,
 
 		skb = dev_alloc_skb(len + net->hard_header_len + 15);
 		if (unlikely(!skb)) {
-			fw_error("out of memory\n");
+			dev_err(&net->dev, "out of memory\n");
 			net->stats.rx_dropped++;
 
 			return -ENOMEM;
@@ -814,7 +815,7 @@ static void fwnet_receive_packet(struct fw_card *card, struct fw_request *r,
 		rcode = RCODE_TYPE_ERROR;
 	else if (fwnet_incoming_packet(dev, payload, length,
 				       source, generation, false) != 0) {
-		fw_error("Incoming packet failure\n");
+		dev_err(&dev->netdev->dev, "incoming packet failure\n");
 		rcode = RCODE_CONFLICT_ERROR;
 	} else
 		rcode = RCODE_COMPLETE;
@@ -881,7 +882,7 @@ static void fwnet_receive_broadcast(struct fw_iso_context *context,
 	if (retval >= 0)
 		fw_iso_context_queue_flush(dev->broadcast_rcv_context);
 	else
-		fw_error("requeue failed\n");
+		dev_err(&dev->netdev->dev, "requeue failed\n");
 }
 
 static struct kmem_cache *fwnet_packet_task_cache;
@@ -936,9 +937,10 @@ static void fwnet_transmit_packet_done(struct fwnet_packet_task *ptask)
 		case RFC2374_HDR_LASTFRAG:
 		case RFC2374_HDR_UNFRAG:
 		default:
-			fw_error("Outstanding packet %x lf %x, header %x,%x\n",
-				 ptask->outstanding_pkts, lf, ptask->hdr.w0,
-				 ptask->hdr.w1);
+			dev_err(&dev->netdev->dev,
+				"outstanding packet %x lf %x, header %x,%x\n",
+				ptask->outstanding_pkts, lf, ptask->hdr.w0,
+				ptask->hdr.w1);
 			BUG();
 
 		case RFC2374_HDR_FIRSTFRAG:
@@ -1010,8 +1012,9 @@ static void fwnet_write_complete(struct fw_card *card, int rcode,
 		fwnet_transmit_packet_failed(ptask);
 
 		if (printk_timed_ratelimit(&j,  1000) || rcode != last_rcode) {
-			fw_error("fwnet_write_complete: "
-				"failed: %x (skipped %d)\n", rcode, errors_skipped);
+			dev_err(&ptask->dev->netdev->dev,
+				"fwnet_write_complete failed: %x (skipped %d)\n",
+				rcode, errors_skipped);
 
 			errors_skipped = 0;
 			last_rcode = rcode;
@@ -1539,14 +1542,12 @@ static int fwnet_probe(struct device *_dev)
 	put_unaligned_be64(card->guid, net->dev_addr);
 	put_unaligned_be64(~0ULL, net->broadcast);
 	ret = register_netdev(net);
-	if (ret) {
-		fw_error("Cannot register the driver\n");
+	if (ret)
 		goto out;
-	}
 
 	list_add_tail(&dev->dev_link, &fwnet_device_list);
-	fw_notify("%s: IPv4 over FireWire on device %016llx\n",
-		  net->name, (unsigned long long)card->guid);
+	dev_notice(&net->dev, "IPv4 over IEEE 1394 on card %s\n",
+		   dev_name(card->device));
  have_dev:
 	ret = fwnet_add_peer(dev, unit, device);
 	if (ret && allocated_netdev) {

commit 59759ff6f151dab70cc227c337fc54da221cf8d7
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sat Feb 18 22:01:54 2012 +0100

    firewire: net: identify to driver core as "firewire_net", not "net"
    
    On second thought, there is little reason to have driver name differ
    from module name.  Therefore, change
        /sys/bus/firewire/drivers/net
        /sys/bus/firewire/devices/fw0.0/driver -> [...]/net
        /sys/module/firewire_net/drivers/firewire:net
    to
        /sys/bus/firewire/drivers/firewire_net
        /sys/bus/firewire/devices/fw0.0/driver -> [...]/firewire_net
        /sys/module/firewire_net/drivers/firewire:firewire_net
    It is redundant but consistent with firewire-sbp2's recently changed
    driver name.
    
    I don't see this anywhere used, so it should not matter either way.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index a20f45b1e7e5..fa305187f468 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -1648,7 +1648,7 @@ static const struct ieee1394_device_id fwnet_id_table[] = {
 static struct fw_driver fwnet_driver = {
 	.driver = {
 		.owner  = THIS_MODULE,
-		.name   = "net",
+		.name   = KBUILD_MODNAME,
 		.bus    = &fw_bus_type,
 		.probe  = fwnet_probe,
 		.remove = fwnet_remove,

commit a74477db9171e677b7a37b89e6e0ac8a15ba1f26
Author: Stephan Gatzka <stephan@gatzka.org>
Date:   Mon Sep 26 21:44:30 2011 +0200

    firewire: net: Use posted writes
    
    Change memory region to ohci "middle address space". This effectively
    reduces the number of packets by 50%.
    
    [Stefan R.:]  This eliminates 1394 ack packets and improved throughput
    by a few percent in some tests with an S400a connection with and without
    gap count optimization.  Since firewire-net taxes the AR-req DMA unit of
    a FireWire controller much more than firewire-sbp2 (which uses the
    middle address space with PCI posted writes too), this commit also
    changes a related error printk into a ratelimited one as a precaution.
    
    Side note:  The IPv4-over-1394 drivers of Mac OS X 10.4, Windows XP SP3,
    and the Thesycon 1394 bus driver for Windows all use the middle address
    space too.
    
    Signed-off-by: Stephan Gatzka <stephan@gatzka.org>
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index d1fad1fb17e2..a20f45b1e7e5 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -1121,17 +1121,12 @@ static int fwnet_broadcast_start(struct fwnet_device *dev)
 	unsigned u;
 
 	if (dev->local_fifo == FWNET_NO_FIFO_ADDR) {
-		/* outside OHCI posted write area? */
-		static const struct fw_address_region region = {
-			.start = 0xffff00000000ULL,
-			.end   = CSR_REGISTER_BASE,
-		};
-
 		dev->handler.length = 4096;
 		dev->handler.address_callback = fwnet_receive_packet;
 		dev->handler.callback_data = dev;
 
-		retval = fw_core_add_address_handler(&dev->handler, &region);
+		retval = fw_core_add_address_handler(&dev->handler,
+					&fw_high_memory_region);
 		if (retval < 0)
 			goto failed_initial;
 

commit 4ec4a67aa100268b4ac5ae32b54843d975969969
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Mon Sep 19 00:20:48 2011 +0200

    firewire: use clamp and min3 macros
    
    Use kernel.h's convenience macros.  Also omit a printk that should never
    happen and won't matter much if it ever happened.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index 03a7a85d0424..d1fad1fb17e2 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -502,11 +502,7 @@ static struct fwnet_peer *fwnet_peer_find_by_node_id(struct fwnet_device *dev,
 static unsigned fwnet_max_payload(unsigned max_rec, unsigned speed)
 {
 	max_rec = min(max_rec, speed + 8);
-	max_rec = min(max_rec, 0xbU); /* <= 4096 */
-	if (max_rec < 8) {
-		fw_notify("max_rec %x out of range\n", max_rec);
-		max_rec = 8;
-	}
+	max_rec = clamp(max_rec, 8U, 11U); /* 512...4096 */
 
 	return (1 << (max_rec + 1)) - RFC2374_FRAG_HDR_SIZE;
 }

commit 441c196e84b11aad3123baa9320eee7abc6b5c98
Merge: 951cc93a7493 9a00c24ae7cb
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jul 22 14:49:48 2011 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/ieee1394/linux1394-2.6
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/ieee1394/linux1394-2.6:
      firewire: document the sysfs ABIs
      firewire: cdev: ABI documentation enhancements
      firewire: cdev: prevent race between first get_info ioctl and bus reset event queuing
      firewire: cdev: return -ENOTTY for unimplemented ioctls, not -EINVAL
      firewire: ohci: skip soft reset retries after card ejection
      firewire: ohci: fix PHY reg access after card ejection
      firewire: ohci: add a comment on PHY reg access serialization
      firewire: ohci: reduce potential context_stop latency
      firewire: ohci: remove superfluous posted write flushes
      firewire: net: replacing deprecated __attribute__((packed)) with __packed

commit e69dd336ee3a05a589629b505b18ba5e7a5b4c54
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Jul 12 23:28:12 2011 -0700

    net: Push protocol type directly down to header_ops->cache()
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index b9762d07198d..eced1c25bf58 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -261,16 +261,16 @@ static int fwnet_header_rebuild(struct sk_buff *skb)
 }
 
 static int fwnet_header_cache(const struct neighbour *neigh,
-			      struct hh_cache *hh)
+			      struct hh_cache *hh, __be16 type)
 {
 	struct net_device *net;
 	struct fwnet_header *h;
 
-	if (hh->hh_type == cpu_to_be16(ETH_P_802_3))
+	if (type == cpu_to_be16(ETH_P_802_3))
 		return -1;
 	net = neigh->dev;
 	h = (struct fwnet_header *)((u8 *)hh->hh_data + 16 - sizeof(*h));
-	h->h_proto = hh->hh_type;
+	h->h_proto = type;
 	memcpy(h->h_dest, neigh->ha, net->addr_len);
 	hh->hh_len = FWNET_HLEN;
 

commit bf337b15c28ae25904a73e7e2e0de2f9c4f0e9f8
Author: August Lilleaas <august@augustl.com>
Date:   Sun May 29 19:07:19 2011 +0200

    firewire: net: replacing deprecated __attribute__((packed)) with __packed
    
    Fixing a deprecation, replacing __attribute__((packed)) with __packed.
    It was deprecated for portability, specifically to avoid GCC specific
    code.  See commit 82ddcb040570411fc2d421d96b3e69711c670328.
    
    Signed-off-by: August Lilleaas <august@augustl.com>
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de> (added include compiler.h)

diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index b9762d07198d..512492a122df 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -7,6 +7,7 @@
  */
 
 #include <linux/bug.h>
+#include <linux/compiler.h>
 #include <linux/delay.h>
 #include <linux/device.h>
 #include <linux/ethtool.h>
@@ -73,7 +74,7 @@ struct rfc2734_arp {
 	__be32 fifo_lo;		/* lo 32bits of sender's FIFO addr	*/
 	__be32 sip;		/* Sender's IP Address			*/
 	__be32 tip;		/* IP Address of requested hw addr	*/
-} __attribute__((packed));
+} __packed;
 
 /* This header format is specific to this driver implementation. */
 #define FWNET_ALEN	8
@@ -81,7 +82,7 @@ struct rfc2734_arp {
 struct fwnet_header {
 	u8 h_dest[FWNET_ALEN];	/* destination address */
 	__be16 h_proto;		/* packet type ID field */
-} __attribute__((packed));
+} __packed;
 
 /* IPv4 and IPv6 encapsulation header */
 struct rfc2734_header {

commit 13882a82ee1646336c3996c93b4a560a55d2a419
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon May 2 09:33:56 2011 +0200

    firewire: optimize iso queueing by setting wake only after the last packet
    
    When queueing iso packets, the run time is dominated by the two
    MMIO accesses that set the DMA context's wake bit.  Because most
    drivers submit packets in batches, we can save much time by
    removing all but the last wakeup.
    
    The internal kernel API is changed to require a call to
    fw_iso_context_queue_flush() after a batch of queued packets.
    The user space API does not change, so one call to
    FW_CDEV_IOC_QUEUE_ISO must specify multiple packets to take
    advantage of this optimization.
    
    In my measurements, this patch reduces the time needed to queue
    fifty skip packets from userspace to one sixth on a 2.5 GHz CPU,
    or to one third at 800 MHz.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index 3f04dd3681cf..b9762d07198d 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -881,7 +881,9 @@ static void fwnet_receive_broadcast(struct fw_iso_context *context,
 
 	spin_unlock_irqrestore(&dev->lock, flags);
 
-	if (retval < 0)
+	if (retval >= 0)
+		fw_iso_context_queue_flush(dev->broadcast_rcv_context);
+	else
 		fw_error("requeue failed\n");
 }
 

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index 7ed08fd1214e..3f04dd3681cf 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -453,7 +453,7 @@ static bool fwnet_pd_update(struct fwnet_peer *peer,
 	memcpy(pd->pbuf + frag_off, frag_buf, frag_len);
 
 	/*
-	 * Move list entry to beginnig of list so that oldest partial
+	 * Move list entry to beginning of list so that oldest partial
 	 * datagrams percolate to the end of the list
 	 */
 	list_move_tail(&pd->pd_link, &peer->pd_list);

commit 74a145049938b73b7e5421423f64a254d4192d3f
Author: Maxim Levitsky <maximlevitsky@gmail.com>
Date:   Mon Nov 29 04:09:52 2010 +0200

    firewire: net: invalidate ARP entries of removed nodes
    
    This makes it possible to resume communication with a node that dropped
    off the bus for a brief period.  Otherwise communication will only be
    possible after ARP cache entry timeouts.
    
    Signed-off-by: Maxim Levitsky <maximlevitsky@gmail.com>
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de> (rebased)

diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index c2e194c58667..7ed08fd1214e 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -191,6 +191,7 @@ struct fwnet_peer {
 	struct fwnet_device *dev;
 	u64 guid;
 	u64 fifo;
+	__be32 ip;
 
 	/* guarded by dev->lock */
 	struct list_head pd_list; /* received partial datagrams */
@@ -570,6 +571,8 @@ static int fwnet_finish_incoming_packet(struct net_device *net,
 				peer->speed = sspd;
 			if (peer->max_payload > max_payload)
 				peer->max_payload = max_payload;
+
+			peer->ip = arp1394->sip;
 		}
 		spin_unlock_irqrestore(&dev->lock, flags);
 
@@ -1470,6 +1473,7 @@ static int fwnet_add_peer(struct fwnet_device *dev,
 	peer->dev = dev;
 	peer->guid = (u64)device->config_rom[3] << 32 | device->config_rom[4];
 	peer->fifo = FWNET_NO_FIFO_ADDR;
+	peer->ip = 0;
 	INIT_LIST_HEAD(&peer->pd_list);
 	peer->pdg_size = 0;
 	peer->datagram_label = 0;
@@ -1589,10 +1593,13 @@ static int fwnet_remove(struct device *_dev)
 
 	mutex_lock(&fwnet_device_mutex);
 
+	net = dev->netdev;
+	if (net && peer->ip)
+		arp_invalidate(net, peer->ip);
+
 	fwnet_remove_peer(peer, dev);
 
 	if (list_empty(&dev->peer_list)) {
-		net = dev->netdev;
 		unregister_netdev(net);
 
 		if (dev->local_fifo != FWNET_NO_FIFO_ADDR)

commit c16714704bb35165e5b85d927873dcc643772648
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Fri Dec 17 22:22:33 2010 +0100

    firewire: net: set carrier state at ifup
    
    At ifup, carrier status would be shown on even if it actually was off.
    Also add an include for ethtool_ops rather than to rely on the one from
    netdevice.h.
    
    Note, we can alas not use fwnet_device_mutex to serialize access to
    dev->peer_count (as I originally wanted).  This would cause a lock
    inversion:
      - fwnet_probe | takes fwnet_device_mutex
          + register_netdev | takes rtnl_mutex
      - devinet_ioctl | takes rtnl_mutex
          + fwnet_open | ...must not take fwnet_device_mutex
    
    Hence use the dev->lock spinlock for serialization.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index 7fd51c9e243d..c2e194c58667 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -9,6 +9,7 @@
 #include <linux/bug.h>
 #include <linux/delay.h>
 #include <linux/device.h>
+#include <linux/ethtool.h>
 #include <linux/firewire.h>
 #include <linux/firewire-constants.h>
 #include <linux/highmem.h>
@@ -178,8 +179,8 @@ struct fwnet_device {
 
 	/* Number of tx datagrams that have been queued but not yet acked */
 	int queued_datagrams;
-	int peer_count;
 
+	int peer_count;
 	struct list_head peer_list;
 	struct fw_card *card;
 	struct net_device *netdev;
@@ -1222,6 +1223,14 @@ static int fwnet_broadcast_start(struct fwnet_device *dev)
 	return retval;
 }
 
+static void set_carrier_state(struct fwnet_device *dev)
+{
+	if (dev->peer_count > 1)
+		netif_carrier_on(dev->netdev);
+	else
+		netif_carrier_off(dev->netdev);
+}
+
 /* ifup */
 static int fwnet_open(struct net_device *net)
 {
@@ -1235,6 +1244,10 @@ static int fwnet_open(struct net_device *net)
 	}
 	netif_start_queue(net);
 
+	spin_lock_irq(&dev->lock);
+	set_carrier_state(dev);
+	spin_unlock_irq(&dev->lock);
+
 	return 0;
 }
 
@@ -1429,7 +1442,6 @@ static void fwnet_init_dev(struct net_device *net)
 	net->type		= ARPHRD_IEEE1394;
 	net->tx_queue_len	= FWNET_TX_QUEUE_LEN;
 	net->ethtool_ops	= &fwnet_ethtool_ops;
-
 }
 
 /* caller must hold fwnet_device_mutex */
@@ -1471,6 +1483,7 @@ static int fwnet_add_peer(struct fwnet_device *dev,
 	spin_lock_irq(&dev->lock);
 	list_add_tail(&peer->peer_link, &dev->peer_list);
 	dev->peer_count++;
+	set_carrier_state(dev);
 	spin_unlock_irq(&dev->lock);
 
 	return 0;
@@ -1542,9 +1555,6 @@ static int fwnet_probe(struct device *_dev)
 		unregister_netdev(net);
 		list_del(&dev->dev_link);
 	}
-
-	if (dev->peer_count > 1)
-		netif_carrier_on(net);
  out:
 	if (ret && allocated_netdev)
 		free_netdev(net);
@@ -1554,14 +1564,15 @@ static int fwnet_probe(struct device *_dev)
 	return ret;
 }
 
-static void fwnet_remove_peer(struct fwnet_peer *peer)
+static void fwnet_remove_peer(struct fwnet_peer *peer, struct fwnet_device *dev)
 {
 	struct fwnet_partial_datagram *pd, *pd_next;
 
-	spin_lock_irq(&peer->dev->lock);
+	spin_lock_irq(&dev->lock);
 	list_del(&peer->peer_link);
-	peer->dev->peer_count--;
-	spin_unlock_irq(&peer->dev->lock);
+	dev->peer_count--;
+	set_carrier_state(dev);
+	spin_unlock_irq(&dev->lock);
 
 	list_for_each_entry_safe(pd, pd_next, &peer->pd_list, pd_link)
 		fwnet_pd_delete(pd);
@@ -1578,12 +1589,7 @@ static int fwnet_remove(struct device *_dev)
 
 	mutex_lock(&fwnet_device_mutex);
 
-	fwnet_remove_peer(peer);
-
-	/* If we serve just one node, that means we lost link
-		with outer world */
-	if (dev->peer_count == 1)
-		netif_carrier_off(dev->netdev);
+	fwnet_remove_peer(peer, dev);
 
 	if (list_empty(&dev->peer_list)) {
 		net = dev->netdev;

commit 18bb36f9fab5980efeff063755c037a622f0231c
Author: Maxim Levitsky <maximlevitsky@gmail.com>
Date:   Wed Dec 8 04:22:57 2010 +0200

    firewire: net: add carrier detection
    
    To make userland, e.g. NetworkManager work with firewire, we need to
    detect whether cable is plugged or not.  Simple and correct way of doing
    that is just counting number of peers.  No peers - no link and vice
    versa.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index ea31e3084d67..7fd51c9e243d 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -178,6 +178,7 @@ struct fwnet_device {
 
 	/* Number of tx datagrams that have been queued but not yet acked */
 	int queued_datagrams;
+	int peer_count;
 
 	struct list_head peer_list;
 	struct fw_card *card;
@@ -1405,6 +1406,10 @@ static int fwnet_change_mtu(struct net_device *net, int new_mtu)
 	return 0;
 }
 
+static const struct ethtool_ops fwnet_ethtool_ops = {
+	.get_link	= ethtool_op_get_link,
+};
+
 static const struct net_device_ops fwnet_netdev_ops = {
 	.ndo_open       = fwnet_open,
 	.ndo_stop	= fwnet_stop,
@@ -1423,6 +1428,8 @@ static void fwnet_init_dev(struct net_device *net)
 	net->hard_header_len	= FWNET_HLEN;
 	net->type		= ARPHRD_IEEE1394;
 	net->tx_queue_len	= FWNET_TX_QUEUE_LEN;
+	net->ethtool_ops	= &fwnet_ethtool_ops;
+
 }
 
 /* caller must hold fwnet_device_mutex */
@@ -1463,6 +1470,7 @@ static int fwnet_add_peer(struct fwnet_device *dev,
 
 	spin_lock_irq(&dev->lock);
 	list_add_tail(&peer->peer_link, &dev->peer_list);
+	dev->peer_count++;
 	spin_unlock_irq(&dev->lock);
 
 	return 0;
@@ -1534,6 +1542,9 @@ static int fwnet_probe(struct device *_dev)
 		unregister_netdev(net);
 		list_del(&dev->dev_link);
 	}
+
+	if (dev->peer_count > 1)
+		netif_carrier_on(net);
  out:
 	if (ret && allocated_netdev)
 		free_netdev(net);
@@ -1549,6 +1560,7 @@ static void fwnet_remove_peer(struct fwnet_peer *peer)
 
 	spin_lock_irq(&peer->dev->lock);
 	list_del(&peer->peer_link);
+	peer->dev->peer_count--;
 	spin_unlock_irq(&peer->dev->lock);
 
 	list_for_each_entry_safe(pd, pd_next, &peer->pd_list, pd_link)
@@ -1568,6 +1580,11 @@ static int fwnet_remove(struct device *_dev)
 
 	fwnet_remove_peer(peer);
 
+	/* If we serve just one node, that means we lost link
+		with outer world */
+	if (dev->peer_count == 1)
+		netif_carrier_off(dev->netdev);
+
 	if (list_empty(&dev->peer_list)) {
 		net = dev->netdev;
 		unregister_netdev(net);

commit c4d6fd40df38eb4c187565d48807f5f902481ba8
Author: Maxim Levitsky <maximlevitsky@gmail.com>
Date:   Mon Nov 29 04:09:53 2010 +0200

    firewire: net: ratelimit error messages
    
    Unfortunately its easy to trigger such error messages by removing the
    cable while sending streams of data over the link.
    
    Such errors are normal, and therefore this patch stops firewire-net from
    flooding the kernel log with these errors, by combining series of same
    errors together.
    
    Signed-off-by: Maxim Levitsky <maximlevitsky@gmail.com>
    
    (Stefan R:)  Eventually we should remove this logging when firewire-net
    and related firewire-ohci facilities have been stabilized.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index 1a467a91fb0b..ea31e3084d67 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -996,15 +996,23 @@ static void fwnet_transmit_packet_failed(struct fwnet_packet_task *ptask)
 static void fwnet_write_complete(struct fw_card *card, int rcode,
 				 void *payload, size_t length, void *data)
 {
-	struct fwnet_packet_task *ptask;
-
-	ptask = data;
+	struct fwnet_packet_task *ptask = data;
+	static unsigned long j;
+	static int last_rcode, errors_skipped;
 
 	if (rcode == RCODE_COMPLETE) {
 		fwnet_transmit_packet_done(ptask);
 	} else {
-		fw_error("fwnet_write_complete: failed: %x\n", rcode);
 		fwnet_transmit_packet_failed(ptask);
+
+		if (printk_timed_ratelimit(&j,  1000) || rcode != last_rcode) {
+			fw_error("fwnet_write_complete: "
+				"failed: %x (skipped %d)\n", rcode, errors_skipped);
+
+			errors_skipped = 0;
+			last_rcode = rcode;
+		} else
+			errors_skipped++;
 	}
 }
 

commit b2268830f5cf29d94b3e4a2af0b795a8f28776fe
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sun Nov 14 14:35:40 2010 +0100

    firewire: net: throttle TX queue before running out of tlabels
    
    This prevents firewire-net from submitting write requests in fast
    succession until failure due to all 64 transaction labels were used up
    for unfinished split transactions.  The netif_stop/wake_queue API is
    used for this purpose.
    
    Without this stop/wake mechanism, datagrams were simply lost whenever
    the tlabel pool was exhausted.  Plus, tlabel exhaustion by firewire-net
    also prevented other unrelated outbound transactions to be initiated.
    
    The chosen queue depth was checked by me to hit the maximum possible
    throughput with an OS X peer whose receive DMA is good enough to never
    reject requests due to busy inbound request FIFO.  Current Linux peers
    show a mixed picture of -5%...+15% change in bandwidth; their current
    bottleneck are RCODE_BUSY situations (fewer or more, depending on TX
    queue depth) due to too small AR buffer in firewire-ohci.
    
    Maxim Levitsky tested this change with similar watermarks with a Linux
    peer and some pending firewire-ohci improvements that address the
    RCODE_BUSY problem and confirmed that these TX queue limits are good.
    
    Note:  This removes some netif_wake_queue from reception code paths.
    They were apparently copy&paste artefacts from a nonsensical
    netif_wake_queue use in the older eth1394 driver.  This belongs only
    into the transmit path.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>
    Tested-by: Maxim Levitsky <maximlevitsky@gmail.com>

diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index d2d488b9cd96..1a467a91fb0b 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -27,8 +27,14 @@
 #include <asm/unaligned.h>
 #include <net/arp.h>
 
-#define FWNET_MAX_FRAGMENTS	25	/* arbitrary limit */
-#define FWNET_ISO_PAGE_COUNT	(PAGE_SIZE < 16 * 1024 ? 4 : 2)
+/* rx limits */
+#define FWNET_MAX_FRAGMENTS		30 /* arbitrary, > TX queue depth */
+#define FWNET_ISO_PAGE_COUNT		(PAGE_SIZE < 16*1024 ? 4 : 2)
+
+/* tx limits */
+#define FWNET_MAX_QUEUED_DATAGRAMS	20 /* < 64 = number of tlabels */
+#define FWNET_MIN_QUEUED_DATAGRAMS	10 /* should keep AT DMA busy enough */
+#define FWNET_TX_QUEUE_LEN		FWNET_MAX_QUEUED_DATAGRAMS /* ? */
 
 #define IEEE1394_BROADCAST_CHANNEL	31
 #define IEEE1394_ALL_NODES		(0xffc0 | 0x003f)
@@ -640,8 +646,6 @@ static int fwnet_finish_incoming_packet(struct net_device *net,
 		net->stats.rx_packets++;
 		net->stats.rx_bytes += skb->len;
 	}
-	if (netif_queue_stopped(net))
-		netif_wake_queue(net);
 
 	return 0;
 
@@ -650,8 +654,6 @@ static int fwnet_finish_incoming_packet(struct net_device *net,
 	net->stats.rx_dropped++;
 
 	dev_kfree_skb_any(skb);
-	if (netif_queue_stopped(net))
-		netif_wake_queue(net);
 
 	return -ENOENT;
 }
@@ -783,15 +785,10 @@ static int fwnet_incoming_packet(struct fwnet_device *dev, __be32 *buf, int len,
 	 * Datagram is not complete, we're done for the
 	 * moment.
 	 */
-	spin_unlock_irqrestore(&dev->lock, flags);
-
-	return 0;
+	retval = 0;
  fail:
 	spin_unlock_irqrestore(&dev->lock, flags);
 
-	if (netif_queue_stopped(net))
-		netif_wake_queue(net);
-
 	return retval;
 }
 
@@ -891,6 +888,13 @@ static void fwnet_free_ptask(struct fwnet_packet_task *ptask)
 	kmem_cache_free(fwnet_packet_task_cache, ptask);
 }
 
+/* Caller must hold dev->lock. */
+static void dec_queued_datagrams(struct fwnet_device *dev)
+{
+	if (--dev->queued_datagrams == FWNET_MIN_QUEUED_DATAGRAMS)
+		netif_wake_queue(dev->netdev);
+}
+
 static int fwnet_send_packet(struct fwnet_packet_task *ptask);
 
 static void fwnet_transmit_packet_done(struct fwnet_packet_task *ptask)
@@ -907,7 +911,7 @@ static void fwnet_transmit_packet_done(struct fwnet_packet_task *ptask)
 	/* Check whether we or the networking TX soft-IRQ is last user. */
 	free = (ptask->outstanding_pkts == 0 && ptask->enqueued);
 	if (free)
-		dev->queued_datagrams--;
+		dec_queued_datagrams(dev);
 
 	if (ptask->outstanding_pkts == 0) {
 		dev->netdev->stats.tx_packets++;
@@ -978,7 +982,7 @@ static void fwnet_transmit_packet_failed(struct fwnet_packet_task *ptask)
 	/* Check whether we or the networking TX soft-IRQ is last user. */
 	free = ptask->enqueued;
 	if (free)
-		dev->queued_datagrams--;
+		dec_queued_datagrams(dev);
 
 	dev->netdev->stats.tx_dropped++;
 	dev->netdev->stats.tx_errors++;
@@ -1063,7 +1067,7 @@ static int fwnet_send_packet(struct fwnet_packet_task *ptask)
 		if (!free)
 			ptask->enqueued = true;
 		else
-			dev->queued_datagrams--;
+			dec_queued_datagrams(dev);
 
 		spin_unlock_irqrestore(&dev->lock, flags);
 
@@ -1082,7 +1086,7 @@ static int fwnet_send_packet(struct fwnet_packet_task *ptask)
 	if (!free)
 		ptask->enqueued = true;
 	else
-		dev->queued_datagrams--;
+		dec_queued_datagrams(dev);
 
 	spin_unlock_irqrestore(&dev->lock, flags);
 
@@ -1248,6 +1252,15 @@ static netdev_tx_t fwnet_tx(struct sk_buff *skb, struct net_device *net)
 	struct fwnet_peer *peer;
 	unsigned long flags;
 
+	spin_lock_irqsave(&dev->lock, flags);
+
+	/* Can this happen? */
+	if (netif_queue_stopped(dev->netdev)) {
+		spin_unlock_irqrestore(&dev->lock, flags);
+
+		return NETDEV_TX_BUSY;
+	}
+
 	ptask = kmem_cache_alloc(fwnet_packet_task_cache, GFP_ATOMIC);
 	if (ptask == NULL)
 		goto fail;
@@ -1266,9 +1279,6 @@ static netdev_tx_t fwnet_tx(struct sk_buff *skb, struct net_device *net)
 	proto = hdr_buf.h_proto;
 	dg_size = skb->len;
 
-	/* serialize access to peer, including peer->datagram_label */
-	spin_lock_irqsave(&dev->lock, flags);
-
 	/*
 	 * Set the transmission type for the packet.  ARP packets and IP
 	 * broadcast packets are sent via GASP.
@@ -1290,7 +1300,7 @@ static netdev_tx_t fwnet_tx(struct sk_buff *skb, struct net_device *net)
 
 		peer = fwnet_peer_find_by_guid(dev, be64_to_cpu(guid));
 		if (!peer || peer->fifo == FWNET_NO_FIFO_ADDR)
-			goto fail_unlock;
+			goto fail;
 
 		generation         = peer->generation;
 		dest_node          = peer->node_id;
@@ -1344,7 +1354,8 @@ static netdev_tx_t fwnet_tx(struct sk_buff *skb, struct net_device *net)
 		max_payload += RFC2374_FRAG_HDR_SIZE;
 	}
 
-	dev->queued_datagrams++;
+	if (++dev->queued_datagrams == FWNET_MAX_QUEUED_DATAGRAMS)
+		netif_stop_queue(dev->netdev);
 
 	spin_unlock_irqrestore(&dev->lock, flags);
 
@@ -1355,9 +1366,9 @@ static netdev_tx_t fwnet_tx(struct sk_buff *skb, struct net_device *net)
 
 	return NETDEV_TX_OK;
 
- fail_unlock:
-	spin_unlock_irqrestore(&dev->lock, flags);
  fail:
+	spin_unlock_irqrestore(&dev->lock, flags);
+
 	if (ptask)
 		kmem_cache_free(fwnet_packet_task_cache, ptask);
 
@@ -1403,7 +1414,7 @@ static void fwnet_init_dev(struct net_device *net)
 	net->addr_len		= FWNET_ALEN;
 	net->hard_header_len	= FWNET_HLEN;
 	net->type		= ARPHRD_IEEE1394;
-	net->tx_queue_len	= 10;
+	net->tx_queue_len	= FWNET_TX_QUEUE_LEN;
 }
 
 /* caller must hold fwnet_device_mutex */

commit 48553011cea504796e513350740781ac6745f556
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sat Nov 6 23:18:23 2010 +0100

    firewire: net: replace lists by counters
    
    The current transmit code does not at all make use of
      - fwnet_device.packet_list
    and only very limited use of
      - fwnet_device.broadcasted_list,
      - fwnet_device.queued_packets.
    Their current function is to track whether the TX soft-IRQ finished
    dealing with an skb when the AT-req tasklet takes over, and to discard
    pending tx datagrams (if there are any) when the local node is removed.
    
    The latter does actually contain a race condition bug with TX soft-IRQ
    and AT-req tasklet.
    
    Instead of these lists and the corresponding link in fwnet_packet_task,
      - a flag in fwnet_packet_task to track whether fwnet_tx is done,
      - a counter of queued datagrams in fwnet_device
    do the job as well.
    
    The above mentioned theoretic race condition is resolved by letting
    fwnet_remove sleep until all datagrams were flushed.  It may sleep
    almost arbitrarily long since fwnet_remove is executed in the context of
    a multithreaded (concurrency managed) workqueue.
    
    The type of max_payload is changed to u16 here to avoid waste in struct
    fwnet_packet_task.  This value cannot exceed 4096 per IEEE 1394:2008
    table 16-18 (or 32678 per specification of packet headers, if there is
    ever going to be something else than beta mode).
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index 3a27cee5bf26..d2d488b9cd96 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -7,6 +7,7 @@
  */
 
 #include <linux/bug.h>
+#include <linux/delay.h>
 #include <linux/device.h>
 #include <linux/firewire.h>
 #include <linux/firewire-constants.h>
@@ -169,15 +170,8 @@ struct fwnet_device {
 	struct fw_address_handler handler;
 	u64 local_fifo;
 
-	/* List of packets to be sent */
-	struct list_head packet_list;
-	/*
-	 * List of packets that were broadcasted.  When we get an ISO interrupt
-	 * one of them has been sent
-	 */
-	struct list_head broadcasted_list;
-	/* List of packets that have been sent but not yet acked */
-	struct list_head sent_list;
+	/* Number of tx datagrams that have been queued but not yet acked */
+	int queued_datagrams;
 
 	struct list_head peer_list;
 	struct fw_card *card;
@@ -195,7 +189,7 @@ struct fwnet_peer {
 	unsigned pdg_size;        /* pd_list size */
 
 	u16 datagram_label;       /* outgoing datagram label */
-	unsigned max_payload;     /* includes RFC2374_FRAG_HDR_SIZE overhead */
+	u16 max_payload;          /* includes RFC2374_FRAG_HDR_SIZE overhead */
 	int node_id;
 	int generation;
 	unsigned speed;
@@ -203,22 +197,18 @@ struct fwnet_peer {
 
 /* This is our task struct. It's used for the packet complete callback.  */
 struct fwnet_packet_task {
-	/*
-	 * ptask can actually be on dev->packet_list, dev->broadcasted_list,
-	 * or dev->sent_list depending on its current state.
-	 */
-	struct list_head pt_link;
 	struct fw_transaction transaction;
 	struct rfc2734_header hdr;
 	struct sk_buff *skb;
 	struct fwnet_device *dev;
 
 	int outstanding_pkts;
-	unsigned max_payload;
 	u64 fifo_addr;
 	u16 dest_node;
+	u16 max_payload;
 	u8 generation;
 	u8 speed;
+	u8 enqueued;
 };
 
 /*
@@ -915,9 +905,9 @@ static void fwnet_transmit_packet_done(struct fwnet_packet_task *ptask)
 	ptask->outstanding_pkts--;
 
 	/* Check whether we or the networking TX soft-IRQ is last user. */
-	free = (ptask->outstanding_pkts == 0 && !list_empty(&ptask->pt_link));
+	free = (ptask->outstanding_pkts == 0 && ptask->enqueued);
 	if (free)
-		list_del(&ptask->pt_link);
+		dev->queued_datagrams--;
 
 	if (ptask->outstanding_pkts == 0) {
 		dev->netdev->stats.tx_packets++;
@@ -986,9 +976,9 @@ static void fwnet_transmit_packet_failed(struct fwnet_packet_task *ptask)
 	ptask->outstanding_pkts = 0;
 
 	/* Check whether we or the networking TX soft-IRQ is last user. */
-	free = !list_empty(&ptask->pt_link);
+	free = ptask->enqueued;
 	if (free)
-		list_del(&ptask->pt_link);
+		dev->queued_datagrams--;
 
 	dev->netdev->stats.tx_dropped++;
 	dev->netdev->stats.tx_errors++;
@@ -1069,9 +1059,11 @@ static int fwnet_send_packet(struct fwnet_packet_task *ptask)
 		spin_lock_irqsave(&dev->lock, flags);
 
 		/* If the AT tasklet already ran, we may be last user. */
-		free = (ptask->outstanding_pkts == 0 && list_empty(&ptask->pt_link));
+		free = (ptask->outstanding_pkts == 0 && !ptask->enqueued);
 		if (!free)
-			list_add_tail(&ptask->pt_link, &dev->broadcasted_list);
+			ptask->enqueued = true;
+		else
+			dev->queued_datagrams--;
 
 		spin_unlock_irqrestore(&dev->lock, flags);
 
@@ -1086,9 +1078,11 @@ static int fwnet_send_packet(struct fwnet_packet_task *ptask)
 	spin_lock_irqsave(&dev->lock, flags);
 
 	/* If the AT tasklet already ran, we may be last user. */
-	free = (ptask->outstanding_pkts == 0 && list_empty(&ptask->pt_link));
+	free = (ptask->outstanding_pkts == 0 && !ptask->enqueued);
 	if (!free)
-		list_add_tail(&ptask->pt_link, &dev->sent_list);
+		ptask->enqueued = true;
+	else
+		dev->queued_datagrams--;
 
 	spin_unlock_irqrestore(&dev->lock, flags);
 
@@ -1350,10 +1344,12 @@ static netdev_tx_t fwnet_tx(struct sk_buff *skb, struct net_device *net)
 		max_payload += RFC2374_FRAG_HDR_SIZE;
 	}
 
+	dev->queued_datagrams++;
+
 	spin_unlock_irqrestore(&dev->lock, flags);
 
 	ptask->max_payload = max_payload;
-	INIT_LIST_HEAD(&ptask->pt_link);
+	ptask->enqueued    = 0;
 
 	fwnet_send_packet(ptask);
 
@@ -1487,14 +1483,9 @@ static int fwnet_probe(struct device *_dev)
 	dev->broadcast_rcv_context = NULL;
 	dev->broadcast_xmt_max_payload = 0;
 	dev->broadcast_xmt_datagramlabel = 0;
-
 	dev->local_fifo = FWNET_NO_FIFO_ADDR;
-
-	INIT_LIST_HEAD(&dev->packet_list);
-	INIT_LIST_HEAD(&dev->broadcasted_list);
-	INIT_LIST_HEAD(&dev->sent_list);
+	dev->queued_datagrams = 0;
 	INIT_LIST_HEAD(&dev->peer_list);
-
 	dev->card = card;
 	dev->netdev = net;
 
@@ -1552,7 +1543,7 @@ static int fwnet_remove(struct device *_dev)
 	struct fwnet_peer *peer = dev_get_drvdata(_dev);
 	struct fwnet_device *dev = peer->dev;
 	struct net_device *net;
-	struct fwnet_packet_task *ptask, *pt_next;
+	int i;
 
 	mutex_lock(&fwnet_device_mutex);
 
@@ -1570,21 +1561,9 @@ static int fwnet_remove(struct device *_dev)
 					      dev->card);
 			fw_iso_context_destroy(dev->broadcast_rcv_context);
 		}
-		list_for_each_entry_safe(ptask, pt_next,
-					 &dev->packet_list, pt_link) {
-			dev_kfree_skb_any(ptask->skb);
-			kmem_cache_free(fwnet_packet_task_cache, ptask);
-		}
-		list_for_each_entry_safe(ptask, pt_next,
-					 &dev->broadcasted_list, pt_link) {
-			dev_kfree_skb_any(ptask->skb);
-			kmem_cache_free(fwnet_packet_task_cache, ptask);
-		}
-		list_for_each_entry_safe(ptask, pt_next,
-					 &dev->sent_list, pt_link) {
-			dev_kfree_skb_any(ptask->skb);
-			kmem_cache_free(fwnet_packet_task_cache, ptask);
-		}
+		for (i = 0; dev->queued_datagrams && i < 5; i++)
+			ssleep(1);
+		WARN_ON(dev->queued_datagrams);
 		list_del(&dev->dev_link);
 
 		free_netdev(net);

commit 7ee11fa8d0a84b05cefe12b0bebc05ab0ea89cd6
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sat Nov 6 16:57:28 2010 +0100

    firewire: net: fix memory leaks
    
    a) fwnet_transmit_packet_done used to poison ptask->pt_link by list_del.
    If fwnet_send_packet checked later whether it was responsible to clean
    up (in the border case that the TX soft IRQ was outpaced by the AT-req
    tasklet on another CPU), it missed this because ptask->pt_link was no
    longer shown as empty.
    
    b) If fwnet_write_complete got an rcode other than RCODE_COMPLETE, we
    missed to free the skb and ptask entirely.
    
    Also, count stats.tx_dropped and stats.tx_errors when rcode != 0.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index e2e968e732bc..3a27cee5bf26 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -916,9 +916,10 @@ static void fwnet_transmit_packet_done(struct fwnet_packet_task *ptask)
 
 	/* Check whether we or the networking TX soft-IRQ is last user. */
 	free = (ptask->outstanding_pkts == 0 && !list_empty(&ptask->pt_link));
+	if (free)
+		list_del(&ptask->pt_link);
 
 	if (ptask->outstanding_pkts == 0) {
-		list_del(&ptask->pt_link);
 		dev->netdev->stats.tx_packets++;
 		dev->netdev->stats.tx_bytes += skb->len;
 	}
@@ -973,6 +974,31 @@ static void fwnet_transmit_packet_done(struct fwnet_packet_task *ptask)
 		fwnet_free_ptask(ptask);
 }
 
+static void fwnet_transmit_packet_failed(struct fwnet_packet_task *ptask)
+{
+	struct fwnet_device *dev = ptask->dev;
+	unsigned long flags;
+	bool free;
+
+	spin_lock_irqsave(&dev->lock, flags);
+
+	/* One fragment failed; don't try to send remaining fragments. */
+	ptask->outstanding_pkts = 0;
+
+	/* Check whether we or the networking TX soft-IRQ is last user. */
+	free = !list_empty(&ptask->pt_link);
+	if (free)
+		list_del(&ptask->pt_link);
+
+	dev->netdev->stats.tx_dropped++;
+	dev->netdev->stats.tx_errors++;
+
+	spin_unlock_irqrestore(&dev->lock, flags);
+
+	if (free)
+		fwnet_free_ptask(ptask);
+}
+
 static void fwnet_write_complete(struct fw_card *card, int rcode,
 				 void *payload, size_t length, void *data)
 {
@@ -980,11 +1006,12 @@ static void fwnet_write_complete(struct fw_card *card, int rcode,
 
 	ptask = data;
 
-	if (rcode == RCODE_COMPLETE)
+	if (rcode == RCODE_COMPLETE) {
 		fwnet_transmit_packet_done(ptask);
-	else
+	} else {
 		fw_error("fwnet_write_complete: failed: %x\n", rcode);
-		/* ??? error recovery */
+		fwnet_transmit_packet_failed(ptask);
+	}
 }
 
 static int fwnet_send_packet(struct fwnet_packet_task *ptask)

commit 902bca00dc6e3b3ff5fbb1e32e5dbb45d5f30579
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sat Nov 6 12:36:13 2010 +0100

    firewire: net: count stats.tx_packets and stats.tx_bytes
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index 18fdd9703b48..e2e968e732bc 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -906,6 +906,7 @@ static int fwnet_send_packet(struct fwnet_packet_task *ptask);
 static void fwnet_transmit_packet_done(struct fwnet_packet_task *ptask)
 {
 	struct fwnet_device *dev = ptask->dev;
+	struct sk_buff *skb = ptask->skb;
 	unsigned long flags;
 	bool free;
 
@@ -916,8 +917,11 @@ static void fwnet_transmit_packet_done(struct fwnet_packet_task *ptask)
 	/* Check whether we or the networking TX soft-IRQ is last user. */
 	free = (ptask->outstanding_pkts == 0 && !list_empty(&ptask->pt_link));
 
-	if (ptask->outstanding_pkts == 0)
+	if (ptask->outstanding_pkts == 0) {
 		list_del(&ptask->pt_link);
+		dev->netdev->stats.tx_packets++;
+		dev->netdev->stats.tx_bytes += skb->len;
+	}
 
 	spin_unlock_irqrestore(&dev->lock, flags);
 
@@ -926,7 +930,6 @@ static void fwnet_transmit_packet_done(struct fwnet_packet_task *ptask)
 		u16 fg_off;
 		u16 datagram_label;
 		u16 lf;
-		struct sk_buff *skb;
 
 		/* Update the ptask to point to the next fragment and send it */
 		lf = fwnet_get_hdr_lf(&ptask->hdr);
@@ -953,7 +956,7 @@ static void fwnet_transmit_packet_done(struct fwnet_packet_task *ptask)
 			datagram_label = fwnet_get_hdr_dgl(&ptask->hdr);
 			break;
 		}
-		skb = ptask->skb;
+
 		skb_pull(skb, ptask->max_payload);
 		if (ptask->outstanding_pkts > 1) {
 			fwnet_make_sf_hdr(&ptask->hdr, RFC2374_HDR_INTFRAG,

commit e548833df83c3554229eff0672900bfe958b45fd
Merge: cbd9da7be869 053d8f662270
Author: David S. Miller <davem@davemloft.net>
Date:   Thu Sep 9 22:27:33 2010 -0700

    Merge branch 'master' of master.kernel.org:/pub/scm/linux/kernel/git/davem/net-2.6
    
    Conflicts:
            net/mac80211/main.c

commit 1bf145fed572583d4cb7c1784689a0b42c997ba6
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Mon Aug 16 23:45:54 2010 +0200

    firewire: net: fix unicast reception RCODE in failure paths
    
    The incoming request hander fwnet_receive_packet() expects subsequent
    datagram handling code to return non-zero on errors.  However, almost
    none of the failure paths did so.  Fix them all.
    
    (This error reporting is used to send and RCODE_CONFLICT_ERROR to the
    sender node in such failure cases.  Two modes of failure exist:  Out of
    memory, or firewire-net is unaware of any peer node to which a fragment
    or an ARP packet belongs.  However, it is unclear whether a sender can
    actually make use of such information.  A Linux peer apparently can't.
    Maybe it should all be simplified to void functions.)
    
    Reported-by: Julia Lawall <julia@diku.dk>
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index da17d409a244..33f8421c71cc 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -579,7 +579,7 @@ static int fwnet_finish_incoming_packet(struct net_device *net,
 		if (!peer) {
 			fw_notify("No peer for ARP packet from %016llx\n",
 				  (unsigned long long)peer_guid);
-			goto failed_proto;
+			goto no_peer;
 		}
 
 		/*
@@ -656,7 +656,7 @@ static int fwnet_finish_incoming_packet(struct net_device *net,
 
 	return 0;
 
- failed_proto:
+ no_peer:
 	net->stats.rx_errors++;
 	net->stats.rx_dropped++;
 
@@ -664,7 +664,7 @@ static int fwnet_finish_incoming_packet(struct net_device *net,
 	if (netif_queue_stopped(net))
 		netif_wake_queue(net);
 
-	return 0;
+	return -ENOENT;
 }
 
 static int fwnet_incoming_packet(struct fwnet_device *dev, __be32 *buf, int len,
@@ -701,7 +701,7 @@ static int fwnet_incoming_packet(struct fwnet_device *dev, __be32 *buf, int len,
 			fw_error("out of memory\n");
 			net->stats.rx_dropped++;
 
-			return -1;
+			return -ENOMEM;
 		}
 		skb_reserve(skb, (net->hard_header_len + 15) & ~15);
 		memcpy(skb_put(skb, len), buf, len);
@@ -726,8 +726,10 @@ static int fwnet_incoming_packet(struct fwnet_device *dev, __be32 *buf, int len,
 	spin_lock_irqsave(&dev->lock, flags);
 
 	peer = fwnet_peer_find_by_node_id(dev, source_node_id, generation);
-	if (!peer)
-		goto bad_proto;
+	if (!peer) {
+		retval = -ENOENT;
+		goto fail;
+	}
 
 	pd = fwnet_pd_find(peer, datagram_label);
 	if (pd == NULL) {
@@ -741,7 +743,7 @@ static int fwnet_incoming_packet(struct fwnet_device *dev, __be32 *buf, int len,
 				  dg_size, buf, fg_off, len);
 		if (pd == NULL) {
 			retval = -ENOMEM;
-			goto bad_proto;
+			goto fail;
 		}
 		peer->pdg_size++;
 	} else {
@@ -755,9 +757,9 @@ static int fwnet_incoming_packet(struct fwnet_device *dev, __be32 *buf, int len,
 			pd = fwnet_pd_new(net, peer, datagram_label,
 					  dg_size, buf, fg_off, len);
 			if (pd == NULL) {
-				retval = -ENOMEM;
 				peer->pdg_size--;
-				goto bad_proto;
+				retval = -ENOMEM;
+				goto fail;
 			}
 		} else {
 			if (!fwnet_pd_update(peer, pd, buf, fg_off, len)) {
@@ -768,7 +770,8 @@ static int fwnet_incoming_packet(struct fwnet_device *dev, __be32 *buf, int len,
 				 */
 				fwnet_pd_delete(pd);
 				peer->pdg_size--;
-				goto bad_proto;
+				retval = -ENOMEM;
+				goto fail;
 			}
 		}
 	} /* new datagram or add to existing one */
@@ -794,14 +797,13 @@ static int fwnet_incoming_packet(struct fwnet_device *dev, __be32 *buf, int len,
 	spin_unlock_irqrestore(&dev->lock, flags);
 
 	return 0;
-
- bad_proto:
+ fail:
 	spin_unlock_irqrestore(&dev->lock, flags);
 
 	if (netif_queue_stopped(net))
 		netif_wake_queue(net);
 
-	return 0;
+	return retval;
 }
 
 static void fwnet_receive_packet(struct fw_card *card, struct fw_request *r,

commit 01414802054c382072b6cb9a1bdc6e243c74b2d5
Author: Ben Hutchings <bhutchings@solarflare.com>
Date:   Tue Aug 17 02:31:15 2010 -0700

    ethtool: Provide a default implementation of ethtool_ops::get_drvinfo
    
    The driver name and bus address for a net_device can normally be found
    through the driver model now.  Instead of requiring drivers to provide
    this information redundantly through the ethtool_ops::get_drvinfo
    operation, use the driver model to do so if the driver does not define
    the operation.  Since ETHTOOL_GDRVINFO no longer requires the driver
    to implement any operations, do not require net_device::ethtool_ops to
    be set either.
    
    Remove implementations of get_drvinfo and ethtool_ops that provide
    only this information.
    
    Signed-off-by: Ben Hutchings <bhutchings@solarflare.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index da17d409a244..51e8a35ebd7e 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -8,7 +8,6 @@
 
 #include <linux/bug.h>
 #include <linux/device.h>
-#include <linux/ethtool.h>
 #include <linux/firewire.h>
 #include <linux/firewire-constants.h>
 #include <linux/highmem.h>
@@ -1359,17 +1358,6 @@ static int fwnet_change_mtu(struct net_device *net, int new_mtu)
 	return 0;
 }
 
-static void fwnet_get_drvinfo(struct net_device *net,
-			      struct ethtool_drvinfo *info)
-{
-	strcpy(info->driver, KBUILD_MODNAME);
-	strcpy(info->bus_info, "ieee1394");
-}
-
-static const struct ethtool_ops fwnet_ethtool_ops = {
-	.get_drvinfo = fwnet_get_drvinfo,
-};
-
 static const struct net_device_ops fwnet_netdev_ops = {
 	.ndo_open       = fwnet_open,
 	.ndo_stop	= fwnet_stop,
@@ -1388,7 +1376,6 @@ static void fwnet_init_dev(struct net_device *net)
 	net->hard_header_len	= FWNET_HLEN;
 	net->type		= ARPHRD_IEEE1394;
 	net->tx_queue_len	= 10;
-	SET_ETHTOOL_OPS(net, &fwnet_ethtool_ops);
 }
 
 /* caller must hold fwnet_device_mutex */

commit e78483c5aeb0d7fbb0e365802145f1045e62957e
Merge: 9fe6206f4006 b20d02e37eea 20802224298c
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Mon Aug 2 09:33:25 2010 +0200

    Merge firewire branches to be released post v2.6.35
    
    Conflicts:
            drivers/firewire/core-card.c
            drivers/firewire/core-cdev.c
    
    and forgotten #include <linux/time.h> in drivers/firewire/ohci.c
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

commit 33e553fe2b4a983ef34a57ab1440d8d33397bb12
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sun Jun 20 22:50:35 2010 +0200

    firewire: remove an unused function argument
    
    void (*fw_address_callback_t)(..., int speed, ...) is the speed that a
    remote node chose to transmit a request to us.  In case of split
    transactions, firewire-core will transmit the response at that speed.
    
    Upper layer drivers on the other hand (firewire-net, -sbp2, firedtv, and
    userspace drivers) cannot do anything useful with that speed datum,
    except log it for debug purposes.  But data that is merely potentially
    (not even actually) used for debug purposes does not belong into the API.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index 2d3dc7ded0a9..4bb3fb882f63 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -805,8 +805,8 @@ static int fwnet_incoming_packet(struct fwnet_device *dev, __be32 *buf, int len,
 
 static void fwnet_receive_packet(struct fw_card *card, struct fw_request *r,
 		int tcode, int destination, int source, int generation,
-		int speed, unsigned long long offset, void *payload,
-		size_t length, void *callback_data)
+		unsigned long long offset, void *payload, size_t length,
+		void *callback_data)
 {
 	struct fwnet_device *dev = callback_data;
 	int rcode;

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index 2d3dc7ded0a9..7142eeec8074 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -21,6 +21,7 @@
 #include <linux/mutex.h>
 #include <linux/netdevice.h>
 #include <linux/skbuff.h>
+#include <linux/slab.h>
 #include <linux/spinlock.h>
 
 #include <asm/unaligned.h>

commit 110f82d7a2e0ff5a17617a9672f1ccb7e44bc0c6
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Mon Jan 18 22:36:49 2010 +0100

    firewire: net: fix panic in fwnet_write_complete
    
    In the transmit path of firewire-net (IPv4 over 1394), the following
    race condition may occur:
      - The networking soft IRQ inserts a datagram into the 1394 async
        request transmit DMA.
      - The 1394 async transmit completion tasklet runs to finish cleaning
        up (unlink datagram from list of pending ones, release skb and
        outbound 1394 transaction object) --- before the networking soft IRQ
        had a chance to proceed and add the datagram to the list of pending
        datagrams.
    
    This caused a panic in the 1394 async transmit completion tasklet when
    it dereferenced unitialized list heads:
    http://bugzilla.kernel.org/show_bug.cgi?id=15077
    
    The fix is to add checks in the tx soft IRQ and in the tasklet to
    determine which of these two is the last referrer to the transaction
    object.  Then handle the cleanup of the object by the last referrer
    rather than assuming that the tasklet is always the last one.
    
    There is another similar race:  Between said tasklet and fwnet_close,
    i.e. at ifdown.  However, that race is much less likely to occur in
    practice and shall be fixed in a separate update.
    
    Reported-by:   <basinilya@gmail.com>
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index cbaf420c36c5..2d3dc7ded0a9 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -893,20 +893,31 @@ static void fwnet_receive_broadcast(struct fw_iso_context *context,
 
 static struct kmem_cache *fwnet_packet_task_cache;
 
+static void fwnet_free_ptask(struct fwnet_packet_task *ptask)
+{
+	dev_kfree_skb_any(ptask->skb);
+	kmem_cache_free(fwnet_packet_task_cache, ptask);
+}
+
 static int fwnet_send_packet(struct fwnet_packet_task *ptask);
 
 static void fwnet_transmit_packet_done(struct fwnet_packet_task *ptask)
 {
-	struct fwnet_device *dev;
+	struct fwnet_device *dev = ptask->dev;
 	unsigned long flags;
-
-	dev = ptask->dev;
+	bool free;
 
 	spin_lock_irqsave(&dev->lock, flags);
-	list_del(&ptask->pt_link);
-	spin_unlock_irqrestore(&dev->lock, flags);
 
-	ptask->outstanding_pkts--; /* FIXME access inside lock */
+	ptask->outstanding_pkts--;
+
+	/* Check whether we or the networking TX soft-IRQ is last user. */
+	free = (ptask->outstanding_pkts == 0 && !list_empty(&ptask->pt_link));
+
+	if (ptask->outstanding_pkts == 0)
+		list_del(&ptask->pt_link);
+
+	spin_unlock_irqrestore(&dev->lock, flags);
 
 	if (ptask->outstanding_pkts > 0) {
 		u16 dg_size;
@@ -951,10 +962,10 @@ static void fwnet_transmit_packet_done(struct fwnet_packet_task *ptask)
 			ptask->max_payload = skb->len + RFC2374_FRAG_HDR_SIZE;
 		}
 		fwnet_send_packet(ptask);
-	} else {
-		dev_kfree_skb_any(ptask->skb);
-		kmem_cache_free(fwnet_packet_task_cache, ptask);
 	}
+
+	if (free)
+		fwnet_free_ptask(ptask);
 }
 
 static void fwnet_write_complete(struct fw_card *card, int rcode,
@@ -977,6 +988,7 @@ static int fwnet_send_packet(struct fwnet_packet_task *ptask)
 	unsigned tx_len;
 	struct rfc2734_header *bufhdr;
 	unsigned long flags;
+	bool free;
 
 	dev = ptask->dev;
 	tx_len = ptask->max_payload;
@@ -1022,12 +1034,16 @@ static int fwnet_send_packet(struct fwnet_packet_task *ptask)
 				generation, SCODE_100, 0ULL, ptask->skb->data,
 				tx_len + 8, fwnet_write_complete, ptask);
 
-		/* FIXME race? */
 		spin_lock_irqsave(&dev->lock, flags);
-		list_add_tail(&ptask->pt_link, &dev->broadcasted_list);
+
+		/* If the AT tasklet already ran, we may be last user. */
+		free = (ptask->outstanding_pkts == 0 && list_empty(&ptask->pt_link));
+		if (!free)
+			list_add_tail(&ptask->pt_link, &dev->broadcasted_list);
+
 		spin_unlock_irqrestore(&dev->lock, flags);
 
-		return 0;
+		goto out;
 	}
 
 	fw_send_request(dev->card, &ptask->transaction,
@@ -1035,12 +1051,19 @@ static int fwnet_send_packet(struct fwnet_packet_task *ptask)
 			ptask->generation, ptask->speed, ptask->fifo_addr,
 			ptask->skb->data, tx_len, fwnet_write_complete, ptask);
 
-	/* FIXME race? */
 	spin_lock_irqsave(&dev->lock, flags);
-	list_add_tail(&ptask->pt_link, &dev->sent_list);
+
+	/* If the AT tasklet already ran, we may be last user. */
+	free = (ptask->outstanding_pkts == 0 && list_empty(&ptask->pt_link));
+	if (!free)
+		list_add_tail(&ptask->pt_link, &dev->sent_list);
+
 	spin_unlock_irqrestore(&dev->lock, flags);
 
 	dev->netdev->trans_start = jiffies;
+ out:
+	if (free)
+		fwnet_free_ptask(ptask);
 
 	return 0;
 }
@@ -1298,6 +1321,8 @@ static netdev_tx_t fwnet_tx(struct sk_buff *skb, struct net_device *net)
 	spin_unlock_irqrestore(&dev->lock, flags);
 
 	ptask->max_payload = max_payload;
+	INIT_LIST_HEAD(&ptask->pt_link);
+
 	fwnet_send_packet(ptask);
 
 	return NETDEV_TX_OK;

commit 451f14439847db302e5104c44458b2dbb4b1829d
Author: Eric Dumazet <eric.dumazet@gmail.com>
Date:   Mon Aug 31 06:34:50 2009 +0000

    drivers: Kill now superfluous ->last_rx stores
    
    The generic packet receive code takes care of setting
    netdev->last_rx when necessary, for the sake of the
    bonding ARP monitor.
    
    Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com>
    Acked-by: Neil Horman <nhorman@txudriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index 84edc8b84c62..cbaf420c36c5 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -663,8 +663,6 @@ static int fwnet_finish_incoming_packet(struct net_device *net,
 	if (netif_queue_stopped(net))
 		netif_wake_queue(net);
 
-	net->last_rx = jiffies;
-
 	return 0;
 }
 

commit 0fc0b732eaa38beb93a6fb62f77c7bd9622c76ec
Author: Stephen Hemminger <shemminger@vyatta.com>
Date:   Wed Sep 2 01:03:33 2009 -0700

    netdev: drivers should make ethtool_ops const
    
    No need to put ethtool_ops in data, they should be const.
    
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index d923d1dc458f..84edc8b84c62 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -1342,7 +1342,7 @@ static void fwnet_get_drvinfo(struct net_device *net,
 	strcpy(info->bus_info, "ieee1394");
 }
 
-static struct ethtool_ops fwnet_ethtool_ops = {
+static const struct ethtool_ops fwnet_ethtool_ops = {
 	.get_drvinfo = fwnet_get_drvinfo,
 };
 

commit 424efe9caf6047ffbcd6b383ff4d2347254aabf1
Author: Stephen Hemminger <shemminger@vyatta.com>
Date:   Mon Aug 31 19:50:51 2009 +0000

    netdev: convert pseudo drivers to netdev_tx_t
    
    These are all drivers that don't touch real hardware.
    
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index a42209a73aed..d923d1dc458f 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -1188,7 +1188,7 @@ static int fwnet_stop(struct net_device *net)
 	return 0;
 }
 
-static int fwnet_tx(struct sk_buff *skb, struct net_device *net)
+static netdev_tx_t fwnet_tx(struct sk_buff *skb, struct net_device *net)
 {
 	struct fwnet_header hdr_buf;
 	struct fwnet_device *dev = netdev_priv(net);

commit 00635b8ee2b5650fd01f5602ecfa289db336b570
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Tue Jun 16 22:35:32 2009 +0200

    firewire: net: better FIFO address range check and rcodes
    
    The AR req handler should not check the generation; higher level code
    is the better place to handle bus generation changes.  The target node
    ID just needs to be checked for not being the "all nodes" address; in
    this case don't handle the request and don't respond.
    
    Use Address_Error and Type_Error rcodes as appropriate.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index 47dcb45d720e..a42209a73aed 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -810,29 +810,27 @@ static void fwnet_receive_packet(struct fw_card *card, struct fw_request *r,
 		int speed, unsigned long long offset, void *payload,
 		size_t length, void *callback_data)
 {
-	struct fwnet_device *dev;
-	int status;
+	struct fwnet_device *dev = callback_data;
+	int rcode;
 
-	dev = callback_data;
-	if (tcode != TCODE_WRITE_BLOCK_REQUEST
-	    || destination != card->node_id	/* <- FIXME */
-	    || generation != card->generation	/* <- FIXME */
-	    || offset != dev->handler.offset) {
-		fw_send_response(card, r, RCODE_CONFLICT_ERROR);
+	if (destination == IEEE1394_ALL_NODES) {
+		kfree(r);
 
 		return;
 	}
 
-	status = fwnet_incoming_packet(dev, payload, length,
-				       source, generation, false);
-	if (status != 0) {
+	if (offset != dev->handler.offset)
+		rcode = RCODE_ADDRESS_ERROR;
+	else if (tcode != TCODE_WRITE_BLOCK_REQUEST)
+		rcode = RCODE_TYPE_ERROR;
+	else if (fwnet_incoming_packet(dev, payload, length,
+				       source, generation, false) != 0) {
 		fw_error("Incoming packet failure\n");
-		fw_send_response(card, r, RCODE_CONFLICT_ERROR);
-
-		return;
-	}
+		rcode = RCODE_CONFLICT_ERROR;
+	} else
+		rcode = RCODE_COMPLETE;
 
-	fw_send_response(card, r, RCODE_COMPLETE);
+	fw_send_response(card, r, rcode);
 }
 
 static void fwnet_receive_broadcast(struct fw_iso_context *context,

commit b01b4babbf204443b5a846a7494546501614cefc
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Tue Jun 16 20:43:55 2009 +0200

    firewire: net: fix card driver reloading
    
    Fix some problems from "firewire: net: allow for unordered unit
    discovery":
      - fwnet_remove was missing a list_del, causing fwnet_probe to crash if
        called after fwnet_remove, e.g. if firewire-ohci was unloaded and
        reloaded.
      - fwnet_probe should set its new_netdev flag only if it actually
        allocated a net_device.
      - Use dev_set_drvdata and dev_get_drvdata instead of deprecated direct
        access to device.driver_data.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index 95e35a36b01f..47dcb45d720e 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -1390,7 +1390,8 @@ static int fwnet_add_peer(struct fwnet_device *dev,
 	if (!peer)
 		return -ENOMEM;
 
-	unit->device.driver_data = peer;
+	dev_set_drvdata(&unit->device, peer);
+
 	peer->dev = dev;
 	peer->guid = (u64)device->config_rom[3] << 32 | device->config_rom[4];
 	peer->fifo = FWNET_NO_FIFO_ADDR;
@@ -1417,27 +1418,26 @@ static int fwnet_probe(struct device *_dev)
 	struct fw_device *device = fw_parent_device(unit);
 	struct fw_card *card = device->card;
 	struct net_device *net;
+	bool allocated_netdev = false;
 	struct fwnet_device *dev;
 	unsigned max_mtu;
-	bool new_netdev;
 	int ret;
 
 	mutex_lock(&fwnet_device_mutex);
 
 	dev = fwnet_dev_find(card);
 	if (dev) {
-		new_netdev = false;
 		net = dev->netdev;
 		goto have_dev;
 	}
 
-	new_netdev = true;
 	net = alloc_netdev(sizeof(*dev), "firewire%d", fwnet_init_dev);
 	if (net == NULL) {
 		ret = -ENOMEM;
 		goto out;
 	}
 
+	allocated_netdev = true;
 	SET_NETDEV_DEV(net, card->device);
 	dev = netdev_priv(net);
 
@@ -1479,12 +1479,12 @@ static int fwnet_probe(struct device *_dev)
 		  net->name, (unsigned long long)card->guid);
  have_dev:
 	ret = fwnet_add_peer(dev, unit, device);
-	if (ret && new_netdev) {
+	if (ret && allocated_netdev) {
 		unregister_netdev(net);
 		list_del(&dev->dev_link);
 	}
  out:
-	if (ret && new_netdev)
+	if (ret && allocated_netdev)
 		free_netdev(net);
 
 	mutex_unlock(&fwnet_device_mutex);
@@ -1508,7 +1508,7 @@ static void fwnet_remove_peer(struct fwnet_peer *peer)
 
 static int fwnet_remove(struct device *_dev)
 {
-	struct fwnet_peer *peer = _dev->driver_data;
+	struct fwnet_peer *peer = dev_get_drvdata(_dev);
 	struct fwnet_device *dev = peer->dev;
 	struct net_device *net;
 	struct fwnet_packet_task *ptask, *pt_next;
@@ -1544,6 +1544,8 @@ static int fwnet_remove(struct device *_dev)
 			dev_kfree_skb_any(ptask->skb);
 			kmem_cache_free(fwnet_packet_task_cache, ptask);
 		}
+		list_del(&dev->dev_link);
+
 		free_netdev(net);
 	}
 
@@ -1559,7 +1561,7 @@ static int fwnet_remove(struct device *_dev)
 static void fwnet_update(struct fw_unit *unit)
 {
 	struct fw_device *device = fw_parent_device(unit);
-	struct fwnet_peer *peer = unit->device.driver_data;
+	struct fwnet_peer *peer = dev_get_drvdata(&unit->device);
 	int generation;
 
 	generation = device->generation;

commit 1337f8535ac1f41915d9e8aa03d5a3edf2f7c0a5
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sun Jun 14 11:47:44 2009 +0200

    firewire: net: adjust net_device ops
    
    The .ndo_tx_timeout callback is currently without function; delete it.
    Give .watchdog_timeo a proper time value; lower it to 2 seconds.
    
    Decrease the .tx_queue_len from 1000 (as in Ethernet card drivers) to 10
    because we have only 64 transaction labels available, and responders
    might have further limits of their AR req contexts.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index d67e8d957d21..95e35a36b01f 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -1328,13 +1328,6 @@ static int fwnet_tx(struct sk_buff *skb, struct net_device *net)
 	return NETDEV_TX_OK;
 }
 
-static void fwnet_tx_timeout(struct net_device *net)
-{
-	fw_error("%s: timeout\n", net->name);
-
-	/* FIXME: What to do if we timeout? */
-}
-
 static int fwnet_change_mtu(struct net_device *net, int new_mtu)
 {
 	if (new_mtu < 68)
@@ -1359,7 +1352,6 @@ static const struct net_device_ops fwnet_netdev_ops = {
 	.ndo_open       = fwnet_open,
 	.ndo_stop	= fwnet_stop,
 	.ndo_start_xmit = fwnet_tx,
-	.ndo_tx_timeout = fwnet_tx_timeout,
 	.ndo_change_mtu = fwnet_change_mtu,
 };
 
@@ -1367,13 +1359,13 @@ static void fwnet_init_dev(struct net_device *net)
 {
 	net->header_ops		= &fwnet_header_ops;
 	net->netdev_ops		= &fwnet_netdev_ops;
-	net->watchdog_timeo	= 100000; /* ? FIXME */
+	net->watchdog_timeo	= 2 * HZ;
 	net->flags		= IFF_BROADCAST | IFF_MULTICAST;
 	net->features		= NETIF_F_HIGHDMA;
 	net->addr_len		= FWNET_ALEN;
 	net->hard_header_len	= FWNET_HLEN;
 	net->type		= ARPHRD_IEEE1394;
-	net->tx_queue_len	= 1000; /* ? FIXME */
+	net->tx_queue_len	= 10;
 	SET_ETHTOOL_OPS(net, &fwnet_ethtool_ops);
 }
 

commit 156ce867a6725ea8a24b452469a6dc9f3fa6a161
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sun Jun 14 11:46:57 2009 +0200

    firewire: net: remove unused code
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index d83c54587a63..d67e8d957d21 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -628,13 +628,8 @@ static int fwnet_finish_incoming_packet(struct net_device *net,
 				skb->pkt_type = PACKET_MULTICAST;
 #endif
 		} else {
-			if (memcmp(eth->h_dest, net->dev_addr, net->addr_len)) {
-				u64 a1, a2;
-
-				memcpy(&a1, eth->h_dest, sizeof(u64));
-				memcpy(&a2, net->dev_addr, sizeof(u64));
+			if (memcmp(eth->h_dest, net->dev_addr, net->addr_len))
 				skb->pkt_type = PACKET_OTHERHOST;
-			}
 		}
 		if (ntohs(eth->h_proto) >= 1536) {
 			protocol = eth->h_proto;

commit 5a124d382ea5c97be43c779e4f481455e0287654
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sun Jun 14 11:45:27 2009 +0200

    firewire: net: allow for unordered unit discovery
    
    Decouple the creation and destruction of the net_device from the order
    of discovery and removal of nodes with RFC 2734 unit directories since
    there is no reliable order.  The net_device is now created when the
    first RFC 2734 unit on a card is discovered, and destroyed when the last
    RFC 2734 unit on a card went away.  This includes all remote units as
    well as the local unit, which is therefore tracked as a peer now too.
    
    Also, locking around the list of peers is slightly extended to guard
    against peer removal.  As a side effect, fwnet_peer.pdg_lock has become
    superfluous and is deleted.
    
    Peer data (max_rec, speed, node ID, generation) are updated more
    carefully.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index ba6f924b1b13..d83c54587a63 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -18,8 +18,10 @@
 #include <linux/mod_devicetable.h>
 #include <linux/module.h>
 #include <linux/moduleparam.h>
+#include <linux/mutex.h>
 #include <linux/netdevice.h>
 #include <linux/skbuff.h>
+#include <linux/spinlock.h>
 
 #include <asm/unaligned.h>
 #include <net/arp.h>
@@ -135,40 +137,11 @@ struct fwnet_partial_datagram {
 	u16 datagram_size;
 };
 
-/*
- * We keep one of these for each IPv4 capable device attached to a fw_card.
- * The list of them is stored in the fw_card structure rather than in the
- * fwnet_device because the remote IPv4 nodes may be probed before the card is,
- * so we need a place to store them before the fwnet_device structure is
- * allocated.
- */
-struct fwnet_peer {
-	struct list_head peer_link;
-	/* guid of the remote peer */
-	u64 guid;
-	/* FIFO address to transmit datagrams to, or FWNET_NO_FIFO_ADDR */
-	u64 fifo;
-
-	spinlock_t pdg_lock;	/* partial datagram lock		*/
-	/* List of partial datagrams received from this peer */
-	struct list_head pd_list;
-	/* Number of entries in pd_list at the moment */
-	unsigned pdg_size;
-
-	/* max payload to transmit to this remote peer */
-	/* This already includes the RFC2374_FRAG_HDR_SIZE overhead */
-	u16 max_payload;
-	/* outgoing datagram label */
-	u16 datagram_label;
-	/* Current node_id of the remote peer */
-	u16 node_id;
-	/* current generation of the remote peer */
-	u8 generation;
-	/* max speed that this peer can receive at */
-	u8 xmt_speed;
-};
+static DEFINE_MUTEX(fwnet_device_mutex);
+static LIST_HEAD(fwnet_device_list);
 
 struct fwnet_device {
+	struct list_head dev_link;
 	spinlock_t lock;
 	enum {
 		FWNET_BROADCAST_ERROR,
@@ -206,7 +179,26 @@ struct fwnet_device {
 	/* List of packets that have been sent but not yet acked */
 	struct list_head sent_list;
 
+	struct list_head peer_list;
 	struct fw_card *card;
+	struct net_device *netdev;
+};
+
+struct fwnet_peer {
+	struct list_head peer_link;
+	struct fwnet_device *dev;
+	u64 guid;
+	u64 fifo;
+
+	/* guarded by dev->lock */
+	struct list_head pd_list; /* received partial datagrams */
+	unsigned pdg_size;        /* pd_list size */
+
+	u16 datagram_label;       /* outgoing datagram label */
+	unsigned max_payload;     /* includes RFC2374_FRAG_HDR_SIZE overhead */
+	int node_id;
+	int generation;
+	unsigned speed;
 };
 
 /* This is our task struct. It's used for the packet complete callback.  */
@@ -479,102 +471,47 @@ static bool fwnet_pd_is_complete(struct fwnet_partial_datagram *pd)
 	return fi->len == pd->datagram_size;
 }
 
-static int fwnet_peer_new(struct fw_card *card, struct fw_device *device)
-{
-	struct fwnet_peer *peer;
-
-	peer = kmalloc(sizeof(*peer), GFP_KERNEL);
-	if (!peer) {
-		fw_error("out of memory\n");
-
-		return -ENOMEM;
-	}
-	peer->guid = (u64)device->config_rom[3] << 32 | device->config_rom[4];
-	peer->fifo = FWNET_NO_FIFO_ADDR;
-	INIT_LIST_HEAD(&peer->pd_list);
-	spin_lock_init(&peer->pdg_lock);
-	peer->pdg_size = 0;
-	peer->generation = device->generation;
-	rmb();
-	peer->node_id = device->node_id;
-	 /* FIXME what should it really be? */
-	peer->max_payload = IEEE1394_MAX_PAYLOAD_S100 - RFC2374_UNFRAG_HDR_SIZE;
-	peer->datagram_label = 0U;
-	peer->xmt_speed = device->max_speed;
-	list_add_tail(&peer->peer_link, &card->peer_list);
-
-	return 0;
-}
-
-/* FIXME caller must take the lock, or peer needs to be reference-counted */
+/* caller must hold dev->lock */
 static struct fwnet_peer *fwnet_peer_find_by_guid(struct fwnet_device *dev,
 						  u64 guid)
 {
-	struct fwnet_peer *p, *peer = NULL;
-	unsigned long flags;
+	struct fwnet_peer *peer;
 
-	spin_lock_irqsave(&dev->lock, flags);
-	list_for_each_entry(p, &dev->card->peer_list, peer_link)
-		if (p->guid == guid) {
-			peer = p;
-			break;
-		}
-	spin_unlock_irqrestore(&dev->lock, flags);
+	list_for_each_entry(peer, &dev->peer_list, peer_link)
+		if (peer->guid == guid)
+			return peer;
 
-	return peer;
+	return NULL;
 }
 
-/* FIXME caller must take the lock, or peer needs to be reference-counted */
-/* FIXME node_id doesn't mean anything without generation */
+/* caller must hold dev->lock */
 static struct fwnet_peer *fwnet_peer_find_by_node_id(struct fwnet_device *dev,
-						     u16 node_id)
+						int node_id, int generation)
 {
-	struct fwnet_peer *p, *peer = NULL;
-	unsigned long flags;
+	struct fwnet_peer *peer;
 
-	spin_lock_irqsave(&dev->lock, flags);
-	list_for_each_entry(p, &dev->card->peer_list, peer_link)
-		if (p->node_id == node_id) {
-			peer = p;
-			break;
-		}
-	spin_unlock_irqrestore(&dev->lock, flags);
+	list_for_each_entry(peer, &dev->peer_list, peer_link)
+		if (peer->node_id    == node_id &&
+		    peer->generation == generation)
+			return peer;
 
-	return peer;
+	return NULL;
 }
 
-/* FIXME */
-static void fwnet_peer_delete(struct fw_card *card, struct fw_device *device)
+/* See IEEE 1394-2008 table 6-4, table 8-8, table 16-18. */
+static unsigned fwnet_max_payload(unsigned max_rec, unsigned speed)
 {
-	struct net_device *net;
-	struct fwnet_device *dev;
-	struct fwnet_peer *peer;
-	u64 guid;
-	unsigned long flags;
-	struct fwnet_partial_datagram *pd, *pd_next;
-
-	guid = (u64)device->config_rom[3] << 32 | device->config_rom[4];
-	net = card->netdev;
-	if (net)
-		dev = netdev_priv(net);
-	else
-		dev = NULL;
-	if (dev)
-		spin_lock_irqsave(&dev->lock, flags);
-
-	list_for_each_entry(peer, &card->peer_list, peer_link) {
-		if (peer->guid == guid) {
-			list_del(&peer->peer_link);
-			list_for_each_entry_safe(pd, pd_next, &peer->pd_list,
-						 pd_link)
-				fwnet_pd_delete(pd);
-			break;
-		}
+	max_rec = min(max_rec, speed + 8);
+	max_rec = min(max_rec, 0xbU); /* <= 4096 */
+	if (max_rec < 8) {
+		fw_notify("max_rec %x out of range\n", max_rec);
+		max_rec = 8;
 	}
-	if (dev)
-		spin_unlock_irqrestore(&dev->lock, flags);
+
+	return (1 << (max_rec + 1)) - RFC2374_FRAG_HDR_SIZE;
 }
 
+
 static int fwnet_finish_incoming_packet(struct net_device *net,
 					struct sk_buff *skb, u16 source_node_id,
 					bool is_broadcast, u16 ether_type)
@@ -606,71 +543,44 @@ static int fwnet_finish_incoming_packet(struct net_device *net,
 		unsigned char *arp_ptr;
 		u64 fifo_addr;
 		u64 peer_guid;
-		u8 max_rec;
-		u8 sspd;
+		unsigned sspd;
 		u16 max_payload;
 		struct fwnet_peer *peer;
-		static const u16 fwnet_speed_to_max_payload[] = {
-			/* S100, S200, S400, S800, S1600, S3200 */
-			    512, 1024, 2048, 4096,  4096,  4096
-		};
+		unsigned long flags;
+
+		arp1394   = (struct rfc2734_arp *)skb->data;
+		arp       = (struct arphdr *)skb->data;
+		arp_ptr   = (unsigned char *)(arp + 1);
+		peer_guid = get_unaligned_be64(&arp1394->s_uniq_id);
+		fifo_addr = (u64)get_unaligned_be16(&arp1394->fifo_hi) << 32
+				| get_unaligned_be32(&arp1394->fifo_lo);
 
-		arp1394 = (struct rfc2734_arp *)skb->data;
-		arp = (struct arphdr *)skb->data;
-		arp_ptr = (unsigned char *)(arp + 1);
-		fifo_addr = (u64)ntohs(arp1394->fifo_hi) << 32
-				| ntohl(arp1394->fifo_lo);
-		max_rec = dev->card->max_receive;
-		if (arp1394->max_rec < max_rec)
-			max_rec = arp1394->max_rec;
 		sspd = arp1394->sspd;
 		/* Sanity check.  OS X 10.3 PPC reportedly sends 131. */
 		if (sspd > SCODE_3200) {
 			fw_notify("sspd %x out of range\n", sspd);
-			sspd = 0;
+			sspd = SCODE_3200;
 		}
+		max_payload = fwnet_max_payload(arp1394->max_rec, sspd);
 
-		max_payload = min(fwnet_speed_to_max_payload[sspd],
-			(u16)(1 << (max_rec + 1))) - RFC2374_UNFRAG_HDR_SIZE;
-
-		peer_guid = get_unaligned_be64(&arp1394->s_uniq_id);
+		spin_lock_irqsave(&dev->lock, flags);
 		peer = fwnet_peer_find_by_guid(dev, peer_guid);
+		if (peer) {
+			peer->fifo = fifo_addr;
+
+			if (peer->speed > sspd)
+				peer->speed = sspd;
+			if (peer->max_payload > max_payload)
+				peer->max_payload = max_payload;
+		}
+		spin_unlock_irqrestore(&dev->lock, flags);
+
 		if (!peer) {
 			fw_notify("No peer for ARP packet from %016llx\n",
 				  (unsigned long long)peer_guid);
 			goto failed_proto;
 		}
 
-		/* FIXME don't use card->generation */
-		if (peer->node_id != source_node_id ||
-		    peer->generation != dev->card->generation) {
-			fw_notify("Internal error: peer->node_id (%x) != "
-				  "source_node_id (%x) or peer->generation (%x)"
-				  " != dev->card->generation(%x)\n",
-				  peer->node_id, source_node_id,
-				  peer->generation, dev->card->generation);
-			peer->node_id = source_node_id;
-			peer->generation = dev->card->generation;
-		}
-
-		/* FIXME: for debugging */
-		if (sspd > SCODE_400)
-			sspd = SCODE_400;
-		/* Update our speed/payload/fifo_offset table */
-		/*
-		 * FIXME: this does not handle cases where two high-speed endpoints must use a slower speed because of
-		 * a lower speed hub between them.  We need to look at the actual topology map here.
-		 */
-		peer->fifo = fifo_addr;
-		peer->max_payload = max_payload;
-		/*
-		 * Only allow speeds to go down from their initial value.
-		 * Otherwise a local peer that can only do S400 or slower may
-		 * be told to transmit at S800 to a faster remote peer.
-		 */
-		if (peer->xmt_speed > sspd)
-			peer->xmt_speed = sspd;
-
 		/*
 		 * Now that we're done with the 1394 specific stuff, we'll
 		 * need to alter some of the data.  Believe it or not, all
@@ -764,10 +674,11 @@ static int fwnet_finish_incoming_packet(struct net_device *net,
 }
 
 static int fwnet_incoming_packet(struct fwnet_device *dev, __be32 *buf, int len,
-				 u16 source_node_id, bool is_broadcast)
+				 int source_node_id, int generation,
+				 bool is_broadcast)
 {
 	struct sk_buff *skb;
-	struct net_device *net;
+	struct net_device *net = dev->netdev;
 	struct rfc2734_header hdr;
 	unsigned lf;
 	unsigned long flags;
@@ -779,8 +690,6 @@ static int fwnet_incoming_packet(struct fwnet_device *dev, __be32 *buf, int len,
 	int retval;
 	u16 ether_type;
 
-	net = dev->card->netdev;
-
 	hdr.w0 = be32_to_cpu(buf[0]);
 	lf = fwnet_get_hdr_lf(&hdr);
 	if (lf == RFC2374_HDR_UNFRAG) {
@@ -819,9 +728,12 @@ static int fwnet_incoming_packet(struct fwnet_device *dev, __be32 *buf, int len,
 	}
 	datagram_label = fwnet_get_hdr_dgl(&hdr);
 	dg_size = fwnet_get_hdr_dg_size(&hdr); /* ??? + 1 */
-	peer = fwnet_peer_find_by_node_id(dev, source_node_id);
 
-	spin_lock_irqsave(&peer->pdg_lock, flags);
+	spin_lock_irqsave(&dev->lock, flags);
+
+	peer = fwnet_peer_find_by_node_id(dev, source_node_id, generation);
+	if (!peer)
+		goto bad_proto;
 
 	pd = fwnet_pd_find(peer, datagram_label);
 	if (pd == NULL) {
@@ -876,7 +788,7 @@ static int fwnet_incoming_packet(struct fwnet_device *dev, __be32 *buf, int len,
 		skb = skb_get(pd->skb);
 		fwnet_pd_delete(pd);
 
-		spin_unlock_irqrestore(&peer->pdg_lock, flags);
+		spin_unlock_irqrestore(&dev->lock, flags);
 
 		return fwnet_finish_incoming_packet(net, skb, source_node_id,
 						    false, ether_type);
@@ -885,12 +797,12 @@ static int fwnet_incoming_packet(struct fwnet_device *dev, __be32 *buf, int len,
 	 * Datagram is not complete, we're done for the
 	 * moment.
 	 */
-	spin_unlock_irqrestore(&peer->pdg_lock, flags);
+	spin_unlock_irqrestore(&dev->lock, flags);
 
 	return 0;
 
  bad_proto:
-	spin_unlock_irqrestore(&peer->pdg_lock, flags);
+	spin_unlock_irqrestore(&dev->lock, flags);
 
 	if (netif_queue_stopped(net))
 		netif_wake_queue(net);
@@ -916,7 +828,8 @@ static void fwnet_receive_packet(struct fw_card *card, struct fw_request *r,
 		return;
 	}
 
-	status = fwnet_incoming_packet(dev, payload, length, source, false);
+	status = fwnet_incoming_packet(dev, payload, length,
+				       source, generation, false);
 	if (status != 0) {
 		fw_error("Incoming packet failure\n");
 		fw_send_response(card, r, RCODE_CONFLICT_ERROR);
@@ -966,7 +879,7 @@ static void fwnet_receive_broadcast(struct fw_iso_context *context,
 		buf_ptr += 2;
 		length -= IEEE1394_GASP_HDR_SIZE;
 		fwnet_incoming_packet(dev, buf_ptr, length,
-				      source_node_id, true);
+				      source_node_id, -1, true);
 	}
 
 	packet.payload_length = dev->rcv_buffer_size;
@@ -1073,7 +986,6 @@ static int fwnet_send_packet(struct fwnet_packet_task *ptask)
 	unsigned tx_len;
 	struct rfc2734_header *bufhdr;
 	unsigned long flags;
-	struct net_device *net;
 
 	dev = ptask->dev;
 	tx_len = ptask->max_payload;
@@ -1137,8 +1049,7 @@ static int fwnet_send_packet(struct fwnet_packet_task *ptask)
 	list_add_tail(&ptask->pt_link, &dev->sent_list);
 	spin_unlock_irqrestore(&dev->lock, flags);
 
-	net = dev->card->netdev;
-	net->trans_start = jiffies;
+	dev->netdev->trans_start = jiffies;
 
 	return 0;
 }
@@ -1294,7 +1205,8 @@ static int fwnet_tx(struct sk_buff *skb, struct net_device *net)
 	u16 dg_size;
 	u16 *datagram_label_ptr;
 	struct fwnet_packet_task *ptask;
-	struct fwnet_peer *peer = NULL;
+	struct fwnet_peer *peer;
+	unsigned long flags;
 
 	ptask = kmem_cache_alloc(fwnet_packet_task_cache, GFP_ATOMIC);
 	if (ptask == NULL)
@@ -1314,6 +1226,9 @@ static int fwnet_tx(struct sk_buff *skb, struct net_device *net)
 	proto = hdr_buf.h_proto;
 	dg_size = skb->len;
 
+	/* serialize access to peer, including peer->datagram_label */
+	spin_lock_irqsave(&dev->lock, flags);
+
 	/*
 	 * Set the transmission type for the packet.  ARP packets and IP
 	 * broadcast packets are sent via GASP.
@@ -1322,35 +1237,30 @@ static int fwnet_tx(struct sk_buff *skb, struct net_device *net)
 	    || proto == htons(ETH_P_ARP)
 	    || (proto == htons(ETH_P_IP)
 		&& IN_MULTICAST(ntohl(ip_hdr(skb)->daddr)))) {
-		max_payload = dev->broadcast_xmt_max_payload;
+		max_payload        = dev->broadcast_xmt_max_payload;
 		datagram_label_ptr = &dev->broadcast_xmt_datagramlabel;
 
-		ptask->fifo_addr = FWNET_NO_FIFO_ADDR;
-		ptask->generation = 0;
-		ptask->dest_node = IEEE1394_ALL_NODES;
-		ptask->speed = SCODE_100;
+		ptask->fifo_addr   = FWNET_NO_FIFO_ADDR;
+		ptask->generation  = 0;
+		ptask->dest_node   = IEEE1394_ALL_NODES;
+		ptask->speed       = SCODE_100;
 	} else {
 		__be64 guid = get_unaligned((__be64 *)hdr_buf.h_dest);
 		u8 generation;
 
 		peer = fwnet_peer_find_by_guid(dev, be64_to_cpu(guid));
-		if (!peer)
-			goto fail;
-
-		if (peer->fifo == FWNET_NO_FIFO_ADDR)
-			goto fail;
+		if (!peer || peer->fifo == FWNET_NO_FIFO_ADDR)
+			goto fail_unlock;
 
-		generation = peer->generation;
-		smp_rmb();
-		dest_node = peer->node_id;
-
-		max_payload = peer->max_payload;
+		generation         = peer->generation;
+		dest_node          = peer->node_id;
+		max_payload        = peer->max_payload;
 		datagram_label_ptr = &peer->datagram_label;
 
-		ptask->fifo_addr = peer->fifo;
-		ptask->generation = generation;
-		ptask->dest_node = dest_node;
-		ptask->speed = peer->xmt_speed;
+		ptask->fifo_addr   = peer->fifo;
+		ptask->generation  = generation;
+		ptask->dest_node   = dest_node;
+		ptask->speed       = peer->speed;
 	}
 
 	/* If this is an ARP packet, convert it */
@@ -1393,11 +1303,16 @@ static int fwnet_tx(struct sk_buff *skb, struct net_device *net)
 		ptask->outstanding_pkts = DIV_ROUND_UP(dg_size, max_payload);
 		max_payload += RFC2374_FRAG_HDR_SIZE;
 	}
+
+	spin_unlock_irqrestore(&dev->lock, flags);
+
 	ptask->max_payload = max_payload;
 	fwnet_send_packet(ptask);
 
 	return NETDEV_TX_OK;
 
+ fail_unlock:
+	spin_unlock_irqrestore(&dev->lock, flags);
  fail:
 	if (ptask)
 		kmem_cache_free(fwnet_packet_task_cache, ptask);
@@ -1467,7 +1382,48 @@ static void fwnet_init_dev(struct net_device *net)
 	SET_ETHTOOL_OPS(net, &fwnet_ethtool_ops);
 }
 
-/* FIXME create netdev upon first fw_unit of a card, not upon local fw_unit */
+/* caller must hold fwnet_device_mutex */
+static struct fwnet_device *fwnet_dev_find(struct fw_card *card)
+{
+	struct fwnet_device *dev;
+
+	list_for_each_entry(dev, &fwnet_device_list, dev_link)
+		if (dev->card == card)
+			return dev;
+
+	return NULL;
+}
+
+static int fwnet_add_peer(struct fwnet_device *dev,
+			  struct fw_unit *unit, struct fw_device *device)
+{
+	struct fwnet_peer *peer;
+
+	peer = kmalloc(sizeof(*peer), GFP_KERNEL);
+	if (!peer)
+		return -ENOMEM;
+
+	unit->device.driver_data = peer;
+	peer->dev = dev;
+	peer->guid = (u64)device->config_rom[3] << 32 | device->config_rom[4];
+	peer->fifo = FWNET_NO_FIFO_ADDR;
+	INIT_LIST_HEAD(&peer->pd_list);
+	peer->pdg_size = 0;
+	peer->datagram_label = 0;
+	peer->speed = device->max_speed;
+	peer->max_payload = fwnet_max_payload(device->max_rec, peer->speed);
+
+	peer->generation = device->generation;
+	smp_rmb();
+	peer->node_id = device->node_id;
+
+	spin_lock_irq(&dev->lock);
+	list_add_tail(&peer->peer_link, &dev->peer_list);
+	spin_unlock_irq(&dev->lock);
+
+	return 0;
+}
+
 static int fwnet_probe(struct device *_dev)
 {
 	struct fw_unit *unit = fw_unit(_dev);
@@ -1476,16 +1432,22 @@ static int fwnet_probe(struct device *_dev)
 	struct net_device *net;
 	struct fwnet_device *dev;
 	unsigned max_mtu;
+	bool new_netdev;
+	int ret;
 
-	if (!device->is_local) {
-		int added;
+	mutex_lock(&fwnet_device_mutex);
 
-		added = fwnet_peer_new(card, device);
-		return added;
+	dev = fwnet_dev_find(card);
+	if (dev) {
+		new_netdev = false;
+		net = dev->netdev;
+		goto have_dev;
 	}
+
+	new_netdev = true;
 	net = alloc_netdev(sizeof(*dev), "firewire%d", fwnet_init_dev);
 	if (net == NULL) {
-		fw_error("out of memory\n");
+		ret = -ENOMEM;
 		goto out;
 	}
 
@@ -1500,12 +1462,13 @@ static int fwnet_probe(struct device *_dev)
 
 	dev->local_fifo = FWNET_NO_FIFO_ADDR;
 
-	/* INIT_WORK(&dev->wake, fwnet_handle_queue);*/
 	INIT_LIST_HEAD(&dev->packet_list);
 	INIT_LIST_HEAD(&dev->broadcasted_list);
 	INIT_LIST_HEAD(&dev->sent_list);
+	INIT_LIST_HEAD(&dev->peer_list);
 
 	dev->card = card;
+	dev->netdev = net;
 
 	/*
 	 * Use the RFC 2734 default 1500 octets or the maximum payload
@@ -1518,43 +1481,57 @@ static int fwnet_probe(struct device *_dev)
 	/* Set our hardware address while we're at it */
 	put_unaligned_be64(card->guid, net->dev_addr);
 	put_unaligned_be64(~0ULL, net->broadcast);
-	if (register_netdev(net)) {
+	ret = register_netdev(net);
+	if (ret) {
 		fw_error("Cannot register the driver\n");
 		goto out;
 	}
 
+	list_add_tail(&dev->dev_link, &fwnet_device_list);
 	fw_notify("%s: IPv4 over FireWire on device %016llx\n",
 		  net->name, (unsigned long long)card->guid);
-	card->netdev = net;
-
-	return 0;
+ have_dev:
+	ret = fwnet_add_peer(dev, unit, device);
+	if (ret && new_netdev) {
+		unregister_netdev(net);
+		list_del(&dev->dev_link);
+	}
  out:
-	if (net)
+	if (ret && new_netdev)
 		free_netdev(net);
 
-	return -ENOENT;
+	mutex_unlock(&fwnet_device_mutex);
+
+	return ret;
+}
+
+static void fwnet_remove_peer(struct fwnet_peer *peer)
+{
+	struct fwnet_partial_datagram *pd, *pd_next;
+
+	spin_lock_irq(&peer->dev->lock);
+	list_del(&peer->peer_link);
+	spin_unlock_irq(&peer->dev->lock);
+
+	list_for_each_entry_safe(pd, pd_next, &peer->pd_list, pd_link)
+		fwnet_pd_delete(pd);
+
+	kfree(peer);
 }
 
 static int fwnet_remove(struct device *_dev)
 {
-	struct fw_unit *unit = fw_unit(_dev);
-	struct fw_device *device = fw_parent_device(unit);
-	struct fw_card *card = device->card;
+	struct fwnet_peer *peer = _dev->driver_data;
+	struct fwnet_device *dev = peer->dev;
 	struct net_device *net;
-	struct fwnet_device *dev;
-	struct fwnet_peer *peer;
-	struct fwnet_partial_datagram *pd, *pd_next;
 	struct fwnet_packet_task *ptask, *pt_next;
 
-	if (!device->is_local) {
-		fwnet_peer_delete(card, device);
+	mutex_lock(&fwnet_device_mutex);
 
-		return 0;
-	}
+	fwnet_remove_peer(peer);
 
-	net = card->netdev;
-	if (net) {
-		dev = netdev_priv(net);
+	if (list_empty(&dev->peer_list)) {
+		net = dev->netdev;
 		unregister_netdev(net);
 
 		if (dev->local_fifo != FWNET_NO_FIFO_ADDR)
@@ -1580,19 +1557,11 @@ static int fwnet_remove(struct device *_dev)
 			dev_kfree_skb_any(ptask->skb);
 			kmem_cache_free(fwnet_packet_task_cache, ptask);
 		}
-		list_for_each_entry(peer, &card->peer_list, peer_link) {
-			if (peer->pdg_size) {
-				list_for_each_entry_safe(pd, pd_next,
-						&peer->pd_list, pd_link)
-					fwnet_pd_delete(pd);
-				peer->pdg_size = 0;
-			}
-			peer->fifo = FWNET_NO_FIFO_ADDR;
-		}
 		free_netdev(net);
-		card->netdev = NULL;
 	}
 
+	mutex_unlock(&fwnet_device_mutex);
+
 	return 0;
 }
 
@@ -1603,24 +1572,15 @@ static int fwnet_remove(struct device *_dev)
 static void fwnet_update(struct fw_unit *unit)
 {
 	struct fw_device *device = fw_parent_device(unit);
-	struct net_device *net = device->card->netdev;
-	struct fwnet_device *dev;
-	struct fwnet_peer *peer;
-	u64 guid;
+	struct fwnet_peer *peer = unit->device.driver_data;
+	int generation;
 
-	if (net && !device->is_local) {
-		dev = netdev_priv(net);
-		guid = (u64)device->config_rom[3] << 32 | device->config_rom[4];
-		peer = fwnet_peer_find_by_guid(dev, guid);
-		if (!peer) {
-			fw_error("fwnet_update: no peer for device %016llx\n",
-				 (unsigned long long)guid);
-			return;
-		}
-		peer->generation = device->generation;
-		rmb();
-		peer->node_id = device->node_id;
-	}
+	generation = device->generation;
+
+	spin_lock_irq(&peer->dev->lock);
+	peer->node_id    = device->node_id;
+	peer->generation = generation;
+	spin_unlock_irq(&peer->dev->lock);
 }
 
 static const struct ieee1394_device_id fwnet_id_table[] = {

commit f91e3bd842ec6f5cea245993926ee8ff26250467
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sun Jun 7 22:57:53 2009 +0200

    firewire: net: style changes
    
    Change names of types, variables, functions.
    Omit debug code.
    Use get_unaligned*, put_unaligned*.
    Annotate big endian data.
    Handle errors in __init.
    Change whitespace.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index 15353886bd80..ba6f924b1b13 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -6,6 +6,7 @@
  * based on eth1394 by Ben Collins et al
  */
 
+#include <linux/bug.h>
 #include <linux/device.h>
 #include <linux/ethtool.h>
 #include <linux/firewire.h>
@@ -13,6 +14,7 @@
 #include <linux/highmem.h>
 #include <linux/in.h>
 #include <linux/ip.h>
+#include <linux/jiffies.h>
 #include <linux/mod_devicetable.h>
 #include <linux/module.h>
 #include <linux/moduleparam.h>
@@ -22,181 +24,109 @@
 #include <asm/unaligned.h>
 #include <net/arp.h>
 
-/* Things to potentially make runtime cofigurable */
-/* must be at least as large as our maximum receive size */
-#define FIFO_SIZE 4096
-/* Network timeout in glibbles */
-#define IPV4_TIMEOUT       100000
+#define FWNET_MAX_FRAGMENTS	25	/* arbitrary limit */
+#define FWNET_ISO_PAGE_COUNT	(PAGE_SIZE < 16 * 1024 ? 4 : 2)
 
-/* Runitme configurable paramaters */
-static int ipv4_mpd = 25;
-static int ipv4_max_xmt = 0;
-/* 16k for receiving arp and broadcast packets.  Enough? */
-static int ipv4_iso_page_count = 4;
+#define IEEE1394_BROADCAST_CHANNEL	31
+#define IEEE1394_ALL_NODES		(0xffc0 | 0x003f)
+#define IEEE1394_MAX_PAYLOAD_S100	512
+#define FWNET_NO_FIFO_ADDR		(~0ULL)
 
-MODULE_AUTHOR("Jay Fenlason (fenlason@redhat.com)");
-MODULE_DESCRIPTION("Firewire IPv4 Driver (IPv4-over-IEEE1394 as per RFC 2734)");
-MODULE_LICENSE("GPL");
-MODULE_DEVICE_TABLE(ieee1394, ipv4_id_table);
-module_param_named(max_partial_datagrams, ipv4_mpd, int, S_IRUGO | S_IWUSR);
-MODULE_PARM_DESC(max_partial_datagrams, "Maximum number of received"
- " incomplete fragmented datagrams (default = 25).");
-
-/* Max xmt is useful for forcing fragmentation, which makes testing easier. */
-module_param_named(max_transmit, ipv4_max_xmt, int, S_IRUGO | S_IWUSR);
-MODULE_PARM_DESC(max_transmit, "Maximum datagram size to transmit"
- " (larger datagrams will be fragmented) (default = 0 (use hardware defaults).");
-
-/* iso page count controls how many pages will be used for receiving broadcast packets. */
-module_param_named(iso_pages, ipv4_iso_page_count, int, S_IRUGO | S_IWUSR);
-MODULE_PARM_DESC(iso_pages, "Number of pages to use for receiving broadcast packets"
- " (default = 4).");
-
-/* uncomment this line to do debugging */
-#define fw_debug(s, args...) printk(KERN_DEBUG KBUILD_MODNAME ": " s, ## args)
-
-/* comment out these lines to do debugging. */
-/* #undef fw_debug */
-/* #define fw_debug(s...) */
-/* #define print_hex_dump(l...) */
-
-/* Define a fake hardware header format for the networking core.  Note that
- * header size cannot exceed 16 bytes as that is the size of the header cache.
- * Also, we do not need the source address in the header so we omit it and
- * keep the header to under 16 bytes */
-#define IPV4_ALEN (8)
-/* This must equal sizeof(struct ipv4_ether_hdr) */
-#define IPV4_HLEN (10)
-
-/* FIXME: what's a good size for this? */
-#define INVALID_FIFO_ADDR (u64)~0ULL
-
-/* Things specified by standards */
-#define BROADCAST_CHANNEL 31
-
-#define S100_BUFFER_SIZE 512
-#define MAX_BUFFER_SIZE 4096
-
-#define IPV4_GASP_SPECIFIER_ID	0x00005EU
-#define IPV4_GASP_VERSION	0x00000001U
-
-#define IPV4_GASP_OVERHEAD (2 * sizeof(u32)) /* for GASP header */
-
-#define IPV4_UNFRAG_HDR_SIZE	sizeof(u32)
-#define IPV4_FRAG_HDR_SIZE	(2 * sizeof(u32))
-#define IPV4_FRAG_OVERHEAD	sizeof(u32)
-
-#define ALL_NODES (0xffc0 | 0x003f)
-
-#define IPV4_HDR_UNFRAG		0	/* unfragmented		*/
-#define IPV4_HDR_FIRSTFRAG	1	/* first fragment	*/
-#define IPV4_HDR_LASTFRAG	2	/* last fragment	*/
-#define IPV4_HDR_INTFRAG	3	/* interior fragment	*/
-
-/* Our arp packet (ARPHRD_IEEE1394) */
-/* FIXME: note that this is probably bogus on weird-endian machines */
-struct ipv4_arp {
-	u16 hw_type;		/* 0x0018	*/
-	u16 proto_type;		/* 0x0806       */
-	u8 hw_addr_len;		/* 16		*/
-	u8 ip_addr_len;         /* 4		*/
-	u16 opcode;	        /* ARP Opcode	*/
-	/* Above is exactly the same format as struct arphdr */
-
-	u64 s_uniq_id;		/* Sender's 64bit EUI			*/
-	u8 max_rec;             /* Sender's max packet size		*/
-	u8 sspd;		/* Sender's max speed			*/
-	u16 fifo_hi;            /* hi 16bits of sender's FIFO addr	*/
-	u32 fifo_lo;            /* lo 32bits of sender's FIFO addr	*/
-	u32 sip;		/* Sender's IP Address			*/
-	u32 tip;		/* IP Address of requested hw addr	*/
-} __attribute__((packed));
+#define IANA_SPECIFIER_ID		0x00005eU
+#define RFC2734_SW_VERSION		0x000001U
 
-struct ipv4_ether_hdr {
-	unsigned char	h_dest[IPV4_ALEN];	/* destination address */
-	unsigned short  h_proto;                /* packet type ID field */
-}  __attribute__((packed));
+#define IEEE1394_GASP_HDR_SIZE	8
 
-static inline struct ipv4_ether_hdr *ipv4_ether_hdr(const struct sk_buff *skb)
-{
-	return (struct ipv4_ether_hdr *)skb_mac_header(skb);
-}
+#define RFC2374_UNFRAG_HDR_SIZE	4
+#define RFC2374_FRAG_HDR_SIZE	8
+#define RFC2374_FRAG_OVERHEAD	4
 
-enum ipv4_tx_type {
-	IPV4_UNKNOWN = 0,
-	IPV4_GASP = 1,
-	IPV4_WRREQ = 2,
-};
+#define RFC2374_HDR_UNFRAG	0	/* unfragmented		*/
+#define RFC2374_HDR_FIRSTFRAG	1	/* first fragment	*/
+#define RFC2374_HDR_LASTFRAG	2	/* last fragment	*/
+#define RFC2374_HDR_INTFRAG	3	/* interior fragment	*/
 
-enum ipv4_broadcast_state {
-	IPV4_BROADCAST_ERROR,
-	IPV4_BROADCAST_RUNNING,
-	IPV4_BROADCAST_STOPPED,
-};
+#define RFC2734_HW_ADDR_LEN	16
 
-#define ipv4_get_hdr_lf(h)		(((h)->w0&0xC0000000)>>30)
-#define ipv4_get_hdr_ether_type(h)	(((h)->w0&0x0000FFFF)    )
-#define ipv4_get_hdr_dg_size(h)		(((h)->w0&0x0FFF0000)>>16)
-#define ipv4_get_hdr_fg_off(h)		(((h)->w0&0x00000FFF)    )
-#define ipv4_get_hdr_dgl(h)		(((h)->w1&0xFFFF0000)>>16)
+struct rfc2734_arp {
+	__be16 hw_type;		/* 0x0018	*/
+	__be16 proto_type;	/* 0x0806       */
+	u8 hw_addr_len;		/* 16		*/
+	u8 ip_addr_len;		/* 4		*/
+	__be16 opcode;		/* ARP Opcode	*/
+	/* Above is exactly the same format as struct arphdr */
 
-#define ipv4_set_hdr_lf(lf)		(( lf)<<30)
-#define ipv4_set_hdr_ether_type(et)	(( et)    )
-#define ipv4_set_hdr_dg_size(dgs)	((dgs)<<16)
-#define ipv4_set_hdr_fg_off(fgo)	((fgo)    )
+	__be64 s_uniq_id;	/* Sender's 64bit EUI			*/
+	u8 max_rec;		/* Sender's max packet size		*/
+	u8 sspd;		/* Sender's max speed			*/
+	__be16 fifo_hi;		/* hi 16bits of sender's FIFO addr	*/
+	__be32 fifo_lo;		/* lo 32bits of sender's FIFO addr	*/
+	__be32 sip;		/* Sender's IP Address			*/
+	__be32 tip;		/* IP Address of requested hw addr	*/
+} __attribute__((packed));
 
-#define ipv4_set_hdr_dgl(dgl)		((dgl)<<16)
+/* This header format is specific to this driver implementation. */
+#define FWNET_ALEN	8
+#define FWNET_HLEN	10
+struct fwnet_header {
+	u8 h_dest[FWNET_ALEN];	/* destination address */
+	__be16 h_proto;		/* packet type ID field */
+} __attribute__((packed));
 
-struct ipv4_hdr {
+/* IPv4 and IPv6 encapsulation header */
+struct rfc2734_header {
 	u32 w0;
 	u32 w1;
 };
 
-static inline void ipv4_make_uf_hdr( struct ipv4_hdr *hdr, unsigned ether_type) {
-	hdr->w0 = ipv4_set_hdr_lf(IPV4_HDR_UNFRAG)
-		   |ipv4_set_hdr_ether_type(ether_type);
-	fw_debug ( "Setting unfragmented header %p to %x\n", hdr, hdr->w0 );
-}
+#define fwnet_get_hdr_lf(h)		(((h)->w0 & 0xc0000000) >> 30)
+#define fwnet_get_hdr_ether_type(h)	(((h)->w0 & 0x0000ffff))
+#define fwnet_get_hdr_dg_size(h)	(((h)->w0 & 0x0fff0000) >> 16)
+#define fwnet_get_hdr_fg_off(h)		(((h)->w0 & 0x00000fff))
+#define fwnet_get_hdr_dgl(h)		(((h)->w1 & 0xffff0000) >> 16)
 
-static inline void ipv4_make_ff_hdr ( struct ipv4_hdr *hdr, unsigned ether_type, unsigned dg_size, unsigned dgl ) {
-	hdr->w0 = ipv4_set_hdr_lf(IPV4_HDR_FIRSTFRAG)
-		   |ipv4_set_hdr_dg_size(dg_size)
-		   |ipv4_set_hdr_ether_type(ether_type);
-	hdr->w1 = ipv4_set_hdr_dgl(dgl);
-	fw_debug ( "Setting fragmented header %p to first_frag %x,%x (et %x, dgs %x, dgl %x)\n", hdr, hdr->w0, hdr->w1,
- ether_type, dg_size, dgl );
-}
+#define fwnet_set_hdr_lf(lf)		((lf)  << 30)
+#define fwnet_set_hdr_ether_type(et)	(et)
+#define fwnet_set_hdr_dg_size(dgs)	((dgs) << 16)
+#define fwnet_set_hdr_fg_off(fgo)	(fgo)
 
-static inline void ipv4_make_sf_hdr ( struct ipv4_hdr *hdr, unsigned lf, unsigned dg_size, unsigned fg_off, unsigned dgl) {
-	hdr->w0 = ipv4_set_hdr_lf(lf)
-		 |ipv4_set_hdr_dg_size(dg_size)
-		 |ipv4_set_hdr_fg_off(fg_off);
-	hdr->w1 = ipv4_set_hdr_dgl(dgl);
-	fw_debug ( "Setting fragmented header %p to %x,%x (lf %x, dgs %x, fo %x dgl %x)\n",
- hdr, hdr->w0, hdr->w1,
- lf, dg_size, fg_off, dgl );
-}
+#define fwnet_set_hdr_dgl(dgl)		((dgl) << 16)
 
-/* End of IP1394 headers */
+static inline void fwnet_make_uf_hdr(struct rfc2734_header *hdr,
+		unsigned ether_type)
+{
+	hdr->w0 = fwnet_set_hdr_lf(RFC2374_HDR_UNFRAG)
+		  | fwnet_set_hdr_ether_type(ether_type);
+}
 
-/* Fragment types */
-#define ETH1394_HDR_LF_UF	0	/* unfragmented		*/
-#define ETH1394_HDR_LF_FF	1	/* first fragment	*/
-#define ETH1394_HDR_LF_LF	2	/* last fragment	*/
-#define ETH1394_HDR_LF_IF	3	/* interior fragment	*/
+static inline void fwnet_make_ff_hdr(struct rfc2734_header *hdr,
+		unsigned ether_type, unsigned dg_size, unsigned dgl)
+{
+	hdr->w0 = fwnet_set_hdr_lf(RFC2374_HDR_FIRSTFRAG)
+		  | fwnet_set_hdr_dg_size(dg_size)
+		  | fwnet_set_hdr_ether_type(ether_type);
+	hdr->w1 = fwnet_set_hdr_dgl(dgl);
+}
 
-#define IP1394_HW_ADDR_LEN	16	/* As per RFC		*/
+static inline void fwnet_make_sf_hdr(struct rfc2734_header *hdr,
+		unsigned lf, unsigned dg_size, unsigned fg_off, unsigned dgl)
+{
+	hdr->w0 = fwnet_set_hdr_lf(lf)
+		  | fwnet_set_hdr_dg_size(dg_size)
+		  | fwnet_set_hdr_fg_off(fg_off);
+	hdr->w1 = fwnet_set_hdr_dgl(dgl);
+}
 
 /* This list keeps track of what parts of the datagram have been filled in */
-struct ipv4_fragment_info {
-        struct list_head fragment_info;
+struct fwnet_fragment_info {
+	struct list_head fi_link;
 	u16 offset;
 	u16 len;
 };
 
-struct ipv4_partial_datagram {
-	struct list_head pdg_list;
-	struct list_head fragment_info;
+struct fwnet_partial_datagram {
+	struct list_head pd_link;
+	struct list_head fi_list;
 	struct sk_buff *skb;
 	/* FIXME Why not use skb->data? */
 	char *pbuf;
@@ -208,40 +138,43 @@ struct ipv4_partial_datagram {
 /*
  * We keep one of these for each IPv4 capable device attached to a fw_card.
  * The list of them is stored in the fw_card structure rather than in the
- * ipv4_priv because the remote IPv4 nodes may be probed before the card is,
- * so we need a place to store them before the ipv4_priv structure is
+ * fwnet_device because the remote IPv4 nodes may be probed before the card is,
+ * so we need a place to store them before the fwnet_device structure is
  * allocated.
  */
-struct ipv4_node {
-	struct list_head ipv4_nodes;
-	/* guid of the remote node */
+struct fwnet_peer {
+	struct list_head peer_link;
+	/* guid of the remote peer */
 	u64 guid;
-	/* FIFO address to transmit datagrams to, or INVALID_FIFO_ADDR */
+	/* FIFO address to transmit datagrams to, or FWNET_NO_FIFO_ADDR */
 	u64 fifo;
 
 	spinlock_t pdg_lock;	/* partial datagram lock		*/
-	/* List of partial datagrams received from this node */
-	struct list_head pdg_list;
-	/* Number of entries in pdg_list at the moment */
+	/* List of partial datagrams received from this peer */
+	struct list_head pd_list;
+	/* Number of entries in pd_list at the moment */
 	unsigned pdg_size;
 
-	/* max payload to transmit to this remote node */
-	/* This already includes the IPV4_FRAG_HDR_SIZE overhead */
+	/* max payload to transmit to this remote peer */
+	/* This already includes the RFC2374_FRAG_HDR_SIZE overhead */
 	u16 max_payload;
 	/* outgoing datagram label */
 	u16 datagram_label;
-	/* Current node_id of the remote node */
-	u16 nodeid;
-	/* current generation of the remote node */
+	/* Current node_id of the remote peer */
+	u16 node_id;
+	/* current generation of the remote peer */
 	u8 generation;
-	/* max speed that this node can receive at */
+	/* max speed that this peer can receive at */
 	u8 xmt_speed;
 };
 
-struct ipv4_priv {
+struct fwnet_device {
 	spinlock_t lock;
-
-	enum ipv4_broadcast_state broadcast_state;
+	enum {
+		FWNET_BROADCAST_ERROR,
+		FWNET_BROADCAST_RUNNING,
+		FWNET_BROADCAST_STOPPED,
+	} broadcast_state;
 	struct fw_iso_context *broadcast_rcv_context;
 	struct fw_iso_buffer broadcast_rcv_buffer;
 	void **broadcast_rcv_buffer_ptrs;
@@ -257,14 +190,12 @@ struct ipv4_priv {
 	u16 broadcast_xmt_datagramlabel;
 
 	/*
-	 * The csr address that remote nodes must send datagrams to for us to
+	 * The CSR address that remote nodes must send datagrams to for us to
 	 * receive them.
 	 */
 	struct fw_address_handler handler;
 	u64 local_fifo;
 
-	/* Wake up to xmt	 */
-        /* struct work_struct wake;*/
 	/* List of packets to be sent */
 	struct list_head packet_list;
 	/*
@@ -279,17 +210,17 @@ struct ipv4_priv {
 };
 
 /* This is our task struct. It's used for the packet complete callback.  */
-struct ipv4_packet_task {
+struct fwnet_packet_task {
 	/*
-	 * ptask can actually be on priv->packet_list, priv->broadcasted_list,
-	 * or priv->sent_list depending on its current state.
+	 * ptask can actually be on dev->packet_list, dev->broadcasted_list,
+	 * or dev->sent_list depending on its current state.
 	 */
-	struct list_head packet_list;
+	struct list_head pt_link;
 	struct fw_transaction transaction;
-	struct ipv4_hdr hdr;
+	struct rfc2734_header hdr;
 	struct sk_buff *skb;
-	struct ipv4_priv *priv;
-	enum ipv4_tx_type tx_type;
+	struct fwnet_device *dev;
+
 	int outstanding_pkts;
 	unsigned max_payload;
 	u64 fifo_addr;
@@ -298,243 +229,192 @@ struct ipv4_packet_task {
 	u8 speed;
 };
 
-static struct kmem_cache *ipv4_packet_task_cache;
-
-static const char ipv4_driver_name[] = "firewire-ipv4";
-
-static const struct ieee1394_device_id ipv4_id_table[] = {
-	{
-		.match_flags  = IEEE1394_MATCH_SPECIFIER_ID |
-				IEEE1394_MATCH_VERSION,
-		.specifier_id = IPV4_GASP_SPECIFIER_ID,
-		.version      = IPV4_GASP_VERSION,
-	},
-	{ }
-};
-
-static u32 ipv4_unit_directory_data[] = {
-	0x00040000,					/* unit directory */
-	0x12000000 | IPV4_GASP_SPECIFIER_ID,	/* specifier ID */
-	0x81000003,					/* text descriptor */
-	0x13000000 | IPV4_GASP_VERSION,		/* version */
-	0x81000005,					/* text descriptor */
-
-	0x00030000,					/* Three quadlets */
-	0x00000000,					/* Text */
-	0x00000000,					/* Language 0 */
-	0x49414e41,					/* I A N A */
-	0x00030000,					/* Three quadlets */
-	0x00000000,					/* Text */
-	0x00000000,					/* Language 0 */
-	0x49507634,					/* I P v 4 */
-};
-
-static struct fw_descriptor ipv4_unit_directory = {
-	.length = ARRAY_SIZE(ipv4_unit_directory_data),
-	.key = 0xd1000000,
-	.data = ipv4_unit_directory_data
-};
-
-static int ipv4_send_packet(struct ipv4_packet_task *ptask );
-
-/* ------------------------------------------------------------------ */
-/******************************************
- * HW Header net device functions
- ******************************************/
-  /* These functions have been adapted from net/ethernet/eth.c */
-
-/* Create a fake MAC header for an arbitrary protocol layer.
- * saddr=NULL means use device source address
- * daddr=NULL means leave destination address (eg unresolved arp). */
+/*
+ * saddr == NULL means use device source address.
+ * daddr == NULL means leave destination address (eg unresolved arp).
+ */
+static int fwnet_header_create(struct sk_buff *skb, struct net_device *net,
+			unsigned short type, const void *daddr,
+			const void *saddr, unsigned len)
+{
+	struct fwnet_header *h;
 
-static int ipv4_header ( struct sk_buff *skb, struct net_device *dev,
-		       unsigned short type, const void *daddr,
-		       const void *saddr, unsigned len) {
-	struct ipv4_ether_hdr *eth;
+	h = (struct fwnet_header *)skb_push(skb, sizeof(*h));
+	put_unaligned_be16(type, &h->h_proto);
 
-	eth = (struct ipv4_ether_hdr *)skb_push(skb, sizeof(*eth));
-	eth->h_proto = htons(type);
+	if (net->flags & (IFF_LOOPBACK | IFF_NOARP)) {
+		memset(h->h_dest, 0, net->addr_len);
 
-	if (dev->flags & (IFF_LOOPBACK | IFF_NOARP)) {
-		memset(eth->h_dest, 0, dev->addr_len);
-		return dev->hard_header_len;
+		return net->hard_header_len;
 	}
 
 	if (daddr) {
-		memcpy(eth->h_dest, daddr, dev->addr_len);
-		return dev->hard_header_len;
+		memcpy(h->h_dest, daddr, net->addr_len);
+
+		return net->hard_header_len;
 	}
 
-	return -dev->hard_header_len;
+	return -net->hard_header_len;
 }
 
-/* Rebuild the faked MAC header. This is called after an ARP
- * (or in future other address resolution) has completed on this
- * sk_buff. We now let ARP fill in the other fields.
- *
- * This routine CANNOT use cached dst->neigh!
- * Really, it is used only when dst->neigh is wrong.
- */
-
-static int ipv4_rebuild_header(struct sk_buff *skb)
+static int fwnet_header_rebuild(struct sk_buff *skb)
 {
-	struct ipv4_ether_hdr *eth;
+	struct fwnet_header *h = (struct fwnet_header *)skb->data;
 
-	eth = (struct ipv4_ether_hdr *)skb->data;
-	if (eth->h_proto == htons(ETH_P_IP))
-		return arp_find((unsigned char *)&eth->h_dest, skb);
+	if (get_unaligned_be16(&h->h_proto) == ETH_P_IP)
+		return arp_find((unsigned char *)&h->h_dest, skb);
 
-	fw_notify ( "%s: unable to resolve type %04x addresses\n",
-		   skb->dev->name,ntohs(eth->h_proto) );
+	fw_notify("%s: unable to resolve type %04x addresses\n",
+		  skb->dev->name, be16_to_cpu(h->h_proto));
 	return 0;
 }
 
-static int ipv4_header_cache(const struct neighbour *neigh, struct hh_cache *hh) {
-	unsigned short type = hh->hh_type;
-	struct net_device *dev;
-	struct ipv4_ether_hdr *eth;
+static int fwnet_header_cache(const struct neighbour *neigh,
+			      struct hh_cache *hh)
+{
+	struct net_device *net;
+	struct fwnet_header *h;
 
-	if (type == htons(ETH_P_802_3))
+	if (hh->hh_type == cpu_to_be16(ETH_P_802_3))
 		return -1;
-	dev = neigh->dev;
-	eth = (struct ipv4_ether_hdr *)((u8 *)hh->hh_data + 16 - sizeof(*eth));
-	eth->h_proto = type;
-	memcpy(eth->h_dest, neigh->ha, dev->addr_len);
+	net = neigh->dev;
+	h = (struct fwnet_header *)((u8 *)hh->hh_data + 16 - sizeof(*h));
+	h->h_proto = hh->hh_type;
+	memcpy(h->h_dest, neigh->ha, net->addr_len);
+	hh->hh_len = FWNET_HLEN;
 
-	hh->hh_len = IPV4_HLEN;
 	return 0;
 }
 
 /* Called by Address Resolution module to notify changes in address. */
-static void ipv4_header_cache_update(struct hh_cache *hh, const struct net_device *dev, const unsigned char * haddr ) {
-	memcpy((u8 *)hh->hh_data + 16 - IPV4_HLEN, haddr, dev->addr_len);
+static void fwnet_header_cache_update(struct hh_cache *hh,
+		const struct net_device *net, const unsigned char *haddr)
+{
+	memcpy((u8 *)hh->hh_data + 16 - FWNET_HLEN, haddr, net->addr_len);
 }
 
-static int ipv4_header_parse(const struct sk_buff *skb, unsigned char *haddr) {
-	memcpy(haddr, skb->dev->dev_addr, IPV4_ALEN);
-	return IPV4_ALEN;
+static int fwnet_header_parse(const struct sk_buff *skb, unsigned char *haddr)
+{
+	memcpy(haddr, skb->dev->dev_addr, FWNET_ALEN);
+
+	return FWNET_ALEN;
 }
 
-static const struct header_ops ipv4_header_ops = {
-	.create         = ipv4_header,
-	.rebuild        = ipv4_rebuild_header,
-	.cache		= ipv4_header_cache,
-	.cache_update	= ipv4_header_cache_update,
-	.parse          = ipv4_header_parse,
+static const struct header_ops fwnet_header_ops = {
+	.create         = fwnet_header_create,
+	.rebuild        = fwnet_header_rebuild,
+	.cache		= fwnet_header_cache,
+	.cache_update	= fwnet_header_cache_update,
+	.parse          = fwnet_header_parse,
 };
 
-/* ------------------------------------------------------------------ */
-
 /* FIXME: is this correct for all cases? */
-static bool ipv4_frag_overlap(struct ipv4_partial_datagram *pd, unsigned offset, unsigned len)
+static bool fwnet_frag_overlap(struct fwnet_partial_datagram *pd,
+			       unsigned offset, unsigned len)
 {
-        struct ipv4_fragment_info *fi;
+	struct fwnet_fragment_info *fi;
 	unsigned end = offset + len;
 
-	list_for_each_entry(fi, &pd->fragment_info, fragment_info) {
-		if (offset < fi->offset + fi->len && end > fi->offset) {
-			fw_debug ( "frag_overlap pd %p fi %p (%x@%x) with %x@%x\n", pd, fi, fi->len, fi->offset, len, offset );
+	list_for_each_entry(fi, &pd->fi_list, fi_link)
+		if (offset < fi->offset + fi->len && end > fi->offset)
 			return true;
-		}
-	}
-	fw_debug ( "frag_overlap %p does not overlap with %x@%x\n", pd, len, offset );
+
 	return false;
 }
 
 /* Assumes that new fragment does not overlap any existing fragments */
-static struct ipv4_fragment_info *ipv4_frag_new ( struct ipv4_partial_datagram *pd, unsigned offset, unsigned len ) {
-	struct ipv4_fragment_info *fi, *fi2, *new;
+static struct fwnet_fragment_info *fwnet_frag_new(
+	struct fwnet_partial_datagram *pd, unsigned offset, unsigned len)
+{
+	struct fwnet_fragment_info *fi, *fi2, *new;
 	struct list_head *list;
 
-	fw_debug ( "frag_new pd %p %x@%x\n", pd, len, offset );
-	list = &pd->fragment_info;
-	list_for_each_entry(fi, &pd->fragment_info, fragment_info) {
+	list = &pd->fi_list;
+	list_for_each_entry(fi, &pd->fi_list, fi_link) {
 		if (fi->offset + fi->len == offset) {
 			/* The new fragment can be tacked on to the end */
 			/* Did the new fragment plug a hole? */
-			fi2 = list_entry(fi->fragment_info.next, struct ipv4_fragment_info, fragment_info);
+			fi2 = list_entry(fi->fi_link.next,
+					 struct fwnet_fragment_info, fi_link);
 			if (fi->offset + fi->len == fi2->offset) {
-				fw_debug ( "pd %p: hole filling %p (%x@%x) and %p(%x@%x): now %x@%x\n", pd, fi, fi->len, fi->offset,
-				fi2, fi2->len, fi2->offset, fi->len + len + fi2->len, fi->offset );
 				/* glue fragments together */
 				fi->len += len + fi2->len;
-				list_del(&fi2->fragment_info);
+				list_del(&fi2->fi_link);
 				kfree(fi2);
 			} else {
-				fw_debug ( "pd %p: extending %p from %x@%x to %x@%x\n", pd, fi, fi->len, fi->offset, fi->len+len, fi->offset );
 				fi->len += len;
 			}
+
 			return fi;
 		}
 		if (offset + len == fi->offset) {
 			/* The new fragment can be tacked on to the beginning */
 			/* Did the new fragment plug a hole? */
-			fi2 = list_entry(fi->fragment_info.prev, struct ipv4_fragment_info, fragment_info);
+			fi2 = list_entry(fi->fi_link.prev,
+					 struct fwnet_fragment_info, fi_link);
 			if (fi2->offset + fi2->len == fi->offset) {
 				/* glue fragments together */
-				fw_debug ( "pd %p: extending %p and merging with %p from %x@%x to %x@%x\n",
- pd, fi2, fi, fi2->len, fi2->offset, fi2->len + fi->len + len, fi2->offset );
 				fi2->len += fi->len + len;
-				list_del(&fi->fragment_info);
+				list_del(&fi->fi_link);
 				kfree(fi);
+
 				return fi2;
 			}
-			fw_debug ( "pd %p: extending %p from %x@%x to %x@%x\n", pd, fi, fi->len, fi->offset, offset, fi->len + len );
 			fi->offset = offset;
 			fi->len += len;
+
 			return fi;
 		}
 		if (offset > fi->offset + fi->len) {
-			list = &fi->fragment_info;
+			list = &fi->fi_link;
 			break;
 		}
 		if (offset + len < fi->offset) {
-			list = fi->fragment_info.prev;
+			list = fi->fi_link.prev;
 			break;
 		}
 	}
 
 	new = kmalloc(sizeof(*new), GFP_ATOMIC);
 	if (!new) {
-		fw_error ( "out of memory in fragment handling!\n" );
+		fw_error("out of memory\n");
 		return NULL;
 	}
 
 	new->offset = offset;
 	new->len = len;
-	list_add(&new->fragment_info, list);
-	fw_debug ( "pd %p: new frag %p %x@%x\n", pd, new, new->len, new->offset );
-	list_for_each_entry( fi, &pd->fragment_info, fragment_info )
-		fw_debug ( "fi %p %x@%x\n", fi, fi->len, fi->offset );
+	list_add(&new->fi_link, list);
+
 	return new;
 }
 
-/* ------------------------------------------------------------------ */
-
-static struct ipv4_partial_datagram *ipv4_pd_new(struct net_device *netdev,
- struct ipv4_node *node, u16 datagram_label, unsigned dg_size, u32 *frag_buf,
- unsigned frag_off, unsigned frag_len) {
-	struct ipv4_partial_datagram *new;
-	struct ipv4_fragment_info *fi;
+static struct fwnet_partial_datagram *fwnet_pd_new(struct net_device *net,
+		struct fwnet_peer *peer, u16 datagram_label, unsigned dg_size,
+		void *frag_buf, unsigned frag_off, unsigned frag_len)
+{
+	struct fwnet_partial_datagram *new;
+	struct fwnet_fragment_info *fi;
 
 	new = kmalloc(sizeof(*new), GFP_ATOMIC);
 	if (!new)
 		goto fail;
-	INIT_LIST_HEAD(&new->fragment_info);
-	fi = ipv4_frag_new ( new, frag_off, frag_len);
-	if ( fi == NULL )
+
+	INIT_LIST_HEAD(&new->fi_list);
+	fi = fwnet_frag_new(new, frag_off, frag_len);
+	if (fi == NULL)
 		goto fail_w_new;
+
 	new->datagram_label = datagram_label;
 	new->datagram_size = dg_size;
-	new->skb = dev_alloc_skb(dg_size + netdev->hard_header_len + 15);
-	if ( new->skb == NULL )
+	new->skb = dev_alloc_skb(dg_size + net->hard_header_len + 15);
+	if (new->skb == NULL)
 		goto fail_w_fi;
-	skb_reserve(new->skb, (netdev->hard_header_len + 15) & ~15);
+
+	skb_reserve(new->skb, (net->hard_header_len + 15) & ~15);
 	new->pbuf = skb_put(new->skb, dg_size);
 	memcpy(new->pbuf + frag_off, frag_buf, frag_len);
-	list_add_tail(&new->pdg_list, &node->pdg_list);
-	fw_debug ( "pd_new: new pd %p { dgl %u, dg_size %u, skb %p, pbuf %p } on node %p\n",
- new, new->datagram_label, new->datagram_size, new->skb, new->pbuf, node );
+	list_add_tail(&new->pd_link, &peer->pd_list);
+
 	return new;
 
 fail_w_fi:
@@ -542,174 +422,171 @@ static struct ipv4_partial_datagram *ipv4_pd_new(struct net_device *netdev,
 fail_w_new:
 	kfree(new);
 fail:
-	fw_error("ipv4_pd_new: no memory\n");
+	fw_error("out of memory\n");
+
 	return NULL;
 }
 
-static struct ipv4_partial_datagram *ipv4_pd_find(struct ipv4_node *node, u16 datagram_label) {
-	struct ipv4_partial_datagram *pd;
+static struct fwnet_partial_datagram *fwnet_pd_find(struct fwnet_peer *peer,
+						    u16 datagram_label)
+{
+	struct fwnet_partial_datagram *pd;
 
-	list_for_each_entry(pd, &node->pdg_list, pdg_list) {
-	        if ( pd->datagram_label == datagram_label ) {
-			fw_debug ( "pd_find(node %p, label %u): pd %p\n", node, datagram_label, pd );
+	list_for_each_entry(pd, &peer->pd_list, pd_link)
+		if (pd->datagram_label == datagram_label)
 			return pd;
-		}
-	}
-	fw_debug ( "pd_find(node %p, label %u) no entry\n", node, datagram_label );
+
 	return NULL;
 }
 
 
-static void ipv4_pd_delete ( struct ipv4_partial_datagram *old ) {
-	struct ipv4_fragment_info *fi, *n;
+static void fwnet_pd_delete(struct fwnet_partial_datagram *old)
+{
+	struct fwnet_fragment_info *fi, *n;
 
-	fw_debug ( "pd_delete %p\n", old );
-	list_for_each_entry_safe(fi, n, &old->fragment_info, fragment_info) {
-		fw_debug ( "Freeing fi %p\n", fi );
+	list_for_each_entry_safe(fi, n, &old->fi_list, fi_link)
 		kfree(fi);
-	}
-	list_del(&old->pdg_list);
+
+	list_del(&old->pd_link);
 	dev_kfree_skb_any(old->skb);
 	kfree(old);
 }
 
-static bool ipv4_pd_update ( struct ipv4_node *node, struct ipv4_partial_datagram *pd,
- u32 *frag_buf, unsigned frag_off, unsigned frag_len) {
-	fw_debug ( "pd_update node %p, pd %p, frag_buf %p, %x@%x\n", node, pd, frag_buf, frag_len, frag_off );
-	if ( ipv4_frag_new ( pd, frag_off, frag_len ) == NULL)
+static bool fwnet_pd_update(struct fwnet_peer *peer,
+		struct fwnet_partial_datagram *pd, void *frag_buf,
+		unsigned frag_off, unsigned frag_len)
+{
+	if (fwnet_frag_new(pd, frag_off, frag_len) == NULL)
 		return false;
+
 	memcpy(pd->pbuf + frag_off, frag_buf, frag_len);
 
 	/*
 	 * Move list entry to beginnig of list so that oldest partial
 	 * datagrams percolate to the end of the list
 	 */
-	list_move_tail(&pd->pdg_list, &node->pdg_list);
-	fw_debug ( "New pd list:\n" );
-	list_for_each_entry ( pd, &node->pdg_list, pdg_list ) {
-		fw_debug ( "pd %p\n", pd );
-	}
+	list_move_tail(&pd->pd_link, &peer->pd_list);
+
 	return true;
 }
 
-static bool ipv4_pd_is_complete ( struct ipv4_partial_datagram *pd ) {
-	struct ipv4_fragment_info *fi;
-	bool ret;
+static bool fwnet_pd_is_complete(struct fwnet_partial_datagram *pd)
+{
+	struct fwnet_fragment_info *fi;
 
-	fi = list_entry(pd->fragment_info.next, struct ipv4_fragment_info, fragment_info);
+	fi = list_entry(pd->fi_list.next, struct fwnet_fragment_info, fi_link);
 
-	ret = (fi->len == pd->datagram_size);
-	fw_debug ( "pd_is_complete (pd %p, dgs %x): fi %p (%x@%x) %s\n", pd, pd->datagram_size, fi, fi->len, fi->offset, ret ? "yes" : "no" );
-	return ret;
+	return fi->len == pd->datagram_size;
 }
 
-/* ------------------------------------------------------------------ */
+static int fwnet_peer_new(struct fw_card *card, struct fw_device *device)
+{
+	struct fwnet_peer *peer;
 
-static int ipv4_node_new ( struct fw_card *card, struct fw_device *device ) {
-	struct ipv4_node *node;
+	peer = kmalloc(sizeof(*peer), GFP_KERNEL);
+	if (!peer) {
+		fw_error("out of memory\n");
 
-	node = kmalloc ( sizeof(*node), GFP_KERNEL );
-	if ( ! node ) {
-		fw_error ( "allocate new node failed\n" );
 		return -ENOMEM;
 	}
-	node->guid = (u64)device->config_rom[3] << 32 | device->config_rom[4];
-	node->fifo = INVALID_FIFO_ADDR;
-	INIT_LIST_HEAD(&node->pdg_list);
-	spin_lock_init(&node->pdg_lock);
-	node->pdg_size = 0;
-	node->generation = device->generation;
+	peer->guid = (u64)device->config_rom[3] << 32 | device->config_rom[4];
+	peer->fifo = FWNET_NO_FIFO_ADDR;
+	INIT_LIST_HEAD(&peer->pd_list);
+	spin_lock_init(&peer->pdg_lock);
+	peer->pdg_size = 0;
+	peer->generation = device->generation;
 	rmb();
-	node->nodeid = device->node_id;
+	peer->node_id = device->node_id;
 	 /* FIXME what should it really be? */
-	node->max_payload = S100_BUFFER_SIZE - IPV4_UNFRAG_HDR_SIZE;
-	node->datagram_label = 0U;
-	node->xmt_speed = device->max_speed;
-	list_add_tail ( &node->ipv4_nodes, &card->ipv4_nodes );
-	fw_debug ( "node_new: %p { guid %016llx, generation %u, nodeid %x, max_payload %x, xmt_speed %x } added\n",
- node, (unsigned long long)node->guid, node->generation, node->nodeid, node->max_payload, node->xmt_speed );
+	peer->max_payload = IEEE1394_MAX_PAYLOAD_S100 - RFC2374_UNFRAG_HDR_SIZE;
+	peer->datagram_label = 0U;
+	peer->xmt_speed = device->max_speed;
+	list_add_tail(&peer->peer_link, &card->peer_list);
+
 	return 0;
 }
 
-static struct ipv4_node *ipv4_node_find_by_guid(struct ipv4_priv *priv, u64 guid) {
-	struct ipv4_node *node;
+/* FIXME caller must take the lock, or peer needs to be reference-counted */
+static struct fwnet_peer *fwnet_peer_find_by_guid(struct fwnet_device *dev,
+						  u64 guid)
+{
+	struct fwnet_peer *p, *peer = NULL;
 	unsigned long flags;
 
-	spin_lock_irqsave(&priv->lock, flags);
-	list_for_each_entry(node, &priv->card->ipv4_nodes, ipv4_nodes)
-		if (node->guid == guid) {
-			/* FIXME: lock the node first? */
-			spin_unlock_irqrestore ( &priv->lock, flags );
-			fw_debug ( "node_find_by_guid (%016llx) found %p\n", (unsigned long long)guid, node );
-			return node;
+	spin_lock_irqsave(&dev->lock, flags);
+	list_for_each_entry(p, &dev->card->peer_list, peer_link)
+		if (p->guid == guid) {
+			peer = p;
+			break;
 		}
+	spin_unlock_irqrestore(&dev->lock, flags);
 
-	spin_unlock_irqrestore ( &priv->lock, flags );
-	fw_debug ( "node_find_by_guid (%016llx) not found\n", (unsigned long long)guid );
-	return NULL;
+	return peer;
 }
 
-static struct ipv4_node *ipv4_node_find_by_nodeid(struct ipv4_priv *priv, u16 nodeid) {
-	struct ipv4_node *node;
+/* FIXME caller must take the lock, or peer needs to be reference-counted */
+/* FIXME node_id doesn't mean anything without generation */
+static struct fwnet_peer *fwnet_peer_find_by_node_id(struct fwnet_device *dev,
+						     u16 node_id)
+{
+	struct fwnet_peer *p, *peer = NULL;
 	unsigned long flags;
 
-	spin_lock_irqsave(&priv->lock, flags);
-	list_for_each_entry(node, &priv->card->ipv4_nodes, ipv4_nodes)
-		if (node->nodeid == nodeid) {
-			/* FIXME: lock the node first? */
-			spin_unlock_irqrestore ( &priv->lock, flags );
-			fw_debug ( "node_find_by_nodeid (%x) found %p\n", nodeid, node );
-			return node;
+	spin_lock_irqsave(&dev->lock, flags);
+	list_for_each_entry(p, &dev->card->peer_list, peer_link)
+		if (p->node_id == node_id) {
+			peer = p;
+			break;
 		}
-	fw_debug ( "node_find_by_nodeid (%x) not found\n", nodeid );
-	spin_unlock_irqrestore ( &priv->lock, flags );
-	return NULL;
+	spin_unlock_irqrestore(&dev->lock, flags);
+
+	return peer;
 }
 
-/* This is only complicated because we can't assume priv exists */
-static void ipv4_node_delete ( struct fw_card *card, struct fw_device *device ) {
-	struct net_device *netdev;
-	struct ipv4_priv *priv;
-	struct ipv4_node *node;
+/* FIXME */
+static void fwnet_peer_delete(struct fw_card *card, struct fw_device *device)
+{
+	struct net_device *net;
+	struct fwnet_device *dev;
+	struct fwnet_peer *peer;
 	u64 guid;
 	unsigned long flags;
-	struct ipv4_partial_datagram *pd, *pd_next;
+	struct fwnet_partial_datagram *pd, *pd_next;
 
 	guid = (u64)device->config_rom[3] << 32 | device->config_rom[4];
-	netdev = card->netdev;
-	if ( netdev )
-		priv = netdev_priv ( netdev );
+	net = card->netdev;
+	if (net)
+		dev = netdev_priv(net);
 	else
-		priv = NULL;
-	if ( priv )
-		spin_lock_irqsave ( &priv->lock, flags );
-	list_for_each_entry( node, &card->ipv4_nodes, ipv4_nodes ) {
-		if ( node->guid == guid ) {
-			list_del ( &node->ipv4_nodes );
-			list_for_each_entry_safe( pd, pd_next, &node->pdg_list, pdg_list )
-				ipv4_pd_delete ( pd );
+		dev = NULL;
+	if (dev)
+		spin_lock_irqsave(&dev->lock, flags);
+
+	list_for_each_entry(peer, &card->peer_list, peer_link) {
+		if (peer->guid == guid) {
+			list_del(&peer->peer_link);
+			list_for_each_entry_safe(pd, pd_next, &peer->pd_list,
+						 pd_link)
+				fwnet_pd_delete(pd);
 			break;
 		}
 	}
-	if ( priv )
-		spin_unlock_irqrestore ( &priv->lock, flags );
+	if (dev)
+		spin_unlock_irqrestore(&dev->lock, flags);
 }
 
-/* ------------------------------------------------------------------ */
-
-
-static int ipv4_finish_incoming_packet ( struct net_device *netdev,
- struct sk_buff *skb, u16 source_node_id, bool is_broadcast, u16 ether_type ) {
-	struct ipv4_priv *priv;
-	static u64 broadcast_hw = ~0ULL;
+static int fwnet_finish_incoming_packet(struct net_device *net,
+					struct sk_buff *skb, u16 source_node_id,
+					bool is_broadcast, u16 ether_type)
+{
+	struct fwnet_device *dev;
+	static const __be64 broadcast_hw = cpu_to_be64(~0ULL);
 	int status;
-	u64 guid;
+	__be64 guid;
 
-	fw_debug ( "ipv4_finish_incoming_packet(%p, %p, %x, %s, %x\n",
- netdev, skb, source_node_id, is_broadcast ? "true" : "false", ether_type );
-	priv = netdev_priv(netdev);
+	dev = netdev_priv(net);
 	/* Write metadata, and then pass to the receive level */
-	skb->dev = netdev;
+	skb->dev = net;
 	skb->ip_summed = CHECKSUM_UNNECESSARY;  /* don't check it */
 
 	/*
@@ -724,73 +601,75 @@ static int ipv4_finish_incoming_packet ( struct net_device *netdev,
 	 * about the sending machine.
 	 */
 	if (ether_type == ETH_P_ARP) {
-		struct ipv4_arp *arp1394;
+		struct rfc2734_arp *arp1394;
 		struct arphdr *arp;
 		unsigned char *arp_ptr;
 		u64 fifo_addr;
+		u64 peer_guid;
 		u8 max_rec;
 		u8 sspd;
 		u16 max_payload;
-		struct ipv4_node *node;
-		static const u16 ipv4_speed_to_max_payload[] = {
+		struct fwnet_peer *peer;
+		static const u16 fwnet_speed_to_max_payload[] = {
 			/* S100, S200, S400, S800, S1600, S3200 */
 			    512, 1024, 2048, 4096,  4096,  4096
 		};
 
-		/* fw_debug ( "ARP packet\n" ); */
-		arp1394 = (struct ipv4_arp *)skb->data;
+		arp1394 = (struct rfc2734_arp *)skb->data;
 		arp = (struct arphdr *)skb->data;
 		arp_ptr = (unsigned char *)(arp + 1);
-		fifo_addr = (u64)ntohs(arp1394->fifo_hi) << 32 |
- ntohl(arp1394->fifo_lo);
-		max_rec = priv->card->max_receive;
-		if ( arp1394->max_rec < max_rec )
+		fifo_addr = (u64)ntohs(arp1394->fifo_hi) << 32
+				| ntohl(arp1394->fifo_lo);
+		max_rec = dev->card->max_receive;
+		if (arp1394->max_rec < max_rec)
 			max_rec = arp1394->max_rec;
 		sspd = arp1394->sspd;
-		/*
-		 * Sanity check. MacOSX seems to be sending us 131 in this
-		 * field (atleast on my Panther G5). Not sure why.
-		 */
-		if (sspd > 5 ) {
-			fw_notify ( "sspd %x out of range\n", sspd );
+		/* Sanity check.  OS X 10.3 PPC reportedly sends 131. */
+		if (sspd > SCODE_3200) {
+			fw_notify("sspd %x out of range\n", sspd);
 			sspd = 0;
 		}
 
-		max_payload = min(ipv4_speed_to_max_payload[sspd],
- (u16)(1 << (max_rec + 1))) - IPV4_UNFRAG_HDR_SIZE;
+		max_payload = min(fwnet_speed_to_max_payload[sspd],
+			(u16)(1 << (max_rec + 1))) - RFC2374_UNFRAG_HDR_SIZE;
 
-		guid = be64_to_cpu(get_unaligned(&arp1394->s_uniq_id));
-		node = ipv4_node_find_by_guid(priv, guid);
-		if (!node) {
-			fw_notify ( "No node for ARP packet from %llx\n", guid );
+		peer_guid = get_unaligned_be64(&arp1394->s_uniq_id);
+		peer = fwnet_peer_find_by_guid(dev, peer_guid);
+		if (!peer) {
+			fw_notify("No peer for ARP packet from %016llx\n",
+				  (unsigned long long)peer_guid);
 			goto failed_proto;
 		}
-		if ( node->nodeid != source_node_id || node->generation != priv->card->generation ) {
-			fw_notify ( "Internal error: node->nodeid (%x) != soucre_node_id (%x) or node->generation (%x) != priv->card->generation(%x)\n",
- node->nodeid, source_node_id, node->generation, priv->card->generation );
-			node->nodeid = source_node_id;
-			node->generation = priv->card->generation;
+
+		/* FIXME don't use card->generation */
+		if (peer->node_id != source_node_id ||
+		    peer->generation != dev->card->generation) {
+			fw_notify("Internal error: peer->node_id (%x) != "
+				  "source_node_id (%x) or peer->generation (%x)"
+				  " != dev->card->generation(%x)\n",
+				  peer->node_id, source_node_id,
+				  peer->generation, dev->card->generation);
+			peer->node_id = source_node_id;
+			peer->generation = dev->card->generation;
 		}
 
 		/* FIXME: for debugging */
-		if ( sspd > SCODE_400 )
+		if (sspd > SCODE_400)
 			sspd = SCODE_400;
 		/* Update our speed/payload/fifo_offset table */
 		/*
 		 * FIXME: this does not handle cases where two high-speed endpoints must use a slower speed because of
 		 * a lower speed hub between them.  We need to look at the actual topology map here.
 		 */
-		fw_debug ( "Setting node %p fifo %llx (was %llx), max_payload %x (was %x), speed %x (was %x)\n",
- node, fifo_addr, node->fifo, max_payload, node->max_payload, sspd, node->xmt_speed );
-		node->fifo =	fifo_addr;
-		node->max_payload = max_payload;
+		peer->fifo = fifo_addr;
+		peer->max_payload = max_payload;
 		/*
 		 * Only allow speeds to go down from their initial value.
-		 * Otherwise a local node that can only do S400 or slower may
-		 * be told to transmit at S800 to a faster remote node.
+		 * Otherwise a local peer that can only do S400 or slower may
+		 * be told to transmit at S800 to a faster remote peer.
 		 */
-		if ( node->xmt_speed > sspd )
-			node->xmt_speed = sspd;
+		if (peer->xmt_speed > sspd)
+			peer->xmt_speed = sspd;
 
 		/*
 		 * Now that we're done with the 1394 specific stuff, we'll
@@ -805,248 +684,257 @@ static int ipv4_finish_incoming_packet ( struct net_device *netdev,
 		 */
 
 		arp->ar_hln = 8;
-		arp_ptr += arp->ar_hln;		/* skip over sender unique id */
-		*(u32 *)arp_ptr = arp1394->sip; /* move sender IP addr */
-		arp_ptr += arp->ar_pln;		/* skip over sender IP addr */
+		/* skip over sender unique id */
+		arp_ptr += arp->ar_hln;
+		/* move sender IP addr */
+		put_unaligned(arp1394->sip, (u32 *)arp_ptr);
+		/* skip over sender IP addr */
+		arp_ptr += arp->ar_pln;
 
 		if (arp->ar_op == htons(ARPOP_REQUEST))
 			memset(arp_ptr, 0, sizeof(u64));
 		else
-			memcpy(arp_ptr, netdev->dev_addr, sizeof(u64));
+			memcpy(arp_ptr, net->dev_addr, sizeof(u64));
 	}
 
 	/* Now add the ethernet header. */
-	guid = cpu_to_be64(priv->card->guid);
-	if (dev_hard_header(skb, netdev, ether_type, is_broadcast ? &broadcast_hw : &guid, NULL,
- skb->len) >= 0) {
-		struct ipv4_ether_hdr *eth;
+	guid = cpu_to_be64(dev->card->guid);
+	if (dev_hard_header(skb, net, ether_type,
+			   is_broadcast ? &broadcast_hw : &guid,
+			   NULL, skb->len) >= 0) {
+		struct fwnet_header *eth;
 		u16 *rawp;
 		__be16 protocol;
 
 		skb_reset_mac_header(skb);
 		skb_pull(skb, sizeof(*eth));
-		eth = ipv4_ether_hdr(skb);
+		eth = (struct fwnet_header *)skb_mac_header(skb);
 		if (*eth->h_dest & 1) {
-			if (memcmp(eth->h_dest, netdev->broadcast, netdev->addr_len) == 0) {
-				fw_debug ( "Broadcast\n" );
+			if (memcmp(eth->h_dest, net->broadcast,
+				   net->addr_len) == 0)
 				skb->pkt_type = PACKET_BROADCAST;
-			}
 #if 0
 			else
 				skb->pkt_type = PACKET_MULTICAST;
 #endif
 		} else {
-			if (memcmp(eth->h_dest, netdev->dev_addr, netdev->addr_len)) {
+			if (memcmp(eth->h_dest, net->dev_addr, net->addr_len)) {
 				u64 a1, a2;
 
-				memcpy ( &a1, eth->h_dest, sizeof(u64));
-				memcpy ( &a2, netdev->dev_addr, sizeof(u64));
-				fw_debug ( "Otherhost %llx %llx %x\n", a1, a2, netdev->addr_len );
+				memcpy(&a1, eth->h_dest, sizeof(u64));
+				memcpy(&a2, net->dev_addr, sizeof(u64));
 				skb->pkt_type = PACKET_OTHERHOST;
 			}
 		}
 		if (ntohs(eth->h_proto) >= 1536) {
-			fw_debug ( " proto %x %x\n", eth->h_proto, ntohs(eth->h_proto) );
 			protocol = eth->h_proto;
 		} else {
 			rawp = (u16 *)skb->data;
-			if (*rawp == 0xFFFF) {
-				fw_debug ( "proto 802_3\n" );
+			if (*rawp == 0xffff)
 				protocol = htons(ETH_P_802_3);
-			} else {
-				fw_debug ( "proto 802_2\n" );
+			else
 				protocol = htons(ETH_P_802_2);
-			}
 		}
 		skb->protocol = protocol;
 	}
 	status = netif_rx(skb);
-	if ( status == NET_RX_DROP) {
-		netdev->stats.rx_errors++;
-		netdev->stats.rx_dropped++;
+	if (status == NET_RX_DROP) {
+		net->stats.rx_errors++;
+		net->stats.rx_dropped++;
 	} else {
-		netdev->stats.rx_packets++;
-		netdev->stats.rx_bytes += skb->len;
+		net->stats.rx_packets++;
+		net->stats.rx_bytes += skb->len;
 	}
-	if (netif_queue_stopped(netdev))
-		netif_wake_queue(netdev);
+	if (netif_queue_stopped(net))
+		netif_wake_queue(net);
+
 	return 0;
 
  failed_proto:
-	netdev->stats.rx_errors++;
-	netdev->stats.rx_dropped++;
+	net->stats.rx_errors++;
+	net->stats.rx_dropped++;
+
 	dev_kfree_skb_any(skb);
-	if (netif_queue_stopped(netdev))
-		netif_wake_queue(netdev);
-	netdev->last_rx = jiffies;
+	if (netif_queue_stopped(net))
+		netif_wake_queue(net);
+
+	net->last_rx = jiffies;
+
 	return 0;
 }
 
-/* ------------------------------------------------------------------ */
-
-static int ipv4_incoming_packet ( struct ipv4_priv *priv, u32 *buf, int len, u16 source_node_id, bool is_broadcast ) {
+static int fwnet_incoming_packet(struct fwnet_device *dev, __be32 *buf, int len,
+				 u16 source_node_id, bool is_broadcast)
+{
 	struct sk_buff *skb;
-	struct net_device *netdev;
-	struct ipv4_hdr hdr;
+	struct net_device *net;
+	struct rfc2734_header hdr;
 	unsigned lf;
 	unsigned long flags;
-	struct ipv4_node *node;
-	struct ipv4_partial_datagram *pd;
+	struct fwnet_peer *peer;
+	struct fwnet_partial_datagram *pd;
 	int fg_off;
 	int dg_size;
 	u16 datagram_label;
 	int retval;
 	u16 ether_type;
 
-	fw_debug ( "ipv4_incoming_packet(%p, %p, %d, %x, %s)\n", priv, buf, len, source_node_id, is_broadcast ? "true" : "false" );
-	netdev = priv->card->netdev;
+	net = dev->card->netdev;
 
-	hdr.w0 = ntohl(buf[0]);
-	lf = ipv4_get_hdr_lf(&hdr);
-	if ( lf == IPV4_HDR_UNFRAG ) {
+	hdr.w0 = be32_to_cpu(buf[0]);
+	lf = fwnet_get_hdr_lf(&hdr);
+	if (lf == RFC2374_HDR_UNFRAG) {
 		/*
 		 * An unfragmented datagram has been received by the ieee1394
 		 * bus. Build an skbuff around it so we can pass it to the
 		 * high level network layer.
 		 */
-		ether_type = ipv4_get_hdr_ether_type(&hdr);
-		fw_debug ( "header w0 = %x, lf = %x, ether_type = %x\n", hdr.w0, lf, ether_type );
+		ether_type = fwnet_get_hdr_ether_type(&hdr);
 		buf++;
-		len -= IPV4_UNFRAG_HDR_SIZE;
+		len -= RFC2374_UNFRAG_HDR_SIZE;
 
-		skb = dev_alloc_skb(len + netdev->hard_header_len + 15);
+		skb = dev_alloc_skb(len + net->hard_header_len + 15);
 		if (unlikely(!skb)) {
-			fw_error ( "Out of memory for incoming packet\n");
-			netdev->stats.rx_dropped++;
+			fw_error("out of memory\n");
+			net->stats.rx_dropped++;
+
 			return -1;
 		}
-		skb_reserve(skb, (netdev->hard_header_len + 15) & ~15);
-		memcpy(skb_put(skb, len), buf, len );
-		return ipv4_finish_incoming_packet(netdev, skb, source_node_id, is_broadcast, ether_type );
+		skb_reserve(skb, (net->hard_header_len + 15) & ~15);
+		memcpy(skb_put(skb, len), buf, len);
+
+		return fwnet_finish_incoming_packet(net, skb, source_node_id,
+						    is_broadcast, ether_type);
 	}
 	/* A datagram fragment has been received, now the fun begins. */
 	hdr.w1 = ntohl(buf[1]);
-	buf +=2;
-	len -= IPV4_FRAG_HDR_SIZE;
-	if ( lf ==IPV4_HDR_FIRSTFRAG ) {
-		ether_type = ipv4_get_hdr_ether_type(&hdr);
+	buf += 2;
+	len -= RFC2374_FRAG_HDR_SIZE;
+	if (lf == RFC2374_HDR_FIRSTFRAG) {
+		ether_type = fwnet_get_hdr_ether_type(&hdr);
 		fg_off = 0;
 	} else {
-		fg_off = ipv4_get_hdr_fg_off(&hdr);
-		ether_type = 0; /* Shut up compiler! */
+		ether_type = 0;
+		fg_off = fwnet_get_hdr_fg_off(&hdr);
 	}
-	datagram_label = ipv4_get_hdr_dgl(&hdr);
-	dg_size = ipv4_get_hdr_dg_size(&hdr); /* ??? + 1 */
-	fw_debug ( "fragmented: %x.%x = lf %x, ether_type %x, fg_off %x, dgl %x, dg_size %x\n", hdr.w0, hdr.w1, lf, ether_type, fg_off, datagram_label, dg_size );
-	node = ipv4_node_find_by_nodeid ( priv, source_node_id);
-	spin_lock_irqsave(&node->pdg_lock, flags);
-	pd = ipv4_pd_find( node, datagram_label );
+	datagram_label = fwnet_get_hdr_dgl(&hdr);
+	dg_size = fwnet_get_hdr_dg_size(&hdr); /* ??? + 1 */
+	peer = fwnet_peer_find_by_node_id(dev, source_node_id);
+
+	spin_lock_irqsave(&peer->pdg_lock, flags);
+
+	pd = fwnet_pd_find(peer, datagram_label);
 	if (pd == NULL) {
-		while ( node->pdg_size >= ipv4_mpd ) {
+		while (peer->pdg_size >= FWNET_MAX_FRAGMENTS) {
 			/* remove the oldest */
-			ipv4_pd_delete ( list_first_entry(&node->pdg_list, struct ipv4_partial_datagram, pdg_list) );
-			node->pdg_size--;
+			fwnet_pd_delete(list_first_entry(&peer->pd_list,
+				struct fwnet_partial_datagram, pd_link));
+			peer->pdg_size--;
 		}
-		pd = ipv4_pd_new ( netdev, node, datagram_label, dg_size,
- buf, fg_off, len);
-		if ( pd == NULL) {
+		pd = fwnet_pd_new(net, peer, datagram_label,
+				  dg_size, buf, fg_off, len);
+		if (pd == NULL) {
 			retval = -ENOMEM;
 			goto bad_proto;
 		}
-		node->pdg_size++;
+		peer->pdg_size++;
 	} else {
-		if (ipv4_frag_overlap(pd, fg_off, len) || pd->datagram_size != dg_size) {
+		if (fwnet_frag_overlap(pd, fg_off, len) ||
+		    pd->datagram_size != dg_size) {
 			/*
 			 * Differing datagram sizes or overlapping fragments,
-			 * Either way the remote machine is playing silly buggers
-			 * with us: obliterate the old datagram and start a new one.
+			 * discard old datagram and start a new one.
 			 */
-			ipv4_pd_delete ( pd );
-			pd = ipv4_pd_new ( netdev, node, datagram_label,
- dg_size, buf, fg_off, len);
-			if ( pd == NULL ) {
+			fwnet_pd_delete(pd);
+			pd = fwnet_pd_new(net, peer, datagram_label,
+					  dg_size, buf, fg_off, len);
+			if (pd == NULL) {
 				retval = -ENOMEM;
-				node->pdg_size--;
+				peer->pdg_size--;
 				goto bad_proto;
 			}
 		} else {
-			bool worked;
-
-			worked = ipv4_pd_update ( node, pd,
- buf, fg_off, len );
-			if ( ! worked ) {
+			if (!fwnet_pd_update(peer, pd, buf, fg_off, len)) {
 				/*
 				 * Couldn't save off fragment anyway
 				 * so might as well obliterate the
 				 * datagram now.
 				 */
-				ipv4_pd_delete ( pd );
-				node->pdg_size--;
+				fwnet_pd_delete(pd);
+				peer->pdg_size--;
 				goto bad_proto;
 			}
 		}
 	} /* new datagram or add to existing one */
 
-	if ( lf == IPV4_HDR_FIRSTFRAG )
+	if (lf == RFC2374_HDR_FIRSTFRAG)
 		pd->ether_type = ether_type;
-	if ( ipv4_pd_is_complete ( pd ) ) {
+
+	if (fwnet_pd_is_complete(pd)) {
 		ether_type = pd->ether_type;
-		node->pdg_size--;
+		peer->pdg_size--;
 		skb = skb_get(pd->skb);
-		ipv4_pd_delete ( pd );
-		spin_unlock_irqrestore(&node->pdg_lock, flags);
-		return ipv4_finish_incoming_packet ( netdev, skb, source_node_id, false, ether_type );
+		fwnet_pd_delete(pd);
+
+		spin_unlock_irqrestore(&peer->pdg_lock, flags);
+
+		return fwnet_finish_incoming_packet(net, skb, source_node_id,
+						    false, ether_type);
 	}
 	/*
 	 * Datagram is not complete, we're done for the
 	 * moment.
 	 */
-	spin_unlock_irqrestore(&node->pdg_lock, flags);
+	spin_unlock_irqrestore(&peer->pdg_lock, flags);
+
 	return 0;
 
  bad_proto:
-	spin_unlock_irqrestore(&node->pdg_lock, flags);
-	if (netif_queue_stopped(netdev))
-		netif_wake_queue(netdev);
+	spin_unlock_irqrestore(&peer->pdg_lock, flags);
+
+	if (netif_queue_stopped(net))
+		netif_wake_queue(net);
+
 	return 0;
 }
 
-static void ipv4_receive_packet ( struct fw_card *card, struct fw_request *r,
- int tcode, int destination, int source, int generation, int speed,
- unsigned long long offset, void *payload, size_t length, void *callback_data ) {
-	struct ipv4_priv *priv;
+static void fwnet_receive_packet(struct fw_card *card, struct fw_request *r,
+		int tcode, int destination, int source, int generation,
+		int speed, unsigned long long offset, void *payload,
+		size_t length, void *callback_data)
+{
+	struct fwnet_device *dev;
 	int status;
 
-	fw_debug ( "ipv4_receive_packet(%p,%p,%x,%x,%x,%x,%x,%llx,%p,%lx,%p)\n",
- card, r, tcode, destination, source, generation, speed, offset, payload,
- (unsigned long)length, callback_data);
-	print_hex_dump ( KERN_DEBUG, "header: ", DUMP_PREFIX_OFFSET, 32, 1, payload, length, false );
-	priv = callback_data;
-	if (   tcode != TCODE_WRITE_BLOCK_REQUEST
-	    || destination != card->node_id
-	    || generation != card->generation
-	    || offset != priv->handler.offset ) {
+	dev = callback_data;
+	if (tcode != TCODE_WRITE_BLOCK_REQUEST
+	    || destination != card->node_id	/* <- FIXME */
+	    || generation != card->generation	/* <- FIXME */
+	    || offset != dev->handler.offset) {
 		fw_send_response(card, r, RCODE_CONFLICT_ERROR);
-		fw_debug("Conflict error card node_id=%x, card generation=%x, local offset %llx\n",
- card->node_id, card->generation, (unsigned long long)priv->handler.offset );
+
 		return;
 	}
-	status = ipv4_incoming_packet ( priv, payload, length, source, false );
-	if ( status != 0 ) {
-		fw_error ( "Incoming packet failure\n" );
-		fw_send_response ( card, r, RCODE_CONFLICT_ERROR );
+
+	status = fwnet_incoming_packet(dev, payload, length, source, false);
+	if (status != 0) {
+		fw_error("Incoming packet failure\n");
+		fw_send_response(card, r, RCODE_CONFLICT_ERROR);
+
 		return;
 	}
-	fw_send_response ( card, r, RCODE_COMPLETE );
+
+	fw_send_response(card, r, RCODE_COMPLETE);
 }
 
-static void ipv4_receive_broadcast(struct fw_iso_context *context, u32 cycle,
- size_t header_length, void *header, void *data) {
-	struct ipv4_priv *priv;
+static void fwnet_receive_broadcast(struct fw_iso_context *context,
+		u32 cycle, size_t header_length, void *header, void *data)
+{
+	struct fwnet_device *dev;
 	struct fw_iso_packet packet;
 	struct fw_card *card;
-	u16 *hdr_ptr;
-	u32 *buf_ptr;
+	__be16 *hdr_ptr;
+	__be32 *buf_ptr;
 	int retval;
 	u32 length;
 	u16 source_node_id;
@@ -1055,70 +943,68 @@ static void ipv4_receive_broadcast(struct fw_iso_context *context, u32 cycle,
 	unsigned long offset;
 	unsigned long flags;
 
-	fw_debug ( "ipv4_receive_broadcast ( context=%p, cycle=%x, header_length=%lx, header=%p, data=%p )\n", context, cycle, (unsigned long)header_length, header, data );
-	print_hex_dump ( KERN_DEBUG, "header: ", DUMP_PREFIX_OFFSET, 32, 1, header, header_length, false );
-	priv = data;
-	card = priv->card;
+	dev = data;
+	card = dev->card;
 	hdr_ptr = header;
-	length = ntohs(hdr_ptr[0]);
-	spin_lock_irqsave(&priv->lock,flags);
-	offset = priv->rcv_buffer_size * priv->broadcast_rcv_next_ptr;
-	buf_ptr = priv->broadcast_rcv_buffer_ptrs[priv->broadcast_rcv_next_ptr++];
-	if ( priv->broadcast_rcv_next_ptr == priv->num_broadcast_rcv_ptrs )
-		priv->broadcast_rcv_next_ptr = 0;
-	spin_unlock_irqrestore(&priv->lock,flags);
-	fw_debug ( "length %u at %p\n", length, buf_ptr );
-	print_hex_dump ( KERN_DEBUG, "buffer: ", DUMP_PREFIX_OFFSET, 32, 1, buf_ptr, length, false );
+	length = be16_to_cpup(hdr_ptr);
+
+	spin_lock_irqsave(&dev->lock, flags);
+
+	offset = dev->rcv_buffer_size * dev->broadcast_rcv_next_ptr;
+	buf_ptr = dev->broadcast_rcv_buffer_ptrs[dev->broadcast_rcv_next_ptr++];
+	if (dev->broadcast_rcv_next_ptr == dev->num_broadcast_rcv_ptrs)
+		dev->broadcast_rcv_next_ptr = 0;
+
+	spin_unlock_irqrestore(&dev->lock, flags);
 
 	specifier_id =    (be32_to_cpu(buf_ptr[0]) & 0xffff) << 8
 			| (be32_to_cpu(buf_ptr[1]) & 0xff000000) >> 24;
-	ver = be32_to_cpu(buf_ptr[1]) & 0xFFFFFF;
+	ver = be32_to_cpu(buf_ptr[1]) & 0xffffff;
 	source_node_id = be32_to_cpu(buf_ptr[0]) >> 16;
-	/* fw_debug ( "source %x SpecID %x ver %x\n", source_node_id, specifier_id, ver ); */
-	if ( specifier_id == IPV4_GASP_SPECIFIER_ID && ver == IPV4_GASP_VERSION ) {
+
+	if (specifier_id == IANA_SPECIFIER_ID && ver == RFC2734_SW_VERSION) {
 		buf_ptr += 2;
-		length -= IPV4_GASP_OVERHEAD;
-		ipv4_incoming_packet(priv, buf_ptr, length, source_node_id, true);
-	} else
-		fw_debug ( "Ignoring packet: not GASP\n" );
-	packet.payload_length = priv->rcv_buffer_size;
+		length -= IEEE1394_GASP_HDR_SIZE;
+		fwnet_incoming_packet(dev, buf_ptr, length,
+				      source_node_id, true);
+	}
+
+	packet.payload_length = dev->rcv_buffer_size;
 	packet.interrupt = 1;
 	packet.skip = 0;
 	packet.tag = 3;
 	packet.sy = 0;
-	packet.header_length = IPV4_GASP_OVERHEAD;
-	spin_lock_irqsave(&priv->lock,flags);
-	retval = fw_iso_context_queue ( priv->broadcast_rcv_context, &packet,
- &priv->broadcast_rcv_buffer, offset );
-	spin_unlock_irqrestore(&priv->lock,flags);
-	if ( retval < 0 )
-		fw_error ( "requeue failed\n" );
-}
+	packet.header_length = IEEE1394_GASP_HDR_SIZE;
+
+	spin_lock_irqsave(&dev->lock, flags);
 
-static void debug_ptask ( struct ipv4_packet_task *ptask ) {
-	static const char *tx_types[] = { "Unknown", "GASP", "Write" };
-
-	fw_debug ( "packet %p { hdr { w0 %x w1 %x }, skb %p, priv %p,"
- " tx_type %s, outstanding_pkts %d, max_payload %x, fifo %llx,"
- " speed %x, dest_node %x, generation %x }\n",
- ptask, ptask->hdr.w0, ptask->hdr.w1, ptask->skb, ptask->priv,
- ptask->tx_type > IPV4_WRREQ ? "Invalid" : tx_types[ptask->tx_type],
- ptask->outstanding_pkts,  ptask->max_payload,
- ptask->fifo_addr, ptask->speed, ptask->dest_node, ptask->generation );
-	print_hex_dump ( KERN_DEBUG, "packet :", DUMP_PREFIX_OFFSET, 32, 1,
- ptask->skb->data, ptask->skb->len, false );
+	retval = fw_iso_context_queue(dev->broadcast_rcv_context, &packet,
+				      &dev->broadcast_rcv_buffer, offset);
+
+	spin_unlock_irqrestore(&dev->lock, flags);
+
+	if (retval < 0)
+		fw_error("requeue failed\n");
 }
 
-static void ipv4_transmit_packet_done ( struct ipv4_packet_task *ptask ) {
-	struct ipv4_priv *priv;
+static struct kmem_cache *fwnet_packet_task_cache;
+
+static int fwnet_send_packet(struct fwnet_packet_task *ptask);
+
+static void fwnet_transmit_packet_done(struct fwnet_packet_task *ptask)
+{
+	struct fwnet_device *dev;
 	unsigned long flags;
 
-	priv = ptask->priv;
-	spin_lock_irqsave ( &priv->lock, flags );
-	list_del ( &ptask->packet_list );
-	spin_unlock_irqrestore ( &priv->lock, flags );
-	ptask->outstanding_pkts--;
-	if ( ptask->outstanding_pkts > 0 ) {
+	dev = ptask->dev;
+
+	spin_lock_irqsave(&dev->lock, flags);
+	list_del(&ptask->pt_link);
+	spin_unlock_irqrestore(&dev->lock, flags);
+
+	ptask->outstanding_pkts--; /* FIXME access inside lock */
+
+	if (ptask->outstanding_pkts > 0) {
 		u16 dg_size;
 		u16 fg_off;
 		u16 datagram_label;
@@ -1126,133 +1012,139 @@ static void ipv4_transmit_packet_done ( struct ipv4_packet_task *ptask ) {
 		struct sk_buff *skb;
 
 		/* Update the ptask to point to the next fragment and send it */
-		lf = ipv4_get_hdr_lf(&ptask->hdr);
+		lf = fwnet_get_hdr_lf(&ptask->hdr);
 		switch (lf) {
-		case IPV4_HDR_LASTFRAG:
-		case IPV4_HDR_UNFRAG:
+		case RFC2374_HDR_LASTFRAG:
+		case RFC2374_HDR_UNFRAG:
 		default:
-			fw_error ( "Outstanding packet %x lf %x, header %x,%x\n", ptask->outstanding_pkts, lf, ptask->hdr.w0, ptask->hdr.w1 );
+			fw_error("Outstanding packet %x lf %x, header %x,%x\n",
+				 ptask->outstanding_pkts, lf, ptask->hdr.w0,
+				 ptask->hdr.w1);
 			BUG();
 
-		case IPV4_HDR_FIRSTFRAG:
+		case RFC2374_HDR_FIRSTFRAG:
 			/* Set frag type here for future interior fragments */
-			dg_size = ipv4_get_hdr_dg_size(&ptask->hdr);
-			fg_off = ptask->max_payload - IPV4_FRAG_HDR_SIZE;
-			datagram_label = ipv4_get_hdr_dgl(&ptask->hdr);
+			dg_size = fwnet_get_hdr_dg_size(&ptask->hdr);
+			fg_off = ptask->max_payload - RFC2374_FRAG_HDR_SIZE;
+			datagram_label = fwnet_get_hdr_dgl(&ptask->hdr);
 			break;
 
-		case IPV4_HDR_INTFRAG:
-			dg_size = ipv4_get_hdr_dg_size(&ptask->hdr);
-			fg_off = ipv4_get_hdr_fg_off(&ptask->hdr) + ptask->max_payload - IPV4_FRAG_HDR_SIZE;
-			datagram_label = ipv4_get_hdr_dgl(&ptask->hdr);
+		case RFC2374_HDR_INTFRAG:
+			dg_size = fwnet_get_hdr_dg_size(&ptask->hdr);
+			fg_off = fwnet_get_hdr_fg_off(&ptask->hdr)
+				  + ptask->max_payload - RFC2374_FRAG_HDR_SIZE;
+			datagram_label = fwnet_get_hdr_dgl(&ptask->hdr);
 			break;
 		}
 		skb = ptask->skb;
-		skb_pull ( skb, ptask->max_payload );
-		if ( ptask->outstanding_pkts > 1 ) {
-			ipv4_make_sf_hdr ( &ptask->hdr,
-  IPV4_HDR_INTFRAG, dg_size, fg_off, datagram_label );
+		skb_pull(skb, ptask->max_payload);
+		if (ptask->outstanding_pkts > 1) {
+			fwnet_make_sf_hdr(&ptask->hdr, RFC2374_HDR_INTFRAG,
+					  dg_size, fg_off, datagram_label);
 		} else {
-			ipv4_make_sf_hdr ( &ptask->hdr,
-  IPV4_HDR_LASTFRAG, dg_size, fg_off, datagram_label );
-			ptask->max_payload = skb->len + IPV4_FRAG_HDR_SIZE;
-
+			fwnet_make_sf_hdr(&ptask->hdr, RFC2374_HDR_LASTFRAG,
+					  dg_size, fg_off, datagram_label);
+			ptask->max_payload = skb->len + RFC2374_FRAG_HDR_SIZE;
 		}
-		ipv4_send_packet ( ptask );
+		fwnet_send_packet(ptask);
 	} else {
-		dev_kfree_skb_any ( ptask->skb );
-		kmem_cache_free( ipv4_packet_task_cache, ptask );
+		dev_kfree_skb_any(ptask->skb);
+		kmem_cache_free(fwnet_packet_task_cache, ptask);
 	}
 }
 
-static void ipv4_write_complete ( struct fw_card *card, int rcode,
- void *payload, size_t length, void *data ) {
-	struct ipv4_packet_task *ptask;
+static void fwnet_write_complete(struct fw_card *card, int rcode,
+				 void *payload, size_t length, void *data)
+{
+	struct fwnet_packet_task *ptask;
 
 	ptask = data;
-	fw_debug ( "ipv4_write_complete ( %p, %x, %p, %lx, %p )\n",
- card, rcode, payload, (unsigned long)length, data );
-	debug_ptask ( ptask );
 
-	if ( rcode == RCODE_COMPLETE ) {
-		ipv4_transmit_packet_done ( ptask );
-	} else {
-		fw_error ( "ipv4_write_complete: failed: %x\n", rcode );
+	if (rcode == RCODE_COMPLETE)
+		fwnet_transmit_packet_done(ptask);
+	else
+		fw_error("fwnet_write_complete: failed: %x\n", rcode);
 		/* ??? error recovery */
-	}
 }
 
-static int ipv4_send_packet ( struct ipv4_packet_task *ptask ) {
-	struct ipv4_priv *priv;
+static int fwnet_send_packet(struct fwnet_packet_task *ptask)
+{
+	struct fwnet_device *dev;
 	unsigned tx_len;
-	struct ipv4_hdr *bufhdr;
+	struct rfc2734_header *bufhdr;
 	unsigned long flags;
-	struct net_device *netdev;
-#if 0 /* stefanr */
-	int retval;
-#endif
+	struct net_device *net;
 
-	fw_debug ( "ipv4_send_packet\n" );
-	debug_ptask ( ptask );
-	priv = ptask->priv;
+	dev = ptask->dev;
 	tx_len = ptask->max_payload;
-	switch (ipv4_get_hdr_lf(&ptask->hdr)) {
-	case IPV4_HDR_UNFRAG:
-		bufhdr = (struct ipv4_hdr *)skb_push(ptask->skb, IPV4_UNFRAG_HDR_SIZE);
-		bufhdr->w0 = htonl(ptask->hdr.w0);
+	switch (fwnet_get_hdr_lf(&ptask->hdr)) {
+	case RFC2374_HDR_UNFRAG:
+		bufhdr = (struct rfc2734_header *)
+				skb_push(ptask->skb, RFC2374_UNFRAG_HDR_SIZE);
+		put_unaligned_be32(ptask->hdr.w0, &bufhdr->w0);
 		break;
 
-	case IPV4_HDR_FIRSTFRAG:
-	case IPV4_HDR_INTFRAG:
-	case IPV4_HDR_LASTFRAG:
-		bufhdr = (struct ipv4_hdr *)skb_push(ptask->skb, IPV4_FRAG_HDR_SIZE);
-		bufhdr->w0 = htonl(ptask->hdr.w0);
-		bufhdr->w1 = htonl(ptask->hdr.w1);
+	case RFC2374_HDR_FIRSTFRAG:
+	case RFC2374_HDR_INTFRAG:
+	case RFC2374_HDR_LASTFRAG:
+		bufhdr = (struct rfc2734_header *)
+				skb_push(ptask->skb, RFC2374_FRAG_HDR_SIZE);
+		put_unaligned_be32(ptask->hdr.w0, &bufhdr->w0);
+		put_unaligned_be32(ptask->hdr.w1, &bufhdr->w1);
 		break;
 
 	default:
 		BUG();
 	}
-	if ( ptask->tx_type == IPV4_GASP ) {
-		u32 *packets;
+	if (ptask->dest_node == IEEE1394_ALL_NODES) {
+		u8 *p;
 		int generation;
-		int nodeid;
+		int node_id;
 
 		/* ptask->generation may not have been set yet */
-		generation = priv->card->generation;
+		generation = dev->card->generation;
 		smp_rmb();
-		nodeid = priv->card->node_id;
-		packets = (u32 *)skb_push(ptask->skb, sizeof(u32)*2);
-		packets[0] = htonl(nodeid << 16 | (IPV4_GASP_SPECIFIER_ID>>8));
-		packets[1] = htonl((IPV4_GASP_SPECIFIER_ID & 0xFF) << 24 | IPV4_GASP_VERSION);
-		fw_send_request ( priv->card, &ptask->transaction, TCODE_STREAM_DATA,
- fw_stream_packet_destination_id(3, BROADCAST_CHANNEL, 0),
- generation, SCODE_100, 0ULL, ptask->skb->data, tx_len + 8, ipv4_write_complete, ptask );
-		spin_lock_irqsave(&priv->lock,flags);
-		list_add_tail ( &ptask->packet_list, &priv->broadcasted_list );
-		spin_unlock_irqrestore(&priv->lock,flags);
-#if 0 /* stefanr */
-		return retval;
-#else
+		node_id = dev->card->node_id;
+
+		p = skb_push(ptask->skb, 8);
+		put_unaligned_be32(node_id << 16 | IANA_SPECIFIER_ID >> 8, p);
+		put_unaligned_be32((IANA_SPECIFIER_ID & 0xff) << 24
+						| RFC2734_SW_VERSION, &p[4]);
+
+		/* We should not transmit if broadcast_channel.valid == 0. */
+		fw_send_request(dev->card, &ptask->transaction,
+				TCODE_STREAM_DATA,
+				fw_stream_packet_destination_id(3,
+						IEEE1394_BROADCAST_CHANNEL, 0),
+				generation, SCODE_100, 0ULL, ptask->skb->data,
+				tx_len + 8, fwnet_write_complete, ptask);
+
+		/* FIXME race? */
+		spin_lock_irqsave(&dev->lock, flags);
+		list_add_tail(&ptask->pt_link, &dev->broadcasted_list);
+		spin_unlock_irqrestore(&dev->lock, flags);
+
 		return 0;
-#endif
 	}
-	fw_debug("send_request (%p, %p, WRITE_BLOCK, %x, %x, %x, %llx, %p, %d, %p, %p\n",
- priv->card, &ptask->transaction, ptask->dest_node, ptask->generation,
- ptask->speed, (unsigned long long)ptask->fifo_addr, ptask->skb->data, tx_len,
- ipv4_write_complete, ptask );
-	fw_send_request ( priv->card, &ptask->transaction,
- TCODE_WRITE_BLOCK_REQUEST, ptask->dest_node, ptask->generation, ptask->speed,
- ptask->fifo_addr, ptask->skb->data, tx_len, ipv4_write_complete, ptask );
-	spin_lock_irqsave(&priv->lock,flags);
-	list_add_tail ( &ptask->packet_list, &priv->sent_list );
-	spin_unlock_irqrestore(&priv->lock,flags);
-	netdev = priv->card->netdev;
-	netdev->trans_start = jiffies;
+
+	fw_send_request(dev->card, &ptask->transaction,
+			TCODE_WRITE_BLOCK_REQUEST, ptask->dest_node,
+			ptask->generation, ptask->speed, ptask->fifo_addr,
+			ptask->skb->data, tx_len, fwnet_write_complete, ptask);
+
+	/* FIXME race? */
+	spin_lock_irqsave(&dev->lock, flags);
+	list_add_tail(&ptask->pt_link, &dev->sent_list);
+	spin_unlock_irqrestore(&dev->lock, flags);
+
+	net = dev->card->netdev;
+	net->trans_start = jiffies;
+
 	return 0;
 }
 
-static int ipv4_broadcast_start ( struct ipv4_priv *priv ) {
+static int fwnet_broadcast_start(struct fwnet_device *dev)
+{
 	struct fw_iso_context *context;
 	int retval;
 	unsigned num_packets;
@@ -1260,150 +1152,151 @@ static int ipv4_broadcast_start ( struct ipv4_priv *priv ) {
 	struct fw_iso_packet packet;
 	unsigned long offset;
 	unsigned u;
-	/* unsigned transmit_speed; */
 
-#if 0 /* stefanr */
-	if ( priv->card->broadcast_channel != (BROADCAST_CHANNEL_VALID|BROADCAST_CHANNEL_INITIAL)) {
-		fw_notify ( "Invalid broadcast channel %x\n", priv->card->broadcast_channel );
-		/* FIXME: try again later? */
-		/* return -EINVAL; */
-	}
-#endif
-	if ( priv->local_fifo == INVALID_FIFO_ADDR ) {
-		struct fw_address_region region;
-
-		priv->handler.length = FIFO_SIZE;
-		priv->handler.address_callback = ipv4_receive_packet;
-		priv->handler.callback_data = priv;
-		/* FIXME: this is OHCI, but what about others? */
-		region.start = 0xffff00000000ULL;
-		region.end =   0xfffffffffffcULL;
-
-		retval = fw_core_add_address_handler ( &priv->handler, &region );
-		if ( retval < 0 )
+	if (dev->local_fifo == FWNET_NO_FIFO_ADDR) {
+		/* outside OHCI posted write area? */
+		static const struct fw_address_region region = {
+			.start = 0xffff00000000ULL,
+			.end   = CSR_REGISTER_BASE,
+		};
+
+		dev->handler.length = 4096;
+		dev->handler.address_callback = fwnet_receive_packet;
+		dev->handler.callback_data = dev;
+
+		retval = fw_core_add_address_handler(&dev->handler, &region);
+		if (retval < 0)
 			goto failed_initial;
-		priv->local_fifo = priv->handler.offset;
+
+		dev->local_fifo = dev->handler.offset;
 	}
 
-	/*
-	 * FIXME: rawiso limits us to PAGE_SIZE.  This only matters if we ever have
-	 * a machine with PAGE_SIZE < 4096
-	 */
-	max_receive = 1U << (priv->card->max_receive + 1);
-	num_packets = ( ipv4_iso_page_count * PAGE_SIZE ) / max_receive;
-	if ( ! priv->broadcast_rcv_context ) {
+	max_receive = 1U << (dev->card->max_receive + 1);
+	num_packets = (FWNET_ISO_PAGE_COUNT * PAGE_SIZE) / max_receive;
+
+	if (!dev->broadcast_rcv_context) {
 		void **ptrptr;
 
-		context = fw_iso_context_create ( priv->card,
- FW_ISO_CONTEXT_RECEIVE, BROADCAST_CHANNEL,
- priv->card->link_speed, 8, ipv4_receive_broadcast, priv );
+		context = fw_iso_context_create(dev->card,
+		    FW_ISO_CONTEXT_RECEIVE, IEEE1394_BROADCAST_CHANNEL,
+		    dev->card->link_speed, 8, fwnet_receive_broadcast, dev);
 		if (IS_ERR(context)) {
 			retval = PTR_ERR(context);
 			goto failed_context_create;
 		}
-		retval = fw_iso_buffer_init ( &priv->broadcast_rcv_buffer,
- priv->card, ipv4_iso_page_count, DMA_FROM_DEVICE );
-		if ( retval < 0 )
+
+		retval = fw_iso_buffer_init(&dev->broadcast_rcv_buffer,
+		    dev->card, FWNET_ISO_PAGE_COUNT, DMA_FROM_DEVICE);
+		if (retval < 0)
 			goto failed_buffer_init;
-		ptrptr = kmalloc ( sizeof(void*)*num_packets, GFP_KERNEL );
-		if ( ! ptrptr ) {
+
+		ptrptr = kmalloc(sizeof(void *) * num_packets, GFP_KERNEL);
+		if (!ptrptr) {
 			retval = -ENOMEM;
 			goto failed_ptrs_alloc;
 		}
-		priv->broadcast_rcv_buffer_ptrs = ptrptr;
-		for ( u = 0; u < ipv4_iso_page_count; u++ ) {
+
+		dev->broadcast_rcv_buffer_ptrs = ptrptr;
+		for (u = 0; u < FWNET_ISO_PAGE_COUNT; u++) {
 			void *ptr;
 			unsigned v;
 
-			ptr = kmap ( priv->broadcast_rcv_buffer.pages[u] );
-			for ( v = 0; v < num_packets / ipv4_iso_page_count; v++ )
-				*ptrptr++ = (void *)((char *)ptr + v * max_receive);
+			ptr = kmap(dev->broadcast_rcv_buffer.pages[u]);
+			for (v = 0; v < num_packets / FWNET_ISO_PAGE_COUNT; v++)
+				*ptrptr++ = (void *)
+						((char *)ptr + v * max_receive);
 		}
-		priv->broadcast_rcv_context = context;
-	} else
-		context = priv->broadcast_rcv_context;
+		dev->broadcast_rcv_context = context;
+	} else {
+		context = dev->broadcast_rcv_context;
+	}
 
 	packet.payload_length = max_receive;
 	packet.interrupt = 1;
 	packet.skip = 0;
 	packet.tag = 3;
 	packet.sy = 0;
-	packet.header_length = IPV4_GASP_OVERHEAD;
+	packet.header_length = IEEE1394_GASP_HDR_SIZE;
 	offset = 0;
-	for ( u = 0; u < num_packets; u++ ) {
-		retval = fw_iso_context_queue ( context, &packet,
- &priv->broadcast_rcv_buffer, offset );
-		if ( retval < 0 )
+
+	for (u = 0; u < num_packets; u++) {
+		retval = fw_iso_context_queue(context, &packet,
+				&dev->broadcast_rcv_buffer, offset);
+		if (retval < 0)
 			goto failed_rcv_queue;
+
 		offset += max_receive;
 	}
-	priv->num_broadcast_rcv_ptrs = num_packets;
-	priv->rcv_buffer_size = max_receive;
-	priv->broadcast_rcv_next_ptr = 0U;
-	retval = fw_iso_context_start ( context, -1, 0, FW_ISO_CONTEXT_MATCH_ALL_TAGS ); /* ??? sync */
-	if ( retval < 0 )
+	dev->num_broadcast_rcv_ptrs = num_packets;
+	dev->rcv_buffer_size = max_receive;
+	dev->broadcast_rcv_next_ptr = 0U;
+	retval = fw_iso_context_start(context, -1, 0,
+			FW_ISO_CONTEXT_MATCH_ALL_TAGS); /* ??? sync */
+	if (retval < 0)
 		goto failed_rcv_queue;
-	/* FIXME: adjust this when we know the max receive speeds of all other IP nodes on the bus. */
-	/* since we only xmt at S100 ??? */
-	priv->broadcast_xmt_max_payload = S100_BUFFER_SIZE - IPV4_GASP_OVERHEAD - IPV4_UNFRAG_HDR_SIZE;
-	priv->broadcast_state = IPV4_BROADCAST_RUNNING;
+
+	/* FIXME: adjust it according to the min. speed of all known peers? */
+	dev->broadcast_xmt_max_payload = IEEE1394_MAX_PAYLOAD_S100
+			- IEEE1394_GASP_HDR_SIZE - RFC2374_UNFRAG_HDR_SIZE;
+	dev->broadcast_state = FWNET_BROADCAST_RUNNING;
+
 	return 0;
 
  failed_rcv_queue:
-	kfree ( priv->broadcast_rcv_buffer_ptrs );
-	priv->broadcast_rcv_buffer_ptrs = NULL;
+	kfree(dev->broadcast_rcv_buffer_ptrs);
+	dev->broadcast_rcv_buffer_ptrs = NULL;
  failed_ptrs_alloc:
-	fw_iso_buffer_destroy ( &priv->broadcast_rcv_buffer, priv->card );
+	fw_iso_buffer_destroy(&dev->broadcast_rcv_buffer, dev->card);
  failed_buffer_init:
-	fw_iso_context_destroy ( context );
-	priv->broadcast_rcv_context = NULL;
+	fw_iso_context_destroy(context);
+	dev->broadcast_rcv_context = NULL;
  failed_context_create:
-	fw_core_remove_address_handler ( &priv->handler );
+	fw_core_remove_address_handler(&dev->handler);
  failed_initial:
-	priv->local_fifo = INVALID_FIFO_ADDR;
+	dev->local_fifo = FWNET_NO_FIFO_ADDR;
+
 	return retval;
 }
 
-/* This is called after an "ifup" */
-static int ipv4_open(struct net_device *dev) {
-	struct ipv4_priv *priv;
+/* ifup */
+static int fwnet_open(struct net_device *net)
+{
+	struct fwnet_device *dev = netdev_priv(net);
 	int ret;
 
-	priv = netdev_priv(dev);
-	if (priv->broadcast_state == IPV4_BROADCAST_ERROR) {
-		ret = ipv4_broadcast_start ( priv );
+	if (dev->broadcast_state == FWNET_BROADCAST_ERROR) {
+		ret = fwnet_broadcast_start(dev);
 		if (ret)
 			return ret;
 	}
-	netif_start_queue(dev);
+	netif_start_queue(net);
+
 	return 0;
 }
 
-/* This is called after an "ifdown" */
-static int ipv4_stop(struct net_device *netdev)
+/* ifdown */
+static int fwnet_stop(struct net_device *net)
 {
-	/* flush priv->wake */
-	/* flush_scheduled_work(); */
+	netif_stop_queue(net);
+
+	/* Deallocate iso context for use by other applications? */
 
-	netif_stop_queue(netdev);
 	return 0;
 }
 
-/* Transmit a packet (called by kernel) */
-static int ipv4_tx(struct sk_buff *skb, struct net_device *netdev)
+static int fwnet_tx(struct sk_buff *skb, struct net_device *net)
 {
-	struct ipv4_ether_hdr hdr_buf;
-	struct ipv4_priv *priv = netdev_priv(netdev);
+	struct fwnet_header hdr_buf;
+	struct fwnet_device *dev = netdev_priv(net);
 	__be16 proto;
 	u16 dest_node;
-	enum ipv4_tx_type tx_type;
 	unsigned max_payload;
 	u16 dg_size;
 	u16 *datagram_label_ptr;
-	struct ipv4_packet_task *ptask;
-	struct ipv4_node *node = NULL;
+	struct fwnet_packet_task *ptask;
+	struct fwnet_peer *peer = NULL;
 
-	ptask = kmem_cache_alloc(ipv4_packet_task_cache, GFP_ATOMIC);
+	ptask = kmem_cache_alloc(fwnet_packet_task_cache, GFP_ATOMIC);
 	if (ptask == NULL)
 		goto fail;
 
@@ -1412,7 +1305,7 @@ static int ipv4_tx(struct sk_buff *skb, struct net_device *netdev)
 		goto fail;
 
 	/*
-	 * Get rid of the fake ipv4 header, but first make a copy.
+	 * Make a copy of the driver-specific header.
 	 * We might need to rebuild the header on tx failure.
 	 */
 	memcpy(&hdr_buf, skb->data, sizeof(hdr_buf));
@@ -1425,110 +1318,95 @@ static int ipv4_tx(struct sk_buff *skb, struct net_device *netdev)
 	 * Set the transmission type for the packet.  ARP packets and IP
 	 * broadcast packets are sent via GASP.
 	 */
-	if (   memcmp(hdr_buf.h_dest, netdev->broadcast, IPV4_ALEN) == 0
+	if (memcmp(hdr_buf.h_dest, net->broadcast, FWNET_ALEN) == 0
 	    || proto == htons(ETH_P_ARP)
-	    || (   proto == htons(ETH_P_IP)
-		&& IN_MULTICAST(ntohl(ip_hdr(skb)->daddr)) ) ) {
-		/* fw_debug ( "transmitting arp or multicast packet\n" );*/
-		tx_type = IPV4_GASP;
-		dest_node = ALL_NODES;
-		max_payload = priv->broadcast_xmt_max_payload;
-		/* BUG_ON(max_payload < S100_BUFFER_SIZE - IPV4_GASP_OVERHEAD); */
-		datagram_label_ptr = &priv->broadcast_xmt_datagramlabel;
-		ptask->fifo_addr = INVALID_FIFO_ADDR;
-		ptask->generation = 0U;
-		ptask->dest_node = 0U;
-		ptask->speed = 0;
+	    || (proto == htons(ETH_P_IP)
+		&& IN_MULTICAST(ntohl(ip_hdr(skb)->daddr)))) {
+		max_payload = dev->broadcast_xmt_max_payload;
+		datagram_label_ptr = &dev->broadcast_xmt_datagramlabel;
+
+		ptask->fifo_addr = FWNET_NO_FIFO_ADDR;
+		ptask->generation = 0;
+		ptask->dest_node = IEEE1394_ALL_NODES;
+		ptask->speed = SCODE_100;
 	} else {
-		__be64 guid = get_unaligned((u64 *)hdr_buf.h_dest);
+		__be64 guid = get_unaligned((__be64 *)hdr_buf.h_dest);
 		u8 generation;
 
-		node = ipv4_node_find_by_guid(priv, be64_to_cpu(guid));
-		if (!node) {
-			fw_debug ( "Normal packet but no node\n" );
+		peer = fwnet_peer_find_by_guid(dev, be64_to_cpu(guid));
+		if (!peer)
 			goto fail;
-		}
 
-		if (node->fifo == INVALID_FIFO_ADDR) {
-			fw_debug ( "Normal packet but no fifo addr\n" );
+		if (peer->fifo == FWNET_NO_FIFO_ADDR)
 			goto fail;
-		}
 
-		/* fw_debug ( "Transmitting normal packet to %x at %llxx\n", node->nodeid, node->fifo ); */
-		generation = node->generation;
-		dest_node = node->nodeid;
-		max_payload = node->max_payload;
-		/* BUG_ON(max_payload < S100_BUFFER_SIZE - IPV4_FRAG_HDR_SIZE); */
+		generation = peer->generation;
+		smp_rmb();
+		dest_node = peer->node_id;
+
+		max_payload = peer->max_payload;
+		datagram_label_ptr = &peer->datagram_label;
 
-		datagram_label_ptr = &node->datagram_label;
-		tx_type = IPV4_WRREQ;
-		ptask->fifo_addr = node->fifo;
+		ptask->fifo_addr = peer->fifo;
 		ptask->generation = generation;
 		ptask->dest_node = dest_node;
-		ptask->speed = node->xmt_speed;
+		ptask->speed = peer->xmt_speed;
 	}
 
 	/* If this is an ARP packet, convert it */
 	if (proto == htons(ETH_P_ARP)) {
-		/* Convert a standard ARP packet to 1394 ARP. The first 8 bytes (the entire
-		 * arphdr) is the same format as the ip1394 header, so they overlap.  The rest
-		 * needs to be munged a bit.  The remainder of the arphdr is formatted based
-		 * on hwaddr len and ipaddr len.  We know what they'll be, so it's easy to
-		 * judge.
-		 *
-		 * Now that the EUI is used for the hardware address all we need to do to make
-		 * this work for 1394 is to insert 2 quadlets that contain max_rec size,
-		 * speed, and unicast FIFO address information between the sender_unique_id
-		 * and the IP addresses.
-		 */
 		struct arphdr *arp = (struct arphdr *)skb->data;
 		unsigned char *arp_ptr = (unsigned char *)(arp + 1);
-		struct ipv4_arp *arp1394 = (struct ipv4_arp *)skb->data;
-		u32 ipaddr;
-
-		ipaddr = *(u32*)(arp_ptr + IPV4_ALEN);
-		arp1394->hw_addr_len    = 16;
-		arp1394->max_rec        = priv->card->max_receive;
-		arp1394->sspd		= priv->card->link_speed;
-		arp1394->fifo_hi	= htons(priv->local_fifo >> 32);
-		arp1394->fifo_lo        = htonl(priv->local_fifo & 0xFFFFFFFF);
-		arp1394->sip		= ipaddr;
+		struct rfc2734_arp *arp1394 = (struct rfc2734_arp *)skb->data;
+		__be32 ipaddr;
+
+		ipaddr = get_unaligned((__be32 *)(arp_ptr + FWNET_ALEN));
+
+		arp1394->hw_addr_len    = RFC2734_HW_ADDR_LEN;
+		arp1394->max_rec        = dev->card->max_receive;
+		arp1394->sspd		= dev->card->link_speed;
+
+		put_unaligned_be16(dev->local_fifo >> 32,
+				   &arp1394->fifo_hi);
+		put_unaligned_be32(dev->local_fifo & 0xffffffff,
+				   &arp1394->fifo_lo);
+		put_unaligned(ipaddr, &arp1394->sip);
 	}
-	if ( ipv4_max_xmt && max_payload > ipv4_max_xmt )
-		max_payload = ipv4_max_xmt;
 
 	ptask->hdr.w0 = 0;
 	ptask->hdr.w1 = 0;
 	ptask->skb = skb;
-	ptask->priv = priv;
-        ptask->tx_type = tx_type;
+	ptask->dev = dev;
+
 	/* Does it all fit in one packet? */
-	if ( dg_size <= max_payload ) {
-		ipv4_make_uf_hdr(&ptask->hdr, be16_to_cpu(proto));
+	if (dg_size <= max_payload) {
+		fwnet_make_uf_hdr(&ptask->hdr, ntohs(proto));
 		ptask->outstanding_pkts = 1;
-		max_payload = dg_size + IPV4_UNFRAG_HDR_SIZE;
+		max_payload = dg_size + RFC2374_UNFRAG_HDR_SIZE;
 	} else {
 		u16 datagram_label;
 
-		max_payload -= IPV4_FRAG_OVERHEAD;
+		max_payload -= RFC2374_FRAG_OVERHEAD;
 		datagram_label = (*datagram_label_ptr)++;
-		ipv4_make_ff_hdr(&ptask->hdr, be16_to_cpu(proto), dg_size, datagram_label );
+		fwnet_make_ff_hdr(&ptask->hdr, ntohs(proto), dg_size,
+				  datagram_label);
 		ptask->outstanding_pkts = DIV_ROUND_UP(dg_size, max_payload);
-		max_payload += IPV4_FRAG_HDR_SIZE;
+		max_payload += RFC2374_FRAG_HDR_SIZE;
 	}
 	ptask->max_payload = max_payload;
-	ipv4_send_packet ( ptask );
+	fwnet_send_packet(ptask);
+
 	return NETDEV_TX_OK;
 
  fail:
 	if (ptask)
-		kmem_cache_free(ipv4_packet_task_cache, ptask);
+		kmem_cache_free(fwnet_packet_task_cache, ptask);
 
 	if (skb != NULL)
 		dev_kfree_skb(skb);
 
-	netdev->stats.tx_dropped++;
-	netdev->stats.tx_errors++;
+	net->stats.tx_dropped++;
+	net->stats.tx_errors++;
 
 	/*
 	 * FIXME: According to a patch from 2003-02-26, "returning non-zero
@@ -1540,280 +1418,291 @@ static int ipv4_tx(struct sk_buff *skb, struct net_device *netdev)
 	return NETDEV_TX_OK;
 }
 
-/*
- * FIXME: What to do if we timeout? I think a host reset is probably in order,
- * so that's what we do. Should we increment the stat counters too?
- */
-static void ipv4_tx_timeout(struct net_device *dev) {
-	struct ipv4_priv *priv;
+static void fwnet_tx_timeout(struct net_device *net)
+{
+	fw_error("%s: timeout\n", net->name);
 
-	priv = netdev_priv(dev);
-	fw_error ( "%s: Timeout, resetting host\n", dev->name );
-#if 0 /* stefanr */
-	fw_core_initiate_bus_reset ( priv->card, 1 );
-#endif
+	/* FIXME: What to do if we timeout? */
 }
 
-static int ipv4_change_mtu ( struct net_device *dev, int new_mtu ) {
-#if 0
-	int max_mtu;
-	struct ipv4_priv *priv;
-#endif
-
+static int fwnet_change_mtu(struct net_device *net, int new_mtu)
+{
 	if (new_mtu < 68)
 		return -EINVAL;
 
-#if 0
-	priv = netdev_priv(dev);
-	/* This is not actually true because we can fragment packets at the firewire layer */
-	max_mtu = (1 << (priv->card->max_receive + 1))
-		                - sizeof(struct ipv4_hdr) - IPV4_GASP_OVERHEAD;
-	if (new_mtu > max_mtu) {
-		fw_notify ( "%s: Local node constrains MTU to %d\n", dev->name, max_mtu);
-		return -ERANGE;
-	}
-#endif
-	dev->mtu = new_mtu;
+	net->mtu = new_mtu;
 	return 0;
 }
 
-static void ipv4_get_drvinfo(struct net_device *dev,
-struct ethtool_drvinfo *info) {
-	strcpy(info->driver, ipv4_driver_name);
-	strcpy(info->bus_info, "ieee1394"); /* FIXME provide more detail? */
+static void fwnet_get_drvinfo(struct net_device *net,
+			      struct ethtool_drvinfo *info)
+{
+	strcpy(info->driver, KBUILD_MODNAME);
+	strcpy(info->bus_info, "ieee1394");
 }
 
-static struct ethtool_ops ipv4_ethtool_ops = {
-	.get_drvinfo = ipv4_get_drvinfo,
+static struct ethtool_ops fwnet_ethtool_ops = {
+	.get_drvinfo = fwnet_get_drvinfo,
 };
 
-static const struct net_device_ops ipv4_netdev_ops = {
-	.ndo_open       = ipv4_open,
-	.ndo_stop	= ipv4_stop,
-	.ndo_start_xmit = ipv4_tx,
-	.ndo_tx_timeout = ipv4_tx_timeout,
-	.ndo_change_mtu = ipv4_change_mtu,
+static const struct net_device_ops fwnet_netdev_ops = {
+	.ndo_open       = fwnet_open,
+	.ndo_stop	= fwnet_stop,
+	.ndo_start_xmit = fwnet_tx,
+	.ndo_tx_timeout = fwnet_tx_timeout,
+	.ndo_change_mtu = fwnet_change_mtu,
 };
 
-static void ipv4_init_dev ( struct net_device *dev ) {
-	dev->header_ops		= &ipv4_header_ops;
-	dev->netdev_ops         = &ipv4_netdev_ops;
-	SET_ETHTOOL_OPS(dev, &ipv4_ethtool_ops);
-
-	dev->watchdog_timeo	= IPV4_TIMEOUT;
-	dev->flags		= IFF_BROADCAST | IFF_MULTICAST;
-	dev->features		= NETIF_F_HIGHDMA;
-	dev->addr_len		= IPV4_ALEN;
-	dev->hard_header_len	= IPV4_HLEN;
-	dev->type		= ARPHRD_IEEE1394;
-
-	/* FIXME: This value was copied from ether_setup(). Is it too much? */
-	dev->tx_queue_len	= 1000;
+static void fwnet_init_dev(struct net_device *net)
+{
+	net->header_ops		= &fwnet_header_ops;
+	net->netdev_ops		= &fwnet_netdev_ops;
+	net->watchdog_timeo	= 100000; /* ? FIXME */
+	net->flags		= IFF_BROADCAST | IFF_MULTICAST;
+	net->features		= NETIF_F_HIGHDMA;
+	net->addr_len		= FWNET_ALEN;
+	net->hard_header_len	= FWNET_HLEN;
+	net->type		= ARPHRD_IEEE1394;
+	net->tx_queue_len	= 1000; /* ? FIXME */
+	SET_ETHTOOL_OPS(net, &fwnet_ethtool_ops);
 }
 
-static int ipv4_probe ( struct device *dev ) {
-	struct fw_unit * unit;
-	struct fw_device *device;
-	struct fw_card *card;
-	struct net_device *netdev;
-	struct ipv4_priv *priv;
+/* FIXME create netdev upon first fw_unit of a card, not upon local fw_unit */
+static int fwnet_probe(struct device *_dev)
+{
+	struct fw_unit *unit = fw_unit(_dev);
+	struct fw_device *device = fw_parent_device(unit);
+	struct fw_card *card = device->card;
+	struct net_device *net;
+	struct fwnet_device *dev;
 	unsigned max_mtu;
-	__be64 guid;
-
-	fw_debug("ipv4 Probing\n" );
-	unit = fw_unit ( dev );
-	device = fw_device ( unit->device.parent );
-	card = device->card;
 
-	if ( ! device->is_local ) {
+	if (!device->is_local) {
 		int added;
 
-		fw_debug ( "Non-local, adding remote node entry\n" );
-		added = ipv4_node_new ( card, device );
+		added = fwnet_peer_new(card, device);
 		return added;
 	}
-	fw_debug("ipv4 Local: adding netdev\n" );
-	netdev = alloc_netdev ( sizeof(*priv), "firewire%d", ipv4_init_dev );
-	if ( netdev == NULL) {
-		fw_error( "Out of memory\n");
+	net = alloc_netdev(sizeof(*dev), "firewire%d", fwnet_init_dev);
+	if (net == NULL) {
+		fw_error("out of memory\n");
 		goto out;
 	}
 
-	SET_NETDEV_DEV(netdev, card->device);
-	priv = netdev_priv(netdev);
+	SET_NETDEV_DEV(net, card->device);
+	dev = netdev_priv(net);
 
-	spin_lock_init(&priv->lock);
-	priv->broadcast_state = IPV4_BROADCAST_ERROR;
-	priv->broadcast_rcv_context = NULL;
-	priv->broadcast_xmt_max_payload = 0;
-	priv->broadcast_xmt_datagramlabel = 0;
+	spin_lock_init(&dev->lock);
+	dev->broadcast_state = FWNET_BROADCAST_ERROR;
+	dev->broadcast_rcv_context = NULL;
+	dev->broadcast_xmt_max_payload = 0;
+	dev->broadcast_xmt_datagramlabel = 0;
 
-	priv->local_fifo = INVALID_FIFO_ADDR;
+	dev->local_fifo = FWNET_NO_FIFO_ADDR;
 
-	/* INIT_WORK(&priv->wake, ipv4_handle_queue);*/
-	INIT_LIST_HEAD(&priv->packet_list);
-	INIT_LIST_HEAD(&priv->broadcasted_list);
-	INIT_LIST_HEAD(&priv->sent_list );
+	/* INIT_WORK(&dev->wake, fwnet_handle_queue);*/
+	INIT_LIST_HEAD(&dev->packet_list);
+	INIT_LIST_HEAD(&dev->broadcasted_list);
+	INIT_LIST_HEAD(&dev->sent_list);
 
-	priv->card = card;
+	dev->card = card;
 
 	/*
 	 * Use the RFC 2734 default 1500 octets or the maximum payload
 	 * as initial MTU
 	 */
 	max_mtu = (1 << (card->max_receive + 1))
-		  - sizeof(struct ipv4_hdr) - IPV4_GASP_OVERHEAD;
-	netdev->mtu = min(1500U, max_mtu);
+		  - sizeof(struct rfc2734_header) - IEEE1394_GASP_HDR_SIZE;
+	net->mtu = min(1500U, max_mtu);
 
 	/* Set our hardware address while we're at it */
-	guid = cpu_to_be64(card->guid);
-	memcpy(netdev->dev_addr, &guid, sizeof(u64));
-	memset(netdev->broadcast, 0xff, sizeof(u64));
-	if ( register_netdev ( netdev ) ) {
-		fw_error ( "Cannot register the driver\n");
+	put_unaligned_be64(card->guid, net->dev_addr);
+	put_unaligned_be64(~0ULL, net->broadcast);
+	if (register_netdev(net)) {
+		fw_error("Cannot register the driver\n");
 		goto out;
 	}
 
-	fw_notify ( "%s: IPv4 over Firewire on device %016llx\n",
- netdev->name, card->guid );
-	card->netdev = netdev;
+	fw_notify("%s: IPv4 over FireWire on device %016llx\n",
+		  net->name, (unsigned long long)card->guid);
+	card->netdev = net;
 
-	return 0 /* ipv4_new_node ( ud ) */;
+	return 0;
  out:
-	if ( netdev )
-		free_netdev ( netdev );
+	if (net)
+		free_netdev(net);
+
 	return -ENOENT;
 }
 
+static int fwnet_remove(struct device *_dev)
+{
+	struct fw_unit *unit = fw_unit(_dev);
+	struct fw_device *device = fw_parent_device(unit);
+	struct fw_card *card = device->card;
+	struct net_device *net;
+	struct fwnet_device *dev;
+	struct fwnet_peer *peer;
+	struct fwnet_partial_datagram *pd, *pd_next;
+	struct fwnet_packet_task *ptask, *pt_next;
+
+	if (!device->is_local) {
+		fwnet_peer_delete(card, device);
 
-static int ipv4_remove ( struct device *dev ) {
-	struct fw_unit * unit;
-	struct fw_device *device;
-	struct fw_card *card;
-	struct net_device *netdev;
-	struct ipv4_priv *priv;
-	struct ipv4_node *node;
-	struct ipv4_partial_datagram *pd, *pd_next;
-	struct ipv4_packet_task *ptask, *pt_next;
-
-	fw_debug("ipv4 Removing\n" );
-	unit = fw_unit ( dev );
-	device = fw_device ( unit->device.parent );
-	card = device->card;
-
-	if ( ! device->is_local ) {
-		fw_debug ( "Node %x is non-local, removing remote node entry\n", device->node_id );
-		ipv4_node_delete ( card, device );
 		return 0;
 	}
-	netdev = card->netdev;
-	if ( netdev ) {
-		fw_debug ( "Node %x is local: deleting netdev\n", device->node_id );
-		priv = netdev_priv ( netdev );
-		unregister_netdev ( netdev );
-		fw_debug ( "unregistered\n" );
-		if ( priv->local_fifo != INVALID_FIFO_ADDR )
-			fw_core_remove_address_handler ( &priv->handler );
-		fw_debug ( "address handler gone\n" );
-		if ( priv->broadcast_rcv_context ) {
-			fw_iso_context_stop ( priv->broadcast_rcv_context );
-			fw_iso_buffer_destroy ( &priv->broadcast_rcv_buffer, priv->card );
-			fw_iso_context_destroy ( priv->broadcast_rcv_context );
-			fw_debug ( "rcv stopped\n" );
+
+	net = card->netdev;
+	if (net) {
+		dev = netdev_priv(net);
+		unregister_netdev(net);
+
+		if (dev->local_fifo != FWNET_NO_FIFO_ADDR)
+			fw_core_remove_address_handler(&dev->handler);
+		if (dev->broadcast_rcv_context) {
+			fw_iso_context_stop(dev->broadcast_rcv_context);
+			fw_iso_buffer_destroy(&dev->broadcast_rcv_buffer,
+					      dev->card);
+			fw_iso_context_destroy(dev->broadcast_rcv_context);
 		}
-		list_for_each_entry_safe( ptask, pt_next, &priv->packet_list, packet_list ) {
-			dev_kfree_skb_any ( ptask->skb );
-			kmem_cache_free( ipv4_packet_task_cache, ptask );
+		list_for_each_entry_safe(ptask, pt_next,
+					 &dev->packet_list, pt_link) {
+			dev_kfree_skb_any(ptask->skb);
+			kmem_cache_free(fwnet_packet_task_cache, ptask);
 		}
-		list_for_each_entry_safe( ptask, pt_next, &priv->broadcasted_list, packet_list ) {
-			dev_kfree_skb_any ( ptask->skb );
-			kmem_cache_free( ipv4_packet_task_cache, ptask );
+		list_for_each_entry_safe(ptask, pt_next,
+					 &dev->broadcasted_list, pt_link) {
+			dev_kfree_skb_any(ptask->skb);
+			kmem_cache_free(fwnet_packet_task_cache, ptask);
 		}
-		list_for_each_entry_safe( ptask, pt_next, &priv->sent_list, packet_list ) {
-			dev_kfree_skb_any ( ptask->skb );
-			kmem_cache_free( ipv4_packet_task_cache, ptask );
+		list_for_each_entry_safe(ptask, pt_next,
+					 &dev->sent_list, pt_link) {
+			dev_kfree_skb_any(ptask->skb);
+			kmem_cache_free(fwnet_packet_task_cache, ptask);
 		}
-		fw_debug ( "lists emptied\n" );
-		list_for_each_entry( node, &card->ipv4_nodes, ipv4_nodes ) {
-			if ( node->pdg_size ) {
-				list_for_each_entry_safe( pd, pd_next, &node->pdg_list, pdg_list )
-					ipv4_pd_delete ( pd );
-				node->pdg_size = 0;
+		list_for_each_entry(peer, &card->peer_list, peer_link) {
+			if (peer->pdg_size) {
+				list_for_each_entry_safe(pd, pd_next,
+						&peer->pd_list, pd_link)
+					fwnet_pd_delete(pd);
+				peer->pdg_size = 0;
 			}
-			node->fifo = INVALID_FIFO_ADDR;
+			peer->fifo = FWNET_NO_FIFO_ADDR;
 		}
-		fw_debug ( "nodes cleaned up\n" );
-		free_netdev ( netdev );
+		free_netdev(net);
 		card->netdev = NULL;
-		fw_debug ( "done\n" );
 	}
+
 	return 0;
 }
 
-static void ipv4_update ( struct fw_unit *unit ) {
-	struct fw_device *device;
-	struct fw_card *card;
+/*
+ * FIXME abort partially sent fragmented datagrams,
+ * discard partially received fragmented datagrams
+ */
+static void fwnet_update(struct fw_unit *unit)
+{
+	struct fw_device *device = fw_parent_device(unit);
+	struct net_device *net = device->card->netdev;
+	struct fwnet_device *dev;
+	struct fwnet_peer *peer;
+	u64 guid;
 
-	fw_debug ( "ipv4_update unit %p\n", unit );
-	device = fw_device ( unit->device.parent );
-	card = device->card;
-	if ( ! device->is_local ) {
-		struct ipv4_node *node;
-		u64 guid;
-		struct net_device *netdev;
-		struct ipv4_priv *priv;
-
-		netdev = card->netdev;
-		if ( netdev ) {
-			priv = netdev_priv ( netdev );
-			guid = (u64)device->config_rom[3] << 32 | device->config_rom[4];
-			node = ipv4_node_find_by_guid ( priv, guid );
-			if ( ! node ) {
-				fw_error ( "ipv4_update: no node for device %llx\n", guid );
-				return;
-			}
-			fw_debug ( "Non-local, updating remote node entry for guid %llx old generation %x, old nodeid %x\n", guid, node->generation, node->nodeid );
-			node->generation = device->generation;
-			rmb();
-			node->nodeid = device->node_id;
-			fw_debug ( "New generation %x, new nodeid %x\n", node->generation, node->nodeid );
-		} else
-			fw_error ( "nonlocal, but no netdev?  How can that be?\n" );
-	} else {
-		/* FIXME: What do we need to do on bus reset? */
-		fw_debug ( "Local, doing nothing\n" );
+	if (net && !device->is_local) {
+		dev = netdev_priv(net);
+		guid = (u64)device->config_rom[3] << 32 | device->config_rom[4];
+		peer = fwnet_peer_find_by_guid(dev, guid);
+		if (!peer) {
+			fw_error("fwnet_update: no peer for device %016llx\n",
+				 (unsigned long long)guid);
+			return;
+		}
+		peer->generation = device->generation;
+		rmb();
+		peer->node_id = device->node_id;
 	}
 }
 
-static struct fw_driver ipv4_driver = {
+static const struct ieee1394_device_id fwnet_id_table[] = {
+	{
+		.match_flags  = IEEE1394_MATCH_SPECIFIER_ID |
+				IEEE1394_MATCH_VERSION,
+		.specifier_id = IANA_SPECIFIER_ID,
+		.version      = RFC2734_SW_VERSION,
+	},
+	{ }
+};
+
+static struct fw_driver fwnet_driver = {
 	.driver = {
-		.owner = THIS_MODULE,
-		.name = ipv4_driver_name,
-		.bus = &fw_bus_type,
-		.probe = ipv4_probe,
-		.remove = ipv4_remove,
+		.owner  = THIS_MODULE,
+		.name   = "net",
+		.bus    = &fw_bus_type,
+		.probe  = fwnet_probe,
+		.remove = fwnet_remove,
 	},
-	.update = ipv4_update,
-	.id_table = ipv4_id_table,
+	.update   = fwnet_update,
+	.id_table = fwnet_id_table,
+};
+
+static const u32 rfc2374_unit_directory_data[] = {
+	0x00040000,	/* directory_length		*/
+	0x1200005e,	/* unit_specifier_id: IANA	*/
+	0x81000003,	/* textual descriptor offset	*/
+	0x13000001,	/* unit_sw_version: RFC 2734	*/
+	0x81000005,	/* textual descriptor offset	*/
+	0x00030000,	/* descriptor_length		*/
+	0x00000000,	/* text				*/
+	0x00000000,	/* minimal ASCII, en		*/
+	0x49414e41,	/* I A N A			*/
+	0x00030000,	/* descriptor_length		*/
+	0x00000000,	/* text				*/
+	0x00000000,	/* minimal ASCII, en		*/
+	0x49507634,	/* I P v 4			*/
+};
+
+static struct fw_descriptor rfc2374_unit_directory = {
+	.length = ARRAY_SIZE(rfc2374_unit_directory_data),
+	.key    = (CSR_DIRECTORY | CSR_UNIT) << 24,
+	.data   = rfc2374_unit_directory_data
 };
 
-static int __init ipv4_init ( void ) {
-	int added;
+static int __init fwnet_init(void)
+{
+	int err;
+
+	err = fw_core_add_descriptor(&rfc2374_unit_directory);
+	if (err)
+		return err;
 
-	added = fw_core_add_descriptor ( &ipv4_unit_directory );
-	if ( added < 0 )
-		fw_error ( "Failed to add descriptor" );
-	ipv4_packet_task_cache = kmem_cache_create("packet_task",
- sizeof(struct ipv4_packet_task), 0, 0, NULL);
-	fw_debug("Adding ipv4 module\n" );
-	return driver_register ( &ipv4_driver.driver );
+	fwnet_packet_task_cache = kmem_cache_create("packet_task",
+			sizeof(struct fwnet_packet_task), 0, 0, NULL);
+	if (!fwnet_packet_task_cache) {
+		err = -ENOMEM;
+		goto out;
+	}
+
+	err = driver_register(&fwnet_driver.driver);
+	if (!err)
+		return 0;
+
+	kmem_cache_destroy(fwnet_packet_task_cache);
+out:
+	fw_core_remove_descriptor(&rfc2374_unit_directory);
+
+	return err;
 }
+module_init(fwnet_init);
 
-static void __exit ipv4_cleanup ( void ) {
-	fw_core_remove_descriptor ( &ipv4_unit_directory );
-	fw_debug("Removing ipv4 module\n" );
-	driver_unregister ( &ipv4_driver.driver );
+static void __exit fwnet_cleanup(void)
+{
+	driver_unregister(&fwnet_driver.driver);
+	kmem_cache_destroy(fwnet_packet_task_cache);
+	fw_core_remove_descriptor(&rfc2374_unit_directory);
 }
+module_exit(fwnet_cleanup);
 
-module_init(ipv4_init);
-module_exit(ipv4_cleanup);
+MODULE_AUTHOR("Jay Fenlason <fenlason@redhat.com>");
+MODULE_DESCRIPTION("IPv4 over IEEE1394 as per RFC 2734");
+MODULE_LICENSE("GPL");
+MODULE_DEVICE_TABLE(ieee1394, fwnet_id_table);

commit b9530fd6c3f057bda258c8e2631ad1a25959f4a2
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sun Jun 7 22:57:53 2009 +0200

    firewire: net: add Kconfig item, rename driver
    
    The driver is now called firewire-net.  It might implement the transport
    of other networking protocols in the future, notably IPv6 per RFC 3146.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
new file mode 100644
index 000000000000..15353886bd80
--- /dev/null
+++ b/drivers/firewire/net.c
@@ -0,0 +1,1819 @@
+/*
+ * IPv4 over IEEE 1394, per RFC 2734
+ *
+ * Copyright (C) 2009 Jay Fenlason <fenlason@redhat.com>
+ *
+ * based on eth1394 by Ben Collins et al
+ */
+
+#include <linux/device.h>
+#include <linux/ethtool.h>
+#include <linux/firewire.h>
+#include <linux/firewire-constants.h>
+#include <linux/highmem.h>
+#include <linux/in.h>
+#include <linux/ip.h>
+#include <linux/mod_devicetable.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/netdevice.h>
+#include <linux/skbuff.h>
+
+#include <asm/unaligned.h>
+#include <net/arp.h>
+
+/* Things to potentially make runtime cofigurable */
+/* must be at least as large as our maximum receive size */
+#define FIFO_SIZE 4096
+/* Network timeout in glibbles */
+#define IPV4_TIMEOUT       100000
+
+/* Runitme configurable paramaters */
+static int ipv4_mpd = 25;
+static int ipv4_max_xmt = 0;
+/* 16k for receiving arp and broadcast packets.  Enough? */
+static int ipv4_iso_page_count = 4;
+
+MODULE_AUTHOR("Jay Fenlason (fenlason@redhat.com)");
+MODULE_DESCRIPTION("Firewire IPv4 Driver (IPv4-over-IEEE1394 as per RFC 2734)");
+MODULE_LICENSE("GPL");
+MODULE_DEVICE_TABLE(ieee1394, ipv4_id_table);
+module_param_named(max_partial_datagrams, ipv4_mpd, int, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(max_partial_datagrams, "Maximum number of received"
+ " incomplete fragmented datagrams (default = 25).");
+
+/* Max xmt is useful for forcing fragmentation, which makes testing easier. */
+module_param_named(max_transmit, ipv4_max_xmt, int, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(max_transmit, "Maximum datagram size to transmit"
+ " (larger datagrams will be fragmented) (default = 0 (use hardware defaults).");
+
+/* iso page count controls how many pages will be used for receiving broadcast packets. */
+module_param_named(iso_pages, ipv4_iso_page_count, int, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(iso_pages, "Number of pages to use for receiving broadcast packets"
+ " (default = 4).");
+
+/* uncomment this line to do debugging */
+#define fw_debug(s, args...) printk(KERN_DEBUG KBUILD_MODNAME ": " s, ## args)
+
+/* comment out these lines to do debugging. */
+/* #undef fw_debug */
+/* #define fw_debug(s...) */
+/* #define print_hex_dump(l...) */
+
+/* Define a fake hardware header format for the networking core.  Note that
+ * header size cannot exceed 16 bytes as that is the size of the header cache.
+ * Also, we do not need the source address in the header so we omit it and
+ * keep the header to under 16 bytes */
+#define IPV4_ALEN (8)
+/* This must equal sizeof(struct ipv4_ether_hdr) */
+#define IPV4_HLEN (10)
+
+/* FIXME: what's a good size for this? */
+#define INVALID_FIFO_ADDR (u64)~0ULL
+
+/* Things specified by standards */
+#define BROADCAST_CHANNEL 31
+
+#define S100_BUFFER_SIZE 512
+#define MAX_BUFFER_SIZE 4096
+
+#define IPV4_GASP_SPECIFIER_ID	0x00005EU
+#define IPV4_GASP_VERSION	0x00000001U
+
+#define IPV4_GASP_OVERHEAD (2 * sizeof(u32)) /* for GASP header */
+
+#define IPV4_UNFRAG_HDR_SIZE	sizeof(u32)
+#define IPV4_FRAG_HDR_SIZE	(2 * sizeof(u32))
+#define IPV4_FRAG_OVERHEAD	sizeof(u32)
+
+#define ALL_NODES (0xffc0 | 0x003f)
+
+#define IPV4_HDR_UNFRAG		0	/* unfragmented		*/
+#define IPV4_HDR_FIRSTFRAG	1	/* first fragment	*/
+#define IPV4_HDR_LASTFRAG	2	/* last fragment	*/
+#define IPV4_HDR_INTFRAG	3	/* interior fragment	*/
+
+/* Our arp packet (ARPHRD_IEEE1394) */
+/* FIXME: note that this is probably bogus on weird-endian machines */
+struct ipv4_arp {
+	u16 hw_type;		/* 0x0018	*/
+	u16 proto_type;		/* 0x0806       */
+	u8 hw_addr_len;		/* 16		*/
+	u8 ip_addr_len;         /* 4		*/
+	u16 opcode;	        /* ARP Opcode	*/
+	/* Above is exactly the same format as struct arphdr */
+
+	u64 s_uniq_id;		/* Sender's 64bit EUI			*/
+	u8 max_rec;             /* Sender's max packet size		*/
+	u8 sspd;		/* Sender's max speed			*/
+	u16 fifo_hi;            /* hi 16bits of sender's FIFO addr	*/
+	u32 fifo_lo;            /* lo 32bits of sender's FIFO addr	*/
+	u32 sip;		/* Sender's IP Address			*/
+	u32 tip;		/* IP Address of requested hw addr	*/
+} __attribute__((packed));
+
+struct ipv4_ether_hdr {
+	unsigned char	h_dest[IPV4_ALEN];	/* destination address */
+	unsigned short  h_proto;                /* packet type ID field */
+}  __attribute__((packed));
+
+static inline struct ipv4_ether_hdr *ipv4_ether_hdr(const struct sk_buff *skb)
+{
+	return (struct ipv4_ether_hdr *)skb_mac_header(skb);
+}
+
+enum ipv4_tx_type {
+	IPV4_UNKNOWN = 0,
+	IPV4_GASP = 1,
+	IPV4_WRREQ = 2,
+};
+
+enum ipv4_broadcast_state {
+	IPV4_BROADCAST_ERROR,
+	IPV4_BROADCAST_RUNNING,
+	IPV4_BROADCAST_STOPPED,
+};
+
+#define ipv4_get_hdr_lf(h)		(((h)->w0&0xC0000000)>>30)
+#define ipv4_get_hdr_ether_type(h)	(((h)->w0&0x0000FFFF)    )
+#define ipv4_get_hdr_dg_size(h)		(((h)->w0&0x0FFF0000)>>16)
+#define ipv4_get_hdr_fg_off(h)		(((h)->w0&0x00000FFF)    )
+#define ipv4_get_hdr_dgl(h)		(((h)->w1&0xFFFF0000)>>16)
+
+#define ipv4_set_hdr_lf(lf)		(( lf)<<30)
+#define ipv4_set_hdr_ether_type(et)	(( et)    )
+#define ipv4_set_hdr_dg_size(dgs)	((dgs)<<16)
+#define ipv4_set_hdr_fg_off(fgo)	((fgo)    )
+
+#define ipv4_set_hdr_dgl(dgl)		((dgl)<<16)
+
+struct ipv4_hdr {
+	u32 w0;
+	u32 w1;
+};
+
+static inline void ipv4_make_uf_hdr( struct ipv4_hdr *hdr, unsigned ether_type) {
+	hdr->w0 = ipv4_set_hdr_lf(IPV4_HDR_UNFRAG)
+		   |ipv4_set_hdr_ether_type(ether_type);
+	fw_debug ( "Setting unfragmented header %p to %x\n", hdr, hdr->w0 );
+}
+
+static inline void ipv4_make_ff_hdr ( struct ipv4_hdr *hdr, unsigned ether_type, unsigned dg_size, unsigned dgl ) {
+	hdr->w0 = ipv4_set_hdr_lf(IPV4_HDR_FIRSTFRAG)
+		   |ipv4_set_hdr_dg_size(dg_size)
+		   |ipv4_set_hdr_ether_type(ether_type);
+	hdr->w1 = ipv4_set_hdr_dgl(dgl);
+	fw_debug ( "Setting fragmented header %p to first_frag %x,%x (et %x, dgs %x, dgl %x)\n", hdr, hdr->w0, hdr->w1,
+ ether_type, dg_size, dgl );
+}
+
+static inline void ipv4_make_sf_hdr ( struct ipv4_hdr *hdr, unsigned lf, unsigned dg_size, unsigned fg_off, unsigned dgl) {
+	hdr->w0 = ipv4_set_hdr_lf(lf)
+		 |ipv4_set_hdr_dg_size(dg_size)
+		 |ipv4_set_hdr_fg_off(fg_off);
+	hdr->w1 = ipv4_set_hdr_dgl(dgl);
+	fw_debug ( "Setting fragmented header %p to %x,%x (lf %x, dgs %x, fo %x dgl %x)\n",
+ hdr, hdr->w0, hdr->w1,
+ lf, dg_size, fg_off, dgl );
+}
+
+/* End of IP1394 headers */
+
+/* Fragment types */
+#define ETH1394_HDR_LF_UF	0	/* unfragmented		*/
+#define ETH1394_HDR_LF_FF	1	/* first fragment	*/
+#define ETH1394_HDR_LF_LF	2	/* last fragment	*/
+#define ETH1394_HDR_LF_IF	3	/* interior fragment	*/
+
+#define IP1394_HW_ADDR_LEN	16	/* As per RFC		*/
+
+/* This list keeps track of what parts of the datagram have been filled in */
+struct ipv4_fragment_info {
+        struct list_head fragment_info;
+	u16 offset;
+	u16 len;
+};
+
+struct ipv4_partial_datagram {
+	struct list_head pdg_list;
+	struct list_head fragment_info;
+	struct sk_buff *skb;
+	/* FIXME Why not use skb->data? */
+	char *pbuf;
+	u16 datagram_label;
+	u16 ether_type;
+	u16 datagram_size;
+};
+
+/*
+ * We keep one of these for each IPv4 capable device attached to a fw_card.
+ * The list of them is stored in the fw_card structure rather than in the
+ * ipv4_priv because the remote IPv4 nodes may be probed before the card is,
+ * so we need a place to store them before the ipv4_priv structure is
+ * allocated.
+ */
+struct ipv4_node {
+	struct list_head ipv4_nodes;
+	/* guid of the remote node */
+	u64 guid;
+	/* FIFO address to transmit datagrams to, or INVALID_FIFO_ADDR */
+	u64 fifo;
+
+	spinlock_t pdg_lock;	/* partial datagram lock		*/
+	/* List of partial datagrams received from this node */
+	struct list_head pdg_list;
+	/* Number of entries in pdg_list at the moment */
+	unsigned pdg_size;
+
+	/* max payload to transmit to this remote node */
+	/* This already includes the IPV4_FRAG_HDR_SIZE overhead */
+	u16 max_payload;
+	/* outgoing datagram label */
+	u16 datagram_label;
+	/* Current node_id of the remote node */
+	u16 nodeid;
+	/* current generation of the remote node */
+	u8 generation;
+	/* max speed that this node can receive at */
+	u8 xmt_speed;
+};
+
+struct ipv4_priv {
+	spinlock_t lock;
+
+	enum ipv4_broadcast_state broadcast_state;
+	struct fw_iso_context *broadcast_rcv_context;
+	struct fw_iso_buffer broadcast_rcv_buffer;
+	void **broadcast_rcv_buffer_ptrs;
+	unsigned broadcast_rcv_next_ptr;
+	unsigned num_broadcast_rcv_ptrs;
+	unsigned rcv_buffer_size;
+	/*
+	 * This value is the maximum unfragmented datagram size that can be
+	 * sent by the hardware.  It already has the GASP overhead and the
+	 * unfragmented datagram header overhead calculated into it.
+	 */
+	unsigned broadcast_xmt_max_payload;
+	u16 broadcast_xmt_datagramlabel;
+
+	/*
+	 * The csr address that remote nodes must send datagrams to for us to
+	 * receive them.
+	 */
+	struct fw_address_handler handler;
+	u64 local_fifo;
+
+	/* Wake up to xmt	 */
+        /* struct work_struct wake;*/
+	/* List of packets to be sent */
+	struct list_head packet_list;
+	/*
+	 * List of packets that were broadcasted.  When we get an ISO interrupt
+	 * one of them has been sent
+	 */
+	struct list_head broadcasted_list;
+	/* List of packets that have been sent but not yet acked */
+	struct list_head sent_list;
+
+	struct fw_card *card;
+};
+
+/* This is our task struct. It's used for the packet complete callback.  */
+struct ipv4_packet_task {
+	/*
+	 * ptask can actually be on priv->packet_list, priv->broadcasted_list,
+	 * or priv->sent_list depending on its current state.
+	 */
+	struct list_head packet_list;
+	struct fw_transaction transaction;
+	struct ipv4_hdr hdr;
+	struct sk_buff *skb;
+	struct ipv4_priv *priv;
+	enum ipv4_tx_type tx_type;
+	int outstanding_pkts;
+	unsigned max_payload;
+	u64 fifo_addr;
+	u16 dest_node;
+	u8 generation;
+	u8 speed;
+};
+
+static struct kmem_cache *ipv4_packet_task_cache;
+
+static const char ipv4_driver_name[] = "firewire-ipv4";
+
+static const struct ieee1394_device_id ipv4_id_table[] = {
+	{
+		.match_flags  = IEEE1394_MATCH_SPECIFIER_ID |
+				IEEE1394_MATCH_VERSION,
+		.specifier_id = IPV4_GASP_SPECIFIER_ID,
+		.version      = IPV4_GASP_VERSION,
+	},
+	{ }
+};
+
+static u32 ipv4_unit_directory_data[] = {
+	0x00040000,					/* unit directory */
+	0x12000000 | IPV4_GASP_SPECIFIER_ID,	/* specifier ID */
+	0x81000003,					/* text descriptor */
+	0x13000000 | IPV4_GASP_VERSION,		/* version */
+	0x81000005,					/* text descriptor */
+
+	0x00030000,					/* Three quadlets */
+	0x00000000,					/* Text */
+	0x00000000,					/* Language 0 */
+	0x49414e41,					/* I A N A */
+	0x00030000,					/* Three quadlets */
+	0x00000000,					/* Text */
+	0x00000000,					/* Language 0 */
+	0x49507634,					/* I P v 4 */
+};
+
+static struct fw_descriptor ipv4_unit_directory = {
+	.length = ARRAY_SIZE(ipv4_unit_directory_data),
+	.key = 0xd1000000,
+	.data = ipv4_unit_directory_data
+};
+
+static int ipv4_send_packet(struct ipv4_packet_task *ptask );
+
+/* ------------------------------------------------------------------ */
+/******************************************
+ * HW Header net device functions
+ ******************************************/
+  /* These functions have been adapted from net/ethernet/eth.c */
+
+/* Create a fake MAC header for an arbitrary protocol layer.
+ * saddr=NULL means use device source address
+ * daddr=NULL means leave destination address (eg unresolved arp). */
+
+static int ipv4_header ( struct sk_buff *skb, struct net_device *dev,
+		       unsigned short type, const void *daddr,
+		       const void *saddr, unsigned len) {
+	struct ipv4_ether_hdr *eth;
+
+	eth = (struct ipv4_ether_hdr *)skb_push(skb, sizeof(*eth));
+	eth->h_proto = htons(type);
+
+	if (dev->flags & (IFF_LOOPBACK | IFF_NOARP)) {
+		memset(eth->h_dest, 0, dev->addr_len);
+		return dev->hard_header_len;
+	}
+
+	if (daddr) {
+		memcpy(eth->h_dest, daddr, dev->addr_len);
+		return dev->hard_header_len;
+	}
+
+	return -dev->hard_header_len;
+}
+
+/* Rebuild the faked MAC header. This is called after an ARP
+ * (or in future other address resolution) has completed on this
+ * sk_buff. We now let ARP fill in the other fields.
+ *
+ * This routine CANNOT use cached dst->neigh!
+ * Really, it is used only when dst->neigh is wrong.
+ */
+
+static int ipv4_rebuild_header(struct sk_buff *skb)
+{
+	struct ipv4_ether_hdr *eth;
+
+	eth = (struct ipv4_ether_hdr *)skb->data;
+	if (eth->h_proto == htons(ETH_P_IP))
+		return arp_find((unsigned char *)&eth->h_dest, skb);
+
+	fw_notify ( "%s: unable to resolve type %04x addresses\n",
+		   skb->dev->name,ntohs(eth->h_proto) );
+	return 0;
+}
+
+static int ipv4_header_cache(const struct neighbour *neigh, struct hh_cache *hh) {
+	unsigned short type = hh->hh_type;
+	struct net_device *dev;
+	struct ipv4_ether_hdr *eth;
+
+	if (type == htons(ETH_P_802_3))
+		return -1;
+	dev = neigh->dev;
+	eth = (struct ipv4_ether_hdr *)((u8 *)hh->hh_data + 16 - sizeof(*eth));
+	eth->h_proto = type;
+	memcpy(eth->h_dest, neigh->ha, dev->addr_len);
+
+	hh->hh_len = IPV4_HLEN;
+	return 0;
+}
+
+/* Called by Address Resolution module to notify changes in address. */
+static void ipv4_header_cache_update(struct hh_cache *hh, const struct net_device *dev, const unsigned char * haddr ) {
+	memcpy((u8 *)hh->hh_data + 16 - IPV4_HLEN, haddr, dev->addr_len);
+}
+
+static int ipv4_header_parse(const struct sk_buff *skb, unsigned char *haddr) {
+	memcpy(haddr, skb->dev->dev_addr, IPV4_ALEN);
+	return IPV4_ALEN;
+}
+
+static const struct header_ops ipv4_header_ops = {
+	.create         = ipv4_header,
+	.rebuild        = ipv4_rebuild_header,
+	.cache		= ipv4_header_cache,
+	.cache_update	= ipv4_header_cache_update,
+	.parse          = ipv4_header_parse,
+};
+
+/* ------------------------------------------------------------------ */
+
+/* FIXME: is this correct for all cases? */
+static bool ipv4_frag_overlap(struct ipv4_partial_datagram *pd, unsigned offset, unsigned len)
+{
+        struct ipv4_fragment_info *fi;
+	unsigned end = offset + len;
+
+	list_for_each_entry(fi, &pd->fragment_info, fragment_info) {
+		if (offset < fi->offset + fi->len && end > fi->offset) {
+			fw_debug ( "frag_overlap pd %p fi %p (%x@%x) with %x@%x\n", pd, fi, fi->len, fi->offset, len, offset );
+			return true;
+		}
+	}
+	fw_debug ( "frag_overlap %p does not overlap with %x@%x\n", pd, len, offset );
+	return false;
+}
+
+/* Assumes that new fragment does not overlap any existing fragments */
+static struct ipv4_fragment_info *ipv4_frag_new ( struct ipv4_partial_datagram *pd, unsigned offset, unsigned len ) {
+	struct ipv4_fragment_info *fi, *fi2, *new;
+	struct list_head *list;
+
+	fw_debug ( "frag_new pd %p %x@%x\n", pd, len, offset );
+	list = &pd->fragment_info;
+	list_for_each_entry(fi, &pd->fragment_info, fragment_info) {
+		if (fi->offset + fi->len == offset) {
+			/* The new fragment can be tacked on to the end */
+			/* Did the new fragment plug a hole? */
+			fi2 = list_entry(fi->fragment_info.next, struct ipv4_fragment_info, fragment_info);
+			if (fi->offset + fi->len == fi2->offset) {
+				fw_debug ( "pd %p: hole filling %p (%x@%x) and %p(%x@%x): now %x@%x\n", pd, fi, fi->len, fi->offset,
+				fi2, fi2->len, fi2->offset, fi->len + len + fi2->len, fi->offset );
+				/* glue fragments together */
+				fi->len += len + fi2->len;
+				list_del(&fi2->fragment_info);
+				kfree(fi2);
+			} else {
+				fw_debug ( "pd %p: extending %p from %x@%x to %x@%x\n", pd, fi, fi->len, fi->offset, fi->len+len, fi->offset );
+				fi->len += len;
+			}
+			return fi;
+		}
+		if (offset + len == fi->offset) {
+			/* The new fragment can be tacked on to the beginning */
+			/* Did the new fragment plug a hole? */
+			fi2 = list_entry(fi->fragment_info.prev, struct ipv4_fragment_info, fragment_info);
+			if (fi2->offset + fi2->len == fi->offset) {
+				/* glue fragments together */
+				fw_debug ( "pd %p: extending %p and merging with %p from %x@%x to %x@%x\n",
+ pd, fi2, fi, fi2->len, fi2->offset, fi2->len + fi->len + len, fi2->offset );
+				fi2->len += fi->len + len;
+				list_del(&fi->fragment_info);
+				kfree(fi);
+				return fi2;
+			}
+			fw_debug ( "pd %p: extending %p from %x@%x to %x@%x\n", pd, fi, fi->len, fi->offset, offset, fi->len + len );
+			fi->offset = offset;
+			fi->len += len;
+			return fi;
+		}
+		if (offset > fi->offset + fi->len) {
+			list = &fi->fragment_info;
+			break;
+		}
+		if (offset + len < fi->offset) {
+			list = fi->fragment_info.prev;
+			break;
+		}
+	}
+
+	new = kmalloc(sizeof(*new), GFP_ATOMIC);
+	if (!new) {
+		fw_error ( "out of memory in fragment handling!\n" );
+		return NULL;
+	}
+
+	new->offset = offset;
+	new->len = len;
+	list_add(&new->fragment_info, list);
+	fw_debug ( "pd %p: new frag %p %x@%x\n", pd, new, new->len, new->offset );
+	list_for_each_entry( fi, &pd->fragment_info, fragment_info )
+		fw_debug ( "fi %p %x@%x\n", fi, fi->len, fi->offset );
+	return new;
+}
+
+/* ------------------------------------------------------------------ */
+
+static struct ipv4_partial_datagram *ipv4_pd_new(struct net_device *netdev,
+ struct ipv4_node *node, u16 datagram_label, unsigned dg_size, u32 *frag_buf,
+ unsigned frag_off, unsigned frag_len) {
+	struct ipv4_partial_datagram *new;
+	struct ipv4_fragment_info *fi;
+
+	new = kmalloc(sizeof(*new), GFP_ATOMIC);
+	if (!new)
+		goto fail;
+	INIT_LIST_HEAD(&new->fragment_info);
+	fi = ipv4_frag_new ( new, frag_off, frag_len);
+	if ( fi == NULL )
+		goto fail_w_new;
+	new->datagram_label = datagram_label;
+	new->datagram_size = dg_size;
+	new->skb = dev_alloc_skb(dg_size + netdev->hard_header_len + 15);
+	if ( new->skb == NULL )
+		goto fail_w_fi;
+	skb_reserve(new->skb, (netdev->hard_header_len + 15) & ~15);
+	new->pbuf = skb_put(new->skb, dg_size);
+	memcpy(new->pbuf + frag_off, frag_buf, frag_len);
+	list_add_tail(&new->pdg_list, &node->pdg_list);
+	fw_debug ( "pd_new: new pd %p { dgl %u, dg_size %u, skb %p, pbuf %p } on node %p\n",
+ new, new->datagram_label, new->datagram_size, new->skb, new->pbuf, node );
+	return new;
+
+fail_w_fi:
+	kfree(fi);
+fail_w_new:
+	kfree(new);
+fail:
+	fw_error("ipv4_pd_new: no memory\n");
+	return NULL;
+}
+
+static struct ipv4_partial_datagram *ipv4_pd_find(struct ipv4_node *node, u16 datagram_label) {
+	struct ipv4_partial_datagram *pd;
+
+	list_for_each_entry(pd, &node->pdg_list, pdg_list) {
+	        if ( pd->datagram_label == datagram_label ) {
+			fw_debug ( "pd_find(node %p, label %u): pd %p\n", node, datagram_label, pd );
+			return pd;
+		}
+	}
+	fw_debug ( "pd_find(node %p, label %u) no entry\n", node, datagram_label );
+	return NULL;
+}
+
+
+static void ipv4_pd_delete ( struct ipv4_partial_datagram *old ) {
+	struct ipv4_fragment_info *fi, *n;
+
+	fw_debug ( "pd_delete %p\n", old );
+	list_for_each_entry_safe(fi, n, &old->fragment_info, fragment_info) {
+		fw_debug ( "Freeing fi %p\n", fi );
+		kfree(fi);
+	}
+	list_del(&old->pdg_list);
+	dev_kfree_skb_any(old->skb);
+	kfree(old);
+}
+
+static bool ipv4_pd_update ( struct ipv4_node *node, struct ipv4_partial_datagram *pd,
+ u32 *frag_buf, unsigned frag_off, unsigned frag_len) {
+	fw_debug ( "pd_update node %p, pd %p, frag_buf %p, %x@%x\n", node, pd, frag_buf, frag_len, frag_off );
+	if ( ipv4_frag_new ( pd, frag_off, frag_len ) == NULL)
+		return false;
+	memcpy(pd->pbuf + frag_off, frag_buf, frag_len);
+
+	/*
+	 * Move list entry to beginnig of list so that oldest partial
+	 * datagrams percolate to the end of the list
+	 */
+	list_move_tail(&pd->pdg_list, &node->pdg_list);
+	fw_debug ( "New pd list:\n" );
+	list_for_each_entry ( pd, &node->pdg_list, pdg_list ) {
+		fw_debug ( "pd %p\n", pd );
+	}
+	return true;
+}
+
+static bool ipv4_pd_is_complete ( struct ipv4_partial_datagram *pd ) {
+	struct ipv4_fragment_info *fi;
+	bool ret;
+
+	fi = list_entry(pd->fragment_info.next, struct ipv4_fragment_info, fragment_info);
+
+	ret = (fi->len == pd->datagram_size);
+	fw_debug ( "pd_is_complete (pd %p, dgs %x): fi %p (%x@%x) %s\n", pd, pd->datagram_size, fi, fi->len, fi->offset, ret ? "yes" : "no" );
+	return ret;
+}
+
+/* ------------------------------------------------------------------ */
+
+static int ipv4_node_new ( struct fw_card *card, struct fw_device *device ) {
+	struct ipv4_node *node;
+
+	node = kmalloc ( sizeof(*node), GFP_KERNEL );
+	if ( ! node ) {
+		fw_error ( "allocate new node failed\n" );
+		return -ENOMEM;
+	}
+	node->guid = (u64)device->config_rom[3] << 32 | device->config_rom[4];
+	node->fifo = INVALID_FIFO_ADDR;
+	INIT_LIST_HEAD(&node->pdg_list);
+	spin_lock_init(&node->pdg_lock);
+	node->pdg_size = 0;
+	node->generation = device->generation;
+	rmb();
+	node->nodeid = device->node_id;
+	 /* FIXME what should it really be? */
+	node->max_payload = S100_BUFFER_SIZE - IPV4_UNFRAG_HDR_SIZE;
+	node->datagram_label = 0U;
+	node->xmt_speed = device->max_speed;
+	list_add_tail ( &node->ipv4_nodes, &card->ipv4_nodes );
+	fw_debug ( "node_new: %p { guid %016llx, generation %u, nodeid %x, max_payload %x, xmt_speed %x } added\n",
+ node, (unsigned long long)node->guid, node->generation, node->nodeid, node->max_payload, node->xmt_speed );
+	return 0;
+}
+
+static struct ipv4_node *ipv4_node_find_by_guid(struct ipv4_priv *priv, u64 guid) {
+	struct ipv4_node *node;
+	unsigned long flags;
+
+	spin_lock_irqsave(&priv->lock, flags);
+	list_for_each_entry(node, &priv->card->ipv4_nodes, ipv4_nodes)
+		if (node->guid == guid) {
+			/* FIXME: lock the node first? */
+			spin_unlock_irqrestore ( &priv->lock, flags );
+			fw_debug ( "node_find_by_guid (%016llx) found %p\n", (unsigned long long)guid, node );
+			return node;
+		}
+
+	spin_unlock_irqrestore ( &priv->lock, flags );
+	fw_debug ( "node_find_by_guid (%016llx) not found\n", (unsigned long long)guid );
+	return NULL;
+}
+
+static struct ipv4_node *ipv4_node_find_by_nodeid(struct ipv4_priv *priv, u16 nodeid) {
+	struct ipv4_node *node;
+	unsigned long flags;
+
+	spin_lock_irqsave(&priv->lock, flags);
+	list_for_each_entry(node, &priv->card->ipv4_nodes, ipv4_nodes)
+		if (node->nodeid == nodeid) {
+			/* FIXME: lock the node first? */
+			spin_unlock_irqrestore ( &priv->lock, flags );
+			fw_debug ( "node_find_by_nodeid (%x) found %p\n", nodeid, node );
+			return node;
+		}
+	fw_debug ( "node_find_by_nodeid (%x) not found\n", nodeid );
+	spin_unlock_irqrestore ( &priv->lock, flags );
+	return NULL;
+}
+
+/* This is only complicated because we can't assume priv exists */
+static void ipv4_node_delete ( struct fw_card *card, struct fw_device *device ) {
+	struct net_device *netdev;
+	struct ipv4_priv *priv;
+	struct ipv4_node *node;
+	u64 guid;
+	unsigned long flags;
+	struct ipv4_partial_datagram *pd, *pd_next;
+
+	guid = (u64)device->config_rom[3] << 32 | device->config_rom[4];
+	netdev = card->netdev;
+	if ( netdev )
+		priv = netdev_priv ( netdev );
+	else
+		priv = NULL;
+	if ( priv )
+		spin_lock_irqsave ( &priv->lock, flags );
+	list_for_each_entry( node, &card->ipv4_nodes, ipv4_nodes ) {
+		if ( node->guid == guid ) {
+			list_del ( &node->ipv4_nodes );
+			list_for_each_entry_safe( pd, pd_next, &node->pdg_list, pdg_list )
+				ipv4_pd_delete ( pd );
+			break;
+		}
+	}
+	if ( priv )
+		spin_unlock_irqrestore ( &priv->lock, flags );
+}
+
+/* ------------------------------------------------------------------ */
+
+
+static int ipv4_finish_incoming_packet ( struct net_device *netdev,
+ struct sk_buff *skb, u16 source_node_id, bool is_broadcast, u16 ether_type ) {
+	struct ipv4_priv *priv;
+	static u64 broadcast_hw = ~0ULL;
+	int status;
+	u64 guid;
+
+	fw_debug ( "ipv4_finish_incoming_packet(%p, %p, %x, %s, %x\n",
+ netdev, skb, source_node_id, is_broadcast ? "true" : "false", ether_type );
+	priv = netdev_priv(netdev);
+	/* Write metadata, and then pass to the receive level */
+	skb->dev = netdev;
+	skb->ip_summed = CHECKSUM_UNNECESSARY;  /* don't check it */
+
+	/*
+	 * Parse the encapsulation header. This actually does the job of
+	 * converting to an ethernet frame header, as well as arp
+	 * conversion if needed. ARP conversion is easier in this
+	 * direction, since we are using ethernet as our backend.
+	 */
+	/*
+	 * If this is an ARP packet, convert it. First, we want to make
+	 * use of some of the fields, since they tell us a little bit
+	 * about the sending machine.
+	 */
+	if (ether_type == ETH_P_ARP) {
+		struct ipv4_arp *arp1394;
+		struct arphdr *arp;
+		unsigned char *arp_ptr;
+		u64 fifo_addr;
+		u8 max_rec;
+		u8 sspd;
+		u16 max_payload;
+		struct ipv4_node *node;
+		static const u16 ipv4_speed_to_max_payload[] = {
+			/* S100, S200, S400, S800, S1600, S3200 */
+			    512, 1024, 2048, 4096,  4096,  4096
+		};
+
+		/* fw_debug ( "ARP packet\n" ); */
+		arp1394 = (struct ipv4_arp *)skb->data;
+		arp = (struct arphdr *)skb->data;
+		arp_ptr = (unsigned char *)(arp + 1);
+		fifo_addr = (u64)ntohs(arp1394->fifo_hi) << 32 |
+ ntohl(arp1394->fifo_lo);
+		max_rec = priv->card->max_receive;
+		if ( arp1394->max_rec < max_rec )
+			max_rec = arp1394->max_rec;
+		sspd = arp1394->sspd;
+		/*
+		 * Sanity check. MacOSX seems to be sending us 131 in this
+		 * field (atleast on my Panther G5). Not sure why.
+		 */
+		if (sspd > 5 ) {
+			fw_notify ( "sspd %x out of range\n", sspd );
+			sspd = 0;
+		}
+
+		max_payload = min(ipv4_speed_to_max_payload[sspd],
+ (u16)(1 << (max_rec + 1))) - IPV4_UNFRAG_HDR_SIZE;
+
+		guid = be64_to_cpu(get_unaligned(&arp1394->s_uniq_id));
+		node = ipv4_node_find_by_guid(priv, guid);
+		if (!node) {
+			fw_notify ( "No node for ARP packet from %llx\n", guid );
+			goto failed_proto;
+		}
+		if ( node->nodeid != source_node_id || node->generation != priv->card->generation ) {
+			fw_notify ( "Internal error: node->nodeid (%x) != soucre_node_id (%x) or node->generation (%x) != priv->card->generation(%x)\n",
+ node->nodeid, source_node_id, node->generation, priv->card->generation );
+			node->nodeid = source_node_id;
+			node->generation = priv->card->generation;
+		}
+
+		/* FIXME: for debugging */
+		if ( sspd > SCODE_400 )
+			sspd = SCODE_400;
+		/* Update our speed/payload/fifo_offset table */
+		/*
+		 * FIXME: this does not handle cases where two high-speed endpoints must use a slower speed because of
+		 * a lower speed hub between them.  We need to look at the actual topology map here.
+		 */
+		fw_debug ( "Setting node %p fifo %llx (was %llx), max_payload %x (was %x), speed %x (was %x)\n",
+ node, fifo_addr, node->fifo, max_payload, node->max_payload, sspd, node->xmt_speed );
+		node->fifo =	fifo_addr;
+		node->max_payload = max_payload;
+		/*
+		 * Only allow speeds to go down from their initial value.
+		 * Otherwise a local node that can only do S400 or slower may
+		 * be told to transmit at S800 to a faster remote node.
+		 */
+		if ( node->xmt_speed > sspd )
+			node->xmt_speed = sspd;
+
+		/*
+		 * Now that we're done with the 1394 specific stuff, we'll
+		 * need to alter some of the data.  Believe it or not, all
+		 * that needs to be done is sender_IP_address needs to be
+		 * moved, the destination hardware address get stuffed
+		 * in and the hardware address length set to 8.
+		 *
+		 * IMPORTANT: The code below overwrites 1394 specific data
+		 * needed above so keep the munging of the data for the
+		 * higher level IP stack last.
+		 */
+
+		arp->ar_hln = 8;
+		arp_ptr += arp->ar_hln;		/* skip over sender unique id */
+		*(u32 *)arp_ptr = arp1394->sip; /* move sender IP addr */
+		arp_ptr += arp->ar_pln;		/* skip over sender IP addr */
+
+		if (arp->ar_op == htons(ARPOP_REQUEST))
+			memset(arp_ptr, 0, sizeof(u64));
+		else
+			memcpy(arp_ptr, netdev->dev_addr, sizeof(u64));
+	}
+
+	/* Now add the ethernet header. */
+	guid = cpu_to_be64(priv->card->guid);
+	if (dev_hard_header(skb, netdev, ether_type, is_broadcast ? &broadcast_hw : &guid, NULL,
+ skb->len) >= 0) {
+		struct ipv4_ether_hdr *eth;
+		u16 *rawp;
+		__be16 protocol;
+
+		skb_reset_mac_header(skb);
+		skb_pull(skb, sizeof(*eth));
+		eth = ipv4_ether_hdr(skb);
+		if (*eth->h_dest & 1) {
+			if (memcmp(eth->h_dest, netdev->broadcast, netdev->addr_len) == 0) {
+				fw_debug ( "Broadcast\n" );
+				skb->pkt_type = PACKET_BROADCAST;
+			}
+#if 0
+			else
+				skb->pkt_type = PACKET_MULTICAST;
+#endif
+		} else {
+			if (memcmp(eth->h_dest, netdev->dev_addr, netdev->addr_len)) {
+				u64 a1, a2;
+
+				memcpy ( &a1, eth->h_dest, sizeof(u64));
+				memcpy ( &a2, netdev->dev_addr, sizeof(u64));
+				fw_debug ( "Otherhost %llx %llx %x\n", a1, a2, netdev->addr_len );
+				skb->pkt_type = PACKET_OTHERHOST;
+			}
+		}
+		if (ntohs(eth->h_proto) >= 1536) {
+			fw_debug ( " proto %x %x\n", eth->h_proto, ntohs(eth->h_proto) );
+			protocol = eth->h_proto;
+		} else {
+			rawp = (u16 *)skb->data;
+			if (*rawp == 0xFFFF) {
+				fw_debug ( "proto 802_3\n" );
+				protocol = htons(ETH_P_802_3);
+			} else {
+				fw_debug ( "proto 802_2\n" );
+				protocol = htons(ETH_P_802_2);
+			}
+		}
+		skb->protocol = protocol;
+	}
+	status = netif_rx(skb);
+	if ( status == NET_RX_DROP) {
+		netdev->stats.rx_errors++;
+		netdev->stats.rx_dropped++;
+	} else {
+		netdev->stats.rx_packets++;
+		netdev->stats.rx_bytes += skb->len;
+	}
+	if (netif_queue_stopped(netdev))
+		netif_wake_queue(netdev);
+	return 0;
+
+ failed_proto:
+	netdev->stats.rx_errors++;
+	netdev->stats.rx_dropped++;
+	dev_kfree_skb_any(skb);
+	if (netif_queue_stopped(netdev))
+		netif_wake_queue(netdev);
+	netdev->last_rx = jiffies;
+	return 0;
+}
+
+/* ------------------------------------------------------------------ */
+
+static int ipv4_incoming_packet ( struct ipv4_priv *priv, u32 *buf, int len, u16 source_node_id, bool is_broadcast ) {
+	struct sk_buff *skb;
+	struct net_device *netdev;
+	struct ipv4_hdr hdr;
+	unsigned lf;
+	unsigned long flags;
+	struct ipv4_node *node;
+	struct ipv4_partial_datagram *pd;
+	int fg_off;
+	int dg_size;
+	u16 datagram_label;
+	int retval;
+	u16 ether_type;
+
+	fw_debug ( "ipv4_incoming_packet(%p, %p, %d, %x, %s)\n", priv, buf, len, source_node_id, is_broadcast ? "true" : "false" );
+	netdev = priv->card->netdev;
+
+	hdr.w0 = ntohl(buf[0]);
+	lf = ipv4_get_hdr_lf(&hdr);
+	if ( lf == IPV4_HDR_UNFRAG ) {
+		/*
+		 * An unfragmented datagram has been received by the ieee1394
+		 * bus. Build an skbuff around it so we can pass it to the
+		 * high level network layer.
+		 */
+		ether_type = ipv4_get_hdr_ether_type(&hdr);
+		fw_debug ( "header w0 = %x, lf = %x, ether_type = %x\n", hdr.w0, lf, ether_type );
+		buf++;
+		len -= IPV4_UNFRAG_HDR_SIZE;
+
+		skb = dev_alloc_skb(len + netdev->hard_header_len + 15);
+		if (unlikely(!skb)) {
+			fw_error ( "Out of memory for incoming packet\n");
+			netdev->stats.rx_dropped++;
+			return -1;
+		}
+		skb_reserve(skb, (netdev->hard_header_len + 15) & ~15);
+		memcpy(skb_put(skb, len), buf, len );
+		return ipv4_finish_incoming_packet(netdev, skb, source_node_id, is_broadcast, ether_type );
+	}
+	/* A datagram fragment has been received, now the fun begins. */
+	hdr.w1 = ntohl(buf[1]);
+	buf +=2;
+	len -= IPV4_FRAG_HDR_SIZE;
+	if ( lf ==IPV4_HDR_FIRSTFRAG ) {
+		ether_type = ipv4_get_hdr_ether_type(&hdr);
+		fg_off = 0;
+	} else {
+		fg_off = ipv4_get_hdr_fg_off(&hdr);
+		ether_type = 0; /* Shut up compiler! */
+	}
+	datagram_label = ipv4_get_hdr_dgl(&hdr);
+	dg_size = ipv4_get_hdr_dg_size(&hdr); /* ??? + 1 */
+	fw_debug ( "fragmented: %x.%x = lf %x, ether_type %x, fg_off %x, dgl %x, dg_size %x\n", hdr.w0, hdr.w1, lf, ether_type, fg_off, datagram_label, dg_size );
+	node = ipv4_node_find_by_nodeid ( priv, source_node_id);
+	spin_lock_irqsave(&node->pdg_lock, flags);
+	pd = ipv4_pd_find( node, datagram_label );
+	if (pd == NULL) {
+		while ( node->pdg_size >= ipv4_mpd ) {
+			/* remove the oldest */
+			ipv4_pd_delete ( list_first_entry(&node->pdg_list, struct ipv4_partial_datagram, pdg_list) );
+			node->pdg_size--;
+		}
+		pd = ipv4_pd_new ( netdev, node, datagram_label, dg_size,
+ buf, fg_off, len);
+		if ( pd == NULL) {
+			retval = -ENOMEM;
+			goto bad_proto;
+		}
+		node->pdg_size++;
+	} else {
+		if (ipv4_frag_overlap(pd, fg_off, len) || pd->datagram_size != dg_size) {
+			/*
+			 * Differing datagram sizes or overlapping fragments,
+			 * Either way the remote machine is playing silly buggers
+			 * with us: obliterate the old datagram and start a new one.
+			 */
+			ipv4_pd_delete ( pd );
+			pd = ipv4_pd_new ( netdev, node, datagram_label,
+ dg_size, buf, fg_off, len);
+			if ( pd == NULL ) {
+				retval = -ENOMEM;
+				node->pdg_size--;
+				goto bad_proto;
+			}
+		} else {
+			bool worked;
+
+			worked = ipv4_pd_update ( node, pd,
+ buf, fg_off, len );
+			if ( ! worked ) {
+				/*
+				 * Couldn't save off fragment anyway
+				 * so might as well obliterate the
+				 * datagram now.
+				 */
+				ipv4_pd_delete ( pd );
+				node->pdg_size--;
+				goto bad_proto;
+			}
+		}
+	} /* new datagram or add to existing one */
+
+	if ( lf == IPV4_HDR_FIRSTFRAG )
+		pd->ether_type = ether_type;
+	if ( ipv4_pd_is_complete ( pd ) ) {
+		ether_type = pd->ether_type;
+		node->pdg_size--;
+		skb = skb_get(pd->skb);
+		ipv4_pd_delete ( pd );
+		spin_unlock_irqrestore(&node->pdg_lock, flags);
+		return ipv4_finish_incoming_packet ( netdev, skb, source_node_id, false, ether_type );
+	}
+	/*
+	 * Datagram is not complete, we're done for the
+	 * moment.
+	 */
+	spin_unlock_irqrestore(&node->pdg_lock, flags);
+	return 0;
+
+ bad_proto:
+	spin_unlock_irqrestore(&node->pdg_lock, flags);
+	if (netif_queue_stopped(netdev))
+		netif_wake_queue(netdev);
+	return 0;
+}
+
+static void ipv4_receive_packet ( struct fw_card *card, struct fw_request *r,
+ int tcode, int destination, int source, int generation, int speed,
+ unsigned long long offset, void *payload, size_t length, void *callback_data ) {
+	struct ipv4_priv *priv;
+	int status;
+
+	fw_debug ( "ipv4_receive_packet(%p,%p,%x,%x,%x,%x,%x,%llx,%p,%lx,%p)\n",
+ card, r, tcode, destination, source, generation, speed, offset, payload,
+ (unsigned long)length, callback_data);
+	print_hex_dump ( KERN_DEBUG, "header: ", DUMP_PREFIX_OFFSET, 32, 1, payload, length, false );
+	priv = callback_data;
+	if (   tcode != TCODE_WRITE_BLOCK_REQUEST
+	    || destination != card->node_id
+	    || generation != card->generation
+	    || offset != priv->handler.offset ) {
+		fw_send_response(card, r, RCODE_CONFLICT_ERROR);
+		fw_debug("Conflict error card node_id=%x, card generation=%x, local offset %llx\n",
+ card->node_id, card->generation, (unsigned long long)priv->handler.offset );
+		return;
+	}
+	status = ipv4_incoming_packet ( priv, payload, length, source, false );
+	if ( status != 0 ) {
+		fw_error ( "Incoming packet failure\n" );
+		fw_send_response ( card, r, RCODE_CONFLICT_ERROR );
+		return;
+	}
+	fw_send_response ( card, r, RCODE_COMPLETE );
+}
+
+static void ipv4_receive_broadcast(struct fw_iso_context *context, u32 cycle,
+ size_t header_length, void *header, void *data) {
+	struct ipv4_priv *priv;
+	struct fw_iso_packet packet;
+	struct fw_card *card;
+	u16 *hdr_ptr;
+	u32 *buf_ptr;
+	int retval;
+	u32 length;
+	u16 source_node_id;
+	u32 specifier_id;
+	u32 ver;
+	unsigned long offset;
+	unsigned long flags;
+
+	fw_debug ( "ipv4_receive_broadcast ( context=%p, cycle=%x, header_length=%lx, header=%p, data=%p )\n", context, cycle, (unsigned long)header_length, header, data );
+	print_hex_dump ( KERN_DEBUG, "header: ", DUMP_PREFIX_OFFSET, 32, 1, header, header_length, false );
+	priv = data;
+	card = priv->card;
+	hdr_ptr = header;
+	length = ntohs(hdr_ptr[0]);
+	spin_lock_irqsave(&priv->lock,flags);
+	offset = priv->rcv_buffer_size * priv->broadcast_rcv_next_ptr;
+	buf_ptr = priv->broadcast_rcv_buffer_ptrs[priv->broadcast_rcv_next_ptr++];
+	if ( priv->broadcast_rcv_next_ptr == priv->num_broadcast_rcv_ptrs )
+		priv->broadcast_rcv_next_ptr = 0;
+	spin_unlock_irqrestore(&priv->lock,flags);
+	fw_debug ( "length %u at %p\n", length, buf_ptr );
+	print_hex_dump ( KERN_DEBUG, "buffer: ", DUMP_PREFIX_OFFSET, 32, 1, buf_ptr, length, false );
+
+	specifier_id =    (be32_to_cpu(buf_ptr[0]) & 0xffff) << 8
+			| (be32_to_cpu(buf_ptr[1]) & 0xff000000) >> 24;
+	ver = be32_to_cpu(buf_ptr[1]) & 0xFFFFFF;
+	source_node_id = be32_to_cpu(buf_ptr[0]) >> 16;
+	/* fw_debug ( "source %x SpecID %x ver %x\n", source_node_id, specifier_id, ver ); */
+	if ( specifier_id == IPV4_GASP_SPECIFIER_ID && ver == IPV4_GASP_VERSION ) {
+		buf_ptr += 2;
+		length -= IPV4_GASP_OVERHEAD;
+		ipv4_incoming_packet(priv, buf_ptr, length, source_node_id, true);
+	} else
+		fw_debug ( "Ignoring packet: not GASP\n" );
+	packet.payload_length = priv->rcv_buffer_size;
+	packet.interrupt = 1;
+	packet.skip = 0;
+	packet.tag = 3;
+	packet.sy = 0;
+	packet.header_length = IPV4_GASP_OVERHEAD;
+	spin_lock_irqsave(&priv->lock,flags);
+	retval = fw_iso_context_queue ( priv->broadcast_rcv_context, &packet,
+ &priv->broadcast_rcv_buffer, offset );
+	spin_unlock_irqrestore(&priv->lock,flags);
+	if ( retval < 0 )
+		fw_error ( "requeue failed\n" );
+}
+
+static void debug_ptask ( struct ipv4_packet_task *ptask ) {
+	static const char *tx_types[] = { "Unknown", "GASP", "Write" };
+
+	fw_debug ( "packet %p { hdr { w0 %x w1 %x }, skb %p, priv %p,"
+ " tx_type %s, outstanding_pkts %d, max_payload %x, fifo %llx,"
+ " speed %x, dest_node %x, generation %x }\n",
+ ptask, ptask->hdr.w0, ptask->hdr.w1, ptask->skb, ptask->priv,
+ ptask->tx_type > IPV4_WRREQ ? "Invalid" : tx_types[ptask->tx_type],
+ ptask->outstanding_pkts,  ptask->max_payload,
+ ptask->fifo_addr, ptask->speed, ptask->dest_node, ptask->generation );
+	print_hex_dump ( KERN_DEBUG, "packet :", DUMP_PREFIX_OFFSET, 32, 1,
+ ptask->skb->data, ptask->skb->len, false );
+}
+
+static void ipv4_transmit_packet_done ( struct ipv4_packet_task *ptask ) {
+	struct ipv4_priv *priv;
+	unsigned long flags;
+
+	priv = ptask->priv;
+	spin_lock_irqsave ( &priv->lock, flags );
+	list_del ( &ptask->packet_list );
+	spin_unlock_irqrestore ( &priv->lock, flags );
+	ptask->outstanding_pkts--;
+	if ( ptask->outstanding_pkts > 0 ) {
+		u16 dg_size;
+		u16 fg_off;
+		u16 datagram_label;
+		u16 lf;
+		struct sk_buff *skb;
+
+		/* Update the ptask to point to the next fragment and send it */
+		lf = ipv4_get_hdr_lf(&ptask->hdr);
+		switch (lf) {
+		case IPV4_HDR_LASTFRAG:
+		case IPV4_HDR_UNFRAG:
+		default:
+			fw_error ( "Outstanding packet %x lf %x, header %x,%x\n", ptask->outstanding_pkts, lf, ptask->hdr.w0, ptask->hdr.w1 );
+			BUG();
+
+		case IPV4_HDR_FIRSTFRAG:
+			/* Set frag type here for future interior fragments */
+			dg_size = ipv4_get_hdr_dg_size(&ptask->hdr);
+			fg_off = ptask->max_payload - IPV4_FRAG_HDR_SIZE;
+			datagram_label = ipv4_get_hdr_dgl(&ptask->hdr);
+			break;
+
+		case IPV4_HDR_INTFRAG:
+			dg_size = ipv4_get_hdr_dg_size(&ptask->hdr);
+			fg_off = ipv4_get_hdr_fg_off(&ptask->hdr) + ptask->max_payload - IPV4_FRAG_HDR_SIZE;
+			datagram_label = ipv4_get_hdr_dgl(&ptask->hdr);
+			break;
+		}
+		skb = ptask->skb;
+		skb_pull ( skb, ptask->max_payload );
+		if ( ptask->outstanding_pkts > 1 ) {
+			ipv4_make_sf_hdr ( &ptask->hdr,
+  IPV4_HDR_INTFRAG, dg_size, fg_off, datagram_label );
+		} else {
+			ipv4_make_sf_hdr ( &ptask->hdr,
+  IPV4_HDR_LASTFRAG, dg_size, fg_off, datagram_label );
+			ptask->max_payload = skb->len + IPV4_FRAG_HDR_SIZE;
+
+		}
+		ipv4_send_packet ( ptask );
+	} else {
+		dev_kfree_skb_any ( ptask->skb );
+		kmem_cache_free( ipv4_packet_task_cache, ptask );
+	}
+}
+
+static void ipv4_write_complete ( struct fw_card *card, int rcode,
+ void *payload, size_t length, void *data ) {
+	struct ipv4_packet_task *ptask;
+
+	ptask = data;
+	fw_debug ( "ipv4_write_complete ( %p, %x, %p, %lx, %p )\n",
+ card, rcode, payload, (unsigned long)length, data );
+	debug_ptask ( ptask );
+
+	if ( rcode == RCODE_COMPLETE ) {
+		ipv4_transmit_packet_done ( ptask );
+	} else {
+		fw_error ( "ipv4_write_complete: failed: %x\n", rcode );
+		/* ??? error recovery */
+	}
+}
+
+static int ipv4_send_packet ( struct ipv4_packet_task *ptask ) {
+	struct ipv4_priv *priv;
+	unsigned tx_len;
+	struct ipv4_hdr *bufhdr;
+	unsigned long flags;
+	struct net_device *netdev;
+#if 0 /* stefanr */
+	int retval;
+#endif
+
+	fw_debug ( "ipv4_send_packet\n" );
+	debug_ptask ( ptask );
+	priv = ptask->priv;
+	tx_len = ptask->max_payload;
+	switch (ipv4_get_hdr_lf(&ptask->hdr)) {
+	case IPV4_HDR_UNFRAG:
+		bufhdr = (struct ipv4_hdr *)skb_push(ptask->skb, IPV4_UNFRAG_HDR_SIZE);
+		bufhdr->w0 = htonl(ptask->hdr.w0);
+		break;
+
+	case IPV4_HDR_FIRSTFRAG:
+	case IPV4_HDR_INTFRAG:
+	case IPV4_HDR_LASTFRAG:
+		bufhdr = (struct ipv4_hdr *)skb_push(ptask->skb, IPV4_FRAG_HDR_SIZE);
+		bufhdr->w0 = htonl(ptask->hdr.w0);
+		bufhdr->w1 = htonl(ptask->hdr.w1);
+		break;
+
+	default:
+		BUG();
+	}
+	if ( ptask->tx_type == IPV4_GASP ) {
+		u32 *packets;
+		int generation;
+		int nodeid;
+
+		/* ptask->generation may not have been set yet */
+		generation = priv->card->generation;
+		smp_rmb();
+		nodeid = priv->card->node_id;
+		packets = (u32 *)skb_push(ptask->skb, sizeof(u32)*2);
+		packets[0] = htonl(nodeid << 16 | (IPV4_GASP_SPECIFIER_ID>>8));
+		packets[1] = htonl((IPV4_GASP_SPECIFIER_ID & 0xFF) << 24 | IPV4_GASP_VERSION);
+		fw_send_request ( priv->card, &ptask->transaction, TCODE_STREAM_DATA,
+ fw_stream_packet_destination_id(3, BROADCAST_CHANNEL, 0),
+ generation, SCODE_100, 0ULL, ptask->skb->data, tx_len + 8, ipv4_write_complete, ptask );
+		spin_lock_irqsave(&priv->lock,flags);
+		list_add_tail ( &ptask->packet_list, &priv->broadcasted_list );
+		spin_unlock_irqrestore(&priv->lock,flags);
+#if 0 /* stefanr */
+		return retval;
+#else
+		return 0;
+#endif
+	}
+	fw_debug("send_request (%p, %p, WRITE_BLOCK, %x, %x, %x, %llx, %p, %d, %p, %p\n",
+ priv->card, &ptask->transaction, ptask->dest_node, ptask->generation,
+ ptask->speed, (unsigned long long)ptask->fifo_addr, ptask->skb->data, tx_len,
+ ipv4_write_complete, ptask );
+	fw_send_request ( priv->card, &ptask->transaction,
+ TCODE_WRITE_BLOCK_REQUEST, ptask->dest_node, ptask->generation, ptask->speed,
+ ptask->fifo_addr, ptask->skb->data, tx_len, ipv4_write_complete, ptask );
+	spin_lock_irqsave(&priv->lock,flags);
+	list_add_tail ( &ptask->packet_list, &priv->sent_list );
+	spin_unlock_irqrestore(&priv->lock,flags);
+	netdev = priv->card->netdev;
+	netdev->trans_start = jiffies;
+	return 0;
+}
+
+static int ipv4_broadcast_start ( struct ipv4_priv *priv ) {
+	struct fw_iso_context *context;
+	int retval;
+	unsigned num_packets;
+	unsigned max_receive;
+	struct fw_iso_packet packet;
+	unsigned long offset;
+	unsigned u;
+	/* unsigned transmit_speed; */
+
+#if 0 /* stefanr */
+	if ( priv->card->broadcast_channel != (BROADCAST_CHANNEL_VALID|BROADCAST_CHANNEL_INITIAL)) {
+		fw_notify ( "Invalid broadcast channel %x\n", priv->card->broadcast_channel );
+		/* FIXME: try again later? */
+		/* return -EINVAL; */
+	}
+#endif
+	if ( priv->local_fifo == INVALID_FIFO_ADDR ) {
+		struct fw_address_region region;
+
+		priv->handler.length = FIFO_SIZE;
+		priv->handler.address_callback = ipv4_receive_packet;
+		priv->handler.callback_data = priv;
+		/* FIXME: this is OHCI, but what about others? */
+		region.start = 0xffff00000000ULL;
+		region.end =   0xfffffffffffcULL;
+
+		retval = fw_core_add_address_handler ( &priv->handler, &region );
+		if ( retval < 0 )
+			goto failed_initial;
+		priv->local_fifo = priv->handler.offset;
+	}
+
+	/*
+	 * FIXME: rawiso limits us to PAGE_SIZE.  This only matters if we ever have
+	 * a machine with PAGE_SIZE < 4096
+	 */
+	max_receive = 1U << (priv->card->max_receive + 1);
+	num_packets = ( ipv4_iso_page_count * PAGE_SIZE ) / max_receive;
+	if ( ! priv->broadcast_rcv_context ) {
+		void **ptrptr;
+
+		context = fw_iso_context_create ( priv->card,
+ FW_ISO_CONTEXT_RECEIVE, BROADCAST_CHANNEL,
+ priv->card->link_speed, 8, ipv4_receive_broadcast, priv );
+		if (IS_ERR(context)) {
+			retval = PTR_ERR(context);
+			goto failed_context_create;
+		}
+		retval = fw_iso_buffer_init ( &priv->broadcast_rcv_buffer,
+ priv->card, ipv4_iso_page_count, DMA_FROM_DEVICE );
+		if ( retval < 0 )
+			goto failed_buffer_init;
+		ptrptr = kmalloc ( sizeof(void*)*num_packets, GFP_KERNEL );
+		if ( ! ptrptr ) {
+			retval = -ENOMEM;
+			goto failed_ptrs_alloc;
+		}
+		priv->broadcast_rcv_buffer_ptrs = ptrptr;
+		for ( u = 0; u < ipv4_iso_page_count; u++ ) {
+			void *ptr;
+			unsigned v;
+
+			ptr = kmap ( priv->broadcast_rcv_buffer.pages[u] );
+			for ( v = 0; v < num_packets / ipv4_iso_page_count; v++ )
+				*ptrptr++ = (void *)((char *)ptr + v * max_receive);
+		}
+		priv->broadcast_rcv_context = context;
+	} else
+		context = priv->broadcast_rcv_context;
+
+	packet.payload_length = max_receive;
+	packet.interrupt = 1;
+	packet.skip = 0;
+	packet.tag = 3;
+	packet.sy = 0;
+	packet.header_length = IPV4_GASP_OVERHEAD;
+	offset = 0;
+	for ( u = 0; u < num_packets; u++ ) {
+		retval = fw_iso_context_queue ( context, &packet,
+ &priv->broadcast_rcv_buffer, offset );
+		if ( retval < 0 )
+			goto failed_rcv_queue;
+		offset += max_receive;
+	}
+	priv->num_broadcast_rcv_ptrs = num_packets;
+	priv->rcv_buffer_size = max_receive;
+	priv->broadcast_rcv_next_ptr = 0U;
+	retval = fw_iso_context_start ( context, -1, 0, FW_ISO_CONTEXT_MATCH_ALL_TAGS ); /* ??? sync */
+	if ( retval < 0 )
+		goto failed_rcv_queue;
+	/* FIXME: adjust this when we know the max receive speeds of all other IP nodes on the bus. */
+	/* since we only xmt at S100 ??? */
+	priv->broadcast_xmt_max_payload = S100_BUFFER_SIZE - IPV4_GASP_OVERHEAD - IPV4_UNFRAG_HDR_SIZE;
+	priv->broadcast_state = IPV4_BROADCAST_RUNNING;
+	return 0;
+
+ failed_rcv_queue:
+	kfree ( priv->broadcast_rcv_buffer_ptrs );
+	priv->broadcast_rcv_buffer_ptrs = NULL;
+ failed_ptrs_alloc:
+	fw_iso_buffer_destroy ( &priv->broadcast_rcv_buffer, priv->card );
+ failed_buffer_init:
+	fw_iso_context_destroy ( context );
+	priv->broadcast_rcv_context = NULL;
+ failed_context_create:
+	fw_core_remove_address_handler ( &priv->handler );
+ failed_initial:
+	priv->local_fifo = INVALID_FIFO_ADDR;
+	return retval;
+}
+
+/* This is called after an "ifup" */
+static int ipv4_open(struct net_device *dev) {
+	struct ipv4_priv *priv;
+	int ret;
+
+	priv = netdev_priv(dev);
+	if (priv->broadcast_state == IPV4_BROADCAST_ERROR) {
+		ret = ipv4_broadcast_start ( priv );
+		if (ret)
+			return ret;
+	}
+	netif_start_queue(dev);
+	return 0;
+}
+
+/* This is called after an "ifdown" */
+static int ipv4_stop(struct net_device *netdev)
+{
+	/* flush priv->wake */
+	/* flush_scheduled_work(); */
+
+	netif_stop_queue(netdev);
+	return 0;
+}
+
+/* Transmit a packet (called by kernel) */
+static int ipv4_tx(struct sk_buff *skb, struct net_device *netdev)
+{
+	struct ipv4_ether_hdr hdr_buf;
+	struct ipv4_priv *priv = netdev_priv(netdev);
+	__be16 proto;
+	u16 dest_node;
+	enum ipv4_tx_type tx_type;
+	unsigned max_payload;
+	u16 dg_size;
+	u16 *datagram_label_ptr;
+	struct ipv4_packet_task *ptask;
+	struct ipv4_node *node = NULL;
+
+	ptask = kmem_cache_alloc(ipv4_packet_task_cache, GFP_ATOMIC);
+	if (ptask == NULL)
+		goto fail;
+
+	skb = skb_share_check(skb, GFP_ATOMIC);
+	if (!skb)
+		goto fail;
+
+	/*
+	 * Get rid of the fake ipv4 header, but first make a copy.
+	 * We might need to rebuild the header on tx failure.
+	 */
+	memcpy(&hdr_buf, skb->data, sizeof(hdr_buf));
+	skb_pull(skb, sizeof(hdr_buf));
+
+	proto = hdr_buf.h_proto;
+	dg_size = skb->len;
+
+	/*
+	 * Set the transmission type for the packet.  ARP packets and IP
+	 * broadcast packets are sent via GASP.
+	 */
+	if (   memcmp(hdr_buf.h_dest, netdev->broadcast, IPV4_ALEN) == 0
+	    || proto == htons(ETH_P_ARP)
+	    || (   proto == htons(ETH_P_IP)
+		&& IN_MULTICAST(ntohl(ip_hdr(skb)->daddr)) ) ) {
+		/* fw_debug ( "transmitting arp or multicast packet\n" );*/
+		tx_type = IPV4_GASP;
+		dest_node = ALL_NODES;
+		max_payload = priv->broadcast_xmt_max_payload;
+		/* BUG_ON(max_payload < S100_BUFFER_SIZE - IPV4_GASP_OVERHEAD); */
+		datagram_label_ptr = &priv->broadcast_xmt_datagramlabel;
+		ptask->fifo_addr = INVALID_FIFO_ADDR;
+		ptask->generation = 0U;
+		ptask->dest_node = 0U;
+		ptask->speed = 0;
+	} else {
+		__be64 guid = get_unaligned((u64 *)hdr_buf.h_dest);
+		u8 generation;
+
+		node = ipv4_node_find_by_guid(priv, be64_to_cpu(guid));
+		if (!node) {
+			fw_debug ( "Normal packet but no node\n" );
+			goto fail;
+		}
+
+		if (node->fifo == INVALID_FIFO_ADDR) {
+			fw_debug ( "Normal packet but no fifo addr\n" );
+			goto fail;
+		}
+
+		/* fw_debug ( "Transmitting normal packet to %x at %llxx\n", node->nodeid, node->fifo ); */
+		generation = node->generation;
+		dest_node = node->nodeid;
+		max_payload = node->max_payload;
+		/* BUG_ON(max_payload < S100_BUFFER_SIZE - IPV4_FRAG_HDR_SIZE); */
+
+		datagram_label_ptr = &node->datagram_label;
+		tx_type = IPV4_WRREQ;
+		ptask->fifo_addr = node->fifo;
+		ptask->generation = generation;
+		ptask->dest_node = dest_node;
+		ptask->speed = node->xmt_speed;
+	}
+
+	/* If this is an ARP packet, convert it */
+	if (proto == htons(ETH_P_ARP)) {
+		/* Convert a standard ARP packet to 1394 ARP. The first 8 bytes (the entire
+		 * arphdr) is the same format as the ip1394 header, so they overlap.  The rest
+		 * needs to be munged a bit.  The remainder of the arphdr is formatted based
+		 * on hwaddr len and ipaddr len.  We know what they'll be, so it's easy to
+		 * judge.
+		 *
+		 * Now that the EUI is used for the hardware address all we need to do to make
+		 * this work for 1394 is to insert 2 quadlets that contain max_rec size,
+		 * speed, and unicast FIFO address information between the sender_unique_id
+		 * and the IP addresses.
+		 */
+		struct arphdr *arp = (struct arphdr *)skb->data;
+		unsigned char *arp_ptr = (unsigned char *)(arp + 1);
+		struct ipv4_arp *arp1394 = (struct ipv4_arp *)skb->data;
+		u32 ipaddr;
+
+		ipaddr = *(u32*)(arp_ptr + IPV4_ALEN);
+		arp1394->hw_addr_len    = 16;
+		arp1394->max_rec        = priv->card->max_receive;
+		arp1394->sspd		= priv->card->link_speed;
+		arp1394->fifo_hi	= htons(priv->local_fifo >> 32);
+		arp1394->fifo_lo        = htonl(priv->local_fifo & 0xFFFFFFFF);
+		arp1394->sip		= ipaddr;
+	}
+	if ( ipv4_max_xmt && max_payload > ipv4_max_xmt )
+		max_payload = ipv4_max_xmt;
+
+	ptask->hdr.w0 = 0;
+	ptask->hdr.w1 = 0;
+	ptask->skb = skb;
+	ptask->priv = priv;
+        ptask->tx_type = tx_type;
+	/* Does it all fit in one packet? */
+	if ( dg_size <= max_payload ) {
+		ipv4_make_uf_hdr(&ptask->hdr, be16_to_cpu(proto));
+		ptask->outstanding_pkts = 1;
+		max_payload = dg_size + IPV4_UNFRAG_HDR_SIZE;
+	} else {
+		u16 datagram_label;
+
+		max_payload -= IPV4_FRAG_OVERHEAD;
+		datagram_label = (*datagram_label_ptr)++;
+		ipv4_make_ff_hdr(&ptask->hdr, be16_to_cpu(proto), dg_size, datagram_label );
+		ptask->outstanding_pkts = DIV_ROUND_UP(dg_size, max_payload);
+		max_payload += IPV4_FRAG_HDR_SIZE;
+	}
+	ptask->max_payload = max_payload;
+	ipv4_send_packet ( ptask );
+	return NETDEV_TX_OK;
+
+ fail:
+	if (ptask)
+		kmem_cache_free(ipv4_packet_task_cache, ptask);
+
+	if (skb != NULL)
+		dev_kfree_skb(skb);
+
+	netdev->stats.tx_dropped++;
+	netdev->stats.tx_errors++;
+
+	/*
+	 * FIXME: According to a patch from 2003-02-26, "returning non-zero
+	 * causes serious problems" here, allegedly.  Before that patch,
+	 * -ERRNO was returned which is not appropriate under Linux 2.6.
+	 * Perhaps more needs to be done?  Stop the queue in serious
+	 * conditions and restart it elsewhere?
+	 */
+	return NETDEV_TX_OK;
+}
+
+/*
+ * FIXME: What to do if we timeout? I think a host reset is probably in order,
+ * so that's what we do. Should we increment the stat counters too?
+ */
+static void ipv4_tx_timeout(struct net_device *dev) {
+	struct ipv4_priv *priv;
+
+	priv = netdev_priv(dev);
+	fw_error ( "%s: Timeout, resetting host\n", dev->name );
+#if 0 /* stefanr */
+	fw_core_initiate_bus_reset ( priv->card, 1 );
+#endif
+}
+
+static int ipv4_change_mtu ( struct net_device *dev, int new_mtu ) {
+#if 0
+	int max_mtu;
+	struct ipv4_priv *priv;
+#endif
+
+	if (new_mtu < 68)
+		return -EINVAL;
+
+#if 0
+	priv = netdev_priv(dev);
+	/* This is not actually true because we can fragment packets at the firewire layer */
+	max_mtu = (1 << (priv->card->max_receive + 1))
+		                - sizeof(struct ipv4_hdr) - IPV4_GASP_OVERHEAD;
+	if (new_mtu > max_mtu) {
+		fw_notify ( "%s: Local node constrains MTU to %d\n", dev->name, max_mtu);
+		return -ERANGE;
+	}
+#endif
+	dev->mtu = new_mtu;
+	return 0;
+}
+
+static void ipv4_get_drvinfo(struct net_device *dev,
+struct ethtool_drvinfo *info) {
+	strcpy(info->driver, ipv4_driver_name);
+	strcpy(info->bus_info, "ieee1394"); /* FIXME provide more detail? */
+}
+
+static struct ethtool_ops ipv4_ethtool_ops = {
+	.get_drvinfo = ipv4_get_drvinfo,
+};
+
+static const struct net_device_ops ipv4_netdev_ops = {
+	.ndo_open       = ipv4_open,
+	.ndo_stop	= ipv4_stop,
+	.ndo_start_xmit = ipv4_tx,
+	.ndo_tx_timeout = ipv4_tx_timeout,
+	.ndo_change_mtu = ipv4_change_mtu,
+};
+
+static void ipv4_init_dev ( struct net_device *dev ) {
+	dev->header_ops		= &ipv4_header_ops;
+	dev->netdev_ops         = &ipv4_netdev_ops;
+	SET_ETHTOOL_OPS(dev, &ipv4_ethtool_ops);
+
+	dev->watchdog_timeo	= IPV4_TIMEOUT;
+	dev->flags		= IFF_BROADCAST | IFF_MULTICAST;
+	dev->features		= NETIF_F_HIGHDMA;
+	dev->addr_len		= IPV4_ALEN;
+	dev->hard_header_len	= IPV4_HLEN;
+	dev->type		= ARPHRD_IEEE1394;
+
+	/* FIXME: This value was copied from ether_setup(). Is it too much? */
+	dev->tx_queue_len	= 1000;
+}
+
+static int ipv4_probe ( struct device *dev ) {
+	struct fw_unit * unit;
+	struct fw_device *device;
+	struct fw_card *card;
+	struct net_device *netdev;
+	struct ipv4_priv *priv;
+	unsigned max_mtu;
+	__be64 guid;
+
+	fw_debug("ipv4 Probing\n" );
+	unit = fw_unit ( dev );
+	device = fw_device ( unit->device.parent );
+	card = device->card;
+
+	if ( ! device->is_local ) {
+		int added;
+
+		fw_debug ( "Non-local, adding remote node entry\n" );
+		added = ipv4_node_new ( card, device );
+		return added;
+	}
+	fw_debug("ipv4 Local: adding netdev\n" );
+	netdev = alloc_netdev ( sizeof(*priv), "firewire%d", ipv4_init_dev );
+	if ( netdev == NULL) {
+		fw_error( "Out of memory\n");
+		goto out;
+	}
+
+	SET_NETDEV_DEV(netdev, card->device);
+	priv = netdev_priv(netdev);
+
+	spin_lock_init(&priv->lock);
+	priv->broadcast_state = IPV4_BROADCAST_ERROR;
+	priv->broadcast_rcv_context = NULL;
+	priv->broadcast_xmt_max_payload = 0;
+	priv->broadcast_xmt_datagramlabel = 0;
+
+	priv->local_fifo = INVALID_FIFO_ADDR;
+
+	/* INIT_WORK(&priv->wake, ipv4_handle_queue);*/
+	INIT_LIST_HEAD(&priv->packet_list);
+	INIT_LIST_HEAD(&priv->broadcasted_list);
+	INIT_LIST_HEAD(&priv->sent_list );
+
+	priv->card = card;
+
+	/*
+	 * Use the RFC 2734 default 1500 octets or the maximum payload
+	 * as initial MTU
+	 */
+	max_mtu = (1 << (card->max_receive + 1))
+		  - sizeof(struct ipv4_hdr) - IPV4_GASP_OVERHEAD;
+	netdev->mtu = min(1500U, max_mtu);
+
+	/* Set our hardware address while we're at it */
+	guid = cpu_to_be64(card->guid);
+	memcpy(netdev->dev_addr, &guid, sizeof(u64));
+	memset(netdev->broadcast, 0xff, sizeof(u64));
+	if ( register_netdev ( netdev ) ) {
+		fw_error ( "Cannot register the driver\n");
+		goto out;
+	}
+
+	fw_notify ( "%s: IPv4 over Firewire on device %016llx\n",
+ netdev->name, card->guid );
+	card->netdev = netdev;
+
+	return 0 /* ipv4_new_node ( ud ) */;
+ out:
+	if ( netdev )
+		free_netdev ( netdev );
+	return -ENOENT;
+}
+
+
+static int ipv4_remove ( struct device *dev ) {
+	struct fw_unit * unit;
+	struct fw_device *device;
+	struct fw_card *card;
+	struct net_device *netdev;
+	struct ipv4_priv *priv;
+	struct ipv4_node *node;
+	struct ipv4_partial_datagram *pd, *pd_next;
+	struct ipv4_packet_task *ptask, *pt_next;
+
+	fw_debug("ipv4 Removing\n" );
+	unit = fw_unit ( dev );
+	device = fw_device ( unit->device.parent );
+	card = device->card;
+
+	if ( ! device->is_local ) {
+		fw_debug ( "Node %x is non-local, removing remote node entry\n", device->node_id );
+		ipv4_node_delete ( card, device );
+		return 0;
+	}
+	netdev = card->netdev;
+	if ( netdev ) {
+		fw_debug ( "Node %x is local: deleting netdev\n", device->node_id );
+		priv = netdev_priv ( netdev );
+		unregister_netdev ( netdev );
+		fw_debug ( "unregistered\n" );
+		if ( priv->local_fifo != INVALID_FIFO_ADDR )
+			fw_core_remove_address_handler ( &priv->handler );
+		fw_debug ( "address handler gone\n" );
+		if ( priv->broadcast_rcv_context ) {
+			fw_iso_context_stop ( priv->broadcast_rcv_context );
+			fw_iso_buffer_destroy ( &priv->broadcast_rcv_buffer, priv->card );
+			fw_iso_context_destroy ( priv->broadcast_rcv_context );
+			fw_debug ( "rcv stopped\n" );
+		}
+		list_for_each_entry_safe( ptask, pt_next, &priv->packet_list, packet_list ) {
+			dev_kfree_skb_any ( ptask->skb );
+			kmem_cache_free( ipv4_packet_task_cache, ptask );
+		}
+		list_for_each_entry_safe( ptask, pt_next, &priv->broadcasted_list, packet_list ) {
+			dev_kfree_skb_any ( ptask->skb );
+			kmem_cache_free( ipv4_packet_task_cache, ptask );
+		}
+		list_for_each_entry_safe( ptask, pt_next, &priv->sent_list, packet_list ) {
+			dev_kfree_skb_any ( ptask->skb );
+			kmem_cache_free( ipv4_packet_task_cache, ptask );
+		}
+		fw_debug ( "lists emptied\n" );
+		list_for_each_entry( node, &card->ipv4_nodes, ipv4_nodes ) {
+			if ( node->pdg_size ) {
+				list_for_each_entry_safe( pd, pd_next, &node->pdg_list, pdg_list )
+					ipv4_pd_delete ( pd );
+				node->pdg_size = 0;
+			}
+			node->fifo = INVALID_FIFO_ADDR;
+		}
+		fw_debug ( "nodes cleaned up\n" );
+		free_netdev ( netdev );
+		card->netdev = NULL;
+		fw_debug ( "done\n" );
+	}
+	return 0;
+}
+
+static void ipv4_update ( struct fw_unit *unit ) {
+	struct fw_device *device;
+	struct fw_card *card;
+
+	fw_debug ( "ipv4_update unit %p\n", unit );
+	device = fw_device ( unit->device.parent );
+	card = device->card;
+	if ( ! device->is_local ) {
+		struct ipv4_node *node;
+		u64 guid;
+		struct net_device *netdev;
+		struct ipv4_priv *priv;
+
+		netdev = card->netdev;
+		if ( netdev ) {
+			priv = netdev_priv ( netdev );
+			guid = (u64)device->config_rom[3] << 32 | device->config_rom[4];
+			node = ipv4_node_find_by_guid ( priv, guid );
+			if ( ! node ) {
+				fw_error ( "ipv4_update: no node for device %llx\n", guid );
+				return;
+			}
+			fw_debug ( "Non-local, updating remote node entry for guid %llx old generation %x, old nodeid %x\n", guid, node->generation, node->nodeid );
+			node->generation = device->generation;
+			rmb();
+			node->nodeid = device->node_id;
+			fw_debug ( "New generation %x, new nodeid %x\n", node->generation, node->nodeid );
+		} else
+			fw_error ( "nonlocal, but no netdev?  How can that be?\n" );
+	} else {
+		/* FIXME: What do we need to do on bus reset? */
+		fw_debug ( "Local, doing nothing\n" );
+	}
+}
+
+static struct fw_driver ipv4_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = ipv4_driver_name,
+		.bus = &fw_bus_type,
+		.probe = ipv4_probe,
+		.remove = ipv4_remove,
+	},
+	.update = ipv4_update,
+	.id_table = ipv4_id_table,
+};
+
+static int __init ipv4_init ( void ) {
+	int added;
+
+	added = fw_core_add_descriptor ( &ipv4_unit_directory );
+	if ( added < 0 )
+		fw_error ( "Failed to add descriptor" );
+	ipv4_packet_task_cache = kmem_cache_create("packet_task",
+ sizeof(struct ipv4_packet_task), 0, 0, NULL);
+	fw_debug("Adding ipv4 module\n" );
+	return driver_register ( &ipv4_driver.driver );
+}
+
+static void __exit ipv4_cleanup ( void ) {
+	fw_core_remove_descriptor ( &ipv4_unit_directory );
+	fw_debug("Removing ipv4 module\n" );
+	driver_unregister ( &ipv4_driver.driver );
+}
+
+module_init(ipv4_init);
+module_exit(ipv4_cleanup);
