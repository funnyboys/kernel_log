commit c38e7e212acdb52dc8c0553340050b02e4a3f848
Author: Gustavo A. R. Silva <gustavoars@kernel.org>
Date:   Thu May 28 09:35:11 2020 -0500

    firewire: ohci: Replace zero-length array with flexible-array
    
    There is a regular need in the kernel to provide a way to declare having a
    dynamically sized set of trailing elements in a structure. Kernel code should
    always use “flexible array members”[1] for these cases. The older style of
    one-element or zero-length arrays should no longer be used[2].
    
    [1] https://en.wikipedia.org/wiki/Flexible_array_member
    [2] https://github.com/KSPP/linux/issues/21
    
    Signed-off-by: Gustavo A. R. Silva <gustavoars@kernel.org>

diff --git a/drivers/firewire/nosy.c b/drivers/firewire/nosy.c
index 6ca2f5ab6c57..5fd6a60b6741 100644
--- a/drivers/firewire/nosy.c
+++ b/drivers/firewire/nosy.c
@@ -52,7 +52,7 @@ struct pcl {
 
 struct packet {
 	unsigned int length;
-	char data[0];
+	char data[];
 };
 
 struct packet_buffer {

commit 4bdc0d676a643140bdf17dbf7eafedee3d496a3c
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Jan 6 09:43:50 2020 +0100

    remove ioremap_nocache and devm_ioremap_nocache
    
    ioremap has provided non-cached semantics by default since the Linux 2.6
    days, so remove the additional ioremap_nocache interface.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/drivers/firewire/nosy.c b/drivers/firewire/nosy.c
index 0cc746673677..6ca2f5ab6c57 100644
--- a/drivers/firewire/nosy.c
+++ b/drivers/firewire/nosy.c
@@ -551,7 +551,7 @@ add_card(struct pci_dev *dev, const struct pci_device_id *unused)
 	INIT_LIST_HEAD(&lynx->client_list);
 	kref_init(&lynx->kref);
 
-	lynx->registers = ioremap_nocache(pci_resource_start(dev, 0),
+	lynx->registers = ioremap(pci_resource_start(dev, 0),
 					  PCILYNX_MAX_REGISTER);
 	if (lynx->registers == NULL) {
 		dev_err(&dev->dev, "Failed to map registers\n");

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/firewire/nosy.c b/drivers/firewire/nosy.c
index 515e96db4391..0cc746673677 100644
--- a/drivers/firewire/nosy.c
+++ b/drivers/firewire/nosy.c
@@ -1,20 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * nosy - Snoop mode driver for TI PCILynx 1394 controllers
  * Copyright (C) 2002-2007 Kristian Høgsberg
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
 #include <linux/device.h>

commit c5bf68fe0c86a5835bd2e6aead1c49976360753f
Author: Kirill Smelkov <kirr@nexedi.com>
Date:   Tue Mar 26 23:51:19 2019 +0300

    *: convert stream-like files from nonseekable_open -> stream_open
    
    Using scripts/coccinelle/api/stream_open.cocci added in 10dce8af3422
    ("fs: stream_open - opener for stream-like files so that read and write
    can run simultaneously without deadlock"), search and convert to
    stream_open all in-kernel nonseekable_open users for which read and
    write actually do not depend on ppos and where there is no other methods
    in file_operations which assume @offset access.
    
    I've verified each generated change manually - that it is correct to convert -
    and each other nonseekable_open instance left - that it is either not correct
    to convert there, or that it is not converted due to current stream_open.cocci
    limitations. The script also does not convert files that should be valid to
    convert, but that currently have .llseek = noop_llseek or generic_file_llseek
    for unknown reason despite file being opened with nonseekable_open (e.g.
    drivers/input/mousedev.c)
    
    Among cases converted 14 were potentially vulnerable to read vs write deadlock
    (see details in 10dce8af3422):
    
            drivers/char/pcmcia/cm4000_cs.c:1685:7-23: ERROR: cm4000_fops: .read() can deadlock .write(); change nonseekable_open -> stream_open to fix.
            drivers/gnss/core.c:45:1-17: ERROR: gnss_fops: .read() can deadlock .write(); change nonseekable_open -> stream_open to fix.
            drivers/hid/uhid.c:635:1-17: ERROR: uhid_fops: .read() can deadlock .write(); change nonseekable_open -> stream_open to fix.
            drivers/infiniband/core/user_mad.c:988:1-17: ERROR: umad_fops: .read() can deadlock .write(); change nonseekable_open -> stream_open to fix.
            drivers/input/evdev.c:527:1-17: ERROR: evdev_fops: .read() can deadlock .write(); change nonseekable_open -> stream_open to fix.
            drivers/input/misc/uinput.c:401:1-17: ERROR: uinput_fops: .read() can deadlock .write(); change nonseekable_open -> stream_open to fix.
            drivers/isdn/capi/capi.c:963:8-24: ERROR: capi_fops: .read() can deadlock .write(); change nonseekable_open -> stream_open to fix.
            drivers/leds/uleds.c:77:1-17: ERROR: uleds_fops: .read() can deadlock .write(); change nonseekable_open -> stream_open to fix.
            drivers/media/rc/lirc_dev.c:198:1-17: ERROR: lirc_fops: .read() can deadlock .write(); change nonseekable_open -> stream_open to fix.
            drivers/s390/char/fs3270.c:488:1-17: ERROR: fs3270_fops: .read() can deadlock .write(); change nonseekable_open -> stream_open to fix.
            drivers/usb/misc/ldusb.c:310:1-17: ERROR: ld_usb_fops: .read() can deadlock .write(); change nonseekable_open -> stream_open to fix.
            drivers/xen/evtchn.c:667:8-24: ERROR: evtchn_fops: .read() can deadlock .write(); change nonseekable_open -> stream_open to fix.
            net/batman-adv/icmp_socket.c:80:1-17: ERROR: batadv_fops: .read() can deadlock .write(); change nonseekable_open -> stream_open to fix.
            net/rfkill/core.c:1146:8-24: ERROR: rfkill_fops: .read() can deadlock .write(); change nonseekable_open -> stream_open to fix.
    
    and the rest were just safe to convert to stream_open because their read and
    write do not use ppos at all and corresponding file_operations do not
    have methods that assume @offset file access(*):
    
            arch/powerpc/platforms/52xx/mpc52xx_gpt.c:631:8-24: WARNING: mpc52xx_wdt_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            arch/powerpc/platforms/cell/spufs/file.c:591:8-24: WARNING: spufs_ibox_fops: .read() has stream semantic; safe to change nonseekable_open -> stream_open.
            arch/powerpc/platforms/cell/spufs/file.c:591:8-24: WARNING: spufs_ibox_stat_fops: .read() has stream semantic; safe to change nonseekable_open -> stream_open.
            arch/powerpc/platforms/cell/spufs/file.c:591:8-24: WARNING: spufs_mbox_fops: .read() has stream semantic; safe to change nonseekable_open -> stream_open.
            arch/powerpc/platforms/cell/spufs/file.c:591:8-24: WARNING: spufs_mbox_stat_fops: .read() has stream semantic; safe to change nonseekable_open -> stream_open.
            arch/powerpc/platforms/cell/spufs/file.c:591:8-24: WARNING: spufs_wbox_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            arch/powerpc/platforms/cell/spufs/file.c:591:8-24: WARNING: spufs_wbox_stat_fops: .read() has stream semantic; safe to change nonseekable_open -> stream_open.
            arch/um/drivers/harddog_kern.c:88:8-24: WARNING: harddog_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            arch/x86/kernel/cpu/microcode/core.c:430:33-49: WARNING: microcode_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/char/ds1620.c:215:8-24: WARNING: ds1620_fops: .read() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/char/dtlk.c:301:1-17: WARNING: dtlk_fops: .read() and .write() have stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/char/ipmi/ipmi_watchdog.c:840:9-25: WARNING: ipmi_wdog_fops: .read() and .write() have stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/char/pcmcia/scr24x_cs.c:95:8-24: WARNING: scr24x_fops: .read() and .write() have stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/char/tb0219.c:246:9-25: WARNING: tb0219_fops: .read() and .write() have stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/firewire/nosy.c:306:8-24: WARNING: nosy_ops: .read() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/hwmon/fschmd.c:840:8-24: WARNING: watchdog_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/hwmon/w83793.c:1344:8-24: WARNING: watchdog_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/infiniband/core/ucma.c:1747:8-24: WARNING: ucma_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/infiniband/core/ucm.c:1178:8-24: WARNING: ucm_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/infiniband/core/uverbs_main.c:1086:8-24: WARNING: uverbs_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/input/joydev.c:282:1-17: WARNING: joydev_fops: .read() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/pci/switch/switchtec.c:393:1-17: WARNING: switchtec_fops: .read() and .write() have stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/platform/chrome/cros_ec_debugfs.c:135:8-24: WARNING: cros_ec_console_log_fops: .read() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/rtc/rtc-ds1374.c:470:9-25: WARNING: ds1374_wdt_fops: .read() and .write() have stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/rtc/rtc-m41t80.c:805:9-25: WARNING: wdt_fops: .read() and .write() have stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/s390/char/tape_char.c:293:2-18: WARNING: tape_fops: .read() and .write() have stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/s390/char/zcore.c:194:8-24: WARNING: zcore_reipl_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/s390/crypto/zcrypt_api.c:528:8-24: WARNING: zcrypt_fops: .read() and .write() have stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/spi/spidev.c:594:1-17: WARNING: spidev_fops: .read() and .write() have stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/staging/pi433/pi433_if.c:974:1-17: WARNING: pi433_fops: .read() and .write() have stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/acquirewdt.c:203:8-24: WARNING: acq_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/advantechwdt.c:202:8-24: WARNING: advwdt_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/alim1535_wdt.c:252:8-24: WARNING: ali_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/alim7101_wdt.c:217:8-24: WARNING: wdt_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/ar7_wdt.c:166:8-24: WARNING: ar7_wdt_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/at91rm9200_wdt.c:113:8-24: WARNING: at91wdt_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/ath79_wdt.c:135:8-24: WARNING: ath79_wdt_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/bcm63xx_wdt.c:119:8-24: WARNING: bcm63xx_wdt_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/cpu5wdt.c:143:8-24: WARNING: cpu5wdt_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/cpwd.c:397:8-24: WARNING: cpwd_fops: .read() and .write() have stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/eurotechwdt.c:319:8-24: WARNING: eurwdt_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/f71808e_wdt.c:528:8-24: WARNING: watchdog_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/gef_wdt.c:232:8-24: WARNING: gef_wdt_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/geodewdt.c:95:8-24: WARNING: geodewdt_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/ib700wdt.c:241:8-24: WARNING: ibwdt_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/ibmasr.c:326:8-24: WARNING: asr_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/indydog.c:80:8-24: WARNING: indydog_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/intel_scu_watchdog.c:307:8-24: WARNING: intel_scu_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/iop_wdt.c:104:8-24: WARNING: iop_wdt_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/it8712f_wdt.c:330:8-24: WARNING: it8712f_wdt_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/ixp4xx_wdt.c:68:8-24: WARNING: ixp4xx_wdt_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/ks8695_wdt.c:145:8-24: WARNING: ks8695wdt_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/m54xx_wdt.c:88:8-24: WARNING: m54xx_wdt_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/machzwd.c:336:8-24: WARNING: zf_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/mixcomwd.c:153:8-24: WARNING: mixcomwd_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/mtx-1_wdt.c:121:8-24: WARNING: mtx1_wdt_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/mv64x60_wdt.c:136:8-24: WARNING: mv64x60_wdt_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/nuc900_wdt.c:134:8-24: WARNING: nuc900wdt_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/nv_tco.c:164:8-24: WARNING: nv_tco_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/pc87413_wdt.c:289:8-24: WARNING: pc87413_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/pcwd.c:698:8-24: WARNING: pcwd_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/pcwd.c:737:8-24: WARNING: pcwd_temp_fops: .read() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/pcwd_pci.c:581:8-24: WARNING: pcipcwd_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/pcwd_pci.c:623:8-24: WARNING: pcipcwd_temp_fops: .read() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/pcwd_usb.c:488:8-24: WARNING: usb_pcwd_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/pcwd_usb.c:527:8-24: WARNING: usb_pcwd_temperature_fops: .read() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/pika_wdt.c:121:8-24: WARNING: pikawdt_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/pnx833x_wdt.c:119:8-24: WARNING: pnx833x_wdt_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/rc32434_wdt.c:153:8-24: WARNING: rc32434_wdt_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/rdc321x_wdt.c:145:8-24: WARNING: rdc321x_wdt_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/riowd.c:79:1-17: WARNING: riowd_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/sa1100_wdt.c:62:8-24: WARNING: sa1100dog_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/sbc60xxwdt.c:211:8-24: WARNING: wdt_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/sbc7240_wdt.c:139:8-24: WARNING: wdt_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/sbc8360.c:274:8-24: WARNING: sbc8360_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/sbc_epx_c3.c:81:8-24: WARNING: epx_c3_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/sbc_fitpc2_wdt.c:78:8-24: WARNING: fitpc2_wdt_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/sb_wdog.c:108:1-17: WARNING: sbwdog_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/sc1200wdt.c:181:8-24: WARNING: sc1200wdt_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/sc520_wdt.c:261:8-24: WARNING: wdt_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/sch311x_wdt.c:319:8-24: WARNING: sch311x_wdt_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/scx200_wdt.c:105:8-24: WARNING: scx200_wdt_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/smsc37b787_wdt.c:369:8-24: WARNING: wb_smsc_wdt_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/w83877f_wdt.c:227:8-24: WARNING: wdt_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/w83977f_wdt.c:301:8-24: WARNING: wdt_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/wafer5823wdt.c:200:8-24: WARNING: wafwdt_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/watchdog_dev.c:828:8-24: WARNING: watchdog_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/wdrtas.c:379:8-24: WARNING: wdrtas_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/wdrtas.c:445:8-24: WARNING: wdrtas_temp_fops: .read() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/wdt285.c:104:1-17: WARNING: watchdog_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/wdt977.c:276:8-24: WARNING: wdt977_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/wdt.c:424:8-24: WARNING: wdt_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/wdt.c:484:8-24: WARNING: wdt_temp_fops: .read() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/wdt_pci.c:464:8-24: WARNING: wdtpci_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/wdt_pci.c:527:8-24: WARNING: wdtpci_temp_fops: .read() has stream semantic; safe to change nonseekable_open -> stream_open.
            net/batman-adv/log.c:105:1-17: WARNING: batadv_log_fops: .read() has stream semantic; safe to change nonseekable_open -> stream_open.
            sound/core/control.c:57:7-23: WARNING: snd_ctl_f_ops: .read() has stream semantic; safe to change nonseekable_open -> stream_open.
            sound/core/rawmidi.c:385:7-23: WARNING: snd_rawmidi_f_ops: .read() and .write() have stream semantic; safe to change nonseekable_open -> stream_open.
            sound/core/seq/seq_clientmgr.c:310:7-23: WARNING: snd_seq_f_ops: .read() and .write() have stream semantic; safe to change nonseekable_open -> stream_open.
            sound/core/timer.c:1428:7-23: WARNING: snd_timer_f_ops: .read() has stream semantic; safe to change nonseekable_open -> stream_open.
    
    One can also recheck/review the patch via generating it with explanation comments included via
    
            $ make coccicheck MODE=patch COCCI=scripts/coccinelle/api/stream_open.cocci SPFLAGS="-D explain"
    
    (*) This second group also contains cases with read/write deadlocks that
    stream_open.cocci don't yet detect, but which are still valid to convert to
    stream_open since ppos is not used. For example drivers/pci/switch/switchtec.c
    calls wait_for_completion_interruptible() in its .read, but stream_open.cocci
    currently detects only "wait_event*" as blocking.
    
    Cc: Michael Kerrisk <mtk.manpages@gmail.com>
    Cc: Yongzhi Pan <panyongzhi@gmail.com>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: David Vrabel <david.vrabel@citrix.com>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: Miklos Szeredi <miklos@szeredi.hu>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Kirill Tkhai <ktkhai@virtuozzo.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Julia Lawall <Julia.Lawall@lip6.fr>
    Cc: Nikolaus Rath <Nikolaus@rath.org>
    Cc: Han-Wen Nienhuys <hanwen@google.com>
    Cc: Anatolij Gustschin <agust@denx.de>
    Cc: Jeff Dike <jdike@addtoit.com>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Anton Ivanov <anton.ivanov@cambridgegreys.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: "James R. Van Zandt" <jrv@vanzandt.mv.com>
    Cc: Corey Minyard <minyard@acm.org>
    Cc: Harald Welte <laforge@gnumonks.org>
    Acked-by: Lubomir Rintel <lkundrak@v3.sk> [scr24x_cs]
    Cc: Stefan Richter <stefanr@s5r6.in-berlin.de>
    Cc: Johan Hovold <johan@kernel.org>
    Cc: David Herrmann <dh.herrmann@googlemail.com>
    Cc: Jiri Kosina <jikos@kernel.org>
    Cc: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Cc: Jean Delvare <jdelvare@suse.com>
    Acked-by: Guenter Roeck <linux@roeck-us.net>    [watchdog/* hwmon/*]
    Cc: Rudolf Marek <r.marek@assembler.cz>
    Cc: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Cc: Karsten Keil <isdn@linux-pingi.de>
    Cc: Jacek Anaszewski <jacek.anaszewski@gmail.com>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Mauro Carvalho Chehab <mchehab@kernel.org>
    Cc: Kurt Schwemmer <kurt.schwemmer@microsemi.com>
    Acked-by: Logan Gunthorpe <logang@deltatee.com> [drivers/pci/switch/switchtec]
    Acked-by: Bjorn Helgaas <bhelgaas@google.com> [drivers/pci/switch/switchtec]
    Cc: Benson Leung <bleung@chromium.org>
    Acked-by: Enric Balletbo i Serra <enric.balletbo@collabora.com> [platform/chrome]
    Cc: Alessandro Zummo <a.zummo@towertech.it>
    Acked-by: Alexandre Belloni <alexandre.belloni@bootlin.com> [rtc/*]
    Cc: Mark Brown <broonie@kernel.org>
    Cc: Wim Van Sebroeck <wim@linux-watchdog.org>
    Cc: Florian Fainelli <f.fainelli@gmail.com>
    Cc: bcm-kernel-feedback-list@broadcom.com
    Cc: Wan ZongShun <mcuos.com@gmail.com>
    Cc: Zwane Mwaikambo <zwanem@gmail.com>
    Cc: Marek Lindner <mareklindner@neomailbox.ch>
    Cc: Simon Wunderlich <sw@simonwunderlich.de>
    Cc: Antonio Quartulli <a@unstable.cc>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Johannes Berg <johannes@sipsolutions.net>
    Cc: Jaroslav Kysela <perex@perex.cz>
    Cc: Takashi Iwai <tiwai@suse.com>
    Signed-off-by: Kirill Smelkov <kirr@nexedi.com>

diff --git a/drivers/firewire/nosy.c b/drivers/firewire/nosy.c
index a128dd1126ae..515e96db4391 100644
--- a/drivers/firewire/nosy.c
+++ b/drivers/firewire/nosy.c
@@ -303,7 +303,7 @@ nosy_open(struct inode *inode, struct file *file)
 
 	file->private_data = client;
 
-	return nonseekable_open(inode, file);
+	return stream_open(inode, file);
 fail:
 	kfree(client);
 	lynx_put(lynx);

commit a9a08845e9acbd224e4ee466f5c1275ed50054e8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Feb 11 14:34:03 2018 -0800

    vfs: do bulk POLL* -> EPOLL* replacement
    
    This is the mindless scripted replacement of kernel use of POLL*
    variables as described by Al, done by this script:
    
        for V in IN OUT PRI ERR RDNORM RDBAND WRNORM WRBAND HUP RDHUP NVAL MSG; do
            L=`git grep -l -w POLL$V | grep -v '^t' | grep -v /um/ | grep -v '^sa' | grep -v '/poll.h$'|grep -v '^D'`
            for f in $L; do sed -i "-es/^\([^\"]*\)\(\<POLL$V\>\)/\\1E\\2/" $f; done
        done
    
    with de-mangling cleanups yet to come.
    
    NOTE! On almost all architectures, the EPOLL* constants have the same
    values as the POLL* constants do.  But they keyword here is "almost".
    For various bad reasons they aren't the same, and epoll() doesn't
    actually work quite correctly in some cases due to this on Sparc et al.
    
    The next patch from Al will sort out the final differences, and we
    should be all done.
    
    Scripted-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/firewire/nosy.c b/drivers/firewire/nosy.c
index fee2e9e7ea20..a128dd1126ae 100644
--- a/drivers/firewire/nosy.c
+++ b/drivers/firewire/nosy.c
@@ -337,10 +337,10 @@ nosy_poll(struct file *file, poll_table *pt)
 	poll_wait(file, &client->buffer.wait, pt);
 
 	if (atomic_read(&client->buffer.size) > 0)
-		ret = POLLIN | POLLRDNORM;
+		ret = EPOLLIN | EPOLLRDNORM;
 
 	if (list_empty(&client->lynx->link))
-		ret |= POLLHUP;
+		ret |= EPOLLHUP;
 
 	return ret;
 }

commit afc9a42b7464f76e1388cad87d8543c69f6f74ed
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Jul 3 06:39:46 2017 -0400

    the rest of drivers/*: annotate ->poll() instances
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/firewire/nosy.c b/drivers/firewire/nosy.c
index 180f0a96528c..fee2e9e7ea20 100644
--- a/drivers/firewire/nosy.c
+++ b/drivers/firewire/nosy.c
@@ -328,11 +328,11 @@ nosy_release(struct inode *inode, struct file *file)
 	return 0;
 }
 
-static unsigned int
+static __poll_t
 nosy_poll(struct file *file, poll_table *pt)
 {
 	struct client *client = file->private_data;
-	unsigned int ret = 0;
+	__poll_t ret = 0;
 
 	poll_wait(file, &client->buffer.wait, pt);
 

commit 6449e31ddebdce68508cfaf0915d31aad3835f4f
Author: Alexey Khoroshilov <khoroshilov@ispras.ru>
Date:   Sun Sep 25 00:19:05 2016 +0300

    firewire: nosy: do not ignore errors in ioremap_nocache()
    
    There is no check if ioremap_nocache() returns a valid pointer.
    Potentially it can lead to null pointer dereference.
    
    Found by Linux Driver Verification project (linuxtesting.org).
    
    Signed-off-by: Alexey Khoroshilov <khoroshilov@ispras.ru>
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de> (renamed goto labels)

diff --git a/drivers/firewire/nosy.c b/drivers/firewire/nosy.c
index 631c977b0da5..180f0a96528c 100644
--- a/drivers/firewire/nosy.c
+++ b/drivers/firewire/nosy.c
@@ -566,6 +566,11 @@ add_card(struct pci_dev *dev, const struct pci_device_id *unused)
 
 	lynx->registers = ioremap_nocache(pci_resource_start(dev, 0),
 					  PCILYNX_MAX_REGISTER);
+	if (lynx->registers == NULL) {
+		dev_err(&dev->dev, "Failed to map registers\n");
+		ret = -ENOMEM;
+		goto fail_deallocate_lynx;
+	}
 
 	lynx->rcv_start_pcl = pci_alloc_consistent(lynx->pci_device,
 				sizeof(struct pcl), &lynx->rcv_start_pcl_bus);
@@ -578,7 +583,7 @@ add_card(struct pci_dev *dev, const struct pci_device_id *unused)
 	    lynx->rcv_buffer == NULL) {
 		dev_err(&dev->dev, "Failed to allocate receive buffer\n");
 		ret = -ENOMEM;
-		goto fail_deallocate;
+		goto fail_deallocate_buffers;
 	}
 	lynx->rcv_start_pcl->next	= cpu_to_le32(lynx->rcv_pcl_bus);
 	lynx->rcv_pcl->next		= cpu_to_le32(PCL_NEXT_INVALID);
@@ -641,7 +646,7 @@ add_card(struct pci_dev *dev, const struct pci_device_id *unused)
 		dev_err(&dev->dev,
 			"Failed to allocate shared interrupt %d\n", dev->irq);
 		ret = -EIO;
-		goto fail_deallocate;
+		goto fail_deallocate_buffers;
 	}
 
 	lynx->misc.parent = &dev->dev;
@@ -668,7 +673,7 @@ add_card(struct pci_dev *dev, const struct pci_device_id *unused)
 	reg_write(lynx, PCI_INT_ENABLE, 0);
 	free_irq(lynx->pci_device->irq, lynx);
 
-fail_deallocate:
+fail_deallocate_buffers:
 	if (lynx->rcv_start_pcl)
 		pci_free_consistent(lynx->pci_device, sizeof(struct pcl),
 				lynx->rcv_start_pcl, lynx->rcv_start_pcl_bus);
@@ -679,6 +684,8 @@ add_card(struct pci_dev *dev, const struct pci_device_id *unused)
 		pci_free_consistent(lynx->pci_device, PAGE_SIZE,
 				lynx->rcv_buffer, lynx->rcv_buffer_bus);
 	iounmap(lynx->registers);
+
+fail_deallocate_lynx:
 	kfree(lynx);
 
 fail_disable:

commit 384fbb96f9268eee0b703b39cb07557403bd9aac
Author: Tina Ruchandani <ruchandani.tina@gmail.com>
Date:   Sun Mar 20 22:59:11 2016 -0700

    firewire: nosy: Replace timeval with timespec64
    
    'struct timeval' uses a 32 bit field for its 'seconds' value which
    will overflow in year 2038 and beyond. This patch replaces the use
    of timeval in nosy.c with timespec64 which doesn't suffer from y2038
    issue. The code is correct as is - since it is only using the
    microseconds portion of timeval. However, this patch does the
    replacement as part of a larger effort to remove all instances of
    'struct timeval' from the kernel (that would help identify cases
    where the code is actually broken).
    
    Signed-off-by: Tina Ruchandani <ruchandani.tina@gmail.com>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/nosy.c b/drivers/firewire/nosy.c
index 8a46077129ac..631c977b0da5 100644
--- a/drivers/firewire/nosy.c
+++ b/drivers/firewire/nosy.c
@@ -446,14 +446,16 @@ static void
 bus_reset_irq_handler(struct pcilynx *lynx)
 {
 	struct client *client;
-	struct timeval tv;
+	struct timespec64 ts64;
+	u32    timestamp;
 
-	do_gettimeofday(&tv);
+	ktime_get_real_ts64(&ts64);
+	timestamp = ts64.tv_nsec / NSEC_PER_USEC;
 
 	spin_lock(&lynx->client_list_lock);
 
 	list_for_each_entry(client, &lynx->client_list, link)
-		packet_buffer_put(&client->buffer, &tv.tv_usec, 4);
+		packet_buffer_put(&client->buffer, &timestamp, 4);
 
 	spin_unlock(&lynx->client_list_lock);
 }

commit 2ae4b6b20e2004dccf80d804ae52b073377c2f5b
Author: Amitoj Kaur Chawla <amitoj1606@gmail.com>
Date:   Thu Oct 22 04:05:00 2015 +0530

    firewire: nosy: Replace timeval with timespec64
    
    32 bit systems using 'struct timeval' will break in the year 2038, so
    we replace the code appropriately. However, this driver is not broken
    in 2038 since we are using only the microseconds portion of the
    current time.
    
    This patch replaces timeval with timespec64.
    
    Signed-off-by: Amitoj Kaur Chawla <amitoj1606@gmail.com>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/nosy.c b/drivers/firewire/nosy.c
index 76b2d390f6ec..8a46077129ac 100644
--- a/drivers/firewire/nosy.c
+++ b/drivers/firewire/nosy.c
@@ -33,6 +33,7 @@
 #include <linux/sched.h> /* required for linux/wait.h */
 #include <linux/slab.h>
 #include <linux/spinlock.h>
+#include <linux/time64.h>
 #include <linux/timex.h>
 #include <linux/uaccess.h>
 #include <linux/wait.h>
@@ -413,17 +414,18 @@ static void
 packet_irq_handler(struct pcilynx *lynx)
 {
 	struct client *client;
-	u32 tcode_mask, tcode;
+	u32 tcode_mask, tcode, timestamp;
 	size_t length;
-	struct timeval tv;
+	struct timespec64 ts64;
 
 	/* FIXME: Also report rcv_speed. */
 
 	length = __le32_to_cpu(lynx->rcv_pcl->pcl_status) & 0x00001fff;
 	tcode  = __le32_to_cpu(lynx->rcv_buffer[1]) >> 4 & 0xf;
 
-	do_gettimeofday(&tv);
-	lynx->rcv_buffer[0] = (__force __le32)tv.tv_usec;
+	ktime_get_real_ts64(&ts64);
+	timestamp = ts64.tv_nsec / NSEC_PER_USEC;
+	lynx->rcv_buffer[0] = (__force __le32)timestamp;
 
 	if (length == PHY_PACKET_SIZE)
 		tcode_mask = 1 << TCODE_PHY_PACKET;

commit 7eeb741895ea8926e6064dd0bbb349c6ebc09e8b
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:24:13 2012 -0500

    firewire: remove use of __devinitdata
    
    CONFIG_HOTPLUG is going away as an option so __devinitdata is no
    longer needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Acked-by: Stefan Richter <stefanr@s5r6.in-berlin.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/firewire/nosy.c b/drivers/firewire/nosy.c
index 7a712b9ffb15..76b2d390f6ec 100644
--- a/drivers/firewire/nosy.c
+++ b/drivers/firewire/nosy.c
@@ -683,7 +683,7 @@ add_card(struct pci_dev *dev, const struct pci_device_id *unused)
 	return ret;
 }
 
-static struct pci_device_id pci_table[] __devinitdata = {
+static struct pci_device_id pci_table[] = {
 	{
 		.vendor =    PCI_VENDOR_ID_TI,
 		.device =    PCI_DEVICE_ID_TI_PCILYNX,

commit 03f94c0f6215fa0cc471d07ffb3c4bcb1a0889c1
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:22:57 2012 -0500

    firewire: remove use of __devinit
    
    CONFIG_HOTPLUG is going away as an option so __devinit is no longer
    needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Acked-by: Stefan Richter <stefanr@s5r6.in-berlin.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/firewire/nosy.c b/drivers/firewire/nosy.c
index 4ebfb2273672..7a712b9ffb15 100644
--- a/drivers/firewire/nosy.c
+++ b/drivers/firewire/nosy.c
@@ -529,7 +529,7 @@ remove_card(struct pci_dev *dev)
 
 #define RCV_BUFFER_SIZE (16 * 1024)
 
-static int __devinit
+static int
 add_card(struct pci_dev *dev, const struct pci_device_id *unused)
 {
 	struct pcilynx *lynx;

commit fe2af11c220c7bb3a67f7aec0594811e5c59e019
Author: Axel Lin <axel.lin@gmail.com>
Date:   Tue Apr 3 10:07:01 2012 +0800

    firewire: use module_pci_driver
    
    This patch converts the drivers in drivers/firewire/* to use module_pci_driver()
    macro which makes the code smaller and a bit simpler.
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/nosy.c b/drivers/firewire/nosy.c
index a7c4422a688e..4ebfb2273672 100644
--- a/drivers/firewire/nosy.c
+++ b/drivers/firewire/nosy.c
@@ -693,6 +693,8 @@ static struct pci_device_id pci_table[] __devinitdata = {
 	{ }	/* Terminating entry */
 };
 
+MODULE_DEVICE_TABLE(pci, pci_table);
+
 static struct pci_driver lynx_pci_driver = {
 	.name =		driver_name,
 	.id_table =	pci_table,
@@ -700,22 +702,8 @@ static struct pci_driver lynx_pci_driver = {
 	.remove =	remove_card,
 };
 
+module_pci_driver(lynx_pci_driver);
+
 MODULE_AUTHOR("Kristian Hoegsberg");
 MODULE_DESCRIPTION("Snoop mode driver for TI pcilynx 1394 controllers");
 MODULE_LICENSE("GPL");
-MODULE_DEVICE_TABLE(pci, pci_table);
-
-static int __init nosy_init(void)
-{
-	return pci_register_driver(&lynx_pci_driver);
-}
-
-static void __exit nosy_cleanup(void)
-{
-	pci_unregister_driver(&lynx_pci_driver);
-
-	pr_info("Unloaded %s\n", driver_name);
-}
-
-module_init(nosy_init);
-module_exit(nosy_cleanup);

commit e894d1d7fd8cfa89a085df2d368a5e652751b0a1
Author: santosh nayak <santoshprasadnayak@gmail.com>
Date:   Tue Feb 21 15:38:13 2012 +0530

    firewire: nosy: Use the macro DMA_BIT_MASK().
    
    Use the macro DMA_BIT_MASK instead of the constant  0xffffffff
    
    Signed-off-by: Santosh Nayak <santoshprasadnayak@gmail.com>
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/nosy.c b/drivers/firewire/nosy.c
index 763626b739d1..a7c4422a688e 100644
--- a/drivers/firewire/nosy.c
+++ b/drivers/firewire/nosy.c
@@ -36,7 +36,7 @@
 #include <linux/timex.h>
 #include <linux/uaccess.h>
 #include <linux/wait.h>
-
+#include <linux/dma-mapping.h>
 #include <linux/atomic.h>
 #include <asm/byteorder.h>
 
@@ -536,7 +536,7 @@ add_card(struct pci_dev *dev, const struct pci_device_id *unused)
 	u32 p, end;
 	int ret, i;
 
-	if (pci_set_dma_mask(dev, 0xffffffff)) {
+	if (pci_set_dma_mask(dev, DMA_BIT_MASK(32))) {
 		dev_err(&dev->dev,
 		    "DMA address limits not supported for PCILynx hardware\n");
 		return -ENXIO;

commit 60063497a95e716c9a689af3be2687d261f115b4
Author: Arun Sharma <asharma@fb.com>
Date:   Tue Jul 26 16:09:06 2011 -0700

    atomic: use <linux/atomic.h>
    
    This allows us to move duplicated code in <asm/atomic.h>
    (atomic_inc_not_zero() for now) to <linux/atomic.h>
    
    Signed-off-by: Arun Sharma <asharma@fb.com>
    Reviewed-by: Eric Dumazet <eric.dumazet@gmail.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: David Miller <davem@davemloft.net>
    Cc: Eric Dumazet <eric.dumazet@gmail.com>
    Acked-by: Mike Frysinger <vapier@gentoo.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/firewire/nosy.c b/drivers/firewire/nosy.c
index 0618145376ad..763626b739d1 100644
--- a/drivers/firewire/nosy.c
+++ b/drivers/firewire/nosy.c
@@ -37,7 +37,7 @@
 #include <linux/uaccess.h>
 #include <linux/wait.h>
 
-#include <asm/atomic.h>
+#include <linux/atomic.h>
 #include <asm/byteorder.h>
 
 #include "nosy.h"

commit 60a74a6ff86b4e90b9558956589390efdeb4e924
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sat Oct 23 13:18:56 2010 +0200

    firewire: nosy: char device is not seekable
    
    Amend .open handler accordingly and remove the .llseek handler.
    .llseek = NULL means no_llseek (return error) since commit 776c163b1b93.
    
    The only client that uses this interface is nosy-dump in linux/tools/firewire
    and it knows not to seek in this char dev.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/nosy.c b/drivers/firewire/nosy.c
index bf184fb59a5e..0618145376ad 100644
--- a/drivers/firewire/nosy.c
+++ b/drivers/firewire/nosy.c
@@ -302,7 +302,7 @@ nosy_open(struct inode *inode, struct file *file)
 
 	file->private_data = client;
 
-	return 0;
+	return nonseekable_open(inode, file);
 fail:
 	kfree(client);
 	lynx_put(lynx);
@@ -405,7 +405,6 @@ static const struct file_operations nosy_ops = {
 	.poll =			nosy_poll,
 	.open =			nosy_open,
 	.release =		nosy_release,
-	.llseek =		noop_llseek,
 };
 
 #define PHY_PACKET_SIZE 12 /* 1 payload, 1 inverse, 1 ack = 3 quadlets */

commit 6038f373a3dc1f1c26496e60b6c40b164716f07e
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Sun Aug 15 18:52:59 2010 +0200

    llseek: automatically add .llseek fop
    
    All file_operations should get a .llseek operation so we can make
    nonseekable_open the default for future file operations without a
    .llseek pointer.
    
    The three cases that we can automatically detect are no_llseek, seq_lseek
    and default_llseek. For cases where we can we can automatically prove that
    the file offset is always ignored, we use noop_llseek, which maintains
    the current behavior of not returning an error from a seek.
    
    New drivers should normally not use noop_llseek but instead use no_llseek
    and call nonseekable_open at open time.  Existing drivers can be converted
    to do the same when the maintainer knows for certain that no user code
    relies on calling seek on the device file.
    
    The generated code is often incorrectly indented and right now contains
    comments that clarify for each added line why a specific variant was
    chosen. In the version that gets submitted upstream, the comments will
    be gone and I will manually fix the indentation, because there does not
    seem to be a way to do that using coccinelle.
    
    Some amount of new code is currently sitting in linux-next that should get
    the same modifications, which I will do at the end of the merge window.
    
    Many thanks to Julia Lawall for helping me learn to write a semantic
    patch that does all this.
    
    ===== begin semantic patch =====
    // This adds an llseek= method to all file operations,
    // as a preparation for making no_llseek the default.
    //
    // The rules are
    // - use no_llseek explicitly if we do nonseekable_open
    // - use seq_lseek for sequential files
    // - use default_llseek if we know we access f_pos
    // - use noop_llseek if we know we don't access f_pos,
    //   but we still want to allow users to call lseek
    //
    @ open1 exists @
    identifier nested_open;
    @@
    nested_open(...)
    {
    <+...
    nonseekable_open(...)
    ...+>
    }
    
    @ open exists@
    identifier open_f;
    identifier i, f;
    identifier open1.nested_open;
    @@
    int open_f(struct inode *i, struct file *f)
    {
    <+...
    (
    nonseekable_open(...)
    |
    nested_open(...)
    )
    ...+>
    }
    
    @ read disable optional_qualifier exists @
    identifier read_f;
    identifier f, p, s, off;
    type ssize_t, size_t, loff_t;
    expression E;
    identifier func;
    @@
    ssize_t read_f(struct file *f, char *p, size_t s, loff_t *off)
    {
    <+...
    (
       *off = E
    |
       *off += E
    |
       func(..., off, ...)
    |
       E = *off
    )
    ...+>
    }
    
    @ read_no_fpos disable optional_qualifier exists @
    identifier read_f;
    identifier f, p, s, off;
    type ssize_t, size_t, loff_t;
    @@
    ssize_t read_f(struct file *f, char *p, size_t s, loff_t *off)
    {
    ... when != off
    }
    
    @ write @
    identifier write_f;
    identifier f, p, s, off;
    type ssize_t, size_t, loff_t;
    expression E;
    identifier func;
    @@
    ssize_t write_f(struct file *f, const char *p, size_t s, loff_t *off)
    {
    <+...
    (
      *off = E
    |
      *off += E
    |
      func(..., off, ...)
    |
      E = *off
    )
    ...+>
    }
    
    @ write_no_fpos @
    identifier write_f;
    identifier f, p, s, off;
    type ssize_t, size_t, loff_t;
    @@
    ssize_t write_f(struct file *f, const char *p, size_t s, loff_t *off)
    {
    ... when != off
    }
    
    @ fops0 @
    identifier fops;
    @@
    struct file_operations fops = {
     ...
    };
    
    @ has_llseek depends on fops0 @
    identifier fops0.fops;
    identifier llseek_f;
    @@
    struct file_operations fops = {
    ...
     .llseek = llseek_f,
    ...
    };
    
    @ has_read depends on fops0 @
    identifier fops0.fops;
    identifier read_f;
    @@
    struct file_operations fops = {
    ...
     .read = read_f,
    ...
    };
    
    @ has_write depends on fops0 @
    identifier fops0.fops;
    identifier write_f;
    @@
    struct file_operations fops = {
    ...
     .write = write_f,
    ...
    };
    
    @ has_open depends on fops0 @
    identifier fops0.fops;
    identifier open_f;
    @@
    struct file_operations fops = {
    ...
     .open = open_f,
    ...
    };
    
    // use no_llseek if we call nonseekable_open
    ////////////////////////////////////////////
    @ nonseekable1 depends on !has_llseek && has_open @
    identifier fops0.fops;
    identifier nso ~= "nonseekable_open";
    @@
    struct file_operations fops = {
    ...  .open = nso, ...
    +.llseek = no_llseek, /* nonseekable */
    };
    
    @ nonseekable2 depends on !has_llseek @
    identifier fops0.fops;
    identifier open.open_f;
    @@
    struct file_operations fops = {
    ...  .open = open_f, ...
    +.llseek = no_llseek, /* open uses nonseekable */
    };
    
    // use seq_lseek for sequential files
    /////////////////////////////////////
    @ seq depends on !has_llseek @
    identifier fops0.fops;
    identifier sr ~= "seq_read";
    @@
    struct file_operations fops = {
    ...  .read = sr, ...
    +.llseek = seq_lseek, /* we have seq_read */
    };
    
    // use default_llseek if there is a readdir
    ///////////////////////////////////////////
    @ fops1 depends on !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier readdir_e;
    @@
    // any other fop is used that changes pos
    struct file_operations fops = {
    ... .readdir = readdir_e, ...
    +.llseek = default_llseek, /* readdir is present */
    };
    
    // use default_llseek if at least one of read/write touches f_pos
    /////////////////////////////////////////////////////////////////
    @ fops2 depends on !fops1 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier read.read_f;
    @@
    // read fops use offset
    struct file_operations fops = {
    ... .read = read_f, ...
    +.llseek = default_llseek, /* read accesses f_pos */
    };
    
    @ fops3 depends on !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier write.write_f;
    @@
    // write fops use offset
    struct file_operations fops = {
    ... .write = write_f, ...
    +       .llseek = default_llseek, /* write accesses f_pos */
    };
    
    // Use noop_llseek if neither read nor write accesses f_pos
    ///////////////////////////////////////////////////////////
    
    @ fops4 depends on !fops1 && !fops2 && !fops3 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier read_no_fpos.read_f;
    identifier write_no_fpos.write_f;
    @@
    // write fops use offset
    struct file_operations fops = {
    ...
     .write = write_f,
     .read = read_f,
    ...
    +.llseek = noop_llseek, /* read and write both use no f_pos */
    };
    
    @ depends on has_write && !has_read && !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier write_no_fpos.write_f;
    @@
    struct file_operations fops = {
    ... .write = write_f, ...
    +.llseek = noop_llseek, /* write uses no f_pos */
    };
    
    @ depends on has_read && !has_write && !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier read_no_fpos.read_f;
    @@
    struct file_operations fops = {
    ... .read = read_f, ...
    +.llseek = noop_llseek, /* read uses no f_pos */
    };
    
    @ depends on !has_read && !has_write && !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    @@
    struct file_operations fops = {
    ...
    +.llseek = noop_llseek, /* no read or write fn */
    };
    ===== End semantic patch =====
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Cc: Julia Lawall <julia@diku.dk>
    Cc: Christoph Hellwig <hch@infradead.org>

diff --git a/drivers/firewire/nosy.c b/drivers/firewire/nosy.c
index 8528b10763ed..bf184fb59a5e 100644
--- a/drivers/firewire/nosy.c
+++ b/drivers/firewire/nosy.c
@@ -405,6 +405,7 @@ static const struct file_operations nosy_ops = {
 	.poll =			nosy_poll,
 	.open =			nosy_open,
 	.release =		nosy_release,
+	.llseek =		noop_llseek,
 };
 
 #define PHY_PACKET_SIZE 12 /* 1 payload, 1 inverse, 1 ack = 3 quadlets */

commit 7429b17d30a19fd52a0c07de9d3959746d321e15
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Thu Jul 22 11:56:38 2010 +0200

    firewire: nosy: use generic printk macros
    
    Replace home-grown printk wrapper macros by ones from kernel.h and
    device.h.
    
    Also raise the log level in set_phy_reg() from debug to error because
    these are really error conditions.  Could even be WARN_ON.  Lower the
    log level in the device probe and driver shutdown from notice to info.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/nosy.c b/drivers/firewire/nosy.c
index 225e64956823..8528b10763ed 100644
--- a/drivers/firewire/nosy.c
+++ b/drivers/firewire/nosy.c
@@ -17,6 +17,7 @@
  * Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+#include <linux/device.h>
 #include <linux/errno.h>
 #include <linux/fs.h>
 #include <linux/init.h>
@@ -45,10 +46,6 @@
 #define TCODE_PHY_PACKET		0x10
 #define PCI_DEVICE_ID_TI_PCILYNX	0x8000
 
-#define notify(s, args...) printk(KERN_NOTICE s, ## args)
-#define error(s, args...) printk(KERN_ERR s, ## args)
-#define debug(s, args...) printk(KERN_DEBUG s, ## args)
-
 static char driver_name[] = KBUILD_MODNAME;
 
 /* this is the physical layout of a PCL, its size is 128 bytes */
@@ -260,15 +257,15 @@ static int
 set_phy_reg(struct pcilynx *lynx, int addr, int val)
 {
 	if (addr > 15) {
-		debug("PHY register address %d out of range\n", addr);
+		dev_err(&lynx->pci_device->dev,
+			"PHY register address %d out of range\n", addr);
 		return -1;
 	}
-
 	if (val > 0xff) {
-		debug("PHY register value %d out of range\n", val);
+		dev_err(&lynx->pci_device->dev,
+			"PHY register value %d out of range\n", val);
 		return -1;
 	}
-
 	reg_write(lynx, LINK_PHY, LINK_PHY_WRITE |
 		  LINK_PHY_ADDR(addr) | LINK_PHY_WDATA(val));
 
@@ -540,19 +537,19 @@ add_card(struct pci_dev *dev, const struct pci_device_id *unused)
 	int ret, i;
 
 	if (pci_set_dma_mask(dev, 0xffffffff)) {
-		error("DMA address limits not supported "
-		      "for PCILynx hardware\n");
+		dev_err(&dev->dev,
+		    "DMA address limits not supported for PCILynx hardware\n");
 		return -ENXIO;
 	}
 	if (pci_enable_device(dev)) {
-		error("Failed to enable PCILynx hardware\n");
+		dev_err(&dev->dev, "Failed to enable PCILynx hardware\n");
 		return -ENXIO;
 	}
 	pci_set_master(dev);
 
 	lynx = kzalloc(sizeof *lynx, GFP_KERNEL);
 	if (lynx == NULL) {
-		error("Failed to allocate control structure memory\n");
+		dev_err(&dev->dev, "Failed to allocate control structure\n");
 		ret = -ENOMEM;
 		goto fail_disable;
 	}
@@ -575,7 +572,7 @@ add_card(struct pci_dev *dev, const struct pci_device_id *unused)
 	if (lynx->rcv_start_pcl == NULL ||
 	    lynx->rcv_pcl == NULL ||
 	    lynx->rcv_buffer == NULL) {
-		error("Failed to allocate receive buffer\n");
+		dev_err(&dev->dev, "Failed to allocate receive buffer\n");
 		ret = -ENOMEM;
 		goto fail_deallocate;
 	}
@@ -637,7 +634,8 @@ add_card(struct pci_dev *dev, const struct pci_device_id *unused)
 
 	if (request_irq(dev->irq, irq_handler, IRQF_SHARED,
 			driver_name, lynx)) {
-		error("Failed to allocate shared interrupt %d\n", dev->irq);
+		dev_err(&dev->dev,
+			"Failed to allocate shared interrupt %d\n", dev->irq);
 		ret = -EIO;
 		goto fail_deallocate;
 	}
@@ -650,14 +648,15 @@ add_card(struct pci_dev *dev, const struct pci_device_id *unused)
 	mutex_lock(&card_mutex);
 	ret = misc_register(&lynx->misc);
 	if (ret) {
-		error("Failed to register misc char device\n");
+		dev_err(&dev->dev, "Failed to register misc char device\n");
 		mutex_unlock(&card_mutex);
 		goto fail_free_irq;
 	}
 	list_add_tail(&lynx->link, &card_list);
 	mutex_unlock(&card_mutex);
 
-	notify("Initialized PCILynx IEEE1394 card, irq=%d\n", dev->irq);
+	dev_info(&dev->dev,
+		 "Initialized PCILynx IEEE1394 card, irq=%d\n", dev->irq);
 
 	return 0;
 
@@ -715,7 +714,7 @@ static void __exit nosy_cleanup(void)
 {
 	pci_unregister_driver(&lynx_pci_driver);
 
-	notify("Unloaded %s.\n", driver_name);
+	pr_info("Unloaded %s\n", driver_name);
 }
 
 module_init(nosy_init);

commit fd8c8d46ca9402c15383d2cf0bc3ee7740de3b62
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Thu Jul 22 11:56:38 2010 +0200

    firewire: nosy: endianess fixes and annotations
    
    1.)  The DMA programs (struct pcl) are PCI-endian = little endian data
    (except for the 3rd quadlet in a PCL which the controller does not
    touch).  Annotate them as such.
    
    Fix all accesses of the PCL to work with big endian CPUs also.  Not
    actually tested, I only have a little endian PC to test with.  This
    includes replacement of a bitfield struct pcl_status by open-coded
    shift and mask operations.
    
    2.)  The two __attribute__ ((packed)) at struct pcl are not really
    required since it consists of u32/__le32 only, i.e. there will be no
    padding with or without the attribute.
    
    3.)  The received IEEE 1394 data are byteswapped by the controller from
    IEEE 1394 endian = big endian to PCI endian = little endian because the
    PCL_BIGENDIAN control bit is set.  Therefore annotate the DMA buffer as
    a __le32 array.
    
    Fix the one access of the DMA buffer (the check of the transaction code
    of link packets) to work with big endian CPUs.  Also fix the two
    accesses of the client bounce buffer (the reading of packet length).
    
    4.)  Add a comment to the userspace ABI header that all of the data gets
    out as little endian data, except for the timestamp which is CPU endian.
    (We could make it little endian too, but why?  Vice versa, an ioctl
    could be added to dump packet data in big endian byte order...)
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/nosy.c b/drivers/firewire/nosy.c
index b8dcaa28e1ad..225e64956823 100644
--- a/drivers/firewire/nosy.c
+++ b/drivers/firewire/nosy.c
@@ -51,33 +51,19 @@
 
 static char driver_name[] = KBUILD_MODNAME;
 
-struct pcl_status {
-	unsigned int transfer_count : 13;
-	unsigned int reserved0 : 1;
-	unsigned int ack_type : 1;
-	unsigned int ack : 4;
-	unsigned int rcv_speed : 2;
-	unsigned int rcv_dma_channel : 6;
-	unsigned int packet_complete : 1;
-	unsigned int packet_error : 1;
-	unsigned int master_error : 1;
-	unsigned int iso_mode : 1;
-	unsigned int self_id : 1;
-};
-
 /* this is the physical layout of a PCL, its size is 128 bytes */
 struct pcl {
-        u32 next;
-        u32 async_error_next;
-        u32 user_data;
-        struct pcl_status pcl_status;
-        u32 remaining_transfer_count;
-        u32 next_data_buffer;
-        struct {
-                u32 control;
-                u32 pointer;
-        } buffer[13] __attribute__ ((packed));
-} __attribute__ ((packed));
+	__le32 next;
+	__le32 async_error_next;
+	u32 user_data;
+	__le32 pcl_status;
+	__le32 remaining_transfer_count;
+	__le32 next_data_buffer;
+	struct {
+		__le32 control;
+		__le32 pointer;
+	} buffer[13];
+};
 
 struct packet {
 	unsigned int length;
@@ -98,7 +84,7 @@ struct pcilynx {
 	__iomem char *registers;
 
 	struct pcl *rcv_start_pcl, *rcv_pcl;
-	u32 *rcv_buffer;
+	__le32 *rcv_buffer;
 
 	dma_addr_t rcv_start_pcl_bus, rcv_pcl_bus, rcv_buffer_bus;
 
@@ -426,35 +412,26 @@ static const struct file_operations nosy_ops = {
 
 #define PHY_PACKET_SIZE 12 /* 1 payload, 1 inverse, 1 ack = 3 quadlets */
 
-struct link_packet {
-	unsigned int priority : 4;
-	unsigned int tcode : 4;
-	unsigned int rt : 2;
-	unsigned int tlabel : 6;
-	unsigned int destination : 16;
-};
-
 static void
 packet_irq_handler(struct pcilynx *lynx)
 {
 	struct client *client;
-	u32 tcode_mask;
+	u32 tcode_mask, tcode;
 	size_t length;
-	struct link_packet *packet;
 	struct timeval tv;
 
 	/* FIXME: Also report rcv_speed. */
 
-	length = lynx->rcv_pcl->pcl_status.transfer_count;
-	packet = (struct link_packet *) &lynx->rcv_buffer[1];
+	length = __le32_to_cpu(lynx->rcv_pcl->pcl_status) & 0x00001fff;
+	tcode  = __le32_to_cpu(lynx->rcv_buffer[1]) >> 4 & 0xf;
 
 	do_gettimeofday(&tv);
-	lynx->rcv_buffer[0] = tv.tv_usec;
+	lynx->rcv_buffer[0] = (__force __le32)tv.tv_usec;
 
 	if (length == PHY_PACKET_SIZE)
 		tcode_mask = 1 << TCODE_PHY_PACKET;
 	else
-		tcode_mask = 1 << packet->tcode;
+		tcode_mask = 1 << tcode;
 
 	spin_lock(&lynx->client_list_lock);
 
@@ -602,21 +579,22 @@ add_card(struct pci_dev *dev, const struct pci_device_id *unused)
 		ret = -ENOMEM;
 		goto fail_deallocate;
 	}
-	lynx->rcv_start_pcl->next = lynx->rcv_pcl_bus;
-	lynx->rcv_pcl->next = PCL_NEXT_INVALID;
-	lynx->rcv_pcl->async_error_next = PCL_NEXT_INVALID;
+	lynx->rcv_start_pcl->next	= cpu_to_le32(lynx->rcv_pcl_bus);
+	lynx->rcv_pcl->next		= cpu_to_le32(PCL_NEXT_INVALID);
+	lynx->rcv_pcl->async_error_next	= cpu_to_le32(PCL_NEXT_INVALID);
 
 	lynx->rcv_pcl->buffer[0].control =
-		PCL_CMD_RCV | PCL_BIGENDIAN | 2044;
-	lynx->rcv_pcl->buffer[0].pointer = lynx->rcv_buffer_bus + 4;
+			cpu_to_le32(PCL_CMD_RCV | PCL_BIGENDIAN | 2044);
+	lynx->rcv_pcl->buffer[0].pointer =
+			cpu_to_le32(lynx->rcv_buffer_bus + 4);
 	p = lynx->rcv_buffer_bus + 2048;
 	end = lynx->rcv_buffer_bus + RCV_BUFFER_SIZE;
 	for (i = 1; p < end; i++, p += 2048) {
 		lynx->rcv_pcl->buffer[i].control =
-			PCL_CMD_RCV | PCL_BIGENDIAN | 2048;
-		lynx->rcv_pcl->buffer[i].pointer = p;
+			cpu_to_le32(PCL_CMD_RCV | PCL_BIGENDIAN | 2048);
+		lynx->rcv_pcl->buffer[i].pointer = cpu_to_le32(p);
 	}
-	lynx->rcv_pcl->buffer[i - 1].control |= PCL_LAST_BUFF;
+	lynx->rcv_pcl->buffer[i - 1].control |= cpu_to_le32(PCL_LAST_BUFF);
 
 	reg_set_bits(lynx, MISC_CONTROL, MISC_CONTROL_SWRESET);
 	/* Fix buggy cards with autoboot pin not tied low: */

commit c89db7b8bc88d8288dcfbe7a885b950d2560d564
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Thu Jul 22 11:56:38 2010 +0200

    firewire: nosy: annotate __user pointers and __iomem pointers
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/nosy.c b/drivers/firewire/nosy.c
index edd729aafeca..b8dcaa28e1ad 100644
--- a/drivers/firewire/nosy.c
+++ b/drivers/firewire/nosy.c
@@ -95,7 +95,7 @@ struct packet_buffer {
 
 struct pcilynx {
 	struct pci_dev *pci_device;
-	unsigned char *registers;
+	__iomem char *registers;
 
 	struct pcl *rcv_start_pcl, *rcv_pcl;
 	u32 *rcv_buffer;
@@ -163,7 +163,7 @@ packet_buffer_destroy(struct packet_buffer *buffer)
 }
 
 static int
-packet_buffer_get(struct client *client, void *data, size_t user_length)
+packet_buffer_get(struct client *client, char __user *data, size_t user_length)
 {
 	struct packet_buffer *buffer = &client->buffer;
 	size_t length;
@@ -362,7 +362,7 @@ nosy_poll(struct file *file, poll_table *pt)
 }
 
 static ssize_t
-nosy_read(struct file *file, char *buffer, size_t count, loff_t *offset)
+nosy_read(struct file *file, char __user *buffer, size_t count, loff_t *offset)
 {
 	struct client *client = file->private_data;
 
@@ -383,7 +383,7 @@ nosy_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		stats.lost_packet_count  = client->buffer.lost_packet_count;
 		spin_unlock_irq(client_list_lock);
 
-		if (copy_to_user((void *) arg, &stats, sizeof stats))
+		if (copy_to_user((void __user *) arg, &stats, sizeof stats))
 			return -EFAULT;
 		else
 			return 0;

commit 424d66cedae8bebb00fdb917fc8430f7b8a655cf
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Thu Jul 22 11:56:38 2010 +0200

    firewire: nosy: fix device shutdown with active client
    
    Fix race between nosy_open() and remove_card() by replacing the
    unprotected array of card pointers by a mutex-protected list of cards.
    
    Make card instances reference-counted and let each client hold a
    reference.
    
    Notify clients about card removal via POLLHUP in poll()'s events
    bitmap; also let read() fail with errno=ENODEV if the card was removed
    and everything in the buffer was read.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/nosy.c b/drivers/firewire/nosy.c
index ccf9c461bd86..edd729aafeca 100644
--- a/drivers/firewire/nosy.c
+++ b/drivers/firewire/nosy.c
@@ -23,8 +23,10 @@
 #include <linux/interrupt.h>
 #include <linux/io.h>
 #include <linux/kernel.h>
+#include <linux/kref.h>
 #include <linux/miscdevice.h>
 #include <linux/module.h>
+#include <linux/mutex.h>
 #include <linux/pci.h>
 #include <linux/poll.h>
 #include <linux/sched.h> /* required for linux/wait.h */
@@ -104,8 +106,30 @@ struct pcilynx {
 	struct list_head client_list;
 
 	struct miscdevice misc;
+	struct list_head link;
+	struct kref kref;
 };
 
+static inline struct pcilynx *
+lynx_get(struct pcilynx *lynx)
+{
+	kref_get(&lynx->kref);
+
+	return lynx;
+}
+
+static void
+lynx_release(struct kref *kref)
+{
+	kfree(container_of(kref, struct pcilynx, kref));
+}
+
+static inline void
+lynx_put(struct pcilynx *lynx)
+{
+	kref_put(&lynx->kref, lynx_release);
+}
+
 struct client {
 	struct pcilynx *lynx;
 	u32 tcode_mask;
@@ -113,8 +137,8 @@ struct client {
 	struct list_head link;
 };
 
-#define MAX_MINORS 64
-static struct pcilynx *minors[MAX_MINORS];
+static DEFINE_MUTEX(card_mutex);
+static LIST_HEAD(card_list);
 
 static int
 packet_buffer_init(struct packet_buffer *buffer, size_t capacity)
@@ -139,15 +163,20 @@ packet_buffer_destroy(struct packet_buffer *buffer)
 }
 
 static int
-packet_buffer_get(struct packet_buffer *buffer, void *data, size_t user_length)
+packet_buffer_get(struct client *client, void *data, size_t user_length)
 {
+	struct packet_buffer *buffer = &client->buffer;
 	size_t length;
 	char *end;
 
 	if (wait_event_interruptible(buffer->wait,
-				     atomic_read(&buffer->size) > 0))
+				     atomic_read(&buffer->size) > 0) ||
+				     list_empty(&client->lynx->link))
 		return -ERESTARTSYS;
 
+	if (atomic_read(&buffer->size) == 0)
+		return -ENODEV;
+
 	/* FIXME: Check length <= user_length. */
 
 	end = buffer->data + buffer->capacity;
@@ -265,39 +294,52 @@ nosy_open(struct inode *inode, struct file *file)
 {
 	int minor = iminor(inode);
 	struct client *client;
-
-	if (minor > MAX_MINORS || minors[minor] == NULL)
+	struct pcilynx *tmp, *lynx = NULL;
+
+	mutex_lock(&card_mutex);
+	list_for_each_entry(tmp, &card_list, link)
+		if (tmp->misc.minor == minor) {
+			lynx = lynx_get(tmp);
+			break;
+		}
+	mutex_unlock(&card_mutex);
+	if (lynx == NULL)
 		return -ENODEV;
 
 	client = kmalloc(sizeof *client, GFP_KERNEL);
 	if (client == NULL)
-		return -ENOMEM;
+		goto fail;
 
 	client->tcode_mask = ~0;
-	client->lynx = minors[minor];
+	client->lynx = lynx;
 	INIT_LIST_HEAD(&client->link);
 
-	if (packet_buffer_init(&client->buffer, 128 * 1024) < 0) {
-		kfree(client);
-		return -ENOMEM;
-	}
+	if (packet_buffer_init(&client->buffer, 128 * 1024) < 0)
+		goto fail;
 
 	file->private_data = client;
 
 	return 0;
+fail:
+	kfree(client);
+	lynx_put(lynx);
+
+	return -ENOMEM;
 }
 
 static int
 nosy_release(struct inode *inode, struct file *file)
 {
 	struct client *client = file->private_data;
+	struct pcilynx *lynx = client->lynx;
 
-	spin_lock_irq(&client->lynx->client_list_lock);
+	spin_lock_irq(&lynx->client_list_lock);
 	list_del_init(&client->link);
-	spin_unlock_irq(&client->lynx->client_list_lock);
+	spin_unlock_irq(&lynx->client_list_lock);
 
 	packet_buffer_destroy(&client->buffer);
 	kfree(client);
+	lynx_put(lynx);
 
 	return 0;
 }
@@ -306,13 +348,17 @@ static unsigned int
 nosy_poll(struct file *file, poll_table *pt)
 {
 	struct client *client = file->private_data;
+	unsigned int ret = 0;
 
 	poll_wait(file, &client->buffer.wait, pt);
 
 	if (atomic_read(&client->buffer.size) > 0)
-		return POLLIN | POLLRDNORM;
-	else
-		return 0;
+		ret = POLLIN | POLLRDNORM;
+
+	if (list_empty(&client->lynx->link))
+		ret |= POLLHUP;
+
+	return ret;
 }
 
 static ssize_t
@@ -320,7 +366,7 @@ nosy_read(struct file *file, char *buffer, size_t count, loff_t *offset)
 {
 	struct client *client = file->private_data;
 
-	return packet_buffer_get(&client->buffer, buffer, count);
+	return packet_buffer_get(client, buffer, count);
 }
 
 static long
@@ -479,16 +525,22 @@ irq_handler(int irq, void *device)
 static void
 remove_card(struct pci_dev *dev)
 {
-	struct pcilynx *lynx;
+	struct pcilynx *lynx = pci_get_drvdata(dev);
+	struct client *client;
 
-	lynx = pci_get_drvdata(dev);
-	if (!lynx)
-		return;
-	pci_set_drvdata(dev, NULL);
+	mutex_lock(&card_mutex);
+	list_del_init(&lynx->link);
+	misc_deregister(&lynx->misc);
+	mutex_unlock(&card_mutex);
 
 	reg_write(lynx, PCI_INT_ENABLE, 0);
 	free_irq(lynx->pci_device->irq, lynx);
 
+	spin_lock_irq(&lynx->client_list_lock);
+	list_for_each_entry(client, &lynx->client_list, link)
+		wake_up_interruptible(&client->buffer.wait);
+	spin_unlock_irq(&lynx->client_list_lock);
+
 	pci_free_consistent(lynx->pci_device, sizeof(struct pcl),
 			    lynx->rcv_start_pcl, lynx->rcv_start_pcl_bus);
 	pci_free_consistent(lynx->pci_device, sizeof(struct pcl),
@@ -498,11 +550,7 @@ remove_card(struct pci_dev *dev)
 
 	iounmap(lynx->registers);
 	pci_disable_device(dev);
-
-	minors[lynx->misc.minor] = NULL;
-	misc_deregister(&lynx->misc);
-
-	kfree(lynx);
+	lynx_put(lynx);
 }
 
 #define RCV_BUFFER_SIZE (16 * 1024)
@@ -536,6 +584,7 @@ add_card(struct pci_dev *dev, const struct pci_device_id *unused)
 
 	spin_lock_init(&lynx->client_list_lock);
 	INIT_LIST_HEAD(&lynx->client_list);
+	kref_init(&lynx->kref);
 
 	lynx->registers = ioremap_nocache(pci_resource_start(dev, 0),
 					  PCILYNX_MAX_REGISTER);
@@ -619,12 +668,16 @@ add_card(struct pci_dev *dev, const struct pci_device_id *unused)
 	lynx->misc.minor = MISC_DYNAMIC_MINOR;
 	lynx->misc.name = "nosy";
 	lynx->misc.fops = &nosy_ops;
+
+	mutex_lock(&card_mutex);
 	ret = misc_register(&lynx->misc);
 	if (ret) {
 		error("Failed to register misc char device\n");
+		mutex_unlock(&card_mutex);
 		goto fail_free_irq;
 	}
-	minors[lynx->misc.minor] = lynx;
+	list_add_tail(&lynx->link, &card_list);
+	mutex_unlock(&card_mutex);
 
 	notify("Initialized PCILynx IEEE1394 card, irq=%d\n", dev->irq);
 

commit b6d9c125e6610591c04ca9045f641e35ce1a9226
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Thu Jul 22 11:56:38 2010 +0200

    firewire: nosy: handle errors in device probe
    
    and add a missing pci_disable_device() to device shutdown.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/nosy.c b/drivers/firewire/nosy.c
index a241b62630b2..ccf9c461bd86 100644
--- a/drivers/firewire/nosy.c
+++ b/drivers/firewire/nosy.c
@@ -497,6 +497,7 @@ remove_card(struct pci_dev *dev)
 			    lynx->rcv_buffer, lynx->rcv_buffer_bus);
 
 	iounmap(lynx->registers);
+	pci_disable_device(dev);
 
 	minors[lynx->misc.minor] = NULL;
 	misc_deregister(&lynx->misc);
@@ -511,7 +512,7 @@ add_card(struct pci_dev *dev, const struct pci_device_id *unused)
 {
 	struct pcilynx *lynx;
 	u32 p, end;
-	int i;
+	int ret, i;
 
 	if (pci_set_dma_mask(dev, 0xffffffff)) {
 		error("DMA address limits not supported "
@@ -527,7 +528,8 @@ add_card(struct pci_dev *dev, const struct pci_device_id *unused)
 	lynx = kzalloc(sizeof *lynx, GFP_KERNEL);
 	if (lynx == NULL) {
 		error("Failed to allocate control structure memory\n");
-		return -ENOMEM;
+		ret = -ENOMEM;
+		goto fail_disable;
 	}
 	lynx->pci_device = dev;
 	pci_set_drvdata(dev, lynx);
@@ -547,9 +549,9 @@ add_card(struct pci_dev *dev, const struct pci_device_id *unused)
 	if (lynx->rcv_start_pcl == NULL ||
 	    lynx->rcv_pcl == NULL ||
 	    lynx->rcv_buffer == NULL) {
-		/* FIXME: do proper error handling. */
 		error("Failed to allocate receive buffer\n");
-		return -ENOMEM;
+		ret = -ENOMEM;
+		goto fail_deallocate;
 	}
 	lynx->rcv_start_pcl->next = lynx->rcv_pcl_bus;
 	lynx->rcv_pcl->next = PCL_NEXT_INVALID;
@@ -609,22 +611,46 @@ add_card(struct pci_dev *dev, const struct pci_device_id *unused)
 	if (request_irq(dev->irq, irq_handler, IRQF_SHARED,
 			driver_name, lynx)) {
 		error("Failed to allocate shared interrupt %d\n", dev->irq);
-		return -EIO;
+		ret = -EIO;
+		goto fail_deallocate;
 	}
 
 	lynx->misc.parent = &dev->dev;
 	lynx->misc.minor = MISC_DYNAMIC_MINOR;
 	lynx->misc.name = "nosy";
 	lynx->misc.fops = &nosy_ops;
-	if (misc_register(&lynx->misc)) {
+	ret = misc_register(&lynx->misc);
+	if (ret) {
 		error("Failed to register misc char device\n");
-		return -ENOMEM;
+		goto fail_free_irq;
 	}
 	minors[lynx->misc.minor] = lynx;
 
 	notify("Initialized PCILynx IEEE1394 card, irq=%d\n", dev->irq);
 
 	return 0;
+
+fail_free_irq:
+	reg_write(lynx, PCI_INT_ENABLE, 0);
+	free_irq(lynx->pci_device->irq, lynx);
+
+fail_deallocate:
+	if (lynx->rcv_start_pcl)
+		pci_free_consistent(lynx->pci_device, sizeof(struct pcl),
+				lynx->rcv_start_pcl, lynx->rcv_start_pcl_bus);
+	if (lynx->rcv_pcl)
+		pci_free_consistent(lynx->pci_device, sizeof(struct pcl),
+				lynx->rcv_pcl, lynx->rcv_pcl_bus);
+	if (lynx->rcv_buffer)
+		pci_free_consistent(lynx->pci_device, PAGE_SIZE,
+				lynx->rcv_buffer, lynx->rcv_buffer_bus);
+	iounmap(lynx->registers);
+	kfree(lynx);
+
+fail_disable:
+	pci_disable_device(dev);
+
+	return ret;
 }
 
 static struct pci_device_id pci_table[] __devinitdata = {

commit 165476671f731b4c3d6cf401d0e1886f4a4f4a8e
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Thu Jul 22 11:56:38 2010 +0200

    firewire: nosy: fix IRQ handler for card ejection
    
    Untested, I don't have a PCILynx CardBus card.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/nosy.c b/drivers/firewire/nosy.c
index 57a1100f8f4e..a241b62630b2 100644
--- a/drivers/firewire/nosy.c
+++ b/drivers/firewire/nosy.c
@@ -444,6 +444,10 @@ irq_handler(int irq, void *device)
 
 	pci_int_status = reg_read(lynx, PCI_INT_STATUS);
 
+	if (pci_int_status == ~0)
+		/* Card was ejected. */
+		return IRQ_NONE;
+
 	if ((pci_int_status & PCI_INT_INT_PEND) == 0)
 		/* Not our interrupt, bail out quickly. */
 		return IRQ_NONE;

commit 55e77c06c6017a70630cf599770369b8ba07c841
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Thu Jul 22 11:56:38 2010 +0200

    firewire: nosy: unroll some simple functions
    
    nosy_start/stop_snoop() and nosy_add/remove_client() are simple enough
    to be inlined into their callers.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/nosy.c b/drivers/firewire/nosy.c
index 2357e170e930..57a1100f8f4e 100644
--- a/drivers/firewire/nosy.c
+++ b/drivers/firewire/nosy.c
@@ -260,68 +260,44 @@ set_phy_reg(struct pcilynx *lynx, int addr, int val)
 	return 0;
 }
 
-static void
-nosy_start_snoop(struct client *client)
-{
-	spin_lock_irq(&client->lynx->client_list_lock);
-	list_add_tail(&client->link, &client->lynx->client_list);
-	spin_unlock_irq(&client->lynx->client_list_lock);
-}
-
-static void
-nosy_stop_snoop(struct client *client)
-{
-	spin_lock_irq(&client->lynx->client_list_lock);
-	list_del_init(&client->link);
-	spin_unlock_irq(&client->lynx->client_list_lock);
-}
-
-static struct client *
-nosy_add_client(struct pcilynx *lynx)
+static int
+nosy_open(struct inode *inode, struct file *file)
 {
+	int minor = iminor(inode);
 	struct client *client;
 
+	if (minor > MAX_MINORS || minors[minor] == NULL)
+		return -ENODEV;
+
 	client = kmalloc(sizeof *client, GFP_KERNEL);
+	if (client == NULL)
+		return -ENOMEM;
+
 	client->tcode_mask = ~0;
-	client->lynx = lynx;
+	client->lynx = minors[minor];
 	INIT_LIST_HEAD(&client->link);
 
 	if (packet_buffer_init(&client->buffer, 128 * 1024) < 0) {
 		kfree(client);
-		debug("Failed to allocate packet buffer\n");
-		return NULL;
+		return -ENOMEM;
 	}
 
-	return client;
-}
+	file->private_data = client;
 
-static void
-nosy_remove_client(struct client *client)
-{
-	nosy_stop_snoop(client);
-	packet_buffer_destroy(&client->buffer);
-	kfree(client);
+	return 0;
 }
 
 static int
-nosy_open(struct inode *inode, struct file *file)
+nosy_release(struct inode *inode, struct file *file)
 {
-	int minor = iminor(inode);
-
-	if (minor > MAX_MINORS || minors[minor] == NULL)
-		return -ENODEV;
+	struct client *client = file->private_data;
 
-	file->private_data = nosy_add_client(minors[minor]);
-	if (file->private_data == NULL)
-		return -ENOMEM;
-	else
-		return 0;
-}
+	spin_lock_irq(&client->lynx->client_list_lock);
+	list_del_init(&client->link);
+	spin_unlock_irq(&client->lynx->client_list_lock);
 
-static int
-nosy_release(struct inode *inode, struct file *file)
-{
-	nosy_remove_client(file->private_data);
+	packet_buffer_destroy(&client->buffer);
+	kfree(client);
 
 	return 0;
 }
@@ -367,17 +343,24 @@ nosy_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 			return 0;
 
 	case NOSY_IOC_START:
-		nosy_start_snoop(client);
+		spin_lock_irq(client_list_lock);
+		list_add_tail(&client->link, &client->lynx->client_list);
+		spin_unlock_irq(client_list_lock);
+
 		return 0;
 
 	case NOSY_IOC_STOP:
-		nosy_stop_snoop(client);
+		spin_lock_irq(client_list_lock);
+		list_del_init(&client->link);
+		spin_unlock_irq(client_list_lock);
+
 		return 0;
 
 	case NOSY_IOC_FILTER:
 		spin_lock_irq(client_list_lock);
 		client->tcode_mask = arg;
 		spin_unlock_irq(client_list_lock);
+
 		return 0;
 
 	default:

commit 685c3f80b6d88478a6428676f9daab59faf3cd4b
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Thu Jul 22 11:56:38 2010 +0200

    firewire: nosy: use flagless variants of spinlock accessors
    
    nosy_start/stop_snoop() are always only called by the ioctl method, i.e.
    with IRQs enabled.  packet_handler() and bus_reset_handler() are always
    only called by the IRQ handler.  Hence neither one needs to track IRQ
    flags.
    
    To underline the call context of packet_handler() and
    bus_reset_handler(), rename these functions to *_irq_handler().
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/nosy.c b/drivers/firewire/nosy.c
index 637e51485a70..2357e170e930 100644
--- a/drivers/firewire/nosy.c
+++ b/drivers/firewire/nosy.c
@@ -263,21 +263,17 @@ set_phy_reg(struct pcilynx *lynx, int addr, int val)
 static void
 nosy_start_snoop(struct client *client)
 {
-	unsigned long flags;
-
-	spin_lock_irqsave(&client->lynx->client_list_lock, flags);
+	spin_lock_irq(&client->lynx->client_list_lock);
 	list_add_tail(&client->link, &client->lynx->client_list);
-	spin_unlock_irqrestore(&client->lynx->client_list_lock, flags);
+	spin_unlock_irq(&client->lynx->client_list_lock);
 }
 
 static void
 nosy_stop_snoop(struct client *client)
 {
-	unsigned long flags;
-
-	spin_lock_irqsave(&client->lynx->client_list_lock, flags);
+	spin_lock_irq(&client->lynx->client_list_lock);
 	list_del_init(&client->link);
-	spin_unlock_irqrestore(&client->lynx->client_list_lock, flags);
+	spin_unlock_irq(&client->lynx->client_list_lock);
 }
 
 static struct client *
@@ -410,9 +406,8 @@ struct link_packet {
 };
 
 static void
-packet_handler(struct pcilynx *lynx)
+packet_irq_handler(struct pcilynx *lynx)
 {
-	unsigned long flags;
 	struct client *client;
 	u32 tcode_mask;
 	size_t length;
@@ -432,31 +427,30 @@ packet_handler(struct pcilynx *lynx)
 	else
 		tcode_mask = 1 << packet->tcode;
 
-	spin_lock_irqsave(&lynx->client_list_lock, flags);
+	spin_lock(&lynx->client_list_lock);
 
 	list_for_each_entry(client, &lynx->client_list, link)
 		if (client->tcode_mask & tcode_mask)
 			packet_buffer_put(&client->buffer,
 					  lynx->rcv_buffer, length + 4);
 
-	spin_unlock_irqrestore(&lynx->client_list_lock, flags);
+	spin_unlock(&lynx->client_list_lock);
 }
 
 static void
-bus_reset_handler(struct pcilynx *lynx)
+bus_reset_irq_handler(struct pcilynx *lynx)
 {
-	unsigned long flags;
 	struct client *client;
 	struct timeval tv;
 
 	do_gettimeofday(&tv);
 
-	spin_lock_irqsave(&lynx->client_list_lock, flags);
+	spin_lock(&lynx->client_list_lock);
 
 	list_for_each_entry(client, &lynx->client_list, link)
 		packet_buffer_put(&client->buffer, &tv.tv_usec, 4);
 
-	spin_unlock_irqrestore(&lynx->client_list_lock, flags);
+	spin_unlock(&lynx->client_list_lock);
 }
 
 static irqreturn_t
@@ -478,7 +472,7 @@ irq_handler(int irq, void *device)
 		reg_write(lynx, LINK_INT_STATUS, link_int_status);
 
 		if ((link_int_status & LINK_INT_PHY_BUSRESET) > 0)
-			bus_reset_handler(lynx);
+			bus_reset_irq_handler(lynx);
 	}
 
 	/* Clear the PCI_INT_STATUS register only after clearing the
@@ -488,7 +482,7 @@ irq_handler(int irq, void *device)
 	reg_write(lynx, PCI_INT_STATUS, pci_int_status);
 
 	if ((pci_int_status & PCI_INT_DMA0_HLT) > 0) {
-		packet_handler(lynx);
+		packet_irq_handler(lynx);
 		run_pcl(lynx, lynx->rcv_start_pcl_bus, 0);
 	}
 

commit a2d39db9dec0e7e403f54c9cf98b7dbc82b4c44a
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Thu Jul 22 11:56:38 2010 +0200

    firewire: nosy: fix list corruption by NOSY_IOC_STOP
    
    nosy_stop_snoop() would blow up the second time it was called without
    nosy_start_snoop() in between.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/nosy.c b/drivers/firewire/nosy.c
index 6470514190d5..637e51485a70 100644
--- a/drivers/firewire/nosy.c
+++ b/drivers/firewire/nosy.c
@@ -276,7 +276,7 @@ nosy_stop_snoop(struct client *client)
 	unsigned long flags;
 
 	spin_lock_irqsave(&client->lynx->client_list_lock, flags);
-	list_del(&client->link);
+	list_del_init(&client->link);
 	spin_unlock_irqrestore(&client->lynx->client_list_lock, flags);
 }
 

commit c7b2a99c66e7b40d8843a70f2981e375eeedf062
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Thu Jul 22 11:56:38 2010 +0200

    firewire: nosy: convert to unlocked ioctl
    
    The required serialization of NOSY_IOC_START and NOSY_IOC_STOP is
    already provided by the client_list_lock.
    
    NOSY_IOC_FILTER does not really require serialization since accesses
    to tcode_mask are atomic on any sane CPU architecture.  Nevertheless,
    make it explicit that we want this to be atomic by means of
    client_list_lock (which also surrounds the other tcode_mask access in
    the IRQ handler).  While we are at it, change the type of tcode_mask to
    u32 for consistency with the user API.
    
    NOSY_IOC_GET_STATS does not require serialization against itself.  But
    there is a bug here regarding concurrent updates of the two counters
    by the IRQ handler.  Fix it by taking the client_list_lock in this ioctl
    too.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/nosy.c b/drivers/firewire/nosy.c
index ea392d0985a5..6470514190d5 100644
--- a/drivers/firewire/nosy.c
+++ b/drivers/firewire/nosy.c
@@ -108,7 +108,7 @@ struct pcilynx {
 
 struct client {
 	struct pcilynx *lynx;
-	unsigned long tcode_mask;
+	u32 tcode_mask;
 	struct packet_buffer buffer;
 	struct list_head link;
 };
@@ -351,17 +351,20 @@ nosy_read(struct file *file, char *buffer, size_t count, loff_t *offset)
 	return packet_buffer_get(&client->buffer, buffer, count);
 }
 
-static int
-nosy_ioctl(struct inode *inode, struct file *file,
-	   unsigned int cmd, unsigned long arg)
+static long
+nosy_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 {
 	struct client *client = file->private_data;
+	spinlock_t *client_list_lock = &client->lynx->client_list_lock;
 	struct nosy_stats stats;
 
 	switch (cmd) {
 	case NOSY_IOC_GET_STATS:
+		spin_lock_irq(client_list_lock);
 		stats.total_packet_count = client->buffer.total_packet_count;
-		stats.lost_packet_count = client->buffer.lost_packet_count;
+		stats.lost_packet_count  = client->buffer.lost_packet_count;
+		spin_unlock_irq(client_list_lock);
+
 		if (copy_to_user((void *) arg, &stats, sizeof stats))
 			return -EFAULT;
 		else
@@ -376,7 +379,9 @@ nosy_ioctl(struct inode *inode, struct file *file,
 		return 0;
 
 	case NOSY_IOC_FILTER:
+		spin_lock_irq(client_list_lock);
 		client->tcode_mask = arg;
+		spin_unlock_irq(client_list_lock);
 		return 0;
 
 	default:
@@ -386,12 +391,12 @@ nosy_ioctl(struct inode *inode, struct file *file,
 }
 
 static const struct file_operations nosy_ops = {
-	.owner =	THIS_MODULE,
-	.read =		nosy_read,
-	.ioctl =	nosy_ioctl,
-	.poll =		nosy_poll,
-	.open =		nosy_open,
-	.release =	nosy_release,
+	.owner =		THIS_MODULE,
+	.read =			nosy_read,
+	.unlocked_ioctl =	nosy_ioctl,
+	.poll =			nosy_poll,
+	.open =			nosy_open,
+	.release =		nosy_release,
 };
 
 #define PHY_PACKET_SIZE 12 /* 1 payload, 1 inverse, 1 ack = 3 quadlets */
@@ -409,7 +414,7 @@ packet_handler(struct pcilynx *lynx)
 {
 	unsigned long flags;
 	struct client *client;
-	unsigned long tcode_mask;
+	u32 tcode_mask;
 	size_t length;
 	struct link_packet *packet;
 	struct timeval tv;

commit b5e47729043c9224b21ab3dc7c63e8a38dbb4923
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Tue Jul 27 10:28:30 2010 +0200

    firewire: nosy: misc cleanups
    
    Extend copyright note to 2007, c.f. Kristian's git log.
    
    Includes:
      - replace some <asm/*.h> by <linux/*.h>
      - add required indirectly included <linux/spinlock.h>
      - order alphabetically
    
    Coding style related changes:
      - change to utf8
      - normalize whitespace
      - normalize comment style
      - remove usages of __FUNCTION__
      - remove an unnecessary cast from void *
    
    Const and static declarations:
      - driver_name is not const in pci_driver.name, drop const qualifier
      - driver_name can be taken from KBUILD_MODNAME
      - the global variable minors[] can and should be static
      - constify struct file_operations instance
    
    Data types:
      - Remove unused struct member struct packet.code.  struct packet is
        only used for driver-internal bookkeeping; it does not appear on the
        wire or in DMA programs or the userspace ABI.  Hence the unused
        member .code can be removed without worries.
    
    Preprocessor macros:
      - unroll a preprocessor macro that containd a return
      - use list_for_each_entry
    
    Printk:
      - add missing terminating \n in some format strings
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/nosy.c b/drivers/firewire/nosy.c
index 079710bf1197..ea392d0985a5 100644
--- a/drivers/firewire/nosy.c
+++ b/drivers/firewire/nosy.c
@@ -1,7 +1,6 @@
-/* -*- c-file-style: "linux" -*-
- *
- * nosy.c - Snoop mode driver for TI pcilynx 1394 controllers
- * Copyright (C) 2002 Kristian Hgsberg
+/*
+ * nosy - Snoop mode driver for TI PCILynx 1394 controllers
+ * Copyright (C) 2002-2007 Kristian Høgsberg
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -18,23 +17,25 @@
  * Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-#include <linux/kernel.h>
-#include <linux/slab.h>
-#include <linux/interrupt.h>
-#include <linux/sched.h> /* required for linux/wait.h */
-#include <linux/wait.h>
 #include <linux/errno.h>
-#include <linux/module.h>
+#include <linux/fs.h>
 #include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/miscdevice.h>
+#include <linux/module.h>
 #include <linux/pci.h>
-#include <linux/fs.h>
 #include <linux/poll.h>
-#include <linux/miscdevice.h>
-#include <asm/byteorder.h>
+#include <linux/sched.h> /* required for linux/wait.h */
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/timex.h>
+#include <linux/uaccess.h>
+#include <linux/wait.h>
+
 #include <asm/atomic.h>
-#include <asm/io.h>
-#include <asm/uaccess.h>
-#include <asm/timex.h>
+#include <asm/byteorder.h>
 
 #include "nosy.h"
 #include "nosy-user.h"
@@ -46,7 +47,7 @@
 #define error(s, args...) printk(KERN_ERR s, ## args)
 #define debug(s, args...) printk(KERN_DEBUG s, ## args)
 
-static const char driver_name[] = "nosy";
+static char driver_name[] = KBUILD_MODNAME;
 
 struct pcl_status {
 	unsigned int transfer_count : 13;
@@ -77,8 +78,7 @@ struct pcl {
 } __attribute__ ((packed));
 
 struct packet {
-	unsigned int length : 16;
-	unsigned int code : 16;
+	unsigned int length;
 	char data[0];
 };
 
@@ -87,8 +87,8 @@ struct packet_buffer {
 	size_t capacity;
 	long total_packet_count, lost_packet_count;
 	atomic_t size;
-	struct packet *head, *tail;	
-        wait_queue_head_t wait;	
+	struct packet *head, *tail;
+	wait_queue_head_t wait;
 };
 
 struct pcilynx {
@@ -106,7 +106,6 @@ struct pcilynx {
 	struct miscdevice misc;
 };
 
-
 struct client {
 	struct pcilynx *lynx;
 	unsigned long tcode_mask;
@@ -115,7 +114,7 @@ struct client {
 };
 
 #define MAX_MINORS 64
-struct pcilynx *minors[MAX_MINORS];
+static struct pcilynx *minors[MAX_MINORS];
 
 static int
 packet_buffer_init(struct packet_buffer *buffer, size_t capacity)
@@ -128,7 +127,7 @@ packet_buffer_init(struct packet_buffer *buffer, size_t capacity)
 	buffer->capacity = capacity;
 	buffer->lost_packet_count = 0;
 	atomic_set(&buffer->size, 0);
-        init_waitqueue_head(&buffer->wait);
+	init_waitqueue_head(&buffer->wait);
 
 	return 0;
 }
@@ -158,8 +157,7 @@ packet_buffer_get(struct packet_buffer *buffer, void *data, size_t user_length)
 		if (copy_to_user(data, buffer->head->data, length))
 			return -EFAULT;
 		buffer->head = (struct packet *) &buffer->head->data[length];
-	}
-	else {
+	} else {
 		size_t split = end - buffer->head->data;
 
 		if (copy_to_user(data, buffer->head->data, split))
@@ -169,11 +167,12 @@ packet_buffer_get(struct packet_buffer *buffer, void *data, size_t user_length)
 		buffer->head = (struct packet *) &buffer->data[length - split];
 	}
 
-	/* Decrease buffer->size as the last thing, since this is what
+	/*
+	 * Decrease buffer->size as the last thing, since this is what
 	 * keeps the interrupt from overwriting the packet we are
-	 * retrieving from the buffer.  */
-
-	atomic_sub(sizeof (struct packet) + length, &buffer->size);
+	 * retrieving from the buffer.
+	 */
+	atomic_sub(sizeof(struct packet) + length, &buffer->size);
 
 	return length;
 }
@@ -185,8 +184,8 @@ packet_buffer_put(struct packet_buffer *buffer, void *data, size_t length)
 
 	buffer->total_packet_count++;
 
-	if (buffer->capacity < 
-	    atomic_read(&buffer->size) + sizeof (struct packet) + length) {
+	if (buffer->capacity <
+	    atomic_read(&buffer->size) + sizeof(struct packet) + length) {
 		buffer->lost_packet_count++;
 		return;
 	}
@@ -197,69 +196,68 @@ packet_buffer_put(struct packet_buffer *buffer, void *data, size_t length)
 	if (&buffer->tail->data[length] < end) {
 		memcpy(buffer->tail->data, data, length);
 		buffer->tail = (struct packet *) &buffer->tail->data[length];
-	}
-	else {
+	} else {
 		size_t split = end - buffer->tail->data;
 
 		memcpy(buffer->tail->data, data, split);
 		memcpy(buffer->data, data + split, length - split);
 		buffer->tail = (struct packet *) &buffer->data[length - split];
 	}
-	
+
 	/* Finally, adjust buffer size and wake up userspace reader. */
 
-	atomic_add(sizeof (struct packet) + length, &buffer->size);
+	atomic_add(sizeof(struct packet) + length, &buffer->size);
 	wake_up_interruptible(&buffer->wait);
 }
 
 static inline void
 reg_write(struct pcilynx *lynx, int offset, u32 data)
 {
-        writel(data, lynx->registers + offset);
+	writel(data, lynx->registers + offset);
 }
 
 static inline u32
 reg_read(struct pcilynx *lynx, int offset)
 {
-        return readl(lynx->registers + offset);
+	return readl(lynx->registers + offset);
 }
 
 static inline void
 reg_set_bits(struct pcilynx *lynx, int offset, u32 mask)
 {
-        reg_write(lynx, offset, (reg_read(lynx, offset) | mask));
+	reg_write(lynx, offset, (reg_read(lynx, offset) | mask));
 }
 
-/* Maybe the pcl programs could be setup to just append data instead
- * of using a whole packet. */
-
-static inline void 
-run_pcl(struct pcilynx *lynx, dma_addr_t pcl_bus, int dmachan)
+/*
+ * Maybe the pcl programs could be set up to just append data instead
+ * of using a whole packet.
+ */
+static inline void
+run_pcl(struct pcilynx *lynx, dma_addr_t pcl_bus,
+			   int dmachan)
 {
-        reg_write(lynx, DMA0_CURRENT_PCL + dmachan * 0x20, pcl_bus);
-        reg_write(lynx, DMA0_CHAN_CTRL + dmachan * 0x20,
-                  DMA_CHAN_CTRL_ENABLE | DMA_CHAN_CTRL_LINK);
+	reg_write(lynx, DMA0_CURRENT_PCL + dmachan * 0x20, pcl_bus);
+	reg_write(lynx, DMA0_CHAN_CTRL + dmachan * 0x20,
+		  DMA_CHAN_CTRL_ENABLE | DMA_CHAN_CTRL_LINK);
 }
 
 static int
 set_phy_reg(struct pcilynx *lynx, int addr, int val)
 {
-        if (addr > 15) {
-                debug("%s: PHY register address %d out of range",
-		      __FUNCTION__, addr);
-                return -1;
-        }
-
-        if (val > 0xff) {
-                debug("%s: PHY register value %d out of range",
-		      __FUNCTION__, val);
-                return -1;
-        }
-
-        reg_write(lynx, LINK_PHY, LINK_PHY_WRITE |
+	if (addr > 15) {
+		debug("PHY register address %d out of range\n", addr);
+		return -1;
+	}
+
+	if (val > 0xff) {
+		debug("PHY register value %d out of range\n", val);
+		return -1;
+	}
+
+	reg_write(lynx, LINK_PHY, LINK_PHY_WRITE |
 		  LINK_PHY_ADDR(addr) | LINK_PHY_WDATA(val));
 
-        return 0;
+	return 0;
 }
 
 static void
@@ -317,7 +315,7 @@ nosy_open(struct inode *inode, struct file *file)
 	if (minor > MAX_MINORS || minors[minor] == NULL)
 		return -ENODEV;
 
-        file->private_data = nosy_add_client(minors[minor]);
+	file->private_data = nosy_add_client(minors[minor]);
 	if (file->private_data == NULL)
 		return -ENOMEM;
 	else
@@ -329,7 +327,7 @@ nosy_release(struct inode *inode, struct file *file)
 {
 	nosy_remove_client(file->private_data);
 
-        return 0;
+	return 0;
 }
 
 static unsigned int
@@ -358,19 +356,17 @@ nosy_ioctl(struct inode *inode, struct file *file,
 	   unsigned int cmd, unsigned long arg)
 {
 	struct client *client = file->private_data;
+	struct nosy_stats stats;
 
 	switch (cmd) {
-	case NOSY_IOC_GET_STATS: {
-		struct nosy_stats stats;
-
+	case NOSY_IOC_GET_STATS:
 		stats.total_packet_count = client->buffer.total_packet_count;
 		stats.lost_packet_count = client->buffer.lost_packet_count;
 		if (copy_to_user((void *) arg, &stats, sizeof stats))
 			return -EFAULT;
 		else
 			return 0;
-	}
-	
+
 	case NOSY_IOC_START:
 		nosy_start_snoop(client);
 		return 0;
@@ -389,13 +385,13 @@ nosy_ioctl(struct inode *inode, struct file *file,
 	}
 }
 
-static struct file_operations nosy_ops = {
+static const struct file_operations nosy_ops = {
 	.owner =	THIS_MODULE,
-        .read =         nosy_read,
+	.read =		nosy_read,
 	.ioctl =	nosy_ioctl,
-        .poll =         nosy_poll,
-        .open =         nosy_open,
-        .release =      nosy_release,
+	.poll =		nosy_poll,
+	.open =		nosy_open,
+	.release =	nosy_release,
 };
 
 #define PHY_PACKET_SIZE 12 /* 1 payload, 1 inverse, 1 ack = 3 quadlets */
@@ -412,7 +408,6 @@ static void
 packet_handler(struct pcilynx *lynx)
 {
 	unsigned long flags;
-	struct list_head *pos;
 	struct client *client;
 	unsigned long tcode_mask;
 	size_t length;
@@ -434,12 +429,10 @@ packet_handler(struct pcilynx *lynx)
 
 	spin_lock_irqsave(&lynx->client_list_lock, flags);
 
-	list_for_each(pos, &lynx->client_list) {
-		client = list_entry(pos, struct client, link);
+	list_for_each_entry(client, &lynx->client_list, link)
 		if (client->tcode_mask & tcode_mask)
-			packet_buffer_put(&client->buffer, 
+			packet_buffer_put(&client->buffer,
 					  lynx->rcv_buffer, length + 4);
-	}
 
 	spin_unlock_irqrestore(&lynx->client_list_lock, flags);
 }
@@ -448,7 +441,6 @@ static void
 bus_reset_handler(struct pcilynx *lynx)
 {
 	unsigned long flags;
-	struct list_head *pos;
 	struct client *client;
 	struct timeval tv;
 
@@ -456,23 +448,19 @@ bus_reset_handler(struct pcilynx *lynx)
 
 	spin_lock_irqsave(&lynx->client_list_lock, flags);
 
-	list_for_each(pos, &lynx->client_list) {
-		client = list_entry(pos, struct client, link);
+	list_for_each_entry(client, &lynx->client_list, link)
 		packet_buffer_put(&client->buffer, &tv.tv_usec, 4);
-	}
 
 	spin_unlock_irqrestore(&lynx->client_list_lock, flags);
 }
 
-
-
 static irqreturn_t
 irq_handler(int irq, void *device)
 {
-	struct pcilynx *lynx = (struct pcilynx *) device;
+	struct pcilynx *lynx = device;
 	u32 pci_int_status;
-	
-        pci_int_status = reg_read(lynx, PCI_INT_STATUS);
+
+	pci_int_status = reg_read(lynx, PCI_INT_STATUS);
 
 	if ((pci_int_status & PCI_INT_INT_PEND) == 0)
 		/* Not our interrupt, bail out quickly. */
@@ -505,19 +493,19 @@ irq_handler(int irq, void *device)
 static void
 remove_card(struct pci_dev *dev)
 {
-        struct pcilynx *lynx;
+	struct pcilynx *lynx;
 
-        lynx = pci_get_drvdata(dev);
-        if (!lynx)
+	lynx = pci_get_drvdata(dev);
+	if (!lynx)
 		return;
-        pci_set_drvdata(dev, NULL);
+	pci_set_drvdata(dev, NULL);
 
 	reg_write(lynx, PCI_INT_ENABLE, 0);
 	free_irq(lynx->pci_device->irq, lynx);
 
-	pci_free_consistent(lynx->pci_device, sizeof (struct pcl), 
+	pci_free_consistent(lynx->pci_device, sizeof(struct pcl),
 			    lynx->rcv_start_pcl, lynx->rcv_start_pcl_bus);
-	pci_free_consistent(lynx->pci_device, sizeof (struct pcl), 
+	pci_free_consistent(lynx->pci_device, sizeof(struct pcl),
 			    lynx->rcv_pcl, lynx->rcv_pcl_bus);
 	pci_free_consistent(lynx->pci_device, PAGE_SIZE,
 			    lynx->rcv_buffer, lynx->rcv_buffer_bus);
@@ -532,64 +520,58 @@ remove_card(struct pci_dev *dev)
 
 #define RCV_BUFFER_SIZE (16 * 1024)
 
-#define FAIL(s, args...)			\
-	do {					\
-		error(s, ## args);		\
-		return err;			\
-	} while (0)
-
 static int __devinit
 add_card(struct pci_dev *dev, const struct pci_device_id *unused)
 {
-        struct pcilynx *lynx;
+	struct pcilynx *lynx;
 	u32 p, end;
-	int err, i;
-
-        err = -ENXIO;
+	int i;
 
-        if (pci_set_dma_mask(dev, 0xffffffff))
-                FAIL("DMA address limits not supported "
-		     "for PCILynx hardware.\n");
-        if (pci_enable_device(dev))
-                FAIL("Failed to enable PCILynx hardware.\n");
-        pci_set_master(dev);
-
-        err = -ENOMEM;
+	if (pci_set_dma_mask(dev, 0xffffffff)) {
+		error("DMA address limits not supported "
+		      "for PCILynx hardware\n");
+		return -ENXIO;
+	}
+	if (pci_enable_device(dev)) {
+		error("Failed to enable PCILynx hardware\n");
+		return -ENXIO;
+	}
+	pci_set_master(dev);
 
 	lynx = kzalloc(sizeof *lynx, GFP_KERNEL);
-        if (lynx == NULL)
-		FAIL("Failed to allocate control structure memory.\n");
-
-        lynx->pci_device = dev;
-        pci_set_drvdata(dev, lynx);
+	if (lynx == NULL) {
+		error("Failed to allocate control structure memory\n");
+		return -ENOMEM;
+	}
+	lynx->pci_device = dev;
+	pci_set_drvdata(dev, lynx);
 
 	spin_lock_init(&lynx->client_list_lock);
 	INIT_LIST_HEAD(&lynx->client_list);
 
-        lynx->registers = ioremap_nocache(pci_resource_start(dev, 0),
-                                          PCILYNX_MAX_REGISTER);
-
-        lynx->rcv_start_pcl = pci_alloc_consistent(lynx->pci_device,
-						   sizeof(struct pcl),
-						   &lynx->rcv_start_pcl_bus);
-        lynx->rcv_pcl = pci_alloc_consistent(lynx->pci_device,
-					     sizeof(struct pcl),
-					     &lynx->rcv_pcl_bus);
-        lynx->rcv_buffer = pci_alloc_consistent(lynx->pci_device, RCV_BUFFER_SIZE,
-						&lynx->rcv_buffer_bus);
-        if (lynx->rcv_start_pcl == NULL ||
+	lynx->registers = ioremap_nocache(pci_resource_start(dev, 0),
+					  PCILYNX_MAX_REGISTER);
+
+	lynx->rcv_start_pcl = pci_alloc_consistent(lynx->pci_device,
+				sizeof(struct pcl), &lynx->rcv_start_pcl_bus);
+	lynx->rcv_pcl = pci_alloc_consistent(lynx->pci_device,
+				sizeof(struct pcl), &lynx->rcv_pcl_bus);
+	lynx->rcv_buffer = pci_alloc_consistent(lynx->pci_device,
+				RCV_BUFFER_SIZE, &lynx->rcv_buffer_bus);
+	if (lynx->rcv_start_pcl == NULL ||
 	    lynx->rcv_pcl == NULL ||
-	    lynx->rcv_buffer == NULL)
+	    lynx->rcv_buffer == NULL) {
 		/* FIXME: do proper error handling. */
-                FAIL("Failed to allocate receive buffer.\n");
-
+		error("Failed to allocate receive buffer\n");
+		return -ENOMEM;
+	}
 	lynx->rcv_start_pcl->next = lynx->rcv_pcl_bus;
-        lynx->rcv_pcl->next = PCL_NEXT_INVALID;
-        lynx->rcv_pcl->async_error_next = PCL_NEXT_INVALID;
+	lynx->rcv_pcl->next = PCL_NEXT_INVALID;
+	lynx->rcv_pcl->async_error_next = PCL_NEXT_INVALID;
 
-        lynx->rcv_pcl->buffer[0].control =
+	lynx->rcv_pcl->buffer[0].control =
 		PCL_CMD_RCV | PCL_BIGENDIAN | 2044;
-        lynx->rcv_pcl->buffer[0].pointer = lynx->rcv_buffer_bus + 4;
+	lynx->rcv_pcl->buffer[0].pointer = lynx->rcv_buffer_bus + 4;
 	p = lynx->rcv_buffer_bus + 2048;
 	end = lynx->rcv_buffer_bus + RCV_BUFFER_SIZE;
 	for (i = 1; p < end; i++, p += 2048) {
@@ -599,31 +581,31 @@ add_card(struct pci_dev *dev, const struct pci_device_id *unused)
 	}
 	lynx->rcv_pcl->buffer[i - 1].control |= PCL_LAST_BUFF;
 
-        reg_set_bits(lynx, MISC_CONTROL, MISC_CONTROL_SWRESET);
-        /* Fix buggy cards with autoboot pin not tied low: */
-        reg_write(lynx, DMA0_CHAN_CTRL, 0);
-        reg_write(lynx, DMA_GLOBAL_REGISTER, 0x00 << 24);
+	reg_set_bits(lynx, MISC_CONTROL, MISC_CONTROL_SWRESET);
+	/* Fix buggy cards with autoboot pin not tied low: */
+	reg_write(lynx, DMA0_CHAN_CTRL, 0);
+	reg_write(lynx, DMA_GLOBAL_REGISTER, 0x00 << 24);
 
 #if 0
-        /* now, looking for PHY register set */
-        if ((get_phy_reg(lynx, 2) & 0xe0) == 0xe0) {
-                lynx->phyic.reg_1394a = 1;
-                PRINT(KERN_INFO, lynx->id,
-                      "found 1394a conform PHY (using extended register set)");
-                lynx->phyic.vendor = get_phy_vendorid(lynx);
-                lynx->phyic.product = get_phy_productid(lynx);
-        } else {
-                lynx->phyic.reg_1394a = 0;
-                PRINT(KERN_INFO, lynx->id, "found old 1394 PHY");
-        }
+	/* now, looking for PHY register set */
+	if ((get_phy_reg(lynx, 2) & 0xe0) == 0xe0) {
+		lynx->phyic.reg_1394a = 1;
+		PRINT(KERN_INFO, lynx->id,
+		      "found 1394a conform PHY (using extended register set)");
+		lynx->phyic.vendor = get_phy_vendorid(lynx);
+		lynx->phyic.product = get_phy_productid(lynx);
+	} else {
+		lynx->phyic.reg_1394a = 0;
+		PRINT(KERN_INFO, lynx->id, "found old 1394 PHY");
+	}
 #endif
 
 	/* Setup the general receive FIFO max size. */
 	reg_write(lynx, FIFO_SIZES, 255);
 
-        reg_set_bits(lynx, PCI_INT_ENABLE, PCI_INT_DMA_ALL);
+	reg_set_bits(lynx, PCI_INT_ENABLE, PCI_INT_DMA_ALL);
 
-        reg_write(lynx, LINK_INT_ENABLE,
+	reg_write(lynx, LINK_INT_ENABLE,
 		  LINK_INT_PHY_TIME_OUT | LINK_INT_PHY_REG_RCVD |
 		  LINK_INT_PHY_BUSRESET | LINK_INT_IT_STUCK |
 		  LINK_INT_AT_STUCK | LINK_INT_SNTRJ |
@@ -638,58 +620,60 @@ add_card(struct pci_dev *dev, const struct pci_device_id *unused)
 
 	run_pcl(lynx, lynx->rcv_start_pcl_bus, 0);
 
-        if (request_irq(dev->irq, irq_handler, IRQF_SHARED, driver_name, lynx))
-		FAIL("Failed to allocate shared interrupt %d.", dev->irq);
+	if (request_irq(dev->irq, irq_handler, IRQF_SHARED,
+			driver_name, lynx)) {
+		error("Failed to allocate shared interrupt %d\n", dev->irq);
+		return -EIO;
+	}
 
 	lynx->misc.parent = &dev->dev;
 	lynx->misc.minor = MISC_DYNAMIC_MINOR;
 	lynx->misc.name = "nosy";
 	lynx->misc.fops = &nosy_ops;
-	if (misc_register(&lynx->misc))
-                FAIL("Failed to register misc char device.");
+	if (misc_register(&lynx->misc)) {
+		error("Failed to register misc char device\n");
+		return -ENOMEM;
+	}
 	minors[lynx->misc.minor] = lynx;
 
 	notify("Initialized PCILynx IEEE1394 card, irq=%d\n", dev->irq);
 
-        return 0;
+	return 0;
 }
 
 static struct pci_device_id pci_table[] __devinitdata = {
 	{
-                .vendor =    PCI_VENDOR_ID_TI,
-                .device =    PCI_DEVICE_ID_TI_PCILYNX,
-                .subvendor = PCI_ANY_ID,
-                .subdevice = PCI_ANY_ID,
+		.vendor =    PCI_VENDOR_ID_TI,
+		.device =    PCI_DEVICE_ID_TI_PCILYNX,
+		.subvendor = PCI_ANY_ID,
+		.subdevice = PCI_ANY_ID,
 	},
 	{ }	/* Terminating entry */
 };
 
 static struct pci_driver lynx_pci_driver = {
-	.name =		(char *) driver_name,
+	.name =		driver_name,
 	.id_table =	pci_table,
 	.probe =	add_card,
-	.remove =	__devexit_p(remove_card),
+	.remove =	remove_card,
 };
 
-MODULE_AUTHOR("Kristian Hgsberg");
+MODULE_AUTHOR("Kristian Hoegsberg");
 MODULE_DESCRIPTION("Snoop mode driver for TI pcilynx 1394 controllers");
 MODULE_LICENSE("GPL");
 MODULE_DEVICE_TABLE(pci, pci_table);
 
 static int __init nosy_init(void)
 {
- 	/* notify("Loaded %s version %s.\n", driver_name, VERSION); */
-
-        return pci_register_driver(&lynx_pci_driver);
+	return pci_register_driver(&lynx_pci_driver);
 }
 
 static void __exit nosy_cleanup(void)
 {
-        pci_unregister_driver(&lynx_pci_driver);
+	pci_unregister_driver(&lynx_pci_driver);
 
 	notify("Unloaded %s.\n", driver_name);
 }
 
-
 module_init(nosy_init);
 module_exit(nosy_cleanup);

commit 286468210d83ce0ca1e37e346ed9f4457a161650
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Tue Jul 27 10:26:33 2010 +0200

    firewire: new driver: nosy - IEEE 1394 traffic sniffer
    
    This adds the traffic sniffer driver for Texas Instruments PCILynx/
    PCILynx2 based cards.  The use cases for nosy are analysis of
    nonstandard protocols and as an aid in development of drivers,
    applications, or firmwares.
    
    Author of the driver is Kristian Høgsberg.  Known contributers are
    Jody McIntyre and Jonathan Woithe.
    
    Nosy programs PCILynx chips to operate in promiscuous mode, which is a
    feature that is not found in OHCI-1394 controllers.  Hence, only special
    hardware as mentioned in the Kconfig help text is suitable for nosy.
    
    This is only the kernelspace part of nosy.  There is a userspace
    interface to it, called nosy-dump, proposed to be added into the tools/
    subdirectory of the kernel sources in a subsequent change.  Kernelspace
    and userspave component of nosy communicate via a 'misc' character
    device file called /dev/nosy with a simple ioctl() and read() based
    protocol, as described by nosy-user.h.
    
    The files added here are taken from
    git://anongit.freedesktop.org/~krh/nosy commit ee29be97 (2009-11-10)
    with the following changes by Stefan Richter:
      - Kconfig and Makefile hunks are written from scratch.
      - Commented out version printk in nosy.c.
      - Included missing <linux/sched.h>, reported by Stephen Rothwell.
    
    "git shortlog nosy{-user.h,.c,.h}" from nosy's git repository:
    
    Jonathan Woithe (2):
          Nosy updates for recent kernels
          Fix uninitialised memory (needed for 2.6.31 kernel)
    
    Kristian Høgsberg (5):
          Pull over nosy from mercurial repo.
          Use a misc device instead.
          Add simple AV/C decoder.
          Don't break down on big payloads.
          Set parent device for misc device.
    
    As a low-level IEEE 1394 driver, its files are placed into
    drivers/firewire/ although nosy is not part of the firewire driver
    stack.
    
    I am aware of the following literature from Texas Instruments about
    PCILynx programming:
          SCPA020A - PCILynx 1394 to PCI Bus Interface TSB12LV21BPGF
                     Functional Specification
          SLLA023  - Initialization and Asynchronous Programming of the
                     TSB12LV21A 1394 Device
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>
    Acked-by: Kristian Høgsberg <krh@bitplanet.net>

diff --git a/drivers/firewire/nosy.c b/drivers/firewire/nosy.c
new file mode 100644
index 000000000000..079710bf1197
--- /dev/null
+++ b/drivers/firewire/nosy.c
@@ -0,0 +1,695 @@
+/* -*- c-file-style: "linux" -*-
+ *
+ * nosy.c - Snoop mode driver for TI pcilynx 1394 controllers
+ * Copyright (C) 2002 Kristian Hgsberg
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/sched.h> /* required for linux/wait.h */
+#include <linux/wait.h>
+#include <linux/errno.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/fs.h>
+#include <linux/poll.h>
+#include <linux/miscdevice.h>
+#include <asm/byteorder.h>
+#include <asm/atomic.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <asm/timex.h>
+
+#include "nosy.h"
+#include "nosy-user.h"
+
+#define TCODE_PHY_PACKET		0x10
+#define PCI_DEVICE_ID_TI_PCILYNX	0x8000
+
+#define notify(s, args...) printk(KERN_NOTICE s, ## args)
+#define error(s, args...) printk(KERN_ERR s, ## args)
+#define debug(s, args...) printk(KERN_DEBUG s, ## args)
+
+static const char driver_name[] = "nosy";
+
+struct pcl_status {
+	unsigned int transfer_count : 13;
+	unsigned int reserved0 : 1;
+	unsigned int ack_type : 1;
+	unsigned int ack : 4;
+	unsigned int rcv_speed : 2;
+	unsigned int rcv_dma_channel : 6;
+	unsigned int packet_complete : 1;
+	unsigned int packet_error : 1;
+	unsigned int master_error : 1;
+	unsigned int iso_mode : 1;
+	unsigned int self_id : 1;
+};
+
+/* this is the physical layout of a PCL, its size is 128 bytes */
+struct pcl {
+        u32 next;
+        u32 async_error_next;
+        u32 user_data;
+        struct pcl_status pcl_status;
+        u32 remaining_transfer_count;
+        u32 next_data_buffer;
+        struct {
+                u32 control;
+                u32 pointer;
+        } buffer[13] __attribute__ ((packed));
+} __attribute__ ((packed));
+
+struct packet {
+	unsigned int length : 16;
+	unsigned int code : 16;
+	char data[0];
+};
+
+struct packet_buffer {
+	char *data;
+	size_t capacity;
+	long total_packet_count, lost_packet_count;
+	atomic_t size;
+	struct packet *head, *tail;	
+        wait_queue_head_t wait;	
+};
+
+struct pcilynx {
+	struct pci_dev *pci_device;
+	unsigned char *registers;
+
+	struct pcl *rcv_start_pcl, *rcv_pcl;
+	u32 *rcv_buffer;
+
+	dma_addr_t rcv_start_pcl_bus, rcv_pcl_bus, rcv_buffer_bus;
+
+	spinlock_t client_list_lock;
+	struct list_head client_list;
+
+	struct miscdevice misc;
+};
+
+
+struct client {
+	struct pcilynx *lynx;
+	unsigned long tcode_mask;
+	struct packet_buffer buffer;
+	struct list_head link;
+};
+
+#define MAX_MINORS 64
+struct pcilynx *minors[MAX_MINORS];
+
+static int
+packet_buffer_init(struct packet_buffer *buffer, size_t capacity)
+{
+	buffer->data = kmalloc(capacity, GFP_KERNEL);
+	if (buffer->data == NULL)
+		return -ENOMEM;
+	buffer->head = (struct packet *) buffer->data;
+	buffer->tail = (struct packet *) buffer->data;
+	buffer->capacity = capacity;
+	buffer->lost_packet_count = 0;
+	atomic_set(&buffer->size, 0);
+        init_waitqueue_head(&buffer->wait);
+
+	return 0;
+}
+
+static void
+packet_buffer_destroy(struct packet_buffer *buffer)
+{
+	kfree(buffer->data);
+}
+
+static int
+packet_buffer_get(struct packet_buffer *buffer, void *data, size_t user_length)
+{
+	size_t length;
+	char *end;
+
+	if (wait_event_interruptible(buffer->wait,
+				     atomic_read(&buffer->size) > 0))
+		return -ERESTARTSYS;
+
+	/* FIXME: Check length <= user_length. */
+
+	end = buffer->data + buffer->capacity;
+	length = buffer->head->length;
+
+	if (&buffer->head->data[length] < end) {
+		if (copy_to_user(data, buffer->head->data, length))
+			return -EFAULT;
+		buffer->head = (struct packet *) &buffer->head->data[length];
+	}
+	else {
+		size_t split = end - buffer->head->data;
+
+		if (copy_to_user(data, buffer->head->data, split))
+			return -EFAULT;
+		if (copy_to_user(data + split, buffer->data, length - split))
+			return -EFAULT;
+		buffer->head = (struct packet *) &buffer->data[length - split];
+	}
+
+	/* Decrease buffer->size as the last thing, since this is what
+	 * keeps the interrupt from overwriting the packet we are
+	 * retrieving from the buffer.  */
+
+	atomic_sub(sizeof (struct packet) + length, &buffer->size);
+
+	return length;
+}
+
+static void
+packet_buffer_put(struct packet_buffer *buffer, void *data, size_t length)
+{
+	char *end;
+
+	buffer->total_packet_count++;
+
+	if (buffer->capacity < 
+	    atomic_read(&buffer->size) + sizeof (struct packet) + length) {
+		buffer->lost_packet_count++;
+		return;
+	}
+
+	end = buffer->data + buffer->capacity;
+	buffer->tail->length = length;
+
+	if (&buffer->tail->data[length] < end) {
+		memcpy(buffer->tail->data, data, length);
+		buffer->tail = (struct packet *) &buffer->tail->data[length];
+	}
+	else {
+		size_t split = end - buffer->tail->data;
+
+		memcpy(buffer->tail->data, data, split);
+		memcpy(buffer->data, data + split, length - split);
+		buffer->tail = (struct packet *) &buffer->data[length - split];
+	}
+	
+	/* Finally, adjust buffer size and wake up userspace reader. */
+
+	atomic_add(sizeof (struct packet) + length, &buffer->size);
+	wake_up_interruptible(&buffer->wait);
+}
+
+static inline void
+reg_write(struct pcilynx *lynx, int offset, u32 data)
+{
+        writel(data, lynx->registers + offset);
+}
+
+static inline u32
+reg_read(struct pcilynx *lynx, int offset)
+{
+        return readl(lynx->registers + offset);
+}
+
+static inline void
+reg_set_bits(struct pcilynx *lynx, int offset, u32 mask)
+{
+        reg_write(lynx, offset, (reg_read(lynx, offset) | mask));
+}
+
+/* Maybe the pcl programs could be setup to just append data instead
+ * of using a whole packet. */
+
+static inline void 
+run_pcl(struct pcilynx *lynx, dma_addr_t pcl_bus, int dmachan)
+{
+        reg_write(lynx, DMA0_CURRENT_PCL + dmachan * 0x20, pcl_bus);
+        reg_write(lynx, DMA0_CHAN_CTRL + dmachan * 0x20,
+                  DMA_CHAN_CTRL_ENABLE | DMA_CHAN_CTRL_LINK);
+}
+
+static int
+set_phy_reg(struct pcilynx *lynx, int addr, int val)
+{
+        if (addr > 15) {
+                debug("%s: PHY register address %d out of range",
+		      __FUNCTION__, addr);
+                return -1;
+        }
+
+        if (val > 0xff) {
+                debug("%s: PHY register value %d out of range",
+		      __FUNCTION__, val);
+                return -1;
+        }
+
+        reg_write(lynx, LINK_PHY, LINK_PHY_WRITE |
+		  LINK_PHY_ADDR(addr) | LINK_PHY_WDATA(val));
+
+        return 0;
+}
+
+static void
+nosy_start_snoop(struct client *client)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&client->lynx->client_list_lock, flags);
+	list_add_tail(&client->link, &client->lynx->client_list);
+	spin_unlock_irqrestore(&client->lynx->client_list_lock, flags);
+}
+
+static void
+nosy_stop_snoop(struct client *client)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&client->lynx->client_list_lock, flags);
+	list_del(&client->link);
+	spin_unlock_irqrestore(&client->lynx->client_list_lock, flags);
+}
+
+static struct client *
+nosy_add_client(struct pcilynx *lynx)
+{
+	struct client *client;
+
+	client = kmalloc(sizeof *client, GFP_KERNEL);
+	client->tcode_mask = ~0;
+	client->lynx = lynx;
+	INIT_LIST_HEAD(&client->link);
+
+	if (packet_buffer_init(&client->buffer, 128 * 1024) < 0) {
+		kfree(client);
+		debug("Failed to allocate packet buffer\n");
+		return NULL;
+	}
+
+	return client;
+}
+
+static void
+nosy_remove_client(struct client *client)
+{
+	nosy_stop_snoop(client);
+	packet_buffer_destroy(&client->buffer);
+	kfree(client);
+}
+
+static int
+nosy_open(struct inode *inode, struct file *file)
+{
+	int minor = iminor(inode);
+
+	if (minor > MAX_MINORS || minors[minor] == NULL)
+		return -ENODEV;
+
+        file->private_data = nosy_add_client(minors[minor]);
+	if (file->private_data == NULL)
+		return -ENOMEM;
+	else
+		return 0;
+}
+
+static int
+nosy_release(struct inode *inode, struct file *file)
+{
+	nosy_remove_client(file->private_data);
+
+        return 0;
+}
+
+static unsigned int
+nosy_poll(struct file *file, poll_table *pt)
+{
+	struct client *client = file->private_data;
+
+	poll_wait(file, &client->buffer.wait, pt);
+
+	if (atomic_read(&client->buffer.size) > 0)
+		return POLLIN | POLLRDNORM;
+	else
+		return 0;
+}
+
+static ssize_t
+nosy_read(struct file *file, char *buffer, size_t count, loff_t *offset)
+{
+	struct client *client = file->private_data;
+
+	return packet_buffer_get(&client->buffer, buffer, count);
+}
+
+static int
+nosy_ioctl(struct inode *inode, struct file *file,
+	   unsigned int cmd, unsigned long arg)
+{
+	struct client *client = file->private_data;
+
+	switch (cmd) {
+	case NOSY_IOC_GET_STATS: {
+		struct nosy_stats stats;
+
+		stats.total_packet_count = client->buffer.total_packet_count;
+		stats.lost_packet_count = client->buffer.lost_packet_count;
+		if (copy_to_user((void *) arg, &stats, sizeof stats))
+			return -EFAULT;
+		else
+			return 0;
+	}
+	
+	case NOSY_IOC_START:
+		nosy_start_snoop(client);
+		return 0;
+
+	case NOSY_IOC_STOP:
+		nosy_stop_snoop(client);
+		return 0;
+
+	case NOSY_IOC_FILTER:
+		client->tcode_mask = arg;
+		return 0;
+
+	default:
+		return -EINVAL;
+		/* Flush buffer, configure filter. */
+	}
+}
+
+static struct file_operations nosy_ops = {
+	.owner =	THIS_MODULE,
+        .read =         nosy_read,
+	.ioctl =	nosy_ioctl,
+        .poll =         nosy_poll,
+        .open =         nosy_open,
+        .release =      nosy_release,
+};
+
+#define PHY_PACKET_SIZE 12 /* 1 payload, 1 inverse, 1 ack = 3 quadlets */
+
+struct link_packet {
+	unsigned int priority : 4;
+	unsigned int tcode : 4;
+	unsigned int rt : 2;
+	unsigned int tlabel : 6;
+	unsigned int destination : 16;
+};
+
+static void
+packet_handler(struct pcilynx *lynx)
+{
+	unsigned long flags;
+	struct list_head *pos;
+	struct client *client;
+	unsigned long tcode_mask;
+	size_t length;
+	struct link_packet *packet;
+	struct timeval tv;
+
+	/* FIXME: Also report rcv_speed. */
+
+	length = lynx->rcv_pcl->pcl_status.transfer_count;
+	packet = (struct link_packet *) &lynx->rcv_buffer[1];
+
+	do_gettimeofday(&tv);
+	lynx->rcv_buffer[0] = tv.tv_usec;
+
+	if (length == PHY_PACKET_SIZE)
+		tcode_mask = 1 << TCODE_PHY_PACKET;
+	else
+		tcode_mask = 1 << packet->tcode;
+
+	spin_lock_irqsave(&lynx->client_list_lock, flags);
+
+	list_for_each(pos, &lynx->client_list) {
+		client = list_entry(pos, struct client, link);
+		if (client->tcode_mask & tcode_mask)
+			packet_buffer_put(&client->buffer, 
+					  lynx->rcv_buffer, length + 4);
+	}
+
+	spin_unlock_irqrestore(&lynx->client_list_lock, flags);
+}
+
+static void
+bus_reset_handler(struct pcilynx *lynx)
+{
+	unsigned long flags;
+	struct list_head *pos;
+	struct client *client;
+	struct timeval tv;
+
+	do_gettimeofday(&tv);
+
+	spin_lock_irqsave(&lynx->client_list_lock, flags);
+
+	list_for_each(pos, &lynx->client_list) {
+		client = list_entry(pos, struct client, link);
+		packet_buffer_put(&client->buffer, &tv.tv_usec, 4);
+	}
+
+	spin_unlock_irqrestore(&lynx->client_list_lock, flags);
+}
+
+
+
+static irqreturn_t
+irq_handler(int irq, void *device)
+{
+	struct pcilynx *lynx = (struct pcilynx *) device;
+	u32 pci_int_status;
+	
+        pci_int_status = reg_read(lynx, PCI_INT_STATUS);
+
+	if ((pci_int_status & PCI_INT_INT_PEND) == 0)
+		/* Not our interrupt, bail out quickly. */
+		return IRQ_NONE;
+
+	if ((pci_int_status & PCI_INT_P1394_INT) != 0) {
+		u32 link_int_status;
+
+		link_int_status = reg_read(lynx, LINK_INT_STATUS);
+		reg_write(lynx, LINK_INT_STATUS, link_int_status);
+
+		if ((link_int_status & LINK_INT_PHY_BUSRESET) > 0)
+			bus_reset_handler(lynx);
+	}
+
+	/* Clear the PCI_INT_STATUS register only after clearing the
+	 * LINK_INT_STATUS register; otherwise the PCI_INT_P1394 will
+	 * be set again immediately. */
+
+	reg_write(lynx, PCI_INT_STATUS, pci_int_status);
+
+	if ((pci_int_status & PCI_INT_DMA0_HLT) > 0) {
+		packet_handler(lynx);
+		run_pcl(lynx, lynx->rcv_start_pcl_bus, 0);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static void
+remove_card(struct pci_dev *dev)
+{
+        struct pcilynx *lynx;
+
+        lynx = pci_get_drvdata(dev);
+        if (!lynx)
+		return;
+        pci_set_drvdata(dev, NULL);
+
+	reg_write(lynx, PCI_INT_ENABLE, 0);
+	free_irq(lynx->pci_device->irq, lynx);
+
+	pci_free_consistent(lynx->pci_device, sizeof (struct pcl), 
+			    lynx->rcv_start_pcl, lynx->rcv_start_pcl_bus);
+	pci_free_consistent(lynx->pci_device, sizeof (struct pcl), 
+			    lynx->rcv_pcl, lynx->rcv_pcl_bus);
+	pci_free_consistent(lynx->pci_device, PAGE_SIZE,
+			    lynx->rcv_buffer, lynx->rcv_buffer_bus);
+
+	iounmap(lynx->registers);
+
+	minors[lynx->misc.minor] = NULL;
+	misc_deregister(&lynx->misc);
+
+	kfree(lynx);
+}
+
+#define RCV_BUFFER_SIZE (16 * 1024)
+
+#define FAIL(s, args...)			\
+	do {					\
+		error(s, ## args);		\
+		return err;			\
+	} while (0)
+
+static int __devinit
+add_card(struct pci_dev *dev, const struct pci_device_id *unused)
+{
+        struct pcilynx *lynx;
+	u32 p, end;
+	int err, i;
+
+        err = -ENXIO;
+
+        if (pci_set_dma_mask(dev, 0xffffffff))
+                FAIL("DMA address limits not supported "
+		     "for PCILynx hardware.\n");
+        if (pci_enable_device(dev))
+                FAIL("Failed to enable PCILynx hardware.\n");
+        pci_set_master(dev);
+
+        err = -ENOMEM;
+
+	lynx = kzalloc(sizeof *lynx, GFP_KERNEL);
+        if (lynx == NULL)
+		FAIL("Failed to allocate control structure memory.\n");
+
+        lynx->pci_device = dev;
+        pci_set_drvdata(dev, lynx);
+
+	spin_lock_init(&lynx->client_list_lock);
+	INIT_LIST_HEAD(&lynx->client_list);
+
+        lynx->registers = ioremap_nocache(pci_resource_start(dev, 0),
+                                          PCILYNX_MAX_REGISTER);
+
+        lynx->rcv_start_pcl = pci_alloc_consistent(lynx->pci_device,
+						   sizeof(struct pcl),
+						   &lynx->rcv_start_pcl_bus);
+        lynx->rcv_pcl = pci_alloc_consistent(lynx->pci_device,
+					     sizeof(struct pcl),
+					     &lynx->rcv_pcl_bus);
+        lynx->rcv_buffer = pci_alloc_consistent(lynx->pci_device, RCV_BUFFER_SIZE,
+						&lynx->rcv_buffer_bus);
+        if (lynx->rcv_start_pcl == NULL ||
+	    lynx->rcv_pcl == NULL ||
+	    lynx->rcv_buffer == NULL)
+		/* FIXME: do proper error handling. */
+                FAIL("Failed to allocate receive buffer.\n");
+
+	lynx->rcv_start_pcl->next = lynx->rcv_pcl_bus;
+        lynx->rcv_pcl->next = PCL_NEXT_INVALID;
+        lynx->rcv_pcl->async_error_next = PCL_NEXT_INVALID;
+
+        lynx->rcv_pcl->buffer[0].control =
+		PCL_CMD_RCV | PCL_BIGENDIAN | 2044;
+        lynx->rcv_pcl->buffer[0].pointer = lynx->rcv_buffer_bus + 4;
+	p = lynx->rcv_buffer_bus + 2048;
+	end = lynx->rcv_buffer_bus + RCV_BUFFER_SIZE;
+	for (i = 1; p < end; i++, p += 2048) {
+		lynx->rcv_pcl->buffer[i].control =
+			PCL_CMD_RCV | PCL_BIGENDIAN | 2048;
+		lynx->rcv_pcl->buffer[i].pointer = p;
+	}
+	lynx->rcv_pcl->buffer[i - 1].control |= PCL_LAST_BUFF;
+
+        reg_set_bits(lynx, MISC_CONTROL, MISC_CONTROL_SWRESET);
+        /* Fix buggy cards with autoboot pin not tied low: */
+        reg_write(lynx, DMA0_CHAN_CTRL, 0);
+        reg_write(lynx, DMA_GLOBAL_REGISTER, 0x00 << 24);
+
+#if 0
+        /* now, looking for PHY register set */
+        if ((get_phy_reg(lynx, 2) & 0xe0) == 0xe0) {
+                lynx->phyic.reg_1394a = 1;
+                PRINT(KERN_INFO, lynx->id,
+                      "found 1394a conform PHY (using extended register set)");
+                lynx->phyic.vendor = get_phy_vendorid(lynx);
+                lynx->phyic.product = get_phy_productid(lynx);
+        } else {
+                lynx->phyic.reg_1394a = 0;
+                PRINT(KERN_INFO, lynx->id, "found old 1394 PHY");
+        }
+#endif
+
+	/* Setup the general receive FIFO max size. */
+	reg_write(lynx, FIFO_SIZES, 255);
+
+        reg_set_bits(lynx, PCI_INT_ENABLE, PCI_INT_DMA_ALL);
+
+        reg_write(lynx, LINK_INT_ENABLE,
+		  LINK_INT_PHY_TIME_OUT | LINK_INT_PHY_REG_RCVD |
+		  LINK_INT_PHY_BUSRESET | LINK_INT_IT_STUCK |
+		  LINK_INT_AT_STUCK | LINK_INT_SNTRJ |
+		  LINK_INT_TC_ERR | LINK_INT_GRF_OVER_FLOW |
+		  LINK_INT_ITF_UNDER_FLOW | LINK_INT_ATF_UNDER_FLOW);
+
+	/* Disable the L flag in self ID packets. */
+	set_phy_reg(lynx, 4, 0);
+
+	/* Put this baby into snoop mode */
+	reg_set_bits(lynx, LINK_CONTROL, LINK_CONTROL_SNOOP_ENABLE);
+
+	run_pcl(lynx, lynx->rcv_start_pcl_bus, 0);
+
+        if (request_irq(dev->irq, irq_handler, IRQF_SHARED, driver_name, lynx))
+		FAIL("Failed to allocate shared interrupt %d.", dev->irq);
+
+	lynx->misc.parent = &dev->dev;
+	lynx->misc.minor = MISC_DYNAMIC_MINOR;
+	lynx->misc.name = "nosy";
+	lynx->misc.fops = &nosy_ops;
+	if (misc_register(&lynx->misc))
+                FAIL("Failed to register misc char device.");
+	minors[lynx->misc.minor] = lynx;
+
+	notify("Initialized PCILynx IEEE1394 card, irq=%d\n", dev->irq);
+
+        return 0;
+}
+
+static struct pci_device_id pci_table[] __devinitdata = {
+	{
+                .vendor =    PCI_VENDOR_ID_TI,
+                .device =    PCI_DEVICE_ID_TI_PCILYNX,
+                .subvendor = PCI_ANY_ID,
+                .subdevice = PCI_ANY_ID,
+	},
+	{ }	/* Terminating entry */
+};
+
+static struct pci_driver lynx_pci_driver = {
+	.name =		(char *) driver_name,
+	.id_table =	pci_table,
+	.probe =	add_card,
+	.remove =	__devexit_p(remove_card),
+};
+
+MODULE_AUTHOR("Kristian Hgsberg");
+MODULE_DESCRIPTION("Snoop mode driver for TI pcilynx 1394 controllers");
+MODULE_LICENSE("GPL");
+MODULE_DEVICE_TABLE(pci, pci_table);
+
+static int __init nosy_init(void)
+{
+ 	/* notify("Loaded %s version %s.\n", driver_name, VERSION); */
+
+        return pci_register_driver(&lynx_pci_driver);
+}
+
+static void __exit nosy_cleanup(void)
+{
+        pci_unregister_driver(&lynx_pci_driver);
+
+	notify("Unloaded %s.\n", driver_name);
+}
+
+
+module_init(nosy_init);
+module_exit(nosy_cleanup);
