commit c38e7e212acdb52dc8c0553340050b02e4a3f848
Author: Gustavo A. R. Silva <gustavoars@kernel.org>
Date:   Thu May 28 09:35:11 2020 -0500

    firewire: ohci: Replace zero-length array with flexible-array
    
    There is a regular need in the kernel to provide a way to declare having a
    dynamically sized set of trailing elements in a structure. Kernel code should
    always use “flexible array members”[1] for these cases. The older style of
    one-element or zero-length arrays should no longer be used[2].
    
    [1] https://en.wikipedia.org/wiki/Flexible_array_member
    [2] https://github.com/KSPP/linux/issues/21
    
    Signed-off-by: Gustavo A. R. Silva <gustavoars@kernel.org>

diff --git a/drivers/firewire/core.h b/drivers/firewire/core.h
index 4b0e4ee655a1..71d5f16f311c 100644
--- a/drivers/firewire/core.h
+++ b/drivers/firewire/core.h
@@ -191,7 +191,7 @@ struct fw_node {
 	/* Upper layer specific data. */
 	void *data;
 
-	struct fw_node *ports[0];
+	struct fw_node *ports[];
 };
 
 static inline struct fw_node *fw_node_get(struct fw_node *node)

commit 7807759e4ad8d46347a5d52a0910269320b81e65
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Tue Nov 5 14:49:39 2019 +0100

    firewire: core: code cleanup after vm_map_pages_zero introduction
    
    Commit 22660db89262 turned fw_iso_buffer_map_vma into a one-liner.
    There is no need to keep this in the core-iso.c collection of buffer
    management functions; put it inline into the sole user, the character
    device file driver.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/core.h b/drivers/firewire/core.h
index 0f0bed3a4bbb..4b0e4ee655a1 100644
--- a/drivers/firewire/core.h
+++ b/drivers/firewire/core.h
@@ -158,8 +158,6 @@ void fw_node_event(struct fw_card *card, struct fw_node *node, int event);
 int fw_iso_buffer_alloc(struct fw_iso_buffer *buffer, int page_count);
 int fw_iso_buffer_map_dma(struct fw_iso_buffer *buffer, struct fw_card *card,
 			  enum dma_data_direction direction);
-int fw_iso_buffer_map_vma(struct fw_iso_buffer *buffer,
-			  struct vm_area_struct *vma);
 
 
 /* -topology */

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/firewire/core.h b/drivers/firewire/core.h
index c07962ead5e4..0f0bed3a4bbb 100644
--- a/drivers/firewire/core.h
+++ b/drivers/firewire/core.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef _FIREWIRE_CORE_H
 #define _FIREWIRE_CORE_H
 

commit 392910cf3f8a0161d3da45d02ea17f2910d9193b
Author: Elena Reshetova <elena.reshetova@intel.com>
Date:   Mon Mar 6 16:20:49 2017 +0200

    drivers, firewire: convert fw_node.ref_count from atomic_t to refcount_t
    
    refcount_t type and corresponding API should be
    used instead of atomic_t when the variable is used as
    a reference counter. This allows to avoid accidental
    refcounter overflows that might lead to use-after-free
    situations.
    
    Signed-off-by: Elena Reshetova <elena.reshetova@intel.com>
    Signed-off-by: Hans Liljestrand <ishkamiel@gmail.com>
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: David Windsor <dwindsor@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/firewire/core.h b/drivers/firewire/core.h
index e1480ff683d2..c07962ead5e4 100644
--- a/drivers/firewire/core.h
+++ b/drivers/firewire/core.h
@@ -12,7 +12,7 @@
 #include <linux/slab.h>
 #include <linux/types.h>
 
-#include <linux/atomic.h>
+#include <linux/refcount.h>
 
 struct device;
 struct fw_card;
@@ -184,7 +184,7 @@ struct fw_node {
 			 * local node to this node. */
 	u8 max_depth:4;	/* Maximum depth to any leaf node */
 	u8 max_hops:4;	/* Max hops in this sub tree */
-	atomic_t ref_count;
+	refcount_t ref_count;
 
 	/* For serializing node topology into a list. */
 	struct list_head link;
@@ -197,14 +197,14 @@ struct fw_node {
 
 static inline struct fw_node *fw_node_get(struct fw_node *node)
 {
-	atomic_inc(&node->ref_count);
+	refcount_inc(&node->ref_count);
 
 	return node;
 }
 
 static inline void fw_node_put(struct fw_node *node)
 {
-	if (atomic_dec_and_test(&node->ref_count))
+	if (refcount_dec_and_test(&node->ref_count))
 		kfree(node);
 }
 

commit b77279bc2e81545b20824da701b349272a78e4e7
Merge: 15b588303155 16088cb6c02d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jun 4 09:08:25 2014 -0700

    Merge tag 'sound-3.16-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound into next
    
    Pull sound updates from Takashi Iwai:
     "At this time, majority of changes come from ASoC world while we got a
      few new drivers in other places for FireWire and USB.  There have been
      lots of ASoC core cleanups / refactoring, but very little visible to
      external users.
    
      ASoC:
       - Support for specifying aux CODECs in DT
       - Removal of the deprecated mux and enum macros
       - More moves towards full componentisation
       - Removal of some unused I/O code
       - Lots of cleanups, fixes and enhancements to the davinci, Freescale,
         Haswell and Realtek drivers
       - Several drivers exposed directly in Kconfig for use with
         simple-card
       - GPIO descriptor support for jacks
       - More updates and fixes to the Freescale SSI, Intel and rsnd drivers
       - New drivers for Cirrus CS42L56, Realtek RT5639, RT5642 and RT5651
         and ST STA350, Analog Devices ADAU1361, ADAU1381, ADAU1761 and
         ADAU1781, and Realtek RT5677
    
      HD-audio:
       - Clean up Dell headset quirks
       - Noise fixes for Dell and Sony laptops
       - Thinkpad T440 dock fix
       - Realtek codec updates (ALC293,ALC233,ALC3235)
       - Tegra HD-audio HDMI support
    
      FireWire-audio:
       - FireWire audio stack enhancement (AMDTP, MIDI), support for
         incoming isochronous stream and duplex streams with timestamp
         synchronization
       - BeBoB-based devices support
       - Fireworks-based device support
    
      USB-audio:
       - Behringer BCD2000 USB device support
    
      Misc:
       - Clean up of a few old drivers, atmel, fm801, etc"
    
    * tag 'sound-3.16-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound: (480 commits)
      ASoC: Fix wrong argument for card remove callbacks
      ASoC: free jack GPIOs before the sound card is freed
      ALSA: firewire-lib: Remove a comment about restriction of asynchronous operation
      ASoC: cache: Fix error code when not using ASoC level cache
      ALSA: hda/realtek - Fix COEF widget NID for ALC260 replacer fixup
      ALSA: hda/realtek - Correction of fixup codes for PB V7900 laptop
      ALSA: firewire-lib: Use IEC 61883-6 compliant labels for Raw Audio data
      ASoC: add RT5677 CODEC driver
      ASoC: intel: The Baytrail/MAX98090 driver depends on I2C
      ASoC: rt5640: Add the function "get_clk_info" to RL6231 shared support
      ASoC: rt5640: Add the function of the PLL clock calculation to RL6231 shared support
      ASoC: rt5640: Add RL6231 class device shared support for RT5640, RT5645 and RT5651
      ASoC: cache: Fix possible ZERO_SIZE_PTR pointer dereferencing error.
      ASoC: Add helper functions to cast from DAPM context to CODEC/platform
      ALSA: bebob: sizeof() vs ARRAY_SIZE() typo
      ASoC: wm9713: correct mono out PGA sources
      ALSA: synth: emux: soundfont.c: Cleaning up memory leak
      ASoC: fsl: Remove dependencies of boards for SND_SOC_EUKREA_TLV320
      ASoC: fsl-ssi: Use regmap
      ASoC: fsl-ssi: reorder and document fsl_ssi_private
      ...

commit 2fe2023adf695d08af5b598b2be3b288a95d563c
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Thu May 29 15:23:26 2014 +0200

    firewire: revert to 4 GB RDMA, fix protocols using Memory Space
    
    Undo a feature introduced in v3.14 by commit fcd46b34425d
    "firewire: Enable remote DMA above 4 GB".  That change raised the
    minimum address at which protocol drivers and user programs can register
    for request reception from 0x0001'0000'0000 to 0x8000'0000'0000.
    It turned out that at least one vendor-specific protocol exists which
    uses lower addresses:  https://bugzilla.kernel.org/show_bug.cgi?id=76921
    
    For the time being, revert most of commit fcd46b34425d so that affected
    protocols work like with kernel v3.13 and before.  Just keep the valid
    documentation parts from the regressing commit, and the ability to
    identify controllers which could be programmed to accept >32 bit
    physical DMA addresses.  The rest of fcd46b34425d should probably be
    brought back as an optional instead of default feature.
    
    Reported-by: Fabien Spindler <fabien.spindler@inria.fr>
    Cc: <stable@vger.kernel.org> # 3.14+
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/core.h b/drivers/firewire/core.h
index c98764aeeec6..f477308b6e9c 100644
--- a/drivers/firewire/core.h
+++ b/drivers/firewire/core.h
@@ -237,8 +237,8 @@ static inline bool is_next_generation(int new_generation, int old_generation)
 
 #define LOCAL_BUS 0xffc0
 
-/* arbitrarily chosen maximum range for physical DMA: 128 TB */
-#define FW_MAX_PHYSICAL_RANGE		(128ULL << 40)
+/* OHCI-1394's default upper bound for physical DMA: 4 GB */
+#define FW_MAX_PHYSICAL_RANGE		(1ULL << 32)
 
 void fw_core_handle_request(struct fw_card *card, struct fw_packet *request);
 void fw_core_handle_response(struct fw_card *card, struct fw_packet *packet);

commit 9b1ee0b2cb8bffdbb3003b1d5205f3ae0592c15a
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Apr 25 22:45:30 2014 +0900

    ALSA: firewire/bebob: Add a workaround for M-Audio special Firewire series
    
    In post commit, a quirk of this firmware about transactions is reported.
    This commit apply a workaround for this quirk.
    
    They often fail transactions due to gap_count mismatch. This state is changed
    by generating bus reset.
    
    The fw_schedule_bus_reset() is an exported symbol in firewire-core. But there
    are no header for public. This commit moves its prototype from
    drivers/firewire/core.h to include/linux/firewire.h.
    
    This mismatch still affects bus management before generating this bus reset.
    It still takes a time to call driver's probe() because transactions are still
    often failed.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/drivers/firewire/core.h b/drivers/firewire/core.h
index c98764aeeec6..870044e82316 100644
--- a/drivers/firewire/core.h
+++ b/drivers/firewire/core.h
@@ -118,7 +118,6 @@ int fw_card_add(struct fw_card *card,
 		u32 max_receive, u32 link_speed, u64 guid);
 void fw_core_remove_card(struct fw_card *card);
 int fw_compute_block_crc(__be32 *block);
-void fw_schedule_bus_reset(struct fw_card *card, bool delayed, bool short_reset);
 void fw_schedule_bm_work(struct fw_card *card, unsigned long delay);
 
 /* -cdev */

commit fcd46b34425da52703fe65b7f08850c509dcb0ed
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sat Jan 18 17:32:20 2014 +0100

    firewire: Enable remote DMA above 4 GB
    
    This makes all of a machine's memory accessible to remote debugging via
    FireWire, using the physical response unit (i.e. RDMA) of OHCI-1394 link
    layer controllers.
    
    This requires actual support by the controller.  The only ones currently
    known to support it are Agere/LSI FW643.  Most if not all other OHCI-1394
    controllers do not implement the optional Physical Upper Bound register.
    With them, RDMA will continue to be limited to the lowermost 4 GB.
    
    firewire-ohci's startup message in the kernel log is augmented to tell
    whether the controller does expose more than 4 GB to RDMA.
    
    While OHCI-1394 allows for a maximum Physical Upper Bound of
    0xffff'0000'0000 (near 256 TB), this implementation sets it to
    0x8000'0000'0000 (128 TB) in order to avoid interference with applications
    that require interrupt-served asynchronous request reception at
    respectively low addresses.
    
    Note, this change does not switch remote DMA on.  It only increases the
    range of remote access to all memory (instead of just 4 GB) whenever
    remote DMA was switched on by other means.  The latter is achieved by
    setting firewire-ohci's remote_dma parameter, or if the physical DMA
    filter is opened through firewire-sbp2.
    
    Derived from patch "firewire: Enable physical DMA above 4GB" by
    Peter Hurley <peter@hurleysoftware.com> from March 27, 2013.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/core.h b/drivers/firewire/core.h
index 515a42c786d0..c98764aeeec6 100644
--- a/drivers/firewire/core.h
+++ b/drivers/firewire/core.h
@@ -237,6 +237,9 @@ static inline bool is_next_generation(int new_generation, int old_generation)
 
 #define LOCAL_BUS 0xffc0
 
+/* arbitrarily chosen maximum range for physical DMA: 128 TB */
+#define FW_MAX_PHYSICAL_RANGE		(128ULL << 40)
+
 void fw_core_handle_request(struct fw_card *card, struct fw_packet *request);
 void fw_core_handle_response(struct fw_card *card, struct fw_packet *packet);
 int fw_get_response_length(struct fw_request *request);

commit 2f78d8e249973f1eeb88315e6444e616c60177ae
Merge: f2fde3a65e88 26c72e22c94f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu May 24 12:57:47 2012 -0700

    Merge tag 'firewire-updates' of git://git.kernel.org/pub/scm/linux/kernel/git/ieee1394/linux1394
    
    Pull IEEE 1394 (FireWire) subsystem updates from Stefan Richter:
    
     - Fix mismatch between DMA mapping direction (was wrong) and DMA
       synchronization direction (was correct) of isochronous reception
       buffers of userspace drivers if vma-mapped for R/W access.  For
       example, libdc1394 was affected.
    
     - more consistent retry stategy in device discovery/ rediscovery, and
       improved failure diagnostics
    
     - various small cleanups, e.g. use SCSI layer's DMA mapping API in
       firewire-sbp2
    
    * tag 'firewire-updates' of git://git.kernel.org/pub/scm/linux/kernel/git/ieee1394/linux1394:
      firewire: sbp2: document the absence of alignment requirements
      firewire: sbp2: remove superfluous blk_queue_max_segment_size() call
      firewire: sbp2: use scsi_dma_(un)map
      firewire: sbp2: give correct DMA device to scsi framework
      firewire: core: fw_device_refresh(): clean up error handling
      firewire: core: log config rom reading errors
      firewire: core: log error in case of failed bus manager lock
      firewire: move rcode_string() to core
      firewire: core: improve reread_config_rom() interface
      firewire: core: wait for inaccessible devices after bus reset
      firewire: ohci: omit spinlock IRQ flags where possible
      firewire: ohci: correct signedness of a local variable
      firewire: core: fix DMA mapping direction
      firewire: use module_pci_driver

commit fc5f80b152896c1ffded2a91d11dcb08ffcffebb
Author: Chris Boot <bootc@bootc.net>
Date:   Wed Feb 1 22:36:02 2012 +0000

    firewire: Move fw_card kref functions into linux/firewire.h
    
    When writing a firewire driver that doesn't deal with struct fw_device
    objects (e.g. it only publishes FireWire units and doesn't subscribe to
    them), you likely need to keep referenced to struct fw_card objects so
    that you can send messages to other nodes. This patch moves
    fw_card_put(), fw_card_get() and fw_card_release() into the public
    include/linux/firewire.h header instead of drivers/firewire/core.h, and
    adds EXPORT_SYMBOL_GPL(fw_card_release).
    
    The firewire-sbp-target module requires these so it can keep a reference
    to the fw_card object in order that it can fetch ORBs to execute and
    read/write related data and status information.
    
    Signed-off-by: Chris Boot <bootc@bootc.net>
    Acked-by: Stefan Richter <stefanr@s5r6.in-berlin.de>
    Cc: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>

diff --git a/drivers/firewire/core.h b/drivers/firewire/core.h
index 9047f5547d98..b5a2f6197053 100644
--- a/drivers/firewire/core.h
+++ b/drivers/firewire/core.h
@@ -120,21 +120,6 @@ int fw_compute_block_crc(__be32 *block);
 void fw_schedule_bus_reset(struct fw_card *card, bool delayed, bool short_reset);
 void fw_schedule_bm_work(struct fw_card *card, unsigned long delay);
 
-static inline struct fw_card *fw_card_get(struct fw_card *card)
-{
-	kref_get(&card->kref);
-
-	return card;
-}
-
-void fw_card_release(struct kref *kref);
-
-static inline void fw_card_put(struct fw_card *card)
-{
-	kref_put(&card->kref, fw_card_release);
-}
-
-
 /* -cdev */
 
 extern const struct file_operations fw_device_ops;

commit 0b6c4857f7684f6d3f59e0506f62953575346978
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Mon Apr 9 20:51:18 2012 +0200

    firewire: core: fix DMA mapping direction
    
    Seen with recent libdc1394:  If a client mmap()s the buffer of an
    isochronous reception buffer with PROT_READ|PROT_WRITE instead of just
    PROT_READ, firewire-core sets the wrong DMA mapping direction during
    buffer initialization.
    
    The fix is to split fw_iso_buffer_init() into allocation and DMA mapping
    and to perform the latter after both buffer and DMA context were
    allocated.  Buffer allocation and context allocation may happen in any
    order, but we need the context type (reception or transmission) in order
    to set the DMA direction of the buffer.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/core.h b/drivers/firewire/core.h
index 9047f5547d98..94257aecd054 100644
--- a/drivers/firewire/core.h
+++ b/drivers/firewire/core.h
@@ -3,6 +3,7 @@
 
 #include <linux/compiler.h>
 #include <linux/device.h>
+#include <linux/dma-mapping.h>
 #include <linux/fs.h>
 #include <linux/list.h>
 #include <linux/idr.h>
@@ -169,7 +170,11 @@ void fw_node_event(struct fw_card *card, struct fw_node *node, int event);
 
 /* -iso */
 
-int fw_iso_buffer_map(struct fw_iso_buffer *buffer, struct vm_area_struct *vma);
+int fw_iso_buffer_alloc(struct fw_iso_buffer *buffer, int page_count);
+int fw_iso_buffer_map_dma(struct fw_iso_buffer *buffer, struct fw_card *card,
+			  enum dma_data_direction direction);
+int fw_iso_buffer_map_vma(struct fw_iso_buffer *buffer,
+			  struct vm_area_struct *vma);
 
 
 /* -topology */

commit d1bbd20972936b9b178fda3eb1ec417cb27fdc01
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Sun Mar 18 19:06:39 2012 +0100

    firewire: allow explicit flushing of iso packet completions
    
    Extend the kernel and userspace APIs to allow reporting all currently
    completed isochronous packets, even if the next interrupt packet has not
    yet been reached.  This is required to determine the status of the
    packets at the end of a paused or stopped stream, and useful for more
    precise synchronization of audio streams.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/core.h b/drivers/firewire/core.h
index 62f57a4331e3..9047f5547d98 100644
--- a/drivers/firewire/core.h
+++ b/drivers/firewire/core.h
@@ -106,6 +106,8 @@ struct fw_card_driver {
 
 	void (*flush_queue_iso)(struct fw_iso_context *ctx);
 
+	int (*flush_iso_completions)(struct fw_iso_context *ctx);
+
 	int (*stop_iso)(struct fw_iso_context *ctx);
 };
 

commit 26b4950de174bc96c27b77546370dec84fb75ae7
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sat Feb 18 22:03:14 2012 +0100

    firewire: core: prefix log messages with card name
    
    Associate all log messages from firewire-core with the respective card
    because some people have more than one card.  E.g.
        firewire_ohci 0000:04:00.0: added OHCI v1.10 device as card 0, 8 IR + 8 IT contexts, quirks 0x0
        firewire_ohci 0000:05:00.0: added OHCI v1.10 device as card 1, 8 IR + 8 IT contexts, quirks 0x0
        firewire_core: created device fw0: GUID 0814438400000389, S800
        firewire_core: phy config: new root=ffc1, gap_count=5
        firewire_core: created device fw1: GUID 0814438400000388, S800
        firewire_core: created device fw2: GUID 0001d202e06800d1, S800
    turns into
        firewire_ohci 0000:04:00.0: added OHCI v1.10 device as card 0, 8 IR + 8 IT contexts, quirks 0x0
        firewire_ohci 0000:05:00.0: added OHCI v1.10 device as card 1, 8 IR + 8 IT contexts, quirks 0x0
        firewire_core 0000:04:00.0: created device fw0: GUID 0814438400000389, S800
        firewire_core 0000:04:00.0: phy config: new root=ffc1, gap_count=5
        firewire_core 0000:05:00.0: created device fw1: GUID 0814438400000388, S800
        firewire_core 0000:04:00.0: created device fw2: GUID 0001d202e06800d1, S800
    
    This increases the module size slightly; to keep this in check, turn the
    former printk wrapper macros into functions.  Their implementation is
    largely copied from driver core's dev_printk counterparts.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/core.h b/drivers/firewire/core.h
index b5b34952cf16..62f57a4331e3 100644
--- a/drivers/firewire/core.h
+++ b/drivers/firewire/core.h
@@ -1,6 +1,7 @@
 #ifndef _FIREWIRE_CORE_H
 #define _FIREWIRE_CORE_H
 
+#include <linux/compiler.h>
 #include <linux/device.h>
 #include <linux/fs.h>
 #include <linux/list.h>
@@ -24,6 +25,11 @@ struct fw_packet;
 
 /* -card */
 
+extern __printf(2, 3)
+void fw_err(const struct fw_card *card, const char *fmt, ...);
+extern __printf(2, 3)
+void fw_notice(const struct fw_card *card, const char *fmt, ...);
+
 /* bitfields within the PHY registers */
 #define PHY_LINK_ACTIVE		0x80
 #define PHY_CONTENDER		0x40

commit 210762268466634ddbfaddb48fdf5181ce4b5f2d
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sat Aug 27 18:53:03 2011 +0200

    firewire: move fw_device reference counting from drivers to core
    
    fw_unit device drivers invariably need to talk to the fw_unit's parent
    (an fw_device) and grandparent (an fw_card).  firewire-core already
    maintains an fw_card reference for the entire lifetime of an fw_device.
    Likewise, let firewire-core maintain an fw_device reference for the
    entire lifetime of an fw_unit so that fw_unit drivers don't have to.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/core.h b/drivers/firewire/core.h
index b45be5767529..b5b34952cf16 100644
--- a/drivers/firewire/core.h
+++ b/drivers/firewire/core.h
@@ -1,6 +1,7 @@
 #ifndef _FIREWIRE_CORE_H
 #define _FIREWIRE_CORE_H
 
+#include <linux/device.h>
 #include <linux/fs.h>
 #include <linux/list.h>
 #include <linux/idr.h>
@@ -141,6 +142,18 @@ extern struct rw_semaphore fw_device_rwsem;
 extern struct idr fw_device_idr;
 extern int fw_cdev_major;
 
+static inline struct fw_device *fw_device_get(struct fw_device *device)
+{
+	get_device(&device->device);
+
+	return device;
+}
+
+static inline void fw_device_put(struct fw_device *device)
+{
+	put_device(&device->device);
+}
+
 struct fw_device *fw_device_get_by_devt(dev_t devt);
 int fw_device_set_broadcast_channel(struct device *dev, void *gen);
 void fw_node_event(struct fw_card *card, struct fw_node *node, int event);

commit 60063497a95e716c9a689af3be2687d261f115b4
Author: Arun Sharma <asharma@fb.com>
Date:   Tue Jul 26 16:09:06 2011 -0700

    atomic: use <linux/atomic.h>
    
    This allows us to move duplicated code in <asm/atomic.h>
    (atomic_inc_not_zero() for now) to <linux/atomic.h>
    
    Signed-off-by: Arun Sharma <asharma@fb.com>
    Reviewed-by: Eric Dumazet <eric.dumazet@gmail.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: David Miller <davem@davemloft.net>
    Cc: Eric Dumazet <eric.dumazet@gmail.com>
    Acked-by: Mike Frysinger <vapier@gentoo.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/firewire/core.h b/drivers/firewire/core.h
index 0fe4e4e6eda7..b45be5767529 100644
--- a/drivers/firewire/core.h
+++ b/drivers/firewire/core.h
@@ -9,7 +9,7 @@
 #include <linux/slab.h>
 #include <linux/types.h>
 
-#include <asm/atomic.h>
+#include <linux/atomic.h>
 
 struct device;
 struct fw_card;

commit 105e53f863c04e1d9e5bb34bf753c9fdbce6a60c
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sun May 1 20:50:31 2011 +0200

    firewire: sbp2: parallelize login, reconnect, logout
    
    The struct sbp2_logical_unit.work items can all be executed in parallel
    but are not reentrant.  Furthermore, reconnect or re-login work must be
    executed in a WQ_MEM_RECLAIM workqueue.
    
    Hence replace the old single-threaded firewire-sbp2 workqueue by a
    concurrency-managed but non-reentrant workqueue with rescuer.
    firewire-core already maintains one, hence use this one.
    
    In earlier versions of this change, I observed occasional failures of
    parallel INQUIRY to an Initio INIC-2430 FireWire 800 to dual IDE bridge.
    More testing indicates that parallel INQUIRY is not actually a problem,
    but too quick successions of logout and login + INQUIRY, e.g. a quick
    sequence of cable plugout and plugin, can result in failed INQUIRY.
    This does not seem to be something that should or could be addressed by
    serialization.
    
    Another dual-LU device to which I currently have access to, an
    OXUF924DSB FireWire 800 to dual SATA bridge with firmware from MacPower,
    has been successfully tested with this too.
    
    This change is beneficial to environments with two or more FireWire
    storage devices, especially if they are located on the same bus.
    Management tasks that should be performed as soon and as quickly as
    possible, especially reconnect, are no longer held up by tasks on other
    devices that may take a long time, especially login with INQUIRY and sd
    or sr driver probe.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/core.h b/drivers/firewire/core.h
index 00ea7730c6a7..0fe4e4e6eda7 100644
--- a/drivers/firewire/core.h
+++ b/drivers/firewire/core.h
@@ -140,8 +140,6 @@ void fw_cdev_handle_phy_packet(struct fw_card *card, struct fw_packet *p);
 extern struct rw_semaphore fw_device_rwsem;
 extern struct idr fw_device_idr;
 extern int fw_cdev_major;
-struct workqueue_struct;
-extern struct workqueue_struct *fw_wq;
 
 struct fw_device *fw_device_get_by_devt(dev_t devt);
 int fw_device_set_broadcast_channel(struct device *dev, void *gen);

commit 6ea9e7bbfc389a12d52646449a201fe933ccd663
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Wed Oct 13 13:39:46 2010 +0200

    firewire: core: use non-reentrant workqueue with rescuer
    
    firewire-core manages the following types of work items:
    
    fw_card.br_work:
      - resets the bus on a card and possibly sends a PHY packet before that
      - does not sleep for long or not at all
      - is scheduled via fw_schedule_bus_reset() by
          - firewire-ohci's pci_probe method
          - firewire-ohci's set_config_rom method, called by kernelspace
            protocol drivers and userspace drivers which add/remove
            Configuration ROM descriptors
          - userspace drivers which use the bus reset ioctl
          - itself if the last reset happened less than 2 seconds ago
    
    fw_card.bm_work:
      - performs bus management duties
      - usually does not (but may in corner cases) sleep for long
      - is scheduled via fw_schedule_bm_work() by
          - firewire-ohci's self-ID-complete IRQ handler tasklet
          - firewire-core's fw_device.work instances whenever the root node
            device was (successfully or unsuccessfully) discovered,
            refreshed, or rediscovered
          - itself in case of resource allocation failures or in order to
            obey the 125ms bus manager arbitration interval
    
    fw_device.work:
      - performs node probe, update, shutdown, revival, removal; including
        kernel driver probe, update, shutdown and bus reset notification to
        userspace drivers
      - usually sleeps moderately long, in corner cases very long
      - is scheduled by
          - firewire-ohci's self-ID-complete IRQ handler tasklet via the
            core's fw_node_event
          - firewire-ohci's pci_remove method via core's fw_destroy_nodes/
            fw_node_event
          - itself during retries, e.g. while a node is powering up
    
    iso_resource.work:
      - accesses registers at the Isochronous Resource Manager node
      - usually does not (but may in corner cases) sleep for long
      - is scheduled via schedule_iso_resource() by
          - the owning userspace driver at addition and removal of the
            resource
          - firewire-core's fw_device.work instances after bus reset
          - itself in case of resource allocation if necessary to obey the
            1000ms reallocation period after bus reset
    
    fw_card.br_work instances should not, and instances of the others must
    not, be executed in parallel by multiple CPUs -- but were not protected
    against that.  Hence allocate a non-reentrant workqueue for them.
    
    fw_device.work may be used in the memory reclaim path in case of SBP-2
    device updates.  Hence we need a workqueue with rescuer and cannot use
    system_nrt_wq.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>
    Reviewed-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/firewire/core.h b/drivers/firewire/core.h
index 0fe4e4e6eda7..00ea7730c6a7 100644
--- a/drivers/firewire/core.h
+++ b/drivers/firewire/core.h
@@ -140,6 +140,8 @@ void fw_cdev_handle_phy_packet(struct fw_card *card, struct fw_packet *p);
 extern struct rw_semaphore fw_device_rwsem;
 extern struct idr fw_device_idr;
 extern int fw_cdev_major;
+struct workqueue_struct;
+extern struct workqueue_struct *fw_wq;
 
 struct fw_device *fw_device_get_by_devt(dev_t devt);
 int fw_device_set_broadcast_channel(struct device *dev, void *gen);

commit 13882a82ee1646336c3996c93b4a560a55d2a419
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon May 2 09:33:56 2011 +0200

    firewire: optimize iso queueing by setting wake only after the last packet
    
    When queueing iso packets, the run time is dominated by the two
    MMIO accesses that set the DMA context's wake bit.  Because most
    drivers submit packets in batches, we can save much time by
    removing all but the last wakeup.
    
    The internal kernel API is changed to require a call to
    fw_iso_context_queue_flush() after a batch of queued packets.
    The user space API does not change, so one call to
    FW_CDEV_IOC_QUEUE_ISO must specify multiple packets to take
    advantage of this optimization.
    
    In my measurements, this patch reduces the time needed to queue
    fifty skip packets from userspace to one sixth on a 2.5 GHz CPU,
    or to one third at 800 MHz.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/core.h b/drivers/firewire/core.h
index 25e729cde2f7..0fe4e4e6eda7 100644
--- a/drivers/firewire/core.h
+++ b/drivers/firewire/core.h
@@ -97,6 +97,8 @@ struct fw_card_driver {
 			 struct fw_iso_buffer *buffer,
 			 unsigned long payload);
 
+	void (*flush_queue_iso)(struct fw_iso_context *ctx);
+
 	int (*stop_iso)(struct fw_iso_context *ctx);
 };
 

commit 31ef9134eb52636d383a7d0626cbbd345cb94f2f
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Tue Mar 15 07:53:21 2011 +0100

    ALSA: add LaCie FireWire Speakers/Griffin FireWave Surround driver
    
    Add a driver for two playback-only FireWire devices based on the OXFW970
    chip.
    
    v2: better AMDTP API abstraction; fix fw_unit leak; small fixes
    v3: cache the iPCR value
    v4: FireWave constraints; fix fw_device reference counting;
        fix PCR caching; small changes and fixes
    v5: volume/mute support; fix crashing due to pcm stop races
    v6: fix build; one-channel volume for LaCie
    v7: use signed values to make volume (range checks) work; fix function
        block IDs for volume/mute; always use channel 0 for LaCie volume
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Acked-by: Stefan Richter <stefanr@s5r6.in-berlin.de>
    Tested-by: Jay Fenlason <fenlason@redhat.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/drivers/firewire/core.h b/drivers/firewire/core.h
index f8dfcf1c6cbe..25e729cde2f7 100644
--- a/drivers/firewire/core.h
+++ b/drivers/firewire/core.h
@@ -147,9 +147,6 @@ void fw_node_event(struct fw_card *card, struct fw_node *node, int event);
 /* -iso */
 
 int fw_iso_buffer_map(struct fw_iso_buffer *buffer, struct vm_area_struct *vma);
-void fw_iso_resource_manage(struct fw_card *card, int generation,
-			    u64 channels_mask, int *channel, int *bandwidth,
-			    bool allocate, __be32 buffer[2]);
 
 
 /* -topology */

commit 5b06db166c4d38638980283505259fa165d4f369
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Tue Nov 30 08:24:47 2010 +0100

    firewire: make PHY packet header format consistent
    
    Change the header of PHY packets to be sent to include a pseudo
    transaction code.  This makes the header consistent with that of
    received PHY packets, and allows at_context_queue_packet() and
    log_ar_at_event() to see the packet type directly instead of having
    to deduce it from the header length or even from the header contents.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/core.h b/drivers/firewire/core.h
index e6239f971be6..f8dfcf1c6cbe 100644
--- a/drivers/firewire/core.h
+++ b/drivers/firewire/core.h
@@ -215,9 +215,11 @@ static inline bool is_next_generation(int new_generation, int old_generation)
 
 /* -transaction */
 
+#define TCODE_LINK_INTERNAL		0xe
+
 #define TCODE_IS_READ_REQUEST(tcode)	(((tcode) & ~1) == 4)
 #define TCODE_IS_BLOCK_PACKET(tcode)	(((tcode) &  1) != 0)
-#define TCODE_IS_LINK_INTERNAL(tcode)	((tcode) == 0xe)
+#define TCODE_IS_LINK_INTERNAL(tcode)	((tcode) == TCODE_LINK_INTERNAL)
 #define TCODE_IS_REQUEST(tcode)		(((tcode) &  2) == 0)
 #define TCODE_IS_RESPONSE(tcode)	(((tcode) &  2) != 0)
 #define TCODE_HAS_REQUEST_DATA(tcode)	(((tcode) & 12) != 4)

commit 872e330e38806d835bd6c311c93ab998e2fb9058
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Thu Jul 29 18:19:22 2010 +0200

    firewire: add isochronous multichannel reception
    
    This adds the DMA context programming and userspace ABI for multichannel
    reception, i.e. for listening on multiple channel numbers by means of a
    single DMA context.
    
    The use case is reception of more streams than there are IR DMA units
    offered by the link layer.  This is already implemented by the older
    ohci1394 + ieee1394 + raw1394 stack.  And as discussed recently on
    linux1394-devel, this feature is occasionally used in practice.
    
    The big drawbacks of this mode are that buffer layout and interrupt
    generation necessarily differ from single-channel reception:  Headers
    and trailers are not stripped from packets, packets are not aligned with
    buffer chunks, interrupts are per buffer chunk, not per packet.
    
    These drawbacks also cause a rather hefty code footprint to support this
    rarely used OHCI-1394 feature.  (367 lines added, among them 94 lines of
    added userspace ABI documentation.)
    
    This implementation enforces that a multichannel reception context may
    only listen to channels to which no single-channel context on the same
    link layer is presently listening to.  OHCI-1394 would allow to overlay
    single-channel contexts by the multi-channel context, but this would be
    a departure from the present first-come-first-served policy of IR
    context creation.
    
    The implementation is heavily based on an earlier one by Jay Fenlason.
    Thanks Jay.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/core.h b/drivers/firewire/core.h
index 28621e44b111..e6239f971be6 100644
--- a/drivers/firewire/core.h
+++ b/drivers/firewire/core.h
@@ -90,6 +90,8 @@ struct fw_card_driver {
 	int (*start_iso)(struct fw_iso_context *ctx,
 			 s32 cycle, u32 sync, u32 tags);
 
+	int (*set_iso_channels)(struct fw_iso_context *ctx, u64 *channels);
+
 	int (*queue_iso)(struct fw_iso_context *ctx,
 			 struct fw_iso_packet *packet,
 			 struct fw_iso_buffer *buffer,

commit cc550216ae9a2993ef3973464714dc1a39ab1f86
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sun Jul 18 13:00:50 2010 +0200

    firewire: cdev: add PHY pinging
    
    This extends the FW_CDEV_IOC_SEND_PHY_PACKET ioctl() for /dev/fw* to be
    useful for ping time measurements.  One application for it would be gap
    count optimization in userspace that is based on ping times rather than
    hop count.  (The latter is implemented in firewire-core itself but is
    not applicable to beta PHYs that act as repeater.)
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/core.h b/drivers/firewire/core.h
index 3102b6b63438..28621e44b111 100644
--- a/drivers/firewire/core.h
+++ b/drivers/firewire/core.h
@@ -234,4 +234,9 @@ void fw_fill_response(struct fw_packet *response, u32 *request_header,
 void fw_send_phy_config(struct fw_card *card,
 			int node_id, int generation, int gap_count);
 
+static inline bool is_ping_packet(u32 *data)
+{
+	return (data[0] & 0xc0ffffff) == 0 && ~data[0] == data[1];
+}
+
 #endif /* _FIREWIRE_CORE_H */

commit bf54e1462b9192fdef7ea9e2bc44fdc16a4b87bc
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Fri Jul 16 22:25:51 2010 +0200

    firewire: cdev: add PHY packet reception
    
    Add an FW_CDEV_IOC_RECEIVE_PHY_PACKETS ioctl() and
    FW_CDEV_EVENT_PHY_PACKET_RECEIVED poll()/read() event for /dev/fw*.
    This can be used to get information from remote PHYs by remote access
    PHY packets.
    
    This is also the 2nd half of the functionality (the receive part) to
    support a userspace implementation of a VersaPHY transaction layer.
    
    Safety considerations:
    
      - PHY packets are generally broadcasts, hence some kind of elevated
        privileges should be required of a process to be able to listen in
        on PHY packets.  This implementation assumes that a process that is
        allowed to open the /dev/fw* of a local node does have this
        privilege.
    
        There was an inconclusive discussion about introducing POSIX
        capabilities as a means to check for user privileges for these
        kinds of operations.
    
    Other limitations:
    
      - PHY packet reception may be switched on by ioctl() but cannot be
        switched off again.  It would be trivial to provide an off switch,
        but this is not worth the code.  The client should simply close()
        the fd then, or just ignore further events.
    
      - For sake of simplicity of API and kernel-side implementation, no
        filter per packet content is provided.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/core.h b/drivers/firewire/core.h
index ff6c90922001..3102b6b63438 100644
--- a/drivers/firewire/core.h
+++ b/drivers/firewire/core.h
@@ -128,6 +128,7 @@ extern const struct file_operations fw_device_ops;
 
 void fw_device_cdev_update(struct fw_device *device);
 void fw_device_cdev_remove(struct fw_device *device);
+void fw_cdev_handle_phy_packet(struct fw_card *card, struct fw_packet *p);
 
 
 /* -device */
@@ -214,6 +215,7 @@ static inline bool is_next_generation(int new_generation, int old_generation)
 
 #define TCODE_IS_READ_REQUEST(tcode)	(((tcode) & ~1) == 4)
 #define TCODE_IS_BLOCK_PACKET(tcode)	(((tcode) &  1) != 0)
+#define TCODE_IS_LINK_INTERNAL(tcode)	((tcode) == 0xe)
 #define TCODE_IS_REQUEST(tcode)		(((tcode) &  2) == 0)
 #define TCODE_IS_RESPONSE(tcode)	(((tcode) &  2) != 0)
 #define TCODE_HAS_REQUEST_DATA(tcode)	(((tcode) & 12) != 4)

commit 02d37bed188c500ee7afb0a2dc6b65a80704c58e
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Thu Jul 8 16:09:06 2010 +0200

    firewire: core: integrate software-forced bus resets with bus management
    
    Bus resets which are triggered
      - by the kernel drivers after updates of the local nodes' config ROM,
      - by userspace software via ioctl
    shall be deferred until after >=2 seconds after the last bus reset.
    
    If multiple modifications of the local nodes' config ROM happen in a row,
    only a single bus reset should happen after them.
    
    When the local node's link goes from inactive to active or vice versa,
    and at the two occasions of bus resets mentioned above --- and if the
    current gap count differs from 63 --- the bus reset should be preceded
    by a PHY configuration packet that reaffirms the gap count.  Otherwise a
    bus manager would have to reset the bus again right after that.
    
    This is necessary to promote bus stability, e.g. leave grace periods for
    allocations and reallocations of isochronous channels and bandwidth,
    SBP-2 reconnections etc.; see IEEE 1394 clause 8.2.1.
    
    This change implements all of the above by moving bus reset initiation
    into a delayed work (except for bus resets which are triggered by the
    bus manager workqueue job and are performed there immediately).  It
    comes with a necessary addition to the card driver methods that allows
    to get the current gap count from PHY registers.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/core.h b/drivers/firewire/core.h
index 3000dd74acfd..ff6c90922001 100644
--- a/drivers/firewire/core.h
+++ b/drivers/firewire/core.h
@@ -51,6 +51,7 @@ struct fw_card_driver {
 	int (*enable)(struct fw_card *card,
 		      const __be32 *config_rom, size_t length);
 
+	int (*read_phy_reg)(struct fw_card *card, int address);
 	int (*update_phy_reg)(struct fw_card *card, int address,
 			      int clear_bits, int set_bits);
 
@@ -102,8 +103,8 @@ void fw_card_initialize(struct fw_card *card,
 int fw_card_add(struct fw_card *card,
 		u32 max_receive, u32 link_speed, u64 guid);
 void fw_core_remove_card(struct fw_card *card);
-int fw_core_initiate_bus_reset(struct fw_card *card, int short_reset);
 int fw_compute_block_crc(__be32 *block);
+void fw_schedule_bus_reset(struct fw_card *card, bool delayed, bool short_reset);
 void fw_schedule_bm_work(struct fw_card *card, unsigned long delay);
 
 static inline struct fw_card *fw_card_get(struct fw_card *card)
@@ -225,6 +226,9 @@ void fw_core_handle_response(struct fw_card *card, struct fw_packet *packet);
 int fw_get_response_length(struct fw_request *request);
 void fw_fill_response(struct fw_packet *response, u32 *request_header,
 		      int rcode, void *payload, size_t length);
+
+#define FW_PHY_CONFIG_NO_NODE_ID	-1
+#define FW_PHY_CONFIG_CURRENT_GAP_COUNT	-1
 void fw_send_phy_config(struct fw_card *card,
 			int node_id, int generation, int gap_count);
 

commit 0fcff4e39323f466a47684d7c8ffa77e1be86c8a
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sat Jun 12 20:35:52 2010 +0200

    firewire: rename CSR access driver methods
    
    Rather than "read a Control and Status Registers (CSR) Architecture
    register" I prefer to say "read a Control and Status Register".
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/core.h b/drivers/firewire/core.h
index 8280c625170b..3000dd74acfd 100644
--- a/drivers/firewire/core.h
+++ b/drivers/firewire/core.h
@@ -78,8 +78,8 @@ struct fw_card_driver {
 	int (*enable_phys_dma)(struct fw_card *card,
 			       int node_id, int generation);
 
-	u32 (*read_csr_reg)(struct fw_card *card, int csr_offset);
-	void (*write_csr_reg)(struct fw_card *card, int csr_offset, u32 value);
+	u32 (*read_csr)(struct fw_card *card, int csr_offset);
+	void (*write_csr)(struct fw_card *card, int csr_offset, u32 value);
 
 	struct fw_iso_context *
 	(*allocate_iso_context)(struct fw_card *card,

commit c8a94ded57e9cc2498d401b2f5c856213a3e19fb
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sat Jun 12 20:34:50 2010 +0200

    firewire: normalize STATE_CLEAR/SET CSR access interface
    
    Push the maintenance of STATE_CLEAR/SET.abdicate down into the card
    driver.  This way, the read/write_csr_reg driver method works uniformly
    across all CSR offsets.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/core.h b/drivers/firewire/core.h
index 8dc76d8711a5..8280c625170b 100644
--- a/drivers/firewire/core.h
+++ b/drivers/firewire/core.h
@@ -196,7 +196,7 @@ static inline void fw_node_put(struct fw_node *node)
 }
 
 void fw_core_handle_bus_reset(struct fw_card *card, int node_id,
-			      int generation, int self_id_count, u32 *self_ids);
+	int generation, int self_id_count, u32 *self_ids, bool bm_abdicate);
 void fw_destroy_nodes(struct fw_card *card);
 
 /*

commit db3c9cc105ee844f6cd7a1beb9926fb8e9a093ae
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sat Jun 12 20:30:21 2010 +0200

    firewire: replace get_features card driver hook
    
    by feature variables in the fw_card struct.  The hook appeared to be an
    unnecessary abstraction in the card driver interface.
    
    Cleaner would be to pass those feature flags as arguments to
    fw_card_initialize() or fw_card_add(), but the FairnessControl register
    is in the SCLK domain and may therefore not be accessible while Link
    Power Status is off, i.e. before the card->driver->enable call from
    fw_card_add().
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/core.h b/drivers/firewire/core.h
index 3f9e39b60bca..8dc76d8711a5 100644
--- a/drivers/firewire/core.h
+++ b/drivers/firewire/core.h
@@ -38,9 +38,6 @@ struct fw_packet;
 #define BROADCAST_CHANNEL_INITIAL	(1 << 31 | 31)
 #define BROADCAST_CHANNEL_VALID		(1 << 30)
 
-#define FEATURE_PRIORITY_BUDGET		0x01
-#define FEATURE_CHANNEL_31_ALLOCATED	0x02
-
 #define CSR_STATE_BIT_CMSTR	(1 << 8)
 #define CSR_STATE_BIT_ABDICATE	(1 << 10)
 
@@ -84,8 +81,6 @@ struct fw_card_driver {
 	u32 (*read_csr_reg)(struct fw_card *card, int csr_offset);
 	void (*write_csr_reg)(struct fw_card *card, int csr_offset, u32 value);
 
-	unsigned int (*get_features)(struct fw_card *card);
-
 	struct fw_iso_context *
 	(*allocate_iso_context)(struct fw_card *card,
 				int type, int channel, size_t header_size);

commit e91b2787d0a2e4719b016e8dec0afd2d5ab6c30f
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Thu Jun 10 08:40:49 2010 +0200

    firewire: allocate broadcast channel in hardware
    
    On OHCI 1.1 controllers, let the hardware allocate the broadcast channel
    automatically.  This removes a theoretical race condition directly after
    a bus reset where it could be possible to read the channel allocation
    register with channel 31 still being unallocated.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/drivers/firewire/core.h b/drivers/firewire/core.h
index a9ace1f8dc3f..3f9e39b60bca 100644
--- a/drivers/firewire/core.h
+++ b/drivers/firewire/core.h
@@ -39,6 +39,7 @@ struct fw_packet;
 #define BROADCAST_CHANNEL_VALID		(1 << 30)
 
 #define FEATURE_PRIORITY_BUDGET		0x01
+#define FEATURE_CHANNEL_31_ALLOCATED	0x02
 
 #define CSR_STATE_BIT_CMSTR	(1 << 8)
 #define CSR_STATE_BIT_ABDICATE	(1 << 10)

commit 7e0e314f198d5048b74c8f0ef9f4c1c02e5ecfc9
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Thu Jun 10 08:37:15 2010 +0200

    firewire: core: add CSR abdicate support
    
    Implement the abdicate bit, which is required for bus manager
    capable nodes and tested by the Base 1394 Test Suite.
    
    Finally, something to do at a command reset!  :-)
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/drivers/firewire/core.h b/drivers/firewire/core.h
index aaecdd1c1767..a9ace1f8dc3f 100644
--- a/drivers/firewire/core.h
+++ b/drivers/firewire/core.h
@@ -41,6 +41,7 @@ struct fw_packet;
 #define FEATURE_PRIORITY_BUDGET		0x01
 
 #define CSR_STATE_BIT_CMSTR	(1 << 8)
+#define CSR_STATE_BIT_ABDICATE	(1 << 10)
 
 struct fw_card_driver {
 	/*

commit 4ffb7a6a066e4be4577976d1c08e237c7479770a
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Thu Jun 10 08:36:37 2010 +0200

    firewire: add CSR cmstr support
    
    Implement the cmstr bit, which is required for cycle master capable
    nodes and tested for by the Base 1394 Test Suite.
    
    This bit allows the bus master to disable cycle start packets; there are
    bus master implementations that actually do this.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/drivers/firewire/core.h b/drivers/firewire/core.h
index 3b8c0f042f49..aaecdd1c1767 100644
--- a/drivers/firewire/core.h
+++ b/drivers/firewire/core.h
@@ -40,6 +40,8 @@ struct fw_packet;
 
 #define FEATURE_PRIORITY_BUDGET		0x01
 
+#define CSR_STATE_BIT_CMSTR	(1 << 8)
+
 struct fw_card_driver {
 	/*
 	 * Enable the given card with the given initial config rom.

commit a1a1132bd83d0aea51d4f19be4b4a58a064a0131
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Thu Jun 10 08:35:06 2010 +0200

    firewire: add CSR PRIORITY_BUDGET support
    
    If supported by the OHCI controller, implement the PRIORITY_BUDGET
    register, which is required for nodes that can use asynchronous
    priority arbitration.
    
    To allow the core to determine what features the lowlevel device
    supports, add a new card driver callback.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/drivers/firewire/core.h b/drivers/firewire/core.h
index efcdeb2e31e6..3b8c0f042f49 100644
--- a/drivers/firewire/core.h
+++ b/drivers/firewire/core.h
@@ -38,6 +38,8 @@ struct fw_packet;
 #define BROADCAST_CHANNEL_INITIAL	(1 << 31 | 31)
 #define BROADCAST_CHANNEL_VALID		(1 << 30)
 
+#define FEATURE_PRIORITY_BUDGET		0x01
+
 struct fw_card_driver {
 	/*
 	 * Enable the given card with the given initial config rom.
@@ -78,6 +80,8 @@ struct fw_card_driver {
 	u32 (*read_csr_reg)(struct fw_card *card, int csr_offset);
 	void (*write_csr_reg)(struct fw_card *card, int csr_offset, u32 value);
 
+	unsigned int (*get_features)(struct fw_card *card);
+
 	struct fw_iso_context *
 	(*allocate_iso_context)(struct fw_card *card,
 				int type, int channel, size_t header_size);

commit 506f1a31932747f56a5029d5b3c14b1b68f41ccc
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Thu Jun 10 08:25:19 2010 +0200

    firewire: add CSR NODE_IDS support
    
    The NODE_IDS register, and especially its bus_id field, is quite
    useless because 1394.1 requires that the bus_id field always stays
    0x3ff.  However, the 1394 specification requires this register on all
    transaction capable nodes, and the Base 1394 Test Suite tests for it,
    so we better implement it.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/drivers/firewire/core.h b/drivers/firewire/core.h
index c19e9873e433..efcdeb2e31e6 100644
--- a/drivers/firewire/core.h
+++ b/drivers/firewire/core.h
@@ -76,6 +76,7 @@ struct fw_card_driver {
 			       int node_id, int generation);
 
 	u32 (*read_csr_reg)(struct fw_card *card, int csr_offset);
+	void (*write_csr_reg)(struct fw_card *card, int csr_offset, u32 value);
 
 	struct fw_iso_context *
 	(*allocate_iso_context)(struct fw_card *card,

commit 60d32970c5a32e8c4f340a9e41993759ad658ef2
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Thu Jun 10 08:24:35 2010 +0200

    firewire: add read_csr_reg driver callback
    
    To prepare for the following additions of more OHCI-implemented CSR
    registers, replace the get_cycle_time driver callback with a generic
    CSR register callback.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/drivers/firewire/core.h b/drivers/firewire/core.h
index 25a72e57a0cd..c19e9873e433 100644
--- a/drivers/firewire/core.h
+++ b/drivers/firewire/core.h
@@ -75,7 +75,7 @@ struct fw_card_driver {
 	int (*enable_phys_dma)(struct fw_card *card,
 			       int node_id, int generation);
 
-	u32 (*get_cycle_time)(struct fw_card *card);
+	u32 (*read_csr_reg)(struct fw_card *card, int csr_offset);
 
 	struct fw_iso_context *
 	(*allocate_iso_context)(struct fw_card *card,

commit a10c0ce76098857b899505d05de9f2e13ddf7a7a
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Wed May 19 08:28:32 2010 +0200

    firewire: check cdev response length
    
    Add a check that the data length in the SEND_RESPONSE ioctl is correct.
    Incidentally, this also fixes the previously wrong response length of
    software-handled lock requests.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/core.h b/drivers/firewire/core.h
index 0ecfcd95f4c5..25a72e57a0cd 100644
--- a/drivers/firewire/core.h
+++ b/drivers/firewire/core.h
@@ -218,6 +218,7 @@ static inline bool is_next_generation(int new_generation, int old_generation)
 
 void fw_core_handle_request(struct fw_card *card, struct fw_packet *request);
 void fw_core_handle_response(struct fw_card *card, struct fw_packet *packet);
+int fw_get_response_length(struct fw_request *request);
 void fw_fill_response(struct fw_packet *response, u32 *request_header,
 		      int rcode, void *payload, size_t length);
 void fw_send_phy_config(struct fw_card *card,

commit 5c40cbfefa828208c671e2f58789e4dd04f79563
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Tue Apr 27 09:07:00 2010 +0200

    firewire: core: use separate timeout for each transaction
    
    Using a single timeout for all transaction that need to be flushed does
    not work if the submission of new transactions can defer the timeout
    indefinitely into the future.  We need to have timeouts that do not
    change due to other transactions; the simplest way to do this is with a
    separate timer for each transaction.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de> (+ one lockdep annotation)

diff --git a/drivers/firewire/core.h b/drivers/firewire/core.h
index 7a9759bf6837..0ecfcd95f4c5 100644
--- a/drivers/firewire/core.h
+++ b/drivers/firewire/core.h
@@ -220,7 +220,6 @@ void fw_core_handle_request(struct fw_card *card, struct fw_packet *request);
 void fw_core_handle_response(struct fw_card *card, struct fw_packet *packet);
 void fw_fill_response(struct fw_packet *response, u32 *request_header,
 		      int rcode, void *payload, size_t length);
-void fw_flush_transactions(struct fw_card *card);
 void fw_send_phy_config(struct fw_card *card,
 			int node_id, int generation, int gap_count);
 

commit 925e7a6504966b838c519f009086982c68e0666f
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Sun Apr 4 15:19:54 2010 +0200

    firewire: ohci: enable 1394a enhancements
    
    The OHCI spec says that, if the programPhyEnable bit is set, the driver
    is responsible for configuring the IEEE1394a enhancements within the PHY
    and the link consistently.  So do this.
    
    Also add a quirk to allow disabling these enhancements; this is needed
    for the TSB12LV22 where ack accelerations are buggy (erratum b).
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/core.h b/drivers/firewire/core.h
index b2a7b651473a..7a9759bf6837 100644
--- a/drivers/firewire/core.h
+++ b/drivers/firewire/core.h
@@ -27,8 +27,12 @@ struct fw_packet;
 #define PHY_LINK_ACTIVE		0x80
 #define PHY_CONTENDER		0x40
 #define PHY_BUS_RESET		0x40
+#define PHY_EXTENDED_REGISTERS	0xe0
 #define PHY_BUS_SHORT_RESET	0x40
 #define PHY_INT_STATUS_BITS	0x3c
+#define PHY_ENABLE_ACCEL	0x02
+#define PHY_ENABLE_MULTI	0x01
+#define PHY_PAGE_SELECT		0xe0
 
 #define BANDWIDTH_AVAILABLE_INITIAL	4915
 #define BROADCAST_CHANNEL_INITIAL	(1 << 31 | 31)

commit e7014dada041982ae12ba7fd1967ca0ab0243e04
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Thu Apr 1 16:40:18 2010 +0200

    firewire: ohci: do not clear PHY interrupt status inadvertently
    
    The interrupt status bits in PHY register 5 are cleared by writing a one
    bit.  To avoid clearing them unadvertently, do not write them back when
    they were read as set, but only when they have been explicitly requested
    to be set.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/core.h b/drivers/firewire/core.h
index fb0321300cce..b2a7b651473a 100644
--- a/drivers/firewire/core.h
+++ b/drivers/firewire/core.h
@@ -28,6 +28,7 @@ struct fw_packet;
 #define PHY_CONTENDER		0x40
 #define PHY_BUS_RESET		0x40
 #define PHY_BUS_SHORT_RESET	0x40
+#define PHY_INT_STATUS_BITS	0x3c
 
 #define BANDWIDTH_AVAILABLE_INITIAL	4915
 #define BROADCAST_CHANNEL_INITIAL	(1 << 31 | 31)

commit 168cf9af699e87d5a6f44b684583714ecabb8e71
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sun Feb 14 18:49:18 2010 +0100

    firewire: remove incomplete Bus_Time CSR support
    
    The current implementation of Bus_Time read access was buggy since it
    did not ensure that Bus_Time.second_count_hi and second_count_lo came
    from the same 128 seconds period.
    
    Reported-by: Håkan Johansson <f96hajo@chalmers.se>
    
    Instead of a fix, remove Bus_Time register support altogether.  The spec
    requires all cycle master capable nodes to implement this (all Linux
    nodes are cycle master capable) while it also says that it "may" be
    initialized by the bus manager or by the IRM standing in for a bus
    manager.  (Neither Linux' firewire-core nor ieee1394 nodemgr implement
    this.)
    
    Since we cannot rely on Bus_Time having been initialized by a bus
    manager, it is better to return an error instead of a nonsensical value
    on a read request to Bus_Time.
    
    Alternatively, we could fix the Bus_Time read integrity bug _and_
    implement (a) cycle master's write support of the register as well as
    (b) bus manager's Bus_Time initialization service, i.e. preservation of
    the Bus_Time when the cycle master node of a bus changes.  However, that
    would be quite some code for a feature that is unreliable to begin with
    and very likely unused in practice.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/core.h b/drivers/firewire/core.h
index ed3b1a765c00..fb0321300cce 100644
--- a/drivers/firewire/core.h
+++ b/drivers/firewire/core.h
@@ -70,7 +70,7 @@ struct fw_card_driver {
 	int (*enable_phys_dma)(struct fw_card *card,
 			       int node_id, int generation);
 
-	u64 (*get_bus_time)(struct fw_card *card);
+	u32 (*get_cycle_time)(struct fw_card *card);
 
 	struct fw_iso_context *
 	(*allocate_iso_context)(struct fw_card *card,

commit cb7c96da3651111efbe088fa12f9bed61836ea93
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Thu Oct 8 00:42:53 2009 +0200

    firewire: core: optimize Topology Map creation
    
    The Topology Map of the local node was created in CPU byte order,
    then a temporary big endian copy was created to compute the CRC,
    and when a read request to the Topology Map arrived it had to be
    converted to big endian byte order again.
    
    We now generate it in big endian byte order in the first place.
    This also rids us of 1000 bytes stack usage in tasklet context.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/core.h b/drivers/firewire/core.h
index 7adca7cb9f55..ed3b1a765c00 100644
--- a/drivers/firewire/core.h
+++ b/drivers/firewire/core.h
@@ -94,7 +94,7 @@ int fw_card_add(struct fw_card *card,
 		u32 max_receive, u32 link_speed, u64 guid);
 void fw_core_remove_card(struct fw_card *card);
 int fw_core_initiate_bus_reset(struct fw_card *card, int short_reset);
-int fw_compute_block_crc(u32 *block);
+int fw_compute_block_crc(__be32 *block);
 void fw_schedule_bm_work(struct fw_card *card, unsigned long delay);
 
 static inline struct fw_card *fw_card_get(struct fw_card *card)

commit 8e85973efc87dfae8508f1a3440fd44612897458
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Thu Oct 8 00:41:59 2009 +0200

    firewire: optimize config ROM creation
    
    The config ROM image of the local node was created in CPU byte order,
    then a temporary big endian copy was created to compute the CRC, and
    finally the card driver created its own big endian copy.
    
    We now generate it in big endian byte order in the first place to avoid
    one byte order conversion and the temporary on-stack copy of the ROM
    image (1000 bytes stack usage in process context).  Furthermore, two
    1000 bytes memset()s are replaced by one 1000 bytes - ROM length sized
    memset.
    
    The trivial fw_memcpy_{from,to}_be32() helpers are now superfluous and
    removed.  The newly added __compute_block_crc() function will be folded
    into fw_compute_block_crc() in a subsequent change.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/core.h b/drivers/firewire/core.h
index 7ff6e7585152..7adca7cb9f55 100644
--- a/drivers/firewire/core.h
+++ b/drivers/firewire/core.h
@@ -40,7 +40,8 @@ struct fw_card_driver {
 	 * enable the PHY or set the link_on bit and initiate a bus
 	 * reset.
 	 */
-	int (*enable)(struct fw_card *card, u32 *config_rom, size_t length);
+	int (*enable)(struct fw_card *card,
+		      const __be32 *config_rom, size_t length);
 
 	int (*update_phy_reg)(struct fw_card *card, int address,
 			      int clear_bits, int set_bits);
@@ -48,10 +49,10 @@ struct fw_card_driver {
 	/*
 	 * Update the config rom for an enabled card.  This function
 	 * should change the config rom that is presented on the bus
-	 * an initiate a bus reset.
+	 * and initiate a bus reset.
 	 */
 	int (*set_config_rom)(struct fw_card *card,
-			      u32 *config_rom, size_t length);
+			      const __be32 *config_rom, size_t length);
 
 	void (*send_request)(struct fw_card *card, struct fw_packet *packet);
 	void (*send_response)(struct fw_card *card, struct fw_packet *packet);

commit 18668ff9a3232d5f942a2f7abc1ad67d2760dcdf
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sun Sep 6 18:49:48 2009 +0200

    firewire: core: header file cleanup
    
    fw_card_get, fw_card_put, fw_card_release are currently not exported for
    use outside the firewire-core.  Move their definitions/ declarations
    from the subsystem header file to the core header file.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/core.h b/drivers/firewire/core.h
index 6052816be353..7ff6e7585152 100644
--- a/drivers/firewire/core.h
+++ b/drivers/firewire/core.h
@@ -96,6 +96,20 @@ int fw_core_initiate_bus_reset(struct fw_card *card, int short_reset);
 int fw_compute_block_crc(u32 *block);
 void fw_schedule_bm_work(struct fw_card *card, unsigned long delay);
 
+static inline struct fw_card *fw_card_get(struct fw_card *card)
+{
+	kref_get(&card->kref);
+
+	return card;
+}
+
+void fw_card_release(struct kref *kref);
+
+static inline void fw_card_put(struct fw_card *card)
+{
+	kref_put(&card->kref, fw_card_release);
+}
+
 
 /* -cdev */
 

commit 6fdc03709433ccc2005f0f593ae9d9dd04f7b485
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sat Jun 20 13:23:59 2009 +0200

    firewire: core: do not DMA-map stack addresses
    
    The DMA mapping API cannot map on-stack addresses, as explained in
    Documentation/DMA-mapping.txt.  Convert the two cases of on-stack packet
    payload buffers in firewire-core (payload of lock requests in the bus
    manager work and in iso resource management) to slab-allocated memory.
    
    There are a number on-stack buffers for quadlet write or quadlet read
    requests in firewire-core and firewire-sbp2.  These are harmless; they
    are copied to/ from card driver internal DMA buffers since quadlet
    payloads are inlined with packet headers.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/core.h b/drivers/firewire/core.h
index c3cfc647e5e3..6052816be353 100644
--- a/drivers/firewire/core.h
+++ b/drivers/firewire/core.h
@@ -120,7 +120,8 @@ void fw_node_event(struct fw_card *card, struct fw_node *node, int event);
 
 int fw_iso_buffer_map(struct fw_iso_buffer *buffer, struct vm_area_struct *vma);
 void fw_iso_resource_manage(struct fw_card *card, int generation,
-		u64 channels_mask, int *channel, int *bandwidth, bool allocate);
+			    u64 channels_mask, int *channel, int *bandwidth,
+			    bool allocate, __be32 buffer[2]);
 
 
 /* -topology */

commit c76acec6d55107b652a37c90b36c00bc8b04dabb
Author: Jay Fenlason <fenlason@redhat.com>
Date:   Mon May 18 13:08:06 2009 -0400

    firewire: add IPv4 support
    
    Implement IPv4 over IEEE 1394 as per RFC 2734 for the newer firewire
    stack.  This feature has only been present in the older ieee1394 stack
    via the eth1394 driver.
    
    Still to do:
      - fix ipv4_priv and ipv4_node lifetime logic
      - fix determination of speeds and max payloads
      - fix bus reset handling
      - fix unaligned memory accesses
      - fix coding style
      - further testing/ improvement of fragment reassembly
      - perhaps multicast support
    
    Signed-off-by: Jay Fenlason <fenlason@redhat.com>
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de> (rebased, copyright note, changelog)

diff --git a/drivers/firewire/core.h b/drivers/firewire/core.h
index 0a25a7b38a80..c3cfc647e5e3 100644
--- a/drivers/firewire/core.h
+++ b/drivers/firewire/core.h
@@ -1,7 +1,6 @@
 #ifndef _FIREWIRE_CORE_H
 #define _FIREWIRE_CORE_H
 
-#include <linux/dma-mapping.h>
 #include <linux/fs.h>
 #include <linux/list.h>
 #include <linux/idr.h>
@@ -97,17 +96,6 @@ int fw_core_initiate_bus_reset(struct fw_card *card, int short_reset);
 int fw_compute_block_crc(u32 *block);
 void fw_schedule_bm_work(struct fw_card *card, unsigned long delay);
 
-struct fw_descriptor {
-	struct list_head link;
-	size_t length;
-	u32 immediate;
-	u32 key;
-	const u32 *data;
-};
-
-int fw_core_add_descriptor(struct fw_descriptor *desc);
-void fw_core_remove_descriptor(struct fw_descriptor *desc);
-
 
 /* -cdev */
 
@@ -130,77 +118,7 @@ void fw_node_event(struct fw_card *card, struct fw_node *node, int event);
 
 /* -iso */
 
-/*
- * The iso packet format allows for an immediate header/payload part
- * stored in 'header' immediately after the packet info plus an
- * indirect payload part that is pointer to by the 'payload' field.
- * Applications can use one or the other or both to implement simple
- * low-bandwidth streaming (e.g. audio) or more advanced
- * scatter-gather streaming (e.g. assembling video frame automatically).
- */
-struct fw_iso_packet {
-	u16 payload_length;	/* Length of indirect payload. */
-	u32 interrupt:1;	/* Generate interrupt on this packet */
-	u32 skip:1;		/* Set to not send packet at all. */
-	u32 tag:2;
-	u32 sy:4;
-	u32 header_length:8;	/* Length of immediate header. */
-	u32 header[0];
-};
-
-#define FW_ISO_CONTEXT_TRANSMIT	0
-#define FW_ISO_CONTEXT_RECEIVE	1
-
-#define FW_ISO_CONTEXT_MATCH_TAG0	 1
-#define FW_ISO_CONTEXT_MATCH_TAG1	 2
-#define FW_ISO_CONTEXT_MATCH_TAG2	 4
-#define FW_ISO_CONTEXT_MATCH_TAG3	 8
-#define FW_ISO_CONTEXT_MATCH_ALL_TAGS	15
-
-/*
- * An iso buffer is just a set of pages mapped for DMA in the
- * specified direction.  Since the pages are to be used for DMA, they
- * are not mapped into the kernel virtual address space.  We store the
- * DMA address in the page private. The helper function
- * fw_iso_buffer_map() will map the pages into a given vma.
- */
-struct fw_iso_buffer {
-	enum dma_data_direction direction;
-	struct page **pages;
-	int page_count;
-};
-
-typedef void (*fw_iso_callback_t)(struct fw_iso_context *context,
-				  u32 cycle, size_t header_length,
-				  void *header, void *data);
-
-struct fw_iso_context {
-	struct fw_card *card;
-	int type;
-	int channel;
-	int speed;
-	size_t header_size;
-	fw_iso_callback_t callback;
-	void *callback_data;
-};
-
-int fw_iso_buffer_init(struct fw_iso_buffer *buffer, struct fw_card *card,
-		       int page_count, enum dma_data_direction direction);
 int fw_iso_buffer_map(struct fw_iso_buffer *buffer, struct vm_area_struct *vma);
-void fw_iso_buffer_destroy(struct fw_iso_buffer *buffer, struct fw_card *card);
-
-struct fw_iso_context *fw_iso_context_create(struct fw_card *card,
-		int type, int channel, int speed, size_t header_size,
-		fw_iso_callback_t callback, void *callback_data);
-int fw_iso_context_queue(struct fw_iso_context *ctx,
-			 struct fw_iso_packet *packet,
-			 struct fw_iso_buffer *buffer,
-			 unsigned long payload);
-int fw_iso_context_start(struct fw_iso_context *ctx,
-			 int cycle, int sync, int tags);
-int fw_iso_context_stop(struct fw_iso_context *ctx);
-void fw_iso_context_destroy(struct fw_iso_context *ctx);
-
 void fw_iso_resource_manage(struct fw_card *card, int generation,
 		u64 channels_mask, int *channel, int *bandwidth, bool allocate);
 
@@ -285,9 +203,4 @@ void fw_flush_transactions(struct fw_card *card);
 void fw_send_phy_config(struct fw_card *card,
 			int node_id, int generation, int gap_count);
 
-static inline int fw_stream_packet_destination_id(int tag, int channel, int sy)
-{
-	return tag << 14 | channel << 8 | sy;
-}
-
 #endif /* _FIREWIRE_CORE_H */

commit 099d54143e49d49c33cd25779ca725191df59b73
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sat Jun 6 18:37:25 2009 +0200

    firewire: core: prepare for non-core children of card devices
    
    The IP-over-1394 driver will add child devices beneath card devices
    which are not of type fw_device.  Hence firewire-core's callbacks in
    device_for_each_child() and device_find_child() need to check for the
    device type now.
    
    Initial version written by Jay Fenlason.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/core.h b/drivers/firewire/core.h
index 273f0ab82928..0a25a7b38a80 100644
--- a/drivers/firewire/core.h
+++ b/drivers/firewire/core.h
@@ -124,7 +124,7 @@ extern struct idr fw_device_idr;
 extern int fw_cdev_major;
 
 struct fw_device *fw_device_get_by_devt(dev_t devt);
-void fw_device_set_broadcast_channel(struct fw_device *device, int generation);
+int fw_device_set_broadcast_channel(struct device *dev, void *gen);
 void fw_node_event(struct fw_card *card, struct fw_node *node, int event);
 
 

commit 77c9a5daa9c4d9b37812c9c69c7bcbb3f9399c3c
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Fri Jun 5 16:26:18 2009 +0200

    firewire: reorganize header files
    
    The three header files of firewire-core, i.e.
     "drivers/firewire/fw-device.h",
     "drivers/firewire/fw-topology.h",
     "drivers/firewire/fw-transaction.h",
    are replaced by
     "drivers/firewire/core.h",
     "include/linux/firewire.h".
    
    The latter includes everything which a firewire high-level driver (like
    firewire-sbp2) needs besides linux/firewire-constants.h, while core.h
    contains the rest which is needed by firewire-core itself and by low-
    level drivers (card drivers) like firewire-ohci.
    
    High-level drivers can now also reside outside of drivers/firewire
    without having to add drivers/firewire to the header file search path in
    makefiles.  At least the firedtv driver will be such a driver.
    
    I also considered to spread the contents of core.h over several files,
    one for each .c file where the respective implementation resides.  But
    it turned out that most core .c files will end up including most of the
    core .h files.  Also, the combined core.h isn't unreasonably big, and it
    will lose more of its contents to linux/firewire.h anyway soon when more
    firewire drivers are added.  (IP-over-1394, firedtv, and there are plans
    for one or two more.)
    
    Furthermore, fw-ohci.h is renamed to ohci.h.  The name of core.h and
    ohci.h is chosen with regard to name changes of the .c files in a
    follow-up change.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/core.h b/drivers/firewire/core.h
new file mode 100644
index 000000000000..273f0ab82928
--- /dev/null
+++ b/drivers/firewire/core.h
@@ -0,0 +1,293 @@
+#ifndef _FIREWIRE_CORE_H
+#define _FIREWIRE_CORE_H
+
+#include <linux/dma-mapping.h>
+#include <linux/fs.h>
+#include <linux/list.h>
+#include <linux/idr.h>
+#include <linux/mm_types.h>
+#include <linux/rwsem.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+
+#include <asm/atomic.h>
+
+struct device;
+struct fw_card;
+struct fw_device;
+struct fw_iso_buffer;
+struct fw_iso_context;
+struct fw_iso_packet;
+struct fw_node;
+struct fw_packet;
+
+
+/* -card */
+
+/* bitfields within the PHY registers */
+#define PHY_LINK_ACTIVE		0x80
+#define PHY_CONTENDER		0x40
+#define PHY_BUS_RESET		0x40
+#define PHY_BUS_SHORT_RESET	0x40
+
+#define BANDWIDTH_AVAILABLE_INITIAL	4915
+#define BROADCAST_CHANNEL_INITIAL	(1 << 31 | 31)
+#define BROADCAST_CHANNEL_VALID		(1 << 30)
+
+struct fw_card_driver {
+	/*
+	 * Enable the given card with the given initial config rom.
+	 * This function is expected to activate the card, and either
+	 * enable the PHY or set the link_on bit and initiate a bus
+	 * reset.
+	 */
+	int (*enable)(struct fw_card *card, u32 *config_rom, size_t length);
+
+	int (*update_phy_reg)(struct fw_card *card, int address,
+			      int clear_bits, int set_bits);
+
+	/*
+	 * Update the config rom for an enabled card.  This function
+	 * should change the config rom that is presented on the bus
+	 * an initiate a bus reset.
+	 */
+	int (*set_config_rom)(struct fw_card *card,
+			      u32 *config_rom, size_t length);
+
+	void (*send_request)(struct fw_card *card, struct fw_packet *packet);
+	void (*send_response)(struct fw_card *card, struct fw_packet *packet);
+	/* Calling cancel is valid once a packet has been submitted. */
+	int (*cancel_packet)(struct fw_card *card, struct fw_packet *packet);
+
+	/*
+	 * Allow the specified node ID to do direct DMA out and in of
+	 * host memory.  The card will disable this for all node when
+	 * a bus reset happens, so driver need to reenable this after
+	 * bus reset.  Returns 0 on success, -ENODEV if the card
+	 * doesn't support this, -ESTALE if the generation doesn't
+	 * match.
+	 */
+	int (*enable_phys_dma)(struct fw_card *card,
+			       int node_id, int generation);
+
+	u64 (*get_bus_time)(struct fw_card *card);
+
+	struct fw_iso_context *
+	(*allocate_iso_context)(struct fw_card *card,
+				int type, int channel, size_t header_size);
+	void (*free_iso_context)(struct fw_iso_context *ctx);
+
+	int (*start_iso)(struct fw_iso_context *ctx,
+			 s32 cycle, u32 sync, u32 tags);
+
+	int (*queue_iso)(struct fw_iso_context *ctx,
+			 struct fw_iso_packet *packet,
+			 struct fw_iso_buffer *buffer,
+			 unsigned long payload);
+
+	int (*stop_iso)(struct fw_iso_context *ctx);
+};
+
+void fw_card_initialize(struct fw_card *card,
+		const struct fw_card_driver *driver, struct device *device);
+int fw_card_add(struct fw_card *card,
+		u32 max_receive, u32 link_speed, u64 guid);
+void fw_core_remove_card(struct fw_card *card);
+int fw_core_initiate_bus_reset(struct fw_card *card, int short_reset);
+int fw_compute_block_crc(u32 *block);
+void fw_schedule_bm_work(struct fw_card *card, unsigned long delay);
+
+struct fw_descriptor {
+	struct list_head link;
+	size_t length;
+	u32 immediate;
+	u32 key;
+	const u32 *data;
+};
+
+int fw_core_add_descriptor(struct fw_descriptor *desc);
+void fw_core_remove_descriptor(struct fw_descriptor *desc);
+
+
+/* -cdev */
+
+extern const struct file_operations fw_device_ops;
+
+void fw_device_cdev_update(struct fw_device *device);
+void fw_device_cdev_remove(struct fw_device *device);
+
+
+/* -device */
+
+extern struct rw_semaphore fw_device_rwsem;
+extern struct idr fw_device_idr;
+extern int fw_cdev_major;
+
+struct fw_device *fw_device_get_by_devt(dev_t devt);
+void fw_device_set_broadcast_channel(struct fw_device *device, int generation);
+void fw_node_event(struct fw_card *card, struct fw_node *node, int event);
+
+
+/* -iso */
+
+/*
+ * The iso packet format allows for an immediate header/payload part
+ * stored in 'header' immediately after the packet info plus an
+ * indirect payload part that is pointer to by the 'payload' field.
+ * Applications can use one or the other or both to implement simple
+ * low-bandwidth streaming (e.g. audio) or more advanced
+ * scatter-gather streaming (e.g. assembling video frame automatically).
+ */
+struct fw_iso_packet {
+	u16 payload_length;	/* Length of indirect payload. */
+	u32 interrupt:1;	/* Generate interrupt on this packet */
+	u32 skip:1;		/* Set to not send packet at all. */
+	u32 tag:2;
+	u32 sy:4;
+	u32 header_length:8;	/* Length of immediate header. */
+	u32 header[0];
+};
+
+#define FW_ISO_CONTEXT_TRANSMIT	0
+#define FW_ISO_CONTEXT_RECEIVE	1
+
+#define FW_ISO_CONTEXT_MATCH_TAG0	 1
+#define FW_ISO_CONTEXT_MATCH_TAG1	 2
+#define FW_ISO_CONTEXT_MATCH_TAG2	 4
+#define FW_ISO_CONTEXT_MATCH_TAG3	 8
+#define FW_ISO_CONTEXT_MATCH_ALL_TAGS	15
+
+/*
+ * An iso buffer is just a set of pages mapped for DMA in the
+ * specified direction.  Since the pages are to be used for DMA, they
+ * are not mapped into the kernel virtual address space.  We store the
+ * DMA address in the page private. The helper function
+ * fw_iso_buffer_map() will map the pages into a given vma.
+ */
+struct fw_iso_buffer {
+	enum dma_data_direction direction;
+	struct page **pages;
+	int page_count;
+};
+
+typedef void (*fw_iso_callback_t)(struct fw_iso_context *context,
+				  u32 cycle, size_t header_length,
+				  void *header, void *data);
+
+struct fw_iso_context {
+	struct fw_card *card;
+	int type;
+	int channel;
+	int speed;
+	size_t header_size;
+	fw_iso_callback_t callback;
+	void *callback_data;
+};
+
+int fw_iso_buffer_init(struct fw_iso_buffer *buffer, struct fw_card *card,
+		       int page_count, enum dma_data_direction direction);
+int fw_iso_buffer_map(struct fw_iso_buffer *buffer, struct vm_area_struct *vma);
+void fw_iso_buffer_destroy(struct fw_iso_buffer *buffer, struct fw_card *card);
+
+struct fw_iso_context *fw_iso_context_create(struct fw_card *card,
+		int type, int channel, int speed, size_t header_size,
+		fw_iso_callback_t callback, void *callback_data);
+int fw_iso_context_queue(struct fw_iso_context *ctx,
+			 struct fw_iso_packet *packet,
+			 struct fw_iso_buffer *buffer,
+			 unsigned long payload);
+int fw_iso_context_start(struct fw_iso_context *ctx,
+			 int cycle, int sync, int tags);
+int fw_iso_context_stop(struct fw_iso_context *ctx);
+void fw_iso_context_destroy(struct fw_iso_context *ctx);
+
+void fw_iso_resource_manage(struct fw_card *card, int generation,
+		u64 channels_mask, int *channel, int *bandwidth, bool allocate);
+
+
+/* -topology */
+
+enum {
+	FW_NODE_CREATED,
+	FW_NODE_UPDATED,
+	FW_NODE_DESTROYED,
+	FW_NODE_LINK_ON,
+	FW_NODE_LINK_OFF,
+	FW_NODE_INITIATED_RESET,
+};
+
+struct fw_node {
+	u16 node_id;
+	u8 color;
+	u8 port_count;
+	u8 link_on:1;
+	u8 initiated_reset:1;
+	u8 b_path:1;
+	u8 phy_speed:2;	/* As in the self ID packet. */
+	u8 max_speed:2;	/* Minimum of all phy-speeds on the path from the
+			 * local node to this node. */
+	u8 max_depth:4;	/* Maximum depth to any leaf node */
+	u8 max_hops:4;	/* Max hops in this sub tree */
+	atomic_t ref_count;
+
+	/* For serializing node topology into a list. */
+	struct list_head link;
+
+	/* Upper layer specific data. */
+	void *data;
+
+	struct fw_node *ports[0];
+};
+
+static inline struct fw_node *fw_node_get(struct fw_node *node)
+{
+	atomic_inc(&node->ref_count);
+
+	return node;
+}
+
+static inline void fw_node_put(struct fw_node *node)
+{
+	if (atomic_dec_and_test(&node->ref_count))
+		kfree(node);
+}
+
+void fw_core_handle_bus_reset(struct fw_card *card, int node_id,
+			      int generation, int self_id_count, u32 *self_ids);
+void fw_destroy_nodes(struct fw_card *card);
+
+/*
+ * Check whether new_generation is the immediate successor of old_generation.
+ * Take counter roll-over at 255 (as per OHCI) into account.
+ */
+static inline bool is_next_generation(int new_generation, int old_generation)
+{
+	return (new_generation & 0xff) == ((old_generation + 1) & 0xff);
+}
+
+
+/* -transaction */
+
+#define TCODE_IS_READ_REQUEST(tcode)	(((tcode) & ~1) == 4)
+#define TCODE_IS_BLOCK_PACKET(tcode)	(((tcode) &  1) != 0)
+#define TCODE_IS_REQUEST(tcode)		(((tcode) &  2) == 0)
+#define TCODE_IS_RESPONSE(tcode)	(((tcode) &  2) != 0)
+#define TCODE_HAS_REQUEST_DATA(tcode)	(((tcode) & 12) != 4)
+#define TCODE_HAS_RESPONSE_DATA(tcode)	(((tcode) & 12) != 0)
+
+#define LOCAL_BUS 0xffc0
+
+void fw_core_handle_request(struct fw_card *card, struct fw_packet *request);
+void fw_core_handle_response(struct fw_card *card, struct fw_packet *packet);
+void fw_fill_response(struct fw_packet *response, u32 *request_header,
+		      int rcode, void *payload, size_t length);
+void fw_flush_transactions(struct fw_card *card);
+void fw_send_phy_config(struct fw_card *card,
+			int node_id, int generation, int gap_count);
+
+static inline int fw_stream_packet_destination_id(int tag, int channel, int sy)
+{
+	return tag << 14 | channel << 8 | sy;
+}
+
+#endif /* _FIREWIRE_CORE_H */
