commit d0173278935a9c7ea268cc8baa8b669ecb57c0e3
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Thu Jun 20 09:28:46 2019 -0700

    watchdog: convert remaining drivers to use SPDX license identifier
    
    This gets rid of the unnecessary license boilerplate, and avoids
    having to deal with individual patches one by one.
    
    No functional changes.
    
    Reviewed-by: Jerry Hoemann <jerry.hoemann@hpe.com>
    Acked-by: Sylvain Lemieux <slemieux.tyco@gmail.com>
    Reviewed-by: Matthias Brugger <matthias.bgg@gmail.com>
    Acked-by: William Breathitt Gray <vilhelm.gray@gmail.com>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@linux-watchdog.org>

diff --git a/drivers/watchdog/ebc-c384_wdt.c b/drivers/watchdog/ebc-c384_wdt.c
index c176f59fea28..8ef4b0df3855 100644
--- a/drivers/watchdog/ebc-c384_wdt.c
+++ b/drivers/watchdog/ebc-c384_wdt.c
@@ -2,15 +2,6 @@
 /*
  * Watchdog timer driver for the WinSystems EBC-C384
  * Copyright (C) 2016 William Breathitt Gray
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License, version 2, as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
  */
 #include <linux/device.h>
 #include <linux/dmi.h>

commit cccbf8baa1097b3ff9c1cecfcd5060739c8880e1
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Fri Apr 19 20:15:50 2019 +0200

    watchdog: ebc-c384_wdt: drop warning after calling watchdog_init_timeout
    
    The core will print out details now.
    
    Reviewed-by: Guenter Roeck <linux@roeck-us.net>
    Acked-by: William Breathitt Gray <vilhelm.gray@gmail.com>
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@linux-watchdog.org>

diff --git a/drivers/watchdog/ebc-c384_wdt.c b/drivers/watchdog/ebc-c384_wdt.c
index 4c4c8ce78021..c176f59fea28 100644
--- a/drivers/watchdog/ebc-c384_wdt.c
+++ b/drivers/watchdog/ebc-c384_wdt.c
@@ -117,10 +117,7 @@ static int ebc_c384_wdt_probe(struct device *dev, unsigned int id)
 	wdd->max_timeout = WATCHDOG_MAX_TIMEOUT;
 
 	watchdog_set_nowayout(wdd, nowayout);
-
-	if (watchdog_init_timeout(wdd, timeout, dev))
-		dev_warn(dev, "Invalid timeout (%u seconds), using default (%u seconds)\n",
-			timeout, WATCHDOG_TIMEOUT);
+	watchdog_init_timeout(wdd, timeout, dev);
 
 	return devm_watchdog_register_device(dev, wdd);
 }

commit 2e62c4988bbf2b514aa7672c2ee5252531c7155f
Author: Marcus Folkesson <marcus.folkesson@gmail.com>
Date:   Fri Mar 16 16:14:11 2018 +0100

    watchdog: add SPDX identifiers for watchdog subsystem
    
    - Add SPDX identifier
    - Remove boiler plate license text
    - If MODULE_LICENSE and boiler plate does not match, go for boiler plate
      license
    
    Signed-off-by: Marcus Folkesson <marcus.folkesson@gmail.com>
    Acked-by: Adam Thomson <Adam.Thomson.Opensource@diasemi.com>
    Acked-by: Baruch Siach <baruch@tkos.co.il>
    Acked-by: Charles Keepax <ckeepax@opensource.cirrus.com>
    Acked-by: Keiji Hayashibara <hayashibara.keiji@socionext.com>
    Acked-by: Johannes Thumshirn <jth@kernel.org>
    Acked-by: Florian Fainelli <f.fainelli@gmail.com>
    Acked-by: Mans Rullgard <mans@mansr.com>
    Acked-by: Matthias Brugger <matthias.bgg@gmail.com>
    Acked-by: Michal Simek <michal.simek@xilinx.com>
    Acked-by: Neil Armstrong <narmstrong@baylibre.com>
    Acked-by: Nicolas Ferre <nicolas.ferre@microchip.com>
    Acked-by: Thierry Reding <treding@nvidia.com>
    Acked-by: Tomas Winkler <tomas.winkler@intel.com>
    Acked-by: Patrice Chotard <patrice.chotard@st.com>
    Acked-by: William Breathitt Gray <vilhelm.gray@gmail.com>
    Reviewed-by: Eric Anholt <eric@anholt.net>
    Reviewed-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/drivers/watchdog/ebc-c384_wdt.c b/drivers/watchdog/ebc-c384_wdt.c
index 2170b275ea01..4c4c8ce78021 100644
--- a/drivers/watchdog/ebc-c384_wdt.c
+++ b/drivers/watchdog/ebc-c384_wdt.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Watchdog timer driver for the WinSystems EBC-C384
  * Copyright (C) 2016 William Breathitt Gray

commit 540aea3dbffc6a75d0b3b77db1cde36a065a6ab5
Author: William Breathitt Gray <vilhelm.gray@gmail.com>
Date:   Tue Jan 24 17:02:33 2017 -0500

    watchdog: ebc-c384_wdt: Utilize devm_ functions in driver probe callback
    
    The devm_ resource manager functions allow memory to be automatically
    released when a device is unbound. This patch takes advantage of the
    resource manager functions and replaces the watchdog_register_device
    call with the devm_watchdog_register_device call. In addition, the
    ebc_c384_wdt_remove function has been removed as no longer necessary due
    to the use of the relevant devm_ resource manager functions.
    
    Signed-off-by: William Breathitt Gray <vilhelm.gray@gmail.com>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>

diff --git a/drivers/watchdog/ebc-c384_wdt.c b/drivers/watchdog/ebc-c384_wdt.c
index 4b849b8e37c2..2170b275ea01 100644
--- a/drivers/watchdog/ebc-c384_wdt.c
+++ b/drivers/watchdog/ebc-c384_wdt.c
@@ -121,18 +121,7 @@ static int ebc_c384_wdt_probe(struct device *dev, unsigned int id)
 		dev_warn(dev, "Invalid timeout (%u seconds), using default (%u seconds)\n",
 			timeout, WATCHDOG_TIMEOUT);
 
-	dev_set_drvdata(dev, wdd);
-
-	return watchdog_register_device(wdd);
-}
-
-static int ebc_c384_wdt_remove(struct device *dev, unsigned int id)
-{
-	struct watchdog_device *wdd = dev_get_drvdata(dev);
-
-	watchdog_unregister_device(wdd);
-
-	return 0;
+	return devm_watchdog_register_device(dev, wdd);
 }
 
 static struct isa_driver ebc_c384_wdt_driver = {
@@ -140,7 +129,6 @@ static struct isa_driver ebc_c384_wdt_driver = {
 	.driver = {
 		.name = MODULE_NAME
 	},
-	.remove = ebc_c384_wdt_remove
 };
 
 static int __init ebc_c384_wdt_init(void)

commit 4ef1bec4e4f393aa96d2b5345bb08baabaec8ee1
Author: William Breathitt Gray <vilhelm.gray@gmail.com>
Date:   Sun May 1 18:44:26 2016 -0400

    watchdog: ebc-c384_wdt: Utilize the ISA bus driver
    
    The WinSystems EBC-C384 watchdog timer is controlled via ISA bus
    communication. As such, the ISA bus driver is more appropriate than the
    platform driver for the WinSystems EBC-C384 watchdog timer driver.
    
    Cc: Wim Van Sebroeck <wim@iguana.be>
    Acked-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: William Breathitt Gray <vilhelm.gray@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/watchdog/ebc-c384_wdt.c b/drivers/watchdog/ebc-c384_wdt.c
index 77fda0b4b90e..4b849b8e37c2 100644
--- a/drivers/watchdog/ebc-c384_wdt.c
+++ b/drivers/watchdog/ebc-c384_wdt.c
@@ -16,10 +16,10 @@
 #include <linux/errno.h>
 #include <linux/io.h>
 #include <linux/ioport.h>
+#include <linux/isa.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/moduleparam.h>
-#include <linux/platform_device.h>
 #include <linux/types.h>
 #include <linux/watchdog.h>
 
@@ -95,9 +95,8 @@ static const struct watchdog_info ebc_c384_wdt_info = {
 	.identity = MODULE_NAME
 };
 
-static int __init ebc_c384_wdt_probe(struct platform_device *pdev)
+static int ebc_c384_wdt_probe(struct device *dev, unsigned int id)
 {
-	struct device *dev = &pdev->dev;
 	struct watchdog_device *wdd;
 
 	if (!devm_request_region(dev, BASE_ADDR, ADDR_EXTENT, dev_name(dev))) {
@@ -122,61 +121,39 @@ static int __init ebc_c384_wdt_probe(struct platform_device *pdev)
 		dev_warn(dev, "Invalid timeout (%u seconds), using default (%u seconds)\n",
 			timeout, WATCHDOG_TIMEOUT);
 
-	platform_set_drvdata(pdev, wdd);
+	dev_set_drvdata(dev, wdd);
 
 	return watchdog_register_device(wdd);
 }
 
-static int ebc_c384_wdt_remove(struct platform_device *pdev)
+static int ebc_c384_wdt_remove(struct device *dev, unsigned int id)
 {
-	struct watchdog_device *wdd = platform_get_drvdata(pdev);
+	struct watchdog_device *wdd = dev_get_drvdata(dev);
 
 	watchdog_unregister_device(wdd);
 
 	return 0;
 }
 
-static struct platform_driver ebc_c384_wdt_driver = {
+static struct isa_driver ebc_c384_wdt_driver = {
+	.probe = ebc_c384_wdt_probe,
 	.driver = {
 		.name = MODULE_NAME
 	},
 	.remove = ebc_c384_wdt_remove
 };
 
-static struct platform_device *ebc_c384_wdt_device;
-
 static int __init ebc_c384_wdt_init(void)
 {
-	int err;
-
 	if (!dmi_match(DMI_BOARD_NAME, "EBC-C384 SBC"))
 		return -ENODEV;
 
-	ebc_c384_wdt_device = platform_device_alloc(MODULE_NAME, -1);
-	if (!ebc_c384_wdt_device)
-		return -ENOMEM;
-
-	err = platform_device_add(ebc_c384_wdt_device);
-	if (err)
-		goto err_platform_device;
-
-	err = platform_driver_probe(&ebc_c384_wdt_driver, ebc_c384_wdt_probe);
-	if (err)
-		goto err_platform_driver;
-
-	return 0;
-
-err_platform_driver:
-	platform_device_del(ebc_c384_wdt_device);
-err_platform_device:
-	platform_device_put(ebc_c384_wdt_device);
-	return err;
+	return isa_register_driver(&ebc_c384_wdt_driver, 1);
 }
 
 static void __exit ebc_c384_wdt_exit(void)
 {
-	platform_device_unregister(ebc_c384_wdt_device);
-	platform_driver_unregister(&ebc_c384_wdt_driver);
+	isa_unregister_driver(&ebc_c384_wdt_driver);
 }
 
 module_init(ebc_c384_wdt_init);
@@ -185,4 +162,4 @@ module_exit(ebc_c384_wdt_exit);
 MODULE_AUTHOR("William Breathitt Gray <vilhelm.gray@gmail.com>");
 MODULE_DESCRIPTION("WinSystems EBC-C384 watchdog timer driver");
 MODULE_LICENSE("GPL v2");
-MODULE_ALIAS("platform:" MODULE_NAME);
+MODULE_ALIAS("isa:" MODULE_NAME);

commit c36a483d80072f7efdd09e94dd733120dc8ecfb2
Author: William Breathitt Gray <vilhelm.gray@gmail.com>
Date:   Sun Feb 28 23:54:46 2016 -0500

    watchdog: Add watchdog timer support for the WinSystems EBC-C384
    
    The WinSystems EBC-C384 has an onboard watchdog timer. The timeout range
    supported by the watchdog timer is 1 second to 255 minutes. Timeouts
    under 256 seconds have a 1 second granularity, while the rest have a 1
    minute granularity.
    
    This driver adds watchdog timer support for this onboard watchdog timer.
    The timeout may be configured via the timeout module parameter.
    
    Signed-off-by: William Breathitt Gray <vilhelm.gray@gmail.com>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/drivers/watchdog/ebc-c384_wdt.c b/drivers/watchdog/ebc-c384_wdt.c
new file mode 100644
index 000000000000..77fda0b4b90e
--- /dev/null
+++ b/drivers/watchdog/ebc-c384_wdt.c
@@ -0,0 +1,188 @@
+/*
+ * Watchdog timer driver for the WinSystems EBC-C384
+ * Copyright (C) 2016 William Breathitt Gray
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License, version 2, as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ */
+#include <linux/device.h>
+#include <linux/dmi.h>
+#include <linux/errno.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/platform_device.h>
+#include <linux/types.h>
+#include <linux/watchdog.h>
+
+#define MODULE_NAME		"ebc-c384_wdt"
+#define WATCHDOG_TIMEOUT	60
+/*
+ * The timeout value in minutes must fit in a single byte when sent to the
+ * watchdog timer; the maximum timeout possible is 15300 (255 * 60) seconds.
+ */
+#define WATCHDOG_MAX_TIMEOUT	15300
+#define BASE_ADDR		0x564
+#define ADDR_EXTENT		5
+#define CFG_ADDR		(BASE_ADDR + 1)
+#define PET_ADDR		(BASE_ADDR + 2)
+
+static bool nowayout = WATCHDOG_NOWAYOUT;
+module_param(nowayout, bool, 0);
+MODULE_PARM_DESC(nowayout, "Watchdog cannot be stopped once started (default="
+	__MODULE_STRING(WATCHDOG_NOWAYOUT) ")");
+
+static unsigned timeout;
+module_param(timeout, uint, 0);
+MODULE_PARM_DESC(timeout, "Watchdog timeout in seconds (default="
+	__MODULE_STRING(WATCHDOG_TIMEOUT) ")");
+
+static int ebc_c384_wdt_start(struct watchdog_device *wdev)
+{
+	unsigned t = wdev->timeout;
+
+	/* resolution is in minutes for timeouts greater than 255 seconds */
+	if (t > 255)
+		t = DIV_ROUND_UP(t, 60);
+
+	outb(t, PET_ADDR);
+
+	return 0;
+}
+
+static int ebc_c384_wdt_stop(struct watchdog_device *wdev)
+{
+	outb(0x00, PET_ADDR);
+
+	return 0;
+}
+
+static int ebc_c384_wdt_set_timeout(struct watchdog_device *wdev, unsigned t)
+{
+	/* resolution is in minutes for timeouts greater than 255 seconds */
+	if (t > 255) {
+		/* round second resolution up to minute granularity */
+		wdev->timeout = roundup(t, 60);
+
+		/* set watchdog timer for minutes */
+		outb(0x00, CFG_ADDR);
+	} else {
+		wdev->timeout = t;
+
+		/* set watchdog timer for seconds */
+		outb(0x80, CFG_ADDR);
+	}
+
+	return 0;
+}
+
+static const struct watchdog_ops ebc_c384_wdt_ops = {
+	.start = ebc_c384_wdt_start,
+	.stop = ebc_c384_wdt_stop,
+	.set_timeout = ebc_c384_wdt_set_timeout
+};
+
+static const struct watchdog_info ebc_c384_wdt_info = {
+	.options = WDIOF_KEEPALIVEPING | WDIOF_MAGICCLOSE | WDIOF_SETTIMEOUT,
+	.identity = MODULE_NAME
+};
+
+static int __init ebc_c384_wdt_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct watchdog_device *wdd;
+
+	if (!devm_request_region(dev, BASE_ADDR, ADDR_EXTENT, dev_name(dev))) {
+		dev_err(dev, "Unable to lock port addresses (0x%X-0x%X)\n",
+			BASE_ADDR, BASE_ADDR + ADDR_EXTENT);
+		return -EBUSY;
+	}
+
+	wdd = devm_kzalloc(dev, sizeof(*wdd), GFP_KERNEL);
+	if (!wdd)
+		return -ENOMEM;
+
+	wdd->info = &ebc_c384_wdt_info;
+	wdd->ops = &ebc_c384_wdt_ops;
+	wdd->timeout = WATCHDOG_TIMEOUT;
+	wdd->min_timeout = 1;
+	wdd->max_timeout = WATCHDOG_MAX_TIMEOUT;
+
+	watchdog_set_nowayout(wdd, nowayout);
+
+	if (watchdog_init_timeout(wdd, timeout, dev))
+		dev_warn(dev, "Invalid timeout (%u seconds), using default (%u seconds)\n",
+			timeout, WATCHDOG_TIMEOUT);
+
+	platform_set_drvdata(pdev, wdd);
+
+	return watchdog_register_device(wdd);
+}
+
+static int ebc_c384_wdt_remove(struct platform_device *pdev)
+{
+	struct watchdog_device *wdd = platform_get_drvdata(pdev);
+
+	watchdog_unregister_device(wdd);
+
+	return 0;
+}
+
+static struct platform_driver ebc_c384_wdt_driver = {
+	.driver = {
+		.name = MODULE_NAME
+	},
+	.remove = ebc_c384_wdt_remove
+};
+
+static struct platform_device *ebc_c384_wdt_device;
+
+static int __init ebc_c384_wdt_init(void)
+{
+	int err;
+
+	if (!dmi_match(DMI_BOARD_NAME, "EBC-C384 SBC"))
+		return -ENODEV;
+
+	ebc_c384_wdt_device = platform_device_alloc(MODULE_NAME, -1);
+	if (!ebc_c384_wdt_device)
+		return -ENOMEM;
+
+	err = platform_device_add(ebc_c384_wdt_device);
+	if (err)
+		goto err_platform_device;
+
+	err = platform_driver_probe(&ebc_c384_wdt_driver, ebc_c384_wdt_probe);
+	if (err)
+		goto err_platform_driver;
+
+	return 0;
+
+err_platform_driver:
+	platform_device_del(ebc_c384_wdt_device);
+err_platform_device:
+	platform_device_put(ebc_c384_wdt_device);
+	return err;
+}
+
+static void __exit ebc_c384_wdt_exit(void)
+{
+	platform_device_unregister(ebc_c384_wdt_device);
+	platform_driver_unregister(&ebc_c384_wdt_driver);
+}
+
+module_init(ebc_c384_wdt_init);
+module_exit(ebc_c384_wdt_exit);
+
+MODULE_AUTHOR("William Breathitt Gray <vilhelm.gray@gmail.com>");
+MODULE_DESCRIPTION("WinSystems EBC-C384 watchdog timer driver");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:" MODULE_NAME);
