commit 0b468829c325026e0f2cec7f4e1b3ea2949f6d0d
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Tue Apr 23 11:48:31 2019 -0400

    watchdog: rtd119x: drop unused module.h include
    
    The Kconfig for this driver is:
    
    config RTD119X_WATCHDOG
           bool "Realtek RTD118x/RTD129x watchdog support"
    
    ...and hence it doesn't need to include module.h for anything.
    There are no other signs of unused modular infrastructure.
    
    Cc: Wim Van Sebroeck <wim@linux-watchdog.org>
    Cc: Guenter Roeck <linux@roeck-us.net>
    Cc: linux-watchdog@vger.kernel.org
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Reviewed-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@linux-watchdog.org>

diff --git a/drivers/watchdog/rtd119x_wdt.c b/drivers/watchdog/rtd119x_wdt.c
index c4cb23d65218..834b94ff3f90 100644
--- a/drivers/watchdog/rtd119x_wdt.c
+++ b/drivers/watchdog/rtd119x_wdt.c
@@ -9,7 +9,6 @@
 #include <linux/bitops.h>
 #include <linux/clk.h>
 #include <linux/io.h>
-#include <linux/module.h>
 #include <linux/of.h>
 #include <linux/of_address.h>
 #include <linux/platform_device.h>

commit 553140a016d03d96a01cddce035ac49be14da7cf
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Tue Apr 9 10:23:52 2019 -0700

    watchdog: rtd119x_wdt: Convert to use device managed functions and other improvements
    
    Use device managed functions to simplify error handling, reduce
    source code size, improve readability, and reduce the likelyhood of bugs.
    Other improvements as listed below.
    
    The conversion was done automatically with coccinelle using the
    following semantic patches. The semantic patches and the scripts
    used to generate this commit log are available at
    https://github.com/groeck/coccinelle-patches
    
    - Drop assignments to otherwise unused variables
    - Drop unnecessary braces around conditional return statements
    - Drop empty remove function
    - Use devm_add_action_or_reset() for calls to clk_disable_unprepare
    - Replace 'of_clk_get(np, 0)' with 'devm_clk_get(dev, NULL)'
    - Introduce local variable 'struct device *dev' and use it instead of
      dereferencing it repeatedly
    - Use devm_watchdog_register_driver() to register watchdog device
    
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@linux-watchdog.org>

diff --git a/drivers/watchdog/rtd119x_wdt.c b/drivers/watchdog/rtd119x_wdt.c
index cb17c49f3534..c4cb23d65218 100644
--- a/drivers/watchdog/rtd119x_wdt.c
+++ b/drivers/watchdog/rtd119x_wdt.c
@@ -95,12 +95,18 @@ static const struct of_device_id rtd119x_wdt_dt_ids[] = {
 	 { }
 };
 
+static void rtd119x_clk_disable_unprepare(void *data)
+{
+	clk_disable_unprepare(data);
+}
+
 static int rtd119x_wdt_probe(struct platform_device *pdev)
 {
+	struct device *dev = &pdev->dev;
 	struct rtd119x_watchdog_device *data;
 	int ret;
 
-	data = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);
+	data = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);
 	if (!data)
 		return -ENOMEM;
 
@@ -108,22 +114,24 @@ static int rtd119x_wdt_probe(struct platform_device *pdev)
 	if (IS_ERR(data->base))
 		return PTR_ERR(data->base);
 
-	data->clk = of_clk_get(pdev->dev.of_node, 0);
+	data->clk = devm_clk_get(dev, NULL);
 	if (IS_ERR(data->clk))
 		return PTR_ERR(data->clk);
 
 	ret = clk_prepare_enable(data->clk);
-	if (ret) {
-		clk_put(data->clk);
+	if (ret)
+		return ret;
+	ret = devm_add_action_or_reset(dev, rtd119x_clk_disable_unprepare,
+				       data->clk);
+	if (ret)
 		return ret;
-	}
 
 	data->wdt_dev.info = &rtd119x_wdt_info;
 	data->wdt_dev.ops = &rtd119x_wdt_ops;
 	data->wdt_dev.timeout = 120;
 	data->wdt_dev.max_timeout = 0xffffffff / clk_get_rate(data->clk);
 	data->wdt_dev.min_timeout = 1;
-	data->wdt_dev.parent = &pdev->dev;
+	data->wdt_dev.parent = dev;
 
 	watchdog_stop_on_reboot(&data->wdt_dev);
 	watchdog_set_drvdata(&data->wdt_dev, data);
@@ -133,31 +141,11 @@ static int rtd119x_wdt_probe(struct platform_device *pdev)
 	rtd119x_wdt_set_timeout(&data->wdt_dev, data->wdt_dev.timeout);
 	rtd119x_wdt_stop(&data->wdt_dev);
 
-	ret = watchdog_register_device(&data->wdt_dev);
-	if (ret) {
-		clk_disable_unprepare(data->clk);
-		clk_put(data->clk);
-		return ret;
-	}
-
-	return 0;
-}
-
-static int rtd119x_wdt_remove(struct platform_device *pdev)
-{
-	struct rtd119x_watchdog_device *data = platform_get_drvdata(pdev);
-
-	watchdog_unregister_device(&data->wdt_dev);
-
-	clk_disable_unprepare(data->clk);
-	clk_put(data->clk);
-
-	return 0;
+	return devm_watchdog_register_device(dev, &data->wdt_dev);
 }
 
 static struct platform_driver rtd119x_wdt_driver = {
 	.probe = rtd119x_wdt_probe,
-	.remove = rtd119x_wdt_remove,
 	.driver = {
 		.name = "rtd1295-watchdog",
 		.of_match_table	= rtd119x_wdt_dt_ids,

commit 8dd29f19512cc75ee470d7bb8ec86af199de23a8
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Sun Apr 7 08:29:35 2019 -0700

    watchdog: rtd119x_wdt: Fix remove function
    
    The driver registers the watchdog with devm_watchdog_register_device() but
    still calls watchdog_unregister_device() on remove. Since clocks have to
    be stopped when removing the driver, after the watchdog device has been
    unregistered, we can not drop the call to watchdog_unregister_device().
    Use watchdog_register_device() to register the watchdog.
    
    Fixes: 2bdf6acbfead7 ("watchdog: Add Realtek RTD1295")
    Cc: Andreas FÃ¤rber <afaerber@suse.de>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@linux-watchdog.org>

diff --git a/drivers/watchdog/rtd119x_wdt.c b/drivers/watchdog/rtd119x_wdt.c
index d823c9def36f..cb17c49f3534 100644
--- a/drivers/watchdog/rtd119x_wdt.c
+++ b/drivers/watchdog/rtd119x_wdt.c
@@ -133,7 +133,7 @@ static int rtd119x_wdt_probe(struct platform_device *pdev)
 	rtd119x_wdt_set_timeout(&data->wdt_dev, data->wdt_dev.timeout);
 	rtd119x_wdt_stop(&data->wdt_dev);
 
-	ret = devm_watchdog_register_device(&pdev->dev, &data->wdt_dev);
+	ret = watchdog_register_device(&data->wdt_dev);
 	if (ret) {
 		clk_disable_unprepare(data->clk);
 		clk_put(data->clk);

commit 0f0a6a285ec0c7b0ac0b532f87a784605322f9ce
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Tue Apr 2 12:01:53 2019 -0700

    watchdog: Convert to use devm_platform_ioremap_resource
    
    Use devm_platform_ioremap_resource to reduce source code size,
    improve readability, and reduce the likelyhood of bugs.
    
    The conversion was done automatically with coccinelle using the
    following semantic patch.
    
    @r@
    identifier res, pdev;
    expression a;
    expression index;
    expression e;
    @@
    
    <+...
    - res = platform_get_resource(pdev, IORESOURCE_MEM, index);
    - a = devm_ioremap_resource(e, res);
    + a = devm_platform_ioremap_resource(pdev, index);
    ...+>
    
    @depends on r@
    identifier r.res;
    @@
    - struct resource *res;
      ... when != res
    
    @@
    identifier res, pdev;
    expression index;
    expression a;
    @@
    - struct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, index);
    - a = devm_ioremap_resource(&pdev->dev, res);
    + a = devm_platform_ioremap_resource(pdev, index);
    
    Cc: Joel Stanley <joel@jms.id.au>
    Cc: Nicolas Ferre <nicolas.ferre@microchip.com>
    Cc: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Cc: Florian Fainelli <f.fainelli@gmail.com>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Baruch Siach <baruch@tkos.co.il>
    Cc: Keguang Zhang <keguang.zhang@gmail.com>
    Cc: Vladimir Zapolskiy <vz@mleia.com>
    Cc: Kevin Hilman <khilman@baylibre.com>
    Cc: Matthias Brugger <matthias.bgg@gmail.com>
    Cc: Avi Fishman <avifishman70@gmail.com>
    Cc: Nancy Yuen <yuenn@google.com>
    Cc: Brendan Higgins <brendanhiggins@google.com>
    Cc: Wan ZongShun <mcuos.com@gmail.com>
    Cc: Michal Simek <michal.simek@xilinx.com>
    Cc: Sylvain Lemieux <slemieux.tyco@gmail.com>
    Cc: Kukjin Kim <kgene@kernel.org>
    Cc: Barry Song <baohua@kernel.org>
    Cc: Orson Zhai <orsonzhai@gmail.com>
    Cc: Patrice Chotard <patrice.chotard@st.com>
    Cc: Maxime Coquelin <mcoquelin.stm32@gmail.com>
    Cc: Maxime Ripard <maxime.ripard@bootlin.com>
    Cc: Chen-Yu Tsai <wens@csie.org>
    Cc: Marc Gonzalez <marc.w.gonzalez@free.fr>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Cc: Shawn Guo <shawnguo@kernel.org>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Acked-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Tested-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Acked-by: Joel Stanley <joel@jms.id.au>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Maxime Ripard <maxime.ripard@bootlin.com>
    Acked-by: Michal Simek <michal.simek@xilinx.com> (cadence/xilinx wdts)
    Acked-by: Thierry Reding <treding@nvidia.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Acked-by: Patrice Chotard <patrice.chotard@st.com>
    Acked-by: Vladimir Zapolskiy <vz@mleia.com>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@linux-watchdog.org>

diff --git a/drivers/watchdog/rtd119x_wdt.c b/drivers/watchdog/rtd119x_wdt.c
index d001c17ddfde..d823c9def36f 100644
--- a/drivers/watchdog/rtd119x_wdt.c
+++ b/drivers/watchdog/rtd119x_wdt.c
@@ -98,15 +98,13 @@ static const struct of_device_id rtd119x_wdt_dt_ids[] = {
 static int rtd119x_wdt_probe(struct platform_device *pdev)
 {
 	struct rtd119x_watchdog_device *data;
-	struct resource *res;
 	int ret;
 
 	data = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);
 	if (!data)
 		return -ENOMEM;
 
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	data->base = devm_ioremap_resource(&pdev->dev, res);
+	data->base = devm_platform_ioremap_resource(pdev, 0);
 	if (IS_ERR(data->base))
 		return PTR_ERR(data->base);
 

commit 2bdf6acbfead7e9aa69f36ee5682d1e5c8f70367
Author: Andreas FÃ¤rber <afaerber@suse.de>
Date:   Tue Sep 5 01:16:01 2017 +0200

    watchdog: Add Realtek RTD1295
    
    Add a watchdog driver for the Realtek RTD1295 SoC.
    
    Based on QNAP's arch/arm/mach-rtk119x/driver/rtk_watchdog.c code and
    mach-rtk119x/driver/dc2vo/fpga/include/iso_reg.h register defines.
    
    Signed-off-by: Andreas FÃ¤rber <afaerber@suse.de>
    Reviewed-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/drivers/watchdog/rtd119x_wdt.c b/drivers/watchdog/rtd119x_wdt.c
new file mode 100644
index 000000000000..d001c17ddfde
--- /dev/null
+++ b/drivers/watchdog/rtd119x_wdt.c
@@ -0,0 +1,168 @@
+/*
+ * Realtek RTD129x watchdog
+ *
+ * Copyright (c) 2017 Andreas FÃ¤rber
+ *
+ * SPDX-License-Identifier: GPL-2.0+
+ */
+
+#include <linux/bitops.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+#include <linux/watchdog.h>
+
+#define RTD119X_TCWCR		0x0
+#define RTD119X_TCWTR		0x4
+#define RTD119X_TCWOV		0xc
+
+#define RTD119X_TCWCR_WDEN_DISABLED		0xa5
+#define RTD119X_TCWCR_WDEN_ENABLED		0xff
+#define RTD119X_TCWCR_WDEN_MASK			0xff
+
+#define RTD119X_TCWTR_WDCLR			BIT(0)
+
+struct rtd119x_watchdog_device {
+	struct watchdog_device wdt_dev;
+	void __iomem *base;
+	struct clk *clk;
+};
+
+static int rtd119x_wdt_start(struct watchdog_device *wdev)
+{
+	struct rtd119x_watchdog_device *data = watchdog_get_drvdata(wdev);
+	u32 val;
+
+	val = readl_relaxed(data->base + RTD119X_TCWCR);
+	val &= ~RTD119X_TCWCR_WDEN_MASK;
+	val |= RTD119X_TCWCR_WDEN_ENABLED;
+	writel(val, data->base + RTD119X_TCWCR);
+
+	return 0;
+}
+
+static int rtd119x_wdt_stop(struct watchdog_device *wdev)
+{
+	struct rtd119x_watchdog_device *data = watchdog_get_drvdata(wdev);
+	u32 val;
+
+	val = readl_relaxed(data->base + RTD119X_TCWCR);
+	val &= ~RTD119X_TCWCR_WDEN_MASK;
+	val |= RTD119X_TCWCR_WDEN_DISABLED;
+	writel(val, data->base + RTD119X_TCWCR);
+
+	return 0;
+}
+
+static int rtd119x_wdt_ping(struct watchdog_device *wdev)
+{
+	struct rtd119x_watchdog_device *data = watchdog_get_drvdata(wdev);
+
+	writel_relaxed(RTD119X_TCWTR_WDCLR, data->base + RTD119X_TCWTR);
+
+	return rtd119x_wdt_start(wdev);
+}
+
+static int rtd119x_wdt_set_timeout(struct watchdog_device *wdev, unsigned int val)
+{
+	struct rtd119x_watchdog_device *data = watchdog_get_drvdata(wdev);
+
+	writel(val * clk_get_rate(data->clk), data->base + RTD119X_TCWOV);
+
+	data->wdt_dev.timeout = val;
+
+	return 0;
+}
+
+static const struct watchdog_ops rtd119x_wdt_ops = {
+	.owner = THIS_MODULE,
+	.start		= rtd119x_wdt_start,
+	.stop		= rtd119x_wdt_stop,
+	.ping		= rtd119x_wdt_ping,
+	.set_timeout	= rtd119x_wdt_set_timeout,
+};
+
+static const struct watchdog_info rtd119x_wdt_info = {
+	.identity = "rtd119x-wdt",
+	.options = 0,
+};
+
+static const struct of_device_id rtd119x_wdt_dt_ids[] = {
+	 { .compatible = "realtek,rtd1295-watchdog" },
+	 { }
+};
+
+static int rtd119x_wdt_probe(struct platform_device *pdev)
+{
+	struct rtd119x_watchdog_device *data;
+	struct resource *res;
+	int ret;
+
+	data = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	data->base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(data->base))
+		return PTR_ERR(data->base);
+
+	data->clk = of_clk_get(pdev->dev.of_node, 0);
+	if (IS_ERR(data->clk))
+		return PTR_ERR(data->clk);
+
+	ret = clk_prepare_enable(data->clk);
+	if (ret) {
+		clk_put(data->clk);
+		return ret;
+	}
+
+	data->wdt_dev.info = &rtd119x_wdt_info;
+	data->wdt_dev.ops = &rtd119x_wdt_ops;
+	data->wdt_dev.timeout = 120;
+	data->wdt_dev.max_timeout = 0xffffffff / clk_get_rate(data->clk);
+	data->wdt_dev.min_timeout = 1;
+	data->wdt_dev.parent = &pdev->dev;
+
+	watchdog_stop_on_reboot(&data->wdt_dev);
+	watchdog_set_drvdata(&data->wdt_dev, data);
+	platform_set_drvdata(pdev, data);
+
+	writel_relaxed(RTD119X_TCWTR_WDCLR, data->base + RTD119X_TCWTR);
+	rtd119x_wdt_set_timeout(&data->wdt_dev, data->wdt_dev.timeout);
+	rtd119x_wdt_stop(&data->wdt_dev);
+
+	ret = devm_watchdog_register_device(&pdev->dev, &data->wdt_dev);
+	if (ret) {
+		clk_disable_unprepare(data->clk);
+		clk_put(data->clk);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int rtd119x_wdt_remove(struct platform_device *pdev)
+{
+	struct rtd119x_watchdog_device *data = platform_get_drvdata(pdev);
+
+	watchdog_unregister_device(&data->wdt_dev);
+
+	clk_disable_unprepare(data->clk);
+	clk_put(data->clk);
+
+	return 0;
+}
+
+static struct platform_driver rtd119x_wdt_driver = {
+	.probe = rtd119x_wdt_probe,
+	.remove = rtd119x_wdt_remove,
+	.driver = {
+		.name = "rtd1295-watchdog",
+		.of_match_table	= rtd119x_wdt_dt_ids,
+	},
+};
+builtin_platform_driver(rtd119x_wdt_driver);
