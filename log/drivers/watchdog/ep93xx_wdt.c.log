commit d6ab05106a70c584318479ec766f6f82c63e0541
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Mon Apr 8 12:38:38 2019 -0700

    watchdog: ep93xx_wdt: Use 'dev' instead of dereferencing it repeatedly
    
    Introduce local variable 'struct device *dev' and use it instead of
    dereferencing it repeatedly.
    
    The conversion was done automatically with coccinelle using the
    following semantic patches. The semantic patches and the scripts
    used to generate this commit log are available at
    https://github.com/groeck/coccinelle-patches
    
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@linux-watchdog.org>

diff --git a/drivers/watchdog/ep93xx_wdt.c b/drivers/watchdog/ep93xx_wdt.c
index 1e721c2f9eac..38e26f160b9a 100644
--- a/drivers/watchdog/ep93xx_wdt.c
+++ b/drivers/watchdog/ep93xx_wdt.c
@@ -89,12 +89,13 @@ static const struct watchdog_ops ep93xx_wdt_ops = {
 
 static int ep93xx_wdt_probe(struct platform_device *pdev)
 {
+	struct device *dev = &pdev->dev;
 	struct ep93xx_wdt_priv *priv;
 	struct watchdog_device *wdd;
 	unsigned long val;
 	int ret;
 
-	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
 	if (!priv)
 		return -ENOMEM;
 
@@ -110,21 +111,21 @@ static int ep93xx_wdt_probe(struct platform_device *pdev)
 	wdd->ops = &ep93xx_wdt_ops;
 	wdd->min_timeout = 1;
 	wdd->max_hw_heartbeat_ms = 200;
-	wdd->parent = &pdev->dev;
+	wdd->parent = dev;
 
 	watchdog_set_nowayout(wdd, nowayout);
 
 	wdd->timeout = WDT_TIMEOUT;
-	watchdog_init_timeout(wdd, timeout, &pdev->dev);
+	watchdog_init_timeout(wdd, timeout, dev);
 
 	watchdog_set_drvdata(wdd, priv);
 
-	ret = devm_watchdog_register_device(&pdev->dev, wdd);
+	ret = devm_watchdog_register_device(dev, wdd);
 	if (ret)
 		return ret;
 
-	dev_info(&pdev->dev, "EP93XX watchdog driver %s\n",
-		(val & 0x08) ? " (nCS1 disable detected)" : "");
+	dev_info(dev, "EP93XX watchdog driver %s\n",
+		 (val & 0x08) ? " (nCS1 disable detected)" : "");
 
 	return 0;
 }

commit 0f0a6a285ec0c7b0ac0b532f87a784605322f9ce
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Tue Apr 2 12:01:53 2019 -0700

    watchdog: Convert to use devm_platform_ioremap_resource
    
    Use devm_platform_ioremap_resource to reduce source code size,
    improve readability, and reduce the likelyhood of bugs.
    
    The conversion was done automatically with coccinelle using the
    following semantic patch.
    
    @r@
    identifier res, pdev;
    expression a;
    expression index;
    expression e;
    @@
    
    <+...
    - res = platform_get_resource(pdev, IORESOURCE_MEM, index);
    - a = devm_ioremap_resource(e, res);
    + a = devm_platform_ioremap_resource(pdev, index);
    ...+>
    
    @depends on r@
    identifier r.res;
    @@
    - struct resource *res;
      ... when != res
    
    @@
    identifier res, pdev;
    expression index;
    expression a;
    @@
    - struct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, index);
    - a = devm_ioremap_resource(&pdev->dev, res);
    + a = devm_platform_ioremap_resource(pdev, index);
    
    Cc: Joel Stanley <joel@jms.id.au>
    Cc: Nicolas Ferre <nicolas.ferre@microchip.com>
    Cc: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Cc: Florian Fainelli <f.fainelli@gmail.com>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Baruch Siach <baruch@tkos.co.il>
    Cc: Keguang Zhang <keguang.zhang@gmail.com>
    Cc: Vladimir Zapolskiy <vz@mleia.com>
    Cc: Kevin Hilman <khilman@baylibre.com>
    Cc: Matthias Brugger <matthias.bgg@gmail.com>
    Cc: Avi Fishman <avifishman70@gmail.com>
    Cc: Nancy Yuen <yuenn@google.com>
    Cc: Brendan Higgins <brendanhiggins@google.com>
    Cc: Wan ZongShun <mcuos.com@gmail.com>
    Cc: Michal Simek <michal.simek@xilinx.com>
    Cc: Sylvain Lemieux <slemieux.tyco@gmail.com>
    Cc: Kukjin Kim <kgene@kernel.org>
    Cc: Barry Song <baohua@kernel.org>
    Cc: Orson Zhai <orsonzhai@gmail.com>
    Cc: Patrice Chotard <patrice.chotard@st.com>
    Cc: Maxime Coquelin <mcoquelin.stm32@gmail.com>
    Cc: Maxime Ripard <maxime.ripard@bootlin.com>
    Cc: Chen-Yu Tsai <wens@csie.org>
    Cc: Marc Gonzalez <marc.w.gonzalez@free.fr>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Cc: Shawn Guo <shawnguo@kernel.org>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Acked-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Tested-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Acked-by: Joel Stanley <joel@jms.id.au>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Maxime Ripard <maxime.ripard@bootlin.com>
    Acked-by: Michal Simek <michal.simek@xilinx.com> (cadence/xilinx wdts)
    Acked-by: Thierry Reding <treding@nvidia.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Acked-by: Patrice Chotard <patrice.chotard@st.com>
    Acked-by: Vladimir Zapolskiy <vz@mleia.com>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@linux-watchdog.org>

diff --git a/drivers/watchdog/ep93xx_wdt.c b/drivers/watchdog/ep93xx_wdt.c
index f9b14e6efd9a..1e721c2f9eac 100644
--- a/drivers/watchdog/ep93xx_wdt.c
+++ b/drivers/watchdog/ep93xx_wdt.c
@@ -91,7 +91,6 @@ static int ep93xx_wdt_probe(struct platform_device *pdev)
 {
 	struct ep93xx_wdt_priv *priv;
 	struct watchdog_device *wdd;
-	struct resource *res;
 	unsigned long val;
 	int ret;
 
@@ -99,8 +98,7 @@ static int ep93xx_wdt_probe(struct platform_device *pdev)
 	if (!priv)
 		return -ENOMEM;
 
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	priv->mmio = devm_ioremap_resource(&pdev->dev, res);
+	priv->mmio = devm_platform_ioremap_resource(pdev, 0);
 	if (IS_ERR(priv->mmio))
 		return PTR_ERR(priv->mmio);
 

commit 917003610d178b8bc3cbc63ee9fd203a7b01c444
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Jan 31 09:33:29 2017 -0700

    watchdog: ep93xx_wdt: cleanup and let the core handle the heartbeat
    
    Cleanup this driver and remove the 200ms heartbeat timer. The core now
    has the ability to handle the heartbeat.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    [groeck: Dropped 0-initialization of static variable]
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>

diff --git a/drivers/watchdog/ep93xx_wdt.c b/drivers/watchdog/ep93xx_wdt.c
index 8a6e1a7c63ae..f9b14e6efd9a 100644
--- a/drivers/watchdog/ep93xx_wdt.c
+++ b/drivers/watchdog/ep93xx_wdt.c
@@ -19,21 +19,13 @@
  * for us to rely on the user space daemon alone. So we ping the
  * wdt each ~200msec and eventually stop doing it if the user space
  * daemon dies.
- *
- * TODO:
- *
- *	- Test last reset from watchdog status
- *	- Add a few missing ioctls
  */
 
 #include <linux/platform_device.h>
 #include <linux/module.h>
 #include <linux/watchdog.h>
-#include <linux/timer.h>
 #include <linux/io.h>
 
-#define WDT_VERSION	"0.4"
-
 /* default timeout (secs) */
 #define WDT_TIMEOUT 30
 
@@ -41,59 +33,48 @@ static bool nowayout = WATCHDOG_NOWAYOUT;
 module_param(nowayout, bool, 0);
 MODULE_PARM_DESC(nowayout, "Watchdog cannot be stopped once started");
 
-static unsigned int timeout = WDT_TIMEOUT;
+static unsigned int timeout;
 module_param(timeout, uint, 0);
-MODULE_PARM_DESC(timeout,
-	"Watchdog timeout in seconds. (1<=timeout<=3600, default="
-				__MODULE_STRING(WDT_TIMEOUT) ")");
-
-static void __iomem *mmio_base;
-static struct timer_list timer;
-static unsigned long next_heartbeat;
+MODULE_PARM_DESC(timeout, "Watchdog timeout in seconds.");
 
 #define EP93XX_WATCHDOG		0x00
 #define EP93XX_WDSTATUS		0x04
 
-/* reset the wdt every ~200ms - the heartbeat of the device is 0.250 seconds*/
-#define WDT_INTERVAL (HZ/5)
-
-static void ep93xx_wdt_timer_ping(unsigned long data)
-{
-	if (time_before(jiffies, next_heartbeat))
-		writel(0x5555, mmio_base + EP93XX_WATCHDOG);
-
-	/* Re-set the timer interval */
-	mod_timer(&timer, jiffies + WDT_INTERVAL);
-}
+struct ep93xx_wdt_priv {
+	void __iomem *mmio;
+	struct watchdog_device wdd;
+};
 
 static int ep93xx_wdt_start(struct watchdog_device *wdd)
 {
-	next_heartbeat = jiffies + (timeout * HZ);
+	struct ep93xx_wdt_priv *priv = watchdog_get_drvdata(wdd);
 
-	writel(0xaaaa, mmio_base + EP93XX_WATCHDOG);
-	mod_timer(&timer, jiffies + WDT_INTERVAL);
+	writel(0xaaaa, priv->mmio + EP93XX_WATCHDOG);
 
 	return 0;
 }
 
 static int ep93xx_wdt_stop(struct watchdog_device *wdd)
 {
-	del_timer_sync(&timer);
-	writel(0xaa55, mmio_base + EP93XX_WATCHDOG);
+	struct ep93xx_wdt_priv *priv = watchdog_get_drvdata(wdd);
+
+	writel(0xaa55, priv->mmio + EP93XX_WATCHDOG);
 
 	return 0;
 }
 
-static int ep93xx_wdt_keepalive(struct watchdog_device *wdd)
+static int ep93xx_wdt_ping(struct watchdog_device *wdd)
 {
-	/* user land ping */
-	next_heartbeat = jiffies + (timeout * HZ);
+	struct ep93xx_wdt_priv *priv = watchdog_get_drvdata(wdd);
+
+	writel(0x5555, priv->mmio + EP93XX_WATCHDOG);
 
 	return 0;
 }
 
 static const struct watchdog_info ep93xx_wdt_ident = {
 	.options	= WDIOF_CARDRESET |
+			  WDIOF_SETTIMEOUT |
 			  WDIOF_MAGICCLOSE |
 			  WDIOF_KEEPALIVEPING,
 	.identity	= "EP93xx Watchdog",
@@ -103,55 +84,50 @@ static const struct watchdog_ops ep93xx_wdt_ops = {
 	.owner		= THIS_MODULE,
 	.start		= ep93xx_wdt_start,
 	.stop		= ep93xx_wdt_stop,
-	.ping		= ep93xx_wdt_keepalive,
-};
-
-static struct watchdog_device ep93xx_wdt_wdd = {
-	.info		= &ep93xx_wdt_ident,
-	.ops		= &ep93xx_wdt_ops,
+	.ping		= ep93xx_wdt_ping,
 };
 
 static int ep93xx_wdt_probe(struct platform_device *pdev)
 {
+	struct ep93xx_wdt_priv *priv;
+	struct watchdog_device *wdd;
 	struct resource *res;
 	unsigned long val;
-	int err;
+	int ret;
+
+	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	mmio_base = devm_ioremap_resource(&pdev->dev, res);
-	if (IS_ERR(mmio_base))
-		return PTR_ERR(mmio_base);
+	priv->mmio = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(priv->mmio))
+		return PTR_ERR(priv->mmio);
 
-	if (timeout < 1 || timeout > 3600) {
-		timeout = WDT_TIMEOUT;
-		dev_warn(&pdev->dev,
-			"timeout value must be 1<=x<=3600, using %d\n",
-			timeout);
-	}
+	val = readl(priv->mmio + EP93XX_WATCHDOG);
 
-	val = readl(mmio_base + EP93XX_WATCHDOG);
-	ep93xx_wdt_wdd.bootstatus = (val & 0x01) ? WDIOF_CARDRESET : 0;
-	ep93xx_wdt_wdd.timeout = timeout;
-	ep93xx_wdt_wdd.parent = &pdev->dev;
+	wdd = &priv->wdd;
+	wdd->bootstatus = (val & 0x01) ? WDIOF_CARDRESET : 0;
+	wdd->info = &ep93xx_wdt_ident;
+	wdd->ops = &ep93xx_wdt_ops;
+	wdd->min_timeout = 1;
+	wdd->max_hw_heartbeat_ms = 200;
+	wdd->parent = &pdev->dev;
 
-	watchdog_set_nowayout(&ep93xx_wdt_wdd, nowayout);
+	watchdog_set_nowayout(wdd, nowayout);
 
-	setup_timer(&timer, ep93xx_wdt_timer_ping, 1);
+	wdd->timeout = WDT_TIMEOUT;
+	watchdog_init_timeout(wdd, timeout, &pdev->dev);
 
-	err = watchdog_register_device(&ep93xx_wdt_wdd);
-	if (err)
-		return err;
+	watchdog_set_drvdata(wdd, priv);
 
-	dev_info(&pdev->dev,
-		"EP93XX watchdog, driver version " WDT_VERSION "%s\n",
-		(val & 0x08) ? " (nCS1 disable detected)" : "");
+	ret = devm_watchdog_register_device(&pdev->dev, wdd);
+	if (ret)
+		return ret;
 
-	return 0;
-}
+	dev_info(&pdev->dev, "EP93XX watchdog driver %s\n",
+		(val & 0x08) ? " (nCS1 disable detected)" : "");
 
-static int ep93xx_wdt_remove(struct platform_device *pdev)
-{
-	watchdog_unregister_device(&ep93xx_wdt_wdd);
 	return 0;
 }
 
@@ -160,7 +136,6 @@ static struct platform_driver ep93xx_wdt_driver = {
 		.name	= "ep93xx-wdt",
 	},
 	.probe		= ep93xx_wdt_probe,
-	.remove		= ep93xx_wdt_remove,
 };
 
 module_platform_driver(ep93xx_wdt_driver);
@@ -170,4 +145,3 @@ MODULE_AUTHOR("Alessandro Zummo <a.zummo@towertech.it>");
 MODULE_AUTHOR("H Hartley Sweeten <hsweeten@visionengravers.com>");
 MODULE_DESCRIPTION("EP93xx Watchdog");
 MODULE_LICENSE("GPL");
-MODULE_VERSION(WDT_VERSION);

commit b893e344bfbd01a3df5df32ecb9f7bf8f1271d46
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Sat Jan 28 13:11:17 2017 +0530

    watchdog: constify watchdog_ops structures
    
    Declare watchdog_ops structures as const as they are only stored in the
    ops field of a watchdog_device structure. This field is of type const, so
    watchdog_ops structures having this property can be made const too.
    Done using Coccinelle:
    
    @r disable optional_qualifier@
    identifier x;
    position p;
    @@
    static struct watchdog_ops x@p={...};
    
    @ok@
    struct watchdog_device w;
    identifier r.x;
    position p;
    @@
    w.ops=&x@p;
    
    @bad@
    position p != {r.p,ok.p};
    identifier r.x;
    @@
    x@p
    
    @depends on !bad disable optional_qualifier@
    identifier r.x;
    @@
    +const
    struct watchdog_ops x;
    
    File size details before and after patching.
    First line of every .o file shows the file size before patching
    and second line shows the size after patching.
    
       text    data     bss     dec     hex filename
    
       1340     544       0    1884     75c drivers/watchdog/bcm_kona_wdt.o
       1436     440       0    1876     754 drivers/watchdog/bcm_kona_wdt.o
    
       1176     544       4    1724     6bc drivers/watchdog/digicolor_wdt.o
       1272     440       4    1716     6b4 drivers/watchdog/digicolor_wdt.o
    
        925     580      89    1594     63a drivers/watchdog/ep93xx_wdt.o
       1021     476      89    1586     632 drivers/watchdog/ep93xx_wdt.o
    
       4932     288      17    5237    1475 drivers/watchdog/s3c2410_wdt.o
       5028     192      17    5237    1475 drivers/watchdog/s3c2410_wdt.o
    
       1977     292       1    2270     8de drivers/watchdog/sama5d4_wdt.o
       2073     196       1    2270     8de drivers/watchdog/sama5d4_wdt.o
    
       1375     484       1    1860     744 drivers/watchdog/sirfsoc_wdt.o
       1471     380       1    1852     73c drivers/watchdog/sirfsoc_wdt.o
    
    Size remains the same for the files drivers/watchdog/diag288_wdt.o
    drivers/watchdog/asm9260_wdt.o and drivers/watchdog/atlas7_wdt.o
    
    The following .o files did not compile:
    drivers/watchdog/sun4v_wdt.o, drivers/watchdog/sbsa_gwdt.o,
    drivers/watchdog/rt2880_wdt.o, drivers/watchdog/booke_wdt.o
    drivers/watchdog/mt7621_wdt.o
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>

diff --git a/drivers/watchdog/ep93xx_wdt.c b/drivers/watchdog/ep93xx_wdt.c
index 0a4d7cc05d54..8a6e1a7c63ae 100644
--- a/drivers/watchdog/ep93xx_wdt.c
+++ b/drivers/watchdog/ep93xx_wdt.c
@@ -99,7 +99,7 @@ static const struct watchdog_info ep93xx_wdt_ident = {
 	.identity	= "EP93xx Watchdog",
 };
 
-static struct watchdog_ops ep93xx_wdt_ops = {
+static const struct watchdog_ops ep93xx_wdt_ops = {
 	.owner		= THIS_MODULE,
 	.start		= ep93xx_wdt_start,
 	.stop		= ep93xx_wdt_stop,

commit 6551881c86c791237a3bebf11eb3bd70b60ea782
Author: Pratyush Anand <panand@redhat.com>
Date:   Thu Aug 20 14:05:01 2015 +0530

    Watchdog: Fix parent of watchdog_devices
    
    /sys/class/watchdog/watchdogn/device/modalias can help to identify the
    driver/module for a given watchdog node. However, many wdt devices do not
    set their parent and so, we do not see an entry for device in sysfs for
    such devices.
    
    This patch fixes parent of watchdog_device so that
    /sys/class/watchdog/watchdogn/device is populated.
    
    Exceptions: booke, diag288, octeon, softdog and w83627hf -- They do not
    have any parent. Not sure, how we can identify driver for these devices.
    
    Signed-off-by: Pratyush Anand <panand@redhat.com>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Acked-by: Guenter Roeck <linux@roeck-us.net>
    Acked-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Acked-by: Lee Jones <lee.jones@linaro.org>
    Acked-by: Lubomir Rintel <lkundrak@v3.sk>
    Acked-by: Maxime Coquelin <maxime.coquelin@st.com>
    Acked-by: Thierry Reding <treding@nvidia.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/drivers/watchdog/ep93xx_wdt.c b/drivers/watchdog/ep93xx_wdt.c
index 7a2cc7191c58..0a4d7cc05d54 100644
--- a/drivers/watchdog/ep93xx_wdt.c
+++ b/drivers/watchdog/ep93xx_wdt.c
@@ -132,6 +132,7 @@ static int ep93xx_wdt_probe(struct platform_device *pdev)
 	val = readl(mmio_base + EP93XX_WATCHDOG);
 	ep93xx_wdt_wdd.bootstatus = (val & 0x01) ? WDIOF_CARDRESET : 0;
 	ep93xx_wdt_wdd.timeout = timeout;
+	ep93xx_wdt_wdd.parent = &pdev->dev;
 
 	watchdog_set_nowayout(&ep93xx_wdt_wdd, nowayout);
 

commit fa21a580dea456c03fcf69203dcd0195df3f7dee
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Mon Oct 20 16:21:56 2014 +0200

    watchdog: drop owner assignment from platform_drivers
    
    A platform_driver does not need to set an owner, it will be populated by the
    driver core.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/watchdog/ep93xx_wdt.c b/drivers/watchdog/ep93xx_wdt.c
index 5f54e1e5819a..7a2cc7191c58 100644
--- a/drivers/watchdog/ep93xx_wdt.c
+++ b/drivers/watchdog/ep93xx_wdt.c
@@ -156,7 +156,6 @@ static int ep93xx_wdt_remove(struct platform_device *pdev)
 
 static struct platform_driver ep93xx_wdt_driver = {
 	.driver		= {
-		.owner	= THIS_MODULE,
 		.name	= "ep93xx-wdt",
 	},
 	.probe		= ep93xx_wdt_probe,

commit 5f5e19093b2fa592720810154f15ffe51aa9277f
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Thu Feb 27 14:41:42 2014 +0900

    watchdog: fix checkpatch warnings and error
    
    Fix the following checkpatch warnings and error:
      WARNING: quoted string split across lines
      WARNING: braces {} are not necessary for single statement blocks
      WARNING: __initdata should be placed after ibmasr_id_table[]
      WARNING: please, no space before tabs
      ERROR: do not initialise statics to 0 or NULL
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Reviewed-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/drivers/watchdog/ep93xx_wdt.c b/drivers/watchdog/ep93xx_wdt.c
index 5e4f3dea85f5..5f54e1e5819a 100644
--- a/drivers/watchdog/ep93xx_wdt.c
+++ b/drivers/watchdog/ep93xx_wdt.c
@@ -165,9 +165,9 @@ static struct platform_driver ep93xx_wdt_driver = {
 
 module_platform_driver(ep93xx_wdt_driver);
 
-MODULE_AUTHOR("Ray Lehtiniemi <rayl@mail.com>,"
-		"Alessandro Zummo <a.zummo@towertech.it>,"
-		"H Hartley Sweeten <hsweeten@visionengravers.com>");
+MODULE_AUTHOR("Ray Lehtiniemi <rayl@mail.com>");
+MODULE_AUTHOR("Alessandro Zummo <a.zummo@towertech.it>");
+MODULE_AUTHOR("H Hartley Sweeten <hsweeten@visionengravers.com>");
 MODULE_DESCRIPTION("EP93xx Watchdog");
 MODULE_LICENSE("GPL");
 MODULE_VERSION(WDT_VERSION);

commit 4f6120b014c6a981a57a8951e01acfead1a57069
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Tue Feb 11 21:41:54 2014 +0900

    watchdog: ep93xx_wdt: Use devm_ioremap_resource()
    
    Use devm_ioremap_resource() in order to make the code simpler,
    and remove redundant return value check of platform_get_resource()
    because the value is checked by devm_ioremap_resource().
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Reviewed-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/drivers/watchdog/ep93xx_wdt.c b/drivers/watchdog/ep93xx_wdt.c
index d1d07f2f69df..5e4f3dea85f5 100644
--- a/drivers/watchdog/ep93xx_wdt.c
+++ b/drivers/watchdog/ep93xx_wdt.c
@@ -118,16 +118,9 @@ static int ep93xx_wdt_probe(struct platform_device *pdev)
 	int err;
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!res)
-		return -ENXIO;
-
-	if (!devm_request_mem_region(&pdev->dev, res->start,
-				     resource_size(res), pdev->name))
-		return -EBUSY;
-
-	mmio_base = devm_ioremap(&pdev->dev, res->start, resource_size(res));
-	if (!mmio_base)
-		return -ENXIO;
+	mmio_base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(mmio_base))
+		return PTR_ERR(mmio_base);
 
 	if (timeout < 1 || timeout > 3600) {
 		timeout = WDT_TIMEOUT;

commit 9539210e17dc09ea1472076c297d461c7507a5bb
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Tue Nov 19 13:26:17 2013 -0800

    watchdog: Drop unnecessary include of miscdevice.h
    
    After commit 487722cf2 (watchdog: Get rid of MODULE_ALIAS_MISCDEV
    statements) the affected drivers no longer need to include miscdevice.h.
    Only exception is rt2880_wdt.c which never needed it.
    
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Reviewed-by: Jean Delvare <jdelvare@suse.de>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/drivers/watchdog/ep93xx_wdt.c b/drivers/watchdog/ep93xx_wdt.c
index 833e81311848..d1d07f2f69df 100644
--- a/drivers/watchdog/ep93xx_wdt.c
+++ b/drivers/watchdog/ep93xx_wdt.c
@@ -28,7 +28,6 @@
 
 #include <linux/platform_device.h>
 #include <linux/module.h>
-#include <linux/miscdevice.h>
 #include <linux/watchdog.h>
 #include <linux/timer.h>
 #include <linux/io.h>

commit 487722cf2d66126338217896642bd5eec832c34b
Author: Jean Delvare <jdelvare@suse.de>
Date:   Mon Oct 21 17:38:49 2013 +0200

    watchdog: Get rid of MODULE_ALIAS_MISCDEV statements
    
    I just can't find any value in MODULE_ALIAS_MISCDEV(WATCHDOG_MINOR)
    and MODULE_ALIAS_MISCDEV(TEMP_MINOR) statements.
    
    Either the device is enumerated and the driver already has a module
    alias (e.g. PCI, USB etc.) that will get the right driver loaded
    automatically.
    
    Or the device is not enumerated and loading its driver will lead to
    more or less intrusive hardware poking. Such hardware poking should be
    limited to a bare minimum, so the user should really decide which
    drivers should be tried and in what order. Trying them all in
    arbitrary order can't do any good.
    
    On top of that, loading that many drivers at once bloats the kernel
    log. Also many drivers will stay loaded afterward, bloating the output
    of "lsmod" and wasting memory. Some modules (cs5535_mfgpt which gets
    loaded as a dependency) can't even be unloaded!
    
    If defining char-major-10-130 is needed then it should happen in
    user-space.
    
    Signed-off-by: Jean Delvare <jdelvare@suse.de>
    Acked-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>
    Cc: Stephen Warren <swarren@wwwdotorg.org>
    Cc: Mike Frysinger <vapier.adi@gmail.com>
    Cc: Wan ZongShun <mcuos.com@gmail.com>
    Cc: Ben Dooks <ben-linux@fluff.org>
    Cc: Kukjin Kim <kgene.kim@samsung.com>
    Cc: Zwane Mwaikambo <zwane@arm.linux.org.uk>
    Cc: Jim Cromie <jim.cromie@gmail.com>

diff --git a/drivers/watchdog/ep93xx_wdt.c b/drivers/watchdog/ep93xx_wdt.c
index e0574844c313..833e81311848 100644
--- a/drivers/watchdog/ep93xx_wdt.c
+++ b/drivers/watchdog/ep93xx_wdt.c
@@ -179,4 +179,3 @@ MODULE_AUTHOR("Ray Lehtiniemi <rayl@mail.com>,"
 MODULE_DESCRIPTION("EP93xx Watchdog");
 MODULE_LICENSE("GPL");
 MODULE_VERSION(WDT_VERSION);
-MODULE_ALIAS_MISCDEV(WATCHDOG_MINOR);

commit 4b12b896c27c3b54592816606679f5b02f638930
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:26:24 2012 -0500

    watchdog: remove use of __devexit
    
    CONFIG_HOTPLUG is going away as an option so __devexit is no
    longer needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Wim Van Sebroeck <wim@iguana.be>
    Cc: Wan ZongShun <mcuos.com@gmail.com>
    Cc: Ben Dooks <ben-linux@fluff.org>
    Cc: Kukjin Kim <kgene.kim@samsung.com>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/watchdog/ep93xx_wdt.c b/drivers/watchdog/ep93xx_wdt.c
index f1bd88c5a204..e0574844c313 100644
--- a/drivers/watchdog/ep93xx_wdt.c
+++ b/drivers/watchdog/ep93xx_wdt.c
@@ -156,7 +156,7 @@ static int ep93xx_wdt_probe(struct platform_device *pdev)
 	return 0;
 }
 
-static int __devexit ep93xx_wdt_remove(struct platform_device *pdev)
+static int ep93xx_wdt_remove(struct platform_device *pdev)
 {
 	watchdog_unregister_device(&ep93xx_wdt_wdd);
 	return 0;

commit 2d991a164a61858012651e13c59521975504e260
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:21:41 2012 -0500

    watchdog: remove use of __devinit
    
    CONFIG_HOTPLUG is going away as an option so __devinit is no longer
    needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Wim Van Sebroeck <wim@iguana.be>
    Cc: Wan ZongShun <mcuos.com@gmail.com>
    Cc: Ben Dooks <ben-linux@fluff.org>
    Cc: Kukjin Kim <kgene.kim@samsung.com>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/watchdog/ep93xx_wdt.c b/drivers/watchdog/ep93xx_wdt.c
index 91703a58145d..f1bd88c5a204 100644
--- a/drivers/watchdog/ep93xx_wdt.c
+++ b/drivers/watchdog/ep93xx_wdt.c
@@ -112,7 +112,7 @@ static struct watchdog_device ep93xx_wdt_wdd = {
 	.ops		= &ep93xx_wdt_ops,
 };
 
-static int __devinit ep93xx_wdt_probe(struct platform_device *pdev)
+static int ep93xx_wdt_probe(struct platform_device *pdev)
 {
 	struct resource *res;
 	unsigned long val;

commit 82268714bdf06bc06135efb707a9de590ab2d294
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:21:12 2012 -0500

    watchdog: remove use of __devexit_p
    
    CONFIG_HOTPLUG is going away as an option so __devexit_p is no longer
    needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Wim Van Sebroeck <wim@iguana.be>
    Cc: Wan ZongShun <mcuos.com@gmail.com>
    Cc: Ben Dooks <ben-linux@fluff.org>
    Cc: Kukjin Kim <kgene.kim@samsung.com>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/watchdog/ep93xx_wdt.c b/drivers/watchdog/ep93xx_wdt.c
index 77050037597a..91703a58145d 100644
--- a/drivers/watchdog/ep93xx_wdt.c
+++ b/drivers/watchdog/ep93xx_wdt.c
@@ -168,7 +168,7 @@ static struct platform_driver ep93xx_wdt_driver = {
 		.name	= "ep93xx-wdt",
 	},
 	.probe		= ep93xx_wdt_probe,
-	.remove		= __devexit_p(ep93xx_wdt_remove),
+	.remove		= ep93xx_wdt_remove,
 };
 
 module_platform_driver(ep93xx_wdt_driver);

commit 2ca1606359695cc7ce371c7829c4082d9095fc06
Author: Wim Van Sebroeck <wim@iguana.be>
Date:   Thu Mar 22 09:37:10 2012 +0100

    watchdog: ep93xx_wdt: timeout is an unsigned int value.
    
    the timeout is a positive thus unsigned int value.
    Also re-add the comment about the actual heartbeat.
    
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/drivers/watchdog/ep93xx_wdt.c b/drivers/watchdog/ep93xx_wdt.c
index 29575f8228bd..77050037597a 100644
--- a/drivers/watchdog/ep93xx_wdt.c
+++ b/drivers/watchdog/ep93xx_wdt.c
@@ -42,8 +42,8 @@ static bool nowayout = WATCHDOG_NOWAYOUT;
 module_param(nowayout, bool, 0);
 MODULE_PARM_DESC(nowayout, "Watchdog cannot be stopped once started");
 
-static int timeout = WDT_TIMEOUT;
-module_param(timeout, int, 0);
+static unsigned int timeout = WDT_TIMEOUT;
+module_param(timeout, uint, 0);
 MODULE_PARM_DESC(timeout,
 	"Watchdog timeout in seconds. (1<=timeout<=3600, default="
 				__MODULE_STRING(WDT_TIMEOUT) ")");
@@ -55,7 +55,7 @@ static unsigned long next_heartbeat;
 #define EP93XX_WATCHDOG		0x00
 #define EP93XX_WDSTATUS		0x04
 
-/* reset the wdt every ~200ms */
+/* reset the wdt every ~200ms - the heartbeat of the device is 0.250 seconds*/
 #define WDT_INTERVAL (HZ/5)
 
 static void ep93xx_wdt_timer_ping(unsigned long data)

commit 59dcf1eb1a4b15610c68a4dbb7430d61a65f4af3
Author: Mika Westerberg <mika.westerberg@iki.fi>
Date:   Sun Mar 18 13:09:52 2012 +0200

    watchdog: ep93xx_wdt: Fix timeout after conversion to watchdog core
    
    After the conversion of this driver to the watchdog core, I noticed that we
    miss setting the initial timeout of the wdt device.
    This results in a failure of the WDIOC_GETTIMEOUT ioctl call.
    
    Reviewed-by: Mika Westerberg <mika.westerberg@iki.fi>
    Tested-by: Mika Westerberg <mika.westerberg@iki.fi>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/drivers/watchdog/ep93xx_wdt.c b/drivers/watchdog/ep93xx_wdt.c
index 414ce8fdecc9..29575f8228bd 100644
--- a/drivers/watchdog/ep93xx_wdt.c
+++ b/drivers/watchdog/ep93xx_wdt.c
@@ -139,6 +139,7 @@ static int __devinit ep93xx_wdt_probe(struct platform_device *pdev)
 
 	val = readl(mmio_base + EP93XX_WATCHDOG);
 	ep93xx_wdt_wdd.bootstatus = (val & 0x01) ? WDIOF_CARDRESET : 0;
+	ep93xx_wdt_wdd.timeout = timeout;
 
 	watchdog_set_nowayout(&ep93xx_wdt_wdd, nowayout);
 

commit e12a679ddee4eb5ab2f99f7cf129355461e142c0
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Mar 14 10:31:50 2012 -0700

    watchdog: Convert ep93xx driver to watchdog core
    
    Convert the ep93xx_wdt driver to the watchdog framework API.
    
    Also, use the dev_<fmt> functions instead of pr_<fmt> for logging.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ryan Mallon <rmallon@gmail.com>
    Cc: Mika Westerberg <mika.westerberg@iki.fi>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/drivers/watchdog/ep93xx_wdt.c b/drivers/watchdog/ep93xx_wdt.c
index bd01bde27c4a..414ce8fdecc9 100644
--- a/drivers/watchdog/ep93xx_wdt.c
+++ b/drivers/watchdog/ep93xx_wdt.c
@@ -8,6 +8,9 @@
  * Authors: Ray Lehtiniemi <rayl@mail.com>,
  *	Alessandro Zummo <a.zummo@towertech.it>
  *
+ * Copyright (c) 2012 H Hartley Sweeten <hsweeten@visionengravers.com>
+ *	Convert to a platform device and use the watchdog framework API
+ *
  * This file is licensed under the terms of the GNU General Public
  * License version 2. This program is licensed "as is" without any
  * warranty of any kind, whether express or implied.
@@ -23,33 +26,31 @@
  *	- Add a few missing ioctls
  */
 
-#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
-
 #include <linux/platform_device.h>
 #include <linux/module.h>
-#include <linux/fs.h>
 #include <linux/miscdevice.h>
 #include <linux/watchdog.h>
 #include <linux/timer.h>
-#include <linux/uaccess.h>
 #include <linux/io.h>
 
-#define WDT_VERSION	"0.3"
+#define WDT_VERSION	"0.4"
 
 /* default timeout (secs) */
 #define WDT_TIMEOUT 30
 
 static bool nowayout = WATCHDOG_NOWAYOUT;
+module_param(nowayout, bool, 0);
+MODULE_PARM_DESC(nowayout, "Watchdog cannot be stopped once started");
+
 static int timeout = WDT_TIMEOUT;
+module_param(timeout, int, 0);
+MODULE_PARM_DESC(timeout,
+	"Watchdog timeout in seconds. (1<=timeout<=3600, default="
+				__MODULE_STRING(WDT_TIMEOUT) ")");
 
 static void __iomem *mmio_base;
 static struct timer_list timer;
 static unsigned long next_heartbeat;
-static unsigned long wdt_status;
-static unsigned long boot_status;
-
-#define WDT_IN_USE		0
-#define WDT_OK_TO_CLOSE		1
 
 #define EP93XX_WATCHDOG		0x00
 #define EP93XX_WDSTATUS		0x04
@@ -57,155 +58,60 @@ static unsigned long boot_status;
 /* reset the wdt every ~200ms */
 #define WDT_INTERVAL (HZ/5)
 
-static void wdt_enable(void)
-{
-	writel(0xaaaa, mmio_base + EP93XX_WATCHDOG);
-}
-
-static void wdt_disable(void)
+static void ep93xx_wdt_timer_ping(unsigned long data)
 {
-	writel(0xaa55, mmio_base + EP93XX_WATCHDOG);
-}
+	if (time_before(jiffies, next_heartbeat))
+		writel(0x5555, mmio_base + EP93XX_WATCHDOG);
 
-static inline void wdt_ping(void)
-{
-	writel(0x5555, mmio_base + EP93XX_WATCHDOG);
+	/* Re-set the timer interval */
+	mod_timer(&timer, jiffies + WDT_INTERVAL);
 }
 
-static void wdt_startup(void)
+static int ep93xx_wdt_start(struct watchdog_device *wdd)
 {
 	next_heartbeat = jiffies + (timeout * HZ);
 
-	wdt_enable();
+	writel(0xaaaa, mmio_base + EP93XX_WATCHDOG);
 	mod_timer(&timer, jiffies + WDT_INTERVAL);
+
+	return 0;
 }
 
-static void wdt_shutdown(void)
+static int ep93xx_wdt_stop(struct watchdog_device *wdd)
 {
 	del_timer_sync(&timer);
-	wdt_disable();
+	writel(0xaa55, mmio_base + EP93XX_WATCHDOG);
+
+	return 0;
 }
 
-static void wdt_keepalive(void)
+static int ep93xx_wdt_keepalive(struct watchdog_device *wdd)
 {
 	/* user land ping */
 	next_heartbeat = jiffies + (timeout * HZ);
-}
-
-static int ep93xx_wdt_open(struct inode *inode, struct file *file)
-{
-	if (test_and_set_bit(WDT_IN_USE, &wdt_status))
-		return -EBUSY;
-
-	clear_bit(WDT_OK_TO_CLOSE, &wdt_status);
-
-	wdt_startup();
-
-	return nonseekable_open(inode, file);
-}
-
-static ssize_t
-ep93xx_wdt_write(struct file *file, const char __user *data, size_t len,
-		 loff_t *ppos)
-{
-	if (len) {
-		if (!nowayout) {
-			size_t i;
-
-			clear_bit(WDT_OK_TO_CLOSE, &wdt_status);
-
-			for (i = 0; i != len; i++) {
-				char c;
 
-				if (get_user(c, data + i))
-					return -EFAULT;
-
-				if (c == 'V')
-					set_bit(WDT_OK_TO_CLOSE, &wdt_status);
-				else
-					clear_bit(WDT_OK_TO_CLOSE, &wdt_status);
-			}
-		}
-		wdt_keepalive();
-	}
-
-	return len;
+	return 0;
 }
 
-static const struct watchdog_info ident = {
-	.options = WDIOF_CARDRESET | WDIOF_MAGICCLOSE,
-	.identity = "EP93xx Watchdog",
+static const struct watchdog_info ep93xx_wdt_ident = {
+	.options	= WDIOF_CARDRESET |
+			  WDIOF_MAGICCLOSE |
+			  WDIOF_KEEPALIVEPING,
+	.identity	= "EP93xx Watchdog",
 };
 
-static long ep93xx_wdt_ioctl(struct file *file,
-					unsigned int cmd, unsigned long arg)
-{
-	int ret = -ENOTTY;
-
-	switch (cmd) {
-	case WDIOC_GETSUPPORT:
-		ret = copy_to_user((struct watchdog_info __user *)arg, &ident,
-				sizeof(ident)) ? -EFAULT : 0;
-		break;
-
-	case WDIOC_GETSTATUS:
-		ret = put_user(0, (int __user *)arg);
-		break;
-
-	case WDIOC_GETBOOTSTATUS:
-		ret = put_user(boot_status, (int __user *)arg);
-		break;
-
-	case WDIOC_KEEPALIVE:
-		wdt_keepalive();
-		ret = 0;
-		break;
-
-	case WDIOC_GETTIMEOUT:
-		/* actually, it is 0.250 seconds.... */
-		ret = put_user(1, (int __user *)arg);
-		break;
-	}
-	return ret;
-}
-
-static int ep93xx_wdt_release(struct inode *inode, struct file *file)
-{
-	if (test_bit(WDT_OK_TO_CLOSE, &wdt_status))
-		wdt_shutdown();
-	else
-		pr_crit("Device closed unexpectedly - timer will not stop\n");
-
-	clear_bit(WDT_IN_USE, &wdt_status);
-	clear_bit(WDT_OK_TO_CLOSE, &wdt_status);
-
-	return 0;
-}
-
-static const struct file_operations ep93xx_wdt_fops = {
+static struct watchdog_ops ep93xx_wdt_ops = {
 	.owner		= THIS_MODULE,
-	.write		= ep93xx_wdt_write,
-	.unlocked_ioctl	= ep93xx_wdt_ioctl,
-	.open		= ep93xx_wdt_open,
-	.release	= ep93xx_wdt_release,
-	.llseek		= no_llseek,
+	.start		= ep93xx_wdt_start,
+	.stop		= ep93xx_wdt_stop,
+	.ping		= ep93xx_wdt_keepalive,
 };
 
-static struct miscdevice ep93xx_wdt_miscdev = {
-	.minor		= WATCHDOG_MINOR,
-	.name		= "watchdog",
-	.fops		= &ep93xx_wdt_fops,
+static struct watchdog_device ep93xx_wdt_wdd = {
+	.info		= &ep93xx_wdt_ident,
+	.ops		= &ep93xx_wdt_ops,
 };
 
-static void ep93xx_timer_ping(unsigned long data)
-{
-	if (time_before(jiffies, next_heartbeat))
-		wdt_ping();
-
-	/* Re-set the timer interval */
-	mod_timer(&timer, jiffies + WDT_INTERVAL);
-}
-
 static int __devinit ep93xx_wdt_probe(struct platform_device *pdev)
 {
 	struct resource *res;
@@ -226,26 +132,32 @@ static int __devinit ep93xx_wdt_probe(struct platform_device *pdev)
 
 	if (timeout < 1 || timeout > 3600) {
 		timeout = WDT_TIMEOUT;
-		pr_info("timeout value must be 1<=x<=3600, using %d\n",
+		dev_warn(&pdev->dev,
+			"timeout value must be 1<=x<=3600, using %d\n",
 			timeout);
 	}
 
 	val = readl(mmio_base + EP93XX_WATCHDOG);
-	boot_status = val & 0x01 ? 1 : 0;
+	ep93xx_wdt_wdd.bootstatus = (val & 0x01) ? WDIOF_CARDRESET : 0;
+
+	watchdog_set_nowayout(&ep93xx_wdt_wdd, nowayout);
 
-	setup_timer(&timer, ep93xx_timer_ping, 1);
+	setup_timer(&timer, ep93xx_wdt_timer_ping, 1);
 
-	err = misc_register(&ep93xx_wdt_miscdev);
+	err = watchdog_register_device(&ep93xx_wdt_wdd);
+	if (err)
+		return err;
 
-	pr_info("EP93XX watchdog, driver version " WDT_VERSION "%s\n",
+	dev_info(&pdev->dev,
+		"EP93XX watchdog, driver version " WDT_VERSION "%s\n",
 		(val & 0x08) ? " (nCS1 disable detected)" : "");
-	return err;
+
+	return 0;
 }
 
 static int __devexit ep93xx_wdt_remove(struct platform_device *pdev)
 {
-	wdt_shutdown();
-	misc_deregister(&ep93xx_wdt_miscdev);
+	watchdog_unregister_device(&ep93xx_wdt_wdd);
 	return 0;
 }
 
@@ -260,16 +172,9 @@ static struct platform_driver ep93xx_wdt_driver = {
 
 module_platform_driver(ep93xx_wdt_driver);
 
-module_param(nowayout, bool, 0);
-MODULE_PARM_DESC(nowayout, "Watchdog cannot be stopped once started");
-
-module_param(timeout, int, 0);
-MODULE_PARM_DESC(timeout,
-	"Watchdog timeout in seconds. (1<=timeout<=3600, default="
-				__MODULE_STRING(WDT_TIMEOUT) ")");
-
 MODULE_AUTHOR("Ray Lehtiniemi <rayl@mail.com>,"
-		"Alessandro Zummo <a.zummo@towertech.it>");
+		"Alessandro Zummo <a.zummo@towertech.it>,"
+		"H Hartley Sweeten <hsweeten@visionengravers.com>");
 MODULE_DESCRIPTION("EP93xx Watchdog");
 MODULE_LICENSE("GPL");
 MODULE_VERSION(WDT_VERSION);

commit 697b41e4d4b20b8d8564f5501927b0ed07153990
Author: Wim Van Sebroeck <wim@iguana.be>
Date:   Tue Mar 13 09:06:12 2012 +0100

    watchdog: ep93xx_wdt.c: fix platform probe
    
    Fix the device/driver init so that the misc_register
    happens as last (since this opens userspace access to
    the device).
    
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/drivers/watchdog/ep93xx_wdt.c b/drivers/watchdog/ep93xx_wdt.c
index 35c49da30b42..bd01bde27c4a 100644
--- a/drivers/watchdog/ep93xx_wdt.c
+++ b/drivers/watchdog/ep93xx_wdt.c
@@ -224,21 +224,21 @@ static int __devinit ep93xx_wdt_probe(struct platform_device *pdev)
 	if (!mmio_base)
 		return -ENXIO;
 
-	err = misc_register(&ep93xx_wdt_miscdev);
-
-	val = readl(mmio_base + EP93XX_WATCHDOG);
-	boot_status = val & 0x01 ? 1 : 0;
-
-	pr_info("EP93XX watchdog, driver version " WDT_VERSION "%s\n",
-		(val & 0x08) ? " (nCS1 disable detected)" : "");
-
 	if (timeout < 1 || timeout > 3600) {
 		timeout = WDT_TIMEOUT;
 		pr_info("timeout value must be 1<=x<=3600, using %d\n",
 			timeout);
 	}
 
+	val = readl(mmio_base + EP93XX_WATCHDOG);
+	boot_status = val & 0x01 ? 1 : 0;
+
 	setup_timer(&timer, ep93xx_timer_ping, 1);
+
+	err = misc_register(&ep93xx_wdt_miscdev);
+
+	pr_info("EP93XX watchdog, driver version " WDT_VERSION "%s\n",
+		(val & 0x08) ? " (nCS1 disable detected)" : "");
 	return err;
 }
 

commit 3e0113a896803f792ffdf19b016578420824573f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 13 09:48:16 2012 +1100

    watchdog: ep93xx: Convert the watchdog driver into a platform device.
    
    Convert the ep93xx watchdog driver into a platform device and
    remove it's dependency on <mach/hardware.h>.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Ryan Mallon <rmallon@gmail.com>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>
    Reviewed-by: Mika Westerberg <mika.westerberg@iki.fi>
    Acked-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/drivers/watchdog/ep93xx_wdt.c b/drivers/watchdog/ep93xx_wdt.c
index 8caa3164270c..35c49da30b42 100644
--- a/drivers/watchdog/ep93xx_wdt.c
+++ b/drivers/watchdog/ep93xx_wdt.c
@@ -25,6 +25,7 @@
 
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
 
+#include <linux/platform_device.h>
 #include <linux/module.h>
 #include <linux/fs.h>
 #include <linux/miscdevice.h>
@@ -32,7 +33,6 @@
 #include <linux/timer.h>
 #include <linux/uaccess.h>
 #include <linux/io.h>
-#include <mach/hardware.h>
 
 #define WDT_VERSION	"0.3"
 
@@ -42,6 +42,7 @@
 static bool nowayout = WATCHDOG_NOWAYOUT;
 static int timeout = WDT_TIMEOUT;
 
+static void __iomem *mmio_base;
 static struct timer_list timer;
 static unsigned long next_heartbeat;
 static unsigned long wdt_status;
@@ -50,26 +51,25 @@ static unsigned long boot_status;
 #define WDT_IN_USE		0
 #define WDT_OK_TO_CLOSE		1
 
-#define EP93XX_WDT_REG(x)	(EP93XX_WATCHDOG_BASE + (x))
-#define EP93XX_WDT_WATCHDOG	EP93XX_WDT_REG(0x00)
-#define EP93XX_WDT_WDSTATUS	EP93XX_WDT_REG(0x04)
+#define EP93XX_WATCHDOG		0x00
+#define EP93XX_WDSTATUS		0x04
 
 /* reset the wdt every ~200ms */
 #define WDT_INTERVAL (HZ/5)
 
 static void wdt_enable(void)
 {
-	__raw_writew(0xaaaa, EP93XX_WDT_WATCHDOG);
+	writel(0xaaaa, mmio_base + EP93XX_WATCHDOG);
 }
 
 static void wdt_disable(void)
 {
-	__raw_writew(0xaa55, EP93XX_WDT_WATCHDOG);
+	writel(0xaa55, mmio_base + EP93XX_WATCHDOG);
 }
 
 static inline void wdt_ping(void)
 {
-	__raw_writew(0x5555, EP93XX_WDT_WATCHDOG);
+	writel(0x5555, mmio_base + EP93XX_WATCHDOG);
 }
 
 static void wdt_startup(void)
@@ -206,17 +206,31 @@ static void ep93xx_timer_ping(unsigned long data)
 	mod_timer(&timer, jiffies + WDT_INTERVAL);
 }
 
-static int __init ep93xx_wdt_init(void)
+static int __devinit ep93xx_wdt_probe(struct platform_device *pdev)
 {
+	struct resource *res;
+	unsigned long val;
 	int err;
 
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res)
+		return -ENXIO;
+
+	if (!devm_request_mem_region(&pdev->dev, res->start,
+				     resource_size(res), pdev->name))
+		return -EBUSY;
+
+	mmio_base = devm_ioremap(&pdev->dev, res->start, resource_size(res));
+	if (!mmio_base)
+		return -ENXIO;
+
 	err = misc_register(&ep93xx_wdt_miscdev);
 
-	boot_status = __raw_readl(EP93XX_WDT_WATCHDOG) & 0x01 ? 1 : 0;
+	val = readl(mmio_base + EP93XX_WATCHDOG);
+	boot_status = val & 0x01 ? 1 : 0;
 
 	pr_info("EP93XX watchdog, driver version " WDT_VERSION "%s\n",
-		(__raw_readl(EP93XX_WDT_WATCHDOG) & 0x08)
-		? " (nCS1 disable detected)" : "");
+		(val & 0x08) ? " (nCS1 disable detected)" : "");
 
 	if (timeout < 1 || timeout > 3600) {
 		timeout = WDT_TIMEOUT;
@@ -228,14 +242,23 @@ static int __init ep93xx_wdt_init(void)
 	return err;
 }
 
-static void __exit ep93xx_wdt_exit(void)
+static int __devexit ep93xx_wdt_remove(struct platform_device *pdev)
 {
 	wdt_shutdown();
 	misc_deregister(&ep93xx_wdt_miscdev);
+	return 0;
 }
 
-module_init(ep93xx_wdt_init);
-module_exit(ep93xx_wdt_exit);
+static struct platform_driver ep93xx_wdt_driver = {
+	.driver		= {
+		.owner	= THIS_MODULE,
+		.name	= "ep93xx-wdt",
+	},
+	.probe		= ep93xx_wdt_probe,
+	.remove		= __devexit_p(ep93xx_wdt_remove),
+};
+
+module_platform_driver(ep93xx_wdt_driver);
 
 module_param(nowayout, bool, 0);
 MODULE_PARM_DESC(nowayout, "Watchdog cannot be stopped once started");

commit 86a1e1896c2710402e29a875d8d830244274244d
Author: Wim Van Sebroeck <wim@iguana.be>
Date:   Mon Mar 5 16:51:11 2012 +0100

    watchdog: nowayout is bool
    
    nowayout is actually a boolean value.
    So make it bool for all watchdog device drivers.
    
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/drivers/watchdog/ep93xx_wdt.c b/drivers/watchdog/ep93xx_wdt.c
index a6532b52c457..8caa3164270c 100644
--- a/drivers/watchdog/ep93xx_wdt.c
+++ b/drivers/watchdog/ep93xx_wdt.c
@@ -39,7 +39,7 @@
 /* default timeout (secs) */
 #define WDT_TIMEOUT 30
 
-static int nowayout = WATCHDOG_NOWAYOUT;
+static bool nowayout = WATCHDOG_NOWAYOUT;
 static int timeout = WDT_TIMEOUT;
 
 static struct timer_list timer;
@@ -237,7 +237,7 @@ static void __exit ep93xx_wdt_exit(void)
 module_init(ep93xx_wdt_init);
 module_exit(ep93xx_wdt_exit);
 
-module_param(nowayout, int, 0);
+module_param(nowayout, bool, 0);
 MODULE_PARM_DESC(nowayout, "Watchdog cannot be stopped once started");
 
 module_param(timeout, int, 0);

commit 27c766aaacb265d625dc634bf7903f7f9fd0c697
Author: Joe Perches <joe@perches.com>
Date:   Wed Feb 15 15:06:19 2012 -0800

    watchdog: Use pr_<fmt> and pr_<level>
    
    Use the current logging styles.
    
    Make sure all output has a prefix.
    Add missing newlines.
    Remove now unnecessary PFX, NAME, and miscellaneous other #defines.
    Coalesce formats.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/drivers/watchdog/ep93xx_wdt.c b/drivers/watchdog/ep93xx_wdt.c
index 726b7df61fd0..a6532b52c457 100644
--- a/drivers/watchdog/ep93xx_wdt.c
+++ b/drivers/watchdog/ep93xx_wdt.c
@@ -23,6 +23,8 @@
  *	- Add a few missing ioctls
  */
 
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
 #include <linux/module.h>
 #include <linux/fs.h>
 #include <linux/miscdevice.h>
@@ -33,7 +35,6 @@
 #include <mach/hardware.h>
 
 #define WDT_VERSION	"0.3"
-#define PFX		"ep93xx_wdt: "
 
 /* default timeout (secs) */
 #define WDT_TIMEOUT 30
@@ -173,8 +174,7 @@ static int ep93xx_wdt_release(struct inode *inode, struct file *file)
 	if (test_bit(WDT_OK_TO_CLOSE, &wdt_status))
 		wdt_shutdown();
 	else
-		printk(KERN_CRIT PFX
-			"Device closed unexpectedly - timer will not stop\n");
+		pr_crit("Device closed unexpectedly - timer will not stop\n");
 
 	clear_bit(WDT_IN_USE, &wdt_status);
 	clear_bit(WDT_OK_TO_CLOSE, &wdt_status);
@@ -214,15 +214,13 @@ static int __init ep93xx_wdt_init(void)
 
 	boot_status = __raw_readl(EP93XX_WDT_WATCHDOG) & 0x01 ? 1 : 0;
 
-	printk(KERN_INFO PFX "EP93XX watchdog, driver version "
-		WDT_VERSION "%s\n",
+	pr_info("EP93XX watchdog, driver version " WDT_VERSION "%s\n",
 		(__raw_readl(EP93XX_WDT_WATCHDOG) & 0x08)
 		? " (nCS1 disable detected)" : "");
 
 	if (timeout < 1 || timeout > 3600) {
 		timeout = WDT_TIMEOUT;
-		printk(KERN_INFO PFX
-			"timeout value must be 1<=x<=3600, using %d\n",
+		pr_info("timeout value must be 1<=x<=3600, using %d\n",
 			timeout);
 	}
 

commit 6038f373a3dc1f1c26496e60b6c40b164716f07e
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Sun Aug 15 18:52:59 2010 +0200

    llseek: automatically add .llseek fop
    
    All file_operations should get a .llseek operation so we can make
    nonseekable_open the default for future file operations without a
    .llseek pointer.
    
    The three cases that we can automatically detect are no_llseek, seq_lseek
    and default_llseek. For cases where we can we can automatically prove that
    the file offset is always ignored, we use noop_llseek, which maintains
    the current behavior of not returning an error from a seek.
    
    New drivers should normally not use noop_llseek but instead use no_llseek
    and call nonseekable_open at open time.  Existing drivers can be converted
    to do the same when the maintainer knows for certain that no user code
    relies on calling seek on the device file.
    
    The generated code is often incorrectly indented and right now contains
    comments that clarify for each added line why a specific variant was
    chosen. In the version that gets submitted upstream, the comments will
    be gone and I will manually fix the indentation, because there does not
    seem to be a way to do that using coccinelle.
    
    Some amount of new code is currently sitting in linux-next that should get
    the same modifications, which I will do at the end of the merge window.
    
    Many thanks to Julia Lawall for helping me learn to write a semantic
    patch that does all this.
    
    ===== begin semantic patch =====
    // This adds an llseek= method to all file operations,
    // as a preparation for making no_llseek the default.
    //
    // The rules are
    // - use no_llseek explicitly if we do nonseekable_open
    // - use seq_lseek for sequential files
    // - use default_llseek if we know we access f_pos
    // - use noop_llseek if we know we don't access f_pos,
    //   but we still want to allow users to call lseek
    //
    @ open1 exists @
    identifier nested_open;
    @@
    nested_open(...)
    {
    <+...
    nonseekable_open(...)
    ...+>
    }
    
    @ open exists@
    identifier open_f;
    identifier i, f;
    identifier open1.nested_open;
    @@
    int open_f(struct inode *i, struct file *f)
    {
    <+...
    (
    nonseekable_open(...)
    |
    nested_open(...)
    )
    ...+>
    }
    
    @ read disable optional_qualifier exists @
    identifier read_f;
    identifier f, p, s, off;
    type ssize_t, size_t, loff_t;
    expression E;
    identifier func;
    @@
    ssize_t read_f(struct file *f, char *p, size_t s, loff_t *off)
    {
    <+...
    (
       *off = E
    |
       *off += E
    |
       func(..., off, ...)
    |
       E = *off
    )
    ...+>
    }
    
    @ read_no_fpos disable optional_qualifier exists @
    identifier read_f;
    identifier f, p, s, off;
    type ssize_t, size_t, loff_t;
    @@
    ssize_t read_f(struct file *f, char *p, size_t s, loff_t *off)
    {
    ... when != off
    }
    
    @ write @
    identifier write_f;
    identifier f, p, s, off;
    type ssize_t, size_t, loff_t;
    expression E;
    identifier func;
    @@
    ssize_t write_f(struct file *f, const char *p, size_t s, loff_t *off)
    {
    <+...
    (
      *off = E
    |
      *off += E
    |
      func(..., off, ...)
    |
      E = *off
    )
    ...+>
    }
    
    @ write_no_fpos @
    identifier write_f;
    identifier f, p, s, off;
    type ssize_t, size_t, loff_t;
    @@
    ssize_t write_f(struct file *f, const char *p, size_t s, loff_t *off)
    {
    ... when != off
    }
    
    @ fops0 @
    identifier fops;
    @@
    struct file_operations fops = {
     ...
    };
    
    @ has_llseek depends on fops0 @
    identifier fops0.fops;
    identifier llseek_f;
    @@
    struct file_operations fops = {
    ...
     .llseek = llseek_f,
    ...
    };
    
    @ has_read depends on fops0 @
    identifier fops0.fops;
    identifier read_f;
    @@
    struct file_operations fops = {
    ...
     .read = read_f,
    ...
    };
    
    @ has_write depends on fops0 @
    identifier fops0.fops;
    identifier write_f;
    @@
    struct file_operations fops = {
    ...
     .write = write_f,
    ...
    };
    
    @ has_open depends on fops0 @
    identifier fops0.fops;
    identifier open_f;
    @@
    struct file_operations fops = {
    ...
     .open = open_f,
    ...
    };
    
    // use no_llseek if we call nonseekable_open
    ////////////////////////////////////////////
    @ nonseekable1 depends on !has_llseek && has_open @
    identifier fops0.fops;
    identifier nso ~= "nonseekable_open";
    @@
    struct file_operations fops = {
    ...  .open = nso, ...
    +.llseek = no_llseek, /* nonseekable */
    };
    
    @ nonseekable2 depends on !has_llseek @
    identifier fops0.fops;
    identifier open.open_f;
    @@
    struct file_operations fops = {
    ...  .open = open_f, ...
    +.llseek = no_llseek, /* open uses nonseekable */
    };
    
    // use seq_lseek for sequential files
    /////////////////////////////////////
    @ seq depends on !has_llseek @
    identifier fops0.fops;
    identifier sr ~= "seq_read";
    @@
    struct file_operations fops = {
    ...  .read = sr, ...
    +.llseek = seq_lseek, /* we have seq_read */
    };
    
    // use default_llseek if there is a readdir
    ///////////////////////////////////////////
    @ fops1 depends on !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier readdir_e;
    @@
    // any other fop is used that changes pos
    struct file_operations fops = {
    ... .readdir = readdir_e, ...
    +.llseek = default_llseek, /* readdir is present */
    };
    
    // use default_llseek if at least one of read/write touches f_pos
    /////////////////////////////////////////////////////////////////
    @ fops2 depends on !fops1 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier read.read_f;
    @@
    // read fops use offset
    struct file_operations fops = {
    ... .read = read_f, ...
    +.llseek = default_llseek, /* read accesses f_pos */
    };
    
    @ fops3 depends on !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier write.write_f;
    @@
    // write fops use offset
    struct file_operations fops = {
    ... .write = write_f, ...
    +       .llseek = default_llseek, /* write accesses f_pos */
    };
    
    // Use noop_llseek if neither read nor write accesses f_pos
    ///////////////////////////////////////////////////////////
    
    @ fops4 depends on !fops1 && !fops2 && !fops3 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier read_no_fpos.read_f;
    identifier write_no_fpos.write_f;
    @@
    // write fops use offset
    struct file_operations fops = {
    ...
     .write = write_f,
     .read = read_f,
    ...
    +.llseek = noop_llseek, /* read and write both use no f_pos */
    };
    
    @ depends on has_write && !has_read && !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier write_no_fpos.write_f;
    @@
    struct file_operations fops = {
    ... .write = write_f, ...
    +.llseek = noop_llseek, /* write uses no f_pos */
    };
    
    @ depends on has_read && !has_write && !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier read_no_fpos.read_f;
    @@
    struct file_operations fops = {
    ... .read = read_f, ...
    +.llseek = noop_llseek, /* read uses no f_pos */
    };
    
    @ depends on !has_read && !has_write && !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    @@
    struct file_operations fops = {
    ...
    +.llseek = noop_llseek, /* no read or write fn */
    };
    ===== End semantic patch =====
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Cc: Julia Lawall <julia@diku.dk>
    Cc: Christoph Hellwig <hch@infradead.org>

diff --git a/drivers/watchdog/ep93xx_wdt.c b/drivers/watchdog/ep93xx_wdt.c
index 59359c9a5e01..726b7df61fd0 100644
--- a/drivers/watchdog/ep93xx_wdt.c
+++ b/drivers/watchdog/ep93xx_wdt.c
@@ -188,6 +188,7 @@ static const struct file_operations ep93xx_wdt_fops = {
 	.unlocked_ioctl	= ep93xx_wdt_ioctl,
 	.open		= ep93xx_wdt_open,
 	.release	= ep93xx_wdt_release,
+	.llseek		= no_llseek,
 };
 
 static struct miscdevice ep93xx_wdt_miscdev = {

commit d557f651b3617b46ed18d5bac48a851df1dbf684
Author: Wim Van Sebroeck <wim@iguana.be>
Date:   Mon May 3 08:58:56 2010 +0000

    watchdog: ep93xx_wdt.c fix default timout value in MODULE_PARM_DESC string.
    
    The WATCHDOG_TIMEOUT macro does not exist. The default timeout value is WDT_TIMEOUT.
    Fix the MODULE_PARM_DESC so that the code can compile again.
    
    reported-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/drivers/watchdog/ep93xx_wdt.c b/drivers/watchdog/ep93xx_wdt.c
index 88ed54e50f74..59359c9a5e01 100644
--- a/drivers/watchdog/ep93xx_wdt.c
+++ b/drivers/watchdog/ep93xx_wdt.c
@@ -244,7 +244,7 @@ MODULE_PARM_DESC(nowayout, "Watchdog cannot be stopped once started");
 module_param(timeout, int, 0);
 MODULE_PARM_DESC(timeout,
 	"Watchdog timeout in seconds. (1<=timeout<=3600, default="
-				__MODULE_STRING(WATCHDOG_TIMEOUT) ")");
+				__MODULE_STRING(WDT_TIMEOUT) ")");
 
 MODULE_AUTHOR("Ray Lehtiniemi <rayl@mail.com>,"
 		"Alessandro Zummo <a.zummo@towertech.it>");

commit 42747d712de56cf2087b702d2ad90af114c53138
Author: Wim Van Sebroeck <wim@iguana.be>
Date:   Sat Dec 26 18:55:22 2009 +0000

    [WATCHDOG] watchdog_info constify
    
    make the watchdog_info struct const where possible.
    
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/drivers/watchdog/ep93xx_wdt.c b/drivers/watchdog/ep93xx_wdt.c
index cdd55e0d09f8..88ed54e50f74 100644
--- a/drivers/watchdog/ep93xx_wdt.c
+++ b/drivers/watchdog/ep93xx_wdt.c
@@ -131,7 +131,7 @@ ep93xx_wdt_write(struct file *file, const char __user *data, size_t len,
 	return len;
 }
 
-static struct watchdog_info ident = {
+static const struct watchdog_info ident = {
 	.options = WDIOF_CARDRESET | WDIOF_MAGICCLOSE,
 	.identity = "EP93xx Watchdog",
 };

commit 2653d1d7f0284f3b68f25dafa208d0a013f7e9db
Author: Ryan Mallon <ryan@bluewatersys.com>
Date:   Wed Jul 15 21:33:22 2009 +0100

    [ARM] 5606/1: Fix ep93xx watchdog driver headers
    
    Fix a number of build errors in the ep93xx watchdog driver due
    to missing io.h
    
    Signed-off-by: Ryan Mallon <ryan@bluewatersys.com>
    Acked-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/watchdog/ep93xx_wdt.c b/drivers/watchdog/ep93xx_wdt.c
index e9f950ff86ea..cdd55e0d09f8 100644
--- a/drivers/watchdog/ep93xx_wdt.c
+++ b/drivers/watchdog/ep93xx_wdt.c
@@ -29,6 +29,7 @@
 #include <linux/watchdog.h>
 #include <linux/timer.h>
 #include <linux/uaccess.h>
+#include <linux/io.h>
 #include <mach/hardware.h>
 
 #define WDT_VERSION	"0.3"

commit 097d9eb537ff4d88b74c3fe67392e27c478ca3c5
Merge: c41107c2d4fd aeee90dfa018
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Fri Aug 8 17:33:47 2008 +0100

    Merge Linus' latest into master
    
    Conflicts:
    
            drivers/watchdog/at91rm9200_wdt.c
            drivers/watchdog/davinci_wdt.c
            drivers/watchdog/ep93xx_wdt.c
            drivers/watchdog/ixp2000_wdt.c
            drivers/watchdog/ixp4xx_wdt.c
            drivers/watchdog/ks8695_wdt.c
            drivers/watchdog/omap_wdt.c
            drivers/watchdog/pnx4008_wdt.c
            drivers/watchdog/sa1100_wdt.c
            drivers/watchdog/wdt285.c

commit a09e64fbc0094e3073dbb09c3b4bfe4ab669244b
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Tue Aug 5 16:14:15 2008 +0100

    [ARM] Move include/asm-arm/arch-* to arch/arm/*/include/mach
    
    This just leaves include/asm-arm/plat-* to deal with.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/watchdog/ep93xx_wdt.c b/drivers/watchdog/ep93xx_wdt.c
index 7476844dbac3..af8ef14c0e4c 100644
--- a/drivers/watchdog/ep93xx_wdt.c
+++ b/drivers/watchdog/ep93xx_wdt.c
@@ -29,7 +29,7 @@
 #include <linux/watchdog.h>
 #include <linux/timer.h>
 
-#include <asm/arch/hardware.h>
+#include <mach/hardware.h>
 #include <asm/uaccess.h>
 
 #define WDT_VERSION	"0.3"

commit be509729356b7433f73df2b9a966674a437fbbc1
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Mon Aug 4 10:41:28 2008 +0100

    [ARM] Remove asm/hardware.h, use asm/arch/hardware.h instead
    
    Remove includes of asm/hardware.h in addition to asm/arch/hardware.h.
    Then, since asm/hardware.h only exists to include asm/arch/hardware.h,
    update everything to directly include asm/arch/hardware.h and remove
    asm/hardware.h.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/watchdog/ep93xx_wdt.c b/drivers/watchdog/ep93xx_wdt.c
index 0e4787a0bb87..7476844dbac3 100644
--- a/drivers/watchdog/ep93xx_wdt.c
+++ b/drivers/watchdog/ep93xx_wdt.c
@@ -29,7 +29,7 @@
 #include <linux/watchdog.h>
 #include <linux/timer.h>
 
-#include <asm/hardware.h>
+#include <asm/arch/hardware.h>
 #include <asm/uaccess.h>
 
 #define WDT_VERSION	"0.3"

commit 0c06090c9472db0525cb6fe229c3bea33bbbbb3c
Author: Wim Van Sebroeck <wim@iguana.be>
Date:   Fri Jul 18 11:41:17 2008 +0000

    [WATCHDOG] Coding style - Indentation - part 2
    
    This brings the watchdog drivers into line with coding style.
    This patch takes cares of the indentation as described in chapter 1.
    Main changes:
    * Re-structure the ioctl switch call for all drivers as follows:
            switch (cmd) {
            case WDIOC_GETSUPPORT:
            case WDIOC_GETSTATUS:
            case WDIOC_GETBOOTSTATUS:
            case WDIOC_GETTEMP:
            case WDIOC_SETOPTIONS:
            case WDIOC_KEEPALIVE:
            case WDIOC_SETTIMEOUT:
            case WDIOC_GETTIMEOUT:
            case WDIOC_GETTIMELEFT:
            default:
            }
    
    This to make the migration from the drivers to the uniform watchdog
    device driver easier in the future.
    
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/drivers/watchdog/ep93xx_wdt.c b/drivers/watchdog/ep93xx_wdt.c
index cdcdd11173a7..07b74a768922 100644
--- a/drivers/watchdog/ep93xx_wdt.c
+++ b/drivers/watchdog/ep93xx_wdt.c
@@ -155,15 +155,15 @@ static long ep93xx_wdt_ioctl(struct file *file,
 		ret = put_user(boot_status, (int __user *)arg);
 		break;
 
-	case WDIOC_GETTIMEOUT:
-		/* actually, it is 0.250 seconds.... */
-		ret = put_user(1, (int __user *)arg);
-		break;
-
 	case WDIOC_KEEPALIVE:
 		wdt_keepalive();
 		ret = 0;
 		break;
+
+	case WDIOC_GETTIMEOUT:
+		/* actually, it is 0.250 seconds.... */
+		ret = put_user(1, (int __user *)arg);
+		break;
 	}
 	return ret;
 }

commit f339e2ac9d65656e6d18c92b1ddc4a7801373318
Author: Alan Cox <alan@redhat.com>
Date:   Mon May 19 14:05:35 2008 +0100

    [WATCHDOG 09/57] ep93xx_wdt: unlocked_ioctl
    
    Review and switch to unlocked_ioctl
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/drivers/watchdog/ep93xx_wdt.c b/drivers/watchdog/ep93xx_wdt.c
index 0e4787a0bb87..cdcdd11173a7 100644
--- a/drivers/watchdog/ep93xx_wdt.c
+++ b/drivers/watchdog/ep93xx_wdt.c
@@ -28,9 +28,9 @@
 #include <linux/miscdevice.h>
 #include <linux/watchdog.h>
 #include <linux/timer.h>
+#include <linux/uaccess.h>
 
 #include <asm/hardware.h>
-#include <asm/uaccess.h>
 
 #define WDT_VERSION	"0.3"
 #define PFX		"ep93xx_wdt: "
@@ -136,9 +136,8 @@ static struct watchdog_info ident = {
 	.identity = "EP93xx Watchdog",
 };
 
-static int
-ep93xx_wdt_ioctl(struct inode *inode, struct file *file, unsigned int cmd,
-		 unsigned long arg)
+static long ep93xx_wdt_ioctl(struct file *file,
+					unsigned int cmd, unsigned long arg)
 {
 	int ret = -ENOTTY;
 
@@ -174,8 +173,8 @@ static int ep93xx_wdt_release(struct inode *inode, struct file *file)
 	if (test_bit(WDT_OK_TO_CLOSE, &wdt_status))
 		wdt_shutdown();
 	else
-		printk(KERN_CRIT PFX "Device closed unexpectedly - "
-			"timer will not stop\n");
+		printk(KERN_CRIT PFX
+			"Device closed unexpectedly - timer will not stop\n");
 
 	clear_bit(WDT_IN_USE, &wdt_status);
 	clear_bit(WDT_OK_TO_CLOSE, &wdt_status);
@@ -186,7 +185,7 @@ static int ep93xx_wdt_release(struct inode *inode, struct file *file)
 static const struct file_operations ep93xx_wdt_fops = {
 	.owner		= THIS_MODULE,
 	.write		= ep93xx_wdt_write,
-	.ioctl		= ep93xx_wdt_ioctl,
+	.unlocked_ioctl	= ep93xx_wdt_ioctl,
 	.open		= ep93xx_wdt_open,
 	.release	= ep93xx_wdt_release,
 };
@@ -243,7 +242,9 @@ module_param(nowayout, int, 0);
 MODULE_PARM_DESC(nowayout, "Watchdog cannot be stopped once started");
 
 module_param(timeout, int, 0);
-MODULE_PARM_DESC(timeout, "Watchdog timeout in seconds. (1<=timeout<=3600, default=" __MODULE_STRING(WATCHDOG_TIMEOUT) ")");
+MODULE_PARM_DESC(timeout,
+	"Watchdog timeout in seconds. (1<=timeout<=3600, default="
+				__MODULE_STRING(WATCHDOG_TIMEOUT) ")");
 
 MODULE_AUTHOR("Ray Lehtiniemi <rayl@mail.com>,"
 		"Alessandro Zummo <a.zummo@towertech.it>");

commit b7e04f8c61a46d742de23af5d7ca2b41b33e40ac
Author: Wim Van Sebroeck <wim@iguana.be>
Date:   Fri Aug 17 08:38:02 2007 +0000

    mv watchdog tree under drivers
    
    move watchdog tree from drivers/char/watchdog to drivers/watchdog.
    
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/drivers/watchdog/ep93xx_wdt.c b/drivers/watchdog/ep93xx_wdt.c
new file mode 100644
index 000000000000..0e4787a0bb87
--- /dev/null
+++ b/drivers/watchdog/ep93xx_wdt.c
@@ -0,0 +1,253 @@
+/*
+ * Watchdog driver for Cirrus Logic EP93xx family of devices.
+ *
+ * Copyright (c) 2004 Ray Lehtiniemi
+ * Copyright (c) 2006 Tower Technologies
+ * Based on ep93xx driver, bits from alim7101_wdt.c
+ *
+ * Authors: Ray Lehtiniemi <rayl@mail.com>,
+ *	Alessandro Zummo <a.zummo@towertech.it>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ *
+ * This watchdog fires after 250msec, which is a too short interval
+ * for us to rely on the user space daemon alone. So we ping the
+ * wdt each ~200msec and eventually stop doing it if the user space
+ * daemon dies.
+ *
+ * TODO:
+ *
+ *	- Test last reset from watchdog status
+ *	- Add a few missing ioctls
+ */
+
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/miscdevice.h>
+#include <linux/watchdog.h>
+#include <linux/timer.h>
+
+#include <asm/hardware.h>
+#include <asm/uaccess.h>
+
+#define WDT_VERSION	"0.3"
+#define PFX		"ep93xx_wdt: "
+
+/* default timeout (secs) */
+#define WDT_TIMEOUT 30
+
+static int nowayout = WATCHDOG_NOWAYOUT;
+static int timeout = WDT_TIMEOUT;
+
+static struct timer_list timer;
+static unsigned long next_heartbeat;
+static unsigned long wdt_status;
+static unsigned long boot_status;
+
+#define WDT_IN_USE		0
+#define WDT_OK_TO_CLOSE		1
+
+#define EP93XX_WDT_REG(x)	(EP93XX_WATCHDOG_BASE + (x))
+#define EP93XX_WDT_WATCHDOG	EP93XX_WDT_REG(0x00)
+#define EP93XX_WDT_WDSTATUS	EP93XX_WDT_REG(0x04)
+
+/* reset the wdt every ~200ms */
+#define WDT_INTERVAL (HZ/5)
+
+static void wdt_enable(void)
+{
+	__raw_writew(0xaaaa, EP93XX_WDT_WATCHDOG);
+}
+
+static void wdt_disable(void)
+{
+	__raw_writew(0xaa55, EP93XX_WDT_WATCHDOG);
+}
+
+static inline void wdt_ping(void)
+{
+	__raw_writew(0x5555, EP93XX_WDT_WATCHDOG);
+}
+
+static void wdt_startup(void)
+{
+	next_heartbeat = jiffies + (timeout * HZ);
+
+	wdt_enable();
+	mod_timer(&timer, jiffies + WDT_INTERVAL);
+}
+
+static void wdt_shutdown(void)
+{
+	del_timer_sync(&timer);
+	wdt_disable();
+}
+
+static void wdt_keepalive(void)
+{
+	/* user land ping */
+	next_heartbeat = jiffies + (timeout * HZ);
+}
+
+static int ep93xx_wdt_open(struct inode *inode, struct file *file)
+{
+	if (test_and_set_bit(WDT_IN_USE, &wdt_status))
+		return -EBUSY;
+
+	clear_bit(WDT_OK_TO_CLOSE, &wdt_status);
+
+	wdt_startup();
+
+	return nonseekable_open(inode, file);
+}
+
+static ssize_t
+ep93xx_wdt_write(struct file *file, const char __user *data, size_t len,
+		 loff_t *ppos)
+{
+	if (len) {
+		if (!nowayout) {
+			size_t i;
+
+			clear_bit(WDT_OK_TO_CLOSE, &wdt_status);
+
+			for (i = 0; i != len; i++) {
+				char c;
+
+				if (get_user(c, data + i))
+					return -EFAULT;
+
+				if (c == 'V')
+					set_bit(WDT_OK_TO_CLOSE, &wdt_status);
+				else
+					clear_bit(WDT_OK_TO_CLOSE, &wdt_status);
+			}
+		}
+		wdt_keepalive();
+	}
+
+	return len;
+}
+
+static struct watchdog_info ident = {
+	.options = WDIOF_CARDRESET | WDIOF_MAGICCLOSE,
+	.identity = "EP93xx Watchdog",
+};
+
+static int
+ep93xx_wdt_ioctl(struct inode *inode, struct file *file, unsigned int cmd,
+		 unsigned long arg)
+{
+	int ret = -ENOTTY;
+
+	switch (cmd) {
+	case WDIOC_GETSUPPORT:
+		ret = copy_to_user((struct watchdog_info __user *)arg, &ident,
+				sizeof(ident)) ? -EFAULT : 0;
+		break;
+
+	case WDIOC_GETSTATUS:
+		ret = put_user(0, (int __user *)arg);
+		break;
+
+	case WDIOC_GETBOOTSTATUS:
+		ret = put_user(boot_status, (int __user *)arg);
+		break;
+
+	case WDIOC_GETTIMEOUT:
+		/* actually, it is 0.250 seconds.... */
+		ret = put_user(1, (int __user *)arg);
+		break;
+
+	case WDIOC_KEEPALIVE:
+		wdt_keepalive();
+		ret = 0;
+		break;
+	}
+	return ret;
+}
+
+static int ep93xx_wdt_release(struct inode *inode, struct file *file)
+{
+	if (test_bit(WDT_OK_TO_CLOSE, &wdt_status))
+		wdt_shutdown();
+	else
+		printk(KERN_CRIT PFX "Device closed unexpectedly - "
+			"timer will not stop\n");
+
+	clear_bit(WDT_IN_USE, &wdt_status);
+	clear_bit(WDT_OK_TO_CLOSE, &wdt_status);
+
+	return 0;
+}
+
+static const struct file_operations ep93xx_wdt_fops = {
+	.owner		= THIS_MODULE,
+	.write		= ep93xx_wdt_write,
+	.ioctl		= ep93xx_wdt_ioctl,
+	.open		= ep93xx_wdt_open,
+	.release	= ep93xx_wdt_release,
+};
+
+static struct miscdevice ep93xx_wdt_miscdev = {
+	.minor		= WATCHDOG_MINOR,
+	.name		= "watchdog",
+	.fops		= &ep93xx_wdt_fops,
+};
+
+static void ep93xx_timer_ping(unsigned long data)
+{
+	if (time_before(jiffies, next_heartbeat))
+		wdt_ping();
+
+	/* Re-set the timer interval */
+	mod_timer(&timer, jiffies + WDT_INTERVAL);
+}
+
+static int __init ep93xx_wdt_init(void)
+{
+	int err;
+
+	err = misc_register(&ep93xx_wdt_miscdev);
+
+	boot_status = __raw_readl(EP93XX_WDT_WATCHDOG) & 0x01 ? 1 : 0;
+
+	printk(KERN_INFO PFX "EP93XX watchdog, driver version "
+		WDT_VERSION "%s\n",
+		(__raw_readl(EP93XX_WDT_WATCHDOG) & 0x08)
+		? " (nCS1 disable detected)" : "");
+
+	if (timeout < 1 || timeout > 3600) {
+		timeout = WDT_TIMEOUT;
+		printk(KERN_INFO PFX
+			"timeout value must be 1<=x<=3600, using %d\n",
+			timeout);
+	}
+
+	setup_timer(&timer, ep93xx_timer_ping, 1);
+	return err;
+}
+
+static void __exit ep93xx_wdt_exit(void)
+{
+	wdt_shutdown();
+	misc_deregister(&ep93xx_wdt_miscdev);
+}
+
+module_init(ep93xx_wdt_init);
+module_exit(ep93xx_wdt_exit);
+
+module_param(nowayout, int, 0);
+MODULE_PARM_DESC(nowayout, "Watchdog cannot be stopped once started");
+
+module_param(timeout, int, 0);
+MODULE_PARM_DESC(timeout, "Watchdog timeout in seconds. (1<=timeout<=3600, default=" __MODULE_STRING(WATCHDOG_TIMEOUT) ")");
+
+MODULE_AUTHOR("Ray Lehtiniemi <rayl@mail.com>,"
+		"Alessandro Zummo <a.zummo@towertech.it>");
+MODULE_DESCRIPTION("EP93xx Watchdog");
+MODULE_LICENSE("GPL");
+MODULE_VERSION(WDT_VERSION);
+MODULE_ALIAS_MISCDEV(WATCHDOG_MINOR);
