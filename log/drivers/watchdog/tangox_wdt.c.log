commit c838a3ae614ba324f9e1d762440a6e031ee5bed6
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Tue Apr 9 10:24:01 2019 -0700

    watchdog: tangox_wdt: Convert to use device managed functions and other improvements
    
    Use device managed functions to simplify error handling, reduce
    source code size, improve readability, and reduce the likelyhood of bugs.
    Other improvements as listed below.
    
    The conversion was done automatically with coccinelle using the
    following semantic patches. The semantic patches and the scripts
    used to generate this commit log are available at
    https://github.com/groeck/coccinelle-patches
    
    - Drop assignments to otherwise unused variables
    - Drop unnecessary braces around conditional return statements
    - Drop empty remove function
    - Use devm_add_action_or_reset() for calls to clk_disable_unprepare
    - Replace stop on remove with call to watchdog_stop_on_unregister()
    - Use devm_watchdog_register_driver() to register watchdog device
    
    Cc: Marc Gonzalez <marc.w.gonzalez@free.fr>
    Cc: Mans Rullgard <mans@mansr.com>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Acked-by: Mans Rullgard <mans@mansr.com>
    Signed-off-by: Wim Van Sebroeck <wim@linux-watchdog.org>

diff --git a/drivers/watchdog/tangox_wdt.c b/drivers/watchdog/tangox_wdt.c
index 16611fe0d9d1..1afb0e9d808c 100644
--- a/drivers/watchdog/tangox_wdt.c
+++ b/drivers/watchdog/tangox_wdt.c
@@ -108,6 +108,11 @@ static const struct watchdog_ops tangox_wdt_ops = {
 	.restart	= tangox_wdt_restart,
 };
 
+static void tangox_clk_disable_unprepare(void *data)
+{
+	clk_disable_unprepare(data);
+}
+
 static int tangox_wdt_probe(struct platform_device *pdev)
 {
 	struct tangox_wdt_device *dev;
@@ -129,12 +134,14 @@ static int tangox_wdt_probe(struct platform_device *pdev)
 	err = clk_prepare_enable(dev->clk);
 	if (err)
 		return err;
+	err = devm_add_action_or_reset(&pdev->dev,
+				       tangox_clk_disable_unprepare, dev->clk);
+	if (err)
+		return err;
 
 	dev->clk_rate = clk_get_rate(dev->clk);
-	if (!dev->clk_rate) {
-		err = -EINVAL;
-		goto err;
-	}
+	if (!dev->clk_rate)
+		return -EINVAL;
 
 	dev->wdt.parent = &pdev->dev;
 	dev->wdt.info = &tangox_wdt_info;
@@ -168,30 +175,15 @@ static int tangox_wdt_probe(struct platform_device *pdev)
 
 	watchdog_set_restart_priority(&dev->wdt, 128);
 
-	err = watchdog_register_device(&dev->wdt);
+	watchdog_stop_on_unregister(&dev->wdt);
+	err = devm_watchdog_register_device(&pdev->dev, &dev->wdt);
 	if (err)
-		goto err;
+		return err;
 
 	platform_set_drvdata(pdev, dev);
 
 	dev_info(&pdev->dev, "SMP86xx/SMP87xx watchdog registered\n");
 
-	return 0;
-
- err:
-	clk_disable_unprepare(dev->clk);
-	return err;
-}
-
-static int tangox_wdt_remove(struct platform_device *pdev)
-{
-	struct tangox_wdt_device *dev = platform_get_drvdata(pdev);
-
-	tangox_wdt_stop(&dev->wdt);
-	clk_disable_unprepare(dev->clk);
-
-	watchdog_unregister_device(&dev->wdt);
-
 	return 0;
 }
 
@@ -204,7 +196,6 @@ MODULE_DEVICE_TABLE(of, tangox_wdt_dt_ids);
 
 static struct platform_driver tangox_wdt_driver = {
 	.probe	= tangox_wdt_probe,
-	.remove	= tangox_wdt_remove,
 	.driver	= {
 		.name		= "tangox-wdt",
 		.of_match_table	= tangox_wdt_dt_ids,

commit 0f0a6a285ec0c7b0ac0b532f87a784605322f9ce
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Tue Apr 2 12:01:53 2019 -0700

    watchdog: Convert to use devm_platform_ioremap_resource
    
    Use devm_platform_ioremap_resource to reduce source code size,
    improve readability, and reduce the likelyhood of bugs.
    
    The conversion was done automatically with coccinelle using the
    following semantic patch.
    
    @r@
    identifier res, pdev;
    expression a;
    expression index;
    expression e;
    @@
    
    <+...
    - res = platform_get_resource(pdev, IORESOURCE_MEM, index);
    - a = devm_ioremap_resource(e, res);
    + a = devm_platform_ioremap_resource(pdev, index);
    ...+>
    
    @depends on r@
    identifier r.res;
    @@
    - struct resource *res;
      ... when != res
    
    @@
    identifier res, pdev;
    expression index;
    expression a;
    @@
    - struct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, index);
    - a = devm_ioremap_resource(&pdev->dev, res);
    + a = devm_platform_ioremap_resource(pdev, index);
    
    Cc: Joel Stanley <joel@jms.id.au>
    Cc: Nicolas Ferre <nicolas.ferre@microchip.com>
    Cc: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Cc: Florian Fainelli <f.fainelli@gmail.com>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Baruch Siach <baruch@tkos.co.il>
    Cc: Keguang Zhang <keguang.zhang@gmail.com>
    Cc: Vladimir Zapolskiy <vz@mleia.com>
    Cc: Kevin Hilman <khilman@baylibre.com>
    Cc: Matthias Brugger <matthias.bgg@gmail.com>
    Cc: Avi Fishman <avifishman70@gmail.com>
    Cc: Nancy Yuen <yuenn@google.com>
    Cc: Brendan Higgins <brendanhiggins@google.com>
    Cc: Wan ZongShun <mcuos.com@gmail.com>
    Cc: Michal Simek <michal.simek@xilinx.com>
    Cc: Sylvain Lemieux <slemieux.tyco@gmail.com>
    Cc: Kukjin Kim <kgene@kernel.org>
    Cc: Barry Song <baohua@kernel.org>
    Cc: Orson Zhai <orsonzhai@gmail.com>
    Cc: Patrice Chotard <patrice.chotard@st.com>
    Cc: Maxime Coquelin <mcoquelin.stm32@gmail.com>
    Cc: Maxime Ripard <maxime.ripard@bootlin.com>
    Cc: Chen-Yu Tsai <wens@csie.org>
    Cc: Marc Gonzalez <marc.w.gonzalez@free.fr>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Cc: Shawn Guo <shawnguo@kernel.org>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Acked-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Tested-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Acked-by: Joel Stanley <joel@jms.id.au>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Maxime Ripard <maxime.ripard@bootlin.com>
    Acked-by: Michal Simek <michal.simek@xilinx.com> (cadence/xilinx wdts)
    Acked-by: Thierry Reding <treding@nvidia.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Acked-by: Patrice Chotard <patrice.chotard@st.com>
    Acked-by: Vladimir Zapolskiy <vz@mleia.com>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@linux-watchdog.org>

diff --git a/drivers/watchdog/tangox_wdt.c b/drivers/watchdog/tangox_wdt.c
index d0b53f3c0d17..16611fe0d9d1 100644
--- a/drivers/watchdog/tangox_wdt.c
+++ b/drivers/watchdog/tangox_wdt.c
@@ -111,7 +111,6 @@ static const struct watchdog_ops tangox_wdt_ops = {
 static int tangox_wdt_probe(struct platform_device *pdev)
 {
 	struct tangox_wdt_device *dev;
-	struct resource *res;
 	u32 config;
 	int err;
 
@@ -119,8 +118,7 @@ static int tangox_wdt_probe(struct platform_device *pdev)
 	if (!dev)
 		return -ENOMEM;
 
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	dev->base = devm_ioremap_resource(&pdev->dev, res);
+	dev->base = devm_platform_ioremap_resource(pdev, 0);
 	if (IS_ERR(dev->base))
 		return PTR_ERR(dev->base);
 

commit ac3167257b9fe16c9426c2087ead1c9f1b0992b1
Author: Randy Dunlap <rdunlap@infradead.org>
Date:   Tue Jun 19 22:47:28 2018 -0700

    headers: separate linux/mod_devicetable.h from linux/platform_device.h
    
    At over 4000 #includes, <linux/platform_device.h> is the 9th most
    #included header file in the Linux kernel.  It does not need
    <linux/mod_devicetable.h>, so drop that header and explicitly add
    <linux/mod_devicetable.h> to source files that need it.
    
       4146 #include <linux/platform_device.h>
    
    After this patch, there are 225 files that use <linux/mod_devicetable.h>,
    for a reduction of around 3900 times that <linux/mod_devicetable.h>
    does not have to be read & parsed.
    
        225 #include <linux/mod_devicetable.h>
    
    This patch was build-tested on 20 different arch-es.
    
    It also makes these drivers SubmitChecklist#1 compliant.
    
    Signed-off-by: Randy Dunlap <rdunlap@infradead.org>
    Reported-by: kbuild test robot <lkp@intel.com> # drivers/media/platform/vimc/
    Reported-by: kbuild test robot <lkp@intel.com> # drivers/pinctrl/pinctrl-u300.c
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/watchdog/tangox_wdt.c b/drivers/watchdog/tangox_wdt.c
index b1de8297fa40..d0b53f3c0d17 100644
--- a/drivers/watchdog/tangox_wdt.c
+++ b/drivers/watchdog/tangox_wdt.c
@@ -11,6 +11,7 @@
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/moduleparam.h>
+#include <linux/mod_devicetable.h>
 #include <linux/platform_device.h>
 #include <linux/watchdog.h>
 

commit 2e62c4988bbf2b514aa7672c2ee5252531c7155f
Author: Marcus Folkesson <marcus.folkesson@gmail.com>
Date:   Fri Mar 16 16:14:11 2018 +0100

    watchdog: add SPDX identifiers for watchdog subsystem
    
    - Add SPDX identifier
    - Remove boiler plate license text
    - If MODULE_LICENSE and boiler plate does not match, go for boiler plate
      license
    
    Signed-off-by: Marcus Folkesson <marcus.folkesson@gmail.com>
    Acked-by: Adam Thomson <Adam.Thomson.Opensource@diasemi.com>
    Acked-by: Baruch Siach <baruch@tkos.co.il>
    Acked-by: Charles Keepax <ckeepax@opensource.cirrus.com>
    Acked-by: Keiji Hayashibara <hayashibara.keiji@socionext.com>
    Acked-by: Johannes Thumshirn <jth@kernel.org>
    Acked-by: Florian Fainelli <f.fainelli@gmail.com>
    Acked-by: Mans Rullgard <mans@mansr.com>
    Acked-by: Matthias Brugger <matthias.bgg@gmail.com>
    Acked-by: Michal Simek <michal.simek@xilinx.com>
    Acked-by: Neil Armstrong <narmstrong@baylibre.com>
    Acked-by: Nicolas Ferre <nicolas.ferre@microchip.com>
    Acked-by: Thierry Reding <treding@nvidia.com>
    Acked-by: Tomas Winkler <tomas.winkler@intel.com>
    Acked-by: Patrice Chotard <patrice.chotard@st.com>
    Acked-by: William Breathitt Gray <vilhelm.gray@gmail.com>
    Reviewed-by: Eric Anholt <eric@anholt.net>
    Reviewed-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/drivers/watchdog/tangox_wdt.c b/drivers/watchdog/tangox_wdt.c
index d5fcce062920..b1de8297fa40 100644
--- a/drivers/watchdog/tangox_wdt.c
+++ b/drivers/watchdog/tangox_wdt.c
@@ -1,11 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  *  Copyright (C) 2015 Mans Rullgard <mans@mansr.com>
  *  SMP86xx/SMP87xx Watchdog driver
- *
- *  This program is free software; you can redistribute it and/or modify it
- *  under  the terms of the GNU General  Public License as published by the
- *  Free Software Foundation;  either version 2 of the License, or (at your
- *  option) any later version.
  */
 
 #include <linux/bitops.h>

commit 0397c5db1d3174a553da674bb779007cc62cc241
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Wed Jan 4 12:28:01 2017 -0800

    watchdog: tangox: Use watchdog core to install restart handler
    
    Use the infrastructure provided by the watchdog core to install
    the restart handler.
    
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>

diff --git a/drivers/watchdog/tangox_wdt.c b/drivers/watchdog/tangox_wdt.c
index 202c4b9cc921..d5fcce062920 100644
--- a/drivers/watchdog/tangox_wdt.c
+++ b/drivers/watchdog/tangox_wdt.c
@@ -15,9 +15,7 @@
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/moduleparam.h>
-#include <linux/notifier.h>
 #include <linux/platform_device.h>
-#include <linux/reboot.h>
 #include <linux/watchdog.h>
 
 #define DEFAULT_TIMEOUT 30
@@ -47,7 +45,6 @@ struct tangox_wdt_device {
 	void __iomem *base;
 	unsigned long clk_rate;
 	struct clk *clk;
-	struct notifier_block restart;
 };
 
 static int tangox_wdt_set_timeout(struct watchdog_device *wdt,
@@ -96,24 +93,24 @@ static const struct watchdog_info tangox_wdt_info = {
 	.identity = "tangox watchdog",
 };
 
+static int tangox_wdt_restart(struct watchdog_device *wdt,
+			      unsigned long action, void *data)
+{
+	struct tangox_wdt_device *dev = watchdog_get_drvdata(wdt);
+
+	writel(1, dev->base + WD_COUNTER);
+
+	return 0;
+}
+
 static const struct watchdog_ops tangox_wdt_ops = {
 	.start		= tangox_wdt_start,
 	.stop		= tangox_wdt_stop,
 	.set_timeout	= tangox_wdt_set_timeout,
 	.get_timeleft	= tangox_wdt_get_timeleft,
+	.restart	= tangox_wdt_restart,
 };
 
-static int tangox_wdt_restart(struct notifier_block *nb, unsigned long action,
-			      void *data)
-{
-	struct tangox_wdt_device *dev =
-		container_of(nb, struct tangox_wdt_device, restart);
-
-	writel(1, dev->base + WD_COUNTER);
-
-	return NOTIFY_DONE;
-}
-
 static int tangox_wdt_probe(struct platform_device *pdev)
 {
 	struct tangox_wdt_device *dev;
@@ -174,18 +171,14 @@ static int tangox_wdt_probe(struct platform_device *pdev)
 		tangox_wdt_start(&dev->wdt);
 	}
 
+	watchdog_set_restart_priority(&dev->wdt, 128);
+
 	err = watchdog_register_device(&dev->wdt);
 	if (err)
 		goto err;
 
 	platform_set_drvdata(pdev, dev);
 
-	dev->restart.notifier_call = tangox_wdt_restart;
-	dev->restart.priority = 128;
-	err = register_restart_handler(&dev->restart);
-	if (err)
-		dev_warn(&pdev->dev, "failed to register restart handler\n");
-
 	dev_info(&pdev->dev, "SMP86xx/SMP87xx watchdog registered\n");
 
 	return 0;
@@ -202,7 +195,6 @@ static int tangox_wdt_remove(struct platform_device *pdev)
 	tangox_wdt_stop(&dev->wdt);
 	clk_disable_unprepare(dev->clk);
 
-	unregister_restart_handler(&dev->restart);
 	watchdog_unregister_device(&dev->wdt);
 
 	return 0;

commit c7ef68c32265a396a4d977f896a11a4cebb0ace4
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Sun Jul 17 13:47:47 2016 -0700

    watchdog: tangox: Set max_hw_heartbeat_ms instead of max_timeout
    
    Setting max_hw_heartbeat_ms lets the watchdog core provide a virtual
    timeout if the timeout requested by user space is larger than the maximum
    hardware timeout. Also, it helps the watchdog core to provide heartbeats
    if the hardware watchdog is running while closed.
    
    Fixes: a3e376d26ace ("watchdog: tangox: Mark running watchdog correctly")
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/drivers/watchdog/tangox_wdt.c b/drivers/watchdog/tangox_wdt.c
index e7a5d0fc81d4..202c4b9cc921 100644
--- a/drivers/watchdog/tangox_wdt.c
+++ b/drivers/watchdog/tangox_wdt.c
@@ -149,7 +149,7 @@ static int tangox_wdt_probe(struct platform_device *pdev)
 	dev->wdt.ops = &tangox_wdt_ops;
 	dev->wdt.timeout = DEFAULT_TIMEOUT;
 	dev->wdt.min_timeout = 1;
-	dev->wdt.max_timeout = (U32_MAX - 1) / dev->clk_rate;
+	dev->wdt.max_hw_heartbeat_ms = (U32_MAX - 1) / dev->clk_rate;
 
 	watchdog_init_timeout(&dev->wdt, timeout, &pdev->dev);
 	watchdog_set_nowayout(&dev->wdt, nowayout);

commit a3e376d26ace6d823f7aa4c63476e7089a6196df
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Fri May 27 15:28:00 2016 -0700

    watchdog: tangox: Mark running watchdog correctly
    
    A running watchdog is marked with WDOG_HW_RUNNING, not with WDOG_ACTIVE.
    WDOG_ACTIVE indicates that the watchdog device has been opened from user
    space.
    
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/drivers/watchdog/tangox_wdt.c b/drivers/watchdog/tangox_wdt.c
index cfbed7e051b6..e7a5d0fc81d4 100644
--- a/drivers/watchdog/tangox_wdt.c
+++ b/drivers/watchdog/tangox_wdt.c
@@ -170,7 +170,7 @@ static int tangox_wdt_probe(struct platform_device *pdev)
 	 * already running.
 	 */
 	if (readl(dev->base + WD_COUNTER)) {
-		set_bit(WDOG_ACTIVE, &dev->wdt.status);
+		set_bit(WDOG_HW_RUNNING, &dev->wdt.status);
 		tangox_wdt_start(&dev->wdt);
 	}
 

commit 84b84bcf4f718b7b9f5296d4068025fea801a0e1
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Thu Mar 3 09:24:12 2016 +0100

    watchdog: tangox_wdt: test clock rate to avoid division by 0
    
    The clk API may return 0 on clk_get_rate, so we should check the result before
    using it as a divisor. For this, refactor the code to use a central
    error path.
    
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/drivers/watchdog/tangox_wdt.c b/drivers/watchdog/tangox_wdt.c
index 709c1ed6fd79..cfbed7e051b6 100644
--- a/drivers/watchdog/tangox_wdt.c
+++ b/drivers/watchdog/tangox_wdt.c
@@ -139,6 +139,10 @@ static int tangox_wdt_probe(struct platform_device *pdev)
 		return err;
 
 	dev->clk_rate = clk_get_rate(dev->clk);
+	if (!dev->clk_rate) {
+		err = -EINVAL;
+		goto err;
+	}
 
 	dev->wdt.parent = &pdev->dev;
 	dev->wdt.info = &tangox_wdt_info;
@@ -171,10 +175,8 @@ static int tangox_wdt_probe(struct platform_device *pdev)
 	}
 
 	err = watchdog_register_device(&dev->wdt);
-	if (err) {
-		clk_disable_unprepare(dev->clk);
-		return err;
-	}
+	if (err)
+		goto err;
 
 	platform_set_drvdata(pdev, dev);
 
@@ -187,6 +189,10 @@ static int tangox_wdt_probe(struct platform_device *pdev)
 	dev_info(&pdev->dev, "SMP86xx/SMP87xx watchdog registered\n");
 
 	return 0;
+
+ err:
+	clk_disable_unprepare(dev->clk);
+	return err;
 }
 
 static int tangox_wdt_remove(struct platform_device *pdev)

commit 3d29f80813ba335a21b56debff8e4b92a2772a64
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Thu Dec 24 14:22:01 2015 -0800

    watchdog: tangox: Print info message using pointer to platform device
    
    The device pointer in struct watchdog_device should not be used by drivers
    and may be removed in the near future. Use the platform device pointer for
    info messages instead.
    
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/drivers/watchdog/tangox_wdt.c b/drivers/watchdog/tangox_wdt.c
index b9ee6246e7c2..709c1ed6fd79 100644
--- a/drivers/watchdog/tangox_wdt.c
+++ b/drivers/watchdog/tangox_wdt.c
@@ -184,7 +184,7 @@ static int tangox_wdt_probe(struct platform_device *pdev)
 	if (err)
 		dev_warn(&pdev->dev, "failed to register restart handler\n");
 
-	dev_info(dev->wdt.dev, "SMP86xx/SMP87xx watchdog registered\n");
+	dev_info(&pdev->dev, "SMP86xx/SMP87xx watchdog registered\n");
 
 	return 0;
 }

commit dca536c433a20f916451d8318f4aa7158c0d811c
Author: Mans Rullgard <mans@mansr.com>
Date:   Thu Nov 19 22:09:05 2015 +0000

    watchdog: add support for Sigma Designs SMP86xx/SMP87xx
    
    This adds support for the Sigma Designs SMP86xx/SMP87xx family built-in
    watchdog.
    
    Signed-off-by: Mans Rullgard <mans@mansr.com>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/drivers/watchdog/tangox_wdt.c b/drivers/watchdog/tangox_wdt.c
new file mode 100644
index 000000000000..b9ee6246e7c2
--- /dev/null
+++ b/drivers/watchdog/tangox_wdt.c
@@ -0,0 +1,225 @@
+/*
+ *  Copyright (C) 2015 Mans Rullgard <mans@mansr.com>
+ *  SMP86xx/SMP87xx Watchdog driver
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under  the terms of the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the License, or (at your
+ *  option) any later version.
+ */
+
+#include <linux/bitops.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/notifier.h>
+#include <linux/platform_device.h>
+#include <linux/reboot.h>
+#include <linux/watchdog.h>
+
+#define DEFAULT_TIMEOUT 30
+
+static bool nowayout = WATCHDOG_NOWAYOUT;
+module_param(nowayout, bool, 0);
+MODULE_PARM_DESC(nowayout,
+		 "Watchdog cannot be stopped once started (default="
+		 __MODULE_STRING(WATCHDOG_NOWAYOUT) ")");
+
+static unsigned int timeout;
+module_param(timeout, int, 0);
+MODULE_PARM_DESC(timeout, "Watchdog timeout");
+
+/*
+ * Counter counts down from programmed value.  Reset asserts when
+ * the counter reaches 1.
+ */
+#define WD_COUNTER		0
+
+#define WD_CONFIG		4
+#define WD_CONFIG_XTAL_IN	BIT(0)
+#define WD_CONFIG_DISABLE	BIT(31)
+
+struct tangox_wdt_device {
+	struct watchdog_device wdt;
+	void __iomem *base;
+	unsigned long clk_rate;
+	struct clk *clk;
+	struct notifier_block restart;
+};
+
+static int tangox_wdt_set_timeout(struct watchdog_device *wdt,
+				  unsigned int new_timeout)
+{
+	wdt->timeout = new_timeout;
+
+	return 0;
+}
+
+static int tangox_wdt_start(struct watchdog_device *wdt)
+{
+	struct tangox_wdt_device *dev = watchdog_get_drvdata(wdt);
+	u32 ticks;
+
+	ticks = 1 + wdt->timeout * dev->clk_rate;
+	writel(ticks, dev->base + WD_COUNTER);
+
+	return 0;
+}
+
+static int tangox_wdt_stop(struct watchdog_device *wdt)
+{
+	struct tangox_wdt_device *dev = watchdog_get_drvdata(wdt);
+
+	writel(0, dev->base + WD_COUNTER);
+
+	return 0;
+}
+
+static unsigned int tangox_wdt_get_timeleft(struct watchdog_device *wdt)
+{
+	struct tangox_wdt_device *dev = watchdog_get_drvdata(wdt);
+	u32 count;
+
+	count = readl(dev->base + WD_COUNTER);
+
+	if (!count)
+		return 0;
+
+	return (count - 1) / dev->clk_rate;
+}
+
+static const struct watchdog_info tangox_wdt_info = {
+	.options  = WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING | WDIOF_MAGICCLOSE,
+	.identity = "tangox watchdog",
+};
+
+static const struct watchdog_ops tangox_wdt_ops = {
+	.start		= tangox_wdt_start,
+	.stop		= tangox_wdt_stop,
+	.set_timeout	= tangox_wdt_set_timeout,
+	.get_timeleft	= tangox_wdt_get_timeleft,
+};
+
+static int tangox_wdt_restart(struct notifier_block *nb, unsigned long action,
+			      void *data)
+{
+	struct tangox_wdt_device *dev =
+		container_of(nb, struct tangox_wdt_device, restart);
+
+	writel(1, dev->base + WD_COUNTER);
+
+	return NOTIFY_DONE;
+}
+
+static int tangox_wdt_probe(struct platform_device *pdev)
+{
+	struct tangox_wdt_device *dev;
+	struct resource *res;
+	u32 config;
+	int err;
+
+	dev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);
+	if (!dev)
+		return -ENOMEM;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	dev->base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(dev->base))
+		return PTR_ERR(dev->base);
+
+	dev->clk = devm_clk_get(&pdev->dev, NULL);
+	if (IS_ERR(dev->clk))
+		return PTR_ERR(dev->clk);
+
+	err = clk_prepare_enable(dev->clk);
+	if (err)
+		return err;
+
+	dev->clk_rate = clk_get_rate(dev->clk);
+
+	dev->wdt.parent = &pdev->dev;
+	dev->wdt.info = &tangox_wdt_info;
+	dev->wdt.ops = &tangox_wdt_ops;
+	dev->wdt.timeout = DEFAULT_TIMEOUT;
+	dev->wdt.min_timeout = 1;
+	dev->wdt.max_timeout = (U32_MAX - 1) / dev->clk_rate;
+
+	watchdog_init_timeout(&dev->wdt, timeout, &pdev->dev);
+	watchdog_set_nowayout(&dev->wdt, nowayout);
+	watchdog_set_drvdata(&dev->wdt, dev);
+
+	/*
+	 * Deactivate counter if disable bit is set to avoid
+	 * accidental reset.
+	 */
+	config = readl(dev->base + WD_CONFIG);
+	if (config & WD_CONFIG_DISABLE)
+		writel(0, dev->base + WD_COUNTER);
+
+	writel(WD_CONFIG_XTAL_IN, dev->base + WD_CONFIG);
+
+	/*
+	 * Mark as active and restart with configured timeout if
+	 * already running.
+	 */
+	if (readl(dev->base + WD_COUNTER)) {
+		set_bit(WDOG_ACTIVE, &dev->wdt.status);
+		tangox_wdt_start(&dev->wdt);
+	}
+
+	err = watchdog_register_device(&dev->wdt);
+	if (err) {
+		clk_disable_unprepare(dev->clk);
+		return err;
+	}
+
+	platform_set_drvdata(pdev, dev);
+
+	dev->restart.notifier_call = tangox_wdt_restart;
+	dev->restart.priority = 128;
+	err = register_restart_handler(&dev->restart);
+	if (err)
+		dev_warn(&pdev->dev, "failed to register restart handler\n");
+
+	dev_info(dev->wdt.dev, "SMP86xx/SMP87xx watchdog registered\n");
+
+	return 0;
+}
+
+static int tangox_wdt_remove(struct platform_device *pdev)
+{
+	struct tangox_wdt_device *dev = platform_get_drvdata(pdev);
+
+	tangox_wdt_stop(&dev->wdt);
+	clk_disable_unprepare(dev->clk);
+
+	unregister_restart_handler(&dev->restart);
+	watchdog_unregister_device(&dev->wdt);
+
+	return 0;
+}
+
+static const struct of_device_id tangox_wdt_dt_ids[] = {
+	{ .compatible = "sigma,smp8642-wdt" },
+	{ .compatible = "sigma,smp8759-wdt" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, tangox_wdt_dt_ids);
+
+static struct platform_driver tangox_wdt_driver = {
+	.probe	= tangox_wdt_probe,
+	.remove	= tangox_wdt_remove,
+	.driver	= {
+		.name		= "tangox-wdt",
+		.of_match_table	= tangox_wdt_dt_ids,
+	},
+};
+
+module_platform_driver(tangox_wdt_driver);
+
+MODULE_AUTHOR("Mans Rullgard <mans@mansr.com>");
+MODULE_DESCRIPTION("SMP86xx/SMP87xx Watchdog driver");
+MODULE_LICENSE("GPL");
