commit 73027cb8e8390c8b19e5925d621b74066ccab215
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Tue Apr 23 11:48:35 2019 -0400

    watchdog: coh901327: make it explicitly non-modular
    
    The Kconfig currently controlling compilation of this code is:
    
    config COH901327_WATCHDOG
           bool "ST-Ericsson COH 901 327 watchdog"
    
    ...meaning that it currently is not being built as a module by anyone.
    
    Lets remove the modular code that is essentially orphaned, so that
    when reading the driver there is no doubt it is builtin-only.
    
    We explicitly disallow a driver unbind, since that doesn't have a
    sensible use case anyway, and it allows us to drop the ".remove"
    code for non-modular drivers.
    
    Since module_platform_driver() uses the same init level priority as
    builtin_platform_driver() the init ordering remains unchanged with
    this commit.
    
    Also note that MODULE_ALIAS is a no-op for non-modular code.
    
    We also delete the MODULE_LICENSE tag etc. since all that information
    is already contained at the top of the file in the comments.
    
    We replace module.h with moduleparam.h since the file does actually
    declare some module parameters (i.e. boot args for non-modules).
    
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Wim Van Sebroeck <wim@iguana.be>
    Cc: Guenter Roeck <linux@roeck-us.net>
    Cc: linux-watchdog@vger.kernel.org
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Reviewed-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@linux-watchdog.org>

diff --git a/drivers/watchdog/coh901327_wdt.c b/drivers/watchdog/coh901327_wdt.c
index 3c4eaa0d1178..260c50b08483 100644
--- a/drivers/watchdog/coh901327_wdt.c
+++ b/drivers/watchdog/coh901327_wdt.c
@@ -6,7 +6,7 @@
  * Watchdog driver for the ST-Ericsson AB COH 901 327 IP core
  * Author: Linus Walleij <linus.walleij@stericsson.com>
  */
-#include <linux/module.h>
+#include <linux/moduleparam.h>
 #include <linux/mod_devicetable.h>
 #include <linux/types.h>
 #include <linux/watchdog.h>
@@ -243,16 +243,6 @@ static struct watchdog_device coh901327_wdt = {
 	.timeout = U300_WDOG_DEFAULT_TIMEOUT,
 };
 
-static int __exit coh901327_remove(struct platform_device *pdev)
-{
-	watchdog_unregister_device(&coh901327_wdt);
-	coh901327_disable();
-	free_irq(irq, pdev);
-	clk_disable_unprepare(clk);
-	clk_put(clk);
-	return 0;
-}
-
 static int __init coh901327_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
@@ -406,19 +396,13 @@ static struct platform_driver coh901327_driver = {
 	.driver = {
 		.name	= "coh901327_wdog",
 		.of_match_table = coh901327_dt_match,
+		.suppress_bind_attrs = true,
 	},
-	.remove		= __exit_p(coh901327_remove),
 	.suspend	= coh901327_suspend,
 	.resume		= coh901327_resume,
 };
+builtin_platform_driver_probe(coh901327_driver, coh901327_probe);
 
-module_platform_driver_probe(coh901327_driver, coh901327_probe);
-
-MODULE_AUTHOR("Linus Walleij <linus.walleij@stericsson.com>");
-MODULE_DESCRIPTION("COH 901 327 Watchdog");
-
+/* not really modular, but ... */
 module_param(margin, uint, 0);
 MODULE_PARM_DESC(margin, "Watchdog margin in seconds (default 60s)");
-
-MODULE_LICENSE("GPL v2");
-MODULE_ALIAS("platform:coh901327-watchdog");

commit 0f0a6a285ec0c7b0ac0b532f87a784605322f9ce
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Tue Apr 2 12:01:53 2019 -0700

    watchdog: Convert to use devm_platform_ioremap_resource
    
    Use devm_platform_ioremap_resource to reduce source code size,
    improve readability, and reduce the likelyhood of bugs.
    
    The conversion was done automatically with coccinelle using the
    following semantic patch.
    
    @r@
    identifier res, pdev;
    expression a;
    expression index;
    expression e;
    @@
    
    <+...
    - res = platform_get_resource(pdev, IORESOURCE_MEM, index);
    - a = devm_ioremap_resource(e, res);
    + a = devm_platform_ioremap_resource(pdev, index);
    ...+>
    
    @depends on r@
    identifier r.res;
    @@
    - struct resource *res;
      ... when != res
    
    @@
    identifier res, pdev;
    expression index;
    expression a;
    @@
    - struct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, index);
    - a = devm_ioremap_resource(&pdev->dev, res);
    + a = devm_platform_ioremap_resource(pdev, index);
    
    Cc: Joel Stanley <joel@jms.id.au>
    Cc: Nicolas Ferre <nicolas.ferre@microchip.com>
    Cc: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Cc: Florian Fainelli <f.fainelli@gmail.com>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Baruch Siach <baruch@tkos.co.il>
    Cc: Keguang Zhang <keguang.zhang@gmail.com>
    Cc: Vladimir Zapolskiy <vz@mleia.com>
    Cc: Kevin Hilman <khilman@baylibre.com>
    Cc: Matthias Brugger <matthias.bgg@gmail.com>
    Cc: Avi Fishman <avifishman70@gmail.com>
    Cc: Nancy Yuen <yuenn@google.com>
    Cc: Brendan Higgins <brendanhiggins@google.com>
    Cc: Wan ZongShun <mcuos.com@gmail.com>
    Cc: Michal Simek <michal.simek@xilinx.com>
    Cc: Sylvain Lemieux <slemieux.tyco@gmail.com>
    Cc: Kukjin Kim <kgene@kernel.org>
    Cc: Barry Song <baohua@kernel.org>
    Cc: Orson Zhai <orsonzhai@gmail.com>
    Cc: Patrice Chotard <patrice.chotard@st.com>
    Cc: Maxime Coquelin <mcoquelin.stm32@gmail.com>
    Cc: Maxime Ripard <maxime.ripard@bootlin.com>
    Cc: Chen-Yu Tsai <wens@csie.org>
    Cc: Marc Gonzalez <marc.w.gonzalez@free.fr>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Cc: Shawn Guo <shawnguo@kernel.org>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Acked-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Tested-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Acked-by: Joel Stanley <joel@jms.id.au>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Maxime Ripard <maxime.ripard@bootlin.com>
    Acked-by: Michal Simek <michal.simek@xilinx.com> (cadence/xilinx wdts)
    Acked-by: Thierry Reding <treding@nvidia.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Acked-by: Patrice Chotard <patrice.chotard@st.com>
    Acked-by: Vladimir Zapolskiy <vz@mleia.com>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@linux-watchdog.org>

diff --git a/drivers/watchdog/coh901327_wdt.c b/drivers/watchdog/coh901327_wdt.c
index f29d1edc5bad..3c4eaa0d1178 100644
--- a/drivers/watchdog/coh901327_wdt.c
+++ b/drivers/watchdog/coh901327_wdt.c
@@ -258,12 +258,10 @@ static int __init coh901327_probe(struct platform_device *pdev)
 	struct device *dev = &pdev->dev;
 	int ret;
 	u16 val;
-	struct resource *res;
 
 	parent = dev;
 
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	virtbase = devm_ioremap_resource(dev, res);
+	virtbase = devm_platform_ioremap_resource(pdev, 0);
 	if (IS_ERR(virtbase))
 		return PTR_ERR(virtbase);
 

commit ac3167257b9fe16c9426c2087ead1c9f1b0992b1
Author: Randy Dunlap <rdunlap@infradead.org>
Date:   Tue Jun 19 22:47:28 2018 -0700

    headers: separate linux/mod_devicetable.h from linux/platform_device.h
    
    At over 4000 #includes, <linux/platform_device.h> is the 9th most
    #included header file in the Linux kernel.  It does not need
    <linux/mod_devicetable.h>, so drop that header and explicitly add
    <linux/mod_devicetable.h> to source files that need it.
    
       4146 #include <linux/platform_device.h>
    
    After this patch, there are 225 files that use <linux/mod_devicetable.h>,
    for a reduction of around 3900 times that <linux/mod_devicetable.h>
    does not have to be read & parsed.
    
        225 #include <linux/mod_devicetable.h>
    
    This patch was build-tested on 20 different arch-es.
    
    It also makes these drivers SubmitChecklist#1 compliant.
    
    Signed-off-by: Randy Dunlap <rdunlap@infradead.org>
    Reported-by: kbuild test robot <lkp@intel.com> # drivers/media/platform/vimc/
    Reported-by: kbuild test robot <lkp@intel.com> # drivers/pinctrl/pinctrl-u300.c
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/watchdog/coh901327_wdt.c b/drivers/watchdog/coh901327_wdt.c
index e3a78f927f83..f29d1edc5bad 100644
--- a/drivers/watchdog/coh901327_wdt.c
+++ b/drivers/watchdog/coh901327_wdt.c
@@ -7,6 +7,7 @@
  * Author: Linus Walleij <linus.walleij@stericsson.com>
  */
 #include <linux/module.h>
+#include <linux/mod_devicetable.h>
 #include <linux/types.h>
 #include <linux/watchdog.h>
 #include <linux/interrupt.h>

commit 8d039d4d3d387d15e6c9bb7a406c6689efdb8540
Author: Marcus Folkesson <marcus.folkesson@gmail.com>
Date:   Sat Feb 10 10:27:01 2018 +0100

    watchdog: coh901327: make license text and module licence match
    
    Licence text is specifying "GPLv2" but the MODULE_LICENSE is set to "GPLv2
    or later".
    
    See include/linux/module.h:
    "GPL"                           [GNU Public License v2 or later]
    "GPL v2"                        [GNU Public License v2]
    
    When on it, add SPDX identifier tag.
    
    Signed-off-by: Marcus Folkesson <marcus.folkesson@gmail.com>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Guenter Roeck <linux@roeck-us.net>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/drivers/watchdog/coh901327_wdt.c b/drivers/watchdog/coh901327_wdt.c
index 500af8a7ec5a..e3a78f927f83 100644
--- a/drivers/watchdog/coh901327_wdt.c
+++ b/drivers/watchdog/coh901327_wdt.c
@@ -1,8 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * coh901327_wdt.c
  *
  * Copyright (C) 2008-2009 ST-Ericsson AB
- * License terms: GNU General Public License (GPL) version 2
  * Watchdog driver for the ST-Ericsson AB COH 901 327 IP core
  * Author: Linus Walleij <linus.walleij@stericsson.com>
  */
@@ -421,5 +421,5 @@ MODULE_DESCRIPTION("COH 901 327 Watchdog");
 module_param(margin, uint, 0);
 MODULE_PARM_DESC(margin, "Watchdog margin in seconds (default 60s)");
 
-MODULE_LICENSE("GPL");
+MODULE_LICENSE("GPL v2");
 MODULE_ALIAS("platform:coh901327-watchdog");

commit 321390d9bdd9e0481bde19bd965d019855c1ec74
Author: Marcus Folkesson <marcus.folkesson@gmail.com>
Date:   Sun Feb 11 21:08:47 2018 +0100

    watchdog: coh901327: make use of timeout-secs provided in devicetree
    
    watchdog_init_timeout() will allways pick timeout_param since it
    defaults to a valid timeout.
    
    Following best practice described in
    Documentation/watchdog/watchdog-kernel-api.txt to make use of
    the parameter logic.
    
    Signed-off-by: Marcus Folkesson <marcus.folkesson@gmail.com>
    Reviewed-by: Guenter Roeck <linux@roeck-us.net>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/drivers/watchdog/coh901327_wdt.c b/drivers/watchdog/coh901327_wdt.c
index 4410337f4f7f..500af8a7ec5a 100644
--- a/drivers/watchdog/coh901327_wdt.c
+++ b/drivers/watchdog/coh901327_wdt.c
@@ -67,7 +67,9 @@
 #define U300_WDOG_IFR_WILL_BARK_IRQ_FORCE_ENABLE			0x0001U
 
 /* Default timeout in seconds = 1 minute */
-static unsigned int margin = 60;
+#define U300_WDOG_DEFAULT_TIMEOUT					60
+
+static unsigned int margin;
 static int irq;
 static void __iomem *virtbase;
 static struct device *parent;
@@ -235,8 +237,9 @@ static struct watchdog_device coh901327_wdt = {
 	 * timeout register is max
 	 * 0x7FFF = 327670ms ~= 327s.
 	 */
-	.min_timeout = 0,
+	.min_timeout = 1,
 	.max_timeout = 327,
+	.timeout = U300_WDOG_DEFAULT_TIMEOUT,
 };
 
 static int __exit coh901327_remove(struct platform_device *pdev)
@@ -315,16 +318,15 @@ static int __init coh901327_probe(struct platform_device *pdev)
 		goto out_no_irq;
 	}
 
-	ret = watchdog_init_timeout(&coh901327_wdt, margin, dev);
-	if (ret < 0)
-		coh901327_wdt.timeout = 60;
+	watchdog_init_timeout(&coh901327_wdt, margin, dev);
 
 	coh901327_wdt.parent = dev;
 	ret = watchdog_register_device(&coh901327_wdt);
 	if (ret)
 		goto out_no_wdog;
 
-	dev_info(dev, "initialized. timer margin=%d sec\n", margin);
+	dev_info(dev, "initialized. (timeout=%d sec)\n",
+			coh901327_wdt.timeout);
 	return 0;
 
 out_no_wdog:

commit 9215fc79521a05debba3ba67668caeb65d204cc7
Author: Gustavo A. R. Silva <garsilva@embeddedor.com>
Date:   Fri Jul 7 19:33:30 2017 -0500

    watchdog: coh901327_wdt: constify watchdog_ops structure
    
    Check for watchdog_ops structures that are only stored in the ops field of
    a watchdog_device structure. This field is declared const, so watchdog_ops
    structures that have this property can be declared as const also.
    
    This issue was detected using Coccinelle and the following semantic patch:
    
    @r
    disable optional_qualifier@
    identifier i;
    position p;
    @@
    static struct watchdog_ops i@p = { ... };
    
    @ok@
    identifier r.i;
    struct watchdog_device e;
    position p;
    @@
    e.ops = &i@p;
    
    @bad@
    position p != {r.p,ok.p};
    identifier r.i;
    struct watchdog_ops e;
    @@
    e@i@p
    
    @depends on !bad disable optional_qualifier@
    identifier r.i;
    @@
    static
    +const
     struct watchdog_ops i = { ... };
    
    Signed-off-by: Gustavo A. R. Silva <garsilva@embeddedor.com>
    Reviewed-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/drivers/watchdog/coh901327_wdt.c b/drivers/watchdog/coh901327_wdt.c
index 38dd60f0cfcc..4410337f4f7f 100644
--- a/drivers/watchdog/coh901327_wdt.c
+++ b/drivers/watchdog/coh901327_wdt.c
@@ -218,7 +218,7 @@ static const struct watchdog_info coh901327_ident = {
 	.identity = DRV_NAME,
 };
 
-static struct watchdog_ops coh901327_ops = {
+static const struct watchdog_ops coh901327_ops = {
 	.owner = THIS_MODULE,
 	.start = coh901327_start,
 	.stop = coh901327_stop,

commit 9e14375880c4a64e190b296023f52e987cb9d33e
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Tue Jan 3 19:21:37 2017 -0800

    watchdog: coh901327_wdt: Use dev variable instead of pdev->dev
    
    Use a local dev variable instead of dereferencing pdev->dev several
    times in the probe function to make the code easier to read.
    
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>

diff --git a/drivers/watchdog/coh901327_wdt.c b/drivers/watchdog/coh901327_wdt.c
index 986222efe174..38dd60f0cfcc 100644
--- a/drivers/watchdog/coh901327_wdt.c
+++ b/drivers/watchdog/coh901327_wdt.c
@@ -251,60 +251,56 @@ static int __exit coh901327_remove(struct platform_device *pdev)
 
 static int __init coh901327_probe(struct platform_device *pdev)
 {
+	struct device *dev = &pdev->dev;
 	int ret;
 	u16 val;
 	struct resource *res;
 
-	parent = &pdev->dev;
+	parent = dev;
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	virtbase = devm_ioremap_resource(&pdev->dev, res);
+	virtbase = devm_ioremap_resource(dev, res);
 	if (IS_ERR(virtbase))
 		return PTR_ERR(virtbase);
 
-	clk = clk_get(&pdev->dev, NULL);
+	clk = clk_get(dev, NULL);
 	if (IS_ERR(clk)) {
 		ret = PTR_ERR(clk);
-		dev_err(&pdev->dev, "could not get clock\n");
+		dev_err(dev, "could not get clock\n");
 		return ret;
 	}
 	ret = clk_prepare_enable(clk);
 	if (ret) {
-		dev_err(&pdev->dev, "could not prepare and enable clock\n");
+		dev_err(dev, "could not prepare and enable clock\n");
 		goto out_no_clk_enable;
 	}
 
 	val = readw(virtbase + U300_WDOG_SR);
 	switch (val) {
 	case U300_WDOG_SR_STATUS_TIMED_OUT:
-		dev_info(&pdev->dev,
-			"watchdog timed out since last chip reset!\n");
+		dev_info(dev, "watchdog timed out since last chip reset!\n");
 		coh901327_wdt.bootstatus |= WDIOF_CARDRESET;
 		/* Status will be cleared below */
 		break;
 	case U300_WDOG_SR_STATUS_NORMAL:
-		dev_info(&pdev->dev,
-			"in normal status, no timeouts have occurred.\n");
+		dev_info(dev, "in normal status, no timeouts have occurred.\n");
 		break;
 	default:
-		dev_info(&pdev->dev,
-			"contains an illegal status code (%08x)\n", val);
+		dev_info(dev, "contains an illegal status code (%08x)\n", val);
 		break;
 	}
 
 	val = readw(virtbase + U300_WDOG_D2R);
 	switch (val) {
 	case U300_WDOG_D2R_DISABLE_STATUS_DISABLED:
-		dev_info(&pdev->dev, "currently disabled.\n");
+		dev_info(dev, "currently disabled.\n");
 		break;
 	case U300_WDOG_D2R_DISABLE_STATUS_ENABLED:
-		dev_info(&pdev->dev,
-			 "currently enabled! (disabling it now)\n");
+		dev_info(dev, "currently enabled! (disabling it now)\n");
 		coh901327_disable();
 		break;
 	default:
-		dev_err(&pdev->dev,
-			"contains an illegal enable/disable code (%08x)\n",
+		dev_err(dev, "contains an illegal enable/disable code (%08x)\n",
 			val);
 		break;
 	}
@@ -319,16 +315,16 @@ static int __init coh901327_probe(struct platform_device *pdev)
 		goto out_no_irq;
 	}
 
-	ret = watchdog_init_timeout(&coh901327_wdt, margin, &pdev->dev);
+	ret = watchdog_init_timeout(&coh901327_wdt, margin, dev);
 	if (ret < 0)
 		coh901327_wdt.timeout = 60;
 
-	coh901327_wdt.parent = &pdev->dev;
+	coh901327_wdt.parent = dev;
 	ret = watchdog_register_device(&coh901327_wdt);
 	if (ret)
 		goto out_no_wdog;
 
-	dev_info(&pdev->dev, "initialized. timer margin=%d sec\n", margin);
+	dev_info(dev, "initialized. timer margin=%d sec\n", margin);
 	return 0;
 
 out_no_wdog:

commit 30c65b22f04262206e1ea00a87469233930066c2
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Tue Jan 3 03:10:30 2017 -0800

    watchdog: coh901327_wdt: Use devm_ioremap_resource to map resources
    
    Map resources using devm_ioremap_resource() to simplify error handling.
    
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>

diff --git a/drivers/watchdog/coh901327_wdt.c b/drivers/watchdog/coh901327_wdt.c
index 1385a920df4f..986222efe174 100644
--- a/drivers/watchdog/coh901327_wdt.c
+++ b/drivers/watchdog/coh901327_wdt.c
@@ -68,8 +68,6 @@
 
 /* Default timeout in seconds = 1 minute */
 static unsigned int margin = 60;
-static resource_size_t phybase;
-static resource_size_t physize;
 static int irq;
 static void __iomem *virtbase;
 static struct device *parent;
@@ -248,8 +246,6 @@ static int __exit coh901327_remove(struct platform_device *pdev)
 	free_irq(irq, pdev);
 	clk_disable_unprepare(clk);
 	clk_put(clk);
-	iounmap(virtbase);
-	release_mem_region(phybase, physize);
 	return 0;
 }
 
@@ -259,30 +255,18 @@ static int __init coh901327_probe(struct platform_device *pdev)
 	u16 val;
 	struct resource *res;
 
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!res)
-		return -ENOENT;
-
 	parent = &pdev->dev;
-	physize = resource_size(res);
-	phybase = res->start;
-
-	if (request_mem_region(phybase, physize, DRV_NAME) == NULL) {
-		ret = -EBUSY;
-		goto out;
-	}
 
-	virtbase = ioremap(phybase, physize);
-	if (!virtbase) {
-		ret = -ENOMEM;
-		goto out_no_remap;
-	}
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	virtbase = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(virtbase))
+		return PTR_ERR(virtbase);
 
 	clk = clk_get(&pdev->dev, NULL);
 	if (IS_ERR(clk)) {
 		ret = PTR_ERR(clk);
 		dev_err(&pdev->dev, "could not get clock\n");
-		goto out_no_clk;
+		return ret;
 	}
 	ret = clk_prepare_enable(clk);
 	if (ret) {
@@ -353,11 +337,6 @@ static int __init coh901327_probe(struct platform_device *pdev)
 	clk_disable_unprepare(clk);
 out_no_clk_enable:
 	clk_put(clk);
-out_no_clk:
-	iounmap(virtbase);
-out_no_remap:
-	release_mem_region(phybase, SZ_4K);
-out:
 	return ret;
 }
 

commit 14da8d427eb8ea10d8fb78a1264583bb9b279231
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Tue Jan 3 03:03:27 2017 -0800

    watchdog: coh901327_wdt: Keep clock enabled after loading driver
    
    Enabling the clock before accessing chip registers and disabling it
    afterwards does not really make sense and only adds complexity to
    the driver. In addition to that, a comment int the driver suggests
    that it does not serve a useful purpose either.
    
    "The watchdog block is of course always clocked, the
     clk_enable()/clk_disable() calls are mainly for performing reference
     counting higher up in the clock hierarchy."
    
    Just keep the clock enabled instead.
    
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>

diff --git a/drivers/watchdog/coh901327_wdt.c b/drivers/watchdog/coh901327_wdt.c
index dc97b2fd6c49..1385a920df4f 100644
--- a/drivers/watchdog/coh901327_wdt.c
+++ b/drivers/watchdog/coh901327_wdt.c
@@ -74,11 +74,6 @@ static int irq;
 static void __iomem *virtbase;
 static struct device *parent;
 
-/*
- * The watchdog block is of course always clocked, the
- * clk_enable()/clk_disable() calls are mainly for performing reference
- * counting higher up in the clock hierarchy.
- */
 static struct clk *clk;
 
 /*
@@ -90,7 +85,6 @@ static void coh901327_enable(u16 timeout)
 	unsigned long freq;
 	unsigned long delay_ns;
 
-	clk_enable(clk);
 	/* Restart timer if it is disabled */
 	val = readw(virtbase + U300_WDOG_D2R);
 	if (val == U300_WDOG_D2R_DISABLE_STATUS_DISABLED)
@@ -118,7 +112,6 @@ static void coh901327_enable(u16 timeout)
 	 */
 	(void) readw(virtbase + U300_WDOG_CR);
 	val = readw(virtbase + U300_WDOG_D2R);
-	clk_disable(clk);
 	if (val != U300_WDOG_D2R_DISABLE_STATUS_ENABLED)
 		dev_err(parent,
 			"%s(): watchdog not enabled! D2R value %04x\n",
@@ -129,7 +122,6 @@ static void coh901327_disable(void)
 {
 	u16 val;
 
-	clk_enable(clk);
 	/* Disable the watchdog interrupt if it is active */
 	writew(0x0000U, virtbase + U300_WDOG_IMR);
 	/* If the watchdog is currently enabled, attempt to disable it */
@@ -144,7 +136,6 @@ static void coh901327_disable(void)
 		       virtbase + U300_WDOG_D2R);
 	}
 	val = readw(virtbase + U300_WDOG_D2R);
-	clk_disable(clk);
 	if (val != U300_WDOG_D2R_DISABLE_STATUS_DISABLED)
 		dev_err(parent,
 			"%s(): watchdog not disabled! D2R value %04x\n",
@@ -165,11 +156,9 @@ static int coh901327_stop(struct watchdog_device *wdt_dev)
 
 static int coh901327_ping(struct watchdog_device *wdd)
 {
-	clk_enable(clk);
 	/* Feed the watchdog */
 	writew(U300_WDOG_FR_FEED_RESTART_TIMER,
 	       virtbase + U300_WDOG_FR);
-	clk_disable(clk);
 	return 0;
 }
 
@@ -177,13 +166,11 @@ static int coh901327_settimeout(struct watchdog_device *wdt_dev,
 				unsigned int time)
 {
 	wdt_dev->timeout = time;
-	clk_enable(clk);
 	/* Set new timeout value */
 	writew(time * 100, virtbase + U300_WDOG_TR);
 	/* Feed the dog */
 	writew(U300_WDOG_FR_FEED_RESTART_TIMER,
 	       virtbase + U300_WDOG_FR);
-	clk_disable(clk);
 	return 0;
 }
 
@@ -191,13 +178,11 @@ static unsigned int coh901327_gettimeleft(struct watchdog_device *wdt_dev)
 {
 	u16 val;
 
-	clk_enable(clk);
 	/* Read repeatedly until the value is stable! */
 	val = readw(virtbase + U300_WDOG_CR);
 	while (val & U300_WDOG_CR_VALID_IND)
 		val = readw(virtbase + U300_WDOG_CR);
 	val &= U300_WDOG_CR_COUNT_VALUE_MASK;
-	clk_disable(clk);
 	if (val != 0)
 		val /= 100;
 
@@ -221,13 +206,11 @@ static irqreturn_t coh901327_interrupt(int irq, void *data)
 	 * to prevent a watchdog reset by feeding the watchdog at this
 	 * point.
 	 */
-	clk_enable(clk);
 	val = readw(virtbase + U300_WDOG_IER);
 	if (val == U300_WDOG_IER_WILL_BARK_IRQ_EVENT_IND)
 		writew(U300_WDOG_IER_WILL_BARK_IRQ_ACK_ENABLE,
 		       virtbase + U300_WDOG_IER);
 	writew(0x0000U, virtbase + U300_WDOG_IMR);
-	clk_disable(clk);
 	dev_crit(parent, "watchdog is barking!\n");
 	return IRQ_HANDLED;
 }
@@ -263,7 +246,7 @@ static int __exit coh901327_remove(struct platform_device *pdev)
 	watchdog_unregister_device(&coh901327_wdt);
 	coh901327_disable();
 	free_irq(irq, pdev);
-	clk_unprepare(clk);
+	clk_disable_unprepare(clk);
 	clk_put(clk);
 	iounmap(virtbase);
 	release_mem_region(phybase, physize);
@@ -352,8 +335,6 @@ static int __init coh901327_probe(struct platform_device *pdev)
 		goto out_no_irq;
 	}
 
-	clk_disable(clk);
-
 	ret = watchdog_init_timeout(&coh901327_wdt, margin, &pdev->dev);
 	if (ret < 0)
 		coh901327_wdt.timeout = 60;

commit 01372ae13ba6a4792de2f4bd474f1374b5404448
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Tue Jan 3 03:22:09 2017 -0800

    watchdog: coh901327_wdt: Simplify error handling in probe function
    
    Checking if there is no error followed by a goto if there is one is
    confusing. Reverse the logic.
    
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>

diff --git a/drivers/watchdog/coh901327_wdt.c b/drivers/watchdog/coh901327_wdt.c
index a099b77fc0b9..dc97b2fd6c49 100644
--- a/drivers/watchdog/coh901327_wdt.c
+++ b/drivers/watchdog/coh901327_wdt.c
@@ -360,12 +360,10 @@ static int __init coh901327_probe(struct platform_device *pdev)
 
 	coh901327_wdt.parent = &pdev->dev;
 	ret = watchdog_register_device(&coh901327_wdt);
-	if (ret == 0)
-		dev_info(&pdev->dev,
-			 "initialized. timer margin=%d sec\n", margin);
-	else
+	if (ret)
 		goto out_no_wdog;
 
+	dev_info(&pdev->dev, "initialized. timer margin=%d sec\n", margin);
 	return 0;
 
 out_no_wdog:

commit 6551881c86c791237a3bebf11eb3bd70b60ea782
Author: Pratyush Anand <panand@redhat.com>
Date:   Thu Aug 20 14:05:01 2015 +0530

    Watchdog: Fix parent of watchdog_devices
    
    /sys/class/watchdog/watchdogn/device/modalias can help to identify the
    driver/module for a given watchdog node. However, many wdt devices do not
    set their parent and so, we do not see an entry for device in sysfs for
    such devices.
    
    This patch fixes parent of watchdog_device so that
    /sys/class/watchdog/watchdogn/device is populated.
    
    Exceptions: booke, diag288, octeon, softdog and w83627hf -- They do not
    have any parent. Not sure, how we can identify driver for these devices.
    
    Signed-off-by: Pratyush Anand <panand@redhat.com>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Acked-by: Guenter Roeck <linux@roeck-us.net>
    Acked-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Acked-by: Lee Jones <lee.jones@linaro.org>
    Acked-by: Lubomir Rintel <lkundrak@v3.sk>
    Acked-by: Maxime Coquelin <maxime.coquelin@st.com>
    Acked-by: Thierry Reding <treding@nvidia.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/drivers/watchdog/coh901327_wdt.c b/drivers/watchdog/coh901327_wdt.c
index ce12f437f195..a099b77fc0b9 100644
--- a/drivers/watchdog/coh901327_wdt.c
+++ b/drivers/watchdog/coh901327_wdt.c
@@ -358,6 +358,7 @@ static int __init coh901327_probe(struct platform_device *pdev)
 	if (ret < 0)
 		coh901327_wdt.timeout = 60;
 
+	coh901327_wdt.parent = &pdev->dev;
 	ret = watchdog_register_device(&coh901327_wdt);
 	if (ret == 0)
 		dev_info(&pdev->dev,

commit fa21a580dea456c03fcf69203dcd0195df3f7dee
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Mon Oct 20 16:21:56 2014 +0200

    watchdog: drop owner assignment from platform_drivers
    
    A platform_driver does not need to set an owner, it will be populated by the
    driver core.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/watchdog/coh901327_wdt.c b/drivers/watchdog/coh901327_wdt.c
index 4bd070f524e5..ce12f437f195 100644
--- a/drivers/watchdog/coh901327_wdt.c
+++ b/drivers/watchdog/coh901327_wdt.c
@@ -448,7 +448,6 @@ static const struct of_device_id coh901327_dt_match[] = {
 
 static struct platform_driver coh901327_driver = {
 	.driver = {
-		.owner	= THIS_MODULE,
 		.name	= "coh901327_wdog",
 		.of_match_table = coh901327_dt_match,
 	},

commit c83c199199b9d68c56b5cc53b01b8f513f91b93a
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Fri Apr 19 12:56:36 2013 +0200

    watchdog: coh901327: devicetree support
    
    This adds support for probing the COH 901 327 watchdog from
    the device tree and also adds associated bindings.
    
    Acked-by: Wim Van Sebroeck <wim@iguana.be>
    Reviewed-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/watchdog/coh901327_wdt.c b/drivers/watchdog/coh901327_wdt.c
index b9b8a8be6f12..4bd070f524e5 100644
--- a/drivers/watchdog/coh901327_wdt.c
+++ b/drivers/watchdog/coh901327_wdt.c
@@ -354,9 +354,9 @@ static int __init coh901327_probe(struct platform_device *pdev)
 
 	clk_disable(clk);
 
-	if (margin < 1 || margin > 327)
-		margin = 60;
-	coh901327_wdt.timeout = margin;
+	ret = watchdog_init_timeout(&coh901327_wdt, margin, &pdev->dev);
+	if (ret < 0)
+		coh901327_wdt.timeout = 60;
 
 	ret = watchdog_register_device(&coh901327_wdt);
 	if (ret == 0)
@@ -441,10 +441,16 @@ void coh901327_watchdog_reset(void)
 	/* Return and await doom */
 }
 
+static const struct of_device_id coh901327_dt_match[] = {
+	{ .compatible = "stericsson,coh901327" },
+	{},
+};
+
 static struct platform_driver coh901327_driver = {
 	.driver = {
 		.owner	= THIS_MODULE,
 		.name	= "coh901327_wdog",
+		.of_match_table = coh901327_dt_match,
 	},
 	.remove		= __exit_p(coh901327_remove),
 	.suspend	= coh901327_suspend,

commit 1cb9204cc6e22ec18e62ab0687e2240cbdb15200
Author: Fabio Porcedda <fabio.porcedda@gmail.com>
Date:   Wed Jan 9 12:15:27 2013 +0100

    watchdog: convert drivers/watchdog/* to use module_platform_driver_probe
    
    This makes the code a bit smaller by getting rid of
    some boilerplate code.
    
    Signed-off-by: Fabio Porcedda <fabio.porcedda@gmail.com>
    Cc: Wim Van Sebroeck <wim@iguana.be>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/watchdog/coh901327_wdt.c b/drivers/watchdog/coh901327_wdt.c
index cb5da5c3ece2..b9b8a8be6f12 100644
--- a/drivers/watchdog/coh901327_wdt.c
+++ b/drivers/watchdog/coh901327_wdt.c
@@ -451,17 +451,7 @@ static struct platform_driver coh901327_driver = {
 	.resume		= coh901327_resume,
 };
 
-static int __init coh901327_init(void)
-{
-	return platform_driver_probe(&coh901327_driver, coh901327_probe);
-}
-module_init(coh901327_init);
-
-static void __exit coh901327_exit(void)
-{
-	platform_driver_unregister(&coh901327_driver);
-}
-module_exit(coh901327_exit);
+module_platform_driver_probe(coh901327_driver, coh901327_probe);
 
 MODULE_AUTHOR("Linus Walleij <linus.walleij@stericsson.com>");
 MODULE_DESCRIPTION("COH 901 327 Watchdog");

commit c362cb597b5c30a32f4228136e0dfd9bf4c5d65b
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Jun 12 19:19:01 2012 +0200

    watchdog: coh901327_wdt: use clk_prepare/unprepare
    
    Make sure we prepare/unprepare the COH901327 watchdog timer
    as is required by the clk API especially if you use common
    clock.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Reviewed-by : Pankaj Jangra <jangra.pankaj9@gmail.com>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/drivers/watchdog/coh901327_wdt.c b/drivers/watchdog/coh901327_wdt.c
index 6876430a9f5e..cb5da5c3ece2 100644
--- a/drivers/watchdog/coh901327_wdt.c
+++ b/drivers/watchdog/coh901327_wdt.c
@@ -263,6 +263,7 @@ static int __exit coh901327_remove(struct platform_device *pdev)
 	watchdog_unregister_device(&coh901327_wdt);
 	coh901327_disable();
 	free_irq(irq, pdev);
+	clk_unprepare(clk);
 	clk_put(clk);
 	iounmap(virtbase);
 	release_mem_region(phybase, physize);
@@ -300,9 +301,9 @@ static int __init coh901327_probe(struct platform_device *pdev)
 		dev_err(&pdev->dev, "could not get clock\n");
 		goto out_no_clk;
 	}
-	ret = clk_enable(clk);
+	ret = clk_prepare_enable(clk);
 	if (ret) {
-		dev_err(&pdev->dev, "could not enable clock\n");
+		dev_err(&pdev->dev, "could not prepare and enable clock\n");
 		goto out_no_clk_enable;
 	}
 
@@ -369,7 +370,7 @@ static int __init coh901327_probe(struct platform_device *pdev)
 out_no_wdog:
 	free_irq(irq, pdev);
 out_no_irq:
-	clk_disable(clk);
+	clk_disable_unprepare(clk);
 out_no_clk_enable:
 	clk_put(clk);
 out_no_clk:

commit dddbc6a0513b25c80e73e14ee704186deedc0d00
Author: Wim Van Sebroeck <wim@iguana.be>
Date:   Thu Mar 22 20:42:16 2012 +0100

    watchdog: coh901327_wdt.c: fix timeout
    
    Set the timeout value properly so that we don't get faulty values
    for the WDIOC_GETTIMEOUT iotcl. 'margin' should be an unsigned int.
    Also add a check to see if margin is a valid parameter after it is
    loaded as a module.
    
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Wolfram Sang <w.sang@pengutronix.de>

diff --git a/drivers/watchdog/coh901327_wdt.c b/drivers/watchdog/coh901327_wdt.c
index 7f0cbeb58770..6876430a9f5e 100644
--- a/drivers/watchdog/coh901327_wdt.c
+++ b/drivers/watchdog/coh901327_wdt.c
@@ -67,7 +67,7 @@
 #define U300_WDOG_IFR_WILL_BARK_IRQ_FORCE_ENABLE			0x0001U
 
 /* Default timeout in seconds = 1 minute */
-static int margin = 60;
+static unsigned int margin = 60;
 static resource_size_t phybase;
 static resource_size_t physize;
 static int irq;
@@ -153,7 +153,7 @@ static void coh901327_disable(void)
 
 static int coh901327_start(struct watchdog_device *wdt_dev)
 {
-	coh901327_enable(margin * 100);
+	coh901327_enable(wdt_dev->timeout * 100);
 	return 0;
 }
 
@@ -176,10 +176,10 @@ static int coh901327_ping(struct watchdog_device *wdd)
 static int coh901327_settimeout(struct watchdog_device *wdt_dev,
 				unsigned int time)
 {
-	margin = time;
+	wdt_dev->timeout = time;
 	clk_enable(clk);
 	/* Set new timeout value */
-	writew(margin * 100, virtbase + U300_WDOG_TR);
+	writew(time * 100, virtbase + U300_WDOG_TR);
 	/* Feed the dog */
 	writew(U300_WDOG_FR_FEED_RESTART_TIMER,
 	       virtbase + U300_WDOG_FR);
@@ -250,7 +250,7 @@ static struct watchdog_device coh901327_wdt = {
 	.info = &coh901327_ident,
 	.ops = &coh901327_ops,
 	/*
-	 * Max margin is 327 since the 10ms
+	 * Max timeout is 327 since the 10ms
 	 * timeout register is max
 	 * 0x7FFF = 327670ms ~= 327s.
 	 */
@@ -353,6 +353,10 @@ static int __init coh901327_probe(struct platform_device *pdev)
 
 	clk_disable(clk);
 
+	if (margin < 1 || margin > 327)
+		margin = 60;
+	coh901327_wdt.timeout = margin;
+
 	ret = watchdog_register_device(&coh901327_wdt);
 	if (ret == 0)
 		dev_info(&pdev->dev,
@@ -461,7 +465,7 @@ module_exit(coh901327_exit);
 MODULE_AUTHOR("Linus Walleij <linus.walleij@stericsson.com>");
 MODULE_DESCRIPTION("COH 901 327 Watchdog");
 
-module_param(margin, int, 0);
+module_param(margin, uint, 0);
 MODULE_PARM_DESC(margin, "Watchdog margin in seconds (default 60s)");
 
 MODULE_LICENSE("GPL");

commit 15b25701b282bd761a82c6508529b2145744075f
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Fri Mar 16 09:14:12 2012 +0100

    watchdog: coh901327: convert to use watchdog core
    
    This converts the COH901327 watchdog to use the watchdog core.
    I followed Wolframs document, looked at some other drivers and
    tested it on the U300.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Cc: Wolfram Sang <w.sang@pengutronix.de>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/drivers/watchdog/coh901327_wdt.c b/drivers/watchdog/coh901327_wdt.c
index 5b89f7d6cd0f..7f0cbeb58770 100644
--- a/drivers/watchdog/coh901327_wdt.c
+++ b/drivers/watchdog/coh901327_wdt.c
@@ -8,17 +8,15 @@
  */
 #include <linux/module.h>
 #include <linux/types.h>
-#include <linux/fs.h>
-#include <linux/miscdevice.h>
 #include <linux/watchdog.h>
 #include <linux/interrupt.h>
 #include <linux/pm.h>
 #include <linux/platform_device.h>
 #include <linux/io.h>
 #include <linux/bitops.h>
-#include <linux/uaccess.h>
 #include <linux/clk.h>
 #include <linux/delay.h>
+#include <linux/err.h>
 
 #define DRV_NAME "WDOG COH 901 327"
 
@@ -74,8 +72,6 @@ static resource_size_t phybase;
 static resource_size_t physize;
 static int irq;
 static void __iomem *virtbase;
-static unsigned long coh901327_users;
-static unsigned long boot_status;
 static struct device *parent;
 
 /*
@@ -155,30 +151,31 @@ static void coh901327_disable(void)
 			__func__, val);
 }
 
-static void coh901327_start(void)
+static int coh901327_start(struct watchdog_device *wdt_dev)
 {
 	coh901327_enable(margin * 100);
+	return 0;
+}
+
+static int coh901327_stop(struct watchdog_device *wdt_dev)
+{
+	coh901327_disable();
+	return 0;
 }
 
-static void coh901327_keepalive(void)
+static int coh901327_ping(struct watchdog_device *wdd)
 {
 	clk_enable(clk);
 	/* Feed the watchdog */
 	writew(U300_WDOG_FR_FEED_RESTART_TIMER,
 	       virtbase + U300_WDOG_FR);
 	clk_disable(clk);
+	return 0;
 }
 
-static int coh901327_settimeout(int time)
+static int coh901327_settimeout(struct watchdog_device *wdt_dev,
+				unsigned int time)
 {
-	/*
-	 * Max margin is 327 since the 10ms
-	 * timeout register is max
-	 * 0x7FFF = 327670ms ~= 327s.
-	 */
-	if (time <= 0 || time > 327)
-		return -EINVAL;
-
 	margin = time;
 	clk_enable(clk);
 	/* Set new timeout value */
@@ -190,6 +187,23 @@ static int coh901327_settimeout(int time)
 	return 0;
 }
 
+static unsigned int coh901327_gettimeleft(struct watchdog_device *wdt_dev)
+{
+	u16 val;
+
+	clk_enable(clk);
+	/* Read repeatedly until the value is stable! */
+	val = readw(virtbase + U300_WDOG_CR);
+	while (val & U300_WDOG_CR_VALID_IND)
+		val = readw(virtbase + U300_WDOG_CR);
+	val &= U300_WDOG_CR_COUNT_VALUE_MASK;
+	clk_disable(clk);
+	if (val != 0)
+		val /= 100;
+
+	return val;
+}
+
 /*
  * This interrupt occurs 10 ms before the watchdog WILL bark.
  */
@@ -218,130 +232,35 @@ static irqreturn_t coh901327_interrupt(int irq, void *data)
 	return IRQ_HANDLED;
 }
 
-/*
- * Allow only one user (daemon) to open the watchdog
- */
-static int coh901327_open(struct inode *inode, struct file *file)
-{
-	if (test_and_set_bit(1, &coh901327_users))
-		return -EBUSY;
-	coh901327_start();
-	return nonseekable_open(inode, file);
-}
-
-static int coh901327_release(struct inode *inode, struct file *file)
-{
-	clear_bit(1, &coh901327_users);
-	coh901327_disable();
-	return 0;
-}
-
-static ssize_t coh901327_write(struct file *file, const char __user *data,
-			       size_t len, loff_t *ppos)
-{
-	if (len)
-		coh901327_keepalive();
-	return len;
-}
-
-static long coh901327_ioctl(struct file *file, unsigned int cmd,
-			    unsigned long arg)
-{
-	int ret = -ENOTTY;
-	u16 val;
-	int time;
-	int new_options;
-	union {
-		struct watchdog_info __user *ident;
-		int __user *i;
-	} uarg;
-	static const struct watchdog_info ident = {
-		.options		= WDIOF_CARDRESET |
-					  WDIOF_SETTIMEOUT |
-					  WDIOF_KEEPALIVEPING,
-		.identity		= "COH 901 327 Watchdog",
-		.firmware_version	= 1,
-	};
-	uarg.i = (int __user *)arg;
-
-	switch (cmd) {
-	case WDIOC_GETSUPPORT:
-		ret = copy_to_user(uarg.ident, &ident,
-				   sizeof(ident)) ? -EFAULT : 0;
-		break;
-
-	case WDIOC_GETSTATUS:
-		ret = put_user(0, uarg.i);
-		break;
-
-	case WDIOC_GETBOOTSTATUS:
-		ret = put_user(boot_status, uarg.i);
-		break;
-
-	case WDIOC_SETOPTIONS:
-		ret = get_user(new_options, uarg.i);
-		if (ret)
-			break;
-		if (new_options & WDIOS_DISABLECARD)
-			coh901327_disable();
-		if (new_options & WDIOS_ENABLECARD)
-			coh901327_start();
-		ret = 0;
-		break;
-
-	case WDIOC_KEEPALIVE:
-		coh901327_keepalive();
-		ret = 0;
-		break;
-
-	case WDIOC_SETTIMEOUT:
-		ret = get_user(time, uarg.i);
-		if (ret)
-			break;
-
-		ret = coh901327_settimeout(time);
-		if (ret)
-			break;
-		/* Then fall through to return set value */
-
-	case WDIOC_GETTIMEOUT:
-		ret = put_user(margin, uarg.i);
-		break;
-
-	case WDIOC_GETTIMELEFT:
-		clk_enable(clk);
-		/* Read repeatedly until the value is stable! */
-		val = readw(virtbase + U300_WDOG_CR);
-		while (val & U300_WDOG_CR_VALID_IND)
-			val = readw(virtbase + U300_WDOG_CR);
-		val &= U300_WDOG_CR_COUNT_VALUE_MASK;
-		clk_disable(clk);
-		if (val != 0)
-			val /= 100;
-		ret = put_user(val, uarg.i);
-		break;
-	}
-	return ret;
-}
+static const struct watchdog_info coh901327_ident = {
+	.options = WDIOF_CARDRESET | WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING,
+	.identity = DRV_NAME,
+};
 
-static const struct file_operations coh901327_fops = {
-	.owner		= THIS_MODULE,
-	.llseek		= no_llseek,
-	.write		= coh901327_write,
-	.unlocked_ioctl	= coh901327_ioctl,
-	.open		= coh901327_open,
-	.release	= coh901327_release,
+static struct watchdog_ops coh901327_ops = {
+	.owner = THIS_MODULE,
+	.start = coh901327_start,
+	.stop = coh901327_stop,
+	.ping = coh901327_ping,
+	.set_timeout = coh901327_settimeout,
+	.get_timeleft = coh901327_gettimeleft,
 };
 
-static struct miscdevice coh901327_miscdev = {
-	.minor		= WATCHDOG_MINOR,
-	.name		= "watchdog",
-	.fops		= &coh901327_fops,
+static struct watchdog_device coh901327_wdt = {
+	.info = &coh901327_ident,
+	.ops = &coh901327_ops,
+	/*
+	 * Max margin is 327 since the 10ms
+	 * timeout register is max
+	 * 0x7FFF = 327670ms ~= 327s.
+	 */
+	.min_timeout = 0,
+	.max_timeout = 327,
 };
 
 static int __exit coh901327_remove(struct platform_device *pdev)
 {
-	misc_deregister(&coh901327_miscdev);
+	watchdog_unregister_device(&coh901327_wdt);
 	coh901327_disable();
 	free_irq(irq, pdev);
 	clk_put(clk);
@@ -350,7 +269,6 @@ static int __exit coh901327_remove(struct platform_device *pdev)
 	return 0;
 }
 
-
 static int __init coh901327_probe(struct platform_device *pdev)
 {
 	int ret;
@@ -393,7 +311,7 @@ static int __init coh901327_probe(struct platform_device *pdev)
 	case U300_WDOG_SR_STATUS_TIMED_OUT:
 		dev_info(&pdev->dev,
 			"watchdog timed out since last chip reset!\n");
-		boot_status = WDIOF_CARDRESET;
+		coh901327_wdt.bootstatus |= WDIOF_CARDRESET;
 		/* Status will be cleared below */
 		break;
 	case U300_WDOG_SR_STATUS_NORMAL:
@@ -435,7 +353,7 @@ static int __init coh901327_probe(struct platform_device *pdev)
 
 	clk_disable(clk);
 
-	ret = misc_register(&coh901327_miscdev);
+	ret = watchdog_register_device(&coh901327_wdt);
 	if (ret == 0)
 		dev_info(&pdev->dev,
 			 "initialized. timer margin=%d sec\n", margin);
@@ -547,4 +465,4 @@ module_param(margin, int, 0);
 MODULE_PARM_DESC(margin, "Watchdog margin in seconds (default 60s)");
 
 MODULE_LICENSE("GPL");
-MODULE_ALIAS_MISCDEV(WATCHDOG_MINOR);
+MODULE_ALIAS("platform:coh901327-watchdog");

commit 452190cb0526e9cc11b0998a600411cb9c7cd684
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Mon Oct 3 10:52:58 2011 +0200

    watchdog: move coh901327 state holders
    
    The state holders used in the PM path of the drivers report as
    unused variables when compiling without CONFIG_PM so let's
    move them inside CONFIG_PM.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/drivers/watchdog/coh901327_wdt.c b/drivers/watchdog/coh901327_wdt.c
index 03f449a430d2..5b89f7d6cd0f 100644
--- a/drivers/watchdog/coh901327_wdt.c
+++ b/drivers/watchdog/coh901327_wdt.c
@@ -76,8 +76,6 @@ static int irq;
 static void __iomem *virtbase;
 static unsigned long coh901327_users;
 static unsigned long boot_status;
-static u16 wdogenablestore;
-static u16 irqmaskstore;
 static struct device *parent;
 
 /*
@@ -461,6 +459,10 @@ static int __init coh901327_probe(struct platform_device *pdev)
 }
 
 #ifdef CONFIG_PM
+
+static u16 wdogenablestore;
+static u16 irqmaskstore;
+
 static int coh901327_suspend(struct platform_device *pdev, pm_message_t state)
 {
 	irqmaskstore = readw(virtbase + U300_WDOG_IMR) & 0x0001U;

commit 86b5912880453532440358b1486410ad49ef7672
Author: Yong Zhang <yong.zhang0@gmail.com>
Date:   Wed Sep 7 16:10:55 2011 +0800

    watchdog: irq: Remove IRQF_DISABLED
    
    This flag is a NOOP and can be removed now.
    
    Signed-off-by: Yong Zhang <yong.zhang0@gmail.com>
    Acked-by: Wolfram Sang <w.sang@pengutronix.de>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/drivers/watchdog/coh901327_wdt.c b/drivers/watchdog/coh901327_wdt.c
index 9291506b8b23..03f449a430d2 100644
--- a/drivers/watchdog/coh901327_wdt.c
+++ b/drivers/watchdog/coh901327_wdt.c
@@ -429,7 +429,7 @@ static int __init coh901327_probe(struct platform_device *pdev)
 	writew(U300_WDOG_SR_RESET_STATUS_RESET, virtbase + U300_WDOG_SR);
 
 	irq = platform_get_irq(pdev, 0);
-	if (request_irq(irq, coh901327_interrupt, IRQF_DISABLED,
+	if (request_irq(irq, coh901327_interrupt, 0,
 			DRV_NAME " Bark", pdev)) {
 		ret = -EIO;
 		goto out_no_irq;

commit 42747d712de56cf2087b702d2ad90af114c53138
Author: Wim Van Sebroeck <wim@iguana.be>
Date:   Sat Dec 26 18:55:22 2009 +0000

    [WATCHDOG] watchdog_info constify
    
    make the watchdog_info struct const where possible.
    
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/drivers/watchdog/coh901327_wdt.c b/drivers/watchdog/coh901327_wdt.c
index 923cc68dba26..9291506b8b23 100644
--- a/drivers/watchdog/coh901327_wdt.c
+++ b/drivers/watchdog/coh901327_wdt.c
@@ -257,7 +257,7 @@ static long coh901327_ioctl(struct file *file, unsigned int cmd,
 		struct watchdog_info __user *ident;
 		int __user *i;
 	} uarg;
-	static struct watchdog_info ident = {
+	static const struct watchdog_info ident = {
 		.options		= WDIOF_CARDRESET |
 					  WDIOF_SETTIMEOUT |
 					  WDIOF_KEEPALIVEPING,

commit af901ca181d92aac3a7dc265144a9081a86d8f39
Author: André Goddard Rosa <andre.goddard@gmail.com>
Date:   Sat Nov 14 13:09:05 2009 -0200

    tree-wide: fix assorted typos all over the place
    
    That is "success", "unknown", "through", "performance", "[re|un]mapping"
    , "access", "default", "reasonable", "[con]currently", "temperature"
    , "channel", "[un]used", "application", "example","hierarchy", "therefore"
    , "[over|under]flow", "contiguous", "threshold", "enough" and others.
    
    Signed-off-by: André Goddard Rosa <andre.goddard@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/watchdog/coh901327_wdt.c b/drivers/watchdog/coh901327_wdt.c
index 381026c0bd7b..923cc68dba26 100644
--- a/drivers/watchdog/coh901327_wdt.c
+++ b/drivers/watchdog/coh901327_wdt.c
@@ -508,7 +508,7 @@ void coh901327_watchdog_reset(void)
 	 * deactivating the watchdog before it is shut down by it.
 	 *
 	 * NOTE: on future versions of the watchdog, this restriction is
-	 * gone: the watchdog will be reloaded with a defaul value (1 min)
+	 * gone: the watchdog will be reloaded with a default value (1 min)
 	 * instead of last value, and you can conveniently set the watchdog
 	 * timeout to 10ms (value = 1) without any problems.
 	 */

commit 0ecc3bf47b09de24c6b1163ba6558448aadd31ce
Author: Linus Walleij <linus.walleij@stericsson.com>
Date:   Mon Aug 10 00:04:35 2009 +0200

    [WATCHDOG] Use DIV_ROUND_UP() macro in the coh901327 WDT
    
    I saw Julia Lawalls various commits fixing up the use of rounding
    macros and since my already submitted patch was not caught in this
    I took it upon myself to fix it up for this driver as well.
    
    Signed-off-by: Linus Walleij <linus.walleij@stericsson.com>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/drivers/watchdog/coh901327_wdt.c b/drivers/watchdog/coh901327_wdt.c
index aec7cefdef21..381026c0bd7b 100644
--- a/drivers/watchdog/coh901327_wdt.c
+++ b/drivers/watchdog/coh901327_wdt.c
@@ -110,7 +110,7 @@ static void coh901327_enable(u16 timeout)
 	 * Wait 3 32 kHz cycles for it to take effect
 	 */
 	freq = clk_get_rate(clk);
-	delay_ns = (1000000000 + freq - 1) / freq; /* Freq to ns and round up */
+	delay_ns = DIV_ROUND_UP(1000000000, freq); /* Freq to ns and round up */
 	delay_ns = 3 * delay_ns; /* Wait 3 cycles */
 	ndelay(delay_ns);
 	/* Enable the watchdog interrupt */

commit 5973bee46fe66db94fab198979dec87f263fc2a8
Author: Linus Walleij <linus.walleij@stericsson.com>
Date:   Tue Jul 21 00:40:46 2009 +0200

    [WATCHDOG] Fix COH 901 327 watchdog enablement
    
    Since the COH 901 327 found in U300 is clocked at 32 kHz we need
    to wait for the interrupt clearing flag to propagate through
    hardware in order not to accidentally fire off any interrupts
    when we enable them.
    
    Signed-off-by: Linus Walleij <linus.walleij@stericsson.com>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/drivers/watchdog/coh901327_wdt.c b/drivers/watchdog/coh901327_wdt.c
index fecb307d28e9..aec7cefdef21 100644
--- a/drivers/watchdog/coh901327_wdt.c
+++ b/drivers/watchdog/coh901327_wdt.c
@@ -18,6 +18,7 @@
 #include <linux/bitops.h>
 #include <linux/uaccess.h>
 #include <linux/clk.h>
+#include <linux/delay.h>
 
 #define DRV_NAME "WDOG COH 901 327"
 
@@ -92,6 +93,8 @@ static struct clk *clk;
 static void coh901327_enable(u16 timeout)
 {
 	u16 val;
+	unsigned long freq;
+	unsigned long delay_ns;
 
 	clk_enable(clk);
 	/* Restart timer if it is disabled */
@@ -102,6 +105,14 @@ static void coh901327_enable(u16 timeout)
 	/* Acknowledge any pending interrupt so it doesn't just fire off */
 	writew(U300_WDOG_IER_WILL_BARK_IRQ_ACK_ENABLE,
 	       virtbase + U300_WDOG_IER);
+	/*
+	 * The interrupt is cleared in the 32 kHz clock domain.
+	 * Wait 3 32 kHz cycles for it to take effect
+	 */
+	freq = clk_get_rate(clk);
+	delay_ns = (1000000000 + freq - 1) / freq; /* Freq to ns and round up */
+	delay_ns = 3 * delay_ns; /* Wait 3 cycles */
+	ndelay(delay_ns);
 	/* Enable the watchdog interrupt */
 	writew(U300_WDOG_IMR_WILL_BARK_IRQ_ENABLE, virtbase + U300_WDOG_IMR);
 	/* Activate the watchdog timer */

commit 01480701d5cef5b3b0f8406d2eab1eaff82f9d5c
Author: Linus Walleij <linus.walleij@stericsson.com>
Date:   Wed May 6 15:35:40 2009 +0200

    [WATCHDOG] U300 COH 901 327 watchdog driver
    
    This patch adds support for the U300 COH 901 327 watchdog for the
    U300 platform recently added to RMK:s ARM tree.
    
    Signed-off-by: Linus Walleij <linus.walleij@stericsson.com>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/drivers/watchdog/coh901327_wdt.c b/drivers/watchdog/coh901327_wdt.c
new file mode 100644
index 000000000000..fecb307d28e9
--- /dev/null
+++ b/drivers/watchdog/coh901327_wdt.c
@@ -0,0 +1,537 @@
+/*
+ * coh901327_wdt.c
+ *
+ * Copyright (C) 2008-2009 ST-Ericsson AB
+ * License terms: GNU General Public License (GPL) version 2
+ * Watchdog driver for the ST-Ericsson AB COH 901 327 IP core
+ * Author: Linus Walleij <linus.walleij@stericsson.com>
+ */
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/fs.h>
+#include <linux/miscdevice.h>
+#include <linux/watchdog.h>
+#include <linux/interrupt.h>
+#include <linux/pm.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/bitops.h>
+#include <linux/uaccess.h>
+#include <linux/clk.h>
+
+#define DRV_NAME "WDOG COH 901 327"
+
+/*
+ * COH 901 327 register definitions
+ */
+
+/* WDOG_FEED Register 32bit (-/W) */
+#define U300_WDOG_FR							0x00
+#define U300_WDOG_FR_FEED_RESTART_TIMER					0xFEEDU
+/* WDOG_TIMEOUT Register 32bit (R/W) */
+#define U300_WDOG_TR							0x04
+#define U300_WDOG_TR_TIMEOUT_MASK					0x7FFFU
+/* WDOG_DISABLE1 Register 32bit (-/W) */
+#define U300_WDOG_D1R							0x08
+#define U300_WDOG_D1R_DISABLE1_DISABLE_TIMER				0x2BADU
+/* WDOG_DISABLE2 Register 32bit (R/W) */
+#define U300_WDOG_D2R							0x0C
+#define U300_WDOG_D2R_DISABLE2_DISABLE_TIMER				0xCAFEU
+#define U300_WDOG_D2R_DISABLE_STATUS_DISABLED				0xDABEU
+#define U300_WDOG_D2R_DISABLE_STATUS_ENABLED				0x0000U
+/* WDOG_STATUS Register 32bit (R/W) */
+#define U300_WDOG_SR							0x10
+#define U300_WDOG_SR_STATUS_TIMED_OUT					0xCFE8U
+#define U300_WDOG_SR_STATUS_NORMAL					0x0000U
+#define U300_WDOG_SR_RESET_STATUS_RESET					0xE8B4U
+/* WDOG_COUNT Register 32bit (R/-) */
+#define U300_WDOG_CR							0x14
+#define U300_WDOG_CR_VALID_IND						0x8000U
+#define U300_WDOG_CR_VALID_STABLE					0x0000U
+#define U300_WDOG_CR_COUNT_VALUE_MASK					0x7FFFU
+/* WDOG_JTAGOVR Register 32bit (R/W) */
+#define U300_WDOG_JOR							0x18
+#define U300_WDOG_JOR_JTAG_MODE_IND					0x0002U
+#define U300_WDOG_JOR_JTAG_WATCHDOG_ENABLE				0x0001U
+/* WDOG_RESTART Register 32bit (-/W) */
+#define U300_WDOG_RR							0x1C
+#define U300_WDOG_RR_RESTART_VALUE_RESUME				0xACEDU
+/* WDOG_IRQ_EVENT Register 32bit (R/W) */
+#define U300_WDOG_IER							0x20
+#define U300_WDOG_IER_WILL_BARK_IRQ_EVENT_IND				0x0001U
+#define U300_WDOG_IER_WILL_BARK_IRQ_ACK_ENABLE				0x0001U
+/* WDOG_IRQ_MASK Register 32bit (R/W) */
+#define U300_WDOG_IMR							0x24
+#define U300_WDOG_IMR_WILL_BARK_IRQ_ENABLE				0x0001U
+/* WDOG_IRQ_FORCE Register 32bit (R/W) */
+#define U300_WDOG_IFR							0x28
+#define U300_WDOG_IFR_WILL_BARK_IRQ_FORCE_ENABLE			0x0001U
+
+/* Default timeout in seconds = 1 minute */
+static int margin = 60;
+static resource_size_t phybase;
+static resource_size_t physize;
+static int irq;
+static void __iomem *virtbase;
+static unsigned long coh901327_users;
+static unsigned long boot_status;
+static u16 wdogenablestore;
+static u16 irqmaskstore;
+static struct device *parent;
+
+/*
+ * The watchdog block is of course always clocked, the
+ * clk_enable()/clk_disable() calls are mainly for performing reference
+ * counting higher up in the clock hierarchy.
+ */
+static struct clk *clk;
+
+/*
+ * Enabling and disabling functions.
+ */
+static void coh901327_enable(u16 timeout)
+{
+	u16 val;
+
+	clk_enable(clk);
+	/* Restart timer if it is disabled */
+	val = readw(virtbase + U300_WDOG_D2R);
+	if (val == U300_WDOG_D2R_DISABLE_STATUS_DISABLED)
+		writew(U300_WDOG_RR_RESTART_VALUE_RESUME,
+		       virtbase + U300_WDOG_RR);
+	/* Acknowledge any pending interrupt so it doesn't just fire off */
+	writew(U300_WDOG_IER_WILL_BARK_IRQ_ACK_ENABLE,
+	       virtbase + U300_WDOG_IER);
+	/* Enable the watchdog interrupt */
+	writew(U300_WDOG_IMR_WILL_BARK_IRQ_ENABLE, virtbase + U300_WDOG_IMR);
+	/* Activate the watchdog timer */
+	writew(timeout, virtbase + U300_WDOG_TR);
+	/* Start the watchdog timer */
+	writew(U300_WDOG_FR_FEED_RESTART_TIMER, virtbase + U300_WDOG_FR);
+	/*
+	 * Extra read so that this change propagate in the watchdog.
+	 */
+	(void) readw(virtbase + U300_WDOG_CR);
+	val = readw(virtbase + U300_WDOG_D2R);
+	clk_disable(clk);
+	if (val != U300_WDOG_D2R_DISABLE_STATUS_ENABLED)
+		dev_err(parent,
+			"%s(): watchdog not enabled! D2R value %04x\n",
+			__func__, val);
+}
+
+static void coh901327_disable(void)
+{
+	u16 val;
+
+	clk_enable(clk);
+	/* Disable the watchdog interrupt if it is active */
+	writew(0x0000U, virtbase + U300_WDOG_IMR);
+	/* If the watchdog is currently enabled, attempt to disable it */
+	val = readw(virtbase + U300_WDOG_D2R);
+	if (val != U300_WDOG_D2R_DISABLE_STATUS_DISABLED) {
+		writew(U300_WDOG_D1R_DISABLE1_DISABLE_TIMER,
+		       virtbase + U300_WDOG_D1R);
+		writew(U300_WDOG_D2R_DISABLE2_DISABLE_TIMER,
+		       virtbase + U300_WDOG_D2R);
+		/* Write this twice (else problems occur) */
+		writew(U300_WDOG_D2R_DISABLE2_DISABLE_TIMER,
+		       virtbase + U300_WDOG_D2R);
+	}
+	val = readw(virtbase + U300_WDOG_D2R);
+	clk_disable(clk);
+	if (val != U300_WDOG_D2R_DISABLE_STATUS_DISABLED)
+		dev_err(parent,
+			"%s(): watchdog not disabled! D2R value %04x\n",
+			__func__, val);
+}
+
+static void coh901327_start(void)
+{
+	coh901327_enable(margin * 100);
+}
+
+static void coh901327_keepalive(void)
+{
+	clk_enable(clk);
+	/* Feed the watchdog */
+	writew(U300_WDOG_FR_FEED_RESTART_TIMER,
+	       virtbase + U300_WDOG_FR);
+	clk_disable(clk);
+}
+
+static int coh901327_settimeout(int time)
+{
+	/*
+	 * Max margin is 327 since the 10ms
+	 * timeout register is max
+	 * 0x7FFF = 327670ms ~= 327s.
+	 */
+	if (time <= 0 || time > 327)
+		return -EINVAL;
+
+	margin = time;
+	clk_enable(clk);
+	/* Set new timeout value */
+	writew(margin * 100, virtbase + U300_WDOG_TR);
+	/* Feed the dog */
+	writew(U300_WDOG_FR_FEED_RESTART_TIMER,
+	       virtbase + U300_WDOG_FR);
+	clk_disable(clk);
+	return 0;
+}
+
+/*
+ * This interrupt occurs 10 ms before the watchdog WILL bark.
+ */
+static irqreturn_t coh901327_interrupt(int irq, void *data)
+{
+	u16 val;
+
+	/*
+	 * Ack IRQ? If this occurs we're FUBAR anyway, so
+	 * just acknowledge, disable the interrupt and await the imminent end.
+	 * If you at some point need a host of callbacks to be called
+	 * when the system is about to watchdog-reset, add them here!
+	 *
+	 * NOTE: on future versions of this IP-block, it will be possible
+	 * to prevent a watchdog reset by feeding the watchdog at this
+	 * point.
+	 */
+	clk_enable(clk);
+	val = readw(virtbase + U300_WDOG_IER);
+	if (val == U300_WDOG_IER_WILL_BARK_IRQ_EVENT_IND)
+		writew(U300_WDOG_IER_WILL_BARK_IRQ_ACK_ENABLE,
+		       virtbase + U300_WDOG_IER);
+	writew(0x0000U, virtbase + U300_WDOG_IMR);
+	clk_disable(clk);
+	dev_crit(parent, "watchdog is barking!\n");
+	return IRQ_HANDLED;
+}
+
+/*
+ * Allow only one user (daemon) to open the watchdog
+ */
+static int coh901327_open(struct inode *inode, struct file *file)
+{
+	if (test_and_set_bit(1, &coh901327_users))
+		return -EBUSY;
+	coh901327_start();
+	return nonseekable_open(inode, file);
+}
+
+static int coh901327_release(struct inode *inode, struct file *file)
+{
+	clear_bit(1, &coh901327_users);
+	coh901327_disable();
+	return 0;
+}
+
+static ssize_t coh901327_write(struct file *file, const char __user *data,
+			       size_t len, loff_t *ppos)
+{
+	if (len)
+		coh901327_keepalive();
+	return len;
+}
+
+static long coh901327_ioctl(struct file *file, unsigned int cmd,
+			    unsigned long arg)
+{
+	int ret = -ENOTTY;
+	u16 val;
+	int time;
+	int new_options;
+	union {
+		struct watchdog_info __user *ident;
+		int __user *i;
+	} uarg;
+	static struct watchdog_info ident = {
+		.options		= WDIOF_CARDRESET |
+					  WDIOF_SETTIMEOUT |
+					  WDIOF_KEEPALIVEPING,
+		.identity		= "COH 901 327 Watchdog",
+		.firmware_version	= 1,
+	};
+	uarg.i = (int __user *)arg;
+
+	switch (cmd) {
+	case WDIOC_GETSUPPORT:
+		ret = copy_to_user(uarg.ident, &ident,
+				   sizeof(ident)) ? -EFAULT : 0;
+		break;
+
+	case WDIOC_GETSTATUS:
+		ret = put_user(0, uarg.i);
+		break;
+
+	case WDIOC_GETBOOTSTATUS:
+		ret = put_user(boot_status, uarg.i);
+		break;
+
+	case WDIOC_SETOPTIONS:
+		ret = get_user(new_options, uarg.i);
+		if (ret)
+			break;
+		if (new_options & WDIOS_DISABLECARD)
+			coh901327_disable();
+		if (new_options & WDIOS_ENABLECARD)
+			coh901327_start();
+		ret = 0;
+		break;
+
+	case WDIOC_KEEPALIVE:
+		coh901327_keepalive();
+		ret = 0;
+		break;
+
+	case WDIOC_SETTIMEOUT:
+		ret = get_user(time, uarg.i);
+		if (ret)
+			break;
+
+		ret = coh901327_settimeout(time);
+		if (ret)
+			break;
+		/* Then fall through to return set value */
+
+	case WDIOC_GETTIMEOUT:
+		ret = put_user(margin, uarg.i);
+		break;
+
+	case WDIOC_GETTIMELEFT:
+		clk_enable(clk);
+		/* Read repeatedly until the value is stable! */
+		val = readw(virtbase + U300_WDOG_CR);
+		while (val & U300_WDOG_CR_VALID_IND)
+			val = readw(virtbase + U300_WDOG_CR);
+		val &= U300_WDOG_CR_COUNT_VALUE_MASK;
+		clk_disable(clk);
+		if (val != 0)
+			val /= 100;
+		ret = put_user(val, uarg.i);
+		break;
+	}
+	return ret;
+}
+
+static const struct file_operations coh901327_fops = {
+	.owner		= THIS_MODULE,
+	.llseek		= no_llseek,
+	.write		= coh901327_write,
+	.unlocked_ioctl	= coh901327_ioctl,
+	.open		= coh901327_open,
+	.release	= coh901327_release,
+};
+
+static struct miscdevice coh901327_miscdev = {
+	.minor		= WATCHDOG_MINOR,
+	.name		= "watchdog",
+	.fops		= &coh901327_fops,
+};
+
+static int __exit coh901327_remove(struct platform_device *pdev)
+{
+	misc_deregister(&coh901327_miscdev);
+	coh901327_disable();
+	free_irq(irq, pdev);
+	clk_put(clk);
+	iounmap(virtbase);
+	release_mem_region(phybase, physize);
+	return 0;
+}
+
+
+static int __init coh901327_probe(struct platform_device *pdev)
+{
+	int ret;
+	u16 val;
+	struct resource *res;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res)
+		return -ENOENT;
+
+	parent = &pdev->dev;
+	physize = resource_size(res);
+	phybase = res->start;
+
+	if (request_mem_region(phybase, physize, DRV_NAME) == NULL) {
+		ret = -EBUSY;
+		goto out;
+	}
+
+	virtbase = ioremap(phybase, physize);
+	if (!virtbase) {
+		ret = -ENOMEM;
+		goto out_no_remap;
+	}
+
+	clk = clk_get(&pdev->dev, NULL);
+	if (IS_ERR(clk)) {
+		ret = PTR_ERR(clk);
+		dev_err(&pdev->dev, "could not get clock\n");
+		goto out_no_clk;
+	}
+	ret = clk_enable(clk);
+	if (ret) {
+		dev_err(&pdev->dev, "could not enable clock\n");
+		goto out_no_clk_enable;
+	}
+
+	val = readw(virtbase + U300_WDOG_SR);
+	switch (val) {
+	case U300_WDOG_SR_STATUS_TIMED_OUT:
+		dev_info(&pdev->dev,
+			"watchdog timed out since last chip reset!\n");
+		boot_status = WDIOF_CARDRESET;
+		/* Status will be cleared below */
+		break;
+	case U300_WDOG_SR_STATUS_NORMAL:
+		dev_info(&pdev->dev,
+			"in normal status, no timeouts have occurred.\n");
+		break;
+	default:
+		dev_info(&pdev->dev,
+			"contains an illegal status code (%08x)\n", val);
+		break;
+	}
+
+	val = readw(virtbase + U300_WDOG_D2R);
+	switch (val) {
+	case U300_WDOG_D2R_DISABLE_STATUS_DISABLED:
+		dev_info(&pdev->dev, "currently disabled.\n");
+		break;
+	case U300_WDOG_D2R_DISABLE_STATUS_ENABLED:
+		dev_info(&pdev->dev,
+			 "currently enabled! (disabling it now)\n");
+		coh901327_disable();
+		break;
+	default:
+		dev_err(&pdev->dev,
+			"contains an illegal enable/disable code (%08x)\n",
+			val);
+		break;
+	}
+
+	/* Reset the watchdog */
+	writew(U300_WDOG_SR_RESET_STATUS_RESET, virtbase + U300_WDOG_SR);
+
+	irq = platform_get_irq(pdev, 0);
+	if (request_irq(irq, coh901327_interrupt, IRQF_DISABLED,
+			DRV_NAME " Bark", pdev)) {
+		ret = -EIO;
+		goto out_no_irq;
+	}
+
+	clk_disable(clk);
+
+	ret = misc_register(&coh901327_miscdev);
+	if (ret == 0)
+		dev_info(&pdev->dev,
+			 "initialized. timer margin=%d sec\n", margin);
+	else
+		goto out_no_wdog;
+
+	return 0;
+
+out_no_wdog:
+	free_irq(irq, pdev);
+out_no_irq:
+	clk_disable(clk);
+out_no_clk_enable:
+	clk_put(clk);
+out_no_clk:
+	iounmap(virtbase);
+out_no_remap:
+	release_mem_region(phybase, SZ_4K);
+out:
+	return ret;
+}
+
+#ifdef CONFIG_PM
+static int coh901327_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	irqmaskstore = readw(virtbase + U300_WDOG_IMR) & 0x0001U;
+	wdogenablestore = readw(virtbase + U300_WDOG_D2R);
+	/* If watchdog is on, disable it here and now */
+	if (wdogenablestore == U300_WDOG_D2R_DISABLE_STATUS_ENABLED)
+		coh901327_disable();
+	return 0;
+}
+
+static int coh901327_resume(struct platform_device *pdev)
+{
+	/* Restore the watchdog interrupt */
+	writew(irqmaskstore, virtbase + U300_WDOG_IMR);
+	if (wdogenablestore == U300_WDOG_D2R_DISABLE_STATUS_ENABLED) {
+		/* Restart the watchdog timer */
+		writew(U300_WDOG_RR_RESTART_VALUE_RESUME,
+		       virtbase + U300_WDOG_RR);
+		writew(U300_WDOG_FR_FEED_RESTART_TIMER,
+		       virtbase + U300_WDOG_FR);
+	}
+	return 0;
+}
+#else
+#define coh901327_suspend NULL
+#define coh901327_resume  NULL
+#endif
+
+/*
+ * Mistreating the watchdog is the only way to perform a software reset of the
+ * system on EMP platforms. So we implement this and export a symbol for it.
+ */
+void coh901327_watchdog_reset(void)
+{
+	/* Enable even if on JTAG too */
+	writew(U300_WDOG_JOR_JTAG_WATCHDOG_ENABLE,
+	       virtbase + U300_WDOG_JOR);
+	/*
+	 * Timeout = 5s, we have to wait for the watchdog reset to
+	 * actually take place: the watchdog will be reloaded with the
+	 * default value immediately, so we HAVE to reboot and get back
+	 * into the kernel in 30s, or the device will reboot again!
+	 * The boot loader will typically deactivate the watchdog, so we
+	 * need time enough for the boot loader to get to the point of
+	 * deactivating the watchdog before it is shut down by it.
+	 *
+	 * NOTE: on future versions of the watchdog, this restriction is
+	 * gone: the watchdog will be reloaded with a defaul value (1 min)
+	 * instead of last value, and you can conveniently set the watchdog
+	 * timeout to 10ms (value = 1) without any problems.
+	 */
+	coh901327_enable(500);
+	/* Return and await doom */
+}
+
+static struct platform_driver coh901327_driver = {
+	.driver = {
+		.owner	= THIS_MODULE,
+		.name	= "coh901327_wdog",
+	},
+	.remove		= __exit_p(coh901327_remove),
+	.suspend	= coh901327_suspend,
+	.resume		= coh901327_resume,
+};
+
+static int __init coh901327_init(void)
+{
+	return platform_driver_probe(&coh901327_driver, coh901327_probe);
+}
+module_init(coh901327_init);
+
+static void __exit coh901327_exit(void)
+{
+	platform_driver_unregister(&coh901327_driver);
+}
+module_exit(coh901327_exit);
+
+MODULE_AUTHOR("Linus Walleij <linus.walleij@stericsson.com>");
+MODULE_DESCRIPTION("COH 901 327 Watchdog");
+
+module_param(margin, int, 0);
+MODULE_PARM_DESC(margin, "Watchdog margin in seconds (default 60s)");
+
+MODULE_LICENSE("GPL");
+MODULE_ALIAS_MISCDEV(WATCHDOG_MINOR);
