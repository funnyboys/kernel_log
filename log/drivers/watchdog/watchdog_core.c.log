commit 9232c80659e941ffa6c7bfc96bd64c6172ef0452
Author: Dmitry Safonov <dima@arista.com>
Date:   Sun Feb 23 11:49:39 2020 +0000

    watchdog: Add stop_on_reboot parameter to control reboot policy
    
    Many watchdog drivers use watchdog_stop_on_reboot() helper in order
    to stop the watchdog on system reboot. Unfortunately, this logic is
    coded in driver's probe function and doesn't allows user to decide what
    to do during shutdown/reboot.
    
    On the other side, Xen and Qemu watchdog drivers (xen_wdt and i6300esb)
    may be configured to either send NMI or turn off/reboot VM as
    the watchdog action. As the kernel may stuck at any state, sending NMIs
    can't reliably reboot the VM.
    
    At Arista, we benefited from the following set-up: the emulated watchdogs
    trigger VM reset and softdog is set to catch less severe conditions to
    generate vmcore. Just before reboot watchdog's timeout is increased
    to some good-enough value (3 mins). That keeps watchdog always running
    and guarantees that VM doesn't stuck.
    
    Provide new stop_on_reboot module parameter to let user control
    watchdog's reboot policy.
    
    Cc: Guenter Roeck <linux@roeck-us.net>
    Cc: Wim Van Sebroeck <wim@linux-watchdog.org>
    Cc: linux-watchdog@vger.kernel.org
    Signed-off-by: Dmitry Safonov <dima@arista.com>
    Reviewed-by: Guenter Roeck <linux@roeck-us.net>
    Link: https://lore.kernel.org/r/20200223114939.194754-1-dima@arista.com
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@linux-watchdog.org>

diff --git a/drivers/watchdog/watchdog_core.c b/drivers/watchdog/watchdog_core.c
index 861daf4f37b2..423844757812 100644
--- a/drivers/watchdog/watchdog_core.c
+++ b/drivers/watchdog/watchdog_core.c
@@ -39,6 +39,10 @@
 
 static DEFINE_IDA(watchdog_ida);
 
+static int stop_on_reboot = -1;
+module_param(stop_on_reboot, int, 0444);
+MODULE_PARM_DESC(stop_on_reboot, "Stop watchdogs on reboot (0=keep watching, 1=stop)");
+
 /*
  * Deferred Registration infrastructure.
  *
@@ -254,6 +258,14 @@ static int __watchdog_register_device(struct watchdog_device *wdd)
 		}
 	}
 
+	/* Module parameter to force watchdog policy on reboot. */
+	if (stop_on_reboot != -1) {
+		if (stop_on_reboot)
+			set_bit(WDOG_STOP_ON_REBOOT, &wdd->status);
+		else
+			clear_bit(WDOG_STOP_ON_REBOOT, &wdd->status);
+	}
+
 	if (test_bit(WDOG_STOP_ON_REBOOT, &wdd->status)) {
 		wdd->reboot_nb.notifier_call = watchdog_reboot_notifier;
 

commit 69503e585192fdd84b240f18a0873d20e18a2e0a
Author: Vladis Dronov <vdronov@redhat.com>
Date:   Wed Jan 8 13:53:47 2020 +0100

    watchdog: fix UAF in reboot notifier handling in watchdog core code
    
    After the commit 44ea39420fc9 ("drivers/watchdog: make use of
    devm_register_reboot_notifier()") the struct notifier_block reboot_nb in
    the struct watchdog_device is removed from the reboot notifiers chain at
    the time watchdog's chardev is closed. But at least in i6300esb.c case
    reboot_nb is embedded in the struct esb_dev which can be freed on its
    device removal and before the chardev is closed, thus UAF at reboot:
    
    [    7.728581] esb_probe: esb_dev.watchdog_device ffff91316f91ab28
    ts# uname -r                            note the address ^^^
    5.5.0-rc5-ae6088-wdog
    ts# ./openwdog0 &
    [1] 696
    ts# opened /dev/watchdog0, sleeping 10s...
    ts# echo 1 > /sys/devices/pci0000\:00/0000\:00\:09.0/remove
    [  178.086079] devres:rel_nodes: dev ffff91317668a0b0 data ffff91316f91ab28
               esb_dev.watchdog_device.reboot_nb memory is freed here ^^^
    ts# ...woken up
    [  181.459010] devres:rel_nodes: dev ffff913171781000 data ffff913174a1dae8
    [  181.460195] devm_unreg_reboot_notifier: res ffff913174a1dae8 nb ffff91316f91ab78
                                         attempt to use memory already freed ^^^
    [  181.461063] devm_unreg_reboot_notifier: nb->call 6b6b6b6b6b6b6b6b
    [  181.461243] devm_unreg_reboot_notifier: nb->next 6b6b6b6b6b6b6b6b
                    freed memory is filled with a slub poison ^^^
    [1]+  Done                    ./openwdog0
    ts# reboot
    [  229.921862] systemd-shutdown[1]: Rebooting.
    [  229.939265] notifier_call_chain: nb ffffffff9c6c2f20 nb->next ffffffff9c6d50c0
    [  229.943080] notifier_call_chain: nb ffffffff9c6d50c0 nb->next 6b6b6b6b6b6b6b6b
    [  229.946054] notifier_call_chain: nb 6b6b6b6b6b6b6b6b INVAL
    [  229.957584] general protection fault: 0000 [#1] SMP
    [  229.958770] CPU: 0 PID: 1 Comm: systemd-shutdow Not tainted 5.5.0-rc5-ae6088-wdog
    [  229.960224] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), ...
    [  229.963288] RIP: 0010:notifier_call_chain+0x66/0xd0
    [  229.969082] RSP: 0018:ffffb20dc0013d88 EFLAGS: 00010246
    [  229.970812] RAX: 000000000000002e RBX: 6b6b6b6b6b6b6b6b RCX: 00000000000008b3
    [  229.972929] RDX: 0000000000000000 RSI: 0000000000000096 RDI: ffffffff9ccc46ac
    [  229.975028] RBP: 0000000000000001 R08: 0000000000000000 R09: 00000000000008b3
    [  229.977039] R10: 0000000000000001 R11: ffffffff9c26c740 R12: 0000000000000000
    [  229.979155] R13: 6b6b6b6b6b6b6b6b R14: 0000000000000000 R15: 00000000fffffffa
    ...   slub_debug=FZP poison ^^^
    [  229.989089] Call Trace:
    [  229.990157]  blocking_notifier_call_chain+0x43/0x59
    [  229.991401]  kernel_restart_prepare+0x14/0x30
    [  229.992607]  kernel_restart+0x9/0x30
    [  229.993800]  __do_sys_reboot+0x1d2/0x210
    [  230.000149]  do_syscall_64+0x3d/0x130
    [  230.001277]  entry_SYSCALL_64_after_hwframe+0x44/0xa9
    [  230.002639] RIP: 0033:0x7f5461bdd177
    [  230.016402] Modules linked in: i6300esb
    [  230.050261] Kernel panic - not syncing: Attempted to kill init! exitcode=0x0000000b
    
    Fix the crash by reverting 44ea39420fc9 so unregister_reboot_notifier()
    is called when watchdog device is removed. This also makes handling of
    the reboot notifier unified with the handling of the restart handler,
    which is freed with unregister_restart_handler() in the same place.
    
    Fixes: 44ea39420fc9 ("drivers/watchdog: make use of devm_register_reboot_notifier()")
    Cc: stable@vger.kernel.org # v4.15+
    Signed-off-by: Vladis Dronov <vdronov@redhat.com>
    Reviewed-by: Guenter Roeck <linux@roeck-us.net>
    Link: https://lore.kernel.org/r/20200108125347.6067-1-vdronov@redhat.com
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@linux-watchdog.org>

diff --git a/drivers/watchdog/watchdog_core.c b/drivers/watchdog/watchdog_core.c
index 21e8085b848b..861daf4f37b2 100644
--- a/drivers/watchdog/watchdog_core.c
+++ b/drivers/watchdog/watchdog_core.c
@@ -147,6 +147,25 @@ int watchdog_init_timeout(struct watchdog_device *wdd,
 }
 EXPORT_SYMBOL_GPL(watchdog_init_timeout);
 
+static int watchdog_reboot_notifier(struct notifier_block *nb,
+				    unsigned long code, void *data)
+{
+	struct watchdog_device *wdd;
+
+	wdd = container_of(nb, struct watchdog_device, reboot_nb);
+	if (code == SYS_DOWN || code == SYS_HALT) {
+		if (watchdog_active(wdd)) {
+			int ret;
+
+			ret = wdd->ops->stop(wdd);
+			if (ret)
+				return NOTIFY_BAD;
+		}
+	}
+
+	return NOTIFY_DONE;
+}
+
 static int watchdog_restart_notifier(struct notifier_block *nb,
 				     unsigned long action, void *data)
 {
@@ -235,6 +254,19 @@ static int __watchdog_register_device(struct watchdog_device *wdd)
 		}
 	}
 
+	if (test_bit(WDOG_STOP_ON_REBOOT, &wdd->status)) {
+		wdd->reboot_nb.notifier_call = watchdog_reboot_notifier;
+
+		ret = register_reboot_notifier(&wdd->reboot_nb);
+		if (ret) {
+			pr_err("watchdog%d: Cannot register reboot notifier (%d)\n",
+			       wdd->id, ret);
+			watchdog_dev_unregister(wdd);
+			ida_simple_remove(&watchdog_ida, id);
+			return ret;
+		}
+	}
+
 	if (wdd->ops->restart) {
 		wdd->restart_nb.notifier_call = watchdog_restart_notifier;
 
@@ -289,6 +321,9 @@ static void __watchdog_unregister_device(struct watchdog_device *wdd)
 	if (wdd->ops->restart)
 		unregister_restart_handler(&wdd->restart_nb);
 
+	if (test_bit(WDOG_STOP_ON_REBOOT, &wdd->status))
+		unregister_reboot_notifier(&wdd->reboot_nb);
+
 	watchdog_dev_unregister(wdd);
 	ida_simple_remove(&watchdog_ida, wdd->id);
 }

commit d0173278935a9c7ea268cc8baa8b669ecb57c0e3
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Thu Jun 20 09:28:46 2019 -0700

    watchdog: convert remaining drivers to use SPDX license identifier
    
    This gets rid of the unnecessary license boilerplate, and avoids
    having to deal with individual patches one by one.
    
    No functional changes.
    
    Reviewed-by: Jerry Hoemann <jerry.hoemann@hpe.com>
    Acked-by: Sylvain Lemieux <slemieux.tyco@gmail.com>
    Reviewed-by: Matthias Brugger <matthias.bgg@gmail.com>
    Acked-by: William Breathitt Gray <vilhelm.gray@gmail.com>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@linux-watchdog.org>

diff --git a/drivers/watchdog/watchdog_core.c b/drivers/watchdog/watchdog_core.c
index cf3247224a6e..21e8085b848b 100644
--- a/drivers/watchdog/watchdog_core.c
+++ b/drivers/watchdog/watchdog_core.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  *	watchdog_core.c
  *
@@ -16,11 +17,6 @@
  *	  Satyam Sharma <satyam@infradead.org>
  *	  Randy Dunlap <randy.dunlap@oracle.com>
  *
- *	This program is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU General Public License
- *	as published by the Free Software Foundation; either version
- *	2 of the License, or (at your option) any later version.
- *
  *	Neither Alan Cox, CymruNet Ltd., Wim Van Sebroeck nor Iguana vzw.
  *	admit liability nor provide warranty for any of this software.
  *	This material is provided "AS-IS" and at no charge.

commit b608075e4bd6ad21968e8bfddd396c43b625e2b1
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Sat May 18 23:27:17 2019 +0200

    watchdog: let core print error message when registering device fails
    
    So we can remove boilerplate code from drivers.
    
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@linux-watchdog.org>

diff --git a/drivers/watchdog/watchdog_core.c b/drivers/watchdog/watchdog_core.c
index 9fd096af0cc5..cf3247224a6e 100644
--- a/drivers/watchdog/watchdog_core.c
+++ b/drivers/watchdog/watchdog_core.c
@@ -264,6 +264,7 @@ static int __watchdog_register_device(struct watchdog_device *wdd)
 
 int watchdog_register_device(struct watchdog_device *wdd)
 {
+	const char *dev_str;
 	int ret = 0;
 
 	mutex_lock(&wtd_deferred_reg_mutex);
@@ -272,6 +273,14 @@ int watchdog_register_device(struct watchdog_device *wdd)
 	else
 		watchdog_deferred_registration_add(wdd);
 	mutex_unlock(&wtd_deferred_reg_mutex);
+
+	if (ret) {
+		dev_str = wdd->parent ? dev_name(wdd->parent) :
+			  (const char *)wdd->info->identity;
+		pr_err("%s: failed to register watchdog device (err = %d)\n",
+			dev_str, ret);
+	}
+
 	return ret;
 }
 EXPORT_SYMBOL_GPL(watchdog_register_device);

commit 80030425e0207172cd68a8952c5054db85ffa85f
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Sat May 18 23:27:16 2019 +0200

    watchdog: make watchdog_deferred_registration_add() void
    
    It cannot fail, so no return value needed.
    
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@linux-watchdog.org>

diff --git a/drivers/watchdog/watchdog_core.c b/drivers/watchdog/watchdog_core.c
index 62be9e52a4de..9fd096af0cc5 100644
--- a/drivers/watchdog/watchdog_core.c
+++ b/drivers/watchdog/watchdog_core.c
@@ -60,11 +60,10 @@ static DEFINE_MUTEX(wtd_deferred_reg_mutex);
 static LIST_HEAD(wtd_deferred_reg_list);
 static bool wtd_deferred_reg_done;
 
-static int watchdog_deferred_registration_add(struct watchdog_device *wdd)
+static void watchdog_deferred_registration_add(struct watchdog_device *wdd)
 {
 	list_add_tail(&wdd->deferred,
 		      &wtd_deferred_reg_list);
-	return 0;
 }
 
 static void watchdog_deferred_registration_del(struct watchdog_device *wdd)
@@ -265,13 +264,13 @@ static int __watchdog_register_device(struct watchdog_device *wdd)
 
 int watchdog_register_device(struct watchdog_device *wdd)
 {
-	int ret;
+	int ret = 0;
 
 	mutex_lock(&wtd_deferred_reg_mutex);
 	if (wtd_deferred_reg_done)
 		ret = __watchdog_register_device(wdd);
 	else
-		ret = watchdog_deferred_registration_add(wdd);
+		watchdog_deferred_registration_add(wdd);
 	mutex_unlock(&wtd_deferred_reg_mutex);
 	return ret;
 }

commit e907972be3816d741f08e82f08c4e88bc807ca36
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Fri Apr 19 20:15:47 2019 +0200

    watchdog: add error messages when initializing timeout fails
    
    This not only removes boilerplate code from watchdog drivers, it can
    also be more specific which of the supplied value actually fails. Also,
    the loglevel becomes now consistent across drivers.
    
    Reviewed-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@linux-watchdog.org>

diff --git a/drivers/watchdog/watchdog_core.c b/drivers/watchdog/watchdog_core.c
index 21e53cc49977..62be9e52a4de 100644
--- a/drivers/watchdog/watchdog_core.c
+++ b/drivers/watchdog/watchdog_core.c
@@ -115,6 +115,8 @@ static void watchdog_check_min_max_timeout(struct watchdog_device *wdd)
 int watchdog_init_timeout(struct watchdog_device *wdd,
 				unsigned int timeout_parm, struct device *dev)
 {
+	const char *dev_str = wdd->parent ? dev_name(wdd->parent) :
+			      (const char *)wdd->info->identity;
 	unsigned int t = 0;
 	int ret = 0;
 
@@ -126,6 +128,8 @@ int watchdog_init_timeout(struct watchdog_device *wdd,
 			wdd->timeout = timeout_parm;
 			return 0;
 		}
+		pr_err("%s: driver supplied timeout (%u) out of range\n",
+			dev_str, timeout_parm);
 		ret = -EINVAL;
 	}
 
@@ -136,9 +140,14 @@ int watchdog_init_timeout(struct watchdog_device *wdd,
 			wdd->timeout = t;
 			return 0;
 		}
+		pr_err("%s: DT supplied timeout (%u) out of range\n", dev_str, t);
 		ret = -EINVAL;
 	}
 
+	if (ret < 0 && wdd->timeout)
+		pr_warn("%s: falling back to default timeout (%u)\n", dev_str,
+			wdd->timeout);
+
 	return ret;
 }
 EXPORT_SYMBOL_GPL(watchdog_init_timeout);

commit 34ef4087a1d50f5481732ad85544362516e8185f
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Fri Apr 19 20:15:46 2019 +0200

    watchdog: refactor watchdog_init_timeout
    
    The function is not easy to read and has a problem: -EINVAL is returned
    when the module parameter is invalid but the DT parameter is OK.
    
    Refactor the code to have the same pattern of checks for the module
    parameter and DT. Further ones can be easily added in the future if the
    need arises. The above mentioned problem is fixed, too.
    
    Some documentation is added to describe the different handlings of '0'
    for the module parameter and the DT property.
    
    Reviewed-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@linux-watchdog.org>

diff --git a/drivers/watchdog/watchdog_core.c b/drivers/watchdog/watchdog_core.c
index eb8fa25f8eb2..21e53cc49977 100644
--- a/drivers/watchdog/watchdog_core.c
+++ b/drivers/watchdog/watchdog_core.c
@@ -105,9 +105,12 @@ static void watchdog_check_min_max_timeout(struct watchdog_device *wdd)
  * timeout module parameter (if it is valid value) or the timeout-sec property
  * (only if it is a valid value and the timeout_parm is out of bounds).
  * If none of them are valid then we keep the old value (which should normally
- * be the default timeout value).
+ * be the default timeout value). Note that for the module parameter, '0' means
+ * 'use default' while it is an invalid value for the timeout-sec property.
+ * It should simply be dropped if you want to use the default value then.
  *
- * A zero is returned on success and -EINVAL for failure.
+ * A zero is returned on success or -EINVAL if all provided values are out of
+ * bounds.
  */
 int watchdog_init_timeout(struct watchdog_device *wdd,
 				unsigned int timeout_parm, struct device *dev)
@@ -117,22 +120,24 @@ int watchdog_init_timeout(struct watchdog_device *wdd,
 
 	watchdog_check_min_max_timeout(wdd);
 
-	/* try to get the timeout module parameter first */
-	if (!watchdog_timeout_invalid(wdd, timeout_parm) && timeout_parm) {
-		wdd->timeout = timeout_parm;
-		return ret;
-	}
-	if (timeout_parm)
+	/* check the driver supplied value (likely a module parameter) first */
+	if (timeout_parm) {
+		if (!watchdog_timeout_invalid(wdd, timeout_parm)) {
+			wdd->timeout = timeout_parm;
+			return 0;
+		}
 		ret = -EINVAL;
+	}
 
 	/* try to get the timeout_sec property */
-	if (dev == NULL || dev->of_node == NULL)
-		return ret;
-	of_property_read_u32(dev->of_node, "timeout-sec", &t);
-	if (!watchdog_timeout_invalid(wdd, t) && t)
-		wdd->timeout = t;
-	else
+	if (dev && dev->of_node &&
+	    of_property_read_u32(dev->of_node, "timeout-sec", &t) == 0) {
+		if (t && !watchdog_timeout_invalid(wdd, t)) {
+			wdd->timeout = t;
+			return 0;
+		}
 		ret = -EINVAL;
+	}
 
 	return ret;
 }

commit 8bc86475a0ded71bb0cfa95d88b1708292741356
Author: Corentin Labbe <clabbe.montjoie@gmail.com>
Date:   Wed Dec 13 20:41:40 2017 +0100

    watchdog: document watchdog_init_timeout() wdd parameter
    
    All parameters of watchdog_init_timeout() are documented with exception
    of wdd, thus generating a build warning.
    
    This patch document it and so remove the following build warning:
    drivers/watchdog/watchdog_core.c:113: warning: No description found for parameter 'wdd'
    
    Signed-off-by: Corentin Labbe <clabbe.montjoie@gmail.com>
    Reviewed-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/drivers/watchdog/watchdog_core.c b/drivers/watchdog/watchdog_core.c
index 8a8d952f8df9..eb8fa25f8eb2 100644
--- a/drivers/watchdog/watchdog_core.c
+++ b/drivers/watchdog/watchdog_core.c
@@ -97,6 +97,7 @@ static void watchdog_check_min_max_timeout(struct watchdog_device *wdd)
 
 /**
  * watchdog_init_timeout() - initialize the timeout field
+ * @wdd: watchdog device
  * @timeout_parm: timeout module parameter
  * @dev: Device that stores the timeout-sec property
  *

commit 44ea39420fc95e7432ddc91de4eb58c7470ab897
Author: Andrey Smirnov <andrew.smirnov@gmail.com>
Date:   Fri Nov 17 15:31:01 2017 -0800

    drivers/watchdog: make use of devm_register_reboot_notifier()
    
    Save a bit of cleanup code by leveraging newly added
    devm_register_reboot_notifier().
    
    [akpm@linux-foundation.org: small cleanup: avoid 80-col tricks]
    Link: http://lkml.kernel.org/r/20170411160615.9784-1-andrew.smirnov@gmail.com
    Signed-off-by: Andrey Smirnov <andrew.smirnov@gmail.com>
    Acked-by: Guenter Roeck <linux@roeck-us.net>
    Cc: Chris Healy <cphealy@gmail.com>
    Cc: Wim Van Sebroeck <wim@iguana.be>
    Cc: Andy Shevchenko <andy.shevchenko@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/watchdog/watchdog_core.c b/drivers/watchdog/watchdog_core.c
index 74265b2f806c..8a8d952f8df9 100644
--- a/drivers/watchdog/watchdog_core.c
+++ b/drivers/watchdog/watchdog_core.c
@@ -137,25 +137,6 @@ int watchdog_init_timeout(struct watchdog_device *wdd,
 }
 EXPORT_SYMBOL_GPL(watchdog_init_timeout);
 
-static int watchdog_reboot_notifier(struct notifier_block *nb,
-				    unsigned long code, void *data)
-{
-	struct watchdog_device *wdd = container_of(nb, struct watchdog_device,
-						   reboot_nb);
-
-	if (code == SYS_DOWN || code == SYS_HALT) {
-		if (watchdog_active(wdd)) {
-			int ret;
-
-			ret = wdd->ops->stop(wdd);
-			if (ret)
-				return NOTIFY_BAD;
-		}
-	}
-
-	return NOTIFY_DONE;
-}
-
 static int watchdog_restart_notifier(struct notifier_block *nb,
 				     unsigned long action, void *data)
 {
@@ -244,19 +225,6 @@ static int __watchdog_register_device(struct watchdog_device *wdd)
 		}
 	}
 
-	if (test_bit(WDOG_STOP_ON_REBOOT, &wdd->status)) {
-		wdd->reboot_nb.notifier_call = watchdog_reboot_notifier;
-
-		ret = register_reboot_notifier(&wdd->reboot_nb);
-		if (ret) {
-			pr_err("watchdog%d: Cannot register reboot notifier (%d)\n",
-			       wdd->id, ret);
-			watchdog_dev_unregister(wdd);
-			ida_simple_remove(&watchdog_ida, wdd->id);
-			return ret;
-		}
-	}
-
 	if (wdd->ops->restart) {
 		wdd->restart_nb.notifier_call = watchdog_restart_notifier;
 
@@ -302,9 +270,6 @@ static void __watchdog_unregister_device(struct watchdog_device *wdd)
 	if (wdd->ops->restart)
 		unregister_restart_handler(&wdd->restart_nb);
 
-	if (test_bit(WDOG_STOP_ON_REBOOT, &wdd->status))
-		unregister_reboot_notifier(&wdd->reboot_nb);
-
 	watchdog_dev_unregister(wdd);
 	ida_simple_remove(&watchdog_ida, wdd->id);
 }

commit 2e91838bf7ffdedabdb29e091207d6531d04ef4f
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Tue Aug 9 22:34:31 2016 -0700

    watchdog: core: Fix devres_alloc() allocation size
    
    Coverity reports:
    
    Passing argument 152UL /* sizeof (*wdd) */ to function __devres_alloc_node
    and then casting the return value to struct watchdog_device ** is
    suspicious.
    
    Allocation size needs to be sizeof(*rcwdd), not sizeof(*wdd).
    
    Fixes: 83fbae5a148c ("watchdog: Add a device managed API for ...")
    Cc: Neil Armstrong <narmstrong@baylibre.com>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Acked-by: Neil Armstrong <narmstrong@baylibre.com>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/drivers/watchdog/watchdog_core.c b/drivers/watchdog/watchdog_core.c
index 6abb83cd7681..74265b2f806c 100644
--- a/drivers/watchdog/watchdog_core.c
+++ b/drivers/watchdog/watchdog_core.c
@@ -349,7 +349,7 @@ int devm_watchdog_register_device(struct device *dev,
 	struct watchdog_device **rcwdd;
 	int ret;
 
-	rcwdd = devres_alloc(devm_watchdog_unregister_device, sizeof(*wdd),
+	rcwdd = devres_alloc(devm_watchdog_unregister_device, sizeof(*rcwdd),
 			     GFP_KERNEL);
 	if (!rcwdd)
 		return -ENOMEM;

commit 1894cad9bf2c10359b2b7a0c00e564698f712751
Author: Pratyush Anand <panand@redhat.com>
Date:   Tue May 31 14:08:08 2016 +0800

    watchdog: skip min and max timeout validity check when max_hw_heartbeat_ms is defined
    
    When max_hw_heartbeat_ms has a none zero value, max_timeout is not used.
    So it's value can be 0. In such case if a driver uses min_timeout
    functionality, then check will always fail.
    
    This patch fixes above issue.
    
    Signed-off-by: Pratyush Anand <panand@redhat.com>
    Signed-off-by: Fu Wei <fu.wei@linaro.org>
    Reviewed-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/drivers/watchdog/watchdog_core.c b/drivers/watchdog/watchdog_core.c
index f4f02d2763ec..6abb83cd7681 100644
--- a/drivers/watchdog/watchdog_core.c
+++ b/drivers/watchdog/watchdog_core.c
@@ -88,7 +88,7 @@ static void watchdog_check_min_max_timeout(struct watchdog_device *wdd)
 	 * Check that we have valid min and max timeout values, if
 	 * not reset them both to 0 (=not used or unknown)
 	 */
-	if (wdd->min_timeout > wdd->max_timeout) {
+	if (!wdd->max_hw_heartbeat_ms && wdd->min_timeout > wdd->max_timeout) {
 		pr_info("Invalid min and max timeout values, resetting to 0!\n");
 		wdd->min_timeout = 0;
 		wdd->max_timeout = 0;

commit 83fbae5a148cc1cd53e5be1a28edb3b6701b7af2
Author: Neil Armstrong <narmstrong@baylibre.com>
Date:   Fri May 27 17:33:54 2016 +0200

    watchdog: Add a device managed API for watchdog_register_device()
    
    This helps in reducing code in .remove callbacks and sometimes
    dropping .remove callbacks entirely.
    
    Signed-off-by: Neil Armstrong <narmstrong@baylibre.com>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/drivers/watchdog/watchdog_core.c b/drivers/watchdog/watchdog_core.c
index 7c3ba58ae1be..f4f02d2763ec 100644
--- a/drivers/watchdog/watchdog_core.c
+++ b/drivers/watchdog/watchdog_core.c
@@ -329,6 +329,43 @@ void watchdog_unregister_device(struct watchdog_device *wdd)
 
 EXPORT_SYMBOL_GPL(watchdog_unregister_device);
 
+static void devm_watchdog_unregister_device(struct device *dev, void *res)
+{
+	watchdog_unregister_device(*(struct watchdog_device **)res);
+}
+
+/**
+ * devm_watchdog_register_device() - resource managed watchdog_register_device()
+ * @dev: device that is registering this watchdog device
+ * @wdd: watchdog device
+ *
+ * Managed watchdog_register_device(). For watchdog device registered by this
+ * function,  watchdog_unregister_device() is automatically called on driver
+ * detach. See watchdog_register_device() for more information.
+ */
+int devm_watchdog_register_device(struct device *dev,
+				struct watchdog_device *wdd)
+{
+	struct watchdog_device **rcwdd;
+	int ret;
+
+	rcwdd = devres_alloc(devm_watchdog_unregister_device, sizeof(*wdd),
+			     GFP_KERNEL);
+	if (!rcwdd)
+		return -ENOMEM;
+
+	ret = watchdog_register_device(wdd);
+	if (!ret) {
+		*rcwdd = wdd;
+		devres_add(dev, rcwdd);
+	} else {
+		devres_free(rcwdd);
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(devm_watchdog_register_device);
+
 static int __init watchdog_deferred_registration(void)
 {
 	mutex_lock(&wtd_deferred_reg_mutex);

commit 1f93d2abf488c6a41bdd5e6caf80b559493eea8d
Merge: 48dd7cefa010 540be8b2add1
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed May 25 10:19:17 2016 -0700

    Merge git://www.linux-watchdog.org/linux-watchdog
    
    Pull watchdog updates from Wim Van Sebroeck:
    
     - add support for Fintek F81865 Super-IO chip
    
     - add support for watchdogs (RWDT and SWDT) found on RCar Gen3 based
       SoCs from Renesas
    
     - octeon: Handle the FROZEN hot plug notifier actions
    
     - f71808e_wdt fixes and cleanups
    
     - some small improvements in code and documentation
    
    * git://www.linux-watchdog.org/linux-watchdog:
      MAINTAINERS: Add file patterns for watchdog device tree bindings
      Documentation: Add ebc-c384_wdt watchdog-parameters.txt entry
      watchdog: shwdt: Use setup_timer()
      watchdog: cpwd: Use setup_timer()
      arm64: defconfig: enable Renesas Watchdog Timer
      watchdog: renesas-wdt: add driver
      watchdog: remove error message when unable to allocate watchdog device
      watchdog: f71808e_wdt: Fix WDTMOUT_STS register read
      watchdog: f71808e_wdt: Fix typo
      watchdog: f71808e_wdt: Add F81865 support
      watchdog: sp5100_tco: properly check for new register layouts
      watchdog: core: Fix circular locking dependency
      watchdog: core: fix trivial typo in a comment
      watchdog: hpwdt: Adjust documentation to match latest kernel module parameters.
      watchdog: imx2_wdt: add external reset support via dt prop
      watchdog: octeon: Handle the FROZEN hot plug notifier actions.
      watchdog: qcom: Report reboot reason

commit 358d5a565fa6a5f51fcd04f8e890a0a474a814fe
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Tue Apr 12 17:56:11 2016 +0200

    watchdog: core: fix trivial typo in a comment
    
    Let's have balanced round brackets.
    
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/drivers/watchdog/watchdog_core.c b/drivers/watchdog/watchdog_core.c
index c1658fe73d58..6249ed34214a 100644
--- a/drivers/watchdog/watchdog_core.c
+++ b/drivers/watchdog/watchdog_core.c
@@ -104,7 +104,7 @@ static void watchdog_check_min_max_timeout(struct watchdog_device *wdd)
  * timeout module parameter (if it is valid value) or the timeout-sec property
  * (only if it is a valid value and the timeout_parm is out of bounds).
  * If none of them are valid then we keep the old value (which should normally
- * be the default timeout value.
+ * be the default timeout value).
  *
  * A zero is returned on success and -EINVAL for failure.
  */

commit c01e01597cbd0cf0571c2b05bf9e2245afb4478d
Author: Masanari Iida <standby24x7@gmail.com>
Date:   Wed Apr 20 00:27:33 2016 +0900

    treewide: Fix typos in printk
    
    This patch fix spelling typos in printk from various part
    of the codes.
    
    Signed-off-by: Masanari Iida <standby24x7@gmail.com>
    Acked-by: Randy Dunlap <rdunlap@infradead.org>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/watchdog/watchdog_core.c b/drivers/watchdog/watchdog_core.c
index c1658fe73d58..981a668b17e3 100644
--- a/drivers/watchdog/watchdog_core.c
+++ b/drivers/watchdog/watchdog_core.c
@@ -262,7 +262,7 @@ static int __watchdog_register_device(struct watchdog_device *wdd)
 
 		ret = register_restart_handler(&wdd->restart_nb);
 		if (ret)
-			pr_warn("watchog%d: Cannot register restart handler (%d)\n",
+			pr_warn("watchdog%d: Cannot register restart handler (%d)\n",
 				wdd->id, ret);
 	}
 

commit d0684c8a9354953efdea214b437445c00743cf49
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Sun Feb 28 13:12:17 2016 -0800

    watchdog: Make stop function optional
    
    Not all hardware watchdogs can be stopped. The driver for
    such watchdogs would typically only set the WATCHDOG_HW_RUNNING
    flag in its stop function. Make the stop function optional and set
    WATCHDOG_HW_RUNNING in the watchdog core if it is not provided.
    
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/drivers/watchdog/watchdog_core.c b/drivers/watchdog/watchdog_core.c
index d9b3c9c023c4..c1658fe73d58 100644
--- a/drivers/watchdog/watchdog_core.c
+++ b/drivers/watchdog/watchdog_core.c
@@ -199,7 +199,7 @@ static int __watchdog_register_device(struct watchdog_device *wdd)
 		return -EINVAL;
 
 	/* Mandatory operations need to be supported */
-	if (wdd->ops->start == NULL || wdd->ops->stop == NULL)
+	if (!wdd->ops->start || (!wdd->ops->stop && !wdd->max_hw_heartbeat_ms))
 		return -EINVAL;
 
 	watchdog_check_min_max_timeout(wdd);

commit 4d8b229d5ea610affe672e919021e9d02cd877da
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Fri Feb 26 17:32:49 2016 -0800

    watchdog: Add 'action' and 'data' parameters to restart handler callback
    
    The 'action' (or restart mode) and data parameters may be used by restart
    handlers, so they should be passed to the restart callback functions.
    
    Cc: Sylvain Lemieux <slemieux@tycoint.com>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/drivers/watchdog/watchdog_core.c b/drivers/watchdog/watchdog_core.c
index e600fd93b7de..d9b3c9c023c4 100644
--- a/drivers/watchdog/watchdog_core.c
+++ b/drivers/watchdog/watchdog_core.c
@@ -164,7 +164,7 @@ static int watchdog_restart_notifier(struct notifier_block *nb,
 
 	int ret;
 
-	ret = wdd->ops->restart(wdd);
+	ret = wdd->ops->restart(wdd, action, data);
 	if (ret)
 		return NOTIFY_BAD;
 

commit 0254e953537c92df3e7d0176f401a211e944fd61
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Sun Jan 3 15:11:58 2016 -0800

    watchdog: Drop pointer to watchdog device from struct watchdog_device
    
    The lifetime of the watchdog device pointer is different from the lifetime
    of its character device. Remove it entirely to avoid race conditions.
    
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/drivers/watchdog/watchdog_core.c b/drivers/watchdog/watchdog_core.c
index ec1ab6c1a80b..e600fd93b7de 100644
--- a/drivers/watchdog/watchdog_core.c
+++ b/drivers/watchdog/watchdog_core.c
@@ -249,8 +249,8 @@ static int __watchdog_register_device(struct watchdog_device *wdd)
 
 		ret = register_reboot_notifier(&wdd->reboot_nb);
 		if (ret) {
-			dev_err(wdd->dev, "Cannot register reboot notifier (%d)\n",
-				ret);
+			pr_err("watchdog%d: Cannot register reboot notifier (%d)\n",
+			       wdd->id, ret);
 			watchdog_dev_unregister(wdd);
 			ida_simple_remove(&watchdog_ida, wdd->id);
 			return ret;
@@ -262,8 +262,8 @@ static int __watchdog_register_device(struct watchdog_device *wdd)
 
 		ret = register_restart_handler(&wdd->restart_nb);
 		if (ret)
-			dev_warn(wdd->dev, "Cannot register restart handler (%d)\n",
-				 ret);
+			pr_warn("watchog%d: Cannot register restart handler (%d)\n",
+				wdd->id, ret);
 	}
 
 	return 0;

commit b4ffb1909843b28f3b1b60197d517b123b7a9b66
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Fri Dec 25 16:01:42 2015 -0800

    watchdog: Separate and maintain variables based on variable lifetime
    
    All variables required by the watchdog core to manage a watchdog are
    currently stored in struct watchdog_device. The lifetime of those
    variables is determined by the watchdog driver. However, the lifetime
    of variables used by the watchdog core differs from the lifetime of
    struct watchdog_device. To remedy this situation, watchdog drivers
    can implement ref and unref callbacks, to be used by the watchdog
    core to lock struct watchdog_device in memory.
    
    While this solves the immediate problem, it depends on watchdog drivers
    to actually implement the ref/unref callbacks. This is error prone,
    often not implemented in the first place, or not implemented correctly.
    
    To solve the problem without requiring driver support, split the variables
    in struct watchdog_device into two data structures - one for variables
    associated with the watchdog driver, one for variables associated with
    the watchdog core. With this approach, the watchdog core can keep track
    of its variable lifetime and no longer depends on ref/unref callbacks
    in the driver. As a side effect, some of the variables originally in
    struct watchdog_driver are now private to the watchdog core and no longer
    visible in watchdog drivers.
    
    As a side effect of the changes made, an ioctl will now always fail
    with -ENODEV after a watchdog device was unregistered with the character
    device still open. Previously, it would only fail with -ENODEV in some
    situations. Also, ioctl operations are now atomic from driver perspective.
    With this change, it is now guaranteed that the driver will not unregister
    a watchdog between a timeout change and the subsequent ping.
    
    The 'ref' and 'unref' callbacks in struct watchdog_driver are no longer
    used and marked as deprecated.
    
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/drivers/watchdog/watchdog_core.c b/drivers/watchdog/watchdog_core.c
index f0293f7d2b80..ec1ab6c1a80b 100644
--- a/drivers/watchdog/watchdog_core.c
+++ b/drivers/watchdog/watchdog_core.c
@@ -210,8 +210,6 @@ static int __watchdog_register_device(struct watchdog_device *wdd)
 	 * corrupted in a later stage then we expect a kernel panic!
 	 */
 
-	mutex_init(&wdd->lock);
-
 	/* Use alias for watchdog id if possible */
 	if (wdd->parent) {
 		ret = of_alias_get_id(wdd->parent->of_node, "watchdog");

commit 32ecc6392654a0db34b310e8924b5b2c3b8bf503
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Fri Dec 25 16:01:40 2015 -0800

    watchdog: Create watchdog device in watchdog_dev.c
    
    The watchdog character device is currently created in watchdog_dev.c,
    and the watchdog device in watchdog_core.c. This results in
    cross-dependencies, since device creation needs to know the watchdog
    character device number as well as the watchdog class, both of which
    reside in watchdog_dev.c.
    
    Create the watchdog device in watchdog_dev.c to simplify the code.
    
    Inspired by earlier patch set from Damien Riegel.
    
    Cc: Damien Riegel <damien.riegel@savoirfairelinux.com>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/drivers/watchdog/watchdog_core.c b/drivers/watchdog/watchdog_core.c
index 551af042867c..f0293f7d2b80 100644
--- a/drivers/watchdog/watchdog_core.c
+++ b/drivers/watchdog/watchdog_core.c
@@ -42,7 +42,6 @@
 #include "watchdog_core.h"	/* For watchdog_dev_register/... */
 
 static DEFINE_IDA(watchdog_ida);
-static struct class *watchdog_class;
 
 /*
  * Deferred Registration infrastructure.
@@ -194,7 +193,7 @@ EXPORT_SYMBOL_GPL(watchdog_set_restart_priority);
 
 static int __watchdog_register_device(struct watchdog_device *wdd)
 {
-	int ret, id = -1, devno;
+	int ret, id = -1;
 
 	if (wdd == NULL || wdd->info == NULL || wdd->ops == NULL)
 		return -EINVAL;
@@ -247,16 +246,6 @@ static int __watchdog_register_device(struct watchdog_device *wdd)
 		}
 	}
 
-	devno = wdd->cdev.dev;
-	wdd->dev = device_create(watchdog_class, wdd->parent, devno,
-					wdd, "watchdog%d", wdd->id);
-	if (IS_ERR(wdd->dev)) {
-		watchdog_dev_unregister(wdd);
-		ida_simple_remove(&watchdog_ida, id);
-		ret = PTR_ERR(wdd->dev);
-		return ret;
-	}
-
 	if (test_bit(WDOG_STOP_ON_REBOOT, &wdd->status)) {
 		wdd->reboot_nb.notifier_call = watchdog_reboot_notifier;
 
@@ -265,9 +254,7 @@ static int __watchdog_register_device(struct watchdog_device *wdd)
 			dev_err(wdd->dev, "Cannot register reboot notifier (%d)\n",
 				ret);
 			watchdog_dev_unregister(wdd);
-			device_destroy(watchdog_class, devno);
 			ida_simple_remove(&watchdog_ida, wdd->id);
-			wdd->dev = NULL;
 			return ret;
 		}
 	}
@@ -311,9 +298,6 @@ EXPORT_SYMBOL_GPL(watchdog_register_device);
 
 static void __watchdog_unregister_device(struct watchdog_device *wdd)
 {
-	int ret;
-	int devno;
-
 	if (wdd == NULL)
 		return;
 
@@ -323,13 +307,8 @@ static void __watchdog_unregister_device(struct watchdog_device *wdd)
 	if (test_bit(WDOG_STOP_ON_REBOOT, &wdd->status))
 		unregister_reboot_notifier(&wdd->reboot_nb);
 
-	devno = wdd->cdev.dev;
-	ret = watchdog_dev_unregister(wdd);
-	if (ret)
-		pr_err("error unregistering /dev/watchdog (err=%d)\n", ret);
-	device_destroy(watchdog_class, devno);
+	watchdog_dev_unregister(wdd);
 	ida_simple_remove(&watchdog_ida, wdd->id);
-	wdd->dev = NULL;
 }
 
 /**
@@ -370,9 +349,11 @@ static int __init watchdog_deferred_registration(void)
 
 static int __init watchdog_init(void)
 {
-	watchdog_class = watchdog_dev_init();
-	if (IS_ERR(watchdog_class))
-		return PTR_ERR(watchdog_class);
+	int err;
+
+	err = watchdog_dev_init();
+	if (err < 0)
+		return err;
 
 	watchdog_deferred_registration();
 	return 0;

commit 33b711269ade3f6bc9d9d15e4343e6fa922d999b
Author: Pratyush Anand <panand@redhat.com>
Date:   Thu Dec 17 17:53:59 2015 +0530

    watchdog: Read device status through sysfs attributes
    
    This patch adds following attributes to watchdog device's sysfs interface
    to read its different status.
    
    * state - reads whether device is active or not
    * identity - reads Watchdog device's identity string.
    * timeout - reads current timeout.
    * timeleft - reads timeleft before watchdog generates a reset
    * bootstatus - reads status of the watchdog device at boot
    * status - reads watchdog device's  internal status bits
    * nowayout - reads whether nowayout feature was set or not
    
    Testing with iTCO_wdt:
     # cd /sys/class/watchdog/watchdog1/
     # ls
    bootstatus  dev  device  identity  nowayout  power  state
    subsystem  timeleft  timeout  uevent
     # cat identity
    iTCO_wdt
     # cat timeout
    30
     # cat state
    inactive
     # echo > /dev/watchdog1
     # cat timeleft
    26
     # cat state
    active
     # cat bootstatus
    0
     # cat nowayout
    0
    
    Signed-off-by: Pratyush Anand <panand@redhat.com>
    Reviewed-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/drivers/watchdog/watchdog_core.c b/drivers/watchdog/watchdog_core.c
index 357d23c79545..551af042867c 100644
--- a/drivers/watchdog/watchdog_core.c
+++ b/drivers/watchdog/watchdog_core.c
@@ -249,7 +249,7 @@ static int __watchdog_register_device(struct watchdog_device *wdd)
 
 	devno = wdd->cdev.dev;
 	wdd->dev = device_create(watchdog_class, wdd->parent, devno,
-					NULL, "watchdog%d", wdd->id);
+					wdd, "watchdog%d", wdd->id);
 	if (IS_ERR(wdd->dev)) {
 		watchdog_dev_unregister(wdd);
 		ida_simple_remove(&watchdog_ida, id);

commit 906d7a5cfeda508e7361f021605579a00cd82815
Author: Pratyush Anand <panand@redhat.com>
Date:   Thu Dec 17 17:53:58 2015 +0530

    watchdog: Use static struct class watchdog_class in stead of pointer
    
    We need few sysfs attributes to know different status of a watchdog device.
    To do that, we need to associate .dev_groups with watchdog_class. So
    convert it from pointer to static.
    Putting this static struct in watchdog_dev.c, so that static device
    attributes defined in that file can be attached to it.
    
    Signed-off-by: Pratyush Anand <panand@redhat.com>
    Suggested-by: Guenter Roeck <linux@roeck-us.net>
    Reviewed-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/drivers/watchdog/watchdog_core.c b/drivers/watchdog/watchdog_core.c
index 0bb32a487f46..357d23c79545 100644
--- a/drivers/watchdog/watchdog_core.c
+++ b/drivers/watchdog/watchdog_core.c
@@ -370,19 +370,9 @@ static int __init watchdog_deferred_registration(void)
 
 static int __init watchdog_init(void)
 {
-	int err;
-
-	watchdog_class = class_create(THIS_MODULE, "watchdog");
-	if (IS_ERR(watchdog_class)) {
-		pr_err("couldn't create class\n");
+	watchdog_class = watchdog_dev_init();
+	if (IS_ERR(watchdog_class))
 		return PTR_ERR(watchdog_class);
-	}
-
-	err = watchdog_dev_init();
-	if (err < 0) {
-		class_destroy(watchdog_class);
-		return err;
-	}
 
 	watchdog_deferred_registration();
 	return 0;
@@ -391,7 +381,6 @@ static int __init watchdog_init(void)
 static void __exit watchdog_exit(void)
 {
 	watchdog_dev_exit();
-	class_destroy(watchdog_class);
 	ida_destroy(&watchdog_ida);
 }
 

commit e131319669e0ef5e6fcd75174daeffa40492135c
Author: Damien Riegel <damien.riegel@savoirfairelinux.com>
Date:   Fri Nov 20 16:54:51 2015 -0500

    watchdog: core: add reboot notifier support
    
    Many watchdog drivers register a reboot notifier in order to stop the
    watchdog on system reboot. Thus we can factorize this code in the
    watchdog core.
    
    For that purpose, a new notifier block is added in watchdog_device for
    internal use only, as well as a new watchdog_stop_on_reboot helper
    function.
    
    If this helper is called, watchdog core registers the related notifier
    block and will stop the watchdog when SYS_HALT or SYS_DOWN is received.
    
    Since this operation can be critical on some platforms, abort the device
    registration if the reboot notifier registration fails.
    
    Suggested-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Signed-off-by: Damien Riegel <damien.riegel@savoirfairelinux.com>
    Reviewed-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/drivers/watchdog/watchdog_core.c b/drivers/watchdog/watchdog_core.c
index 88a34efac400..0bb32a487f46 100644
--- a/drivers/watchdog/watchdog_core.c
+++ b/drivers/watchdog/watchdog_core.c
@@ -138,6 +138,25 @@ int watchdog_init_timeout(struct watchdog_device *wdd,
 }
 EXPORT_SYMBOL_GPL(watchdog_init_timeout);
 
+static int watchdog_reboot_notifier(struct notifier_block *nb,
+				    unsigned long code, void *data)
+{
+	struct watchdog_device *wdd = container_of(nb, struct watchdog_device,
+						   reboot_nb);
+
+	if (code == SYS_DOWN || code == SYS_HALT) {
+		if (watchdog_active(wdd)) {
+			int ret;
+
+			ret = wdd->ops->stop(wdd);
+			if (ret)
+				return NOTIFY_BAD;
+		}
+	}
+
+	return NOTIFY_DONE;
+}
+
 static int watchdog_restart_notifier(struct notifier_block *nb,
 				     unsigned long action, void *data)
 {
@@ -238,6 +257,21 @@ static int __watchdog_register_device(struct watchdog_device *wdd)
 		return ret;
 	}
 
+	if (test_bit(WDOG_STOP_ON_REBOOT, &wdd->status)) {
+		wdd->reboot_nb.notifier_call = watchdog_reboot_notifier;
+
+		ret = register_reboot_notifier(&wdd->reboot_nb);
+		if (ret) {
+			dev_err(wdd->dev, "Cannot register reboot notifier (%d)\n",
+				ret);
+			watchdog_dev_unregister(wdd);
+			device_destroy(watchdog_class, devno);
+			ida_simple_remove(&watchdog_ida, wdd->id);
+			wdd->dev = NULL;
+			return ret;
+		}
+	}
+
 	if (wdd->ops->restart) {
 		wdd->restart_nb.notifier_call = watchdog_restart_notifier;
 
@@ -286,6 +320,9 @@ static void __watchdog_unregister_device(struct watchdog_device *wdd)
 	if (wdd->ops->restart)
 		unregister_restart_handler(&wdd->restart_nb);
 
+	if (test_bit(WDOG_STOP_ON_REBOOT, &wdd->status))
+		unregister_reboot_notifier(&wdd->reboot_nb);
+
 	devno = wdd->cdev.dev;
 	ret = watchdog_dev_unregister(wdd);
 	if (ret)

commit 2165bf524da5f5e496d1cdb8c5afae1345ecce1e
Author: Damien Riegel <damien.riegel@savoirfairelinux.com>
Date:   Mon Nov 16 12:27:59 2015 -0500

    watchdog: core: add restart handler support
    
    Many watchdog drivers implement the same code to register a restart
    handler. This patch provides a generic way to set such a function.
    
    The patch adds a new restart watchdog operation. If a restart priority
    greater than 0 is needed, the driver can call
    watchdog_set_restart_priority to set it.
    
    Suggested-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Signed-off-by: Damien Riegel <damien.riegel@savoirfairelinux.com>
    Reviewed-by: Guenter Roeck <linux@roeck-us.net>
    Reviewed-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/drivers/watchdog/watchdog_core.c b/drivers/watchdog/watchdog_core.c
index 873f13972cf4..88a34efac400 100644
--- a/drivers/watchdog/watchdog_core.c
+++ b/drivers/watchdog/watchdog_core.c
@@ -32,6 +32,7 @@
 #include <linux/types.h>	/* For standard types */
 #include <linux/errno.h>	/* For the -ENODEV/... values */
 #include <linux/kernel.h>	/* For printk/panic/... */
+#include <linux/reboot.h>	/* For restart handler */
 #include <linux/watchdog.h>	/* For watchdog specific items */
 #include <linux/init.h>		/* For __init/__exit/... */
 #include <linux/idr.h>		/* For ida_* macros */
@@ -137,6 +138,41 @@ int watchdog_init_timeout(struct watchdog_device *wdd,
 }
 EXPORT_SYMBOL_GPL(watchdog_init_timeout);
 
+static int watchdog_restart_notifier(struct notifier_block *nb,
+				     unsigned long action, void *data)
+{
+	struct watchdog_device *wdd = container_of(nb, struct watchdog_device,
+						   restart_nb);
+
+	int ret;
+
+	ret = wdd->ops->restart(wdd);
+	if (ret)
+		return NOTIFY_BAD;
+
+	return NOTIFY_DONE;
+}
+
+/**
+ * watchdog_set_restart_priority - Change priority of restart handler
+ * @wdd: watchdog device
+ * @priority: priority of the restart handler, should follow these guidelines:
+ *   0:   use watchdog's restart function as last resort, has limited restart
+ *        capabilies
+ *   128: default restart handler, use if no other handler is expected to be
+ *        available and/or if restart is sufficient to restart the entire system
+ *   255: preempt all other handlers
+ *
+ * If a wdd->ops->restart function is provided when watchdog_register_device is
+ * called, it will be registered as a restart handler with the priority given
+ * here.
+ */
+void watchdog_set_restart_priority(struct watchdog_device *wdd, int priority)
+{
+	wdd->restart_nb.priority = priority;
+}
+EXPORT_SYMBOL_GPL(watchdog_set_restart_priority);
+
 static int __watchdog_register_device(struct watchdog_device *wdd)
 {
 	int ret, id = -1, devno;
@@ -202,6 +238,15 @@ static int __watchdog_register_device(struct watchdog_device *wdd)
 		return ret;
 	}
 
+	if (wdd->ops->restart) {
+		wdd->restart_nb.notifier_call = watchdog_restart_notifier;
+
+		ret = register_restart_handler(&wdd->restart_nb);
+		if (ret)
+			dev_warn(wdd->dev, "Cannot register restart handler (%d)\n",
+				 ret);
+	}
+
 	return 0;
 }
 
@@ -238,6 +283,9 @@ static void __watchdog_unregister_device(struct watchdog_device *wdd)
 	if (wdd == NULL)
 		return;
 
+	if (wdd->ops->restart)
+		unregister_restart_handler(&wdd->restart_nb);
+
 	devno = wdd->cdev.dev;
 	ret = watchdog_dev_unregister(wdd);
 	if (ret)

commit 9dd4e173f71d5ac6ea37f7dbf49af6e5cd44f9fb
Author: Justin Chen <justinpopo6@gmail.com>
Date:   Wed Sep 2 11:00:17 2015 -0700

    watchdog: watchdog_dev: Use device tree alias for naming watchdogs
    
    Currently there is no way to easily differentiate multiple
    watchdog devices. The watchdogs are named by the order they
    are probed.
    1st probed watchdog: /dev/watchdog0
    2nd probed watchdog: /dev/watchdog1
    ...
    
    This change uses the alias of the watchdog device node for
    the name of the watchdog.
    aliases {
        watchdog0 = "/...../...."
        watchdog3 = "/..../....."
        watchdog2 = "/..../....."
        ...
    }
    
    This will translate to...
    /dev/watchdog0
    /dev/watchdog3
    /dev/watchdog2
    
    v2
    Assign alias number to id in watchdog_core instead of watchdog_dev.
    If failed to get id, fallback to original ida_simple_get call.
    
    Signed-off-by: Justin Chen <justinpopo6@gmail.com>
    Reviewed-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/drivers/watchdog/watchdog_core.c b/drivers/watchdog/watchdog_core.c
index 1a8059455413..873f13972cf4 100644
--- a/drivers/watchdog/watchdog_core.c
+++ b/drivers/watchdog/watchdog_core.c
@@ -139,7 +139,7 @@ EXPORT_SYMBOL_GPL(watchdog_init_timeout);
 
 static int __watchdog_register_device(struct watchdog_device *wdd)
 {
-	int ret, id, devno;
+	int ret, id = -1, devno;
 
 	if (wdd == NULL || wdd->info == NULL || wdd->ops == NULL)
 		return -EINVAL;
@@ -157,7 +157,18 @@ static int __watchdog_register_device(struct watchdog_device *wdd)
 	 */
 
 	mutex_init(&wdd->lock);
-	id = ida_simple_get(&watchdog_ida, 0, MAX_DOGS, GFP_KERNEL);
+
+	/* Use alias for watchdog id if possible */
+	if (wdd->parent) {
+		ret = of_alias_get_id(wdd->parent->of_node, "watchdog");
+		if (ret >= 0)
+			id = ida_simple_get(&watchdog_ida, ret,
+					    ret + 1, GFP_KERNEL);
+	}
+
+	if (id < 0)
+		id = ida_simple_get(&watchdog_ida, 0, MAX_DOGS, GFP_KERNEL);
+
 	if (id < 0)
 		return id;
 	wdd->id = id;

commit ef90174f821041313d42d99c1c8b35a3af64a910
Author: Jean-Baptiste Theou <jtheou@adeneo-embedded.us>
Date:   Tue Jun 9 09:55:02 2015 -0700

    watchdog: watchdog_core: Add watchdog registration deferral mechanism
    
    Currently, watchdog subsystem require the misc subsystem to
    register a watchdog. This may not be the case in case of an
    early registration of a watchdog, which can be required when
    the watchdog cannot be disabled.
    
    This patch introduces a deferral mechanism to remove this requirement.
    
    Signed-off-by: Jean-Baptiste Theou <jtheou@adeneo-embedded.us>
    Reviewed-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/drivers/watchdog/watchdog_core.c b/drivers/watchdog/watchdog_core.c
index cec9b559647d..1a8059455413 100644
--- a/drivers/watchdog/watchdog_core.c
+++ b/drivers/watchdog/watchdog_core.c
@@ -43,6 +43,45 @@
 static DEFINE_IDA(watchdog_ida);
 static struct class *watchdog_class;
 
+/*
+ * Deferred Registration infrastructure.
+ *
+ * Sometimes watchdog drivers needs to be loaded as soon as possible,
+ * for example when it's impossible to disable it. To do so,
+ * raising the initcall level of the watchdog driver is a solution.
+ * But in such case, the miscdev is maybe not ready (subsys_initcall), and
+ * watchdog_core need miscdev to register the watchdog as a char device.
+ *
+ * The deferred registration infrastructure offer a way for the watchdog
+ * subsystem to register a watchdog properly, even before miscdev is ready.
+ */
+
+static DEFINE_MUTEX(wtd_deferred_reg_mutex);
+static LIST_HEAD(wtd_deferred_reg_list);
+static bool wtd_deferred_reg_done;
+
+static int watchdog_deferred_registration_add(struct watchdog_device *wdd)
+{
+	list_add_tail(&wdd->deferred,
+		      &wtd_deferred_reg_list);
+	return 0;
+}
+
+static void watchdog_deferred_registration_del(struct watchdog_device *wdd)
+{
+	struct list_head *p, *n;
+	struct watchdog_device *wdd_tmp;
+
+	list_for_each_safe(p, n, &wtd_deferred_reg_list) {
+		wdd_tmp = list_entry(p, struct watchdog_device,
+				     deferred);
+		if (wdd_tmp == wdd) {
+			list_del(&wdd_tmp->deferred);
+			break;
+		}
+	}
+}
+
 static void watchdog_check_min_max_timeout(struct watchdog_device *wdd)
 {
 	/*
@@ -98,17 +137,7 @@ int watchdog_init_timeout(struct watchdog_device *wdd,
 }
 EXPORT_SYMBOL_GPL(watchdog_init_timeout);
 
-/**
- * watchdog_register_device() - register a watchdog device
- * @wdd: watchdog device
- *
- * Register a watchdog device with the kernel so that the
- * watchdog timer can be accessed from userspace.
- *
- * A zero is returned on success and a negative errno code for
- * failure.
- */
-int watchdog_register_device(struct watchdog_device *wdd)
+static int __watchdog_register_device(struct watchdog_device *wdd)
 {
 	int ret, id, devno;
 
@@ -164,16 +193,33 @@ int watchdog_register_device(struct watchdog_device *wdd)
 
 	return 0;
 }
-EXPORT_SYMBOL_GPL(watchdog_register_device);
 
 /**
- * watchdog_unregister_device() - unregister a watchdog device
- * @wdd: watchdog device to unregister
+ * watchdog_register_device() - register a watchdog device
+ * @wdd: watchdog device
  *
- * Unregister a watchdog device that was previously successfully
- * registered with watchdog_register_device().
+ * Register a watchdog device with the kernel so that the
+ * watchdog timer can be accessed from userspace.
+ *
+ * A zero is returned on success and a negative errno code for
+ * failure.
  */
-void watchdog_unregister_device(struct watchdog_device *wdd)
+
+int watchdog_register_device(struct watchdog_device *wdd)
+{
+	int ret;
+
+	mutex_lock(&wtd_deferred_reg_mutex);
+	if (wtd_deferred_reg_done)
+		ret = __watchdog_register_device(wdd);
+	else
+		ret = watchdog_deferred_registration_add(wdd);
+	mutex_unlock(&wtd_deferred_reg_mutex);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(watchdog_register_device);
+
+static void __watchdog_unregister_device(struct watchdog_device *wdd)
 {
 	int ret;
 	int devno;
@@ -189,8 +235,43 @@ void watchdog_unregister_device(struct watchdog_device *wdd)
 	ida_simple_remove(&watchdog_ida, wdd->id);
 	wdd->dev = NULL;
 }
+
+/**
+ * watchdog_unregister_device() - unregister a watchdog device
+ * @wdd: watchdog device to unregister
+ *
+ * Unregister a watchdog device that was previously successfully
+ * registered with watchdog_register_device().
+ */
+
+void watchdog_unregister_device(struct watchdog_device *wdd)
+{
+	mutex_lock(&wtd_deferred_reg_mutex);
+	if (wtd_deferred_reg_done)
+		__watchdog_unregister_device(wdd);
+	else
+		watchdog_deferred_registration_del(wdd);
+	mutex_unlock(&wtd_deferred_reg_mutex);
+}
+
 EXPORT_SYMBOL_GPL(watchdog_unregister_device);
 
+static int __init watchdog_deferred_registration(void)
+{
+	mutex_lock(&wtd_deferred_reg_mutex);
+	wtd_deferred_reg_done = true;
+	while (!list_empty(&wtd_deferred_reg_list)) {
+		struct watchdog_device *wdd;
+
+		wdd = list_first_entry(&wtd_deferred_reg_list,
+				       struct watchdog_device, deferred);
+		list_del(&wdd->deferred);
+		__watchdog_register_device(wdd);
+	}
+	mutex_unlock(&wtd_deferred_reg_mutex);
+	return 0;
+}
+
 static int __init watchdog_init(void)
 {
 	int err;
@@ -207,6 +288,7 @@ static int __init watchdog_init(void)
 		return err;
 	}
 
+	watchdog_deferred_registration();
 	return 0;
 }
 
@@ -217,7 +299,7 @@ static void __exit watchdog_exit(void)
 	ida_destroy(&watchdog_ida);
 }
 
-subsys_initcall(watchdog_init);
+subsys_initcall_sync(watchdog_init);
 module_exit(watchdog_exit);
 
 MODULE_AUTHOR("Alan Cox <alan@lxorguk.ukuu.org.uk>");

commit 2c34d59916bd82efe6544f39ec162e8c9236009d
Author: Doug Anderson <dianders@chromium.org>
Date:   Tue Nov 26 10:22:52 2013 -0800

    watchdog: core: Make dt "timeout-sec" property work on drivers w/out min/max
    
    It is valid for a watchdog driver to have 0 for a "min" and "max"
    timeout if the driver doesn't need the core to enforce the concepts of
    min and max.  The s3c2410_wdt driver is one such driver.  Specifically
    it can be hard for that driver to come up with a static "max" on all
    platforms without a lot more information since the input clock on
    S3C2410 and S3C2440 can change with DVFS.
    
    As written, watchdog_init_timeout() will not ever read "timeout-sec"
    on these drivers since watchdog_timeout_invalid() will _never_ return
    true.  Change to not consider a timeout_parm of 0 as valid even if
    min/max aren't specified by the driver.  Also handle the case when
    there is no min/max and no "timeout-sec" property.
    
    Signed-off-by: Doug Anderson <dianders@chromium.org>
    Reviewed-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/drivers/watchdog/watchdog_core.c b/drivers/watchdog/watchdog_core.c
index 461336c4519f..cec9b559647d 100644
--- a/drivers/watchdog/watchdog_core.c
+++ b/drivers/watchdog/watchdog_core.c
@@ -78,7 +78,7 @@ int watchdog_init_timeout(struct watchdog_device *wdd,
 	watchdog_check_min_max_timeout(wdd);
 
 	/* try to get the timeout module parameter first */
-	if (!watchdog_timeout_invalid(wdd, timeout_parm)) {
+	if (!watchdog_timeout_invalid(wdd, timeout_parm) && timeout_parm) {
 		wdd->timeout = timeout_parm;
 		return ret;
 	}
@@ -89,7 +89,7 @@ int watchdog_init_timeout(struct watchdog_device *wdd,
 	if (dev == NULL || dev->of_node == NULL)
 		return ret;
 	of_property_read_u32(dev->of_node, "timeout-sec", &t);
-	if (!watchdog_timeout_invalid(wdd, t))
+	if (!watchdog_timeout_invalid(wdd, t) && t)
 		wdd->timeout = t;
 	else
 		ret = -EINVAL;

commit 6ffcff931971ce78d08220a7a3bbaddaea207598
Author: Sachin Kamat <sachin.kamat@linaro.org>
Date:   Mon Oct 28 14:17:17 2013 +0530

    watchdog: watchdog_core: Fix a trivial typo
    
    Fixed a trivial typo.
    
    Signed-off-by: Sachin Kamat <sachin.kamat@linaro.org>
    Reviewed-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/drivers/watchdog/watchdog_core.c b/drivers/watchdog/watchdog_core.c
index 05d18b4c661b..461336c4519f 100644
--- a/drivers/watchdog/watchdog_core.c
+++ b/drivers/watchdog/watchdog_core.c
@@ -77,7 +77,7 @@ int watchdog_init_timeout(struct watchdog_device *wdd,
 
 	watchdog_check_min_max_timeout(wdd);
 
-	/* try to get the tiemout module parameter first */
+	/* try to get the timeout module parameter first */
 	if (!watchdog_timeout_invalid(wdd, timeout_parm)) {
 		wdd->timeout = timeout_parm;
 		return ret;

commit 3048253ed957fc6cdc34599178408559aa1e0062
Author: Fabio Porcedda <fabio.porcedda@gmail.com>
Date:   Tue Jan 8 11:04:10 2013 +0100

    watchdog: core: dt: add support for the timeout-sec dt property
    
    Add support for watchdog drivers to initialize/set the timeout field
    of the watchdog_device structure. The timeout field is initialised
    either with the module timeout parameter value (if valid) or with the
    timeout-sec dt property (if valid). If both are invalid the initial
    value is unchanged.
    
    Signed-off-by: Fabio Porcedda <fabio.porcedda@gmail.com>
    Acked-by: Nicolas Ferre <nicolas.ferre@atmel.com>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/drivers/watchdog/watchdog_core.c b/drivers/watchdog/watchdog_core.c
index 3796434991fa..05d18b4c661b 100644
--- a/drivers/watchdog/watchdog_core.c
+++ b/drivers/watchdog/watchdog_core.c
@@ -36,12 +36,68 @@
 #include <linux/init.h>		/* For __init/__exit/... */
 #include <linux/idr.h>		/* For ida_* macros */
 #include <linux/err.h>		/* For IS_ERR macros */
+#include <linux/of.h>		/* For of_get_timeout_sec */
 
 #include "watchdog_core.h"	/* For watchdog_dev_register/... */
 
 static DEFINE_IDA(watchdog_ida);
 static struct class *watchdog_class;
 
+static void watchdog_check_min_max_timeout(struct watchdog_device *wdd)
+{
+	/*
+	 * Check that we have valid min and max timeout values, if
+	 * not reset them both to 0 (=not used or unknown)
+	 */
+	if (wdd->min_timeout > wdd->max_timeout) {
+		pr_info("Invalid min and max timeout values, resetting to 0!\n");
+		wdd->min_timeout = 0;
+		wdd->max_timeout = 0;
+	}
+}
+
+/**
+ * watchdog_init_timeout() - initialize the timeout field
+ * @timeout_parm: timeout module parameter
+ * @dev: Device that stores the timeout-sec property
+ *
+ * Initialize the timeout field of the watchdog_device struct with either the
+ * timeout module parameter (if it is valid value) or the timeout-sec property
+ * (only if it is a valid value and the timeout_parm is out of bounds).
+ * If none of them are valid then we keep the old value (which should normally
+ * be the default timeout value.
+ *
+ * A zero is returned on success and -EINVAL for failure.
+ */
+int watchdog_init_timeout(struct watchdog_device *wdd,
+				unsigned int timeout_parm, struct device *dev)
+{
+	unsigned int t = 0;
+	int ret = 0;
+
+	watchdog_check_min_max_timeout(wdd);
+
+	/* try to get the tiemout module parameter first */
+	if (!watchdog_timeout_invalid(wdd, timeout_parm)) {
+		wdd->timeout = timeout_parm;
+		return ret;
+	}
+	if (timeout_parm)
+		ret = -EINVAL;
+
+	/* try to get the timeout_sec property */
+	if (dev == NULL || dev->of_node == NULL)
+		return ret;
+	of_property_read_u32(dev->of_node, "timeout-sec", &t);
+	if (!watchdog_timeout_invalid(wdd, t))
+		wdd->timeout = t;
+	else
+		ret = -EINVAL;
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(watchdog_init_timeout);
+
 /**
  * watchdog_register_device() - register a watchdog device
  * @wdd: watchdog device
@@ -63,15 +119,7 @@ int watchdog_register_device(struct watchdog_device *wdd)
 	if (wdd->ops->start == NULL || wdd->ops->stop == NULL)
 		return -EINVAL;
 
-	/*
-	 * Check that we have valid min and max timeout values, if
-	 * not reset them both to 0 (=not used or unknown)
-	 */
-	if (wdd->min_timeout > wdd->max_timeout) {
-		pr_info("Invalid min and max timeout values, resetting to 0!\n");
-		wdd->min_timeout = 0;
-		wdd->max_timeout = 0;
-	}
+	watchdog_check_min_max_timeout(wdd);
 
 	/*
 	 * Note: now that all watchdog_device data has been verified, we

commit b232a70a1735c004f9ee6fdf363def527b9234b6
Author: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
Date:   Mon Sep 10 12:41:15 2012 +0800

    watchdog: move the dereference below the NULL test
    
    The dereference should be moved below the NULL test.
    
    spatch with a semantic match is used to found this.
    (http://coccinelle.lip6.fr/)
    
    Signed-off-by: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/drivers/watchdog/watchdog_core.c b/drivers/watchdog/watchdog_core.c
index 6aa46a90ff02..3796434991fa 100644
--- a/drivers/watchdog/watchdog_core.c
+++ b/drivers/watchdog/watchdog_core.c
@@ -128,11 +128,12 @@ EXPORT_SYMBOL_GPL(watchdog_register_device);
 void watchdog_unregister_device(struct watchdog_device *wdd)
 {
 	int ret;
-	int devno = wdd->cdev.dev;
+	int devno;
 
 	if (wdd == NULL)
 		return;
 
+	devno = wdd->cdev.dev;
 	ret = watchdog_dev_unregister(wdd);
 	if (ret)
 		pr_err("error unregistering /dev/watchdog (err=%d)\n", ret);

commit f4e9c82f64b524314a390b13d3ba7d483f09258f
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Tue May 22 11:40:26 2012 +0200

    watchdog: Add Locking support
    
    This patch fixes some potential multithreading issues, despite only
    allowing one process to open the /dev/watchdog device, we can still get
    called multiple times at the same time, since a program could be using thread,
    or could share the fd after a fork.
    
    This causes 2 potential problems:
    1) watchdog_start / open do an unlocked test_n_set / test_n_clear,
       if these 2 race, the watchdog could be stopped while the active
       bit indicates it is running or visa versa.
    
    2) Most watchdog_dev drivers probably assume that only one
       watchdog-op will get called at a time, this is not necessary
       true atm.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/drivers/watchdog/watchdog_core.c b/drivers/watchdog/watchdog_core.c
index 86a57673abf9..6aa46a90ff02 100644
--- a/drivers/watchdog/watchdog_core.c
+++ b/drivers/watchdog/watchdog_core.c
@@ -79,6 +79,7 @@ int watchdog_register_device(struct watchdog_device *wdd)
 	 * corrupted in a later stage then we expect a kernel panic!
 	 */
 
+	mutex_init(&wdd->lock);
 	id = ida_simple_get(&watchdog_ida, 0, MAX_DOGS, GFP_KERNEL);
 	if (id < 0)
 		return id;

commit d6b469d915ae348b3bb8b25034063d6870ff4a00
Author: Alan Cox <alan@linux.intel.com>
Date:   Fri May 11 12:00:20 2012 +0200

    watchdog: create all the proper device files
    
    Create the watchdog class and it's associated devices.
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/drivers/watchdog/watchdog_core.c b/drivers/watchdog/watchdog_core.c
index 5f9879369003..86a57673abf9 100644
--- a/drivers/watchdog/watchdog_core.c
+++ b/drivers/watchdog/watchdog_core.c
@@ -35,10 +35,12 @@
 #include <linux/watchdog.h>	/* For watchdog specific items */
 #include <linux/init.h>		/* For __init/__exit/... */
 #include <linux/idr.h>		/* For ida_* macros */
+#include <linux/err.h>		/* For IS_ERR macros */
 
 #include "watchdog_core.h"	/* For watchdog_dev_register/... */
 
 static DEFINE_IDA(watchdog_ida);
+static struct class *watchdog_class;
 
 /**
  * watchdog_register_device() - register a watchdog device
@@ -52,7 +54,7 @@ static DEFINE_IDA(watchdog_ida);
  */
 int watchdog_register_device(struct watchdog_device *wdd)
 {
-	int ret, id;
+	int ret, id, devno;
 
 	if (wdd == NULL || wdd->info == NULL || wdd->ops == NULL)
 		return -EINVAL;
@@ -101,6 +103,16 @@ int watchdog_register_device(struct watchdog_device *wdd)
 		}
 	}
 
+	devno = wdd->cdev.dev;
+	wdd->dev = device_create(watchdog_class, wdd->parent, devno,
+					NULL, "watchdog%d", wdd->id);
+	if (IS_ERR(wdd->dev)) {
+		watchdog_dev_unregister(wdd);
+		ida_simple_remove(&watchdog_ida, id);
+		ret = PTR_ERR(wdd->dev);
+		return ret;
+	}
+
 	return 0;
 }
 EXPORT_SYMBOL_GPL(watchdog_register_device);
@@ -115,6 +127,7 @@ EXPORT_SYMBOL_GPL(watchdog_register_device);
 void watchdog_unregister_device(struct watchdog_device *wdd)
 {
 	int ret;
+	int devno = wdd->cdev.dev;
 
 	if (wdd == NULL)
 		return;
@@ -122,18 +135,35 @@ void watchdog_unregister_device(struct watchdog_device *wdd)
 	ret = watchdog_dev_unregister(wdd);
 	if (ret)
 		pr_err("error unregistering /dev/watchdog (err=%d)\n", ret);
+	device_destroy(watchdog_class, devno);
 	ida_simple_remove(&watchdog_ida, wdd->id);
+	wdd->dev = NULL;
 }
 EXPORT_SYMBOL_GPL(watchdog_unregister_device);
 
 static int __init watchdog_init(void)
 {
-	return watchdog_dev_init();
+	int err;
+
+	watchdog_class = class_create(THIS_MODULE, "watchdog");
+	if (IS_ERR(watchdog_class)) {
+		pr_err("couldn't create class\n");
+		return PTR_ERR(watchdog_class);
+	}
+
+	err = watchdog_dev_init();
+	if (err < 0) {
+		class_destroy(watchdog_class);
+		return err;
+	}
+
+	return 0;
 }
 
 static void __exit watchdog_exit(void)
 {
 	watchdog_dev_exit();
+	class_destroy(watchdog_class);
 	ida_destroy(&watchdog_ida);
 }
 

commit 45f5fed30a6460ec58f159ff297a2974153a97de
Author: Alan Cox <alan@linux.intel.com>
Date:   Thu May 10 21:48:59 2012 +0200

    watchdog: Add multiple device support
    
    We keep the old /dev/watchdog interface file for the first watchdog via
    miscdev. This is basically a cut and paste of the relevant interface code
    from the rtc driver layer tweaked for watchdog.
    
    Revised to fix problems noted by Hans de Goede
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/drivers/watchdog/watchdog_core.c b/drivers/watchdog/watchdog_core.c
index 8598308278d3..5f9879369003 100644
--- a/drivers/watchdog/watchdog_core.c
+++ b/drivers/watchdog/watchdog_core.c
@@ -34,9 +34,12 @@
 #include <linux/kernel.h>	/* For printk/panic/... */
 #include <linux/watchdog.h>	/* For watchdog specific items */
 #include <linux/init.h>		/* For __init/__exit/... */
+#include <linux/idr.h>		/* For ida_* macros */
 
 #include "watchdog_core.h"	/* For watchdog_dev_register/... */
 
+static DEFINE_IDA(watchdog_ida);
+
 /**
  * watchdog_register_device() - register a watchdog device
  * @wdd: watchdog device
@@ -49,7 +52,7 @@
  */
 int watchdog_register_device(struct watchdog_device *wdd)
 {
-	int ret;
+	int ret, id;
 
 	if (wdd == NULL || wdd->info == NULL || wdd->ops == NULL)
 		return -EINVAL;
@@ -74,11 +77,28 @@ int watchdog_register_device(struct watchdog_device *wdd)
 	 * corrupted in a later stage then we expect a kernel panic!
 	 */
 
-	/* We only support 1 watchdog device via the /dev/watchdog interface */
+	id = ida_simple_get(&watchdog_ida, 0, MAX_DOGS, GFP_KERNEL);
+	if (id < 0)
+		return id;
+	wdd->id = id;
+
 	ret = watchdog_dev_register(wdd);
 	if (ret) {
-		pr_err("error registering /dev/watchdog (err=%d)\n", ret);
-		return ret;
+		ida_simple_remove(&watchdog_ida, id);
+		if (!(id == 0 && ret == -EBUSY))
+			return ret;
+
+		/* Retry in case a legacy watchdog module exists */
+		id = ida_simple_get(&watchdog_ida, 1, MAX_DOGS, GFP_KERNEL);
+		if (id < 0)
+			return id;
+		wdd->id = id;
+
+		ret = watchdog_dev_register(wdd);
+		if (ret) {
+			ida_simple_remove(&watchdog_ida, id);
+			return ret;
+		}
 	}
 
 	return 0;
@@ -102,9 +122,24 @@ void watchdog_unregister_device(struct watchdog_device *wdd)
 	ret = watchdog_dev_unregister(wdd);
 	if (ret)
 		pr_err("error unregistering /dev/watchdog (err=%d)\n", ret);
+	ida_simple_remove(&watchdog_ida, wdd->id);
 }
 EXPORT_SYMBOL_GPL(watchdog_unregister_device);
 
+static int __init watchdog_init(void)
+{
+	return watchdog_dev_init();
+}
+
+static void __exit watchdog_exit(void)
+{
+	watchdog_dev_exit();
+	ida_destroy(&watchdog_ida);
+}
+
+subsys_initcall(watchdog_init);
+module_exit(watchdog_exit);
+
 MODULE_AUTHOR("Alan Cox <alan@lxorguk.ukuu.org.uk>");
 MODULE_AUTHOR("Wim Van Sebroeck <wim@iguana.be>");
 MODULE_DESCRIPTION("WatchDog Timer Driver Core");

commit 6cfb5aa836884bcd66e2c5d0a101e97ba78aaafd
Author: Wim Van Sebroeck <wim@iguana.be>
Date:   Mon May 21 15:31:06 2012 +0200

    watchdog: correct the name of the watchdog_core inlude file
    
    The watchdog_core include file should have been named
    watchdog_core.h and not watchdog_dev.h . Correct this.
    
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/drivers/watchdog/watchdog_core.c b/drivers/watchdog/watchdog_core.c
index 14d768bfa267..8598308278d3 100644
--- a/drivers/watchdog/watchdog_core.c
+++ b/drivers/watchdog/watchdog_core.c
@@ -35,7 +35,7 @@
 #include <linux/watchdog.h>	/* For watchdog specific items */
 #include <linux/init.h>		/* For __init/__exit/... */
 
-#include "watchdog_dev.h"	/* For watchdog_dev_register/... */
+#include "watchdog_core.h"	/* For watchdog_dev_register/... */
 
 /**
  * watchdog_register_device() - register a watchdog device

commit 27c766aaacb265d625dc634bf7903f7f9fd0c697
Author: Joe Perches <joe@perches.com>
Date:   Wed Feb 15 15:06:19 2012 -0800

    watchdog: Use pr_<fmt> and pr_<level>
    
    Use the current logging styles.
    
    Make sure all output has a prefix.
    Add missing newlines.
    Remove now unnecessary PFX, NAME, and miscellaneous other #defines.
    Coalesce formats.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/drivers/watchdog/watchdog_core.c b/drivers/watchdog/watchdog_core.c
index cfa1a1518aad..14d768bfa267 100644
--- a/drivers/watchdog/watchdog_core.c
+++ b/drivers/watchdog/watchdog_core.c
@@ -77,7 +77,7 @@ int watchdog_register_device(struct watchdog_device *wdd)
 	/* We only support 1 watchdog device via the /dev/watchdog interface */
 	ret = watchdog_dev_register(wdd);
 	if (ret) {
-		pr_err("error registering /dev/watchdog (err=%d).\n", ret);
+		pr_err("error registering /dev/watchdog (err=%d)\n", ret);
 		return ret;
 	}
 
@@ -101,7 +101,7 @@ void watchdog_unregister_device(struct watchdog_device *wdd)
 
 	ret = watchdog_dev_unregister(wdd);
 	if (ret)
-		pr_err("error unregistering /dev/watchdog (err=%d).\n", ret);
+		pr_err("error unregistering /dev/watchdog (err=%d)\n", ret);
 }
 EXPORT_SYMBOL_GPL(watchdog_unregister_device);
 

commit 3f43f68e29f1dcb853d70280c7412fc0ef9a0da6
Author: Wim Van Sebroeck <wim@iguana.be>
Date:   Fri Jul 22 19:00:16 2011 +0000

    watchdog: WatchDog Timer Driver Core - Add minimum and max timeout
    
    Add min_timeout (minimum timeout) and max_timeout
    values so that the framework can check if the new
    timeout value is between the minimum and maximum
    timeout values. If both values are 0, then the
    framework will leave the check for the watchdog
    device driver itself.
    
    Signed-off-by: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Wolfram Sang <w.sang@pengutronix.de>

diff --git a/drivers/watchdog/watchdog_core.c b/drivers/watchdog/watchdog_core.c
index 47fc1267ad4e..cfa1a1518aad 100644
--- a/drivers/watchdog/watchdog_core.c
+++ b/drivers/watchdog/watchdog_core.c
@@ -58,6 +58,16 @@ int watchdog_register_device(struct watchdog_device *wdd)
 	if (wdd->ops->start == NULL || wdd->ops->stop == NULL)
 		return -EINVAL;
 
+	/*
+	 * Check that we have valid min and max timeout values, if
+	 * not reset them both to 0 (=not used or unknown)
+	 */
+	if (wdd->min_timeout > wdd->max_timeout) {
+		pr_info("Invalid min and max timeout values, resetting to 0!\n");
+		wdd->min_timeout = 0;
+		wdd->max_timeout = 0;
+	}
+
 	/*
 	 * Note: now that all watchdog_device data has been verified, we
 	 * will not check this anymore in other functions. If data gets

commit 43316044d4f64da008d6aca7d4b60771b9a24eb8
Author: Wim Van Sebroeck <wim@iguana.be>
Date:   Fri Jul 22 18:55:18 2011 +0000

    watchdog: WatchDog Timer Driver Core - Add basic framework
    
    The WatchDog Timer Driver Core is a framework
    that contains the common code for all watchdog-driver's.
    It also introduces a watchdog device structure and the
    operations that go with it.
    
    This is the introduction of this framework. This part
    supports the minimal watchdog userspace API (or with
    other words: the functionality to use /dev/watchdog's
    open, release and write functionality as defined in
    the simplest watchdog API). Extra functionality will
    follow in the next set of patches.
    
    Signed-off-by: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Wolfram Sang <w.sang@pengutronix.de>

diff --git a/drivers/watchdog/watchdog_core.c b/drivers/watchdog/watchdog_core.c
new file mode 100644
index 000000000000..47fc1267ad4e
--- /dev/null
+++ b/drivers/watchdog/watchdog_core.c
@@ -0,0 +1,101 @@
+/*
+ *	watchdog_core.c
+ *
+ *	(c) Copyright 2008-2011 Alan Cox <alan@lxorguk.ukuu.org.uk>,
+ *						All Rights Reserved.
+ *
+ *	(c) Copyright 2008-2011 Wim Van Sebroeck <wim@iguana.be>.
+ *
+ *	This source code is part of the generic code that can be used
+ *	by all the watchdog timer drivers.
+ *
+ *	Based on source code of the following authors:
+ *	  Matt Domsch <Matt_Domsch@dell.com>,
+ *	  Rob Radez <rob@osinvestor.com>,
+ *	  Rusty Lynch <rusty@linux.co.intel.com>
+ *	  Satyam Sharma <satyam@infradead.org>
+ *	  Randy Dunlap <randy.dunlap@oracle.com>
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ *
+ *	Neither Alan Cox, CymruNet Ltd., Wim Van Sebroeck nor Iguana vzw.
+ *	admit liability nor provide warranty for any of this software.
+ *	This material is provided "AS-IS" and at no charge.
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/module.h>	/* For EXPORT_SYMBOL/module stuff/... */
+#include <linux/types.h>	/* For standard types */
+#include <linux/errno.h>	/* For the -ENODEV/... values */
+#include <linux/kernel.h>	/* For printk/panic/... */
+#include <linux/watchdog.h>	/* For watchdog specific items */
+#include <linux/init.h>		/* For __init/__exit/... */
+
+#include "watchdog_dev.h"	/* For watchdog_dev_register/... */
+
+/**
+ * watchdog_register_device() - register a watchdog device
+ * @wdd: watchdog device
+ *
+ * Register a watchdog device with the kernel so that the
+ * watchdog timer can be accessed from userspace.
+ *
+ * A zero is returned on success and a negative errno code for
+ * failure.
+ */
+int watchdog_register_device(struct watchdog_device *wdd)
+{
+	int ret;
+
+	if (wdd == NULL || wdd->info == NULL || wdd->ops == NULL)
+		return -EINVAL;
+
+	/* Mandatory operations need to be supported */
+	if (wdd->ops->start == NULL || wdd->ops->stop == NULL)
+		return -EINVAL;
+
+	/*
+	 * Note: now that all watchdog_device data has been verified, we
+	 * will not check this anymore in other functions. If data gets
+	 * corrupted in a later stage then we expect a kernel panic!
+	 */
+
+	/* We only support 1 watchdog device via the /dev/watchdog interface */
+	ret = watchdog_dev_register(wdd);
+	if (ret) {
+		pr_err("error registering /dev/watchdog (err=%d).\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(watchdog_register_device);
+
+/**
+ * watchdog_unregister_device() - unregister a watchdog device
+ * @wdd: watchdog device to unregister
+ *
+ * Unregister a watchdog device that was previously successfully
+ * registered with watchdog_register_device().
+ */
+void watchdog_unregister_device(struct watchdog_device *wdd)
+{
+	int ret;
+
+	if (wdd == NULL)
+		return;
+
+	ret = watchdog_dev_unregister(wdd);
+	if (ret)
+		pr_err("error unregistering /dev/watchdog (err=%d).\n", ret);
+}
+EXPORT_SYMBOL_GPL(watchdog_unregister_device);
+
+MODULE_AUTHOR("Alan Cox <alan@lxorguk.ukuu.org.uk>");
+MODULE_AUTHOR("Wim Van Sebroeck <wim@iguana.be>");
+MODULE_DESCRIPTION("WatchDog Timer Driver Core");
+MODULE_LICENSE("GPL");
