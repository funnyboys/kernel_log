commit 660662f857bc342b287572789b2494d0614e001d
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri May 24 12:04:10 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 150
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 or at your option any
      later version this program is distributed in the hope that it will
      be useful but without any warranty without even the implied warranty
      of merchantability or fitness for a particular purpose see the gnu
      general public license for more details you should have received a
      copy of the gnu general public license along with this program if
      not write to the free software foundation inc 59 temple place suite
      330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 42 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190524100845.259718220@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index 3a4c1aa0201e..afaf30a3622c 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -1,22 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * pnpacpi -- PnP ACPI driver
  *
  * Copyright (c) 2004 Matthieu Castet <castet.matthieu@free.fr>
  * Copyright (c) 2004 Li Shaohua <shaohua.li@intel.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2, or (at your option) any
- * later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
 #include <linux/export.h>

commit 4d183d04195318c8ee8bce048f3f9a89c0e2056d
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Jun 24 01:54:39 2017 +0200

    ACPI / PM: Consolidate device wakeup settings code
    
    Currently, there are two separate ways of handling device wakeup
    settings in the ACPI core, depending on whether this is runtime
    wakeup or system wakeup (from sleep states).  However, after the
    previous commit eliminating the run_wake ACPI device wakeup flag,
    there is no difference between the two any more at the ACPI level,
    so they can be combined.
    
    For this reason, introduce acpi_pm_set_device_wakeup() to replace both
    acpi_pm_device_run_wake() and acpi_pm_device_sleep_wake() and make it
    check the ACPI device object's wakeup.valid flag to determine whether
    or not the device can be set up to generate wakeup signals.
    
    Also notice that zpodd_enable/disable_run_wake() only call
    device_set_run_wake() because acpi_pm_device_run_wake() called
    device_run_wake(), which is not done by acpi_pm_set_device_wakeup(),
    so drop the now redundant device_set_run_wake() calls from there.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index 9113876487ed..3a4c1aa0201e 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -149,8 +149,8 @@ static int pnpacpi_suspend(struct pnp_dev *dev, pm_message_t state)
 	}
 
 	if (device_can_wakeup(&dev->dev)) {
-		error = acpi_pm_device_sleep_wake(&dev->dev,
-				device_may_wakeup(&dev->dev));
+		error = acpi_pm_set_device_wakeup(&dev->dev,
+					      device_may_wakeup(&dev->dev));
 		if (error)
 			return error;
 	}
@@ -185,7 +185,7 @@ static int pnpacpi_resume(struct pnp_dev *dev)
 	}
 
 	if (device_may_wakeup(&dev->dev))
-		acpi_pm_device_sleep_wake(&dev->dev, false);
+		acpi_pm_set_device_wakeup(&dev->dev, false);
 
 	if (acpi_device_power_manageable(acpi_dev))
 		error = acpi_device_set_power(acpi_dev, ACPI_STATE_D0);

commit 844142c3f80c66fb2c311b118d60abdfe02322cb
Author: Rasmus Villemoes <linux@rasmusvillemoes.dk>
Date:   Wed Sep 9 23:59:42 2015 +0200

    ACPI / scan: constify struct acpi_hardware_id::id
    
    This is preparation for using kstrdup_const to initialize that member.
    
    Signed-off-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index 5153d1d69aee..9113876487ed 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -207,7 +207,7 @@ struct pnp_protocol pnpacpi_protocol = {
 };
 EXPORT_SYMBOL(pnpacpi_protocol);
 
-static char *__init pnpacpi_get_id(struct acpi_device *device)
+static const char *__init pnpacpi_get_id(struct acpi_device *device)
 {
 	struct acpi_hardware_id *id;
 
@@ -222,7 +222,7 @@ static char *__init pnpacpi_get_id(struct acpi_device *device)
 static int __init pnpacpi_add_device(struct acpi_device *device)
 {
 	struct pnp_dev *dev;
-	char *pnpid;
+	const char *pnpid;
 	struct acpi_hardware_id *id;
 	int error;
 

commit 2eb1eb02dda368fb224bf5a379d2448c742b71db
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Mar 13 01:45:49 2015 +0100

    PNP / ACPI: Use ACPI_COMPANION_SET() during initialization
    
    pnpacpi_add_device() calls acpi_bind_one() on an already registered
    device, which is a mistake, but it can initialize the ACPI companion
    field of the struct device to be registered using ACPI_COMPANION_SET()
    instead, so make it do that.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index d2b780aade89..5153d1d69aee 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -248,6 +248,7 @@ static int __init pnpacpi_add_device(struct acpi_device *device)
 	if (!dev)
 		return -ENOMEM;
 
+	ACPI_COMPANION_SET(&dev->dev, device);
 	dev->data = device;
 	/* .enabled means the device can decode the resources */
 	dev->active = device->status.enabled;
@@ -290,11 +291,9 @@ static int __init pnpacpi_add_device(struct acpi_device *device)
 		return error;
 	}
 
-	error = acpi_bind_one(&dev->dev, device);
-
 	num++;
 
-	return error;
+	return 0;
 }
 
 static acpi_status __init pnpacpi_add_device_handler(acpi_handle handle,

commit e70dba6020eaaceb1d3619dfb535c719900c7091
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Jul 23 01:03:06 2014 +0200

    ACPI / PNP: Use ACPI_COMPANION() instead of ACPI_HANDLE()
    
    The ACPI_HANDLE() macro evaluates ACPI_COMPANION() internally to
    return the handle of the device's ACPI companion, so it is much
    more straightforward and efficient to use ACPI_COMPANION()
    directly to obtain the device's ACPI companion object instead of
    using ACPI_HANDLE() and acpi_bus_get_device() on the returned
    handle for the same thing.
    
    Do that in several places in the ACPI PNP core code.
    
    Also use acpi_device_set_power() and acpi_device_power_manageable()
    instead of acpi_bus_set_power() and acpi_bus_power_manageable(),
    respectively, because the former two are more efficient if the
    ACPI device object is already available.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index 3bebedaee8e1..d2b780aade89 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -67,8 +67,8 @@ static int pnpacpi_set_resources(struct pnp_dev *dev)
 
 	pnp_dbg(&dev->dev, "set resources\n");
 
-	handle = ACPI_HANDLE(&dev->dev);
-	if (!handle || acpi_bus_get_device(handle, &acpi_dev)) {
+	acpi_dev = ACPI_COMPANION(&dev->dev);
+	if (!acpi_dev) {
 		dev_dbg(&dev->dev, "ACPI device not found in %s!\n", __func__);
 		return -ENODEV;
 	}
@@ -76,6 +76,7 @@ static int pnpacpi_set_resources(struct pnp_dev *dev)
 	if (WARN_ON_ONCE(acpi_dev != dev->data))
 		dev->data = acpi_dev;
 
+	handle = acpi_dev->handle;
 	if (acpi_has_method(handle, METHOD_NAME__SRS)) {
 		struct acpi_buffer buffer;
 
@@ -93,8 +94,8 @@ static int pnpacpi_set_resources(struct pnp_dev *dev)
 		}
 		kfree(buffer.pointer);
 	}
-	if (!ret && acpi_bus_power_manageable(handle))
-		ret = acpi_bus_set_power(handle, ACPI_STATE_D0);
+	if (!ret && acpi_device_power_manageable(acpi_dev))
+		ret = acpi_device_set_power(acpi_dev, ACPI_STATE_D0);
 
 	return ret;
 }
@@ -102,23 +103,22 @@ static int pnpacpi_set_resources(struct pnp_dev *dev)
 static int pnpacpi_disable_resources(struct pnp_dev *dev)
 {
 	struct acpi_device *acpi_dev;
-	acpi_handle handle;
 	acpi_status status;
 
 	dev_dbg(&dev->dev, "disable resources\n");
 
-	handle = ACPI_HANDLE(&dev->dev);
-	if (!handle || acpi_bus_get_device(handle, &acpi_dev)) {
+	acpi_dev = ACPI_COMPANION(&dev->dev);
+	if (!acpi_dev) {
 		dev_dbg(&dev->dev, "ACPI device not found in %s!\n", __func__);
 		return 0;
 	}
 
 	/* acpi_unregister_gsi(pnp_irq(dev, 0)); */
-	if (acpi_bus_power_manageable(handle))
-		acpi_bus_set_power(handle, ACPI_STATE_D3_COLD);
+	if (acpi_device_power_manageable(acpi_dev))
+		acpi_device_set_power(acpi_dev, ACPI_STATE_D3_COLD);
 
-	/* continue even if acpi_bus_set_power() fails */
-	status = acpi_evaluate_object(handle, "_DIS", NULL, NULL);
+	/* continue even if acpi_device_set_power() fails */
+	status = acpi_evaluate_object(acpi_dev->handle, "_DIS", NULL, NULL);
 	if (ACPI_FAILURE(status) && status != AE_NOT_FOUND)
 		return -ENODEV;
 
@@ -128,26 +128,22 @@ static int pnpacpi_disable_resources(struct pnp_dev *dev)
 #ifdef CONFIG_ACPI_SLEEP
 static bool pnpacpi_can_wakeup(struct pnp_dev *dev)
 {
-	struct acpi_device *acpi_dev;
-	acpi_handle handle;
+	struct acpi_device *acpi_dev = ACPI_COMPANION(&dev->dev);
 
-	handle = ACPI_HANDLE(&dev->dev);
-	if (!handle || acpi_bus_get_device(handle, &acpi_dev)) {
+	if (!acpi_dev) {
 		dev_dbg(&dev->dev, "ACPI device not found in %s!\n", __func__);
 		return false;
 	}
 
-	return acpi_bus_can_wakeup(handle);
+	return acpi_bus_can_wakeup(acpi_dev->handle);
 }
 
 static int pnpacpi_suspend(struct pnp_dev *dev, pm_message_t state)
 {
-	struct acpi_device *acpi_dev;
-	acpi_handle handle;
+	struct acpi_device *acpi_dev = ACPI_COMPANION(&dev->dev);
 	int error = 0;
 
-	handle = ACPI_HANDLE(&dev->dev);
-	if (!handle || acpi_bus_get_device(handle, &acpi_dev)) {
+	if (!acpi_dev) {
 		dev_dbg(&dev->dev, "ACPI device not found in %s!\n", __func__);
 		return 0;
 	}
@@ -159,7 +155,7 @@ static int pnpacpi_suspend(struct pnp_dev *dev, pm_message_t state)
 			return error;
 	}
 
-	if (acpi_bus_power_manageable(handle)) {
+	if (acpi_device_power_manageable(acpi_dev)) {
 		int power_state = acpi_pm_device_sleep_state(&dev->dev, NULL,
 							ACPI_STATE_D3_COLD);
 		if (power_state < 0)
@@ -167,12 +163,12 @@ static int pnpacpi_suspend(struct pnp_dev *dev, pm_message_t state)
 					ACPI_STATE_D0 : ACPI_STATE_D3_COLD;
 
 		/*
-		 * acpi_bus_set_power() often fails (keyboard port can't be
+		 * acpi_device_set_power() can fail (keyboard port can't be
 		 * powered-down?), and in any case, our return value is ignored
 		 * by pnp_bus_suspend().  Hence we don't revert the wakeup
 		 * setting if the set_power fails.
 		 */
-		error = acpi_bus_set_power(handle, power_state);
+		error = acpi_device_set_power(acpi_dev, power_state);
 	}
 
 	return error;
@@ -180,11 +176,10 @@ static int pnpacpi_suspend(struct pnp_dev *dev, pm_message_t state)
 
 static int pnpacpi_resume(struct pnp_dev *dev)
 {
-	struct acpi_device *acpi_dev;
-	acpi_handle handle = ACPI_HANDLE(&dev->dev);
+	struct acpi_device *acpi_dev = ACPI_COMPANION(&dev->dev);
 	int error = 0;
 
-	if (!handle || acpi_bus_get_device(handle, &acpi_dev)) {
+	if (!acpi_dev) {
 		dev_dbg(&dev->dev, "ACPI device not found in %s!\n", __func__);
 		return -ENODEV;
 	}
@@ -192,8 +187,8 @@ static int pnpacpi_resume(struct pnp_dev *dev)
 	if (device_may_wakeup(&dev->dev))
 		acpi_pm_device_sleep_wake(&dev->dev, false);
 
-	if (acpi_bus_power_manageable(handle))
-		error = acpi_bus_set_power(handle, ACPI_STATE_D0);
+	if (acpi_device_power_manageable(acpi_dev))
+		error = acpi_device_set_power(acpi_dev, ACPI_STATE_D0);
 
 	return error;
 }

commit f1b1dc845cb1418b2b0de35491b0da87498ea6a8
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Mon Jul 7 14:07:38 2014 +0200

    ACPI / PNP: do ACPI binding directly
    
    PNPACPI uses acpi_bus_type to do ACPI binding for the PNPACPI devices.
    
    This is overkill because PNPACPI code already knows which ACPI
    device object to bind during PNPACPI device enumeration.
    
    This patch removes acpi_pnp_bus and does the binding by invoking
    acpi_bind_one() directly after device enumerated.
    
    This also fixes a bug in the previous code that some PNPACPI devices failed
    to be bound because
     1. the ACPI device _HID is not pnpid, e.g. "MSFT0001", but its _CID is,
        e.g. "PNP0303", thus ACPI _CID is used as the pnp device device id.
     2. device is bound only if the pnp device id matches the ACPI device _HID.
    
    Tested-by: Prigent Christophe <christophe.prigent@intel.com>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index b81448b2c75d..3bebedaee8e1 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -295,9 +295,11 @@ static int __init pnpacpi_add_device(struct acpi_device *device)
 		return error;
 	}
 
+	error = acpi_bind_one(&dev->dev, device);
+
 	num++;
 
-	return 0;
+	return error;
 }
 
 static acpi_status __init pnpacpi_add_device_handler(acpi_handle handle,
@@ -313,41 +315,6 @@ static acpi_status __init pnpacpi_add_device_handler(acpi_handle handle,
 	return AE_OK;
 }
 
-static int __init acpi_pnp_match(struct device *dev, void *_pnp)
-{
-	struct acpi_device *acpi = to_acpi_device(dev);
-	struct pnp_dev *pnp = _pnp;
-
-	/* true means it matched */
-	return !acpi->physical_node_count
-	    && compare_pnp_id(pnp->id, acpi_device_hid(acpi));
-}
-
-static struct acpi_device * __init acpi_pnp_find_companion(struct device *dev)
-{
-	dev = bus_find_device(&acpi_bus_type, NULL, to_pnp_dev(dev),
-			      acpi_pnp_match);
-	if (!dev)
-		return NULL;
-
-	put_device(dev);
-	return to_acpi_device(dev);
-}
-
-/* complete initialization of a PNPACPI device includes having
- * pnpdev->dev.archdata.acpi_handle point to its ACPI sibling.
- */
-static bool acpi_pnp_bus_match(struct device *dev)
-{
-	return dev->bus == &pnp_bus_type;
-}
-
-static struct acpi_bus_type __initdata acpi_pnp_bus = {
-	.name	     = "PNP",
-	.match	     = acpi_pnp_bus_match,
-	.find_companion = acpi_pnp_find_companion,
-};
-
 int pnpacpi_disabled __initdata;
 static int __init pnpacpi_init(void)
 {
@@ -357,10 +324,8 @@ static int __init pnpacpi_init(void)
 	}
 	printk(KERN_INFO "pnp: PnP ACPI init\n");
 	pnp_register_protocol(&pnpacpi_protocol);
-	register_acpi_bus_type(&acpi_pnp_bus);
 	acpi_get_devices(NULL, pnpacpi_add_device_handler, NULL, NULL);
 	printk(KERN_INFO "pnp: PnP ACPI: found %d devices\n", num);
-	unregister_acpi_bus_type(&acpi_pnp_bus);
 	pnp_platform_devices = 1;
 	return 0;
 }

commit eec15edbb0e14485998635ea7c62e30911b465f0
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Fri May 30 04:23:01 2014 +0200

    ACPI / PNP: use device ID list for PNPACPI device enumeration
    
    ACPI can be used to enumerate PNP devices, but the code does not
    handle this in the right way currently.  Namely, if an ACPI device
    object
     1. Has a _CRS method,
     2. Has an identification of
        "three capital characters followed by four hex digits",
     3. Is not in the excluded IDs list,
    it will be enumerated to PNP bus (that is, a PNP device object will
    be create for it).  This means that, actually, the PNP bus type is
    used as the default bus type for enumerating _HID devices in ACPI.
    
    However, more and more _HID devices need to be enumerated to the
    platform bus instead (that is, platform device objects need to be
    created for them).  As a result, the device ID list in acpi_platform.c
    is used to enforce creating platform device objects rather than PNP
    device objects for matching devices.  That list has been continuously
    growing recently, unfortunately, and it is pretty much guaranteed to
    grow even more in the future.
    
    To address that problem it is better to enumerate _HID devices
    as platform devices by default.  To this end, change the way of
    enumerating PNP devices by adding a PNP ACPI scan handler that
    will use a device ID list to create PNP devices for the ACPI
    device objects whose device IDs are present in that list.
    
    The initial device ID list in the PNP ACPI scan handler contains
    all of the pnp_device_id strings from all the existing PNP drivers,
    so this change should be transparent to the PNP core and all of the
    PNP drivers.  Still, in the future it should be possible to reduce
    its size by converting PNP drivers that need not be PNP for any
    technical reasons into platform drivers.
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    [rjw: Rewrote the changelog, modified the PNP ACPI scan handler code]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index c31aa07b3ba5..b81448b2c75d 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -30,26 +30,6 @@
 
 static int num;
 
-/* We need only to blacklist devices that have already an acpi driver that
- * can't use pnp layer. We don't need to blacklist device that are directly
- * used by the kernel (PCI root, ...), as it is harmless and there were
- * already present in pnpbios. But there is an exception for devices that
- * have irqs (PIC, Timer) because we call acpi_register_gsi.
- * Finally, only devices that have a CRS method need to be in this list.
- */
-static struct acpi_device_id excluded_id_list[] __initdata = {
-	{"PNP0C09", 0},		/* EC */
-	{"PNP0C0F", 0},		/* Link device */
-	{"PNP0000", 0},		/* PIC */
-	{"PNP0100", 0},		/* Timer */
-	{"", 0},
-};
-
-static inline int __init is_exclusive_device(struct acpi_device *dev)
-{
-	return (!acpi_match_device_ids(dev, excluded_id_list));
-}
-
 /*
  * Compatible Device IDs
  */
@@ -266,7 +246,7 @@ static int __init pnpacpi_add_device(struct acpi_device *device)
 	if (!pnpid)
 		return 0;
 
-	if (is_exclusive_device(device) || !device->status.present)
+	if (!device->status.present)
 		return 0;
 
 	dev = pnp_alloc_dev(&pnpacpi_protocol, num, pnpid);
@@ -326,10 +306,10 @@ static acpi_status __init pnpacpi_add_device_handler(acpi_handle handle,
 {
 	struct acpi_device *device;
 
-	if (!acpi_bus_get_device(handle, &device))
-		pnpacpi_add_device(device);
-	else
+	if (acpi_bus_get_device(handle, &device))
 		return AE_CTRL_DEPTH;
+	if (acpi_is_pnp_device(device))
+		pnpacpi_add_device(device);
 	return AE_OK;
 }
 

commit a8d22396302b7e4e5f0a594c1c1594388c29edaf
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Apr 30 22:36:33 2014 +0200

    PNP / ACPI: Do not return errors if _DIS or _SRS are not present
    
    The ACPI PNP subsystem returns errors from pnpacpi_set_resources()
    and pnpacpi_disable_resources() if the _SRS or _DIS methods are not
    present, respectively, but it should not do that, because those
    methods are optional.  For this reason, modify pnpacpi_set_resources()
    and pnpacpi_disable_resources(), respectively, to ignore missing _SRS
    or _DIS.
    
    This problem has been uncovered by commit 202317a573b2 (ACPI / scan:
    Add acpi_device objects for all device nodes in the namespace) and
    manifested itself by causing serial port suspend to fail on some
    systems.
    
    Fixes: 202317a573b2 (ACPI / scan: Add acpi_device objects for all device nodes in the namespace)
    References: https://bugzilla.kernel.org/show_bug.cgi?id=74371
    Reported-by: wxg4net <wxg4net@gmail.com>
    Reported-and-tested-by: <nonproffessional@gmail.com>
    Cc: 3.14+ <stable@vger.kernel.org> # 3.14+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index 9f611cbbc294..c31aa07b3ba5 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -83,8 +83,7 @@ static int pnpacpi_set_resources(struct pnp_dev *dev)
 {
 	struct acpi_device *acpi_dev;
 	acpi_handle handle;
-	struct acpi_buffer buffer;
-	int ret;
+	int ret = 0;
 
 	pnp_dbg(&dev->dev, "set resources\n");
 
@@ -97,19 +96,26 @@ static int pnpacpi_set_resources(struct pnp_dev *dev)
 	if (WARN_ON_ONCE(acpi_dev != dev->data))
 		dev->data = acpi_dev;
 
-	ret = pnpacpi_build_resource_template(dev, &buffer);
-	if (ret)
-		return ret;
-	ret = pnpacpi_encode_resources(dev, &buffer);
-	if (ret) {
+	if (acpi_has_method(handle, METHOD_NAME__SRS)) {
+		struct acpi_buffer buffer;
+
+		ret = pnpacpi_build_resource_template(dev, &buffer);
+		if (ret)
+			return ret;
+
+		ret = pnpacpi_encode_resources(dev, &buffer);
+		if (!ret) {
+			acpi_status status;
+
+			status = acpi_set_current_resources(handle, &buffer);
+			if (ACPI_FAILURE(status))
+				ret = -EIO;
+		}
 		kfree(buffer.pointer);
-		return ret;
 	}
-	if (ACPI_FAILURE(acpi_set_current_resources(handle, &buffer)))
-		ret = -EINVAL;
-	else if (acpi_bus_power_manageable(handle))
+	if (!ret && acpi_bus_power_manageable(handle))
 		ret = acpi_bus_set_power(handle, ACPI_STATE_D0);
-	kfree(buffer.pointer);
+
 	return ret;
 }
 
@@ -117,7 +123,7 @@ static int pnpacpi_disable_resources(struct pnp_dev *dev)
 {
 	struct acpi_device *acpi_dev;
 	acpi_handle handle;
-	int ret;
+	acpi_status status;
 
 	dev_dbg(&dev->dev, "disable resources\n");
 
@@ -128,13 +134,15 @@ static int pnpacpi_disable_resources(struct pnp_dev *dev)
 	}
 
 	/* acpi_unregister_gsi(pnp_irq(dev, 0)); */
-	ret = 0;
 	if (acpi_bus_power_manageable(handle))
 		acpi_bus_set_power(handle, ACPI_STATE_D3_COLD);
-		/* continue even if acpi_bus_set_power() fails */
-	if (ACPI_FAILURE(acpi_evaluate_object(handle, "_DIS", NULL, NULL)))
-		ret = -ENODEV;
-	return ret;
+
+	/* continue even if acpi_bus_set_power() fails */
+	status = acpi_evaluate_object(handle, "_DIS", NULL, NULL);
+	if (ACPI_FAILURE(status) && status != AE_NOT_FOUND)
+		return -ENODEV;
+
+	return 0;
 }
 
 #ifdef CONFIG_ACPI_SLEEP

commit a759012e5f9717a69c2c2f03d6c7fe435e150824
Merge: bcc7201a9117 d8254e0e72c8
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Jan 12 23:48:18 2014 +0100

    Merge branch 'pnp'
    
    * pnp:
      PNPBIOS: check return value of pnp_add_device()
      PNP: Mark the function pnp_build_option() as static in resource.c
      PNP / card: add missing put_device() call
      PNPACPI: check return value of pnp_add_device()

commit 249135d1a2ea3c1719c48d31351413d55d2fdef4
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Sun Dec 15 04:10:11 2013 -0800

    PNPACPI: check return value of pnp_add_device()
    
    pnp_add_device() may fail so we need to handle errors and avoid leaking
    memory. Also, do not use ACPI-specific return codes (AE_OK) but rather
    standard one (0).
    
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index 14655a0f0431..4bd4c54ad205 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -242,6 +242,7 @@ static int __init pnpacpi_add_device(struct acpi_device *device)
 	struct pnp_dev *dev;
 	char *pnpid;
 	struct acpi_hardware_id *id;
+	int error;
 
 	/* Skip devices that are already bound */
 	if (device->physical_node_count)
@@ -300,10 +301,16 @@ static int __init pnpacpi_add_device(struct acpi_device *device)
 	/* clear out the damaged flags */
 	if (!dev->active)
 		pnp_init_resources(dev);
-	pnp_add_device(dev);
+
+	error = pnp_add_device(dev);
+	if (error) {
+		put_device(&dev->dev);
+		return error;
+	}
+
 	num++;
 
-	return AE_OK;
+	return 0;
 }
 
 static acpi_status __init pnpacpi_add_device_handler(acpi_handle handle,

commit e3f02c5228c4b600abf6ca243301176f25553bd5
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Nov 29 16:27:34 2013 +0100

    ACPI / bind: Rework struct acpi_bus_type
    
    Replace the .find_device function pointer in struct acpi_bus_type
    with a new one, .find_companion, that is supposed to point to a
    function returning struct acpi_device pointer (instead of an int)
    and takes one argument (instead of two).  This way the role of
    this callback is more clear and the implementation of it can
    be more straightforward.
    
    Update all of the users of struct acpi_bus_type (PCI, PNP/ACPI and
    USB) to reflect the structure change.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Tested-by: Lan Tianyu <tianyu.lan@intel.com> # for USB/ACPI

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index e869ba698ac0..156d14e2587e 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -328,20 +328,15 @@ static int __init acpi_pnp_match(struct device *dev, void *_pnp)
 	    && compare_pnp_id(pnp->id, acpi_device_hid(acpi));
 }
 
-static int __init acpi_pnp_find_device(struct device *dev, acpi_handle * handle)
+static struct acpi_device * __init acpi_pnp_find_companion(struct device *dev)
 {
-	struct device *adev;
-	struct acpi_device *acpi;
-
-	adev = bus_find_device(&acpi_bus_type, NULL,
-			       to_pnp_dev(dev), acpi_pnp_match);
-	if (!adev)
-		return -ENODEV;
+	dev = bus_find_device(&acpi_bus_type, NULL, to_pnp_dev(dev),
+			      acpi_pnp_match);
+	if (!dev)
+		return NULL;
 
-	acpi = to_acpi_device(adev);
-	*handle = acpi->handle;
-	put_device(adev);
-	return 0;
+	put_device(dev);
+	return to_acpi_device(dev);
 }
 
 /* complete initialization of a PNPACPI device includes having
@@ -355,7 +350,7 @@ static bool acpi_pnp_bus_match(struct device *dev)
 static struct acpi_bus_type __initdata acpi_pnp_bus = {
 	.name	     = "PNP",
 	.match	     = acpi_pnp_bus_match,
-	.find_device = acpi_pnp_find_device,
+	.find_companion = acpi_pnp_find_companion,
 };
 
 int pnpacpi_disabled __initdata;

commit 8b48463f89429af408ff695244dc627e1acff4f7
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Tue Dec 3 08:49:16 2013 +0800

    ACPI: Clean up inclusions of ACPI header files
    
    Replace direct inclusions of <acpi/acpi.h>, <acpi/acpi_bus.h> and
    <acpi/acpi_drivers.h>, which are incorrect, with <linux/acpi.h>
    inclusions and remove some inclusions of those files that aren't
    necessary.
    
    First of all, <acpi/acpi.h>, <acpi/acpi_bus.h> and <acpi/acpi_drivers.h>
    should not be included directly from any files that are built for
    CONFIG_ACPI unset, because that generally leads to build warnings about
    undefined symbols in !CONFIG_ACPI builds.  For CONFIG_ACPI set,
    <linux/acpi.h> includes those files and for CONFIG_ACPI unset it
    provides stub ACPI symbols to be used in that case.
    
    Second, there are ordering dependencies between those files that always
    have to be met.  Namely, it is required that <acpi/acpi_bus.h> be included
    prior to <acpi/acpi_drivers.h> so that the acpi_pci_root declarations the
    latter depends on are always there.  And <acpi/acpi.h> which provides
    basic ACPICA type declarations should always be included prior to any other
    ACPI headers in CONFIG_ACPI builds.  That also is taken care of including
    <linux/acpi.h> as appropriate.
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Matthew Garrett <mjg59@srcf.ucam.org>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com> (drivers/pci stuff)
    Acked-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com> (Xen stuff)
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index 14655a0f0431..e869ba698ac0 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -24,7 +24,6 @@
 #include <linux/pnp.h>
 #include <linux/slab.h>
 #include <linux/mod_devicetable.h>
-#include <acpi/acpi_bus.h>
 
 #include "../base.h"
 #include "pnpacpi.h"

commit 3a83f992490f8235661b768e53bd5f14915420ac
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Nov 14 23:17:21 2013 +0100

    ACPI: Eliminate the DEVICE_ACPI_HANDLE() macro
    
    Since DEVICE_ACPI_HANDLE() is now literally identical to
    ACPI_HANDLE(), replace it with the latter everywhere and drop its
    definition from include/acpi.h.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index 747826d99059..14655a0f0431 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -89,7 +89,7 @@ static int pnpacpi_set_resources(struct pnp_dev *dev)
 
 	pnp_dbg(&dev->dev, "set resources\n");
 
-	handle = DEVICE_ACPI_HANDLE(&dev->dev);
+	handle = ACPI_HANDLE(&dev->dev);
 	if (!handle || acpi_bus_get_device(handle, &acpi_dev)) {
 		dev_dbg(&dev->dev, "ACPI device not found in %s!\n", __func__);
 		return -ENODEV;
@@ -122,7 +122,7 @@ static int pnpacpi_disable_resources(struct pnp_dev *dev)
 
 	dev_dbg(&dev->dev, "disable resources\n");
 
-	handle = DEVICE_ACPI_HANDLE(&dev->dev);
+	handle = ACPI_HANDLE(&dev->dev);
 	if (!handle || acpi_bus_get_device(handle, &acpi_dev)) {
 		dev_dbg(&dev->dev, "ACPI device not found in %s!\n", __func__);
 		return 0;
@@ -144,7 +144,7 @@ static bool pnpacpi_can_wakeup(struct pnp_dev *dev)
 	struct acpi_device *acpi_dev;
 	acpi_handle handle;
 
-	handle = DEVICE_ACPI_HANDLE(&dev->dev);
+	handle = ACPI_HANDLE(&dev->dev);
 	if (!handle || acpi_bus_get_device(handle, &acpi_dev)) {
 		dev_dbg(&dev->dev, "ACPI device not found in %s!\n", __func__);
 		return false;
@@ -159,7 +159,7 @@ static int pnpacpi_suspend(struct pnp_dev *dev, pm_message_t state)
 	acpi_handle handle;
 	int error = 0;
 
-	handle = DEVICE_ACPI_HANDLE(&dev->dev);
+	handle = ACPI_HANDLE(&dev->dev);
 	if (!handle || acpi_bus_get_device(handle, &acpi_dev)) {
 		dev_dbg(&dev->dev, "ACPI device not found in %s!\n", __func__);
 		return 0;
@@ -194,7 +194,7 @@ static int pnpacpi_suspend(struct pnp_dev *dev, pm_message_t state)
 static int pnpacpi_resume(struct pnp_dev *dev)
 {
 	struct acpi_device *acpi_dev;
-	acpi_handle handle = DEVICE_ACPI_HANDLE(&dev->dev);
+	acpi_handle handle = ACPI_HANDLE(&dev->dev);
 	int error = 0;
 
 	if (!handle || acpi_bus_get_device(handle, &acpi_dev)) {

commit 0e77e2c416e8fa110fa0e749db0ae1e9344b6050
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Tue Sep 3 08:32:08 2013 +0800

    pnpacpi: convert acpi_get_handle() to acpi_has_method()
    
    acpi_has_method() is a new ACPI API introduced to check
    the existence of an ACPI control method.
    
    It can be used to replace acpi_get_handle() in the case that
    1. the calling function doesn't need the ACPI handle of the control method.
    and
    2. the calling function doesn't care the reason why the method is unavailable.
    
    Convert acpi_get_handle() to acpi_has_method()
    in drivers/pnp/pnpacpi/core.c in this patch.
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    CC: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index 34049b0b4c73..747826d99059 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -239,8 +239,6 @@ static char *__init pnpacpi_get_id(struct acpi_device *device)
 
 static int __init pnpacpi_add_device(struct acpi_device *device)
 {
-	acpi_handle temp = NULL;
-	acpi_status status;
 	struct pnp_dev *dev;
 	char *pnpid;
 	struct acpi_hardware_id *id;
@@ -253,8 +251,7 @@ static int __init pnpacpi_add_device(struct acpi_device *device)
 	 * If a PnPacpi device is not present , the device
 	 * driver should not be loaded.
 	 */
-	status = acpi_get_handle(device->handle, "_CRS", &temp);
-	if (ACPI_FAILURE(status))
+	if (!acpi_has_method(device->handle, "_CRS"))
 		return 0;
 
 	pnpid = pnpacpi_get_id(device);
@@ -271,16 +268,14 @@ static int __init pnpacpi_add_device(struct acpi_device *device)
 	dev->data = device;
 	/* .enabled means the device can decode the resources */
 	dev->active = device->status.enabled;
-	status = acpi_get_handle(device->handle, "_SRS", &temp);
-	if (ACPI_SUCCESS(status))
+	if (acpi_has_method(device->handle, "_SRS"))
 		dev->capabilities |= PNP_CONFIGURABLE;
 	dev->capabilities |= PNP_READ;
 	if (device->flags.dynamic_status && (dev->capabilities & PNP_CONFIGURABLE))
 		dev->capabilities |= PNP_WRITE;
 	if (device->flags.removable)
 		dev->capabilities |= PNP_REMOVABLE;
-	status = acpi_get_handle(device->handle, "_DIS", &temp);
-	if (ACPI_SUCCESS(status))
+	if (acpi_has_method(device->handle, "_DIS"))
 		dev->capabilities |= PNP_DISABLE;
 
 	if (strlen(acpi_device_name(device)))

commit 8ad928d52e63a9b7d69f0873d7318c4561e2f8cd
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Jul 30 14:36:20 2013 +0200

    ACPI / PM: Use ACPI_STATE_D3_COLD instead of ACPI_STATE_D3 everywhere
    
    There are several places in the tree where ACPI_STATE_D3 is used
    instead of ACPI_STATE_D3_COLD which should be used instead for
    clarity.  Modify them all to use ACPI_STATE_D3_COLD as appropriate.
    
    [The definition of ACPI_STATE_D3 itself cannot go away at this point
     as it is part of ACPICA.]
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Aaron Lu <aaron.lu@intel.com>

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index 55cd459a3908..34049b0b4c73 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -131,7 +131,7 @@ static int pnpacpi_disable_resources(struct pnp_dev *dev)
 	/* acpi_unregister_gsi(pnp_irq(dev, 0)); */
 	ret = 0;
 	if (acpi_bus_power_manageable(handle))
-		acpi_bus_set_power(handle, ACPI_STATE_D3);
+		acpi_bus_set_power(handle, ACPI_STATE_D3_COLD);
 		/* continue even if acpi_bus_set_power() fails */
 	if (ACPI_FAILURE(acpi_evaluate_object(handle, "_DIS", NULL, NULL)))
 		ret = -ENODEV;
@@ -174,10 +174,10 @@ static int pnpacpi_suspend(struct pnp_dev *dev, pm_message_t state)
 
 	if (acpi_bus_power_manageable(handle)) {
 		int power_state = acpi_pm_device_sleep_state(&dev->dev, NULL,
-							     ACPI_STATE_D3);
+							ACPI_STATE_D3_COLD);
 		if (power_state < 0)
 			power_state = (state.event == PM_EVENT_ON) ?
-					ACPI_STATE_D0 : ACPI_STATE_D3;
+					ACPI_STATE_D0 : ACPI_STATE_D3_COLD;
 
 		/*
 		 * acpi_bus_set_power() often fails (keyboard port can't be

commit 53540098b23c3884b4a0b4f220b9d977bc496af3
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Mar 3 22:35:20 2013 +0100

    ACPI / glue: Add .match() callback to struct acpi_bus_type
    
    USB uses the .find_bridge() callback from struct acpi_bus_type
    incorrectly, because as a result of the way it is used by USB every
    device in the system that doesn't have a bus type or parent is
    passed to usb_acpi_find_device() for inspection.
    
    What USB actually needs, though, is to call usb_acpi_find_device()
    for USB ports that don't have a bus type defined, but have
    usb_port_device_type as their device type, as well as for USB
    devices.
    
    To fix that replace the struct bus_type pointer in struct
    acpi_bus_type used for matching devices to specific subsystems
    with a .match() callback to be used for this purpose and update
    the users of struct acpi_bus_type, including USB, accordingly.
    Define the .match() callback routine for USB, usb_acpi_bus_match(),
    in such a way that it will cover both USB devices and USB ports
    and remove the now redundant .find_bridge() callback pointer from
    usb_acpi_bus.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Yinghai Lu <yinghai@kernel.org>
    Acked-by: Jeff Garzik <jgarzik@pobox.com>

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index 8813fc03aa09..55cd459a3908 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -353,8 +353,14 @@ static int __init acpi_pnp_find_device(struct device *dev, acpi_handle * handle)
 /* complete initialization of a PNPACPI device includes having
  * pnpdev->dev.archdata.acpi_handle point to its ACPI sibling.
  */
+static bool acpi_pnp_bus_match(struct device *dev)
+{
+	return dev->bus == &pnp_bus_type;
+}
+
 static struct acpi_bus_type __initdata acpi_pnp_bus = {
-	.bus	     = &pnp_bus_type,
+	.name	     = "PNP",
+	.match	     = acpi_pnp_bus_match,
 	.find_device = acpi_pnp_find_device,
 };
 

commit cfc57557f204c09c2c028be6e18923e9475c311d
Author: Yasuaki Ishimatsu <isimatu.yasuaki@jp.fujitsu.com>
Date:   Thu Jan 31 03:26:12 2013 +0000

    PNPACPI: Fix acpi_bus_get_device() check in drivers/pnp/pnpacpi/core.c
    
    acpi_bus_get_device() returns int not acpi_status.
    
    The patch change not to apply ACPI_FAILURE() to the return value of
    acpi_bus_get_device().
    
    Signed-off-by: Yasuaki Ishimatsu <isimatu.yasuaki@jp.fujitsu.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index 72e822e17d47..8813fc03aa09 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -90,7 +90,7 @@ static int pnpacpi_set_resources(struct pnp_dev *dev)
 	pnp_dbg(&dev->dev, "set resources\n");
 
 	handle = DEVICE_ACPI_HANDLE(&dev->dev);
-	if (!handle || ACPI_FAILURE(acpi_bus_get_device(handle, &acpi_dev))) {
+	if (!handle || acpi_bus_get_device(handle, &acpi_dev)) {
 		dev_dbg(&dev->dev, "ACPI device not found in %s!\n", __func__);
 		return -ENODEV;
 	}
@@ -123,7 +123,7 @@ static int pnpacpi_disable_resources(struct pnp_dev *dev)
 	dev_dbg(&dev->dev, "disable resources\n");
 
 	handle = DEVICE_ACPI_HANDLE(&dev->dev);
-	if (!handle || ACPI_FAILURE(acpi_bus_get_device(handle, &acpi_dev))) {
+	if (!handle || acpi_bus_get_device(handle, &acpi_dev)) {
 		dev_dbg(&dev->dev, "ACPI device not found in %s!\n", __func__);
 		return 0;
 	}
@@ -145,7 +145,7 @@ static bool pnpacpi_can_wakeup(struct pnp_dev *dev)
 	acpi_handle handle;
 
 	handle = DEVICE_ACPI_HANDLE(&dev->dev);
-	if (!handle || ACPI_FAILURE(acpi_bus_get_device(handle, &acpi_dev))) {
+	if (!handle || acpi_bus_get_device(handle, &acpi_dev)) {
 		dev_dbg(&dev->dev, "ACPI device not found in %s!\n", __func__);
 		return false;
 	}
@@ -160,7 +160,7 @@ static int pnpacpi_suspend(struct pnp_dev *dev, pm_message_t state)
 	int error = 0;
 
 	handle = DEVICE_ACPI_HANDLE(&dev->dev);
-	if (!handle || ACPI_FAILURE(acpi_bus_get_device(handle, &acpi_dev))) {
+	if (!handle || acpi_bus_get_device(handle, &acpi_dev)) {
 		dev_dbg(&dev->dev, "ACPI device not found in %s!\n", __func__);
 		return 0;
 	}
@@ -197,7 +197,7 @@ static int pnpacpi_resume(struct pnp_dev *dev)
 	acpi_handle handle = DEVICE_ACPI_HANDLE(&dev->dev);
 	int error = 0;
 
-	if (!handle || ACPI_FAILURE(acpi_bus_get_device(handle, &acpi_dev))) {
+	if (!handle || acpi_bus_get_device(handle, &acpi_dev)) {
 		dev_dbg(&dev->dev, "ACPI device not found in %s!\n", __func__);
 		return -ENODEV;
 	}

commit 1a14f30b36e5d20a2a1be24888c2158541d97bab
Merge: 583bdc598206 cdc87c5a30f4
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Dec 7 23:14:35 2012 +0100

    Merge branch 'acpi-general'
    
    * acpi-general:
      pnpacpi: fix incorrect TEST_ALPHA() test
      ACPI / video: ignore BIOS initial backlight value for HP Folio 13-2000
      ACPI : do not use Lid and Sleep button for S5 wakeup

commit cdc87c5a30f407ed1ce43d8a22261116873d5ef1
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Fri Dec 7 23:11:14 2012 +0100

    pnpacpi: fix incorrect TEST_ALPHA() test
    
    TEST_ALPHA() is broken and always returns 0.
    
    [akpm@linux-foundation.org: return false for '@' as well, per Bjorn]
    Signed-off-by: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index ec8e914f756c..767f526209e8 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -58,7 +58,7 @@ static inline int __init is_exclusive_device(struct acpi_device *dev)
 	if (!(('0' <= (c) && (c) <= '9') || ('A' <= (c) && (c) <= 'F'))) \
 		return 0
 #define TEST_ALPHA(c) \
-	if (!('@' <= (c) || (c) <= 'Z')) \
+	if (!('A' <= (c) && (c) <= 'Z')) \
 		return 0
 static int __init ispnpidacpi(const char *id)
 {

commit 6b728f1a906976ec658827adc9c2d27608aa8517
Merge: d9ba1025a46d a6b5e88c0e42
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Dec 4 13:46:08 2012 +0100

    Merge branch 'acpi-general'
    
    * acpi-general:
      ACPI / PNP: Do not crash due to stale pointer use during system resume
      ACPI / video: Add "Asus UL30VT" to ACPI video detect blacklist
      ACPI: do acpisleep dmi check when CONFIG_ACPI_SLEEP is set

commit a6b5e88c0e42093b9057856f35770966c8c591e3
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Nov 30 13:05:05 2012 +0100

    ACPI / PNP: Do not crash due to stale pointer use during system resume
    
    During resume from system suspend the 'data' field of
    struct pnp_dev in pnpacpi_set_resources() may be a stale pointer,
    due to removal of the associated ACPI device node object in the
    previous suspend-resume cycle.  This happens, for example, if a
    dockable machine is booted in the docking station and then suspended
    and resumed and suspended again.  If that happens,
    pnpacpi_build_resource_template() called from pnpacpi_set_resources()
    attempts to use that pointer and crashes.
    
    However, pnpacpi_set_resources() actually checks the device's ACPI
    handle, attempts to find the ACPI device node object attached to it
    and returns an error code if that fails, so in fact it knows what the
    correct value of dev->data should be.  Use this observation to update
    dev->data with the correct value if necessary and dump a call trace
    if that's the case (once).
    
    We still need to fix the root cause of this issue, but preventing
    systems from crashing because of it is an improvement too.
    
    Reported-and-tested-by: Zdenek Kabelac <zdenek.kabelac@gmail.com>
    References: https://bugzilla.kernel.org/show_bug.cgi?id=51071
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index 26b5d4b18dd7..ec8e914f756c 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -95,6 +95,9 @@ static int pnpacpi_set_resources(struct pnp_dev *dev)
 		return -ENODEV;
 	}
 
+	if (WARN_ON_ONCE(acpi_dev != dev->data))
+		dev->data = acpi_dev;
+
 	ret = pnpacpi_build_resource_template(dev, &buffer);
 	if (ret)
 		return ret;

commit 2905875344f977acd188a2b0f1d163491e91459b
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Fri Nov 23 21:07:12 2012 +0100

    ACPI / PNP: skip ACPI device nodes associated with physical nodes already
    
    Make pnpacpi_add_device() ignore ACPI device nodes already associated
    with struct device objects representing physical devices.
    
    In particular, this will prevent PNP device objects from being
    created for ACPI device nodes already associated with platform
    devices.
    
    This change was originally proposed by Mika Westerberg.
    
    [rjw: Modified the subject and changelog.]
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index 26b5d4b18dd7..653d5637a37c 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -242,6 +242,10 @@ static int __init pnpacpi_add_device(struct acpi_device *device)
 	char *pnpid;
 	struct acpi_hardware_id *id;
 
+	/* Skip devices that are already bound */
+	if (device->physical_node_count)
+		return 0;
+
 	/*
 	 * If a PnPacpi device is not present , the device
 	 * driver should not be loaded.

commit 1033f9041d526dd694e2b2e12744e47c41040c4d
Author: Lan Tianyu <tianyu.lan@intel.com>
Date:   Fri Aug 17 14:44:09 2012 +0800

    ACPI: Allow ACPI binding with USB-3.0 hub
    
    A USB port's position and connectability can't be identified on some boards
    via USB hub registers. ACPI _UPC and _PLD can help to resolve this issue
    and so it is necessary to bind USB with ACPI. This patch is to allow ACPI
    binding with USB-3.0 hub.
    
    Current ACPI only can bind one struct-device to one ACPI device node.
    This can not work with USB-3.0 hub, because the USB-3.0 hub has two logical
    devices. Each works for USB-2.0 and USB-3.0 devices. In the Linux USB subsystem,
    those two logical hubs are treated as two seperate devices that have two struct
    devices. But in the ACPI DSDT, these two logical hubs share one ACPI device
    node. So there is a requirement to bind multi struct-devices to one ACPI
    device node. This patch is to resolve such problem.
    
    Following is the ACPI device nodes' description under xhci hcd.
    
    Device (XHC)
                Device (RHUB)
                    Device (HSP1)
                    Device (HSP2)
                    Device (HSP3)
                    Device (HSP4)
                    Device (SSP1)
                    Device (SSP2)
                    Device (SSP3)
                    Device (SSP4)
    
    Topology in the Linux
    
            device XHC
               USB-2.0 logical hub    USB-3.0 logical hub
                    HSP1                    SSP1
                    HSP2                    SSP2
                    HSP3                    SSP3
                    HSP4                    SSP4
    
    This patch also modifies the output of /proc/acpi/wakeup. One ACPI node
    can be associated with multiple devices:
    
    XHC             S4      *enabled        pci:0000:00:14.0
    RHUB    S0      disabled        usb:usb1
                            disabled        usb:usb2
    
    Signed-off-by: Lan Tianyu <tianyu.lan@intel.com>
    Acked-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index 507a8e2b9a4c..26b5d4b18dd7 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -321,14 +321,9 @@ static int __init acpi_pnp_match(struct device *dev, void *_pnp)
 {
 	struct acpi_device *acpi = to_acpi_device(dev);
 	struct pnp_dev *pnp = _pnp;
-	struct device *physical_device;
-
-	physical_device = acpi_get_physical_device(acpi->handle);
-	if (physical_device)
-		put_device(physical_device);
 
 	/* true means it matched */
-	return !physical_device
+	return !acpi->physical_node_count
 	    && compare_pnp_id(pnp->id, acpi_device_hid(acpi));
 }
 

commit ee85f543710dd56ce526cb44e39191f32972e5ad
Author: Huang Ying <ying.huang@intel.com>
Date:   Sat Jun 23 10:23:48 2012 +0800

    ACPI/PM: specify lowest allowed state for device sleep state
    
    Lower device sleep state can save more power, but has more exit
    latency too.  Sometimes, to satisfy some power QoS and other
    requirement, we need to constrain the lowest device sleep state.
    
    In this patch, a parameter to specify lowest allowed state for
    acpi_pm_device_sleep_state is added.  So that the caller can enforce
    the constraint via the parameter.
    
    This is needed by PCIe D3cold support, where the lowest power state
    allowed may be D3_HOT instead of default D3_COLD.
    
    CC: Len Brown <lenb@kernel.org>
    CC: linux-acpi@vger.kernel.org
    Reviewed-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Huang Ying <ying.huang@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index d21e8f59c84e..507a8e2b9a4c 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -170,8 +170,8 @@ static int pnpacpi_suspend(struct pnp_dev *dev, pm_message_t state)
 	}
 
 	if (acpi_bus_power_manageable(handle)) {
-		int power_state = acpi_pm_device_sleep_state(&dev->dev, NULL);
-
+		int power_state = acpi_pm_device_sleep_state(&dev->dev, NULL,
+							     ACPI_STATE_D3);
 		if (power_state < 0)
 			power_state = (state.event == PM_EVENT_ON) ?
 					ACPI_STATE_D0 : ACPI_STATE_D3;

commit 89e96ada572fb216e582dbe3f64e1a6939a37f74
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Sat Mar 3 13:29:20 2012 -0800

    PNPACPI: Fix device ref leaking in acpi_pnp_match
    
    During testing pci root bus removal, found some root bus bridge is not freed.
    If booting with pnpacpi=off, those hostbridge could be freed without problem.
    It turns out that some devices reference are not released during acpi_pnp_match.
    that match should not hold one device ref during every calling.
    Add pu_device calling before returning.
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Cc: stable@vger.kernel.org
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index b00c17612a89..d21e8f59c84e 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -321,9 +321,14 @@ static int __init acpi_pnp_match(struct device *dev, void *_pnp)
 {
 	struct acpi_device *acpi = to_acpi_device(dev);
 	struct pnp_dev *pnp = _pnp;
+	struct device *physical_device;
+
+	physical_device = acpi_get_physical_device(acpi->handle);
+	if (physical_device)
+		put_device(physical_device);
 
 	/* true means it matched */
-	return !acpi_get_physical_device(acpi->handle)
+	return !physical_device
 	    && compare_pnp_id(pnp->id, acpi_device_hid(acpi));
 }
 

commit 26e6e9e54ca197005421e0f0b852e3517eb3e2f5
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Wed Oct 26 18:06:20 2011 -0400

    pnp: Add export.h for EXPORT_SYMBOL/THIS_MODULE as required
    
    These macros are no longer in module.h and module.h is no longer
    present everywhere.  Call out export.h for the users who are
    making use of these macros.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index ca84d5099ce7..b00c17612a89 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -19,6 +19,7 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
+#include <linux/export.h>
 #include <linux/acpi.h>
 #include <linux/pnp.h>
 #include <linux/slab.h>

commit cc8e7a355c1ec64b06a5b8126c47c5cb47f44fce
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Jan 10 21:23:16 2011 +0100

    PNP / ACPI: Use DEVICE_ACPI_HANDLE() for device ACPI handle access
    
    The PNP ACPI driver squirrels the ACPI handles of PNP devices' ACPI
    companions, but this isn't correct, because those handles should be
    accessed using the DEVICE_ACPI_HANDLE() macro operating on struct
    device objects.
    
    Using DEVICE_ACPI_HANDLE() in the PNP ACPI driver instead of the
    driver's own copies of the ACPI handles allows us to avoid a problem
    with docking stations where a machine docked before suspend to RAM
    and undocked while suspended crashes during the subsequent resume (in
    that case the ACPI companion of the PNP device in question doesn't
    exist any more while the device is being resumed).  It also allows us
    to avoid the problem where suspend to RAM fails when the machine was
    undocked while suspended before (again, the ACPI companion of the PNP
    device is not present any more while it is being suspended).
    
    This change doesn't fix all of the the PNP ACPI driver's problems
    with PNP devices in docking stations (generally speaking, the driver
    has no idea that devices can come and go and doesn't even attempt to
    handle such events), but at least it makes suspend work for the
    users of docking stations who don't use the PNP devices located in
    there.
    
    References: https://bugzilla.kernel.org/show_bug.cgi?id=15100
    
    Reported-and-tested-by: Toralf Förster <toralf.foerster@gmx.de>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index 57313f4658bc..ca84d5099ce7 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -81,12 +81,19 @@ static int pnpacpi_get_resources(struct pnp_dev *dev)
 
 static int pnpacpi_set_resources(struct pnp_dev *dev)
 {
-	struct acpi_device *acpi_dev = dev->data;
-	acpi_handle handle = acpi_dev->handle;
+	struct acpi_device *acpi_dev;
+	acpi_handle handle;
 	struct acpi_buffer buffer;
 	int ret;
 
 	pnp_dbg(&dev->dev, "set resources\n");
+
+	handle = DEVICE_ACPI_HANDLE(&dev->dev);
+	if (!handle || ACPI_FAILURE(acpi_bus_get_device(handle, &acpi_dev))) {
+		dev_dbg(&dev->dev, "ACPI device not found in %s!\n", __func__);
+		return -ENODEV;
+	}
+
 	ret = pnpacpi_build_resource_template(dev, &buffer);
 	if (ret)
 		return ret;
@@ -105,12 +112,18 @@ static int pnpacpi_set_resources(struct pnp_dev *dev)
 
 static int pnpacpi_disable_resources(struct pnp_dev *dev)
 {
-	struct acpi_device *acpi_dev = dev->data;
-	acpi_handle handle = acpi_dev->handle;
+	struct acpi_device *acpi_dev;
+	acpi_handle handle;
 	int ret;
 
 	dev_dbg(&dev->dev, "disable resources\n");
 
+	handle = DEVICE_ACPI_HANDLE(&dev->dev);
+	if (!handle || ACPI_FAILURE(acpi_bus_get_device(handle, &acpi_dev))) {
+		dev_dbg(&dev->dev, "ACPI device not found in %s!\n", __func__);
+		return 0;
+	}
+
 	/* acpi_unregister_gsi(pnp_irq(dev, 0)); */
 	ret = 0;
 	if (acpi_bus_power_manageable(handle))
@@ -124,46 +137,74 @@ static int pnpacpi_disable_resources(struct pnp_dev *dev)
 #ifdef CONFIG_ACPI_SLEEP
 static bool pnpacpi_can_wakeup(struct pnp_dev *dev)
 {
-	struct acpi_device *acpi_dev = dev->data;
-	acpi_handle handle = acpi_dev->handle;
+	struct acpi_device *acpi_dev;
+	acpi_handle handle;
+
+	handle = DEVICE_ACPI_HANDLE(&dev->dev);
+	if (!handle || ACPI_FAILURE(acpi_bus_get_device(handle, &acpi_dev))) {
+		dev_dbg(&dev->dev, "ACPI device not found in %s!\n", __func__);
+		return false;
+	}
 
 	return acpi_bus_can_wakeup(handle);
 }
 
 static int pnpacpi_suspend(struct pnp_dev *dev, pm_message_t state)
 {
-	struct acpi_device *acpi_dev = dev->data;
-	acpi_handle handle = acpi_dev->handle;
-	int power_state;
+	struct acpi_device *acpi_dev;
+	acpi_handle handle;
+	int error = 0;
+
+	handle = DEVICE_ACPI_HANDLE(&dev->dev);
+	if (!handle || ACPI_FAILURE(acpi_bus_get_device(handle, &acpi_dev))) {
+		dev_dbg(&dev->dev, "ACPI device not found in %s!\n", __func__);
+		return 0;
+	}
 
 	if (device_can_wakeup(&dev->dev)) {
-		int rc = acpi_pm_device_sleep_wake(&dev->dev,
+		error = acpi_pm_device_sleep_wake(&dev->dev,
 				device_may_wakeup(&dev->dev));
+		if (error)
+			return error;
+	}
+
+	if (acpi_bus_power_manageable(handle)) {
+		int power_state = acpi_pm_device_sleep_state(&dev->dev, NULL);
+
+		if (power_state < 0)
+			power_state = (state.event == PM_EVENT_ON) ?
+					ACPI_STATE_D0 : ACPI_STATE_D3;
 
-		if (rc)
-			return rc;
+		/*
+		 * acpi_bus_set_power() often fails (keyboard port can't be
+		 * powered-down?), and in any case, our return value is ignored
+		 * by pnp_bus_suspend().  Hence we don't revert the wakeup
+		 * setting if the set_power fails.
+		 */
+		error = acpi_bus_set_power(handle, power_state);
 	}
-	power_state = acpi_pm_device_sleep_state(&dev->dev, NULL);
-	if (power_state < 0)
-		power_state = (state.event == PM_EVENT_ON) ?
-				ACPI_STATE_D0 : ACPI_STATE_D3;
-
-	/* acpi_bus_set_power() often fails (keyboard port can't be
-	 * powered-down?), and in any case, our return value is ignored
-	 * by pnp_bus_suspend().  Hence we don't revert the wakeup
-	 * setting if the set_power fails.
-	 */
-	return acpi_bus_set_power(handle, power_state);
+
+	return error;
 }
 
 static int pnpacpi_resume(struct pnp_dev *dev)
 {
-	struct acpi_device *acpi_dev = dev->data;
-	acpi_handle handle = acpi_dev->handle;
+	struct acpi_device *acpi_dev;
+	acpi_handle handle = DEVICE_ACPI_HANDLE(&dev->dev);
+	int error = 0;
+
+	if (!handle || ACPI_FAILURE(acpi_bus_get_device(handle, &acpi_dev))) {
+		dev_dbg(&dev->dev, "ACPI device not found in %s!\n", __func__);
+		return -ENODEV;
+	}
 
 	if (device_may_wakeup(&dev->dev))
 		acpi_pm_device_sleep_wake(&dev->dev, false);
-	return acpi_bus_set_power(handle, ACPI_STATE_D0);
+
+	if (acpi_bus_power_manageable(handle))
+		error = acpi_bus_set_power(handle, ACPI_STATE_D0);
+
+	return error;
 }
 #endif
 

commit 66c3ec4f1f70ee87833363166b594855631d7ba6
Author: Jan Beulich <JBeulich@novell.com>
Date:   Tue Dec 7 15:05:49 2010 +0000

    ACPI/PNP: avoid section mismatch warning
    
    Signed-off-by: Jan Beulich <jbeulich@novell.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index 2d73dfcecdbb..57313f4658bc 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -180,7 +180,7 @@ struct pnp_protocol pnpacpi_protocol = {
 };
 EXPORT_SYMBOL(pnpacpi_protocol);
 
-static char *pnpacpi_get_id(struct acpi_device *device)
+static char *__init pnpacpi_get_id(struct acpi_device *device)
 {
 	struct acpi_hardware_id *id;
 

commit b10b977b792bb28c03267e00562c8254dca50f36
Merge: 22156ea7bb63 420a0f66378c
Author: Len Brown <len.brown@intel.com>
Date:   Mon Oct 25 02:13:44 2010 -0400

    Merge branch 'pnpacpi-invalid-device-id' into release

commit 620e112cfe1c9281c176de8ad1a7691c4eb4950d
Author: Thomas Renninger <trenn@suse.de>
Date:   Fri Oct 1 10:54:00 2010 +0200

    ACPI/PNP: A HID value of an object never changes -> make it const
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index dc4e32e031e9..4aafcf89b03b 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -59,7 +59,7 @@ static inline int __init is_exclusive_device(struct acpi_device *dev)
 #define TEST_ALPHA(c) \
 	if (!('@' <= (c) || (c) <= 'Z')) \
 		return 0
-static int __init ispnpidacpi(char *id)
+static int __init ispnpidacpi(const char *id)
 {
 	TEST_ALPHA(id[0]);
 	TEST_ALPHA(id[1]);

commit 420a0f66378c84b00b0e603e4d38210102dbe367
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Sat Sep 18 10:11:09 2010 -0700

    PNPACPI: cope with invalid device IDs
    
    If primary ID (HID) is invalid try locating first valid ID on compatible
    ID list before giving up.
    
    This helps, for example, to recognize i8042 AUX port on Sony Vaio VPCZ1
    which uses SNYSYN0003 as HID. Without the patch users are forced to
    boot with i8042.nopnp to make use of their touchpads.
    
    Tested-by: Jan-Hendrik Zab <jan@jhz.name>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index dc4e32e031e9..0d943eea1c2d 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -28,7 +28,7 @@
 #include "../base.h"
 #include "pnpacpi.h"
 
-static int num = 0;
+static int num;
 
 /* We need only to blacklist devices that have already an acpi driver that
  * can't use pnp layer. We don't need to blacklist device that are directly
@@ -180,11 +180,24 @@ struct pnp_protocol pnpacpi_protocol = {
 };
 EXPORT_SYMBOL(pnpacpi_protocol);
 
+static char *pnpacpi_get_id(struct acpi_device *device)
+{
+	struct acpi_hardware_id *id;
+
+	list_for_each_entry(id, &device->pnp.ids, list) {
+		if (ispnpidacpi(id->id))
+			return id->id;
+	}
+
+	return NULL;
+}
+
 static int __init pnpacpi_add_device(struct acpi_device *device)
 {
 	acpi_handle temp = NULL;
 	acpi_status status;
 	struct pnp_dev *dev;
+	char *pnpid;
 	struct acpi_hardware_id *id;
 
 	/*
@@ -192,11 +205,17 @@ static int __init pnpacpi_add_device(struct acpi_device *device)
 	 * driver should not be loaded.
 	 */
 	status = acpi_get_handle(device->handle, "_CRS", &temp);
-	if (ACPI_FAILURE(status) || !ispnpidacpi(acpi_device_hid(device)) ||
-	    is_exclusive_device(device) || (!device->status.present))
+	if (ACPI_FAILURE(status))
+		return 0;
+
+	pnpid = pnpacpi_get_id(device);
+	if (!pnpid)
+		return 0;
+
+	if (is_exclusive_device(device) || !device->status.present)
 		return 0;
 
-	dev = pnp_alloc_dev(&pnpacpi_protocol, num, acpi_device_hid(device));
+	dev = pnp_alloc_dev(&pnpacpi_protocol, num, pnpid);
 	if (!dev)
 		return -ENOMEM;
 
@@ -227,7 +246,7 @@ static int __init pnpacpi_add_device(struct acpi_device *device)
 		pnpacpi_parse_resource_option_data(dev);
 
 	list_for_each_entry(id, &device->pnp.ids, list) {
-		if (!strcmp(id->id, acpi_device_hid(device)))
+		if (!strcmp(id->id, pnpid))
 			continue;
 		if (!ispnpidacpi(id->id))
 			continue;

commit b14e033e17d0ea0ba12668d0d2f371cd31586994
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Jun 29 22:49:24 2010 +0200

    PNPACPI: Add support for remote wakeup
    
    This patch (as1354) adds remote-wakeup support to the pnpacpi driver.
    The new can_wakeup method also allows other PNP protocol drivers
    (pnpbios or iaspnp) to add wakeup support, but I don't know enough
    about how they work to actually do it.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Reviewed-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index f7ff628b7d94..dc4e32e031e9 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -122,17 +122,37 @@ static int pnpacpi_disable_resources(struct pnp_dev *dev)
 }
 
 #ifdef CONFIG_ACPI_SLEEP
+static bool pnpacpi_can_wakeup(struct pnp_dev *dev)
+{
+	struct acpi_device *acpi_dev = dev->data;
+	acpi_handle handle = acpi_dev->handle;
+
+	return acpi_bus_can_wakeup(handle);
+}
+
 static int pnpacpi_suspend(struct pnp_dev *dev, pm_message_t state)
 {
 	struct acpi_device *acpi_dev = dev->data;
 	acpi_handle handle = acpi_dev->handle;
 	int power_state;
 
+	if (device_can_wakeup(&dev->dev)) {
+		int rc = acpi_pm_device_sleep_wake(&dev->dev,
+				device_may_wakeup(&dev->dev));
+
+		if (rc)
+			return rc;
+	}
 	power_state = acpi_pm_device_sleep_state(&dev->dev, NULL);
 	if (power_state < 0)
 		power_state = (state.event == PM_EVENT_ON) ?
 				ACPI_STATE_D0 : ACPI_STATE_D3;
 
+	/* acpi_bus_set_power() often fails (keyboard port can't be
+	 * powered-down?), and in any case, our return value is ignored
+	 * by pnp_bus_suspend().  Hence we don't revert the wakeup
+	 * setting if the set_power fails.
+	 */
 	return acpi_bus_set_power(handle, power_state);
 }
 
@@ -141,6 +161,8 @@ static int pnpacpi_resume(struct pnp_dev *dev)
 	struct acpi_device *acpi_dev = dev->data;
 	acpi_handle handle = acpi_dev->handle;
 
+	if (device_may_wakeup(&dev->dev))
+		acpi_pm_device_sleep_wake(&dev->dev, false);
 	return acpi_bus_set_power(handle, ACPI_STATE_D0);
 }
 #endif
@@ -151,6 +173,7 @@ struct pnp_protocol pnpacpi_protocol = {
 	.set	 = pnpacpi_set_resources,
 	.disable = pnpacpi_disable_resources,
 #ifdef CONFIG_ACPI_SLEEP
+	.can_wakeup = pnpacpi_can_wakeup,
 	.suspend = pnpacpi_suspend,
 	.resume = pnpacpi_resume,
 #endif

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index 5314bf630bc4..f7ff628b7d94 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -21,6 +21,7 @@
 
 #include <linux/acpi.h>
 #include <linux/pnp.h>
+#include <linux/slab.h>
 #include <linux/mod_devicetable.h>
 #include <acpi/acpi_bus.h>
 

commit 9065ce4500085b9ca66b19d3c4d21a73cb410173
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Nov 17 17:05:19 2009 -0700

    PNP: add interface to retrieve ACPI device from a PNPACPI device
    
    Add pnp_acpi_device(pnp_dev), which takes a PNP device and returns the
    associated ACPI device (or NULL, if the device is not a PNPACPI device).
    
    This allows us to write a PNP driver that can manage both traditional
    PNPBIOS and ACPI devices, treating ACPI-only functionality as an optional
    extension.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index b2348fc2378e..5314bf630bc4 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -144,7 +144,7 @@ static int pnpacpi_resume(struct pnp_dev *dev)
 }
 #endif
 
-static struct pnp_protocol pnpacpi_protocol = {
+struct pnp_protocol pnpacpi_protocol = {
 	.name	 = "Plug and Play ACPI",
 	.get	 = pnpacpi_get_resources,
 	.set	 = pnpacpi_set_resources,
@@ -154,6 +154,7 @@ static struct pnp_protocol pnpacpi_protocol = {
 	.resume = pnpacpi_resume,
 #endif
 };
+EXPORT_SYMBOL(pnpacpi_protocol);
 
 static int __init pnpacpi_add_device(struct acpi_device *device)
 {

commit c4da6940a7a41c72781ff2d62ebd4b99f3749f14
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Nov 17 17:05:14 2009 -0700

    PNPACPI: save struct acpi_device, not just acpi_handle
    
    Some drivers need to look at things in the acpi_device structure
    besides the handle.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index 83b8b5ac49c9..b2348fc2378e 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -80,7 +80,8 @@ static int pnpacpi_get_resources(struct pnp_dev *dev)
 
 static int pnpacpi_set_resources(struct pnp_dev *dev)
 {
-	acpi_handle handle = dev->data;
+	struct acpi_device *acpi_dev = dev->data;
+	acpi_handle handle = acpi_dev->handle;
 	struct acpi_buffer buffer;
 	int ret;
 
@@ -103,7 +104,8 @@ static int pnpacpi_set_resources(struct pnp_dev *dev)
 
 static int pnpacpi_disable_resources(struct pnp_dev *dev)
 {
-	acpi_handle handle = dev->data;
+	struct acpi_device *acpi_dev = dev->data;
+	acpi_handle handle = acpi_dev->handle;
 	int ret;
 
 	dev_dbg(&dev->dev, "disable resources\n");
@@ -121,6 +123,8 @@ static int pnpacpi_disable_resources(struct pnp_dev *dev)
 #ifdef CONFIG_ACPI_SLEEP
 static int pnpacpi_suspend(struct pnp_dev *dev, pm_message_t state)
 {
+	struct acpi_device *acpi_dev = dev->data;
+	acpi_handle handle = acpi_dev->handle;
 	int power_state;
 
 	power_state = acpi_pm_device_sleep_state(&dev->dev, NULL);
@@ -128,12 +132,15 @@ static int pnpacpi_suspend(struct pnp_dev *dev, pm_message_t state)
 		power_state = (state.event == PM_EVENT_ON) ?
 				ACPI_STATE_D0 : ACPI_STATE_D3;
 
-	return acpi_bus_set_power((acpi_handle) dev->data, power_state);
+	return acpi_bus_set_power(handle, power_state);
 }
 
 static int pnpacpi_resume(struct pnp_dev *dev)
 {
-	return acpi_bus_set_power((acpi_handle) dev->data, ACPI_STATE_D0);
+	struct acpi_device *acpi_dev = dev->data;
+	acpi_handle handle = acpi_dev->handle;
+
+	return acpi_bus_set_power(handle, ACPI_STATE_D0);
 }
 #endif
 
@@ -168,7 +175,7 @@ static int __init pnpacpi_add_device(struct acpi_device *device)
 	if (!dev)
 		return -ENOMEM;
 
-	dev->data = device->handle;
+	dev->data = device;
 	/* .enabled means the device can decode the resources */
 	dev->active = device->status.enabled;
 	status = acpi_get_handle(device->handle, "_SRS", &temp);

commit 1131b938f0757350f569f8ad5bee737cd02b8e58
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Sep 21 13:35:29 2009 -0600

    ACPI: remove acpi_device.flags.hardware_id
    
    Every acpi_device has at least one ID (if there's no _HID or _CID, we
    give it a synthetic or default ID).  So there's no longer a need to
    check whether an ID exists; we can just use it.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index 3a4478f1fc72..83b8b5ac49c9 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -230,8 +230,7 @@ static int __init acpi_pnp_match(struct device *dev, void *_pnp)
 	struct pnp_dev *pnp = _pnp;
 
 	/* true means it matched */
-	return acpi->flags.hardware_id
-	    && !acpi_get_physical_device(acpi->handle)
+	return !acpi_get_physical_device(acpi->handle)
 	    && compare_pnp_id(pnp->id, acpi_device_hid(acpi));
 }
 

commit 7f47fa6c2ff15f5e59cdbb350f86faef6829294a
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Sep 21 13:35:19 2009 -0600

    ACPI: maintain a single list of _HID and _CID IDs
    
    There's no need to treat _HID and _CID differently.  Keeping them in
    a single list makes code that uses the IDs a little simpler because it
    can just traverse the list rather than checking "do we have a HID?",
    "do we have any CIDs?"
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Reviewed-by: Alex Chiang <achiang@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index ff963d4dab46..3a4478f1fc72 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -153,6 +153,7 @@ static int __init pnpacpi_add_device(struct acpi_device *device)
 	acpi_handle temp = NULL;
 	acpi_status status;
 	struct pnp_dev *dev;
+	struct acpi_hardware_id *id;
 
 	/*
 	 * If a PnPacpi device is not present , the device
@@ -193,15 +194,12 @@ static int __init pnpacpi_add_device(struct acpi_device *device)
 	if (dev->capabilities & PNP_CONFIGURABLE)
 		pnpacpi_parse_resource_option_data(dev);
 
-	if (device->flags.compatible_ids) {
-		struct acpica_device_id_list *cid_list = device->pnp.cid_list;
-		int i;
-
-		for (i = 0; i < cid_list->count; i++) {
-			if (!ispnpidacpi(cid_list->ids[i].string))
-				continue;
-			pnp_add_id(dev, cid_list->ids[i].string);
-		}
+	list_for_each_entry(id, &device->pnp.ids, list) {
+		if (!strcmp(id->id, acpi_device_hid(device)))
+			continue;
+		if (!ispnpidacpi(id->id))
+			continue;
+		pnp_add_id(dev, id->id);
 	}
 
 	/* clear out the damaged flags */

commit ea8d82fd316208bd0ffe6f64823d04bcb8c57158
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Sep 21 13:35:09 2009 -0600

    ACPI: use acpi_device_hid() when possible
    
    Use acpi_device_hid() rather than accessing acpi_device.pnp.hardware_id
    directly.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index c07fdb94d665..ff963d4dab46 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -234,7 +234,7 @@ static int __init acpi_pnp_match(struct device *dev, void *_pnp)
 	/* true means it matched */
 	return acpi->flags.hardware_id
 	    && !acpi_get_physical_device(acpi->handle)
-	    && compare_pnp_id(pnp->id, acpi->pnp.hardware_id);
+	    && compare_pnp_id(pnp->id, acpi_device_hid(acpi));
 }
 
 static int __init acpi_pnp_find_device(struct device *dev, acpi_handle * handle)

commit 15b8dd53f5ffaf8e2d9095c423f713423f576c0f
Author: Bob Moore <robert.moore@intel.com>
Date:   Mon Jun 29 13:39:29 2009 +0800

    ACPICA: Major update for acpi_get_object_info external interface
    
    Completed a major update for the acpi_get_object_info external interface.
    Changes include:
     - Support for variable, unlimited length HID, UID, and CID strings
     - Support Processor objects the same as Devices (HID,UID,CID,ADR,STA, etc.)
     - Call the _SxW power methods on behalf of a device object
     - Determine if a device is a PCI root bridge
     - Change the ACPI_BUFFER parameter to ACPI_DEVICE_INFO.
    These changes will require an update to all callers of this interface.
    See the ACPICA Programmer Reference for details.
    
    Also, update all invocations of acpi_get_object_info interface
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index 9496494f340e..c07fdb94d665 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -194,13 +194,13 @@ static int __init pnpacpi_add_device(struct acpi_device *device)
 		pnpacpi_parse_resource_option_data(dev);
 
 	if (device->flags.compatible_ids) {
-		struct acpi_compatible_id_list *cid_list = device->pnp.cid_list;
+		struct acpica_device_id_list *cid_list = device->pnp.cid_list;
 		int i;
 
 		for (i = 0; i < cid_list->count; i++) {
-			if (!ispnpidacpi(cid_list->id[i].value))
+			if (!ispnpidacpi(cid_list->ids[i].string))
 				continue;
-			pnp_add_id(dev, cid_list->id[i].value);
+			pnp_add_id(dev, cid_list->ids[i].string);
 		}
 	}
 

commit 19bde778c1fd2574cc020a618d7d576f260271ca
Author: Len Brown <len.brown@intel.com>
Date:   Fri May 8 00:22:29 2009 -0400

    ACPI: suspend: don't let device _PS3 failure prevent suspend
    
    6328a57401dc5f5cf9931738eb7268fcd8058c49
    "Enable PNPACPI _PSx Support, v3"
    
    added a call to acpi_bus_set_power(handle, ACPI_STATE_D3)
    to pnpacpi_disable_resource() before the existing call
    to evaluate _DIS on the device.
    
    This caused suspend to fail on the system in
    http://bugzilla.kernel.org/show_bug.cgi?id=13243
    because the sanity check to verify we entered _PS3
    failed on the serial port.
    
    As a work-around, that sanity check can be disabled
    system-wide with "acpi.power_nocheck=1"
    
    Or perhaps we should just shrug off the _PS3 failure
    and carry on with _DIS like we used to -- which is
    what this patch does.
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index 9a3a682c6981..9496494f340e 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -110,11 +110,9 @@ static int pnpacpi_disable_resources(struct pnp_dev *dev)
 
 	/* acpi_unregister_gsi(pnp_irq(dev, 0)); */
 	ret = 0;
-	if (acpi_bus_power_manageable(handle)) {
-		ret = acpi_bus_set_power(handle, ACPI_STATE_D3);
-		if (ret)
-			return ret;
-	}
+	if (acpi_bus_power_manageable(handle))
+		acpi_bus_set_power(handle, ACPI_STATE_D3);
+		/* continue even if acpi_bus_set_power() fails */
 	if (ACPI_FAILURE(acpi_evaluate_object(handle, "_DIS", NULL, NULL)))
 		ret = -ENODEV;
 	return ret;

commit 6328a57401dc5f5cf9931738eb7268fcd8058c49
Author: Witold Szczeponik <Witold.Szczeponik@gmx.net>
Date:   Mon Mar 30 19:31:06 2009 +0200

    Enable PNPACPI _PSx Support, v3
    
    (This is an update to the patch presented earlier in
    http://lkml.org/lkml/2008/12/8/284, with new error handling.)
    
    This patch sets the power of PnP ACPI devices to D0 when they
    are activated and to D3 when they are disabled.  The latter is
    in correspondence with the ACPI 3.0 specification, whereas the
    former is added in order to be able to power up a device after
    it has been previously disabled (or when booting up a system).
    (As a consequence, the patch makes the PnP ACPI code more ACPI
    compliant.)
    
    Section 6.2.2 of the ACPI Specification (at least versions 1.0b
    and 3.0a) states: "Prior to running this control method [_DIS],
    the OS[PM] will have already put the device in the D3 state."
    Unfortunately, there is no clear statement as to when to put
    a device in the D0 state. :-( Therefore, the patch executes the
    method calls as _PS3/_DIS and _SRS/_PS0. What is clear: "If the
    device is disabled, _SRS enables the device at the specified
    resources." (From the ACPI 3.0a Specification.)
    
    The patch fixes a problem with some IBM ThinkPads (at least the
    600E and the 600X) where the serial ports have a dedicated
    power source that needs to be brought up before the serial port
    can be used.  Without this patch, the serial port is enabled
    but has no power. (In the past, the tpctl utility had to be
    utilized to turn on the power, but support for this feature
    stopped with version 5.9 as it did not support the more recent
    kernel versions.)
    
    The error handlers that handle any errors that can occur during
    the power up/power down phases return the error codes to the
    caller directly.  Comments welcome! :-)
    
    No regressions were observed on hardware that does not require
    this patch.
    
    The patch is applied against 2.6.27.x.
    
    Signed-off-by: Witold Szczeponik <Witold.Szczeponik@gmx.net>
    Acked-by: Zhao Yakui <yakui.zhao@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index 2834846a185d..9a3a682c6981 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -83,7 +83,6 @@ static int pnpacpi_set_resources(struct pnp_dev *dev)
 	acpi_handle handle = dev->data;
 	struct acpi_buffer buffer;
 	int ret;
-	acpi_status status;
 
 	pnp_dbg(&dev->dev, "set resources\n");
 	ret = pnpacpi_build_resource_template(dev, &buffer);
@@ -94,21 +93,31 @@ static int pnpacpi_set_resources(struct pnp_dev *dev)
 		kfree(buffer.pointer);
 		return ret;
 	}
-	status = acpi_set_current_resources(handle, &buffer);
-	if (ACPI_FAILURE(status))
+	if (ACPI_FAILURE(acpi_set_current_resources(handle, &buffer)))
 		ret = -EINVAL;
+	else if (acpi_bus_power_manageable(handle))
+		ret = acpi_bus_set_power(handle, ACPI_STATE_D0);
 	kfree(buffer.pointer);
 	return ret;
 }
 
 static int pnpacpi_disable_resources(struct pnp_dev *dev)
 {
-	acpi_status status;
+	acpi_handle handle = dev->data;
+	int ret;
+
+	dev_dbg(&dev->dev, "disable resources\n");
 
 	/* acpi_unregister_gsi(pnp_irq(dev, 0)); */
-	status = acpi_evaluate_object((acpi_handle) dev->data,
-				      "_DIS", NULL, NULL);
-	return ACPI_FAILURE(status) ? -ENODEV : 0;
+	ret = 0;
+	if (acpi_bus_power_manageable(handle)) {
+		ret = acpi_bus_set_power(handle, ACPI_STATE_D3);
+		if (ret)
+			return ret;
+	}
+	if (ACPI_FAILURE(acpi_evaluate_object(handle, "_DIS", NULL, NULL)))
+		ret = -ENODEV;
+	return ret;
 }
 
 #ifdef CONFIG_ACPI_SLEEP

commit ea7e96e0f2277107d9ea14c3f16c86ba82b2e560
Author: Lin Ming <ming.m.lin@intel.com>
Date:   Tue Dec 16 16:28:17 2008 +0800

    ACPI: remove private acpica headers from driver files
    
    External driver files should not include any private acpica headers.
    
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index 383e47c392a4..2834846a185d 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -23,7 +23,6 @@
 #include <linux/pnp.h>
 #include <linux/mod_devicetable.h>
 #include <acpi/acpi_bus.h>
-#include <acpi/actypes.h>
 
 #include "../base.h"
 #include "pnpacpi.h"

commit 057316cc6a5b521b332a1d7ccc871cd60c904c74
Merge: 3e2dab9a1c2d 2515ddc6db8e
Author: Len Brown <len.brown@intel.com>
Date:   Wed Oct 22 23:57:26 2008 -0400

    Merge branch 'linus' into test
    
    Conflicts:
            MAINTAINERS
            arch/x86/kernel/acpi/boot.c
            arch/x86/kernel/acpi/sleep.c
            drivers/acpi/Kconfig
            drivers/pnp/Makefile
            drivers/pnp/quirks.c
    
    Signed-off-by: Len Brown <len.brown@intel.com>

commit 4dff4e7f6cbcd2722b02dbb394ba87c4e05f8841
Merge: 5f50ef453dcb ac88a8f3f7df
Author: Len Brown <len.brown@intel.com>
Date:   Wed Oct 22 23:28:43 2008 -0400

    Merge branch 'pnp-debug' into test

commit 39a0ad871000d2a016a4fa113a6e53d22aabf25d
Author: Zhao Yakui <yakui.zhao@intel.com>
Date:   Mon Aug 11 13:40:22 2008 +0800

    ACPI : Load device driver according to the status of acpi device
    
    According to ACPI spec when the status of some device is not present
    but functional, the device is valid and the children of this device
    should be enumerated. It means that the device should be added to
    linux acpi device tree. But the device driver for this device should not
    be loaded.
        The detailed info can be found in the section 6.3.7 of ACPI 3.0b spec.
        _STA may return bit 0 clear (not present) with bit 3 set (device is
    functional). This case is used to indicate a valid device for which no
    device driver should be loaded (for example, a bridge device.).
    Children of this device may be present and valid. OS should continue
    enumeration below a device whose _STA returns this bit combination
    
    http://bugzilla.kernel.org/show_bug.cgi?id=3358
    
    Signed-off-by: Zhao Yakui <yakui.zhao@intel.com>
    Signed-off-by: Li Shaohua <shaohua.li@intel.com>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index c1b9ea34977b..98b9df7776e9 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -148,9 +148,13 @@ static int __init pnpacpi_add_device(struct acpi_device *device)
 	acpi_status status;
 	struct pnp_dev *dev;
 
+	/*
+	 * If a PnPacpi device is not present , the device
+	 * driver should not be loaded.
+	 */
 	status = acpi_get_handle(device->handle, "_CRS", &temp);
 	if (ACPI_FAILURE(status) || !ispnpidacpi(acpi_device_hid(device)) ||
-	    is_exclusive_device(device))
+	    is_exclusive_device(device) || (!device->status.present))
 		return 0;
 
 	dev = pnp_alloc_dev(&pnpacpi_protocol, num, acpi_device_hid(device));

commit 2f53432c2aedbe79020e44525eb069d9138a01dd
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Aug 19 16:53:47 2008 -0600

    PNP: convert to using pnp_dbg()
    
    pnp_dbg() is equivalent to dev_dbg() except that we can turn it
    on at boot-time with the "pnp.debug" kernel parameter, so we don't
    have to build a new kernel image.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index 67c651bcaf71..b57d9d59dca5 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -75,7 +75,7 @@ static int __init ispnpidacpi(char *id)
 
 static int pnpacpi_get_resources(struct pnp_dev *dev)
 {
-	dev_dbg(&dev->dev, "get resources\n");
+	pnp_dbg(&dev->dev, "get resources\n");
 	return pnpacpi_parse_allocated_resource(dev);
 }
 
@@ -86,7 +86,7 @@ static int pnpacpi_set_resources(struct pnp_dev *dev)
 	int ret;
 	acpi_status status;
 
-	dev_dbg(&dev->dev, "set resources\n");
+	pnp_dbg(&dev->dev, "set resources\n");
 	ret = pnpacpi_build_resource_template(dev, &buffer);
 	if (ret)
 		return ret;

commit c865d2f6eb160c15b74245b4891c8e945d67d96c
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Aug 19 16:53:26 2008 -0600

    PNP: convert the last few pnp_info() uses to printk()
    
    There are only a few remaining uses of pnp_info(), so I just
    converted them to printk and removed the pnp_err(), pnp_info(),
    pnp_warn(), and pnp_dbg() wrappers.
    
    I also removed a couple debug messages that don't seem useful any
    more ("driver registered", "driver unregistered", "driver attached").
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index c1b9ea34977b..67c651bcaf71 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -255,14 +255,14 @@ int pnpacpi_disabled __initdata;
 static int __init pnpacpi_init(void)
 {
 	if (acpi_disabled || pnpacpi_disabled) {
-		pnp_info("PnP ACPI: disabled");
+		printk(KERN_INFO "pnp: PnP ACPI: disabled\n");
 		return 0;
 	}
-	pnp_info("PnP ACPI init");
+	printk(KERN_INFO "pnp: PnP ACPI init\n");
 	pnp_register_protocol(&pnpacpi_protocol);
 	register_acpi_bus_type(&acpi_pnp_bus);
 	acpi_get_devices(NULL, pnpacpi_add_device_handler, NULL, NULL);
-	pnp_info("PnP ACPI: found %d devices", num);
+	printk(KERN_INFO "pnp: PnP ACPI: found %d devices\n", num);
 	unregister_acpi_bus_type(&acpi_pnp_bus);
 	pnp_platform_devices = 1;
 	return 0;

commit ed458df4d2470adc02762a87a9ad665d0b1a2bd4
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Oct 10 08:00:17 2008 -0700

    PnP: move pnpacpi/pnpbios_init to after PCI init
    
    We already did that a long time ago for pnp_system_init, but
    pnpacpi_init and pnpbios_init remained as subsys_initcalls, and get
    linked into the kernel before the arch-specific routines that finalize
    the PCI resources (pci_subsys_init).
    
    This means that the PnP routines would either register their resources
    before the PCI layer could, or would be unable to check whether a PCI
    resource had already been registered.  Both are problematic.
    
    I wanted to do this before 2.6.27, but every time we change something
    like this, something breaks.  That said, _every_ single time we trust
    some firmware (like PnP tables) more than we trust the hardware itself
    (like PCI probing), the problems have been worse.
    
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index c1b9ea34977b..53561d72b4ee 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -268,7 +268,7 @@ static int __init pnpacpi_init(void)
 	return 0;
 }
 
-subsys_initcall(pnpacpi_init);
+fs_initcall(pnpacpi_init);
 
 static int __init pnpacpi_setup(char *str)
 {

commit 2fe2de5f6c283a7d2a82c1b99a19012079cee555
Author: David Brownell <dbrownell@users.sourceforge.net>
Date:   Thu Jun 5 01:15:40 2008 +0200

    ACPI PM: acpi_pm_device_sleep_state() cleanup
    
    Get rid of a superfluous acpi_pm_device_sleep_state() parameter.  The
    only legitimate value of that parameter must be derived from the first
    parameter, which is what all the callers already do.  (However, this
    does not address the fact that ACPI still doesn't set up those flags.)
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index 50902773beaf..c1b9ea34977b 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -117,9 +117,7 @@ static int pnpacpi_suspend(struct pnp_dev *dev, pm_message_t state)
 {
 	int power_state;
 
-	power_state = acpi_pm_device_sleep_state(&dev->dev,
-						device_may_wakeup(&dev->dev),
-						NULL);
+	power_state = acpi_pm_device_sleep_state(&dev->dev, NULL);
 	if (power_state < 0)
 		power_state = (state.event == PM_EVENT_ON) ?
 				ACPI_STATE_D0 : ACPI_STATE_D3;

commit 008238b54ac2350babf195084ecedbcf7851a202
Merge: 96916090f488 dfd2e1b4e6eb
Author: Len Brown <len.brown@intel.com>
Date:   Wed Apr 30 13:59:05 2008 -0400

    Merge branch 'pnp' into release

commit 9448b0d43e5509c6b7baca02510a92ef2de6e328
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Tue Apr 29 22:52:01 2008 +0200

    acpi: fix section mismatch warning in pnpacpi
    
    Fix following section mismatch warning:
    WARNING: vmlinux.o(.text+0x153d69): Section mismatch in reference from the function is_exclusive_device() to the variable .init.data:excluded_id_list
    
    is_exclusive_device is only used from __init context so document
    this with the __init annotation and get rid of the warning.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index c283a9a70d83..63e64ef39fb7 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -44,7 +44,7 @@ static struct acpi_device_id excluded_id_list[] __initdata = {
 	{"", 0},
 };
 
-static inline int is_exclusive_device(struct acpi_device *dev)
+static inline int __init is_exclusive_device(struct acpi_device *dev)
 {
 	return (!acpi_match_device_ids(dev, excluded_id_list));
 }

commit d152cf5d0c3325979e71ee53b425fdd51a1a285a
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Apr 28 16:34:39 2008 -0600

    PNPACPI: move _CRS/_PRS warnings closer to the action
    
    Move warnings about _CRS and _PRS problems to the place where we
    actually make the ACPI calls.  Then we don't have to pass around
    acpi_status values any more than necessary.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Acked-By: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index 7e4512a60f58..0950b711f19e 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -75,11 +75,8 @@ static int __init ispnpidacpi(char *id)
 
 static int pnpacpi_get_resources(struct pnp_dev *dev)
 {
-	acpi_status status;
-
 	dev_dbg(&dev->dev, "get resources\n");
-	status = pnpacpi_parse_allocated_resource(dev);
-	return ACPI_FAILURE(status) ? -ENODEV : 0;
+	return pnpacpi_parse_allocated_resource(dev);
 }
 
 static int pnpacpi_set_resources(struct pnp_dev *dev)
@@ -182,22 +179,11 @@ static int __init pnpacpi_add_device(struct acpi_device *device)
 	else
 		strncpy(dev->name, acpi_device_bid(device), sizeof(dev->name));
 
-	if (dev->active) {
-		/* parse allocated resource */
-		status = pnpacpi_parse_allocated_resource(dev);
-		if (ACPI_FAILURE(status) && (status != AE_NOT_FOUND)) {
-			pnp_err("PnPACPI: METHOD_NAME__CRS failure for %s",
-				acpi_device_hid(device));
-		}
-	}
+	if (dev->active)
+		pnpacpi_parse_allocated_resource(dev);
 
-	if (dev->capabilities & PNP_CONFIGURABLE) {
-		status = pnpacpi_parse_resource_option_data(dev);
-		if (ACPI_FAILURE(status) && (status != AE_NOT_FOUND)) {
-			pnp_err("PnPACPI: METHOD_NAME__PRS failure for %s",
-				acpi_device_hid(device));
-		}
-	}
+	if (dev->capabilities & PNP_CONFIGURABLE)
+		pnpacpi_parse_resource_option_data(dev);
 
 	if (device->flags.compatible_ids) {
 		struct acpi_compatible_id_list *cid_list = device->pnp.cid_list;

commit f44900020926b2cb06b87f0f52643d6285514fc3
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Apr 28 16:34:09 2008 -0600

    PNP: add pnp_init_resources(struct pnp_dev *) interface
    
    Add pnp_init_resources(struct pnp_dev *) to replace
    pnp_init_resource_table(), which takes a pointer to the
    pnp_resource_table itself.  Passing only the pnp_dev * reduces
    the possibility for error in the caller and removes the
    pnp_resource_table implementation detail from the interface.
    
    Even though pnp_init_resource_table() is exported, I did not
    export pnp_init_resources() because it is used only by the PNP
    core.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Acked-By: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index 1ac894d2df5a..7e4512a60f58 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -212,7 +212,7 @@ static int __init pnpacpi_add_device(struct acpi_device *device)
 
 	/* clear out the damaged flags */
 	if (!dev->active)
-		pnp_init_resource_table(&dev->res);
+		pnp_init_resources(dev);
 	pnp_add_device(dev);
 	num++;
 

commit 72dcc883d8e5b59105e75ee5265442e458740575
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Apr 28 16:34:07 2008 -0600

    PNP: add debug output to encoders
    
    Add debug output to encoders (enabled by CONFIG_PNP_DEBUG).  This
    uses dev_printk, so I had to add pnp_dev arguments at the same time.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Acked-By: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index 3fd2416d6795..1ac894d2df5a 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -77,6 +77,7 @@ static int pnpacpi_get_resources(struct pnp_dev *dev)
 {
 	acpi_status status;
 
+	dev_dbg(&dev->dev, "get resources\n");
 	status = pnpacpi_parse_allocated_resource(dev);
 	return ACPI_FAILURE(status) ? -ENODEV : 0;
 }
@@ -88,6 +89,7 @@ static int pnpacpi_set_resources(struct pnp_dev *dev)
 	int ret;
 	acpi_status status;
 
+	dev_dbg(&dev->dev, "set resources\n");
 	ret = pnpacpi_build_resource_template(dev, &buffer);
 	if (ret)
 		return ret;

commit 4ab55d8d4f7b910c4c60e0f8ff70d0dfdd484f02
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Apr 28 16:34:06 2008 -0600

    PNP: remove more pnp_resource_table arguments
    
    Stop passing around struct pnp_resource_table pointers.  In most cases,
    the caller doesn't need to know how the resources are stored inside
    the struct pnp_dev.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Acked-By: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index 590fbcb0ee89..3fd2416d6795 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -77,8 +77,7 @@ static int pnpacpi_get_resources(struct pnp_dev *dev)
 {
 	acpi_status status;
 
-	status = pnpacpi_parse_allocated_resource((acpi_handle) dev->data,
-						  &dev->res);
+	status = pnpacpi_parse_allocated_resource(dev);
 	return ACPI_FAILURE(status) ? -ENODEV : 0;
 }
 
@@ -92,7 +91,7 @@ static int pnpacpi_set_resources(struct pnp_dev *dev)
 	ret = pnpacpi_build_resource_template(dev, &buffer);
 	if (ret)
 		return ret;
-	ret = pnpacpi_encode_resources(&dev->res, &buffer);
+	ret = pnpacpi_encode_resources(dev, &buffer);
 	if (ret) {
 		kfree(buffer.pointer);
 		return ret;
@@ -183,8 +182,7 @@ static int __init pnpacpi_add_device(struct acpi_device *device)
 
 	if (dev->active) {
 		/* parse allocated resource */
-		status = pnpacpi_parse_allocated_resource(device->handle,
-							  &dev->res);
+		status = pnpacpi_parse_allocated_resource(dev);
 		if (ACPI_FAILURE(status) && (status != AE_NOT_FOUND)) {
 			pnp_err("PnPACPI: METHOD_NAME__CRS failure for %s",
 				acpi_device_hid(device));
@@ -192,8 +190,7 @@ static int __init pnpacpi_add_device(struct acpi_device *device)
 	}
 
 	if (dev->capabilities & PNP_CONFIGURABLE) {
-		status = pnpacpi_parse_resource_option_data(device->handle,
-							    dev);
+		status = pnpacpi_parse_resource_option_data(dev);
 		if (ACPI_FAILURE(status) && (status != AE_NOT_FOUND)) {
 			pnp_err("PnPACPI: METHOD_NAME__PRS failure for %s",
 				acpi_device_hid(device));

commit 59284cb4099411bc6f4915a5a4cb76414440c447
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Apr 28 16:34:05 2008 -0600

    PNP: remove pnp_resource_table from internal get/set interfaces
    
    When we call protocol->get() and protocol->set() methods, we currently
    supply pointers to both the pnp_dev and the pnp_resource_table even
    though the pnp_resource_table should always be the one associated with
    the pnp_dev.
    
    This removes the pnp_resource_table arguments to make it clear that
    these methods only operate on the specified pnp_dev.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Acked-By: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index 27546873880c..590fbcb0ee89 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -73,8 +73,7 @@ static int __init ispnpidacpi(char *id)
 	return 1;
 }
 
-static int pnpacpi_get_resources(struct pnp_dev *dev,
-				 struct pnp_resource_table *res)
+static int pnpacpi_get_resources(struct pnp_dev *dev)
 {
 	acpi_status status;
 
@@ -83,8 +82,7 @@ static int pnpacpi_get_resources(struct pnp_dev *dev,
 	return ACPI_FAILURE(status) ? -ENODEV : 0;
 }
 
-static int pnpacpi_set_resources(struct pnp_dev *dev,
-				 struct pnp_resource_table *res)
+static int pnpacpi_set_resources(struct pnp_dev *dev)
 {
 	acpi_handle handle = dev->data;
 	struct acpi_buffer buffer;
@@ -94,7 +92,7 @@ static int pnpacpi_set_resources(struct pnp_dev *dev,
 	ret = pnpacpi_build_resource_template(dev, &buffer);
 	if (ret)
 		return ret;
-	ret = pnpacpi_encode_resources(res, &buffer);
+	ret = pnpacpi_encode_resources(&dev->res, &buffer);
 	if (ret) {
 		kfree(buffer.pointer);
 		return ret;

commit cdef6254e17e98f1071ce1bfc8f2a87997c855d0
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Apr 28 16:34:03 2008 -0600

    PNPACPI: pass pnp_dev instead of acpi_handle
    
    Pass the pnp_dev pointer when possible instead of the acpi_handle.
    This allows better error messages and reduces the chance of error
    in the caller.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Acked-By: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index fd3fca6dddd3..27546873880c 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -88,10 +88,10 @@ static int pnpacpi_set_resources(struct pnp_dev *dev,
 {
 	acpi_handle handle = dev->data;
 	struct acpi_buffer buffer;
-	int ret = 0;
+	int ret;
 	acpi_status status;
 
-	ret = pnpacpi_build_resource_template(handle, &buffer);
+	ret = pnpacpi_build_resource_template(dev, &buffer);
 	if (ret)
 		return ret;
 	ret = pnpacpi_encode_resources(res, &buffer);

commit bda1e4e5a3d976046378cd495a63e1ee0847deec
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Apr 28 16:33:54 2008 -0600

    PNP: add pnp_alloc_dev()
    
    Add pnp_alloc_dev() to allocate a struct pnp_dev and fill in the
    protocol, instance number, and initial PNP ID.  Now it is always
    valid to use dev_printk() on any pnp_dev pointer.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Acked-By: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index 86aea1ebfee7..fd3fca6dddd3 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -152,7 +152,6 @@ static int __init pnpacpi_add_device(struct acpi_device *device)
 {
 	acpi_handle temp = NULL;
 	acpi_status status;
-	struct pnp_id *dev_id;
 	struct pnp_dev *dev;
 
 	status = acpi_get_handle(device->handle, "_CRS", &temp);
@@ -160,11 +159,10 @@ static int __init pnpacpi_add_device(struct acpi_device *device)
 	    is_exclusive_device(device))
 		return 0;
 
-	dev = kzalloc(sizeof(struct pnp_dev), GFP_KERNEL);
-	if (!dev) {
-		pnp_err("Out of memory");
+	dev = pnp_alloc_dev(&pnpacpi_protocol, num, acpi_device_hid(device));
+	if (!dev)
 		return -ENOMEM;
-	}
+
 	dev->data = device->handle;
 	/* .enabled means the device can decode the resources */
 	dev->active = device->status.enabled;
@@ -180,19 +178,11 @@ static int __init pnpacpi_add_device(struct acpi_device *device)
 	if (ACPI_SUCCESS(status))
 		dev->capabilities |= PNP_DISABLE;
 
-	dev->protocol = &pnpacpi_protocol;
-
 	if (strlen(acpi_device_name(device)))
 		strncpy(dev->name, acpi_device_name(device), sizeof(dev->name));
 	else
 		strncpy(dev->name, acpi_device_bid(device), sizeof(dev->name));
 
-	dev->number = num;
-
-	dev_id = pnp_add_id(dev, acpi_device_hid(device));
-	if (!dev_id)
-		goto err;
-
 	if (dev->active) {
 		/* parse allocated resource */
 		status = pnpacpi_parse_allocated_resource(device->handle,
@@ -230,9 +220,6 @@ static int __init pnpacpi_add_device(struct acpi_device *device)
 	num++;
 
 	return AE_OK;
-err:
-	kfree(dev);
-	return -EINVAL;
 }
 
 static acpi_status __init pnpacpi_add_device_handler(acpi_handle handle,

commit 772defc6292bae8b6db298476d1dabd22a99492b
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Apr 28 16:33:52 2008 -0600

    PNP: change pnp_add_id() to allocate its own pnp_id structures
    
    This moves some of the pnp_id knowledge out of the backends and into
    the PNP core.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Acked-By: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index 4807d76f8a04..86aea1ebfee7 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -73,18 +73,6 @@ static int __init ispnpidacpi(char *id)
 	return 1;
 }
 
-static void __init pnpidacpi_to_pnpid(char *id, char *str)
-{
-	str[0] = id[0];
-	str[1] = id[1];
-	str[2] = id[2];
-	str[3] = tolower(id[3]);
-	str[4] = tolower(id[4]);
-	str[5] = tolower(id[5]);
-	str[6] = tolower(id[6]);
-	str[7] = '\0';
-}
-
 static int pnpacpi_get_resources(struct pnp_dev *dev,
 				 struct pnp_resource_table *res)
 {
@@ -201,12 +189,9 @@ static int __init pnpacpi_add_device(struct acpi_device *device)
 
 	dev->number = num;
 
-	/* set the initial values for the PnP device */
-	dev_id = kzalloc(sizeof(struct pnp_id), GFP_KERNEL);
+	dev_id = pnp_add_id(dev, acpi_device_hid(device));
 	if (!dev_id)
 		goto err;
-	pnpidacpi_to_pnpid(acpi_device_hid(device), dev_id->id);
-	pnp_add_id(dev_id, dev);
 
 	if (dev->active) {
 		/* parse allocated resource */
@@ -227,7 +212,6 @@ static int __init pnpacpi_add_device(struct acpi_device *device)
 		}
 	}
 
-	/* parse compatible ids */
 	if (device->flags.compatible_ids) {
 		struct acpi_compatible_id_list *cid_list = device->pnp.cid_list;
 		int i;
@@ -235,12 +219,7 @@ static int __init pnpacpi_add_device(struct acpi_device *device)
 		for (i = 0; i < cid_list->count; i++) {
 			if (!ispnpidacpi(cid_list->id[i].value))
 				continue;
-			dev_id = kzalloc(sizeof(struct pnp_id), GFP_KERNEL);
-			if (!dev_id)
-				continue;
-
-			pnpidacpi_to_pnpid(cid_list->id[i].value, dev_id->id);
-			pnp_add_id(dev_id, dev);
+			pnp_add_id(dev, cid_list->id[i].value);
 		}
 	}
 

commit 1692b27bf37826f85f9c12f8468848885643532a
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Apr 28 16:33:51 2008 -0600

    PNP: make pnp_add_id() internal to PNP core
    
    pnp_add_id() doesn't need to be exposed outside the PNP core, so
    move the declaration to an internal header file.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Acked-By: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index 53f91068d0b0..4807d76f8a04 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -25,6 +25,7 @@
 #include <acpi/acpi_bus.h>
 #include <acpi/actypes.h>
 
+#include "../base.h"
 #include "pnpacpi.h"
 
 static int num = 0;

commit 4a490498643ea37520c315769b293085b6018ddd
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Apr 28 16:33:50 2008 -0600

    PNPACPI: continue after _CRS and _PRS errors
    
    Keep going and register the device even if we have trouble parsing
    _CRS or _PRS.  A parsing problem might mean we ignore some resources
    the device is using, or we might not be able to change its resources.
    But we should still take note of anything we *could* parse correctly.
    
    Also remove reference to dev_id because I plan to remove it soon.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index c283a9a70d83..53f91068d0b0 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -213,8 +213,7 @@ static int __init pnpacpi_add_device(struct acpi_device *device)
 							  &dev->res);
 		if (ACPI_FAILURE(status) && (status != AE_NOT_FOUND)) {
 			pnp_err("PnPACPI: METHOD_NAME__CRS failure for %s",
-				dev_id->id);
-			goto err1;
+				acpi_device_hid(device));
 		}
 	}
 
@@ -223,8 +222,7 @@ static int __init pnpacpi_add_device(struct acpi_device *device)
 							    dev);
 		if (ACPI_FAILURE(status) && (status != AE_NOT_FOUND)) {
 			pnp_err("PnPACPI: METHOD_NAME__PRS failure for %s",
-				dev_id->id);
-			goto err1;
+				acpi_device_hid(device));
 		}
 	}
 
@@ -252,8 +250,6 @@ static int __init pnpacpi_add_device(struct acpi_device *device)
 	num++;
 
 	return AE_OK;
-err1:
-	kfree(dev_id);
 err:
 	kfree(dev);
 	return -EINVAL;

commit 6bf69b5ebf22f8f5b4551bad688979fe29049126
Author: Roel Kluin <12o3l@tiscali.nl>
Date:   Mon Feb 11 16:05:35 2008 +0100

    pnpacpi: __initdata is not an identifier
    
    sparse complains at drivers/pnp/pnpacpi/core.c:39 with the error:
    Trying to use reserved word '__attribute__' as identifier
    Expected ) in function declarator, got ".init.data"
    
    and at drivers/pnp/pnpacpi/core.c:49:38 with the error:
    undefined identifier 'excluded_id_list'
    
    With the patch below these sparse complaints do not occur
    
    Signed-off-by: Roel Kluin <12o3l@tiscali.nl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index 662b4c279cfc..c283a9a70d83 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -36,7 +36,7 @@ static int num = 0;
  * have irqs (PIC, Timer) because we call acpi_register_gsi.
  * Finally, only devices that have a CRS method need to be in this list.
  */
-static struct __initdata acpi_device_id excluded_id_list[] = {
+static struct acpi_device_id excluded_id_list[] __initdata = {
 	{"PNP0C09", 0},		/* EC */
 	{"PNP0C0F", 0},		/* Link device */
 	{"PNP0000", 0},		/* PIC */

commit 856608ee5e1ea37b8976ce01ddbd19a45da88921
Author: Shaohua Li <shaohua.li@intel.com>
Date:   Sat Jan 12 19:37:49 2008 -0500

    pnp: Failed to activate device 00:0a - Samsung P35 XVM 1600 III
    
    PNP_WRITE requires protocol supports .set. If ACPI doesn't support _SRS, .set ismeanless, so PNP_WRITE.
    
    Signed-off-by: Shaohua Li <shaohua.li@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index dada89906314..662b4c279cfc 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -183,7 +183,7 @@ static int __init pnpacpi_add_device(struct acpi_device *device)
 	if (ACPI_SUCCESS(status))
 		dev->capabilities |= PNP_CONFIGURABLE;
 	dev->capabilities |= PNP_READ;
-	if (device->flags.dynamic_status)
+	if (device->flags.dynamic_status && (dev->capabilities & PNP_CONFIGURABLE))
 		dev->capabilities |= PNP_WRITE;
 	if (device->flags.removable)
 		dev->capabilities |= PNP_REMOVABLE;

commit 348366b963e4e1462c8354827a9cb910aa865bf2
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Oct 16 23:31:12 2007 -0700

    PNP: add debug message for adding new device
    
    Add PNP debug message when adding a device, remove similar PNPACPI message
    with less information.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Cc: Adam Belay <ambx1@neo.rr.com>
    Cc: Len Brown <lenb@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index e6a2a9fc7f0a..dada89906314 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -171,7 +171,6 @@ static int __init pnpacpi_add_device(struct acpi_device *device)
 	    is_exclusive_device(device))
 		return 0;
 
-	pnp_dbg("ACPI device : hid %s", acpi_device_hid(device));
 	dev = kzalloc(sizeof(struct pnp_dev), GFP_KERNEL);
 	if (!dev) {
 		pnp_err("Out of memory");

commit 36e02b62084efa72f1f04c95e13295a456f394c2
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Oct 16 23:31:06 2007 -0700

    PNP: make pnpacpi_suspend handle errors
    
    pnpacpi_suspend() doesn't check the result returned by
    acpi_pm_device_sleep_state() before passing it to acpi_bus_set_power(),
    which may not be desirable.   Make it select the target power state of the
    device using its second argument if acpi_pm_device_sleep_state() fails.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Looks-ok-to: Pavel Machek <pavel@ucw.cz>
    Cc: Adam Belay <ambx1@neo.rr.com>
    Cc: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index a5a372222d69..e6a2a9fc7f0a 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -130,11 +130,16 @@ static int pnpacpi_disable_resources(struct pnp_dev *dev)
 #ifdef CONFIG_ACPI_SLEEP
 static int pnpacpi_suspend(struct pnp_dev *dev, pm_message_t state)
 {
-	return acpi_bus_set_power((acpi_handle) dev->data,
-				  acpi_pm_device_sleep_state(&dev->dev,
-							     device_may_wakeup
-							     (&dev->dev),
-							     NULL));
+	int power_state;
+
+	power_state = acpi_pm_device_sleep_state(&dev->dev,
+						device_may_wakeup(&dev->dev),
+						NULL);
+	if (power_state < 0)
+		power_state = (state.event == PM_EVENT_ON) ?
+				ACPI_STATE_D0 : ACPI_STATE_D3;
+
+	return acpi_bus_set_power((acpi_handle) dev->data, power_state);
 }
 
 static int pnpacpi_resume(struct pnp_dev *dev)

commit 1e0aa9ad721349781b728ec4226876247e3fd431
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Wed Aug 15 10:32:08 2007 -0600

    PNP: fix up after Lindent
    
    More manual fixups after Lindent.  No functional change.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Acked-by: Adam Belay <abelay@novell.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index 616fc72190bf..a5a372222d69 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -248,9 +248,9 @@ static int __init pnpacpi_add_device(struct acpi_device *device)
 	num++;
 
 	return AE_OK;
-      err1:
+err1:
 	kfree(dev_id);
-      err:
+err:
 	kfree(dev);
 	return -EINVAL;
 }

commit 673d5b43daa00b42759cecc6b0760b8bf6be80d2
Author: Len Brown <len.brown@intel.com>
Date:   Sat Jul 28 03:33:16 2007 -0400

    ACPI: restore CONFIG_ACPI_SLEEP
    
    Restore the 2.6.22 CONFIG_ACPI_SLEEP build option, but now shadowing the
    new CONFIG_PM_SLEEP option.
    
    Signed-off-by: Len Brown <len.brown@intel.com>
    [ Modified to work with the PM config setup changes. ]
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index 6a2a3c2f4d5e..616fc72190bf 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -127,6 +127,7 @@ static int pnpacpi_disable_resources(struct pnp_dev *dev)
 	return ACPI_FAILURE(status) ? -ENODEV : 0;
 }
 
+#ifdef CONFIG_ACPI_SLEEP
 static int pnpacpi_suspend(struct pnp_dev *dev, pm_message_t state)
 {
 	return acpi_bus_set_power((acpi_handle) dev->data,
@@ -140,14 +141,17 @@ static int pnpacpi_resume(struct pnp_dev *dev)
 {
 	return acpi_bus_set_power((acpi_handle) dev->data, ACPI_STATE_D0);
 }
+#endif
 
 static struct pnp_protocol pnpacpi_protocol = {
 	.name	 = "Plug and Play ACPI",
 	.get	 = pnpacpi_get_resources,
 	.set	 = pnpacpi_set_resources,
 	.disable = pnpacpi_disable_resources,
+#ifdef CONFIG_ACPI_SLEEP
 	.suspend = pnpacpi_suspend,
 	.resume = pnpacpi_resume,
+#endif
 };
 
 static int __init pnpacpi_add_device(struct acpi_device *device)

commit 07d4e9af109221ab731c5aaf832e89776c64b013
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Thu Jul 26 10:41:21 2007 -0700

    PNP: fix up after Lindent
    
    These are manual fixups after running Lindent.  No functional change.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Adam Belay <ambx1@neo.rr.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index 423c8e7e322d..6a2a3c2f4d5e 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -34,9 +34,9 @@ static int num = 0;
  * used by the kernel (PCI root, ...), as it is harmless and there were
  * already present in pnpbios. But there is an exception for devices that
  * have irqs (PIC, Timer) because we call acpi_register_gsi.
- * Finaly only devices that have a CRS method need to be in this list.
+ * Finally, only devices that have a CRS method need to be in this list.
  */
-static __initdata struct acpi_device_id excluded_id_list[] = {
+static struct __initdata acpi_device_id excluded_id_list[] = {
 	{"PNP0C09", 0},		/* EC */
 	{"PNP0C0F", 0},		/* Link device */
 	{"PNP0000", 0},		/* PIC */
@@ -88,6 +88,7 @@ static int pnpacpi_get_resources(struct pnp_dev *dev,
 				 struct pnp_resource_table *res)
 {
 	acpi_status status;
+
 	status = pnpacpi_parse_allocated_resource((acpi_handle) dev->data,
 						  &dev->res);
 	return ACPI_FAILURE(status) ? -ENODEV : 0;
@@ -141,9 +142,9 @@ static int pnpacpi_resume(struct pnp_dev *dev)
 }
 
 static struct pnp_protocol pnpacpi_protocol = {
-	.name = "Plug and Play ACPI",
-	.get = pnpacpi_get_resources,
-	.set = pnpacpi_set_resources,
+	.name	 = "Plug and Play ACPI",
+	.get	 = pnpacpi_get_resources,
+	.set	 = pnpacpi_set_resources,
 	.disable = pnpacpi_disable_resources,
 	.suspend = pnpacpi_suspend,
 	.resume = pnpacpi_resume,
@@ -168,7 +169,7 @@ static int __init pnpacpi_add_device(struct acpi_device *device)
 		return -ENOMEM;
 	}
 	dev->data = device->handle;
-	/* .enabled means if the device can decode the resources */
+	/* .enabled means the device can decode the resources */
 	dev->active = device->status.enabled;
 	status = acpi_get_handle(device->handle, "_SRS", &temp);
 	if (ACPI_SUCCESS(status))
@@ -200,8 +201,8 @@ static int __init pnpacpi_add_device(struct acpi_device *device)
 
 	if (dev->active) {
 		/* parse allocated resource */
-		status =
-		    pnpacpi_parse_allocated_resource(device->handle, &dev->res);
+		status = pnpacpi_parse_allocated_resource(device->handle,
+							  &dev->res);
 		if (ACPI_FAILURE(status) && (status != AE_NOT_FOUND)) {
 			pnp_err("PnPACPI: METHOD_NAME__CRS failure for %s",
 				dev_id->id);
@@ -294,7 +295,7 @@ static int __init acpi_pnp_find_device(struct device *dev, acpi_handle * handle)
  * pnpdev->dev.archdata.acpi_handle point to its ACPI sibling.
  */
 static struct acpi_bus_type __initdata acpi_pnp_bus = {
-	.bus = &pnp_bus_type,
+	.bus	     = &pnp_bus_type,
 	.find_device = acpi_pnp_find_device,
 };
 
@@ -327,7 +328,3 @@ static int __init pnpacpi_setup(char *str)
 }
 
 __setup("pnpacpi=", pnpacpi_setup);
-
-#if 0
-EXPORT_SYMBOL(pnpacpi_protocol);
-#endif

commit 9dd78466c956ac4b4f38e12032dc4249ccf57ad1
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Thu Jul 26 10:41:20 2007 -0700

    PNP: Lindent all source files
    
    Run Lindent on all PNP source files.
    
    Produced by:
    
        $ quilt new pnp-lindent
        $ find drivers/pnp -name \*.[ch] | xargs quilt add
        $ quilt add include/linux/{pnp.h,pnpbios.h}
        $ scripts/Lindent drivers/pnp/*.c drivers/pnp/*/*.c include/linux/pnp*.h
        $ quilt refresh --sort
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Adam Belay <ambx1@neo.rr.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index fcd32ac575c3..423c8e7e322d 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -36,11 +36,11 @@ static int num = 0;
  * have irqs (PIC, Timer) because we call acpi_register_gsi.
  * Finaly only devices that have a CRS method need to be in this list.
  */
-static __initdata struct acpi_device_id excluded_id_list[] ={
-	{"PNP0C09", 0}, /* EC */
-	{"PNP0C0F", 0}, /* Link device */
-	{"PNP0000", 0}, /* PIC */
-	{"PNP0100", 0}, /* Timer */
+static __initdata struct acpi_device_id excluded_id_list[] = {
+	{"PNP0C09", 0},		/* EC */
+	{"PNP0C0F", 0},		/* Link device */
+	{"PNP0000", 0},		/* PIC */
+	{"PNP0100", 0},		/* Timer */
 	{"", 0},
 };
 
@@ -84,15 +84,17 @@ static void __init pnpidacpi_to_pnpid(char *id, char *str)
 	str[7] = '\0';
 }
 
-static int pnpacpi_get_resources(struct pnp_dev * dev, struct pnp_resource_table * res)
+static int pnpacpi_get_resources(struct pnp_dev *dev,
+				 struct pnp_resource_table *res)
 {
 	acpi_status status;
-	status = pnpacpi_parse_allocated_resource((acpi_handle)dev->data,
-		&dev->res);
+	status = pnpacpi_parse_allocated_resource((acpi_handle) dev->data,
+						  &dev->res);
 	return ACPI_FAILURE(status) ? -ENODEV : 0;
 }
 
-static int pnpacpi_set_resources(struct pnp_dev * dev, struct pnp_resource_table * res)
+static int pnpacpi_set_resources(struct pnp_dev *dev,
+				 struct pnp_resource_table *res)
 {
 	acpi_handle handle = dev->data;
 	struct acpi_buffer buffer;
@@ -119,27 +121,29 @@ static int pnpacpi_disable_resources(struct pnp_dev *dev)
 	acpi_status status;
 
 	/* acpi_unregister_gsi(pnp_irq(dev, 0)); */
-	status = acpi_evaluate_object((acpi_handle)dev->data,
-		"_DIS", NULL, NULL);
+	status = acpi_evaluate_object((acpi_handle) dev->data,
+				      "_DIS", NULL, NULL);
 	return ACPI_FAILURE(status) ? -ENODEV : 0;
 }
 
 static int pnpacpi_suspend(struct pnp_dev *dev, pm_message_t state)
 {
-	return acpi_bus_set_power((acpi_handle)dev->data,
-		acpi_pm_device_sleep_state(&dev->dev,
-		device_may_wakeup(&dev->dev), NULL));
+	return acpi_bus_set_power((acpi_handle) dev->data,
+				  acpi_pm_device_sleep_state(&dev->dev,
+							     device_may_wakeup
+							     (&dev->dev),
+							     NULL));
 }
 
 static int pnpacpi_resume(struct pnp_dev *dev)
 {
-	return acpi_bus_set_power((acpi_handle)dev->data, ACPI_STATE_D0);
+	return acpi_bus_set_power((acpi_handle) dev->data, ACPI_STATE_D0);
 }
 
 static struct pnp_protocol pnpacpi_protocol = {
-	.name	= "Plug and Play ACPI",
-	.get	= pnpacpi_get_resources,
-	.set	= pnpacpi_set_resources,
+	.name = "Plug and Play ACPI",
+	.get = pnpacpi_get_resources,
+	.set = pnpacpi_set_resources,
 	.disable = pnpacpi_disable_resources,
 	.suspend = pnpacpi_suspend,
 	.resume = pnpacpi_resume,
@@ -154,11 +158,11 @@ static int __init pnpacpi_add_device(struct acpi_device *device)
 
 	status = acpi_get_handle(device->handle, "_CRS", &temp);
 	if (ACPI_FAILURE(status) || !ispnpidacpi(acpi_device_hid(device)) ||
-		is_exclusive_device(device))
+	    is_exclusive_device(device))
 		return 0;
 
 	pnp_dbg("ACPI device : hid %s", acpi_device_hid(device));
-	dev =  kzalloc(sizeof(struct pnp_dev), GFP_KERNEL);
+	dev = kzalloc(sizeof(struct pnp_dev), GFP_KERNEL);
 	if (!dev) {
 		pnp_err("Out of memory");
 		return -ENOMEM;
@@ -194,20 +198,23 @@ static int __init pnpacpi_add_device(struct acpi_device *device)
 	pnpidacpi_to_pnpid(acpi_device_hid(device), dev_id->id);
 	pnp_add_id(dev_id, dev);
 
-	if(dev->active) {
+	if (dev->active) {
 		/* parse allocated resource */
-		status = pnpacpi_parse_allocated_resource(device->handle, &dev->res);
+		status =
+		    pnpacpi_parse_allocated_resource(device->handle, &dev->res);
 		if (ACPI_FAILURE(status) && (status != AE_NOT_FOUND)) {
-			pnp_err("PnPACPI: METHOD_NAME__CRS failure for %s", dev_id->id);
+			pnp_err("PnPACPI: METHOD_NAME__CRS failure for %s",
+				dev_id->id);
 			goto err1;
 		}
 	}
 
-	if(dev->capabilities & PNP_CONFIGURABLE) {
+	if (dev->capabilities & PNP_CONFIGURABLE) {
 		status = pnpacpi_parse_resource_option_data(device->handle,
-			dev);
+							    dev);
 		if (ACPI_FAILURE(status) && (status != AE_NOT_FOUND)) {
-			pnp_err("PnPACPI: METHOD_NAME__PRS failure for %s", dev_id->id);
+			pnp_err("PnPACPI: METHOD_NAME__PRS failure for %s",
+				dev_id->id);
 			goto err1;
 		}
 	}
@@ -233,18 +240,19 @@ static int __init pnpacpi_add_device(struct acpi_device *device)
 	if (!dev->active)
 		pnp_init_resource_table(&dev->res);
 	pnp_add_device(dev);
-	num ++;
+	num++;
 
 	return AE_OK;
-err1:
+      err1:
 	kfree(dev_id);
-err:
+      err:
 	kfree(dev);
 	return -EINVAL;
 }
 
 static acpi_status __init pnpacpi_add_device_handler(acpi_handle handle,
-	u32 lvl, void *context, void **rv)
+						     u32 lvl, void *context,
+						     void **rv)
 {
 	struct acpi_device *device;
 
@@ -257,23 +265,22 @@ static acpi_status __init pnpacpi_add_device_handler(acpi_handle handle,
 
 static int __init acpi_pnp_match(struct device *dev, void *_pnp)
 {
-	struct acpi_device	*acpi = to_acpi_device(dev);
-	struct pnp_dev		*pnp = _pnp;
+	struct acpi_device *acpi = to_acpi_device(dev);
+	struct pnp_dev *pnp = _pnp;
 
 	/* true means it matched */
 	return acpi->flags.hardware_id
-		&& !acpi_get_physical_device(acpi->handle)
-		&& compare_pnp_id(pnp->id, acpi->pnp.hardware_id);
+	    && !acpi_get_physical_device(acpi->handle)
+	    && compare_pnp_id(pnp->id, acpi->pnp.hardware_id);
 }
 
-static int __init acpi_pnp_find_device(struct device *dev, acpi_handle *handle)
+static int __init acpi_pnp_find_device(struct device *dev, acpi_handle * handle)
 {
-	struct device		*adev;
-	struct acpi_device	*acpi;
+	struct device *adev;
+	struct acpi_device *acpi;
 
 	adev = bus_find_device(&acpi_bus_type, NULL,
-			to_pnp_dev(dev),
-			acpi_pnp_match);
+			       to_pnp_dev(dev), acpi_pnp_match);
 	if (!adev)
 		return -ENODEV;
 
@@ -307,6 +314,7 @@ static int __init pnpacpi_init(void)
 	pnp_platform_devices = 1;
 	return 0;
 }
+
 subsys_initcall(pnpacpi_init);
 
 static int __init pnpacpi_setup(char *str)
@@ -317,6 +325,7 @@ static int __init pnpacpi_setup(char *str)
 		pnpacpi_disabled = 1;
 	return 1;
 }
+
 __setup("pnpacpi=", pnpacpi_setup);
 
 #if 0

commit 323ef30af3a0da47cc761b04b262d98d0fe79126
Merge: cb3e0c107beb 1ba90e3a87c4
Author: Len Brown <len.brown@intel.com>
Date:   Wed Jul 25 01:36:53 2007 -0400

    Pull auto-load-modules into release branch

commit 29b71a1ca74491fab9fed09e9d835d840d042690
Author: Thomas Renninger <trenn@suse.de>
Date:   Mon Jul 23 14:43:51 2007 +0200

    ACPI: autoload modules - Create ACPI alias interface
    
    Modify modpost (file2alias.c) to add acpi*:XYZ0001: alias in modules.alias
    like:
    grep acpi /lib/modules/2.6.22-rc4-default/modules.alias
    alias acpi*:SNY5001:* sony_laptop
    alias acpi*:SNY6001:* sony_laptop
    for e.g. the sony_laptop module.
    This module matches against all ACPI devices with a HID or CID of SNY5001
    or SNY6001
    
    Export an uevent and modalias sysfs file containing the string:
    [MODALIAS=]acpi:PNP0C0C:
    additional CIDs are concatenated at the end.
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index a00548799e98..0bc889144e6f 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -21,7 +21,10 @@
 
 #include <linux/acpi.h>
 #include <linux/pnp.h>
+#include <linux/mod_devicetable.h>
 #include <acpi/acpi_bus.h>
+#include <acpi/actypes.h>
+
 #include "pnpacpi.h"
 
 static int num = 0;
@@ -33,15 +36,17 @@ static int num = 0;
  * have irqs (PIC, Timer) because we call acpi_register_gsi.
  * Finaly only devices that have a CRS method need to be in this list.
  */
-static char __initdata excluded_id_list[] =
-	"PNP0C09," /* EC */
-	"PNP0C0F," /* Link device */
-	"PNP0000," /* PIC */
-	"PNP0100," /* Timer */
-	;
+static __initdata struct acpi_device_id excluded_id_list[] ={
+	{"PNP0C09", 0}, /* EC */
+	{"PNP0C0F", 0}, /* Link device */
+	{"PNP0000", 0}, /* PIC */
+	{"PNP0100", 0}, /* Timer */
+	{"", 0},
+};
+
 static inline int is_exclusive_device(struct acpi_device *dev)
 {
-	return (!acpi_match_ids(dev, excluded_id_list));
+	return (!acpi_match_device_ids(dev, excluded_id_list));
 }
 
 /*

commit fc30e68e88baf463683bde43347756889ba2ffae
Author: Shaohua Li <shaohua.li@intel.com>
Date:   Fri Jul 20 10:03:20 2007 +0800

    ACPI, PNP: hook ACPI D-state to PNP suspend/resume
    
    applied after Rafel's 'PM: Update global suspend and hibernation operations framework' patch set
    
    Signed-off-by: Shaohua Li <shaohua.li@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index a00548799e98..c37a558ecd96 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -119,11 +119,25 @@ static int pnpacpi_disable_resources(struct pnp_dev *dev)
 	return ACPI_FAILURE(status) ? -ENODEV : 0;
 }
 
+static int pnpacpi_suspend(struct pnp_dev *dev, pm_message_t state)
+{
+	return acpi_bus_set_power((acpi_handle)dev->data,
+		acpi_pm_device_sleep_state(&dev->dev,
+		device_may_wakeup(&dev->dev), NULL));
+}
+
+static int pnpacpi_resume(struct pnp_dev *dev)
+{
+	return acpi_bus_set_power((acpi_handle)dev->data, ACPI_STATE_D0);
+}
+
 static struct pnp_protocol pnpacpi_protocol = {
 	.name	= "Plug and Play ACPI",
 	.get	= pnpacpi_get_resources,
 	.set	= pnpacpi_set_resources,
 	.disable = pnpacpi_disable_resources,
+	.suspend = pnpacpi_suspend,
+	.resume = pnpacpi_resume,
 };
 
 static int __init pnpacpi_add_device(struct acpi_device *device)

commit 8f81dd149806bc53c68c92f34d61f88427079039
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue May 8 00:35:54 2007 -0700

    PNP: notice whether we have PNP devices (PNPBIOS or PNPACPI)
    
    This series converts i386 and x86_64 legacy serial ports to be platform
    devices and prevents probing for them if we have PNP.
    
    This prevents double discovery, where a device was found both by the legacy
    probe and by 8250_pnp.
    
    This also prevents the serial driver from claiming IRDA devices (unless they
    have a UART PNP ID).  The serial legacy probe sometimes assumed the wrong IRQ,
    so the user had to use "setserial" to fix it.
    
    Removing the need for setserial to make IRDA devices work seems good, but it
    does break some things.  In particular, you may need to keep setserial from
    poking legacy UART stuff back in by doing something like "dpkg-reconfigure
    setserial" with the "kernel" option.  Otherwise, the setserial-discovered
    "UART" will claim resources and prevent the IRDA driver from loading.
    
    This patch:
    
    If we can discover devices using PNP, we can skip some legacy probes.  This
    flag ("pnp_platform_devices") indicates that PNPBIOS or PNPACPI is enabled and
    should tell us about builtin devices.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Cc: Keith Owens <kaos@ocs.com.au>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Adam Belay <ambx1@neo.rr.com>
    Cc: Matthieu CASTET <castet.matthieu@free.fr>
    Cc: Jean Tourrilhes <jt@hpl.hp.com>
    Cc: Matthew Garrett <mjg59@srcf.ucam.org>
    Cc: Ville Syrjala <syrjala@sci.fi>
    Cc: Russell King <rmk+serial@arm.linux.org.uk>
    Cc: Samuel Ortiz <samuel@sortiz.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index 7eb8275185b6..a00548799e98 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -285,6 +285,7 @@ static int __init pnpacpi_init(void)
 	acpi_get_devices(NULL, pnpacpi_add_device_handler, NULL, NULL);
 	pnp_info("PnP ACPI: found %d devices", num);
 	unregister_acpi_bus_type(&acpi_pnp_bus);
+	pnp_platform_devices = 1;
 	return 0;
 }
 subsys_initcall(pnpacpi_init);

commit 55955aad7c09e4d93029d0cf2d360b41891f2fe4
Author: David Brownell <david-b@pacbell.net>
Date:   Tue May 8 00:28:35 2007 -0700

    PNPACPI sets pnpdev->dev.archdata
    
    Teach PNPACPI how to hook up its devices to their ACPI nodes, so that
    pnpdev->dev.archdata points to the parallel acpi device node.  Previously
    this only worked for PCI, leaving a notable hole.
    
    Export "acpi_bus_type" so this can work.
    
    Remove some extraneous whitespace.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Cc: Adam Belay <ambx1@neo.rr.com>
    Cc: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Greg KH <greg@kroah.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index 62eda5d59024..7eb8275185b6 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -3,7 +3,7 @@
  *
  * Copyright (c) 2004 Matthieu Castet <castet.matthieu@free.fr>
  * Copyright (c) 2004 Li Shaohua <shaohua.li@intel.com>
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the
  * Free Software Foundation; either version 2, or (at your option) any
@@ -18,7 +18,7 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
- 
+
 #include <linux/acpi.h>
 #include <linux/pnp.h>
 #include <acpi/acpi_bus.h>
@@ -82,7 +82,7 @@ static void __init pnpidacpi_to_pnpid(char *id, char *str)
 static int pnpacpi_get_resources(struct pnp_dev * dev, struct pnp_resource_table * res)
 {
 	acpi_status status;
-	status = pnpacpi_parse_allocated_resource((acpi_handle)dev->data, 
+	status = pnpacpi_parse_allocated_resource((acpi_handle)dev->data,
 		&dev->res);
 	return ACPI_FAILURE(status) ? -ENODEV : 0;
 }
@@ -112,9 +112,9 @@ static int pnpacpi_set_resources(struct pnp_dev * dev, struct pnp_resource_table
 static int pnpacpi_disable_resources(struct pnp_dev *dev)
 {
 	acpi_status status;
-	
+
 	/* acpi_unregister_gsi(pnp_irq(dev, 0)); */
-	status = acpi_evaluate_object((acpi_handle)dev->data, 
+	status = acpi_evaluate_object((acpi_handle)dev->data,
 		"_DIS", NULL, NULL);
 	return ACPI_FAILURE(status) ? -ENODEV : 0;
 }
@@ -167,7 +167,7 @@ static int __init pnpacpi_add_device(struct acpi_device *device)
 		strncpy(dev->name, acpi_device_bid(device), sizeof(dev->name));
 
 	dev->number = num;
-	
+
 	/* set the initial values for the PnP device */
 	dev_id = kzalloc(sizeof(struct pnp_id), GFP_KERNEL);
 	if (!dev_id)
@@ -185,14 +185,14 @@ static int __init pnpacpi_add_device(struct acpi_device *device)
 	}
 
 	if(dev->capabilities & PNP_CONFIGURABLE) {
-		status = pnpacpi_parse_resource_option_data(device->handle, 
+		status = pnpacpi_parse_resource_option_data(device->handle,
 			dev);
 		if (ACPI_FAILURE(status) && (status != AE_NOT_FOUND)) {
 			pnp_err("PnPACPI: METHOD_NAME__PRS failure for %s", dev_id->id);
 			goto err1;
 		}
 	}
-	
+
 	/* parse compatible ids */
 	if (device->flags.compatible_ids) {
 		struct acpi_compatible_id_list *cid_list = device->pnp.cid_list;
@@ -236,6 +236,42 @@ static acpi_status __init pnpacpi_add_device_handler(acpi_handle handle,
 	return AE_OK;
 }
 
+static int __init acpi_pnp_match(struct device *dev, void *_pnp)
+{
+	struct acpi_device	*acpi = to_acpi_device(dev);
+	struct pnp_dev		*pnp = _pnp;
+
+	/* true means it matched */
+	return acpi->flags.hardware_id
+		&& !acpi_get_physical_device(acpi->handle)
+		&& compare_pnp_id(pnp->id, acpi->pnp.hardware_id);
+}
+
+static int __init acpi_pnp_find_device(struct device *dev, acpi_handle *handle)
+{
+	struct device		*adev;
+	struct acpi_device	*acpi;
+
+	adev = bus_find_device(&acpi_bus_type, NULL,
+			to_pnp_dev(dev),
+			acpi_pnp_match);
+	if (!adev)
+		return -ENODEV;
+
+	acpi = to_acpi_device(adev);
+	*handle = acpi->handle;
+	put_device(adev);
+	return 0;
+}
+
+/* complete initialization of a PNPACPI device includes having
+ * pnpdev->dev.archdata.acpi_handle point to its ACPI sibling.
+ */
+static struct acpi_bus_type __initdata acpi_pnp_bus = {
+	.bus = &pnp_bus_type,
+	.find_device = acpi_pnp_find_device,
+};
+
 int pnpacpi_disabled __initdata;
 static int __init pnpacpi_init(void)
 {
@@ -245,8 +281,10 @@ static int __init pnpacpi_init(void)
 	}
 	pnp_info("PnP ACPI init");
 	pnp_register_protocol(&pnpacpi_protocol);
+	register_acpi_bus_type(&acpi_pnp_bus);
 	acpi_get_devices(NULL, pnpacpi_add_device_handler, NULL, NULL);
 	pnp_info("PnP ACPI: found %d devices", num);
+	unregister_acpi_bus_type(&acpi_pnp_bus);
 	return 0;
 }
 subsys_initcall(pnpacpi_init);

commit cd86128088554d64fea1679191509f00e6353c5b
Author: Robert P. J. Day <rpjday@mindspring.com>
Date:   Wed Dec 13 00:34:52 2006 -0800

    [PATCH] Fix numerous kcalloc() calls, convert to kzalloc()
    
    All kcalloc() calls of the form "kcalloc(1,...)" are converted to the
    equivalent kzalloc() calls, and a few kcalloc() calls with the incorrect
    ordering of the first two arguments are fixed.
    
    Signed-off-by: Robert P. J. Day <rpjday@mindspring.com>
    Cc: Jeff Garzik <jeff@garzik.org>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Cc: Dominik Brodowski <linux@dominikbrodowski.net>
    Cc: Adam Belay <ambx1@neo.rr.com>
    Cc: James Bottomley <James.Bottomley@steeleye.com>
    Cc: Greg KH <greg@kroah.com>
    Cc: Mark Fasheh <mark.fasheh@oracle.com>
    Cc: Trond Myklebust <trond.myklebust@fys.uio.no>
    Cc: Neil Brown <neilb@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index 6cf34a63c790..62eda5d59024 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -139,7 +139,7 @@ static int __init pnpacpi_add_device(struct acpi_device *device)
 		return 0;
 
 	pnp_dbg("ACPI device : hid %s", acpi_device_hid(device));
-	dev =  kcalloc(1, sizeof(struct pnp_dev), GFP_KERNEL);
+	dev =  kzalloc(sizeof(struct pnp_dev), GFP_KERNEL);
 	if (!dev) {
 		pnp_err("Out of memory");
 		return -ENOMEM;
@@ -169,7 +169,7 @@ static int __init pnpacpi_add_device(struct acpi_device *device)
 	dev->number = num;
 	
 	/* set the initial values for the PnP device */
-	dev_id = kcalloc(1, sizeof(struct pnp_id), GFP_KERNEL);
+	dev_id = kzalloc(sizeof(struct pnp_id), GFP_KERNEL);
 	if (!dev_id)
 		goto err;
 	pnpidacpi_to_pnpid(acpi_device_hid(device), dev_id->id);
@@ -201,7 +201,7 @@ static int __init pnpacpi_add_device(struct acpi_device *device)
 		for (i = 0; i < cid_list->count; i++) {
 			if (!ispnpidacpi(cid_list->id[i].value))
 				continue;
-			dev_id = kcalloc(1, sizeof(struct pnp_id), GFP_KERNEL);
+			dev_id = kzalloc(sizeof(struct pnp_id), GFP_KERNEL);
 			if (!dev_id)
 				continue;
 

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jörn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jörn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index f104577f73e0..6cf34a63c790 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -19,7 +19,6 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
  
-#include <linux/config.h>
 #include <linux/acpi.h>
 #include <linux/pnp.h>
 #include <acpi/acpi_bus.h>

commit c4bb6f5ad968540d7f9619565bacd18d7419b85f
Author: matthieu castet <castet.matthieu@free.fr>
Date:   Fri Jan 6 01:31:00 2006 -0500

    [PNPACPI] clean excluded_id_list[]
    
    Clean the blacklist.  Battery, Button, Fan have no _CRS
    and can be removed.  PCI root is in pnpbios and is harmless.
    
    Cc: Adam Belay <ambx1@neo.rr.com>
    Cc: "Li, Shaohua" <shaohua.li@intel.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index e77d1feb759e..f104577f73e0 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -27,12 +27,15 @@
 
 static int num = 0;
 
+/* We need only to blacklist devices that have already an acpi driver that
+ * can't use pnp layer. We don't need to blacklist device that are directly
+ * used by the kernel (PCI root, ...), as it is harmless and there were
+ * already present in pnpbios. But there is an exception for devices that
+ * have irqs (PIC, Timer) because we call acpi_register_gsi.
+ * Finaly only devices that have a CRS method need to be in this list.
+ */
 static char __initdata excluded_id_list[] =
-	"PNP0C0A," /* Battery */
-	"PNP0C0C,PNP0C0E,PNP0C0D," /* Button */
 	"PNP0C09," /* EC */
-	"PNP0C0B," /* Fan */
-	"PNP0A03," /* PCI root */
 	"PNP0C0F," /* Link device */
 	"PNP0000," /* PIC */
 	"PNP0100," /* Timer */

commit 07b0120d53a3e7cbc88458a64a4d668fc416100f
Author: matthieu castet <castet.matthieu@free.fr>
Date:   Fri Jan 6 01:31:00 2006 -0500

    [PNPACPI] Ignore devices that have no resources
    
    Ignore devices that don't have a _CRS method.
    They are useless for the PNP layer as they don't provide any resources.
    
    Cc: Adam Belay <ambx1@neo.rr.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index 816479ad217b..e77d1feb759e 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -131,7 +131,8 @@ static int __init pnpacpi_add_device(struct acpi_device *device)
 	struct pnp_id *dev_id;
 	struct pnp_dev *dev;
 
-	if (!ispnpidacpi(acpi_device_hid(device)) ||
+	status = acpi_get_handle(device->handle, "_CRS", &temp);
+	if (ACPI_FAILURE(status) || !ispnpidacpi(acpi_device_hid(device)) ||
 		is_exclusive_device(device))
 		return 0;
 

commit b449f63c8ce4a517cb91f237cc3d68d083ec2dd3
Author: Adrian Bunk <bunk@stusta.de>
Date:   Mon Nov 7 01:01:48 2005 -0800

    [PATCH] drivers/pnp/: cleanups
    
    This patch contains the following possible cleanups:
    - make needlessly global code static
    - #if 0 the following unused global function:
      - core.c: pnp_remove_device
    - #if 0 the following unneeded EXPORT_SYMBOL's:
      - card.c: pnp_add_card
      - card.c: pnp_remove_card
      - card.c: pnp_add_card_device
      - card.c: pnp_remove_card_device
      - card.c: pnp_add_card_id
      - core.c: pnp_register_protocol
      - core.c: pnp_unregister_protocol
      - core.c: pnp_add_device
      - core.c: pnp_remove_device
      - pnpacpi/core.c: pnpacpi_protocol
      - driver.c: pnp_add_id
      - isapnp/core.c: isapnp_read_byte
      - manager.c: pnp_auto_config_dev
      - resource.c: pnp_register_dependent_option
      - resource.c: pnp_register_independent_option
      - resource.c: pnp_register_irq_resource
      - resource.c: pnp_register_dma_resource
      - resource.c: pnp_register_port_resource
      - resource.c: pnp_register_mem_resource
    
    Note that this patch #if 0's exactly one functions and removes no
    functions.  Most it does is the #if 0 of EXPORT_SYMBOL's, so if any modular
    code will use any of them, re-adding will be trivial.
    
    Modular ISAPnP might be interesting in some cases, but this is more legacy
    code.  If someone would work on it to sort all the issues out (starting
    with the point that most users of __ISAPNP__ will have to be fixed)
    re-enabling the required EXPORT_SYMBOL's won't be hard for him.
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Cc: Adam Belay <ambx1@neo.rr.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index 1a8915e74160..816479ad217b 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -117,7 +117,7 @@ static int pnpacpi_disable_resources(struct pnp_dev *dev)
 	return ACPI_FAILURE(status) ? -ENODEV : 0;
 }
 
-struct pnp_protocol pnpacpi_protocol = {
+static struct pnp_protocol pnpacpi_protocol = {
 	.name	= "Plug and Play ACPI",
 	.get	= pnpacpi_get_resources,
 	.set	= pnpacpi_set_resources,
@@ -234,7 +234,7 @@ static acpi_status __init pnpacpi_add_device_handler(acpi_handle handle,
 }
 
 int pnpacpi_disabled __initdata;
-int __init pnpacpi_init(void)
+static int __init pnpacpi_init(void)
 {
 	if (acpi_disabled || pnpacpi_disabled) {
 		pnp_info("PnP ACPI: disabled");
@@ -258,4 +258,6 @@ static int __init pnpacpi_setup(char *str)
 }
 __setup("pnpacpi=", pnpacpi_setup);
 
+#if 0
 EXPORT_SYMBOL(pnpacpi_protocol);
+#endif

commit e139aa595c5d3bd01699530cbe017dec75fdb07f
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Sep 6 15:17:05 2005 -0700

    [PATCH] PNP: make pnp_dbg conditional directly on CONFIG_PNP_DEBUG
    
    Seems pointless to require .c files to test CONFIG_PNP_DEBUG and
    conditionally define DEBUG before including <linux/pnp.h>.  Just test
    CONFIG_PNP_DEBUG directly in pnp.h.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Cc: Adam Belay <ambx1@neo.rr.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index d3d292ea5876..1a8915e74160 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -19,6 +19,7 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
  
+#include <linux/config.h>
 #include <linux/acpi.h>
 #include <linux/pnp.h>
 #include <acpi/acpi_bus.h>

commit a2822e7f00cdccbff8e507b5ebbddce1aa95eb5d
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Sep 6 15:16:51 2005 -0700

    [PATCH] pnp: consolidate kmalloc wrappers
    
    ISAPNP, PNPBIOS, and PNPACPI all had their own kmalloc wrappers that
    reimplemented kcalloc().  Remove the wrappers and just use kcalloc()
    directly.
    
    Note that this also removes the PNPBIOS error message when the kmalloc
    fails.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index 8655dd2e5b83..d3d292ea5876 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -41,14 +41,6 @@ static inline int is_exclusive_device(struct acpi_device *dev)
 	return (!acpi_match_ids(dev, excluded_id_list));
 }
 
-void *pnpacpi_kmalloc(size_t size, int f)
-{
-	void *p = kmalloc(size, f);
-	if (p)
-		memset(p, 0, size);
-	return p;
-}
-
 /*
  * Compatible Device IDs
  */
@@ -143,7 +135,7 @@ static int __init pnpacpi_add_device(struct acpi_device *device)
 		return 0;
 
 	pnp_dbg("ACPI device : hid %s", acpi_device_hid(device));
-	dev =  pnpacpi_kmalloc(sizeof(struct pnp_dev), GFP_KERNEL);
+	dev =  kcalloc(1, sizeof(struct pnp_dev), GFP_KERNEL);
 	if (!dev) {
 		pnp_err("Out of memory");
 		return -ENOMEM;
@@ -173,7 +165,7 @@ static int __init pnpacpi_add_device(struct acpi_device *device)
 	dev->number = num;
 	
 	/* set the initial values for the PnP device */
-	dev_id = pnpacpi_kmalloc(sizeof(struct pnp_id), GFP_KERNEL);
+	dev_id = kcalloc(1, sizeof(struct pnp_id), GFP_KERNEL);
 	if (!dev_id)
 		goto err;
 	pnpidacpi_to_pnpid(acpi_device_hid(device), dev_id->id);
@@ -205,8 +197,7 @@ static int __init pnpacpi_add_device(struct acpi_device *device)
 		for (i = 0; i < cid_list->count; i++) {
 			if (!ispnpidacpi(cid_list->id[i].value))
 				continue;
-			dev_id = pnpacpi_kmalloc(sizeof(struct pnp_id), 
-				GFP_KERNEL);
+			dev_id = kcalloc(1, sizeof(struct pnp_id), GFP_KERNEL);
 			if (!dev_id)
 				continue;
 

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
new file mode 100644
index 000000000000..8655dd2e5b83
--- /dev/null
+++ b/drivers/pnp/pnpacpi/core.c
@@ -0,0 +1,269 @@
+/*
+ * pnpacpi -- PnP ACPI driver
+ *
+ * Copyright (c) 2004 Matthieu Castet <castet.matthieu@free.fr>
+ * Copyright (c) 2004 Li Shaohua <shaohua.li@intel.com>
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+ 
+#include <linux/acpi.h>
+#include <linux/pnp.h>
+#include <acpi/acpi_bus.h>
+#include "pnpacpi.h"
+
+static int num = 0;
+
+static char __initdata excluded_id_list[] =
+	"PNP0C0A," /* Battery */
+	"PNP0C0C,PNP0C0E,PNP0C0D," /* Button */
+	"PNP0C09," /* EC */
+	"PNP0C0B," /* Fan */
+	"PNP0A03," /* PCI root */
+	"PNP0C0F," /* Link device */
+	"PNP0000," /* PIC */
+	"PNP0100," /* Timer */
+	;
+static inline int is_exclusive_device(struct acpi_device *dev)
+{
+	return (!acpi_match_ids(dev, excluded_id_list));
+}
+
+void *pnpacpi_kmalloc(size_t size, int f)
+{
+	void *p = kmalloc(size, f);
+	if (p)
+		memset(p, 0, size);
+	return p;
+}
+
+/*
+ * Compatible Device IDs
+ */
+#define TEST_HEX(c) \
+	if (!(('0' <= (c) && (c) <= '9') || ('A' <= (c) && (c) <= 'F'))) \
+		return 0
+#define TEST_ALPHA(c) \
+	if (!('@' <= (c) || (c) <= 'Z')) \
+		return 0
+static int __init ispnpidacpi(char *id)
+{
+	TEST_ALPHA(id[0]);
+	TEST_ALPHA(id[1]);
+	TEST_ALPHA(id[2]);
+	TEST_HEX(id[3]);
+	TEST_HEX(id[4]);
+	TEST_HEX(id[5]);
+	TEST_HEX(id[6]);
+	if (id[7] != '\0')
+		return 0;
+	return 1;
+}
+
+static void __init pnpidacpi_to_pnpid(char *id, char *str)
+{
+	str[0] = id[0];
+	str[1] = id[1];
+	str[2] = id[2];
+	str[3] = tolower(id[3]);
+	str[4] = tolower(id[4]);
+	str[5] = tolower(id[5]);
+	str[6] = tolower(id[6]);
+	str[7] = '\0';
+}
+
+static int pnpacpi_get_resources(struct pnp_dev * dev, struct pnp_resource_table * res)
+{
+	acpi_status status;
+	status = pnpacpi_parse_allocated_resource((acpi_handle)dev->data, 
+		&dev->res);
+	return ACPI_FAILURE(status) ? -ENODEV : 0;
+}
+
+static int pnpacpi_set_resources(struct pnp_dev * dev, struct pnp_resource_table * res)
+{
+	acpi_handle handle = dev->data;
+	struct acpi_buffer buffer;
+	int ret = 0;
+	acpi_status status;
+
+	ret = pnpacpi_build_resource_template(handle, &buffer);
+	if (ret)
+		return ret;
+	ret = pnpacpi_encode_resources(res, &buffer);
+	if (ret) {
+		kfree(buffer.pointer);
+		return ret;
+	}
+	status = acpi_set_current_resources(handle, &buffer);
+	if (ACPI_FAILURE(status))
+		ret = -EINVAL;
+	kfree(buffer.pointer);
+	return ret;
+}
+
+static int pnpacpi_disable_resources(struct pnp_dev *dev)
+{
+	acpi_status status;
+	
+	/* acpi_unregister_gsi(pnp_irq(dev, 0)); */
+	status = acpi_evaluate_object((acpi_handle)dev->data, 
+		"_DIS", NULL, NULL);
+	return ACPI_FAILURE(status) ? -ENODEV : 0;
+}
+
+struct pnp_protocol pnpacpi_protocol = {
+	.name	= "Plug and Play ACPI",
+	.get	= pnpacpi_get_resources,
+	.set	= pnpacpi_set_resources,
+	.disable = pnpacpi_disable_resources,
+};
+
+static int __init pnpacpi_add_device(struct acpi_device *device)
+{
+	acpi_handle temp = NULL;
+	acpi_status status;
+	struct pnp_id *dev_id;
+	struct pnp_dev *dev;
+
+	if (!ispnpidacpi(acpi_device_hid(device)) ||
+		is_exclusive_device(device))
+		return 0;
+
+	pnp_dbg("ACPI device : hid %s", acpi_device_hid(device));
+	dev =  pnpacpi_kmalloc(sizeof(struct pnp_dev), GFP_KERNEL);
+	if (!dev) {
+		pnp_err("Out of memory");
+		return -ENOMEM;
+	}
+	dev->data = device->handle;
+	/* .enabled means if the device can decode the resources */
+	dev->active = device->status.enabled;
+	status = acpi_get_handle(device->handle, "_SRS", &temp);
+	if (ACPI_SUCCESS(status))
+		dev->capabilities |= PNP_CONFIGURABLE;
+	dev->capabilities |= PNP_READ;
+	if (device->flags.dynamic_status)
+		dev->capabilities |= PNP_WRITE;
+	if (device->flags.removable)
+		dev->capabilities |= PNP_REMOVABLE;
+	status = acpi_get_handle(device->handle, "_DIS", &temp);
+	if (ACPI_SUCCESS(status))
+		dev->capabilities |= PNP_DISABLE;
+
+	dev->protocol = &pnpacpi_protocol;
+
+	if (strlen(acpi_device_name(device)))
+		strncpy(dev->name, acpi_device_name(device), sizeof(dev->name));
+	else
+		strncpy(dev->name, acpi_device_bid(device), sizeof(dev->name));
+
+	dev->number = num;
+	
+	/* set the initial values for the PnP device */
+	dev_id = pnpacpi_kmalloc(sizeof(struct pnp_id), GFP_KERNEL);
+	if (!dev_id)
+		goto err;
+	pnpidacpi_to_pnpid(acpi_device_hid(device), dev_id->id);
+	pnp_add_id(dev_id, dev);
+
+	if(dev->active) {
+		/* parse allocated resource */
+		status = pnpacpi_parse_allocated_resource(device->handle, &dev->res);
+		if (ACPI_FAILURE(status) && (status != AE_NOT_FOUND)) {
+			pnp_err("PnPACPI: METHOD_NAME__CRS failure for %s", dev_id->id);
+			goto err1;
+		}
+	}
+
+	if(dev->capabilities & PNP_CONFIGURABLE) {
+		status = pnpacpi_parse_resource_option_data(device->handle, 
+			dev);
+		if (ACPI_FAILURE(status) && (status != AE_NOT_FOUND)) {
+			pnp_err("PnPACPI: METHOD_NAME__PRS failure for %s", dev_id->id);
+			goto err1;
+		}
+	}
+	
+	/* parse compatible ids */
+	if (device->flags.compatible_ids) {
+		struct acpi_compatible_id_list *cid_list = device->pnp.cid_list;
+		int i;
+
+		for (i = 0; i < cid_list->count; i++) {
+			if (!ispnpidacpi(cid_list->id[i].value))
+				continue;
+			dev_id = pnpacpi_kmalloc(sizeof(struct pnp_id), 
+				GFP_KERNEL);
+			if (!dev_id)
+				continue;
+
+			pnpidacpi_to_pnpid(cid_list->id[i].value, dev_id->id);
+			pnp_add_id(dev_id, dev);
+		}
+	}
+
+	/* clear out the damaged flags */
+	if (!dev->active)
+		pnp_init_resource_table(&dev->res);
+	pnp_add_device(dev);
+	num ++;
+
+	return AE_OK;
+err1:
+	kfree(dev_id);
+err:
+	kfree(dev);
+	return -EINVAL;
+}
+
+static acpi_status __init pnpacpi_add_device_handler(acpi_handle handle,
+	u32 lvl, void *context, void **rv)
+{
+	struct acpi_device *device;
+
+	if (!acpi_bus_get_device(handle, &device))
+		pnpacpi_add_device(device);
+	else
+		return AE_CTRL_DEPTH;
+	return AE_OK;
+}
+
+int pnpacpi_disabled __initdata;
+int __init pnpacpi_init(void)
+{
+	if (acpi_disabled || pnpacpi_disabled) {
+		pnp_info("PnP ACPI: disabled");
+		return 0;
+	}
+	pnp_info("PnP ACPI init");
+	pnp_register_protocol(&pnpacpi_protocol);
+	acpi_get_devices(NULL, pnpacpi_add_device_handler, NULL, NULL);
+	pnp_info("PnP ACPI: found %d devices", num);
+	return 0;
+}
+subsys_initcall(pnpacpi_init);
+
+static int __init pnpacpi_setup(char *str)
+{
+	if (str == NULL)
+		return 1;
+	if (!strncmp(str, "off", 3))
+		pnpacpi_disabled = 1;
+	return 1;
+}
+__setup("pnpacpi=", pnpacpi_setup);
+
+EXPORT_SYMBOL(pnpacpi_protocol);
