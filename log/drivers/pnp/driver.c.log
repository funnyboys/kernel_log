commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pnp/driver.c b/drivers/pnp/driver.c
index 63452f20e3e9..93a30a8f88d1 100644
--- a/drivers/pnp/driver.c
+++ b/drivers/pnp/driver.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * driver.c - device id matching, driver model, etc.
  *

commit e0f03e87fc6f27a8af9896f430f2945b3b1664c0
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Wed Dec 16 07:33:22 2015 +0100

    PNP: respect PNP_DRIVER_RES_DO_NOT_CHANGE when detaching
    
    I have a device (Nuvoton 6779D Super-IO IR RC with nuvoton-cir driver)
    which works after initial boot but not any longer if I unload and
    re-load the driver module.
    
    Digging into the issue I found that unloading the driver calls
    pnp_disable_dev although the driver has flag PNP_DRIVER_RES_DO_NOT_CHANGE
    set. IMHO this is not right.
    
    Let's have a look at the call chain when probing a device:
    pnp_device_probe
    1. attaches the device
    2. if it's not active and PNP_DRIVER_RES_DO_NOT_CHANGE is not set
       it gets activated
    3. probes driver
    
    I think pnp_device_remove should do it in reverse order and also
    respect PNP_DRIVER_RES_DO_NOT_CHANGE. Therefore:
    1. call drivers remove callback
    2. if device is active and PNP_DRIVER_RES_DO_NOT_CHANGE is not set
       disable it
    3. detach device
    
    The change works for me and sounds logical to me.
    However I don't know the pnp driver in detail so I might be wrong.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pnp/driver.c b/drivers/pnp/driver.c
index 153a493b5413..63452f20e3e9 100644
--- a/drivers/pnp/driver.c
+++ b/drivers/pnp/driver.c
@@ -74,7 +74,6 @@ void pnp_device_detach(struct pnp_dev *pnp_dev)
 	if (pnp_dev->status == PNP_ATTACHED)
 		pnp_dev->status = PNP_READY;
 	mutex_unlock(&pnp_lock);
-	pnp_disable_dev(pnp_dev);
 }
 
 static int pnp_device_probe(struct device *dev)
@@ -131,6 +130,11 @@ static int pnp_device_remove(struct device *dev)
 			drv->remove(pnp_dev);
 		pnp_dev->driver = NULL;
 	}
+
+	if (pnp_dev->active &&
+	    (!drv || !(drv->flags & PNP_DRIVER_RES_DO_NOT_CHANGE)))
+		pnp_disable_dev(pnp_dev);
+
 	pnp_device_detach(pnp_dev);
 	return 0;
 }

commit 38f6b38dbb0896511c509fbb6ceabbedbee8e87d
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Mar 18 22:39:55 2015 +0100

    PNP: Convert pnp_lock into a mutex
    
    pnp_lock is a spinlock, but it is only acquired from process context,
    so it may be a mutex just fine.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pnp/driver.c b/drivers/pnp/driver.c
index 4e57d3370368..153a493b5413 100644
--- a/drivers/pnp/driver.c
+++ b/drivers/pnp/driver.c
@@ -58,22 +58,22 @@ static const struct pnp_device_id *match_device(struct pnp_driver *drv,
 
 int pnp_device_attach(struct pnp_dev *pnp_dev)
 {
-	spin_lock(&pnp_lock);
+	mutex_lock(&pnp_lock);
 	if (pnp_dev->status != PNP_READY) {
-		spin_unlock(&pnp_lock);
+		mutex_unlock(&pnp_lock);
 		return -EBUSY;
 	}
 	pnp_dev->status = PNP_ATTACHED;
-	spin_unlock(&pnp_lock);
+	mutex_unlock(&pnp_lock);
 	return 0;
 }
 
 void pnp_device_detach(struct pnp_dev *pnp_dev)
 {
-	spin_lock(&pnp_lock);
+	mutex_lock(&pnp_lock);
 	if (pnp_dev->status == PNP_ATTACHED)
 		pnp_dev->status = PNP_READY;
-	spin_unlock(&pnp_lock);
+	mutex_unlock(&pnp_lock);
 	pnp_disable_dev(pnp_dev);
 }
 

commit 01395d798452435f19de3bfe5d04325db4e49677
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Thu Jan 22 11:50:24 2015 -0500

    PNP: Allow console to override ACPI device sleep
    
    If the serial console is an ACPI PNP device, the PNP bus always powers
    down the device at system suspend, even though the no_console_suspend
    command line parameter is specified (eg., when debugging suspend/resume).
    
    Add PNP_CONSOLE capability, which when set, prevents calling both the
    ->disable() and ->suspend() PNP protocol methods if console suspend
    is disabled.
    
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pnp/driver.c b/drivers/pnp/driver.c
index f748cc8cbb03..4e57d3370368 100644
--- a/drivers/pnp/driver.c
+++ b/drivers/pnp/driver.c
@@ -182,7 +182,7 @@ static int __pnp_bus_suspend(struct device *dev, pm_message_t state)
 			return error;
 	}
 
-	if (pnp_dev->protocol->suspend)
+	if (pnp_can_suspend(pnp_dev))
 		pnp_dev->protocol->suspend(pnp_dev, state);
 	return 0;
 }

commit 8a37ea50e7acf8db6821ba094ca41384e7d8c70c
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Thu Dec 5 02:01:55 2013 +0100

    PNP: fix restoring devices after hibernation
    
    On returning from hibernation 'restore' callback is called,
    not 'resume'.  Fix it.
    
    Fixes: eaf140b60ec9 (PNP: convert PNP driver bus legacy pm_ops to dev_pm_ops)
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Cc: 3.12+ <stable@vger.kernel.org> # 3.12+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pnp/driver.c b/drivers/pnp/driver.c
index 6936e0acedcd..f748cc8cbb03 100644
--- a/drivers/pnp/driver.c
+++ b/drivers/pnp/driver.c
@@ -197,6 +197,11 @@ static int pnp_bus_freeze(struct device *dev)
 	return __pnp_bus_suspend(dev, PMSG_FREEZE);
 }
 
+static int pnp_bus_poweroff(struct device *dev)
+{
+	return __pnp_bus_suspend(dev, PMSG_HIBERNATE);
+}
+
 static int pnp_bus_resume(struct device *dev)
 {
 	struct pnp_dev *pnp_dev = to_pnp_dev(dev);
@@ -234,9 +239,14 @@ static int pnp_bus_resume(struct device *dev)
 }
 
 static const struct dev_pm_ops pnp_bus_dev_pm_ops = {
+	/* Suspend callbacks */
 	.suspend = pnp_bus_suspend,
-	.freeze = pnp_bus_freeze,
 	.resume = pnp_bus_resume,
+	/* Hibernate callbacks */
+	.freeze = pnp_bus_freeze,
+	.thaw = pnp_bus_resume,
+	.poweroff = pnp_bus_poweroff,
+	.restore = pnp_bus_resume,
 };
 
 struct bus_type pnp_bus_type = {

commit 2df4390130a85c2dd85ba3eb96f0c25ae7c5bca3
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sun Oct 6 23:55:42 2013 -0700

    PNP: convert bus code to use dev_groups
    
    The dev_attrs field of struct bus_type is going away soon, dev_groups
    should be used instead.  This converts the PNP bus code to use the
    correct field.
    
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pnp/driver.c b/drivers/pnp/driver.c
index a39ee38a9414..6936e0acedcd 100644
--- a/drivers/pnp/driver.c
+++ b/drivers/pnp/driver.c
@@ -246,7 +246,7 @@ struct bus_type pnp_bus_type = {
 	.remove  = pnp_device_remove,
 	.shutdown = pnp_device_shutdown,
 	.pm	 = &pnp_bus_dev_pm_ops,
-	.dev_attrs = pnp_interface_attrs,
+	.dev_groups = pnp_dev_groups,
 };
 
 int pnp_register_driver(struct pnp_driver *drv)

commit 729377d559607ea40d714e8f7092f40f643cf01f
Author: Shuah Khan <shuah.kh@samsung.com>
Date:   Wed Sep 11 14:23:09 2013 -0700

    pnp: change pnp bus pm_ops to invoke pnp driver dev_pm_ops if specified
    
    pnp_bus_suspend() and pnp_bus_resume() invoke legacy pm_ops from
    pnp_driver.  Changed pnp_bus_suspend() and pnp_bus_resume() to check if
    pnp driver has dev_pm_ops and call.  If dev_pm_ops don't exist, then call
    use legacy pm_ops.  Without this change, pnp_driver dev_pm_ops will not
    get called.
    
    In addition to the pnp driver bus pm_ops change to invoke driver
    dev_pm_ops, this patch set contains changes to rtc-cmos, tpm_tis, and
    apple-gmux pnp drivers to convert from legacy pm_ops to dev_pm_ops.
    
    This patch (of 4):
    
    pnp_bus_suspend() and pnp_bus_resume() invoke legacy pm_ops from
    pnp_driver.  Changed pnp_bus_suspend() and pnp_bus_resume() to check if
    pnp driver has dev_pm_ops and call.  If dev_pm_ops don't exist, then call
    use legacy pm_ops.  Without this change, pnp_driver dev_pm_ops will not
    get called.
    
    Signed-off-by: Shuah Khan <shuah.kh@samsung.com>
    Cc: Matthew Garrett <matthew.garrett@nebula.com>
    Cc: Leonidas Da Silva Barbosa <leosilva@linux.vnet.ibm.com>
    Cc: Ashley Lai <ashley@ashleylai.com>
    Cc: Rajiv Andrade <mail@srajiv.net>
    Cc: Marcel Selhorst <tpmdd@selhorst.net>
    Cc: Sirrix AG <tpmdd@sirrix.com>
    Cc: Alessandro Zummo <a.zummo@towertech.it>
    Cc: "Rafael J. Wysocki" <rafael.j.wysocki@intel.com>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Grant Likely <grant.likely@linaro.org>
    Cc: Rob Herring <rob.herring@calxeda.com>
    Cc: Peter Hüwe <PeterHuewe@gmx.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pnp/driver.c b/drivers/pnp/driver.c
index 12adb43a0693..a39ee38a9414 100644
--- a/drivers/pnp/driver.c
+++ b/drivers/pnp/driver.c
@@ -163,6 +163,13 @@ static int __pnp_bus_suspend(struct device *dev, pm_message_t state)
 	if (!pnp_drv)
 		return 0;
 
+	if (pnp_drv->driver.pm && pnp_drv->driver.pm->suspend) {
+		error = pnp_drv->driver.pm->suspend(dev);
+		suspend_report_result(pnp_drv->driver.pm->suspend, error);
+		if (error)
+			return error;
+	}
+
 	if (pnp_drv->suspend) {
 		error = pnp_drv->suspend(pnp_dev, state);
 		if (error)
@@ -211,6 +218,12 @@ static int pnp_bus_resume(struct device *dev)
 			return error;
 	}
 
+	if (pnp_drv->driver.pm && pnp_drv->driver.pm->resume) {
+		error = pnp_drv->driver.pm->resume(dev);
+		if (error)
+			return error;
+	}
+
 	if (pnp_drv->resume) {
 		error = pnp_drv->resume(pnp_dev);
 		if (error)

commit eaf140b60ec961252083ab8adaf67aef29a362dd
Author: Shuah Khan <shuah.kh@samsung.com>
Date:   Fri Jul 26 15:07:26 2013 -0600

    PNP: convert PNP driver bus legacy pm_ops to dev_pm_ops
    
    Convert drivers/pnp/driver.c bus legacy pm_ops to dev_pm_ops using
    existing suspend and resume routines.  Add freeze interface to
    handle PM_EVENT_FREEZE correctly with dev_pm_ops.  pm_op() looks for
    freeze interface when the event is PM_EVENT_FREEZE.
    
    Signed-off-by: Shuah Khan <shuah.kh@samsung.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pnp/driver.c b/drivers/pnp/driver.c
index 00e94032531a..12adb43a0693 100644
--- a/drivers/pnp/driver.c
+++ b/drivers/pnp/driver.c
@@ -154,7 +154,7 @@ static int pnp_bus_match(struct device *dev, struct device_driver *drv)
 	return 1;
 }
 
-static int pnp_bus_suspend(struct device *dev, pm_message_t state)
+static int __pnp_bus_suspend(struct device *dev, pm_message_t state)
 {
 	struct pnp_dev *pnp_dev = to_pnp_dev(dev);
 	struct pnp_driver *pnp_drv = pnp_dev->driver;
@@ -180,6 +180,16 @@ static int pnp_bus_suspend(struct device *dev, pm_message_t state)
 	return 0;
 }
 
+static int pnp_bus_suspend(struct device *dev)
+{
+	return __pnp_bus_suspend(dev, PMSG_SUSPEND);
+}
+
+static int pnp_bus_freeze(struct device *dev)
+{
+	return __pnp_bus_suspend(dev, PMSG_FREEZE);
+}
+
 static int pnp_bus_resume(struct device *dev)
 {
 	struct pnp_dev *pnp_dev = to_pnp_dev(dev);
@@ -210,14 +220,19 @@ static int pnp_bus_resume(struct device *dev)
 	return 0;
 }
 
+static const struct dev_pm_ops pnp_bus_dev_pm_ops = {
+	.suspend = pnp_bus_suspend,
+	.freeze = pnp_bus_freeze,
+	.resume = pnp_bus_resume,
+};
+
 struct bus_type pnp_bus_type = {
 	.name    = "pnp",
 	.match   = pnp_bus_match,
 	.probe   = pnp_device_probe,
 	.remove  = pnp_device_remove,
 	.shutdown = pnp_device_shutdown,
-	.suspend = pnp_bus_suspend,
-	.resume  = pnp_bus_resume,
+	.pm	 = &pnp_bus_dev_pm_ops,
 	.dev_attrs = pnp_interface_attrs,
 };
 

commit cc8e7a355c1ec64b06a5b8126c47c5cb47f44fce
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Jan 10 21:23:16 2011 +0100

    PNP / ACPI: Use DEVICE_ACPI_HANDLE() for device ACPI handle access
    
    The PNP ACPI driver squirrels the ACPI handles of PNP devices' ACPI
    companions, but this isn't correct, because those handles should be
    accessed using the DEVICE_ACPI_HANDLE() macro operating on struct
    device objects.
    
    Using DEVICE_ACPI_HANDLE() in the PNP ACPI driver instead of the
    driver's own copies of the ACPI handles allows us to avoid a problem
    with docking stations where a machine docked before suspend to RAM
    and undocked while suspended crashes during the subsequent resume (in
    that case the ACPI companion of the PNP device in question doesn't
    exist any more while the device is being resumed).  It also allows us
    to avoid the problem where suspend to RAM fails when the machine was
    undocked while suspended before (again, the ACPI companion of the PNP
    device is not present any more while it is being suspended).
    
    This change doesn't fix all of the the PNP ACPI driver's problems
    with PNP devices in docking stations (generally speaking, the driver
    has no idea that devices can come and go and doesn't even attempt to
    handle such events), but at least it makes suspend work for the
    users of docking stations who don't use the PNP devices located in
    there.
    
    References: https://bugzilla.kernel.org/show_bug.cgi?id=15100
    
    Reported-and-tested-by: Toralf Förster <toralf.foerster@gmx.de>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/driver.c b/drivers/pnp/driver.c
index d1dbb9df53fa..00e94032531a 100644
--- a/drivers/pnp/driver.c
+++ b/drivers/pnp/driver.c
@@ -189,8 +189,11 @@ static int pnp_bus_resume(struct device *dev)
 	if (!pnp_drv)
 		return 0;
 
-	if (pnp_dev->protocol->resume)
-		pnp_dev->protocol->resume(pnp_dev);
+	if (pnp_dev->protocol->resume) {
+		error = pnp_dev->protocol->resume(pnp_dev);
+		if (error)
+			return error;
+	}
 
 	if (pnp_can_write(pnp_dev)) {
 		error = pnp_start_dev(pnp_dev);

commit 620e112cfe1c9281c176de8ad1a7691c4eb4950d
Author: Thomas Renninger <trenn@suse.de>
Date:   Fri Oct 1 10:54:00 2010 +0200

    ACPI/PNP: A HID value of an object never changes -> make it const
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/driver.c b/drivers/pnp/driver.c
index cd11b113494f..d1dbb9df53fa 100644
--- a/drivers/pnp/driver.c
+++ b/drivers/pnp/driver.c
@@ -236,7 +236,7 @@ void pnp_unregister_driver(struct pnp_driver *drv)
  * @dev: pointer to the desired device
  * @id: pointer to an EISA id string
  */
-struct pnp_id *pnp_add_id(struct pnp_dev *dev, char *id)
+struct pnp_id *pnp_add_id(struct pnp_dev *dev, const char *id)
 {
 	struct pnp_id *dev_id, *ptr;
 

commit abd6633c67925f90775bb74755f9c547e30f1f20
Author: David Härdeman <david@hardeman.nu>
Date:   Mon Sep 21 17:04:52 2009 -0700

    pnp: add a shutdown method to pnp drivers
    
    The shutdown method is used by the winbond cir driver to setup the
    hardware for wake-from-S5.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: David Härdeman <david@hardeman.nu>
    Cc: Dmitry Torokhov <dtor@mail.ru>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pnp/driver.c b/drivers/pnp/driver.c
index 527ee764c93f..cd11b113494f 100644
--- a/drivers/pnp/driver.c
+++ b/drivers/pnp/driver.c
@@ -135,6 +135,15 @@ static int pnp_device_remove(struct device *dev)
 	return 0;
 }
 
+static void pnp_device_shutdown(struct device *dev)
+{
+	struct pnp_dev *pnp_dev = to_pnp_dev(dev);
+	struct pnp_driver *drv = pnp_dev->driver;
+
+	if (drv && drv->shutdown)
+		drv->shutdown(pnp_dev);
+}
+
 static int pnp_bus_match(struct device *dev, struct device_driver *drv)
 {
 	struct pnp_dev *pnp_dev = to_pnp_dev(dev);
@@ -203,6 +212,7 @@ struct bus_type pnp_bus_type = {
 	.match   = pnp_bus_match,
 	.probe   = pnp_device_probe,
 	.remove  = pnp_device_remove,
+	.shutdown = pnp_device_shutdown,
 	.suspend = pnp_bus_suspend,
 	.resume  = pnp_bus_resume,
 	.dev_attrs = pnp_interface_attrs,

commit 057316cc6a5b521b332a1d7ccc871cd60c904c74
Merge: 3e2dab9a1c2d 2515ddc6db8e
Author: Len Brown <len.brown@intel.com>
Date:   Wed Oct 22 23:57:26 2008 -0400

    Merge branch 'linus' into test
    
    Conflicts:
            MAINTAINERS
            arch/x86/kernel/acpi/boot.c
            arch/x86/kernel/acpi/sleep.c
            drivers/acpi/Kconfig
            drivers/pnp/Makefile
            drivers/pnp/quirks.c
    
    Signed-off-by: Len Brown <len.brown@intel.com>

commit 8a89efd18aa15bb832778baa4e6eee3857ecada4
Author: Drew Moseley <dmoseley@mvista.com>
Date:   Sun Sep 28 01:31:35 2008 +0200

    PNP: create device attributes via default device attributes
    
    This creates the attributes before the uevent is sent.
    
    Signed-off-by: Drew Moseley <dmoseley@mvista.com>
    Acked-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pnp/driver.c b/drivers/pnp/driver.c
index d3f869ee1d92..e3f7e89c4dfb 100644
--- a/drivers/pnp/driver.c
+++ b/drivers/pnp/driver.c
@@ -206,6 +206,7 @@ struct bus_type pnp_bus_type = {
 	.remove  = pnp_device_remove,
 	.suspend = pnp_bus_suspend,
 	.resume  = pnp_bus_resume,
+	.dev_attrs = pnp_interface_attrs,
 };
 
 int pnp_register_driver(struct pnp_driver *drv)

commit c865d2f6eb160c15b74245b4891c8e945d67d96c
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Aug 19 16:53:26 2008 -0600

    PNP: convert the last few pnp_info() uses to printk()
    
    There are only a few remaining uses of pnp_info(), so I just
    converted them to printk and removed the pnp_err(), pnp_info(),
    pnp_warn(), and pnp_dbg() wrappers.
    
    I also removed a couple debug messages that don't seem useful any
    more ("driver registered", "driver unregistered", "driver attached").
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/driver.c b/drivers/pnp/driver.c
index d3f869ee1d92..54673a4f5901 100644
--- a/drivers/pnp/driver.c
+++ b/drivers/pnp/driver.c
@@ -114,7 +114,6 @@ static int pnp_device_probe(struct device *dev)
 	} else
 		goto fail;
 
-	dev_dbg(dev, "driver attached\n");
 	return error;
 
 fail:
@@ -210,8 +209,6 @@ struct bus_type pnp_bus_type = {
 
 int pnp_register_driver(struct pnp_driver *drv)
 {
-	pnp_dbg("the driver '%s' has been registered", drv->name);
-
 	drv->driver.name = drv->name;
 	drv->driver.bus = &pnp_bus_type;
 
@@ -221,7 +218,6 @@ int pnp_register_driver(struct pnp_driver *drv)
 void pnp_unregister_driver(struct pnp_driver *drv)
 {
 	driver_unregister(&drv->driver);
-	pnp_dbg("the driver '%s' has been unregistered", drv->name);
 }
 
 /**

commit 772defc6292bae8b6db298476d1dabd22a99492b
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Apr 28 16:33:52 2008 -0600

    PNP: change pnp_add_id() to allocate its own pnp_id structures
    
    This moves some of the pnp_id knowledge out of the backends and into
    the PNP core.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Acked-By: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/driver.c b/drivers/pnp/driver.c
index e85cbf116db1..d3f869ee1d92 100644
--- a/drivers/pnp/driver.c
+++ b/drivers/pnp/driver.c
@@ -226,22 +226,36 @@ void pnp_unregister_driver(struct pnp_driver *drv)
 
 /**
  * pnp_add_id - adds an EISA id to the specified device
- * @id: pointer to a pnp_id structure
  * @dev: pointer to the desired device
+ * @id: pointer to an EISA id string
  */
-int pnp_add_id(struct pnp_id *id, struct pnp_dev *dev)
+struct pnp_id *pnp_add_id(struct pnp_dev *dev, char *id)
 {
-	struct pnp_id *ptr;
+	struct pnp_id *dev_id, *ptr;
 
-	id->next = NULL;
+	dev_id = kzalloc(sizeof(struct pnp_id), GFP_KERNEL);
+	if (!dev_id)
+		return NULL;
+
+	dev_id->id[0] = id[0];
+	dev_id->id[1] = id[1];
+	dev_id->id[2] = id[2];
+	dev_id->id[3] = tolower(id[3]);
+	dev_id->id[4] = tolower(id[4]);
+	dev_id->id[5] = tolower(id[5]);
+	dev_id->id[6] = tolower(id[6]);
+	dev_id->id[7] = '\0';
+
+	dev_id->next = NULL;
 	ptr = dev->id;
 	while (ptr && ptr->next)
 		ptr = ptr->next;
 	if (ptr)
-		ptr->next = id;
+		ptr->next = dev_id;
 	else
-		dev->id = id;
-	return 0;
+		dev->id = dev_id;
+
+	return dev_id;
 }
 
 EXPORT_SYMBOL(pnp_register_driver);

commit 0bc11fd446d2ca29459c3c8e04a6d36db9bbbea4
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Apr 28 02:15:57 2008 -0700

    PNP: skip dev->protocol NULL checks
    
    Every PNP device should have a valid protocol pointer.  If it doesn't,
    something's wrong and we should oops so we can find and fix the problem.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Cc: Adam Belay <ambx1@neo.rr.com>
    Cc: Adrian Bunk <bunk@kernel.org>
    Cc: Rene Herman <rene.herman@keyaccess.nl>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pnp/driver.c b/drivers/pnp/driver.c
index 12a1645a2e43..e85cbf116db1 100644
--- a/drivers/pnp/driver.c
+++ b/drivers/pnp/driver.c
@@ -167,7 +167,7 @@ static int pnp_bus_suspend(struct device *dev, pm_message_t state)
 			return error;
 	}
 
-	if (pnp_dev->protocol && pnp_dev->protocol->suspend)
+	if (pnp_dev->protocol->suspend)
 		pnp_dev->protocol->suspend(pnp_dev, state);
 	return 0;
 }
@@ -181,7 +181,7 @@ static int pnp_bus_resume(struct device *dev)
 	if (!pnp_drv)
 		return 0;
 
-	if (pnp_dev->protocol && pnp_dev->protocol->resume)
+	if (pnp_dev->protocol->resume)
 		pnp_dev->protocol->resume(pnp_dev);
 
 	if (pnp_can_write(pnp_dev)) {

commit 5d38998ed15b31f524bde9a193d60150af30d916
Author: Rene Herman <rene.herman@keyaccess.nl>
Date:   Wed Feb 6 01:40:05 2008 -0800

    PNP: do not test PNP_DRIVER_RES_DO_NOT_CHANGE on suspend/resume
    
    The PNP_DRIVER_RES_DO_NOT_CHANGE flag is meant to signify that the PNP core
    should not change resources for the device -- not that it shouldn't
    disable/enable the device on suspend/resume.
    
    ALSA ISAPnP drivers set PNP_DRIVER_RES_DO_NOT_CHANAGE (0x0001) through
    setting PNP_DRIVER_RES_DISABLE (0x0003).  The latter including the former
    may in itself be considered rather unexpected but doesn't change that
    suspend/resume wouldn't seem to have any business testing the flag.
    
    As reported by Ondrej Zary for snd-cs4236, ALSA driven ISAPnP cards don't
    survive swsusp hibernation with the resume skipping setting the resources
    due to testing the flag -- the same test in the suspend path isn't enough
    to keep hibernation from disabling the card it seems.
    
    These tests were added (in 2005) by Piere Ossman in commit
    68094e3251a664ee1389fcf179497237cbf78331, "alsa: Improved PnP suspend
    support" who doesn't remember why.  This deletes them.
    
    Signed-off-by: Rene Herman <rene.herman@gmail.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Cc: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Cc: Pierre Ossman <drzeus@drzeus.cx>
    Cc: Adam Belay <ambx1@neo.rr.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pnp/driver.c b/drivers/pnp/driver.c
index a262762c5b88..12a1645a2e43 100644
--- a/drivers/pnp/driver.c
+++ b/drivers/pnp/driver.c
@@ -161,8 +161,7 @@ static int pnp_bus_suspend(struct device *dev, pm_message_t state)
 			return error;
 	}
 
-	if (!(pnp_drv->flags & PNP_DRIVER_RES_DO_NOT_CHANGE) &&
-	    pnp_can_disable(pnp_dev)) {
+	if (pnp_can_disable(pnp_dev)) {
 		error = pnp_stop_dev(pnp_dev);
 		if (error)
 			return error;
@@ -185,14 +184,17 @@ static int pnp_bus_resume(struct device *dev)
 	if (pnp_dev->protocol && pnp_dev->protocol->resume)
 		pnp_dev->protocol->resume(pnp_dev);
 
-	if (!(pnp_drv->flags & PNP_DRIVER_RES_DO_NOT_CHANGE)) {
+	if (pnp_can_write(pnp_dev)) {
 		error = pnp_start_dev(pnp_dev);
 		if (error)
 			return error;
 	}
 
-	if (pnp_drv->resume)
-		return pnp_drv->resume(pnp_dev);
+	if (pnp_drv->resume) {
+		error = pnp_drv->resume(pnp_dev);
+		if (error)
+			return error;
+	}
 
 	return 0;
 }

commit a05d0781695566296e74a3670dd5bbd3daf24ae2
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Oct 16 23:31:10 2007 -0700

    PNP: use dev_info(), dev_err(), etc in core
    
    If we have the struct pnp_dev available, we can use dev_info(), dev_err(),
    etc., to give a little more information and consistency.
    
    [akpm@linux-foundation.org: fix warning]
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Cc: Adam Belay <ambx1@neo.rr.com>
    Cc: Len Brown <lenb@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pnp/driver.c b/drivers/pnp/driver.c
index 2fa64a6b25c8..a262762c5b88 100644
--- a/drivers/pnp/driver.c
+++ b/drivers/pnp/driver.c
@@ -86,9 +86,6 @@ static int pnp_device_probe(struct device *dev)
 	pnp_dev = to_pnp_dev(dev);
 	pnp_drv = to_pnp_driver(dev->driver);
 
-	pnp_dbg("match found with the PnP device '%s' and the driver '%s'",
-		dev->bus_id, pnp_drv->name);
-
 	error = pnp_device_attach(pnp_dev);
 	if (error < 0)
 		return error;
@@ -116,6 +113,8 @@ static int pnp_device_probe(struct device *dev)
 		error = 0;
 	} else
 		goto fail;
+
+	dev_dbg(dev, "driver attached\n");
 	return error;
 
 fail:

commit b173491339b9ae7f1322241ce6228c1268513a39
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Wed Aug 15 10:32:13 2007 -0600

    PNP: remove null pointer checks
    
    Remove some null pointer checks.  Null pointers in these areas indicate
    programming errors, and I think it's better to oops immediately rather
    than return an error that is easily ignored.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Acked-by: Adam Belay <abelay@novell.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/driver.c b/drivers/pnp/driver.c
index 9be01b0433b9..2fa64a6b25c8 100644
--- a/drivers/pnp/driver.c
+++ b/drivers/pnp/driver.c
@@ -232,10 +232,6 @@ int pnp_add_id(struct pnp_id *id, struct pnp_dev *dev)
 {
 	struct pnp_id *ptr;
 
-	if (!id)
-		return -EINVAL;
-	if (!dev)
-		return -EINVAL;
 	id->next = NULL;
 	ptr = dev->id;
 	while (ptr && ptr->next)

commit 1e0aa9ad721349781b728ec4226876247e3fd431
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Wed Aug 15 10:32:08 2007 -0600

    PNP: fix up after Lindent
    
    More manual fixups after Lindent.  No functional change.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Acked-by: Adam Belay <abelay@novell.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/driver.c b/drivers/pnp/driver.c
index 30b8f6f3258a..9be01b0433b9 100644
--- a/drivers/pnp/driver.c
+++ b/drivers/pnp/driver.c
@@ -118,7 +118,7 @@ static int pnp_device_probe(struct device *dev)
 		goto fail;
 	return error;
 
-      fail:
+fail:
 	pnp_device_detach(pnp_dev);
 	return error;
 }

commit 07d4e9af109221ab731c5aaf832e89776c64b013
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Thu Jul 26 10:41:21 2007 -0700

    PNP: fix up after Lindent
    
    These are manual fixups after running Lindent.  No functional change.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Adam Belay <ambx1@neo.rr.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pnp/driver.c b/drivers/pnp/driver.c
index 913d926f8baf..30b8f6f3258a 100644
--- a/drivers/pnp/driver.c
+++ b/drivers/pnp/driver.c
@@ -2,7 +2,6 @@
  * driver.c - device id matching, driver model, etc.
  *
  * Copyright 2002 Adam Belay <ambx1@neo.rr.com>
- *
  */
 
 #include <linux/string.h>
@@ -16,6 +15,7 @@
 static int compare_func(const char *ida, const char *idb)
 {
 	int i;
+
 	/* we only need to compare the last 4 chars */
 	for (i = 3; i < 7; i++) {
 		if (ida[i] != 'X' &&
@@ -44,6 +44,7 @@ static const struct pnp_device_id *match_device(struct pnp_driver *drv,
 						struct pnp_dev *dev)
 {
 	const struct pnp_device_id *drv_id = drv->id_table;
+
 	if (!drv_id)
 		return NULL;
 
@@ -140,6 +141,7 @@ static int pnp_bus_match(struct device *dev, struct device_driver *drv)
 {
 	struct pnp_dev *pnp_dev = to_pnp_dev(dev);
 	struct pnp_driver *pnp_drv = to_pnp_driver(drv);
+
 	if (match_device(pnp_drv, pnp_dev) == NULL)
 		return 0;
 	return 1;
@@ -197,12 +199,12 @@ static int pnp_bus_resume(struct device *dev)
 }
 
 struct bus_type pnp_bus_type = {
-	.name = "pnp",
-	.match = pnp_bus_match,
-	.probe = pnp_device_probe,
-	.remove = pnp_device_remove,
+	.name    = "pnp",
+	.match   = pnp_bus_match,
+	.probe   = pnp_device_probe,
+	.remove  = pnp_device_remove,
 	.suspend = pnp_bus_suspend,
-	.resume = pnp_bus_resume,
+	.resume  = pnp_bus_resume,
 };
 
 int pnp_register_driver(struct pnp_driver *drv)
@@ -225,12 +227,11 @@ void pnp_unregister_driver(struct pnp_driver *drv)
  * pnp_add_id - adds an EISA id to the specified device
  * @id: pointer to a pnp_id structure
  * @dev: pointer to the desired device
- *
  */
-
 int pnp_add_id(struct pnp_id *id, struct pnp_dev *dev)
 {
 	struct pnp_id *ptr;
+
 	if (!id)
 		return -EINVAL;
 	if (!dev)
@@ -248,8 +249,5 @@ int pnp_add_id(struct pnp_id *id, struct pnp_dev *dev)
 
 EXPORT_SYMBOL(pnp_register_driver);
 EXPORT_SYMBOL(pnp_unregister_driver);
-#if 0
-EXPORT_SYMBOL(pnp_add_id);
-#endif
 EXPORT_SYMBOL(pnp_device_attach);
 EXPORT_SYMBOL(pnp_device_detach);

commit 9dd78466c956ac4b4f38e12032dc4249ccf57ad1
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Thu Jul 26 10:41:20 2007 -0700

    PNP: Lindent all source files
    
    Run Lindent on all PNP source files.
    
    Produced by:
    
        $ quilt new pnp-lindent
        $ find drivers/pnp -name \*.[ch] | xargs quilt add
        $ quilt add include/linux/{pnp.h,pnpbios.h}
        $ scripts/Lindent drivers/pnp/*.c drivers/pnp/*/*.c include/linux/pnp*.h
        $ quilt refresh --sort
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Adam Belay <ambx1@neo.rr.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pnp/driver.c b/drivers/pnp/driver.c
index 1432806451cd..913d926f8baf 100644
--- a/drivers/pnp/driver.c
+++ b/drivers/pnp/driver.c
@@ -17,11 +17,9 @@ static int compare_func(const char *ida, const char *idb)
 {
 	int i;
 	/* we only need to compare the last 4 chars */
-	for (i=3; i<7; i++)
-	{
+	for (i = 3; i < 7; i++) {
 		if (ida[i] != 'X' &&
-		    idb[i] != 'X' &&
-		    toupper(ida[i]) != toupper(idb[i]))
+		    idb[i] != 'X' && toupper(ida[i]) != toupper(idb[i]))
 			return 0;
 	}
 	return 1;
@@ -31,18 +29,19 @@ int compare_pnp_id(struct pnp_id *pos, const char *id)
 {
 	if (!pos || !id || (strlen(id) != 7))
 		return 0;
-	if (memcmp(id,"ANYDEVS",7)==0)
+	if (memcmp(id, "ANYDEVS", 7) == 0)
 		return 1;
-	while (pos){
-		if (memcmp(pos->id,id,3)==0)
-			if (compare_func(pos->id,id)==1)
+	while (pos) {
+		if (memcmp(pos->id, id, 3) == 0)
+			if (compare_func(pos->id, id) == 1)
 				return 1;
 		pos = pos->next;
 	}
 	return 0;
 }
 
-static const struct pnp_device_id * match_device(struct pnp_driver *drv, struct pnp_dev *dev)
+static const struct pnp_device_id *match_device(struct pnp_driver *drv,
+						struct pnp_dev *dev)
 {
 	const struct pnp_device_id *drv_id = drv->id_table;
 	if (!drv_id)
@@ -59,7 +58,7 @@ static const struct pnp_device_id * match_device(struct pnp_driver *drv, struct
 int pnp_device_attach(struct pnp_dev *pnp_dev)
 {
 	spin_lock(&pnp_lock);
-	if(pnp_dev->status != PNP_READY){
+	if (pnp_dev->status != PNP_READY) {
 		spin_unlock(&pnp_lock);
 		return -EBUSY;
 	}
@@ -86,7 +85,8 @@ static int pnp_device_probe(struct device *dev)
 	pnp_dev = to_pnp_dev(dev);
 	pnp_drv = to_pnp_driver(dev->driver);
 
-	pnp_dbg("match found with the PnP device '%s' and the driver '%s'", dev->bus_id,pnp_drv->name);
+	pnp_dbg("match found with the PnP device '%s' and the driver '%s'",
+		dev->bus_id, pnp_drv->name);
 
 	error = pnp_device_attach(pnp_dev);
 	if (error < 0)
@@ -99,7 +99,7 @@ static int pnp_device_probe(struct device *dev)
 				return error;
 		}
 	} else if ((pnp_drv->flags & PNP_DRIVER_RES_DISABLE)
-		    == PNP_DRIVER_RES_DISABLE) {
+		   == PNP_DRIVER_RES_DISABLE) {
 		error = pnp_disable_dev(pnp_dev);
 		if (error < 0)
 			return error;
@@ -110,22 +110,22 @@ static int pnp_device_probe(struct device *dev)
 		if (dev_id != NULL)
 			error = pnp_drv->probe(pnp_dev, dev_id);
 	}
-	if (error >= 0){
+	if (error >= 0) {
 		pnp_dev->driver = pnp_drv;
 		error = 0;
 	} else
 		goto fail;
 	return error;
 
-fail:
+      fail:
 	pnp_device_detach(pnp_dev);
 	return error;
 }
 
 static int pnp_device_remove(struct device *dev)
 {
-	struct pnp_dev * pnp_dev = to_pnp_dev(dev);
-	struct pnp_driver * drv = pnp_dev->driver;
+	struct pnp_dev *pnp_dev = to_pnp_dev(dev);
+	struct pnp_driver *drv = pnp_dev->driver;
 
 	if (drv) {
 		if (drv->remove)
@@ -138,8 +138,8 @@ static int pnp_device_remove(struct device *dev)
 
 static int pnp_bus_match(struct device *dev, struct device_driver *drv)
 {
-	struct pnp_dev * pnp_dev = to_pnp_dev(dev);
-	struct pnp_driver * pnp_drv = to_pnp_driver(drv);
+	struct pnp_dev *pnp_dev = to_pnp_dev(dev);
+	struct pnp_driver *pnp_drv = to_pnp_driver(drv);
 	if (match_device(pnp_drv, pnp_dev) == NULL)
 		return 0;
 	return 1;
@@ -147,8 +147,8 @@ static int pnp_bus_match(struct device *dev, struct device_driver *drv)
 
 static int pnp_bus_suspend(struct device *dev, pm_message_t state)
 {
-	struct pnp_dev * pnp_dev = to_pnp_dev(dev);
-	struct pnp_driver * pnp_drv = pnp_dev->driver;
+	struct pnp_dev *pnp_dev = to_pnp_dev(dev);
+	struct pnp_driver *pnp_drv = pnp_dev->driver;
 	int error;
 
 	if (!pnp_drv)
@@ -162,9 +162,9 @@ static int pnp_bus_suspend(struct device *dev, pm_message_t state)
 
 	if (!(pnp_drv->flags & PNP_DRIVER_RES_DO_NOT_CHANGE) &&
 	    pnp_can_disable(pnp_dev)) {
-	    	error = pnp_stop_dev(pnp_dev);
-	    	if (error)
-	    		return error;
+		error = pnp_stop_dev(pnp_dev);
+		if (error)
+			return error;
 	}
 
 	if (pnp_dev->protocol && pnp_dev->protocol->suspend)
@@ -174,8 +174,8 @@ static int pnp_bus_suspend(struct device *dev, pm_message_t state)
 
 static int pnp_bus_resume(struct device *dev)
 {
-	struct pnp_dev * pnp_dev = to_pnp_dev(dev);
-	struct pnp_driver * pnp_drv = pnp_dev->driver;
+	struct pnp_dev *pnp_dev = to_pnp_dev(dev);
+	struct pnp_driver *pnp_drv = pnp_dev->driver;
 	int error;
 
 	if (!pnp_drv)
@@ -197,10 +197,10 @@ static int pnp_bus_resume(struct device *dev)
 }
 
 struct bus_type pnp_bus_type = {
-	.name	= "pnp",
-	.match	= pnp_bus_match,
-	.probe	= pnp_device_probe,
-	.remove	= pnp_device_remove,
+	.name = "pnp",
+	.match = pnp_bus_match,
+	.probe = pnp_device_probe,
+	.remove = pnp_device_remove,
 	.suspend = pnp_bus_suspend,
 	.resume = pnp_bus_resume,
 };

commit fc30e68e88baf463683bde43347756889ba2ffae
Author: Shaohua Li <shaohua.li@intel.com>
Date:   Fri Jul 20 10:03:20 2007 +0800

    ACPI, PNP: hook ACPI D-state to PNP suspend/resume
    
    applied after Rafel's 'PM: Update global suspend and hibernation operations framework' patch set
    
    Signed-off-by: Shaohua Li <shaohua.li@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/driver.c b/drivers/pnp/driver.c
index e161423b4300..1432806451cd 100644
--- a/drivers/pnp/driver.c
+++ b/drivers/pnp/driver.c
@@ -167,6 +167,8 @@ static int pnp_bus_suspend(struct device *dev, pm_message_t state)
 	    		return error;
 	}
 
+	if (pnp_dev->protocol && pnp_dev->protocol->suspend)
+		pnp_dev->protocol->suspend(pnp_dev, state);
 	return 0;
 }
 
@@ -179,6 +181,9 @@ static int pnp_bus_resume(struct device *dev)
 	if (!pnp_drv)
 		return 0;
 
+	if (pnp_dev->protocol && pnp_dev->protocol->resume)
+		pnp_dev->protocol->resume(pnp_dev);
+
 	if (!(pnp_drv->flags & PNP_DRIVER_RES_DO_NOT_CHANGE)) {
 		error = pnp_start_dev(pnp_dev);
 		if (error)

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jörn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jörn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/drivers/pnp/driver.c b/drivers/pnp/driver.c
index e54c15383193..e161423b4300 100644
--- a/drivers/pnp/driver.c
+++ b/drivers/pnp/driver.c
@@ -5,7 +5,6 @@
  *
  */
 
-#include <linux/config.h>
 #include <linux/string.h>
 #include <linux/list.h>
 #include <linux/module.h>

commit 982c609448b9d724e1c3a0d5aeee388c064479f0
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Mar 27 01:17:08 2006 -0800

    [PATCH] pnp: PNP: adjust pnp_register_driver signature
    
    Remove the assumption that pnp_register_driver() returns the number of devices
    claimed.  Returning the count is unreliable because devices may be hot-plugged
    in the future.
    
    This changes the convention to "zero for success, or a negative error value,"
    which matches pci_register_driver(), acpi_bus_register_driver(), and
    platform_driver_register().
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Cc: Adam Belay <ambx1@neo.rr.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/pnp/driver.c b/drivers/pnp/driver.c
index 7cafacdd12b0..e54c15383193 100644
--- a/drivers/pnp/driver.c
+++ b/drivers/pnp/driver.c
@@ -201,31 +201,14 @@ struct bus_type pnp_bus_type = {
 	.resume = pnp_bus_resume,
 };
 
-
-static int count_devices(struct device * dev, void * c)
-{
-	int * count = c;
-	(*count)++;
-	return 0;
-}
-
 int pnp_register_driver(struct pnp_driver *drv)
 {
-	int count;
-
 	pnp_dbg("the driver '%s' has been registered", drv->name);
 
 	drv->driver.name = drv->name;
 	drv->driver.bus = &pnp_bus_type;
 
-	count = driver_register(&drv->driver);
-
-	/* get the number of initial matches */
-	if (count >= 0){
-		count = 0;
-		driver_for_each_device(&drv->driver, NULL, &count, count_devices);
-	}
-	return count;
+	return driver_register(&drv->driver);
 }
 
 void pnp_unregister_driver(struct pnp_driver *drv)

commit 4681fc320889de4591f945c4fdf08546eb9ab266
Author: Russell King <rmk@arm.linux.org.uk>
Date:   Thu Jan 5 14:41:37 2006 +0000

    [PATCH] Add pnp_bus_type probe and remove methods
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pnp/driver.c b/drivers/pnp/driver.c
index 15fb758a9e52..7cafacdd12b0 100644
--- a/drivers/pnp/driver.c
+++ b/drivers/pnp/driver.c
@@ -195,6 +195,8 @@ static int pnp_bus_resume(struct device *dev)
 struct bus_type pnp_bus_type = {
 	.name	= "pnp",
 	.match	= pnp_bus_match,
+	.probe	= pnp_device_probe,
+	.remove	= pnp_device_remove,
 	.suspend = pnp_bus_suspend,
 	.resume = pnp_bus_resume,
 };
@@ -215,8 +217,6 @@ int pnp_register_driver(struct pnp_driver *drv)
 
 	drv->driver.name = drv->name;
 	drv->driver.bus = &pnp_bus_type;
-	drv->driver.probe = pnp_device_probe;
-	drv->driver.remove = pnp_device_remove;
 
 	count = driver_register(&drv->driver);
 

commit 68094e3251a664ee1389fcf179497237cbf78331
Author: Pierre Ossman <drzeus-list@drzeus.cx>
Date:   Tue Nov 29 09:09:32 2005 +0100

    [ALSA] [PATCH] alsa: Improved PnP suspend support
    
    Also use the PnP functions to start/stop the devices during the suspend so
    that drivers will not have to duplicate this code.
    
    Cc: Adam Belay <ambx1@neo.rr.com>
    Cc: Jaroslav Kysela <perex@suse.cz>
    Cc: Takashi Iwai <tiwai@suse.de>
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/drivers/pnp/driver.c b/drivers/pnp/driver.c
index ea2cb9a8b21d..15fb758a9e52 100644
--- a/drivers/pnp/driver.c
+++ b/drivers/pnp/driver.c
@@ -150,19 +150,46 @@ static int pnp_bus_suspend(struct device *dev, pm_message_t state)
 {
 	struct pnp_dev * pnp_dev = to_pnp_dev(dev);
 	struct pnp_driver * pnp_drv = pnp_dev->driver;
+	int error;
+
+	if (!pnp_drv)
+		return 0;
+
+	if (pnp_drv->suspend) {
+		error = pnp_drv->suspend(pnp_dev, state);
+		if (error)
+			return error;
+	}
+
+	if (!(pnp_drv->flags & PNP_DRIVER_RES_DO_NOT_CHANGE) &&
+	    pnp_can_disable(pnp_dev)) {
+	    	error = pnp_stop_dev(pnp_dev);
+	    	if (error)
+	    		return error;
+	}
 
-	if (pnp_drv && pnp_drv->suspend)
-		return pnp_drv->suspend(pnp_dev, state);
 	return 0;
 }
 
-static void pnp_bus_resume(struct device *dev)
+static int pnp_bus_resume(struct device *dev)
 {
 	struct pnp_dev * pnp_dev = to_pnp_dev(dev);
 	struct pnp_driver * pnp_drv = pnp_dev->driver;
+	int error;
+
+	if (!pnp_drv)
+		return 0;
+
+	if (!(pnp_drv->flags & PNP_DRIVER_RES_DO_NOT_CHANGE)) {
+		error = pnp_start_dev(pnp_dev);
+		if (error)
+			return error;
+	}
 
-	if (pnp_drv && pnp_drv->resume)
-		pnp_drv->resume(pnp_dev);
+	if (pnp_drv->resume)
+		return pnp_drv->resume(pnp_dev);
+
+	return 0;
 }
 
 struct bus_type pnp_bus_type = {

commit 4c98cfef2efa6b6662ac28c4f0069964bbd9fdf9
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Nov 29 09:09:32 2005 +0100

    [ALSA] PATCH] Add PM support to PnP drivers
    
    Add suspend/resume callback to pnp_driver and pnp_card_driver.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/drivers/pnp/driver.c b/drivers/pnp/driver.c
index d3ccce706ab4..ea2cb9a8b21d 100644
--- a/drivers/pnp/driver.c
+++ b/drivers/pnp/driver.c
@@ -146,10 +146,30 @@ static int pnp_bus_match(struct device *dev, struct device_driver *drv)
 	return 1;
 }
 
+static int pnp_bus_suspend(struct device *dev, pm_message_t state)
+{
+	struct pnp_dev * pnp_dev = to_pnp_dev(dev);
+	struct pnp_driver * pnp_drv = pnp_dev->driver;
+
+	if (pnp_drv && pnp_drv->suspend)
+		return pnp_drv->suspend(pnp_dev, state);
+	return 0;
+}
+
+static void pnp_bus_resume(struct device *dev)
+{
+	struct pnp_dev * pnp_dev = to_pnp_dev(dev);
+	struct pnp_driver * pnp_drv = pnp_dev->driver;
+
+	if (pnp_drv && pnp_drv->resume)
+		pnp_drv->resume(pnp_dev);
+}
 
 struct bus_type pnp_bus_type = {
 	.name	= "pnp",
 	.match	= pnp_bus_match,
+	.suspend = pnp_bus_suspend,
+	.resume = pnp_bus_resume,
 };
 
 

commit b449f63c8ce4a517cb91f237cc3d68d083ec2dd3
Author: Adrian Bunk <bunk@stusta.de>
Date:   Mon Nov 7 01:01:48 2005 -0800

    [PATCH] drivers/pnp/: cleanups
    
    This patch contains the following possible cleanups:
    - make needlessly global code static
    - #if 0 the following unused global function:
      - core.c: pnp_remove_device
    - #if 0 the following unneeded EXPORT_SYMBOL's:
      - card.c: pnp_add_card
      - card.c: pnp_remove_card
      - card.c: pnp_add_card_device
      - card.c: pnp_remove_card_device
      - card.c: pnp_add_card_id
      - core.c: pnp_register_protocol
      - core.c: pnp_unregister_protocol
      - core.c: pnp_add_device
      - core.c: pnp_remove_device
      - pnpacpi/core.c: pnpacpi_protocol
      - driver.c: pnp_add_id
      - isapnp/core.c: isapnp_read_byte
      - manager.c: pnp_auto_config_dev
      - resource.c: pnp_register_dependent_option
      - resource.c: pnp_register_independent_option
      - resource.c: pnp_register_irq_resource
      - resource.c: pnp_register_dma_resource
      - resource.c: pnp_register_port_resource
      - resource.c: pnp_register_mem_resource
    
    Note that this patch #if 0's exactly one functions and removes no
    functions.  Most it does is the #if 0 of EXPORT_SYMBOL's, so if any modular
    code will use any of them, re-adding will be trivial.
    
    Modular ISAPnP might be interesting in some cases, but this is more legacy
    code.  If someone would work on it to sort all the issues out (starting
    with the point that most users of __ISAPNP__ will have to be fixed)
    re-enabling the required EXPORT_SYMBOL's won't be hard for him.
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Cc: Adam Belay <ambx1@neo.rr.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/pnp/driver.c b/drivers/pnp/driver.c
index 33da25f3213f..d3ccce706ab4 100644
--- a/drivers/pnp/driver.c
+++ b/drivers/pnp/driver.c
@@ -214,6 +214,8 @@ int pnp_add_id(struct pnp_id *id, struct pnp_dev *dev)
 
 EXPORT_SYMBOL(pnp_register_driver);
 EXPORT_SYMBOL(pnp_unregister_driver);
+#if 0
 EXPORT_SYMBOL(pnp_add_id);
+#endif
 EXPORT_SYMBOL(pnp_device_attach);
 EXPORT_SYMBOL(pnp_device_detach);

commit e139aa595c5d3bd01699530cbe017dec75fdb07f
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Sep 6 15:17:05 2005 -0700

    [PATCH] PNP: make pnp_dbg conditional directly on CONFIG_PNP_DEBUG
    
    Seems pointless to require .c files to test CONFIG_PNP_DEBUG and
    conditionally define DEBUG before including <linux/pnp.h>.  Just test
    CONFIG_PNP_DEBUG directly in pnp.h.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Cc: Adam Belay <ambx1@neo.rr.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/pnp/driver.c b/drivers/pnp/driver.c
index 1d037c2a82ac..33da25f3213f 100644
--- a/drivers/pnp/driver.c
+++ b/drivers/pnp/driver.c
@@ -11,13 +11,6 @@
 #include <linux/module.h>
 #include <linux/ctype.h>
 #include <linux/slab.h>
-
-#ifdef CONFIG_PNP_DEBUG
-	#define DEBUG
-#else
-	#undef DEBUG
-#endif
-
 #include <linux/pnp.h>
 #include "base.h"
 

commit 8d618afdd61ccaacbab4976a556c0ddcf36e2d8a
Author: mochel@digitalimplant.org <mochel@digitalimplant.org>
Date:   Mon Mar 21 11:07:54 2005 -0800

    [PATCH] Use driver_for_each_device() in drivers/pnp/driver.c instead of manually walking list.
    
    Signed-off-by: Patrick Mochel <mochel@digitalimplant.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    
    diff -Nru a/drivers/pnp/driver.c b/drivers/pnp/driver.c

diff --git a/drivers/pnp/driver.c b/drivers/pnp/driver.c
index d64c1ca4fa76..1d037c2a82ac 100644
--- a/drivers/pnp/driver.c
+++ b/drivers/pnp/driver.c
@@ -160,10 +160,16 @@ struct bus_type pnp_bus_type = {
 };
 
 
+static int count_devices(struct device * dev, void * c)
+{
+	int * count = c;
+	(*count)++;
+	return 0;
+}
+
 int pnp_register_driver(struct pnp_driver *drv)
 {
 	int count;
-	struct list_head *pos;
 
 	pnp_dbg("the driver '%s' has been registered", drv->name);
 
@@ -177,9 +183,7 @@ int pnp_register_driver(struct pnp_driver *drv)
 	/* get the number of initial matches */
 	if (count >= 0){
 		count = 0;
-		list_for_each(pos,&drv->driver.devices){
-			count++;
-		}
+		driver_for_each_device(&drv->driver, NULL, &count, count_devices);
 	}
 	return count;
 }

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/pnp/driver.c b/drivers/pnp/driver.c
new file mode 100644
index 000000000000..d64c1ca4fa76
--- /dev/null
+++ b/drivers/pnp/driver.c
@@ -0,0 +1,222 @@
+/*
+ * driver.c - device id matching, driver model, etc.
+ *
+ * Copyright 2002 Adam Belay <ambx1@neo.rr.com>
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/string.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/ctype.h>
+#include <linux/slab.h>
+
+#ifdef CONFIG_PNP_DEBUG
+	#define DEBUG
+#else
+	#undef DEBUG
+#endif
+
+#include <linux/pnp.h>
+#include "base.h"
+
+static int compare_func(const char *ida, const char *idb)
+{
+	int i;
+	/* we only need to compare the last 4 chars */
+	for (i=3; i<7; i++)
+	{
+		if (ida[i] != 'X' &&
+		    idb[i] != 'X' &&
+		    toupper(ida[i]) != toupper(idb[i]))
+			return 0;
+	}
+	return 1;
+}
+
+int compare_pnp_id(struct pnp_id *pos, const char *id)
+{
+	if (!pos || !id || (strlen(id) != 7))
+		return 0;
+	if (memcmp(id,"ANYDEVS",7)==0)
+		return 1;
+	while (pos){
+		if (memcmp(pos->id,id,3)==0)
+			if (compare_func(pos->id,id)==1)
+				return 1;
+		pos = pos->next;
+	}
+	return 0;
+}
+
+static const struct pnp_device_id * match_device(struct pnp_driver *drv, struct pnp_dev *dev)
+{
+	const struct pnp_device_id *drv_id = drv->id_table;
+	if (!drv_id)
+		return NULL;
+
+	while (*drv_id->id) {
+		if (compare_pnp_id(dev->id, drv_id->id))
+			return drv_id;
+		drv_id++;
+	}
+	return NULL;
+}
+
+int pnp_device_attach(struct pnp_dev *pnp_dev)
+{
+	spin_lock(&pnp_lock);
+	if(pnp_dev->status != PNP_READY){
+		spin_unlock(&pnp_lock);
+		return -EBUSY;
+	}
+	pnp_dev->status = PNP_ATTACHED;
+	spin_unlock(&pnp_lock);
+	return 0;
+}
+
+void pnp_device_detach(struct pnp_dev *pnp_dev)
+{
+	spin_lock(&pnp_lock);
+	if (pnp_dev->status == PNP_ATTACHED)
+		pnp_dev->status = PNP_READY;
+	spin_unlock(&pnp_lock);
+	pnp_disable_dev(pnp_dev);
+}
+
+static int pnp_device_probe(struct device *dev)
+{
+	int error;
+	struct pnp_driver *pnp_drv;
+	struct pnp_dev *pnp_dev;
+	const struct pnp_device_id *dev_id = NULL;
+	pnp_dev = to_pnp_dev(dev);
+	pnp_drv = to_pnp_driver(dev->driver);
+
+	pnp_dbg("match found with the PnP device '%s' and the driver '%s'", dev->bus_id,pnp_drv->name);
+
+	error = pnp_device_attach(pnp_dev);
+	if (error < 0)
+		return error;
+
+	if (pnp_dev->active == 0) {
+		if (!(pnp_drv->flags & PNP_DRIVER_RES_DO_NOT_CHANGE)) {
+			error = pnp_activate_dev(pnp_dev);
+			if (error < 0)
+				return error;
+		}
+	} else if ((pnp_drv->flags & PNP_DRIVER_RES_DISABLE)
+		    == PNP_DRIVER_RES_DISABLE) {
+		error = pnp_disable_dev(pnp_dev);
+		if (error < 0)
+			return error;
+	}
+	error = 0;
+	if (pnp_drv->probe) {
+		dev_id = match_device(pnp_drv, pnp_dev);
+		if (dev_id != NULL)
+			error = pnp_drv->probe(pnp_dev, dev_id);
+	}
+	if (error >= 0){
+		pnp_dev->driver = pnp_drv;
+		error = 0;
+	} else
+		goto fail;
+	return error;
+
+fail:
+	pnp_device_detach(pnp_dev);
+	return error;
+}
+
+static int pnp_device_remove(struct device *dev)
+{
+	struct pnp_dev * pnp_dev = to_pnp_dev(dev);
+	struct pnp_driver * drv = pnp_dev->driver;
+
+	if (drv) {
+		if (drv->remove)
+			drv->remove(pnp_dev);
+		pnp_dev->driver = NULL;
+	}
+	pnp_device_detach(pnp_dev);
+	return 0;
+}
+
+static int pnp_bus_match(struct device *dev, struct device_driver *drv)
+{
+	struct pnp_dev * pnp_dev = to_pnp_dev(dev);
+	struct pnp_driver * pnp_drv = to_pnp_driver(drv);
+	if (match_device(pnp_drv, pnp_dev) == NULL)
+		return 0;
+	return 1;
+}
+
+
+struct bus_type pnp_bus_type = {
+	.name	= "pnp",
+	.match	= pnp_bus_match,
+};
+
+
+int pnp_register_driver(struct pnp_driver *drv)
+{
+	int count;
+	struct list_head *pos;
+
+	pnp_dbg("the driver '%s' has been registered", drv->name);
+
+	drv->driver.name = drv->name;
+	drv->driver.bus = &pnp_bus_type;
+	drv->driver.probe = pnp_device_probe;
+	drv->driver.remove = pnp_device_remove;
+
+	count = driver_register(&drv->driver);
+
+	/* get the number of initial matches */
+	if (count >= 0){
+		count = 0;
+		list_for_each(pos,&drv->driver.devices){
+			count++;
+		}
+	}
+	return count;
+}
+
+void pnp_unregister_driver(struct pnp_driver *drv)
+{
+	driver_unregister(&drv->driver);
+	pnp_dbg("the driver '%s' has been unregistered", drv->name);
+}
+
+/**
+ * pnp_add_id - adds an EISA id to the specified device
+ * @id: pointer to a pnp_id structure
+ * @dev: pointer to the desired device
+ *
+ */
+
+int pnp_add_id(struct pnp_id *id, struct pnp_dev *dev)
+{
+	struct pnp_id *ptr;
+	if (!id)
+		return -EINVAL;
+	if (!dev)
+		return -EINVAL;
+	id->next = NULL;
+	ptr = dev->id;
+	while (ptr && ptr->next)
+		ptr = ptr->next;
+	if (ptr)
+		ptr->next = id;
+	else
+		dev->id = id;
+	return 0;
+}
+
+EXPORT_SYMBOL(pnp_register_driver);
+EXPORT_SYMBOL(pnp_unregister_driver);
+EXPORT_SYMBOL(pnp_add_id);
+EXPORT_SYMBOL(pnp_device_attach);
+EXPORT_SYMBOL(pnp_device_detach);
