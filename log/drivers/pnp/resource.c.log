commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pnp/resource.c b/drivers/pnp/resource.c
index f980ff7166e9..70d4ba95735a 100644
--- a/drivers/pnp/resource.c
+++ b/drivers/pnp/resource.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * resource.c - Contains functions for registering and analyzing resource information
  *

commit eeeb98bf06286380f74fc0d39df643c50fd056e5
Author: Jakub Sitnicki <jsitnicki@gmail.com>
Date:   Mon Dec 8 22:01:57 2014 +0100

    PNP: Switch from __check_region() to __request_region()
    
    PNP core is the last user of the __check_region() which has been
    deprecated for almost 12 years (since v2.5.54). Replace it with a combo
    of __request_region() followed by __release_region().
    
    pnp_check_port() and pnp_check_mem() remain racy after this change.
    
    Signed-off-by: Jakub Sitnicki <jsitnicki@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pnp/resource.c b/drivers/pnp/resource.c
index 782e82289571..f980ff7166e9 100644
--- a/drivers/pnp/resource.c
+++ b/drivers/pnp/resource.c
@@ -179,8 +179,9 @@ int pnp_check_port(struct pnp_dev *dev, struct resource *res)
 	/* check if the resource is already in use, skip if the
 	 * device is active because it itself may be in use */
 	if (!dev->active) {
-		if (__check_region(&ioport_resource, *port, length(port, end)))
+		if (!request_region(*port, length(port, end), "pnp"))
 			return 0;
+		release_region(*port, length(port, end));
 	}
 
 	/* check if the resource is reserved */
@@ -241,8 +242,9 @@ int pnp_check_mem(struct pnp_dev *dev, struct resource *res)
 	/* check if the resource is already in use, skip if the
 	 * device is active because it itself may be in use */
 	if (!dev->active) {
-		if (check_mem_region(*addr, length(addr, end)))
+		if (!request_mem_region(*addr, length(addr, end), "pnp"))
 			return 0;
+		release_mem_region(*addr, length(addr, end));
 	}
 
 	/* check if the resource is reserved */

commit ff73b80d64bb2d3324ae85c3b7e953a0a17d7171
Author: Fabian Frederick <fabf@skynet.be>
Date:   Sat May 10 12:47:15 2014 +0200

    PNP / resources: remove positive test on unsigned values
    
    irq and dma are both resource_size_t (derived from phys_addr_t <-> unsigned)
    
    Signed-off-by: Fabian Frederick <fabf@skynet.be>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pnp/resource.c b/drivers/pnp/resource.c
index 01712cbfd92e..782e82289571 100644
--- a/drivers/pnp/resource.c
+++ b/drivers/pnp/resource.c
@@ -360,7 +360,7 @@ int pnp_check_irq(struct pnp_dev *dev, struct resource *res)
 		return 1;
 
 	/* check if the resource is valid */
-	if (*irq < 0 || *irq > 15)
+	if (*irq > 15)
 		return 0;
 
 	/* check if the resource is reserved */
@@ -424,7 +424,7 @@ int pnp_check_dma(struct pnp_dev *dev, struct resource *res)
 		return 1;
 
 	/* check if the resource is valid */
-	if (*dma < 0 || *dma == 4 || *dma > 7)
+	if (*dma == 4 || *dma > 7)
 		return 0;
 
 	/* check if the resource is reserved */

commit e1563769f7b4494c5f789c689495c1e90a0d4bfc
Author: Michael Opdenacker <michael.opdenacker@free-electrons.com>
Date:   Fri Mar 21 01:10:28 2014 +0100

    PNP: remove deprecated IRQF_DISABLED
    
    This patch removes the use of the IRQF_DISABLED flag
    from drivers/pnp/resource.c
    
    It's a NOOP since 2.6.35 and it will be removed one day.
    
    Signed-off-by: Michael Opdenacker <michael.opdenacker@free-electrons.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pnp/resource.c b/drivers/pnp/resource.c
index bacddd102ae9..01712cbfd92e 100644
--- a/drivers/pnp/resource.c
+++ b/drivers/pnp/resource.c
@@ -385,7 +385,7 @@ int pnp_check_irq(struct pnp_dev *dev, struct resource *res)
 	 * device is active because it itself may be in use */
 	if (!dev->active) {
 		if (request_irq(*irq, pnp_test_handler,
-				IRQF_DISABLED | IRQF_PROBE_SHARED, "pnp", NULL))
+				IRQF_PROBE_SHARED, "pnp", NULL))
 			return 0;
 		free_irq(*irq, NULL);
 	}

commit 62c6dae02d4fe2bfa6bc699ae456ff1c50d10bd0
Author: Rashika Kheria <rashika.kheria@gmail.com>
Date:   Sat Dec 14 18:50:56 2013 +0530

    PNP: Mark the function pnp_build_option() as static in resource.c
    
    This patch marks the function pnp_build_option() as static in resource.c
    because it is not used outside this file.
    
    Thus, it also eliminates the following warning in resource.c:
    drivers/pnp/resource.c:34:20: warning: no previous prototype for ‘pnp_build_option’ [-Wmissing-prototypes]
    
    Signed-off-by: Rashika Kheria <rashika.kheria@gmail.com>
    Reviewed-by: Josh Triplett <josh@joshtriplett.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pnp/resource.c b/drivers/pnp/resource.c
index d95e101ffb43..bacddd102ae9 100644
--- a/drivers/pnp/resource.c
+++ b/drivers/pnp/resource.c
@@ -31,7 +31,7 @@ static int pnp_reserve_mem[16] = {[0 ... 15] = -1 };	/* reserve (don't use) some
  * option registration
  */
 
-struct pnp_option *pnp_build_option(struct pnp_dev *dev, unsigned long type,
+static struct pnp_option *pnp_build_option(struct pnp_dev *dev, unsigned long type,
 				    unsigned int option_flags)
 {
 	struct pnp_option *option;

commit 3c0fc0710185e618a661528eed2183102e25c2f8
Author: Liu ShuoX <shuox.liu@intel.com>
Date:   Tue Jul 16 16:23:44 2013 +0800

    PNP / ACPI: avoid garbage in resource name
    
    Set temporary variable as 0 to avoid garbage string output from
    /proc/iomem after register resources and reset to PNP dev name
    later.
    
    Signed-off-by: Liu ShuoX <shuox.liu@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pnp/resource.c b/drivers/pnp/resource.c
index 3e6db1c1dc29..d95e101ffb43 100644
--- a/drivers/pnp/resource.c
+++ b/drivers/pnp/resource.c
@@ -515,6 +515,7 @@ struct pnp_resource *pnp_add_resource(struct pnp_dev *dev,
 	}
 
 	pnp_res->res = *res;
+	pnp_res->res.name = dev->name;
 	dev_dbg(&dev->dev, "%pR\n", res);
 	return pnp_res;
 }

commit 046d9ce6820e99087e81511284045eada94950e8
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Nov 15 00:30:01 2012 +0100

    ACPI: Move device resources interpretation code from PNP to ACPI core
    
    Move some code used for parsing ACPI device resources from the PNP
    subsystem to the ACPI core, so that other bus types (platform, SPI,
    I2C) can use the same routines for parsing resources in a consistent
    way, without duplicating code.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/pnp/resource.c b/drivers/pnp/resource.c
index b0ecacbe53b1..3e6db1c1dc29 100644
--- a/drivers/pnp/resource.c
+++ b/drivers/pnp/resource.c
@@ -503,6 +503,22 @@ static struct pnp_resource *pnp_new_resource(struct pnp_dev *dev)
 	return pnp_res;
 }
 
+struct pnp_resource *pnp_add_resource(struct pnp_dev *dev,
+				      struct resource *res)
+{
+	struct pnp_resource *pnp_res;
+
+	pnp_res = pnp_new_resource(dev);
+	if (!pnp_res) {
+		dev_err(&dev->dev, "can't add resource %pR\n", res);
+		return NULL;
+	}
+
+	pnp_res->res = *res;
+	dev_dbg(&dev->dev, "%pR\n", res);
+	return pnp_res;
+}
+
 struct pnp_resource *pnp_add_irq_resource(struct pnp_dev *dev, int irq,
 					  int flags)
 {

commit 586f83e2b4c080073b115c1a0fcc2757f52839b8
Author: David Rientjes <rientjes@google.com>
Date:   Tue Mar 22 16:34:56 2011 -0700

    pnp: only assign IORESOURCE_DMA if CONFIG_ISA_DMA_API is enabled
    
    IORESOURCE_DMA cannot be assigned without utilizing the interface
    provided by CONFIG_ISA_DMA_API, specifically request_dma() and
    free_dma().  Thus, there's a strict dependency on the config option and
    limits IORESOURCE_DMA only to architectures that support ISA-style DMA.
    
    ia64 is not one of those architectures, so pnp_check_dma() no longer
    needs to be special-cased for that architecture.
    
    pnp_assign_resources() will now return -EINVAL if IORESOURCE_DMA is
    attempted on such a kernel.
    
    Signed-off-by: David Rientjes <rientjes@google.com>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: "Luck, Tony" <tony.luck@intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pnp/resource.c b/drivers/pnp/resource.c
index a925e6b63d72..b0ecacbe53b1 100644
--- a/drivers/pnp/resource.c
+++ b/drivers/pnp/resource.c
@@ -409,9 +409,9 @@ int pnp_check_irq(struct pnp_dev *dev, struct resource *res)
 	return 1;
 }
 
+#ifdef CONFIG_ISA_DMA_API
 int pnp_check_dma(struct pnp_dev *dev, struct resource *res)
 {
-#ifndef CONFIG_IA64
 	int i;
 	struct pnp_dev *tdev;
 	struct resource *tres;
@@ -466,11 +466,8 @@ int pnp_check_dma(struct pnp_dev *dev, struct resource *res)
 	}
 
 	return 1;
-#else
-	/* IA64 does not have legacy DMA */
-	return 0;
-#endif
 }
+#endif /* CONFIG_ISA_DMA_API */
 
 unsigned long pnp_resource_type(struct resource *res)
 {

commit c1f3f2819667a238585c65bba96c8b16af39a442
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Wed Sep 29 12:24:23 2010 -0600

    PNP: log PNP resources, as we do for PCI
    
    ACPI devices are often involved in address space conflicts with PCI devices,
    so I think it's worth logging the resources they use.  Otherwise we have to
    depend on lspnp or groping around in sysfs to find them.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/resource.c b/drivers/pnp/resource.c
index e3446ab8b563..a925e6b63d72 100644
--- a/drivers/pnp/resource.c
+++ b/drivers/pnp/resource.c
@@ -523,7 +523,7 @@ struct pnp_resource *pnp_add_irq_resource(struct pnp_dev *dev, int irq,
 	res->start = irq;
 	res->end = irq;
 
-	pnp_dbg(&dev->dev, "  add %pr\n", res);
+	dev_printk(KERN_DEBUG, &dev->dev, "%pR\n", res);
 	return pnp_res;
 }
 
@@ -544,7 +544,7 @@ struct pnp_resource *pnp_add_dma_resource(struct pnp_dev *dev, int dma,
 	res->start = dma;
 	res->end = dma;
 
-	pnp_dbg(&dev->dev, "  add %pr\n", res);
+	dev_printk(KERN_DEBUG, &dev->dev, "%pR\n", res);
 	return pnp_res;
 }
 
@@ -568,7 +568,7 @@ struct pnp_resource *pnp_add_io_resource(struct pnp_dev *dev,
 	res->start = start;
 	res->end = end;
 
-	pnp_dbg(&dev->dev, "  add %pr\n", res);
+	dev_printk(KERN_DEBUG, &dev->dev, "%pR\n", res);
 	return pnp_res;
 }
 
@@ -592,7 +592,7 @@ struct pnp_resource *pnp_add_mem_resource(struct pnp_dev *dev,
 	res->start = start;
 	res->end = end;
 
-	pnp_dbg(&dev->dev, "  add %pr\n", res);
+	dev_printk(KERN_DEBUG, &dev->dev, "%pR\n", res);
 	return pnp_res;
 }
 
@@ -616,7 +616,7 @@ struct pnp_resource *pnp_add_bus_resource(struct pnp_dev *dev,
 	res->start = start;
 	res->end = end;
 
-	pnp_dbg(&dev->dev, "  add %pr\n", res);
+	dev_printk(KERN_DEBUG, &dev->dev, "%pR\n", res);
 	return pnp_res;
 }
 

commit 11439a6fd90b4861df64b4f983726e1c54977ab7
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon May 3 10:47:21 2010 -0600

    PNP: don't check for conflicts with bridge windows
    
    With fa35b4926, I broke a lot of PNP resource assignment.  That commit made
    PNPACPI include bridge windows as PNP resources, and PNP resource assignment
    treats any enabled overlapping PNP resources as conflicts.  Since PCI host
    bridge windows typically include most of the I/O port space, this makes PNP
    port assigments fail.
    
    The PCI host bridge driver will eventually use those PNP window resources,
    so we should make PNP ignore them when checking for conflicts.
    
    This fixes https://bugzilla.kernel.org/show_bug.cgi?id=15903
    
    Reported-and-tested-by: Pavel Kysilka <goldenfish@linuxsoft.cz>
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/resource.c b/drivers/pnp/resource.c
index 2e54e6a23c72..e3446ab8b563 100644
--- a/drivers/pnp/resource.c
+++ b/drivers/pnp/resource.c
@@ -211,6 +211,8 @@ int pnp_check_port(struct pnp_dev *dev, struct resource *res)
 			if (tres->flags & IORESOURCE_IO) {
 				if (cannot_compare(tres->flags))
 					continue;
+				if (tres->flags & IORESOURCE_WINDOW)
+					continue;
 				tport = &tres->start;
 				tend = &tres->end;
 				if (ranged_conflict(port, end, tport, tend))
@@ -271,6 +273,8 @@ int pnp_check_mem(struct pnp_dev *dev, struct resource *res)
 			if (tres->flags & IORESOURCE_MEM) {
 				if (cannot_compare(tres->flags))
 					continue;
+				if (tres->flags & IORESOURCE_WINDOW)
+					continue;
 				taddr = &tres->start;
 				tend = &tres->end;
 				if (ranged_conflict(addr, end, taddr, tend))

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/pnp/resource.c b/drivers/pnp/resource.c
index 5b277dbaacde..2e54e6a23c72 100644
--- a/drivers/pnp/resource.c
+++ b/drivers/pnp/resource.c
@@ -8,6 +8,7 @@
  */
 
 #include <linux/module.h>
+#include <linux/slab.h>
 #include <linux/errno.h>
 #include <linux/interrupt.h>
 #include <linux/kernel.h>

commit 7e0e9c042790d4ea44c6a00ddaad8b8bbcc3f17f
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Fri Mar 5 10:47:57 2010 -0700

    PNPACPI: add bus number support
    
    Add support for bus number resources.  This is for bridges with a range of
    bus numbers behind them.  Previously, PNP ignored bus number resources.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/resource.c b/drivers/pnp/resource.c
index 64d0596bafb5..5b277dbaacde 100644
--- a/drivers/pnp/resource.c
+++ b/drivers/pnp/resource.c
@@ -470,7 +470,8 @@ int pnp_check_dma(struct pnp_dev *dev, struct resource *res)
 unsigned long pnp_resource_type(struct resource *res)
 {
 	return res->flags & (IORESOURCE_IO  | IORESOURCE_MEM |
-			     IORESOURCE_IRQ | IORESOURCE_DMA);
+			     IORESOURCE_IRQ | IORESOURCE_DMA |
+			     IORESOURCE_BUS);
 }
 
 struct resource *pnp_get_resource(struct pnp_dev *dev,
@@ -590,6 +591,30 @@ struct pnp_resource *pnp_add_mem_resource(struct pnp_dev *dev,
 	return pnp_res;
 }
 
+struct pnp_resource *pnp_add_bus_resource(struct pnp_dev *dev,
+					  resource_size_t start,
+					  resource_size_t end)
+{
+	struct pnp_resource *pnp_res;
+	struct resource *res;
+
+	pnp_res = pnp_new_resource(dev);
+	if (!pnp_res) {
+		dev_err(&dev->dev, "can't add resource for BUS %#llx-%#llx\n",
+			(unsigned long long) start,
+			(unsigned long long) end);
+		return NULL;
+	}
+
+	res = &pnp_res->res;
+	res->flags = IORESOURCE_BUS;
+	res->start = start;
+	res->end = end;
+
+	pnp_dbg(&dev->dev, "  add %pr\n", res);
+	return pnp_res;
+}
+
 /*
  * Determine whether the specified resource is a possible configuration
  * for this device.

commit c7dabef8a2c59e6a3de9d66fc35fb6a43ef7172d
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Oct 27 13:26:47 2009 -0600

    vsprintf: use %pR, %pr instead of %pRt, %pRf
    
    Jesse accidentally applied v1 [1] of the patchset instead of v2 [2].  This
    is the diff between v1 and v2.
    
    The changes in this patch are:
        - tidied vsprintf stack buffer to shrink and compute size more
          accurately
        - use %pR for decoding and %pr for "raw" (with type and flags) instead
          of adding %pRt and %pRf
    
    [1] http://lkml.org/lkml/2009/10/6/491
    [2] http://lkml.org/lkml/2009/10/13/441
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pnp/resource.c b/drivers/pnp/resource.c
index 18557d7bb0b9..64d0596bafb5 100644
--- a/drivers/pnp/resource.c
+++ b/drivers/pnp/resource.c
@@ -517,7 +517,7 @@ struct pnp_resource *pnp_add_irq_resource(struct pnp_dev *dev, int irq,
 	res->start = irq;
 	res->end = irq;
 
-	pnp_dbg(&dev->dev, "  add %pRf\n", res);
+	pnp_dbg(&dev->dev, "  add %pr\n", res);
 	return pnp_res;
 }
 
@@ -538,7 +538,7 @@ struct pnp_resource *pnp_add_dma_resource(struct pnp_dev *dev, int dma,
 	res->start = dma;
 	res->end = dma;
 
-	pnp_dbg(&dev->dev, "  add %pRf\n", res);
+	pnp_dbg(&dev->dev, "  add %pr\n", res);
 	return pnp_res;
 }
 
@@ -562,7 +562,7 @@ struct pnp_resource *pnp_add_io_resource(struct pnp_dev *dev,
 	res->start = start;
 	res->end = end;
 
-	pnp_dbg(&dev->dev, "  add %pRf\n", res);
+	pnp_dbg(&dev->dev, "  add %pr\n", res);
 	return pnp_res;
 }
 
@@ -586,7 +586,7 @@ struct pnp_resource *pnp_add_mem_resource(struct pnp_dev *dev,
 	res->start = start;
 	res->end = end;
 
-	pnp_dbg(&dev->dev, "  add %pRf\n", res);
+	pnp_dbg(&dev->dev, "  add %pr\n", res);
 	return pnp_res;
 }
 

commit 9a007b3791cdba3601d835ea10e68c14115b9afb
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Oct 6 15:34:00 2009 -0600

    PNP: print resources consistently with %pRt
    
    This uses %pRt and %pRf to print additional resource information (type,
    size, prefetchability, etc.) consistently.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pnp/resource.c b/drivers/pnp/resource.c
index ba9765427886..18557d7bb0b9 100644
--- a/drivers/pnp/resource.c
+++ b/drivers/pnp/resource.c
@@ -517,7 +517,7 @@ struct pnp_resource *pnp_add_irq_resource(struct pnp_dev *dev, int irq,
 	res->start = irq;
 	res->end = irq;
 
-	pnp_dbg(&dev->dev, "  add irq %d flags %#x\n", irq, flags);
+	pnp_dbg(&dev->dev, "  add %pRf\n", res);
 	return pnp_res;
 }
 
@@ -538,7 +538,7 @@ struct pnp_resource *pnp_add_dma_resource(struct pnp_dev *dev, int dma,
 	res->start = dma;
 	res->end = dma;
 
-	pnp_dbg(&dev->dev, "  add dma %d flags %#x\n", dma, flags);
+	pnp_dbg(&dev->dev, "  add %pRf\n", res);
 	return pnp_res;
 }
 
@@ -562,8 +562,7 @@ struct pnp_resource *pnp_add_io_resource(struct pnp_dev *dev,
 	res->start = start;
 	res->end = end;
 
-	pnp_dbg(&dev->dev, "  add io  %#llx-%#llx flags %#x\n",
-		(unsigned long long) start, (unsigned long long) end, flags);
+	pnp_dbg(&dev->dev, "  add %pRf\n", res);
 	return pnp_res;
 }
 
@@ -587,8 +586,7 @@ struct pnp_resource *pnp_add_mem_resource(struct pnp_dev *dev,
 	res->start = start;
 	res->end = end;
 
-	pnp_dbg(&dev->dev, "  add mem %#llx-%#llx flags %#x\n",
-		(unsigned long long) start, (unsigned long long) end, flags);
+	pnp_dbg(&dev->dev, "  add %pRf\n", res);
 	return pnp_res;
 }
 

commit 1b8e69662e1a086878bf930a6042daf7f8a076cc
Author: Bjorn Helgaas <bjorn.helgaas at hp.com>
Date:   Fri Jun 5 14:37:23 2009 +0000

    pnp: add PNP resource range checking function
    
    Add a PNP resource range check function, indicating whether a resource
    has been assigned to any device.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    [apw@canonical.com: fixed up exports et al]
    Signed-off-by: Andy Whitcroft <apw@canonical.com>
    Signed-off-by: Eric Anholt <eric@anholt.net>

diff --git a/drivers/pnp/resource.c b/drivers/pnp/resource.c
index f604061d2bb0..ba9765427886 100644
--- a/drivers/pnp/resource.c
+++ b/drivers/pnp/resource.c
@@ -638,6 +638,24 @@ int pnp_possible_config(struct pnp_dev *dev, int type, resource_size_t start,
 }
 EXPORT_SYMBOL(pnp_possible_config);
 
+int pnp_range_reserved(resource_size_t start, resource_size_t end)
+{
+	struct pnp_dev *dev;
+	struct pnp_resource *pnp_res;
+	resource_size_t *dev_start, *dev_end;
+
+	pnp_for_each_dev(dev) {
+		list_for_each_entry(pnp_res, &dev->resources, list) {
+			dev_start = &pnp_res->res.start;
+			dev_end   = &pnp_res->res.end;
+			if (ranged_conflict(&start, &end, dev_start, dev_end))
+				return 1;
+		}
+	}
+	return 0;
+}
+EXPORT_SYMBOL(pnp_range_reserved);
+
 /* format is: pnp_reserve_irq=irq1[,irq2] .... */
 static int __init pnp_setup_reserve_irq(char *str)
 {

commit 057316cc6a5b521b332a1d7ccc871cd60c904c74
Merge: 3e2dab9a1c2d 2515ddc6db8e
Author: Len Brown <len.brown@intel.com>
Date:   Wed Oct 22 23:57:26 2008 -0400

    Merge branch 'linus' into test
    
    Conflicts:
            MAINTAINERS
            arch/x86/kernel/acpi/boot.c
            arch/x86/kernel/acpi/sleep.c
            drivers/acpi/Kconfig
            drivers/pnp/Makefile
            drivers/pnp/quirks.c
    
    Signed-off-by: Len Brown <len.brown@intel.com>

commit b563cf59c4d67da7d671788a9848416bfa4180ab
Author: Rene Herman <rene.herman@keyaccess.nl>
Date:   Wed Oct 15 22:03:58 2008 -0700

    pnp: make the resource type an unsigned long
    
    PnP encodes the resource type directly as its struct resource->flags value
    which is an unsigned long.  Make it so...
    
    Signed-off-by: Rene Herman <rene.herman@gmail.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Acked-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Cc: Andi Kleen <andi@firstfloor.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pnp/resource.c b/drivers/pnp/resource.c
index 4cfe3a1efdfb..dbae23acdd5b 100644
--- a/drivers/pnp/resource.c
+++ b/drivers/pnp/resource.c
@@ -467,14 +467,14 @@ int pnp_check_dma(struct pnp_dev *dev, struct resource *res)
 #endif
 }
 
-int pnp_resource_type(struct resource *res)
+unsigned long pnp_resource_type(struct resource *res)
 {
 	return res->flags & (IORESOURCE_IO  | IORESOURCE_MEM |
 			     IORESOURCE_IRQ | IORESOURCE_DMA);
 }
 
 struct resource *pnp_get_resource(struct pnp_dev *dev,
-				  unsigned int type, unsigned int num)
+				  unsigned long type, unsigned int num)
 {
 	struct pnp_resource *pnp_res;
 	struct resource *res;

commit 2f53432c2aedbe79020e44525eb069d9138a01dd
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Aug 19 16:53:47 2008 -0600

    PNP: convert to using pnp_dbg()
    
    pnp_dbg() is equivalent to dev_dbg() except that we can turn it
    on at boot-time with the "pnp.debug" kernel parameter, so we don't
    have to build a new kernel image.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/resource.c b/drivers/pnp/resource.c
index e0206da6851a..5ef463d89f16 100644
--- a/drivers/pnp/resource.c
+++ b/drivers/pnp/resource.c
@@ -294,7 +294,7 @@ static int pci_dev_uses_irq(struct pnp_dev *pnp, struct pci_dev *pci,
 	u8 progif;
 
 	if (pci->irq == irq) {
-		dev_dbg(&pnp->dev, "  device %s using irq %d\n",
+		pnp_dbg(&pnp->dev, "  device %s using irq %d\n",
 			pci_name(pci), irq);
 		return 1;
 	}
@@ -316,7 +316,7 @@ static int pci_dev_uses_irq(struct pnp_dev *pnp, struct pci_dev *pci,
 		if ((progif & 0x5) != 0x5)
 			if (pci_get_legacy_ide_irq(pci, 0) == irq ||
 			    pci_get_legacy_ide_irq(pci, 1) == irq) {
-				dev_dbg(&pnp->dev, "  legacy IDE device %s "
+				pnp_dbg(&pnp->dev, "  legacy IDE device %s "
 					"using irq %d\n", pci_name(pci), irq);
 				return 1;
 			}
@@ -517,7 +517,7 @@ struct pnp_resource *pnp_add_irq_resource(struct pnp_dev *dev, int irq,
 	res->start = irq;
 	res->end = irq;
 
-	dev_dbg(&dev->dev, "  add irq %d flags %#x\n", irq, flags);
+	pnp_dbg(&dev->dev, "  add irq %d flags %#x\n", irq, flags);
 	return pnp_res;
 }
 
@@ -538,7 +538,7 @@ struct pnp_resource *pnp_add_dma_resource(struct pnp_dev *dev, int dma,
 	res->start = dma;
 	res->end = dma;
 
-	dev_dbg(&dev->dev, "  add dma %d flags %#x\n", dma, flags);
+	pnp_dbg(&dev->dev, "  add dma %d flags %#x\n", dma, flags);
 	return pnp_res;
 }
 
@@ -562,7 +562,7 @@ struct pnp_resource *pnp_add_io_resource(struct pnp_dev *dev,
 	res->start = start;
 	res->end = end;
 
-	dev_dbg(&dev->dev, "  add io  %#llx-%#llx flags %#x\n",
+	pnp_dbg(&dev->dev, "  add io  %#llx-%#llx flags %#x\n",
 		(unsigned long long) start, (unsigned long long) end, flags);
 	return pnp_res;
 }
@@ -587,7 +587,7 @@ struct pnp_resource *pnp_add_mem_resource(struct pnp_dev *dev,
 	res->start = start;
 	res->end = end;
 
-	dev_dbg(&dev->dev, "  add mem %#llx-%#llx flags %#x\n",
+	pnp_dbg(&dev->dev, "  add mem %#llx-%#llx flags %#x\n",
 		(unsigned long long) start, (unsigned long long) end, flags);
 	return pnp_res;
 }

commit 6a0b93bae96f292b6c091cce5abfb9a644e649e9
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Aug 19 16:53:16 2008 -0600

    PNP: fix debug formatting (cosmetic)
    
    This patch just fixes indentation of a couple debug messages.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/resource.c b/drivers/pnp/resource.c
index 4cfe3a1efdfb..e0206da6851a 100644
--- a/drivers/pnp/resource.c
+++ b/drivers/pnp/resource.c
@@ -294,7 +294,7 @@ static int pci_dev_uses_irq(struct pnp_dev *pnp, struct pci_dev *pci,
 	u8 progif;
 
 	if (pci->irq == irq) {
-		dev_dbg(&pnp->dev, "device %s using irq %d\n",
+		dev_dbg(&pnp->dev, "  device %s using irq %d\n",
 			pci_name(pci), irq);
 		return 1;
 	}
@@ -316,7 +316,7 @@ static int pci_dev_uses_irq(struct pnp_dev *pnp, struct pci_dev *pci,
 		if ((progif & 0x5) != 0x5)
 			if (pci_get_legacy_ide_irq(pci, 0) == irq ||
 			    pci_get_legacy_ide_irq(pci, 1) == irq) {
-				dev_dbg(&pnp->dev, "legacy IDE device %s "
+				dev_dbg(&pnp->dev, "  legacy IDE device %s "
 					"using irq %d\n", pci_name(pci), irq);
 				return 1;
 			}

commit 84684c7469a2e6fcbf8c808ac5030ba2de14ff77
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Fri Jun 27 16:57:18 2008 -0600

    PNP: avoid legacy IDE IRQs
    
    If an IDE controller is in compatibility mode, it expects to use
    IRQs 14 and 15, so PNP should avoid them.
    
    This patch should resolve this problem report:
      parallel driver grabs IRQ14 preventing legacy SFF ATA controller from working
      https://bugzilla.novell.com/show_bug.cgi?id=375836
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>
    Signed-off-by: Andi Kleen <ak@linux.intel.com>

diff --git a/drivers/pnp/resource.c b/drivers/pnp/resource.c
index d6388970a1a4..4cfe3a1efdfb 100644
--- a/drivers/pnp/resource.c
+++ b/drivers/pnp/resource.c
@@ -286,6 +286,61 @@ static irqreturn_t pnp_test_handler(int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
+#ifdef CONFIG_PCI
+static int pci_dev_uses_irq(struct pnp_dev *pnp, struct pci_dev *pci,
+			    unsigned int irq)
+{
+	u32 class;
+	u8 progif;
+
+	if (pci->irq == irq) {
+		dev_dbg(&pnp->dev, "device %s using irq %d\n",
+			pci_name(pci), irq);
+		return 1;
+	}
+
+	/*
+	 * See pci_setup_device() and ata_pci_sff_activate_host() for
+	 * similar IDE legacy detection.
+	 */
+	pci_read_config_dword(pci, PCI_CLASS_REVISION, &class);
+	class >>= 8;		/* discard revision ID */
+	progif = class & 0xff;
+	class >>= 8;
+
+	if (class == PCI_CLASS_STORAGE_IDE) {
+		/*
+		 * Unless both channels are native-PCI mode only,
+		 * treat the compatibility IRQs as busy.
+		 */
+		if ((progif & 0x5) != 0x5)
+			if (pci_get_legacy_ide_irq(pci, 0) == irq ||
+			    pci_get_legacy_ide_irq(pci, 1) == irq) {
+				dev_dbg(&pnp->dev, "legacy IDE device %s "
+					"using irq %d\n", pci_name(pci), irq);
+				return 1;
+			}
+	}
+
+	return 0;
+}
+#endif
+
+static int pci_uses_irq(struct pnp_dev *pnp, unsigned int irq)
+{
+#ifdef CONFIG_PCI
+	struct pci_dev *pci = NULL;
+
+	for_each_pci_dev(pci) {
+		if (pci_dev_uses_irq(pnp, pci, irq)) {
+			pci_dev_put(pci);
+			return 1;
+		}
+	}
+#endif
+	return 0;
+}
+
 int pnp_check_irq(struct pnp_dev *dev, struct resource *res)
 {
 	int i;
@@ -317,18 +372,9 @@ int pnp_check_irq(struct pnp_dev *dev, struct resource *res)
 		}
 	}
 
-#ifdef CONFIG_PCI
 	/* check if the resource is being used by a pci device */
-	{
-		struct pci_dev *pci = NULL;
-		for_each_pci_dev(pci) {
-			if (pci->irq == *irq) {
-				pci_dev_put(pci);
-				return 0;
-			}
-		}
-	}
-#endif
+	if (pci_uses_irq(dev, *irq))
+		return 0;
 
 	/* check if the resource is already in use, skip if the
 	 * device is active because it itself may be in use */

commit 1f32ca31e7409d37c1b25e5f81840fb184380cdf
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Fri Jun 27 16:57:17 2008 -0600

    PNP: convert resource options to single linked list
    
    ISAPNP, PNPBIOS, and ACPI describe the "possible resource settings" of
    a device, i.e., the possibilities an OS bus driver has when it assigns
    I/O port, MMIO, and other resources to the device.
    
    PNP used to maintain this "possible resource setting" information in
    one independent option structure and a list of dependent option
    structures for each device.  Each of these option structures had lists
    of I/O, memory, IRQ, and DMA resources, for example:
    
      dev
        independent options
          ind-io0  -> ind-io1  ...
          ind-mem0 -> ind-mem1 ...
          ...
        dependent option set 0
          dep0-io0  -> dep0-io1  ...
          dep0-mem0 -> dep0-mem1 ...
          ...
        dependent option set 1
          dep1-io0  -> dep1-io1  ...
          dep1-mem0 -> dep1-mem1 ...
          ...
        ...
    
    This data structure was designed for ISAPNP, where the OS configures
    device resource settings by writing directly to configuration
    registers.  The OS can write the registers in arbitrary order much
    like it writes PCI BARs.
    
    However, for PNPBIOS and ACPI devices, the OS uses firmware interfaces
    that perform device configuration, and it is important to pass the
    desired settings to those interfaces in the correct order.  The OS
    learns the correct order by using firmware interfaces that return the
    "current resource settings" and "possible resource settings," but the
    option structures above doesn't store the ordering information.
    
    This patch replaces the independent and dependent lists with a single
    list of options.  For example, a device might have possible resource
    settings like this:
    
      dev
        options
          ind-io0 -> dep0-io0 -> dep1->io0 -> ind-io1 ...
    
    All the possible settings are in the same list, in the order they
    come from the firmware "possible resource settings" list.  Each entry
    is tagged with an independent/dependent flag.  Dependent entries also
    have a "set number" and an optional priority value.  All dependent
    entries must be assigned from the same set.  For example, the OS can
    use all the entries from dependent set 0, or all the entries from
    dependent set 1, but it cannot mix entries from set 0 with entries
    from set 1.
    
    Prior to this patch PNP didn't keep track of the order of this list,
    and it assigned all independent options first, then all dependent
    ones.  Using the example above, that resulted in a "desired
    configuration" list like this:
    
      ind->io0 -> ind->io1 -> depN-io0 ...
    
    instead of the list the firmware expects, which looks like this:
    
      ind->io0 -> depN-io0 -> ind-io1 ...
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Acked-by: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/resource.c b/drivers/pnp/resource.c
index a795864dc695..d6388970a1a4 100644
--- a/drivers/pnp/resource.c
+++ b/drivers/pnp/resource.c
@@ -3,6 +3,8 @@
  *
  * based on isapnp.c resource management (c) Jaroslav Kysela <perex@perex.cz>
  * Copyright 2003 Adam Belay <ambx1@neo.rr.com>
+ * Copyright (C) 2008 Hewlett-Packard Development Company, L.P.
+ *	Bjorn Helgaas <bjorn.helgaas@hp.com>
  */
 
 #include <linux/module.h>
@@ -28,78 +30,36 @@ static int pnp_reserve_mem[16] = {[0 ... 15] = -1 };	/* reserve (don't use) some
  * option registration
  */
 
-struct pnp_option *pnp_build_option(int priority)
+struct pnp_option *pnp_build_option(struct pnp_dev *dev, unsigned long type,
+				    unsigned int option_flags)
 {
-	struct pnp_option *option = pnp_alloc(sizeof(struct pnp_option));
+	struct pnp_option *option;
 
+	option = kzalloc(sizeof(struct pnp_option), GFP_KERNEL);
 	if (!option)
 		return NULL;
 
-	option->priority = priority & 0xff;
-	/* make sure the priority is valid */
-	if (option->priority > PNP_RES_PRIORITY_FUNCTIONAL)
-		option->priority = PNP_RES_PRIORITY_INVALID;
-
-	return option;
-}
-
-struct pnp_option *pnp_register_independent_option(struct pnp_dev *dev)
-{
-	struct pnp_option *option;
-
-	option = pnp_build_option(PNP_RES_PRIORITY_PREFERRED);
-
-	/* this should never happen but if it does we'll try to continue */
-	if (dev->independent)
-		dev_err(&dev->dev, "independent resource already registered\n");
-	dev->independent = option;
-
-	dev_dbg(&dev->dev, "new independent option\n");
-	return option;
-}
-
-struct pnp_option *pnp_register_dependent_option(struct pnp_dev *dev,
-						 int priority)
-{
-	struct pnp_option *option;
+	option->flags = option_flags;
+	option->type = type;
 
-	option = pnp_build_option(priority);
-
-	if (dev->dependent) {
-		struct pnp_option *parent = dev->dependent;
-		while (parent->next)
-			parent = parent->next;
-		parent->next = option;
-	} else
-		dev->dependent = option;
-
-	dev_dbg(&dev->dev, "new dependent option (priority %#x)\n", priority);
+	list_add_tail(&option->list, &dev->options);
 	return option;
 }
 
-int pnp_register_irq_resource(struct pnp_dev *dev, struct pnp_option *option,
+int pnp_register_irq_resource(struct pnp_dev *dev, unsigned int option_flags,
 			      pnp_irq_mask_t *map, unsigned char flags)
 {
-	struct pnp_irq *irq, *ptr;
-#ifdef DEBUG
-	char buf[PNP_IRQ_NR];   /* hex-encoded, so this is overkill but safe */
-#endif
+	struct pnp_option *option;
+	struct pnp_irq *irq;
 
-	irq = kzalloc(sizeof(struct pnp_irq), GFP_KERNEL);
-	if (!irq)
+	option = pnp_build_option(dev, IORESOURCE_IRQ, option_flags);
+	if (!option)
 		return -ENOMEM;
 
+	irq = &option->u.irq;
 	irq->map = *map;
 	irq->flags = flags;
 
-	ptr = option->irq;
-	while (ptr && ptr->next)
-		ptr = ptr->next;
-	if (ptr)
-		ptr->next = irq;
-	else
-		option->irq = irq;
-
 #ifdef CONFIG_PCI
 	{
 		int i;
@@ -110,163 +70,81 @@ int pnp_register_irq_resource(struct pnp_dev *dev, struct pnp_option *option,
 	}
 #endif
 
-#ifdef DEBUG
-	bitmap_scnprintf(buf, sizeof(buf), irq->map.bits, PNP_IRQ_NR);
-	dev_dbg(&dev->dev, "  irq bitmask %s flags %#x\n", buf,
-		irq->flags);
-#endif
+	dbg_pnp_show_option(dev, option);
 	return 0;
 }
 
-int pnp_register_dma_resource(struct pnp_dev *dev, struct pnp_option *option,
+int pnp_register_dma_resource(struct pnp_dev *dev, unsigned int option_flags,
 			      unsigned char map, unsigned char flags)
 {
-	struct pnp_dma *dma, *ptr;
+	struct pnp_option *option;
+	struct pnp_dma *dma;
 
-	dma = kzalloc(sizeof(struct pnp_dma), GFP_KERNEL);
-	if (!dma)
+	option = pnp_build_option(dev, IORESOURCE_DMA, option_flags);
+	if (!option)
 		return -ENOMEM;
 
+	dma = &option->u.dma;
 	dma->map = map;
 	dma->flags = flags;
 
-	ptr = option->dma;
-	while (ptr && ptr->next)
-		ptr = ptr->next;
-	if (ptr)
-		ptr->next = dma;
-	else
-		option->dma = dma;
-
-	dev_dbg(&dev->dev, "  dma bitmask %#x flags %#x\n", dma->map,
-		dma->flags);
+	dbg_pnp_show_option(dev, option);
 	return 0;
 }
 
-int pnp_register_port_resource(struct pnp_dev *dev, struct pnp_option *option,
+int pnp_register_port_resource(struct pnp_dev *dev, unsigned int option_flags,
 			       resource_size_t min, resource_size_t max,
 			       resource_size_t align, resource_size_t size,
 			       unsigned char flags)
 {
-	struct pnp_port *port, *ptr;
+	struct pnp_option *option;
+	struct pnp_port *port;
 
-	port = kzalloc(sizeof(struct pnp_port), GFP_KERNEL);
-	if (!port)
+	option = pnp_build_option(dev, IORESOURCE_IO, option_flags);
+	if (!option)
 		return -ENOMEM;
 
+	port = &option->u.port;
 	port->min = min;
 	port->max = max;
 	port->align = align;
 	port->size = size;
 	port->flags = flags;
 
-	ptr = option->port;
-	while (ptr && ptr->next)
-		ptr = ptr->next;
-	if (ptr)
-		ptr->next = port;
-	else
-		option->port = port;
-
-	dev_dbg(&dev->dev, "  io  "
-		"min %#llx max %#llx align %lld size %lld flags %#x\n",
-		(unsigned long long) port->min,
-		(unsigned long long) port->max,
-		(unsigned long long) port->align,
-		(unsigned long long) port->size, port->flags);
+	dbg_pnp_show_option(dev, option);
 	return 0;
 }
 
-int pnp_register_mem_resource(struct pnp_dev *dev, struct pnp_option *option,
+int pnp_register_mem_resource(struct pnp_dev *dev, unsigned int option_flags,
 			      resource_size_t min, resource_size_t max,
 			      resource_size_t align, resource_size_t size,
 			      unsigned char flags)
 {
-	struct pnp_mem *mem, *ptr;
+	struct pnp_option *option;
+	struct pnp_mem *mem;
 
-	mem = kzalloc(sizeof(struct pnp_mem), GFP_KERNEL);
-	if (!mem)
+	option = pnp_build_option(dev, IORESOURCE_MEM, option_flags);
+	if (!option)
 		return -ENOMEM;
 
+	mem = &option->u.mem;
 	mem->min = min;
 	mem->max = max;
 	mem->align = align;
 	mem->size = size;
 	mem->flags = flags;
 
-	ptr = option->mem;
-	while (ptr && ptr->next)
-		ptr = ptr->next;
-	if (ptr)
-		ptr->next = mem;
-	else
-		option->mem = mem;
-
-	dev_dbg(&dev->dev, "  mem "
-		"min %#llx max %#llx align %lld size %lld flags %#x\n",
-		(unsigned long long) mem->min,
-		(unsigned long long) mem->max,
-		(unsigned long long) mem->align,
-		(unsigned long long) mem->size, mem->flags);
+	dbg_pnp_show_option(dev, option);
 	return 0;
 }
 
-static void pnp_free_port(struct pnp_port *port)
-{
-	struct pnp_port *next;
-
-	while (port) {
-		next = port->next;
-		kfree(port);
-		port = next;
-	}
-}
-
-static void pnp_free_irq(struct pnp_irq *irq)
-{
-	struct pnp_irq *next;
-
-	while (irq) {
-		next = irq->next;
-		kfree(irq);
-		irq = next;
-	}
-}
-
-static void pnp_free_dma(struct pnp_dma *dma)
-{
-	struct pnp_dma *next;
-
-	while (dma) {
-		next = dma->next;
-		kfree(dma);
-		dma = next;
-	}
-}
-
-static void pnp_free_mem(struct pnp_mem *mem)
+void pnp_free_options(struct pnp_dev *dev)
 {
-	struct pnp_mem *next;
-
-	while (mem) {
-		next = mem->next;
-		kfree(mem);
-		mem = next;
-	}
-}
+	struct pnp_option *option, *tmp;
 
-void pnp_free_option(struct pnp_option *option)
-{
-	struct pnp_option *next;
-
-	while (option) {
-		next = option->next;
-		pnp_free_port(option->port);
-		pnp_free_irq(option->irq);
-		pnp_free_dma(option->dma);
-		pnp_free_mem(option->mem);
+	list_for_each_entry_safe(option, tmp, &dev->options, list) {
+		list_del(&option->list);
 		kfree(option);
-		option = next;
 	}
 }
 
@@ -668,66 +546,50 @@ struct pnp_resource *pnp_add_mem_resource(struct pnp_dev *dev,
 	return pnp_res;
 }
 
-static int pnp_possible_option(struct pnp_option *option, int type,
-			       resource_size_t start, resource_size_t size)
+/*
+ * Determine whether the specified resource is a possible configuration
+ * for this device.
+ */
+int pnp_possible_config(struct pnp_dev *dev, int type, resource_size_t start,
+			resource_size_t size)
 {
-	struct pnp_option *tmp;
+	struct pnp_option *option;
 	struct pnp_port *port;
 	struct pnp_mem *mem;
 	struct pnp_irq *irq;
 	struct pnp_dma *dma;
 
-	if (!option)
-		return 0;
+	list_for_each_entry(option, &dev->options, list) {
+		if (option->type != type)
+			continue;
 
-	for (tmp = option; tmp; tmp = tmp->next) {
-		switch (type) {
+		switch (option->type) {
 		case IORESOURCE_IO:
-			for (port = tmp->port; port; port = port->next) {
-				if (port->min == start && port->size == size)
-					return 1;
-			}
+			port = &option->u.port;
+			if (port->min == start && port->size == size)
+				return 1;
 			break;
 		case IORESOURCE_MEM:
-			for (mem = tmp->mem; mem; mem = mem->next) {
-				if (mem->min == start && mem->size == size)
-					return 1;
-			}
+			mem = &option->u.mem;
+			if (mem->min == start && mem->size == size)
+				return 1;
 			break;
 		case IORESOURCE_IRQ:
-			for (irq = tmp->irq; irq; irq = irq->next) {
-				if (start < PNP_IRQ_NR &&
-				    test_bit(start, irq->map.bits))
-					return 1;
-			}
+			irq = &option->u.irq;
+			if (start < PNP_IRQ_NR &&
+			    test_bit(start, irq->map.bits))
+				return 1;
 			break;
 		case IORESOURCE_DMA:
-			for (dma = tmp->dma; dma; dma = dma->next) {
-				if (dma->map & (1 << start))
-					return 1;
-			}
+			dma = &option->u.dma;
+			if (dma->map & (1 << start))
+				return 1;
 			break;
 		}
 	}
 
 	return 0;
 }
-
-/*
- * Determine whether the specified resource is a possible configuration
- * for this device.
- */
-int pnp_possible_config(struct pnp_dev *dev, int type, resource_size_t start,
-			resource_size_t size)
-{
-	if (pnp_possible_option(dev->independent, type, start, size))
-		return 1;
-
-	if (pnp_possible_option(dev->dependent, type, start, size))
-		return 1;
-
-	return 0;
-}
 EXPORT_SYMBOL(pnp_possible_config);
 
 /* format is: pnp_reserve_irq=irq1[,irq2] .... */

commit 2d29a7a794c5bae982955cd5dd0a76e766e57f39
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Fri Jun 27 16:57:13 2008 -0600

    PNP: rename pnp_register_*_resource() local variables
    
    No functional change; just rename "data" to something more
    descriptive.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Acked-by: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/resource.c b/drivers/pnp/resource.c
index 61145491f363..a795864dc695 100644
--- a/drivers/pnp/resource.c
+++ b/drivers/pnp/resource.c
@@ -80,40 +80,40 @@ struct pnp_option *pnp_register_dependent_option(struct pnp_dev *dev,
 int pnp_register_irq_resource(struct pnp_dev *dev, struct pnp_option *option,
 			      pnp_irq_mask_t *map, unsigned char flags)
 {
-	struct pnp_irq *data, *ptr;
+	struct pnp_irq *irq, *ptr;
 #ifdef DEBUG
 	char buf[PNP_IRQ_NR];   /* hex-encoded, so this is overkill but safe */
 #endif
 
-	data = kzalloc(sizeof(struct pnp_irq), GFP_KERNEL);
-	if (!data)
+	irq = kzalloc(sizeof(struct pnp_irq), GFP_KERNEL);
+	if (!irq)
 		return -ENOMEM;
 
-	data->map = *map;
-	data->flags = flags;
+	irq->map = *map;
+	irq->flags = flags;
 
 	ptr = option->irq;
 	while (ptr && ptr->next)
 		ptr = ptr->next;
 	if (ptr)
-		ptr->next = data;
+		ptr->next = irq;
 	else
-		option->irq = data;
+		option->irq = irq;
 
 #ifdef CONFIG_PCI
 	{
 		int i;
 
 		for (i = 0; i < 16; i++)
-			if (test_bit(i, data->map.bits))
+			if (test_bit(i, irq->map.bits))
 				pcibios_penalize_isa_irq(i, 0);
 	}
 #endif
 
 #ifdef DEBUG
-	bitmap_scnprintf(buf, sizeof(buf), data->map.bits, PNP_IRQ_NR);
+	bitmap_scnprintf(buf, sizeof(buf), irq->map.bits, PNP_IRQ_NR);
 	dev_dbg(&dev->dev, "  irq bitmask %s flags %#x\n", buf,
-		data->flags);
+		irq->flags);
 #endif
 	return 0;
 }
@@ -121,25 +121,25 @@ int pnp_register_irq_resource(struct pnp_dev *dev, struct pnp_option *option,
 int pnp_register_dma_resource(struct pnp_dev *dev, struct pnp_option *option,
 			      unsigned char map, unsigned char flags)
 {
-	struct pnp_dma *data, *ptr;
+	struct pnp_dma *dma, *ptr;
 
-	data = kzalloc(sizeof(struct pnp_dma), GFP_KERNEL);
-	if (!data)
+	dma = kzalloc(sizeof(struct pnp_dma), GFP_KERNEL);
+	if (!dma)
 		return -ENOMEM;
 
-	data->map = map;
-	data->flags = flags;
+	dma->map = map;
+	dma->flags = flags;
 
 	ptr = option->dma;
 	while (ptr && ptr->next)
 		ptr = ptr->next;
 	if (ptr)
-		ptr->next = data;
+		ptr->next = dma;
 	else
-		option->dma = data;
+		option->dma = dma;
 
-	dev_dbg(&dev->dev, "  dma bitmask %#x flags %#x\n", data->map,
-		data->flags);
+	dev_dbg(&dev->dev, "  dma bitmask %#x flags %#x\n", dma->map,
+		dma->flags);
 	return 0;
 }
 
@@ -148,32 +148,32 @@ int pnp_register_port_resource(struct pnp_dev *dev, struct pnp_option *option,
 			       resource_size_t align, resource_size_t size,
 			       unsigned char flags)
 {
-	struct pnp_port *data, *ptr;
+	struct pnp_port *port, *ptr;
 
-	data = kzalloc(sizeof(struct pnp_port), GFP_KERNEL);
-	if (!data)
+	port = kzalloc(sizeof(struct pnp_port), GFP_KERNEL);
+	if (!port)
 		return -ENOMEM;
 
-	data->min = min;
-	data->max = max;
-	data->align = align;
-	data->size = size;
-	data->flags = flags;
+	port->min = min;
+	port->max = max;
+	port->align = align;
+	port->size = size;
+	port->flags = flags;
 
 	ptr = option->port;
 	while (ptr && ptr->next)
 		ptr = ptr->next;
 	if (ptr)
-		ptr->next = data;
+		ptr->next = port;
 	else
-		option->port = data;
+		option->port = port;
 
 	dev_dbg(&dev->dev, "  io  "
 		"min %#llx max %#llx align %lld size %lld flags %#x\n",
-		(unsigned long long) data->min,
-		(unsigned long long) data->max,
-		(unsigned long long) data->align,
-		(unsigned long long) data->size, data->flags);
+		(unsigned long long) port->min,
+		(unsigned long long) port->max,
+		(unsigned long long) port->align,
+		(unsigned long long) port->size, port->flags);
 	return 0;
 }
 
@@ -182,32 +182,32 @@ int pnp_register_mem_resource(struct pnp_dev *dev, struct pnp_option *option,
 			      resource_size_t align, resource_size_t size,
 			      unsigned char flags)
 {
-	struct pnp_mem *data, *ptr;
+	struct pnp_mem *mem, *ptr;
 
-	data = kzalloc(sizeof(struct pnp_mem), GFP_KERNEL);
-	if (!data)
+	mem = kzalloc(sizeof(struct pnp_mem), GFP_KERNEL);
+	if (!mem)
 		return -ENOMEM;
 
-	data->min = min;
-	data->max = max;
-	data->align = align;
-	data->size = size;
-	data->flags = flags;
+	mem->min = min;
+	mem->max = max;
+	mem->align = align;
+	mem->size = size;
+	mem->flags = flags;
 
 	ptr = option->mem;
 	while (ptr && ptr->next)
 		ptr = ptr->next;
 	if (ptr)
-		ptr->next = data;
+		ptr->next = mem;
 	else
-		option->mem = data;
+		option->mem = mem;
 
 	dev_dbg(&dev->dev, "  mem "
 		"min %#llx max %#llx align %lld size %lld flags %#x\n",
-		(unsigned long long) data->min,
-		(unsigned long long) data->max,
-		(unsigned long long) data->align,
-		(unsigned long long) data->size, data->flags);
+		(unsigned long long) mem->min,
+		(unsigned long long) mem->max,
+		(unsigned long long) mem->align,
+		(unsigned long long) mem->size, mem->flags);
 	return 0;
 }
 

commit c227536b4cc2600fc9d22ba0067f699165f6621f
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Fri Jun 27 16:57:11 2008 -0600

    PNP: centralize resource option allocations
    
    This patch moves all the option allocations (pnp_mem, pnp_port, etc)
    into the pnp_register_{mem,port,irq,dma}_resource() functions.  This
    will make it easier to rework the option data structures.
    
    The non-trivial part of this patch is the IRQ handling.  The backends
    have to allocate a local pnp_irq_mask_t bitmap, populate it, and pass
    a pointer to pnp_register_irq_resource().
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Acked-by: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/resource.c b/drivers/pnp/resource.c
index 391828c7f207..61145491f363 100644
--- a/drivers/pnp/resource.c
+++ b/drivers/pnp/resource.c
@@ -78,13 +78,20 @@ struct pnp_option *pnp_register_dependent_option(struct pnp_dev *dev,
 }
 
 int pnp_register_irq_resource(struct pnp_dev *dev, struct pnp_option *option,
-			      struct pnp_irq *data)
+			      pnp_irq_mask_t *map, unsigned char flags)
 {
-	struct pnp_irq *ptr;
+	struct pnp_irq *data, *ptr;
 #ifdef DEBUG
 	char buf[PNP_IRQ_NR];   /* hex-encoded, so this is overkill but safe */
 #endif
 
+	data = kzalloc(sizeof(struct pnp_irq), GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	data->map = *map;
+	data->flags = flags;
+
 	ptr = option->irq;
 	while (ptr && ptr->next)
 		ptr = ptr->next;
@@ -112,9 +119,16 @@ int pnp_register_irq_resource(struct pnp_dev *dev, struct pnp_option *option,
 }
 
 int pnp_register_dma_resource(struct pnp_dev *dev, struct pnp_option *option,
-			      struct pnp_dma *data)
+			      unsigned char map, unsigned char flags)
 {
-	struct pnp_dma *ptr;
+	struct pnp_dma *data, *ptr;
+
+	data = kzalloc(sizeof(struct pnp_dma), GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	data->map = map;
+	data->flags = flags;
 
 	ptr = option->dma;
 	while (ptr && ptr->next)
@@ -130,9 +144,21 @@ int pnp_register_dma_resource(struct pnp_dev *dev, struct pnp_option *option,
 }
 
 int pnp_register_port_resource(struct pnp_dev *dev, struct pnp_option *option,
-			       struct pnp_port *data)
+			       resource_size_t min, resource_size_t max,
+			       resource_size_t align, resource_size_t size,
+			       unsigned char flags)
 {
-	struct pnp_port *ptr;
+	struct pnp_port *data, *ptr;
+
+	data = kzalloc(sizeof(struct pnp_port), GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	data->min = min;
+	data->max = max;
+	data->align = align;
+	data->size = size;
+	data->flags = flags;
 
 	ptr = option->port;
 	while (ptr && ptr->next)
@@ -152,9 +178,21 @@ int pnp_register_port_resource(struct pnp_dev *dev, struct pnp_option *option,
 }
 
 int pnp_register_mem_resource(struct pnp_dev *dev, struct pnp_option *option,
-			      struct pnp_mem *data)
+			      resource_size_t min, resource_size_t max,
+			      resource_size_t align, resource_size_t size,
+			      unsigned char flags)
 {
-	struct pnp_mem *ptr;
+	struct pnp_mem *data, *ptr;
+
+	data = kzalloc(sizeof(struct pnp_mem), GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	data->min = min;
+	data->max = max;
+	data->align = align;
+	data->size = size;
+	data->flags = flags;
 
 	ptr = option->mem;
 	while (ptr && ptr->next)

commit 169aaffe885c56745188e7913f212a67beaa3b80
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Fri Jun 27 16:57:06 2008 -0600

    PNP: increase I/O port & memory option address sizes
    
    ACPI Address Space Descriptors can be up to 64 bits wide.
    We should keep track of the whole thing when parsing resource
    options, so this patch changes PNP port and mem option
    fields from "unsigned short" and "unsigned int" to
    "resource_size_t".
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Acked-by: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/resource.c b/drivers/pnp/resource.c
index 55a57cded24a..391828c7f207 100644
--- a/drivers/pnp/resource.c
+++ b/drivers/pnp/resource.c
@@ -143,8 +143,11 @@ int pnp_register_port_resource(struct pnp_dev *dev, struct pnp_option *option,
 		option->port = data;
 
 	dev_dbg(&dev->dev, "  io  "
-		"min %#x max %#x align %d size %d flags %#x\n",
-		data->min, data->max, data->align, data->size, data->flags);
+		"min %#llx max %#llx align %lld size %lld flags %#x\n",
+		(unsigned long long) data->min,
+		(unsigned long long) data->max,
+		(unsigned long long) data->align,
+		(unsigned long long) data->size, data->flags);
 	return 0;
 }
 
@@ -162,8 +165,11 @@ int pnp_register_mem_resource(struct pnp_dev *dev, struct pnp_option *option,
 		option->mem = data;
 
 	dev_dbg(&dev->dev, "  mem "
-		"min %#x max %#x align %d size %d flags %#x\n",
-		data->min, data->max, data->align, data->size, data->flags);
+		"min %#llx max %#llx align %lld size %lld flags %#x\n",
+		(unsigned long long) data->min,
+		(unsigned long long) data->max,
+		(unsigned long long) data->align,
+		(unsigned long long) data->size, data->flags);
 	return 0;
 }
 

commit 7aefff51854ccd33599c40b4e360d94cb2b7622f
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Fri Jun 27 16:57:05 2008 -0600

    PNP: introduce pnp_irq_mask_t typedef
    
    This adds a typedef for the IRQ bitmap, which should cause
    no functional change, but will make it easier to pass a
    pointer to a bitmap to pnp_register_irq_resource().
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Acked-by: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/resource.c b/drivers/pnp/resource.c
index 786fd356916d..55a57cded24a 100644
--- a/drivers/pnp/resource.c
+++ b/drivers/pnp/resource.c
@@ -98,13 +98,13 @@ int pnp_register_irq_resource(struct pnp_dev *dev, struct pnp_option *option,
 		int i;
 
 		for (i = 0; i < 16; i++)
-			if (test_bit(i, data->map))
+			if (test_bit(i, data->map.bits))
 				pcibios_penalize_isa_irq(i, 0);
 	}
 #endif
 
 #ifdef DEBUG
-	bitmap_scnprintf(buf, sizeof(buf), data->map, PNP_IRQ_NR);
+	bitmap_scnprintf(buf, sizeof(buf), data->map.bits, PNP_IRQ_NR);
 	dev_dbg(&dev->dev, "  irq bitmask %s flags %#x\n", buf,
 		data->flags);
 #endif
@@ -653,7 +653,7 @@ static int pnp_possible_option(struct pnp_option *option, int type,
 		case IORESOURCE_IRQ:
 			for (irq = tmp->irq; irq; irq = irq->next) {
 				if (start < PNP_IRQ_NR &&
-				    test_bit(start, irq->map))
+				    test_bit(start, irq->map.bits))
 					return 1;
 			}
 			break;

commit 57fd51a8be26921b56747ddd09d1d9e01c11c9e0
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Fri Jun 27 16:57:01 2008 -0600

    PNP: add pnp_possible_config() -- can a device could be configured this way?
    
    As part of a heuristic to identify modem devices, 8250_pnp.c
    checks to see whether a device can be configured at any of the
    legacy COM port addresses.
    
    This patch moves the code that traverses the PNP "possible resource
    options" from 8250_pnp.c to the PNP subsystem.  This encapsulation
    is important because a future patch will change the implementation
    of those resource options.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Acked-by: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/resource.c b/drivers/pnp/resource.c
index ff79aa6168cf..786fd356916d 100644
--- a/drivers/pnp/resource.c
+++ b/drivers/pnp/resource.c
@@ -624,6 +624,68 @@ struct pnp_resource *pnp_add_mem_resource(struct pnp_dev *dev,
 	return pnp_res;
 }
 
+static int pnp_possible_option(struct pnp_option *option, int type,
+			       resource_size_t start, resource_size_t size)
+{
+	struct pnp_option *tmp;
+	struct pnp_port *port;
+	struct pnp_mem *mem;
+	struct pnp_irq *irq;
+	struct pnp_dma *dma;
+
+	if (!option)
+		return 0;
+
+	for (tmp = option; tmp; tmp = tmp->next) {
+		switch (type) {
+		case IORESOURCE_IO:
+			for (port = tmp->port; port; port = port->next) {
+				if (port->min == start && port->size == size)
+					return 1;
+			}
+			break;
+		case IORESOURCE_MEM:
+			for (mem = tmp->mem; mem; mem = mem->next) {
+				if (mem->min == start && mem->size == size)
+					return 1;
+			}
+			break;
+		case IORESOURCE_IRQ:
+			for (irq = tmp->irq; irq; irq = irq->next) {
+				if (start < PNP_IRQ_NR &&
+				    test_bit(start, irq->map))
+					return 1;
+			}
+			break;
+		case IORESOURCE_DMA:
+			for (dma = tmp->dma; dma; dma = dma->next) {
+				if (dma->map & (1 << start))
+					return 1;
+			}
+			break;
+		}
+	}
+
+	return 0;
+}
+
+/*
+ * Determine whether the specified resource is a possible configuration
+ * for this device.
+ */
+int pnp_possible_config(struct pnp_dev *dev, int type, resource_size_t start,
+			resource_size_t size)
+{
+	if (pnp_possible_option(dev->independent, type, start, size))
+		return 1;
+
+	if (pnp_possible_option(dev->dependent, type, start, size))
+		return 1;
+
+	return 0;
+}
+EXPORT_SYMBOL(pnp_possible_config);
+
 /* format is: pnp_reserve_irq=irq1[,irq2] .... */
 static int __init pnp_setup_reserve_irq(char *str)
 {

commit 25d39c39d82d062f4be685146abd054a3bafdf12
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Fri Jun 27 16:56:59 2008 -0600

    PNP: remove ratelimit on add resource failures
    
    We used to have a fixed-size resource table.  If a device had
    twenty resources when the table only had space for ten, we didn't
    need ten warnings, so we added the ratelimit.
    
    Now that we can dynamically allocate new resources, we should
    only get failures if the allocation fails.  That should be
    rare enough that we don't need to ratelimit the messages.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>
    Signed-off-by: Andi Kleen <ak@linux.intel.com>

diff --git a/drivers/pnp/resource.c b/drivers/pnp/resource.c
index 0797a77bd042..ff79aa6168cf 100644
--- a/drivers/pnp/resource.c
+++ b/drivers/pnp/resource.c
@@ -537,15 +537,10 @@ struct pnp_resource *pnp_add_irq_resource(struct pnp_dev *dev, int irq,
 {
 	struct pnp_resource *pnp_res;
 	struct resource *res;
-	static unsigned char warned;
 
 	pnp_res = pnp_new_resource(dev);
 	if (!pnp_res) {
-		if (!warned) {
-			dev_err(&dev->dev, "can't add resource for IRQ %d\n",
-				irq);
-			warned = 1;
-		}
+		dev_err(&dev->dev, "can't add resource for IRQ %d\n", irq);
 		return NULL;
 	}
 
@@ -563,15 +558,10 @@ struct pnp_resource *pnp_add_dma_resource(struct pnp_dev *dev, int dma,
 {
 	struct pnp_resource *pnp_res;
 	struct resource *res;
-	static unsigned char warned;
 
 	pnp_res = pnp_new_resource(dev);
 	if (!pnp_res) {
-		if (!warned) {
-			dev_err(&dev->dev, "can't add resource for DMA %d\n",
-				dma);
-			warned = 1;
-		}
+		dev_err(&dev->dev, "can't add resource for DMA %d\n", dma);
 		return NULL;
 	}
 
@@ -590,16 +580,12 @@ struct pnp_resource *pnp_add_io_resource(struct pnp_dev *dev,
 {
 	struct pnp_resource *pnp_res;
 	struct resource *res;
-	static unsigned char warned;
 
 	pnp_res = pnp_new_resource(dev);
 	if (!pnp_res) {
-		if (!warned) {
-			dev_err(&dev->dev, "can't add resource for IO "
-				"%#llx-%#llx\n",(unsigned long long) start,
-				(unsigned long long) end);
-			warned = 1;
-		}
+		dev_err(&dev->dev, "can't add resource for IO %#llx-%#llx\n",
+			(unsigned long long) start,
+			(unsigned long long) end);
 		return NULL;
 	}
 
@@ -619,16 +605,12 @@ struct pnp_resource *pnp_add_mem_resource(struct pnp_dev *dev,
 {
 	struct pnp_resource *pnp_res;
 	struct resource *res;
-	static unsigned char warned;
 
 	pnp_res = pnp_new_resource(dev);
 	if (!pnp_res) {
-		if (!warned) {
-			dev_err(&dev->dev, "can't add resource for MEM "
-				"%#llx-%#llx\n",(unsigned long long) start,
-				(unsigned long long) end);
-			warned = 1;
-		}
+		dev_err(&dev->dev, "can't add resource for MEM %#llx-%#llx\n",
+			(unsigned long long) start,
+			(unsigned long long) end);
 		return NULL;
 	}
 

commit aee3ad815dd291a7193ab01da0f1a30c84d00061
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Fri Jun 27 16:56:57 2008 -0600

    PNP: replace pnp_resource_table with dynamically allocated resources
    
    PNP used to have a fixed-size pnp_resource_table for tracking the
    resources used by a device.  This table often overflowed, so we've
    had to increase the table size, which wastes memory because most
    devices have very few resources.
    
    This patch replaces the table with a linked list of resources where
    the entries are allocated on demand.
    
    This removes messages like these:
    
        pnpacpi: exceeded the max number of IO resources
        00:01: too many I/O port resources
    
    References:
    
        http://bugzilla.kernel.org/show_bug.cgi?id=9535
        http://bugzilla.kernel.org/show_bug.cgi?id=9740
        http://lkml.org/lkml/2007/11/30/110
    
    This patch also changes the way PNP uses the IORESOURCE_UNSET,
    IORESOURCE_AUTO, and IORESOURCE_DISABLED flags.
    
    Prior to this patch, the pnp_resource_table entries used the flags
    like this:
    
        IORESOURCE_UNSET
            This table entry is unused and available for use.  When this flag
            is set, we shouldn't look at anything else in the resource structure.
            This flag is set when a resource table entry is initialized.
    
        IORESOURCE_AUTO
            This resource was assigned automatically by pnp_assign_{io,mem,etc}().
    
            This flag is set when a resource table entry is initialized and
            cleared whenever we discover a resource setting by reading an ISAPNP
            config register, parsing a PNPBIOS resource data stream, parsing an
            ACPI _CRS list, or interpreting a sysfs "set" command.
    
            Resources marked IORESOURCE_AUTO are reinitialized and marked as
            IORESOURCE_UNSET by pnp_clean_resource_table() in these cases:
    
                - before we attempt to assign resources automatically,
                - if we fail to assign resources automatically,
                - after disabling a device
    
        IORESOURCE_DISABLED
            Set by pnp_assign_{io,mem,etc}() when automatic assignment fails.
            Also set by PNPBIOS and PNPACPI for:
    
                - invalid IRQs or GSI registration failures
                - invalid DMA channels
                - I/O ports above 0x10000
                - mem ranges with negative length
    
    After this patch, there is no pnp_resource_table, and the resource list
    entries use the flags like this:
    
        IORESOURCE_UNSET
            This flag is no longer used in PNP.  Instead of keeping
            IORESOURCE_UNSET entries in the resource list, we remove
            entries from the list and free them.
    
        IORESOURCE_AUTO
            No change in meaning: it still means the resource was assigned
            automatically by pnp_assign_{port,mem,etc}(), but these functions
            now set the bit explicitly.
    
            We still "clean" a device's resource list in the same places,
            but rather than reinitializing IORESOURCE_AUTO entries, we
            just remove them from the list.
    
            Note that IORESOURCE_AUTO entries are always at the end of the
            list, so removing them doesn't reorder other list entries.
            This is because non-IORESOURCE_AUTO entries are added by the
            ISAPNP, PNPBIOS, or PNPACPI "get resources" methods and by the
            sysfs "set" command.  In each of these cases, we completely free
            the resource list first.
    
        IORESOURCE_DISABLED
            In addition to the cases where we used to set this flag, ISAPNP now
            adds an IORESOURCE_DISABLED resource when it reads a configuration
            register with a "disabled" value.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>
    Signed-off-by: Andi Kleen <ak@linux.intel.com>

diff --git a/drivers/pnp/resource.c b/drivers/pnp/resource.c
index cce341f743d4..0797a77bd042 100644
--- a/drivers/pnp/resource.c
+++ b/drivers/pnp/resource.c
@@ -237,7 +237,7 @@ void pnp_free_option(struct pnp_option *option)
 	!((*(enda) < *(startb)) || (*(endb) < *(starta)))
 
 #define cannot_compare(flags) \
-((flags) & (IORESOURCE_UNSET | IORESOURCE_DISABLED))
+((flags) & IORESOURCE_DISABLED)
 
 int pnp_check_port(struct pnp_dev *dev, struct resource *res)
 {
@@ -505,81 +505,31 @@ int pnp_resource_type(struct resource *res)
 			     IORESOURCE_IRQ | IORESOURCE_DMA);
 }
 
-struct pnp_resource *pnp_get_pnp_resource(struct pnp_dev *dev,
-					  unsigned int type, unsigned int num)
-{
-	struct pnp_resource_table *res = dev->res;
-
-	switch (type) {
-	case IORESOURCE_IO:
-		if (num >= PNP_MAX_PORT)
-			return NULL;
-		return &res->port[num];
-	case IORESOURCE_MEM:
-		if (num >= PNP_MAX_MEM)
-			return NULL;
-		return &res->mem[num];
-	case IORESOURCE_IRQ:
-		if (num >= PNP_MAX_IRQ)
-			return NULL;
-		return &res->irq[num];
-	case IORESOURCE_DMA:
-		if (num >= PNP_MAX_DMA)
-			return NULL;
-		return &res->dma[num];
-	}
-	return NULL;
-}
-
 struct resource *pnp_get_resource(struct pnp_dev *dev,
 				  unsigned int type, unsigned int num)
 {
 	struct pnp_resource *pnp_res;
+	struct resource *res;
 
-	pnp_res = pnp_get_pnp_resource(dev, type, num);
-	if (pnp_res)
-		return &pnp_res->res;
-
+	list_for_each_entry(pnp_res, &dev->resources, list) {
+		res = &pnp_res->res;
+		if (pnp_resource_type(res) == type && num-- == 0)
+			return res;
+	}
 	return NULL;
 }
 EXPORT_SYMBOL(pnp_get_resource);
 
-static struct pnp_resource *pnp_new_resource(struct pnp_dev *dev, int type)
+static struct pnp_resource *pnp_new_resource(struct pnp_dev *dev)
 {
 	struct pnp_resource *pnp_res;
-	int i;
 
-	switch (type) {
-	case IORESOURCE_IO:
-		for (i = 0; i < PNP_MAX_PORT; i++) {
-			pnp_res = pnp_get_pnp_resource(dev, IORESOURCE_IO, i);
-			if (pnp_res && !pnp_resource_valid(&pnp_res->res))
-				return pnp_res;
-		}
-		break;
-	case IORESOURCE_MEM:
-		for (i = 0; i < PNP_MAX_MEM; i++) {
-			pnp_res = pnp_get_pnp_resource(dev, IORESOURCE_MEM, i);
-			if (pnp_res && !pnp_resource_valid(&pnp_res->res))
-				return pnp_res;
-		}
-		break;
-	case IORESOURCE_IRQ:
-		for (i = 0; i < PNP_MAX_IRQ; i++) {
-			pnp_res = pnp_get_pnp_resource(dev, IORESOURCE_IRQ, i);
-			if (pnp_res && !pnp_resource_valid(&pnp_res->res))
-				return pnp_res;
-		}
-		break;
-	case IORESOURCE_DMA:
-		for (i = 0; i < PNP_MAX_DMA; i++) {
-			pnp_res = pnp_get_pnp_resource(dev, IORESOURCE_DMA, i);
-			if (pnp_res && !pnp_resource_valid(&pnp_res->res))
-				return pnp_res;
-		}
-		break;
-	}
-	return NULL;
+	pnp_res = kzalloc(sizeof(struct pnp_resource), GFP_KERNEL);
+	if (!pnp_res)
+		return NULL;
+
+	list_add_tail(&pnp_res->list, &dev->resources);
+	return pnp_res;
 }
 
 struct pnp_resource *pnp_add_irq_resource(struct pnp_dev *dev, int irq,
@@ -589,7 +539,7 @@ struct pnp_resource *pnp_add_irq_resource(struct pnp_dev *dev, int irq,
 	struct resource *res;
 	static unsigned char warned;
 
-	pnp_res = pnp_new_resource(dev, IORESOURCE_IRQ);
+	pnp_res = pnp_new_resource(dev);
 	if (!pnp_res) {
 		if (!warned) {
 			dev_err(&dev->dev, "can't add resource for IRQ %d\n",
@@ -615,7 +565,7 @@ struct pnp_resource *pnp_add_dma_resource(struct pnp_dev *dev, int dma,
 	struct resource *res;
 	static unsigned char warned;
 
-	pnp_res = pnp_new_resource(dev, IORESOURCE_DMA);
+	pnp_res = pnp_new_resource(dev);
 	if (!pnp_res) {
 		if (!warned) {
 			dev_err(&dev->dev, "can't add resource for DMA %d\n",
@@ -642,7 +592,7 @@ struct pnp_resource *pnp_add_io_resource(struct pnp_dev *dev,
 	struct resource *res;
 	static unsigned char warned;
 
-	pnp_res = pnp_new_resource(dev, IORESOURCE_IO);
+	pnp_res = pnp_new_resource(dev);
 	if (!pnp_res) {
 		if (!warned) {
 			dev_err(&dev->dev, "can't add resource for IO "
@@ -671,7 +621,7 @@ struct pnp_resource *pnp_add_mem_resource(struct pnp_dev *dev,
 	struct resource *res;
 	static unsigned char warned;
 
-	pnp_res = pnp_new_resource(dev, IORESOURCE_MEM);
+	pnp_res = pnp_new_resource(dev);
 	if (!pnp_res) {
 		if (!warned) {
 			dev_err(&dev->dev, "can't add resource for MEM "

commit 940e98dbc616f1df7b63b73858a966969baf261d
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Fri Jun 27 16:56:54 2008 -0600

    PNP: add pnp_resource_type() internal interface
    
    Given a struct resource, this returns the type (IO, MEM, IRQ, DMA).
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>
    Signed-off-by: Andi Kleen <ak@linux.intel.com>

diff --git a/drivers/pnp/resource.c b/drivers/pnp/resource.c
index 390b50096e30..cce341f743d4 100644
--- a/drivers/pnp/resource.c
+++ b/drivers/pnp/resource.c
@@ -499,6 +499,12 @@ int pnp_check_dma(struct pnp_dev *dev, struct resource *res)
 #endif
 }
 
+int pnp_resource_type(struct resource *res)
+{
+	return res->flags & (IORESOURCE_IO  | IORESOURCE_MEM |
+			     IORESOURCE_IRQ | IORESOURCE_DMA);
+}
+
 struct pnp_resource *pnp_get_pnp_resource(struct pnp_dev *dev,
 					  unsigned int type, unsigned int num)
 {

commit bc033c9b5fd261855278f4ed82c3713cc549afbe
Author: Rene Herman <rene.herman@keyaccess.nl>
Date:   Wed May 14 16:05:34 2008 -0700

    pnp: add pnp_build_option() to the API
    
    The subsequent AD181x quirk patch would like this as part of the API.
    pnp_register_dependent_option() adds to the same dependent chain the quirk is
    walking which is fairly unclean.  This enables a private option chain build
    which it can then just add onto the end when done.
    
    Signed-off-by: Rene Herman <rene.herman@gmail.com>
    Tested-by: Uwe Bugla <uwe.bugla@gmx.de>
    Acked-by: Uwe Bugla <uwe.bugla@gmx.de>
    Acked-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Cc: Takashi Iwai <tiwai@suse.de>
    Cc: Len Brown <len.brown@intel.com
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pnp/resource.c b/drivers/pnp/resource.c
index 2041620d5682..390b50096e30 100644
--- a/drivers/pnp/resource.c
+++ b/drivers/pnp/resource.c
@@ -28,7 +28,7 @@ static int pnp_reserve_mem[16] = {[0 ... 15] = -1 };	/* reserve (don't use) some
  * option registration
  */
 
-static struct pnp_option *pnp_build_option(int priority)
+struct pnp_option *pnp_build_option(int priority)
 {
 	struct pnp_option *option = pnp_alloc(sizeof(struct pnp_option));
 

commit d6180f36617953990bf90d4c1ff85b77e9995cd1
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Apr 28 16:34:37 2008 -0600

    PNP: make generic pnp_add_mem_resource()
    
    Add a pnp_add_mem_resource() that can be used by all the PNP
    backends.  This consolidates a little more pnp_resource_table
    knowledge into one place.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/resource.c b/drivers/pnp/resource.c
index 64387b70026a..2041620d5682 100644
--- a/drivers/pnp/resource.c
+++ b/drivers/pnp/resource.c
@@ -657,6 +657,35 @@ struct pnp_resource *pnp_add_io_resource(struct pnp_dev *dev,
 	return pnp_res;
 }
 
+struct pnp_resource *pnp_add_mem_resource(struct pnp_dev *dev,
+					  resource_size_t start,
+					  resource_size_t end, int flags)
+{
+	struct pnp_resource *pnp_res;
+	struct resource *res;
+	static unsigned char warned;
+
+	pnp_res = pnp_new_resource(dev, IORESOURCE_MEM);
+	if (!pnp_res) {
+		if (!warned) {
+			dev_err(&dev->dev, "can't add resource for MEM "
+				"%#llx-%#llx\n",(unsigned long long) start,
+				(unsigned long long) end);
+			warned = 1;
+		}
+		return NULL;
+	}
+
+	res = &pnp_res->res;
+	res->flags = IORESOURCE_MEM | flags;
+	res->start = start;
+	res->end = end;
+
+	dev_dbg(&dev->dev, "  add mem %#llx-%#llx flags %#x\n",
+		(unsigned long long) start, (unsigned long long) end, flags);
+	return pnp_res;
+}
+
 /* format is: pnp_reserve_irq=irq1[,irq2] .... */
 static int __init pnp_setup_reserve_irq(char *str)
 {

commit cc8c2e308194f0997c718c7c735550ff06754d20
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Apr 28 16:34:36 2008 -0600

    PNP: make generic pnp_add_io_resource()
    
    Add a pnp_add_io_resource() that can be used by all the PNP
    backends.  This consolidates a little more pnp_resource_table
    knowledge into one place.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/resource.c b/drivers/pnp/resource.c
index 2a8612e31ab7..64387b70026a 100644
--- a/drivers/pnp/resource.c
+++ b/drivers/pnp/resource.c
@@ -628,6 +628,35 @@ struct pnp_resource *pnp_add_dma_resource(struct pnp_dev *dev, int dma,
 	return pnp_res;
 }
 
+struct pnp_resource *pnp_add_io_resource(struct pnp_dev *dev,
+					 resource_size_t start,
+					 resource_size_t end, int flags)
+{
+	struct pnp_resource *pnp_res;
+	struct resource *res;
+	static unsigned char warned;
+
+	pnp_res = pnp_new_resource(dev, IORESOURCE_IO);
+	if (!pnp_res) {
+		if (!warned) {
+			dev_err(&dev->dev, "can't add resource for IO "
+				"%#llx-%#llx\n",(unsigned long long) start,
+				(unsigned long long) end);
+			warned = 1;
+		}
+		return NULL;
+	}
+
+	res = &pnp_res->res;
+	res->flags = IORESOURCE_IO | flags;
+	res->start = start;
+	res->end = end;
+
+	dev_dbg(&dev->dev, "  add io  %#llx-%#llx flags %#x\n",
+		(unsigned long long) start, (unsigned long long) end, flags);
+	return pnp_res;
+}
+
 /* format is: pnp_reserve_irq=irq1[,irq2] .... */
 static int __init pnp_setup_reserve_irq(char *str)
 {

commit dc16f5f2ede8cc2acf8ac22857a7fecf3a4296c2
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Apr 28 16:34:35 2008 -0600

    PNP: make generic pnp_add_dma_resource()
    
    Add a pnp_add_dma_resource() that can be used by all the PNP
    backends.  This consolidates a little more pnp_resource_table
    knowledge into one place.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/resource.c b/drivers/pnp/resource.c
index 082a556b9dcc..2a8612e31ab7 100644
--- a/drivers/pnp/resource.c
+++ b/drivers/pnp/resource.c
@@ -602,6 +602,32 @@ struct pnp_resource *pnp_add_irq_resource(struct pnp_dev *dev, int irq,
 	return pnp_res;
 }
 
+struct pnp_resource *pnp_add_dma_resource(struct pnp_dev *dev, int dma,
+					  int flags)
+{
+	struct pnp_resource *pnp_res;
+	struct resource *res;
+	static unsigned char warned;
+
+	pnp_res = pnp_new_resource(dev, IORESOURCE_DMA);
+	if (!pnp_res) {
+		if (!warned) {
+			dev_err(&dev->dev, "can't add resource for DMA %d\n",
+				dma);
+			warned = 1;
+		}
+		return NULL;
+	}
+
+	res = &pnp_res->res;
+	res->flags = IORESOURCE_DMA | flags;
+	res->start = dma;
+	res->end = dma;
+
+	dev_dbg(&dev->dev, "  add dma %d flags %#x\n", dma, flags);
+	return pnp_res;
+}
+
 /* format is: pnp_reserve_irq=irq1[,irq2] .... */
 static int __init pnp_setup_reserve_irq(char *str)
 {

commit dbddd0383c59d588f8db5e773b062756e39117ec
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Apr 28 16:34:34 2008 -0600

    PNP: make generic pnp_add_irq_resource()
    
    Add a pnp_add_irq_resource() that can be used by all the PNP
    backends.  This consolidates a little more pnp_resource_table
    knowledge into one place.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/resource.c b/drivers/pnp/resource.c
index 1f4134eea7b7..082a556b9dcc 100644
--- a/drivers/pnp/resource.c
+++ b/drivers/pnp/resource.c
@@ -576,6 +576,32 @@ static struct pnp_resource *pnp_new_resource(struct pnp_dev *dev, int type)
 	return NULL;
 }
 
+struct pnp_resource *pnp_add_irq_resource(struct pnp_dev *dev, int irq,
+					  int flags)
+{
+	struct pnp_resource *pnp_res;
+	struct resource *res;
+	static unsigned char warned;
+
+	pnp_res = pnp_new_resource(dev, IORESOURCE_IRQ);
+	if (!pnp_res) {
+		if (!warned) {
+			dev_err(&dev->dev, "can't add resource for IRQ %d\n",
+				irq);
+			warned = 1;
+		}
+		return NULL;
+	}
+
+	res = &pnp_res->res;
+	res->flags = IORESOURCE_IRQ | flags;
+	res->start = irq;
+	res->end = irq;
+
+	dev_dbg(&dev->dev, "  add irq %d flags %#x\n", irq, flags);
+	return pnp_res;
+}
+
 /* format is: pnp_reserve_irq=irq1[,irq2] .... */
 static int __init pnp_setup_reserve_irq(char *str)
 {

commit a50b6d7b8d7e1a8b13bd1be65a865b115e1190d9
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Apr 28 16:34:33 2008 -0600

    PNP: add pnp_new_resource() to find a new unset pnp_resource
    
    This encapsulates the code to locate a new pnp_resource of the
    desired type.  Currently this uses the pnp_resource_table, but
    it will soon change to find a resource in a linked list.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/resource.c b/drivers/pnp/resource.c
index c57cfe51d52a..1f4134eea7b7 100644
--- a/drivers/pnp/resource.c
+++ b/drivers/pnp/resource.c
@@ -538,6 +538,44 @@ struct resource *pnp_get_resource(struct pnp_dev *dev,
 }
 EXPORT_SYMBOL(pnp_get_resource);
 
+static struct pnp_resource *pnp_new_resource(struct pnp_dev *dev, int type)
+{
+	struct pnp_resource *pnp_res;
+	int i;
+
+	switch (type) {
+	case IORESOURCE_IO:
+		for (i = 0; i < PNP_MAX_PORT; i++) {
+			pnp_res = pnp_get_pnp_resource(dev, IORESOURCE_IO, i);
+			if (pnp_res && !pnp_resource_valid(&pnp_res->res))
+				return pnp_res;
+		}
+		break;
+	case IORESOURCE_MEM:
+		for (i = 0; i < PNP_MAX_MEM; i++) {
+			pnp_res = pnp_get_pnp_resource(dev, IORESOURCE_MEM, i);
+			if (pnp_res && !pnp_resource_valid(&pnp_res->res))
+				return pnp_res;
+		}
+		break;
+	case IORESOURCE_IRQ:
+		for (i = 0; i < PNP_MAX_IRQ; i++) {
+			pnp_res = pnp_get_pnp_resource(dev, IORESOURCE_IRQ, i);
+			if (pnp_res && !pnp_resource_valid(&pnp_res->res))
+				return pnp_res;
+		}
+		break;
+	case IORESOURCE_DMA:
+		for (i = 0; i < PNP_MAX_DMA; i++) {
+			pnp_res = pnp_get_pnp_resource(dev, IORESOURCE_DMA, i);
+			if (pnp_res && !pnp_resource_valid(&pnp_res->res))
+				return pnp_res;
+		}
+		break;
+	}
+	return NULL;
+}
+
 /* format is: pnp_reserve_irq=irq1[,irq2] .... */
 static int __init pnp_setup_reserve_irq(char *str)
 {

commit 0a977f15469457d9a19eed992caf71995c674064
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Apr 28 16:34:31 2008 -0600

    PNP: add pnp_get_pnp_resource()
    
    In some places, we need to get the struct pnp_resource, not just
    the struct resource, because ISAPNP needs to store the register
    index in the pnp_resource.
    
    I don't like pnp_get_pnp_resource() and hope that it is temporary,
    but we need it for a little while.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/resource.c b/drivers/pnp/resource.c
index 7e9f4300e5f6..c57cfe51d52a 100644
--- a/drivers/pnp/resource.c
+++ b/drivers/pnp/resource.c
@@ -499,8 +499,8 @@ int pnp_check_dma(struct pnp_dev *dev, struct resource *res)
 #endif
 }
 
-struct resource *pnp_get_resource(struct pnp_dev *dev,
-				  unsigned int type, unsigned int num)
+struct pnp_resource *pnp_get_pnp_resource(struct pnp_dev *dev,
+					  unsigned int type, unsigned int num)
 {
 	struct pnp_resource_table *res = dev->res;
 
@@ -508,22 +508,34 @@ struct resource *pnp_get_resource(struct pnp_dev *dev,
 	case IORESOURCE_IO:
 		if (num >= PNP_MAX_PORT)
 			return NULL;
-		return &res->port[num].res;
+		return &res->port[num];
 	case IORESOURCE_MEM:
 		if (num >= PNP_MAX_MEM)
 			return NULL;
-		return &res->mem[num].res;
+		return &res->mem[num];
 	case IORESOURCE_IRQ:
 		if (num >= PNP_MAX_IRQ)
 			return NULL;
-		return &res->irq[num].res;
+		return &res->irq[num];
 	case IORESOURCE_DMA:
 		if (num >= PNP_MAX_DMA)
 			return NULL;
-		return &res->dma[num].res;
+		return &res->dma[num];
 	}
 	return NULL;
 }
+
+struct resource *pnp_get_resource(struct pnp_dev *dev,
+				  unsigned int type, unsigned int num)
+{
+	struct pnp_resource *pnp_res;
+
+	pnp_res = pnp_get_pnp_resource(dev, type, num);
+	if (pnp_res)
+		return &pnp_res->res;
+
+	return NULL;
+}
 EXPORT_SYMBOL(pnp_get_resource);
 
 /* format is: pnp_reserve_irq=irq1[,irq2] .... */

commit 784f01d5bdeae7d7005ede17305306b042ba2617
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Apr 28 16:34:30 2008 -0600

    PNP: add struct pnp_resource
    
    This patch adds a "struct pnp_resource".  This currently
    contains only a struct resource, but we will soon need
    additional PNP-specific information.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/resource.c b/drivers/pnp/resource.c
index f7adc7eefbf8..7e9f4300e5f6 100644
--- a/drivers/pnp/resource.c
+++ b/drivers/pnp/resource.c
@@ -508,19 +508,19 @@ struct resource *pnp_get_resource(struct pnp_dev *dev,
 	case IORESOURCE_IO:
 		if (num >= PNP_MAX_PORT)
 			return NULL;
-		return &res->port_resource[num];
+		return &res->port[num].res;
 	case IORESOURCE_MEM:
 		if (num >= PNP_MAX_MEM)
 			return NULL;
-		return &res->mem_resource[num];
+		return &res->mem[num].res;
 	case IORESOURCE_IRQ:
 		if (num >= PNP_MAX_IRQ)
 			return NULL;
-		return &res->irq_resource[num];
+		return &res->irq[num].res;
 	case IORESOURCE_DMA:
 		if (num >= PNP_MAX_DMA)
 			return NULL;
-		return &res->dma_resource[num];
+		return &res->dma[num].res;
 	}
 	return NULL;
 }

commit 02d83b5da3efa3c278ce87db2637f3dd6837166d
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Apr 28 16:34:28 2008 -0600

    PNP: make pnp_resource_table private to PNP core
    
    There are no remaining references to the PNP_MAX_* constants or
    the pnp_resource_table structure outside of the PNP core.  Make
    them private to the PNP core.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/resource.c b/drivers/pnp/resource.c
index 84362818fa8b..f7adc7eefbf8 100644
--- a/drivers/pnp/resource.c
+++ b/drivers/pnp/resource.c
@@ -502,7 +502,7 @@ int pnp_check_dma(struct pnp_dev *dev, struct resource *res)
 struct resource *pnp_get_resource(struct pnp_dev *dev,
 				  unsigned int type, unsigned int num)
 {
-	struct pnp_resource_table *res = &dev->res;
+	struct pnp_resource_table *res = dev->res;
 
 	switch (type) {
 	case IORESOURCE_IO:

commit 95ab3669f7830682c7762e9c305a0c1dd44454cc
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Apr 28 16:34:26 2008 -0600

    PNP: remove PNP_MAX_* uses
    
    Remove some PNP_MAX_* uses.  The pnp_resource_table isn't
    dynamic yet, but with pnp_get_resource(), we can start moving
    away from the table size constants.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/resource.c b/drivers/pnp/resource.c
index b2516d62fcf6..84362818fa8b 100644
--- a/drivers/pnp/resource.c
+++ b/drivers/pnp/resource.c
@@ -269,9 +269,8 @@ int pnp_check_port(struct pnp_dev *dev, struct resource *res)
 	}
 
 	/* check for internal conflicts */
-	for (i = 0; i < PNP_MAX_PORT; i++) {
-		tres = pnp_get_resource(dev, IORESOURCE_IO, i);
-		if (tres && tres != res && tres->flags & IORESOURCE_IO) {
+	for (i = 0; (tres = pnp_get_resource(dev, IORESOURCE_IO, i)); i++) {
+		if (tres != res && tres->flags & IORESOURCE_IO) {
 			tport = &tres->start;
 			tend = &tres->end;
 			if (ranged_conflict(port, end, tport, tend))
@@ -283,9 +282,10 @@ int pnp_check_port(struct pnp_dev *dev, struct resource *res)
 	pnp_for_each_dev(tdev) {
 		if (tdev == dev)
 			continue;
-		for (i = 0; i < PNP_MAX_PORT; i++) {
-			tres = pnp_get_resource(tdev, IORESOURCE_IO, i);
-			if (tres && tres->flags & IORESOURCE_IO) {
+		for (i = 0;
+		     (tres = pnp_get_resource(tdev, IORESOURCE_IO, i));
+		     i++) {
+			if (tres->flags & IORESOURCE_IO) {
 				if (cannot_compare(tres->flags))
 					continue;
 				tport = &tres->start;
@@ -329,9 +329,8 @@ int pnp_check_mem(struct pnp_dev *dev, struct resource *res)
 	}
 
 	/* check for internal conflicts */
-	for (i = 0; i < PNP_MAX_MEM; i++) {
-		tres = pnp_get_resource(dev, IORESOURCE_MEM, i);
-		if (tres && tres != res && tres->flags & IORESOURCE_MEM) {
+	for (i = 0; (tres = pnp_get_resource(dev, IORESOURCE_MEM, i)); i++) {
+		if (tres != res && tres->flags & IORESOURCE_MEM) {
 			taddr = &tres->start;
 			tend = &tres->end;
 			if (ranged_conflict(addr, end, taddr, tend))
@@ -343,9 +342,10 @@ int pnp_check_mem(struct pnp_dev *dev, struct resource *res)
 	pnp_for_each_dev(tdev) {
 		if (tdev == dev)
 			continue;
-		for (i = 0; i < PNP_MAX_MEM; i++) {
-			tres = pnp_get_resource(tdev, IORESOURCE_MEM, i);
-			if (tres && tres->flags & IORESOURCE_MEM) {
+		for (i = 0;
+		     (tres = pnp_get_resource(tdev, IORESOURCE_MEM, i));
+		     i++) {
+			if (tres->flags & IORESOURCE_MEM) {
 				if (cannot_compare(tres->flags))
 					continue;
 				taddr = &tres->start;
@@ -388,9 +388,8 @@ int pnp_check_irq(struct pnp_dev *dev, struct resource *res)
 	}
 
 	/* check for internal conflicts */
-	for (i = 0; i < PNP_MAX_IRQ; i++) {
-		tres = pnp_get_resource(dev, IORESOURCE_IRQ, i);
-		if (tres && tres != res && tres->flags & IORESOURCE_IRQ) {
+	for (i = 0; (tres = pnp_get_resource(dev, IORESOURCE_IRQ, i)); i++) {
+		if (tres != res && tres->flags & IORESOURCE_IRQ) {
 			if (tres->start == *irq)
 				return 0;
 		}
@@ -422,9 +421,10 @@ int pnp_check_irq(struct pnp_dev *dev, struct resource *res)
 	pnp_for_each_dev(tdev) {
 		if (tdev == dev)
 			continue;
-		for (i = 0; i < PNP_MAX_IRQ; i++) {
-			tres = pnp_get_resource(tdev, IORESOURCE_IRQ, i);
-			if (tres && tres->flags & IORESOURCE_IRQ) {
+		for (i = 0;
+		     (tres = pnp_get_resource(tdev, IORESOURCE_IRQ, i));
+		     i++) {
+			if (tres->flags & IORESOURCE_IRQ) {
 				if (cannot_compare(tres->flags))
 					continue;
 				if (tres->start == *irq)
@@ -461,9 +461,8 @@ int pnp_check_dma(struct pnp_dev *dev, struct resource *res)
 	}
 
 	/* check for internal conflicts */
-	for (i = 0; i < PNP_MAX_DMA; i++) {
-		tres = pnp_get_resource(dev, IORESOURCE_DMA, i);
-		if (tres && tres != res && tres->flags & IORESOURCE_DMA) {
+	for (i = 0; (tres = pnp_get_resource(dev, IORESOURCE_DMA, i)); i++) {
+		if (tres != res && tres->flags & IORESOURCE_DMA) {
 			if (tres->start == *dma)
 				return 0;
 		}
@@ -481,9 +480,10 @@ int pnp_check_dma(struct pnp_dev *dev, struct resource *res)
 	pnp_for_each_dev(tdev) {
 		if (tdev == dev)
 			continue;
-		for (i = 0; i < PNP_MAX_DMA; i++) {
-			tres = pnp_get_resource(tdev, IORESOURCE_DMA, i);
-			if (tres && tres->flags & IORESOURCE_DMA) {
+		for (i = 0;
+		     (tres = pnp_get_resource(tdev, IORESOURCE_DMA, i));
+		     i++) {
+			if (tres->flags & IORESOURCE_DMA) {
 				if (cannot_compare(tres->flags))
 					continue;
 				if (tres->start == *dma)

commit be81b4a4838ce329b9f3978c7fc007b047c23722
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Apr 28 16:34:23 2008 -0600

    PNP: convert resource checks to use pnp_get_resource(), not pnp_resource_table
    
    This removes more direct references to pnp_resource_table.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Acked-By: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/resource.c b/drivers/pnp/resource.c
index 93bf45e01f2c..b2516d62fcf6 100644
--- a/drivers/pnp/resource.c
+++ b/drivers/pnp/resource.c
@@ -270,8 +270,8 @@ int pnp_check_port(struct pnp_dev *dev, struct resource *res)
 
 	/* check for internal conflicts */
 	for (i = 0; i < PNP_MAX_PORT; i++) {
-		tres = &dev->res.port_resource[i];
-		if (tres != res && tres->flags & IORESOURCE_IO) {
+		tres = pnp_get_resource(dev, IORESOURCE_IO, i);
+		if (tres && tres != res && tres->flags & IORESOURCE_IO) {
 			tport = &tres->start;
 			tend = &tres->end;
 			if (ranged_conflict(port, end, tport, tend))
@@ -284,8 +284,8 @@ int pnp_check_port(struct pnp_dev *dev, struct resource *res)
 		if (tdev == dev)
 			continue;
 		for (i = 0; i < PNP_MAX_PORT; i++) {
-			tres = &tdev->res.port_resource[i];
-			if (tres->flags & IORESOURCE_IO) {
+			tres = pnp_get_resource(tdev, IORESOURCE_IO, i);
+			if (tres && tres->flags & IORESOURCE_IO) {
 				if (cannot_compare(tres->flags))
 					continue;
 				tport = &tres->start;
@@ -330,8 +330,8 @@ int pnp_check_mem(struct pnp_dev *dev, struct resource *res)
 
 	/* check for internal conflicts */
 	for (i = 0; i < PNP_MAX_MEM; i++) {
-		tres = &dev->res.mem_resource[i];
-		if (tres != res && tres->flags & IORESOURCE_MEM) {
+		tres = pnp_get_resource(dev, IORESOURCE_MEM, i);
+		if (tres && tres != res && tres->flags & IORESOURCE_MEM) {
 			taddr = &tres->start;
 			tend = &tres->end;
 			if (ranged_conflict(addr, end, taddr, tend))
@@ -344,8 +344,8 @@ int pnp_check_mem(struct pnp_dev *dev, struct resource *res)
 		if (tdev == dev)
 			continue;
 		for (i = 0; i < PNP_MAX_MEM; i++) {
-			tres = &tdev->res.mem_resource[i];
-			if (tres->flags & IORESOURCE_MEM) {
+			tres = pnp_get_resource(tdev, IORESOURCE_MEM, i);
+			if (tres && tres->flags & IORESOURCE_MEM) {
 				if (cannot_compare(tres->flags))
 					continue;
 				taddr = &tres->start;
@@ -389,8 +389,8 @@ int pnp_check_irq(struct pnp_dev *dev, struct resource *res)
 
 	/* check for internal conflicts */
 	for (i = 0; i < PNP_MAX_IRQ; i++) {
-		tres = &dev->res.irq_resource[i];
-		if (tres != res && tres->flags & IORESOURCE_IRQ) {
+		tres = pnp_get_resource(dev, IORESOURCE_IRQ, i);
+		if (tres && tres != res && tres->flags & IORESOURCE_IRQ) {
 			if (tres->start == *irq)
 				return 0;
 		}
@@ -423,8 +423,8 @@ int pnp_check_irq(struct pnp_dev *dev, struct resource *res)
 		if (tdev == dev)
 			continue;
 		for (i = 0; i < PNP_MAX_IRQ; i++) {
-			tres = &tdev->res.irq_resource[i];
-			if (tres->flags & IORESOURCE_IRQ) {
+			tres = pnp_get_resource(tdev, IORESOURCE_IRQ, i);
+			if (tres && tres->flags & IORESOURCE_IRQ) {
 				if (cannot_compare(tres->flags))
 					continue;
 				if (tres->start == *irq)
@@ -462,8 +462,8 @@ int pnp_check_dma(struct pnp_dev *dev, struct resource *res)
 
 	/* check for internal conflicts */
 	for (i = 0; i < PNP_MAX_DMA; i++) {
-		tres = &dev->res.dma_resource[i];
-		if (tres != res && tres->flags & IORESOURCE_DMA) {
+		tres = pnp_get_resource(dev, IORESOURCE_DMA, i);
+		if (tres && tres != res && tres->flags & IORESOURCE_DMA) {
 			if (tres->start == *dma)
 				return 0;
 		}
@@ -482,8 +482,8 @@ int pnp_check_dma(struct pnp_dev *dev, struct resource *res)
 		if (tdev == dev)
 			continue;
 		for (i = 0; i < PNP_MAX_DMA; i++) {
-			tres = &tdev->res.dma_resource[i];
-			if (tres->flags & IORESOURCE_DMA) {
+			tres = pnp_get_resource(tdev, IORESOURCE_DMA, i);
+			if (tres && tres->flags & IORESOURCE_DMA) {
 				if (cannot_compare(tres->flags))
 					continue;
 				if (tres->start == *dma)

commit f5d94ff014cb7e6212f40fc6644f3fd68507df33
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Apr 28 16:34:22 2008 -0600

    PNP: pass resources, not indexes, to pnp_check_port(), et al
    
    The caller already has the struct resource pointer, so no need for
    pnp_check_port(), pnp_check_mem(), etc., to look it up again.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Acked-By: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/resource.c b/drivers/pnp/resource.c
index eab16e5520ae..93bf45e01f2c 100644
--- a/drivers/pnp/resource.c
+++ b/drivers/pnp/resource.c
@@ -239,14 +239,13 @@ void pnp_free_option(struct pnp_option *option)
 #define cannot_compare(flags) \
 ((flags) & (IORESOURCE_UNSET | IORESOURCE_DISABLED))
 
-int pnp_check_port(struct pnp_dev *dev, int idx)
+int pnp_check_port(struct pnp_dev *dev, struct resource *res)
 {
 	int i;
 	struct pnp_dev *tdev;
-	struct resource *res, *tres;
+	struct resource *tres;
 	resource_size_t *port, *end, *tport, *tend;
 
-	res = &dev->res.port_resource[idx];
 	port = &res->start;
 	end = &res->end;
 
@@ -300,14 +299,13 @@ int pnp_check_port(struct pnp_dev *dev, int idx)
 	return 1;
 }
 
-int pnp_check_mem(struct pnp_dev *dev, int idx)
+int pnp_check_mem(struct pnp_dev *dev, struct resource *res)
 {
 	int i;
 	struct pnp_dev *tdev;
-	struct resource *res, *tres;
+	struct resource *tres;
 	resource_size_t *addr, *end, *taddr, *tend;
 
-	res = &dev->res.mem_resource[idx];
 	addr = &res->start;
 	end = &res->end;
 
@@ -366,14 +364,13 @@ static irqreturn_t pnp_test_handler(int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
-int pnp_check_irq(struct pnp_dev *dev, int idx)
+int pnp_check_irq(struct pnp_dev *dev, struct resource *res)
 {
 	int i;
 	struct pnp_dev *tdev;
-	struct resource *res, *tres;
+	struct resource *tres;
 	resource_size_t *irq;
 
-	res = &dev->res.irq_resource[idx];
 	irq = &res->start;
 
 	/* if the resource doesn't exist, don't complain about it */
@@ -439,15 +436,14 @@ int pnp_check_irq(struct pnp_dev *dev, int idx)
 	return 1;
 }
 
-int pnp_check_dma(struct pnp_dev *dev, int idx)
+int pnp_check_dma(struct pnp_dev *dev, struct resource *res)
 {
 #ifndef CONFIG_IA64
 	int i;
 	struct pnp_dev *tdev;
-	struct resource *res, *tres;
+	struct resource *tres;
 	resource_size_t *dma;
 
-	res = &dev->res.dma_resource[idx];
 	dma = &res->start;
 
 	/* if the resource doesn't exist, don't complain about it */

commit db9eaeab3e7ab72d773820820f1ba33960ad24c4
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Apr 28 16:34:21 2008 -0600

    PNP: check for conflicts with all resources, not just earlier ones
    
    This patch removes a use of "idx" in pnp_check_port() and similar
    functions, in preparation for replacing idx with a pointer to the
    resource itself.
    
    I split this out because it changes the behavior slightly: we used
    to check for conflicts only with earlier resources, e.g., we checked
    resource 2 against resources 0 and 1 but not against 3, 4, etc.  Now
    we will check against all resources except 2.
    
    Since resources are assigned in ascending order, the old behavior
    was probably safe, but I don't like to depend on that ordering.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Acked-By: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/resource.c b/drivers/pnp/resource.c
index f89945ebd8b6..eab16e5520ae 100644
--- a/drivers/pnp/resource.c
+++ b/drivers/pnp/resource.c
@@ -270,9 +270,9 @@ int pnp_check_port(struct pnp_dev *dev, int idx)
 	}
 
 	/* check for internal conflicts */
-	for (i = 0; i < PNP_MAX_PORT && i != idx; i++) {
+	for (i = 0; i < PNP_MAX_PORT; i++) {
 		tres = &dev->res.port_resource[i];
-		if (tres->flags & IORESOURCE_IO) {
+		if (tres != res && tres->flags & IORESOURCE_IO) {
 			tport = &tres->start;
 			tend = &tres->end;
 			if (ranged_conflict(port, end, tport, tend))
@@ -331,9 +331,9 @@ int pnp_check_mem(struct pnp_dev *dev, int idx)
 	}
 
 	/* check for internal conflicts */
-	for (i = 0; i < PNP_MAX_MEM && i != idx; i++) {
+	for (i = 0; i < PNP_MAX_MEM; i++) {
 		tres = &dev->res.mem_resource[i];
-		if (tres->flags & IORESOURCE_MEM) {
+		if (tres != res && tres->flags & IORESOURCE_MEM) {
 			taddr = &tres->start;
 			tend = &tres->end;
 			if (ranged_conflict(addr, end, taddr, tend))
@@ -391,9 +391,9 @@ int pnp_check_irq(struct pnp_dev *dev, int idx)
 	}
 
 	/* check for internal conflicts */
-	for (i = 0; i < PNP_MAX_IRQ && i != idx; i++) {
+	for (i = 0; i < PNP_MAX_IRQ; i++) {
 		tres = &dev->res.irq_resource[i];
-		if (tres->flags & IORESOURCE_IRQ) {
+		if (tres != res && tres->flags & IORESOURCE_IRQ) {
 			if (tres->start == *irq)
 				return 0;
 		}
@@ -465,9 +465,9 @@ int pnp_check_dma(struct pnp_dev *dev, int idx)
 	}
 
 	/* check for internal conflicts */
-	for (i = 0; i < PNP_MAX_DMA && i != idx; i++) {
+	for (i = 0; i < PNP_MAX_DMA; i++) {
 		tres = &dev->res.dma_resource[i];
-		if (tres->flags & IORESOURCE_DMA) {
+		if (tres != res && tres->flags & IORESOURCE_DMA) {
 			if (tres->start == *dma)
 				return 0;
 		}

commit 30c016a0c8d2aae10be6a87bb98f0e85db8b09d5
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Apr 28 16:34:19 2008 -0600

    PNP: reduce redundancy in pnp_check_port() and others
    
    Use a temporary "res" pointer to replace repeated lookups in
    the pnp resource tables.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Acked-By: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/resource.c b/drivers/pnp/resource.c
index 15995f9f8b7c..f89945ebd8b6 100644
--- a/drivers/pnp/resource.c
+++ b/drivers/pnp/resource.c
@@ -243,13 +243,15 @@ int pnp_check_port(struct pnp_dev *dev, int idx)
 {
 	int i;
 	struct pnp_dev *tdev;
+	struct resource *res, *tres;
 	resource_size_t *port, *end, *tport, *tend;
 
-	port = &dev->res.port_resource[idx].start;
-	end = &dev->res.port_resource[idx].end;
+	res = &dev->res.port_resource[idx];
+	port = &res->start;
+	end = &res->end;
 
 	/* if the resource doesn't exist, don't complain about it */
-	if (cannot_compare(dev->res.port_resource[idx].flags))
+	if (cannot_compare(res->flags))
 		return 1;
 
 	/* check if the resource is already in use, skip if the
@@ -269,9 +271,10 @@ int pnp_check_port(struct pnp_dev *dev, int idx)
 
 	/* check for internal conflicts */
 	for (i = 0; i < PNP_MAX_PORT && i != idx; i++) {
-		if (dev->res.port_resource[i].flags & IORESOURCE_IO) {
-			tport = &dev->res.port_resource[i].start;
-			tend = &dev->res.port_resource[i].end;
+		tres = &dev->res.port_resource[i];
+		if (tres->flags & IORESOURCE_IO) {
+			tport = &tres->start;
+			tend = &tres->end;
 			if (ranged_conflict(port, end, tport, tend))
 				return 0;
 		}
@@ -282,12 +285,12 @@ int pnp_check_port(struct pnp_dev *dev, int idx)
 		if (tdev == dev)
 			continue;
 		for (i = 0; i < PNP_MAX_PORT; i++) {
-			if (tdev->res.port_resource[i].flags & IORESOURCE_IO) {
-				if (cannot_compare
-				    (tdev->res.port_resource[i].flags))
+			tres = &tdev->res.port_resource[i];
+			if (tres->flags & IORESOURCE_IO) {
+				if (cannot_compare(tres->flags))
 					continue;
-				tport = &tdev->res.port_resource[i].start;
-				tend = &tdev->res.port_resource[i].end;
+				tport = &tres->start;
+				tend = &tres->end;
 				if (ranged_conflict(port, end, tport, tend))
 					return 0;
 			}
@@ -301,13 +304,15 @@ int pnp_check_mem(struct pnp_dev *dev, int idx)
 {
 	int i;
 	struct pnp_dev *tdev;
+	struct resource *res, *tres;
 	resource_size_t *addr, *end, *taddr, *tend;
 
-	addr = &dev->res.mem_resource[idx].start;
-	end = &dev->res.mem_resource[idx].end;
+	res = &dev->res.mem_resource[idx];
+	addr = &res->start;
+	end = &res->end;
 
 	/* if the resource doesn't exist, don't complain about it */
-	if (cannot_compare(dev->res.mem_resource[idx].flags))
+	if (cannot_compare(res->flags))
 		return 1;
 
 	/* check if the resource is already in use, skip if the
@@ -327,9 +332,10 @@ int pnp_check_mem(struct pnp_dev *dev, int idx)
 
 	/* check for internal conflicts */
 	for (i = 0; i < PNP_MAX_MEM && i != idx; i++) {
-		if (dev->res.mem_resource[i].flags & IORESOURCE_MEM) {
-			taddr = &dev->res.mem_resource[i].start;
-			tend = &dev->res.mem_resource[i].end;
+		tres = &dev->res.mem_resource[i];
+		if (tres->flags & IORESOURCE_MEM) {
+			taddr = &tres->start;
+			tend = &tres->end;
 			if (ranged_conflict(addr, end, taddr, tend))
 				return 0;
 		}
@@ -340,12 +346,12 @@ int pnp_check_mem(struct pnp_dev *dev, int idx)
 		if (tdev == dev)
 			continue;
 		for (i = 0; i < PNP_MAX_MEM; i++) {
-			if (tdev->res.mem_resource[i].flags & IORESOURCE_MEM) {
-				if (cannot_compare
-				    (tdev->res.mem_resource[i].flags))
+			tres = &tdev->res.mem_resource[i];
+			if (tres->flags & IORESOURCE_MEM) {
+				if (cannot_compare(tres->flags))
 					continue;
-				taddr = &tdev->res.mem_resource[i].start;
-				tend = &tdev->res.mem_resource[i].end;
+				taddr = &tres->start;
+				tend = &tres->end;
 				if (ranged_conflict(addr, end, taddr, tend))
 					return 0;
 			}
@@ -364,10 +370,14 @@ int pnp_check_irq(struct pnp_dev *dev, int idx)
 {
 	int i;
 	struct pnp_dev *tdev;
-	resource_size_t *irq = &dev->res.irq_resource[idx].start;
+	struct resource *res, *tres;
+	resource_size_t *irq;
+
+	res = &dev->res.irq_resource[idx];
+	irq = &res->start;
 
 	/* if the resource doesn't exist, don't complain about it */
-	if (cannot_compare(dev->res.irq_resource[idx].flags))
+	if (cannot_compare(res->flags))
 		return 1;
 
 	/* check if the resource is valid */
@@ -382,8 +392,9 @@ int pnp_check_irq(struct pnp_dev *dev, int idx)
 
 	/* check for internal conflicts */
 	for (i = 0; i < PNP_MAX_IRQ && i != idx; i++) {
-		if (dev->res.irq_resource[i].flags & IORESOURCE_IRQ) {
-			if (dev->res.irq_resource[i].start == *irq)
+		tres = &dev->res.irq_resource[i];
+		if (tres->flags & IORESOURCE_IRQ) {
+			if (tres->start == *irq)
 				return 0;
 		}
 	}
@@ -415,11 +426,11 @@ int pnp_check_irq(struct pnp_dev *dev, int idx)
 		if (tdev == dev)
 			continue;
 		for (i = 0; i < PNP_MAX_IRQ; i++) {
-			if (tdev->res.irq_resource[i].flags & IORESOURCE_IRQ) {
-				if (cannot_compare
-				    (tdev->res.irq_resource[i].flags))
+			tres = &tdev->res.irq_resource[i];
+			if (tres->flags & IORESOURCE_IRQ) {
+				if (cannot_compare(tres->flags))
 					continue;
-				if ((tdev->res.irq_resource[i].start == *irq))
+				if (tres->start == *irq)
 					return 0;
 			}
 		}
@@ -433,10 +444,14 @@ int pnp_check_dma(struct pnp_dev *dev, int idx)
 #ifndef CONFIG_IA64
 	int i;
 	struct pnp_dev *tdev;
-	resource_size_t *dma = &dev->res.dma_resource[idx].start;
+	struct resource *res, *tres;
+	resource_size_t *dma;
+
+	res = &dev->res.dma_resource[idx];
+	dma = &res->start;
 
 	/* if the resource doesn't exist, don't complain about it */
-	if (cannot_compare(dev->res.dma_resource[idx].flags))
+	if (cannot_compare(res->flags))
 		return 1;
 
 	/* check if the resource is valid */
@@ -451,8 +466,9 @@ int pnp_check_dma(struct pnp_dev *dev, int idx)
 
 	/* check for internal conflicts */
 	for (i = 0; i < PNP_MAX_DMA && i != idx; i++) {
-		if (dev->res.dma_resource[i].flags & IORESOURCE_DMA) {
-			if (dev->res.dma_resource[i].start == *dma)
+		tres = &dev->res.dma_resource[i];
+		if (tres->flags & IORESOURCE_DMA) {
+			if (tres->start == *dma)
 				return 0;
 		}
 	}
@@ -470,11 +486,11 @@ int pnp_check_dma(struct pnp_dev *dev, int idx)
 		if (tdev == dev)
 			continue;
 		for (i = 0; i < PNP_MAX_DMA; i++) {
-			if (tdev->res.dma_resource[i].flags & IORESOURCE_DMA) {
-				if (cannot_compare
-				    (tdev->res.dma_resource[i].flags))
+			tres = &tdev->res.dma_resource[i];
+			if (tres->flags & IORESOURCE_DMA) {
+				if (cannot_compare(tres->flags))
 					continue;
-				if ((tdev->res.dma_resource[i].start == *dma))
+				if (tres->start == *dma)
 					return 0;
 			}
 		}

commit ecfa935a2f7ef89543608f3ca05340c158c9a236
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Apr 28 16:34:17 2008 -0600

    PNP: use conventional "i" for loop indices
    
    Cosmetic only: just use "i" instead of "tmp".
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Acked-By: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/resource.c b/drivers/pnp/resource.c
index ef8835ec5778..15995f9f8b7c 100644
--- a/drivers/pnp/resource.c
+++ b/drivers/pnp/resource.c
@@ -241,7 +241,7 @@ void pnp_free_option(struct pnp_option *option)
 
 int pnp_check_port(struct pnp_dev *dev, int idx)
 {
-	int tmp;
+	int i;
 	struct pnp_dev *tdev;
 	resource_size_t *port, *end, *tport, *tend;
 
@@ -260,18 +260,18 @@ int pnp_check_port(struct pnp_dev *dev, int idx)
 	}
 
 	/* check if the resource is reserved */
-	for (tmp = 0; tmp < 8; tmp++) {
-		int rport = pnp_reserve_io[tmp << 1];
-		int rend = pnp_reserve_io[(tmp << 1) + 1] + rport - 1;
+	for (i = 0; i < 8; i++) {
+		int rport = pnp_reserve_io[i << 1];
+		int rend = pnp_reserve_io[(i << 1) + 1] + rport - 1;
 		if (ranged_conflict(port, end, &rport, &rend))
 			return 0;
 	}
 
 	/* check for internal conflicts */
-	for (tmp = 0; tmp < PNP_MAX_PORT && tmp != idx; tmp++) {
-		if (dev->res.port_resource[tmp].flags & IORESOURCE_IO) {
-			tport = &dev->res.port_resource[tmp].start;
-			tend = &dev->res.port_resource[tmp].end;
+	for (i = 0; i < PNP_MAX_PORT && i != idx; i++) {
+		if (dev->res.port_resource[i].flags & IORESOURCE_IO) {
+			tport = &dev->res.port_resource[i].start;
+			tend = &dev->res.port_resource[i].end;
 			if (ranged_conflict(port, end, tport, tend))
 				return 0;
 		}
@@ -281,13 +281,13 @@ int pnp_check_port(struct pnp_dev *dev, int idx)
 	pnp_for_each_dev(tdev) {
 		if (tdev == dev)
 			continue;
-		for (tmp = 0; tmp < PNP_MAX_PORT; tmp++) {
-			if (tdev->res.port_resource[tmp].flags & IORESOURCE_IO) {
+		for (i = 0; i < PNP_MAX_PORT; i++) {
+			if (tdev->res.port_resource[i].flags & IORESOURCE_IO) {
 				if (cannot_compare
-				    (tdev->res.port_resource[tmp].flags))
+				    (tdev->res.port_resource[i].flags))
 					continue;
-				tport = &tdev->res.port_resource[tmp].start;
-				tend = &tdev->res.port_resource[tmp].end;
+				tport = &tdev->res.port_resource[i].start;
+				tend = &tdev->res.port_resource[i].end;
 				if (ranged_conflict(port, end, tport, tend))
 					return 0;
 			}
@@ -299,7 +299,7 @@ int pnp_check_port(struct pnp_dev *dev, int idx)
 
 int pnp_check_mem(struct pnp_dev *dev, int idx)
 {
-	int tmp;
+	int i;
 	struct pnp_dev *tdev;
 	resource_size_t *addr, *end, *taddr, *tend;
 
@@ -318,18 +318,18 @@ int pnp_check_mem(struct pnp_dev *dev, int idx)
 	}
 
 	/* check if the resource is reserved */
-	for (tmp = 0; tmp < 8; tmp++) {
-		int raddr = pnp_reserve_mem[tmp << 1];
-		int rend = pnp_reserve_mem[(tmp << 1) + 1] + raddr - 1;
+	for (i = 0; i < 8; i++) {
+		int raddr = pnp_reserve_mem[i << 1];
+		int rend = pnp_reserve_mem[(i << 1) + 1] + raddr - 1;
 		if (ranged_conflict(addr, end, &raddr, &rend))
 			return 0;
 	}
 
 	/* check for internal conflicts */
-	for (tmp = 0; tmp < PNP_MAX_MEM && tmp != idx; tmp++) {
-		if (dev->res.mem_resource[tmp].flags & IORESOURCE_MEM) {
-			taddr = &dev->res.mem_resource[tmp].start;
-			tend = &dev->res.mem_resource[tmp].end;
+	for (i = 0; i < PNP_MAX_MEM && i != idx; i++) {
+		if (dev->res.mem_resource[i].flags & IORESOURCE_MEM) {
+			taddr = &dev->res.mem_resource[i].start;
+			tend = &dev->res.mem_resource[i].end;
 			if (ranged_conflict(addr, end, taddr, tend))
 				return 0;
 		}
@@ -339,13 +339,13 @@ int pnp_check_mem(struct pnp_dev *dev, int idx)
 	pnp_for_each_dev(tdev) {
 		if (tdev == dev)
 			continue;
-		for (tmp = 0; tmp < PNP_MAX_MEM; tmp++) {
-			if (tdev->res.mem_resource[tmp].flags & IORESOURCE_MEM) {
+		for (i = 0; i < PNP_MAX_MEM; i++) {
+			if (tdev->res.mem_resource[i].flags & IORESOURCE_MEM) {
 				if (cannot_compare
-				    (tdev->res.mem_resource[tmp].flags))
+				    (tdev->res.mem_resource[i].flags))
 					continue;
-				taddr = &tdev->res.mem_resource[tmp].start;
-				tend = &tdev->res.mem_resource[tmp].end;
+				taddr = &tdev->res.mem_resource[i].start;
+				tend = &tdev->res.mem_resource[i].end;
 				if (ranged_conflict(addr, end, taddr, tend))
 					return 0;
 			}
@@ -362,7 +362,7 @@ static irqreturn_t pnp_test_handler(int irq, void *dev_id)
 
 int pnp_check_irq(struct pnp_dev *dev, int idx)
 {
-	int tmp;
+	int i;
 	struct pnp_dev *tdev;
 	resource_size_t *irq = &dev->res.irq_resource[idx].start;
 
@@ -375,15 +375,15 @@ int pnp_check_irq(struct pnp_dev *dev, int idx)
 		return 0;
 
 	/* check if the resource is reserved */
-	for (tmp = 0; tmp < 16; tmp++) {
-		if (pnp_reserve_irq[tmp] == *irq)
+	for (i = 0; i < 16; i++) {
+		if (pnp_reserve_irq[i] == *irq)
 			return 0;
 	}
 
 	/* check for internal conflicts */
-	for (tmp = 0; tmp < PNP_MAX_IRQ && tmp != idx; tmp++) {
-		if (dev->res.irq_resource[tmp].flags & IORESOURCE_IRQ) {
-			if (dev->res.irq_resource[tmp].start == *irq)
+	for (i = 0; i < PNP_MAX_IRQ && i != idx; i++) {
+		if (dev->res.irq_resource[i].flags & IORESOURCE_IRQ) {
+			if (dev->res.irq_resource[i].start == *irq)
 				return 0;
 		}
 	}
@@ -414,12 +414,12 @@ int pnp_check_irq(struct pnp_dev *dev, int idx)
 	pnp_for_each_dev(tdev) {
 		if (tdev == dev)
 			continue;
-		for (tmp = 0; tmp < PNP_MAX_IRQ; tmp++) {
-			if (tdev->res.irq_resource[tmp].flags & IORESOURCE_IRQ) {
+		for (i = 0; i < PNP_MAX_IRQ; i++) {
+			if (tdev->res.irq_resource[i].flags & IORESOURCE_IRQ) {
 				if (cannot_compare
-				    (tdev->res.irq_resource[tmp].flags))
+				    (tdev->res.irq_resource[i].flags))
 					continue;
-				if ((tdev->res.irq_resource[tmp].start == *irq))
+				if ((tdev->res.irq_resource[i].start == *irq))
 					return 0;
 			}
 		}
@@ -431,7 +431,7 @@ int pnp_check_irq(struct pnp_dev *dev, int idx)
 int pnp_check_dma(struct pnp_dev *dev, int idx)
 {
 #ifndef CONFIG_IA64
-	int tmp;
+	int i;
 	struct pnp_dev *tdev;
 	resource_size_t *dma = &dev->res.dma_resource[idx].start;
 
@@ -444,15 +444,15 @@ int pnp_check_dma(struct pnp_dev *dev, int idx)
 		return 0;
 
 	/* check if the resource is reserved */
-	for (tmp = 0; tmp < 8; tmp++) {
-		if (pnp_reserve_dma[tmp] == *dma)
+	for (i = 0; i < 8; i++) {
+		if (pnp_reserve_dma[i] == *dma)
 			return 0;
 	}
 
 	/* check for internal conflicts */
-	for (tmp = 0; tmp < PNP_MAX_DMA && tmp != idx; tmp++) {
-		if (dev->res.dma_resource[tmp].flags & IORESOURCE_DMA) {
-			if (dev->res.dma_resource[tmp].start == *dma)
+	for (i = 0; i < PNP_MAX_DMA && i != idx; i++) {
+		if (dev->res.dma_resource[i].flags & IORESOURCE_DMA) {
+			if (dev->res.dma_resource[i].start == *dma)
 				return 0;
 		}
 	}
@@ -469,12 +469,12 @@ int pnp_check_dma(struct pnp_dev *dev, int idx)
 	pnp_for_each_dev(tdev) {
 		if (tdev == dev)
 			continue;
-		for (tmp = 0; tmp < PNP_MAX_DMA; tmp++) {
-			if (tdev->res.dma_resource[tmp].flags & IORESOURCE_DMA) {
+		for (i = 0; i < PNP_MAX_DMA; i++) {
+			if (tdev->res.dma_resource[i].flags & IORESOURCE_DMA) {
 				if (cannot_compare
-				    (tdev->res.dma_resource[tmp].flags))
+				    (tdev->res.dma_resource[i].flags))
 					continue;
-				if ((tdev->res.dma_resource[tmp].start == *dma))
+				if ((tdev->res.dma_resource[i].start == *dma))
 					return 0;
 			}
 		}

commit b90eca0a61ebd010036242e29610bc6a909e3f19
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Apr 28 16:34:14 2008 -0600

    PNP: add pnp_get_resource() interface
    
    This adds a pnp_get_resource() that works the same way as
    platform_get_resource().  This will enable us to consolidate
    many pnp_resource_table references in one place, which will
    make it easier to make the table dynamic.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Acked-By: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/resource.c b/drivers/pnp/resource.c
index eee6d8eddcb4..ef8835ec5778 100644
--- a/drivers/pnp/resource.c
+++ b/drivers/pnp/resource.c
@@ -487,6 +487,33 @@ int pnp_check_dma(struct pnp_dev *dev, int idx)
 #endif
 }
 
+struct resource *pnp_get_resource(struct pnp_dev *dev,
+				  unsigned int type, unsigned int num)
+{
+	struct pnp_resource_table *res = &dev->res;
+
+	switch (type) {
+	case IORESOURCE_IO:
+		if (num >= PNP_MAX_PORT)
+			return NULL;
+		return &res->port_resource[num];
+	case IORESOURCE_MEM:
+		if (num >= PNP_MAX_MEM)
+			return NULL;
+		return &res->mem_resource[num];
+	case IORESOURCE_IRQ:
+		if (num >= PNP_MAX_IRQ)
+			return NULL;
+		return &res->irq_resource[num];
+	case IORESOURCE_DMA:
+		if (num >= PNP_MAX_DMA)
+			return NULL;
+		return &res->dma_resource[num];
+	}
+	return NULL;
+}
+EXPORT_SYMBOL(pnp_get_resource);
+
 /* format is: pnp_reserve_irq=irq1[,irq2] .... */
 static int __init pnp_setup_reserve_irq(char *str)
 {

commit c1caf06ccfd3a4efd4b489f89bcdabd2362f31d0
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Apr 28 16:34:04 2008 -0600

    PNP: add debug output to option registration
    
    Add debug output to resource option registration functions (enabled
    by CONFIG_PNP_DEBUG).  This uses dev_printk, so I had to add pnp_dev
    arguments at the same time.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Acked-By: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/resource.c b/drivers/pnp/resource.c
index e50ebcffb962..eee6d8eddcb4 100644
--- a/drivers/pnp/resource.c
+++ b/drivers/pnp/resource.c
@@ -53,6 +53,8 @@ struct pnp_option *pnp_register_independent_option(struct pnp_dev *dev)
 	if (dev->independent)
 		dev_err(&dev->dev, "independent resource already registered\n");
 	dev->independent = option;
+
+	dev_dbg(&dev->dev, "new independent option\n");
 	return option;
 }
 
@@ -70,12 +72,18 @@ struct pnp_option *pnp_register_dependent_option(struct pnp_dev *dev,
 		parent->next = option;
 	} else
 		dev->dependent = option;
+
+	dev_dbg(&dev->dev, "new dependent option (priority %#x)\n", priority);
 	return option;
 }
 
-int pnp_register_irq_resource(struct pnp_option *option, struct pnp_irq *data)
+int pnp_register_irq_resource(struct pnp_dev *dev, struct pnp_option *option,
+			      struct pnp_irq *data)
 {
 	struct pnp_irq *ptr;
+#ifdef DEBUG
+	char buf[PNP_IRQ_NR];   /* hex-encoded, so this is overkill but safe */
+#endif
 
 	ptr = option->irq;
 	while (ptr && ptr->next)
@@ -94,10 +102,17 @@ int pnp_register_irq_resource(struct pnp_option *option, struct pnp_irq *data)
 				pcibios_penalize_isa_irq(i, 0);
 	}
 #endif
+
+#ifdef DEBUG
+	bitmap_scnprintf(buf, sizeof(buf), data->map, PNP_IRQ_NR);
+	dev_dbg(&dev->dev, "  irq bitmask %s flags %#x\n", buf,
+		data->flags);
+#endif
 	return 0;
 }
 
-int pnp_register_dma_resource(struct pnp_option *option, struct pnp_dma *data)
+int pnp_register_dma_resource(struct pnp_dev *dev, struct pnp_option *option,
+			      struct pnp_dma *data)
 {
 	struct pnp_dma *ptr;
 
@@ -109,10 +124,13 @@ int pnp_register_dma_resource(struct pnp_option *option, struct pnp_dma *data)
 	else
 		option->dma = data;
 
+	dev_dbg(&dev->dev, "  dma bitmask %#x flags %#x\n", data->map,
+		data->flags);
 	return 0;
 }
 
-int pnp_register_port_resource(struct pnp_option *option, struct pnp_port *data)
+int pnp_register_port_resource(struct pnp_dev *dev, struct pnp_option *option,
+			       struct pnp_port *data)
 {
 	struct pnp_port *ptr;
 
@@ -124,10 +142,14 @@ int pnp_register_port_resource(struct pnp_option *option, struct pnp_port *data)
 	else
 		option->port = data;
 
+	dev_dbg(&dev->dev, "  io  "
+		"min %#x max %#x align %d size %d flags %#x\n",
+		data->min, data->max, data->align, data->size, data->flags);
 	return 0;
 }
 
-int pnp_register_mem_resource(struct pnp_option *option, struct pnp_mem *data)
+int pnp_register_mem_resource(struct pnp_dev *dev, struct pnp_option *option,
+			      struct pnp_mem *data)
 {
 	struct pnp_mem *ptr;
 
@@ -138,6 +160,10 @@ int pnp_register_mem_resource(struct pnp_option *option, struct pnp_mem *data)
 		ptr->next = data;
 	else
 		option->mem = data;
+
+	dev_dbg(&dev->dev, "  mem "
+		"min %#x max %#x align %d size %d flags %#x\n",
+		data->min, data->max, data->align, data->size, data->flags);
 	return 0;
 }
 

commit 8ea50a3f0b70977939d2d9d3671b8173482afff2
Author: Julia Lawall <julia@diku.dk>
Date:   Wed Nov 28 16:21:36 2007 -0800

    drivers/pnp/resource.c: Add missing pci_dev_put
    
    There should be a pci_dev_put when breaking out of a loop that iterates
    over calls to pci_get_device and similar functions.
    
    This was fixed using the following semantic patch.
    
    // <smpl>
    @@
    identifier d;
    type T;
    expression e;
    iterator for_each_pci_dev;
    @@
    
    T *d;
    ...
    for_each_pci_dev(d)
       {... when != pci_dev_put(d)
            when != e = d
    (
        return d;
    |
    +  pci_dev_put(d);
    ?  return ...;
    )
    ...}
    // </smpl>
    
    Signed-off-by: Julia Lawall <julia@diku.dk>
    Cc: Greg KH <greg@kroah.com>
    Cc: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pnp/resource.c b/drivers/pnp/resource.c
index 41d73a5e9312..e50ebcffb962 100644
--- a/drivers/pnp/resource.c
+++ b/drivers/pnp/resource.c
@@ -367,8 +367,10 @@ int pnp_check_irq(struct pnp_dev *dev, int idx)
 	{
 		struct pci_dev *pci = NULL;
 		for_each_pci_dev(pci) {
-			if (pci->irq == *irq)
+			if (pci->irq == *irq) {
+				pci_dev_put(pci);
 				return 0;
+			}
 		}
 	}
 #endif

commit a05d0781695566296e74a3670dd5bbd3daf24ae2
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Oct 16 23:31:10 2007 -0700

    PNP: use dev_info(), dev_err(), etc in core
    
    If we have the struct pnp_dev available, we can use dev_info(), dev_err(),
    etc., to give a little more information and consistency.
    
    [akpm@linux-foundation.org: fix warning]
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Cc: Adam Belay <ambx1@neo.rr.com>
    Cc: Len Brown <lenb@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pnp/resource.c b/drivers/pnp/resource.c
index 087fed18628f..41d73a5e9312 100644
--- a/drivers/pnp/resource.c
+++ b/drivers/pnp/resource.c
@@ -51,7 +51,7 @@ struct pnp_option *pnp_register_independent_option(struct pnp_dev *dev)
 
 	/* this should never happen but if it does we'll try to continue */
 	if (dev->independent)
-		pnp_err("independent resource already registered");
+		dev_err(&dev->dev, "independent resource already registered\n");
 	dev->independent = option;
 	return option;
 }

commit c1017a4cdb68ae5368fbc9ee42c77f1f5dca8916
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Mon Oct 15 09:50:19 2007 +0200

    [ALSA] Changed Jaroslav Kysela's e-mail from perex@suse.cz to perex@perex.cz
    
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/drivers/pnp/resource.c b/drivers/pnp/resource.c
index ef1286900db3..087fed18628f 100644
--- a/drivers/pnp/resource.c
+++ b/drivers/pnp/resource.c
@@ -1,7 +1,7 @@
 /*
  * resource.c - Contains functions for registering and analyzing resource information
  *
- * based on isapnp.c resource management (c) Jaroslav Kysela <perex@suse.cz>
+ * based on isapnp.c resource management (c) Jaroslav Kysela <perex@perex.cz>
  * Copyright 2003 Adam Belay <ambx1@neo.rr.com>
  */
 

commit b173491339b9ae7f1322241ce6228c1268513a39
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Wed Aug 15 10:32:13 2007 -0600

    PNP: remove null pointer checks
    
    Remove some null pointer checks.  Null pointers in these areas indicate
    programming errors, and I think it's better to oops immediately rather
    than return an error that is easily ignored.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Acked-by: Adam Belay <abelay@novell.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/resource.c b/drivers/pnp/resource.c
index ea6ec14a0559..ef1286900db3 100644
--- a/drivers/pnp/resource.c
+++ b/drivers/pnp/resource.c
@@ -47,9 +47,6 @@ struct pnp_option *pnp_register_independent_option(struct pnp_dev *dev)
 {
 	struct pnp_option *option;
 
-	if (!dev)
-		return NULL;
-
 	option = pnp_build_option(PNP_RES_PRIORITY_PREFERRED);
 
 	/* this should never happen but if it does we'll try to continue */
@@ -64,9 +61,6 @@ struct pnp_option *pnp_register_dependent_option(struct pnp_dev *dev,
 {
 	struct pnp_option *option;
 
-	if (!dev)
-		return NULL;
-
 	option = pnp_build_option(priority);
 
 	if (dev->dependent) {
@@ -83,11 +77,6 @@ int pnp_register_irq_resource(struct pnp_option *option, struct pnp_irq *data)
 {
 	struct pnp_irq *ptr;
 
-	if (!option)
-		return -EINVAL;
-	if (!data)
-		return -EINVAL;
-
 	ptr = option->irq;
 	while (ptr && ptr->next)
 		ptr = ptr->next;
@@ -112,11 +101,6 @@ int pnp_register_dma_resource(struct pnp_option *option, struct pnp_dma *data)
 {
 	struct pnp_dma *ptr;
 
-	if (!option)
-		return -EINVAL;
-	if (!data)
-		return -EINVAL;
-
 	ptr = option->dma;
 	while (ptr && ptr->next)
 		ptr = ptr->next;
@@ -132,11 +116,6 @@ int pnp_register_port_resource(struct pnp_option *option, struct pnp_port *data)
 {
 	struct pnp_port *ptr;
 
-	if (!option)
-		return -EINVAL;
-	if (!data)
-		return -EINVAL;
-
 	ptr = option->port;
 	while (ptr && ptr->next)
 		ptr = ptr->next;
@@ -152,11 +131,6 @@ int pnp_register_mem_resource(struct pnp_option *option, struct pnp_mem *data)
 {
 	struct pnp_mem *ptr;
 
-	if (!option)
-		return -EINVAL;
-	if (!data)
-		return -EINVAL;
-
 	ptr = option->mem;
 	while (ptr && ptr->next)
 		ptr = ptr->next;

commit 07d4e9af109221ab731c5aaf832e89776c64b013
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Thu Jul 26 10:41:21 2007 -0700

    PNP: fix up after Lindent
    
    These are manual fixups after running Lindent.  No functional change.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Adam Belay <ambx1@neo.rr.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pnp/resource.c b/drivers/pnp/resource.c
index 635b11a0cf82..ea6ec14a0559 100644
--- a/drivers/pnp/resource.c
+++ b/drivers/pnp/resource.c
@@ -3,7 +3,6 @@
  *
  * based on isapnp.c resource management (c) Jaroslav Kysela <perex@suse.cz>
  * Copyright 2003 Adam Belay <ambx1@neo.rr.com>
- *
  */
 
 #include <linux/module.h>
@@ -20,10 +19,10 @@
 #include <linux/pnp.h>
 #include "base.h"
 
-static int pnp_reserve_irq[16] = {[0...15] = -1 };	/* reserve (don't use) some IRQ */
-static int pnp_reserve_dma[8] = {[0...7] = -1 };	/* reserve (don't use) some DMA */
-static int pnp_reserve_io[16] = {[0...15] = -1 };	/* reserve (don't use) some I/O region */
-static int pnp_reserve_mem[16] = {[0...15] = -1 };	/* reserve (don't use) some memory region */
+static int pnp_reserve_irq[16] = {[0 ... 15] = -1 };	/* reserve (don't use) some IRQ */
+static int pnp_reserve_dma[8] = {[0 ... 7] = -1 };	/* reserve (don't use) some DMA */
+static int pnp_reserve_io[16] = {[0 ... 15] = -1 };	/* reserve (don't use) some I/O region */
+static int pnp_reserve_mem[16] = {[0 ... 15] = -1 };	/* reserve (don't use) some memory region */
 
 /*
  * option registration
@@ -33,7 +32,6 @@ static struct pnp_option *pnp_build_option(int priority)
 {
 	struct pnp_option *option = pnp_alloc(sizeof(struct pnp_option));
 
-	/* check if pnp_alloc ran out of memory */
 	if (!option)
 		return NULL;
 
@@ -48,6 +46,7 @@ static struct pnp_option *pnp_build_option(int priority)
 struct pnp_option *pnp_register_independent_option(struct pnp_dev *dev)
 {
 	struct pnp_option *option;
+
 	if (!dev)
 		return NULL;
 
@@ -64,6 +63,7 @@ struct pnp_option *pnp_register_dependent_option(struct pnp_dev *dev,
 						 int priority)
 {
 	struct pnp_option *option;
+
 	if (!dev)
 		return NULL;
 
@@ -82,6 +82,7 @@ struct pnp_option *pnp_register_dependent_option(struct pnp_dev *dev,
 int pnp_register_irq_resource(struct pnp_option *option, struct pnp_irq *data)
 {
 	struct pnp_irq *ptr;
+
 	if (!option)
 		return -EINVAL;
 	if (!data)
@@ -110,6 +111,7 @@ int pnp_register_irq_resource(struct pnp_option *option, struct pnp_irq *data)
 int pnp_register_dma_resource(struct pnp_option *option, struct pnp_dma *data)
 {
 	struct pnp_dma *ptr;
+
 	if (!option)
 		return -EINVAL;
 	if (!data)
@@ -129,6 +131,7 @@ int pnp_register_dma_resource(struct pnp_option *option, struct pnp_dma *data)
 int pnp_register_port_resource(struct pnp_option *option, struct pnp_port *data)
 {
 	struct pnp_port *ptr;
+
 	if (!option)
 		return -EINVAL;
 	if (!data)
@@ -148,6 +151,7 @@ int pnp_register_port_resource(struct pnp_option *option, struct pnp_port *data)
 int pnp_register_mem_resource(struct pnp_option *option, struct pnp_mem *data)
 {
 	struct pnp_mem *ptr;
+
 	if (!option)
 		return -EINVAL;
 	if (!data)
@@ -240,6 +244,7 @@ int pnp_check_port(struct pnp_dev *dev, int idx)
 	int tmp;
 	struct pnp_dev *tdev;
 	resource_size_t *port, *end, *tport, *tend;
+
 	port = &dev->res.port_resource[idx].start;
 	end = &dev->res.port_resource[idx].end;
 
@@ -297,6 +302,7 @@ int pnp_check_mem(struct pnp_dev *dev, int idx)
 	int tmp;
 	struct pnp_dev *tdev;
 	resource_size_t *addr, *end, *taddr, *tend;
+
 	addr = &dev->res.mem_resource[idx].start;
 	end = &dev->res.mem_resource[idx].end;
 
@@ -474,22 +480,12 @@ int pnp_check_dma(struct pnp_dev *dev, int idx)
 
 	return 1;
 #else
-	/* IA64 hasn't legacy DMA */
+	/* IA64 does not have legacy DMA */
 	return 0;
 #endif
 }
 
-#if 0
-EXPORT_SYMBOL(pnp_register_dependent_option);
-EXPORT_SYMBOL(pnp_register_independent_option);
-EXPORT_SYMBOL(pnp_register_irq_resource);
-EXPORT_SYMBOL(pnp_register_dma_resource);
-EXPORT_SYMBOL(pnp_register_port_resource);
-EXPORT_SYMBOL(pnp_register_mem_resource);
-#endif /*  0  */
-
 /* format is: pnp_reserve_irq=irq1[,irq2] .... */
-
 static int __init pnp_setup_reserve_irq(char *str)
 {
 	int i;
@@ -503,7 +499,6 @@ static int __init pnp_setup_reserve_irq(char *str)
 __setup("pnp_reserve_irq=", pnp_setup_reserve_irq);
 
 /* format is: pnp_reserve_dma=dma1[,dma2] .... */
-
 static int __init pnp_setup_reserve_dma(char *str)
 {
 	int i;
@@ -517,7 +512,6 @@ static int __init pnp_setup_reserve_dma(char *str)
 __setup("pnp_reserve_dma=", pnp_setup_reserve_dma);
 
 /* format is: pnp_reserve_io=io1,size1[,io2,size2] .... */
-
 static int __init pnp_setup_reserve_io(char *str)
 {
 	int i;
@@ -531,7 +525,6 @@ static int __init pnp_setup_reserve_io(char *str)
 __setup("pnp_reserve_io=", pnp_setup_reserve_io);
 
 /* format is: pnp_reserve_mem=mem1,size1[,mem2,size2] .... */
-
 static int __init pnp_setup_reserve_mem(char *str)
 {
 	int i;

commit 9dd78466c956ac4b4f38e12032dc4249ccf57ad1
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Thu Jul 26 10:41:20 2007 -0700

    PNP: Lindent all source files
    
    Run Lindent on all PNP source files.
    
    Produced by:
    
        $ quilt new pnp-lindent
        $ find drivers/pnp -name \*.[ch] | xargs quilt add
        $ quilt add include/linux/{pnp.h,pnpbios.h}
        $ scripts/Lindent drivers/pnp/*.c drivers/pnp/*/*.c include/linux/pnp*.h
        $ quilt refresh --sort
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Adam Belay <ambx1@neo.rr.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pnp/resource.c b/drivers/pnp/resource.c
index a685fbec4604..635b11a0cf82 100644
--- a/drivers/pnp/resource.c
+++ b/drivers/pnp/resource.c
@@ -20,17 +20,16 @@
 #include <linux/pnp.h>
 #include "base.h"
 
-static int pnp_reserve_irq[16] = { [0 ... 15] = -1 };	/* reserve (don't use) some IRQ */
-static int pnp_reserve_dma[8] = { [0 ... 7] = -1 };	/* reserve (don't use) some DMA */
-static int pnp_reserve_io[16] = { [0 ... 15] = -1 };	/* reserve (don't use) some I/O region */
-static int pnp_reserve_mem[16] = { [0 ... 15] = -1 };	/* reserve (don't use) some memory region */
-
+static int pnp_reserve_irq[16] = {[0...15] = -1 };	/* reserve (don't use) some IRQ */
+static int pnp_reserve_dma[8] = {[0...7] = -1 };	/* reserve (don't use) some DMA */
+static int pnp_reserve_io[16] = {[0...15] = -1 };	/* reserve (don't use) some I/O region */
+static int pnp_reserve_mem[16] = {[0...15] = -1 };	/* reserve (don't use) some memory region */
 
 /*
  * option registration
  */
 
-static struct pnp_option * pnp_build_option(int priority)
+static struct pnp_option *pnp_build_option(int priority)
 {
 	struct pnp_option *option = pnp_alloc(sizeof(struct pnp_option));
 
@@ -46,7 +45,7 @@ static struct pnp_option * pnp_build_option(int priority)
 	return option;
 }
 
-struct pnp_option * pnp_register_independent_option(struct pnp_dev *dev)
+struct pnp_option *pnp_register_independent_option(struct pnp_dev *dev)
 {
 	struct pnp_option *option;
 	if (!dev)
@@ -61,7 +60,8 @@ struct pnp_option * pnp_register_independent_option(struct pnp_dev *dev)
 	return option;
 }
 
-struct pnp_option * pnp_register_dependent_option(struct pnp_dev *dev, int priority)
+struct pnp_option *pnp_register_dependent_option(struct pnp_dev *dev,
+						 int priority)
 {
 	struct pnp_option *option;
 	if (!dev)
@@ -222,7 +222,6 @@ void pnp_free_option(struct pnp_option *option)
 	}
 }
 
-
 /*
  * resource validity checking
  */
@@ -236,7 +235,7 @@ void pnp_free_option(struct pnp_option *option)
 #define cannot_compare(flags) \
 ((flags) & (IORESOURCE_UNSET | IORESOURCE_DISABLED))
 
-int pnp_check_port(struct pnp_dev * dev, int idx)
+int pnp_check_port(struct pnp_dev *dev, int idx)
 {
 	int tmp;
 	struct pnp_dev *tdev;
@@ -250,8 +249,8 @@ int pnp_check_port(struct pnp_dev * dev, int idx)
 
 	/* check if the resource is already in use, skip if the
 	 * device is active because it itself may be in use */
-	if(!dev->active) {
-		if (__check_region(&ioport_resource, *port, length(port,end)))
+	if (!dev->active) {
+		if (__check_region(&ioport_resource, *port, length(port, end)))
 			return 0;
 	}
 
@@ -259,7 +258,7 @@ int pnp_check_port(struct pnp_dev * dev, int idx)
 	for (tmp = 0; tmp < 8; tmp++) {
 		int rport = pnp_reserve_io[tmp << 1];
 		int rend = pnp_reserve_io[(tmp << 1) + 1] + rport - 1;
-		if (ranged_conflict(port,end,&rport,&rend))
+		if (ranged_conflict(port, end, &rport, &rend))
 			return 0;
 	}
 
@@ -268,7 +267,7 @@ int pnp_check_port(struct pnp_dev * dev, int idx)
 		if (dev->res.port_resource[tmp].flags & IORESOURCE_IO) {
 			tport = &dev->res.port_resource[tmp].start;
 			tend = &dev->res.port_resource[tmp].end;
-			if (ranged_conflict(port,end,tport,tend))
+			if (ranged_conflict(port, end, tport, tend))
 				return 0;
 		}
 	}
@@ -279,11 +278,12 @@ int pnp_check_port(struct pnp_dev * dev, int idx)
 			continue;
 		for (tmp = 0; tmp < PNP_MAX_PORT; tmp++) {
 			if (tdev->res.port_resource[tmp].flags & IORESOURCE_IO) {
-				if (cannot_compare(tdev->res.port_resource[tmp].flags))
+				if (cannot_compare
+				    (tdev->res.port_resource[tmp].flags))
 					continue;
 				tport = &tdev->res.port_resource[tmp].start;
 				tend = &tdev->res.port_resource[tmp].end;
-				if (ranged_conflict(port,end,tport,tend))
+				if (ranged_conflict(port, end, tport, tend))
 					return 0;
 			}
 		}
@@ -292,7 +292,7 @@ int pnp_check_port(struct pnp_dev * dev, int idx)
 	return 1;
 }
 
-int pnp_check_mem(struct pnp_dev * dev, int idx)
+int pnp_check_mem(struct pnp_dev *dev, int idx)
 {
 	int tmp;
 	struct pnp_dev *tdev;
@@ -306,8 +306,8 @@ int pnp_check_mem(struct pnp_dev * dev, int idx)
 
 	/* check if the resource is already in use, skip if the
 	 * device is active because it itself may be in use */
-	if(!dev->active) {
-		if (check_mem_region(*addr, length(addr,end)))
+	if (!dev->active) {
+		if (check_mem_region(*addr, length(addr, end)))
 			return 0;
 	}
 
@@ -315,7 +315,7 @@ int pnp_check_mem(struct pnp_dev * dev, int idx)
 	for (tmp = 0; tmp < 8; tmp++) {
 		int raddr = pnp_reserve_mem[tmp << 1];
 		int rend = pnp_reserve_mem[(tmp << 1) + 1] + raddr - 1;
-		if (ranged_conflict(addr,end,&raddr,&rend))
+		if (ranged_conflict(addr, end, &raddr, &rend))
 			return 0;
 	}
 
@@ -324,7 +324,7 @@ int pnp_check_mem(struct pnp_dev * dev, int idx)
 		if (dev->res.mem_resource[tmp].flags & IORESOURCE_MEM) {
 			taddr = &dev->res.mem_resource[tmp].start;
 			tend = &dev->res.mem_resource[tmp].end;
-			if (ranged_conflict(addr,end,taddr,tend))
+			if (ranged_conflict(addr, end, taddr, tend))
 				return 0;
 		}
 	}
@@ -335,11 +335,12 @@ int pnp_check_mem(struct pnp_dev * dev, int idx)
 			continue;
 		for (tmp = 0; tmp < PNP_MAX_MEM; tmp++) {
 			if (tdev->res.mem_resource[tmp].flags & IORESOURCE_MEM) {
-				if (cannot_compare(tdev->res.mem_resource[tmp].flags))
+				if (cannot_compare
+				    (tdev->res.mem_resource[tmp].flags))
 					continue;
 				taddr = &tdev->res.mem_resource[tmp].start;
 				tend = &tdev->res.mem_resource[tmp].end;
-				if (ranged_conflict(addr,end,taddr,tend))
+				if (ranged_conflict(addr, end, taddr, tend))
 					return 0;
 			}
 		}
@@ -353,11 +354,11 @@ static irqreturn_t pnp_test_handler(int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
-int pnp_check_irq(struct pnp_dev * dev, int idx)
+int pnp_check_irq(struct pnp_dev *dev, int idx)
 {
 	int tmp;
 	struct pnp_dev *tdev;
-	resource_size_t * irq = &dev->res.irq_resource[idx].start;
+	resource_size_t *irq = &dev->res.irq_resource[idx].start;
 
 	/* if the resource doesn't exist, don't complain about it */
 	if (cannot_compare(dev->res.irq_resource[idx].flags))
@@ -394,9 +395,9 @@ int pnp_check_irq(struct pnp_dev * dev, int idx)
 
 	/* check if the resource is already in use, skip if the
 	 * device is active because it itself may be in use */
-	if(!dev->active) {
+	if (!dev->active) {
 		if (request_irq(*irq, pnp_test_handler,
-				IRQF_DISABLED|IRQF_PROBE_SHARED, "pnp", NULL))
+				IRQF_DISABLED | IRQF_PROBE_SHARED, "pnp", NULL))
 			return 0;
 		free_irq(*irq, NULL);
 	}
@@ -407,7 +408,8 @@ int pnp_check_irq(struct pnp_dev * dev, int idx)
 			continue;
 		for (tmp = 0; tmp < PNP_MAX_IRQ; tmp++) {
 			if (tdev->res.irq_resource[tmp].flags & IORESOURCE_IRQ) {
-				if (cannot_compare(tdev->res.irq_resource[tmp].flags))
+				if (cannot_compare
+				    (tdev->res.irq_resource[tmp].flags))
 					continue;
 				if ((tdev->res.irq_resource[tmp].start == *irq))
 					return 0;
@@ -418,12 +420,12 @@ int pnp_check_irq(struct pnp_dev * dev, int idx)
 	return 1;
 }
 
-int pnp_check_dma(struct pnp_dev * dev, int idx)
+int pnp_check_dma(struct pnp_dev *dev, int idx)
 {
 #ifndef CONFIG_IA64
 	int tmp;
 	struct pnp_dev *tdev;
-	resource_size_t * dma = &dev->res.dma_resource[idx].start;
+	resource_size_t *dma = &dev->res.dma_resource[idx].start;
 
 	/* if the resource doesn't exist, don't complain about it */
 	if (cannot_compare(dev->res.dma_resource[idx].flags))
@@ -449,7 +451,7 @@ int pnp_check_dma(struct pnp_dev * dev, int idx)
 
 	/* check if the resource is already in use, skip if the
 	 * device is active because it itself may be in use */
-	if(!dev->active) {
+	if (!dev->active) {
 		if (request_dma(*dma, "pnp"))
 			return 0;
 		free_dma(*dma);
@@ -461,7 +463,8 @@ int pnp_check_dma(struct pnp_dev * dev, int idx)
 			continue;
 		for (tmp = 0; tmp < PNP_MAX_DMA; tmp++) {
 			if (tdev->res.dma_resource[tmp].flags & IORESOURCE_DMA) {
-				if (cannot_compare(tdev->res.dma_resource[tmp].flags))
+				if (cannot_compare
+				    (tdev->res.dma_resource[tmp].flags))
 					continue;
 				if ((tdev->res.dma_resource[tmp].start == *dma))
 					return 0;
@@ -476,7 +479,6 @@ int pnp_check_dma(struct pnp_dev * dev, int idx)
 #endif
 }
 
-
 #if 0
 EXPORT_SYMBOL(pnp_register_dependent_option);
 EXPORT_SYMBOL(pnp_register_independent_option);
@@ -484,8 +486,7 @@ EXPORT_SYMBOL(pnp_register_irq_resource);
 EXPORT_SYMBOL(pnp_register_dma_resource);
 EXPORT_SYMBOL(pnp_register_port_resource);
 EXPORT_SYMBOL(pnp_register_mem_resource);
-#endif  /*  0  */
-
+#endif /*  0  */
 
 /* format is: pnp_reserve_irq=irq1[,irq2] .... */
 
@@ -494,7 +495,7 @@ static int __init pnp_setup_reserve_irq(char *str)
 	int i;
 
 	for (i = 0; i < 16; i++)
-		if (get_option(&str,&pnp_reserve_irq[i]) != 2)
+		if (get_option(&str, &pnp_reserve_irq[i]) != 2)
 			break;
 	return 1;
 }
@@ -508,7 +509,7 @@ static int __init pnp_setup_reserve_dma(char *str)
 	int i;
 
 	for (i = 0; i < 8; i++)
-		if (get_option(&str,&pnp_reserve_dma[i]) != 2)
+		if (get_option(&str, &pnp_reserve_dma[i]) != 2)
 			break;
 	return 1;
 }
@@ -522,7 +523,7 @@ static int __init pnp_setup_reserve_io(char *str)
 	int i;
 
 	for (i = 0; i < 16; i++)
-		if (get_option(&str,&pnp_reserve_io[i]) != 2)
+		if (get_option(&str, &pnp_reserve_io[i]) != 2)
 			break;
 	return 1;
 }
@@ -536,7 +537,7 @@ static int __init pnp_setup_reserve_mem(char *str)
 	int i;
 
 	for (i = 0; i < 16; i++)
-		if (get_option(&str,&pnp_reserve_mem[i]) != 2)
+		if (get_option(&str, &pnp_reserve_mem[i]) != 2)
 			break;
 	return 1;
 }

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/drivers/pnp/resource.c b/drivers/pnp/resource.c
index 5c8ec21e1086..a685fbec4604 100644
--- a/drivers/pnp/resource.c
+++ b/drivers/pnp/resource.c
@@ -348,7 +348,7 @@ int pnp_check_mem(struct pnp_dev * dev, int idx)
 	return 1;
 }
 
-static irqreturn_t pnp_test_handler(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t pnp_test_handler(int irq, void *dev_id)
 {
 	return IRQ_HANDLED;
 }

commit dace145374b8e39aeb920304c358ab5e220341ab
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jul 1 19:29:38 2006 -0700

    [PATCH] irq-flags: misc drivers: Use the new IRQF_ constants
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/pnp/resource.c b/drivers/pnp/resource.c
index 9fefe563f8fc..5c8ec21e1086 100644
--- a/drivers/pnp/resource.c
+++ b/drivers/pnp/resource.c
@@ -396,7 +396,7 @@ int pnp_check_irq(struct pnp_dev * dev, int idx)
 	 * device is active because it itself may be in use */
 	if(!dev->active) {
 		if (request_irq(*irq, pnp_test_handler,
-				SA_INTERRUPT|SA_PROBEIRQ, "pnp", NULL))
+				IRQF_DISABLED|IRQF_PROBE_SHARED, "pnp", NULL))
 			return 0;
 		free_irq(*irq, NULL);
 	}

commit 0cadaf45bd7c19f0bef49d1eebfff38a046b9ba4
Author: Andrew Morton <akpm@osdl.org>
Date:   Sat Jul 1 04:36:37 2006 -0700

    [PATCH] pnp: suppress request_irq() warning
    
    Suppress the "setup_irq: irq handler mismatch" coming out of pnp_check_irq():
    failures are expected here.
    
    Cc: <stable@kernel.org>
    Cc: Santiago Garcia Mantinan <manty@manty.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/pnp/resource.c b/drivers/pnp/resource.c
index e7cf6bec737e..9fefe563f8fc 100644
--- a/drivers/pnp/resource.c
+++ b/drivers/pnp/resource.c
@@ -395,7 +395,8 @@ int pnp_check_irq(struct pnp_dev * dev, int idx)
 	/* check if the resource is already in use, skip if the
 	 * device is active because it itself may be in use */
 	if(!dev->active) {
-		if (request_irq(*irq, pnp_test_handler, SA_INTERRUPT, "pnp", NULL))
+		if (request_irq(*irq, pnp_test_handler,
+				SA_INTERRUPT|SA_PROBEIRQ, "pnp", NULL))
 			return 0;
 		free_irq(*irq, NULL);
 	}

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jörn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jörn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/drivers/pnp/resource.c b/drivers/pnp/resource.c
index 7bb892f58cc0..e7cf6bec737e 100644
--- a/drivers/pnp/resource.c
+++ b/drivers/pnp/resource.c
@@ -6,7 +6,6 @@
  *
  */
 
-#include <linux/config.h>
 #include <linux/module.h>
 #include <linux/errno.h>
 #include <linux/interrupt.h>

commit b60ba8343b78b182c03cf239d4342785376c1ad1
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Jun 12 17:07:07 2006 -0700

    [PATCH] 64bit resource: change pnp core to use resource_size_t
    
    Based on a patch series originally from Vivek Goyal <vgoyal@in.ibm.com>
    
    Cc: Vivek Goyal <vgoyal@in.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pnp/resource.c b/drivers/pnp/resource.c
index 6ded527169f4..7bb892f58cc0 100644
--- a/drivers/pnp/resource.c
+++ b/drivers/pnp/resource.c
@@ -241,7 +241,7 @@ int pnp_check_port(struct pnp_dev * dev, int idx)
 {
 	int tmp;
 	struct pnp_dev *tdev;
-	unsigned long *port, *end, *tport, *tend;
+	resource_size_t *port, *end, *tport, *tend;
 	port = &dev->res.port_resource[idx].start;
 	end = &dev->res.port_resource[idx].end;
 
@@ -297,7 +297,7 @@ int pnp_check_mem(struct pnp_dev * dev, int idx)
 {
 	int tmp;
 	struct pnp_dev *tdev;
-	unsigned long *addr, *end, *taddr, *tend;
+	resource_size_t *addr, *end, *taddr, *tend;
 	addr = &dev->res.mem_resource[idx].start;
 	end = &dev->res.mem_resource[idx].end;
 
@@ -358,7 +358,7 @@ int pnp_check_irq(struct pnp_dev * dev, int idx)
 {
 	int tmp;
 	struct pnp_dev *tdev;
-	unsigned long * irq = &dev->res.irq_resource[idx].start;
+	resource_size_t * irq = &dev->res.irq_resource[idx].start;
 
 	/* if the resource doesn't exist, don't complain about it */
 	if (cannot_compare(dev->res.irq_resource[idx].flags))
@@ -423,7 +423,7 @@ int pnp_check_dma(struct pnp_dev * dev, int idx)
 #ifndef CONFIG_IA64
 	int tmp;
 	struct pnp_dev *tdev;
-	unsigned long * dma = &dev->res.dma_resource[idx].start;
+	resource_size_t * dma = &dev->res.dma_resource[idx].start;
 
 	/* if the resource doesn't exist, don't complain about it */
 	if (cannot_compare(dev->res.dma_resource[idx].flags))

commit b449f63c8ce4a517cb91f237cc3d68d083ec2dd3
Author: Adrian Bunk <bunk@stusta.de>
Date:   Mon Nov 7 01:01:48 2005 -0800

    [PATCH] drivers/pnp/: cleanups
    
    This patch contains the following possible cleanups:
    - make needlessly global code static
    - #if 0 the following unused global function:
      - core.c: pnp_remove_device
    - #if 0 the following unneeded EXPORT_SYMBOL's:
      - card.c: pnp_add_card
      - card.c: pnp_remove_card
      - card.c: pnp_add_card_device
      - card.c: pnp_remove_card_device
      - card.c: pnp_add_card_id
      - core.c: pnp_register_protocol
      - core.c: pnp_unregister_protocol
      - core.c: pnp_add_device
      - core.c: pnp_remove_device
      - pnpacpi/core.c: pnpacpi_protocol
      - driver.c: pnp_add_id
      - isapnp/core.c: isapnp_read_byte
      - manager.c: pnp_auto_config_dev
      - resource.c: pnp_register_dependent_option
      - resource.c: pnp_register_independent_option
      - resource.c: pnp_register_irq_resource
      - resource.c: pnp_register_dma_resource
      - resource.c: pnp_register_port_resource
      - resource.c: pnp_register_mem_resource
    
    Note that this patch #if 0's exactly one functions and removes no
    functions.  Most it does is the #if 0 of EXPORT_SYMBOL's, so if any modular
    code will use any of them, re-adding will be trivial.
    
    Modular ISAPnP might be interesting in some cases, but this is more legacy
    code.  If someone would work on it to sort all the issues out (starting
    with the point that most users of __ISAPNP__ will have to be fixed)
    re-enabling the required EXPORT_SYMBOL's won't be hard for him.
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Cc: Adam Belay <ambx1@neo.rr.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/pnp/resource.c b/drivers/pnp/resource.c
index 887ad8939349..6ded527169f4 100644
--- a/drivers/pnp/resource.c
+++ b/drivers/pnp/resource.c
@@ -477,12 +477,14 @@ int pnp_check_dma(struct pnp_dev * dev, int idx)
 }
 
 
+#if 0
 EXPORT_SYMBOL(pnp_register_dependent_option);
 EXPORT_SYMBOL(pnp_register_independent_option);
 EXPORT_SYMBOL(pnp_register_irq_resource);
 EXPORT_SYMBOL(pnp_register_dma_resource);
 EXPORT_SYMBOL(pnp_register_port_resource);
 EXPORT_SYMBOL(pnp_register_mem_resource);
+#endif  /*  0  */
 
 
 /* format is: pnp_reserve_irq=irq1[,irq2] .... */

commit c9c3e457de24cca2ca688fa397d93a241f472048
Author: David Shaohua Li <shaohua.li@intel.com>
Date:   Fri Apr 1 00:07:31 2005 -0500

    [ACPI] PNPACPI vs sound IRQ
    
    http://bugme.osdl.org/show_bug.cgi?id=4016
    
    Written-by: David Shaohua Li <shaohua.li@intel.com>
    Acked-by: Adam Belay <abelay@novell.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/resource.c b/drivers/pnp/resource.c
index 2d1322dd7e19..887ad8939349 100644
--- a/drivers/pnp/resource.c
+++ b/drivers/pnp/resource.c
@@ -102,7 +102,7 @@ int pnp_register_irq_resource(struct pnp_option *option, struct pnp_irq *data)
 
 		for (i = 0; i < 16; i++)
 			if (test_bit(i, data->map))
-				pcibios_penalize_isa_irq(i);
+				pcibios_penalize_isa_irq(i, 0);
 	}
 #endif
 	return 0;

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/pnp/resource.c b/drivers/pnp/resource.c
new file mode 100644
index 000000000000..2d1322dd7e19
--- /dev/null
+++ b/drivers/pnp/resource.c
@@ -0,0 +1,542 @@
+/*
+ * resource.c - Contains functions for registering and analyzing resource information
+ *
+ * based on isapnp.c resource management (c) Jaroslav Kysela <perex@suse.cz>
+ * Copyright 2003 Adam Belay <ambx1@neo.rr.com>
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <asm/io.h>
+#include <asm/dma.h>
+#include <asm/irq.h>
+#include <linux/pci.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+
+#include <linux/pnp.h>
+#include "base.h"
+
+static int pnp_reserve_irq[16] = { [0 ... 15] = -1 };	/* reserve (don't use) some IRQ */
+static int pnp_reserve_dma[8] = { [0 ... 7] = -1 };	/* reserve (don't use) some DMA */
+static int pnp_reserve_io[16] = { [0 ... 15] = -1 };	/* reserve (don't use) some I/O region */
+static int pnp_reserve_mem[16] = { [0 ... 15] = -1 };	/* reserve (don't use) some memory region */
+
+
+/*
+ * option registration
+ */
+
+static struct pnp_option * pnp_build_option(int priority)
+{
+	struct pnp_option *option = pnp_alloc(sizeof(struct pnp_option));
+
+	/* check if pnp_alloc ran out of memory */
+	if (!option)
+		return NULL;
+
+	option->priority = priority & 0xff;
+	/* make sure the priority is valid */
+	if (option->priority > PNP_RES_PRIORITY_FUNCTIONAL)
+		option->priority = PNP_RES_PRIORITY_INVALID;
+
+	return option;
+}
+
+struct pnp_option * pnp_register_independent_option(struct pnp_dev *dev)
+{
+	struct pnp_option *option;
+	if (!dev)
+		return NULL;
+
+	option = pnp_build_option(PNP_RES_PRIORITY_PREFERRED);
+
+	/* this should never happen but if it does we'll try to continue */
+	if (dev->independent)
+		pnp_err("independent resource already registered");
+	dev->independent = option;
+	return option;
+}
+
+struct pnp_option * pnp_register_dependent_option(struct pnp_dev *dev, int priority)
+{
+	struct pnp_option *option;
+	if (!dev)
+		return NULL;
+
+	option = pnp_build_option(priority);
+
+	if (dev->dependent) {
+		struct pnp_option *parent = dev->dependent;
+		while (parent->next)
+			parent = parent->next;
+		parent->next = option;
+	} else
+		dev->dependent = option;
+	return option;
+}
+
+int pnp_register_irq_resource(struct pnp_option *option, struct pnp_irq *data)
+{
+	struct pnp_irq *ptr;
+	if (!option)
+		return -EINVAL;
+	if (!data)
+		return -EINVAL;
+
+	ptr = option->irq;
+	while (ptr && ptr->next)
+		ptr = ptr->next;
+	if (ptr)
+		ptr->next = data;
+	else
+		option->irq = data;
+
+#ifdef CONFIG_PCI
+	{
+		int i;
+
+		for (i = 0; i < 16; i++)
+			if (test_bit(i, data->map))
+				pcibios_penalize_isa_irq(i);
+	}
+#endif
+	return 0;
+}
+
+int pnp_register_dma_resource(struct pnp_option *option, struct pnp_dma *data)
+{
+	struct pnp_dma *ptr;
+	if (!option)
+		return -EINVAL;
+	if (!data)
+		return -EINVAL;
+
+	ptr = option->dma;
+	while (ptr && ptr->next)
+		ptr = ptr->next;
+	if (ptr)
+		ptr->next = data;
+	else
+		option->dma = data;
+
+	return 0;
+}
+
+int pnp_register_port_resource(struct pnp_option *option, struct pnp_port *data)
+{
+	struct pnp_port *ptr;
+	if (!option)
+		return -EINVAL;
+	if (!data)
+		return -EINVAL;
+
+	ptr = option->port;
+	while (ptr && ptr->next)
+		ptr = ptr->next;
+	if (ptr)
+		ptr->next = data;
+	else
+		option->port = data;
+
+	return 0;
+}
+
+int pnp_register_mem_resource(struct pnp_option *option, struct pnp_mem *data)
+{
+	struct pnp_mem *ptr;
+	if (!option)
+		return -EINVAL;
+	if (!data)
+		return -EINVAL;
+
+	ptr = option->mem;
+	while (ptr && ptr->next)
+		ptr = ptr->next;
+	if (ptr)
+		ptr->next = data;
+	else
+		option->mem = data;
+	return 0;
+}
+
+static void pnp_free_port(struct pnp_port *port)
+{
+	struct pnp_port *next;
+
+	while (port) {
+		next = port->next;
+		kfree(port);
+		port = next;
+	}
+}
+
+static void pnp_free_irq(struct pnp_irq *irq)
+{
+	struct pnp_irq *next;
+
+	while (irq) {
+		next = irq->next;
+		kfree(irq);
+		irq = next;
+	}
+}
+
+static void pnp_free_dma(struct pnp_dma *dma)
+{
+	struct pnp_dma *next;
+
+	while (dma) {
+		next = dma->next;
+		kfree(dma);
+		dma = next;
+	}
+}
+
+static void pnp_free_mem(struct pnp_mem *mem)
+{
+	struct pnp_mem *next;
+
+	while (mem) {
+		next = mem->next;
+		kfree(mem);
+		mem = next;
+	}
+}
+
+void pnp_free_option(struct pnp_option *option)
+{
+	struct pnp_option *next;
+
+	while (option) {
+		next = option->next;
+		pnp_free_port(option->port);
+		pnp_free_irq(option->irq);
+		pnp_free_dma(option->dma);
+		pnp_free_mem(option->mem);
+		kfree(option);
+		option = next;
+	}
+}
+
+
+/*
+ * resource validity checking
+ */
+
+#define length(start, end) (*(end) - *(start) + 1)
+
+/* Two ranges conflict if one doesn't end before the other starts */
+#define ranged_conflict(starta, enda, startb, endb) \
+	!((*(enda) < *(startb)) || (*(endb) < *(starta)))
+
+#define cannot_compare(flags) \
+((flags) & (IORESOURCE_UNSET | IORESOURCE_DISABLED))
+
+int pnp_check_port(struct pnp_dev * dev, int idx)
+{
+	int tmp;
+	struct pnp_dev *tdev;
+	unsigned long *port, *end, *tport, *tend;
+	port = &dev->res.port_resource[idx].start;
+	end = &dev->res.port_resource[idx].end;
+
+	/* if the resource doesn't exist, don't complain about it */
+	if (cannot_compare(dev->res.port_resource[idx].flags))
+		return 1;
+
+	/* check if the resource is already in use, skip if the
+	 * device is active because it itself may be in use */
+	if(!dev->active) {
+		if (__check_region(&ioport_resource, *port, length(port,end)))
+			return 0;
+	}
+
+	/* check if the resource is reserved */
+	for (tmp = 0; tmp < 8; tmp++) {
+		int rport = pnp_reserve_io[tmp << 1];
+		int rend = pnp_reserve_io[(tmp << 1) + 1] + rport - 1;
+		if (ranged_conflict(port,end,&rport,&rend))
+			return 0;
+	}
+
+	/* check for internal conflicts */
+	for (tmp = 0; tmp < PNP_MAX_PORT && tmp != idx; tmp++) {
+		if (dev->res.port_resource[tmp].flags & IORESOURCE_IO) {
+			tport = &dev->res.port_resource[tmp].start;
+			tend = &dev->res.port_resource[tmp].end;
+			if (ranged_conflict(port,end,tport,tend))
+				return 0;
+		}
+	}
+
+	/* check for conflicts with other pnp devices */
+	pnp_for_each_dev(tdev) {
+		if (tdev == dev)
+			continue;
+		for (tmp = 0; tmp < PNP_MAX_PORT; tmp++) {
+			if (tdev->res.port_resource[tmp].flags & IORESOURCE_IO) {
+				if (cannot_compare(tdev->res.port_resource[tmp].flags))
+					continue;
+				tport = &tdev->res.port_resource[tmp].start;
+				tend = &tdev->res.port_resource[tmp].end;
+				if (ranged_conflict(port,end,tport,tend))
+					return 0;
+			}
+		}
+	}
+
+	return 1;
+}
+
+int pnp_check_mem(struct pnp_dev * dev, int idx)
+{
+	int tmp;
+	struct pnp_dev *tdev;
+	unsigned long *addr, *end, *taddr, *tend;
+	addr = &dev->res.mem_resource[idx].start;
+	end = &dev->res.mem_resource[idx].end;
+
+	/* if the resource doesn't exist, don't complain about it */
+	if (cannot_compare(dev->res.mem_resource[idx].flags))
+		return 1;
+
+	/* check if the resource is already in use, skip if the
+	 * device is active because it itself may be in use */
+	if(!dev->active) {
+		if (check_mem_region(*addr, length(addr,end)))
+			return 0;
+	}
+
+	/* check if the resource is reserved */
+	for (tmp = 0; tmp < 8; tmp++) {
+		int raddr = pnp_reserve_mem[tmp << 1];
+		int rend = pnp_reserve_mem[(tmp << 1) + 1] + raddr - 1;
+		if (ranged_conflict(addr,end,&raddr,&rend))
+			return 0;
+	}
+
+	/* check for internal conflicts */
+	for (tmp = 0; tmp < PNP_MAX_MEM && tmp != idx; tmp++) {
+		if (dev->res.mem_resource[tmp].flags & IORESOURCE_MEM) {
+			taddr = &dev->res.mem_resource[tmp].start;
+			tend = &dev->res.mem_resource[tmp].end;
+			if (ranged_conflict(addr,end,taddr,tend))
+				return 0;
+		}
+	}
+
+	/* check for conflicts with other pnp devices */
+	pnp_for_each_dev(tdev) {
+		if (tdev == dev)
+			continue;
+		for (tmp = 0; tmp < PNP_MAX_MEM; tmp++) {
+			if (tdev->res.mem_resource[tmp].flags & IORESOURCE_MEM) {
+				if (cannot_compare(tdev->res.mem_resource[tmp].flags))
+					continue;
+				taddr = &tdev->res.mem_resource[tmp].start;
+				tend = &tdev->res.mem_resource[tmp].end;
+				if (ranged_conflict(addr,end,taddr,tend))
+					return 0;
+			}
+		}
+	}
+
+	return 1;
+}
+
+static irqreturn_t pnp_test_handler(int irq, void *dev_id, struct pt_regs *regs)
+{
+	return IRQ_HANDLED;
+}
+
+int pnp_check_irq(struct pnp_dev * dev, int idx)
+{
+	int tmp;
+	struct pnp_dev *tdev;
+	unsigned long * irq = &dev->res.irq_resource[idx].start;
+
+	/* if the resource doesn't exist, don't complain about it */
+	if (cannot_compare(dev->res.irq_resource[idx].flags))
+		return 1;
+
+	/* check if the resource is valid */
+	if (*irq < 0 || *irq > 15)
+		return 0;
+
+	/* check if the resource is reserved */
+	for (tmp = 0; tmp < 16; tmp++) {
+		if (pnp_reserve_irq[tmp] == *irq)
+			return 0;
+	}
+
+	/* check for internal conflicts */
+	for (tmp = 0; tmp < PNP_MAX_IRQ && tmp != idx; tmp++) {
+		if (dev->res.irq_resource[tmp].flags & IORESOURCE_IRQ) {
+			if (dev->res.irq_resource[tmp].start == *irq)
+				return 0;
+		}
+	}
+
+#ifdef CONFIG_PCI
+	/* check if the resource is being used by a pci device */
+	{
+		struct pci_dev *pci = NULL;
+		for_each_pci_dev(pci) {
+			if (pci->irq == *irq)
+				return 0;
+		}
+	}
+#endif
+
+	/* check if the resource is already in use, skip if the
+	 * device is active because it itself may be in use */
+	if(!dev->active) {
+		if (request_irq(*irq, pnp_test_handler, SA_INTERRUPT, "pnp", NULL))
+			return 0;
+		free_irq(*irq, NULL);
+	}
+
+	/* check for conflicts with other pnp devices */
+	pnp_for_each_dev(tdev) {
+		if (tdev == dev)
+			continue;
+		for (tmp = 0; tmp < PNP_MAX_IRQ; tmp++) {
+			if (tdev->res.irq_resource[tmp].flags & IORESOURCE_IRQ) {
+				if (cannot_compare(tdev->res.irq_resource[tmp].flags))
+					continue;
+				if ((tdev->res.irq_resource[tmp].start == *irq))
+					return 0;
+			}
+		}
+	}
+
+	return 1;
+}
+
+int pnp_check_dma(struct pnp_dev * dev, int idx)
+{
+#ifndef CONFIG_IA64
+	int tmp;
+	struct pnp_dev *tdev;
+	unsigned long * dma = &dev->res.dma_resource[idx].start;
+
+	/* if the resource doesn't exist, don't complain about it */
+	if (cannot_compare(dev->res.dma_resource[idx].flags))
+		return 1;
+
+	/* check if the resource is valid */
+	if (*dma < 0 || *dma == 4 || *dma > 7)
+		return 0;
+
+	/* check if the resource is reserved */
+	for (tmp = 0; tmp < 8; tmp++) {
+		if (pnp_reserve_dma[tmp] == *dma)
+			return 0;
+	}
+
+	/* check for internal conflicts */
+	for (tmp = 0; tmp < PNP_MAX_DMA && tmp != idx; tmp++) {
+		if (dev->res.dma_resource[tmp].flags & IORESOURCE_DMA) {
+			if (dev->res.dma_resource[tmp].start == *dma)
+				return 0;
+		}
+	}
+
+	/* check if the resource is already in use, skip if the
+	 * device is active because it itself may be in use */
+	if(!dev->active) {
+		if (request_dma(*dma, "pnp"))
+			return 0;
+		free_dma(*dma);
+	}
+
+	/* check for conflicts with other pnp devices */
+	pnp_for_each_dev(tdev) {
+		if (tdev == dev)
+			continue;
+		for (tmp = 0; tmp < PNP_MAX_DMA; tmp++) {
+			if (tdev->res.dma_resource[tmp].flags & IORESOURCE_DMA) {
+				if (cannot_compare(tdev->res.dma_resource[tmp].flags))
+					continue;
+				if ((tdev->res.dma_resource[tmp].start == *dma))
+					return 0;
+			}
+		}
+	}
+
+	return 1;
+#else
+	/* IA64 hasn't legacy DMA */
+	return 0;
+#endif
+}
+
+
+EXPORT_SYMBOL(pnp_register_dependent_option);
+EXPORT_SYMBOL(pnp_register_independent_option);
+EXPORT_SYMBOL(pnp_register_irq_resource);
+EXPORT_SYMBOL(pnp_register_dma_resource);
+EXPORT_SYMBOL(pnp_register_port_resource);
+EXPORT_SYMBOL(pnp_register_mem_resource);
+
+
+/* format is: pnp_reserve_irq=irq1[,irq2] .... */
+
+static int __init pnp_setup_reserve_irq(char *str)
+{
+	int i;
+
+	for (i = 0; i < 16; i++)
+		if (get_option(&str,&pnp_reserve_irq[i]) != 2)
+			break;
+	return 1;
+}
+
+__setup("pnp_reserve_irq=", pnp_setup_reserve_irq);
+
+/* format is: pnp_reserve_dma=dma1[,dma2] .... */
+
+static int __init pnp_setup_reserve_dma(char *str)
+{
+	int i;
+
+	for (i = 0; i < 8; i++)
+		if (get_option(&str,&pnp_reserve_dma[i]) != 2)
+			break;
+	return 1;
+}
+
+__setup("pnp_reserve_dma=", pnp_setup_reserve_dma);
+
+/* format is: pnp_reserve_io=io1,size1[,io2,size2] .... */
+
+static int __init pnp_setup_reserve_io(char *str)
+{
+	int i;
+
+	for (i = 0; i < 16; i++)
+		if (get_option(&str,&pnp_reserve_io[i]) != 2)
+			break;
+	return 1;
+}
+
+__setup("pnp_reserve_io=", pnp_setup_reserve_io);
+
+/* format is: pnp_reserve_mem=mem1,size1[,mem2,size2] .... */
+
+static int __init pnp_setup_reserve_mem(char *str)
+{
+	int i;
+
+	for (i = 0; i < 16; i++)
+		if (get_option(&str,&pnp_reserve_mem[i]) != 2)
+			break;
+	return 1;
+}
+
+__setup("pnp_reserve_mem=", pnp_setup_reserve_mem);
