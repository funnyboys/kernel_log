commit 660662f857bc342b287572789b2494d0614e001d
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri May 24 12:04:10 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 150
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 or at your option any
      later version this program is distributed in the hope that it will
      be useful but without any warranty without even the implied warranty
      of merchantability or fitness for a particular purpose see the gnu
      general public license for more details you should have received a
      copy of the gnu general public license along with this program if
      not write to the free software foundation inc 59 temple place suite
      330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 42 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190524100845.259718220@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pnp/pnpbios/core.c b/drivers/pnp/pnpbios/core.c
index 077f334fdbae..9b760e73ee8f 100644
--- a/drivers/pnp/pnpbios/core.c
+++ b/drivers/pnp/pnpbios/core.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * pnpbios -- PnP BIOS driver
  *
@@ -17,20 +18,6 @@
  *
  * Ported to the PnP Layer and several additional improvements (C) 2002
  * by Adam Belay <ambx1@neo.rr.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2, or (at your option) any
- * later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
 /* Change Log

commit 846583ce151644b8538ca6cdf3f0857a80787649
Author: Vasyl Gomonovych <gomonovych@gmail.com>
Date:   Wed Nov 29 17:20:57 2017 +0100

    PNP: pnpbios: Use PTR_ERR_OR_ZERO()
    
    Fix ptr_ret.cocci warnings:
    drivers/pnp/pnpbios/core.c:584:1-3: WARNING: PTR_ERR_OR_ZERO can be used
    
    Use PTR_ERR_OR_ZERO rather than if(IS_ERR(...)) + PTR_ERR
    
    Generated by: scripts/coccinelle/api/ptr_ret.cocci
    
    Signed-off-by: Vasyl Gomonovych <gomonovych@gmail.com>
    Reviewed-by: Jean Delvare <jdelvare@suse.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pnp/pnpbios/core.c b/drivers/pnp/pnpbios/core.c
index e681140b85d8..077f334fdbae 100644
--- a/drivers/pnp/pnpbios/core.c
+++ b/drivers/pnp/pnpbios/core.c
@@ -581,10 +581,7 @@ static int __init pnpbios_thread_init(void)
 
 	init_completion(&unload_sem);
 	task = kthread_run(pnp_dock_thread, NULL, "kpnpbiosd");
-	if (IS_ERR(task))
-		return PTR_ERR(task);
-
-	return 0;
+	return PTR_ERR_OR_ZERO(task);
 }
 
 /* Start the kernel thread later: */

commit 6faadbbb7f9da70ce484f98f72223c20125a1009
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Sep 14 11:59:30 2017 +0200

    dmi: Mark all struct dmi_system_id instances const
    
    ... and __initconst if applicable.
    
    Based on similar work for an older kernel in the Grsecurity patch.
    
    [JD: fix toshiba-wmi build]
    [JD: add htcpen]
    [JD: move __initconst where checkscript wants it]
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jean Delvare <jdelvare@suse.de>

diff --git a/drivers/pnp/pnpbios/core.c b/drivers/pnp/pnpbios/core.c
index 0ced908e7aa8..e681140b85d8 100644
--- a/drivers/pnp/pnpbios/core.c
+++ b/drivers/pnp/pnpbios/core.c
@@ -495,7 +495,7 @@ static int __init exploding_pnp_bios(const struct dmi_system_id *d)
 	return 0;
 }
 
-static struct dmi_system_id pnpbios_dmi_table[] __initdata = {
+static const struct dmi_system_id pnpbios_dmi_table[] __initconst = {
 	{			/* PnPBIOS GPF on boot */
 	 .callback = exploding_pnp_bios,
 	 .ident = "Higraded P14H",

commit 377e7a27c049d6df9c1804454904e438ed12f1a4
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sun Dec 11 18:00:43 2016 +0100

    Make static usermode helper binaries constant
    
    There are a number of usermode helper binaries that are "hard coded" in
    the kernel today, so mark them as "const" to make it harder for someone
    to change where the variables point to.
    
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Thomas Sailer <t.sailer@alumni.ethz.ch>
    Cc: "Rafael J. Wysocki" <rafael.j.wysocki@intel.com>
    Cc: Johan Hovold <johan@kernel.org>
    Cc: Alex Elder <elder@kernel.org>
    Cc: "J. Bruce Fields" <bfields@fieldses.org>
    Cc: Jeff Layton <jlayton@poochiereds.net>
    Cc: David Howells <dhowells@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pnp/pnpbios/core.c b/drivers/pnp/pnpbios/core.c
index c38a5b9733c8..0ced908e7aa8 100644
--- a/drivers/pnp/pnpbios/core.c
+++ b/drivers/pnp/pnpbios/core.c
@@ -98,6 +98,7 @@ static struct completion unload_sem;
  */
 static int pnp_dock_event(int dock, struct pnp_docking_station_info *info)
 {
+	static char const sbin_pnpbios[] = "/sbin/pnpbios";
 	char *argv[3], **envp, *buf, *scratch;
 	int i = 0, value;
 
@@ -112,7 +113,7 @@ static int pnp_dock_event(int dock, struct pnp_docking_station_info *info)
 	 * integrated into the driver core and use the usual infrastructure
 	 * like sysfs and uevents
 	 */
-	argv[0] = "/sbin/pnpbios";
+	argv[0] = (char *)sbin_pnpbios;
 	argv[1] = "dock";
 	argv[2] = NULL;
 
@@ -139,7 +140,7 @@ static int pnp_dock_event(int dock, struct pnp_docking_station_info *info)
 			   info->location_id, info->serial, info->capabilities);
 	envp[i] = NULL;
 
-	value = call_usermodehelper(argv [0], argv, envp, UMH_WAIT_EXEC);
+	value = call_usermodehelper(sbin_pnpbios, argv, envp, UMH_WAIT_EXEC);
 	kfree(buf);
 	kfree(envp);
 	return 0;

commit 61a67a366d5b5f9e3c8f27d056a3a67ede2a0026
Author: Randy Dunlap <rdunlap@infradead.org>
Date:   Tue Jul 26 16:26:40 2016 -0700

    PNP: pnpbios: add header file to fix build errors
    
    Fix build errors due to missing header file:
    
    ../drivers/pnp/pnpbios/core.c: In function 'pnp_dock_event':
    ../drivers/pnp/pnpbios/core.c:141:2: error: implicit declaration of function 'call_usermodehelper' [-Werror=implicit-function-declaration]
      value = call_usermodehelper(argv [0], argv, envp, UMH_WAIT_EXEC);
      ^
    ../drivers/pnp/pnpbios/core.c:141:52: error: 'UMH_WAIT_EXEC' undeclared (first use in this function)
      value = call_usermodehelper(argv [0], argv, envp, UMH_WAIT_EXEC);
                                                        ^
    Signed-off-by: Randy Dunlap <rdunlap@infradead.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pnp/pnpbios/core.c b/drivers/pnp/pnpbios/core.c
index bedb361746a0..c38a5b9733c8 100644
--- a/drivers/pnp/pnpbios/core.c
+++ b/drivers/pnp/pnpbios/core.c
@@ -60,6 +60,7 @@
 #include <linux/delay.h>
 #include <linux/acpi.h>
 #include <linux/freezer.h>
+#include <linux/kmod.h>
 #include <linux/kthread.h>
 
 #include <asm/page.h>

commit 917c7fc264abb9c470486b157bc7252e53f68fbb
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Sun Jul 3 14:20:15 2016 -0400

    PNP: make pnpbios core explicitly non-modular
    
    The Kconfig currently controlling compilation of this code is:
    
    config PNPBIOS
            bool "Plug and Play BIOS support"
    
    ...meaning that it currently is not being built as a module by anyone.
    
    Lets remove the couple traces of modularity, so that when reading the
    driver there is no doubt it is builtin-only.
    
    Since module_init translates to device_initcall in the non-modular
    case, the init ordering remains unchanged with this commit.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pnp/pnpbios/core.c b/drivers/pnp/pnpbios/core.c
index 81603d99082b..bedb361746a0 100644
--- a/drivers/pnp/pnpbios/core.c
+++ b/drivers/pnp/pnpbios/core.c
@@ -46,7 +46,6 @@
  */
 
 #include <linux/types.h>
-#include <linux/module.h>
 #include <linux/init.h>
 #include <linux/linkage.h>
 #include <linux/kernel.h>
@@ -587,6 +586,6 @@ static int __init pnpbios_thread_init(void)
 }
 
 /* Start the kernel thread later: */
-module_init(pnpbios_thread_init);
+device_initcall(pnpbios_thread_init);
 
 EXPORT_SYMBOL(pnpbios_protocol);

commit 80dfd83dfab6e49a31ab8fc484a801aef1c567bd
Author: Luis R. Rodriguez <mcgrof@kernel.org>
Date:   Wed Apr 13 17:04:41 2016 -0700

    x86, drivers/pnpbios: Replace paravirt_enabled() check with legacy device check
    
    Since we are removing paravirt_enabled() replace it with a
    logical equivalent. Even though PNPBIOS is x86 specific we
    add an arch-specific type call, which can be implemented by
    any architecture to show how other legacy attribute devices
    can later be also checked for with other ACPI legacy attribute
    flags.
    
    This implicates the first ACPI 5.2.9.3 IA-PC Boot Architecture
    ACPI_FADT_LEGACY_DEVICES flag device, and shows how to add more.
    
    The reason pnpbios gets a defined structure and as such uses
    a different approach than the RTC legacy quirk is that ACPI
    has a respective RTC flag, while pnpbios does not. We fold
    the pnpbios quirk under ACPI_FADT_LEGACY_DEVICES ACPI flag
    use case, and use a struct of possible devices to enable
    future extensions of this.
    
    As per 0-day, this bumps the vmlinux size using i386-tinyconfig as
    follows:
    
    TOTAL   TEXT   init.text   x86_early_init_platform_quirks()
    +32     +28    +28         +28
    
    That's 4 byte overhead total, the rest is cleared out on init
    as its all __init text.
    
    v2: split out subarch handlng on switch to make it easier
        later to add other subarchs. The 'fall-through' switch
        handling can be confusing and we'll remove it later
        when we add handling for X86_SUBARCH_CE4100.
    v3: document vmlinux size impact as per 0-day, and also
        explain why pnpbios is treated differently than the
        RTC legacy feature.
    
    Signed-off-by: Luis R. Rodriguez <mcgrof@kernel.org>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: andrew.cooper3@citrix.com
    Cc: andriy.shevchenko@linux.intel.com
    Cc: bigeasy@linutronix.de
    Cc: boris.ostrovsky@oracle.com
    Cc: david.vrabel@citrix.com
    Cc: ffainelli@freebox.fr
    Cc: george.dunlap@citrix.com
    Cc: glin@suse.com
    Cc: jgross@suse.com
    Cc: jlee@suse.com
    Cc: josh@joshtriplett.org
    Cc: julien.grall@linaro.org
    Cc: konrad.wilk@oracle.com
    Cc: kozerkov@parallels.com
    Cc: lenb@kernel.org
    Cc: lguest@lists.ozlabs.org
    Cc: linux-acpi@vger.kernel.org
    Cc: lv.zheng@intel.com
    Cc: matt@codeblueprint.co.uk
    Cc: mbizon@freebox.fr
    Cc: rjw@rjwysocki.net
    Cc: robert.moore@intel.com
    Cc: rusty@rustcorp.com.au
    Cc: tiwai@suse.de
    Cc: toshi.kani@hp.com
    Cc: xen-devel@lists.xensource.com
    Link: http://lkml.kernel.org/r/1460592286-300-12-git-send-email-mcgrof@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/pnp/pnpbios/core.c b/drivers/pnp/pnpbios/core.c
index facd43b8516c..81603d99082b 100644
--- a/drivers/pnp/pnpbios/core.c
+++ b/drivers/pnp/pnpbios/core.c
@@ -521,10 +521,11 @@ static int __init pnpbios_init(void)
 	int ret;
 
 	if (pnpbios_disabled || dmi_check_system(pnpbios_dmi_table) ||
-	    paravirt_enabled()) {
+	    arch_pnpbios_disabled()) {
 		printk(KERN_INFO "PnPBIOS: Disabled\n");
 		return -ENODEV;
 	}
+
 #ifdef CONFIG_PNPACPI
 	if (!acpi_disabled && !pnpacpi_disabled) {
 		pnpbios_disabled = 1;

commit 625505b509b38b3a389cb3f4fd6520a46763bf45
Author: Alan Cox <alan@linux.intel.com>
Date:   Tue Jan 20 12:54:50 2015 +0000

    pnpbios: bail out on strange errors
    
    A small number of systems respond to PnP dock queries with bogus values.
    This causes us to keep logging an error every 2 seconds. Instead of trying
    again just assume the BIOS is crapware and doesn't actually have dock
    functionality.
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pnp/pnpbios/core.c b/drivers/pnp/pnpbios/core.c
index 074569e77d22..facd43b8516c 100644
--- a/drivers/pnp/pnpbios/core.c
+++ b/drivers/pnp/pnpbios/core.c
@@ -181,7 +181,8 @@ static int pnp_dock_thread(void *unused)
 			break;
 		default:
 			pnpbios_print_status("pnp_dock_thread", status);
-			continue;
+			printk(KERN_WARNING "PnPBIOS: disabling dock monitoring.\n");
+			complete_and_exit(&unload_sem, 0);
 		}
 		if (d != docked) {
 			if (pnp_dock_event(d, &now) == 0) {

commit d8254e0e72c8cc6131f789f8645338b719f57648
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Tue Jan 7 00:16:37 2014 +0100

    PNPBIOS: check return value of pnp_add_device()
    
    pnp_add_device() may fail so we need to handle errors and avoid leaking
    memory.
    
    Also, when pnp_alloc_dev fails, return -ENOMEM rather than -1.
    
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pnp/pnpbios/core.c b/drivers/pnp/pnpbios/core.c
index 9b86a01af631..074569e77d22 100644
--- a/drivers/pnp/pnpbios/core.c
+++ b/drivers/pnp/pnpbios/core.c
@@ -312,18 +312,19 @@ static int __init insert_device(struct pnp_bios_node *node)
 	struct list_head *pos;
 	struct pnp_dev *dev;
 	char id[8];
+	int error;
 
 	/* check if the device is already added */
 	list_for_each(pos, &pnpbios_protocol.devices) {
 		dev = list_entry(pos, struct pnp_dev, protocol_list);
 		if (dev->number == node->handle)
-			return -1;
+			return -EEXIST;
 	}
 
 	pnp_eisa_id_to_string(node->eisa_id & PNP_EISA_ID_MASK, id);
 	dev = pnp_alloc_dev(&pnpbios_protocol, node->handle, id);
 	if (!dev)
-		return -1;
+		return -ENOMEM;
 
 	pnpbios_parse_data_stream(dev, node);
 	dev->active = pnp_is_active(dev);
@@ -342,7 +343,12 @@ static int __init insert_device(struct pnp_bios_node *node)
 	if (!dev->active)
 		pnp_init_resources(dev);
 
-	pnp_add_device(dev);
+	error = pnp_add_device(dev);
+	if (error) {
+		put_device(&dev->dev);
+		return error;
+	}
+
 	pnpbios_interface_attach_device(node);
 
 	return 0;

commit 933ee7119fb14156f46dc8bce8218f62db13c568
Author: Paul Bolle <pebolle@tiscali.nl>
Date:   Wed Mar 27 00:47:03 2013 +0000

    powerpc: remove PReP platform
    
    PPC_PREP is marked as BROKEN since v2.6.15. Remove all PReP specific
    code now.
    
    Signed-off-by: Paul Bolle <pebolle@tiscali.nl>
    Signed-off-by: Michael Ellerman <michael@ellerman.id.au>

diff --git a/drivers/pnp/pnpbios/core.c b/drivers/pnp/pnpbios/core.c
index 5d66e5585f97..9b86a01af631 100644
--- a/drivers/pnp/pnpbios/core.c
+++ b/drivers/pnp/pnpbios/core.c
@@ -513,10 +513,6 @@ static int __init pnpbios_init(void)
 {
 	int ret;
 
-#if defined(CONFIG_PPC)
-	if (check_legacy_ioport(PNPBIOS_BASE))
-		return -ENODEV;
-#endif
 	if (pnpbios_disabled || dmi_check_system(pnpbios_dmi_table) ||
 	    paravirt_enabled()) {
 		printk(KERN_INFO "PnPBIOS: Disabled\n");
@@ -570,10 +566,7 @@ fs_initcall(pnpbios_init);
 static int __init pnpbios_thread_init(void)
 {
 	struct task_struct *task;
-#if defined(CONFIG_PPC)
-	if (check_legacy_ioport(PNPBIOS_BASE))
-		return 0;
-#endif
+
 	if (pnpbios_disabled)
 		return 0;
 

commit 38de2790c7bd212fa96f50c896fdc2f4def76087
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:19:14 2012 -0500

    pnpbios: remove CONFIG_HOTPLUG ifdefs
    
    Remove conditional code based on CONFIG_HOTPLUG being false.  It's
    always on now in preparation of it going away as an option.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Adam Belay <abelay@mit.edu>
    Reviewed-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pnp/pnpbios/core.c b/drivers/pnp/pnpbios/core.c
index 9d4222648640..5d66e5585f97 100644
--- a/drivers/pnp/pnpbios/core.c
+++ b/drivers/pnp/pnpbios/core.c
@@ -91,8 +91,6 @@ struct pnp_dev_node_info node_info;
  *
  */
 
-#ifdef CONFIG_HOTPLUG
-
 static struct completion unload_sem;
 
 /*
@@ -199,8 +197,6 @@ static int pnp_dock_thread(void *unused)
 	complete_and_exit(&unload_sem, 0);
 }
 
-#endif				/* CONFIG_HOTPLUG */
-
 static int pnpbios_get_resources(struct pnp_dev *dev)
 {
 	u8 nodenum = dev->number;
@@ -573,21 +569,19 @@ fs_initcall(pnpbios_init);
 
 static int __init pnpbios_thread_init(void)
 {
+	struct task_struct *task;
 #if defined(CONFIG_PPC)
 	if (check_legacy_ioport(PNPBIOS_BASE))
 		return 0;
 #endif
 	if (pnpbios_disabled)
 		return 0;
-#ifdef CONFIG_HOTPLUG
-	{
-		struct task_struct *task;
-		init_completion(&unload_sem);
-		task = kthread_run(pnp_dock_thread, NULL, "kpnpbiosd");
-		if (IS_ERR(task))
-			return PTR_ERR(task);
-	}
-#endif
+
+	init_completion(&unload_sem);
+	task = kthread_run(pnp_dock_thread, NULL, "kpnpbiosd");
+	if (IS_ERR(task))
+		return PTR_ERR(task);
+
 	return 0;
 }
 

commit 9ffc93f203c18a70623f21950f1dd473c9ec48cd
Author: David Howells <dhowells@redhat.com>
Date:   Wed Mar 28 18:30:03 2012 +0100

    Remove all #inclusions of asm/system.h
    
    Remove all #inclusions of asm/system.h preparatory to splitting and killing
    it.  Performed with the following command:
    
    perl -p -i -e 's!^#\s*include\s*<asm/system[.]h>.*\n!!' `grep -Irl '^#\s*include\s*<asm/system[.]h>' *`
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/drivers/pnp/pnpbios/core.c b/drivers/pnp/pnpbios/core.c
index cfe86853feb2..9d4222648640 100644
--- a/drivers/pnp/pnpbios/core.c
+++ b/drivers/pnp/pnpbios/core.c
@@ -65,7 +65,6 @@
 
 #include <asm/page.h>
 #include <asm/desc.h>
-#include <asm/system.h>
 #include <asm/byteorder.h>
 
 #include "../base.h"

commit b277c884f7856ce0791b1e72079023a86767981b
Author: Erik Ekman <erik@kryo.se>
Date:   Thu Apr 2 16:57:09 2009 -0700

    pnpbios: propagate kthread_run() error
    
    - Error code from kthread_run() is now returned in pnpbios_thread_init()
    
    - Remove variable which always was 0.
    
    Signed-off-by: Erik Ekman <erik@kryo.se>
    Cc: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pnp/pnpbios/core.c b/drivers/pnp/pnpbios/core.c
index e706d22b6dd1..cfe86853feb2 100644
--- a/drivers/pnp/pnpbios/core.c
+++ b/drivers/pnp/pnpbios/core.c
@@ -94,7 +94,6 @@ struct pnp_dev_node_info node_info;
 
 #ifdef CONFIG_HOTPLUG
 
-static int unloading = 0;
 static struct completion unload_sem;
 
 /*
@@ -158,7 +157,7 @@ static int pnp_dock_thread(void *unused)
 	int docked = -1, d = 0;
 
 	set_freezable();
-	while (!unloading) {
+	while (1) {
 		int status;
 
 		/*
@@ -586,8 +585,8 @@ static int __init pnpbios_thread_init(void)
 		struct task_struct *task;
 		init_completion(&unload_sem);
 		task = kthread_run(pnp_dock_thread, NULL, "kpnpbiosd");
-		if (!IS_ERR(task))
-			unloading = 0;
+		if (IS_ERR(task))
+			return PTR_ERR(task);
 	}
 #endif
 	return 0;

commit 8c655918b15691d3a97f4e9a7c3c0a6ac992e297
Author: Erik Ekman <erik@kryo.se>
Date:   Thu Apr 2 16:57:08 2009 -0700

    pnpbios: fix warning if CONFIG_HOTPLUG=n
    
    drivers/pnp/pnpbios/core.c: In function 'pnpbios_thread_init':
    drivers/pnp/pnpbios/core.c:578: warning: unused variable 'task'
    
    Signed-off-by: Erik Ekman <erik@kryo.se>
    Cc: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pnp/pnpbios/core.c b/drivers/pnp/pnpbios/core.c
index 996f64838079..e706d22b6dd1 100644
--- a/drivers/pnp/pnpbios/core.c
+++ b/drivers/pnp/pnpbios/core.c
@@ -575,8 +575,6 @@ fs_initcall(pnpbios_init);
 
 static int __init pnpbios_thread_init(void)
 {
-	struct task_struct *task;
-
 #if defined(CONFIG_PPC)
 	if (check_legacy_ioport(PNPBIOS_BASE))
 		return 0;
@@ -584,10 +582,13 @@ static int __init pnpbios_thread_init(void)
 	if (pnpbios_disabled)
 		return 0;
 #ifdef CONFIG_HOTPLUG
-	init_completion(&unload_sem);
-	task = kthread_run(pnp_dock_thread, NULL, "kpnpbiosd");
-	if (!IS_ERR(task))
-		unloading = 0;
+	{
+		struct task_struct *task;
+		init_completion(&unload_sem);
+		task = kthread_run(pnp_dock_thread, NULL, "kpnpbiosd");
+		if (!IS_ERR(task))
+			unloading = 0;
+	}
 #endif
 	return 0;
 }

commit 057316cc6a5b521b332a1d7ccc871cd60c904c74
Merge: 3e2dab9a1c2d 2515ddc6db8e
Author: Len Brown <len.brown@intel.com>
Date:   Wed Oct 22 23:57:26 2008 -0400

    Merge branch 'linus' into test
    
    Conflicts:
            MAINTAINERS
            arch/x86/kernel/acpi/boot.c
            arch/x86/kernel/acpi/sleep.c
            drivers/acpi/Kconfig
            drivers/pnp/Makefile
            drivers/pnp/quirks.c
    
    Signed-off-by: Len Brown <len.brown@intel.com>

commit 6dc6472581f693b5fc95aebedf67b4960fb85cf0
Merge: ee673eaa72d8 8acd3a60bcca
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Wed Oct 15 11:31:54 2008 +1100

    Merge commit 'origin'
    
    Manual fixup of conflicts on:
    
            arch/powerpc/include/asm/dcr-regs.h
            drivers/net/ibm_newemac/core.h

commit 2f53432c2aedbe79020e44525eb069d9138a01dd
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Aug 19 16:53:47 2008 -0600

    PNP: convert to using pnp_dbg()
    
    pnp_dbg() is equivalent to dev_dbg() except that we can turn it
    on at boot-time with the "pnp.debug" kernel parameter, so we don't
    have to build a new kernel image.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/pnpbios/core.c b/drivers/pnp/pnpbios/core.c
index 19a4be1a9a31..2f79eb2190e1 100644
--- a/drivers/pnp/pnpbios/core.c
+++ b/drivers/pnp/pnpbios/core.c
@@ -211,7 +211,7 @@ static int pnpbios_get_resources(struct pnp_dev *dev)
 	if (!pnpbios_is_dynamic(dev))
 		return -EPERM;
 
-	dev_dbg(&dev->dev, "get resources\n");
+	pnp_dbg(&dev->dev, "get resources\n");
 	node = kzalloc(node_info.max_node_size, GFP_KERNEL);
 	if (!node)
 		return -1;
@@ -234,7 +234,7 @@ static int pnpbios_set_resources(struct pnp_dev *dev)
 	if (!pnpbios_is_dynamic(dev))
 		return -EPERM;
 
-	dev_dbg(&dev->dev, "set resources\n");
+	pnp_dbg(&dev->dev, "set resources\n");
 	node = kzalloc(node_info.max_node_size, GFP_KERNEL);
 	if (!node)
 		return -1;

commit ed458df4d2470adc02762a87a9ad665d0b1a2bd4
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Oct 10 08:00:17 2008 -0700

    PnP: move pnpacpi/pnpbios_init to after PCI init
    
    We already did that a long time ago for pnp_system_init, but
    pnpacpi_init and pnpbios_init remained as subsys_initcalls, and get
    linked into the kernel before the arch-specific routines that finalize
    the PCI resources (pci_subsys_init).
    
    This means that the PnP routines would either register their resources
    before the PCI layer could, or would be unable to check whether a PCI
    resource had already been registered.  Both are problematic.
    
    I wanted to do this before 2.6.27, but every time we change something
    like this, something breaks.  That said, _every_ single time we trust
    some firmware (like PnP tables) more than we trust the hardware itself
    (like PCI probing), the problems have been worse.
    
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pnp/pnpbios/core.c b/drivers/pnp/pnpbios/core.c
index 19a4be1a9a31..662dfcddedc6 100644
--- a/drivers/pnp/pnpbios/core.c
+++ b/drivers/pnp/pnpbios/core.c
@@ -571,7 +571,7 @@ static int __init pnpbios_init(void)
 	return 0;
 }
 
-subsys_initcall(pnpbios_init);
+fs_initcall(pnpbios_init);
 
 static int __init pnpbios_thread_init(void)
 {

commit 68e1ee62f0f8e556642a59ebaf0c2cc2ac6ccfa6
Author: Kumar Gala <galak@kernel.crashing.org>
Date:   Mon Sep 22 14:41:31 2008 -0700

    powerpc: convert CONFIG_PPC_MERGE to CONFIG_PPC for legacy io checks
    
    Now that arch/ppc is dead CONFIG_PPC_MERGE is always defined for all
    powerpc platforms and we want to get rid of CONFIG_PPC_MERGE use
    CONFIG_PPC instead.
    
    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>
    Acked-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>

diff --git a/drivers/pnp/pnpbios/core.c b/drivers/pnp/pnpbios/core.c
index 19a4be1a9a31..0797dd170369 100644
--- a/drivers/pnp/pnpbios/core.c
+++ b/drivers/pnp/pnpbios/core.c
@@ -519,7 +519,7 @@ static int __init pnpbios_init(void)
 {
 	int ret;
 
-#if defined(CONFIG_PPC_MERGE)
+#if defined(CONFIG_PPC)
 	if (check_legacy_ioport(PNPBIOS_BASE))
 		return -ENODEV;
 #endif
@@ -577,7 +577,7 @@ static int __init pnpbios_thread_init(void)
 {
 	struct task_struct *task;
 
-#if defined(CONFIG_PPC_MERGE)
+#if defined(CONFIG_PPC)
 	if (check_legacy_ioport(PNPBIOS_BASE))
 		return 0;
 #endif

commit dfd2e1b4e6eb46ff59c7e1c1111c967b8b5981c1
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Apr 28 16:34:42 2008 -0600

    PNPBIOS: remove include/linux/pnpbios.h
    
    The contents of include/linux/pnpbios.h are used only inside the PNPBIOS
    backend, so this file doesn't need to be visible outside PNP.
    
    This patch moves the contents into an existing PNPBIOS-specific file,
    drivers/pnp/pnpbios/pnpbios.h.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Acked-By: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/pnpbios/core.c b/drivers/pnp/pnpbios/core.c
index f5477ca85956..19a4be1a9a31 100644
--- a/drivers/pnp/pnpbios/core.c
+++ b/drivers/pnp/pnpbios/core.c
@@ -50,7 +50,6 @@
 #include <linux/init.h>
 #include <linux/linkage.h>
 #include <linux/kernel.h>
-#include <linux/pnpbios.h>
 #include <linux/device.h>
 #include <linux/pnp.h>
 #include <linux/mm.h>

commit f44900020926b2cb06b87f0f52643d6285514fc3
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Apr 28 16:34:09 2008 -0600

    PNP: add pnp_init_resources(struct pnp_dev *) interface
    
    Add pnp_init_resources(struct pnp_dev *) to replace
    pnp_init_resource_table(), which takes a pointer to the
    pnp_resource_table itself.  Passing only the pnp_dev * reduces
    the possibility for error in the caller and removes the
    pnp_resource_table implementation detail from the interface.
    
    Even though pnp_init_resource_table() is exported, I did not
    export pnp_init_resources() because it is used only by the PNP
    core.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Acked-By: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/pnpbios/core.c b/drivers/pnp/pnpbios/core.c
index 76d398531da6..f5477ca85956 100644
--- a/drivers/pnp/pnpbios/core.c
+++ b/drivers/pnp/pnpbios/core.c
@@ -347,7 +347,7 @@ static int __init insert_device(struct pnp_bios_node *node)
 
 	/* clear out the damaged flags */
 	if (!dev->active)
-		pnp_init_resource_table(&dev->res);
+		pnp_init_resources(dev);
 
 	pnp_add_device(dev);
 	pnpbios_interface_attach_device(node);

commit 72dcc883d8e5b59105e75ee5265442e458740575
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Apr 28 16:34:07 2008 -0600

    PNP: add debug output to encoders
    
    Add debug output to encoders (enabled by CONFIG_PNP_DEBUG).  This
    uses dev_printk, so I had to add pnp_dev arguments at the same time.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Acked-By: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/pnpbios/core.c b/drivers/pnp/pnpbios/core.c
index 1711e7f29613..76d398531da6 100644
--- a/drivers/pnp/pnpbios/core.c
+++ b/drivers/pnp/pnpbios/core.c
@@ -212,6 +212,7 @@ static int pnpbios_get_resources(struct pnp_dev *dev)
 	if (!pnpbios_is_dynamic(dev))
 		return -EPERM;
 
+	dev_dbg(&dev->dev, "get resources\n");
 	node = kzalloc(node_info.max_node_size, GFP_KERNEL);
 	if (!node)
 		return -1;
@@ -234,6 +235,7 @@ static int pnpbios_set_resources(struct pnp_dev *dev)
 	if (!pnpbios_is_dynamic(dev))
 		return -EPERM;
 
+	dev_dbg(&dev->dev, "set resources\n");
 	node = kzalloc(node_info.max_node_size, GFP_KERNEL);
 	if (!node)
 		return -1;

commit 4ab55d8d4f7b910c4c60e0f8ff70d0dfdd484f02
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Apr 28 16:34:06 2008 -0600

    PNP: remove more pnp_resource_table arguments
    
    Stop passing around struct pnp_resource_table pointers.  In most cases,
    the caller doesn't need to know how the resources are stored inside
    the struct pnp_dev.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Acked-By: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/pnpbios/core.c b/drivers/pnp/pnpbios/core.c
index 9852755b5590..1711e7f29613 100644
--- a/drivers/pnp/pnpbios/core.c
+++ b/drivers/pnp/pnpbios/core.c
@@ -219,7 +219,7 @@ static int pnpbios_get_resources(struct pnp_dev *dev)
 		kfree(node);
 		return -ENODEV;
 	}
-	pnpbios_read_resources_from_node(&dev->res, node);
+	pnpbios_read_resources_from_node(dev, node);
 	dev->active = pnp_is_active(dev);
 	kfree(node);
 	return 0;
@@ -241,7 +241,7 @@ static int pnpbios_set_resources(struct pnp_dev *dev)
 		kfree(node);
 		return -ENODEV;
 	}
-	if (pnpbios_write_resources_to_node(&dev->res, node) < 0) {
+	if (pnpbios_write_resources_to_node(dev, node) < 0) {
 		kfree(node);
 		return -1;
 	}

commit 59284cb4099411bc6f4915a5a4cb76414440c447
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Apr 28 16:34:05 2008 -0600

    PNP: remove pnp_resource_table from internal get/set interfaces
    
    When we call protocol->get() and protocol->set() methods, we currently
    supply pointers to both the pnp_dev and the pnp_resource_table even
    though the pnp_resource_table should always be the one associated with
    the pnp_dev.
    
    This removes the pnp_resource_table arguments to make it clear that
    these methods only operate on the specified pnp_dev.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Acked-By: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/pnpbios/core.c b/drivers/pnp/pnpbios/core.c
index 6af2be2c1d67..9852755b5590 100644
--- a/drivers/pnp/pnpbios/core.c
+++ b/drivers/pnp/pnpbios/core.c
@@ -204,8 +204,7 @@ static int pnp_dock_thread(void *unused)
 
 #endif				/* CONFIG_HOTPLUG */
 
-static int pnpbios_get_resources(struct pnp_dev *dev,
-				 struct pnp_resource_table *res)
+static int pnpbios_get_resources(struct pnp_dev *dev)
 {
 	u8 nodenum = dev->number;
 	struct pnp_bios_node *node;
@@ -220,14 +219,13 @@ static int pnpbios_get_resources(struct pnp_dev *dev,
 		kfree(node);
 		return -ENODEV;
 	}
-	pnpbios_read_resources_from_node(res, node);
+	pnpbios_read_resources_from_node(&dev->res, node);
 	dev->active = pnp_is_active(dev);
 	kfree(node);
 	return 0;
 }
 
-static int pnpbios_set_resources(struct pnp_dev *dev,
-				 struct pnp_resource_table *res)
+static int pnpbios_set_resources(struct pnp_dev *dev)
 {
 	u8 nodenum = dev->number;
 	struct pnp_bios_node *node;
@@ -243,7 +241,7 @@ static int pnpbios_set_resources(struct pnp_dev *dev,
 		kfree(node);
 		return -ENODEV;
 	}
-	if (pnpbios_write_resources_to_node(res, node) < 0) {
+	if (pnpbios_write_resources_to_node(&dev->res, node) < 0) {
 		kfree(node);
 		return -1;
 	}

commit bda1e4e5a3d976046378cd495a63e1ee0847deec
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Apr 28 16:33:54 2008 -0600

    PNP: add pnp_alloc_dev()
    
    Add pnp_alloc_dev() to allocate a struct pnp_dev and fill in the
    protocol, instance number, and initial PNP ID.  Now it is always
    valid to use dev_printk() on any pnp_dev pointer.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Acked-By: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/pnpbios/core.c b/drivers/pnp/pnpbios/core.c
index 3ee5ed437385..6af2be2c1d67 100644
--- a/drivers/pnp/pnpbios/core.c
+++ b/drivers/pnp/pnpbios/core.c
@@ -318,7 +318,6 @@ static int __init insert_device(struct pnp_bios_node *node)
 {
 	struct list_head *pos;
 	struct pnp_dev *dev;
-	struct pnp_id *dev_id;
 	char id[8];
 
 	/* check if the device is already added */
@@ -328,18 +327,11 @@ static int __init insert_device(struct pnp_bios_node *node)
 			return -1;
 	}
 
-	dev = kzalloc(sizeof(struct pnp_dev), GFP_KERNEL);
-	if (!dev)
-		return -1;
-
 	pnp_eisa_id_to_string(node->eisa_id & PNP_EISA_ID_MASK, id);
-	dev_id = pnp_add_id(dev, id);
-	if (!dev_id) {
-		kfree(dev);
+	dev = pnp_alloc_dev(&pnpbios_protocol, node->handle, id);
+	if (!dev)
 		return -1;
-	}
 
-	dev->number = node->handle;
 	pnpbios_parse_data_stream(dev, node);
 	dev->active = pnp_is_active(dev);
 	dev->flags = node->flags;
@@ -352,7 +344,6 @@ static int __init insert_device(struct pnp_bios_node *node)
 		dev->capabilities |= PNP_WRITE;
 	if (dev->flags & PNPBIOS_REMOVABLE)
 		dev->capabilities |= PNP_REMOVABLE;
-	dev->protocol = &pnpbios_protocol;
 
 	/* clear out the damaged flags */
 	if (!dev->active)

commit 25eb846189d20db4114cebf14fee96d69bef4667
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Apr 28 16:33:53 2008 -0600

    PNP: add pnp_eisa_id_to_string()
    
    Converting the EISA ID to a string is messy and error-prone, and
    we might as well use the same code for ISAPNP and PNPBIOS.
    
    PNPACPI uses the conversion done by the ACPI core with
    acpi_ex_eisa_id_to_string().
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Acked-By: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/pnpbios/core.c b/drivers/pnp/pnpbios/core.c
index 2d592aea0aa7..3ee5ed437385 100644
--- a/drivers/pnp/pnpbios/core.c
+++ b/drivers/pnp/pnpbios/core.c
@@ -332,7 +332,7 @@ static int __init insert_device(struct pnp_bios_node *node)
 	if (!dev)
 		return -1;
 
-	pnpid32_to_pnpid(node->eisa_id, id);
+	pnp_eisa_id_to_string(node->eisa_id & PNP_EISA_ID_MASK, id);
 	dev_id = pnp_add_id(dev, id);
 	if (!dev_id) {
 		kfree(dev);

commit 772defc6292bae8b6db298476d1dabd22a99492b
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Apr 28 16:33:52 2008 -0600

    PNP: change pnp_add_id() to allocate its own pnp_id structures
    
    This moves some of the pnp_id knowledge out of the backends and into
    the PNP core.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Acked-By: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/pnpbios/core.c b/drivers/pnp/pnpbios/core.c
index 2a5353bceb24..2d592aea0aa7 100644
--- a/drivers/pnp/pnpbios/core.c
+++ b/drivers/pnp/pnpbios/core.c
@@ -332,16 +332,14 @@ static int __init insert_device(struct pnp_bios_node *node)
 	if (!dev)
 		return -1;
 
-	dev_id = kzalloc(sizeof(struct pnp_id), GFP_KERNEL);
+	pnpid32_to_pnpid(node->eisa_id, id);
+	dev_id = pnp_add_id(dev, id);
 	if (!dev_id) {
 		kfree(dev);
 		return -1;
 	}
 
 	dev->number = node->handle;
-	pnpid32_to_pnpid(node->eisa_id, id);
-	memcpy(dev_id->id, id, 7);
-	pnp_add_id(dev_id, dev);
 	pnpbios_parse_data_stream(dev, node);
 	dev->active = pnp_is_active(dev);
 	dev->flags = node->flags;

commit 1692b27bf37826f85f9c12f8468848885643532a
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Apr 28 16:33:51 2008 -0600

    PNP: make pnp_add_id() internal to PNP core
    
    pnp_add_id() doesn't need to be exposed outside the PNP core, so
    move the declaration to an internal header file.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Acked-By: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/pnpbios/core.c b/drivers/pnp/pnpbios/core.c
index a8a51500e1e9..2a5353bceb24 100644
--- a/drivers/pnp/pnpbios/core.c
+++ b/drivers/pnp/pnpbios/core.c
@@ -69,6 +69,7 @@
 #include <asm/system.h>
 #include <asm/byteorder.h>
 
+#include "../base.h"
 #include "pnpbios.h"
 
 /*

commit 0d63e4f9ea61df1d727bd52a174aba732e6e1853
Author: Jan Blunck <jblunck@suse.de>
Date:   Thu Feb 14 19:34:28 2008 -0800

    Dont touch fs_struct in drivers
    
    The sound drivers and the pnpbios core test for current->root != NULL.  This
    test seems to be unnecessary since we always have rootfs mounted before
    initializing the drivers.
    
    Signed-off-by: Jan Blunck <jblunck@suse.de>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Cc: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Cc: Jaroslav Kysela <perex@suse.cz>
    Acked-by: Takashi Iwai <tiwai@suse.de>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pnp/pnpbios/core.c b/drivers/pnp/pnpbios/core.c
index f7e67197a568..a8a51500e1e9 100644
--- a/drivers/pnp/pnpbios/core.c
+++ b/drivers/pnp/pnpbios/core.c
@@ -105,8 +105,6 @@ static int pnp_dock_event(int dock, struct pnp_docking_station_info *info)
 	char *argv[3], **envp, *buf, *scratch;
 	int i = 0, value;
 
-	if (!current->fs->root)
-		return -EAGAIN;
 	if (!(envp = kcalloc(20, sizeof(char *), GFP_KERNEL)))
 		return -ENOMEM;
 	if (!(buf = kzalloc(256, GFP_KERNEL))) {

commit 2bb9a6b32f98873adf89a0de04c898681a2c5b8e
Author: Thomas Renninger <trenn@suse.de>
Date:   Wed Feb 6 01:40:03 2008 -0800

    pnp: declare PNP option parsing functions as __init
    
    There are three kind of parse functions provided by PNP acpi/bios:
     - get current resources
     - set resources
     - get possible resources
    The first two may be needed later at runtime.
    The possible resource settings should never change dynamically.
    And even if this would make any sense (I doubt it), the current implementation
    only parses possible resource settings at early init time:
      -> declare all the option parsing __init
    
    [akpm@linux-foundation.org: coding-style fixes]
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Acked-By: Rene Herman <rene.herman@gmail.com>
    Cc: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pnp/pnpbios/core.c b/drivers/pnp/pnpbios/core.c
index e33e03f71084..f7e67197a568 100644
--- a/drivers/pnp/pnpbios/core.c
+++ b/drivers/pnp/pnpbios/core.c
@@ -315,7 +315,7 @@ struct pnp_protocol pnpbios_protocol = {
 	.disable = pnpbios_disable_resources,
 };
 
-static int insert_device(struct pnp_bios_node *node)
+static int __init insert_device(struct pnp_bios_node *node)
 {
 	struct list_head *pos;
 	struct pnp_dev *dev;

commit 36405e96c8090fc8fc05d56755645a5821c98992
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Oct 16 23:31:11 2007 -0700

    PNP: simplify PNPBIOS insert_device
    
    Hoist the struct pnp_dev alloc up into the function where it's used.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Cc: Adam Belay <ambx1@neo.rr.com>
    Cc: Len Brown <lenb@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pnp/pnpbios/core.c b/drivers/pnp/pnpbios/core.c
index 4e9fd37cff35..e33e03f71084 100644
--- a/drivers/pnp/pnpbios/core.c
+++ b/drivers/pnp/pnpbios/core.c
@@ -315,25 +315,31 @@ struct pnp_protocol pnpbios_protocol = {
 	.disable = pnpbios_disable_resources,
 };
 
-static int insert_device(struct pnp_dev *dev, struct pnp_bios_node *node)
+static int insert_device(struct pnp_bios_node *node)
 {
 	struct list_head *pos;
-	struct pnp_dev *pnp_dev;
+	struct pnp_dev *dev;
 	struct pnp_id *dev_id;
 	char id[8];
 
 	/* check if the device is already added */
-	dev->number = node->handle;
 	list_for_each(pos, &pnpbios_protocol.devices) {
-		pnp_dev = list_entry(pos, struct pnp_dev, protocol_list);
-		if (dev->number == pnp_dev->number)
+		dev = list_entry(pos, struct pnp_dev, protocol_list);
+		if (dev->number == node->handle)
 			return -1;
 	}
 
-	/* set the initial values for the PnP device */
+	dev = kzalloc(sizeof(struct pnp_dev), GFP_KERNEL);
+	if (!dev)
+		return -1;
+
 	dev_id = kzalloc(sizeof(struct pnp_id), GFP_KERNEL);
-	if (!dev_id)
+	if (!dev_id) {
+		kfree(dev);
 		return -1;
+	}
+
+	dev->number = node->handle;
 	pnpid32_to_pnpid(node->eisa_id, id);
 	memcpy(dev_id->id, id, 7);
 	pnp_add_id(dev_id, dev);
@@ -367,7 +373,6 @@ static void __init build_devlist(void)
 	unsigned int nodes_got = 0;
 	unsigned int devs = 0;
 	struct pnp_bios_node *node;
-	struct pnp_dev *dev;
 
 	node = kzalloc(node_info.max_node_size, GFP_KERNEL);
 	if (!node)
@@ -388,12 +393,7 @@ static void __init build_devlist(void)
 				break;
 		}
 		nodes_got++;
-		dev = kzalloc(sizeof(struct pnp_dev), GFP_KERNEL);
-		if (!dev)
-			break;
-		if (insert_device(dev, node) < 0)
-			kfree(dev);
-		else
+		if (insert_device(node) == 0)
 			devs++;
 		if (nodenum <= thisnodenum) {
 			printk(KERN_ERR

commit 1855256c497ecfefc730df6032243f26855ce52c
Author: Jeff Garzik <jeff@garzik.org>
Date:   Wed Oct 3 15:15:40 2007 -0400

    drivers/firmware: const-ify DMI API and internals
    
    Three main sets of changes:
    
    1) dmi_get_system_info() return value should have been marked const,
       since callers should not be changing that data.
    
    2) const-ify DMI internals, since DMI firmware tables should,
       whenever possible, be marked const to ensure we never ever write to
       that data area.
    
    3) const-ify DMI API, to enable marking tables const where possible
       in low-level drivers.
    
    And if we're really lucky, this might enable some additional
    optimizations on the part of the compiler.
    
    The bulk of the changes are #2 and #3, which are interrelated.  #1 could
    have been a separate patch, but it was so small compared to the others,
    it was easier to roll it into this changeset.
    
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/pnp/pnpbios/core.c b/drivers/pnp/pnpbios/core.c
index 0691f473e9d4..4e9fd37cff35 100644
--- a/drivers/pnp/pnpbios/core.c
+++ b/drivers/pnp/pnpbios/core.c
@@ -500,7 +500,7 @@ static int __init pnpbios_probe_system(void)
 	return 0;
 }
 
-static int __init exploding_pnp_bios(struct dmi_system_id *d)
+static int __init exploding_pnp_bios(const struct dmi_system_id *d)
 {
 	printk(KERN_WARNING "%s detected. Disabling PnPBIOS\n", d->ident);
 	return 0;

commit 4f0217e30249ac0eb13b65ef64f2aee627465da2
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Wed Aug 15 10:32:12 2007 -0600

    PNP: remove MODULE infrastructure
    
    We don't support building any part of PNP as a module (*drivers* can be
    modules, of course, but the PNP infrastructure itself can not).  Since
    MODULE will never be defined, remove the ifdefs and dead code.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Acked-by: Adam Belay <abelay@novell.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/pnpbios/core.c b/drivers/pnp/pnpbios/core.c
index 9892a6afe46c..0691f473e9d4 100644
--- a/drivers/pnp/pnpbios/core.c
+++ b/drivers/pnp/pnpbios/core.c
@@ -419,7 +419,6 @@ static void __init build_devlist(void)
 static int pnpbios_disabled;
 int pnpbios_dont_use_current_config;
 
-#ifndef MODULE
 static int __init pnpbios_setup(char *str)
 {
 	int invert;
@@ -443,7 +442,6 @@ static int __init pnpbios_setup(char *str)
 }
 
 __setup("pnpbios=", pnpbios_setup);
-#endif
 
 /* PnP BIOS signature: "$PnP" */
 #define PNP_SIGNATURE   (('$' << 0) + ('P' << 8) + ('n' << 16) + ('P' << 24))
@@ -607,48 +605,7 @@ static int __init pnpbios_thread_init(void)
 	return 0;
 }
 
-#ifndef MODULE
-
-/* init/main.c calls pnpbios_init early */
-
 /* Start the kernel thread later: */
 module_init(pnpbios_thread_init);
 
-#else
-
-/*
- * N.B.: Building pnpbios as a module hasn't been fully implemented
- */
-
-MODULE_LICENSE("GPL");
-
-static int __init pnpbios_init_all(void)
-{
-	int r;
-
-	r = pnpbios_init();
-	if (r)
-		return r;
-	r = pnpbios_thread_init();
-	if (r)
-		return r;
-	return 0;
-}
-
-static void __exit pnpbios_exit(void)
-{
-#ifdef CONFIG_HOTPLUG
-	unloading = 1;
-	wait_for_completion(&unload_sem);
-#endif
-	pnpbios_proc_exit();
-	/* We ought to free resources here */
-	return;
-}
-
-module_init(pnpbios_init_all);
-module_exit(pnpbios_exit);
-
-#endif
-
 EXPORT_SYMBOL(pnpbios_protocol);

commit 1e0aa9ad721349781b728ec4226876247e3fd431
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Wed Aug 15 10:32:08 2007 -0600

    PNP: fix up after Lindent
    
    More manual fixups after Lindent.  No functional change.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Acked-by: Adam Belay <abelay@novell.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/pnpbios/core.c b/drivers/pnp/pnpbios/core.c
index 3692a099b45f..9892a6afe46c 100644
--- a/drivers/pnp/pnpbios/core.c
+++ b/drivers/pnp/pnpbios/core.c
@@ -591,6 +591,7 @@ subsys_initcall(pnpbios_init);
 static int __init pnpbios_thread_init(void)
 {
 	struct task_struct *task;
+
 #if defined(CONFIG_PPC_MERGE)
 	if (check_legacy_ioport(PNPBIOS_BASE))
 		return 0;

commit 07d4e9af109221ab731c5aaf832e89776c64b013
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Thu Jul 26 10:41:21 2007 -0700

    PNP: fix up after Lindent
    
    These are manual fixups after running Lindent.  No functional change.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Adam Belay <ambx1@neo.rr.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pnp/pnpbios/core.c b/drivers/pnp/pnpbios/core.c
index 21289cb13a33..3692a099b45f 100644
--- a/drivers/pnp/pnpbios/core.c
+++ b/drivers/pnp/pnpbios/core.c
@@ -100,25 +100,24 @@ static struct completion unload_sem;
 /*
  * (Much of this belongs in a shared routine somewhere)
  */
-
 static int pnp_dock_event(int dock, struct pnp_docking_station_info *info)
 {
 	char *argv[3], **envp, *buf, *scratch;
 	int i = 0, value;
 
-	if (!current->fs->root) {
+	if (!current->fs->root)
 		return -EAGAIN;
-	}
-	if (!(envp = kcalloc(20, sizeof(char *), GFP_KERNEL))) {
+	if (!(envp = kcalloc(20, sizeof(char *), GFP_KERNEL)))
 		return -ENOMEM;
-	}
 	if (!(buf = kzalloc(256, GFP_KERNEL))) {
 		kfree(envp);
 		return -ENOMEM;
 	}
 
-	/* FIXME: if there are actual users of this, it should be integrated into
-	 * the driver core and use the usual infrastructure like sysfs and uevents */
+	/* FIXME: if there are actual users of this, it should be
+	 * integrated into the driver core and use the usual infrastructure
+	 * like sysfs and uevents
+	 */
 	argv[0] = "/sbin/pnpbios";
 	argv[1] = "dock";
 	argv[2] = NULL;
@@ -146,7 +145,7 @@ static int pnp_dock_event(int dock, struct pnp_docking_station_info *info)
 			   info->location_id, info->serial, info->capabilities);
 	envp[i] = NULL;
 
-	value = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_EXEC);
+	value = call_usermodehelper(argv [0], argv, envp, UMH_WAIT_EXEC);
 	kfree(buf);
 	kfree(envp);
 	return 0;
@@ -159,6 +158,7 @@ static int pnp_dock_thread(void *unused)
 {
 	static struct pnp_docking_station_info now;
 	int docked = -1, d = 0;
+
 	set_freezable();
 	while (!unloading) {
 		int status;
@@ -203,7 +203,7 @@ static int pnp_dock_thread(void *unused)
 	complete_and_exit(&unload_sem, 0);
 }
 
-#endif /* CONFIG_HOTPLUG */
+#endif				/* CONFIG_HOTPLUG */
 
 static int pnpbios_get_resources(struct pnp_dev *dev,
 				 struct pnp_resource_table *res)
@@ -211,7 +211,6 @@ static int pnpbios_get_resources(struct pnp_dev *dev,
 	u8 nodenum = dev->number;
 	struct pnp_bios_node *node;
 
-	/* just in case */
 	if (!pnpbios_is_dynamic(dev))
 		return -EPERM;
 
@@ -235,7 +234,6 @@ static int pnpbios_set_resources(struct pnp_dev *dev,
 	struct pnp_bios_node *node;
 	int ret;
 
-	/* just in case */
 	if (!pnpbios_is_dynamic(dev))
 		return -EPERM;
 
@@ -263,6 +261,7 @@ static void pnpbios_zero_data_stream(struct pnp_bios_node *node)
 	unsigned char *end = (char *)(node->data + node->size);
 	unsigned int len;
 	int i;
+
 	while ((char *)p < (char *)end) {
 		if (p[0] & 0x80) {	/* large tag */
 			len = (p[2] << 8) | p[1];
@@ -287,7 +286,6 @@ static int pnpbios_disable_resources(struct pnp_dev *dev)
 	u8 nodenum = dev->number;
 	int ret;
 
-	/* just in case */
 	if (dev->flags & PNPBIOS_NO_DISABLE || !pnpbios_is_dynamic(dev))
 		return -EPERM;
 
@@ -418,8 +416,8 @@ static void __init build_devlist(void)
  *
  */
 
-static int pnpbios_disabled;	/* = 0 */
-int pnpbios_dont_use_current_config;	/* = 0 */
+static int pnpbios_disabled;
+int pnpbios_dont_use_current_config;
 
 #ifndef MODULE
 static int __init pnpbios_setup(char *str)
@@ -551,7 +549,7 @@ static int __init pnpbios_init(void)
 		printk(KERN_INFO "PnPBIOS: Disabled by ACPI PNP\n");
 		return -ENODEV;
 	}
-#endif /* CONFIG_ACPI */
+#endif				/* CONFIG_ACPI */
 
 	/* scan the system for pnpbios support */
 	if (!pnpbios_probe_system())

commit 9dd78466c956ac4b4f38e12032dc4249ccf57ad1
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Thu Jul 26 10:41:20 2007 -0700

    PNP: Lindent all source files
    
    Run Lindent on all PNP source files.
    
    Produced by:
    
        $ quilt new pnp-lindent
        $ find drivers/pnp -name \*.[ch] | xargs quilt add
        $ quilt add include/linux/{pnp.h,pnpbios.h}
        $ scripts/Lindent drivers/pnp/*.c drivers/pnp/*/*.c include/linux/pnp*.h
        $ quilt refresh --sort
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Adam Belay <ambx1@neo.rr.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pnp/pnpbios/core.c b/drivers/pnp/pnpbios/core.c
index ed112ee16012..21289cb13a33 100644
--- a/drivers/pnp/pnpbios/core.c
+++ b/drivers/pnp/pnpbios/core.c
@@ -32,7 +32,7 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
- 
+
 /* Change Log
  *
  * Adam Belay - <ambx1@neo.rr.com> - March 16, 2003
@@ -71,14 +71,13 @@
 
 #include "pnpbios.h"
 
-
 /*
  *
  * PnP BIOS INTERFACE
  *
  */
 
-static union pnp_bios_install_struct * pnp_bios_install = NULL;
+static union pnp_bios_install_struct *pnp_bios_install = NULL;
 
 int pnp_bios_present(void)
 {
@@ -101,36 +100,36 @@ static struct completion unload_sem;
 /*
  * (Much of this belongs in a shared routine somewhere)
  */
- 
+
 static int pnp_dock_event(int dock, struct pnp_docking_station_info *info)
 {
-	char *argv [3], **envp, *buf, *scratch;
+	char *argv[3], **envp, *buf, *scratch;
 	int i = 0, value;
 
 	if (!current->fs->root) {
 		return -EAGAIN;
 	}
-	if (!(envp = kcalloc(20, sizeof (char *), GFP_KERNEL))) {
+	if (!(envp = kcalloc(20, sizeof(char *), GFP_KERNEL))) {
 		return -ENOMEM;
 	}
 	if (!(buf = kzalloc(256, GFP_KERNEL))) {
-		kfree (envp);
+		kfree(envp);
 		return -ENOMEM;
 	}
 
 	/* FIXME: if there are actual users of this, it should be integrated into
 	 * the driver core and use the usual infrastructure like sysfs and uevents */
-	argv [0] = "/sbin/pnpbios";
-	argv [1] = "dock";
-	argv [2] = NULL;
+	argv[0] = "/sbin/pnpbios";
+	argv[1] = "dock";
+	argv[2] = NULL;
 
 	/* minimal command environment */
-	envp [i++] = "HOME=/";
-	envp [i++] = "PATH=/sbin:/bin:/usr/sbin:/usr/bin";
+	envp[i++] = "HOME=/";
+	envp[i++] = "PATH=/sbin:/bin:/usr/sbin:/usr/bin";
 
 #ifdef	DEBUG
 	/* hint that policy agent should enter no-stdout debug mode */
-	envp [i++] = "DEBUG=kernel";
+	envp[i++] = "DEBUG=kernel";
 #endif
 	/* extensible set of named bus-specific parameters,
 	 * supporting multiple driver selection algorithms.
@@ -138,33 +137,32 @@ static int pnp_dock_event(int dock, struct pnp_docking_station_info *info)
 	scratch = buf;
 
 	/* action:  add, remove */
-	envp [i++] = scratch;
-	scratch += sprintf (scratch, "ACTION=%s", dock?"add":"remove") + 1;
+	envp[i++] = scratch;
+	scratch += sprintf(scratch, "ACTION=%s", dock ? "add" : "remove") + 1;
 
 	/* Report the ident for the dock */
-	envp [i++] = scratch;
-	scratch += sprintf (scratch, "DOCK=%x/%x/%x",
-		info->location_id, info->serial, info->capabilities);
+	envp[i++] = scratch;
+	scratch += sprintf(scratch, "DOCK=%x/%x/%x",
+			   info->location_id, info->serial, info->capabilities);
 	envp[i] = NULL;
-	
-	value = call_usermodehelper (argv [0], argv, envp, UMH_WAIT_EXEC);
-	kfree (buf);
-	kfree (envp);
+
+	value = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_EXEC);
+	kfree(buf);
+	kfree(envp);
 	return 0;
 }
 
 /*
  * Poll the PnP docking at regular intervals
  */
-static int pnp_dock_thread(void * unused)
+static int pnp_dock_thread(void *unused)
 {
 	static struct pnp_docking_station_info now;
 	int docked = -1, d = 0;
 	set_freezable();
-	while (!unloading)
-	{
+	while (!unloading) {
 		int status;
-		
+
 		/*
 		 * Poll every 2 seconds
 		 */
@@ -175,30 +173,29 @@ static int pnp_dock_thread(void * unused)
 
 		status = pnp_bios_dock_station_info(&now);
 
-		switch(status)
-		{
+		switch (status) {
 			/*
 			 * No dock to manage
 			 */
-			case PNP_FUNCTION_NOT_SUPPORTED:
-				complete_and_exit(&unload_sem, 0);
-			case PNP_SYSTEM_NOT_DOCKED:
-				d = 0;
-				break;
-			case PNP_SUCCESS:
-				d = 1;
-				break;
-			default:
-				pnpbios_print_status( "pnp_dock_thread", status );
-				continue;
+		case PNP_FUNCTION_NOT_SUPPORTED:
+			complete_and_exit(&unload_sem, 0);
+		case PNP_SYSTEM_NOT_DOCKED:
+			d = 0;
+			break;
+		case PNP_SUCCESS:
+			d = 1;
+			break;
+		default:
+			pnpbios_print_status("pnp_dock_thread", status);
+			continue;
 		}
-		if(d != docked)
-		{
-			if(pnp_dock_event(d, &now)==0)
-			{
+		if (d != docked) {
+			if (pnp_dock_event(d, &now) == 0) {
 				docked = d;
 #if 0
-				printk(KERN_INFO "PnPBIOS: Docking station %stached\n", docked?"at":"de");
+				printk(KERN_INFO
+				       "PnPBIOS: Docking station %stached\n",
+				       docked ? "at" : "de");
 #endif
 			}
 		}
@@ -206,21 +203,22 @@ static int pnp_dock_thread(void * unused)
 	complete_and_exit(&unload_sem, 0);
 }
 
-#endif   /* CONFIG_HOTPLUG */
+#endif /* CONFIG_HOTPLUG */
 
-static int pnpbios_get_resources(struct pnp_dev * dev, struct pnp_resource_table * res)
+static int pnpbios_get_resources(struct pnp_dev *dev,
+				 struct pnp_resource_table *res)
 {
 	u8 nodenum = dev->number;
-	struct pnp_bios_node * node;
+	struct pnp_bios_node *node;
 
 	/* just in case */
-	if(!pnpbios_is_dynamic(dev))
+	if (!pnpbios_is_dynamic(dev))
 		return -EPERM;
 
 	node = kzalloc(node_info.max_node_size, GFP_KERNEL);
 	if (!node)
 		return -1;
-	if (pnp_bios_get_dev_node(&nodenum, (char )PNPMODE_DYNAMIC, node)) {
+	if (pnp_bios_get_dev_node(&nodenum, (char)PNPMODE_DYNAMIC, node)) {
 		kfree(node);
 		return -ENODEV;
 	}
@@ -230,10 +228,11 @@ static int pnpbios_get_resources(struct pnp_dev * dev, struct pnp_resource_table
 	return 0;
 }
 
-static int pnpbios_set_resources(struct pnp_dev * dev, struct pnp_resource_table * res)
+static int pnpbios_set_resources(struct pnp_dev *dev,
+				 struct pnp_resource_table *res)
 {
 	u8 nodenum = dev->number;
-	struct pnp_bios_node * node;
+	struct pnp_bios_node *node;
 	int ret;
 
 	/* just in case */
@@ -243,11 +242,11 @@ static int pnpbios_set_resources(struct pnp_dev * dev, struct pnp_resource_table
 	node = kzalloc(node_info.max_node_size, GFP_KERNEL);
 	if (!node)
 		return -1;
-	if (pnp_bios_get_dev_node(&nodenum, (char )PNPMODE_DYNAMIC, node)) {
+	if (pnp_bios_get_dev_node(&nodenum, (char)PNPMODE_DYNAMIC, node)) {
 		kfree(node);
 		return -ENODEV;
 	}
-	if(pnpbios_write_resources_to_node(res, node)<0) {
+	if (pnpbios_write_resources_to_node(res, node) < 0) {
 		kfree(node);
 		return -1;
 	}
@@ -258,18 +257,18 @@ static int pnpbios_set_resources(struct pnp_dev * dev, struct pnp_resource_table
 	return ret;
 }
 
-static void pnpbios_zero_data_stream(struct pnp_bios_node * node)
+static void pnpbios_zero_data_stream(struct pnp_bios_node *node)
 {
-	unsigned char * p = (char *)node->data;
-	unsigned char * end = (char *)(node->data + node->size);
+	unsigned char *p = (char *)node->data;
+	unsigned char *end = (char *)(node->data + node->size);
 	unsigned int len;
 	int i;
 	while ((char *)p < (char *)end) {
-		if(p[0] & 0x80) { /* large tag */
+		if (p[0] & 0x80) {	/* large tag */
 			len = (p[2] << 8) | p[1];
 			p += 3;
 		} else {
-			if (((p[0]>>3) & 0x0f) == 0x0f)
+			if (((p[0] >> 3) & 0x0f) == 0x0f)
 				return;
 			len = p[0] & 0x07;
 			p += 1;
@@ -278,24 +277,25 @@ static void pnpbios_zero_data_stream(struct pnp_bios_node * node)
 			p[i] = 0;
 		p += len;
 	}
-	printk(KERN_ERR "PnPBIOS: Resource structure did not contain an end tag.\n");
+	printk(KERN_ERR
+	       "PnPBIOS: Resource structure did not contain an end tag.\n");
 }
 
 static int pnpbios_disable_resources(struct pnp_dev *dev)
 {
-	struct pnp_bios_node * node;
+	struct pnp_bios_node *node;
 	u8 nodenum = dev->number;
 	int ret;
 
 	/* just in case */
-	if(dev->flags & PNPBIOS_NO_DISABLE || !pnpbios_is_dynamic(dev))
+	if (dev->flags & PNPBIOS_NO_DISABLE || !pnpbios_is_dynamic(dev))
 		return -EPERM;
 
 	node = kzalloc(node_info.max_node_size, GFP_KERNEL);
 	if (!node)
 		return -ENOMEM;
 
-	if (pnp_bios_get_dev_node(&nodenum, (char )PNPMODE_DYNAMIC, node)) {
+	if (pnp_bios_get_dev_node(&nodenum, (char)PNPMODE_DYNAMIC, node)) {
 		kfree(node);
 		return -ENODEV;
 	}
@@ -311,22 +311,22 @@ static int pnpbios_disable_resources(struct pnp_dev *dev)
 /* PnP Layer support */
 
 struct pnp_protocol pnpbios_protocol = {
-	.name	= "Plug and Play BIOS",
-	.get	= pnpbios_get_resources,
-	.set	= pnpbios_set_resources,
+	.name = "Plug and Play BIOS",
+	.get = pnpbios_get_resources,
+	.set = pnpbios_set_resources,
 	.disable = pnpbios_disable_resources,
 };
 
-static int insert_device(struct pnp_dev *dev, struct pnp_bios_node * node)
+static int insert_device(struct pnp_dev *dev, struct pnp_bios_node *node)
 {
-	struct list_head * pos;
-	struct pnp_dev * pnp_dev;
+	struct list_head *pos;
+	struct pnp_dev *pnp_dev;
 	struct pnp_id *dev_id;
 	char id[8];
 
 	/* check if the device is already added */
 	dev->number = node->handle;
-	list_for_each (pos, &pnpbios_protocol.devices){
+	list_for_each(pos, &pnpbios_protocol.devices) {
 		pnp_dev = list_entry(pos, struct pnp_dev, protocol_list);
 		if (dev->number == pnp_dev->number)
 			return -1;
@@ -336,8 +336,8 @@ static int insert_device(struct pnp_dev *dev, struct pnp_bios_node * node)
 	dev_id = kzalloc(sizeof(struct pnp_id), GFP_KERNEL);
 	if (!dev_id)
 		return -1;
-	pnpid32_to_pnpid(node->eisa_id,id);
-	memcpy(dev_id->id,id,7);
+	pnpid32_to_pnpid(node->eisa_id, id);
+	memcpy(dev_id->id, id, 7);
 	pnp_add_id(dev_id, dev);
 	pnpbios_parse_data_stream(dev, node);
 	dev->active = pnp_is_active(dev);
@@ -375,35 +375,41 @@ static void __init build_devlist(void)
 	if (!node)
 		return;
 
-	for(nodenum=0; nodenum<0xff; ) {
+	for (nodenum = 0; nodenum < 0xff;) {
 		u8 thisnodenum = nodenum;
 		/* eventually we will want to use PNPMODE_STATIC here but for now
 		 * dynamic will help us catch buggy bioses to add to the blacklist.
 		 */
 		if (!pnpbios_dont_use_current_config) {
-			if (pnp_bios_get_dev_node(&nodenum, (char )PNPMODE_DYNAMIC, node))
+			if (pnp_bios_get_dev_node
+			    (&nodenum, (char)PNPMODE_DYNAMIC, node))
 				break;
 		} else {
-			if (pnp_bios_get_dev_node(&nodenum, (char )PNPMODE_STATIC, node))
+			if (pnp_bios_get_dev_node
+			    (&nodenum, (char)PNPMODE_STATIC, node))
 				break;
 		}
 		nodes_got++;
-		dev =  kzalloc(sizeof (struct pnp_dev), GFP_KERNEL);
+		dev = kzalloc(sizeof(struct pnp_dev), GFP_KERNEL);
 		if (!dev)
 			break;
-		if(insert_device(dev,node)<0)
+		if (insert_device(dev, node) < 0)
 			kfree(dev);
 		else
 			devs++;
 		if (nodenum <= thisnodenum) {
-			printk(KERN_ERR "PnPBIOS: build_devlist: Node number 0x%x is out of sequence following node 0x%x. Aborting.\n", (unsigned int)nodenum, (unsigned int)thisnodenum);
+			printk(KERN_ERR
+			       "PnPBIOS: build_devlist: Node number 0x%x is out of sequence following node 0x%x. Aborting.\n",
+			       (unsigned int)nodenum,
+			       (unsigned int)thisnodenum);
 			break;
 		}
 	}
 	kfree(node);
 
-	printk(KERN_INFO "PnPBIOS: %i node%s reported by PnP BIOS; %i recorded by driver\n",
-		nodes_got, nodes_got != 1 ? "s" : "", devs);
+	printk(KERN_INFO
+	       "PnPBIOS: %i node%s reported by PnP BIOS; %i recorded by driver\n",
+	       nodes_got, nodes_got != 1 ? "s" : "", devs);
 }
 
 /*
@@ -412,8 +418,8 @@ static void __init build_devlist(void)
  *
  */
 
-static int pnpbios_disabled; /* = 0 */
-int pnpbios_dont_use_current_config; /* = 0 */
+static int pnpbios_disabled;	/* = 0 */
+int pnpbios_dont_use_current_config;	/* = 0 */
 
 #ifndef MODULE
 static int __init pnpbios_setup(char *str)
@@ -422,9 +428,9 @@ static int __init pnpbios_setup(char *str)
 
 	while ((str != NULL) && (*str != '\0')) {
 		if (strncmp(str, "off", 3) == 0)
-			pnpbios_disabled=1;
+			pnpbios_disabled = 1;
 		if (strncmp(str, "on", 2) == 0)
-			pnpbios_disabled=0;
+			pnpbios_disabled = 0;
 		invert = (strncmp(str, "no-", 3) == 0);
 		if (invert)
 			str += 3;
@@ -453,35 +459,41 @@ static int __init pnpbios_probe_system(void)
 	printk(KERN_INFO "PnPBIOS: Scanning system for PnP BIOS support...\n");
 
 	/*
- 	 * Search the defined area (0xf0000-0xffff0) for a valid PnP BIOS
+	 * Search the defined area (0xf0000-0xffff0) for a valid PnP BIOS
 	 * structure and, if one is found, sets up the selectors and
 	 * entry points
 	 */
-	for (check = (union pnp_bios_install_struct *) __va(0xf0000);
-	     check < (union pnp_bios_install_struct *) __va(0xffff0);
+	for (check = (union pnp_bios_install_struct *)__va(0xf0000);
+	     check < (union pnp_bios_install_struct *)__va(0xffff0);
 	     check = (void *)check + 16) {
 		if (check->fields.signature != PNP_SIGNATURE)
 			continue;
-		printk(KERN_INFO "PnPBIOS: Found PnP BIOS installation structure at 0x%p\n", check);
+		printk(KERN_INFO
+		       "PnPBIOS: Found PnP BIOS installation structure at 0x%p\n",
+		       check);
 		length = check->fields.length;
 		if (!length) {
-			printk(KERN_ERR "PnPBIOS: installation structure is invalid, skipping\n");
+			printk(KERN_ERR
+			       "PnPBIOS: installation structure is invalid, skipping\n");
 			continue;
 		}
 		for (sum = 0, i = 0; i < length; i++)
 			sum += check->chars[i];
 		if (sum) {
-			printk(KERN_ERR "PnPBIOS: installation structure is corrupted, skipping\n");
+			printk(KERN_ERR
+			       "PnPBIOS: installation structure is corrupted, skipping\n");
 			continue;
 		}
 		if (check->fields.version < 0x10) {
-			printk(KERN_WARNING "PnPBIOS: PnP BIOS version %d.%d is not supported\n",
+			printk(KERN_WARNING
+			       "PnPBIOS: PnP BIOS version %d.%d is not supported\n",
 			       check->fields.version >> 4,
 			       check->fields.version & 15);
 			continue;
 		}
-		printk(KERN_INFO "PnPBIOS: PnP BIOS version %d.%d, entry 0x%x:0x%x, dseg 0x%x\n",
-                       check->fields.version >> 4, check->fields.version & 15,
+		printk(KERN_INFO
+		       "PnPBIOS: PnP BIOS version %d.%d, entry 0x%x:0x%x, dseg 0x%x\n",
+		       check->fields.version >> 4, check->fields.version & 15,
 		       check->fields.pm16cseg, check->fields.pm16offset,
 		       check->fields.pm16dseg);
 		pnp_bios_install = check;
@@ -499,25 +511,25 @@ static int __init exploding_pnp_bios(struct dmi_system_id *d)
 }
 
 static struct dmi_system_id pnpbios_dmi_table[] __initdata = {
-	{	/* PnPBIOS GPF on boot */
-		.callback = exploding_pnp_bios,
-		.ident = "Higraded P14H",
-		.matches = {
-			DMI_MATCH(DMI_BIOS_VENDOR, "American Megatrends Inc."),
-			DMI_MATCH(DMI_BIOS_VERSION, "07.00T"),
-			DMI_MATCH(DMI_SYS_VENDOR, "Higraded"),
-			DMI_MATCH(DMI_PRODUCT_NAME, "P14H"),
-		},
-	},
-	{	/* PnPBIOS GPF on boot */
-		.callback = exploding_pnp_bios,
-		.ident = "ASUS P4P800",
-		.matches = {
-			DMI_MATCH(DMI_BOARD_VENDOR, "ASUSTeK Computer Inc."),
-			DMI_MATCH(DMI_BOARD_NAME, "P4P800"),
-		},
-	},
-	{ }
+	{			/* PnPBIOS GPF on boot */
+	 .callback = exploding_pnp_bios,
+	 .ident = "Higraded P14H",
+	 .matches = {
+		     DMI_MATCH(DMI_BIOS_VENDOR, "American Megatrends Inc."),
+		     DMI_MATCH(DMI_BIOS_VERSION, "07.00T"),
+		     DMI_MATCH(DMI_SYS_VENDOR, "Higraded"),
+		     DMI_MATCH(DMI_PRODUCT_NAME, "P14H"),
+		     },
+	 },
+	{			/* PnPBIOS GPF on boot */
+	 .callback = exploding_pnp_bios,
+	 .ident = "ASUS P4P800",
+	 .matches = {
+		     DMI_MATCH(DMI_BOARD_VENDOR, "ASUSTeK Computer Inc."),
+		     DMI_MATCH(DMI_BOARD_NAME, "P4P800"),
+		     },
+	 },
+	{}
 };
 
 static int __init pnpbios_init(void)
@@ -533,7 +545,6 @@ static int __init pnpbios_init(void)
 		printk(KERN_INFO "PnPBIOS: Disabled\n");
 		return -ENODEV;
 	}
-
 #ifdef CONFIG_PNPACPI
 	if (!acpi_disabled && !pnpacpi_disabled) {
 		pnpbios_disabled = 1;
@@ -552,14 +563,16 @@ static int __init pnpbios_init(void)
 	/* read the node info */
 	ret = pnp_bios_dev_node_info(&node_info);
 	if (ret) {
-		printk(KERN_ERR "PnPBIOS: Unable to get node info.  Aborting.\n");
+		printk(KERN_ERR
+		       "PnPBIOS: Unable to get node info.  Aborting.\n");
 		return ret;
 	}
 
 	/* register with the pnp layer */
 	ret = pnp_register_protocol(&pnpbios_protocol);
 	if (ret) {
-		printk(KERN_ERR "PnPBIOS: Unable to register driver.  Aborting.\n");
+		printk(KERN_ERR
+		       "PnPBIOS: Unable to register driver.  Aborting.\n");
 		return ret;
 	}
 

commit 86313c488a6848b7ec2ba04e74f25f79dd32a0b7
Author: Jeremy Fitzhardinge <jeremy@xensource.com>
Date:   Tue Jul 17 18:37:03 2007 -0700

    usermodehelper: Tidy up waiting
    
    Rather than using a tri-state integer for the wait flag in
    call_usermodehelper_exec, define a proper enum, and use that.  I've
    preserved the integer values so that any callers I've missed should
    still work OK.
    
    Signed-off-by: Jeremy Fitzhardinge <jeremy@xensource.com>
    Cc: James Bottomley <James.Bottomley@HansenPartnership.com>
    Cc: Randy Dunlap <randy.dunlap@oracle.com>
    Cc: Christoph Hellwig <hch@infradead.org>
    Cc: Andi Kleen <ak@suse.de>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Johannes Berg <johannes@sipsolutions.net>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Cc: Joel Becker <joel.becker@oracle.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Cc: Srivatsa Vaddagiri <vatsa@in.ibm.com>
    Cc: Oleg Nesterov <oleg@tv-sign.ru>
    Cc: David Howells <dhowells@redhat.com>

diff --git a/drivers/pnp/pnpbios/core.c b/drivers/pnp/pnpbios/core.c
index 03baf1c64a2e..ed112ee16012 100644
--- a/drivers/pnp/pnpbios/core.c
+++ b/drivers/pnp/pnpbios/core.c
@@ -147,7 +147,7 @@ static int pnp_dock_event(int dock, struct pnp_docking_station_info *info)
 		info->location_id, info->serial, info->capabilities);
 	envp[i] = NULL;
 	
-	value = call_usermodehelper (argv [0], argv, envp, 0);
+	value = call_usermodehelper (argv [0], argv, envp, UMH_WAIT_EXEC);
 	kfree (buf);
 	kfree (envp);
 	return 0;

commit 831441862956fffa17b9801db37e6ea1650b0f69
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Jul 17 04:03:35 2007 -0700

    Freezer: make kernel threads nonfreezable by default
    
    Currently, the freezer treats all tasks as freezable, except for the kernel
    threads that explicitly set the PF_NOFREEZE flag for themselves.  This
    approach is problematic, since it requires every kernel thread to either
    set PF_NOFREEZE explicitly, or call try_to_freeze(), even if it doesn't
    care for the freezing of tasks at all.
    
    It seems better to only require the kernel threads that want to or need to
    be frozen to use some freezer-related code and to remove any
    freezer-related code from the other (nonfreezable) kernel threads, which is
    done in this patch.
    
    The patch causes all kernel threads to be nonfreezable by default (ie.  to
    have PF_NOFREEZE set by default) and introduces the set_freezable()
    function that should be called by the freezable kernel threads in order to
    unset PF_NOFREEZE.  It also makes all of the currently freezable kernel
    threads call set_freezable(), so it shouldn't cause any (intentional)
    change of behaviour to appear.  Additionally, it updates documentation to
    describe the freezing of tasks more accurately.
    
    [akpm@linux-foundation.org: build fixes]
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Nigel Cunningham <nigel@nigel.suspend2.net>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Oleg Nesterov <oleg@tv-sign.ru>
    Cc: Gautham R Shenoy <ego@in.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pnp/pnpbios/core.c b/drivers/pnp/pnpbios/core.c
index 3a201b77b963..03baf1c64a2e 100644
--- a/drivers/pnp/pnpbios/core.c
+++ b/drivers/pnp/pnpbios/core.c
@@ -160,6 +160,7 @@ static int pnp_dock_thread(void * unused)
 {
 	static struct pnp_docking_station_info now;
 	int docked = -1, d = 0;
+	set_freezable();
 	while (!unloading)
 	{
 		int status;

commit 8f81dd149806bc53c68c92f34d61f88427079039
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue May 8 00:35:54 2007 -0700

    PNP: notice whether we have PNP devices (PNPBIOS or PNPACPI)
    
    This series converts i386 and x86_64 legacy serial ports to be platform
    devices and prevents probing for them if we have PNP.
    
    This prevents double discovery, where a device was found both by the legacy
    probe and by 8250_pnp.
    
    This also prevents the serial driver from claiming IRDA devices (unless they
    have a UART PNP ID).  The serial legacy probe sometimes assumed the wrong IRQ,
    so the user had to use "setserial" to fix it.
    
    Removing the need for setserial to make IRDA devices work seems good, but it
    does break some things.  In particular, you may need to keep setserial from
    poking legacy UART stuff back in by doing something like "dpkg-reconfigure
    setserial" with the "kernel" option.  Otherwise, the setserial-discovered
    "UART" will claim resources and prevent the IRDA driver from loading.
    
    This patch:
    
    If we can discover devices using PNP, we can skip some legacy probes.  This
    flag ("pnp_platform_devices") indicates that PNPBIOS or PNPACPI is enabled and
    should tell us about builtin devices.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Cc: Keith Owens <kaos@ocs.com.au>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Adam Belay <ambx1@neo.rr.com>
    Cc: Matthieu CASTET <castet.matthieu@free.fr>
    Cc: Jean Tourrilhes <jt@hpl.hp.com>
    Cc: Matthew Garrett <mjg59@srcf.ucam.org>
    Cc: Ville Syrjala <syrjala@sci.fi>
    Cc: Russell King <rmk+serial@arm.linux.org.uk>
    Cc: Samuel Ortiz <samuel@sortiz.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pnp/pnpbios/core.c b/drivers/pnp/pnpbios/core.c
index b71aff21b3fc..3a201b77b963 100644
--- a/drivers/pnp/pnpbios/core.c
+++ b/drivers/pnp/pnpbios/core.c
@@ -570,6 +570,7 @@ static int __init pnpbios_init(void)
 	/* scan for pnpbios devices */
 	build_devlist();
 
+	pnp_platform_devices = 1;
 	return 0;
 }
 

commit db9c02fa8bd50eb104781a9f78cae923d8da1e74
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Tue May 8 00:30:17 2007 -0700

    pnpbios: convert to use the kthread API
    
    This patches modifies the pnpbios kernel thread to start with ktrhead_run
    not kernel_thread and deamonize.  Doing this makes the code a little
    simpler and easier to maintain.
    
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>
    Cc: Adam Belay <ambx1@neo.rr.com>
    Cc: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pnp/pnpbios/core.c b/drivers/pnp/pnpbios/core.c
index 95738dbd5d45..b71aff21b3fc 100644
--- a/drivers/pnp/pnpbios/core.c
+++ b/drivers/pnp/pnpbios/core.c
@@ -62,6 +62,7 @@
 #include <linux/delay.h>
 #include <linux/acpi.h>
 #include <linux/freezer.h>
+#include <linux/kthread.h>
 
 #include <asm/page.h>
 #include <asm/desc.h>
@@ -159,9 +160,7 @@ static int pnp_dock_thread(void * unused)
 {
 	static struct pnp_docking_station_info now;
 	int docked = -1, d = 0;
-	daemonize("kpnpbiosd");
-	allow_signal(SIGKILL);
-	while(!unloading && !signal_pending(current))
+	while (!unloading)
 	{
 		int status;
 		
@@ -170,11 +169,8 @@ static int pnp_dock_thread(void * unused)
 		 */
 		msleep_interruptible(2000);
 
-		if(signal_pending(current)) {
-			if (try_to_freeze())
-				continue;
-			break;
-		}
+		if (try_to_freeze())
+			continue;
 
 		status = pnp_bios_dock_station_info(&now);
 
@@ -581,6 +577,7 @@ subsys_initcall(pnpbios_init);
 
 static int __init pnpbios_thread_init(void)
 {
+	struct task_struct *task;
 #if defined(CONFIG_PPC_MERGE)
 	if (check_legacy_ioport(PNPBIOS_BASE))
 		return 0;
@@ -589,7 +586,8 @@ static int __init pnpbios_thread_init(void)
 		return 0;
 #ifdef CONFIG_HOTPLUG
 	init_completion(&unload_sem);
-	if (kernel_thread(pnp_dock_thread, NULL, CLONE_KERNEL) > 0)
+	task = kthread_run(pnp_dock_thread, NULL, "kpnpbiosd");
+	if (!IS_ERR(task))
 		unloading = 0;
 #endif
 	return 0;

commit 5cbded585d129d0226cb48ac4202b253c781be26
Author: Robert P. J. Day <rpjday@mindspring.com>
Date:   Wed Dec 13 00:35:56 2006 -0800

    [PATCH] getting rid of all casts of k[cmz]alloc() calls
    
    Run this:
    
            #!/bin/sh
            for f in $(grep -Erl "\([^\)]*\) *k[cmz]alloc" *) ; do
              echo "De-casting $f..."
              perl -pi -e "s/ ?= ?\([^\)]*\) *(k[cmz]alloc) *\(/ = \1\(/" $f
            done
    
    And then go through and reinstate those cases where code is casting pointers
    to non-pointers.
    
    And then drop a few hunks which conflicted with outstanding work.
    
    Cc: Russell King <rmk@arm.linux.org.uk>, Ian Molton <spyro@f2s.com>
    Cc: Mikael Starvik <starvik@axis.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Kyle McMartin <kyle@mcmartin.ca>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Jeff Dike <jdike@addtoit.com>
    Cc: Greg KH <greg@kroah.com>
    Cc: Jens Axboe <jens.axboe@oracle.com>
    Cc: Paul Fulghum <paulkf@microgate.com>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Cc: Karsten Keil <kkeil@suse.de>
    Cc: Mauro Carvalho Chehab <mchehab@infradead.org>
    Cc: Jeff Garzik <jeff@garzik.org>
    Cc: James Bottomley <James.Bottomley@steeleye.com>
    Cc: Ian Kent <raven@themaw.net>
    Cc: Steven French <sfrench@us.ibm.com>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: Neil Brown <neilb@cse.unsw.edu.au>
    Cc: Jaroslav Kysela <perex@suse.cz>
    Cc: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/pnp/pnpbios/core.c b/drivers/pnp/pnpbios/core.c
index b7fdb4d21a96..95738dbd5d45 100644
--- a/drivers/pnp/pnpbios/core.c
+++ b/drivers/pnp/pnpbios/core.c
@@ -109,7 +109,7 @@ static int pnp_dock_event(int dock, struct pnp_docking_station_info *info)
 	if (!current->fs->root) {
 		return -EAGAIN;
 	}
-	if (!(envp = (char **) kcalloc (20, sizeof (char *), GFP_KERNEL))) {
+	if (!(envp = kcalloc(20, sizeof (char *), GFP_KERNEL))) {
 		return -ENOMEM;
 	}
 	if (!(buf = kzalloc(256, GFP_KERNEL))) {

commit cd86128088554d64fea1679191509f00e6353c5b
Author: Robert P. J. Day <rpjday@mindspring.com>
Date:   Wed Dec 13 00:34:52 2006 -0800

    [PATCH] Fix numerous kcalloc() calls, convert to kzalloc()
    
    All kcalloc() calls of the form "kcalloc(1,...)" are converted to the
    equivalent kzalloc() calls, and a few kcalloc() calls with the incorrect
    ordering of the first two arguments are fixed.
    
    Signed-off-by: Robert P. J. Day <rpjday@mindspring.com>
    Cc: Jeff Garzik <jeff@garzik.org>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Cc: Dominik Brodowski <linux@dominikbrodowski.net>
    Cc: Adam Belay <ambx1@neo.rr.com>
    Cc: James Bottomley <James.Bottomley@steeleye.com>
    Cc: Greg KH <greg@kroah.com>
    Cc: Mark Fasheh <mark.fasheh@oracle.com>
    Cc: Trond Myklebust <trond.myklebust@fys.uio.no>
    Cc: Neil Brown <neilb@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/pnp/pnpbios/core.c b/drivers/pnp/pnpbios/core.c
index 33adeba1a31f..b7fdb4d21a96 100644
--- a/drivers/pnp/pnpbios/core.c
+++ b/drivers/pnp/pnpbios/core.c
@@ -112,7 +112,7 @@ static int pnp_dock_event(int dock, struct pnp_docking_station_info *info)
 	if (!(envp = (char **) kcalloc (20, sizeof (char *), GFP_KERNEL))) {
 		return -ENOMEM;
 	}
-	if (!(buf = kcalloc (1, 256, GFP_KERNEL))) {
+	if (!(buf = kzalloc(256, GFP_KERNEL))) {
 		kfree (envp);
 		return -ENOMEM;
 	}
@@ -220,7 +220,7 @@ static int pnpbios_get_resources(struct pnp_dev * dev, struct pnp_resource_table
 	if(!pnpbios_is_dynamic(dev))
 		return -EPERM;
 
-	node = kcalloc(1, node_info.max_node_size, GFP_KERNEL);
+	node = kzalloc(node_info.max_node_size, GFP_KERNEL);
 	if (!node)
 		return -1;
 	if (pnp_bios_get_dev_node(&nodenum, (char )PNPMODE_DYNAMIC, node)) {
@@ -243,7 +243,7 @@ static int pnpbios_set_resources(struct pnp_dev * dev, struct pnp_resource_table
 	if (!pnpbios_is_dynamic(dev))
 		return -EPERM;
 
-	node = kcalloc(1, node_info.max_node_size, GFP_KERNEL);
+	node = kzalloc(node_info.max_node_size, GFP_KERNEL);
 	if (!node)
 		return -1;
 	if (pnp_bios_get_dev_node(&nodenum, (char )PNPMODE_DYNAMIC, node)) {
@@ -294,7 +294,7 @@ static int pnpbios_disable_resources(struct pnp_dev *dev)
 	if(dev->flags & PNPBIOS_NO_DISABLE || !pnpbios_is_dynamic(dev))
 		return -EPERM;
 
-	node = kcalloc(1, node_info.max_node_size, GFP_KERNEL);
+	node = kzalloc(node_info.max_node_size, GFP_KERNEL);
 	if (!node)
 		return -ENOMEM;
 
@@ -336,7 +336,7 @@ static int insert_device(struct pnp_dev *dev, struct pnp_bios_node * node)
 	}
 
 	/* set the initial values for the PnP device */
-	dev_id = kcalloc(1, sizeof(struct pnp_id), GFP_KERNEL);
+	dev_id = kzalloc(sizeof(struct pnp_id), GFP_KERNEL);
 	if (!dev_id)
 		return -1;
 	pnpid32_to_pnpid(node->eisa_id,id);
@@ -374,7 +374,7 @@ static void __init build_devlist(void)
 	struct pnp_bios_node *node;
 	struct pnp_dev *dev;
 
-	node = kcalloc(1, node_info.max_node_size, GFP_KERNEL);
+	node = kzalloc(node_info.max_node_size, GFP_KERNEL);
 	if (!node)
 		return;
 
@@ -391,7 +391,7 @@ static void __init build_devlist(void)
 				break;
 		}
 		nodes_got++;
-		dev =  kcalloc(1, sizeof (struct pnp_dev), GFP_KERNEL);
+		dev =  kzalloc(sizeof (struct pnp_dev), GFP_KERNEL);
 		if (!dev)
 			break;
 		if(insert_device(dev,node)<0)

commit 4522d58275f124105819723e24e912c8e5bf3cdd
Merge: 6cf24f031bc9 64a26a731235
Author: Linus Torvalds <torvalds@woody.osdl.org>
Date:   Thu Dec 7 08:59:11 2006 -0800

    Merge branch 'for-linus' of git://one.firstfloor.org/home/andi/git/linux-2.6
    
    * 'for-linus' of git://one.firstfloor.org/home/andi/git/linux-2.6: (156 commits)
      [PATCH] x86-64: Export smp_call_function_single
      [PATCH] i386: Clean up smp_tune_scheduling()
      [PATCH] unwinder: move .eh_frame to RODATA
      [PATCH] unwinder: fully support linker generated .eh_frame_hdr section
      [PATCH] x86-64: don't use set_irq_regs()
      [PATCH] x86-64: check vector in setup_ioapic_dest to verify if need setup_IO_APIC_irq
      [PATCH] x86-64: Make ix86 default to HIGHMEM4G instead of NOHIGHMEM
      [PATCH] i386: replace kmalloc+memset with kzalloc
      [PATCH] x86-64: remove remaining pc98 code
      [PATCH] x86-64: remove unused variable
      [PATCH] x86-64: Fix constraints in atomic_add_return()
      [PATCH] x86-64: fix asm constraints in i386 atomic_add_return
      [PATCH] x86-64: Correct documentation for bzImage protocol v2.05
      [PATCH] x86-64: replace kmalloc+memset with kzalloc in MTRR code
      [PATCH] x86-64: Fix numaq build error
      [PATCH] x86-64: include/asm-x86_64/cpufeature.h isn't a userspace header
      [PATCH] unwinder: Add debugging output to the Dwarf2 unwinder
      [PATCH] x86-64: Clarify error message in GART code
      [PATCH] x86-64: Fix interrupt race in idle callback (3rd try)
      [PATCH] x86-64: Remove unwind stack pointer alignment forcing again
      ...
    
    Fixed conflict in include/linux/uaccess.h manually
    
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

commit 7dfb71030f7636a0d65200158113c37764552f93
Author: Nigel Cunningham <ncunningham@linuxmail.org>
Date:   Wed Dec 6 20:34:23 2006 -0800

    [PATCH] Add include/linux/freezer.h and move definitions from sched.h
    
    Move process freezing functions from include/linux/sched.h to freezer.h, so
    that modifications to the freezer or the kernel configuration don't require
    recompiling just about everything.
    
    [akpm@osdl.org: fix ueagle driver]
    Signed-off-by: Nigel Cunningham <nigel@suspend2.net>
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Cc: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/pnp/pnpbios/core.c b/drivers/pnp/pnpbios/core.c
index 81a6c83d89a6..81186f479a3f 100644
--- a/drivers/pnp/pnpbios/core.c
+++ b/drivers/pnp/pnpbios/core.c
@@ -61,6 +61,7 @@
 #include <linux/dmi.h>
 #include <linux/delay.h>
 #include <linux/acpi.h>
+#include <linux/freezer.h>
 
 #include <asm/page.h>
 #include <asm/desc.h>

commit 6020c8f315709a508b027ef6749e85b125190947
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Thu Dec 7 02:14:08 2006 +0100

    [PATCH] paravirt: Allow disable power management under hypervisor
    
    Two legacy power management modes are much easier to just explicitly disable
    when running in paravirtualized mode - neither APM nor PnP is still relevant.
    The status of ACPI is still debatable, and noacpi is still a common enough
    boot parameter that it is not necessary to explicitly disable ACPI.
    
    Signed-off-by: Zachary Amsden <zach@vmware.com>
    Signed-off-by: Chris Wright <chrisw@sous-sol.org>
    Signed-off-by: Andi Kleen <ak@suse.de>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Cc: Jeremy Fitzhardinge <jeremy@goop.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>

diff --git a/drivers/pnp/pnpbios/core.c b/drivers/pnp/pnpbios/core.c
index 81a6c83d89a6..80066ad792f7 100644
--- a/drivers/pnp/pnpbios/core.c
+++ b/drivers/pnp/pnpbios/core.c
@@ -530,7 +530,8 @@ static int __init pnpbios_init(void)
 	if (check_legacy_ioport(PNPBIOS_BASE))
 		return -ENODEV;
 #endif
-	if (pnpbios_disabled || dmi_check_system(pnpbios_dmi_table)) {
+	if (pnpbios_disabled || dmi_check_system(pnpbios_dmi_table) ||
+	    paravirt_enabled()) {
 		printk(KERN_INFO "PnPBIOS: Disabled\n");
 		return -ENODEV;
 	}

commit 30cbc22217bb3d5d4c74c88127fbf595460bdb76
Author: Olaf Hering <olaf@aepfle.de>
Date:   Sat Sep 30 23:27:57 2006 -0700

    [PATCH] update legacy io handling for pmac
    
    ppc can boot one single binary on prep, chrp and pmac boards.  ppc64 can
    boot one single binary on pseries and G5 boards.  pmac has no legacy io,
    probing for PC style legacy hardware (or accessing the legacy io area
    regulary) may lead to a hard crash:
    
    * add check for parport_pc, exit on pmac.  32bit chrp has no
      ->check_legacy_ioport, the probe is always called.  64bit chrp has
      check_legacy_ioport, check for a "parallel" node
    
    * add check for isapnp, only PReP boards may have real ISA slots.  32bit
      PReP will have no ->check_legacy_ioport, the probe is always called.
    
    * update code in i8042_platform_init.  Run ->check_legacy_ioport first,
      always call request_region.  No functional change.  Remove whitespace
      before i8042_reset init.
    
    Signed-off-by: Olaf Hering <olaf@aepfle.de>
    Acked-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Adam Belay <ambx1@neo.rr.com>
    Cc: Dmitry Torokhov <dtor@mail.ru>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/pnp/pnpbios/core.c b/drivers/pnp/pnpbios/core.c
index 551f58e29810..81a6c83d89a6 100644
--- a/drivers/pnp/pnpbios/core.c
+++ b/drivers/pnp/pnpbios/core.c
@@ -526,6 +526,10 @@ static int __init pnpbios_init(void)
 {
 	int ret;
 
+#if defined(CONFIG_PPC_MERGE)
+	if (check_legacy_ioport(PNPBIOS_BASE))
+		return -ENODEV;
+#endif
 	if (pnpbios_disabled || dmi_check_system(pnpbios_dmi_table)) {
 		printk(KERN_INFO "PnPBIOS: Disabled\n");
 		return -ENODEV;
@@ -575,6 +579,10 @@ subsys_initcall(pnpbios_init);
 
 static int __init pnpbios_thread_init(void)
 {
+#if defined(CONFIG_PPC_MERGE)
+	if (check_legacy_ioport(PNPBIOS_BASE))
+		return 0;
+#endif
 	if (pnpbios_disabled)
 		return 0;
 #ifdef CONFIG_HOTPLUG

commit 3ae192080cb4d007792d13522efa98ebe7f15475
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Sun Jul 30 03:03:55 2006 -0700

    [PATCH] Fix swsusp with PNP BIOS
    
    swsusp is unable to suspend my machine (DTK FortisPro TOP-5A notebook) with
    kernel 2.6.17.5 because it's unable to suspend PNP device 00:16 (mouse).
    
    The problem is in PNP BIOS.  pnp_bus_suspend() calls pnp_stop_dev() for the
    device if the device can be disabled according to pnp_can_disable().  The
    problem is that pnpbios_disable_resources() returns -EPERM if the device is
    not dynamic (!pnpbios_is_dynamic()) but insert_device() happily sets
    PNP_DISABLE capability/flag even if the device is not dynamic.  So we try
    to disable non-dynamic devices which will fail.  This patch prevents
    insert_device() from setting PNP_DISABLE if the device is not dynamic and
    fixes suspend on my system.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Cc: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/pnp/pnpbios/core.c b/drivers/pnp/pnpbios/core.c
index b154b3f52cbe..551f58e29810 100644
--- a/drivers/pnp/pnpbios/core.c
+++ b/drivers/pnp/pnpbios/core.c
@@ -346,7 +346,7 @@ static int insert_device(struct pnp_dev *dev, struct pnp_bios_node * node)
 	dev->flags = node->flags;
 	if (!(dev->flags & PNPBIOS_NO_CONFIG))
 		dev->capabilities |= PNP_CONFIGURABLE;
-	if (!(dev->flags & PNPBIOS_NO_DISABLE))
+	if (!(dev->flags & PNPBIOS_NO_DISABLE) && pnpbios_is_dynamic(dev))
 		dev->capabilities |= PNP_DISABLE;
 	dev->capabilities |= PNP_READ;
 	if (pnpbios_is_dynamic(dev))

commit 034382117725f6b6b26fbb138498139c5c012c1b
Author: Kay Sievers <kay.sievers@suse.de>
Date:   Fri Nov 11 04:25:06 2005 +0100

    [PATCH] keep pnpbios usermod_helper away from hotplug_path[]
    
    These days we use udev to manage all kernel events. /proc/sys/kernel/hotplug
    will usually be disabled by an init-script. pnpnbios is not integrated with
    the driver core and should stay away from the now disabled /sbin/hotplug.
    
    Set the helper to /sbin/phpbios, even when there is probably no current
    user of this faciliy. If it's needed, it should definitely get proper driver
    core integration instead of forking binaries from the kernel.
    
    Signed-off-by: Kay Sievers <kay.sievers@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pnp/pnpbios/core.c b/drivers/pnp/pnpbios/core.c
index f49674f07949..b154b3f52cbe 100644
--- a/drivers/pnp/pnpbios/core.c
+++ b/drivers/pnp/pnpbios/core.c
@@ -56,7 +56,6 @@
 #include <linux/mm.h>
 #include <linux/smp.h>
 #include <linux/slab.h>
-#include <linux/kobject_uevent.h>
 #include <linux/completion.h>
 #include <linux/spinlock.h>
 #include <linux/dmi.h>
@@ -106,8 +105,6 @@ static int pnp_dock_event(int dock, struct pnp_docking_station_info *info)
 	char *argv [3], **envp, *buf, *scratch;
 	int i = 0, value;
 
-	if (!hotplug_path [0])
-		return -ENOENT;
 	if (!current->fs->root) {
 		return -EAGAIN;
 	}
@@ -119,8 +116,9 @@ static int pnp_dock_event(int dock, struct pnp_docking_station_info *info)
 		return -ENOMEM;
 	}
 
-	/* only one standardized param to hotplug command: type */
-	argv [0] = hotplug_path;
+	/* FIXME: if there are actual users of this, it should be integrated into
+	 * the driver core and use the usual infrastructure like sysfs and uevents */
+	argv [0] = "/sbin/pnpbios";
 	argv [1] = "dock";
 	argv [2] = NULL;
 

commit a2822e7f00cdccbff8e507b5ebbddce1aa95eb5d
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Sep 6 15:16:51 2005 -0700

    [PATCH] pnp: consolidate kmalloc wrappers
    
    ISAPNP, PNPBIOS, and PNPACPI all had their own kmalloc wrappers that
    reimplemented kcalloc().  Remove the wrappers and just use kcalloc()
    directly.
    
    Note that this also removes the PNPBIOS error message when the kmalloc
    fails.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/pnp/pnpbios/core.c b/drivers/pnp/pnpbios/core.c
index 778a324028f4..f49674f07949 100644
--- a/drivers/pnp/pnpbios/core.c
+++ b/drivers/pnp/pnpbios/core.c
@@ -86,16 +86,6 @@ int pnp_bios_present(void)
 
 struct pnp_dev_node_info node_info;
 
-void *pnpbios_kmalloc(size_t size, int f)
-{
-	void *p = kmalloc( size, f );
-	if ( p == NULL )
-		printk(KERN_ERR "PnPBIOS: kmalloc() failed\n");
-	else
-		memset(p, 0, size);
-	return p;
-}
-
 /*
  *
  * DOCKING FUNCTIONS
@@ -121,10 +111,10 @@ static int pnp_dock_event(int dock, struct pnp_docking_station_info *info)
 	if (!current->fs->root) {
 		return -EAGAIN;
 	}
-	if (!(envp = (char **) pnpbios_kmalloc (20 * sizeof (char *), GFP_KERNEL))) {
+	if (!(envp = (char **) kcalloc (20, sizeof (char *), GFP_KERNEL))) {
 		return -ENOMEM;
 	}
-	if (!(buf = pnpbios_kmalloc (256, GFP_KERNEL))) {
+	if (!(buf = kcalloc (1, 256, GFP_KERNEL))) {
 		kfree (envp);
 		return -ENOMEM;
 	}
@@ -231,7 +221,7 @@ static int pnpbios_get_resources(struct pnp_dev * dev, struct pnp_resource_table
 	if(!pnpbios_is_dynamic(dev))
 		return -EPERM;
 
-	node = pnpbios_kmalloc(node_info.max_node_size, GFP_KERNEL);
+	node = kcalloc(1, node_info.max_node_size, GFP_KERNEL);
 	if (!node)
 		return -1;
 	if (pnp_bios_get_dev_node(&nodenum, (char )PNPMODE_DYNAMIC, node)) {
@@ -254,7 +244,7 @@ static int pnpbios_set_resources(struct pnp_dev * dev, struct pnp_resource_table
 	if (!pnpbios_is_dynamic(dev))
 		return -EPERM;
 
-	node = pnpbios_kmalloc(node_info.max_node_size, GFP_KERNEL);
+	node = kcalloc(1, node_info.max_node_size, GFP_KERNEL);
 	if (!node)
 		return -1;
 	if (pnp_bios_get_dev_node(&nodenum, (char )PNPMODE_DYNAMIC, node)) {
@@ -305,7 +295,7 @@ static int pnpbios_disable_resources(struct pnp_dev *dev)
 	if(dev->flags & PNPBIOS_NO_DISABLE || !pnpbios_is_dynamic(dev))
 		return -EPERM;
 
-	node = pnpbios_kmalloc(node_info.max_node_size, GFP_KERNEL);
+	node = kcalloc(1, node_info.max_node_size, GFP_KERNEL);
 	if (!node)
 		return -ENOMEM;
 
@@ -347,7 +337,7 @@ static int insert_device(struct pnp_dev *dev, struct pnp_bios_node * node)
 	}
 
 	/* set the initial values for the PnP device */
-	dev_id = pnpbios_kmalloc(sizeof(struct pnp_id), GFP_KERNEL);
+	dev_id = kcalloc(1, sizeof(struct pnp_id), GFP_KERNEL);
 	if (!dev_id)
 		return -1;
 	pnpid32_to_pnpid(node->eisa_id,id);
@@ -385,7 +375,7 @@ static void __init build_devlist(void)
 	struct pnp_bios_node *node;
 	struct pnp_dev *dev;
 
-	node = pnpbios_kmalloc(node_info.max_node_size, GFP_KERNEL);
+	node = kcalloc(1, node_info.max_node_size, GFP_KERNEL);
 	if (!node)
 		return;
 
@@ -402,7 +392,7 @@ static void __init build_devlist(void)
 				break;
 		}
 		nodes_got++;
-		dev =  pnpbios_kmalloc(sizeof (struct pnp_dev), GFP_KERNEL);
+		dev =  kcalloc(1, sizeof (struct pnp_dev), GFP_KERNEL);
 		if (!dev)
 			break;
 		if(insert_device(dev,node)<0)

commit 3e1d1d28d99dabe63c64f7f40f1ca1d646de1f73
Author: Christoph Lameter <christoph@lameter.com>
Date:   Fri Jun 24 23:13:50 2005 -0700

    [PATCH] Cleanup patch for process freezing
    
    1. Establish a simple API for process freezing defined in linux/include/sched.h:
    
       frozen(process)              Check for frozen process
       freezing(process)            Check if a process is being frozen
       freeze(process)              Tell a process to freeze (go to refrigerator)
       thaw_process(process)        Restart process
       frozen_process(process)      Process is frozen now
    
    2. Remove all references to PF_FREEZE and PF_FROZEN from all
       kernel sources except sched.h
    
    3. Fix numerous locations where try_to_freeze is manually done by a driver
    
    4. Remove the argument that is no longer necessary from two function calls.
    
    5. Some whitespace cleanup
    
    6. Clear potential race in refrigerator (provides an open window of PF_FREEZE
       cleared before setting PF_FROZEN, recalc_sigpending does not check
       PF_FROZEN).
    
    This patch does not address the problem of freeze_processes() violating the rule
    that a task may only modify its own flags by setting PF_FREEZE. This is not clean
    in an SMP environment. freeze(process) is therefore not SMP safe!
    
    Signed-off-by: Christoph Lameter <christoph@lameter.com>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/pnp/pnpbios/core.c b/drivers/pnp/pnpbios/core.c
index e939c93a931c..778a324028f4 100644
--- a/drivers/pnp/pnpbios/core.c
+++ b/drivers/pnp/pnpbios/core.c
@@ -182,7 +182,7 @@ static int pnp_dock_thread(void * unused)
 		msleep_interruptible(2000);
 
 		if(signal_pending(current)) {
-			if (try_to_freeze(PF_FREEZE))
+			if (try_to_freeze())
 				continue;
 			break;
 		}

commit ffbe5523a8e7f808681007aaea282da9a316a699
Author: maximilian attems <janitor@sternwelten.at>
Date:   Sat Apr 16 15:25:51 2005 -0700

    [PATCH] pnpbios: eliminate bad section references
    
    one of the last buildcheck errors on i386, thanks Randy again for double
    checking.
    
    Fix pnpbios section references:
    make dmi_system_id pnpbios_dmi_table __initdata
    
    Error: ./drivers/pnp/pnpbios/core.o .data refers to 00000100 R_386_32
    .init.text
    Error: ./drivers/pnp/pnpbios/core.o .data refers to 0000012c R_386_32
    .init.text
    
    Signed-off-by: maximilian attems <janitor@sternwelten.at>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/pnp/pnpbios/core.c b/drivers/pnp/pnpbios/core.c
index 0f6330b3af12..e939c93a931c 100644
--- a/drivers/pnp/pnpbios/core.c
+++ b/drivers/pnp/pnpbios/core.c
@@ -512,7 +512,7 @@ static int __init exploding_pnp_bios(struct dmi_system_id *d)
 	return 0;
 }
 
-static struct dmi_system_id pnpbios_dmi_table[] = {
+static struct dmi_system_id pnpbios_dmi_table[] __initdata = {
 	{	/* PnPBIOS GPF on boot */
 		.callback = exploding_pnp_bios,
 		.ident = "Higraded P14H",

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/pnp/pnpbios/core.c b/drivers/pnp/pnpbios/core.c
new file mode 100644
index 000000000000..0f6330b3af12
--- /dev/null
+++ b/drivers/pnp/pnpbios/core.c
@@ -0,0 +1,644 @@
+/*
+ * pnpbios -- PnP BIOS driver
+ *
+ * This driver provides access to Plug-'n'-Play services provided by
+ * the PnP BIOS firmware, described in the following documents:
+ *   Plug and Play BIOS Specification, Version 1.0A, 5 May 1994
+ *   Plug and Play BIOS Clarification Paper, 6 October 1994
+ *     Compaq Computer Corporation, Phoenix Technologies Ltd., Intel Corp.
+ * 
+ * Originally (C) 1998 Christian Schmidt <schmidt@digadd.de>
+ * Modifications (C) 1998 Tom Lees <tom@lpsg.demon.co.uk>
+ * Minor reorganizations by David Hinds <dahinds@users.sourceforge.net>
+ * Further modifications (C) 2001, 2002 by:
+ *   Alan Cox <alan@redhat.com>
+ *   Thomas Hood
+ *   Brian Gerst <bgerst@didntduck.org>
+ *
+ * Ported to the PnP Layer and several additional improvements (C) 2002
+ * by Adam Belay <ambx1@neo.rr.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+ 
+/* Change Log
+ *
+ * Adam Belay - <ambx1@neo.rr.com> - March 16, 2003
+ * rev 1.01	Only call pnp_bios_dev_node_info once
+ *		Added pnpbios_print_status
+ *		Added several new error messages and info messages
+ *		Added pnpbios_interface_attach_device
+ *		integrated core and proc init system
+ *		Introduced PNPMODE flags
+ *		Removed some useless includes
+ */
+
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/linkage.h>
+#include <linux/kernel.h>
+#include <linux/pnpbios.h>
+#include <linux/device.h>
+#include <linux/pnp.h>
+#include <linux/mm.h>
+#include <linux/smp.h>
+#include <linux/slab.h>
+#include <linux/kobject_uevent.h>
+#include <linux/completion.h>
+#include <linux/spinlock.h>
+#include <linux/dmi.h>
+#include <linux/delay.h>
+#include <linux/acpi.h>
+
+#include <asm/page.h>
+#include <asm/desc.h>
+#include <asm/system.h>
+#include <asm/byteorder.h>
+
+#include "pnpbios.h"
+
+
+/*
+ *
+ * PnP BIOS INTERFACE
+ *
+ */
+
+static union pnp_bios_install_struct * pnp_bios_install = NULL;
+
+int pnp_bios_present(void)
+{
+	return (pnp_bios_install != NULL);
+}
+
+struct pnp_dev_node_info node_info;
+
+void *pnpbios_kmalloc(size_t size, int f)
+{
+	void *p = kmalloc( size, f );
+	if ( p == NULL )
+		printk(KERN_ERR "PnPBIOS: kmalloc() failed\n");
+	else
+		memset(p, 0, size);
+	return p;
+}
+
+/*
+ *
+ * DOCKING FUNCTIONS
+ *
+ */
+
+#ifdef CONFIG_HOTPLUG
+
+static int unloading = 0;
+static struct completion unload_sem;
+
+/*
+ * (Much of this belongs in a shared routine somewhere)
+ */
+ 
+static int pnp_dock_event(int dock, struct pnp_docking_station_info *info)
+{
+	char *argv [3], **envp, *buf, *scratch;
+	int i = 0, value;
+
+	if (!hotplug_path [0])
+		return -ENOENT;
+	if (!current->fs->root) {
+		return -EAGAIN;
+	}
+	if (!(envp = (char **) pnpbios_kmalloc (20 * sizeof (char *), GFP_KERNEL))) {
+		return -ENOMEM;
+	}
+	if (!(buf = pnpbios_kmalloc (256, GFP_KERNEL))) {
+		kfree (envp);
+		return -ENOMEM;
+	}
+
+	/* only one standardized param to hotplug command: type */
+	argv [0] = hotplug_path;
+	argv [1] = "dock";
+	argv [2] = NULL;
+
+	/* minimal command environment */
+	envp [i++] = "HOME=/";
+	envp [i++] = "PATH=/sbin:/bin:/usr/sbin:/usr/bin";
+
+#ifdef	DEBUG
+	/* hint that policy agent should enter no-stdout debug mode */
+	envp [i++] = "DEBUG=kernel";
+#endif
+	/* extensible set of named bus-specific parameters,
+	 * supporting multiple driver selection algorithms.
+	 */
+	scratch = buf;
+
+	/* action:  add, remove */
+	envp [i++] = scratch;
+	scratch += sprintf (scratch, "ACTION=%s", dock?"add":"remove") + 1;
+
+	/* Report the ident for the dock */
+	envp [i++] = scratch;
+	scratch += sprintf (scratch, "DOCK=%x/%x/%x",
+		info->location_id, info->serial, info->capabilities);
+	envp[i] = NULL;
+	
+	value = call_usermodehelper (argv [0], argv, envp, 0);
+	kfree (buf);
+	kfree (envp);
+	return 0;
+}
+
+/*
+ * Poll the PnP docking at regular intervals
+ */
+static int pnp_dock_thread(void * unused)
+{
+	static struct pnp_docking_station_info now;
+	int docked = -1, d = 0;
+	daemonize("kpnpbiosd");
+	allow_signal(SIGKILL);
+	while(!unloading && !signal_pending(current))
+	{
+		int status;
+		
+		/*
+		 * Poll every 2 seconds
+		 */
+		msleep_interruptible(2000);
+
+		if(signal_pending(current)) {
+			if (try_to_freeze(PF_FREEZE))
+				continue;
+			break;
+		}
+
+		status = pnp_bios_dock_station_info(&now);
+
+		switch(status)
+		{
+			/*
+			 * No dock to manage
+			 */
+			case PNP_FUNCTION_NOT_SUPPORTED:
+				complete_and_exit(&unload_sem, 0);
+			case PNP_SYSTEM_NOT_DOCKED:
+				d = 0;
+				break;
+			case PNP_SUCCESS:
+				d = 1;
+				break;
+			default:
+				pnpbios_print_status( "pnp_dock_thread", status );
+				continue;
+		}
+		if(d != docked)
+		{
+			if(pnp_dock_event(d, &now)==0)
+			{
+				docked = d;
+#if 0
+				printk(KERN_INFO "PnPBIOS: Docking station %stached\n", docked?"at":"de");
+#endif
+			}
+		}
+	}
+	complete_and_exit(&unload_sem, 0);
+}
+
+#endif   /* CONFIG_HOTPLUG */
+
+static int pnpbios_get_resources(struct pnp_dev * dev, struct pnp_resource_table * res)
+{
+	u8 nodenum = dev->number;
+	struct pnp_bios_node * node;
+
+	/* just in case */
+	if(!pnpbios_is_dynamic(dev))
+		return -EPERM;
+
+	node = pnpbios_kmalloc(node_info.max_node_size, GFP_KERNEL);
+	if (!node)
+		return -1;
+	if (pnp_bios_get_dev_node(&nodenum, (char )PNPMODE_DYNAMIC, node)) {
+		kfree(node);
+		return -ENODEV;
+	}
+	pnpbios_read_resources_from_node(res, node);
+	dev->active = pnp_is_active(dev);
+	kfree(node);
+	return 0;
+}
+
+static int pnpbios_set_resources(struct pnp_dev * dev, struct pnp_resource_table * res)
+{
+	u8 nodenum = dev->number;
+	struct pnp_bios_node * node;
+	int ret;
+
+	/* just in case */
+	if (!pnpbios_is_dynamic(dev))
+		return -EPERM;
+
+	node = pnpbios_kmalloc(node_info.max_node_size, GFP_KERNEL);
+	if (!node)
+		return -1;
+	if (pnp_bios_get_dev_node(&nodenum, (char )PNPMODE_DYNAMIC, node)) {
+		kfree(node);
+		return -ENODEV;
+	}
+	if(pnpbios_write_resources_to_node(res, node)<0) {
+		kfree(node);
+		return -1;
+	}
+	ret = pnp_bios_set_dev_node(node->handle, (char)PNPMODE_DYNAMIC, node);
+	kfree(node);
+	if (ret > 0)
+		ret = -1;
+	return ret;
+}
+
+static void pnpbios_zero_data_stream(struct pnp_bios_node * node)
+{
+	unsigned char * p = (char *)node->data;
+	unsigned char * end = (char *)(node->data + node->size);
+	unsigned int len;
+	int i;
+	while ((char *)p < (char *)end) {
+		if(p[0] & 0x80) { /* large tag */
+			len = (p[2] << 8) | p[1];
+			p += 3;
+		} else {
+			if (((p[0]>>3) & 0x0f) == 0x0f)
+				return;
+			len = p[0] & 0x07;
+			p += 1;
+		}
+		for (i = 0; i < len; i++)
+			p[i] = 0;
+		p += len;
+	}
+	printk(KERN_ERR "PnPBIOS: Resource structure did not contain an end tag.\n");
+}
+
+static int pnpbios_disable_resources(struct pnp_dev *dev)
+{
+	struct pnp_bios_node * node;
+	u8 nodenum = dev->number;
+	int ret;
+
+	/* just in case */
+	if(dev->flags & PNPBIOS_NO_DISABLE || !pnpbios_is_dynamic(dev))
+		return -EPERM;
+
+	node = pnpbios_kmalloc(node_info.max_node_size, GFP_KERNEL);
+	if (!node)
+		return -ENOMEM;
+
+	if (pnp_bios_get_dev_node(&nodenum, (char )PNPMODE_DYNAMIC, node)) {
+		kfree(node);
+		return -ENODEV;
+	}
+	pnpbios_zero_data_stream(node);
+
+	ret = pnp_bios_set_dev_node(dev->number, (char)PNPMODE_DYNAMIC, node);
+	kfree(node);
+	if (ret > 0)
+		ret = -1;
+	return ret;
+}
+
+/* PnP Layer support */
+
+struct pnp_protocol pnpbios_protocol = {
+	.name	= "Plug and Play BIOS",
+	.get	= pnpbios_get_resources,
+	.set	= pnpbios_set_resources,
+	.disable = pnpbios_disable_resources,
+};
+
+static int insert_device(struct pnp_dev *dev, struct pnp_bios_node * node)
+{
+	struct list_head * pos;
+	struct pnp_dev * pnp_dev;
+	struct pnp_id *dev_id;
+	char id[8];
+
+	/* check if the device is already added */
+	dev->number = node->handle;
+	list_for_each (pos, &pnpbios_protocol.devices){
+		pnp_dev = list_entry(pos, struct pnp_dev, protocol_list);
+		if (dev->number == pnp_dev->number)
+			return -1;
+	}
+
+	/* set the initial values for the PnP device */
+	dev_id = pnpbios_kmalloc(sizeof(struct pnp_id), GFP_KERNEL);
+	if (!dev_id)
+		return -1;
+	pnpid32_to_pnpid(node->eisa_id,id);
+	memcpy(dev_id->id,id,7);
+	pnp_add_id(dev_id, dev);
+	pnpbios_parse_data_stream(dev, node);
+	dev->active = pnp_is_active(dev);
+	dev->flags = node->flags;
+	if (!(dev->flags & PNPBIOS_NO_CONFIG))
+		dev->capabilities |= PNP_CONFIGURABLE;
+	if (!(dev->flags & PNPBIOS_NO_DISABLE))
+		dev->capabilities |= PNP_DISABLE;
+	dev->capabilities |= PNP_READ;
+	if (pnpbios_is_dynamic(dev))
+		dev->capabilities |= PNP_WRITE;
+	if (dev->flags & PNPBIOS_REMOVABLE)
+		dev->capabilities |= PNP_REMOVABLE;
+	dev->protocol = &pnpbios_protocol;
+
+	/* clear out the damaged flags */
+	if (!dev->active)
+		pnp_init_resource_table(&dev->res);
+
+	pnp_add_device(dev);
+	pnpbios_interface_attach_device(node);
+
+	return 0;
+}
+
+static void __init build_devlist(void)
+{
+	u8 nodenum;
+	unsigned int nodes_got = 0;
+	unsigned int devs = 0;
+	struct pnp_bios_node *node;
+	struct pnp_dev *dev;
+
+	node = pnpbios_kmalloc(node_info.max_node_size, GFP_KERNEL);
+	if (!node)
+		return;
+
+	for(nodenum=0; nodenum<0xff; ) {
+		u8 thisnodenum = nodenum;
+		/* eventually we will want to use PNPMODE_STATIC here but for now
+		 * dynamic will help us catch buggy bioses to add to the blacklist.
+		 */
+		if (!pnpbios_dont_use_current_config) {
+			if (pnp_bios_get_dev_node(&nodenum, (char )PNPMODE_DYNAMIC, node))
+				break;
+		} else {
+			if (pnp_bios_get_dev_node(&nodenum, (char )PNPMODE_STATIC, node))
+				break;
+		}
+		nodes_got++;
+		dev =  pnpbios_kmalloc(sizeof (struct pnp_dev), GFP_KERNEL);
+		if (!dev)
+			break;
+		if(insert_device(dev,node)<0)
+			kfree(dev);
+		else
+			devs++;
+		if (nodenum <= thisnodenum) {
+			printk(KERN_ERR "PnPBIOS: build_devlist: Node number 0x%x is out of sequence following node 0x%x. Aborting.\n", (unsigned int)nodenum, (unsigned int)thisnodenum);
+			break;
+		}
+	}
+	kfree(node);
+
+	printk(KERN_INFO "PnPBIOS: %i node%s reported by PnP BIOS; %i recorded by driver\n",
+		nodes_got, nodes_got != 1 ? "s" : "", devs);
+}
+
+/*
+ *
+ * INIT AND EXIT
+ *
+ */
+
+static int pnpbios_disabled; /* = 0 */
+int pnpbios_dont_use_current_config; /* = 0 */
+
+#ifndef MODULE
+static int __init pnpbios_setup(char *str)
+{
+	int invert;
+
+	while ((str != NULL) && (*str != '\0')) {
+		if (strncmp(str, "off", 3) == 0)
+			pnpbios_disabled=1;
+		if (strncmp(str, "on", 2) == 0)
+			pnpbios_disabled=0;
+		invert = (strncmp(str, "no-", 3) == 0);
+		if (invert)
+			str += 3;
+		if (strncmp(str, "curr", 4) == 0)
+			pnpbios_dont_use_current_config = invert;
+		str = strchr(str, ',');
+		if (str != NULL)
+			str += strspn(str, ", \t");
+	}
+
+	return 1;
+}
+
+__setup("pnpbios=", pnpbios_setup);
+#endif
+
+/* PnP BIOS signature: "$PnP" */
+#define PNP_SIGNATURE   (('$' << 0) + ('P' << 8) + ('n' << 16) + ('P' << 24))
+
+static int __init pnpbios_probe_system(void)
+{
+	union pnp_bios_install_struct *check;
+	u8 sum;
+	int length, i;
+
+	printk(KERN_INFO "PnPBIOS: Scanning system for PnP BIOS support...\n");
+
+	/*
+ 	 * Search the defined area (0xf0000-0xffff0) for a valid PnP BIOS
+	 * structure and, if one is found, sets up the selectors and
+	 * entry points
+	 */
+	for (check = (union pnp_bios_install_struct *) __va(0xf0000);
+	     check < (union pnp_bios_install_struct *) __va(0xffff0);
+	     check = (void *)check + 16) {
+		if (check->fields.signature != PNP_SIGNATURE)
+			continue;
+		printk(KERN_INFO "PnPBIOS: Found PnP BIOS installation structure at 0x%p\n", check);
+		length = check->fields.length;
+		if (!length) {
+			printk(KERN_ERR "PnPBIOS: installation structure is invalid, skipping\n");
+			continue;
+		}
+		for (sum = 0, i = 0; i < length; i++)
+			sum += check->chars[i];
+		if (sum) {
+			printk(KERN_ERR "PnPBIOS: installation structure is corrupted, skipping\n");
+			continue;
+		}
+		if (check->fields.version < 0x10) {
+			printk(KERN_WARNING "PnPBIOS: PnP BIOS version %d.%d is not supported\n",
+			       check->fields.version >> 4,
+			       check->fields.version & 15);
+			continue;
+		}
+		printk(KERN_INFO "PnPBIOS: PnP BIOS version %d.%d, entry 0x%x:0x%x, dseg 0x%x\n",
+                       check->fields.version >> 4, check->fields.version & 15,
+		       check->fields.pm16cseg, check->fields.pm16offset,
+		       check->fields.pm16dseg);
+		pnp_bios_install = check;
+		return 1;
+	}
+
+	printk(KERN_INFO "PnPBIOS: PnP BIOS support was not detected.\n");
+	return 0;
+}
+
+static int __init exploding_pnp_bios(struct dmi_system_id *d)
+{
+	printk(KERN_WARNING "%s detected. Disabling PnPBIOS\n", d->ident);
+	return 0;
+}
+
+static struct dmi_system_id pnpbios_dmi_table[] = {
+	{	/* PnPBIOS GPF on boot */
+		.callback = exploding_pnp_bios,
+		.ident = "Higraded P14H",
+		.matches = {
+			DMI_MATCH(DMI_BIOS_VENDOR, "American Megatrends Inc."),
+			DMI_MATCH(DMI_BIOS_VERSION, "07.00T"),
+			DMI_MATCH(DMI_SYS_VENDOR, "Higraded"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "P14H"),
+		},
+	},
+	{	/* PnPBIOS GPF on boot */
+		.callback = exploding_pnp_bios,
+		.ident = "ASUS P4P800",
+		.matches = {
+			DMI_MATCH(DMI_BOARD_VENDOR, "ASUSTeK Computer Inc."),
+			DMI_MATCH(DMI_BOARD_NAME, "P4P800"),
+		},
+	},
+	{ }
+};
+
+static int __init pnpbios_init(void)
+{
+	int ret;
+
+	if (pnpbios_disabled || dmi_check_system(pnpbios_dmi_table)) {
+		printk(KERN_INFO "PnPBIOS: Disabled\n");
+		return -ENODEV;
+	}
+
+#ifdef CONFIG_PNPACPI
+	if (!acpi_disabled && !pnpacpi_disabled) {
+		pnpbios_disabled = 1;
+		printk(KERN_INFO "PnPBIOS: Disabled by ACPI PNP\n");
+		return -ENODEV;
+	}
+#endif /* CONFIG_ACPI */
+
+	/* scan the system for pnpbios support */
+	if (!pnpbios_probe_system())
+		return -ENODEV;
+
+	/* make preparations for bios calls */
+	pnpbios_calls_init(pnp_bios_install);
+
+	/* read the node info */
+	ret = pnp_bios_dev_node_info(&node_info);
+	if (ret) {
+		printk(KERN_ERR "PnPBIOS: Unable to get node info.  Aborting.\n");
+		return ret;
+	}
+
+	/* register with the pnp layer */
+	ret = pnp_register_protocol(&pnpbios_protocol);
+	if (ret) {
+		printk(KERN_ERR "PnPBIOS: Unable to register driver.  Aborting.\n");
+		return ret;
+	}
+
+	/* start the proc interface */
+	ret = pnpbios_proc_init();
+	if (ret)
+		printk(KERN_ERR "PnPBIOS: Failed to create proc interface.\n");
+
+	/* scan for pnpbios devices */
+	build_devlist();
+
+	return 0;
+}
+
+subsys_initcall(pnpbios_init);
+
+static int __init pnpbios_thread_init(void)
+{
+	if (pnpbios_disabled)
+		return 0;
+#ifdef CONFIG_HOTPLUG
+	init_completion(&unload_sem);
+	if (kernel_thread(pnp_dock_thread, NULL, CLONE_KERNEL) > 0)
+		unloading = 0;
+#endif
+	return 0;
+}
+
+#ifndef MODULE
+
+/* init/main.c calls pnpbios_init early */
+
+/* Start the kernel thread later: */
+module_init(pnpbios_thread_init);
+
+#else
+
+/*
+ * N.B.: Building pnpbios as a module hasn't been fully implemented
+ */
+
+MODULE_LICENSE("GPL");
+
+static int __init pnpbios_init_all(void)
+{
+	int r;
+
+	r = pnpbios_init();
+	if (r)
+		return r;
+	r = pnpbios_thread_init();
+	if (r)
+		return r;
+	return 0;
+}
+
+static void __exit pnpbios_exit(void)
+{
+#ifdef CONFIG_HOTPLUG
+	unloading = 1;
+	wait_for_completion(&unload_sem);
+#endif
+	pnpbios_proc_exit();
+	/* We ought to free resources here */
+	return;
+}
+
+module_init(pnpbios_init_all);
+module_exit(pnpbios_exit);
+
+#endif
+
+EXPORT_SYMBOL(pnpbios_protocol);
