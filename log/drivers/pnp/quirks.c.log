commit d75f773c86a2b8b7278e2c33343b46a4024bc002
Author: Sakari Ailus <sakari.ailus@linux.intel.com>
Date:   Mon Mar 25 21:32:28 2019 +0200

    treewide: Switch printk users from %pf and %pF to %ps and %pS, respectively
    
    %pF and %pf are functionally equivalent to %pS and %ps conversion
    specifiers. The former are deprecated, therefore switch the current users
    to use the preferred variant.
    
    The changes have been produced by the following command:
    
            git grep -l '%p[fF]' | grep -v '^\(tools\|Documentation\)/' | \
            while read i; do perl -i -pe 's/%pf/%ps/g; s/%pF/%pS/g;' $i; done
    
    And verifying the result.
    
    Link: http://lkml.kernel.org/r/20190325193229.23390-1-sakari.ailus@linux.intel.com
    Cc: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: sparclinux@vger.kernel.org
    Cc: linux-um@lists.infradead.org
    Cc: xen-devel@lists.xenproject.org
    Cc: linux-acpi@vger.kernel.org
    Cc: linux-pm@vger.kernel.org
    Cc: drbd-dev@lists.linbit.com
    Cc: linux-block@vger.kernel.org
    Cc: linux-mmc@vger.kernel.org
    Cc: linux-nvdimm@lists.01.org
    Cc: linux-pci@vger.kernel.org
    Cc: linux-scsi@vger.kernel.org
    Cc: linux-btrfs@vger.kernel.org
    Cc: linux-f2fs-devel@lists.sourceforge.net
    Cc: linux-mm@kvack.org
    Cc: ceph-devel@vger.kernel.org
    Cc: netdev@vger.kernel.org
    Signed-off-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Acked-by: David Sterba <dsterba@suse.com> (for btrfs)
    Acked-by: Mike Rapoport <rppt@linux.ibm.com> (for mm/memblock.c)
    Acked-by: Bjorn Helgaas <bhelgaas@google.com> (for drivers/pci)
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/drivers/pnp/quirks.c b/drivers/pnp/quirks.c
index 803666ae3635..de99f371d362 100644
--- a/drivers/pnp/quirks.c
+++ b/drivers/pnp/quirks.c
@@ -458,7 +458,7 @@ void pnp_fixup_device(struct pnp_dev *dev)
 	for (f = pnp_fixups; *f->id; f++) {
 		if (!compare_pnp_id(dev->id, f->id))
 			continue;
-		pnp_dbg(&dev->dev, "%s: calling %pF\n", f->id,
+		pnp_dbg(&dev->dev, "%s: calling %pS\n", f->id,
 			f->quirk_function);
 		f->quirk_function(dev);
 	}

commit 245fe15e4773d62fe528d5876e73c8ed31c32873
Author: Sergey Senozhatsky <sergey.senozhatsky.work@gmail.com>
Date:   Fri Dec 8 11:56:12 2017 +0900

    PNP: remove unneeded kallsyms include
    
    The file was converted from print_fn_descriptor_symbol()
    to %pF some time ago (2e532d68a2b3e2aa {pci,pnp} quirks.c:
    don't use deprecated print_fn_descriptor_symbol()). kallsyms
    does not seem to be needed anymore.
    
    Signed-off-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pnp/quirks.c b/drivers/pnp/quirks.c
index f054cdddfef8..803666ae3635 100644
--- a/drivers/pnp/quirks.c
+++ b/drivers/pnp/quirks.c
@@ -21,7 +21,6 @@
 #include <linux/slab.h>
 #include <linux/pnp.h>
 #include <linux/io.h>
-#include <linux/kallsyms.h>
 #include "base.h"
 
 static void quirk_awe32_add_ports(struct pnp_dev *dev,

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pnp/quirks.c b/drivers/pnp/quirks.c
index d28e3ab9479c..f054cdddfef8 100644
--- a/drivers/pnp/quirks.c
+++ b/drivers/pnp/quirks.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  *  This file contains quirk handling code for PnP devices
  *  Some devices do not report all their resources, and need to have extra

commit ed1f0eeebaeeb7f790e9e7642116a208581e5bfc
Author: Josh Boyer <jwboyer@fedoraproject.org>
Date:   Wed Feb 3 01:00:29 2016 +0100

    PNP: Add Haswell-ULT to Intel MCH size workaround
    
    Add device ID 0x0a04 for Haswell-ULT to the list of devices with MCH
    problems.
    
    From a Lenovo ThinkPad T440S:
    [    0.188604] pnp: PnP ACPI init
    [    0.189044] system 00:00: [mem 0x00000000-0x0009ffff] could not be reserved
    [    0.189048] system 00:00: [mem 0x000c0000-0x000c3fff] could not be reserved
    [    0.189050] system 00:00: [mem 0x000c4000-0x000c7fff] could not be reserved
    [    0.189052] system 00:00: [mem 0x000c8000-0x000cbfff] could not be reserved
    [    0.189054] system 00:00: [mem 0x000cc000-0x000cffff] could not be reserved
    [    0.189056] system 00:00: [mem 0x000d0000-0x000d3fff] has been reserved
    [    0.189058] system 00:00: [mem 0x000d4000-0x000d7fff] has been reserved
    [    0.189060] system 00:00: [mem 0x000d8000-0x000dbfff] has been reserved
    [    0.189061] system 00:00: [mem 0x000dc000-0x000dffff] has been reserved
    [    0.189063] system 00:00: [mem 0x000e0000-0x000e3fff] could not be reserved
    [    0.189065] system 00:00: [mem 0x000e4000-0x000e7fff] could not be reserved
    [    0.189067] system 00:00: [mem 0x000e8000-0x000ebfff] could not be reserved
    [    0.189069] system 00:00: [mem 0x000ec000-0x000effff] could not be reserved
    [    0.189071] system 00:00: [mem 0x000f0000-0x000fffff] could not be reserved
    [    0.189073] system 00:00: [mem 0x00100000-0xdf9fffff] could not be reserved
    [    0.189075] system 00:00: [mem 0xfec00000-0xfed3ffff] could not be reserved
    [    0.189078] system 00:00: [mem 0xfed4c000-0xffffffff] could not be reserved
    [    0.189082] system 00:00: Plug and Play ACPI device, IDs PNP0c01 (active)
    [    0.189216] system 00:01: [io  0x1800-0x189f] could not be reserved
    [    0.189220] system 00:01: [io  0x0800-0x087f] has been reserved
    [    0.189222] system 00:01: [io  0x0880-0x08ff] has been reserved
    [    0.189224] system 00:01: [io  0x0900-0x097f] has been reserved
    [    0.189226] system 00:01: [io  0x0980-0x09ff] has been reserved
    [    0.189229] system 00:01: [io  0x0a00-0x0a7f] has been reserved
    [    0.189231] system 00:01: [io  0x0a80-0x0aff] has been reserved
    [    0.189233] system 00:01: [io  0x0b00-0x0b7f] has been reserved
    [    0.189235] system 00:01: [io  0x0b80-0x0bff] has been reserved
    [    0.189238] system 00:01: [io  0x15e0-0x15ef] has been reserved
    [    0.189240] system 00:01: [io  0x1600-0x167f] has been reserved
    [    0.189242] system 00:01: [io  0x1640-0x165f] has been reserved
    [    0.189246] system 00:01: [mem 0xf8000000-0xfbffffff] could not be reserved
    [    0.189249] system 00:01: [mem 0x00000000-0x00000fff] could not be reserved
    [    0.189251] system 00:01: [mem 0xfed1c000-0xfed1ffff] has been reserved
    [    0.189254] system 00:01: [mem 0xfed10000-0xfed13fff] has been reserved
    [    0.189256] system 00:01: [mem 0xfed18000-0xfed18fff] has been reserved
    [    0.189258] system 00:01: [mem 0xfed19000-0xfed19fff] has been reserved
    [    0.189261] system 00:01: [mem 0xfed45000-0xfed4bfff] has been reserved
    [    0.189264] system 00:01: Plug and Play ACPI device, IDs PNP0c02 (active)
    [....]
    [    0.583653] resource sanity check: requesting [mem 0xfed10000-0xfed15fff], which spans more than pnp 00:01 [mem 0xfed10000-0xfed13fff]
    [    0.583654] ------------[ cut here ]------------
    [    0.583660] WARNING: CPU: 0 PID: 1 at arch/x86/mm/ioremap.c:198 __ioremap_caller+0x2c5/0x380()
    [    0.583661] Info: mapping multiple BARs. Your kernel is fine.
    [    0.583662] Modules linked in:
    
    [    0.583666] CPU: 0 PID: 1 Comm: swapper/0 Not tainted 4.3.3-303.fc23.x86_64 #1
    [    0.583668] Hardware name: LENOVO 20AR001GXS/20AR001GXS, BIOS GJET86WW (2.36 ) 12/04/2015
    [    0.583670]  0000000000000000 0000000014cf7e59 ffff880214a1baf8 ffffffff813a625f
    [    0.583673]  ffff880214a1bb40 ffff880214a1bb30 ffffffff810a07c2 00000000fed10000
    [    0.583675]  ffffc90000cb8000 0000000000006000 0000000000000000 ffff8800d6381040
    [    0.583678] Call Trace:
    [    0.583683]  [<ffffffff813a625f>] dump_stack+0x44/0x55
    [    0.583686]  [<ffffffff810a07c2>] warn_slowpath_common+0x82/0xc0
    [    0.583688]  [<ffffffff810a085c>] warn_slowpath_fmt+0x5c/0x80
    [    0.583692]  [<ffffffff810a6fba>] ? iomem_map_sanity_check+0xba/0xd0
    [    0.583695]  [<ffffffff81065835>] __ioremap_caller+0x2c5/0x380
    [    0.583698]  [<ffffffff81065907>] ioremap_nocache+0x17/0x20
    [    0.583701]  [<ffffffff8103a119>] snb_uncore_imc_init_box+0x79/0xb0
    [    0.583705]  [<ffffffff81038900>] uncore_pci_probe+0xd0/0x1b0
    [    0.583707]  [<ffffffff813efda5>] local_pci_probe+0x45/0xa0
    [    0.583710]  [<ffffffff813f118d>] pci_device_probe+0xfd/0x140
    [    0.583713]  [<ffffffff814d9b52>] driver_probe_device+0x222/0x480
    [    0.583715]  [<ffffffff814d9e34>] __driver_attach+0x84/0x90
    [    0.583717]  [<ffffffff814d9db0>] ? driver_probe_device+0x480/0x480
    [    0.583720]  [<ffffffff814d762c>] bus_for_each_dev+0x6c/0xc0
    [    0.583722]  [<ffffffff814d930e>] driver_attach+0x1e/0x20
    [    0.583724]  [<ffffffff814d8e4b>] bus_add_driver+0x1eb/0x280
    [    0.583727]  [<ffffffff81d6af1a>] ? uncore_cpu_setup+0x12/0x12
    [    0.583729]  [<ffffffff814da680>] driver_register+0x60/0xe0
    [    0.583733]  [<ffffffff813ef78c>] __pci_register_driver+0x4c/0x50
    [    0.583736]  [<ffffffff81d6affc>] intel_uncore_init+0xe2/0x2e6
    [    0.583738]  [<ffffffff81d6af1a>] ? uncore_cpu_setup+0x12/0x12
    [    0.583741]  [<ffffffff81002123>] do_one_initcall+0xb3/0x200
    [    0.583745]  [<ffffffff810be500>] ? parse_args+0x1a0/0x4a0
    [    0.583749]  [<ffffffff81d5c1c8>] kernel_init_freeable+0x189/0x223
    [    0.583752]  [<ffffffff81775c40>] ? rest_init+0x80/0x80
    [    0.583754]  [<ffffffff81775c4e>] kernel_init+0xe/0xe0
    [    0.583758]  [<ffffffff81781adf>] ret_from_fork+0x3f/0x70
    [    0.583760]  [<ffffffff81775c40>] ? rest_init+0x80/0x80
    [    0.583765] ---[ end trace 077c426a39e018aa ]---
    
    00:00.0 Host bridge [0600]: Intel Corporation Haswell-ULT DRAM Controller [8086:0a04] (rev 0b)
            Subsystem: Lenovo Device [17aa:220c]
            Control: I/O- Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR- FastB2B- DisINTx-
            Status: Cap+ 66MHz- UDF- FastB2B+ ParErr- DEVSEL=fast >TAbort- <TAbort- <MAbort+ >SERR- <PERR- INTx-
            Latency: 0
            Capabilities: <access denied>
            Kernel driver in use: hsw_uncore
    
    Link: https://bugzilla.redhat.com/show_bug.cgi?id=1300955
    Tested-by: <robo@tcp.sk>
    Signed-off-by: Josh Boyer <jwboyer@fedoraproject.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pnp/quirks.c b/drivers/pnp/quirks.c
index f700723ca5d6..d28e3ab9479c 100644
--- a/drivers/pnp/quirks.c
+++ b/drivers/pnp/quirks.c
@@ -342,6 +342,7 @@ static void quirk_amd_mmconfig_area(struct pnp_dev *dev)
 /* Device IDs of parts that have 32KB MCH space */
 static const unsigned int mch_quirk_devices[] = {
 	0x0154,	/* Ivy Bridge */
+	0x0a04, /* Haswell-ULT */
 	0x0c00,	/* Haswell */
 	0x1604, /* Broadwell */
 };

commit a77060f07ffc6ac978e280e738302f3e5572a99e
Author: Christophe Le Roy <christophe.fish@gmail.com>
Date:   Fri Dec 11 09:13:42 2015 +0100

    PNP: Add Broadwell to Intel MCH size workaround
    
    Add device ID 0x1604 for Broadwell to commit cb171f7abb9a ("PNP:
    Work around BIOS defects in Intel MCH area reporting").
    
    >From a Lenovo ThinkPad T550:
    
      system 00:01: [io  0x1800-0x189f] could not be reserved
      system 00:01: [io  0x0800-0x087f] has been reserved
      system 00:01: [io  0x0880-0x08ff] has been reserved
      system 00:01: [io  0x0900-0x097f] has been reserved
      system 00:01: [io  0x0980-0x09ff] has been reserved
      system 00:01: [io  0x0a00-0x0a7f] has been reserved
      system 00:01: [io  0x0a80-0x0aff] has been reserved
      system 00:01: [io  0x0b00-0x0b7f] has been reserved
      system 00:01: [io  0x0b80-0x0bff] has been reserved
      system 00:01: [io  0x15e0-0x15ef] has been reserved
      system 00:01: [io  0x1600-0x167f] has been reserved
      system 00:01: [io  0x1640-0x165f] has been reserved
      system 00:01: [mem 0xf8000000-0xfbffffff] could not be reserved
      system 00:01: [mem 0xfed1c000-0xfed1ffff] has been reserved
      system 00:01: [mem 0xfed10000-0xfed13fff] has been reserved
      system 00:01: [mem 0xfed18000-0xfed18fff] has been reserved
      system 00:01: [mem 0xfed19000-0xfed19fff] has been reserved
      system 00:01: [mem 0xfed45000-0xfed4bfff] has been reserved
      system 00:01: Plug and Play ACPI device, IDs PNP0c02 (active)
      [...]
      resource sanity check: requesting [mem 0xfed10000-0xfed15fff], which spans more than pnp 00:01 [mem 0xfed10000-0xfed13fff]
      ------------[ cut here ]------------
      WARNING: CPU: 2 PID: 1 at /build/linux-CrHvZ_/linux-4.2.6/arch/x86/mm/ioremap.c:198 __ioremap_caller+0x2ee/0x360()
      Info: mapping multiple BARs. Your kernel is fine.
      Modules linked in:
      CPU: 2 PID: 1 Comm: swapper/0 Not tainted 4.2.0-1-amd64 #1 Debian 4.2.6-1
      Hardware name: LENOVO 20CKCTO1WW/20CKCTO1WW, BIOS N11ET34W (1.10 ) 08/20/2015
       0000000000000000 ffffffff817e6868 ffffffff8154e2f6 ffff8802241efbf8
       ffffffff8106e5b1 ffffc90000e98000 0000000000006000 ffffc90000e98000
       0000000000006000 0000000000000000 ffffffff8106e62a ffffffff817e68c8
      Call Trace:
       [<ffffffff8154e2f6>] ? dump_stack+0x40/0x50
       [<ffffffff8106e5b1>] ? warn_slowpath_common+0x81/0xb0
       [<ffffffff8106e62a>] ? warn_slowpath_fmt+0x4a/0x50
       [<ffffffff810742a3>] ? iomem_map_sanity_check+0xb3/0xc0
       [<ffffffff8105dade>] ? __ioremap_caller+0x2ee/0x360
       [<ffffffff81036ae6>] ? snb_uncore_imc_init_box+0x66/0x90
       [<ffffffff810351a8>] ? uncore_pci_probe+0xc8/0x1a0
       [<ffffffff81302d7f>] ? local_pci_probe+0x3f/0xa0
       [<ffffffff81303ea4>] ? pci_device_probe+0xc4/0x110
       [<ffffffff813d9b1e>] ? driver_probe_device+0x1ee/0x450
       [<ffffffff813d9dfb>] ? __driver_attach+0x7b/0x80
       [<ffffffff813d9d80>] ? driver_probe_device+0x450/0x450
       [<ffffffff813d796a>] ? bus_for_each_dev+0x5a/0x90
       [<ffffffff813d9091>] ? bus_add_driver+0x1f1/0x290
       [<ffffffff81b37fa8>] ? uncore_cpu_setup+0xc/0xc
       [<ffffffff813da73f>] ? driver_register+0x5f/0xe0
       [<ffffffff81b38074>] ? intel_uncore_init+0xcc/0x2b0
       [<ffffffff81b37fa8>] ? uncore_cpu_setup+0xc/0xc
       [<ffffffff8100213e>] ? do_one_initcall+0xce/0x200
       [<ffffffff8108a100>] ? parse_args+0x140/0x4e0
       [<ffffffff81b2b0cb>] ? kernel_init_freeable+0x162/0x1e8
       [<ffffffff815443f0>] ? rest_init+0x80/0x80
       [<ffffffff815443fe>] ? kernel_init+0xe/0xf0
       [<ffffffff81553e5f>] ? ret_from_fork+0x3f/0x70
       [<ffffffff815443f0>] ? rest_init+0x80/0x80
      ---[ end trace 472e7959536abf12 ]---
    
      00:00.0 Host bridge: Intel Corporation Broadwell-U Host Bridge -OPI (rev 09)
              Subsystem: Lenovo Device 2223
              Control: I/O- Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR- FastB2B- DisINTx-
              Status: Cap+ 66MHz- UDF- FastB2B+ ParErr- DEVSEL=fast >TAbort- <TAbort- <MAbort+ >SERR- <PERR- INTx-
              Latency: 0
              Capabilities: [e0] Vendor Specific Information: Len=0c <?>
              Kernel driver in use: bdw_uncore
      00: 86 80 04 16 06 00 90 20 09 00 00 06 00 00 00 00
      10: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
      20: 00 00 00 00 00 00 00 00 00 00 00 00 aa 17 23 22
      30: 00 00 00 00 e0 00 00 00 00 00 00 00 00 00 00 00
    
    Signed-off-by: Christophe Le Roy <christophe.fish@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pnp/quirks.c b/drivers/pnp/quirks.c
index 943c1cb9566c..f700723ca5d6 100644
--- a/drivers/pnp/quirks.c
+++ b/drivers/pnp/quirks.c
@@ -343,6 +343,7 @@ static void quirk_amd_mmconfig_area(struct pnp_dev *dev)
 static const unsigned int mch_quirk_devices[] = {
 	0x0154,	/* Ivy Bridge */
 	0x0c00,	/* Haswell */
+	0x1604, /* Broadwell */
 };
 
 static struct pci_dev *get_intel_host(void)

commit f7834c092c42995e9f3611b7d186e9dfdb8430cc
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Mar 3 16:13:56 2015 -0600

    PNP: Don't check for overlaps with unassigned PCI BARs
    
    After 0509ad5e1a7d ("PNP: disable PNP motherboard resources that overlap
    PCI BARs"), we disable and warn about PNP resources that overlap PCI BARs.
    But we assume that all PCI BARs are valid, which is incorrect, because a
    BAR may not have any space assigned to it.  In that case, we will not
    enable the BAR, so no other resource can conflict with it.
    
    Ignore PCI BARs that are unassigned, as indicated by IORESOURCE_UNSET.
    
    Firmware often leaves PCI BARs unassigned, containing zero.  Zero is a
    valid BAR value, so we can't just check for that, but the PCI core can set
    IORESOURCE_UNSET when it detects an unassigned BAR by other means.  This
    should get rid of many of the annoying messages like this:
    
      pnp 00:00: disabling [io  0x0061] because it overlaps 0001:05:00.0 BAR 0 [io  0x0000-0x00ff]
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pnp/quirks.c b/drivers/pnp/quirks.c
index ebf0d6710b5a..943c1cb9566c 100644
--- a/drivers/pnp/quirks.c
+++ b/drivers/pnp/quirks.c
@@ -246,13 +246,16 @@ static void quirk_system_pci_resources(struct pnp_dev *dev)
 	 */
 	for_each_pci_dev(pdev) {
 		for (i = 0; i < DEVICE_COUNT_RESOURCE; i++) {
-			unsigned long type;
+			unsigned long flags, type;
 
-			type = pci_resource_flags(pdev, i) &
-					(IORESOURCE_IO | IORESOURCE_MEM);
+			flags = pci_resource_flags(pdev, i);
+			type = flags & (IORESOURCE_IO | IORESOURCE_MEM);
 			if (!type || pci_resource_len(pdev, i) == 0)
 				continue;
 
+			if (flags & IORESOURCE_UNSET)
+				continue;
+
 			pci_start = pci_resource_start(pdev, i);
 			pci_end = pci_resource_end(pdev, i);
 			for (j = 0;

commit b3413afb4a8995a67f5df6218c6d0ff3a53a6978
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Apr 29 00:20:34 2014 +0200

    PNP: Fix compile error in quirks.c
    
    Fix the compile error:
    
    drivers/pnp/quirks.c:393:2: error: implicit declaration of function 'pcibios_bus_to_resource'
    
    that occurs when building with CONFIG_PCI unset.  The quirk is only
    relevent to Intel devices, so we could use "#if defined(CONFIG_X86) &&
    defined(CONFIG_PCI)" instead, but testing CONFIG_X86 is not strictly
    necessary.
    
    Fixes: cb171f7abb9a (PNP: Work around BIOS defects in Intel MCH area reporting)
    Reported-by: Randy Dunlap <rdunlap@infradead.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pnp/quirks.c b/drivers/pnp/quirks.c
index 3736bc408adb..ebf0d6710b5a 100644
--- a/drivers/pnp/quirks.c
+++ b/drivers/pnp/quirks.c
@@ -335,7 +335,7 @@ static void quirk_amd_mmconfig_area(struct pnp_dev *dev)
 }
 #endif
 
-#ifdef CONFIG_X86
+#ifdef CONFIG_PCI
 /* Device IDs of parts that have 32KB MCH space */
 static const unsigned int mch_quirk_devices[] = {
 	0x0154,	/* Ivy Bridge */
@@ -440,7 +440,7 @@ static struct pnp_fixup pnp_fixups[] = {
 #ifdef CONFIG_AMD_NB
 	{"PNP0c01", quirk_amd_mmconfig_area},
 #endif
-#ifdef CONFIG_X86
+#ifdef CONFIG_PCI
 	{"PNP0c02", quirk_intel_mch},
 #endif
 	{""}

commit cb171f7abb9a1a250fb41d088b81799f75bd1357
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Apr 23 10:21:06 2014 -0600

    PNP: Work around BIOS defects in Intel MCH area reporting
    
    Work around BIOSes that don't report the entire Intel MCH area.
    
    MCHBAR is not an architected PCI BAR, so MCH space is usually reported as a
    PNP0C02 resource.  The MCH space was once 16KB, but is 32KB in newer parts.
    Some BIOSes still report a PNP0C02 resource that is only 16KB, which means
    the rest of the MCH space is consumed but unreported.
    
    This can cause resource map sanity check warnings or (theoretically) a
    device conflict if we assigned the unreported space to another device.
    
    The Intel perf event uncore driver tripped over this when it claimed the
    MCH region:
    
      resource map sanity check conflict: 0xfed10000 0xfed15fff 0xfed10000 0xfed13fff pnp 00:01
      Info: mapping multiple BARs. Your kernel is fine.
    
    To prevent this, if we find a PNP0C02 resource that covers part of the MCH
    space, extend it to cover the entire space.
    
    References: http://lkml.kernel.org/r/20140224162400.GE16457@pd.tnic
    Reported-and-tested-by: Borislav Petkov <bp@alien8.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Borislav Petkov <bp@suse.de>
    Acked-by: Stephane Eranian <eranian@google.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pnp/quirks.c b/drivers/pnp/quirks.c
index 258fef272ea7..3736bc408adb 100644
--- a/drivers/pnp/quirks.c
+++ b/drivers/pnp/quirks.c
@@ -15,6 +15,7 @@
 
 #include <linux/types.h>
 #include <linux/kernel.h>
+#include <linux/pci.h>
 #include <linux/string.h>
 #include <linux/slab.h>
 #include <linux/pnp.h>
@@ -334,6 +335,81 @@ static void quirk_amd_mmconfig_area(struct pnp_dev *dev)
 }
 #endif
 
+#ifdef CONFIG_X86
+/* Device IDs of parts that have 32KB MCH space */
+static const unsigned int mch_quirk_devices[] = {
+	0x0154,	/* Ivy Bridge */
+	0x0c00,	/* Haswell */
+};
+
+static struct pci_dev *get_intel_host(void)
+{
+	int i;
+	struct pci_dev *host;
+
+	for (i = 0; i < ARRAY_SIZE(mch_quirk_devices); i++) {
+		host = pci_get_device(PCI_VENDOR_ID_INTEL, mch_quirk_devices[i],
+				      NULL);
+		if (host)
+			return host;
+	}
+	return NULL;
+}
+
+static void quirk_intel_mch(struct pnp_dev *dev)
+{
+	struct pci_dev *host;
+	u32 addr_lo, addr_hi;
+	struct pci_bus_region region;
+	struct resource mch;
+	struct pnp_resource *pnp_res;
+	struct resource *res;
+
+	host = get_intel_host();
+	if (!host)
+		return;
+
+	/*
+	 * MCHBAR is not an architected PCI BAR, so MCH space is usually
+	 * reported as a PNP0C02 resource.  The MCH space was originally
+	 * 16KB, but is 32KB in newer parts.  Some BIOSes still report a
+	 * PNP0C02 resource that is only 16KB, which means the rest of the
+	 * MCH space is consumed but unreported.
+	 */
+
+	/*
+	 * Read MCHBAR for Host Member Mapped Register Range Base
+	 * https://www-ssl.intel.com/content/www/us/en/processors/core/4th-gen-core-family-desktop-vol-2-datasheet
+	 * Sec 3.1.12.
+	 */
+	pci_read_config_dword(host, 0x48, &addr_lo);
+	region.start = addr_lo & ~0x7fff;
+	pci_read_config_dword(host, 0x4c, &addr_hi);
+	region.start |= (u64) addr_hi << 32;
+	region.end = region.start + 32*1024 - 1;
+
+	memset(&mch, 0, sizeof(mch));
+	mch.flags = IORESOURCE_MEM;
+	pcibios_bus_to_resource(host->bus, &mch, &region);
+
+	list_for_each_entry(pnp_res, &dev->resources, list) {
+		res = &pnp_res->res;
+		if (res->end < mch.start || res->start > mch.end)
+			continue;	/* no overlap */
+		if (res->start == mch.start && res->end == mch.end)
+			continue;	/* exact match */
+
+		dev_info(&dev->dev, FW_BUG "PNP resource %pR covers only part of %s Intel MCH; extending to %pR\n",
+			 res, pci_name(host), &mch);
+		res->start = mch.start;
+		res->end = mch.end;
+		break;
+	}
+
+	pci_dev_put(host);
+}
+#endif
+
 /*
  *  PnP Quirks
  *  Cards or devices that need some tweaking due to incomplete resource info
@@ -363,6 +439,9 @@ static struct pnp_fixup pnp_fixups[] = {
 	{"PNP0c02", quirk_system_pci_resources},
 #ifdef CONFIG_AMD_NB
 	{"PNP0c01", quirk_amd_mmconfig_area},
+#endif
+#ifdef CONFIG_X86
+	{"PNP0c02", quirk_intel_mch},
 #endif
 	{""}
 };

commit eb31aae8cb5eb54e234ed2d857ddac868195d911
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Jan 5 14:27:24 2012 -0700

    PNP: work around Dell 1536/1546 BIOS MMCONFIG bug that breaks USB
    
    Some Dell BIOSes have MCFG tables that don't report the entire
    MMCONFIG area claimed by the chipset.  If we move PCI devices into
    that claimed-but-unreported area, they don't work.
    
    This quirk reads the AMD MMCONFIG MSRs and adds PNP0C01 resources as
    needed to cover the entire area.
    
    Example problem scenario:
    
      BIOS-e820: 00000000cfec5400 - 00000000d4000000 (reserved)
      Fam 10h mmconf [d0000000, dfffffff]
      PCI: MMCONFIG for domain 0000 [bus 00-3f] at [mem 0xd0000000-0xd3ffffff] (base 0xd0000000)
      pnp 00:0c: [mem 0xd0000000-0xd3ffffff]
      pci 0000:00:12.0: reg 10: [mem 0xffb00000-0xffb00fff]
      pci 0000:00:12.0: no compatible bridge window for [mem 0xffb00000-0xffb00fff]
      pci 0000:00:12.0: BAR 0: assigned [mem 0xd4000000-0xd40000ff]
    
    Reported-by: Lisa Salimbas <lisa.salimbas@canonical.com>
    Reported-by: <thuban@singularity.fr>
    Tested-by: dann frazier <dann.frazier@canonical.com>
    References: https://bugzilla.kernel.org/show_bug.cgi?id=31602
    References: https://bugs.launchpad.net/ubuntu/+source/linux/+bug/647043
    References: https://bugzilla.redhat.com/show_bug.cgi?id=770308
    Cc: stable@kernel.org   # 2.6.34+
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pnp/quirks.c b/drivers/pnp/quirks.c
index dfbd5a6cc58b..258fef272ea7 100644
--- a/drivers/pnp/quirks.c
+++ b/drivers/pnp/quirks.c
@@ -295,6 +295,45 @@ static void quirk_system_pci_resources(struct pnp_dev *dev)
 	}
 }
 
+#ifdef CONFIG_AMD_NB
+
+#include <asm/amd_nb.h>
+
+static void quirk_amd_mmconfig_area(struct pnp_dev *dev)
+{
+	resource_size_t start, end;
+	struct pnp_resource *pnp_res;
+	struct resource *res;
+	struct resource mmconfig_res, *mmconfig;
+
+	mmconfig = amd_get_mmconfig_range(&mmconfig_res);
+	if (!mmconfig)
+		return;
+
+	list_for_each_entry(pnp_res, &dev->resources, list) {
+		res = &pnp_res->res;
+		if (res->end < mmconfig->start || res->start > mmconfig->end ||
+		    (res->start == mmconfig->start && res->end == mmconfig->end))
+			continue;
+
+		dev_info(&dev->dev, FW_BUG
+			 "%pR covers only part of AMD MMCONFIG area %pR; adding more reservations\n",
+			 res, mmconfig);
+		if (mmconfig->start < res->start) {
+			start = mmconfig->start;
+			end = res->start - 1;
+			pnp_add_mem_resource(dev, start, end, 0);
+		}
+		if (mmconfig->end > res->end) {
+			start = res->end + 1;
+			end = mmconfig->end;
+			pnp_add_mem_resource(dev, start, end, 0);
+		}
+		break;
+	}
+}
+#endif
+
 /*
  *  PnP Quirks
  *  Cards or devices that need some tweaking due to incomplete resource info
@@ -322,6 +361,9 @@ static struct pnp_fixup pnp_fixups[] = {
 	/* PnP resources that might overlap PCI BARs */
 	{"PNP0c01", quirk_system_pci_resources},
 	{"PNP0c02", quirk_system_pci_resources},
+#ifdef CONFIG_AMD_NB
+	{"PNP0c01", quirk_amd_mmconfig_area},
+#endif
 	{""}
 };
 

commit c7dabef8a2c59e6a3de9d66fc35fb6a43ef7172d
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Oct 27 13:26:47 2009 -0600

    vsprintf: use %pR, %pr instead of %pRt, %pRf
    
    Jesse accidentally applied v1 [1] of the patchset instead of v2 [2].  This
    is the diff between v1 and v2.
    
    The changes in this patch are:
        - tidied vsprintf stack buffer to shrink and compute size more
          accurately
        - use %pR for decoding and %pr for "raw" (with type and flags) instead
          of adding %pRt and %pRf
    
    [1] http://lkml.org/lkml/2009/10/6/491
    [2] http://lkml.org/lkml/2009/10/13/441
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pnp/quirks.c b/drivers/pnp/quirks.c
index 3a2031b25c3c..dfbd5a6cc58b 100644
--- a/drivers/pnp/quirks.c
+++ b/drivers/pnp/quirks.c
@@ -285,8 +285,9 @@ static void quirk_system_pci_resources(struct pnp_dev *dev)
 				 * the PCI region, and that might prevent a PCI
 				 * driver from requesting its resources.
 				 */
-				dev_warn(&dev->dev, "resource %pRt overlaps %s "
-					 "BAR %d %pRt, disabling\n", res,
+				dev_warn(&dev->dev,
+					 "disabling %pR because it overlaps "
+					 "%s BAR %d %pR\n", res,
 					 pci_name(pdev), i, &pdev->resource[i]);
 				res->flags |= IORESOURCE_DISABLED;
 			}

commit 9a007b3791cdba3601d835ea10e68c14115b9afb
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Oct 6 15:34:00 2009 -0600

    PNP: print resources consistently with %pRt
    
    This uses %pRt and %pRf to print additional resource information (type,
    size, prefetchability, etc.) consistently.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pnp/quirks.c b/drivers/pnp/quirks.c
index 8473fe5ed7ff..3a2031b25c3c 100644
--- a/drivers/pnp/quirks.c
+++ b/drivers/pnp/quirks.c
@@ -285,15 +285,9 @@ static void quirk_system_pci_resources(struct pnp_dev *dev)
 				 * the PCI region, and that might prevent a PCI
 				 * driver from requesting its resources.
 				 */
-				dev_warn(&dev->dev, "%s resource "
-					"(0x%llx-0x%llx) overlaps %s BAR %d "
-					"(0x%llx-0x%llx), disabling\n",
-					pnp_resource_type_name(res),
-					(unsigned long long) pnp_start,
-					(unsigned long long) pnp_end,
-					pci_name(pdev), i,
-					(unsigned long long) pci_start,
-					(unsigned long long) pci_end);
+				dev_warn(&dev->dev, "resource %pRt overlaps %s "
+					 "BAR %d %pRt, disabling\n", res,
+					 pci_name(pdev), i, &pdev->resource[i]);
 				res->flags |= IORESOURCE_DISABLED;
 			}
 		}

commit 057316cc6a5b521b332a1d7ccc871cd60c904c74
Merge: 3e2dab9a1c2d 2515ddc6db8e
Author: Len Brown <len.brown@intel.com>
Date:   Wed Oct 22 23:57:26 2008 -0400

    Merge branch 'linus' into test
    
    Conflicts:
            MAINTAINERS
            arch/x86/kernel/acpi/boot.c
            arch/x86/kernel/acpi/sleep.c
            drivers/acpi/Kconfig
            drivers/pnp/Makefile
            drivers/pnp/quirks.c
    
    Signed-off-by: Len Brown <len.brown@intel.com>

commit 2e532d68a2b3e2aa6b19731501222069735c741c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Oct 16 16:11:43 2008 -0700

    {pci,pnp} quirks.c: don't use deprecated print_fn_descriptor_symbol()
    
    I dunno how this missed Bjorn and his quest to use %pF in commit
    c80cfb0406c01bb5da91bfe30f5cb1fd96831138 ("vsprintf: use new vsprintf
    symbolic function pointer format"), but it did.
    
    So use %pF in the two remaining places that still tried to print out
    function pointers by hand.
    
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pnp/quirks.c b/drivers/pnp/quirks.c
index d15e2b77af88..c144bd575611 100644
--- a/drivers/pnp/quirks.c
+++ b/drivers/pnp/quirks.c
@@ -338,8 +338,7 @@ void pnp_fixup_device(struct pnp_dev *dev)
 		if (!compare_pnp_id(dev->id, f->id))
 			continue;
 #ifdef DEBUG
-		dev_dbg(&dev->dev, "%s: calling ", f->id);
-		print_fn_descriptor_symbol("%s\n", f->quirk_function);
+		dev_dbg(&dev->dev, "%s: calling %pF\n", f->id, f->quirk_function);
 #endif
 		f->quirk_function(dev);
 	}

commit b563cf59c4d67da7d671788a9848416bfa4180ab
Author: Rene Herman <rene.herman@keyaccess.nl>
Date:   Wed Oct 15 22:03:58 2008 -0700

    pnp: make the resource type an unsigned long
    
    PnP encodes the resource type directly as its struct resource->flags value
    which is an unsigned long.  Make it so...
    
    Signed-off-by: Rene Herman <rene.herman@gmail.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Acked-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Cc: Andi Kleen <andi@firstfloor.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pnp/quirks.c b/drivers/pnp/quirks.c
index 0bdf9b8a5e58..d15e2b77af88 100644
--- a/drivers/pnp/quirks.c
+++ b/drivers/pnp/quirks.c
@@ -245,7 +245,7 @@ static void quirk_system_pci_resources(struct pnp_dev *dev)
 	 */
 	for_each_pci_dev(pdev) {
 		for (i = 0; i < DEVICE_COUNT_RESOURCE; i++) {
-			unsigned int type;
+			unsigned long type;
 
 			type = pci_resource_flags(pdev, i) &
 					(IORESOURCE_IO | IORESOURCE_MEM);

commit 2f53432c2aedbe79020e44525eb069d9138a01dd
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Aug 19 16:53:47 2008 -0600

    PNP: convert to using pnp_dbg()
    
    pnp_dbg() is equivalent to dev_dbg() except that we can turn it
    on at boot-time with the "pnp.debug" kernel parameter, so we don't
    have to build a new kernel image.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/quirks.c b/drivers/pnp/quirks.c
index 414bb0945729..3d2e56094783 100644
--- a/drivers/pnp/quirks.c
+++ b/drivers/pnp/quirks.c
@@ -337,7 +337,7 @@ void pnp_fixup_device(struct pnp_dev *dev)
 	for (f = pnp_fixups; *f->id; f++) {
 		if (!compare_pnp_id(dev->id, f->id))
 			continue;
-		dev_dbg(&dev->dev, "%s: calling %pF\n", f->id,
+		pnp_dbg(&dev->dev, "%s: calling %pF\n", f->id,
 			f->quirk_function);
 		f->quirk_function(dev);
 	}

commit 668b21de141edcba3fb13a4f810641eea4740fd7
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Aug 19 16:53:31 2008 -0600

    PNP: use new vsprintf symbolic function pointer format
    
    Use the '%pF' format to get rid of an "#ifdef DEBUG".
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/quirks.c b/drivers/pnp/quirks.c
index 0bdf9b8a5e58..414bb0945729 100644
--- a/drivers/pnp/quirks.c
+++ b/drivers/pnp/quirks.c
@@ -337,10 +337,8 @@ void pnp_fixup_device(struct pnp_dev *dev)
 	for (f = pnp_fixups; *f->id; f++) {
 		if (!compare_pnp_id(dev->id, f->id))
 			continue;
-#ifdef DEBUG
-		dev_dbg(&dev->dev, "%s: calling ", f->id);
-		print_fn_descriptor_symbol("%s\n", f->quirk_function);
-#endif
+		dev_dbg(&dev->dev, "%s: calling %pF\n", f->id,
+			f->quirk_function);
 		f->quirk_function(dev);
 	}
 }

commit 999ed65ad12e374d7445fbc13f5a1d146ae4b0da
Author: Rene Herman <rene.herman@gmail.com>
Date:   Fri Jul 25 19:44:47 2008 -0700

    pnp: have quirk_system_pci_resources() include io resources
    
    quirk_system_pci_resources() disables a PnP mem resource that overlaps a
    PCI BAR so as to not keep the PCI driver from claiming the resource.  Have
    it do the same for io resources.
    
    Here, ACPI claims ports that overlap with my soundcard causing the
    soundcard driver to fail to load.  It's unknown why my ACPI BIOS claims
    those ports; it did not use to but this is not a (kernel) regression.
    Some odd BIOS reconfig triggered by temporarily removing the card seems to
    have brought this on.
    
    Signed-off-by: Rene Herman <rene.herman@gmail.com>
    Acked-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pnp/quirks.c b/drivers/pnp/quirks.c
index 55f55ed72dc7..0bdf9b8a5e58 100644
--- a/drivers/pnp/quirks.c
+++ b/drivers/pnp/quirks.c
@@ -245,15 +245,17 @@ static void quirk_system_pci_resources(struct pnp_dev *dev)
 	 */
 	for_each_pci_dev(pdev) {
 		for (i = 0; i < DEVICE_COUNT_RESOURCE; i++) {
-			if (!(pci_resource_flags(pdev, i) & IORESOURCE_MEM) ||
-			    pci_resource_len(pdev, i) == 0)
+			unsigned int type;
+
+			type = pci_resource_flags(pdev, i) &
+					(IORESOURCE_IO | IORESOURCE_MEM);
+			if (!type || pci_resource_len(pdev, i) == 0)
 				continue;
 
 			pci_start = pci_resource_start(pdev, i);
 			pci_end = pci_resource_end(pdev, i);
 			for (j = 0;
-			     (res = pnp_get_resource(dev, IORESOURCE_MEM, j));
-			     j++) {
+			     (res = pnp_get_resource(dev, type, j)); j++) {
 				if (res->start == 0 && res->end == 0)
 					continue;
 
@@ -283,9 +285,10 @@ static void quirk_system_pci_resources(struct pnp_dev *dev)
 				 * the PCI region, and that might prevent a PCI
 				 * driver from requesting its resources.
 				 */
-				dev_warn(&dev->dev, "mem resource "
+				dev_warn(&dev->dev, "%s resource "
 					"(0x%llx-0x%llx) overlaps %s BAR %d "
 					"(0x%llx-0x%llx), disabling\n",
+					pnp_resource_type_name(res),
 					(unsigned long long) pnp_start,
 					(unsigned long long) pnp_end,
 					pci_name(pdev), i,

commit 1f32ca31e7409d37c1b25e5f81840fb184380cdf
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Fri Jun 27 16:57:17 2008 -0600

    PNP: convert resource options to single linked list
    
    ISAPNP, PNPBIOS, and ACPI describe the "possible resource settings" of
    a device, i.e., the possibilities an OS bus driver has when it assigns
    I/O port, MMIO, and other resources to the device.
    
    PNP used to maintain this "possible resource setting" information in
    one independent option structure and a list of dependent option
    structures for each device.  Each of these option structures had lists
    of I/O, memory, IRQ, and DMA resources, for example:
    
      dev
        independent options
          ind-io0  -> ind-io1  ...
          ind-mem0 -> ind-mem1 ...
          ...
        dependent option set 0
          dep0-io0  -> dep0-io1  ...
          dep0-mem0 -> dep0-mem1 ...
          ...
        dependent option set 1
          dep1-io0  -> dep1-io1  ...
          dep1-mem0 -> dep1-mem1 ...
          ...
        ...
    
    This data structure was designed for ISAPNP, where the OS configures
    device resource settings by writing directly to configuration
    registers.  The OS can write the registers in arbitrary order much
    like it writes PCI BARs.
    
    However, for PNPBIOS and ACPI devices, the OS uses firmware interfaces
    that perform device configuration, and it is important to pass the
    desired settings to those interfaces in the correct order.  The OS
    learns the correct order by using firmware interfaces that return the
    "current resource settings" and "possible resource settings," but the
    option structures above doesn't store the ordering information.
    
    This patch replaces the independent and dependent lists with a single
    list of options.  For example, a device might have possible resource
    settings like this:
    
      dev
        options
          ind-io0 -> dep0-io0 -> dep1->io0 -> ind-io1 ...
    
    All the possible settings are in the same list, in the order they
    come from the firmware "possible resource settings" list.  Each entry
    is tagged with an independent/dependent flag.  Dependent entries also
    have a "set number" and an optional priority value.  All dependent
    entries must be assigned from the same set.  For example, the OS can
    use all the entries from dependent set 0, or all the entries from
    dependent set 1, but it cannot mix entries from set 0 with entries
    from set 1.
    
    Prior to this patch PNP didn't keep track of the order of this list,
    and it assigned all independent options first, then all dependent
    ones.  Using the example above, that resulted in a "desired
    configuration" list like this:
    
      ind->io0 -> ind->io1 -> depN-io0 ...
    
    instead of the list the firmware expects, which looks like this:
    
      ind->io0 -> depN-io0 -> ind-io1 ...
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Acked-by: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/quirks.c b/drivers/pnp/quirks.c
index e8515ce0d296..55f55ed72dc7 100644
--- a/drivers/pnp/quirks.c
+++ b/drivers/pnp/quirks.c
@@ -5,6 +5,8 @@
  *  when building up the resource structure for the first time.
  *
  *  Copyright (c) 2000 Peter Denison <peterd@pnd-pc.demon.co.uk>
+ *  Copyright (C) 2008 Hewlett-Packard Development Company, L.P.
+ *	Bjorn Helgaas <bjorn.helgaas@hp.com>
  *
  *  Heavily based on PCI quirks handling which is
  *
@@ -20,189 +22,207 @@
 #include <linux/kallsyms.h>
 #include "base.h"
 
+static void quirk_awe32_add_ports(struct pnp_dev *dev,
+				  struct pnp_option *option,
+				  unsigned int offset)
+{
+	struct pnp_option *new_option;
+
+	new_option = kmalloc(sizeof(struct pnp_option), GFP_KERNEL);
+	if (!new_option) {
+		dev_err(&dev->dev, "couldn't add ioport region to option set "
+			"%d\n", pnp_option_set(option));
+		return;
+	}
+
+	*new_option = *option;
+	new_option->u.port.min += offset;
+	new_option->u.port.max += offset;
+	list_add(&new_option->list, &option->list);
+
+	dev_info(&dev->dev, "added ioport region %#llx-%#llx to set %d\n",
+		(unsigned long long) new_option->u.port.min,
+		(unsigned long long) new_option->u.port.max,
+		pnp_option_set(option));
+}
+
 static void quirk_awe32_resources(struct pnp_dev *dev)
 {
-	struct pnp_port *port, *port2, *port3;
-	struct pnp_option *res = dev->dependent;
+	struct pnp_option *option;
+	unsigned int set = ~0;
 
 	/*
-	 * Unfortunately the isapnp_add_port_resource is too tightly bound
-	 * into the PnP discovery sequence, and cannot be used. Link in the
-	 * two extra ports (at offset 0x400 and 0x800 from the one given) by
-	 * hand.
+	 * Add two extra ioport regions (at offset 0x400 and 0x800 from the
+	 * one given) to every dependent option set.
 	 */
-	for (; res; res = res->next) {
-		port2 = pnp_alloc(sizeof(struct pnp_port));
-		if (!port2)
-			return;
-		port3 = pnp_alloc(sizeof(struct pnp_port));
-		if (!port3) {
-			kfree(port2);
-			return;
+	list_for_each_entry(option, &dev->options, list) {
+		if (pnp_option_is_dependent(option) &&
+		    pnp_option_set(option) != set) {
+			set = pnp_option_set(option);
+			quirk_awe32_add_ports(dev, option, 0x800);
+			quirk_awe32_add_ports(dev, option, 0x400);
 		}
-		port = res->port;
-		memcpy(port2, port, sizeof(struct pnp_port));
-		memcpy(port3, port, sizeof(struct pnp_port));
-		port->next = port2;
-		port2->next = port3;
-		port2->min += 0x400;
-		port2->max += 0x400;
-		port3->min += 0x800;
-		port3->max += 0x800;
-		dev_info(&dev->dev,
-			"AWE32 quirk - added ioports 0x%lx and 0x%lx\n",
-			(unsigned long)port2->min,
-			(unsigned long)port3->min);
 	}
 }
 
 static void quirk_cmi8330_resources(struct pnp_dev *dev)
 {
-	struct pnp_option *res = dev->dependent;
-	unsigned long tmp;
-
-	for (; res; res = res->next) {
-
-		struct pnp_irq *irq;
-		struct pnp_dma *dma;
+	struct pnp_option *option;
+	struct pnp_irq *irq;
+	struct pnp_dma *dma;
 
-		for (irq = res->irq; irq; irq = irq->next) {
-			/* Valid irqs are 5, 7, 10 */
-			tmp = 0x04A0;
-			bitmap_copy(irq->map.bits, &tmp, 16);
-		}
+	list_for_each_entry(option, &dev->options, list) {
+		if (!pnp_option_is_dependent(option))
+			continue;
 
-		for (dma = res->dma; dma; dma = dma->next) {
-			/* Valid 8bit dma channels are 1,3 */
+		if (option->type == IORESOURCE_IRQ) {
+			irq = &option->u.irq;
+			bitmap_zero(irq->map.bits, PNP_IRQ_NR);
+			__set_bit(5, irq->map.bits);
+			__set_bit(7, irq->map.bits);
+			__set_bit(10, irq->map.bits);
+			dev_info(&dev->dev, "set possible IRQs in "
+				 "option set %d to 5, 7, 10\n",
+				 pnp_option_set(option));
+		} else if (option->type == IORESOURCE_DMA) {
+			dma = &option->u.dma;
 			if ((dma->flags & IORESOURCE_DMA_TYPE_MASK) ==
-			    IORESOURCE_DMA_8BIT)
-				dma->map = 0x000A;
+						IORESOURCE_DMA_8BIT &&
+			    dma->map != 0x0A) {
+				dev_info(&dev->dev, "changing possible "
+					 "DMA channel mask in option set %d "
+					 "from %#02x to 0x0A (1, 3)\n",
+					 pnp_option_set(option), dma->map);
+				dma->map = 0x0A;
+			}
 		}
 	}
-	dev_info(&dev->dev, "CMI8330 quirk - forced possible IRQs to 5, 7, 10 "
-		"and DMA channels to 1, 3\n");
 }
 
 static void quirk_sb16audio_resources(struct pnp_dev *dev)
 {
+	struct pnp_option *option;
+	unsigned int prev_option_flags = ~0, n = 0;
 	struct pnp_port *port;
-	struct pnp_option *res = dev->dependent;
-	int changed = 0;
 
 	/*
-	 * The default range on the mpu port for these devices is 0x388-0x388.
+	 * The default range on the OPL port for these devices is 0x388-0x388.
 	 * Here we increase that range so that two such cards can be
 	 * auto-configured.
 	 */
+	list_for_each_entry(option, &dev->options, list) {
+		if (prev_option_flags != option->flags) {
+			prev_option_flags = option->flags;
+			n = 0;
+		}
 
-	for (; res; res = res->next) {
-		port = res->port;
-		if (!port)
-			continue;
-		port = port->next;
-		if (!port)
-			continue;
-		port = port->next;
-		if (!port)
-			continue;
-		if (port->min != port->max)
-			continue;
-		port->max += 0x70;
-		changed = 1;
+		if (pnp_option_is_dependent(option) &&
+		    option->type == IORESOURCE_IO) {
+			n++;
+			port = &option->u.port;
+			if (n == 3 && port->min == port->max) {
+				port->max += 0x70;
+				dev_info(&dev->dev, "increased option port "
+					 "range from %#llx-%#llx to "
+					 "%#llx-%#llx\n",
+					 (unsigned long long) port->min,
+					 (unsigned long long) port->min,
+					 (unsigned long long) port->min,
+					 (unsigned long long) port->max);
+			}
+		}
 	}
-	if (changed)
-		dev_info(&dev->dev, "SB audio device quirk - increased port range\n");
 }
 
-static struct pnp_option *quirk_isapnp_mpu_options(struct pnp_dev *dev)
+static struct pnp_option *pnp_clone_dependent_set(struct pnp_dev *dev,
+						  unsigned int set)
 {
-	struct pnp_option *head = NULL;
-	struct pnp_option *prev = NULL;
-	struct pnp_option *res;
-
-	/*
-	 * Build a functional IRQ-optional variant of each MPU option.
-	 */
-
-	for (res = dev->dependent; res; res = res->next) {
-		struct pnp_option *curr;
-		struct pnp_port *port;
-		struct pnp_port *copy_port;
-		struct pnp_irq *irq;
-		struct pnp_irq *copy_irq;
-
-		port = res->port;
-		irq = res->irq;
-		if (!port || !irq)
-			continue;
+	struct pnp_option *tail = NULL, *first_new_option = NULL;
+	struct pnp_option *option, *new_option;
+	unsigned int flags;
 
-		copy_port = pnp_alloc(sizeof *copy_port);
-		if (!copy_port)
-			break;
-
-		copy_irq = pnp_alloc(sizeof *copy_irq);
-		if (!copy_irq) {
-			kfree(copy_port);
-			break;
-		}
+	list_for_each_entry(option, &dev->options, list) {
+		if (pnp_option_is_dependent(option))
+			tail = option;
+	}
+	if (!tail) {
+		dev_err(&dev->dev, "no dependent option sets\n");
+		return NULL;
+	}
 
-		*copy_port = *port;
-		copy_port->next = NULL;
+	flags = pnp_new_dependent_set(dev, PNP_RES_PRIORITY_FUNCTIONAL);
+	list_for_each_entry(option, &dev->options, list) {
+		if (pnp_option_is_dependent(option) &&
+		    pnp_option_set(option) == set) {
+			new_option = kmalloc(sizeof(struct pnp_option),
+					     GFP_KERNEL);
+			if (!new_option) {
+				dev_err(&dev->dev, "couldn't clone dependent "
+					"set %d\n", set);
+				return NULL;
+			}
 
-		*copy_irq = *irq;
-		copy_irq->flags |= IORESOURCE_IRQ_OPTIONAL;
-		copy_irq->next = NULL;
+			*new_option = *option;
+			new_option->flags = flags;
+			if (!first_new_option)
+				first_new_option = new_option;
 
-		curr = pnp_build_option(PNP_RES_PRIORITY_FUNCTIONAL);
-		if (!curr) {
-			kfree(copy_port);
-			kfree(copy_irq);
-			break;
+			list_add(&new_option->list, &tail->list);
+			tail = new_option;
 		}
-		curr->port = copy_port;
-		curr->irq = copy_irq;
-
-		if (prev)
-			prev->next = curr;
-		else
-			head = curr;
-		prev = curr;
 	}
-	if (head)
-		dev_info(&dev->dev, "adding IRQ-optional MPU options\n");
 
-	return head;
+	return first_new_option;
 }
 
-static void quirk_ad1815_mpu_resources(struct pnp_dev *dev)
+
+static void quirk_add_irq_optional_dependent_sets(struct pnp_dev *dev)
 {
-	struct pnp_option *res;
+	struct pnp_option *new_option;
+	unsigned int num_sets, i, set;
 	struct pnp_irq *irq;
 
-	res = dev->independent;
-	if (!res)
-		return;
+	num_sets = dev->num_dependent_sets;
+	for (i = 0; i < num_sets; i++) {
+		new_option = pnp_clone_dependent_set(dev, i);
+		if (!new_option)
+			return;
 
-	irq = res->irq;
-	if (!irq || irq->next)
-		return;
+		set = pnp_option_set(new_option);
+		while (new_option && pnp_option_set(new_option) == set) {
+			if (new_option->type == IORESOURCE_IRQ) {
+				irq = &new_option->u.irq;
+				irq->flags |= IORESOURCE_IRQ_OPTIONAL;
+			}
+			dbg_pnp_show_option(dev, new_option);
+			new_option = list_entry(new_option->list.next,
+						struct pnp_option, list);
+		}
 
-	irq->flags |= IORESOURCE_IRQ_OPTIONAL;
-	dev_info(&dev->dev, "made independent IRQ optional\n");
+		dev_info(&dev->dev, "added dependent option set %d (same as "
+			 "set %d except IRQ optional)\n", set, i);
+	}
 }
 
-static void quirk_isapnp_mpu_resources(struct pnp_dev *dev)
+static void quirk_ad1815_mpu_resources(struct pnp_dev *dev)
 {
-	struct pnp_option *res;
+	struct pnp_option *option;
+	struct pnp_irq *irq = NULL;
+	unsigned int independent_irqs = 0;
+
+	list_for_each_entry(option, &dev->options, list) {
+		if (option->type == IORESOURCE_IRQ &&
+		    !pnp_option_is_dependent(option)) {
+			independent_irqs++;
+			irq = &option->u.irq;
+		}
+	}
 
-	res = dev->dependent;
-	if (!res)
+	if (independent_irqs != 1)
 		return;
 
-	while (res->next)
-		res = res->next;
-
-	res->next = quirk_isapnp_mpu_options(dev);
+	irq->flags |= IORESOURCE_IRQ_OPTIONAL;
+	dev_info(&dev->dev, "made independent IRQ optional\n");
 }
 
 #include <linux/pci.h>
@@ -297,10 +317,10 @@ static struct pnp_fixup pnp_fixups[] = {
 	{"CTL0043", quirk_sb16audio_resources},
 	{"CTL0044", quirk_sb16audio_resources},
 	{"CTL0045", quirk_sb16audio_resources},
-	/* Add IRQ-less MPU options */
+	/* Add IRQ-optional MPU options */
 	{"ADS7151", quirk_ad1815_mpu_resources},
-	{"ADS7181", quirk_isapnp_mpu_resources},
-	{"AZT0002", quirk_isapnp_mpu_resources},
+	{"ADS7181", quirk_add_irq_optional_dependent_sets},
+	{"AZT0002", quirk_add_irq_optional_dependent_sets},
 	/* PnP resources that might overlap PCI BARs */
 	{"PNP0c01", quirk_system_pci_resources},
 	{"PNP0c02", quirk_system_pci_resources},

commit d5ebde6ef5c2d51828f975a81d7d0e58bccfd833
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Fri Jun 27 16:57:14 2008 -0600

    PNP: support optional IRQ resources
    
    This patch adds an IORESOURCE_IRQ_OPTIONAL flag for use when
    assigning resources to a device.  If the flag is set and we are
    unable to assign an IRQ to the device, we can leave the IRQ
    disabled but allow the overall resource allocation to succeed.
    
    Some devices request an IRQ, but can run without an IRQ
    (possibly with degraded performance).  This flag lets us run
    the device without the IRQ instead of just leaving the
    device disabled.
    
    This is a reimplementation of this previous change by Rene
    Herman <rene.herman@gmail.com>:
        http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commit;h=3b73a223661ed137c5d3d2635f954382e94f5a43
    
    I reimplemented this for two reasons:
        - to prepare for converting all resource options into a single linked
          list, as opposed to the per-resource-type lists we have now, and
        - to preserve the order and number of resource options.
    
    In PNPBIOS and ACPI, we configure a device by giving firmware a
    list of resource assignments.  It is important that this list
    has exactly the same number of resources, in the same order,
    as the "template" list we got from the firmware in the first
    place.
    
    The problem of a sound card MPU401 being left disabled for want of
    an IRQ was reported by Uwe Bugla <uwe.bugla@gmx.de>.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Acked-by: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/quirks.c b/drivers/pnp/quirks.c
index 48e60171b3ba..e8515ce0d296 100644
--- a/drivers/pnp/quirks.c
+++ b/drivers/pnp/quirks.c
@@ -121,34 +121,46 @@ static struct pnp_option *quirk_isapnp_mpu_options(struct pnp_dev *dev)
 	struct pnp_option *res;
 
 	/*
-	 * Build a functional IRQ-less variant of each MPU option.
+	 * Build a functional IRQ-optional variant of each MPU option.
 	 */
 
 	for (res = dev->dependent; res; res = res->next) {
 		struct pnp_option *curr;
 		struct pnp_port *port;
-		struct pnp_port *copy;
+		struct pnp_port *copy_port;
+		struct pnp_irq *irq;
+		struct pnp_irq *copy_irq;
 
 		port = res->port;
-		if (!port || !res->irq)
+		irq = res->irq;
+		if (!port || !irq)
 			continue;
 
-		copy = pnp_alloc(sizeof *copy);
-		if (!copy)
+		copy_port = pnp_alloc(sizeof *copy_port);
+		if (!copy_port)
+			break;
+
+		copy_irq = pnp_alloc(sizeof *copy_irq);
+		if (!copy_irq) {
+			kfree(copy_port);
 			break;
+		}
+
+		*copy_port = *port;
+		copy_port->next = NULL;
 
-		copy->min = port->min;
-		copy->max = port->max;
-		copy->align = port->align;
-		copy->size = port->size;
-		copy->flags = port->flags;
+		*copy_irq = *irq;
+		copy_irq->flags |= IORESOURCE_IRQ_OPTIONAL;
+		copy_irq->next = NULL;
 
 		curr = pnp_build_option(PNP_RES_PRIORITY_FUNCTIONAL);
 		if (!curr) {
-			kfree(copy);
+			kfree(copy_port);
+			kfree(copy_irq);
 			break;
 		}
-		curr->port = copy;
+		curr->port = copy_port;
+		curr->irq = copy_irq;
 
 		if (prev)
 			prev->next = curr;
@@ -157,7 +169,7 @@ static struct pnp_option *quirk_isapnp_mpu_options(struct pnp_dev *dev)
 		prev = curr;
 	}
 	if (head)
-		dev_info(&dev->dev, "adding IRQ-less MPU options\n");
+		dev_info(&dev->dev, "adding IRQ-optional MPU options\n");
 
 	return head;
 }
@@ -167,10 +179,6 @@ static void quirk_ad1815_mpu_resources(struct pnp_dev *dev)
 	struct pnp_option *res;
 	struct pnp_irq *irq;
 
-	/*
-	 * Distribute the independent IRQ over the dependent options
-	 */
-
 	res = dev->independent;
 	if (!res)
 		return;
@@ -179,33 +187,8 @@ static void quirk_ad1815_mpu_resources(struct pnp_dev *dev)
 	if (!irq || irq->next)
 		return;
 
-	res = dev->dependent;
-	if (!res)
-		return;
-
-	while (1) {
-		struct pnp_irq *copy;
-
-		copy = pnp_alloc(sizeof *copy);
-		if (!copy)
-			break;
-
-		bitmap_copy(copy->map.bits, irq->map.bits, PNP_IRQ_NR);
-		copy->flags = irq->flags;
-
-		copy->next = res->irq; /* Yes, this is NULL */
-		res->irq = copy;
-
-		if (!res->next)
-			break;
-		res = res->next;
-	}
-	kfree(irq);
-
-	res->next = quirk_isapnp_mpu_options(dev);
-
-	res = dev->independent;
-	res->irq = NULL;
+	irq->flags |= IORESOURCE_IRQ_OPTIONAL;
+	dev_info(&dev->dev, "made independent IRQ optional\n");
 }
 
 static void quirk_isapnp_mpu_resources(struct pnp_dev *dev)

commit 7aefff51854ccd33599c40b4e360d94cb2b7622f
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Fri Jun 27 16:57:05 2008 -0600

    PNP: introduce pnp_irq_mask_t typedef
    
    This adds a typedef for the IRQ bitmap, which should cause
    no functional change, but will make it easier to pass a
    pointer to a bitmap to pnp_register_irq_resource().
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Acked-by: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/quirks.c b/drivers/pnp/quirks.c
index 21acb54eff6d..48e60171b3ba 100644
--- a/drivers/pnp/quirks.c
+++ b/drivers/pnp/quirks.c
@@ -66,15 +66,18 @@ static void quirk_cmi8330_resources(struct pnp_dev *dev)
 		struct pnp_irq *irq;
 		struct pnp_dma *dma;
 
-		for (irq = res->irq; irq; irq = irq->next) {	// Valid irqs are 5, 7, 10
+		for (irq = res->irq; irq; irq = irq->next) {
+			/* Valid irqs are 5, 7, 10 */
 			tmp = 0x04A0;
-			bitmap_copy(irq->map, &tmp, 16);	// 0000 0100 1010 0000
+			bitmap_copy(irq->map.bits, &tmp, 16);
 		}
 
-		for (dma = res->dma; dma; dma = dma->next)	// Valid 8bit dma channels are 1,3
+		for (dma = res->dma; dma; dma = dma->next) {
+			/* Valid 8bit dma channels are 1,3 */
 			if ((dma->flags & IORESOURCE_DMA_TYPE_MASK) ==
 			    IORESOURCE_DMA_8BIT)
 				dma->map = 0x000A;
+		}
 	}
 	dev_info(&dev->dev, "CMI8330 quirk - forced possible IRQs to 5, 7, 10 "
 		"and DMA channels to 1, 3\n");
@@ -187,7 +190,7 @@ static void quirk_ad1815_mpu_resources(struct pnp_dev *dev)
 		if (!copy)
 			break;
 
-		memcpy(copy->map, irq->map, sizeof copy->map);
+		bitmap_copy(copy->map.bits, irq->map.bits, PNP_IRQ_NR);
 		copy->flags = irq->flags;
 
 		copy->next = res->irq; /* Yes, this is NULL */

commit aee3ad815dd291a7193ab01da0f1a30c84d00061
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Fri Jun 27 16:56:57 2008 -0600

    PNP: replace pnp_resource_table with dynamically allocated resources
    
    PNP used to have a fixed-size pnp_resource_table for tracking the
    resources used by a device.  This table often overflowed, so we've
    had to increase the table size, which wastes memory because most
    devices have very few resources.
    
    This patch replaces the table with a linked list of resources where
    the entries are allocated on demand.
    
    This removes messages like these:
    
        pnpacpi: exceeded the max number of IO resources
        00:01: too many I/O port resources
    
    References:
    
        http://bugzilla.kernel.org/show_bug.cgi?id=9535
        http://bugzilla.kernel.org/show_bug.cgi?id=9740
        http://lkml.org/lkml/2007/11/30/110
    
    This patch also changes the way PNP uses the IORESOURCE_UNSET,
    IORESOURCE_AUTO, and IORESOURCE_DISABLED flags.
    
    Prior to this patch, the pnp_resource_table entries used the flags
    like this:
    
        IORESOURCE_UNSET
            This table entry is unused and available for use.  When this flag
            is set, we shouldn't look at anything else in the resource structure.
            This flag is set when a resource table entry is initialized.
    
        IORESOURCE_AUTO
            This resource was assigned automatically by pnp_assign_{io,mem,etc}().
    
            This flag is set when a resource table entry is initialized and
            cleared whenever we discover a resource setting by reading an ISAPNP
            config register, parsing a PNPBIOS resource data stream, parsing an
            ACPI _CRS list, or interpreting a sysfs "set" command.
    
            Resources marked IORESOURCE_AUTO are reinitialized and marked as
            IORESOURCE_UNSET by pnp_clean_resource_table() in these cases:
    
                - before we attempt to assign resources automatically,
                - if we fail to assign resources automatically,
                - after disabling a device
    
        IORESOURCE_DISABLED
            Set by pnp_assign_{io,mem,etc}() when automatic assignment fails.
            Also set by PNPBIOS and PNPACPI for:
    
                - invalid IRQs or GSI registration failures
                - invalid DMA channels
                - I/O ports above 0x10000
                - mem ranges with negative length
    
    After this patch, there is no pnp_resource_table, and the resource list
    entries use the flags like this:
    
        IORESOURCE_UNSET
            This flag is no longer used in PNP.  Instead of keeping
            IORESOURCE_UNSET entries in the resource list, we remove
            entries from the list and free them.
    
        IORESOURCE_AUTO
            No change in meaning: it still means the resource was assigned
            automatically by pnp_assign_{port,mem,etc}(), but these functions
            now set the bit explicitly.
    
            We still "clean" a device's resource list in the same places,
            but rather than reinitializing IORESOURCE_AUTO entries, we
            just remove them from the list.
    
            Note that IORESOURCE_AUTO entries are always at the end of the
            list, so removing them doesn't reorder other list entries.
            This is because non-IORESOURCE_AUTO entries are added by the
            ISAPNP, PNPBIOS, or PNPACPI "get resources" methods and by the
            sysfs "set" command.  In each of these cases, we completely free
            the resource list first.
    
        IORESOURCE_DISABLED
            In addition to the cases where we used to set this flag, ISAPNP now
            adds an IORESOURCE_DISABLED resource when it reads a configuration
            register with a "disabled" value.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>
    Signed-off-by: Andi Kleen <ak@linux.intel.com>

diff --git a/drivers/pnp/quirks.c b/drivers/pnp/quirks.c
index 1ff3bb585ab2..21acb54eff6d 100644
--- a/drivers/pnp/quirks.c
+++ b/drivers/pnp/quirks.c
@@ -248,8 +248,7 @@ static void quirk_system_pci_resources(struct pnp_dev *dev)
 			for (j = 0;
 			     (res = pnp_get_resource(dev, IORESOURCE_MEM, j));
 			     j++) {
-				if (res->flags & IORESOURCE_UNSET ||
-				    (res->start == 0 && res->end == 0))
+				if (res->start == 0 && res->end == 0)
 					continue;
 
 				pnp_start = res->start;

commit 4b34fe156455d26ee6ed67b61539f136bf4e439c
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Jun 2 16:42:49 2008 -0600

    PNP: mark resources that conflict with PCI devices "disabled"
    
    Both the PNP/PCI conflict detection quirk and the PNP system
    driver must use the same mechanism to mark resources as disabled.
    
    I think it's best to keep the resource and to keep the type bit
    (IORESOURCE_MEM, etc), so that we match the list from firmware
    as closely as possible.
    
    Fixes this regression from 2.6.25: http://lkml.org/lkml/2008/6/1/82
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Tested-by: Avuton Olrich <avuton@gmail.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pnp/quirks.c b/drivers/pnp/quirks.c
index e2b7de4cb05e..1ff3bb585ab2 100644
--- a/drivers/pnp/quirks.c
+++ b/drivers/pnp/quirks.c
@@ -286,7 +286,7 @@ static void quirk_system_pci_resources(struct pnp_dev *dev)
 					pci_name(pdev), i,
 					(unsigned long long) pci_start,
 					(unsigned long long) pci_end);
-				res->flags = 0;
+				res->flags |= IORESOURCE_DISABLED;
 			}
 		}
 	}

commit a442ac512f36981182e66a427ad05f449ff6593b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu May 15 17:50:37 2008 -0700

    Clean up 'print_fn_descriptor_symbol()' types
    
    Everybody wants to pass it a function pointer, and in fact, that is what
    you _must_ pass it for it to make sense (since it knows that ia64 and
    ppc64 use descriptors for function pointers and fetches the actual
    address from there).
    
    So don't make the argument be a 'unsigned long' and force everybody to
    add a cast.
    
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pnp/quirks.c b/drivers/pnp/quirks.c
index ffdb12a59c40..e2b7de4cb05e 100644
--- a/drivers/pnp/quirks.c
+++ b/drivers/pnp/quirks.c
@@ -331,8 +331,7 @@ void pnp_fixup_device(struct pnp_dev *dev)
 			continue;
 #ifdef DEBUG
 		dev_dbg(&dev->dev, "%s: calling ", f->id);
-		print_fn_descriptor_symbol("%s\n",
-				(unsigned long) f->quirk_function);
+		print_fn_descriptor_symbol("%s\n", f->quirk_function);
 #endif
 		f->quirk_function(dev);
 	}

commit 3b73a223661ed137c5d3d2635f954382e94f5a43
Author: Rene Herman <rene.herman@keyaccess.nl>
Date:   Wed May 14 16:05:36 2008 -0700

    pnp: add ISAPnP MPU option quirks
    
    The AD181x and AZT230 chips don't support an IRQ-less MPU401 option but
    work fine without one.  This adds (priority functional) IRQ-less options
    for each port option to help systems with few available IRQs.
    
    The AD1815 quirk can't use pnp_register_irq_resource() due to doubly
    penalizing the IRQ.  Also, while not a practical issue due to no IRQ
    option being present for the dependents, this needs to add in front, not
    back.
    
    Doesn't use pnp_register_port_resource() for symetry with above.
    
    This does not delete the AD1815 independent option even though it should
    be empty after the IRQ transfer due to AD1816 coming with an empty but
    still present independent option by default.
    
    Was tested on AD1815, AD1816 and AZT2320.  The ALSA snd-ad1818a driver
    also support the AZT2002 ID for MPU401 but this doesn't as I was unable to
    test it.
    
    Signed-off-by: Rene Herman <rene.herman@gmail.com>
    Tested-by: Uwe Bugla <uwe.bugla@gmx.de>
    Acked-by: Uwe Bugla <uwe.bugla@gmx.de>
    Acked-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Cc: Takashi Iwai <tiwai@suse.de>
    Cc: Len Brown <len.brown@intel.com
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pnp/quirks.c b/drivers/pnp/quirks.c
index a1af2f989482..ffdb12a59c40 100644
--- a/drivers/pnp/quirks.c
+++ b/drivers/pnp/quirks.c
@@ -111,6 +111,113 @@ static void quirk_sb16audio_resources(struct pnp_dev *dev)
 		dev_info(&dev->dev, "SB audio device quirk - increased port range\n");
 }
 
+static struct pnp_option *quirk_isapnp_mpu_options(struct pnp_dev *dev)
+{
+	struct pnp_option *head = NULL;
+	struct pnp_option *prev = NULL;
+	struct pnp_option *res;
+
+	/*
+	 * Build a functional IRQ-less variant of each MPU option.
+	 */
+
+	for (res = dev->dependent; res; res = res->next) {
+		struct pnp_option *curr;
+		struct pnp_port *port;
+		struct pnp_port *copy;
+
+		port = res->port;
+		if (!port || !res->irq)
+			continue;
+
+		copy = pnp_alloc(sizeof *copy);
+		if (!copy)
+			break;
+
+		copy->min = port->min;
+		copy->max = port->max;
+		copy->align = port->align;
+		copy->size = port->size;
+		copy->flags = port->flags;
+
+		curr = pnp_build_option(PNP_RES_PRIORITY_FUNCTIONAL);
+		if (!curr) {
+			kfree(copy);
+			break;
+		}
+		curr->port = copy;
+
+		if (prev)
+			prev->next = curr;
+		else
+			head = curr;
+		prev = curr;
+	}
+	if (head)
+		dev_info(&dev->dev, "adding IRQ-less MPU options\n");
+
+	return head;
+}
+
+static void quirk_ad1815_mpu_resources(struct pnp_dev *dev)
+{
+	struct pnp_option *res;
+	struct pnp_irq *irq;
+
+	/*
+	 * Distribute the independent IRQ over the dependent options
+	 */
+
+	res = dev->independent;
+	if (!res)
+		return;
+
+	irq = res->irq;
+	if (!irq || irq->next)
+		return;
+
+	res = dev->dependent;
+	if (!res)
+		return;
+
+	while (1) {
+		struct pnp_irq *copy;
+
+		copy = pnp_alloc(sizeof *copy);
+		if (!copy)
+			break;
+
+		memcpy(copy->map, irq->map, sizeof copy->map);
+		copy->flags = irq->flags;
+
+		copy->next = res->irq; /* Yes, this is NULL */
+		res->irq = copy;
+
+		if (!res->next)
+			break;
+		res = res->next;
+	}
+	kfree(irq);
+
+	res->next = quirk_isapnp_mpu_options(dev);
+
+	res = dev->independent;
+	res->irq = NULL;
+}
+
+static void quirk_isapnp_mpu_resources(struct pnp_dev *dev)
+{
+	struct pnp_option *res;
+
+	res = dev->dependent;
+	if (!res)
+		return;
+
+	while (res->next)
+		res = res->next;
+
+	res->next = quirk_isapnp_mpu_options(dev);
+}
 
 #include <linux/pci.h>
 
@@ -205,6 +312,11 @@ static struct pnp_fixup pnp_fixups[] = {
 	{"CTL0043", quirk_sb16audio_resources},
 	{"CTL0044", quirk_sb16audio_resources},
 	{"CTL0045", quirk_sb16audio_resources},
+	/* Add IRQ-less MPU options */
+	{"ADS7151", quirk_ad1815_mpu_resources},
+	{"ADS7181", quirk_isapnp_mpu_resources},
+	{"AZT0002", quirk_isapnp_mpu_resources},
+	/* PnP resources that might overlap PCI BARs */
 	{"PNP0c01", quirk_system_pci_resources},
 	{"PNP0c02", quirk_system_pci_resources},
 	{""}

commit 726a7a3d17f183bd0f93daff4d56953c6af78c57
Author: Rene Herman <rene.herman@gmail.com>
Date:   Wed May 14 16:05:33 2008 -0700

    pnp: clean up pnp_fixup_device()
    
    Make it look a bit more like pci_fixup_device/pci_do_fixups.  Also print
    the PnP ID and delete the () from the "foo+0x0/0x1234()".
    
    Signed-off-by: Rene Herman <rene.herman@gmail.com>
    Tested-by: Uwe Bugla <uwe.bugla@gmx.de>
    Acked-by: Uwe Bugla <uwe.bugla@gmx.de>
    Acked-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Cc: Takashi Iwai <tiwai@suse.de>
    Cc: Len Brown <len.brown@intel.com
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pnp/quirks.c b/drivers/pnp/quirks.c
index d049a2279fea..a1af2f989482 100644
--- a/drivers/pnp/quirks.c
+++ b/drivers/pnp/quirks.c
@@ -212,20 +212,16 @@ static struct pnp_fixup pnp_fixups[] = {
 
 void pnp_fixup_device(struct pnp_dev *dev)
 {
-	int i = 0;
-	void (*quirk)(struct pnp_dev *);
-
-	while (*pnp_fixups[i].id) {
-		if (compare_pnp_id(dev->id, pnp_fixups[i].id)) {
-			quirk = pnp_fixups[i].quirk_function;
+	struct pnp_fixup *f;
 
+	for (f = pnp_fixups; *f->id; f++) {
+		if (!compare_pnp_id(dev->id, f->id))
+			continue;
 #ifdef DEBUG
-			dev_dbg(&dev->dev, "calling ");
-			print_fn_descriptor_symbol("%s()\n",
-				(unsigned long) *quirk);
+		dev_dbg(&dev->dev, "%s: calling ", f->id);
+		print_fn_descriptor_symbol("%s\n",
+				(unsigned long) f->quirk_function);
 #endif
-			(*quirk)(dev);
-		}
-		i++;
+		f->quirk_function(dev);
 	}
 }

commit 95ab3669f7830682c7762e9c305a0c1dd44454cc
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Apr 28 16:34:26 2008 -0600

    PNP: remove PNP_MAX_* uses
    
    Remove some PNP_MAX_* uses.  The pnp_resource_table isn't
    dynamic yet, but with pnp_get_resource(), we can start moving
    away from the table size constants.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/quirks.c b/drivers/pnp/quirks.c
index c47dd252f449..d049a2279fea 100644
--- a/drivers/pnp/quirks.c
+++ b/drivers/pnp/quirks.c
@@ -138,13 +138,15 @@ static void quirk_system_pci_resources(struct pnp_dev *dev)
 
 			pci_start = pci_resource_start(pdev, i);
 			pci_end = pci_resource_end(pdev, i);
-			for (j = 0; j < PNP_MAX_MEM; j++) {
-				if (!pnp_mem_valid(dev, j) ||
-				    pnp_mem_len(dev, j) == 0)
+			for (j = 0;
+			     (res = pnp_get_resource(dev, IORESOURCE_MEM, j));
+			     j++) {
+				if (res->flags & IORESOURCE_UNSET ||
+				    (res->start == 0 && res->end == 0))
 					continue;
 
-				pnp_start = pnp_mem_start(dev, j);
-				pnp_end = pnp_mem_end(dev, j);
+				pnp_start = res->start;
+				pnp_end = res->end;
 
 				/*
 				 * If the PNP region doesn't overlap the PCI
@@ -177,7 +179,6 @@ static void quirk_system_pci_resources(struct pnp_dev *dev)
 					pci_name(pdev), i,
 					(unsigned long long) pci_start,
 					(unsigned long long) pci_end);
-				res = pnp_get_resource(dev, IORESOURCE_MEM, j);
 				res->flags = 0;
 			}
 		}

commit 53052feb6ddd05cb2b5c6e89fb489bf83bbb6803
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Apr 28 16:34:15 2008 -0600

    PNP: remove pnp_mem_flags() as an lvalue
    
    A future change will change pnp_mem_flags() from a "#define that
    simplifies to an lvalue" to "an inline function that returns the
    flags value."
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Acked-By: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/quirks.c b/drivers/pnp/quirks.c
index e4daf4635c48..c47dd252f449 100644
--- a/drivers/pnp/quirks.c
+++ b/drivers/pnp/quirks.c
@@ -117,6 +117,7 @@ static void quirk_sb16audio_resources(struct pnp_dev *dev)
 static void quirk_system_pci_resources(struct pnp_dev *dev)
 {
 	struct pci_dev *pdev = NULL;
+	struct resource *res;
 	resource_size_t pnp_start, pnp_end, pci_start, pci_end;
 	int i, j;
 
@@ -176,7 +177,8 @@ static void quirk_system_pci_resources(struct pnp_dev *dev)
 					pci_name(pdev), i,
 					(unsigned long long) pci_start,
 					(unsigned long long) pci_end);
-				pnp_mem_flags(dev, j) = 0;
+				res = pnp_get_resource(dev, IORESOURCE_MEM, j);
+				res->flags = 0;
 			}
 		}
 	}

commit 1e3832b0b1518232f47d89bc9d1f68e151a749ff
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Apr 28 02:15:59 2008 -0700

    PNP: use dev_printk for quirk messages
    
    Convert quirk printks to dev_printk().
    
    [akpm@linux-foundation.org: fix warnings, improve output text]
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Cc: Adam Belay <ambx1@neo.rr.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pnp/quirks.c b/drivers/pnp/quirks.c
index 1e8b1b4c09be..e4daf4635c48 100644
--- a/drivers/pnp/quirks.c
+++ b/drivers/pnp/quirks.c
@@ -49,8 +49,11 @@ static void quirk_awe32_resources(struct pnp_dev *dev)
 		port2->max += 0x400;
 		port3->min += 0x800;
 		port3->max += 0x800;
+		dev_info(&dev->dev,
+			"AWE32 quirk - added ioports 0x%lx and 0x%lx\n",
+			(unsigned long)port2->min,
+			(unsigned long)port3->min);
 	}
-	printk(KERN_INFO "pnp: AWE32 quirk - adding two ports\n");
 }
 
 static void quirk_cmi8330_resources(struct pnp_dev *dev)
@@ -73,7 +76,8 @@ static void quirk_cmi8330_resources(struct pnp_dev *dev)
 			    IORESOURCE_DMA_8BIT)
 				dma->map = 0x000A;
 	}
-	printk(KERN_INFO "pnp: CMI8330 quirk - fixing interrupts and dma\n");
+	dev_info(&dev->dev, "CMI8330 quirk - forced possible IRQs to 5, 7, 10 "
+		"and DMA channels to 1, 3\n");
 }
 
 static void quirk_sb16audio_resources(struct pnp_dev *dev)
@@ -104,8 +108,7 @@ static void quirk_sb16audio_resources(struct pnp_dev *dev)
 		changed = 1;
 	}
 	if (changed)
-		printk(KERN_INFO
-		       "pnp: SB audio device quirk - increasing port range\n");
+		dev_info(&dev->dev, "SB audio device quirk - increased port range\n");
 }
 
 

commit b8068162806266552933e395877452de4f2427e7
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Apr 28 02:15:58 2008 -0700

    PNP: simplify quirk debug output
    
    print_fn_descriptor_symbol() prints the address if we don't have a symbol,
    so no need to print both.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pnp/quirks.c b/drivers/pnp/quirks.c
index 37993206ae5d..1e8b1b4c09be 100644
--- a/drivers/pnp/quirks.c
+++ b/drivers/pnp/quirks.c
@@ -214,8 +214,8 @@ void pnp_fixup_device(struct pnp_dev *dev)
 			quirk = pnp_fixups[i].quirk_function;
 
 #ifdef DEBUG
-			dev_dbg(&dev->dev, "calling quirk 0x%p", quirk);
-			print_fn_descriptor_symbol(": %s()\n",
+			dev_dbg(&dev->dev, "calling ");
+			print_fn_descriptor_symbol("%s()\n",
 				(unsigned long) *quirk);
 #endif
 			(*quirk)(dev);

commit 0509ad5e1a7d9220f09edd5be114bf3bd51a7023
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Mar 11 15:24:41 2008 -0600

    PNP: disable PNP motherboard resources that overlap PCI BARs
    
    Some BIOSes have PNP motherboard devices with resources that
    partially overlap PCI BARs.  The PNP system driver claims these
    motherboard resources, which prevents the normal PCI driver from
    requesting them later.
    
    This patch disables the PNP resources that conflict with PCI BARs
    so they won't be claimed by the PNP system driver.
    
    Of course, this only works if PCI devices have already been enumerated.
    Currently this is the case because PCI devices are discovered before
    any PNP init via this path:
    
        acpi_pci_root_init() -> acpi_pci_root_add() -> pci_acpi_scan_root() ->
            pci_scan_bus_parented() -> pci_scan_child_bus() -> ...
    
    Avuton Olrich tested this and confirmed that it fixes his ALSA sound
    card (see http://lkml.org/lkml/2008/1/27/168).
    
    References:
        https://bugzilla.redhat.com/show_bug.cgi?id=280641
        https://bugzilla.redhat.com/show_bug.cgi?id=313491
        http://lkml.org/lkml/2008/1/9/449
        http://thread.gmane.org/gmane.linux.acpi.devel/27312
        http://lkml.org/lkml/2008/1/27/168
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pnp/quirks.c b/drivers/pnp/quirks.c
index e903b8c2b1fa..37993206ae5d 100644
--- a/drivers/pnp/quirks.c
+++ b/drivers/pnp/quirks.c
@@ -108,6 +108,77 @@ static void quirk_sb16audio_resources(struct pnp_dev *dev)
 		       "pnp: SB audio device quirk - increasing port range\n");
 }
 
+
+#include <linux/pci.h>
+
+static void quirk_system_pci_resources(struct pnp_dev *dev)
+{
+	struct pci_dev *pdev = NULL;
+	resource_size_t pnp_start, pnp_end, pci_start, pci_end;
+	int i, j;
+
+	/*
+	 * Some BIOSes have PNP motherboard devices with resources that
+	 * partially overlap PCI BARs.  The PNP system driver claims these
+	 * motherboard resources, which prevents the normal PCI driver from
+	 * requesting them later.
+	 *
+	 * This patch disables the PNP resources that conflict with PCI BARs
+	 * so they won't be claimed by the PNP system driver.
+	 */
+	for_each_pci_dev(pdev) {
+		for (i = 0; i < DEVICE_COUNT_RESOURCE; i++) {
+			if (!(pci_resource_flags(pdev, i) & IORESOURCE_MEM) ||
+			    pci_resource_len(pdev, i) == 0)
+				continue;
+
+			pci_start = pci_resource_start(pdev, i);
+			pci_end = pci_resource_end(pdev, i);
+			for (j = 0; j < PNP_MAX_MEM; j++) {
+				if (!pnp_mem_valid(dev, j) ||
+				    pnp_mem_len(dev, j) == 0)
+					continue;
+
+				pnp_start = pnp_mem_start(dev, j);
+				pnp_end = pnp_mem_end(dev, j);
+
+				/*
+				 * If the PNP region doesn't overlap the PCI
+				 * region at all, there's no problem.
+				 */
+				if (pnp_end < pci_start || pnp_start > pci_end)
+					continue;
+
+				/*
+				 * If the PNP region completely encloses (or is
+				 * at least as large as) the PCI region, that's
+				 * also OK.  For example, this happens when the
+				 * PNP device describes a bridge with PCI
+				 * behind it.
+				 */
+				if (pnp_start <= pci_start &&
+				    pnp_end >= pci_end)
+					continue;
+
+				/*
+				 * Otherwise, the PNP region overlaps *part* of
+				 * the PCI region, and that might prevent a PCI
+				 * driver from requesting its resources.
+				 */
+				dev_warn(&dev->dev, "mem resource "
+					"(0x%llx-0x%llx) overlaps %s BAR %d "
+					"(0x%llx-0x%llx), disabling\n",
+					(unsigned long long) pnp_start,
+					(unsigned long long) pnp_end,
+					pci_name(pdev), i,
+					(unsigned long long) pci_start,
+					(unsigned long long) pci_end);
+				pnp_mem_flags(dev, j) = 0;
+			}
+		}
+	}
+}
+
 /*
  *  PnP Quirks
  *  Cards or devices that need some tweaking due to incomplete resource info
@@ -128,6 +199,8 @@ static struct pnp_fixup pnp_fixups[] = {
 	{"CTL0043", quirk_sb16audio_resources},
 	{"CTL0044", quirk_sb16audio_resources},
 	{"CTL0045", quirk_sb16audio_resources},
+	{"PNP0c01", quirk_system_pci_resources},
+	{"PNP0c02", quirk_system_pci_resources},
 	{""}
 };
 

commit e0aca2330b59752193877da49c6e6b07df78690a
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Mar 11 15:24:40 2008 -0600

    PNP: revert Supermicro H8DCE motherboard quirk
    
    There are other systems with similar problems
    (http://lkml.org/lkml/2008/1/27/168), so we need a more
    generic quirk.  Remove the Supermicro-specific one first.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pnp/quirks.c b/drivers/pnp/quirks.c
index 4065139753b6..e903b8c2b1fa 100644
--- a/drivers/pnp/quirks.c
+++ b/drivers/pnp/quirks.c
@@ -17,7 +17,6 @@
 #include <linux/slab.h>
 #include <linux/pnp.h>
 #include <linux/io.h>
-#include <linux/dmi.h>
 #include <linux/kallsyms.h>
 #include "base.h"
 
@@ -109,46 +108,6 @@ static void quirk_sb16audio_resources(struct pnp_dev *dev)
 		       "pnp: SB audio device quirk - increasing port range\n");
 }
 
-static void quirk_supermicro_h8dce_system(struct pnp_dev *dev)
-{
-	int i;
-	static struct dmi_system_id supermicro_h8dce[] = {
-		{
-			.ident = "Supermicro H8DCE",
-			.matches = {
-				DMI_MATCH(DMI_SYS_VENDOR, "Supermicro"),
-				DMI_MATCH(DMI_PRODUCT_NAME, "H8DCE"),
-			},
-		},
-		{ }
-	};
-
-	if (!dmi_check_system(supermicro_h8dce))
-		return;
-
-	/*
-	 * On the Supermicro H8DCE, there's a system device with resources
-	 * that overlap BAR 6 of the built-in SATA PCI adapter.  If the PNP
-	 * system device claims them, the sata_nv driver won't be able to.
-	 * More details at:
-	 *     https://bugzilla.redhat.com/show_bug.cgi?id=280641
-	 *     https://bugzilla.redhat.com/show_bug.cgi?id=313491
-	 *     http://lkml.org/lkml/2008/1/9/449
-	 *     http://thread.gmane.org/gmane.linux.acpi.devel/27312
-	 */
-	for (i = 0; i < PNP_MAX_MEM; i++) {
-		if (pnp_mem_valid(dev, i) && pnp_mem_len(dev, i) &&
-		    (pnp_mem_start(dev, i) & 0xdfef0000) == 0xdfef0000) {
-			dev_warn(&dev->dev, "disabling 0x%llx-0x%llx to prevent"
-				" conflict with sata_nv PCI device\n",
-				(unsigned long long) pnp_mem_start(dev, i),
-				(unsigned long long) (pnp_mem_start(dev, i) +
-					pnp_mem_len(dev, i) - 1));
-			pnp_mem_flags(dev, i) = 0;
-		}
-	}
-}
-
 /*
  *  PnP Quirks
  *  Cards or devices that need some tweaking due to incomplete resource info
@@ -169,8 +128,6 @@ static struct pnp_fixup pnp_fixups[] = {
 	{"CTL0043", quirk_sb16audio_resources},
 	{"CTL0044", quirk_sb16audio_resources},
 	{"CTL0045", quirk_sb16audio_resources},
-	{"PNP0c01", quirk_supermicro_h8dce_system},
-	{"PNP0c02", quirk_supermicro_h8dce_system},
 	{""}
 };
 

commit 445a1d3e24b806bff01e422f0ddadf68e0eb5d0f
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Wed Feb 6 01:40:08 2008 -0800

    PNP: disable Supermicro H8DCE motherboard resources that overlap SATA BARs
    
    Some Supermicro BIOSes describe a SATA PCI BAR as a motherboard resource.
    The PNP system driver claims motherboard resources, and this prevents the
    sata_nv driver from requesting it later.
    
    This patch disables the PNP0C01/PNP0C02 resources so they won't be claimed
    by the PNP system driver, so they'll available for sata_nv.
    
    This fixes the bugs below, where sata_nv detects only two out of four SATA
    drives.  The signature includes dmesg lines similar to these:
    
      pnp: 00:09: iomem range 0xdfefc000-0xdfefcfff has been reserved
      pnp: 00:09: iomem range 0xdfefd000-0xdfefd3ff has been reserved
      pnp: 00:09: iomem range 0xdfefe000-0xdfefe3ff has been reserved
    
      PCI: Unable to reserve mem region #6:1000@dfefd000 for device 0000:80:07.0
      sata_nv: probe of 0000:80:07.0 failed with error -16
      PCI: Unable to reserve mem region #6:1000@dfefe000 for device 0000:80:08.0
      sata_nv: probe of 0000:80:08.0 failed with error -16
    
    References:
        https://bugzilla.redhat.com/show_bug.cgi?id=280641
        https://bugzilla.redhat.com/show_bug.cgi?id=313491
        http://lkml.org/lkml/2008/1/9/449
        http://thread.gmane.org/gmane.linux.acpi.devel/27312
    
    This is post-2.6.24 material.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pnp/quirks.c b/drivers/pnp/quirks.c
index e903b8c2b1fa..4065139753b6 100644
--- a/drivers/pnp/quirks.c
+++ b/drivers/pnp/quirks.c
@@ -17,6 +17,7 @@
 #include <linux/slab.h>
 #include <linux/pnp.h>
 #include <linux/io.h>
+#include <linux/dmi.h>
 #include <linux/kallsyms.h>
 #include "base.h"
 
@@ -108,6 +109,46 @@ static void quirk_sb16audio_resources(struct pnp_dev *dev)
 		       "pnp: SB audio device quirk - increasing port range\n");
 }
 
+static void quirk_supermicro_h8dce_system(struct pnp_dev *dev)
+{
+	int i;
+	static struct dmi_system_id supermicro_h8dce[] = {
+		{
+			.ident = "Supermicro H8DCE",
+			.matches = {
+				DMI_MATCH(DMI_SYS_VENDOR, "Supermicro"),
+				DMI_MATCH(DMI_PRODUCT_NAME, "H8DCE"),
+			},
+		},
+		{ }
+	};
+
+	if (!dmi_check_system(supermicro_h8dce))
+		return;
+
+	/*
+	 * On the Supermicro H8DCE, there's a system device with resources
+	 * that overlap BAR 6 of the built-in SATA PCI adapter.  If the PNP
+	 * system device claims them, the sata_nv driver won't be able to.
+	 * More details at:
+	 *     https://bugzilla.redhat.com/show_bug.cgi?id=280641
+	 *     https://bugzilla.redhat.com/show_bug.cgi?id=313491
+	 *     http://lkml.org/lkml/2008/1/9/449
+	 *     http://thread.gmane.org/gmane.linux.acpi.devel/27312
+	 */
+	for (i = 0; i < PNP_MAX_MEM; i++) {
+		if (pnp_mem_valid(dev, i) && pnp_mem_len(dev, i) &&
+		    (pnp_mem_start(dev, i) & 0xdfef0000) == 0xdfef0000) {
+			dev_warn(&dev->dev, "disabling 0x%llx-0x%llx to prevent"
+				" conflict with sata_nv PCI device\n",
+				(unsigned long long) pnp_mem_start(dev, i),
+				(unsigned long long) (pnp_mem_start(dev, i) +
+					pnp_mem_len(dev, i) - 1));
+			pnp_mem_flags(dev, i) = 0;
+		}
+	}
+}
+
 /*
  *  PnP Quirks
  *  Cards or devices that need some tweaking due to incomplete resource info
@@ -128,6 +169,8 @@ static struct pnp_fixup pnp_fixups[] = {
 	{"CTL0043", quirk_sb16audio_resources},
 	{"CTL0044", quirk_sb16audio_resources},
 	{"CTL0045", quirk_sb16audio_resources},
+	{"PNP0c01", quirk_supermicro_h8dce_system},
+	{"PNP0c02", quirk_supermicro_h8dce_system},
 	{""}
 };
 

commit a05d0781695566296e74a3670dd5bbd3daf24ae2
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Oct 16 23:31:10 2007 -0700

    PNP: use dev_info(), dev_err(), etc in core
    
    If we have the struct pnp_dev available, we can use dev_info(), dev_err(),
    etc., to give a little more information and consistency.
    
    [akpm@linux-foundation.org: fix warning]
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Cc: Adam Belay <ambx1@neo.rr.com>
    Cc: Len Brown <lenb@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pnp/quirks.c b/drivers/pnp/quirks.c
index 6b0cf0c2a088..e903b8c2b1fa 100644
--- a/drivers/pnp/quirks.c
+++ b/drivers/pnp/quirks.c
@@ -17,6 +17,7 @@
 #include <linux/slab.h>
 #include <linux/pnp.h>
 #include <linux/io.h>
+#include <linux/kallsyms.h>
 #include "base.h"
 
 static void quirk_awe32_resources(struct pnp_dev *dev)
@@ -133,11 +134,18 @@ static struct pnp_fixup pnp_fixups[] = {
 void pnp_fixup_device(struct pnp_dev *dev)
 {
 	int i = 0;
+	void (*quirk)(struct pnp_dev *);
 
 	while (*pnp_fixups[i].id) {
 		if (compare_pnp_id(dev->id, pnp_fixups[i].id)) {
-			pnp_dbg("Calling quirk for %s", dev->dev.bus_id);
-			pnp_fixups[i].quirk_function(dev);
+			quirk = pnp_fixups[i].quirk_function;
+
+#ifdef DEBUG
+			dev_dbg(&dev->dev, "calling quirk 0x%p", quirk);
+			print_fn_descriptor_symbol(": %s()\n",
+				(unsigned long) *quirk);
+#endif
+			(*quirk)(dev);
 		}
 		i++;
 	}

commit b70ae1d9f69ba52767af89f90fd79587669bc7ff
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Sep 11 15:23:35 2007 -0700

    PNP: remove SMCf010 quirk
    
    If the quirk enables the SIR part of the SMCf010 device, the 8250 driver
    may claim it as a legacy ttyS device, which makes the legacy probe in the
    smsc-ircc2 driver fail.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Cc: Andrey Borzenkov <arvidjaar@mail.ru>
    Cc: Michal Piotrowski <michal.k.k.piotrowski@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pnp/quirks.c b/drivers/pnp/quirks.c
index 90755d4cdb9f..6b0cf0c2a088 100644
--- a/drivers/pnp/quirks.c
+++ b/drivers/pnp/quirks.c
@@ -107,108 +107,6 @@ static void quirk_sb16audio_resources(struct pnp_dev *dev)
 		       "pnp: SB audio device quirk - increasing port range\n");
 }
 
-static int quirk_smc_fir_enabled(struct pnp_dev *dev)
-{
-	unsigned long firbase;
-	u8 bank, high, low, chip;
-
-	if (!pnp_port_valid(dev, 1))
-		return 0;
-
-	firbase = pnp_port_start(dev, 1);
-
-	/* Select register bank 3 */
-	bank = inb(firbase + 7);
-	bank &= 0xf0;
-	bank |= 3;
-	outb(bank, firbase + 7);
-
-	high = inb(firbase + 0);
-	low = inb(firbase + 1);
-	chip = inb(firbase + 2);
-
-	/* This corresponds to the check in smsc_ircc_present() */
-	if (high == 0x10 && low == 0xb8 && (chip == 0xf1 || chip == 0xf2))
-		return 1;
-
-	return 0;
-}
-
-static void quirk_smc_enable(struct pnp_dev *dev)
-{
-	struct resource fir, sir, irq;
-
-	pnp_activate_dev(dev);
-	if (quirk_smc_fir_enabled(dev))
-		return;
-
-	/*
-	 * Sometimes the BIOS claims the device is enabled, but it reports
-	 * the wrong FIR resources or doesn't properly configure ISA or LPC
-	 * bridges on the way to the device.
-	 *
-	 * HP nc6000 and nc8000/nw8000 laptops have known problems like
-	 * this.  Fortunately, they do fix things up if we auto-configure
-	 * the device using its _PRS and _SRS methods.
-	 */
-	dev_err(&dev->dev, "%s not responding at SIR 0x%lx, FIR 0x%lx; "
-		"auto-configuring\n", dev->id->id,
-		(unsigned long)pnp_port_start(dev, 0),
-		(unsigned long)pnp_port_start(dev, 1));
-
-	pnp_disable_dev(dev);
-	pnp_init_resource_table(&dev->res);
-	pnp_auto_config_dev(dev);
-	pnp_activate_dev(dev);
-	if (quirk_smc_fir_enabled(dev)) {
-		dev_err(&dev->dev, "responds at SIR 0x%lx, FIR 0x%lx\n",
-			(unsigned long)pnp_port_start(dev, 0),
-			(unsigned long)pnp_port_start(dev, 1));
-		return;
-	}
-
-	/*
-	 * The Toshiba Portege 4000 _CRS reports the FIR region first,
-	 * followed by the SIR region.  The BIOS will configure the bridge,
-	 * but only if we call _SRS with SIR first, then FIR.  It also
-	 * reports the IRQ as active high, when it is really active low.
-	 */
-	dev_err(&dev->dev, "not responding at SIR 0x%lx, FIR 0x%lx; "
-		"swapping SIR/FIR and reconfiguring\n",
-		(unsigned long)pnp_port_start(dev, 0),
-		(unsigned long)pnp_port_start(dev, 1));
-
-	/*
-	 * Clear IORESOURCE_AUTO so pnp_activate_dev() doesn't reassign
-	 * these resources any more.
-	 */
-	fir = dev->res.port_resource[0];
-	sir = dev->res.port_resource[1];
-	fir.flags &= ~IORESOURCE_AUTO;
-	sir.flags &= ~IORESOURCE_AUTO;
-
-	irq = dev->res.irq_resource[0];
-	irq.flags &= ~IORESOURCE_AUTO;
-	irq.flags &= ~IORESOURCE_BITS;
-	irq.flags |= IORESOURCE_IRQ_LOWEDGE;
-
-	pnp_disable_dev(dev);
-	dev->res.port_resource[0] = sir;
-	dev->res.port_resource[1] = fir;
-	dev->res.irq_resource[0] = irq;
-	pnp_activate_dev(dev);
-
-	if (quirk_smc_fir_enabled(dev)) {
-		dev_err(&dev->dev, "responds at SIR 0x%lx, FIR 0x%lx\n",
-			(unsigned long)pnp_port_start(dev, 0),
-			(unsigned long)pnp_port_start(dev, 1));
-		return;
-	}
-
-	dev_err(&dev->dev, "giving up; try \"smsc-ircc2.nopnp\" and "
-		"email bjorn.helgaas@hp.com\n");
-}
-
 /*
  *  PnP Quirks
  *  Cards or devices that need some tweaking due to incomplete resource info
@@ -229,7 +127,6 @@ static struct pnp_fixup pnp_fixups[] = {
 	{"CTL0043", quirk_sb16audio_resources},
 	{"CTL0044", quirk_sb16audio_resources},
 	{"CTL0045", quirk_sb16audio_resources},
-	{"SMCf010", quirk_smc_enable},
 	{""}
 };
 

commit 07d4e9af109221ab731c5aaf832e89776c64b013
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Thu Jul 26 10:41:21 2007 -0700

    PNP: fix up after Lindent
    
    These are manual fixups after running Lindent.  No functional change.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Adam Belay <ambx1@neo.rr.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pnp/quirks.c b/drivers/pnp/quirks.c
index 8e7d7738f296..90755d4cdb9f 100644
--- a/drivers/pnp/quirks.c
+++ b/drivers/pnp/quirks.c
@@ -105,7 +105,6 @@ static void quirk_sb16audio_resources(struct pnp_dev *dev)
 	if (changed)
 		printk(KERN_INFO
 		       "pnp: SB audio device quirk - increasing port range\n");
-	return;
 }
 
 static int quirk_smc_fir_enabled(struct pnp_dev *dev)

commit 9dd78466c956ac4b4f38e12032dc4249ccf57ad1
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Thu Jul 26 10:41:20 2007 -0700

    PNP: Lindent all source files
    
    Run Lindent on all PNP source files.
    
    Produced by:
    
        $ quilt new pnp-lindent
        $ find drivers/pnp -name \*.[ch] | xargs quilt add
        $ quilt add include/linux/{pnp.h,pnpbios.h}
        $ scripts/Lindent drivers/pnp/*.c drivers/pnp/*/*.c include/linux/pnp*.h
        $ quilt refresh --sort
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Adam Belay <ambx1@neo.rr.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pnp/quirks.c b/drivers/pnp/quirks.c
index 7c3236690cc3..8e7d7738f296 100644
--- a/drivers/pnp/quirks.c
+++ b/drivers/pnp/quirks.c
@@ -19,7 +19,6 @@
 #include <linux/io.h>
 #include "base.h"
 
-
 static void quirk_awe32_resources(struct pnp_dev *dev)
 {
 	struct pnp_port *port, *port2, *port3;
@@ -31,7 +30,7 @@ static void quirk_awe32_resources(struct pnp_dev *dev)
 	 * two extra ports (at offset 0x400 and 0x800 from the one given) by
 	 * hand.
 	 */
-	for ( ; res ; res = res->next ) {
+	for (; res; res = res->next) {
 		port2 = pnp_alloc(sizeof(struct pnp_port));
 		if (!port2)
 			return;
@@ -58,18 +57,19 @@ static void quirk_cmi8330_resources(struct pnp_dev *dev)
 	struct pnp_option *res = dev->dependent;
 	unsigned long tmp;
 
-	for ( ; res ; res = res->next ) {
+	for (; res; res = res->next) {
 
 		struct pnp_irq *irq;
 		struct pnp_dma *dma;
 
-		for( irq = res->irq; irq; irq = irq->next ) {	// Valid irqs are 5, 7, 10
+		for (irq = res->irq; irq; irq = irq->next) {	// Valid irqs are 5, 7, 10
 			tmp = 0x04A0;
 			bitmap_copy(irq->map, &tmp, 16);	// 0000 0100 1010 0000
 		}
 
-		for( dma = res->dma; dma; dma = dma->next ) // Valid 8bit dma channels are 1,3
-			if( ( dma->flags & IORESOURCE_DMA_TYPE_MASK ) == IORESOURCE_DMA_8BIT )
+		for (dma = res->dma; dma; dma = dma->next)	// Valid 8bit dma channels are 1,3
+			if ((dma->flags & IORESOURCE_DMA_TYPE_MASK) ==
+			    IORESOURCE_DMA_8BIT)
 				dma->map = 0x000A;
 	}
 	printk(KERN_INFO "pnp: CMI8330 quirk - fixing interrupts and dma\n");
@@ -79,7 +79,7 @@ static void quirk_sb16audio_resources(struct pnp_dev *dev)
 {
 	struct pnp_port *port;
 	struct pnp_option *res = dev->dependent;
-	int    changed = 0;
+	int changed = 0;
 
 	/*
 	 * The default range on the mpu port for these devices is 0x388-0x388.
@@ -87,23 +87,24 @@ static void quirk_sb16audio_resources(struct pnp_dev *dev)
 	 * auto-configured.
 	 */
 
-	for( ; res ; res = res->next ) {
+	for (; res; res = res->next) {
 		port = res->port;
-		if(!port)
+		if (!port)
 			continue;
 		port = port->next;
-		if(!port)
+		if (!port)
 			continue;
 		port = port->next;
-		if(!port)
+		if (!port)
 			continue;
-		if(port->min != port->max)
+		if (port->min != port->max)
 			continue;
 		port->max += 0x70;
 		changed = 1;
 	}
-	if(changed)
-		printk(KERN_INFO "pnp: SB audio device quirk - increasing port range\n");
+	if (changed)
+		printk(KERN_INFO
+		       "pnp: SB audio device quirk - increasing port range\n");
 	return;
 }
 
@@ -124,7 +125,7 @@ static int quirk_smc_fir_enabled(struct pnp_dev *dev)
 	outb(bank, firbase + 7);
 
 	high = inb(firbase + 0);
-	low  = inb(firbase + 1);
+	low = inb(firbase + 1);
 	chip = inb(firbase + 2);
 
 	/* This corresponds to the check in smsc_ircc_present() */
@@ -153,8 +154,8 @@ static void quirk_smc_enable(struct pnp_dev *dev)
 	 */
 	dev_err(&dev->dev, "%s not responding at SIR 0x%lx, FIR 0x%lx; "
 		"auto-configuring\n", dev->id->id,
-		(unsigned long) pnp_port_start(dev, 0),
-		(unsigned long) pnp_port_start(dev, 1));
+		(unsigned long)pnp_port_start(dev, 0),
+		(unsigned long)pnp_port_start(dev, 1));
 
 	pnp_disable_dev(dev);
 	pnp_init_resource_table(&dev->res);
@@ -162,8 +163,8 @@ static void quirk_smc_enable(struct pnp_dev *dev)
 	pnp_activate_dev(dev);
 	if (quirk_smc_fir_enabled(dev)) {
 		dev_err(&dev->dev, "responds at SIR 0x%lx, FIR 0x%lx\n",
-			(unsigned long) pnp_port_start(dev, 0),
-			(unsigned long) pnp_port_start(dev, 1));
+			(unsigned long)pnp_port_start(dev, 0),
+			(unsigned long)pnp_port_start(dev, 1));
 		return;
 	}
 
@@ -175,8 +176,8 @@ static void quirk_smc_enable(struct pnp_dev *dev)
 	 */
 	dev_err(&dev->dev, "not responding at SIR 0x%lx, FIR 0x%lx; "
 		"swapping SIR/FIR and reconfiguring\n",
-		(unsigned long) pnp_port_start(dev, 0),
-		(unsigned long) pnp_port_start(dev, 1));
+		(unsigned long)pnp_port_start(dev, 0),
+		(unsigned long)pnp_port_start(dev, 1));
 
 	/*
 	 * Clear IORESOURCE_AUTO so pnp_activate_dev() doesn't reassign
@@ -200,8 +201,8 @@ static void quirk_smc_enable(struct pnp_dev *dev)
 
 	if (quirk_smc_fir_enabled(dev)) {
 		dev_err(&dev->dev, "responds at SIR 0x%lx, FIR 0x%lx\n",
-			(unsigned long) pnp_port_start(dev, 0),
-			(unsigned long) pnp_port_start(dev, 1));
+			(unsigned long)pnp_port_start(dev, 0),
+			(unsigned long)pnp_port_start(dev, 1));
 		return;
 	}
 
@@ -209,7 +210,6 @@ static void quirk_smc_enable(struct pnp_dev *dev)
 		"email bjorn.helgaas@hp.com\n");
 }
 
-
 /*
  *  PnP Quirks
  *  Cards or devices that need some tweaking due to incomplete resource info
@@ -217,21 +217,21 @@ static void quirk_smc_enable(struct pnp_dev *dev)
 
 static struct pnp_fixup pnp_fixups[] = {
 	/* Soundblaster awe io port quirk */
-	{ "CTL0021", quirk_awe32_resources },
-	{ "CTL0022", quirk_awe32_resources },
-	{ "CTL0023", quirk_awe32_resources },
+	{"CTL0021", quirk_awe32_resources},
+	{"CTL0022", quirk_awe32_resources},
+	{"CTL0023", quirk_awe32_resources},
 	/* CMI 8330 interrupt and dma fix */
-	{ "@X@0001", quirk_cmi8330_resources },
+	{"@X@0001", quirk_cmi8330_resources},
 	/* Soundblaster audio device io port range quirk */
-	{ "CTL0001", quirk_sb16audio_resources },
-	{ "CTL0031", quirk_sb16audio_resources },
-	{ "CTL0041", quirk_sb16audio_resources },
-	{ "CTL0042", quirk_sb16audio_resources },
-	{ "CTL0043", quirk_sb16audio_resources },
-	{ "CTL0044", quirk_sb16audio_resources },
-	{ "CTL0045", quirk_sb16audio_resources },
-	{ "SMCf010", quirk_smc_enable },
-	{ "" }
+	{"CTL0001", quirk_sb16audio_resources},
+	{"CTL0031", quirk_sb16audio_resources},
+	{"CTL0041", quirk_sb16audio_resources},
+	{"CTL0042", quirk_sb16audio_resources},
+	{"CTL0043", quirk_sb16audio_resources},
+	{"CTL0044", quirk_sb16audio_resources},
+	{"CTL0045", quirk_sb16audio_resources},
+	{"SMCf010", quirk_smc_enable},
+	{""}
 };
 
 void pnp_fixup_device(struct pnp_dev *dev)
@@ -239,9 +239,8 @@ void pnp_fixup_device(struct pnp_dev *dev)
 	int i = 0;
 
 	while (*pnp_fixups[i].id) {
-		if (compare_pnp_id(dev->id,pnp_fixups[i].id)) {
-			pnp_dbg("Calling quirk for %s",
-		                  dev->dev.bus_id);
+		if (compare_pnp_id(dev->id, pnp_fixups[i].id)) {
+			pnp_dbg("Calling quirk for %s", dev->dev.bus_id);
 			pnp_fixups[i].quirk_function(dev);
 		}
 		i++;

commit 41a5311465b9de6d18e78b733a2c6e1b33e89be8
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Fri Jul 6 02:39:54 2007 -0700

    PNP SMCf010 quirk: work around Toshiba Portege 4000 ACPI issues
    
    When we enable the SMCf010 IR device, the Toshiba Portege 4000 BIOS claims
    the device is working, but it really isn't configured correctly.  The BIOS
    *will* configure it, but only if we call _SRS after (1) reversing the order
    of the SIR and FIR I/O port regions and (2) changing the IRQ from
    active-high to active-low.
    
    This patch addresses the 2.6.22 regression:
        "no irda0 interface (2.6.21 was OK), smsc does not find chip"
    
    I tested this on a Portege 4000.  The smsc-ircc2 driver correctly detects
    the device, and "irattach irda0 -s && irdadump" shows transmitted and
    received packets.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Cc: Andrey Borzenkov <arvidjaar@mail.ru>
    Cc: Samuel Ortiz <samuel@sortiz.org>
    Cc: "Linus Walleij (LD/EAB)" <linus.walleij@ericsson.com>
    Cc: Michal Piotrowski <michal.k.k.piotrowski@gmail.com>
    Cc: Adam Belay <ambx1@neo.rr.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pnp/quirks.c b/drivers/pnp/quirks.c
index 967a8e22b2da..7c3236690cc3 100644
--- a/drivers/pnp/quirks.c
+++ b/drivers/pnp/quirks.c
@@ -136,11 +136,10 @@ static int quirk_smc_fir_enabled(struct pnp_dev *dev)
 
 static void quirk_smc_enable(struct pnp_dev *dev)
 {
-	/*
-	 * If the BIOS left the device disabled, or it is enabled and
-	 * responding correctly, we're in good shape.
-	 */
-	if (!dev->active || quirk_smc_fir_enabled(dev))
+	struct resource fir, sir, irq;
+
+	pnp_activate_dev(dev);
+	if (quirk_smc_fir_enabled(dev))
 		return;
 
 	/*
@@ -152,16 +151,62 @@ static void quirk_smc_enable(struct pnp_dev *dev)
 	 * this.  Fortunately, they do fix things up if we auto-configure
 	 * the device using its _PRS and _SRS methods.
 	 */
-	dev_err(&dev->dev, "%s device not responding, auto-configuring "
-		"resources\n", dev->id->id);
+	dev_err(&dev->dev, "%s not responding at SIR 0x%lx, FIR 0x%lx; "
+		"auto-configuring\n", dev->id->id,
+		(unsigned long) pnp_port_start(dev, 0),
+		(unsigned long) pnp_port_start(dev, 1));
 
 	pnp_disable_dev(dev);
 	pnp_init_resource_table(&dev->res);
 	pnp_auto_config_dev(dev);
 	pnp_activate_dev(dev);
+	if (quirk_smc_fir_enabled(dev)) {
+		dev_err(&dev->dev, "responds at SIR 0x%lx, FIR 0x%lx\n",
+			(unsigned long) pnp_port_start(dev, 0),
+			(unsigned long) pnp_port_start(dev, 1));
+		return;
+	}
+
+	/*
+	 * The Toshiba Portege 4000 _CRS reports the FIR region first,
+	 * followed by the SIR region.  The BIOS will configure the bridge,
+	 * but only if we call _SRS with SIR first, then FIR.  It also
+	 * reports the IRQ as active high, when it is really active low.
+	 */
+	dev_err(&dev->dev, "not responding at SIR 0x%lx, FIR 0x%lx; "
+		"swapping SIR/FIR and reconfiguring\n",
+		(unsigned long) pnp_port_start(dev, 0),
+		(unsigned long) pnp_port_start(dev, 1));
+
+	/*
+	 * Clear IORESOURCE_AUTO so pnp_activate_dev() doesn't reassign
+	 * these resources any more.
+	 */
+	fir = dev->res.port_resource[0];
+	sir = dev->res.port_resource[1];
+	fir.flags &= ~IORESOURCE_AUTO;
+	sir.flags &= ~IORESOURCE_AUTO;
+
+	irq = dev->res.irq_resource[0];
+	irq.flags &= ~IORESOURCE_AUTO;
+	irq.flags &= ~IORESOURCE_BITS;
+	irq.flags |= IORESOURCE_IRQ_LOWEDGE;
+
+	pnp_disable_dev(dev);
+	dev->res.port_resource[0] = sir;
+	dev->res.port_resource[1] = fir;
+	dev->res.irq_resource[0] = irq;
+	pnp_activate_dev(dev);
+
+	if (quirk_smc_fir_enabled(dev)) {
+		dev_err(&dev->dev, "responds at SIR 0x%lx, FIR 0x%lx\n",
+			(unsigned long) pnp_port_start(dev, 0),
+			(unsigned long) pnp_port_start(dev, 1));
+		return;
+	}
 
-	if (!quirk_smc_fir_enabled(dev))
-		dev_err(&dev->dev, "giving up; try \"smsc-ircc2.nopnp\"\n");
+	dev_err(&dev->dev, "giving up; try \"smsc-ircc2.nopnp\" and "
+		"email bjorn.helgaas@hp.com\n");
 }
 
 

commit 172d0496cd22c98ee2e4238821fa309c01685f3a
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Wed Jun 27 14:09:52 2007 -0700

    PNP SMCf010 quirk: auto-config device if BIOS left it broken
    
    Some HP firmware leaves the SMCf010 IRDA device incompletely configured, or
    reports the wrong resources in _CRS.  As a workaround, when we find such a
    device, try to auto-configure the device.
    
    This ignores the _CRS data, picks a config from _PRS, and runs _SRS to
    configure the device.  This makes smsc-ircc2 work correctly with PNP
    resources (with no preconfiguration!) on all the machines I tested.
    
    I think Windows does something like this by default for all devices,
    so we should consider doing the same thing in Linux.
    
    This patch addresses part of the 2.6.22 regression:
        "no irda0 interface (2.6.21 was OK), smsc does not find chip"
    It fixes smsc-ircc2 PNP device detection on HP nc6000, nc6220, nw8000,
    nw8240, and possibly other machines.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Cc: Samuel Ortiz <samuel@sortiz.org>
    Cc: "Linus Walleij (LD/EAB)" <linus.walleij@ericsson.com>
    Cc: Andrey Borzenkov <arvidjaar@mail.ru>
    Cc: Michal Piotrowski <michal.k.k.piotrowski@gmail.com>
    Cc: Adam Belay <ambx1@neo.rr.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pnp/quirks.c b/drivers/pnp/quirks.c
index 277df50c89ae..967a8e22b2da 100644
--- a/drivers/pnp/quirks.c
+++ b/drivers/pnp/quirks.c
@@ -107,31 +107,61 @@ static void quirk_sb16audio_resources(struct pnp_dev *dev)
 	return;
 }
 
-static void quirk_smc_enable(struct pnp_dev *dev)
+static int quirk_smc_fir_enabled(struct pnp_dev *dev)
 {
-	unsigned int firbase;
+	unsigned long firbase;
+	u8 bank, high, low, chip;
+
+	if (!pnp_port_valid(dev, 1))
+		return 0;
+
+	firbase = pnp_port_start(dev, 1);
+
+	/* Select register bank 3 */
+	bank = inb(firbase + 7);
+	bank &= 0xf0;
+	bank |= 3;
+	outb(bank, firbase + 7);
+
+	high = inb(firbase + 0);
+	low  = inb(firbase + 1);
+	chip = inb(firbase + 2);
+
+	/* This corresponds to the check in smsc_ircc_present() */
+	if (high == 0x10 && low == 0xb8 && (chip == 0xf1 || chip == 0xf2))
+		return 1;
+
+	return 0;
+}
 
-	if (!dev->active || !pnp_port_valid(dev, 1))
+static void quirk_smc_enable(struct pnp_dev *dev)
+{
+	/*
+	 * If the BIOS left the device disabled, or it is enabled and
+	 * responding correctly, we're in good shape.
+	 */
+	if (!dev->active || quirk_smc_fir_enabled(dev))
 		return;
 
 	/*
-	 * On the HP/Compaq nw8240 (and probably other similar machines),
-	 * there is an SMCF010 device with two I/O port regions:
-	 *
-	 *	0x3e8-0x3ef SIR
-	 *	0x100-0x10f FIR
+	 * Sometimes the BIOS claims the device is enabled, but it reports
+	 * the wrong FIR resources or doesn't properly configure ISA or LPC
+	 * bridges on the way to the device.
 	 *
-	 * _STA reports the device is enabled, but in fact, the BIOS
-	 * neglects to enable the FIR range.  Fortunately, it does fully
-	 * enable the device if we call _SRS.
+	 * HP nc6000 and nc8000/nw8000 laptops have known problems like
+	 * this.  Fortunately, they do fix things up if we auto-configure
+	 * the device using its _PRS and _SRS methods.
 	 */
-	firbase = pnp_port_start(dev, 1);
-	if (inb(firbase + 0x7 /* IRCC_MASTER */) == 0xff) {
-		pnp_err("%s (%s) enabled but not responding, disabling and "
-			"re-enabling", dev->dev.bus_id, pnp_dev_name(dev));
-		pnp_disable_dev(dev);
-		pnp_activate_dev(dev);
-	}
+	dev_err(&dev->dev, "%s device not responding, auto-configuring "
+		"resources\n", dev->id->id);
+
+	pnp_disable_dev(dev);
+	pnp_init_resource_table(&dev->res);
+	pnp_auto_config_dev(dev);
+	pnp_activate_dev(dev);
+
+	if (!quirk_smc_fir_enabled(dev))
+		dev_err(&dev->dev, "giving up; try \"smsc-ircc2.nopnp\"\n");
 }
 
 

commit a1e7e636fe9fff531a4fc42e65c8e8416fde5220
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue May 8 00:36:00 2007 -0700

    PNP: workaround HP BIOS defect that leaves SMCF010 device partly enabled
    
    Some HP/Compaq firmware reports via ACPI that the SMCF010 IR device is
    enabled, but in fact, it leaves the device partly disabled.
    
    HP nw8240 BIOS 68DTV Ver.  F.0F, released 9/15/2005 is one BIOS that has this
    problem.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Cc: Keith Owens <kaos@ocs.com.au>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Adam Belay <ambx1@neo.rr.com>
    Cc: Matthieu CASTET <castet.matthieu@free.fr>
    Cc: Jean Tourrilhes <jt@hpl.hp.com>
    Cc: Matthew Garrett <mjg59@srcf.ucam.org>
    Cc: Ville Syrjala <syrjala@sci.fi>
    Cc: Russell King <rmk+serial@arm.linux.org.uk>
    Cc: Samuel Ortiz <samuel@sortiz.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pnp/quirks.c b/drivers/pnp/quirks.c
index e97ecefe8584..277df50c89ae 100644
--- a/drivers/pnp/quirks.c
+++ b/drivers/pnp/quirks.c
@@ -16,6 +16,7 @@
 #include <linux/string.h>
 #include <linux/slab.h>
 #include <linux/pnp.h>
+#include <linux/io.h>
 #include "base.h"
 
 
@@ -106,6 +107,34 @@ static void quirk_sb16audio_resources(struct pnp_dev *dev)
 	return;
 }
 
+static void quirk_smc_enable(struct pnp_dev *dev)
+{
+	unsigned int firbase;
+
+	if (!dev->active || !pnp_port_valid(dev, 1))
+		return;
+
+	/*
+	 * On the HP/Compaq nw8240 (and probably other similar machines),
+	 * there is an SMCF010 device with two I/O port regions:
+	 *
+	 *	0x3e8-0x3ef SIR
+	 *	0x100-0x10f FIR
+	 *
+	 * _STA reports the device is enabled, but in fact, the BIOS
+	 * neglects to enable the FIR range.  Fortunately, it does fully
+	 * enable the device if we call _SRS.
+	 */
+	firbase = pnp_port_start(dev, 1);
+	if (inb(firbase + 0x7 /* IRCC_MASTER */) == 0xff) {
+		pnp_err("%s (%s) enabled but not responding, disabling and "
+			"re-enabling", dev->dev.bus_id, pnp_dev_name(dev));
+		pnp_disable_dev(dev);
+		pnp_activate_dev(dev);
+	}
+}
+
+
 /*
  *  PnP Quirks
  *  Cards or devices that need some tweaking due to incomplete resource info
@@ -126,6 +155,7 @@ static struct pnp_fixup pnp_fixups[] = {
 	{ "CTL0043", quirk_sb16audio_resources },
 	{ "CTL0044", quirk_sb16audio_resources },
 	{ "CTL0045", quirk_sb16audio_resources },
+	{ "SMCf010", quirk_smc_enable },
 	{ "" }
 };
 

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jrn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jrn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/drivers/pnp/quirks.c b/drivers/pnp/quirks.c
index 8936b0cb2ec3..e97ecefe8584 100644
--- a/drivers/pnp/quirks.c
+++ b/drivers/pnp/quirks.c
@@ -11,7 +11,6 @@
  *  Copyright (c) 1999 Martin Mares <mj@ucw.cz>
  */
 
-#include <linux/config.h>
 #include <linux/types.h>
 #include <linux/kernel.h>
 #include <linux/string.h>

commit e139aa595c5d3bd01699530cbe017dec75fdb07f
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Sep 6 15:17:05 2005 -0700

    [PATCH] PNP: make pnp_dbg conditional directly on CONFIG_PNP_DEBUG
    
    Seems pointless to require .c files to test CONFIG_PNP_DEBUG and
    conditionally define DEBUG before including <linux/pnp.h>.  Just test
    CONFIG_PNP_DEBUG directly in pnp.h.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Cc: Adam Belay <ambx1@neo.rr.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/pnp/quirks.c b/drivers/pnp/quirks.c
index 596a02d7e03d..8936b0cb2ec3 100644
--- a/drivers/pnp/quirks.c
+++ b/drivers/pnp/quirks.c
@@ -16,13 +16,6 @@
 #include <linux/kernel.h>
 #include <linux/string.h>
 #include <linux/slab.h>
-
-#ifdef CONFIG_PNP_DEBUG
-	#define DEBUG
-#else
-	#undef DEBUG
-#endif
-
 #include <linux/pnp.h>
 #include "base.h"
 

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/pnp/quirks.c b/drivers/pnp/quirks.c
new file mode 100644
index 000000000000..596a02d7e03d
--- /dev/null
+++ b/drivers/pnp/quirks.c
@@ -0,0 +1,152 @@
+/*
+ *  This file contains quirk handling code for PnP devices
+ *  Some devices do not report all their resources, and need to have extra
+ *  resources added. This is most easily accomplished at initialisation time
+ *  when building up the resource structure for the first time.
+ *
+ *  Copyright (c) 2000 Peter Denison <peterd@pnd-pc.demon.co.uk>
+ *
+ *  Heavily based on PCI quirks handling which is
+ *
+ *  Copyright (c) 1999 Martin Mares <mj@ucw.cz>
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+
+#ifdef CONFIG_PNP_DEBUG
+	#define DEBUG
+#else
+	#undef DEBUG
+#endif
+
+#include <linux/pnp.h>
+#include "base.h"
+
+
+static void quirk_awe32_resources(struct pnp_dev *dev)
+{
+	struct pnp_port *port, *port2, *port3;
+	struct pnp_option *res = dev->dependent;
+
+	/*
+	 * Unfortunately the isapnp_add_port_resource is too tightly bound
+	 * into the PnP discovery sequence, and cannot be used. Link in the
+	 * two extra ports (at offset 0x400 and 0x800 from the one given) by
+	 * hand.
+	 */
+	for ( ; res ; res = res->next ) {
+		port2 = pnp_alloc(sizeof(struct pnp_port));
+		if (!port2)
+			return;
+		port3 = pnp_alloc(sizeof(struct pnp_port));
+		if (!port3) {
+			kfree(port2);
+			return;
+		}
+		port = res->port;
+		memcpy(port2, port, sizeof(struct pnp_port));
+		memcpy(port3, port, sizeof(struct pnp_port));
+		port->next = port2;
+		port2->next = port3;
+		port2->min += 0x400;
+		port2->max += 0x400;
+		port3->min += 0x800;
+		port3->max += 0x800;
+	}
+	printk(KERN_INFO "pnp: AWE32 quirk - adding two ports\n");
+}
+
+static void quirk_cmi8330_resources(struct pnp_dev *dev)
+{
+	struct pnp_option *res = dev->dependent;
+	unsigned long tmp;
+
+	for ( ; res ; res = res->next ) {
+
+		struct pnp_irq *irq;
+		struct pnp_dma *dma;
+
+		for( irq = res->irq; irq; irq = irq->next ) {	// Valid irqs are 5, 7, 10
+			tmp = 0x04A0;
+			bitmap_copy(irq->map, &tmp, 16);	// 0000 0100 1010 0000
+		}
+
+		for( dma = res->dma; dma; dma = dma->next ) // Valid 8bit dma channels are 1,3
+			if( ( dma->flags & IORESOURCE_DMA_TYPE_MASK ) == IORESOURCE_DMA_8BIT )
+				dma->map = 0x000A;
+	}
+	printk(KERN_INFO "pnp: CMI8330 quirk - fixing interrupts and dma\n");
+}
+
+static void quirk_sb16audio_resources(struct pnp_dev *dev)
+{
+	struct pnp_port *port;
+	struct pnp_option *res = dev->dependent;
+	int    changed = 0;
+
+	/*
+	 * The default range on the mpu port for these devices is 0x388-0x388.
+	 * Here we increase that range so that two such cards can be
+	 * auto-configured.
+	 */
+
+	for( ; res ; res = res->next ) {
+		port = res->port;
+		if(!port)
+			continue;
+		port = port->next;
+		if(!port)
+			continue;
+		port = port->next;
+		if(!port)
+			continue;
+		if(port->min != port->max)
+			continue;
+		port->max += 0x70;
+		changed = 1;
+	}
+	if(changed)
+		printk(KERN_INFO "pnp: SB audio device quirk - increasing port range\n");
+	return;
+}
+
+/*
+ *  PnP Quirks
+ *  Cards or devices that need some tweaking due to incomplete resource info
+ */
+
+static struct pnp_fixup pnp_fixups[] = {
+	/* Soundblaster awe io port quirk */
+	{ "CTL0021", quirk_awe32_resources },
+	{ "CTL0022", quirk_awe32_resources },
+	{ "CTL0023", quirk_awe32_resources },
+	/* CMI 8330 interrupt and dma fix */
+	{ "@X@0001", quirk_cmi8330_resources },
+	/* Soundblaster audio device io port range quirk */
+	{ "CTL0001", quirk_sb16audio_resources },
+	{ "CTL0031", quirk_sb16audio_resources },
+	{ "CTL0041", quirk_sb16audio_resources },
+	{ "CTL0042", quirk_sb16audio_resources },
+	{ "CTL0043", quirk_sb16audio_resources },
+	{ "CTL0044", quirk_sb16audio_resources },
+	{ "CTL0045", quirk_sb16audio_resources },
+	{ "" }
+};
+
+void pnp_fixup_device(struct pnp_dev *dev)
+{
+	int i = 0;
+
+	while (*pnp_fixups[i].id) {
+		if (compare_pnp_id(dev->id,pnp_fixups[i].id)) {
+			pnp_dbg("Calling quirk for %s",
+		                  dev->dev.bus_id);
+			pnp_fixups[i].quirk_function(dev);
+		}
+		i++;
+	}
+}
