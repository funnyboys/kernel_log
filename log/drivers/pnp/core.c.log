commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pnp/core.c b/drivers/pnp/core.c
index b54620e53830..3bf18d718975 100644
--- a/drivers/pnp/core.c
+++ b/drivers/pnp/core.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * core.c - contains all core device and protocol registration functions
  *

commit 71150d226564686ef32d15d29edfd18346f6e929
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Mar 18 22:40:04 2015 +0100

    PNP: Avoid leaving unregistered device objects in lists
    
    pnp_register_protocol() and __pnp_add_device() both have a problem
    that if device_register() fails, the objects they create will be left
    in the lists they have been put one beforehand.  Unfortunately, that
    is not handled by the callers of those routines either, so in case
    of a device registration errors the PNP bus type's data structures
    will end up in an inconsistent state.
    
    Make pnp_register_protocol() and __pnp_add_device() remove the
    objects from the lists if device registration fails.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pnp/core.c b/drivers/pnp/core.c
index ef2f59c4e57c..b54620e53830 100644
--- a/drivers/pnp/core.c
+++ b/drivers/pnp/core.c
@@ -42,6 +42,13 @@ void *pnp_alloc(long size)
 	return result;
 }
 
+static void pnp_remove_protocol(struct pnp_protocol *protocol)
+{
+	mutex_lock(&pnp_lock);
+	list_del(&protocol->protocol_list);
+	mutex_unlock(&pnp_lock);
+}
+
 /**
  * pnp_protocol_register - adds a pnp protocol to the pnp layer
  * @protocol: pointer to the corresponding pnp_protocol structure
@@ -50,12 +57,13 @@ void *pnp_alloc(long size)
  */
 int pnp_register_protocol(struct pnp_protocol *protocol)
 {
-	int nodenum;
 	struct list_head *pos;
+	int nodenum, ret;
 
 	INIT_LIST_HEAD(&protocol->devices);
 	INIT_LIST_HEAD(&protocol->cards);
 	nodenum = 0;
+
 	mutex_lock(&pnp_lock);
 
 	/* assign the lowest unused number */
@@ -67,12 +75,18 @@ int pnp_register_protocol(struct pnp_protocol *protocol)
 		}
 	}
 
+	protocol->number = nodenum;
+	dev_set_name(&protocol->dev, "pnp%d", nodenum);
+
 	list_add_tail(&protocol->protocol_list, &pnp_protocols);
+
 	mutex_unlock(&pnp_lock);
 
-	protocol->number = nodenum;
-	dev_set_name(&protocol->dev, "pnp%d", nodenum);
-	return device_register(&protocol->dev);
+	ret = device_register(&protocol->dev);
+	if (ret)
+		pnp_remove_protocol(protocol);
+
+	return ret;
 }
 
 /**
@@ -81,9 +95,7 @@ int pnp_register_protocol(struct pnp_protocol *protocol)
  */
 void pnp_unregister_protocol(struct pnp_protocol *protocol)
 {
-	mutex_lock(&pnp_lock);
-	list_del(&protocol->protocol_list);
-	mutex_unlock(&pnp_lock);
+	pnp_remove_protocol(protocol);
 	device_unregister(&protocol->dev);
 }
 
@@ -158,18 +170,36 @@ struct pnp_dev *pnp_alloc_dev(struct pnp_protocol *protocol, int id,
 	return dev;
 }
 
+static void pnp_delist_device(struct pnp_dev *dev)
+{
+	mutex_lock(&pnp_lock);
+	list_del(&dev->global_list);
+	list_del(&dev->protocol_list);
+	mutex_unlock(&pnp_lock);
+}
+
 int __pnp_add_device(struct pnp_dev *dev)
 {
+	int ret;
+
 	pnp_fixup_device(dev);
 	dev->status = PNP_READY;
+
 	mutex_lock(&pnp_lock);
+
 	list_add_tail(&dev->global_list, &pnp_global);
 	list_add_tail(&dev->protocol_list, &dev->protocol->devices);
+
 	mutex_unlock(&pnp_lock);
-	if (dev->protocol->can_wakeup)
+
+	ret = device_register(&dev->dev);
+	if (ret)
+		pnp_delist_device(dev);
+	else if (dev->protocol->can_wakeup)
 		device_set_wakeup_capable(&dev->dev,
 				dev->protocol->can_wakeup(dev));
-	return device_register(&dev->dev);
+
+	return ret;
 }
 
 /*
@@ -204,10 +234,7 @@ int pnp_add_device(struct pnp_dev *dev)
 
 void __pnp_remove_device(struct pnp_dev *dev)
 {
-	mutex_lock(&pnp_lock);
-	list_del(&dev->global_list);
-	list_del(&dev->protocol_list);
-	mutex_unlock(&pnp_lock);
+	pnp_delist_device(dev);
 	device_unregister(&dev->dev);
 }
 

commit 38f6b38dbb0896511c509fbb6ceabbedbee8e87d
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Mar 18 22:39:55 2015 +0100

    PNP: Convert pnp_lock into a mutex
    
    pnp_lock is a spinlock, but it is only acquired from process context,
    so it may be a mutex just fine.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pnp/core.c b/drivers/pnp/core.c
index cb6ce42f8e77..ef2f59c4e57c 100644
--- a/drivers/pnp/core.c
+++ b/drivers/pnp/core.c
@@ -9,6 +9,7 @@
 #include <linux/list.h>
 #include <linux/device.h>
 #include <linux/module.h>
+#include <linux/mutex.h>
 #include <linux/init.h>
 #include <linux/string.h>
 #include <linux/slab.h>
@@ -19,7 +20,7 @@
 
 static LIST_HEAD(pnp_protocols);
 LIST_HEAD(pnp_global);
-DEFINE_SPINLOCK(pnp_lock);
+DEFINE_MUTEX(pnp_lock);
 
 /*
  * ACPI or PNPBIOS should tell us about all platform devices, so we can
@@ -55,7 +56,7 @@ int pnp_register_protocol(struct pnp_protocol *protocol)
 	INIT_LIST_HEAD(&protocol->devices);
 	INIT_LIST_HEAD(&protocol->cards);
 	nodenum = 0;
-	spin_lock(&pnp_lock);
+	mutex_lock(&pnp_lock);
 
 	/* assign the lowest unused number */
 	list_for_each(pos, &pnp_protocols) {
@@ -67,7 +68,7 @@ int pnp_register_protocol(struct pnp_protocol *protocol)
 	}
 
 	list_add_tail(&protocol->protocol_list, &pnp_protocols);
-	spin_unlock(&pnp_lock);
+	mutex_unlock(&pnp_lock);
 
 	protocol->number = nodenum;
 	dev_set_name(&protocol->dev, "pnp%d", nodenum);
@@ -80,9 +81,9 @@ int pnp_register_protocol(struct pnp_protocol *protocol)
  */
 void pnp_unregister_protocol(struct pnp_protocol *protocol)
 {
-	spin_lock(&pnp_lock);
+	mutex_lock(&pnp_lock);
 	list_del(&protocol->protocol_list);
-	spin_unlock(&pnp_lock);
+	mutex_unlock(&pnp_lock);
 	device_unregister(&protocol->dev);
 }
 
@@ -161,10 +162,10 @@ int __pnp_add_device(struct pnp_dev *dev)
 {
 	pnp_fixup_device(dev);
 	dev->status = PNP_READY;
-	spin_lock(&pnp_lock);
+	mutex_lock(&pnp_lock);
 	list_add_tail(&dev->global_list, &pnp_global);
 	list_add_tail(&dev->protocol_list, &dev->protocol->devices);
-	spin_unlock(&pnp_lock);
+	mutex_unlock(&pnp_lock);
 	if (dev->protocol->can_wakeup)
 		device_set_wakeup_capable(&dev->dev,
 				dev->protocol->can_wakeup(dev));
@@ -203,10 +204,10 @@ int pnp_add_device(struct pnp_dev *dev)
 
 void __pnp_remove_device(struct pnp_dev *dev)
 {
-	spin_lock(&pnp_lock);
+	mutex_lock(&pnp_lock);
 	list_del(&dev->global_list);
 	list_del(&dev->protocol_list);
-	spin_unlock(&pnp_lock);
+	mutex_unlock(&pnp_lock);
 	device_unregister(&dev->dev);
 }
 

commit 6d1f23f204c9e4638bd30ff3a768c47e40cd3ac0
Merge: 633379a0f9f1 cdefba03e44b
Author: Len Brown <len.brown@intel.com>
Date:   Wed Jan 12 04:59:44 2011 -0500

    Merge branch 'pnp' into release

commit cdefba03e44bd3b3311a3849a81ec7030dfa1519
Author: Thomas Renninger <trenn@suse.de>
Date:   Mon Oct 25 21:11:16 2010 +0200

    PNP: Set up pnp_debug via module and not via boot param.
    
    Cleanup only, no functional change (pnp.debug can be enabled
    and disabled at runtime, but that's not a real enhancement).
    
    This one depends on another PNP cleanup patch:
    PNP: Compile all pnp built-in stuff in one module namespace
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/core.c b/drivers/pnp/core.c
index 88b3cde52596..9801918b2726 100644
--- a/drivers/pnp/core.c
+++ b/drivers/pnp/core.c
@@ -218,10 +218,5 @@ subsys_initcall(pnp_init);
 int pnp_debug;
 
 #if defined(CONFIG_PNP_DEBUG_MESSAGES)
-static int __init pnp_debug_setup(char *__unused)
-{
-	pnp_debug = 1;
-	return 1;
-}
-__setup("pnp.debug", pnp_debug_setup);
+module_param_named(debug, pnp_debug, int, 0644);
 #endif

commit 8c654bb80801aeafba071396602c777758604980
Merge: b10b977b792b c1f3f2819667
Author: Len Brown <len.brown@intel.com>
Date:   Mon Oct 25 02:13:48 2010 -0400

    Merge branch 'pnp-log' into release

commit 620e112cfe1c9281c176de8ad1a7691c4eb4950d
Author: Thomas Renninger <trenn@suse.de>
Date:   Fri Oct 1 10:54:00 2010 +0200

    ACPI/PNP: A HID value of an object never changes -> make it const
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/core.c b/drivers/pnp/core.c
index 88b3cde52596..c79ee1ded68d 100644
--- a/drivers/pnp/core.c
+++ b/drivers/pnp/core.c
@@ -124,7 +124,8 @@ static void pnp_release_device(struct device *dmdev)
 	kfree(dev);
 }
 
-struct pnp_dev *pnp_alloc_dev(struct pnp_protocol *protocol, int id, char *pnpid)
+struct pnp_dev *pnp_alloc_dev(struct pnp_protocol *protocol, int id,
+			      const char *pnpid)
 {
 	struct pnp_dev *dev;
 	struct pnp_id *dev_id;

commit c1f3f2819667a238585c65bba96c8b16af39a442
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Wed Sep 29 12:24:23 2010 -0600

    PNP: log PNP resources, as we do for PCI
    
    ACPI devices are often involved in address space conflicts with PCI devices,
    so I think it's worth logging the resources they use.  Otherwise we have to
    depend on lspnp or groping around in sysfs to find them.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/core.c b/drivers/pnp/core.c
index 88b3cde52596..53a8f33e649c 100644
--- a/drivers/pnp/core.c
+++ b/drivers/pnp/core.c
@@ -194,8 +194,9 @@ int pnp_add_device(struct pnp_dev *dev)
 	for (id = dev->id; id; id = id->next)
 		len += scnprintf(buf + len, sizeof(buf) - len, " %s", id->id);
 
-	pnp_dbg(&dev->dev, "%s device, IDs%s (%s)\n",
-		dev->protocol->name, buf, dev->active ? "active" : "disabled");
+	dev_printk(KERN_DEBUG, &dev->dev, "%s device, IDs%s (%s)\n",
+		   dev->protocol->name, buf,
+		   dev->active ? "active" : "disabled");
 	return 0;
 }
 

commit b14e033e17d0ea0ba12668d0d2f371cd31586994
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Jun 29 22:49:24 2010 +0200

    PNPACPI: Add support for remote wakeup
    
    This patch (as1354) adds remote-wakeup support to the pnpacpi driver.
    The new can_wakeup method also allows other PNP protocol drivers
    (pnpbios or iaspnp) to add wakeup support, but I don't know enough
    about how they work to actually do it.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Reviewed-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/pnp/core.c b/drivers/pnp/core.c
index 5dba90995d9e..88b3cde52596 100644
--- a/drivers/pnp/core.c
+++ b/drivers/pnp/core.c
@@ -164,6 +164,9 @@ int __pnp_add_device(struct pnp_dev *dev)
 	list_add_tail(&dev->global_list, &pnp_global);
 	list_add_tail(&dev->protocol_list, &dev->protocol->devices);
 	spin_unlock(&pnp_lock);
+	if (dev->protocol->can_wakeup)
+		device_set_wakeup_capable(&dev->dev,
+				dev->protocol->can_wakeup(dev));
 	return device_register(&dev->dev);
 }
 

commit 2f4f27d42a301ed147e50c2edbcd27bb8990bc8e
Author: Yang Hongyang <yanghy@cn.fujitsu.com>
Date:   Mon Apr 6 19:01:18 2009 -0700

    dma-mapping: replace all DMA_24BIT_MASK macro with DMA_BIT_MASK(24)
    
    Replace all DMA_24BIT_MASK macro with DMA_BIT_MASK(24)
    
    Signed-off-by: Yang Hongyang<yanghy@cn.fujitsu.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pnp/core.c b/drivers/pnp/core.c
index 14814f231739..5dba90995d9e 100644
--- a/drivers/pnp/core.c
+++ b/drivers/pnp/core.c
@@ -137,7 +137,7 @@ struct pnp_dev *pnp_alloc_dev(struct pnp_protocol *protocol, int id, char *pnpid
 	INIT_LIST_HEAD(&dev->options);
 	dev->protocol = protocol;
 	dev->number = id;
-	dev->dma_mask = DMA_24BIT_MASK;
+	dev->dma_mask = DMA_BIT_MASK(24);
 
 	dev->dev.parent = &dev->protocol->dev;
 	dev->dev.bus = &pnp_bus_type;

commit c85e37c51e7feecbe758e16ecaaa55cea1682e47
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Tue Jan 6 10:44:38 2009 -0800

    pnp: struct device - replace bus_id with dev_name(), dev_set_name()
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pnp/core.c b/drivers/pnp/core.c
index 16c01c6fa7c5..14814f231739 100644
--- a/drivers/pnp/core.c
+++ b/drivers/pnp/core.c
@@ -70,7 +70,7 @@ int pnp_register_protocol(struct pnp_protocol *protocol)
 	spin_unlock(&pnp_lock);
 
 	protocol->number = nodenum;
-	sprintf(protocol->dev.bus_id, "pnp%d", nodenum);
+	dev_set_name(&protocol->dev, "pnp%d", nodenum);
 	return device_register(&protocol->dev);
 }
 
@@ -145,8 +145,7 @@ struct pnp_dev *pnp_alloc_dev(struct pnp_protocol *protocol, int id, char *pnpid
 	dev->dev.coherent_dma_mask = dev->dma_mask;
 	dev->dev.release = &pnp_release_device;
 
-	sprintf(dev->dev.bus_id, "%02x:%02x", dev->protocol->number,
-		dev->number);
+	dev_set_name(&dev->dev, "%02x:%02x", dev->protocol->number, dev->number);
 
 	dev_id = pnp_add_id(dev, pnpid);
 	if (!dev_id) {

commit 057316cc6a5b521b332a1d7ccc871cd60c904c74
Merge: 3e2dab9a1c2d 2515ddc6db8e
Author: Len Brown <len.brown@intel.com>
Date:   Wed Oct 22 23:57:26 2008 -0400

    Merge branch 'linus' into test
    
    Conflicts:
            MAINTAINERS
            arch/x86/kernel/acpi/boot.c
            arch/x86/kernel/acpi/sleep.c
            drivers/acpi/Kconfig
            drivers/pnp/Makefile
            drivers/pnp/quirks.c
    
    Signed-off-by: Len Brown <len.brown@intel.com>

commit c813b4e16ead3c3df98ac84419d4df2adf33fe01
Merge: c8d8a2321f9c 02683ffdf655
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Oct 16 12:40:26 2008 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core-2.6
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core-2.6: (46 commits)
      UIO: Fix mapping of logical and virtual memory
      UIO: add automata sercos3 pci card support
      UIO: Change driver name of uio_pdrv
      UIO: Add alignment warnings for uio-mem
      Driver core: add bus_sort_breadthfirst() function
      NET: convert the phy_device file to use bus_find_device_by_name
      kobject: Cleanup kobject_rename and !CONFIG_SYSFS
      kobject: Fix kobject_rename and !CONFIG_SYSFS
      sysfs: Make dir and name args to sysfs_notify() const
      platform: add new device registration helper
      sysfs: use ilookup5() instead of ilookup5_nowait()
      PNP: create device attributes via default device attributes
      Driver core: make bus_find_device_by_name() more robust
      usb: turn dev_warn+WARN_ON combos into dev_WARN
      debug: use dev_WARN() rather than WARN_ON() in device_pm_add()
      debug: Introduce a dev_WARN() function
      sysfs: fix deadlock
      device model: Do a quickcheck for driver binding before doing an expensive check
      Driver core: Fix cleanup in device_create_vargs().
      Driver core: Clarify device cleanup.
      ...

commit a63cc18f02b941662ca5f6c33adca1aa9e8c1a96
Author: Adrian Bunk <bunk@kernel.org>
Date:   Wed Oct 15 22:03:57 2008 -0700

    pnp: remove printk() with outdated version
    
    There's no point in printing some ancient version number forever.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Acked-by: Rene Herman <rene.herman@gmail.com>
    Acked-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Acked-by: Adam M Belay <abelay@MIT.EDU>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pnp/core.c b/drivers/pnp/core.c
index a411582bcd72..cc0aeaed6179 100644
--- a/drivers/pnp/core.c
+++ b/drivers/pnp/core.c
@@ -218,7 +218,6 @@ void __pnp_remove_device(struct pnp_dev *dev)
 
 static int __init pnp_init(void)
 {
-	printk(KERN_INFO "Linux Plug and Play Support v0.97 (c) Adam Belay\n");
 	return bus_register(&pnp_bus_type);
 }
 

commit 8a89efd18aa15bb832778baa4e6eee3857ecada4
Author: Drew Moseley <dmoseley@mvista.com>
Date:   Sun Sep 28 01:31:35 2008 +0200

    PNP: create device attributes via default device attributes
    
    This creates the attributes before the uevent is sent.
    
    Signed-off-by: Drew Moseley <dmoseley@mvista.com>
    Acked-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pnp/core.c b/drivers/pnp/core.c
index a411582bcd72..7d65da821229 100644
--- a/drivers/pnp/core.c
+++ b/drivers/pnp/core.c
@@ -159,21 +159,13 @@ struct pnp_dev *pnp_alloc_dev(struct pnp_protocol *protocol, int id, char *pnpid
 
 int __pnp_add_device(struct pnp_dev *dev)
 {
-	int ret;
-
 	pnp_fixup_device(dev);
 	dev->status = PNP_READY;
 	spin_lock(&pnp_lock);
 	list_add_tail(&dev->global_list, &pnp_global);
 	list_add_tail(&dev->protocol_list, &dev->protocol->devices);
 	spin_unlock(&pnp_lock);
-
-	ret = device_register(&dev->dev);
-	if (ret)
-		return ret;
-
-	pnp_interface_attach_device(dev);
-	return 0;
+	return device_register(&dev->dev);
 }
 
 /*

commit 2f53432c2aedbe79020e44525eb069d9138a01dd
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Aug 19 16:53:47 2008 -0600

    PNP: convert to using pnp_dbg()
    
    pnp_dbg() is equivalent to dev_dbg() except that we can turn it
    on at boot-time with the "pnp.debug" kernel parameter, so we don't
    have to build a new kernel image.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/core.c b/drivers/pnp/core.c
index 61291b5bfe12..521561509a75 100644
--- a/drivers/pnp/core.c
+++ b/drivers/pnp/core.c
@@ -200,7 +200,7 @@ int pnp_add_device(struct pnp_dev *dev)
 	for (id = dev->id; id; id = id->next)
 		len += scnprintf(buf + len, sizeof(buf) - len, " %s", id->id);
 
-	dev_dbg(&dev->dev, "%s device, IDs%s (%s)\n",
+	pnp_dbg(&dev->dev, "%s device, IDs%s (%s)\n",
 		dev->protocol->name, buf, dev->active ? "active" : "disabled");
 	return 0;
 }

commit 97ef062bbe08f46903f29ecdf432be302c977f3b
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Aug 19 16:53:41 2008 -0600

    PNP: add CONFIG_PNP_DEBUG_MESSAGES and pnp_dbg()
    
    This adds the core function pnp_dbg() and a new config option to
    enable it.
    
    The PNP core debugging messages can be enabled at boot-time with the
    "pnp.debug" kernel parameter.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/core.c b/drivers/pnp/core.c
index 7cb1ffc14d4e..61291b5bfe12 100644
--- a/drivers/pnp/core.c
+++ b/drivers/pnp/core.c
@@ -221,3 +221,14 @@ static int __init pnp_init(void)
 }
 
 subsys_initcall(pnp_init);
+
+int pnp_debug;
+
+#if defined(CONFIG_PNP_DEBUG_MESSAGES)
+static int __init pnp_debug_setup(char *__unused)
+{
+	pnp_debug = 1;
+	return 1;
+}
+__setup("pnp.debug", pnp_debug_setup);
+#endif

commit 2663f60d434139298835af690f4891cec5c1e501
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Aug 19 16:53:36 2008 -0600

    PNP: remove some uses of DEBUG ifdef
    
    Use scnprintf() to build up a buffer of PNP IDs to print.  This
    makes the printk atomic and helps get rid of an #ifdef.
    
    Also remove an "#ifdef DEBUG" from some debug functions.  The
    functions only produce debug output, so it's OK to run the
    function and just have the output be dropped at the end.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/core.c b/drivers/pnp/core.c
index a411582bcd72..7cb1ffc14d4e 100644
--- a/drivers/pnp/core.c
+++ b/drivers/pnp/core.c
@@ -185,6 +185,9 @@ int __pnp_add_device(struct pnp_dev *dev)
 int pnp_add_device(struct pnp_dev *dev)
 {
 	int ret;
+	char buf[128];
+	int len = 0;
+	struct pnp_id *id;
 
 	if (dev->card)
 		return -EINVAL;
@@ -193,17 +196,12 @@ int pnp_add_device(struct pnp_dev *dev)
 	if (ret)
 		return ret;
 
-#ifdef CONFIG_PNP_DEBUG
-	{
-		struct pnp_id *id;
+	buf[0] = '\0';
+	for (id = dev->id; id; id = id->next)
+		len += scnprintf(buf + len, sizeof(buf) - len, " %s", id->id);
 
-		dev_printk(KERN_DEBUG, &dev->dev, "%s device, IDs",
-			dev->protocol->name);
-		for (id = dev->id; id; id = id->next)
-			printk(" %s", id->id);
-		printk(" (%s)\n", dev->active ? "active" : "disabled");
-	}
-#endif
+	dev_dbg(&dev->dev, "%s device, IDs%s (%s)\n",
+		dev->protocol->name, buf, dev->active ? "active" : "disabled");
 	return 0;
 }
 

commit 1f32ca31e7409d37c1b25e5f81840fb184380cdf
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Fri Jun 27 16:57:17 2008 -0600

    PNP: convert resource options to single linked list
    
    ISAPNP, PNPBIOS, and ACPI describe the "possible resource settings" of
    a device, i.e., the possibilities an OS bus driver has when it assigns
    I/O port, MMIO, and other resources to the device.
    
    PNP used to maintain this "possible resource setting" information in
    one independent option structure and a list of dependent option
    structures for each device.  Each of these option structures had lists
    of I/O, memory, IRQ, and DMA resources, for example:
    
      dev
        independent options
          ind-io0  -> ind-io1  ...
          ind-mem0 -> ind-mem1 ...
          ...
        dependent option set 0
          dep0-io0  -> dep0-io1  ...
          dep0-mem0 -> dep0-mem1 ...
          ...
        dependent option set 1
          dep1-io0  -> dep1-io1  ...
          dep1-mem0 -> dep1-mem1 ...
          ...
        ...
    
    This data structure was designed for ISAPNP, where the OS configures
    device resource settings by writing directly to configuration
    registers.  The OS can write the registers in arbitrary order much
    like it writes PCI BARs.
    
    However, for PNPBIOS and ACPI devices, the OS uses firmware interfaces
    that perform device configuration, and it is important to pass the
    desired settings to those interfaces in the correct order.  The OS
    learns the correct order by using firmware interfaces that return the
    "current resource settings" and "possible resource settings," but the
    option structures above doesn't store the ordering information.
    
    This patch replaces the independent and dependent lists with a single
    list of options.  For example, a device might have possible resource
    settings like this:
    
      dev
        options
          ind-io0 -> dep0-io0 -> dep1->io0 -> ind-io1 ...
    
    All the possible settings are in the same list, in the order they
    come from the firmware "possible resource settings" list.  Each entry
    is tagged with an independent/dependent flag.  Dependent entries also
    have a "set number" and an optional priority value.  All dependent
    entries must be assigned from the same set.  For example, the OS can
    use all the entries from dependent set 0, or all the entries from
    dependent set 1, but it cannot mix entries from set 0 with entries
    from set 1.
    
    Prior to this patch PNP didn't keep track of the order of this list,
    and it assigned all independent options first, then all dependent
    ones.  Using the example above, that resulted in a "desired
    configuration" list like this:
    
      ind->io0 -> ind->io1 -> depN-io0 ...
    
    instead of the list the firmware expects, which looks like this:
    
      ind->io0 -> depN-io0 -> ind-io1 ...
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Acked-by: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/core.c b/drivers/pnp/core.c
index 7182da92aec3..a411582bcd72 100644
--- a/drivers/pnp/core.c
+++ b/drivers/pnp/core.c
@@ -118,10 +118,9 @@ static void pnp_release_device(struct device *dmdev)
 {
 	struct pnp_dev *dev = to_pnp_dev(dmdev);
 
-	pnp_free_option(dev->independent);
-	pnp_free_option(dev->dependent);
 	pnp_free_ids(dev);
 	pnp_free_resources(dev);
+	pnp_free_options(dev);
 	kfree(dev);
 }
 
@@ -135,6 +134,7 @@ struct pnp_dev *pnp_alloc_dev(struct pnp_protocol *protocol, int id, char *pnpid
 		return NULL;
 
 	INIT_LIST_HEAD(&dev->resources);
+	INIT_LIST_HEAD(&dev->options);
 	dev->protocol = protocol;
 	dev->number = id;
 	dev->dma_mask = DMA_24BIT_MASK;

commit aee3ad815dd291a7193ab01da0f1a30c84d00061
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Fri Jun 27 16:56:57 2008 -0600

    PNP: replace pnp_resource_table with dynamically allocated resources
    
    PNP used to have a fixed-size pnp_resource_table for tracking the
    resources used by a device.  This table often overflowed, so we've
    had to increase the table size, which wastes memory because most
    devices have very few resources.
    
    This patch replaces the table with a linked list of resources where
    the entries are allocated on demand.
    
    This removes messages like these:
    
        pnpacpi: exceeded the max number of IO resources
        00:01: too many I/O port resources
    
    References:
    
        http://bugzilla.kernel.org/show_bug.cgi?id=9535
        http://bugzilla.kernel.org/show_bug.cgi?id=9740
        http://lkml.org/lkml/2007/11/30/110
    
    This patch also changes the way PNP uses the IORESOURCE_UNSET,
    IORESOURCE_AUTO, and IORESOURCE_DISABLED flags.
    
    Prior to this patch, the pnp_resource_table entries used the flags
    like this:
    
        IORESOURCE_UNSET
            This table entry is unused and available for use.  When this flag
            is set, we shouldn't look at anything else in the resource structure.
            This flag is set when a resource table entry is initialized.
    
        IORESOURCE_AUTO
            This resource was assigned automatically by pnp_assign_{io,mem,etc}().
    
            This flag is set when a resource table entry is initialized and
            cleared whenever we discover a resource setting by reading an ISAPNP
            config register, parsing a PNPBIOS resource data stream, parsing an
            ACPI _CRS list, or interpreting a sysfs "set" command.
    
            Resources marked IORESOURCE_AUTO are reinitialized and marked as
            IORESOURCE_UNSET by pnp_clean_resource_table() in these cases:
    
                - before we attempt to assign resources automatically,
                - if we fail to assign resources automatically,
                - after disabling a device
    
        IORESOURCE_DISABLED
            Set by pnp_assign_{io,mem,etc}() when automatic assignment fails.
            Also set by PNPBIOS and PNPACPI for:
    
                - invalid IRQs or GSI registration failures
                - invalid DMA channels
                - I/O ports above 0x10000
                - mem ranges with negative length
    
    After this patch, there is no pnp_resource_table, and the resource list
    entries use the flags like this:
    
        IORESOURCE_UNSET
            This flag is no longer used in PNP.  Instead of keeping
            IORESOURCE_UNSET entries in the resource list, we remove
            entries from the list and free them.
    
        IORESOURCE_AUTO
            No change in meaning: it still means the resource was assigned
            automatically by pnp_assign_{port,mem,etc}(), but these functions
            now set the bit explicitly.
    
            We still "clean" a device's resource list in the same places,
            but rather than reinitializing IORESOURCE_AUTO entries, we
            just remove them from the list.
    
            Note that IORESOURCE_AUTO entries are always at the end of the
            list, so removing them doesn't reorder other list entries.
            This is because non-IORESOURCE_AUTO entries are added by the
            ISAPNP, PNPBIOS, or PNPACPI "get resources" methods and by the
            sysfs "set" command.  In each of these cases, we completely free
            the resource list first.
    
        IORESOURCE_DISABLED
            In addition to the cases where we used to set this flag, ISAPNP now
            adds an IORESOURCE_DISABLED resource when it reads a configuration
            register with a "disabled" value.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>
    Signed-off-by: Andi Kleen <ak@linux.intel.com>

diff --git a/drivers/pnp/core.c b/drivers/pnp/core.c
index 20771b7d4482..7182da92aec3 100644
--- a/drivers/pnp/core.c
+++ b/drivers/pnp/core.c
@@ -99,6 +99,21 @@ static void pnp_free_ids(struct pnp_dev *dev)
 	}
 }
 
+void pnp_free_resource(struct pnp_resource *pnp_res)
+{
+	list_del(&pnp_res->list);
+	kfree(pnp_res);
+}
+
+void pnp_free_resources(struct pnp_dev *dev)
+{
+	struct pnp_resource *pnp_res, *tmp;
+
+	list_for_each_entry_safe(pnp_res, tmp, &dev->resources, list) {
+		pnp_free_resource(pnp_res);
+	}
+}
+
 static void pnp_release_device(struct device *dmdev)
 {
 	struct pnp_dev *dev = to_pnp_dev(dmdev);
@@ -106,7 +121,7 @@ static void pnp_release_device(struct device *dmdev)
 	pnp_free_option(dev->independent);
 	pnp_free_option(dev->dependent);
 	pnp_free_ids(dev);
-	kfree(dev->res);
+	pnp_free_resources(dev);
 	kfree(dev);
 }
 
@@ -119,12 +134,7 @@ struct pnp_dev *pnp_alloc_dev(struct pnp_protocol *protocol, int id, char *pnpid
 	if (!dev)
 		return NULL;
 
-	dev->res = kzalloc(sizeof(struct pnp_resource_table), GFP_KERNEL);
-	if (!dev->res) {
-		kfree(dev);
-		return NULL;
-	}
-
+	INIT_LIST_HEAD(&dev->resources);
 	dev->protocol = protocol;
 	dev->number = id;
 	dev->dma_mask = DMA_24BIT_MASK;
@@ -140,7 +150,6 @@ struct pnp_dev *pnp_alloc_dev(struct pnp_protocol *protocol, int id, char *pnpid
 
 	dev_id = pnp_add_id(dev, pnpid);
 	if (!dev_id) {
-		kfree(dev->res);
 		kfree(dev);
 		return NULL;
 	}

commit 02d83b5da3efa3c278ce87db2637f3dd6837166d
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Apr 28 16:34:28 2008 -0600

    PNP: make pnp_resource_table private to PNP core
    
    There are no remaining references to the PNP_MAX_* constants or
    the pnp_resource_table structure outside of the PNP core.  Make
    them private to the PNP core.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/core.c b/drivers/pnp/core.c
index cf37701a4f9e..20771b7d4482 100644
--- a/drivers/pnp/core.c
+++ b/drivers/pnp/core.c
@@ -106,6 +106,7 @@ static void pnp_release_device(struct device *dmdev)
 	pnp_free_option(dev->independent);
 	pnp_free_option(dev->dependent);
 	pnp_free_ids(dev);
+	kfree(dev->res);
 	kfree(dev);
 }
 
@@ -118,6 +119,12 @@ struct pnp_dev *pnp_alloc_dev(struct pnp_protocol *protocol, int id, char *pnpid
 	if (!dev)
 		return NULL;
 
+	dev->res = kzalloc(sizeof(struct pnp_resource_table), GFP_KERNEL);
+	if (!dev->res) {
+		kfree(dev);
+		return NULL;
+	}
+
 	dev->protocol = protocol;
 	dev->number = id;
 	dev->dma_mask = DMA_24BIT_MASK;
@@ -133,6 +140,7 @@ struct pnp_dev *pnp_alloc_dev(struct pnp_protocol *protocol, int id, char *pnpid
 
 	dev_id = pnp_add_id(dev, pnpid);
 	if (!dev_id) {
+		kfree(dev->res);
 		kfree(dev);
 		return NULL;
 	}

commit bda1e4e5a3d976046378cd495a63e1ee0847deec
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Apr 28 16:33:54 2008 -0600

    PNP: add pnp_alloc_dev()
    
    Add pnp_alloc_dev() to allocate a struct pnp_dev and fill in the
    protocol, instance number, and initial PNP ID.  Now it is always
    valid to use dev_printk() on any pnp_dev pointer.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Acked-By: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/core.c b/drivers/pnp/core.c
index 7d366ca672d3..cf37701a4f9e 100644
--- a/drivers/pnp/core.c
+++ b/drivers/pnp/core.c
@@ -109,15 +109,42 @@ static void pnp_release_device(struct device *dmdev)
 	kfree(dev);
 }
 
-int __pnp_add_device(struct pnp_dev *dev)
+struct pnp_dev *pnp_alloc_dev(struct pnp_protocol *protocol, int id, char *pnpid)
 {
-	int ret;
+	struct pnp_dev *dev;
+	struct pnp_id *dev_id;
 
-	pnp_fixup_device(dev);
+	dev = kzalloc(sizeof(struct pnp_dev), GFP_KERNEL);
+	if (!dev)
+		return NULL;
+
+	dev->protocol = protocol;
+	dev->number = id;
+	dev->dma_mask = DMA_24BIT_MASK;
+
+	dev->dev.parent = &dev->protocol->dev;
 	dev->dev.bus = &pnp_bus_type;
 	dev->dev.dma_mask = &dev->dma_mask;
-	dev->dma_mask = dev->dev.coherent_dma_mask = DMA_24BIT_MASK;
+	dev->dev.coherent_dma_mask = dev->dma_mask;
 	dev->dev.release = &pnp_release_device;
+
+	sprintf(dev->dev.bus_id, "%02x:%02x", dev->protocol->number,
+		dev->number);
+
+	dev_id = pnp_add_id(dev, pnpid);
+	if (!dev_id) {
+		kfree(dev);
+		return NULL;
+	}
+
+	return dev;
+}
+
+int __pnp_add_device(struct pnp_dev *dev)
+{
+	int ret;
+
+	pnp_fixup_device(dev);
 	dev->status = PNP_READY;
 	spin_lock(&pnp_lock);
 	list_add_tail(&dev->global_list, &pnp_global);
@@ -145,9 +172,6 @@ int pnp_add_device(struct pnp_dev *dev)
 	if (dev->card)
 		return -EINVAL;
 
-	dev->dev.parent = &dev->protocol->dev;
-	sprintf(dev->dev.bus_id, "%02x:%02x", dev->protocol->number,
-		dev->number);
 	ret = __pnp_add_device(dev);
 	if (ret)
 		return ret;

commit 348366b963e4e1462c8354827a9cb910aa865bf2
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Oct 16 23:31:12 2007 -0700

    PNP: add debug message for adding new device
    
    Add PNP debug message when adding a device, remove similar PNPACPI message
    with less information.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Cc: Adam Belay <ambx1@neo.rr.com>
    Cc: Len Brown <lenb@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pnp/core.c b/drivers/pnp/core.c
index d5964feb14de..7d366ca672d3 100644
--- a/drivers/pnp/core.c
+++ b/drivers/pnp/core.c
@@ -125,9 +125,11 @@ int __pnp_add_device(struct pnp_dev *dev)
 	spin_unlock(&pnp_lock);
 
 	ret = device_register(&dev->dev);
-	if (ret == 0)
-		pnp_interface_attach_device(dev);
-	return ret;
+	if (ret)
+		return ret;
+
+	pnp_interface_attach_device(dev);
+	return 0;
 }
 
 /*
@@ -138,12 +140,30 @@ int __pnp_add_device(struct pnp_dev *dev)
  */
 int pnp_add_device(struct pnp_dev *dev)
 {
+	int ret;
+
 	if (dev->card)
 		return -EINVAL;
+
 	dev->dev.parent = &dev->protocol->dev;
 	sprintf(dev->dev.bus_id, "%02x:%02x", dev->protocol->number,
 		dev->number);
-	return __pnp_add_device(dev);
+	ret = __pnp_add_device(dev);
+	if (ret)
+		return ret;
+
+#ifdef CONFIG_PNP_DEBUG
+	{
+		struct pnp_id *id;
+
+		dev_printk(KERN_DEBUG, &dev->dev, "%s device, IDs",
+			dev->protocol->name);
+		for (id = dev->id; id; id = id->next)
+			printk(" %s", id->id);
+		printk(" (%s)\n", dev->active ? "active" : "disabled");
+	}
+#endif
+	return 0;
 }
 
 void __pnp_remove_device(struct pnp_dev *dev)

commit b173491339b9ae7f1322241ce6228c1268513a39
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Wed Aug 15 10:32:13 2007 -0600

    PNP: remove null pointer checks
    
    Remove some null pointer checks.  Null pointers in these areas indicate
    programming errors, and I think it's better to oops immediately rather
    than return an error that is easily ignored.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Acked-by: Adam Belay <abelay@novell.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pnp/core.c b/drivers/pnp/core.c
index 61066fdb9e6d..d5964feb14de 100644
--- a/drivers/pnp/core.c
+++ b/drivers/pnp/core.c
@@ -52,9 +52,6 @@ int pnp_register_protocol(struct pnp_protocol *protocol)
 	int nodenum;
 	struct list_head *pos;
 
-	if (!protocol)
-		return -EINVAL;
-
 	INIT_LIST_HEAD(&protocol->devices);
 	INIT_LIST_HEAD(&protocol->cards);
 	nodenum = 0;
@@ -94,8 +91,6 @@ static void pnp_free_ids(struct pnp_dev *dev)
 	struct pnp_id *id;
 	struct pnp_id *next;
 
-	if (!dev)
-		return;
 	id = dev->id;
 	while (id) {
 		next = id->next;
@@ -143,7 +138,7 @@ int __pnp_add_device(struct pnp_dev *dev)
  */
 int pnp_add_device(struct pnp_dev *dev)
 {
-	if (!dev || !dev->protocol || dev->card)
+	if (dev->card)
 		return -EINVAL;
 	dev->dev.parent = &dev->protocol->dev;
 	sprintf(dev->dev.bus_id, "%02x:%02x", dev->protocol->number,

commit 07d4e9af109221ab731c5aaf832e89776c64b013
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Thu Jul 26 10:41:21 2007 -0700

    PNP: fix up after Lindent
    
    These are manual fixups after running Lindent.  No functional change.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Adam Belay <ambx1@neo.rr.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pnp/core.c b/drivers/pnp/core.c
index 1dfdc325211d..61066fdb9e6d 100644
--- a/drivers/pnp/core.c
+++ b/drivers/pnp/core.c
@@ -2,7 +2,6 @@
  * core.c - contains all core device and protocol registration functions
  *
  * Copyright 2002 Adam Belay <ambx1@neo.rr.com>
- *
  */
 
 #include <linux/pnp.h>
@@ -48,7 +47,6 @@ void *pnp_alloc(long size)
  *
  *  Ex protocols: ISAPNP, PNPBIOS, etc
  */
-
 int pnp_register_protocol(struct pnp_protocol *protocol)
 {
 	int nodenum;
@@ -82,7 +80,6 @@ int pnp_register_protocol(struct pnp_protocol *protocol)
 /**
  * pnp_protocol_unregister - removes a pnp protocol from the pnp layer
  * @protocol: pointer to the corresponding pnp_protocol structure
- *
  */
 void pnp_unregister_protocol(struct pnp_protocol *protocol)
 {
@@ -96,6 +93,7 @@ static void pnp_free_ids(struct pnp_dev *dev)
 {
 	struct pnp_id *id;
 	struct pnp_id *next;
+
 	if (!dev)
 		return;
 	id = dev->id;
@@ -109,6 +107,7 @@ static void pnp_free_ids(struct pnp_dev *dev)
 static void pnp_release_device(struct device *dmdev)
 {
 	struct pnp_dev *dev = to_pnp_dev(dmdev);
+
 	pnp_free_option(dev->independent);
 	pnp_free_option(dev->dependent);
 	pnp_free_ids(dev);
@@ -118,6 +117,7 @@ static void pnp_release_device(struct device *dmdev)
 int __pnp_add_device(struct pnp_dev *dev)
 {
 	int ret;
+
 	pnp_fixup_device(dev);
 	dev->dev.bus = &pnp_bus_type;
 	dev->dev.dma_mask = &dev->dma_mask;
@@ -141,7 +141,6 @@ int __pnp_add_device(struct pnp_dev *dev)
  *
  *  adds to driver model, name database, fixups, interface, etc.
  */
-
 int pnp_add_device(struct pnp_dev *dev)
 {
 	if (!dev || !dev->protocol || dev->card)
@@ -161,21 +160,6 @@ void __pnp_remove_device(struct pnp_dev *dev)
 	device_unregister(&dev->dev);
 }
 
-/**
- * pnp_remove_device - removes a pnp device from the pnp layer
- * @dev: pointer to dev to add
- *
- * this function will free all mem used by dev
- */
-#if 0
-void pnp_remove_device(struct pnp_dev *dev)
-{
-	if (!dev || dev->card)
-		return;
-	__pnp_remove_device(dev);
-}
-#endif /*  0  */
-
 static int __init pnp_init(void)
 {
 	printk(KERN_INFO "Linux Plug and Play Support v0.97 (c) Adam Belay\n");
@@ -183,10 +167,3 @@ static int __init pnp_init(void)
 }
 
 subsys_initcall(pnp_init);
-
-#if 0
-EXPORT_SYMBOL(pnp_register_protocol);
-EXPORT_SYMBOL(pnp_unregister_protocol);
-EXPORT_SYMBOL(pnp_add_device);
-EXPORT_SYMBOL(pnp_remove_device);
-#endif /*  0  */

commit 9dd78466c956ac4b4f38e12032dc4249ccf57ad1
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Thu Jul 26 10:41:20 2007 -0700

    PNP: Lindent all source files
    
    Run Lindent on all PNP source files.
    
    Produced by:
    
        $ quilt new pnp-lindent
        $ find drivers/pnp -name \*.[ch] | xargs quilt add
        $ quilt add include/linux/{pnp.h,pnpbios.h}
        $ scripts/Lindent drivers/pnp/*.c drivers/pnp/*/*.c include/linux/pnp*.h
        $ quilt refresh --sort
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Adam Belay <ambx1@neo.rr.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pnp/core.c b/drivers/pnp/core.c
index 8e7b2dd38810..1dfdc325211d 100644
--- a/drivers/pnp/core.c
+++ b/drivers/pnp/core.c
@@ -18,7 +18,6 @@
 
 #include "base.h"
 
-
 static LIST_HEAD(pnp_protocols);
 LIST_HEAD(pnp_global);
 DEFINE_SPINLOCK(pnp_lock);
@@ -36,7 +35,7 @@ void *pnp_alloc(long size)
 	void *result;
 
 	result = kzalloc(size, GFP_KERNEL);
-	if (!result){
+	if (!result) {
 		printk(KERN_ERR "pnp: Out of Memory\n");
 		return NULL;
 	}
@@ -53,7 +52,7 @@ void *pnp_alloc(long size)
 int pnp_register_protocol(struct pnp_protocol *protocol)
 {
 	int nodenum;
-	struct list_head * pos;
+	struct list_head *pos;
 
 	if (!protocol)
 		return -EINVAL;
@@ -64,9 +63,9 @@ int pnp_register_protocol(struct pnp_protocol *protocol)
 	spin_lock(&pnp_lock);
 
 	/* assign the lowest unused number */
-	list_for_each(pos,&pnp_protocols) {
-		struct pnp_protocol * cur = to_pnp_protocol(pos);
-		if (cur->number == nodenum){
+	list_for_each(pos, &pnp_protocols) {
+		struct pnp_protocol *cur = to_pnp_protocol(pos);
+		if (cur->number == nodenum) {
 			pos = &pnp_protocols;
 			nodenum++;
 		}
@@ -93,11 +92,10 @@ void pnp_unregister_protocol(struct pnp_protocol *protocol)
 	device_unregister(&protocol->dev);
 }
 
-
 static void pnp_free_ids(struct pnp_dev *dev)
 {
-	struct pnp_id * id;
-	struct pnp_id * next;
+	struct pnp_id *id;
+	struct pnp_id *next;
 	if (!dev)
 		return;
 	id = dev->id;
@@ -110,7 +108,7 @@ static void pnp_free_ids(struct pnp_dev *dev)
 
 static void pnp_release_device(struct device *dmdev)
 {
-	struct pnp_dev * dev = to_pnp_dev(dmdev);
+	struct pnp_dev *dev = to_pnp_dev(dmdev);
 	pnp_free_option(dev->independent);
 	pnp_free_option(dev->dependent);
 	pnp_free_ids(dev);
@@ -149,7 +147,8 @@ int pnp_add_device(struct pnp_dev *dev)
 	if (!dev || !dev->protocol || dev->card)
 		return -EINVAL;
 	dev->dev.parent = &dev->protocol->dev;
-	sprintf(dev->dev.bus_id, "%02x:%02x", dev->protocol->number, dev->number);
+	sprintf(dev->dev.bus_id, "%02x:%02x", dev->protocol->number,
+		dev->number);
 	return __pnp_add_device(dev);
 }
 
@@ -175,7 +174,7 @@ void pnp_remove_device(struct pnp_dev *dev)
 		return;
 	__pnp_remove_device(dev);
 }
-#endif  /*  0  */
+#endif /*  0  */
 
 static int __init pnp_init(void)
 {
@@ -190,4 +189,4 @@ EXPORT_SYMBOL(pnp_register_protocol);
 EXPORT_SYMBOL(pnp_unregister_protocol);
 EXPORT_SYMBOL(pnp_add_device);
 EXPORT_SYMBOL(pnp_remove_device);
-#endif  /*  0  */
+#endif /*  0  */

commit dd00cc486ab1c17049a535413d1751ef3482141c
Author: Yoann Padioleau <padator@wanadoo.fr>
Date:   Thu Jul 19 01:49:03 2007 -0700

    some kmalloc/memset ->kzalloc (tree wide)
    
    Transform some calls to kmalloc/memset to a single kzalloc (or kcalloc).
    
    Here is a short excerpt of the semantic patch performing
    this transformation:
    
    @@
    type T2;
    expression x;
    identifier f,fld;
    expression E;
    expression E1,E2;
    expression e1,e2,e3,y;
    statement S;
    @@
    
     x =
    - kmalloc
    + kzalloc
      (E1,E2)
      ...  when != \(x->fld=E;\|y=f(...,x,...);\|f(...,x,...);\|x=E;\|while(...) S\|for(e1;e2;e3) S\)
    - memset((T2)x,0,E1);
    
    @@
    expression E1,E2,E3;
    @@
    
    - kzalloc(E1 * E2,E3)
    + kcalloc(E1,E2,E3)
    
    [akpm@linux-foundation.org: get kcalloc args the right way around]
    Signed-off-by: Yoann Padioleau <padator@wanadoo.fr>
    Cc: Richard Henderson <rth@twiddle.net>
    Cc: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
    Acked-by: Russell King <rmk@arm.linux.org.uk>
    Cc: Bryan Wu <bryan.wu@analog.com>
    Acked-by: Jiri Slaby <jirislaby@gmail.com>
    Cc: Dave Airlie <airlied@linux.ie>
    Acked-by: Roland Dreier <rolandd@cisco.com>
    Cc: Jiri Kosina <jkosina@suse.cz>
    Acked-by: Dmitry Torokhov <dtor@mail.ru>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Acked-by: Mauro Carvalho Chehab <mchehab@infradead.org>
    Acked-by: Pierre Ossman <drzeus-list@drzeus.cx>
    Cc: Jeff Garzik <jeff@garzik.org>
    Cc: "David S. Miller" <davem@davemloft.net>
    Acked-by: Greg KH <greg@kroah.com>
    Cc: James Bottomley <James.Bottomley@steeleye.com>
    Cc: "Antonino A. Daplas" <adaplas@pol.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pnp/core.c b/drivers/pnp/core.c
index 3e20b1cc7778..8e7b2dd38810 100644
--- a/drivers/pnp/core.c
+++ b/drivers/pnp/core.c
@@ -35,12 +35,11 @@ void *pnp_alloc(long size)
 {
 	void *result;
 
-	result = kmalloc(size, GFP_KERNEL);
+	result = kzalloc(size, GFP_KERNEL);
 	if (!result){
 		printk(KERN_ERR "pnp: Out of Memory\n");
 		return NULL;
 	}
-	memset(result, 0, size);
 	return result;
 }
 

commit 8f81dd149806bc53c68c92f34d61f88427079039
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue May 8 00:35:54 2007 -0700

    PNP: notice whether we have PNP devices (PNPBIOS or PNPACPI)
    
    This series converts i386 and x86_64 legacy serial ports to be platform
    devices and prevents probing for them if we have PNP.
    
    This prevents double discovery, where a device was found both by the legacy
    probe and by 8250_pnp.
    
    This also prevents the serial driver from claiming IRDA devices (unless they
    have a UART PNP ID).  The serial legacy probe sometimes assumed the wrong IRQ,
    so the user had to use "setserial" to fix it.
    
    Removing the need for setserial to make IRDA devices work seems good, but it
    does break some things.  In particular, you may need to keep setserial from
    poking legacy UART stuff back in by doing something like "dpkg-reconfigure
    setserial" with the "kernel" option.  Otherwise, the setserial-discovered
    "UART" will claim resources and prevent the IRDA driver from loading.
    
    This patch:
    
    If we can discover devices using PNP, we can skip some legacy probes.  This
    flag ("pnp_platform_devices") indicates that PNPBIOS or PNPACPI is enabled and
    should tell us about builtin devices.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Cc: Keith Owens <kaos@ocs.com.au>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Adam Belay <ambx1@neo.rr.com>
    Cc: Matthieu CASTET <castet.matthieu@free.fr>
    Cc: Jean Tourrilhes <jt@hpl.hp.com>
    Cc: Matthew Garrett <mjg59@srcf.ucam.org>
    Cc: Ville Syrjala <syrjala@sci.fi>
    Cc: Russell King <rmk+serial@arm.linux.org.uk>
    Cc: Samuel Ortiz <samuel@sortiz.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pnp/core.c b/drivers/pnp/core.c
index d8d75541552c..3e20b1cc7778 100644
--- a/drivers/pnp/core.c
+++ b/drivers/pnp/core.c
@@ -23,6 +23,14 @@ static LIST_HEAD(pnp_protocols);
 LIST_HEAD(pnp_global);
 DEFINE_SPINLOCK(pnp_lock);
 
+/*
+ * ACPI or PNPBIOS should tell us about all platform devices, so we can
+ * skip some blind probes.  ISAPNP typically enumerates only plug-in ISA
+ * devices, not built-in things like COM ports.
+ */
+int pnp_platform_devices;
+EXPORT_SYMBOL(pnp_platform_devices);
+
 void *pnp_alloc(long size)
 {
 	void *result;

commit 2e17c5508fa015f2c7690e29041f437e9308c64f
Author: David Brownell <david-b@pacbell.net>
Date:   Tue May 8 00:25:29 2007 -0700

    init dma masks in pnp_dev
    
    PNP now initializes device dma masks, which prevents oopses when generic
    dma calls are made using pnp device nodes.
    
    This assumes PNP only uses ISA DMA, with 24 bit addresses; and that it's
    safe to init those masks for all devices (rather than finding out which
    devices have been assigned DMA channels, and handling only those).
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Cc: Adam Belay <abelay@novell.com>
    Cc: Jaroslav Kysela <perex@suse.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pnp/core.c b/drivers/pnp/core.c
index aec83ec5ea23..d8d75541552c 100644
--- a/drivers/pnp/core.c
+++ b/drivers/pnp/core.c
@@ -14,6 +14,7 @@
 #include <linux/string.h>
 #include <linux/slab.h>
 #include <linux/errno.h>
+#include <linux/dma-mapping.h>
 
 #include "base.h"
 
@@ -114,6 +115,8 @@ int __pnp_add_device(struct pnp_dev *dev)
 	int ret;
 	pnp_fixup_device(dev);
 	dev->dev.bus = &pnp_bus_type;
+	dev->dev.dma_mask = &dev->dma_mask;
+	dev->dma_mask = dev->dev.coherent_dma_mask = DMA_24BIT_MASK;
 	dev->dev.release = &pnp_release_device;
 	dev->status = PNP_READY;
 	spin_lock(&pnp_lock);

commit b449f63c8ce4a517cb91f237cc3d68d083ec2dd3
Author: Adrian Bunk <bunk@stusta.de>
Date:   Mon Nov 7 01:01:48 2005 -0800

    [PATCH] drivers/pnp/: cleanups
    
    This patch contains the following possible cleanups:
    - make needlessly global code static
    - #if 0 the following unused global function:
      - core.c: pnp_remove_device
    - #if 0 the following unneeded EXPORT_SYMBOL's:
      - card.c: pnp_add_card
      - card.c: pnp_remove_card
      - card.c: pnp_add_card_device
      - card.c: pnp_remove_card_device
      - card.c: pnp_add_card_id
      - core.c: pnp_register_protocol
      - core.c: pnp_unregister_protocol
      - core.c: pnp_add_device
      - core.c: pnp_remove_device
      - pnpacpi/core.c: pnpacpi_protocol
      - driver.c: pnp_add_id
      - isapnp/core.c: isapnp_read_byte
      - manager.c: pnp_auto_config_dev
      - resource.c: pnp_register_dependent_option
      - resource.c: pnp_register_independent_option
      - resource.c: pnp_register_irq_resource
      - resource.c: pnp_register_dma_resource
      - resource.c: pnp_register_port_resource
      - resource.c: pnp_register_mem_resource
    
    Note that this patch #if 0's exactly one functions and removes no
    functions.  Most it does is the #if 0 of EXPORT_SYMBOL's, so if any modular
    code will use any of them, re-adding will be trivial.
    
    Modular ISAPnP might be interesting in some cases, but this is more legacy
    code.  If someone would work on it to sort all the issues out (starting
    with the point that most users of __ISAPNP__ will have to be fixed)
    re-enabling the required EXPORT_SYMBOL's won't be hard for him.
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Cc: Adam Belay <ambx1@neo.rr.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/pnp/core.c b/drivers/pnp/core.c
index deed92459bc5..aec83ec5ea23 100644
--- a/drivers/pnp/core.c
+++ b/drivers/pnp/core.c
@@ -158,13 +158,14 @@ void __pnp_remove_device(struct pnp_dev *dev)
  *
  * this function will free all mem used by dev
  */
-
+#if 0
 void pnp_remove_device(struct pnp_dev *dev)
 {
 	if (!dev || dev->card)
 		return;
 	__pnp_remove_device(dev);
 }
+#endif  /*  0  */
 
 static int __init pnp_init(void)
 {
@@ -174,7 +175,9 @@ static int __init pnp_init(void)
 
 subsys_initcall(pnp_init);
 
+#if 0
 EXPORT_SYMBOL(pnp_register_protocol);
 EXPORT_SYMBOL(pnp_unregister_protocol);
 EXPORT_SYMBOL(pnp_add_device);
 EXPORT_SYMBOL(pnp_remove_device);
+#endif  /*  0  */

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/pnp/core.c b/drivers/pnp/core.c
new file mode 100644
index 000000000000..deed92459bc5
--- /dev/null
+++ b/drivers/pnp/core.c
@@ -0,0 +1,180 @@
+/*
+ * core.c - contains all core device and protocol registration functions
+ *
+ * Copyright 2002 Adam Belay <ambx1@neo.rr.com>
+ *
+ */
+
+#include <linux/pnp.h>
+#include <linux/types.h>
+#include <linux/list.h>
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+
+#include "base.h"
+
+
+static LIST_HEAD(pnp_protocols);
+LIST_HEAD(pnp_global);
+DEFINE_SPINLOCK(pnp_lock);
+
+void *pnp_alloc(long size)
+{
+	void *result;
+
+	result = kmalloc(size, GFP_KERNEL);
+	if (!result){
+		printk(KERN_ERR "pnp: Out of Memory\n");
+		return NULL;
+	}
+	memset(result, 0, size);
+	return result;
+}
+
+/**
+ * pnp_protocol_register - adds a pnp protocol to the pnp layer
+ * @protocol: pointer to the corresponding pnp_protocol structure
+ *
+ *  Ex protocols: ISAPNP, PNPBIOS, etc
+ */
+
+int pnp_register_protocol(struct pnp_protocol *protocol)
+{
+	int nodenum;
+	struct list_head * pos;
+
+	if (!protocol)
+		return -EINVAL;
+
+	INIT_LIST_HEAD(&protocol->devices);
+	INIT_LIST_HEAD(&protocol->cards);
+	nodenum = 0;
+	spin_lock(&pnp_lock);
+
+	/* assign the lowest unused number */
+	list_for_each(pos,&pnp_protocols) {
+		struct pnp_protocol * cur = to_pnp_protocol(pos);
+		if (cur->number == nodenum){
+			pos = &pnp_protocols;
+			nodenum++;
+		}
+	}
+
+	list_add_tail(&protocol->protocol_list, &pnp_protocols);
+	spin_unlock(&pnp_lock);
+
+	protocol->number = nodenum;
+	sprintf(protocol->dev.bus_id, "pnp%d", nodenum);
+	return device_register(&protocol->dev);
+}
+
+/**
+ * pnp_protocol_unregister - removes a pnp protocol from the pnp layer
+ * @protocol: pointer to the corresponding pnp_protocol structure
+ *
+ */
+void pnp_unregister_protocol(struct pnp_protocol *protocol)
+{
+	spin_lock(&pnp_lock);
+	list_del(&protocol->protocol_list);
+	spin_unlock(&pnp_lock);
+	device_unregister(&protocol->dev);
+}
+
+
+static void pnp_free_ids(struct pnp_dev *dev)
+{
+	struct pnp_id * id;
+	struct pnp_id * next;
+	if (!dev)
+		return;
+	id = dev->id;
+	while (id) {
+		next = id->next;
+		kfree(id);
+		id = next;
+	}
+}
+
+static void pnp_release_device(struct device *dmdev)
+{
+	struct pnp_dev * dev = to_pnp_dev(dmdev);
+	pnp_free_option(dev->independent);
+	pnp_free_option(dev->dependent);
+	pnp_free_ids(dev);
+	kfree(dev);
+}
+
+int __pnp_add_device(struct pnp_dev *dev)
+{
+	int ret;
+	pnp_fixup_device(dev);
+	dev->dev.bus = &pnp_bus_type;
+	dev->dev.release = &pnp_release_device;
+	dev->status = PNP_READY;
+	spin_lock(&pnp_lock);
+	list_add_tail(&dev->global_list, &pnp_global);
+	list_add_tail(&dev->protocol_list, &dev->protocol->devices);
+	spin_unlock(&pnp_lock);
+
+	ret = device_register(&dev->dev);
+	if (ret == 0)
+		pnp_interface_attach_device(dev);
+	return ret;
+}
+
+/*
+ * pnp_add_device - adds a pnp device to the pnp layer
+ * @dev: pointer to dev to add
+ *
+ *  adds to driver model, name database, fixups, interface, etc.
+ */
+
+int pnp_add_device(struct pnp_dev *dev)
+{
+	if (!dev || !dev->protocol || dev->card)
+		return -EINVAL;
+	dev->dev.parent = &dev->protocol->dev;
+	sprintf(dev->dev.bus_id, "%02x:%02x", dev->protocol->number, dev->number);
+	return __pnp_add_device(dev);
+}
+
+void __pnp_remove_device(struct pnp_dev *dev)
+{
+	spin_lock(&pnp_lock);
+	list_del(&dev->global_list);
+	list_del(&dev->protocol_list);
+	spin_unlock(&pnp_lock);
+	device_unregister(&dev->dev);
+}
+
+/**
+ * pnp_remove_device - removes a pnp device from the pnp layer
+ * @dev: pointer to dev to add
+ *
+ * this function will free all mem used by dev
+ */
+
+void pnp_remove_device(struct pnp_dev *dev)
+{
+	if (!dev || dev->card)
+		return;
+	__pnp_remove_device(dev);
+}
+
+static int __init pnp_init(void)
+{
+	printk(KERN_INFO "Linux Plug and Play Support v0.97 (c) Adam Belay\n");
+	return bus_register(&pnp_bus_type);
+}
+
+subsys_initcall(pnp_init);
+
+EXPORT_SYMBOL(pnp_register_protocol);
+EXPORT_SYMBOL(pnp_unregister_protocol);
+EXPORT_SYMBOL(pnp_add_device);
+EXPORT_SYMBOL(pnp_remove_device);
