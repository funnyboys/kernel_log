commit a86d6df84ae6eb1fd1ca6cbd03f16637674a6af8
Author: Sean Young <sean@mess.org>
Date:   Fri Mar 23 16:47:37 2018 -0400

    media: rc: set timeout to smallest value required by enabled protocols
    
    The longer the IR timeout, the longer the rc device waits until delivering
    the trailing space. So, by reducing this timeout, we reduce the delay for
    the last scancode to be delivered.
    
    Note that the lirc daemon disables all protocols, in which case we revert
    back to the default value.
    
    Signed-off-by: Sean Young <sean@mess.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/rc/ir-nec-decoder.c b/drivers/media/rc/ir-nec-decoder.c
index 21647b809e6f..6a8973ae3684 100644
--- a/drivers/media/rc/ir-nec-decoder.c
+++ b/drivers/media/rc/ir-nec-decoder.c
@@ -253,6 +253,7 @@ static struct ir_raw_handler nec_handler = {
 	.decode		= ir_nec_decode,
 	.encode		= ir_nec_encode,
 	.carrier	= 38000,
+	.min_timeout	= NEC_TRAILER_SPACE,
 };
 
 static int __init ir_nec_decode_init(void)

commit 50078a903830796a8a47f26edc4cc10b9061711f
Author: Sean Young <sean@mess.org>
Date:   Mon Feb 12 07:20:52 2018 -0500

    media: rc: replace IR_dprintk() with dev_dbg in IR decoders
    
    Use dev_dbg() rather than custom debug function.
    
    Signed-off-by: Sean Young <sean@mess.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/rc/ir-nec-decoder.c b/drivers/media/rc/ir-nec-decoder.c
index 31d7bafe7bda..21647b809e6f 100644
--- a/drivers/media/rc/ir-nec-decoder.c
+++ b/drivers/media/rc/ir-nec-decoder.c
@@ -49,8 +49,8 @@ static int ir_nec_decode(struct rc_dev *dev, struct ir_raw_event ev)
 		return 0;
 	}
 
-	IR_dprintk(2, "NEC decode started at state %d (%uus %s)\n",
-		   data->state, TO_US(ev.duration), TO_STR(ev.pulse));
+	dev_dbg(&dev->dev, "NEC decode started at state %d (%uus %s)\n",
+		data->state, TO_US(ev.duration), TO_STR(ev.pulse));
 
 	switch (data->state) {
 
@@ -99,13 +99,11 @@ static int ir_nec_decode(struct rc_dev *dev, struct ir_raw_event ev)
 			break;
 
 		if (data->necx_repeat && data->count == NECX_REPEAT_BITS &&
-			geq_margin(ev.duration,
-			NEC_TRAILER_SPACE, NEC_UNIT / 2)) {
-				IR_dprintk(1, "Repeat last key\n");
-				rc_repeat(dev);
-				data->state = STATE_INACTIVE;
-				return 0;
-
+		    geq_margin(ev.duration, NEC_TRAILER_SPACE, NEC_UNIT / 2)) {
+			dev_dbg(&dev->dev, "Repeat last key\n");
+			rc_repeat(dev);
+			data->state = STATE_INACTIVE;
+			return 0;
 		} else if (data->count > NECX_REPEAT_BITS)
 			data->necx_repeat = false;
 
@@ -164,8 +162,8 @@ static int ir_nec_decode(struct rc_dev *dev, struct ir_raw_event ev)
 		return 0;
 	}
 
-	IR_dprintk(1, "NEC decode failed at count %d state %d (%uus %s)\n",
-		   data->count, data->state, TO_US(ev.duration), TO_STR(ev.pulse));
+	dev_dbg(&dev->dev, "NEC decode failed at count %d state %d (%uus %s)\n",
+		data->count, data->state, TO_US(ev.duration), TO_STR(ev.pulse));
 	data->state = STATE_INACTIVE;
 	return -EINVAL;
 }

commit cdfaa01c1cfeb828e6d3c0c5e4f54375fc3ccb95
Author: Sean Young <sean@mess.org>
Date:   Sat Feb 25 06:51:30 2017 -0500

    media: lirc: use the correct carrier for scancode transmit
    
    If the lirc device supports it, set the carrier for the protocol.
    
    Signed-off-by: Sean Young <sean@mess.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/rc/ir-nec-decoder.c b/drivers/media/rc/ir-nec-decoder.c
index 22eed9505244..31d7bafe7bda 100644
--- a/drivers/media/rc/ir-nec-decoder.c
+++ b/drivers/media/rc/ir-nec-decoder.c
@@ -254,6 +254,7 @@ static struct ir_raw_handler nec_handler = {
 							RC_PROTO_BIT_NEC32,
 	.decode		= ir_nec_decode,
 	.encode		= ir_nec_encode,
+	.carrier	= 38000,
 };
 
 static int __init ir_nec_decode_init(void)

commit 20835280ce0495f933bc8a69f2faac31f23daa2f
Author: Mauro Carvalho Chehab <mchehab@s-opensource.com>
Date:   Fri Dec 1 08:47:08 2017 -0500

    media: rc: add SPDX identifiers to the code I wrote
    
    As we're now using SPDX identifiers, on the several
    media drivers I wrote, add the proper SPDX, identifying
    the license I meant.
    
    As we're now using the short license, it doesn't make sense to
    keep the original license text.
    
    Also, fix MODULE_LICENSE to properly identify GPL v2.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/rc/ir-nec-decoder.c b/drivers/media/rc/ir-nec-decoder.c
index 6880c190dcd2..22eed9505244 100644
--- a/drivers/media/rc/ir-nec-decoder.c
+++ b/drivers/media/rc/ir-nec-decoder.c
@@ -1,16 +1,7 @@
-/* ir-nec-decoder.c - handle NEC IR Pulse/Space protocol
- *
- * Copyright (C) 2010 by Mauro Carvalho Chehab
- *
- * This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation version 2 of the License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- */
+// SPDX-License-Identifier: GPL-2.0
+// ir-nec-decoder.c - handle NEC IR Pulse/Space protocol
+//
+// Copyright (C) 2010 by Mauro Carvalho Chehab
 
 #include <linux/bitrev.h>
 #include <linux/module.h>
@@ -281,7 +272,7 @@ static void __exit ir_nec_decode_exit(void)
 module_init(ir_nec_decode_init);
 module_exit(ir_nec_decode_exit);
 
-MODULE_LICENSE("GPL");
+MODULE_LICENSE("GPL v2");
 MODULE_AUTHOR("Mauro Carvalho Chehab");
 MODULE_AUTHOR("Red Hat Inc. (http://www.redhat.com)");
 MODULE_DESCRIPTION("NEC IR protocol decoder");

commit 64dc6829a0080e3c8e70d52a98e9b0e30d968bd8
Author: Mauro Carvalho Chehab <mchehab@s-opensource.com>
Date:   Mon Nov 27 10:23:07 2017 -0500

    media: ir-nec-decoder: fix kernel-doc parameters
    
    Some parameters aren't correctly identified, as noticed by
    those warnings:
            drivers/media/rc/ir-nec-decoder.c:49: warning: No description found for parameter 'ev'
            drivers/media/rc/ir-nec-decoder.c:49: warning: Excess function parameter 'duration' description in 'ir_nec_decode'
            drivers/media/rc/ir-nec-decoder.c:189: warning: Excess function parameter 'raw' description in 'ir_nec_scancode_to_raw'
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/rc/ir-nec-decoder.c b/drivers/media/rc/ir-nec-decoder.c
index a95d09acc22a..6880c190dcd2 100644
--- a/drivers/media/rc/ir-nec-decoder.c
+++ b/drivers/media/rc/ir-nec-decoder.c
@@ -41,7 +41,7 @@ enum nec_state {
 /**
  * ir_nec_decode() - Decode one NEC pulse or space
  * @dev:	the struct rc_dev descriptor of the device
- * @duration:	the struct ir_raw_event descriptor of the pulse/space
+ * @ev:		the struct ir_raw_event descriptor of the pulse/space
  *
  * This function returns -EINVAL if the pulse violates the state machine
  */
@@ -183,7 +183,6 @@ static int ir_nec_decode(struct rc_dev *dev, struct ir_raw_event ev)
  * ir_nec_scancode_to_raw() - encode an NEC scancode ready for modulation.
  * @protocol:	specific protocol to use
  * @scancode:	a single NEC scancode.
- * @raw:	raw data to be modulated.
  */
 static u32 ir_nec_scancode_to_raw(enum rc_proto protocol, u32 scancode)
 {

commit 829bbf268894d0866bb9dd2b1e430cfa5c5f0779
Author: Sean Young <sean@mess.org>
Date:   Sun Oct 1 16:38:29 2017 -0400

    media: rc: nec decoder should not send both repeat and keycode
    
    When receiving an nec repeat, rc_repeat() is called and then rc_keydown()
    with the last decoded scancode. That last call is redundant.
    
    Fixes: 265a2988d202 ("media: rc-core: consistent use of rc_repeat()")
    
    Cc: <stable@vger.kernel.org> # v4.14
    Signed-off-by: Sean Young <sean@mess.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/rc/ir-nec-decoder.c b/drivers/media/rc/ir-nec-decoder.c
index 817c18f2ddd1..a95d09acc22a 100644
--- a/drivers/media/rc/ir-nec-decoder.c
+++ b/drivers/media/rc/ir-nec-decoder.c
@@ -87,8 +87,6 @@ static int ir_nec_decode(struct rc_dev *dev, struct ir_raw_event ev)
 			data->state = STATE_BIT_PULSE;
 			return 0;
 		} else if (eq_margin(ev.duration, NEC_REPEAT_SPACE, NEC_UNIT / 2)) {
-			rc_repeat(dev);
-			IR_dprintk(1, "Repeat last key\n");
 			data->state = STATE_TRAILER_PULSE;
 			return 0;
 		}
@@ -151,19 +149,26 @@ static int ir_nec_decode(struct rc_dev *dev, struct ir_raw_event ev)
 		if (!geq_margin(ev.duration, NEC_TRAILER_SPACE, NEC_UNIT / 2))
 			break;
 
-		address     = bitrev8((data->bits >> 24) & 0xff);
-		not_address = bitrev8((data->bits >> 16) & 0xff);
-		command	    = bitrev8((data->bits >>  8) & 0xff);
-		not_command = bitrev8((data->bits >>  0) & 0xff);
+		if (data->count == NEC_NBITS) {
+			address     = bitrev8((data->bits >> 24) & 0xff);
+			not_address = bitrev8((data->bits >> 16) & 0xff);
+			command	    = bitrev8((data->bits >>  8) & 0xff);
+			not_command = bitrev8((data->bits >>  0) & 0xff);
+
+			scancode = ir_nec_bytes_to_scancode(address,
+							    not_address,
+							    command,
+							    not_command,
+							    &rc_proto);
 
-		scancode = ir_nec_bytes_to_scancode(address, not_address,
-						    command, not_command,
-						    &rc_proto);
+			if (data->is_nec_x)
+				data->necx_repeat = true;
 
-		if (data->is_nec_x)
-			data->necx_repeat = true;
+			rc_keydown(dev, rc_proto, scancode, 0);
+		} else {
+			rc_repeat(dev);
+		}
 
-		rc_keydown(dev, rc_proto, scancode, 0);
 		data->state = STATE_INACTIVE;
 		return 0;
 	}

commit 6d741bfed5ed06ed42a16d30f1ed7afdcaf7f092
Author: Sean Young <sean@mess.org>
Date:   Mon Aug 7 16:20:58 2017 -0400

    media: rc: rename RC_TYPE_* to RC_PROTO_* and RC_BIT_* to RC_PROTO_BIT_*
    
    RC_TYPE is confusing and it's just the protocol. So rename it.
    
    Suggested-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Sean Young <sean@mess.org>
    Acked-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/rc/ir-nec-decoder.c b/drivers/media/rc/ir-nec-decoder.c
index 23d2bc8c190d..817c18f2ddd1 100644
--- a/drivers/media/rc/ir-nec-decoder.c
+++ b/drivers/media/rc/ir-nec-decoder.c
@@ -49,7 +49,7 @@ static int ir_nec_decode(struct rc_dev *dev, struct ir_raw_event ev)
 {
 	struct nec_dec *data = &dev->raw->nec;
 	u32 scancode;
-	enum rc_type rc_type;
+	enum rc_proto rc_proto;
 	u8 address, not_address, command, not_command;
 
 	if (!is_timing_event(ev)) {
@@ -158,12 +158,12 @@ static int ir_nec_decode(struct rc_dev *dev, struct ir_raw_event ev)
 
 		scancode = ir_nec_bytes_to_scancode(address, not_address,
 						    command, not_command,
-						    &rc_type);
+						    &rc_proto);
 
 		if (data->is_nec_x)
 			data->necx_repeat = true;
 
-		rc_keydown(dev, rc_type, scancode, 0);
+		rc_keydown(dev, rc_proto, scancode, 0);
 		data->state = STATE_INACTIVE;
 		return 0;
 	}
@@ -180,19 +180,19 @@ static int ir_nec_decode(struct rc_dev *dev, struct ir_raw_event ev)
  * @scancode:	a single NEC scancode.
  * @raw:	raw data to be modulated.
  */
-static u32 ir_nec_scancode_to_raw(enum rc_type protocol, u32 scancode)
+static u32 ir_nec_scancode_to_raw(enum rc_proto protocol, u32 scancode)
 {
 	unsigned int addr, addr_inv, data, data_inv;
 
 	data = scancode & 0xff;
 
-	if (protocol == RC_TYPE_NEC32) {
+	if (protocol == RC_PROTO_NEC32) {
 		/* 32-bit NEC (used by Apple and TiVo remotes) */
 		/* scan encoding: aaAAddDD */
 		addr_inv   = (scancode >> 24) & 0xff;
 		addr       = (scancode >> 16) & 0xff;
 		data_inv   = (scancode >>  8) & 0xff;
-	} else if (protocol == RC_TYPE_NECX) {
+	} else if (protocol == RC_PROTO_NECX) {
 		/* Extended NEC */
 		/* scan encoding AAaaDD */
 		addr       = (scancode >> 16) & 0xff;
@@ -236,7 +236,7 @@ static const struct ir_raw_timings_pd ir_nec_timings = {
  *		-ENOBUFS if there isn't enough space in the array to fit the
  *		encoding. In this case all @max events will have been written.
  */
-static int ir_nec_encode(enum rc_type protocol, u32 scancode,
+static int ir_nec_encode(enum rc_proto protocol, u32 scancode,
 			 struct ir_raw_event *events, unsigned int max)
 {
 	struct ir_raw_event *e = events;
@@ -255,7 +255,8 @@ static int ir_nec_encode(enum rc_type protocol, u32 scancode,
 }
 
 static struct ir_raw_handler nec_handler = {
-	.protocols	= RC_BIT_NEC | RC_BIT_NECX | RC_BIT_NEC32,
+	.protocols	= RC_PROTO_BIT_NEC | RC_PROTO_BIT_NECX |
+							RC_PROTO_BIT_NEC32,
 	.decode		= ir_nec_decode,
 	.encode		= ir_nec_encode,
 };

commit e8ffda78623677f7935b30901a173405b4861bda
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Sun Jul 30 09:23:11 2017 -0400

    media: rc: ir-nec-decoder: move scancode composing code into a shared function
    
    The NEC scancode composing and protocol type detection in
    ir_nec_decode() is generic enough to be a shared function.  Let's create
    an inline function in rc-core.h, so that other remote control drivers
    can reuse this function to save some code.
    
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    Signed-off-by: Sean Young <sean@mess.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/rc/ir-nec-decoder.c b/drivers/media/rc/ir-nec-decoder.c
index 75b9137f6faf..23d2bc8c190d 100644
--- a/drivers/media/rc/ir-nec-decoder.c
+++ b/drivers/media/rc/ir-nec-decoder.c
@@ -51,7 +51,6 @@ static int ir_nec_decode(struct rc_dev *dev, struct ir_raw_event ev)
 	u32 scancode;
 	enum rc_type rc_type;
 	u8 address, not_address, command, not_command;
-	bool send_32bits = false;
 
 	if (!is_timing_event(ev)) {
 		if (ev.reset)
@@ -157,34 +156,9 @@ static int ir_nec_decode(struct rc_dev *dev, struct ir_raw_event ev)
 		command	    = bitrev8((data->bits >>  8) & 0xff);
 		not_command = bitrev8((data->bits >>  0) & 0xff);
 
-		if ((command ^ not_command) != 0xff) {
-			IR_dprintk(1, "NEC checksum error: received 0x%08x\n",
-				   data->bits);
-			send_32bits = true;
-		}
-
-		if (send_32bits) {
-			/* NEC transport, but modified protocol, used by at
-			 * least Apple and TiVo remotes */
-			scancode = not_address << 24 |
-				address     << 16 |
-				not_command <<  8 |
-				command;
-			IR_dprintk(1, "NEC (modified) scancode 0x%08x\n", scancode);
-			rc_type = RC_TYPE_NEC32;
-		} else if ((address ^ not_address) != 0xff) {
-			/* Extended NEC */
-			scancode = address     << 16 |
-				   not_address <<  8 |
-				   command;
-			IR_dprintk(1, "NEC (Ext) scancode 0x%06x\n", scancode);
-			rc_type = RC_TYPE_NECX;
-		} else {
-			/* Normal NEC */
-			scancode = address << 8 | command;
-			IR_dprintk(1, "NEC scancode 0x%04x\n", scancode);
-			rc_type = RC_TYPE_NEC;
-		}
+		scancode = ir_nec_bytes_to_scancode(address, not_address,
+						    command, not_command,
+						    &rc_type);
 
 		if (data->is_nec_x)
 			data->necx_repeat = true;

commit 265a2988d202b3aba0bbbb4d828c66d3741d59db
Author: David Härdeman <david@hardeman.nu>
Date:   Thu Jun 22 15:23:54 2017 -0400

    media: rc-core: consistent use of rc_repeat()
    
    The NEC decoder and the Sanyo decoders check if dev->keypressed is true
    before calling rc_repeat (without holding dev->keylock).
    
    Meanwhile, the XMP and JVC decoders do no such checks.
    
    This patch makes sure all users of rc_repeat() do so consistently by
    removing extra checks in NEC/Sanyo and modifying the check a bit in
    rc_repeat() so that no input event is generated if the key isn't pressed.
    
    Signed-off-by: David Härdeman <david@hardeman.nu>
    Signed-off-by: Sean Young <sean@mess.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/rc/ir-nec-decoder.c b/drivers/media/rc/ir-nec-decoder.c
index 3ce850314dca..75b9137f6faf 100644
--- a/drivers/media/rc/ir-nec-decoder.c
+++ b/drivers/media/rc/ir-nec-decoder.c
@@ -88,13 +88,9 @@ static int ir_nec_decode(struct rc_dev *dev, struct ir_raw_event ev)
 			data->state = STATE_BIT_PULSE;
 			return 0;
 		} else if (eq_margin(ev.duration, NEC_REPEAT_SPACE, NEC_UNIT / 2)) {
-			if (!dev->keypressed) {
-				IR_dprintk(1, "Discarding last key repeat: event after key up\n");
-			} else {
-				rc_repeat(dev);
-				IR_dprintk(1, "Repeat last key\n");
-				data->state = STATE_TRAILER_PULSE;
-			}
+			rc_repeat(dev);
+			IR_dprintk(1, "Repeat last key\n");
+			data->state = STATE_TRAILER_PULSE;
 			return 0;
 		}
 

commit 141cfb1432f5c8e120d49229be52a32c8705afba
Author: James Hogan <james@albanarts.com>
Date:   Fri Mar 14 20:04:14 2014 -0300

    [media] rc: ir-nec-decoder: Add encode capability
    
    Add the capability to encode NEC scancodes as raw events. The
    scancode_to_raw is pretty much taken from the img-ir NEC filter()
    callback, and modulation uses the pulse distance helper added in a
    previous commit.
    
    Signed-off-by: James Hogan <james@albanarts.com>
    Signed-off-by: Sean Young <sean@mess.org>
    Cc: Antti Seppälä <a.seppala@gmail.com>
    Cc: David Härdeman <david@hardeman.nu>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/rc/ir-nec-decoder.c b/drivers/media/rc/ir-nec-decoder.c
index a5d418e33eca..3ce850314dca 100644
--- a/drivers/media/rc/ir-nec-decoder.c
+++ b/drivers/media/rc/ir-nec-decoder.c
@@ -204,9 +204,90 @@ static int ir_nec_decode(struct rc_dev *dev, struct ir_raw_event ev)
 	return -EINVAL;
 }
 
+/**
+ * ir_nec_scancode_to_raw() - encode an NEC scancode ready for modulation.
+ * @protocol:	specific protocol to use
+ * @scancode:	a single NEC scancode.
+ * @raw:	raw data to be modulated.
+ */
+static u32 ir_nec_scancode_to_raw(enum rc_type protocol, u32 scancode)
+{
+	unsigned int addr, addr_inv, data, data_inv;
+
+	data = scancode & 0xff;
+
+	if (protocol == RC_TYPE_NEC32) {
+		/* 32-bit NEC (used by Apple and TiVo remotes) */
+		/* scan encoding: aaAAddDD */
+		addr_inv   = (scancode >> 24) & 0xff;
+		addr       = (scancode >> 16) & 0xff;
+		data_inv   = (scancode >>  8) & 0xff;
+	} else if (protocol == RC_TYPE_NECX) {
+		/* Extended NEC */
+		/* scan encoding AAaaDD */
+		addr       = (scancode >> 16) & 0xff;
+		addr_inv   = (scancode >>  8) & 0xff;
+		data_inv   = data ^ 0xff;
+	} else {
+		/* Normal NEC */
+		/* scan encoding: AADD */
+		addr       = (scancode >>  8) & 0xff;
+		addr_inv   = addr ^ 0xff;
+		data_inv   = data ^ 0xff;
+	}
+
+	/* raw encoding: ddDDaaAA */
+	return data_inv << 24 |
+	       data     << 16 |
+	       addr_inv <<  8 |
+	       addr;
+}
+
+static const struct ir_raw_timings_pd ir_nec_timings = {
+	.header_pulse	= NEC_HEADER_PULSE,
+	.header_space	= NEC_HEADER_SPACE,
+	.bit_pulse	= NEC_BIT_PULSE,
+	.bit_space[0]	= NEC_BIT_0_SPACE,
+	.bit_space[1]	= NEC_BIT_1_SPACE,
+	.trailer_pulse	= NEC_TRAILER_PULSE,
+	.trailer_space	= NEC_TRAILER_SPACE,
+	.msb_first	= 0,
+};
+
+/**
+ * ir_nec_encode() - Encode a scancode as a stream of raw events
+ *
+ * @protocol:	protocol to encode
+ * @scancode:	scancode to encode
+ * @events:	array of raw ir events to write into
+ * @max:	maximum size of @events
+ *
+ * Returns:	The number of events written.
+ *		-ENOBUFS if there isn't enough space in the array to fit the
+ *		encoding. In this case all @max events will have been written.
+ */
+static int ir_nec_encode(enum rc_type protocol, u32 scancode,
+			 struct ir_raw_event *events, unsigned int max)
+{
+	struct ir_raw_event *e = events;
+	int ret;
+	u32 raw;
+
+	/* Convert a NEC scancode to raw NEC data */
+	raw = ir_nec_scancode_to_raw(protocol, scancode);
+
+	/* Modulate the raw data using a pulse distance modulation */
+	ret = ir_raw_gen_pd(&e, max, &ir_nec_timings, NEC_NBITS, raw);
+	if (ret < 0)
+		return ret;
+
+	return e - events;
+}
+
 static struct ir_raw_handler nec_handler = {
 	.protocols	= RC_BIT_NEC | RC_BIT_NECX | RC_BIT_NEC32,
 	.decode		= ir_nec_decode,
+	.encode		= ir_nec_encode,
 };
 
 static int __init ir_nec_decode_init(void)

commit 6eae57e9d5b01d0ee4b1932b66102b1b9b6cd93d
Author: Sean Young <sean@mess.org>
Date:   Thu Dec 15 07:37:48 2016 -0200

    [media] rc: unify nec32 protocol scancode format
    
    There are two different encodings used for nec32:
     - The ir-nec-decoder.c decoder treats it as 32 bit msb first.
     - The img-ir decoder/encoder, winbond wakeup, dib0700, ir-ctl userspace,
       treat nec32 analogous to necx and nec: 4 bytes, each lsb first. So this
       format reverses the 4 bytes.
    
    There are arguments to be had for both formats, but we should not use
    different formats in different parts of the kernel. Selecting the second
    format introduces the least code churn. It does mean that the TiVo keymap
    needs updating.
    
    This change was submitted before as "18bc174 [media] media: rc: change
    32bit NEC scancode format", which was reverted because it was unclear
    what scancode rc drivers produce. There are now more examples of drivers
    which produce nec32 in lsb format.
    
    The TiVo keymap is verified against the Nero Liquid TiVo remote. The
    keymap is not for the Tivo DVR remote, which uses rc-5.
    
    Signed-off-by: Sean Young <sean@mess.org>
    Cc: James Hogan <james.hogan@imgtec.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/rc/ir-nec-decoder.c b/drivers/media/rc/ir-nec-decoder.c
index 2a9d155548ab..a5d418e33eca 100644
--- a/drivers/media/rc/ir-nec-decoder.c
+++ b/drivers/media/rc/ir-nec-decoder.c
@@ -170,7 +170,10 @@ static int ir_nec_decode(struct rc_dev *dev, struct ir_raw_event ev)
 		if (send_32bits) {
 			/* NEC transport, but modified protocol, used by at
 			 * least Apple and TiVo remotes */
-			scancode = data->bits;
+			scancode = not_address << 24 |
+				address     << 16 |
+				not_command <<  8 |
+				command;
 			IR_dprintk(1, "NEC (modified) scancode 0x%08x\n", scancode);
 			rc_type = RC_TYPE_NEC32;
 		} else if ((address ^ not_address) != 0xff) {

commit 2ceeca0499d745213306ecd785af17adb2321b6a
Author: Sean Young <sean@mess.org>
Date:   Wed Sep 21 06:54:19 2016 -0300

    [media] rc: split nec protocol into its three variants
    
    Currently we do not know what variant (bit length) of the nec protocol
    is used, other than from guessing from the length of the scancode. Now
    nec will be handled the same way as the sony protocol or the rc6 protocol;
    one variant per bit length.
    
    In the future we might want to expose the rc protocol type to userspace
    and we don't want to be introducing this world of pain into userspace
    too.
    
    Signed-off-by: Sean Young <sean@mess.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/rc/ir-nec-decoder.c b/drivers/media/rc/ir-nec-decoder.c
index bea0d1eedee0..2a9d155548ab 100644
--- a/drivers/media/rc/ir-nec-decoder.c
+++ b/drivers/media/rc/ir-nec-decoder.c
@@ -49,6 +49,7 @@ static int ir_nec_decode(struct rc_dev *dev, struct ir_raw_event ev)
 {
 	struct nec_dec *data = &dev->raw->nec;
 	u32 scancode;
+	enum rc_type rc_type;
 	u8 address, not_address, command, not_command;
 	bool send_32bits = false;
 
@@ -171,22 +172,25 @@ static int ir_nec_decode(struct rc_dev *dev, struct ir_raw_event ev)
 			 * least Apple and TiVo remotes */
 			scancode = data->bits;
 			IR_dprintk(1, "NEC (modified) scancode 0x%08x\n", scancode);
+			rc_type = RC_TYPE_NEC32;
 		} else if ((address ^ not_address) != 0xff) {
 			/* Extended NEC */
 			scancode = address     << 16 |
 				   not_address <<  8 |
 				   command;
 			IR_dprintk(1, "NEC (Ext) scancode 0x%06x\n", scancode);
+			rc_type = RC_TYPE_NECX;
 		} else {
 			/* Normal NEC */
 			scancode = address << 8 | command;
 			IR_dprintk(1, "NEC scancode 0x%04x\n", scancode);
+			rc_type = RC_TYPE_NEC;
 		}
 
 		if (data->is_nec_x)
 			data->necx_repeat = true;
 
-		rc_keydown(dev, RC_TYPE_NEC, scancode, 0);
+		rc_keydown(dev, rc_type, scancode, 0);
 		data->state = STATE_INACTIVE;
 		return 0;
 	}
@@ -198,7 +202,7 @@ static int ir_nec_decode(struct rc_dev *dev, struct ir_raw_event ev)
 }
 
 static struct ir_raw_handler nec_handler = {
-	.protocols	= RC_BIT_NEC,
+	.protocols	= RC_BIT_NEC | RC_BIT_NECX | RC_BIT_NEC32,
 	.decode		= ir_nec_decode,
 };
 

commit d80ca8bd71f0b01b2b12459189927cb3299cfab9
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Mon Nov 16 17:52:50 2015 -0200

    [media] media: rc: move check whether a protocol is enabled to the core
    
    Checking whether a protocol is enabled and calling the related decoder
    functions should be done by the rc core, not the protocol handlers.
    
    Properly handle lirc considering that no protocol bit is set for lirc.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/rc/ir-nec-decoder.c b/drivers/media/rc/ir-nec-decoder.c
index 7b81fec0820f..bea0d1eedee0 100644
--- a/drivers/media/rc/ir-nec-decoder.c
+++ b/drivers/media/rc/ir-nec-decoder.c
@@ -52,9 +52,6 @@ static int ir_nec_decode(struct rc_dev *dev, struct ir_raw_event ev)
 	u8 address, not_address, command, not_command;
 	bool send_32bits = false;
 
-	if (!(dev->enabled_protocols & RC_BIT_NEC))
-		return 0;
-
 	if (!is_timing_event(ev)) {
 		if (ev.reset)
 			data->state = STATE_INACTIVE;

commit c5540fbb9de39ceec108a889133664a887c2f55a
Author: David Härdeman <david@hardeman.nu>
Date:   Thu Apr 3 20:32:21 2014 -0300

    [media] rc-core: remove protocol arrays
    
    The basic API of rc-core used to be:
    
            dev = rc_allocate_device();
            dev->x = a;
            dev->y = b;
            dev->z = c;
            rc_register_device();
    
    which is a pretty common pattern in the kernel, after the introduction of
    protocol arrays the API looks something like:
    
            dev = rc_allocate_device();
            dev->x = a;
            rc_set_allowed_protocols(dev, RC_BIT_X);
            dev->z = c;
            rc_register_device();
    
    There's no real need for the protocols to be an array, so change it
    back to be consistent (and in preparation for the following patches).
    
    [m.chehab@samsung.com: added missing changes at some files]
    Signed-off-by: David Härdeman <david@hardeman.nu>
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/drivers/media/rc/ir-nec-decoder.c b/drivers/media/rc/ir-nec-decoder.c
index c4333d5c0046..7b81fec0820f 100644
--- a/drivers/media/rc/ir-nec-decoder.c
+++ b/drivers/media/rc/ir-nec-decoder.c
@@ -52,7 +52,7 @@ static int ir_nec_decode(struct rc_dev *dev, struct ir_raw_event ev)
 	u8 address, not_address, command, not_command;
 	bool send_32bits = false;
 
-	if (!rc_protocols_enabled(dev, RC_BIT_NEC))
+	if (!(dev->enabled_protocols & RC_BIT_NEC))
 		return 0;
 
 	if (!is_timing_event(ev)) {

commit 120703f9eb32033f0e39bdc552c0273c8ab45f33
Author: David Härdeman <david@hardeman.nu>
Date:   Thu Apr 3 20:31:30 2014 -0300

    [media] rc-core: document the protocol type
    
    Right now the protocol information is not preserved, rc-core gets handed a
    scancode but has no idea which protocol it corresponds to.
    
    This patch (which required reading through the source/keymap for all drivers,
    not fun) makes the protocol information explicit which is important
    documentation and makes it easier to e.g. support multiple protocols with one
    decoder (think rc5 and rc-streamzap). The information isn't used yet so there
    should be no functional changes.
    
    [m.chehab@samsung.com: rebased, added cxusb and removed bad whitespacing]
    Signed-off-by: David Härdeman <david@hardeman.nu>
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/drivers/media/rc/ir-nec-decoder.c b/drivers/media/rc/ir-nec-decoder.c
index 35c42e5e270b..c4333d5c0046 100644
--- a/drivers/media/rc/ir-nec-decoder.c
+++ b/drivers/media/rc/ir-nec-decoder.c
@@ -189,7 +189,7 @@ static int ir_nec_decode(struct rc_dev *dev, struct ir_raw_event ev)
 		if (data->is_nec_x)
 			data->necx_repeat = true;
 
-		rc_keydown(dev, scancode, 0);
+		rc_keydown(dev, RC_TYPE_NEC, scancode, 0);
 		data->state = STATE_INACTIVE;
 		return 0;
 	}

commit 42f5e630e06326fa47b3ba86e572b51c36b0a3b1
Author: David Härdeman <david@hardeman.nu>
Date:   Fri Apr 4 19:05:56 2014 -0300

    [media] rc-core: do not change 32bit NEC scancode format for now
    
    This reverts 18bc17448147e93f31cc9b1a83be49f1224657b2 and changes
    the code at img-ir-nec.c to use the order used by the other NEC decoders.
    
    The original patch ignored the fact that NEC32 scancodes are generated not
    only in the NEC raw decoder but also directly in some drivers. Whichever
    approach is chosen it should be consistent across drivers and this patch
    needs more discussion.
    
    Furthermore, I'm convinced that we have to stop playing games trying to
    decipher the "meaning" of NEC scancodes (what's the customer/vendor/address,
    which byte is the MSB, etc).
    
    Signed-off-by: David Härdeman <david@hardeman.nu>
    Acked-by: James Hogan <james.hogan@imgtec.com>
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/drivers/media/rc/ir-nec-decoder.c b/drivers/media/rc/ir-nec-decoder.c
index 9de1791d2494..35c42e5e270b 100644
--- a/drivers/media/rc/ir-nec-decoder.c
+++ b/drivers/media/rc/ir-nec-decoder.c
@@ -172,10 +172,7 @@ static int ir_nec_decode(struct rc_dev *dev, struct ir_raw_event ev)
 		if (send_32bits) {
 			/* NEC transport, but modified protocol, used by at
 			 * least Apple and TiVo remotes */
-			scancode = not_address << 24 |
-				   address     << 16 |
-				   not_command <<  8 |
-				   command;
+			scancode = data->bits;
 			IR_dprintk(1, "NEC (modified) scancode 0x%08x\n", scancode);
 		} else if ((address ^ not_address) != 0xff) {
 			/* Extended NEC */

commit 1a1934fab0c920f0d3bceeb60c9fe2dae8a56be9
Author: James Hogan <james.hogan@imgtec.com>
Date:   Fri Feb 28 20:17:03 2014 -0300

    [media] rc: abstract access to allowed/enabled protocols
    
    The allowed and enabled protocol masks need to be expanded to be per
    filter type in order to support wakeup filter protocol selection. To
    ease that process abstract access to the rc_dev::allowed_protos and
    rc_dev::enabled_protocols members with inline functions.
    
    Signed-off-by: James Hogan <james.hogan@imgtec.com>
    Reviewed-by: Antti Seppälä <a.seppala@gmail.com>
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/drivers/media/rc/ir-nec-decoder.c b/drivers/media/rc/ir-nec-decoder.c
index e687a4247052..9de1791d2494 100644
--- a/drivers/media/rc/ir-nec-decoder.c
+++ b/drivers/media/rc/ir-nec-decoder.c
@@ -52,7 +52,7 @@ static int ir_nec_decode(struct rc_dev *dev, struct ir_raw_event ev)
 	u8 address, not_address, command, not_command;
 	bool send_32bits = false;
 
-	if (!(dev->enabled_protocols & RC_BIT_NEC))
+	if (!rc_protocols_enabled(dev, RC_BIT_NEC))
 		return 0;
 
 	if (!is_timing_event(ev)) {

commit 37e59f876bc710d67a30b660826a5e83e07101ce
Author: Mauro Carvalho Chehab <m.chehab@samsung.com>
Date:   Fri Feb 7 08:03:07 2014 -0200

    [media, edac] Change my email address
    
    There are several left overs with my old email address.
    Remove their occurrences and add myself at CREDITS, to
    allow people to be able to reach me on my new addresses.
    
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/drivers/media/rc/ir-nec-decoder.c b/drivers/media/rc/ir-nec-decoder.c
index 1bab7ea686fc..e687a4247052 100644
--- a/drivers/media/rc/ir-nec-decoder.c
+++ b/drivers/media/rc/ir-nec-decoder.c
@@ -1,6 +1,6 @@
 /* ir-nec-decoder.c - handle NEC IR Pulse/Space protocol
  *
- * Copyright (C) 2010 by Mauro Carvalho Chehab <mchehab@redhat.com>
+ * Copyright (C) 2010 by Mauro Carvalho Chehab
  *
  * This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
@@ -225,6 +225,6 @@ module_init(ir_nec_decode_init);
 module_exit(ir_nec_decode_exit);
 
 MODULE_LICENSE("GPL");
-MODULE_AUTHOR("Mauro Carvalho Chehab <mchehab@redhat.com>");
+MODULE_AUTHOR("Mauro Carvalho Chehab");
 MODULE_AUTHOR("Red Hat Inc. (http://www.redhat.com)");
 MODULE_DESCRIPTION("NEC IR protocol decoder");

commit 18bc17448147e93f31cc9b1a83be49f1224657b2
Author: James Hogan <james.hogan@imgtec.com>
Date:   Fri Jan 17 10:58:50 2014 -0300

    [media] media: rc: change 32bit NEC scancode format
    
    Change 32bit NEC scancode format (used by Apple and TiVo remotes) to
    encode the data with the correct bit order. Previously the raw bits were
    used without being bit reversed, now each 16bit half is bit reversed
    compared to before.
    
    So for the raw NEC data:
      (LSB/First) 0xAAaaCCcc (MSB/Last)
    (where traditionally AA=address, aa=~address, CC=command, cc=~command)
    
    We now generate the scancodes:
      (MSB) 0x0000AACC (LSB) (normal NEC)
      (MSB) 0x00AAaaCC (LSB) (extended NEC, address check wrong)
      (MSB) 0xaaAAccCC (LSB) (32-bit NEC, command check wrong)
    
    Note that the address byte order in 32-bit NEC scancodes is different to
    that of the extended NEC scancodes. I chose this way as it maintains the
    order of the bits in the address/command fields, and CC is clearly
    intended to be the LSB of the command if the TiVo codes are anything to
    go by so it makes sense for AA to also be the LSB.
    
    The TiVo keymap is updated accordingly.
    
    Signed-off-by: James Hogan <james.hogan@imgtec.com>
    Cc: Mauro Carvalho Chehab <m.chehab@samsung.com>
    Cc: Jarod Wilson <jarod@redhat.com>
    Cc: linux-media@vger.kernel.org
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/drivers/media/rc/ir-nec-decoder.c b/drivers/media/rc/ir-nec-decoder.c
index 9a9009411439..1bab7ea686fc 100644
--- a/drivers/media/rc/ir-nec-decoder.c
+++ b/drivers/media/rc/ir-nec-decoder.c
@@ -172,7 +172,10 @@ static int ir_nec_decode(struct rc_dev *dev, struct ir_raw_event ev)
 		if (send_32bits) {
 			/* NEC transport, but modified protocol, used by at
 			 * least Apple and TiVo remotes */
-			scancode = data->bits;
+			scancode = not_address << 24 |
+				   address     << 16 |
+				   not_command <<  8 |
+				   command;
 			IR_dprintk(1, "NEC (modified) scancode 0x%08x\n", scancode);
 		} else if ((address ^ not_address) != 0xff) {
 			/* Extended NEC */

commit 9719afae5e589b409e137c36f89073d134f0de33
Author: David Härdeman <david@hardeman.nu>
Date:   Wed Mar 6 16:52:05 2013 -0300

    [media] rc-core: don't treat dev->rc_map.rc_type as a bitmap
    
    store_protocols() treats dev->rc_map.rc_type as a bitmap which is wrong for
    two reasons. First of all, it is pretty bogus to change the protocol type of
    the keymap just because the hardware has been asked to decode a different
    protocol.
    Second, dev->rc_map.rc_type is an enum (i.e. a single protocol) as pointed
    out by James Hogan <james.hogan@imgtec.com>.
    Fix both issues by introducing a separate enabled_protocols member to
    struct rc_dev.
    
    Signed-off-by: David Härdeman <david@hardeman.nu>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/rc/ir-nec-decoder.c b/drivers/media/rc/ir-nec-decoder.c
index a47ee3634969..9a9009411439 100644
--- a/drivers/media/rc/ir-nec-decoder.c
+++ b/drivers/media/rc/ir-nec-decoder.c
@@ -52,7 +52,7 @@ static int ir_nec_decode(struct rc_dev *dev, struct ir_raw_event ev)
 	u8 address, not_address, command, not_command;
 	bool send_32bits = false;
 
-	if (!(dev->raw->enabled_protocols & RC_BIT_NEC))
+	if (!(dev->enabled_protocols & RC_BIT_NEC))
 		return 0;
 
 	if (!is_timing_event(ev)) {

commit c003ab1bedf028db15b0185b683d5c387204e8f5
Author: David Härdeman <david@hardeman.nu>
Date:   Thu Oct 11 19:11:54 2012 -0300

    [media] rc-core: add separate defines for protocol bitmaps and numbers
    
    The RC_TYPE_* defines are currently used both where a single protocol is
    expected and where a bitmap of protocols is expected.
    
    Functions like rc_keydown() and functions which add/remove entries to the
    keytable want a single protocol. Future userspace APIs would also
    benefit from numeric protocols (rather than bitmap ones). Keytables are
    smaller if they can use a small(ish) integer rather than a bitmap.
    
    Other functions or struct members (e.g. allowed_protos,
    enabled_protocols, etc) accept multiple protocols and need a bitmap.
    
    Using different types reduces the risk of programmer error. Using a
    protocol enum whereever possible also makes for a more future-proof
    user-space API as we don't need to worry about a sufficient number of
    bits being available (e.g. in structs used for ioctl() calls).
    
    The use of both a number and a corresponding bit is dalso one in e.g.
    the input subsystem as well (see all the references to set/clear bit when
    changing keytables for example).
    
    This patch separate the different usages in preparation for
    upcoming patches.
    
    Where a single protocol is expected, enum rc_type is used; where one or more
    protocol(s) are expected, something like u64 is used.
    
    The patch has been rewritten so that the format of the sysfs "protocols"
    file is no longer altered (at the loss of some detail). The file itself
    should probably be deprecated in the future though.
    
    Signed-off-by: David Härdeman <david@hardeman.nu>
    Cc: Andy Walls <awalls@md.metrocast.net>
    Cc: Maxim Levitsky <maximlevitsky@gmail.com>
    Cc: Antti Palosaari <crope@iki.fi>
    Cc: Mike Isely <isely@pobox.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/rc/ir-nec-decoder.c b/drivers/media/rc/ir-nec-decoder.c
index 2ca509e6e16b..a47ee3634969 100644
--- a/drivers/media/rc/ir-nec-decoder.c
+++ b/drivers/media/rc/ir-nec-decoder.c
@@ -52,7 +52,7 @@ static int ir_nec_decode(struct rc_dev *dev, struct ir_raw_event ev)
 	u8 address, not_address, command, not_command;
 	bool send_32bits = false;
 
-	if (!(dev->raw->enabled_protocols & RC_TYPE_NEC))
+	if (!(dev->raw->enabled_protocols & RC_BIT_NEC))
 		return 0;
 
 	if (!is_timing_event(ev)) {
@@ -201,7 +201,7 @@ static int ir_nec_decode(struct rc_dev *dev, struct ir_raw_event ev)
 }
 
 static struct ir_raw_handler nec_handler = {
-	.protocols	= RC_TYPE_NEC,
+	.protocols	= RC_BIT_NEC,
 	.decode		= ir_nec_decode,
 };
 

commit 743135e7a59b452c2ad526a040e494772af815a9
Author: Sean Young <sean@mess.org>
Date:   Tue Jul 31 06:37:29 2012 -0300

    [media] nec-decoder: fix NEC decoding for Pioneer Laserdisc CU-700 remote
    
    This remote sends a header pulse of 8150us followed by a space of 4000us.
    
    Signed-off-by: Sean Young <sean@mess.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/rc/ir-nec-decoder.c b/drivers/media/rc/ir-nec-decoder.c
index 3c9431a9f62d..2ca509e6e16b 100644
--- a/drivers/media/rc/ir-nec-decoder.c
+++ b/drivers/media/rc/ir-nec-decoder.c
@@ -70,7 +70,7 @@ static int ir_nec_decode(struct rc_dev *dev, struct ir_raw_event ev)
 		if (!ev.pulse)
 			break;
 
-		if (eq_margin(ev.duration, NEC_HEADER_PULSE, NEC_UNIT / 2)) {
+		if (eq_margin(ev.duration, NEC_HEADER_PULSE, NEC_UNIT * 2)) {
 			data->is_nec_x = false;
 			data->necx_repeat = false;
 		} else if (eq_margin(ev.duration, NECX_HEADER_PULSE, NEC_UNIT / 2))
@@ -86,7 +86,7 @@ static int ir_nec_decode(struct rc_dev *dev, struct ir_raw_event ev)
 		if (ev.pulse)
 			break;
 
-		if (eq_margin(ev.duration, NEC_HEADER_SPACE, NEC_UNIT / 2)) {
+		if (eq_margin(ev.duration, NEC_HEADER_SPACE, NEC_UNIT)) {
 			data->state = STATE_BIT_PULSE;
 			return 0;
 		} else if (eq_margin(ev.duration, NEC_REPEAT_SPACE, NEC_UNIT / 2)) {

commit 12cbfd0a3c52a52c2948c91b9e62e73c468d1572
Merge: b32e72430830 cfcfc9eca2bc
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Wed Nov 23 19:42:09 2011 -0200

    Merge tag 'v3.2-rc2' into staging/for_v3.3
    
    * tag 'v3.2-rc2': (3068 commits)
      Linux 3.2-rc2
      hfs: add sanity check for file name length
      fsl-rio: fix compile error
      blackfin: Fixup export.h includes
      Blackfin: add serial TX IRQ in individual platform resource
      virtio-pci: fix use after free
      ACPI / cpuidle: Remove acpi_idle_suspend (to fix suspend regression)
      drm/radeon/kms/combios: fix dynamic allocation of PM clock modes
      [CPUFREQ] db8500: fix build error due to undeclared i variable
      bma023: Add SFI translation for this device
      vrtc: change its year offset from 1960 to 1972
      ce4100: fix a build error
      arm/imx: fix imx6q mmc error when mounting rootfs
      arm/imx: fix AUTO_ZRELADDR selection
      arm/imx: fix the references to ARCH_MX3
      ARM: mx51/53: set pwm clock parent to ipg_perclk
      btrfs: rename the option to nospace_cache
      drm/radeon/kms/pm: switch to dynamically allocating clock mode array
      drm/radeon/kms: optimize r600_pm_profile_init
      drm/radeon/kms/pm: add a proper pm profile init function for fusion
      ...
    
    Conflicts:
            drivers/media/radio/Kconfig

commit 39cac3758f62c6495d954e0d7dc1ca7e69fa565d
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Wed Nov 23 12:03:32 2011 -0300

    [media] ir-nec-decoder: Report what bit failed at debug msg
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/rc/ir-nec-decoder.c b/drivers/media/rc/ir-nec-decoder.c
index 63ee722dbd02..a8253182caf5 100644
--- a/drivers/media/rc/ir-nec-decoder.c
+++ b/drivers/media/rc/ir-nec-decoder.c
@@ -193,8 +193,8 @@ static int ir_nec_decode(struct rc_dev *dev, struct ir_raw_event ev)
 		return 0;
 	}
 
-	IR_dprintk(1, "NEC decode failed at state %d (%uus %s)\n",
-		   data->state, TO_US(ev.duration), TO_STR(ev.pulse));
+	IR_dprintk(1, "NEC decode failed at count %d state %d (%uus %s)\n",
+		   data->count, data->state, TO_US(ev.duration), TO_STR(ev.pulse));
 	data->state = STATE_INACTIVE;
 	return -EINVAL;
 }

commit 7a707b89202f905bd9f9fbde326933c59a81214c
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Sun Jul 3 14:03:12 2011 -0400

    drivers/media: Add module.h to all files using it implicitly
    
    A pending cleanup will mean that module.h won't be implicitly
    everywhere anymore.  Make sure the modular drivers in clocksource
    are actually calling out for <module.h> explicitly in advance.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/drivers/media/rc/ir-nec-decoder.c b/drivers/media/rc/ir-nec-decoder.c
index 63ee722dbd02..17f8db00435a 100644
--- a/drivers/media/rc/ir-nec-decoder.c
+++ b/drivers/media/rc/ir-nec-decoder.c
@@ -13,6 +13,7 @@
  */
 
 #include <linux/bitrev.h>
+#include <linux/module.h>
 #include "rc-core-priv.h"
 
 #define NEC_NBITS		32

commit 4be22b6a7f2f2b7eb6f7aab8902068a367cda8ba
Author: Jarod Wilson <jarod@redhat.com>
Date:   Tue Mar 22 17:23:15 2011 -0300

    [media] rc: interim support for 32-bit NEC-ish scancodes
    
    The Apple and TiVo remotes I've got use an NEC-ish protocol, but rather
    than a command/not_command pair, they have what appear to be vendor ID
    bytes. This change makes the NEC decoder warn if the command/not_command
    checksum fails, but then passes along a full 32-bit scancode for keymap
    lookup. This change should make no difference for existing keymaps,
    since they simply won't have 32-bit scancodes, but allows for a 32-bit
    keymap. At the moment, that'll have to be uploaded by the user, but I've
    got Apple and TiVo remote keymaps forthcoming.
    
    In the long run (2.6.40, hopefully), we should probably just always use
    all 32 bits for all NEC keymaps, but this should get us by for 2.6.39.
    
    (Note that a few of the TiVo keys actuallly *do* pass the command
    checksum, so for now, the keymap for this remote will have to be a mix
    of 24-bit and 32-bit scancodes, but so be it).
    
    Signed-off-by: Jarod Wilson <jarod@redhat.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/rc/ir-nec-decoder.c b/drivers/media/rc/ir-nec-decoder.c
index 7b58b4a1729b..63ee722dbd02 100644
--- a/drivers/media/rc/ir-nec-decoder.c
+++ b/drivers/media/rc/ir-nec-decoder.c
@@ -49,6 +49,7 @@ static int ir_nec_decode(struct rc_dev *dev, struct ir_raw_event ev)
 	struct nec_dec *data = &dev->raw->nec;
 	u32 scancode;
 	u8 address, not_address, command, not_command;
+	bool send_32bits = false;
 
 	if (!(dev->raw->enabled_protocols & RC_TYPE_NEC))
 		return 0;
@@ -164,10 +165,15 @@ static int ir_nec_decode(struct rc_dev *dev, struct ir_raw_event ev)
 		if ((command ^ not_command) != 0xff) {
 			IR_dprintk(1, "NEC checksum error: received 0x%08x\n",
 				   data->bits);
-			break;
+			send_32bits = true;
 		}
 
-		if ((address ^ not_address) != 0xff) {
+		if (send_32bits) {
+			/* NEC transport, but modified protocol, used by at
+			 * least Apple and TiVo remotes */
+			scancode = data->bits;
+			IR_dprintk(1, "NEC (modified) scancode 0x%08x\n", scancode);
+		} else if ((address ^ not_address) != 0xff) {
 			/* Extended NEC */
 			scancode = address     << 16 |
 				   not_address <<  8 |

commit 21d33014108671cc6b02feda088f32bf26ce532d
Author: Mariusz Białończyk <manio@skyboo.net>
Date:   Wed Dec 29 19:48:43 2010 -0300

    [media] ir-nec-decoder: fix repeat key issue
    
    Fixing the problem with NEC protocol and repeating keys under the following
    circumstances. The problem occurs when there is a repeat code without
    properly decoded scancode. This leads to repeat the wrong (last decoded)
    scancode.
    
    An example from real life:
    I am pressing volume down, then several minutes later i am pressing
    volume up, but the real scancode is wrongly decoded and only a repeat
    event is emitted, so as a result volume is going down while i am holding
    volume up button.
    
    The patch fixes above problem using rc_keyup timeout (as pointed by Mauro).
    It just prevents key repeats if they appear after rc_keyup.
    
    Signed-off-by: Mariusz Białończyk <manio@skyboo.net>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/rc/ir-nec-decoder.c b/drivers/media/rc/ir-nec-decoder.c
index 5d15c31288b9..7b58b4a1729b 100644
--- a/drivers/media/rc/ir-nec-decoder.c
+++ b/drivers/media/rc/ir-nec-decoder.c
@@ -88,9 +88,13 @@ static int ir_nec_decode(struct rc_dev *dev, struct ir_raw_event ev)
 			data->state = STATE_BIT_PULSE;
 			return 0;
 		} else if (eq_margin(ev.duration, NEC_REPEAT_SPACE, NEC_UNIT / 2)) {
-			rc_repeat(dev);
-			IR_dprintk(1, "Repeat last key\n");
-			data->state = STATE_TRAILER_PULSE;
+			if (!dev->keypressed) {
+				IR_dprintk(1, "Discarding last key repeat: event after key up\n");
+			} else {
+				rc_repeat(dev);
+				IR_dprintk(1, "Repeat last key\n");
+				data->state = STATE_TRAILER_PULSE;
+			}
 			return 0;
 		}
 

commit 52b661449aecc47e652a164c0d8078b31e10aca0
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Wed Nov 17 14:20:52 2010 -0300

    [media] rc: Rename remote controller type to rc_type instead of ir_type
    
    for i in `find drivers/staging -type f -name *.[ch]` `find include/media -type f -name *.[ch]` `find drivers/media -type f -name *.[ch]`; do sed s,IR_TYPE,RC_TYPE,g <$i >a && mv a $i; done
    for i in `find drivers/staging -type f -name *.[ch]` `find include/media -type f -name *.[ch]` `find drivers/media -type f -name *.[ch]`; do sed s,ir_type,rc_type,g <$i >a && mv a $i; done
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/rc/ir-nec-decoder.c b/drivers/media/rc/ir-nec-decoder.c
index 235d774d0ec2..5d15c31288b9 100644
--- a/drivers/media/rc/ir-nec-decoder.c
+++ b/drivers/media/rc/ir-nec-decoder.c
@@ -50,7 +50,7 @@ static int ir_nec_decode(struct rc_dev *dev, struct ir_raw_event ev)
 	u32 scancode;
 	u8 address, not_address, command, not_command;
 
-	if (!(dev->raw->enabled_protocols & IR_TYPE_NEC))
+	if (!(dev->raw->enabled_protocols & RC_TYPE_NEC))
 		return 0;
 
 	if (!is_timing_event(ev)) {
@@ -190,7 +190,7 @@ static int ir_nec_decode(struct rc_dev *dev, struct ir_raw_event ev)
 }
 
 static struct ir_raw_handler nec_handler = {
-	.protocols	= IR_TYPE_NEC,
+	.protocols	= RC_TYPE_NEC,
 	.decode		= ir_nec_decode,
 };
 

commit ca86674b8a93ea11c4bb6f4dd0113b1adf1fa841
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Wed Nov 17 13:53:11 2010 -0300

    [media] Rename all public generic RC functions from ir_ to rc_
    
    Those functions are not InfraRed specific. So, rename them to properly
    reflect it.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/rc/ir-nec-decoder.c b/drivers/media/rc/ir-nec-decoder.c
index 8ff157a140ca..235d774d0ec2 100644
--- a/drivers/media/rc/ir-nec-decoder.c
+++ b/drivers/media/rc/ir-nec-decoder.c
@@ -88,7 +88,7 @@ static int ir_nec_decode(struct rc_dev *dev, struct ir_raw_event ev)
 			data->state = STATE_BIT_PULSE;
 			return 0;
 		} else if (eq_margin(ev.duration, NEC_REPEAT_SPACE, NEC_UNIT / 2)) {
-			ir_repeat(dev);
+			rc_repeat(dev);
 			IR_dprintk(1, "Repeat last key\n");
 			data->state = STATE_TRAILER_PULSE;
 			return 0;
@@ -114,7 +114,7 @@ static int ir_nec_decode(struct rc_dev *dev, struct ir_raw_event ev)
 			geq_margin(ev.duration,
 			NEC_TRAILER_SPACE, NEC_UNIT / 2)) {
 				IR_dprintk(1, "Repeat last key\n");
-				ir_repeat(dev);
+				rc_repeat(dev);
 				data->state = STATE_INACTIVE;
 				return 0;
 
@@ -178,7 +178,7 @@ static int ir_nec_decode(struct rc_dev *dev, struct ir_raw_event ev)
 		if (data->is_nec_x)
 			data->necx_repeat = true;
 
-		ir_keydown(dev, scancode, 0);
+		rc_keydown(dev, scancode, 0);
 		data->state = STATE_INACTIVE;
 		return 0;
 	}

commit d8b4b5822f51e2142b731b42c81e3f03eec475b2
Author: David HÃ¤rdeman <david@hardeman.nu>
Date:   Fri Oct 29 16:08:23 2010 -0300

    [media] ir-core: make struct rc_dev the primary interface
    
    This patch merges the ir_input_dev and ir_dev_props structs into a single
    struct called rc_dev. The drivers and various functions in rc-core used
    by the drivers are also changed to use rc_dev as the primary interface
    when dealing with rc-core.
    
    This means that the input_dev is abstracted away from the drivers which
    is necessary if we ever want to support multiple input devs per rc device.
    
    The new API is similar to what the input subsystem uses, i.e:
    rc_device_alloc()
    rc_device_free()
    rc_device_register()
    rc_device_unregister()
    
    [mchehab@redhat.com: Fix compilation on mceusb and cx231xx, due to merge conflicts]
    Signed-off-by: David Härdeman <david@hardeman.nu>
    Acked-by: Jarod Wilson <jarod@redhat.com>
    Tested-by: Jarod Wilson <jarod@redhat.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/rc/ir-nec-decoder.c b/drivers/media/rc/ir-nec-decoder.c
index cad4e994aa78..8ff157a140ca 100644
--- a/drivers/media/rc/ir-nec-decoder.c
+++ b/drivers/media/rc/ir-nec-decoder.c
@@ -39,19 +39,18 @@ enum nec_state {
 
 /**
  * ir_nec_decode() - Decode one NEC pulse or space
- * @input_dev:	the struct input_dev descriptor of the device
+ * @dev:	the struct rc_dev descriptor of the device
  * @duration:	the struct ir_raw_event descriptor of the pulse/space
  *
  * This function returns -EINVAL if the pulse violates the state machine
  */
-static int ir_nec_decode(struct input_dev *input_dev, struct ir_raw_event ev)
+static int ir_nec_decode(struct rc_dev *dev, struct ir_raw_event ev)
 {
-	struct ir_input_dev *ir_dev = input_get_drvdata(input_dev);
-	struct nec_dec *data = &ir_dev->raw->nec;
+	struct nec_dec *data = &dev->raw->nec;
 	u32 scancode;
 	u8 address, not_address, command, not_command;
 
-	if (!(ir_dev->raw->enabled_protocols & IR_TYPE_NEC))
+	if (!(dev->raw->enabled_protocols & IR_TYPE_NEC))
 		return 0;
 
 	if (!is_timing_event(ev)) {
@@ -89,7 +88,7 @@ static int ir_nec_decode(struct input_dev *input_dev, struct ir_raw_event ev)
 			data->state = STATE_BIT_PULSE;
 			return 0;
 		} else if (eq_margin(ev.duration, NEC_REPEAT_SPACE, NEC_UNIT / 2)) {
-			ir_repeat(input_dev);
+			ir_repeat(dev);
 			IR_dprintk(1, "Repeat last key\n");
 			data->state = STATE_TRAILER_PULSE;
 			return 0;
@@ -115,7 +114,7 @@ static int ir_nec_decode(struct input_dev *input_dev, struct ir_raw_event ev)
 			geq_margin(ev.duration,
 			NEC_TRAILER_SPACE, NEC_UNIT / 2)) {
 				IR_dprintk(1, "Repeat last key\n");
-				ir_repeat(input_dev);
+				ir_repeat(dev);
 				data->state = STATE_INACTIVE;
 				return 0;
 
@@ -179,7 +178,7 @@ static int ir_nec_decode(struct input_dev *input_dev, struct ir_raw_event ev)
 		if (data->is_nec_x)
 			data->necx_repeat = true;
 
-		ir_keydown(input_dev, scancode, 0);
+		ir_keydown(dev, scancode, 0);
 		data->state = STATE_INACTIVE;
 		return 0;
 	}

commit f62de675f796a992011c598c405a3d6fada9aa20
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Tue Nov 9 23:09:57 2010 -0300

    [media] Rename rc-core files from ir- to rc-
    
    As protocol decoders are specific to InfraRed, keep their names as-is.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/rc/ir-nec-decoder.c b/drivers/media/rc/ir-nec-decoder.c
index 70993f79c8a2..cad4e994aa78 100644
--- a/drivers/media/rc/ir-nec-decoder.c
+++ b/drivers/media/rc/ir-nec-decoder.c
@@ -13,7 +13,7 @@
  */
 
 #include <linux/bitrev.h>
-#include "ir-core-priv.h"
+#include "rc-core-priv.h"
 
 #define NEC_NBITS		32
 #define NEC_UNIT		562500  /* ns */

commit 32cf86f6d16367db5a10039c1dd938a2427d697c
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Tue Nov 9 23:00:14 2010 -0300

    [media] rename drivers/media/IR to drives/media/rc
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/rc/ir-nec-decoder.c b/drivers/media/rc/ir-nec-decoder.c
new file mode 100644
index 000000000000..70993f79c8a2
--- /dev/null
+++ b/drivers/media/rc/ir-nec-decoder.c
@@ -0,0 +1,217 @@
+/* ir-nec-decoder.c - handle NEC IR Pulse/Space protocol
+ *
+ * Copyright (C) 2010 by Mauro Carvalho Chehab <mchehab@redhat.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ */
+
+#include <linux/bitrev.h>
+#include "ir-core-priv.h"
+
+#define NEC_NBITS		32
+#define NEC_UNIT		562500  /* ns */
+#define NEC_HEADER_PULSE	(16 * NEC_UNIT)
+#define NECX_HEADER_PULSE	(8  * NEC_UNIT) /* Less common NEC variant */
+#define NEC_HEADER_SPACE	(8  * NEC_UNIT)
+#define NEC_REPEAT_SPACE	(4  * NEC_UNIT)
+#define NEC_BIT_PULSE		(1  * NEC_UNIT)
+#define NEC_BIT_0_SPACE		(1  * NEC_UNIT)
+#define NEC_BIT_1_SPACE		(3  * NEC_UNIT)
+#define	NEC_TRAILER_PULSE	(1  * NEC_UNIT)
+#define	NEC_TRAILER_SPACE	(10 * NEC_UNIT) /* even longer in reality */
+#define NECX_REPEAT_BITS	1
+
+enum nec_state {
+	STATE_INACTIVE,
+	STATE_HEADER_SPACE,
+	STATE_BIT_PULSE,
+	STATE_BIT_SPACE,
+	STATE_TRAILER_PULSE,
+	STATE_TRAILER_SPACE,
+};
+
+/**
+ * ir_nec_decode() - Decode one NEC pulse or space
+ * @input_dev:	the struct input_dev descriptor of the device
+ * @duration:	the struct ir_raw_event descriptor of the pulse/space
+ *
+ * This function returns -EINVAL if the pulse violates the state machine
+ */
+static int ir_nec_decode(struct input_dev *input_dev, struct ir_raw_event ev)
+{
+	struct ir_input_dev *ir_dev = input_get_drvdata(input_dev);
+	struct nec_dec *data = &ir_dev->raw->nec;
+	u32 scancode;
+	u8 address, not_address, command, not_command;
+
+	if (!(ir_dev->raw->enabled_protocols & IR_TYPE_NEC))
+		return 0;
+
+	if (!is_timing_event(ev)) {
+		if (ev.reset)
+			data->state = STATE_INACTIVE;
+		return 0;
+	}
+
+	IR_dprintk(2, "NEC decode started at state %d (%uus %s)\n",
+		   data->state, TO_US(ev.duration), TO_STR(ev.pulse));
+
+	switch (data->state) {
+
+	case STATE_INACTIVE:
+		if (!ev.pulse)
+			break;
+
+		if (eq_margin(ev.duration, NEC_HEADER_PULSE, NEC_UNIT / 2)) {
+			data->is_nec_x = false;
+			data->necx_repeat = false;
+		} else if (eq_margin(ev.duration, NECX_HEADER_PULSE, NEC_UNIT / 2))
+			data->is_nec_x = true;
+		else
+			break;
+
+		data->count = 0;
+		data->state = STATE_HEADER_SPACE;
+		return 0;
+
+	case STATE_HEADER_SPACE:
+		if (ev.pulse)
+			break;
+
+		if (eq_margin(ev.duration, NEC_HEADER_SPACE, NEC_UNIT / 2)) {
+			data->state = STATE_BIT_PULSE;
+			return 0;
+		} else if (eq_margin(ev.duration, NEC_REPEAT_SPACE, NEC_UNIT / 2)) {
+			ir_repeat(input_dev);
+			IR_dprintk(1, "Repeat last key\n");
+			data->state = STATE_TRAILER_PULSE;
+			return 0;
+		}
+
+		break;
+
+	case STATE_BIT_PULSE:
+		if (!ev.pulse)
+			break;
+
+		if (!eq_margin(ev.duration, NEC_BIT_PULSE, NEC_UNIT / 2))
+			break;
+
+		data->state = STATE_BIT_SPACE;
+		return 0;
+
+	case STATE_BIT_SPACE:
+		if (ev.pulse)
+			break;
+
+		if (data->necx_repeat && data->count == NECX_REPEAT_BITS &&
+			geq_margin(ev.duration,
+			NEC_TRAILER_SPACE, NEC_UNIT / 2)) {
+				IR_dprintk(1, "Repeat last key\n");
+				ir_repeat(input_dev);
+				data->state = STATE_INACTIVE;
+				return 0;
+
+		} else if (data->count > NECX_REPEAT_BITS)
+			data->necx_repeat = false;
+
+		data->bits <<= 1;
+		if (eq_margin(ev.duration, NEC_BIT_1_SPACE, NEC_UNIT / 2))
+			data->bits |= 1;
+		else if (!eq_margin(ev.duration, NEC_BIT_0_SPACE, NEC_UNIT / 2))
+			break;
+		data->count++;
+
+		if (data->count == NEC_NBITS)
+			data->state = STATE_TRAILER_PULSE;
+		else
+			data->state = STATE_BIT_PULSE;
+
+		return 0;
+
+	case STATE_TRAILER_PULSE:
+		if (!ev.pulse)
+			break;
+
+		if (!eq_margin(ev.duration, NEC_TRAILER_PULSE, NEC_UNIT / 2))
+			break;
+
+		data->state = STATE_TRAILER_SPACE;
+		return 0;
+
+	case STATE_TRAILER_SPACE:
+		if (ev.pulse)
+			break;
+
+		if (!geq_margin(ev.duration, NEC_TRAILER_SPACE, NEC_UNIT / 2))
+			break;
+
+		address     = bitrev8((data->bits >> 24) & 0xff);
+		not_address = bitrev8((data->bits >> 16) & 0xff);
+		command	    = bitrev8((data->bits >>  8) & 0xff);
+		not_command = bitrev8((data->bits >>  0) & 0xff);
+
+		if ((command ^ not_command) != 0xff) {
+			IR_dprintk(1, "NEC checksum error: received 0x%08x\n",
+				   data->bits);
+			break;
+		}
+
+		if ((address ^ not_address) != 0xff) {
+			/* Extended NEC */
+			scancode = address     << 16 |
+				   not_address <<  8 |
+				   command;
+			IR_dprintk(1, "NEC (Ext) scancode 0x%06x\n", scancode);
+		} else {
+			/* Normal NEC */
+			scancode = address << 8 | command;
+			IR_dprintk(1, "NEC scancode 0x%04x\n", scancode);
+		}
+
+		if (data->is_nec_x)
+			data->necx_repeat = true;
+
+		ir_keydown(input_dev, scancode, 0);
+		data->state = STATE_INACTIVE;
+		return 0;
+	}
+
+	IR_dprintk(1, "NEC decode failed at state %d (%uus %s)\n",
+		   data->state, TO_US(ev.duration), TO_STR(ev.pulse));
+	data->state = STATE_INACTIVE;
+	return -EINVAL;
+}
+
+static struct ir_raw_handler nec_handler = {
+	.protocols	= IR_TYPE_NEC,
+	.decode		= ir_nec_decode,
+};
+
+static int __init ir_nec_decode_init(void)
+{
+	ir_raw_handler_register(&nec_handler);
+
+	printk(KERN_INFO "IR NEC protocol handler initialized\n");
+	return 0;
+}
+
+static void __exit ir_nec_decode_exit(void)
+{
+	ir_raw_handler_unregister(&nec_handler);
+}
+
+module_init(ir_nec_decode_init);
+module_exit(ir_nec_decode_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Mauro Carvalho Chehab <mchehab@redhat.com>");
+MODULE_AUTHOR("Red Hat Inc. (http://www.redhat.com)");
+MODULE_DESCRIPTION("NEC IR protocol decoder");
