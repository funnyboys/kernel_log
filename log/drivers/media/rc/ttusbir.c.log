commit c942fddf8793b2013be8c901b47d0a8dc02bf99f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:06 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 157
    
    Based on 3 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [kishon] [vijay] [abraham]
      [i] [kishon]@[ti] [com] this program is distributed in the hope that
      it will be useful but without any warranty without even the implied
      warranty of merchantability or fitness for a particular purpose see
      the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [graeme] [gregory]
      [gg]@[slimlogic] [co] [uk] [author] [kishon] [vijay] [abraham] [i]
      [kishon]@[ti] [com] [based] [on] [twl6030]_[usb] [c] [author] [hema]
      [hk] [hemahk]@[ti] [com] this program is distributed in the hope
      that it will be useful but without any warranty without even the
      implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1105 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.202006027@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/media/rc/ttusbir.c b/drivers/media/rc/ttusbir.c
index 8d4b56d057ae..011a8b620d86 100644
--- a/drivers/media/rc/ttusbir.c
+++ b/drivers/media/rc/ttusbir.c
@@ -1,17 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * TechnoTrend USB IR Receiver
  *
  * Copyright (C) 2012 Sean Young <sean@mess.org>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
  */
 
 #include <linux/module.h>

commit 183e19f5b9ee18fc7bc4b3983a91b5d0dd6c7871
Author: Sean Young <sean@mess.org>
Date:   Tue Aug 21 15:57:52 2018 -0400

    media: rc: Remove init_ir_raw_event and DEFINE_IR_RAW_EVENT macros
    
    This can be done with c99 initializers, which makes the code cleaner
    and more transparent. It does require gcc 4.6, because of this bug
    in earlier versions:
    
            https://gcc.gnu.org/bugzilla/show_bug.cgi?id=10676
    
    Since commit cafa0010cd51 ("Raise the minimum required gcc version to
    4.6"), this is the case.
    
    Signed-off-by: Sean Young <sean@mess.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/rc/ttusbir.c b/drivers/media/rc/ttusbir.c
index aafea3c5170b..8d4b56d057ae 100644
--- a/drivers/media/rc/ttusbir.c
+++ b/drivers/media/rc/ttusbir.c
@@ -117,12 +117,10 @@ static void ttusbir_bulk_complete(struct urb *urb)
  */
 static void ttusbir_process_ir_data(struct ttusbir *tt, uint8_t *buf)
 {
-	struct ir_raw_event rawir;
+	struct ir_raw_event rawir = {};
 	unsigned i, v, b;
 	bool event = false;
 
-	init_ir_raw_event(&rawir);
-
 	for (i = 0; i < 128; i++) {
 		v = buf[i] & 0xfe;
 		switch (v) {

commit 6d741bfed5ed06ed42a16d30f1ed7afdcaf7f092
Author: Sean Young <sean@mess.org>
Date:   Mon Aug 7 16:20:58 2017 -0400

    media: rc: rename RC_TYPE_* to RC_PROTO_* and RC_BIT_* to RC_PROTO_BIT_*
    
    RC_TYPE is confusing and it's just the protocol. So rename it.
    
    Suggested-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Sean Young <sean@mess.org>
    Acked-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/rc/ttusbir.c b/drivers/media/rc/ttusbir.c
index 5002a91e830e..aafea3c5170b 100644
--- a/drivers/media/rc/ttusbir.c
+++ b/drivers/media/rc/ttusbir.c
@@ -313,7 +313,7 @@ static int ttusbir_probe(struct usb_interface *intf,
 	rc->input_phys = tt->phys;
 	usb_to_input_id(tt->udev, &rc->input_id);
 	rc->dev.parent = &intf->dev;
-	rc->allowed_protocols = RC_BIT_ALL_IR_DECODER;
+	rc->allowed_protocols = RC_PROTO_BIT_ALL_IR_DECODER;
 	rc->priv = tt;
 	rc->driver_name = DRIVER_NAME;
 	rc->map_name = RC_MAP_TT_1500;

commit 518f4b26be1ebf6ce220c4e37b5c7e5410c4d064
Author: Sean Young <sean@mess.org>
Date:   Sat Jul 1 12:13:19 2017 -0400

    media: rc-core: rename input_name to device_name
    
    When an ir-spi is registered, you get this message.
    
    rc rc0: Unspecified device as /devices/platform/soc/3f215080.spi/spi_master/spi32766/spi32766.128/rc/rc0
    
    "Unspecified device" refers to input_name, which makes no sense for IR
    TX only devices. So, rename to device_name.
    
    Also make driver_name const char* so that no casts are needed anywhere.
    
    Now ir-spi reports:
    
    rc rc0: IR SPI as /devices/platform/soc/3f215080.spi/spi_master/spi32766/spi32766.128/rc/rc0
    
    Signed-off-by: Sean Young <sean@mess.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/rc/ttusbir.c b/drivers/media/rc/ttusbir.c
index 23be7702e2df..5002a91e830e 100644
--- a/drivers/media/rc/ttusbir.c
+++ b/drivers/media/rc/ttusbir.c
@@ -309,7 +309,7 @@ static int ttusbir_probe(struct usb_interface *intf,
 
 	usb_make_path(tt->udev, tt->phys, sizeof(tt->phys));
 
-	rc->input_name = DRIVER_DESC;
+	rc->device_name = DRIVER_DESC;
 	rc->input_phys = tt->phys;
 	usb_to_input_id(tt->udev, &rc->input_id);
 	rc->dev.parent = &intf->dev;

commit 0f7499fddb153a333dff3c1dc4280c178b9b5a80
Author: Andi Shyti <andi.shyti@samsung.com>
Date:   Fri Dec 16 06:50:58 2016 -0200

    [media] rc-main: assign driver type during allocation
    
    The driver type can be assigned immediately when an RC device
    requests to the framework to allocate the device.
    
    This is an 'enum rc_driver_type' data type and specifies whether
    the device is a raw receiver or scancode receiver. The type will
    be given as parameter to the rc_allocate_device device.
    
    Change accordingly all the drivers calling rc_allocate_device()
    so that the device type is specified during the rc device
    allocation. Whenever the device type is not specified, it will be
    set as RC_DRIVER_SCANCODE which was the default '0' value.
    
    Suggested-by: Sean Young <sean@mess.org>
    Signed-off-by: Andi Shyti <andi.shyti@samsung.com>
    Signed-off-by: Sean Young <sean@mess.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/rc/ttusbir.c b/drivers/media/rc/ttusbir.c
index cf70e0403294..23be7702e2df 100644
--- a/drivers/media/rc/ttusbir.c
+++ b/drivers/media/rc/ttusbir.c
@@ -201,7 +201,7 @@ static int ttusbir_probe(struct usb_interface *intf,
 	int altsetting = -1;
 
 	tt = kzalloc(sizeof(*tt), GFP_KERNEL);
-	rc = rc_allocate_device();
+	rc = rc_allocate_device(RC_DRIVER_IR_RAW);
 	if (!tt || !rc) {
 		ret = -ENOMEM;
 		goto out;
@@ -313,7 +313,6 @@ static int ttusbir_probe(struct usb_interface *intf,
 	rc->input_phys = tt->phys;
 	usb_to_input_id(tt->udev, &rc->input_id);
 	rc->dev.parent = &intf->dev;
-	rc->driver_type = RC_DRIVER_IR_RAW;
 	rc->allowed_protocols = RC_BIT_ALL_IR_DECODER;
 	rc->priv = tt;
 	rc->driver_name = DRIVER_NAME;

commit 8c34b5c4c82e060de0d8bbf26b978c68bffe5a18
Author: Sean Young <sean@mess.org>
Date:   Sat Dec 3 08:55:56 2016 -0200

    [media] rc: raw IR drivers cannot handle cec, unknown or other
    
    unknown and other are for IR protocols for which we have no decoder,
    so the raw IR drivers have no chance of generating them. cec is not
    an IR protocol.
    
    Signed-off-by: Sean Young <sean@mess.org>
    Cc: Jiri Kosina <jikos@kernel.org>
    Cc: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Cc: Bruno Prémont <bonbons@linux-vserver.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/rc/ttusbir.c b/drivers/media/rc/ttusbir.c
index bc7c091d6572..cf70e0403294 100644
--- a/drivers/media/rc/ttusbir.c
+++ b/drivers/media/rc/ttusbir.c
@@ -314,7 +314,7 @@ static int ttusbir_probe(struct usb_interface *intf,
 	usb_to_input_id(tt->udev, &rc->input_id);
 	rc->dev.parent = &intf->dev;
 	rc->driver_type = RC_DRIVER_IR_RAW;
-	rc->allowed_protocols = RC_BIT_ALL;
+	rc->allowed_protocols = RC_BIT_ALL_IR_DECODER;
 	rc->priv = tt;
 	rc->driver_name = DRIVER_NAME;
 	rc->map_name = RC_MAP_TT_1500;

commit 56a6036c5fcb784290edde050baacddb168f4a33
Author: Sean Young <sean@mess.org>
Date:   Fri Dec 2 15:16:12 2016 -0200

    [media] rc: allow software timeout to be set
    
    Both the iguanair and the technotrend usb ir do not do any timeout
    handling in hardware, so timeout is entirely done in
    ir_raw_event_store_with_filter(). Any sensible timeout value will
    do, so allow it to be set using LIRC_SET_REC_TIMEOUT.
    
    Signed-off-by: Sean Young <sean@mess.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/rc/ttusbir.c b/drivers/media/rc/ttusbir.c
index 066c12a4f0e9..bc7c091d6572 100644
--- a/drivers/media/rc/ttusbir.c
+++ b/drivers/media/rc/ttusbir.c
@@ -318,7 +318,10 @@ static int ttusbir_probe(struct usb_interface *intf,
 	rc->priv = tt;
 	rc->driver_name = DRIVER_NAME;
 	rc->map_name = RC_MAP_TT_1500;
-	rc->timeout = MS_TO_NS(100);
+	rc->min_timeout = 1;
+	rc->timeout = IR_DEFAULT_TIMEOUT;
+	rc->max_timeout = 10 * IR_DEFAULT_TIMEOUT;
+
 	/*
 	 * The precision is NS_PER_BIT, but since every 8th bit can be
 	 * overwritten with garbage the accuracy is at best 2 * NS_PER_BIT.

commit bcb63314e2c23f1ed622418b65f9409512659c73
Author: Sakari Ailus <sakari.ailus@linux.intel.com>
Date:   Fri Oct 28 09:31:20 2016 -0200

    [media] media: Drop FSF's postal address from the source code files
    
    Drop the FSF's postal address from the source code files that typically
    contain mostly the license text. Of the 628 removed instances, 578 are
    outdated.
    
    The patch has been created with the following command without manual edits:
    
    git grep -l "675 Mass Ave\|59 Temple Place\|51 Franklin St" -- \
            drivers/media/ include/media|while read i; do i=$i perl -e '
    open(F,"< $ENV{i}");
    $a=join("", <F>);
    $a =~ s/[ \t]*\*\n.*You should.*\n.*along with.*\n.*(\n.*USA.*$)?\n//m
            && $a =~ s/(^.*)Or, (point your browser to) /$1To obtain the license, $2\n$1/m;
    close(F);
    open(F, "> $ENV{i}");
    print F $a;
    close(F);'; done
    
    Signed-off-by: Sakari Ailus <sakari.ailus@linux.intel.com>

diff --git a/drivers/media/rc/ttusbir.c b/drivers/media/rc/ttusbir.c
index bc214e2b3a36..066c12a4f0e9 100644
--- a/drivers/media/rc/ttusbir.c
+++ b/drivers/media/rc/ttusbir.c
@@ -12,10 +12,6 @@
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
  */
 
 #include <linux/module.h>

commit c5540fbb9de39ceec108a889133664a887c2f55a
Author: David Härdeman <david@hardeman.nu>
Date:   Thu Apr 3 20:32:21 2014 -0300

    [media] rc-core: remove protocol arrays
    
    The basic API of rc-core used to be:
    
            dev = rc_allocate_device();
            dev->x = a;
            dev->y = b;
            dev->z = c;
            rc_register_device();
    
    which is a pretty common pattern in the kernel, after the introduction of
    protocol arrays the API looks something like:
    
            dev = rc_allocate_device();
            dev->x = a;
            rc_set_allowed_protocols(dev, RC_BIT_X);
            dev->z = c;
            rc_register_device();
    
    There's no real need for the protocols to be an array, so change it
    back to be consistent (and in preparation for the following patches).
    
    [m.chehab@samsung.com: added missing changes at some files]
    Signed-off-by: David Härdeman <david@hardeman.nu>
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/drivers/media/rc/ttusbir.c b/drivers/media/rc/ttusbir.c
index c5be38e2a2fe..bc214e2b3a36 100644
--- a/drivers/media/rc/ttusbir.c
+++ b/drivers/media/rc/ttusbir.c
@@ -318,7 +318,7 @@ static int ttusbir_probe(struct usb_interface *intf,
 	usb_to_input_id(tt->udev, &rc->input_id);
 	rc->dev.parent = &intf->dev;
 	rc->driver_type = RC_DRIVER_IR_RAW;
-	rc_set_allowed_protocols(rc, RC_BIT_ALL);
+	rc->allowed_protocols = RC_BIT_ALL;
 	rc->priv = tt;
 	rc->driver_name = DRIVER_NAME;
 	rc->map_name = RC_MAP_TT_1500;

commit 1a1934fab0c920f0d3bceeb60c9fe2dae8a56be9
Author: James Hogan <james.hogan@imgtec.com>
Date:   Fri Feb 28 20:17:03 2014 -0300

    [media] rc: abstract access to allowed/enabled protocols
    
    The allowed and enabled protocol masks need to be expanded to be per
    filter type in order to support wakeup filter protocol selection. To
    ease that process abstract access to the rc_dev::allowed_protos and
    rc_dev::enabled_protocols members with inline functions.
    
    Signed-off-by: James Hogan <james.hogan@imgtec.com>
    Reviewed-by: Antti Seppälä <a.seppala@gmail.com>
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/drivers/media/rc/ttusbir.c b/drivers/media/rc/ttusbir.c
index d8de2056a4f6..c5be38e2a2fe 100644
--- a/drivers/media/rc/ttusbir.c
+++ b/drivers/media/rc/ttusbir.c
@@ -318,7 +318,7 @@ static int ttusbir_probe(struct usb_interface *intf,
 	usb_to_input_id(tt->udev, &rc->input_id);
 	rc->dev.parent = &intf->dev;
 	rc->driver_type = RC_DRIVER_IR_RAW;
-	rc->allowed_protos = RC_BIT_ALL;
+	rc_set_allowed_protocols(rc, RC_BIT_ALL);
 	rc->priv = tt;
 	rc->driver_name = DRIVER_NAME;
 	rc->map_name = RC_MAP_TT_1500;

commit 5704e76c86a6bccbe41632041744a481c5bcb247
Author: Sean Young <sean@mess.org>
Date:   Tue Jul 30 19:00:02 2013 -0300

    [media] ttusbir: wire up rc feedback led
    
    Signed-off-by: Sean Young <sean@mess.org>
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/drivers/media/rc/ttusbir.c b/drivers/media/rc/ttusbir.c
index 891762d167ed..d8de2056a4f6 100644
--- a/drivers/media/rc/ttusbir.c
+++ b/drivers/media/rc/ttusbir.c
@@ -302,6 +302,7 @@ static int ttusbir_probe(struct usb_interface *intf,
 						ttusbir_bulk_complete, tt);
 
 	tt->led.name = "ttusbir:green:power";
+	tt->led.default_trigger = "rc-feedback";
 	tt->led.brightness_set = ttusbir_brightness_set;
 	tt->led.brightness_get = ttusbir_brightness_get;
 	tt->is_led_on = tt->led_on = true;

commit a9bd87c232b87014b20fdf52416f80c5c1e869fc
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Thu Apr 4 16:32:09 2013 -0300

    [media] MEDIA: ttusbir, fix double free
    
    rc_unregister_device already calls rc_free_device to free the passed
    device. But in one of ttusbir's probe fail paths, we call
    rc_unregister_device _and_ rc_free_device. This is wrong and results
    in a double free.
    Instead, set rc to NULL resulting in rc_free_device being a noop.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/rc/ttusbir.c b/drivers/media/rc/ttusbir.c
index cf0d47f57fb2..891762d167ed 100644
--- a/drivers/media/rc/ttusbir.c
+++ b/drivers/media/rc/ttusbir.c
@@ -347,6 +347,7 @@ static int ttusbir_probe(struct usb_interface *intf,
 	return 0;
 out3:
 	rc_unregister_device(rc);
+	rc = NULL;
 out2:
 	led_classdev_unregister(&tt->led);
 out:

commit 1e801adc7a70c2f67214b2617088a41f4bebe55e
Author: Sean Young <sean@mess.org>
Date:   Tue Jan 29 08:19:28 2013 -0300

    [media] ttusbir: add missing endian conversion
    
    spotted by sparse.
    
    Signed-off-by: Sean Young <sean@mess.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/rc/ttusbir.c b/drivers/media/rc/ttusbir.c
index f9226b83de41..cf0d47f57fb2 100644
--- a/drivers/media/rc/ttusbir.c
+++ b/drivers/media/rc/ttusbir.c
@@ -213,19 +213,20 @@ static int ttusbir_probe(struct usb_interface *intf,
 
 	/* find the correct alt setting */
 	for (i = 0; i < intf->num_altsetting && altsetting == -1; i++) {
-		int bulk_out_endp = -1, iso_in_endp = -1;
+		int max_packet, bulk_out_endp = -1, iso_in_endp = -1;
 
 		idesc = &intf->altsetting[i].desc;
 
 		for (j = 0; j < idesc->bNumEndpoints; j++) {
 			desc = &intf->altsetting[i].endpoint[j].desc;
+			max_packet = le16_to_cpu(desc->wMaxPacketSize);
 			if (usb_endpoint_dir_in(desc) &&
 					usb_endpoint_xfer_isoc(desc) &&
-					desc->wMaxPacketSize == 0x10)
+					max_packet == 0x10)
 				iso_in_endp = j;
 			else if (usb_endpoint_dir_out(desc) &&
 					usb_endpoint_xfer_bulk(desc) &&
-					desc->wMaxPacketSize == 0x20)
+					max_packet == 0x20)
 				bulk_out_endp = j;
 
 			if (bulk_out_endp != -1 && iso_in_endp != -1) {

commit d2008b56cfd6fa76ac6990d9c12a045ce5026c85
Author: Sean Young <sean@mess.org>
Date:   Tue Jan 29 08:19:27 2013 -0300

    [media] ttusbir: do not set led twice on resume
    
    led_classdev_resume already sets the led.
    
    Signed-off-by: Sean Young <sean@mess.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/rc/ttusbir.c b/drivers/media/rc/ttusbir.c
index 78be8a914225..f9226b83de41 100644
--- a/drivers/media/rc/ttusbir.c
+++ b/drivers/media/rc/ttusbir.c
@@ -408,9 +408,8 @@ static int ttusbir_resume(struct usb_interface *intf)
 	struct ttusbir *tt = usb_get_intfdata(intf);
 	int i, rc;
 
-	led_classdev_resume(&tt->led);
 	tt->is_led_on = true;
-	ttusbir_set_led(tt);
+	led_classdev_resume(&tt->led);
 
 	for (i = 0; i < NUM_URBS; i++) {
 		rc = usb_submit_urb(tt->urb[i], GFP_KERNEL);

commit 4c62e9764ab403d42f9b8871b1241fe7812f19d4
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Dec 21 13:17:53 2012 -0800

    Drivers: media: remove __dev* attributes.
    
    CONFIG_HOTPLUG is going away as an option.  As a result, the __dev*
    markings need to be removed.
    
    This change removes the use of __devinit, __devexit_p, __devinitdata,
    __devinitconst, and __devexit from these drivers.
    
    Based on patches originally written by Bill Pemberton, but redone by me
    in order to handle some of the coding style issues better, by hand.
    
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Mauro Carvalho Chehab <mchehab@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/media/rc/ttusbir.c b/drivers/media/rc/ttusbir.c
index f0921b5483eb..78be8a914225 100644
--- a/drivers/media/rc/ttusbir.c
+++ b/drivers/media/rc/ttusbir.c
@@ -194,8 +194,8 @@ static void ttusbir_urb_complete(struct urb *urb)
 		dev_warn(tt->dev, "failed to resubmit urb: %d\n", rc);
 }
 
-static int __devinit ttusbir_probe(struct usb_interface *intf,
-						const struct usb_device_id *id)
+static int ttusbir_probe(struct usb_interface *intf,
+			 const struct usb_device_id *id)
 {
 	struct ttusbir *tt;
 	struct usb_interface_descriptor *idesc;
@@ -367,7 +367,7 @@ static int __devinit ttusbir_probe(struct usb_interface *intf,
 	return ret;
 }
 
-static void __devexit ttusbir_disconnect(struct usb_interface *intf)
+static void ttusbir_disconnect(struct usb_interface *intf)
 {
 	struct ttusbir *tt = usb_get_intfdata(intf);
 	struct usb_device *udev = tt->udev;
@@ -435,7 +435,7 @@ static struct usb_driver ttusbir_driver = {
 	.suspend = ttusbir_suspend,
 	.resume = ttusbir_resume,
 	.reset_resume = ttusbir_resume,
-	.disconnect = __devexit_p(ttusbir_disconnect)
+	.disconnect = ttusbir_disconnect,
 };
 
 module_usb_driver(ttusbir_driver);

commit c003ab1bedf028db15b0185b683d5c387204e8f5
Author: David Härdeman <david@hardeman.nu>
Date:   Thu Oct 11 19:11:54 2012 -0300

    [media] rc-core: add separate defines for protocol bitmaps and numbers
    
    The RC_TYPE_* defines are currently used both where a single protocol is
    expected and where a bitmap of protocols is expected.
    
    Functions like rc_keydown() and functions which add/remove entries to the
    keytable want a single protocol. Future userspace APIs would also
    benefit from numeric protocols (rather than bitmap ones). Keytables are
    smaller if they can use a small(ish) integer rather than a bitmap.
    
    Other functions or struct members (e.g. allowed_protos,
    enabled_protocols, etc) accept multiple protocols and need a bitmap.
    
    Using different types reduces the risk of programmer error. Using a
    protocol enum whereever possible also makes for a more future-proof
    user-space API as we don't need to worry about a sufficient number of
    bits being available (e.g. in structs used for ioctl() calls).
    
    The use of both a number and a corresponding bit is dalso one in e.g.
    the input subsystem as well (see all the references to set/clear bit when
    changing keytables for example).
    
    This patch separate the different usages in preparation for
    upcoming patches.
    
    Where a single protocol is expected, enum rc_type is used; where one or more
    protocol(s) are expected, something like u64 is used.
    
    The patch has been rewritten so that the format of the sysfs "protocols"
    file is no longer altered (at the loss of some detail). The file itself
    should probably be deprecated in the future though.
    
    Signed-off-by: David Härdeman <david@hardeman.nu>
    Cc: Andy Walls <awalls@md.metrocast.net>
    Cc: Maxim Levitsky <maximlevitsky@gmail.com>
    Cc: Antti Palosaari <crope@iki.fi>
    Cc: Mike Isely <isely@pobox.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/rc/ttusbir.c b/drivers/media/rc/ttusbir.c
index fef05235234a..f0921b5483eb 100644
--- a/drivers/media/rc/ttusbir.c
+++ b/drivers/media/rc/ttusbir.c
@@ -316,7 +316,7 @@ static int __devinit ttusbir_probe(struct usb_interface *intf,
 	usb_to_input_id(tt->udev, &rc->input_id);
 	rc->dev.parent = &intf->dev;
 	rc->driver_type = RC_DRIVER_IR_RAW;
-	rc->allowed_protos = RC_TYPE_ALL;
+	rc->allowed_protos = RC_BIT_ALL;
 	rc->priv = tt;
 	rc->driver_name = DRIVER_NAME;
 	rc->map_name = RC_MAP_TT_1500;

commit 3404cb5c4dbbbac884722f418d5561d81dba969f
Author: Sean Young <sean@mess.org>
Date:   Tue Aug 28 13:18:32 2012 -0300

    [media] ttusbir: ad support suspend and resume
    
    While here, fix the led name: the led is green, not yellow.
    
    Signed-off-by: Sean Young <sean@mess.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/rc/ttusbir.c b/drivers/media/rc/ttusbir.c
index 1aee57fd2f32..fef05235234a 100644
--- a/drivers/media/rc/ttusbir.c
+++ b/drivers/media/rc/ttusbir.c
@@ -66,11 +66,11 @@ static void ttusbir_set_led(struct ttusbir *tt)
 
 	smp_mb();
 
-	if (tt->led_on != tt->is_led_on &&
+	if (tt->led_on != tt->is_led_on && tt->udev &&
 				atomic_add_unless(&tt->led_complete, 1, 1)) {
 		tt->bulk_buffer[4] = tt->is_led_on = tt->led_on;
 		ret = usb_submit_urb(tt->bulk_urb, GFP_ATOMIC);
-		if (ret && ret != -ENODEV) {
+		if (ret) {
 			dev_warn(tt->dev, "failed to submit bulk urb: %d\n",
 									ret);
 			atomic_dec(&tt->led_complete);
@@ -300,7 +300,7 @@ static int __devinit ttusbir_probe(struct usb_interface *intf,
 		tt->bulk_out_endp), tt->bulk_buffer, sizeof(tt->bulk_buffer),
 						ttusbir_bulk_complete, tt);
 
-	tt->led.name = "ttusbir:yellow:power";
+	tt->led.name = "ttusbir:green:power";
 	tt->led.brightness_set = ttusbir_brightness_set;
 	tt->led.brightness_get = ttusbir_brightness_get;
 	tt->is_led_on = tt->led_on = true;
@@ -370,13 +370,16 @@ static int __devinit ttusbir_probe(struct usb_interface *intf,
 static void __devexit ttusbir_disconnect(struct usb_interface *intf)
 {
 	struct ttusbir *tt = usb_get_intfdata(intf);
+	struct usb_device *udev = tt->udev;
 	int i;
 
+	tt->udev = NULL;
+
 	rc_unregister_device(tt->rc);
 	led_classdev_unregister(&tt->led);
 	for (i = 0; i < NUM_URBS; i++) {
 		usb_kill_urb(tt->urb[i]);
-		usb_free_coherent(tt->udev, 128, tt->urb[i]->transfer_buffer,
+		usb_free_coherent(udev, 128, tt->urb[i]->transfer_buffer,
 						tt->urb[i]->transfer_dma);
 		usb_free_urb(tt->urb[i]);
 	}
@@ -386,6 +389,40 @@ static void __devexit ttusbir_disconnect(struct usb_interface *intf)
 	kfree(tt);
 }
 
+static int ttusbir_suspend(struct usb_interface *intf, pm_message_t message)
+{
+	struct ttusbir *tt = usb_get_intfdata(intf);
+	int i;
+
+	for (i = 0; i < NUM_URBS; i++)
+		usb_kill_urb(tt->urb[i]);
+
+	led_classdev_suspend(&tt->led);
+	usb_kill_urb(tt->bulk_urb);
+
+	return 0;
+}
+
+static int ttusbir_resume(struct usb_interface *intf)
+{
+	struct ttusbir *tt = usb_get_intfdata(intf);
+	int i, rc;
+
+	led_classdev_resume(&tt->led);
+	tt->is_led_on = true;
+	ttusbir_set_led(tt);
+
+	for (i = 0; i < NUM_URBS; i++) {
+		rc = usb_submit_urb(tt->urb[i], GFP_KERNEL);
+		if (rc) {
+			dev_warn(tt->dev, "failed to submit urb: %d\n", rc);
+			break;
+		}
+	}
+
+	return rc;
+}
+
 static const struct usb_device_id ttusbir_table[] = {
 	{ USB_DEVICE(0x0b48, 0x2003) },
 	{ }
@@ -395,6 +432,9 @@ static struct usb_driver ttusbir_driver = {
 	.name = DRIVER_NAME,
 	.id_table = ttusbir_table,
 	.probe = ttusbir_probe,
+	.suspend = ttusbir_suspend,
+	.resume = ttusbir_resume,
+	.reset_resume = ttusbir_resume,
 	.disconnect = __devexit_p(ttusbir_disconnect)
 };
 

commit b83bfd1b0127b0963fcac39280280e365e7e04d8
Author: Sean Young <sean@mess.org>
Date:   Mon Aug 13 08:59:47 2012 -0300

    [media] rc: do not wake up rc thread unless there is something to do
    
    The TechnoTrend USB IR Receiver sends 125 ISO URBs per second, even when
    there is no IR activity. Reduce the number of wake ups from the other
    drivers too.
    
    This saves about 0.25ms/s on a 2.4GHz Core 2 according to powertop.
    
    Signed-off-by: Sean Young <sean@mess.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/rc/ttusbir.c b/drivers/media/rc/ttusbir.c
index 71f03acabac8..1aee57fd2f32 100644
--- a/drivers/media/rc/ttusbir.c
+++ b/drivers/media/rc/ttusbir.c
@@ -121,8 +121,9 @@ static void ttusbir_bulk_complete(struct urb *urb)
  */
 static void ttusbir_process_ir_data(struct ttusbir *tt, uint8_t *buf)
 {
+	struct ir_raw_event rawir;
 	unsigned i, v, b;
-	DEFINE_IR_RAW_EVENT(rawir);
+	bool event = false;
 
 	init_ir_raw_event(&rawir);
 
@@ -132,12 +133,14 @@ static void ttusbir_process_ir_data(struct ttusbir *tt, uint8_t *buf)
 		case 0xfe:
 			rawir.pulse = false;
 			rawir.duration = NS_PER_BYTE;
-			ir_raw_event_store_with_filter(tt->rc, &rawir);
+			if (ir_raw_event_store_with_filter(tt->rc, &rawir))
+				event = true;
 			break;
 		case 0:
 			rawir.pulse = true;
 			rawir.duration = NS_PER_BYTE;
-			ir_raw_event_store_with_filter(tt->rc, &rawir);
+			if (ir_raw_event_store_with_filter(tt->rc, &rawir))
+				event = true;
 			break;
 		default:
 			/* one edge per byte */
@@ -150,16 +153,20 @@ static void ttusbir_process_ir_data(struct ttusbir *tt, uint8_t *buf)
 			}
 
 			rawir.duration = NS_PER_BIT * (8 - b);
-			ir_raw_event_store_with_filter(tt->rc, &rawir);
+			if (ir_raw_event_store_with_filter(tt->rc, &rawir))
+				event = true;
 
 			rawir.pulse = !rawir.pulse;
 			rawir.duration = NS_PER_BIT * b;
-			ir_raw_event_store_with_filter(tt->rc, &rawir);
+			if (ir_raw_event_store_with_filter(tt->rc, &rawir))
+				event = true;
 			break;
 		}
 	}
 
-	ir_raw_event_handle(tt->rc);
+	/* don't wakeup when there's nothing to do */
+	if (event)
+		ir_raw_event_handle(tt->rc);
 }
 
 static void ttusbir_urb_complete(struct urb *urb)

commit 0938069fa08970f1c898970c1331a029efe9a1ce
Author: Sean Young <sean@mess.org>
Date:   Mon Aug 13 08:59:46 2012 -0300

    [media] rc: Add support for the TechnoTrend USB IR Receiver
    
    This driver adds support for TechnoTrend USB IR Receiver. It is a complete
    rewrite of the staging/media/lirc/lirc_ttusbir driver. It adds more
    accurate sample reporting and led control.
    
    Signed-off-by: Sean Young <sean@mess.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/rc/ttusbir.c b/drivers/media/rc/ttusbir.c
new file mode 100644
index 000000000000..71f03acabac8
--- /dev/null
+++ b/drivers/media/rc/ttusbir.c
@@ -0,0 +1,400 @@
+/*
+ * TechnoTrend USB IR Receiver
+ *
+ * Copyright (C) 2012 Sean Young <sean@mess.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include <linux/module.h>
+#include <linux/usb.h>
+#include <linux/usb/input.h>
+#include <linux/slab.h>
+#include <linux/leds.h>
+#include <media/rc-core.h>
+
+#define DRIVER_NAME	"ttusbir"
+#define DRIVER_DESC	"TechnoTrend USB IR Receiver"
+/*
+ * The Windows driver uses 8 URBS, the original lirc drivers has a
+ * configurable amount (2 default, 4 max). This device generates about 125
+ * messages per second (!), whether IR is idle or not.
+ */
+#define NUM_URBS	4
+#define NS_PER_BYTE	62500
+#define NS_PER_BIT	(NS_PER_BYTE/8)
+
+struct ttusbir {
+	struct rc_dev *rc;
+	struct device *dev;
+	struct usb_device *udev;
+
+	struct urb *urb[NUM_URBS];
+
+	struct led_classdev led;
+	struct urb *bulk_urb;
+	uint8_t bulk_buffer[5];
+	int bulk_out_endp, iso_in_endp;
+	bool led_on, is_led_on;
+	atomic_t led_complete;
+
+	char phys[64];
+};
+
+static enum led_brightness ttusbir_brightness_get(struct led_classdev *led_dev)
+{
+	struct ttusbir *tt = container_of(led_dev, struct ttusbir, led);
+
+	return tt->led_on ? LED_FULL : LED_OFF;
+}
+
+static void ttusbir_set_led(struct ttusbir *tt)
+{
+	int ret;
+
+	smp_mb();
+
+	if (tt->led_on != tt->is_led_on &&
+				atomic_add_unless(&tt->led_complete, 1, 1)) {
+		tt->bulk_buffer[4] = tt->is_led_on = tt->led_on;
+		ret = usb_submit_urb(tt->bulk_urb, GFP_ATOMIC);
+		if (ret && ret != -ENODEV) {
+			dev_warn(tt->dev, "failed to submit bulk urb: %d\n",
+									ret);
+			atomic_dec(&tt->led_complete);
+		}
+	}
+}
+
+static void ttusbir_brightness_set(struct led_classdev *led_dev, enum
+						led_brightness brightness)
+{
+	struct ttusbir *tt = container_of(led_dev, struct ttusbir, led);
+
+	tt->led_on = brightness != LED_OFF;
+
+	ttusbir_set_led(tt);
+}
+
+/*
+ * The urb cannot be reused until the urb completes
+ */
+static void ttusbir_bulk_complete(struct urb *urb)
+{
+	struct ttusbir *tt = urb->context;
+
+	atomic_dec(&tt->led_complete);
+
+	switch (urb->status) {
+	case 0:
+		break;
+	case -ECONNRESET:
+	case -ENOENT:
+	case -ESHUTDOWN:
+		usb_unlink_urb(urb);
+		return;
+	case -EPIPE:
+	default:
+		dev_dbg(tt->dev, "Error: urb status = %d\n", urb->status);
+		break;
+	}
+
+	ttusbir_set_led(tt);
+}
+
+/*
+ * The data is one bit per sample, a set bit signifying silence and samples
+ * being MSB first. Bit 0 can contain garbage so take it to be whatever
+ * bit 1 is, so we don't have unexpected edges.
+ */
+static void ttusbir_process_ir_data(struct ttusbir *tt, uint8_t *buf)
+{
+	unsigned i, v, b;
+	DEFINE_IR_RAW_EVENT(rawir);
+
+	init_ir_raw_event(&rawir);
+
+	for (i = 0; i < 128; i++) {
+		v = buf[i] & 0xfe;
+		switch (v) {
+		case 0xfe:
+			rawir.pulse = false;
+			rawir.duration = NS_PER_BYTE;
+			ir_raw_event_store_with_filter(tt->rc, &rawir);
+			break;
+		case 0:
+			rawir.pulse = true;
+			rawir.duration = NS_PER_BYTE;
+			ir_raw_event_store_with_filter(tt->rc, &rawir);
+			break;
+		default:
+			/* one edge per byte */
+			if (v & 2) {
+				b = ffz(v | 1);
+				rawir.pulse = true;
+			} else {
+				b = ffs(v) - 1;
+				rawir.pulse = false;
+			}
+
+			rawir.duration = NS_PER_BIT * (8 - b);
+			ir_raw_event_store_with_filter(tt->rc, &rawir);
+
+			rawir.pulse = !rawir.pulse;
+			rawir.duration = NS_PER_BIT * b;
+			ir_raw_event_store_with_filter(tt->rc, &rawir);
+			break;
+		}
+	}
+
+	ir_raw_event_handle(tt->rc);
+}
+
+static void ttusbir_urb_complete(struct urb *urb)
+{
+	struct ttusbir *tt = urb->context;
+	int rc;
+
+	switch (urb->status) {
+	case 0:
+		ttusbir_process_ir_data(tt, urb->transfer_buffer);
+		break;
+	case -ECONNRESET:
+	case -ENOENT:
+	case -ESHUTDOWN:
+		usb_unlink_urb(urb);
+		return;
+	case -EPIPE:
+	default:
+		dev_dbg(tt->dev, "Error: urb status = %d\n", urb->status);
+		break;
+	}
+
+	rc = usb_submit_urb(urb, GFP_ATOMIC);
+	if (rc && rc != -ENODEV)
+		dev_warn(tt->dev, "failed to resubmit urb: %d\n", rc);
+}
+
+static int __devinit ttusbir_probe(struct usb_interface *intf,
+						const struct usb_device_id *id)
+{
+	struct ttusbir *tt;
+	struct usb_interface_descriptor *idesc;
+	struct usb_endpoint_descriptor *desc;
+	struct rc_dev *rc;
+	int i, j, ret;
+	int altsetting = -1;
+
+	tt = kzalloc(sizeof(*tt), GFP_KERNEL);
+	rc = rc_allocate_device();
+	if (!tt || !rc) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	/* find the correct alt setting */
+	for (i = 0; i < intf->num_altsetting && altsetting == -1; i++) {
+		int bulk_out_endp = -1, iso_in_endp = -1;
+
+		idesc = &intf->altsetting[i].desc;
+
+		for (j = 0; j < idesc->bNumEndpoints; j++) {
+			desc = &intf->altsetting[i].endpoint[j].desc;
+			if (usb_endpoint_dir_in(desc) &&
+					usb_endpoint_xfer_isoc(desc) &&
+					desc->wMaxPacketSize == 0x10)
+				iso_in_endp = j;
+			else if (usb_endpoint_dir_out(desc) &&
+					usb_endpoint_xfer_bulk(desc) &&
+					desc->wMaxPacketSize == 0x20)
+				bulk_out_endp = j;
+
+			if (bulk_out_endp != -1 && iso_in_endp != -1) {
+				tt->bulk_out_endp = bulk_out_endp;
+				tt->iso_in_endp = iso_in_endp;
+				altsetting = i;
+				break;
+			}
+		}
+	}
+
+	if (altsetting == -1) {
+		dev_err(&intf->dev, "cannot find expected altsetting\n");
+		ret = -ENODEV;
+		goto out;
+	}
+
+	tt->dev = &intf->dev;
+	tt->udev = interface_to_usbdev(intf);
+	tt->rc = rc;
+
+	ret = usb_set_interface(tt->udev, 0, altsetting);
+	if (ret)
+		goto out;
+
+	for (i = 0; i < NUM_URBS; i++) {
+		struct urb *urb = usb_alloc_urb(8, GFP_KERNEL);
+		void *buffer;
+
+		if (!urb) {
+			ret = -ENOMEM;
+			goto out;
+		}
+
+		urb->dev = tt->udev;
+		urb->context = tt;
+		urb->pipe = usb_rcvisocpipe(tt->udev, tt->iso_in_endp);
+		urb->interval = 1;
+		buffer = usb_alloc_coherent(tt->udev, 128, GFP_KERNEL,
+						&urb->transfer_dma);
+		if (!buffer) {
+			usb_free_urb(urb);
+			ret = -ENOMEM;
+			goto out;
+		}
+		urb->transfer_flags = URB_NO_TRANSFER_DMA_MAP | URB_ISO_ASAP;
+		urb->transfer_buffer = buffer;
+		urb->complete = ttusbir_urb_complete;
+		urb->number_of_packets = 8;
+		urb->transfer_buffer_length = 128;
+
+		for (j = 0; j < 8; j++) {
+			urb->iso_frame_desc[j].offset = j * 16;
+			urb->iso_frame_desc[j].length = 16;
+		}
+
+		tt->urb[i] = urb;
+	}
+
+	tt->bulk_urb = usb_alloc_urb(0, GFP_KERNEL);
+	if (!tt->bulk_urb) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	tt->bulk_buffer[0] = 0xaa;
+	tt->bulk_buffer[1] = 0x01;
+	tt->bulk_buffer[2] = 0x05;
+	tt->bulk_buffer[3] = 0x01;
+
+	usb_fill_bulk_urb(tt->bulk_urb, tt->udev, usb_sndbulkpipe(tt->udev,
+		tt->bulk_out_endp), tt->bulk_buffer, sizeof(tt->bulk_buffer),
+						ttusbir_bulk_complete, tt);
+
+	tt->led.name = "ttusbir:yellow:power";
+	tt->led.brightness_set = ttusbir_brightness_set;
+	tt->led.brightness_get = ttusbir_brightness_get;
+	tt->is_led_on = tt->led_on = true;
+	atomic_set(&tt->led_complete, 0);
+	ret = led_classdev_register(&intf->dev, &tt->led);
+	if (ret)
+		goto out;
+
+	usb_make_path(tt->udev, tt->phys, sizeof(tt->phys));
+
+	rc->input_name = DRIVER_DESC;
+	rc->input_phys = tt->phys;
+	usb_to_input_id(tt->udev, &rc->input_id);
+	rc->dev.parent = &intf->dev;
+	rc->driver_type = RC_DRIVER_IR_RAW;
+	rc->allowed_protos = RC_TYPE_ALL;
+	rc->priv = tt;
+	rc->driver_name = DRIVER_NAME;
+	rc->map_name = RC_MAP_TT_1500;
+	rc->timeout = MS_TO_NS(100);
+	/*
+	 * The precision is NS_PER_BIT, but since every 8th bit can be
+	 * overwritten with garbage the accuracy is at best 2 * NS_PER_BIT.
+	 */
+	rc->rx_resolution = NS_PER_BIT;
+
+	ret = rc_register_device(rc);
+	if (ret) {
+		dev_err(&intf->dev, "failed to register rc device %d\n", ret);
+		goto out2;
+	}
+
+	usb_set_intfdata(intf, tt);
+
+	for (i = 0; i < NUM_URBS; i++) {
+		ret = usb_submit_urb(tt->urb[i], GFP_KERNEL);
+		if (ret) {
+			dev_err(tt->dev, "failed to submit urb %d\n", ret);
+			goto out3;
+		}
+	}
+
+	return 0;
+out3:
+	rc_unregister_device(rc);
+out2:
+	led_classdev_unregister(&tt->led);
+out:
+	if (tt) {
+		for (i = 0; i < NUM_URBS && tt->urb[i]; i++) {
+			struct urb *urb = tt->urb[i];
+
+			usb_kill_urb(urb);
+			usb_free_coherent(tt->udev, 128, urb->transfer_buffer,
+							urb->transfer_dma);
+			usb_free_urb(urb);
+		}
+		usb_kill_urb(tt->bulk_urb);
+		usb_free_urb(tt->bulk_urb);
+		kfree(tt);
+	}
+	rc_free_device(rc);
+
+	return ret;
+}
+
+static void __devexit ttusbir_disconnect(struct usb_interface *intf)
+{
+	struct ttusbir *tt = usb_get_intfdata(intf);
+	int i;
+
+	rc_unregister_device(tt->rc);
+	led_classdev_unregister(&tt->led);
+	for (i = 0; i < NUM_URBS; i++) {
+		usb_kill_urb(tt->urb[i]);
+		usb_free_coherent(tt->udev, 128, tt->urb[i]->transfer_buffer,
+						tt->urb[i]->transfer_dma);
+		usb_free_urb(tt->urb[i]);
+	}
+	usb_kill_urb(tt->bulk_urb);
+	usb_free_urb(tt->bulk_urb);
+	usb_set_intfdata(intf, NULL);
+	kfree(tt);
+}
+
+static const struct usb_device_id ttusbir_table[] = {
+	{ USB_DEVICE(0x0b48, 0x2003) },
+	{ }
+};
+
+static struct usb_driver ttusbir_driver = {
+	.name = DRIVER_NAME,
+	.id_table = ttusbir_table,
+	.probe = ttusbir_probe,
+	.disconnect = __devexit_p(ttusbir_disconnect)
+};
+
+module_usb_driver(ttusbir_driver);
+
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_AUTHOR("Sean Young <sean@mess.org>");
+MODULE_LICENSE("GPL");
+MODULE_DEVICE_TABLE(usb, ttusbir_table);
+
