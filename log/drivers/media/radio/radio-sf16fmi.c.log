commit e83ce3005db16243e1085925251fd0776bb60d09
Author: Hans Verkuil <hverkuil-cisco@xs4all.nl>
Date:   Tue Jun 4 07:19:52 2019 -0400

    media: media/radio: set device_caps in struct video_device
    
    Instead of filling in the struct v4l2_capability device_caps
    field, fill in the struct video_device device_caps field.
    
    That way the V4L2 core knows what the capabilities of the
    video device are.
    
    But this only really works if all drivers use this, so convert
    all radio drivers in this patch.
    
    Signed-off-by: Hans Verkuil <hverkuil-cisco@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/radio/radio-sf16fmi.c b/drivers/media/radio/radio-sf16fmi.c
index 434c03338d7f..54a40d60e4fd 100644
--- a/drivers/media/radio/radio-sf16fmi.c
+++ b/drivers/media/radio/radio-sf16fmi.c
@@ -133,8 +133,6 @@ static int vidioc_querycap(struct file *file, void  *priv,
 	strscpy(v->driver, "radio-sf16fmi", sizeof(v->driver));
 	strscpy(v->card, "SF16-FMI/FMP/FMD radio", sizeof(v->card));
 	strscpy(v->bus_info, "ISA:radio-sf16fmi", sizeof(v->bus_info));
-	v->device_caps = V4L2_CAP_TUNER | V4L2_CAP_RADIO;
-	v->capabilities = v->device_caps | V4L2_CAP_DEVICE_CAPS;
 	return 0;
 }
 
@@ -345,6 +343,7 @@ static int __init fmi_init(void)
 	fmi->vdev.fops = &fmi_fops;
 	fmi->vdev.ioctl_ops = &fmi_ioctl_ops;
 	fmi->vdev.release = video_device_release_empty;
+	fmi->vdev.device_caps = V4L2_CAP_TUNER | V4L2_CAP_RADIO;
 	video_set_drvdata(&fmi->vdev, fmi);
 
 	mutex_init(&fmi->lock);

commit 09c434b8a0047c69e48499de0107de312901e798
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 13:08:20 2019 +0100

    treewide: Add SPDX license identifier for more missed files
    
    Add SPDX license identifiers to all files which:
    
     - Have no license information of any form
    
     - Have MODULE_LICENCE("GPL*") inside which was used in the initial
       scan/conversion to ignore the file
    
    These files fall under the project license, GPL v2 only. The resulting SPDX
    license identifier is:
    
      GPL-2.0-only
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/media/radio/radio-sf16fmi.c b/drivers/media/radio/radio-sf16fmi.c
index a8fedc963614..434c03338d7f 100644
--- a/drivers/media/radio/radio-sf16fmi.c
+++ b/drivers/media/radio/radio-sf16fmi.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /* SF16-FMI, SF16-FMP and SF16-FMD radio driver for Linux radio support
  * heavily based on rtrack driver...
  * (c) 1997 M. Kirkwood

commit c0decac19da3906d9b66291e57b7759489e1170f
Author: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
Date:   Mon Sep 10 08:19:14 2018 -0400

    media: use strscpy() instead of strlcpy()
    
    The implementation of strscpy() is more robust and safer.
    
    That's now the recommended way to copy NUL terminated strings.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Acked-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/radio/radio-sf16fmi.c b/drivers/media/radio/radio-sf16fmi.c
index 4f9b97edd9eb..a8fedc963614 100644
--- a/drivers/media/radio/radio-sf16fmi.c
+++ b/drivers/media/radio/radio-sf16fmi.c
@@ -129,9 +129,9 @@ static void fmi_set_freq(struct fmi *fmi)
 static int vidioc_querycap(struct file *file, void  *priv,
 					struct v4l2_capability *v)
 {
-	strlcpy(v->driver, "radio-sf16fmi", sizeof(v->driver));
-	strlcpy(v->card, "SF16-FMI/FMP/FMD radio", sizeof(v->card));
-	strlcpy(v->bus_info, "ISA:radio-sf16fmi", sizeof(v->bus_info));
+	strscpy(v->driver, "radio-sf16fmi", sizeof(v->driver));
+	strscpy(v->card, "SF16-FMI/FMP/FMD radio", sizeof(v->card));
+	strscpy(v->bus_info, "ISA:radio-sf16fmi", sizeof(v->bus_info));
 	v->device_caps = V4L2_CAP_TUNER | V4L2_CAP_RADIO;
 	v->capabilities = v->device_caps | V4L2_CAP_DEVICE_CAPS;
 	return 0;
@@ -145,7 +145,7 @@ static int vidioc_g_tuner(struct file *file, void *priv,
 	if (v->index > 0)
 		return -EINVAL;
 
-	strlcpy(v->name, "FM", sizeof(v->name));
+	strscpy(v->name, "FM", sizeof(v->name));
 	v->type = V4L2_TUNER_RADIO;
 	v->rangelow = RSF16_MINFREQ;
 	v->rangehigh = RSF16_MAXFREQ;
@@ -315,7 +315,7 @@ static int __init fmi_init(void)
 		return -ENODEV;
 	}
 
-	strlcpy(v4l2_dev->name, "sf16fmi", sizeof(v4l2_dev->name));
+	strscpy(v4l2_dev->name, "sf16fmi", sizeof(v4l2_dev->name));
 	fmi->io = io;
 
 	res = v4l2_device_register(NULL, v4l2_dev);
@@ -339,7 +339,7 @@ static int __init fmi_init(void)
 		return res;
 	}
 
-	strlcpy(fmi->vdev.name, v4l2_dev->name, sizeof(fmi->vdev.name));
+	strscpy(fmi->vdev.name, v4l2_dev->name, sizeof(fmi->vdev.name));
 	fmi->vdev.v4l2_dev = v4l2_dev;
 	fmi->vdev.fops = &fmi_fops;
 	fmi->vdev.ioctl_ops = &fmi_ioctl_ops;

commit 3259081991a9398434f6f49468b960f136ac0158
Author: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
Date:   Wed Apr 25 05:34:48 2018 -0400

    MAINTAINERS & files: Canonize the e-mails I use at files
    
    From now on, I'll start using my @kernel.org as my development e-mail.
    
    As such, let's remove the entries that point to the old
    mchehab@s-opensource.com at MAINTAINERS file.
    
    For the files written with a copyright with mchehab@s-opensource,
    let's keep Samsung on their names, using mchehab+samsung@kernel.org,
    in order to keep pointing to my employer, with sponsors the work.
    
    For the files written before I join Samsung (on July, 4 2013),
    let's just use mchehab@kernel.org.
    
    For bug reports, we can simply point to just kernel.org, as
    this will reach my mchehab+samsung inbox anyway.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>
    Signed-off-by: Brian Warner <brian.warner@samsung.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/radio/radio-sf16fmi.c b/drivers/media/radio/radio-sf16fmi.c
index fc4e63d36e4c..4f9b97edd9eb 100644
--- a/drivers/media/radio/radio-sf16fmi.c
+++ b/drivers/media/radio/radio-sf16fmi.c
@@ -13,7 +13,7 @@
  *  No volume control - only mute/unmute - you have to use line volume
  *  control on SB-part of SF16-FMI/SF16-FMP/SF16-FMD
  *
- * Converted to V4L2 API by Mauro Carvalho Chehab <mchehab@infradead.org>
+ * Converted to V4L2 API by Mauro Carvalho Chehab <mchehab@kernel.org>
  */
 
 #include <linux/kernel.h>	/* __setup			*/

commit 6e6a8b5a38cb04d5ef35d4eb57836126b954e7c8
Author: Mauro Carvalho Chehab <mchehab@s-opensource.com>
Date:   Thu Jan 4 13:08:56 2018 -0500

    media: replace all <spaces><tab> occurrences
    
    There are a lot of places where sequences of space/tabs are
    found. Get rid of all spaces before tabs.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/radio/radio-sf16fmi.c b/drivers/media/radio/radio-sf16fmi.c
index 28a89466cddc..fc4e63d36e4c 100644
--- a/drivers/media/radio/radio-sf16fmi.c
+++ b/drivers/media/radio/radio-sf16fmi.c
@@ -17,7 +17,7 @@
  */
 
 #include <linux/kernel.h>	/* __setup			*/
-#include <linux/module.h>	/* Modules 			*/
+#include <linux/module.h>	/* Modules			*/
 #include <linux/init.h>		/* Initdata			*/
 #include <linux/ioport.h>	/* request_region		*/
 #include <linux/delay.h>	/* udelay			*/
@@ -110,7 +110,7 @@ static inline int fmi_getsigstr(struct fmi *fmi)
 	val = fmi->mute ? 0x00 : 0x08;	/* mute/unmute */
 	outb(val, fmi->io);
 	outb(val | 0x10, fmi->io);
-	msleep(143); 		/* was schedule_timeout(HZ/7) */
+	msleep(143);		/* was schedule_timeout(HZ/7) */
 	res = (int)inb(fmi->io + 1);
 	outb(val, fmi->io);
 

commit 24c8f11f8bce5a959d04f887179b0f1ec43e1c33
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Wed Sep 24 15:42:11 2014 -0300

    [media] radio-sf16fmi: declare pnp_attached as static
    
    drivers/media/radio/radio-sf16fmi.c:59:6: warning: symbol 'pnp_attached' was not declared. Should it be static?
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/radio/radio-sf16fmi.c b/drivers/media/radio/radio-sf16fmi.c
index bcd0946c84a5..28a89466cddc 100644
--- a/drivers/media/radio/radio-sf16fmi.c
+++ b/drivers/media/radio/radio-sf16fmi.c
@@ -56,7 +56,7 @@ struct fmi
 
 static struct fmi fmi_card;
 static struct pnp_dev *dev;
-bool pnp_attached;
+static bool pnp_attached;
 
 #define RSF16_MINFREQ (87U * 16000)
 #define RSF16_MAXFREQ (108U * 16000)

commit 8b4b68186f7095fc2a4badaacd31a39ac6cadea2
Author: Mauro Carvalho Chehab <m.chehab@samsung.com>
Date:   Wed Sep 3 15:54:17 2014 -0300

    [media] radio: use true/false for boolean vars
    
    Instead of using 0 or 1 for boolean, use the true/false
    defines.
    
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/drivers/media/radio/radio-sf16fmi.c b/drivers/media/radio/radio-sf16fmi.c
index d7ce8fe6b5ae..bcd0946c84a5 100644
--- a/drivers/media/radio/radio-sf16fmi.c
+++ b/drivers/media/radio/radio-sf16fmi.c
@@ -285,7 +285,7 @@ static int __init fmi_init(void)
 				io = isapnp_fmi_probe();
 				if (io < 0)
 					continue;
-				pnp_attached = 1;
+				pnp_attached = true;
 			}
 			if (!request_region(io, 2, "radio-sf16fmi")) {
 				if (pnp_attached)
@@ -349,7 +349,7 @@ static int __init fmi_init(void)
 	mutex_init(&fmi->lock);
 
 	/* mute card and set default frequency */
-	fmi->mute = 1;
+	fmi->mute = true;
 	fmi->curfreq = RSF16_MINFREQ;
 	fmi_set_freq(fmi);
 

commit 95cd5d5ee67c2108765ae87d34761d54fd6671ce
Author: Ramakrishnan Muthukrishnan <ramakrmu@cisco.com>
Date:   Thu Jun 19 14:22:58 2014 -0300

    [media] media: remove the setting of the flag V4L2_FL_USE_FH_PRIO
    
    Since all the drivers that use `struct v4l2_fh' use the core
    priority checking, the setting of the flag in the drivers can
    be removed.
    
    Signed-off-by: Ramakrishnan Muthukrishnan <ramakrmu@cisco.com>
    Reviewed-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/drivers/media/radio/radio-sf16fmi.c b/drivers/media/radio/radio-sf16fmi.c
index 6f4318ff0db3..d7ce8fe6b5ae 100644
--- a/drivers/media/radio/radio-sf16fmi.c
+++ b/drivers/media/radio/radio-sf16fmi.c
@@ -344,7 +344,6 @@ static int __init fmi_init(void)
 	fmi->vdev.fops = &fmi_fops;
 	fmi->vdev.ioctl_ops = &fmi_ioctl_ops;
 	fmi->vdev.release = video_device_release_empty;
-	set_bit(V4L2_FL_USE_FH_PRIO, &fmi->vdev.flags);
 	video_set_drvdata(&fmi->vdev, fmi);
 
 	mutex_init(&fmi->lock);

commit d9ec089ef248064ec9b3d027ed707ac6e0a3f2aa
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Fri Jun 14 17:01:39 2013 -0300

    [media] radio-sf16fmi: Set frequency during init
    
    Set freqency during initialization to fix v4l2-compliance error.
    This also fixes VIDIOC_G_FREQUENCY always returning zero (broken by me during LM7000 conversion).
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-sf16fmi.c b/drivers/media/radio/radio-sf16fmi.c
index ed7299d42a24..6f4318ff0db3 100644
--- a/drivers/media/radio/radio-sf16fmi.c
+++ b/drivers/media/radio/radio-sf16fmi.c
@@ -50,7 +50,7 @@ struct fmi
 	struct video_device vdev;
 	int io;
 	bool mute;
-	unsigned long curfreq; /* freq in kHz */
+	u32 curfreq; /* freq in kHz */
 	struct mutex lock;
 };
 
@@ -118,6 +118,14 @@ static inline int fmi_getsigstr(struct fmi *fmi)
 	return (res & 2) ? 0 : 0xFFFF;
 }
 
+static void fmi_set_freq(struct fmi *fmi)
+{
+	fmi->curfreq = clamp(fmi->curfreq, RSF16_MINFREQ, RSF16_MAXFREQ);
+	/* rounding in steps of 800 to match the freq
+	   that will be used */
+	lm7000_set_freq((fmi->curfreq / 800) * 800, fmi, fmi_set_pins);
+}
+
 static int vidioc_querycap(struct file *file, void  *priv,
 					struct v4l2_capability *v)
 {
@@ -158,14 +166,13 @@ static int vidioc_s_frequency(struct file *file, void *priv,
 					const struct v4l2_frequency *f)
 {
 	struct fmi *fmi = video_drvdata(file);
-	unsigned freq = f->frequency;
 
 	if (f->tuner != 0 || f->type != V4L2_TUNER_RADIO)
 		return -EINVAL;
-	clamp(freq, RSF16_MINFREQ, RSF16_MAXFREQ);
-	/* rounding in steps of 800 to match the freq
-	   that will be used */
-	lm7000_set_freq((freq / 800) * 800, fmi, fmi_set_pins);
+
+	fmi->curfreq = f->frequency;
+	fmi_set_freq(fmi);
+
 	return 0;
 }
 
@@ -342,8 +349,10 @@ static int __init fmi_init(void)
 
 	mutex_init(&fmi->lock);
 
-	/* mute card - prevents noisy bootups */
-	fmi_mute(fmi);
+	/* mute card and set default frequency */
+	fmi->mute = 1;
+	fmi->curfreq = RSF16_MINFREQ;
+	fmi_set_freq(fmi);
 
 	if (video_register_device(&fmi->vdev, VFL_TYPE_RADIO, radio_nr) < 0) {
 		v4l2_ctrl_handler_free(hdl);

commit 9291682ea490756157cd26dcc94fd46bd725df6b
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Fri Jun 14 17:01:38 2013 -0300

    [media] radio-sf16fmi: Add module name to bus_info
    
    Fix v4l2-compliance in VIDIOC_QUERYCAP by changing "ISA" to "ISA:radio-sf16fmi".
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-sf16fmi.c b/drivers/media/radio/radio-sf16fmi.c
index 9e712c8310f2..ed7299d42a24 100644
--- a/drivers/media/radio/radio-sf16fmi.c
+++ b/drivers/media/radio/radio-sf16fmi.c
@@ -123,7 +123,7 @@ static int vidioc_querycap(struct file *file, void  *priv,
 {
 	strlcpy(v->driver, "radio-sf16fmi", sizeof(v->driver));
 	strlcpy(v->card, "SF16-FMI/FMP/FMD radio", sizeof(v->card));
-	strlcpy(v->bus_info, "ISA", sizeof(v->bus_info));
+	strlcpy(v->bus_info, "ISA:radio-sf16fmi", sizeof(v->bus_info));
 	v->device_caps = V4L2_CAP_TUNER | V4L2_CAP_RADIO;
 	v->capabilities = v->device_caps | V4L2_CAP_DEVICE_CAPS;
 	return 0;

commit 0dc5d82dcdfcec4d195b70fe8c0a13e5e6dd8d5a
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Sun Feb 3 09:51:59 2013 -0300

    [media] radio-sf16fmi: add control event and prio support
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Cc: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-sf16fmi.c b/drivers/media/radio/radio-sf16fmi.c
index b058f36669ee..9e712c8310f2 100644
--- a/drivers/media/radio/radio-sf16fmi.c
+++ b/drivers/media/radio/radio-sf16fmi.c
@@ -28,6 +28,7 @@
 #include <media/v4l2-device.h>
 #include <media/v4l2-ioctl.h>
 #include <media/v4l2-ctrls.h>
+#include <media/v4l2-event.h>
 #include "lm7000.h"
 
 MODULE_AUTHOR("Petr Vandrovec, vandrove@vc.cvut.cz and M. Kirkwood");
@@ -202,6 +203,9 @@ static const struct v4l2_ctrl_ops fmi_ctrl_ops = {
 
 static const struct v4l2_file_operations fmi_fops = {
 	.owner		= THIS_MODULE,
+	.open		= v4l2_fh_open,
+	.release	= v4l2_fh_release,
+	.poll		= v4l2_ctrl_poll,
 	.unlocked_ioctl	= video_ioctl2,
 };
 
@@ -211,6 +215,9 @@ static const struct v4l2_ioctl_ops fmi_ioctl_ops = {
 	.vidioc_s_tuner     = vidioc_s_tuner,
 	.vidioc_g_frequency = vidioc_g_frequency,
 	.vidioc_s_frequency = vidioc_s_frequency,
+	.vidioc_log_status  = v4l2_ctrl_log_status,
+	.vidioc_subscribe_event = v4l2_ctrl_subscribe_event,
+	.vidioc_unsubscribe_event = v4l2_event_unsubscribe,
 };
 
 /* ladis: this is my card. does any other types exist? */
@@ -330,6 +337,7 @@ static int __init fmi_init(void)
 	fmi->vdev.fops = &fmi_fops;
 	fmi->vdev.ioctl_ops = &fmi_ioctl_ops;
 	fmi->vdev.release = video_device_release_empty;
+	set_bit(V4L2_FL_USE_FH_PRIO, &fmi->vdev.flags);
 	video_set_drvdata(&fmi->vdev, fmi);
 
 	mutex_init(&fmi->lock);

commit 268d06bb765da0bdd17344a6877f5898713a7cbb
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Sun Feb 3 09:51:06 2013 -0300

    [media] radio-sf16fmi: convert to the control framework
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Cc: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-sf16fmi.c b/drivers/media/radio/radio-sf16fmi.c
index 9cd0338a3d2b..b058f36669ee 100644
--- a/drivers/media/radio/radio-sf16fmi.c
+++ b/drivers/media/radio/radio-sf16fmi.c
@@ -27,6 +27,7 @@
 #include <linux/io.h>		/* outb, outb_p			*/
 #include <media/v4l2-device.h>
 #include <media/v4l2-ioctl.h>
+#include <media/v4l2-ctrls.h>
 #include "lm7000.h"
 
 MODULE_AUTHOR("Petr Vandrovec, vandrove@vc.cvut.cz and M. Kirkwood");
@@ -44,6 +45,7 @@ module_param(radio_nr, int, 0);
 struct fmi
 {
 	struct v4l2_device v4l2_dev;
+	struct v4l2_ctrl_handler hdl;
 	struct video_device vdev;
 	int io;
 	bool mute;
@@ -178,46 +180,26 @@ static int vidioc_g_frequency(struct file *file, void *priv,
 	return 0;
 }
 
-static int vidioc_queryctrl(struct file *file, void *priv,
-					struct v4l2_queryctrl *qc)
+static int fmi_s_ctrl(struct v4l2_ctrl *ctrl)
 {
-	switch (qc->id) {
-	case V4L2_CID_AUDIO_MUTE:
-		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 1);
-	}
-	return -EINVAL;
-}
-
-static int vidioc_g_ctrl(struct file *file, void *priv,
-					struct v4l2_control *ctrl)
-{
-	struct fmi *fmi = video_drvdata(file);
+	struct fmi *fmi = container_of(ctrl->handler, struct fmi, hdl);
 
 	switch (ctrl->id) {
 	case V4L2_CID_AUDIO_MUTE:
-		ctrl->value = fmi->mute;
-		return 0;
-	}
-	return -EINVAL;
-}
-
-static int vidioc_s_ctrl(struct file *file, void *priv,
-					struct v4l2_control *ctrl)
-{
-	struct fmi *fmi = video_drvdata(file);
-
-	switch (ctrl->id) {
-	case V4L2_CID_AUDIO_MUTE:
-		if (ctrl->value)
+		if (ctrl->val)
 			fmi_mute(fmi);
 		else
 			fmi_unmute(fmi);
-		fmi->mute = ctrl->value;
+		fmi->mute = ctrl->val;
 		return 0;
 	}
 	return -EINVAL;
 }
 
+static const struct v4l2_ctrl_ops fmi_ctrl_ops = {
+	.s_ctrl = fmi_s_ctrl,
+};
+
 static const struct v4l2_file_operations fmi_fops = {
 	.owner		= THIS_MODULE,
 	.unlocked_ioctl	= video_ioctl2,
@@ -229,9 +211,6 @@ static const struct v4l2_ioctl_ops fmi_ioctl_ops = {
 	.vidioc_s_tuner     = vidioc_s_tuner,
 	.vidioc_g_frequency = vidioc_g_frequency,
 	.vidioc_s_frequency = vidioc_s_frequency,
-	.vidioc_queryctrl   = vidioc_queryctrl,
-	.vidioc_g_ctrl      = vidioc_g_ctrl,
-	.vidioc_s_ctrl      = vidioc_s_ctrl,
 };
 
 /* ladis: this is my card. does any other types exist? */
@@ -281,6 +260,7 @@ static int __init fmi_init(void)
 {
 	struct fmi *fmi = &fmi_card;
 	struct v4l2_device *v4l2_dev = &fmi->v4l2_dev;
+	struct v4l2_ctrl_handler *hdl = &fmi->hdl;
 	int res, i;
 	int probe_ports[] = { 0, 0x284, 0x384 };
 
@@ -333,6 +313,18 @@ static int __init fmi_init(void)
 		return res;
 	}
 
+	v4l2_ctrl_handler_init(hdl, 1);
+	v4l2_ctrl_new_std(hdl, &fmi_ctrl_ops,
+			V4L2_CID_AUDIO_MUTE, 0, 1, 1, 1);
+	v4l2_dev->ctrl_handler = hdl;
+	if (hdl->error) {
+		res = hdl->error;
+		v4l2_err(v4l2_dev, "Could not register controls\n");
+		v4l2_ctrl_handler_free(hdl);
+		v4l2_device_unregister(v4l2_dev);
+		return res;
+	}
+
 	strlcpy(fmi->vdev.name, v4l2_dev->name, sizeof(fmi->vdev.name));
 	fmi->vdev.v4l2_dev = v4l2_dev;
 	fmi->vdev.fops = &fmi_fops;
@@ -346,6 +338,7 @@ static int __init fmi_init(void)
 	fmi_mute(fmi);
 
 	if (video_register_device(&fmi->vdev, VFL_TYPE_RADIO, radio_nr) < 0) {
+		v4l2_ctrl_handler_free(hdl);
 		v4l2_device_unregister(v4l2_dev);
 		release_region(fmi->io, 2);
 		if (pnp_attached)
@@ -361,6 +354,7 @@ static void __exit fmi_exit(void)
 {
 	struct fmi *fmi = &fmi_card;
 
+	v4l2_ctrl_handler_free(&fmi->hdl);
 	video_unregister_device(&fmi->vdev);
 	v4l2_device_unregister(&fmi->v4l2_dev);
 	release_region(fmi->io, 2);

commit 96bb42b8ab3d4f15b5e98a65c6d8decf36f3f930
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Fri May 31 06:21:03 2013 -0300

    [media] radio-sf16fmi: clamp frequency
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Cc: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-sf16fmi.c b/drivers/media/radio/radio-sf16fmi.c
index 80beda7781bc..9cd0338a3d2b 100644
--- a/drivers/media/radio/radio-sf16fmi.c
+++ b/drivers/media/radio/radio-sf16fmi.c
@@ -55,8 +55,8 @@ static struct fmi fmi_card;
 static struct pnp_dev *dev;
 bool pnp_attached;
 
-#define RSF16_MINFREQ (87 * 16000)
-#define RSF16_MAXFREQ (108 * 16000)
+#define RSF16_MINFREQ (87U * 16000)
+#define RSF16_MAXFREQ (108U * 16000)
 
 #define FMI_BIT_TUN_CE		(1 << 0)
 #define FMI_BIT_TUN_CLK		(1 << 1)
@@ -155,15 +155,14 @@ static int vidioc_s_frequency(struct file *file, void *priv,
 					const struct v4l2_frequency *f)
 {
 	struct fmi *fmi = video_drvdata(file);
+	unsigned freq = f->frequency;
 
 	if (f->tuner != 0 || f->type != V4L2_TUNER_RADIO)
 		return -EINVAL;
-	if (f->frequency < RSF16_MINFREQ ||
-			f->frequency > RSF16_MAXFREQ)
-		return -EINVAL;
+	clamp(freq, RSF16_MINFREQ, RSF16_MAXFREQ);
 	/* rounding in steps of 800 to match the freq
 	   that will be used */
-	lm7000_set_freq((f->frequency / 800) * 800, fmi, fmi_set_pins);
+	lm7000_set_freq((freq / 800) * 800, fmi, fmi_set_pins);
 	return 0;
 }
 

commit f90842d62b16356a8316528c91d0757a17d3e9e3
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Sun Feb 3 09:44:14 2013 -0300

    [media] radio-sf16fmi: add device_caps support to querycap
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Cc: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-sf16fmi.c b/drivers/media/radio/radio-sf16fmi.c
index c1d51ec72831..80beda7781bc 100644
--- a/drivers/media/radio/radio-sf16fmi.c
+++ b/drivers/media/radio/radio-sf16fmi.c
@@ -121,7 +121,8 @@ static int vidioc_querycap(struct file *file, void  *priv,
 	strlcpy(v->driver, "radio-sf16fmi", sizeof(v->driver));
 	strlcpy(v->card, "SF16-FMI/FMP/FMD radio", sizeof(v->card));
 	strlcpy(v->bus_info, "ISA", sizeof(v->bus_info));
-	v->capabilities = V4L2_CAP_TUNER | V4L2_CAP_RADIO;
+	v->device_caps = V4L2_CAP_TUNER | V4L2_CAP_RADIO;
+	v->capabilities = v->device_caps | V4L2_CAP_DEVICE_CAPS;
 	return 0;
 }
 

commit 65a110dfb8f6c307712e3296a0f6312c3a211eb6
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Sun Feb 3 09:43:15 2013 -0300

    [media] radio-sf16fmi: remove audio/input ioctls
    
    The audio and input ioctls do not apply to radio devices. Remove them.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Cc: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-sf16fmi.c b/drivers/media/radio/radio-sf16fmi.c
index adfcc61bdf0b..c1d51ec72831 100644
--- a/drivers/media/radio/radio-sf16fmi.c
+++ b/drivers/media/radio/radio-sf16fmi.c
@@ -218,32 +218,6 @@ static int vidioc_s_ctrl(struct file *file, void *priv,
 	return -EINVAL;
 }
 
-static int vidioc_g_input(struct file *filp, void *priv, unsigned int *i)
-{
-	*i = 0;
-	return 0;
-}
-
-static int vidioc_s_input(struct file *filp, void *priv, unsigned int i)
-{
-	return i ? -EINVAL : 0;
-}
-
-static int vidioc_g_audio(struct file *file, void *priv,
-					struct v4l2_audio *a)
-{
-	a->index = 0;
-	strlcpy(a->name, "Radio", sizeof(a->name));
-	a->capability = V4L2_AUDCAP_STEREO;
-	return 0;
-}
-
-static int vidioc_s_audio(struct file *file, void *priv,
-					const struct v4l2_audio *a)
-{
-	return a->index ? -EINVAL : 0;
-}
-
 static const struct v4l2_file_operations fmi_fops = {
 	.owner		= THIS_MODULE,
 	.unlocked_ioctl	= video_ioctl2,
@@ -253,10 +227,6 @@ static const struct v4l2_ioctl_ops fmi_ioctl_ops = {
 	.vidioc_querycap    = vidioc_querycap,
 	.vidioc_g_tuner     = vidioc_g_tuner,
 	.vidioc_s_tuner     = vidioc_s_tuner,
-	.vidioc_g_audio     = vidioc_g_audio,
-	.vidioc_s_audio     = vidioc_s_audio,
-	.vidioc_g_input     = vidioc_g_input,
-	.vidioc_s_input     = vidioc_s_input,
 	.vidioc_g_frequency = vidioc_g_frequency,
 	.vidioc_s_frequency = vidioc_s_frequency,
 	.vidioc_queryctrl   = vidioc_queryctrl,

commit 2f73c7c582a685b3198b974cd6d964d0338f8ab5
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Fri Mar 15 06:10:06 2013 -0300

    [media] v4l2: add const to argument of write-only s_tuner ioctl
    
    This ioctl is defined as IOW, so pass the argument as const.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Acked-by: Alexey Klimov <klimov.linux@gmail.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-sf16fmi.c b/drivers/media/radio/radio-sf16fmi.c
index 6142b5b3e81b..adfcc61bdf0b 100644
--- a/drivers/media/radio/radio-sf16fmi.c
+++ b/drivers/media/radio/radio-sf16fmi.c
@@ -145,7 +145,7 @@ static int vidioc_g_tuner(struct file *file, void *priv,
 }
 
 static int vidioc_s_tuner(struct file *file, void *priv,
-					struct v4l2_tuner *v)
+					const struct v4l2_tuner *v)
 {
 	return v->index ? -EINVAL : 0;
 }

commit b530a447bb588fdf43fdf4eb909e4ee1921d47ac
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Tue Mar 19 04:09:26 2013 -0300

    [media] v4l2: add const to argument of write-only s_frequency ioctl
    
    This ioctl is defined as IOW, so pass the argument as const.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-sf16fmi.c b/drivers/media/radio/radio-sf16fmi.c
index 637a55564958..6142b5b3e81b 100644
--- a/drivers/media/radio/radio-sf16fmi.c
+++ b/drivers/media/radio/radio-sf16fmi.c
@@ -151,7 +151,7 @@ static int vidioc_s_tuner(struct file *file, void *priv,
 }
 
 static int vidioc_s_frequency(struct file *file, void *priv,
-					struct v4l2_frequency *f)
+					const struct v4l2_frequency *f)
 {
 	struct fmi *fmi = video_drvdata(file);
 

commit 4c62e9764ab403d42f9b8871b1241fe7812f19d4
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Dec 21 13:17:53 2012 -0800

    Drivers: media: remove __dev* attributes.
    
    CONFIG_HOTPLUG is going away as an option.  As a result, the __dev*
    markings need to be removed.
    
    This change removes the use of __devinit, __devexit_p, __devinitdata,
    __devinitconst, and __devexit from these drivers.
    
    Based on patches originally written by Bill Pemberton, but redone by me
    in order to handle some of the coding style issues better, by hand.
    
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Mauro Carvalho Chehab <mchehab@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/media/radio/radio-sf16fmi.c b/drivers/media/radio/radio-sf16fmi.c
index c260a2a354b1..637a55564958 100644
--- a/drivers/media/radio/radio-sf16fmi.c
+++ b/drivers/media/radio/radio-sf16fmi.c
@@ -265,7 +265,7 @@ static const struct v4l2_ioctl_ops fmi_ioctl_ops = {
 };
 
 /* ladis: this is my card. does any other types exist? */
-static struct isapnp_device_id id_table[] __devinitdata = {
+static struct isapnp_device_id id_table[] = {
 		/* SF16-FMI */
 	{	ISAPNP_ANY_ID, ISAPNP_ANY_ID,
 		ISAPNP_VENDOR('M','F','R'), ISAPNP_FUNCTION(0xad10), 0},

commit a5133b17df6b4a8d68f39a89967938d87d892a46
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Sat Oct 27 13:43:05 2012 -0300

    [media] radio-sf16fmi: get rid of warning: no previous prototype
    
    drivers/media/radio/radio-sf16fmi.c:67:6: warning: no previous prototype for 'fmi_set_pins' [-Wmissing-prototypes]
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-sf16fmi.c b/drivers/media/radio/radio-sf16fmi.c
index 227dcdb54df3..c260a2a354b1 100644
--- a/drivers/media/radio/radio-sf16fmi.c
+++ b/drivers/media/radio/radio-sf16fmi.c
@@ -64,7 +64,7 @@ bool pnp_attached;
 #define FMI_BIT_VOL_SW		(1 << 3)
 #define FMI_BIT_TUN_STRQ	(1 << 4)
 
-void fmi_set_pins(void *handle, u8 pins)
+static void fmi_set_pins(void *handle, u8 pins)
 {
 	struct fmi *fmi = handle;
 	u8 bits = FMI_BIT_TUN_STRQ;

commit 0e8025b9f6011a6bd69d01080d584bc95a89d02e
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Tue Sep 4 11:59:31 2012 -0300

    [media] v4l2: make vidioc_s_audio const
    
    Write-only ioctls should have a const argument in the ioctl op.
    Do this conversion for vidioc_s_audio.
    Adding const for write-only ioctls was decided during the 2012 Media Workshop.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-sf16fmi.c b/drivers/media/radio/radio-sf16fmi.c
index 8185d5fbfa89..227dcdb54df3 100644
--- a/drivers/media/radio/radio-sf16fmi.c
+++ b/drivers/media/radio/radio-sf16fmi.c
@@ -239,7 +239,7 @@ static int vidioc_g_audio(struct file *file, void *priv,
 }
 
 static int vidioc_s_audio(struct file *file, void *priv,
-					struct v4l2_audio *a)
+					const struct v4l2_audio *a)
 {
 	return a->index ? -EINVAL : 0;
 }

commit 6b39023a362ef9f12c29de6574fe2522e7ad2060
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Wed Jun 13 17:25:44 2012 -0300

    [media] radio-sf16fmi: Use LM7000 driver
    
    Convert radio-sf16fmi to use generic LM7000 driver.
    Tested with SF16-FMI, SF16-FMP and SF16-FMD.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-sf16fmi.c b/drivers/media/radio/radio-sf16fmi.c
index a81d723b8c77..8185d5fbfa89 100644
--- a/drivers/media/radio/radio-sf16fmi.c
+++ b/drivers/media/radio/radio-sf16fmi.c
@@ -27,6 +27,7 @@
 #include <linux/io.h>		/* outb, outb_p			*/
 #include <media/v4l2-device.h>
 #include <media/v4l2-ioctl.h>
+#include "lm7000.h"
 
 MODULE_AUTHOR("Petr Vandrovec, vandrove@vc.cvut.cz and M. Kirkwood");
 MODULE_DESCRIPTION("A driver for the SF16-FMI, SF16-FMP and SF16-FMD radio.");
@@ -54,31 +55,33 @@ static struct fmi fmi_card;
 static struct pnp_dev *dev;
 bool pnp_attached;
 
-/* freq is in 1/16 kHz to internal number, hw precision is 50 kHz */
-/* It is only useful to give freq in interval of 800 (=0.05Mhz),
- * other bits will be truncated, e.g 92.7400016 -> 92.7, but
- * 92.7400017 -> 92.75
- */
-#define RSF16_ENCODE(x)	((x) / 800 + 214)
 #define RSF16_MINFREQ (87 * 16000)
 #define RSF16_MAXFREQ (108 * 16000)
 
-static void outbits(int bits, unsigned int data, int io)
+#define FMI_BIT_TUN_CE		(1 << 0)
+#define FMI_BIT_TUN_CLK		(1 << 1)
+#define FMI_BIT_TUN_DATA	(1 << 2)
+#define FMI_BIT_VOL_SW		(1 << 3)
+#define FMI_BIT_TUN_STRQ	(1 << 4)
+
+void fmi_set_pins(void *handle, u8 pins)
 {
-	while (bits--) {
-		if (data & 1) {
-			outb(5, io);
-			udelay(6);
-			outb(7, io);
-			udelay(6);
-		} else {
-			outb(1, io);
-			udelay(6);
-			outb(3, io);
-			udelay(6);
-		}
-		data >>= 1;
-	}
+	struct fmi *fmi = handle;
+	u8 bits = FMI_BIT_TUN_STRQ;
+
+	if (!fmi->mute)
+		bits |= FMI_BIT_VOL_SW;
+
+	if (pins & LM7000_DATA)
+		bits |= FMI_BIT_TUN_DATA;
+	if (pins & LM7000_CLK)
+		bits |= FMI_BIT_TUN_CLK;
+	if (pins & LM7000_CE)
+		bits |= FMI_BIT_TUN_CE;
+
+	mutex_lock(&fmi->lock);
+	outb_p(bits, fmi->io);
+	mutex_unlock(&fmi->lock);
 }
 
 static inline void fmi_mute(struct fmi *fmi)
@@ -95,20 +98,6 @@ static inline void fmi_unmute(struct fmi *fmi)
 	mutex_unlock(&fmi->lock);
 }
 
-static inline int fmi_setfreq(struct fmi *fmi, unsigned long freq)
-{
-	mutex_lock(&fmi->lock);
-	fmi->curfreq = freq;
-
-	outbits(16, RSF16_ENCODE(freq), fmi->io);
-	outbits(8, 0xC0, fmi->io);
-	msleep(143);		/* was schedule_timeout(HZ/7) */
-	mutex_unlock(&fmi->lock);
-	if (!fmi->mute)
-		fmi_unmute(fmi);
-	return 0;
-}
-
 static inline int fmi_getsigstr(struct fmi *fmi)
 {
 	int val;
@@ -173,7 +162,7 @@ static int vidioc_s_frequency(struct file *file, void *priv,
 		return -EINVAL;
 	/* rounding in steps of 800 to match the freq
 	   that will be used */
-	fmi_setfreq(fmi, (f->frequency / 800) * 800);
+	lm7000_set_freq((f->frequency / 800) * 800, fmi, fmi_set_pins);
 	return 0;
 }
 

commit 6d642d26065c5d375fbb819dbfd8f5d1b9255ece
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Mon Jun 25 11:05:15 2012 -0300

    Revert "[media] radio-sf16fmi: Use LM7000 driver"
    
    This reverts commit 1e70a6cf7e965bafd89bf363772eb1a4b8e35934.
    
    As requested by Hans Verkuil:
    > You accidentally merged the wrong first version of the lm7000 patch series.
    >
    > These are the correct second version patches:
    >
    > http://patchwork.linuxtv.org/patch/11689/
    > http://patchwork.linuxtv.org/patch/11690/
    > http://patchwork.linuxtv.org/patch/11691/
    >
    > The second version is much simpler and doesn't require the creation of a whole
    > new driver.
    
    Requested-by: Hans Verkuil <hverkuil@xs4all.nl>
    Cc: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-sf16fmi.c b/drivers/media/radio/radio-sf16fmi.c
index ddd922dd8adb..a81d723b8c77 100644
--- a/drivers/media/radio/radio-sf16fmi.c
+++ b/drivers/media/radio/radio-sf16fmi.c
@@ -27,8 +27,6 @@
 #include <linux/io.h>		/* outb, outb_p			*/
 #include <media/v4l2-device.h>
 #include <media/v4l2-ioctl.h>
-#include <media/v4l2-ctrls.h>
-#include "lm7000.h"
 
 MODULE_AUTHOR("Petr Vandrovec, vandrove@vc.cvut.cz and M. Kirkwood");
 MODULE_DESCRIPTION("A driver for the SF16-FMI, SF16-FMP and SF16-FMD radio.");

commit 1e70a6cf7e965bafd89bf363772eb1a4b8e35934
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Tue Jun 12 14:38:07 2012 -0300

    [media] radio-sf16fmi: Use LM7000 driver
    
    Convert radio-sf16fmi to use generic LM7000 driver.
    Tested with SF16-FMI, SF16-FMP and SF16-FMD.
    
    radio.");
    @@ -48,37 +50,40 @@ struct fmi
            bool mute;
            unsigned long curfreq; /* freq in kHz */
            struct mutex lock;
    +       struct lm7000 lm;
     };
    
     static struct fmi fmi_card;
     static struct pnp_dev *dev;
     bool pnp_attached;
    
    -/* freq is in 1/16 kHz to internal number, hw precision is 50 kHz */
    -/* It is only useful to give freq in interval of 800 (=0.05Mhz),
    - * other bits will be truncated, e.g 92.7400016 -> 92.7, but
    - * 92.7400017 -> 92.75
    - */
    -#define RSF16_ENCODE(x)        ((x) / 800 + 214)
     #define RSF16_MINFREQ (87 * 16000)
     #define RSF16_MAXFREQ (108 * 16000)
    
    -static void outbits(int bits, unsigned int data, int io)
    +#define FMI_BIT_TUN_CE         (1 << 0)
    +#define FMI_BIT_TUN_CLK                (1 << 1)
    +#define FMI_BIT_TUN_DATA       (1 << 2)
    +#define FMI_BIT_VOL_SW         (1 << 3)
    +#define FMI_BIT_TUN_STRQ       (1 << 4)
    +
    +void fmi_set_pins(struct lm7000 *lm, u8 pins)
     {
    -       while (bits--) {
    -               if (data & 1) {
    -                       outb(5, io);
    -                       udelay(6);
    -                       outb(7, io);
    -                       udelay(6);
    -               } else {
    -                       outb(1, io);
    -                       udelay(6);
    -                       outb(3, io);
    -                       udelay(6);
    -               }
    -               data >>= 1;
    -       }
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Acked-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-sf16fmi.c b/drivers/media/radio/radio-sf16fmi.c
index a81d723b8c77..ddd922dd8adb 100644
--- a/drivers/media/radio/radio-sf16fmi.c
+++ b/drivers/media/radio/radio-sf16fmi.c
@@ -27,6 +27,8 @@
 #include <linux/io.h>		/* outb, outb_p			*/
 #include <media/v4l2-device.h>
 #include <media/v4l2-ioctl.h>
+#include <media/v4l2-ctrls.h>
+#include "lm7000.h"
 
 MODULE_AUTHOR("Petr Vandrovec, vandrove@vc.cvut.cz and M. Kirkwood");
 MODULE_DESCRIPTION("A driver for the SF16-FMI, SF16-FMP and SF16-FMD radio.");

commit abed623ca59a7d1abed6c4e7459be03e25a90a1e
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Sat May 19 13:18:26 2012 -0300

    [media] radio-sf16fmi: add support for SF16-FMD
    
    Add support for SF16-FMD card to radio-sf16fmi driver.
    Only new PnP ID is added and texts changed.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-sf16fmi.c b/drivers/media/radio/radio-sf16fmi.c
index 22c5743bf9db..a81d723b8c77 100644
--- a/drivers/media/radio/radio-sf16fmi.c
+++ b/drivers/media/radio/radio-sf16fmi.c
@@ -1,4 +1,4 @@
-/* SF16-FMI and SF16-FMP radio driver for Linux radio support
+/* SF16-FMI, SF16-FMP and SF16-FMD radio driver for Linux radio support
  * heavily based on rtrack driver...
  * (c) 1997 M. Kirkwood
  * (c) 1998 Petr Vandrovec, vandrove@vc.cvut.cz
@@ -11,7 +11,7 @@
  *
  *  Frequency control is done digitally -- ie out(port,encodefreq(95.8));
  *  No volume control - only mute/unmute - you have to use line volume
- *  control on SB-part of SF16-FMI/SF16-FMP
+ *  control on SB-part of SF16-FMI/SF16-FMP/SF16-FMD
  *
  * Converted to V4L2 API by Mauro Carvalho Chehab <mchehab@infradead.org>
  */
@@ -29,7 +29,7 @@
 #include <media/v4l2-ioctl.h>
 
 MODULE_AUTHOR("Petr Vandrovec, vandrove@vc.cvut.cz and M. Kirkwood");
-MODULE_DESCRIPTION("A driver for the SF16-FMI and SF16-FMP radio.");
+MODULE_DESCRIPTION("A driver for the SF16-FMI, SF16-FMP and SF16-FMD radio.");
 MODULE_LICENSE("GPL");
 MODULE_VERSION("0.0.3");
 
@@ -37,7 +37,7 @@ static int io = -1;
 static int radio_nr = -1;
 
 module_param(io, int, 0);
-MODULE_PARM_DESC(io, "I/O address of the SF16-FMI or SF16-FMP card (0x284 or 0x384)");
+MODULE_PARM_DESC(io, "I/O address of the SF16-FMI/SF16-FMP/SF16-FMD card (0x284 or 0x384)");
 module_param(radio_nr, int, 0);
 
 struct fmi
@@ -130,7 +130,7 @@ static int vidioc_querycap(struct file *file, void  *priv,
 					struct v4l2_capability *v)
 {
 	strlcpy(v->driver, "radio-sf16fmi", sizeof(v->driver));
-	strlcpy(v->card, "SF16-FMx radio", sizeof(v->card));
+	strlcpy(v->card, "SF16-FMI/FMP/FMD radio", sizeof(v->card));
 	strlcpy(v->bus_info, "ISA", sizeof(v->bus_info));
 	v->capabilities = V4L2_CAP_TUNER | V4L2_CAP_RADIO;
 	return 0;
@@ -277,8 +277,12 @@ static const struct v4l2_ioctl_ops fmi_ioctl_ops = {
 
 /* ladis: this is my card. does any other types exist? */
 static struct isapnp_device_id id_table[] __devinitdata = {
+		/* SF16-FMI */
 	{	ISAPNP_ANY_ID, ISAPNP_ANY_ID,
 		ISAPNP_VENDOR('M','F','R'), ISAPNP_FUNCTION(0xad10), 0},
+		/* SF16-FMD */
+	{	ISAPNP_ANY_ID, ISAPNP_ANY_ID,
+		ISAPNP_VENDOR('M','F','R'), ISAPNP_FUNCTION(0xad12), 0},
 	{	ISAPNP_CARD_END, },
 };
 

commit 29834c1ac7589c72996c5d02349d63fd397ef131
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Sat Jun 25 10:15:42 2011 -0300

    [media] radio: Use the subsystem version control for VIDIOC_QUERYCAP
    
    Just like the video drivers, the right thing to do is to use
    the per-subsystem version control.
    
    Acked-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-sf16fmi.c b/drivers/media/radio/radio-sf16fmi.c
index b5a5f89e238a..22c5743bf9db 100644
--- a/drivers/media/radio/radio-sf16fmi.c
+++ b/drivers/media/radio/radio-sf16fmi.c
@@ -16,7 +16,6 @@
  * Converted to V4L2 API by Mauro Carvalho Chehab <mchehab@infradead.org>
  */
 
-#include <linux/version.h>
 #include <linux/kernel.h>	/* __setup			*/
 #include <linux/module.h>	/* Modules 			*/
 #include <linux/init.h>		/* Initdata			*/
@@ -32,6 +31,7 @@
 MODULE_AUTHOR("Petr Vandrovec, vandrove@vc.cvut.cz and M. Kirkwood");
 MODULE_DESCRIPTION("A driver for the SF16-FMI and SF16-FMP radio.");
 MODULE_LICENSE("GPL");
+MODULE_VERSION("0.0.3");
 
 static int io = -1;
 static int radio_nr = -1;
@@ -40,8 +40,6 @@ module_param(io, int, 0);
 MODULE_PARM_DESC(io, "I/O address of the SF16-FMI or SF16-FMP card (0x284 or 0x384)");
 module_param(radio_nr, int, 0);
 
-#define RADIO_VERSION KERNEL_VERSION(0, 0, 2)
-
 struct fmi
 {
 	struct v4l2_device v4l2_dev;
@@ -134,7 +132,6 @@ static int vidioc_querycap(struct file *file, void  *priv,
 	strlcpy(v->driver, "radio-sf16fmi", sizeof(v->driver));
 	strlcpy(v->card, "SF16-FMx radio", sizeof(v->card));
 	strlcpy(v->bus_info, "ISA", sizeof(v->bus_info));
-	v->version = RADIO_VERSION;
 	v->capabilities = V4L2_CAP_TUNER | V4L2_CAP_RADIO;
 	return 0;
 }

commit 32958fdd1663aeaa23b5edbfbb0db684ffd4e20e
Author: Hans Verkuil <hverkuil@xs4all.nl>
Date:   Sun Nov 14 09:36:23 2010 -0300

    [media] BKL: trivial BKL removal from V4L2 radio drivers
    
    The patch converts a bunch of V4L2 radio drivers to unlocked_ioctl.
    
    These are all simple conversions: most already had a lock and so the ioctl
    fop could simply be replaced by unlocked_ioctl.
    
    radio-miropcm20.c was converted to use the new V4L2 core lock.
    
    While doing this work I noticed that many of these drivers initialized
    some more fields or muted audio or something like that *after* creating
    the device node. This should be done before the device node is created
    to prevent problems. Especially hal tends to grab a device node as soon
    as it is created.
    
    In one or two cases the mutex_init was even done after the device creation!
    
    Signed-off-by: Hans Verkuil <hverkuil@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-sf16fmi.c b/drivers/media/radio/radio-sf16fmi.c
index 985359d18aa5..b5a5f89e238a 100644
--- a/drivers/media/radio/radio-sf16fmi.c
+++ b/drivers/media/radio/radio-sf16fmi.c
@@ -260,7 +260,7 @@ static int vidioc_s_audio(struct file *file, void *priv,
 
 static const struct v4l2_file_operations fmi_fops = {
 	.owner		= THIS_MODULE,
-	.ioctl		= video_ioctl2,
+	.unlocked_ioctl	= video_ioctl2,
 };
 
 static const struct v4l2_ioctl_ops fmi_ioctl_ops = {
@@ -382,6 +382,9 @@ static int __init fmi_init(void)
 
 	mutex_init(&fmi->lock);
 
+	/* mute card - prevents noisy bootups */
+	fmi_mute(fmi);
+
 	if (video_register_device(&fmi->vdev, VFL_TYPE_RADIO, radio_nr) < 0) {
 		v4l2_device_unregister(v4l2_dev);
 		release_region(fmi->io, 2);
@@ -391,8 +394,6 @@ static int __init fmi_init(void)
 	}
 
 	v4l2_info(v4l2_dev, "card driver at 0x%x\n", fmi->io);
-	/* mute card - prevents noisy bootups */
-	fmi_mute(fmi);
 	return 0;
 }
 

commit 67cabf503cd0ad7473cf1856f9c9bb6320098be6
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Thu Dec 10 17:12:32 2009 -0300

    V4L/DVB (13609): radio-sf16fmi: add autoprobing
    
    Add automatic probing of ports 0x284 and 0x384 to radio-sf16fmi if no card is
    found using PnP.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Douglas Schilling Landgraf <dougsland@redhat.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-sf16fmi.c b/drivers/media/radio/radio-sf16fmi.c
index e9ecfe11cda5..985359d18aa5 100644
--- a/drivers/media/radio/radio-sf16fmi.c
+++ b/drivers/media/radio/radio-sf16fmi.c
@@ -54,6 +54,7 @@ struct fmi
 
 static struct fmi fmi_card;
 static struct pnp_dev *dev;
+bool pnp_attached;
 
 /* freq is in 1/16 kHz to internal number, hw precision is 50 kHz */
 /* It is only useful to give freq in interval of 800 (=0.05Mhz),
@@ -320,26 +321,54 @@ static int __init fmi_init(void)
 {
 	struct fmi *fmi = &fmi_card;
 	struct v4l2_device *v4l2_dev = &fmi->v4l2_dev;
-	int res;
+	int res, i;
+	int probe_ports[] = { 0, 0x284, 0x384 };
+
+	if (io < 0) {
+		for (i = 0; i < ARRAY_SIZE(probe_ports); i++) {
+			io = probe_ports[i];
+			if (io == 0) {
+				io = isapnp_fmi_probe();
+				if (io < 0)
+					continue;
+				pnp_attached = 1;
+			}
+			if (!request_region(io, 2, "radio-sf16fmi")) {
+				if (pnp_attached)
+					pnp_device_detach(dev);
+				io = -1;
+				continue;
+			}
+			if (pnp_attached ||
+			    ((inb(io) & 0xf9) == 0xf9 && (inb(io) & 0x4) == 0))
+				break;
+			release_region(io, 2);
+			io = -1;
+		}
+	} else {
+		if (!request_region(io, 2, "radio-sf16fmi")) {
+			printk(KERN_ERR "radio-sf16fmi: port %#x already in use\n", io);
+			return -EBUSY;
+		}
+		if (inb(io) == 0xff) {
+			printk(KERN_ERR "radio-sf16fmi: card not present at %#x\n", io);
+			release_region(io, 2);
+			return -ENODEV;
+		}
+	}
+	if (io < 0) {
+		printk(KERN_ERR "radio-sf16fmi: no cards found\n");
+		return -ENODEV;
+	}
 
-	if (io < 0)
-		io = isapnp_fmi_probe();
 	strlcpy(v4l2_dev->name, "sf16fmi", sizeof(v4l2_dev->name));
 	fmi->io = io;
-	if (fmi->io < 0) {
-		v4l2_err(v4l2_dev, "No PnP card found.\n");
-		return fmi->io;
-	}
-	if (!request_region(io, 2, "radio-sf16fmi")) {
-		v4l2_err(v4l2_dev, "port 0x%x already in use\n", fmi->io);
-		pnp_device_detach(dev);
-		return -EBUSY;
-	}
 
 	res = v4l2_device_register(NULL, v4l2_dev);
 	if (res < 0) {
 		release_region(fmi->io, 2);
-		pnp_device_detach(dev);
+		if (pnp_attached)
+			pnp_device_detach(dev);
 		v4l2_err(v4l2_dev, "Could not register v4l2_device\n");
 		return res;
 	}
@@ -356,7 +385,8 @@ static int __init fmi_init(void)
 	if (video_register_device(&fmi->vdev, VFL_TYPE_RADIO, radio_nr) < 0) {
 		v4l2_device_unregister(v4l2_dev);
 		release_region(fmi->io, 2);
-		pnp_device_detach(dev);
+		if (pnp_attached)
+			pnp_device_detach(dev);
 		return -EINVAL;
 	}
 
@@ -373,7 +403,7 @@ static void __exit fmi_exit(void)
 	video_unregister_device(&fmi->vdev);
 	v4l2_device_unregister(&fmi->v4l2_dev);
 	release_region(fmi->io, 2);
-	if (dev)
+	if (dev && pnp_attached)
 		pnp_device_detach(dev);
 }
 

commit 4b8303747474033d6d73828607eafab77c620d96
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Thu Dec 10 17:06:44 2009 -0300

    V4L/DVB (13608): radio-sf16fmi: fix mute, add SF16-FMP to texts
    
    Fix completely broken mute handling radio-sf16fmi.
    The sound was muted immediately after tuning in KRadio.
    Also fix typos and add SF16-FMP to the texts.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Acked-by: Petr Vandrovec <petr@vandrovec.name>
    Signed-off-by: Douglas Schilling Landgraf <dougsland@redhat.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-sf16fmi.c b/drivers/media/radio/radio-sf16fmi.c
index 93990b7899ec..e9ecfe11cda5 100644
--- a/drivers/media/radio/radio-sf16fmi.c
+++ b/drivers/media/radio/radio-sf16fmi.c
@@ -1,4 +1,4 @@
-/* SF16FMI radio driver for Linux radio support
+/* SF16-FMI and SF16-FMP radio driver for Linux radio support
  * heavily based on rtrack driver...
  * (c) 1997 M. Kirkwood
  * (c) 1998 Petr Vandrovec, vandrove@vc.cvut.cz
@@ -11,7 +11,7 @@
  *
  *  Frequency control is done digitally -- ie out(port,encodefreq(95.8));
  *  No volume control - only mute/unmute - you have to use line volume
- *  control on SB-part of SF16FMI
+ *  control on SB-part of SF16-FMI/SF16-FMP
  *
  * Converted to V4L2 API by Mauro Carvalho Chehab <mchehab@infradead.org>
  */
@@ -30,14 +30,14 @@
 #include <media/v4l2-ioctl.h>
 
 MODULE_AUTHOR("Petr Vandrovec, vandrove@vc.cvut.cz and M. Kirkwood");
-MODULE_DESCRIPTION("A driver for the SF16MI radio.");
+MODULE_DESCRIPTION("A driver for the SF16-FMI and SF16-FMP radio.");
 MODULE_LICENSE("GPL");
 
 static int io = -1;
 static int radio_nr = -1;
 
 module_param(io, int, 0);
-MODULE_PARM_DESC(io, "I/O address of the SF16MI card (0x284 or 0x384)");
+MODULE_PARM_DESC(io, "I/O address of the SF16-FMI or SF16-FMP card (0x284 or 0x384)");
 module_param(radio_nr, int, 0);
 
 #define RADIO_VERSION KERNEL_VERSION(0, 0, 2)
@@ -47,7 +47,7 @@ struct fmi
 	struct v4l2_device v4l2_dev;
 	struct video_device vdev;
 	int io;
-	int curvol; /* 1 or 0 */
+	bool mute;
 	unsigned long curfreq; /* freq in kHz */
 	struct mutex lock;
 };
@@ -105,7 +105,7 @@ static inline int fmi_setfreq(struct fmi *fmi, unsigned long freq)
 	outbits(8, 0xC0, fmi->io);
 	msleep(143);		/* was schedule_timeout(HZ/7) */
 	mutex_unlock(&fmi->lock);
-	if (fmi->curvol)
+	if (!fmi->mute)
 		fmi_unmute(fmi);
 	return 0;
 }
@@ -116,7 +116,7 @@ static inline int fmi_getsigstr(struct fmi *fmi)
 	int res;
 
 	mutex_lock(&fmi->lock);
-	val = fmi->curvol ? 0x08 : 0x00;	/* unmute/mute */
+	val = fmi->mute ? 0x00 : 0x08;	/* mute/unmute */
 	outb(val, fmi->io);
 	outb(val | 0x10, fmi->io);
 	msleep(143); 		/* was schedule_timeout(HZ/7) */
@@ -208,7 +208,7 @@ static int vidioc_g_ctrl(struct file *file, void *priv,
 
 	switch (ctrl->id) {
 	case V4L2_CID_AUDIO_MUTE:
-		ctrl->value = fmi->curvol;
+		ctrl->value = fmi->mute;
 		return 0;
 	}
 	return -EINVAL;
@@ -225,7 +225,7 @@ static int vidioc_s_ctrl(struct file *file, void *priv,
 			fmi_mute(fmi);
 		else
 			fmi_unmute(fmi);
-		fmi->curvol = ctrl->value;
+		fmi->mute = ctrl->value;
 		return 0;
 	}
 	return -EINVAL;

commit a3a9e287daa1f299e318161b790b1c5902b1d869
Author: Hans Verkuil <hverkuil@xs4all.nl>
Date:   Fri Nov 27 04:33:25 2009 -0300

    V4L/DVB (13547): radio: add trivial checks on the tuner and type args.
    
    Many radio drivers did not check the tuner and type field correctly
    for g/s_frequency. These checks have now been added.
    
    Signed-off-by: Hans Verkuil <hverkuil@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-sf16fmi.c b/drivers/media/radio/radio-sf16fmi.c
index 49c4aab95dab..93990b7899ec 100644
--- a/drivers/media/radio/radio-sf16fmi.c
+++ b/drivers/media/radio/radio-sf16fmi.c
@@ -168,6 +168,8 @@ static int vidioc_s_frequency(struct file *file, void *priv,
 {
 	struct fmi *fmi = video_drvdata(file);
 
+	if (f->tuner != 0 || f->type != V4L2_TUNER_RADIO)
+		return -EINVAL;
 	if (f->frequency < RSF16_MINFREQ ||
 			f->frequency > RSF16_MAXFREQ)
 		return -EINVAL;
@@ -182,6 +184,8 @@ static int vidioc_g_frequency(struct file *file, void *priv,
 {
 	struct fmi *fmi = video_drvdata(file);
 
+	if (f->tuner != 0)
+		return -EINVAL;
 	f->type = V4L2_TUNER_RADIO;
 	f->frequency = fmi->curfreq;
 	return 0;

commit 38092a4402e0df6f1f283ff6e455197035266ce7
Author: Hans Verkuil <hverkuil@xs4all.nl>
Date:   Sat May 2 12:06:15 2009 -0300

    V4L/DVB (11677): radio-fm16: fix g_tuner.
    
    g_tuner handled capability, audmode and rxsubchans incorrectly.
    
    Signed-off-by: Hans Verkuil <hverkuil@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-sf16fmi.c b/drivers/media/radio/radio-sf16fmi.c
index e598b5471d8a..49c4aab95dab 100644
--- a/drivers/media/radio/radio-sf16fmi.c
+++ b/drivers/media/radio/radio-sf16fmi.c
@@ -151,7 +151,7 @@ static int vidioc_g_tuner(struct file *file, void *priv,
 	v->rangelow = RSF16_MINFREQ;
 	v->rangehigh = RSF16_MAXFREQ;
 	v->rxsubchans = V4L2_TUNER_SUB_MONO | V4L2_TUNER_SUB_STEREO;
-	v->capability = V4L2_TUNER_CAP_LOW;
+	v->capability = V4L2_TUNER_CAP_STEREO | V4L2_TUNER_CAP_LOW;
 	v->audmode = V4L2_TUNER_MODE_STEREO;
 	v->signal = fmi_getsigstr(fmi);
 	return 0;

commit 1d80db562f9ee6d6d72cdbf488493e4cd6433669
Author: Hans Verkuil <hverkuil@xs4all.nl>
Date:   Sat May 2 12:04:13 2009 -0300

    V4L/DVB (11676): radio-fm16: cleanups
    
    Remove bogus flags field
    
    Signed-off-by: Hans Verkuil <hverkuil@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-sf16fmi.c b/drivers/media/radio/radio-sf16fmi.c
index 5cf6c45b91fe..e598b5471d8a 100644
--- a/drivers/media/radio/radio-sf16fmi.c
+++ b/drivers/media/radio/radio-sf16fmi.c
@@ -49,7 +49,6 @@ struct fmi
 	int io;
 	int curvol; /* 1 or 0 */
 	unsigned long curfreq; /* freq in kHz */
-	__u32 flags;
 	struct mutex lock;
 };
 
@@ -57,7 +56,7 @@ static struct fmi fmi_card;
 static struct pnp_dev *dev;
 
 /* freq is in 1/16 kHz to internal number, hw precision is 50 kHz */
-/* It is only useful to give freq in intervall of 800 (=0.05Mhz),
+/* It is only useful to give freq in interval of 800 (=0.05Mhz),
  * other bits will be truncated, e.g 92.7400016 -> 92.7, but
  * 92.7400017 -> 92.75
  */
@@ -142,7 +141,6 @@ static int vidioc_querycap(struct file *file, void  *priv,
 static int vidioc_g_tuner(struct file *file, void *priv,
 					struct v4l2_tuner *v)
 {
-	int mult;
 	struct fmi *fmi = video_drvdata(file);
 
 	if (v->index > 0)
@@ -150,11 +148,10 @@ static int vidioc_g_tuner(struct file *file, void *priv,
 
 	strlcpy(v->name, "FM", sizeof(v->name));
 	v->type = V4L2_TUNER_RADIO;
-	mult = (fmi->flags & V4L2_TUNER_CAP_LOW) ? 1 : 1000;
-	v->rangelow = RSF16_MINFREQ / mult;
-	v->rangehigh = RSF16_MAXFREQ / mult;
+	v->rangelow = RSF16_MINFREQ;
+	v->rangehigh = RSF16_MAXFREQ;
 	v->rxsubchans = V4L2_TUNER_SUB_MONO | V4L2_TUNER_SUB_STEREO;
-	v->capability = fmi->flags & V4L2_TUNER_CAP_LOW;
+	v->capability = V4L2_TUNER_CAP_LOW;
 	v->audmode = V4L2_TUNER_MODE_STEREO;
 	v->signal = fmi_getsigstr(fmi);
 	return 0;
@@ -171,8 +168,6 @@ static int vidioc_s_frequency(struct file *file, void *priv,
 {
 	struct fmi *fmi = video_drvdata(file);
 
-	if (!(fmi->flags & V4L2_TUNER_CAP_LOW))
-		f->frequency *= 1000;
 	if (f->frequency < RSF16_MINFREQ ||
 			f->frequency > RSF16_MAXFREQ)
 		return -EINVAL;
@@ -189,8 +184,6 @@ static int vidioc_g_frequency(struct file *file, void *priv,
 
 	f->type = V4L2_TUNER_RADIO;
 	f->frequency = fmi->curfreq;
-	if (!(fmi->flags & V4L2_TUNER_CAP_LOW))
-		f->frequency /= 1000;
 	return 0;
 }
 
@@ -347,7 +340,6 @@ static int __init fmi_init(void)
 		return res;
 	}
 
-	fmi->flags = V4L2_TUNER_CAP_LOW;
 	strlcpy(fmi->vdev.name, v4l2_dev->name, sizeof(fmi->vdev.name));
 	fmi->vdev.v4l2_dev = v4l2_dev;
 	fmi->vdev.fops = &fmi_fops;

commit dc47b77897b33fca328bd4cd487224808b740ce3
Author: Hans Verkuil <hverkuil@xs4all.nl>
Date:   Sat May 2 11:52:35 2009 -0300

    V4L/DVB (11675): ivtv/radio: fix V4L2_TUNER_MODE/V4L2_TUNER_SUB confusion
    
    V4L2_TUNER_MODE_ was used in a few places where V4L2_TUNER_SUB_ should have
    been used.
    
    Signed-off-by: Hans Verkuil <hverkuil@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-sf16fmi.c b/drivers/media/radio/radio-sf16fmi.c
index 1dba8f0832a0..5cf6c45b91fe 100644
--- a/drivers/media/radio/radio-sf16fmi.c
+++ b/drivers/media/radio/radio-sf16fmi.c
@@ -153,7 +153,7 @@ static int vidioc_g_tuner(struct file *file, void *priv,
 	mult = (fmi->flags & V4L2_TUNER_CAP_LOW) ? 1 : 1000;
 	v->rangelow = RSF16_MINFREQ / mult;
 	v->rangehigh = RSF16_MAXFREQ / mult;
-	v->rxsubchans = V4L2_TUNER_SUB_MONO | V4L2_TUNER_MODE_STEREO;
+	v->rxsubchans = V4L2_TUNER_SUB_MONO | V4L2_TUNER_SUB_STEREO;
 	v->capability = fmi->flags & V4L2_TUNER_CAP_LOW;
 	v->audmode = V4L2_TUNER_MODE_STEREO;
 	v->signal = fmi_getsigstr(fmi);

commit ff1a3ebb9cd9baecd167500c660bd76129b67b1c
Author: Alexey Klimov <klimov.linux@gmail.com>
Date:   Sun Mar 29 20:19:54 2009 -0300

    V4L/DVB (11391): pci-isa radios: remove open and release functions
    
    Patch removes empty open and release functions in pci and isa radio
    drivers, setting them to NULL. V4L module doesn't call for them due to
    previous patch.
    
    Signed-off-by: Alexey Klimov <klimov.linux@gmail.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-sf16fmi.c b/drivers/media/radio/radio-sf16fmi.c
index f4784f0d1a88..1dba8f0832a0 100644
--- a/drivers/media/radio/radio-sf16fmi.c
+++ b/drivers/media/radio/radio-sf16fmi.c
@@ -260,20 +260,8 @@ static int vidioc_s_audio(struct file *file, void *priv,
 	return a->index ? -EINVAL : 0;
 }
 
-static int fmi_open(struct file *file)
-{
-	return 0;
-}
-
-static int fmi_release(struct file *file)
-{
-	return 0;
-}
-
 static const struct v4l2_file_operations fmi_fops = {
 	.owner		= THIS_MODULE,
-	.open           = fmi_open,
-	.release        = fmi_release,
 	.ioctl		= video_ioctl2,
 };
 

commit ab84f5736086b84d99015cd82515a31b95e03f48
Author: Hans Verkuil <hverkuil@xs4all.nl>
Date:   Wed Mar 11 04:25:47 2009 -0300

    V4L/DVB (10959): radio: remove uaccess include
    
    This include isn't needed and so can be removed.
    
    Signed-off-by: Hans Verkuil <hverkuil@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-sf16fmi.c b/drivers/media/radio/radio-sf16fmi.c
index 4982d0cefb4f..f4784f0d1a88 100644
--- a/drivers/media/radio/radio-sf16fmi.c
+++ b/drivers/media/radio/radio-sf16fmi.c
@@ -26,7 +26,6 @@
 #include <linux/mutex.h>
 #include <linux/videodev2.h>	/* kernel radio structs		*/
 #include <linux/io.h>		/* outb, outb_p			*/
-#include <linux/uaccess.h>	/* copy to/from user		*/
 #include <media/v4l2-device.h>
 #include <media/v4l2-ioctl.h>
 

commit c41269fd9275cce88b90af644969c6a5e2067657
Author: Hans Verkuil <hverkuil@xs4all.nl>
Date:   Fri Mar 6 13:52:34 2009 -0300

    V4L/DVB (10888): radio-sf16fmi: convert to v4l2_device.
    
    Signed-off-by: Hans Verkuil <hverkuil@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-sf16fmi.c b/drivers/media/radio/radio-sf16fmi.c
index d358e48c2422..4982d0cefb4f 100644
--- a/drivers/media/radio/radio-sf16fmi.c
+++ b/drivers/media/radio/radio-sf16fmi.c
@@ -22,113 +22,110 @@
 #include <linux/init.h>		/* Initdata			*/
 #include <linux/ioport.h>	/* request_region		*/
 #include <linux/delay.h>	/* udelay			*/
-#include <linux/videodev2.h>	/* kernel radio structs		*/
-#include <media/v4l2-common.h>
-#include <media/v4l2-ioctl.h>
 #include <linux/isapnp.h>
-#include <asm/io.h>		/* outb, outb_p			*/
-#include <asm/uaccess.h>	/* copy to/from user		*/
 #include <linux/mutex.h>
+#include <linux/videodev2.h>	/* kernel radio structs		*/
+#include <linux/io.h>		/* outb, outb_p			*/
+#include <linux/uaccess.h>	/* copy to/from user		*/
+#include <media/v4l2-device.h>
+#include <media/v4l2-ioctl.h>
 
-#define RADIO_VERSION KERNEL_VERSION(0,0,2)
+MODULE_AUTHOR("Petr Vandrovec, vandrove@vc.cvut.cz and M. Kirkwood");
+MODULE_DESCRIPTION("A driver for the SF16MI radio.");
+MODULE_LICENSE("GPL");
 
-static struct v4l2_queryctrl radio_qctrl[] = {
-	{
-		.id            = V4L2_CID_AUDIO_MUTE,
-		.name          = "Mute",
-		.minimum       = 0,
-		.maximum       = 1,
-		.default_value = 1,
-		.type          = V4L2_CTRL_TYPE_BOOLEAN,
-	}
-};
+static int io = -1;
+static int radio_nr = -1;
+
+module_param(io, int, 0);
+MODULE_PARM_DESC(io, "I/O address of the SF16MI card (0x284 or 0x384)");
+module_param(radio_nr, int, 0);
+
+#define RADIO_VERSION KERNEL_VERSION(0, 0, 2)
 
-struct fmi_device
+struct fmi
 {
-	unsigned long in_use;
-	int port;
+	struct v4l2_device v4l2_dev;
+	struct video_device vdev;
+	int io;
 	int curvol; /* 1 or 0 */
 	unsigned long curfreq; /* freq in kHz */
 	__u32 flags;
+	struct mutex lock;
 };
 
-static int io = -1;
-static int radio_nr = -1;
-static struct pnp_dev *dev = NULL;
-static struct mutex lock;
+static struct fmi fmi_card;
+static struct pnp_dev *dev;
 
 /* freq is in 1/16 kHz to internal number, hw precision is 50 kHz */
 /* It is only useful to give freq in intervall of 800 (=0.05Mhz),
  * other bits will be truncated, e.g 92.7400016 -> 92.7, but
  * 92.7400017 -> 92.75
  */
-#define RSF16_ENCODE(x)	((x)/800+214)
-#define RSF16_MINFREQ 87*16000
-#define RSF16_MAXFREQ 108*16000
+#define RSF16_ENCODE(x)	((x) / 800 + 214)
+#define RSF16_MINFREQ (87 * 16000)
+#define RSF16_MAXFREQ (108 * 16000)
 
-static void outbits(int bits, unsigned int data, int port)
+static void outbits(int bits, unsigned int data, int io)
 {
-	while(bits--) {
-		if(data & 1) {
-			outb(5, port);
+	while (bits--) {
+		if (data & 1) {
+			outb(5, io);
 			udelay(6);
-			outb(7, port);
+			outb(7, io);
 			udelay(6);
 		} else {
-			outb(1, port);
+			outb(1, io);
 			udelay(6);
-			outb(3, port);
+			outb(3, io);
 			udelay(6);
 		}
-		data>>=1;
+		data >>= 1;
 	}
 }
 
-static inline void fmi_mute(int port)
+static inline void fmi_mute(struct fmi *fmi)
 {
-	mutex_lock(&lock);
-	outb(0x00, port);
-	mutex_unlock(&lock);
+	mutex_lock(&fmi->lock);
+	outb(0x00, fmi->io);
+	mutex_unlock(&fmi->lock);
 }
 
-static inline void fmi_unmute(int port)
+static inline void fmi_unmute(struct fmi *fmi)
 {
-	mutex_lock(&lock);
-	outb(0x08, port);
-	mutex_unlock(&lock);
+	mutex_lock(&fmi->lock);
+	outb(0x08, fmi->io);
+	mutex_unlock(&fmi->lock);
 }
 
-static inline int fmi_setfreq(struct fmi_device *dev)
+static inline int fmi_setfreq(struct fmi *fmi, unsigned long freq)
 {
-	int myport = dev->port;
-	unsigned long freq = dev->curfreq;
+	mutex_lock(&fmi->lock);
+	fmi->curfreq = freq;
 
-	mutex_lock(&lock);
-
-	outbits(16, RSF16_ENCODE(freq), myport);
-	outbits(8, 0xC0, myport);
+	outbits(16, RSF16_ENCODE(freq), fmi->io);
+	outbits(8, 0xC0, fmi->io);
 	msleep(143);		/* was schedule_timeout(HZ/7) */
-	mutex_unlock(&lock);
-	if (dev->curvol) fmi_unmute(myport);
+	mutex_unlock(&fmi->lock);
+	if (fmi->curvol)
+		fmi_unmute(fmi);
 	return 0;
 }
 
-static inline int fmi_getsigstr(struct fmi_device *dev)
+static inline int fmi_getsigstr(struct fmi *fmi)
 {
 	int val;
 	int res;
-	int myport = dev->port;
-
 
-	mutex_lock(&lock);
-	val = dev->curvol ? 0x08 : 0x00;	/* unmute/mute */
-	outb(val, myport);
-	outb(val | 0x10, myport);
+	mutex_lock(&fmi->lock);
+	val = fmi->curvol ? 0x08 : 0x00;	/* unmute/mute */
+	outb(val, fmi->io);
+	outb(val | 0x10, fmi->io);
 	msleep(143); 		/* was schedule_timeout(HZ/7) */
-	res = (int)inb(myport+1);
-	outb(val, myport);
+	res = (int)inb(fmi->io + 1);
+	outb(val, fmi->io);
 
-	mutex_unlock(&lock);
+	mutex_unlock(&fmi->lock);
 	return (res & 2) ? 0 : 0xFFFF;
 }
 
@@ -137,9 +134,9 @@ static int vidioc_querycap(struct file *file, void  *priv,
 {
 	strlcpy(v->driver, "radio-sf16fmi", sizeof(v->driver));
 	strlcpy(v->card, "SF16-FMx radio", sizeof(v->card));
-	sprintf(v->bus_info, "ISA");
+	strlcpy(v->bus_info, "ISA", sizeof(v->bus_info));
 	v->version = RADIO_VERSION;
-	v->capabilities = V4L2_CAP_TUNER;
+	v->capabilities = V4L2_CAP_TUNER | V4L2_CAP_RADIO;
 	return 0;
 }
 
@@ -147,18 +144,18 @@ static int vidioc_g_tuner(struct file *file, void *priv,
 					struct v4l2_tuner *v)
 {
 	int mult;
-	struct fmi_device *fmi = video_drvdata(file);
+	struct fmi *fmi = video_drvdata(file);
 
 	if (v->index > 0)
 		return -EINVAL;
 
-	strcpy(v->name, "FM");
+	strlcpy(v->name, "FM", sizeof(v->name));
 	v->type = V4L2_TUNER_RADIO;
 	mult = (fmi->flags & V4L2_TUNER_CAP_LOW) ? 1 : 1000;
-	v->rangelow = RSF16_MINFREQ/mult;
-	v->rangehigh = RSF16_MAXFREQ/mult;
+	v->rangelow = RSF16_MINFREQ / mult;
+	v->rangehigh = RSF16_MAXFREQ / mult;
 	v->rxsubchans = V4L2_TUNER_SUB_MONO | V4L2_TUNER_MODE_STEREO;
-	v->capability = fmi->flags&V4L2_TUNER_CAP_LOW;
+	v->capability = fmi->flags & V4L2_TUNER_CAP_LOW;
 	v->audmode = V4L2_TUNER_MODE_STEREO;
 	v->signal = fmi_getsigstr(fmi);
 	return 0;
@@ -167,32 +164,29 @@ static int vidioc_g_tuner(struct file *file, void *priv,
 static int vidioc_s_tuner(struct file *file, void *priv,
 					struct v4l2_tuner *v)
 {
-	if (v->index > 0)
-		return -EINVAL;
-	return 0;
+	return v->index ? -EINVAL : 0;
 }
 
 static int vidioc_s_frequency(struct file *file, void *priv,
 					struct v4l2_frequency *f)
 {
-	struct fmi_device *fmi = video_drvdata(file);
+	struct fmi *fmi = video_drvdata(file);
 
 	if (!(fmi->flags & V4L2_TUNER_CAP_LOW))
 		f->frequency *= 1000;
 	if (f->frequency < RSF16_MINFREQ ||
-			f->frequency > RSF16_MAXFREQ )
+			f->frequency > RSF16_MAXFREQ)
 		return -EINVAL;
-	/*rounding in steps of 800 to match th freq
-	that will be used */
-	fmi->curfreq = (f->frequency/800)*800;
-	fmi_setfreq(fmi);
+	/* rounding in steps of 800 to match the freq
+	   that will be used */
+	fmi_setfreq(fmi, (f->frequency / 800) * 800);
 	return 0;
 }
 
 static int vidioc_g_frequency(struct file *file, void *priv,
 					struct v4l2_frequency *f)
 {
-	struct fmi_device *fmi = video_drvdata(file);
+	struct fmi *fmi = video_drvdata(file);
 
 	f->type = V4L2_TUNER_RADIO;
 	f->frequency = fmi->curfreq;
@@ -204,14 +198,9 @@ static int vidioc_g_frequency(struct file *file, void *priv,
 static int vidioc_queryctrl(struct file *file, void *priv,
 					struct v4l2_queryctrl *qc)
 {
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(radio_qctrl); i++) {
-		if (qc->id && qc->id == radio_qctrl[i].id) {
-			memcpy(qc, &(radio_qctrl[i]),
-						sizeof(*qc));
-			return 0;
-		}
+	switch (qc->id) {
+	case V4L2_CID_AUDIO_MUTE:
+		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 1);
 	}
 	return -EINVAL;
 }
@@ -219,7 +208,7 @@ static int vidioc_queryctrl(struct file *file, void *priv,
 static int vidioc_g_ctrl(struct file *file, void *priv,
 					struct v4l2_control *ctrl)
 {
-	struct fmi_device *fmi = video_drvdata(file);
+	struct fmi *fmi = video_drvdata(file);
 
 	switch (ctrl->id) {
 	case V4L2_CID_AUDIO_MUTE:
@@ -232,31 +221,20 @@ static int vidioc_g_ctrl(struct file *file, void *priv,
 static int vidioc_s_ctrl(struct file *file, void *priv,
 					struct v4l2_control *ctrl)
 {
-	struct fmi_device *fmi = video_drvdata(file);
+	struct fmi *fmi = video_drvdata(file);
 
 	switch (ctrl->id) {
 	case V4L2_CID_AUDIO_MUTE:
 		if (ctrl->value)
-			fmi_mute(fmi->port);
+			fmi_mute(fmi);
 		else
-			fmi_unmute(fmi->port);
+			fmi_unmute(fmi);
 		fmi->curvol = ctrl->value;
 		return 0;
 	}
 	return -EINVAL;
 }
 
-static int vidioc_g_audio(struct file *file, void *priv,
-					struct v4l2_audio *a)
-{
-	if (a->index > 1)
-		return -EINVAL;
-
-	strcpy(a->name, "Radio");
-	a->capability = V4L2_AUDCAP_STEREO;
-	return 0;
-}
-
 static int vidioc_g_input(struct file *filp, void *priv, unsigned int *i)
 {
 	*i = 0;
@@ -265,36 +243,38 @@ static int vidioc_g_input(struct file *filp, void *priv, unsigned int *i)
 
 static int vidioc_s_input(struct file *filp, void *priv, unsigned int i)
 {
-	if (i != 0)
-		return -EINVAL;
-	return 0;
+	return i ? -EINVAL : 0;
 }
 
-static int vidioc_s_audio(struct file *file, void *priv,
+static int vidioc_g_audio(struct file *file, void *priv,
 					struct v4l2_audio *a)
 {
-	if (a->index != 0)
-		return -EINVAL;
+	a->index = 0;
+	strlcpy(a->name, "Radio", sizeof(a->name));
+	a->capability = V4L2_AUDCAP_STEREO;
 	return 0;
 }
 
-static struct fmi_device fmi_unit;
+static int vidioc_s_audio(struct file *file, void *priv,
+					struct v4l2_audio *a)
+{
+	return a->index ? -EINVAL : 0;
+}
 
-static int fmi_exclusive_open(struct file *file)
+static int fmi_open(struct file *file)
 {
-	return test_and_set_bit(0, &fmi_unit.in_use) ? -EBUSY : 0;
+	return 0;
 }
 
-static int fmi_exclusive_release(struct file *file)
+static int fmi_release(struct file *file)
 {
-	clear_bit(0, &fmi_unit.in_use);
 	return 0;
 }
 
 static const struct v4l2_file_operations fmi_fops = {
 	.owner		= THIS_MODULE,
-	.open           = fmi_exclusive_open,
-	.release        = fmi_exclusive_release,
+	.open           = fmi_open,
+	.release        = fmi_release,
 	.ioctl		= video_ioctl2,
 };
 
@@ -313,13 +293,6 @@ static const struct v4l2_ioctl_ops fmi_ioctl_ops = {
 	.vidioc_s_ctrl      = vidioc_s_ctrl,
 };
 
-static struct video_device fmi_radio = {
-	.name		= "SF16FMx radio",
-	.fops           = &fmi_fops,
-	.ioctl_ops 	= &fmi_ioctl_ops,
-	.release	= video_device_release_empty,
-};
-
 /* ladis: this is my card. does any other types exist? */
 static struct isapnp_device_id id_table[] __devinitdata = {
 	{	ISAPNP_ANY_ID, ISAPNP_ANY_ID,
@@ -344,7 +317,7 @@ static int __init isapnp_fmi_probe(void)
 	if (pnp_device_attach(dev) < 0)
 		return -EAGAIN;
 	if (pnp_activate_dev(dev) < 0) {
-		printk ("radio-sf16fmi: PnP configure failed (out of resources?)\n");
+		printk(KERN_ERR "radio-sf16fmi: PnP configure failed (out of resources?)\n");
 		pnp_device_detach(dev);
 		return -ENOMEM;
 	}
@@ -354,59 +327,72 @@ static int __init isapnp_fmi_probe(void)
 	}
 
 	i = pnp_port_start(dev, 0);
-	printk ("radio-sf16fmi: PnP reports card at %#x\n", i);
+	printk(KERN_INFO "radio-sf16fmi: PnP reports card at %#x\n", i);
 
 	return i;
 }
 
 static int __init fmi_init(void)
 {
+	struct fmi *fmi = &fmi_card;
+	struct v4l2_device *v4l2_dev = &fmi->v4l2_dev;
+	int res;
+
 	if (io < 0)
 		io = isapnp_fmi_probe();
-	if (io < 0) {
-		printk(KERN_ERR "radio-sf16fmi: No PnP card found.\n");
-		return io;
+	strlcpy(v4l2_dev->name, "sf16fmi", sizeof(v4l2_dev->name));
+	fmi->io = io;
+	if (fmi->io < 0) {
+		v4l2_err(v4l2_dev, "No PnP card found.\n");
+		return fmi->io;
 	}
 	if (!request_region(io, 2, "radio-sf16fmi")) {
-		printk(KERN_ERR "radio-sf16fmi: port 0x%x already in use\n", io);
+		v4l2_err(v4l2_dev, "port 0x%x already in use\n", fmi->io);
 		pnp_device_detach(dev);
 		return -EBUSY;
 	}
 
-	fmi_unit.port = io;
-	fmi_unit.curvol = 0;
-	fmi_unit.curfreq = 0;
-	fmi_unit.flags = V4L2_TUNER_CAP_LOW;
-	video_set_drvdata(&fmi_radio, &fmi_unit);
+	res = v4l2_device_register(NULL, v4l2_dev);
+	if (res < 0) {
+		release_region(fmi->io, 2);
+		pnp_device_detach(dev);
+		v4l2_err(v4l2_dev, "Could not register v4l2_device\n");
+		return res;
+	}
+
+	fmi->flags = V4L2_TUNER_CAP_LOW;
+	strlcpy(fmi->vdev.name, v4l2_dev->name, sizeof(fmi->vdev.name));
+	fmi->vdev.v4l2_dev = v4l2_dev;
+	fmi->vdev.fops = &fmi_fops;
+	fmi->vdev.ioctl_ops = &fmi_ioctl_ops;
+	fmi->vdev.release = video_device_release_empty;
+	video_set_drvdata(&fmi->vdev, fmi);
 
-	mutex_init(&lock);
+	mutex_init(&fmi->lock);
 
-	if (video_register_device(&fmi_radio, VFL_TYPE_RADIO, radio_nr) < 0) {
-		release_region(io, 2);
+	if (video_register_device(&fmi->vdev, VFL_TYPE_RADIO, radio_nr) < 0) {
+		v4l2_device_unregister(v4l2_dev);
+		release_region(fmi->io, 2);
+		pnp_device_detach(dev);
 		return -EINVAL;
 	}
 
-	printk(KERN_INFO "SF16FMx radio card driver at 0x%x\n", io);
+	v4l2_info(v4l2_dev, "card driver at 0x%x\n", fmi->io);
 	/* mute card - prevents noisy bootups */
-	fmi_mute(io);
+	fmi_mute(fmi);
 	return 0;
 }
 
-MODULE_AUTHOR("Petr Vandrovec, vandrove@vc.cvut.cz and M. Kirkwood");
-MODULE_DESCRIPTION("A driver for the SF16MI radio.");
-MODULE_LICENSE("GPL");
-
-module_param(io, int, 0);
-MODULE_PARM_DESC(io, "I/O address of the SF16MI card (0x284 or 0x384)");
-module_param(radio_nr, int, 0);
-
-static void __exit fmi_cleanup_module(void)
+static void __exit fmi_exit(void)
 {
-	video_unregister_device(&fmi_radio);
-	release_region(io, 2);
+	struct fmi *fmi = &fmi_card;
+
+	video_unregister_device(&fmi->vdev);
+	v4l2_device_unregister(&fmi->v4l2_dev);
+	release_region(fmi->io, 2);
 	if (dev)
 		pnp_device_detach(dev);
 }
 
 module_init(fmi_init);
-module_exit(fmi_cleanup_module);
+module_exit(fmi_exit);

commit bec43661b1dc0075b7445223ba775674133b164d
Author: Hans Verkuil <hverkuil@xs4all.nl>
Date:   Tue Dec 30 06:58:20 2008 -0300

    V4L/DVB (10135): v4l2: introduce v4l2_file_operations.
    
    Introduce a struct v4l2_file_operations for v4l2 drivers.
    
    Remove the unnecessary inode argument.
    
    Move compat32 handling (and llseek) into the v4l2-dev core: this is now
    handled in the v4l2 core and no longer in the drivers themselves.
    
    Note that this changeset reverts an earlier patch that changed the return
    type of__video_ioctl2 from int to long. This change will be reinstated
    later in a much improved version.
    
    Signed-off-by: Hans Verkuil <hverkuil@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-sf16fmi.c b/drivers/media/radio/radio-sf16fmi.c
index 834d43651c70..d358e48c2422 100644
--- a/drivers/media/radio/radio-sf16fmi.c
+++ b/drivers/media/radio/radio-sf16fmi.c
@@ -280,26 +280,22 @@ static int vidioc_s_audio(struct file *file, void *priv,
 
 static struct fmi_device fmi_unit;
 
-static int fmi_exclusive_open(struct inode *inode, struct file *file)
+static int fmi_exclusive_open(struct file *file)
 {
 	return test_and_set_bit(0, &fmi_unit.in_use) ? -EBUSY : 0;
 }
 
-static int fmi_exclusive_release(struct inode *inode, struct file *file)
+static int fmi_exclusive_release(struct file *file)
 {
 	clear_bit(0, &fmi_unit.in_use);
 	return 0;
 }
 
-static const struct file_operations fmi_fops = {
+static const struct v4l2_file_operations fmi_fops = {
 	.owner		= THIS_MODULE,
 	.open           = fmi_exclusive_open,
 	.release        = fmi_exclusive_release,
 	.ioctl		= video_ioctl2,
-#ifdef CONFIG_COMPAT
-	.compat_ioctl	= v4l_compat_ioctl32,
-#endif
-	.llseek         = no_llseek,
 };
 
 static const struct v4l2_ioctl_ops fmi_ioctl_ops = {

commit d9b01449e75d1351296595e28d2af72993bcc3dc
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Mon Oct 27 15:13:47 2008 -0300

    V4L/DVB (9491): rationalise addresses to one common one
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-sf16fmi.c b/drivers/media/radio/radio-sf16fmi.c
index 329c90bddadd..834d43651c70 100644
--- a/drivers/media/radio/radio-sf16fmi.c
+++ b/drivers/media/radio/radio-sf16fmi.c
@@ -3,7 +3,7 @@
  * (c) 1997 M. Kirkwood
  * (c) 1998 Petr Vandrovec, vandrove@vc.cvut.cz
  *
- * Fitted to new interface by Alan Cox <alan.cox@linux.org>
+ * Fitted to new interface by Alan Cox <alan@lxorguk.ukuu.org.uk>
  * Made working and cleaned up functions <mikael.hedin@irf.se>
  * Support for ISAPnP by Ladislav Michl <ladis@psi.cz>
  *

commit c170ecf434bceb0e188b14a6deb3bfa3ec9ef699
Author: Hans Verkuil <hverkuil@xs4all.nl>
Date:   Sat Aug 23 08:32:09 2008 -0300

    V4L/DVB (8788): v4l: replace video_get_drvdata(video_devdata(filp)) with video_drvdata(filp)
    
    Use the new video_drvdata(filp) function where it is safe to do so.
    
    Signed-off-by: Hans Verkuil <hverkuil@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-sf16fmi.c b/drivers/media/radio/radio-sf16fmi.c
index 810c366b73b0..329c90bddadd 100644
--- a/drivers/media/radio/radio-sf16fmi.c
+++ b/drivers/media/radio/radio-sf16fmi.c
@@ -147,8 +147,7 @@ static int vidioc_g_tuner(struct file *file, void *priv,
 					struct v4l2_tuner *v)
 {
 	int mult;
-	struct video_device *dev = video_devdata(file);
-	struct fmi_device *fmi = video_get_drvdata(dev);
+	struct fmi_device *fmi = video_drvdata(file);
 
 	if (v->index > 0)
 		return -EINVAL;
@@ -176,8 +175,7 @@ static int vidioc_s_tuner(struct file *file, void *priv,
 static int vidioc_s_frequency(struct file *file, void *priv,
 					struct v4l2_frequency *f)
 {
-	struct video_device *dev = video_devdata(file);
-	struct fmi_device *fmi = video_get_drvdata(dev);
+	struct fmi_device *fmi = video_drvdata(file);
 
 	if (!(fmi->flags & V4L2_TUNER_CAP_LOW))
 		f->frequency *= 1000;
@@ -194,8 +192,7 @@ static int vidioc_s_frequency(struct file *file, void *priv,
 static int vidioc_g_frequency(struct file *file, void *priv,
 					struct v4l2_frequency *f)
 {
-	struct video_device *dev = video_devdata(file);
-	struct fmi_device *fmi = video_get_drvdata(dev);
+	struct fmi_device *fmi = video_drvdata(file);
 
 	f->type = V4L2_TUNER_RADIO;
 	f->frequency = fmi->curfreq;
@@ -222,8 +219,7 @@ static int vidioc_queryctrl(struct file *file, void *priv,
 static int vidioc_g_ctrl(struct file *file, void *priv,
 					struct v4l2_control *ctrl)
 {
-	struct video_device *dev = video_devdata(file);
-	struct fmi_device *fmi = video_get_drvdata(dev);
+	struct fmi_device *fmi = video_drvdata(file);
 
 	switch (ctrl->id) {
 	case V4L2_CID_AUDIO_MUTE:
@@ -236,8 +232,7 @@ static int vidioc_g_ctrl(struct file *file, void *priv,
 static int vidioc_s_ctrl(struct file *file, void *priv,
 					struct v4l2_control *ctrl)
 {
-	struct video_device *dev = video_devdata(file);
-	struct fmi_device *fmi = video_get_drvdata(dev);
+	struct fmi_device *fmi = video_drvdata(file);
 
 	switch (ctrl->id) {
 	case V4L2_CID_AUDIO_MUTE:

commit 601e9444f249d219009ec05674268d90f6f1cdcb
Author: Hans Verkuil <hverkuil@xs4all.nl>
Date:   Sat Aug 23 07:24:07 2008 -0300

    V4L/DVB (8786): v4l2: remove the priv field, use dev_get_drvdata instead
    
    Remove the priv field and let video_get/set_drvdata use dev_get_drvdata
    and dev_set_drvdata instead.
    
    Convert all drivers that still used priv directly.
    
    Signed-off-by: Hans Verkuil <hverkuil@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-sf16fmi.c b/drivers/media/radio/radio-sf16fmi.c
index 6d865a7a91ec..810c366b73b0 100644
--- a/drivers/media/radio/radio-sf16fmi.c
+++ b/drivers/media/radio/radio-sf16fmi.c
@@ -148,7 +148,7 @@ static int vidioc_g_tuner(struct file *file, void *priv,
 {
 	int mult;
 	struct video_device *dev = video_devdata(file);
-	struct fmi_device *fmi = dev->priv;
+	struct fmi_device *fmi = video_get_drvdata(dev);
 
 	if (v->index > 0)
 		return -EINVAL;
@@ -177,7 +177,7 @@ static int vidioc_s_frequency(struct file *file, void *priv,
 					struct v4l2_frequency *f)
 {
 	struct video_device *dev = video_devdata(file);
-	struct fmi_device *fmi = dev->priv;
+	struct fmi_device *fmi = video_get_drvdata(dev);
 
 	if (!(fmi->flags & V4L2_TUNER_CAP_LOW))
 		f->frequency *= 1000;
@@ -195,7 +195,7 @@ static int vidioc_g_frequency(struct file *file, void *priv,
 					struct v4l2_frequency *f)
 {
 	struct video_device *dev = video_devdata(file);
-	struct fmi_device *fmi = dev->priv;
+	struct fmi_device *fmi = video_get_drvdata(dev);
 
 	f->type = V4L2_TUNER_RADIO;
 	f->frequency = fmi->curfreq;
@@ -223,7 +223,7 @@ static int vidioc_g_ctrl(struct file *file, void *priv,
 					struct v4l2_control *ctrl)
 {
 	struct video_device *dev = video_devdata(file);
-	struct fmi_device *fmi = dev->priv;
+	struct fmi_device *fmi = video_get_drvdata(dev);
 
 	switch (ctrl->id) {
 	case V4L2_CID_AUDIO_MUTE:
@@ -237,7 +237,7 @@ static int vidioc_s_ctrl(struct file *file, void *priv,
 					struct v4l2_control *ctrl)
 {
 	struct video_device *dev = video_devdata(file);
-	struct fmi_device *fmi = dev->priv;
+	struct fmi_device *fmi = video_get_drvdata(dev);
 
 	switch (ctrl->id) {
 	case V4L2_CID_AUDIO_MUTE:
@@ -386,7 +386,7 @@ static int __init fmi_init(void)
 	fmi_unit.curvol = 0;
 	fmi_unit.curfreq = 0;
 	fmi_unit.flags = V4L2_TUNER_CAP_LOW;
-	fmi_radio.priv = &fmi_unit;
+	video_set_drvdata(&fmi_radio, &fmi_unit);
 
 	mutex_init(&lock);
 

commit aa5e90af7d78d1711f8f4275ce3638817c0023dc
Author: Hans Verkuil <hverkuil@xs4all.nl>
Date:   Sat Aug 23 06:23:55 2008 -0300

    V4L/DVB (8783): v4l: add all missing video_device release callbacks
    
    All drivers that call video_device_register where checked to see if they
    set the release callback of struct video_device. Where that callback was
    missing it was added.
    
    Signed-off-by: Hans Verkuil <hverkuil@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-sf16fmi.c b/drivers/media/radio/radio-sf16fmi.c
index 55f8334513f3..6d865a7a91ec 100644
--- a/drivers/media/radio/radio-sf16fmi.c
+++ b/drivers/media/radio/radio-sf16fmi.c
@@ -326,6 +326,7 @@ static struct video_device fmi_radio = {
 	.name		= "SF16FMx radio",
 	.fops           = &fmi_fops,
 	.ioctl_ops 	= &fmi_ioctl_ops,
+	.release	= video_device_release_empty,
 };
 
 /* ladis: this is my card. does any other types exist? */

commit 3ca685aae04960eaa8b2c97baf384996c20cf9ac
Author: Hans Verkuil <hverkuil@xs4all.nl>
Date:   Sat Aug 23 04:49:13 2008 -0300

    V4L/DVB (8776): radio: replace video_exclusive_open/release
    
    Move the video_exclusive_open/release functionality into the driver itself.
    
    Signed-off-by: Hans Verkuil <hverkuil@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-sf16fmi.c b/drivers/media/radio/radio-sf16fmi.c
index 0d478f54a907..55f8334513f3 100644
--- a/drivers/media/radio/radio-sf16fmi.c
+++ b/drivers/media/radio/radio-sf16fmi.c
@@ -45,6 +45,7 @@ static struct v4l2_queryctrl radio_qctrl[] = {
 
 struct fmi_device
 {
+	unsigned long in_use;
 	int port;
 	int curvol; /* 1 or 0 */
 	unsigned long curfreq; /* freq in kHz */
@@ -284,10 +285,21 @@ static int vidioc_s_audio(struct file *file, void *priv,
 
 static struct fmi_device fmi_unit;
 
+static int fmi_exclusive_open(struct inode *inode, struct file *file)
+{
+	return test_and_set_bit(0, &fmi_unit.in_use) ? -EBUSY : 0;
+}
+
+static int fmi_exclusive_release(struct inode *inode, struct file *file)
+{
+	clear_bit(0, &fmi_unit.in_use);
+	return 0;
+}
+
 static const struct file_operations fmi_fops = {
 	.owner		= THIS_MODULE,
-	.open           = video_exclusive_open,
-	.release        = video_exclusive_release,
+	.open           = fmi_exclusive_open,
+	.release        = fmi_exclusive_release,
 	.ioctl		= video_ioctl2,
 #ifdef CONFIG_COMPAT
 	.compat_ioctl	= v4l_compat_ioctl32,

commit cba99ae81901fe61ac4b0d65c697474af29dc4ea
Author: Hans Verkuil <hverkuil@xs4all.nl>
Date:   Wed Sep 3 17:11:58 2008 -0300

    V4L/DVB (8778): radio: fix incorrect video_register_device result check
    
    Signed-off-by: Hans Verkuil <hverkuil@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-sf16fmi.c b/drivers/media/radio/radio-sf16fmi.c
index bb5d92f104af..0d478f54a907 100644
--- a/drivers/media/radio/radio-sf16fmi.c
+++ b/drivers/media/radio/radio-sf16fmi.c
@@ -377,7 +377,7 @@ static int __init fmi_init(void)
 
 	mutex_init(&lock);
 
-	if (video_register_device(&fmi_radio, VFL_TYPE_RADIO, radio_nr) == -1) {
+	if (video_register_device(&fmi_radio, VFL_TYPE_RADIO, radio_nr) < 0) {
 		release_region(io, 2);
 		return -EINVAL;
 	}

commit 0ea6bc8d43c9ee3c5384bea184eab020927a5b2c
Author: Hans Verkuil <hverkuil@xs4all.nl>
Date:   Sat Jul 26 08:26:43 2008 -0300

    V4L/DVB (8523): v4l2-dev: remove unused type and type2 field from video_device
    
    The type and type2 fields were unused and so could be removed.
    Instead add a vfl_type field that contains the type of the video
    device.
    
    Signed-off-by: Hans Verkuil <hverkuil@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@infradead.org>

diff --git a/drivers/media/radio/radio-sf16fmi.c b/drivers/media/radio/radio-sf16fmi.c
index 975f8521848a..bb5d92f104af 100644
--- a/drivers/media/radio/radio-sf16fmi.c
+++ b/drivers/media/radio/radio-sf16fmi.c
@@ -312,7 +312,6 @@ static const struct v4l2_ioctl_ops fmi_ioctl_ops = {
 
 static struct video_device fmi_radio = {
 	.name		= "SF16FMx radio",
-	.type		= VID_TYPE_TUNER,
 	.fops           = &fmi_fops,
 	.ioctl_ops 	= &fmi_ioctl_ops,
 };

commit 9c39d7eafa366b807067697f7fc5b14d8b865179
Author: Hans Verkuil <hverkuil@xs4all.nl>
Date:   Mon Jul 21 07:51:45 2008 -0300

    V4L/DVB (8483): Remove obsolete owner field from video_device struct.
    
    According to an old comment this should have been removed in 2.6.15.
    Better late than never...
    
    Signed-off-by: Hans Verkuil <hverkuil@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@infradead.org>

diff --git a/drivers/media/radio/radio-sf16fmi.c b/drivers/media/radio/radio-sf16fmi.c
index 75b68a024541..975f8521848a 100644
--- a/drivers/media/radio/radio-sf16fmi.c
+++ b/drivers/media/radio/radio-sf16fmi.c
@@ -311,7 +311,6 @@ static const struct v4l2_ioctl_ops fmi_ioctl_ops = {
 };
 
 static struct video_device fmi_radio = {
-	.owner		= THIS_MODULE,
 	.name		= "SF16FMx radio",
 	.type		= VID_TYPE_TUNER,
 	.fops           = &fmi_fops,

commit a399810ca69d9d4bd30ab8c1678c7439e567f90b
Author: Hans Verkuil <hverkuil@xs4all.nl>
Date:   Mon Jul 21 02:57:38 2008 -0300

    V4L/DVB (8482): videodev: move all ioctl callbacks to a new v4l2_ioctl_ops struct
    
    All ioctl callbacks are now stored in a new v4l2_ioctl_ops struct. Drivers fill in
    a const struct v4l2_ioctl_ops and video_device just contains a const pointer to it.
    
    This ensures a clean separation between the const ops struct and the non-const
    video_device struct.
    
    Signed-off-by: Hans Verkuil <hverkuil@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@infradead.org>

diff --git a/drivers/media/radio/radio-sf16fmi.c b/drivers/media/radio/radio-sf16fmi.c
index bb8b1c9107b1..75b68a024541 100644
--- a/drivers/media/radio/radio-sf16fmi.c
+++ b/drivers/media/radio/radio-sf16fmi.c
@@ -295,12 +295,7 @@ static const struct file_operations fmi_fops = {
 	.llseek         = no_llseek,
 };
 
-static struct video_device fmi_radio=
-{
-	.owner		= THIS_MODULE,
-	.name		= "SF16FMx radio",
-	.type		= VID_TYPE_TUNER,
-	.fops           = &fmi_fops,
+static const struct v4l2_ioctl_ops fmi_ioctl_ops = {
 	.vidioc_querycap    = vidioc_querycap,
 	.vidioc_g_tuner     = vidioc_g_tuner,
 	.vidioc_s_tuner     = vidioc_s_tuner,
@@ -315,6 +310,14 @@ static struct video_device fmi_radio=
 	.vidioc_s_ctrl      = vidioc_s_ctrl,
 };
 
+static struct video_device fmi_radio = {
+	.owner		= THIS_MODULE,
+	.name		= "SF16FMx radio",
+	.type		= VID_TYPE_TUNER,
+	.fops           = &fmi_fops,
+	.ioctl_ops 	= &fmi_ioctl_ops,
+};
+
 /* ladis: this is my card. does any other types exist? */
 static struct isapnp_device_id id_table[] __devinitdata = {
 	{	ISAPNP_ANY_ID, ISAPNP_ANY_ID,

commit 35ea11ff84719b1bfab2909903a9640a86552fd1
Author: Hans Verkuil <hverkuil@xs4all.nl>
Date:   Sun Jul 20 08:12:02 2008 -0300

    V4L/DVB (8430): videodev: move some functions from v4l2-dev.h to v4l2-common.h or v4l2-ioctl.h
    
    The functions in a header should not belong to another module. The prio functions
    belong to v4l2-common.c, so move them to v4l2-common.h.
    
    The ioctl functions belong to v4l2-ioctl.c, so create a new v4l2-ioctl.h header
    and move those functions to it.
    
    Signed-off-by: Hans Verkuil <hverkuil@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@infradead.org>

diff --git a/drivers/media/radio/radio-sf16fmi.c b/drivers/media/radio/radio-sf16fmi.c
index 66e052fd3909..bb8b1c9107b1 100644
--- a/drivers/media/radio/radio-sf16fmi.c
+++ b/drivers/media/radio/radio-sf16fmi.c
@@ -24,6 +24,7 @@
 #include <linux/delay.h>	/* udelay			*/
 #include <linux/videodev2.h>	/* kernel radio structs		*/
 #include <media/v4l2-common.h>
+#include <media/v4l2-ioctl.h>
 #include <linux/isapnp.h>
 #include <asm/io.h>		/* outb, outb_p			*/
 #include <asm/uaccess.h>	/* copy to/from user		*/

commit 078ff7953448163d8779e489bd0119dd9a9b4732
Author: Douglas Schilling Landgraf <dougsland@gmail.com>
Date:   Tue Apr 22 14:46:11 2008 -0300

    V4L/DVB (7402):  add macro validation for v4l_compat_ioctl32
    
    Added macro CONFIG_COMPAT for v4l_compat_ioctl32.
    
    Signed-off-by: Douglas Schilling Landgraf <dougsland@gmail.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@infradead.org>

diff --git a/drivers/media/radio/radio-sf16fmi.c b/drivers/media/radio/radio-sf16fmi.c
index 53e114857377..66e052fd3909 100644
--- a/drivers/media/radio/radio-sf16fmi.c
+++ b/drivers/media/radio/radio-sf16fmi.c
@@ -288,7 +288,9 @@ static const struct file_operations fmi_fops = {
 	.open           = video_exclusive_open,
 	.release        = video_exclusive_release,
 	.ioctl		= video_ioctl2,
+#ifdef CONFIG_COMPAT
 	.compat_ioctl	= v4l_compat_ioctl32,
+#endif
 	.llseek         = no_llseek,
 };
 

commit e08a8c9dc7d247ec2a98ea2d7ac5ecea6af5593c
Author: Mauro Carvalho Chehab <mchehab@infradead.org>
Date:   Sun Jan 27 14:43:20 2008 -0300

    V4L/DVB (7093): radio-sf16fmi: fix request_region()
    
    isapnp_fmi_probe attaches device. However, if request_region() fails, the
    device isn't disattached.
    
    Reviewed-by: Douglas Schilling Landgraf <dougsland@gmail.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@infradead.org>

diff --git a/drivers/media/radio/radio-sf16fmi.c b/drivers/media/radio/radio-sf16fmi.c
index 3118bdab3183..53e114857377 100644
--- a/drivers/media/radio/radio-sf16fmi.c
+++ b/drivers/media/radio/radio-sf16fmi.c
@@ -361,6 +361,7 @@ static int __init fmi_init(void)
 	}
 	if (!request_region(io, 2, "radio-sf16fmi")) {
 		printk(KERN_ERR "radio-sf16fmi: port 0x%x already in use\n", io);
+		pnp_device_detach(dev);
 		return -EBUSY;
 	}
 

commit a999337b49fcdd2c4a475e97e4b8337ebdfa4abf
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Wed Jan 23 02:39:39 2008 -0300

    V4L/DVB (7078): radio: fix sf16fmi section mismatch
    
    isapnp_fmi_probe() is only called by fmi_init(), which is __init,
    so isapnp_fmi_probe() can also be __init.
    
    media/radio/radio-sf16fmi.c:
    WARNING: vmlinux.o(.text+0x994e19): Section mismatch: reference to .init.data: (between 'isapnp_fmi_probe' and 'vidioc_s_tuner')
    WARNING: vmlinux.o(.text+0x994e22): Section mismatch: reference to .init.data: (between 'isapnp_fmi_probe' and 'vidioc_s_tuner')
    WARNING: vmlinux.o(.text+0x994e3a): Section mismatch: reference to .init.data:id_table (between 'isapnp_fmi_probe' and 'vidioc_s_tuner')
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Acked-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@infradead.org>

diff --git a/drivers/media/radio/radio-sf16fmi.c b/drivers/media/radio/radio-sf16fmi.c
index 395165367f37..3118bdab3183 100644
--- a/drivers/media/radio/radio-sf16fmi.c
+++ b/drivers/media/radio/radio-sf16fmi.c
@@ -321,7 +321,7 @@ static struct isapnp_device_id id_table[] __devinitdata = {
 
 MODULE_DEVICE_TABLE(isapnp, id_table);
 
-static int isapnp_fmi_probe(void)
+static int __init isapnp_fmi_probe(void)
 {
 	int i = 0;
 

commit 2e02b9a717388c99f2c2ef0aa03f86334bbf8fc7
Author: Douglas Schilling Landgraf <dougsland@gmail.com>
Date:   Sun May 27 14:05:01 2007 -0300

    V4L/DVB (5705): Removed unnecessary .hardware from video_device struct.
    
    From: Douglas Schilling Landgraf <dougsland@gmail.com>
    
    Signed-off-by: Douglas Schilling Landgraf <dougsland@gmail.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@infradead.org>

diff --git a/drivers/media/radio/radio-sf16fmi.c b/drivers/media/radio/radio-sf16fmi.c
index dc33f19c0e2c..395165367f37 100644
--- a/drivers/media/radio/radio-sf16fmi.c
+++ b/drivers/media/radio/radio-sf16fmi.c
@@ -297,7 +297,6 @@ static struct video_device fmi_radio=
 	.owner		= THIS_MODULE,
 	.name		= "SF16FMx radio",
 	.type		= VID_TYPE_TUNER,
-	.hardware	= 0,
 	.fops           = &fmi_fops,
 	.vidioc_querycap    = vidioc_querycap,
 	.vidioc_g_tuner     = vidioc_g_tuner,

commit c123b867713425f8db060b5e29201a1056c45d90
Author: Douglas Landgraf <dougsland@gmail.com>
Date:   Mon Apr 23 17:52:12 2007 -0300

    V4L/DVB (5550): Radio-sf16fmi.c Replace fmi_do_ioctl to use video_ioctl2
    
    Convert radio-sf16fmi to use video_ioctl2
    
    Signed-off-by:  Douglas Schilling Landgraf <dougsland@gmail.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@infradead.org>

diff --git a/drivers/media/radio/radio-sf16fmi.c b/drivers/media/radio/radio-sf16fmi.c
index f4619e4dda4f..dc33f19c0e2c 100644
--- a/drivers/media/radio/radio-sf16fmi.c
+++ b/drivers/media/radio/radio-sf16fmi.c
@@ -130,137 +130,155 @@ static inline int fmi_getsigstr(struct fmi_device *dev)
 	return (res & 2) ? 0 : 0xFFFF;
 }
 
-static int fmi_do_ioctl(struct inode *inode, struct file *file,
-			unsigned int cmd, void *arg)
+static int vidioc_querycap(struct file *file, void  *priv,
+					struct v4l2_capability *v)
 {
+	strlcpy(v->driver, "radio-sf16fmi", sizeof(v->driver));
+	strlcpy(v->card, "SF16-FMx radio", sizeof(v->card));
+	sprintf(v->bus_info, "ISA");
+	v->version = RADIO_VERSION;
+	v->capabilities = V4L2_CAP_TUNER;
+	return 0;
+}
+
+static int vidioc_g_tuner(struct file *file, void *priv,
+					struct v4l2_tuner *v)
+{
+	int mult;
 	struct video_device *dev = video_devdata(file);
-	struct fmi_device *fmi=dev->priv;
+	struct fmi_device *fmi = dev->priv;
 
-	switch(cmd)
-	{
-		case VIDIOC_QUERYCAP:
-		{
-			struct v4l2_capability *v = arg;
-			memset(v,0,sizeof(*v));
-			strlcpy(v->driver, "radio-sf16fmi", sizeof (v->driver));
-			strlcpy(v->card, "SF16-FMx radio", sizeof (v->card));
-			sprintf(v->bus_info,"ISA");
-			v->version = RADIO_VERSION;
-			v->capabilities = V4L2_CAP_TUNER;
+	if (v->index > 0)
+		return -EINVAL;
 
-			return 0;
-		}
-		case VIDIOC_G_TUNER:
-		{
-			struct v4l2_tuner *v = arg;
-			int mult;
-
-			if (v->index > 0)
-				return -EINVAL;
-
-			memset(v,0,sizeof(*v));
-			strcpy(v->name, "FM");
-			v->type = V4L2_TUNER_RADIO;
-
-			mult = (fmi->flags & V4L2_TUNER_CAP_LOW) ? 1 : 1000;
-			v->rangelow = RSF16_MINFREQ/mult;
-			v->rangehigh = RSF16_MAXFREQ/mult;
-			v->rxsubchans =V4L2_TUNER_SUB_MONO | V4L2_TUNER_MODE_STEREO;
-			v->capability=fmi->flags&V4L2_TUNER_CAP_LOW;
-			v->audmode = V4L2_TUNER_MODE_STEREO;
-			v->signal = fmi_getsigstr(fmi);
+	strcpy(v->name, "FM");
+	v->type = V4L2_TUNER_RADIO;
+	mult = (fmi->flags & V4L2_TUNER_CAP_LOW) ? 1 : 1000;
+	v->rangelow = RSF16_MINFREQ/mult;
+	v->rangehigh = RSF16_MAXFREQ/mult;
+	v->rxsubchans = V4L2_TUNER_SUB_MONO | V4L2_TUNER_MODE_STEREO;
+	v->capability = fmi->flags&V4L2_TUNER_CAP_LOW;
+	v->audmode = V4L2_TUNER_MODE_STEREO;
+	v->signal = fmi_getsigstr(fmi);
+	return 0;
+}
 
-			return 0;
-		}
-		case VIDIOC_S_TUNER:
-		{
-			struct v4l2_tuner *v = arg;
+static int vidioc_s_tuner(struct file *file, void *priv,
+					struct v4l2_tuner *v)
+{
+	if (v->index > 0)
+		return -EINVAL;
+	return 0;
+}
 
-			if (v->index > 0)
-				return -EINVAL;
+static int vidioc_s_frequency(struct file *file, void *priv,
+					struct v4l2_frequency *f)
+{
+	struct video_device *dev = video_devdata(file);
+	struct fmi_device *fmi = dev->priv;
 
-			return 0;
-		}
-		case VIDIOC_S_FREQUENCY:
-		{
-			struct v4l2_frequency *f = arg;
-
-			if (!(fmi->flags & V4L2_TUNER_CAP_LOW))
-				f->frequency *= 1000;
-			if (f->frequency < RSF16_MINFREQ ||
-					f->frequency > RSF16_MAXFREQ )
-				return -EINVAL;
-			/*rounding in steps of 800 to match th freq
-			  that will be used */
-			fmi->curfreq = (f->frequency/800)*800;
-			fmi_setfreq(fmi);
+	if (!(fmi->flags & V4L2_TUNER_CAP_LOW))
+		f->frequency *= 1000;
+	if (f->frequency < RSF16_MINFREQ ||
+			f->frequency > RSF16_MAXFREQ )
+		return -EINVAL;
+	/*rounding in steps of 800 to match th freq
+	that will be used */
+	fmi->curfreq = (f->frequency/800)*800;
+	fmi_setfreq(fmi);
+	return 0;
+}
 
-			return 0;
-		}
-		case VIDIOC_G_FREQUENCY:
-		{
-			struct v4l2_frequency *f = arg;
+static int vidioc_g_frequency(struct file *file, void *priv,
+					struct v4l2_frequency *f)
+{
+	struct video_device *dev = video_devdata(file);
+	struct fmi_device *fmi = dev->priv;
 
-			f->type = V4L2_TUNER_RADIO;
-			f->frequency = fmi->curfreq;
-			if (!(fmi->flags & V4L2_TUNER_CAP_LOW))
-				f->frequency /= 1000;
+	f->type = V4L2_TUNER_RADIO;
+	f->frequency = fmi->curfreq;
+	if (!(fmi->flags & V4L2_TUNER_CAP_LOW))
+		f->frequency /= 1000;
+	return 0;
+}
+
+static int vidioc_queryctrl(struct file *file, void *priv,
+					struct v4l2_queryctrl *qc)
+{
+	int i;
 
+	for (i = 0; i < ARRAY_SIZE(radio_qctrl); i++) {
+		if (qc->id && qc->id == radio_qctrl[i].id) {
+			memcpy(qc, &(radio_qctrl[i]),
+						sizeof(*qc));
 			return 0;
 		}
-		case VIDIOC_QUERYCTRL:
-		{
-			struct v4l2_queryctrl *qc = arg;
-			int i;
-
-			for (i = 0; i < ARRAY_SIZE(radio_qctrl); i++) {
-				if (qc->id && qc->id == radio_qctrl[i].id) {
-					memcpy(qc, &(radio_qctrl[i]),
-								sizeof(*qc));
-					return (0);
-				}
-			}
-			return -EINVAL;
-		}
-		case VIDIOC_G_CTRL:
-		{
-			struct v4l2_control *ctrl= arg;
-
-			switch (ctrl->id) {
-				case V4L2_CID_AUDIO_MUTE:
-					ctrl->value=fmi->curvol;
-					return (0);
-			}
-			return -EINVAL;
-		}
-		case VIDIOC_S_CTRL:
-		{
-			struct v4l2_control *ctrl= arg;
-
-			switch (ctrl->id) {
-				case V4L2_CID_AUDIO_MUTE:
-				{
-					if (ctrl->value)
-						fmi_mute(fmi->port);
-					else
-						fmi_unmute(fmi->port);
-
-					fmi->curvol=ctrl->value;
-					return (0);
-				}
-			}
-			return -EINVAL;
-		}
-		default:
-			return v4l_compat_translate_ioctl(inode,file,cmd,arg,
-							  fmi_do_ioctl);
 	}
+	return -EINVAL;
+}
+
+static int vidioc_g_ctrl(struct file *file, void *priv,
+					struct v4l2_control *ctrl)
+{
+	struct video_device *dev = video_devdata(file);
+	struct fmi_device *fmi = dev->priv;
+
+	switch (ctrl->id) {
+	case V4L2_CID_AUDIO_MUTE:
+		ctrl->value = fmi->curvol;
+		return 0;
+	}
+	return -EINVAL;
+}
+
+static int vidioc_s_ctrl(struct file *file, void *priv,
+					struct v4l2_control *ctrl)
+{
+	struct video_device *dev = video_devdata(file);
+	struct fmi_device *fmi = dev->priv;
+
+	switch (ctrl->id) {
+	case V4L2_CID_AUDIO_MUTE:
+		if (ctrl->value)
+			fmi_mute(fmi->port);
+		else
+			fmi_unmute(fmi->port);
+		fmi->curvol = ctrl->value;
+		return 0;
+	}
+	return -EINVAL;
 }
 
-static int fmi_ioctl(struct inode *inode, struct file *file,
-		     unsigned int cmd, unsigned long arg)
+static int vidioc_g_audio(struct file *file, void *priv,
+					struct v4l2_audio *a)
 {
-	return video_usercopy(inode, file, cmd, arg, fmi_do_ioctl);
+	if (a->index > 1)
+		return -EINVAL;
+
+	strcpy(a->name, "Radio");
+	a->capability = V4L2_AUDCAP_STEREO;
+	return 0;
+}
+
+static int vidioc_g_input(struct file *filp, void *priv, unsigned int *i)
+{
+	*i = 0;
+	return 0;
+}
+
+static int vidioc_s_input(struct file *filp, void *priv, unsigned int i)
+{
+	if (i != 0)
+		return -EINVAL;
+	return 0;
+}
+
+static int vidioc_s_audio(struct file *file, void *priv,
+					struct v4l2_audio *a)
+{
+	if (a->index != 0)
+		return -EINVAL;
+	return 0;
 }
 
 static struct fmi_device fmi_unit;
@@ -269,7 +287,7 @@ static const struct file_operations fmi_fops = {
 	.owner		= THIS_MODULE,
 	.open           = video_exclusive_open,
 	.release        = video_exclusive_release,
-	.ioctl		= fmi_ioctl,
+	.ioctl		= video_ioctl2,
 	.compat_ioctl	= v4l_compat_ioctl32,
 	.llseek         = no_llseek,
 };
@@ -281,6 +299,18 @@ static struct video_device fmi_radio=
 	.type		= VID_TYPE_TUNER,
 	.hardware	= 0,
 	.fops           = &fmi_fops,
+	.vidioc_querycap    = vidioc_querycap,
+	.vidioc_g_tuner     = vidioc_g_tuner,
+	.vidioc_s_tuner     = vidioc_s_tuner,
+	.vidioc_g_audio     = vidioc_g_audio,
+	.vidioc_s_audio     = vidioc_s_audio,
+	.vidioc_g_input     = vidioc_g_input,
+	.vidioc_s_input     = vidioc_s_input,
+	.vidioc_g_frequency = vidioc_g_frequency,
+	.vidioc_s_frequency = vidioc_s_frequency,
+	.vidioc_queryctrl   = vidioc_queryctrl,
+	.vidioc_g_ctrl      = vidioc_g_ctrl,
+	.vidioc_s_ctrl      = vidioc_s_ctrl,
 };
 
 /* ladis: this is my card. does any other types exist? */

commit fa027c2a0a0d6d1df6b29ee99048502c93da0dd4
Author: Arjan van de Ven <arjan@linux.intel.com>
Date:   Mon Feb 12 00:55:33 2007 -0800

    [PATCH] mark struct file_operations const 4
    
    Many struct file_operations in the kernel can be "const".  Marking them const
    moves these to the .rodata section, which avoids false sharing with potential
    dirty data.  In addition it'll catch accidental writes at compile time to
    these shared resources.
    
    [akpm@sdl.org: dvb fix]
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/media/radio/radio-sf16fmi.c b/drivers/media/radio/radio-sf16fmi.c
index ecc854b4ba38..f4619e4dda4f 100644
--- a/drivers/media/radio/radio-sf16fmi.c
+++ b/drivers/media/radio/radio-sf16fmi.c
@@ -265,7 +265,7 @@ static int fmi_ioctl(struct inode *inode, struct file *file,
 
 static struct fmi_device fmi_unit;
 
-static struct file_operations fmi_fops = {
+static const struct file_operations fmi_fops = {
 	.owner		= THIS_MODULE,
 	.open           = video_exclusive_open,
 	.release        = video_exclusive_release,

commit 2cd885aa0f35e9329292e5be2a6c9d424bba5531
Author: Andrew Morton <akpm@osdl.org>
Date:   Tue Aug 8 09:10:09 2006 -0300

    V4L/DVB (4394): Git-dvb: radio-sf16fmi build fix
    
    drivers/media/radio/radio-sf16fmi.c: In function 'fmi_do_ioctl':
    drivers/media/radio/radio-sf16fmi.c:147: warning: implicit declaration of function 'KERNEL_VERSION'
    
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@infradead.org>

diff --git a/drivers/media/radio/radio-sf16fmi.c b/drivers/media/radio/radio-sf16fmi.c
index 5b62285ed0ce..ecc854b4ba38 100644
--- a/drivers/media/radio/radio-sf16fmi.c
+++ b/drivers/media/radio/radio-sf16fmi.c
@@ -16,6 +16,7 @@
  * Converted to V4L2 API by Mauro Carvalho Chehab <mchehab@infradead.org>
  */
 
+#include <linux/version.h>
 #include <linux/kernel.h>	/* __setup			*/
 #include <linux/module.h>	/* Modules 			*/
 #include <linux/init.h>		/* Initdata			*/

commit fa38ad6592558660086e8ed4b12e5fdf90e78f90
Author: Mauro Carvalho Chehab <mchehab@infradead.org>
Date:   Tue Aug 8 09:10:02 2006 -0300

    V4L/DVB (4354): A small fix at fmi->flags logic
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@infradead.org>

diff --git a/drivers/media/radio/radio-sf16fmi.c b/drivers/media/radio/radio-sf16fmi.c
index 43524119ac1c..5b62285ed0ce 100644
--- a/drivers/media/radio/radio-sf16fmi.c
+++ b/drivers/media/radio/radio-sf16fmi.c
@@ -165,7 +165,7 @@ static int fmi_do_ioctl(struct inode *inode, struct file *file,
 			v->rangelow = RSF16_MINFREQ/mult;
 			v->rangehigh = RSF16_MAXFREQ/mult;
 			v->rxsubchans =V4L2_TUNER_SUB_MONO | V4L2_TUNER_MODE_STEREO;
-			v->capability=fmi->flags;
+			v->capability=fmi->flags&V4L2_TUNER_CAP_LOW;
 			v->audmode = V4L2_TUNER_MODE_STEREO;
 			v->signal = fmi_getsigstr(fmi);
 

commit a2ef73af4cd6cb46be13b11f9ce64d6b44f0350b
Author: Mauro Carvalho Chehab <mchehab@infradead.org>
Date:   Tue Aug 8 09:10:02 2006 -0300

    V4L/DVB (4353): V4L2 conversion: radio-sf16fmi
    
    Driver conversion to V4L2 API.
    Require some testing, since this obsolete hardware is not
    common those days.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@infradead.org>

diff --git a/drivers/media/radio/radio-sf16fmi.c b/drivers/media/radio/radio-sf16fmi.c
index efee6e339d15..43524119ac1c 100644
--- a/drivers/media/radio/radio-sf16fmi.c
+++ b/drivers/media/radio/radio-sf16fmi.c
@@ -13,6 +13,7 @@
  *  No volume control - only mute/unmute - you have to use line volume
  *  control on SB-part of SF16FMI
  *
+ * Converted to V4L2 API by Mauro Carvalho Chehab <mchehab@infradead.org>
  */
 
 #include <linux/kernel.h>	/* __setup			*/
@@ -20,13 +21,26 @@
 #include <linux/init.h>		/* Initdata			*/
 #include <linux/ioport.h>	/* request_region		*/
 #include <linux/delay.h>	/* udelay			*/
-#include <linux/videodev.h>	/* kernel radio structs		*/
+#include <linux/videodev2.h>	/* kernel radio structs		*/
 #include <media/v4l2-common.h>
 #include <linux/isapnp.h>
 #include <asm/io.h>		/* outb, outb_p			*/
 #include <asm/uaccess.h>	/* copy to/from user		*/
 #include <linux/mutex.h>
 
+#define RADIO_VERSION KERNEL_VERSION(0,0,2)
+
+static struct v4l2_queryctrl radio_qctrl[] = {
+	{
+		.id            = V4L2_CID_AUDIO_MUTE,
+		.name          = "Mute",
+		.minimum       = 0,
+		.maximum       = 1,
+		.default_value = 1,
+		.type          = V4L2_CTRL_TYPE_BOOLEAN,
+	}
+};
+
 struct fmi_device
 {
 	int port;
@@ -123,93 +137,122 @@ static int fmi_do_ioctl(struct inode *inode, struct file *file,
 
 	switch(cmd)
 	{
-		case VIDIOCGCAP:
+		case VIDIOC_QUERYCAP:
 		{
-			struct video_capability *v = arg;
+			struct v4l2_capability *v = arg;
 			memset(v,0,sizeof(*v));
-			strcpy(v->name, "SF16-FMx radio");
-			v->type=VID_TYPE_TUNER;
-			v->channels=1;
-			v->audios=1;
+			strlcpy(v->driver, "radio-sf16fmi", sizeof (v->driver));
+			strlcpy(v->card, "SF16-FMx radio", sizeof (v->card));
+			sprintf(v->bus_info,"ISA");
+			v->version = RADIO_VERSION;
+			v->capabilities = V4L2_CAP_TUNER;
+
 			return 0;
 		}
-		case VIDIOCGTUNER:
+		case VIDIOC_G_TUNER:
 		{
-			struct video_tuner *v = arg;
+			struct v4l2_tuner *v = arg;
 			int mult;
 
-			if(v->tuner)	/* Only 1 tuner */
+			if (v->index > 0)
 				return -EINVAL;
+
+			memset(v,0,sizeof(*v));
 			strcpy(v->name, "FM");
-			mult = (fmi->flags & VIDEO_TUNER_LOW) ? 1 : 1000;
+			v->type = V4L2_TUNER_RADIO;
+
+			mult = (fmi->flags & V4L2_TUNER_CAP_LOW) ? 1 : 1000;
 			v->rangelow = RSF16_MINFREQ/mult;
 			v->rangehigh = RSF16_MAXFREQ/mult;
-			v->flags=fmi->flags;
-			v->mode=VIDEO_MODE_AUTO;
+			v->rxsubchans =V4L2_TUNER_SUB_MONO | V4L2_TUNER_MODE_STEREO;
+			v->capability=fmi->flags;
+			v->audmode = V4L2_TUNER_MODE_STEREO;
 			v->signal = fmi_getsigstr(fmi);
+
 			return 0;
 		}
-		case VIDIOCSTUNER:
+		case VIDIOC_S_TUNER:
 		{
-			struct video_tuner *v = arg;
-			if(v->tuner!=0)
+			struct v4l2_tuner *v = arg;
+
+			if (v->index > 0)
 				return -EINVAL;
-			fmi->flags = v->flags & VIDEO_TUNER_LOW;
-			/* Only 1 tuner so no setting needed ! */
-			return 0;
-		}
-		case VIDIOCGFREQ:
-		{
-			unsigned long *freq = arg;
-			*freq = fmi->curfreq;
-			if (!(fmi->flags & VIDEO_TUNER_LOW))
-			    *freq /= 1000;
+
 			return 0;
 		}
-		case VIDIOCSFREQ:
+		case VIDIOC_S_FREQUENCY:
 		{
-			unsigned long *freq = arg;
-			if (!(fmi->flags & VIDEO_TUNER_LOW))
-				*freq *= 1000;
-			if (*freq < RSF16_MINFREQ || *freq > RSF16_MAXFREQ )
+			struct v4l2_frequency *f = arg;
+
+			if (!(fmi->flags & V4L2_TUNER_CAP_LOW))
+				f->frequency *= 1000;
+			if (f->frequency < RSF16_MINFREQ ||
+					f->frequency > RSF16_MAXFREQ )
 				return -EINVAL;
 			/*rounding in steps of 800 to match th freq
 			  that will be used */
-			fmi->curfreq = (*freq/800)*800;
+			fmi->curfreq = (f->frequency/800)*800;
 			fmi_setfreq(fmi);
+
 			return 0;
 		}
-		case VIDIOCGAUDIO:
+		case VIDIOC_G_FREQUENCY:
 		{
-			struct video_audio *v = arg;
-			memset(v,0,sizeof(*v));
-			v->flags=( (!fmi->curvol)*VIDEO_AUDIO_MUTE | VIDEO_AUDIO_MUTABLE);
-			strcpy(v->name, "Radio");
-			v->mode=VIDEO_SOUND_STEREO;
+			struct v4l2_frequency *f = arg;
+
+			f->type = V4L2_TUNER_RADIO;
+			f->frequency = fmi->curfreq;
+			if (!(fmi->flags & V4L2_TUNER_CAP_LOW))
+				f->frequency /= 1000;
+
 			return 0;
 		}
-		case VIDIOCSAUDIO:
+		case VIDIOC_QUERYCTRL:
 		{
-			struct video_audio *v = arg;
-			if(v->audio)
-				return -EINVAL;
-			fmi->curvol= v->flags&VIDEO_AUDIO_MUTE ? 0 : 1;
-			fmi->curvol ?
-				fmi_unmute(fmi->port) : fmi_mute(fmi->port);
-			return 0;
+			struct v4l2_queryctrl *qc = arg;
+			int i;
+
+			for (i = 0; i < ARRAY_SIZE(radio_qctrl); i++) {
+				if (qc->id && qc->id == radio_qctrl[i].id) {
+					memcpy(qc, &(radio_qctrl[i]),
+								sizeof(*qc));
+					return (0);
+				}
+			}
+			return -EINVAL;
 		}
-		case VIDIOCGUNIT:
+		case VIDIOC_G_CTRL:
 		{
-			struct video_unit *v = arg;
-			v->video=VIDEO_NO_UNIT;
-			v->vbi=VIDEO_NO_UNIT;
-			v->radio=dev->minor;
-			v->audio=0; /* How do we find out this??? */
-			v->teletext=VIDEO_NO_UNIT;
-			return 0;
+			struct v4l2_control *ctrl= arg;
+
+			switch (ctrl->id) {
+				case V4L2_CID_AUDIO_MUTE:
+					ctrl->value=fmi->curvol;
+					return (0);
+			}
+			return -EINVAL;
+		}
+		case VIDIOC_S_CTRL:
+		{
+			struct v4l2_control *ctrl= arg;
+
+			switch (ctrl->id) {
+				case V4L2_CID_AUDIO_MUTE:
+				{
+					if (ctrl->value)
+						fmi_mute(fmi->port);
+					else
+						fmi_unmute(fmi->port);
+
+					fmi->curvol=ctrl->value;
+					return (0);
+				}
+			}
+			return -EINVAL;
 		}
 		default:
-			return -ENOIOCTLCMD;
+			return v4l_compat_translate_ioctl(inode,file,cmd,arg,
+							  fmi_do_ioctl);
 	}
 }
 
@@ -235,7 +278,7 @@ static struct video_device fmi_radio=
 	.owner		= THIS_MODULE,
 	.name		= "SF16FMx radio",
 	.type		= VID_TYPE_TUNER,
-	.hardware	= VID_HARDWARE_SF16MI,
+	.hardware	= 0,
 	.fops           = &fmi_fops,
 };
 
@@ -294,7 +337,7 @@ static int __init fmi_init(void)
 	fmi_unit.port = io;
 	fmi_unit.curvol = 0;
 	fmi_unit.curfreq = 0;
-	fmi_unit.flags = VIDEO_TUNER_LOW;
+	fmi_unit.flags = V4L2_TUNER_CAP_LOW;
 	fmi_radio.priv = &fmi_unit;
 
 	mutex_init(&lock);

commit 5e87efa3b29c105f81fea785babafb098e4e046d
Author: Mauro Carvalho Chehab <mchehab@infradead.org>
Date:   Mon Jun 5 10:26:32 2006 -0300

    V4L/DVB (4068): Removed all references to kernel stuff from videodev.h and videodev2.h
    
    The videodev.h and videodev2.h describe the public API for V4L and V4L2.
    It shouldn't have there any kernel-specific stuff. Those were moved to
    v4l2-dev.h.
    This patch removes some uneeded headers and include v4l2-common.h on all
    V4L driver. This header includes device implementation of V4L2 API provided
    on v4l2-dev.h as well as V4L2 internal ioctls that provides connections
    between master driver and its i2c devices.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@infradead.org>

diff --git a/drivers/media/radio/radio-sf16fmi.c b/drivers/media/radio/radio-sf16fmi.c
index 70cfbc3910dd..efee6e339d15 100644
--- a/drivers/media/radio/radio-sf16fmi.c
+++ b/drivers/media/radio/radio-sf16fmi.c
@@ -21,6 +21,7 @@
 #include <linux/ioport.h>	/* request_region		*/
 #include <linux/delay.h>	/* udelay			*/
 #include <linux/videodev.h>	/* kernel radio structs		*/
+#include <media/v4l2-common.h>
 #include <linux/isapnp.h>
 #include <asm/io.h>		/* outb, outb_p			*/
 #include <asm/uaccess.h>	/* copy to/from user		*/

commit 4286c6f65ec01efa8f5108cadea402ecf3b12279
Author: Mauro Carvalho Chehab <mchehab@infradead.org>
Date:   Sat Apr 8 16:06:16 2006 -0300

    V4L/DVB (3753): Whitespace cleanups at media/radio
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@infradead.org>

diff --git a/drivers/media/radio/radio-sf16fmi.c b/drivers/media/radio/radio-sf16fmi.c
index 53073b424107..70cfbc3910dd 100644
--- a/drivers/media/radio/radio-sf16fmi.c
+++ b/drivers/media/radio/radio-sf16fmi.c
@@ -12,7 +12,7 @@
  *  Frequency control is done digitally -- ie out(port,encodefreq(95.8));
  *  No volume control - only mute/unmute - you have to use line volume
  *  control on SB-part of SF16FMI
- *  
+ *
  */
 
 #include <linux/kernel.h>	/* __setup			*/
@@ -29,19 +29,19 @@
 struct fmi_device
 {
 	int port;
-        int curvol; /* 1 or 0 */
-        unsigned long curfreq; /* freq in kHz */
-        __u32 flags;
+	int curvol; /* 1 or 0 */
+	unsigned long curfreq; /* freq in kHz */
+	__u32 flags;
 };
 
-static int io = -1; 
+static int io = -1;
 static int radio_nr = -1;
 static struct pnp_dev *dev = NULL;
 static struct mutex lock;
 
 /* freq is in 1/16 kHz to internal number, hw precision is 50 kHz */
 /* It is only useful to give freq in intervall of 800 (=0.05Mhz),
- * other bits will be truncated, e.g 92.7400016 -> 92.7, but 
+ * other bits will be truncated, e.g 92.7400016 -> 92.7, but
  * 92.7400017 -> 92.75
  */
 #define RSF16_ENCODE(x)	((x)/800+214)
@@ -51,7 +51,7 @@ static struct mutex lock;
 static void outbits(int bits, unsigned int data, int port)
 {
 	while(bits--) {
- 		if(data & 1) {
+		if(data & 1) {
 			outb(5, port);
 			udelay(6);
 			outb(7, port);
@@ -101,7 +101,7 @@ static inline int fmi_getsigstr(struct fmi_device *dev)
 	int res;
 	int myport = dev->port;
 
-	
+
 	mutex_lock(&lock);
 	val = dev->curvol ? 0x08 : 0x00;	/* unmute/mute */
 	outb(val, myport);
@@ -109,7 +109,7 @@ static inline int fmi_getsigstr(struct fmi_device *dev)
 	msleep(143); 		/* was schedule_timeout(HZ/7) */
 	res = (int)inb(myport+1);
 	outb(val, myport);
-	
+
 	mutex_unlock(&lock);
 	return (res & 2) ? 0 : 0xFFFF;
 }
@@ -119,7 +119,7 @@ static int fmi_do_ioctl(struct inode *inode, struct file *file,
 {
 	struct video_device *dev = video_devdata(file);
 	struct fmi_device *fmi=dev->priv;
-	
+
 	switch(cmd)
 	{
 		case VIDIOCGCAP:
@@ -174,18 +174,18 @@ static int fmi_do_ioctl(struct inode *inode, struct file *file,
 				return -EINVAL;
 			/*rounding in steps of 800 to match th freq
 			  that will be used */
-			fmi->curfreq = (*freq/800)*800; 
+			fmi->curfreq = (*freq/800)*800;
 			fmi_setfreq(fmi);
 			return 0;
 		}
 		case VIDIOCGAUDIO:
-		{	
+		{
 			struct video_audio *v = arg;
 			memset(v,0,sizeof(*v));
 			v->flags=( (!fmi->curvol)*VIDEO_AUDIO_MUTE | VIDEO_AUDIO_MUTABLE);
 			strcpy(v->name, "Radio");
 			v->mode=VIDEO_SOUND_STEREO;
-			return 0;			
+			return 0;
 		}
 		case VIDIOCSAUDIO:
 		{
@@ -193,19 +193,19 @@ static int fmi_do_ioctl(struct inode *inode, struct file *file,
 			if(v->audio)
 				return -EINVAL;
 			fmi->curvol= v->flags&VIDEO_AUDIO_MUTE ? 0 : 1;
-			fmi->curvol ? 
+			fmi->curvol ?
 				fmi_unmute(fmi->port) : fmi_mute(fmi->port);
 			return 0;
 		}
-	        case VIDIOCGUNIT:
+		case VIDIOCGUNIT:
 		{
-               		struct video_unit *v = arg;
+			struct video_unit *v = arg;
 			v->video=VIDEO_NO_UNIT;
 			v->vbi=VIDEO_NO_UNIT;
 			v->radio=dev->minor;
 			v->audio=0; /* How do we find out this??? */
 			v->teletext=VIDEO_NO_UNIT;
-			return 0;			
+			return 0;
 		}
 		default:
 			return -ENOIOCTLCMD;
@@ -295,14 +295,14 @@ static int __init fmi_init(void)
 	fmi_unit.curfreq = 0;
 	fmi_unit.flags = VIDEO_TUNER_LOW;
 	fmi_radio.priv = &fmi_unit;
-	
+
 	mutex_init(&lock);
-	
+
 	if (video_register_device(&fmi_radio, VFL_TYPE_RADIO, radio_nr) == -1) {
 		release_region(io, 2);
 		return -EINVAL;
 	}
-		
+
 	printk(KERN_INFO "SF16FMx radio card driver at 0x%x\n", io);
 	/* mute card - prevents noisy bootups */
 	fmi_mute(io);

commit 3593cab5d62c4c7abced1076710f9bc2d8847433
Author: Ingo Molnar <mingo@elte.hu>
Date:   Tue Feb 7 06:49:14 2006 -0200

    V4L/DVB (3318b): sem2mutex: drivers/media/, #2
    
    Semaphore to mutex conversion.
    
    The conversion was generated via scripts, and the result was validated
    automatically via a script as well.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@infradead.org>

diff --git a/drivers/media/radio/radio-sf16fmi.c b/drivers/media/radio/radio-sf16fmi.c
index 0229f792a059..53073b424107 100644
--- a/drivers/media/radio/radio-sf16fmi.c
+++ b/drivers/media/radio/radio-sf16fmi.c
@@ -24,7 +24,7 @@
 #include <linux/isapnp.h>
 #include <asm/io.h>		/* outb, outb_p			*/
 #include <asm/uaccess.h>	/* copy to/from user		*/
-#include <asm/semaphore.h>
+#include <linux/mutex.h>
 
 struct fmi_device
 {
@@ -37,7 +37,7 @@ struct fmi_device
 static int io = -1; 
 static int radio_nr = -1;
 static struct pnp_dev *dev = NULL;
-static struct semaphore lock;
+static struct mutex lock;
 
 /* freq is in 1/16 kHz to internal number, hw precision is 50 kHz */
 /* It is only useful to give freq in intervall of 800 (=0.05Mhz),
@@ -68,16 +68,16 @@ static void outbits(int bits, unsigned int data, int port)
 
 static inline void fmi_mute(int port)
 {
-	down(&lock);
+	mutex_lock(&lock);
 	outb(0x00, port);
-	up(&lock);
+	mutex_unlock(&lock);
 }
 
 static inline void fmi_unmute(int port)
 {
-	down(&lock);
+	mutex_lock(&lock);
 	outb(0x08, port);
-	up(&lock);
+	mutex_unlock(&lock);
 }
 
 static inline int fmi_setfreq(struct fmi_device *dev)
@@ -85,12 +85,12 @@ static inline int fmi_setfreq(struct fmi_device *dev)
 	int myport = dev->port;
 	unsigned long freq = dev->curfreq;
 
-	down(&lock);
+	mutex_lock(&lock);
 
 	outbits(16, RSF16_ENCODE(freq), myport);
 	outbits(8, 0xC0, myport);
 	msleep(143);		/* was schedule_timeout(HZ/7) */
-	up(&lock);
+	mutex_unlock(&lock);
 	if (dev->curvol) fmi_unmute(myport);
 	return 0;
 }
@@ -102,7 +102,7 @@ static inline int fmi_getsigstr(struct fmi_device *dev)
 	int myport = dev->port;
 
 	
-	down(&lock);
+	mutex_lock(&lock);
 	val = dev->curvol ? 0x08 : 0x00;	/* unmute/mute */
 	outb(val, myport);
 	outb(val | 0x10, myport);
@@ -110,7 +110,7 @@ static inline int fmi_getsigstr(struct fmi_device *dev)
 	res = (int)inb(myport+1);
 	outb(val, myport);
 	
-	up(&lock);
+	mutex_unlock(&lock);
 	return (res & 2) ? 0 : 0xFFFF;
 }
 
@@ -296,7 +296,7 @@ static int __init fmi_init(void)
 	fmi_unit.flags = VIDEO_TUNER_LOW;
 	fmi_radio.priv = &fmi_unit;
 	
-	init_MUTEX(&lock);
+	mutex_init(&lock);
 	
 	if (video_register_device(&fmi_radio, VFL_TYPE_RADIO, radio_nr) == -1) {
 		release_region(io, 2);

commit 0d0fbf8152fb3bb4393be11e8df7f70e1fbbd738
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Jan 9 15:24:57 2006 -0200

    V4L (926_2): Moves compat32 functions from fs to v4l subsystem
    
    This moves the 32 bit ioctl compatibility handlers for
    Video4Linux into a new file and adds explicit calls to them
    to each v4l device driver.
    
    Unfortunately, there does not seem to be any code handling
    the v4l2 ioctls, so quite often the code goes through two
    separate conversions, first from 32 bit v4l to 64 bit v4l,
    and from there to 64 bit v4l2. My patch does not change
    that, so there is still much room for improvement.
    
    Also, some drivers have additional ioctl numbers, for
    which the conversion should be handled internally to
    that driver.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@brturbo.com.br>

diff --git a/drivers/media/radio/radio-sf16fmi.c b/drivers/media/radio/radio-sf16fmi.c
index 6f03ce4dd7b0..0229f792a059 100644
--- a/drivers/media/radio/radio-sf16fmi.c
+++ b/drivers/media/radio/radio-sf16fmi.c
@@ -225,6 +225,7 @@ static struct file_operations fmi_fops = {
 	.open           = video_exclusive_open,
 	.release        = video_exclusive_release,
 	.ioctl		= fmi_ioctl,
+	.compat_ioctl	= v4l_compat_ioctl32,
 	.llseek         = no_llseek,
 };
 

commit fb911ee849756fc6c609dddded92d9207ff3fb29
Author: Peter Osterlund <petero2@telia.com>
Date:   Tue Sep 13 01:25:15 2005 -0700

    [PATCH] Remove unnecessary check_region references in comments
    
    Remove check_region references from comments and printk statements so that
    searching for real users of this deprecated function gets easier.
    
    Signed-off-by: Peter Osterlund <petero2@telia.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/media/radio/radio-sf16fmi.c b/drivers/media/radio/radio-sf16fmi.c
index 3a464a09221f..6f03ce4dd7b0 100644
--- a/drivers/media/radio/radio-sf16fmi.c
+++ b/drivers/media/radio/radio-sf16fmi.c
@@ -18,7 +18,7 @@
 #include <linux/kernel.h>	/* __setup			*/
 #include <linux/module.h>	/* Modules 			*/
 #include <linux/init.h>		/* Initdata			*/
-#include <linux/ioport.h>	/* check_region, request_region	*/
+#include <linux/ioport.h>	/* request_region		*/
 #include <linux/delay.h>	/* udelay			*/
 #include <linux/videodev.h>	/* kernel radio structs		*/
 #include <linux/isapnp.h>

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/media/radio/radio-sf16fmi.c b/drivers/media/radio/radio-sf16fmi.c
new file mode 100644
index 000000000000..3a464a09221f
--- /dev/null
+++ b/drivers/media/radio/radio-sf16fmi.c
@@ -0,0 +1,328 @@
+/* SF16FMI radio driver for Linux radio support
+ * heavily based on rtrack driver...
+ * (c) 1997 M. Kirkwood
+ * (c) 1998 Petr Vandrovec, vandrove@vc.cvut.cz
+ *
+ * Fitted to new interface by Alan Cox <alan.cox@linux.org>
+ * Made working and cleaned up functions <mikael.hedin@irf.se>
+ * Support for ISAPnP by Ladislav Michl <ladis@psi.cz>
+ *
+ * Notes on the hardware
+ *
+ *  Frequency control is done digitally -- ie out(port,encodefreq(95.8));
+ *  No volume control - only mute/unmute - you have to use line volume
+ *  control on SB-part of SF16FMI
+ *  
+ */
+
+#include <linux/kernel.h>	/* __setup			*/
+#include <linux/module.h>	/* Modules 			*/
+#include <linux/init.h>		/* Initdata			*/
+#include <linux/ioport.h>	/* check_region, request_region	*/
+#include <linux/delay.h>	/* udelay			*/
+#include <linux/videodev.h>	/* kernel radio structs		*/
+#include <linux/isapnp.h>
+#include <asm/io.h>		/* outb, outb_p			*/
+#include <asm/uaccess.h>	/* copy to/from user		*/
+#include <asm/semaphore.h>
+
+struct fmi_device
+{
+	int port;
+        int curvol; /* 1 or 0 */
+        unsigned long curfreq; /* freq in kHz */
+        __u32 flags;
+};
+
+static int io = -1; 
+static int radio_nr = -1;
+static struct pnp_dev *dev = NULL;
+static struct semaphore lock;
+
+/* freq is in 1/16 kHz to internal number, hw precision is 50 kHz */
+/* It is only useful to give freq in intervall of 800 (=0.05Mhz),
+ * other bits will be truncated, e.g 92.7400016 -> 92.7, but 
+ * 92.7400017 -> 92.75
+ */
+#define RSF16_ENCODE(x)	((x)/800+214)
+#define RSF16_MINFREQ 87*16000
+#define RSF16_MAXFREQ 108*16000
+
+static void outbits(int bits, unsigned int data, int port)
+{
+	while(bits--) {
+ 		if(data & 1) {
+			outb(5, port);
+			udelay(6);
+			outb(7, port);
+			udelay(6);
+		} else {
+			outb(1, port);
+			udelay(6);
+			outb(3, port);
+			udelay(6);
+		}
+		data>>=1;
+	}
+}
+
+static inline void fmi_mute(int port)
+{
+	down(&lock);
+	outb(0x00, port);
+	up(&lock);
+}
+
+static inline void fmi_unmute(int port)
+{
+	down(&lock);
+	outb(0x08, port);
+	up(&lock);
+}
+
+static inline int fmi_setfreq(struct fmi_device *dev)
+{
+	int myport = dev->port;
+	unsigned long freq = dev->curfreq;
+
+	down(&lock);
+
+	outbits(16, RSF16_ENCODE(freq), myport);
+	outbits(8, 0xC0, myport);
+	msleep(143);		/* was schedule_timeout(HZ/7) */
+	up(&lock);
+	if (dev->curvol) fmi_unmute(myport);
+	return 0;
+}
+
+static inline int fmi_getsigstr(struct fmi_device *dev)
+{
+	int val;
+	int res;
+	int myport = dev->port;
+
+	
+	down(&lock);
+	val = dev->curvol ? 0x08 : 0x00;	/* unmute/mute */
+	outb(val, myport);
+	outb(val | 0x10, myport);
+	msleep(143); 		/* was schedule_timeout(HZ/7) */
+	res = (int)inb(myport+1);
+	outb(val, myport);
+	
+	up(&lock);
+	return (res & 2) ? 0 : 0xFFFF;
+}
+
+static int fmi_do_ioctl(struct inode *inode, struct file *file,
+			unsigned int cmd, void *arg)
+{
+	struct video_device *dev = video_devdata(file);
+	struct fmi_device *fmi=dev->priv;
+	
+	switch(cmd)
+	{
+		case VIDIOCGCAP:
+		{
+			struct video_capability *v = arg;
+			memset(v,0,sizeof(*v));
+			strcpy(v->name, "SF16-FMx radio");
+			v->type=VID_TYPE_TUNER;
+			v->channels=1;
+			v->audios=1;
+			return 0;
+		}
+		case VIDIOCGTUNER:
+		{
+			struct video_tuner *v = arg;
+			int mult;
+
+			if(v->tuner)	/* Only 1 tuner */
+				return -EINVAL;
+			strcpy(v->name, "FM");
+			mult = (fmi->flags & VIDEO_TUNER_LOW) ? 1 : 1000;
+			v->rangelow = RSF16_MINFREQ/mult;
+			v->rangehigh = RSF16_MAXFREQ/mult;
+			v->flags=fmi->flags;
+			v->mode=VIDEO_MODE_AUTO;
+			v->signal = fmi_getsigstr(fmi);
+			return 0;
+		}
+		case VIDIOCSTUNER:
+		{
+			struct video_tuner *v = arg;
+			if(v->tuner!=0)
+				return -EINVAL;
+			fmi->flags = v->flags & VIDEO_TUNER_LOW;
+			/* Only 1 tuner so no setting needed ! */
+			return 0;
+		}
+		case VIDIOCGFREQ:
+		{
+			unsigned long *freq = arg;
+			*freq = fmi->curfreq;
+			if (!(fmi->flags & VIDEO_TUNER_LOW))
+			    *freq /= 1000;
+			return 0;
+		}
+		case VIDIOCSFREQ:
+		{
+			unsigned long *freq = arg;
+			if (!(fmi->flags & VIDEO_TUNER_LOW))
+				*freq *= 1000;
+			if (*freq < RSF16_MINFREQ || *freq > RSF16_MAXFREQ )
+				return -EINVAL;
+			/*rounding in steps of 800 to match th freq
+			  that will be used */
+			fmi->curfreq = (*freq/800)*800; 
+			fmi_setfreq(fmi);
+			return 0;
+		}
+		case VIDIOCGAUDIO:
+		{	
+			struct video_audio *v = arg;
+			memset(v,0,sizeof(*v));
+			v->flags=( (!fmi->curvol)*VIDEO_AUDIO_MUTE | VIDEO_AUDIO_MUTABLE);
+			strcpy(v->name, "Radio");
+			v->mode=VIDEO_SOUND_STEREO;
+			return 0;			
+		}
+		case VIDIOCSAUDIO:
+		{
+			struct video_audio *v = arg;
+			if(v->audio)
+				return -EINVAL;
+			fmi->curvol= v->flags&VIDEO_AUDIO_MUTE ? 0 : 1;
+			fmi->curvol ? 
+				fmi_unmute(fmi->port) : fmi_mute(fmi->port);
+			return 0;
+		}
+	        case VIDIOCGUNIT:
+		{
+               		struct video_unit *v = arg;
+			v->video=VIDEO_NO_UNIT;
+			v->vbi=VIDEO_NO_UNIT;
+			v->radio=dev->minor;
+			v->audio=0; /* How do we find out this??? */
+			v->teletext=VIDEO_NO_UNIT;
+			return 0;			
+		}
+		default:
+			return -ENOIOCTLCMD;
+	}
+}
+
+static int fmi_ioctl(struct inode *inode, struct file *file,
+		     unsigned int cmd, unsigned long arg)
+{
+	return video_usercopy(inode, file, cmd, arg, fmi_do_ioctl);
+}
+
+static struct fmi_device fmi_unit;
+
+static struct file_operations fmi_fops = {
+	.owner		= THIS_MODULE,
+	.open           = video_exclusive_open,
+	.release        = video_exclusive_release,
+	.ioctl		= fmi_ioctl,
+	.llseek         = no_llseek,
+};
+
+static struct video_device fmi_radio=
+{
+	.owner		= THIS_MODULE,
+	.name		= "SF16FMx radio",
+	.type		= VID_TYPE_TUNER,
+	.hardware	= VID_HARDWARE_SF16MI,
+	.fops           = &fmi_fops,
+};
+
+/* ladis: this is my card. does any other types exist? */
+static struct isapnp_device_id id_table[] __devinitdata = {
+	{	ISAPNP_ANY_ID, ISAPNP_ANY_ID,
+		ISAPNP_VENDOR('M','F','R'), ISAPNP_FUNCTION(0xad10), 0},
+	{	ISAPNP_CARD_END, },
+};
+
+MODULE_DEVICE_TABLE(isapnp, id_table);
+
+static int isapnp_fmi_probe(void)
+{
+	int i = 0;
+
+	while (id_table[i].card_vendor != 0 && dev == NULL) {
+		dev = pnp_find_dev(NULL, id_table[i].vendor,
+				   id_table[i].function, NULL);
+		i++;
+	}
+
+	if (!dev)
+		return -ENODEV;
+	if (pnp_device_attach(dev) < 0)
+		return -EAGAIN;
+	if (pnp_activate_dev(dev) < 0) {
+		printk ("radio-sf16fmi: PnP configure failed (out of resources?)\n");
+		pnp_device_detach(dev);
+		return -ENOMEM;
+	}
+	if (!pnp_port_valid(dev, 0)) {
+		pnp_device_detach(dev);
+		return -ENODEV;
+	}
+
+	i = pnp_port_start(dev, 0);
+	printk ("radio-sf16fmi: PnP reports card at %#x\n", i);
+
+	return i;
+}
+
+static int __init fmi_init(void)
+{
+	if (io < 0)
+		io = isapnp_fmi_probe();
+	if (io < 0) {
+		printk(KERN_ERR "radio-sf16fmi: No PnP card found.\n");
+		return io;
+	}
+	if (!request_region(io, 2, "radio-sf16fmi")) {
+		printk(KERN_ERR "radio-sf16fmi: port 0x%x already in use\n", io);
+		return -EBUSY;
+	}
+
+	fmi_unit.port = io;
+	fmi_unit.curvol = 0;
+	fmi_unit.curfreq = 0;
+	fmi_unit.flags = VIDEO_TUNER_LOW;
+	fmi_radio.priv = &fmi_unit;
+	
+	init_MUTEX(&lock);
+	
+	if (video_register_device(&fmi_radio, VFL_TYPE_RADIO, radio_nr) == -1) {
+		release_region(io, 2);
+		return -EINVAL;
+	}
+		
+	printk(KERN_INFO "SF16FMx radio card driver at 0x%x\n", io);
+	/* mute card - prevents noisy bootups */
+	fmi_mute(io);
+	return 0;
+}
+
+MODULE_AUTHOR("Petr Vandrovec, vandrove@vc.cvut.cz and M. Kirkwood");
+MODULE_DESCRIPTION("A driver for the SF16MI radio.");
+MODULE_LICENSE("GPL");
+
+module_param(io, int, 0);
+MODULE_PARM_DESC(io, "I/O address of the SF16MI card (0x284 or 0x384)");
+module_param(radio_nr, int, 0);
+
+static void __exit fmi_cleanup_module(void)
+{
+	video_unregister_device(&fmi_radio);
+	release_region(io, 2);
+	if (dev)
+		pnp_device_detach(dev);
+}
+
+module_init(fmi_init);
+module_exit(fmi_cleanup_module);
