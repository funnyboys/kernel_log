commit 5800571960234f9d1f1011bf135799b2014d4268
Merge: d17589afa970 d1fdb6d8f6a4
Author: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
Date:   Tue Jun 11 12:09:28 2019 -0400

    Merge tag 'v5.2-rc4' into media/master
    
    There are some conflicts due to SPDX changes. We also have more
    patches being merged via media tree touching them.
    
    So, let's merge back from upstream and address those.
    
    Linux 5.2-rc4
    
    * tag 'v5.2-rc4': (767 commits)
      Linux 5.2-rc4
      MAINTAINERS: Karthikeyan Ramasubramanian is MIA
      i2c: xiic: Add max_read_len quirk
      lockref: Limit number of cmpxchg loop retries
      uaccess: add noop untagged_addr definition
      x86/insn-eval: Fix use-after-free access to LDT entry
      kbuild: use more portable 'command -v' for cc-cross-prefix
      s390/unwind: correct stack switching during unwind
      block, bfq: add weight symlink to the bfq.weight cgroup parameter
      cgroup: let a symlink too be created with a cftype file
      drm/nouveau/secboot/gp10[2467]: support newer FW to fix SEC2 failures on some boards
      drm/nouveau/secboot: enable loading of versioned LS PMU/SEC2 ACR msgqueue FW
      drm/nouveau/secboot: split out FW version-specific LS function pointers
      drm/nouveau/secboot: pass max supported FW version to LS load funcs
      drm/nouveau/core: support versioned firmware loading
      drm/nouveau/core: pass subdev into nvkm_firmware_get, rather than device
      block: free sched's request pool in blk_cleanup_queue
      pktgen: do not sleep with the thread lock held.
      net: mvpp2: Use strscpy to handle stat strings
      net: rds: fix memory leak in rds_ib_flush_mr_pool
      ...
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

commit e83ce3005db16243e1085925251fd0776bb60d09
Author: Hans Verkuil <hverkuil-cisco@xs4all.nl>
Date:   Tue Jun 4 07:19:52 2019 -0400

    media: media/radio: set device_caps in struct video_device
    
    Instead of filling in the struct v4l2_capability device_caps
    field, fill in the struct video_device device_caps field.
    
    That way the V4L2 core knows what the capabilities of the
    video device are.
    
    But this only really works if all drivers use this, so convert
    all radio drivers in this patch.
    
    Signed-off-by: Hans Verkuil <hverkuil-cisco@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/radio/radio-tea5777.c b/drivers/media/radio/radio-tea5777.c
index 61f751cf1aa4..17f9e21ff3c5 100644
--- a/drivers/media/radio/radio-tea5777.c
+++ b/drivers/media/radio/radio-tea5777.c
@@ -270,9 +270,6 @@ static int vidioc_querycap(struct file *file, void  *priv,
 	strscpy(v->card, tea->card, sizeof(v->card));
 	strlcat(v->card, " TEA5777", sizeof(v->card));
 	strscpy(v->bus_info, tea->bus_info, sizeof(v->bus_info));
-	v->device_caps = V4L2_CAP_TUNER | V4L2_CAP_RADIO;
-	v->device_caps |= V4L2_CAP_HW_FREQ_SEEK;
-	v->capabilities = v->device_caps | V4L2_CAP_DEVICE_CAPS;
 	return 0;
 }
 
@@ -563,6 +560,8 @@ int radio_tea5777_init(struct radio_tea5777 *tea, struct module *owner)
 	strscpy(tea->vd.name, tea->v4l2_dev->name, sizeof(tea->vd.name));
 	tea->vd.lock = &tea->mutex;
 	tea->vd.v4l2_dev = tea->v4l2_dev;
+	tea->vd.device_caps = V4L2_CAP_TUNER | V4L2_CAP_RADIO |
+			      V4L2_CAP_HW_FREQ_SEEK;
 	tea->fops = tea575x_fops;
 	tea->fops.owner = owner;
 	tea->vd.fops = &tea->fops;

commit c942fddf8793b2013be8c901b47d0a8dc02bf99f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:06 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 157
    
    Based on 3 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [kishon] [vijay] [abraham]
      [i] [kishon]@[ti] [com] this program is distributed in the hope that
      it will be useful but without any warranty without even the implied
      warranty of merchantability or fitness for a particular purpose see
      the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [graeme] [gregory]
      [gg]@[slimlogic] [co] [uk] [author] [kishon] [vijay] [abraham] [i]
      [kishon]@[ti] [com] [based] [on] [twl6030]_[usb] [c] [author] [hema]
      [hk] [hemahk]@[ti] [com] this program is distributed in the hope
      that it will be useful but without any warranty without even the
      implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1105 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.202006027@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/media/radio/radio-tea5777.c b/drivers/media/radio/radio-tea5777.c
index 61f751cf1aa4..49d4beba341e 100644
--- a/drivers/media/radio/radio-tea5777.c
+++ b/drivers/media/radio/radio-tea5777.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *   v4l2 driver for TEA5777 Philips AM/FM radio tuner chips
  *
@@ -6,17 +7,6 @@
  *   Based on the ALSA driver for TEA5757/5759 Philips AM/FM radio tuner chips:
  *
  *	Copyright (c) 2004 Jaroslav Kysela <perex@perex.cz>
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
  */
 
 #include <linux/delay.h>

commit c0decac19da3906d9b66291e57b7759489e1170f
Author: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
Date:   Mon Sep 10 08:19:14 2018 -0400

    media: use strscpy() instead of strlcpy()
    
    The implementation of strscpy() is more robust and safer.
    
    That's now the recommended way to copy NUL terminated strings.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Acked-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/radio/radio-tea5777.c b/drivers/media/radio/radio-tea5777.c
index 04ed1a5d1177..61f751cf1aa4 100644
--- a/drivers/media/radio/radio-tea5777.c
+++ b/drivers/media/radio/radio-tea5777.c
@@ -266,10 +266,10 @@ static int vidioc_querycap(struct file *file, void  *priv,
 {
 	struct radio_tea5777 *tea = video_drvdata(file);
 
-	strlcpy(v->driver, tea->v4l2_dev->name, sizeof(v->driver));
-	strlcpy(v->card, tea->card, sizeof(v->card));
+	strscpy(v->driver, tea->v4l2_dev->name, sizeof(v->driver));
+	strscpy(v->card, tea->card, sizeof(v->card));
 	strlcat(v->card, " TEA5777", sizeof(v->card));
-	strlcpy(v->bus_info, tea->bus_info, sizeof(v->bus_info));
+	strscpy(v->bus_info, tea->bus_info, sizeof(v->bus_info));
 	v->device_caps = V4L2_CAP_TUNER | V4L2_CAP_RADIO;
 	v->device_caps |= V4L2_CAP_HW_FREQ_SEEK;
 	v->capabilities = v->device_caps | V4L2_CAP_DEVICE_CAPS;
@@ -304,9 +304,9 @@ static int vidioc_g_tuner(struct file *file, void *priv,
 
 	memset(v, 0, sizeof(*v));
 	if (tea->has_am)
-		strlcpy(v->name, "AM/FM", sizeof(v->name));
+		strscpy(v->name, "AM/FM", sizeof(v->name));
 	else
-		strlcpy(v->name, "FM", sizeof(v->name));
+		strscpy(v->name, "FM", sizeof(v->name));
 	v->type = V4L2_TUNER_RADIO;
 	v->capability = V4L2_TUNER_CAP_LOW | V4L2_TUNER_CAP_STEREO |
 			V4L2_TUNER_CAP_FREQ_BANDS |
@@ -560,7 +560,7 @@ int radio_tea5777_init(struct radio_tea5777 *tea, struct module *owner)
 	tea->vd = tea575x_radio;
 	video_set_drvdata(&tea->vd, tea);
 	mutex_init(&tea->mutex);
-	strlcpy(tea->vd.name, tea->v4l2_dev->name, sizeof(tea->vd.name));
+	strscpy(tea->vd.name, tea->v4l2_dev->name, sizeof(tea->vd.name));
 	tea->vd.lock = &tea->mutex;
 	tea->vd.v4l2_dev = tea->v4l2_dev;
 	tea->fops = tea575x_fops;

commit bcb63314e2c23f1ed622418b65f9409512659c73
Author: Sakari Ailus <sakari.ailus@linux.intel.com>
Date:   Fri Oct 28 09:31:20 2016 -0200

    [media] media: Drop FSF's postal address from the source code files
    
    Drop the FSF's postal address from the source code files that typically
    contain mostly the license text. Of the 628 removed instances, 578 are
    outdated.
    
    The patch has been created with the following command without manual edits:
    
    git grep -l "675 Mass Ave\|59 Temple Place\|51 Franklin St" -- \
            drivers/media/ include/media|while read i; do i=$i perl -e '
    open(F,"< $ENV{i}");
    $a=join("", <F>);
    $a =~ s/[ \t]*\*\n.*You should.*\n.*along with.*\n.*(\n.*USA.*$)?\n//m
            && $a =~ s/(^.*)Or, (point your browser to) /$1To obtain the license, $2\n$1/m;
    close(F);
    open(F, "> $ENV{i}");
    print F $a;
    close(F);'; done
    
    Signed-off-by: Sakari Ailus <sakari.ailus@linux.intel.com>

diff --git a/drivers/media/radio/radio-tea5777.c b/drivers/media/radio/radio-tea5777.c
index 83fe7ab358df..04ed1a5d1177 100644
--- a/drivers/media/radio/radio-tea5777.c
+++ b/drivers/media/radio/radio-tea5777.c
@@ -17,10 +17,6 @@
  *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *   GNU General Public License for more details.
  *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
  */
 
 #include <linux/delay.h>

commit 95cd5d5ee67c2108765ae87d34761d54fd6671ce
Author: Ramakrishnan Muthukrishnan <ramakrmu@cisco.com>
Date:   Thu Jun 19 14:22:58 2014 -0300

    [media] media: remove the setting of the flag V4L2_FL_USE_FH_PRIO
    
    Since all the drivers that use `struct v4l2_fh' use the core
    priority checking, the setting of the flag in the drivers can
    be removed.
    
    Signed-off-by: Ramakrishnan Muthukrishnan <ramakrmu@cisco.com>
    Reviewed-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/drivers/media/radio/radio-tea5777.c b/drivers/media/radio/radio-tea5777.c
index e2455970725a..83fe7ab358df 100644
--- a/drivers/media/radio/radio-tea5777.c
+++ b/drivers/media/radio/radio-tea5777.c
@@ -570,7 +570,6 @@ int radio_tea5777_init(struct radio_tea5777 *tea, struct module *owner)
 	tea->fops = tea575x_fops;
 	tea->fops.owner = owner;
 	tea->vd.fops = &tea->fops;
-	set_bit(V4L2_FL_USE_FH_PRIO, &tea->vd.flags);
 
 	tea->vd.ctrl_handler = &tea->ctrl_handler;
 	v4l2_ctrl_handler_init(&tea->ctrl_handler, 1);

commit 2f73c7c582a685b3198b974cd6d964d0338f8ab5
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Fri Mar 15 06:10:06 2013 -0300

    [media] v4l2: add const to argument of write-only s_tuner ioctl
    
    This ioctl is defined as IOW, so pass the argument as const.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Acked-by: Alexey Klimov <klimov.linux@gmail.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-tea5777.c b/drivers/media/radio/radio-tea5777.c
index fcd7c195e0c5..e2455970725a 100644
--- a/drivers/media/radio/radio-tea5777.c
+++ b/drivers/media/radio/radio-tea5777.c
@@ -336,7 +336,7 @@ static int vidioc_g_tuner(struct file *file, void *priv,
 }
 
 static int vidioc_s_tuner(struct file *file, void *priv,
-					struct v4l2_tuner *v)
+					const struct v4l2_tuner *v)
 {
 	struct radio_tea5777 *tea = video_drvdata(file);
 	u32 orig_audmode = tea->audmode;
@@ -344,10 +344,9 @@ static int vidioc_s_tuner(struct file *file, void *priv,
 	if (v->index)
 		return -EINVAL;
 
-	if (v->audmode > V4L2_TUNER_MODE_STEREO)
-		v->audmode = V4L2_TUNER_MODE_STEREO;
-
 	tea->audmode = v->audmode;
+	if (tea->audmode > V4L2_TUNER_MODE_STEREO)
+		tea->audmode = V4L2_TUNER_MODE_STEREO;
 
 	if (tea->audmode != orig_audmode && tea->band == BAND_FM)
 		return radio_tea5777_set_freq(tea);

commit b530a447bb588fdf43fdf4eb909e4ee1921d47ac
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Tue Mar 19 04:09:26 2013 -0300

    [media] v4l2: add const to argument of write-only s_frequency ioctl
    
    This ioctl is defined as IOW, so pass the argument as const.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-tea5777.c b/drivers/media/radio/radio-tea5777.c
index 4b5190d4fea5..fcd7c195e0c5 100644
--- a/drivers/media/radio/radio-tea5777.c
+++ b/drivers/media/radio/radio-tea5777.c
@@ -368,7 +368,7 @@ static int vidioc_g_frequency(struct file *file, void *priv,
 }
 
 static int vidioc_s_frequency(struct file *file, void *priv,
-					struct v4l2_frequency *f)
+					const struct v4l2_frequency *f)
 {
 	struct radio_tea5777 *tea = video_drvdata(file);
 

commit 617ade61ea88a370c89960918eddfa10c41316f5
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Fri Sep 21 09:33:35 2012 -0300

    [media] radio drivers: in non-blocking mode return EAGAIN in hwseek
    
    VIDIOC_S_HW_FREQ_SEEK should return EAGAIN when called in non-blocking
    mode. This might change in the future if we add support for this in the
    future, but right now this is not supported.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-tea5777.c b/drivers/media/radio/radio-tea5777.c
index c1a2ea6e87a3..4b5190d4fea5 100644
--- a/drivers/media/radio/radio-tea5777.c
+++ b/drivers/media/radio/radio-tea5777.c
@@ -397,6 +397,9 @@ static int vidioc_s_hw_freq_seek(struct file *file, void *fh,
 	if (a->tuner || a->wrap_around)
 		return -EINVAL;
 
+	if (file->f_flags & O_NONBLOCK)
+		return -EWOULDBLOCK;
+
 	if (rangelow || rangehigh) {
 		for (i = 0; i < ARRAY_SIZE(bands); i++) {
 			if (i == BAND_AM && !tea->has_am)

commit ec6f4328108f1c83d5ac907c0d978fa886ef9627
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Fri Sep 14 07:41:18 2012 -0300

    [media] v4l2: make vidioc_s_freq_hw_seek const
    
    Write-only ioctls should have a const argument in the ioctl op.
    Do this conversion for vidioc_s_freq_hw_seek.
    Adding const for write-only ioctls was decided during the 2012 Media Workshop.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-tea5777.c b/drivers/media/radio/radio-tea5777.c
index ef8289829794..c1a2ea6e87a3 100644
--- a/drivers/media/radio/radio-tea5777.c
+++ b/drivers/media/radio/radio-tea5777.c
@@ -385,59 +385,61 @@ static int vidioc_s_frequency(struct file *file, void *priv,
 }
 
 static int vidioc_s_hw_freq_seek(struct file *file, void *fh,
-					struct v4l2_hw_freq_seek *a)
+					const struct v4l2_hw_freq_seek *a)
 {
 	struct radio_tea5777 *tea = video_drvdata(file);
 	unsigned long timeout;
+	u32 rangelow = a->rangelow;
+	u32 rangehigh = a->rangehigh;
 	int i, res, spacing;
 	u32 orig_freq;
 
 	if (a->tuner || a->wrap_around)
 		return -EINVAL;
 
-	if (a->rangelow || a->rangehigh) {
+	if (rangelow || rangehigh) {
 		for (i = 0; i < ARRAY_SIZE(bands); i++) {
 			if (i == BAND_AM && !tea->has_am)
 				continue;
-			if (bands[i].rangelow  >= a->rangelow &&
-			    bands[i].rangehigh <= a->rangehigh)
+			if (bands[i].rangelow  >= rangelow &&
+			    bands[i].rangehigh <= rangehigh)
 				break;
 		}
 		if (i == ARRAY_SIZE(bands))
 			return -EINVAL; /* No matching band found */
 
 		tea->band = i;
-		if (tea->freq < a->rangelow || tea->freq > a->rangehigh) {
-			tea->freq = clamp(tea->freq, a->rangelow,
-						     a->rangehigh);
+		if (tea->freq < rangelow || tea->freq > rangehigh) {
+			tea->freq = clamp(tea->freq, rangelow,
+						     rangehigh);
 			res = radio_tea5777_set_freq(tea);
 			if (res)
 				return res;
 		}
 	} else {
-		a->rangelow  = bands[tea->band].rangelow;
-		a->rangehigh = bands[tea->band].rangehigh;
+		rangelow  = bands[tea->band].rangelow;
+		rangehigh = bands[tea->band].rangehigh;
 	}
 
 	spacing   = (tea->band == BAND_AM) ? (5 * 16) : (200 * 16); /* kHz */
 	orig_freq = tea->freq;
 
 	tea->write_reg |= TEA5777_W_PROGBLIM_MASK;
-	if (tea->seek_rangelow != a->rangelow) {
+	if (tea->seek_rangelow != rangelow) {
 		tea->write_reg &= ~TEA5777_W_UPDWN_MASK;
-		tea->freq = a->rangelow;
+		tea->freq = rangelow;
 		res = radio_tea5777_set_freq(tea);
 		if (res)
 			goto leave;
-		tea->seek_rangelow = a->rangelow;
+		tea->seek_rangelow = rangelow;
 	}
-	if (tea->seek_rangehigh != a->rangehigh) {
+	if (tea->seek_rangehigh != rangehigh) {
 		tea->write_reg |= TEA5777_W_UPDWN_MASK;
-		tea->freq = a->rangehigh;
+		tea->freq = rangehigh;
 		res = radio_tea5777_set_freq(tea);
 		if (res)
 			goto leave;
-		tea->seek_rangehigh = a->rangehigh;
+		tea->seek_rangehigh = rangehigh;
 	}
 	tea->write_reg &= ~TEA5777_W_PROGBLIM_MASK;
 

commit d1f280d615a0f0b723dac5a2cd3f2f7f18bca4fa
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Sat Aug 11 12:37:13 2012 -0300

    [media] radio-shark2: Add support for suspend & resume
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-tea5777.c b/drivers/media/radio/radio-tea5777.c
index 818e57c20086..ef8289829794 100644
--- a/drivers/media/radio/radio-tea5777.c
+++ b/drivers/media/radio/radio-tea5777.c
@@ -184,7 +184,7 @@ static u32 tea5777_freq_to_v4l2_freq(struct radio_tea5777 *tea, u32 freq)
 	return 0; /* Never reached */
 }
 
-static int radio_tea5777_set_freq(struct radio_tea5777 *tea)
+int radio_tea5777_set_freq(struct radio_tea5777 *tea)
 {
 	u32 freq;
 	int res;

commit d7aab0bf9dbd658c25e815aa034042aed6801f3e
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Fri Aug 10 15:49:59 2012 -0300

    [media] radio-tea5777: Add support for tuning AM
    
    This completes my work on the Griffin radioSHARK2 driver, let me use this
    opportunity to thank Hisaaki Shibata for his generous donation of a
    Griffin radioSHARK2 to me, which has made this driver possible.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-tea5777.c b/drivers/media/radio/radio-tea5777.c
index 8cfa364b8190..818e57c20086 100644
--- a/drivers/media/radio/radio-tea5777.c
+++ b/drivers/media/radio/radio-tea5777.c
@@ -39,13 +39,11 @@ MODULE_AUTHOR("Hans de Goede <perex@perex.cz>");
 MODULE_DESCRIPTION("Routines for control of TEA5777 Philips AM/FM radio tuner chips");
 MODULE_LICENSE("GPL");
 
-/* Fixed FM only band for now, will implement multi-band support when the
-   VIDIOC_ENUM_FREQ_BANDS API is upstream */
-#define TEA5777_FM_RANGELOW		(76000 * 16)
-#define TEA5777_FM_RANGEHIGH		(108000 * 16)
-
 #define TEA5777_FM_IF			150 /* kHz */
-#define TEA5777_FM_FREQ_STEP		50 /* kHz */
+#define TEA5777_FM_FREQ_STEP		50  /* kHz */
+
+#define TEA5777_AM_IF			21  /* kHz */
+#define TEA5777_AM_FREQ_STEP		1   /* kHz */
 
 /* Write reg, common bits */
 #define TEA5777_W_MUTE_MASK		(1LL << 47)
@@ -94,7 +92,7 @@ MODULE_LICENSE("GPL");
 #define TEA5777_W_FM_PLL_SHIFT		32
 #define TEA5777_W_FM_FREF_MASK		(0x03LL << 30)
 #define TEA5777_W_FM_FREF_SHIFT		30
-#define TEA5777_W_FM_FREF_VALUE		0 /* 50 kHz tune steps, 150 kHz IF */
+#define TEA5777_W_FM_FREF_VALUE		0LL /* 50k steps, 150k IF */
 
 #define TEA5777_W_FM_FORCEMONO_MASK	(1LL << 15)
 #define TEA5777_W_FM_FORCEMONO_SHIFT	15
@@ -115,6 +113,8 @@ MODULE_LICENSE("GPL");
 #define TEA5777_W_AM_AGCIF_SHIFT	32
 #define TEA5777_W_AM_MWLW_MASK		(1LL << 31)
 #define TEA5777_W_AM_MWLW_SHIFT		31
+#define TEA5777_W_AM_LW			0LL
+#define TEA5777_W_AM_MW			1LL
 #define TEA5777_W_AM_LNA_MASK		(1LL << 30)
 #define TEA5777_W_AM_LNA_SHIFT		30
 
@@ -147,9 +147,41 @@ MODULE_LICENSE("GPL");
 #define TEA5777_R_FM_PLL_MASK		0x1fff
 #define TEA5777_R_FM_PLL_SHIFT		0
 
+enum { BAND_FM, BAND_AM };
+
+static const struct v4l2_frequency_band bands[] = {
+	{
+		.type = V4L2_TUNER_RADIO,
+		.index = 0,
+		.capability = V4L2_TUNER_CAP_LOW | V4L2_TUNER_CAP_STEREO |
+			      V4L2_TUNER_CAP_FREQ_BANDS |
+			      V4L2_TUNER_CAP_HWSEEK_BOUNDED |
+			      V4L2_TUNER_CAP_HWSEEK_PROG_LIM,
+		.rangelow   =  76000 * 16,
+		.rangehigh  = 108000 * 16,
+		.modulation = V4L2_BAND_MODULATION_FM,
+	},
+	{
+		.type = V4L2_TUNER_RADIO,
+		.index = 1,
+		.capability = V4L2_TUNER_CAP_LOW | V4L2_TUNER_CAP_FREQ_BANDS |
+			      V4L2_TUNER_CAP_HWSEEK_BOUNDED |
+			      V4L2_TUNER_CAP_HWSEEK_PROG_LIM,
+		.rangelow   =  530 * 16,
+		.rangehigh  = 1710 * 16,
+		.modulation = V4L2_BAND_MODULATION_AM,
+	},
+};
+
 static u32 tea5777_freq_to_v4l2_freq(struct radio_tea5777 *tea, u32 freq)
 {
-	return (freq * TEA5777_FM_FREQ_STEP + TEA5777_FM_IF) * 16;
+	switch (tea->band) {
+	case BAND_FM:
+		return (freq * TEA5777_FM_FREQ_STEP + TEA5777_FM_IF) * 16;
+	case BAND_AM:
+		return (freq * TEA5777_AM_FREQ_STEP + TEA5777_AM_IF) * 16;
+	}
+	return 0; /* Never reached */
 }
 
 static int radio_tea5777_set_freq(struct radio_tea5777 *tea)
@@ -157,15 +189,40 @@ static int radio_tea5777_set_freq(struct radio_tea5777 *tea)
 	u32 freq;
 	int res;
 
-	freq = clamp_t(u32, tea->freq,
-		       TEA5777_FM_RANGELOW, TEA5777_FM_RANGEHIGH);
+	freq = clamp(tea->freq, bands[tea->band].rangelow,
+				bands[tea->band].rangehigh);
 	freq = (freq + 8) / 16; /* to kHz */
 
-	freq = (freq - TEA5777_FM_IF) / TEA5777_FM_FREQ_STEP;
-
-	tea->write_reg &= ~(TEA5777_W_FM_PLL_MASK | TEA5777_W_FM_FREF_MASK);
-	tea->write_reg |= (u64)freq << TEA5777_W_FM_PLL_SHIFT;
-	tea->write_reg |= TEA5777_W_FM_FREF_VALUE << TEA5777_W_FM_FREF_SHIFT;
+	switch (tea->band) {
+	case BAND_FM:
+		tea->write_reg &= ~TEA5777_W_AM_FM_MASK;
+		freq = (freq - TEA5777_FM_IF) / TEA5777_FM_FREQ_STEP;
+		tea->write_reg &= ~TEA5777_W_FM_PLL_MASK;
+		tea->write_reg |= (u64)freq << TEA5777_W_FM_PLL_SHIFT;
+		tea->write_reg &= ~TEA5777_W_FM_FREF_MASK;
+		tea->write_reg |= TEA5777_W_FM_FREF_VALUE <<
+				  TEA5777_W_FM_FREF_SHIFT;
+		tea->write_reg &= ~TEA5777_W_FM_FORCEMONO_MASK;
+		if (tea->audmode == V4L2_TUNER_MODE_MONO)
+			tea->write_reg |= 1LL << TEA5777_W_FM_FORCEMONO_SHIFT;
+		break;
+	case BAND_AM:
+		tea->write_reg &= ~TEA5777_W_AM_FM_MASK;
+		tea->write_reg |= (1LL << TEA5777_W_AM_FM_SHIFT);
+		freq = (freq - TEA5777_AM_IF) / TEA5777_AM_FREQ_STEP;
+		tea->write_reg &= ~TEA5777_W_AM_PLL_MASK;
+		tea->write_reg |= (u64)freq << TEA5777_W_AM_PLL_SHIFT;
+		tea->write_reg &= ~TEA5777_W_AM_AGCRF_MASK;
+		tea->write_reg &= ~TEA5777_W_AM_AGCRF_MASK;
+		tea->write_reg &= ~TEA5777_W_AM_MWLW_MASK;
+		tea->write_reg |= TEA5777_W_AM_MW << TEA5777_W_AM_MWLW_SHIFT;
+		tea->write_reg &= ~TEA5777_W_AM_LNA_MASK;
+		tea->write_reg |= 1LL << TEA5777_W_AM_LNA_SHIFT;
+		tea->write_reg &= ~TEA5777_W_AM_PEAK_MASK;
+		tea->write_reg |= 1LL << TEA5777_W_AM_PEAK_SHIFT;
+		tea->write_reg &= ~TEA5777_W_AM_CALLIGN_MASK;
+		break;
+	}
 
 	res = tea->ops->write_reg(tea, tea->write_reg);
 	if (res)
@@ -223,6 +280,19 @@ static int vidioc_querycap(struct file *file, void  *priv,
 	return 0;
 }
 
+static int vidioc_enum_freq_bands(struct file *file, void *priv,
+					 struct v4l2_frequency_band *band)
+{
+	struct radio_tea5777 *tea = video_drvdata(file);
+
+	if (band->tuner != 0 || band->index >= ARRAY_SIZE(bands) ||
+	    (!tea->has_am && band->index == BAND_AM))
+		return -EINVAL;
+
+	*band = bands[band->index];
+	return 0;
+}
+
 static int vidioc_g_tuner(struct file *file, void *priv,
 					struct v4l2_tuner *v)
 {
@@ -243,13 +313,18 @@ static int vidioc_g_tuner(struct file *file, void *priv,
 		strlcpy(v->name, "FM", sizeof(v->name));
 	v->type = V4L2_TUNER_RADIO;
 	v->capability = V4L2_TUNER_CAP_LOW | V4L2_TUNER_CAP_STEREO |
-			V4L2_TUNER_CAP_HWSEEK_BOUNDED;
-	v->rangelow   = TEA5777_FM_RANGELOW;
-	v->rangehigh  = TEA5777_FM_RANGEHIGH;
-	v->rxsubchans = (tea->read_reg & TEA5777_R_FM_STEREO_MASK) ?
-			V4L2_TUNER_SUB_STEREO : V4L2_TUNER_SUB_MONO;
-	v->audmode = (tea->write_reg & TEA5777_W_FM_FORCEMONO_MASK) ?
-		V4L2_TUNER_MODE_MONO : V4L2_TUNER_MODE_STEREO;
+			V4L2_TUNER_CAP_FREQ_BANDS |
+			V4L2_TUNER_CAP_HWSEEK_BOUNDED |
+			V4L2_TUNER_CAP_HWSEEK_PROG_LIM;
+	v->rangelow   = tea->has_am ? bands[BAND_AM].rangelow :
+				      bands[BAND_FM].rangelow;
+	v->rangehigh  = bands[BAND_FM].rangehigh;
+	if (tea->band == BAND_FM &&
+			(tea->read_reg & TEA5777_R_FM_STEREO_MASK))
+		v->rxsubchans = V4L2_TUNER_SUB_STEREO;
+	else
+		v->rxsubchans = V4L2_TUNER_SUB_MONO;
+	v->audmode = tea->audmode;
 	/* shift - 12 to convert 4-bits (0-15) scale to 16-bits (0-65535) */
 	v->signal = (tea->read_reg & TEA5777_R_LEVEL_MASK) >>
 		    (TEA5777_R_LEVEL_SHIFT - 12);
@@ -264,16 +339,20 @@ static int vidioc_s_tuner(struct file *file, void *priv,
 					struct v4l2_tuner *v)
 {
 	struct radio_tea5777 *tea = video_drvdata(file);
+	u32 orig_audmode = tea->audmode;
 
 	if (v->index)
 		return -EINVAL;
 
-	if (v->audmode == V4L2_TUNER_MODE_MONO)
-		tea->write_reg |= TEA5777_W_FM_FORCEMONO_MASK;
-	else
-		tea->write_reg &= ~TEA5777_W_FM_FORCEMONO_MASK;
+	if (v->audmode > V4L2_TUNER_MODE_STEREO)
+		v->audmode = V4L2_TUNER_MODE_STEREO;
 
-	return radio_tea5777_set_freq(tea);
+	tea->audmode = v->audmode;
+
+	if (tea->audmode != orig_audmode && tea->band == BAND_FM)
+		return radio_tea5777_set_freq(tea);
+
+	return 0;
 }
 
 static int vidioc_g_frequency(struct file *file, void *priv,
@@ -296,6 +375,11 @@ static int vidioc_s_frequency(struct file *file, void *priv,
 	if (f->tuner != 0 || f->type != V4L2_TUNER_RADIO)
 		return -EINVAL;
 
+	if (tea->has_am && f->frequency < (20000 * 16))
+		tea->band = BAND_AM;
+	else
+		tea->band = BAND_FM;
+
 	tea->freq = f->frequency;
 	return radio_tea5777_set_freq(tea);
 }
@@ -304,32 +388,56 @@ static int vidioc_s_hw_freq_seek(struct file *file, void *fh,
 					struct v4l2_hw_freq_seek *a)
 {
 	struct radio_tea5777 *tea = video_drvdata(file);
-	u32 orig_freq = tea->freq;
 	unsigned long timeout;
-	int res, spacing = 200 * 16; /* 200 kHz */
-	/* These are fixed *for now* */
-	const u32 seek_rangelow  = TEA5777_FM_RANGELOW;
-	const u32 seek_rangehigh = TEA5777_FM_RANGEHIGH;
+	int i, res, spacing;
+	u32 orig_freq;
 
 	if (a->tuner || a->wrap_around)
 		return -EINVAL;
 
+	if (a->rangelow || a->rangehigh) {
+		for (i = 0; i < ARRAY_SIZE(bands); i++) {
+			if (i == BAND_AM && !tea->has_am)
+				continue;
+			if (bands[i].rangelow  >= a->rangelow &&
+			    bands[i].rangehigh <= a->rangehigh)
+				break;
+		}
+		if (i == ARRAY_SIZE(bands))
+			return -EINVAL; /* No matching band found */
+
+		tea->band = i;
+		if (tea->freq < a->rangelow || tea->freq > a->rangehigh) {
+			tea->freq = clamp(tea->freq, a->rangelow,
+						     a->rangehigh);
+			res = radio_tea5777_set_freq(tea);
+			if (res)
+				return res;
+		}
+	} else {
+		a->rangelow  = bands[tea->band].rangelow;
+		a->rangehigh = bands[tea->band].rangehigh;
+	}
+
+	spacing   = (tea->band == BAND_AM) ? (5 * 16) : (200 * 16); /* kHz */
+	orig_freq = tea->freq;
+
 	tea->write_reg |= TEA5777_W_PROGBLIM_MASK;
-	if (seek_rangelow != tea->seek_rangelow) {
+	if (tea->seek_rangelow != a->rangelow) {
 		tea->write_reg &= ~TEA5777_W_UPDWN_MASK;
-		tea->freq = seek_rangelow;
+		tea->freq = a->rangelow;
 		res = radio_tea5777_set_freq(tea);
 		if (res)
 			goto leave;
-		tea->seek_rangelow = tea->freq;
+		tea->seek_rangelow = a->rangelow;
 	}
-	if (seek_rangehigh != tea->seek_rangehigh) {
+	if (tea->seek_rangehigh != a->rangehigh) {
 		tea->write_reg |= TEA5777_W_UPDWN_MASK;
-		tea->freq = seek_rangehigh;
+		tea->freq = a->rangehigh;
 		res = radio_tea5777_set_freq(tea);
 		if (res)
 			goto leave;
-		tea->seek_rangehigh = tea->freq;
+		tea->seek_rangehigh = a->rangehigh;
 	}
 	tea->write_reg &= ~TEA5777_W_PROGBLIM_MASK;
 
@@ -417,6 +525,7 @@ static const struct v4l2_ioctl_ops tea575x_ioctl_ops = {
 	.vidioc_g_frequency = vidioc_g_frequency,
 	.vidioc_s_frequency = vidioc_s_frequency,
 	.vidioc_s_hw_freq_seek = vidioc_s_hw_freq_seek,
+	.vidioc_enum_freq_bands = vidioc_enum_freq_bands,
 	.vidioc_log_status  = v4l2_ctrl_log_status,
 	.vidioc_subscribe_event = v4l2_ctrl_subscribe_event,
 	.vidioc_unsubscribe_event = v4l2_event_unsubscribe,
@@ -439,8 +548,9 @@ int radio_tea5777_init(struct radio_tea5777 *tea, struct module *owner)
 			 (1LL << TEA5777_W_IFW_SHIFT) |
 			 (1LL << TEA5777_W_INTEXT_SHIFT) |
 			 (1LL << TEA5777_W_CHP0_SHIFT) |
-			 (2LL << TEA5777_W_SLEV_SHIFT);
+			 (1LL << TEA5777_W_SLEV_SHIFT);
 	tea->freq = 90500 * 16;	/* 90.5Mhz default */
+	tea->audmode = V4L2_TUNER_MODE_STEREO;
 	res = radio_tea5777_set_freq(tea);
 	if (res) {
 		v4l2_err(tea->v4l2_dev, "can't set initial freq (%d)\n", res);

commit 4fad5c474f9078dd133996cabaffdb5df8a1e28e
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Fri Aug 10 07:47:25 2012 -0300

    [media] radio-tea5777.c: Get rid of do_div usage
    
    freq fits easily into 32 bits until it gets shifted, so make it 32 bits,
    and cast it to 64 bits before shifting.
    
    [mchehab@redhat.com: also remove asm/div64.h header, as this is not
     needed anymore]
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-tea5777.c b/drivers/media/radio/radio-tea5777.c
index 5bc9fa62720b..8cfa364b8190 100644
--- a/drivers/media/radio/radio-tea5777.c
+++ b/drivers/media/radio/radio-tea5777.c
@@ -33,7 +33,6 @@
 #include <media/v4l2-fh.h>
 #include <media/v4l2-ioctl.h>
 #include <media/v4l2-event.h>
-#include <asm/div64.h>
 #include "radio-tea5777.h"
 
 MODULE_AUTHOR("Hans de Goede <perex@perex.cz>");
@@ -155,18 +154,17 @@ static u32 tea5777_freq_to_v4l2_freq(struct radio_tea5777 *tea, u32 freq)
 
 static int radio_tea5777_set_freq(struct radio_tea5777 *tea)
 {
-	u64 freq;
+	u32 freq;
 	int res;
 
 	freq = clamp_t(u32, tea->freq,
-		       TEA5777_FM_RANGELOW, TEA5777_FM_RANGEHIGH) + 8;
-	do_div(freq, 16); /* to kHz */
+		       TEA5777_FM_RANGELOW, TEA5777_FM_RANGEHIGH);
+	freq = (freq + 8) / 16; /* to kHz */
 
-	freq -= TEA5777_FM_IF;
-	do_div(freq, TEA5777_FM_FREQ_STEP);
+	freq = (freq - TEA5777_FM_IF) / TEA5777_FM_FREQ_STEP;
 
 	tea->write_reg &= ~(TEA5777_W_FM_PLL_MASK | TEA5777_W_FM_FREF_MASK);
-	tea->write_reg |= freq << TEA5777_W_FM_PLL_SHIFT;
+	tea->write_reg |= (u64)freq << TEA5777_W_FM_PLL_SHIFT;
 	tea->write_reg |= TEA5777_W_FM_FREF_VALUE << TEA5777_W_FM_FREF_SHIFT;
 
 	res = tea->ops->write_reg(tea, tea->write_reg);

commit 2f2da1e2995c9362babd7da3cc9d340be184ea73
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Tue Jul 31 16:38:41 2012 -0300

    [media] radio-tea5777: use library for 64bits div
    
    drivers/built-in.o: In function `radio_tea5777_set_freq':
    radio-tea5777.c:(.text+0x4d8704): undefined reference to `__udivdi3'
    
    Reported-by: Randy Dunlap <rdunlap@xenotime.net>
    Cc: Hans de Goede <hdegoede@redhat.com>
    Acked-by: Randy Dunlap <rdunlap@xenotime.net>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-tea5777.c b/drivers/media/radio/radio-tea5777.c
index 3e12179364f8..5bc9fa62720b 100644
--- a/drivers/media/radio/radio-tea5777.c
+++ b/drivers/media/radio/radio-tea5777.c
@@ -33,6 +33,7 @@
 #include <media/v4l2-fh.h>
 #include <media/v4l2-ioctl.h>
 #include <media/v4l2-event.h>
+#include <asm/div64.h>
 #include "radio-tea5777.h"
 
 MODULE_AUTHOR("Hans de Goede <perex@perex.cz>");
@@ -158,10 +159,11 @@ static int radio_tea5777_set_freq(struct radio_tea5777 *tea)
 	int res;
 
 	freq = clamp_t(u32, tea->freq,
-		       TEA5777_FM_RANGELOW, TEA5777_FM_RANGEHIGH);
-	freq = (freq + 8) / 16; /* to kHz */
+		       TEA5777_FM_RANGELOW, TEA5777_FM_RANGEHIGH) + 8;
+	do_div(freq, 16); /* to kHz */
 
-	freq = (freq - TEA5777_FM_IF) / TEA5777_FM_FREQ_STEP;
+	freq -= TEA5777_FM_IF;
+	do_div(freq, TEA5777_FM_FREQ_STEP);
 
 	tea->write_reg &= ~(TEA5777_W_FM_PLL_MASK | TEA5777_W_FM_FREF_MASK);
 	tea->write_reg |= freq << TEA5777_W_FM_PLL_SHIFT;

commit 4faba767c6243b43ad975406fe027be7394e4591
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Sat Jun 23 04:39:58 2012 -0300

    [media] shark2: New driver for the Griffin radioSHARK v2 USB radio receiver
    
    This driver consists of 2 parts, a generic tea5777 driver and a driver
    for the Griffin radioSHARK v2 USB radio receiver, which is the only driver
    using the generic tea5777 for now.
    
    This first version only implements FM support, once the the new
    VIDIOC_ENUM_FREQ_BANDS API is upstream I'll also add AM support.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-tea5777.c b/drivers/media/radio/radio-tea5777.c
new file mode 100644
index 000000000000..3e12179364f8
--- /dev/null
+++ b/drivers/media/radio/radio-tea5777.c
@@ -0,0 +1,489 @@
+/*
+ *   v4l2 driver for TEA5777 Philips AM/FM radio tuner chips
+ *
+ *	Copyright (c) 2012 Hans de Goede <hdegoede@redhat.com>
+ *
+ *   Based on the ALSA driver for TEA5757/5759 Philips AM/FM radio tuner chips:
+ *
+ *	Copyright (c) 2004 Jaroslav Kysela <perex@perex.cz>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-dev.h>
+#include <media/v4l2-fh.h>
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-event.h>
+#include "radio-tea5777.h"
+
+MODULE_AUTHOR("Hans de Goede <perex@perex.cz>");
+MODULE_DESCRIPTION("Routines for control of TEA5777 Philips AM/FM radio tuner chips");
+MODULE_LICENSE("GPL");
+
+/* Fixed FM only band for now, will implement multi-band support when the
+   VIDIOC_ENUM_FREQ_BANDS API is upstream */
+#define TEA5777_FM_RANGELOW		(76000 * 16)
+#define TEA5777_FM_RANGEHIGH		(108000 * 16)
+
+#define TEA5777_FM_IF			150 /* kHz */
+#define TEA5777_FM_FREQ_STEP		50 /* kHz */
+
+/* Write reg, common bits */
+#define TEA5777_W_MUTE_MASK		(1LL << 47)
+#define TEA5777_W_MUTE_SHIFT		47
+#define TEA5777_W_AM_FM_MASK		(1LL << 46)
+#define TEA5777_W_AM_FM_SHIFT		46
+#define TEA5777_W_STB_MASK		(1LL << 45)
+#define TEA5777_W_STB_SHIFT		45
+
+#define TEA5777_W_IFCE_MASK		(1LL << 29)
+#define TEA5777_W_IFCE_SHIFT		29
+#define TEA5777_W_IFW_MASK		(1LL << 28)
+#define TEA5777_W_IFW_SHIFT		28
+#define TEA5777_W_HILO_MASK		(1LL << 27)
+#define TEA5777_W_HILO_SHIFT		27
+#define TEA5777_W_DBUS_MASK		(1LL << 26)
+#define TEA5777_W_DBUS_SHIFT		26
+
+#define TEA5777_W_INTEXT_MASK		(1LL << 24)
+#define TEA5777_W_INTEXT_SHIFT		24
+#define TEA5777_W_P1_MASK		(1LL << 23)
+#define TEA5777_W_P1_SHIFT		23
+#define TEA5777_W_P0_MASK		(1LL << 22)
+#define TEA5777_W_P0_SHIFT		22
+#define TEA5777_W_PEN1_MASK		(1LL << 21)
+#define TEA5777_W_PEN1_SHIFT		21
+#define TEA5777_W_PEN0_MASK		(1LL << 20)
+#define TEA5777_W_PEN0_SHIFT		20
+
+#define TEA5777_W_CHP0_MASK		(1LL << 18)
+#define TEA5777_W_CHP0_SHIFT		18
+#define TEA5777_W_DEEM_MASK		(1LL << 17)
+#define TEA5777_W_DEEM_SHIFT		17
+
+#define TEA5777_W_SEARCH_MASK		(1LL << 7)
+#define TEA5777_W_SEARCH_SHIFT		7
+#define TEA5777_W_PROGBLIM_MASK		(1LL << 6)
+#define TEA5777_W_PROGBLIM_SHIFT	6
+#define TEA5777_W_UPDWN_MASK		(1LL << 5)
+#define TEA5777_W_UPDWN_SHIFT		5
+#define TEA5777_W_SLEV_MASK		(3LL << 3)
+#define TEA5777_W_SLEV_SHIFT		3
+
+/* Write reg, FM specific bits */
+#define TEA5777_W_FM_PLL_MASK		(0x1fffLL << 32)
+#define TEA5777_W_FM_PLL_SHIFT		32
+#define TEA5777_W_FM_FREF_MASK		(0x03LL << 30)
+#define TEA5777_W_FM_FREF_SHIFT		30
+#define TEA5777_W_FM_FREF_VALUE		0 /* 50 kHz tune steps, 150 kHz IF */
+
+#define TEA5777_W_FM_FORCEMONO_MASK	(1LL << 15)
+#define TEA5777_W_FM_FORCEMONO_SHIFT	15
+#define TEA5777_W_FM_SDSOFF_MASK	(1LL << 14)
+#define TEA5777_W_FM_SDSOFF_SHIFT	14
+#define TEA5777_W_FM_DOFF_MASK		(1LL << 13)
+#define TEA5777_W_FM_DOFF_SHIFT		13
+
+#define TEA5777_W_FM_STEP_MASK		(3LL << 1)
+#define TEA5777_W_FM_STEP_SHIFT		1
+
+/* Write reg, AM specific bits */
+#define TEA5777_W_AM_PLL_MASK		(0x7ffLL << 34)
+#define TEA5777_W_AM_PLL_SHIFT		34
+#define TEA5777_W_AM_AGCRF_MASK		(1LL << 33)
+#define TEA5777_W_AM_AGCRF_SHIFT	33
+#define TEA5777_W_AM_AGCIF_MASK		(1LL << 32)
+#define TEA5777_W_AM_AGCIF_SHIFT	32
+#define TEA5777_W_AM_MWLW_MASK		(1LL << 31)
+#define TEA5777_W_AM_MWLW_SHIFT		31
+#define TEA5777_W_AM_LNA_MASK		(1LL << 30)
+#define TEA5777_W_AM_LNA_SHIFT		30
+
+#define TEA5777_W_AM_PEAK_MASK		(1LL << 25)
+#define TEA5777_W_AM_PEAK_SHIFT		25
+
+#define TEA5777_W_AM_RFB_MASK		(1LL << 16)
+#define TEA5777_W_AM_RFB_SHIFT		16
+#define TEA5777_W_AM_CALLIGN_MASK	(1LL << 15)
+#define TEA5777_W_AM_CALLIGN_SHIFT	15
+#define TEA5777_W_AM_CBANK_MASK		(0x7fLL << 8)
+#define TEA5777_W_AM_CBANK_SHIFT	8
+
+#define TEA5777_W_AM_DELAY_MASK		(1LL << 2)
+#define TEA5777_W_AM_DELAY_SHIFT	2
+#define TEA5777_W_AM_STEP_MASK		(1LL << 1)
+#define TEA5777_W_AM_STEP_SHIFT		1
+
+/* Read reg, common bits */
+#define TEA5777_R_LEVEL_MASK		(0x0f << 17)
+#define TEA5777_R_LEVEL_SHIFT		17
+#define TEA5777_R_SFOUND_MASK		(0x01 << 16)
+#define TEA5777_R_SFOUND_SHIFT		16
+#define TEA5777_R_BLIM_MASK		(0x01 << 15)
+#define TEA5777_R_BLIM_SHIFT		15
+
+/* Read reg, FM specific bits */
+#define TEA5777_R_FM_STEREO_MASK	(0x01 << 21)
+#define TEA5777_R_FM_STEREO_SHIFT	21
+#define TEA5777_R_FM_PLL_MASK		0x1fff
+#define TEA5777_R_FM_PLL_SHIFT		0
+
+static u32 tea5777_freq_to_v4l2_freq(struct radio_tea5777 *tea, u32 freq)
+{
+	return (freq * TEA5777_FM_FREQ_STEP + TEA5777_FM_IF) * 16;
+}
+
+static int radio_tea5777_set_freq(struct radio_tea5777 *tea)
+{
+	u64 freq;
+	int res;
+
+	freq = clamp_t(u32, tea->freq,
+		       TEA5777_FM_RANGELOW, TEA5777_FM_RANGEHIGH);
+	freq = (freq + 8) / 16; /* to kHz */
+
+	freq = (freq - TEA5777_FM_IF) / TEA5777_FM_FREQ_STEP;
+
+	tea->write_reg &= ~(TEA5777_W_FM_PLL_MASK | TEA5777_W_FM_FREF_MASK);
+	tea->write_reg |= freq << TEA5777_W_FM_PLL_SHIFT;
+	tea->write_reg |= TEA5777_W_FM_FREF_VALUE << TEA5777_W_FM_FREF_SHIFT;
+
+	res = tea->ops->write_reg(tea, tea->write_reg);
+	if (res)
+		return res;
+
+	tea->needs_write = false;
+	tea->read_reg = -1;
+	tea->freq = tea5777_freq_to_v4l2_freq(tea, freq);
+
+	return 0;
+}
+
+static int radio_tea5777_update_read_reg(struct radio_tea5777 *tea, int wait)
+{
+	int res;
+
+	if (tea->read_reg != -1)
+		return 0;
+
+	if (tea->write_before_read && tea->needs_write) {
+		res = radio_tea5777_set_freq(tea);
+		if (res)
+			return res;
+	}
+
+	if (wait) {
+		if (schedule_timeout_interruptible(msecs_to_jiffies(wait)))
+			return -ERESTARTSYS;
+	}
+
+	res = tea->ops->read_reg(tea, &tea->read_reg);
+	if (res)
+		return res;
+
+	tea->needs_write = true;
+	return 0;
+}
+
+/*
+ * Linux Video interface
+ */
+
+static int vidioc_querycap(struct file *file, void  *priv,
+					struct v4l2_capability *v)
+{
+	struct radio_tea5777 *tea = video_drvdata(file);
+
+	strlcpy(v->driver, tea->v4l2_dev->name, sizeof(v->driver));
+	strlcpy(v->card, tea->card, sizeof(v->card));
+	strlcat(v->card, " TEA5777", sizeof(v->card));
+	strlcpy(v->bus_info, tea->bus_info, sizeof(v->bus_info));
+	v->device_caps = V4L2_CAP_TUNER | V4L2_CAP_RADIO;
+	v->device_caps |= V4L2_CAP_HW_FREQ_SEEK;
+	v->capabilities = v->device_caps | V4L2_CAP_DEVICE_CAPS;
+	return 0;
+}
+
+static int vidioc_g_tuner(struct file *file, void *priv,
+					struct v4l2_tuner *v)
+{
+	struct radio_tea5777 *tea = video_drvdata(file);
+	int res;
+
+	if (v->index > 0)
+		return -EINVAL;
+
+	res = radio_tea5777_update_read_reg(tea, 0);
+	if (res)
+		return res;
+
+	memset(v, 0, sizeof(*v));
+	if (tea->has_am)
+		strlcpy(v->name, "AM/FM", sizeof(v->name));
+	else
+		strlcpy(v->name, "FM", sizeof(v->name));
+	v->type = V4L2_TUNER_RADIO;
+	v->capability = V4L2_TUNER_CAP_LOW | V4L2_TUNER_CAP_STEREO |
+			V4L2_TUNER_CAP_HWSEEK_BOUNDED;
+	v->rangelow   = TEA5777_FM_RANGELOW;
+	v->rangehigh  = TEA5777_FM_RANGEHIGH;
+	v->rxsubchans = (tea->read_reg & TEA5777_R_FM_STEREO_MASK) ?
+			V4L2_TUNER_SUB_STEREO : V4L2_TUNER_SUB_MONO;
+	v->audmode = (tea->write_reg & TEA5777_W_FM_FORCEMONO_MASK) ?
+		V4L2_TUNER_MODE_MONO : V4L2_TUNER_MODE_STEREO;
+	/* shift - 12 to convert 4-bits (0-15) scale to 16-bits (0-65535) */
+	v->signal = (tea->read_reg & TEA5777_R_LEVEL_MASK) >>
+		    (TEA5777_R_LEVEL_SHIFT - 12);
+
+	/* Invalidate read_reg, so that next call we return up2date signal */
+	tea->read_reg = -1;
+
+	return 0;
+}
+
+static int vidioc_s_tuner(struct file *file, void *priv,
+					struct v4l2_tuner *v)
+{
+	struct radio_tea5777 *tea = video_drvdata(file);
+
+	if (v->index)
+		return -EINVAL;
+
+	if (v->audmode == V4L2_TUNER_MODE_MONO)
+		tea->write_reg |= TEA5777_W_FM_FORCEMONO_MASK;
+	else
+		tea->write_reg &= ~TEA5777_W_FM_FORCEMONO_MASK;
+
+	return radio_tea5777_set_freq(tea);
+}
+
+static int vidioc_g_frequency(struct file *file, void *priv,
+					struct v4l2_frequency *f)
+{
+	struct radio_tea5777 *tea = video_drvdata(file);
+
+	if (f->tuner != 0)
+		return -EINVAL;
+	f->type = V4L2_TUNER_RADIO;
+	f->frequency = tea->freq;
+	return 0;
+}
+
+static int vidioc_s_frequency(struct file *file, void *priv,
+					struct v4l2_frequency *f)
+{
+	struct radio_tea5777 *tea = video_drvdata(file);
+
+	if (f->tuner != 0 || f->type != V4L2_TUNER_RADIO)
+		return -EINVAL;
+
+	tea->freq = f->frequency;
+	return radio_tea5777_set_freq(tea);
+}
+
+static int vidioc_s_hw_freq_seek(struct file *file, void *fh,
+					struct v4l2_hw_freq_seek *a)
+{
+	struct radio_tea5777 *tea = video_drvdata(file);
+	u32 orig_freq = tea->freq;
+	unsigned long timeout;
+	int res, spacing = 200 * 16; /* 200 kHz */
+	/* These are fixed *for now* */
+	const u32 seek_rangelow  = TEA5777_FM_RANGELOW;
+	const u32 seek_rangehigh = TEA5777_FM_RANGEHIGH;
+
+	if (a->tuner || a->wrap_around)
+		return -EINVAL;
+
+	tea->write_reg |= TEA5777_W_PROGBLIM_MASK;
+	if (seek_rangelow != tea->seek_rangelow) {
+		tea->write_reg &= ~TEA5777_W_UPDWN_MASK;
+		tea->freq = seek_rangelow;
+		res = radio_tea5777_set_freq(tea);
+		if (res)
+			goto leave;
+		tea->seek_rangelow = tea->freq;
+	}
+	if (seek_rangehigh != tea->seek_rangehigh) {
+		tea->write_reg |= TEA5777_W_UPDWN_MASK;
+		tea->freq = seek_rangehigh;
+		res = radio_tea5777_set_freq(tea);
+		if (res)
+			goto leave;
+		tea->seek_rangehigh = tea->freq;
+	}
+	tea->write_reg &= ~TEA5777_W_PROGBLIM_MASK;
+
+	tea->write_reg |= TEA5777_W_SEARCH_MASK;
+	if (a->seek_upward) {
+		tea->write_reg |= TEA5777_W_UPDWN_MASK;
+		tea->freq = orig_freq + spacing;
+	} else {
+		tea->write_reg &= ~TEA5777_W_UPDWN_MASK;
+		tea->freq = orig_freq - spacing;
+	}
+	res = radio_tea5777_set_freq(tea);
+	if (res)
+		goto leave;
+
+	timeout = jiffies + msecs_to_jiffies(5000);
+	for (;;) {
+		if (time_after(jiffies, timeout)) {
+			res = -ENODATA;
+			break;
+		}
+
+		res = radio_tea5777_update_read_reg(tea, 100);
+		if (res)
+			break;
+
+		/*
+		 * Note we use tea->freq to track how far we've searched sofar
+		 * this is necessary to ensure we continue seeking at the right
+		 * point, in the write_before_read case.
+		 */
+		tea->freq = (tea->read_reg & TEA5777_R_FM_PLL_MASK);
+		tea->freq = tea5777_freq_to_v4l2_freq(tea, tea->freq);
+
+		if ((tea->read_reg & TEA5777_R_SFOUND_MASK)) {
+			tea->write_reg &= ~TEA5777_W_SEARCH_MASK;
+			return 0;
+		}
+
+		if (tea->read_reg & TEA5777_R_BLIM_MASK) {
+			res = -ENODATA;
+			break;
+		}
+
+		/* Force read_reg update */
+		tea->read_reg = -1;
+	}
+leave:
+	tea->write_reg &= ~TEA5777_W_PROGBLIM_MASK;
+	tea->write_reg &= ~TEA5777_W_SEARCH_MASK;
+	tea->freq = orig_freq;
+	radio_tea5777_set_freq(tea);
+	return res;
+}
+
+static int tea575x_s_ctrl(struct v4l2_ctrl *c)
+{
+	struct radio_tea5777 *tea =
+		container_of(c->handler, struct radio_tea5777, ctrl_handler);
+
+	switch (c->id) {
+	case V4L2_CID_AUDIO_MUTE:
+		if (c->val)
+			tea->write_reg |= TEA5777_W_MUTE_MASK;
+		else
+			tea->write_reg &= ~TEA5777_W_MUTE_MASK;
+
+		return radio_tea5777_set_freq(tea);
+	}
+
+	return -EINVAL;
+}
+
+static const struct v4l2_file_operations tea575x_fops = {
+	.unlocked_ioctl	= video_ioctl2,
+	.open		= v4l2_fh_open,
+	.release	= v4l2_fh_release,
+	.poll		= v4l2_ctrl_poll,
+};
+
+static const struct v4l2_ioctl_ops tea575x_ioctl_ops = {
+	.vidioc_querycap    = vidioc_querycap,
+	.vidioc_g_tuner     = vidioc_g_tuner,
+	.vidioc_s_tuner     = vidioc_s_tuner,
+	.vidioc_g_frequency = vidioc_g_frequency,
+	.vidioc_s_frequency = vidioc_s_frequency,
+	.vidioc_s_hw_freq_seek = vidioc_s_hw_freq_seek,
+	.vidioc_log_status  = v4l2_ctrl_log_status,
+	.vidioc_subscribe_event = v4l2_ctrl_subscribe_event,
+	.vidioc_unsubscribe_event = v4l2_event_unsubscribe,
+};
+
+static const struct video_device tea575x_radio = {
+	.ioctl_ops	= &tea575x_ioctl_ops,
+	.release	= video_device_release_empty,
+};
+
+static const struct v4l2_ctrl_ops tea575x_ctrl_ops = {
+	.s_ctrl = tea575x_s_ctrl,
+};
+
+int radio_tea5777_init(struct radio_tea5777 *tea, struct module *owner)
+{
+	int res;
+
+	tea->write_reg = (1LL << TEA5777_W_IFCE_SHIFT) |
+			 (1LL << TEA5777_W_IFW_SHIFT) |
+			 (1LL << TEA5777_W_INTEXT_SHIFT) |
+			 (1LL << TEA5777_W_CHP0_SHIFT) |
+			 (2LL << TEA5777_W_SLEV_SHIFT);
+	tea->freq = 90500 * 16;	/* 90.5Mhz default */
+	res = radio_tea5777_set_freq(tea);
+	if (res) {
+		v4l2_err(tea->v4l2_dev, "can't set initial freq (%d)\n", res);
+		return res;
+	}
+
+	tea->vd = tea575x_radio;
+	video_set_drvdata(&tea->vd, tea);
+	mutex_init(&tea->mutex);
+	strlcpy(tea->vd.name, tea->v4l2_dev->name, sizeof(tea->vd.name));
+	tea->vd.lock = &tea->mutex;
+	tea->vd.v4l2_dev = tea->v4l2_dev;
+	tea->fops = tea575x_fops;
+	tea->fops.owner = owner;
+	tea->vd.fops = &tea->fops;
+	set_bit(V4L2_FL_USE_FH_PRIO, &tea->vd.flags);
+
+	tea->vd.ctrl_handler = &tea->ctrl_handler;
+	v4l2_ctrl_handler_init(&tea->ctrl_handler, 1);
+	v4l2_ctrl_new_std(&tea->ctrl_handler, &tea575x_ctrl_ops,
+			  V4L2_CID_AUDIO_MUTE, 0, 1, 1, 1);
+	res = tea->ctrl_handler.error;
+	if (res) {
+		v4l2_err(tea->v4l2_dev, "can't initialize controls\n");
+		v4l2_ctrl_handler_free(&tea->ctrl_handler);
+		return res;
+	}
+	v4l2_ctrl_handler_setup(&tea->ctrl_handler);
+
+	res = video_register_device(&tea->vd, VFL_TYPE_RADIO, -1);
+	if (res) {
+		v4l2_err(tea->v4l2_dev, "can't register video device!\n");
+		v4l2_ctrl_handler_free(tea->vd.ctrl_handler);
+		return res;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(radio_tea5777_init);
+
+void radio_tea5777_exit(struct radio_tea5777 *tea)
+{
+	video_unregister_device(&tea->vd);
+	v4l2_ctrl_handler_free(tea->vd.ctrl_handler);
+}
+EXPORT_SYMBOL_GPL(radio_tea5777_exit);
