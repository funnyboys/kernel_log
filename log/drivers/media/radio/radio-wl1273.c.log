commit 1091eb830627625dcf79958d99353c2391f41708
Author: Johan Hovold <johan@kernel.org>
Date:   Thu Oct 10 10:13:32 2019 -0300

    media: radio: wl1273: fix interrupt masking on release
    
    If a process is interrupted while accessing the radio device and the
    core lock is contended, release() could return early and fail to update
    the interrupt mask.
    
    Note that the return value of the v4l2 release file operation is
    ignored.
    
    Fixes: 87d1a50ce451 ("[media] V4L2: WL1273 FM Radio: TI WL1273 FM radio driver")
    Cc: stable <stable@vger.kernel.org>     # 2.6.38
    Cc: Matti Aaltonen <matti.j.aaltonen@nokia.com>
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Hans Verkuil <hverkuil-cisco@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@kernel.org>

diff --git a/drivers/media/radio/radio-wl1273.c b/drivers/media/radio/radio-wl1273.c
index 104ac41c6f96..112376873167 100644
--- a/drivers/media/radio/radio-wl1273.c
+++ b/drivers/media/radio/radio-wl1273.c
@@ -1148,8 +1148,7 @@ static int wl1273_fm_fops_release(struct file *file)
 	if (radio->rds_users > 0) {
 		radio->rds_users--;
 		if (radio->rds_users == 0) {
-			if (mutex_lock_interruptible(&core->lock))
-				return -EINTR;
+			mutex_lock(&core->lock);
 
 			radio->irq_flags &= ~WL1273_RDS_EVENT;
 

commit 5800571960234f9d1f1011bf135799b2014d4268
Merge: d17589afa970 d1fdb6d8f6a4
Author: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
Date:   Tue Jun 11 12:09:28 2019 -0400

    Merge tag 'v5.2-rc4' into media/master
    
    There are some conflicts due to SPDX changes. We also have more
    patches being merged via media tree touching them.
    
    So, let's merge back from upstream and address those.
    
    Linux 5.2-rc4
    
    * tag 'v5.2-rc4': (767 commits)
      Linux 5.2-rc4
      MAINTAINERS: Karthikeyan Ramasubramanian is MIA
      i2c: xiic: Add max_read_len quirk
      lockref: Limit number of cmpxchg loop retries
      uaccess: add noop untagged_addr definition
      x86/insn-eval: Fix use-after-free access to LDT entry
      kbuild: use more portable 'command -v' for cc-cross-prefix
      s390/unwind: correct stack switching during unwind
      block, bfq: add weight symlink to the bfq.weight cgroup parameter
      cgroup: let a symlink too be created with a cftype file
      drm/nouveau/secboot/gp10[2467]: support newer FW to fix SEC2 failures on some boards
      drm/nouveau/secboot: enable loading of versioned LS PMU/SEC2 ACR msgqueue FW
      drm/nouveau/secboot: split out FW version-specific LS function pointers
      drm/nouveau/secboot: pass max supported FW version to LS load funcs
      drm/nouveau/core: support versioned firmware loading
      drm/nouveau/core: pass subdev into nvkm_firmware_get, rather than device
      block: free sched's request pool in blk_cleanup_queue
      pktgen: do not sleep with the thread lock held.
      net: mvpp2: Use strscpy to handle stat strings
      net: rds: fix memory leak in rds_ib_flush_mr_pool
      ...
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

commit e83ce3005db16243e1085925251fd0776bb60d09
Author: Hans Verkuil <hverkuil-cisco@xs4all.nl>
Date:   Tue Jun 4 07:19:52 2019 -0400

    media: media/radio: set device_caps in struct video_device
    
    Instead of filling in the struct v4l2_capability device_caps
    field, fill in the struct video_device device_caps field.
    
    That way the V4L2 core knows what the capabilities of the
    video device are.
    
    But this only really works if all drivers use this, so convert
    all radio drivers in this patch.
    
    Signed-off-by: Hans Verkuil <hverkuil-cisco@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/radio/radio-wl1273.c b/drivers/media/radio/radio-wl1273.c
index b95704f3cb8b..a1a36ce396ee 100644
--- a/drivers/media/radio/radio-wl1273.c
+++ b/drivers/media/radio/radio-wl1273.c
@@ -1292,14 +1292,6 @@ static int wl1273_fm_vidioc_querycap(struct file *file, void *priv,
 		sizeof(capability->card));
 	strscpy(capability->bus_info, radio->bus_type,
 		sizeof(capability->bus_info));
-
-	capability->device_caps = V4L2_CAP_HW_FREQ_SEEK |
-		V4L2_CAP_TUNER | V4L2_CAP_RADIO | V4L2_CAP_AUDIO |
-		V4L2_CAP_RDS_CAPTURE | V4L2_CAP_MODULATOR |
-		V4L2_CAP_RDS_OUTPUT;
-	capability->capabilities = capability->device_caps |
-		V4L2_CAP_DEVICE_CAPS;
-
 	return 0;
 }
 
@@ -1988,6 +1980,10 @@ static const struct video_device wl1273_viddev_template = {
 	.name			= WL1273_FM_DRIVER_NAME,
 	.release		= wl1273_vdev_release,
 	.vfl_dir		= VFL_DIR_TX,
+	.device_caps		= V4L2_CAP_HW_FREQ_SEEK | V4L2_CAP_TUNER |
+				  V4L2_CAP_RADIO | V4L2_CAP_AUDIO |
+				  V4L2_CAP_RDS_CAPTURE | V4L2_CAP_MODULATOR |
+				  V4L2_CAP_RDS_OUTPUT,
 };
 
 static int wl1273_fm_radio_remove(struct platform_device *pdev)

commit 1802d0beecafe581ad584634ba92f8a471d8a63a
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:21 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 174
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation this program is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 655 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070034.575739538@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/media/radio/radio-wl1273.c b/drivers/media/radio/radio-wl1273.c
index b95704f3cb8b..330de50f8920 100644
--- a/drivers/media/radio/radio-wl1273.c
+++ b/drivers/media/radio/radio-wl1273.c
@@ -1,17 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Driver for the Texas Instruments WL1273 FM radio.
  *
  * Copyright (C) 2011 Nokia Corporation
  * Author: Matti J. Aaltonen <matti.j.aaltonen@nokia.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the
- * GNU General Public License for more details.
  */
 
 #include <linux/delay.h>

commit c0decac19da3906d9b66291e57b7759489e1170f
Author: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
Date:   Mon Sep 10 08:19:14 2018 -0400

    media: use strscpy() instead of strlcpy()
    
    The implementation of strscpy() is more robust and safer.
    
    That's now the recommended way to copy NUL terminated strings.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Acked-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/radio/radio-wl1273.c b/drivers/media/radio/radio-wl1273.c
index 11aa94f189cb..b95704f3cb8b 100644
--- a/drivers/media/radio/radio-wl1273.c
+++ b/drivers/media/radio/radio-wl1273.c
@@ -1286,11 +1286,11 @@ static int wl1273_fm_vidioc_querycap(struct file *file, void *priv,
 
 	dev_dbg(radio->dev, "%s\n", __func__);
 
-	strlcpy(capability->driver, WL1273_FM_DRIVER_NAME,
+	strscpy(capability->driver, WL1273_FM_DRIVER_NAME,
 		sizeof(capability->driver));
-	strlcpy(capability->card, "Texas Instruments Wl1273 FM Radio",
+	strscpy(capability->card, "Texas Instruments Wl1273 FM Radio",
 		sizeof(capability->card));
-	strlcpy(capability->bus_info, radio->bus_type,
+	strscpy(capability->bus_info, radio->bus_type,
 		sizeof(capability->bus_info));
 
 	capability->device_caps = V4L2_CAP_HW_FREQ_SEEK |
@@ -1488,7 +1488,7 @@ static int wl1273_fm_vidioc_g_audio(struct file *file, void *priv,
 	if (audio->index > 1)
 		return -EINVAL;
 
-	strlcpy(audio->name, "Radio", sizeof(audio->name));
+	strscpy(audio->name, "Radio", sizeof(audio->name));
 	audio->capability = V4L2_AUDCAP_STEREO;
 
 	return 0;
@@ -1523,7 +1523,7 @@ static int wl1273_fm_vidioc_g_tuner(struct file *file, void *priv,
 	if (tuner->index > 0)
 		return -EINVAL;
 
-	strlcpy(tuner->name, WL1273_FM_DRIVER_NAME, sizeof(tuner->name));
+	strscpy(tuner->name, WL1273_FM_DRIVER_NAME, sizeof(tuner->name));
 	tuner->type = V4L2_TUNER_RADIO;
 
 	tuner->rangelow	= WL1273_FREQ(WL1273_BAND_JAPAN_LOW);
@@ -1781,7 +1781,7 @@ static int wl1273_fm_vidioc_g_modulator(struct file *file, void *priv,
 
 	dev_dbg(radio->dev, "%s\n", __func__);
 
-	strlcpy(modulator->name, WL1273_FM_DRIVER_NAME,
+	strscpy(modulator->name, WL1273_FM_DRIVER_NAME,
 		sizeof(modulator->name));
 
 	modulator->rangelow = WL1273_FREQ(WL1273_BAND_JAPAN_LOW);

commit dcefa533bd97922a3cac37f395247082be44600b
Author: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
Date:   Tue Aug 7 09:25:37 2018 -0400

    media: radio-wl1273: fix return code for the polling routine
    
    All poll handlers should return a poll flag, and not error codes. So,
    instead of returning an error, do the right thing here,
    e. g. to return EPOLERR on errors, just like the V4L2 VB2 code.
    
    Solves the following sparse warning:
        drivers/media/radio/radio-wl1273.c:1099:24: warning: incorrect type in return expression (different base types)
        drivers/media/radio/radio-wl1273.c:1099:24:    expected restricted __poll_t
        drivers/media/radio/radio-wl1273.c:1099:24:    got int
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/radio/radio-wl1273.c b/drivers/media/radio/radio-wl1273.c
index 8f9f8dfc3497..11aa94f189cb 100644
--- a/drivers/media/radio/radio-wl1273.c
+++ b/drivers/media/radio/radio-wl1273.c
@@ -1096,7 +1096,7 @@ static __poll_t wl1273_fm_fops_poll(struct file *file,
 	struct wl1273_core *core = radio->core;
 
 	if (radio->owner && radio->owner != file)
-		return -EBUSY;
+		return EPOLLERR;
 
 	radio->owner = file;
 

commit 9aa4d4ea244481fe98eb181ec5d7a9f7cb86f076
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Thu Feb 22 15:45:47 2018 -0500

    media: usb: don't initialize vars if not needed
    
    Some local variables will be set to an appropriate value before usage.
    Thus omit explicit initialisations at the beginning of these functions.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Acked-by: Alexey Klimov <klimov.linux@gmail.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/radio/radio-wl1273.c b/drivers/media/radio/radio-wl1273.c
index 58e944591602..8f9f8dfc3497 100644
--- a/drivers/media/radio/radio-wl1273.c
+++ b/drivers/media/radio/radio-wl1273.c
@@ -671,7 +671,7 @@ static int wl1273_fm_start(struct wl1273_device *radio, int new_mode)
 static int wl1273_fm_suspend(struct wl1273_device *radio)
 {
 	struct wl1273_core *core = radio->core;
-	int r = 0;
+	int r;
 
 	/* Cannot go from OFF to SUSPENDED */
 	if (core->mode == WL1273_MODE_RX)

commit a9a08845e9acbd224e4ee466f5c1275ed50054e8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Feb 11 14:34:03 2018 -0800

    vfs: do bulk POLL* -> EPOLL* replacement
    
    This is the mindless scripted replacement of kernel use of POLL*
    variables as described by Al, done by this script:
    
        for V in IN OUT PRI ERR RDNORM RDBAND WRNORM WRBAND HUP RDHUP NVAL MSG; do
            L=`git grep -l -w POLL$V | grep -v '^t' | grep -v /um/ | grep -v '^sa' | grep -v '/poll.h$'|grep -v '^D'`
            for f in $L; do sed -i "-es/^\([^\"]*\)\(\<POLL$V\>\)/\\1E\\2/" $f; done
        done
    
    with de-mangling cleanups yet to come.
    
    NOTE! On almost all architectures, the EPOLL* constants have the same
    values as the POLL* constants do.  But they keyword here is "almost".
    For various bad reasons they aren't the same, and epoll() doesn't
    actually work quite correctly in some cases due to this on Sparc et al.
    
    The next patch from Al will sort out the final differences, and we
    should be all done.
    
    Scripted-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/media/radio/radio-wl1273.c b/drivers/media/radio/radio-wl1273.c
index f92b0f9241a9..58e944591602 100644
--- a/drivers/media/radio/radio-wl1273.c
+++ b/drivers/media/radio/radio-wl1273.c
@@ -1104,10 +1104,10 @@ static __poll_t wl1273_fm_fops_poll(struct file *file,
 		poll_wait(file, &radio->read_queue, pts);
 
 		if (radio->rd_index != radio->wr_index)
-			return POLLIN | POLLRDNORM;
+			return EPOLLIN | EPOLLRDNORM;
 
 	} else if (core->mode == WL1273_MODE_TX) {
-		return POLLOUT | POLLWRNORM;
+		return EPOLLOUT | EPOLLWRNORM;
 	}
 
 	return 0;

commit 168fe32a072a4b8dc81a3aebf0e5e588d38e2955
Merge: 13ddd1667e7f c71d227fc413
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jan 30 17:58:07 2018 -0800

    Merge branch 'misc.poll' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull poll annotations from Al Viro:
     "This introduces a __bitwise type for POLL### bitmap, and propagates
      the annotations through the tree. Most of that stuff is as simple as
      'make ->poll() instances return __poll_t and do the same to local
      variables used to hold the future return value'.
    
      Some of the obvious brainos found in process are fixed (e.g. POLLIN
      misspelled as POLL_IN). At that point the amount of sparse warnings is
      low and most of them are for genuine bugs - e.g. ->poll() instance
      deciding to return -EINVAL instead of a bitmap. I hadn't touched those
      in this series - it's large enough as it is.
    
      Another problem it has caught was eventpoll() ABI mess; select.c and
      eventpoll.c assumed that corresponding POLL### and EPOLL### were
      equal. That's true for some, but not all of them - EPOLL### are
      arch-independent, but POLL### are not.
    
      The last commit in this series separates userland POLL### values from
      the (now arch-independent) kernel-side ones, converting between them
      in the few places where they are copied to/from userland. AFAICS, this
      is the least disruptive fix preserving poll(2) ABI and making epoll()
      work on all architectures.
    
      As it is, it's simply broken on sparc - try to give it EPOLLWRNORM and
      it will trigger only on what would've triggered EPOLLWRBAND on other
      architectures. EPOLLWRBAND and EPOLLRDHUP, OTOH, are never triggered
      at all on sparc. With this patch they should work consistently on all
      architectures"
    
    * 'misc.poll' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (37 commits)
      make kernel-side POLL... arch-independent
      eventpoll: no need to mask the result of epi_item_poll() again
      eventpoll: constify struct epoll_event pointers
      debugging printk in sg_poll() uses %x to print POLL... bitmap
      annotate poll(2) guts
      9p: untangle ->poll() mess
      ->si_band gets POLL... bitmap stored into a user-visible long field
      ring_buffer_poll_wait() return value used as return value of ->poll()
      the rest of drivers/*: annotate ->poll() instances
      media: annotate ->poll() instances
      fs: annotate ->poll() instances
      ipc, kernel, mm: annotate ->poll() instances
      net: annotate ->poll() instances
      apparmor: annotate ->poll() instances
      tomoyo: annotate ->poll() instances
      sound: annotate ->poll() instances
      acpi: annotate ->poll() instances
      crypto: annotate ->poll() instances
      block: annotate ->poll() instances
      x86: annotate ->poll() instances
      ...

commit 5bef1c0bd53abb80613f901c4ac50131d035604f
Author: Mauro Carvalho Chehab <mchehab@s-opensource.com>
Date:   Wed Nov 29 10:00:58 2017 -0500

    media: radio-wl1273: fix a parameter name at kernel-doc macro
    
    Solve those warnings:
            drivers/media/radio/radio-wl1273.c:1337: warning: No description found for parameter 'radio'
            drivers/media/radio/radio-wl1273.c:1337: warning: Excess function parameter 'core' description in 'wl1273_fm_set_tx_power'
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/radio/radio-wl1273.c b/drivers/media/radio/radio-wl1273.c
index 903fcd5e99c0..3cbdc085c65d 100644
--- a/drivers/media/radio/radio-wl1273.c
+++ b/drivers/media/radio/radio-wl1273.c
@@ -1330,7 +1330,7 @@ static int wl1273_fm_vidioc_s_input(struct file *file, void *priv,
 
 /**
  * wl1273_fm_set_tx_power() -	Set the transmission power value.
- * @core:			A pointer to the device struct.
+ * @radio:			A pointer to the device struct.
  * @power:			The new power value.
  */
 static int wl1273_fm_set_tx_power(struct wl1273_device *radio, u16 power)

commit c23e0cb81e4021b9712b1093d54713991fd9b7c2
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Jul 3 03:02:56 2017 -0400

    media: annotate ->poll() instances
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/media/radio/radio-wl1273.c b/drivers/media/radio/radio-wl1273.c
index 903fcd5e99c0..4cd4241fc7be 100644
--- a/drivers/media/radio/radio-wl1273.c
+++ b/drivers/media/radio/radio-wl1273.c
@@ -1089,7 +1089,7 @@ static ssize_t wl1273_fm_fops_write(struct file *file, const char __user *buf,
 	return r;
 }
 
-static unsigned int wl1273_fm_fops_poll(struct file *file,
+static __poll_t wl1273_fm_fops_poll(struct file *file,
 					struct poll_table_struct *pts)
 {
 	struct wl1273_device *radio = video_get_drvdata(video_devdata(file));

commit 96cc6956c6f097bae8f143f700a2795959b20a44
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Sat Aug 26 04:43:43 2017 -0400

    media: radio: make video_device const
    
    Make these const as they are only used in a copy operation.
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/radio/radio-wl1273.c b/drivers/media/radio/radio-wl1273.c
index 17e82a9a0109..903fcd5e99c0 100644
--- a/drivers/media/radio/radio-wl1273.c
+++ b/drivers/media/radio/radio-wl1273.c
@@ -1982,7 +1982,7 @@ static const struct v4l2_ioctl_ops wl1273_ioctl_ops = {
 	.vidioc_log_status      = wl1273_fm_vidioc_log_status,
 };
 
-static struct video_device wl1273_viddev_template = {
+static const struct video_device wl1273_viddev_template = {
 	.fops			= &wl1273_fops,
 	.ioctl_ops		= &wl1273_ioctl_ops,
 	.name			= WL1273_FM_DRIVER_NAME,

commit 13c2bede49f996ca34a368dfe05be53d6b2ccc22
Author: Gustavo A. R. Silva <garsilva@embeddedor.com>
Date:   Thu Jun 22 01:01:22 2017 -0300

    media: radio: wl1273: add check on core->write() return value
    
    Check return value from call to core->write(), so in case of
    error print error message, jump to goto label fail and eventually
    return.
    
    Addresses-Coverity-ID: 1226943
    
    Signed-off-by: Gustavo A. R. Silva <garsilva@embeddedor.com>
    Signed-off-by: Hans Verkuil <hansverk@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/radio/radio-wl1273.c b/drivers/media/radio/radio-wl1273.c
index 7240223dc15a..17e82a9a0109 100644
--- a/drivers/media/radio/radio-wl1273.c
+++ b/drivers/media/radio/radio-wl1273.c
@@ -610,10 +610,21 @@ static int wl1273_fm_start(struct wl1273_device *radio, int new_mode)
 			}
 		}
 
-		if (radio->rds_on)
+		if (radio->rds_on) {
 			r = core->write(core, WL1273_RDS_DATA_ENB, 1);
-		else
+			if (r) {
+				dev_err(dev, "%s: RDS_DATA_ENB ON fails\n",
+					__func__);
+				goto fail;
+			}
+		} else {
 			r = core->write(core, WL1273_RDS_DATA_ENB, 0);
+			if (r) {
+				dev_err(dev, "%s: RDS_DATA_ENB OFF fails\n",
+					__func__);
+				goto fail;
+			}
+		}
 	} else {
 		dev_warn(dev, "%s: Illegal mode.\n", __func__);
 	}

commit bcb63314e2c23f1ed622418b65f9409512659c73
Author: Sakari Ailus <sakari.ailus@linux.intel.com>
Date:   Fri Oct 28 09:31:20 2016 -0200

    [media] media: Drop FSF's postal address from the source code files
    
    Drop the FSF's postal address from the source code files that typically
    contain mostly the license text. Of the 628 removed instances, 578 are
    outdated.
    
    The patch has been created with the following command without manual edits:
    
    git grep -l "675 Mass Ave\|59 Temple Place\|51 Franklin St" -- \
            drivers/media/ include/media|while read i; do i=$i perl -e '
    open(F,"< $ENV{i}");
    $a=join("", <F>);
    $a =~ s/[ \t]*\*\n.*You should.*\n.*along with.*\n.*(\n.*USA.*$)?\n//m
            && $a =~ s/(^.*)Or, (point your browser to) /$1To obtain the license, $2\n$1/m;
    close(F);
    open(F, "> $ENV{i}");
    print F $a;
    close(F);'; done
    
    Signed-off-by: Sakari Ailus <sakari.ailus@linux.intel.com>

diff --git a/drivers/media/radio/radio-wl1273.c b/drivers/media/radio/radio-wl1273.c
index 9ce4b12299b4..7240223dc15a 100644
--- a/drivers/media/radio/radio-wl1273.c
+++ b/drivers/media/radio/radio-wl1273.c
@@ -12,10 +12,6 @@
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the
  * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
  */
 
 #include <linux/delay.h>

commit 547633def7f5eb6deebf83400f61341b31eb7018
Author: Mauro Carvalho Chehab <mchehab@s-opensource.com>
Date:   Tue Oct 18 17:44:25 2016 -0200

    [media] radio: don't break long lines
    
    Due to the 80-cols restrictions, and latter due to checkpatch
    warnings, several strings were broken into multiple lines. This
    is not considered a good practice anymore, as it makes harder
    to grep for strings at the source code.
    
    As we're right now fixing other drivers due to KERN_CONT, we need
    to be able to identify what printk strings don't end with a "\n".
    It is a way easier to detect those if we don't break long lines.
    
    So, join those continuation lines.
    
    The patch was generated via the script below, and manually
    adjusted if needed.
    
    </script>
    use Text::Tabs;
    while (<>) {
            if ($next ne "") {
                    $c=$_;
                    if ($c =~ /^\s+\"(.*)/) {
                            $c2=$1;
                            $next =~ s/\"\n$//;
                            $n = expand($next);
                            $funpos = index($n, '(');
                            $pos = index($c2, '",');
                            if ($funpos && $pos > 0) {
                                    $s1 = substr $c2, 0, $pos + 2;
                                    $s2 = ' ' x ($funpos + 1) . substr $c2, $pos + 2;
                                    $s2 =~ s/^\s+//;
    
                                    $s2 = ' ' x ($funpos + 1) . $s2 if ($s2 ne "");
    
                                    print unexpand("$next$s1\n");
                                    print unexpand("$s2\n") if ($s2 ne "");
                            } else {
                                    print "$next$c2\n";
                            }
                            $next="";
                            next;
                    } else {
                            print $next;
                    }
                    $next="";
            } else {
                    if (m/\"$/) {
                            if (!m/\\n\"$/) {
                                    $next=$_;
                                    next;
                            }
                    }
            }
            print $_;
    }
    </script>
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/radio/radio-wl1273.c b/drivers/media/radio/radio-wl1273.c
index a93f681aa9d6..9ce4b12299b4 100644
--- a/drivers/media/radio/radio-wl1273.c
+++ b/drivers/media/radio/radio-wl1273.c
@@ -2068,8 +2068,7 @@ static int wl1273_fm_radio_probe(struct platform_device *pdev)
 			goto err_request_irq;
 		}
 	} else {
-		dev_err(radio->dev, WL1273_FM_DRIVER_NAME ": Core WL1273 IRQ"
-			" not configured");
+		dev_err(radio->dev, WL1273_FM_DRIVER_NAME ": Core WL1273 IRQ not configured");
 		r = -EINVAL;
 		goto pdata_err;
 	}

commit c973f76e7e931593825280861b9ede522b67f9af
Author: Nicholas Mc Guire <hofrat@osadl.org>
Date:   Thu Feb 5 05:56:42 2015 -0300

    [media] media: radio: handle timeouts
    
    Add handling for timeout case.
    
    Signed-off-by: Nicholas Mc Guire <hofrat@osadl.org>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/radio/radio-wl1273.c b/drivers/media/radio/radio-wl1273.c
index 571c7f6de439..a93f681aa9d6 100644
--- a/drivers/media/radio/radio-wl1273.c
+++ b/drivers/media/radio/radio-wl1273.c
@@ -828,9 +828,12 @@ static int wl1273_fm_set_seek(struct wl1273_device *radio,
 	if (r)
 		goto out;
 
+	/* wait for the FR IRQ */
 	wait_for_completion_timeout(&radio->busy, msecs_to_jiffies(1000));
-	if (!(radio->irq_received & WL1273_BL_EVENT))
+	if (!(radio->irq_received & WL1273_BL_EVENT)) {
+		r = -ETIMEDOUT;
 		goto out;
+	}
 
 	radio->irq_received &= ~WL1273_BL_EVENT;
 
@@ -856,7 +859,9 @@ static int wl1273_fm_set_seek(struct wl1273_device *radio,
 	if (r)
 		goto out;
 
-	wait_for_completion_timeout(&radio->busy, msecs_to_jiffies(1000));
+	/* wait for the FR IRQ */
+	if (!wait_for_completion_timeout(&radio->busy, msecs_to_jiffies(1000)))
+		r = -ETIMEDOUT;
 out:
 	dev_dbg(radio->dev, "%s: Err: %d\n", __func__, r);
 	return r;

commit daa939db21108c951765ce1089d423fd90f8a447
Author: Nicholas Mc Guire <hofrat@osadl.org>
Date:   Thu Feb 5 04:58:48 2015 -0300

    [media] media: radio: assign wait_for_completion_timeout to appropriately typed var
    
    wait_for_completion_timeout() returns unsigned long not int. This assigns
    the return value to an appropriately typed variable (also helps keep
    static code checkers happy).
    
    Signed-off-by: Nicholas Mc Guire <hofrat@osadl.org>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/radio/radio-wl1273.c b/drivers/media/radio/radio-wl1273.c
index b8f36445516b..571c7f6de439 100644
--- a/drivers/media/radio/radio-wl1273.c
+++ b/drivers/media/radio/radio-wl1273.c
@@ -347,6 +347,7 @@ static int wl1273_fm_set_tx_freq(struct wl1273_device *radio, unsigned int freq)
 {
 	struct wl1273_core *core = radio->core;
 	int r = 0;
+	unsigned long t;
 
 	if (freq < WL1273_BAND_TX_LOW) {
 		dev_err(radio->dev,
@@ -378,11 +379,11 @@ static int wl1273_fm_set_tx_freq(struct wl1273_device *radio, unsigned int freq)
 	reinit_completion(&radio->busy);
 
 	/* wait for the FR IRQ */
-	r = wait_for_completion_timeout(&radio->busy, msecs_to_jiffies(2000));
-	if (!r)
+	t = wait_for_completion_timeout(&radio->busy, msecs_to_jiffies(2000));
+	if (!t)
 		return -ETIMEDOUT;
 
-	dev_dbg(radio->dev, "WL1273_CHANL_SET: %d\n", r);
+	dev_dbg(radio->dev, "WL1273_CHANL_SET: %lu\n", t);
 
 	/* Enable the output power */
 	r = core->write(core, WL1273_POWER_ENB_SET, 1);
@@ -392,12 +393,12 @@ static int wl1273_fm_set_tx_freq(struct wl1273_device *radio, unsigned int freq)
 	reinit_completion(&radio->busy);
 
 	/* wait for the POWER_ENB IRQ */
-	r = wait_for_completion_timeout(&radio->busy, msecs_to_jiffies(1000));
-	if (!r)
+	t = wait_for_completion_timeout(&radio->busy, msecs_to_jiffies(1000));
+	if (!t)
 		return -ETIMEDOUT;
 
 	radio->tx_frequency = freq;
-	dev_dbg(radio->dev, "WL1273_POWER_ENB_SET: %d\n", r);
+	dev_dbg(radio->dev, "WL1273_POWER_ENB_SET: %lu\n", t);
 
 	return	0;
 }
@@ -406,6 +407,7 @@ static int wl1273_fm_set_rx_freq(struct wl1273_device *radio, unsigned int freq)
 {
 	struct wl1273_core *core = radio->core;
 	int r, f;
+	unsigned long t;
 
 	if (freq < radio->rangelow) {
 		dev_err(radio->dev,
@@ -446,8 +448,8 @@ static int wl1273_fm_set_rx_freq(struct wl1273_device *radio, unsigned int freq)
 
 	reinit_completion(&radio->busy);
 
-	r = wait_for_completion_timeout(&radio->busy, msecs_to_jiffies(2000));
-	if (!r) {
+	t = wait_for_completion_timeout(&radio->busy, msecs_to_jiffies(2000));
+	if (!t) {
 		dev_err(radio->dev, "%s: TIMEOUT\n", __func__);
 		return -ETIMEDOUT;
 	}

commit e6b5be2be4e30037eb551e0ed09dd97bd00d85d3
Merge: 37da7bbbe84f f1c488a78d9f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Dec 14 16:10:09 2014 -0800

    Merge tag 'driver-core-3.19-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    Pull driver core update from Greg KH:
     "Here's the set of driver core patches for 3.19-rc1.
    
      They are dominated by the removal of the .owner field in platform
      drivers.  They touch a lot of files, but they are "simple" changes,
      just removing a line in a structure.
    
      Other than that, a few minor driver core and debugfs changes.  There
      are some ath9k patches coming in through this tree that have been
      acked by the wireless maintainers as they relied on the debugfs
      changes.
    
      Everything has been in linux-next for a while"
    
    * tag 'driver-core-3.19-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core: (324 commits)
      Revert "ath: ath9k: use debugfs_create_devm_seqfile() helper for seq_file entries"
      fs: debugfs: add forward declaration for struct device type
      firmware class: Deletion of an unnecessary check before the function call "vunmap"
      firmware loader: fix hung task warning dump
      devcoredump: provide a one-way disable function
      device: Add dev_<level>_once variants
      ath: ath9k: use debugfs_create_devm_seqfile() helper for seq_file entries
      ath: use seq_file api for ath9k debugfs files
      debugfs: add helper function to create device related seq_file
      drivers/base: cacheinfo: remove noisy error boot message
      Revert "core: platform: add warning if driver has no owner"
      drivers: base: support cpu cache information interface to userspace via sysfs
      drivers: base: add cpu_device_create to support per-cpu devices
      topology: replace custom attribute macros with standard DEVICE_ATTR*
      cpumask: factor out show_cpumap into separate helper function
      driver core: Fix unbalanced device reference in drivers_probe
      driver core: fix race with userland in device_add()
      sysfs/kernfs: make read requests on pre-alloc files use the buffer.
      sysfs/kernfs: allow attributes to request write buffer be pre-allocated.
      fs: sysfs: return EGBIG on write if offset is larger than file size
      ...

commit 7027c448d2408827ce6f952a161fcb6254fb2234
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Mon Nov 24 06:37:24 2014 -0300

    [media] media/radio: fix querycap
    
    Querycap should set the device_caps field.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/radio/radio-wl1273.c b/drivers/media/radio/radio-wl1273.c
index 9cf6731fb816..284f789265e0 100644
--- a/drivers/media/radio/radio-wl1273.c
+++ b/drivers/media/radio/radio-wl1273.c
@@ -1279,10 +1279,12 @@ static int wl1273_fm_vidioc_querycap(struct file *file, void *priv,
 	strlcpy(capability->bus_info, radio->bus_type,
 		sizeof(capability->bus_info));
 
-	capability->capabilities = V4L2_CAP_HW_FREQ_SEEK |
+	capability->device_caps = V4L2_CAP_HW_FREQ_SEEK |
 		V4L2_CAP_TUNER | V4L2_CAP_RADIO | V4L2_CAP_AUDIO |
 		V4L2_CAP_RDS_CAPTURE | V4L2_CAP_MODULATOR |
 		V4L2_CAP_RDS_OUTPUT;
+	capability->capabilities = capability->device_caps |
+		V4L2_CAP_DEVICE_CAPS;
 
 	return 0;
 }

commit da2dc6fff5b63b94a45d75b77b1a441d1b55a4bf
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Mon Oct 20 16:20:51 2014 +0200

    media: radio: drop owner assignment from platform_drivers
    
    A platform_driver does not need to set an owner, it will be populated by the
    driver core.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/media/radio/radio-wl1273.c b/drivers/media/radio/radio-wl1273.c
index 9cf6731fb816..fd2281c4a784 100644
--- a/drivers/media/radio/radio-wl1273.c
+++ b/drivers/media/radio/radio-wl1273.c
@@ -2148,7 +2148,6 @@ static struct platform_driver wl1273_fm_radio_driver = {
 	.remove		= wl1273_fm_radio_remove,
 	.driver		= {
 		.name	= "wl1273_fm_radio",
-		.owner	= THIS_MODULE,
 	},
 };
 

commit 16735d022f72b20ddbb2274b8e109f69575e9b2b
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Thu Nov 14 14:32:02 2013 -0800

    tree-wide: use reinit_completion instead of INIT_COMPLETION
    
    Use this new function to make code more comprehensible, since we are
    reinitialzing the completion, not initializing.
    
    [akpm@linux-foundation.org: linux-next resyncs]
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>
    Acked-by: Linus Walleij <linus.walleij@linaro.org> (personally at LCE13)
    Cc: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/media/radio/radio-wl1273.c b/drivers/media/radio/radio-wl1273.c
index 97c2c18803ef..9cf6731fb816 100644
--- a/drivers/media/radio/radio-wl1273.c
+++ b/drivers/media/radio/radio-wl1273.c
@@ -375,7 +375,7 @@ static int wl1273_fm_set_tx_freq(struct wl1273_device *radio, unsigned int freq)
 	if (r)
 		return r;
 
-	INIT_COMPLETION(radio->busy);
+	reinit_completion(&radio->busy);
 
 	/* wait for the FR IRQ */
 	r = wait_for_completion_timeout(&radio->busy, msecs_to_jiffies(2000));
@@ -389,7 +389,7 @@ static int wl1273_fm_set_tx_freq(struct wl1273_device *radio, unsigned int freq)
 	if (r)
 		return r;
 
-	INIT_COMPLETION(radio->busy);
+	reinit_completion(&radio->busy);
 
 	/* wait for the POWER_ENB IRQ */
 	r = wait_for_completion_timeout(&radio->busy, msecs_to_jiffies(1000));
@@ -444,7 +444,7 @@ static int wl1273_fm_set_rx_freq(struct wl1273_device *radio, unsigned int freq)
 		goto err;
 	}
 
-	INIT_COMPLETION(radio->busy);
+	reinit_completion(&radio->busy);
 
 	r = wait_for_completion_timeout(&radio->busy, msecs_to_jiffies(2000));
 	if (!r) {
@@ -805,7 +805,7 @@ static int wl1273_fm_set_seek(struct wl1273_device *radio,
 	if (level < SCHAR_MIN || level > SCHAR_MAX)
 		return -EINVAL;
 
-	INIT_COMPLETION(radio->busy);
+	reinit_completion(&radio->busy);
 	dev_dbg(radio->dev, "%s: BUSY\n", __func__);
 
 	r = core->write(core, WL1273_INT_MASK_SET, radio->irq_flags);
@@ -847,7 +847,7 @@ static int wl1273_fm_set_seek(struct wl1273_device *radio,
 	if (r)
 		goto out;
 
-	INIT_COMPLETION(radio->busy);
+	reinit_completion(&radio->busy);
 	dev_dbg(radio->dev, "%s: BUSY\n", __func__);
 
 	r = core->write(core, WL1273_TUNER_MODE_SET, TUNER_MODE_AUTO_SEEK);

commit 2f73c7c582a685b3198b974cd6d964d0338f8ab5
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Fri Mar 15 06:10:06 2013 -0300

    [media] v4l2: add const to argument of write-only s_tuner ioctl
    
    This ioctl is defined as IOW, so pass the argument as const.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Acked-by: Alexey Klimov <klimov.linux@gmail.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-wl1273.c b/drivers/media/radio/radio-wl1273.c
index 9a02fee904bf..97c2c18803ef 100644
--- a/drivers/media/radio/radio-wl1273.c
+++ b/drivers/media/radio/radio-wl1273.c
@@ -1559,7 +1559,7 @@ static int wl1273_fm_vidioc_g_tuner(struct file *file, void *priv,
 }
 
 static int wl1273_fm_vidioc_s_tuner(struct file *file, void *priv,
-				    struct v4l2_tuner *tuner)
+				    const struct v4l2_tuner *tuner)
 {
 	struct wl1273_device *radio = video_get_drvdata(video_devdata(file));
 	struct wl1273_core *core = radio->core;

commit b530a447bb588fdf43fdf4eb909e4ee1921d47ac
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Tue Mar 19 04:09:26 2013 -0300

    [media] v4l2: add const to argument of write-only s_frequency ioctl
    
    This ioctl is defined as IOW, so pass the argument as const.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-wl1273.c b/drivers/media/radio/radio-wl1273.c
index 02151e0e6e63..9a02fee904bf 100644
--- a/drivers/media/radio/radio-wl1273.c
+++ b/drivers/media/radio/radio-wl1273.c
@@ -1640,7 +1640,7 @@ static int wl1273_fm_vidioc_g_frequency(struct file *file, void *priv,
 }
 
 static int wl1273_fm_vidioc_s_frequency(struct file *file, void *priv,
-					struct v4l2_frequency *freq)
+					const struct v4l2_frequency *freq)
 {
 	struct wl1273_device *radio = video_get_drvdata(video_devdata(file));
 	struct wl1273_core *core = radio->core;

commit 21fbd5809ad126b949206d78e0a0e07ec872ea11
Merge: d9978ec56800 ed72d37a33fd
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Feb 24 17:35:10 2013 -0800

    Merge branch 'v4l_for_linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mchehab/linux-media
    
    Pull media updates from Mauro Carvalho Chehab:
    
     - Some cleanups at V4L2 documentation
    
     - new drivers: ts2020 frontend, ov9650 sensor, s5c73m3 sensor,
       sh-mobile veu mem2mem driver, radio-ma901, davinci_vpfe staging
       driver
    
     - Lots of missing MAINTAINERS entries added
    
     - several em28xx driver improvements, including its conversion to
       videobuf2
    
     - several fixups on drivers to make them to better comply with the API
    
     - DVB core: add support for DVBv5 stats, allowing the implementation of
       statistics for new standards like ISDB
    
     - mb86a20s: add statistics to the driver
    
     - lots of new board additions, cleanups, and driver improvements.
    
    * 'v4l_for_linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mchehab/linux-media: (596 commits)
      [media] media: Add 0x3009 USB PID to ttusb2 driver (fixed diff)
      [media] rtl28xxu: Add USB IDs for Compro VideoMate U620F
      [media] em28xx: add usb id for terratec h5 rev. 3
      [media] media: rc: gpio-ir-recv: add support for device tree parsing
      [media] mceusb: move check earlier to make smatch happy
      [media] radio-si470x doc: add info about v4l2-ctl and sox+alsa
      [media] staging: media: Remove unnecessary OOM messages
      [media] sh_vou: Use vou_dev instead of vou_file wherever possible
      [media] sh_vou: Use video_drvdata()
      [media] drivers/media/platform/soc_camera/pxa_camera.c: use devm_ functions
      [media] mt9t112: mt9t111 format set up differs from mt9t112
      [media] sh-mobile-ceu-camera: fix SHARPNESS control default
      Revert "[media] fc0011: Return early, if the frequency is already tuned"
      [media] cx18/ivtv: fix regression: remove __init from a non-init function
      [media] em28xx: fix analog streaming with USB bulk transfers
      [media] stv0900: remove unnecessary null pointer check
      [media] fc0011: Return early, if the frequency is already tuned
      [media] fc0011: Add some sanity checks and cleanups
      [media] fc0011: Fix xin value clamping
      Revert "[media] [PATH,1/2] mxl5007 move reset to attach"
      ...

commit ce4a3d52888a95473914bd54bcf6c566014fc03e
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Sat Jan 5 08:52:12 2013 -0300

    [media] radio: set vfl_dir correctly to fix modulator regression
    
    The vfl_dir field should be set to indicate whether a device can receive
    data, output data or can do both. This is used to let the v4l core know
    which ioctls should be accepted and which can be refused.
    Unfortunately, when this field was added the radio modulator drivers were
    not updated: radio modulators transmit and so vfl_dir should be set to
    VFL_DIR_TX (or VFL_DIR_M2M in the special case of wl128x).
    Because of this omission it is not possible to call g/s_modulator for these
    drivers, which effectively renders them useless.
    This patch sets the correct vfl_dir value for these drivers, correcting
    this bug.
    Thanks to Paul Grinberg for bringing this to my attention.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-wl1273.c b/drivers/media/radio/radio-wl1273.c
index c48be195bbad..cabbe3adf435 100644
--- a/drivers/media/radio/radio-wl1273.c
+++ b/drivers/media/radio/radio-wl1273.c
@@ -1971,6 +1971,7 @@ static struct video_device wl1273_viddev_template = {
 	.ioctl_ops		= &wl1273_ioctl_ops,
 	.name			= WL1273_FM_DRIVER_NAME,
 	.release		= wl1273_vdev_release,
+	.vfl_dir		= VFL_DIR_TX,
 };
 
 static int wl1273_fm_radio_remove(struct platform_device *pdev)

commit a32f7d1ad3744914273c6907204c2ab3b5d496a0
Merge: 6b9e50c463ef 68d6f84ba0c4
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Thu Jan 24 18:49:18 2013 -0200

    Merge branch 'v4l_for_linus' into staging/for_v3.9
    
    * v4l_for_linus: (464 commits)
      [media] uvcvideo: Set error_idx properly for S_EXT_CTRLS failures
      [media] uvcvideo: Cleanup leftovers of partial revert
      [media] uvcvideo: Return -EACCES when trying to set a read-only control
      Linux 3.8-rc3
      mm: reinstante dropped pmd_trans_splitting() check
      cred: Remove tgcred pointer from struct cred
      drm/ttm: fix fence locking in ttm_buffer_object_transfer
      ARM: clps711x: Fix bad merge of clockevents setup
      ARM: highbank: save and restore L2 cache and GIC on suspend
      ARM: highbank: add a power request clear
      ARM: highbank: fix secondary boot and hotplug
      ARM: highbank: fix typos with hignbank in power request functions
      ARM: dts: fix highbank cpu mpidr values
      ARM: dts: add device_type prop to cpu nodes on Calxeda platforms
      drm/prime: drop reference on imported dma-buf come from gem
      xen/netfront: improve truesize tracking
      ARM: mx5: Fix MX53 flexcan2 clock
      ARM: OMAP2+: am33xx-hwmod: Fix wrongly terminated am33xx_usbss_mpu_irqs array
      sctp: fix Kconfig bug in default cookie hmac selection
      EDAC: Cleanup device deregistering path
      ...
    
    Conflicts:
            drivers/media/pci/dm1105/dm1105.c
            drivers/media/platform/soc_camera/mx2_camera.c

commit 4c62e9764ab403d42f9b8871b1241fe7812f19d4
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Dec 21 13:17:53 2012 -0800

    Drivers: media: remove __dev* attributes.
    
    CONFIG_HOTPLUG is going away as an option.  As a result, the __dev*
    markings need to be removed.
    
    This change removes the use of __devinit, __devexit_p, __devinitdata,
    __devinitconst, and __devexit from these drivers.
    
    Based on patches originally written by Bill Pemberton, but redone by me
    in order to handle some of the coding style issues better, by hand.
    
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Mauro Carvalho Chehab <mchehab@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/media/radio/radio-wl1273.c b/drivers/media/radio/radio-wl1273.c
index 9b0c9fa0beb8..c48be195bbad 100644
--- a/drivers/media/radio/radio-wl1273.c
+++ b/drivers/media/radio/radio-wl1273.c
@@ -1990,7 +1990,7 @@ static int wl1273_fm_radio_remove(struct platform_device *pdev)
 	return 0;
 }
 
-static int __devinit wl1273_fm_radio_probe(struct platform_device *pdev)
+static int wl1273_fm_radio_probe(struct platform_device *pdev)
 {
 	struct wl1273_core **core = pdev->dev.platform_data;
 	struct wl1273_device *radio;
@@ -2145,7 +2145,7 @@ static int __devinit wl1273_fm_radio_probe(struct platform_device *pdev)
 
 static struct platform_driver wl1273_fm_radio_driver = {
 	.probe		= wl1273_fm_radio_probe,
-	.remove		= __devexit_p(wl1273_fm_radio_remove),
+	.remove		= wl1273_fm_radio_remove,
 	.driver		= {
 		.name	= "wl1273_fm_radio",
 		.owner	= THIS_MODULE,

commit 2b9b325d73dc092e1b888c381b98dde57d394194
Author: Ezequiel Garcia <elezegarcia@gmail.com>
Date:   Tue Oct 23 15:57:25 2012 -0300

    [media] radio-wl1273: Replace memcpy with struct assignment
    
    This kind of memcpy() is error-prone. Its replacement with a struct
    assignment is prefered because it's type-safe and much easier to read.
    Found by coccinelle. Hand patched and reviewed.
    Tested by compilation only.
    A simplified version of the semantic match that finds this problem is as
    follows: (http://coccinelle.lip6.fr/)
    // <smpl>
    @@
    identifier struct_name;
    struct struct_name to;
    struct struct_name from;
    expression E;
    @@
    -memcpy(&(to), &(from), E);
    +to = from;
    // </smpl>
    
    Signed-off-by: Peter Senna Tschudin <peter.senna@gmail.com>
    Signed-off-by: Ezequiel Garcia <elezegarcia@gmail.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-wl1273.c b/drivers/media/radio/radio-wl1273.c
index 9b0c9fa0beb8..6e55e93c0cf6 100644
--- a/drivers/media/radio/radio-wl1273.c
+++ b/drivers/media/radio/radio-wl1273.c
@@ -2084,8 +2084,7 @@ static int __devinit wl1273_fm_radio_probe(struct platform_device *pdev)
 	}
 
 	/* V4L2 configuration */
-	memcpy(&radio->videodev, &wl1273_viddev_template,
-	       sizeof(wl1273_viddev_template));
+	radio->videodev = wl1273_viddev_template;
 
 	radio->videodev.v4l2_dev = &radio->v4l2dev;
 

commit 617ade61ea88a370c89960918eddfa10c41316f5
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Fri Sep 21 09:33:35 2012 -0300

    [media] radio drivers: in non-blocking mode return EAGAIN in hwseek
    
    VIDIOC_S_HW_FREQ_SEEK should return EAGAIN when called in non-blocking
    mode. This might change in the future if we add support for this in the
    future, but right now this is not supported.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-wl1273.c b/drivers/media/radio/radio-wl1273.c
index b53ecbc67f17..9b0c9fa0beb8 100644
--- a/drivers/media/radio/radio-wl1273.c
+++ b/drivers/media/radio/radio-wl1273.c
@@ -1693,6 +1693,9 @@ static int wl1273_fm_vidioc_s_hw_freq_seek(struct file *file, void *priv,
 	if (seek->tuner != 0 || seek->type != V4L2_TUNER_RADIO)
 		return -EINVAL;
 
+	if (file->f_flags & O_NONBLOCK)
+		return -EWOULDBLOCK;
+
 	if (mutex_lock_interruptible(&core->lock))
 		return -EINTR;
 

commit 3f70e1f598a6be4277e71516a98457fd3bddfbd0
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Tue Sep 4 12:08:47 2012 -0300

    [media] v4l2: make vidioc_s_modulator const
    
    Write-only ioctls should have a const argument in the ioctl op.
    Do this conversion for vidioc_s_modulator.
    Adding const for write-only ioctls was decided during the 2012 Media Workshop.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-wl1273.c b/drivers/media/radio/radio-wl1273.c
index 2d93354fdcec..b53ecbc67f17 100644
--- a/drivers/media/radio/radio-wl1273.c
+++ b/drivers/media/radio/radio-wl1273.c
@@ -1715,7 +1715,7 @@ static int wl1273_fm_vidioc_s_hw_freq_seek(struct file *file, void *priv,
 }
 
 static int wl1273_fm_vidioc_s_modulator(struct file *file, void *priv,
-					struct v4l2_modulator *modulator)
+					const struct v4l2_modulator *modulator)
 {
 	struct wl1273_device *radio = video_get_drvdata(video_devdata(file));
 	struct wl1273_core *core = radio->core;

commit 0e8025b9f6011a6bd69d01080d584bc95a89d02e
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Tue Sep 4 11:59:31 2012 -0300

    [media] v4l2: make vidioc_s_audio const
    
    Write-only ioctls should have a const argument in the ioctl op.
    Do this conversion for vidioc_s_audio.
    Adding const for write-only ioctls was decided during the 2012 Media Workshop.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-wl1273.c b/drivers/media/radio/radio-wl1273.c
index 71968a610734..2d93354fdcec 100644
--- a/drivers/media/radio/radio-wl1273.c
+++ b/drivers/media/radio/radio-wl1273.c
@@ -1479,7 +1479,7 @@ static int wl1273_fm_vidioc_g_audio(struct file *file, void *priv,
 }
 
 static int wl1273_fm_vidioc_s_audio(struct file *file, void *priv,
-				    struct v4l2_audio *audio)
+				    const struct v4l2_audio *audio)
 {
 	struct wl1273_device *radio = video_get_drvdata(video_devdata(file));
 

commit ec6f4328108f1c83d5ac907c0d978fa886ef9627
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Fri Sep 14 07:41:18 2012 -0300

    [media] v4l2: make vidioc_s_freq_hw_seek const
    
    Write-only ioctls should have a const argument in the ioctl op.
    Do this conversion for vidioc_s_freq_hw_seek.
    Adding const for write-only ioctls was decided during the 2012 Media Workshop.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-wl1273.c b/drivers/media/radio/radio-wl1273.c
index a22ad1c1f3d5..71968a610734 100644
--- a/drivers/media/radio/radio-wl1273.c
+++ b/drivers/media/radio/radio-wl1273.c
@@ -1682,7 +1682,7 @@ static int wl1273_fm_vidioc_s_frequency(struct file *file, void *priv,
 #define WL1273_DEFAULT_SEEK_LEVEL	7
 
 static int wl1273_fm_vidioc_s_hw_freq_seek(struct file *file, void *priv,
-					   struct v4l2_hw_freq_seek *seek)
+					   const struct v4l2_hw_freq_seek *seek)
 {
 	struct wl1273_device *radio = video_get_drvdata(video_devdata(file));
 	struct wl1273_core *core = radio->core;

commit d91e0139351b040ec558accab84bf59d5cef5552
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Tue Jul 31 05:21:35 2012 -0300

    [media] drivers/media/radio/radio-wl1273.c: use devm_ functions
    
    The various devm_ functions allocate memory that is released when a driver
    detaches.  This patch uses these functions for data that is allocated in
    the probe function of a platform device and is only freed in the remove
    function.
    
    In two cases, the original memory allocation function was kmalloc, which
    has been changed to a zeroing allocation to benefit from the devm function.
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-wl1273.c b/drivers/media/radio/radio-wl1273.c
index e8428f573ccd..a22ad1c1f3d5 100644
--- a/drivers/media/radio/radio-wl1273.c
+++ b/drivers/media/radio/radio-wl1273.c
@@ -1983,9 +1983,6 @@ static int wl1273_fm_radio_remove(struct platform_device *pdev)
 	v4l2_ctrl_handler_free(&radio->ctrl_handler);
 	video_unregister_device(&radio->videodev);
 	v4l2_device_unregister(&radio->v4l2dev);
-	kfree(radio->buffer);
-	kfree(radio->write_buf);
-	kfree(radio);
 
 	return 0;
 }
@@ -2005,7 +2002,7 @@ static int __devinit wl1273_fm_radio_probe(struct platform_device *pdev)
 		goto pdata_err;
 	}
 
-	radio = kzalloc(sizeof(*radio), GFP_KERNEL);
+	radio = devm_kzalloc(&pdev->dev, sizeof(*radio), GFP_KERNEL);
 	if (!radio) {
 		r = -ENOMEM;
 		goto pdata_err;
@@ -2013,11 +2010,11 @@ static int __devinit wl1273_fm_radio_probe(struct platform_device *pdev)
 
 	/* RDS buffer allocation */
 	radio->buf_size = rds_buf * RDS_BLOCK_SIZE;
-	radio->buffer = kmalloc(radio->buf_size, GFP_KERNEL);
+	radio->buffer = devm_kzalloc(&pdev->dev, radio->buf_size, GFP_KERNEL);
 	if (!radio->buffer) {
 		pr_err("Cannot allocate memory for RDS buffer.\n");
 		r = -ENOMEM;
-		goto err_kmalloc;
+		goto pdata_err;
 	}
 
 	radio->core = *core;
@@ -2043,7 +2040,7 @@ static int __devinit wl1273_fm_radio_probe(struct platform_device *pdev)
 		if (r) {
 			dev_err(radio->dev, WL1273_FM_DRIVER_NAME
 				": Cannot get platform data\n");
-			goto err_resources;
+			goto pdata_err;
 		}
 
 		dev_dbg(radio->dev, "irq: %d\n", radio->core->client->irq);
@@ -2061,13 +2058,13 @@ static int __devinit wl1273_fm_radio_probe(struct platform_device *pdev)
 		dev_err(radio->dev, WL1273_FM_DRIVER_NAME ": Core WL1273 IRQ"
 			" not configured");
 		r = -EINVAL;
-		goto err_resources;
+		goto pdata_err;
 	}
 
 	init_completion(&radio->busy);
 	init_waitqueue_head(&radio->read_queue);
 
-	radio->write_buf = kmalloc(256, GFP_KERNEL);
+	radio->write_buf = devm_kzalloc(&pdev->dev, 256, GFP_KERNEL);
 	if (!radio->write_buf) {
 		r = -ENOMEM;
 		goto write_buf_err;
@@ -2080,7 +2077,7 @@ static int __devinit wl1273_fm_radio_probe(struct platform_device *pdev)
 	r = v4l2_device_register(&pdev->dev, &radio->v4l2dev);
 	if (r) {
 		dev_err(&pdev->dev, "Cannot register v4l2_device.\n");
-		goto device_register_err;
+		goto write_buf_err;
 	}
 
 	/* V4L2 configuration */
@@ -2135,16 +2132,10 @@ static int __devinit wl1273_fm_radio_probe(struct platform_device *pdev)
 handler_init_err:
 	v4l2_ctrl_handler_free(&radio->ctrl_handler);
 	v4l2_device_unregister(&radio->v4l2dev);
-device_register_err:
-	kfree(radio->write_buf);
 write_buf_err:
 	free_irq(radio->core->client->irq, radio);
 err_request_irq:
 	radio->core->pdata->free_resources();
-err_resources:
-	kfree(radio->buffer);
-err_kmalloc:
-	kfree(radio);
 pdata_err:
 	return r;
 }

commit 54f6019b5860ec062d1149b3a97a5a63ad3e4da9
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Sun May 27 07:25:06 2012 -0300

    [media] S_HW_FREQ_SEEK: set capability flags and return ENODATA instead of EAGAIN
    
    Set the new capability flags in G_TUNER and return ENODATA if no channels
    were found.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Acked-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-wl1273.c b/drivers/media/radio/radio-wl1273.c
index f1b607099b6c..e8428f573ccd 100644
--- a/drivers/media/radio/radio-wl1273.c
+++ b/drivers/media/radio/radio-wl1273.c
@@ -1514,7 +1514,8 @@ static int wl1273_fm_vidioc_g_tuner(struct file *file, void *priv,
 	tuner->rangehigh = WL1273_FREQ(WL1273_BAND_OTHER_HIGH);
 
 	tuner->capability = V4L2_TUNER_CAP_LOW | V4L2_TUNER_CAP_RDS |
-		V4L2_TUNER_CAP_STEREO | V4L2_TUNER_CAP_RDS_BLOCK_IO;
+		V4L2_TUNER_CAP_STEREO | V4L2_TUNER_CAP_RDS_BLOCK_IO |
+		V4L2_TUNER_CAP_HWSEEK_BOUNDED | V4L2_TUNER_CAP_HWSEEK_WRAP;
 
 	if (radio->stereo)
 		tuner->audmode = V4L2_TUNER_MODE_STEREO;

commit 1d6629b1561ad34a6e6d17ece00bd65e1bab3724
Author: Axel Lin <axel.lin@gmail.com>
Date:   Tue Jan 10 03:21:49 2012 -0300

    [media] convert drivers/media/* to use module_platform_driver()
    
    This patch converts the drivers in drivers/media/* to use the
    module_platform_driver() macro which makes the code smaller and a bit
    simpler.
    
    Cc: Mauro Carvalho Chehab <mchehab@infradead.org>
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Cc: Kyungmin Park <kyungmin.park@samsung.com>
    Cc: Hans Verkuil <hans.verkuil@cisco.com>
    Cc: "Richard Röjfors" <richard.rojfors@pelagicore.com>
    Cc: "Matti J. Aaltonen" <matti.j.aaltonen@nokia.com>
    Cc: Lucas De Marchi <lucas.demarchi@profusion.mobi>
    Cc: Manjunath Hadli <manjunath.hadli@ti.com>
    Cc: Muralidharan Karicheri <m-karicheri2@ti.com>
    Cc: Anatolij Gustschin <agust@denx.de>
    Cc: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
    Cc: Marek Szyprowski <m.szyprowski@samsung.com>
    Cc: Robert Jarzmik <robert.jarzmik@free.fr>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Daniel Drake <dsd@laptop.org>
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Acked-by: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
    Acked-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Acked-by: Matti J. Aaltonen <matti.j.aaltonen@nokia.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-wl1273.c b/drivers/media/radio/radio-wl1273.c
index 8aa4968d57bc..f1b607099b6c 100644
--- a/drivers/media/radio/radio-wl1273.c
+++ b/drivers/media/radio/radio-wl1273.c
@@ -2148,8 +2148,6 @@ static int __devinit wl1273_fm_radio_probe(struct platform_device *pdev)
 	return r;
 }
 
-MODULE_ALIAS("platform:wl1273_fm_radio");
-
 static struct platform_driver wl1273_fm_radio_driver = {
 	.probe		= wl1273_fm_radio_probe,
 	.remove		= __devexit_p(wl1273_fm_radio_remove),
@@ -2159,20 +2157,9 @@ static struct platform_driver wl1273_fm_radio_driver = {
 	},
 };
 
-static int __init wl1273_fm_module_init(void)
-{
-	pr_info("%s\n", __func__);
-	return platform_driver_register(&wl1273_fm_radio_driver);
-}
-module_init(wl1273_fm_module_init);
-
-static void __exit wl1273_fm_module_exit(void)
-{
-	platform_driver_unregister(&wl1273_fm_radio_driver);
-	pr_info(DRIVER_DESC ", Exiting.\n");
-}
-module_exit(wl1273_fm_module_exit);
+module_platform_driver(wl1273_fm_radio_driver);
 
 MODULE_AUTHOR("Matti Aaltonen <matti.j.aaltonen@nokia.com>");
 MODULE_DESCRIPTION(DRIVER_DESC);
 MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:wl1273_fm_radio");

commit 32aaeffbd4a7457bf2f7448b33b5946ff2a960eb
Merge: 208bca086040 67b84999b1a8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Nov 6 19:44:47 2011 -0800

    Merge branch 'modsplit-Oct31_2011' of git://git.kernel.org/pub/scm/linux/kernel/git/paulg/linux
    
    * 'modsplit-Oct31_2011' of git://git.kernel.org/pub/scm/linux/kernel/git/paulg/linux: (230 commits)
      Revert "tracing: Include module.h in define_trace.h"
      irq: don't put module.h into irq.h for tracking irqgen modules.
      bluetooth: macroize two small inlines to avoid module.h
      ip_vs.h: fix implicit use of module_get/module_put from module.h
      nf_conntrack.h: fix up fallout from implicit moduleparam.h presence
      include: replace linux/module.h with "struct module" wherever possible
      include: convert various register fcns to macros to avoid include chaining
      crypto.h: remove unused crypto_tfm_alg_modname() inline
      uwb.h: fix implicit use of asm/page.h for PAGE_SIZE
      pm_runtime.h: explicitly requires notifier.h
      linux/dmaengine.h: fix implicit use of bitmap.h and asm/page.h
      miscdevice.h: fix up implicit use of lists and types
      stop_machine.h: fix implicit use of smp.h for smp_processor_id
      of: fix implicit use of errno.h in include/linux/of.h
      of_platform.h: delete needless include <linux/module.h>
      acpi: remove module.h include from platform/aclinux.h
      miscdevice.h: delete unnecessary inclusion of module.h
      device_cgroup.h: delete needless include <linux/module.h>
      net: sch_generic remove redundant use of <linux/module.h>
      net: inet_timewait_sock doesnt need <linux/module.h>
      ...
    
    Fix up trivial conflicts (other header files, and  removal of the ab3550 mfd driver) in
     - drivers/media/dvb/frontends/dibx000_common.c
     - drivers/media/video/{mt9m111.c,ov6650.c}
     - drivers/mfd/ab3550-core.c
     - include/linux/dmaengine.h

commit 7a707b89202f905bd9f9fbde326933c59a81214c
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Sun Jul 3 14:03:12 2011 -0400

    drivers/media: Add module.h to all files using it implicitly
    
    A pending cleanup will mean that module.h won't be implicitly
    everywhere anymore.  Make sure the modular drivers in clocksource
    are actually calling out for <module.h> explicitly in advance.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/drivers/media/radio/radio-wl1273.c b/drivers/media/radio/radio-wl1273.c
index 46cacf845049..5e7dfda817b2 100644
--- a/drivers/media/radio/radio-wl1273.c
+++ b/drivers/media/radio/radio-wl1273.c
@@ -23,6 +23,7 @@
 #include <linux/interrupt.h>
 #include <linux/mfd/wl1273-core.h>
 #include <linux/slab.h>
+#include <linux/module.h>
 #include <media/v4l2-common.h>
 #include <media/v4l2-ctrls.h>
 #include <media/v4l2-device.h>

commit 88365105d683187e02a4f75220eaf51fd0c0b6e0
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Fri Aug 26 07:35:14 2011 -0300

    [media] v4l2-ctrls: replace is_volatile with V4L2_CTRL_FLAG_VOLATILE
    
    With the new flag there is no need anymore to have a separate is_volatile
    field. Modify all users to use the new flag.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Acked-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-wl1273.c b/drivers/media/radio/radio-wl1273.c
index 46cacf845049..6d1e4e750f63 100644
--- a/drivers/media/radio/radio-wl1273.c
+++ b/drivers/media/radio/radio-wl1273.c
@@ -2109,7 +2109,7 @@ static int __devinit wl1273_fm_radio_probe(struct platform_device *pdev)
 				 V4L2_CID_TUNE_ANTENNA_CAPACITOR,
 				 0, 255, 1, 255);
 	if (ctrl)
-		ctrl->is_volatile = 1;
+		ctrl->flags |= V4L2_CTRL_FLAG_VOLATILE;
 
 	if (radio->ctrl_handler.error) {
 		r = radio->ctrl_handler.error;

commit ddac5c107942d9584a9f55701aad405b57618726
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Fri Jun 10 05:43:34 2011 -0300

    [media] v4l2-ctrls: fix and improve volatile control handling
    
    If you have a cluster of controls that is a mix of volatile and non-volatile
    controls, then requesting the value of the volatile control would fail if the
    master control of that cluster was non-volatile. The code assumed that the
    volatile state of the master control was the same for all other controls in
    the cluster.
    
    This is now fixed.
    
    In addition, it was clear from bugs in some drivers that it was confusing that
    the ctrl->cur union had to be used in g_volatile_ctrl. Several drivers used the
    'new' values instead. The framework was changed so that drivers now set the new
    value instead of the current value.
    
    This has an additional benefit as well: the volatile values are now only stored
    in the 'new' value, leaving the current value alone. This is useful for
    autofoo/foo control clusters where you want to have a 'foo' control act like a
    volatile control if 'autofoo' is on, but as a normal control when it is off.
    
    Since with this change the cur value is no longer overwritten when g_volatile_ctrl
    is called, you can use it to remember the original 'foo' value. For example:
    
    autofoo = 0, foo = 10 and foo is non-volatile.
    
    Now autofoo is set to 1 and foo is marked volatile. Retrieving the foo value
    will get the volatile value. Set autofoo back to 0, which marks foo as non-
    volatile again, and retrieving foo will get the old current value of 10.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-wl1273.c b/drivers/media/radio/radio-wl1273.c
index 459f7272d326..46cacf845049 100644
--- a/drivers/media/radio/radio-wl1273.c
+++ b/drivers/media/radio/radio-wl1273.c
@@ -1382,7 +1382,7 @@ static int wl1273_fm_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
 
 	switch (ctrl->id) {
 	case  V4L2_CID_TUNE_ANTENNA_CAPACITOR:
-		ctrl->cur.val = wl1273_fm_get_tx_ctune(radio);
+		ctrl->val = wl1273_fm_get_tx_ctune(radio);
 		break;
 
 	default:

commit c0880dcded3ffe77700184e9d96c110ce0094c11
Merge: f7fc06e3a47d 616a4b83bd1b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri May 27 10:14:22 2011 -0700

    Merge branch 'v4l_for_linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mchehab/linux-2.6
    
    * 'v4l_for_linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mchehab/linux-2.6:
      [media] v1.88 DM04/QQBOX Move remote to use rc_core dvb-usb-remote
      [media] Add missing include guard to header file
      [media] Inlined functions should be static
      [media] Remove invalid parameter description
      [media] cpia2: fix warning about invalid trigraph sequence
      [media] s5p-csis: Add missing dependency on PLAT_S5P
      [media] gspca/kinect: wrap gspca_debug with GSPCA_DEBUG
      [media] fintek-cir: new driver for Fintek LPC SuperIO CIR function
      [media] uvcvideo: Connect video devices to media entities
      [media] uvcvideo: Register subdevices for each entity
      [media] uvcvideo: Register a v4l2_device
      [media] add V4L2-PIX-FMT-SRGGB12 & friends to docbook
      [media] Documentation/DocBook: Rename media fops xml files
      [media] Media DocBook: fix validation errors
      [media] wl12xx: g_volatile_ctrl fix: wrong field set
      [media] fix kconfig dependency warning for VIDEO_TIMBERDALE
      [media] dm1105: GPIO handling added, I2C on GPIO added, LNB control through GPIO reworked
      [media] Add support for M-5MOLS 8 Mega Pixel camera ISP

commit 9e554696c03e04c51d095c1c451e26a8cb6a84fa
Author: Samuel Ortiz <sameo@linux.intel.com>
Date:   Wed Apr 6 11:56:04 2011 +0200

    mfd: Use mfd cell platform_data for wl1273 cells platform bits
    
    With the addition of a platform device mfd_cell pointer, MFD drivers
    can go back to passing platform data back to their sub drivers.
    This allows for an mfd_cell->mfd_data removal and thus keep the
    sub drivers MFD agnostic. This is mostly needed for non MFD aware
    sub drivers.
    
    Cc: Matti Aaltonen <matti.j.aaltonen@nokia.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/media/radio/radio-wl1273.c b/drivers/media/radio/radio-wl1273.c
index e2550dc2944f..46cacf845049 100644
--- a/drivers/media/radio/radio-wl1273.c
+++ b/drivers/media/radio/radio-wl1273.c
@@ -1990,7 +1990,7 @@ static int wl1273_fm_radio_remove(struct platform_device *pdev)
 
 static int __devinit wl1273_fm_radio_probe(struct platform_device *pdev)
 {
-	struct wl1273_core **core = mfd_get_data(pdev);
+	struct wl1273_core **core = pdev->dev.platform_data;
 	struct wl1273_device *radio;
 	struct v4l2_ctrl *ctrl;
 	int r = 0;

commit c6ae804a65649d5919d232d65dc6a08c9e5ac01b
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Thu May 5 04:37:28 2011 -0300

    [media] wl12xx: g_volatile_ctrl fix: wrong field set
    
    The function g_volatile_ctrl should change the current value rather than the
    new value. These two drivers didn't do that, so the value is never reported
    correctly.
    
    In the future this will change since this behavior is clearly unexpected,
    but for now fix these drivers first.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-wl1273.c b/drivers/media/radio/radio-wl1273.c
index e2550dc2944f..9dbbd31b5ba2 100644
--- a/drivers/media/radio/radio-wl1273.c
+++ b/drivers/media/radio/radio-wl1273.c
@@ -1382,7 +1382,7 @@ static int wl1273_fm_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
 
 	switch (ctrl->id) {
 	case  V4L2_CID_TUNE_ANTENNA_CAPACITOR:
-		ctrl->val = wl1273_fm_get_tx_ctune(radio);
+		ctrl->cur.val = wl1273_fm_get_tx_ctune(radio);
 		break;
 
 	default:

commit 76d21c563569bcea6bc67d65cc2c460cff643058
Merge: 6e50e9f9f4a8 472af2b05bde
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Mar 24 09:50:13 2011 -0700

    Merge branch 'v4l_for_linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mchehab/linux-2.6
    
    * 'v4l_for_linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mchehab/linux-2.6: (442 commits)
      [media] videobuf2-dma-contig: make cookie() return a pointer to dma_addr_t
      [media] sh_mobile_ceu_camera: Do not call vb2's mem_ops directly
      [media] V4L: soc-camera: explicitly require V4L2_BUF_TYPE_VIDEO_CAPTURE
      [media] v4l: soc-camera: Store negotiated buffer settings
      [media] rc: interim support for 32-bit NEC-ish scancodes
      [media] mceusb: topseed 0x0011 needs gen3 init for tx to work
      [media] lirc_zilog: error out if buffer read bytes != chunk size
      [media] lirc: silence some compile warnings
      [media] hdpvr: use same polling interval as other OS
      [media] ir-kbd-i2c: pass device code w/key in hauppauge case
      [media] rc/keymaps: Remove the obsolete rc-rc5-tv keymap
      [media] remove the old RC_MAP_HAUPPAUGE_NEW RC map
      [media] rc/keymaps: Rename Hauppauge table as rc-hauppauge
      [media] rc-rc5-hauppauge-new: Fix Hauppauge Grey mapping
      [media] rc-rc5-hauppauge-new: Add support for the old Black RC
      [media] rc-rc5-hauppauge-new: Add the old control to the table
      [media] rc-winfast: Fix the keycode tables
      [media] a800: Fix a few wrong IR key assignments
      [media] opera1: Use multimedia keys instead of an app-specific mapping
      [media] dw2102: Use multimedia keys instead of an app-specific mapping
      ...
    
    Fix up trivial conflicts (remove/modify and some real conflicts) in:
            arch/arm/mach-omap2/devices.c
            drivers/staging/Kconfig
            drivers/staging/Makefile
            drivers/staging/dabusb/dabusb.c
            drivers/staging/dabusb/dabusb.h
            drivers/staging/easycap/easycap_ioctl.c
            drivers/staging/usbvideo/usbvideo.c
            drivers/staging/usbvideo/vicam.c

commit 15de7a41d30cfe8090efdc5fd6a92ed7a2d80ce7
Author: Andres Salomon <dilinger@queued.net>
Date:   Thu Feb 17 19:07:17 2011 -0800

    mfd: mfd_cell is now implicitly available to wl1273 drivers
    
    The cell's platform_data is now accessed with a helper function;
    change clients to use that, and remove the now-unused data_size.
    
    Signed-off-by: Andres Salomon <dilinger@queued.net>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/media/radio/radio-wl1273.c b/drivers/media/radio/radio-wl1273.c
index 7ecc8e657663..4698eb00b59f 100644
--- a/drivers/media/radio/radio-wl1273.c
+++ b/drivers/media/radio/radio-wl1273.c
@@ -2138,7 +2138,7 @@ static int wl1273_fm_radio_remove(struct platform_device *pdev)
 
 static int __devinit wl1273_fm_radio_probe(struct platform_device *pdev)
 {
-	struct wl1273_core **core = pdev->dev.platform_data;
+	struct wl1273_core **core = mfd_get_data(pdev);
 	struct wl1273_device *radio;
 	struct v4l2_ctrl *ctrl;
 	int r = 0;

commit 868e90d55c0eb6f3c5949c2a747714072c3e080a
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Jan 24 11:23:15 2011 -0300

    [media] radio-wl1273: remove unused wl1273_device->work
    
    wl1273_device->work is unused.  Remove it along with the spurious
    flush_scheduled_work() call in wl1273_fm_module_exit().
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Matti Aaltonen <matti.j.aaltonen@nokia.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-wl1273.c b/drivers/media/radio/radio-wl1273.c
index 9e177dccc673..46cacf845049 100644
--- a/drivers/media/radio/radio-wl1273.c
+++ b/drivers/media/radio/radio-wl1273.c
@@ -67,7 +67,6 @@ struct wl1273_device {
 
 	/* RDS */
 	unsigned int rds_on;
-	struct delayed_work work;
 
 	wait_queue_head_t read_queue;
 	struct mutex lock; /* for serializing fm radio operations */
@@ -967,9 +966,6 @@ static int wl1273_fm_rds_off(struct wl1273_device *radio)
 	if (r)
 		goto out;
 
-	/* stop rds reception */
-	cancel_delayed_work(&radio->work);
-
 	/* Service pending read */
 	wake_up_interruptible(&radio->read_queue);
 
@@ -2171,7 +2167,6 @@ module_init(wl1273_fm_module_init);
 
 static void __exit wl1273_fm_module_exit(void)
 {
-	flush_scheduled_work();
 	platform_driver_unregister(&wl1273_fm_radio_driver);
 	pr_info(DRIVER_DESC ", Exiting.\n");
 }

commit 96a9cc681ecfaf2ed9b6c62090888550f604d783
Author: Matti Aaltonen <matti.j.aaltonen@nokia.com>
Date:   Tue Mar 1 10:10:36 2011 -0300

    [media] V4L2: WL1273 FM Radio: TI WL1273 FM radio driver
    
    This module implements V4L2 controls for the Texas Instruments
    WL1273 FM Radio and handles the communication with the chip.
    
    Signed-off-by: Matti J. Aaltonen <matti.j.aaltonen@nokia.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-wl1273.c b/drivers/media/radio/radio-wl1273.c
index 7ecc8e657663..9e177dccc673 100644
--- a/drivers/media/radio/radio-wl1273.c
+++ b/drivers/media/radio/radio-wl1273.c
@@ -1,7 +1,7 @@
 /*
  * Driver for the Texas Instruments WL1273 FM radio.
  *
- * Copyright (C) 2010 Nokia Corporation
+ * Copyright (C) 2011 Nokia Corporation
  * Author: Matti J. Aaltonen <matti.j.aaltonen@nokia.com>
  *
  * This program is free software; you can redistribute it and/or
@@ -104,58 +104,6 @@ static unsigned int rds_buf = 100;
 module_param(rds_buf, uint, 0);
 MODULE_PARM_DESC(rds_buf, "Number of RDS buffer entries. Default = 100");
 
-static int wl1273_fm_read_reg(struct wl1273_core *core, u8 reg, u16 *value)
-{
-	struct i2c_client *client = core->client;
-	u8 b[2];
-	int r;
-
-	r = i2c_smbus_read_i2c_block_data(client, reg, sizeof(b), b);
-	if (r != 2) {
-		dev_err(&client->dev, "%s: Read: %d fails.\n", __func__, reg);
-		return -EREMOTEIO;
-	}
-
-	*value = (u16)b[0] << 8 | b[1];
-
-	return 0;
-}
-
-static int wl1273_fm_write_cmd(struct wl1273_core *core, u8 cmd, u16 param)
-{
-	struct i2c_client *client = core->client;
-	u8 buf[] = { (param >> 8) & 0xff, param & 0xff };
-	int r;
-
-	r = i2c_smbus_write_i2c_block_data(client, cmd, sizeof(buf), buf);
-	if (r) {
-		dev_err(&client->dev, "%s: Cmd: %d fails.\n", __func__, cmd);
-		return r;
-	}
-
-	return 0;
-}
-
-static int wl1273_fm_write_data(struct wl1273_core *core, u8 *data, u16 len)
-{
-	struct i2c_client *client = core->client;
-	struct i2c_msg msg;
-	int r;
-
-	msg.addr = client->addr;
-	msg.flags = 0;
-	msg.buf = data;
-	msg.len = len;
-
-	r = i2c_transfer(client->adapter, &msg, 1);
-	if (r != 1) {
-		dev_err(&client->dev, "%s: write error.\n", __func__);
-		return -EREMOTEIO;
-	}
-
-	return 0;
-}
-
 static int wl1273_fm_write_fw(struct wl1273_core *core,
 			      __u8 *fw, int len)
 {
@@ -188,94 +136,6 @@ static int wl1273_fm_write_fw(struct wl1273_core *core,
 	return r;
 }
 
-/**
- * wl1273_fm_set_audio() -	Set audio mode.
- * @core:			A pointer to the device struct.
- * @new_mode:			The new audio mode.
- *
- * Audio modes are WL1273_AUDIO_DIGITAL and WL1273_AUDIO_ANALOG.
- */
-static int wl1273_fm_set_audio(struct wl1273_core *core, unsigned int new_mode)
-{
-	int r = 0;
-
-	if (core->mode == WL1273_MODE_OFF ||
-	    core->mode == WL1273_MODE_SUSPENDED)
-		return -EPERM;
-
-	if (core->mode == WL1273_MODE_RX && new_mode == WL1273_AUDIO_DIGITAL) {
-		r = wl1273_fm_write_cmd(core, WL1273_PCM_MODE_SET,
-					WL1273_PCM_DEF_MODE);
-		if (r)
-			goto out;
-
-		r = wl1273_fm_write_cmd(core, WL1273_I2S_MODE_CONFIG_SET,
-					core->i2s_mode);
-		if (r)
-			goto out;
-
-		r = wl1273_fm_write_cmd(core, WL1273_AUDIO_ENABLE,
-					WL1273_AUDIO_ENABLE_I2S);
-		if (r)
-			goto out;
-
-	} else if (core->mode == WL1273_MODE_RX &&
-		   new_mode == WL1273_AUDIO_ANALOG) {
-		r = wl1273_fm_write_cmd(core, WL1273_AUDIO_ENABLE,
-					WL1273_AUDIO_ENABLE_ANALOG);
-		if (r)
-			goto out;
-
-	} else if (core->mode == WL1273_MODE_TX &&
-		   new_mode == WL1273_AUDIO_DIGITAL) {
-		r = wl1273_fm_write_cmd(core, WL1273_I2S_MODE_CONFIG_SET,
-					core->i2s_mode);
-		if (r)
-			goto out;
-
-		r = wl1273_fm_write_cmd(core, WL1273_AUDIO_IO_SET,
-					WL1273_AUDIO_IO_SET_I2S);
-		if (r)
-			goto out;
-
-	} else if (core->mode == WL1273_MODE_TX &&
-		   new_mode == WL1273_AUDIO_ANALOG) {
-		r = wl1273_fm_write_cmd(core, WL1273_AUDIO_IO_SET,
-					WL1273_AUDIO_IO_SET_ANALOG);
-		if (r)
-			goto out;
-	}
-
-	core->audio_mode = new_mode;
-out:
-	return r;
-}
-
-/**
- * wl1273_fm_set_volume() -	Set volume.
- * @core:			A pointer to the device struct.
- * @volume:			The new volume value.
- */
-static int wl1273_fm_set_volume(struct wl1273_core *core, unsigned int volume)
-{
-	u16 val;
-	int r;
-
-	if (volume > WL1273_MAX_VOLUME)
-		return -EINVAL;
-
-	if (core->volume == volume)
-		return 0;
-
-	val = volume;
-	r = wl1273_fm_read_reg(core, WL1273_VOLUME_SET, &val);
-	if (r)
-		return r;
-
-	core->volume = volume;
-	return 0;
-}
-
 #define WL1273_FIFO_HAS_DATA(status)	(1 << 5 & status)
 #define WL1273_RDS_CORRECTABLE_ERROR	(1 << 3)
 #define WL1273_RDS_UNCORRECTABLE_ERROR	(1 << 4)
@@ -306,7 +166,7 @@ static int wl1273_fm_rds(struct wl1273_device *radio)
 	if (core->mode != WL1273_MODE_RX)
 		return 0;
 
-	r = wl1273_fm_read_reg(core, WL1273_RDS_SYNC_GET, &val);
+	r = core->read(core, WL1273_RDS_SYNC_GET, &val);
 	if (r)
 		return r;
 
@@ -374,7 +234,7 @@ static irqreturn_t wl1273_fm_irq_thread_handler(int irq, void *dev_id)
 	u16 flags;
 	int r;
 
-	r = wl1273_fm_read_reg(core, WL1273_FLAG_GET, &flags);
+	r = core->read(core, WL1273_FLAG_GET, &flags);
 	if (r)
 		goto out;
 
@@ -398,7 +258,7 @@ static irqreturn_t wl1273_fm_irq_thread_handler(int irq, void *dev_id)
 	if (flags & WL1273_LEV_EVENT) {
 		u16 level;
 
-		r = wl1273_fm_read_reg(core, WL1273_RSSI_LVL_GET, &level);
+		r = core->read(core, WL1273_RSSI_LVL_GET, &level);
 		if (r)
 			goto out;
 
@@ -439,8 +299,8 @@ static irqreturn_t wl1273_fm_irq_thread_handler(int irq, void *dev_id)
 		dev_dbg(radio->dev, "IRQ: FR:\n");
 
 		if (core->mode == WL1273_MODE_RX) {
-			r = wl1273_fm_write_cmd(core, WL1273_TUNER_MODE_SET,
-						TUNER_MODE_STOP_SEARCH);
+			r = core->write(core, WL1273_TUNER_MODE_SET,
+					TUNER_MODE_STOP_SEARCH);
 			if (r) {
 				dev_err(radio->dev,
 					"%s: TUNER_MODE_SET fails: %d\n",
@@ -448,7 +308,7 @@ static irqreturn_t wl1273_fm_irq_thread_handler(int irq, void *dev_id)
 				goto out;
 			}
 
-			r = wl1273_fm_read_reg(core, WL1273_FREQ_SET, &freq);
+			r = core->read(core, WL1273_FREQ_SET, &freq);
 			if (r)
 				goto out;
 
@@ -467,7 +327,7 @@ static irqreturn_t wl1273_fm_irq_thread_handler(int irq, void *dev_id)
 			dev_dbg(radio->dev, "%dkHz\n", radio->rx_frequency);
 
 		} else {
-			r = wl1273_fm_read_reg(core, WL1273_CHANL_SET, &freq);
+			r = core->read(core, WL1273_CHANL_SET, &freq);
 			if (r)
 				goto out;
 
@@ -477,8 +337,7 @@ static irqreturn_t wl1273_fm_irq_thread_handler(int irq, void *dev_id)
 	}
 
 out:
-	wl1273_fm_write_cmd(core, WL1273_INT_MASK_SET,
-			    radio->irq_flags);
+	core->write(core, WL1273_INT_MASK_SET, radio->irq_flags);
 	complete(&radio->busy);
 
 	return IRQ_HANDLED;
@@ -512,7 +371,7 @@ static int wl1273_fm_set_tx_freq(struct wl1273_device *radio, unsigned int freq)
 	dev_dbg(radio->dev, "%s: freq: %d kHz\n", __func__, freq);
 
 	/* Set the current tx channel */
-	r = wl1273_fm_write_cmd(core, WL1273_CHANL_SET, freq / 10);
+	r = core->write(core, WL1273_CHANL_SET, freq / 10);
 	if (r)
 		return r;
 
@@ -526,7 +385,7 @@ static int wl1273_fm_set_tx_freq(struct wl1273_device *radio, unsigned int freq)
 	dev_dbg(radio->dev, "WL1273_CHANL_SET: %d\n", r);
 
 	/* Enable the output power */
-	r = wl1273_fm_write_cmd(core, WL1273_POWER_ENB_SET, 1);
+	r = core->write(core, WL1273_POWER_ENB_SET, 1);
 	if (r)
 		return r;
 
@@ -566,20 +425,20 @@ static int wl1273_fm_set_rx_freq(struct wl1273_device *radio, unsigned int freq)
 
 	dev_dbg(radio->dev, "%s: %dkHz\n", __func__, freq);
 
-	wl1273_fm_write_cmd(core, WL1273_INT_MASK_SET, radio->irq_flags);
+	core->write(core, WL1273_INT_MASK_SET, radio->irq_flags);
 
 	if (radio->band == WL1273_BAND_JAPAN)
 		f = (freq - WL1273_BAND_JAPAN_LOW) / 50;
 	else
 		f = (freq - WL1273_BAND_OTHER_LOW) / 50;
 
-	r = wl1273_fm_write_cmd(core, WL1273_FREQ_SET, f);
+	r = core->write(core, WL1273_FREQ_SET, f);
 	if (r) {
 		dev_err(radio->dev, "FREQ_SET fails\n");
 		goto err;
 	}
 
-	r = wl1273_fm_write_cmd(core, WL1273_TUNER_MODE_SET, TUNER_MODE_PRESET);
+	r = core->write(core, WL1273_TUNER_MODE_SET, TUNER_MODE_PRESET);
 	if (r) {
 		dev_err(radio->dev, "TUNER_MODE_SET fails\n");
 		goto err;
@@ -609,7 +468,7 @@ static int wl1273_fm_get_freq(struct wl1273_device *radio)
 	int r;
 
 	if (core->mode == WL1273_MODE_RX) {
-		r = wl1273_fm_read_reg(core, WL1273_FREQ_SET, &f);
+		r = core->read(core, WL1273_FREQ_SET, &f);
 		if (r)
 			return r;
 
@@ -619,7 +478,7 @@ static int wl1273_fm_get_freq(struct wl1273_device *radio)
 		else
 			freq = WL1273_BAND_OTHER_LOW + 50 * f;
 	} else {
-		r = wl1273_fm_read_reg(core, WL1273_CHANL_SET, &f);
+		r = core->read(core, WL1273_CHANL_SET, &f);
 		if (r)
 			return r;
 
@@ -670,7 +529,7 @@ static int wl1273_fm_upload_firmware_patch(struct wl1273_device *radio)
 	}
 
 	/* ignore possible error here */
-	wl1273_fm_write_cmd(core, WL1273_RESET, 0);
+	core->write(core, WL1273_RESET, 0);
 
 	dev_dbg(dev, "%s - download OK, r: %d\n", __func__, r);
 out:
@@ -683,14 +542,14 @@ static int wl1273_fm_stop(struct wl1273_device *radio)
 	struct wl1273_core *core = radio->core;
 
 	if (core->mode == WL1273_MODE_RX) {
-		int r = wl1273_fm_write_cmd(core, WL1273_POWER_SET,
+		int r = core->write(core, WL1273_POWER_SET,
 				    WL1273_POWER_SET_OFF);
 		if (r)
 			dev_err(radio->dev, "%s: POWER_SET fails: %d\n",
 				__func__, r);
 	} else if (core->mode == WL1273_MODE_TX) {
-		int r = wl1273_fm_write_cmd(core, WL1273_PUPD_SET,
-					    WL1273_PUPD_SET_OFF);
+		int r = core->write(core, WL1273_PUPD_SET,
+				    WL1273_PUPD_SET_OFF);
 		if (r)
 			dev_err(radio->dev,
 				"%s: PUPD_SET fails: %d\n", __func__, r);
@@ -725,11 +584,11 @@ static int wl1273_fm_start(struct wl1273_device *radio, int new_mode)
 			val |= WL1273_POWER_SET_RDS;
 
 		/* If this fails try again */
-		r = wl1273_fm_write_cmd(core, WL1273_POWER_SET, val);
+		r = core->write(core, WL1273_POWER_SET, val);
 		if (r) {
 			msleep(100);
 
-			r = wl1273_fm_write_cmd(core, WL1273_POWER_SET, val);
+			r = core->write(core, WL1273_POWER_SET, val);
 			if (r) {
 				dev_err(dev, "%s: POWER_SET fails\n", __func__);
 				goto fail;
@@ -742,11 +601,10 @@ static int wl1273_fm_start(struct wl1273_device *radio, int new_mode)
 
 	} else if (new_mode == WL1273_MODE_TX) {
 		/* If this fails try again once */
-		r = wl1273_fm_write_cmd(core, WL1273_PUPD_SET,
-					WL1273_PUPD_SET_ON);
+		r = core->write(core, WL1273_PUPD_SET, WL1273_PUPD_SET_ON);
 		if (r) {
 			msleep(100);
-			r = wl1273_fm_write_cmd(core, WL1273_PUPD_SET,
+			r = core->write(core, WL1273_PUPD_SET,
 					WL1273_PUPD_SET_ON);
 			if (r) {
 				dev_err(dev, "%s: PUPD_SET fails\n", __func__);
@@ -755,9 +613,9 @@ static int wl1273_fm_start(struct wl1273_device *radio, int new_mode)
 		}
 
 		if (radio->rds_on)
-			r = wl1273_fm_write_cmd(core, WL1273_RDS_DATA_ENB, 1);
+			r = core->write(core, WL1273_RDS_DATA_ENB, 1);
 		else
-			r = wl1273_fm_write_cmd(core, WL1273_RDS_DATA_ENB, 0);
+			r = core->write(core, WL1273_RDS_DATA_ENB, 0);
 	} else {
 		dev_warn(dev, "%s: Illegal mode.\n", __func__);
 	}
@@ -777,14 +635,14 @@ static int wl1273_fm_start(struct wl1273_device *radio, int new_mode)
 			if (radio->rds_on)
 				val |= WL1273_POWER_SET_RDS;
 
-			r = wl1273_fm_write_cmd(core, WL1273_POWER_SET, val);
+			r = core->write(core, WL1273_POWER_SET, val);
 			if (r) {
 				dev_err(dev, "%s: POWER_SET fails\n", __func__);
 				goto fail;
 			}
 		} else if (new_mode == WL1273_MODE_TX) {
-			r = wl1273_fm_write_cmd(core, WL1273_PUPD_SET,
-						WL1273_PUPD_SET_ON);
+			r = core->write(core, WL1273_PUPD_SET,
+					WL1273_PUPD_SET_ON);
 			if (r) {
 				dev_err(dev, "%s: PUPD_SET fails\n", __func__);
 				goto fail;
@@ -808,10 +666,10 @@ static int wl1273_fm_suspend(struct wl1273_device *radio)
 
 	/* Cannot go from OFF to SUSPENDED */
 	if (core->mode == WL1273_MODE_RX)
-		r = wl1273_fm_write_cmd(core, WL1273_POWER_SET,
+		r = core->write(core, WL1273_POWER_SET,
 				WL1273_POWER_SET_RETENTION);
 	else if (core->mode == WL1273_MODE_TX)
-		r = wl1273_fm_write_cmd(core, WL1273_PUPD_SET,
+		r = core->write(core, WL1273_PUPD_SET,
 				WL1273_PUPD_SET_RETENTION);
 	else
 		r = -EINVAL;
@@ -852,8 +710,7 @@ static int wl1273_fm_set_mode(struct wl1273_device *radio, int mode)
 		}
 
 		core->mode = mode;
-		r = wl1273_fm_write_cmd(core, WL1273_INT_MASK_SET,
-					radio->irq_flags);
+		r = core->write(core, WL1273_INT_MASK_SET, radio->irq_flags);
 		if (r) {
 			dev_err(dev, "INT_MASK_SET fails.\n");
 			goto out;
@@ -951,22 +808,21 @@ static int wl1273_fm_set_seek(struct wl1273_device *radio,
 	INIT_COMPLETION(radio->busy);
 	dev_dbg(radio->dev, "%s: BUSY\n", __func__);
 
-	r = wl1273_fm_write_cmd(core, WL1273_INT_MASK_SET, radio->irq_flags);
+	r = core->write(core, WL1273_INT_MASK_SET, radio->irq_flags);
 	if (r)
 		goto out;
 
 	dev_dbg(radio->dev, "%s\n", __func__);
 
-	r = wl1273_fm_write_cmd(core, WL1273_SEARCH_LVL_SET, level);
+	r = core->write(core, WL1273_SEARCH_LVL_SET, level);
 	if (r)
 		goto out;
 
-	r = wl1273_fm_write_cmd(core, WL1273_SEARCH_DIR_SET, dir);
+	r = core->write(core, WL1273_SEARCH_DIR_SET, dir);
 	if (r)
 		goto out;
 
-	r = wl1273_fm_write_cmd(core, WL1273_TUNER_MODE_SET,
-				TUNER_MODE_AUTO_SEEK);
+	r = core->write(core, WL1273_TUNER_MODE_SET, TUNER_MODE_AUTO_SEEK);
 	if (r)
 		goto out;
 
@@ -994,8 +850,7 @@ static int wl1273_fm_set_seek(struct wl1273_device *radio,
 	INIT_COMPLETION(radio->busy);
 	dev_dbg(radio->dev, "%s: BUSY\n", __func__);
 
-	r = wl1273_fm_write_cmd(core, WL1273_TUNER_MODE_SET,
-				TUNER_MODE_AUTO_SEEK);
+	r = core->write(core, WL1273_TUNER_MODE_SET, TUNER_MODE_AUTO_SEEK);
 	if (r)
 		goto out;
 
@@ -1020,7 +875,7 @@ static unsigned int wl1273_fm_get_tx_ctune(struct wl1273_device *radio)
 	    core->mode == WL1273_MODE_SUSPENDED)
 		return -EPERM;
 
-	r = wl1273_fm_read_reg(core, WL1273_READ_FMANT_TUNE_VALUE, &val);
+	r = core->read(core, WL1273_READ_FMANT_TUNE_VALUE, &val);
 	if (r) {
 		dev_err(dev, "%s: read error: %d\n", __func__, r);
 		goto out;
@@ -1066,7 +921,7 @@ static int wl1273_fm_set_preemphasis(struct wl1273_device *radio,
 		goto out;
 	}
 
-	r = wl1273_fm_write_cmd(core, WL1273_PREMPH_SET, em);
+	r = core->write(core, WL1273_PREMPH_SET, em);
 	if (r)
 		goto out;
 
@@ -1086,7 +941,7 @@ static int wl1273_fm_rds_on(struct wl1273_device *radio)
 	if (radio->rds_on)
 		return 0;
 
-	r = wl1273_fm_write_cmd(core, WL1273_POWER_SET,
+	r = core->write(core, WL1273_POWER_SET,
 			WL1273_POWER_SET_FM | WL1273_POWER_SET_RDS);
 	if (r)
 		goto out;
@@ -1108,7 +963,7 @@ static int wl1273_fm_rds_off(struct wl1273_device *radio)
 
 	radio->irq_flags &= ~WL1273_RDS_EVENT;
 
-	r = wl1273_fm_write_cmd(core, WL1273_INT_MASK_SET, radio->irq_flags);
+	r = core->write(core, WL1273_INT_MASK_SET, radio->irq_flags);
 	if (r)
 		goto out;
 
@@ -1120,7 +975,7 @@ static int wl1273_fm_rds_off(struct wl1273_device *radio)
 
 	dev_dbg(radio->dev, "%s\n", __func__);
 
-	r = wl1273_fm_write_cmd(core, WL1273_POWER_SET, WL1273_POWER_SET_FM);
+	r = core->write(core, WL1273_POWER_SET, WL1273_POWER_SET_FM);
 	if (r)
 		goto out;
 
@@ -1143,14 +998,14 @@ static int wl1273_fm_set_rds(struct wl1273_device *radio, unsigned int new_mode)
 		return -EPERM;
 
 	if (new_mode == WL1273_RDS_RESET) {
-		r = wl1273_fm_write_cmd(core, WL1273_RDS_CNTRL_SET, 1);
+		r = core->write(core, WL1273_RDS_CNTRL_SET, 1);
 		return r;
 	}
 
 	if (core->mode == WL1273_MODE_TX && new_mode == WL1273_RDS_OFF) {
-		r = wl1273_fm_write_cmd(core, WL1273_RDS_DATA_ENB, 0);
+		r = core->write(core, WL1273_RDS_DATA_ENB, 0);
 	} else if (core->mode == WL1273_MODE_TX && new_mode == WL1273_RDS_ON) {
-		r = wl1273_fm_write_cmd(core, WL1273_RDS_DATA_ENB, 1);
+		r = core->write(core, WL1273_RDS_DATA_ENB, 1);
 	} else if (core->mode == WL1273_MODE_RX && new_mode == WL1273_RDS_OFF) {
 		r = wl1273_fm_rds_off(radio);
 	} else if (core->mode == WL1273_MODE_RX && new_mode == WL1273_RDS_ON) {
@@ -1171,12 +1026,13 @@ static ssize_t wl1273_fm_fops_write(struct file *file, const char __user *buf,
 				    size_t count, loff_t *ppos)
 {
 	struct wl1273_device *radio = video_get_drvdata(video_devdata(file));
+	struct wl1273_core *core = radio->core;
 	u16 val;
 	int r;
 
 	dev_dbg(radio->dev, "%s\n", __func__);
 
-	if (radio->core->mode != WL1273_MODE_TX)
+	if (core->mode != WL1273_MODE_TX)
 		return count;
 
 	if (radio->rds_users == 0) {
@@ -1184,7 +1040,7 @@ static ssize_t wl1273_fm_fops_write(struct file *file, const char __user *buf,
 		return 0;
 	}
 
-	if (mutex_lock_interruptible(&radio->core->lock))
+	if (mutex_lock_interruptible(&core->lock))
 		return -EINTR;
 	/*
 	 * Multiple processes can open the device, but only
@@ -1202,7 +1058,7 @@ static ssize_t wl1273_fm_fops_write(struct file *file, const char __user *buf,
 	else
 		val = count;
 
-	wl1273_fm_write_cmd(radio->core, WL1273_RDS_CONFIG_DATA_SET, val);
+	core->write(core, WL1273_RDS_CONFIG_DATA_SET, val);
 
 	if (copy_from_user(radio->write_buf + 1, buf, val)) {
 		r = -EFAULT;
@@ -1213,11 +1069,11 @@ static ssize_t wl1273_fm_fops_write(struct file *file, const char __user *buf,
 	dev_dbg(radio->dev, "From user: \"%s\"\n", radio->write_buf);
 
 	radio->write_buf[0] = WL1273_RDS_DATA_SET;
-	wl1273_fm_write_data(radio->core, radio->write_buf, val + 1);
+	core->write_data(core, radio->write_buf, val + 1);
 
 	r = val;
 out:
-	mutex_unlock(&radio->core->lock);
+	mutex_unlock(&core->lock);
 
 	return r;
 }
@@ -1263,8 +1119,8 @@ static int wl1273_fm_fops_open(struct file *file)
 
 		radio->irq_flags |= WL1273_RDS_EVENT;
 
-		r = wl1273_fm_write_cmd(core, WL1273_INT_MASK_SET,
-					radio->irq_flags);
+		r = core->write(core, WL1273_INT_MASK_SET,
+				radio->irq_flags);
 		if (r) {
 			mutex_unlock(&core->lock);
 			goto out;
@@ -1295,9 +1151,9 @@ static int wl1273_fm_fops_release(struct file *file)
 			radio->irq_flags &= ~WL1273_RDS_EVENT;
 
 			if (core->mode == WL1273_MODE_RX) {
-				r = wl1273_fm_write_cmd(core,
-							WL1273_INT_MASK_SET,
-							radio->irq_flags);
+				r = core->write(core,
+						WL1273_INT_MASK_SET,
+						radio->irq_flags);
 				if (r) {
 					mutex_unlock(&core->lock);
 					goto out;
@@ -1324,7 +1180,7 @@ static ssize_t wl1273_fm_fops_read(struct file *file, char __user *buf,
 
 	dev_dbg(radio->dev, "%s\n", __func__);
 
-	if (radio->core->mode != WL1273_MODE_RX)
+	if (core->mode != WL1273_MODE_RX)
 		return 0;
 
 	if (radio->rds_users == 0) {
@@ -1345,7 +1201,7 @@ static ssize_t wl1273_fm_fops_read(struct file *file, char __user *buf,
 	}
 	radio->owner = file;
 
-	r = wl1273_fm_read_reg(core, WL1273_RDS_SYNC_GET, &val);
+	r = core->read(core, WL1273_RDS_SYNC_GET, &val);
 	if (r) {
 		dev_err(radio->dev, "%s: Get RDS_SYNC fails.\n", __func__);
 		goto out;
@@ -1466,23 +1322,24 @@ static int wl1273_fm_vidioc_s_input(struct file *file, void *priv,
  */
 static int wl1273_fm_set_tx_power(struct wl1273_device *radio, u16 power)
 {
+	struct wl1273_core *core = radio->core;
 	int r;
 
-	if (radio->core->mode == WL1273_MODE_OFF ||
-	    radio->core->mode == WL1273_MODE_SUSPENDED)
+	if (core->mode == WL1273_MODE_OFF ||
+	    core->mode == WL1273_MODE_SUSPENDED)
 		return -EPERM;
 
-	mutex_lock(&radio->core->lock);
+	mutex_lock(&core->lock);
 
 	/* Convert the dBuV value to chip presentation */
-	r = wl1273_fm_write_cmd(radio->core, WL1273_POWER_LEV_SET, 122 - power);
+	r = core->write(core, WL1273_POWER_LEV_SET, 122 - power);
 	if (r)
 		goto out;
 
 	radio->tx_power = power;
 
 out:
-	mutex_unlock(&radio->core->lock);
+	mutex_unlock(&core->lock);
 	return r;
 }
 
@@ -1493,23 +1350,24 @@ static int wl1273_fm_set_tx_power(struct wl1273_device *radio, u16 power)
 static int wl1273_fm_tx_set_spacing(struct wl1273_device *radio,
 				    unsigned int spacing)
 {
+	struct wl1273_core *core = radio->core;
 	int r;
 
 	if (spacing == 0) {
-		r = wl1273_fm_write_cmd(radio->core, WL1273_SCAN_SPACING_SET,
-					WL1273_SPACING_100kHz);
+		r = core->write(core, WL1273_SCAN_SPACING_SET,
+				WL1273_SPACING_100kHz);
 		radio->spacing = 100;
 	} else if (spacing - 50000 < 25000) {
-		r = wl1273_fm_write_cmd(radio->core, WL1273_SCAN_SPACING_SET,
-					WL1273_SPACING_50kHz);
+		r = core->write(core, WL1273_SCAN_SPACING_SET,
+				WL1273_SPACING_50kHz);
 		radio->spacing = 50;
 	} else if (spacing - 100000 < 50000) {
-		r = wl1273_fm_write_cmd(radio->core, WL1273_SCAN_SPACING_SET,
-					WL1273_SPACING_100kHz);
+		r = core->write(core, WL1273_SCAN_SPACING_SET,
+				WL1273_SPACING_100kHz);
 		radio->spacing = 100;
 	} else {
-		r = wl1273_fm_write_cmd(radio->core, WL1273_SCAN_SPACING_SET,
-					WL1273_SPACING_200kHz);
+		r = core->write(core, WL1273_SCAN_SPACING_SET,
+				WL1273_SPACING_200kHz);
 		radio->spacing = 200;
 	}
 
@@ -1567,17 +1425,17 @@ static int wl1273_fm_vidioc_s_ctrl(struct v4l2_ctrl *ctrl)
 			return -EINTR;
 
 		if (core->mode == WL1273_MODE_RX && ctrl->val)
-			r = wl1273_fm_write_cmd(core,
-						WL1273_MUTE_STATUS_SET,
-						WL1273_MUTE_HARD_LEFT |
-						WL1273_MUTE_HARD_RIGHT);
+			r = core->write(core,
+					WL1273_MUTE_STATUS_SET,
+					WL1273_MUTE_HARD_LEFT |
+					WL1273_MUTE_HARD_RIGHT);
 		else if (core->mode == WL1273_MODE_RX)
-			r = wl1273_fm_write_cmd(core,
-						WL1273_MUTE_STATUS_SET, 0x0);
+			r = core->write(core,
+					WL1273_MUTE_STATUS_SET, 0x0);
 		else if (core->mode == WL1273_MODE_TX && ctrl->val)
-			r = wl1273_fm_write_cmd(core, WL1273_MUTE, 1);
+			r = core->write(core, WL1273_MUTE, 1);
 		else if (core->mode == WL1273_MODE_TX)
-			r = wl1273_fm_write_cmd(core, WL1273_MUTE, 0);
+			r = core->write(core, WL1273_MUTE, 0);
 
 		mutex_unlock(&core->lock);
 		break;
@@ -1672,7 +1530,7 @@ static int wl1273_fm_vidioc_g_tuner(struct file *file, void *priv,
 	if (mutex_lock_interruptible(&core->lock))
 		return -EINTR;
 
-	r = wl1273_fm_read_reg(core, WL1273_STEREO_GET, &val);
+	r = core->read(core, WL1273_STEREO_GET, &val);
 	if (r)
 		goto out;
 
@@ -1681,7 +1539,7 @@ static int wl1273_fm_vidioc_g_tuner(struct file *file, void *priv,
 	else
 		tuner->rxsubchans = V4L2_TUNER_SUB_MONO;
 
-	r = wl1273_fm_read_reg(core, WL1273_RSSI_LVL_GET, &val);
+	r = core->read(core, WL1273_RSSI_LVL_GET, &val);
 	if (r)
 		goto out;
 
@@ -1690,7 +1548,7 @@ static int wl1273_fm_vidioc_g_tuner(struct file *file, void *priv,
 
 	tuner->afc = 0;
 
-	r = wl1273_fm_read_reg(core, WL1273_RDS_SYNC_GET, &val);
+	r = core->read(core, WL1273_RDS_SYNC_GET, &val);
 	if (r)
 		goto out;
 
@@ -1736,8 +1594,7 @@ static int wl1273_fm_vidioc_s_tuner(struct file *file, void *priv,
 		dev_warn(radio->dev, "%s: RDS fails: %d\n", __func__, r);
 
 	if (tuner->audmode == V4L2_TUNER_MODE_MONO) {
-		r = wl1273_fm_write_cmd(core, WL1273_MOST_MODE_SET,
-					WL1273_RX_MONO);
+		r = core->write(core, WL1273_MOST_MODE_SET, WL1273_RX_MONO);
 		if (r < 0) {
 			dev_warn(radio->dev, "%s: MOST_MODE fails: %d\n",
 				 __func__, r);
@@ -1745,8 +1602,7 @@ static int wl1273_fm_vidioc_s_tuner(struct file *file, void *priv,
 		}
 		radio->stereo = false;
 	} else if (tuner->audmode == V4L2_TUNER_MODE_STEREO) {
-		r = wl1273_fm_write_cmd(core, WL1273_MOST_MODE_SET,
-					WL1273_RX_STEREO);
+		r = core->write(core, WL1273_MOST_MODE_SET, WL1273_RX_STEREO);
 		if (r < 0) {
 			dev_warn(radio->dev, "%s: MOST_MODE fails: %d\n",
 				 __func__, r);
@@ -1885,10 +1741,10 @@ static int wl1273_fm_vidioc_s_modulator(struct file *file, void *priv,
 		r = wl1273_fm_set_rds(radio, WL1273_RDS_OFF);
 
 	if (modulator->txsubchans & V4L2_TUNER_SUB_MONO)
-		r = wl1273_fm_write_cmd(core, WL1273_MONO_SET, WL1273_TX_MONO);
+		r = core->write(core, WL1273_MONO_SET, WL1273_TX_MONO);
 	else
-		r = wl1273_fm_write_cmd(core, WL1273_MONO_SET,
-					WL1273_RX_STEREO);
+		r = core->write(core, WL1273_MONO_SET,
+				WL1273_RX_STEREO);
 	if (r < 0)
 		dev_warn(radio->dev, WL1273_FM_DRIVER_NAME
 			 "MONO_SET fails: %d\n", r);
@@ -1923,7 +1779,7 @@ static int wl1273_fm_vidioc_g_modulator(struct file *file, void *priv,
 	if (mutex_lock_interruptible(&core->lock))
 		return -EINTR;
 
-	r = wl1273_fm_read_reg(core, WL1273_MONO_SET, &val);
+	r = core->read(core, WL1273_MONO_SET, &val);
 	if (r)
 		goto out;
 
@@ -1960,38 +1816,38 @@ static int wl1273_fm_vidioc_log_status(struct file *file, void *priv)
 		return 0;
 	}
 
-	r = wl1273_fm_read_reg(core, WL1273_ASIC_ID_GET, &val);
+	r = core->read(core, WL1273_ASIC_ID_GET, &val);
 	if (r)
 		dev_err(dev, "%s: Get ASIC_ID fails.\n", __func__);
 	else
 		dev_info(dev, "ASIC_ID: 0x%04x\n", val);
 
-	r = wl1273_fm_read_reg(core, WL1273_ASIC_VER_GET, &val);
+	r = core->read(core, WL1273_ASIC_VER_GET, &val);
 	if (r)
 		dev_err(dev, "%s: Get ASIC_VER fails.\n", __func__);
 	else
 		dev_info(dev, "ASIC Version: 0x%04x\n", val);
 
-	r = wl1273_fm_read_reg(core, WL1273_FIRM_VER_GET, &val);
+	r = core->read(core, WL1273_FIRM_VER_GET, &val);
 	if (r)
 		dev_err(dev, "%s: Get FIRM_VER fails.\n", __func__);
 	else
 		dev_info(dev, "FW version: %d(0x%04x)\n", val, val);
 
-	r = wl1273_fm_read_reg(core, WL1273_BAND_SET, &val);
+	r = core->read(core, WL1273_BAND_SET, &val);
 	if (r)
 		dev_err(dev, "%s: Get BAND fails.\n", __func__);
 	else
 		dev_info(dev, "BAND: %d\n", val);
 
 	if (core->mode == WL1273_MODE_TX) {
-		r = wl1273_fm_read_reg(core, WL1273_PUPD_SET, &val);
+		r = core->read(core, WL1273_PUPD_SET, &val);
 		if (r)
 			dev_err(dev, "%s: Get PUPD fails.\n", __func__);
 		else
 			dev_info(dev, "PUPD: 0x%04x\n", val);
 
-		r = wl1273_fm_read_reg(core, WL1273_CHANL_SET, &val);
+		r = core->read(core, WL1273_CHANL_SET, &val);
 		if (r)
 			dev_err(dev, "%s: Get CHANL fails.\n", __func__);
 		else
@@ -1999,13 +1855,13 @@ static int wl1273_fm_vidioc_log_status(struct file *file, void *priv)
 	} else if (core->mode == WL1273_MODE_RX) {
 		int bf = radio->rangelow;
 
-		r = wl1273_fm_read_reg(core, WL1273_FREQ_SET, &val);
+		r = core->read(core, WL1273_FREQ_SET, &val);
 		if (r)
 			dev_err(dev, "%s: Get FREQ fails.\n", __func__);
 		else
 			dev_info(dev, "RX Frequency: %dkHz\n", bf + val*50);
 
-		r = wl1273_fm_read_reg(core, WL1273_MOST_MODE_SET, &val);
+		r = core->read(core, WL1273_MOST_MODE_SET, &val);
 		if (r)
 			dev_err(dev, "%s: Get MOST_MODE fails.\n",
 				__func__);
@@ -2016,7 +1872,7 @@ static int wl1273_fm_vidioc_log_status(struct file *file, void *priv)
 		else
 			dev_info(dev, "MOST_MODE: Unexpected value: %d\n", val);
 
-		r = wl1273_fm_read_reg(core, WL1273_MOST_BLEND_SET, &val);
+		r = core->read(core, WL1273_MOST_BLEND_SET, &val);
 		if (r)
 			dev_err(dev, "%s: Get MOST_BLEND fails.\n", __func__);
 		else if (val == 0)
@@ -2027,7 +1883,7 @@ static int wl1273_fm_vidioc_log_status(struct file *file, void *priv)
 		else
 			dev_info(dev, "MOST_BLEND: Unexpected val: %d\n", val);
 
-		r = wl1273_fm_read_reg(core, WL1273_STEREO_GET, &val);
+		r = core->read(core, WL1273_STEREO_GET, &val);
 		if (r)
 			dev_err(dev, "%s: Get STEREO fails.\n", __func__);
 		else if (val == 0)
@@ -2037,25 +1893,25 @@ static int wl1273_fm_vidioc_log_status(struct file *file, void *priv)
 		else
 			dev_info(dev, "STEREO: Unexpected value: %d\n", val);
 
-		r = wl1273_fm_read_reg(core, WL1273_RSSI_LVL_GET, &val);
+		r = core->read(core, WL1273_RSSI_LVL_GET, &val);
 		if (r)
 			dev_err(dev, "%s: Get RSSI_LVL fails.\n", __func__);
 		else
 			dev_info(dev, "RX signal strength: %d\n", (s16) val);
 
-		r = wl1273_fm_read_reg(core, WL1273_POWER_SET, &val);
+		r = core->read(core, WL1273_POWER_SET, &val);
 		if (r)
 			dev_err(dev, "%s: Get POWER fails.\n", __func__);
 		else
 			dev_info(dev, "POWER: 0x%04x\n", val);
 
-		r = wl1273_fm_read_reg(core, WL1273_INT_MASK_SET, &val);
+		r = core->read(core, WL1273_INT_MASK_SET, &val);
 		if (r)
 			dev_err(dev, "%s: Get INT_MASK fails.\n", __func__);
 		else
 			dev_info(dev, "INT_MASK: 0x%04x\n", val);
 
-		r = wl1273_fm_read_reg(core, WL1273_RDS_SYNC_GET, &val);
+		r = core->read(core, WL1273_RDS_SYNC_GET, &val);
 		if (r)
 			dev_err(dev, "%s: Get RDS_SYNC fails.\n",
 				__func__);
@@ -2067,14 +1923,14 @@ static int wl1273_fm_vidioc_log_status(struct file *file, void *priv)
 		else
 			dev_info(dev, "RDS_SYNC: Unexpected value: %d\n", val);
 
-		r = wl1273_fm_read_reg(core, WL1273_I2S_MODE_CONFIG_SET, &val);
+		r = core->read(core, WL1273_I2S_MODE_CONFIG_SET, &val);
 		if (r)
 			dev_err(dev, "%s: Get I2S_MODE_CONFIG fails.\n",
 				__func__);
 		else
 			dev_info(dev, "I2S_MODE_CONFIG: 0x%04x\n", val);
 
-		r = wl1273_fm_read_reg(core, WL1273_VOLUME_SET, &val);
+		r = core->read(core, WL1273_VOLUME_SET, &val);
 		if (r)
 			dev_err(dev, "%s: Get VOLUME fails.\n", __func__);
 		else
@@ -2184,10 +2040,6 @@ static int __devinit wl1273_fm_radio_probe(struct platform_device *pdev)
 	radio->stereo = true;
 	radio->bus_type = "I2C";
 
-	radio->core->write = wl1273_fm_write_cmd;
-	radio->core->set_audio = wl1273_fm_set_audio;
-	radio->core->set_volume = wl1273_fm_set_volume;
-
 	if (radio->core->pdata->request_resources) {
 		r = radio->core->pdata->request_resources(radio->core->client);
 		if (r) {

commit 34b8fc8e683cbcbbe47806260ef5dc505915b45f
Author: Matti Aaltonen <matti.j.aaltonen@nokia.com>
Date:   Tue Jan 4 08:29:37 2011 -0300

    [media] V4L2: WL1273 FM Radio: Replace ioctl with unlocked_ioctl
    
    Use unlocked_ioctl in v4l2_file_operations. The locking is
    already in place.
    
    Signed-off-by: Matti J. Aaltonen <matti.j.aaltonen@nokia.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-wl1273.c b/drivers/media/radio/radio-wl1273.c
index dd6bd364efa0..7ecc8e657663 100644
--- a/drivers/media/radio/radio-wl1273.c
+++ b/drivers/media/radio/radio-wl1273.c
@@ -1407,7 +1407,7 @@ static const struct v4l2_file_operations wl1273_fops = {
 	.read		= wl1273_fm_fops_read,
 	.write		= wl1273_fm_fops_write,
 	.poll		= wl1273_fm_fops_poll,
-	.ioctl		= video_ioctl2,
+	.unlocked_ioctl	= video_ioctl2,
 	.open		= wl1273_fm_fops_open,
 	.release	= wl1273_fm_fops_release,
 };

commit fce50ac80e38b1d205939ff7d4777536701263a6
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Mon Dec 27 11:44:50 2010 -0300

    [media] radio-wl1273: Fix two warnings
    
    drivers/media/radio/radio-wl1273.c: In function ‘wl1273_fm_upload_firmware_patch’:
    drivers/media/radio/radio-wl1273.c:675:2: warning: ‘n’ may be used uninitialized in this function
    drivers/media/radio/radio-wl1273.c:675:2: warning: ‘i’ may be used uninitialized in this function
    
    Those vars are never initialized, and the debug message makes no sense, as it
    will show just two random values.
    
    Cc: Matti J. Aaltonen <matti.j.aaltonen@nokia.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-wl1273.c b/drivers/media/radio/radio-wl1273.c
index 1813790b8e9b..dd6bd364efa0 100644
--- a/drivers/media/radio/radio-wl1273.c
+++ b/drivers/media/radio/radio-wl1273.c
@@ -645,7 +645,7 @@ static int wl1273_fm_upload_firmware_patch(struct wl1273_device *radio)
 	const char *fw_name = "radio-wl1273-fw.bin";
 	struct device *dev = radio->dev;
 	__u8 *ptr;
-	int i, n, r;
+	int r;
 
 	dev_dbg(dev, "%s:\n", __func__);
 
@@ -672,7 +672,6 @@ static int wl1273_fm_upload_firmware_patch(struct wl1273_device *radio)
 	/* ignore possible error here */
 	wl1273_fm_write_cmd(core, WL1273_RESET, 0);
 
-	dev_dbg(dev, "n: %d, i: %d\n", n, i);
 	dev_dbg(dev, "%s - download OK, r: %d\n", __func__, r);
 out:
 	release_firmware(fw_p);

commit 87d1a50ce45168cbaec10397e876286a398052c1
Author: Matti Aaltonen <matti.j.aaltonen@nokia.com>
Date:   Fri Dec 10 11:41:34 2010 -0300

    [media] V4L2: WL1273 FM Radio: TI WL1273 FM radio driver
    
    This module implements V4L2 controls for the Texas Instruments
    WL1273 FM Radio and handles the communication with the chip.
    
    Signed-off-by: Matti J. Aaltonen <matti.j.aaltonen@nokia.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-wl1273.c b/drivers/media/radio/radio-wl1273.c
new file mode 100644
index 000000000000..1813790b8e9b
--- /dev/null
+++ b/drivers/media/radio/radio-wl1273.c
@@ -0,0 +1,2331 @@
+/*
+ * Driver for the Texas Instruments WL1273 FM radio.
+ *
+ * Copyright (C) 2010 Nokia Corporation
+ * Author: Matti J. Aaltonen <matti.j.aaltonen@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include <linux/delay.h>
+#include <linux/firmware.h>
+#include <linux/interrupt.h>
+#include <linux/mfd/wl1273-core.h>
+#include <linux/slab.h>
+#include <media/v4l2-common.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-ioctl.h>
+
+#define DRIVER_DESC "Wl1273 FM Radio"
+
+#define WL1273_POWER_SET_OFF		0
+#define WL1273_POWER_SET_FM		BIT(0)
+#define WL1273_POWER_SET_RDS		BIT(1)
+#define WL1273_POWER_SET_RETENTION	BIT(4)
+
+#define WL1273_PUPD_SET_OFF		0x00
+#define WL1273_PUPD_SET_ON		0x01
+#define WL1273_PUPD_SET_RETENTION	0x10
+
+#define WL1273_FREQ(x)		(x * 10000 / 625)
+#define WL1273_INV_FREQ(x)	(x * 625 / 10000)
+
+/*
+ * static int radio_nr - The number of the radio device
+ *
+ * The default is 0.
+ */
+static int radio_nr;
+module_param(radio_nr, int, 0);
+MODULE_PARM_DESC(radio_nr, "The number of the radio device. Default = 0");
+
+struct wl1273_device {
+	char *bus_type;
+
+	u8 forbidden;
+	unsigned int preemphasis;
+	unsigned int spacing;
+	unsigned int tx_power;
+	unsigned int rx_frequency;
+	unsigned int tx_frequency;
+	unsigned int rangelow;
+	unsigned int rangehigh;
+	unsigned int band;
+	bool stereo;
+
+	/* RDS */
+	unsigned int rds_on;
+	struct delayed_work work;
+
+	wait_queue_head_t read_queue;
+	struct mutex lock; /* for serializing fm radio operations */
+	struct completion busy;
+
+	unsigned char *buffer;
+	unsigned int buf_size;
+	unsigned int rd_index;
+	unsigned int wr_index;
+
+	/* Selected interrupts */
+	u16 irq_flags;
+	u16 irq_received;
+
+	struct v4l2_ctrl_handler ctrl_handler;
+	struct v4l2_device v4l2dev;
+	struct video_device videodev;
+	struct device *dev;
+	struct wl1273_core *core;
+	struct file *owner;
+	char *write_buf;
+	unsigned int rds_users;
+};
+
+#define WL1273_IRQ_MASK	 (WL1273_FR_EVENT		|	\
+			  WL1273_POW_ENB_EVENT)
+
+/*
+ * static unsigned int rds_buf - the number of RDS buffer blocks used.
+ *
+ * The default number is 100.
+ */
+static unsigned int rds_buf = 100;
+module_param(rds_buf, uint, 0);
+MODULE_PARM_DESC(rds_buf, "Number of RDS buffer entries. Default = 100");
+
+static int wl1273_fm_read_reg(struct wl1273_core *core, u8 reg, u16 *value)
+{
+	struct i2c_client *client = core->client;
+	u8 b[2];
+	int r;
+
+	r = i2c_smbus_read_i2c_block_data(client, reg, sizeof(b), b);
+	if (r != 2) {
+		dev_err(&client->dev, "%s: Read: %d fails.\n", __func__, reg);
+		return -EREMOTEIO;
+	}
+
+	*value = (u16)b[0] << 8 | b[1];
+
+	return 0;
+}
+
+static int wl1273_fm_write_cmd(struct wl1273_core *core, u8 cmd, u16 param)
+{
+	struct i2c_client *client = core->client;
+	u8 buf[] = { (param >> 8) & 0xff, param & 0xff };
+	int r;
+
+	r = i2c_smbus_write_i2c_block_data(client, cmd, sizeof(buf), buf);
+	if (r) {
+		dev_err(&client->dev, "%s: Cmd: %d fails.\n", __func__, cmd);
+		return r;
+	}
+
+	return 0;
+}
+
+static int wl1273_fm_write_data(struct wl1273_core *core, u8 *data, u16 len)
+{
+	struct i2c_client *client = core->client;
+	struct i2c_msg msg;
+	int r;
+
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.buf = data;
+	msg.len = len;
+
+	r = i2c_transfer(client->adapter, &msg, 1);
+	if (r != 1) {
+		dev_err(&client->dev, "%s: write error.\n", __func__);
+		return -EREMOTEIO;
+	}
+
+	return 0;
+}
+
+static int wl1273_fm_write_fw(struct wl1273_core *core,
+			      __u8 *fw, int len)
+{
+	struct i2c_client *client = core->client;
+	struct i2c_msg msg;
+	int i, r = 0;
+
+	msg.addr = client->addr;
+	msg.flags = 0;
+
+	for (i = 0; i <= len; i++) {
+		msg.len = fw[0];
+		msg.buf = fw + 1;
+
+		fw += msg.len + 1;
+		dev_dbg(&client->dev, "%s:len[%d]: %d\n", __func__, i, msg.len);
+
+		r = i2c_transfer(client->adapter, &msg, 1);
+		if (r < 0 && i < len + 1)
+			break;
+	}
+
+	dev_dbg(&client->dev, "%s: i: %d\n", __func__, i);
+	dev_dbg(&client->dev, "%s: len + 1: %d\n", __func__, len + 1);
+
+	/* Last transfer always fails. */
+	if (i == len || r == 1)
+		r = 0;
+
+	return r;
+}
+
+/**
+ * wl1273_fm_set_audio() -	Set audio mode.
+ * @core:			A pointer to the device struct.
+ * @new_mode:			The new audio mode.
+ *
+ * Audio modes are WL1273_AUDIO_DIGITAL and WL1273_AUDIO_ANALOG.
+ */
+static int wl1273_fm_set_audio(struct wl1273_core *core, unsigned int new_mode)
+{
+	int r = 0;
+
+	if (core->mode == WL1273_MODE_OFF ||
+	    core->mode == WL1273_MODE_SUSPENDED)
+		return -EPERM;
+
+	if (core->mode == WL1273_MODE_RX && new_mode == WL1273_AUDIO_DIGITAL) {
+		r = wl1273_fm_write_cmd(core, WL1273_PCM_MODE_SET,
+					WL1273_PCM_DEF_MODE);
+		if (r)
+			goto out;
+
+		r = wl1273_fm_write_cmd(core, WL1273_I2S_MODE_CONFIG_SET,
+					core->i2s_mode);
+		if (r)
+			goto out;
+
+		r = wl1273_fm_write_cmd(core, WL1273_AUDIO_ENABLE,
+					WL1273_AUDIO_ENABLE_I2S);
+		if (r)
+			goto out;
+
+	} else if (core->mode == WL1273_MODE_RX &&
+		   new_mode == WL1273_AUDIO_ANALOG) {
+		r = wl1273_fm_write_cmd(core, WL1273_AUDIO_ENABLE,
+					WL1273_AUDIO_ENABLE_ANALOG);
+		if (r)
+			goto out;
+
+	} else if (core->mode == WL1273_MODE_TX &&
+		   new_mode == WL1273_AUDIO_DIGITAL) {
+		r = wl1273_fm_write_cmd(core, WL1273_I2S_MODE_CONFIG_SET,
+					core->i2s_mode);
+		if (r)
+			goto out;
+
+		r = wl1273_fm_write_cmd(core, WL1273_AUDIO_IO_SET,
+					WL1273_AUDIO_IO_SET_I2S);
+		if (r)
+			goto out;
+
+	} else if (core->mode == WL1273_MODE_TX &&
+		   new_mode == WL1273_AUDIO_ANALOG) {
+		r = wl1273_fm_write_cmd(core, WL1273_AUDIO_IO_SET,
+					WL1273_AUDIO_IO_SET_ANALOG);
+		if (r)
+			goto out;
+	}
+
+	core->audio_mode = new_mode;
+out:
+	return r;
+}
+
+/**
+ * wl1273_fm_set_volume() -	Set volume.
+ * @core:			A pointer to the device struct.
+ * @volume:			The new volume value.
+ */
+static int wl1273_fm_set_volume(struct wl1273_core *core, unsigned int volume)
+{
+	u16 val;
+	int r;
+
+	if (volume > WL1273_MAX_VOLUME)
+		return -EINVAL;
+
+	if (core->volume == volume)
+		return 0;
+
+	val = volume;
+	r = wl1273_fm_read_reg(core, WL1273_VOLUME_SET, &val);
+	if (r)
+		return r;
+
+	core->volume = volume;
+	return 0;
+}
+
+#define WL1273_FIFO_HAS_DATA(status)	(1 << 5 & status)
+#define WL1273_RDS_CORRECTABLE_ERROR	(1 << 3)
+#define WL1273_RDS_UNCORRECTABLE_ERROR	(1 << 4)
+
+static int wl1273_fm_rds(struct wl1273_device *radio)
+{
+	struct wl1273_core *core = radio->core;
+	struct i2c_client *client = core->client;
+	u16 val;
+	u8 b0 = WL1273_RDS_DATA_GET, status;
+	struct v4l2_rds_data rds = { 0, 0, 0 };
+	struct i2c_msg msg[] = {
+		{
+			.addr = client->addr,
+			.flags = 0,
+			.buf = &b0,
+			.len = 1,
+		},
+		{
+			.addr = client->addr,
+			.flags = I2C_M_RD,
+			.buf = (u8 *) &rds,
+			.len = sizeof(rds),
+		}
+	};
+	int r;
+
+	if (core->mode != WL1273_MODE_RX)
+		return 0;
+
+	r = wl1273_fm_read_reg(core, WL1273_RDS_SYNC_GET, &val);
+	if (r)
+		return r;
+
+	if ((val & 0x01) == 0) {
+		/* RDS decoder not synchronized */
+		return -EAGAIN;
+	}
+
+	/* copy all four RDS blocks to internal buffer */
+	do {
+		r = i2c_transfer(client->adapter, msg, ARRAY_SIZE(msg));
+		if (r != ARRAY_SIZE(msg)) {
+			dev_err(radio->dev, WL1273_FM_DRIVER_NAME
+				": %s: read_rds error r == %i)\n",
+				__func__, r);
+		}
+
+		status = rds.block;
+
+		if (!WL1273_FIFO_HAS_DATA(status))
+			break;
+
+		/* copy bits 0-2 (the block ID) to bits 3-5 */
+		rds.block = V4L2_RDS_BLOCK_MSK & status;
+		rds.block |= rds.block << 3;
+
+		/* copy the error bits to standard positions */
+		if (WL1273_RDS_UNCORRECTABLE_ERROR & status) {
+			rds.block |= V4L2_RDS_BLOCK_ERROR;
+			rds.block &= ~V4L2_RDS_BLOCK_CORRECTED;
+		} else if  (WL1273_RDS_CORRECTABLE_ERROR & status) {
+			rds.block &= ~V4L2_RDS_BLOCK_ERROR;
+			rds.block |= V4L2_RDS_BLOCK_CORRECTED;
+		}
+
+		/* copy RDS block to internal buffer */
+		memcpy(&radio->buffer[radio->wr_index], &rds, RDS_BLOCK_SIZE);
+		radio->wr_index += 3;
+
+		/* wrap write pointer */
+		if (radio->wr_index >= radio->buf_size)
+			radio->wr_index = 0;
+
+		/* check for overflow & start over */
+		if (radio->wr_index == radio->rd_index) {
+			dev_dbg(radio->dev, "RDS OVERFLOW");
+
+			radio->rd_index = 0;
+			radio->wr_index = 0;
+			break;
+		}
+	} while (WL1273_FIFO_HAS_DATA(status));
+
+	/* wake up read queue */
+	if (radio->wr_index != radio->rd_index)
+		wake_up_interruptible(&radio->read_queue);
+
+	return 0;
+}
+
+static irqreturn_t wl1273_fm_irq_thread_handler(int irq, void *dev_id)
+{
+	struct wl1273_device *radio = dev_id;
+	struct wl1273_core *core = radio->core;
+	u16 flags;
+	int r;
+
+	r = wl1273_fm_read_reg(core, WL1273_FLAG_GET, &flags);
+	if (r)
+		goto out;
+
+	if (flags & WL1273_BL_EVENT) {
+		radio->irq_received = flags;
+		dev_dbg(radio->dev, "IRQ: BL\n");
+	}
+
+	if (flags & WL1273_RDS_EVENT) {
+		msleep(200);
+
+		wl1273_fm_rds(radio);
+	}
+
+	if (flags & WL1273_BBLK_EVENT)
+		dev_dbg(radio->dev, "IRQ: BBLK\n");
+
+	if (flags & WL1273_LSYNC_EVENT)
+		dev_dbg(radio->dev, "IRQ: LSYNC\n");
+
+	if (flags & WL1273_LEV_EVENT) {
+		u16 level;
+
+		r = wl1273_fm_read_reg(core, WL1273_RSSI_LVL_GET, &level);
+		if (r)
+			goto out;
+
+		if (level > 14)
+			dev_dbg(radio->dev, "IRQ: LEV: 0x%x04\n", level);
+	}
+
+	if (flags & WL1273_IFFR_EVENT)
+		dev_dbg(radio->dev, "IRQ: IFFR\n");
+
+	if (flags & WL1273_PI_EVENT)
+		dev_dbg(radio->dev, "IRQ: PI\n");
+
+	if (flags & WL1273_PD_EVENT)
+		dev_dbg(radio->dev, "IRQ: PD\n");
+
+	if (flags & WL1273_STIC_EVENT)
+		dev_dbg(radio->dev, "IRQ: STIC\n");
+
+	if (flags & WL1273_MAL_EVENT)
+		dev_dbg(radio->dev, "IRQ: MAL\n");
+
+	if (flags & WL1273_POW_ENB_EVENT) {
+		complete(&radio->busy);
+		dev_dbg(radio->dev, "NOT BUSY\n");
+		dev_dbg(radio->dev, "IRQ: POW_ENB\n");
+	}
+
+	if (flags & WL1273_SCAN_OVER_EVENT)
+		dev_dbg(radio->dev, "IRQ: SCAN_OVER\n");
+
+	if (flags & WL1273_ERROR_EVENT)
+		dev_dbg(radio->dev, "IRQ: ERROR\n");
+
+	if (flags & WL1273_FR_EVENT) {
+		u16 freq;
+
+		dev_dbg(radio->dev, "IRQ: FR:\n");
+
+		if (core->mode == WL1273_MODE_RX) {
+			r = wl1273_fm_write_cmd(core, WL1273_TUNER_MODE_SET,
+						TUNER_MODE_STOP_SEARCH);
+			if (r) {
+				dev_err(radio->dev,
+					"%s: TUNER_MODE_SET fails: %d\n",
+					__func__, r);
+				goto out;
+			}
+
+			r = wl1273_fm_read_reg(core, WL1273_FREQ_SET, &freq);
+			if (r)
+				goto out;
+
+			if (radio->band == WL1273_BAND_JAPAN)
+				radio->rx_frequency = WL1273_BAND_JAPAN_LOW +
+					freq * 50;
+			else
+				radio->rx_frequency = WL1273_BAND_OTHER_LOW +
+					freq * 50;
+			/*
+			 *  The driver works better with this msleep,
+			 *  the documentation doesn't mention it.
+			 */
+			usleep_range(10000, 15000);
+
+			dev_dbg(radio->dev, "%dkHz\n", radio->rx_frequency);
+
+		} else {
+			r = wl1273_fm_read_reg(core, WL1273_CHANL_SET, &freq);
+			if (r)
+				goto out;
+
+			dev_dbg(radio->dev, "%dkHz\n", freq);
+		}
+		dev_dbg(radio->dev, "%s: NOT BUSY\n", __func__);
+	}
+
+out:
+	wl1273_fm_write_cmd(core, WL1273_INT_MASK_SET,
+			    radio->irq_flags);
+	complete(&radio->busy);
+
+	return IRQ_HANDLED;
+}
+
+static int wl1273_fm_set_tx_freq(struct wl1273_device *radio, unsigned int freq)
+{
+	struct wl1273_core *core = radio->core;
+	int r = 0;
+
+	if (freq < WL1273_BAND_TX_LOW) {
+		dev_err(radio->dev,
+			"Frequency out of range: %d < %d\n", freq,
+			WL1273_BAND_TX_LOW);
+		return -ERANGE;
+	}
+
+	if (freq > WL1273_BAND_TX_HIGH) {
+		dev_err(radio->dev,
+			"Frequency out of range: %d > %d\n", freq,
+			WL1273_BAND_TX_HIGH);
+		return -ERANGE;
+	}
+
+	/*
+	 *  The driver works better with this sleep,
+	 *  the documentation doesn't mention it.
+	 */
+	usleep_range(5000, 10000);
+
+	dev_dbg(radio->dev, "%s: freq: %d kHz\n", __func__, freq);
+
+	/* Set the current tx channel */
+	r = wl1273_fm_write_cmd(core, WL1273_CHANL_SET, freq / 10);
+	if (r)
+		return r;
+
+	INIT_COMPLETION(radio->busy);
+
+	/* wait for the FR IRQ */
+	r = wait_for_completion_timeout(&radio->busy, msecs_to_jiffies(2000));
+	if (!r)
+		return -ETIMEDOUT;
+
+	dev_dbg(radio->dev, "WL1273_CHANL_SET: %d\n", r);
+
+	/* Enable the output power */
+	r = wl1273_fm_write_cmd(core, WL1273_POWER_ENB_SET, 1);
+	if (r)
+		return r;
+
+	INIT_COMPLETION(radio->busy);
+
+	/* wait for the POWER_ENB IRQ */
+	r = wait_for_completion_timeout(&radio->busy, msecs_to_jiffies(1000));
+	if (!r)
+		return -ETIMEDOUT;
+
+	radio->tx_frequency = freq;
+	dev_dbg(radio->dev, "WL1273_POWER_ENB_SET: %d\n", r);
+
+	return	0;
+}
+
+static int wl1273_fm_set_rx_freq(struct wl1273_device *radio, unsigned int freq)
+{
+	struct wl1273_core *core = radio->core;
+	int r, f;
+
+	if (freq < radio->rangelow) {
+		dev_err(radio->dev,
+			"Frequency out of range: %d < %d\n", freq,
+			radio->rangelow);
+		r = -ERANGE;
+		goto err;
+	}
+
+	if (freq > radio->rangehigh) {
+		dev_err(radio->dev,
+			"Frequency out of range: %d > %d\n", freq,
+			radio->rangehigh);
+		r = -ERANGE;
+		goto err;
+	}
+
+	dev_dbg(radio->dev, "%s: %dkHz\n", __func__, freq);
+
+	wl1273_fm_write_cmd(core, WL1273_INT_MASK_SET, radio->irq_flags);
+
+	if (radio->band == WL1273_BAND_JAPAN)
+		f = (freq - WL1273_BAND_JAPAN_LOW) / 50;
+	else
+		f = (freq - WL1273_BAND_OTHER_LOW) / 50;
+
+	r = wl1273_fm_write_cmd(core, WL1273_FREQ_SET, f);
+	if (r) {
+		dev_err(radio->dev, "FREQ_SET fails\n");
+		goto err;
+	}
+
+	r = wl1273_fm_write_cmd(core, WL1273_TUNER_MODE_SET, TUNER_MODE_PRESET);
+	if (r) {
+		dev_err(radio->dev, "TUNER_MODE_SET fails\n");
+		goto err;
+	}
+
+	INIT_COMPLETION(radio->busy);
+
+	r = wait_for_completion_timeout(&radio->busy, msecs_to_jiffies(2000));
+	if (!r) {
+		dev_err(radio->dev, "%s: TIMEOUT\n", __func__);
+		return -ETIMEDOUT;
+	}
+
+	radio->rd_index = 0;
+	radio->wr_index = 0;
+	radio->rx_frequency = freq;
+	return 0;
+err:
+	return r;
+}
+
+static int wl1273_fm_get_freq(struct wl1273_device *radio)
+{
+	struct wl1273_core *core = radio->core;
+	unsigned int freq;
+	u16 f;
+	int r;
+
+	if (core->mode == WL1273_MODE_RX) {
+		r = wl1273_fm_read_reg(core, WL1273_FREQ_SET, &f);
+		if (r)
+			return r;
+
+		dev_dbg(radio->dev, "Freq get: 0x%04x\n", f);
+		if (radio->band == WL1273_BAND_JAPAN)
+			freq = WL1273_BAND_JAPAN_LOW + 50 * f;
+		else
+			freq = WL1273_BAND_OTHER_LOW + 50 * f;
+	} else {
+		r = wl1273_fm_read_reg(core, WL1273_CHANL_SET, &f);
+		if (r)
+			return r;
+
+		freq = f * 10;
+	}
+
+	return freq;
+}
+
+/**
+ * wl1273_fm_upload_firmware_patch() -	Upload the firmware.
+ * @radio:				A pointer to the device struct.
+ *
+ * The firmware file consists of arrays of bytes where the first byte
+ * gives the array length. The first byte in the file gives the
+ * number of these arrays.
+ */
+static int wl1273_fm_upload_firmware_patch(struct wl1273_device *radio)
+{
+	struct wl1273_core *core = radio->core;
+	unsigned int packet_num;
+	const struct firmware *fw_p;
+	const char *fw_name = "radio-wl1273-fw.bin";
+	struct device *dev = radio->dev;
+	__u8 *ptr;
+	int i, n, r;
+
+	dev_dbg(dev, "%s:\n", __func__);
+
+	/*
+	 * Uploading the firmware patch is not always necessary,
+	 * so we only print an info message.
+	 */
+	if (request_firmware(&fw_p, fw_name, dev)) {
+		dev_info(dev, "%s - %s not found\n", __func__, fw_name);
+
+		return 0;
+	}
+
+	ptr = (__u8 *) fw_p->data;
+	packet_num = ptr[0];
+	dev_dbg(dev, "%s: packets: %d\n", __func__, packet_num);
+
+	r = wl1273_fm_write_fw(core, ptr + 1, packet_num);
+	if (r) {
+		dev_err(dev, "FW upload error: %d\n", r);
+		goto out;
+	}
+
+	/* ignore possible error here */
+	wl1273_fm_write_cmd(core, WL1273_RESET, 0);
+
+	dev_dbg(dev, "n: %d, i: %d\n", n, i);
+	dev_dbg(dev, "%s - download OK, r: %d\n", __func__, r);
+out:
+	release_firmware(fw_p);
+	return r;
+}
+
+static int wl1273_fm_stop(struct wl1273_device *radio)
+{
+	struct wl1273_core *core = radio->core;
+
+	if (core->mode == WL1273_MODE_RX) {
+		int r = wl1273_fm_write_cmd(core, WL1273_POWER_SET,
+				    WL1273_POWER_SET_OFF);
+		if (r)
+			dev_err(radio->dev, "%s: POWER_SET fails: %d\n",
+				__func__, r);
+	} else if (core->mode == WL1273_MODE_TX) {
+		int r = wl1273_fm_write_cmd(core, WL1273_PUPD_SET,
+					    WL1273_PUPD_SET_OFF);
+		if (r)
+			dev_err(radio->dev,
+				"%s: PUPD_SET fails: %d\n", __func__, r);
+	}
+
+	if (core->pdata->disable) {
+		core->pdata->disable();
+		dev_dbg(radio->dev, "Back to reset\n");
+	}
+
+	return 0;
+}
+
+static int wl1273_fm_start(struct wl1273_device *radio, int new_mode)
+{
+	struct wl1273_core *core = radio->core;
+	struct wl1273_fm_platform_data *pdata = core->pdata;
+	struct device *dev = radio->dev;
+	int r = -EINVAL;
+
+	if (pdata->enable && core->mode == WL1273_MODE_OFF) {
+		dev_dbg(radio->dev, "Out of reset\n");
+
+		pdata->enable();
+		msleep(250);
+	}
+
+	if (new_mode == WL1273_MODE_RX) {
+		u16 val = WL1273_POWER_SET_FM;
+
+		if (radio->rds_on)
+			val |= WL1273_POWER_SET_RDS;
+
+		/* If this fails try again */
+		r = wl1273_fm_write_cmd(core, WL1273_POWER_SET, val);
+		if (r) {
+			msleep(100);
+
+			r = wl1273_fm_write_cmd(core, WL1273_POWER_SET, val);
+			if (r) {
+				dev_err(dev, "%s: POWER_SET fails\n", __func__);
+				goto fail;
+			}
+		}
+
+		/* rds buffer configuration */
+		radio->wr_index = 0;
+		radio->rd_index = 0;
+
+	} else if (new_mode == WL1273_MODE_TX) {
+		/* If this fails try again once */
+		r = wl1273_fm_write_cmd(core, WL1273_PUPD_SET,
+					WL1273_PUPD_SET_ON);
+		if (r) {
+			msleep(100);
+			r = wl1273_fm_write_cmd(core, WL1273_PUPD_SET,
+					WL1273_PUPD_SET_ON);
+			if (r) {
+				dev_err(dev, "%s: PUPD_SET fails\n", __func__);
+				goto fail;
+			}
+		}
+
+		if (radio->rds_on)
+			r = wl1273_fm_write_cmd(core, WL1273_RDS_DATA_ENB, 1);
+		else
+			r = wl1273_fm_write_cmd(core, WL1273_RDS_DATA_ENB, 0);
+	} else {
+		dev_warn(dev, "%s: Illegal mode.\n", __func__);
+	}
+
+	if (core->mode == WL1273_MODE_OFF) {
+		r = wl1273_fm_upload_firmware_patch(radio);
+		if (r)
+			dev_warn(dev, "Firmware upload failed.\n");
+
+		/*
+		 * Sometimes the chip is in a wrong power state at this point.
+		 * So we set the power once again.
+		 */
+		if (new_mode == WL1273_MODE_RX) {
+			u16 val = WL1273_POWER_SET_FM;
+
+			if (radio->rds_on)
+				val |= WL1273_POWER_SET_RDS;
+
+			r = wl1273_fm_write_cmd(core, WL1273_POWER_SET, val);
+			if (r) {
+				dev_err(dev, "%s: POWER_SET fails\n", __func__);
+				goto fail;
+			}
+		} else if (new_mode == WL1273_MODE_TX) {
+			r = wl1273_fm_write_cmd(core, WL1273_PUPD_SET,
+						WL1273_PUPD_SET_ON);
+			if (r) {
+				dev_err(dev, "%s: PUPD_SET fails\n", __func__);
+				goto fail;
+			}
+		}
+	}
+
+	return 0;
+fail:
+	if (pdata->disable)
+		pdata->disable();
+
+	dev_dbg(dev, "%s: return: %d\n", __func__, r);
+	return r;
+}
+
+static int wl1273_fm_suspend(struct wl1273_device *radio)
+{
+	struct wl1273_core *core = radio->core;
+	int r = 0;
+
+	/* Cannot go from OFF to SUSPENDED */
+	if (core->mode == WL1273_MODE_RX)
+		r = wl1273_fm_write_cmd(core, WL1273_POWER_SET,
+				WL1273_POWER_SET_RETENTION);
+	else if (core->mode == WL1273_MODE_TX)
+		r = wl1273_fm_write_cmd(core, WL1273_PUPD_SET,
+				WL1273_PUPD_SET_RETENTION);
+	else
+		r = -EINVAL;
+
+	if (r) {
+		dev_err(radio->dev, "%s: POWER_SET fails: %d\n", __func__, r);
+		goto out;
+	}
+
+out:
+	return r;
+}
+
+static int wl1273_fm_set_mode(struct wl1273_device *radio, int mode)
+{
+	struct wl1273_core *core = radio->core;
+	struct device *dev = radio->dev;
+	int old_mode;
+	int r;
+
+	dev_dbg(dev, "%s\n", __func__);
+	dev_dbg(dev, "Forbidden modes: 0x%02x\n", radio->forbidden);
+
+	old_mode = core->mode;
+	if (mode & radio->forbidden) {
+		r = -EPERM;
+		goto out;
+	}
+
+	switch (mode) {
+	case WL1273_MODE_RX:
+	case WL1273_MODE_TX:
+		r = wl1273_fm_start(radio, mode);
+		if (r) {
+			dev_err(dev, "%s: Cannot start.\n", __func__);
+			wl1273_fm_stop(radio);
+			goto out;
+		}
+
+		core->mode = mode;
+		r = wl1273_fm_write_cmd(core, WL1273_INT_MASK_SET,
+					radio->irq_flags);
+		if (r) {
+			dev_err(dev, "INT_MASK_SET fails.\n");
+			goto out;
+		}
+
+		/* remember previous settings */
+		if (mode == WL1273_MODE_RX) {
+			r = wl1273_fm_set_rx_freq(radio, radio->rx_frequency);
+			if (r) {
+				dev_err(dev, "set freq fails: %d.\n", r);
+				goto out;
+			}
+
+			r = core->set_volume(core, core->volume);
+			if (r) {
+				dev_err(dev, "set volume fails: %d.\n", r);
+				goto out;
+			}
+
+			dev_dbg(dev, "%s: Set vol: %d.\n", __func__,
+				core->volume);
+		} else {
+			r = wl1273_fm_set_tx_freq(radio, radio->tx_frequency);
+			if (r) {
+				dev_err(dev, "set freq fails: %d.\n", r);
+				goto out;
+			}
+		}
+
+		dev_dbg(radio->dev, "%s: Set audio mode.\n", __func__);
+
+		r = core->set_audio(core, core->audio_mode);
+		if (r)
+			dev_err(dev, "Cannot set audio mode.\n");
+		break;
+
+	case WL1273_MODE_OFF:
+		r = wl1273_fm_stop(radio);
+		if (r)
+			dev_err(dev, "%s: Off fails: %d\n", __func__, r);
+		else
+			core->mode = WL1273_MODE_OFF;
+
+		break;
+
+	case WL1273_MODE_SUSPENDED:
+		r = wl1273_fm_suspend(radio);
+		if (r)
+			dev_err(dev, "%s: Suspend fails: %d\n", __func__, r);
+		else
+			core->mode = WL1273_MODE_SUSPENDED;
+
+		break;
+
+	default:
+		dev_err(dev, "%s: Unknown mode: %d\n", __func__, mode);
+		r = -EINVAL;
+		break;
+	}
+out:
+	if (r)
+		core->mode = old_mode;
+
+	return r;
+}
+
+static int wl1273_fm_set_seek(struct wl1273_device *radio,
+			      unsigned int wrap_around,
+			      unsigned int seek_upward,
+			      int level)
+{
+	struct wl1273_core *core = radio->core;
+	int r = 0;
+	unsigned int dir = (seek_upward == 0) ? 0 : 1;
+	unsigned int f;
+
+	f = radio->rx_frequency;
+	dev_dbg(radio->dev, "rx_frequency: %d\n", f);
+
+	if (dir && f + radio->spacing <= radio->rangehigh)
+		r = wl1273_fm_set_rx_freq(radio, f + radio->spacing);
+	else if (dir && wrap_around)
+		r = wl1273_fm_set_rx_freq(radio, radio->rangelow);
+	else if (f - radio->spacing >= radio->rangelow)
+		r = wl1273_fm_set_rx_freq(radio, f - radio->spacing);
+	else if (wrap_around)
+		r = wl1273_fm_set_rx_freq(radio, radio->rangehigh);
+
+	if (r)
+		goto out;
+
+	if (level < SCHAR_MIN || level > SCHAR_MAX)
+		return -EINVAL;
+
+	INIT_COMPLETION(radio->busy);
+	dev_dbg(radio->dev, "%s: BUSY\n", __func__);
+
+	r = wl1273_fm_write_cmd(core, WL1273_INT_MASK_SET, radio->irq_flags);
+	if (r)
+		goto out;
+
+	dev_dbg(radio->dev, "%s\n", __func__);
+
+	r = wl1273_fm_write_cmd(core, WL1273_SEARCH_LVL_SET, level);
+	if (r)
+		goto out;
+
+	r = wl1273_fm_write_cmd(core, WL1273_SEARCH_DIR_SET, dir);
+	if (r)
+		goto out;
+
+	r = wl1273_fm_write_cmd(core, WL1273_TUNER_MODE_SET,
+				TUNER_MODE_AUTO_SEEK);
+	if (r)
+		goto out;
+
+	wait_for_completion_timeout(&radio->busy, msecs_to_jiffies(1000));
+	if (!(radio->irq_received & WL1273_BL_EVENT))
+		goto out;
+
+	radio->irq_received &= ~WL1273_BL_EVENT;
+
+	if (!wrap_around)
+		goto out;
+
+	/* Wrap around */
+	dev_dbg(radio->dev, "Wrap around in HW seek.\n");
+
+	if (seek_upward)
+		f = radio->rangelow;
+	else
+		f = radio->rangehigh;
+
+	r = wl1273_fm_set_rx_freq(radio, f);
+	if (r)
+		goto out;
+
+	INIT_COMPLETION(radio->busy);
+	dev_dbg(radio->dev, "%s: BUSY\n", __func__);
+
+	r = wl1273_fm_write_cmd(core, WL1273_TUNER_MODE_SET,
+				TUNER_MODE_AUTO_SEEK);
+	if (r)
+		goto out;
+
+	wait_for_completion_timeout(&radio->busy, msecs_to_jiffies(1000));
+out:
+	dev_dbg(radio->dev, "%s: Err: %d\n", __func__, r);
+	return r;
+}
+
+/**
+ * wl1273_fm_get_tx_ctune() -	Get the TX tuning capacitor value.
+ * @radio:			A pointer to the device struct.
+ */
+static unsigned int wl1273_fm_get_tx_ctune(struct wl1273_device *radio)
+{
+	struct wl1273_core *core = radio->core;
+	struct device *dev = radio->dev;
+	u16 val;
+	int r;
+
+	if (core->mode == WL1273_MODE_OFF ||
+	    core->mode == WL1273_MODE_SUSPENDED)
+		return -EPERM;
+
+	r = wl1273_fm_read_reg(core, WL1273_READ_FMANT_TUNE_VALUE, &val);
+	if (r) {
+		dev_err(dev, "%s: read error: %d\n", __func__, r);
+		goto out;
+	}
+
+out:
+	return val;
+}
+
+/**
+ * wl1273_fm_set_preemphasis() - Set the TX pre-emphasis value.
+ * @radio:			 A pointer to the device struct.
+ * @preemphasis:		 The new pre-amphasis value.
+ *
+ * Possible pre-emphasis values are: V4L2_PREEMPHASIS_DISABLED,
+ * V4L2_PREEMPHASIS_50_uS and V4L2_PREEMPHASIS_75_uS.
+ */
+static int wl1273_fm_set_preemphasis(struct wl1273_device *radio,
+				     unsigned int preemphasis)
+{
+	struct wl1273_core *core = radio->core;
+	int r;
+	u16 em;
+
+	if (core->mode == WL1273_MODE_OFF ||
+	    core->mode == WL1273_MODE_SUSPENDED)
+		return -EPERM;
+
+	mutex_lock(&core->lock);
+
+	switch (preemphasis) {
+	case V4L2_PREEMPHASIS_DISABLED:
+		em = 1;
+		break;
+	case V4L2_PREEMPHASIS_50_uS:
+		em = 0;
+		break;
+	case V4L2_PREEMPHASIS_75_uS:
+		em = 2;
+		break;
+	default:
+		r = -EINVAL;
+		goto out;
+	}
+
+	r = wl1273_fm_write_cmd(core, WL1273_PREMPH_SET, em);
+	if (r)
+		goto out;
+
+	radio->preemphasis = preemphasis;
+
+out:
+	mutex_unlock(&core->lock);
+	return r;
+}
+
+static int wl1273_fm_rds_on(struct wl1273_device *radio)
+{
+	struct wl1273_core *core = radio->core;
+	int r;
+
+	dev_dbg(radio->dev, "%s\n", __func__);
+	if (radio->rds_on)
+		return 0;
+
+	r = wl1273_fm_write_cmd(core, WL1273_POWER_SET,
+			WL1273_POWER_SET_FM | WL1273_POWER_SET_RDS);
+	if (r)
+		goto out;
+
+	r = wl1273_fm_set_rx_freq(radio, radio->rx_frequency);
+	if (r)
+		dev_err(radio->dev, "set freq fails: %d.\n", r);
+out:
+	return r;
+}
+
+static int wl1273_fm_rds_off(struct wl1273_device *radio)
+{
+	struct wl1273_core *core = radio->core;
+	int r;
+
+	if (!radio->rds_on)
+		return 0;
+
+	radio->irq_flags &= ~WL1273_RDS_EVENT;
+
+	r = wl1273_fm_write_cmd(core, WL1273_INT_MASK_SET, radio->irq_flags);
+	if (r)
+		goto out;
+
+	/* stop rds reception */
+	cancel_delayed_work(&radio->work);
+
+	/* Service pending read */
+	wake_up_interruptible(&radio->read_queue);
+
+	dev_dbg(radio->dev, "%s\n", __func__);
+
+	r = wl1273_fm_write_cmd(core, WL1273_POWER_SET, WL1273_POWER_SET_FM);
+	if (r)
+		goto out;
+
+	r = wl1273_fm_set_rx_freq(radio, radio->rx_frequency);
+	if (r)
+		dev_err(radio->dev, "set freq fails: %d.\n", r);
+out:
+	dev_dbg(radio->dev, "%s: exiting...\n", __func__);
+
+	return r;
+}
+
+static int wl1273_fm_set_rds(struct wl1273_device *radio, unsigned int new_mode)
+{
+	int r = 0;
+	struct wl1273_core *core = radio->core;
+
+	if (core->mode == WL1273_MODE_OFF ||
+	    core->mode == WL1273_MODE_SUSPENDED)
+		return -EPERM;
+
+	if (new_mode == WL1273_RDS_RESET) {
+		r = wl1273_fm_write_cmd(core, WL1273_RDS_CNTRL_SET, 1);
+		return r;
+	}
+
+	if (core->mode == WL1273_MODE_TX && new_mode == WL1273_RDS_OFF) {
+		r = wl1273_fm_write_cmd(core, WL1273_RDS_DATA_ENB, 0);
+	} else if (core->mode == WL1273_MODE_TX && new_mode == WL1273_RDS_ON) {
+		r = wl1273_fm_write_cmd(core, WL1273_RDS_DATA_ENB, 1);
+	} else if (core->mode == WL1273_MODE_RX && new_mode == WL1273_RDS_OFF) {
+		r = wl1273_fm_rds_off(radio);
+	} else if (core->mode == WL1273_MODE_RX && new_mode == WL1273_RDS_ON) {
+		r = wl1273_fm_rds_on(radio);
+	} else {
+		dev_err(radio->dev, "%s: Unknown mode: %d\n",
+			__func__, new_mode);
+		r = -EINVAL;
+	}
+
+	if (!r)
+		radio->rds_on = (new_mode == WL1273_RDS_ON) ? true : false;
+
+	return r;
+}
+
+static ssize_t wl1273_fm_fops_write(struct file *file, const char __user *buf,
+				    size_t count, loff_t *ppos)
+{
+	struct wl1273_device *radio = video_get_drvdata(video_devdata(file));
+	u16 val;
+	int r;
+
+	dev_dbg(radio->dev, "%s\n", __func__);
+
+	if (radio->core->mode != WL1273_MODE_TX)
+		return count;
+
+	if (radio->rds_users == 0) {
+		dev_warn(radio->dev, "%s: RDS not on.\n", __func__);
+		return 0;
+	}
+
+	if (mutex_lock_interruptible(&radio->core->lock))
+		return -EINTR;
+	/*
+	 * Multiple processes can open the device, but only
+	 * one gets to write to it.
+	 */
+	if (radio->owner && radio->owner != file) {
+		r = -EBUSY;
+		goto out;
+	}
+	radio->owner = file;
+
+	/* Manual Mode */
+	if (count > 255)
+		val = 255;
+	else
+		val = count;
+
+	wl1273_fm_write_cmd(radio->core, WL1273_RDS_CONFIG_DATA_SET, val);
+
+	if (copy_from_user(radio->write_buf + 1, buf, val)) {
+		r = -EFAULT;
+		goto out;
+	}
+
+	dev_dbg(radio->dev, "Count: %d\n", val);
+	dev_dbg(radio->dev, "From user: \"%s\"\n", radio->write_buf);
+
+	radio->write_buf[0] = WL1273_RDS_DATA_SET;
+	wl1273_fm_write_data(radio->core, radio->write_buf, val + 1);
+
+	r = val;
+out:
+	mutex_unlock(&radio->core->lock);
+
+	return r;
+}
+
+static unsigned int wl1273_fm_fops_poll(struct file *file,
+					struct poll_table_struct *pts)
+{
+	struct wl1273_device *radio = video_get_drvdata(video_devdata(file));
+	struct wl1273_core *core = radio->core;
+
+	if (radio->owner && radio->owner != file)
+		return -EBUSY;
+
+	radio->owner = file;
+
+	if (core->mode == WL1273_MODE_RX) {
+		poll_wait(file, &radio->read_queue, pts);
+
+		if (radio->rd_index != radio->wr_index)
+			return POLLIN | POLLRDNORM;
+
+	} else if (core->mode == WL1273_MODE_TX) {
+		return POLLOUT | POLLWRNORM;
+	}
+
+	return 0;
+}
+
+static int wl1273_fm_fops_open(struct file *file)
+{
+	struct wl1273_device *radio = video_get_drvdata(video_devdata(file));
+	struct wl1273_core *core = radio->core;
+	int r = 0;
+
+	dev_dbg(radio->dev, "%s\n", __func__);
+
+	if (core->mode == WL1273_MODE_RX && radio->rds_on &&
+	    !radio->rds_users) {
+		dev_dbg(radio->dev, "%s: Mode: %d\n", __func__, core->mode);
+
+		if (mutex_lock_interruptible(&core->lock))
+			return -EINTR;
+
+		radio->irq_flags |= WL1273_RDS_EVENT;
+
+		r = wl1273_fm_write_cmd(core, WL1273_INT_MASK_SET,
+					radio->irq_flags);
+		if (r) {
+			mutex_unlock(&core->lock);
+			goto out;
+		}
+
+		radio->rds_users++;
+
+		mutex_unlock(&core->lock);
+	}
+out:
+	return r;
+}
+
+static int wl1273_fm_fops_release(struct file *file)
+{
+	struct wl1273_device *radio = video_get_drvdata(video_devdata(file));
+	struct wl1273_core *core = radio->core;
+	int r = 0;
+
+	dev_dbg(radio->dev, "%s\n", __func__);
+
+	if (radio->rds_users > 0) {
+		radio->rds_users--;
+		if (radio->rds_users == 0) {
+			if (mutex_lock_interruptible(&core->lock))
+				return -EINTR;
+
+			radio->irq_flags &= ~WL1273_RDS_EVENT;
+
+			if (core->mode == WL1273_MODE_RX) {
+				r = wl1273_fm_write_cmd(core,
+							WL1273_INT_MASK_SET,
+							radio->irq_flags);
+				if (r) {
+					mutex_unlock(&core->lock);
+					goto out;
+				}
+			}
+			mutex_unlock(&core->lock);
+		}
+	}
+
+	if (file == radio->owner)
+		radio->owner = NULL;
+out:
+	return r;
+}
+
+static ssize_t wl1273_fm_fops_read(struct file *file, char __user *buf,
+				   size_t count, loff_t *ppos)
+{
+	int r = 0;
+	struct wl1273_device *radio = video_get_drvdata(video_devdata(file));
+	struct wl1273_core *core = radio->core;
+	unsigned int block_count = 0;
+	u16 val;
+
+	dev_dbg(radio->dev, "%s\n", __func__);
+
+	if (radio->core->mode != WL1273_MODE_RX)
+		return 0;
+
+	if (radio->rds_users == 0) {
+		dev_warn(radio->dev, "%s: RDS not on.\n", __func__);
+		return 0;
+	}
+
+	if (mutex_lock_interruptible(&core->lock))
+		return -EINTR;
+
+	/*
+	 * Multiple processes can open the device, but only
+	 * one at a time gets read access.
+	 */
+	if (radio->owner && radio->owner != file) {
+		r = -EBUSY;
+		goto out;
+	}
+	radio->owner = file;
+
+	r = wl1273_fm_read_reg(core, WL1273_RDS_SYNC_GET, &val);
+	if (r) {
+		dev_err(radio->dev, "%s: Get RDS_SYNC fails.\n", __func__);
+		goto out;
+	} else if (val == 0) {
+		dev_info(radio->dev, "RDS_SYNC: Not synchronized\n");
+		r = -ENODATA;
+		goto out;
+	}
+
+	/* block if no new data available */
+	while (radio->wr_index == radio->rd_index) {
+		if (file->f_flags & O_NONBLOCK) {
+			r = -EWOULDBLOCK;
+			goto out;
+		}
+
+		dev_dbg(radio->dev, "%s: Wait for RDS data.\n", __func__);
+		if (wait_event_interruptible(radio->read_queue,
+					     radio->wr_index !=
+					     radio->rd_index) < 0) {
+			r = -EINTR;
+			goto out;
+		}
+	}
+
+	/* calculate block count from byte count */
+	count /= RDS_BLOCK_SIZE;
+
+	/* copy RDS blocks from the internal buffer and to user buffer */
+	while (block_count < count) {
+		if (radio->rd_index == radio->wr_index)
+			break;
+
+		/* always transfer complete RDS blocks */
+		if (copy_to_user(buf, &radio->buffer[radio->rd_index],
+				 RDS_BLOCK_SIZE))
+			break;
+
+		/* increment and wrap the read pointer */
+		radio->rd_index += RDS_BLOCK_SIZE;
+		if (radio->rd_index >= radio->buf_size)
+			radio->rd_index = 0;
+
+		/* increment counters */
+		block_count++;
+		buf += RDS_BLOCK_SIZE;
+		r += RDS_BLOCK_SIZE;
+	}
+
+out:
+	dev_dbg(radio->dev, "%s: exit\n", __func__);
+	mutex_unlock(&core->lock);
+
+	return r;
+}
+
+static const struct v4l2_file_operations wl1273_fops = {
+	.owner		= THIS_MODULE,
+	.read		= wl1273_fm_fops_read,
+	.write		= wl1273_fm_fops_write,
+	.poll		= wl1273_fm_fops_poll,
+	.ioctl		= video_ioctl2,
+	.open		= wl1273_fm_fops_open,
+	.release	= wl1273_fm_fops_release,
+};
+
+static int wl1273_fm_vidioc_querycap(struct file *file, void *priv,
+				     struct v4l2_capability *capability)
+{
+	struct wl1273_device *radio = video_get_drvdata(video_devdata(file));
+
+	dev_dbg(radio->dev, "%s\n", __func__);
+
+	strlcpy(capability->driver, WL1273_FM_DRIVER_NAME,
+		sizeof(capability->driver));
+	strlcpy(capability->card, "Texas Instruments Wl1273 FM Radio",
+		sizeof(capability->card));
+	strlcpy(capability->bus_info, radio->bus_type,
+		sizeof(capability->bus_info));
+
+	capability->capabilities = V4L2_CAP_HW_FREQ_SEEK |
+		V4L2_CAP_TUNER | V4L2_CAP_RADIO | V4L2_CAP_AUDIO |
+		V4L2_CAP_RDS_CAPTURE | V4L2_CAP_MODULATOR |
+		V4L2_CAP_RDS_OUTPUT;
+
+	return 0;
+}
+
+static int wl1273_fm_vidioc_g_input(struct file *file, void *priv,
+				    unsigned int *i)
+{
+	struct wl1273_device *radio = video_get_drvdata(video_devdata(file));
+
+	dev_dbg(radio->dev, "%s\n", __func__);
+
+	*i = 0;
+
+	return 0;
+}
+
+static int wl1273_fm_vidioc_s_input(struct file *file, void *priv,
+				    unsigned int i)
+{
+	struct wl1273_device *radio = video_get_drvdata(video_devdata(file));
+
+	dev_dbg(radio->dev, "%s\n", __func__);
+
+	if (i != 0)
+		return -EINVAL;
+
+	return 0;
+}
+
+/**
+ * wl1273_fm_set_tx_power() -	Set the transmission power value.
+ * @core:			A pointer to the device struct.
+ * @power:			The new power value.
+ */
+static int wl1273_fm_set_tx_power(struct wl1273_device *radio, u16 power)
+{
+	int r;
+
+	if (radio->core->mode == WL1273_MODE_OFF ||
+	    radio->core->mode == WL1273_MODE_SUSPENDED)
+		return -EPERM;
+
+	mutex_lock(&radio->core->lock);
+
+	/* Convert the dBuV value to chip presentation */
+	r = wl1273_fm_write_cmd(radio->core, WL1273_POWER_LEV_SET, 122 - power);
+	if (r)
+		goto out;
+
+	radio->tx_power = power;
+
+out:
+	mutex_unlock(&radio->core->lock);
+	return r;
+}
+
+#define WL1273_SPACING_50kHz	1
+#define WL1273_SPACING_100kHz	2
+#define WL1273_SPACING_200kHz	4
+
+static int wl1273_fm_tx_set_spacing(struct wl1273_device *radio,
+				    unsigned int spacing)
+{
+	int r;
+
+	if (spacing == 0) {
+		r = wl1273_fm_write_cmd(radio->core, WL1273_SCAN_SPACING_SET,
+					WL1273_SPACING_100kHz);
+		radio->spacing = 100;
+	} else if (spacing - 50000 < 25000) {
+		r = wl1273_fm_write_cmd(radio->core, WL1273_SCAN_SPACING_SET,
+					WL1273_SPACING_50kHz);
+		radio->spacing = 50;
+	} else if (spacing - 100000 < 50000) {
+		r = wl1273_fm_write_cmd(radio->core, WL1273_SCAN_SPACING_SET,
+					WL1273_SPACING_100kHz);
+		radio->spacing = 100;
+	} else {
+		r = wl1273_fm_write_cmd(radio->core, WL1273_SCAN_SPACING_SET,
+					WL1273_SPACING_200kHz);
+		radio->spacing = 200;
+	}
+
+	return r;
+}
+
+static int wl1273_fm_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct wl1273_device *radio = ctrl->priv;
+	struct wl1273_core *core = radio->core;
+
+	dev_dbg(radio->dev, "%s\n", __func__);
+
+	if (mutex_lock_interruptible(&core->lock))
+		return -EINTR;
+
+	switch (ctrl->id) {
+	case  V4L2_CID_TUNE_ANTENNA_CAPACITOR:
+		ctrl->val = wl1273_fm_get_tx_ctune(radio);
+		break;
+
+	default:
+		dev_warn(radio->dev, "%s: Unknown IOCTL: %d\n",
+			 __func__, ctrl->id);
+		break;
+	}
+
+	mutex_unlock(&core->lock);
+
+	return 0;
+}
+
+#define WL1273_MUTE_SOFT_ENABLE    (1 << 0)
+#define WL1273_MUTE_AC             (1 << 1)
+#define WL1273_MUTE_HARD_LEFT      (1 << 2)
+#define WL1273_MUTE_HARD_RIGHT     (1 << 3)
+#define WL1273_MUTE_SOFT_FORCE     (1 << 4)
+
+static inline struct wl1273_device *to_radio(struct v4l2_ctrl *ctrl)
+{
+	return container_of(ctrl->handler, struct wl1273_device, ctrl_handler);
+}
+
+static int wl1273_fm_vidioc_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct wl1273_device *radio = to_radio(ctrl);
+	struct wl1273_core *core = radio->core;
+	int r = 0;
+
+	dev_dbg(radio->dev, "%s\n", __func__);
+
+	switch (ctrl->id) {
+	case V4L2_CID_AUDIO_MUTE:
+		if (mutex_lock_interruptible(&core->lock))
+			return -EINTR;
+
+		if (core->mode == WL1273_MODE_RX && ctrl->val)
+			r = wl1273_fm_write_cmd(core,
+						WL1273_MUTE_STATUS_SET,
+						WL1273_MUTE_HARD_LEFT |
+						WL1273_MUTE_HARD_RIGHT);
+		else if (core->mode == WL1273_MODE_RX)
+			r = wl1273_fm_write_cmd(core,
+						WL1273_MUTE_STATUS_SET, 0x0);
+		else if (core->mode == WL1273_MODE_TX && ctrl->val)
+			r = wl1273_fm_write_cmd(core, WL1273_MUTE, 1);
+		else if (core->mode == WL1273_MODE_TX)
+			r = wl1273_fm_write_cmd(core, WL1273_MUTE, 0);
+
+		mutex_unlock(&core->lock);
+		break;
+
+	case V4L2_CID_AUDIO_VOLUME:
+		if (ctrl->val == 0)
+			r = wl1273_fm_set_mode(radio, WL1273_MODE_OFF);
+		else
+			r =  core->set_volume(core, core->volume);
+		break;
+
+	case V4L2_CID_TUNE_PREEMPHASIS:
+		r = wl1273_fm_set_preemphasis(radio, ctrl->val);
+		break;
+
+	case V4L2_CID_TUNE_POWER_LEVEL:
+		r = wl1273_fm_set_tx_power(radio, ctrl->val);
+		break;
+
+	default:
+		dev_warn(radio->dev, "%s: Unknown IOCTL: %d\n",
+			 __func__, ctrl->id);
+		break;
+	}
+
+	dev_dbg(radio->dev, "%s\n", __func__);
+	return r;
+}
+
+static int wl1273_fm_vidioc_g_audio(struct file *file, void *priv,
+				    struct v4l2_audio *audio)
+{
+	struct wl1273_device *radio = video_get_drvdata(video_devdata(file));
+
+	dev_dbg(radio->dev, "%s\n", __func__);
+
+	if (audio->index > 1)
+		return -EINVAL;
+
+	strlcpy(audio->name, "Radio", sizeof(audio->name));
+	audio->capability = V4L2_AUDCAP_STEREO;
+
+	return 0;
+}
+
+static int wl1273_fm_vidioc_s_audio(struct file *file, void *priv,
+				    struct v4l2_audio *audio)
+{
+	struct wl1273_device *radio = video_get_drvdata(video_devdata(file));
+
+	dev_dbg(radio->dev, "%s\n", __func__);
+
+	if (audio->index != 0)
+		return -EINVAL;
+
+	return 0;
+}
+
+#define WL1273_RDS_NOT_SYNCHRONIZED 0
+#define WL1273_RDS_SYNCHRONIZED 1
+
+static int wl1273_fm_vidioc_g_tuner(struct file *file, void *priv,
+				    struct v4l2_tuner *tuner)
+{
+	struct wl1273_device *radio = video_get_drvdata(video_devdata(file));
+	struct wl1273_core *core = radio->core;
+	u16 val;
+	int r;
+
+	dev_dbg(radio->dev, "%s\n", __func__);
+
+	if (tuner->index > 0)
+		return -EINVAL;
+
+	strlcpy(tuner->name, WL1273_FM_DRIVER_NAME, sizeof(tuner->name));
+	tuner->type = V4L2_TUNER_RADIO;
+
+	tuner->rangelow	= WL1273_FREQ(WL1273_BAND_JAPAN_LOW);
+	tuner->rangehigh = WL1273_FREQ(WL1273_BAND_OTHER_HIGH);
+
+	tuner->capability = V4L2_TUNER_CAP_LOW | V4L2_TUNER_CAP_RDS |
+		V4L2_TUNER_CAP_STEREO | V4L2_TUNER_CAP_RDS_BLOCK_IO;
+
+	if (radio->stereo)
+		tuner->audmode = V4L2_TUNER_MODE_STEREO;
+	else
+		tuner->audmode = V4L2_TUNER_MODE_MONO;
+
+	if (core->mode != WL1273_MODE_RX)
+		return 0;
+
+	if (mutex_lock_interruptible(&core->lock))
+		return -EINTR;
+
+	r = wl1273_fm_read_reg(core, WL1273_STEREO_GET, &val);
+	if (r)
+		goto out;
+
+	if (val == 1)
+		tuner->rxsubchans = V4L2_TUNER_SUB_STEREO;
+	else
+		tuner->rxsubchans = V4L2_TUNER_SUB_MONO;
+
+	r = wl1273_fm_read_reg(core, WL1273_RSSI_LVL_GET, &val);
+	if (r)
+		goto out;
+
+	tuner->signal = (s16) val;
+	dev_dbg(radio->dev, "Signal: %d\n", tuner->signal);
+
+	tuner->afc = 0;
+
+	r = wl1273_fm_read_reg(core, WL1273_RDS_SYNC_GET, &val);
+	if (r)
+		goto out;
+
+	if (val == WL1273_RDS_SYNCHRONIZED)
+		tuner->rxsubchans |= V4L2_TUNER_SUB_RDS;
+out:
+	mutex_unlock(&core->lock);
+
+	return r;
+}
+
+static int wl1273_fm_vidioc_s_tuner(struct file *file, void *priv,
+				    struct v4l2_tuner *tuner)
+{
+	struct wl1273_device *radio = video_get_drvdata(video_devdata(file));
+	struct wl1273_core *core = radio->core;
+	int r = 0;
+
+	dev_dbg(radio->dev, "%s\n", __func__);
+	dev_dbg(radio->dev, "tuner->index: %d\n", tuner->index);
+	dev_dbg(radio->dev, "tuner->name: %s\n", tuner->name);
+	dev_dbg(radio->dev, "tuner->capability: 0x%04x\n", tuner->capability);
+	dev_dbg(radio->dev, "tuner->rxsubchans: 0x%04x\n", tuner->rxsubchans);
+	dev_dbg(radio->dev, "tuner->rangelow: %d\n", tuner->rangelow);
+	dev_dbg(radio->dev, "tuner->rangehigh: %d\n", tuner->rangehigh);
+
+	if (tuner->index > 0)
+		return -EINVAL;
+
+	if (mutex_lock_interruptible(&core->lock))
+		return -EINTR;
+
+	r = wl1273_fm_set_mode(radio, WL1273_MODE_RX);
+	if (r)
+		goto out;
+
+	if (tuner->rxsubchans & V4L2_TUNER_SUB_RDS)
+		r = wl1273_fm_set_rds(radio, WL1273_RDS_ON);
+	else
+		r = wl1273_fm_set_rds(radio, WL1273_RDS_OFF);
+
+	if (r)
+		dev_warn(radio->dev, "%s: RDS fails: %d\n", __func__, r);
+
+	if (tuner->audmode == V4L2_TUNER_MODE_MONO) {
+		r = wl1273_fm_write_cmd(core, WL1273_MOST_MODE_SET,
+					WL1273_RX_MONO);
+		if (r < 0) {
+			dev_warn(radio->dev, "%s: MOST_MODE fails: %d\n",
+				 __func__, r);
+			goto out;
+		}
+		radio->stereo = false;
+	} else if (tuner->audmode == V4L2_TUNER_MODE_STEREO) {
+		r = wl1273_fm_write_cmd(core, WL1273_MOST_MODE_SET,
+					WL1273_RX_STEREO);
+		if (r < 0) {
+			dev_warn(radio->dev, "%s: MOST_MODE fails: %d\n",
+				 __func__, r);
+			goto out;
+		}
+		radio->stereo = true;
+	} else {
+		dev_err(radio->dev, "%s: tuner->audmode: %d\n",
+			 __func__, tuner->audmode);
+		r = -EINVAL;
+		goto out;
+	}
+
+out:
+	mutex_unlock(&core->lock);
+
+	return r;
+}
+
+static int wl1273_fm_vidioc_g_frequency(struct file *file, void *priv,
+					struct v4l2_frequency *freq)
+{
+	struct wl1273_device *radio = video_get_drvdata(video_devdata(file));
+	struct wl1273_core *core = radio->core;
+
+	dev_dbg(radio->dev, "%s\n", __func__);
+
+	if (mutex_lock_interruptible(&core->lock))
+		return -EINTR;
+
+	freq->type = V4L2_TUNER_RADIO;
+	freq->frequency = WL1273_FREQ(wl1273_fm_get_freq(radio));
+
+	mutex_unlock(&core->lock);
+
+	return 0;
+}
+
+static int wl1273_fm_vidioc_s_frequency(struct file *file, void *priv,
+					struct v4l2_frequency *freq)
+{
+	struct wl1273_device *radio = video_get_drvdata(video_devdata(file));
+	struct wl1273_core *core = radio->core;
+	int r;
+
+	dev_dbg(radio->dev, "%s: %d\n", __func__, freq->frequency);
+
+	if (freq->type != V4L2_TUNER_RADIO) {
+		dev_dbg(radio->dev,
+			"freq->type != V4L2_TUNER_RADIO: %d\n", freq->type);
+		return -EINVAL;
+	}
+
+	if (mutex_lock_interruptible(&core->lock))
+		return -EINTR;
+
+	if (core->mode == WL1273_MODE_RX) {
+		dev_dbg(radio->dev, "freq: %d\n", freq->frequency);
+
+		r = wl1273_fm_set_rx_freq(radio,
+					  WL1273_INV_FREQ(freq->frequency));
+		if (r)
+			dev_warn(radio->dev, WL1273_FM_DRIVER_NAME
+				 ": set frequency failed with %d\n", r);
+	} else {
+		r = wl1273_fm_set_tx_freq(radio,
+					  WL1273_INV_FREQ(freq->frequency));
+		if (r)
+			dev_warn(radio->dev, WL1273_FM_DRIVER_NAME
+				 ": set frequency failed with %d\n", r);
+	}
+
+	mutex_unlock(&core->lock);
+
+	dev_dbg(radio->dev, "wl1273_vidioc_s_frequency: DONE\n");
+	return r;
+}
+
+#define WL1273_DEFAULT_SEEK_LEVEL	7
+
+static int wl1273_fm_vidioc_s_hw_freq_seek(struct file *file, void *priv,
+					   struct v4l2_hw_freq_seek *seek)
+{
+	struct wl1273_device *radio = video_get_drvdata(video_devdata(file));
+	struct wl1273_core *core = radio->core;
+	int r;
+
+	dev_dbg(radio->dev, "%s\n", __func__);
+
+	if (seek->tuner != 0 || seek->type != V4L2_TUNER_RADIO)
+		return -EINVAL;
+
+	if (mutex_lock_interruptible(&core->lock))
+		return -EINTR;
+
+	r = wl1273_fm_set_mode(radio, WL1273_MODE_RX);
+	if (r)
+		goto out;
+
+	r = wl1273_fm_tx_set_spacing(radio, seek->spacing);
+	if (r)
+		dev_warn(radio->dev, "HW seek failed: %d\n", r);
+
+	r = wl1273_fm_set_seek(radio, seek->wrap_around, seek->seek_upward,
+			       WL1273_DEFAULT_SEEK_LEVEL);
+	if (r)
+		dev_warn(radio->dev, "HW seek failed: %d\n", r);
+
+out:
+	mutex_unlock(&core->lock);
+	return r;
+}
+
+static int wl1273_fm_vidioc_s_modulator(struct file *file, void *priv,
+					struct v4l2_modulator *modulator)
+{
+	struct wl1273_device *radio = video_get_drvdata(video_devdata(file));
+	struct wl1273_core *core = radio->core;
+	int r = 0;
+
+	dev_dbg(radio->dev, "%s\n", __func__);
+
+	if (modulator->index > 0)
+		return -EINVAL;
+
+	if (mutex_lock_interruptible(&core->lock))
+		return -EINTR;
+
+	r = wl1273_fm_set_mode(radio, WL1273_MODE_TX);
+	if (r)
+		goto out;
+
+	if (modulator->txsubchans & V4L2_TUNER_SUB_RDS)
+		r = wl1273_fm_set_rds(radio, WL1273_RDS_ON);
+	else
+		r = wl1273_fm_set_rds(radio, WL1273_RDS_OFF);
+
+	if (modulator->txsubchans & V4L2_TUNER_SUB_MONO)
+		r = wl1273_fm_write_cmd(core, WL1273_MONO_SET, WL1273_TX_MONO);
+	else
+		r = wl1273_fm_write_cmd(core, WL1273_MONO_SET,
+					WL1273_RX_STEREO);
+	if (r < 0)
+		dev_warn(radio->dev, WL1273_FM_DRIVER_NAME
+			 "MONO_SET fails: %d\n", r);
+out:
+	mutex_unlock(&core->lock);
+
+	return r;
+}
+
+static int wl1273_fm_vidioc_g_modulator(struct file *file, void *priv,
+					struct v4l2_modulator *modulator)
+{
+	struct wl1273_device *radio = video_get_drvdata(video_devdata(file));
+	struct wl1273_core *core = radio->core;
+	u16 val;
+	int r;
+
+	dev_dbg(radio->dev, "%s\n", __func__);
+
+	strlcpy(modulator->name, WL1273_FM_DRIVER_NAME,
+		sizeof(modulator->name));
+
+	modulator->rangelow = WL1273_FREQ(WL1273_BAND_JAPAN_LOW);
+	modulator->rangehigh = WL1273_FREQ(WL1273_BAND_OTHER_HIGH);
+
+	modulator->capability =  V4L2_TUNER_CAP_LOW | V4L2_TUNER_CAP_RDS |
+		V4L2_TUNER_CAP_STEREO | V4L2_TUNER_CAP_RDS_BLOCK_IO;
+
+	if (core->mode != WL1273_MODE_TX)
+		return 0;
+
+	if (mutex_lock_interruptible(&core->lock))
+		return -EINTR;
+
+	r = wl1273_fm_read_reg(core, WL1273_MONO_SET, &val);
+	if (r)
+		goto out;
+
+	if (val == WL1273_TX_STEREO)
+		modulator->txsubchans = V4L2_TUNER_SUB_STEREO;
+	else
+		modulator->txsubchans = V4L2_TUNER_SUB_MONO;
+
+	if (radio->rds_on)
+		modulator->txsubchans |= V4L2_TUNER_SUB_RDS;
+out:
+	mutex_unlock(&core->lock);
+
+	return 0;
+}
+
+static int wl1273_fm_vidioc_log_status(struct file *file, void *priv)
+{
+	struct wl1273_device *radio = video_get_drvdata(video_devdata(file));
+	struct wl1273_core *core = radio->core;
+	struct device *dev = radio->dev;
+	u16 val;
+	int r;
+
+	dev_info(dev, DRIVER_DESC);
+
+	if (core->mode == WL1273_MODE_OFF) {
+		dev_info(dev, "Mode: Off\n");
+		return 0;
+	}
+
+	if (core->mode == WL1273_MODE_SUSPENDED) {
+		dev_info(dev, "Mode: Suspended\n");
+		return 0;
+	}
+
+	r = wl1273_fm_read_reg(core, WL1273_ASIC_ID_GET, &val);
+	if (r)
+		dev_err(dev, "%s: Get ASIC_ID fails.\n", __func__);
+	else
+		dev_info(dev, "ASIC_ID: 0x%04x\n", val);
+
+	r = wl1273_fm_read_reg(core, WL1273_ASIC_VER_GET, &val);
+	if (r)
+		dev_err(dev, "%s: Get ASIC_VER fails.\n", __func__);
+	else
+		dev_info(dev, "ASIC Version: 0x%04x\n", val);
+
+	r = wl1273_fm_read_reg(core, WL1273_FIRM_VER_GET, &val);
+	if (r)
+		dev_err(dev, "%s: Get FIRM_VER fails.\n", __func__);
+	else
+		dev_info(dev, "FW version: %d(0x%04x)\n", val, val);
+
+	r = wl1273_fm_read_reg(core, WL1273_BAND_SET, &val);
+	if (r)
+		dev_err(dev, "%s: Get BAND fails.\n", __func__);
+	else
+		dev_info(dev, "BAND: %d\n", val);
+
+	if (core->mode == WL1273_MODE_TX) {
+		r = wl1273_fm_read_reg(core, WL1273_PUPD_SET, &val);
+		if (r)
+			dev_err(dev, "%s: Get PUPD fails.\n", __func__);
+		else
+			dev_info(dev, "PUPD: 0x%04x\n", val);
+
+		r = wl1273_fm_read_reg(core, WL1273_CHANL_SET, &val);
+		if (r)
+			dev_err(dev, "%s: Get CHANL fails.\n", __func__);
+		else
+			dev_info(dev, "Tx frequency: %dkHz\n", val*10);
+	} else if (core->mode == WL1273_MODE_RX) {
+		int bf = radio->rangelow;
+
+		r = wl1273_fm_read_reg(core, WL1273_FREQ_SET, &val);
+		if (r)
+			dev_err(dev, "%s: Get FREQ fails.\n", __func__);
+		else
+			dev_info(dev, "RX Frequency: %dkHz\n", bf + val*50);
+
+		r = wl1273_fm_read_reg(core, WL1273_MOST_MODE_SET, &val);
+		if (r)
+			dev_err(dev, "%s: Get MOST_MODE fails.\n",
+				__func__);
+		else if (val == 0)
+			dev_info(dev, "MOST_MODE: Stereo according to blend\n");
+		else if (val == 1)
+			dev_info(dev, "MOST_MODE: Force mono output\n");
+		else
+			dev_info(dev, "MOST_MODE: Unexpected value: %d\n", val);
+
+		r = wl1273_fm_read_reg(core, WL1273_MOST_BLEND_SET, &val);
+		if (r)
+			dev_err(dev, "%s: Get MOST_BLEND fails.\n", __func__);
+		else if (val == 0)
+			dev_info(dev,
+				 "MOST_BLEND: Switched blend & hysteresis.\n");
+		else if (val == 1)
+			dev_info(dev, "MOST_BLEND: Soft blend.\n");
+		else
+			dev_info(dev, "MOST_BLEND: Unexpected val: %d\n", val);
+
+		r = wl1273_fm_read_reg(core, WL1273_STEREO_GET, &val);
+		if (r)
+			dev_err(dev, "%s: Get STEREO fails.\n", __func__);
+		else if (val == 0)
+			dev_info(dev, "STEREO: Not detected\n");
+		else if (val == 1)
+			dev_info(dev, "STEREO: Detected\n");
+		else
+			dev_info(dev, "STEREO: Unexpected value: %d\n", val);
+
+		r = wl1273_fm_read_reg(core, WL1273_RSSI_LVL_GET, &val);
+		if (r)
+			dev_err(dev, "%s: Get RSSI_LVL fails.\n", __func__);
+		else
+			dev_info(dev, "RX signal strength: %d\n", (s16) val);
+
+		r = wl1273_fm_read_reg(core, WL1273_POWER_SET, &val);
+		if (r)
+			dev_err(dev, "%s: Get POWER fails.\n", __func__);
+		else
+			dev_info(dev, "POWER: 0x%04x\n", val);
+
+		r = wl1273_fm_read_reg(core, WL1273_INT_MASK_SET, &val);
+		if (r)
+			dev_err(dev, "%s: Get INT_MASK fails.\n", __func__);
+		else
+			dev_info(dev, "INT_MASK: 0x%04x\n", val);
+
+		r = wl1273_fm_read_reg(core, WL1273_RDS_SYNC_GET, &val);
+		if (r)
+			dev_err(dev, "%s: Get RDS_SYNC fails.\n",
+				__func__);
+		else if (val == 0)
+			dev_info(dev, "RDS_SYNC: Not synchronized\n");
+
+		else if (val == 1)
+			dev_info(dev, "RDS_SYNC: Synchronized\n");
+		else
+			dev_info(dev, "RDS_SYNC: Unexpected value: %d\n", val);
+
+		r = wl1273_fm_read_reg(core, WL1273_I2S_MODE_CONFIG_SET, &val);
+		if (r)
+			dev_err(dev, "%s: Get I2S_MODE_CONFIG fails.\n",
+				__func__);
+		else
+			dev_info(dev, "I2S_MODE_CONFIG: 0x%04x\n", val);
+
+		r = wl1273_fm_read_reg(core, WL1273_VOLUME_SET, &val);
+		if (r)
+			dev_err(dev, "%s: Get VOLUME fails.\n", __func__);
+		else
+			dev_info(dev, "VOLUME: 0x%04x\n", val);
+	}
+
+	return 0;
+}
+
+static void wl1273_vdev_release(struct video_device *dev)
+{
+}
+
+static const struct v4l2_ctrl_ops wl1273_ctrl_ops = {
+	.s_ctrl = wl1273_fm_vidioc_s_ctrl,
+	.g_volatile_ctrl = wl1273_fm_g_volatile_ctrl,
+};
+
+static const struct v4l2_ioctl_ops wl1273_ioctl_ops = {
+	.vidioc_querycap	= wl1273_fm_vidioc_querycap,
+	.vidioc_g_input		= wl1273_fm_vidioc_g_input,
+	.vidioc_s_input		= wl1273_fm_vidioc_s_input,
+	.vidioc_g_audio		= wl1273_fm_vidioc_g_audio,
+	.vidioc_s_audio		= wl1273_fm_vidioc_s_audio,
+	.vidioc_g_tuner		= wl1273_fm_vidioc_g_tuner,
+	.vidioc_s_tuner		= wl1273_fm_vidioc_s_tuner,
+	.vidioc_g_frequency	= wl1273_fm_vidioc_g_frequency,
+	.vidioc_s_frequency	= wl1273_fm_vidioc_s_frequency,
+	.vidioc_s_hw_freq_seek	= wl1273_fm_vidioc_s_hw_freq_seek,
+	.vidioc_g_modulator	= wl1273_fm_vidioc_g_modulator,
+	.vidioc_s_modulator	= wl1273_fm_vidioc_s_modulator,
+	.vidioc_log_status      = wl1273_fm_vidioc_log_status,
+};
+
+static struct video_device wl1273_viddev_template = {
+	.fops			= &wl1273_fops,
+	.ioctl_ops		= &wl1273_ioctl_ops,
+	.name			= WL1273_FM_DRIVER_NAME,
+	.release		= wl1273_vdev_release,
+};
+
+static int wl1273_fm_radio_remove(struct platform_device *pdev)
+{
+	struct wl1273_device *radio = platform_get_drvdata(pdev);
+	struct wl1273_core *core = radio->core;
+
+	dev_info(&pdev->dev, "%s.\n", __func__);
+
+	free_irq(core->client->irq, radio);
+	core->pdata->free_resources();
+
+	v4l2_ctrl_handler_free(&radio->ctrl_handler);
+	video_unregister_device(&radio->videodev);
+	v4l2_device_unregister(&radio->v4l2dev);
+	kfree(radio->buffer);
+	kfree(radio->write_buf);
+	kfree(radio);
+
+	return 0;
+}
+
+static int __devinit wl1273_fm_radio_probe(struct platform_device *pdev)
+{
+	struct wl1273_core **core = pdev->dev.platform_data;
+	struct wl1273_device *radio;
+	struct v4l2_ctrl *ctrl;
+	int r = 0;
+
+	pr_debug("%s\n", __func__);
+
+	if (!core) {
+		dev_err(&pdev->dev, "No platform data.\n");
+		r = -EINVAL;
+		goto pdata_err;
+	}
+
+	radio = kzalloc(sizeof(*radio), GFP_KERNEL);
+	if (!radio) {
+		r = -ENOMEM;
+		goto pdata_err;
+	}
+
+	/* RDS buffer allocation */
+	radio->buf_size = rds_buf * RDS_BLOCK_SIZE;
+	radio->buffer = kmalloc(radio->buf_size, GFP_KERNEL);
+	if (!radio->buffer) {
+		pr_err("Cannot allocate memory for RDS buffer.\n");
+		r = -ENOMEM;
+		goto err_kmalloc;
+	}
+
+	radio->core = *core;
+	radio->irq_flags = WL1273_IRQ_MASK;
+	radio->dev = &radio->core->client->dev;
+	radio->rds_on = false;
+	radio->core->mode = WL1273_MODE_OFF;
+	radio->tx_power = 118;
+	radio->core->audio_mode = WL1273_AUDIO_ANALOG;
+	radio->band = WL1273_BAND_OTHER;
+	radio->core->i2s_mode = WL1273_I2S_DEF_MODE;
+	radio->core->channel_number = 2;
+	radio->core->volume = WL1273_DEFAULT_VOLUME;
+	radio->rx_frequency = WL1273_BAND_OTHER_LOW;
+	radio->tx_frequency = WL1273_BAND_OTHER_HIGH;
+	radio->rangelow = WL1273_BAND_OTHER_LOW;
+	radio->rangehigh = WL1273_BAND_OTHER_HIGH;
+	radio->stereo = true;
+	radio->bus_type = "I2C";
+
+	radio->core->write = wl1273_fm_write_cmd;
+	radio->core->set_audio = wl1273_fm_set_audio;
+	radio->core->set_volume = wl1273_fm_set_volume;
+
+	if (radio->core->pdata->request_resources) {
+		r = radio->core->pdata->request_resources(radio->core->client);
+		if (r) {
+			dev_err(radio->dev, WL1273_FM_DRIVER_NAME
+				": Cannot get platform data\n");
+			goto err_resources;
+		}
+
+		dev_dbg(radio->dev, "irq: %d\n", radio->core->client->irq);
+
+		r = request_threaded_irq(radio->core->client->irq, NULL,
+					 wl1273_fm_irq_thread_handler,
+					 IRQF_ONESHOT | IRQF_TRIGGER_FALLING,
+					 "wl1273-fm", radio);
+		if (r < 0) {
+			dev_err(radio->dev, WL1273_FM_DRIVER_NAME
+				": Unable to register IRQ handler: %d\n", r);
+			goto err_request_irq;
+		}
+	} else {
+		dev_err(radio->dev, WL1273_FM_DRIVER_NAME ": Core WL1273 IRQ"
+			" not configured");
+		r = -EINVAL;
+		goto err_resources;
+	}
+
+	init_completion(&radio->busy);
+	init_waitqueue_head(&radio->read_queue);
+
+	radio->write_buf = kmalloc(256, GFP_KERNEL);
+	if (!radio->write_buf) {
+		r = -ENOMEM;
+		goto write_buf_err;
+	}
+
+	radio->dev = &pdev->dev;
+	radio->v4l2dev.ctrl_handler = &radio->ctrl_handler;
+	radio->rds_users = 0;
+
+	r = v4l2_device_register(&pdev->dev, &radio->v4l2dev);
+	if (r) {
+		dev_err(&pdev->dev, "Cannot register v4l2_device.\n");
+		goto device_register_err;
+	}
+
+	/* V4L2 configuration */
+	memcpy(&radio->videodev, &wl1273_viddev_template,
+	       sizeof(wl1273_viddev_template));
+
+	radio->videodev.v4l2_dev = &radio->v4l2dev;
+
+	v4l2_ctrl_handler_init(&radio->ctrl_handler, 6);
+
+	/* add in ascending ID order */
+	v4l2_ctrl_new_std(&radio->ctrl_handler, &wl1273_ctrl_ops,
+			  V4L2_CID_AUDIO_VOLUME, 0, WL1273_MAX_VOLUME, 1,
+			  WL1273_DEFAULT_VOLUME);
+
+	v4l2_ctrl_new_std(&radio->ctrl_handler, &wl1273_ctrl_ops,
+			  V4L2_CID_AUDIO_MUTE, 0, 1, 1, 1);
+
+	v4l2_ctrl_new_std_menu(&radio->ctrl_handler, &wl1273_ctrl_ops,
+			       V4L2_CID_TUNE_PREEMPHASIS,
+			       V4L2_PREEMPHASIS_75_uS, 0x03,
+			       V4L2_PREEMPHASIS_50_uS);
+
+	v4l2_ctrl_new_std(&radio->ctrl_handler, &wl1273_ctrl_ops,
+			  V4L2_CID_TUNE_POWER_LEVEL, 91, 122, 1, 118);
+
+	ctrl = v4l2_ctrl_new_std(&radio->ctrl_handler, &wl1273_ctrl_ops,
+				 V4L2_CID_TUNE_ANTENNA_CAPACITOR,
+				 0, 255, 1, 255);
+	if (ctrl)
+		ctrl->is_volatile = 1;
+
+	if (radio->ctrl_handler.error) {
+		r = radio->ctrl_handler.error;
+		dev_err(&pdev->dev, "Ctrl handler error: %d\n", r);
+		goto handler_init_err;
+	}
+
+	video_set_drvdata(&radio->videodev, radio);
+	platform_set_drvdata(pdev, radio);
+
+	/* register video device */
+	r = video_register_device(&radio->videodev, VFL_TYPE_RADIO, radio_nr);
+	if (r) {
+		dev_err(&pdev->dev, WL1273_FM_DRIVER_NAME
+			": Could not register video device\n");
+		goto handler_init_err;
+	}
+
+	return 0;
+
+handler_init_err:
+	v4l2_ctrl_handler_free(&radio->ctrl_handler);
+	v4l2_device_unregister(&radio->v4l2dev);
+device_register_err:
+	kfree(radio->write_buf);
+write_buf_err:
+	free_irq(radio->core->client->irq, radio);
+err_request_irq:
+	radio->core->pdata->free_resources();
+err_resources:
+	kfree(radio->buffer);
+err_kmalloc:
+	kfree(radio);
+pdata_err:
+	return r;
+}
+
+MODULE_ALIAS("platform:wl1273_fm_radio");
+
+static struct platform_driver wl1273_fm_radio_driver = {
+	.probe		= wl1273_fm_radio_probe,
+	.remove		= __devexit_p(wl1273_fm_radio_remove),
+	.driver		= {
+		.name	= "wl1273_fm_radio",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init wl1273_fm_module_init(void)
+{
+	pr_info("%s\n", __func__);
+	return platform_driver_register(&wl1273_fm_radio_driver);
+}
+module_init(wl1273_fm_module_init);
+
+static void __exit wl1273_fm_module_exit(void)
+{
+	flush_scheduled_work();
+	platform_driver_unregister(&wl1273_fm_radio_driver);
+	pr_info(DRIVER_DESC ", Exiting.\n");
+}
+module_exit(wl1273_fm_module_exit);
+
+MODULE_AUTHOR("Matti Aaltonen <matti.j.aaltonen@nokia.com>");
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE("GPL");
