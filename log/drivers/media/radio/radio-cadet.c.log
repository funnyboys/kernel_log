commit e83ce3005db16243e1085925251fd0776bb60d09
Author: Hans Verkuil <hverkuil-cisco@xs4all.nl>
Date:   Tue Jun 4 07:19:52 2019 -0400

    media: media/radio: set device_caps in struct video_device
    
    Instead of filling in the struct v4l2_capability device_caps
    field, fill in the struct video_device device_caps field.
    
    That way the V4L2 core knows what the capabilities of the
    video device are.
    
    But this only really works if all drivers use this, so convert
    all radio drivers in this patch.
    
    Signed-off-by: Hans Verkuil <hverkuil-cisco@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/radio/radio-cadet.c b/drivers/media/radio/radio-cadet.c
index 12160894839c..a5db9b4dc3de 100644
--- a/drivers/media/radio/radio-cadet.c
+++ b/drivers/media/radio/radio-cadet.c
@@ -357,9 +357,6 @@ static int vidioc_querycap(struct file *file, void *priv,
 	strscpy(v->driver, "ADS Cadet", sizeof(v->driver));
 	strscpy(v->card, "ADS Cadet", sizeof(v->card));
 	strscpy(v->bus_info, "ISA:radio-cadet", sizeof(v->bus_info));
-	v->device_caps = V4L2_CAP_TUNER | V4L2_CAP_RADIO |
-			  V4L2_CAP_READWRITE | V4L2_CAP_RDS_CAPTURE;
-	v->capabilities = v->device_caps | V4L2_CAP_DEVICE_CAPS;
 	return 0;
 }
 
@@ -646,6 +643,8 @@ static int __init cadet_init(void)
 	dev->vdev.ioctl_ops = &cadet_ioctl_ops;
 	dev->vdev.release = video_device_release_empty;
 	dev->vdev.lock = &dev->lock;
+	dev->vdev.device_caps = V4L2_CAP_TUNER | V4L2_CAP_RADIO |
+				V4L2_CAP_READWRITE | V4L2_CAP_RDS_CAPTURE;
 	video_set_drvdata(&dev->vdev, dev);
 
 	res = video_register_device(&dev->vdev, VFL_TYPE_RADIO, radio_nr);

commit 09c434b8a0047c69e48499de0107de312901e798
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 13:08:20 2019 +0100

    treewide: Add SPDX license identifier for more missed files
    
    Add SPDX license identifiers to all files which:
    
     - Have no license information of any form
    
     - Have MODULE_LICENCE("GPL*") inside which was used in the initial
       scan/conversion to ignore the file
    
    These files fall under the project license, GPL v2 only. The resulting SPDX
    license identifier is:
    
      GPL-2.0-only
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/media/radio/radio-cadet.c b/drivers/media/radio/radio-cadet.c
index d12e07e32546..12160894839c 100644
--- a/drivers/media/radio/radio-cadet.c
+++ b/drivers/media/radio/radio-cadet.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /* radio-cadet.c - A video4linux driver for the ADS Cadet AM/FM Radio Card
  *
  * by Fred Gleason <fredg@wava.com>

commit c0decac19da3906d9b66291e57b7759489e1170f
Author: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
Date:   Mon Sep 10 08:19:14 2018 -0400

    media: use strscpy() instead of strlcpy()
    
    The implementation of strscpy() is more robust and safer.
    
    That's now the recommended way to copy NUL terminated strings.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Acked-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/radio/radio-cadet.c b/drivers/media/radio/radio-cadet.c
index 5b82e63885cd..d12e07e32546 100644
--- a/drivers/media/radio/radio-cadet.c
+++ b/drivers/media/radio/radio-cadet.c
@@ -353,9 +353,9 @@ static ssize_t cadet_read(struct file *file, char __user *data, size_t count, lo
 static int vidioc_querycap(struct file *file, void *priv,
 				struct v4l2_capability *v)
 {
-	strlcpy(v->driver, "ADS Cadet", sizeof(v->driver));
-	strlcpy(v->card, "ADS Cadet", sizeof(v->card));
-	strlcpy(v->bus_info, "ISA:radio-cadet", sizeof(v->bus_info));
+	strscpy(v->driver, "ADS Cadet", sizeof(v->driver));
+	strscpy(v->card, "ADS Cadet", sizeof(v->card));
+	strscpy(v->bus_info, "ISA:radio-cadet", sizeof(v->bus_info));
 	v->device_caps = V4L2_CAP_TUNER | V4L2_CAP_RADIO |
 			  V4L2_CAP_READWRITE | V4L2_CAP_RDS_CAPTURE;
 	v->capabilities = v->device_caps | V4L2_CAP_DEVICE_CAPS;
@@ -370,7 +370,7 @@ static int vidioc_g_tuner(struct file *file, void *priv,
 	if (v->index)
 		return -EINVAL;
 	v->type = V4L2_TUNER_RADIO;
-	strlcpy(v->name, "Radio", sizeof(v->name));
+	strscpy(v->name, "Radio", sizeof(v->name));
 	v->capability = bands[0].capability | bands[1].capability;
 	v->rangelow = bands[0].rangelow;	   /* 520 kHz (start of AM band) */
 	v->rangehigh = bands[1].rangehigh;    /* 108.0 MHz (end of FM band) */
@@ -595,7 +595,7 @@ static int __init cadet_init(void)
 	struct v4l2_ctrl_handler *hdl;
 	int res = -ENODEV;
 
-	strlcpy(v4l2_dev->name, "cadet", sizeof(v4l2_dev->name));
+	strscpy(v4l2_dev->name, "cadet", sizeof(v4l2_dev->name));
 	mutex_init(&dev->lock);
 
 	/* If a probe was requested then probe ISAPnP first (safest) */
@@ -639,7 +639,7 @@ static int __init cadet_init(void)
 	dev->is_fm_band = true;
 	dev->curfreq = bands[dev->is_fm_band].rangelow;
 	cadet_setfreq(dev, dev->curfreq);
-	strlcpy(dev->vdev.name, v4l2_dev->name, sizeof(dev->vdev.name));
+	strscpy(dev->vdev.name, v4l2_dev->name, sizeof(dev->vdev.name));
 	dev->vdev.v4l2_dev = v4l2_dev;
 	dev->vdev.fops = &cadet_fops;
 	dev->vdev.ioctl_ops = &cadet_ioctl_ops;

commit a9a08845e9acbd224e4ee466f5c1275ed50054e8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Feb 11 14:34:03 2018 -0800

    vfs: do bulk POLL* -> EPOLL* replacement
    
    This is the mindless scripted replacement of kernel use of POLL*
    variables as described by Al, done by this script:
    
        for V in IN OUT PRI ERR RDNORM RDBAND WRNORM WRBAND HUP RDHUP NVAL MSG; do
            L=`git grep -l -w POLL$V | grep -v '^t' | grep -v /um/ | grep -v '^sa' | grep -v '/poll.h$'|grep -v '^D'`
            for f in $L; do sed -i "-es/^\([^\"]*\)\(\<POLL$V\>\)/\\1E\\2/" $f; done
        done
    
    with de-mangling cleanups yet to come.
    
    NOTE! On almost all architectures, the EPOLL* constants have the same
    values as the POLL* constants do.  But they keyword here is "almost".
    For various bad reasons they aren't the same, and epoll() doesn't
    actually work quite correctly in some cases due to this on Sparc et al.
    
    The next patch from Al will sort out the final differences, and we
    should be all done.
    
    Scripted-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/media/radio/radio-cadet.c b/drivers/media/radio/radio-cadet.c
index af7c68b344d1..5b82e63885cd 100644
--- a/drivers/media/radio/radio-cadet.c
+++ b/drivers/media/radio/radio-cadet.c
@@ -488,14 +488,14 @@ static __poll_t cadet_poll(struct file *file, struct poll_table_struct *wait)
 	__poll_t res = v4l2_ctrl_poll(file, wait);
 
 	poll_wait(file, &dev->read_queue, wait);
-	if (dev->rdsstat == 0 && (req_events & (POLLIN | POLLRDNORM))) {
+	if (dev->rdsstat == 0 && (req_events & (EPOLLIN | EPOLLRDNORM))) {
 		mutex_lock(&dev->lock);
 		if (dev->rdsstat == 0)
 			cadet_start_rds(dev);
 		mutex_unlock(&dev->lock);
 	}
 	if (cadet_has_rds_data(dev))
-		res |= POLLIN | POLLRDNORM;
+		res |= EPOLLIN | EPOLLRDNORM;
 	return res;
 }
 

commit 68c5735eaa5e680e701c9a2d1e3c7880bdf5ab66
Merge: 2246edfaf88d 273caa260035
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Feb 6 11:27:48 2018 -0800

    Merge tag 'media/v4.16-2' of git://git.kernel.org/pub/scm/linux/kernel/git/mchehab/linux-media
    
    Pull media updates from Mauro Carvalho Chehab:
    
     - videobuf2 was moved to a media/common dir, as it is now used by the
       DVB subsystem too
    
     - Digital TV core memory mapped support interface
    
     - new sensor driver: ov7740
    
     - several improvements at ddbridge driver
    
     - new V4L2 driver: IPU3 CIO2 CSI-2 receiver unit, found on some Intel
       SoCs
    
     - new tuner driver: tda18250
    
     - finally got rid of all LIRC staging drivers
    
     - as we don't have old lirc drivers anymore, restruct the lirc device
       code
    
     - add support for UVC metadata
    
     - add a new staging driver for NVIDIA Tegra Video Decoder Engine
    
     - DVB kAPI headers moved to include/media
    
     - synchronize the kAPI and uAPI for the DVB subsystem, removing the gap
       for non-legacy APIs
    
     - reduce the kAPI gap for V4L2
    
     - lots of other driver enhancements, cleanups, etc.
    
    * tag 'media/v4.16-2' of git://git.kernel.org/pub/scm/linux/kernel/git/mchehab/linux-media: (407 commits)
      media: v4l2-compat-ioctl32.c: make ctrl_is_pointer work for subdevs
      media: v4l2-compat-ioctl32.c: refactor compat ioctl32 logic
      media: v4l2-compat-ioctl32.c: don't copy back the result for certain errors
      media: v4l2-compat-ioctl32.c: drop pr_info for unknown buffer type
      media: v4l2-compat-ioctl32.c: copy clip list in put_v4l2_window32
      media: v4l2-compat-ioctl32.c: fix ctrl_is_pointer
      media: v4l2-compat-ioctl32.c: copy m.userptr in put_v4l2_plane32
      media: v4l2-compat-ioctl32.c: avoid sizeof(type)
      media: v4l2-compat-ioctl32.c: move 'helper' functions to __get/put_v4l2_format32
      media: v4l2-compat-ioctl32.c: fix the indentation
      media: v4l2-compat-ioctl32.c: add missing VIDIOC_PREPARE_BUF
      media: v4l2-ioctl.c: don't copy back the result for -ENOTTY
      media: v4l2-ioctl.c: use check_fmt for enum/g/s/try_fmt
      media: vivid: fix module load error when enabling fb and no_error_inj=1
      media: dvb_demux: improve debug messages
      media: dvb_demux: Better handle discontinuity errors
      media: cxusb, dib0700: ignore XC2028_I2C_FLUSH
      media: ts2020: avoid integer overflows on 32 bit machines
      media: i2c: ov7740: use gpio/consumer.h instead of gpio.h
      media: entity: Add a nop variant of media_entity_cleanup
      ...

commit 6e6a8b5a38cb04d5ef35d4eb57836126b954e7c8
Author: Mauro Carvalho Chehab <mchehab@s-opensource.com>
Date:   Thu Jan 4 13:08:56 2018 -0500

    media: replace all <spaces><tab> occurrences
    
    There are a lot of places where sequences of space/tabs are
    found. Get rid of all spaces before tabs.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/radio/radio-cadet.c b/drivers/media/radio/radio-cadet.c
index 7575e5370a49..ec5c88801402 100644
--- a/drivers/media/radio/radio-cadet.c
+++ b/drivers/media/radio/radio-cadet.c
@@ -30,7 +30,7 @@
  *		Changed API to V4L2
  */
 
-#include <linux/module.h>	/* Modules 			*/
+#include <linux/module.h>	/* Modules			*/
 #include <linux/init.h>		/* Initdata			*/
 #include <linux/ioport.h>	/* request_region		*/
 #include <linux/delay.h>	/* udelay			*/
@@ -503,7 +503,7 @@ static unsigned int cadet_poll(struct file *file, struct poll_table_struct *wait
 static const struct v4l2_file_operations cadet_fops = {
 	.owner		= THIS_MODULE,
 	.open		= cadet_open,
-	.release       	= cadet_release,
+	.release	= cadet_release,
 	.read		= cadet_read,
 	.unlocked_ioctl	= video_ioctl2,
 	.poll		= cadet_poll,

commit c23e0cb81e4021b9712b1093d54713991fd9b7c2
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Jul 3 03:02:56 2017 -0400

    media: annotate ->poll() instances
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/media/radio/radio-cadet.c b/drivers/media/radio/radio-cadet.c
index 7a6b3efefedb..dba611003a00 100644
--- a/drivers/media/radio/radio-cadet.c
+++ b/drivers/media/radio/radio-cadet.c
@@ -481,11 +481,11 @@ static int cadet_release(struct file *file)
 	return 0;
 }
 
-static unsigned int cadet_poll(struct file *file, struct poll_table_struct *wait)
+static __poll_t cadet_poll(struct file *file, struct poll_table_struct *wait)
 {
 	struct cadet *dev = video_drvdata(file);
 	__poll_t req_events = poll_requested_events(wait);
-	unsigned int res = v4l2_ctrl_poll(file, wait);
+	__poll_t res = v4l2_ctrl_poll(file, wait);
 
 	poll_wait(file, &dev->read_queue, wait);
 	if (dev->rdsstat == 0 && (req_events & (POLLIN | POLLRDNORM))) {

commit 01699437758328090813212ecefe3ab6f0d5b9cc
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Jul 3 03:14:15 2017 -0400

    annotate poll_table_struct ->_key
    
    Only POLL... bitmaps ever end up there and their only use is checking
    for POLL... bits in them.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/media/radio/radio-cadet.c b/drivers/media/radio/radio-cadet.c
index 7575e5370a49..7a6b3efefedb 100644
--- a/drivers/media/radio/radio-cadet.c
+++ b/drivers/media/radio/radio-cadet.c
@@ -484,7 +484,7 @@ static int cadet_release(struct file *file)
 static unsigned int cadet_poll(struct file *file, struct poll_table_struct *wait)
 {
 	struct cadet *dev = video_drvdata(file);
-	unsigned long req_events = poll_requested_events(wait);
+	__poll_t req_events = poll_requested_events(wait);
 	unsigned int res = v4l2_ctrl_poll(file, wait);
 
 	poll_wait(file, &dev->read_queue, wait);

commit 297fced0f86a27b55729afa6a8e53f45095433a3
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Oct 24 11:23:03 2017 -0400

    media: radio: Convert timers to use timer_setup()
    
    In preparation for unconditionally passing the struct timer_list pointer to
    all timer callbacks, switch to using the new timer_setup() and from_timer()
    to pass the timer pointer explicitly.
    
    Cc: Hans Verkuil <hverkuil@xs4all.nl>
    Cc: Mauro Carvalho Chehab <mchehab@kernel.org>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/radio/radio-cadet.c b/drivers/media/radio/radio-cadet.c
index 6888b7db449d..7575e5370a49 100644
--- a/drivers/media/radio/radio-cadet.c
+++ b/drivers/media/radio/radio-cadet.c
@@ -281,9 +281,9 @@ static bool cadet_has_rds_data(struct cadet *dev)
 }
 
 
-static void cadet_handler(unsigned long data)
+static void cadet_handler(struct timer_list *t)
 {
-	struct cadet *dev = (void *)data;
+	struct cadet *dev = from_timer(dev, t, readtimer);
 
 	/* Service the RDS fifo */
 	if (mutex_trylock(&dev->lock)) {
@@ -309,7 +309,6 @@ static void cadet_handler(unsigned long data)
 	/*
 	 * Clean up and exit
 	 */
-	setup_timer(&dev->readtimer, cadet_handler, data);
 	dev->readtimer.expires = jiffies + msecs_to_jiffies(50);
 	add_timer(&dev->readtimer);
 }
@@ -318,7 +317,7 @@ static void cadet_start_rds(struct cadet *dev)
 {
 	dev->rdsstat = 1;
 	outb(0x80, dev->io);        /* Select RDS fifo */
-	setup_timer(&dev->readtimer, cadet_handler, (unsigned long)dev);
+	timer_setup(&dev->readtimer, cadet_handler, 0);
 	dev->readtimer.expires = jiffies + msecs_to_jiffies(50);
 	add_timer(&dev->readtimer);
 }

commit db4a8505ff86f6ccbe4880969c1d45c2d0ea7987
Author: Arvind Yadav <arvind.yadav.cs@gmail.com>
Date:   Wed Aug 16 01:30:10 2017 -0400

    media: radio: constify pnp_device_id
    
    pnp_device_id are not supposed to change at runtime. All functions
    working with pnp_device_id provided by <linux/pnp.h> work with
    const pnp_device_id. So mark the non-const structs as const.
    
    Signed-off-by: Arvind Yadav <arvind.yadav.cs@gmail.com>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/radio/radio-cadet.c b/drivers/media/radio/radio-cadet.c
index cbaf850f4791..6888b7db449d 100644
--- a/drivers/media/radio/radio-cadet.c
+++ b/drivers/media/radio/radio-cadet.c
@@ -528,7 +528,7 @@ static const struct v4l2_ctrl_ops cadet_ctrl_ops = {
 
 #ifdef CONFIG_PNP
 
-static struct pnp_device_id cadet_pnp_devices[] = {
+static const struct pnp_device_id cadet_pnp_devices[] = {
 	/* ADS Cadet AM/FM Radio Card */
 	{.id = "MSM0c24", .driver_data = 0},
 	{.id = ""}

commit 75d1b1379fba4ca2fb6fb7b70141ac0afb807fbf
Author: Matej Hulín <mito.hulin@gmail.com>
Date:   Mon Jan 23 07:12:30 2017 -0200

    [media] media: radio-cadet, initialize timer with setup_timer
    
    Stop accessing timer struct members directly and use the setup_timer
    helper intended for that use. It makes the code cleaner and will allow
    for easier change of the timer struct internals.
    
    Signed-off-by: Matej Hulín <mito.hulin@gmail.com>
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/radio/radio-cadet.c b/drivers/media/radio/radio-cadet.c
index 82affaedf067..cbaf850f4791 100644
--- a/drivers/media/radio/radio-cadet.c
+++ b/drivers/media/radio/radio-cadet.c
@@ -309,9 +309,7 @@ static void cadet_handler(unsigned long data)
 	/*
 	 * Clean up and exit
 	 */
-	init_timer(&dev->readtimer);
-	dev->readtimer.function = cadet_handler;
-	dev->readtimer.data = data;
+	setup_timer(&dev->readtimer, cadet_handler, data);
 	dev->readtimer.expires = jiffies + msecs_to_jiffies(50);
 	add_timer(&dev->readtimer);
 }
@@ -320,9 +318,7 @@ static void cadet_start_rds(struct cadet *dev)
 {
 	dev->rdsstat = 1;
 	outb(0x80, dev->io);        /* Select RDS fifo */
-	init_timer(&dev->readtimer);
-	dev->readtimer.function = cadet_handler;
-	dev->readtimer.data = (unsigned long)dev;
+	setup_timer(&dev->readtimer, cadet_handler, (unsigned long)dev);
 	dev->readtimer.expires = jiffies + msecs_to_jiffies(50);
 	add_timer(&dev->readtimer);
 }

commit 95cd5d5ee67c2108765ae87d34761d54fd6671ce
Author: Ramakrishnan Muthukrishnan <ramakrmu@cisco.com>
Date:   Thu Jun 19 14:22:58 2014 -0300

    [media] media: remove the setting of the flag V4L2_FL_USE_FH_PRIO
    
    Since all the drivers that use `struct v4l2_fh' use the core
    priority checking, the setting of the flag in the drivers can
    be removed.
    
    Signed-off-by: Ramakrishnan Muthukrishnan <ramakrmu@cisco.com>
    Reviewed-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/drivers/media/radio/radio-cadet.c b/drivers/media/radio/radio-cadet.c
index d719e59e2179..82affaedf067 100644
--- a/drivers/media/radio/radio-cadet.c
+++ b/drivers/media/radio/radio-cadet.c
@@ -650,7 +650,6 @@ static int __init cadet_init(void)
 	dev->vdev.ioctl_ops = &cadet_ioctl_ops;
 	dev->vdev.release = video_device_release_empty;
 	dev->vdev.lock = &dev->lock;
-	set_bit(V4L2_FL_USE_FH_PRIO, &dev->vdev.flags);
 	video_set_drvdata(&dev->vdev, dev);
 
 	res = video_register_device(&dev->vdev, VFL_TYPE_RADIO, radio_nr);

commit ce0ede2c06202dace68a2f0401ebaafdaa2720d2
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Mon Feb 10 07:21:36 2014 -0300

    [media] radio-cadet: avoid interruptible_sleep_on race
    
    interruptible_sleep_on is racy and going away. This replaces
    one use in the radio-cadet driver with a wait_event_interruptible
    call. Special care was taken that accesses to the rdsin and rdsout
    indices are always done with dev->lock held.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/drivers/media/radio/radio-cadet.c b/drivers/media/radio/radio-cadet.c
index 545c04cf7226..d719e59e2179 100644
--- a/drivers/media/radio/radio-cadet.c
+++ b/drivers/media/radio/radio-cadet.c
@@ -270,6 +270,16 @@ static void cadet_setfreq(struct cadet *dev, unsigned freq)
 	outb(inb(dev->io + 1) & 0x7f, dev->io + 1);
 }
 
+static bool cadet_has_rds_data(struct cadet *dev)
+{
+	bool result;
+
+	mutex_lock(&dev->lock);
+	result = dev->rdsin != dev->rdsout;
+	mutex_unlock(&dev->lock);
+	return result;
+}
+
 
 static void cadet_handler(unsigned long data)
 {
@@ -279,13 +289,12 @@ static void cadet_handler(unsigned long data)
 	if (mutex_trylock(&dev->lock)) {
 		outb(0x3, dev->io);       /* Select RDS Decoder Control */
 		if ((inb(dev->io + 1) & 0x20) != 0)
-			printk(KERN_CRIT "cadet: RDS fifo overflow\n");
+			pr_err("cadet: RDS fifo overflow\n");
 		outb(0x80, dev->io);      /* Select RDS fifo */
+
 		while ((inb(dev->io) & 0x80) != 0) {
 			dev->rdsbuf[dev->rdsin] = inb(dev->io + 1);
-			if (dev->rdsin + 1 == dev->rdsout)
-				printk(KERN_WARNING "cadet: RDS buffer overflow\n");
-			else
+			if (dev->rdsin + 1 != dev->rdsout)
 				dev->rdsin++;
 		}
 		mutex_unlock(&dev->lock);
@@ -294,7 +303,7 @@ static void cadet_handler(unsigned long data)
 	/*
 	 * Service pending read
 	 */
-	if (dev->rdsin != dev->rdsout)
+	if (cadet_has_rds_data(dev))
 		wake_up_interruptible(&dev->read_queue);
 
 	/*
@@ -327,22 +336,21 @@ static ssize_t cadet_read(struct file *file, char __user *data, size_t count, lo
 	mutex_lock(&dev->lock);
 	if (dev->rdsstat == 0)
 		cadet_start_rds(dev);
-	if (dev->rdsin == dev->rdsout) {
-		if (file->f_flags & O_NONBLOCK) {
-			i = -EWOULDBLOCK;
-			goto unlock;
-		}
-		mutex_unlock(&dev->lock);
-		interruptible_sleep_on(&dev->read_queue);
-		mutex_lock(&dev->lock);
-	}
+	mutex_unlock(&dev->lock);
+
+	if (!cadet_has_rds_data(dev) && (file->f_flags & O_NONBLOCK))
+		return -EWOULDBLOCK;
+	i = wait_event_interruptible(dev->read_queue, cadet_has_rds_data(dev));
+	if (i)
+		return i;
+
+	mutex_lock(&dev->lock);
 	while (i < count && dev->rdsin != dev->rdsout)
 		readbuf[i++] = dev->rdsbuf[dev->rdsout++];
+	mutex_unlock(&dev->lock);
 
 	if (i && copy_to_user(data, readbuf, i))
-		i = -EFAULT;
-unlock:
-	mutex_unlock(&dev->lock);
+		return -EFAULT;
 	return i;
 }
 
@@ -352,7 +360,7 @@ static int vidioc_querycap(struct file *file, void *priv,
 {
 	strlcpy(v->driver, "ADS Cadet", sizeof(v->driver));
 	strlcpy(v->card, "ADS Cadet", sizeof(v->card));
-	strlcpy(v->bus_info, "ISA", sizeof(v->bus_info));
+	strlcpy(v->bus_info, "ISA:radio-cadet", sizeof(v->bus_info));
 	v->device_caps = V4L2_CAP_TUNER | V4L2_CAP_RADIO |
 			  V4L2_CAP_READWRITE | V4L2_CAP_RDS_CAPTURE;
 	v->capabilities = v->device_caps | V4L2_CAP_DEVICE_CAPS;
@@ -491,7 +499,7 @@ static unsigned int cadet_poll(struct file *file, struct poll_table_struct *wait
 			cadet_start_rds(dev);
 		mutex_unlock(&dev->lock);
 	}
-	if (dev->rdsin != dev->rdsout)
+	if (cadet_has_rds_data(dev))
 		res |= POLLIN | POLLRDNORM;
 	return res;
 }

commit 2f73c7c582a685b3198b974cd6d964d0338f8ab5
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Fri Mar 15 06:10:06 2013 -0300

    [media] v4l2: add const to argument of write-only s_tuner ioctl
    
    This ioctl is defined as IOW, so pass the argument as const.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Acked-by: Alexey Klimov <klimov.linux@gmail.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-cadet.c b/drivers/media/radio/radio-cadet.c
index 59be293cbf42..545c04cf7226 100644
--- a/drivers/media/radio/radio-cadet.c
+++ b/drivers/media/radio/radio-cadet.c
@@ -390,7 +390,7 @@ static int vidioc_g_tuner(struct file *file, void *priv,
 }
 
 static int vidioc_s_tuner(struct file *file, void *priv,
-				struct v4l2_tuner *v)
+				const struct v4l2_tuner *v)
 {
 	return v->index ? -EINVAL : 0;
 }

commit b530a447bb588fdf43fdf4eb909e4ee1921d47ac
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Tue Mar 19 04:09:26 2013 -0300

    [media] v4l2: add const to argument of write-only s_frequency ioctl
    
    This ioctl is defined as IOW, so pass the argument as const.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-cadet.c b/drivers/media/radio/radio-cadet.c
index 643d80ac28fb..59be293cbf42 100644
--- a/drivers/media/radio/radio-cadet.c
+++ b/drivers/media/radio/radio-cadet.c
@@ -90,6 +90,26 @@ static u16 sigtable[2][4] = {
 	{ 2185, 4369, 13107, 65535 },
 };
 
+static const struct v4l2_frequency_band bands[] = {
+	{
+		.index = 0,
+		.type = V4L2_TUNER_RADIO,
+		.capability = V4L2_TUNER_CAP_LOW | V4L2_TUNER_CAP_FREQ_BANDS,
+		.rangelow = 8320,      /* 520 kHz */
+		.rangehigh = 26400,    /* 1650 kHz */
+		.modulation = V4L2_BAND_MODULATION_AM,
+	}, {
+		.index = 1,
+		.type = V4L2_TUNER_RADIO,
+		.capability = V4L2_TUNER_CAP_STEREO | V4L2_TUNER_CAP_RDS |
+			V4L2_TUNER_CAP_RDS_BLOCK_IO | V4L2_TUNER_CAP_LOW |
+			V4L2_TUNER_CAP_FREQ_BANDS,
+		.rangelow = 1400000,   /* 87.5 MHz */
+		.rangehigh = 1728000,  /* 108.0 MHz */
+		.modulation = V4L2_BAND_MODULATION_FM,
+	},
+};
+
 
 static int cadet_getstereo(struct cadet *dev)
 {
@@ -196,6 +216,8 @@ static void cadet_setfreq(struct cadet *dev, unsigned freq)
 	int i, j, test;
 	int curvol;
 
+	freq = clamp(freq, bands[dev->is_fm_band].rangelow,
+			   bands[dev->is_fm_band].rangehigh);
 	dev->curfreq = freq;
 	/*
 	 * Formulate a fifo command
@@ -337,26 +359,6 @@ static int vidioc_querycap(struct file *file, void *priv,
 	return 0;
 }
 
-static const struct v4l2_frequency_band bands[] = {
-	{
-		.index = 0,
-		.type = V4L2_TUNER_RADIO,
-		.capability = V4L2_TUNER_CAP_LOW | V4L2_TUNER_CAP_FREQ_BANDS,
-		.rangelow = 8320,      /* 520 kHz */
-		.rangehigh = 26400,    /* 1650 kHz */
-		.modulation = V4L2_BAND_MODULATION_AM,
-	}, {
-		.index = 1,
-		.type = V4L2_TUNER_RADIO,
-		.capability = V4L2_TUNER_CAP_STEREO | V4L2_TUNER_CAP_RDS |
-			V4L2_TUNER_CAP_RDS_BLOCK_IO | V4L2_TUNER_CAP_LOW |
-			V4L2_TUNER_CAP_FREQ_BANDS,
-		.rangelow = 1400000,   /* 87.5 MHz */
-		.rangehigh = 1728000,  /* 108.0 MHz */
-		.modulation = V4L2_BAND_MODULATION_FM,
-	},
-};
-
 static int vidioc_g_tuner(struct file *file, void *priv,
 				struct v4l2_tuner *v)
 {
@@ -418,7 +420,7 @@ static int vidioc_g_frequency(struct file *file, void *priv,
 
 
 static int vidioc_s_frequency(struct file *file, void *priv,
-				struct v4l2_frequency *f)
+				const struct v4l2_frequency *f)
 {
 	struct cadet *dev = video_drvdata(file);
 
@@ -426,8 +428,6 @@ static int vidioc_s_frequency(struct file *file, void *priv,
 		return -EINVAL;
 	dev->is_fm_band =
 		f->frequency >= (bands[0].rangehigh + bands[1].rangelow) / 2;
-	clamp(f->frequency, bands[dev->is_fm_band].rangelow,
-			    bands[dev->is_fm_band].rangehigh);
 	cadet_setfreq(dev, f->frequency);
 	return 0;
 }

commit 8ca7080443dafdb67714ad0be36378639d002e6f
Author: Peter Senna Tschudin <peter.senna@gmail.com>
Date:   Thu Sep 6 11:23:52 2012 -0300

    [media] drivers/media/radio/radio-cadet.c: fix error return code
    
    Convert a nonnegative error return code to a negative one, as returned
    elsewhere in the function.
    A simplified version of the semantic match that finds this problem is as
    follows: (http://coccinelle.lip6.fr/)
    // <smpl>
    (
    if@p1 (\(ret < 0\|ret != 0\))
     { ... return ret; }
    |
    ret@p1 = 0
    )
    ... when != ret = e1
        when != &ret
    *if(...)
    {
      ... when != ret = e2
          when forall
     return ret;
    }
    // </smpl>
    
    Signed-off-by: Peter Senna Tschudin <peter.senna@gmail.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-cadet.c b/drivers/media/radio/radio-cadet.c
index 697a421c9940..643d80ac28fb 100644
--- a/drivers/media/radio/radio-cadet.c
+++ b/drivers/media/radio/radio-cadet.c
@@ -645,7 +645,8 @@ static int __init cadet_init(void)
 	set_bit(V4L2_FL_USE_FH_PRIO, &dev->vdev.flags);
 	video_set_drvdata(&dev->vdev, dev);
 
-	if (video_register_device(&dev->vdev, VFL_TYPE_RADIO, radio_nr) < 0)
+	res = video_register_device(&dev->vdev, VFL_TYPE_RADIO, radio_nr);
+	if (res < 0)
 		goto err_hdl;
 	v4l2_info(v4l2_dev, "ADS Cadet Radio Card at 0x%x\n", dev->io);
 	return 0;

commit 6652c716a5e46f0631d26a7f83a8f7247d293ae7
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Tue Jul 10 08:26:04 2012 -0300

    [media] radio-cadet: implement frequency band enumeration
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-cadet.c b/drivers/media/radio/radio-cadet.c
index d1fb42746fc2..697a421c9940 100644
--- a/drivers/media/radio/radio-cadet.c
+++ b/drivers/media/radio/radio-cadet.c
@@ -66,7 +66,8 @@ struct cadet {
 	struct video_device vdev;
 	struct v4l2_ctrl_handler ctrl_handler;
 	int io;
-	int curtuner;
+	bool is_fm_band;
+	u32 curfreq;
 	int tunestat;
 	int sigstrength;
 	wait_queue_head_t read_queue;
@@ -84,9 +85,9 @@ static struct cadet cadet_card;
  * The V4L API spec does not define any particular unit for the signal
  * strength value.  These values are in microvolts of RF at the tuner's input.
  */
-static __u16 sigtable[2][4] = {
+static u16 sigtable[2][4] = {
+	{ 1835, 2621,  4128, 65535 },
 	{ 2185, 4369, 13107, 65535 },
-	{ 1835, 2621,  4128, 65535 }
 };
 
 
@@ -94,7 +95,7 @@ static int cadet_getstereo(struct cadet *dev)
 {
 	int ret = V4L2_TUNER_SUB_MONO;
 
-	if (dev->curtuner != 0)	/* Only FM has stereo capability! */
+	if (!dev->is_fm_band)	/* Only FM has stereo capability! */
 		return V4L2_TUNER_SUB_MONO;
 
 	outb(7, dev->io);          /* Select tuner control */
@@ -149,20 +150,18 @@ static unsigned cadet_getfreq(struct cadet *dev)
 	/*
 	 * Convert to actual frequency
 	 */
-	if (dev->curtuner == 0) {    /* FM */
-		test = 12500;
-		for (i = 0; i < 14; i++) {
-			if ((fifo & 0x01) != 0)
-				freq += test;
-			test = test << 1;
-			fifo = fifo >> 1;
-		}
-		freq -= 10700000;           /* IF frequency is 10.7 MHz */
-		freq = (freq * 16) / 1000;   /* Make it 1/16 kHz */
+	if (!dev->is_fm_band)    /* AM */
+		return ((fifo & 0x7fff) - 450) * 16;
+
+	test = 12500;
+	for (i = 0; i < 14; i++) {
+		if ((fifo & 0x01) != 0)
+			freq += test;
+		test = test << 1;
+		fifo = fifo >> 1;
 	}
-	if (dev->curtuner == 1)    /* AM */
-		freq = ((fifo & 0x7fff) - 2010) * 16;
-
+	freq -= 10700000;           /* IF frequency is 10.7 MHz */
+	freq = (freq * 16) / 1000;   /* Make it 1/16 kHz */
 	return freq;
 }
 
@@ -197,11 +196,12 @@ static void cadet_setfreq(struct cadet *dev, unsigned freq)
 	int i, j, test;
 	int curvol;
 
+	dev->curfreq = freq;
 	/*
 	 * Formulate a fifo command
 	 */
 	fifo = 0;
-	if (dev->curtuner == 0) {    /* FM */
+	if (dev->is_fm_band) {    /* FM */
 		test = 102400;
 		freq = freq / 16;       /* Make it kHz */
 		freq += 10700;               /* IF is 10700 kHz */
@@ -213,10 +213,9 @@ static void cadet_setfreq(struct cadet *dev, unsigned freq)
 			}
 			test = test >> 1;
 		}
-	}
-	if (dev->curtuner == 1) {    /* AM */
-		fifo = (freq / 16) + 2010;            /* Make it kHz */
-		fifo |= 0x100000;            /* Select AM Band */
+	} else {	/* AM */
+		fifo = (freq / 16) + 450;	/* Make it kHz */
+		fifo |= 0x100000;		/* Select AM Band */
 	}
 
 	/*
@@ -239,7 +238,7 @@ static void cadet_setfreq(struct cadet *dev, unsigned freq)
 
 		cadet_gettune(dev);
 		if ((dev->tunestat & 0x40) == 0) {   /* Tuned */
-			dev->sigstrength = sigtable[dev->curtuner][j];
+			dev->sigstrength = sigtable[dev->is_fm_band][j];
 			goto reset_rds;
 		}
 	}
@@ -338,39 +337,52 @@ static int vidioc_querycap(struct file *file, void *priv,
 	return 0;
 }
 
+static const struct v4l2_frequency_band bands[] = {
+	{
+		.index = 0,
+		.type = V4L2_TUNER_RADIO,
+		.capability = V4L2_TUNER_CAP_LOW | V4L2_TUNER_CAP_FREQ_BANDS,
+		.rangelow = 8320,      /* 520 kHz */
+		.rangehigh = 26400,    /* 1650 kHz */
+		.modulation = V4L2_BAND_MODULATION_AM,
+	}, {
+		.index = 1,
+		.type = V4L2_TUNER_RADIO,
+		.capability = V4L2_TUNER_CAP_STEREO | V4L2_TUNER_CAP_RDS |
+			V4L2_TUNER_CAP_RDS_BLOCK_IO | V4L2_TUNER_CAP_LOW |
+			V4L2_TUNER_CAP_FREQ_BANDS,
+		.rangelow = 1400000,   /* 87.5 MHz */
+		.rangehigh = 1728000,  /* 108.0 MHz */
+		.modulation = V4L2_BAND_MODULATION_FM,
+	},
+};
+
 static int vidioc_g_tuner(struct file *file, void *priv,
 				struct v4l2_tuner *v)
 {
 	struct cadet *dev = video_drvdata(file);
 
+	if (v->index)
+		return -EINVAL;
 	v->type = V4L2_TUNER_RADIO;
-	switch (v->index) {
-	case 0:
-		strlcpy(v->name, "FM", sizeof(v->name));
-		v->capability = V4L2_TUNER_CAP_STEREO | V4L2_TUNER_CAP_RDS |
-			V4L2_TUNER_CAP_RDS_BLOCK_IO | V4L2_TUNER_CAP_LOW;
-		v->rangelow = 1400000;     /* 87.5 MHz */
-		v->rangehigh = 1728000;    /* 108.0 MHz */
+	strlcpy(v->name, "Radio", sizeof(v->name));
+	v->capability = bands[0].capability | bands[1].capability;
+	v->rangelow = bands[0].rangelow;	   /* 520 kHz (start of AM band) */
+	v->rangehigh = bands[1].rangehigh;    /* 108.0 MHz (end of FM band) */
+	if (dev->is_fm_band) {
 		v->rxsubchans = cadet_getstereo(dev);
-		v->audmode = V4L2_TUNER_MODE_STEREO;
 		outb(3, dev->io);
 		outb(inb(dev->io + 1) & 0x7f, dev->io + 1);
 		mdelay(100);
 		outb(3, dev->io);
 		if (inb(dev->io + 1) & 0x80)
 			v->rxsubchans |= V4L2_TUNER_SUB_RDS;
-		break;
-	case 1:
-		strlcpy(v->name, "AM", sizeof(v->name));
-		v->capability = V4L2_TUNER_CAP_LOW;
+	} else {
 		v->rangelow = 8320;      /* 520 kHz */
 		v->rangehigh = 26400;    /* 1650 kHz */
 		v->rxsubchans = V4L2_TUNER_SUB_MONO;
-		v->audmode = V4L2_TUNER_MODE_MONO;
-		break;
-	default:
-		return -EINVAL;
 	}
+	v->audmode = V4L2_TUNER_MODE_STEREO;
 	v->signal = dev->sigstrength; /* We might need to modify scaling of this */
 	return 0;
 }
@@ -378,8 +390,17 @@ static int vidioc_g_tuner(struct file *file, void *priv,
 static int vidioc_s_tuner(struct file *file, void *priv,
 				struct v4l2_tuner *v)
 {
-	if (v->index != 0 && v->index != 1)
+	return v->index ? -EINVAL : 0;
+}
+
+static int vidioc_enum_freq_bands(struct file *file, void *priv,
+				struct v4l2_frequency_band *band)
+{
+	if (band->tuner)
+		return -EINVAL;
+	if (band->index >= ARRAY_SIZE(bands))
 		return -EINVAL;
+	*band = bands[band->index];
 	return 0;
 }
 
@@ -388,10 +409,10 @@ static int vidioc_g_frequency(struct file *file, void *priv,
 {
 	struct cadet *dev = video_drvdata(file);
 
-	if (f->tuner > 1)
+	if (f->tuner)
 		return -EINVAL;
 	f->type = V4L2_TUNER_RADIO;
-	f->frequency = cadet_getfreq(dev);
+	f->frequency = dev->curfreq;
 	return 0;
 }
 
@@ -401,20 +422,12 @@ static int vidioc_s_frequency(struct file *file, void *priv,
 {
 	struct cadet *dev = video_drvdata(file);
 
-	if (f->type != V4L2_TUNER_RADIO)
-		return -EINVAL;
-	if (f->tuner == 0) {
-		if (f->frequency < 1400000)
-			f->frequency = 1400000;
-		else if (f->frequency > 1728000)
-			f->frequency = 1728000;
-	} else if (f->tuner == 1) {
-		if (f->frequency < 8320)
-			f->frequency = 8320;
-		else if (f->frequency > 26400)
-			f->frequency = 26400;
-	} else
+	if (f->tuner)
 		return -EINVAL;
+	dev->is_fm_band =
+		f->frequency >= (bands[0].rangehigh + bands[1].rangelow) / 2;
+	clamp(f->frequency, bands[dev->is_fm_band].rangelow,
+			    bands[dev->is_fm_band].rangehigh);
 	cadet_setfreq(dev, f->frequency);
 	return 0;
 }
@@ -499,6 +512,7 @@ static const struct v4l2_ioctl_ops cadet_ioctl_ops = {
 	.vidioc_s_tuner     = vidioc_s_tuner,
 	.vidioc_g_frequency = vidioc_g_frequency,
 	.vidioc_s_frequency = vidioc_s_frequency,
+	.vidioc_enum_freq_bands = vidioc_enum_freq_bands,
 	.vidioc_log_status  = v4l2_ctrl_log_status,
 	.vidioc_subscribe_event = v4l2_ctrl_subscribe_event,
 	.vidioc_unsubscribe_event = v4l2_event_unsubscribe,
@@ -555,8 +569,8 @@ static void cadet_probe(struct cadet *dev)
 	for (i = 0; i < 8; i++) {
 		dev->io = iovals[i];
 		if (request_region(dev->io, 2, "cadet-probe")) {
-			cadet_setfreq(dev, 1410);
-			if (cadet_getfreq(dev) == 1410) {
+			cadet_setfreq(dev, bands[1].rangelow);
+			if (cadet_getfreq(dev) == bands[1].rangelow) {
 				release_region(dev->io, 2);
 				return;
 			}
@@ -619,6 +633,9 @@ static int __init cadet_init(void)
 		goto err_hdl;
 	}
 
+	dev->is_fm_band = true;
+	dev->curfreq = bands[dev->is_fm_band].rangelow;
+	cadet_setfreq(dev, dev->curfreq);
 	strlcpy(dev->vdev.name, v4l2_dev->name, sizeof(dev->vdev.name));
 	dev->vdev.v4l2_dev = v4l2_dev;
 	dev->vdev.fops = &cadet_fops;

commit cc0d32665f9f8d4e7297a470e91b8848c7f0436c
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Mon Jul 2 09:46:46 2012 -0300

    [media] radio-cadet: fix RDS handling
    
    The current RDS code suffered from bit rot. Clean it up and make it work again.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-cadet.c b/drivers/media/radio/radio-cadet.c
index 93536b7e75c7..d1fb42746fc2 100644
--- a/drivers/media/radio/radio-cadet.c
+++ b/drivers/media/radio/radio-cadet.c
@@ -71,7 +71,7 @@ struct cadet {
 	int sigstrength;
 	wait_queue_head_t read_queue;
 	struct timer_list readtimer;
-	__u8 rdsin, rdsout, rdsstat;
+	u8 rdsin, rdsout, rdsstat;
 	unsigned char rdsbuf[RDS_BUFFER];
 	struct mutex lock;
 	int reading;
@@ -85,8 +85,8 @@ static struct cadet cadet_card;
  * strength value.  These values are in microvolts of RF at the tuner's input.
  */
 static __u16 sigtable[2][4] = {
-	{  5, 10, 30,  150 },
-	{ 28, 40, 63, 1000 }
+	{ 2185, 4369, 13107, 65535 },
+	{ 1835, 2621,  4128, 65535 }
 };
 
 
@@ -240,10 +240,13 @@ static void cadet_setfreq(struct cadet *dev, unsigned freq)
 		cadet_gettune(dev);
 		if ((dev->tunestat & 0x40) == 0) {   /* Tuned */
 			dev->sigstrength = sigtable[dev->curtuner][j];
-			return;
+			goto reset_rds;
 		}
 	}
 	dev->sigstrength = 0;
+reset_rds:
+	outb(3, dev->io);
+	outb(inb(dev->io + 1) & 0x7f, dev->io + 1);
 }
 
 
@@ -259,7 +262,7 @@ static void cadet_handler(unsigned long data)
 		outb(0x80, dev->io);      /* Select RDS fifo */
 		while ((inb(dev->io) & 0x80) != 0) {
 			dev->rdsbuf[dev->rdsin] = inb(dev->io + 1);
-			if (dev->rdsin == dev->rdsout)
+			if (dev->rdsin + 1 == dev->rdsout)
 				printk(KERN_WARNING "cadet: RDS buffer overflow\n");
 			else
 				dev->rdsin++;
@@ -278,11 +281,21 @@ static void cadet_handler(unsigned long data)
 	 */
 	init_timer(&dev->readtimer);
 	dev->readtimer.function = cadet_handler;
-	dev->readtimer.data = (unsigned long)0;
+	dev->readtimer.data = data;
 	dev->readtimer.expires = jiffies + msecs_to_jiffies(50);
 	add_timer(&dev->readtimer);
 }
 
+static void cadet_start_rds(struct cadet *dev)
+{
+	dev->rdsstat = 1;
+	outb(0x80, dev->io);        /* Select RDS fifo */
+	init_timer(&dev->readtimer);
+	dev->readtimer.function = cadet_handler;
+	dev->readtimer.data = (unsigned long)dev;
+	dev->readtimer.expires = jiffies + msecs_to_jiffies(50);
+	add_timer(&dev->readtimer);
+}
 
 static ssize_t cadet_read(struct file *file, char __user *data, size_t count, loff_t *ppos)
 {
@@ -291,26 +304,21 @@ static ssize_t cadet_read(struct file *file, char __user *data, size_t count, lo
 	int i = 0;
 
 	mutex_lock(&dev->lock);
-	if (dev->rdsstat == 0) {
-		dev->rdsstat = 1;
-		outb(0x80, dev->io);        /* Select RDS fifo */
-		init_timer(&dev->readtimer);
-		dev->readtimer.function = cadet_handler;
-		dev->readtimer.data = (unsigned long)dev;
-		dev->readtimer.expires = jiffies + msecs_to_jiffies(50);
-		add_timer(&dev->readtimer);
-	}
+	if (dev->rdsstat == 0)
+		cadet_start_rds(dev);
 	if (dev->rdsin == dev->rdsout) {
 		if (file->f_flags & O_NONBLOCK) {
 			i = -EWOULDBLOCK;
 			goto unlock;
 		}
+		mutex_unlock(&dev->lock);
 		interruptible_sleep_on(&dev->read_queue);
+		mutex_lock(&dev->lock);
 	}
 	while (i < count && dev->rdsin != dev->rdsout)
 		readbuf[i++] = dev->rdsbuf[dev->rdsout++];
 
-	if (copy_to_user(data, readbuf, i))
+	if (i && copy_to_user(data, readbuf, i))
 		i = -EFAULT;
 unlock:
 	mutex_unlock(&dev->lock);
@@ -345,7 +353,12 @@ static int vidioc_g_tuner(struct file *file, void *priv,
 		v->rangehigh = 1728000;    /* 108.0 MHz */
 		v->rxsubchans = cadet_getstereo(dev);
 		v->audmode = V4L2_TUNER_MODE_STEREO;
-		v->rxsubchans |= V4L2_TUNER_SUB_RDS;
+		outb(3, dev->io);
+		outb(inb(dev->io + 1) & 0x7f, dev->io + 1);
+		mdelay(100);
+		outb(3, dev->io);
+		if (inb(dev->io + 1) & 0x80)
+			v->rxsubchans |= V4L2_TUNER_SUB_RDS;
 		break;
 	case 1:
 		strlcpy(v->name, "AM", sizeof(v->name));
@@ -455,9 +468,16 @@ static int cadet_release(struct file *file)
 static unsigned int cadet_poll(struct file *file, struct poll_table_struct *wait)
 {
 	struct cadet *dev = video_drvdata(file);
+	unsigned long req_events = poll_requested_events(wait);
 	unsigned int res = v4l2_ctrl_poll(file, wait);
 
 	poll_wait(file, &dev->read_queue, wait);
+	if (dev->rdsstat == 0 && (req_events & (POLLIN | POLLRDNORM))) {
+		mutex_lock(&dev->lock);
+		if (dev->rdsstat == 0)
+			cadet_start_rds(dev);
+		mutex_unlock(&dev->lock);
+	}
 	if (dev->rdsin != dev->rdsout)
 		res |= POLLIN | POLLRDNORM;
 	return res;
@@ -628,6 +648,8 @@ static void __exit cadet_exit(void)
 	video_unregister_device(&dev->vdev);
 	v4l2_ctrl_handler_free(&dev->ctrl_handler);
 	v4l2_device_unregister(&dev->v4l2_dev);
+	outb(7, dev->io);	/* Mute */
+	outb(0x00, dev->io + 1);
 	release_region(dev->io, 2);
 	pnp_unregister_driver(&cadet_pnp_driver);
 }

commit b54c97db7f51c47c361533956db18c8b191033b5
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Mon Jul 2 09:36:39 2012 -0300

    [media] radio-cadet: upgrade to latest frameworks
    
    - add control framework
    - use core locking
    - use V4L2_TUNER_CAP_LOW
    - remove volume support: there is no hardware volume control
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-cadet.c b/drivers/media/radio/radio-cadet.c
index 16a089fad909..93536b7e75c7 100644
--- a/drivers/media/radio/radio-cadet.c
+++ b/drivers/media/radio/radio-cadet.c
@@ -41,6 +41,9 @@
 #include <linux/io.h>		/* outb, outb_p			*/
 #include <media/v4l2-device.h>
 #include <media/v4l2-ioctl.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-fh.h>
+#include <media/v4l2-event.h>
 
 MODULE_AUTHOR("Fred Gleason, Russell Kroll, Quay Lu, Donald Song, Jason Lewis, Scott McGrath, William McGrath");
 MODULE_DESCRIPTION("A driver for the ADS Cadet AM/FM/RDS radio card.");
@@ -61,8 +64,8 @@ module_param(radio_nr, int, 0);
 struct cadet {
 	struct v4l2_device v4l2_dev;
 	struct video_device vdev;
+	struct v4l2_ctrl_handler ctrl_handler;
 	int io;
-	int users;
 	int curtuner;
 	int tunestat;
 	int sigstrength;
@@ -94,11 +97,9 @@ static int cadet_getstereo(struct cadet *dev)
 	if (dev->curtuner != 0)	/* Only FM has stereo capability! */
 		return V4L2_TUNER_SUB_MONO;
 
-	mutex_lock(&dev->lock);
 	outb(7, dev->io);          /* Select tuner control */
 	if ((inb(dev->io + 1) & 0x40) == 0)
 		ret = V4L2_TUNER_SUB_STEREO;
-	mutex_unlock(&dev->lock);
 	return ret;
 }
 
@@ -111,8 +112,6 @@ static unsigned cadet_gettune(struct cadet *dev)
 	 * Prepare for read
 	 */
 
-	mutex_lock(&dev->lock);
-
 	outb(7, dev->io);       /* Select tuner control */
 	curvol = inb(dev->io + 1); /* Save current volume/mute setting */
 	outb(0x00, dev->io + 1);  /* Ensure WRITE-ENABLE is LOW */
@@ -134,8 +133,6 @@ static unsigned cadet_gettune(struct cadet *dev)
 	 * Restore volume/mute setting
 	 */
 	outb(curvol, dev->io + 1);
-	mutex_unlock(&dev->lock);
-
 	return fifo;
 }
 
@@ -161,7 +158,7 @@ static unsigned cadet_getfreq(struct cadet *dev)
 			fifo = fifo >> 1;
 		}
 		freq -= 10700000;           /* IF frequency is 10.7 MHz */
-		freq = (freq * 16) / 1000000;   /* Make it 1/16 MHz */
+		freq = (freq * 16) / 1000;   /* Make it 1/16 kHz */
 	}
 	if (dev->curtuner == 1)    /* AM */
 		freq = ((fifo & 0x7fff) - 2010) * 16;
@@ -174,8 +171,6 @@ static void cadet_settune(struct cadet *dev, unsigned fifo)
 	int i;
 	unsigned test;
 
-	mutex_lock(&dev->lock);
-
 	outb(7, dev->io);                /* Select tuner control */
 	/*
 	 * Write the shift register
@@ -194,7 +189,6 @@ static void cadet_settune(struct cadet *dev, unsigned fifo)
 		test = 0x1c | ((fifo >> 23) & 0x02);
 		outb(test, dev->io + 1);
 	}
-	mutex_unlock(&dev->lock);
 }
 
 static void cadet_setfreq(struct cadet *dev, unsigned freq)
@@ -209,7 +203,7 @@ static void cadet_setfreq(struct cadet *dev, unsigned freq)
 	fifo = 0;
 	if (dev->curtuner == 0) {    /* FM */
 		test = 102400;
-		freq = (freq * 1000) / 16;       /* Make it kHz */
+		freq = freq / 16;       /* Make it kHz */
 		freq += 10700;               /* IF is 10700 kHz */
 		for (i = 0; i < 14; i++) {
 			fifo = fifo << 1;
@@ -229,10 +223,8 @@ static void cadet_setfreq(struct cadet *dev, unsigned freq)
 	 * Save current volume/mute setting
 	 */
 
-	mutex_lock(&dev->lock);
 	outb(7, dev->io);                /* Select tuner control */
 	curvol = inb(dev->io + 1);
-	mutex_unlock(&dev->lock);
 
 	/*
 	 * Tune the card
@@ -240,10 +232,8 @@ static void cadet_setfreq(struct cadet *dev, unsigned freq)
 	for (j = 3; j > -1; j--) {
 		cadet_settune(dev, fifo | (j << 16));
 
-		mutex_lock(&dev->lock);
 		outb(7, dev->io);         /* Select tuner control */
 		outb(curvol, dev->io + 1);
-		mutex_unlock(&dev->lock);
 
 		msleep(100);
 
@@ -257,32 +247,6 @@ static void cadet_setfreq(struct cadet *dev, unsigned freq)
 }
 
 
-static int cadet_getvol(struct cadet *dev)
-{
-	int ret = 0;
-
-	mutex_lock(&dev->lock);
-
-	outb(7, dev->io);                /* Select tuner control */
-	if ((inb(dev->io + 1) & 0x20) != 0)
-		ret = 0xffff;
-
-	mutex_unlock(&dev->lock);
-	return ret;
-}
-
-
-static void cadet_setvol(struct cadet *dev, int vol)
-{
-	mutex_lock(&dev->lock);
-	outb(7, dev->io);                /* Select tuner control */
-	if (vol > 0)
-		outb(0x20, dev->io + 1);
-	else
-		outb(0x00, dev->io + 1);
-	mutex_unlock(&dev->lock);
-}
-
 static void cadet_handler(unsigned long data)
 {
 	struct cadet *dev = (void *)data;
@@ -337,18 +301,19 @@ static ssize_t cadet_read(struct file *file, char __user *data, size_t count, lo
 		add_timer(&dev->readtimer);
 	}
 	if (dev->rdsin == dev->rdsout) {
-		mutex_unlock(&dev->lock);
-		if (file->f_flags & O_NONBLOCK)
-			return -EWOULDBLOCK;
+		if (file->f_flags & O_NONBLOCK) {
+			i = -EWOULDBLOCK;
+			goto unlock;
+		}
 		interruptible_sleep_on(&dev->read_queue);
-		mutex_lock(&dev->lock);
 	}
 	while (i < count && dev->rdsin != dev->rdsout)
 		readbuf[i++] = dev->rdsbuf[dev->rdsout++];
-	mutex_unlock(&dev->lock);
 
 	if (copy_to_user(data, readbuf, i))
-		return -EFAULT;
+		i = -EFAULT;
+unlock:
+	mutex_unlock(&dev->lock);
 	return i;
 }
 
@@ -359,8 +324,9 @@ static int vidioc_querycap(struct file *file, void *priv,
 	strlcpy(v->driver, "ADS Cadet", sizeof(v->driver));
 	strlcpy(v->card, "ADS Cadet", sizeof(v->card));
 	strlcpy(v->bus_info, "ISA", sizeof(v->bus_info));
-	v->capabilities = V4L2_CAP_TUNER | V4L2_CAP_RADIO |
+	v->device_caps = V4L2_CAP_TUNER | V4L2_CAP_RADIO |
 			  V4L2_CAP_READWRITE | V4L2_CAP_RDS_CAPTURE;
+	v->capabilities = v->device_caps | V4L2_CAP_DEVICE_CAPS;
 	return 0;
 }
 
@@ -374,20 +340,11 @@ static int vidioc_g_tuner(struct file *file, void *priv,
 	case 0:
 		strlcpy(v->name, "FM", sizeof(v->name));
 		v->capability = V4L2_TUNER_CAP_STEREO | V4L2_TUNER_CAP_RDS |
-			V4L2_TUNER_CAP_RDS_BLOCK_IO;
-		v->rangelow = 1400;     /* 87.5 MHz */
-		v->rangehigh = 1728;    /* 108.0 MHz */
+			V4L2_TUNER_CAP_RDS_BLOCK_IO | V4L2_TUNER_CAP_LOW;
+		v->rangelow = 1400000;     /* 87.5 MHz */
+		v->rangehigh = 1728000;    /* 108.0 MHz */
 		v->rxsubchans = cadet_getstereo(dev);
-		switch (v->rxsubchans) {
-		case V4L2_TUNER_SUB_MONO:
-			v->audmode = V4L2_TUNER_MODE_MONO;
-			break;
-		case V4L2_TUNER_SUB_STEREO:
-			v->audmode = V4L2_TUNER_MODE_STEREO;
-			break;
-		default:
-			break;
-		}
+		v->audmode = V4L2_TUNER_MODE_STEREO;
 		v->rxsubchans |= V4L2_TUNER_SUB_RDS;
 		break;
 	case 1:
@@ -408,11 +365,8 @@ static int vidioc_g_tuner(struct file *file, void *priv,
 static int vidioc_s_tuner(struct file *file, void *priv,
 				struct v4l2_tuner *v)
 {
-	struct cadet *dev = video_drvdata(file);
-
 	if (v->index != 0 && v->index != 1)
 		return -EINVAL;
-	dev->curtuner = v->index;
 	return 0;
 }
 
@@ -421,7 +375,8 @@ static int vidioc_g_frequency(struct file *file, void *priv,
 {
 	struct cadet *dev = video_drvdata(file);
 
-	f->tuner = dev->curtuner;
+	if (f->tuner > 1)
+		return -EINVAL;
 	f->type = V4L2_TUNER_RADIO;
 	f->frequency = cadet_getfreq(dev);
 	return 0;
@@ -435,101 +390,52 @@ static int vidioc_s_frequency(struct file *file, void *priv,
 
 	if (f->type != V4L2_TUNER_RADIO)
 		return -EINVAL;
-	if (dev->curtuner == 0 && (f->frequency < 1400 || f->frequency > 1728))
-		return -EINVAL;
-	if (dev->curtuner == 1 && (f->frequency < 8320 || f->frequency > 26400))
+	if (f->tuner == 0) {
+		if (f->frequency < 1400000)
+			f->frequency = 1400000;
+		else if (f->frequency > 1728000)
+			f->frequency = 1728000;
+	} else if (f->tuner == 1) {
+		if (f->frequency < 8320)
+			f->frequency = 8320;
+		else if (f->frequency > 26400)
+			f->frequency = 26400;
+	} else
 		return -EINVAL;
 	cadet_setfreq(dev, f->frequency);
 	return 0;
 }
 
-static int vidioc_queryctrl(struct file *file, void *priv,
-				struct v4l2_queryctrl *qc)
+static int cadet_s_ctrl(struct v4l2_ctrl *ctrl)
 {
-	switch (qc->id) {
-	case V4L2_CID_AUDIO_MUTE:
-		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 1);
-	case V4L2_CID_AUDIO_VOLUME:
-		return v4l2_ctrl_query_fill(qc, 0, 0xff, 1, 0xff);
-	}
-	return -EINVAL;
-}
-
-static int vidioc_g_ctrl(struct file *file, void *priv,
-				struct v4l2_control *ctrl)
-{
-	struct cadet *dev = video_drvdata(file);
+	struct cadet *dev = container_of(ctrl->handler, struct cadet, ctrl_handler);
 
 	switch (ctrl->id) {
-	case V4L2_CID_AUDIO_MUTE: /* TODO: Handle this correctly */
-		ctrl->value = (cadet_getvol(dev) == 0);
-		break;
-	case V4L2_CID_AUDIO_VOLUME:
-		ctrl->value = cadet_getvol(dev);
-		break;
-	default:
-		return -EINVAL;
-	}
-	return 0;
-}
-
-static int vidioc_s_ctrl(struct file *file, void *priv,
-				struct v4l2_control *ctrl)
-{
-	struct cadet *dev = video_drvdata(file);
-
-	switch (ctrl->id){
-	case V4L2_CID_AUDIO_MUTE: /* TODO: Handle this correctly */
-		if (ctrl->value)
-			cadet_setvol(dev, 0);
+	case V4L2_CID_AUDIO_MUTE:
+		outb(7, dev->io);                /* Select tuner control */
+		if (ctrl->val)
+			outb(0x00, dev->io + 1);
 		else
-			cadet_setvol(dev, 0xffff);
-		break;
-	case V4L2_CID_AUDIO_VOLUME:
-		cadet_setvol(dev, ctrl->value);
-		break;
-	default:
-		return -EINVAL;
+			outb(0x20, dev->io + 1);
+		return 0;
 	}
-	return 0;
-}
-
-static int vidioc_g_input(struct file *filp, void *priv, unsigned int *i)
-{
-	*i = 0;
-	return 0;
-}
-
-static int vidioc_s_input(struct file *filp, void *priv, unsigned int i)
-{
-	return i ? -EINVAL : 0;
-}
-
-static int vidioc_g_audio(struct file *file, void *priv,
-				struct v4l2_audio *a)
-{
-	a->index = 0;
-	strlcpy(a->name, "Radio", sizeof(a->name));
-	a->capability = V4L2_AUDCAP_STEREO;
-	return 0;
-}
-
-static int vidioc_s_audio(struct file *file, void *priv,
-				struct v4l2_audio *a)
-{
-	return a->index ? -EINVAL : 0;
+	return -EINVAL;
 }
 
 static int cadet_open(struct file *file)
 {
 	struct cadet *dev = video_drvdata(file);
+	int err;
 
 	mutex_lock(&dev->lock);
-	dev->users++;
-	if (1 == dev->users)
+	err = v4l2_fh_open(file);
+	if (err)
+		goto fail;
+	if (v4l2_fh_is_singular_file(file))
 		init_waitqueue_head(&dev->read_queue);
+fail:
 	mutex_unlock(&dev->lock);
-	return 0;
+	return err;
 }
 
 static int cadet_release(struct file *file)
@@ -537,11 +443,11 @@ static int cadet_release(struct file *file)
 	struct cadet *dev = video_drvdata(file);
 
 	mutex_lock(&dev->lock);
-	dev->users--;
-	if (0 == dev->users) {
+	if (v4l2_fh_is_singular_file(file) && dev->rdsstat) {
 		del_timer_sync(&dev->readtimer);
 		dev->rdsstat = 0;
 	}
+	v4l2_fh_release(file);
 	mutex_unlock(&dev->lock);
 	return 0;
 }
@@ -549,11 +455,12 @@ static int cadet_release(struct file *file)
 static unsigned int cadet_poll(struct file *file, struct poll_table_struct *wait)
 {
 	struct cadet *dev = video_drvdata(file);
+	unsigned int res = v4l2_ctrl_poll(file, wait);
 
 	poll_wait(file, &dev->read_queue, wait);
 	if (dev->rdsin != dev->rdsout)
-		return POLLIN | POLLRDNORM;
-	return 0;
+		res |= POLLIN | POLLRDNORM;
+	return res;
 }
 
 
@@ -572,13 +479,13 @@ static const struct v4l2_ioctl_ops cadet_ioctl_ops = {
 	.vidioc_s_tuner     = vidioc_s_tuner,
 	.vidioc_g_frequency = vidioc_g_frequency,
 	.vidioc_s_frequency = vidioc_s_frequency,
-	.vidioc_queryctrl   = vidioc_queryctrl,
-	.vidioc_g_ctrl      = vidioc_g_ctrl,
-	.vidioc_s_ctrl      = vidioc_s_ctrl,
-	.vidioc_g_audio     = vidioc_g_audio,
-	.vidioc_s_audio     = vidioc_s_audio,
-	.vidioc_g_input     = vidioc_g_input,
-	.vidioc_s_input     = vidioc_s_input,
+	.vidioc_log_status  = v4l2_ctrl_log_status,
+	.vidioc_subscribe_event = v4l2_ctrl_subscribe_event,
+	.vidioc_unsubscribe_event = v4l2_event_unsubscribe,
+};
+
+static const struct v4l2_ctrl_ops cadet_ctrl_ops = {
+	.s_ctrl = cadet_s_ctrl,
 };
 
 #ifdef CONFIG_PNP
@@ -648,7 +555,8 @@ static int __init cadet_init(void)
 {
 	struct cadet *dev = &cadet_card;
 	struct v4l2_device *v4l2_dev = &dev->v4l2_dev;
-	int res;
+	struct v4l2_ctrl_handler *hdl;
+	int res = -ENODEV;
 
 	strlcpy(v4l2_dev->name, "cadet", sizeof(v4l2_dev->name));
 	mutex_init(&dev->lock);
@@ -680,23 +588,37 @@ static int __init cadet_init(void)
 		goto fail;
 	}
 
+	hdl = &dev->ctrl_handler;
+	v4l2_ctrl_handler_init(hdl, 2);
+	v4l2_ctrl_new_std(hdl, &cadet_ctrl_ops,
+			V4L2_CID_AUDIO_MUTE, 0, 1, 1, 1);
+	v4l2_dev->ctrl_handler = hdl;
+	if (hdl->error) {
+		res = hdl->error;
+		v4l2_err(v4l2_dev, "Could not register controls\n");
+		goto err_hdl;
+	}
+
 	strlcpy(dev->vdev.name, v4l2_dev->name, sizeof(dev->vdev.name));
 	dev->vdev.v4l2_dev = v4l2_dev;
 	dev->vdev.fops = &cadet_fops;
 	dev->vdev.ioctl_ops = &cadet_ioctl_ops;
 	dev->vdev.release = video_device_release_empty;
+	dev->vdev.lock = &dev->lock;
+	set_bit(V4L2_FL_USE_FH_PRIO, &dev->vdev.flags);
 	video_set_drvdata(&dev->vdev, dev);
 
-	if (video_register_device(&dev->vdev, VFL_TYPE_RADIO, radio_nr) < 0) {
-		v4l2_device_unregister(v4l2_dev);
-		release_region(dev->io, 2);
-		goto fail;
-	}
+	if (video_register_device(&dev->vdev, VFL_TYPE_RADIO, radio_nr) < 0)
+		goto err_hdl;
 	v4l2_info(v4l2_dev, "ADS Cadet Radio Card at 0x%x\n", dev->io);
 	return 0;
+err_hdl:
+	v4l2_ctrl_handler_free(hdl);
+	v4l2_device_unregister(v4l2_dev);
+	release_region(dev->io, 2);
 fail:
 	pnp_unregister_driver(&cadet_pnp_driver);
-	return -ENODEV;
+	return res;
 }
 
 static void __exit cadet_exit(void)
@@ -704,6 +626,7 @@ static void __exit cadet_exit(void)
 	struct cadet *dev = &cadet_card;
 
 	video_unregister_device(&dev->vdev);
+	v4l2_ctrl_handler_free(&dev->ctrl_handler);
 	v4l2_device_unregister(&dev->v4l2_dev);
 	release_region(dev->io, 2);
 	pnp_unregister_driver(&cadet_pnp_driver);

commit 29834c1ac7589c72996c5d02349d63fd397ef131
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Sat Jun 25 10:15:42 2011 -0300

    [media] radio: Use the subsystem version control for VIDIOC_QUERYCAP
    
    Just like the video drivers, the right thing to do is to use
    the per-subsystem version control.
    
    Acked-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-cadet.c b/drivers/media/radio/radio-cadet.c
index bc9ad0897c55..16a089fad909 100644
--- a/drivers/media/radio/radio-cadet.c
+++ b/drivers/media/radio/radio-cadet.c
@@ -30,7 +30,6 @@
  *		Changed API to V4L2
  */
 
-#include <linux/version.h>
 #include <linux/module.h>	/* Modules 			*/
 #include <linux/init.h>		/* Initdata			*/
 #include <linux/ioport.h>	/* request_region		*/
@@ -46,6 +45,7 @@
 MODULE_AUTHOR("Fred Gleason, Russell Kroll, Quay Lu, Donald Song, Jason Lewis, Scott McGrath, William McGrath");
 MODULE_DESCRIPTION("A driver for the ADS Cadet AM/FM/RDS radio card.");
 MODULE_LICENSE("GPL");
+MODULE_VERSION("0.3.4");
 
 static int io = -1;		/* default to isapnp activation */
 static int radio_nr = -1;
@@ -54,8 +54,6 @@ module_param(io, int, 0);
 MODULE_PARM_DESC(io, "I/O address of Cadet card (0x330,0x332,0x334,0x336,0x338,0x33a,0x33c,0x33e)");
 module_param(radio_nr, int, 0);
 
-#define CADET_VERSION KERNEL_VERSION(0, 3, 3)
-
 #define RDS_BUFFER 256
 #define RDS_RX_FLAG 1
 #define MBS_RX_FLAG 2
@@ -361,7 +359,6 @@ static int vidioc_querycap(struct file *file, void *priv,
 	strlcpy(v->driver, "ADS Cadet", sizeof(v->driver));
 	strlcpy(v->card, "ADS Cadet", sizeof(v->card));
 	strlcpy(v->bus_info, "ISA", sizeof(v->bus_info));
-	v->version = CADET_VERSION;
 	v->capabilities = V4L2_CAP_TUNER | V4L2_CAP_RADIO |
 			  V4L2_CAP_READWRITE | V4L2_CAP_RDS_CAPTURE;
 	return 0;

commit 1cccee0b84e3445a142d0e9edcbf66b677b2e7e5
Author: Hans Verkuil <hverkuil@xs4all.nl>
Date:   Sun Nov 14 09:43:52 2010 -0300

    [media] cadet: use unlocked_ioctl
    
    Converted from ioctl to unlocked_ioctl.
    
    This driver already used an internal lock, but it was missing in cadet_open and
    cadet_release and it was not used correctly in cadet_read.
    
    Signed-off-by: Hans Verkuil <hverkuil@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-cadet.c b/drivers/media/radio/radio-cadet.c
index b701ea6e7c73..bc9ad0897c55 100644
--- a/drivers/media/radio/radio-cadet.c
+++ b/drivers/media/radio/radio-cadet.c
@@ -328,11 +328,10 @@ static ssize_t cadet_read(struct file *file, char __user *data, size_t count, lo
 	unsigned char readbuf[RDS_BUFFER];
 	int i = 0;
 
+	mutex_lock(&dev->lock);
 	if (dev->rdsstat == 0) {
-		mutex_lock(&dev->lock);
 		dev->rdsstat = 1;
 		outb(0x80, dev->io);        /* Select RDS fifo */
-		mutex_unlock(&dev->lock);
 		init_timer(&dev->readtimer);
 		dev->readtimer.function = cadet_handler;
 		dev->readtimer.data = (unsigned long)dev;
@@ -340,12 +339,15 @@ static ssize_t cadet_read(struct file *file, char __user *data, size_t count, lo
 		add_timer(&dev->readtimer);
 	}
 	if (dev->rdsin == dev->rdsout) {
+		mutex_unlock(&dev->lock);
 		if (file->f_flags & O_NONBLOCK)
 			return -EWOULDBLOCK;
 		interruptible_sleep_on(&dev->read_queue);
+		mutex_lock(&dev->lock);
 	}
 	while (i < count && dev->rdsin != dev->rdsout)
 		readbuf[i++] = dev->rdsbuf[dev->rdsout++];
+	mutex_unlock(&dev->lock);
 
 	if (copy_to_user(data, readbuf, i))
 		return -EFAULT;
@@ -525,9 +527,11 @@ static int cadet_open(struct file *file)
 {
 	struct cadet *dev = video_drvdata(file);
 
+	mutex_lock(&dev->lock);
 	dev->users++;
 	if (1 == dev->users)
 		init_waitqueue_head(&dev->read_queue);
+	mutex_unlock(&dev->lock);
 	return 0;
 }
 
@@ -535,11 +539,13 @@ static int cadet_release(struct file *file)
 {
 	struct cadet *dev = video_drvdata(file);
 
+	mutex_lock(&dev->lock);
 	dev->users--;
 	if (0 == dev->users) {
 		del_timer_sync(&dev->readtimer);
 		dev->rdsstat = 0;
 	}
+	mutex_unlock(&dev->lock);
 	return 0;
 }
 
@@ -559,7 +565,7 @@ static const struct v4l2_file_operations cadet_fops = {
 	.open		= cadet_open,
 	.release       	= cadet_release,
 	.read		= cadet_read,
-	.ioctl		= video_ioctl2,
+	.unlocked_ioctl	= video_ioctl2,
 	.poll		= cadet_poll,
 };
 

commit cb0ed22270129b980257fa9c83b152f09ecd9eda
Author: Matti Aaltonen <matti.j.aaltonen@nokia.com>
Date:   Mon Oct 18 06:54:14 2010 -0300

    [media] [RFC,1/1] V4L2: Use new CAP bits in existing RDS capable drivers
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-cadet.c b/drivers/media/radio/radio-cadet.c
index 482d0f3be5ff..b701ea6e7c73 100644
--- a/drivers/media/radio/radio-cadet.c
+++ b/drivers/media/radio/radio-cadet.c
@@ -374,7 +374,8 @@ static int vidioc_g_tuner(struct file *file, void *priv,
 	switch (v->index) {
 	case 0:
 		strlcpy(v->name, "FM", sizeof(v->name));
-		v->capability = V4L2_TUNER_CAP_STEREO | V4L2_TUNER_CAP_RDS;
+		v->capability = V4L2_TUNER_CAP_STEREO | V4L2_TUNER_CAP_RDS |
+			V4L2_TUNER_CAP_RDS_BLOCK_IO;
 		v->rangelow = 1400;     /* 87.5 MHz */
 		v->rangehigh = 1728;    /* 108.0 MHz */
 		v->rxsubchans = cadet_getstereo(dev);

commit a99bbaf5ee6bad1aca0c88ea65ec6e5373e86184
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Sun Oct 4 16:11:37 2009 +0400

    headers: remove sched.h from poll.h
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/media/radio/radio-cadet.c b/drivers/media/radio/radio-cadet.c
index 8b1440136c45..482d0f3be5ff 100644
--- a/drivers/media/radio/radio-cadet.c
+++ b/drivers/media/radio/radio-cadet.c
@@ -38,6 +38,7 @@
 #include <linux/videodev2.h>	/* V4L2 API defs		*/
 #include <linux/param.h>
 #include <linux/pnp.h>
+#include <linux/sched.h>
 #include <linux/io.h>		/* outb, outb_p			*/
 #include <media/v4l2-device.h>
 #include <media/v4l2-ioctl.h>

commit 8e280f24d33dbe7dab719978dfc2f266af76c8af
Author: Hans Verkuil <hverkuil@xs4all.nl>
Date:   Sat Jun 20 06:19:09 2009 -0300

    V4L/DVB (12217): radio-cadet: conform to the RDS spec.
    
    Signed-off-by: Hans Verkuil <hverkuil@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-cadet.c b/drivers/media/radio/radio-cadet.c
index d30fc0ce82c0..8b1440136c45 100644
--- a/drivers/media/radio/radio-cadet.c
+++ b/drivers/media/radio/radio-cadet.c
@@ -359,7 +359,8 @@ static int vidioc_querycap(struct file *file, void *priv,
 	strlcpy(v->card, "ADS Cadet", sizeof(v->card));
 	strlcpy(v->bus_info, "ISA", sizeof(v->bus_info));
 	v->version = CADET_VERSION;
-	v->capabilities = V4L2_CAP_TUNER | V4L2_CAP_RADIO | V4L2_CAP_READWRITE;
+	v->capabilities = V4L2_CAP_TUNER | V4L2_CAP_RADIO |
+			  V4L2_CAP_READWRITE | V4L2_CAP_RDS_CAPTURE;
 	return 0;
 }
 
@@ -372,7 +373,7 @@ static int vidioc_g_tuner(struct file *file, void *priv,
 	switch (v->index) {
 	case 0:
 		strlcpy(v->name, "FM", sizeof(v->name));
-		v->capability = V4L2_TUNER_CAP_STEREO;
+		v->capability = V4L2_TUNER_CAP_STEREO | V4L2_TUNER_CAP_RDS;
 		v->rangelow = 1400;     /* 87.5 MHz */
 		v->rangehigh = 1728;    /* 108.0 MHz */
 		v->rxsubchans = cadet_getstereo(dev);
@@ -386,6 +387,7 @@ static int vidioc_g_tuner(struct file *file, void *priv,
 		default:
 			break;
 		}
+		v->rxsubchans |= V4L2_TUNER_SUB_RDS;
 		break;
 	case 1:
 		strlcpy(v->name, "AM", sizeof(v->name));

commit ab84f5736086b84d99015cd82515a31b95e03f48
Author: Hans Verkuil <hverkuil@xs4all.nl>
Date:   Wed Mar 11 04:25:47 2009 -0300

    V4L/DVB (10959): radio: remove uaccess include
    
    This include isn't needed and so can be removed.
    
    Signed-off-by: Hans Verkuil <hverkuil@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-cadet.c b/drivers/media/radio/radio-cadet.c
index 4627c5a662ee..d30fc0ce82c0 100644
--- a/drivers/media/radio/radio-cadet.c
+++ b/drivers/media/radio/radio-cadet.c
@@ -39,7 +39,6 @@
 #include <linux/param.h>
 #include <linux/pnp.h>
 #include <linux/io.h>		/* outb, outb_p			*/
-#include <linux/uaccess.h>	/* copy to/from user		*/
 #include <media/v4l2-device.h>
 #include <media/v4l2-ioctl.h>
 

commit b24c20cc5b3a4c6e2ec8d6145d2c1f9920cab3f4
Author: Hans Verkuil <hverkuil@xs4all.nl>
Date:   Mon Mar 9 08:11:21 2009 -0300

    V4L/DVB (10894): ISA radio drivers: improve kernel log message
    
    It's much nicer if the log message tells you which io ports are possible,
    rather than having to run modinfo or look it up in the source or manual.
    
    Signed-off-by: Hans Verkuil <hverkuil@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-cadet.c b/drivers/media/radio/radio-cadet.c
index 7741f33ce873..4627c5a662ee 100644
--- a/drivers/media/radio/radio-cadet.c
+++ b/drivers/media/radio/radio-cadet.c
@@ -659,7 +659,8 @@ static int __init cadet_init(void)
 	/* Else we bail out */
 	if (dev->io < 0) {
 #ifdef MODULE
-		v4l2_err(v4l2_dev, "you must set an I/O address with io=0x???\n");
+		v4l2_err(v4l2_dev, "you must set an I/O address with io=0x330, 0x332, 0x334,\n");
+		v4l2_err(v4l2_dev, "0x336, 0x338, 0x33a, 0x33c or 0x33e\n");
 #endif
 		goto fail;
 	}

commit bec2aec56561b70787ef62f070988594bd6d1b5f
Author: Hans Verkuil <hverkuil@xs4all.nl>
Date:   Fri Mar 6 13:48:47 2009 -0300

    V4L/DVB (10882): radio-cadet: convert to v4l2_device.
    
    Signed-off-by: Hans Verkuil <hverkuil@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-cadet.c b/drivers/media/radio/radio-cadet.c
index cb3075ac104c..7741f33ce873 100644
--- a/drivers/media/radio/radio-cadet.c
+++ b/drivers/media/radio/radio-cadet.c
@@ -35,333 +35,319 @@
 #include <linux/init.h>		/* Initdata			*/
 #include <linux/ioport.h>	/* request_region		*/
 #include <linux/delay.h>	/* udelay			*/
-#include <asm/io.h>		/* outb, outb_p			*/
-#include <asm/uaccess.h>	/* copy to/from user		*/
 #include <linux/videodev2.h>	/* V4L2 API defs		*/
-#include <media/v4l2-common.h>
-#include <media/v4l2-ioctl.h>
 #include <linux/param.h>
 #include <linux/pnp.h>
+#include <linux/io.h>		/* outb, outb_p			*/
+#include <linux/uaccess.h>	/* copy to/from user		*/
+#include <media/v4l2-device.h>
+#include <media/v4l2-ioctl.h>
+
+MODULE_AUTHOR("Fred Gleason, Russell Kroll, Quay Lu, Donald Song, Jason Lewis, Scott McGrath, William McGrath");
+MODULE_DESCRIPTION("A driver for the ADS Cadet AM/FM/RDS radio card.");
+MODULE_LICENSE("GPL");
+
+static int io = -1;		/* default to isapnp activation */
+static int radio_nr = -1;
+
+module_param(io, int, 0);
+MODULE_PARM_DESC(io, "I/O address of Cadet card (0x330,0x332,0x334,0x336,0x338,0x33a,0x33c,0x33e)");
+module_param(radio_nr, int, 0);
+
+#define CADET_VERSION KERNEL_VERSION(0, 3, 3)
 
 #define RDS_BUFFER 256
 #define RDS_RX_FLAG 1
 #define MBS_RX_FLAG 2
 
-#define CADET_VERSION KERNEL_VERSION(0,3,3)
-
-static struct v4l2_queryctrl radio_qctrl[] = {
-	{
-		.id            = V4L2_CID_AUDIO_MUTE,
-		.name          = "Mute",
-		.minimum       = 0,
-		.maximum       = 1,
-		.default_value = 1,
-		.type          = V4L2_CTRL_TYPE_BOOLEAN,
-	},{
-		.id            = V4L2_CID_AUDIO_VOLUME,
-		.name          = "Volume",
-		.minimum       = 0,
-		.maximum       = 0xff,
-		.step          = 1,
-		.default_value = 0xff,
-		.type          = V4L2_CTRL_TYPE_INTEGER,
-	}
+struct cadet {
+	struct v4l2_device v4l2_dev;
+	struct video_device vdev;
+	int io;
+	int users;
+	int curtuner;
+	int tunestat;
+	int sigstrength;
+	wait_queue_head_t read_queue;
+	struct timer_list readtimer;
+	__u8 rdsin, rdsout, rdsstat;
+	unsigned char rdsbuf[RDS_BUFFER];
+	struct mutex lock;
+	int reading;
 };
 
-static int io=-1;		/* default to isapnp activation */
-static int radio_nr = -1;
-static int users;
-static int curtuner;
-static int tunestat;
-static int sigstrength;
-static wait_queue_head_t read_queue;
-static struct timer_list readtimer;
-static __u8 rdsin, rdsout, rdsstat;
-static unsigned char rdsbuf[RDS_BUFFER];
-static spinlock_t cadet_io_lock;
-
-static int cadet_probe(void);
+static struct cadet cadet_card;
 
 /*
  * Signal Strength Threshold Values
  * The V4L API spec does not define any particular unit for the signal
  * strength value.  These values are in microvolts of RF at the tuner's input.
  */
-static __u16 sigtable[2][4]={{5,10,30,150},{28,40,63,1000}};
+static __u16 sigtable[2][4] = {
+	{  5, 10, 30,  150 },
+	{ 28, 40, 63, 1000 }
+};
 
 
-static int
-cadet_getstereo(void)
+static int cadet_getstereo(struct cadet *dev)
 {
 	int ret = V4L2_TUNER_SUB_MONO;
-	if(curtuner != 0)	/* Only FM has stereo capability! */
+
+	if (dev->curtuner != 0)	/* Only FM has stereo capability! */
 		return V4L2_TUNER_SUB_MONO;
 
-	spin_lock(&cadet_io_lock);
-	outb(7,io);          /* Select tuner control */
-	if( (inb(io+1) & 0x40) == 0)
+	mutex_lock(&dev->lock);
+	outb(7, dev->io);          /* Select tuner control */
+	if ((inb(dev->io + 1) & 0x40) == 0)
 		ret = V4L2_TUNER_SUB_STEREO;
-	spin_unlock(&cadet_io_lock);
+	mutex_unlock(&dev->lock);
 	return ret;
 }
 
-static unsigned
-cadet_gettune(void)
+static unsigned cadet_gettune(struct cadet *dev)
 {
-	int curvol,i;
-	unsigned fifo=0;
+	int curvol, i;
+	unsigned fifo = 0;
 
 	/*
 	 * Prepare for read
 	 */
 
-	spin_lock(&cadet_io_lock);
+	mutex_lock(&dev->lock);
 
-	outb(7,io);       /* Select tuner control */
-	curvol=inb(io+1); /* Save current volume/mute setting */
-	outb(0x00,io+1);  /* Ensure WRITE-ENABLE is LOW */
-	tunestat=0xffff;
+	outb(7, dev->io);       /* Select tuner control */
+	curvol = inb(dev->io + 1); /* Save current volume/mute setting */
+	outb(0x00, dev->io + 1);  /* Ensure WRITE-ENABLE is LOW */
+	dev->tunestat = 0xffff;
 
 	/*
 	 * Read the shift register
 	 */
-	for(i=0;i<25;i++) {
-		fifo=(fifo<<1)|((inb(io+1)>>7)&0x01);
-		if(i<24) {
-			outb(0x01,io+1);
-			tunestat&=inb(io+1);
-			outb(0x00,io+1);
+	for (i = 0; i < 25; i++) {
+		fifo = (fifo << 1) | ((inb(dev->io + 1) >> 7) & 0x01);
+		if (i < 24) {
+			outb(0x01, dev->io + 1);
+			dev->tunestat &= inb(dev->io + 1);
+			outb(0x00, dev->io + 1);
 		}
 	}
 
 	/*
 	 * Restore volume/mute setting
 	 */
-	outb(curvol,io+1);
-	spin_unlock(&cadet_io_lock);
+	outb(curvol, dev->io + 1);
+	mutex_unlock(&dev->lock);
 
 	return fifo;
 }
 
-static unsigned
-cadet_getfreq(void)
+static unsigned cadet_getfreq(struct cadet *dev)
 {
 	int i;
-	unsigned freq=0,test,fifo=0;
+	unsigned freq = 0, test, fifo = 0;
 
 	/*
 	 * Read current tuning
 	 */
-	fifo=cadet_gettune();
+	fifo = cadet_gettune(dev);
 
 	/*
 	 * Convert to actual frequency
 	 */
-	if(curtuner==0) {    /* FM */
-		test=12500;
-		for(i=0;i<14;i++) {
-			if((fifo&0x01)!=0) {
-				freq+=test;
-			}
-			test=test<<1;
-			fifo=fifo>>1;
+	if (dev->curtuner == 0) {    /* FM */
+		test = 12500;
+		for (i = 0; i < 14; i++) {
+			if ((fifo & 0x01) != 0)
+				freq += test;
+			test = test << 1;
+			fifo = fifo >> 1;
 		}
-		freq-=10700000;           /* IF frequency is 10.7 MHz */
-		freq=(freq*16)/1000000;   /* Make it 1/16 MHz */
-	}
-	if(curtuner==1) {    /* AM */
-		freq=((fifo&0x7fff)-2010)*16;
+		freq -= 10700000;           /* IF frequency is 10.7 MHz */
+		freq = (freq * 16) / 1000000;   /* Make it 1/16 MHz */
 	}
+	if (dev->curtuner == 1)    /* AM */
+		freq = ((fifo & 0x7fff) - 2010) * 16;
 
 	return freq;
 }
 
-static void
-cadet_settune(unsigned fifo)
+static void cadet_settune(struct cadet *dev, unsigned fifo)
 {
 	int i;
 	unsigned test;
 
-	spin_lock(&cadet_io_lock);
+	mutex_lock(&dev->lock);
 
-	outb(7,io);                /* Select tuner control */
+	outb(7, dev->io);                /* Select tuner control */
 	/*
 	 * Write the shift register
 	 */
-	test=0;
-	test=(fifo>>23)&0x02;      /* Align data for SDO */
-	test|=0x1c;                /* SDM=1, SWE=1, SEN=1, SCK=0 */
-	outb(7,io);                /* Select tuner control */
-	outb(test,io+1);           /* Initialize for write */
-	for(i=0;i<25;i++) {
-		test|=0x01;              /* Toggle SCK High */
-		outb(test,io+1);
-		test&=0xfe;              /* Toggle SCK Low */
-		outb(test,io+1);
-		fifo=fifo<<1;            /* Prepare the next bit */
-		test=0x1c|((fifo>>23)&0x02);
-		outb(test,io+1);
+	test = 0;
+	test = (fifo >> 23) & 0x02;      /* Align data for SDO */
+	test |= 0x1c;                /* SDM=1, SWE=1, SEN=1, SCK=0 */
+	outb(7, dev->io);                /* Select tuner control */
+	outb(test, dev->io + 1);           /* Initialize for write */
+	for (i = 0; i < 25; i++) {
+		test |= 0x01;              /* Toggle SCK High */
+		outb(test, dev->io + 1);
+		test &= 0xfe;              /* Toggle SCK Low */
+		outb(test, dev->io + 1);
+		fifo = fifo << 1;            /* Prepare the next bit */
+		test = 0x1c | ((fifo >> 23) & 0x02);
+		outb(test, dev->io + 1);
 	}
-	spin_unlock(&cadet_io_lock);
+	mutex_unlock(&dev->lock);
 }
 
-static void
-cadet_setfreq(unsigned freq)
+static void cadet_setfreq(struct cadet *dev, unsigned freq)
 {
 	unsigned fifo;
-	int i,j,test;
+	int i, j, test;
 	int curvol;
 
 	/*
 	 * Formulate a fifo command
 	 */
-	fifo=0;
-	if(curtuner==0) {    /* FM */
-		test=102400;
-		freq=(freq*1000)/16;       /* Make it kHz */
-		freq+=10700;               /* IF is 10700 kHz */
-		for(i=0;i<14;i++) {
-			fifo=fifo<<1;
-			if(freq>=test) {
-				fifo|=0x01;
-				freq-=test;
+	fifo = 0;
+	if (dev->curtuner == 0) {    /* FM */
+		test = 102400;
+		freq = (freq * 1000) / 16;       /* Make it kHz */
+		freq += 10700;               /* IF is 10700 kHz */
+		for (i = 0; i < 14; i++) {
+			fifo = fifo << 1;
+			if (freq >= test) {
+				fifo |= 0x01;
+				freq -= test;
 			}
-			test=test>>1;
+			test = test >> 1;
 		}
 	}
-	if(curtuner==1) {    /* AM */
-		fifo=(freq/16)+2010;            /* Make it kHz */
-		fifo|=0x100000;            /* Select AM Band */
+	if (dev->curtuner == 1) {    /* AM */
+		fifo = (freq / 16) + 2010;            /* Make it kHz */
+		fifo |= 0x100000;            /* Select AM Band */
 	}
 
 	/*
 	 * Save current volume/mute setting
 	 */
 
-	spin_lock(&cadet_io_lock);
-	outb(7,io);                /* Select tuner control */
-	curvol=inb(io+1);
-	spin_unlock(&cadet_io_lock);
+	mutex_lock(&dev->lock);
+	outb(7, dev->io);                /* Select tuner control */
+	curvol = inb(dev->io + 1);
+	mutex_unlock(&dev->lock);
 
 	/*
 	 * Tune the card
 	 */
-	for(j=3;j>-1;j--) {
-		cadet_settune(fifo|(j<<16));
+	for (j = 3; j > -1; j--) {
+		cadet_settune(dev, fifo | (j << 16));
 
-		spin_lock(&cadet_io_lock);
-		outb(7,io);         /* Select tuner control */
-		outb(curvol,io+1);
-		spin_unlock(&cadet_io_lock);
+		mutex_lock(&dev->lock);
+		outb(7, dev->io);         /* Select tuner control */
+		outb(curvol, dev->io + 1);
+		mutex_unlock(&dev->lock);
 
 		msleep(100);
 
-		cadet_gettune();
-		if((tunestat & 0x40) == 0) {   /* Tuned */
-			sigstrength=sigtable[curtuner][j];
+		cadet_gettune(dev);
+		if ((dev->tunestat & 0x40) == 0) {   /* Tuned */
+			dev->sigstrength = sigtable[dev->curtuner][j];
 			return;
 		}
 	}
-	sigstrength=0;
+	dev->sigstrength = 0;
 }
 
 
-static int
-cadet_getvol(void)
+static int cadet_getvol(struct cadet *dev)
 {
 	int ret = 0;
 
-	spin_lock(&cadet_io_lock);
+	mutex_lock(&dev->lock);
 
-	outb(7,io);                /* Select tuner control */
-	if((inb(io + 1) & 0x20) != 0)
+	outb(7, dev->io);                /* Select tuner control */
+	if ((inb(dev->io + 1) & 0x20) != 0)
 		ret = 0xffff;
 
-	spin_unlock(&cadet_io_lock);
+	mutex_unlock(&dev->lock);
 	return ret;
 }
 
 
-static void
-cadet_setvol(int vol)
+static void cadet_setvol(struct cadet *dev, int vol)
 {
-	spin_lock(&cadet_io_lock);
-	outb(7,io);                /* Select tuner control */
-	if(vol>0)
-		outb(0x20,io+1);
+	mutex_lock(&dev->lock);
+	outb(7, dev->io);                /* Select tuner control */
+	if (vol > 0)
+		outb(0x20, dev->io + 1);
 	else
-		outb(0x00,io+1);
-	spin_unlock(&cadet_io_lock);
+		outb(0x00, dev->io + 1);
+	mutex_unlock(&dev->lock);
 }
 
-static void
-cadet_handler(unsigned long data)
+static void cadet_handler(unsigned long data)
 {
-	/*
-	 * Service the RDS fifo
-	 */
+	struct cadet *dev = (void *)data;
 
-	if(spin_trylock(&cadet_io_lock))
-	{
-		outb(0x3,io);       /* Select RDS Decoder Control */
-		if((inb(io+1)&0x20)!=0) {
+	/* Service the RDS fifo */
+	if (mutex_trylock(&dev->lock)) {
+		outb(0x3, dev->io);       /* Select RDS Decoder Control */
+		if ((inb(dev->io + 1) & 0x20) != 0)
 			printk(KERN_CRIT "cadet: RDS fifo overflow\n");
-		}
-		outb(0x80,io);      /* Select RDS fifo */
-		while((inb(io)&0x80)!=0) {
-			rdsbuf[rdsin]=inb(io+1);
-			if(rdsin==rdsout)
+		outb(0x80, dev->io);      /* Select RDS fifo */
+		while ((inb(dev->io) & 0x80) != 0) {
+			dev->rdsbuf[dev->rdsin] = inb(dev->io + 1);
+			if (dev->rdsin == dev->rdsout)
 				printk(KERN_WARNING "cadet: RDS buffer overflow\n");
 			else
-				rdsin++;
+				dev->rdsin++;
 		}
-		spin_unlock(&cadet_io_lock);
+		mutex_unlock(&dev->lock);
 	}
 
 	/*
 	 * Service pending read
 	 */
-	if( rdsin!=rdsout)
-		wake_up_interruptible(&read_queue);
+	if (dev->rdsin != dev->rdsout)
+		wake_up_interruptible(&dev->read_queue);
 
 	/*
 	 * Clean up and exit
 	 */
-	init_timer(&readtimer);
-	readtimer.function=cadet_handler;
-	readtimer.data=(unsigned long)0;
-	readtimer.expires=jiffies+msecs_to_jiffies(50);
-	add_timer(&readtimer);
+	init_timer(&dev->readtimer);
+	dev->readtimer.function = cadet_handler;
+	dev->readtimer.data = (unsigned long)0;
+	dev->readtimer.expires = jiffies + msecs_to_jiffies(50);
+	add_timer(&dev->readtimer);
 }
 
 
-
-static ssize_t
-cadet_read(struct file *file, char __user *data, size_t count, loff_t *ppos)
+static ssize_t cadet_read(struct file *file, char __user *data, size_t count, loff_t *ppos)
 {
-	int i=0;
+	struct cadet *dev = video_drvdata(file);
 	unsigned char readbuf[RDS_BUFFER];
-
-	if(rdsstat==0) {
-		spin_lock(&cadet_io_lock);
-		rdsstat=1;
-		outb(0x80,io);        /* Select RDS fifo */
-		spin_unlock(&cadet_io_lock);
-		init_timer(&readtimer);
-		readtimer.function=cadet_handler;
-		readtimer.data=(unsigned long)0;
-		readtimer.expires=jiffies+msecs_to_jiffies(50);
-		add_timer(&readtimer);
+	int i = 0;
+
+	if (dev->rdsstat == 0) {
+		mutex_lock(&dev->lock);
+		dev->rdsstat = 1;
+		outb(0x80, dev->io);        /* Select RDS fifo */
+		mutex_unlock(&dev->lock);
+		init_timer(&dev->readtimer);
+		dev->readtimer.function = cadet_handler;
+		dev->readtimer.data = (unsigned long)dev;
+		dev->readtimer.expires = jiffies + msecs_to_jiffies(50);
+		add_timer(&dev->readtimer);
 	}
-	if(rdsin==rdsout) {
+	if (dev->rdsin == dev->rdsout) {
 		if (file->f_flags & O_NONBLOCK)
 			return -EWOULDBLOCK;
-		interruptible_sleep_on(&read_queue);
+		interruptible_sleep_on(&dev->read_queue);
 	}
-	while( i<count && rdsin!=rdsout)
-		readbuf[i++]=rdsbuf[rdsout++];
+	while (i < count && dev->rdsin != dev->rdsout)
+		readbuf[i++] = dev->rdsbuf[dev->rdsout++];
 
-	if (copy_to_user(data,readbuf,i))
+	if (copy_to_user(data, readbuf, i))
 		return -EFAULT;
 	return i;
 }
@@ -370,38 +356,40 @@ cadet_read(struct file *file, char __user *data, size_t count, loff_t *ppos)
 static int vidioc_querycap(struct file *file, void *priv,
 				struct v4l2_capability *v)
 {
-	v->capabilities =
-		V4L2_CAP_TUNER |
-		V4L2_CAP_READWRITE;
+	strlcpy(v->driver, "ADS Cadet", sizeof(v->driver));
+	strlcpy(v->card, "ADS Cadet", sizeof(v->card));
+	strlcpy(v->bus_info, "ISA", sizeof(v->bus_info));
 	v->version = CADET_VERSION;
-	strcpy(v->driver, "ADS Cadet");
-	strcpy(v->card, "ADS Cadet");
+	v->capabilities = V4L2_CAP_TUNER | V4L2_CAP_RADIO | V4L2_CAP_READWRITE;
 	return 0;
 }
 
 static int vidioc_g_tuner(struct file *file, void *priv,
 				struct v4l2_tuner *v)
 {
+	struct cadet *dev = video_drvdata(file);
+
 	v->type = V4L2_TUNER_RADIO;
 	switch (v->index) {
 	case 0:
-		strcpy(v->name, "FM");
+		strlcpy(v->name, "FM", sizeof(v->name));
 		v->capability = V4L2_TUNER_CAP_STEREO;
 		v->rangelow = 1400;     /* 87.5 MHz */
 		v->rangehigh = 1728;    /* 108.0 MHz */
-		v->rxsubchans=cadet_getstereo();
-		switch (v->rxsubchans){
+		v->rxsubchans = cadet_getstereo(dev);
+		switch (v->rxsubchans) {
 		case V4L2_TUNER_SUB_MONO:
 			v->audmode = V4L2_TUNER_MODE_MONO;
 			break;
 		case V4L2_TUNER_SUB_STEREO:
 			v->audmode = V4L2_TUNER_MODE_STEREO;
 			break;
-		default: ;
+		default:
+			break;
 		}
 		break;
 	case 1:
-		strcpy(v->name, "AM");
+		strlcpy(v->name, "AM", sizeof(v->name));
 		v->capability = V4L2_TUNER_CAP_LOW;
 		v->rangelow = 8320;      /* 520 kHz */
 		v->rangehigh = 26400;    /* 1650 kHz */
@@ -411,25 +399,29 @@ static int vidioc_g_tuner(struct file *file, void *priv,
 	default:
 		return -EINVAL;
 	}
-	v->signal = sigstrength; /* We might need to modify scaling of this */
+	v->signal = dev->sigstrength; /* We might need to modify scaling of this */
 	return 0;
 }
 
 static int vidioc_s_tuner(struct file *file, void *priv,
 				struct v4l2_tuner *v)
 {
-	if((v->index != 0)&&(v->index != 1))
+	struct cadet *dev = video_drvdata(file);
+
+	if (v->index != 0 && v->index != 1)
 		return -EINVAL;
-	curtuner = v->index;
+	dev->curtuner = v->index;
 	return 0;
 }
 
 static int vidioc_g_frequency(struct file *file, void *priv,
 				struct v4l2_frequency *f)
 {
-	f->tuner = curtuner;
+	struct cadet *dev = video_drvdata(file);
+
+	f->tuner = dev->curtuner;
 	f->type = V4L2_TUNER_RADIO;
-	f->frequency = cadet_getfreq();
+	f->frequency = cadet_getfreq(dev);
 	return 0;
 }
 
@@ -437,27 +429,26 @@ static int vidioc_g_frequency(struct file *file, void *priv,
 static int vidioc_s_frequency(struct file *file, void *priv,
 				struct v4l2_frequency *f)
 {
+	struct cadet *dev = video_drvdata(file);
+
 	if (f->type != V4L2_TUNER_RADIO)
 		return -EINVAL;
-	if((curtuner==0)&&((f->frequency<1400)||(f->frequency>1728)))
+	if (dev->curtuner == 0 && (f->frequency < 1400 || f->frequency > 1728))
 		return -EINVAL;
-	if((curtuner==1)&&((f->frequency<8320)||(f->frequency>26400)))
+	if (dev->curtuner == 1 && (f->frequency < 8320 || f->frequency > 26400))
 		return -EINVAL;
-	cadet_setfreq(f->frequency);
+	cadet_setfreq(dev, f->frequency);
 	return 0;
 }
 
 static int vidioc_queryctrl(struct file *file, void *priv,
 				struct v4l2_queryctrl *qc)
 {
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(radio_qctrl); i++) {
-		if (qc->id && qc->id == radio_qctrl[i].id) {
-			memcpy(qc, &(radio_qctrl[i]),
-						sizeof(*qc));
-			return 0;
-		}
+	switch (qc->id) {
+	case V4L2_CID_AUDIO_MUTE:
+		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 1);
+	case V4L2_CID_AUDIO_VOLUME:
+		return v4l2_ctrl_query_fill(qc, 0, 0xff, 1, 0xff);
 	}
 	return -EINVAL;
 }
@@ -465,12 +456,14 @@ static int vidioc_queryctrl(struct file *file, void *priv,
 static int vidioc_g_ctrl(struct file *file, void *priv,
 				struct v4l2_control *ctrl)
 {
-	switch (ctrl->id){
+	struct cadet *dev = video_drvdata(file);
+
+	switch (ctrl->id) {
 	case V4L2_CID_AUDIO_MUTE: /* TODO: Handle this correctly */
-		ctrl->value = (cadet_getvol() == 0);
+		ctrl->value = (cadet_getvol(dev) == 0);
 		break;
 	case V4L2_CID_AUDIO_VOLUME:
-		ctrl->value = cadet_getvol();
+		ctrl->value = cadet_getvol(dev);
 		break;
 	default:
 		return -EINVAL;
@@ -481,15 +474,17 @@ static int vidioc_g_ctrl(struct file *file, void *priv,
 static int vidioc_s_ctrl(struct file *file, void *priv,
 				struct v4l2_control *ctrl)
 {
+	struct cadet *dev = video_drvdata(file);
+
 	switch (ctrl->id){
 	case V4L2_CID_AUDIO_MUTE: /* TODO: Handle this correctly */
 		if (ctrl->value)
-			cadet_setvol(0);
+			cadet_setvol(dev, 0);
 		else
-			cadet_setvol(0xffff);
+			cadet_setvol(dev, 0xffff);
 		break;
 	case V4L2_CID_AUDIO_VOLUME:
-		cadet_setvol(ctrl->value);
+		cadet_setvol(dev, ctrl->value);
 		break;
 	default:
 		return -EINVAL;
@@ -497,16 +492,6 @@ static int vidioc_s_ctrl(struct file *file, void *priv,
 	return 0;
 }
 
-static int vidioc_g_audio(struct file *file, void *priv,
-				struct v4l2_audio *a)
-{
-	if (a->index > 1)
-		return -EINVAL;
-	strcpy(a->name, "Radio");
-	a->capability = V4L2_AUDCAP_STEREO;
-	return 0;
-}
-
 static int vidioc_g_input(struct file *filp, void *priv, unsigned int *i)
 {
 	*i = 0;
@@ -515,43 +500,52 @@ static int vidioc_g_input(struct file *filp, void *priv, unsigned int *i)
 
 static int vidioc_s_input(struct file *filp, void *priv, unsigned int i)
 {
-	if (i != 0)
-		return -EINVAL;
+	return i ? -EINVAL : 0;
+}
+
+static int vidioc_g_audio(struct file *file, void *priv,
+				struct v4l2_audio *a)
+{
+	a->index = 0;
+	strlcpy(a->name, "Radio", sizeof(a->name));
+	a->capability = V4L2_AUDCAP_STEREO;
 	return 0;
 }
 
 static int vidioc_s_audio(struct file *file, void *priv,
 				struct v4l2_audio *a)
 {
-	if (a->index != 0)
-		return -EINVAL;
-	return 0;
+	return a->index ? -EINVAL : 0;
 }
 
-static int
-cadet_open(struct file *file)
+static int cadet_open(struct file *file)
 {
-	users++;
-	if (1 == users) init_waitqueue_head(&read_queue);
+	struct cadet *dev = video_drvdata(file);
+
+	dev->users++;
+	if (1 == dev->users)
+		init_waitqueue_head(&dev->read_queue);
 	return 0;
 }
 
-static int
-cadet_release(struct file *file)
+static int cadet_release(struct file *file)
 {
-	users--;
-	if (0 == users){
-		del_timer_sync(&readtimer);
-		rdsstat=0;
+	struct cadet *dev = video_drvdata(file);
+
+	dev->users--;
+	if (0 == dev->users) {
+		del_timer_sync(&dev->readtimer);
+		dev->rdsstat = 0;
 	}
 	return 0;
 }
 
-static unsigned int
-cadet_poll(struct file *file, struct poll_table_struct *wait)
+static unsigned int cadet_poll(struct file *file, struct poll_table_struct *wait)
 {
-	poll_wait(file,&read_queue,wait);
-	if(rdsin != rdsout)
+	struct cadet *dev = video_drvdata(file);
+
+	poll_wait(file, &dev->read_queue, wait);
+	if (dev->rdsin != dev->rdsout)
 		return POLLIN | POLLRDNORM;
 	return 0;
 }
@@ -581,13 +575,6 @@ static const struct v4l2_ioctl_ops cadet_ioctl_ops = {
 	.vidioc_s_input     = vidioc_s_input,
 };
 
-static struct video_device cadet_radio = {
-	.name		= "Cadet radio",
-	.fops           = &cadet_fops,
-	.ioctl_ops 	= &cadet_ioctl_ops,
-	.release	= video_device_release_empty,
-};
-
 #ifdef CONFIG_PNP
 
 static struct pnp_device_id cadet_pnp_devices[] = {
@@ -598,7 +585,7 @@ static struct pnp_device_id cadet_pnp_devices[] = {
 
 MODULE_DEVICE_TABLE(pnp, cadet_pnp_devices);
 
-static int cadet_pnp_probe(struct pnp_dev * dev, const struct pnp_device_id *dev_id)
+static int cadet_pnp_probe(struct pnp_dev *dev, const struct pnp_device_id *dev_id)
 {
 	if (!dev)
 		return -ENODEV;
@@ -606,13 +593,12 @@ static int cadet_pnp_probe(struct pnp_dev * dev, const struct pnp_device_id *dev
 	if (io > 0)
 		return -EBUSY;
 
-	if (!pnp_port_valid(dev, 0)) {
+	if (!pnp_port_valid(dev, 0))
 		return -ENODEV;
-	}
 
 	io = pnp_port_start(dev, 0);
 
-	printk ("radio-cadet: PnP reports device at %#x\n", io);
+	printk(KERN_INFO "radio-cadet: PnP reports device at %#x\n", io);
 
 	return io;
 }
@@ -628,23 +614,23 @@ static struct pnp_driver cadet_pnp_driver = {
 static struct pnp_driver cadet_pnp_driver;
 #endif
 
-static int cadet_probe(void)
+static void cadet_probe(struct cadet *dev)
 {
-	static int iovals[8]={0x330,0x332,0x334,0x336,0x338,0x33a,0x33c,0x33e};
+	static int iovals[8] = { 0x330, 0x332, 0x334, 0x336, 0x338, 0x33a, 0x33c, 0x33e };
 	int i;
 
-	for(i=0;i<8;i++) {
-		io=iovals[i];
-		if (request_region(io, 2, "cadet-probe")) {
-			cadet_setfreq(1410);
-			if(cadet_getfreq()==1410) {
-				release_region(io, 2);
-				return io;
+	for (i = 0; i < 8; i++) {
+		dev->io = iovals[i];
+		if (request_region(dev->io, 2, "cadet-probe")) {
+			cadet_setfreq(dev, 1410);
+			if (cadet_getfreq(dev) == 1410) {
+				release_region(dev->io, 2);
+				return;
 			}
-			release_region(io, 2);
+			release_region(dev->io, 2);
 		}
 	}
-	return -1;
+	dev->io = -1;
 }
 
 /*
@@ -654,59 +640,68 @@ static int cadet_probe(void)
 
 static int __init cadet_init(void)
 {
-	spin_lock_init(&cadet_io_lock);
+	struct cadet *dev = &cadet_card;
+	struct v4l2_device *v4l2_dev = &dev->v4l2_dev;
+	int res;
 
-	/*
-	 *	If a probe was requested then probe ISAPnP first (safest)
-	 */
+	strlcpy(v4l2_dev->name, "cadet", sizeof(v4l2_dev->name));
+	mutex_init(&dev->lock);
+
+	/* If a probe was requested then probe ISAPnP first (safest) */
 	if (io < 0)
 		pnp_register_driver(&cadet_pnp_driver);
-	/*
-	 *	If that fails then probe unsafely if probe is requested
-	 */
-	if(io < 0)
-		io = cadet_probe ();
+	dev->io = io;
 
-	/*
-	 *	Else we bail out
-	 */
+	/* If that fails then probe unsafely if probe is requested */
+	if (dev->io < 0)
+		cadet_probe(dev);
 
-	if(io < 0) {
+	/* Else we bail out */
+	if (dev->io < 0) {
 #ifdef MODULE
-		printk(KERN_ERR "You must set an I/O address with io=0x???\n");
+		v4l2_err(v4l2_dev, "you must set an I/O address with io=0x???\n");
 #endif
 		goto fail;
 	}
-	if (!request_region(io,2,"cadet"))
+	if (!request_region(dev->io, 2, "cadet"))
+		goto fail;
+
+	res = v4l2_device_register(NULL, v4l2_dev);
+	if (res < 0) {
+		release_region(dev->io, 2);
+		v4l2_err(v4l2_dev, "could not register v4l2_device\n");
 		goto fail;
-	if (video_register_device(&cadet_radio, VFL_TYPE_RADIO, radio_nr) < 0) {
-		release_region(io,2);
+	}
+
+	strlcpy(dev->vdev.name, v4l2_dev->name, sizeof(dev->vdev.name));
+	dev->vdev.v4l2_dev = v4l2_dev;
+	dev->vdev.fops = &cadet_fops;
+	dev->vdev.ioctl_ops = &cadet_ioctl_ops;
+	dev->vdev.release = video_device_release_empty;
+	video_set_drvdata(&dev->vdev, dev);
+
+	if (video_register_device(&dev->vdev, VFL_TYPE_RADIO, radio_nr) < 0) {
+		v4l2_device_unregister(v4l2_dev);
+		release_region(dev->io, 2);
 		goto fail;
 	}
-	printk(KERN_INFO "ADS Cadet Radio Card at 0x%x\n",io);
+	v4l2_info(v4l2_dev, "ADS Cadet Radio Card at 0x%x\n", dev->io);
 	return 0;
 fail:
 	pnp_unregister_driver(&cadet_pnp_driver);
-	return -1;
+	return -ENODEV;
 }
 
-
-
-MODULE_AUTHOR("Fred Gleason, Russell Kroll, Quay Lu, Donald Song, Jason Lewis, Scott McGrath, William McGrath");
-MODULE_DESCRIPTION("A driver for the ADS Cadet AM/FM/RDS radio card.");
-MODULE_LICENSE("GPL");
-
-module_param(io, int, 0);
-MODULE_PARM_DESC(io, "I/O address of Cadet card (0x330,0x332,0x334,0x336,0x338,0x33a,0x33c,0x33e)");
-module_param(radio_nr, int, 0);
-
-static void __exit cadet_cleanup_module(void)
+static void __exit cadet_exit(void)
 {
-	video_unregister_device(&cadet_radio);
-	release_region(io,2);
+	struct cadet *dev = &cadet_card;
+
+	video_unregister_device(&dev->vdev);
+	v4l2_device_unregister(&dev->v4l2_dev);
+	release_region(dev->io, 2);
 	pnp_unregister_driver(&cadet_pnp_driver);
 }
 
 module_init(cadet_init);
-module_exit(cadet_cleanup_module);
+module_exit(cadet_exit);
 

commit bec43661b1dc0075b7445223ba775674133b164d
Author: Hans Verkuil <hverkuil@xs4all.nl>
Date:   Tue Dec 30 06:58:20 2008 -0300

    V4L/DVB (10135): v4l2: introduce v4l2_file_operations.
    
    Introduce a struct v4l2_file_operations for v4l2 drivers.
    
    Remove the unnecessary inode argument.
    
    Move compat32 handling (and llseek) into the v4l2-dev core: this is now
    handled in the v4l2 core and no longer in the drivers themselves.
    
    Note that this changeset reverts an earlier patch that changed the return
    type of__video_ioctl2 from int to long. This change will be reinstated
    later in a much improved version.
    
    Signed-off-by: Hans Verkuil <hverkuil@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-cadet.c b/drivers/media/radio/radio-cadet.c
index bfd37f38b9ab..cb3075ac104c 100644
--- a/drivers/media/radio/radio-cadet.c
+++ b/drivers/media/radio/radio-cadet.c
@@ -529,7 +529,7 @@ static int vidioc_s_audio(struct file *file, void *priv,
 }
 
 static int
-cadet_open(struct inode *inode, struct file *file)
+cadet_open(struct file *file)
 {
 	users++;
 	if (1 == users) init_waitqueue_head(&read_queue);
@@ -537,7 +537,7 @@ cadet_open(struct inode *inode, struct file *file)
 }
 
 static int
-cadet_release(struct inode *inode, struct file *file)
+cadet_release(struct file *file)
 {
 	users--;
 	if (0 == users){
@@ -557,17 +557,13 @@ cadet_poll(struct file *file, struct poll_table_struct *wait)
 }
 
 
-static const struct file_operations cadet_fops = {
+static const struct v4l2_file_operations cadet_fops = {
 	.owner		= THIS_MODULE,
 	.open		= cadet_open,
 	.release       	= cadet_release,
 	.read		= cadet_read,
 	.ioctl		= video_ioctl2,
 	.poll		= cadet_poll,
-#ifdef CONFIG_COMPAT
-	.compat_ioctl	= v4l_compat_ioctl32,
-#endif
-	.llseek         = no_llseek,
 };
 
 static const struct v4l2_ioctl_ops cadet_ioctl_ops = {

commit d9b01449e75d1351296595e28d2af72993bcc3dc
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Mon Oct 27 15:13:47 2008 -0300

    V4L/DVB (9491): rationalise addresses to one common one
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-cadet.c b/drivers/media/radio/radio-cadet.c
index 0490a1fa999d..bfd37f38b9ab 100644
--- a/drivers/media/radio/radio-cadet.c
+++ b/drivers/media/radio/radio-cadet.c
@@ -23,7 +23,7 @@
  * 2002-01-17	Adam Belay <ambx1@neo.rr.com>
  *		Updated to latest pnp code
  *
- * 2003-01-31	Alan Cox <alan@redhat.com>
+ * 2003-01-31	Alan Cox <alan@lxorguk.ukuu.org.uk>
  *		Cleaned up locking, delay code, general odds and ends
  *
  * 2006-07-30	Hans J. Koch <koch@hjk-az.de>

commit aa5e90af7d78d1711f8f4275ce3638817c0023dc
Author: Hans Verkuil <hverkuil@xs4all.nl>
Date:   Sat Aug 23 06:23:55 2008 -0300

    V4L/DVB (8783): v4l: add all missing video_device release callbacks
    
    All drivers that call video_device_register where checked to see if they
    set the release callback of struct video_device. Where that callback was
    missing it was added.
    
    Signed-off-by: Hans Verkuil <hverkuil@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-cadet.c b/drivers/media/radio/radio-cadet.c
index 04c3698d32e4..0490a1fa999d 100644
--- a/drivers/media/radio/radio-cadet.c
+++ b/drivers/media/radio/radio-cadet.c
@@ -589,6 +589,7 @@ static struct video_device cadet_radio = {
 	.name		= "Cadet radio",
 	.fops           = &cadet_fops,
 	.ioctl_ops 	= &cadet_ioctl_ops,
+	.release	= video_device_release_empty,
 };
 
 #ifdef CONFIG_PNP

commit cba99ae81901fe61ac4b0d65c697474af29dc4ea
Author: Hans Verkuil <hverkuil@xs4all.nl>
Date:   Wed Sep 3 17:11:58 2008 -0300

    V4L/DVB (8778): radio: fix incorrect video_register_device result check
    
    Signed-off-by: Hans Verkuil <hverkuil@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-cadet.c b/drivers/media/radio/radio-cadet.c
index 6166e726ed72..04c3698d32e4 100644
--- a/drivers/media/radio/radio-cadet.c
+++ b/drivers/media/radio/radio-cadet.c
@@ -682,7 +682,7 @@ static int __init cadet_init(void)
 	}
 	if (!request_region(io,2,"cadet"))
 		goto fail;
-	if(video_register_device(&cadet_radio,VFL_TYPE_RADIO,radio_nr)==-1) {
+	if (video_register_device(&cadet_radio, VFL_TYPE_RADIO, radio_nr) < 0) {
 		release_region(io,2);
 		goto fail;
 	}

commit 0ea6bc8d43c9ee3c5384bea184eab020927a5b2c
Author: Hans Verkuil <hverkuil@xs4all.nl>
Date:   Sat Jul 26 08:26:43 2008 -0300

    V4L/DVB (8523): v4l2-dev: remove unused type and type2 field from video_device
    
    The type and type2 fields were unused and so could be removed.
    Instead add a vfl_type field that contains the type of the video
    device.
    
    Signed-off-by: Hans Verkuil <hverkuil@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@infradead.org>

diff --git a/drivers/media/radio/radio-cadet.c b/drivers/media/radio/radio-cadet.c
index 362a279f0680..6166e726ed72 100644
--- a/drivers/media/radio/radio-cadet.c
+++ b/drivers/media/radio/radio-cadet.c
@@ -587,7 +587,6 @@ static const struct v4l2_ioctl_ops cadet_ioctl_ops = {
 
 static struct video_device cadet_radio = {
 	.name		= "Cadet radio",
-	.type		= VID_TYPE_TUNER,
 	.fops           = &cadet_fops,
 	.ioctl_ops 	= &cadet_ioctl_ops,
 };

commit 9c39d7eafa366b807067697f7fc5b14d8b865179
Author: Hans Verkuil <hverkuil@xs4all.nl>
Date:   Mon Jul 21 07:51:45 2008 -0300

    V4L/DVB (8483): Remove obsolete owner field from video_device struct.
    
    According to an old comment this should have been removed in 2.6.15.
    Better late than never...
    
    Signed-off-by: Hans Verkuil <hverkuil@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@infradead.org>

diff --git a/drivers/media/radio/radio-cadet.c b/drivers/media/radio/radio-cadet.c
index 36b850fc14b4..362a279f0680 100644
--- a/drivers/media/radio/radio-cadet.c
+++ b/drivers/media/radio/radio-cadet.c
@@ -586,7 +586,6 @@ static const struct v4l2_ioctl_ops cadet_ioctl_ops = {
 };
 
 static struct video_device cadet_radio = {
-	.owner		= THIS_MODULE,
 	.name		= "Cadet radio",
 	.type		= VID_TYPE_TUNER,
 	.fops           = &cadet_fops,

commit a399810ca69d9d4bd30ab8c1678c7439e567f90b
Author: Hans Verkuil <hverkuil@xs4all.nl>
Date:   Mon Jul 21 02:57:38 2008 -0300

    V4L/DVB (8482): videodev: move all ioctl callbacks to a new v4l2_ioctl_ops struct
    
    All ioctl callbacks are now stored in a new v4l2_ioctl_ops struct. Drivers fill in
    a const struct v4l2_ioctl_ops and video_device just contains a const pointer to it.
    
    This ensures a clean separation between the const ops struct and the non-const
    video_device struct.
    
    Signed-off-by: Hans Verkuil <hverkuil@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@infradead.org>

diff --git a/drivers/media/radio/radio-cadet.c b/drivers/media/radio/radio-cadet.c
index 484ea87d7fba..36b850fc14b4 100644
--- a/drivers/media/radio/radio-cadet.c
+++ b/drivers/media/radio/radio-cadet.c
@@ -570,12 +570,7 @@ static const struct file_operations cadet_fops = {
 	.llseek         = no_llseek,
 };
 
-static struct video_device cadet_radio=
-{
-	.owner		= THIS_MODULE,
-	.name		= "Cadet radio",
-	.type		= VID_TYPE_TUNER,
-	.fops           = &cadet_fops,
+static const struct v4l2_ioctl_ops cadet_ioctl_ops = {
 	.vidioc_querycap    = vidioc_querycap,
 	.vidioc_g_tuner     = vidioc_g_tuner,
 	.vidioc_s_tuner     = vidioc_s_tuner,
@@ -590,6 +585,14 @@ static struct video_device cadet_radio=
 	.vidioc_s_input     = vidioc_s_input,
 };
 
+static struct video_device cadet_radio = {
+	.owner		= THIS_MODULE,
+	.name		= "Cadet radio",
+	.type		= VID_TYPE_TUNER,
+	.fops           = &cadet_fops,
+	.ioctl_ops 	= &cadet_ioctl_ops,
+};
+
 #ifdef CONFIG_PNP
 
 static struct pnp_device_id cadet_pnp_devices[] = {

commit 35ea11ff84719b1bfab2909903a9640a86552fd1
Author: Hans Verkuil <hverkuil@xs4all.nl>
Date:   Sun Jul 20 08:12:02 2008 -0300

    V4L/DVB (8430): videodev: move some functions from v4l2-dev.h to v4l2-common.h or v4l2-ioctl.h
    
    The functions in a header should not belong to another module. The prio functions
    belong to v4l2-common.c, so move them to v4l2-common.h.
    
    The ioctl functions belong to v4l2-ioctl.c, so create a new v4l2-ioctl.h header
    and move those functions to it.
    
    Signed-off-by: Hans Verkuil <hverkuil@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@infradead.org>

diff --git a/drivers/media/radio/radio-cadet.c b/drivers/media/radio/radio-cadet.c
index b14db53ea456..484ea87d7fba 100644
--- a/drivers/media/radio/radio-cadet.c
+++ b/drivers/media/radio/radio-cadet.c
@@ -39,6 +39,7 @@
 #include <asm/uaccess.h>	/* copy to/from user		*/
 #include <linux/videodev2.h>	/* V4L2 API defs		*/
 #include <media/v4l2-common.h>
+#include <media/v4l2-ioctl.h>
 #include <linux/param.h>
 #include <linux/pnp.h>
 

commit 078ff7953448163d8779e489bd0119dd9a9b4732
Author: Douglas Schilling Landgraf <dougsland@gmail.com>
Date:   Tue Apr 22 14:46:11 2008 -0300

    V4L/DVB (7402):  add macro validation for v4l_compat_ioctl32
    
    Added macro CONFIG_COMPAT for v4l_compat_ioctl32.
    
    Signed-off-by: Douglas Schilling Landgraf <dougsland@gmail.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@infradead.org>

diff --git a/drivers/media/radio/radio-cadet.c b/drivers/media/radio/radio-cadet.c
index 265c4ea95502..b14db53ea456 100644
--- a/drivers/media/radio/radio-cadet.c
+++ b/drivers/media/radio/radio-cadet.c
@@ -563,7 +563,9 @@ static const struct file_operations cadet_fops = {
 	.read		= cadet_read,
 	.ioctl		= video_ioctl2,
 	.poll		= cadet_poll,
+#ifdef CONFIG_COMPAT
 	.compat_ioctl	= v4l_compat_ioctl32,
+#endif
 	.llseek         = no_llseek,
 };
 

commit ff699e6bd02eb1c6d02c7c2b576c2ee6caab201c
Author: Douglas Schilling Landgraf <dougsland@gmail.com>
Date:   Tue Apr 22 14:41:48 2008 -0300

    V4L/DVB (7094):  static memory
    
    - Static memory is always initialized with 0.
    - Replaced in some cases C99 comments for /* */
    
    Signed-off-by: Douglas Schilling Landgraf <dougsland@gmail.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@infradead.org>

diff --git a/drivers/media/radio/radio-cadet.c b/drivers/media/radio/radio-cadet.c
index 57b9e3adc8f0..265c4ea95502 100644
--- a/drivers/media/radio/radio-cadet.c
+++ b/drivers/media/radio/radio-cadet.c
@@ -69,13 +69,13 @@ static struct v4l2_queryctrl radio_qctrl[] = {
 
 static int io=-1;		/* default to isapnp activation */
 static int radio_nr = -1;
-static int users=0;
-static int curtuner=0;
-static int tunestat=0;
-static int sigstrength=0;
+static int users;
+static int curtuner;
+static int tunestat;
+static int sigstrength;
 static wait_queue_head_t read_queue;
 static struct timer_list readtimer;
-static __u8 rdsin=0,rdsout=0,rdsstat=0;
+static __u8 rdsin, rdsout, rdsstat;
 static unsigned char rdsbuf[RDS_BUFFER];
 static spinlock_t cadet_io_lock;
 

commit 044dfc99fe3e1e0fa85bbdd1936ee229e399250c
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Mar 31 21:21:48 2008 -0300

    V4L/DVB (7486): radio-cadet: wrap PNP probe code in #ifdef CONFIG_PNP
    
    Wrap PNP probe code in #ifdef CONFIG_PNP.
    
    Without this change, we'll have unresolved references to pnp_get_resource()
    function when CONFIG_PNP=n.  (This is a new interface that's not in mainline
    yet.)
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@infradead.org>

diff --git a/drivers/media/radio/radio-cadet.c b/drivers/media/radio/radio-cadet.c
index 34e317ced5a3..57b9e3adc8f0 100644
--- a/drivers/media/radio/radio-cadet.c
+++ b/drivers/media/radio/radio-cadet.c
@@ -587,6 +587,8 @@ static struct video_device cadet_radio=
 	.vidioc_s_input     = vidioc_s_input,
 };
 
+#ifdef CONFIG_PNP
+
 static struct pnp_device_id cadet_pnp_devices[] = {
 	/* ADS Cadet AM/FM Radio Card */
 	{.id = "MSM0c24", .driver_data = 0},
@@ -621,6 +623,10 @@ static struct pnp_driver cadet_pnp_driver = {
 	.remove		= NULL,
 };
 
+#else
+static struct pnp_driver cadet_pnp_driver;
+#endif
+
 static int cadet_probe(void)
 {
 	static int iovals[8]={0x330,0x332,0x334,0x336,0x338,0x33a,0x33c,0x33e};

commit a2d66a37c743ba201e85c93c4ec29d58ca94b728
Author: Mauro Carvalho Chehab <mchehab@infradead.org>
Date:   Tue Jul 17 16:15:58 2007 -0300

    V4L/DVB (5857): Use msecs_to_jiffies instead of HZ on radio drivers
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@infradead.org>

diff --git a/drivers/media/radio/radio-cadet.c b/drivers/media/radio/radio-cadet.c
index 8cf2e9df5c8a..34e317ced5a3 100644
--- a/drivers/media/radio/radio-cadet.c
+++ b/drivers/media/radio/radio-cadet.c
@@ -329,7 +329,7 @@ cadet_handler(unsigned long data)
 	init_timer(&readtimer);
 	readtimer.function=cadet_handler;
 	readtimer.data=(unsigned long)0;
-	readtimer.expires=jiffies+(HZ/20);
+	readtimer.expires=jiffies+msecs_to_jiffies(50);
 	add_timer(&readtimer);
 }
 
@@ -349,7 +349,7 @@ cadet_read(struct file *file, char __user *data, size_t count, loff_t *ppos)
 		init_timer(&readtimer);
 		readtimer.function=cadet_handler;
 		readtimer.data=(unsigned long)0;
-		readtimer.expires=jiffies+(HZ/20);
+		readtimer.expires=jiffies+msecs_to_jiffies(50);
 		add_timer(&readtimer);
 	}
 	if(rdsin==rdsout) {

commit c1c4fd3eee302b285a20f17a838ef7cc423a28b3
Author: Douglas Landgraf <dougsland@gmail.com>
Date:   Mon May 7 16:17:16 2007 -0300

    V4L/DVB (5621): Radio-cadet.c Replace cadet_do_ioctl to use video_ioctl2
    
    Convert radio-cadet to use video_ioctl2
    
    Signed-off-by: Douglas Schilling Landgraf <dougsland@gmail.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@infradead.org>

diff --git a/drivers/media/radio/radio-cadet.c b/drivers/media/radio/radio-cadet.c
index 8fbf0d8bd278..8cf2e9df5c8a 100644
--- a/drivers/media/radio/radio-cadet.c
+++ b/drivers/media/radio/radio-cadet.c
@@ -48,6 +48,25 @@
 
 #define CADET_VERSION KERNEL_VERSION(0,3,3)
 
+static struct v4l2_queryctrl radio_qctrl[] = {
+	{
+		.id            = V4L2_CID_AUDIO_MUTE,
+		.name          = "Mute",
+		.minimum       = 0,
+		.maximum       = 1,
+		.default_value = 1,
+		.type          = V4L2_CTRL_TYPE_BOOLEAN,
+	},{
+		.id            = V4L2_CID_AUDIO_VOLUME,
+		.name          = "Volume",
+		.minimum       = 0,
+		.maximum       = 0xff,
+		.step          = 1,
+		.default_value = 0xff,
+		.type          = V4L2_CTRL_TYPE_INTEGER,
+	}
+};
+
 static int io=-1;		/* default to isapnp activation */
 static int radio_nr = -1;
 static int users=0;
@@ -347,135 +366,165 @@ cadet_read(struct file *file, char __user *data, size_t count, loff_t *ppos)
 }
 
 
+static int vidioc_querycap(struct file *file, void *priv,
+				struct v4l2_capability *v)
+{
+	v->capabilities =
+		V4L2_CAP_TUNER |
+		V4L2_CAP_READWRITE;
+	v->version = CADET_VERSION;
+	strcpy(v->driver, "ADS Cadet");
+	strcpy(v->card, "ADS Cadet");
+	return 0;
+}
 
-static int cadet_do_ioctl(struct inode *inode, struct file *file,
-			  unsigned int cmd, void *arg)
+static int vidioc_g_tuner(struct file *file, void *priv,
+				struct v4l2_tuner *v)
 {
-	switch(cmd)
-	{
-		case VIDIOC_QUERYCAP:
-		{
-			struct v4l2_capability *cap = arg;
-			memset(cap,0,sizeof(*cap));
-			cap->capabilities =
-				V4L2_CAP_TUNER |
-				V4L2_CAP_READWRITE;
-			cap->version = CADET_VERSION;
-			strcpy(cap->driver, "ADS Cadet");
-			strcpy(cap->card, "ADS Cadet");
-			return 0;
+	v->type = V4L2_TUNER_RADIO;
+	switch (v->index) {
+	case 0:
+		strcpy(v->name, "FM");
+		v->capability = V4L2_TUNER_CAP_STEREO;
+		v->rangelow = 1400;     /* 87.5 MHz */
+		v->rangehigh = 1728;    /* 108.0 MHz */
+		v->rxsubchans=cadet_getstereo();
+		switch (v->rxsubchans){
+		case V4L2_TUNER_SUB_MONO:
+			v->audmode = V4L2_TUNER_MODE_MONO;
+			break;
+		case V4L2_TUNER_SUB_STEREO:
+			v->audmode = V4L2_TUNER_MODE_STEREO;
+			break;
+		default: ;
 		}
-		case VIDIOC_G_TUNER:
-		{
-			struct v4l2_tuner *t = arg;
-			memset(t,0,sizeof(*t));
-			t->type = V4L2_TUNER_RADIO;
-			switch (t->index)
-			{
-				case 0: strcpy(t->name, "FM");
-					t->capability = V4L2_TUNER_CAP_STEREO;
-					t->rangelow = 1400;     /* 87.5 MHz */
-					t->rangehigh = 1728;    /* 108.0 MHz */
-					t->rxsubchans=cadet_getstereo();
-					switch (t->rxsubchans){
-						case V4L2_TUNER_SUB_MONO:
-							t->audmode = V4L2_TUNER_MODE_MONO;
-							break;
-						case V4L2_TUNER_SUB_STEREO:
-							t->audmode = V4L2_TUNER_MODE_STEREO;
-							break;
-						default: ;
-					}
-					break;
-				case 1: strcpy(t->name, "AM");
-					t->capability = V4L2_TUNER_CAP_LOW;
-					t->rangelow = 8320;      /* 520 kHz */
-					t->rangehigh = 26400;    /* 1650 kHz */
-					t->rxsubchans = V4L2_TUNER_SUB_MONO;
-					t->audmode = V4L2_TUNER_MODE_MONO;
-					break;
-				default:
-					return -EINVAL;
-			}
+		break;
+	case 1:
+		strcpy(v->name, "AM");
+		v->capability = V4L2_TUNER_CAP_LOW;
+		v->rangelow = 8320;      /* 520 kHz */
+		v->rangehigh = 26400;    /* 1650 kHz */
+		v->rxsubchans = V4L2_TUNER_SUB_MONO;
+		v->audmode = V4L2_TUNER_MODE_MONO;
+		break;
+	default:
+		return -EINVAL;
+	}
+	v->signal = sigstrength; /* We might need to modify scaling of this */
+	return 0;
+}
 
-			t->signal = sigstrength; /* We might need to modify scaling of this */
-			return 0;
-		}
-		case VIDIOC_S_TUNER:
-		{
-			struct v4l2_tuner *t = arg;
-			if((t->index != 0)&&(t->index != 1))
-				return -EINVAL;
+static int vidioc_s_tuner(struct file *file, void *priv,
+				struct v4l2_tuner *v)
+{
+	if((v->index != 0)&&(v->index != 1))
+		return -EINVAL;
+	curtuner = v->index;
+	return 0;
+}
 
-			curtuner = t->index;
-			return 0;
-		}
-		case VIDIOC_G_FREQUENCY:
-		{
-			struct v4l2_frequency *f = arg;
-			memset(f,0,sizeof(*f));
-			f->tuner = curtuner;
-			f->type = V4L2_TUNER_RADIO;
-			f->frequency = cadet_getfreq();
-			return 0;
-		}
-		case VIDIOC_S_FREQUENCY:
-		{
-			struct v4l2_frequency *f = arg;
-			if (f->type != V4L2_TUNER_RADIO){
-				return -EINVAL;
-			}
-			if((curtuner==0)&&((f->frequency<1400)||(f->frequency>1728))) {
-				return -EINVAL;
-			}
-			if((curtuner==1)&&((f->frequency<8320)||(f->frequency>26400))) {
-				return -EINVAL;
-			}
-			cadet_setfreq(f->frequency);
-			return 0;
-		}
-		case VIDIOC_G_CTRL:
-		{
-			struct v4l2_control *c = arg;
-			switch (c->id){
-				case V4L2_CID_AUDIO_MUTE: /* TODO: Handle this correctly */
-					c->value = (cadet_getvol() == 0);
-					break;
-				case V4L2_CID_AUDIO_VOLUME:
-					c->value = cadet_getvol();
-					break;
-				default:
-					return -EINVAL;
-			}
-			return 0;
-		}
-		case VIDIOC_S_CTRL:
-		{
-			struct v4l2_control *c = arg;
-			switch (c->id){
-				case V4L2_CID_AUDIO_MUTE: /* TODO: Handle this correctly */
-					if (c->value) cadet_setvol(0);
-						else cadet_setvol(0xffff);
-					break;
-				case V4L2_CID_AUDIO_VOLUME:
-					cadet_setvol(c->value);
-					break;
-				default:
-					return -EINVAL;
-			}
+static int vidioc_g_frequency(struct file *file, void *priv,
+				struct v4l2_frequency *f)
+{
+	f->tuner = curtuner;
+	f->type = V4L2_TUNER_RADIO;
+	f->frequency = cadet_getfreq();
+	return 0;
+}
+
+
+static int vidioc_s_frequency(struct file *file, void *priv,
+				struct v4l2_frequency *f)
+{
+	if (f->type != V4L2_TUNER_RADIO)
+		return -EINVAL;
+	if((curtuner==0)&&((f->frequency<1400)||(f->frequency>1728)))
+		return -EINVAL;
+	if((curtuner==1)&&((f->frequency<8320)||(f->frequency>26400)))
+		return -EINVAL;
+	cadet_setfreq(f->frequency);
+	return 0;
+}
+
+static int vidioc_queryctrl(struct file *file, void *priv,
+				struct v4l2_queryctrl *qc)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(radio_qctrl); i++) {
+		if (qc->id && qc->id == radio_qctrl[i].id) {
+			memcpy(qc, &(radio_qctrl[i]),
+						sizeof(*qc));
 			return 0;
 		}
+	}
+	return -EINVAL;
+}
 
-		default:
-			return -ENOIOCTLCMD;
+static int vidioc_g_ctrl(struct file *file, void *priv,
+				struct v4l2_control *ctrl)
+{
+	switch (ctrl->id){
+	case V4L2_CID_AUDIO_MUTE: /* TODO: Handle this correctly */
+		ctrl->value = (cadet_getvol() == 0);
+		break;
+	case V4L2_CID_AUDIO_VOLUME:
+		ctrl->value = cadet_getvol();
+		break;
+	default:
+		return -EINVAL;
 	}
+	return 0;
 }
 
-static int
-cadet_ioctl(struct inode *inode, struct file *file,
-		       unsigned int cmd, unsigned long arg)
+static int vidioc_s_ctrl(struct file *file, void *priv,
+				struct v4l2_control *ctrl)
 {
-	return video_usercopy(inode, file, cmd, arg, cadet_do_ioctl);
+	switch (ctrl->id){
+	case V4L2_CID_AUDIO_MUTE: /* TODO: Handle this correctly */
+		if (ctrl->value)
+			cadet_setvol(0);
+		else
+			cadet_setvol(0xffff);
+		break;
+	case V4L2_CID_AUDIO_VOLUME:
+		cadet_setvol(ctrl->value);
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int vidioc_g_audio(struct file *file, void *priv,
+				struct v4l2_audio *a)
+{
+	if (a->index > 1)
+		return -EINVAL;
+	strcpy(a->name, "Radio");
+	a->capability = V4L2_AUDCAP_STEREO;
+	return 0;
+}
+
+static int vidioc_g_input(struct file *filp, void *priv, unsigned int *i)
+{
+	*i = 0;
+	return 0;
+}
+
+static int vidioc_s_input(struct file *filp, void *priv, unsigned int i)
+{
+	if (i != 0)
+		return -EINVAL;
+	return 0;
+}
+
+static int vidioc_s_audio(struct file *file, void *priv,
+				struct v4l2_audio *a)
+{
+	if (a->index != 0)
+		return -EINVAL;
+	return 0;
 }
 
 static int
@@ -512,7 +561,7 @@ static const struct file_operations cadet_fops = {
 	.open		= cadet_open,
 	.release       	= cadet_release,
 	.read		= cadet_read,
-	.ioctl		= cadet_ioctl,
+	.ioctl		= video_ioctl2,
 	.poll		= cadet_poll,
 	.compat_ioctl	= v4l_compat_ioctl32,
 	.llseek         = no_llseek,
@@ -524,6 +573,18 @@ static struct video_device cadet_radio=
 	.name		= "Cadet radio",
 	.type		= VID_TYPE_TUNER,
 	.fops           = &cadet_fops,
+	.vidioc_querycap    = vidioc_querycap,
+	.vidioc_g_tuner     = vidioc_g_tuner,
+	.vidioc_s_tuner     = vidioc_s_tuner,
+	.vidioc_g_frequency = vidioc_g_frequency,
+	.vidioc_s_frequency = vidioc_s_frequency,
+	.vidioc_queryctrl   = vidioc_queryctrl,
+	.vidioc_g_ctrl      = vidioc_g_ctrl,
+	.vidioc_s_ctrl      = vidioc_s_ctrl,
+	.vidioc_g_audio     = vidioc_g_audio,
+	.vidioc_s_audio     = vidioc_s_audio,
+	.vidioc_g_input     = vidioc_g_input,
+	.vidioc_s_input     = vidioc_s_input,
 };
 
 static struct pnp_device_id cadet_pnp_devices[] = {

commit fa027c2a0a0d6d1df6b29ee99048502c93da0dd4
Author: Arjan van de Ven <arjan@linux.intel.com>
Date:   Mon Feb 12 00:55:33 2007 -0800

    [PATCH] mark struct file_operations const 4
    
    Many struct file_operations in the kernel can be "const".  Marking them const
    moves these to the .rodata section, which avoids false sharing with potential
    dirty data.  In addition it'll catch accidental writes at compile time to
    these shared resources.
    
    [akpm@sdl.org: dvb fix]
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/media/radio/radio-cadet.c b/drivers/media/radio/radio-cadet.c
index 69d4b7919c5a..8fbf0d8bd278 100644
--- a/drivers/media/radio/radio-cadet.c
+++ b/drivers/media/radio/radio-cadet.c
@@ -507,7 +507,7 @@ cadet_poll(struct file *file, struct poll_table_struct *wait)
 }
 
 
-static struct file_operations cadet_fops = {
+static const struct file_operations cadet_fops = {
 	.owner		= THIS_MODULE,
 	.open		= cadet_open,
 	.release       	= cadet_release,

commit d591b9ccbe27fe974702411cff422fb6c6c62ad2
Author: Andrew Morton <akpm@osdl.org>
Date:   Tue Aug 8 10:52:22 2006 -0300

    V4L/DVB (4484): Git-dvb: cadet build fix
    
    drivers/media/radio/radio-cadet.c: In function 'cadet_do_ioctl':
    drivers/media/radio/radio-cadet.c:362: warning: implicit declaration of function 'KERNEL_VERSION'
    
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@infradead.org>

diff --git a/drivers/media/radio/radio-cadet.c b/drivers/media/radio/radio-cadet.c
index 938856588831..69d4b7919c5a 100644
--- a/drivers/media/radio/radio-cadet.c
+++ b/drivers/media/radio/radio-cadet.c
@@ -30,6 +30,7 @@
  *		Changed API to V4L2
  */
 
+#include <linux/version.h>
 #include <linux/module.h>	/* Modules 			*/
 #include <linux/init.h>		/* Initdata			*/
 #include <linux/ioport.h>	/* request_region		*/

commit c0c7fa096623c0cfdd9d253de9d874558066cdbb
Author: Hans J. Koch <koch@hjk-az.de>
Date:   Tue Aug 8 09:10:12 2006 -0300

    V4L/DVB (4406): Convert radio-cadet to V4L2 API
    
    This is a card with RDS capabilities.
    RDS specifications didn't change from V4L1 to V4L2, so that part should be OK.
    This patch changed the following stuff:
    * The device can be opened multiple times. That's necessary because there are
    at least a radio application and an RDS application (rdsd) that want to
    open() the device.
    * Added a poll() function. Every character device should have that, and rdsd
    expects it as it uses select() on that file descriptor.
    * Converted the ioctls to V4L2. MUTE is not implemented correctly as the
    card doesn't seem to have a special bit for that. Probably there are a few
    more ioctls that should at least return 0 or an error.
    As I do not own such a card, I couldn't test anything. If there is anybody out
    there who owns such an ancient card, please test and report.
    I just checked that the code compiles.
    
    Signed-off-by: Hans J. Koch <koch@hjk-az.de>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@infradead.org>

diff --git a/drivers/media/radio/radio-cadet.c b/drivers/media/radio/radio-cadet.c
index 8641aec7baf8..938856588831 100644
--- a/drivers/media/radio/radio-cadet.c
+++ b/drivers/media/radio/radio-cadet.c
@@ -25,6 +25,9 @@
  *
  * 2003-01-31	Alan Cox <alan@redhat.com>
  *		Cleaned up locking, delay code, general odds and ends
+ *
+ * 2006-07-30	Hans J. Koch <koch@hjk-az.de>
+ *		Changed API to V4L2
  */
 
 #include <linux/module.h>	/* Modules 			*/
@@ -33,12 +36,16 @@
 #include <linux/delay.h>	/* udelay			*/
 #include <asm/io.h>		/* outb, outb_p			*/
 #include <asm/uaccess.h>	/* copy to/from user		*/
-#include <linux/videodev.h>	/* kernel radio structs		*/
+#include <linux/videodev2.h>	/* V4L2 API defs		*/
 #include <media/v4l2-common.h>
 #include <linux/param.h>
 #include <linux/pnp.h>
 
 #define RDS_BUFFER 256
+#define RDS_RX_FLAG 1
+#define MBS_RX_FLAG 2
+
+#define CADET_VERSION KERNEL_VERSION(0,3,3)
 
 static int io=-1;		/* default to isapnp activation */
 static int radio_nr = -1;
@@ -61,44 +68,24 @@ static int cadet_probe(void);
  */
 static __u16 sigtable[2][4]={{5,10,30,150},{28,40,63,1000}};
 
-static int cadet_getrds(void)
-{
-	int rdsstat=0;
-
-	spin_lock(&cadet_io_lock);
-	outb(3,io);                 /* Select Decoder Control/Status */
-	outb(inb(io+1)&0x7f,io+1);  /* Reset RDS detection */
-	spin_unlock(&cadet_io_lock);
-
-	msleep(100);
-
-	spin_lock(&cadet_io_lock);
-	outb(3,io);                 /* Select Decoder Control/Status */
-	if((inb(io+1)&0x80)!=0) {
-		rdsstat|=VIDEO_TUNER_RDS_ON;
-	}
-	if((inb(io+1)&0x10)!=0) {
-		rdsstat|=VIDEO_TUNER_MBS_ON;
-	}
-	spin_unlock(&cadet_io_lock);
-	return rdsstat;
-}
 
-static int cadet_getstereo(void)
+static int
+cadet_getstereo(void)
 {
-	int ret = 0;
+	int ret = V4L2_TUNER_SUB_MONO;
 	if(curtuner != 0)	/* Only FM has stereo capability! */
-		return 0;
+		return V4L2_TUNER_SUB_MONO;
 
 	spin_lock(&cadet_io_lock);
 	outb(7,io);          /* Select tuner control */
 	if( (inb(io+1) & 0x40) == 0)
-		ret = 1;
+		ret = V4L2_TUNER_SUB_STEREO;
 	spin_unlock(&cadet_io_lock);
 	return ret;
 }
 
-static unsigned cadet_gettune(void)
+static unsigned
+cadet_gettune(void)
 {
 	int curvol,i;
 	unsigned fifo=0;
@@ -135,7 +122,8 @@ static unsigned cadet_gettune(void)
 	return fifo;
 }
 
-static unsigned cadet_getfreq(void)
+static unsigned
+cadet_getfreq(void)
 {
 	int i;
 	unsigned freq=0,test,fifo=0;
@@ -167,7 +155,8 @@ static unsigned cadet_getfreq(void)
 	return freq;
 }
 
-static void cadet_settune(unsigned fifo)
+static void
+cadet_settune(unsigned fifo)
 {
 	int i;
 	unsigned test;
@@ -195,7 +184,8 @@ static void cadet_settune(unsigned fifo)
 	spin_unlock(&cadet_io_lock);
 }
 
-static void cadet_setfreq(unsigned freq)
+static void
+cadet_setfreq(unsigned freq)
 {
 	unsigned fifo;
 	int i,j,test;
@@ -255,7 +245,8 @@ static void cadet_setfreq(unsigned freq)
 }
 
 
-static int cadet_getvol(void)
+static int
+cadet_getvol(void)
 {
 	int ret = 0;
 
@@ -270,7 +261,8 @@ static int cadet_getvol(void)
 }
 
 
-static void cadet_setvol(int vol)
+static void
+cadet_setvol(int vol)
 {
 	spin_lock(&cadet_io_lock);
 	outb(7,io);                /* Select tuner control */
@@ -281,7 +273,8 @@ static void cadet_setvol(int vol)
 	spin_unlock(&cadet_io_lock);
 }
 
-static void cadet_handler(unsigned long data)
+static void
+cadet_handler(unsigned long data)
 {
 	/*
 	 * Service the RDS fifo
@@ -322,8 +315,8 @@ static void cadet_handler(unsigned long data)
 
 
 
-static ssize_t cadet_read(struct file *file, char __user *data,
-			  size_t count, loff_t *ppos)
+static ssize_t
+cadet_read(struct file *file, char __user *data, size_t count, loff_t *ppos)
 {
 	int i=0;
 	unsigned char readbuf[RDS_BUFFER];
@@ -359,128 +352,156 @@ static int cadet_do_ioctl(struct inode *inode, struct file *file,
 {
 	switch(cmd)
 	{
-		case VIDIOCGCAP:
+		case VIDIOC_QUERYCAP:
 		{
-			struct video_capability *v = arg;
-			memset(v,0,sizeof(*v));
-			v->type=VID_TYPE_TUNER;
-			v->channels=2;
-			v->audios=1;
-			strcpy(v->name, "ADS Cadet");
+			struct v4l2_capability *cap = arg;
+			memset(cap,0,sizeof(*cap));
+			cap->capabilities =
+				V4L2_CAP_TUNER |
+				V4L2_CAP_READWRITE;
+			cap->version = CADET_VERSION;
+			strcpy(cap->driver, "ADS Cadet");
+			strcpy(cap->card, "ADS Cadet");
 			return 0;
 		}
-		case VIDIOCGTUNER:
+		case VIDIOC_G_TUNER:
 		{
-			struct video_tuner *v = arg;
-			if((v->tuner<0)||(v->tuner>1)) {
-				return -EINVAL;
-			}
-			switch(v->tuner) {
-				case 0:
-				strcpy(v->name,"FM");
-				v->rangelow=1400;     /* 87.5 MHz */
-				v->rangehigh=1728;    /* 108.0 MHz */
-				v->flags=0;
-				v->mode=0;
-				v->mode|=VIDEO_MODE_AUTO;
-				v->signal=sigstrength;
-				if(cadet_getstereo()==1) {
-					v->flags|=VIDEO_TUNER_STEREO_ON;
-				}
-				v->flags|=cadet_getrds();
-				break;
-				case 1:
-				strcpy(v->name,"AM");
-				v->rangelow=8320;      /* 520 kHz */
-				v->rangehigh=26400;    /* 1650 kHz */
-				v->flags=0;
-				v->flags|=VIDEO_TUNER_LOW;
-				v->mode=0;
-				v->mode|=VIDEO_MODE_AUTO;
-				v->signal=sigstrength;
-				break;
+			struct v4l2_tuner *t = arg;
+			memset(t,0,sizeof(*t));
+			t->type = V4L2_TUNER_RADIO;
+			switch (t->index)
+			{
+				case 0: strcpy(t->name, "FM");
+					t->capability = V4L2_TUNER_CAP_STEREO;
+					t->rangelow = 1400;     /* 87.5 MHz */
+					t->rangehigh = 1728;    /* 108.0 MHz */
+					t->rxsubchans=cadet_getstereo();
+					switch (t->rxsubchans){
+						case V4L2_TUNER_SUB_MONO:
+							t->audmode = V4L2_TUNER_MODE_MONO;
+							break;
+						case V4L2_TUNER_SUB_STEREO:
+							t->audmode = V4L2_TUNER_MODE_STEREO;
+							break;
+						default: ;
+					}
+					break;
+				case 1: strcpy(t->name, "AM");
+					t->capability = V4L2_TUNER_CAP_LOW;
+					t->rangelow = 8320;      /* 520 kHz */
+					t->rangehigh = 26400;    /* 1650 kHz */
+					t->rxsubchans = V4L2_TUNER_SUB_MONO;
+					t->audmode = V4L2_TUNER_MODE_MONO;
+					break;
+				default:
+					return -EINVAL;
 			}
+
+			t->signal = sigstrength; /* We might need to modify scaling of this */
 			return 0;
 		}
-		case VIDIOCSTUNER:
+		case VIDIOC_S_TUNER:
 		{
-			struct video_tuner *v = arg;
-			if((v->tuner<0)||(v->tuner>1)) {
+			struct v4l2_tuner *t = arg;
+			if((t->index != 0)&&(t->index != 1))
 				return -EINVAL;
-			}
-			curtuner=v->tuner;
+
+			curtuner = t->index;
 			return 0;
 		}
-		case VIDIOCGFREQ:
+		case VIDIOC_G_FREQUENCY:
 		{
-			unsigned long *freq = arg;
-			*freq = cadet_getfreq();
+			struct v4l2_frequency *f = arg;
+			memset(f,0,sizeof(*f));
+			f->tuner = curtuner;
+			f->type = V4L2_TUNER_RADIO;
+			f->frequency = cadet_getfreq();
 			return 0;
 		}
-		case VIDIOCSFREQ:
+		case VIDIOC_S_FREQUENCY:
 		{
-			unsigned long *freq = arg;
-			if((curtuner==0)&&((*freq<1400)||(*freq>1728))) {
+			struct v4l2_frequency *f = arg;
+			if (f->type != V4L2_TUNER_RADIO){
+				return -EINVAL;
+			}
+			if((curtuner==0)&&((f->frequency<1400)||(f->frequency>1728))) {
 				return -EINVAL;
 			}
-			if((curtuner==1)&&((*freq<8320)||(*freq>26400))) {
+			if((curtuner==1)&&((f->frequency<8320)||(f->frequency>26400))) {
 				return -EINVAL;
 			}
-			cadet_setfreq(*freq);
+			cadet_setfreq(f->frequency);
 			return 0;
 		}
-		case VIDIOCGAUDIO:
+		case VIDIOC_G_CTRL:
 		{
-			struct video_audio *v = arg;
-			memset(v,0, sizeof(*v));
-			v->flags=VIDEO_AUDIO_MUTABLE|VIDEO_AUDIO_VOLUME;
-			if(cadet_getstereo()==0) {
-				v->mode=VIDEO_SOUND_MONO;
-			} else {
-				v->mode=VIDEO_SOUND_STEREO;
+			struct v4l2_control *c = arg;
+			switch (c->id){
+				case V4L2_CID_AUDIO_MUTE: /* TODO: Handle this correctly */
+					c->value = (cadet_getvol() == 0);
+					break;
+				case V4L2_CID_AUDIO_VOLUME:
+					c->value = cadet_getvol();
+					break;
+				default:
+					return -EINVAL;
 			}
-			v->volume=cadet_getvol();
-			v->step=0xffff;
-			strcpy(v->name, "Radio");
 			return 0;
 		}
-		case VIDIOCSAUDIO:
+		case VIDIOC_S_CTRL:
 		{
-			struct video_audio *v = arg;
-			if(v->audio)
-				return -EINVAL;
-			cadet_setvol(v->volume);
-			if(v->flags&VIDEO_AUDIO_MUTE)
-				cadet_setvol(0);
-			else
-				cadet_setvol(0xffff);
+			struct v4l2_control *c = arg;
+			switch (c->id){
+				case V4L2_CID_AUDIO_MUTE: /* TODO: Handle this correctly */
+					if (c->value) cadet_setvol(0);
+						else cadet_setvol(0xffff);
+					break;
+				case V4L2_CID_AUDIO_VOLUME:
+					cadet_setvol(c->value);
+					break;
+				default:
+					return -EINVAL;
+			}
 			return 0;
 		}
+
 		default:
 			return -ENOIOCTLCMD;
 	}
 }
 
-static int cadet_ioctl(struct inode *inode, struct file *file,
+static int
+cadet_ioctl(struct inode *inode, struct file *file,
 		       unsigned int cmd, unsigned long arg)
 {
 	return video_usercopy(inode, file, cmd, arg, cadet_do_ioctl);
 }
 
-static int cadet_open(struct inode *inode, struct file *file)
+static int
+cadet_open(struct inode *inode, struct file *file)
 {
-	if(users)
-		return -EBUSY;
 	users++;
-	init_waitqueue_head(&read_queue);
+	if (1 == users) init_waitqueue_head(&read_queue);
 	return 0;
 }
 
-static int cadet_release(struct inode *inode, struct file *file)
+static int
+cadet_release(struct inode *inode, struct file *file)
 {
-	del_timer_sync(&readtimer);
-	rdsstat=0;
 	users--;
+	if (0 == users){
+		del_timer_sync(&readtimer);
+		rdsstat=0;
+	}
+	return 0;
+}
+
+static unsigned int
+cadet_poll(struct file *file, struct poll_table_struct *wait)
+{
+	poll_wait(file,&read_queue,wait);
+	if(rdsin != rdsout)
+		return POLLIN | POLLRDNORM;
 	return 0;
 }
 
@@ -491,6 +512,7 @@ static struct file_operations cadet_fops = {
 	.release       	= cadet_release,
 	.read		= cadet_read,
 	.ioctl		= cadet_ioctl,
+	.poll		= cadet_poll,
 	.compat_ioctl	= v4l_compat_ioctl32,
 	.llseek         = no_llseek,
 };
@@ -500,7 +522,6 @@ static struct video_device cadet_radio=
 	.owner		= THIS_MODULE,
 	.name		= "Cadet radio",
 	.type		= VID_TYPE_TUNER,
-	.hardware	= VID_HARDWARE_CADET,
 	.fops           = &cadet_fops,
 };
 

commit 5e87efa3b29c105f81fea785babafb098e4e046d
Author: Mauro Carvalho Chehab <mchehab@infradead.org>
Date:   Mon Jun 5 10:26:32 2006 -0300

    V4L/DVB (4068): Removed all references to kernel stuff from videodev.h and videodev2.h
    
    The videodev.h and videodev2.h describe the public API for V4L and V4L2.
    It shouldn't have there any kernel-specific stuff. Those were moved to
    v4l2-dev.h.
    This patch removes some uneeded headers and include v4l2-common.h on all
    V4L driver. This header includes device implementation of V4L2 API provided
    on v4l2-dev.h as well as V4L2 internal ioctls that provides connections
    between master driver and its i2c devices.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@infradead.org>

diff --git a/drivers/media/radio/radio-cadet.c b/drivers/media/radio/radio-cadet.c
index c048454c7ba5..8641aec7baf8 100644
--- a/drivers/media/radio/radio-cadet.c
+++ b/drivers/media/radio/radio-cadet.c
@@ -34,6 +34,7 @@
 #include <asm/io.h>		/* outb, outb_p			*/
 #include <asm/uaccess.h>	/* copy to/from user		*/
 #include <linux/videodev.h>	/* kernel radio structs		*/
+#include <media/v4l2-common.h>
 #include <linux/param.h>
 #include <linux/pnp.h>
 

commit 4286c6f65ec01efa8f5108cadea402ecf3b12279
Author: Mauro Carvalho Chehab <mchehab@infradead.org>
Date:   Sat Apr 8 16:06:16 2006 -0300

    V4L/DVB (3753): Whitespace cleanups at media/radio
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@infradead.org>

diff --git a/drivers/media/radio/radio-cadet.c b/drivers/media/radio/radio-cadet.c
index f1b5ac81e9d2..c048454c7ba5 100644
--- a/drivers/media/radio/radio-cadet.c
+++ b/drivers/media/radio/radio-cadet.c
@@ -8,7 +8,7 @@
  * Russell Kroll    (rkroll@exploits.org)
  * Quay Ly
  * Donald Song
- * Jason Lewis      (jlewis@twilight.vtc.vsc.edu) 
+ * Jason Lewis      (jlewis@twilight.vtc.vsc.edu)
  * Scott McGrath    (smcgrath@twilight.vtc.vsc.edu)
  * William McGrath  (wmcgrath@twilight.vtc.vsc.edu)
  *
@@ -55,29 +55,29 @@ static int cadet_probe(void);
 
 /*
  * Signal Strength Threshold Values
- * The V4L API spec does not define any particular unit for the signal 
+ * The V4L API spec does not define any particular unit for the signal
  * strength value.  These values are in microvolts of RF at the tuner's input.
  */
 static __u16 sigtable[2][4]={{5,10,30,150},{28,40,63,1000}};
 
 static int cadet_getrds(void)
 {
-        int rdsstat=0;
+	int rdsstat=0;
 
 	spin_lock(&cadet_io_lock);
-        outb(3,io);                 /* Select Decoder Control/Status */
+	outb(3,io);                 /* Select Decoder Control/Status */
 	outb(inb(io+1)&0x7f,io+1);  /* Reset RDS detection */
 	spin_unlock(&cadet_io_lock);
-	
+
 	msleep(100);
 
-	spin_lock(&cadet_io_lock);	
-        outb(3,io);                 /* Select Decoder Control/Status */
+	spin_lock(&cadet_io_lock);
+	outb(3,io);                 /* Select Decoder Control/Status */
 	if((inb(io+1)&0x80)!=0) {
-	        rdsstat|=VIDEO_TUNER_RDS_ON;
+		rdsstat|=VIDEO_TUNER_RDS_ON;
 	}
 	if((inb(io+1)&0x10)!=0) {
-	        rdsstat|=VIDEO_TUNER_MBS_ON;
+		rdsstat|=VIDEO_TUNER_MBS_ON;
 	}
 	spin_unlock(&cadet_io_lock);
 	return rdsstat;
@@ -86,49 +86,49 @@ static int cadet_getrds(void)
 static int cadet_getstereo(void)
 {
 	int ret = 0;
-        if(curtuner != 0)	/* Only FM has stereo capability! */
-	        return 0;
+	if(curtuner != 0)	/* Only FM has stereo capability! */
+		return 0;
 
 	spin_lock(&cadet_io_lock);
-        outb(7,io);          /* Select tuner control */
+	outb(7,io);          /* Select tuner control */
 	if( (inb(io+1) & 0x40) == 0)
-        	ret = 1;
-        spin_unlock(&cadet_io_lock);
-        return ret;
+		ret = 1;
+	spin_unlock(&cadet_io_lock);
+	return ret;
 }
 
 static unsigned cadet_gettune(void)
 {
-        int curvol,i;
+	int curvol,i;
 	unsigned fifo=0;
 
-        /*
-         * Prepare for read
-         */
+	/*
+	 * Prepare for read
+	 */
 
 	spin_lock(&cadet_io_lock);
-	
-        outb(7,io);       /* Select tuner control */
-        curvol=inb(io+1); /* Save current volume/mute setting */
-        outb(0x00,io+1);  /* Ensure WRITE-ENABLE is LOW */
+
+	outb(7,io);       /* Select tuner control */
+	curvol=inb(io+1); /* Save current volume/mute setting */
+	outb(0x00,io+1);  /* Ensure WRITE-ENABLE is LOW */
 	tunestat=0xffff;
 
-        /*
-         * Read the shift register
-         */
-        for(i=0;i<25;i++) {
-                fifo=(fifo<<1)|((inb(io+1)>>7)&0x01);
-                if(i<24) {
-                        outb(0x01,io+1);
+	/*
+	 * Read the shift register
+	 */
+	for(i=0;i<25;i++) {
+		fifo=(fifo<<1)|((inb(io+1)>>7)&0x01);
+		if(i<24) {
+			outb(0x01,io+1);
 			tunestat&=inb(io+1);
-                        outb(0x00,io+1);
-                }
-        }
-
-        /*
-         * Restore volume/mute setting
-         */
-        outb(curvol,io+1);
+			outb(0x00,io+1);
+		}
+	}
+
+	/*
+	 * Restore volume/mute setting
+	 */
+	outb(curvol,io+1);
 	spin_unlock(&cadet_io_lock);
 
 	return fifo;
@@ -136,43 +136,43 @@ static unsigned cadet_gettune(void)
 
 static unsigned cadet_getfreq(void)
 {
-        int i;
-        unsigned freq=0,test,fifo=0;
+	int i;
+	unsigned freq=0,test,fifo=0;
 
 	/*
 	 * Read current tuning
 	 */
 	fifo=cadet_gettune();
 
-        /*
-         * Convert to actual frequency
-         */
+	/*
+	 * Convert to actual frequency
+	 */
 	if(curtuner==0) {    /* FM */
-	        test=12500;
-                for(i=0;i<14;i++) {
-                        if((fifo&0x01)!=0) {
-                                freq+=test;
-                        }
-                        test=test<<1;
-                        fifo=fifo>>1;
-                }
-                freq-=10700000;           /* IF frequency is 10.7 MHz */
-                freq=(freq*16)/1000000;   /* Make it 1/16 MHz */
+		test=12500;
+		for(i=0;i<14;i++) {
+			if((fifo&0x01)!=0) {
+				freq+=test;
+			}
+			test=test<<1;
+			fifo=fifo>>1;
+		}
+		freq-=10700000;           /* IF frequency is 10.7 MHz */
+		freq=(freq*16)/1000000;   /* Make it 1/16 MHz */
 	}
 	if(curtuner==1) {    /* AM */
-	        freq=((fifo&0x7fff)-2010)*16;
+		freq=((fifo&0x7fff)-2010)*16;
 	}
 
-        return freq;
+	return freq;
 }
 
 static void cadet_settune(unsigned fifo)
 {
-        int i;
-	unsigned test;  
+	int i;
+	unsigned test;
 
 	spin_lock(&cadet_io_lock);
-	
+
 	outb(7,io);                /* Select tuner control */
 	/*
 	 * Write the shift register
@@ -183,7 +183,7 @@ static void cadet_settune(unsigned fifo)
 	outb(7,io);                /* Select tuner control */
 	outb(test,io+1);           /* Initialize for write */
 	for(i=0;i<25;i++) {
-   	        test|=0x01;              /* Toggle SCK High */
+		test|=0x01;              /* Toggle SCK High */
 		outb(test,io+1);
 		test&=0xfe;              /* Toggle SCK Low */
 		outb(test,io+1);
@@ -196,57 +196,57 @@ static void cadet_settune(unsigned fifo)
 
 static void cadet_setfreq(unsigned freq)
 {
-        unsigned fifo;
-        int i,j,test;
-        int curvol;
+	unsigned fifo;
+	int i,j,test;
+	int curvol;
 
-        /* 
-         * Formulate a fifo command
-         */
+	/*
+	 * Formulate a fifo command
+	 */
 	fifo=0;
 	if(curtuner==0) {    /* FM */
-        	test=102400;
-                freq=(freq*1000)/16;       /* Make it kHz */
-                freq+=10700;               /* IF is 10700 kHz */
-                for(i=0;i<14;i++) {
-                        fifo=fifo<<1;
-                        if(freq>=test) {
-                                fifo|=0x01;
-                                freq-=test;
-                        }
-                        test=test>>1;
-                }
+		test=102400;
+		freq=(freq*1000)/16;       /* Make it kHz */
+		freq+=10700;               /* IF is 10700 kHz */
+		for(i=0;i<14;i++) {
+			fifo=fifo<<1;
+			if(freq>=test) {
+				fifo|=0x01;
+				freq-=test;
+			}
+			test=test>>1;
+		}
 	}
 	if(curtuner==1) {    /* AM */
-                fifo=(freq/16)+2010;            /* Make it kHz */
+		fifo=(freq/16)+2010;            /* Make it kHz */
 		fifo|=0x100000;            /* Select AM Band */
 	}
 
-        /*
-         * Save current volume/mute setting
-         */
+	/*
+	 * Save current volume/mute setting
+	 */
 
 	spin_lock(&cadet_io_lock);
 	outb(7,io);                /* Select tuner control */
-        curvol=inb(io+1); 
-        spin_unlock(&cadet_io_lock);
+	curvol=inb(io+1);
+	spin_unlock(&cadet_io_lock);
 
 	/*
 	 * Tune the card
 	 */
 	for(j=3;j>-1;j--) {
-	        cadet_settune(fifo|(j<<16));
-	        
-	        spin_lock(&cadet_io_lock);
+		cadet_settune(fifo|(j<<16));
+
+		spin_lock(&cadet_io_lock);
 		outb(7,io);         /* Select tuner control */
 		outb(curvol,io+1);
 		spin_unlock(&cadet_io_lock);
-		
+
 		msleep(100);
 
 		cadet_gettune();
 		if((tunestat & 0x40) == 0) {   /* Tuned */
-		        sigstrength=sigtable[curtuner][j];
+			sigstrength=sigtable[curtuner][j];
 			return;
 		}
 	}
@@ -257,28 +257,28 @@ static void cadet_setfreq(unsigned freq)
 static int cadet_getvol(void)
 {
 	int ret = 0;
-	
+
 	spin_lock(&cadet_io_lock);
-	
-        outb(7,io);                /* Select tuner control */
-        if((inb(io + 1) & 0x20) != 0)
-        	ret = 0xffff;
-        
-        spin_unlock(&cadet_io_lock);
-        return ret;
+
+	outb(7,io);                /* Select tuner control */
+	if((inb(io + 1) & 0x20) != 0)
+		ret = 0xffff;
+
+	spin_unlock(&cadet_io_lock);
+	return ret;
 }
 
 
 static void cadet_setvol(int vol)
 {
 	spin_lock(&cadet_io_lock);
-        outb(7,io);                /* Select tuner control */
-        if(vol>0)
-                outb(0x20,io+1);
-        else
-                outb(0x00,io+1);
+	outb(7,io);                /* Select tuner control */
+	if(vol>0)
+		outb(0x20,io+1);
+	else
+		outb(0x00,io+1);
 	spin_unlock(&cadet_io_lock);
-}  
+}
 
 static void cadet_handler(unsigned long data)
 {
@@ -288,15 +288,15 @@ static void cadet_handler(unsigned long data)
 
 	if(spin_trylock(&cadet_io_lock))
 	{
-	        outb(0x3,io);       /* Select RDS Decoder Control */
+		outb(0x3,io);       /* Select RDS Decoder Control */
 		if((inb(io+1)&0x20)!=0) {
-		        printk(KERN_CRIT "cadet: RDS fifo overflow\n");
+			printk(KERN_CRIT "cadet: RDS fifo overflow\n");
 		}
 		outb(0x80,io);      /* Select RDS fifo */
 		while((inb(io)&0x80)!=0) {
-		        rdsbuf[rdsin]=inb(io+1);
+			rdsbuf[rdsin]=inb(io+1);
 			if(rdsin==rdsout)
-			        printk(KERN_WARNING "cadet: RDS buffer overflow\n");
+				printk(KERN_WARNING "cadet: RDS buffer overflow\n");
 			else
 				rdsin++;
 		}
@@ -307,9 +307,9 @@ static void cadet_handler(unsigned long data)
 	 * Service pending read
 	 */
 	if( rdsin!=rdsout)
-	        wake_up_interruptible(&read_queue);
+		wake_up_interruptible(&read_queue);
 
-	/* 
+	/*
 	 * Clean up and exit
 	 */
 	init_timer(&readtimer);
@@ -324,12 +324,12 @@ static void cadet_handler(unsigned long data)
 static ssize_t cadet_read(struct file *file, char __user *data,
 			  size_t count, loff_t *ppos)
 {
-        int i=0;
+	int i=0;
 	unsigned char readbuf[RDS_BUFFER];
 
-        if(rdsstat==0) {
+	if(rdsstat==0) {
 		spin_lock(&cadet_io_lock);
-	        rdsstat=1;
+		rdsstat=1;
 		outb(0x80,io);        /* Select RDS fifo */
 		spin_unlock(&cadet_io_lock);
 		init_timer(&readtimer);
@@ -339,15 +339,15 @@ static ssize_t cadet_read(struct file *file, char __user *data,
 		add_timer(&readtimer);
 	}
 	if(rdsin==rdsout) {
-  	        if (file->f_flags & O_NONBLOCK)
-		        return -EWOULDBLOCK;
-	        interruptible_sleep_on(&read_queue);
-	}		
+		if (file->f_flags & O_NONBLOCK)
+			return -EWOULDBLOCK;
+		interruptible_sleep_on(&read_queue);
+	}
 	while( i<count && rdsin!=rdsout)
-	        readbuf[i++]=rdsbuf[rdsout++];
+		readbuf[i++]=rdsbuf[rdsout++];
 
 	if (copy_to_user(data,readbuf,i))
-	        return -EFAULT;
+		return -EFAULT;
 	return i;
 }
 
@@ -375,29 +375,29 @@ static int cadet_do_ioctl(struct inode *inode, struct file *file,
 				return -EINVAL;
 			}
 			switch(v->tuner) {
-			        case 0:
-			        strcpy(v->name,"FM");
-			        v->rangelow=1400;     /* 87.5 MHz */
-			        v->rangehigh=1728;    /* 108.0 MHz */
-			        v->flags=0;
-			        v->mode=0;
-			        v->mode|=VIDEO_MODE_AUTO;
-			        v->signal=sigstrength;
-			        if(cadet_getstereo()==1) {
-				        v->flags|=VIDEO_TUNER_STEREO_ON;
-			        }
+				case 0:
+				strcpy(v->name,"FM");
+				v->rangelow=1400;     /* 87.5 MHz */
+				v->rangehigh=1728;    /* 108.0 MHz */
+				v->flags=0;
+				v->mode=0;
+				v->mode|=VIDEO_MODE_AUTO;
+				v->signal=sigstrength;
+				if(cadet_getstereo()==1) {
+					v->flags|=VIDEO_TUNER_STEREO_ON;
+				}
 				v->flags|=cadet_getrds();
-			        break;
-			        case 1:
-			        strcpy(v->name,"AM");
-			        v->rangelow=8320;      /* 520 kHz */
-			        v->rangehigh=26400;    /* 1650 kHz */
-			        v->flags=0;
-			        v->flags|=VIDEO_TUNER_LOW;
-			        v->mode=0;
-			        v->mode|=VIDEO_MODE_AUTO;
-			        v->signal=sigstrength;
-			        break;
+				break;
+				case 1:
+				strcpy(v->name,"AM");
+				v->rangelow=8320;      /* 520 kHz */
+				v->rangehigh=26400;    /* 1650 kHz */
+				v->flags=0;
+				v->flags|=VIDEO_TUNER_LOW;
+				v->mode=0;
+				v->mode|=VIDEO_MODE_AUTO;
+				v->signal=sigstrength;
+				break;
 			}
 			return 0;
 		}
@@ -407,49 +407,49 @@ static int cadet_do_ioctl(struct inode *inode, struct file *file,
 			if((v->tuner<0)||(v->tuner>1)) {
 				return -EINVAL;
 			}
-			curtuner=v->tuner;	
+			curtuner=v->tuner;
 			return 0;
 		}
 		case VIDIOCGFREQ:
 		{
-		        unsigned long *freq = arg;
+			unsigned long *freq = arg;
 			*freq = cadet_getfreq();
 			return 0;
 		}
 		case VIDIOCSFREQ:
 		{
-		        unsigned long *freq = arg;
+			unsigned long *freq = arg;
 			if((curtuner==0)&&((*freq<1400)||(*freq>1728))) {
-			        return -EINVAL;
+				return -EINVAL;
 			}
 			if((curtuner==1)&&((*freq<8320)||(*freq>26400))) {
-			        return -EINVAL;
+				return -EINVAL;
 			}
 			cadet_setfreq(*freq);
 			return 0;
 		}
 		case VIDIOCGAUDIO:
-		{	
+		{
 			struct video_audio *v = arg;
 			memset(v,0, sizeof(*v));
 			v->flags=VIDEO_AUDIO_MUTABLE|VIDEO_AUDIO_VOLUME;
 			if(cadet_getstereo()==0) {
-			        v->mode=VIDEO_SOUND_MONO;
+				v->mode=VIDEO_SOUND_MONO;
 			} else {
 				v->mode=VIDEO_SOUND_STEREO;
 			}
 			v->volume=cadet_getvol();
 			v->step=0xffff;
 			strcpy(v->name, "Radio");
-			return 0;			
+			return 0;
 		}
 		case VIDIOCSAUDIO:
 		{
 			struct video_audio *v = arg;
-			if(v->audio) 
+			if(v->audio)
 				return -EINVAL;
 			cadet_setvol(v->volume);
-			if(v->flags&VIDEO_AUDIO_MUTE) 
+			if(v->flags&VIDEO_AUDIO_MUTE)
 				cadet_setvol(0);
 			else
 				cadet_setvol(0xffff);
@@ -539,16 +539,16 @@ static struct pnp_driver cadet_pnp_driver = {
 
 static int cadet_probe(void)
 {
-        static int iovals[8]={0x330,0x332,0x334,0x336,0x338,0x33a,0x33c,0x33e};
+	static int iovals[8]={0x330,0x332,0x334,0x336,0x338,0x33a,0x33c,0x33e};
 	int i;
 
 	for(i=0;i<8;i++) {
-	        io=iovals[i];
+		io=iovals[i];
 		if (request_region(io, 2, "cadet-probe")) {
-		        cadet_setfreq(1410);
+			cadet_setfreq(1410);
 			if(cadet_getfreq()==1410) {
 				release_region(io, 2);
-			        return io;
+				return io;
 			}
 			release_region(io, 2);
 		}
@@ -556,7 +556,7 @@ static int cadet_probe(void)
 	return -1;
 }
 
-/* 
+/*
  * io should only be set if the user has used something like
  * isapnp (the userspace program) to initialize this card for us
  */
@@ -564,7 +564,7 @@ static int cadet_probe(void)
 static int __init cadet_init(void)
 {
 	spin_lock_init(&cadet_io_lock);
-	
+
 	/*
 	 *	If a probe was requested then probe ISAPnP first (safest)
 	 */
@@ -579,12 +579,12 @@ static int __init cadet_init(void)
 	/*
 	 *	Else we bail out
 	 */
-	 
-        if(io < 0) {
-#ifdef MODULE        
+
+	if(io < 0) {
+#ifdef MODULE
 		printk(KERN_ERR "You must set an I/O address with io=0x???\n");
 #endif
-	        goto fail;
+		goto fail;
 	}
 	if (!request_region(io,2,"cadet"))
 		goto fail;

commit 0d0fbf8152fb3bb4393be11e8df7f70e1fbbd738
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Jan 9 15:24:57 2006 -0200

    V4L (926_2): Moves compat32 functions from fs to v4l subsystem
    
    This moves the 32 bit ioctl compatibility handlers for
    Video4Linux into a new file and adds explicit calls to them
    to each v4l device driver.
    
    Unfortunately, there does not seem to be any code handling
    the v4l2 ioctls, so quite often the code goes through two
    separate conversions, first from 32 bit v4l to 64 bit v4l,
    and from there to 64 bit v4l2. My patch does not change
    that, so there is still much room for improvement.
    
    Also, some drivers have additional ioctl numbers, for
    which the conversion should be handled internally to
    that driver.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@brturbo.com.br>

diff --git a/drivers/media/radio/radio-cadet.c b/drivers/media/radio/radio-cadet.c
index 9b0406318f2d..f1b5ac81e9d2 100644
--- a/drivers/media/radio/radio-cadet.c
+++ b/drivers/media/radio/radio-cadet.c
@@ -490,6 +490,7 @@ static struct file_operations cadet_fops = {
 	.release       	= cadet_release,
 	.read		= cadet_read,
 	.ioctl		= cadet_ioctl,
+	.compat_ioctl	= v4l_compat_ioctl32,
 	.llseek         = no_llseek,
 };
 

commit f1ac046d7b297186f755fb213589b539426e1406
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Fri Oct 14 15:59:04 2005 -0700

    [PATCH] radio-cadet: check request_region() return value correctly
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/media/radio/radio-cadet.c b/drivers/media/radio/radio-cadet.c
index 022913da8c59..9b0406318f2d 100644
--- a/drivers/media/radio/radio-cadet.c
+++ b/drivers/media/radio/radio-cadet.c
@@ -543,7 +543,7 @@ static int cadet_probe(void)
 
 	for(i=0;i<8;i++) {
 	        io=iovals[i];
-	        if(request_region(io,2, "cadet-probe")>=0) {
+		if (request_region(io, 2, "cadet-probe")) {
 		        cadet_setfreq(1410);
 			if(cadet_getfreq()==1410) {
 				release_region(io, 2);

commit fb911ee849756fc6c609dddded92d9207ff3fb29
Author: Peter Osterlund <petero2@telia.com>
Date:   Tue Sep 13 01:25:15 2005 -0700

    [PATCH] Remove unnecessary check_region references in comments
    
    Remove check_region references from comments and printk statements so that
    searching for real users of this deprecated function gets easier.
    
    Signed-off-by: Peter Osterlund <petero2@telia.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/media/radio/radio-cadet.c b/drivers/media/radio/radio-cadet.c
index 53d399b6652b..022913da8c59 100644
--- a/drivers/media/radio/radio-cadet.c
+++ b/drivers/media/radio/radio-cadet.c
@@ -29,7 +29,7 @@
 
 #include <linux/module.h>	/* Modules 			*/
 #include <linux/init.h>		/* Initdata			*/
-#include <linux/ioport.h>	/* check_region, request_region	*/
+#include <linux/ioport.h>	/* request_region		*/
 #include <linux/delay.h>	/* udelay			*/
 #include <asm/io.h>		/* outb, outb_p			*/
 #include <asm/uaccess.h>	/* copy to/from user		*/

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/media/radio/radio-cadet.c b/drivers/media/radio/radio-cadet.c
new file mode 100644
index 000000000000..53d399b6652b
--- /dev/null
+++ b/drivers/media/radio/radio-cadet.c
@@ -0,0 +1,620 @@
+/* radio-cadet.c - A video4linux driver for the ADS Cadet AM/FM Radio Card
+ *
+ * by Fred Gleason <fredg@wava.com>
+ * Version 0.3.3
+ *
+ * (Loosely) based on code for the Aztech radio card by
+ *
+ * Russell Kroll    (rkroll@exploits.org)
+ * Quay Ly
+ * Donald Song
+ * Jason Lewis      (jlewis@twilight.vtc.vsc.edu) 
+ * Scott McGrath    (smcgrath@twilight.vtc.vsc.edu)
+ * William McGrath  (wmcgrath@twilight.vtc.vsc.edu)
+ *
+ * History:
+ * 2000-04-29	Russell Kroll <rkroll@exploits.org>
+ *		Added ISAPnP detection for Linux 2.3/2.4
+ *
+ * 2001-01-10	Russell Kroll <rkroll@exploits.org>
+ *		Removed dead CONFIG_RADIO_CADET_PORT code
+ *		PnP detection on load is now default (no args necessary)
+ *
+ * 2002-01-17	Adam Belay <ambx1@neo.rr.com>
+ *		Updated to latest pnp code
+ *
+ * 2003-01-31	Alan Cox <alan@redhat.com>
+ *		Cleaned up locking, delay code, general odds and ends
+ */
+
+#include <linux/module.h>	/* Modules 			*/
+#include <linux/init.h>		/* Initdata			*/
+#include <linux/ioport.h>	/* check_region, request_region	*/
+#include <linux/delay.h>	/* udelay			*/
+#include <asm/io.h>		/* outb, outb_p			*/
+#include <asm/uaccess.h>	/* copy to/from user		*/
+#include <linux/videodev.h>	/* kernel radio structs		*/
+#include <linux/param.h>
+#include <linux/pnp.h>
+
+#define RDS_BUFFER 256
+
+static int io=-1;		/* default to isapnp activation */
+static int radio_nr = -1;
+static int users=0;
+static int curtuner=0;
+static int tunestat=0;
+static int sigstrength=0;
+static wait_queue_head_t read_queue;
+static struct timer_list readtimer;
+static __u8 rdsin=0,rdsout=0,rdsstat=0;
+static unsigned char rdsbuf[RDS_BUFFER];
+static spinlock_t cadet_io_lock;
+
+static int cadet_probe(void);
+
+/*
+ * Signal Strength Threshold Values
+ * The V4L API spec does not define any particular unit for the signal 
+ * strength value.  These values are in microvolts of RF at the tuner's input.
+ */
+static __u16 sigtable[2][4]={{5,10,30,150},{28,40,63,1000}};
+
+static int cadet_getrds(void)
+{
+        int rdsstat=0;
+
+	spin_lock(&cadet_io_lock);
+        outb(3,io);                 /* Select Decoder Control/Status */
+	outb(inb(io+1)&0x7f,io+1);  /* Reset RDS detection */
+	spin_unlock(&cadet_io_lock);
+	
+	msleep(100);
+
+	spin_lock(&cadet_io_lock);	
+        outb(3,io);                 /* Select Decoder Control/Status */
+	if((inb(io+1)&0x80)!=0) {
+	        rdsstat|=VIDEO_TUNER_RDS_ON;
+	}
+	if((inb(io+1)&0x10)!=0) {
+	        rdsstat|=VIDEO_TUNER_MBS_ON;
+	}
+	spin_unlock(&cadet_io_lock);
+	return rdsstat;
+}
+
+static int cadet_getstereo(void)
+{
+	int ret = 0;
+        if(curtuner != 0)	/* Only FM has stereo capability! */
+	        return 0;
+
+	spin_lock(&cadet_io_lock);
+        outb(7,io);          /* Select tuner control */
+	if( (inb(io+1) & 0x40) == 0)
+        	ret = 1;
+        spin_unlock(&cadet_io_lock);
+        return ret;
+}
+
+static unsigned cadet_gettune(void)
+{
+        int curvol,i;
+	unsigned fifo=0;
+
+        /*
+         * Prepare for read
+         */
+
+	spin_lock(&cadet_io_lock);
+	
+        outb(7,io);       /* Select tuner control */
+        curvol=inb(io+1); /* Save current volume/mute setting */
+        outb(0x00,io+1);  /* Ensure WRITE-ENABLE is LOW */
+	tunestat=0xffff;
+
+        /*
+         * Read the shift register
+         */
+        for(i=0;i<25;i++) {
+                fifo=(fifo<<1)|((inb(io+1)>>7)&0x01);
+                if(i<24) {
+                        outb(0x01,io+1);
+			tunestat&=inb(io+1);
+                        outb(0x00,io+1);
+                }
+        }
+
+        /*
+         * Restore volume/mute setting
+         */
+        outb(curvol,io+1);
+	spin_unlock(&cadet_io_lock);
+
+	return fifo;
+}
+
+static unsigned cadet_getfreq(void)
+{
+        int i;
+        unsigned freq=0,test,fifo=0;
+
+	/*
+	 * Read current tuning
+	 */
+	fifo=cadet_gettune();
+
+        /*
+         * Convert to actual frequency
+         */
+	if(curtuner==0) {    /* FM */
+	        test=12500;
+                for(i=0;i<14;i++) {
+                        if((fifo&0x01)!=0) {
+                                freq+=test;
+                        }
+                        test=test<<1;
+                        fifo=fifo>>1;
+                }
+                freq-=10700000;           /* IF frequency is 10.7 MHz */
+                freq=(freq*16)/1000000;   /* Make it 1/16 MHz */
+	}
+	if(curtuner==1) {    /* AM */
+	        freq=((fifo&0x7fff)-2010)*16;
+	}
+
+        return freq;
+}
+
+static void cadet_settune(unsigned fifo)
+{
+        int i;
+	unsigned test;  
+
+	spin_lock(&cadet_io_lock);
+	
+	outb(7,io);                /* Select tuner control */
+	/*
+	 * Write the shift register
+	 */
+	test=0;
+	test=(fifo>>23)&0x02;      /* Align data for SDO */
+	test|=0x1c;                /* SDM=1, SWE=1, SEN=1, SCK=0 */
+	outb(7,io);                /* Select tuner control */
+	outb(test,io+1);           /* Initialize for write */
+	for(i=0;i<25;i++) {
+   	        test|=0x01;              /* Toggle SCK High */
+		outb(test,io+1);
+		test&=0xfe;              /* Toggle SCK Low */
+		outb(test,io+1);
+		fifo=fifo<<1;            /* Prepare the next bit */
+		test=0x1c|((fifo>>23)&0x02);
+		outb(test,io+1);
+	}
+	spin_unlock(&cadet_io_lock);
+}
+
+static void cadet_setfreq(unsigned freq)
+{
+        unsigned fifo;
+        int i,j,test;
+        int curvol;
+
+        /* 
+         * Formulate a fifo command
+         */
+	fifo=0;
+	if(curtuner==0) {    /* FM */
+        	test=102400;
+                freq=(freq*1000)/16;       /* Make it kHz */
+                freq+=10700;               /* IF is 10700 kHz */
+                for(i=0;i<14;i++) {
+                        fifo=fifo<<1;
+                        if(freq>=test) {
+                                fifo|=0x01;
+                                freq-=test;
+                        }
+                        test=test>>1;
+                }
+	}
+	if(curtuner==1) {    /* AM */
+                fifo=(freq/16)+2010;            /* Make it kHz */
+		fifo|=0x100000;            /* Select AM Band */
+	}
+
+        /*
+         * Save current volume/mute setting
+         */
+
+	spin_lock(&cadet_io_lock);
+	outb(7,io);                /* Select tuner control */
+        curvol=inb(io+1); 
+        spin_unlock(&cadet_io_lock);
+
+	/*
+	 * Tune the card
+	 */
+	for(j=3;j>-1;j--) {
+	        cadet_settune(fifo|(j<<16));
+	        
+	        spin_lock(&cadet_io_lock);
+		outb(7,io);         /* Select tuner control */
+		outb(curvol,io+1);
+		spin_unlock(&cadet_io_lock);
+		
+		msleep(100);
+
+		cadet_gettune();
+		if((tunestat & 0x40) == 0) {   /* Tuned */
+		        sigstrength=sigtable[curtuner][j];
+			return;
+		}
+	}
+	sigstrength=0;
+}
+
+
+static int cadet_getvol(void)
+{
+	int ret = 0;
+	
+	spin_lock(&cadet_io_lock);
+	
+        outb(7,io);                /* Select tuner control */
+        if((inb(io + 1) & 0x20) != 0)
+        	ret = 0xffff;
+        
+        spin_unlock(&cadet_io_lock);
+        return ret;
+}
+
+
+static void cadet_setvol(int vol)
+{
+	spin_lock(&cadet_io_lock);
+        outb(7,io);                /* Select tuner control */
+        if(vol>0)
+                outb(0x20,io+1);
+        else
+                outb(0x00,io+1);
+	spin_unlock(&cadet_io_lock);
+}  
+
+static void cadet_handler(unsigned long data)
+{
+	/*
+	 * Service the RDS fifo
+	 */
+
+	if(spin_trylock(&cadet_io_lock))
+	{
+	        outb(0x3,io);       /* Select RDS Decoder Control */
+		if((inb(io+1)&0x20)!=0) {
+		        printk(KERN_CRIT "cadet: RDS fifo overflow\n");
+		}
+		outb(0x80,io);      /* Select RDS fifo */
+		while((inb(io)&0x80)!=0) {
+		        rdsbuf[rdsin]=inb(io+1);
+			if(rdsin==rdsout)
+			        printk(KERN_WARNING "cadet: RDS buffer overflow\n");
+			else
+				rdsin++;
+		}
+		spin_unlock(&cadet_io_lock);
+	}
+
+	/*
+	 * Service pending read
+	 */
+	if( rdsin!=rdsout)
+	        wake_up_interruptible(&read_queue);
+
+	/* 
+	 * Clean up and exit
+	 */
+	init_timer(&readtimer);
+	readtimer.function=cadet_handler;
+	readtimer.data=(unsigned long)0;
+	readtimer.expires=jiffies+(HZ/20);
+	add_timer(&readtimer);
+}
+
+
+
+static ssize_t cadet_read(struct file *file, char __user *data,
+			  size_t count, loff_t *ppos)
+{
+        int i=0;
+	unsigned char readbuf[RDS_BUFFER];
+
+        if(rdsstat==0) {
+		spin_lock(&cadet_io_lock);
+	        rdsstat=1;
+		outb(0x80,io);        /* Select RDS fifo */
+		spin_unlock(&cadet_io_lock);
+		init_timer(&readtimer);
+		readtimer.function=cadet_handler;
+		readtimer.data=(unsigned long)0;
+		readtimer.expires=jiffies+(HZ/20);
+		add_timer(&readtimer);
+	}
+	if(rdsin==rdsout) {
+  	        if (file->f_flags & O_NONBLOCK)
+		        return -EWOULDBLOCK;
+	        interruptible_sleep_on(&read_queue);
+	}		
+	while( i<count && rdsin!=rdsout)
+	        readbuf[i++]=rdsbuf[rdsout++];
+
+	if (copy_to_user(data,readbuf,i))
+	        return -EFAULT;
+	return i;
+}
+
+
+
+static int cadet_do_ioctl(struct inode *inode, struct file *file,
+			  unsigned int cmd, void *arg)
+{
+	switch(cmd)
+	{
+		case VIDIOCGCAP:
+		{
+			struct video_capability *v = arg;
+			memset(v,0,sizeof(*v));
+			v->type=VID_TYPE_TUNER;
+			v->channels=2;
+			v->audios=1;
+			strcpy(v->name, "ADS Cadet");
+			return 0;
+		}
+		case VIDIOCGTUNER:
+		{
+			struct video_tuner *v = arg;
+			if((v->tuner<0)||(v->tuner>1)) {
+				return -EINVAL;
+			}
+			switch(v->tuner) {
+			        case 0:
+			        strcpy(v->name,"FM");
+			        v->rangelow=1400;     /* 87.5 MHz */
+			        v->rangehigh=1728;    /* 108.0 MHz */
+			        v->flags=0;
+			        v->mode=0;
+			        v->mode|=VIDEO_MODE_AUTO;
+			        v->signal=sigstrength;
+			        if(cadet_getstereo()==1) {
+				        v->flags|=VIDEO_TUNER_STEREO_ON;
+			        }
+				v->flags|=cadet_getrds();
+			        break;
+			        case 1:
+			        strcpy(v->name,"AM");
+			        v->rangelow=8320;      /* 520 kHz */
+			        v->rangehigh=26400;    /* 1650 kHz */
+			        v->flags=0;
+			        v->flags|=VIDEO_TUNER_LOW;
+			        v->mode=0;
+			        v->mode|=VIDEO_MODE_AUTO;
+			        v->signal=sigstrength;
+			        break;
+			}
+			return 0;
+		}
+		case VIDIOCSTUNER:
+		{
+			struct video_tuner *v = arg;
+			if((v->tuner<0)||(v->tuner>1)) {
+				return -EINVAL;
+			}
+			curtuner=v->tuner;	
+			return 0;
+		}
+		case VIDIOCGFREQ:
+		{
+		        unsigned long *freq = arg;
+			*freq = cadet_getfreq();
+			return 0;
+		}
+		case VIDIOCSFREQ:
+		{
+		        unsigned long *freq = arg;
+			if((curtuner==0)&&((*freq<1400)||(*freq>1728))) {
+			        return -EINVAL;
+			}
+			if((curtuner==1)&&((*freq<8320)||(*freq>26400))) {
+			        return -EINVAL;
+			}
+			cadet_setfreq(*freq);
+			return 0;
+		}
+		case VIDIOCGAUDIO:
+		{	
+			struct video_audio *v = arg;
+			memset(v,0, sizeof(*v));
+			v->flags=VIDEO_AUDIO_MUTABLE|VIDEO_AUDIO_VOLUME;
+			if(cadet_getstereo()==0) {
+			        v->mode=VIDEO_SOUND_MONO;
+			} else {
+				v->mode=VIDEO_SOUND_STEREO;
+			}
+			v->volume=cadet_getvol();
+			v->step=0xffff;
+			strcpy(v->name, "Radio");
+			return 0;			
+		}
+		case VIDIOCSAUDIO:
+		{
+			struct video_audio *v = arg;
+			if(v->audio) 
+				return -EINVAL;
+			cadet_setvol(v->volume);
+			if(v->flags&VIDEO_AUDIO_MUTE) 
+				cadet_setvol(0);
+			else
+				cadet_setvol(0xffff);
+			return 0;
+		}
+		default:
+			return -ENOIOCTLCMD;
+	}
+}
+
+static int cadet_ioctl(struct inode *inode, struct file *file,
+		       unsigned int cmd, unsigned long arg)
+{
+	return video_usercopy(inode, file, cmd, arg, cadet_do_ioctl);
+}
+
+static int cadet_open(struct inode *inode, struct file *file)
+{
+	if(users)
+		return -EBUSY;
+	users++;
+	init_waitqueue_head(&read_queue);
+	return 0;
+}
+
+static int cadet_release(struct inode *inode, struct file *file)
+{
+	del_timer_sync(&readtimer);
+	rdsstat=0;
+	users--;
+	return 0;
+}
+
+
+static struct file_operations cadet_fops = {
+	.owner		= THIS_MODULE,
+	.open		= cadet_open,
+	.release       	= cadet_release,
+	.read		= cadet_read,
+	.ioctl		= cadet_ioctl,
+	.llseek         = no_llseek,
+};
+
+static struct video_device cadet_radio=
+{
+	.owner		= THIS_MODULE,
+	.name		= "Cadet radio",
+	.type		= VID_TYPE_TUNER,
+	.hardware	= VID_HARDWARE_CADET,
+	.fops           = &cadet_fops,
+};
+
+static struct pnp_device_id cadet_pnp_devices[] = {
+	/* ADS Cadet AM/FM Radio Card */
+	{.id = "MSM0c24", .driver_data = 0},
+	{.id = ""}
+};
+
+MODULE_DEVICE_TABLE(pnp, cadet_pnp_devices);
+
+static int cadet_pnp_probe(struct pnp_dev * dev, const struct pnp_device_id *dev_id)
+{
+	if (!dev)
+		return -ENODEV;
+	/* only support one device */
+	if (io > 0)
+		return -EBUSY;
+
+	if (!pnp_port_valid(dev, 0)) {
+		return -ENODEV;
+	}
+
+	io = pnp_port_start(dev, 0);
+
+	printk ("radio-cadet: PnP reports device at %#x\n", io);
+
+	return io;
+}
+
+static struct pnp_driver cadet_pnp_driver = {
+	.name		= "radio-cadet",
+	.id_table	= cadet_pnp_devices,
+	.probe		= cadet_pnp_probe,
+	.remove		= NULL,
+};
+
+static int cadet_probe(void)
+{
+        static int iovals[8]={0x330,0x332,0x334,0x336,0x338,0x33a,0x33c,0x33e};
+	int i;
+
+	for(i=0;i<8;i++) {
+	        io=iovals[i];
+	        if(request_region(io,2, "cadet-probe")>=0) {
+		        cadet_setfreq(1410);
+			if(cadet_getfreq()==1410) {
+				release_region(io, 2);
+			        return io;
+			}
+			release_region(io, 2);
+		}
+	}
+	return -1;
+}
+
+/* 
+ * io should only be set if the user has used something like
+ * isapnp (the userspace program) to initialize this card for us
+ */
+
+static int __init cadet_init(void)
+{
+	spin_lock_init(&cadet_io_lock);
+	
+	/*
+	 *	If a probe was requested then probe ISAPnP first (safest)
+	 */
+	if (io < 0)
+		pnp_register_driver(&cadet_pnp_driver);
+	/*
+	 *	If that fails then probe unsafely if probe is requested
+	 */
+	if(io < 0)
+		io = cadet_probe ();
+
+	/*
+	 *	Else we bail out
+	 */
+	 
+        if(io < 0) {
+#ifdef MODULE        
+		printk(KERN_ERR "You must set an I/O address with io=0x???\n");
+#endif
+	        goto fail;
+	}
+	if (!request_region(io,2,"cadet"))
+		goto fail;
+	if(video_register_device(&cadet_radio,VFL_TYPE_RADIO,radio_nr)==-1) {
+		release_region(io,2);
+		goto fail;
+	}
+	printk(KERN_INFO "ADS Cadet Radio Card at 0x%x\n",io);
+	return 0;
+fail:
+	pnp_unregister_driver(&cadet_pnp_driver);
+	return -1;
+}
+
+
+
+MODULE_AUTHOR("Fred Gleason, Russell Kroll, Quay Lu, Donald Song, Jason Lewis, Scott McGrath, William McGrath");
+MODULE_DESCRIPTION("A driver for the ADS Cadet AM/FM/RDS radio card.");
+MODULE_LICENSE("GPL");
+
+module_param(io, int, 0);
+MODULE_PARM_DESC(io, "I/O address of Cadet card (0x330,0x332,0x334,0x336,0x338,0x33a,0x33c,0x33e)");
+module_param(radio_nr, int, 0);
+
+static void __exit cadet_cleanup_module(void)
+{
+	video_unregister_device(&cadet_radio);
+	release_region(io,2);
+	pnp_unregister_driver(&cadet_pnp_driver);
+}
+
+module_init(cadet_init);
+module_exit(cadet_cleanup_module);
+
