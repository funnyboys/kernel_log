commit 09c434b8a0047c69e48499de0107de312901e798
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 13:08:20 2019 +0100

    treewide: Add SPDX license identifier for more missed files
    
    Add SPDX license identifiers to all files which:
    
     - Have no license information of any form
    
     - Have MODULE_LICENCE("GPL*") inside which was used in the initial
       scan/conversion to ignore the file
    
    These files fall under the project license, GPL v2 only. The resulting SPDX
    license identifier is:
    
      GPL-2.0-only
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/media/radio/radio-maxiradio.c b/drivers/media/radio/radio-maxiradio.c
index 1b97ad2ce7d0..ad488ecbd16c 100644
--- a/drivers/media/radio/radio-maxiradio.c
+++ b/drivers/media/radio/radio-maxiradio.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Guillemot Maxi Radio FM 2000 PCI radio card driver for Linux
  * (C) 2001 Dimitromanolakis Apostolos <apdim@grecian.net>

commit c0decac19da3906d9b66291e57b7759489e1170f
Author: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
Date:   Mon Sep 10 08:19:14 2018 -0400

    media: use strscpy() instead of strlcpy()
    
    The implementation of strscpy() is more robust and safer.
    
    That's now the recommended way to copy NUL terminated strings.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Acked-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/radio/radio-maxiradio.c b/drivers/media/radio/radio-maxiradio.c
index e4e758739246..1b97ad2ce7d0 100644
--- a/drivers/media/radio/radio-maxiradio.c
+++ b/drivers/media/radio/radio-maxiradio.c
@@ -142,7 +142,7 @@ static int maxiradio_probe(struct pci_dev *pdev,
 	dev->tea.cannot_read_data = true;
 	dev->tea.v4l2_dev = v4l2_dev;
 	dev->tea.radio_nr = radio_nr;
-	strlcpy(dev->tea.card, "Maxi Radio FM2000", sizeof(dev->tea.card));
+	strscpy(dev->tea.card, "Maxi Radio FM2000", sizeof(dev->tea.card));
 	snprintf(dev->tea.bus_info, sizeof(dev->tea.bus_info),
 			"PCI:%s", pci_name(pdev));
 

commit 3259081991a9398434f6f49468b960f136ac0158
Author: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
Date:   Wed Apr 25 05:34:48 2018 -0400

    MAINTAINERS & files: Canonize the e-mails I use at files
    
    From now on, I'll start using my @kernel.org as my development e-mail.
    
    As such, let's remove the entries that point to the old
    mchehab@s-opensource.com at MAINTAINERS file.
    
    For the files written with a copyright with mchehab@s-opensource,
    let's keep Samsung on their names, using mchehab+samsung@kernel.org,
    in order to keep pointing to my employer, with sponsors the work.
    
    For the files written before I join Samsung (on July, 4 2013),
    let's just use mchehab@kernel.org.
    
    For bug reports, we can simply point to just kernel.org, as
    this will reach my mchehab+samsung inbox anyway.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>
    Signed-off-by: Brian Warner <brian.warner@samsung.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/radio/radio-maxiradio.c b/drivers/media/radio/radio-maxiradio.c
index 95f06f3b35dc..e4e758739246 100644
--- a/drivers/media/radio/radio-maxiradio.c
+++ b/drivers/media/radio/radio-maxiradio.c
@@ -27,7 +27,7 @@
  * BUGS:
  *   - card unmutes if you change frequency
  *
- * (c) 2006, 2007 by Mauro Carvalho Chehab <mchehab@infradead.org>:
+ * (c) 2006, 2007 by Mauro Carvalho Chehab <mchehab@kernel.org>:
  *	- Conversion to V4L2 API
  *      - Uses video_ioctl2 for parsing and to add debug support
  */

commit 4a3fad709bbc74c85fffff8903d17b5e35723365
Author: Mauro Carvalho Chehab <mchehab@s-opensource.com>
Date:   Thu Jan 4 06:47:28 2018 -0500

    media: fix usage of whitespaces and on indentation
    
    On several places, whitespaces are being used for indentation,
    or even at the end of the line.
    
    Fix them.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/radio/radio-maxiradio.c b/drivers/media/radio/radio-maxiradio.c
index 3aa5ad391581..95f06f3b35dc 100644
--- a/drivers/media/radio/radio-maxiradio.c
+++ b/drivers/media/radio/radio-maxiradio.c
@@ -13,7 +13,7 @@
  * anybody does please mail me.
  *
  * For the pdf file see:
- * http://www.nxp.com/acrobat_download2/expired_datasheets/TEA5757_5759_3.pdf 
+ * http://www.nxp.com/acrobat_download2/expired_datasheets/TEA5757_5759_3.pdf
  *
  *
  * CHANGES:

commit c181efd25ca4aa5af64081f4824d5fd3f6ecf03d
Author: Arvind Yadav <arvind.yadav.cs@gmail.com>
Date:   Tue Aug 1 13:56:34 2017 -0400

    media: radio: constify pci_device_id
    
    pci_device_id are not supposed to change at runtime. All functions
    working with pci_device_id provided by <linux/pci.h> work with
    const pci_device_id. So mark the non-const structs as const.
    
    Signed-off-by: Arvind Yadav <arvind.yadav.cs@gmail.com>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/radio/radio-maxiradio.c b/drivers/media/radio/radio-maxiradio.c
index 8253f79d5d75..3aa5ad391581 100644
--- a/drivers/media/radio/radio-maxiradio.c
+++ b/drivers/media/radio/radio-maxiradio.c
@@ -186,7 +186,7 @@ static void maxiradio_remove(struct pci_dev *pdev)
 	kfree(dev);
 }
 
-static struct pci_device_id maxiradio_pci_tbl[] = {
+static const struct pci_device_id maxiradio_pci_tbl[] = {
 	{ PCI_VENDOR_ID_GUILLEMOT, PCI_DEVICE_ID_GUILLEMOT_MAXIRADIO,
 		PCI_ANY_ID, PCI_ANY_ID, },
 	{ 0 }

commit 04bc936591469433b6ad3b16b04e07cb1b86690a
Author: Alexey Khoroshilov <khoroshilov@ispras.ru>
Date:   Fri Jun 3 19:33:06 2016 -0300

    [media] radio-maxiradio: fix memory leak when device is removed
    
    Memory allocated for maxiradio device is not deallocated when
    the device is removed.
    
    Found by Linux Driver Verification project (linuxtesting.org).
    
    Signed-off-by: Alexey Khoroshilov <khoroshilov@ispras.ru>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/radio/radio-maxiradio.c b/drivers/media/radio/radio-maxiradio.c
index 70fd8e80198a..8253f79d5d75 100644
--- a/drivers/media/radio/radio-maxiradio.c
+++ b/drivers/media/radio/radio-maxiradio.c
@@ -183,6 +183,7 @@ static void maxiradio_remove(struct pci_dev *pdev)
 	outb(0, dev->io);
 	v4l2_device_unregister(v4l2_dev);
 	release_region(pci_resource_start(pdev, 0), pci_resource_len(pdev, 0));
+	kfree(dev);
 }
 
 static struct pci_device_id maxiradio_pci_tbl[] = {

commit 22dbec265c4fbea4cecc37bcbdbb730c0bc639ff
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Sun Nov 22 08:32:53 2015 -0200

    [media] media, sound: tea575x: constify snd_tea575x_ops structures
    
    The snd_tea575x_ops structures are never modified, so declare them as
    const.
    
    Done with the help of Coccinelle.
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Reviewed-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/radio/radio-maxiradio.c b/drivers/media/radio/radio-maxiradio.c
index 41c16520a367..70fd8e80198a 100644
--- a/drivers/media/radio/radio-maxiradio.c
+++ b/drivers/media/radio/radio-maxiradio.c
@@ -108,7 +108,7 @@ static void maxiradio_tea575x_set_direction(struct snd_tea575x *tea, bool output
 {
 }
 
-static struct snd_tea575x_ops maxiradio_tea_ops = {
+static const struct snd_tea575x_ops maxiradio_tea_ops = {
 	.set_pins = maxiradio_tea575x_set_pins,
 	.get_pins = maxiradio_tea575x_get_pins,
 	.set_direction = maxiradio_tea575x_set_direction,

commit d647f0b70ce2b4aeb443639dc92b2d859da697a7
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Fri Nov 13 19:40:07 2015 -0200

    [media] include/media: move driver interface headers to a separate dir
    
    Let's not mix headers used by the core with those headers that
    are needed by some driver-specific interface header.
    
    The headers used on drivers were manually moved using:
        mkdir include/media/drv-intf/
        git mv include/media/cx2341x.h include/media/cx25840.h \
            include/media/exynos-fimc.h include/media/msp3400.h \
            include/media/s3c_camif.h include/media/saa7146.h \
            include/media/saa7146_vv.h  include/media/sh_mobile_ceu.h \
            include/media/sh_mobile_csi2.h include/media/sh_vou.h \
            include/media/si476x.h include/media/soc_mediabus.h \
            include/media/tea575x.h include/media/drv-intf/
    
    And the references for those headers were corrected using:
    
        MAIN_DIR="media/"
        PREV_DIR="media/"
        DIRS="drv-intf/"
    
        echo "Checking affected files" >&2
        for i in $DIRS; do
            for j in $(find include/$MAIN_DIR/$i -type f -name '*.h'); do
                     n=`basename $j`
                    git grep -l $n
            done
        done|sort|uniq >files && (
            echo "Handling files..." >&2;
            echo "for i in \$(cat files|grep -v Documentation); do cat \$i | \\";
            (
                    cd include/$MAIN_DIR;
                    for j in $DIRS; do
                            for i in $(ls $j); do
                                    echo "perl -ne 's,(include [\\\"\\<])$PREV_DIR($i)([\\\"\\>]),\1$MAIN_DIR$j\2\3,; print \$_' |\\";
                            done;
                    done;
                    echo "cat > a && mv a \$i; done";
            );
            echo "Handling documentation..." >&2;
            echo "for i in MAINTAINERS \$(cat files); do cat \$i | \\";
            (
                    cd include/$MAIN_DIR;
                    for j in $DIRS; do
                            for i in $(ls $j); do
                                    echo "  perl -ne 's,include/$PREV_DIR($i)\b,include/$MAIN_DIR$j\1,; print \$_' |\\";
                            done;
                    done;
                    echo "cat > a && mv a \$i; done"
            );
        ) >script && . ./script
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/drivers/media/radio/radio-maxiradio.c b/drivers/media/radio/radio-maxiradio.c
index 5236035f0f2a..41c16520a367 100644
--- a/drivers/media/radio/radio-maxiradio.c
+++ b/drivers/media/radio/radio-maxiradio.c
@@ -42,7 +42,7 @@
 #include <linux/videodev2.h>
 #include <linux/io.h>
 #include <linux/slab.h>
-#include <media/tea575x.h>
+#include <media/drv-intf/tea575x.h>
 #include <media/v4l2-device.h>
 #include <media/v4l2-ioctl.h>
 #include <media/v4l2-fh.h>

commit 59b564599bc66f086856b09e480f89555d47b35c
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Sun Jul 28 16:01:43 2013 -0300

    [media] tea575x: Move header from sound to media
    
    Move include/sound/tea575x-tuner.h to include/media/tea575x.h and update files that include it.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Acked-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/drivers/media/radio/radio-maxiradio.c b/drivers/media/radio/radio-maxiradio.c
index 1d1c9e1d386e..5236035f0f2a 100644
--- a/drivers/media/radio/radio-maxiradio.c
+++ b/drivers/media/radio/radio-maxiradio.c
@@ -42,7 +42,7 @@
 #include <linux/videodev2.h>
 #include <linux/io.h>
 #include <linux/slab.h>
-#include <sound/tea575x-tuner.h>
+#include <media/tea575x.h>
 #include <media/v4l2-device.h>
 #include <media/v4l2-ioctl.h>
 #include <media/v4l2-fh.h>

commit 725d7b7139e990c802874a0c440f9914b41c11e6
Author: Libo Chen <libo.chen@huawei.com>
Date:   Sun May 26 22:31:59 2013 -0300

    [media] drivers/media/radio/radio-maxiradio: Convert to module_pci_driver
    
    use module_pci_driver instead of init/exit, make code clean
    
    Signed-off-by: Libo Chen <libo.chen@huawei.com>
    Acked-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/drivers/media/radio/radio-maxiradio.c b/drivers/media/radio/radio-maxiradio.c
index bd4d3a7cdadd..1d1c9e1d386e 100644
--- a/drivers/media/radio/radio-maxiradio.c
+++ b/drivers/media/radio/radio-maxiradio.c
@@ -200,15 +200,4 @@ static struct pci_driver maxiradio_driver = {
 	.remove		= maxiradio_remove,
 };
 
-static int __init maxiradio_init(void)
-{
-	return pci_register_driver(&maxiradio_driver);
-}
-
-static void __exit maxiradio_exit(void)
-{
-	pci_unregister_driver(&maxiradio_driver);
-}
-
-module_init(maxiradio_init);
-module_exit(maxiradio_exit);
+module_pci_driver(maxiradio_driver);

commit 4c62e9764ab403d42f9b8871b1241fe7812f19d4
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Dec 21 13:17:53 2012 -0800

    Drivers: media: remove __dev* attributes.
    
    CONFIG_HOTPLUG is going away as an option.  As a result, the __dev*
    markings need to be removed.
    
    This change removes the use of __devinit, __devexit_p, __devinitdata,
    __devinitconst, and __devexit from these drivers.
    
    Based on patches originally written by Bill Pemberton, but redone by me
    in order to handle some of the coding style issues better, by hand.
    
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Mauro Carvalho Chehab <mchehab@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/media/radio/radio-maxiradio.c b/drivers/media/radio/radio-maxiradio.c
index b415211d0c4b..bd4d3a7cdadd 100644
--- a/drivers/media/radio/radio-maxiradio.c
+++ b/drivers/media/radio/radio-maxiradio.c
@@ -114,7 +114,8 @@ static struct snd_tea575x_ops maxiradio_tea_ops = {
 	.set_direction = maxiradio_tea575x_set_direction,
 };
 
-static int __devinit maxiradio_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
+static int maxiradio_probe(struct pci_dev *pdev,
+			   const struct pci_device_id *ent)
 {
 	struct maxiradio *dev;
 	struct v4l2_device *v4l2_dev;
@@ -172,7 +173,7 @@ static int __devinit maxiradio_probe(struct pci_dev *pdev, const struct pci_devi
 	return retval;
 }
 
-static void __devexit maxiradio_remove(struct pci_dev *pdev)
+static void maxiradio_remove(struct pci_dev *pdev)
 {
 	struct v4l2_device *v4l2_dev = dev_get_drvdata(&pdev->dev);
 	struct maxiradio *dev = to_maxiradio(v4l2_dev);
@@ -196,7 +197,7 @@ static struct pci_driver maxiradio_driver = {
 	.name		= "radio-maxiradio",
 	.id_table	= maxiradio_pci_tbl,
 	.probe		= maxiradio_probe,
-	.remove		= __devexit_p(maxiradio_remove),
+	.remove		= maxiradio_remove,
 };
 
 static int __init maxiradio_init(void)

commit 5daf53a6eb5c54c618c9def388d81c2769fd11a0
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Sat May 19 07:57:03 2012 -0300

    [media] snd_tea575x: Make the module using snd_tea575x the fops owner
    
    Before this patch the owner field of the /dev/radio# device fops was set to
    the snd-tea575x-tuner module itself. Meaning that the module which was using
    it could be rmmod-ed while the device is open, and then BAD things happen.
    
    I know, as I found out the hard way :)
    
    Note that there is no need to also somehow increase the refcount of the
    snd-tea575x-tuner module itself, since any drivers using it will have
    symbolic references to it.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    CC: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-maxiradio.c b/drivers/media/radio/radio-maxiradio.c
index 740a3d5520c7..b415211d0c4b 100644
--- a/drivers/media/radio/radio-maxiradio.c
+++ b/drivers/media/radio/radio-maxiradio.c
@@ -157,7 +157,7 @@ static int __devinit maxiradio_probe(struct pci_dev *pdev, const struct pci_devi
 		goto err_out_free_region;
 
 	dev->io = pci_resource_start(pdev, 0);
-	if (snd_tea575x_init(&dev->tea)) {
+	if (snd_tea575x_init(&dev->tea, THIS_MODULE)) {
 		printk(KERN_ERR "radio-maxiradio: Unable to detect TEA575x tuner\n");
 		goto err_out_free_region;
 	}

commit cfb19b0ab13847a0e0e49521eb94113b0b315e3b
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Sun Feb 5 09:53:17 2012 -0300

    [media] radio-maxiradio: use the tea575x framework
    
    This card is based on the tea575x receiver. Use the tea575x-tuner framework
    instead of reinventing the wheel.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-maxiradio.c b/drivers/media/radio/radio-maxiradio.c
index f872a54cf3d9..740a3d5520c7 100644
--- a/drivers/media/radio/radio-maxiradio.c
+++ b/drivers/media/radio/radio-maxiradio.c
@@ -42,67 +42,37 @@
 #include <linux/videodev2.h>
 #include <linux/io.h>
 #include <linux/slab.h>
+#include <sound/tea575x-tuner.h>
 #include <media/v4l2-device.h>
 #include <media/v4l2-ioctl.h>
-
-#define DRIVER_VERSION	"0.7.8"
-
+#include <media/v4l2-fh.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-event.h>
 
 MODULE_AUTHOR("Dimitromanolakis Apostolos, apdim@grecian.net");
-MODULE_DESCRIPTION("Radio driver for the Guillemot Maxi Radio FM2000 radio.");
+MODULE_DESCRIPTION("Radio driver for the Guillemot Maxi Radio FM2000.");
 MODULE_LICENSE("GPL");
-MODULE_VERSION(DRIVER_VERSION);
+MODULE_VERSION("1.0.0");
 
 static int radio_nr = -1;
-module_param(radio_nr, int, 0);
-
-static int debug;
-
-module_param(debug, int, 0644);
-MODULE_PARM_DESC(debug, "activates debug info");
-
-#define dprintk(dev, num, fmt, arg...) \
-	v4l2_dbg(num, debug, &dev->v4l2_dev, fmt, ## arg)
-
-#ifndef PCI_VENDOR_ID_GUILLEMOT
-#define PCI_VENDOR_ID_GUILLEMOT 0x5046
-#endif
-
-#ifndef PCI_DEVICE_ID_GUILLEMOT
-#define PCI_DEVICE_ID_GUILLEMOT_MAXIRADIO 0x1001
-#endif
-
+module_param(radio_nr, int, 0644);
+MODULE_PARM_DESC(radio_nr, "Radio device number");
 
 /* TEA5757 pin mappings */
 static const int clk = 1, data = 2, wren = 4, mo_st = 8, power = 16;
 
-#define FREQ_LO		(87 * 16000)
-#define FREQ_HI		(108 * 16000)
-
-#define FREQ_IF         171200 /* 10.7*16000   */
-#define FREQ_STEP       200    /* 12.5*16      */
-
-/* (x==fmhz*16*1000) -> bits */
-#define FREQ2BITS(x) \
-  ((((unsigned int)(x) + FREQ_IF + (FREQ_STEP << 1)) / (FREQ_STEP << 2)) << 2)
-
-#define BITS2FREQ(x)	((x) * FREQ_STEP - FREQ_IF)
+static atomic_t maxiradio_instance = ATOMIC_INIT(0);
 
+#define PCI_VENDOR_ID_GUILLEMOT 0x5046
+#define PCI_DEVICE_ID_GUILLEMOT_MAXIRADIO 0x1001
 
 struct maxiradio
 {
+	struct snd_tea575x tea;
 	struct v4l2_device v4l2_dev;
-	struct video_device vdev;
 	struct pci_dev *pdev;
 
 	u16	io;	/* base of radio io */
-	u16	muted;	/* VIDEO_AUDIO_MUTE */
-	u16	stereo;	/* VIDEO_TUNER_STEREO_ON */
-	u16	tuned;	/* signal strength (0 or 0xffff) */
-
-	unsigned long freq;
-
-	struct mutex lock;
 };
 
 static inline struct maxiradio *to_maxiradio(struct v4l2_device *v4l2_dev)
@@ -110,259 +80,41 @@ static inline struct maxiradio *to_maxiradio(struct v4l2_device *v4l2_dev)
 	return container_of(v4l2_dev, struct maxiradio, v4l2_dev);
 }
 
-static void outbit(unsigned long bit, u16 io)
-{
-	int val = power | wren | (bit ? data : 0);
-
-	outb(val, io);
-	udelay(4);
-	outb(val | clk, io);
-	udelay(4);
-	outb(val, io);
-	udelay(4);
-}
-
-static void turn_power(struct maxiradio *dev, int p)
-{
-	if (p != 0) {
-		dprintk(dev, 1, "Radio powered on\n");
-		outb(power, dev->io);
-	} else {
-		dprintk(dev, 1, "Radio powered off\n");
-		outb(0, dev->io);
-	}
-}
-
-static void set_freq(struct maxiradio *dev, u32 freq)
-{
-	unsigned long int si;
-	int bl;
-	int io = dev->io;
-	int val = FREQ2BITS(freq);
-
-	/* TEA5757 shift register bits (see pdf) */
-
-	outbit(0, io); /* 24  search */
-	outbit(1, io); /* 23  search up/down */
-
-	outbit(0, io); /* 22  stereo/mono */
-
-	outbit(0, io); /* 21  band */
-	outbit(0, io); /* 20  band (only 00=FM works I think) */
-
-	outbit(0, io); /* 19  port ? */
-	outbit(0, io); /* 18  port ? */
-
-	outbit(0, io); /* 17  search level */
-	outbit(0, io); /* 16  search level */
-
-	si = 0x8000;
-	for (bl = 1; bl <= 16; bl++) {
-		outbit(val & si, io);
-		si >>= 1;
-	}
-
-	dprintk(dev, 1, "Radio freq set to %d.%02d MHz\n",
-				freq / 16000,
-				freq % 16000 * 100 / 16000);
-
-	turn_power(dev, 1);
-}
-
-static int get_stereo(u16 io)
+static void maxiradio_tea575x_set_pins(struct snd_tea575x *tea, u8 pins)
 {
-	outb(power,io);
-	udelay(4);
+	struct maxiradio *dev = tea->private_data;
+	u8 bits = 0;
 
-	return !(inb(io) & mo_st);
-}
+	bits |= (pins & TEA575X_DATA) ? data : 0;
+	bits |= (pins & TEA575X_CLK)  ? clk  : 0;
+	bits |= (pins & TEA575X_WREN) ? wren : 0;
+	bits |= power;
 
-static int get_tune(u16 io)
-{
-	outb(power+clk,io);
-	udelay(4);
-
-	return !(inb(io) & mo_st);
-}
-
-
-static int vidioc_querycap(struct file *file, void  *priv,
-			    struct v4l2_capability *v)
-{
-	struct maxiradio *dev = video_drvdata(file);
-
-	strlcpy(v->driver, "radio-maxiradio", sizeof(v->driver));
-	strlcpy(v->card, "Maxi Radio FM2000 radio", sizeof(v->card));
-	snprintf(v->bus_info, sizeof(v->bus_info), "PCI:%s", pci_name(dev->pdev));
-	v->capabilities = V4L2_CAP_TUNER | V4L2_CAP_RADIO;
-	return 0;
+	outb(bits, dev->io);
 }
 
-static int vidioc_g_tuner(struct file *file, void *priv,
-			   struct v4l2_tuner *v)
+/* Note: this card cannot read out the data of the shift registers,
+   only the mono/stereo pin works. */
+static u8 maxiradio_tea575x_get_pins(struct snd_tea575x *tea)
 {
-	struct maxiradio *dev = video_drvdata(file);
-
-	if (v->index > 0)
-		return -EINVAL;
-
-	mutex_lock(&dev->lock);
-	strlcpy(v->name, "FM", sizeof(v->name));
-	v->type = V4L2_TUNER_RADIO;
-	v->rangelow = FREQ_LO;
-	v->rangehigh = FREQ_HI;
-	v->rxsubchans = V4L2_TUNER_SUB_MONO | V4L2_TUNER_SUB_STEREO;
-	v->capability = V4L2_TUNER_CAP_LOW;
-	if (get_stereo(dev->io))
-		v->audmode = V4L2_TUNER_MODE_STEREO;
-	else
-		v->audmode = V4L2_TUNER_MODE_MONO;
-	v->signal = 0xffff * get_tune(dev->io);
-	mutex_unlock(&dev->lock);
+	struct maxiradio *dev = tea->private_data;
+	u8 bits = inb(dev->io);
 
-	return 0;
+	return  ((bits & data) ? TEA575X_DATA : 0) |
+		((bits & mo_st) ? TEA575X_MOST : 0);
 }
 
-static int vidioc_s_tuner(struct file *file, void *priv,
-			   struct v4l2_tuner *v)
+static void maxiradio_tea575x_set_direction(struct snd_tea575x *tea, bool output)
 {
-	return v->index ? -EINVAL : 0;
 }
 
-static int vidioc_g_input(struct file *filp, void *priv, unsigned int *i)
-{
-	*i = 0;
-	return 0;
-}
-
-static int vidioc_s_input(struct file *filp, void *priv, unsigned int i)
-{
-	return i ? -EINVAL : 0;
-}
-
-static int vidioc_g_audio(struct file *file, void *priv,
-			   struct v4l2_audio *a)
-{
-	a->index = 0;
-	strlcpy(a->name, "Radio", sizeof(a->name));
-	a->capability = V4L2_AUDCAP_STEREO;
-	return 0;
-}
-
-
-static int vidioc_s_audio(struct file *file, void *priv,
-			   struct v4l2_audio *a)
-{
-	return a->index ? -EINVAL : 0;
-}
-
-static int vidioc_s_frequency(struct file *file, void *priv,
-			       struct v4l2_frequency *f)
-{
-	struct maxiradio *dev = video_drvdata(file);
-
-	if (f->tuner != 0 || f->type != V4L2_TUNER_RADIO)
-		return -EINVAL;
-	if (f->frequency < FREQ_LO || f->frequency > FREQ_HI) {
-		dprintk(dev, 1, "radio freq (%d.%02d MHz) out of range (%d-%d)\n",
-					f->frequency / 16000,
-					f->frequency % 16000 * 100 / 16000,
-					FREQ_LO / 16000, FREQ_HI / 16000);
-
-		return -EINVAL;
-	}
-
-	mutex_lock(&dev->lock);
-	dev->freq = f->frequency;
-	set_freq(dev, dev->freq);
-	msleep(125);
-	mutex_unlock(&dev->lock);
-
-	return 0;
-}
-
-static int vidioc_g_frequency(struct file *file, void *priv,
-			       struct v4l2_frequency *f)
-{
-	struct maxiradio *dev = video_drvdata(file);
-
-	if (f->tuner != 0)
-		return -EINVAL;
-	f->type = V4L2_TUNER_RADIO;
-	f->frequency = dev->freq;
-
-	dprintk(dev, 4, "radio freq is %d.%02d MHz",
-				f->frequency / 16000,
-				f->frequency % 16000 * 100 / 16000);
-
-	return 0;
-}
-
-static int vidioc_queryctrl(struct file *file, void *priv,
-			     struct v4l2_queryctrl *qc)
-{
-	switch (qc->id) {
-	case V4L2_CID_AUDIO_MUTE:
-		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 1);
-	}
-	return -EINVAL;
-}
-
-static int vidioc_g_ctrl(struct file *file, void *priv,
-		struct v4l2_control *ctrl)
-{
-	struct maxiradio *dev = video_drvdata(file);
-
-	switch (ctrl->id) {
-	case V4L2_CID_AUDIO_MUTE:
-		ctrl->value = dev->muted;
-		return 0;
-	}
-
-	return -EINVAL;
-}
-
-static int vidioc_s_ctrl(struct file *file, void *priv,
-		struct v4l2_control *ctrl)
-{
-	struct maxiradio *dev = video_drvdata(file);
-
-	switch (ctrl->id) {
-	case V4L2_CID_AUDIO_MUTE:
-		mutex_lock(&dev->lock);
-		dev->muted = ctrl->value;
-		if (dev->muted)
-			turn_power(dev, 0);
-		else
-			set_freq(dev, dev->freq);
-		mutex_unlock(&dev->lock);
-		return 0;
-	}
-
-	return -EINVAL;
-}
-
-static const struct v4l2_file_operations maxiradio_fops = {
-	.owner		= THIS_MODULE,
-	.unlocked_ioctl = video_ioctl2,
+static struct snd_tea575x_ops maxiradio_tea_ops = {
+	.set_pins = maxiradio_tea575x_set_pins,
+	.get_pins = maxiradio_tea575x_get_pins,
+	.set_direction = maxiradio_tea575x_set_direction,
 };
 
-static const struct v4l2_ioctl_ops maxiradio_ioctl_ops = {
-	.vidioc_querycap    = vidioc_querycap,
-	.vidioc_g_tuner     = vidioc_g_tuner,
-	.vidioc_s_tuner     = vidioc_s_tuner,
-	.vidioc_g_audio     = vidioc_g_audio,
-	.vidioc_s_audio     = vidioc_s_audio,
-	.vidioc_g_input     = vidioc_g_input,
-	.vidioc_s_input     = vidioc_s_input,
-	.vidioc_g_frequency = vidioc_g_frequency,
-	.vidioc_s_frequency = vidioc_s_frequency,
-	.vidioc_queryctrl   = vidioc_queryctrl,
-	.vidioc_g_ctrl      = vidioc_g_ctrl,
-	.vidioc_s_ctrl      = vidioc_s_ctrl,
-};
-
-static int __devinit maxiradio_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)
+static int __devinit maxiradio_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 {
 	struct maxiradio *dev;
 	struct v4l2_device *v4l2_dev;
@@ -375,63 +127,60 @@ static int __devinit maxiradio_init_one(struct pci_dev *pdev, const struct pci_d
 	}
 
 	v4l2_dev = &dev->v4l2_dev;
-	mutex_init(&dev->lock);
-	dev->pdev = pdev;
-	dev->muted = 1;
-	dev->freq = FREQ_LO;
-
-	strlcpy(v4l2_dev->name, "maxiradio", sizeof(v4l2_dev->name));
+	v4l2_device_set_name(v4l2_dev, "maxiradio", &maxiradio_instance);
 
 	retval = v4l2_device_register(&pdev->dev, v4l2_dev);
 	if (retval < 0) {
 		v4l2_err(v4l2_dev, "Could not register v4l2_device\n");
 		goto errfr;
 	}
+	dev->tea.private_data = dev;
+	dev->tea.ops = &maxiradio_tea_ops;
+	/* The data pin cannot be read. This may be a hardware limitation, or
+	   we just don't know how to read it. */
+	dev->tea.cannot_read_data = true;
+	dev->tea.v4l2_dev = v4l2_dev;
+	dev->tea.radio_nr = radio_nr;
+	strlcpy(dev->tea.card, "Maxi Radio FM2000", sizeof(dev->tea.card));
+	snprintf(dev->tea.bus_info, sizeof(dev->tea.bus_info),
+			"PCI:%s", pci_name(pdev));
+
+	retval = -ENODEV;
 
 	if (!request_region(pci_resource_start(pdev, 0),
-			   pci_resource_len(pdev, 0), "Maxi Radio FM 2000")) {
-		v4l2_err(v4l2_dev, "can't reserve I/O ports\n");
-		goto err_out;
+			   pci_resource_len(pdev, 0), v4l2_dev->name)) {
+		dev_err(&pdev->dev, "can't reserve I/O ports\n");
+		goto err_hdl;
 	}
 
 	if (pci_enable_device(pdev))
 		goto err_out_free_region;
 
 	dev->io = pci_resource_start(pdev, 0);
-	strlcpy(dev->vdev.name, v4l2_dev->name, sizeof(dev->vdev.name));
-	dev->vdev.v4l2_dev = v4l2_dev;
-	dev->vdev.fops = &maxiradio_fops;
-	dev->vdev.ioctl_ops = &maxiradio_ioctl_ops;
-	dev->vdev.release = video_device_release_empty;
-	video_set_drvdata(&dev->vdev, dev);
-
-	if (video_register_device(&dev->vdev, VFL_TYPE_RADIO, radio_nr) < 0) {
-		v4l2_err(v4l2_dev, "can't register device!");
+	if (snd_tea575x_init(&dev->tea)) {
+		printk(KERN_ERR "radio-maxiradio: Unable to detect TEA575x tuner\n");
 		goto err_out_free_region;
 	}
-
-	v4l2_info(v4l2_dev, "version " DRIVER_VERSION "\n");
-
-	v4l2_info(v4l2_dev, "found Guillemot MAXI Radio device (io = 0x%x)\n",
-	       dev->io);
 	return 0;
 
 err_out_free_region:
 	release_region(pci_resource_start(pdev, 0), pci_resource_len(pdev, 0));
-err_out:
+err_hdl:
 	v4l2_device_unregister(v4l2_dev);
 errfr:
 	kfree(dev);
-	return -ENODEV;
+	return retval;
 }
 
-static void __devexit maxiradio_remove_one(struct pci_dev *pdev)
+static void __devexit maxiradio_remove(struct pci_dev *pdev)
 {
 	struct v4l2_device *v4l2_dev = dev_get_drvdata(&pdev->dev);
 	struct maxiradio *dev = to_maxiradio(v4l2_dev);
 
-	video_unregister_device(&dev->vdev);
-	v4l2_device_unregister(&dev->v4l2_dev);
+	snd_tea575x_exit(&dev->tea);
+	/* Turn off power */
+	outb(0, dev->io);
+	v4l2_device_unregister(v4l2_dev);
 	release_region(pci_resource_start(pdev, 0), pci_resource_len(pdev, 0));
 }
 
@@ -446,19 +195,19 @@ MODULE_DEVICE_TABLE(pci, maxiradio_pci_tbl);
 static struct pci_driver maxiradio_driver = {
 	.name		= "radio-maxiradio",
 	.id_table	= maxiradio_pci_tbl,
-	.probe		= maxiradio_init_one,
-	.remove		= __devexit_p(maxiradio_remove_one),
+	.probe		= maxiradio_probe,
+	.remove		= __devexit_p(maxiradio_remove),
 };
 
-static int __init maxiradio_radio_init(void)
+static int __init maxiradio_init(void)
 {
 	return pci_register_driver(&maxiradio_driver);
 }
 
-static void __exit maxiradio_radio_exit(void)
+static void __exit maxiradio_exit(void)
 {
 	pci_unregister_driver(&maxiradio_driver);
 }
 
-module_init(maxiradio_radio_init);
-module_exit(maxiradio_radio_exit);
+module_init(maxiradio_init);
+module_exit(maxiradio_exit);

commit 29834c1ac7589c72996c5d02349d63fd397ef131
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Sat Jun 25 10:15:42 2011 -0300

    [media] radio: Use the subsystem version control for VIDIOC_QUERYCAP
    
    Just like the video drivers, the right thing to do is to use
    the per-subsystem version control.
    
    Acked-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-maxiradio.c b/drivers/media/radio/radio-maxiradio.c
index e83e84003025..f872a54cf3d9 100644
--- a/drivers/media/radio/radio-maxiradio.c
+++ b/drivers/media/radio/radio-maxiradio.c
@@ -40,15 +40,18 @@
 #include <linux/mutex.h>
 #include <linux/pci.h>
 #include <linux/videodev2.h>
-#include <linux/version.h>      /* for KERNEL_VERSION MACRO     */
 #include <linux/io.h>
 #include <linux/slab.h>
 #include <media/v4l2-device.h>
 #include <media/v4l2-ioctl.h>
 
+#define DRIVER_VERSION	"0.7.8"
+
+
 MODULE_AUTHOR("Dimitromanolakis Apostolos, apdim@grecian.net");
 MODULE_DESCRIPTION("Radio driver for the Guillemot Maxi Radio FM2000 radio.");
 MODULE_LICENSE("GPL");
+MODULE_VERSION(DRIVER_VERSION);
 
 static int radio_nr = -1;
 module_param(radio_nr, int, 0);
@@ -58,10 +61,6 @@ static int debug;
 module_param(debug, int, 0644);
 MODULE_PARM_DESC(debug, "activates debug info");
 
-#define DRIVER_VERSION	"0.77"
-
-#define RADIO_VERSION KERNEL_VERSION(0, 7, 7)
-
 #define dprintk(dev, num, fmt, arg...) \
 	v4l2_dbg(num, debug, &dev->v4l2_dev, fmt, ## arg)
 
@@ -195,7 +194,6 @@ static int vidioc_querycap(struct file *file, void  *priv,
 	strlcpy(v->driver, "radio-maxiradio", sizeof(v->driver));
 	strlcpy(v->card, "Maxi Radio FM2000 radio", sizeof(v->card));
 	snprintf(v->bus_info, sizeof(v->bus_info), "PCI:%s", pci_name(dev->pdev));
-	v->version = RADIO_VERSION;
 	v->capabilities = V4L2_CAP_TUNER | V4L2_CAP_RADIO;
 	return 0;
 }

commit 372c05c4959aaccdd671f75e0fd332629cf15964
Author: Michal Marek <mmarek@suse.cz>
Date:   Fri Apr 1 12:41:20 2011 +0200

    media/radio-maxiradio: Drop __TIME__ usage
    
    The kernel already prints its build timestamp during boot, no need to
    repeat it in random drivers and produce different object files each
    time.
    
    Acked-by: Mauro Carvalho Chehab <mchehab@redhat.com>
    Cc: linux-media@vger.kernel.org
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/drivers/media/radio/radio-maxiradio.c b/drivers/media/radio/radio-maxiradio.c
index 5c2a9058c09f..e83e84003025 100644
--- a/drivers/media/radio/radio-maxiradio.c
+++ b/drivers/media/radio/radio-maxiradio.c
@@ -412,8 +412,7 @@ static int __devinit maxiradio_init_one(struct pci_dev *pdev, const struct pci_d
 		goto err_out_free_region;
 	}
 
-	v4l2_info(v4l2_dev, "version " DRIVER_VERSION
-			" time " __TIME__ "  " __DATE__ "\n");
+	v4l2_info(v4l2_dev, "version " DRIVER_VERSION "\n");
 
 	v4l2_info(v4l2_dev, "found Guillemot MAXI Radio device (io = 0x%x)\n",
 	       dev->io);

commit 90d873a7f9389478e68494c530afab8b19c04f29
Author: Hans Verkuil <hverkuil@xs4all.nl>
Date:   Wed Jan 5 14:40:07 2011 -0300

    [media] radio-maxiradio.c: use sensible frequency range
    
    Use the standard USA/Europe frequency range of 87-108 MHz instead of the
    arbitrary 50-150 MHz.
    
    Copied from the radio-gemtek-pci driver which supports the same hardware.
    
    Signed-off-by: Hans Verkuil <hverkuil@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-maxiradio.c b/drivers/media/radio/radio-maxiradio.c
index 6459a220b0dd..5c2a9058c09f 100644
--- a/drivers/media/radio/radio-maxiradio.c
+++ b/drivers/media/radio/radio-maxiradio.c
@@ -77,8 +77,8 @@ MODULE_PARM_DESC(debug, "activates debug info");
 /* TEA5757 pin mappings */
 static const int clk = 1, data = 2, wren = 4, mo_st = 8, power = 16;
 
-#define FREQ_LO		(50 * 16000)
-#define FREQ_HI		(150 * 16000)
+#define FREQ_LO		(87 * 16000)
+#define FREQ_HI		(108 * 16000)
 
 #define FREQ_IF         171200 /* 10.7*16000   */
 #define FREQ_STEP       200    /* 12.5*16      */

commit 32958fdd1663aeaa23b5edbfbb0db684ffd4e20e
Author: Hans Verkuil <hverkuil@xs4all.nl>
Date:   Sun Nov 14 09:36:23 2010 -0300

    [media] BKL: trivial BKL removal from V4L2 radio drivers
    
    The patch converts a bunch of V4L2 radio drivers to unlocked_ioctl.
    
    These are all simple conversions: most already had a lock and so the ioctl
    fop could simply be replaced by unlocked_ioctl.
    
    radio-miropcm20.c was converted to use the new V4L2 core lock.
    
    While doing this work I noticed that many of these drivers initialized
    some more fields or muted audio or something like that *after* creating
    the device node. This should be done before the device node is created
    to prevent problems. Especially hal tends to grab a device node as soon
    as it is created.
    
    In one or two cases the mutex_init was even done after the device creation!
    
    Signed-off-by: Hans Verkuil <hverkuil@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-maxiradio.c b/drivers/media/radio/radio-maxiradio.c
index 255d40df4b46..6459a220b0dd 100644
--- a/drivers/media/radio/radio-maxiradio.c
+++ b/drivers/media/radio/radio-maxiradio.c
@@ -346,7 +346,7 @@ static int vidioc_s_ctrl(struct file *file, void *priv,
 
 static const struct v4l2_file_operations maxiradio_fops = {
 	.owner		= THIS_MODULE,
-	.ioctl          = video_ioctl2,
+	.unlocked_ioctl = video_ioctl2,
 };
 
 static const struct v4l2_ioctl_ops maxiradio_ioctl_ops = {

commit 631dd1a885b6d7e9f6f51b4e5b311c2bb04c323c
Author: Justin P. Mattock <justinmattock@gmail.com>
Date:   Mon Oct 18 11:03:14 2010 +0200

    Update broken web addresses in the kernel.
    
    The patch below updates broken web addresses in the kernel
    
    Signed-off-by: Justin P. Mattock <justinmattock@gmail.com>
    Cc: Maciej W. Rozycki <macro@linux-mips.org>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Finn Thain <fthain@telegraphics.com.au>
    Cc: Randy Dunlap <rdunlap@xenotime.net>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Dimitry Torokhov <dmitry.torokhov@gmail.com>
    Cc: Mike Frysinger <vapier.adi@gmail.com>
    Acked-by: Ben Pfaff <blp@cs.stanford.edu>
    Acked-by: Hans J. Koch <hjk@linutronix.de>
    Reviewed-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/media/radio/radio-maxiradio.c b/drivers/media/radio/radio-maxiradio.c
index 4349213b403b..255d40df4b46 100644
--- a/drivers/media/radio/radio-maxiradio.c
+++ b/drivers/media/radio/radio-maxiradio.c
@@ -13,7 +13,7 @@
  * anybody does please mail me.
  *
  * For the pdf file see:
- * http://www.semiconductors.philips.com/pip/TEA5757H/V1
+ * http://www.nxp.com/acrobat_download2/expired_datasheets/TEA5757_5759_3.pdf 
  *
  *
  * CHANGES:

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/media/radio/radio-maxiradio.c b/drivers/media/radio/radio-maxiradio.c
index 44b4dbedb322..4349213b403b 100644
--- a/drivers/media/radio/radio-maxiradio.c
+++ b/drivers/media/radio/radio-maxiradio.c
@@ -42,6 +42,7 @@
 #include <linux/videodev2.h>
 #include <linux/version.h>      /* for KERNEL_VERSION MACRO     */
 #include <linux/io.h>
+#include <linux/slab.h>
 #include <media/v4l2-device.h>
 #include <media/v4l2-ioctl.h>
 

commit a3a9e287daa1f299e318161b790b1c5902b1d869
Author: Hans Verkuil <hverkuil@xs4all.nl>
Date:   Fri Nov 27 04:33:25 2009 -0300

    V4L/DVB (13547): radio: add trivial checks on the tuner and type args.
    
    Many radio drivers did not check the tuner and type field correctly
    for g/s_frequency. These checks have now been added.
    
    Signed-off-by: Hans Verkuil <hverkuil@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-maxiradio.c b/drivers/media/radio/radio-maxiradio.c
index 3da51fe8fb93..44b4dbedb322 100644
--- a/drivers/media/radio/radio-maxiradio.c
+++ b/drivers/media/radio/radio-maxiradio.c
@@ -262,6 +262,8 @@ static int vidioc_s_frequency(struct file *file, void *priv,
 {
 	struct maxiradio *dev = video_drvdata(file);
 
+	if (f->tuner != 0 || f->type != V4L2_TUNER_RADIO)
+		return -EINVAL;
 	if (f->frequency < FREQ_LO || f->frequency > FREQ_HI) {
 		dprintk(dev, 1, "radio freq (%d.%02d MHz) out of range (%d-%d)\n",
 					f->frequency / 16000,
@@ -285,6 +287,8 @@ static int vidioc_g_frequency(struct file *file, void *priv,
 {
 	struct maxiradio *dev = video_drvdata(file);
 
+	if (f->tuner != 0)
+		return -EINVAL;
 	f->type = V4L2_TUNER_RADIO;
 	f->frequency = dev->freq;
 

commit ff1a3ebb9cd9baecd167500c660bd76129b67b1c
Author: Alexey Klimov <klimov.linux@gmail.com>
Date:   Sun Mar 29 20:19:54 2009 -0300

    V4L/DVB (11391): pci-isa radios: remove open and release functions
    
    Patch removes empty open and release functions in pci and isa radio
    drivers, setting them to NULL. V4L module doesn't call for them due to
    previous patch.
    
    Signed-off-by: Alexey Klimov <klimov.linux@gmail.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-maxiradio.c b/drivers/media/radio/radio-maxiradio.c
index 2606f0b30355..3da51fe8fb93 100644
--- a/drivers/media/radio/radio-maxiradio.c
+++ b/drivers/media/radio/radio-maxiradio.c
@@ -339,20 +339,8 @@ static int vidioc_s_ctrl(struct file *file, void *priv,
 	return -EINVAL;
 }
 
-static int maxiradio_open(struct file *file)
-{
-	return 0;
-}
-
-static int maxiradio_release(struct file *file)
-{
-	return 0;
-}
-
 static const struct v4l2_file_operations maxiradio_fops = {
 	.owner		= THIS_MODULE,
-	.open           = maxiradio_open,
-	.release        = maxiradio_release,
 	.ioctl          = video_ioctl2,
 };
 

commit ab84f5736086b84d99015cd82515a31b95e03f48
Author: Hans Verkuil <hverkuil@xs4all.nl>
Date:   Wed Mar 11 04:25:47 2009 -0300

    V4L/DVB (10959): radio: remove uaccess include
    
    This include isn't needed and so can be removed.
    
    Signed-off-by: Hans Verkuil <hverkuil@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-maxiradio.c b/drivers/media/radio/radio-maxiradio.c
index f43e4a6811a3..2606f0b30355 100644
--- a/drivers/media/radio/radio-maxiradio.c
+++ b/drivers/media/radio/radio-maxiradio.c
@@ -42,7 +42,6 @@
 #include <linux/videodev2.h>
 #include <linux/version.h>      /* for KERNEL_VERSION MACRO     */
 #include <linux/io.h>
-#include <linux/uaccess.h>
 #include <media/v4l2-device.h>
 #include <media/v4l2-ioctl.h>
 

commit 2710e6aa3f15cb008577ce31fc469e8af7466075
Author: Hans Verkuil <hverkuil@xs4all.nl>
Date:   Fri Mar 6 13:51:33 2009 -0300

    V4L/DVB (10886): radio-maxiradio: convert to v4l2_device.
    
    Signed-off-by: Hans Verkuil <hverkuil@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-maxiradio.c b/drivers/media/radio/radio-maxiradio.c
index c5dc00aa9c9f..f43e4a6811a3 100644
--- a/drivers/media/radio/radio-maxiradio.c
+++ b/drivers/media/radio/radio-maxiradio.c
@@ -37,38 +37,33 @@
 #include <linux/init.h>
 #include <linux/ioport.h>
 #include <linux/delay.h>
-#include <asm/io.h>
-#include <asm/uaccess.h>
 #include <linux/mutex.h>
-
 #include <linux/pci.h>
 #include <linux/videodev2.h>
-#include <media/v4l2-common.h>
+#include <linux/version.h>      /* for KERNEL_VERSION MACRO     */
+#include <linux/io.h>
+#include <linux/uaccess.h>
+#include <media/v4l2-device.h>
 #include <media/v4l2-ioctl.h>
 
+MODULE_AUTHOR("Dimitromanolakis Apostolos, apdim@grecian.net");
+MODULE_DESCRIPTION("Radio driver for the Guillemot Maxi Radio FM2000 radio.");
+MODULE_LICENSE("GPL");
+
+static int radio_nr = -1;
+module_param(radio_nr, int, 0);
+
+static int debug;
+
+module_param(debug, int, 0644);
+MODULE_PARM_DESC(debug, "activates debug info");
+
 #define DRIVER_VERSION	"0.77"
 
-#include <linux/version.h>      /* for KERNEL_VERSION MACRO     */
-#define RADIO_VERSION KERNEL_VERSION(0,7,7)
-
-static struct video_device maxiradio_radio;
-
-#define dprintk(num, fmt, arg...)                                          \
-	do {                                                               \
-		if (maxiradio_radio.debug >= num)                          \
-			printk(KERN_DEBUG "%s: " fmt,                      \
-				maxiradio_radio.name, ## arg); } while (0)
-
-static struct v4l2_queryctrl radio_qctrl[] = {
-	{
-		.id            = V4L2_CID_AUDIO_MUTE,
-		.name          = "Mute",
-		.minimum       = 0,
-		.maximum       = 1,
-		.default_value = 1,
-		.type          = V4L2_CTRL_TYPE_BOOLEAN,
-	}
-};
+#define RADIO_VERSION KERNEL_VERSION(0, 7, 7)
+
+#define dprintk(dev, num, fmt, arg...) \
+	v4l2_dbg(num, debug, &dev->v4l2_dev, fmt, ## arg)
 
 #ifndef PCI_VENDOR_ID_GUILLEMOT
 #define PCI_VENDOR_ID_GUILLEMOT 0x5046
@@ -80,90 +75,70 @@ static struct v4l2_queryctrl radio_qctrl[] = {
 
 
 /* TEA5757 pin mappings */
-static const int clk = 1, data = 2, wren = 4, mo_st = 8, power = 16 ;
-
-static int radio_nr = -1;
-module_param(radio_nr, int, 0);
+static const int clk = 1, data = 2, wren = 4, mo_st = 8, power = 16;
 
-static unsigned long in_use;
-
-#define FREQ_LO		 50*16000
-#define FREQ_HI		150*16000
+#define FREQ_LO		(50 * 16000)
+#define FREQ_HI		(150 * 16000)
 
 #define FREQ_IF         171200 /* 10.7*16000   */
 #define FREQ_STEP       200    /* 12.5*16      */
 
 /* (x==fmhz*16*1000) -> bits */
-#define FREQ2BITS(x)	((( (unsigned int)(x)+FREQ_IF+(FREQ_STEP<<1)) \
-			/(FREQ_STEP<<2))<<2)
+#define FREQ2BITS(x) \
+  ((((unsigned int)(x) + FREQ_IF + (FREQ_STEP << 1)) / (FREQ_STEP << 2)) << 2)
 
 #define BITS2FREQ(x)	((x) * FREQ_STEP - FREQ_IF)
 
 
-static int maxiradio_exclusive_open(struct file *file)
+struct maxiradio
 {
-	return test_and_set_bit(0, &in_use) ? -EBUSY : 0;
-}
-
-static int maxiradio_exclusive_release(struct file *file)
-{
-	clear_bit(0, &in_use);
-	return 0;
-}
-
-static const struct v4l2_file_operations maxiradio_fops = {
-	.owner		= THIS_MODULE,
-	.open           = maxiradio_exclusive_open,
-	.release        = maxiradio_exclusive_release,
-	.ioctl          = video_ioctl2,
-};
+	struct v4l2_device v4l2_dev;
+	struct video_device vdev;
+	struct pci_dev *pdev;
 
-static struct radio_device
-{
-	__u16	io,	/* base of radio io */
-		muted,	/* VIDEO_AUDIO_MUTE */
-		stereo,	/* VIDEO_TUNER_STEREO_ON */
-		tuned;	/* signal strength (0 or 0xffff) */
+	u16	io;	/* base of radio io */
+	u16	muted;	/* VIDEO_AUDIO_MUTE */
+	u16	stereo;	/* VIDEO_TUNER_STEREO_ON */
+	u16	tuned;	/* signal strength (0 or 0xffff) */
 
 	unsigned long freq;
 
 	struct mutex lock;
-} radio_unit = {
-	.muted =1,
-	.freq = FREQ_LO,
 };
 
-static void outbit(unsigned long bit, __u16 io)
+static inline struct maxiradio *to_maxiradio(struct v4l2_device *v4l2_dev)
 {
-	if (bit != 0)
-		{
-			outb(  power|wren|data     ,io); udelay(4);
-			outb(  power|wren|data|clk ,io); udelay(4);
-			outb(  power|wren|data     ,io); udelay(4);
-		}
-	else
-		{
-			outb(  power|wren          ,io); udelay(4);
-			outb(  power|wren|clk      ,io); udelay(4);
-			outb(  power|wren          ,io); udelay(4);
-		}
+	return container_of(v4l2_dev, struct maxiradio, v4l2_dev);
 }
 
-static void turn_power(__u16 io, int p)
+static void outbit(unsigned long bit, u16 io)
+{
+	int val = power | wren | (bit ? data : 0);
+
+	outb(val, io);
+	udelay(4);
+	outb(val | clk, io);
+	udelay(4);
+	outb(val, io);
+	udelay(4);
+}
+
+static void turn_power(struct maxiradio *dev, int p)
 {
 	if (p != 0) {
-		dprintk(1, "Radio powered on\n");
-		outb(power, io);
+		dprintk(dev, 1, "Radio powered on\n");
+		outb(power, dev->io);
 	} else {
-		dprintk(1, "Radio powered off\n");
-		outb(0,io);
+		dprintk(dev, 1, "Radio powered off\n");
+		outb(0, dev->io);
 	}
 }
 
-static void set_freq(__u16 io, __u32 freq)
+static void set_freq(struct maxiradio *dev, u32 freq)
 {
 	unsigned long int si;
 	int bl;
+	int io = dev->io;
 	int val = FREQ2BITS(freq);
 
 	/* TEA5757 shift register bits (see pdf) */
@@ -188,14 +163,14 @@ static void set_freq(__u16 io, __u32 freq)
 		si >>= 1;
 	}
 
-	dprintk(1, "Radio freq set to %d.%02d MHz\n",
+	dprintk(dev, 1, "Radio freq set to %d.%02d MHz\n",
 				freq / 16000,
 				freq % 16000 * 100 / 16000);
 
-	turn_power(io, 1);
+	turn_power(dev, 1);
 }
 
-static int get_stereo(__u16 io)
+static int get_stereo(u16 io)
 {
 	outb(power,io);
 	udelay(4);
@@ -203,7 +178,7 @@ static int get_stereo(__u16 io)
 	return !(inb(io) & mo_st);
 }
 
-static int get_tune(__u16 io)
+static int get_tune(u16 io)
 {
 	outb(power+clk,io);
 	udelay(4);
@@ -212,95 +187,84 @@ static int get_tune(__u16 io)
 }
 
 
-static int vidioc_querycap (struct file *file, void  *priv,
+static int vidioc_querycap(struct file *file, void  *priv,
 			    struct v4l2_capability *v)
 {
-	strlcpy(v->driver, "radio-maxiradio", sizeof (v->driver));
-	strlcpy(v->card, "Maxi Radio FM2000 radio", sizeof (v->card));
-	sprintf(v->bus_info,"ISA");
-	v->version = RADIO_VERSION;
-	v->capabilities = V4L2_CAP_TUNER;
+	struct maxiradio *dev = video_drvdata(file);
 
+	strlcpy(v->driver, "radio-maxiradio", sizeof(v->driver));
+	strlcpy(v->card, "Maxi Radio FM2000 radio", sizeof(v->card));
+	snprintf(v->bus_info, sizeof(v->bus_info), "PCI:%s", pci_name(dev->pdev));
+	v->version = RADIO_VERSION;
+	v->capabilities = V4L2_CAP_TUNER | V4L2_CAP_RADIO;
 	return 0;
 }
 
-static int vidioc_g_tuner (struct file *file, void *priv,
+static int vidioc_g_tuner(struct file *file, void *priv,
 			   struct v4l2_tuner *v)
 {
-	struct radio_device *card = video_drvdata(file);
+	struct maxiradio *dev = video_drvdata(file);
 
 	if (v->index > 0)
 		return -EINVAL;
 
-	memset(v,0,sizeof(*v));
-	strcpy(v->name, "FM");
+	mutex_lock(&dev->lock);
+	strlcpy(v->name, "FM", sizeof(v->name));
 	v->type = V4L2_TUNER_RADIO;
-
-	v->rangelow=FREQ_LO;
-	v->rangehigh=FREQ_HI;
-	v->rxsubchans =V4L2_TUNER_SUB_MONO|V4L2_TUNER_SUB_STEREO;
-	v->capability=V4L2_TUNER_CAP_LOW;
-	if(get_stereo(card->io))
+	v->rangelow = FREQ_LO;
+	v->rangehigh = FREQ_HI;
+	v->rxsubchans = V4L2_TUNER_SUB_MONO | V4L2_TUNER_SUB_STEREO;
+	v->capability = V4L2_TUNER_CAP_LOW;
+	if (get_stereo(dev->io))
 		v->audmode = V4L2_TUNER_MODE_STEREO;
 	else
 		v->audmode = V4L2_TUNER_MODE_MONO;
-	v->signal=0xffff*get_tune(card->io);
+	v->signal = 0xffff * get_tune(dev->io);
+	mutex_unlock(&dev->lock);
 
 	return 0;
 }
 
-static int vidioc_s_tuner (struct file *file, void *priv,
+static int vidioc_s_tuner(struct file *file, void *priv,
 			   struct v4l2_tuner *v)
 {
-	if (v->index > 0)
-		return -EINVAL;
-
-	return 0;
-}
-
-static int vidioc_g_audio (struct file *file, void *priv,
-			   struct v4l2_audio *a)
-{
-	if (a->index > 1)
-		return -EINVAL;
-
-	strcpy(a->name, "FM");
-	a->capability = V4L2_AUDCAP_STEREO;
-	return 0;
+	return v->index ? -EINVAL : 0;
 }
 
 static int vidioc_g_input(struct file *filp, void *priv, unsigned int *i)
 {
 	*i = 0;
-
 	return 0;
 }
 
 static int vidioc_s_input(struct file *filp, void *priv, unsigned int i)
 {
-	if (i != 0)
-		return -EINVAL;
+	return i ? -EINVAL : 0;
+}
 
+static int vidioc_g_audio(struct file *file, void *priv,
+			   struct v4l2_audio *a)
+{
+	a->index = 0;
+	strlcpy(a->name, "Radio", sizeof(a->name));
+	a->capability = V4L2_AUDCAP_STEREO;
 	return 0;
 }
 
 
-static int vidioc_s_audio (struct file *file, void *priv,
+static int vidioc_s_audio(struct file *file, void *priv,
 			   struct v4l2_audio *a)
 {
-	if (a->index != 0)
-		return -EINVAL;
-
-	return 0;
+	return a->index ? -EINVAL : 0;
 }
 
-static int vidioc_s_frequency (struct file *file, void *priv,
+static int vidioc_s_frequency(struct file *file, void *priv,
 			       struct v4l2_frequency *f)
 {
-	struct radio_device *card = video_drvdata(file);
+	struct maxiradio *dev = video_drvdata(file);
 
 	if (f->frequency < FREQ_LO || f->frequency > FREQ_HI) {
-		dprintk(1, "radio freq (%d.%02d MHz) out of range (%d-%d)\n",
+		dprintk(dev, 1, "radio freq (%d.%02d MHz) out of range (%d-%d)\n",
 					f->frequency / 16000,
 					f->frequency % 16000 * 100 / 16000,
 					FREQ_LO / 16000, FREQ_HI / 16000);
@@ -308,75 +272,91 @@ static int vidioc_s_frequency (struct file *file, void *priv,
 		return -EINVAL;
 	}
 
-	card->freq = f->frequency;
-	set_freq(card->io, card->freq);
+	mutex_lock(&dev->lock);
+	dev->freq = f->frequency;
+	set_freq(dev, dev->freq);
 	msleep(125);
+	mutex_unlock(&dev->lock);
 
 	return 0;
 }
 
-static int vidioc_g_frequency (struct file *file, void *priv,
+static int vidioc_g_frequency(struct file *file, void *priv,
 			       struct v4l2_frequency *f)
 {
-	struct radio_device *card = video_drvdata(file);
+	struct maxiradio *dev = video_drvdata(file);
 
 	f->type = V4L2_TUNER_RADIO;
-	f->frequency = card->freq;
+	f->frequency = dev->freq;
 
-	dprintk(4, "radio freq is %d.%02d MHz",
+	dprintk(dev, 4, "radio freq is %d.%02d MHz",
 				f->frequency / 16000,
 				f->frequency % 16000 * 100 / 16000);
 
 	return 0;
 }
 
-static int vidioc_queryctrl (struct file *file, void *priv,
+static int vidioc_queryctrl(struct file *file, void *priv,
 			     struct v4l2_queryctrl *qc)
 {
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(radio_qctrl); i++) {
-		if (qc->id && qc->id == radio_qctrl[i].id) {
-			memcpy(qc, &(radio_qctrl[i]), sizeof(*qc));
-			return (0);
-		}
+	switch (qc->id) {
+	case V4L2_CID_AUDIO_MUTE:
+		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 1);
 	}
-
 	return -EINVAL;
 }
 
-static int vidioc_g_ctrl (struct file *file, void *priv,
-			    struct v4l2_control *ctrl)
+static int vidioc_g_ctrl(struct file *file, void *priv,
+		struct v4l2_control *ctrl)
 {
-	struct radio_device *card = video_drvdata(file);
+	struct maxiradio *dev = video_drvdata(file);
 
 	switch (ctrl->id) {
-		case V4L2_CID_AUDIO_MUTE:
-			ctrl->value=card->muted;
-			return (0);
+	case V4L2_CID_AUDIO_MUTE:
+		ctrl->value = dev->muted;
+		return 0;
 	}
 
 	return -EINVAL;
 }
 
-static int vidioc_s_ctrl (struct file *file, void *priv,
-			  struct v4l2_control *ctrl)
+static int vidioc_s_ctrl(struct file *file, void *priv,
+		struct v4l2_control *ctrl)
 {
-	struct radio_device *card = video_drvdata(file);
+	struct maxiradio *dev = video_drvdata(file);
 
 	switch (ctrl->id) {
-		case V4L2_CID_AUDIO_MUTE:
-			card->muted = ctrl->value;
-			if(card->muted)
-				turn_power(card->io, 0);
-			else
-				set_freq(card->io, card->freq);
-			return 0;
+	case V4L2_CID_AUDIO_MUTE:
+		mutex_lock(&dev->lock);
+		dev->muted = ctrl->value;
+		if (dev->muted)
+			turn_power(dev, 0);
+		else
+			set_freq(dev, dev->freq);
+		mutex_unlock(&dev->lock);
+		return 0;
 	}
 
 	return -EINVAL;
 }
 
+static int maxiradio_open(struct file *file)
+{
+	return 0;
+}
+
+static int maxiradio_release(struct file *file)
+{
+	return 0;
+}
+
+static const struct v4l2_file_operations maxiradio_fops = {
+	.owner		= THIS_MODULE,
+	.open           = maxiradio_open,
+	.release        = maxiradio_release,
+	.ioctl          = video_ioctl2,
+};
+
 static const struct v4l2_ioctl_ops maxiradio_ioctl_ops = {
 	.vidioc_querycap    = vidioc_querycap,
 	.vidioc_g_tuner     = vidioc_g_tuner,
@@ -392,60 +372,84 @@ static const struct v4l2_ioctl_ops maxiradio_ioctl_ops = {
 	.vidioc_s_ctrl      = vidioc_s_ctrl,
 };
 
-static struct video_device maxiradio_radio = {
-	.name		= "Maxi Radio FM2000 radio",
-	.fops           = &maxiradio_fops,
-	.ioctl_ops 	= &maxiradio_ioctl_ops,
-	.release	= video_device_release_empty,
-};
-
 static int __devinit maxiradio_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)
 {
-	if(!request_region(pci_resource_start(pdev, 0),
+	struct maxiradio *dev;
+	struct v4l2_device *v4l2_dev;
+	int retval = -ENOMEM;
+
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (dev == NULL) {
+		dev_err(&pdev->dev, "not enough memory\n");
+		return -ENOMEM;
+	}
+
+	v4l2_dev = &dev->v4l2_dev;
+	mutex_init(&dev->lock);
+	dev->pdev = pdev;
+	dev->muted = 1;
+	dev->freq = FREQ_LO;
+
+	strlcpy(v4l2_dev->name, "maxiradio", sizeof(v4l2_dev->name));
+
+	retval = v4l2_device_register(&pdev->dev, v4l2_dev);
+	if (retval < 0) {
+		v4l2_err(v4l2_dev, "Could not register v4l2_device\n");
+		goto errfr;
+	}
+
+	if (!request_region(pci_resource_start(pdev, 0),
 			   pci_resource_len(pdev, 0), "Maxi Radio FM 2000")) {
-		printk(KERN_ERR "radio-maxiradio: can't reserve I/O ports\n");
+		v4l2_err(v4l2_dev, "can't reserve I/O ports\n");
 		goto err_out;
 	}
 
 	if (pci_enable_device(pdev))
 		goto err_out_free_region;
 
-	radio_unit.io = pci_resource_start(pdev, 0);
-	mutex_init(&radio_unit.lock);
-	video_set_drvdata(&maxiradio_radio, &radio_unit);
+	dev->io = pci_resource_start(pdev, 0);
+	strlcpy(dev->vdev.name, v4l2_dev->name, sizeof(dev->vdev.name));
+	dev->vdev.v4l2_dev = v4l2_dev;
+	dev->vdev.fops = &maxiradio_fops;
+	dev->vdev.ioctl_ops = &maxiradio_ioctl_ops;
+	dev->vdev.release = video_device_release_empty;
+	video_set_drvdata(&dev->vdev, dev);
 
-	if (video_register_device(&maxiradio_radio, VFL_TYPE_RADIO, radio_nr) < 0) {
-		printk("radio-maxiradio: can't register device!");
+	if (video_register_device(&dev->vdev, VFL_TYPE_RADIO, radio_nr) < 0) {
+		v4l2_err(v4l2_dev, "can't register device!");
 		goto err_out_free_region;
 	}
 
-	printk(KERN_INFO "radio-maxiradio: version "
-	       DRIVER_VERSION
-	       " time "
-	       __TIME__ "  "
-	       __DATE__
-	       "\n");
+	v4l2_info(v4l2_dev, "version " DRIVER_VERSION
+			" time " __TIME__ "  " __DATE__ "\n");
 
-	printk(KERN_INFO "radio-maxiradio: found Guillemot MAXI Radio device (io = 0x%x)\n",
-	       radio_unit.io);
+	v4l2_info(v4l2_dev, "found Guillemot MAXI Radio device (io = 0x%x)\n",
+	       dev->io);
 	return 0;
 
 err_out_free_region:
 	release_region(pci_resource_start(pdev, 0), pci_resource_len(pdev, 0));
 err_out:
+	v4l2_device_unregister(v4l2_dev);
+errfr:
+	kfree(dev);
 	return -ENODEV;
 }
 
 static void __devexit maxiradio_remove_one(struct pci_dev *pdev)
 {
-	video_unregister_device(&maxiradio_radio);
+	struct v4l2_device *v4l2_dev = dev_get_drvdata(&pdev->dev);
+	struct maxiradio *dev = to_maxiradio(v4l2_dev);
+
+	video_unregister_device(&dev->vdev);
+	v4l2_device_unregister(&dev->v4l2_dev);
 	release_region(pci_resource_start(pdev, 0), pci_resource_len(pdev, 0));
 }
 
 static struct pci_device_id maxiradio_pci_tbl[] = {
 	{ PCI_VENDOR_ID_GUILLEMOT, PCI_DEVICE_ID_GUILLEMOT_MAXIRADIO,
 		PCI_ANY_ID, PCI_ANY_ID, },
-	{ 0,}
+	{ 0 }
 };
 
 MODULE_DEVICE_TABLE(pci, maxiradio_pci_tbl);
@@ -469,10 +473,3 @@ static void __exit maxiradio_radio_exit(void)
 
 module_init(maxiradio_radio_init);
 module_exit(maxiradio_radio_exit);
-
-MODULE_AUTHOR("Dimitromanolakis Apostolos, apdim@grecian.net");
-MODULE_DESCRIPTION("Radio driver for the Guillemot Maxi Radio FM2000 radio.");
-MODULE_LICENSE("GPL");
-
-module_param_named(debug,maxiradio_radio.debug, int, 0644);
-MODULE_PARM_DESC(debug,"activates debug info");

commit bec43661b1dc0075b7445223ba775674133b164d
Author: Hans Verkuil <hverkuil@xs4all.nl>
Date:   Tue Dec 30 06:58:20 2008 -0300

    V4L/DVB (10135): v4l2: introduce v4l2_file_operations.
    
    Introduce a struct v4l2_file_operations for v4l2 drivers.
    
    Remove the unnecessary inode argument.
    
    Move compat32 handling (and llseek) into the v4l2-dev core: this is now
    handled in the v4l2 core and no longer in the drivers themselves.
    
    Note that this changeset reverts an earlier patch that changed the return
    type of__video_ioctl2 from int to long. This change will be reinstated
    later in a much improved version.
    
    Signed-off-by: Hans Verkuil <hverkuil@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-maxiradio.c b/drivers/media/radio/radio-maxiradio.c
index c777a17b00bc..c5dc00aa9c9f 100644
--- a/drivers/media/radio/radio-maxiradio.c
+++ b/drivers/media/radio/radio-maxiradio.c
@@ -100,26 +100,22 @@ static unsigned long in_use;
 #define BITS2FREQ(x)	((x) * FREQ_STEP - FREQ_IF)
 
 
-static int maxiradio_exclusive_open(struct inode *inode, struct file *file)
+static int maxiradio_exclusive_open(struct file *file)
 {
 	return test_and_set_bit(0, &in_use) ? -EBUSY : 0;
 }
 
-static int maxiradio_exclusive_release(struct inode *inode, struct file *file)
+static int maxiradio_exclusive_release(struct file *file)
 {
 	clear_bit(0, &in_use);
 	return 0;
 }
 
-static const struct file_operations maxiradio_fops = {
+static const struct v4l2_file_operations maxiradio_fops = {
 	.owner		= THIS_MODULE,
 	.open           = maxiradio_exclusive_open,
 	.release        = maxiradio_exclusive_release,
 	.ioctl          = video_ioctl2,
-#ifdef CONFIG_COMPAT
-	.compat_ioctl	= v4l_compat_ioctl32,
-#endif
-	.llseek         = no_llseek,
 };
 
 static struct radio_device

commit c170ecf434bceb0e188b14a6deb3bfa3ec9ef699
Author: Hans Verkuil <hverkuil@xs4all.nl>
Date:   Sat Aug 23 08:32:09 2008 -0300

    V4L/DVB (8788): v4l: replace video_get_drvdata(video_devdata(filp)) with video_drvdata(filp)
    
    Use the new video_drvdata(filp) function where it is safe to do so.
    
    Signed-off-by: Hans Verkuil <hverkuil@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-maxiradio.c b/drivers/media/radio/radio-maxiradio.c
index 9bf2acf5249c..c777a17b00bc 100644
--- a/drivers/media/radio/radio-maxiradio.c
+++ b/drivers/media/radio/radio-maxiradio.c
@@ -231,8 +231,7 @@ static int vidioc_querycap (struct file *file, void  *priv,
 static int vidioc_g_tuner (struct file *file, void *priv,
 			   struct v4l2_tuner *v)
 {
-	struct video_device *dev = video_devdata(file);
-	struct radio_device *card = video_get_drvdata(dev);
+	struct radio_device *card = video_drvdata(file);
 
 	if (v->index > 0)
 		return -EINVAL;
@@ -302,8 +301,7 @@ static int vidioc_s_audio (struct file *file, void *priv,
 static int vidioc_s_frequency (struct file *file, void *priv,
 			       struct v4l2_frequency *f)
 {
-	struct video_device *dev = video_devdata(file);
-	struct radio_device *card = video_get_drvdata(dev);
+	struct radio_device *card = video_drvdata(file);
 
 	if (f->frequency < FREQ_LO || f->frequency > FREQ_HI) {
 		dprintk(1, "radio freq (%d.%02d MHz) out of range (%d-%d)\n",
@@ -324,8 +322,7 @@ static int vidioc_s_frequency (struct file *file, void *priv,
 static int vidioc_g_frequency (struct file *file, void *priv,
 			       struct v4l2_frequency *f)
 {
-	struct video_device *dev = video_devdata(file);
-	struct radio_device *card = video_get_drvdata(dev);
+	struct radio_device *card = video_drvdata(file);
 
 	f->type = V4L2_TUNER_RADIO;
 	f->frequency = card->freq;
@@ -355,8 +352,7 @@ static int vidioc_queryctrl (struct file *file, void *priv,
 static int vidioc_g_ctrl (struct file *file, void *priv,
 			    struct v4l2_control *ctrl)
 {
-	struct video_device *dev = video_devdata(file);
-	struct radio_device *card = video_get_drvdata(dev);
+	struct radio_device *card = video_drvdata(file);
 
 	switch (ctrl->id) {
 		case V4L2_CID_AUDIO_MUTE:
@@ -370,8 +366,7 @@ static int vidioc_g_ctrl (struct file *file, void *priv,
 static int vidioc_s_ctrl (struct file *file, void *priv,
 			  struct v4l2_control *ctrl)
 {
-	struct video_device *dev = video_devdata(file);
-	struct radio_device *card = video_get_drvdata(dev);
+	struct radio_device *card = video_drvdata(file);
 
 	switch (ctrl->id) {
 		case V4L2_CID_AUDIO_MUTE:

commit 601e9444f249d219009ec05674268d90f6f1cdcb
Author: Hans Verkuil <hverkuil@xs4all.nl>
Date:   Sat Aug 23 07:24:07 2008 -0300

    V4L/DVB (8786): v4l2: remove the priv field, use dev_get_drvdata instead
    
    Remove the priv field and let video_get/set_drvdata use dev_get_drvdata
    and dev_set_drvdata instead.
    
    Convert all drivers that still used priv directly.
    
    Signed-off-by: Hans Verkuil <hverkuil@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-maxiradio.c b/drivers/media/radio/radio-maxiradio.c
index 4e2e8a3d9b5f..9bf2acf5249c 100644
--- a/drivers/media/radio/radio-maxiradio.c
+++ b/drivers/media/radio/radio-maxiradio.c
@@ -232,7 +232,7 @@ static int vidioc_g_tuner (struct file *file, void *priv,
 			   struct v4l2_tuner *v)
 {
 	struct video_device *dev = video_devdata(file);
-	struct radio_device *card=dev->priv;
+	struct radio_device *card = video_get_drvdata(dev);
 
 	if (v->index > 0)
 		return -EINVAL;
@@ -303,7 +303,7 @@ static int vidioc_s_frequency (struct file *file, void *priv,
 			       struct v4l2_frequency *f)
 {
 	struct video_device *dev = video_devdata(file);
-	struct radio_device *card=dev->priv;
+	struct radio_device *card = video_get_drvdata(dev);
 
 	if (f->frequency < FREQ_LO || f->frequency > FREQ_HI) {
 		dprintk(1, "radio freq (%d.%02d MHz) out of range (%d-%d)\n",
@@ -325,7 +325,7 @@ static int vidioc_g_frequency (struct file *file, void *priv,
 			       struct v4l2_frequency *f)
 {
 	struct video_device *dev = video_devdata(file);
-	struct radio_device *card=dev->priv;
+	struct radio_device *card = video_get_drvdata(dev);
 
 	f->type = V4L2_TUNER_RADIO;
 	f->frequency = card->freq;
@@ -356,7 +356,7 @@ static int vidioc_g_ctrl (struct file *file, void *priv,
 			    struct v4l2_control *ctrl)
 {
 	struct video_device *dev = video_devdata(file);
-	struct radio_device *card=dev->priv;
+	struct radio_device *card = video_get_drvdata(dev);
 
 	switch (ctrl->id) {
 		case V4L2_CID_AUDIO_MUTE:
@@ -371,7 +371,7 @@ static int vidioc_s_ctrl (struct file *file, void *priv,
 			  struct v4l2_control *ctrl)
 {
 	struct video_device *dev = video_devdata(file);
-	struct radio_device *card=dev->priv;
+	struct radio_device *card = video_get_drvdata(dev);
 
 	switch (ctrl->id) {
 		case V4L2_CID_AUDIO_MUTE:
@@ -421,7 +421,7 @@ static int __devinit maxiradio_init_one(struct pci_dev *pdev, const struct pci_d
 
 	radio_unit.io = pci_resource_start(pdev, 0);
 	mutex_init(&radio_unit.lock);
-	maxiradio_radio.priv = &radio_unit;
+	video_set_drvdata(&maxiradio_radio, &radio_unit);
 
 	if (video_register_device(&maxiradio_radio, VFL_TYPE_RADIO, radio_nr) < 0) {
 		printk("radio-maxiradio: can't register device!");

commit aa5e90af7d78d1711f8f4275ce3638817c0023dc
Author: Hans Verkuil <hverkuil@xs4all.nl>
Date:   Sat Aug 23 06:23:55 2008 -0300

    V4L/DVB (8783): v4l: add all missing video_device release callbacks
    
    All drivers that call video_device_register where checked to see if they
    set the release callback of struct video_device. Where that callback was
    missing it was added.
    
    Signed-off-by: Hans Verkuil <hverkuil@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-maxiradio.c b/drivers/media/radio/radio-maxiradio.c
index 263ef8b02fd8..4e2e8a3d9b5f 100644
--- a/drivers/media/radio/radio-maxiradio.c
+++ b/drivers/media/radio/radio-maxiradio.c
@@ -402,9 +402,10 @@ static const struct v4l2_ioctl_ops maxiradio_ioctl_ops = {
 };
 
 static struct video_device maxiradio_radio = {
-	.name		    = "Maxi Radio FM2000 radio",
-	.fops               = &maxiradio_fops,
-	.ioctl_ops 	    = &maxiradio_ioctl_ops,
+	.name		= "Maxi Radio FM2000 radio",
+	.fops           = &maxiradio_fops,
+	.ioctl_ops 	= &maxiradio_ioctl_ops,
+	.release	= video_device_release_empty,
 };
 
 static int __devinit maxiradio_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)

commit 3ca685aae04960eaa8b2c97baf384996c20cf9ac
Author: Hans Verkuil <hverkuil@xs4all.nl>
Date:   Sat Aug 23 04:49:13 2008 -0300

    V4L/DVB (8776): radio: replace video_exclusive_open/release
    
    Move the video_exclusive_open/release functionality into the driver itself.
    
    Signed-off-by: Hans Verkuil <hverkuil@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-maxiradio.c b/drivers/media/radio/radio-maxiradio.c
index 0cc6fcb041fd..263ef8b02fd8 100644
--- a/drivers/media/radio/radio-maxiradio.c
+++ b/drivers/media/radio/radio-maxiradio.c
@@ -85,6 +85,7 @@ static const int clk = 1, data = 2, wren = 4, mo_st = 8, power = 16 ;
 static int radio_nr = -1;
 module_param(radio_nr, int, 0);
 
+static unsigned long in_use;
 
 #define FREQ_LO		 50*16000
 #define FREQ_HI		150*16000
@@ -99,10 +100,21 @@ module_param(radio_nr, int, 0);
 #define BITS2FREQ(x)	((x) * FREQ_STEP - FREQ_IF)
 
 
+static int maxiradio_exclusive_open(struct inode *inode, struct file *file)
+{
+	return test_and_set_bit(0, &in_use) ? -EBUSY : 0;
+}
+
+static int maxiradio_exclusive_release(struct inode *inode, struct file *file)
+{
+	clear_bit(0, &in_use);
+	return 0;
+}
+
 static const struct file_operations maxiradio_fops = {
 	.owner		= THIS_MODULE,
-	.open           = video_exclusive_open,
-	.release        = video_exclusive_release,
+	.open           = maxiradio_exclusive_open,
+	.release        = maxiradio_exclusive_release,
 	.ioctl          = video_ioctl2,
 #ifdef CONFIG_COMPAT
 	.compat_ioctl	= v4l_compat_ioctl32,

commit cba99ae81901fe61ac4b0d65c697474af29dc4ea
Author: Hans Verkuil <hverkuil@xs4all.nl>
Date:   Wed Sep 3 17:11:58 2008 -0300

    V4L/DVB (8778): radio: fix incorrect video_register_device result check
    
    Signed-off-by: Hans Verkuil <hverkuil@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-maxiradio.c b/drivers/media/radio/radio-maxiradio.c
index e210da161566..0cc6fcb041fd 100644
--- a/drivers/media/radio/radio-maxiradio.c
+++ b/drivers/media/radio/radio-maxiradio.c
@@ -410,7 +410,7 @@ static int __devinit maxiradio_init_one(struct pci_dev *pdev, const struct pci_d
 	mutex_init(&radio_unit.lock);
 	maxiradio_radio.priv = &radio_unit;
 
-	if (video_register_device(&maxiradio_radio, VFL_TYPE_RADIO, radio_nr)==-1) {
+	if (video_register_device(&maxiradio_radio, VFL_TYPE_RADIO, radio_nr) < 0) {
 		printk("radio-maxiradio: can't register device!");
 		goto err_out_free_region;
 	}

commit c6eb8eafdba4ad18b4520a0d28a38bc9e61883ea
Author: Hans Verkuil <hverkuil@xs4all.nl>
Date:   Wed Sep 3 17:11:54 2008 -0300

    V4L/DVB (8757): v4l-dvb: fix a bunch of sparse warnings
    
    Fixed a lot of sparse warnings: mostly warnings about shadowed variables
    and signed/unsigned mismatches.
    
    Signed-off-by: Hans Verkuil <hverkuil@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-maxiradio.c b/drivers/media/radio/radio-maxiradio.c
index 43c75497dc49..e210da161566 100644
--- a/drivers/media/radio/radio-maxiradio.c
+++ b/drivers/media/radio/radio-maxiradio.c
@@ -156,28 +156,28 @@ static void set_freq(__u16 io, __u32 freq)
 {
 	unsigned long int si;
 	int bl;
-	int data = FREQ2BITS(freq);
+	int val = FREQ2BITS(freq);
 
 	/* TEA5757 shift register bits (see pdf) */
 
-	outbit(0,io); // 24  search
-	outbit(1,io); // 23  search up/down
+	outbit(0, io); /* 24  search */
+	outbit(1, io); /* 23  search up/down */
 
-	outbit(0,io); // 22  stereo/mono
+	outbit(0, io); /* 22  stereo/mono */
 
-	outbit(0,io); // 21  band
-	outbit(0,io); // 20  band (only 00=FM works I think)
+	outbit(0, io); /* 21  band */
+	outbit(0, io); /* 20  band (only 00=FM works I think) */
 
-	outbit(0,io); // 19  port ?
-	outbit(0,io); // 18  port ?
+	outbit(0, io); /* 19  port ? */
+	outbit(0, io); /* 18  port ? */
 
-	outbit(0,io); // 17  search level
-	outbit(0,io); // 16  search level
+	outbit(0, io); /* 17  search level */
+	outbit(0, io); /* 16  search level */
 
 	si = 0x8000;
-	for (bl = 1; bl <= 16 ; bl++) {
-		outbit(data & si,io);
-		si >>=1;
+	for (bl = 1; bl <= 16; bl++) {
+		outbit(val & si, io);
+		si >>= 1;
 	}
 
 	dprintk(1, "Radio freq set to %d.%02d MHz\n",

commit 0ea6bc8d43c9ee3c5384bea184eab020927a5b2c
Author: Hans Verkuil <hverkuil@xs4all.nl>
Date:   Sat Jul 26 08:26:43 2008 -0300

    V4L/DVB (8523): v4l2-dev: remove unused type and type2 field from video_device
    
    The type and type2 fields were unused and so could be removed.
    Instead add a vfl_type field that contains the type of the video
    device.
    
    Signed-off-by: Hans Verkuil <hverkuil@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@infradead.org>

diff --git a/drivers/media/radio/radio-maxiradio.c b/drivers/media/radio/radio-maxiradio.c
index 1b9099606494..43c75497dc49 100644
--- a/drivers/media/radio/radio-maxiradio.c
+++ b/drivers/media/radio/radio-maxiradio.c
@@ -391,7 +391,6 @@ static const struct v4l2_ioctl_ops maxiradio_ioctl_ops = {
 
 static struct video_device maxiradio_radio = {
 	.name		    = "Maxi Radio FM2000 radio",
-	.type		    = VID_TYPE_TUNER,
 	.fops               = &maxiradio_fops,
 	.ioctl_ops 	    = &maxiradio_ioctl_ops,
 };

commit 9c39d7eafa366b807067697f7fc5b14d8b865179
Author: Hans Verkuil <hverkuil@xs4all.nl>
Date:   Mon Jul 21 07:51:45 2008 -0300

    V4L/DVB (8483): Remove obsolete owner field from video_device struct.
    
    According to an old comment this should have been removed in 2.6.15.
    Better late than never...
    
    Signed-off-by: Hans Verkuil <hverkuil@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@infradead.org>

diff --git a/drivers/media/radio/radio-maxiradio.c b/drivers/media/radio/radio-maxiradio.c
index 780516daebba..1b9099606494 100644
--- a/drivers/media/radio/radio-maxiradio.c
+++ b/drivers/media/radio/radio-maxiradio.c
@@ -390,7 +390,6 @@ static const struct v4l2_ioctl_ops maxiradio_ioctl_ops = {
 };
 
 static struct video_device maxiradio_radio = {
-	.owner		    = THIS_MODULE,
 	.name		    = "Maxi Radio FM2000 radio",
 	.type		    = VID_TYPE_TUNER,
 	.fops               = &maxiradio_fops,

commit a399810ca69d9d4bd30ab8c1678c7439e567f90b
Author: Hans Verkuil <hverkuil@xs4all.nl>
Date:   Mon Jul 21 02:57:38 2008 -0300

    V4L/DVB (8482): videodev: move all ioctl callbacks to a new v4l2_ioctl_ops struct
    
    All ioctl callbacks are now stored in a new v4l2_ioctl_ops struct. Drivers fill in
    a const struct v4l2_ioctl_ops and video_device just contains a const pointer to it.
    
    This ensures a clean separation between the const ops struct and the non-const
    video_device struct.
    
    Signed-off-by: Hans Verkuil <hverkuil@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@infradead.org>

diff --git a/drivers/media/radio/radio-maxiradio.c b/drivers/media/radio/radio-maxiradio.c
index 9e824a7d5cc4..780516daebba 100644
--- a/drivers/media/radio/radio-maxiradio.c
+++ b/drivers/media/radio/radio-maxiradio.c
@@ -374,13 +374,7 @@ static int vidioc_s_ctrl (struct file *file, void *priv,
 	return -EINVAL;
 }
 
-static struct video_device maxiradio_radio =
-{
-	.owner		    = THIS_MODULE,
-	.name		    = "Maxi Radio FM2000 radio",
-	.type		    = VID_TYPE_TUNER,
-	.fops               = &maxiradio_fops,
-
+static const struct v4l2_ioctl_ops maxiradio_ioctl_ops = {
 	.vidioc_querycap    = vidioc_querycap,
 	.vidioc_g_tuner     = vidioc_g_tuner,
 	.vidioc_s_tuner     = vidioc_s_tuner,
@@ -395,6 +389,14 @@ static struct video_device maxiradio_radio =
 	.vidioc_s_ctrl      = vidioc_s_ctrl,
 };
 
+static struct video_device maxiradio_radio = {
+	.owner		    = THIS_MODULE,
+	.name		    = "Maxi Radio FM2000 radio",
+	.type		    = VID_TYPE_TUNER,
+	.fops               = &maxiradio_fops,
+	.ioctl_ops 	    = &maxiradio_ioctl_ops,
+};
+
 static int __devinit maxiradio_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)
 {
 	if(!request_region(pci_resource_start(pdev, 0),

commit 35ea11ff84719b1bfab2909903a9640a86552fd1
Author: Hans Verkuil <hverkuil@xs4all.nl>
Date:   Sun Jul 20 08:12:02 2008 -0300

    V4L/DVB (8430): videodev: move some functions from v4l2-dev.h to v4l2-common.h or v4l2-ioctl.h
    
    The functions in a header should not belong to another module. The prio functions
    belong to v4l2-common.c, so move them to v4l2-common.h.
    
    The ioctl functions belong to v4l2-ioctl.c, so create a new v4l2-ioctl.h header
    and move those functions to it.
    
    Signed-off-by: Hans Verkuil <hverkuil@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@infradead.org>

diff --git a/drivers/media/radio/radio-maxiradio.c b/drivers/media/radio/radio-maxiradio.c
index 0133ecf3e040..9e824a7d5cc4 100644
--- a/drivers/media/radio/radio-maxiradio.c
+++ b/drivers/media/radio/radio-maxiradio.c
@@ -44,6 +44,7 @@
 #include <linux/pci.h>
 #include <linux/videodev2.h>
 #include <media/v4l2-common.h>
+#include <media/v4l2-ioctl.h>
 
 #define DRIVER_VERSION	"0.77"
 

commit 078ff7953448163d8779e489bd0119dd9a9b4732
Author: Douglas Schilling Landgraf <dougsland@gmail.com>
Date:   Tue Apr 22 14:46:11 2008 -0300

    V4L/DVB (7402):  add macro validation for v4l_compat_ioctl32
    
    Added macro CONFIG_COMPAT for v4l_compat_ioctl32.
    
    Signed-off-by: Douglas Schilling Landgraf <dougsland@gmail.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@infradead.org>

diff --git a/drivers/media/radio/radio-maxiradio.c b/drivers/media/radio/radio-maxiradio.c
index 8e184cfc1c94..0133ecf3e040 100644
--- a/drivers/media/radio/radio-maxiradio.c
+++ b/drivers/media/radio/radio-maxiradio.c
@@ -103,7 +103,9 @@ static const struct file_operations maxiradio_fops = {
 	.open           = video_exclusive_open,
 	.release        = video_exclusive_release,
 	.ioctl          = video_ioctl2,
+#ifdef CONFIG_COMPAT
 	.compat_ioctl	= v4l_compat_ioctl32,
+#endif
 	.llseek         = no_llseek,
 };
 

commit 712642b8e371687e24ec8e1d34114beab18e92ca
Author: Mauro Carvalho Chehab <mchehab@infradead.org>
Date:   Fri Jan 26 07:33:07 2007 -0300

    V4L/DVB (5155): Properly initialize mute and radio frequency
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@infradead.org>

diff --git a/drivers/media/radio/radio-maxiradio.c b/drivers/media/radio/radio-maxiradio.c
index e5bfbd15820c..8e184cfc1c94 100644
--- a/drivers/media/radio/radio-maxiradio.c
+++ b/drivers/media/radio/radio-maxiradio.c
@@ -117,8 +117,10 @@ static struct radio_device
 	unsigned long freq;
 
 	struct mutex lock;
-} radio_unit = {0, 0, 0, 0, };
-
+} radio_unit = {
+	.muted =1,
+	.freq = FREQ_LO,
+};
 
 static void outbit(unsigned long bit, __u16 io)
 {
@@ -405,7 +407,7 @@ static int __devinit maxiradio_init_one(struct pci_dev *pdev, const struct pci_d
 	mutex_init(&radio_unit.lock);
 	maxiradio_radio.priv = &radio_unit;
 
-	if(video_register_device(&maxiradio_radio, VFL_TYPE_RADIO, radio_nr)==-1) {
+	if (video_register_device(&maxiradio_radio, VFL_TYPE_RADIO, radio_nr)==-1) {
 		printk("radio-maxiradio: can't register device!");
 		goto err_out_free_region;
 	}

commit f1557cebc8c5714fd463ffeb5f424dc56dd61bdf
Author: Mauro Carvalho Chehab <mchehab@infradead.org>
Date:   Fri Jan 26 07:23:44 2007 -0300

    V4L/DVB (5154): Add some debug info, depending on debug level
    
    With debug>0, it will show mute/unmute and set frequency events
    with debug>=4, it will show get frequency events
    Also, some kernel CodingStyle fixes were done.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@infradead.org>

diff --git a/drivers/media/radio/radio-maxiradio.c b/drivers/media/radio/radio-maxiradio.c
index 82a2f83fe2e2..e5bfbd15820c 100644
--- a/drivers/media/radio/radio-maxiradio.c
+++ b/drivers/media/radio/radio-maxiradio.c
@@ -45,10 +45,18 @@
 #include <linux/videodev2.h>
 #include <media/v4l2-common.h>
 
-#define DRIVER_VERSION	"0.76"
+#define DRIVER_VERSION	"0.77"
 
 #include <linux/version.h>      /* for KERNEL_VERSION MACRO     */
-#define RADIO_VERSION KERNEL_VERSION(0,7,6)
+#define RADIO_VERSION KERNEL_VERSION(0,7,7)
+
+static struct video_device maxiradio_radio;
+
+#define dprintk(num, fmt, arg...)                                          \
+	do {                                                               \
+		if (maxiradio_radio.debug >= num)                          \
+			printk(KERN_DEBUG "%s: " fmt,                      \
+				maxiradio_radio.name, ## arg); } while (0)
 
 static struct v4l2_queryctrl radio_qctrl[] = {
 	{
@@ -83,8 +91,9 @@ module_param(radio_nr, int, 0);
 #define FREQ_IF         171200 /* 10.7*16000   */
 #define FREQ_STEP       200    /* 12.5*16      */
 
-#define FREQ2BITS(x)	((( (unsigned int)(x)+FREQ_IF+(FREQ_STEP<<1))\
-			/(FREQ_STEP<<2))<<2) /* (x==fmhz*16*1000) -> bits */
+/* (x==fmhz*16*1000) -> bits */
+#define FREQ2BITS(x)	((( (unsigned int)(x)+FREQ_IF+(FREQ_STEP<<1)) \
+			/(FREQ_STEP<<2))<<2)
 
 #define BITS2FREQ(x)	((x) * FREQ_STEP - FREQ_IF)
 
@@ -113,7 +122,7 @@ static struct radio_device
 
 static void outbit(unsigned long bit, __u16 io)
 {
-	if(bit != 0)
+	if (bit != 0)
 		{
 			outb(  power|wren|data     ,io); udelay(4);
 			outb(  power|wren|data|clk ,io); udelay(4);
@@ -129,14 +138,20 @@ static void outbit(unsigned long bit, __u16 io)
 
 static void turn_power(__u16 io, int p)
 {
-	if(p != 0) outb(power, io); else outb(0,io);
+	if (p != 0) {
+		dprintk(1, "Radio powered on\n");
+		outb(power, io);
+	} else {
+		dprintk(1, "Radio powered off\n");
+		outb(0,io);
+	}
 }
 
-
-static void set_freq(__u16 io, __u32 data)
+static void set_freq(__u16 io, __u32 freq)
 {
 	unsigned long int si;
 	int bl;
+	int data = FREQ2BITS(freq);
 
 	/* TEA5757 shift register bits (see pdf) */
 
@@ -155,20 +170,31 @@ static void set_freq(__u16 io, __u32 data)
 	outbit(0,io); // 16  search level
 
 	si = 0x8000;
-	for(bl = 1; bl <= 16 ; bl++) { outbit(data & si,io); si >>=1; }
+	for (bl = 1; bl <= 16 ; bl++) {
+		outbit(data & si,io);
+		si >>=1;
+	}
 
-	outb(power,io);
+	dprintk(1, "Radio freq set to %d.%02d MHz\n",
+				freq / 16000,
+				freq % 16000 * 100 / 16000);
+
+	turn_power(io, 1);
 }
 
 static int get_stereo(__u16 io)
 {
-	outb(power,io); udelay(4);
+	outb(power,io);
+	udelay(4);
+
 	return !(inb(io) & mo_st);
 }
 
 static int get_tune(__u16 io)
 {
-	outb(power+clk,io); udelay(4);
+	outb(power+clk,io);
+	udelay(4);
+
 	return !(inb(io) & mo_st);
 }
 
@@ -234,6 +260,7 @@ static int vidioc_g_audio (struct file *file, void *priv,
 static int vidioc_g_input(struct file *filp, void *priv, unsigned int *i)
 {
 	*i = 0;
+
 	return 0;
 }
 
@@ -241,6 +268,7 @@ static int vidioc_s_input(struct file *filp, void *priv, unsigned int i)
 {
 	if (i != 0)
 		return -EINVAL;
+
 	return 0;
 }
 
@@ -260,11 +288,17 @@ static int vidioc_s_frequency (struct file *file, void *priv,
 	struct video_device *dev = video_devdata(file);
 	struct radio_device *card=dev->priv;
 
-	if (f->frequency < FREQ_LO || f->frequency > FREQ_HI)
+	if (f->frequency < FREQ_LO || f->frequency > FREQ_HI) {
+		dprintk(1, "radio freq (%d.%02d MHz) out of range (%d-%d)\n",
+					f->frequency / 16000,
+					f->frequency % 16000 * 100 / 16000,
+					FREQ_LO / 16000, FREQ_HI / 16000);
+
 		return -EINVAL;
+	}
 
 	card->freq = f->frequency;
-	set_freq(card->io, FREQ2BITS(card->freq));
+	set_freq(card->io, card->freq);
 	msleep(125);
 
 	return 0;
@@ -279,6 +313,10 @@ static int vidioc_g_frequency (struct file *file, void *priv,
 	f->type = V4L2_TUNER_RADIO;
 	f->frequency = card->freq;
 
+	dprintk(4, "radio freq is %d.%02d MHz",
+				f->frequency / 16000,
+				f->frequency % 16000 * 100 / 16000);
+
 	return 0;
 }
 
@@ -293,6 +331,7 @@ static int vidioc_queryctrl (struct file *file, void *priv,
 			return (0);
 		}
 	}
+
 	return -EINVAL;
 }
 
@@ -307,6 +346,7 @@ static int vidioc_g_ctrl (struct file *file, void *priv,
 			ctrl->value=card->muted;
 			return (0);
 	}
+
 	return -EINVAL;
 }
 
@@ -322,9 +362,10 @@ static int vidioc_s_ctrl (struct file *file, void *priv,
 			if(card->muted)
 				turn_power(card->io, 0);
 			else
-				set_freq(card->io, FREQ2BITS(card->freq));
+				set_freq(card->io, card->freq);
 			return 0;
 	}
+
 	return -EINVAL;
 }
 
@@ -347,7 +388,6 @@ static struct video_device maxiradio_radio =
 	.vidioc_queryctrl   = vidioc_queryctrl,
 	.vidioc_g_ctrl      = vidioc_g_ctrl,
 	.vidioc_s_ctrl      = vidioc_s_ctrl,
-
 };
 
 static int __devinit maxiradio_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)

commit b61f8d695c02dbcd3391b3409eafcf182451f10f
Author: Mauro Carvalho Chehab <mchehab@infradead.org>
Date:   Fri Jan 26 07:07:12 2007 -0300

    V4L/DVB (5153): Make it coherent with vidioc_g_tuner
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@infradead.org>

diff --git a/drivers/media/radio/radio-maxiradio.c b/drivers/media/radio/radio-maxiradio.c
index fd2b9d944cd0..82a2f83fe2e2 100644
--- a/drivers/media/radio/radio-maxiradio.c
+++ b/drivers/media/radio/radio-maxiradio.c
@@ -226,7 +226,7 @@ static int vidioc_g_audio (struct file *file, void *priv,
 	if (a->index > 1)
 		return -EINVAL;
 
-	strcpy(a->name, "Radio");
+	strcpy(a->name, "FM");
 	a->capability = V4L2_AUDCAP_STEREO;
 	return 0;
 }

commit a0c05ab9762560cf12733181d19b6529bb7231d2
Author: Mauro Carvalho Chehab <mchehab@infradead.org>
Date:   Thu Jan 25 16:48:13 2007 -0300

    V4L/DVB (5152): Implements VIDIOC_[S|G]_INPUT on radio-aztech/radio-maxiradio
    
    fmtools use VIDIOCSTUNER, with, in turn, calls VIDIOC_S_INPUT on v4l1-compat.
    So, those ioctls are required for V4L1  to work properly.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@infradead.org>

diff --git a/drivers/media/radio/radio-maxiradio.c b/drivers/media/radio/radio-maxiradio.c
index 40494dc5b7ff..fd2b9d944cd0 100644
--- a/drivers/media/radio/radio-maxiradio.c
+++ b/drivers/media/radio/radio-maxiradio.c
@@ -231,6 +231,20 @@ static int vidioc_g_audio (struct file *file, void *priv,
 	return 0;
 }
 
+static int vidioc_g_input(struct file *filp, void *priv, unsigned int *i)
+{
+	*i = 0;
+	return 0;
+}
+
+static int vidioc_s_input(struct file *filp, void *priv, unsigned int i)
+{
+	if (i != 0)
+		return -EINVAL;
+	return 0;
+}
+
+
 static int vidioc_s_audio (struct file *file, void *priv,
 			   struct v4l2_audio *a)
 {
@@ -326,6 +340,8 @@ static struct video_device maxiradio_radio =
 	.vidioc_s_tuner     = vidioc_s_tuner,
 	.vidioc_g_audio     = vidioc_g_audio,
 	.vidioc_s_audio     = vidioc_s_audio,
+	.vidioc_g_input     = vidioc_g_input,
+	.vidioc_s_input     = vidioc_s_input,
 	.vidioc_g_frequency = vidioc_g_frequency,
 	.vidioc_s_frequency = vidioc_s_frequency,
 	.vidioc_queryctrl   = vidioc_queryctrl,

commit 140dcc46ede8dcd9032bbe0ce52eb4df104a1ab0
Author: Mauro Carvalho Chehab <mchehab@infradead.org>
Date:   Thu Jan 25 15:00:45 2007 -0300

    V4L/DVB (5150): Implement VIDIOC_[GS]_AUDIO on maxiradio
    
    v4l1-compat requires those two ioctls to translate VIDIOC[SG]RADIO
     into V4L2 calls.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@infradead.org>

diff --git a/drivers/media/radio/radio-maxiradio.c b/drivers/media/radio/radio-maxiradio.c
index 2fc866086d13..40494dc5b7ff 100644
--- a/drivers/media/radio/radio-maxiradio.c
+++ b/drivers/media/radio/radio-maxiradio.c
@@ -220,6 +220,26 @@ static int vidioc_s_tuner (struct file *file, void *priv,
 	return 0;
 }
 
+static int vidioc_g_audio (struct file *file, void *priv,
+			   struct v4l2_audio *a)
+{
+	if (a->index > 1)
+		return -EINVAL;
+
+	strcpy(a->name, "Radio");
+	a->capability = V4L2_AUDCAP_STEREO;
+	return 0;
+}
+
+static int vidioc_s_audio (struct file *file, void *priv,
+			   struct v4l2_audio *a)
+{
+	if (a->index != 0)
+		return -EINVAL;
+
+	return 0;
+}
+
 static int vidioc_s_frequency (struct file *file, void *priv,
 			       struct v4l2_frequency *f)
 {
@@ -304,6 +324,8 @@ static struct video_device maxiradio_radio =
 	.vidioc_querycap    = vidioc_querycap,
 	.vidioc_g_tuner     = vidioc_g_tuner,
 	.vidioc_s_tuner     = vidioc_s_tuner,
+	.vidioc_g_audio     = vidioc_g_audio,
+	.vidioc_s_audio     = vidioc_s_audio,
 	.vidioc_g_frequency = vidioc_g_frequency,
 	.vidioc_s_frequency = vidioc_s_frequency,
 	.vidioc_queryctrl   = vidioc_queryctrl,

commit 06470ed612cf2bf99bf05d57259d0a65a5481df5
Author: Mauro Carvalho Chehab <mchehab@infradead.org>
Date:   Thu Jan 25 09:04:34 2007 -0300

    V4L/DVB (5149): Convert radio-maxiradio to use video_ioctl2
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@infradead.org>

diff --git a/drivers/media/radio/radio-maxiradio.c b/drivers/media/radio/radio-maxiradio.c
index 6beeb74004b1..2fc866086d13 100644
--- a/drivers/media/radio/radio-maxiradio.c
+++ b/drivers/media/radio/radio-maxiradio.c
@@ -27,7 +27,9 @@
  * BUGS:
  *   - card unmutes if you change frequency
  *
- * Converted to V4L2 API by Mauro Carvalho Chehab <mchehab@infradead.org>
+ * (c) 2006, 2007 by Mauro Carvalho Chehab <mchehab@infradead.org>:
+ *	- Conversion to V4L2 API
+ *      - Uses video_ioctl2 for parsing and to add debug support
  */
 
 
@@ -87,24 +89,14 @@ module_param(radio_nr, int, 0);
 #define BITS2FREQ(x)	((x) * FREQ_STEP - FREQ_IF)
 
 
-static int radio_ioctl(struct inode *inode, struct file *file,
-		       unsigned int cmd, unsigned long arg);
-
 static const struct file_operations maxiradio_fops = {
 	.owner		= THIS_MODULE,
 	.open           = video_exclusive_open,
 	.release        = video_exclusive_release,
-	.ioctl		= radio_ioctl,
+	.ioctl          = video_ioctl2,
 	.compat_ioctl	= v4l_compat_ioctl32,
 	.llseek         = no_llseek,
 };
-static struct video_device maxiradio_radio =
-{
-	.owner		= THIS_MODULE,
-	.name		= "Maxi Radio FM2000 radio",
-	.type		= VID_TYPE_TUNER,
-	.fops           = &maxiradio_fops,
-};
 
 static struct radio_device
 {
@@ -181,143 +173,144 @@ static int get_tune(__u16 io)
 }
 
 
-static inline int radio_function(struct inode *inode, struct file *file,
-				 unsigned int cmd, void *arg)
+static int vidioc_querycap (struct file *file, void  *priv,
+			    struct v4l2_capability *v)
+{
+	strlcpy(v->driver, "radio-maxiradio", sizeof (v->driver));
+	strlcpy(v->card, "Maxi Radio FM2000 radio", sizeof (v->card));
+	sprintf(v->bus_info,"ISA");
+	v->version = RADIO_VERSION;
+	v->capabilities = V4L2_CAP_TUNER;
+
+	return 0;
+}
+
+static int vidioc_g_tuner (struct file *file, void *priv,
+			   struct v4l2_tuner *v)
 {
 	struct video_device *dev = video_devdata(file);
 	struct radio_device *card=dev->priv;
 
-	switch(cmd) {
-		case VIDIOC_QUERYCAP:
-		{
-			struct v4l2_capability *v = arg;
-			memset(v,0,sizeof(*v));
-			strlcpy(v->driver, "radio-maxiradio", sizeof (v->driver));
-			strlcpy(v->card, "Maxi Radio FM2000 radio", sizeof (v->card));
-			sprintf(v->bus_info,"ISA");
-			v->version = RADIO_VERSION;
-			v->capabilities = V4L2_CAP_TUNER;
+	if (v->index > 0)
+		return -EINVAL;
 
-			return 0;
-		}
-		case VIDIOC_G_TUNER:
-		{
-			struct v4l2_tuner *v = arg;
+	memset(v,0,sizeof(*v));
+	strcpy(v->name, "FM");
+	v->type = V4L2_TUNER_RADIO;
 
-			if (v->index > 0)
-				return -EINVAL;
+	v->rangelow=FREQ_LO;
+	v->rangehigh=FREQ_HI;
+	v->rxsubchans =V4L2_TUNER_SUB_MONO|V4L2_TUNER_SUB_STEREO;
+	v->capability=V4L2_TUNER_CAP_LOW;
+	if(get_stereo(card->io))
+		v->audmode = V4L2_TUNER_MODE_STEREO;
+	else
+		v->audmode = V4L2_TUNER_MODE_MONO;
+	v->signal=0xffff*get_tune(card->io);
 
-			memset(v,0,sizeof(*v));
-			strcpy(v->name, "FM");
-			v->type = V4L2_TUNER_RADIO;
+	return 0;
+}
 
-			v->rangelow=FREQ_LO;
-			v->rangehigh=FREQ_HI;
-			v->rxsubchans =V4L2_TUNER_SUB_MONO|V4L2_TUNER_SUB_STEREO;
-			v->capability=V4L2_TUNER_CAP_LOW;
-			if(get_stereo(card->io))
-				v->audmode = V4L2_TUNER_MODE_STEREO;
-			else
-				v->audmode = V4L2_TUNER_MODE_MONO;
-			v->signal=0xffff*get_tune(card->io);
+static int vidioc_s_tuner (struct file *file, void *priv,
+			   struct v4l2_tuner *v)
+{
+	if (v->index > 0)
+		return -EINVAL;
 
-			return 0;
-		}
-		case VIDIOC_S_TUNER:
-		{
-			struct v4l2_tuner *v = arg;
+	return 0;
+}
 
-			if (v->index > 0)
-				return -EINVAL;
+static int vidioc_s_frequency (struct file *file, void *priv,
+			       struct v4l2_frequency *f)
+{
+	struct video_device *dev = video_devdata(file);
+	struct radio_device *card=dev->priv;
 
-			return 0;
-		}
-		case VIDIOC_S_FREQUENCY:
-		{
-			struct v4l2_frequency *f = arg;
+	if (f->frequency < FREQ_LO || f->frequency > FREQ_HI)
+		return -EINVAL;
 
-			if (f->frequency < FREQ_LO || f->frequency > FREQ_HI)
-				return -EINVAL;
+	card->freq = f->frequency;
+	set_freq(card->io, FREQ2BITS(card->freq));
+	msleep(125);
 
-			card->freq = f->frequency;
-			set_freq(card->io, FREQ2BITS(card->freq));
-			msleep(125);
-			return 0;
-		}
-		case VIDIOC_G_FREQUENCY:
-		{
-			struct v4l2_frequency *f = arg;
+	return 0;
+}
 
-			f->type = V4L2_TUNER_RADIO;
-			f->frequency = card->freq;
+static int vidioc_g_frequency (struct file *file, void *priv,
+			       struct v4l2_frequency *f)
+{
+	struct video_device *dev = video_devdata(file);
+	struct radio_device *card=dev->priv;
 
-			return 0;
-		}
-		case VIDIOC_QUERYCTRL:
-		{
-			struct v4l2_queryctrl *qc = arg;
-			int i;
-
-			for (i = 0; i < ARRAY_SIZE(radio_qctrl); i++) {
-				if (qc->id && qc->id == radio_qctrl[i].id) {
-					memcpy(qc, &(radio_qctrl[i]),
-								sizeof(*qc));
-					return (0);
-				}
-			}
-			return -EINVAL;
-		}
-		case VIDIOC_G_CTRL:
-		{
-			struct v4l2_control *ctrl= arg;
-
-			switch (ctrl->id) {
-				case V4L2_CID_AUDIO_MUTE:
-					ctrl->value=card->muted;
-					return (0);
-			}
-			return -EINVAL;
-		}
-		case VIDIOC_S_CTRL:
-		{
-			struct v4l2_control *ctrl= arg;
-
-			switch (ctrl->id) {
-				case V4L2_CID_AUDIO_MUTE:
-					card->muted = ctrl->value;
-					if(card->muted)
-						turn_power(card->io, 0);
-					else
-						set_freq(card->io, FREQ2BITS(card->freq));
-					return 0;
-			}
-			return -EINVAL;
+	f->type = V4L2_TUNER_RADIO;
+	f->frequency = card->freq;
+
+	return 0;
+}
+
+static int vidioc_queryctrl (struct file *file, void *priv,
+			     struct v4l2_queryctrl *qc)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(radio_qctrl); i++) {
+		if (qc->id && qc->id == radio_qctrl[i].id) {
+			memcpy(qc, &(radio_qctrl[i]), sizeof(*qc));
+			return (0);
 		}
+	}
+	return -EINVAL;
+}
 
-		default:
-			return v4l_compat_translate_ioctl(inode,file,cmd,arg,
-							  radio_function);
+static int vidioc_g_ctrl (struct file *file, void *priv,
+			    struct v4l2_control *ctrl)
+{
+	struct video_device *dev = video_devdata(file);
+	struct radio_device *card=dev->priv;
 
+	switch (ctrl->id) {
+		case V4L2_CID_AUDIO_MUTE:
+			ctrl->value=card->muted;
+			return (0);
 	}
+	return -EINVAL;
 }
 
-static int radio_ioctl(struct inode *inode, struct file *file,
-		       unsigned int cmd, unsigned long arg)
+static int vidioc_s_ctrl (struct file *file, void *priv,
+			  struct v4l2_control *ctrl)
 {
 	struct video_device *dev = video_devdata(file);
 	struct radio_device *card=dev->priv;
-	int ret;
 
-	mutex_lock(&card->lock);
-	ret = video_usercopy(inode, file, cmd, arg, radio_function);
-	mutex_unlock(&card->lock);
-	return ret;
+	switch (ctrl->id) {
+		case V4L2_CID_AUDIO_MUTE:
+			card->muted = ctrl->value;
+			if(card->muted)
+				turn_power(card->io, 0);
+			else
+				set_freq(card->io, FREQ2BITS(card->freq));
+			return 0;
+	}
+	return -EINVAL;
 }
 
-MODULE_AUTHOR("Dimitromanolakis Apostolos, apdim@grecian.net");
-MODULE_DESCRIPTION("Radio driver for the Guillemot Maxi Radio FM2000 radio.");
-MODULE_LICENSE("GPL");
+static struct video_device maxiradio_radio =
+{
+	.owner		    = THIS_MODULE,
+	.name		    = "Maxi Radio FM2000 radio",
+	.type		    = VID_TYPE_TUNER,
+	.fops               = &maxiradio_fops,
+
+	.vidioc_querycap    = vidioc_querycap,
+	.vidioc_g_tuner     = vidioc_g_tuner,
+	.vidioc_s_tuner     = vidioc_s_tuner,
+	.vidioc_g_frequency = vidioc_g_frequency,
+	.vidioc_s_frequency = vidioc_s_frequency,
+	.vidioc_queryctrl   = vidioc_queryctrl,
+	.vidioc_g_ctrl      = vidioc_g_ctrl,
+	.vidioc_s_ctrl      = vidioc_s_ctrl,
 
+};
 
 static int __devinit maxiradio_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)
 {
@@ -389,3 +382,10 @@ static void __exit maxiradio_radio_exit(void)
 
 module_init(maxiradio_radio_init);
 module_exit(maxiradio_radio_exit);
+
+MODULE_AUTHOR("Dimitromanolakis Apostolos, apdim@grecian.net");
+MODULE_DESCRIPTION("Radio driver for the Guillemot Maxi Radio FM2000 radio.");
+MODULE_LICENSE("GPL");
+
+module_param_named(debug,maxiradio_radio.debug, int, 0644);
+MODULE_PARM_DESC(debug,"activates debug info");

commit cd354f1ae75e6466a7e31b727faede57a1f89ca5
Author: Tim Schmielau <tim@physik3.uni-rostock.de>
Date:   Wed Feb 14 00:33:14 2007 -0800

    [PATCH] remove many unneeded #includes of sched.h
    
    After Al Viro (finally) succeeded in removing the sched.h #include in module.h
    recently, it makes sense again to remove other superfluous sched.h includes.
    There are quite a lot of files which include it but don't actually need
    anything defined in there.  Presumably these includes were once needed for
    macros that used to live in sched.h, but moved to other header files in the
    course of cleaning it up.
    
    To ease the pain, this time I did not fiddle with any header files and only
    removed #includes from .c-files, which tend to cause less trouble.
    
    Compile tested against 2.6.20-rc2 and 2.6.20-rc2-mm2 (with offsets) on alpha,
    arm, i386, ia64, mips, powerpc, and x86_64 with allnoconfig, defconfig,
    allmodconfig, and allyesconfig as well as a few randconfigs on x86_64 and all
    configs in arch/arm/configs on arm.  I also checked that no new warnings were
    introduced by the patch (actually, some warnings are removed that were emitted
    by unnecessarily included header files).
    
    Signed-off-by: Tim Schmielau <tim@physik3.uni-rostock.de>
    Acked-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/media/radio/radio-maxiradio.c b/drivers/media/radio/radio-maxiradio.c
index 00a2f31d2af3..6beeb74004b1 100644
--- a/drivers/media/radio/radio-maxiradio.c
+++ b/drivers/media/radio/radio-maxiradio.c
@@ -35,7 +35,6 @@
 #include <linux/init.h>
 #include <linux/ioport.h>
 #include <linux/delay.h>
-#include <linux/sched.h>
 #include <asm/io.h>
 #include <asm/uaccess.h>
 #include <linux/mutex.h>

commit fa027c2a0a0d6d1df6b29ee99048502c93da0dd4
Author: Arjan van de Ven <arjan@linux.intel.com>
Date:   Mon Feb 12 00:55:33 2007 -0800

    [PATCH] mark struct file_operations const 4
    
    Many struct file_operations in the kernel can be "const".  Marking them const
    moves these to the .rodata section, which avoids false sharing with potential
    dirty data.  In addition it'll catch accidental writes at compile time to
    these shared resources.
    
    [akpm@sdl.org: dvb fix]
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/media/radio/radio-maxiradio.c b/drivers/media/radio/radio-maxiradio.c
index c2eeae7a10d0..00a2f31d2af3 100644
--- a/drivers/media/radio/radio-maxiradio.c
+++ b/drivers/media/radio/radio-maxiradio.c
@@ -91,7 +91,7 @@ module_param(radio_nr, int, 0);
 static int radio_ioctl(struct inode *inode, struct file *file,
 		       unsigned int cmd, unsigned long arg);
 
-static struct file_operations maxiradio_fops = {
+static const struct file_operations maxiradio_fops = {
 	.owner		= THIS_MODULE,
 	.open           = video_exclusive_open,
 	.release        = video_exclusive_release,

commit e84fef6b4a9d36fea53354633c590a7800d9fd83
Author: Mauro Carvalho Chehab <mchehab@infradead.org>
Date:   Tue Aug 8 09:10:05 2006 -0300

    V4L/DVB (4364): V4L2 conversion: radio-maxiradio
    
    Driver conversion to V4L2 API.
    Require some testing, since this obsolete hardware is not
    common those days.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@infradead.org>

diff --git a/drivers/media/radio/radio-maxiradio.c b/drivers/media/radio/radio-maxiradio.c
index f93d7afe7304..c2eeae7a10d0 100644
--- a/drivers/media/radio/radio-maxiradio.c
+++ b/drivers/media/radio/radio-maxiradio.c
@@ -20,13 +20,14 @@
  *   0.75b
  *     - better pci interface thanks to Francois Romieu <romieu@cogenit.fr>
  *
- *   0.75
+ *   0.75      Sun Feb  4 22:51:27 EET 2001
  *     - tiding up
  *     - removed support for multiple devices as it didn't work anyway
  *
  * BUGS:
  *   - card unmutes if you change frequency
  *
+ * Converted to V4L2 API by Mauro Carvalho Chehab <mchehab@infradead.org>
  */
 
 
@@ -40,11 +41,24 @@
 #include <linux/mutex.h>
 
 #include <linux/pci.h>
-#include <linux/videodev.h>
+#include <linux/videodev2.h>
 #include <media/v4l2-common.h>
 
-/* version 0.75      Sun Feb  4 22:51:27 EET 2001 */
-#define DRIVER_VERSION	"0.75"
+#define DRIVER_VERSION	"0.76"
+
+#include <linux/version.h>      /* for KERNEL_VERSION MACRO     */
+#define RADIO_VERSION KERNEL_VERSION(0,7,6)
+
+static struct v4l2_queryctrl radio_qctrl[] = {
+	{
+		.id            = V4L2_CID_AUDIO_MUTE,
+		.name          = "Mute",
+		.minimum       = 0,
+		.maximum       = 1,
+		.default_value = 1,
+		.type          = V4L2_CTRL_TYPE_BOOLEAN,
+	}
+};
 
 #ifndef PCI_VENDOR_ID_GUILLEMOT
 #define PCI_VENDOR_ID_GUILLEMOT 0x5046
@@ -90,7 +104,6 @@ static struct video_device maxiradio_radio =
 	.owner		= THIS_MODULE,
 	.name		= "Maxi Radio FM2000 radio",
 	.type		= VID_TYPE_TUNER,
-	.hardware	= VID_HARDWARE_SF16MI,
 	.fops           = &maxiradio_fops,
 };
 
@@ -176,89 +189,116 @@ static inline int radio_function(struct inode *inode, struct file *file,
 	struct radio_device *card=dev->priv;
 
 	switch(cmd) {
-		case VIDIOCGCAP: {
-			struct video_capability *v = arg;
-
+		case VIDIOC_QUERYCAP:
+		{
+			struct v4l2_capability *v = arg;
 			memset(v,0,sizeof(*v));
-			strcpy(v->name, "Maxi Radio FM2000 radio");
-			v->type=VID_TYPE_TUNER;
-			v->channels=v->audios=1;
+			strlcpy(v->driver, "radio-maxiradio", sizeof (v->driver));
+			strlcpy(v->card, "Maxi Radio FM2000 radio", sizeof (v->card));
+			sprintf(v->bus_info,"ISA");
+			v->version = RADIO_VERSION;
+			v->capabilities = V4L2_CAP_TUNER;
+
 			return 0;
 		}
-		case VIDIOCGTUNER: {
-			struct video_tuner *v = arg;
+		case VIDIOC_G_TUNER:
+		{
+			struct v4l2_tuner *v = arg;
 
-			if(v->tuner)
+			if (v->index > 0)
 				return -EINVAL;
 
-			card->stereo = 0xffff * get_stereo(card->io);
-			card->tuned = 0xffff * get_tune(card->io);
-
-			v->flags = VIDEO_TUNER_LOW | card->stereo;
-			v->signal = card->tuned;
-
+			memset(v,0,sizeof(*v));
 			strcpy(v->name, "FM");
-
-			v->rangelow = FREQ_LO;
-			v->rangehigh = FREQ_HI;
-			v->mode = VIDEO_MODE_AUTO;
+			v->type = V4L2_TUNER_RADIO;
+
+			v->rangelow=FREQ_LO;
+			v->rangehigh=FREQ_HI;
+			v->rxsubchans =V4L2_TUNER_SUB_MONO|V4L2_TUNER_SUB_STEREO;
+			v->capability=V4L2_TUNER_CAP_LOW;
+			if(get_stereo(card->io))
+				v->audmode = V4L2_TUNER_MODE_STEREO;
+			else
+				v->audmode = V4L2_TUNER_MODE_MONO;
+			v->signal=0xffff*get_tune(card->io);
 
 			return 0;
 		}
-		case VIDIOCSTUNER: {
-			struct video_tuner *v = arg;
-			if(v->tuner!=0)
+		case VIDIOC_S_TUNER:
+		{
+			struct v4l2_tuner *v = arg;
+
+			if (v->index > 0)
 				return -EINVAL;
-			return 0;
-		}
-		case VIDIOCGFREQ: {
-			unsigned long *freq = arg;
 
-			*freq = card->freq;
 			return 0;
 		}
-		case VIDIOCSFREQ: {
-			unsigned long *freq = arg;
+		case VIDIOC_S_FREQUENCY:
+		{
+			struct v4l2_frequency *f = arg;
 
-			if (*freq < FREQ_LO || *freq > FREQ_HI)
+			if (f->frequency < FREQ_LO || f->frequency > FREQ_HI)
 				return -EINVAL;
-			card->freq = *freq;
+
+			card->freq = f->frequency;
 			set_freq(card->io, FREQ2BITS(card->freq));
 			msleep(125);
 			return 0;
 		}
-		case VIDIOCGAUDIO: {
-			struct video_audio *v = arg;
-			memset(v,0,sizeof(*v));
-			strcpy(v->name, "Radio");
-			v->flags=VIDEO_AUDIO_MUTABLE | card->muted;
-			v->mode=VIDEO_SOUND_STEREO;
-			return 0;
-		}
+		case VIDIOC_G_FREQUENCY:
+		{
+			struct v4l2_frequency *f = arg;
 
-		case VIDIOCSAUDIO: {
-			struct video_audio *v = arg;
+			f->type = V4L2_TUNER_RADIO;
+			f->frequency = card->freq;
 
-			if(v->audio)
-				return -EINVAL;
-			card->muted = v->flags & VIDEO_AUDIO_MUTE;
-			if(card->muted)
-				turn_power(card->io, 0);
-			else
-				set_freq(card->io, FREQ2BITS(card->freq));
 			return 0;
 		}
-		case VIDIOCGUNIT: {
-			struct video_unit *v = arg;
-
-			v->video=VIDEO_NO_UNIT;
-			v->vbi=VIDEO_NO_UNIT;
-			v->radio=dev->minor;
-			v->audio=0;
-			v->teletext=VIDEO_NO_UNIT;
-			return 0;
+		case VIDIOC_QUERYCTRL:
+		{
+			struct v4l2_queryctrl *qc = arg;
+			int i;
+
+			for (i = 0; i < ARRAY_SIZE(radio_qctrl); i++) {
+				if (qc->id && qc->id == radio_qctrl[i].id) {
+					memcpy(qc, &(radio_qctrl[i]),
+								sizeof(*qc));
+					return (0);
+				}
+			}
+			return -EINVAL;
+		}
+		case VIDIOC_G_CTRL:
+		{
+			struct v4l2_control *ctrl= arg;
+
+			switch (ctrl->id) {
+				case V4L2_CID_AUDIO_MUTE:
+					ctrl->value=card->muted;
+					return (0);
+			}
+			return -EINVAL;
 		}
-		default: return -ENOIOCTLCMD;
+		case VIDIOC_S_CTRL:
+		{
+			struct v4l2_control *ctrl= arg;
+
+			switch (ctrl->id) {
+				case V4L2_CID_AUDIO_MUTE:
+					card->muted = ctrl->value;
+					if(card->muted)
+						turn_power(card->io, 0);
+					else
+						set_freq(card->io, FREQ2BITS(card->freq));
+					return 0;
+			}
+			return -EINVAL;
+		}
+
+		default:
+			return v4l_compat_translate_ioctl(inode,file,cmd,arg,
+							  radio_function);
+
 	}
 }
 

commit 5e87efa3b29c105f81fea785babafb098e4e046d
Author: Mauro Carvalho Chehab <mchehab@infradead.org>
Date:   Mon Jun 5 10:26:32 2006 -0300

    V4L/DVB (4068): Removed all references to kernel stuff from videodev.h and videodev2.h
    
    The videodev.h and videodev2.h describe the public API for V4L and V4L2.
    It shouldn't have there any kernel-specific stuff. Those were moved to
    v4l2-dev.h.
    This patch removes some uneeded headers and include v4l2-common.h on all
    V4L driver. This header includes device implementation of V4L2 API provided
    on v4l2-dev.h as well as V4L2 internal ioctls that provides connections
    between master driver and its i2c devices.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@infradead.org>

diff --git a/drivers/media/radio/radio-maxiradio.c b/drivers/media/radio/radio-maxiradio.c
index fe2552569690..f93d7afe7304 100644
--- a/drivers/media/radio/radio-maxiradio.c
+++ b/drivers/media/radio/radio-maxiradio.c
@@ -41,6 +41,7 @@
 
 #include <linux/pci.h>
 #include <linux/videodev.h>
+#include <media/v4l2-common.h>
 
 /* version 0.75      Sun Feb  4 22:51:27 EET 2001 */
 #define DRIVER_VERSION	"0.75"

commit 4286c6f65ec01efa8f5108cadea402ecf3b12279
Author: Mauro Carvalho Chehab <mchehab@infradead.org>
Date:   Sat Apr 8 16:06:16 2006 -0300

    V4L/DVB (3753): Whitespace cleanups at media/radio
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@infradead.org>

diff --git a/drivers/media/radio/radio-maxiradio.c b/drivers/media/radio/radio-maxiradio.c
index f0bf47bcb64c..fe2552569690 100644
--- a/drivers/media/radio/radio-maxiradio.c
+++ b/drivers/media/radio/radio-maxiradio.c
@@ -1,15 +1,15 @@
-/* 
- * Guillemot Maxi Radio FM 2000 PCI radio card driver for Linux 
+/*
+ * Guillemot Maxi Radio FM 2000 PCI radio card driver for Linux
  * (C) 2001 Dimitromanolakis Apostolos <apdim@grecian.net>
  *
  * Based in the radio Maestro PCI driver. Actually it uses the same chip
  * for radio but different pci controller.
  *
  * I didn't have any specs I reversed engineered the protocol from
- * the windows driver (radio.dll). 
+ * the windows driver (radio.dll).
  *
  * The card uses the TEA5757 chip that includes a search function but it
- * is useless as I haven't found any way to read back the frequency. If 
+ * is useless as I haven't found any way to read back the frequency. If
  * anybody does please mail me.
  *
  * For the pdf file see:
@@ -24,7 +24,7 @@
  *     - tiding up
  *     - removed support for multiple devices as it didn't work anyway
  *
- * BUGS: 
+ * BUGS:
  *   - card unmutes if you change frequency
  *
  */
@@ -80,7 +80,7 @@ static struct file_operations maxiradio_fops = {
 	.owner		= THIS_MODULE,
 	.open           = video_exclusive_open,
 	.release        = video_exclusive_release,
-	.ioctl	        = radio_ioctl,
+	.ioctl		= radio_ioctl,
 	.compat_ioctl	= v4l_compat_ioctl32,
 	.llseek         = no_llseek,
 };
@@ -97,11 +97,11 @@ static struct radio_device
 {
 	__u16	io,	/* base of radio io */
 		muted,	/* VIDEO_AUDIO_MUTE */
-		stereo,	/* VIDEO_TUNER_STEREO_ON */	
+		stereo,	/* VIDEO_TUNER_STEREO_ON */
 		tuned;	/* signal strength (0 or 0xffff) */
-		
+
 	unsigned long freq;
-	
+
 	struct mutex lock;
 } radio_unit = {0, 0, 0, 0, };
 
@@ -114,7 +114,7 @@ static void outbit(unsigned long bit, __u16 io)
 			outb(  power|wren|data|clk ,io); udelay(4);
 			outb(  power|wren|data     ,io); udelay(4);
 		}
-	else	
+	else
 		{
 			outb(  power|wren          ,io); udelay(4);
 			outb(  power|wren|clk      ,io); udelay(4);
@@ -132,12 +132,12 @@ static void set_freq(__u16 io, __u32 data)
 {
 	unsigned long int si;
 	int bl;
-	
+
 	/* TEA5757 shift register bits (see pdf) */
 
-	outbit(0,io); // 24  search 
+	outbit(0,io); // 24  search
 	outbit(1,io); // 23  search up/down
-	
+
 	outbit(0,io); // 22  stereo/mono
 
 	outbit(0,io); // 21  band
@@ -145,24 +145,24 @@ static void set_freq(__u16 io, __u32 data)
 
 	outbit(0,io); // 19  port ?
 	outbit(0,io); // 18  port ?
-	
+
 	outbit(0,io); // 17  search level
 	outbit(0,io); // 16  search level
- 
+
 	si = 0x8000;
 	for(bl = 1; bl <= 16 ; bl++) { outbit(data & si,io); si >>=1; }
-	
+
 	outb(power,io);
 }
 
 static int get_stereo(__u16 io)
-{	
+{
 	outb(power,io); udelay(4);
 	return !(inb(io) & mo_st);
 }
 
 static int get_tune(__u16 io)
-{	
+{
 	outb(power+clk,io); udelay(4);
 	return !(inb(io) & mo_st);
 }
@@ -177,7 +177,7 @@ static inline int radio_function(struct inode *inode, struct file *file,
 	switch(cmd) {
 		case VIDIOCGCAP: {
 			struct video_capability *v = arg;
-			
+
 			memset(v,0,sizeof(*v));
 			strcpy(v->name, "Maxi Radio FM2000 radio");
 			v->type=VID_TYPE_TUNER;
@@ -186,22 +186,22 @@ static inline int radio_function(struct inode *inode, struct file *file,
 		}
 		case VIDIOCGTUNER: {
 			struct video_tuner *v = arg;
-			
+
 			if(v->tuner)
 				return -EINVAL;
-				
+
 			card->stereo = 0xffff * get_stereo(card->io);
 			card->tuned = 0xffff * get_tune(card->io);
-			
+
 			v->flags = VIDEO_TUNER_LOW | card->stereo;
 			v->signal = card->tuned;
-			
+
 			strcpy(v->name, "FM");
-			
+
 			v->rangelow = FREQ_LO;
 			v->rangehigh = FREQ_HI;
 			v->mode = VIDEO_MODE_AUTO;
-			
+
 			return 0;
 		}
 		case VIDIOCSTUNER: {
@@ -212,13 +212,13 @@ static inline int radio_function(struct inode *inode, struct file *file,
 		}
 		case VIDIOCGFREQ: {
 			unsigned long *freq = arg;
-			
+
 			*freq = card->freq;
 			return 0;
 		}
 		case VIDIOCSFREQ: {
 			unsigned long *freq = arg;
-			
+
 			if (*freq < FREQ_LO || *freq > FREQ_HI)
 				return -EINVAL;
 			card->freq = *freq;
@@ -226,18 +226,18 @@ static inline int radio_function(struct inode *inode, struct file *file,
 			msleep(125);
 			return 0;
 		}
-		case VIDIOCGAUDIO: {	
+		case VIDIOCGAUDIO: {
 			struct video_audio *v = arg;
 			memset(v,0,sizeof(*v));
 			strcpy(v->name, "Radio");
 			v->flags=VIDEO_AUDIO_MUTABLE | card->muted;
 			v->mode=VIDEO_SOUND_STEREO;
-			return 0;		
+			return 0;
 		}
-		
+
 		case VIDIOCSAUDIO: {
 			struct video_audio *v = arg;
-			
+
 			if(v->audio)
 				return -EINVAL;
 			card->muted = v->flags & VIDEO_AUDIO_MUTE;
@@ -249,13 +249,13 @@ static inline int radio_function(struct inode *inode, struct file *file,
 		}
 		case VIDIOCGUNIT: {
 			struct video_unit *v = arg;
-			
+
 			v->video=VIDEO_NO_UNIT;
 			v->vbi=VIDEO_NO_UNIT;
 			v->radio=dev->minor;
 			v->audio=0;
 			v->teletext=VIDEO_NO_UNIT;
-			return 0;		
+			return 0;
 		}
 		default: return -ENOIOCTLCMD;
 	}
@@ -267,7 +267,7 @@ static int radio_ioctl(struct inode *inode, struct file *file,
 	struct video_device *dev = video_devdata(file);
 	struct radio_device *card=dev->priv;
 	int ret;
-	
+
 	mutex_lock(&card->lock);
 	ret = video_usercopy(inode, file, cmd, arg, radio_function);
 	mutex_unlock(&card->lock);
@@ -282,21 +282,21 @@ MODULE_LICENSE("GPL");
 static int __devinit maxiradio_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)
 {
 	if(!request_region(pci_resource_start(pdev, 0),
-	                   pci_resource_len(pdev, 0), "Maxi Radio FM 2000")) {
-	        printk(KERN_ERR "radio-maxiradio: can't reserve I/O ports\n");
-	        goto err_out;
+			   pci_resource_len(pdev, 0), "Maxi Radio FM 2000")) {
+		printk(KERN_ERR "radio-maxiradio: can't reserve I/O ports\n");
+		goto err_out;
 	}
 
 	if (pci_enable_device(pdev))
-	        goto err_out_free_region;
+		goto err_out_free_region;
 
 	radio_unit.io = pci_resource_start(pdev, 0);
 	mutex_init(&radio_unit.lock);
 	maxiradio_radio.priv = &radio_unit;
 
 	if(video_register_device(&maxiradio_radio, VFL_TYPE_RADIO, radio_nr)==-1) {
-	        printk("radio-maxiradio: can't register device!");
-	        goto err_out_free_region;
+		printk("radio-maxiradio: can't register device!");
+		goto err_out_free_region;
 	}
 
 	printk(KERN_INFO "radio-maxiradio: version "

commit 3593cab5d62c4c7abced1076710f9bc2d8847433
Author: Ingo Molnar <mingo@elte.hu>
Date:   Tue Feb 7 06:49:14 2006 -0200

    V4L/DVB (3318b): sem2mutex: drivers/media/, #2
    
    Semaphore to mutex conversion.
    
    The conversion was generated via scripts, and the result was validated
    automatically via a script as well.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@infradead.org>

diff --git a/drivers/media/radio/radio-maxiradio.c b/drivers/media/radio/radio-maxiradio.c
index c975ddd86cd5..f0bf47bcb64c 100644
--- a/drivers/media/radio/radio-maxiradio.c
+++ b/drivers/media/radio/radio-maxiradio.c
@@ -37,7 +37,8 @@
 #include <linux/sched.h>
 #include <asm/io.h>
 #include <asm/uaccess.h>
-#include <asm/semaphore.h>
+#include <linux/mutex.h>
+
 #include <linux/pci.h>
 #include <linux/videodev.h>
 
@@ -101,7 +102,7 @@ static struct radio_device
 		
 	unsigned long freq;
 	
-	struct  semaphore lock;
+	struct mutex lock;
 } radio_unit = {0, 0, 0, 0, };
 
 
@@ -267,9 +268,9 @@ static int radio_ioctl(struct inode *inode, struct file *file,
 	struct radio_device *card=dev->priv;
 	int ret;
 	
-	down(&card->lock);
+	mutex_lock(&card->lock);
 	ret = video_usercopy(inode, file, cmd, arg, radio_function);
-	up(&card->lock);
+	mutex_unlock(&card->lock);
 	return ret;
 }
 
@@ -290,7 +291,7 @@ static int __devinit maxiradio_init_one(struct pci_dev *pdev, const struct pci_d
 	        goto err_out_free_region;
 
 	radio_unit.io = pci_resource_start(pdev, 0);
-	init_MUTEX(&radio_unit.lock);
+	mutex_init(&radio_unit.lock);
 	maxiradio_radio.priv = &radio_unit;
 
 	if(video_register_device(&maxiradio_radio, VFL_TYPE_RADIO, radio_nr)==-1) {

commit 977127174a7dff52d17faeeb4c4949a54221881f
Merge: 80c053151451 93b47684f60c
Author: Linus Torvalds <torvalds@g5.osdl.org>
Date:   Mon Jan 9 18:41:42 2006 -0800

    Merge master.kernel.org:/pub/scm/linux/kernel/git/gregkh/pci-2.6

commit 9bfab8cec652c80b4864b4d9247520dca042c2df
Author: Richard Knutsson <ricknu-0@student.ltu.se>
Date:   Wed Nov 30 00:59:34 2005 +0100

    [PATCH] drivers/block: Replace pci_module_init() with pci_register_driver()
    
    Replace obsolete pci_module_init() with pci_register_driver().
    
    Signed-off-by: Richard Knutsson <ricknu-0@student.ltu.se>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/media/radio/radio-maxiradio.c b/drivers/media/radio/radio-maxiradio.c
index 02d39a50d5ed..7b33d8f2f8f8 100644
--- a/drivers/media/radio/radio-maxiradio.c
+++ b/drivers/media/radio/radio-maxiradio.c
@@ -337,7 +337,7 @@ static struct pci_driver maxiradio_driver = {
 
 static int __init maxiradio_radio_init(void)
 {
-	return pci_module_init(&maxiradio_driver);
+	return pci_register_driver(&maxiradio_driver);
 }
 
 static void __exit maxiradio_radio_exit(void)

commit 0d0fbf8152fb3bb4393be11e8df7f70e1fbbd738
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Jan 9 15:24:57 2006 -0200

    V4L (926_2): Moves compat32 functions from fs to v4l subsystem
    
    This moves the 32 bit ioctl compatibility handlers for
    Video4Linux into a new file and adds explicit calls to them
    to each v4l device driver.
    
    Unfortunately, there does not seem to be any code handling
    the v4l2 ioctls, so quite often the code goes through two
    separate conversions, first from 32 bit v4l to 64 bit v4l,
    and from there to 64 bit v4l2. My patch does not change
    that, so there is still much room for improvement.
    
    Also, some drivers have additional ioctl numbers, for
    which the conversion should be handled internally to
    that driver.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@brturbo.com.br>

diff --git a/drivers/media/radio/radio-maxiradio.c b/drivers/media/radio/radio-maxiradio.c
index 02d39a50d5ed..30869308332a 100644
--- a/drivers/media/radio/radio-maxiradio.c
+++ b/drivers/media/radio/radio-maxiradio.c
@@ -80,6 +80,7 @@ static struct file_operations maxiradio_fops = {
 	.open           = video_exclusive_open,
 	.release        = video_exclusive_release,
 	.ioctl	        = radio_ioctl,
+	.compat_ioctl	= v4l_compat_ioctl32,
 	.llseek         = no_llseek,
 };
 static struct video_device maxiradio_radio =

commit 77933d7276ee8fa0e2947641941a6f7a100a327b
Author: Jesper Juhl <juhl@dif.dk>
Date:   Wed Jul 27 11:46:09 2005 -0700

    [PATCH] clean up inline static vs static inline
    
    `gcc -W' likes to complain if the static keyword is not at the beginning of
    the declaration.  This patch fixes all remaining occurrences of "inline
    static" up with "static inline" in the entire kernel tree (140 occurrences in
    47 files).
    
    While making this change I came across a few lines with trailing whitespace
    that I also fixed up, I have also added or removed a blank line or two here
    and there, but there are no functional changes in the patch.
    
    Signed-off-by: Jesper Juhl <juhl-lkml@dif.dk>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/media/radio/radio-maxiradio.c b/drivers/media/radio/radio-maxiradio.c
index 5b748a48ce72..02d39a50d5ed 100644
--- a/drivers/media/radio/radio-maxiradio.c
+++ b/drivers/media/radio/radio-maxiradio.c
@@ -166,7 +166,7 @@ static int get_tune(__u16 io)
 }
 
 
-inline static int radio_function(struct inode *inode, struct file *file,
+static inline int radio_function(struct inode *inode, struct file *file,
 				 unsigned int cmd, void *arg)
 {
 	struct video_device *dev = video_devdata(file);

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/media/radio/radio-maxiradio.c b/drivers/media/radio/radio-maxiradio.c
new file mode 100644
index 000000000000..5b748a48ce72
--- /dev/null
+++ b/drivers/media/radio/radio-maxiradio.c
@@ -0,0 +1,349 @@
+/* 
+ * Guillemot Maxi Radio FM 2000 PCI radio card driver for Linux 
+ * (C) 2001 Dimitromanolakis Apostolos <apdim@grecian.net>
+ *
+ * Based in the radio Maestro PCI driver. Actually it uses the same chip
+ * for radio but different pci controller.
+ *
+ * I didn't have any specs I reversed engineered the protocol from
+ * the windows driver (radio.dll). 
+ *
+ * The card uses the TEA5757 chip that includes a search function but it
+ * is useless as I haven't found any way to read back the frequency. If 
+ * anybody does please mail me.
+ *
+ * For the pdf file see:
+ * http://www.semiconductors.philips.com/pip/TEA5757H/V1
+ *
+ *
+ * CHANGES:
+ *   0.75b
+ *     - better pci interface thanks to Francois Romieu <romieu@cogenit.fr>
+ *
+ *   0.75
+ *     - tiding up
+ *     - removed support for multiple devices as it didn't work anyway
+ *
+ * BUGS: 
+ *   - card unmutes if you change frequency
+ *
+ */
+
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/delay.h>
+#include <linux/sched.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <asm/semaphore.h>
+#include <linux/pci.h>
+#include <linux/videodev.h>
+
+/* version 0.75      Sun Feb  4 22:51:27 EET 2001 */
+#define DRIVER_VERSION	"0.75"
+
+#ifndef PCI_VENDOR_ID_GUILLEMOT
+#define PCI_VENDOR_ID_GUILLEMOT 0x5046
+#endif
+
+#ifndef PCI_DEVICE_ID_GUILLEMOT
+#define PCI_DEVICE_ID_GUILLEMOT_MAXIRADIO 0x1001
+#endif
+
+
+/* TEA5757 pin mappings */
+static const int clk = 1, data = 2, wren = 4, mo_st = 8, power = 16 ;
+
+static int radio_nr = -1;
+module_param(radio_nr, int, 0);
+
+
+#define FREQ_LO		 50*16000
+#define FREQ_HI		150*16000
+
+#define FREQ_IF         171200 /* 10.7*16000   */
+#define FREQ_STEP       200    /* 12.5*16      */
+
+#define FREQ2BITS(x)	((( (unsigned int)(x)+FREQ_IF+(FREQ_STEP<<1))\
+			/(FREQ_STEP<<2))<<2) /* (x==fmhz*16*1000) -> bits */
+
+#define BITS2FREQ(x)	((x) * FREQ_STEP - FREQ_IF)
+
+
+static int radio_ioctl(struct inode *inode, struct file *file,
+		       unsigned int cmd, unsigned long arg);
+
+static struct file_operations maxiradio_fops = {
+	.owner		= THIS_MODULE,
+	.open           = video_exclusive_open,
+	.release        = video_exclusive_release,
+	.ioctl	        = radio_ioctl,
+	.llseek         = no_llseek,
+};
+static struct video_device maxiradio_radio =
+{
+	.owner		= THIS_MODULE,
+	.name		= "Maxi Radio FM2000 radio",
+	.type		= VID_TYPE_TUNER,
+	.hardware	= VID_HARDWARE_SF16MI,
+	.fops           = &maxiradio_fops,
+};
+
+static struct radio_device
+{
+	__u16	io,	/* base of radio io */
+		muted,	/* VIDEO_AUDIO_MUTE */
+		stereo,	/* VIDEO_TUNER_STEREO_ON */	
+		tuned;	/* signal strength (0 or 0xffff) */
+		
+	unsigned long freq;
+	
+	struct  semaphore lock;
+} radio_unit = {0, 0, 0, 0, };
+
+
+static void outbit(unsigned long bit, __u16 io)
+{
+	if(bit != 0)
+		{
+			outb(  power|wren|data     ,io); udelay(4);
+			outb(  power|wren|data|clk ,io); udelay(4);
+			outb(  power|wren|data     ,io); udelay(4);
+		}
+	else	
+		{
+			outb(  power|wren          ,io); udelay(4);
+			outb(  power|wren|clk      ,io); udelay(4);
+			outb(  power|wren          ,io); udelay(4);
+		}
+}
+
+static void turn_power(__u16 io, int p)
+{
+	if(p != 0) outb(power, io); else outb(0,io);
+}
+
+
+static void set_freq(__u16 io, __u32 data)
+{
+	unsigned long int si;
+	int bl;
+	
+	/* TEA5757 shift register bits (see pdf) */
+
+	outbit(0,io); // 24  search 
+	outbit(1,io); // 23  search up/down
+	
+	outbit(0,io); // 22  stereo/mono
+
+	outbit(0,io); // 21  band
+	outbit(0,io); // 20  band (only 00=FM works I think)
+
+	outbit(0,io); // 19  port ?
+	outbit(0,io); // 18  port ?
+	
+	outbit(0,io); // 17  search level
+	outbit(0,io); // 16  search level
+ 
+	si = 0x8000;
+	for(bl = 1; bl <= 16 ; bl++) { outbit(data & si,io); si >>=1; }
+	
+	outb(power,io);
+}
+
+static int get_stereo(__u16 io)
+{	
+	outb(power,io); udelay(4);
+	return !(inb(io) & mo_st);
+}
+
+static int get_tune(__u16 io)
+{	
+	outb(power+clk,io); udelay(4);
+	return !(inb(io) & mo_st);
+}
+
+
+inline static int radio_function(struct inode *inode, struct file *file,
+				 unsigned int cmd, void *arg)
+{
+	struct video_device *dev = video_devdata(file);
+	struct radio_device *card=dev->priv;
+
+	switch(cmd) {
+		case VIDIOCGCAP: {
+			struct video_capability *v = arg;
+			
+			memset(v,0,sizeof(*v));
+			strcpy(v->name, "Maxi Radio FM2000 radio");
+			v->type=VID_TYPE_TUNER;
+			v->channels=v->audios=1;
+			return 0;
+		}
+		case VIDIOCGTUNER: {
+			struct video_tuner *v = arg;
+			
+			if(v->tuner)
+				return -EINVAL;
+				
+			card->stereo = 0xffff * get_stereo(card->io);
+			card->tuned = 0xffff * get_tune(card->io);
+			
+			v->flags = VIDEO_TUNER_LOW | card->stereo;
+			v->signal = card->tuned;
+			
+			strcpy(v->name, "FM");
+			
+			v->rangelow = FREQ_LO;
+			v->rangehigh = FREQ_HI;
+			v->mode = VIDEO_MODE_AUTO;
+			
+			return 0;
+		}
+		case VIDIOCSTUNER: {
+			struct video_tuner *v = arg;
+			if(v->tuner!=0)
+				return -EINVAL;
+			return 0;
+		}
+		case VIDIOCGFREQ: {
+			unsigned long *freq = arg;
+			
+			*freq = card->freq;
+			return 0;
+		}
+		case VIDIOCSFREQ: {
+			unsigned long *freq = arg;
+			
+			if (*freq < FREQ_LO || *freq > FREQ_HI)
+				return -EINVAL;
+			card->freq = *freq;
+			set_freq(card->io, FREQ2BITS(card->freq));
+			msleep(125);
+			return 0;
+		}
+		case VIDIOCGAUDIO: {	
+			struct video_audio *v = arg;
+			memset(v,0,sizeof(*v));
+			strcpy(v->name, "Radio");
+			v->flags=VIDEO_AUDIO_MUTABLE | card->muted;
+			v->mode=VIDEO_SOUND_STEREO;
+			return 0;		
+		}
+		
+		case VIDIOCSAUDIO: {
+			struct video_audio *v = arg;
+			
+			if(v->audio)
+				return -EINVAL;
+			card->muted = v->flags & VIDEO_AUDIO_MUTE;
+			if(card->muted)
+				turn_power(card->io, 0);
+			else
+				set_freq(card->io, FREQ2BITS(card->freq));
+			return 0;
+		}
+		case VIDIOCGUNIT: {
+			struct video_unit *v = arg;
+			
+			v->video=VIDEO_NO_UNIT;
+			v->vbi=VIDEO_NO_UNIT;
+			v->radio=dev->minor;
+			v->audio=0;
+			v->teletext=VIDEO_NO_UNIT;
+			return 0;		
+		}
+		default: return -ENOIOCTLCMD;
+	}
+}
+
+static int radio_ioctl(struct inode *inode, struct file *file,
+		       unsigned int cmd, unsigned long arg)
+{
+	struct video_device *dev = video_devdata(file);
+	struct radio_device *card=dev->priv;
+	int ret;
+	
+	down(&card->lock);
+	ret = video_usercopy(inode, file, cmd, arg, radio_function);
+	up(&card->lock);
+	return ret;
+}
+
+MODULE_AUTHOR("Dimitromanolakis Apostolos, apdim@grecian.net");
+MODULE_DESCRIPTION("Radio driver for the Guillemot Maxi Radio FM2000 radio.");
+MODULE_LICENSE("GPL");
+
+
+static int __devinit maxiradio_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)
+{
+	if(!request_region(pci_resource_start(pdev, 0),
+	                   pci_resource_len(pdev, 0), "Maxi Radio FM 2000")) {
+	        printk(KERN_ERR "radio-maxiradio: can't reserve I/O ports\n");
+	        goto err_out;
+	}
+
+	if (pci_enable_device(pdev))
+	        goto err_out_free_region;
+
+	radio_unit.io = pci_resource_start(pdev, 0);
+	init_MUTEX(&radio_unit.lock);
+	maxiradio_radio.priv = &radio_unit;
+
+	if(video_register_device(&maxiradio_radio, VFL_TYPE_RADIO, radio_nr)==-1) {
+	        printk("radio-maxiradio: can't register device!");
+	        goto err_out_free_region;
+	}
+
+	printk(KERN_INFO "radio-maxiradio: version "
+	       DRIVER_VERSION
+	       " time "
+	       __TIME__ "  "
+	       __DATE__
+	       "\n");
+
+	printk(KERN_INFO "radio-maxiradio: found Guillemot MAXI Radio device (io = 0x%x)\n",
+	       radio_unit.io);
+	return 0;
+
+err_out_free_region:
+	release_region(pci_resource_start(pdev, 0), pci_resource_len(pdev, 0));
+err_out:
+	return -ENODEV;
+}
+
+static void __devexit maxiradio_remove_one(struct pci_dev *pdev)
+{
+	video_unregister_device(&maxiradio_radio);
+	release_region(pci_resource_start(pdev, 0), pci_resource_len(pdev, 0));
+}
+
+static struct pci_device_id maxiradio_pci_tbl[] = {
+	{ PCI_VENDOR_ID_GUILLEMOT, PCI_DEVICE_ID_GUILLEMOT_MAXIRADIO,
+		PCI_ANY_ID, PCI_ANY_ID, },
+	{ 0,}
+};
+
+MODULE_DEVICE_TABLE(pci, maxiradio_pci_tbl);
+
+static struct pci_driver maxiradio_driver = {
+	.name		= "radio-maxiradio",
+	.id_table	= maxiradio_pci_tbl,
+	.probe		= maxiradio_init_one,
+	.remove		= __devexit_p(maxiradio_remove_one),
+};
+
+static int __init maxiradio_radio_init(void)
+{
+	return pci_module_init(&maxiradio_driver);
+}
+
+static void __exit maxiradio_radio_exit(void)
+{
+	pci_unregister_driver(&maxiradio_driver);
+}
+
+module_init(maxiradio_radio_init);
+module_exit(maxiradio_radio_exit);
