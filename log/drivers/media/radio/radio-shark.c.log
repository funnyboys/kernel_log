commit c0decac19da3906d9b66291e57b7759489e1170f
Author: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
Date:   Mon Sep 10 08:19:14 2018 -0400

    media: use strscpy() instead of strlcpy()
    
    The implementation of strscpy() is more robust and safer.
    
    That's now the recommended way to copy NUL terminated strings.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Acked-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/radio/radio-shark.c b/drivers/media/radio/radio-shark.c
index 22f3466af2b1..8230da828d0e 100644
--- a/drivers/media/radio/radio-shark.c
+++ b/drivers/media/radio/radio-shark.c
@@ -345,7 +345,7 @@ static int usb_shark_probe(struct usb_interface *intf,
 	shark->tea.ops = &shark_tea_ops;
 	shark->tea.cannot_mute = true;
 	shark->tea.has_am = true;
-	strlcpy(shark->tea.card, "Griffin radioSHARK",
+	strscpy(shark->tea.card, "Griffin radioSHARK",
 		sizeof(shark->tea.card));
 	usb_make_path(shark->usbdev, shark->tea.bus_info,
 		sizeof(shark->tea.bus_info));

commit 1ab2234eefe5c6faa7d49ff5d2f21ac4204a8ca8
Author: Arvind Yadav <arvind.yadav.cs@gmail.com>
Date:   Sun Aug 13 04:54:45 2017 -0400

    media: radio: constify usb_device_id
    
    usb_device_id are not supposed to change at runtime. All functions
    working with usb_device_id provided by <linux/usb.h> work with
    const usb_device_id. So mark the non-const structs as const.
    
    Signed-off-by: Arvind Yadav <arvind.yadav.cs@gmail.com>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/radio/radio-shark.c b/drivers/media/radio/radio-shark.c
index 23971f5502a8..22f3466af2b1 100644
--- a/drivers/media/radio/radio-shark.c
+++ b/drivers/media/radio/radio-shark.c
@@ -392,7 +392,7 @@ static int usb_shark_resume(struct usb_interface *intf)
 #endif
 
 /* Specify the bcdDevice value, as the radioSHARK and radioSHARK2 share ids */
-static struct usb_device_id usb_shark_device_table[] = {
+static const struct usb_device_id usb_shark_device_table[] = {
 	{ .match_flags = USB_DEVICE_ID_MATCH_DEVICE_AND_VERSION |
 			 USB_DEVICE_ID_MATCH_INT_CLASS,
 	  .idVendor     = 0x077d,

commit bcb63314e2c23f1ed622418b65f9409512659c73
Author: Sakari Ailus <sakari.ailus@linux.intel.com>
Date:   Fri Oct 28 09:31:20 2016 -0200

    [media] media: Drop FSF's postal address from the source code files
    
    Drop the FSF's postal address from the source code files that typically
    contain mostly the license text. Of the 628 removed instances, 578 are
    outdated.
    
    The patch has been created with the following command without manual edits:
    
    git grep -l "675 Mass Ave\|59 Temple Place\|51 Franklin St" -- \
            drivers/media/ include/media|while read i; do i=$i perl -e '
    open(F,"< $ENV{i}");
    $a=join("", <F>);
    $a =~ s/[ \t]*\*\n.*You should.*\n.*along with.*\n.*(\n.*USA.*$)?\n//m
            && $a =~ s/(^.*)Or, (point your browser to) /$1To obtain the license, $2\n$1/m;
    close(F);
    open(F, "> $ENV{i}");
    print F $a;
    close(F);'; done
    
    Signed-off-by: Sakari Ailus <sakari.ailus@linux.intel.com>

diff --git a/drivers/media/radio/radio-shark.c b/drivers/media/radio/radio-shark.c
index 85667a95f003..23971f5502a8 100644
--- a/drivers/media/radio/radio-shark.c
+++ b/drivers/media/radio/radio-shark.c
@@ -19,10 +19,6 @@
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 */
 
 #include <linux/init.h>

commit 22dbec265c4fbea4cecc37bcbdbb730c0bc639ff
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Sun Nov 22 08:32:53 2015 -0200

    [media] media, sound: tea575x: constify snd_tea575x_ops structures
    
    The snd_tea575x_ops structures are never modified, so declare them as
    const.
    
    Done with the help of Coccinelle.
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Reviewed-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/radio/radio-shark.c b/drivers/media/radio/radio-shark.c
index 409fac188d40..85667a95f003 100644
--- a/drivers/media/radio/radio-shark.c
+++ b/drivers/media/radio/radio-shark.c
@@ -150,7 +150,7 @@ static u32 shark_read_val(struct snd_tea575x *tea)
 	return val;
 }
 
-static struct snd_tea575x_ops shark_tea_ops = {
+static const struct snd_tea575x_ops shark_tea_ops = {
 	.write_val = shark_write_val,
 	.read_val  = shark_read_val,
 };

commit d647f0b70ce2b4aeb443639dc92b2d859da697a7
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Fri Nov 13 19:40:07 2015 -0200

    [media] include/media: move driver interface headers to a separate dir
    
    Let's not mix headers used by the core with those headers that
    are needed by some driver-specific interface header.
    
    The headers used on drivers were manually moved using:
        mkdir include/media/drv-intf/
        git mv include/media/cx2341x.h include/media/cx25840.h \
            include/media/exynos-fimc.h include/media/msp3400.h \
            include/media/s3c_camif.h include/media/saa7146.h \
            include/media/saa7146_vv.h  include/media/sh_mobile_ceu.h \
            include/media/sh_mobile_csi2.h include/media/sh_vou.h \
            include/media/si476x.h include/media/soc_mediabus.h \
            include/media/tea575x.h include/media/drv-intf/
    
    And the references for those headers were corrected using:
    
        MAIN_DIR="media/"
        PREV_DIR="media/"
        DIRS="drv-intf/"
    
        echo "Checking affected files" >&2
        for i in $DIRS; do
            for j in $(find include/$MAIN_DIR/$i -type f -name '*.h'); do
                     n=`basename $j`
                    git grep -l $n
            done
        done|sort|uniq >files && (
            echo "Handling files..." >&2;
            echo "for i in \$(cat files|grep -v Documentation); do cat \$i | \\";
            (
                    cd include/$MAIN_DIR;
                    for j in $DIRS; do
                            for i in $(ls $j); do
                                    echo "perl -ne 's,(include [\\\"\\<])$PREV_DIR($i)([\\\"\\>]),\1$MAIN_DIR$j\2\3,; print \$_' |\\";
                            done;
                    done;
                    echo "cat > a && mv a \$i; done";
            );
            echo "Handling documentation..." >&2;
            echo "for i in MAINTAINERS \$(cat files); do cat \$i | \\";
            (
                    cd include/$MAIN_DIR;
                    for j in $DIRS; do
                            for i in $(ls $j); do
                                    echo "  perl -ne 's,include/$PREV_DIR($i)\b,include/$MAIN_DIR$j\1,; print \$_' |\\";
                            done;
                    done;
                    echo "cat > a && mv a \$i; done"
            );
        ) >script && . ./script
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/drivers/media/radio/radio-shark.c b/drivers/media/radio/radio-shark.c
index 050b3bb96fec..409fac188d40 100644
--- a/drivers/media/radio/radio-shark.c
+++ b/drivers/media/radio/radio-shark.c
@@ -33,7 +33,7 @@
 #include <linux/usb.h>
 #include <linux/workqueue.h>
 #include <media/v4l2-device.h>
-#include <media/tea575x.h>
+#include <media/drv-intf/tea575x.h>
 
 #if defined(CONFIG_LEDS_CLASS) || \
     (defined(CONFIG_LEDS_CLASS_MODULE) && defined(CONFIG_RADIO_SHARK_MODULE))

commit 812c083ec4ae5182ab034c0ec55dbd5bb937c6f7
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Mon Oct 28 09:16:05 2013 -0300

    [media] radio-shark: Mark shark_resume_leds() inline to kill compiler warning
    
    If SHARK_USE_LEDS=1, but CONFIG_PM=n:
    drivers/media/radio/radio-shark.c:275: warning: ‘shark_resume_leds’ defined but not used
    Instead of making the #ifdef logic even more complicated (there are already
    two definitions of shark_resume_leds()), mark shark_resume_leds() inline to
    kill the compiler warning. shark_resume_leds() is small and it has only one
    caller.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/drivers/media/radio/radio-shark.c b/drivers/media/radio/radio-shark.c
index 3db8a8cfe1a8..050b3bb96fec 100644
--- a/drivers/media/radio/radio-shark.c
+++ b/drivers/media/radio/radio-shark.c
@@ -271,8 +271,7 @@ static void shark_unregister_leds(struct shark_device *shark)
 	cancel_work_sync(&shark->led_work);
 }
 
-#ifdef CONFIG_PM
-static void shark_resume_leds(struct shark_device *shark)
+static inline void shark_resume_leds(struct shark_device *shark)
 {
 	if (test_bit(BLUE_IS_PULSE, &shark->brightness_new))
 		set_bit(BLUE_PULSE_LED, &shark->brightness_new);
@@ -281,7 +280,6 @@ static void shark_resume_leds(struct shark_device *shark)
 	set_bit(RED_LED, &shark->brightness_new);
 	schedule_work(&shark->led_work);
 }
-#endif
 #else
 static int shark_register_leds(struct shark_device *shark, struct device *dev)
 {

commit c5b0b3cb8a2b6637d652cae73f00761a1bd6e66e
Author: Mauro Carvalho Chehab <m.chehab@samsung.com>
Date:   Fri Nov 1 12:44:54 2013 -0300

    [media] radio-shark: remove a warning when CONFIG_PM is not defined
    
    On alpha, allyesconfig doesn't have CONFIG_PM, and produces the following warnings:
            drivers/media/radio/radio-shark.c:274:13: warning: 'shark_resume_leds' defined but not used [-Wunused-function]
            drivers/media/radio/radio-shark2.c:240:13: warning: 'shark_resume_leds' defined but not used [-Wunused-function]
    That's because those functions are used only at device resume.
    
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>
    Reviewed-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/drivers/media/radio/radio-shark.c b/drivers/media/radio/radio-shark.c
index b91477212413..3db8a8cfe1a8 100644
--- a/drivers/media/radio/radio-shark.c
+++ b/drivers/media/radio/radio-shark.c
@@ -271,6 +271,7 @@ static void shark_unregister_leds(struct shark_device *shark)
 	cancel_work_sync(&shark->led_work);
 }
 
+#ifdef CONFIG_PM
 static void shark_resume_leds(struct shark_device *shark)
 {
 	if (test_bit(BLUE_IS_PULSE, &shark->brightness_new))
@@ -280,6 +281,7 @@ static void shark_resume_leds(struct shark_device *shark)
 	set_bit(RED_LED, &shark->brightness_new);
 	schedule_work(&shark->led_work);
 }
+#endif
 #else
 static int shark_register_leds(struct shark_device *shark, struct device *dev)
 {

commit 59b564599bc66f086856b09e480f89555d47b35c
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Sun Jul 28 16:01:43 2013 -0300

    [media] tea575x: Move header from sound to media
    
    Move include/sound/tea575x-tuner.h to include/media/tea575x.h and update files that include it.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Acked-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/drivers/media/radio/radio-shark.c b/drivers/media/radio/radio-shark.c
index 8fa18ab5b725..b91477212413 100644
--- a/drivers/media/radio/radio-shark.c
+++ b/drivers/media/radio/radio-shark.c
@@ -33,7 +33,7 @@
 #include <linux/usb.h>
 #include <linux/workqueue.h>
 #include <media/v4l2-device.h>
-#include <sound/tea575x-tuner.h>
+#include <media/tea575x.h>
 
 #if defined(CONFIG_LEDS_CLASS) || \
     (defined(CONFIG_LEDS_CLASS_MODULE) && defined(CONFIG_RADIO_SHARK_MODULE))

commit 0bb9121c8882f015328084defdf8647df2fef50d
Author: Paul Bolle <pebolle@tiscali.nl>
Date:   Tue Mar 26 09:45:38 2013 +0100

    radio-shark: Fix printk "CONFIG_LED_CLASS"
    
    Signed-off-by: Paul Bolle <pebolle@tiscali.nl>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/media/radio/radio-shark.c b/drivers/media/radio/radio-shark.c
index 8c309c7134d7..8fa18ab5b725 100644
--- a/drivers/media/radio/radio-shark.c
+++ b/drivers/media/radio/radio-shark.c
@@ -284,7 +284,7 @@ static void shark_resume_leds(struct shark_device *shark)
 static int shark_register_leds(struct shark_device *shark, struct device *dev)
 {
 	v4l2_warn(&shark->v4l2_dev,
-		  "CONFIG_LED_CLASS not enabled, LED support disabled\n");
+		  "CONFIG_LEDS_CLASS not enabled, LED support disabled\n");
 	return 0;
 }
 static inline void shark_unregister_leds(struct shark_device *shark) { }

commit 1f71927ed51e9125eb7a3d4aed54f68dd41f2c34
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Thu Sep 13 17:37:40 2012 -0300

    [media] shark,shark2: declare resume/suspend functions as static
    
    drivers/media/radio/shark2.o: In function `_GLOBAL__sub_I_65535_0_usb_shark_suspend':
    drivers/media/radio/radio-shark2.c:344: multiple definition of `usb_shark_suspend'
    drivers/media/radio/radio-shark.o:/home/v4l/v4l/patchwork/drivers/media/radio/radio-shark.c:379: first defined here
    drivers/media/radio/shark2.o: In function `usb_shark_resume':
    drivers/media/radio/radio-shark2.c:349: multiple definition of `usb_shark_resume'
    drivers/media/radio/radio-shark.o:/home/v4l/v4l/patchwork/drivers/media/radio/radio-shark.c:384: first defined here
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-shark.c b/drivers/media/radio/radio-shark.c
index 248bc3a30832..8c309c7134d7 100644
--- a/drivers/media/radio/radio-shark.c
+++ b/drivers/media/radio/radio-shark.c
@@ -375,12 +375,12 @@ static int usb_shark_probe(struct usb_interface *intf,
 }
 
 #ifdef CONFIG_PM
-int usb_shark_suspend(struct usb_interface *intf, pm_message_t message)
+static int usb_shark_suspend(struct usb_interface *intf, pm_message_t message)
 {
 	return 0;
 }
 
-int usb_shark_resume(struct usb_interface *intf)
+static int usb_shark_resume(struct usb_interface *intf)
 {
 	struct v4l2_device *v4l2_dev = usb_get_intfdata(intf);
 	struct shark_device *shark = v4l2_dev_to_shark(v4l2_dev);

commit 559c2009003bb8092e4927a4bac99cbf75834979
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Sat Aug 11 12:55:22 2012 -0300

    [media] radio-shark: Add support for suspend & resume
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-shark.c b/drivers/media/radio/radio-shark.c
index e1970bf031a4..248bc3a30832 100644
--- a/drivers/media/radio/radio-shark.c
+++ b/drivers/media/radio/radio-shark.c
@@ -59,7 +59,8 @@ MODULE_LICENSE("GPL");
 
 #define v4l2_dev_to_shark(d) container_of(d, struct shark_device, v4l2_dev)
 
-enum { BLUE_LED, BLUE_PULSE_LED, RED_LED, NO_LEDS };
+/* Note BLUE_IS_PULSE comes after NO_LEDS as it is a status bit, not a LED */
+enum { BLUE_LED, BLUE_PULSE_LED, RED_LED, NO_LEDS, BLUE_IS_PULSE };
 
 struct shark_device {
 	struct usb_device *usbdev;
@@ -190,6 +191,7 @@ static void shark_led_set_blue(struct led_classdev *led_cdev,
 
 	atomic_set(&shark->brightness[BLUE_LED], value);
 	set_bit(BLUE_LED, &shark->brightness_new);
+	clear_bit(BLUE_IS_PULSE, &shark->brightness_new);
 	schedule_work(&shark->led_work);
 }
 
@@ -201,6 +203,7 @@ static void shark_led_set_blue_pulse(struct led_classdev *led_cdev,
 
 	atomic_set(&shark->brightness[BLUE_PULSE_LED], 256 - value);
 	set_bit(BLUE_PULSE_LED, &shark->brightness_new);
+	set_bit(BLUE_IS_PULSE, &shark->brightness_new);
 	schedule_work(&shark->led_work);
 }
 
@@ -240,6 +243,7 @@ static int shark_register_leds(struct shark_device *shark, struct device *dev)
 {
 	int i, retval;
 
+	atomic_set(&shark->brightness[BLUE_LED], 127);
 	INIT_WORK(&shark->led_work, shark_led_work);
 	for (i = 0; i < NO_LEDS; i++) {
 		shark->leds[i] = shark_led_templates[i];
@@ -266,6 +270,16 @@ static void shark_unregister_leds(struct shark_device *shark)
 
 	cancel_work_sync(&shark->led_work);
 }
+
+static void shark_resume_leds(struct shark_device *shark)
+{
+	if (test_bit(BLUE_IS_PULSE, &shark->brightness_new))
+		set_bit(BLUE_PULSE_LED, &shark->brightness_new);
+	else
+		set_bit(BLUE_LED, &shark->brightness_new);
+	set_bit(RED_LED, &shark->brightness_new);
+	schedule_work(&shark->led_work);
+}
 #else
 static int shark_register_leds(struct shark_device *shark, struct device *dev)
 {
@@ -274,6 +288,7 @@ static int shark_register_leds(struct shark_device *shark, struct device *dev)
 	return 0;
 }
 static inline void shark_unregister_leds(struct shark_device *shark) { }
+static inline void shark_resume_leds(struct shark_device *shark) { }
 #endif
 
 static void usb_shark_disconnect(struct usb_interface *intf)
@@ -359,6 +374,27 @@ static int usb_shark_probe(struct usb_interface *intf,
 	return retval;
 }
 
+#ifdef CONFIG_PM
+int usb_shark_suspend(struct usb_interface *intf, pm_message_t message)
+{
+	return 0;
+}
+
+int usb_shark_resume(struct usb_interface *intf)
+{
+	struct v4l2_device *v4l2_dev = usb_get_intfdata(intf);
+	struct shark_device *shark = v4l2_dev_to_shark(v4l2_dev);
+
+	mutex_lock(&shark->tea.mutex);
+	snd_tea575x_set_freq(&shark->tea);
+	mutex_unlock(&shark->tea.mutex);
+
+	shark_resume_leds(shark);
+
+	return 0;
+}
+#endif
+
 /* Specify the bcdDevice value, as the radioSHARK and radioSHARK2 share ids */
 static struct usb_device_id usb_shark_device_table[] = {
 	{ .match_flags = USB_DEVICE_ID_MATCH_DEVICE_AND_VERSION |
@@ -378,5 +414,10 @@ static struct usb_driver usb_shark_driver = {
 	.probe			= usb_shark_probe,
 	.disconnect		= usb_shark_disconnect,
 	.id_table		= usb_shark_device_table,
+#ifdef CONFIG_PM
+	.suspend		= usb_shark_suspend,
+	.resume			= usb_shark_resume,
+	.reset_resume		= usb_shark_resume,
+#endif
 };
 module_usb_driver(usb_shark_driver);

commit fc488517cc0d50bcc9e4ffa90fee5755f9c914fc
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Thu Jul 12 17:39:18 2012 -0300

    [media] snd_tea575x: Add support for tuning AM
    
    Add support for tuning AM (on devices with the necessary additional
    hardware components), and advertise the available bands using the new
    VIDIOC_ENUM_FREQ_BANDS ioctl.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    CC: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-shark.c b/drivers/media/radio/radio-shark.c
index 72ded29728bb..e1970bf031a4 100644
--- a/drivers/media/radio/radio-shark.c
+++ b/drivers/media/radio/radio-shark.c
@@ -333,6 +333,7 @@ static int usb_shark_probe(struct usb_interface *intf,
 	shark->tea.radio_nr = -1;
 	shark->tea.ops = &shark_tea_ops;
 	shark->tea.cannot_mute = true;
+	shark->tea.has_am = true;
 	strlcpy(shark->tea.card, "Griffin radioSHARK",
 		sizeof(shark->tea.card));
 	usb_make_path(shark->usbdev, shark->tea.bus_info,

commit 3e3b92cac5371031e9d2f916189577025f508ab8
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Sat Aug 11 06:34:54 2012 -0300

    [media] radio-shark: Only compile led support when CONFIG_LED_CLASS is set
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-shark.c b/drivers/media/radio/radio-shark.c
index 1d76afa9e1b7..72ded29728bb 100644
--- a/drivers/media/radio/radio-shark.c
+++ b/drivers/media/radio/radio-shark.c
@@ -35,6 +35,11 @@
 #include <media/v4l2-device.h>
 #include <sound/tea575x-tuner.h>
 
+#if defined(CONFIG_LEDS_CLASS) || \
+    (defined(CONFIG_LEDS_CLASS_MODULE) && defined(CONFIG_RADIO_SHARK_MODULE))
+#define SHARK_USE_LEDS 1
+#endif
+
 /*
  * Version Information
  */
@@ -56,44 +61,18 @@ MODULE_LICENSE("GPL");
 
 enum { BLUE_LED, BLUE_PULSE_LED, RED_LED, NO_LEDS };
 
-static void shark_led_set_blue(struct led_classdev *led_cdev,
-			       enum led_brightness value);
-static void shark_led_set_blue_pulse(struct led_classdev *led_cdev,
-				     enum led_brightness value);
-static void shark_led_set_red(struct led_classdev *led_cdev,
-			      enum led_brightness value);
-
-static const struct led_classdev shark_led_templates[NO_LEDS] = {
-	[BLUE_LED] = {
-		.name		= "%s:blue:",
-		.brightness	= LED_OFF,
-		.max_brightness = 127,
-		.brightness_set = shark_led_set_blue,
-	},
-	[BLUE_PULSE_LED] = {
-		.name		= "%s:blue-pulse:",
-		.brightness	= LED_OFF,
-		.max_brightness = 255,
-		.brightness_set = shark_led_set_blue_pulse,
-	},
-	[RED_LED] = {
-		.name		= "%s:red:",
-		.brightness	= LED_OFF,
-		.max_brightness = 1,
-		.brightness_set = shark_led_set_red,
-	},
-};
-
 struct shark_device {
 	struct usb_device *usbdev;
 	struct v4l2_device v4l2_dev;
 	struct snd_tea575x tea;
 
+#ifdef SHARK_USE_LEDS
 	struct work_struct led_work;
 	struct led_classdev leds[NO_LEDS];
 	char led_names[NO_LEDS][32];
 	atomic_t brightness[NO_LEDS];
 	unsigned long brightness_new;
+#endif
 
 	u8 *transfer_buffer;
 	u32 last_val;
@@ -175,6 +154,7 @@ static struct snd_tea575x_ops shark_tea_ops = {
 	.read_val  = shark_read_val,
 };
 
+#ifdef SHARK_USE_LEDS
 static void shark_led_work(struct work_struct *work)
 {
 	struct shark_device *shark =
@@ -235,21 +215,78 @@ static void shark_led_set_red(struct led_classdev *led_cdev,
 	schedule_work(&shark->led_work);
 }
 
+static const struct led_classdev shark_led_templates[NO_LEDS] = {
+	[BLUE_LED] = {
+		.name		= "%s:blue:",
+		.brightness	= LED_OFF,
+		.max_brightness = 127,
+		.brightness_set = shark_led_set_blue,
+	},
+	[BLUE_PULSE_LED] = {
+		.name		= "%s:blue-pulse:",
+		.brightness	= LED_OFF,
+		.max_brightness = 255,
+		.brightness_set = shark_led_set_blue_pulse,
+	},
+	[RED_LED] = {
+		.name		= "%s:red:",
+		.brightness	= LED_OFF,
+		.max_brightness = 1,
+		.brightness_set = shark_led_set_red,
+	},
+};
+
+static int shark_register_leds(struct shark_device *shark, struct device *dev)
+{
+	int i, retval;
+
+	INIT_WORK(&shark->led_work, shark_led_work);
+	for (i = 0; i < NO_LEDS; i++) {
+		shark->leds[i] = shark_led_templates[i];
+		snprintf(shark->led_names[i], sizeof(shark->led_names[0]),
+			 shark->leds[i].name, shark->v4l2_dev.name);
+		shark->leds[i].name = shark->led_names[i];
+		retval = led_classdev_register(dev, &shark->leds[i]);
+		if (retval) {
+			v4l2_err(&shark->v4l2_dev,
+				 "couldn't register led: %s\n",
+				 shark->led_names[i]);
+			return retval;
+		}
+	}
+	return 0;
+}
+
+static void shark_unregister_leds(struct shark_device *shark)
+{
+	int i;
+
+	for (i = 0; i < NO_LEDS; i++)
+		led_classdev_unregister(&shark->leds[i]);
+
+	cancel_work_sync(&shark->led_work);
+}
+#else
+static int shark_register_leds(struct shark_device *shark, struct device *dev)
+{
+	v4l2_warn(&shark->v4l2_dev,
+		  "CONFIG_LED_CLASS not enabled, LED support disabled\n");
+	return 0;
+}
+static inline void shark_unregister_leds(struct shark_device *shark) { }
+#endif
+
 static void usb_shark_disconnect(struct usb_interface *intf)
 {
 	struct v4l2_device *v4l2_dev = usb_get_intfdata(intf);
 	struct shark_device *shark = v4l2_dev_to_shark(v4l2_dev);
-	int i;
 
 	mutex_lock(&shark->tea.mutex);
 	v4l2_device_disconnect(&shark->v4l2_dev);
 	snd_tea575x_exit(&shark->tea);
 	mutex_unlock(&shark->tea.mutex);
 
-	for (i = 0; i < NO_LEDS; i++)
-		led_classdev_unregister(&shark->leds[i]);
-
-	cancel_work_sync(&shark->led_work);
+	shark_unregister_leds(shark);
 
 	v4l2_device_put(&shark->v4l2_dev);
 }
@@ -267,7 +304,7 @@ static int usb_shark_probe(struct usb_interface *intf,
 			   const struct usb_device_id *id)
 {
 	struct shark_device *shark;
-	int i, retval = -ENOMEM;
+	int retval = -ENOMEM;
 
 	shark = kzalloc(sizeof(struct shark_device), GFP_KERNEL);
 	if (!shark)
@@ -277,8 +314,13 @@ static int usb_shark_probe(struct usb_interface *intf,
 	if (!shark->transfer_buffer)
 		goto err_alloc_buffer;
 
-	shark->v4l2_dev.release = usb_shark_release;
 	v4l2_device_set_name(&shark->v4l2_dev, DRV_NAME, &shark_instance);
+
+	retval = shark_register_leds(shark, &intf->dev);
+	if (retval)
+		goto err_reg_leds;
+
+	shark->v4l2_dev.release = usb_shark_release;
 	retval = v4l2_device_register(&intf->dev, &shark->v4l2_dev);
 	if (retval) {
 		v4l2_err(&shark->v4l2_dev, "couldn't register v4l2_device\n");
@@ -302,32 +344,13 @@ static int usb_shark_probe(struct usb_interface *intf,
 		goto err_init_tea;
 	}
 
-	INIT_WORK(&shark->led_work, shark_led_work);
-	for (i = 0; i < NO_LEDS; i++) {
-		shark->leds[i] = shark_led_templates[i];
-		snprintf(shark->led_names[i], sizeof(shark->led_names[0]),
-			 shark->leds[i].name, shark->v4l2_dev.name);
-		shark->leds[i].name = shark->led_names[i];
-		/*
-		 * We don't fail the probe if we fail to register the leds,
-		 * because once we've called snd_tea575x_init, the /dev/radio0
-		 * node may be opened from userspace holding a reference to us!
-		 *
-		 * Note we cannot register the leds first instead as
-		 * shark_led_work depends on the v4l2 mutex and registered bit.
-		 */
-		retval = led_classdev_register(&intf->dev, &shark->leds[i]);
-		if (retval)
-			v4l2_err(&shark->v4l2_dev,
-				 "couldn't register led: %s\n",
-				 shark->led_names[i]);
-	}
-
 	return 0;
 
 err_init_tea:
 	v4l2_device_unregister(&shark->v4l2_dev);
 err_reg_dev:
+	shark_unregister_leds(shark);
+err_reg_leds:
 	kfree(shark->transfer_buffer);
 err_alloc_buffer:
 	kfree(shark);

commit cfc1b2a06f87f562da2ffb9f8d1ae4203d9bfbfa
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Sat Aug 11 06:34:53 2012 -0300

    [media] radio-shark*: Call cancel_work_sync from disconnect rather then release
    
    This removes the need for shark_led_work to take the v4l2 lock.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-shark.c b/drivers/media/radio/radio-shark.c
index e35b8d938a30..1d76afa9e1b7 100644
--- a/drivers/media/radio/radio-shark.c
+++ b/drivers/media/radio/radio-shark.c
@@ -181,14 +181,6 @@ static void shark_led_work(struct work_struct *work)
 		container_of(work, struct shark_device, led_work);
 	int i, res, brightness, actual_len;
 
-	/*
-	 * We use the v4l2_dev lock and registered bit to ensure the device
-	 * does not get unplugged and unreffed while we're running.
-	 */
-	mutex_lock(&shark->tea.mutex);
-	if (!video_is_registered(&shark->tea.vd))
-		goto leave;
-
 	for (i = 0; i < 3; i++) {
 		if (!test_and_clear_bit(i, &shark->brightness_new))
 			continue;
@@ -208,8 +200,6 @@ static void shark_led_work(struct work_struct *work)
 			v4l2_err(&shark->v4l2_dev, "set LED %s error: %d\n",
 				 shark->led_names[i], res);
 	}
-leave:
-	mutex_unlock(&shark->tea.mutex);
 }
 
 static void shark_led_set_blue(struct led_classdev *led_cdev,
@@ -259,6 +249,8 @@ static void usb_shark_disconnect(struct usb_interface *intf)
 	for (i = 0; i < NO_LEDS; i++)
 		led_classdev_unregister(&shark->leds[i]);
 
+	cancel_work_sync(&shark->led_work);
+
 	v4l2_device_put(&shark->v4l2_dev);
 }
 
@@ -266,7 +258,6 @@ static void usb_shark_release(struct v4l2_device *v4l2_dev)
 {
 	struct shark_device *shark = v4l2_dev_to_shark(v4l2_dev);
 
-	cancel_work_sync(&shark->led_work);
 	v4l2_device_unregister(&shark->v4l2_dev);
 	kfree(shark->transfer_buffer);
 	kfree(shark);

commit 820ddfa6ca87fc12bf202907b77f635df2098e66
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Sat Aug 11 06:34:52 2012 -0300

    [media] radio-shark*: Remove work-around for dangling pointer in usb intfdata
    
    Recent kernels properly clear the usb intfdata pointer when another
    driver fails to bind (in the radio-shark* case the usbhid driver would try
    to bind first.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-shark.c b/drivers/media/radio/radio-shark.c
index d0b6bb507634..e35b8d938a30 100644
--- a/drivers/media/radio/radio-shark.c
+++ b/drivers/media/radio/radio-shark.c
@@ -286,15 +286,6 @@ static int usb_shark_probe(struct usb_interface *intf,
 	if (!shark->transfer_buffer)
 		goto err_alloc_buffer;
 
-	/*
-	 * Work around a bug in usbhid/hid-core.c, where it leaves a dangling
-	 * pointer in intfdata causing v4l2-device.c to not set it. Which
-	 * results in usb_shark_disconnect() referencing the dangling pointer
-	 *
-	 * REMOVE (as soon as the above bug is fixed, patch submitted)
-	 */
-	usb_set_intfdata(intf, NULL);
-
 	shark->v4l2_dev.release = usb_shark_release;
 	v4l2_device_set_name(&shark->v4l2_dev, DRV_NAME, &shark_instance);
 	retval = v4l2_device_register(&intf->dev, &shark->v4l2_dev);

commit 8e2ce73e932b629c3e12546e5fffac7ee54d0093
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Mon May 21 15:24:50 2012 -0300

    [media] radio-shark: New driver for the Griffin radioSHARK USB radio receiver
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-shark.c b/drivers/media/radio/radio-shark.c
new file mode 100644
index 000000000000..d0b6bb507634
--- /dev/null
+++ b/drivers/media/radio/radio-shark.c
@@ -0,0 +1,376 @@
+/*
+ * Linux V4L2 radio driver for the Griffin radioSHARK USB radio receiver
+ *
+ * Note the radioSHARK offers the audio through a regular USB audio device,
+ * this driver only handles the tuning.
+ *
+ * The info necessary to drive the shark was taken from the small userspace
+ * shark.c program by Michael Rolig, which he kindly placed in the Public
+ * Domain.
+ *
+ * Copyright (c) 2012 Hans de Goede <hdegoede@redhat.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+*/
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/leds.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/usb.h>
+#include <linux/workqueue.h>
+#include <media/v4l2-device.h>
+#include <sound/tea575x-tuner.h>
+
+/*
+ * Version Information
+ */
+MODULE_AUTHOR("Hans de Goede <hdegoede@redhat.com>");
+MODULE_DESCRIPTION("Griffin radioSHARK, USB radio receiver driver");
+MODULE_LICENSE("GPL");
+
+#define SHARK_IN_EP		0x83
+#define SHARK_OUT_EP		0x05
+
+#define TEA575X_BIT_MONO	(1<<22)		/* 0 = stereo, 1 = mono */
+#define TEA575X_BIT_BAND_MASK	(3<<20)
+#define TEA575X_BIT_BAND_FM	(0<<20)
+
+#define TB_LEN 6
+#define DRV_NAME "radioshark"
+
+#define v4l2_dev_to_shark(d) container_of(d, struct shark_device, v4l2_dev)
+
+enum { BLUE_LED, BLUE_PULSE_LED, RED_LED, NO_LEDS };
+
+static void shark_led_set_blue(struct led_classdev *led_cdev,
+			       enum led_brightness value);
+static void shark_led_set_blue_pulse(struct led_classdev *led_cdev,
+				     enum led_brightness value);
+static void shark_led_set_red(struct led_classdev *led_cdev,
+			      enum led_brightness value);
+
+static const struct led_classdev shark_led_templates[NO_LEDS] = {
+	[BLUE_LED] = {
+		.name		= "%s:blue:",
+		.brightness	= LED_OFF,
+		.max_brightness = 127,
+		.brightness_set = shark_led_set_blue,
+	},
+	[BLUE_PULSE_LED] = {
+		.name		= "%s:blue-pulse:",
+		.brightness	= LED_OFF,
+		.max_brightness = 255,
+		.brightness_set = shark_led_set_blue_pulse,
+	},
+	[RED_LED] = {
+		.name		= "%s:red:",
+		.brightness	= LED_OFF,
+		.max_brightness = 1,
+		.brightness_set = shark_led_set_red,
+	},
+};
+
+struct shark_device {
+	struct usb_device *usbdev;
+	struct v4l2_device v4l2_dev;
+	struct snd_tea575x tea;
+
+	struct work_struct led_work;
+	struct led_classdev leds[NO_LEDS];
+	char led_names[NO_LEDS][32];
+	atomic_t brightness[NO_LEDS];
+	unsigned long brightness_new;
+
+	u8 *transfer_buffer;
+	u32 last_val;
+};
+
+static atomic_t shark_instance = ATOMIC_INIT(0);
+
+static void shark_write_val(struct snd_tea575x *tea, u32 val)
+{
+	struct shark_device *shark = tea->private_data;
+	int i, res, actual_len;
+
+	/* Avoid unnecessary (slow) USB transfers */
+	if (shark->last_val == val)
+		return;
+
+	memset(shark->transfer_buffer, 0, TB_LEN);
+	shark->transfer_buffer[0] = 0xc0; /* Write shift register command */
+	for (i = 0; i < 4; i++)
+		shark->transfer_buffer[i] |= (val >> (24 - i * 8)) & 0xff;
+
+	res = usb_interrupt_msg(shark->usbdev,
+				usb_sndintpipe(shark->usbdev, SHARK_OUT_EP),
+				shark->transfer_buffer, TB_LEN,
+				&actual_len, 1000);
+	if (res >= 0)
+		shark->last_val = val;
+	else
+		v4l2_err(&shark->v4l2_dev, "set-freq error: %d\n", res);
+}
+
+static u32 shark_read_val(struct snd_tea575x *tea)
+{
+	struct shark_device *shark = tea->private_data;
+	int i, res, actual_len;
+	u32 val = 0;
+
+	memset(shark->transfer_buffer, 0, TB_LEN);
+	shark->transfer_buffer[0] = 0x80;
+	res = usb_interrupt_msg(shark->usbdev,
+				usb_sndintpipe(shark->usbdev, SHARK_OUT_EP),
+				shark->transfer_buffer, TB_LEN,
+				&actual_len, 1000);
+	if (res < 0) {
+		v4l2_err(&shark->v4l2_dev, "request-status error: %d\n", res);
+		return shark->last_val;
+	}
+
+	res = usb_interrupt_msg(shark->usbdev,
+				usb_rcvintpipe(shark->usbdev, SHARK_IN_EP),
+				shark->transfer_buffer, TB_LEN,
+				&actual_len, 1000);
+	if (res < 0) {
+		v4l2_err(&shark->v4l2_dev, "get-status error: %d\n", res);
+		return shark->last_val;
+	}
+
+	for (i = 0; i < 4; i++)
+		val |= shark->transfer_buffer[i] << (24 - i * 8);
+
+	shark->last_val = val;
+
+	/*
+	 * The shark does not allow actually reading the stereo / mono pin :(
+	 * So assume that when we're tuned to an FM station and mono has not
+	 * been requested, that we're receiving stereo.
+	 */
+	if (((val & TEA575X_BIT_BAND_MASK) == TEA575X_BIT_BAND_FM) &&
+	    !(val & TEA575X_BIT_MONO))
+		shark->tea.stereo = true;
+	else
+		shark->tea.stereo = false;
+
+	return val;
+}
+
+static struct snd_tea575x_ops shark_tea_ops = {
+	.write_val = shark_write_val,
+	.read_val  = shark_read_val,
+};
+
+static void shark_led_work(struct work_struct *work)
+{
+	struct shark_device *shark =
+		container_of(work, struct shark_device, led_work);
+	int i, res, brightness, actual_len;
+
+	/*
+	 * We use the v4l2_dev lock and registered bit to ensure the device
+	 * does not get unplugged and unreffed while we're running.
+	 */
+	mutex_lock(&shark->tea.mutex);
+	if (!video_is_registered(&shark->tea.vd))
+		goto leave;
+
+	for (i = 0; i < 3; i++) {
+		if (!test_and_clear_bit(i, &shark->brightness_new))
+			continue;
+
+		brightness = atomic_read(&shark->brightness[i]);
+		memset(shark->transfer_buffer, 0, TB_LEN);
+		if (i != RED_LED) {
+			shark->transfer_buffer[0] = 0xA0 + i;
+			shark->transfer_buffer[1] = brightness;
+		} else
+			shark->transfer_buffer[0] = brightness ? 0xA9 : 0xA8;
+		res = usb_interrupt_msg(shark->usbdev,
+					usb_sndintpipe(shark->usbdev, 0x05),
+					shark->transfer_buffer, TB_LEN,
+					&actual_len, 1000);
+		if (res < 0)
+			v4l2_err(&shark->v4l2_dev, "set LED %s error: %d\n",
+				 shark->led_names[i], res);
+	}
+leave:
+	mutex_unlock(&shark->tea.mutex);
+}
+
+static void shark_led_set_blue(struct led_classdev *led_cdev,
+			       enum led_brightness value)
+{
+	struct shark_device *shark =
+		container_of(led_cdev, struct shark_device, leds[BLUE_LED]);
+
+	atomic_set(&shark->brightness[BLUE_LED], value);
+	set_bit(BLUE_LED, &shark->brightness_new);
+	schedule_work(&shark->led_work);
+}
+
+static void shark_led_set_blue_pulse(struct led_classdev *led_cdev,
+				     enum led_brightness value)
+{
+	struct shark_device *shark = container_of(led_cdev,
+				struct shark_device, leds[BLUE_PULSE_LED]);
+
+	atomic_set(&shark->brightness[BLUE_PULSE_LED], 256 - value);
+	set_bit(BLUE_PULSE_LED, &shark->brightness_new);
+	schedule_work(&shark->led_work);
+}
+
+static void shark_led_set_red(struct led_classdev *led_cdev,
+			      enum led_brightness value)
+{
+	struct shark_device *shark =
+		container_of(led_cdev, struct shark_device, leds[RED_LED]);
+
+	atomic_set(&shark->brightness[RED_LED], value);
+	set_bit(RED_LED, &shark->brightness_new);
+	schedule_work(&shark->led_work);
+}
+
+static void usb_shark_disconnect(struct usb_interface *intf)
+{
+	struct v4l2_device *v4l2_dev = usb_get_intfdata(intf);
+	struct shark_device *shark = v4l2_dev_to_shark(v4l2_dev);
+	int i;
+
+	mutex_lock(&shark->tea.mutex);
+	v4l2_device_disconnect(&shark->v4l2_dev);
+	snd_tea575x_exit(&shark->tea);
+	mutex_unlock(&shark->tea.mutex);
+
+	for (i = 0; i < NO_LEDS; i++)
+		led_classdev_unregister(&shark->leds[i]);
+
+	v4l2_device_put(&shark->v4l2_dev);
+}
+
+static void usb_shark_release(struct v4l2_device *v4l2_dev)
+{
+	struct shark_device *shark = v4l2_dev_to_shark(v4l2_dev);
+
+	cancel_work_sync(&shark->led_work);
+	v4l2_device_unregister(&shark->v4l2_dev);
+	kfree(shark->transfer_buffer);
+	kfree(shark);
+}
+
+static int usb_shark_probe(struct usb_interface *intf,
+			   const struct usb_device_id *id)
+{
+	struct shark_device *shark;
+	int i, retval = -ENOMEM;
+
+	shark = kzalloc(sizeof(struct shark_device), GFP_KERNEL);
+	if (!shark)
+		return retval;
+
+	shark->transfer_buffer = kmalloc(TB_LEN, GFP_KERNEL);
+	if (!shark->transfer_buffer)
+		goto err_alloc_buffer;
+
+	/*
+	 * Work around a bug in usbhid/hid-core.c, where it leaves a dangling
+	 * pointer in intfdata causing v4l2-device.c to not set it. Which
+	 * results in usb_shark_disconnect() referencing the dangling pointer
+	 *
+	 * REMOVE (as soon as the above bug is fixed, patch submitted)
+	 */
+	usb_set_intfdata(intf, NULL);
+
+	shark->v4l2_dev.release = usb_shark_release;
+	v4l2_device_set_name(&shark->v4l2_dev, DRV_NAME, &shark_instance);
+	retval = v4l2_device_register(&intf->dev, &shark->v4l2_dev);
+	if (retval) {
+		v4l2_err(&shark->v4l2_dev, "couldn't register v4l2_device\n");
+		goto err_reg_dev;
+	}
+
+	shark->usbdev = interface_to_usbdev(intf);
+	shark->tea.v4l2_dev = &shark->v4l2_dev;
+	shark->tea.private_data = shark;
+	shark->tea.radio_nr = -1;
+	shark->tea.ops = &shark_tea_ops;
+	shark->tea.cannot_mute = true;
+	strlcpy(shark->tea.card, "Griffin radioSHARK",
+		sizeof(shark->tea.card));
+	usb_make_path(shark->usbdev, shark->tea.bus_info,
+		sizeof(shark->tea.bus_info));
+
+	retval = snd_tea575x_init(&shark->tea, THIS_MODULE);
+	if (retval) {
+		v4l2_err(&shark->v4l2_dev, "couldn't init tea5757\n");
+		goto err_init_tea;
+	}
+
+	INIT_WORK(&shark->led_work, shark_led_work);
+	for (i = 0; i < NO_LEDS; i++) {
+		shark->leds[i] = shark_led_templates[i];
+		snprintf(shark->led_names[i], sizeof(shark->led_names[0]),
+			 shark->leds[i].name, shark->v4l2_dev.name);
+		shark->leds[i].name = shark->led_names[i];
+		/*
+		 * We don't fail the probe if we fail to register the leds,
+		 * because once we've called snd_tea575x_init, the /dev/radio0
+		 * node may be opened from userspace holding a reference to us!
+		 *
+		 * Note we cannot register the leds first instead as
+		 * shark_led_work depends on the v4l2 mutex and registered bit.
+		 */
+		retval = led_classdev_register(&intf->dev, &shark->leds[i]);
+		if (retval)
+			v4l2_err(&shark->v4l2_dev,
+				 "couldn't register led: %s\n",
+				 shark->led_names[i]);
+	}
+
+	return 0;
+
+err_init_tea:
+	v4l2_device_unregister(&shark->v4l2_dev);
+err_reg_dev:
+	kfree(shark->transfer_buffer);
+err_alloc_buffer:
+	kfree(shark);
+
+	return retval;
+}
+
+/* Specify the bcdDevice value, as the radioSHARK and radioSHARK2 share ids */
+static struct usb_device_id usb_shark_device_table[] = {
+	{ .match_flags = USB_DEVICE_ID_MATCH_DEVICE_AND_VERSION |
+			 USB_DEVICE_ID_MATCH_INT_CLASS,
+	  .idVendor     = 0x077d,
+	  .idProduct    = 0x627a,
+	  .bcdDevice_lo = 0x0001,
+	  .bcdDevice_hi = 0x0001,
+	  .bInterfaceClass = 3,
+	},
+	{ }
+};
+MODULE_DEVICE_TABLE(usb, usb_shark_device_table);
+
+static struct usb_driver usb_shark_driver = {
+	.name			= DRV_NAME,
+	.probe			= usb_shark_probe,
+	.disconnect		= usb_shark_disconnect,
+	.id_table		= usb_shark_device_table,
+};
+module_usb_driver(usb_shark_driver);
