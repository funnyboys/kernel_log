commit c0decac19da3906d9b66291e57b7759489e1170f
Author: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
Date:   Mon Sep 10 08:19:14 2018 -0400

    media: use strscpy() instead of strlcpy()
    
    The implementation of strscpy() is more robust and safer.
    
    That's now the recommended way to copy NUL terminated strings.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Acked-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/radio/radio-shark2.c b/drivers/media/radio/radio-shark2.c
index 4d1a4b3d669c..d150f12382c6 100644
--- a/drivers/media/radio/radio-shark2.c
+++ b/drivers/media/radio/radio-shark2.c
@@ -310,7 +310,7 @@ static int usb_shark_probe(struct usb_interface *intf,
 	shark->tea.ops = &shark_tea_ops;
 	shark->tea.has_am = true;
 	shark->tea.write_before_read = true;
-	strlcpy(shark->tea.card, "Griffin radioSHARK2",
+	strscpy(shark->tea.card, "Griffin radioSHARK2",
 		sizeof(shark->tea.card));
 	usb_make_path(shark->usbdev, shark->tea.bus_info,
 		sizeof(shark->tea.bus_info));

commit 1ab2234eefe5c6faa7d49ff5d2f21ac4204a8ca8
Author: Arvind Yadav <arvind.yadav.cs@gmail.com>
Date:   Sun Aug 13 04:54:45 2017 -0400

    media: radio: constify usb_device_id
    
    usb_device_id are not supposed to change at runtime. All functions
    working with usb_device_id provided by <linux/usb.h> work with
    const usb_device_id. So mark the non-const structs as const.
    
    Signed-off-by: Arvind Yadav <arvind.yadav.cs@gmail.com>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/radio/radio-shark2.c b/drivers/media/radio/radio-shark2.c
index b50638ec5f09..4d1a4b3d669c 100644
--- a/drivers/media/radio/radio-shark2.c
+++ b/drivers/media/radio/radio-shark2.c
@@ -358,7 +358,7 @@ static int usb_shark_resume(struct usb_interface *intf)
 #endif
 
 /* Specify the bcdDevice value, as the radioSHARK and radioSHARK2 share ids */
-static struct usb_device_id usb_shark_device_table[] = {
+static const struct usb_device_id usb_shark_device_table[] = {
 	{ .match_flags = USB_DEVICE_ID_MATCH_DEVICE_AND_VERSION |
 			 USB_DEVICE_ID_MATCH_INT_CLASS,
 	  .idVendor     = 0x077d,

commit bcb63314e2c23f1ed622418b65f9409512659c73
Author: Sakari Ailus <sakari.ailus@linux.intel.com>
Date:   Fri Oct 28 09:31:20 2016 -0200

    [media] media: Drop FSF's postal address from the source code files
    
    Drop the FSF's postal address from the source code files that typically
    contain mostly the license text. Of the 628 removed instances, 578 are
    outdated.
    
    The patch has been created with the following command without manual edits:
    
    git grep -l "675 Mass Ave\|59 Temple Place\|51 Franklin St" -- \
            drivers/media/ include/media|while read i; do i=$i perl -e '
    open(F,"< $ENV{i}");
    $a=join("", <F>);
    $a =~ s/[ \t]*\*\n.*You should.*\n.*along with.*\n.*(\n.*USA.*$)?\n//m
            && $a =~ s/(^.*)Or, (point your browser to) /$1To obtain the license, $2\n$1/m;
    close(F);
    open(F, "> $ENV{i}");
    print F $a;
    close(F);'; done
    
    Signed-off-by: Sakari Ailus <sakari.ailus@linux.intel.com>

diff --git a/drivers/media/radio/radio-shark2.c b/drivers/media/radio/radio-shark2.c
index 0e65a85d52c6..b50638ec5f09 100644
--- a/drivers/media/radio/radio-shark2.c
+++ b/drivers/media/radio/radio-shark2.c
@@ -19,10 +19,6 @@
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
  */
 
 #include <linux/init.h>

commit 18a8560cbd627c96477f8f44513e3744d84aced8
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Fri Nov 13 09:38:32 2015 -0200

    [media] radio-shark2: constify radio_tea5777_ops structures
    
    The radio_tea5777_ops structure is never modified, so declare it as const.
    
    Done with the help of Coccinelle.
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/radio/radio-shark2.c b/drivers/media/radio/radio-shark2.c
index 8654e0dc5c95..0e65a85d52c6 100644
--- a/drivers/media/radio/radio-shark2.c
+++ b/drivers/media/radio/radio-shark2.c
@@ -137,7 +137,7 @@ static int shark_read_reg(struct radio_tea5777 *tea, u32 *reg_ret)
 	return 0;
 }
 
-static struct radio_tea5777_ops shark_tea_ops = {
+static const struct radio_tea5777_ops shark_tea_ops = {
 	.write_reg = shark_write_reg,
 	.read_reg  = shark_read_reg,
 };

commit c7223f8f66b685f325879a88a6c955ebf46a8a36
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Sun Nov 17 10:48:29 2013 -0300

    [media] radio-shark2: Mark shark_resume_leds() inline to kill compiler warning
    
    This mirrors the patch to the radio-shark driver by Geert Uytterhoeven.
    If SHARK_USE_LEDS=1, but CONFIG_PM=n:
    drivers/media/radio/radio-shark2.c:240: warning: ‘shark_resume_leds’ defined but not used
    Instead of making the #ifdef logic even more complicated (there are already
    two definitions of shark_resume_leds()), mark shark_resume_leds() inline to
    kill the compiler warning. shark_resume_leds() is small and it has only one
    caller.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/drivers/media/radio/radio-shark2.c b/drivers/media/radio/radio-shark2.c
index d86d90dab8bf..8654e0dc5c95 100644
--- a/drivers/media/radio/radio-shark2.c
+++ b/drivers/media/radio/radio-shark2.c
@@ -237,8 +237,7 @@ static void shark_unregister_leds(struct shark_device *shark)
 	cancel_work_sync(&shark->led_work);
 }
 
-#ifdef CONFIG_PM
-static void shark_resume_leds(struct shark_device *shark)
+static inline void shark_resume_leds(struct shark_device *shark)
 {
 	int i;
 
@@ -247,7 +246,6 @@ static void shark_resume_leds(struct shark_device *shark)
 
 	schedule_work(&shark->led_work);
 }
-#endif
 #else
 static int shark_register_leds(struct shark_device *shark, struct device *dev)
 {

commit c5b0b3cb8a2b6637d652cae73f00761a1bd6e66e
Author: Mauro Carvalho Chehab <m.chehab@samsung.com>
Date:   Fri Nov 1 12:44:54 2013 -0300

    [media] radio-shark: remove a warning when CONFIG_PM is not defined
    
    On alpha, allyesconfig doesn't have CONFIG_PM, and produces the following warnings:
            drivers/media/radio/radio-shark.c:274:13: warning: 'shark_resume_leds' defined but not used [-Wunused-function]
            drivers/media/radio/radio-shark2.c:240:13: warning: 'shark_resume_leds' defined but not used [-Wunused-function]
    That's because those functions are used only at device resume.
    
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>
    Reviewed-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/drivers/media/radio/radio-shark2.c b/drivers/media/radio/radio-shark2.c
index 9fb669721e66..d86d90dab8bf 100644
--- a/drivers/media/radio/radio-shark2.c
+++ b/drivers/media/radio/radio-shark2.c
@@ -237,6 +237,7 @@ static void shark_unregister_leds(struct shark_device *shark)
 	cancel_work_sync(&shark->led_work);
 }
 
+#ifdef CONFIG_PM
 static void shark_resume_leds(struct shark_device *shark)
 {
 	int i;
@@ -246,6 +247,7 @@ static void shark_resume_leds(struct shark_device *shark)
 
 	schedule_work(&shark->led_work);
 }
+#endif
 #else
 static int shark_register_leds(struct shark_device *shark, struct device *dev)
 {

commit 0bb9121c8882f015328084defdf8647df2fef50d
Author: Paul Bolle <pebolle@tiscali.nl>
Date:   Tue Mar 26 09:45:38 2013 +0100

    radio-shark: Fix printk "CONFIG_LED_CLASS"
    
    Signed-off-by: Paul Bolle <pebolle@tiscali.nl>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/media/radio/radio-shark2.c b/drivers/media/radio/radio-shark2.c
index ef65ebbd5364..9fb669721e66 100644
--- a/drivers/media/radio/radio-shark2.c
+++ b/drivers/media/radio/radio-shark2.c
@@ -250,7 +250,7 @@ static void shark_resume_leds(struct shark_device *shark)
 static int shark_register_leds(struct shark_device *shark, struct device *dev)
 {
 	v4l2_warn(&shark->v4l2_dev,
-		  "CONFIG_LED_CLASS not enabled, LED support disabled\n");
+		  "CONFIG_LEDS_CLASS not enabled, LED support disabled\n");
 	return 0;
 }
 static inline void shark_unregister_leds(struct shark_device *shark) { }

commit 1f71927ed51e9125eb7a3d4aed54f68dd41f2c34
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Thu Sep 13 17:37:40 2012 -0300

    [media] shark,shark2: declare resume/suspend functions as static
    
    drivers/media/radio/shark2.o: In function `_GLOBAL__sub_I_65535_0_usb_shark_suspend':
    drivers/media/radio/radio-shark2.c:344: multiple definition of `usb_shark_suspend'
    drivers/media/radio/radio-shark.o:/home/v4l/v4l/patchwork/drivers/media/radio/radio-shark.c:379: first defined here
    drivers/media/radio/shark2.o: In function `usb_shark_resume':
    drivers/media/radio/radio-shark2.c:349: multiple definition of `usb_shark_resume'
    drivers/media/radio/radio-shark.o:/home/v4l/v4l/patchwork/drivers/media/radio/radio-shark.c:384: first defined here
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-shark2.c b/drivers/media/radio/radio-shark2.c
index 9740c760b73c..ef65ebbd5364 100644
--- a/drivers/media/radio/radio-shark2.c
+++ b/drivers/media/radio/radio-shark2.c
@@ -340,12 +340,12 @@ static int usb_shark_probe(struct usb_interface *intf,
 }
 
 #ifdef CONFIG_PM
-int usb_shark_suspend(struct usb_interface *intf, pm_message_t message)
+static int usb_shark_suspend(struct usb_interface *intf, pm_message_t message)
 {
 	return 0;
 }
 
-int usb_shark_resume(struct usb_interface *intf)
+static int usb_shark_resume(struct usb_interface *intf)
 {
 	struct v4l2_device *v4l2_dev = usb_get_intfdata(intf);
 	struct shark_device *shark = v4l2_dev_to_shark(v4l2_dev);

commit d1f280d615a0f0b723dac5a2cd3f2f7f18bca4fa
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Sat Aug 11 12:37:13 2012 -0300

    [media] radio-shark2: Add support for suspend & resume
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-shark2.c b/drivers/media/radio/radio-shark2.c
index 7c730a0277ab..9740c760b73c 100644
--- a/drivers/media/radio/radio-shark2.c
+++ b/drivers/media/radio/radio-shark2.c
@@ -209,6 +209,7 @@ static int shark_register_leds(struct shark_device *shark, struct device *dev)
 {
 	int i, retval;
 
+	atomic_set(&shark->brightness[BLUE_LED], 127);
 	INIT_WORK(&shark->led_work, shark_led_work);
 	for (i = 0; i < NO_LEDS; i++) {
 		shark->leds[i] = shark_led_templates[i];
@@ -235,6 +236,16 @@ static void shark_unregister_leds(struct shark_device *shark)
 
 	cancel_work_sync(&shark->led_work);
 }
+
+static void shark_resume_leds(struct shark_device *shark)
+{
+	int i;
+
+	for (i = 0; i < NO_LEDS; i++)
+		set_bit(i, &shark->brightness_new);
+
+	schedule_work(&shark->led_work);
+}
 #else
 static int shark_register_leds(struct shark_device *shark, struct device *dev)
 {
@@ -243,6 +254,7 @@ static int shark_register_leds(struct shark_device *shark, struct device *dev)
 	return 0;
 }
 static inline void shark_unregister_leds(struct shark_device *shark) { }
+static inline void shark_resume_leds(struct shark_device *shark) { }
 #endif
 
 static void usb_shark_disconnect(struct usb_interface *intf)
@@ -327,6 +339,28 @@ static int usb_shark_probe(struct usb_interface *intf,
 	return retval;
 }
 
+#ifdef CONFIG_PM
+int usb_shark_suspend(struct usb_interface *intf, pm_message_t message)
+{
+	return 0;
+}
+
+int usb_shark_resume(struct usb_interface *intf)
+{
+	struct v4l2_device *v4l2_dev = usb_get_intfdata(intf);
+	struct shark_device *shark = v4l2_dev_to_shark(v4l2_dev);
+	int ret;
+
+	mutex_lock(&shark->tea.mutex);
+	ret = radio_tea5777_set_freq(&shark->tea);
+	mutex_unlock(&shark->tea.mutex);
+
+	shark_resume_leds(shark);
+
+	return ret;
+}
+#endif
+
 /* Specify the bcdDevice value, as the radioSHARK and radioSHARK2 share ids */
 static struct usb_device_id usb_shark_device_table[] = {
 	{ .match_flags = USB_DEVICE_ID_MATCH_DEVICE_AND_VERSION |
@@ -346,5 +380,10 @@ static struct usb_driver usb_shark_driver = {
 	.probe			= usb_shark_probe,
 	.disconnect		= usb_shark_disconnect,
 	.id_table		= usb_shark_device_table,
+#ifdef CONFIG_PM
+	.suspend		= usb_shark_suspend,
+	.resume			= usb_shark_resume,
+	.reset_resume		= usb_shark_resume,
+#endif
 };
 module_usb_driver(usb_shark_driver);

commit 79e8c7bebb467bbc3f2514d75bba669a3f354324
Merge: a47b6118e134 fea7a08acb13
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Fri Aug 24 11:25:10 2012 -0300

    Merge tag 'v3.6-rc3' into staging/for_v3.7
    
    Linux 3.6-rc3
    
    * tag 'v3.6-rc3': (764 commits)
      Linux 3.6-rc3
      task_work: add a scheduling point in task_work_run()
      fs: fix fs/namei.c kernel-doc warnings
      eventpoll: use-after-possible-free in epoll_create1()
      vfio: grab vfio_device reference *before* exposing the sucker via fd_install()
      vfio: get rid of vfio_device_put()/vfio_group_get_device* races
      vfio: get rid of open-coding kref_put_mutex
      introduce kref_put_mutex()
      vfio: don't dereference after kfree...
      fbcon: fix race condition between console lock and cursor timer (v1.1)
      mm: compaction: Abort async compaction if locks are contended or taking too long
      mm: have order > 0 compaction start near a pageblock with free pages
      rapidio/tsi721: fix unused variable compiler warning
      rapidio/tsi721: fix inbound doorbell interrupt handling
      drivers/rtc/rtc-rs5c348.c: fix hour decoding in 12-hour mode
      mm: correct page->pfmemalloc to fix deactivate_slab regression
      drivers/rtc/rtc-pcf2123.c: initialize dynamic sysfs attributes
      mm/compaction.c: fix deferring compaction mistake
      drivers/misc/sgi-xp/xpc_uv.c: SGI XPC fails to load when cpu 0 is out of IRQ resources
      string: do not export memweight() to userspace
      ...

commit 9697b54f3d3cf65de461baff5afd42d755608087
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue Aug 7 12:43:06 2012 -0300

    [media] radio-shark2: use %*ph to print small buffers
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-shark2.c b/drivers/media/radio/radio-shark2.c
index b9575de3e7e8..90aecfb0ff96 100644
--- a/drivers/media/radio/radio-shark2.c
+++ b/drivers/media/radio/radio-shark2.c
@@ -100,12 +100,8 @@ static int shark_write_reg(struct radio_tea5777 *tea, u64 reg)
 	for (i = 0; i < 6; i++)
 		shark->transfer_buffer[i + 1] = (reg >> (40 - i * 8)) & 0xff;
 
-	v4l2_dbg(1, debug, tea->v4l2_dev,
-		 "shark2-write: %02x %02x %02x %02x %02x %02x %02x\n",
-		 shark->transfer_buffer[0], shark->transfer_buffer[1],
-		 shark->transfer_buffer[2], shark->transfer_buffer[3],
-		 shark->transfer_buffer[4], shark->transfer_buffer[5],
-		 shark->transfer_buffer[6]);
+	v4l2_dbg(1, debug, tea->v4l2_dev, "shark2-write: %*ph\n",
+		 7, shark->transfer_buffer);
 
 	res = usb_interrupt_msg(shark->usbdev,
 				usb_sndintpipe(shark->usbdev, SHARK_OUT_EP),
@@ -148,9 +144,8 @@ static int shark_read_reg(struct radio_tea5777 *tea, u32 *reg_ret)
 	for (i = 0; i < 3; i++)
 		reg |= shark->transfer_buffer[i] << (16 - i * 8);
 
-	v4l2_dbg(1, debug, tea->v4l2_dev, "shark2-read: %02x %02x %02x\n",
-		 shark->transfer_buffer[0], shark->transfer_buffer[1],
-		 shark->transfer_buffer[2]);
+	v4l2_dbg(1, debug, tea->v4l2_dev, "shark2-read: %*ph\n",
+		 3, shark->transfer_buffer);
 
 	*reg_ret = reg;
 	return 0;

commit be0c44fb480fe43fe8794ec4bff0b0e7e0b50c72
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Sat Aug 11 06:34:55 2012 -0300

    [media] radio-shark2: Only compile led support when CONFIG_LED_CLASS is set
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-shark2.c b/drivers/media/radio/radio-shark2.c
index 217483ca1b18..7b4efdfaae28 100644
--- a/drivers/media/radio/radio-shark2.c
+++ b/drivers/media/radio/radio-shark2.c
@@ -35,6 +35,11 @@
 #include <media/v4l2-device.h>
 #include "radio-tea5777.h"
 
+#if defined(CONFIG_LEDS_CLASS) || \
+    (defined(CONFIG_LEDS_CLASS_MODULE) && defined(CONFIG_RADIO_SHARK2_MODULE))
+#define SHARK_USE_LEDS 1
+#endif
+
 MODULE_AUTHOR("Hans de Goede <hdegoede@redhat.com>");
 MODULE_DESCRIPTION("Griffin radioSHARK2, USB radio receiver driver");
 MODULE_LICENSE("GPL");
@@ -43,7 +48,6 @@ static int debug;
 module_param(debug, int, 0);
 MODULE_PARM_DESC(debug, "Debug level (0-1)");
 
-
 #define SHARK_IN_EP		0x83
 #define SHARK_OUT_EP		0x05
 
@@ -54,36 +58,18 @@ MODULE_PARM_DESC(debug, "Debug level (0-1)");
 
 enum { BLUE_LED, RED_LED, NO_LEDS };
 
-static void shark_led_set_blue(struct led_classdev *led_cdev,
-			       enum led_brightness value);
-static void shark_led_set_red(struct led_classdev *led_cdev,
-			      enum led_brightness value);
-
-static const struct led_classdev shark_led_templates[NO_LEDS] = {
-	[BLUE_LED] = {
-		.name		= "%s:blue:",
-		.brightness	= LED_OFF,
-		.max_brightness = 127,
-		.brightness_set = shark_led_set_blue,
-	},
-	[RED_LED] = {
-		.name		= "%s:red:",
-		.brightness	= LED_OFF,
-		.max_brightness = 1,
-		.brightness_set = shark_led_set_red,
-	},
-};
-
 struct shark_device {
 	struct usb_device *usbdev;
 	struct v4l2_device v4l2_dev;
 	struct radio_tea5777 tea;
 
+#ifdef SHARK_USE_LEDS
 	struct work_struct led_work;
 	struct led_classdev leds[NO_LEDS];
 	char led_names[NO_LEDS][32];
 	atomic_t brightness[NO_LEDS];
 	unsigned long brightness_new;
+#endif
 
 	u8 *transfer_buffer;
 };
@@ -161,6 +147,7 @@ static struct radio_tea5777_ops shark_tea_ops = {
 	.read_reg  = shark_read_reg,
 };
 
+#ifdef SHARK_USE_LEDS
 static void shark_led_work(struct work_struct *work)
 {
 	struct shark_device *shark =
@@ -208,21 +195,72 @@ static void shark_led_set_red(struct led_classdev *led_cdev,
 	schedule_work(&shark->led_work);
 }
 
+static const struct led_classdev shark_led_templates[NO_LEDS] = {
+	[BLUE_LED] = {
+		.name		= "%s:blue:",
+		.brightness	= LED_OFF,
+		.max_brightness = 127,
+		.brightness_set = shark_led_set_blue,
+	},
+	[RED_LED] = {
+		.name		= "%s:red:",
+		.brightness	= LED_OFF,
+		.max_brightness = 1,
+		.brightness_set = shark_led_set_red,
+	},
+};
+
+static int shark_register_leds(struct shark_device *shark, struct device *dev)
+{
+	int i, retval;
+
+	INIT_WORK(&shark->led_work, shark_led_work);
+	for (i = 0; i < NO_LEDS; i++) {
+		shark->leds[i] = shark_led_templates[i];
+		snprintf(shark->led_names[i], sizeof(shark->led_names[0]),
+			 shark->leds[i].name, shark->v4l2_dev.name);
+		shark->leds[i].name = shark->led_names[i];
+		retval = led_classdev_register(dev, &shark->leds[i]);
+		if (retval) {
+			v4l2_err(&shark->v4l2_dev,
+				 "couldn't register led: %s\n",
+				 shark->led_names[i]);
+			return retval;
+		}
+	}
+	return 0;
+}
+
+static void shark_unregister_leds(struct shark_device *shark)
+{
+	int i;
+
+	for (i = 0; i < NO_LEDS; i++)
+		led_classdev_unregister(&shark->leds[i]);
+
+	cancel_work_sync(&shark->led_work);
+}
+#else
+static int shark_register_leds(struct shark_device *shark, struct device *dev)
+{
+	v4l2_warn(&shark->v4l2_dev,
+		  "CONFIG_LED_CLASS not enabled, LED support disabled\n");
+	return 0;
+}
+static inline void shark_unregister_leds(struct shark_device *shark) { }
+#endif
+
 static void usb_shark_disconnect(struct usb_interface *intf)
 {
 	struct v4l2_device *v4l2_dev = usb_get_intfdata(intf);
 	struct shark_device *shark = v4l2_dev_to_shark(v4l2_dev);
-	int i;
 
 	mutex_lock(&shark->tea.mutex);
 	v4l2_device_disconnect(&shark->v4l2_dev);
 	radio_tea5777_exit(&shark->tea);
 	mutex_unlock(&shark->tea.mutex);
 
-	for (i = 0; i < NO_LEDS; i++)
-		led_classdev_unregister(&shark->leds[i]);
-
-	cancel_work_sync(&shark->led_work);
+	shark_unregister_leds(shark);
 
 	v4l2_device_put(&shark->v4l2_dev);
 }
@@ -240,7 +278,7 @@ static int usb_shark_probe(struct usb_interface *intf,
 			   const struct usb_device_id *id)
 {
 	struct shark_device *shark;
-	int i, retval = -ENOMEM;
+	int retval = -ENOMEM;
 
 	shark = kzalloc(sizeof(struct shark_device), GFP_KERNEL);
 	if (!shark)
@@ -250,8 +288,13 @@ static int usb_shark_probe(struct usb_interface *intf,
 	if (!shark->transfer_buffer)
 		goto err_alloc_buffer;
 
-	shark->v4l2_dev.release = usb_shark_release;
 	v4l2_device_set_name(&shark->v4l2_dev, DRV_NAME, &shark_instance);
+
+	retval = shark_register_leds(shark, &intf->dev);
+	if (retval)
+		goto err_reg_leds;
+
+	shark->v4l2_dev.release = usb_shark_release;
 	retval = v4l2_device_register(&intf->dev, &shark->v4l2_dev);
 	if (retval) {
 		v4l2_err(&shark->v4l2_dev, "couldn't register v4l2_device\n");
@@ -275,32 +318,13 @@ static int usb_shark_probe(struct usb_interface *intf,
 		goto err_init_tea;
 	}
 
-	INIT_WORK(&shark->led_work, shark_led_work);
-	for (i = 0; i < NO_LEDS; i++) {
-		shark->leds[i] = shark_led_templates[i];
-		snprintf(shark->led_names[i], sizeof(shark->led_names[0]),
-			 shark->leds[i].name, shark->v4l2_dev.name);
-		shark->leds[i].name = shark->led_names[i];
-		/*
-		 * We don't fail the probe if we fail to register the leds,
-		 * because once we've called radio_tea5777_init, the /dev/radio0
-		 * node may be opened from userspace holding a reference to us!
-		 *
-		 * Note we cannot register the leds first instead as
-		 * shark_led_work depends on the v4l2 mutex and registered bit.
-		 */
-		retval = led_classdev_register(&intf->dev, &shark->leds[i]);
-		if (retval)
-			v4l2_err(&shark->v4l2_dev,
-				 "couldn't register led: %s\n",
-				 shark->led_names[i]);
-	}
-
 	return 0;
 
 err_init_tea:
 	v4l2_device_unregister(&shark->v4l2_dev);
 err_reg_dev:
+	shark_unregister_leds(shark);
+err_reg_leds:
 	kfree(shark->transfer_buffer);
 err_alloc_buffer:
 	kfree(shark);

commit cfc1b2a06f87f562da2ffb9f8d1ae4203d9bfbfa
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Sat Aug 11 06:34:53 2012 -0300

    [media] radio-shark*: Call cancel_work_sync from disconnect rather then release
    
    This removes the need for shark_led_work to take the v4l2 lock.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-shark2.c b/drivers/media/radio/radio-shark2.c
index fc0289d5da4e..217483ca1b18 100644
--- a/drivers/media/radio/radio-shark2.c
+++ b/drivers/media/radio/radio-shark2.c
@@ -166,13 +166,6 @@ static void shark_led_work(struct work_struct *work)
 	struct shark_device *shark =
 		container_of(work, struct shark_device, led_work);
 	int i, res, brightness, actual_len;
-	/*
-	 * We use the v4l2_dev lock and registered bit to ensure the device
-	 * does not get unplugged and unreffed while we're running.
-	 */
-	mutex_lock(&shark->tea.mutex);
-	if (!video_is_registered(&shark->tea.vd))
-		goto leave;
 
 	for (i = 0; i < 2; i++) {
 		if (!test_and_clear_bit(i, &shark->brightness_new))
@@ -191,8 +184,6 @@ static void shark_led_work(struct work_struct *work)
 			v4l2_err(&shark->v4l2_dev, "set LED %s error: %d\n",
 				 shark->led_names[i], res);
 	}
-leave:
-	mutex_unlock(&shark->tea.mutex);
 }
 
 static void shark_led_set_blue(struct led_classdev *led_cdev,
@@ -231,6 +222,8 @@ static void usb_shark_disconnect(struct usb_interface *intf)
 	for (i = 0; i < NO_LEDS; i++)
 		led_classdev_unregister(&shark->leds[i]);
 
+	cancel_work_sync(&shark->led_work);
+
 	v4l2_device_put(&shark->v4l2_dev);
 }
 
@@ -238,7 +231,6 @@ static void usb_shark_release(struct v4l2_device *v4l2_dev)
 {
 	struct shark_device *shark = v4l2_dev_to_shark(v4l2_dev);
 
-	cancel_work_sync(&shark->led_work);
 	v4l2_device_unregister(&shark->v4l2_dev);
 	kfree(shark->transfer_buffer);
 	kfree(shark);

commit 820ddfa6ca87fc12bf202907b77f635df2098e66
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Sat Aug 11 06:34:52 2012 -0300

    [media] radio-shark*: Remove work-around for dangling pointer in usb intfdata
    
    Recent kernels properly clear the usb intfdata pointer when another
    driver fails to bind (in the radio-shark* case the usbhid driver would try
    to bind first.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-shark2.c b/drivers/media/radio/radio-shark2.c
index b9575de3e7e8..fc0289d5da4e 100644
--- a/drivers/media/radio/radio-shark2.c
+++ b/drivers/media/radio/radio-shark2.c
@@ -258,15 +258,6 @@ static int usb_shark_probe(struct usb_interface *intf,
 	if (!shark->transfer_buffer)
 		goto err_alloc_buffer;
 
-	/*
-	 * Work around a bug in usbhid/hid-core.c, where it leaves a dangling
-	 * pointer in intfdata causing v4l2-device.c to not set it. Which
-	 * results in usb_shark_disconnect() referencing the dangling pointer
-	 *
-	 * REMOVE (as soon as the above bug is fixed, patch submitted)
-	 */
-	usb_set_intfdata(intf, NULL);
-
 	shark->v4l2_dev.release = usb_shark_release;
 	v4l2_device_set_name(&shark->v4l2_dev, DRV_NAME, &shark_instance);
 	retval = v4l2_device_register(&intf->dev, &shark->v4l2_dev);

commit 4faba767c6243b43ad975406fe027be7394e4591
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Sat Jun 23 04:39:58 2012 -0300

    [media] shark2: New driver for the Griffin radioSHARK v2 USB radio receiver
    
    This driver consists of 2 parts, a generic tea5777 driver and a driver
    for the Griffin radioSHARK v2 USB radio receiver, which is the only driver
    using the generic tea5777 for now.
    
    This first version only implements FM support, once the the new
    VIDIOC_ENUM_FREQ_BANDS API is upstream I'll also add AM support.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/radio/radio-shark2.c b/drivers/media/radio/radio-shark2.c
new file mode 100644
index 000000000000..b9575de3e7e8
--- /dev/null
+++ b/drivers/media/radio/radio-shark2.c
@@ -0,0 +1,348 @@
+/*
+ * Linux V4L2 radio driver for the Griffin radioSHARK2 USB radio receiver
+ *
+ * Note the radioSHARK2 offers the audio through a regular USB audio device,
+ * this driver only handles the tuning.
+ *
+ * The info necessary to drive the shark2 was taken from the small userspace
+ * shark2.c program by Hisaaki Shibata, which he kindly placed in the Public
+ * Domain.
+ *
+ * Copyright (c) 2012 Hans de Goede <hdegoede@redhat.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/leds.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/usb.h>
+#include <linux/workqueue.h>
+#include <media/v4l2-device.h>
+#include "radio-tea5777.h"
+
+MODULE_AUTHOR("Hans de Goede <hdegoede@redhat.com>");
+MODULE_DESCRIPTION("Griffin radioSHARK2, USB radio receiver driver");
+MODULE_LICENSE("GPL");
+
+static int debug;
+module_param(debug, int, 0);
+MODULE_PARM_DESC(debug, "Debug level (0-1)");
+
+
+#define SHARK_IN_EP		0x83
+#define SHARK_OUT_EP		0x05
+
+#define TB_LEN 7
+#define DRV_NAME "radioshark2"
+
+#define v4l2_dev_to_shark(d) container_of(d, struct shark_device, v4l2_dev)
+
+enum { BLUE_LED, RED_LED, NO_LEDS };
+
+static void shark_led_set_blue(struct led_classdev *led_cdev,
+			       enum led_brightness value);
+static void shark_led_set_red(struct led_classdev *led_cdev,
+			      enum led_brightness value);
+
+static const struct led_classdev shark_led_templates[NO_LEDS] = {
+	[BLUE_LED] = {
+		.name		= "%s:blue:",
+		.brightness	= LED_OFF,
+		.max_brightness = 127,
+		.brightness_set = shark_led_set_blue,
+	},
+	[RED_LED] = {
+		.name		= "%s:red:",
+		.brightness	= LED_OFF,
+		.max_brightness = 1,
+		.brightness_set = shark_led_set_red,
+	},
+};
+
+struct shark_device {
+	struct usb_device *usbdev;
+	struct v4l2_device v4l2_dev;
+	struct radio_tea5777 tea;
+
+	struct work_struct led_work;
+	struct led_classdev leds[NO_LEDS];
+	char led_names[NO_LEDS][32];
+	atomic_t brightness[NO_LEDS];
+	unsigned long brightness_new;
+
+	u8 *transfer_buffer;
+};
+
+static atomic_t shark_instance = ATOMIC_INIT(0);
+
+static int shark_write_reg(struct radio_tea5777 *tea, u64 reg)
+{
+	struct shark_device *shark = tea->private_data;
+	int i, res, actual_len;
+
+	memset(shark->transfer_buffer, 0, TB_LEN);
+	shark->transfer_buffer[0] = 0x81; /* Write register command */
+	for (i = 0; i < 6; i++)
+		shark->transfer_buffer[i + 1] = (reg >> (40 - i * 8)) & 0xff;
+
+	v4l2_dbg(1, debug, tea->v4l2_dev,
+		 "shark2-write: %02x %02x %02x %02x %02x %02x %02x\n",
+		 shark->transfer_buffer[0], shark->transfer_buffer[1],
+		 shark->transfer_buffer[2], shark->transfer_buffer[3],
+		 shark->transfer_buffer[4], shark->transfer_buffer[5],
+		 shark->transfer_buffer[6]);
+
+	res = usb_interrupt_msg(shark->usbdev,
+				usb_sndintpipe(shark->usbdev, SHARK_OUT_EP),
+				shark->transfer_buffer, TB_LEN,
+				&actual_len, 1000);
+	if (res < 0) {
+		v4l2_err(tea->v4l2_dev, "write error: %d\n", res);
+		return res;
+	}
+
+	return 0;
+}
+
+static int shark_read_reg(struct radio_tea5777 *tea, u32 *reg_ret)
+{
+	struct shark_device *shark = tea->private_data;
+	int i, res, actual_len;
+	u32 reg = 0;
+
+	memset(shark->transfer_buffer, 0, TB_LEN);
+	shark->transfer_buffer[0] = 0x82;
+	res = usb_interrupt_msg(shark->usbdev,
+				usb_sndintpipe(shark->usbdev, SHARK_OUT_EP),
+				shark->transfer_buffer, TB_LEN,
+				&actual_len, 1000);
+	if (res < 0) {
+		v4l2_err(tea->v4l2_dev, "request-read error: %d\n", res);
+		return res;
+	}
+
+	res = usb_interrupt_msg(shark->usbdev,
+				usb_rcvintpipe(shark->usbdev, SHARK_IN_EP),
+				shark->transfer_buffer, TB_LEN,
+				&actual_len, 1000);
+	if (res < 0) {
+		v4l2_err(tea->v4l2_dev, "read error: %d\n", res);
+		return res;
+	}
+
+	for (i = 0; i < 3; i++)
+		reg |= shark->transfer_buffer[i] << (16 - i * 8);
+
+	v4l2_dbg(1, debug, tea->v4l2_dev, "shark2-read: %02x %02x %02x\n",
+		 shark->transfer_buffer[0], shark->transfer_buffer[1],
+		 shark->transfer_buffer[2]);
+
+	*reg_ret = reg;
+	return 0;
+}
+
+static struct radio_tea5777_ops shark_tea_ops = {
+	.write_reg = shark_write_reg,
+	.read_reg  = shark_read_reg,
+};
+
+static void shark_led_work(struct work_struct *work)
+{
+	struct shark_device *shark =
+		container_of(work, struct shark_device, led_work);
+	int i, res, brightness, actual_len;
+	/*
+	 * We use the v4l2_dev lock and registered bit to ensure the device
+	 * does not get unplugged and unreffed while we're running.
+	 */
+	mutex_lock(&shark->tea.mutex);
+	if (!video_is_registered(&shark->tea.vd))
+		goto leave;
+
+	for (i = 0; i < 2; i++) {
+		if (!test_and_clear_bit(i, &shark->brightness_new))
+			continue;
+
+		brightness = atomic_read(&shark->brightness[i]);
+		memset(shark->transfer_buffer, 0, TB_LEN);
+		shark->transfer_buffer[0] = 0x83 + i;
+		shark->transfer_buffer[1] = brightness;
+		res = usb_interrupt_msg(shark->usbdev,
+					usb_sndintpipe(shark->usbdev,
+						       SHARK_OUT_EP),
+					shark->transfer_buffer, TB_LEN,
+					&actual_len, 1000);
+		if (res < 0)
+			v4l2_err(&shark->v4l2_dev, "set LED %s error: %d\n",
+				 shark->led_names[i], res);
+	}
+leave:
+	mutex_unlock(&shark->tea.mutex);
+}
+
+static void shark_led_set_blue(struct led_classdev *led_cdev,
+			       enum led_brightness value)
+{
+	struct shark_device *shark =
+		container_of(led_cdev, struct shark_device, leds[BLUE_LED]);
+
+	atomic_set(&shark->brightness[BLUE_LED], value);
+	set_bit(BLUE_LED, &shark->brightness_new);
+	schedule_work(&shark->led_work);
+}
+
+static void shark_led_set_red(struct led_classdev *led_cdev,
+			      enum led_brightness value)
+{
+	struct shark_device *shark =
+		container_of(led_cdev, struct shark_device, leds[RED_LED]);
+
+	atomic_set(&shark->brightness[RED_LED], value);
+	set_bit(RED_LED, &shark->brightness_new);
+	schedule_work(&shark->led_work);
+}
+
+static void usb_shark_disconnect(struct usb_interface *intf)
+{
+	struct v4l2_device *v4l2_dev = usb_get_intfdata(intf);
+	struct shark_device *shark = v4l2_dev_to_shark(v4l2_dev);
+	int i;
+
+	mutex_lock(&shark->tea.mutex);
+	v4l2_device_disconnect(&shark->v4l2_dev);
+	radio_tea5777_exit(&shark->tea);
+	mutex_unlock(&shark->tea.mutex);
+
+	for (i = 0; i < NO_LEDS; i++)
+		led_classdev_unregister(&shark->leds[i]);
+
+	v4l2_device_put(&shark->v4l2_dev);
+}
+
+static void usb_shark_release(struct v4l2_device *v4l2_dev)
+{
+	struct shark_device *shark = v4l2_dev_to_shark(v4l2_dev);
+
+	cancel_work_sync(&shark->led_work);
+	v4l2_device_unregister(&shark->v4l2_dev);
+	kfree(shark->transfer_buffer);
+	kfree(shark);
+}
+
+static int usb_shark_probe(struct usb_interface *intf,
+			   const struct usb_device_id *id)
+{
+	struct shark_device *shark;
+	int i, retval = -ENOMEM;
+
+	shark = kzalloc(sizeof(struct shark_device), GFP_KERNEL);
+	if (!shark)
+		return retval;
+
+	shark->transfer_buffer = kmalloc(TB_LEN, GFP_KERNEL);
+	if (!shark->transfer_buffer)
+		goto err_alloc_buffer;
+
+	/*
+	 * Work around a bug in usbhid/hid-core.c, where it leaves a dangling
+	 * pointer in intfdata causing v4l2-device.c to not set it. Which
+	 * results in usb_shark_disconnect() referencing the dangling pointer
+	 *
+	 * REMOVE (as soon as the above bug is fixed, patch submitted)
+	 */
+	usb_set_intfdata(intf, NULL);
+
+	shark->v4l2_dev.release = usb_shark_release;
+	v4l2_device_set_name(&shark->v4l2_dev, DRV_NAME, &shark_instance);
+	retval = v4l2_device_register(&intf->dev, &shark->v4l2_dev);
+	if (retval) {
+		v4l2_err(&shark->v4l2_dev, "couldn't register v4l2_device\n");
+		goto err_reg_dev;
+	}
+
+	shark->usbdev = interface_to_usbdev(intf);
+	shark->tea.v4l2_dev = &shark->v4l2_dev;
+	shark->tea.private_data = shark;
+	shark->tea.ops = &shark_tea_ops;
+	shark->tea.has_am = true;
+	shark->tea.write_before_read = true;
+	strlcpy(shark->tea.card, "Griffin radioSHARK2",
+		sizeof(shark->tea.card));
+	usb_make_path(shark->usbdev, shark->tea.bus_info,
+		sizeof(shark->tea.bus_info));
+
+	retval = radio_tea5777_init(&shark->tea, THIS_MODULE);
+	if (retval) {
+		v4l2_err(&shark->v4l2_dev, "couldn't init tea5777\n");
+		goto err_init_tea;
+	}
+
+	INIT_WORK(&shark->led_work, shark_led_work);
+	for (i = 0; i < NO_LEDS; i++) {
+		shark->leds[i] = shark_led_templates[i];
+		snprintf(shark->led_names[i], sizeof(shark->led_names[0]),
+			 shark->leds[i].name, shark->v4l2_dev.name);
+		shark->leds[i].name = shark->led_names[i];
+		/*
+		 * We don't fail the probe if we fail to register the leds,
+		 * because once we've called radio_tea5777_init, the /dev/radio0
+		 * node may be opened from userspace holding a reference to us!
+		 *
+		 * Note we cannot register the leds first instead as
+		 * shark_led_work depends on the v4l2 mutex and registered bit.
+		 */
+		retval = led_classdev_register(&intf->dev, &shark->leds[i]);
+		if (retval)
+			v4l2_err(&shark->v4l2_dev,
+				 "couldn't register led: %s\n",
+				 shark->led_names[i]);
+	}
+
+	return 0;
+
+err_init_tea:
+	v4l2_device_unregister(&shark->v4l2_dev);
+err_reg_dev:
+	kfree(shark->transfer_buffer);
+err_alloc_buffer:
+	kfree(shark);
+
+	return retval;
+}
+
+/* Specify the bcdDevice value, as the radioSHARK and radioSHARK2 share ids */
+static struct usb_device_id usb_shark_device_table[] = {
+	{ .match_flags = USB_DEVICE_ID_MATCH_DEVICE_AND_VERSION |
+			 USB_DEVICE_ID_MATCH_INT_CLASS,
+	  .idVendor     = 0x077d,
+	  .idProduct    = 0x627a,
+	  .bcdDevice_lo = 0x0010,
+	  .bcdDevice_hi = 0x0010,
+	  .bInterfaceClass = 3,
+	},
+	{ }
+};
+MODULE_DEVICE_TABLE(usb, usb_shark_device_table);
+
+static struct usb_driver usb_shark_driver = {
+	.name			= DRV_NAME,
+	.probe			= usb_shark_probe,
+	.disconnect		= usb_shark_disconnect,
+	.id_table		= usb_shark_device_table,
+};
+module_usb_driver(usb_shark_driver);
