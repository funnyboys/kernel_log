commit c942fddf8793b2013be8c901b47d0a8dc02bf99f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:06 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 157
    
    Based on 3 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [kishon] [vijay] [abraham]
      [i] [kishon]@[ti] [com] this program is distributed in the hope that
      it will be useful but without any warranty without even the implied
      warranty of merchantability or fitness for a particular purpose see
      the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [graeme] [gregory]
      [gg]@[slimlogic] [co] [uk] [author] [kishon] [vijay] [abraham] [i]
      [kishon]@[ti] [com] [based] [on] [twl6030]_[usb] [c] [author] [hema]
      [hk] [hemahk]@[ti] [com] this program is distributed in the hope
      that it will be useful but without any warranty without even the
      implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1105 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.202006027@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/media/tuners/it913x.c b/drivers/media/tuners/it913x.c
index b5eb39921e95..e8e66390be41 100644
--- a/drivers/media/tuners/it913x.c
+++ b/drivers/media/tuners/it913x.c
@@ -1,19 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * ITE IT913X silicon tuner driver
  *
  *  Copyright (C) 2011 Malcolm Priestley (tvboxspy@gmail.com)
  *  IT9137 Copyright (C) ITE Tech Inc.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *
- *  GNU General Public License for more details.
  */
 
 #include "it913x.h"

commit a3f90c75b833caeff123499e13e0e31cbecf7d5b
Author: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
Date:   Thu Jul 5 18:59:35 2018 -0400

    media: dvb: convert tuner_info frequencies to Hz
    
    Right now, satellite tuner drivers specify frequencies in kHz,
    while terrestrial/cable ones specify in Hz. That's confusing
    for developers.
    
    However, the main problem is that universal tuners capable
    of handling both satellite and non-satelite delivery systems
    are appearing. We end by needing to hack the drivers in
    order to support such hybrid tuners.
    
    So, convert everything to specify tuner frequencies in Hz.
    
    Plese notice that a similar patch is also needed for frontends.
    
    Tested-by: Katsuhiro Suzuki <suzuki.katsuhiro@socionext.com>
    Acked-by: Michael BÃ¼sch <m@bues.ch>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/tuners/it913x.c b/drivers/media/tuners/it913x.c
index 27e5bc1c3cb5..b5eb39921e95 100644
--- a/drivers/media/tuners/it913x.c
+++ b/drivers/media/tuners/it913x.c
@@ -375,9 +375,9 @@ static int it913x_set_params(struct dvb_frontend *fe)
 
 static const struct dvb_tuner_ops it913x_tuner_ops = {
 	.info = {
-		.name           = "ITE IT913X",
-		.frequency_min  = 174000000,
-		.frequency_max  = 862000000,
+		.name             = "ITE IT913X",
+		.frequency_min_hz = 174 * MHz,
+		.frequency_max_hz = 862 * MHz,
 	},
 
 	.init = it913x_init,

commit 8efb34b280401acdaad19b6f1920af09d2628334
Author: Antti Palosaari <crope@iki.fi>
Date:   Thu Nov 10 01:24:50 2016 -0200

    [media] it913x: add chip device ids for binding
    
    Driver supports 2 different device versions, AX and BX. Use device
    IDs to pass chip version information to driver.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/tuners/it913x.c b/drivers/media/tuners/it913x.c
index 39998066a347..27e5bc1c3cb5 100644
--- a/drivers/media/tuners/it913x.c
+++ b/drivers/media/tuners/it913x.c
@@ -390,6 +390,7 @@ static int it913x_probe(struct platform_device *pdev)
 	struct it913x_platform_data *pdata = pdev->dev.platform_data;
 	struct dvb_frontend *fe = pdata->fe;
 	struct it913x_dev *dev;
+	const struct platform_device_id *id = platform_get_device_id(pdev);
 	int ret;
 	char *chip_ver_str;
 
@@ -403,7 +404,7 @@ static int it913x_probe(struct platform_device *pdev)
 	dev->pdev = pdev;
 	dev->regmap = pdata->regmap;
 	dev->fe = pdata->fe;
-	dev->chip_ver = pdata->chip_ver;
+	dev->chip_ver = id->driver_data;
 	dev->role = pdata->role;
 
 	fe->tuner_priv = dev;
@@ -441,6 +442,13 @@ static int it913x_remove(struct platform_device *pdev)
 	return 0;
 }
 
+static const struct platform_device_id it913x_id_table[] = {
+	{"it9133ax-tuner", 1},
+	{"it9133bx-tuner", 2},
+	{},
+};
+MODULE_DEVICE_TABLE(platform, it913x_id_table);
+
 static struct platform_driver it913x_driver = {
 	.driver = {
 		.name	= "it913x",
@@ -448,6 +456,7 @@ static struct platform_driver it913x_driver = {
 	},
 	.probe		= it913x_probe,
 	.remove		= it913x_remove,
+	.id_table	= it913x_id_table,
 };
 
 module_platform_driver(it913x_driver);

commit 675ee801633396389e73dc8a8e148ff3cad1d470
Author: Antti Palosaari <crope@iki.fi>
Date:   Sun Nov 6 22:00:45 2016 -0200

    [media] it913x: change driver model from i2c to platform
    
    That tuner is integrated to demodulator and communicates via
    demodulators address space. We cannot register both demodulator
    and tuner having same address to same I2C bus, so better to change
    it platform driver in order to implement I2C adapter correctly.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/tuners/it913x.c b/drivers/media/tuners/it913x.c
index a7770b0d30ba..39998066a347 100644
--- a/drivers/media/tuners/it913x.c
+++ b/drivers/media/tuners/it913x.c
@@ -17,10 +17,11 @@
  */
 
 #include "it913x.h"
+#include <linux/platform_device.h>
 #include <linux/regmap.h>
 
 struct it913x_dev {
-	struct i2c_client *client;
+	struct platform_device *pdev;
 	struct regmap *regmap;
 	struct dvb_frontend *fe;
 	u8 chip_ver:2;
@@ -35,13 +36,14 @@ struct it913x_dev {
 static int it913x_init(struct dvb_frontend *fe)
 {
 	struct it913x_dev *dev = fe->tuner_priv;
+	struct platform_device *pdev = dev->pdev;
 	int ret;
 	unsigned int utmp;
 	u8 iqik_m_cal, nv_val, buf[2];
 	static const u8 nv[] = {48, 32, 24, 16, 12, 8, 6, 4, 2};
 	unsigned long timeout;
 
-	dev_dbg(&dev->client->dev, "role %u\n", dev->role);
+	dev_dbg(&pdev->dev, "role %u\n", dev->role);
 
 	ret = regmap_write(dev->regmap, 0x80ec4c, 0x68);
 	if (ret)
@@ -69,7 +71,7 @@ static int it913x_init(struct dvb_frontend *fe)
 		iqik_m_cal = 6;
 		break;
 	default:
-		dev_err(&dev->client->dev, "unknown clock identifier %d\n", utmp);
+		dev_err(&pdev->dev, "unknown clock identifier %d\n", utmp);
 		goto err;
 	}
 
@@ -94,14 +96,14 @@ static int it913x_init(struct dvb_frontend *fe)
 			break;
 	}
 
-	dev_dbg(&dev->client->dev, "r_fbc_m_bdry took %u ms, val %u\n",
+	dev_dbg(&pdev->dev, "r_fbc_m_bdry took %u ms, val %u\n",
 			jiffies_to_msecs(jiffies) -
 			(jiffies_to_msecs(timeout) - TIMEOUT), utmp);
 
 	dev->fn_min = dev->xtal * utmp;
 	dev->fn_min /= (dev->fdiv * nv_val);
 	dev->fn_min *= 1000;
-	dev_dbg(&dev->client->dev, "fn_min %u\n", dev->fn_min);
+	dev_dbg(&pdev->dev, "fn_min %u\n", dev->fn_min);
 
 	/*
 	 * Chip version BX never sets that flag so we just wait 50ms in that
@@ -121,7 +123,7 @@ static int it913x_init(struct dvb_frontend *fe)
 				break;
 		}
 
-		dev_dbg(&dev->client->dev, "p_tsm_init_mode took %u ms, val %u\n",
+		dev_dbg(&pdev->dev, "p_tsm_init_mode took %u ms, val %u\n",
 				jiffies_to_msecs(jiffies) -
 				(jiffies_to_msecs(timeout) - TIMEOUT), utmp);
 	} else {
@@ -148,16 +150,17 @@ static int it913x_init(struct dvb_frontend *fe)
 
 	return 0;
 err:
-	dev_dbg(&dev->client->dev, "failed %d\n", ret);
+	dev_dbg(&pdev->dev, "failed %d\n", ret);
 	return ret;
 }
 
 static int it913x_sleep(struct dvb_frontend *fe)
 {
 	struct it913x_dev *dev = fe->tuner_priv;
+	struct platform_device *pdev = dev->pdev;
 	int ret, len;
 
-	dev_dbg(&dev->client->dev, "role %u\n", dev->role);
+	dev_dbg(&pdev->dev, "role %u\n", dev->role);
 
 	dev->active = false;
 
@@ -174,7 +177,7 @@ static int it913x_sleep(struct dvb_frontend *fe)
 	else
 		len = 15;
 
-	dev_dbg(&dev->client->dev, "role %u, len %d\n", dev->role, len);
+	dev_dbg(&pdev->dev, "role %u, len %d\n", dev->role, len);
 
 	ret = regmap_bulk_write(dev->regmap, 0x80ec02,
 			"\x3f\x1f\x3f\x3e\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00",
@@ -206,13 +209,14 @@ static int it913x_sleep(struct dvb_frontend *fe)
 
 	return 0;
 err:
-	dev_dbg(&dev->client->dev, "failed %d\n", ret);
+	dev_dbg(&pdev->dev, "failed %d\n", ret);
 	return ret;
 }
 
 static int it913x_set_params(struct dvb_frontend *fe)
 {
 	struct it913x_dev *dev = fe->tuner_priv;
+	struct platform_device *pdev = dev->pdev;
 	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
 	int ret;
 	unsigned int utmp;
@@ -220,7 +224,7 @@ static int it913x_set_params(struct dvb_frontend *fe)
 	u16 iqik_m_cal, n_div;
 	u8 u8tmp, n, l_band, lna_band;
 
-	dev_dbg(&dev->client->dev, "role=%u, frequency %u, bandwidth_hz %u\n",
+	dev_dbg(&pdev->dev, "role=%u, frequency %u, bandwidth_hz %u\n",
 			dev->role, c->frequency, c->bandwidth_hz);
 
 	if (!dev->active) {
@@ -286,7 +290,7 @@ static int it913x_set_params(struct dvb_frontend *fe)
 	pre_lo_freq += (u32) n << 13;
 	/* Frequency OMEGA_IQIK_M_CAL_MID*/
 	t_cal_freq = pre_lo_freq + (u32)iqik_m_cal;
-	dev_dbg(&dev->client->dev, "t_cal_freq %u, pre_lo_freq %u\n",
+	dev_dbg(&pdev->dev, "t_cal_freq %u, pre_lo_freq %u\n",
 			t_cal_freq, pre_lo_freq);
 
 	if (c->frequency <=         440000000) {
@@ -365,7 +369,7 @@ static int it913x_set_params(struct dvb_frontend *fe)
 
 	return 0;
 err:
-	dev_dbg(&dev->client->dev, "failed %d\n", ret);
+	dev_dbg(&pdev->dev, "failed %d\n", ret);
 	return ret;
 }
 
@@ -381,40 +385,31 @@ static const struct dvb_tuner_ops it913x_tuner_ops = {
 	.set_params = it913x_set_params,
 };
 
-static int it913x_probe(struct i2c_client *client,
-		const struct i2c_device_id *id)
+static int it913x_probe(struct platform_device *pdev)
 {
-	struct it913x_config *cfg = client->dev.platform_data;
-	struct dvb_frontend *fe = cfg->fe;
+	struct it913x_platform_data *pdata = pdev->dev.platform_data;
+	struct dvb_frontend *fe = pdata->fe;
 	struct it913x_dev *dev;
 	int ret;
 	char *chip_ver_str;
-	static const struct regmap_config regmap_config = {
-		.reg_bits = 24,
-		.val_bits = 8,
-	};
 
 	dev = kzalloc(sizeof(struct it913x_dev), GFP_KERNEL);
 	if (dev == NULL) {
 		ret = -ENOMEM;
-		dev_err(&client->dev, "kzalloc() failed\n");
+		dev_err(&pdev->dev, "kzalloc() failed\n");
 		goto err;
 	}
 
-	dev->client = client;
-	dev->fe = cfg->fe;
-	dev->chip_ver = cfg->chip_ver;
-	dev->role = cfg->role;
-	dev->regmap = regmap_init_i2c(client, &regmap_config);
-	if (IS_ERR(dev->regmap)) {
-		ret = PTR_ERR(dev->regmap);
-		goto err_kfree;
-	}
+	dev->pdev = pdev;
+	dev->regmap = pdata->regmap;
+	dev->fe = pdata->fe;
+	dev->chip_ver = pdata->chip_ver;
+	dev->role = pdata->role;
 
 	fe->tuner_priv = dev;
 	memcpy(&fe->ops.tuner_ops, &it913x_tuner_ops,
 			sizeof(struct dvb_tuner_ops));
-	i2c_set_clientdata(client, dev);
+	platform_set_drvdata(pdev, dev);
 
 	if (dev->chip_ver == 1)
 		chip_ver_str = "AX";
@@ -423,51 +418,39 @@ static int it913x_probe(struct i2c_client *client,
 	else
 		chip_ver_str = "??";
 
-	dev_info(&dev->client->dev, "ITE IT913X %s successfully attached\n",
-			chip_ver_str);
-	dev_dbg(&dev->client->dev, "chip_ver %u, role %u\n",
-			dev->chip_ver, dev->role);
+	dev_info(&pdev->dev, "ITE IT913X %s successfully attached\n",
+		 chip_ver_str);
+	dev_dbg(&pdev->dev, "chip_ver %u, role %u\n", dev->chip_ver, dev->role);
 	return 0;
-
-err_kfree:
-	kfree(dev);
 err:
-	dev_dbg(&client->dev, "failed %d\n", ret);
+	dev_dbg(&pdev->dev, "failed %d\n", ret);
 	return ret;
 }
 
-static int it913x_remove(struct i2c_client *client)
+static int it913x_remove(struct platform_device *pdev)
 {
-	struct it913x_dev *dev = i2c_get_clientdata(client);
+	struct it913x_dev *dev = platform_get_drvdata(pdev);
 	struct dvb_frontend *fe = dev->fe;
 
-	dev_dbg(&client->dev, "\n");
+	dev_dbg(&pdev->dev, "\n");
 
 	memset(&fe->ops.tuner_ops, 0, sizeof(struct dvb_tuner_ops));
 	fe->tuner_priv = NULL;
-	regmap_exit(dev->regmap);
 	kfree(dev);
 
 	return 0;
 }
 
-static const struct i2c_device_id it913x_id_table[] = {
-	{"it913x", 0},
-	{}
-};
-MODULE_DEVICE_TABLE(i2c, it913x_id_table);
-
-static struct i2c_driver it913x_driver = {
+static struct platform_driver it913x_driver = {
 	.driver = {
 		.name	= "it913x",
 		.suppress_bind_attrs	= true,
 	},
 	.probe		= it913x_probe,
 	.remove		= it913x_remove,
-	.id_table	= it913x_id_table,
 };
 
-module_i2c_driver(it913x_driver);
+module_platform_driver(it913x_driver);
 
 MODULE_DESCRIPTION("ITE IT913X silicon tuner driver");
 MODULE_AUTHOR("Antti Palosaari <crope@iki.fi>");

commit bcb63314e2c23f1ed622418b65f9409512659c73
Author: Sakari Ailus <sakari.ailus@linux.intel.com>
Date:   Fri Oct 28 09:31:20 2016 -0200

    [media] media: Drop FSF's postal address from the source code files
    
    Drop the FSF's postal address from the source code files that typically
    contain mostly the license text. Of the 628 removed instances, 578 are
    outdated.
    
    The patch has been created with the following command without manual edits:
    
    git grep -l "675 Mass Ave\|59 Temple Place\|51 Franklin St" -- \
            drivers/media/ include/media|while read i; do i=$i perl -e '
    open(F,"< $ENV{i}");
    $a=join("", <F>);
    $a =~ s/[ \t]*\*\n.*You should.*\n.*along with.*\n.*(\n.*USA.*$)?\n//m
            && $a =~ s/(^.*)Or, (point your browser to) /$1To obtain the license, $2\n$1/m;
    close(F);
    open(F, "> $ENV{i}");
    print F $a;
    close(F);'; done
    
    Signed-off-by: Sakari Ailus <sakari.ailus@linux.intel.com>

diff --git a/drivers/media/tuners/it913x.c b/drivers/media/tuners/it913x.c
index 6c3ef2181fcd..a7770b0d30ba 100644
--- a/drivers/media/tuners/it913x.c
+++ b/drivers/media/tuners/it913x.c
@@ -14,10 +14,6 @@
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *
  *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.=
  */
 
 #include "it913x.h"

commit d8d8636639631b35cbfefecea60be4d80139e98f
Author: Antti Palosaari <crope@iki.fi>
Date:   Wed Jun 29 20:40:23 2016 -0300

    [media] it913x: do not allow driver unbind
    
    Disable runtime unbind as driver does not support it.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/tuners/it913x.c b/drivers/media/tuners/it913x.c
index 5c96da693289..6c3ef2181fcd 100644
--- a/drivers/media/tuners/it913x.c
+++ b/drivers/media/tuners/it913x.c
@@ -464,6 +464,7 @@ MODULE_DEVICE_TABLE(i2c, it913x_id_table);
 static struct i2c_driver it913x_driver = {
 	.driver = {
 		.name	= "it913x",
+		.suppress_bind_attrs	= true,
 	},
 	.probe		= it913x_probe,
 	.remove		= it913x_remove,

commit 8972943c0e002541a7cede3e6612a3f775496fa2
Author: Krzysztof Kozlowski <k.kozlowski@samsung.com>
Date:   Fri Jul 10 03:19:47 2015 -0300

    [media] tuners: Drop owner assignment from i2c_driver
    
    i2c_driver does not need to set an owner because i2c_register_driver()
    will set it.
    
    Signed-off-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/tuners/it913x.c b/drivers/media/tuners/it913x.c
index a076c87eda7a..5c96da693289 100644
--- a/drivers/media/tuners/it913x.c
+++ b/drivers/media/tuners/it913x.c
@@ -463,7 +463,6 @@ MODULE_DEVICE_TABLE(i2c, it913x_id_table);
 
 static struct i2c_driver it913x_driver = {
 	.driver = {
-		.owner	= THIS_MODULE,
 		.name	= "it913x",
 	},
 	.probe		= it913x_probe,

commit 5190ff3e3e6ec55ecda805e68c4746aec8c1203c
Author: Antti Palosaari <crope@iki.fi>
Date:   Sun Aug 31 00:29:33 2014 -0300

    [media] it913x: replace udelay polling with jiffies
    
    udelay based I/O polling loop is a bad idea, especially system
    performance point of view. Kernel jiffies are preferred solution
    for such situations. Use it instead.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/tuners/it913x.c b/drivers/media/tuners/it913x.c
index 098e9d542708..a076c87eda7a 100644
--- a/drivers/media/tuners/it913x.c
+++ b/drivers/media/tuners/it913x.c
@@ -39,10 +39,11 @@ struct it913x_dev {
 static int it913x_init(struct dvb_frontend *fe)
 {
 	struct it913x_dev *dev = fe->tuner_priv;
-	int ret, i;
+	int ret;
 	unsigned int utmp;
 	u8 iqik_m_cal, nv_val, buf[2];
 	static const u8 nv[] = {48, 32, 24, 16, 12, 8, 6, 4, 2};
+	unsigned long timeout;
 
 	dev_dbg(&dev->client->dev, "role %u\n", dev->role);
 
@@ -85,7 +86,9 @@ static int it913x_init(struct dvb_frontend *fe)
 	else
 		nv_val = 2;
 
-	for (i = 0; i < 50; i++) {
+	#define TIMEOUT 50
+	timeout = jiffies + msecs_to_jiffies(TIMEOUT);
+	while (!time_after(jiffies, timeout)) {
 		ret = regmap_bulk_read(dev->regmap, 0x80ed23, buf, 2);
 		if (ret)
 			goto err;
@@ -93,30 +96,38 @@ static int it913x_init(struct dvb_frontend *fe)
 		utmp = (buf[1] << 8) | (buf[0] << 0);
 		if (utmp)
 			break;
-
-		udelay(2000);
 	}
 
-	dev_dbg(&dev->client->dev, "loop count %d, utmp %d\n", i, utmp);
+	dev_dbg(&dev->client->dev, "r_fbc_m_bdry took %u ms, val %u\n",
+			jiffies_to_msecs(jiffies) -
+			(jiffies_to_msecs(timeout) - TIMEOUT), utmp);
 
 	dev->fn_min = dev->xtal * utmp;
 	dev->fn_min /= (dev->fdiv * nv_val);
 	dev->fn_min *= 1000;
 	dev_dbg(&dev->client->dev, "fn_min %u\n", dev->fn_min);
 
+	/*
+	 * Chip version BX never sets that flag so we just wait 50ms in that
+	 * case. It is possible poll BX similarly than AX and then timeout in
+	 * order to get 50ms delay, but that causes about 120 extra I2C
+	 * messages. As for now, we just wait and reduce IO.
+	 */
 	if (dev->chip_ver == 1) {
-		for (i = 0; i < 50; i++) {
+		#define TIMEOUT 50
+		timeout = jiffies + msecs_to_jiffies(TIMEOUT);
+		while (!time_after(jiffies, timeout)) {
 			ret = regmap_read(dev->regmap, 0x80ec82, &utmp);
 			if (ret)
 				goto err;
 
 			if (utmp)
 				break;
-
-			udelay(2000);
 		}
 
-		dev_dbg(&dev->client->dev, "loop count %d\n", i);
+		dev_dbg(&dev->client->dev, "p_tsm_init_mode took %u ms, val %u\n",
+				jiffies_to_msecs(jiffies) -
+				(jiffies_to_msecs(timeout) - TIMEOUT), utmp);
 	} else {
 		msleep(50);
 	}

commit 17027b9620e6a2ea1d7f3cd0761803c44c65e2ed
Author: Antti Palosaari <crope@iki.fi>
Date:   Sat Aug 30 23:52:48 2014 -0300

    [media] it913x: refactor code largely
    
    Refactor code largely.
    
    Try to keep order of register read/write same as windows driver does as
    it makes comparing sniffs easier.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/tuners/it913x.c b/drivers/media/tuners/it913x.c
index 924f18d95ba4..098e9d542708 100644
--- a/drivers/media/tuners/it913x.c
+++ b/drivers/media/tuners/it913x.c
@@ -1,5 +1,5 @@
 /*
- * ITE Tech IT9137 silicon tuner driver
+ * ITE IT913X silicon tuner driver
  *
  *  Copyright (C) 2011 Malcolm Priestley (tvboxspy@gmail.com)
  *  IT9137 Copyright (C) ITE Tech Inc.
@@ -29,79 +29,120 @@ struct it913x_dev {
 	struct dvb_frontend *fe;
 	u8 chip_ver:2;
 	u8 role:2;
-	u16 tun_xtal;
-	u8 tun_fdiv;
-	u8 tun_clk_mode;
-	u32 tun_fn_min;
+	u16 xtal;
+	u8 fdiv;
+	u8 clk_mode;
+	u32 fn_min;
+	bool active;
 };
 
 static int it913x_init(struct dvb_frontend *fe)
 {
 	struct it913x_dev *dev = fe->tuner_priv;
 	int ret, i;
-	unsigned int reg;
-	u8 val, nv_val;
-	u8 nv[] = {48, 32, 24, 16, 12, 8, 6, 4, 2};
-	u8 b[2];
+	unsigned int utmp;
+	u8 iqik_m_cal, nv_val, buf[2];
+	static const u8 nv[] = {48, 32, 24, 16, 12, 8, 6, 4, 2};
 
-	ret = regmap_read(dev->regmap, 0x80ec86, &reg);
-	switch (reg) {
+	dev_dbg(&dev->client->dev, "role %u\n", dev->role);
+
+	ret = regmap_write(dev->regmap, 0x80ec4c, 0x68);
+	if (ret)
+		goto err;
+
+	usleep_range(10000, 100000);
+
+	ret = regmap_read(dev->regmap, 0x80ec86, &utmp);
+	if (ret)
+		goto err;
+
+	switch (utmp) {
 	case 0:
-		dev->tun_clk_mode = reg;
-		dev->tun_xtal = 2000;
-		dev->tun_fdiv = 3;
-		val = 16;
+		/* 12.000 MHz */
+		dev->clk_mode = utmp;
+		dev->xtal = 2000;
+		dev->fdiv = 3;
+		iqik_m_cal = 16;
 		break;
 	case 1:
-	default: /* I/O error too */
-		dev->tun_clk_mode = reg;
-		dev->tun_xtal = 640;
-		dev->tun_fdiv = 1;
-		val = 6;
+		/* 20.480 MHz */
+		dev->clk_mode = utmp;
+		dev->xtal = 640;
+		dev->fdiv = 1;
+		iqik_m_cal = 6;
 		break;
+	default:
+		dev_err(&dev->client->dev, "unknown clock identifier %d\n", utmp);
+		goto err;
 	}
 
-	ret = regmap_read(dev->regmap, 0x80ed03,  &reg);
+	ret = regmap_read(dev->regmap, 0x80ed03,  &utmp);
+	if (ret)
+		goto err;
 
-	if (reg < 0)
-		return -ENODEV;
-	else if (reg < ARRAY_SIZE(nv))
-		nv_val = nv[reg];
+	else if (utmp < ARRAY_SIZE(nv))
+		nv_val = nv[utmp];
 	else
 		nv_val = 2;
 
 	for (i = 0; i < 50; i++) {
-		ret = regmap_bulk_read(dev->regmap, 0x80ed23, &b[0], sizeof(b));
-		reg = (b[1] << 8) + b[0];
-		if (reg > 0)
-			break;
+		ret = regmap_bulk_read(dev->regmap, 0x80ed23, buf, 2);
 		if (ret)
-			return -ENODEV;
+			goto err;
+
+		utmp = (buf[1] << 8) | (buf[0] << 0);
+		if (utmp)
+			break;
+
 		udelay(2000);
 	}
-	dev->tun_fn_min = dev->tun_xtal * reg;
-	dev->tun_fn_min /= (dev->tun_fdiv * nv_val);
-	dev_dbg(&dev->client->dev, "Tuner fn_min %d\n", dev->tun_fn_min);
 
-	if (dev->chip_ver > 1)
-		msleep(50);
-	else {
+	dev_dbg(&dev->client->dev, "loop count %d, utmp %d\n", i, utmp);
+
+	dev->fn_min = dev->xtal * utmp;
+	dev->fn_min /= (dev->fdiv * nv_val);
+	dev->fn_min *= 1000;
+	dev_dbg(&dev->client->dev, "fn_min %u\n", dev->fn_min);
+
+	if (dev->chip_ver == 1) {
 		for (i = 0; i < 50; i++) {
-			ret = regmap_read(dev->regmap, 0x80ec82, &reg);
-			if (ret < 0)
-				return -ENODEV;
-			if (reg > 0)
+			ret = regmap_read(dev->regmap, 0x80ec82, &utmp);
+			if (ret)
+				goto err;
+
+			if (utmp)
 				break;
+
 			udelay(2000);
 		}
+
+		dev_dbg(&dev->client->dev, "loop count %d\n", i);
+	} else {
+		msleep(50);
 	}
 
-	/* Power Up Tuner - common all versions */
-	ret = regmap_write(dev->regmap, 0x80ec40, 0x1);
-	ret |= regmap_write(dev->regmap, 0x80ec57, 0x0);
-	ret |= regmap_write(dev->regmap, 0x80ec58, 0x0);
+	ret = regmap_write(dev->regmap, 0x80ed81, iqik_m_cal);
+	if (ret)
+		goto err;
+
+	ret = regmap_write(dev->regmap, 0x80ec57, 0x00);
+	if (ret)
+		goto err;
+
+	ret = regmap_write(dev->regmap, 0x80ec58, 0x00);
+	if (ret)
+		goto err;
+
+	ret = regmap_write(dev->regmap, 0x80ec40, 0x01);
+	if (ret)
+		goto err;
+
+	dev->active = true;
 
-	return regmap_write(dev->regmap, 0x80ed81, val);
+	return 0;
+err:
+	dev_dbg(&dev->client->dev, "failed %d\n", ret);
+	return ret;
 }
 
 static int it913x_sleep(struct dvb_frontend *fe)
@@ -109,7 +150,9 @@ static int it913x_sleep(struct dvb_frontend *fe)
 	struct it913x_dev *dev = fe->tuner_priv;
 	int ret, len;
 
-	dev_dbg(&dev->client->dev, "role=%u\n", dev->role);
+	dev_dbg(&dev->client->dev, "role %u\n", dev->role);
+
+	dev->active = false;
 
 	ret  = regmap_bulk_write(dev->regmap, 0x80ec40, "\x00", 1);
 	if (ret)
@@ -124,7 +167,7 @@ static int it913x_sleep(struct dvb_frontend *fe)
 	else
 		len = 15;
 
-	dev_dbg(&dev->client->dev, "role=%u len=%d\n", dev->role, len);
+	dev_dbg(&dev->client->dev, "role %u, len %d\n", dev->role, len);
 
 	ret = regmap_bulk_write(dev->regmap, 0x80ec02,
 			"\x3f\x1f\x3f\x3e\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00",
@@ -160,164 +203,159 @@ static int it913x_sleep(struct dvb_frontend *fe)
 	return ret;
 }
 
-static int it9137_set_params(struct dvb_frontend *fe)
+static int it913x_set_params(struct dvb_frontend *fe)
 {
 	struct it913x_dev *dev = fe->tuner_priv;
-	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
-	u32 bandwidth = p->bandwidth_hz;
-	u32 frequency_m = p->frequency;
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
 	int ret;
-	unsigned int reg;
-	u32 frequency = frequency_m / 1000;
-	u32 freq, temp_f, tmp;
-	u16 iqik_m_cal;
-	u16 n_div;
-	u8 n;
-	u8 l_band;
-	u8 lna_band;
-	u8 bw;
-
-	dev_dbg(&dev->client->dev, "Tuner Frequency %d Bandwidth %d\n",
-			frequency, bandwidth);
-
-	if (frequency >= 51000 && frequency <= 440000) {
-		l_band = 0;
-		lna_band = 0;
-	} else if (frequency > 440000 && frequency <= 484000) {
-		l_band = 1;
-		lna_band = 1;
-	} else if (frequency > 484000 && frequency <= 533000) {
-		l_band = 1;
-		lna_band = 2;
-	} else if (frequency > 533000 && frequency <= 587000) {
-		l_band = 1;
-		lna_band = 3;
-	} else if (frequency > 587000 && frequency <= 645000) {
-		l_band = 1;
-		lna_band = 4;
-	} else if (frequency > 645000 && frequency <= 710000) {
-		l_band = 1;
-		lna_band = 5;
-	} else if (frequency > 710000 && frequency <= 782000) {
-		l_band = 1;
-		lna_band = 6;
-	} else if (frequency > 782000 && frequency <= 860000) {
-		l_band = 1;
-		lna_band = 7;
-	} else if (frequency > 1450000 && frequency <= 1492000) {
-		l_band = 1;
-		lna_band = 0;
-	} else if (frequency > 1660000 && frequency <= 1685000) {
-		l_band = 1;
-		lna_band = 1;
-	} else
-		return -EINVAL;
+	unsigned int utmp;
+	u32 pre_lo_freq, t_cal_freq;
+	u16 iqik_m_cal, n_div;
+	u8 u8tmp, n, l_band, lna_band;
 
-	ret = regmap_write(dev->regmap, 0x80ee06, lna_band);
-	if (ret)
-		goto err;
-
-	switch (bandwidth) {
-	case 5000000:
-		bw = 0;
-		break;
-	case 6000000:
-		bw = 2;
-		break;
-	case 7000000:
-		bw = 4;
-		break;
-	default:
-	case 8000000:
-		bw = 6;
-		break;
-	}
-
-	ret = regmap_write(dev->regmap, 0x80ec56, bw);
-	if (ret)
-		goto err;
+	dev_dbg(&dev->client->dev, "role=%u, frequency %u, bandwidth_hz %u\n",
+			dev->role, c->frequency, c->bandwidth_hz);
 
-	ret = regmap_write(dev->regmap, 0x80ec4c, 0xa0 | (l_band << 3));
-	if (ret)
+	if (!dev->active) {
+		ret = -EINVAL;
 		goto err;
+	}
 
-	if (frequency > 53000 && frequency <= 74000) {
+	if (c->frequency <=         74000000) {
 		n_div = 48;
 		n = 0;
-	} else if (frequency > 74000 && frequency <= 111000) {
+	} else if (c->frequency <= 111000000) {
 		n_div = 32;
 		n = 1;
-	} else if (frequency > 111000 && frequency <= 148000) {
+	} else if (c->frequency <= 148000000) {
 		n_div = 24;
 		n = 2;
-	} else if (frequency > 148000 && frequency <= 222000) {
+	} else if (c->frequency <= 222000000) {
 		n_div = 16;
 		n = 3;
-	} else if (frequency > 222000 && frequency <= 296000) {
+	} else if (c->frequency <= 296000000) {
 		n_div = 12;
 		n = 4;
-	} else if (frequency > 296000 && frequency <= 445000) {
+	} else if (c->frequency <= 445000000) {
 		n_div = 8;
 		n = 5;
-	} else if (frequency > 445000 && frequency <= dev->tun_fn_min) {
+	} else if (c->frequency <= dev->fn_min) {
 		n_div = 6;
 		n = 6;
-	} else if (frequency > dev->tun_fn_min && frequency <= 950000) {
+	} else if (c->frequency <= 950000000) {
 		n_div = 4;
 		n = 7;
-	} else if (frequency > 1450000 && frequency <= 1680000) {
+	} else {
 		n_div = 2;
 		n = 0;
-	} else
-		return -EINVAL;
+	}
+
+	ret = regmap_read(dev->regmap, 0x80ed81, &utmp);
+	if (ret)
+		goto err;
 
-	ret = regmap_read(dev->regmap, 0x80ed81, &reg);
-	iqik_m_cal = (u16)reg * n_div;
+	iqik_m_cal = utmp * n_div;
 
-	if (reg < 0x20) {
-		if (dev->tun_clk_mode == 0)
+	if (utmp < 0x20) {
+		if (dev->clk_mode == 0)
 			iqik_m_cal = (iqik_m_cal * 9) >> 5;
 		else
 			iqik_m_cal >>= 1;
 	} else {
 		iqik_m_cal = 0x40 - iqik_m_cal;
-		if (dev->tun_clk_mode == 0)
+		if (dev->clk_mode == 0)
 			iqik_m_cal = ~((iqik_m_cal * 9) >> 5);
 		else
 			iqik_m_cal = ~(iqik_m_cal >> 1);
 	}
 
-	temp_f = frequency * (u32)n_div * (u32)dev->tun_fdiv;
-	freq = temp_f / dev->tun_xtal;
-	tmp = freq * dev->tun_xtal;
+	t_cal_freq = (c->frequency / 1000) * n_div * dev->fdiv;
+	pre_lo_freq = t_cal_freq / dev->xtal;
+	utmp = pre_lo_freq * dev->xtal;
 
-	if ((temp_f - tmp) >= (dev->tun_xtal >> 1))
-		freq++;
+	if ((t_cal_freq - utmp) >= (dev->xtal >> 1))
+		pre_lo_freq++;
 
-	freq += (u32) n << 13;
+	pre_lo_freq += (u32) n << 13;
 	/* Frequency OMEGA_IQIK_M_CAL_MID*/
-	temp_f = freq + (u32)iqik_m_cal;
+	t_cal_freq = pre_lo_freq + (u32)iqik_m_cal;
+	dev_dbg(&dev->client->dev, "t_cal_freq %u, pre_lo_freq %u\n",
+			t_cal_freq, pre_lo_freq);
 
-	ret = regmap_write(dev->regmap, 0x80ec4d, temp_f & 0xff);
+	if (c->frequency <=         440000000) {
+		l_band = 0;
+		lna_band = 0;
+	} else if (c->frequency <=  484000000) {
+		l_band = 1;
+		lna_band = 1;
+	} else if (c->frequency <=  533000000) {
+		l_band = 1;
+		lna_band = 2;
+	} else if (c->frequency <=  587000000) {
+		l_band = 1;
+		lna_band = 3;
+	} else if (c->frequency <=  645000000) {
+		l_band = 1;
+		lna_band = 4;
+	} else if (c->frequency <=  710000000) {
+		l_band = 1;
+		lna_band = 5;
+	} else if (c->frequency <=  782000000) {
+		l_band = 1;
+		lna_band = 6;
+	} else if (c->frequency <=  860000000) {
+		l_band = 1;
+		lna_band = 7;
+	} else if (c->frequency <= 1492000000) {
+		l_band = 1;
+		lna_band = 0;
+	} else if (c->frequency <= 1685000000) {
+		l_band = 1;
+		lna_band = 1;
+	} else {
+		ret = -EINVAL;
+		goto err;
+	}
+
+	/* XXX: latest windows driver does not set that at all */
+	ret = regmap_write(dev->regmap, 0x80ee06, lna_band);
 	if (ret)
 		goto err;
 
-	ret = regmap_write(dev->regmap, 0x80ec4e, (temp_f >> 8) & 0xff);
+	if (c->bandwidth_hz <=      5000000)
+		u8tmp = 0;
+	else if (c->bandwidth_hz <= 6000000)
+		u8tmp = 2;
+	else if (c->bandwidth_hz <= 7000000)
+		u8tmp = 4;
+	else
+		u8tmp = 6;       /* 8000000 */
+
+	ret = regmap_write(dev->regmap, 0x80ec56, u8tmp);
+	if (ret)
+		goto err;
+
+	/* XXX: latest windows driver sets different value (a8 != 68) */
+	ret = regmap_write(dev->regmap, 0x80ec4c, 0xa0 | (l_band << 3));
 	if (ret)
 		goto err;
 
-	dev_dbg(&dev->client->dev, "High Frequency = %04x\n", temp_f);
+	ret = regmap_write(dev->regmap, 0x80ec4d, (t_cal_freq >> 0) & 0xff);
+	if (ret)
+		goto err;
 
-	/* Lower frequency */
-	ret = regmap_write(dev->regmap, 0x80011e, freq & 0xff);
+	ret = regmap_write(dev->regmap, 0x80ec4e, (t_cal_freq >> 8) & 0xff);
 	if (ret)
 		goto err;
 
-	ret = regmap_write(dev->regmap, 0x80011f, (freq >> 8) & 0xff);
+	ret = regmap_write(dev->regmap, 0x80011e, (pre_lo_freq >> 0) & 0xff);
+	if (ret)
+		goto err;
+
+	ret = regmap_write(dev->regmap, 0x80011f, (pre_lo_freq >> 8) & 0xff);
 	if (ret)
 		goto err;
 
-	dev_dbg(&dev->client->dev, "low Frequency = %04x\n", freq);
 	return 0;
 err:
 	dev_dbg(&dev->client->dev, "failed %d\n", ret);
@@ -326,14 +364,14 @@ static int it9137_set_params(struct dvb_frontend *fe)
 
 static const struct dvb_tuner_ops it913x_tuner_ops = {
 	.info = {
-		.name           = "ITE Tech IT913X",
+		.name           = "ITE IT913X",
 		.frequency_min  = 174000000,
 		.frequency_max  = 862000000,
 	},
 
 	.init = it913x_init,
 	.sleep = it913x_sleep,
-	.set_params = it9137_set_params,
+	.set_params = it913x_set_params,
 };
 
 static int it913x_probe(struct i2c_client *client,
@@ -366,11 +404,6 @@ static int it913x_probe(struct i2c_client *client,
 		goto err_kfree;
 	}
 
-	/* tuner RF initial */
-	ret = regmap_write(dev->regmap, 0x80ec4c, 0x68);
-	if (ret)
-		goto err_regmap_exit;
-
 	fe->tuner_priv = dev;
 	memcpy(&fe->ops.tuner_ops, &it913x_tuner_ops,
 			sizeof(struct dvb_tuner_ops));
@@ -385,11 +418,10 @@ static int it913x_probe(struct i2c_client *client,
 
 	dev_info(&dev->client->dev, "ITE IT913X %s successfully attached\n",
 			chip_ver_str);
-	dev_dbg(&dev->client->dev, "chip_ver=%u role=%u\n", dev->chip_ver, dev->role);
+	dev_dbg(&dev->client->dev, "chip_ver %u, role %u\n",
+			dev->chip_ver, dev->role);
 	return 0;
 
-err_regmap_exit:
-	regmap_exit(dev->regmap);
 err_kfree:
 	kfree(dev);
 err:
@@ -430,6 +462,6 @@ static struct i2c_driver it913x_driver = {
 
 module_i2c_driver(it913x_driver);
 
-MODULE_DESCRIPTION("ITE Tech IT913X silicon tuner driver");
+MODULE_DESCRIPTION("ITE IT913X silicon tuner driver");
 MODULE_AUTHOR("Antti Palosaari <crope@iki.fi>");
 MODULE_LICENSE("GPL");

commit 3d2f18d34692a413fcd75f5e83fc1dcb7afac13c
Author: Antti Palosaari <crope@iki.fi>
Date:   Thu Aug 28 02:07:08 2014 -0300

    [media] it913x: get rid of script loader and and private header file
    
    Used script loader is quite useless and hides register numbers
    making code hard to understand. Get rid of it and use standard
    RegMap register write functions directly.
    
    it913x_priv.h file leaves empty after that change and is also
    removed.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/tuners/it913x.c b/drivers/media/tuners/it913x.c
index ab386bf01daf..924f18d95ba4 100644
--- a/drivers/media/tuners/it913x.c
+++ b/drivers/media/tuners/it913x.c
@@ -20,7 +20,8 @@
  *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.=
  */
 
-#include "it913x_priv.h"
+#include "it913x.h"
+#include <linux/regmap.h>
 
 struct it913x_dev {
 	struct i2c_client *client;
@@ -34,25 +35,6 @@ struct it913x_dev {
 	u32 tun_fn_min;
 };
 
-static int it913x_script_loader(struct it913x_dev *dev,
-		struct it913xset *loadscript)
-{
-	int ret, i;
-
-	if (loadscript == NULL)
-		return -EINVAL;
-
-	for (i = 0; i < 1000; ++i) {
-		if (loadscript[i].address == 0x000000)
-			break;
-		ret = regmap_bulk_write(dev->regmap, loadscript[i].address,
-			loadscript[i].reg, loadscript[i].count);
-		if (ret < 0)
-			return -ENODEV;
-	}
-	return 0;
-}
-
 static int it913x_init(struct dvb_frontend *fe)
 {
 	struct it913x_dev *dev = fe->tuner_priv;
@@ -181,7 +163,6 @@ static int it913x_sleep(struct dvb_frontend *fe)
 static int it9137_set_params(struct dvb_frontend *fe)
 {
 	struct it913x_dev *dev = fe->tuner_priv;
-	struct it913xset *set_tuner = set_it9135_template;
 	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
 	u32 bandwidth = p->bandwidth_hz;
 	u32 frequency_m = p->frequency;
@@ -231,7 +212,10 @@ static int it9137_set_params(struct dvb_frontend *fe)
 		lna_band = 1;
 	} else
 		return -EINVAL;
-	set_tuner[0].reg[0] = lna_band;
+
+	ret = regmap_write(dev->regmap, 0x80ee06, lna_band);
+	if (ret)
+		goto err;
 
 	switch (bandwidth) {
 	case 5000000:
@@ -249,8 +233,13 @@ static int it9137_set_params(struct dvb_frontend *fe)
 		break;
 	}
 
-	set_tuner[1].reg[0] = bw;
-	set_tuner[2].reg[0] = 0xa0 | (l_band << 3);
+	ret = regmap_write(dev->regmap, 0x80ec56, bw);
+	if (ret)
+		goto err;
+
+	ret = regmap_write(dev->regmap, 0x80ec4c, 0xa0 | (l_band << 3));
+	if (ret)
+		goto err;
 
 	if (frequency > 53000 && frequency <= 74000) {
 		n_div = 48;
@@ -309,20 +298,30 @@ static int it9137_set_params(struct dvb_frontend *fe)
 	/* Frequency OMEGA_IQIK_M_CAL_MID*/
 	temp_f = freq + (u32)iqik_m_cal;
 
-	set_tuner[3].reg[0] =  temp_f & 0xff;
-	set_tuner[4].reg[0] =  (temp_f >> 8) & 0xff;
+	ret = regmap_write(dev->regmap, 0x80ec4d, temp_f & 0xff);
+	if (ret)
+		goto err;
+
+	ret = regmap_write(dev->regmap, 0x80ec4e, (temp_f >> 8) & 0xff);
+	if (ret)
+		goto err;
 
 	dev_dbg(&dev->client->dev, "High Frequency = %04x\n", temp_f);
 
 	/* Lower frequency */
-	set_tuner[5].reg[0] =  freq & 0xff;
-	set_tuner[6].reg[0] =  (freq >> 8) & 0xff;
-
-	dev_dbg(&dev->client->dev, "low Frequency = %04x\n", freq);
+	ret = regmap_write(dev->regmap, 0x80011e, freq & 0xff);
+	if (ret)
+		goto err;
 
-	ret = it913x_script_loader(dev, set_tuner);
+	ret = regmap_write(dev->regmap, 0x80011f, (freq >> 8) & 0xff);
+	if (ret)
+		goto err;
 
-	return (ret < 0) ? -ENODEV : 0;
+	dev_dbg(&dev->client->dev, "low Frequency = %04x\n", freq);
+	return 0;
+err:
+	dev_dbg(&dev->client->dev, "failed %d\n", ret);
+	return ret;
 }
 
 static const struct dvb_tuner_ops it913x_tuner_ops = {

commit b7413c800fa7566696f1209207a90d014f548dac
Author: Antti Palosaari <crope@iki.fi>
Date:   Thu Aug 28 01:45:52 2014 -0300

    [media] it913x: remove dead code
    
    Remove unused tuner set template.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/tuners/it913x.c b/drivers/media/tuners/it913x.c
index 11d391a5d5c6..ab386bf01daf 100644
--- a/drivers/media/tuners/it913x.c
+++ b/drivers/media/tuners/it913x.c
@@ -28,7 +28,6 @@ struct it913x_dev {
 	struct dvb_frontend *fe;
 	u8 chip_ver:2;
 	u8 role:2;
-	u8 firmware_ver;
 	u16 tun_xtal;
 	u8 tun_fdiv;
 	u8 tun_clk_mode;
@@ -182,7 +181,7 @@ static int it913x_sleep(struct dvb_frontend *fe)
 static int it9137_set_params(struct dvb_frontend *fe)
 {
 	struct it913x_dev *dev = fe->tuner_priv;
-	struct it913xset *set_tuner = set_it9137_template;
+	struct it913xset *set_tuner = set_it9135_template;
 	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
 	u32 bandwidth = p->bandwidth_hz;
 	u32 frequency_m = p->frequency;
@@ -197,11 +196,6 @@ static int it9137_set_params(struct dvb_frontend *fe)
 	u8 lna_band;
 	u8 bw;
 
-	if (dev->firmware_ver == 1)
-		set_tuner = set_it9135_template;
-	else
-		set_tuner = set_it9137_template;
-
 	dev_dbg(&dev->client->dev, "Tuner Frequency %d Bandwidth %d\n",
 			frequency, bandwidth);
 
@@ -367,7 +361,6 @@ static int it913x_probe(struct i2c_client *client,
 	dev->fe = cfg->fe;
 	dev->chip_ver = cfg->chip_ver;
 	dev->role = cfg->role;
-	dev->firmware_ver = 1;
 	dev->regmap = regmap_init_i2c(client, &regmap_config);
 	if (IS_ERR(dev->regmap)) {
 		ret = PTR_ERR(dev->regmap);

commit 676c350f97366f648dbe7f7f8202a695d946f764
Author: Antti Palosaari <crope@iki.fi>
Date:   Wed Aug 27 03:59:27 2014 -0300

    [media] it913x: re-implement sleep
    
    Re-implement sleep. Based USB sniffs taken from the latest Hauppauge
    windows driver version 07/10/2014, 14.6.23.32191.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/tuners/it913x.c b/drivers/media/tuners/it913x.c
index f3e212c127c8..11d391a5d5c6 100644
--- a/drivers/media/tuners/it913x.c
+++ b/drivers/media/tuners/it913x.c
@@ -26,7 +26,8 @@ struct it913x_dev {
 	struct i2c_client *client;
 	struct regmap *regmap;
 	struct dvb_frontend *fe;
-	u8 chip_ver;
+	u8 chip_ver:2;
+	u8 role:2;
 	u8 firmware_ver;
 	u16 tun_xtal;
 	u8 tun_fdiv;
@@ -122,6 +123,62 @@ static int it913x_init(struct dvb_frontend *fe)
 	return regmap_write(dev->regmap, 0x80ed81, val);
 }
 
+static int it913x_sleep(struct dvb_frontend *fe)
+{
+	struct it913x_dev *dev = fe->tuner_priv;
+	int ret, len;
+
+	dev_dbg(&dev->client->dev, "role=%u\n", dev->role);
+
+	ret  = regmap_bulk_write(dev->regmap, 0x80ec40, "\x00", 1);
+	if (ret)
+		goto err;
+
+	/*
+	 * Writing '0x00' to master tuner register '0x80ec08' causes slave tuner
+	 * communication lost. Due to that, we cannot put master full sleep.
+	 */
+	if (dev->role == IT913X_ROLE_DUAL_MASTER)
+		len = 4;
+	else
+		len = 15;
+
+	dev_dbg(&dev->client->dev, "role=%u len=%d\n", dev->role, len);
+
+	ret = regmap_bulk_write(dev->regmap, 0x80ec02,
+			"\x3f\x1f\x3f\x3e\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00",
+			len);
+	if (ret)
+		goto err;
+
+	ret = regmap_bulk_write(dev->regmap, 0x80ec12, "\x00\x00\x00\x00", 4);
+	if (ret)
+		goto err;
+
+	ret = regmap_bulk_write(dev->regmap, 0x80ec17,
+			"\x00\x00\x00\x00\x00\x00\x00\x00\x00", 9);
+	if (ret)
+		goto err;
+
+	ret = regmap_bulk_write(dev->regmap, 0x80ec22,
+			"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 10);
+	if (ret)
+		goto err;
+
+	ret = regmap_bulk_write(dev->regmap, 0x80ec20, "\x00", 1);
+	if (ret)
+		goto err;
+
+	ret = regmap_bulk_write(dev->regmap, 0x80ec3f, "\x01", 1);
+	if (ret)
+		goto err;
+
+	return 0;
+err:
+	dev_dbg(&dev->client->dev, "failed %d\n", ret);
+	return ret;
+}
+
 static int it9137_set_params(struct dvb_frontend *fe)
 {
 	struct it913x_dev *dev = fe->tuner_priv;
@@ -274,20 +331,6 @@ static int it9137_set_params(struct dvb_frontend *fe)
 	return (ret < 0) ? -ENODEV : 0;
 }
 
-/* Power sequence */
-/* Power Up	Tuner on -> Frontend suspend off -> Tuner clk on */
-/* Power Down	Frontend suspend on -> Tuner clk off -> Tuner off */
-
-static int it913x_sleep(struct dvb_frontend *fe)
-{
-	struct it913x_dev *dev = fe->tuner_priv;
-
-	if (dev->chip_ver == 0x01)
-		return it913x_script_loader(dev, it9135ax_tuner_off);
-	else
-		return it913x_script_loader(dev, it9137_tuner_off);
-}
-
 static const struct dvb_tuner_ops it913x_tuner_ops = {
 	.info = {
 		.name           = "ITE Tech IT913X",
@@ -323,6 +366,7 @@ static int it913x_probe(struct i2c_client *client,
 	dev->client = client;
 	dev->fe = cfg->fe;
 	dev->chip_ver = cfg->chip_ver;
+	dev->role = cfg->role;
 	dev->firmware_ver = 1;
 	dev->regmap = regmap_init_i2c(client, &regmap_config);
 	if (IS_ERR(dev->regmap)) {
@@ -349,7 +393,7 @@ static int it913x_probe(struct i2c_client *client,
 
 	dev_info(&dev->client->dev, "ITE IT913X %s successfully attached\n",
 			chip_ver_str);
-	dev_dbg(&dev->client->dev, "chip_ver=%02x\n", dev->chip_ver);
+	dev_dbg(&dev->client->dev, "chip_ver=%u role=%u\n", dev->chip_ver, dev->role);
 	return 0;
 
 err_regmap_exit:

commit d2dbc00cea35081b9f998a0985d151f60ce37835
Author: Antti Palosaari <crope@iki.fi>
Date:   Tue Aug 26 21:45:33 2014 -0300

    [media] it913x: convert to RegMap API
    
    Use RegMap API to cover I2C register access routines.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/tuners/it913x.c b/drivers/media/tuners/it913x.c
index cc959c111a62..f3e212c127c8 100644
--- a/drivers/media/tuners/it913x.c
+++ b/drivers/media/tuners/it913x.c
@@ -24,6 +24,7 @@
 
 struct it913x_dev {
 	struct i2c_client *client;
+	struct regmap *regmap;
 	struct dvb_frontend *fe;
 	u8 chip_ver;
 	u8 firmware_ver;
@@ -33,92 +34,6 @@ struct it913x_dev {
 	u32 tun_fn_min;
 };
 
-/* read multiple registers */
-static int it913x_rd_regs(struct it913x_dev *dev,
-		u32 reg, u8 *data, u8 count)
-{
-	int ret;
-	u8 b[3];
-	struct i2c_msg msg[2] = {
-		{ .addr = dev->client->addr, .flags = 0,
-			.buf = b, .len = sizeof(b) },
-		{ .addr = dev->client->addr, .flags = I2C_M_RD,
-			.buf = data, .len = count }
-	};
-
-	b[0] = (u8)(reg >> 16) & 0xff;
-	b[1] = (u8)(reg >> 8) & 0xff;
-	b[2] = (u8) reg & 0xff;
-
-	ret = i2c_transfer(dev->client->adapter, msg, 2);
-
-	return ret;
-}
-
-/* read single register */
-static int it913x_rd_reg(struct it913x_dev *dev, u32 reg, u8 *val)
-{
-	int ret;
-	u8 b[1];
-
-	ret = it913x_rd_regs(dev, reg, &b[0], sizeof(b));
-	if (ret < 0)
-		return -ENODEV;
-	*val = b[0];
-	return 0;
-}
-
-/* write multiple registers */
-static int it913x_wr_regs(struct it913x_dev *dev,
-		u32 reg, u8 buf[], u8 count)
-{
-	u8 b[256];
-	struct i2c_msg msg[1] = {
-		{ .addr = dev->client->addr, .flags = 0,
-		  .buf = b, .len = 3 + count }
-	};
-	int ret;
-
-	b[0] = (u8)(reg >> 16) & 0xff;
-	b[1] = (u8)(reg >> 8) & 0xff;
-	b[2] = (u8) reg & 0xff;
-	memcpy(&b[3], buf, count);
-
-	ret = i2c_transfer(dev->client->adapter, msg, 1);
-
-	if (ret < 0)
-		return -EIO;
-
-	return 0;
-}
-
-/* write single register */
-static int it913x_wr_reg(struct it913x_dev *dev,
-		u32 reg, u32 data)
-{
-	int ret;
-	u8 b[4];
-	u8 len;
-
-	b[0] = data >> 24;
-	b[1] = (data >> 16) & 0xff;
-	b[2] = (data >> 8) & 0xff;
-	b[3] = data & 0xff;
-	/* expand write as needed */
-	if (data < 0x100)
-		len = 3;
-	else if (data < 0x1000)
-		len = 2;
-	else if (data < 0x100000)
-		len = 1;
-	else
-		len = 0;
-
-	ret = it913x_wr_regs(dev, reg, &b[len], sizeof(b) - len);
-
-	return ret;
-}
-
 static int it913x_script_loader(struct it913x_dev *dev,
 		struct it913xset *loadscript)
 {
@@ -130,8 +45,7 @@ static int it913x_script_loader(struct it913x_dev *dev,
 	for (i = 0; i < 1000; ++i) {
 		if (loadscript[i].address == 0x000000)
 			break;
-		ret = it913x_wr_regs(dev,
-			loadscript[i].address,
+		ret = regmap_bulk_write(dev->regmap, loadscript[i].address,
 			loadscript[i].reg, loadscript[i].count);
 		if (ret < 0)
 			return -ENODEV;
@@ -143,12 +57,12 @@ static int it913x_init(struct dvb_frontend *fe)
 {
 	struct it913x_dev *dev = fe->tuner_priv;
 	int ret, i;
-	u8 reg = 0;
+	unsigned int reg;
 	u8 val, nv_val;
 	u8 nv[] = {48, 32, 24, 16, 12, 8, 6, 4, 2};
 	u8 b[2];
 
-	ret = it913x_rd_reg(dev, 0x80ec86, &reg);
+	ret = regmap_read(dev->regmap, 0x80ec86, &reg);
 	switch (reg) {
 	case 0:
 		dev->tun_clk_mode = reg;
@@ -165,7 +79,7 @@ static int it913x_init(struct dvb_frontend *fe)
 		break;
 	}
 
-	ret = it913x_rd_reg(dev, 0x80ed03,  &reg);
+	ret = regmap_read(dev->regmap, 0x80ed03,  &reg);
 
 	if (reg < 0)
 		return -ENODEV;
@@ -175,11 +89,11 @@ static int it913x_init(struct dvb_frontend *fe)
 		nv_val = 2;
 
 	for (i = 0; i < 50; i++) {
-		ret = it913x_rd_regs(dev, 0x80ed23, &b[0], sizeof(b));
+		ret = regmap_bulk_read(dev->regmap, 0x80ed23, &b[0], sizeof(b));
 		reg = (b[1] << 8) + b[0];
 		if (reg > 0)
 			break;
-		if (ret < 0)
+		if (ret)
 			return -ENODEV;
 		udelay(2000);
 	}
@@ -191,7 +105,7 @@ static int it913x_init(struct dvb_frontend *fe)
 		msleep(50);
 	else {
 		for (i = 0; i < 50; i++) {
-			ret = it913x_rd_reg(dev, 0x80ec82, &reg);
+			ret = regmap_read(dev->regmap, 0x80ec82, &reg);
 			if (ret < 0)
 				return -ENODEV;
 			if (reg > 0)
@@ -201,11 +115,11 @@ static int it913x_init(struct dvb_frontend *fe)
 	}
 
 	/* Power Up Tuner - common all versions */
-	ret = it913x_wr_reg(dev, 0x80ec40, 0x1);
-	ret |= it913x_wr_reg(dev, 0x80ec57, 0x0);
-	ret |= it913x_wr_reg(dev, 0x80ec58, 0x0);
+	ret = regmap_write(dev->regmap, 0x80ec40, 0x1);
+	ret |= regmap_write(dev->regmap, 0x80ec57, 0x0);
+	ret |= regmap_write(dev->regmap, 0x80ec58, 0x0);
 
-	return it913x_wr_reg(dev, 0x80ed81, val);
+	return regmap_write(dev->regmap, 0x80ed81, val);
 }
 
 static int it9137_set_params(struct dvb_frontend *fe)
@@ -216,7 +130,7 @@ static int it9137_set_params(struct dvb_frontend *fe)
 	u32 bandwidth = p->bandwidth_hz;
 	u32 frequency_m = p->frequency;
 	int ret;
-	u8 reg = 0;
+	unsigned int reg;
 	u32 frequency = frequency_m / 1000;
 	u32 freq, temp_f, tmp;
 	u16 iqik_m_cal;
@@ -317,7 +231,7 @@ static int it9137_set_params(struct dvb_frontend *fe)
 	} else
 		return -EINVAL;
 
-	ret = it913x_rd_reg(dev, 0x80ed81, &reg);
+	ret = regmap_read(dev->regmap, 0x80ed81, &reg);
 	iqik_m_cal = (u16)reg * n_div;
 
 	if (reg < 0x20) {
@@ -394,6 +308,10 @@ static int it913x_probe(struct i2c_client *client,
 	struct it913x_dev *dev;
 	int ret;
 	char *chip_ver_str;
+	static const struct regmap_config regmap_config = {
+		.reg_bits = 24,
+		.val_bits = 8,
+	};
 
 	dev = kzalloc(sizeof(struct it913x_dev), GFP_KERNEL);
 	if (dev == NULL) {
@@ -406,11 +324,16 @@ static int it913x_probe(struct i2c_client *client,
 	dev->fe = cfg->fe;
 	dev->chip_ver = cfg->chip_ver;
 	dev->firmware_ver = 1;
+	dev->regmap = regmap_init_i2c(client, &regmap_config);
+	if (IS_ERR(dev->regmap)) {
+		ret = PTR_ERR(dev->regmap);
+		goto err_kfree;
+	}
 
 	/* tuner RF initial */
-	ret = it913x_wr_reg(dev, 0x80ec4c, 0x68);
-	if (ret < 0)
-		goto err;
+	ret = regmap_write(dev->regmap, 0x80ec4c, 0x68);
+	if (ret)
+		goto err_regmap_exit;
 
 	fe->tuner_priv = dev;
 	memcpy(&fe->ops.tuner_ops, &it913x_tuner_ops,
@@ -428,10 +351,13 @@ static int it913x_probe(struct i2c_client *client,
 			chip_ver_str);
 	dev_dbg(&dev->client->dev, "chip_ver=%02x\n", dev->chip_ver);
 	return 0;
+
+err_regmap_exit:
+	regmap_exit(dev->regmap);
+err_kfree:
+	kfree(dev);
 err:
 	dev_dbg(&client->dev, "failed %d\n", ret);
-	kfree(dev);
-
 	return ret;
 }
 
@@ -444,6 +370,7 @@ static int it913x_remove(struct i2c_client *client)
 
 	memset(&fe->ops.tuner_ops, 0, sizeof(struct dvb_tuner_ops));
 	fe->tuner_priv = NULL;
+	regmap_exit(dev->regmap);
 	kfree(dev);
 
 	return 0;

commit a71b65e8c545f5a72c1c227eae8a6df1d68f3f24
Author: Antti Palosaari <crope@iki.fi>
Date:   Tue Aug 26 20:11:08 2014 -0300

    [media] it913x: rename 'state' to 'dev'
    
    foo_dev seems to be most correct term for the structure holding data
    of each device instance. It is most used term in Kernel and also
    examples from book Linux Device Drivers, Third Edition, uses it.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/tuners/it913x.c b/drivers/media/tuners/it913x.c
index 7664878c9454..cc959c111a62 100644
--- a/drivers/media/tuners/it913x.c
+++ b/drivers/media/tuners/it913x.c
@@ -22,7 +22,7 @@
 
 #include "it913x_priv.h"
 
-struct it913x_state {
+struct it913x_dev {
 	struct i2c_client *client;
 	struct dvb_frontend *fe;
 	u8 chip_ver;
@@ -34,15 +34,15 @@ struct it913x_state {
 };
 
 /* read multiple registers */
-static int it913x_rd_regs(struct it913x_state *state,
+static int it913x_rd_regs(struct it913x_dev *dev,
 		u32 reg, u8 *data, u8 count)
 {
 	int ret;
 	u8 b[3];
 	struct i2c_msg msg[2] = {
-		{ .addr = state->client->addr, .flags = 0,
+		{ .addr = dev->client->addr, .flags = 0,
 			.buf = b, .len = sizeof(b) },
-		{ .addr = state->client->addr, .flags = I2C_M_RD,
+		{ .addr = dev->client->addr, .flags = I2C_M_RD,
 			.buf = data, .len = count }
 	};
 
@@ -50,18 +50,18 @@ static int it913x_rd_regs(struct it913x_state *state,
 	b[1] = (u8)(reg >> 8) & 0xff;
 	b[2] = (u8) reg & 0xff;
 
-	ret = i2c_transfer(state->client->adapter, msg, 2);
+	ret = i2c_transfer(dev->client->adapter, msg, 2);
 
 	return ret;
 }
 
 /* read single register */
-static int it913x_rd_reg(struct it913x_state *state, u32 reg, u8 *val)
+static int it913x_rd_reg(struct it913x_dev *dev, u32 reg, u8 *val)
 {
 	int ret;
 	u8 b[1];
 
-	ret = it913x_rd_regs(state, reg, &b[0], sizeof(b));
+	ret = it913x_rd_regs(dev, reg, &b[0], sizeof(b));
 	if (ret < 0)
 		return -ENODEV;
 	*val = b[0];
@@ -69,12 +69,12 @@ static int it913x_rd_reg(struct it913x_state *state, u32 reg, u8 *val)
 }
 
 /* write multiple registers */
-static int it913x_wr_regs(struct it913x_state *state,
+static int it913x_wr_regs(struct it913x_dev *dev,
 		u32 reg, u8 buf[], u8 count)
 {
 	u8 b[256];
 	struct i2c_msg msg[1] = {
-		{ .addr = state->client->addr, .flags = 0,
+		{ .addr = dev->client->addr, .flags = 0,
 		  .buf = b, .len = 3 + count }
 	};
 	int ret;
@@ -84,7 +84,7 @@ static int it913x_wr_regs(struct it913x_state *state,
 	b[2] = (u8) reg & 0xff;
 	memcpy(&b[3], buf, count);
 
-	ret = i2c_transfer(state->client->adapter, msg, 1);
+	ret = i2c_transfer(dev->client->adapter, msg, 1);
 
 	if (ret < 0)
 		return -EIO;
@@ -93,12 +93,12 @@ static int it913x_wr_regs(struct it913x_state *state,
 }
 
 /* write single register */
-static int it913x_wr_reg(struct it913x_state *state,
+static int it913x_wr_reg(struct it913x_dev *dev,
 		u32 reg, u32 data)
 {
 	int ret;
 	u8 b[4];
-	u8 s;
+	u8 len;
 
 	b[0] = data >> 24;
 	b[1] = (data >> 16) & 0xff;
@@ -106,20 +106,20 @@ static int it913x_wr_reg(struct it913x_state *state,
 	b[3] = data & 0xff;
 	/* expand write as needed */
 	if (data < 0x100)
-		s = 3;
+		len = 3;
 	else if (data < 0x1000)
-		s = 2;
+		len = 2;
 	else if (data < 0x100000)
-		s = 1;
+		len = 1;
 	else
-		s = 0;
+		len = 0;
 
-	ret = it913x_wr_regs(state, reg, &b[s], sizeof(b) - s);
+	ret = it913x_wr_regs(dev, reg, &b[len], sizeof(b) - len);
 
 	return ret;
 }
 
-static int it913x_script_loader(struct it913x_state *state,
+static int it913x_script_loader(struct it913x_dev *dev,
 		struct it913xset *loadscript)
 {
 	int ret, i;
@@ -130,7 +130,7 @@ static int it913x_script_loader(struct it913x_state *state,
 	for (i = 0; i < 1000; ++i) {
 		if (loadscript[i].address == 0x000000)
 			break;
-		ret = it913x_wr_regs(state,
+		ret = it913x_wr_regs(dev,
 			loadscript[i].address,
 			loadscript[i].reg, loadscript[i].count);
 		if (ret < 0)
@@ -141,31 +141,31 @@ static int it913x_script_loader(struct it913x_state *state,
 
 static int it913x_init(struct dvb_frontend *fe)
 {
-	struct it913x_state *state = fe->tuner_priv;
+	struct it913x_dev *dev = fe->tuner_priv;
 	int ret, i;
 	u8 reg = 0;
 	u8 val, nv_val;
 	u8 nv[] = {48, 32, 24, 16, 12, 8, 6, 4, 2};
 	u8 b[2];
 
-	ret = it913x_rd_reg(state, 0x80ec86, &reg);
+	ret = it913x_rd_reg(dev, 0x80ec86, &reg);
 	switch (reg) {
 	case 0:
-		state->tun_clk_mode = reg;
-		state->tun_xtal = 2000;
-		state->tun_fdiv = 3;
+		dev->tun_clk_mode = reg;
+		dev->tun_xtal = 2000;
+		dev->tun_fdiv = 3;
 		val = 16;
 		break;
 	case 1:
 	default: /* I/O error too */
-		state->tun_clk_mode = reg;
-		state->tun_xtal = 640;
-		state->tun_fdiv = 1;
+		dev->tun_clk_mode = reg;
+		dev->tun_xtal = 640;
+		dev->tun_fdiv = 1;
 		val = 6;
 		break;
 	}
 
-	ret = it913x_rd_reg(state, 0x80ed03,  &reg);
+	ret = it913x_rd_reg(dev, 0x80ed03,  &reg);
 
 	if (reg < 0)
 		return -ENODEV;
@@ -175,7 +175,7 @@ static int it913x_init(struct dvb_frontend *fe)
 		nv_val = 2;
 
 	for (i = 0; i < 50; i++) {
-		ret = it913x_rd_regs(state, 0x80ed23, &b[0], sizeof(b));
+		ret = it913x_rd_regs(dev, 0x80ed23, &b[0], sizeof(b));
 		reg = (b[1] << 8) + b[0];
 		if (reg > 0)
 			break;
@@ -183,15 +183,15 @@ static int it913x_init(struct dvb_frontend *fe)
 			return -ENODEV;
 		udelay(2000);
 	}
-	state->tun_fn_min = state->tun_xtal * reg;
-	state->tun_fn_min /= (state->tun_fdiv * nv_val);
-	dev_dbg(&state->client->dev, "Tuner fn_min %d\n", state->tun_fn_min);
+	dev->tun_fn_min = dev->tun_xtal * reg;
+	dev->tun_fn_min /= (dev->tun_fdiv * nv_val);
+	dev_dbg(&dev->client->dev, "Tuner fn_min %d\n", dev->tun_fn_min);
 
-	if (state->chip_ver > 1)
+	if (dev->chip_ver > 1)
 		msleep(50);
 	else {
 		for (i = 0; i < 50; i++) {
-			ret = it913x_rd_reg(state, 0x80ec82, &reg);
+			ret = it913x_rd_reg(dev, 0x80ec82, &reg);
 			if (ret < 0)
 				return -ENODEV;
 			if (reg > 0)
@@ -201,16 +201,16 @@ static int it913x_init(struct dvb_frontend *fe)
 	}
 
 	/* Power Up Tuner - common all versions */
-	ret = it913x_wr_reg(state, 0x80ec40, 0x1);
-	ret |= it913x_wr_reg(state, 0x80ec57, 0x0);
-	ret |= it913x_wr_reg(state, 0x80ec58, 0x0);
+	ret = it913x_wr_reg(dev, 0x80ec40, 0x1);
+	ret |= it913x_wr_reg(dev, 0x80ec57, 0x0);
+	ret |= it913x_wr_reg(dev, 0x80ec58, 0x0);
 
-	return it913x_wr_reg(state, 0x80ed81, val);
+	return it913x_wr_reg(dev, 0x80ed81, val);
 }
 
 static int it9137_set_params(struct dvb_frontend *fe)
 {
-	struct it913x_state *state = fe->tuner_priv;
+	struct it913x_dev *dev = fe->tuner_priv;
 	struct it913xset *set_tuner = set_it9137_template;
 	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
 	u32 bandwidth = p->bandwidth_hz;
@@ -226,12 +226,12 @@ static int it9137_set_params(struct dvb_frontend *fe)
 	u8 lna_band;
 	u8 bw;
 
-	if (state->firmware_ver == 1)
+	if (dev->firmware_ver == 1)
 		set_tuner = set_it9135_template;
 	else
 		set_tuner = set_it9137_template;
 
-	dev_dbg(&state->client->dev, "Tuner Frequency %d Bandwidth %d\n",
+	dev_dbg(&dev->client->dev, "Tuner Frequency %d Bandwidth %d\n",
 			frequency, bandwidth);
 
 	if (frequency >= 51000 && frequency <= 440000) {
@@ -305,10 +305,10 @@ static int it9137_set_params(struct dvb_frontend *fe)
 	} else if (frequency > 296000 && frequency <= 445000) {
 		n_div = 8;
 		n = 5;
-	} else if (frequency > 445000 && frequency <= state->tun_fn_min) {
+	} else if (frequency > 445000 && frequency <= dev->tun_fn_min) {
 		n_div = 6;
 		n = 6;
-	} else if (frequency > state->tun_fn_min && frequency <= 950000) {
+	} else if (frequency > dev->tun_fn_min && frequency <= 950000) {
 		n_div = 4;
 		n = 7;
 	} else if (frequency > 1450000 && frequency <= 1680000) {
@@ -317,27 +317,27 @@ static int it9137_set_params(struct dvb_frontend *fe)
 	} else
 		return -EINVAL;
 
-	ret = it913x_rd_reg(state, 0x80ed81, &reg);
+	ret = it913x_rd_reg(dev, 0x80ed81, &reg);
 	iqik_m_cal = (u16)reg * n_div;
 
 	if (reg < 0x20) {
-		if (state->tun_clk_mode == 0)
+		if (dev->tun_clk_mode == 0)
 			iqik_m_cal = (iqik_m_cal * 9) >> 5;
 		else
 			iqik_m_cal >>= 1;
 	} else {
 		iqik_m_cal = 0x40 - iqik_m_cal;
-		if (state->tun_clk_mode == 0)
+		if (dev->tun_clk_mode == 0)
 			iqik_m_cal = ~((iqik_m_cal * 9) >> 5);
 		else
 			iqik_m_cal = ~(iqik_m_cal >> 1);
 	}
 
-	temp_f = frequency * (u32)n_div * (u32)state->tun_fdiv;
-	freq = temp_f / state->tun_xtal;
-	tmp = freq * state->tun_xtal;
+	temp_f = frequency * (u32)n_div * (u32)dev->tun_fdiv;
+	freq = temp_f / dev->tun_xtal;
+	tmp = freq * dev->tun_xtal;
 
-	if ((temp_f - tmp) >= (state->tun_xtal >> 1))
+	if ((temp_f - tmp) >= (dev->tun_xtal >> 1))
 		freq++;
 
 	freq += (u32) n << 13;
@@ -347,15 +347,15 @@ static int it9137_set_params(struct dvb_frontend *fe)
 	set_tuner[3].reg[0] =  temp_f & 0xff;
 	set_tuner[4].reg[0] =  (temp_f >> 8) & 0xff;
 
-	dev_dbg(&state->client->dev, "High Frequency = %04x\n", temp_f);
+	dev_dbg(&dev->client->dev, "High Frequency = %04x\n", temp_f);
 
 	/* Lower frequency */
 	set_tuner[5].reg[0] =  freq & 0xff;
 	set_tuner[6].reg[0] =  (freq >> 8) & 0xff;
 
-	dev_dbg(&state->client->dev, "low Frequency = %04x\n", freq);
+	dev_dbg(&dev->client->dev, "low Frequency = %04x\n", freq);
 
-	ret = it913x_script_loader(state, set_tuner);
+	ret = it913x_script_loader(dev, set_tuner);
 
 	return (ret < 0) ? -ENODEV : 0;
 }
@@ -366,12 +366,12 @@ static int it9137_set_params(struct dvb_frontend *fe)
 
 static int it913x_sleep(struct dvb_frontend *fe)
 {
-	struct it913x_state *state = fe->tuner_priv;
+	struct it913x_dev *dev = fe->tuner_priv;
 
-	if (state->chip_ver == 0x01)
-		return it913x_script_loader(state, it9135ax_tuner_off);
+	if (dev->chip_ver == 0x01)
+		return it913x_script_loader(dev, it9135ax_tuner_off);
 	else
-		return it913x_script_loader(state, it9137_tuner_off);
+		return it913x_script_loader(dev, it9137_tuner_off);
 }
 
 static const struct dvb_tuner_ops it913x_tuner_ops = {
@@ -391,60 +391,60 @@ static int it913x_probe(struct i2c_client *client,
 {
 	struct it913x_config *cfg = client->dev.platform_data;
 	struct dvb_frontend *fe = cfg->fe;
-	struct it913x_state *state;
+	struct it913x_dev *dev;
 	int ret;
 	char *chip_ver_str;
 
-	state = kzalloc(sizeof(struct it913x_state), GFP_KERNEL);
-	if (state == NULL) {
+	dev = kzalloc(sizeof(struct it913x_dev), GFP_KERNEL);
+	if (dev == NULL) {
 		ret = -ENOMEM;
 		dev_err(&client->dev, "kzalloc() failed\n");
 		goto err;
 	}
 
-	state->client = client;
-	state->fe = cfg->fe;
-	state->chip_ver = cfg->chip_ver;
-	state->firmware_ver = 1;
+	dev->client = client;
+	dev->fe = cfg->fe;
+	dev->chip_ver = cfg->chip_ver;
+	dev->firmware_ver = 1;
 
 	/* tuner RF initial */
-	ret = it913x_wr_reg(state, 0x80ec4c, 0x68);
+	ret = it913x_wr_reg(dev, 0x80ec4c, 0x68);
 	if (ret < 0)
 		goto err;
 
-	fe->tuner_priv = state;
+	fe->tuner_priv = dev;
 	memcpy(&fe->ops.tuner_ops, &it913x_tuner_ops,
 			sizeof(struct dvb_tuner_ops));
-	i2c_set_clientdata(client, state);
+	i2c_set_clientdata(client, dev);
 
-	if (state->chip_ver == 1)
+	if (dev->chip_ver == 1)
 		chip_ver_str = "AX";
-	else if (state->chip_ver == 2)
+	else if (dev->chip_ver == 2)
 		chip_ver_str = "BX";
 	else
 		chip_ver_str = "??";
 
-	dev_info(&state->client->dev, "ITE IT913X %s successfully attached\n",
+	dev_info(&dev->client->dev, "ITE IT913X %s successfully attached\n",
 			chip_ver_str);
-	dev_dbg(&state->client->dev, "chip_ver=%02x\n", state->chip_ver);
+	dev_dbg(&dev->client->dev, "chip_ver=%02x\n", dev->chip_ver);
 	return 0;
 err:
 	dev_dbg(&client->dev, "failed %d\n", ret);
-	kfree(state);
+	kfree(dev);
 
 	return ret;
 }
 
 static int it913x_remove(struct i2c_client *client)
 {
-	struct it913x_state *state = i2c_get_clientdata(client);
-	struct dvb_frontend *fe = state->fe;
+	struct it913x_dev *dev = i2c_get_clientdata(client);
+	struct dvb_frontend *fe = dev->fe;
 
 	dev_dbg(&client->dev, "\n");
 
 	memset(&fe->ops.tuner_ops, 0, sizeof(struct dvb_tuner_ops));
 	fe->tuner_priv = NULL;
-	kfree(state);
+	kfree(dev);
 
 	return 0;
 }

commit 8da55c94dd85474a9925bd07a73959ae77a5aa6d
Author: Antti Palosaari <crope@iki.fi>
Date:   Tue Aug 26 18:56:46 2014 -0300

    [media] it913x: change reg read/write routines more common
    
    Change register write and read routines to similar which are
    typically used. We have to add processor core as a part of register
    address in order to simplify register access. Chip has two cores,
    called link and ofdm. As for now, use address bit 24 to address used
    core. Bits 15:0 are register address in given core.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/tuners/it913x.c b/drivers/media/tuners/it913x.c
index 72fefb753af1..7664878c9454 100644
--- a/drivers/media/tuners/it913x.c
+++ b/drivers/media/tuners/it913x.c
@@ -49,7 +49,6 @@ static int it913x_rd_regs(struct it913x_state *state,
 	b[0] = (u8)(reg >> 16) & 0xff;
 	b[1] = (u8)(reg >> 8) & 0xff;
 	b[2] = (u8) reg & 0xff;
-	b[0] |= 0x80; /* All reads from demodulator */
 
 	ret = i2c_transfer(state->client->adapter, msg, 2);
 
@@ -57,18 +56,21 @@ static int it913x_rd_regs(struct it913x_state *state,
 }
 
 /* read single register */
-static int it913x_rd_reg(struct it913x_state *state, u32 reg)
+static int it913x_rd_reg(struct it913x_state *state, u32 reg, u8 *val)
 {
 	int ret;
 	u8 b[1];
 
 	ret = it913x_rd_regs(state, reg, &b[0], sizeof(b));
-	return (ret < 0) ? -ENODEV : b[0];
+	if (ret < 0)
+		return -ENODEV;
+	*val = b[0];
+	return 0;
 }
 
 /* write multiple registers */
 static int it913x_wr_regs(struct it913x_state *state,
-		u8 pro, u32 reg, u8 buf[], u8 count)
+		u32 reg, u8 buf[], u8 count)
 {
 	u8 b[256];
 	struct i2c_msg msg[1] = {
@@ -82,9 +84,6 @@ static int it913x_wr_regs(struct it913x_state *state,
 	b[2] = (u8) reg & 0xff;
 	memcpy(&b[3], buf, count);
 
-	if (pro == PRO_DMOD)
-		b[0] |= 0x80;
-
 	ret = i2c_transfer(state->client->adapter, msg, 1);
 
 	if (ret < 0)
@@ -95,7 +94,7 @@ static int it913x_wr_regs(struct it913x_state *state,
 
 /* write single register */
 static int it913x_wr_reg(struct it913x_state *state,
-		u8 pro, u32 reg, u32 data)
+		u32 reg, u32 data)
 {
 	int ret;
 	u8 b[4];
@@ -115,7 +114,7 @@ static int it913x_wr_reg(struct it913x_state *state,
 	else
 		s = 0;
 
-	ret = it913x_wr_regs(state, pro, reg, &b[s], sizeof(b) - s);
+	ret = it913x_wr_regs(state, reg, &b[s], sizeof(b) - s);
 
 	return ret;
 }
@@ -129,9 +128,9 @@ static int it913x_script_loader(struct it913x_state *state,
 		return -EINVAL;
 
 	for (i = 0; i < 1000; ++i) {
-		if (loadscript[i].pro == 0xff)
+		if (loadscript[i].address == 0x000000)
 			break;
-		ret = it913x_wr_regs(state, loadscript[i].pro,
+		ret = it913x_wr_regs(state,
 			loadscript[i].address,
 			loadscript[i].reg, loadscript[i].count);
 		if (ret < 0)
@@ -143,12 +142,13 @@ static int it913x_script_loader(struct it913x_state *state,
 static int it913x_init(struct dvb_frontend *fe)
 {
 	struct it913x_state *state = fe->tuner_priv;
-	int ret, i, reg;
+	int ret, i;
+	u8 reg = 0;
 	u8 val, nv_val;
 	u8 nv[] = {48, 32, 24, 16, 12, 8, 6, 4, 2};
 	u8 b[2];
 
-	reg = it913x_rd_reg(state, 0xec86);
+	ret = it913x_rd_reg(state, 0x80ec86, &reg);
 	switch (reg) {
 	case 0:
 		state->tun_clk_mode = reg;
@@ -156,13 +156,8 @@ static int it913x_init(struct dvb_frontend *fe)
 		state->tun_fdiv = 3;
 		val = 16;
 		break;
-	case -ENODEV:
-		/* FIXME: these are just avoid divide by 0 */
-		state->tun_xtal = 2000;
-		state->tun_fdiv = 3;
-		return -ENODEV;
 	case 1:
-	default:
+	default: /* I/O error too */
 		state->tun_clk_mode = reg;
 		state->tun_xtal = 640;
 		state->tun_fdiv = 1;
@@ -170,7 +165,7 @@ static int it913x_init(struct dvb_frontend *fe)
 		break;
 	}
 
-	reg = it913x_rd_reg(state, 0xed03);
+	ret = it913x_rd_reg(state, 0x80ed03,  &reg);
 
 	if (reg < 0)
 		return -ENODEV;
@@ -180,7 +175,7 @@ static int it913x_init(struct dvb_frontend *fe)
 		nv_val = 2;
 
 	for (i = 0; i < 50; i++) {
-		ret = it913x_rd_regs(state, 0xed23, &b[0], sizeof(b));
+		ret = it913x_rd_regs(state, 0x80ed23, &b[0], sizeof(b));
 		reg = (b[1] << 8) + b[0];
 		if (reg > 0)
 			break;
@@ -196,21 +191,21 @@ static int it913x_init(struct dvb_frontend *fe)
 		msleep(50);
 	else {
 		for (i = 0; i < 50; i++) {
-			reg = it913x_rd_reg(state, 0xec82);
+			ret = it913x_rd_reg(state, 0x80ec82, &reg);
+			if (ret < 0)
+				return -ENODEV;
 			if (reg > 0)
 				break;
-			if (reg < 0)
-				return -ENODEV;
 			udelay(2000);
 		}
 	}
 
 	/* Power Up Tuner - common all versions */
-	ret = it913x_wr_reg(state, PRO_DMOD, 0xec40, 0x1);
-	ret |= it913x_wr_reg(state, PRO_DMOD, 0xec57, 0x0);
-	ret |= it913x_wr_reg(state, PRO_DMOD, 0xec58, 0x0);
+	ret = it913x_wr_reg(state, 0x80ec40, 0x1);
+	ret |= it913x_wr_reg(state, 0x80ec57, 0x0);
+	ret |= it913x_wr_reg(state, 0x80ec58, 0x0);
 
-	return it913x_wr_reg(state, PRO_DMOD, 0xed81, val);
+	return it913x_wr_reg(state, 0x80ed81, val);
 }
 
 static int it9137_set_params(struct dvb_frontend *fe)
@@ -220,7 +215,8 @@ static int it9137_set_params(struct dvb_frontend *fe)
 	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
 	u32 bandwidth = p->bandwidth_hz;
 	u32 frequency_m = p->frequency;
-	int ret, reg;
+	int ret;
+	u8 reg = 0;
 	u32 frequency = frequency_m / 1000;
 	u32 freq, temp_f, tmp;
 	u16 iqik_m_cal;
@@ -321,7 +317,7 @@ static int it9137_set_params(struct dvb_frontend *fe)
 	} else
 		return -EINVAL;
 
-	reg = it913x_rd_reg(state, 0xed81);
+	ret = it913x_rd_reg(state, 0x80ed81, &reg);
 	iqik_m_cal = (u16)reg * n_div;
 
 	if (reg < 0x20) {
@@ -412,7 +408,7 @@ static int it913x_probe(struct i2c_client *client,
 	state->firmware_ver = 1;
 
 	/* tuner RF initial */
-	ret = it913x_wr_reg(state, PRO_DMOD, 0xec4c, 0x68);
+	ret = it913x_wr_reg(state, 0x80ec4c, 0x68);
 	if (ret < 0)
 		goto err;
 

commit 3b2a5e8c080da37be6135f44d236fe6b796666d9
Author: Antti Palosaari <crope@iki.fi>
Date:   Tue Aug 26 17:14:16 2014 -0300

    [media] it913x: convert to I2C driver
    
    Change the it913x driver to use the I2C high lever tuner
    binding model. As af9035 depends on it, add a code there
    to do the binding.
    
    [mchehab@osg.samsung.com: Merge 3 patches into one, because
     we don't want to break bisect due to the conversion]
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/tuners/it913x.c b/drivers/media/tuners/it913x.c
index 4627925ed117..72fefb753af1 100644
--- a/drivers/media/tuners/it913x.c
+++ b/drivers/media/tuners/it913x.c
@@ -23,10 +23,9 @@
 #include "it913x_priv.h"
 
 struct it913x_state {
-	struct i2c_adapter *i2c_adap;
-	u8 i2c_addr;
+	struct i2c_client *client;
+	struct dvb_frontend *fe;
 	u8 chip_ver;
-	u8 tuner_type;
 	u8 firmware_ver;
 	u16 tun_xtal;
 	u8 tun_fdiv;
@@ -41,9 +40,9 @@ static int it913x_rd_regs(struct it913x_state *state,
 	int ret;
 	u8 b[3];
 	struct i2c_msg msg[2] = {
-		{ .addr = state->i2c_addr, .flags = 0,
+		{ .addr = state->client->addr, .flags = 0,
 			.buf = b, .len = sizeof(b) },
-		{ .addr = state->i2c_addr, .flags = I2C_M_RD,
+		{ .addr = state->client->addr, .flags = I2C_M_RD,
 			.buf = data, .len = count }
 	};
 
@@ -52,7 +51,7 @@ static int it913x_rd_regs(struct it913x_state *state,
 	b[2] = (u8) reg & 0xff;
 	b[0] |= 0x80; /* All reads from demodulator */
 
-	ret = i2c_transfer(state->i2c_adap, msg, 2);
+	ret = i2c_transfer(state->client->adapter, msg, 2);
 
 	return ret;
 }
@@ -73,7 +72,7 @@ static int it913x_wr_regs(struct it913x_state *state,
 {
 	u8 b[256];
 	struct i2c_msg msg[1] = {
-		{ .addr = state->i2c_addr, .flags = 0,
+		{ .addr = state->client->addr, .flags = 0,
 		  .buf = b, .len = 3 + count }
 	};
 	int ret;
@@ -86,7 +85,7 @@ static int it913x_wr_regs(struct it913x_state *state,
 	if (pro == PRO_DMOD)
 		b[0] |= 0x80;
 
-	ret = i2c_transfer(state->i2c_adap, msg, 1);
+	ret = i2c_transfer(state->client->adapter, msg, 1);
 
 	if (ret < 0)
 		return -EIO;
@@ -191,8 +190,7 @@ static int it913x_init(struct dvb_frontend *fe)
 	}
 	state->tun_fn_min = state->tun_xtal * reg;
 	state->tun_fn_min /= (state->tun_fdiv * nv_val);
-	dev_dbg(&state->i2c_adap->dev, "%s: Tuner fn_min %d\n", __func__,
-			state->tun_fn_min);
+	dev_dbg(&state->client->dev, "Tuner fn_min %d\n", state->tun_fn_min);
 
 	if (state->chip_ver > 1)
 		msleep(50);
@@ -237,8 +235,8 @@ static int it9137_set_params(struct dvb_frontend *fe)
 	else
 		set_tuner = set_it9137_template;
 
-	dev_dbg(&state->i2c_adap->dev, "%s: Tuner Frequency %d Bandwidth %d\n",
-			__func__, frequency, bandwidth);
+	dev_dbg(&state->client->dev, "Tuner Frequency %d Bandwidth %d\n",
+			frequency, bandwidth);
 
 	if (frequency >= 51000 && frequency <= 440000) {
 		l_band = 0;
@@ -353,15 +351,13 @@ static int it9137_set_params(struct dvb_frontend *fe)
 	set_tuner[3].reg[0] =  temp_f & 0xff;
 	set_tuner[4].reg[0] =  (temp_f >> 8) & 0xff;
 
-	dev_dbg(&state->i2c_adap->dev, "%s: High Frequency = %04x\n",
-			__func__, temp_f);
+	dev_dbg(&state->client->dev, "High Frequency = %04x\n", temp_f);
 
 	/* Lower frequency */
 	set_tuner[5].reg[0] =  freq & 0xff;
 	set_tuner[6].reg[0] =  (freq >> 8) & 0xff;
 
-	dev_dbg(&state->i2c_adap->dev, "%s: low Frequency = %04x\n",
-			__func__, freq);
+	dev_dbg(&state->client->dev, "low Frequency = %04x\n", freq);
 
 	ret = it913x_script_loader(state, set_tuner);
 
@@ -382,12 +378,6 @@ static int it913x_sleep(struct dvb_frontend *fe)
 		return it913x_script_loader(state, it9137_tuner_off);
 }
 
-static int it913x_release(struct dvb_frontend *fe)
-{
-	kfree(fe->tuner_priv);
-	return 0;
-}
-
 static const struct dvb_tuner_ops it913x_tuner_ops = {
 	.info = {
 		.name           = "ITE Tech IT913X",
@@ -395,68 +385,91 @@ static const struct dvb_tuner_ops it913x_tuner_ops = {
 		.frequency_max  = 862000000,
 	},
 
-	.release = it913x_release,
-
 	.init = it913x_init,
 	.sleep = it913x_sleep,
 	.set_params = it9137_set_params,
 };
 
-struct dvb_frontend *it913x_attach(struct dvb_frontend *fe,
-		struct i2c_adapter *i2c_adap, u8 i2c_addr, u8 config)
+static int it913x_probe(struct i2c_client *client,
+		const struct i2c_device_id *id)
 {
-	struct it913x_state *state = NULL;
+	struct it913x_config *cfg = client->dev.platform_data;
+	struct dvb_frontend *fe = cfg->fe;
+	struct it913x_state *state;
 	int ret;
+	char *chip_ver_str;
 
-	/* allocate memory for the internal state */
 	state = kzalloc(sizeof(struct it913x_state), GFP_KERNEL);
-	if (state == NULL)
-		return NULL;
-
-	state->i2c_adap = i2c_adap;
-	state->i2c_addr = i2c_addr;
-
-	switch (config) {
-	case AF9033_TUNER_IT9135_38:
-	case AF9033_TUNER_IT9135_51:
-	case AF9033_TUNER_IT9135_52:
-		state->chip_ver = 0x01;
-		break;
-	case AF9033_TUNER_IT9135_60:
-	case AF9033_TUNER_IT9135_61:
-	case AF9033_TUNER_IT9135_62:
-		state->chip_ver = 0x02;
-		break;
-	default:
-		dev_dbg(&i2c_adap->dev,
-				"%s: invalid config=%02x\n", __func__, config);
-		goto error;
+	if (state == NULL) {
+		ret = -ENOMEM;
+		dev_err(&client->dev, "kzalloc() failed\n");
+		goto err;
 	}
 
-	state->tuner_type = config;
+	state->client = client;
+	state->fe = cfg->fe;
+	state->chip_ver = cfg->chip_ver;
 	state->firmware_ver = 1;
 
 	/* tuner RF initial */
 	ret = it913x_wr_reg(state, PRO_DMOD, 0xec4c, 0x68);
 	if (ret < 0)
-		goto error;
+		goto err;
 
 	fe->tuner_priv = state;
 	memcpy(&fe->ops.tuner_ops, &it913x_tuner_ops,
 			sizeof(struct dvb_tuner_ops));
+	i2c_set_clientdata(client, state);
+
+	if (state->chip_ver == 1)
+		chip_ver_str = "AX";
+	else if (state->chip_ver == 2)
+		chip_ver_str = "BX";
+	else
+		chip_ver_str = "??";
+
+	dev_info(&state->client->dev, "ITE IT913X %s successfully attached\n",
+			chip_ver_str);
+	dev_dbg(&state->client->dev, "chip_ver=%02x\n", state->chip_ver);
+	return 0;
+err:
+	dev_dbg(&client->dev, "failed %d\n", ret);
+	kfree(state);
 
-	dev_info(&i2c_adap->dev,
-			"%s: ITE Tech IT913X successfully attached\n",
-			KBUILD_MODNAME);
-	dev_dbg(&i2c_adap->dev, "%s: config=%02x chip_ver=%02x\n",
-			__func__, config, state->chip_ver);
+	return ret;
+}
 
-	return fe;
-error:
+static int it913x_remove(struct i2c_client *client)
+{
+	struct it913x_state *state = i2c_get_clientdata(client);
+	struct dvb_frontend *fe = state->fe;
+
+	dev_dbg(&client->dev, "\n");
+
+	memset(&fe->ops.tuner_ops, 0, sizeof(struct dvb_tuner_ops));
+	fe->tuner_priv = NULL;
 	kfree(state);
-	return NULL;
+
+	return 0;
 }
-EXPORT_SYMBOL(it913x_attach);
+
+static const struct i2c_device_id it913x_id_table[] = {
+	{"it913x", 0},
+	{}
+};
+MODULE_DEVICE_TABLE(i2c, it913x_id_table);
+
+static struct i2c_driver it913x_driver = {
+	.driver = {
+		.owner	= THIS_MODULE,
+		.name	= "it913x",
+	},
+	.probe		= it913x_probe,
+	.remove		= it913x_remove,
+	.id_table	= it913x_id_table,
+};
+
+module_i2c_driver(it913x_driver);
 
 MODULE_DESCRIPTION("ITE Tech IT913X silicon tuner driver");
 MODULE_AUTHOR("Antti Palosaari <crope@iki.fi>");

commit c2ba9726c342d113bdc36cfd8e984e30498037c6
Author: Antti Palosaari <crope@iki.fi>
Date:   Tue Aug 26 00:08:16 2014 -0300

    [media] it913x: rename tuner_it913x => it913x
    
    Remove tuner_ prefix from module name and file names. Prefix was
    added due to file name conflict on media out-tree build system.
    Demodulator having same name does not exists anymore. So lets
    remove dumb prefix.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/tuners/it913x.c b/drivers/media/tuners/it913x.c
new file mode 100644
index 000000000000..4627925ed117
--- /dev/null
+++ b/drivers/media/tuners/it913x.c
@@ -0,0 +1,463 @@
+/*
+ * ITE Tech IT9137 silicon tuner driver
+ *
+ *  Copyright (C) 2011 Malcolm Priestley (tvboxspy@gmail.com)
+ *  IT9137 Copyright (C) ITE Tech Inc.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.=
+ */
+
+#include "it913x_priv.h"
+
+struct it913x_state {
+	struct i2c_adapter *i2c_adap;
+	u8 i2c_addr;
+	u8 chip_ver;
+	u8 tuner_type;
+	u8 firmware_ver;
+	u16 tun_xtal;
+	u8 tun_fdiv;
+	u8 tun_clk_mode;
+	u32 tun_fn_min;
+};
+
+/* read multiple registers */
+static int it913x_rd_regs(struct it913x_state *state,
+		u32 reg, u8 *data, u8 count)
+{
+	int ret;
+	u8 b[3];
+	struct i2c_msg msg[2] = {
+		{ .addr = state->i2c_addr, .flags = 0,
+			.buf = b, .len = sizeof(b) },
+		{ .addr = state->i2c_addr, .flags = I2C_M_RD,
+			.buf = data, .len = count }
+	};
+
+	b[0] = (u8)(reg >> 16) & 0xff;
+	b[1] = (u8)(reg >> 8) & 0xff;
+	b[2] = (u8) reg & 0xff;
+	b[0] |= 0x80; /* All reads from demodulator */
+
+	ret = i2c_transfer(state->i2c_adap, msg, 2);
+
+	return ret;
+}
+
+/* read single register */
+static int it913x_rd_reg(struct it913x_state *state, u32 reg)
+{
+	int ret;
+	u8 b[1];
+
+	ret = it913x_rd_regs(state, reg, &b[0], sizeof(b));
+	return (ret < 0) ? -ENODEV : b[0];
+}
+
+/* write multiple registers */
+static int it913x_wr_regs(struct it913x_state *state,
+		u8 pro, u32 reg, u8 buf[], u8 count)
+{
+	u8 b[256];
+	struct i2c_msg msg[1] = {
+		{ .addr = state->i2c_addr, .flags = 0,
+		  .buf = b, .len = 3 + count }
+	};
+	int ret;
+
+	b[0] = (u8)(reg >> 16) & 0xff;
+	b[1] = (u8)(reg >> 8) & 0xff;
+	b[2] = (u8) reg & 0xff;
+	memcpy(&b[3], buf, count);
+
+	if (pro == PRO_DMOD)
+		b[0] |= 0x80;
+
+	ret = i2c_transfer(state->i2c_adap, msg, 1);
+
+	if (ret < 0)
+		return -EIO;
+
+	return 0;
+}
+
+/* write single register */
+static int it913x_wr_reg(struct it913x_state *state,
+		u8 pro, u32 reg, u32 data)
+{
+	int ret;
+	u8 b[4];
+	u8 s;
+
+	b[0] = data >> 24;
+	b[1] = (data >> 16) & 0xff;
+	b[2] = (data >> 8) & 0xff;
+	b[3] = data & 0xff;
+	/* expand write as needed */
+	if (data < 0x100)
+		s = 3;
+	else if (data < 0x1000)
+		s = 2;
+	else if (data < 0x100000)
+		s = 1;
+	else
+		s = 0;
+
+	ret = it913x_wr_regs(state, pro, reg, &b[s], sizeof(b) - s);
+
+	return ret;
+}
+
+static int it913x_script_loader(struct it913x_state *state,
+		struct it913xset *loadscript)
+{
+	int ret, i;
+
+	if (loadscript == NULL)
+		return -EINVAL;
+
+	for (i = 0; i < 1000; ++i) {
+		if (loadscript[i].pro == 0xff)
+			break;
+		ret = it913x_wr_regs(state, loadscript[i].pro,
+			loadscript[i].address,
+			loadscript[i].reg, loadscript[i].count);
+		if (ret < 0)
+			return -ENODEV;
+	}
+	return 0;
+}
+
+static int it913x_init(struct dvb_frontend *fe)
+{
+	struct it913x_state *state = fe->tuner_priv;
+	int ret, i, reg;
+	u8 val, nv_val;
+	u8 nv[] = {48, 32, 24, 16, 12, 8, 6, 4, 2};
+	u8 b[2];
+
+	reg = it913x_rd_reg(state, 0xec86);
+	switch (reg) {
+	case 0:
+		state->tun_clk_mode = reg;
+		state->tun_xtal = 2000;
+		state->tun_fdiv = 3;
+		val = 16;
+		break;
+	case -ENODEV:
+		/* FIXME: these are just avoid divide by 0 */
+		state->tun_xtal = 2000;
+		state->tun_fdiv = 3;
+		return -ENODEV;
+	case 1:
+	default:
+		state->tun_clk_mode = reg;
+		state->tun_xtal = 640;
+		state->tun_fdiv = 1;
+		val = 6;
+		break;
+	}
+
+	reg = it913x_rd_reg(state, 0xed03);
+
+	if (reg < 0)
+		return -ENODEV;
+	else if (reg < ARRAY_SIZE(nv))
+		nv_val = nv[reg];
+	else
+		nv_val = 2;
+
+	for (i = 0; i < 50; i++) {
+		ret = it913x_rd_regs(state, 0xed23, &b[0], sizeof(b));
+		reg = (b[1] << 8) + b[0];
+		if (reg > 0)
+			break;
+		if (ret < 0)
+			return -ENODEV;
+		udelay(2000);
+	}
+	state->tun_fn_min = state->tun_xtal * reg;
+	state->tun_fn_min /= (state->tun_fdiv * nv_val);
+	dev_dbg(&state->i2c_adap->dev, "%s: Tuner fn_min %d\n", __func__,
+			state->tun_fn_min);
+
+	if (state->chip_ver > 1)
+		msleep(50);
+	else {
+		for (i = 0; i < 50; i++) {
+			reg = it913x_rd_reg(state, 0xec82);
+			if (reg > 0)
+				break;
+			if (reg < 0)
+				return -ENODEV;
+			udelay(2000);
+		}
+	}
+
+	/* Power Up Tuner - common all versions */
+	ret = it913x_wr_reg(state, PRO_DMOD, 0xec40, 0x1);
+	ret |= it913x_wr_reg(state, PRO_DMOD, 0xec57, 0x0);
+	ret |= it913x_wr_reg(state, PRO_DMOD, 0xec58, 0x0);
+
+	return it913x_wr_reg(state, PRO_DMOD, 0xed81, val);
+}
+
+static int it9137_set_params(struct dvb_frontend *fe)
+{
+	struct it913x_state *state = fe->tuner_priv;
+	struct it913xset *set_tuner = set_it9137_template;
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+	u32 bandwidth = p->bandwidth_hz;
+	u32 frequency_m = p->frequency;
+	int ret, reg;
+	u32 frequency = frequency_m / 1000;
+	u32 freq, temp_f, tmp;
+	u16 iqik_m_cal;
+	u16 n_div;
+	u8 n;
+	u8 l_band;
+	u8 lna_band;
+	u8 bw;
+
+	if (state->firmware_ver == 1)
+		set_tuner = set_it9135_template;
+	else
+		set_tuner = set_it9137_template;
+
+	dev_dbg(&state->i2c_adap->dev, "%s: Tuner Frequency %d Bandwidth %d\n",
+			__func__, frequency, bandwidth);
+
+	if (frequency >= 51000 && frequency <= 440000) {
+		l_band = 0;
+		lna_band = 0;
+	} else if (frequency > 440000 && frequency <= 484000) {
+		l_band = 1;
+		lna_band = 1;
+	} else if (frequency > 484000 && frequency <= 533000) {
+		l_band = 1;
+		lna_band = 2;
+	} else if (frequency > 533000 && frequency <= 587000) {
+		l_band = 1;
+		lna_band = 3;
+	} else if (frequency > 587000 && frequency <= 645000) {
+		l_band = 1;
+		lna_band = 4;
+	} else if (frequency > 645000 && frequency <= 710000) {
+		l_band = 1;
+		lna_band = 5;
+	} else if (frequency > 710000 && frequency <= 782000) {
+		l_band = 1;
+		lna_band = 6;
+	} else if (frequency > 782000 && frequency <= 860000) {
+		l_band = 1;
+		lna_band = 7;
+	} else if (frequency > 1450000 && frequency <= 1492000) {
+		l_band = 1;
+		lna_band = 0;
+	} else if (frequency > 1660000 && frequency <= 1685000) {
+		l_band = 1;
+		lna_band = 1;
+	} else
+		return -EINVAL;
+	set_tuner[0].reg[0] = lna_band;
+
+	switch (bandwidth) {
+	case 5000000:
+		bw = 0;
+		break;
+	case 6000000:
+		bw = 2;
+		break;
+	case 7000000:
+		bw = 4;
+		break;
+	default:
+	case 8000000:
+		bw = 6;
+		break;
+	}
+
+	set_tuner[1].reg[0] = bw;
+	set_tuner[2].reg[0] = 0xa0 | (l_band << 3);
+
+	if (frequency > 53000 && frequency <= 74000) {
+		n_div = 48;
+		n = 0;
+	} else if (frequency > 74000 && frequency <= 111000) {
+		n_div = 32;
+		n = 1;
+	} else if (frequency > 111000 && frequency <= 148000) {
+		n_div = 24;
+		n = 2;
+	} else if (frequency > 148000 && frequency <= 222000) {
+		n_div = 16;
+		n = 3;
+	} else if (frequency > 222000 && frequency <= 296000) {
+		n_div = 12;
+		n = 4;
+	} else if (frequency > 296000 && frequency <= 445000) {
+		n_div = 8;
+		n = 5;
+	} else if (frequency > 445000 && frequency <= state->tun_fn_min) {
+		n_div = 6;
+		n = 6;
+	} else if (frequency > state->tun_fn_min && frequency <= 950000) {
+		n_div = 4;
+		n = 7;
+	} else if (frequency > 1450000 && frequency <= 1680000) {
+		n_div = 2;
+		n = 0;
+	} else
+		return -EINVAL;
+
+	reg = it913x_rd_reg(state, 0xed81);
+	iqik_m_cal = (u16)reg * n_div;
+
+	if (reg < 0x20) {
+		if (state->tun_clk_mode == 0)
+			iqik_m_cal = (iqik_m_cal * 9) >> 5;
+		else
+			iqik_m_cal >>= 1;
+	} else {
+		iqik_m_cal = 0x40 - iqik_m_cal;
+		if (state->tun_clk_mode == 0)
+			iqik_m_cal = ~((iqik_m_cal * 9) >> 5);
+		else
+			iqik_m_cal = ~(iqik_m_cal >> 1);
+	}
+
+	temp_f = frequency * (u32)n_div * (u32)state->tun_fdiv;
+	freq = temp_f / state->tun_xtal;
+	tmp = freq * state->tun_xtal;
+
+	if ((temp_f - tmp) >= (state->tun_xtal >> 1))
+		freq++;
+
+	freq += (u32) n << 13;
+	/* Frequency OMEGA_IQIK_M_CAL_MID*/
+	temp_f = freq + (u32)iqik_m_cal;
+
+	set_tuner[3].reg[0] =  temp_f & 0xff;
+	set_tuner[4].reg[0] =  (temp_f >> 8) & 0xff;
+
+	dev_dbg(&state->i2c_adap->dev, "%s: High Frequency = %04x\n",
+			__func__, temp_f);
+
+	/* Lower frequency */
+	set_tuner[5].reg[0] =  freq & 0xff;
+	set_tuner[6].reg[0] =  (freq >> 8) & 0xff;
+
+	dev_dbg(&state->i2c_adap->dev, "%s: low Frequency = %04x\n",
+			__func__, freq);
+
+	ret = it913x_script_loader(state, set_tuner);
+
+	return (ret < 0) ? -ENODEV : 0;
+}
+
+/* Power sequence */
+/* Power Up	Tuner on -> Frontend suspend off -> Tuner clk on */
+/* Power Down	Frontend suspend on -> Tuner clk off -> Tuner off */
+
+static int it913x_sleep(struct dvb_frontend *fe)
+{
+	struct it913x_state *state = fe->tuner_priv;
+
+	if (state->chip_ver == 0x01)
+		return it913x_script_loader(state, it9135ax_tuner_off);
+	else
+		return it913x_script_loader(state, it9137_tuner_off);
+}
+
+static int it913x_release(struct dvb_frontend *fe)
+{
+	kfree(fe->tuner_priv);
+	return 0;
+}
+
+static const struct dvb_tuner_ops it913x_tuner_ops = {
+	.info = {
+		.name           = "ITE Tech IT913X",
+		.frequency_min  = 174000000,
+		.frequency_max  = 862000000,
+	},
+
+	.release = it913x_release,
+
+	.init = it913x_init,
+	.sleep = it913x_sleep,
+	.set_params = it9137_set_params,
+};
+
+struct dvb_frontend *it913x_attach(struct dvb_frontend *fe,
+		struct i2c_adapter *i2c_adap, u8 i2c_addr, u8 config)
+{
+	struct it913x_state *state = NULL;
+	int ret;
+
+	/* allocate memory for the internal state */
+	state = kzalloc(sizeof(struct it913x_state), GFP_KERNEL);
+	if (state == NULL)
+		return NULL;
+
+	state->i2c_adap = i2c_adap;
+	state->i2c_addr = i2c_addr;
+
+	switch (config) {
+	case AF9033_TUNER_IT9135_38:
+	case AF9033_TUNER_IT9135_51:
+	case AF9033_TUNER_IT9135_52:
+		state->chip_ver = 0x01;
+		break;
+	case AF9033_TUNER_IT9135_60:
+	case AF9033_TUNER_IT9135_61:
+	case AF9033_TUNER_IT9135_62:
+		state->chip_ver = 0x02;
+		break;
+	default:
+		dev_dbg(&i2c_adap->dev,
+				"%s: invalid config=%02x\n", __func__, config);
+		goto error;
+	}
+
+	state->tuner_type = config;
+	state->firmware_ver = 1;
+
+	/* tuner RF initial */
+	ret = it913x_wr_reg(state, PRO_DMOD, 0xec4c, 0x68);
+	if (ret < 0)
+		goto error;
+
+	fe->tuner_priv = state;
+	memcpy(&fe->ops.tuner_ops, &it913x_tuner_ops,
+			sizeof(struct dvb_tuner_ops));
+
+	dev_info(&i2c_adap->dev,
+			"%s: ITE Tech IT913X successfully attached\n",
+			KBUILD_MODNAME);
+	dev_dbg(&i2c_adap->dev, "%s: config=%02x chip_ver=%02x\n",
+			__func__, config, state->chip_ver);
+
+	return fe;
+error:
+	kfree(state);
+	return NULL;
+}
+EXPORT_SYMBOL(it913x_attach);
+
+MODULE_DESCRIPTION("ITE Tech IT913X silicon tuner driver");
+MODULE_AUTHOR("Antti Palosaari <crope@iki.fi>");
+MODULE_LICENSE("GPL");

commit 99ca5557fff4a4d1d87874384354d42f6c395e1a
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Tue Apr 16 19:43:06 2013 -0300

    [media] it913x: rename its tuner driver to tuner_it913x
    
    There are three drivers with *it913x name on it, and they all
    belong to the same device:
            a tuner, at it913x.c;
            a frontend: it913x-fe.c;
            a bridge: it913x.c, renamed to dvb_usb_it913x by the
    building system.
    
    This is confusing. Even more confusing are the two .c files with
    the same name under different directories, with different contents
    and different functions. So, prepend the tuner one.
    
    This also breaks the out-of-tree compilation system.
    
    Reported-by: Frederic Fays <frederic.fays@gmail.com>
    Acked-by: Antti Palosaari <crope@iki.fi>
    Reviewed-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/tuners/it913x.c b/drivers/media/tuners/it913x.c
deleted file mode 100644
index 4d7a24761050..000000000000
--- a/drivers/media/tuners/it913x.c
+++ /dev/null
@@ -1,447 +0,0 @@
-/*
- * ITE Tech IT9137 silicon tuner driver
- *
- *  Copyright (C) 2011 Malcolm Priestley (tvboxspy@gmail.com)
- *  IT9137 Copyright (C) ITE Tech Inc.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.=
- */
-
-#include "it913x_priv.h"
-
-struct it913x_state {
-	struct i2c_adapter *i2c_adap;
-	u8 i2c_addr;
-	u8 chip_ver;
-	u8 tuner_type;
-	u8 firmware_ver;
-	u16 tun_xtal;
-	u8 tun_fdiv;
-	u8 tun_clk_mode;
-	u32 tun_fn_min;
-};
-
-/* read multiple registers */
-static int it913x_rd_regs(struct it913x_state *state,
-		u32 reg, u8 *data, u8 count)
-{
-	int ret;
-	u8 b[3];
-	struct i2c_msg msg[2] = {
-		{ .addr = state->i2c_addr, .flags = 0,
-			.buf = b, .len = sizeof(b) },
-		{ .addr = state->i2c_addr, .flags = I2C_M_RD,
-			.buf = data, .len = count }
-	};
-	b[0] = (u8)(reg >> 16) & 0xff;
-	b[1] = (u8)(reg >> 8) & 0xff;
-	b[2] = (u8) reg & 0xff;
-	b[0] |= 0x80; /* All reads from demodulator */
-
-	ret = i2c_transfer(state->i2c_adap, msg, 2);
-
-	return ret;
-}
-
-/* read single register */
-static int it913x_rd_reg(struct it913x_state *state, u32 reg)
-{
-	int ret;
-	u8 b[1];
-	ret = it913x_rd_regs(state, reg, &b[0], sizeof(b));
-	return (ret < 0) ? -ENODEV : b[0];
-}
-
-/* write multiple registers */
-static int it913x_wr_regs(struct it913x_state *state,
-		u8 pro, u32 reg, u8 buf[], u8 count)
-{
-	u8 b[256];
-	struct i2c_msg msg[1] = {
-		{ .addr = state->i2c_addr, .flags = 0,
-		  .buf = b, .len = 3 + count }
-	};
-	int ret;
-	b[0] = (u8)(reg >> 16) & 0xff;
-	b[1] = (u8)(reg >> 8) & 0xff;
-	b[2] = (u8) reg & 0xff;
-	memcpy(&b[3], buf, count);
-
-	if (pro == PRO_DMOD)
-		b[0] |= 0x80;
-
-	ret = i2c_transfer(state->i2c_adap, msg, 1);
-
-	if (ret < 0)
-		return -EIO;
-
-	return 0;
-}
-
-/* write single register */
-static int it913x_wr_reg(struct it913x_state *state,
-		u8 pro, u32 reg, u32 data)
-{
-	int ret;
-	u8 b[4];
-	u8 s;
-
-	b[0] = data >> 24;
-	b[1] = (data >> 16) & 0xff;
-	b[2] = (data >> 8) & 0xff;
-	b[3] = data & 0xff;
-	/* expand write as needed */
-	if (data < 0x100)
-		s = 3;
-	else if (data < 0x1000)
-		s = 2;
-	else if (data < 0x100000)
-		s = 1;
-	else
-		s = 0;
-
-	ret = it913x_wr_regs(state, pro, reg, &b[s], sizeof(b) - s);
-
-	return ret;
-}
-
-static int it913x_script_loader(struct it913x_state *state,
-		struct it913xset *loadscript)
-{
-	int ret, i;
-	if (loadscript == NULL)
-		return -EINVAL;
-
-	for (i = 0; i < 1000; ++i) {
-		if (loadscript[i].pro == 0xff)
-			break;
-		ret = it913x_wr_regs(state, loadscript[i].pro,
-			loadscript[i].address,
-			loadscript[i].reg, loadscript[i].count);
-		if (ret < 0)
-			return -ENODEV;
-	}
-	return 0;
-}
-
-static int it913x_init(struct dvb_frontend *fe)
-{
-	struct it913x_state *state = fe->tuner_priv;
-	int ret, i, reg;
-	u8 val, nv_val;
-	u8 nv[] = {48, 32, 24, 16, 12, 8, 6, 4, 2};
-	u8 b[2];
-
-	reg = it913x_rd_reg(state, 0xec86);
-	switch (reg) {
-	case 0:
-		state->tun_clk_mode = reg;
-		state->tun_xtal = 2000;
-		state->tun_fdiv = 3;
-		val = 16;
-		break;
-	case -ENODEV:
-		return -ENODEV;
-	case 1:
-	default:
-		state->tun_clk_mode = reg;
-		state->tun_xtal = 640;
-		state->tun_fdiv = 1;
-		val = 6;
-		break;
-	}
-
-	reg = it913x_rd_reg(state, 0xed03);
-
-	if (reg < 0)
-		return -ENODEV;
-	else if (reg < ARRAY_SIZE(nv))
-		nv_val = nv[reg];
-	else
-		nv_val = 2;
-
-	for (i = 0; i < 50; i++) {
-		ret = it913x_rd_regs(state, 0xed23, &b[0], sizeof(b));
-		reg = (b[1] << 8) + b[0];
-		if (reg > 0)
-			break;
-		if (ret < 0)
-			return -ENODEV;
-		udelay(2000);
-	}
-	state->tun_fn_min = state->tun_xtal * reg;
-	state->tun_fn_min /= (state->tun_fdiv * nv_val);
-	dev_dbg(&state->i2c_adap->dev, "%s: Tuner fn_min %d\n", __func__,
-			state->tun_fn_min);
-
-	if (state->chip_ver > 1)
-		msleep(50);
-	else {
-		for (i = 0; i < 50; i++) {
-			reg = it913x_rd_reg(state, 0xec82);
-			if (reg > 0)
-				break;
-			if (reg < 0)
-				return -ENODEV;
-			udelay(2000);
-		}
-	}
-
-	/* Power Up Tuner - common all versions */
-	ret = it913x_wr_reg(state, PRO_DMOD, 0xec40, 0x1);
-	ret |= it913x_wr_reg(state, PRO_DMOD, 0xfba8, 0x0);
-	ret |= it913x_wr_reg(state, PRO_DMOD, 0xec57, 0x0);
-	ret |= it913x_wr_reg(state, PRO_DMOD, 0xec58, 0x0);
-
-	return it913x_wr_reg(state, PRO_DMOD, 0xed81, val);
-}
-
-static int it9137_set_params(struct dvb_frontend *fe)
-{
-	struct it913x_state *state = fe->tuner_priv;
-	struct it913xset *set_tuner = set_it9137_template;
-	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
-	u32 bandwidth = p->bandwidth_hz;
-	u32 frequency_m = p->frequency;
-	int ret, reg;
-	u32 frequency = frequency_m / 1000;
-	u32 freq, temp_f, tmp;
-	u16 iqik_m_cal;
-	u16 n_div;
-	u8 n;
-	u8 l_band;
-	u8 lna_band;
-	u8 bw;
-
-	if (state->firmware_ver == 1)
-		set_tuner = set_it9135_template;
-	else
-		set_tuner = set_it9137_template;
-
-	dev_dbg(&state->i2c_adap->dev, "%s: Tuner Frequency %d Bandwidth %d\n",
-			__func__, frequency, bandwidth);
-
-	if (frequency >= 51000 && frequency <= 440000) {
-		l_band = 0;
-		lna_band = 0;
-	} else if (frequency > 440000 && frequency <= 484000) {
-		l_band = 1;
-		lna_band = 1;
-	} else if (frequency > 484000 && frequency <= 533000) {
-		l_band = 1;
-		lna_band = 2;
-	} else if (frequency > 533000 && frequency <= 587000) {
-		l_band = 1;
-		lna_band = 3;
-	} else if (frequency > 587000 && frequency <= 645000) {
-		l_band = 1;
-		lna_band = 4;
-	} else if (frequency > 645000 && frequency <= 710000) {
-		l_band = 1;
-		lna_band = 5;
-	} else if (frequency > 710000 && frequency <= 782000) {
-		l_band = 1;
-		lna_band = 6;
-	} else if (frequency > 782000 && frequency <= 860000) {
-		l_band = 1;
-		lna_band = 7;
-	} else if (frequency > 1450000 && frequency <= 1492000) {
-		l_band = 1;
-		lna_band = 0;
-	} else if (frequency > 1660000 && frequency <= 1685000) {
-		l_band = 1;
-		lna_band = 1;
-	} else
-		return -EINVAL;
-	set_tuner[0].reg[0] = lna_band;
-
-	switch (bandwidth) {
-	case 5000000:
-		bw = 0;
-		break;
-	case 6000000:
-		bw = 2;
-		break;
-	case 7000000:
-		bw = 4;
-		break;
-	default:
-	case 8000000:
-		bw = 6;
-		break;
-	}
-
-	set_tuner[1].reg[0] = bw;
-	set_tuner[2].reg[0] = 0xa0 | (l_band << 3);
-
-	if (frequency > 53000 && frequency <= 74000) {
-		n_div = 48;
-		n = 0;
-	} else if (frequency > 74000 && frequency <= 111000) {
-		n_div = 32;
-		n = 1;
-	} else if (frequency > 111000 && frequency <= 148000) {
-		n_div = 24;
-		n = 2;
-	} else if (frequency > 148000 && frequency <= 222000) {
-		n_div = 16;
-		n = 3;
-	} else if (frequency > 222000 && frequency <= 296000) {
-		n_div = 12;
-		n = 4;
-	} else if (frequency > 296000 && frequency <= 445000) {
-		n_div = 8;
-		n = 5;
-	} else if (frequency > 445000 && frequency <= state->tun_fn_min) {
-		n_div = 6;
-		n = 6;
-	} else if (frequency > state->tun_fn_min && frequency <= 950000) {
-		n_div = 4;
-		n = 7;
-	} else if (frequency > 1450000 && frequency <= 1680000) {
-		n_div = 2;
-		n = 0;
-	} else
-		return -EINVAL;
-
-	reg = it913x_rd_reg(state, 0xed81);
-	iqik_m_cal = (u16)reg * n_div;
-
-	if (reg < 0x20) {
-		if (state->tun_clk_mode == 0)
-			iqik_m_cal = (iqik_m_cal * 9) >> 5;
-		else
-			iqik_m_cal >>= 1;
-	} else {
-		iqik_m_cal = 0x40 - iqik_m_cal;
-		if (state->tun_clk_mode == 0)
-			iqik_m_cal = ~((iqik_m_cal * 9) >> 5);
-		else
-			iqik_m_cal = ~(iqik_m_cal >> 1);
-	}
-
-	temp_f = frequency * (u32)n_div * (u32)state->tun_fdiv;
-	freq = temp_f / state->tun_xtal;
-	tmp = freq * state->tun_xtal;
-
-	if ((temp_f - tmp) >= (state->tun_xtal >> 1))
-		freq++;
-
-	freq += (u32) n << 13;
-	/* Frequency OMEGA_IQIK_M_CAL_MID*/
-	temp_f = freq + (u32)iqik_m_cal;
-
-	set_tuner[3].reg[0] =  temp_f & 0xff;
-	set_tuner[4].reg[0] =  (temp_f >> 8) & 0xff;
-
-	dev_dbg(&state->i2c_adap->dev, "%s: High Frequency = %04x\n",
-			__func__, temp_f);
-
-	/* Lower frequency */
-	set_tuner[5].reg[0] =  freq & 0xff;
-	set_tuner[6].reg[0] =  (freq >> 8) & 0xff;
-
-	dev_dbg(&state->i2c_adap->dev, "%s: low Frequency = %04x\n",
-			__func__, freq);
-
-	ret = it913x_script_loader(state, set_tuner);
-
-	return (ret < 0) ? -ENODEV : 0;
-}
-
-/* Power sequence */
-/* Power Up	Tuner on -> Frontend suspend off -> Tuner clk on */
-/* Power Down	Frontend suspend on -> Tuner clk off -> Tuner off */
-
-static int it913x_sleep(struct dvb_frontend *fe)
-{
-	struct it913x_state *state = fe->tuner_priv;
-	return it913x_script_loader(state, it9137_tuner_off);
-}
-
-static int it913x_release(struct dvb_frontend *fe)
-{
-	kfree(fe->tuner_priv);
-	return 0;
-}
-
-static const struct dvb_tuner_ops it913x_tuner_ops = {
-	.info = {
-		.name           = "ITE Tech IT913X",
-		.frequency_min  = 174000000,
-		.frequency_max  = 862000000,
-	},
-
-	.release = it913x_release,
-
-	.init = it913x_init,
-	.sleep = it913x_sleep,
-	.set_params = it9137_set_params,
-};
-
-struct dvb_frontend *it913x_attach(struct dvb_frontend *fe,
-		struct i2c_adapter *i2c_adap, u8 i2c_addr, u8 config)
-{
-	struct it913x_state *state = NULL;
-
-	/* allocate memory for the internal state */
-	state = kzalloc(sizeof(struct it913x_state), GFP_KERNEL);
-	if (state == NULL)
-		return NULL;
-
-	state->i2c_adap = i2c_adap;
-	state->i2c_addr = i2c_addr;
-
-	switch (config) {
-	case AF9033_TUNER_IT9135_38:
-	case AF9033_TUNER_IT9135_51:
-	case AF9033_TUNER_IT9135_52:
-		state->chip_ver = 0x01;
-		break;
-	case AF9033_TUNER_IT9135_60:
-	case AF9033_TUNER_IT9135_61:
-	case AF9033_TUNER_IT9135_62:
-		state->chip_ver = 0x02;
-		break;
-	default:
-		dev_dbg(&i2c_adap->dev,
-				"%s: invalid config=%02x\n", __func__, config);
-		goto error;
-	}
-
-	state->tuner_type = config;
-	state->firmware_ver = 1;
-
-	fe->tuner_priv = state;
-	memcpy(&fe->ops.tuner_ops, &it913x_tuner_ops,
-			sizeof(struct dvb_tuner_ops));
-
-	dev_info(&i2c_adap->dev,
-			"%s: ITE Tech IT913X successfully attached\n",
-			KBUILD_MODNAME);
-	dev_dbg(&i2c_adap->dev, "%s: config=%02x chip_ver=%02x\n",
-			__func__, config, state->chip_ver);
-
-	return fe;
-error:
-	kfree(state);
-	return NULL;
-}
-EXPORT_SYMBOL(it913x_attach);
-
-MODULE_DESCRIPTION("ITE Tech IT913X silicon tuner driver");
-MODULE_AUTHOR("Antti Palosaari <crope@iki.fi>");
-MODULE_LICENSE("GPL");

commit 086991dd106bda1c43a294a874563322e0d777e4
Author: Antti Palosaari <crope@iki.fi>
Date:   Thu Mar 7 22:18:56 2013 -0300

    [media] af9033: move code from it913x to af9033
    
    That register is property of demodulator so move it correct place.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/tuners/it913x.c b/drivers/media/tuners/it913x.c
index 2c60bf77ebfc..4d7a24761050 100644
--- a/drivers/media/tuners/it913x.c
+++ b/drivers/media/tuners/it913x.c
@@ -145,12 +145,6 @@ static int it913x_init(struct dvb_frontend *fe)
 	u8 nv[] = {48, 32, 24, 16, 12, 8, 6, 4, 2};
 	u8 b[2];
 
-	if (state->chip_ver == 2) {
-		ret = it913x_wr_reg(state, PRO_DMOD, TRIGGER_OFSM, 0x1);
-		if (ret < 0)
-			return -ENODEV;
-	}
-
 	reg = it913x_rd_reg(state, 0xec86);
 	switch (reg) {
 	case 0:

commit d423e108c1d6ced41964fafc97c02e4b5d0597a1
Author: Antti Palosaari <crope@iki.fi>
Date:   Thu Mar 7 21:59:41 2013 -0300

    [media] it913x: remove unused af9033 demod tuner config inits
    
    Those are demodulator init tables according to used tuner tuner
    config. af9033 demod driver does those inits currently and due
    to that these duplicate inits could be removed.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/tuners/it913x.c b/drivers/media/tuners/it913x.c
index ec4964ce8a58..2c60bf77ebfc 100644
--- a/drivers/media/tuners/it913x.c
+++ b/drivers/media/tuners/it913x.c
@@ -141,40 +141,10 @@ static int it913x_init(struct dvb_frontend *fe)
 {
 	struct it913x_state *state = fe->tuner_priv;
 	int ret, i, reg;
-	struct it913xset *set_lna;
 	u8 val, nv_val;
 	u8 nv[] = {48, 32, 24, 16, 12, 8, 6, 4, 2};
 	u8 b[2];
 
-	/* LNA Scripts */
-	switch (state->tuner_type) {
-	case AF9033_TUNER_IT9135_51:
-		set_lna = it9135_51;
-		break;
-	case AF9033_TUNER_IT9135_52:
-		set_lna = it9135_52;
-		break;
-	case AF9033_TUNER_IT9135_60:
-		set_lna = it9135_60;
-		break;
-	case AF9033_TUNER_IT9135_61:
-		set_lna = it9135_61;
-		break;
-	case AF9033_TUNER_IT9135_62:
-		set_lna = it9135_62;
-		break;
-	case AF9033_TUNER_IT9135_38:
-	default:
-		set_lna = it9135_38;
-	}
-
-	dev_dbg(&state->i2c_adap->dev, "%s: Tuner LNA type :%02x\n",
-			KBUILD_MODNAME, state->tuner_type);
-
-	ret = it913x_script_loader(state, set_lna);
-	if (ret < 0)
-		return ret;
-
 	if (state->chip_ver == 2) {
 		ret = it913x_wr_reg(state, PRO_DMOD, TRIGGER_OFSM, 0x1);
 		if (ret < 0)

commit 9d7b848e4311a77a9c62df481278e6efb23cba4a
Author: Antti Palosaari <crope@iki.fi>
Date:   Thu Mar 7 00:09:36 2013 -0300

    [media] it913x: remove demod init reg tables
    
    These are demod inits and are already done by af9033 demod driver.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/tuners/it913x.c b/drivers/media/tuners/it913x.c
index 66e003f5316e..ec4964ce8a58 100644
--- a/drivers/media/tuners/it913x.c
+++ b/drivers/media/tuners/it913x.c
@@ -146,14 +146,6 @@ static int it913x_init(struct dvb_frontend *fe)
 	u8 nv[] = {48, 32, 24, 16, 12, 8, 6, 4, 2};
 	u8 b[2];
 
-	/* v1 or v2 tuner script */
-	if (state->chip_ver > 1)
-		ret = it913x_script_loader(state, it9135_v2);
-	else
-		ret = it913x_script_loader(state, it9135_v1);
-	if (ret < 0)
-		return ret;
-
 	/* LNA Scripts */
 	switch (state->tuner_type) {
 	case AF9033_TUNER_IT9135_51:

commit cfd08f0fb9b761c44e4d853c5b38f7fc7c3f5325
Author: Antti Palosaari <crope@iki.fi>
Date:   Thu Feb 28 20:54:44 2013 -0300

    [media] it913x: use dev_foo() logging
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/tuners/it913x.c b/drivers/media/tuners/it913x.c
index 1cb97092f562..66e003f5316e 100644
--- a/drivers/media/tuners/it913x.c
+++ b/drivers/media/tuners/it913x.c
@@ -175,7 +175,9 @@ static int it913x_init(struct dvb_frontend *fe)
 	default:
 		set_lna = it9135_38;
 	}
-	pr_info("Tuner LNA type :%02x\n", state->tuner_type);
+
+	dev_dbg(&state->i2c_adap->dev, "%s: Tuner LNA type :%02x\n",
+			KBUILD_MODNAME, state->tuner_type);
 
 	ret = it913x_script_loader(state, set_lna);
 	if (ret < 0)
@@ -226,7 +228,8 @@ static int it913x_init(struct dvb_frontend *fe)
 	}
 	state->tun_fn_min = state->tun_xtal * reg;
 	state->tun_fn_min /= (state->tun_fdiv * nv_val);
-	pr_debug("Tuner fn_min %d\n", state->tun_fn_min);
+	dev_dbg(&state->i2c_adap->dev, "%s: Tuner fn_min %d\n", __func__,
+			state->tun_fn_min);
 
 	if (state->chip_ver > 1)
 		msleep(50);
@@ -272,7 +275,8 @@ static int it9137_set_params(struct dvb_frontend *fe)
 	else
 		set_tuner = set_it9137_template;
 
-	pr_debug("Tuner Frequency %d Bandwidth %d\n", frequency, bandwidth);
+	dev_dbg(&state->i2c_adap->dev, "%s: Tuner Frequency %d Bandwidth %d\n",
+			__func__, frequency, bandwidth);
 
 	if (frequency >= 51000 && frequency <= 440000) {
 		l_band = 0;
@@ -387,13 +391,15 @@ static int it9137_set_params(struct dvb_frontend *fe)
 	set_tuner[3].reg[0] =  temp_f & 0xff;
 	set_tuner[4].reg[0] =  (temp_f >> 8) & 0xff;
 
-	pr_debug("High Frequency = %04x\n", temp_f);
+	dev_dbg(&state->i2c_adap->dev, "%s: High Frequency = %04x\n",
+			__func__, temp_f);
 
 	/* Lower frequency */
 	set_tuner[5].reg[0] =  freq & 0xff;
 	set_tuner[6].reg[0] =  (freq >> 8) & 0xff;
 
-	pr_debug("low Frequency = %04x\n", freq);
+	dev_dbg(&state->i2c_adap->dev, "%s: low Frequency = %04x\n",
+			__func__, freq);
 
 	ret = it913x_script_loader(state, set_tuner);
 

commit c0d300a66979c7a836c75f6e2d33727543245368
Author: Antti Palosaari <crope@iki.fi>
Date:   Thu Feb 28 20:14:38 2013 -0300

    [media] it913x: include tuner IDs from af9033.h
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/tuners/it913x.c b/drivers/media/tuners/it913x.c
index 6ae9d5ae9654..1cb97092f562 100644
--- a/drivers/media/tuners/it913x.c
+++ b/drivers/media/tuners/it913x.c
@@ -156,22 +156,22 @@ static int it913x_init(struct dvb_frontend *fe)
 
 	/* LNA Scripts */
 	switch (state->tuner_type) {
-	case IT9135_51:
+	case AF9033_TUNER_IT9135_51:
 		set_lna = it9135_51;
 		break;
-	case IT9135_52:
+	case AF9033_TUNER_IT9135_52:
 		set_lna = it9135_52;
 		break;
-	case IT9135_60:
+	case AF9033_TUNER_IT9135_60:
 		set_lna = it9135_60;
 		break;
-	case IT9135_61:
+	case AF9033_TUNER_IT9135_61:
 		set_lna = it9135_61;
 		break;
-	case IT9135_62:
+	case AF9033_TUNER_IT9135_62:
 		set_lna = it9135_62;
 		break;
-	case IT9135_38:
+	case AF9033_TUNER_IT9135_38:
 	default:
 		set_lna = it9135_38;
 	}
@@ -444,14 +444,14 @@ struct dvb_frontend *it913x_attach(struct dvb_frontend *fe,
 	state->i2c_addr = i2c_addr;
 
 	switch (config) {
-	case IT9135_38:
-	case IT9135_51:
-	case IT9135_52:
+	case AF9033_TUNER_IT9135_38:
+	case AF9033_TUNER_IT9135_51:
+	case AF9033_TUNER_IT9135_52:
 		state->chip_ver = 0x01;
 		break;
-	case IT9135_60:
-	case IT9135_61:
-	case IT9135_62:
+	case AF9033_TUNER_IT9135_60:
+	case AF9033_TUNER_IT9135_61:
+	case AF9033_TUNER_IT9135_62:
 		state->chip_ver = 0x02;
 		break;
 	default:

commit 108597979297c75646889e307e276db57aa6d5b8
Author: Antti Palosaari <crope@iki.fi>
Date:   Thu Feb 28 19:02:19 2013 -0300

    [media] it913x: remove unused variables
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/tuners/it913x.c b/drivers/media/tuners/it913x.c
index 66d4b72d97ab..6ae9d5ae9654 100644
--- a/drivers/media/tuners/it913x.c
+++ b/drivers/media/tuners/it913x.c
@@ -23,25 +23,15 @@
 #include "it913x_priv.h"
 
 struct it913x_state {
-	struct dvb_frontend frontend;
 	struct i2c_adapter *i2c_adap;
-	u8 chip_ver;
-	u8 firmware_ver;
 	u8 i2c_addr;
-	u32 frequency;
-	fe_modulation_t constellation;
-	fe_transmit_mode_t transmission_mode;
-	u8 priority;
-	u32 crystalFrequency;
-	u32 adcFrequency;
+	u8 chip_ver;
 	u8 tuner_type;
-	struct adctable *table;
-	fe_status_t it913x_status;
+	u8 firmware_ver;
 	u16 tun_xtal;
 	u8 tun_fdiv;
 	u8 tun_clk_mode;
 	u32 tun_fn_min;
-	u32 ucblocks;
 };
 
 /* read multiple registers */

commit 44af747f4e0174d5dbc8c565a4d329dbcf599921
Author: Antti Palosaari <crope@iki.fi>
Date:   Thu Feb 28 00:14:06 2013 -0300

    [media] it913x: get rid of it913x config struct
    
    We don't need it. Tuner ID and device address are enough.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/tuners/it913x.c b/drivers/media/tuners/it913x.c
index de20da1548aa..66d4b72d97ab 100644
--- a/drivers/media/tuners/it913x.c
+++ b/drivers/media/tuners/it913x.c
@@ -25,7 +25,8 @@
 struct it913x_state {
 	struct dvb_frontend frontend;
 	struct i2c_adapter *i2c_adap;
-	struct ite_config *config;
+	u8 chip_ver;
+	u8 firmware_ver;
 	u8 i2c_addr;
 	u32 frequency;
 	fe_modulation_t constellation;
@@ -156,7 +157,7 @@ static int it913x_init(struct dvb_frontend *fe)
 	u8 b[2];
 
 	/* v1 or v2 tuner script */
-	if (state->config->chip_ver > 1)
+	if (state->chip_ver > 1)
 		ret = it913x_script_loader(state, it9135_v2);
 	else
 		ret = it913x_script_loader(state, it9135_v1);
@@ -190,7 +191,7 @@ static int it913x_init(struct dvb_frontend *fe)
 	if (ret < 0)
 		return ret;
 
-	if (state->config->chip_ver == 2) {
+	if (state->chip_ver == 2) {
 		ret = it913x_wr_reg(state, PRO_DMOD, TRIGGER_OFSM, 0x1);
 		if (ret < 0)
 			return -ENODEV;
@@ -237,7 +238,7 @@ static int it913x_init(struct dvb_frontend *fe)
 	state->tun_fn_min /= (state->tun_fdiv * nv_val);
 	pr_debug("Tuner fn_min %d\n", state->tun_fn_min);
 
-	if (state->config->chip_ver > 1)
+	if (state->chip_ver > 1)
 		msleep(50);
 	else {
 		for (i = 0; i < 50; i++) {
@@ -276,7 +277,7 @@ static int it9137_set_params(struct dvb_frontend *fe)
 	u8 lna_band;
 	u8 bw;
 
-	if (state->config->firmware_ver == 1)
+	if (state->firmware_ver == 1)
 		set_tuner = set_it9135_template;
 	else
 		set_tuner = set_it9137_template;
@@ -440,40 +441,47 @@ static const struct dvb_tuner_ops it913x_tuner_ops = {
 };
 
 struct dvb_frontend *it913x_attach(struct dvb_frontend *fe,
-	struct i2c_adapter *i2c_adap, u8 i2c_addr, struct ite_config *config)
+		struct i2c_adapter *i2c_adap, u8 i2c_addr, u8 config)
 {
 	struct it913x_state *state = NULL;
-	int ret;
 
 	/* allocate memory for the internal state */
 	state = kzalloc(sizeof(struct it913x_state), GFP_KERNEL);
 	if (state == NULL)
 		return NULL;
-	if (config == NULL)
-		goto error;
 
 	state->i2c_adap = i2c_adap;
 	state->i2c_addr = i2c_addr;
-	state->config = config;
 
-	switch (state->config->tuner_id_0) {
+	switch (config) {
+	case IT9135_38:
 	case IT9135_51:
 	case IT9135_52:
+		state->chip_ver = 0x01;
+		break;
 	case IT9135_60:
 	case IT9135_61:
 	case IT9135_62:
-		state->tuner_type = state->config->tuner_id_0;
+		state->chip_ver = 0x02;
 		break;
 	default:
-	case IT9135_38:
-		state->tuner_type = IT9135_38;
+		dev_dbg(&i2c_adap->dev,
+				"%s: invalid config=%02x\n", __func__, config);
+		goto error;
 	}
 
+	state->tuner_type = config;
+	state->firmware_ver = 1;
+
 	fe->tuner_priv = state;
 	memcpy(&fe->ops.tuner_ops, &it913x_tuner_ops,
 			sizeof(struct dvb_tuner_ops));
 
-	pr_info("%s: ITE Tech IT913X attached\n", KBUILD_MODNAME);
+	dev_info(&i2c_adap->dev,
+			"%s: ITE Tech IT913X successfully attached\n",
+			KBUILD_MODNAME);
+	dev_dbg(&i2c_adap->dev, "%s: config=%02x chip_ver=%02x\n",
+			__func__, config, state->chip_ver);
 
 	return fe;
 error:

commit d19812eb5f1efed3fa0ba5d752da5f24d8c89701
Author: Antti Palosaari <crope@iki.fi>
Date:   Wed Feb 27 23:29:02 2013 -0300

    [media] it913x: tuner power up routines
    
    Copy forgotten power up registers from it913x-fe driver.
    Remove two demod registers as those are already written
    by af9033 driver.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/tuners/it913x.c b/drivers/media/tuners/it913x.c
index 82cc053bc998..de20da1548aa 100644
--- a/drivers/media/tuners/it913x.c
+++ b/drivers/media/tuners/it913x.c
@@ -192,11 +192,9 @@ static int it913x_init(struct dvb_frontend *fe)
 
 	if (state->config->chip_ver == 2) {
 		ret = it913x_wr_reg(state, PRO_DMOD, TRIGGER_OFSM, 0x1);
-		ret |= it913x_wr_reg(state, PRO_LINK, PADODPU, 0x0);
-		ret |= it913x_wr_reg(state, PRO_LINK, AGC_O_D, 0x0);
+		if (ret < 0)
+			return -ENODEV;
 	}
-	if (ret < 0)
-		return -ENODEV;
 
 	reg = it913x_rd_reg(state, 0xec86);
 	switch (reg) {
@@ -252,6 +250,12 @@ static int it913x_init(struct dvb_frontend *fe)
 		}
 	}
 
+	/* Power Up Tuner - common all versions */
+	ret = it913x_wr_reg(state, PRO_DMOD, 0xec40, 0x1);
+	ret |= it913x_wr_reg(state, PRO_DMOD, 0xfba8, 0x0);
+	ret |= it913x_wr_reg(state, PRO_DMOD, 0xec57, 0x0);
+	ret |= it913x_wr_reg(state, PRO_DMOD, 0xec58, 0x0);
+
 	return it913x_wr_reg(state, PRO_DMOD, 0xed81, val);
 }
 

commit 42432b3ce89eaf817284f0c6ff81dfd7b4ed35b3
Author: Antti Palosaari <crope@iki.fi>
Date:   Tue Feb 26 20:57:01 2013 -0300

    [media] it913x: rename functions and variables
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/tuners/it913x.c b/drivers/media/tuners/it913x.c
index 6eb3afa32db6..82cc053bc998 100644
--- a/drivers/media/tuners/it913x.c
+++ b/drivers/media/tuners/it913x.c
@@ -22,7 +22,7 @@
 
 #include "it913x_priv.h"
 
-struct it913x_fe_state {
+struct it913x_state {
 	struct dvb_frontend frontend;
 	struct i2c_adapter *i2c_adap;
 	struct ite_config *config;
@@ -43,7 +43,8 @@ struct it913x_fe_state {
 	u32 ucblocks;
 };
 
-static int it913x_read_reg(struct it913x_fe_state *state,
+/* read multiple registers */
+static int it913x_rd_regs(struct it913x_state *state,
 		u32 reg, u8 *data, u8 count)
 {
 	int ret;
@@ -64,15 +65,17 @@ static int it913x_read_reg(struct it913x_fe_state *state,
 	return ret;
 }
 
-static int it913x_read_reg_u8(struct it913x_fe_state *state, u32 reg)
+/* read single register */
+static int it913x_rd_reg(struct it913x_state *state, u32 reg)
 {
 	int ret;
 	u8 b[1];
-	ret = it913x_read_reg(state, reg, &b[0], sizeof(b));
+	ret = it913x_rd_regs(state, reg, &b[0], sizeof(b));
 	return (ret < 0) ? -ENODEV : b[0];
 }
 
-static int it913x_write(struct it913x_fe_state *state,
+/* write multiple registers */
+static int it913x_wr_regs(struct it913x_state *state,
 		u8 pro, u32 reg, u8 buf[], u8 count)
 {
 	u8 b[256];
@@ -97,7 +100,8 @@ static int it913x_write(struct it913x_fe_state *state,
 	return 0;
 }
 
-static int it913x_write_reg(struct it913x_fe_state *state,
+/* write single register */
+static int it913x_wr_reg(struct it913x_state *state,
 		u8 pro, u32 reg, u32 data)
 {
 	int ret;
@@ -118,12 +122,12 @@ static int it913x_write_reg(struct it913x_fe_state *state,
 	else
 		s = 0;
 
-	ret = it913x_write(state, pro, reg, &b[s], sizeof(b) - s);
+	ret = it913x_wr_regs(state, pro, reg, &b[s], sizeof(b) - s);
 
 	return ret;
 }
 
-static int it913x_fe_script_loader(struct it913x_fe_state *state,
+static int it913x_script_loader(struct it913x_state *state,
 		struct it913xset *loadscript)
 {
 	int ret, i;
@@ -133,7 +137,7 @@ static int it913x_fe_script_loader(struct it913x_fe_state *state,
 	for (i = 0; i < 1000; ++i) {
 		if (loadscript[i].pro == 0xff)
 			break;
-		ret = it913x_write(state, loadscript[i].pro,
+		ret = it913x_wr_regs(state, loadscript[i].pro,
 			loadscript[i].address,
 			loadscript[i].reg, loadscript[i].count);
 		if (ret < 0)
@@ -142,9 +146,9 @@ static int it913x_fe_script_loader(struct it913x_fe_state *state,
 	return 0;
 }
 
-static int it913x_init_tuner(struct dvb_frontend *fe)
+static int it913x_init(struct dvb_frontend *fe)
 {
-	struct it913x_fe_state *state = fe->tuner_priv;
+	struct it913x_state *state = fe->tuner_priv;
 	int ret, i, reg;
 	struct it913xset *set_lna;
 	u8 val, nv_val;
@@ -153,9 +157,9 @@ static int it913x_init_tuner(struct dvb_frontend *fe)
 
 	/* v1 or v2 tuner script */
 	if (state->config->chip_ver > 1)
-		ret = it913x_fe_script_loader(state, it9135_v2);
+		ret = it913x_script_loader(state, it9135_v2);
 	else
-		ret = it913x_fe_script_loader(state, it9135_v1);
+		ret = it913x_script_loader(state, it9135_v1);
 	if (ret < 0)
 		return ret;
 
@@ -182,19 +186,19 @@ static int it913x_init_tuner(struct dvb_frontend *fe)
 	}
 	pr_info("Tuner LNA type :%02x\n", state->tuner_type);
 
-	ret = it913x_fe_script_loader(state, set_lna);
+	ret = it913x_script_loader(state, set_lna);
 	if (ret < 0)
 		return ret;
 
 	if (state->config->chip_ver == 2) {
-		ret = it913x_write_reg(state, PRO_DMOD, TRIGGER_OFSM, 0x1);
-		ret |= it913x_write_reg(state, PRO_LINK, PADODPU, 0x0);
-		ret |= it913x_write_reg(state, PRO_LINK, AGC_O_D, 0x0);
+		ret = it913x_wr_reg(state, PRO_DMOD, TRIGGER_OFSM, 0x1);
+		ret |= it913x_wr_reg(state, PRO_LINK, PADODPU, 0x0);
+		ret |= it913x_wr_reg(state, PRO_LINK, AGC_O_D, 0x0);
 	}
 	if (ret < 0)
 		return -ENODEV;
 
-	reg = it913x_read_reg_u8(state, 0xec86);
+	reg = it913x_rd_reg(state, 0xec86);
 	switch (reg) {
 	case 0:
 		state->tun_clk_mode = reg;
@@ -213,7 +217,7 @@ static int it913x_init_tuner(struct dvb_frontend *fe)
 		break;
 	}
 
-	reg = it913x_read_reg_u8(state, 0xed03);
+	reg = it913x_rd_reg(state, 0xed03);
 
 	if (reg < 0)
 		return -ENODEV;
@@ -223,7 +227,7 @@ static int it913x_init_tuner(struct dvb_frontend *fe)
 		nv_val = 2;
 
 	for (i = 0; i < 50; i++) {
-		ret = it913x_read_reg(state, 0xed23, &b[0], sizeof(b));
+		ret = it913x_rd_regs(state, 0xed23, &b[0], sizeof(b));
 		reg = (b[1] << 8) + b[0];
 		if (reg > 0)
 			break;
@@ -239,7 +243,7 @@ static int it913x_init_tuner(struct dvb_frontend *fe)
 		msleep(50);
 	else {
 		for (i = 0; i < 50; i++) {
-			reg = it913x_read_reg_u8(state, 0xec82);
+			reg = it913x_rd_reg(state, 0xec82);
 			if (reg > 0)
 				break;
 			if (reg < 0)
@@ -248,12 +252,12 @@ static int it913x_init_tuner(struct dvb_frontend *fe)
 		}
 	}
 
-	return it913x_write_reg(state, PRO_DMOD, 0xed81, val);
+	return it913x_wr_reg(state, PRO_DMOD, 0xed81, val);
 }
 
-static int it9137_set_tuner(struct dvb_frontend *fe)
+static int it9137_set_params(struct dvb_frontend *fe)
 {
-	struct it913x_fe_state *state = fe->tuner_priv;
+	struct it913x_state *state = fe->tuner_priv;
 	struct it913xset *set_tuner = set_it9137_template;
 	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
 	u32 bandwidth = p->bandwidth_hz;
@@ -358,7 +362,7 @@ static int it9137_set_tuner(struct dvb_frontend *fe)
 	} else
 		return -EINVAL;
 
-	reg = it913x_read_reg_u8(state, 0xed81);
+	reg = it913x_rd_reg(state, 0xed81);
 	iqik_m_cal = (u16)reg * n_div;
 
 	if (reg < 0x20) {
@@ -396,7 +400,7 @@ static int it9137_set_tuner(struct dvb_frontend *fe)
 
 	pr_debug("low Frequency = %04x\n", freq);
 
-	ret = it913x_fe_script_loader(state, set_tuner);
+	ret = it913x_script_loader(state, set_tuner);
 
 	return (ret < 0) ? -ENODEV : 0;
 }
@@ -405,10 +409,10 @@ static int it9137_set_tuner(struct dvb_frontend *fe)
 /* Power Up	Tuner on -> Frontend suspend off -> Tuner clk on */
 /* Power Down	Frontend suspend on -> Tuner clk off -> Tuner off */
 
-static int it913x_fe_sleep(struct dvb_frontend *fe)
+static int it913x_sleep(struct dvb_frontend *fe)
 {
-	struct it913x_fe_state *state = fe->tuner_priv;
-	return it913x_fe_script_loader(state, it9137_tuner_off);
+	struct it913x_state *state = fe->tuner_priv;
+	return it913x_script_loader(state, it9137_tuner_off);
 }
 
 static int it913x_release(struct dvb_frontend *fe)
@@ -426,19 +430,19 @@ static const struct dvb_tuner_ops it913x_tuner_ops = {
 
 	.release = it913x_release,
 
-	.init = it913x_init_tuner,
-	.sleep = it913x_fe_sleep,
-	.set_params = it9137_set_tuner,
+	.init = it913x_init,
+	.sleep = it913x_sleep,
+	.set_params = it9137_set_params,
 };
 
 struct dvb_frontend *it913x_attach(struct dvb_frontend *fe,
 	struct i2c_adapter *i2c_adap, u8 i2c_addr, struct ite_config *config)
 {
-	struct it913x_fe_state *state = NULL;
+	struct it913x_state *state = NULL;
 	int ret;
 
 	/* allocate memory for the internal state */
-	state = kzalloc(sizeof(struct it913x_fe_state), GFP_KERNEL);
+	state = kzalloc(sizeof(struct it913x_state), GFP_KERNEL);
 	if (state == NULL)
 		return NULL;
 	if (config == NULL)

commit 8c1285a28084b5fa07a7842dd72a561f5c3b913e
Author: Antti Palosaari <crope@iki.fi>
Date:   Tue Feb 26 20:42:21 2013 -0300

    [media] it913x: merge it913x_fe_suspend() to it913x_fe_sleep()
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/tuners/it913x.c b/drivers/media/tuners/it913x.c
index f1938a13eace..6eb3afa32db6 100644
--- a/drivers/media/tuners/it913x.c
+++ b/drivers/media/tuners/it913x.c
@@ -401,36 +401,6 @@ static int it9137_set_tuner(struct dvb_frontend *fe)
 	return (ret < 0) ? -ENODEV : 0;
 }
 
-static int it913x_fe_suspend(struct it913x_fe_state *state)
-{
-	int ret = 0;
-	return 0;
-#if 0
-	int ret, i;
-	u8 b;
-
-	ret = it913x_write_reg(state, PRO_DMOD, SUSPEND_FLAG, 0x1);
-
-	ret |= it913x_write_reg(state, PRO_DMOD, TRIGGER_OFSM, 0x0);
-
-	for (i = 0; i < 128; i++) {
-		ret = it913x_read_reg(state, SUSPEND_FLAG, &b, 1);
-		if (ret < 0)
-			return -ENODEV;
-		if (b == 0)
-			break;
-
-	}
-
-	ret |= it913x_write_reg(state, PRO_DMOD, AFE_MEM0, 0x8);
-	/* Turn LED off */
-	ret |= it913x_write_reg(state, PRO_LINK, GPIOH3_O, 0x0);
-#endif
-	ret |= it913x_fe_script_loader(state, it9137_tuner_off);
-
-	return (ret < 0) ? -ENODEV : 0;
-}
-
 /* Power sequence */
 /* Power Up	Tuner on -> Frontend suspend off -> Tuner clk on */
 /* Power Down	Frontend suspend on -> Tuner clk off -> Tuner off */
@@ -438,7 +408,7 @@ static int it913x_fe_suspend(struct it913x_fe_state *state)
 static int it913x_fe_sleep(struct dvb_frontend *fe)
 {
 	struct it913x_fe_state *state = fe->tuner_priv;
-	return it913x_fe_suspend(state);
+	return it913x_fe_script_loader(state, it9137_tuner_off);
 }
 
 static int it913x_release(struct dvb_frontend *fe)

commit ebb0662cee9e6d8f7110c1217a7bd14315fdd148
Author: Antti Palosaari <crope@iki.fi>
Date:   Tue Feb 26 20:34:06 2013 -0300

    [media] it913x: merge it913x_fe_start() to it913x_init_tuner()
    
    Merge those functions to one and disable sleep.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/tuners/it913x.c b/drivers/media/tuners/it913x.c
index 6ee4f97f586e..f1938a13eace 100644
--- a/drivers/media/tuners/it913x.c
+++ b/drivers/media/tuners/it913x.c
@@ -43,7 +43,6 @@ struct it913x_fe_state {
 	u32 ucblocks;
 };
 
-
 static int it913x_read_reg(struct it913x_fe_state *state,
 		u32 reg, u8 *data, u8 count)
 {
@@ -147,10 +146,54 @@ static int it913x_init_tuner(struct dvb_frontend *fe)
 {
 	struct it913x_fe_state *state = fe->tuner_priv;
 	int ret, i, reg;
+	struct it913xset *set_lna;
 	u8 val, nv_val;
 	u8 nv[] = {48, 32, 24, 16, 12, 8, 6, 4, 2};
 	u8 b[2];
 
+	/* v1 or v2 tuner script */
+	if (state->config->chip_ver > 1)
+		ret = it913x_fe_script_loader(state, it9135_v2);
+	else
+		ret = it913x_fe_script_loader(state, it9135_v1);
+	if (ret < 0)
+		return ret;
+
+	/* LNA Scripts */
+	switch (state->tuner_type) {
+	case IT9135_51:
+		set_lna = it9135_51;
+		break;
+	case IT9135_52:
+		set_lna = it9135_52;
+		break;
+	case IT9135_60:
+		set_lna = it9135_60;
+		break;
+	case IT9135_61:
+		set_lna = it9135_61;
+		break;
+	case IT9135_62:
+		set_lna = it9135_62;
+		break;
+	case IT9135_38:
+	default:
+		set_lna = it9135_38;
+	}
+	pr_info("Tuner LNA type :%02x\n", state->tuner_type);
+
+	ret = it913x_fe_script_loader(state, set_lna);
+	if (ret < 0)
+		return ret;
+
+	if (state->config->chip_ver == 2) {
+		ret = it913x_write_reg(state, PRO_DMOD, TRIGGER_OFSM, 0x1);
+		ret |= it913x_write_reg(state, PRO_LINK, PADODPU, 0x0);
+		ret |= it913x_write_reg(state, PRO_LINK, AGC_O_D, 0x0);
+	}
+	if (ret < 0)
+		return -ENODEV;
+
 	reg = it913x_read_reg_u8(state, 0xec86);
 	switch (reg) {
 	case 0:
@@ -361,6 +404,7 @@ static int it9137_set_tuner(struct dvb_frontend *fe)
 static int it913x_fe_suspend(struct it913x_fe_state *state)
 {
 	int ret = 0;
+	return 0;
 #if 0
 	int ret, i;
 	u8 b;
@@ -397,121 +441,6 @@ static int it913x_fe_sleep(struct dvb_frontend *fe)
 	return it913x_fe_suspend(state);
 }
 
-static int it913x_fe_start(struct dvb_frontend *fe)
-{
-	struct it913x_fe_state *state = fe->tuner_priv;
-	struct it913xset *set_lna;
-//	struct it913xset *set_mode;
-	int ret;
-//	u8 adf = (state->config->adf & 0xf);
-//	u32 adc, xtal;
-//	u8 b[4];
-
-	if (state->config->chip_ver == 1)
-		ret = it913x_init_tuner(fe);
-
-#if 0
-	pr_info("ADF table value	:%02x\n", adf);
-
-	if (adf < 10) {
-		state->crystalFrequency = fe_clockTable[adf].xtal ;
-		state->table = fe_clockTable[adf].table;
-		state->adcFrequency = state->table->adcFrequency;
-
-		adc = compute_div(state->adcFrequency, 1000000ul, 19ul);
-		xtal = compute_div(state->crystalFrequency, 1000000ul, 19ul);
-
-	} else
-		return -EINVAL;
-
-	/* Set LED indicator on GPIOH3 */
-	ret = it913x_write_reg(state, PRO_LINK, GPIOH3_EN, 0x1);
-	ret |= it913x_write_reg(state, PRO_LINK, GPIOH3_ON, 0x1);
-	ret |= it913x_write_reg(state, PRO_LINK, GPIOH3_O, 0x1);
-
-	ret |= it913x_write_reg(state, PRO_LINK, 0xf641, state->tuner_type);
-	ret |= it913x_write_reg(state, PRO_DMOD, 0xf5ca, 0x01);
-	ret |= it913x_write_reg(state, PRO_DMOD, 0xf715, 0x01);
-
-	b[0] = xtal & 0xff;
-	b[1] = (xtal >> 8) & 0xff;
-	b[2] = (xtal >> 16) & 0xff;
-	b[3] = (xtal >> 24);
-	ret |= it913x_write(state, PRO_DMOD, XTAL_CLK, b , 4);
-
-	b[0] = adc & 0xff;
-	b[1] = (adc >> 8) & 0xff;
-	b[2] = (adc >> 16) & 0xff;
-	ret |= it913x_write(state, PRO_DMOD, ADC_FREQ, b, 3);
-
-	if (state->config->adc_x2)
-		ret |= it913x_write_reg(state, PRO_DMOD, ADC_X_2, 0x01);
-	b[0] = 0;
-	b[1] = 0;
-	b[2] = 0;
-	ret |= it913x_write(state, PRO_DMOD, 0x0029, b, 3);
-
-	pr_info("Crystal Frequency :%d Adc Frequency :%d ADC X2: %02x\n",
-		state->crystalFrequency, state->adcFrequency,
-			state->config->adc_x2);
-	pr_debug("Xtal value :%04x Adc value :%04x\n", xtal, adc);
-
-	if (ret < 0)
-		return -ENODEV;
-#endif
-
-	/* v1 or v2 tuner script */
-	if (state->config->chip_ver > 1)
-		ret = it913x_fe_script_loader(state, it9135_v2);
-	else
-		ret = it913x_fe_script_loader(state, it9135_v1);
-	if (ret < 0)
-		return ret;
-
-	/* LNA Scripts */
-	switch (state->tuner_type) {
-	case IT9135_51:
-		set_lna = it9135_51;
-		break;
-	case IT9135_52:
-		set_lna = it9135_52;
-		break;
-	case IT9135_60:
-		set_lna = it9135_60;
-		break;
-	case IT9135_61:
-		set_lna = it9135_61;
-		break;
-	case IT9135_62:
-		set_lna = it9135_62;
-		break;
-	case IT9135_38:
-	default:
-		set_lna = it9135_38;
-	}
-	pr_info("Tuner LNA type :%02x\n", state->tuner_type);
-
-	ret = it913x_fe_script_loader(state, set_lna);
-	if (ret < 0)
-		return ret;
-
-	if (state->config->chip_ver == 2) {
-		ret = it913x_write_reg(state, PRO_DMOD, TRIGGER_OFSM, 0x1);
-		ret |= it913x_write_reg(state, PRO_LINK, PADODPU, 0x0);
-		ret |= it913x_write_reg(state, PRO_LINK, AGC_O_D, 0x0);
-		ret |= it913x_init_tuner(fe);
-	}
-	if (ret < 0)
-		return -ENODEV;
-
-	/* Always solo frontend */
-//	set_mode = set_solo_fe;
-//	ret |= it913x_fe_script_loader(state, set_mode);
-
-	ret |= it913x_fe_suspend(state);
-	return (ret < 0) ? -ENODEV : 0;
-}
-
 static int it913x_release(struct dvb_frontend *fe)
 {
 	kfree(fe->tuner_priv);
@@ -566,10 +495,6 @@ struct dvb_frontend *it913x_attach(struct dvb_frontend *fe,
 	memcpy(&fe->ops.tuner_ops, &it913x_tuner_ops,
 			sizeof(struct dvb_tuner_ops));
 
-	ret = it913x_fe_start(fe);
-	if (ret < 0)
-		goto error;
-
 	pr_info("%s: ITE Tech IT913X attached\n", KBUILD_MODNAME);
 
 	return fe;

commit 88b38befc0d8b7590f0b083dc4c8e4cee0b84788
Author: Antti Palosaari <crope@iki.fi>
Date:   Mon Jan 7 09:37:30 2013 -0300

    [media] ITE IT913X silicon tuner driver
    
    It is tuner driver for tuner integrated to the ITE IT9135 and
    IT9137 chips. I split it out from the current it913x-fe driver.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/tuners/it913x.c b/drivers/media/tuners/it913x.c
new file mode 100644
index 000000000000..6ee4f97f586e
--- /dev/null
+++ b/drivers/media/tuners/it913x.c
@@ -0,0 +1,584 @@
+/*
+ * ITE Tech IT9137 silicon tuner driver
+ *
+ *  Copyright (C) 2011 Malcolm Priestley (tvboxspy@gmail.com)
+ *  IT9137 Copyright (C) ITE Tech Inc.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.=
+ */
+
+#include "it913x_priv.h"
+
+struct it913x_fe_state {
+	struct dvb_frontend frontend;
+	struct i2c_adapter *i2c_adap;
+	struct ite_config *config;
+	u8 i2c_addr;
+	u32 frequency;
+	fe_modulation_t constellation;
+	fe_transmit_mode_t transmission_mode;
+	u8 priority;
+	u32 crystalFrequency;
+	u32 adcFrequency;
+	u8 tuner_type;
+	struct adctable *table;
+	fe_status_t it913x_status;
+	u16 tun_xtal;
+	u8 tun_fdiv;
+	u8 tun_clk_mode;
+	u32 tun_fn_min;
+	u32 ucblocks;
+};
+
+
+static int it913x_read_reg(struct it913x_fe_state *state,
+		u32 reg, u8 *data, u8 count)
+{
+	int ret;
+	u8 b[3];
+	struct i2c_msg msg[2] = {
+		{ .addr = state->i2c_addr, .flags = 0,
+			.buf = b, .len = sizeof(b) },
+		{ .addr = state->i2c_addr, .flags = I2C_M_RD,
+			.buf = data, .len = count }
+	};
+	b[0] = (u8)(reg >> 16) & 0xff;
+	b[1] = (u8)(reg >> 8) & 0xff;
+	b[2] = (u8) reg & 0xff;
+	b[0] |= 0x80; /* All reads from demodulator */
+
+	ret = i2c_transfer(state->i2c_adap, msg, 2);
+
+	return ret;
+}
+
+static int it913x_read_reg_u8(struct it913x_fe_state *state, u32 reg)
+{
+	int ret;
+	u8 b[1];
+	ret = it913x_read_reg(state, reg, &b[0], sizeof(b));
+	return (ret < 0) ? -ENODEV : b[0];
+}
+
+static int it913x_write(struct it913x_fe_state *state,
+		u8 pro, u32 reg, u8 buf[], u8 count)
+{
+	u8 b[256];
+	struct i2c_msg msg[1] = {
+		{ .addr = state->i2c_addr, .flags = 0,
+		  .buf = b, .len = 3 + count }
+	};
+	int ret;
+	b[0] = (u8)(reg >> 16) & 0xff;
+	b[1] = (u8)(reg >> 8) & 0xff;
+	b[2] = (u8) reg & 0xff;
+	memcpy(&b[3], buf, count);
+
+	if (pro == PRO_DMOD)
+		b[0] |= 0x80;
+
+	ret = i2c_transfer(state->i2c_adap, msg, 1);
+
+	if (ret < 0)
+		return -EIO;
+
+	return 0;
+}
+
+static int it913x_write_reg(struct it913x_fe_state *state,
+		u8 pro, u32 reg, u32 data)
+{
+	int ret;
+	u8 b[4];
+	u8 s;
+
+	b[0] = data >> 24;
+	b[1] = (data >> 16) & 0xff;
+	b[2] = (data >> 8) & 0xff;
+	b[3] = data & 0xff;
+	/* expand write as needed */
+	if (data < 0x100)
+		s = 3;
+	else if (data < 0x1000)
+		s = 2;
+	else if (data < 0x100000)
+		s = 1;
+	else
+		s = 0;
+
+	ret = it913x_write(state, pro, reg, &b[s], sizeof(b) - s);
+
+	return ret;
+}
+
+static int it913x_fe_script_loader(struct it913x_fe_state *state,
+		struct it913xset *loadscript)
+{
+	int ret, i;
+	if (loadscript == NULL)
+		return -EINVAL;
+
+	for (i = 0; i < 1000; ++i) {
+		if (loadscript[i].pro == 0xff)
+			break;
+		ret = it913x_write(state, loadscript[i].pro,
+			loadscript[i].address,
+			loadscript[i].reg, loadscript[i].count);
+		if (ret < 0)
+			return -ENODEV;
+	}
+	return 0;
+}
+
+static int it913x_init_tuner(struct dvb_frontend *fe)
+{
+	struct it913x_fe_state *state = fe->tuner_priv;
+	int ret, i, reg;
+	u8 val, nv_val;
+	u8 nv[] = {48, 32, 24, 16, 12, 8, 6, 4, 2};
+	u8 b[2];
+
+	reg = it913x_read_reg_u8(state, 0xec86);
+	switch (reg) {
+	case 0:
+		state->tun_clk_mode = reg;
+		state->tun_xtal = 2000;
+		state->tun_fdiv = 3;
+		val = 16;
+		break;
+	case -ENODEV:
+		return -ENODEV;
+	case 1:
+	default:
+		state->tun_clk_mode = reg;
+		state->tun_xtal = 640;
+		state->tun_fdiv = 1;
+		val = 6;
+		break;
+	}
+
+	reg = it913x_read_reg_u8(state, 0xed03);
+
+	if (reg < 0)
+		return -ENODEV;
+	else if (reg < ARRAY_SIZE(nv))
+		nv_val = nv[reg];
+	else
+		nv_val = 2;
+
+	for (i = 0; i < 50; i++) {
+		ret = it913x_read_reg(state, 0xed23, &b[0], sizeof(b));
+		reg = (b[1] << 8) + b[0];
+		if (reg > 0)
+			break;
+		if (ret < 0)
+			return -ENODEV;
+		udelay(2000);
+	}
+	state->tun_fn_min = state->tun_xtal * reg;
+	state->tun_fn_min /= (state->tun_fdiv * nv_val);
+	pr_debug("Tuner fn_min %d\n", state->tun_fn_min);
+
+	if (state->config->chip_ver > 1)
+		msleep(50);
+	else {
+		for (i = 0; i < 50; i++) {
+			reg = it913x_read_reg_u8(state, 0xec82);
+			if (reg > 0)
+				break;
+			if (reg < 0)
+				return -ENODEV;
+			udelay(2000);
+		}
+	}
+
+	return it913x_write_reg(state, PRO_DMOD, 0xed81, val);
+}
+
+static int it9137_set_tuner(struct dvb_frontend *fe)
+{
+	struct it913x_fe_state *state = fe->tuner_priv;
+	struct it913xset *set_tuner = set_it9137_template;
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+	u32 bandwidth = p->bandwidth_hz;
+	u32 frequency_m = p->frequency;
+	int ret, reg;
+	u32 frequency = frequency_m / 1000;
+	u32 freq, temp_f, tmp;
+	u16 iqik_m_cal;
+	u16 n_div;
+	u8 n;
+	u8 l_band;
+	u8 lna_band;
+	u8 bw;
+
+	if (state->config->firmware_ver == 1)
+		set_tuner = set_it9135_template;
+	else
+		set_tuner = set_it9137_template;
+
+	pr_debug("Tuner Frequency %d Bandwidth %d\n", frequency, bandwidth);
+
+	if (frequency >= 51000 && frequency <= 440000) {
+		l_band = 0;
+		lna_band = 0;
+	} else if (frequency > 440000 && frequency <= 484000) {
+		l_band = 1;
+		lna_band = 1;
+	} else if (frequency > 484000 && frequency <= 533000) {
+		l_band = 1;
+		lna_band = 2;
+	} else if (frequency > 533000 && frequency <= 587000) {
+		l_band = 1;
+		lna_band = 3;
+	} else if (frequency > 587000 && frequency <= 645000) {
+		l_band = 1;
+		lna_band = 4;
+	} else if (frequency > 645000 && frequency <= 710000) {
+		l_band = 1;
+		lna_band = 5;
+	} else if (frequency > 710000 && frequency <= 782000) {
+		l_band = 1;
+		lna_band = 6;
+	} else if (frequency > 782000 && frequency <= 860000) {
+		l_band = 1;
+		lna_band = 7;
+	} else if (frequency > 1450000 && frequency <= 1492000) {
+		l_band = 1;
+		lna_band = 0;
+	} else if (frequency > 1660000 && frequency <= 1685000) {
+		l_band = 1;
+		lna_band = 1;
+	} else
+		return -EINVAL;
+	set_tuner[0].reg[0] = lna_band;
+
+	switch (bandwidth) {
+	case 5000000:
+		bw = 0;
+		break;
+	case 6000000:
+		bw = 2;
+		break;
+	case 7000000:
+		bw = 4;
+		break;
+	default:
+	case 8000000:
+		bw = 6;
+		break;
+	}
+
+	set_tuner[1].reg[0] = bw;
+	set_tuner[2].reg[0] = 0xa0 | (l_band << 3);
+
+	if (frequency > 53000 && frequency <= 74000) {
+		n_div = 48;
+		n = 0;
+	} else if (frequency > 74000 && frequency <= 111000) {
+		n_div = 32;
+		n = 1;
+	} else if (frequency > 111000 && frequency <= 148000) {
+		n_div = 24;
+		n = 2;
+	} else if (frequency > 148000 && frequency <= 222000) {
+		n_div = 16;
+		n = 3;
+	} else if (frequency > 222000 && frequency <= 296000) {
+		n_div = 12;
+		n = 4;
+	} else if (frequency > 296000 && frequency <= 445000) {
+		n_div = 8;
+		n = 5;
+	} else if (frequency > 445000 && frequency <= state->tun_fn_min) {
+		n_div = 6;
+		n = 6;
+	} else if (frequency > state->tun_fn_min && frequency <= 950000) {
+		n_div = 4;
+		n = 7;
+	} else if (frequency > 1450000 && frequency <= 1680000) {
+		n_div = 2;
+		n = 0;
+	} else
+		return -EINVAL;
+
+	reg = it913x_read_reg_u8(state, 0xed81);
+	iqik_m_cal = (u16)reg * n_div;
+
+	if (reg < 0x20) {
+		if (state->tun_clk_mode == 0)
+			iqik_m_cal = (iqik_m_cal * 9) >> 5;
+		else
+			iqik_m_cal >>= 1;
+	} else {
+		iqik_m_cal = 0x40 - iqik_m_cal;
+		if (state->tun_clk_mode == 0)
+			iqik_m_cal = ~((iqik_m_cal * 9) >> 5);
+		else
+			iqik_m_cal = ~(iqik_m_cal >> 1);
+	}
+
+	temp_f = frequency * (u32)n_div * (u32)state->tun_fdiv;
+	freq = temp_f / state->tun_xtal;
+	tmp = freq * state->tun_xtal;
+
+	if ((temp_f - tmp) >= (state->tun_xtal >> 1))
+		freq++;
+
+	freq += (u32) n << 13;
+	/* Frequency OMEGA_IQIK_M_CAL_MID*/
+	temp_f = freq + (u32)iqik_m_cal;
+
+	set_tuner[3].reg[0] =  temp_f & 0xff;
+	set_tuner[4].reg[0] =  (temp_f >> 8) & 0xff;
+
+	pr_debug("High Frequency = %04x\n", temp_f);
+
+	/* Lower frequency */
+	set_tuner[5].reg[0] =  freq & 0xff;
+	set_tuner[6].reg[0] =  (freq >> 8) & 0xff;
+
+	pr_debug("low Frequency = %04x\n", freq);
+
+	ret = it913x_fe_script_loader(state, set_tuner);
+
+	return (ret < 0) ? -ENODEV : 0;
+}
+
+static int it913x_fe_suspend(struct it913x_fe_state *state)
+{
+	int ret = 0;
+#if 0
+	int ret, i;
+	u8 b;
+
+	ret = it913x_write_reg(state, PRO_DMOD, SUSPEND_FLAG, 0x1);
+
+	ret |= it913x_write_reg(state, PRO_DMOD, TRIGGER_OFSM, 0x0);
+
+	for (i = 0; i < 128; i++) {
+		ret = it913x_read_reg(state, SUSPEND_FLAG, &b, 1);
+		if (ret < 0)
+			return -ENODEV;
+		if (b == 0)
+			break;
+
+	}
+
+	ret |= it913x_write_reg(state, PRO_DMOD, AFE_MEM0, 0x8);
+	/* Turn LED off */
+	ret |= it913x_write_reg(state, PRO_LINK, GPIOH3_O, 0x0);
+#endif
+	ret |= it913x_fe_script_loader(state, it9137_tuner_off);
+
+	return (ret < 0) ? -ENODEV : 0;
+}
+
+/* Power sequence */
+/* Power Up	Tuner on -> Frontend suspend off -> Tuner clk on */
+/* Power Down	Frontend suspend on -> Tuner clk off -> Tuner off */
+
+static int it913x_fe_sleep(struct dvb_frontend *fe)
+{
+	struct it913x_fe_state *state = fe->tuner_priv;
+	return it913x_fe_suspend(state);
+}
+
+static int it913x_fe_start(struct dvb_frontend *fe)
+{
+	struct it913x_fe_state *state = fe->tuner_priv;
+	struct it913xset *set_lna;
+//	struct it913xset *set_mode;
+	int ret;
+//	u8 adf = (state->config->adf & 0xf);
+//	u32 adc, xtal;
+//	u8 b[4];
+
+	if (state->config->chip_ver == 1)
+		ret = it913x_init_tuner(fe);
+
+#if 0
+	pr_info("ADF table value	:%02x\n", adf);
+
+	if (adf < 10) {
+		state->crystalFrequency = fe_clockTable[adf].xtal ;
+		state->table = fe_clockTable[adf].table;
+		state->adcFrequency = state->table->adcFrequency;
+
+		adc = compute_div(state->adcFrequency, 1000000ul, 19ul);
+		xtal = compute_div(state->crystalFrequency, 1000000ul, 19ul);
+
+	} else
+		return -EINVAL;
+
+	/* Set LED indicator on GPIOH3 */
+	ret = it913x_write_reg(state, PRO_LINK, GPIOH3_EN, 0x1);
+	ret |= it913x_write_reg(state, PRO_LINK, GPIOH3_ON, 0x1);
+	ret |= it913x_write_reg(state, PRO_LINK, GPIOH3_O, 0x1);
+
+	ret |= it913x_write_reg(state, PRO_LINK, 0xf641, state->tuner_type);
+	ret |= it913x_write_reg(state, PRO_DMOD, 0xf5ca, 0x01);
+	ret |= it913x_write_reg(state, PRO_DMOD, 0xf715, 0x01);
+
+	b[0] = xtal & 0xff;
+	b[1] = (xtal >> 8) & 0xff;
+	b[2] = (xtal >> 16) & 0xff;
+	b[3] = (xtal >> 24);
+	ret |= it913x_write(state, PRO_DMOD, XTAL_CLK, b , 4);
+
+	b[0] = adc & 0xff;
+	b[1] = (adc >> 8) & 0xff;
+	b[2] = (adc >> 16) & 0xff;
+	ret |= it913x_write(state, PRO_DMOD, ADC_FREQ, b, 3);
+
+	if (state->config->adc_x2)
+		ret |= it913x_write_reg(state, PRO_DMOD, ADC_X_2, 0x01);
+	b[0] = 0;
+	b[1] = 0;
+	b[2] = 0;
+	ret |= it913x_write(state, PRO_DMOD, 0x0029, b, 3);
+
+	pr_info("Crystal Frequency :%d Adc Frequency :%d ADC X2: %02x\n",
+		state->crystalFrequency, state->adcFrequency,
+			state->config->adc_x2);
+	pr_debug("Xtal value :%04x Adc value :%04x\n", xtal, adc);
+
+	if (ret < 0)
+		return -ENODEV;
+#endif
+
+	/* v1 or v2 tuner script */
+	if (state->config->chip_ver > 1)
+		ret = it913x_fe_script_loader(state, it9135_v2);
+	else
+		ret = it913x_fe_script_loader(state, it9135_v1);
+	if (ret < 0)
+		return ret;
+
+	/* LNA Scripts */
+	switch (state->tuner_type) {
+	case IT9135_51:
+		set_lna = it9135_51;
+		break;
+	case IT9135_52:
+		set_lna = it9135_52;
+		break;
+	case IT9135_60:
+		set_lna = it9135_60;
+		break;
+	case IT9135_61:
+		set_lna = it9135_61;
+		break;
+	case IT9135_62:
+		set_lna = it9135_62;
+		break;
+	case IT9135_38:
+	default:
+		set_lna = it9135_38;
+	}
+	pr_info("Tuner LNA type :%02x\n", state->tuner_type);
+
+	ret = it913x_fe_script_loader(state, set_lna);
+	if (ret < 0)
+		return ret;
+
+	if (state->config->chip_ver == 2) {
+		ret = it913x_write_reg(state, PRO_DMOD, TRIGGER_OFSM, 0x1);
+		ret |= it913x_write_reg(state, PRO_LINK, PADODPU, 0x0);
+		ret |= it913x_write_reg(state, PRO_LINK, AGC_O_D, 0x0);
+		ret |= it913x_init_tuner(fe);
+	}
+	if (ret < 0)
+		return -ENODEV;
+
+	/* Always solo frontend */
+//	set_mode = set_solo_fe;
+//	ret |= it913x_fe_script_loader(state, set_mode);
+
+	ret |= it913x_fe_suspend(state);
+	return (ret < 0) ? -ENODEV : 0;
+}
+
+static int it913x_release(struct dvb_frontend *fe)
+{
+	kfree(fe->tuner_priv);
+	return 0;
+}
+
+static const struct dvb_tuner_ops it913x_tuner_ops = {
+	.info = {
+		.name           = "ITE Tech IT913X",
+		.frequency_min  = 174000000,
+		.frequency_max  = 862000000,
+	},
+
+	.release = it913x_release,
+
+	.init = it913x_init_tuner,
+	.sleep = it913x_fe_sleep,
+	.set_params = it9137_set_tuner,
+};
+
+struct dvb_frontend *it913x_attach(struct dvb_frontend *fe,
+	struct i2c_adapter *i2c_adap, u8 i2c_addr, struct ite_config *config)
+{
+	struct it913x_fe_state *state = NULL;
+	int ret;
+
+	/* allocate memory for the internal state */
+	state = kzalloc(sizeof(struct it913x_fe_state), GFP_KERNEL);
+	if (state == NULL)
+		return NULL;
+	if (config == NULL)
+		goto error;
+
+	state->i2c_adap = i2c_adap;
+	state->i2c_addr = i2c_addr;
+	state->config = config;
+
+	switch (state->config->tuner_id_0) {
+	case IT9135_51:
+	case IT9135_52:
+	case IT9135_60:
+	case IT9135_61:
+	case IT9135_62:
+		state->tuner_type = state->config->tuner_id_0;
+		break;
+	default:
+	case IT9135_38:
+		state->tuner_type = IT9135_38;
+	}
+
+	fe->tuner_priv = state;
+	memcpy(&fe->ops.tuner_ops, &it913x_tuner_ops,
+			sizeof(struct dvb_tuner_ops));
+
+	ret = it913x_fe_start(fe);
+	if (ret < 0)
+		goto error;
+
+	pr_info("%s: ITE Tech IT913X attached\n", KBUILD_MODNAME);
+
+	return fe;
+error:
+	kfree(state);
+	return NULL;
+}
+EXPORT_SYMBOL(it913x_attach);
+
+MODULE_DESCRIPTION("ITE Tech IT913X silicon tuner driver");
+MODULE_AUTHOR("Antti Palosaari <crope@iki.fi>");
+MODULE_LICENSE("GPL");
