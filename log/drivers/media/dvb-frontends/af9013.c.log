commit c942fddf8793b2013be8c901b47d0a8dc02bf99f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:06 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 157
    
    Based on 3 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [kishon] [vijay] [abraham]
      [i] [kishon]@[ti] [com] this program is distributed in the hope that
      it will be useful but without any warranty without even the implied
      warranty of merchantability or fitness for a particular purpose see
      the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [graeme] [gregory]
      [gg]@[slimlogic] [co] [uk] [author] [kishon] [vijay] [abraham] [i]
      [kishon]@[ti] [com] [based] [on] [twl6030]_[usb] [c] [author] [hema]
      [hk] [hemahk]@[ti] [com] this program is distributed in the hope
      that it will be useful but without any warranty without even the
      implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1105 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.202006027@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/media/dvb-frontends/af9013.c b/drivers/media/dvb-frontends/af9013.c
index 35a93b251aab..7281899bd7ae 100644
--- a/drivers/media/dvb-frontends/af9013.c
+++ b/drivers/media/dvb-frontends/af9013.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Afatech AF9013 demodulator driver
  *
@@ -5,17 +6,6 @@
  * Copyright (C) 2011 Antti Palosaari <crope@iki.fi>
  *
  * Thanks to Afatech who kindly provided information.
- *
- *    This program is free software; you can redistribute it and/or modify
- *    it under the terms of the GNU General Public License as published by
- *    the Free Software Foundation; either version 2 of the License, or
- *    (at your option) any later version.
- *
- *    This program is distributed in the hope that it will be useful,
- *    but WITHOUT ANY WARRANTY; without even the implied warranty of
- *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *    GNU General Public License for more details.
- *
  */
 
 #include "af9013_priv.h"

commit 99cc7ad46b62ef20b0478147677bebd1157bd9cf
Merge: 0214f46b3a03 19358d4488db
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Aug 21 17:40:46 2018 -0700

    Merge branch 'i2c/for-4.19' of git://git.kernel.org/pub/scm/linux/kernel/git/wsa/linux
    
    Pull i2c updates from Wolfram Sang:
    
     - the core has now a lockless variant of i2c_smbus_xfer. Some open
       coded versions of this got removed in drivers. This also enables
       proper SCCB support in regmap.
    
     - locking got a more precise naming. i2c_{un}lock_adapter() had to go,
       and we know use i2c_lock_bus() consistently with flags like
       I2C_LOCK_ROOT_ADAPTER and I2C_LOCK_SEGMENT to avoid ambiguity.
    
     - the gpio fault injector got a new delicate testcase
    
     - the bus recovery procedure got fixed to handle the new testcase
       correctly
    
     - a new quirk flag for controllers not able to handle zero length
       messages together with driver updates to use it
    
     - new drivers: FSI bus attached I2C masters, GENI I2C controller, Owl
       family S900
    
     - and a good set of driver improvements and bugfixes
    
    * 'i2c/for-4.19' of git://git.kernel.org/pub/scm/linux/kernel/git/wsa/linux: (77 commits)
      i2c: rcar: implement STOP and REP_START according to docs
      i2c: rcar: refactor private flags
      i2c: core: ACPI: Make acpi_gsb_i2c_read_bytes() check i2c_transfer return value
      i2c: core: ACPI: Properly set status byte to 0 for multi-byte writes
      dt-bindings: i2c: rcar: Add r8a774a1 support
      dt-bindings: i2c: sh_mobile: Add r8a774a1 support
      i2c: imx: Simplify stopped state tracking
      i2c: imx: Fix race condition in dma read
      i2c: pasemi: remove hardcoded bus numbers on smbus
      i2c: designware: Add SPDX license tag
      i2c: designware: Convert to use struct i2c_timings
      i2c: core: Parse SDA hold time from firmware
      i2c: designware-pcidrv: Mark expected switch fall-through
      i2c: amd8111: Mark expected switch fall-through
      i2c: sh_mobile: use core to detect 'no zero length read' quirk
      i2c: xlr: use core to detect 'no zero length' quirk
      i2c: rcar: use core to detect 'no zero length' quirk
      i2c: stu300: use core to detect 'no zero length' quirk
      i2c: pmcmsp: use core to detect 'no zero length' quirk
      i2c: mxs: use core to detect 'no zero length' quirk
      ...

commit f1b1eabff0eb3fc46b06668de8174c0f23b271fd
Author: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
Date:   Thu Jul 5 18:59:36 2018 -0400

    media: dvb: represent min/max/step/tolerance freqs in Hz
    
    Right now, satellite frontend drivers specify frequencies in kHz,
    while terrestrial/cable ones specify in Hz. That's confusing
    for developers.
    
    However, the main problem is that universal frontends capable
    of handling both satellite and non-satelite delivery systems
    are appearing. We end by needing to hack the drivers in
    order to support such hybrid frontends.
    
    So, convert everything to specify frontend frequencies in Hz.
    
    Tested-by: Katsuhiro Suzuki <suzuki.katsuhiro@socionext.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/dvb-frontends/af9013.c b/drivers/media/dvb-frontends/af9013.c
index 482bce49819a..f3acbb57d48c 100644
--- a/drivers/media/dvb-frontends/af9013.c
+++ b/drivers/media/dvb-frontends/af9013.c
@@ -1136,10 +1136,9 @@ static const struct dvb_frontend_ops af9013_ops = {
 	.delsys = { SYS_DVBT },
 	.info = {
 		.name = "Afatech AF9013",
-		.frequency_min = 174000000,
-		.frequency_max = 862000000,
-		.frequency_stepsize = 250000,
-		.frequency_tolerance = 0,
+		.frequency_min_hz = 174 * MHz,
+		.frequency_max_hz = 862 * MHz,
+		.frequency_stepsize_hz = 250 * kHz,
 		.caps =	FE_CAN_FEC_1_2 |
 			FE_CAN_FEC_2_3 |
 			FE_CAN_FEC_3_4 |

commit b1e1ca27570016e3aa0e3265df699fea87013abc
Author: Peter Rosin <peda@axentia.se>
Date:   Wed Jun 20 07:17:57 2018 +0200

    media: af9013: switch to i2c_lock_bus(..., I2C_LOCK_SEGMENT)
    
    Locking the root adapter for __i2c_transfer will deadlock if the
    device sits behind a mux-locked I2C mux. Switch to the finer-grained
    i2c_lock_bus with the I2C_LOCK_SEGMENT flag. If the device does not
    sit behind a mux-locked mux, the two locking variants are equivalent.
    
    Signed-off-by: Peter Rosin <peda@axentia.se>
    Acked-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/media/dvb-frontends/af9013.c b/drivers/media/dvb-frontends/af9013.c
index 482bce49819a..99361c113bca 100644
--- a/drivers/media/dvb-frontends/af9013.c
+++ b/drivers/media/dvb-frontends/af9013.c
@@ -1312,10 +1312,10 @@ static int af9013_wregs(struct i2c_client *client, u8 cmd, u16 reg,
 	memcpy(&buf[3], val, len);
 
 	if (lock)
-		i2c_lock_adapter(client->adapter);
+		i2c_lock_bus(client->adapter, I2C_LOCK_SEGMENT);
 	ret = __i2c_transfer(client->adapter, msg, 1);
 	if (lock)
-		i2c_unlock_adapter(client->adapter);
+		i2c_unlock_bus(client->adapter, I2C_LOCK_SEGMENT);
 	if (ret < 0) {
 		goto err;
 	} else if (ret != 1) {
@@ -1353,10 +1353,10 @@ static int af9013_rregs(struct i2c_client *client, u8 cmd, u16 reg,
 	buf[2] = cmd;
 
 	if (lock)
-		i2c_lock_adapter(client->adapter);
+		i2c_lock_bus(client->adapter, I2C_LOCK_SEGMENT);
 	ret = __i2c_transfer(client->adapter, msg, 2);
 	if (lock)
-		i2c_unlock_adapter(client->adapter);
+		i2c_unlock_bus(client->adapter, I2C_LOCK_SEGMENT);
 	if (ret < 0) {
 		goto err;
 	} else if (ret != 2) {

commit 83d6b7c3276fc056e65957b23c0ef7a3e9a50c18
Author: Antti Palosaari <crope@iki.fi>
Date:   Mon Jun 26 04:57:09 2017 -0400

    media: af9013: add pid filter support
    
    af9013 demod has pid filter. Add support for it.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/af9013.c b/drivers/media/dvb-frontends/af9013.c
index 15af3e9482df..482bce49819a 100644
--- a/drivers/media/dvb-frontends/af9013.c
+++ b/drivers/media/dvb-frontends/af9013.c
@@ -1171,6 +1171,56 @@ static const struct dvb_frontend_ops af9013_ops = {
 	.read_ucblocks = af9013_read_ucblocks,
 };
 
+static int af9013_pid_filter_ctrl(struct dvb_frontend *fe, int onoff)
+{
+	struct af9013_state *state = fe->demodulator_priv;
+	struct i2c_client *client = state->client;
+	int ret;
+
+	dev_dbg(&client->dev, "onoff %d\n", onoff);
+
+	ret = regmap_update_bits(state->regmap, 0xd503, 0x01, onoff);
+	if (ret)
+		goto err;
+
+	return 0;
+err:
+	dev_dbg(&client->dev, "failed %d\n", ret);
+	return ret;
+}
+
+static int af9013_pid_filter(struct dvb_frontend *fe, u8 index, u16 pid,
+			     int onoff)
+{
+	struct af9013_state *state = fe->demodulator_priv;
+	struct i2c_client *client = state->client;
+	int ret;
+	u8 buf[2];
+
+	dev_dbg(&client->dev, "index %d, pid %04x, onoff %d\n",
+		index, pid, onoff);
+
+	if (pid > 0x1fff) {
+		/* 0x2000 is kernel virtual pid for whole ts (all pids) */
+		ret = 0;
+		goto err;
+	}
+
+	buf[0] = (pid >> 0) & 0xff;
+	buf[1] = (pid >> 8) & 0xff;
+	ret = regmap_bulk_write(state->regmap, 0xd505, buf, 2);
+	if (ret)
+		goto err;
+	ret = regmap_write(state->regmap, 0xd504, onoff << 5 | index << 0);
+	if (ret)
+		goto err;
+
+	return 0;
+err:
+	dev_dbg(&client->dev, "failed %d\n", ret);
+	return ret;
+}
+
 static struct dvb_frontend *af9013_get_dvb_frontend(struct i2c_client *client)
 {
 	struct af9013_state *state = i2c_get_clientdata(client);
@@ -1473,6 +1523,8 @@ static int af9013_probe(struct i2c_client *client,
 	/* Setup callbacks */
 	pdata->get_dvb_frontend = af9013_get_dvb_frontend;
 	pdata->get_i2c_adapter = af9013_get_i2c_adapter;
+	pdata->pid_filter = af9013_pid_filter;
+	pdata->pid_filter_ctrl = af9013_pid_filter_ctrl;
 
 	/* Init stats to indicate which stats are supported */
 	c = &state->fe.dtv_property_cache;

commit 12c6b22fbf2379e0b194289227848f4f0439e5c3
Author: Antti Palosaari <crope@iki.fi>
Date:   Fri Jun 23 05:31:49 2017 -0400

    media: af9013: remove all legacy media attach releated stuff
    
    No one is binding that driver through media attach so remove it and
    all related dead code.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/af9013.c b/drivers/media/dvb-frontends/af9013.c
index d55c5f67ce0f..15af3e9482df 100644
--- a/drivers/media/dvb-frontends/af9013.c
+++ b/drivers/media/dvb-frontends/af9013.c
@@ -48,7 +48,6 @@ struct af9013_state {
 	u32 dvbv3_ber;
 	u32 dvbv3_ucblocks;
 	bool first_tune;
-	bool i2c_gate_state;
 };
 
 static int af9013_set_gpio(struct af9013_state *state, u8 gpio, u8 gpioval)
@@ -1031,45 +1030,6 @@ static int af9013_sleep(struct dvb_frontend *fe)
 	return ret;
 }
 
-static int af9013_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)
-{
-	int ret;
-	struct af9013_state *state = fe->demodulator_priv;
-	struct i2c_client *client = state->client;
-
-	dev_dbg(&client->dev, "enable %d\n", enable);
-
-	/* gate already open or close */
-	if (state->i2c_gate_state == enable)
-		return 0;
-
-	if (state->ts_mode == AF9013_TS_MODE_USB)
-		ret = regmap_update_bits(state->regmap, 0xd417, 0x08,
-					 enable << 3);
-	else
-		ret = regmap_update_bits(state->regmap, 0xd607, 0x04,
-					 enable << 2);
-	if (ret)
-		goto err;
-
-	state->i2c_gate_state = enable;
-
-	return 0;
-err:
-	dev_dbg(&client->dev, "failed %d\n", ret);
-	return ret;
-}
-
-static void af9013_release(struct dvb_frontend *fe)
-{
-	struct af9013_state *state = fe->demodulator_priv;
-	struct i2c_client *client = state->client;
-
-	dev_dbg(&client->dev, "\n");
-
-	i2c_unregister_device(client);
-}
-
 static const struct dvb_frontend_ops af9013_ops;
 
 static int af9013_download_firmware(struct af9013_state *state)
@@ -1172,40 +1132,6 @@ static int af9013_download_firmware(struct af9013_state *state)
 	return ret;
 }
 
-/*
- * XXX: That is wrapper to af9013_probe() via driver core in order to provide
- * proper I2C client for legacy media attach binding.
- * New users must use I2C client binding directly!
- */
-struct dvb_frontend *af9013_attach(const struct af9013_config *config,
-				   struct i2c_adapter *i2c)
-{
-	struct i2c_client *client;
-	struct i2c_board_info board_info;
-	struct af9013_platform_data pdata;
-
-	pdata.clk = config->clock;
-	pdata.tuner = config->tuner;
-	pdata.if_frequency = config->if_frequency;
-	pdata.ts_mode = config->ts_mode;
-	pdata.ts_output_pin = 7;
-	pdata.spec_inv = config->spec_inv;
-	memcpy(&pdata.api_version, config->api_version, sizeof(pdata.api_version));
-	memcpy(&pdata.gpio, config->gpio, sizeof(pdata.gpio));
-	pdata.attach_in_use = true;
-
-	memset(&board_info, 0, sizeof(board_info));
-	strlcpy(board_info.type, "af9013", sizeof(board_info.type));
-	board_info.addr = config->i2c_addr;
-	board_info.platform_data = &pdata;
-	client = i2c_new_device(i2c, &board_info);
-	if (!client || !client->dev.driver)
-		return NULL;
-
-	return pdata.get_dvb_frontend(client);
-}
-EXPORT_SYMBOL(af9013_attach);
-
 static const struct dvb_frontend_ops af9013_ops = {
 	.delsys = { SYS_DVBT },
 	.info = {
@@ -1231,8 +1157,6 @@ static const struct dvb_frontend_ops af9013_ops = {
 			FE_CAN_MUTE_TS
 	},
 
-	.release = af9013_release,
-
 	.init = af9013_init,
 	.sleep = af9013_sleep,
 
@@ -1245,8 +1169,6 @@ static const struct dvb_frontend_ops af9013_ops = {
 	.read_signal_strength = af9013_read_signal_strength,
 	.read_ber = af9013_read_ber,
 	.read_ucblocks = af9013_read_ucblocks,
-
-	.i2c_gate_ctrl = af9013_i2c_gate_ctrl,
 };
 
 static struct dvb_frontend *af9013_get_dvb_frontend(struct i2c_client *client)
@@ -1546,8 +1468,6 @@ static int af9013_probe(struct i2c_client *client,
 
 	/* Create dvb frontend */
 	memcpy(&state->fe.ops, &af9013_ops, sizeof(state->fe.ops));
-	if (!pdata->attach_in_use)
-		state->fe.ops.release = NULL;
 	state->fe.demodulator_priv = state;
 
 	/* Setup callbacks */

commit 22e59e7204a46d9f3c6abc02909927a19640f91f
Author: Antti Palosaari <crope@iki.fi>
Date:   Thu Jun 22 12:18:21 2017 -0400

    media: af9013: add i2c mux adapter for tuner bus
    
    Add muxed i2c adapter for demod tuner i2c bus gate control.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/af9013.c b/drivers/media/dvb-frontends/af9013.c
index 87a55cd67e03..d55c5f67ce0f 100644
--- a/drivers/media/dvb-frontends/af9013.c
+++ b/drivers/media/dvb-frontends/af9013.c
@@ -23,6 +23,7 @@
 struct af9013_state {
 	struct i2c_client *client;
 	struct regmap *regmap;
+	struct i2c_mux_core *muxc;
 	struct dvb_frontend fe;
 	u32 clk;
 	u8 tuner;
@@ -1257,9 +1258,65 @@ static struct dvb_frontend *af9013_get_dvb_frontend(struct i2c_client *client)
 	return &state->fe;
 }
 
+static struct i2c_adapter *af9013_get_i2c_adapter(struct i2c_client *client)
+{
+	struct af9013_state *state = i2c_get_clientdata(client);
+
+	dev_dbg(&client->dev, "\n");
+
+	return state->muxc->adapter[0];
+}
+
+/*
+ * XXX: Hackish solution. We use virtual register, reg bit 16, to carry info
+ * about i2c adapter locking. Own locking is needed because i2c mux call has
+ * already locked i2c adapter.
+ */
+static int af9013_select(struct i2c_mux_core *muxc, u32 chan)
+{
+	struct af9013_state *state = i2c_mux_priv(muxc);
+	struct i2c_client *client = state->client;
+	int ret;
+
+	dev_dbg(&client->dev, "\n");
+
+	if (state->ts_mode == AF9013_TS_MODE_USB)
+		ret = regmap_update_bits(state->regmap, 0x1d417, 0x08, 0x08);
+	else
+		ret = regmap_update_bits(state->regmap, 0x1d607, 0x04, 0x04);
+	if (ret)
+		goto err;
+
+	return 0;
+err:
+	dev_dbg(&client->dev, "failed %d\n", ret);
+	return ret;
+}
+
+static int af9013_deselect(struct i2c_mux_core *muxc, u32 chan)
+{
+	struct af9013_state *state = i2c_mux_priv(muxc);
+	struct i2c_client *client = state->client;
+	int ret;
+
+	dev_dbg(&client->dev, "\n");
+
+	if (state->ts_mode == AF9013_TS_MODE_USB)
+		ret = regmap_update_bits(state->regmap, 0x1d417, 0x08, 0x00);
+	else
+		ret = regmap_update_bits(state->regmap, 0x1d607, 0x04, 0x00);
+	if (ret)
+		goto err;
+
+	return 0;
+err:
+	dev_dbg(&client->dev, "failed %d\n", ret);
+	return ret;
+}
+
 /* Own I2C access routines needed for regmap as chip uses extra command byte */
 static int af9013_wregs(struct i2c_client *client, u8 cmd, u16 reg,
-			const u8 *val, int len)
+			const u8 *val, int len, u8 lock)
 {
 	int ret;
 	u8 buf[21];
@@ -1281,7 +1338,12 @@ static int af9013_wregs(struct i2c_client *client, u8 cmd, u16 reg,
 	buf[1] = (reg >> 0) & 0xff;
 	buf[2] = cmd;
 	memcpy(&buf[3], val, len);
-	ret = i2c_transfer(client->adapter, msg, 1);
+
+	if (lock)
+		i2c_lock_adapter(client->adapter);
+	ret = __i2c_transfer(client->adapter, msg, 1);
+	if (lock)
+		i2c_unlock_adapter(client->adapter);
 	if (ret < 0) {
 		goto err;
 	} else if (ret != 1) {
@@ -1296,7 +1358,7 @@ static int af9013_wregs(struct i2c_client *client, u8 cmd, u16 reg,
 }
 
 static int af9013_rregs(struct i2c_client *client, u8 cmd, u16 reg,
-			u8 *val, int len)
+			u8 *val, int len, u8 lock)
 {
 	int ret;
 	u8 buf[3];
@@ -1317,7 +1379,12 @@ static int af9013_rregs(struct i2c_client *client, u8 cmd, u16 reg,
 	buf[0] = (reg >> 8) & 0xff;
 	buf[1] = (reg >> 0) & 0xff;
 	buf[2] = cmd;
-	ret = i2c_transfer(client->adapter, msg, 2);
+
+	if (lock)
+		i2c_lock_adapter(client->adapter);
+	ret = __i2c_transfer(client->adapter, msg, 2);
+	if (lock)
+		i2c_unlock_adapter(client->adapter);
 	if (ret < 0) {
 		goto err;
 	} else if (ret != 2) {
@@ -1337,25 +1404,27 @@ static int af9013_regmap_write(void *context, const void *data, size_t count)
 	struct af9013_state *state = i2c_get_clientdata(client);
 	int ret, i;
 	u8 cmd;
-	u16 reg = ((u8 *)data)[0] << 8|((u8 *)data)[1] << 0;
-	u8 *val = &((u8 *)data)[2];
-	const unsigned int len = count - 2;
+	u8 lock = !((u8 *)data)[0];
+	u16 reg = ((u8 *)data)[1] << 8 | ((u8 *)data)[2] << 0;
+	u8 *val = &((u8 *)data)[3];
+	const unsigned int len = count - 3;
 
 	if (state->ts_mode == AF9013_TS_MODE_USB && (reg & 0xff00) != 0xae00) {
 		cmd = 0 << 7|0 << 6|(len - 1) << 2|1 << 1|1 << 0;
-		ret = af9013_wregs(client, cmd, reg, val, len);
+		ret = af9013_wregs(client, cmd, reg, val, len, lock);
 		if (ret)
 			goto err;
 	} else if (reg >= 0x5100 && reg < 0x8fff) {
 		/* Firmware download */
 		cmd = 1 << 7|1 << 6|(len - 1) << 2|1 << 1|1 << 0;
-		ret = af9013_wregs(client, cmd, reg, val, len);
+		ret = af9013_wregs(client, cmd, reg, val, len, lock);
 		if (ret)
 			goto err;
 	} else {
 		cmd = 0 << 7|0 << 6|(1 - 1) << 2|1 << 1|1 << 0;
 		for (i = 0; i < len; i++) {
-			ret = af9013_wregs(client, cmd, reg + i, val + i, 1);
+			ret = af9013_wregs(client, cmd, reg + i, val + i, 1,
+					   lock);
 			if (ret)
 				goto err;
 		}
@@ -1374,19 +1443,21 @@ static int af9013_regmap_read(void *context, const void *reg_buf,
 	struct af9013_state *state = i2c_get_clientdata(client);
 	int ret, i;
 	u8 cmd;
-	u16 reg = ((u8 *)reg_buf)[0] << 8|((u8 *)reg_buf)[1] << 0;
+	u8 lock = !((u8 *)reg_buf)[0];
+	u16 reg = ((u8 *)reg_buf)[1] << 8 | ((u8 *)reg_buf)[2] << 0;
 	u8 *val = &((u8 *)val_buf)[0];
 	const unsigned int len = val_size;
 
 	if (state->ts_mode == AF9013_TS_MODE_USB && (reg & 0xff00) != 0xae00) {
 		cmd = 0 << 7|0 << 6|(len - 1) << 2|1 << 1|0 << 0;
-		ret = af9013_rregs(client, cmd, reg, val_buf, len);
+		ret = af9013_rregs(client, cmd, reg, val_buf, len, lock);
 		if (ret)
 			goto err;
 	} else {
 		cmd = 0 << 7|0 << 6|(1 - 1) << 2|1 << 1|0 << 0;
 		for (i = 0; i < len; i++) {
-			ret = af9013_rregs(client, cmd, reg + i, val + i, 1);
+			ret = af9013_rregs(client, cmd, reg + i, val + i, 1,
+					   lock);
 			if (ret)
 				goto err;
 		}
@@ -1411,8 +1482,9 @@ static int af9013_probe(struct i2c_client *client,
 		.write = af9013_regmap_write,
 	};
 	static const struct regmap_config regmap_config = {
-		.reg_bits    =  16,
-		.val_bits    =  8,
+		/* Actual reg is 16 bits, see i2c adapter lock */
+		.reg_bits = 24,
+		.val_bits = 8,
 	};
 
 	state = kzalloc(sizeof(*state), GFP_KERNEL);
@@ -1421,6 +1493,8 @@ static int af9013_probe(struct i2c_client *client,
 		goto err;
 	}
 
+	dev_dbg(&client->dev, "\n");
+
 	/* Setup the state */
 	state->client = client;
 	i2c_set_clientdata(client, state);
@@ -1438,25 +1512,36 @@ static int af9013_probe(struct i2c_client *client,
 		ret = PTR_ERR(state->regmap);
 		goto err_kfree;
 	}
+	/* Create mux i2c adapter */
+	state->muxc = i2c_mux_alloc(client->adapter, &client->dev, 1, 0, 0,
+				    af9013_select, af9013_deselect);
+	if (!state->muxc) {
+		ret = -ENOMEM;
+		goto err_regmap_exit;
+	}
+	state->muxc->priv = state;
+	ret = i2c_mux_add_adapter(state->muxc, 0, 0, 0);
+	if (ret)
+		goto err_regmap_exit;
 
 	/* Download firmware */
 	if (state->ts_mode != AF9013_TS_MODE_USB) {
 		ret = af9013_download_firmware(state);
 		if (ret)
-			goto err_regmap_exit;
+			goto err_i2c_mux_del_adapters;
 	}
 
 	/* Firmware version */
 	ret = regmap_bulk_read(state->regmap, 0x5103, firmware_version,
 			       sizeof(firmware_version));
 	if (ret)
-		goto err_regmap_exit;
+		goto err_i2c_mux_del_adapters;
 
 	/* Set GPIOs */
 	for (i = 0; i < sizeof(state->gpio); i++) {
 		ret = af9013_set_gpio(state, i, state->gpio[i]);
 		if (ret)
-			goto err_regmap_exit;
+			goto err_i2c_mux_del_adapters;
 	}
 
 	/* Create dvb frontend */
@@ -1467,6 +1552,7 @@ static int af9013_probe(struct i2c_client *client,
 
 	/* Setup callbacks */
 	pdata->get_dvb_frontend = af9013_get_dvb_frontend;
+	pdata->get_i2c_adapter = af9013_get_i2c_adapter;
 
 	/* Init stats to indicate which stats are supported */
 	c = &state->fe.dtv_property_cache;
@@ -1482,6 +1568,8 @@ static int af9013_probe(struct i2c_client *client,
 		 firmware_version[0], firmware_version[1],
 		 firmware_version[2], firmware_version[3]);
 	return 0;
+err_i2c_mux_del_adapters:
+	i2c_mux_del_adapters(state->muxc);
 err_regmap_exit:
 	regmap_exit(state->regmap);
 err_kfree:
@@ -1497,6 +1585,8 @@ static int af9013_remove(struct i2c_client *client)
 
 	dev_dbg(&client->dev, "\n");
 
+	i2c_mux_del_adapters(state->muxc);
+
 	regmap_exit(state->regmap);
 
 	kfree(state);

commit 3b536127f514217d18c04304cb859841ec63bda7
Author: Antti Palosaari <crope@iki.fi>
Date:   Thu Jun 22 04:24:00 2017 -0400

    media: af9013: convert inittabs suitable for regmap_update_bits
    
    Convert inttabs to format (reg, mask, val) which are suitable
    parameters to pass directly for regmap_update_bits.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/af9013.c b/drivers/media/dvb-frontends/af9013.c
index e81dc827e1b8..87a55cd67e03 100644
--- a/drivers/media/dvb-frontends/af9013.c
+++ b/drivers/media/dvb-frontends/af9013.c
@@ -843,7 +843,7 @@ static int af9013_init(struct dvb_frontend *fe)
 	int ret, i, len;
 	unsigned int utmp;
 	u8 buf[3];
-	const struct af9013_reg_bit *init;
+	const struct af9013_reg_mask_val *tab;
 
 	dev_dbg(&client->dev, "\n");
 
@@ -898,72 +898,66 @@ static int af9013_init(struct dvb_frontend *fe)
 	if (ret)
 		goto err;
 
-	/* load OFSM settings */
-	dev_dbg(&client->dev, "load ofsm settings\n");
-	len = ARRAY_SIZE(ofsm_init);
-	init = ofsm_init;
+	/* Demod core settings */
+	dev_dbg(&client->dev, "load demod core settings\n");
+	len = ARRAY_SIZE(demod_init_tab);
+	tab = demod_init_tab;
 	for (i = 0; i < len; i++) {
-		u16 reg = init[i].addr;
-		u8 mask = GENMASK(init[i].pos + init[i].len - 1, init[i].pos);
-		u8 val = init[i].val << init[i].pos;
-
-		ret = regmap_update_bits(state->regmap, reg, mask, val);
+		ret = regmap_update_bits(state->regmap, tab[i].reg, tab[i].mask,
+					 tab[i].val);
 		if (ret)
 			goto err;
 	}
 
-	/* load tuner specific settings */
+	/* Demod tuner specific settings */
 	dev_dbg(&client->dev, "load tuner specific settings\n");
 	switch (state->tuner) {
 	case AF9013_TUNER_MXL5003D:
-		len = ARRAY_SIZE(tuner_init_mxl5003d);
-		init = tuner_init_mxl5003d;
+		len = ARRAY_SIZE(tuner_init_tab_mxl5003d);
+		tab = tuner_init_tab_mxl5003d;
 		break;
 	case AF9013_TUNER_MXL5005D:
 	case AF9013_TUNER_MXL5005R:
 	case AF9013_TUNER_MXL5007T:
-		len = ARRAY_SIZE(tuner_init_mxl5005);
-		init = tuner_init_mxl5005;
+		len = ARRAY_SIZE(tuner_init_tab_mxl5005);
+		tab = tuner_init_tab_mxl5005;
 		break;
 	case AF9013_TUNER_ENV77H11D5:
-		len = ARRAY_SIZE(tuner_init_env77h11d5);
-		init = tuner_init_env77h11d5;
+		len = ARRAY_SIZE(tuner_init_tab_env77h11d5);
+		tab = tuner_init_tab_env77h11d5;
 		break;
 	case AF9013_TUNER_MT2060:
-		len = ARRAY_SIZE(tuner_init_mt2060);
-		init = tuner_init_mt2060;
+		len = ARRAY_SIZE(tuner_init_tab_mt2060);
+		tab = tuner_init_tab_mt2060;
 		break;
 	case AF9013_TUNER_MC44S803:
-		len = ARRAY_SIZE(tuner_init_mc44s803);
-		init = tuner_init_mc44s803;
+		len = ARRAY_SIZE(tuner_init_tab_mc44s803);
+		tab = tuner_init_tab_mc44s803;
 		break;
 	case AF9013_TUNER_QT1010:
 	case AF9013_TUNER_QT1010A:
-		len = ARRAY_SIZE(tuner_init_qt1010);
-		init = tuner_init_qt1010;
+		len = ARRAY_SIZE(tuner_init_tab_qt1010);
+		tab = tuner_init_tab_qt1010;
 		break;
 	case AF9013_TUNER_MT2060_2:
-		len = ARRAY_SIZE(tuner_init_mt2060_2);
-		init = tuner_init_mt2060_2;
+		len = ARRAY_SIZE(tuner_init_tab_mt2060_2);
+		tab = tuner_init_tab_mt2060_2;
 		break;
 	case AF9013_TUNER_TDA18271:
 	case AF9013_TUNER_TDA18218:
-		len = ARRAY_SIZE(tuner_init_tda18271);
-		init = tuner_init_tda18271;
+		len = ARRAY_SIZE(tuner_init_tab_tda18271);
+		tab = tuner_init_tab_tda18271;
 		break;
 	case AF9013_TUNER_UNKNOWN:
 	default:
-		len = ARRAY_SIZE(tuner_init_unknown);
-		init = tuner_init_unknown;
+		len = ARRAY_SIZE(tuner_init_tab_unknown);
+		tab = tuner_init_tab_unknown;
 		break;
 	}
 
 	for (i = 0; i < len; i++) {
-		u16 reg = init[i].addr;
-		u8 mask = GENMASK(init[i].pos + init[i].len - 1, init[i].pos);
-		u8 val = init[i].val << init[i].pos;
-
-		ret = regmap_update_bits(state->regmap, reg, mask, val);
+		ret = regmap_update_bits(state->regmap, tab[i].reg, tab[i].mask,
+					 tab[i].val);
 		if (ret)
 			goto err;
 	}

commit b911fc89e12c0cfc47e7501e7e1d930c98d403a9
Author: Antti Palosaari <crope@iki.fi>
Date:   Mon Jun 19 02:31:56 2017 -0400

    media: af9013: wrap dvbv3 statistics via dvbv5
    
    Driver has calculated dvbv5 statistics, so use those as a base for
    legacy dvbv3 statistics. Wrap and convert needed values to dvbv3,
    remove old dvbv3 statistic implementations.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/af9013.c b/drivers/media/dvb-frontends/af9013.c
index a054e39510e0..e81dc827e1b8 100644
--- a/drivers/media/dvb-frontends/af9013.c
+++ b/drivers/media/dvb-frontends/af9013.c
@@ -33,12 +33,6 @@ struct af9013_state {
 	u8 api_version[4];
 	u8 gpio[4];
 
-	/* tuner/demod RF and IF AGC limits used for signal strength calc */
-	u8 signal_strength_en, rf_50, rf_80, if_50, if_80;
-	u16 signal_strength;
-	u32 ber;
-	u32 ucblocks;
-	u16 snr;
 	u32 bandwidth_hz;
 	enum fe_status fe_status;
 	/* RF and IF AGC limits used for signal strength calc */
@@ -48,10 +42,12 @@ struct af9013_state {
 	unsigned long strength_jiffies;
 	unsigned long cnr_jiffies;
 	unsigned long ber_ucb_jiffies;
+	u16 dvbv3_snr;
+	u16 dvbv3_strength;
+	u32 dvbv3_ber;
+	u32 dvbv3_ucblocks;
 	bool first_tune;
 	bool i2c_gate_state;
-	unsigned int statistics_step:3;
-	struct delayed_work statistics_work;
 };
 
 static int af9013_set_gpio(struct af9013_state *state, u8 gpio, u8 gpioval)
@@ -106,228 +102,6 @@ static int af9013_set_gpio(struct af9013_state *state, u8 gpio, u8 gpioval)
 	return ret;
 }
 
-static int af9013_statistics_ber_unc_start(struct dvb_frontend *fe)
-{
-	struct af9013_state *state = fe->demodulator_priv;
-	struct i2c_client *client = state->client;
-	int ret;
-
-	dev_dbg(&client->dev, "\n");
-
-	/* reset and start BER counter */
-	ret = regmap_update_bits(state->regmap, 0xd391, 0x10, 0x10);
-	if (ret)
-		goto err;
-
-	return 0;
-err:
-	dev_dbg(&client->dev, "failed %d\n", ret);
-	return ret;
-}
-
-static int af9013_statistics_ber_unc_result(struct dvb_frontend *fe)
-{
-	struct af9013_state *state = fe->demodulator_priv;
-	struct i2c_client *client = state->client;
-	int ret;
-	unsigned int utmp;
-	u8 buf[5];
-
-	dev_dbg(&client->dev, "\n");
-
-	/* check if error bit count is ready */
-	ret = regmap_read(state->regmap, 0xd391, &utmp);
-	if (ret)
-		goto err;
-
-	if (!((utmp >> 4) & 0x01)) {
-		dev_dbg(&client->dev, "not ready\n");
-		return 0;
-	}
-
-	ret = regmap_bulk_read(state->regmap, 0xd387, buf, 5);
-	if (ret)
-		goto err;
-
-	state->ber = (buf[2] << 16) | (buf[1] << 8) | buf[0];
-	state->ucblocks += (buf[4] << 8) | buf[3];
-
-	return 0;
-err:
-	dev_dbg(&client->dev, "failed %d\n", ret);
-	return ret;
-}
-
-static int af9013_statistics_snr_start(struct dvb_frontend *fe)
-{
-	struct af9013_state *state = fe->demodulator_priv;
-	struct i2c_client *client = state->client;
-	int ret;
-
-	dev_dbg(&client->dev, "\n");
-
-	/* start SNR meas */
-	ret = regmap_update_bits(state->regmap, 0xd2e1, 0x08, 0x08);
-	if (ret)
-		goto err;
-
-	return 0;
-err:
-	dev_dbg(&client->dev, "failed %d\n", ret);
-	return ret;
-}
-
-static int af9013_statistics_snr_result(struct dvb_frontend *fe)
-{
-	struct af9013_state *state = fe->demodulator_priv;
-	struct i2c_client *client = state->client;
-	int ret, i, len;
-	unsigned int utmp;
-	u8 buf[3];
-	u32 snr_val;
-	const struct af9013_snr *uninitialized_var(snr_lut);
-
-	dev_dbg(&client->dev, "\n");
-
-	/* check if SNR ready */
-	ret = regmap_read(state->regmap, 0xd2e1, &utmp);
-	if (ret)
-		goto err;
-
-	if (!((utmp >> 3) & 0x01)) {
-		dev_dbg(&client->dev, "not ready\n");
-		return 0;
-	}
-
-	/* read value */
-	ret = regmap_bulk_read(state->regmap, 0xd2e3, buf, 3);
-	if (ret)
-		goto err;
-
-	snr_val = (buf[2] << 16) | (buf[1] << 8) | buf[0];
-
-	/* read current modulation */
-	ret = regmap_read(state->regmap, 0xd3c1, &utmp);
-	if (ret)
-		goto err;
-
-	switch ((utmp >> 6) & 3) {
-	case 0:
-		len = ARRAY_SIZE(qpsk_snr_lut);
-		snr_lut = qpsk_snr_lut;
-		break;
-	case 1:
-		len = ARRAY_SIZE(qam16_snr_lut);
-		snr_lut = qam16_snr_lut;
-		break;
-	case 2:
-		len = ARRAY_SIZE(qam64_snr_lut);
-		snr_lut = qam64_snr_lut;
-		break;
-	default:
-		goto err;
-	}
-
-	for (i = 0; i < len; i++) {
-		utmp = snr_lut[i].snr;
-
-		if (snr_val < snr_lut[i].val)
-			break;
-	}
-	state->snr = utmp * 10; /* dB/10 */
-
-	return 0;
-err:
-	dev_dbg(&client->dev, "failed %d\n", ret);
-	return ret;
-}
-
-static int af9013_statistics_signal_strength(struct dvb_frontend *fe)
-{
-	struct af9013_state *state = fe->demodulator_priv;
-	struct i2c_client *client = state->client;
-	int ret = 0;
-	u8 buf[2], rf_gain, if_gain;
-	int signal_strength;
-
-	dev_dbg(&client->dev, "\n");
-
-	if (!state->signal_strength_en)
-		return 0;
-
-	ret = regmap_bulk_read(state->regmap, 0xd07c, buf, 2);
-	if (ret)
-		goto err;
-
-	rf_gain = buf[0];
-	if_gain = buf[1];
-
-	signal_strength = (0xffff / \
-		(9 * (state->rf_50 + state->if_50) - \
-		11 * (state->rf_80 + state->if_80))) * \
-		(10 * (rf_gain + if_gain) - \
-		11 * (state->rf_80 + state->if_80));
-	if (signal_strength < 0)
-		signal_strength = 0;
-	else if (signal_strength > 0xffff)
-		signal_strength = 0xffff;
-
-	state->signal_strength = signal_strength;
-
-	return 0;
-err:
-	dev_dbg(&client->dev, "failed %d\n", ret);
-	return ret;
-}
-
-static void af9013_statistics_work(struct work_struct *work)
-{
-	struct af9013_state *state = container_of(work,
-		struct af9013_state, statistics_work.work);
-	unsigned int next_msec;
-
-	/* update only signal strength when demod is not locked */
-	if (!(state->fe_status & FE_HAS_LOCK)) {
-		state->statistics_step = 0;
-		state->ber = 0;
-		state->snr = 0;
-	}
-
-	switch (state->statistics_step) {
-	default:
-		state->statistics_step = 0;
-		/* fall-through */
-	case 0:
-		af9013_statistics_signal_strength(&state->fe);
-		state->statistics_step++;
-		next_msec = 300;
-		break;
-	case 1:
-		af9013_statistics_snr_start(&state->fe);
-		state->statistics_step++;
-		next_msec = 200;
-		break;
-	case 2:
-		af9013_statistics_ber_unc_start(&state->fe);
-		state->statistics_step++;
-		next_msec = 1000;
-		break;
-	case 3:
-		af9013_statistics_snr_result(&state->fe);
-		state->statistics_step++;
-		next_msec = 400;
-		break;
-	case 4:
-		af9013_statistics_ber_unc_result(&state->fe);
-		state->statistics_step++;
-		next_msec = 100;
-		break;
-	}
-
-	schedule_delayed_work(&state->statistics_work,
-		msecs_to_jiffies(next_msec));
-}
-
 static int af9013_get_tune_settings(struct dvb_frontend *fe,
 	struct dvb_frontend_tune_settings *fesettings)
 {
@@ -858,6 +632,9 @@ static int af9013_read_status(struct dvb_frontend *fe, enum fe_status *status)
 			stmp1, agc_gain, agc_gain_50dbm, agc_gain_80dbm);
 
 		state->strength_jiffies = jiffies;
+		/* Convert [-90, -30] dBm to [0x0000, 0xffff] for dvbv3 */
+		utmp1 = clamp(stmp1 + 90000, 0, 60000);
+		state->dvbv3_strength = div_u64((u64)utmp1 * 0xffff, 60000);
 
 		c->strength.stat[0].scale = FE_SCALE_DECIBEL;
 		c->strength.stat[0].svalue = stmp1;
@@ -939,6 +716,7 @@ static int af9013_read_status(struct dvb_frontend *fe, enum fe_status *status)
 		dev_dbg(&client->dev, "cnr %u\n", utmp1);
 
 		state->cnr_jiffies = jiffies;
+		state->dvbv3_snr = utmp1 / 100;
 
 		c->cnr.stat[0].scale = FE_SCALE_DECIBEL;
 		c->cnr.stat[0].svalue = utmp1;
@@ -994,6 +772,8 @@ static int af9013_read_status(struct dvb_frontend *fe, enum fe_status *status)
 			utmp3, utmp4);
 
 		state->ber_ucb_jiffies = jiffies;
+		state->dvbv3_ber = utmp1;
+		state->dvbv3_ucblocks += utmp3;
 
 		c->post_bit_error.stat[0].scale = FE_SCALE_COUNTER;
 		c->post_bit_error.stat[0].uvalue += utmp1;
@@ -1023,28 +803,36 @@ static int af9013_read_status(struct dvb_frontend *fe, enum fe_status *status)
 static int af9013_read_snr(struct dvb_frontend *fe, u16 *snr)
 {
 	struct af9013_state *state = fe->demodulator_priv;
-	*snr = state->snr;
+
+	*snr = state->dvbv3_snr;
+
 	return 0;
 }
 
 static int af9013_read_signal_strength(struct dvb_frontend *fe, u16 *strength)
 {
 	struct af9013_state *state = fe->demodulator_priv;
-	*strength = state->signal_strength;
+
+	*strength = state->dvbv3_strength;
+
 	return 0;
 }
 
 static int af9013_read_ber(struct dvb_frontend *fe, u32 *ber)
 {
 	struct af9013_state *state = fe->demodulator_priv;
-	*ber = state->ber;
+
+	*ber = state->dvbv3_ber;
+
 	return 0;
 }
 
 static int af9013_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)
 {
 	struct af9013_state *state = fe->demodulator_priv;
-	*ucblocks = state->ucblocks;
+
+	*ucblocks = state->dvbv3_ucblocks;
+
 	return 0;
 }
 
@@ -1194,50 +982,7 @@ static int af9013_init(struct dvb_frontend *fe)
 	if (ret)
 		goto err;
 
-	/* check if we support signal strength */
-	if (!state->signal_strength_en) {
-		ret = regmap_read(state->regmap, 0x9bee, &utmp);
-		if (ret)
-			goto err;
-
-		state->signal_strength_en = (utmp >> 0) & 0x01;
-	}
-
-	/* read values needed for signal strength calculation */
-	if (state->signal_strength_en && !state->rf_50) {
-		ret = regmap_bulk_read(state->regmap, 0x9bbd, &state->rf_50, 1);
-		if (ret)
-			goto err;
-		ret = regmap_bulk_read(state->regmap, 0x9bd0, &state->rf_80, 1);
-		if (ret)
-			goto err;
-		ret = regmap_bulk_read(state->regmap, 0x9be2, &state->if_50, 1);
-		if (ret)
-			goto err;
-		ret = regmap_bulk_read(state->regmap, 0x9be4, &state->if_80, 1);
-		if (ret)
-			goto err;
-	}
-
-	/* SNR */
-	ret = regmap_write(state->regmap, 0xd2e2, 0x01);
-	if (ret)
-		goto err;
-
-	/* BER / UCB */
-	buf[0] = (10000 >> 0) & 0xff;
-	buf[1] = (10000 >> 8) & 0xff;
-	ret = regmap_bulk_write(state->regmap, 0xd385, buf, 2);
-	if (ret)
-		goto err;
-
-	/* enable FEC monitor */
-	ret = regmap_update_bits(state->regmap, 0xd392, 0x02, 0x02);
-	if (ret)
-		goto err;
-
 	state->first_tune = true;
-	schedule_delayed_work(&state->statistics_work, msecs_to_jiffies(400));
 
 	return 0;
 err:
@@ -1254,9 +999,6 @@ static int af9013_sleep(struct dvb_frontend *fe)
 
 	dev_dbg(&client->dev, "\n");
 
-	/* stop statistics polling */
-	cancel_delayed_work_sync(&state->statistics_work);
-
 	/* disable lock led */
 	ret = regmap_update_bits(state->regmap, 0xd730, 0x01, 0x00);
 	if (ret)
@@ -1696,7 +1438,6 @@ static int af9013_probe(struct i2c_client *client,
 	state->spec_inv = pdata->spec_inv;
 	memcpy(&state->api_version, pdata->api_version, sizeof(state->api_version));
 	memcpy(&state->gpio, pdata->gpio, sizeof(state->gpio));
-	INIT_DELAYED_WORK(&state->statistics_work, af9013_statistics_work);
 	state->regmap = regmap_init(&client->dev, &regmap_bus, client,
 				  &regmap_config);
 	if (IS_ERR(state->regmap)) {
@@ -1762,9 +1503,6 @@ static int af9013_remove(struct i2c_client *client)
 
 	dev_dbg(&client->dev, "\n");
 
-	/* Stop statistics polling */
-	cancel_delayed_work_sync(&state->statistics_work);
-
 	regmap_exit(state->regmap);
 
 	kfree(state);

commit 233f3ef71c1abc2f5577e4617c76f4f3168ddd6e
Author: Antti Palosaari <crope@iki.fi>
Date:   Sun Jun 18 13:26:35 2017 -0400

    media: af9013: dvbv5 ber and per
    
    Implement dvbv5 ber and per.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/af9013.c b/drivers/media/dvb-frontends/af9013.c
index b3d08e437478..a054e39510e0 100644
--- a/drivers/media/dvb-frontends/af9013.c
+++ b/drivers/media/dvb-frontends/af9013.c
@@ -47,6 +47,7 @@ struct af9013_state {
 	unsigned long read_status_jiffies;
 	unsigned long strength_jiffies;
 	unsigned long cnr_jiffies;
+	unsigned long ber_ucb_jiffies;
 	bool first_tune;
 	bool i2c_gate_state;
 	unsigned int statistics_step:3;
@@ -754,7 +755,7 @@ static int af9013_read_status(struct dvb_frontend *fe, enum fe_status *status)
 	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
 	int ret, stmp1;
 	unsigned int utmp, utmp1, utmp2, utmp3, utmp4;
-	u8 buf[3];
+	u8 buf[7];
 
 	dev_dbg(&client->dev, "\n");
 
@@ -947,6 +948,72 @@ static int af9013_read_status(struct dvb_frontend *fe, enum fe_status *status)
 		break;
 	}
 
+	/* BER / PER */
+	switch (state->fe_status & FE_HAS_SYNC) {
+	case FE_HAS_SYNC:
+		if (time_is_after_jiffies(state->ber_ucb_jiffies + msecs_to_jiffies(2000)))
+			break;
+
+		/* Check if ber / ucb is ready */
+		ret = regmap_read(state->regmap, 0xd391, &utmp);
+		if (ret)
+			goto err;
+
+		if (!((utmp >> 4) & 0x01)) {
+			dev_dbg(&client->dev, "ber not ready\n");
+			break;
+		}
+
+		/* Read value */
+		ret = regmap_bulk_read(state->regmap, 0xd385, buf, 7);
+		if (ret)
+			goto err;
+
+		utmp1 = buf[4] << 16 | buf[3] << 8 | buf[2] << 0;
+		utmp2 = (buf[1] << 8 | buf[0] << 0) * 204 * 8;
+		utmp3 = buf[6] << 8 | buf[5] << 0;
+		utmp4 = buf[1] << 8 | buf[0] << 0;
+
+		/* Use 10000 TS packets for measure */
+		if (utmp4 != 10000) {
+			buf[0] = (10000 >> 0) & 0xff;
+			buf[1] = (10000 >> 8) & 0xff;
+			ret = regmap_bulk_write(state->regmap, 0xd385, buf, 2);
+			if (ret)
+				goto err;
+		}
+
+		/* Reset ber / ucb counter */
+		ret = regmap_update_bits(state->regmap, 0xd391, 0x20, 0x20);
+		if (ret)
+			goto err;
+
+		dev_dbg(&client->dev, "post_bit_error %u, post_bit_count %u\n",
+			utmp1, utmp2);
+		dev_dbg(&client->dev, "block_error %u, block_count %u\n",
+			utmp3, utmp4);
+
+		state->ber_ucb_jiffies = jiffies;
+
+		c->post_bit_error.stat[0].scale = FE_SCALE_COUNTER;
+		c->post_bit_error.stat[0].uvalue += utmp1;
+		c->post_bit_count.stat[0].scale = FE_SCALE_COUNTER;
+		c->post_bit_count.stat[0].uvalue += utmp2;
+
+		c->block_error.stat[0].scale = FE_SCALE_COUNTER;
+		c->block_error.stat[0].uvalue += utmp3;
+		c->block_count.stat[0].scale = FE_SCALE_COUNTER;
+		c->block_count.stat[0].uvalue += utmp4;
+		break;
+	default:
+		c->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+		c->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+
+		c->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+		c->block_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+		break;
+	}
+
 	return 0;
 err:
 	dev_dbg(&client->dev, "failed %d\n", ret);
@@ -1670,6 +1737,10 @@ static int af9013_probe(struct i2c_client *client,
 	c = &state->fe.dtv_property_cache;
 	c->strength.len = 1;
 	c->cnr.len = 1;
+	c->post_bit_error.len = 1;
+	c->post_bit_count.len = 1;
+	c->block_error.len = 1;
+	c->block_count.len = 1;
 
 	dev_info(&client->dev, "Afatech AF9013 successfully attached\n");
 	dev_info(&client->dev, "firmware version: %d.%d.%d.%d\n",

commit f3bb7e22b1854e7295800bd30b4ae08e5b69e3c3
Author: Antti Palosaari <crope@iki.fi>
Date:   Sun Jun 18 06:23:15 2017 -0400

    media: af9013: dvbv5 cnr
    
    Implement dvbv5 cnr.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/af9013.c b/drivers/media/dvb-frontends/af9013.c
index 4cb6371572c5..b3d08e437478 100644
--- a/drivers/media/dvb-frontends/af9013.c
+++ b/drivers/media/dvb-frontends/af9013.c
@@ -46,6 +46,7 @@ struct af9013_state {
 	unsigned long set_frontend_jiffies;
 	unsigned long read_status_jiffies;
 	unsigned long strength_jiffies;
+	unsigned long cnr_jiffies;
 	bool first_tune;
 	bool i2c_gate_state;
 	unsigned int statistics_step:3;
@@ -179,7 +180,6 @@ static int af9013_statistics_snr_result(struct dvb_frontend *fe)
 {
 	struct af9013_state *state = fe->demodulator_priv;
 	struct i2c_client *client = state->client;
-	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
 	int ret, i, len;
 	unsigned int utmp;
 	u8 buf[3];
@@ -235,9 +235,6 @@ static int af9013_statistics_snr_result(struct dvb_frontend *fe)
 	}
 	state->snr = utmp * 10; /* dB/10 */
 
-	c->cnr.stat[0].svalue = 1000 * utmp;
-	c->cnr.stat[0].scale = FE_SCALE_DECIBEL;
-
 	return 0;
 err:
 	dev_dbg(&client->dev, "failed %d\n", ret);
@@ -757,7 +754,7 @@ static int af9013_read_status(struct dvb_frontend *fe, enum fe_status *status)
 	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
 	int ret, stmp1;
 	unsigned int utmp, utmp1, utmp2, utmp3, utmp4;
-	u8 buf[2];
+	u8 buf[3];
 
 	dev_dbg(&client->dev, "\n");
 
@@ -869,6 +866,87 @@ static int af9013_read_status(struct dvb_frontend *fe, enum fe_status *status)
 		break;
 	}
 
+	/* CNR */
+	switch (state->fe_status & FE_HAS_VITERBI) {
+	case FE_HAS_VITERBI:
+		if (time_is_after_jiffies(state->cnr_jiffies + msecs_to_jiffies(2000)))
+			break;
+
+		/* Check if cnr ready */
+		ret = regmap_read(state->regmap, 0xd2e1, &utmp);
+		if (ret)
+			goto err;
+
+		if (!((utmp >> 3) & 0x01)) {
+			dev_dbg(&client->dev, "cnr not ready\n");
+			break;
+		}
+
+		/* Read value */
+		ret = regmap_bulk_read(state->regmap, 0xd2e3, buf, 3);
+		if (ret)
+			goto err;
+
+		utmp1 = buf[2] << 16 | buf[1] << 8 | buf[0] << 0;
+
+		/* Read current modulation */
+		ret = regmap_read(state->regmap, 0xd3c1, &utmp);
+		if (ret)
+			goto err;
+
+		switch ((utmp >> 6) & 3) {
+		case 0:
+			/*
+			 * QPSK
+			 * CNR[dB] 13 * -log10((1690000 - value) / value) + 2.6
+			 * value [653799, 1689999], 2.6 / 13 = 3355443
+			 */
+			utmp1 = clamp(utmp1, 653799U, 1689999U);
+			utmp1 = ((u64)(intlog10(utmp1)
+				- intlog10(1690000 - utmp1)
+				+ 3355443) * 13 * 1000) >> 24;
+			break;
+		case 1:
+			/*
+			 * QAM-16
+			 * CNR[dB] 6 * log10((value - 370000) / (828000 - value)) + 15.7
+			 * value [371105, 827999], 15.7 / 6 = 43900382
+			 */
+			utmp1 = clamp(utmp1, 371105U, 827999U);
+			utmp1 = ((u64)(intlog10(utmp1 - 370000)
+				- intlog10(828000 - utmp1)
+				+ 43900382) * 6 * 1000) >> 24;
+			break;
+		case 2:
+			/*
+			 * QAM-64
+			 * CNR[dB] 8 * log10((value - 193000) / (425000 - value)) + 23.8
+			 * value [193246, 424999], 23.8 / 8 = 49912218
+			 */
+			utmp1 = clamp(utmp1, 193246U, 424999U);
+			utmp1 = ((u64)(intlog10(utmp1 - 193000)
+				- intlog10(425000 - utmp1)
+				+ 49912218) * 8 * 1000) >> 24;
+			break;
+		default:
+			dev_dbg(&client->dev, "invalid modulation %u\n",
+				(utmp >> 6) & 3);
+			utmp1 = 0;
+			break;
+		}
+
+		dev_dbg(&client->dev, "cnr %u\n", utmp1);
+
+		state->cnr_jiffies = jiffies;
+
+		c->cnr.stat[0].scale = FE_SCALE_DECIBEL;
+		c->cnr.stat[0].svalue = utmp1;
+		break;
+	default:
+		c->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+		break;
+	}
+
 	return 0;
 err:
 	dev_dbg(&client->dev, "failed %d\n", ret);

commit 943a720f5c5c970e3961ccbf43b94cdcb645696a
Author: Antti Palosaari <crope@iki.fi>
Date:   Sun Jun 18 01:17:49 2017 -0400

    media: af9013: dvbv5 signal strength
    
    Implement dvbv5 signal strength estimate. We know tuner dependent
    -80dBm and -50dBm agc values, construct line equation and use it to
    map agc value to signal strength estimate.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/af9013.c b/drivers/media/dvb-frontends/af9013.c
index 30cf837058da..4cb6371572c5 100644
--- a/drivers/media/dvb-frontends/af9013.c
+++ b/drivers/media/dvb-frontends/af9013.c
@@ -41,8 +41,11 @@ struct af9013_state {
 	u16 snr;
 	u32 bandwidth_hz;
 	enum fe_status fe_status;
+	/* RF and IF AGC limits used for signal strength calc */
+	u8 strength_en, rf_agc_50, rf_agc_80, if_agc_50, if_agc_80;
 	unsigned long set_frontend_jiffies;
 	unsigned long read_status_jiffies;
+	unsigned long strength_jiffies;
 	bool first_tune;
 	bool i2c_gate_state;
 	unsigned int statistics_step:3;
@@ -751,8 +754,12 @@ static int af9013_read_status(struct dvb_frontend *fe, enum fe_status *status)
 {
 	struct af9013_state *state = fe->demodulator_priv;
 	struct i2c_client *client = state->client;
-	int ret;
-	unsigned int utmp, utmp1;
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	int ret, stmp1;
+	unsigned int utmp, utmp1, utmp2, utmp3, utmp4;
+	u8 buf[2];
+
+	dev_dbg(&client->dev, "\n");
 
 	/*
 	 * Return status from the cache if it is younger than 2000ms with the
@@ -791,6 +798,77 @@ static int af9013_read_status(struct dvb_frontend *fe, enum fe_status *status)
 		*status = utmp1;
 	}
 
+	/* Signal strength */
+	switch (state->strength_en) {
+	case 0:
+		/* Check if we support signal strength */
+		ret = regmap_read(state->regmap, 0x9bee, &utmp);
+		if (ret)
+			goto err;
+
+		if ((utmp >> 0) & 0x01) {
+			/* Read agc values for signal strength estimation */
+			ret = regmap_read(state->regmap, 0x9bbd, &utmp1);
+			if (ret)
+				goto err;
+			ret = regmap_read(state->regmap, 0x9bd0, &utmp2);
+			if (ret)
+				goto err;
+			ret = regmap_read(state->regmap, 0x9be2, &utmp3);
+			if (ret)
+				goto err;
+			ret = regmap_read(state->regmap, 0x9be4, &utmp4);
+			if (ret)
+				goto err;
+
+			state->rf_agc_50 = utmp1;
+			state->rf_agc_80 = utmp2;
+			state->if_agc_50 = utmp3;
+			state->if_agc_80 = utmp4;
+			dev_dbg(&client->dev,
+				"rf_agc_50 %u, rf_agc_80 %u, if_agc_50 %u, if_agc_80 %u\n",
+				utmp1, utmp2, utmp3, utmp4);
+
+			state->strength_en = 1;
+		} else {
+			/* Signal strength is not supported */
+			state->strength_en = 2;
+			break;
+		}
+		/* Fall through */
+	case 1:
+		if (time_is_after_jiffies(state->strength_jiffies + msecs_to_jiffies(2000)))
+			break;
+
+		/* Read value */
+		ret = regmap_bulk_read(state->regmap, 0xd07c, buf, 2);
+		if (ret)
+			goto err;
+
+		/*
+		 * Construct line equation from tuner dependent -80/-50 dBm agc
+		 * limits and use it to map current agc value to dBm estimate
+		 */
+		#define agc_gain (buf[0] + buf[1])
+		#define agc_gain_50dbm (state->rf_agc_50 + state->if_agc_50)
+		#define agc_gain_80dbm (state->rf_agc_80 + state->if_agc_80)
+		stmp1 = 30000 * (agc_gain - agc_gain_80dbm) /
+			(agc_gain_50dbm - agc_gain_80dbm) - 80000;
+
+		dev_dbg(&client->dev,
+			"strength %d, agc_gain %d, agc_gain_50dbm %d, agc_gain_80dbm %d\n",
+			stmp1, agc_gain, agc_gain_50dbm, agc_gain_80dbm);
+
+		state->strength_jiffies = jiffies;
+
+		c->strength.stat[0].scale = FE_SCALE_DECIBEL;
+		c->strength.stat[0].svalue = stmp1;
+		break;
+	default:
+		c->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+		break;
+	}
+
 	return 0;
 err:
 	dev_dbg(&client->dev, "failed %d\n", ret);
@@ -1512,6 +1590,7 @@ static int af9013_probe(struct i2c_client *client,
 
 	/* Init stats to indicate which stats are supported */
 	c = &state->fe.dtv_property_cache;
+	c->strength.len = 1;
 	c->cnr.len = 1;
 
 	dev_info(&client->dev, "Afatech AF9013 successfully attached\n");

commit 7903fbe3a636dbee04e5623931013feb80aab817
Author: Antti Palosaari <crope@iki.fi>
Date:   Wed Jun 21 11:02:42 2017 -0400

    media: af9013: change lock detection slightly
    
    Whilst rewritten largely, the basic logic remains same with one
    exception: do not return immediately on success case. We are going to
    add statistics that function and cannot return too early.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/af9013.c b/drivers/media/dvb-frontends/af9013.c
index b8f3ebfc3e27..30cf837058da 100644
--- a/drivers/media/dvb-frontends/af9013.c
+++ b/drivers/media/dvb-frontends/af9013.c
@@ -752,45 +752,44 @@ static int af9013_read_status(struct dvb_frontend *fe, enum fe_status *status)
 	struct af9013_state *state = fe->demodulator_priv;
 	struct i2c_client *client = state->client;
 	int ret;
-	unsigned int utmp;
+	unsigned int utmp, utmp1;
 
 	/*
 	 * Return status from the cache if it is younger than 2000ms with the
 	 * exception of last tune is done during 4000ms.
 	 */
-	if (time_is_after_jiffies(
-		state->read_status_jiffies + msecs_to_jiffies(2000)) &&
-		time_is_before_jiffies(
-		state->set_frontend_jiffies + msecs_to_jiffies(4000))
-	) {
-			*status = state->fe_status;
-			return 0;
+	if (time_is_after_jiffies(state->read_status_jiffies + msecs_to_jiffies(2000)) &&
+	    time_is_before_jiffies(state->set_frontend_jiffies + msecs_to_jiffies(4000))) {
+		*status = state->fe_status;
 	} else {
-		*status = 0;
-	}
+		/* MPEG2 lock */
+		ret = regmap_read(state->regmap, 0xd507, &utmp);
+		if (ret)
+			goto err;
 
-	/* MPEG2 lock */
-	ret = regmap_read(state->regmap, 0xd507, &utmp);
-	if (ret)
-		goto err;
+		if ((utmp >> 6) & 0x01) {
+			utmp1 = FE_HAS_SIGNAL | FE_HAS_CARRIER |
+				FE_HAS_VITERBI | FE_HAS_SYNC | FE_HAS_LOCK;
+		} else {
+			/* TPS lock */
+			ret = regmap_read(state->regmap, 0xd330, &utmp);
+			if (ret)
+				goto err;
 
-	if ((utmp >> 6) & 0x01)
-		*status |= FE_HAS_SIGNAL | FE_HAS_CARRIER | FE_HAS_VITERBI |
-			FE_HAS_SYNC | FE_HAS_LOCK;
+			if ((utmp >> 3) & 0x01)
+				utmp1 = FE_HAS_SIGNAL | FE_HAS_CARRIER |
+					FE_HAS_VITERBI;
+			else
+				utmp1 = 0;
+		}
 
-	if (!*status) {
-		/* TPS lock */
-		ret = regmap_read(state->regmap, 0xd330, &utmp);
-		if (ret)
-			goto err;
+		dev_dbg(&client->dev, "fe_status %02x\n", utmp1);
 
-		if ((utmp >> 3) & 0x01)
-			*status |= FE_HAS_SIGNAL | FE_HAS_CARRIER |
-				FE_HAS_VITERBI;
-	}
+		state->read_status_jiffies = jiffies;
 
-	state->fe_status = *status;
-	state->read_status_jiffies = jiffies;
+		state->fe_status = utmp1;
+		*status = utmp1;
+	}
 
 	return 0;
 err:

commit cdd19b526f5b806ff0468cec1d429feffaf10c89
Author: Antti Palosaari <crope@iki.fi>
Date:   Tue Jun 13 22:58:06 2017 -0300

    [media] af9013: refactor power control
    
    Move power-up and power-down functionality to init/sleep ops and
    get rid of old function.
    
    Fixes and simplifies power-up functionality slightly.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/af9013.c b/drivers/media/dvb-frontends/af9013.c
index 8408e155b6f5..b8f3ebfc3e27 100644
--- a/drivers/media/dvb-frontends/af9013.c
+++ b/drivers/media/dvb-frontends/af9013.c
@@ -101,59 +101,6 @@ static int af9013_set_gpio(struct af9013_state *state, u8 gpio, u8 gpioval)
 	return ret;
 }
 
-static int af9013_power_ctrl(struct af9013_state *state, u8 onoff)
-{
-	struct i2c_client *client = state->client;
-	int ret;
-	unsigned int utmp;
-
-	dev_dbg(&client->dev, "onoff %d\n", onoff);
-
-	/* enable reset */
-	ret = regmap_update_bits(state->regmap, 0xd417, 0x10, 0x10);
-	if (ret)
-		goto err;
-
-	/* start reset mechanism */
-	ret = regmap_write(state->regmap, 0xaeff, 0x01);
-	if (ret)
-		goto err;
-
-	/* wait reset performs */
-	ret = regmap_read_poll_timeout(state->regmap, 0xd417, utmp,
-				       (utmp >> 1) & 0x01, 5000, 1000000);
-	if (ret)
-		goto err;
-
-	if (!((utmp >> 1) & 0x01))
-		return -ETIMEDOUT;
-
-	if (onoff) {
-		/* clear reset */
-		ret = regmap_update_bits(state->regmap, 0xd417, 0x02, 0x00);
-		if (ret)
-			goto err;
-		/* disable reset */
-		ret = regmap_update_bits(state->regmap, 0xd417, 0x10, 0x00);
-		if (ret)
-			goto err;
-		/* power on */
-		ret = regmap_update_bits(state->regmap, 0xd73a, 0x08, 0x00);
-		if (ret)
-			goto err;
-	} else {
-		/* power off */
-		ret = regmap_update_bits(state->regmap, 0xd73a, 0x08, 0x08);
-		if (ret)
-			goto err;
-	}
-
-	return 0;
-err:
-	dev_dbg(&client->dev, "failed %d\n", ret);
-	return ret;
-}
-
 static int af9013_statistics_ber_unc_start(struct dvb_frontend *fe)
 {
 	struct af9013_state *state = fe->demodulator_priv;
@@ -890,8 +837,18 @@ static int af9013_init(struct dvb_frontend *fe)
 
 	dev_dbg(&client->dev, "\n");
 
-	/* power on */
-	ret = af9013_power_ctrl(state, 1);
+	/* ADC on */
+	ret = regmap_update_bits(state->regmap, 0xd73a, 0x08, 0x00);
+	if (ret)
+		goto err;
+
+	/* Clear reset */
+	ret = regmap_update_bits(state->regmap, 0xd417, 0x02, 0x00);
+	if (ret)
+		goto err;
+
+	/* Disable reset */
+	ret = regmap_update_bits(state->regmap, 0xd417, 0x10, 0x00);
 	if (ret)
 		goto err;
 
@@ -1071,6 +1028,7 @@ static int af9013_sleep(struct dvb_frontend *fe)
 	struct af9013_state *state = fe->demodulator_priv;
 	struct i2c_client *client = state->client;
 	int ret;
+	unsigned int utmp;
 
 	dev_dbg(&client->dev, "\n");
 
@@ -1082,8 +1040,29 @@ static int af9013_sleep(struct dvb_frontend *fe)
 	if (ret)
 		goto err;
 
-	/* power off */
-	ret = af9013_power_ctrl(state, 0);
+	/* Enable reset */
+	ret = regmap_update_bits(state->regmap, 0xd417, 0x10, 0x10);
+	if (ret)
+		goto err;
+
+	/* Start reset execution */
+	ret = regmap_write(state->regmap, 0xaeff, 0x01);
+	if (ret)
+		goto err;
+
+	/* Wait reset performs */
+	ret = regmap_read_poll_timeout(state->regmap, 0xd417, utmp,
+				       (utmp >> 1) & 0x01, 5000, 1000000);
+	if (ret)
+		goto err;
+
+	if (!((utmp >> 1) & 0x01)) {
+		ret = -ETIMEDOUT;
+		goto err;
+	}
+
+	/* ADC off */
+	ret = regmap_update_bits(state->regmap, 0xd73a, 0x08, 0x08);
 	if (ret)
 		goto err;
 

commit 96700d248e7cb47cf5a9e392f8331ed50670d39d
Author: Antti Palosaari <crope@iki.fi>
Date:   Tue Jun 13 21:49:33 2017 -0300

    [media] af9013: refactor firmware download routine
    
    Refactor firmware download routine.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/af9013.c b/drivers/media/dvb-frontends/af9013.c
index 5d61be45347a..8408e155b6f5 100644
--- a/drivers/media/dvb-frontends/af9013.c
+++ b/drivers/media/dvb-frontends/af9013.c
@@ -1137,64 +1137,59 @@ static const struct dvb_frontend_ops af9013_ops;
 static int af9013_download_firmware(struct af9013_state *state)
 {
 	struct i2c_client *client = state->client;
-	int ret, i, len, remaining;
+	int ret, i, len, rem;
 	unsigned int utmp;
-	const struct firmware *fw;
+	u8 buf[4];
 	u16 checksum = 0;
-	u8 fw_params[4];
-	u8 *fw_file = AF9013_FIRMWARE;
+	const struct firmware *firmware;
+	const char *name = AF9013_FIRMWARE;
 
-	msleep(100);
-	/* check whether firmware is already running */
+	dev_dbg(&client->dev, "\n");
+
+	/* Check whether firmware is already running */
 	ret = regmap_read(state->regmap, 0x98be, &utmp);
 	if (ret)
 		goto err;
 
 	dev_dbg(&client->dev, "firmware status %02x\n", utmp);
 
-	if (utmp == 0x0c) /* fw is running, no need for download */
+	if (utmp == 0x0c)
 		return 0;
 
 	dev_info(&client->dev, "found a '%s' in cold state, will try to load a firmware\n",
 		 af9013_ops.info.name);
 
-	/* request the firmware, this will block and timeout */
-	ret = request_firmware(&fw, fw_file, &client->dev);
+	/* Request the firmware, will block and timeout */
+	ret = request_firmware(&firmware, name, &client->dev);
 	if (ret) {
 		dev_info(&client->dev, "firmware file '%s' not found %d\n",
-			 fw_file, ret);
+			 name, ret);
 		goto err;
 	}
 
 	dev_info(&client->dev, "downloading firmware from file '%s'\n",
-		 fw_file);
-
-	/* calc checksum */
-	for (i = 0; i < fw->size; i++)
-		checksum += fw->data[i];
+		 name);
 
-	fw_params[0] = checksum >> 8;
-	fw_params[1] = checksum & 0xff;
-	fw_params[2] = fw->size >> 8;
-	fw_params[3] = fw->size & 0xff;
-
-	/* write fw checksum & size */
-	ret = regmap_bulk_write(state->regmap, 0x50fc, fw_params,
-				sizeof(fw_params));
+	/* Write firmware checksum & size */
+	for (i = 0; i < firmware->size; i++)
+		checksum += firmware->data[i];
 
+	buf[0] = (checksum >> 8) & 0xff;
+	buf[1] = (checksum >> 0) & 0xff;
+	buf[2] = (firmware->size >> 8) & 0xff;
+	buf[3] = (firmware->size >> 0) & 0xff;
+	ret = regmap_bulk_write(state->regmap, 0x50fc, buf, 4);
 	if (ret)
 		goto err_release_firmware;
 
-	#define FW_ADDR 0x5100 /* firmware start address */
-	#define LEN_MAX 16 /* max packet size */
-	for (remaining = fw->size; remaining > 0; remaining -= LEN_MAX) {
-		len = remaining;
-		if (len > LEN_MAX)
-			len = LEN_MAX;
-
+	/* Download firmware */
+	#define LEN_MAX 16
+	for (rem = firmware->size; rem > 0; rem -= LEN_MAX) {
+		len = min(LEN_MAX, rem);
 		ret = regmap_bulk_write(state->regmap,
-					FW_ADDR + fw->size - remaining,
-					&fw->data[fw->size - remaining], len);
+					0x5100 + firmware->size - rem,
+					&firmware->data[firmware->size - rem],
+					len);
 		if (ret) {
 			dev_err(&client->dev, "firmware download failed %d\n",
 				ret);
@@ -1202,9 +1197,9 @@ static int af9013_download_firmware(struct af9013_state *state)
 		}
 	}
 
-	release_firmware(fw);
+	release_firmware(firmware);
 
-	/* request boot firmware */
+	/* Boot firmware */
 	ret = regmap_write(state->regmap, 0xe205, 0x01);
 	if (ret)
 		goto err;
@@ -1233,7 +1228,7 @@ static int af9013_download_firmware(struct af9013_state *state)
 
 	return 0;
 err_release_firmware:
-	release_firmware(fw);
+	release_firmware(firmware);
 err:
 	dev_dbg(&client->dev, "failed %d\n", ret);
 	return ret;

commit b2c952377593d0fe0bf1c8d27bd51678979ed34d
Author: Antti Palosaari <crope@iki.fi>
Date:   Tue Jun 13 20:42:52 2017 -0300

    [media] af9013: remove unneeded register writes
    
    Removed register writes are already chip defaults, are not required,
    are set later or belong to AF9015 USB interface.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/af9013.c b/drivers/media/dvb-frontends/af9013.c
index 2b86688d73e0..5d61be45347a 100644
--- a/drivers/media/dvb-frontends/af9013.c
+++ b/drivers/media/dvb-frontends/af9013.c
@@ -895,11 +895,6 @@ static int af9013_init(struct dvb_frontend *fe)
 	if (ret)
 		goto err;
 
-	/* enable ADC */
-	ret = regmap_write(state->regmap, 0xd73a, 0xa4);
-	if (ret)
-		goto err;
-
 	/* write API version to firmware */
 	ret = regmap_bulk_write(state->regmap, 0x9bf2, state->api_version, 4);
 	if (ret)
@@ -936,43 +931,6 @@ static int af9013_init(struct dvb_frontend *fe)
 	if (ret)
 		goto err;
 
-	/* set I2C master clock */
-	ret = regmap_write(state->regmap, 0xd416, 0x14);
-	if (ret)
-		goto err;
-
-	/* set 16 embx */
-	ret = regmap_update_bits(state->regmap, 0xd700, 0x02, 0x02);
-	if (ret)
-		goto err;
-
-	/* set no trigger */
-	ret = regmap_update_bits(state->regmap, 0xd700, 0x04, 0x00);
-	if (ret)
-		goto err;
-
-	/* set read-update bit for constellation */
-	ret = regmap_update_bits(state->regmap, 0xd371, 0x02, 0x02);
-	if (ret)
-		goto err;
-
-	/* settings for mp2if */
-	if (state->ts_mode == AF9013_TS_MODE_USB) {
-		/* AF9015 split PSB to 1.5k + 0.5k */
-		ret = regmap_update_bits(state->regmap, 0xd50b, 0x04, 0x04);
-		if (ret)
-			goto err;
-	} else {
-		/* AF9013 set mpeg to full speed */
-		ret = regmap_update_bits(state->regmap, 0xd502, 0x10, 0x10);
-		if (ret)
-			goto err;
-	}
-
-	ret = regmap_update_bits(state->regmap, 0xd520, 0x10, 0x10);
-	if (ret)
-		goto err;
-
 	/* load OFSM settings */
 	dev_dbg(&client->dev, "load ofsm settings\n");
 	len = ARRAY_SIZE(ofsm_init);

commit eaa455f023c3ac62f99dcb0aed1bd3986b61f71e
Author: Antti Palosaari <crope@iki.fi>
Date:   Tue Jun 13 20:32:15 2017 -0300

    [media] af9013: add configurable TS output pin
    
    On serial TS mode output pin could be selected from D0 or D7.
    Add configuration option to for it.
    
    Rename TS mode config option prefix from AF9013_TS_ to AF9013_TS_MODE_.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/af9013.c b/drivers/media/dvb-frontends/af9013.c
index 2acd9fdd8b39..2b86688d73e0 100644
--- a/drivers/media/dvb-frontends/af9013.c
+++ b/drivers/media/dvb-frontends/af9013.c
@@ -28,6 +28,7 @@ struct af9013_state {
 	u8 tuner;
 	u32 if_frequency;
 	u8 ts_mode;
+	u8 ts_output_pin;
 	bool spec_inv;
 	u8 api_version[4];
 	u8 gpio[4];
@@ -956,17 +957,12 @@ static int af9013_init(struct dvb_frontend *fe)
 		goto err;
 
 	/* settings for mp2if */
-	if (state->ts_mode == AF9013_TS_USB) {
+	if (state->ts_mode == AF9013_TS_MODE_USB) {
 		/* AF9015 split PSB to 1.5k + 0.5k */
 		ret = regmap_update_bits(state->regmap, 0xd50b, 0x04, 0x04);
 		if (ret)
 			goto err;
 	} else {
-		/* AF9013 change the output bit to data7 */
-		ret = regmap_update_bits(state->regmap, 0xd500, 0x08, 0x08);
-		if (ret)
-			goto err;
-
 		/* AF9013 set mpeg to full speed */
 		ret = regmap_update_bits(state->regmap, 0xd502, 0x10, 0x10);
 		if (ret)
@@ -1047,9 +1043,12 @@ static int af9013_init(struct dvb_frontend *fe)
 			goto err;
 	}
 
-	/* TS mode */
-	ret = regmap_update_bits(state->regmap, 0xd500, 0x06,
-				 state->ts_mode << 1);
+	/* TS interface */
+	if (state->ts_output_pin == 7)
+		utmp = 1 << 3 | state->ts_mode << 1;
+	else
+		utmp = 0 << 3 | state->ts_mode << 1;
+	ret = regmap_update_bits(state->regmap, 0xd500, 0x0e, utmp);
 	if (ret)
 		goto err;
 
@@ -1148,7 +1147,7 @@ static int af9013_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)
 	if (state->i2c_gate_state == enable)
 		return 0;
 
-	if (state->ts_mode == AF9013_TS_USB)
+	if (state->ts_mode == AF9013_TS_MODE_USB)
 		ret = regmap_update_bits(state->regmap, 0xd417, 0x08,
 					 enable << 3);
 	else
@@ -1298,6 +1297,7 @@ struct dvb_frontend *af9013_attach(const struct af9013_config *config,
 	pdata.tuner = config->tuner;
 	pdata.if_frequency = config->if_frequency;
 	pdata.ts_mode = config->ts_mode;
+	pdata.ts_output_pin = 7;
 	pdata.spec_inv = config->spec_inv;
 	memcpy(&pdata.api_version, config->api_version, sizeof(pdata.api_version));
 	memcpy(&pdata.gpio, config->gpio, sizeof(pdata.gpio));
@@ -1451,7 +1451,7 @@ static int af9013_regmap_write(void *context, const void *data, size_t count)
 	u8 *val = &((u8 *)data)[2];
 	const unsigned int len = count - 2;
 
-	if (state->ts_mode == AF9013_TS_USB && (reg & 0xff00) != 0xae00) {
+	if (state->ts_mode == AF9013_TS_MODE_USB && (reg & 0xff00) != 0xae00) {
 		cmd = 0 << 7|0 << 6|(len - 1) << 2|1 << 1|1 << 0;
 		ret = af9013_wregs(client, cmd, reg, val, len);
 		if (ret)
@@ -1488,7 +1488,7 @@ static int af9013_regmap_read(void *context, const void *reg_buf,
 	u8 *val = &((u8 *)val_buf)[0];
 	const unsigned int len = val_size;
 
-	if (state->ts_mode == AF9013_TS_USB && (reg & 0xff00) != 0xae00) {
+	if (state->ts_mode == AF9013_TS_MODE_USB && (reg & 0xff00) != 0xae00) {
 		cmd = 0 << 7|0 << 6|(len - 1) << 2|1 << 1|0 << 0;
 		ret = af9013_rregs(client, cmd, reg, val_buf, len);
 		if (ret)
@@ -1538,6 +1538,7 @@ static int af9013_probe(struct i2c_client *client,
 	state->tuner = pdata->tuner;
 	state->if_frequency = pdata->if_frequency;
 	state->ts_mode = pdata->ts_mode;
+	state->ts_output_pin = pdata->ts_output_pin;
 	state->spec_inv = pdata->spec_inv;
 	memcpy(&state->api_version, pdata->api_version, sizeof(state->api_version));
 	memcpy(&state->gpio, pdata->gpio, sizeof(state->gpio));
@@ -1550,7 +1551,7 @@ static int af9013_probe(struct i2c_client *client,
 	}
 
 	/* Download firmware */
-	if (state->ts_mode != AF9013_TS_USB) {
+	if (state->ts_mode != AF9013_TS_MODE_USB) {
 		ret = af9013_download_firmware(state);
 		if (ret)
 			goto err_regmap_exit;

commit d029799b2f52e98f4b0920ed9b80b169f522e0cb
Author: Antti Palosaari <crope@iki.fi>
Date:   Mon Jun 12 15:10:08 2017 -0300

    [media] af9013: add dvbv5 cnr
    
    Add support for DVBv5 CNR.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/af9013.c b/drivers/media/dvb-frontends/af9013.c
index 84b04ab20d21..2acd9fdd8b39 100644
--- a/drivers/media/dvb-frontends/af9013.c
+++ b/drivers/media/dvb-frontends/af9013.c
@@ -228,6 +228,7 @@ static int af9013_statistics_snr_result(struct dvb_frontend *fe)
 {
 	struct af9013_state *state = fe->demodulator_priv;
 	struct i2c_client *client = state->client;
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
 	int ret, i, len;
 	unsigned int utmp;
 	u8 buf[3];
@@ -283,6 +284,9 @@ static int af9013_statistics_snr_result(struct dvb_frontend *fe)
 	}
 	state->snr = utmp * 10; /* dB/10 */
 
+	c->cnr.stat[0].svalue = 1000 * utmp;
+	c->cnr.stat[0].scale = FE_SCALE_DECIBEL;
+
 	return 0;
 err:
 	dev_dbg(&client->dev, "failed %d\n", ret);
@@ -1509,6 +1513,7 @@ static int af9013_probe(struct i2c_client *client,
 {
 	struct af9013_state *state;
 	struct af9013_platform_data *pdata = client->dev.platform_data;
+	struct dtv_frontend_properties *c;
 	int ret, i;
 	u8 firmware_version[4];
 	static const struct regmap_bus regmap_bus = {
@@ -1573,6 +1578,10 @@ static int af9013_probe(struct i2c_client *client,
 	/* Setup callbacks */
 	pdata->get_dvb_frontend = af9013_get_dvb_frontend;
 
+	/* Init stats to indicate which stats are supported */
+	c = &state->fe.dtv_property_cache;
+	c->cnr.len = 1;
+
 	dev_info(&client->dev, "Afatech AF9013 successfully attached\n");
 	dev_info(&client->dev, "firmware version: %d.%d.%d.%d\n",
 		 firmware_version[0], firmware_version[1],

commit bf69e07262f69da5893faca8b696d1a561b0dd24
Author: Antti Palosaari <crope@iki.fi>
Date:   Mon Jun 12 14:32:36 2017 -0300

    [media] af9013: fix error handling
    
    Use typical (return 0/goto err/return err) error handling everywhere.
    Add missing error handling where missing.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/af9013.c b/drivers/media/dvb-frontends/af9013.c
index 3ee9ab1a47cc..84b04ab20d21 100644
--- a/drivers/media/dvb-frontends/af9013.c
+++ b/drivers/media/dvb-frontends/af9013.c
@@ -94,7 +94,7 @@ static int af9013_set_gpio(struct af9013_state *state, u8 gpio, u8 gpioval)
 	if (ret)
 		goto err;
 
-	return ret;
+	return 0;
 err:
 	dev_dbg(&client->dev, "failed %d\n", ret);
 	return ret;
@@ -147,7 +147,7 @@ static int af9013_power_ctrl(struct af9013_state *state, u8 onoff)
 			goto err;
 	}
 
-	return ret;
+	return 0;
 err:
 	dev_dbg(&client->dev, "failed %d\n", ret);
 	return ret;
@@ -166,7 +166,7 @@ static int af9013_statistics_ber_unc_start(struct dvb_frontend *fe)
 	if (ret)
 		goto err;
 
-	return ret;
+	return 0;
 err:
 	dev_dbg(&client->dev, "failed %d\n", ret);
 	return ret;
@@ -199,7 +199,7 @@ static int af9013_statistics_ber_unc_result(struct dvb_frontend *fe)
 	state->ber = (buf[2] << 16) | (buf[1] << 8) | buf[0];
 	state->ucblocks += (buf[4] << 8) | buf[3];
 
-	return ret;
+	return 0;
 err:
 	dev_dbg(&client->dev, "failed %d\n", ret);
 	return ret;
@@ -218,7 +218,7 @@ static int af9013_statistics_snr_start(struct dvb_frontend *fe)
 	if (ret)
 		goto err;
 
-	return ret;
+	return 0;
 err:
 	dev_dbg(&client->dev, "failed %d\n", ret);
 	return ret;
@@ -283,7 +283,7 @@ static int af9013_statistics_snr_result(struct dvb_frontend *fe)
 	}
 	state->snr = utmp * 10; /* dB/10 */
 
-	return ret;
+	return 0;
 err:
 	dev_dbg(&client->dev, "failed %d\n", ret);
 	return ret;
@@ -321,7 +321,7 @@ static int af9013_statistics_signal_strength(struct dvb_frontend *fe)
 
 	state->signal_strength = signal_strength;
 
-	return ret;
+	return 0;
 err:
 	dev_dbg(&client->dev, "failed %d\n", ret);
 	return ret;
@@ -399,8 +399,11 @@ static int af9013_set_frontend(struct dvb_frontend *fe)
 		c->frequency, c->bandwidth_hz);
 
 	/* program tuner */
-	if (fe->ops.tuner_ops.set_params)
-		fe->ops.tuner_ops.set_params(fe);
+	if (fe->ops.tuner_ops.set_params) {
+		ret = fe->ops.tuner_ops.set_params(fe);
+		if (ret)
+			goto err;
+	}
 
 	/* program CFOE coefficients */
 	if (c->bandwidth_hz != state->bandwidth_hz) {
@@ -412,8 +415,10 @@ static int af9013_set_frontend(struct dvb_frontend *fe)
 		}
 
 		/* Return an error if can't find bandwidth or the right clock */
-		if (i == ARRAY_SIZE(coeff_lut))
-			return -EINVAL;
+		if (i == ARRAY_SIZE(coeff_lut)) {
+			ret = -EINVAL;
+			goto err;
+		}
 
 		ret = regmap_bulk_write(state->regmap, 0xae00, coeff_lut[i].val,
 					sizeof(coeff_lut[i].val));
@@ -424,10 +429,14 @@ static int af9013_set_frontend(struct dvb_frontend *fe)
 	/* program frequency control */
 	if (c->bandwidth_hz != state->bandwidth_hz || state->first_tune) {
 		/* get used IF frequency */
-		if (fe->ops.tuner_ops.get_if_frequency)
-			fe->ops.tuner_ops.get_if_frequency(fe, &if_frequency);
-		else
+		if (fe->ops.tuner_ops.get_if_frequency) {
+			ret = fe->ops.tuner_ops.get_if_frequency(fe,
+								 &if_frequency);
+			if (ret)
+				goto err;
+		} else {
 			if_frequency = state->if_frequency;
+		}
 
 		dev_dbg(&client->dev, "if_frequency %u\n", if_frequency);
 
@@ -662,7 +671,7 @@ static int af9013_set_frontend(struct dvb_frontend *fe)
 	state->set_frontend_jiffies = jiffies;
 	state->first_tune = false;
 
-	return ret;
+	return 0;
 err:
 	dev_dbg(&client->dev, "failed %d\n", ret);
 	return ret;
@@ -780,7 +789,7 @@ static int af9013_get_frontend(struct dvb_frontend *fe,
 		break;
 	}
 
-	return ret;
+	return 0;
 err:
 	dev_dbg(&client->dev, "failed %d\n", ret);
 	return ret;
@@ -831,7 +840,7 @@ static int af9013_read_status(struct dvb_frontend *fe, enum fe_status *status)
 	state->fe_status = *status;
 	state->read_status_jiffies = jiffies;
 
-	return ret;
+	return 0;
 err:
 	dev_dbg(&client->dev, "failed %d\n", ret);
 	return ret;
@@ -1090,7 +1099,7 @@ static int af9013_init(struct dvb_frontend *fe)
 	state->first_tune = true;
 	schedule_delayed_work(&state->statistics_work, msecs_to_jiffies(400));
 
-	return ret;
+	return 0;
 err:
 	dev_dbg(&client->dev, "failed %d\n", ret);
 	return ret;
@@ -1117,7 +1126,7 @@ static int af9013_sleep(struct dvb_frontend *fe)
 	if (ret)
 		goto err;
 
-	return ret;
+	return 0;
 err:
 	dev_dbg(&client->dev, "failed %d\n", ret);
 	return ret;
@@ -1146,7 +1155,7 @@ static int af9013_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)
 
 	state->i2c_gate_state = enable;
 
-	return ret;
+	return 0;
 err:
 	dev_dbg(&client->dev, "failed %d\n", ret);
 	return ret;
@@ -1167,7 +1176,7 @@ static const struct dvb_frontend_ops af9013_ops;
 static int af9013_download_firmware(struct af9013_state *state)
 {
 	struct i2c_client *client = state->client;
-	int i, len, remaining, ret;
+	int ret, i, len, remaining;
 	unsigned int utmp;
 	const struct firmware *fw;
 	u16 checksum = 0;
@@ -1179,11 +1188,11 @@ static int af9013_download_firmware(struct af9013_state *state)
 	ret = regmap_read(state->regmap, 0x98be, &utmp);
 	if (ret)
 		goto err;
-	else
-		dev_dbg(&client->dev, "firmware status %02x\n", utmp);
+
+	dev_dbg(&client->dev, "firmware status %02x\n", utmp);
 
 	if (utmp == 0x0c) /* fw is running, no need for download */
-		goto exit;
+		return 0;
 
 	dev_info(&client->dev, "found a '%s' in cold state, will try to load a firmware\n",
 		 af9013_ops.info.name);
@@ -1213,7 +1222,7 @@ static int af9013_download_firmware(struct af9013_state *state)
 				sizeof(fw_params));
 
 	if (ret)
-		goto err_release;
+		goto err_release_firmware;
 
 	#define FW_ADDR 0x5100 /* firmware start address */
 	#define LEN_MAX 16 /* max packet size */
@@ -1228,39 +1237,44 @@ static int af9013_download_firmware(struct af9013_state *state)
 		if (ret) {
 			dev_err(&client->dev, "firmware download failed %d\n",
 				ret);
-			goto err_release;
+			goto err_release_firmware;
 		}
 	}
 
+	release_firmware(fw);
+
 	/* request boot firmware */
 	ret = regmap_write(state->regmap, 0xe205, 0x01);
 	if (ret)
-		goto err_release;
+		goto err;
 
 	/* Check firmware status. 0c=OK, 04=fail */
 	ret = regmap_read_poll_timeout(state->regmap, 0x98be, utmp,
 				       (utmp == 0x0c || utmp == 0x04),
 				       5000, 1000000);
 	if (ret)
-		goto err_release;
+		goto err;
 
 	dev_dbg(&client->dev, "firmware status %02x\n", utmp);
 
 	if (utmp == 0x04) {
-		dev_err(&client->dev, "firmware did not run\n");
 		ret = -ENODEV;
+		dev_err(&client->dev, "firmware did not run\n");
+		goto err;
 	} else if (utmp != 0x0c) {
-		dev_err(&client->dev, "firmware boot timeout\n");
 		ret = -ENODEV;
+		dev_err(&client->dev, "firmware boot timeout\n");
+		goto err;
 	}
 
-err_release:
+	dev_info(&client->dev, "found a '%s' in warm state\n",
+		 af9013_ops.info.name);
+
+	return 0;
+err_release_firmware:
 	release_firmware(fw);
 err:
-exit:
-	if (!ret)
-		dev_info(&client->dev, "found a '%s' in warm state\n",
-			 af9013_ops.info.name);
+	dev_dbg(&client->dev, "failed %d\n", ret);
 	return ret;
 }
 

commit f458a1bc671c38a7819be7f047d47dedcbc16aca
Author: Antti Palosaari <crope@iki.fi>
Date:   Mon Jun 12 02:49:33 2017 -0300

    [media] af9013: convert to regmap api
    
    Use regmap for register access. Own low level i2c read and write
    routines for regmap is still needed because chip uses single command
    byte in addition to typical i2c register access.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/af9013.c b/drivers/media/dvb-frontends/af9013.c
index 9a4e662cb311..3ee9ab1a47cc 100644
--- a/drivers/media/dvb-frontends/af9013.c
+++ b/drivers/media/dvb-frontends/af9013.c
@@ -20,11 +20,9 @@
 
 #include "af9013_priv.h"
 
-/* Max transfer size done by I2C transfer functions */
-#define MAX_XFER_SIZE  64
-
 struct af9013_state {
 	struct i2c_client *client;
+	struct regmap *regmap;
 	struct dvb_frontend fe;
 	u32 clk;
 	u8 tuner;
@@ -50,181 +48,6 @@ struct af9013_state {
 	struct delayed_work statistics_work;
 };
 
-/* write multiple registers */
-static int af9013_wr_regs_i2c(struct af9013_state *state, u8 mbox, u16 reg,
-	const u8 *val, int len)
-{
-	struct i2c_client *client = state->client;
-	int ret;
-	u8 buf[MAX_XFER_SIZE];
-	struct i2c_msg msg[1] = {
-		{
-			.addr = state->client->addr,
-			.flags = 0,
-			.len = 3 + len,
-			.buf = buf,
-		}
-	};
-
-	if (3 + len > sizeof(buf)) {
-		dev_warn(&client->dev, "i2c wr reg %04x, len %d, is too big!\n",
-			 reg, len);
-		return -EINVAL;
-	}
-
-	buf[0] = (reg >> 8) & 0xff;
-	buf[1] = (reg >> 0) & 0xff;
-	buf[2] = mbox;
-	memcpy(&buf[3], val, len);
-
-	ret = i2c_transfer(state->client->adapter, msg, 1);
-	if (ret == 1) {
-		ret = 0;
-	} else {
-		dev_warn(&client->dev, "i2c wr failed %d, reg %04x, len %d\n",
-			 ret, reg, len);
-		ret = -EREMOTEIO;
-	}
-	return ret;
-}
-
-/* read multiple registers */
-static int af9013_rd_regs_i2c(struct af9013_state *state, u8 mbox, u16 reg,
-	u8 *val, int len)
-{
-	struct i2c_client *client = state->client;
-	int ret;
-	u8 buf[3];
-	struct i2c_msg msg[2] = {
-		{
-			.addr = state->client->addr,
-			.flags = 0,
-			.len = 3,
-			.buf = buf,
-		}, {
-			.addr = state->client->addr,
-			.flags = I2C_M_RD,
-			.len = len,
-			.buf = val,
-		}
-	};
-
-	buf[0] = (reg >> 8) & 0xff;
-	buf[1] = (reg >> 0) & 0xff;
-	buf[2] = mbox;
-
-	ret = i2c_transfer(state->client->adapter, msg, 2);
-	if (ret == 2) {
-		ret = 0;
-	} else {
-		dev_warn(&client->dev, "i2c rd failed %d, reg %04x, len %d\n",
-			 ret, reg, len);
-		ret = -EREMOTEIO;
-	}
-	return ret;
-}
-
-/* write multiple registers */
-static int af9013_wr_regs(struct af9013_state *state, u16 reg, const u8 *val,
-	int len)
-{
-	int ret, i;
-	u8 mbox = (0 << 7)|(0 << 6)|(1 << 1)|(1 << 0);
-
-	if ((state->ts_mode == AF9013_TS_USB) &&
-		((reg & 0xff00) != 0xff00) && ((reg & 0xff00) != 0xae00)) {
-		mbox |= ((len - 1) << 2);
-		ret = af9013_wr_regs_i2c(state, mbox, reg, val, len);
-	} else {
-		for (i = 0; i < len; i++) {
-			ret = af9013_wr_regs_i2c(state, mbox, reg+i, val+i, 1);
-			if (ret)
-				goto err;
-		}
-	}
-
-err:
-	return 0;
-}
-
-/* read multiple registers */
-static int af9013_rd_regs(struct af9013_state *state, u16 reg, u8 *val, int len)
-{
-	int ret, i;
-	u8 mbox = (0 << 7)|(0 << 6)|(1 << 1)|(0 << 0);
-
-	if ((state->ts_mode == AF9013_TS_USB) &&
-		((reg & 0xff00) != 0xff00) && ((reg & 0xff00) != 0xae00)) {
-		mbox |= ((len - 1) << 2);
-		ret = af9013_rd_regs_i2c(state, mbox, reg, val, len);
-	} else {
-		for (i = 0; i < len; i++) {
-			ret = af9013_rd_regs_i2c(state, mbox, reg+i, val+i, 1);
-			if (ret)
-				goto err;
-		}
-	}
-
-err:
-	return 0;
-}
-
-/* write single register */
-static int af9013_wr_reg(struct af9013_state *state, u16 reg, u8 val)
-{
-	return af9013_wr_regs(state, reg, &val, 1);
-}
-
-/* read single register */
-static int af9013_rd_reg(struct af9013_state *state, u16 reg, u8 *val)
-{
-	return af9013_rd_regs(state, reg, val, 1);
-}
-
-static int af9013_write_ofsm_regs(struct af9013_state *state, u16 reg, u8 *val,
-	u8 len)
-{
-	u8 mbox = (1 << 7)|(1 << 6)|((len - 1) << 2)|(1 << 1)|(1 << 0);
-	return af9013_wr_regs_i2c(state, mbox, reg, val, len);
-}
-
-static int af9013_wr_reg_bits(struct af9013_state *state, u16 reg, int pos,
-	int len, u8 val)
-{
-	int ret;
-	u8 tmp, mask;
-
-	/* no need for read if whole reg is written */
-	if (len != 8) {
-		ret = af9013_rd_reg(state, reg, &tmp);
-		if (ret)
-			return ret;
-
-		mask = (0xff >> (8 - len)) << pos;
-		val <<= pos;
-		tmp &= ~mask;
-		val |= tmp;
-	}
-
-	return af9013_wr_reg(state, reg, val);
-}
-
-static int af9013_rd_reg_bits(struct af9013_state *state, u16 reg, int pos,
-	int len, u8 *val)
-{
-	int ret;
-	u8 tmp;
-
-	ret = af9013_rd_reg(state, reg, &tmp);
-	if (ret)
-		return ret;
-
-	*val = (tmp >> pos);
-	*val &= (0xff >> (8 - len));
-
-	return 0;
-}
-
 static int af9013_set_gpio(struct af9013_state *state, u8 gpio, u8 gpioval)
 {
 	struct i2c_client *client = state->client;
@@ -266,7 +89,8 @@ static int af9013_set_gpio(struct af9013_state *state, u8 gpio, u8 gpioval)
 		break;
 	}
 
-	ret = af9013_wr_reg_bits(state, addr, pos, 4, gpioval);
+	ret = regmap_update_bits(state->regmap, addr, 0x0f << pos,
+				 gpioval << pos);
 	if (ret)
 		goto err;
 
@@ -279,50 +103,48 @@ static int af9013_set_gpio(struct af9013_state *state, u8 gpio, u8 gpioval)
 static int af9013_power_ctrl(struct af9013_state *state, u8 onoff)
 {
 	struct i2c_client *client = state->client;
-	int ret, i;
-	u8 tmp;
+	int ret;
+	unsigned int utmp;
 
 	dev_dbg(&client->dev, "onoff %d\n", onoff);
 
 	/* enable reset */
-	ret = af9013_wr_reg_bits(state, 0xd417, 4, 1, 1);
+	ret = regmap_update_bits(state->regmap, 0xd417, 0x10, 0x10);
 	if (ret)
 		goto err;
 
 	/* start reset mechanism */
-	ret = af9013_wr_reg(state, 0xaeff, 1);
+	ret = regmap_write(state->regmap, 0xaeff, 0x01);
 	if (ret)
 		goto err;
 
 	/* wait reset performs */
-	for (i = 0; i < 150; i++) {
-		ret = af9013_rd_reg_bits(state, 0xd417, 1, 1, &tmp);
-		if (ret)
-			goto err;
-
-		if (tmp)
-			break; /* reset done */
-
-		usleep_range(5000, 25000);
-	}
+	ret = regmap_read_poll_timeout(state->regmap, 0xd417, utmp,
+				       (utmp >> 1) & 0x01, 5000, 1000000);
+	if (ret)
+		goto err;
 
-	if (!tmp)
+	if (!((utmp >> 1) & 0x01))
 		return -ETIMEDOUT;
 
 	if (onoff) {
 		/* clear reset */
-		ret = af9013_wr_reg_bits(state, 0xd417, 1, 1, 0);
+		ret = regmap_update_bits(state->regmap, 0xd417, 0x02, 0x00);
 		if (ret)
 			goto err;
-
 		/* disable reset */
-		ret = af9013_wr_reg_bits(state, 0xd417, 4, 1, 0);
-
+		ret = regmap_update_bits(state->regmap, 0xd417, 0x10, 0x00);
+		if (ret)
+			goto err;
 		/* power on */
-		ret = af9013_wr_reg_bits(state, 0xd73a, 3, 1, 0);
+		ret = regmap_update_bits(state->regmap, 0xd73a, 0x08, 0x00);
+		if (ret)
+			goto err;
 	} else {
 		/* power off */
-		ret = af9013_wr_reg_bits(state, 0xd73a, 3, 1, 1);
+		ret = regmap_update_bits(state->regmap, 0xd73a, 0x08, 0x08);
+		if (ret)
+			goto err;
 	}
 
 	return ret;
@@ -340,7 +162,7 @@ static int af9013_statistics_ber_unc_start(struct dvb_frontend *fe)
 	dev_dbg(&client->dev, "\n");
 
 	/* reset and start BER counter */
-	ret = af9013_wr_reg_bits(state, 0xd391, 4, 1, 1);
+	ret = regmap_update_bits(state->regmap, 0xd391, 0x10, 0x10);
 	if (ret)
 		goto err;
 
@@ -355,21 +177,22 @@ static int af9013_statistics_ber_unc_result(struct dvb_frontend *fe)
 	struct af9013_state *state = fe->demodulator_priv;
 	struct i2c_client *client = state->client;
 	int ret;
+	unsigned int utmp;
 	u8 buf[5];
 
 	dev_dbg(&client->dev, "\n");
 
 	/* check if error bit count is ready */
-	ret = af9013_rd_reg_bits(state, 0xd391, 4, 1, &buf[0]);
+	ret = regmap_read(state->regmap, 0xd391, &utmp);
 	if (ret)
 		goto err;
 
-	if (!buf[0]) {
+	if (!((utmp >> 4) & 0x01)) {
 		dev_dbg(&client->dev, "not ready\n");
 		return 0;
 	}
 
-	ret = af9013_rd_regs(state, 0xd387, buf, 5);
+	ret = regmap_bulk_read(state->regmap, 0xd387, buf, 5);
 	if (ret)
 		goto err;
 
@@ -391,7 +214,7 @@ static int af9013_statistics_snr_start(struct dvb_frontend *fe)
 	dev_dbg(&client->dev, "\n");
 
 	/* start SNR meas */
-	ret = af9013_wr_reg_bits(state, 0xd2e1, 3, 1, 1);
+	ret = regmap_update_bits(state->regmap, 0xd2e1, 0x08, 0x08);
 	if (ret)
 		goto err;
 
@@ -406,35 +229,36 @@ static int af9013_statistics_snr_result(struct dvb_frontend *fe)
 	struct af9013_state *state = fe->demodulator_priv;
 	struct i2c_client *client = state->client;
 	int ret, i, len;
-	u8 buf[3], tmp;
+	unsigned int utmp;
+	u8 buf[3];
 	u32 snr_val;
 	const struct af9013_snr *uninitialized_var(snr_lut);
 
 	dev_dbg(&client->dev, "\n");
 
 	/* check if SNR ready */
-	ret = af9013_rd_reg_bits(state, 0xd2e1, 3, 1, &tmp);
+	ret = regmap_read(state->regmap, 0xd2e1, &utmp);
 	if (ret)
 		goto err;
 
-	if (!tmp) {
+	if (!((utmp >> 3) & 0x01)) {
 		dev_dbg(&client->dev, "not ready\n");
 		return 0;
 	}
 
 	/* read value */
-	ret = af9013_rd_regs(state, 0xd2e3, buf, 3);
+	ret = regmap_bulk_read(state->regmap, 0xd2e3, buf, 3);
 	if (ret)
 		goto err;
 
 	snr_val = (buf[2] << 16) | (buf[1] << 8) | buf[0];
 
 	/* read current modulation */
-	ret = af9013_rd_reg(state, 0xd3c1, &tmp);
+	ret = regmap_read(state->regmap, 0xd3c1, &utmp);
 	if (ret)
 		goto err;
 
-	switch ((tmp >> 6) & 3) {
+	switch ((utmp >> 6) & 3) {
 	case 0:
 		len = ARRAY_SIZE(qpsk_snr_lut);
 		snr_lut = qpsk_snr_lut;
@@ -452,12 +276,12 @@ static int af9013_statistics_snr_result(struct dvb_frontend *fe)
 	}
 
 	for (i = 0; i < len; i++) {
-		tmp = snr_lut[i].snr;
+		utmp = snr_lut[i].snr;
 
 		if (snr_val < snr_lut[i].val)
 			break;
 	}
-	state->snr = tmp * 10; /* dB/10 */
+	state->snr = utmp * 10; /* dB/10 */
 
 	return ret;
 err:
@@ -478,7 +302,7 @@ static int af9013_statistics_signal_strength(struct dvb_frontend *fe)
 	if (!state->signal_strength_en)
 		return 0;
 
-	ret = af9013_rd_regs(state, 0xd07c, buf, 2);
+	ret = regmap_bulk_read(state->regmap, 0xd07c, buf, 2);
 	if (ret)
 		goto err;
 
@@ -591,8 +415,8 @@ static int af9013_set_frontend(struct dvb_frontend *fe)
 		if (i == ARRAY_SIZE(coeff_lut))
 			return -EINVAL;
 
-		ret = af9013_wr_regs(state, 0xae00, coeff_lut[i].val,
-			sizeof(coeff_lut[i].val));
+		ret = regmap_bulk_write(state->regmap, 0xae00, coeff_lut[i].val,
+					sizeof(coeff_lut[i].val));
 		if (ret)
 			goto err;
 	}
@@ -635,32 +459,32 @@ static int af9013_set_frontend(struct dvb_frontend *fe)
 		buf[4] = (freq_cw >>  8) & 0xff;
 		buf[5] = (freq_cw >> 16) & 0x7f;
 
-		ret = af9013_wr_regs(state, 0xd140, buf, 3);
+		ret = regmap_bulk_write(state->regmap, 0xd140, buf, 3);
 		if (ret)
 			goto err;
 
-		ret = af9013_wr_regs(state, 0x9be7, buf, 6);
+		ret = regmap_bulk_write(state->regmap, 0x9be7, buf, 6);
 		if (ret)
 			goto err;
 	}
 
 	/* clear TPS lock flag */
-	ret = af9013_wr_reg_bits(state, 0xd330, 3, 1, 1);
+	ret = regmap_update_bits(state->regmap, 0xd330, 0x08, 0x08);
 	if (ret)
 		goto err;
 
 	/* clear MPEG2 lock flag */
-	ret = af9013_wr_reg_bits(state, 0xd507, 6, 1, 0);
+	ret = regmap_update_bits(state->regmap, 0xd507, 0x40, 0x00);
 	if (ret)
 		goto err;
 
 	/* empty channel function */
-	ret = af9013_wr_reg_bits(state, 0x9bfe, 0, 1, 0);
+	ret = regmap_update_bits(state->regmap, 0x9bfe, 0x01, 0x00);
 	if (ret)
 		goto err;
 
 	/* empty DVB-T channel function */
-	ret = af9013_wr_reg_bits(state, 0x9bc2, 0, 1, 0);
+	ret = regmap_update_bits(state->regmap, 0x9bc2, 0x01, 0x00);
 	if (ret)
 		goto err;
 
@@ -805,32 +629,32 @@ static int af9013_set_frontend(struct dvb_frontend *fe)
 		goto err;
 	}
 
-	ret = af9013_wr_regs(state, 0xd3c0, buf, 3);
+	ret = regmap_bulk_write(state->regmap, 0xd3c0, buf, 3);
 	if (ret)
 		goto err;
 
 	if (auto_mode) {
 		/* clear easy mode flag */
-		ret = af9013_wr_reg(state, 0xaefd, 0);
+		ret = regmap_write(state->regmap, 0xaefd, 0x00);
 		if (ret)
 			goto err;
 
 		dev_dbg(&client->dev, "auto params\n");
 	} else {
 		/* set easy mode flag */
-		ret = af9013_wr_reg(state, 0xaefd, 1);
+		ret = regmap_write(state->regmap, 0xaefd, 0x01);
 		if (ret)
 			goto err;
 
-		ret = af9013_wr_reg(state, 0xaefe, 0);
+		ret = regmap_write(state->regmap, 0xaefe, 0x00);
 		if (ret)
 			goto err;
 
 		dev_dbg(&client->dev, "manual params\n");
 	}
 
-	/* tune */
-	ret = af9013_wr_reg(state, 0xffff, 0);
+	/* Reset FSM */
+	ret = regmap_write(state->regmap, 0xffff, 0x00);
 	if (ret)
 		goto err;
 
@@ -854,7 +678,7 @@ static int af9013_get_frontend(struct dvb_frontend *fe,
 
 	dev_dbg(&client->dev, "\n");
 
-	ret = af9013_rd_regs(state, 0xd3c0, buf, 3);
+	ret = regmap_bulk_read(state->regmap, 0xd3c0, buf, 3);
 	if (ret)
 		goto err;
 
@@ -967,7 +791,7 @@ static int af9013_read_status(struct dvb_frontend *fe, enum fe_status *status)
 	struct af9013_state *state = fe->demodulator_priv;
 	struct i2c_client *client = state->client;
 	int ret;
-	u8 tmp;
+	unsigned int utmp;
 
 	/*
 	 * Return status from the cache if it is younger than 2000ms with the
@@ -985,21 +809,21 @@ static int af9013_read_status(struct dvb_frontend *fe, enum fe_status *status)
 	}
 
 	/* MPEG2 lock */
-	ret = af9013_rd_reg_bits(state, 0xd507, 6, 1, &tmp);
+	ret = regmap_read(state->regmap, 0xd507, &utmp);
 	if (ret)
 		goto err;
 
-	if (tmp)
+	if ((utmp >> 6) & 0x01)
 		*status |= FE_HAS_SIGNAL | FE_HAS_CARRIER | FE_HAS_VITERBI |
 			FE_HAS_SYNC | FE_HAS_LOCK;
 
 	if (!*status) {
 		/* TPS lock */
-		ret = af9013_rd_reg_bits(state, 0xd330, 3, 1, &tmp);
+		ret = regmap_read(state->regmap, 0xd330, &utmp);
 		if (ret)
 			goto err;
 
-		if (tmp)
+		if ((utmp >> 3) & 0x01)
 			*status |= FE_HAS_SIGNAL | FE_HAS_CARRIER |
 				FE_HAS_VITERBI;
 	}
@@ -1046,8 +870,8 @@ static int af9013_init(struct dvb_frontend *fe)
 	struct af9013_state *state = fe->demodulator_priv;
 	struct i2c_client *client = state->client;
 	int ret, i, len;
-	u8 buf[3], tmp;
-	u32 adc_cw;
+	unsigned int utmp;
+	u8 buf[3];
 	const struct af9013_reg_bit *init;
 
 	dev_dbg(&client->dev, "\n");
@@ -1058,85 +882,85 @@ static int af9013_init(struct dvb_frontend *fe)
 		goto err;
 
 	/* enable ADC */
-	ret = af9013_wr_reg(state, 0xd73a, 0xa4);
+	ret = regmap_write(state->regmap, 0xd73a, 0xa4);
 	if (ret)
 		goto err;
 
 	/* write API version to firmware */
-	ret = af9013_wr_regs(state, 0x9bf2, state->api_version, 4);
+	ret = regmap_bulk_write(state->regmap, 0x9bf2, state->api_version, 4);
 	if (ret)
 		goto err;
 
 	/* program ADC control */
 	switch (state->clk) {
 	case 28800000: /* 28.800 MHz */
-		tmp = 0;
+		utmp = 0;
 		break;
 	case 20480000: /* 20.480 MHz */
-		tmp = 1;
+		utmp = 1;
 		break;
 	case 28000000: /* 28.000 MHz */
-		tmp = 2;
+		utmp = 2;
 		break;
 	case 25000000: /* 25.000 MHz */
-		tmp = 3;
+		utmp = 3;
 		break;
 	default:
 		ret = -EINVAL;
 		goto err;
 	}
 
-	adc_cw = div_u64((u64)state->clk * 0x80000, 1000000);
-	buf[0] = (adc_cw >>  0) & 0xff;
-	buf[1] = (adc_cw >>  8) & 0xff;
-	buf[2] = (adc_cw >> 16) & 0xff;
-	ret = af9013_wr_regs(state, 0xd180, buf, 3);
+	ret = regmap_update_bits(state->regmap, 0x9bd2, 0x0f, utmp);
 	if (ret)
 		goto err;
 
-	ret = af9013_wr_reg_bits(state, 0x9bd2, 0, 4, tmp);
+	utmp = div_u64((u64)state->clk * 0x80000, 1000000);
+	buf[0] = (utmp >>  0) & 0xff;
+	buf[1] = (utmp >>  8) & 0xff;
+	buf[2] = (utmp >> 16) & 0xff;
+	ret = regmap_bulk_write(state->regmap, 0xd180, buf, 3);
 	if (ret)
 		goto err;
 
 	/* set I2C master clock */
-	ret = af9013_wr_reg(state, 0xd416, 0x14);
+	ret = regmap_write(state->regmap, 0xd416, 0x14);
 	if (ret)
 		goto err;
 
 	/* set 16 embx */
-	ret = af9013_wr_reg_bits(state, 0xd700, 1, 1, 1);
+	ret = regmap_update_bits(state->regmap, 0xd700, 0x02, 0x02);
 	if (ret)
 		goto err;
 
 	/* set no trigger */
-	ret = af9013_wr_reg_bits(state, 0xd700, 2, 1, 0);
+	ret = regmap_update_bits(state->regmap, 0xd700, 0x04, 0x00);
 	if (ret)
 		goto err;
 
 	/* set read-update bit for constellation */
-	ret = af9013_wr_reg_bits(state, 0xd371, 1, 1, 1);
+	ret = regmap_update_bits(state->regmap, 0xd371, 0x02, 0x02);
 	if (ret)
 		goto err;
 
 	/* settings for mp2if */
 	if (state->ts_mode == AF9013_TS_USB) {
 		/* AF9015 split PSB to 1.5k + 0.5k */
-		ret = af9013_wr_reg_bits(state, 0xd50b, 2, 1, 1);
+		ret = regmap_update_bits(state->regmap, 0xd50b, 0x04, 0x04);
 		if (ret)
 			goto err;
 	} else {
 		/* AF9013 change the output bit to data7 */
-		ret = af9013_wr_reg_bits(state, 0xd500, 3, 1, 1);
+		ret = regmap_update_bits(state->regmap, 0xd500, 0x08, 0x08);
 		if (ret)
 			goto err;
 
 		/* AF9013 set mpeg to full speed */
-		ret = af9013_wr_reg_bits(state, 0xd502, 4, 1, 1);
+		ret = regmap_update_bits(state->regmap, 0xd502, 0x10, 0x10);
 		if (ret)
 			goto err;
 	}
 
-	ret = af9013_wr_reg_bits(state, 0xd520, 4, 1, 1);
+	ret = regmap_update_bits(state->regmap, 0xd520, 0x10, 0x10);
 	if (ret)
 		goto err;
 
@@ -1145,8 +969,11 @@ static int af9013_init(struct dvb_frontend *fe)
 	len = ARRAY_SIZE(ofsm_init);
 	init = ofsm_init;
 	for (i = 0; i < len; i++) {
-		ret = af9013_wr_reg_bits(state, init[i].addr, init[i].pos,
-			init[i].len, init[i].val);
+		u16 reg = init[i].addr;
+		u8 mask = GENMASK(init[i].pos + init[i].len - 1, init[i].pos);
+		u8 val = init[i].val << init[i].pos;
+
+		ret = regmap_update_bits(state->regmap, reg, mask, val);
 		if (ret)
 			goto err;
 	}
@@ -1198,63 +1025,65 @@ static int af9013_init(struct dvb_frontend *fe)
 	}
 
 	for (i = 0; i < len; i++) {
-		ret = af9013_wr_reg_bits(state, init[i].addr, init[i].pos,
-			init[i].len, init[i].val);
+		u16 reg = init[i].addr;
+		u8 mask = GENMASK(init[i].pos + init[i].len - 1, init[i].pos);
+		u8 val = init[i].val << init[i].pos;
+
+		ret = regmap_update_bits(state->regmap, reg, mask, val);
 		if (ret)
 			goto err;
 	}
 
 	/* TS mode */
-	ret = af9013_wr_reg_bits(state, 0xd500, 1, 2, state->ts_mode);
+	ret = regmap_update_bits(state->regmap, 0xd500, 0x06,
+				 state->ts_mode << 1);
 	if (ret)
 		goto err;
 
 	/* enable lock led */
-	ret = af9013_wr_reg_bits(state, 0xd730, 0, 1, 1);
+	ret = regmap_update_bits(state->regmap, 0xd730, 0x01, 0x01);
 	if (ret)
 		goto err;
 
 	/* check if we support signal strength */
 	if (!state->signal_strength_en) {
-		ret = af9013_rd_reg_bits(state, 0x9bee, 0, 1,
-			&state->signal_strength_en);
+		ret = regmap_read(state->regmap, 0x9bee, &utmp);
 		if (ret)
 			goto err;
+
+		state->signal_strength_en = (utmp >> 0) & 0x01;
 	}
 
 	/* read values needed for signal strength calculation */
 	if (state->signal_strength_en && !state->rf_50) {
-		ret = af9013_rd_reg(state, 0x9bbd, &state->rf_50);
+		ret = regmap_bulk_read(state->regmap, 0x9bbd, &state->rf_50, 1);
 		if (ret)
 			goto err;
-
-		ret = af9013_rd_reg(state, 0x9bd0, &state->rf_80);
+		ret = regmap_bulk_read(state->regmap, 0x9bd0, &state->rf_80, 1);
 		if (ret)
 			goto err;
-
-		ret = af9013_rd_reg(state, 0x9be2, &state->if_50);
+		ret = regmap_bulk_read(state->regmap, 0x9be2, &state->if_50, 1);
 		if (ret)
 			goto err;
-
-		ret = af9013_rd_reg(state, 0x9be4, &state->if_80);
+		ret = regmap_bulk_read(state->regmap, 0x9be4, &state->if_80, 1);
 		if (ret)
 			goto err;
 	}
 
 	/* SNR */
-	ret = af9013_wr_reg(state, 0xd2e2, 1);
+	ret = regmap_write(state->regmap, 0xd2e2, 0x01);
 	if (ret)
 		goto err;
 
 	/* BER / UCB */
 	buf[0] = (10000 >> 0) & 0xff;
 	buf[1] = (10000 >> 8) & 0xff;
-	ret = af9013_wr_regs(state, 0xd385, buf, 2);
+	ret = regmap_bulk_write(state->regmap, 0xd385, buf, 2);
 	if (ret)
 		goto err;
 
 	/* enable FEC monitor */
-	ret = af9013_wr_reg_bits(state, 0xd392, 1, 1, 1);
+	ret = regmap_update_bits(state->regmap, 0xd392, 0x02, 0x02);
 	if (ret)
 		goto err;
 
@@ -1279,7 +1108,7 @@ static int af9013_sleep(struct dvb_frontend *fe)
 	cancel_delayed_work_sync(&state->statistics_work);
 
 	/* disable lock led */
-	ret = af9013_wr_reg_bits(state, 0xd730, 0, 1, 0);
+	ret = regmap_update_bits(state->regmap, 0xd730, 0x01, 0x00);
 	if (ret)
 		goto err;
 
@@ -1307,9 +1136,11 @@ static int af9013_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)
 		return 0;
 
 	if (state->ts_mode == AF9013_TS_USB)
-		ret = af9013_wr_reg_bits(state, 0xd417, 3, 1, enable);
+		ret = regmap_update_bits(state->regmap, 0xd417, 0x08,
+					 enable << 3);
 	else
-		ret = af9013_wr_reg_bits(state, 0xd607, 2, 1, enable);
+		ret = regmap_update_bits(state->regmap, 0xd607, 0x04,
+					 enable << 2);
 	if (ret)
 		goto err;
 
@@ -1337,21 +1168,21 @@ static int af9013_download_firmware(struct af9013_state *state)
 {
 	struct i2c_client *client = state->client;
 	int i, len, remaining, ret;
+	unsigned int utmp;
 	const struct firmware *fw;
 	u16 checksum = 0;
-	u8 val;
 	u8 fw_params[4];
 	u8 *fw_file = AF9013_FIRMWARE;
 
 	msleep(100);
 	/* check whether firmware is already running */
-	ret = af9013_rd_reg(state, 0x98be, &val);
+	ret = regmap_read(state->regmap, 0x98be, &utmp);
 	if (ret)
 		goto err;
 	else
-		dev_dbg(&client->dev, "firmware status %02x\n", val);
+		dev_dbg(&client->dev, "firmware status %02x\n", utmp);
 
-	if (val == 0x0c) /* fw is running, no need for download */
+	if (utmp == 0x0c) /* fw is running, no need for download */
 		goto exit;
 
 	dev_info(&client->dev, "found a '%s' in cold state, will try to load a firmware\n",
@@ -1378,8 +1209,9 @@ static int af9013_download_firmware(struct af9013_state *state)
 	fw_params[3] = fw->size & 0xff;
 
 	/* write fw checksum & size */
-	ret = af9013_write_ofsm_regs(state, 0x50fc,
-		fw_params, sizeof(fw_params));
+	ret = regmap_bulk_write(state->regmap, 0x50fc, fw_params,
+				sizeof(fw_params));
+
 	if (ret)
 		goto err_release;
 
@@ -1390,9 +1222,9 @@ static int af9013_download_firmware(struct af9013_state *state)
 		if (len > LEN_MAX)
 			len = LEN_MAX;
 
-		ret = af9013_write_ofsm_regs(state,
-			FW_ADDR + fw->size - remaining,
-			(u8 *) &fw->data[fw->size - remaining], len);
+		ret = regmap_bulk_write(state->regmap,
+					FW_ADDR + fw->size - remaining,
+					&fw->data[fw->size - remaining], len);
 		if (ret) {
 			dev_err(&client->dev, "firmware download failed %d\n",
 				ret);
@@ -1401,28 +1233,23 @@ static int af9013_download_firmware(struct af9013_state *state)
 	}
 
 	/* request boot firmware */
-	ret = af9013_wr_reg(state, 0xe205, 1);
+	ret = regmap_write(state->regmap, 0xe205, 0x01);
 	if (ret)
 		goto err_release;
 
-	for (i = 0; i < 15; i++) {
-		msleep(100);
-
-		/* check firmware status */
-		ret = af9013_rd_reg(state, 0x98be, &val);
-		if (ret)
-			goto err_release;
-
-		dev_dbg(&client->dev, "firmware status %02x\n", val);
+	/* Check firmware status. 0c=OK, 04=fail */
+	ret = regmap_read_poll_timeout(state->regmap, 0x98be, utmp,
+				       (utmp == 0x0c || utmp == 0x04),
+				       5000, 1000000);
+	if (ret)
+		goto err_release;
 
-		if (val == 0x0c || val == 0x04) /* success or fail */
-			break;
-	}
+	dev_dbg(&client->dev, "firmware status %02x\n", utmp);
 
-	if (val == 0x04) {
+	if (utmp == 0x04) {
 		dev_err(&client->dev, "firmware did not run\n");
 		ret = -ENODEV;
-	} else if (val != 0x0c) {
+	} else if (utmp != 0x0c) {
 		dev_err(&client->dev, "firmware boot timeout\n");
 		ret = -ENODEV;
 	}
@@ -1522,6 +1349,147 @@ static struct dvb_frontend *af9013_get_dvb_frontend(struct i2c_client *client)
 	return &state->fe;
 }
 
+/* Own I2C access routines needed for regmap as chip uses extra command byte */
+static int af9013_wregs(struct i2c_client *client, u8 cmd, u16 reg,
+			const u8 *val, int len)
+{
+	int ret;
+	u8 buf[21];
+	struct i2c_msg msg[1] = {
+		{
+			.addr = client->addr,
+			.flags = 0,
+			.len = 3 + len,
+			.buf = buf,
+		}
+	};
+
+	if (3 + len > sizeof(buf)) {
+		ret = -EINVAL;
+		goto err;
+	}
+
+	buf[0] = (reg >> 8) & 0xff;
+	buf[1] = (reg >> 0) & 0xff;
+	buf[2] = cmd;
+	memcpy(&buf[3], val, len);
+	ret = i2c_transfer(client->adapter, msg, 1);
+	if (ret < 0) {
+		goto err;
+	} else if (ret != 1) {
+		ret = -EREMOTEIO;
+		goto err;
+	}
+
+	return 0;
+err:
+	dev_dbg(&client->dev, "failed %d\n", ret);
+	return ret;
+}
+
+static int af9013_rregs(struct i2c_client *client, u8 cmd, u16 reg,
+			u8 *val, int len)
+{
+	int ret;
+	u8 buf[3];
+	struct i2c_msg msg[2] = {
+		{
+			.addr = client->addr,
+			.flags = 0,
+			.len = 3,
+			.buf = buf,
+		}, {
+			.addr = client->addr,
+			.flags = I2C_M_RD,
+			.len = len,
+			.buf = val,
+		}
+	};
+
+	buf[0] = (reg >> 8) & 0xff;
+	buf[1] = (reg >> 0) & 0xff;
+	buf[2] = cmd;
+	ret = i2c_transfer(client->adapter, msg, 2);
+	if (ret < 0) {
+		goto err;
+	} else if (ret != 2) {
+		ret = -EREMOTEIO;
+		goto err;
+	}
+
+	return 0;
+err:
+	dev_dbg(&client->dev, "failed %d\n", ret);
+	return ret;
+}
+
+static int af9013_regmap_write(void *context, const void *data, size_t count)
+{
+	struct i2c_client *client = context;
+	struct af9013_state *state = i2c_get_clientdata(client);
+	int ret, i;
+	u8 cmd;
+	u16 reg = ((u8 *)data)[0] << 8|((u8 *)data)[1] << 0;
+	u8 *val = &((u8 *)data)[2];
+	const unsigned int len = count - 2;
+
+	if (state->ts_mode == AF9013_TS_USB && (reg & 0xff00) != 0xae00) {
+		cmd = 0 << 7|0 << 6|(len - 1) << 2|1 << 1|1 << 0;
+		ret = af9013_wregs(client, cmd, reg, val, len);
+		if (ret)
+			goto err;
+	} else if (reg >= 0x5100 && reg < 0x8fff) {
+		/* Firmware download */
+		cmd = 1 << 7|1 << 6|(len - 1) << 2|1 << 1|1 << 0;
+		ret = af9013_wregs(client, cmd, reg, val, len);
+		if (ret)
+			goto err;
+	} else {
+		cmd = 0 << 7|0 << 6|(1 - 1) << 2|1 << 1|1 << 0;
+		for (i = 0; i < len; i++) {
+			ret = af9013_wregs(client, cmd, reg + i, val + i, 1);
+			if (ret)
+				goto err;
+		}
+	}
+
+	return 0;
+err:
+	dev_dbg(&client->dev, "failed %d\n", ret);
+	return ret;
+}
+
+static int af9013_regmap_read(void *context, const void *reg_buf,
+			      size_t reg_size, void *val_buf, size_t val_size)
+{
+	struct i2c_client *client = context;
+	struct af9013_state *state = i2c_get_clientdata(client);
+	int ret, i;
+	u8 cmd;
+	u16 reg = ((u8 *)reg_buf)[0] << 8|((u8 *)reg_buf)[1] << 0;
+	u8 *val = &((u8 *)val_buf)[0];
+	const unsigned int len = val_size;
+
+	if (state->ts_mode == AF9013_TS_USB && (reg & 0xff00) != 0xae00) {
+		cmd = 0 << 7|0 << 6|(len - 1) << 2|1 << 1|0 << 0;
+		ret = af9013_rregs(client, cmd, reg, val_buf, len);
+		if (ret)
+			goto err;
+	} else {
+		cmd = 0 << 7|0 << 6|(1 - 1) << 2|1 << 1|0 << 0;
+		for (i = 0; i < len; i++) {
+			ret = af9013_rregs(client, cmd, reg + i, val + i, 1);
+			if (ret)
+				goto err;
+		}
+	}
+
+	return 0;
+err:
+	dev_dbg(&client->dev, "failed %d\n", ret);
+	return ret;
+}
+
 static int af9013_probe(struct i2c_client *client,
 			const struct i2c_device_id *id)
 {
@@ -1529,6 +1497,14 @@ static int af9013_probe(struct i2c_client *client,
 	struct af9013_platform_data *pdata = client->dev.platform_data;
 	int ret, i;
 	u8 firmware_version[4];
+	static const struct regmap_bus regmap_bus = {
+		.read = af9013_regmap_read,
+		.write = af9013_regmap_write,
+	};
+	static const struct regmap_config regmap_config = {
+		.reg_bits    =  16,
+		.val_bits    =  8,
+	};
 
 	state = kzalloc(sizeof(*state), GFP_KERNEL);
 	if (!state) {
@@ -1547,25 +1523,31 @@ static int af9013_probe(struct i2c_client *client,
 	memcpy(&state->api_version, pdata->api_version, sizeof(state->api_version));
 	memcpy(&state->gpio, pdata->gpio, sizeof(state->gpio));
 	INIT_DELAYED_WORK(&state->statistics_work, af9013_statistics_work);
+	state->regmap = regmap_init(&client->dev, &regmap_bus, client,
+				  &regmap_config);
+	if (IS_ERR(state->regmap)) {
+		ret = PTR_ERR(state->regmap);
+		goto err_kfree;
+	}
 
 	/* Download firmware */
 	if (state->ts_mode != AF9013_TS_USB) {
 		ret = af9013_download_firmware(state);
 		if (ret)
-			goto err_kfree;
+			goto err_regmap_exit;
 	}
 
 	/* Firmware version */
-	ret = af9013_rd_regs(state, 0x5103, firmware_version,
-			     sizeof(firmware_version));
+	ret = regmap_bulk_read(state->regmap, 0x5103, firmware_version,
+			       sizeof(firmware_version));
 	if (ret)
-		goto err_kfree;
+		goto err_regmap_exit;
 
 	/* Set GPIOs */
 	for (i = 0; i < sizeof(state->gpio); i++) {
 		ret = af9013_set_gpio(state, i, state->gpio[i]);
 		if (ret)
-			goto err_kfree;
+			goto err_regmap_exit;
 	}
 
 	/* Create dvb frontend */
@@ -1582,6 +1564,8 @@ static int af9013_probe(struct i2c_client *client,
 		 firmware_version[0], firmware_version[1],
 		 firmware_version[2], firmware_version[3]);
 	return 0;
+err_regmap_exit:
+	regmap_exit(state->regmap);
 err_kfree:
 	kfree(state);
 err:
@@ -1598,6 +1582,8 @@ static int af9013_remove(struct i2c_client *client)
 	/* Stop statistics polling */
 	cancel_delayed_work_sync(&state->statistics_work);
 
+	regmap_exit(state->regmap);
+
 	kfree(state);
 
 	return 0;

commit cbb2a2999c0f43920ef83f6e895819474823f6ea
Author: Antti Palosaari <crope@iki.fi>
Date:   Sat Jun 10 22:04:30 2017 -0300

    [media] af9013: fix logging
    
    We can simplify logging as we now have a proper i2c client
    to pass for kernel dev_* logging functions.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/af9013.c b/drivers/media/dvb-frontends/af9013.c
index a6c53bb298ce..9a4e662cb311 100644
--- a/drivers/media/dvb-frontends/af9013.c
+++ b/drivers/media/dvb-frontends/af9013.c
@@ -51,14 +51,15 @@ struct af9013_state {
 };
 
 /* write multiple registers */
-static int af9013_wr_regs_i2c(struct af9013_state *priv, u8 mbox, u16 reg,
+static int af9013_wr_regs_i2c(struct af9013_state *state, u8 mbox, u16 reg,
 	const u8 *val, int len)
 {
+	struct i2c_client *client = state->client;
 	int ret;
 	u8 buf[MAX_XFER_SIZE];
 	struct i2c_msg msg[1] = {
 		{
-			.addr = priv->client->addr,
+			.addr = state->client->addr,
 			.flags = 0,
 			.len = 3 + len,
 			.buf = buf,
@@ -66,9 +67,8 @@ static int af9013_wr_regs_i2c(struct af9013_state *priv, u8 mbox, u16 reg,
 	};
 
 	if (3 + len > sizeof(buf)) {
-		dev_warn(&priv->client->dev,
-			 "%s: i2c wr reg=%04x: len=%d is too big!\n",
-			 KBUILD_MODNAME, reg, len);
+		dev_warn(&client->dev, "i2c wr reg %04x, len %d, is too big!\n",
+			 reg, len);
 		return -EINVAL;
 	}
 
@@ -77,31 +77,32 @@ static int af9013_wr_regs_i2c(struct af9013_state *priv, u8 mbox, u16 reg,
 	buf[2] = mbox;
 	memcpy(&buf[3], val, len);
 
-	ret = i2c_transfer(priv->client->adapter, msg, 1);
+	ret = i2c_transfer(state->client->adapter, msg, 1);
 	if (ret == 1) {
 		ret = 0;
 	} else {
-		dev_warn(&priv->client->dev, "%s: i2c wr failed=%d reg=%04x " \
-				"len=%d\n", KBUILD_MODNAME, ret, reg, len);
+		dev_warn(&client->dev, "i2c wr failed %d, reg %04x, len %d\n",
+			 ret, reg, len);
 		ret = -EREMOTEIO;
 	}
 	return ret;
 }
 
 /* read multiple registers */
-static int af9013_rd_regs_i2c(struct af9013_state *priv, u8 mbox, u16 reg,
+static int af9013_rd_regs_i2c(struct af9013_state *state, u8 mbox, u16 reg,
 	u8 *val, int len)
 {
+	struct i2c_client *client = state->client;
 	int ret;
 	u8 buf[3];
 	struct i2c_msg msg[2] = {
 		{
-			.addr = priv->client->addr,
+			.addr = state->client->addr,
 			.flags = 0,
 			.len = 3,
 			.buf = buf,
 		}, {
-			.addr = priv->client->addr,
+			.addr = state->client->addr,
 			.flags = I2C_M_RD,
 			.len = len,
 			.buf = val,
@@ -112,31 +113,31 @@ static int af9013_rd_regs_i2c(struct af9013_state *priv, u8 mbox, u16 reg,
 	buf[1] = (reg >> 0) & 0xff;
 	buf[2] = mbox;
 
-	ret = i2c_transfer(priv->client->adapter, msg, 2);
+	ret = i2c_transfer(state->client->adapter, msg, 2);
 	if (ret == 2) {
 		ret = 0;
 	} else {
-		dev_warn(&priv->client->dev, "%s: i2c rd failed=%d reg=%04x " \
-				"len=%d\n", KBUILD_MODNAME, ret, reg, len);
+		dev_warn(&client->dev, "i2c rd failed %d, reg %04x, len %d\n",
+			 ret, reg, len);
 		ret = -EREMOTEIO;
 	}
 	return ret;
 }
 
 /* write multiple registers */
-static int af9013_wr_regs(struct af9013_state *priv, u16 reg, const u8 *val,
+static int af9013_wr_regs(struct af9013_state *state, u16 reg, const u8 *val,
 	int len)
 {
 	int ret, i;
 	u8 mbox = (0 << 7)|(0 << 6)|(1 << 1)|(1 << 0);
 
-	if ((priv->ts_mode == AF9013_TS_USB) &&
+	if ((state->ts_mode == AF9013_TS_USB) &&
 		((reg & 0xff00) != 0xff00) && ((reg & 0xff00) != 0xae00)) {
 		mbox |= ((len - 1) << 2);
-		ret = af9013_wr_regs_i2c(priv, mbox, reg, val, len);
+		ret = af9013_wr_regs_i2c(state, mbox, reg, val, len);
 	} else {
 		for (i = 0; i < len; i++) {
-			ret = af9013_wr_regs_i2c(priv, mbox, reg+i, val+i, 1);
+			ret = af9013_wr_regs_i2c(state, mbox, reg+i, val+i, 1);
 			if (ret)
 				goto err;
 		}
@@ -147,18 +148,18 @@ static int af9013_wr_regs(struct af9013_state *priv, u16 reg, const u8 *val,
 }
 
 /* read multiple registers */
-static int af9013_rd_regs(struct af9013_state *priv, u16 reg, u8 *val, int len)
+static int af9013_rd_regs(struct af9013_state *state, u16 reg, u8 *val, int len)
 {
 	int ret, i;
 	u8 mbox = (0 << 7)|(0 << 6)|(1 << 1)|(0 << 0);
 
-	if ((priv->ts_mode == AF9013_TS_USB) &&
+	if ((state->ts_mode == AF9013_TS_USB) &&
 		((reg & 0xff00) != 0xff00) && ((reg & 0xff00) != 0xae00)) {
 		mbox |= ((len - 1) << 2);
-		ret = af9013_rd_regs_i2c(priv, mbox, reg, val, len);
+		ret = af9013_rd_regs_i2c(state, mbox, reg, val, len);
 	} else {
 		for (i = 0; i < len; i++) {
-			ret = af9013_rd_regs_i2c(priv, mbox, reg+i, val+i, 1);
+			ret = af9013_rd_regs_i2c(state, mbox, reg+i, val+i, 1);
 			if (ret)
 				goto err;
 		}
@@ -169,15 +170,15 @@ static int af9013_rd_regs(struct af9013_state *priv, u16 reg, u8 *val, int len)
 }
 
 /* write single register */
-static int af9013_wr_reg(struct af9013_state *priv, u16 reg, u8 val)
+static int af9013_wr_reg(struct af9013_state *state, u16 reg, u8 val)
 {
-	return af9013_wr_regs(priv, reg, &val, 1);
+	return af9013_wr_regs(state, reg, &val, 1);
 }
 
 /* read single register */
-static int af9013_rd_reg(struct af9013_state *priv, u16 reg, u8 *val)
+static int af9013_rd_reg(struct af9013_state *state, u16 reg, u8 *val)
 {
-	return af9013_rd_regs(priv, reg, val, 1);
+	return af9013_rd_regs(state, reg, val, 1);
 }
 
 static int af9013_write_ofsm_regs(struct af9013_state *state, u16 reg, u8 *val,
@@ -226,12 +227,12 @@ static int af9013_rd_reg_bits(struct af9013_state *state, u16 reg, int pos,
 
 static int af9013_set_gpio(struct af9013_state *state, u8 gpio, u8 gpioval)
 {
+	struct i2c_client *client = state->client;
 	int ret;
 	u8 pos;
 	u16 addr;
 
-	dev_dbg(&state->client->dev, "%s: gpio=%d gpioval=%02x\n",
-			__func__, gpio, gpioval);
+	dev_dbg(&client->dev, "gpio %u, gpioval %02x\n", gpio, gpioval);
 
 	/*
 	 * GPIO0 & GPIO1 0xd735
@@ -249,8 +250,6 @@ static int af9013_set_gpio(struct af9013_state *state, u8 gpio, u8 gpioval)
 		break;
 
 	default:
-		dev_err(&state->client->dev, "%s: invalid gpio=%d\n",
-				KBUILD_MODNAME, gpio);
 		ret = -EINVAL;
 		goto err;
 	}
@@ -273,16 +272,17 @@ static int af9013_set_gpio(struct af9013_state *state, u8 gpio, u8 gpioval)
 
 	return ret;
 err:
-	dev_dbg(&state->client->dev, "%s: failed=%d\n", __func__, ret);
+	dev_dbg(&client->dev, "failed %d\n", ret);
 	return ret;
 }
 
 static int af9013_power_ctrl(struct af9013_state *state, u8 onoff)
 {
+	struct i2c_client *client = state->client;
 	int ret, i;
 	u8 tmp;
 
-	dev_dbg(&state->client->dev, "%s: onoff=%d\n", __func__, onoff);
+	dev_dbg(&client->dev, "onoff %d\n", onoff);
 
 	/* enable reset */
 	ret = af9013_wr_reg_bits(state, 0xd417, 4, 1, 1);
@@ -327,16 +327,17 @@ static int af9013_power_ctrl(struct af9013_state *state, u8 onoff)
 
 	return ret;
 err:
-	dev_dbg(&state->client->dev, "%s: failed=%d\n", __func__, ret);
+	dev_dbg(&client->dev, "failed %d\n", ret);
 	return ret;
 }
 
 static int af9013_statistics_ber_unc_start(struct dvb_frontend *fe)
 {
 	struct af9013_state *state = fe->demodulator_priv;
+	struct i2c_client *client = state->client;
 	int ret;
 
-	dev_dbg(&state->client->dev, "%s:\n", __func__);
+	dev_dbg(&client->dev, "\n");
 
 	/* reset and start BER counter */
 	ret = af9013_wr_reg_bits(state, 0xd391, 4, 1, 1);
@@ -345,17 +346,18 @@ static int af9013_statistics_ber_unc_start(struct dvb_frontend *fe)
 
 	return ret;
 err:
-	dev_dbg(&state->client->dev, "%s: failed=%d\n", __func__, ret);
+	dev_dbg(&client->dev, "failed %d\n", ret);
 	return ret;
 }
 
 static int af9013_statistics_ber_unc_result(struct dvb_frontend *fe)
 {
 	struct af9013_state *state = fe->demodulator_priv;
+	struct i2c_client *client = state->client;
 	int ret;
 	u8 buf[5];
 
-	dev_dbg(&state->client->dev, "%s:\n", __func__);
+	dev_dbg(&client->dev, "\n");
 
 	/* check if error bit count is ready */
 	ret = af9013_rd_reg_bits(state, 0xd391, 4, 1, &buf[0]);
@@ -363,7 +365,7 @@ static int af9013_statistics_ber_unc_result(struct dvb_frontend *fe)
 		goto err;
 
 	if (!buf[0]) {
-		dev_dbg(&state->client->dev, "%s: not ready\n", __func__);
+		dev_dbg(&client->dev, "not ready\n");
 		return 0;
 	}
 
@@ -376,16 +378,17 @@ static int af9013_statistics_ber_unc_result(struct dvb_frontend *fe)
 
 	return ret;
 err:
-	dev_dbg(&state->client->dev, "%s: failed=%d\n", __func__, ret);
+	dev_dbg(&client->dev, "failed %d\n", ret);
 	return ret;
 }
 
 static int af9013_statistics_snr_start(struct dvb_frontend *fe)
 {
 	struct af9013_state *state = fe->demodulator_priv;
+	struct i2c_client *client = state->client;
 	int ret;
 
-	dev_dbg(&state->client->dev, "%s:\n", __func__);
+	dev_dbg(&client->dev, "\n");
 
 	/* start SNR meas */
 	ret = af9013_wr_reg_bits(state, 0xd2e1, 3, 1, 1);
@@ -394,19 +397,20 @@ static int af9013_statistics_snr_start(struct dvb_frontend *fe)
 
 	return ret;
 err:
-	dev_dbg(&state->client->dev, "%s: failed=%d\n", __func__, ret);
+	dev_dbg(&client->dev, "failed %d\n", ret);
 	return ret;
 }
 
 static int af9013_statistics_snr_result(struct dvb_frontend *fe)
 {
 	struct af9013_state *state = fe->demodulator_priv;
+	struct i2c_client *client = state->client;
 	int ret, i, len;
 	u8 buf[3], tmp;
 	u32 snr_val;
 	const struct af9013_snr *uninitialized_var(snr_lut);
 
-	dev_dbg(&state->client->dev, "%s:\n", __func__);
+	dev_dbg(&client->dev, "\n");
 
 	/* check if SNR ready */
 	ret = af9013_rd_reg_bits(state, 0xd2e1, 3, 1, &tmp);
@@ -414,7 +418,7 @@ static int af9013_statistics_snr_result(struct dvb_frontend *fe)
 		goto err;
 
 	if (!tmp) {
-		dev_dbg(&state->client->dev, "%s: not ready\n", __func__);
+		dev_dbg(&client->dev, "not ready\n");
 		return 0;
 	}
 
@@ -457,18 +461,19 @@ static int af9013_statistics_snr_result(struct dvb_frontend *fe)
 
 	return ret;
 err:
-	dev_dbg(&state->client->dev, "%s: failed=%d\n", __func__, ret);
+	dev_dbg(&client->dev, "failed %d\n", ret);
 	return ret;
 }
 
 static int af9013_statistics_signal_strength(struct dvb_frontend *fe)
 {
 	struct af9013_state *state = fe->demodulator_priv;
+	struct i2c_client *client = state->client;
 	int ret = 0;
 	u8 buf[2], rf_gain, if_gain;
 	int signal_strength;
 
-	dev_dbg(&state->client->dev, "%s:\n", __func__);
+	dev_dbg(&client->dev, "\n");
 
 	if (!state->signal_strength_en)
 		return 0;
@@ -494,7 +499,7 @@ static int af9013_statistics_signal_strength(struct dvb_frontend *fe)
 
 	return ret;
 err:
-	dev_dbg(&state->client->dev, "%s: failed=%d\n", __func__, ret);
+	dev_dbg(&client->dev, "failed %d\n", ret);
 	return ret;
 }
 
@@ -559,14 +564,15 @@ static int af9013_get_tune_settings(struct dvb_frontend *fe,
 static int af9013_set_frontend(struct dvb_frontend *fe)
 {
 	struct af9013_state *state = fe->demodulator_priv;
+	struct i2c_client *client = state->client;
 	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
 	int ret, i, sampling_freq;
 	bool auto_mode, spec_inv;
 	u8 buf[6];
 	u32 if_frequency, freq_cw;
 
-	dev_dbg(&state->client->dev, "%s: frequency=%d bandwidth_hz=%d\n",
-			__func__, c->frequency, c->bandwidth_hz);
+	dev_dbg(&client->dev, "frequency %u, bandwidth_hz %u\n",
+		c->frequency, c->bandwidth_hz);
 
 	/* program tuner */
 	if (fe->ops.tuner_ops.set_params)
@@ -599,8 +605,7 @@ static int af9013_set_frontend(struct dvb_frontend *fe)
 		else
 			if_frequency = state->if_frequency;
 
-		dev_dbg(&state->client->dev, "%s: if_frequency=%d\n",
-				__func__, if_frequency);
+		dev_dbg(&client->dev, "if_frequency %u\n", if_frequency);
 
 		sampling_freq = if_frequency;
 
@@ -673,8 +678,7 @@ static int af9013_set_frontend(struct dvb_frontend *fe)
 		buf[0] |= (1 << 0);
 		break;
 	default:
-		dev_dbg(&state->client->dev, "%s: invalid transmission_mode\n",
-				__func__);
+		dev_dbg(&client->dev, "invalid transmission_mode\n");
 		auto_mode = true;
 	}
 
@@ -694,8 +698,7 @@ static int af9013_set_frontend(struct dvb_frontend *fe)
 		buf[0] |= (3 << 2);
 		break;
 	default:
-		dev_dbg(&state->client->dev, "%s: invalid guard_interval\n",
-				__func__);
+		dev_dbg(&client->dev, "invalid guard_interval\n");
 		auto_mode = true;
 	}
 
@@ -715,7 +718,7 @@ static int af9013_set_frontend(struct dvb_frontend *fe)
 		buf[0] |= (3 << 4);
 		break;
 	default:
-		dev_dbg(&state->client->dev, "%s: invalid hierarchy\n", __func__);
+		dev_dbg(&client->dev, "invalid hierarchy\n");
 		auto_mode = true;
 	}
 
@@ -732,7 +735,7 @@ static int af9013_set_frontend(struct dvb_frontend *fe)
 		buf[1] |= (2 << 6);
 		break;
 	default:
-		dev_dbg(&state->client->dev, "%s: invalid modulation\n", __func__);
+		dev_dbg(&client->dev, "invalid modulation\n");
 		auto_mode = true;
 	}
 
@@ -758,8 +761,7 @@ static int af9013_set_frontend(struct dvb_frontend *fe)
 		buf[2] |= (4 << 0);
 		break;
 	default:
-		dev_dbg(&state->client->dev, "%s: invalid code_rate_HP\n",
-				__func__);
+		dev_dbg(&client->dev, "invalid code_rate_HP\n");
 		auto_mode = true;
 	}
 
@@ -784,8 +786,7 @@ static int af9013_set_frontend(struct dvb_frontend *fe)
 	case FEC_NONE:
 		break;
 	default:
-		dev_dbg(&state->client->dev, "%s: invalid code_rate_LP\n",
-				__func__);
+		dev_dbg(&client->dev, "invalid code_rate_LP\n");
 		auto_mode = true;
 	}
 
@@ -799,8 +800,7 @@ static int af9013_set_frontend(struct dvb_frontend *fe)
 		buf[1] |= (2 << 2);
 		break;
 	default:
-		dev_dbg(&state->client->dev, "%s: invalid bandwidth_hz\n",
-				__func__);
+		dev_dbg(&client->dev, "invalid bandwidth_hz\n");
 		ret = -EINVAL;
 		goto err;
 	}
@@ -815,7 +815,7 @@ static int af9013_set_frontend(struct dvb_frontend *fe)
 		if (ret)
 			goto err;
 
-		dev_dbg(&state->client->dev, "%s: auto params\n", __func__);
+		dev_dbg(&client->dev, "auto params\n");
 	} else {
 		/* set easy mode flag */
 		ret = af9013_wr_reg(state, 0xaefd, 1);
@@ -826,7 +826,7 @@ static int af9013_set_frontend(struct dvb_frontend *fe)
 		if (ret)
 			goto err;
 
-		dev_dbg(&state->client->dev, "%s: manual params\n", __func__);
+		dev_dbg(&client->dev, "manual params\n");
 	}
 
 	/* tune */
@@ -840,7 +840,7 @@ static int af9013_set_frontend(struct dvb_frontend *fe)
 
 	return ret;
 err:
-	dev_dbg(&state->client->dev, "%s: failed=%d\n", __func__, ret);
+	dev_dbg(&client->dev, "failed %d\n", ret);
 	return ret;
 }
 
@@ -848,10 +848,11 @@ static int af9013_get_frontend(struct dvb_frontend *fe,
 			       struct dtv_frontend_properties *c)
 {
 	struct af9013_state *state = fe->demodulator_priv;
+	struct i2c_client *client = state->client;
 	int ret;
 	u8 buf[3];
 
-	dev_dbg(&state->client->dev, "%s:\n", __func__);
+	dev_dbg(&client->dev, "\n");
 
 	ret = af9013_rd_regs(state, 0xd3c0, buf, 3);
 	if (ret)
@@ -957,13 +958,14 @@ static int af9013_get_frontend(struct dvb_frontend *fe,
 
 	return ret;
 err:
-	dev_dbg(&state->client->dev, "%s: failed=%d\n", __func__, ret);
+	dev_dbg(&client->dev, "failed %d\n", ret);
 	return ret;
 }
 
 static int af9013_read_status(struct dvb_frontend *fe, enum fe_status *status)
 {
 	struct af9013_state *state = fe->demodulator_priv;
+	struct i2c_client *client = state->client;
 	int ret;
 	u8 tmp;
 
@@ -1007,7 +1009,7 @@ static int af9013_read_status(struct dvb_frontend *fe, enum fe_status *status)
 
 	return ret;
 err:
-	dev_dbg(&state->client->dev, "%s: failed=%d\n", __func__, ret);
+	dev_dbg(&client->dev, "failed %d\n", ret);
 	return ret;
 }
 
@@ -1042,12 +1044,13 @@ static int af9013_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)
 static int af9013_init(struct dvb_frontend *fe)
 {
 	struct af9013_state *state = fe->demodulator_priv;
+	struct i2c_client *client = state->client;
 	int ret, i, len;
 	u8 buf[3], tmp;
 	u32 adc_cw;
 	const struct af9013_reg_bit *init;
 
-	dev_dbg(&state->client->dev, "%s:\n", __func__);
+	dev_dbg(&client->dev, "\n");
 
 	/* power on */
 	ret = af9013_power_ctrl(state, 1);
@@ -1079,9 +1082,8 @@ static int af9013_init(struct dvb_frontend *fe)
 		tmp = 3;
 		break;
 	default:
-		dev_err(&state->client->dev, "%s: invalid clock\n",
-				KBUILD_MODNAME);
-		return -EINVAL;
+		ret = -EINVAL;
+		goto err;
 	}
 
 	adc_cw = div_u64((u64)state->clk * 0x80000, 1000000);
@@ -1139,7 +1141,7 @@ static int af9013_init(struct dvb_frontend *fe)
 		goto err;
 
 	/* load OFSM settings */
-	dev_dbg(&state->client->dev, "%s: load ofsm settings\n", __func__);
+	dev_dbg(&client->dev, "load ofsm settings\n");
 	len = ARRAY_SIZE(ofsm_init);
 	init = ofsm_init;
 	for (i = 0; i < len; i++) {
@@ -1150,8 +1152,7 @@ static int af9013_init(struct dvb_frontend *fe)
 	}
 
 	/* load tuner specific settings */
-	dev_dbg(&state->client->dev, "%s: load tuner specific settings\n",
-			__func__);
+	dev_dbg(&client->dev, "load tuner specific settings\n");
 	switch (state->tuner) {
 	case AF9013_TUNER_MXL5003D:
 		len = ARRAY_SIZE(tuner_init_mxl5003d);
@@ -1262,16 +1263,17 @@ static int af9013_init(struct dvb_frontend *fe)
 
 	return ret;
 err:
-	dev_dbg(&state->client->dev, "%s: failed=%d\n", __func__, ret);
+	dev_dbg(&client->dev, "failed %d\n", ret);
 	return ret;
 }
 
 static int af9013_sleep(struct dvb_frontend *fe)
 {
 	struct af9013_state *state = fe->demodulator_priv;
+	struct i2c_client *client = state->client;
 	int ret;
 
-	dev_dbg(&state->client->dev, "%s:\n", __func__);
+	dev_dbg(&client->dev, "\n");
 
 	/* stop statistics polling */
 	cancel_delayed_work_sync(&state->statistics_work);
@@ -1288,7 +1290,7 @@ static int af9013_sleep(struct dvb_frontend *fe)
 
 	return ret;
 err:
-	dev_dbg(&state->client->dev, "%s: failed=%d\n", __func__, ret);
+	dev_dbg(&client->dev, "failed %d\n", ret);
 	return ret;
 }
 
@@ -1296,8 +1298,9 @@ static int af9013_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)
 {
 	int ret;
 	struct af9013_state *state = fe->demodulator_priv;
+	struct i2c_client *client = state->client;
 
-	dev_dbg(&state->client->dev, "%s: enable=%d\n", __func__, enable);
+	dev_dbg(&client->dev, "enable %d\n", enable);
 
 	/* gate already open or close */
 	if (state->i2c_gate_state == enable)
@@ -1314,7 +1317,7 @@ static int af9013_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)
 
 	return ret;
 err:
-	dev_dbg(&state->client->dev, "%s: failed=%d\n", __func__, ret);
+	dev_dbg(&client->dev, "failed %d\n", ret);
 	return ret;
 }
 
@@ -1323,6 +1326,8 @@ static void af9013_release(struct dvb_frontend *fe)
 	struct af9013_state *state = fe->demodulator_priv;
 	struct i2c_client *client = state->client;
 
+	dev_dbg(&client->dev, "\n");
+
 	i2c_unregister_device(client);
 }
 
@@ -1330,6 +1335,7 @@ static const struct dvb_frontend_ops af9013_ops;
 
 static int af9013_download_firmware(struct af9013_state *state)
 {
+	struct i2c_client *client = state->client;
 	int i, len, remaining, ret;
 	const struct firmware *fw;
 	u16 checksum = 0;
@@ -1343,28 +1349,24 @@ static int af9013_download_firmware(struct af9013_state *state)
 	if (ret)
 		goto err;
 	else
-		dev_dbg(&state->client->dev, "%s: firmware status=%02x\n",
-				__func__, val);
+		dev_dbg(&client->dev, "firmware status %02x\n", val);
 
 	if (val == 0x0c) /* fw is running, no need for download */
 		goto exit;
 
-	dev_info(&state->client->dev, "%s: found a '%s' in cold state, will try " \
-			"to load a firmware\n",
-			KBUILD_MODNAME, af9013_ops.info.name);
+	dev_info(&client->dev, "found a '%s' in cold state, will try to load a firmware\n",
+		 af9013_ops.info.name);
 
 	/* request the firmware, this will block and timeout */
-	ret = request_firmware(&fw, fw_file, &state->client->dev);
+	ret = request_firmware(&fw, fw_file, &client->dev);
 	if (ret) {
-		dev_info(&state->client->dev, "%s: did not find the firmware " \
-			"file. (%s) Please see linux/Documentation/dvb/ for " \
-			"more details on firmware-problems. (%d)\n",
-			KBUILD_MODNAME, fw_file, ret);
+		dev_info(&client->dev, "firmware file '%s' not found %d\n",
+			 fw_file, ret);
 		goto err;
 	}
 
-	dev_info(&state->client->dev, "%s: downloading firmware from file '%s'\n",
-			KBUILD_MODNAME, fw_file);
+	dev_info(&client->dev, "downloading firmware from file '%s'\n",
+		 fw_file);
 
 	/* calc checksum */
 	for (i = 0; i < fw->size; i++)
@@ -1392,9 +1394,8 @@ static int af9013_download_firmware(struct af9013_state *state)
 			FW_ADDR + fw->size - remaining,
 			(u8 *) &fw->data[fw->size - remaining], len);
 		if (ret) {
-			dev_err(&state->client->dev,
-					"%s: firmware download failed=%d\n",
-					KBUILD_MODNAME, ret);
+			dev_err(&client->dev, "firmware download failed %d\n",
+				ret);
 			goto err_release;
 		}
 	}
@@ -1412,20 +1413,17 @@ static int af9013_download_firmware(struct af9013_state *state)
 		if (ret)
 			goto err_release;
 
-		dev_dbg(&state->client->dev, "%s: firmware status=%02x\n",
-				__func__, val);
+		dev_dbg(&client->dev, "firmware status %02x\n", val);
 
 		if (val == 0x0c || val == 0x04) /* success or fail */
 			break;
 	}
 
 	if (val == 0x04) {
-		dev_err(&state->client->dev, "%s: firmware did not run\n",
-				KBUILD_MODNAME);
+		dev_err(&client->dev, "firmware did not run\n");
 		ret = -ENODEV;
 	} else if (val != 0x0c) {
-		dev_err(&state->client->dev, "%s: firmware boot timeout\n",
-				KBUILD_MODNAME);
+		dev_err(&client->dev, "firmware boot timeout\n");
 		ret = -ENODEV;
 	}
 
@@ -1434,8 +1432,8 @@ static int af9013_download_firmware(struct af9013_state *state)
 err:
 exit:
 	if (!ret)
-		dev_info(&state->client->dev, "%s: found a '%s' in warm state\n",
-				KBUILD_MODNAME, af9013_ops.info.name);
+		dev_info(&client->dev, "found a '%s' in warm state\n",
+			 af9013_ops.info.name);
 	return ret;
 }
 

commit 903b0e58d890ab9052eef1dbbddcac0f357410b8
Author: Antti Palosaari <crope@iki.fi>
Date:   Sat Jun 10 21:12:14 2017 -0300

    [media] af9013: use kernel 64-bit division
    
    Replace own binary division with 64-bit multiply and division.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/af9013.c b/drivers/media/dvb-frontends/af9013.c
index a10c7165075c..a6c53bb298ce 100644
--- a/drivers/media/dvb-frontends/af9013.c
+++ b/drivers/media/dvb-frontends/af9013.c
@@ -277,33 +277,6 @@ static int af9013_set_gpio(struct af9013_state *state, u8 gpio, u8 gpioval)
 	return ret;
 }
 
-static u32 af9013_div(struct af9013_state *state, u32 a, u32 b, u32 x)
-{
-	u32 r = 0, c = 0, i;
-
-	dev_dbg(&state->client->dev, "%s: a=%d b=%d x=%d\n", __func__, a, b, x);
-
-	if (a > b) {
-		c = a / b;
-		a = a - c * b;
-	}
-
-	for (i = 0; i < x; i++) {
-		if (a >= b) {
-			r += 1;
-			a -= b;
-		}
-		a <<= 1;
-		r <<= 1;
-	}
-	r = (c << (u32)x) + r;
-
-	dev_dbg(&state->client->dev, "%s: a=%d b=%d x=%d r=%d r=%x\n",
-			__func__, a, b, x, r, r);
-
-	return r;
-}
-
 static int af9013_power_ctrl(struct af9013_state *state, u8 onoff)
 {
 	int ret, i;
@@ -641,8 +614,8 @@ static int af9013_set_frontend(struct dvb_frontend *fe)
 			spec_inv = !state->spec_inv;
 		}
 
-		freq_cw = af9013_div(state, sampling_freq, state->clk,
-				23);
+		freq_cw = DIV_ROUND_CLOSEST_ULL((u64)sampling_freq * 0x800000,
+						state->clk);
 
 		if (spec_inv)
 			freq_cw = 0x800000 - freq_cw;
@@ -1111,11 +1084,10 @@ static int af9013_init(struct dvb_frontend *fe)
 		return -EINVAL;
 	}
 
-	adc_cw = af9013_div(state, state->clk, 1000000ul, 19);
+	adc_cw = div_u64((u64)state->clk * 0x80000, 1000000);
 	buf[0] = (adc_cw >>  0) & 0xff;
 	buf[1] = (adc_cw >>  8) & 0xff;
 	buf[2] = (adc_cw >> 16) & 0xff;
-
 	ret = af9013_wr_regs(state, 0xd180, buf, 3);
 	if (ret)
 		goto err;

commit 82d1ce3eba6952929efa770e693d3be6e55bd7ab
Author: Antti Palosaari <crope@iki.fi>
Date:   Sat Jun 10 20:53:42 2017 -0300

    [media] af9013: add i2c client bindings
    
    Add kernel i2c driver bindings.
    That allows dev_* logging, regmap and more.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/af9013.c b/drivers/media/dvb-frontends/af9013.c
index 97229d95c6d4..a10c7165075c 100644
--- a/drivers/media/dvb-frontends/af9013.c
+++ b/drivers/media/dvb-frontends/af9013.c
@@ -24,9 +24,8 @@
 #define MAX_XFER_SIZE  64
 
 struct af9013_state {
-	struct i2c_adapter *i2c;
+	struct i2c_client *client;
 	struct dvb_frontend fe;
-	u8 i2c_addr;
 	u32 clk;
 	u8 tuner;
 	u32 if_frequency;
@@ -59,7 +58,7 @@ static int af9013_wr_regs_i2c(struct af9013_state *priv, u8 mbox, u16 reg,
 	u8 buf[MAX_XFER_SIZE];
 	struct i2c_msg msg[1] = {
 		{
-			.addr = priv->i2c_addr,
+			.addr = priv->client->addr,
 			.flags = 0,
 			.len = 3 + len,
 			.buf = buf,
@@ -67,7 +66,7 @@ static int af9013_wr_regs_i2c(struct af9013_state *priv, u8 mbox, u16 reg,
 	};
 
 	if (3 + len > sizeof(buf)) {
-		dev_warn(&priv->i2c->dev,
+		dev_warn(&priv->client->dev,
 			 "%s: i2c wr reg=%04x: len=%d is too big!\n",
 			 KBUILD_MODNAME, reg, len);
 		return -EINVAL;
@@ -78,11 +77,11 @@ static int af9013_wr_regs_i2c(struct af9013_state *priv, u8 mbox, u16 reg,
 	buf[2] = mbox;
 	memcpy(&buf[3], val, len);
 
-	ret = i2c_transfer(priv->i2c, msg, 1);
+	ret = i2c_transfer(priv->client->adapter, msg, 1);
 	if (ret == 1) {
 		ret = 0;
 	} else {
-		dev_warn(&priv->i2c->dev, "%s: i2c wr failed=%d reg=%04x " \
+		dev_warn(&priv->client->dev, "%s: i2c wr failed=%d reg=%04x " \
 				"len=%d\n", KBUILD_MODNAME, ret, reg, len);
 		ret = -EREMOTEIO;
 	}
@@ -97,12 +96,12 @@ static int af9013_rd_regs_i2c(struct af9013_state *priv, u8 mbox, u16 reg,
 	u8 buf[3];
 	struct i2c_msg msg[2] = {
 		{
-			.addr = priv->i2c_addr,
+			.addr = priv->client->addr,
 			.flags = 0,
 			.len = 3,
 			.buf = buf,
 		}, {
-			.addr = priv->i2c_addr,
+			.addr = priv->client->addr,
 			.flags = I2C_M_RD,
 			.len = len,
 			.buf = val,
@@ -113,11 +112,11 @@ static int af9013_rd_regs_i2c(struct af9013_state *priv, u8 mbox, u16 reg,
 	buf[1] = (reg >> 0) & 0xff;
 	buf[2] = mbox;
 
-	ret = i2c_transfer(priv->i2c, msg, 2);
+	ret = i2c_transfer(priv->client->adapter, msg, 2);
 	if (ret == 2) {
 		ret = 0;
 	} else {
-		dev_warn(&priv->i2c->dev, "%s: i2c rd failed=%d reg=%04x " \
+		dev_warn(&priv->client->dev, "%s: i2c rd failed=%d reg=%04x " \
 				"len=%d\n", KBUILD_MODNAME, ret, reg, len);
 		ret = -EREMOTEIO;
 	}
@@ -231,7 +230,7 @@ static int af9013_set_gpio(struct af9013_state *state, u8 gpio, u8 gpioval)
 	u8 pos;
 	u16 addr;
 
-	dev_dbg(&state->i2c->dev, "%s: gpio=%d gpioval=%02x\n",
+	dev_dbg(&state->client->dev, "%s: gpio=%d gpioval=%02x\n",
 			__func__, gpio, gpioval);
 
 	/*
@@ -250,7 +249,7 @@ static int af9013_set_gpio(struct af9013_state *state, u8 gpio, u8 gpioval)
 		break;
 
 	default:
-		dev_err(&state->i2c->dev, "%s: invalid gpio=%d\n",
+		dev_err(&state->client->dev, "%s: invalid gpio=%d\n",
 				KBUILD_MODNAME, gpio);
 		ret = -EINVAL;
 		goto err;
@@ -274,7 +273,7 @@ static int af9013_set_gpio(struct af9013_state *state, u8 gpio, u8 gpioval)
 
 	return ret;
 err:
-	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	dev_dbg(&state->client->dev, "%s: failed=%d\n", __func__, ret);
 	return ret;
 }
 
@@ -282,7 +281,7 @@ static u32 af9013_div(struct af9013_state *state, u32 a, u32 b, u32 x)
 {
 	u32 r = 0, c = 0, i;
 
-	dev_dbg(&state->i2c->dev, "%s: a=%d b=%d x=%d\n", __func__, a, b, x);
+	dev_dbg(&state->client->dev, "%s: a=%d b=%d x=%d\n", __func__, a, b, x);
 
 	if (a > b) {
 		c = a / b;
@@ -299,7 +298,7 @@ static u32 af9013_div(struct af9013_state *state, u32 a, u32 b, u32 x)
 	}
 	r = (c << (u32)x) + r;
 
-	dev_dbg(&state->i2c->dev, "%s: a=%d b=%d x=%d r=%d r=%x\n",
+	dev_dbg(&state->client->dev, "%s: a=%d b=%d x=%d r=%d r=%x\n",
 			__func__, a, b, x, r, r);
 
 	return r;
@@ -310,7 +309,7 @@ static int af9013_power_ctrl(struct af9013_state *state, u8 onoff)
 	int ret, i;
 	u8 tmp;
 
-	dev_dbg(&state->i2c->dev, "%s: onoff=%d\n", __func__, onoff);
+	dev_dbg(&state->client->dev, "%s: onoff=%d\n", __func__, onoff);
 
 	/* enable reset */
 	ret = af9013_wr_reg_bits(state, 0xd417, 4, 1, 1);
@@ -355,7 +354,7 @@ static int af9013_power_ctrl(struct af9013_state *state, u8 onoff)
 
 	return ret;
 err:
-	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	dev_dbg(&state->client->dev, "%s: failed=%d\n", __func__, ret);
 	return ret;
 }
 
@@ -364,7 +363,7 @@ static int af9013_statistics_ber_unc_start(struct dvb_frontend *fe)
 	struct af9013_state *state = fe->demodulator_priv;
 	int ret;
 
-	dev_dbg(&state->i2c->dev, "%s:\n", __func__);
+	dev_dbg(&state->client->dev, "%s:\n", __func__);
 
 	/* reset and start BER counter */
 	ret = af9013_wr_reg_bits(state, 0xd391, 4, 1, 1);
@@ -373,7 +372,7 @@ static int af9013_statistics_ber_unc_start(struct dvb_frontend *fe)
 
 	return ret;
 err:
-	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	dev_dbg(&state->client->dev, "%s: failed=%d\n", __func__, ret);
 	return ret;
 }
 
@@ -383,7 +382,7 @@ static int af9013_statistics_ber_unc_result(struct dvb_frontend *fe)
 	int ret;
 	u8 buf[5];
 
-	dev_dbg(&state->i2c->dev, "%s:\n", __func__);
+	dev_dbg(&state->client->dev, "%s:\n", __func__);
 
 	/* check if error bit count is ready */
 	ret = af9013_rd_reg_bits(state, 0xd391, 4, 1, &buf[0]);
@@ -391,7 +390,7 @@ static int af9013_statistics_ber_unc_result(struct dvb_frontend *fe)
 		goto err;
 
 	if (!buf[0]) {
-		dev_dbg(&state->i2c->dev, "%s: not ready\n", __func__);
+		dev_dbg(&state->client->dev, "%s: not ready\n", __func__);
 		return 0;
 	}
 
@@ -404,7 +403,7 @@ static int af9013_statistics_ber_unc_result(struct dvb_frontend *fe)
 
 	return ret;
 err:
-	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	dev_dbg(&state->client->dev, "%s: failed=%d\n", __func__, ret);
 	return ret;
 }
 
@@ -413,7 +412,7 @@ static int af9013_statistics_snr_start(struct dvb_frontend *fe)
 	struct af9013_state *state = fe->demodulator_priv;
 	int ret;
 
-	dev_dbg(&state->i2c->dev, "%s:\n", __func__);
+	dev_dbg(&state->client->dev, "%s:\n", __func__);
 
 	/* start SNR meas */
 	ret = af9013_wr_reg_bits(state, 0xd2e1, 3, 1, 1);
@@ -422,7 +421,7 @@ static int af9013_statistics_snr_start(struct dvb_frontend *fe)
 
 	return ret;
 err:
-	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	dev_dbg(&state->client->dev, "%s: failed=%d\n", __func__, ret);
 	return ret;
 }
 
@@ -434,7 +433,7 @@ static int af9013_statistics_snr_result(struct dvb_frontend *fe)
 	u32 snr_val;
 	const struct af9013_snr *uninitialized_var(snr_lut);
 
-	dev_dbg(&state->i2c->dev, "%s:\n", __func__);
+	dev_dbg(&state->client->dev, "%s:\n", __func__);
 
 	/* check if SNR ready */
 	ret = af9013_rd_reg_bits(state, 0xd2e1, 3, 1, &tmp);
@@ -442,7 +441,7 @@ static int af9013_statistics_snr_result(struct dvb_frontend *fe)
 		goto err;
 
 	if (!tmp) {
-		dev_dbg(&state->i2c->dev, "%s: not ready\n", __func__);
+		dev_dbg(&state->client->dev, "%s: not ready\n", __func__);
 		return 0;
 	}
 
@@ -485,7 +484,7 @@ static int af9013_statistics_snr_result(struct dvb_frontend *fe)
 
 	return ret;
 err:
-	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	dev_dbg(&state->client->dev, "%s: failed=%d\n", __func__, ret);
 	return ret;
 }
 
@@ -496,7 +495,7 @@ static int af9013_statistics_signal_strength(struct dvb_frontend *fe)
 	u8 buf[2], rf_gain, if_gain;
 	int signal_strength;
 
-	dev_dbg(&state->i2c->dev, "%s:\n", __func__);
+	dev_dbg(&state->client->dev, "%s:\n", __func__);
 
 	if (!state->signal_strength_en)
 		return 0;
@@ -522,7 +521,7 @@ static int af9013_statistics_signal_strength(struct dvb_frontend *fe)
 
 	return ret;
 err:
-	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	dev_dbg(&state->client->dev, "%s: failed=%d\n", __func__, ret);
 	return ret;
 }
 
@@ -593,7 +592,7 @@ static int af9013_set_frontend(struct dvb_frontend *fe)
 	u8 buf[6];
 	u32 if_frequency, freq_cw;
 
-	dev_dbg(&state->i2c->dev, "%s: frequency=%d bandwidth_hz=%d\n",
+	dev_dbg(&state->client->dev, "%s: frequency=%d bandwidth_hz=%d\n",
 			__func__, c->frequency, c->bandwidth_hz);
 
 	/* program tuner */
@@ -627,7 +626,7 @@ static int af9013_set_frontend(struct dvb_frontend *fe)
 		else
 			if_frequency = state->if_frequency;
 
-		dev_dbg(&state->i2c->dev, "%s: if_frequency=%d\n",
+		dev_dbg(&state->client->dev, "%s: if_frequency=%d\n",
 				__func__, if_frequency);
 
 		sampling_freq = if_frequency;
@@ -701,7 +700,7 @@ static int af9013_set_frontend(struct dvb_frontend *fe)
 		buf[0] |= (1 << 0);
 		break;
 	default:
-		dev_dbg(&state->i2c->dev, "%s: invalid transmission_mode\n",
+		dev_dbg(&state->client->dev, "%s: invalid transmission_mode\n",
 				__func__);
 		auto_mode = true;
 	}
@@ -722,7 +721,7 @@ static int af9013_set_frontend(struct dvb_frontend *fe)
 		buf[0] |= (3 << 2);
 		break;
 	default:
-		dev_dbg(&state->i2c->dev, "%s: invalid guard_interval\n",
+		dev_dbg(&state->client->dev, "%s: invalid guard_interval\n",
 				__func__);
 		auto_mode = true;
 	}
@@ -743,7 +742,7 @@ static int af9013_set_frontend(struct dvb_frontend *fe)
 		buf[0] |= (3 << 4);
 		break;
 	default:
-		dev_dbg(&state->i2c->dev, "%s: invalid hierarchy\n", __func__);
+		dev_dbg(&state->client->dev, "%s: invalid hierarchy\n", __func__);
 		auto_mode = true;
 	}
 
@@ -760,7 +759,7 @@ static int af9013_set_frontend(struct dvb_frontend *fe)
 		buf[1] |= (2 << 6);
 		break;
 	default:
-		dev_dbg(&state->i2c->dev, "%s: invalid modulation\n", __func__);
+		dev_dbg(&state->client->dev, "%s: invalid modulation\n", __func__);
 		auto_mode = true;
 	}
 
@@ -786,7 +785,7 @@ static int af9013_set_frontend(struct dvb_frontend *fe)
 		buf[2] |= (4 << 0);
 		break;
 	default:
-		dev_dbg(&state->i2c->dev, "%s: invalid code_rate_HP\n",
+		dev_dbg(&state->client->dev, "%s: invalid code_rate_HP\n",
 				__func__);
 		auto_mode = true;
 	}
@@ -812,7 +811,7 @@ static int af9013_set_frontend(struct dvb_frontend *fe)
 	case FEC_NONE:
 		break;
 	default:
-		dev_dbg(&state->i2c->dev, "%s: invalid code_rate_LP\n",
+		dev_dbg(&state->client->dev, "%s: invalid code_rate_LP\n",
 				__func__);
 		auto_mode = true;
 	}
@@ -827,7 +826,7 @@ static int af9013_set_frontend(struct dvb_frontend *fe)
 		buf[1] |= (2 << 2);
 		break;
 	default:
-		dev_dbg(&state->i2c->dev, "%s: invalid bandwidth_hz\n",
+		dev_dbg(&state->client->dev, "%s: invalid bandwidth_hz\n",
 				__func__);
 		ret = -EINVAL;
 		goto err;
@@ -843,7 +842,7 @@ static int af9013_set_frontend(struct dvb_frontend *fe)
 		if (ret)
 			goto err;
 
-		dev_dbg(&state->i2c->dev, "%s: auto params\n", __func__);
+		dev_dbg(&state->client->dev, "%s: auto params\n", __func__);
 	} else {
 		/* set easy mode flag */
 		ret = af9013_wr_reg(state, 0xaefd, 1);
@@ -854,7 +853,7 @@ static int af9013_set_frontend(struct dvb_frontend *fe)
 		if (ret)
 			goto err;
 
-		dev_dbg(&state->i2c->dev, "%s: manual params\n", __func__);
+		dev_dbg(&state->client->dev, "%s: manual params\n", __func__);
 	}
 
 	/* tune */
@@ -868,7 +867,7 @@ static int af9013_set_frontend(struct dvb_frontend *fe)
 
 	return ret;
 err:
-	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	dev_dbg(&state->client->dev, "%s: failed=%d\n", __func__, ret);
 	return ret;
 }
 
@@ -879,7 +878,7 @@ static int af9013_get_frontend(struct dvb_frontend *fe,
 	int ret;
 	u8 buf[3];
 
-	dev_dbg(&state->i2c->dev, "%s:\n", __func__);
+	dev_dbg(&state->client->dev, "%s:\n", __func__);
 
 	ret = af9013_rd_regs(state, 0xd3c0, buf, 3);
 	if (ret)
@@ -985,7 +984,7 @@ static int af9013_get_frontend(struct dvb_frontend *fe,
 
 	return ret;
 err:
-	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	dev_dbg(&state->client->dev, "%s: failed=%d\n", __func__, ret);
 	return ret;
 }
 
@@ -1035,7 +1034,7 @@ static int af9013_read_status(struct dvb_frontend *fe, enum fe_status *status)
 
 	return ret;
 err:
-	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	dev_dbg(&state->client->dev, "%s: failed=%d\n", __func__, ret);
 	return ret;
 }
 
@@ -1075,7 +1074,7 @@ static int af9013_init(struct dvb_frontend *fe)
 	u32 adc_cw;
 	const struct af9013_reg_bit *init;
 
-	dev_dbg(&state->i2c->dev, "%s:\n", __func__);
+	dev_dbg(&state->client->dev, "%s:\n", __func__);
 
 	/* power on */
 	ret = af9013_power_ctrl(state, 1);
@@ -1107,7 +1106,7 @@ static int af9013_init(struct dvb_frontend *fe)
 		tmp = 3;
 		break;
 	default:
-		dev_err(&state->i2c->dev, "%s: invalid clock\n",
+		dev_err(&state->client->dev, "%s: invalid clock\n",
 				KBUILD_MODNAME);
 		return -EINVAL;
 	}
@@ -1168,7 +1167,7 @@ static int af9013_init(struct dvb_frontend *fe)
 		goto err;
 
 	/* load OFSM settings */
-	dev_dbg(&state->i2c->dev, "%s: load ofsm settings\n", __func__);
+	dev_dbg(&state->client->dev, "%s: load ofsm settings\n", __func__);
 	len = ARRAY_SIZE(ofsm_init);
 	init = ofsm_init;
 	for (i = 0; i < len; i++) {
@@ -1179,7 +1178,7 @@ static int af9013_init(struct dvb_frontend *fe)
 	}
 
 	/* load tuner specific settings */
-	dev_dbg(&state->i2c->dev, "%s: load tuner specific settings\n",
+	dev_dbg(&state->client->dev, "%s: load tuner specific settings\n",
 			__func__);
 	switch (state->tuner) {
 	case AF9013_TUNER_MXL5003D:
@@ -1291,7 +1290,7 @@ static int af9013_init(struct dvb_frontend *fe)
 
 	return ret;
 err:
-	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	dev_dbg(&state->client->dev, "%s: failed=%d\n", __func__, ret);
 	return ret;
 }
 
@@ -1300,7 +1299,7 @@ static int af9013_sleep(struct dvb_frontend *fe)
 	struct af9013_state *state = fe->demodulator_priv;
 	int ret;
 
-	dev_dbg(&state->i2c->dev, "%s:\n", __func__);
+	dev_dbg(&state->client->dev, "%s:\n", __func__);
 
 	/* stop statistics polling */
 	cancel_delayed_work_sync(&state->statistics_work);
@@ -1317,7 +1316,7 @@ static int af9013_sleep(struct dvb_frontend *fe)
 
 	return ret;
 err:
-	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	dev_dbg(&state->client->dev, "%s: failed=%d\n", __func__, ret);
 	return ret;
 }
 
@@ -1326,7 +1325,7 @@ static int af9013_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)
 	int ret;
 	struct af9013_state *state = fe->demodulator_priv;
 
-	dev_dbg(&state->i2c->dev, "%s: enable=%d\n", __func__, enable);
+	dev_dbg(&state->client->dev, "%s: enable=%d\n", __func__, enable);
 
 	/* gate already open or close */
 	if (state->i2c_gate_state == enable)
@@ -1343,18 +1342,16 @@ static int af9013_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)
 
 	return ret;
 err:
-	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	dev_dbg(&state->client->dev, "%s: failed=%d\n", __func__, ret);
 	return ret;
 }
 
 static void af9013_release(struct dvb_frontend *fe)
 {
 	struct af9013_state *state = fe->demodulator_priv;
+	struct i2c_client *client = state->client;
 
-	/* stop statistics polling */
-	cancel_delayed_work_sync(&state->statistics_work);
-
-	kfree(state);
+	i2c_unregister_device(client);
 }
 
 static const struct dvb_frontend_ops af9013_ops;
@@ -1374,27 +1371,27 @@ static int af9013_download_firmware(struct af9013_state *state)
 	if (ret)
 		goto err;
 	else
-		dev_dbg(&state->i2c->dev, "%s: firmware status=%02x\n",
+		dev_dbg(&state->client->dev, "%s: firmware status=%02x\n",
 				__func__, val);
 
 	if (val == 0x0c) /* fw is running, no need for download */
 		goto exit;
 
-	dev_info(&state->i2c->dev, "%s: found a '%s' in cold state, will try " \
+	dev_info(&state->client->dev, "%s: found a '%s' in cold state, will try " \
 			"to load a firmware\n",
 			KBUILD_MODNAME, af9013_ops.info.name);
 
 	/* request the firmware, this will block and timeout */
-	ret = request_firmware(&fw, fw_file, state->i2c->dev.parent);
+	ret = request_firmware(&fw, fw_file, &state->client->dev);
 	if (ret) {
-		dev_info(&state->i2c->dev, "%s: did not find the firmware " \
+		dev_info(&state->client->dev, "%s: did not find the firmware " \
 			"file. (%s) Please see linux/Documentation/dvb/ for " \
 			"more details on firmware-problems. (%d)\n",
 			KBUILD_MODNAME, fw_file, ret);
 		goto err;
 	}
 
-	dev_info(&state->i2c->dev, "%s: downloading firmware from file '%s'\n",
+	dev_info(&state->client->dev, "%s: downloading firmware from file '%s'\n",
 			KBUILD_MODNAME, fw_file);
 
 	/* calc checksum */
@@ -1423,7 +1420,7 @@ static int af9013_download_firmware(struct af9013_state *state)
 			FW_ADDR + fw->size - remaining,
 			(u8 *) &fw->data[fw->size - remaining], len);
 		if (ret) {
-			dev_err(&state->i2c->dev,
+			dev_err(&state->client->dev,
 					"%s: firmware download failed=%d\n",
 					KBUILD_MODNAME, ret);
 			goto err_release;
@@ -1443,7 +1440,7 @@ static int af9013_download_firmware(struct af9013_state *state)
 		if (ret)
 			goto err_release;
 
-		dev_dbg(&state->i2c->dev, "%s: firmware status=%02x\n",
+		dev_dbg(&state->client->dev, "%s: firmware status=%02x\n",
 				__func__, val);
 
 		if (val == 0x0c || val == 0x04) /* success or fail */
@@ -1451,11 +1448,11 @@ static int af9013_download_firmware(struct af9013_state *state)
 	}
 
 	if (val == 0x04) {
-		dev_err(&state->i2c->dev, "%s: firmware did not run\n",
+		dev_err(&state->client->dev, "%s: firmware did not run\n",
 				KBUILD_MODNAME);
 		ret = -ENODEV;
 	} else if (val != 0x0c) {
-		dev_err(&state->i2c->dev, "%s: firmware boot timeout\n",
+		dev_err(&state->client->dev, "%s: firmware boot timeout\n",
 				KBUILD_MODNAME);
 		ret = -ENODEV;
 	}
@@ -1465,67 +1462,41 @@ static int af9013_download_firmware(struct af9013_state *state)
 err:
 exit:
 	if (!ret)
-		dev_info(&state->i2c->dev, "%s: found a '%s' in warm state\n",
+		dev_info(&state->client->dev, "%s: found a '%s' in warm state\n",
 				KBUILD_MODNAME, af9013_ops.info.name);
 	return ret;
 }
 
+/*
+ * XXX: That is wrapper to af9013_probe() via driver core in order to provide
+ * proper I2C client for legacy media attach binding.
+ * New users must use I2C client binding directly!
+ */
 struct dvb_frontend *af9013_attach(const struct af9013_config *config,
-	struct i2c_adapter *i2c)
+				   struct i2c_adapter *i2c)
 {
-	int ret;
-	struct af9013_state *state = NULL;
-	u8 buf[4], i;
-
-	/* allocate memory for the internal state */
-	state = kzalloc(sizeof(struct af9013_state), GFP_KERNEL);
-	if (state == NULL)
-		goto err;
-
-	/* setup the state */
-	state->i2c = i2c;
-	state->i2c_addr = config->i2c_addr;
-	state->clk = config->clock;
-	state->tuner = config->tuner;
-	state->if_frequency = config->if_frequency;
-	state->ts_mode = config->ts_mode;
-	state->spec_inv = config->spec_inv;
-	memcpy(&state->api_version, config->api_version, sizeof(state->api_version));
-	memcpy(&state->gpio, config->gpio, sizeof(state->gpio));
-
-	/* download firmware */
-	if (state->ts_mode != AF9013_TS_USB) {
-		ret = af9013_download_firmware(state);
-		if (ret)
-			goto err;
-	}
-
-	/* firmware version */
-	ret = af9013_rd_regs(state, 0x5103, buf, 4);
-	if (ret)
-		goto err;
-
-	dev_info(&state->i2c->dev, "%s: firmware version %d.%d.%d.%d\n",
-			KBUILD_MODNAME, buf[0], buf[1], buf[2], buf[3]);
-
-	/* set GPIOs */
-	for (i = 0; i < sizeof(state->gpio); i++) {
-		ret = af9013_set_gpio(state, i, state->gpio[i]);
-		if (ret)
-			goto err;
-	}
-
-	/* create dvb_frontend */
-	memcpy(&state->fe.ops, &af9013_ops,
-		sizeof(struct dvb_frontend_ops));
-	state->fe.demodulator_priv = state;
-
-	INIT_DELAYED_WORK(&state->statistics_work, af9013_statistics_work);
-
-	return &state->fe;
-err:
-	kfree(state);
-	return NULL;
+	struct i2c_client *client;
+	struct i2c_board_info board_info;
+	struct af9013_platform_data pdata;
+
+	pdata.clk = config->clock;
+	pdata.tuner = config->tuner;
+	pdata.if_frequency = config->if_frequency;
+	pdata.ts_mode = config->ts_mode;
+	pdata.spec_inv = config->spec_inv;
+	memcpy(&pdata.api_version, config->api_version, sizeof(pdata.api_version));
+	memcpy(&pdata.gpio, config->gpio, sizeof(pdata.gpio));
+	pdata.attach_in_use = true;
+
+	memset(&board_info, 0, sizeof(board_info));
+	strlcpy(board_info.type, "af9013", sizeof(board_info.type));
+	board_info.addr = config->i2c_addr;
+	board_info.platform_data = &pdata;
+	client = i2c_new_device(i2c, &board_info);
+	if (!client || !client->dev.driver)
+		return NULL;
+
+	return pdata.get_dvb_frontend(client);
 }
 EXPORT_SYMBOL(af9013_attach);
 
@@ -1572,6 +1543,114 @@ static const struct dvb_frontend_ops af9013_ops = {
 	.i2c_gate_ctrl = af9013_i2c_gate_ctrl,
 };
 
+static struct dvb_frontend *af9013_get_dvb_frontend(struct i2c_client *client)
+{
+	struct af9013_state *state = i2c_get_clientdata(client);
+
+	dev_dbg(&client->dev, "\n");
+
+	return &state->fe;
+}
+
+static int af9013_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct af9013_state *state;
+	struct af9013_platform_data *pdata = client->dev.platform_data;
+	int ret, i;
+	u8 firmware_version[4];
+
+	state = kzalloc(sizeof(*state), GFP_KERNEL);
+	if (!state) {
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	/* Setup the state */
+	state->client = client;
+	i2c_set_clientdata(client, state);
+	state->clk = pdata->clk;
+	state->tuner = pdata->tuner;
+	state->if_frequency = pdata->if_frequency;
+	state->ts_mode = pdata->ts_mode;
+	state->spec_inv = pdata->spec_inv;
+	memcpy(&state->api_version, pdata->api_version, sizeof(state->api_version));
+	memcpy(&state->gpio, pdata->gpio, sizeof(state->gpio));
+	INIT_DELAYED_WORK(&state->statistics_work, af9013_statistics_work);
+
+	/* Download firmware */
+	if (state->ts_mode != AF9013_TS_USB) {
+		ret = af9013_download_firmware(state);
+		if (ret)
+			goto err_kfree;
+	}
+
+	/* Firmware version */
+	ret = af9013_rd_regs(state, 0x5103, firmware_version,
+			     sizeof(firmware_version));
+	if (ret)
+		goto err_kfree;
+
+	/* Set GPIOs */
+	for (i = 0; i < sizeof(state->gpio); i++) {
+		ret = af9013_set_gpio(state, i, state->gpio[i]);
+		if (ret)
+			goto err_kfree;
+	}
+
+	/* Create dvb frontend */
+	memcpy(&state->fe.ops, &af9013_ops, sizeof(state->fe.ops));
+	if (!pdata->attach_in_use)
+		state->fe.ops.release = NULL;
+	state->fe.demodulator_priv = state;
+
+	/* Setup callbacks */
+	pdata->get_dvb_frontend = af9013_get_dvb_frontend;
+
+	dev_info(&client->dev, "Afatech AF9013 successfully attached\n");
+	dev_info(&client->dev, "firmware version: %d.%d.%d.%d\n",
+		 firmware_version[0], firmware_version[1],
+		 firmware_version[2], firmware_version[3]);
+	return 0;
+err_kfree:
+	kfree(state);
+err:
+	dev_dbg(&client->dev, "failed %d\n", ret);
+	return ret;
+}
+
+static int af9013_remove(struct i2c_client *client)
+{
+	struct af9013_state *state = i2c_get_clientdata(client);
+
+	dev_dbg(&client->dev, "\n");
+
+	/* Stop statistics polling */
+	cancel_delayed_work_sync(&state->statistics_work);
+
+	kfree(state);
+
+	return 0;
+}
+
+static const struct i2c_device_id af9013_id_table[] = {
+	{"af9013", 0},
+	{}
+};
+MODULE_DEVICE_TABLE(i2c, af9013_id_table);
+
+static struct i2c_driver af9013_driver = {
+	.driver = {
+		.name	= "af9013",
+		.suppress_bind_attrs = true,
+	},
+	.probe		= af9013_probe,
+	.remove		= af9013_remove,
+	.id_table	= af9013_id_table,
+};
+
+module_i2c_driver(af9013_driver);
+
 MODULE_AUTHOR("Antti Palosaari <crope@iki.fi>");
 MODULE_DESCRIPTION("Afatech AF9013 DVB-T demodulator driver");
 MODULE_LICENSE("GPL");

commit a4e2b6fe0edc16a80a3879bab409e18203c57a07
Author: Antti Palosaari <crope@iki.fi>
Date:   Sat Jun 10 19:24:34 2017 -0300

    [media] af9013: move config values directly under driver state
    
    It shorten, as typed chars, access to config values as there is one
    pointer less. Also, when config/platform data is passed to driver there
    could be some values that are not relevant to store state as such or
    not needed to store at all.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/af9013.c b/drivers/media/dvb-frontends/af9013.c
index dc7ccda41bcd..97229d95c6d4 100644
--- a/drivers/media/dvb-frontends/af9013.c
+++ b/drivers/media/dvb-frontends/af9013.c
@@ -26,7 +26,14 @@
 struct af9013_state {
 	struct i2c_adapter *i2c;
 	struct dvb_frontend fe;
-	struct af9013_config config;
+	u8 i2c_addr;
+	u32 clk;
+	u8 tuner;
+	u32 if_frequency;
+	u8 ts_mode;
+	bool spec_inv;
+	u8 api_version[4];
+	u8 gpio[4];
 
 	/* tuner/demod RF and IF AGC limits used for signal strength calc */
 	u8 signal_strength_en, rf_50, rf_80, if_50, if_80;
@@ -52,7 +59,7 @@ static int af9013_wr_regs_i2c(struct af9013_state *priv, u8 mbox, u16 reg,
 	u8 buf[MAX_XFER_SIZE];
 	struct i2c_msg msg[1] = {
 		{
-			.addr = priv->config.i2c_addr,
+			.addr = priv->i2c_addr,
 			.flags = 0,
 			.len = 3 + len,
 			.buf = buf,
@@ -90,12 +97,12 @@ static int af9013_rd_regs_i2c(struct af9013_state *priv, u8 mbox, u16 reg,
 	u8 buf[3];
 	struct i2c_msg msg[2] = {
 		{
-			.addr = priv->config.i2c_addr,
+			.addr = priv->i2c_addr,
 			.flags = 0,
 			.len = 3,
 			.buf = buf,
 		}, {
-			.addr = priv->config.i2c_addr,
+			.addr = priv->i2c_addr,
 			.flags = I2C_M_RD,
 			.len = len,
 			.buf = val,
@@ -124,7 +131,7 @@ static int af9013_wr_regs(struct af9013_state *priv, u16 reg, const u8 *val,
 	int ret, i;
 	u8 mbox = (0 << 7)|(0 << 6)|(1 << 1)|(1 << 0);
 
-	if ((priv->config.ts_mode == AF9013_TS_USB) &&
+	if ((priv->ts_mode == AF9013_TS_USB) &&
 		((reg & 0xff00) != 0xff00) && ((reg & 0xff00) != 0xae00)) {
 		mbox |= ((len - 1) << 2);
 		ret = af9013_wr_regs_i2c(priv, mbox, reg, val, len);
@@ -146,7 +153,7 @@ static int af9013_rd_regs(struct af9013_state *priv, u16 reg, u8 *val, int len)
 	int ret, i;
 	u8 mbox = (0 << 7)|(0 << 6)|(1 << 1)|(0 << 0);
 
-	if ((priv->config.ts_mode == AF9013_TS_USB) &&
+	if ((priv->ts_mode == AF9013_TS_USB) &&
 		((reg & 0xff00) != 0xff00) && ((reg & 0xff00) != 0xae00)) {
 		mbox |= ((len - 1) << 2);
 		ret = af9013_rd_regs_i2c(priv, mbox, reg, val, len);
@@ -596,7 +603,7 @@ static int af9013_set_frontend(struct dvb_frontend *fe)
 	/* program CFOE coefficients */
 	if (c->bandwidth_hz != state->bandwidth_hz) {
 		for (i = 0; i < ARRAY_SIZE(coeff_lut); i++) {
-			if (coeff_lut[i].clock == state->config.clock &&
+			if (coeff_lut[i].clock == state->clk &&
 				coeff_lut[i].bandwidth_hz == c->bandwidth_hz) {
 				break;
 			}
@@ -618,24 +625,24 @@ static int af9013_set_frontend(struct dvb_frontend *fe)
 		if (fe->ops.tuner_ops.get_if_frequency)
 			fe->ops.tuner_ops.get_if_frequency(fe, &if_frequency);
 		else
-			if_frequency = state->config.if_frequency;
+			if_frequency = state->if_frequency;
 
 		dev_dbg(&state->i2c->dev, "%s: if_frequency=%d\n",
 				__func__, if_frequency);
 
 		sampling_freq = if_frequency;
 
-		while (sampling_freq > (state->config.clock / 2))
-			sampling_freq -= state->config.clock;
+		while (sampling_freq > (state->clk / 2))
+			sampling_freq -= state->clk;
 
 		if (sampling_freq < 0) {
 			sampling_freq *= -1;
-			spec_inv = state->config.spec_inv;
+			spec_inv = state->spec_inv;
 		} else {
-			spec_inv = !state->config.spec_inv;
+			spec_inv = !state->spec_inv;
 		}
 
-		freq_cw = af9013_div(state, sampling_freq, state->config.clock,
+		freq_cw = af9013_div(state, sampling_freq, state->clk,
 				23);
 
 		if (spec_inv)
@@ -1081,12 +1088,12 @@ static int af9013_init(struct dvb_frontend *fe)
 		goto err;
 
 	/* write API version to firmware */
-	ret = af9013_wr_regs(state, 0x9bf2, state->config.api_version, 4);
+	ret = af9013_wr_regs(state, 0x9bf2, state->api_version, 4);
 	if (ret)
 		goto err;
 
 	/* program ADC control */
-	switch (state->config.clock) {
+	switch (state->clk) {
 	case 28800000: /* 28.800 MHz */
 		tmp = 0;
 		break;
@@ -1105,7 +1112,7 @@ static int af9013_init(struct dvb_frontend *fe)
 		return -EINVAL;
 	}
 
-	adc_cw = af9013_div(state, state->config.clock, 1000000ul, 19);
+	adc_cw = af9013_div(state, state->clk, 1000000ul, 19);
 	buf[0] = (adc_cw >>  0) & 0xff;
 	buf[1] = (adc_cw >>  8) & 0xff;
 	buf[2] = (adc_cw >> 16) & 0xff;
@@ -1139,7 +1146,7 @@ static int af9013_init(struct dvb_frontend *fe)
 		goto err;
 
 	/* settings for mp2if */
-	if (state->config.ts_mode == AF9013_TS_USB) {
+	if (state->ts_mode == AF9013_TS_USB) {
 		/* AF9015 split PSB to 1.5k + 0.5k */
 		ret = af9013_wr_reg_bits(state, 0xd50b, 2, 1, 1);
 		if (ret)
@@ -1174,7 +1181,7 @@ static int af9013_init(struct dvb_frontend *fe)
 	/* load tuner specific settings */
 	dev_dbg(&state->i2c->dev, "%s: load tuner specific settings\n",
 			__func__);
-	switch (state->config.tuner) {
+	switch (state->tuner) {
 	case AF9013_TUNER_MXL5003D:
 		len = ARRAY_SIZE(tuner_init_mxl5003d);
 		init = tuner_init_mxl5003d;
@@ -1226,7 +1233,7 @@ static int af9013_init(struct dvb_frontend *fe)
 	}
 
 	/* TS mode */
-	ret = af9013_wr_reg_bits(state, 0xd500, 1, 2, state->config.ts_mode);
+	ret = af9013_wr_reg_bits(state, 0xd500, 1, 2, state->ts_mode);
 	if (ret)
 		goto err;
 
@@ -1325,7 +1332,7 @@ static int af9013_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)
 	if (state->i2c_gate_state == enable)
 		return 0;
 
-	if (state->config.ts_mode == AF9013_TS_USB)
+	if (state->ts_mode == AF9013_TS_USB)
 		ret = af9013_wr_reg_bits(state, 0xd417, 3, 1, enable);
 	else
 		ret = af9013_wr_reg_bits(state, 0xd607, 2, 1, enable);
@@ -1477,10 +1484,17 @@ struct dvb_frontend *af9013_attach(const struct af9013_config *config,
 
 	/* setup the state */
 	state->i2c = i2c;
-	memcpy(&state->config, config, sizeof(struct af9013_config));
+	state->i2c_addr = config->i2c_addr;
+	state->clk = config->clock;
+	state->tuner = config->tuner;
+	state->if_frequency = config->if_frequency;
+	state->ts_mode = config->ts_mode;
+	state->spec_inv = config->spec_inv;
+	memcpy(&state->api_version, config->api_version, sizeof(state->api_version));
+	memcpy(&state->gpio, config->gpio, sizeof(state->gpio));
 
 	/* download firmware */
-	if (state->config.ts_mode != AF9013_TS_USB) {
+	if (state->ts_mode != AF9013_TS_USB) {
 		ret = af9013_download_firmware(state);
 		if (ret)
 			goto err;
@@ -1495,8 +1509,8 @@ struct dvb_frontend *af9013_attach(const struct af9013_config *config,
 			KBUILD_MODNAME, buf[0], buf[1], buf[2], buf[3]);
 
 	/* set GPIOs */
-	for (i = 0; i < sizeof(state->config.gpio); i++) {
-		ret = af9013_set_gpio(state, i, state->config.gpio[i]);
+	for (i = 0; i < sizeof(state->gpio); i++) {
+		ret = af9013_set_gpio(state, i, state->gpio[i]);
 		if (ret)
 			goto err;
 	}

commit 88c0530f65e622a96a431b63e3feb707303bc9fc
Author: Gustavo A. R. Silva <garsilva@embeddedor.com>
Date:   Thu Jun 15 17:42:44 2017 -0300

    [media] af9013: add check on af9013_wr_regs() return value
    
    Check return value from call to af9013_wr_regs(), so in case of
    error print debug message and return.
    
    Addresses-Coverity-ID: 1227035
    
    Signed-off-by: Gustavo A. R. Silva <garsilva@embeddedor.com>
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/af9013.c b/drivers/media/dvb-frontends/af9013.c
index 51f942fc0669..dc7ccda41bcd 100644
--- a/drivers/media/dvb-frontends/af9013.c
+++ b/drivers/media/dvb-frontends/af9013.c
@@ -608,6 +608,8 @@ static int af9013_set_frontend(struct dvb_frontend *fe)
 
 		ret = af9013_wr_regs(state, 0xae00, coeff_lut[i].val,
 			sizeof(coeff_lut[i].val));
+		if (ret)
+			goto err;
 	}
 
 	/* program frequency control */

commit 06eeefe8e310bf955da7f82547c72c43e4653d97
Author: Mauro Carvalho Chehab <mchehab@s-opensource.com>
Date:   Thu May 18 08:13:28 2017 -0300

    [media] media drivers: annotate fall-through
    
    Avoid warnings like those:
    
    drivers/media/pci/ddbridge/ddbridge-core.c: In function 'dvb_input_detach':
    drivers/media/pci/ddbridge/ddbridge-core.c:787:6: warning: this statement may fall through [-Wimplicit-fallthrough=]
       if (input->fe) {
          ^
    drivers/media/pci/ddbridge/ddbridge-core.c:792:2: note: here
      case 4:
      ^~~~
    ...
    
    On several cases, it is just that gcc 7.1 is not capable of
    understanding the comment, but on other places, we need an
    annotation.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/af9013.c b/drivers/media/dvb-frontends/af9013.c
index b978002af4d8..51f942fc0669 100644
--- a/drivers/media/dvb-frontends/af9013.c
+++ b/drivers/media/dvb-frontends/af9013.c
@@ -535,6 +535,7 @@ static void af9013_statistics_work(struct work_struct *work)
 	switch (state->statistics_step) {
 	default:
 		state->statistics_step = 0;
+		/* fall-through */
 	case 0:
 		af9013_statistics_signal_strength(&state->fe);
 		state->statistics_step++;

commit bcb63314e2c23f1ed622418b65f9409512659c73
Author: Sakari Ailus <sakari.ailus@linux.intel.com>
Date:   Fri Oct 28 09:31:20 2016 -0200

    [media] media: Drop FSF's postal address from the source code files
    
    Drop the FSF's postal address from the source code files that typically
    contain mostly the license text. Of the 628 removed instances, 578 are
    outdated.
    
    The patch has been created with the following command without manual edits:
    
    git grep -l "675 Mass Ave\|59 Temple Place\|51 Franklin St" -- \
            drivers/media/ include/media|while read i; do i=$i perl -e '
    open(F,"< $ENV{i}");
    $a=join("", <F>);
    $a =~ s/[ \t]*\*\n.*You should.*\n.*along with.*\n.*(\n.*USA.*$)?\n//m
            && $a =~ s/(^.*)Or, (point your browser to) /$1To obtain the license, $2\n$1/m;
    close(F);
    open(F, "> $ENV{i}");
    print F $a;
    close(F);'; done
    
    Signed-off-by: Sakari Ailus <sakari.ailus@linux.intel.com>

diff --git a/drivers/media/dvb-frontends/af9013.c b/drivers/media/dvb-frontends/af9013.c
index c6cb3bbc912a..b978002af4d8 100644
--- a/drivers/media/dvb-frontends/af9013.c
+++ b/drivers/media/dvb-frontends/af9013.c
@@ -16,10 +16,6 @@
  *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *    GNU General Public License for more details.
  *
- *    You should have received a copy of the GNU General Public License
- *    along with this program; if not, write to the Free Software
- *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- *
  */
 
 #include "af9013_priv.h"

commit bd336e63441bcdeeccca6a698087d913a32478c5
Author: Max Kellermann <max.kellermann@gmail.com>
Date:   Tue Aug 9 18:32:21 2016 -0300

    [media] dvb: make DVB frontend *_ops instances "const"
    
    These are immutable.  Making them "const" allows the compiler to move
    them to the "rodata" section.
    
    Note that cxd2841er_t_c_ops cannot be made "const", because
    cxd2841er_attach() modifies it.  Ouch!
    
    [mchehab@s-opensource.com: fix merge conflicts]
    Signed-off-by: Max Kellermann <max.kellermann@gmail.com>
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/af9013.c b/drivers/media/dvb-frontends/af9013.c
index 8bcde336ffd7..c6cb3bbc912a 100644
--- a/drivers/media/dvb-frontends/af9013.c
+++ b/drivers/media/dvb-frontends/af9013.c
@@ -1351,7 +1351,7 @@ static void af9013_release(struct dvb_frontend *fe)
 	kfree(state);
 }
 
-static struct dvb_frontend_ops af9013_ops;
+static const struct dvb_frontend_ops af9013_ops;
 
 static int af9013_download_firmware(struct af9013_state *state)
 {
@@ -1516,7 +1516,7 @@ struct dvb_frontend *af9013_attach(const struct af9013_config *config,
 }
 EXPORT_SYMBOL(af9013_attach);
 
-static struct dvb_frontend_ops af9013_ops = {
+static const struct dvb_frontend_ops af9013_ops = {
 	.delsys = { SYS_DVBT },
 	.info = {
 		.name = "Afatech AF9013",

commit 7e3e68bcfd7713fb1470070c8fa0f108609dd76b
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Thu Feb 4 12:58:30 2016 -0200

    [media] dvb_frontend: pass the props cache to get_frontend() as arg
    
    Instead of using the DTV properties cache directly, pass the get
    frontend data as an argument. For now, everything should remain
    the same, but the next patch will prevent get_frontend to
    affect the global cache.
    
    This is needed because several drivers don't care enough to only
    change the properties if locked. Due to that, calling
    G_PROPERTY before locking on those drivers will make them to
    never lock. Ok, those drivers are crap and should never be
    merged like that, but the core should not rely that the drivers
    would be doing the right thing.
    
    Reviewed-by: Michael Ira Krufky <mkrufky@linuxtv.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/af9013.c b/drivers/media/dvb-frontends/af9013.c
index 41ab5defb798..8bcde336ffd7 100644
--- a/drivers/media/dvb-frontends/af9013.c
+++ b/drivers/media/dvb-frontends/af9013.c
@@ -866,9 +866,9 @@ static int af9013_set_frontend(struct dvb_frontend *fe)
 	return ret;
 }
 
-static int af9013_get_frontend(struct dvb_frontend *fe)
+static int af9013_get_frontend(struct dvb_frontend *fe,
+			       struct dtv_frontend_properties *c)
 {
-	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
 	struct af9013_state *state = fe->demodulator_priv;
 	int ret;
 	u8 buf[3];

commit 631c694f7d7e17147bcf6c7c3669c8f4dc84cc09
Author: Ernst Martin Witte <emw-linux-kernel@nocabal.de>
Date:   Sat Jan 9 18:18:45 2016 -0200

    [media] af9013: cancel_delayed_work_sync before device removal / kfree
    
    af9013_remove  was calling  kfree(state)  with  possibly still  active
    schedule_delayed_work(&state->statistics_work).   A   similar  bug  in
    si2157 caused kernel panics in call_timer_fn e.g. after rmmod cx23885.
    
    Signed-off-by: Ernst Martin Witte <emw-linux-kernel@nocabal.de>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/af9013.c b/drivers/media/dvb-frontends/af9013.c
index e23197da84af..41ab5defb798 100644
--- a/drivers/media/dvb-frontends/af9013.c
+++ b/drivers/media/dvb-frontends/af9013.c
@@ -1344,6 +1344,10 @@ static int af9013_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)
 static void af9013_release(struct dvb_frontend *fe)
 {
 	struct af9013_state *state = fe->demodulator_priv;
+
+	/* stop statistics polling */
+	cancel_delayed_work_sync(&state->statistics_work);
+
 	kfree(state);
 }
 

commit 0df289a209e02f0926042ab07d7d2595ea2d2e9b
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Sun Jun 7 14:53:52 2015 -0300

    [media] dvb: Get rid of typedev usage for enums
    
    The DVB API was originally defined using typedefs. This is against
    Kernel CodingStyle, and there's no good usage here. While we can't
    remove its usage on userspace, we can avoid its usage in Kernelspace.
    
    So, let's do it.
    
    This patch was generated by this shell script:
    
            for j in $(grep typedef include/uapi/linux/dvb/frontend.h |cut -d' ' -f 3); do for i in $(find drivers/media -name '*.[ch]' -type f) $(find drivers/staging/media -name '*.[ch]' -type f); do sed "s,${j}_t,enum $j," <$i >a && mv a $i; done; done
    
    While here, make CodingStyle fixes on the affected lines.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
    Acked-by: Stefan Richter <stefanr@s5r6.in-berlin.de> # for drivers/media/firewire/*

diff --git a/drivers/media/dvb-frontends/af9013.c b/drivers/media/dvb-frontends/af9013.c
index ba6c8f6c42a1..e23197da84af 100644
--- a/drivers/media/dvb-frontends/af9013.c
+++ b/drivers/media/dvb-frontends/af9013.c
@@ -39,7 +39,7 @@ struct af9013_state {
 	u32 ucblocks;
 	u16 snr;
 	u32 bandwidth_hz;
-	fe_status_t fe_status;
+	enum fe_status fe_status;
 	unsigned long set_frontend_jiffies;
 	unsigned long read_status_jiffies;
 	bool first_tune;
@@ -983,7 +983,7 @@ static int af9013_get_frontend(struct dvb_frontend *fe)
 	return ret;
 }
 
-static int af9013_read_status(struct dvb_frontend *fe, fe_status_t *status)
+static int af9013_read_status(struct dvb_frontend *fe, enum fe_status *status)
 {
 	struct af9013_state *state = fe->demodulator_priv;
 	int ret;

commit d7b76c91f471413de9ded837bddeca2164786571
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Tue Apr 28 19:02:19 2015 -0300

    [media] af9013: Don't accept invalid bandwidth
    
    If userspace sends an invalid bandwidth, it should either return
    EINVAL or switch to auto mode.
    
    This driver will go past an array and program the hardware on a
    wrong way if this happens.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/af9013.c b/drivers/media/dvb-frontends/af9013.c
index 8001690d7576..ba6c8f6c42a1 100644
--- a/drivers/media/dvb-frontends/af9013.c
+++ b/drivers/media/dvb-frontends/af9013.c
@@ -605,6 +605,10 @@ static int af9013_set_frontend(struct dvb_frontend *fe)
 			}
 		}
 
+		/* Return an error if can't find bandwidth or the right clock */
+		if (i == ARRAY_SIZE(coeff_lut))
+			return -EINVAL;
+
 		ret = af9013_wr_regs(state, 0xae00, coeff_lut[i].val,
 			sizeof(coeff_lut[i].val));
 	}

commit 6a5e7fde3a04ef5134702753f77e9b8aa6aab789
Author: Mauro Carvalho Chehab <m.chehab@samsung.com>
Date:   Wed Sep 3 15:20:50 2014 -0300

    [media] af9013: use true/false for boolean vars
    
    Instead of using 0 or 1 for boolean, use the true/false
    defines.
    
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/drivers/media/dvb-frontends/af9013.c b/drivers/media/dvb-frontends/af9013.c
index ecf6388d2200..8001690d7576 100644
--- a/drivers/media/dvb-frontends/af9013.c
+++ b/drivers/media/dvb-frontends/af9013.c
@@ -683,7 +683,7 @@ static int af9013_set_frontend(struct dvb_frontend *fe)
 
 	switch (c->transmission_mode) {
 	case TRANSMISSION_MODE_AUTO:
-		auto_mode = 1;
+		auto_mode = true;
 		break;
 	case TRANSMISSION_MODE_2K:
 		break;
@@ -693,12 +693,12 @@ static int af9013_set_frontend(struct dvb_frontend *fe)
 	default:
 		dev_dbg(&state->i2c->dev, "%s: invalid transmission_mode\n",
 				__func__);
-		auto_mode = 1;
+		auto_mode = true;
 	}
 
 	switch (c->guard_interval) {
 	case GUARD_INTERVAL_AUTO:
-		auto_mode = 1;
+		auto_mode = true;
 		break;
 	case GUARD_INTERVAL_1_32:
 		break;
@@ -714,12 +714,12 @@ static int af9013_set_frontend(struct dvb_frontend *fe)
 	default:
 		dev_dbg(&state->i2c->dev, "%s: invalid guard_interval\n",
 				__func__);
-		auto_mode = 1;
+		auto_mode = true;
 	}
 
 	switch (c->hierarchy) {
 	case HIERARCHY_AUTO:
-		auto_mode = 1;
+		auto_mode = true;
 		break;
 	case HIERARCHY_NONE:
 		break;
@@ -734,12 +734,12 @@ static int af9013_set_frontend(struct dvb_frontend *fe)
 		break;
 	default:
 		dev_dbg(&state->i2c->dev, "%s: invalid hierarchy\n", __func__);
-		auto_mode = 1;
+		auto_mode = true;
 	}
 
 	switch (c->modulation) {
 	case QAM_AUTO:
-		auto_mode = 1;
+		auto_mode = true;
 		break;
 	case QPSK:
 		break;
@@ -751,7 +751,7 @@ static int af9013_set_frontend(struct dvb_frontend *fe)
 		break;
 	default:
 		dev_dbg(&state->i2c->dev, "%s: invalid modulation\n", __func__);
-		auto_mode = 1;
+		auto_mode = true;
 	}
 
 	/* Use HP. How and which case we can switch to LP? */
@@ -759,7 +759,7 @@ static int af9013_set_frontend(struct dvb_frontend *fe)
 
 	switch (c->code_rate_HP) {
 	case FEC_AUTO:
-		auto_mode = 1;
+		auto_mode = true;
 		break;
 	case FEC_1_2:
 		break;
@@ -778,12 +778,12 @@ static int af9013_set_frontend(struct dvb_frontend *fe)
 	default:
 		dev_dbg(&state->i2c->dev, "%s: invalid code_rate_HP\n",
 				__func__);
-		auto_mode = 1;
+		auto_mode = true;
 	}
 
 	switch (c->code_rate_LP) {
 	case FEC_AUTO:
-		auto_mode = 1;
+		auto_mode = true;
 		break;
 	case FEC_1_2:
 		break;
@@ -804,7 +804,7 @@ static int af9013_set_frontend(struct dvb_frontend *fe)
 	default:
 		dev_dbg(&state->i2c->dev, "%s: invalid code_rate_LP\n",
 				__func__);
-		auto_mode = 1;
+		auto_mode = true;
 	}
 
 	switch (c->bandwidth_hz) {

commit 045655a94d7be211e72e9c5a181ced906e5e669a
Author: Fabian Frederick <fabf@skynet.be>
Date:   Tue Jul 8 14:23:01 2014 -0300

    [media] dvb-frontends: remove unnecessary break after goto
    
    Cc: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Fabian Frederick <fabf@skynet.be>
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/drivers/media/dvb-frontends/af9013.c b/drivers/media/dvb-frontends/af9013.c
index fb504f1e9125..ecf6388d2200 100644
--- a/drivers/media/dvb-frontends/af9013.c
+++ b/drivers/media/dvb-frontends/af9013.c
@@ -470,7 +470,6 @@ static int af9013_statistics_snr_result(struct dvb_frontend *fe)
 		break;
 	default:
 		goto err;
-		break;
 	}
 
 	for (i = 0; i < len; i++) {

commit 37ebaf6891ee81687bb558e8375c0712d8264ed8
Author: Mauro Carvalho Chehab <m.chehab@samsung.com>
Date:   Sat Nov 2 05:11:47 2013 -0300

    [media] dvb-frontends: Don't use dynamic static allocation
    
    Dynamic static allocation is evil, as Kernel stack is too low, and
    compilation complains about it on some archs:
            drivers/media/dvb-frontends/af9013.c:77:1: warning: 'af9013_wr_regs_i2c' uses dynamic stack allocation [enabled by default]
            drivers/media/dvb-frontends/af9033.c:188:1: warning: 'af9033_wr_reg_val_tab' uses dynamic stack allocation [enabled by default]
            drivers/media/dvb-frontends/af9033.c:68:1: warning: 'af9033_wr_regs' uses dynamic stack allocation [enabled by default]
            drivers/media/dvb-frontends/bcm3510.c:230:1: warning: 'bcm3510_do_hab_cmd' uses dynamic stack allocation [enabled by default]
            drivers/media/dvb-frontends/cxd2820r_core.c:84:1: warning: 'cxd2820r_rd_regs_i2c.isra.1' uses dynamic stack allocation [enabled by default]
            drivers/media/dvb-frontends/rtl2830.c:56:1: warning: 'rtl2830_wr' uses dynamic stack allocation [enabled by default]
            drivers/media/dvb-frontends/rtl2832.c:187:1: warning: 'rtl2832_wr' uses dynamic stack allocation [enabled by default]
            drivers/media/dvb-frontends/tda10071.c:52:1: warning: 'tda10071_wr_regs' uses dynamic stack allocation [enabled by default]
            drivers/media/dvb-frontends/tda10071.c:84:1: warning: 'tda10071_rd_regs' uses dynamic stack allocation [enabled by default]
    Instead, let's enforce a limit for the buffer. Considering that I2C
    transfers are generally limited, and that devices used on USB has a
    max data length of 64 bytes for the control URBs.
    So, it seem safe to use 64 bytes as the hard limit for all those devices.
     On most cases, the limit is a way lower than that, but this limit
    is small enough to not affect the Kernel stack, and it is a no brain
    limit, as using smaller ones would require to either carefully each
    driver or to take a look on each datasheet.
    
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>
    Reviewed-by: Hans Verkuil <hans.verkuil@cisco.com>
    Reviewed-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/drivers/media/dvb-frontends/af9013.c b/drivers/media/dvb-frontends/af9013.c
index a204f2828820..fb504f1e9125 100644
--- a/drivers/media/dvb-frontends/af9013.c
+++ b/drivers/media/dvb-frontends/af9013.c
@@ -24,6 +24,9 @@
 
 #include "af9013_priv.h"
 
+/* Max transfer size done by I2C transfer functions */
+#define MAX_XFER_SIZE  64
+
 struct af9013_state {
 	struct i2c_adapter *i2c;
 	struct dvb_frontend fe;
@@ -50,16 +53,23 @@ static int af9013_wr_regs_i2c(struct af9013_state *priv, u8 mbox, u16 reg,
 	const u8 *val, int len)
 {
 	int ret;
-	u8 buf[3+len];
+	u8 buf[MAX_XFER_SIZE];
 	struct i2c_msg msg[1] = {
 		{
 			.addr = priv->config.i2c_addr,
 			.flags = 0,
-			.len = sizeof(buf),
+			.len = 3 + len,
 			.buf = buf,
 		}
 	};
 
+	if (3 + len > sizeof(buf)) {
+		dev_warn(&priv->i2c->dev,
+			 "%s: i2c wr reg=%04x: len=%d is too big!\n",
+			 KBUILD_MODNAME, reg, len);
+		return -EINVAL;
+	}
+
 	buf[0] = (reg >> 8) & 0xff;
 	buf[1] = (reg >> 0) & 0xff;
 	buf[2] = mbox;

commit c2c1b4156a447f113ef4d167decce29399c2667c
Author: Peter Senna Tschudin <peter.senna@gmail.com>
Date:   Fri Sep 28 05:37:22 2012 -0300

    [media] drivers/media: Remove unnecessary semicolon
    
    A simplified version of the semantic patch that finds this problem is as
    follows: (http://coccinelle.lip6.fr/)
    // <smpl>
    @r1@
    statement S;
    position p,p1;
    @@
    S@p1;@p
    @script:python r2@
    p << r1.p;
    p1 << r1.p1;
    @@
    if p[0].line != p1[0].line_end:
            cocci.include_match(False)
    @@
    position r1.p;
    @@
    -;@p
    // </smpl>
    
    [mchehab@redhat.com: some hunks got bitroted; applied only the
     ones that succeeds]
    Signed-off-by: Peter Senna Tschudin <peter.senna@gmail.com>
    [crope@iki.fi: For my drivers a8293, af9013, af9015, af9035]
    Acked-by: Antti Palosaari <crope@iki.fi>
    Reviewed-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/dvb-frontends/af9013.c b/drivers/media/dvb-frontends/af9013.c
index e9f04a36577b..a204f2828820 100644
--- a/drivers/media/dvb-frontends/af9013.c
+++ b/drivers/media/dvb-frontends/af9013.c
@@ -241,7 +241,7 @@ static int af9013_set_gpio(struct af9013_state *state, u8 gpio, u8 gpioval)
 				KBUILD_MODNAME, gpio);
 		ret = -EINVAL;
 		goto err;
-	};
+	}
 
 	switch (gpio) {
 	case 0:
@@ -253,7 +253,7 @@ static int af9013_set_gpio(struct af9013_state *state, u8 gpio, u8 gpioval)
 	default:
 		pos = 4;
 		break;
-	};
+	}
 
 	ret = af9013_wr_reg_bits(state, addr, pos, 4, gpioval);
 	if (ret)
@@ -726,7 +726,7 @@ static int af9013_set_frontend(struct dvb_frontend *fe)
 	default:
 		dev_dbg(&state->i2c->dev, "%s: invalid hierarchy\n", __func__);
 		auto_mode = 1;
-	};
+	}
 
 	switch (c->modulation) {
 	case QAM_AUTO:

commit 8df379c5a425d127216195861b88f981530e7581
Author: Antti Palosaari <crope@iki.fi>
Date:   Wed Sep 12 20:23:43 2012 -0300

    [media] af9013: use Kernel dev_foo() logging
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/dvb-frontends/af9013.c b/drivers/media/dvb-frontends/af9013.c
index b30ca2da1d58..e9f04a36577b 100644
--- a/drivers/media/dvb-frontends/af9013.c
+++ b/drivers/media/dvb-frontends/af9013.c
@@ -24,10 +24,6 @@
 
 #include "af9013_priv.h"
 
-int af9013_debug;
-module_param_named(debug, af9013_debug, int, 0644);
-MODULE_PARM_DESC(debug, "Turn on/off frontend debugging (default:off).");
-
 struct af9013_state {
 	struct i2c_adapter *i2c;
 	struct dvb_frontend fe;
@@ -73,7 +69,8 @@ static int af9013_wr_regs_i2c(struct af9013_state *priv, u8 mbox, u16 reg,
 	if (ret == 1) {
 		ret = 0;
 	} else {
-		warn("i2c wr failed=%d reg=%04x len=%d", ret, reg, len);
+		dev_warn(&priv->i2c->dev, "%s: i2c wr failed=%d reg=%04x " \
+				"len=%d\n", KBUILD_MODNAME, ret, reg, len);
 		ret = -EREMOTEIO;
 	}
 	return ret;
@@ -107,7 +104,8 @@ static int af9013_rd_regs_i2c(struct af9013_state *priv, u8 mbox, u16 reg,
 	if (ret == 2) {
 		ret = 0;
 	} else {
-		warn("i2c rd failed=%d reg=%04x len=%d", ret, reg, len);
+		dev_warn(&priv->i2c->dev, "%s: i2c rd failed=%d reg=%04x " \
+				"len=%d\n", KBUILD_MODNAME, ret, reg, len);
 		ret = -EREMOTEIO;
 	}
 	return ret;
@@ -220,7 +218,8 @@ static int af9013_set_gpio(struct af9013_state *state, u8 gpio, u8 gpioval)
 	u8 pos;
 	u16 addr;
 
-	dbg("%s: gpio=%d gpioval=%02x", __func__, gpio, gpioval);
+	dev_dbg(&state->i2c->dev, "%s: gpio=%d gpioval=%02x\n",
+			__func__, gpio, gpioval);
 
 	/*
 	 * GPIO0 & GPIO1 0xd735
@@ -238,7 +237,8 @@ static int af9013_set_gpio(struct af9013_state *state, u8 gpio, u8 gpioval)
 		break;
 
 	default:
-		err("invalid gpio:%d\n", gpio);
+		dev_err(&state->i2c->dev, "%s: invalid gpio=%d\n",
+				KBUILD_MODNAME, gpio);
 		ret = -EINVAL;
 		goto err;
 	};
@@ -261,15 +261,15 @@ static int af9013_set_gpio(struct af9013_state *state, u8 gpio, u8 gpioval)
 
 	return ret;
 err:
-	dbg("%s: failed=%d", __func__, ret);
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
 	return ret;
 }
 
-static u32 af913_div(u32 a, u32 b, u32 x)
+static u32 af9013_div(struct af9013_state *state, u32 a, u32 b, u32 x)
 {
 	u32 r = 0, c = 0, i;
 
-	dbg("%s: a=%d b=%d x=%d", __func__, a, b, x);
+	dev_dbg(&state->i2c->dev, "%s: a=%d b=%d x=%d\n", __func__, a, b, x);
 
 	if (a > b) {
 		c = a / b;
@@ -286,7 +286,9 @@ static u32 af913_div(u32 a, u32 b, u32 x)
 	}
 	r = (c << (u32)x) + r;
 
-	dbg("%s: a=%d b=%d x=%d r=%x", __func__, a, b, x, r);
+	dev_dbg(&state->i2c->dev, "%s: a=%d b=%d x=%d r=%d r=%x\n",
+			__func__, a, b, x, r, r);
+
 	return r;
 }
 
@@ -295,7 +297,7 @@ static int af9013_power_ctrl(struct af9013_state *state, u8 onoff)
 	int ret, i;
 	u8 tmp;
 
-	dbg("%s: onoff=%d", __func__, onoff);
+	dev_dbg(&state->i2c->dev, "%s: onoff=%d\n", __func__, onoff);
 
 	/* enable reset */
 	ret = af9013_wr_reg_bits(state, 0xd417, 4, 1, 1);
@@ -340,7 +342,7 @@ static int af9013_power_ctrl(struct af9013_state *state, u8 onoff)
 
 	return ret;
 err:
-	dbg("%s: failed=%d", __func__, ret);
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
 	return ret;
 }
 
@@ -349,7 +351,7 @@ static int af9013_statistics_ber_unc_start(struct dvb_frontend *fe)
 	struct af9013_state *state = fe->demodulator_priv;
 	int ret;
 
-	dbg("%s", __func__);
+	dev_dbg(&state->i2c->dev, "%s:\n", __func__);
 
 	/* reset and start BER counter */
 	ret = af9013_wr_reg_bits(state, 0xd391, 4, 1, 1);
@@ -358,7 +360,7 @@ static int af9013_statistics_ber_unc_start(struct dvb_frontend *fe)
 
 	return ret;
 err:
-	dbg("%s: failed=%d", __func__, ret);
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
 	return ret;
 }
 
@@ -368,7 +370,7 @@ static int af9013_statistics_ber_unc_result(struct dvb_frontend *fe)
 	int ret;
 	u8 buf[5];
 
-	dbg("%s", __func__);
+	dev_dbg(&state->i2c->dev, "%s:\n", __func__);
 
 	/* check if error bit count is ready */
 	ret = af9013_rd_reg_bits(state, 0xd391, 4, 1, &buf[0]);
@@ -376,7 +378,7 @@ static int af9013_statistics_ber_unc_result(struct dvb_frontend *fe)
 		goto err;
 
 	if (!buf[0]) {
-		dbg("%s: not ready", __func__);
+		dev_dbg(&state->i2c->dev, "%s: not ready\n", __func__);
 		return 0;
 	}
 
@@ -389,7 +391,7 @@ static int af9013_statistics_ber_unc_result(struct dvb_frontend *fe)
 
 	return ret;
 err:
-	dbg("%s: failed=%d", __func__, ret);
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
 	return ret;
 }
 
@@ -398,7 +400,7 @@ static int af9013_statistics_snr_start(struct dvb_frontend *fe)
 	struct af9013_state *state = fe->demodulator_priv;
 	int ret;
 
-	dbg("%s", __func__);
+	dev_dbg(&state->i2c->dev, "%s:\n", __func__);
 
 	/* start SNR meas */
 	ret = af9013_wr_reg_bits(state, 0xd2e1, 3, 1, 1);
@@ -407,7 +409,7 @@ static int af9013_statistics_snr_start(struct dvb_frontend *fe)
 
 	return ret;
 err:
-	dbg("%s: failed=%d", __func__, ret);
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
 	return ret;
 }
 
@@ -419,7 +421,7 @@ static int af9013_statistics_snr_result(struct dvb_frontend *fe)
 	u32 snr_val;
 	const struct af9013_snr *uninitialized_var(snr_lut);
 
-	dbg("%s", __func__);
+	dev_dbg(&state->i2c->dev, "%s:\n", __func__);
 
 	/* check if SNR ready */
 	ret = af9013_rd_reg_bits(state, 0xd2e1, 3, 1, &tmp);
@@ -427,7 +429,7 @@ static int af9013_statistics_snr_result(struct dvb_frontend *fe)
 		goto err;
 
 	if (!tmp) {
-		dbg("%s: not ready", __func__);
+		dev_dbg(&state->i2c->dev, "%s: not ready\n", __func__);
 		return 0;
 	}
 
@@ -471,7 +473,7 @@ static int af9013_statistics_snr_result(struct dvb_frontend *fe)
 
 	return ret;
 err:
-	dbg("%s: failed=%d", __func__, ret);
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
 	return ret;
 }
 
@@ -482,7 +484,7 @@ static int af9013_statistics_signal_strength(struct dvb_frontend *fe)
 	u8 buf[2], rf_gain, if_gain;
 	int signal_strength;
 
-	dbg("%s", __func__);
+	dev_dbg(&state->i2c->dev, "%s:\n", __func__);
 
 	if (!state->signal_strength_en)
 		return 0;
@@ -508,7 +510,7 @@ static int af9013_statistics_signal_strength(struct dvb_frontend *fe)
 
 	return ret;
 err:
-	dbg("%s: failed=%d", __func__, ret);
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
 	return ret;
 }
 
@@ -578,8 +580,8 @@ static int af9013_set_frontend(struct dvb_frontend *fe)
 	u8 buf[6];
 	u32 if_frequency, freq_cw;
 
-	dbg("%s: frequency=%d bandwidth_hz=%d", __func__,
-		c->frequency, c->bandwidth_hz);
+	dev_dbg(&state->i2c->dev, "%s: frequency=%d bandwidth_hz=%d\n",
+			__func__, c->frequency, c->bandwidth_hz);
 
 	/* program tuner */
 	if (fe->ops.tuner_ops.set_params)
@@ -606,7 +608,8 @@ static int af9013_set_frontend(struct dvb_frontend *fe)
 		else
 			if_frequency = state->config.if_frequency;
 
-		dbg("%s: if_frequency=%d", __func__, if_frequency);
+		dev_dbg(&state->i2c->dev, "%s: if_frequency=%d\n",
+				__func__, if_frequency);
 
 		sampling_freq = if_frequency;
 
@@ -620,7 +623,8 @@ static int af9013_set_frontend(struct dvb_frontend *fe)
 			spec_inv = !state->config.spec_inv;
 		}
 
-		freq_cw = af913_div(sampling_freq, state->config.clock, 23);
+		freq_cw = af9013_div(state, sampling_freq, state->config.clock,
+				23);
 
 		if (spec_inv)
 			freq_cw = 0x800000 - freq_cw;
@@ -678,7 +682,8 @@ static int af9013_set_frontend(struct dvb_frontend *fe)
 		buf[0] |= (1 << 0);
 		break;
 	default:
-		dbg("%s: invalid transmission_mode", __func__);
+		dev_dbg(&state->i2c->dev, "%s: invalid transmission_mode\n",
+				__func__);
 		auto_mode = 1;
 	}
 
@@ -698,7 +703,8 @@ static int af9013_set_frontend(struct dvb_frontend *fe)
 		buf[0] |= (3 << 2);
 		break;
 	default:
-		dbg("%s: invalid guard_interval", __func__);
+		dev_dbg(&state->i2c->dev, "%s: invalid guard_interval\n",
+				__func__);
 		auto_mode = 1;
 	}
 
@@ -718,7 +724,7 @@ static int af9013_set_frontend(struct dvb_frontend *fe)
 		buf[0] |= (3 << 4);
 		break;
 	default:
-		dbg("%s: invalid hierarchy", __func__);
+		dev_dbg(&state->i2c->dev, "%s: invalid hierarchy\n", __func__);
 		auto_mode = 1;
 	};
 
@@ -735,7 +741,7 @@ static int af9013_set_frontend(struct dvb_frontend *fe)
 		buf[1] |= (2 << 6);
 		break;
 	default:
-		dbg("%s: invalid modulation", __func__);
+		dev_dbg(&state->i2c->dev, "%s: invalid modulation\n", __func__);
 		auto_mode = 1;
 	}
 
@@ -761,7 +767,8 @@ static int af9013_set_frontend(struct dvb_frontend *fe)
 		buf[2] |= (4 << 0);
 		break;
 	default:
-		dbg("%s: invalid code_rate_HP", __func__);
+		dev_dbg(&state->i2c->dev, "%s: invalid code_rate_HP\n",
+				__func__);
 		auto_mode = 1;
 	}
 
@@ -786,7 +793,8 @@ static int af9013_set_frontend(struct dvb_frontend *fe)
 	case FEC_NONE:
 		break;
 	default:
-		dbg("%s: invalid code_rate_LP", __func__);
+		dev_dbg(&state->i2c->dev, "%s: invalid code_rate_LP\n",
+				__func__);
 		auto_mode = 1;
 	}
 
@@ -800,7 +808,8 @@ static int af9013_set_frontend(struct dvb_frontend *fe)
 		buf[1] |= (2 << 2);
 		break;
 	default:
-		dbg("%s: invalid bandwidth_hz", __func__);
+		dev_dbg(&state->i2c->dev, "%s: invalid bandwidth_hz\n",
+				__func__);
 		ret = -EINVAL;
 		goto err;
 	}
@@ -815,7 +824,7 @@ static int af9013_set_frontend(struct dvb_frontend *fe)
 		if (ret)
 			goto err;
 
-		dbg("%s: auto params", __func__);
+		dev_dbg(&state->i2c->dev, "%s: auto params\n", __func__);
 	} else {
 		/* set easy mode flag */
 		ret = af9013_wr_reg(state, 0xaefd, 1);
@@ -826,7 +835,7 @@ static int af9013_set_frontend(struct dvb_frontend *fe)
 		if (ret)
 			goto err;
 
-		dbg("%s: manual params", __func__);
+		dev_dbg(&state->i2c->dev, "%s: manual params\n", __func__);
 	}
 
 	/* tune */
@@ -840,7 +849,7 @@ static int af9013_set_frontend(struct dvb_frontend *fe)
 
 	return ret;
 err:
-	dbg("%s: failed=%d", __func__, ret);
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
 	return ret;
 }
 
@@ -851,7 +860,7 @@ static int af9013_get_frontend(struct dvb_frontend *fe)
 	int ret;
 	u8 buf[3];
 
-	dbg("%s", __func__);
+	dev_dbg(&state->i2c->dev, "%s:\n", __func__);
 
 	ret = af9013_rd_regs(state, 0xd3c0, buf, 3);
 	if (ret)
@@ -957,7 +966,7 @@ static int af9013_get_frontend(struct dvb_frontend *fe)
 
 	return ret;
 err:
-	dbg("%s: failed=%d", __func__, ret);
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
 	return ret;
 }
 
@@ -1007,7 +1016,7 @@ static int af9013_read_status(struct dvb_frontend *fe, fe_status_t *status)
 
 	return ret;
 err:
-	dbg("%s: failed=%d", __func__, ret);
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
 	return ret;
 }
 
@@ -1047,7 +1056,7 @@ static int af9013_init(struct dvb_frontend *fe)
 	u32 adc_cw;
 	const struct af9013_reg_bit *init;
 
-	dbg("%s", __func__);
+	dev_dbg(&state->i2c->dev, "%s:\n", __func__);
 
 	/* power on */
 	ret = af9013_power_ctrl(state, 1);
@@ -1079,11 +1088,12 @@ static int af9013_init(struct dvb_frontend *fe)
 		tmp = 3;
 		break;
 	default:
-		err("invalid clock");
+		dev_err(&state->i2c->dev, "%s: invalid clock\n",
+				KBUILD_MODNAME);
 		return -EINVAL;
 	}
 
-	adc_cw = af913_div(state->config.clock, 1000000ul, 19);
+	adc_cw = af9013_div(state, state->config.clock, 1000000ul, 19);
 	buf[0] = (adc_cw >>  0) & 0xff;
 	buf[1] = (adc_cw >>  8) & 0xff;
 	buf[2] = (adc_cw >> 16) & 0xff;
@@ -1139,7 +1149,7 @@ static int af9013_init(struct dvb_frontend *fe)
 		goto err;
 
 	/* load OFSM settings */
-	dbg("%s: load ofsm settings", __func__);
+	dev_dbg(&state->i2c->dev, "%s: load ofsm settings\n", __func__);
 	len = ARRAY_SIZE(ofsm_init);
 	init = ofsm_init;
 	for (i = 0; i < len; i++) {
@@ -1150,7 +1160,8 @@ static int af9013_init(struct dvb_frontend *fe)
 	}
 
 	/* load tuner specific settings */
-	dbg("%s: load tuner specific settings", __func__);
+	dev_dbg(&state->i2c->dev, "%s: load tuner specific settings\n",
+			__func__);
 	switch (state->config.tuner) {
 	case AF9013_TUNER_MXL5003D:
 		len = ARRAY_SIZE(tuner_init_mxl5003d);
@@ -1261,7 +1272,7 @@ static int af9013_init(struct dvb_frontend *fe)
 
 	return ret;
 err:
-	dbg("%s: failed=%d", __func__, ret);
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
 	return ret;
 }
 
@@ -1270,7 +1281,7 @@ static int af9013_sleep(struct dvb_frontend *fe)
 	struct af9013_state *state = fe->demodulator_priv;
 	int ret;
 
-	dbg("%s", __func__);
+	dev_dbg(&state->i2c->dev, "%s:\n", __func__);
 
 	/* stop statistics polling */
 	cancel_delayed_work_sync(&state->statistics_work);
@@ -1287,7 +1298,7 @@ static int af9013_sleep(struct dvb_frontend *fe)
 
 	return ret;
 err:
-	dbg("%s: failed=%d", __func__, ret);
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
 	return ret;
 }
 
@@ -1296,7 +1307,7 @@ static int af9013_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)
 	int ret;
 	struct af9013_state *state = fe->demodulator_priv;
 
-	dbg("%s: enable=%d", __func__, enable);
+	dev_dbg(&state->i2c->dev, "%s: enable=%d\n", __func__, enable);
 
 	/* gate already open or close */
 	if (state->i2c_gate_state == enable)
@@ -1313,7 +1324,7 @@ static int af9013_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)
 
 	return ret;
 err:
-	dbg("%s: failed=%d", __func__, ret);
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
 	return ret;
 }
 
@@ -1340,25 +1351,28 @@ static int af9013_download_firmware(struct af9013_state *state)
 	if (ret)
 		goto err;
 	else
-		dbg("%s: firmware status=%02x", __func__, val);
+		dev_dbg(&state->i2c->dev, "%s: firmware status=%02x\n",
+				__func__, val);
 
 	if (val == 0x0c) /* fw is running, no need for download */
 		goto exit;
 
-	info("found a '%s' in cold state, will try to load a firmware",
-		af9013_ops.info.name);
+	dev_info(&state->i2c->dev, "%s: found a '%s' in cold state, will try " \
+			"to load a firmware\n",
+			KBUILD_MODNAME, af9013_ops.info.name);
 
 	/* request the firmware, this will block and timeout */
 	ret = request_firmware(&fw, fw_file, state->i2c->dev.parent);
 	if (ret) {
-		err("did not find the firmware file. (%s) "
-			"Please see linux/Documentation/dvb/ for more details" \
-			" on firmware-problems. (%d)",
-			fw_file, ret);
+		dev_info(&state->i2c->dev, "%s: did not find the firmware " \
+			"file. (%s) Please see linux/Documentation/dvb/ for " \
+			"more details on firmware-problems. (%d)\n",
+			KBUILD_MODNAME, fw_file, ret);
 		goto err;
 	}
 
-	info("downloading firmware from file '%s'", fw_file);
+	dev_info(&state->i2c->dev, "%s: downloading firmware from file '%s'\n",
+			KBUILD_MODNAME, fw_file);
 
 	/* calc checksum */
 	for (i = 0; i < fw->size; i++)
@@ -1386,7 +1400,9 @@ static int af9013_download_firmware(struct af9013_state *state)
 			FW_ADDR + fw->size - remaining,
 			(u8 *) &fw->data[fw->size - remaining], len);
 		if (ret) {
-			err("firmware download failed:%d", ret);
+			dev_err(&state->i2c->dev,
+					"%s: firmware download failed=%d\n",
+					KBUILD_MODNAME, ret);
 			goto err_release;
 		}
 	}
@@ -1404,17 +1420,20 @@ static int af9013_download_firmware(struct af9013_state *state)
 		if (ret)
 			goto err_release;
 
-		dbg("%s: firmware status=%02x", __func__, val);
+		dev_dbg(&state->i2c->dev, "%s: firmware status=%02x\n",
+				__func__, val);
 
 		if (val == 0x0c || val == 0x04) /* success or fail */
 			break;
 	}
 
 	if (val == 0x04) {
-		err("firmware did not run");
+		dev_err(&state->i2c->dev, "%s: firmware did not run\n",
+				KBUILD_MODNAME);
 		ret = -ENODEV;
 	} else if (val != 0x0c) {
-		err("firmware boot timeout");
+		dev_err(&state->i2c->dev, "%s: firmware boot timeout\n",
+				KBUILD_MODNAME);
 		ret = -ENODEV;
 	}
 
@@ -1423,7 +1442,8 @@ static int af9013_download_firmware(struct af9013_state *state)
 err:
 exit:
 	if (!ret)
-		info("found a '%s' in warm state.", af9013_ops.info.name);
+		dev_info(&state->i2c->dev, "%s: found a '%s' in warm state\n",
+				KBUILD_MODNAME, af9013_ops.info.name);
 	return ret;
 }
 
@@ -1455,7 +1475,8 @@ struct dvb_frontend *af9013_attach(const struct af9013_config *config,
 	if (ret)
 		goto err;
 
-	info("firmware version %d.%d.%d.%d", buf[0], buf[1], buf[2], buf[3]);
+	dev_info(&state->i2c->dev, "%s: firmware version %d.%d.%d.%d\n",
+			KBUILD_MODNAME, buf[0], buf[1], buf[2], buf[3]);
 
 	/* set GPIOs */
 	for (i = 0; i < sizeof(state->config.gpio); i++) {

commit a71103a6adc10d7003a09ecf1de5532967d6bee8
Author: Antti Palosaari <crope@iki.fi>
Date:   Wed Sep 12 11:37:28 2012 -0300

    [media] af9013: declare MODULE_FIRMWARE
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/dvb-frontends/af9013.c b/drivers/media/dvb-frontends/af9013.c
index 2dac31491755..b30ca2da1d58 100644
--- a/drivers/media/dvb-frontends/af9013.c
+++ b/drivers/media/dvb-frontends/af9013.c
@@ -1332,7 +1332,7 @@ static int af9013_download_firmware(struct af9013_state *state)
 	u16 checksum = 0;
 	u8 val;
 	u8 fw_params[4];
-	u8 *fw_file = AF9013_DEFAULT_FIRMWARE;
+	u8 *fw_file = AF9013_FIRMWARE;
 
 	msleep(100);
 	/* check whether firmware is already running */
@@ -1524,3 +1524,4 @@ static struct dvb_frontend_ops af9013_ops = {
 MODULE_AUTHOR("Antti Palosaari <crope@iki.fi>");
 MODULE_DESCRIPTION("Afatech AF9013 DVB-T demodulator driver");
 MODULE_LICENSE("GPL");
+MODULE_FIRMWARE(AF9013_FIRMWARE);

commit ab2e06acb4ae0293add73608a49512530758edf6
Author: Antti Palosaari <crope@iki.fi>
Date:   Sun Sep 2 18:47:25 2012 -0300

    [media] af9013: add debug for IF frequency
    
    Used IF frequency is one of the most important parameter to know.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/dvb-frontends/af9013.c b/drivers/media/dvb-frontends/af9013.c
index 5bc570d77846..2dac31491755 100644
--- a/drivers/media/dvb-frontends/af9013.c
+++ b/drivers/media/dvb-frontends/af9013.c
@@ -606,6 +606,8 @@ static int af9013_set_frontend(struct dvb_frontend *fe)
 		else
 			if_frequency = state->config.if_frequency;
 
+		dbg("%s: if_frequency=%d", __func__, if_frequency);
+
 		sampling_freq = if_frequency;
 
 		while (sampling_freq > (state->config.clock / 2))

commit 9a0bf528b4d66b605f02634236da085595c22101
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Mon Aug 13 23:13:41 2012 -0300

    [media] move the dvb/frontends to drivers/media/dvb-frontends
    
    Raise the DVB frontends one level up, as the intention is to remove
    the drivers/media/dvb directory.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/dvb-frontends/af9013.c b/drivers/media/dvb-frontends/af9013.c
new file mode 100644
index 000000000000..5bc570d77846
--- /dev/null
+++ b/drivers/media/dvb-frontends/af9013.c
@@ -0,0 +1,1524 @@
+/*
+ * Afatech AF9013 demodulator driver
+ *
+ * Copyright (C) 2007 Antti Palosaari <crope@iki.fi>
+ * Copyright (C) 2011 Antti Palosaari <crope@iki.fi>
+ *
+ * Thanks to Afatech who kindly provided information.
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License
+ *    along with this program; if not, write to the Free Software
+ *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#include "af9013_priv.h"
+
+int af9013_debug;
+module_param_named(debug, af9013_debug, int, 0644);
+MODULE_PARM_DESC(debug, "Turn on/off frontend debugging (default:off).");
+
+struct af9013_state {
+	struct i2c_adapter *i2c;
+	struct dvb_frontend fe;
+	struct af9013_config config;
+
+	/* tuner/demod RF and IF AGC limits used for signal strength calc */
+	u8 signal_strength_en, rf_50, rf_80, if_50, if_80;
+	u16 signal_strength;
+	u32 ber;
+	u32 ucblocks;
+	u16 snr;
+	u32 bandwidth_hz;
+	fe_status_t fe_status;
+	unsigned long set_frontend_jiffies;
+	unsigned long read_status_jiffies;
+	bool first_tune;
+	bool i2c_gate_state;
+	unsigned int statistics_step:3;
+	struct delayed_work statistics_work;
+};
+
+/* write multiple registers */
+static int af9013_wr_regs_i2c(struct af9013_state *priv, u8 mbox, u16 reg,
+	const u8 *val, int len)
+{
+	int ret;
+	u8 buf[3+len];
+	struct i2c_msg msg[1] = {
+		{
+			.addr = priv->config.i2c_addr,
+			.flags = 0,
+			.len = sizeof(buf),
+			.buf = buf,
+		}
+	};
+
+	buf[0] = (reg >> 8) & 0xff;
+	buf[1] = (reg >> 0) & 0xff;
+	buf[2] = mbox;
+	memcpy(&buf[3], val, len);
+
+	ret = i2c_transfer(priv->i2c, msg, 1);
+	if (ret == 1) {
+		ret = 0;
+	} else {
+		warn("i2c wr failed=%d reg=%04x len=%d", ret, reg, len);
+		ret = -EREMOTEIO;
+	}
+	return ret;
+}
+
+/* read multiple registers */
+static int af9013_rd_regs_i2c(struct af9013_state *priv, u8 mbox, u16 reg,
+	u8 *val, int len)
+{
+	int ret;
+	u8 buf[3];
+	struct i2c_msg msg[2] = {
+		{
+			.addr = priv->config.i2c_addr,
+			.flags = 0,
+			.len = 3,
+			.buf = buf,
+		}, {
+			.addr = priv->config.i2c_addr,
+			.flags = I2C_M_RD,
+			.len = len,
+			.buf = val,
+		}
+	};
+
+	buf[0] = (reg >> 8) & 0xff;
+	buf[1] = (reg >> 0) & 0xff;
+	buf[2] = mbox;
+
+	ret = i2c_transfer(priv->i2c, msg, 2);
+	if (ret == 2) {
+		ret = 0;
+	} else {
+		warn("i2c rd failed=%d reg=%04x len=%d", ret, reg, len);
+		ret = -EREMOTEIO;
+	}
+	return ret;
+}
+
+/* write multiple registers */
+static int af9013_wr_regs(struct af9013_state *priv, u16 reg, const u8 *val,
+	int len)
+{
+	int ret, i;
+	u8 mbox = (0 << 7)|(0 << 6)|(1 << 1)|(1 << 0);
+
+	if ((priv->config.ts_mode == AF9013_TS_USB) &&
+		((reg & 0xff00) != 0xff00) && ((reg & 0xff00) != 0xae00)) {
+		mbox |= ((len - 1) << 2);
+		ret = af9013_wr_regs_i2c(priv, mbox, reg, val, len);
+	} else {
+		for (i = 0; i < len; i++) {
+			ret = af9013_wr_regs_i2c(priv, mbox, reg+i, val+i, 1);
+			if (ret)
+				goto err;
+		}
+	}
+
+err:
+	return 0;
+}
+
+/* read multiple registers */
+static int af9013_rd_regs(struct af9013_state *priv, u16 reg, u8 *val, int len)
+{
+	int ret, i;
+	u8 mbox = (0 << 7)|(0 << 6)|(1 << 1)|(0 << 0);
+
+	if ((priv->config.ts_mode == AF9013_TS_USB) &&
+		((reg & 0xff00) != 0xff00) && ((reg & 0xff00) != 0xae00)) {
+		mbox |= ((len - 1) << 2);
+		ret = af9013_rd_regs_i2c(priv, mbox, reg, val, len);
+	} else {
+		for (i = 0; i < len; i++) {
+			ret = af9013_rd_regs_i2c(priv, mbox, reg+i, val+i, 1);
+			if (ret)
+				goto err;
+		}
+	}
+
+err:
+	return 0;
+}
+
+/* write single register */
+static int af9013_wr_reg(struct af9013_state *priv, u16 reg, u8 val)
+{
+	return af9013_wr_regs(priv, reg, &val, 1);
+}
+
+/* read single register */
+static int af9013_rd_reg(struct af9013_state *priv, u16 reg, u8 *val)
+{
+	return af9013_rd_regs(priv, reg, val, 1);
+}
+
+static int af9013_write_ofsm_regs(struct af9013_state *state, u16 reg, u8 *val,
+	u8 len)
+{
+	u8 mbox = (1 << 7)|(1 << 6)|((len - 1) << 2)|(1 << 1)|(1 << 0);
+	return af9013_wr_regs_i2c(state, mbox, reg, val, len);
+}
+
+static int af9013_wr_reg_bits(struct af9013_state *state, u16 reg, int pos,
+	int len, u8 val)
+{
+	int ret;
+	u8 tmp, mask;
+
+	/* no need for read if whole reg is written */
+	if (len != 8) {
+		ret = af9013_rd_reg(state, reg, &tmp);
+		if (ret)
+			return ret;
+
+		mask = (0xff >> (8 - len)) << pos;
+		val <<= pos;
+		tmp &= ~mask;
+		val |= tmp;
+	}
+
+	return af9013_wr_reg(state, reg, val);
+}
+
+static int af9013_rd_reg_bits(struct af9013_state *state, u16 reg, int pos,
+	int len, u8 *val)
+{
+	int ret;
+	u8 tmp;
+
+	ret = af9013_rd_reg(state, reg, &tmp);
+	if (ret)
+		return ret;
+
+	*val = (tmp >> pos);
+	*val &= (0xff >> (8 - len));
+
+	return 0;
+}
+
+static int af9013_set_gpio(struct af9013_state *state, u8 gpio, u8 gpioval)
+{
+	int ret;
+	u8 pos;
+	u16 addr;
+
+	dbg("%s: gpio=%d gpioval=%02x", __func__, gpio, gpioval);
+
+	/*
+	 * GPIO0 & GPIO1 0xd735
+	 * GPIO2 & GPIO3 0xd736
+	 */
+
+	switch (gpio) {
+	case 0:
+	case 1:
+		addr = 0xd735;
+		break;
+	case 2:
+	case 3:
+		addr = 0xd736;
+		break;
+
+	default:
+		err("invalid gpio:%d\n", gpio);
+		ret = -EINVAL;
+		goto err;
+	};
+
+	switch (gpio) {
+	case 0:
+	case 2:
+		pos = 0;
+		break;
+	case 1:
+	case 3:
+	default:
+		pos = 4;
+		break;
+	};
+
+	ret = af9013_wr_reg_bits(state, addr, pos, 4, gpioval);
+	if (ret)
+		goto err;
+
+	return ret;
+err:
+	dbg("%s: failed=%d", __func__, ret);
+	return ret;
+}
+
+static u32 af913_div(u32 a, u32 b, u32 x)
+{
+	u32 r = 0, c = 0, i;
+
+	dbg("%s: a=%d b=%d x=%d", __func__, a, b, x);
+
+	if (a > b) {
+		c = a / b;
+		a = a - c * b;
+	}
+
+	for (i = 0; i < x; i++) {
+		if (a >= b) {
+			r += 1;
+			a -= b;
+		}
+		a <<= 1;
+		r <<= 1;
+	}
+	r = (c << (u32)x) + r;
+
+	dbg("%s: a=%d b=%d x=%d r=%x", __func__, a, b, x, r);
+	return r;
+}
+
+static int af9013_power_ctrl(struct af9013_state *state, u8 onoff)
+{
+	int ret, i;
+	u8 tmp;
+
+	dbg("%s: onoff=%d", __func__, onoff);
+
+	/* enable reset */
+	ret = af9013_wr_reg_bits(state, 0xd417, 4, 1, 1);
+	if (ret)
+		goto err;
+
+	/* start reset mechanism */
+	ret = af9013_wr_reg(state, 0xaeff, 1);
+	if (ret)
+		goto err;
+
+	/* wait reset performs */
+	for (i = 0; i < 150; i++) {
+		ret = af9013_rd_reg_bits(state, 0xd417, 1, 1, &tmp);
+		if (ret)
+			goto err;
+
+		if (tmp)
+			break; /* reset done */
+
+		usleep_range(5000, 25000);
+	}
+
+	if (!tmp)
+		return -ETIMEDOUT;
+
+	if (onoff) {
+		/* clear reset */
+		ret = af9013_wr_reg_bits(state, 0xd417, 1, 1, 0);
+		if (ret)
+			goto err;
+
+		/* disable reset */
+		ret = af9013_wr_reg_bits(state, 0xd417, 4, 1, 0);
+
+		/* power on */
+		ret = af9013_wr_reg_bits(state, 0xd73a, 3, 1, 0);
+	} else {
+		/* power off */
+		ret = af9013_wr_reg_bits(state, 0xd73a, 3, 1, 1);
+	}
+
+	return ret;
+err:
+	dbg("%s: failed=%d", __func__, ret);
+	return ret;
+}
+
+static int af9013_statistics_ber_unc_start(struct dvb_frontend *fe)
+{
+	struct af9013_state *state = fe->demodulator_priv;
+	int ret;
+
+	dbg("%s", __func__);
+
+	/* reset and start BER counter */
+	ret = af9013_wr_reg_bits(state, 0xd391, 4, 1, 1);
+	if (ret)
+		goto err;
+
+	return ret;
+err:
+	dbg("%s: failed=%d", __func__, ret);
+	return ret;
+}
+
+static int af9013_statistics_ber_unc_result(struct dvb_frontend *fe)
+{
+	struct af9013_state *state = fe->demodulator_priv;
+	int ret;
+	u8 buf[5];
+
+	dbg("%s", __func__);
+
+	/* check if error bit count is ready */
+	ret = af9013_rd_reg_bits(state, 0xd391, 4, 1, &buf[0]);
+	if (ret)
+		goto err;
+
+	if (!buf[0]) {
+		dbg("%s: not ready", __func__);
+		return 0;
+	}
+
+	ret = af9013_rd_regs(state, 0xd387, buf, 5);
+	if (ret)
+		goto err;
+
+	state->ber = (buf[2] << 16) | (buf[1] << 8) | buf[0];
+	state->ucblocks += (buf[4] << 8) | buf[3];
+
+	return ret;
+err:
+	dbg("%s: failed=%d", __func__, ret);
+	return ret;
+}
+
+static int af9013_statistics_snr_start(struct dvb_frontend *fe)
+{
+	struct af9013_state *state = fe->demodulator_priv;
+	int ret;
+
+	dbg("%s", __func__);
+
+	/* start SNR meas */
+	ret = af9013_wr_reg_bits(state, 0xd2e1, 3, 1, 1);
+	if (ret)
+		goto err;
+
+	return ret;
+err:
+	dbg("%s: failed=%d", __func__, ret);
+	return ret;
+}
+
+static int af9013_statistics_snr_result(struct dvb_frontend *fe)
+{
+	struct af9013_state *state = fe->demodulator_priv;
+	int ret, i, len;
+	u8 buf[3], tmp;
+	u32 snr_val;
+	const struct af9013_snr *uninitialized_var(snr_lut);
+
+	dbg("%s", __func__);
+
+	/* check if SNR ready */
+	ret = af9013_rd_reg_bits(state, 0xd2e1, 3, 1, &tmp);
+	if (ret)
+		goto err;
+
+	if (!tmp) {
+		dbg("%s: not ready", __func__);
+		return 0;
+	}
+
+	/* read value */
+	ret = af9013_rd_regs(state, 0xd2e3, buf, 3);
+	if (ret)
+		goto err;
+
+	snr_val = (buf[2] << 16) | (buf[1] << 8) | buf[0];
+
+	/* read current modulation */
+	ret = af9013_rd_reg(state, 0xd3c1, &tmp);
+	if (ret)
+		goto err;
+
+	switch ((tmp >> 6) & 3) {
+	case 0:
+		len = ARRAY_SIZE(qpsk_snr_lut);
+		snr_lut = qpsk_snr_lut;
+		break;
+	case 1:
+		len = ARRAY_SIZE(qam16_snr_lut);
+		snr_lut = qam16_snr_lut;
+		break;
+	case 2:
+		len = ARRAY_SIZE(qam64_snr_lut);
+		snr_lut = qam64_snr_lut;
+		break;
+	default:
+		goto err;
+		break;
+	}
+
+	for (i = 0; i < len; i++) {
+		tmp = snr_lut[i].snr;
+
+		if (snr_val < snr_lut[i].val)
+			break;
+	}
+	state->snr = tmp * 10; /* dB/10 */
+
+	return ret;
+err:
+	dbg("%s: failed=%d", __func__, ret);
+	return ret;
+}
+
+static int af9013_statistics_signal_strength(struct dvb_frontend *fe)
+{
+	struct af9013_state *state = fe->demodulator_priv;
+	int ret = 0;
+	u8 buf[2], rf_gain, if_gain;
+	int signal_strength;
+
+	dbg("%s", __func__);
+
+	if (!state->signal_strength_en)
+		return 0;
+
+	ret = af9013_rd_regs(state, 0xd07c, buf, 2);
+	if (ret)
+		goto err;
+
+	rf_gain = buf[0];
+	if_gain = buf[1];
+
+	signal_strength = (0xffff / \
+		(9 * (state->rf_50 + state->if_50) - \
+		11 * (state->rf_80 + state->if_80))) * \
+		(10 * (rf_gain + if_gain) - \
+		11 * (state->rf_80 + state->if_80));
+	if (signal_strength < 0)
+		signal_strength = 0;
+	else if (signal_strength > 0xffff)
+		signal_strength = 0xffff;
+
+	state->signal_strength = signal_strength;
+
+	return ret;
+err:
+	dbg("%s: failed=%d", __func__, ret);
+	return ret;
+}
+
+static void af9013_statistics_work(struct work_struct *work)
+{
+	struct af9013_state *state = container_of(work,
+		struct af9013_state, statistics_work.work);
+	unsigned int next_msec;
+
+	/* update only signal strength when demod is not locked */
+	if (!(state->fe_status & FE_HAS_LOCK)) {
+		state->statistics_step = 0;
+		state->ber = 0;
+		state->snr = 0;
+	}
+
+	switch (state->statistics_step) {
+	default:
+		state->statistics_step = 0;
+	case 0:
+		af9013_statistics_signal_strength(&state->fe);
+		state->statistics_step++;
+		next_msec = 300;
+		break;
+	case 1:
+		af9013_statistics_snr_start(&state->fe);
+		state->statistics_step++;
+		next_msec = 200;
+		break;
+	case 2:
+		af9013_statistics_ber_unc_start(&state->fe);
+		state->statistics_step++;
+		next_msec = 1000;
+		break;
+	case 3:
+		af9013_statistics_snr_result(&state->fe);
+		state->statistics_step++;
+		next_msec = 400;
+		break;
+	case 4:
+		af9013_statistics_ber_unc_result(&state->fe);
+		state->statistics_step++;
+		next_msec = 100;
+		break;
+	}
+
+	schedule_delayed_work(&state->statistics_work,
+		msecs_to_jiffies(next_msec));
+}
+
+static int af9013_get_tune_settings(struct dvb_frontend *fe,
+	struct dvb_frontend_tune_settings *fesettings)
+{
+	fesettings->min_delay_ms = 800;
+	fesettings->step_size = 0;
+	fesettings->max_drift = 0;
+
+	return 0;
+}
+
+static int af9013_set_frontend(struct dvb_frontend *fe)
+{
+	struct af9013_state *state = fe->demodulator_priv;
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	int ret, i, sampling_freq;
+	bool auto_mode, spec_inv;
+	u8 buf[6];
+	u32 if_frequency, freq_cw;
+
+	dbg("%s: frequency=%d bandwidth_hz=%d", __func__,
+		c->frequency, c->bandwidth_hz);
+
+	/* program tuner */
+	if (fe->ops.tuner_ops.set_params)
+		fe->ops.tuner_ops.set_params(fe);
+
+	/* program CFOE coefficients */
+	if (c->bandwidth_hz != state->bandwidth_hz) {
+		for (i = 0; i < ARRAY_SIZE(coeff_lut); i++) {
+			if (coeff_lut[i].clock == state->config.clock &&
+				coeff_lut[i].bandwidth_hz == c->bandwidth_hz) {
+				break;
+			}
+		}
+
+		ret = af9013_wr_regs(state, 0xae00, coeff_lut[i].val,
+			sizeof(coeff_lut[i].val));
+	}
+
+	/* program frequency control */
+	if (c->bandwidth_hz != state->bandwidth_hz || state->first_tune) {
+		/* get used IF frequency */
+		if (fe->ops.tuner_ops.get_if_frequency)
+			fe->ops.tuner_ops.get_if_frequency(fe, &if_frequency);
+		else
+			if_frequency = state->config.if_frequency;
+
+		sampling_freq = if_frequency;
+
+		while (sampling_freq > (state->config.clock / 2))
+			sampling_freq -= state->config.clock;
+
+		if (sampling_freq < 0) {
+			sampling_freq *= -1;
+			spec_inv = state->config.spec_inv;
+		} else {
+			spec_inv = !state->config.spec_inv;
+		}
+
+		freq_cw = af913_div(sampling_freq, state->config.clock, 23);
+
+		if (spec_inv)
+			freq_cw = 0x800000 - freq_cw;
+
+		buf[0] = (freq_cw >>  0) & 0xff;
+		buf[1] = (freq_cw >>  8) & 0xff;
+		buf[2] = (freq_cw >> 16) & 0x7f;
+
+		freq_cw = 0x800000 - freq_cw;
+
+		buf[3] = (freq_cw >>  0) & 0xff;
+		buf[4] = (freq_cw >>  8) & 0xff;
+		buf[5] = (freq_cw >> 16) & 0x7f;
+
+		ret = af9013_wr_regs(state, 0xd140, buf, 3);
+		if (ret)
+			goto err;
+
+		ret = af9013_wr_regs(state, 0x9be7, buf, 6);
+		if (ret)
+			goto err;
+	}
+
+	/* clear TPS lock flag */
+	ret = af9013_wr_reg_bits(state, 0xd330, 3, 1, 1);
+	if (ret)
+		goto err;
+
+	/* clear MPEG2 lock flag */
+	ret = af9013_wr_reg_bits(state, 0xd507, 6, 1, 0);
+	if (ret)
+		goto err;
+
+	/* empty channel function */
+	ret = af9013_wr_reg_bits(state, 0x9bfe, 0, 1, 0);
+	if (ret)
+		goto err;
+
+	/* empty DVB-T channel function */
+	ret = af9013_wr_reg_bits(state, 0x9bc2, 0, 1, 0);
+	if (ret)
+		goto err;
+
+	/* transmission parameters */
+	auto_mode = false;
+	memset(buf, 0, 3);
+
+	switch (c->transmission_mode) {
+	case TRANSMISSION_MODE_AUTO:
+		auto_mode = 1;
+		break;
+	case TRANSMISSION_MODE_2K:
+		break;
+	case TRANSMISSION_MODE_8K:
+		buf[0] |= (1 << 0);
+		break;
+	default:
+		dbg("%s: invalid transmission_mode", __func__);
+		auto_mode = 1;
+	}
+
+	switch (c->guard_interval) {
+	case GUARD_INTERVAL_AUTO:
+		auto_mode = 1;
+		break;
+	case GUARD_INTERVAL_1_32:
+		break;
+	case GUARD_INTERVAL_1_16:
+		buf[0] |= (1 << 2);
+		break;
+	case GUARD_INTERVAL_1_8:
+		buf[0] |= (2 << 2);
+		break;
+	case GUARD_INTERVAL_1_4:
+		buf[0] |= (3 << 2);
+		break;
+	default:
+		dbg("%s: invalid guard_interval", __func__);
+		auto_mode = 1;
+	}
+
+	switch (c->hierarchy) {
+	case HIERARCHY_AUTO:
+		auto_mode = 1;
+		break;
+	case HIERARCHY_NONE:
+		break;
+	case HIERARCHY_1:
+		buf[0] |= (1 << 4);
+		break;
+	case HIERARCHY_2:
+		buf[0] |= (2 << 4);
+		break;
+	case HIERARCHY_4:
+		buf[0] |= (3 << 4);
+		break;
+	default:
+		dbg("%s: invalid hierarchy", __func__);
+		auto_mode = 1;
+	};
+
+	switch (c->modulation) {
+	case QAM_AUTO:
+		auto_mode = 1;
+		break;
+	case QPSK:
+		break;
+	case QAM_16:
+		buf[1] |= (1 << 6);
+		break;
+	case QAM_64:
+		buf[1] |= (2 << 6);
+		break;
+	default:
+		dbg("%s: invalid modulation", __func__);
+		auto_mode = 1;
+	}
+
+	/* Use HP. How and which case we can switch to LP? */
+	buf[1] |= (1 << 4);
+
+	switch (c->code_rate_HP) {
+	case FEC_AUTO:
+		auto_mode = 1;
+		break;
+	case FEC_1_2:
+		break;
+	case FEC_2_3:
+		buf[2] |= (1 << 0);
+		break;
+	case FEC_3_4:
+		buf[2] |= (2 << 0);
+		break;
+	case FEC_5_6:
+		buf[2] |= (3 << 0);
+		break;
+	case FEC_7_8:
+		buf[2] |= (4 << 0);
+		break;
+	default:
+		dbg("%s: invalid code_rate_HP", __func__);
+		auto_mode = 1;
+	}
+
+	switch (c->code_rate_LP) {
+	case FEC_AUTO:
+		auto_mode = 1;
+		break;
+	case FEC_1_2:
+		break;
+	case FEC_2_3:
+		buf[2] |= (1 << 3);
+		break;
+	case FEC_3_4:
+		buf[2] |= (2 << 3);
+		break;
+	case FEC_5_6:
+		buf[2] |= (3 << 3);
+		break;
+	case FEC_7_8:
+		buf[2] |= (4 << 3);
+		break;
+	case FEC_NONE:
+		break;
+	default:
+		dbg("%s: invalid code_rate_LP", __func__);
+		auto_mode = 1;
+	}
+
+	switch (c->bandwidth_hz) {
+	case 6000000:
+		break;
+	case 7000000:
+		buf[1] |= (1 << 2);
+		break;
+	case 8000000:
+		buf[1] |= (2 << 2);
+		break;
+	default:
+		dbg("%s: invalid bandwidth_hz", __func__);
+		ret = -EINVAL;
+		goto err;
+	}
+
+	ret = af9013_wr_regs(state, 0xd3c0, buf, 3);
+	if (ret)
+		goto err;
+
+	if (auto_mode) {
+		/* clear easy mode flag */
+		ret = af9013_wr_reg(state, 0xaefd, 0);
+		if (ret)
+			goto err;
+
+		dbg("%s: auto params", __func__);
+	} else {
+		/* set easy mode flag */
+		ret = af9013_wr_reg(state, 0xaefd, 1);
+		if (ret)
+			goto err;
+
+		ret = af9013_wr_reg(state, 0xaefe, 0);
+		if (ret)
+			goto err;
+
+		dbg("%s: manual params", __func__);
+	}
+
+	/* tune */
+	ret = af9013_wr_reg(state, 0xffff, 0);
+	if (ret)
+		goto err;
+
+	state->bandwidth_hz = c->bandwidth_hz;
+	state->set_frontend_jiffies = jiffies;
+	state->first_tune = false;
+
+	return ret;
+err:
+	dbg("%s: failed=%d", __func__, ret);
+	return ret;
+}
+
+static int af9013_get_frontend(struct dvb_frontend *fe)
+{
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	struct af9013_state *state = fe->demodulator_priv;
+	int ret;
+	u8 buf[3];
+
+	dbg("%s", __func__);
+
+	ret = af9013_rd_regs(state, 0xd3c0, buf, 3);
+	if (ret)
+		goto err;
+
+	switch ((buf[1] >> 6) & 3) {
+	case 0:
+		c->modulation = QPSK;
+		break;
+	case 1:
+		c->modulation = QAM_16;
+		break;
+	case 2:
+		c->modulation = QAM_64;
+		break;
+	}
+
+	switch ((buf[0] >> 0) & 3) {
+	case 0:
+		c->transmission_mode = TRANSMISSION_MODE_2K;
+		break;
+	case 1:
+		c->transmission_mode = TRANSMISSION_MODE_8K;
+	}
+
+	switch ((buf[0] >> 2) & 3) {
+	case 0:
+		c->guard_interval = GUARD_INTERVAL_1_32;
+		break;
+	case 1:
+		c->guard_interval = GUARD_INTERVAL_1_16;
+		break;
+	case 2:
+		c->guard_interval = GUARD_INTERVAL_1_8;
+		break;
+	case 3:
+		c->guard_interval = GUARD_INTERVAL_1_4;
+		break;
+	}
+
+	switch ((buf[0] >> 4) & 7) {
+	case 0:
+		c->hierarchy = HIERARCHY_NONE;
+		break;
+	case 1:
+		c->hierarchy = HIERARCHY_1;
+		break;
+	case 2:
+		c->hierarchy = HIERARCHY_2;
+		break;
+	case 3:
+		c->hierarchy = HIERARCHY_4;
+		break;
+	}
+
+	switch ((buf[2] >> 0) & 7) {
+	case 0:
+		c->code_rate_HP = FEC_1_2;
+		break;
+	case 1:
+		c->code_rate_HP = FEC_2_3;
+		break;
+	case 2:
+		c->code_rate_HP = FEC_3_4;
+		break;
+	case 3:
+		c->code_rate_HP = FEC_5_6;
+		break;
+	case 4:
+		c->code_rate_HP = FEC_7_8;
+		break;
+	}
+
+	switch ((buf[2] >> 3) & 7) {
+	case 0:
+		c->code_rate_LP = FEC_1_2;
+		break;
+	case 1:
+		c->code_rate_LP = FEC_2_3;
+		break;
+	case 2:
+		c->code_rate_LP = FEC_3_4;
+		break;
+	case 3:
+		c->code_rate_LP = FEC_5_6;
+		break;
+	case 4:
+		c->code_rate_LP = FEC_7_8;
+		break;
+	}
+
+	switch ((buf[1] >> 2) & 3) {
+	case 0:
+		c->bandwidth_hz = 6000000;
+		break;
+	case 1:
+		c->bandwidth_hz = 7000000;
+		break;
+	case 2:
+		c->bandwidth_hz = 8000000;
+		break;
+	}
+
+	return ret;
+err:
+	dbg("%s: failed=%d", __func__, ret);
+	return ret;
+}
+
+static int af9013_read_status(struct dvb_frontend *fe, fe_status_t *status)
+{
+	struct af9013_state *state = fe->demodulator_priv;
+	int ret;
+	u8 tmp;
+
+	/*
+	 * Return status from the cache if it is younger than 2000ms with the
+	 * exception of last tune is done during 4000ms.
+	 */
+	if (time_is_after_jiffies(
+		state->read_status_jiffies + msecs_to_jiffies(2000)) &&
+		time_is_before_jiffies(
+		state->set_frontend_jiffies + msecs_to_jiffies(4000))
+	) {
+			*status = state->fe_status;
+			return 0;
+	} else {
+		*status = 0;
+	}
+
+	/* MPEG2 lock */
+	ret = af9013_rd_reg_bits(state, 0xd507, 6, 1, &tmp);
+	if (ret)
+		goto err;
+
+	if (tmp)
+		*status |= FE_HAS_SIGNAL | FE_HAS_CARRIER | FE_HAS_VITERBI |
+			FE_HAS_SYNC | FE_HAS_LOCK;
+
+	if (!*status) {
+		/* TPS lock */
+		ret = af9013_rd_reg_bits(state, 0xd330, 3, 1, &tmp);
+		if (ret)
+			goto err;
+
+		if (tmp)
+			*status |= FE_HAS_SIGNAL | FE_HAS_CARRIER |
+				FE_HAS_VITERBI;
+	}
+
+	state->fe_status = *status;
+	state->read_status_jiffies = jiffies;
+
+	return ret;
+err:
+	dbg("%s: failed=%d", __func__, ret);
+	return ret;
+}
+
+static int af9013_read_snr(struct dvb_frontend *fe, u16 *snr)
+{
+	struct af9013_state *state = fe->demodulator_priv;
+	*snr = state->snr;
+	return 0;
+}
+
+static int af9013_read_signal_strength(struct dvb_frontend *fe, u16 *strength)
+{
+	struct af9013_state *state = fe->demodulator_priv;
+	*strength = state->signal_strength;
+	return 0;
+}
+
+static int af9013_read_ber(struct dvb_frontend *fe, u32 *ber)
+{
+	struct af9013_state *state = fe->demodulator_priv;
+	*ber = state->ber;
+	return 0;
+}
+
+static int af9013_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)
+{
+	struct af9013_state *state = fe->demodulator_priv;
+	*ucblocks = state->ucblocks;
+	return 0;
+}
+
+static int af9013_init(struct dvb_frontend *fe)
+{
+	struct af9013_state *state = fe->demodulator_priv;
+	int ret, i, len;
+	u8 buf[3], tmp;
+	u32 adc_cw;
+	const struct af9013_reg_bit *init;
+
+	dbg("%s", __func__);
+
+	/* power on */
+	ret = af9013_power_ctrl(state, 1);
+	if (ret)
+		goto err;
+
+	/* enable ADC */
+	ret = af9013_wr_reg(state, 0xd73a, 0xa4);
+	if (ret)
+		goto err;
+
+	/* write API version to firmware */
+	ret = af9013_wr_regs(state, 0x9bf2, state->config.api_version, 4);
+	if (ret)
+		goto err;
+
+	/* program ADC control */
+	switch (state->config.clock) {
+	case 28800000: /* 28.800 MHz */
+		tmp = 0;
+		break;
+	case 20480000: /* 20.480 MHz */
+		tmp = 1;
+		break;
+	case 28000000: /* 28.000 MHz */
+		tmp = 2;
+		break;
+	case 25000000: /* 25.000 MHz */
+		tmp = 3;
+		break;
+	default:
+		err("invalid clock");
+		return -EINVAL;
+	}
+
+	adc_cw = af913_div(state->config.clock, 1000000ul, 19);
+	buf[0] = (adc_cw >>  0) & 0xff;
+	buf[1] = (adc_cw >>  8) & 0xff;
+	buf[2] = (adc_cw >> 16) & 0xff;
+
+	ret = af9013_wr_regs(state, 0xd180, buf, 3);
+	if (ret)
+		goto err;
+
+	ret = af9013_wr_reg_bits(state, 0x9bd2, 0, 4, tmp);
+	if (ret)
+		goto err;
+
+	/* set I2C master clock */
+	ret = af9013_wr_reg(state, 0xd416, 0x14);
+	if (ret)
+		goto err;
+
+	/* set 16 embx */
+	ret = af9013_wr_reg_bits(state, 0xd700, 1, 1, 1);
+	if (ret)
+		goto err;
+
+	/* set no trigger */
+	ret = af9013_wr_reg_bits(state, 0xd700, 2, 1, 0);
+	if (ret)
+		goto err;
+
+	/* set read-update bit for constellation */
+	ret = af9013_wr_reg_bits(state, 0xd371, 1, 1, 1);
+	if (ret)
+		goto err;
+
+	/* settings for mp2if */
+	if (state->config.ts_mode == AF9013_TS_USB) {
+		/* AF9015 split PSB to 1.5k + 0.5k */
+		ret = af9013_wr_reg_bits(state, 0xd50b, 2, 1, 1);
+		if (ret)
+			goto err;
+	} else {
+		/* AF9013 change the output bit to data7 */
+		ret = af9013_wr_reg_bits(state, 0xd500, 3, 1, 1);
+		if (ret)
+			goto err;
+
+		/* AF9013 set mpeg to full speed */
+		ret = af9013_wr_reg_bits(state, 0xd502, 4, 1, 1);
+		if (ret)
+			goto err;
+	}
+
+	ret = af9013_wr_reg_bits(state, 0xd520, 4, 1, 1);
+	if (ret)
+		goto err;
+
+	/* load OFSM settings */
+	dbg("%s: load ofsm settings", __func__);
+	len = ARRAY_SIZE(ofsm_init);
+	init = ofsm_init;
+	for (i = 0; i < len; i++) {
+		ret = af9013_wr_reg_bits(state, init[i].addr, init[i].pos,
+			init[i].len, init[i].val);
+		if (ret)
+			goto err;
+	}
+
+	/* load tuner specific settings */
+	dbg("%s: load tuner specific settings", __func__);
+	switch (state->config.tuner) {
+	case AF9013_TUNER_MXL5003D:
+		len = ARRAY_SIZE(tuner_init_mxl5003d);
+		init = tuner_init_mxl5003d;
+		break;
+	case AF9013_TUNER_MXL5005D:
+	case AF9013_TUNER_MXL5005R:
+	case AF9013_TUNER_MXL5007T:
+		len = ARRAY_SIZE(tuner_init_mxl5005);
+		init = tuner_init_mxl5005;
+		break;
+	case AF9013_TUNER_ENV77H11D5:
+		len = ARRAY_SIZE(tuner_init_env77h11d5);
+		init = tuner_init_env77h11d5;
+		break;
+	case AF9013_TUNER_MT2060:
+		len = ARRAY_SIZE(tuner_init_mt2060);
+		init = tuner_init_mt2060;
+		break;
+	case AF9013_TUNER_MC44S803:
+		len = ARRAY_SIZE(tuner_init_mc44s803);
+		init = tuner_init_mc44s803;
+		break;
+	case AF9013_TUNER_QT1010:
+	case AF9013_TUNER_QT1010A:
+		len = ARRAY_SIZE(tuner_init_qt1010);
+		init = tuner_init_qt1010;
+		break;
+	case AF9013_TUNER_MT2060_2:
+		len = ARRAY_SIZE(tuner_init_mt2060_2);
+		init = tuner_init_mt2060_2;
+		break;
+	case AF9013_TUNER_TDA18271:
+	case AF9013_TUNER_TDA18218:
+		len = ARRAY_SIZE(tuner_init_tda18271);
+		init = tuner_init_tda18271;
+		break;
+	case AF9013_TUNER_UNKNOWN:
+	default:
+		len = ARRAY_SIZE(tuner_init_unknown);
+		init = tuner_init_unknown;
+		break;
+	}
+
+	for (i = 0; i < len; i++) {
+		ret = af9013_wr_reg_bits(state, init[i].addr, init[i].pos,
+			init[i].len, init[i].val);
+		if (ret)
+			goto err;
+	}
+
+	/* TS mode */
+	ret = af9013_wr_reg_bits(state, 0xd500, 1, 2, state->config.ts_mode);
+	if (ret)
+		goto err;
+
+	/* enable lock led */
+	ret = af9013_wr_reg_bits(state, 0xd730, 0, 1, 1);
+	if (ret)
+		goto err;
+
+	/* check if we support signal strength */
+	if (!state->signal_strength_en) {
+		ret = af9013_rd_reg_bits(state, 0x9bee, 0, 1,
+			&state->signal_strength_en);
+		if (ret)
+			goto err;
+	}
+
+	/* read values needed for signal strength calculation */
+	if (state->signal_strength_en && !state->rf_50) {
+		ret = af9013_rd_reg(state, 0x9bbd, &state->rf_50);
+		if (ret)
+			goto err;
+
+		ret = af9013_rd_reg(state, 0x9bd0, &state->rf_80);
+		if (ret)
+			goto err;
+
+		ret = af9013_rd_reg(state, 0x9be2, &state->if_50);
+		if (ret)
+			goto err;
+
+		ret = af9013_rd_reg(state, 0x9be4, &state->if_80);
+		if (ret)
+			goto err;
+	}
+
+	/* SNR */
+	ret = af9013_wr_reg(state, 0xd2e2, 1);
+	if (ret)
+		goto err;
+
+	/* BER / UCB */
+	buf[0] = (10000 >> 0) & 0xff;
+	buf[1] = (10000 >> 8) & 0xff;
+	ret = af9013_wr_regs(state, 0xd385, buf, 2);
+	if (ret)
+		goto err;
+
+	/* enable FEC monitor */
+	ret = af9013_wr_reg_bits(state, 0xd392, 1, 1, 1);
+	if (ret)
+		goto err;
+
+	state->first_tune = true;
+	schedule_delayed_work(&state->statistics_work, msecs_to_jiffies(400));
+
+	return ret;
+err:
+	dbg("%s: failed=%d", __func__, ret);
+	return ret;
+}
+
+static int af9013_sleep(struct dvb_frontend *fe)
+{
+	struct af9013_state *state = fe->demodulator_priv;
+	int ret;
+
+	dbg("%s", __func__);
+
+	/* stop statistics polling */
+	cancel_delayed_work_sync(&state->statistics_work);
+
+	/* disable lock led */
+	ret = af9013_wr_reg_bits(state, 0xd730, 0, 1, 0);
+	if (ret)
+		goto err;
+
+	/* power off */
+	ret = af9013_power_ctrl(state, 0);
+	if (ret)
+		goto err;
+
+	return ret;
+err:
+	dbg("%s: failed=%d", __func__, ret);
+	return ret;
+}
+
+static int af9013_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)
+{
+	int ret;
+	struct af9013_state *state = fe->demodulator_priv;
+
+	dbg("%s: enable=%d", __func__, enable);
+
+	/* gate already open or close */
+	if (state->i2c_gate_state == enable)
+		return 0;
+
+	if (state->config.ts_mode == AF9013_TS_USB)
+		ret = af9013_wr_reg_bits(state, 0xd417, 3, 1, enable);
+	else
+		ret = af9013_wr_reg_bits(state, 0xd607, 2, 1, enable);
+	if (ret)
+		goto err;
+
+	state->i2c_gate_state = enable;
+
+	return ret;
+err:
+	dbg("%s: failed=%d", __func__, ret);
+	return ret;
+}
+
+static void af9013_release(struct dvb_frontend *fe)
+{
+	struct af9013_state *state = fe->demodulator_priv;
+	kfree(state);
+}
+
+static struct dvb_frontend_ops af9013_ops;
+
+static int af9013_download_firmware(struct af9013_state *state)
+{
+	int i, len, remaining, ret;
+	const struct firmware *fw;
+	u16 checksum = 0;
+	u8 val;
+	u8 fw_params[4];
+	u8 *fw_file = AF9013_DEFAULT_FIRMWARE;
+
+	msleep(100);
+	/* check whether firmware is already running */
+	ret = af9013_rd_reg(state, 0x98be, &val);
+	if (ret)
+		goto err;
+	else
+		dbg("%s: firmware status=%02x", __func__, val);
+
+	if (val == 0x0c) /* fw is running, no need for download */
+		goto exit;
+
+	info("found a '%s' in cold state, will try to load a firmware",
+		af9013_ops.info.name);
+
+	/* request the firmware, this will block and timeout */
+	ret = request_firmware(&fw, fw_file, state->i2c->dev.parent);
+	if (ret) {
+		err("did not find the firmware file. (%s) "
+			"Please see linux/Documentation/dvb/ for more details" \
+			" on firmware-problems. (%d)",
+			fw_file, ret);
+		goto err;
+	}
+
+	info("downloading firmware from file '%s'", fw_file);
+
+	/* calc checksum */
+	for (i = 0; i < fw->size; i++)
+		checksum += fw->data[i];
+
+	fw_params[0] = checksum >> 8;
+	fw_params[1] = checksum & 0xff;
+	fw_params[2] = fw->size >> 8;
+	fw_params[3] = fw->size & 0xff;
+
+	/* write fw checksum & size */
+	ret = af9013_write_ofsm_regs(state, 0x50fc,
+		fw_params, sizeof(fw_params));
+	if (ret)
+		goto err_release;
+
+	#define FW_ADDR 0x5100 /* firmware start address */
+	#define LEN_MAX 16 /* max packet size */
+	for (remaining = fw->size; remaining > 0; remaining -= LEN_MAX) {
+		len = remaining;
+		if (len > LEN_MAX)
+			len = LEN_MAX;
+
+		ret = af9013_write_ofsm_regs(state,
+			FW_ADDR + fw->size - remaining,
+			(u8 *) &fw->data[fw->size - remaining], len);
+		if (ret) {
+			err("firmware download failed:%d", ret);
+			goto err_release;
+		}
+	}
+
+	/* request boot firmware */
+	ret = af9013_wr_reg(state, 0xe205, 1);
+	if (ret)
+		goto err_release;
+
+	for (i = 0; i < 15; i++) {
+		msleep(100);
+
+		/* check firmware status */
+		ret = af9013_rd_reg(state, 0x98be, &val);
+		if (ret)
+			goto err_release;
+
+		dbg("%s: firmware status=%02x", __func__, val);
+
+		if (val == 0x0c || val == 0x04) /* success or fail */
+			break;
+	}
+
+	if (val == 0x04) {
+		err("firmware did not run");
+		ret = -ENODEV;
+	} else if (val != 0x0c) {
+		err("firmware boot timeout");
+		ret = -ENODEV;
+	}
+
+err_release:
+	release_firmware(fw);
+err:
+exit:
+	if (!ret)
+		info("found a '%s' in warm state.", af9013_ops.info.name);
+	return ret;
+}
+
+struct dvb_frontend *af9013_attach(const struct af9013_config *config,
+	struct i2c_adapter *i2c)
+{
+	int ret;
+	struct af9013_state *state = NULL;
+	u8 buf[4], i;
+
+	/* allocate memory for the internal state */
+	state = kzalloc(sizeof(struct af9013_state), GFP_KERNEL);
+	if (state == NULL)
+		goto err;
+
+	/* setup the state */
+	state->i2c = i2c;
+	memcpy(&state->config, config, sizeof(struct af9013_config));
+
+	/* download firmware */
+	if (state->config.ts_mode != AF9013_TS_USB) {
+		ret = af9013_download_firmware(state);
+		if (ret)
+			goto err;
+	}
+
+	/* firmware version */
+	ret = af9013_rd_regs(state, 0x5103, buf, 4);
+	if (ret)
+		goto err;
+
+	info("firmware version %d.%d.%d.%d", buf[0], buf[1], buf[2], buf[3]);
+
+	/* set GPIOs */
+	for (i = 0; i < sizeof(state->config.gpio); i++) {
+		ret = af9013_set_gpio(state, i, state->config.gpio[i]);
+		if (ret)
+			goto err;
+	}
+
+	/* create dvb_frontend */
+	memcpy(&state->fe.ops, &af9013_ops,
+		sizeof(struct dvb_frontend_ops));
+	state->fe.demodulator_priv = state;
+
+	INIT_DELAYED_WORK(&state->statistics_work, af9013_statistics_work);
+
+	return &state->fe;
+err:
+	kfree(state);
+	return NULL;
+}
+EXPORT_SYMBOL(af9013_attach);
+
+static struct dvb_frontend_ops af9013_ops = {
+	.delsys = { SYS_DVBT },
+	.info = {
+		.name = "Afatech AF9013",
+		.frequency_min = 174000000,
+		.frequency_max = 862000000,
+		.frequency_stepsize = 250000,
+		.frequency_tolerance = 0,
+		.caps =	FE_CAN_FEC_1_2 |
+			FE_CAN_FEC_2_3 |
+			FE_CAN_FEC_3_4 |
+			FE_CAN_FEC_5_6 |
+			FE_CAN_FEC_7_8 |
+			FE_CAN_FEC_AUTO |
+			FE_CAN_QPSK |
+			FE_CAN_QAM_16 |
+			FE_CAN_QAM_64 |
+			FE_CAN_QAM_AUTO |
+			FE_CAN_TRANSMISSION_MODE_AUTO |
+			FE_CAN_GUARD_INTERVAL_AUTO |
+			FE_CAN_HIERARCHY_AUTO |
+			FE_CAN_RECOVER |
+			FE_CAN_MUTE_TS
+	},
+
+	.release = af9013_release,
+
+	.init = af9013_init,
+	.sleep = af9013_sleep,
+
+	.get_tune_settings = af9013_get_tune_settings,
+	.set_frontend = af9013_set_frontend,
+	.get_frontend = af9013_get_frontend,
+
+	.read_status = af9013_read_status,
+	.read_snr = af9013_read_snr,
+	.read_signal_strength = af9013_read_signal_strength,
+	.read_ber = af9013_read_ber,
+	.read_ucblocks = af9013_read_ucblocks,
+
+	.i2c_gate_ctrl = af9013_i2c_gate_ctrl,
+};
+
+MODULE_AUTHOR("Antti Palosaari <crope@iki.fi>");
+MODULE_DESCRIPTION("Afatech AF9013 DVB-T demodulator driver");
+MODULE_LICENSE("GPL");
