commit 09c434b8a0047c69e48499de0107de312901e798
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 13:08:20 2019 +0100

    treewide: Add SPDX license identifier for more missed files
    
    Add SPDX license identifiers to all files which:
    
     - Have no license information of any form
    
     - Have MODULE_LICENCE("GPL*") inside which was used in the initial
       scan/conversion to ignore the file
    
    These files fall under the project license, GPL v2 only. The resulting SPDX
    license identifier is:
    
      GPL-2.0-only
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/media/dvb-frontends/sp887x.c b/drivers/media/dvb-frontends/sp887x.c
index c02f50995df4..c89a91a3daf4 100644
--- a/drivers/media/dvb-frontends/sp887x.c
+++ b/drivers/media/dvb-frontends/sp887x.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
    Driver for the Spase sp887x demodulator
 */

commit f1b1eabff0eb3fc46b06668de8174c0f23b271fd
Author: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
Date:   Thu Jul 5 18:59:36 2018 -0400

    media: dvb: represent min/max/step/tolerance freqs in Hz
    
    Right now, satellite frontend drivers specify frequencies in kHz,
    while terrestrial/cable ones specify in Hz. That's confusing
    for developers.
    
    However, the main problem is that universal frontends capable
    of handling both satellite and non-satelite delivery systems
    are appearing. We end by needing to hack the drivers in
    order to support such hybrid frontends.
    
    So, convert everything to specify frontend frequencies in Hz.
    
    Tested-by: Katsuhiro Suzuki <suzuki.katsuhiro@socionext.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/dvb-frontends/sp887x.c b/drivers/media/dvb-frontends/sp887x.c
index 57a0d0ae2b48..c02f50995df4 100644
--- a/drivers/media/dvb-frontends/sp887x.c
+++ b/drivers/media/dvb-frontends/sp887x.c
@@ -594,9 +594,9 @@ static const struct dvb_frontend_ops sp887x_ops = {
 	.delsys = { SYS_DVBT },
 	.info = {
 		.name = "Spase SP887x DVB-T",
-		.frequency_min =  50500000,
-		.frequency_max = 858000000,
-		.frequency_stepsize = 166666,
+		.frequency_min_hz =  50500 * kHz,
+		.frequency_max_hz = 858000 * kHz,
+		.frequency_stepsize_hz = 166666,
 		.caps = FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |
 			FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |
 			FE_CAN_QPSK | FE_CAN_QAM_16 | FE_CAN_QAM_64 |

commit fe63a1a6216749fd9d9c5b52d52b75240f9d20f3
Author: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
Date:   Tue May 8 18:10:05 2018 -0300

    media: dvb: fix location of get_dvb_firmware script
    
    This script was moved out of Documentation/dvb, but the
    links weren't updated.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
    Acked-by: Jonathan Corbet <corbet@lwn.net>

diff --git a/drivers/media/dvb-frontends/sp887x.c b/drivers/media/dvb-frontends/sp887x.c
index f39d566d7d1d..57a0d0ae2b48 100644
--- a/drivers/media/dvb-frontends/sp887x.c
+++ b/drivers/media/dvb-frontends/sp887x.c
@@ -4,7 +4,7 @@
 
 /*
  * This driver needs external firmware. Please use the command
- * "<kerneldir>/Documentation/dvb/get_dvb_firmware sp887x" to
+ * "<kerneldir>/scripts/get_dvb_firmware sp887x" to
  * download/extract it, and then copy it to /usr/lib/hotplug/firmware
  * or /lib/firmware (depending on configuration of firmware hotplug).
  */

commit 89d6e45c8af8b6e9351564a15467c90e862bbfcd
Author: Mauro Carvalho Chehab <mchehab@s-opensource.com>
Date:   Thu Mar 22 15:13:58 2018 -0400

    media: sp887x: fix a warning
    
    drivers/media/dvb-frontends/sp887x.c:179 sp887x_initial_setup() error: memcpy() '&buf[2]' too small (30 vs 16384)
    
    This is actually a false alarm, but reverting the check order
    makes not only for humans to review the code, but also cleans
    the warning.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/sp887x.c b/drivers/media/dvb-frontends/sp887x.c
index 572a297811fe..f39d566d7d1d 100644
--- a/drivers/media/dvb-frontends/sp887x.c
+++ b/drivers/media/dvb-frontends/sp887x.c
@@ -136,7 +136,7 @@ static void sp887x_setup_agc (struct sp887x_state* state)
 static int sp887x_initial_setup (struct dvb_frontend* fe, const struct firmware *fw)
 {
 	struct sp887x_state* state = fe->demodulator_priv;
-	u8 buf [BLOCKSIZE+2];
+	u8 buf [BLOCKSIZE + 2];
 	int i;
 	int fw_size = fw->size;
 	const unsigned char *mem = fw->data;
@@ -144,7 +144,7 @@ static int sp887x_initial_setup (struct dvb_frontend* fe, const struct firmware
 	dprintk("%s\n", __func__);
 
 	/* ignore the first 10 bytes, then we expect 0x4000 bytes of firmware */
-	if (fw_size < FW_SIZE+10)
+	if (fw_size < FW_SIZE + 10)
 		return -ENODEV;
 
 	mem = fw->data + 10;
@@ -167,7 +167,7 @@ static int sp887x_initial_setup (struct dvb_frontend* fe, const struct firmware
 		int c = BLOCKSIZE;
 		int err;
 
-		if (i+c > FW_SIZE)
+		if (c > FW_SIZE - i)
 			c = FW_SIZE - i;
 
 		/* bit 0x8000 in address is set to enable 13bit mode */

commit fada1935590f66dc6784981e0d557ca09013c847
Author: Mauro Carvalho Chehab <mchehab@s-opensource.com>
Date:   Thu Dec 28 13:03:51 2017 -0500

    media: move dvb kAPI headers to include/media
    
    Except for DVB, all media kAPI headers are at include/media.
    
    Move the headers to it.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/sp887x.c b/drivers/media/dvb-frontends/sp887x.c
index d2c402b52c6e..572a297811fe 100644
--- a/drivers/media/dvb-frontends/sp887x.c
+++ b/drivers/media/dvb-frontends/sp887x.c
@@ -17,7 +17,7 @@
 #include <linux/string.h>
 #include <linux/slab.h>
 
-#include "dvb_frontend.h"
+#include <media/dvb_frontend.h>
 #include "sp887x.h"
 
 

commit cba862dc7301d62f90393f2bbb181834a3125308
Author: Mauro Carvalho Chehab <mchehab@s-opensource.com>
Date:   Wed Nov 29 08:33:45 2017 -0500

    media: drivers: remove "/**" from non-kernel-doc comments
    
    Several comments are wrongly tagged as kernel-doc, causing
    those warnings:
    
      drivers/media/rc/st_rc.c:98: warning: No description found for parameter 'irq'
      drivers/media/rc/st_rc.c:98: warning: No description found for parameter 'data'
      drivers/media/pci/solo6x10/solo6x10-enc.c:183: warning: No description found for parameter 'solo_dev'
      drivers/media/pci/solo6x10/solo6x10-enc.c:183: warning: No description found for parameter 'ch'
      drivers/media/pci/solo6x10/solo6x10-enc.c:183: warning: No description found for parameter 'qp'
      drivers/media/usb/pwc/pwc-dec23.c:652: warning: Cannot understand  *
       on line 652 - I thought it was a doc line
      drivers/media/usb/dvb-usb/cinergyT2-fe.c:40: warning: No description found for parameter 'op'
      drivers/media/usb/dvb-usb/friio-fe.c:301: warning: Cannot understand  * (reg, val) commad list to initialize this module.
       on line 301 - I thought it was a doc line
      drivers/media/rc/streamzap.c:201: warning: No description found for parameter 'urb'
      drivers/media/rc/streamzap.c:333: warning: No description found for parameter 'intf'
      drivers/media/rc/streamzap.c:333: warning: No description found for parameter 'id'
      drivers/media/rc/streamzap.c:464: warning: No description found for parameter 'interface'
      drivers/media/i2c/ov5647.c:432: warning: Cannot understand  * @short Subdev core operations registration
       on line 432 - I thought it was a doc line
      drivers/media/usb/dvb-usb/friio.c:35: warning: No description found for parameter 'd'
      drivers/media/usb/dvb-usb/friio.c:35: warning: No description found for parameter 'addr'
      drivers/media/usb/dvb-usb/friio.c:35: warning: No description found for parameter 'wbuf'
      drivers/media/usb/dvb-usb/friio.c:35: warning: No description found for parameter 'wlen'
      drivers/media/usb/dvb-usb/friio.c:35: warning: No description found for parameter 'rbuf'
      drivers/media/usb/dvb-usb/friio.c:35: warning: No description found for parameter 'rlen'
      drivers/media/platform/vim2m.c:350: warning: No description found for parameter 'priv'
      drivers/media/dvb-frontends/tua6100.c:34: warning: cannot understand function prototype: 'struct tua6100_priv '
      drivers/media/platform/sti/hva/hva-h264.c:140: warning: cannot understand function prototype: 'struct hva_h264_stereo_video_sei '
      drivers/media/platform/sti/hva/hva-h264.c:150: warning: Cannot understand  * @frame_width: width in pixels of the buffer containing the input frame
       on line 150 - I thought it was a doc line
      drivers/media/platform/sti/hva/hva-h264.c:356: warning: Cannot understand  * @ slice_size: slice size
       on line 356 - I thought it was a doc line
      drivers/media/platform/sti/hva/hva-h264.c:369: warning: Cannot understand  * @ bitstream_size: bitstream size
       on line 369 - I thought it was a doc line
      drivers/media/platform/sti/hva/hva-h264.c:395: warning: Cannot understand  * @seq_info:  sequence information buffer
       on line 395 - I thought it was a doc line
      drivers/media/dvb-frontends/sp887x.c:137: warning: No description found for parameter 'fe'
      drivers/media/dvb-frontends/sp887x.c:137: warning: No description found for parameter 'fw'
      drivers/media/dvb-frontends/sp887x.c:287: warning: No description found for parameter 'n'
      drivers/media/dvb-frontends/sp887x.c:287: warning: No description found for parameter 'd'
      drivers/media/dvb-frontends/sp887x.c:287: warning: No description found for parameter 'quotient_i'
      drivers/media/dvb-frontends/sp887x.c:287: warning: No description found for parameter 'quotient_f'
      drivers/media/usb/ttusb-budget/dvb-ttusb-budget.c:83: warning: cannot understand function prototype: 'struct ttusb '
      drivers/media/platform/sh_veu.c:277: warning: No description found for parameter 'priv'
      drivers/media/dvb-frontends/zl10036.c:33: warning: cannot understand function prototype: 'int zl10036_debug; '
      drivers/media/dvb-frontends/zl10036.c:179: warning: No description found for parameter 'state'
      drivers/media/dvb-frontends/zl10036.c:179: warning: No description found for parameter 'frequency'
      drivers/media/platform/rcar_fdp1.c:1139: warning: No description found for parameter 'priv'
      drivers/media/platform/ti-vpe/vpe.c:933: warning: No description found for parameter 'priv'
      drivers/media/usb/gspca/ov519.c:36: warning: No description found for parameter 'fmt'
      drivers/media/usb/dvb-usb/dib0700_devices.c:3367: warning: No description found for parameter 'adap'
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/sp887x.c b/drivers/media/dvb-frontends/sp887x.c
index 7c511c3cd4ca..d2c402b52c6e 100644
--- a/drivers/media/dvb-frontends/sp887x.c
+++ b/drivers/media/dvb-frontends/sp887x.c
@@ -57,7 +57,7 @@ static int sp887x_writereg (struct sp887x_state* state, u16 reg, u16 data)
 	int ret;
 
 	if ((ret = i2c_transfer(state->i2c, &msg, 1)) != 1) {
-		/**
+		/*
 		 *  in case of soft reset we ignore ACK errors...
 		 */
 		if (!(reg == 0xf1a && data == 0x000 &&
@@ -130,7 +130,7 @@ static void sp887x_setup_agc (struct sp887x_state* state)
 
 #define BLOCKSIZE 30
 #define FW_SIZE 0x4000
-/**
+/*
  *  load firmware and setup MPEG interface...
  */
 static int sp887x_initial_setup (struct dvb_frontend* fe, const struct firmware *fw)
@@ -279,7 +279,7 @@ static int configure_reg0xc05(struct dtv_frontend_properties *p, u16 *reg0xc05)
 	return 0;
 }
 
-/**
+/*
  *  estimates division of two 24bit numbers,
  *  derived from the ves1820/stv0299 driver code
  */

commit bd336e63441bcdeeccca6a698087d913a32478c5
Author: Max Kellermann <max.kellermann@gmail.com>
Date:   Tue Aug 9 18:32:21 2016 -0300

    [media] dvb: make DVB frontend *_ops instances "const"
    
    These are immutable.  Making them "const" allows the compiler to move
    them to the "rodata" section.
    
    Note that cxd2841er_t_c_ops cannot be made "const", because
    cxd2841er_attach() modifies it.  Ouch!
    
    [mchehab@s-opensource.com: fix merge conflicts]
    Signed-off-by: Max Kellermann <max.kellermann@gmail.com>
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/sp887x.c b/drivers/media/dvb-frontends/sp887x.c
index f9194b7b7fec..7c511c3cd4ca 100644
--- a/drivers/media/dvb-frontends/sp887x.c
+++ b/drivers/media/dvb-frontends/sp887x.c
@@ -561,7 +561,7 @@ static void sp887x_release(struct dvb_frontend* fe)
 	kfree(state);
 }
 
-static struct dvb_frontend_ops sp887x_ops;
+static const struct dvb_frontend_ops sp887x_ops;
 
 struct dvb_frontend* sp887x_attach(const struct sp887x_config* config,
 				   struct i2c_adapter* i2c)
@@ -590,7 +590,7 @@ struct dvb_frontend* sp887x_attach(const struct sp887x_config* config,
 	return NULL;
 }
 
-static struct dvb_frontend_ops sp887x_ops = {
+static const struct dvb_frontend_ops sp887x_ops = {
 	.delsys = { SYS_DVBT },
 	.info = {
 		.name = "Spase SP887x DVB-T",

commit 4bd69e7b9c1b8c1a5b6cfc50a126ae0a1d926e57
Author: Mauro Carvalho Chehab <mchehab@s-opensource.com>
Date:   Tue Oct 18 17:44:22 2016 -0200

    [media] dvb-frontends: don't break long lines
    
    Due to the 80-cols restrictions, and latter due to checkpatch
    warnings, several strings were broken into multiple lines. This
    is not considered a good practice anymore, as it makes harder
    to grep for strings at the source code.
    
    As we're right now fixing other drivers due to KERN_CONT, we need
    to be able to identify what printk strings don't end with a "\n".
    It is a way easier to detect those if we don't break long lines.
    
    So, join those continuation lines.
    
    The patch was generated via the script below, and manually
    adjusted if needed.
    
    </script>
    use Text::Tabs;
    while (<>) {
            if ($next ne "") {
                    $c=$_;
                    if ($c =~ /^\s+\"(.*)/) {
                            $c2=$1;
                            $next =~ s/\"\n$//;
                            $n = expand($next);
                            $funpos = index($n, '(');
                            $pos = index($c2, '",');
                            if ($funpos && $pos > 0) {
                                    $s1 = substr $c2, 0, $pos + 2;
                                    $s2 = ' ' x ($funpos + 1) . substr $c2, $pos + 2;
                                    $s2 =~ s/^\s+//;
    
                                    $s2 = ' ' x ($funpos + 1) . $s2 if ($s2 ne "");
    
                                    print unexpand("$next$s1\n");
                                    print unexpand("$s2\n") if ($s2 ne "");
                            } else {
                                    print "$next$c2\n";
                            }
                            $next="";
                            next;
                    } else {
                            print $next;
                    }
                    $next="";
            } else {
                    if (m/\"$/) {
                            if (!m/\\n\"$/) {
                                    $next=$_;
                                    next;
                            }
                    }
            }
            print $_;
    }
    </script>
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/sp887x.c b/drivers/media/dvb-frontends/sp887x.c
index 4378fe1b978e..f9194b7b7fec 100644
--- a/drivers/media/dvb-frontends/sp887x.c
+++ b/drivers/media/dvb-frontends/sp887x.c
@@ -63,8 +63,7 @@ static int sp887x_writereg (struct sp887x_state* state, u16 reg, u16 data)
 		if (!(reg == 0xf1a && data == 0x000 &&
 			(ret == -EREMOTEIO || ret == -EFAULT)))
 		{
-			printk("%s: writereg error "
-			       "(reg %03x, data %03x, ret == %i)\n",
+			printk("%s: writereg error (reg %03x, data %03x, ret == %i)\n",
 			       __func__, reg & 0xffff, data & 0xffff, ret);
 			return ret;
 		}

commit 0df289a209e02f0926042ab07d7d2595ea2d2e9b
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Sun Jun 7 14:53:52 2015 -0300

    [media] dvb: Get rid of typedev usage for enums
    
    The DVB API was originally defined using typedefs. This is against
    Kernel CodingStyle, and there's no good usage here. While we can't
    remove its usage on userspace, we can avoid its usage in Kernelspace.
    
    So, let's do it.
    
    This patch was generated by this shell script:
    
            for j in $(grep typedef include/uapi/linux/dvb/frontend.h |cut -d' ' -f 3); do for i in $(find drivers/media -name '*.[ch]' -type f) $(find drivers/staging/media -name '*.[ch]' -type f); do sed "s,${j}_t,enum $j," <$i >a && mv a $i; done; done
    
    While here, make CodingStyle fixes on the affected lines.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
    Acked-by: Stefan Richter <stefanr@s5r6.in-berlin.de> # for drivers/media/firewire/*

diff --git a/drivers/media/dvb-frontends/sp887x.c b/drivers/media/dvb-frontends/sp887x.c
index 1bb81b5ae6e0..4378fe1b978e 100644
--- a/drivers/media/dvb-frontends/sp887x.c
+++ b/drivers/media/dvb-frontends/sp887x.c
@@ -416,7 +416,7 @@ static int sp887x_setup_frontend_parameters(struct dvb_frontend *fe)
 	return 0;
 }
 
-static int sp887x_read_status(struct dvb_frontend* fe, fe_status_t* status)
+static int sp887x_read_status(struct dvb_frontend *fe, enum fe_status *status)
 {
 	struct sp887x_state* state = fe->demodulator_priv;
 	u16 snr12 = sp887x_readreg(state, 0xf16);

commit c2c1b4156a447f113ef4d167decce29399c2667c
Author: Peter Senna Tschudin <peter.senna@gmail.com>
Date:   Fri Sep 28 05:37:22 2012 -0300

    [media] drivers/media: Remove unnecessary semicolon
    
    A simplified version of the semantic patch that finds this problem is as
    follows: (http://coccinelle.lip6.fr/)
    // <smpl>
    @r1@
    statement S;
    position p,p1;
    @@
    S@p1;@p
    @script:python r2@
    p << r1.p;
    p1 << r1.p1;
    @@
    if p[0].line != p1[0].line_end:
            cocci.include_match(False)
    @@
    position r1.p;
    @@
    -;@p
    // </smpl>
    
    [mchehab@redhat.com: some hunks got bitroted; applied only the
     ones that succeeds]
    Signed-off-by: Peter Senna Tschudin <peter.senna@gmail.com>
    [crope@iki.fi: For my drivers a8293, af9013, af9015, af9035]
    Acked-by: Antti Palosaari <crope@iki.fi>
    Reviewed-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/dvb-frontends/sp887x.c b/drivers/media/dvb-frontends/sp887x.c
index f4096ccb226e..1bb81b5ae6e0 100644
--- a/drivers/media/dvb-frontends/sp887x.c
+++ b/drivers/media/dvb-frontends/sp887x.c
@@ -229,7 +229,7 @@ static int configure_reg0xc05(struct dtv_frontend_properties *p, u16 *reg0xc05)
 		break;
 	default:
 		return -EINVAL;
-	};
+	}
 
 	switch (p->hierarchy) {
 	case HIERARCHY_NONE:
@@ -248,7 +248,7 @@ static int configure_reg0xc05(struct dtv_frontend_properties *p, u16 *reg0xc05)
 		break;
 	default:
 		return -EINVAL;
-	};
+	}
 
 	switch (p->code_rate_HP) {
 	case FEC_1_2:
@@ -270,7 +270,7 @@ static int configure_reg0xc05(struct dtv_frontend_properties *p, u16 *reg0xc05)
 		break;
 	default:
 		return -EINVAL;
-	};
+	}
 
 	if (known_parameters)
 		*reg0xc05 |= (2 << 1);	/* use specified parameters */

commit 9a0bf528b4d66b605f02634236da085595c22101
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Mon Aug 13 23:13:41 2012 -0300

    [media] move the dvb/frontends to drivers/media/dvb-frontends
    
    Raise the DVB frontends one level up, as the intention is to remove
    the drivers/media/dvb directory.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/dvb-frontends/sp887x.c b/drivers/media/dvb-frontends/sp887x.c
new file mode 100644
index 000000000000..f4096ccb226e
--- /dev/null
+++ b/drivers/media/dvb-frontends/sp887x.c
@@ -0,0 +1,629 @@
+/*
+   Driver for the Spase sp887x demodulator
+*/
+
+/*
+ * This driver needs external firmware. Please use the command
+ * "<kerneldir>/Documentation/dvb/get_dvb_firmware sp887x" to
+ * download/extract it, and then copy it to /usr/lib/hotplug/firmware
+ * or /lib/firmware (depending on configuration of firmware hotplug).
+ */
+#define SP887X_DEFAULT_FIRMWARE "dvb-fe-sp887x.fw"
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/firmware.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+
+#include "dvb_frontend.h"
+#include "sp887x.h"
+
+
+struct sp887x_state {
+	struct i2c_adapter* i2c;
+	const struct sp887x_config* config;
+	struct dvb_frontend frontend;
+
+	/* demodulator private data */
+	u8 initialised:1;
+};
+
+static int debug;
+#define dprintk(args...) \
+	do { \
+		if (debug) printk(KERN_DEBUG "sp887x: " args); \
+	} while (0)
+
+static int i2c_writebytes (struct sp887x_state* state, u8 *buf, u8 len)
+{
+	struct i2c_msg msg = { .addr = state->config->demod_address, .flags = 0, .buf = buf, .len = len };
+	int err;
+
+	if ((err = i2c_transfer (state->i2c, &msg, 1)) != 1) {
+		printk ("%s: i2c write error (addr %02x, err == %i)\n",
+			__func__, state->config->demod_address, err);
+		return -EREMOTEIO;
+	}
+
+	return 0;
+}
+
+static int sp887x_writereg (struct sp887x_state* state, u16 reg, u16 data)
+{
+	u8 b0 [] = { reg >> 8 , reg & 0xff, data >> 8, data & 0xff };
+	struct i2c_msg msg = { .addr = state->config->demod_address, .flags = 0, .buf = b0, .len = 4 };
+	int ret;
+
+	if ((ret = i2c_transfer(state->i2c, &msg, 1)) != 1) {
+		/**
+		 *  in case of soft reset we ignore ACK errors...
+		 */
+		if (!(reg == 0xf1a && data == 0x000 &&
+			(ret == -EREMOTEIO || ret == -EFAULT)))
+		{
+			printk("%s: writereg error "
+			       "(reg %03x, data %03x, ret == %i)\n",
+			       __func__, reg & 0xffff, data & 0xffff, ret);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static int sp887x_readreg (struct sp887x_state* state, u16 reg)
+{
+	u8 b0 [] = { reg >> 8 , reg & 0xff };
+	u8 b1 [2];
+	int ret;
+	struct i2c_msg msg[] = {{ .addr = state->config->demod_address, .flags = 0, .buf = b0, .len = 2 },
+			 { .addr = state->config->demod_address, .flags = I2C_M_RD, .buf = b1, .len = 2 }};
+
+	if ((ret = i2c_transfer(state->i2c, msg, 2)) != 2) {
+		printk("%s: readreg error (ret == %i)\n", __func__, ret);
+		return -1;
+	}
+
+	return (((b1[0] << 8) | b1[1]) & 0xfff);
+}
+
+static void sp887x_microcontroller_stop (struct sp887x_state* state)
+{
+	dprintk("%s\n", __func__);
+	sp887x_writereg(state, 0xf08, 0x000);
+	sp887x_writereg(state, 0xf09, 0x000);
+
+	/* microcontroller STOP */
+	sp887x_writereg(state, 0xf00, 0x000);
+}
+
+static void sp887x_microcontroller_start (struct sp887x_state* state)
+{
+	dprintk("%s\n", __func__);
+	sp887x_writereg(state, 0xf08, 0x000);
+	sp887x_writereg(state, 0xf09, 0x000);
+
+	/* microcontroller START */
+	sp887x_writereg(state, 0xf00, 0x001);
+}
+
+static void sp887x_setup_agc (struct sp887x_state* state)
+{
+	/* setup AGC parameters */
+	dprintk("%s\n", __func__);
+	sp887x_writereg(state, 0x33c, 0x054);
+	sp887x_writereg(state, 0x33b, 0x04c);
+	sp887x_writereg(state, 0x328, 0x000);
+	sp887x_writereg(state, 0x327, 0x005);
+	sp887x_writereg(state, 0x326, 0x001);
+	sp887x_writereg(state, 0x325, 0x001);
+	sp887x_writereg(state, 0x324, 0x001);
+	sp887x_writereg(state, 0x318, 0x050);
+	sp887x_writereg(state, 0x317, 0x3fe);
+	sp887x_writereg(state, 0x316, 0x001);
+	sp887x_writereg(state, 0x313, 0x005);
+	sp887x_writereg(state, 0x312, 0x002);
+	sp887x_writereg(state, 0x306, 0x000);
+	sp887x_writereg(state, 0x303, 0x000);
+}
+
+#define BLOCKSIZE 30
+#define FW_SIZE 0x4000
+/**
+ *  load firmware and setup MPEG interface...
+ */
+static int sp887x_initial_setup (struct dvb_frontend* fe, const struct firmware *fw)
+{
+	struct sp887x_state* state = fe->demodulator_priv;
+	u8 buf [BLOCKSIZE+2];
+	int i;
+	int fw_size = fw->size;
+	const unsigned char *mem = fw->data;
+
+	dprintk("%s\n", __func__);
+
+	/* ignore the first 10 bytes, then we expect 0x4000 bytes of firmware */
+	if (fw_size < FW_SIZE+10)
+		return -ENODEV;
+
+	mem = fw->data + 10;
+
+	/* soft reset */
+	sp887x_writereg(state, 0xf1a, 0x000);
+
+	sp887x_microcontroller_stop (state);
+
+	printk ("%s: firmware upload... ", __func__);
+
+	/* setup write pointer to -1 (end of memory) */
+	/* bit 0x8000 in address is set to enable 13bit mode */
+	sp887x_writereg(state, 0x8f08, 0x1fff);
+
+	/* dummy write (wrap around to start of memory) */
+	sp887x_writereg(state, 0x8f0a, 0x0000);
+
+	for (i = 0; i < FW_SIZE; i += BLOCKSIZE) {
+		int c = BLOCKSIZE;
+		int err;
+
+		if (i+c > FW_SIZE)
+			c = FW_SIZE - i;
+
+		/* bit 0x8000 in address is set to enable 13bit mode */
+		/* bit 0x4000 enables multibyte read/write transfers */
+		/* write register is 0xf0a */
+		buf[0] = 0xcf;
+		buf[1] = 0x0a;
+
+		memcpy(&buf[2], mem + i, c);
+
+		if ((err = i2c_writebytes (state, buf, c+2)) < 0) {
+			printk ("failed.\n");
+			printk ("%s: i2c error (err == %i)\n", __func__, err);
+			return err;
+		}
+	}
+
+	/* don't write RS bytes between packets */
+	sp887x_writereg(state, 0xc13, 0x001);
+
+	/* suppress clock if (!data_valid) */
+	sp887x_writereg(state, 0xc14, 0x000);
+
+	/* setup MPEG interface... */
+	sp887x_writereg(state, 0xc1a, 0x872);
+	sp887x_writereg(state, 0xc1b, 0x001);
+	sp887x_writereg(state, 0xc1c, 0x000); /* parallel mode (serial mode == 1) */
+	sp887x_writereg(state, 0xc1a, 0x871);
+
+	/* ADC mode, 2 for MT8872, 3 for SP8870/SP8871 */
+	sp887x_writereg(state, 0x301, 0x002);
+
+	sp887x_setup_agc(state);
+
+	/* bit 0x010: enable data valid signal */
+	sp887x_writereg(state, 0xd00, 0x010);
+	sp887x_writereg(state, 0x0d1, 0x000);
+	return 0;
+};
+
+static int configure_reg0xc05(struct dtv_frontend_properties *p, u16 *reg0xc05)
+{
+	int known_parameters = 1;
+
+	*reg0xc05 = 0x000;
+
+	switch (p->modulation) {
+	case QPSK:
+		break;
+	case QAM_16:
+		*reg0xc05 |= (1 << 10);
+		break;
+	case QAM_64:
+		*reg0xc05 |= (2 << 10);
+		break;
+	case QAM_AUTO:
+		known_parameters = 0;
+		break;
+	default:
+		return -EINVAL;
+	};
+
+	switch (p->hierarchy) {
+	case HIERARCHY_NONE:
+		break;
+	case HIERARCHY_1:
+		*reg0xc05 |= (1 << 7);
+		break;
+	case HIERARCHY_2:
+		*reg0xc05 |= (2 << 7);
+		break;
+	case HIERARCHY_4:
+		*reg0xc05 |= (3 << 7);
+		break;
+	case HIERARCHY_AUTO:
+		known_parameters = 0;
+		break;
+	default:
+		return -EINVAL;
+	};
+
+	switch (p->code_rate_HP) {
+	case FEC_1_2:
+		break;
+	case FEC_2_3:
+		*reg0xc05 |= (1 << 3);
+		break;
+	case FEC_3_4:
+		*reg0xc05 |= (2 << 3);
+		break;
+	case FEC_5_6:
+		*reg0xc05 |= (3 << 3);
+		break;
+	case FEC_7_8:
+		*reg0xc05 |= (4 << 3);
+		break;
+	case FEC_AUTO:
+		known_parameters = 0;
+		break;
+	default:
+		return -EINVAL;
+	};
+
+	if (known_parameters)
+		*reg0xc05 |= (2 << 1);	/* use specified parameters */
+	else
+		*reg0xc05 |= (1 << 1);	/* enable autoprobing */
+
+	return 0;
+}
+
+/**
+ *  estimates division of two 24bit numbers,
+ *  derived from the ves1820/stv0299 driver code
+ */
+static void divide (int n, int d, int *quotient_i, int *quotient_f)
+{
+	unsigned int q, r;
+
+	r = (n % d) << 8;
+	q = (r / d);
+
+	if (quotient_i)
+		*quotient_i = q;
+
+	if (quotient_f) {
+		r = (r % d) << 8;
+		q = (q << 8) | (r / d);
+		r = (r % d) << 8;
+		*quotient_f = (q << 8) | (r / d);
+	}
+}
+
+static void sp887x_correct_offsets (struct sp887x_state* state,
+				    struct dtv_frontend_properties *p,
+				    int actual_freq)
+{
+	static const u32 srate_correction [] = { 1879617, 4544878, 8098561 };
+	int bw_index;
+	int freq_offset = actual_freq - p->frequency;
+	int sysclock = 61003; //[kHz]
+	int ifreq = 36000000;
+	int freq;
+	int frequency_shift;
+
+	switch (p->bandwidth_hz) {
+	default:
+	case 8000000:
+		bw_index = 0;
+		break;
+	case 7000000:
+		bw_index = 1;
+		break;
+	case 6000000:
+		bw_index = 2;
+		break;
+	}
+
+	if (p->inversion == INVERSION_ON)
+		freq = ifreq - freq_offset;
+	else
+		freq = ifreq + freq_offset;
+
+	divide(freq / 333, sysclock, NULL, &frequency_shift);
+
+	if (p->inversion == INVERSION_ON)
+		frequency_shift = -frequency_shift;
+
+	/* sample rate correction */
+	sp887x_writereg(state, 0x319, srate_correction[bw_index] >> 12);
+	sp887x_writereg(state, 0x31a, srate_correction[bw_index] & 0xfff);
+
+	/* carrier offset correction */
+	sp887x_writereg(state, 0x309, frequency_shift >> 12);
+	sp887x_writereg(state, 0x30a, frequency_shift & 0xfff);
+}
+
+static int sp887x_setup_frontend_parameters(struct dvb_frontend *fe)
+{
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+	struct sp887x_state* state = fe->demodulator_priv;
+	unsigned actual_freq;
+	int err;
+	u16 val, reg0xc05;
+
+	if (p->bandwidth_hz != 8000000 &&
+	    p->bandwidth_hz != 7000000 &&
+	    p->bandwidth_hz != 6000000)
+		return -EINVAL;
+
+	if ((err = configure_reg0xc05(p, &reg0xc05)))
+		return err;
+
+	sp887x_microcontroller_stop(state);
+
+	/* setup the PLL */
+	if (fe->ops.tuner_ops.set_params) {
+		fe->ops.tuner_ops.set_params(fe);
+		if (fe->ops.i2c_gate_ctrl) fe->ops.i2c_gate_ctrl(fe, 0);
+	}
+	if (fe->ops.tuner_ops.get_frequency) {
+		fe->ops.tuner_ops.get_frequency(fe, &actual_freq);
+		if (fe->ops.i2c_gate_ctrl) fe->ops.i2c_gate_ctrl(fe, 0);
+	} else {
+		actual_freq = p->frequency;
+	}
+
+	/* read status reg in order to clear <pending irqs */
+	sp887x_readreg(state, 0x200);
+
+	sp887x_correct_offsets(state, p, actual_freq);
+
+	/* filter for 6/7/8 Mhz channel */
+	if (p->bandwidth_hz == 6000000)
+		val = 2;
+	else if (p->bandwidth_hz == 7000000)
+		val = 1;
+	else
+		val = 0;
+
+	sp887x_writereg(state, 0x311, val);
+
+	/* scan order: 2k first = 0, 8k first = 1 */
+	if (p->transmission_mode == TRANSMISSION_MODE_2K)
+		sp887x_writereg(state, 0x338, 0x000);
+	else
+		sp887x_writereg(state, 0x338, 0x001);
+
+	sp887x_writereg(state, 0xc05, reg0xc05);
+
+	if (p->bandwidth_hz == 6000000)
+		val = 2 << 3;
+	else if (p->bandwidth_hz == 7000000)
+		val = 3 << 3;
+	else
+		val = 0 << 3;
+
+	/* enable OFDM and SAW bits as lock indicators in sync register 0xf17,
+	 * optimize algorithm for given bandwidth...
+	 */
+	sp887x_writereg(state, 0xf14, 0x160 | val);
+	sp887x_writereg(state, 0xf15, 0x000);
+
+	sp887x_microcontroller_start(state);
+	return 0;
+}
+
+static int sp887x_read_status(struct dvb_frontend* fe, fe_status_t* status)
+{
+	struct sp887x_state* state = fe->demodulator_priv;
+	u16 snr12 = sp887x_readreg(state, 0xf16);
+	u16 sync0x200 = sp887x_readreg(state, 0x200);
+	u16 sync0xf17 = sp887x_readreg(state, 0xf17);
+
+	*status = 0;
+
+	if (snr12 > 0x00f)
+		*status |= FE_HAS_SIGNAL;
+
+	//if (sync0x200 & 0x004)
+	//	*status |= FE_HAS_SYNC | FE_HAS_CARRIER;
+
+	//if (sync0x200 & 0x008)
+	//	*status |= FE_HAS_VITERBI;
+
+	if ((sync0xf17 & 0x00f) == 0x002) {
+		*status |= FE_HAS_LOCK;
+		*status |= FE_HAS_VITERBI | FE_HAS_SYNC | FE_HAS_CARRIER;
+	}
+
+	if (sync0x200 & 0x001) {	/* tuner adjustment requested...*/
+		int steps = (sync0x200 >> 4) & 0x00f;
+		if (steps & 0x008)
+			steps = -steps;
+		dprintk("sp887x: implement tuner adjustment (%+i steps)!!\n",
+		       steps);
+	}
+
+	return 0;
+}
+
+static int sp887x_read_ber(struct dvb_frontend* fe, u32* ber)
+{
+	struct sp887x_state* state = fe->demodulator_priv;
+
+	*ber = (sp887x_readreg(state, 0xc08) & 0x3f) |
+	       (sp887x_readreg(state, 0xc07) << 6);
+	sp887x_writereg(state, 0xc08, 0x000);
+	sp887x_writereg(state, 0xc07, 0x000);
+	if (*ber >= 0x3fff0)
+		*ber = ~0;
+
+	return 0;
+}
+
+static int sp887x_read_signal_strength(struct dvb_frontend* fe, u16* strength)
+{
+	struct sp887x_state* state = fe->demodulator_priv;
+
+	u16 snr12 = sp887x_readreg(state, 0xf16);
+	u32 signal = 3 * (snr12 << 4);
+	*strength = (signal < 0xffff) ? signal : 0xffff;
+
+	return 0;
+}
+
+static int sp887x_read_snr(struct dvb_frontend* fe, u16* snr)
+{
+	struct sp887x_state* state = fe->demodulator_priv;
+
+	u16 snr12 = sp887x_readreg(state, 0xf16);
+	*snr = (snr12 << 4) | (snr12 >> 8);
+
+	return 0;
+}
+
+static int sp887x_read_ucblocks(struct dvb_frontend* fe, u32* ucblocks)
+{
+	struct sp887x_state* state = fe->demodulator_priv;
+
+	*ucblocks = sp887x_readreg(state, 0xc0c);
+	if (*ucblocks == 0xfff)
+		*ucblocks = ~0;
+
+	return 0;
+}
+
+static int sp887x_i2c_gate_ctrl(struct dvb_frontend* fe, int enable)
+{
+	struct sp887x_state* state = fe->demodulator_priv;
+
+	if (enable) {
+		return sp887x_writereg(state, 0x206, 0x001);
+	} else {
+		return sp887x_writereg(state, 0x206, 0x000);
+	}
+}
+
+static int sp887x_sleep(struct dvb_frontend* fe)
+{
+	struct sp887x_state* state = fe->demodulator_priv;
+
+	/* tristate TS output and disable interface pins */
+	sp887x_writereg(state, 0xc18, 0x000);
+
+	return 0;
+}
+
+static int sp887x_init(struct dvb_frontend* fe)
+{
+	struct sp887x_state* state = fe->demodulator_priv;
+	const struct firmware *fw = NULL;
+	int ret;
+
+	if (!state->initialised) {
+		/* request the firmware, this will block until someone uploads it */
+		printk("sp887x: waiting for firmware upload (%s)...\n", SP887X_DEFAULT_FIRMWARE);
+		ret = state->config->request_firmware(fe, &fw, SP887X_DEFAULT_FIRMWARE);
+		if (ret) {
+			printk("sp887x: no firmware upload (timeout or file not found?)\n");
+			return ret;
+		}
+
+		ret = sp887x_initial_setup(fe, fw);
+		release_firmware(fw);
+		if (ret) {
+			printk("sp887x: writing firmware to device failed\n");
+			return ret;
+		}
+		printk("sp887x: firmware upload complete\n");
+		state->initialised = 1;
+	}
+
+	/* enable TS output and interface pins */
+	sp887x_writereg(state, 0xc18, 0x00d);
+
+	return 0;
+}
+
+static int sp887x_get_tune_settings(struct dvb_frontend* fe, struct dvb_frontend_tune_settings* fesettings)
+{
+	fesettings->min_delay_ms = 350;
+	fesettings->step_size = 166666*2;
+	fesettings->max_drift = (166666*2)+1;
+	return 0;
+}
+
+static void sp887x_release(struct dvb_frontend* fe)
+{
+	struct sp887x_state* state = fe->demodulator_priv;
+	kfree(state);
+}
+
+static struct dvb_frontend_ops sp887x_ops;
+
+struct dvb_frontend* sp887x_attach(const struct sp887x_config* config,
+				   struct i2c_adapter* i2c)
+{
+	struct sp887x_state* state = NULL;
+
+	/* allocate memory for the internal state */
+	state = kzalloc(sizeof(struct sp887x_state), GFP_KERNEL);
+	if (state == NULL) goto error;
+
+	/* setup the state */
+	state->config = config;
+	state->i2c = i2c;
+	state->initialised = 0;
+
+	/* check if the demod is there */
+	if (sp887x_readreg(state, 0x0200) < 0) goto error;
+
+	/* create dvb_frontend */
+	memcpy(&state->frontend.ops, &sp887x_ops, sizeof(struct dvb_frontend_ops));
+	state->frontend.demodulator_priv = state;
+	return &state->frontend;
+
+error:
+	kfree(state);
+	return NULL;
+}
+
+static struct dvb_frontend_ops sp887x_ops = {
+	.delsys = { SYS_DVBT },
+	.info = {
+		.name = "Spase SP887x DVB-T",
+		.frequency_min =  50500000,
+		.frequency_max = 858000000,
+		.frequency_stepsize = 166666,
+		.caps = FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |
+			FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |
+			FE_CAN_QPSK | FE_CAN_QAM_16 | FE_CAN_QAM_64 |
+			FE_CAN_RECOVER
+	},
+
+	.release = sp887x_release,
+
+	.init = sp887x_init,
+	.sleep = sp887x_sleep,
+	.i2c_gate_ctrl = sp887x_i2c_gate_ctrl,
+
+	.set_frontend = sp887x_setup_frontend_parameters,
+	.get_tune_settings = sp887x_get_tune_settings,
+
+	.read_status = sp887x_read_status,
+	.read_ber = sp887x_read_ber,
+	.read_signal_strength = sp887x_read_signal_strength,
+	.read_snr = sp887x_read_snr,
+	.read_ucblocks = sp887x_read_ucblocks,
+};
+
+module_param(debug, int, 0644);
+MODULE_PARM_DESC(debug, "Turn on/off frontend debugging (default:off).");
+
+MODULE_DESCRIPTION("Spase sp887x DVB-T demodulator driver");
+MODULE_LICENSE("GPL");
+
+EXPORT_SYMBOL(sp887x_attach);
