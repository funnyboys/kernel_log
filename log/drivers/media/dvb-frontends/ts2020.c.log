commit 2f507ffa9ca59535b204f43ec793e5c96394c4f4
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Mon Dec 16 16:51:32 2019 +0100

    media: dvb-frontends: ts2020: convert to use i2c_new_client_device()
    
    Use the newer API returning an ERRPTR and use the new helper to bail
    out.
    
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Signed-off-by: Sean Young <sean@mess.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+huawei@kernel.org>

diff --git a/drivers/media/dvb-frontends/ts2020.c b/drivers/media/dvb-frontends/ts2020.c
index 6c24d6d0d4c9..234607b02edb 100644
--- a/drivers/media/dvb-frontends/ts2020.c
+++ b/drivers/media/dvb-frontends/ts2020.c
@@ -519,8 +519,8 @@ struct dvb_frontend *ts2020_attach(struct dvb_frontend *fe,
 	strscpy(board_info.type, "ts2020", I2C_NAME_SIZE);
 	board_info.addr = config->tuner_address;
 	board_info.platform_data = &pdata;
-	client = i2c_new_device(i2c, &board_info);
-	if (!client || !client->dev.driver)
+	client = i2c_new_client_device(i2c, &board_info);
+	if (!i2c_client_has_driver(client))
 		return NULL;
 
 	return fe;

commit 74ba9207e1adf1966c57450340534ae9742d00af
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 20 09:19:02 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 61
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      675 mass ave cambridge ma 02139 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 441 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Michael Ellerman <mpe@ellerman.id.au> (powerpc)
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190520071858.739733335@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/media/dvb-frontends/ts2020.c b/drivers/media/dvb-frontends/ts2020.c
index 0af9b335be12..6c24d6d0d4c9 100644
--- a/drivers/media/dvb-frontends/ts2020.c
+++ b/drivers/media/dvb-frontends/ts2020.c
@@ -1,22 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
     Montage Technology TS2020 - Silicon Tuner driver
     Copyright (C) 2009-2012 Konstantin Dimitrov <kosio.dimitrov@gmail.com>
 
     Copyright (C) 2009-2012 TurboSight.com
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
 #include <media/dvb_frontend.h>

commit 37d1e62b5bb3b1229d0c49f2ee45e67dc67274be
Author: Yizhuo <yzhai003@ucr.edu>
Date:   Wed Jan 30 12:33:30 2019 -0500

    media: ts2020: Variable "utmp" in function ts2020_set_tuner_rf() could be uninitialized
    
    In function ts2020_set_tuner_rf(), local variable "utmp" could
    be uninitialized if function regmap_read() returns -EINVAL.
    However, this value is used in if statement and written to
    the register, which is potentially unsafe.
    
    Signed-off-by: Yizhuo <yzhai003@ucr.edu>
    Signed-off-by: Sean Young <sean@mess.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/dvb-frontends/ts2020.c b/drivers/media/dvb-frontends/ts2020.c
index e5cd2cd414f4..0af9b335be12 100644
--- a/drivers/media/dvb-frontends/ts2020.c
+++ b/drivers/media/dvb-frontends/ts2020.c
@@ -180,6 +180,9 @@ static int ts2020_set_tuner_rf(struct dvb_frontend *fe)
 	unsigned int utmp;
 
 	ret = regmap_read(dev->regmap, 0x3d, &utmp);
+	if (ret)
+		return ret;
+
 	utmp &= 0x7f;
 	if (utmp < 0x16)
 		utmp = 0xa1;

commit c0decac19da3906d9b66291e57b7759489e1170f
Author: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
Date:   Mon Sep 10 08:19:14 2018 -0400

    media: use strscpy() instead of strlcpy()
    
    The implementation of strscpy() is more robust and safer.
    
    That's now the recommended way to copy NUL terminated strings.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Acked-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/dvb-frontends/ts2020.c b/drivers/media/dvb-frontends/ts2020.c
index 3e3e40878633..e5cd2cd414f4 100644
--- a/drivers/media/dvb-frontends/ts2020.c
+++ b/drivers/media/dvb-frontends/ts2020.c
@@ -525,7 +525,7 @@ struct dvb_frontend *ts2020_attach(struct dvb_frontend *fe,
 	pdata.attach_in_use = true;
 
 	memset(&board_info, 0, sizeof(board_info));
-	strlcpy(board_info.type, "ts2020", I2C_NAME_SIZE);
+	strscpy(board_info.type, "ts2020", I2C_NAME_SIZE);
 	board_info.addr = config->tuner_address;
 	board_info.platform_data = &pdata;
 	client = i2c_new_device(i2c, &board_info);

commit a3f90c75b833caeff123499e13e0e31cbecf7d5b
Author: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
Date:   Thu Jul 5 18:59:35 2018 -0400

    media: dvb: convert tuner_info frequencies to Hz
    
    Right now, satellite tuner drivers specify frequencies in kHz,
    while terrestrial/cable ones specify in Hz. That's confusing
    for developers.
    
    However, the main problem is that universal tuners capable
    of handling both satellite and non-satelite delivery systems
    are appearing. We end by needing to hack the drivers in
    order to support such hybrid tuners.
    
    So, convert everything to specify tuner frequencies in Hz.
    
    Plese notice that a similar patch is also needed for frontends.
    
    Tested-by: Katsuhiro Suzuki <suzuki.katsuhiro@socionext.com>
    Acked-by: Michael BÃ¼sch <m@bues.ch>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/dvb-frontends/ts2020.c b/drivers/media/dvb-frontends/ts2020.c
index c55882a8da06..3e3e40878633 100644
--- a/drivers/media/dvb-frontends/ts2020.c
+++ b/drivers/media/dvb-frontends/ts2020.c
@@ -498,8 +498,8 @@ static int ts2020_read_signal_strength(struct dvb_frontend *fe,
 static const struct dvb_tuner_ops ts2020_tuner_ops = {
 	.info = {
 		.name = "TS2020",
-		.frequency_min = 950000,
-		.frequency_max = 2150000
+		.frequency_min_hz =  950 * MHz,
+		.frequency_max_hz = 2150 * MHz
 	},
 	.init = ts2020_init,
 	.release = ts2020_release,

commit 81742be14b6a90c9fd0ff6eb4218bdf696ad8e46
Author: Mauro Carvalho Chehab <mchehab@s-opensource.com>
Date:   Wed Jan 10 07:20:39 2018 -0500

    media: ts2020: avoid integer overflows on 32 bit machines
    
    Before this patch, when compiled for arm32, the signal strength
    were reported as:
    
    Lock   (0x1f) Signal= 4294908.66dBm C/N= 12.79dB
    
    Because of a 32 bit integer overflow. After it, it is properly
    reported as:
    
            Lock   (0x1f) Signal= -58.64dBm C/N= 12.79dB
    
    Cc: stable@vger.kernel.org
    Fixes: 0f91c9d6bab9 ("[media] TS2020: Calculate tuner gain correctly")
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/ts2020.c b/drivers/media/dvb-frontends/ts2020.c
index 07f1726a5774..c55882a8da06 100644
--- a/drivers/media/dvb-frontends/ts2020.c
+++ b/drivers/media/dvb-frontends/ts2020.c
@@ -368,7 +368,7 @@ static int ts2020_read_tuner_gain(struct dvb_frontend *fe, unsigned v_agc,
 		gain2 = clamp_t(long, gain2, 0, 13);
 		v_agc = clamp_t(long, v_agc, 400, 1100);
 
-		*_gain = -(gain1 * 2330 +
+		*_gain = -((__s64)gain1 * 2330 +
 			   gain2 * 3500 +
 			   v_agc * 24 / 10 * 10 +
 			   10000);
@@ -386,7 +386,7 @@ static int ts2020_read_tuner_gain(struct dvb_frontend *fe, unsigned v_agc,
 		gain3 = clamp_t(long, gain3, 0, 6);
 		v_agc = clamp_t(long, v_agc, 600, 1600);
 
-		*_gain = -(gain1 * 2650 +
+		*_gain = -((__s64)gain1 * 2650 +
 			   gain2 * 3380 +
 			   gain3 * 2850 +
 			   v_agc * 176 / 100 * 10 -

commit fada1935590f66dc6784981e0d557ca09013c847
Author: Mauro Carvalho Chehab <mchehab@s-opensource.com>
Date:   Thu Dec 28 13:03:51 2017 -0500

    media: move dvb kAPI headers to include/media
    
    Except for DVB, all media kAPI headers are at include/media.
    
    Move the headers to it.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/ts2020.c b/drivers/media/dvb-frontends/ts2020.c
index 931e5c98da8a..07f1726a5774 100644
--- a/drivers/media/dvb-frontends/ts2020.c
+++ b/drivers/media/dvb-frontends/ts2020.c
@@ -19,7 +19,7 @@
     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
-#include "dvb_frontend.h"
+#include <media/dvb_frontend.h>
 #include "ts2020.h"
 #include <linux/regmap.h>
 #include <linux/math64.h>

commit 194ced7a5a99b303daf0bca6d0a1697731265602
Author: Max Kellermann <max.kellermann@gmail.com>
Date:   Tue Aug 9 18:32:31 2016 -0300

    [media] dvb_frontend: tuner_ops.release returns void
    
    It is not clear what this return value means.  All implemenations
    return 0, and the one caller ignores the value.  Let's remove this
    useless return value completely.
    
    Signed-off-by: Max Kellermann <max.kellermann@gmail.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/ts2020.c b/drivers/media/dvb-frontends/ts2020.c
index a9f6bbea6df3..931e5c98da8a 100644
--- a/drivers/media/dvb-frontends/ts2020.c
+++ b/drivers/media/dvb-frontends/ts2020.c
@@ -56,7 +56,7 @@ struct ts2020_reg_val {
 
 static void ts2020_stat_work(struct work_struct *work);
 
-static int ts2020_release(struct dvb_frontend *fe)
+static void ts2020_release(struct dvb_frontend *fe)
 {
 	struct ts2020_priv *priv = fe->tuner_priv;
 	struct i2c_client *client = priv->client;
@@ -64,7 +64,6 @@ static int ts2020_release(struct dvb_frontend *fe)
 	dev_dbg(&client->dev, "\n");
 
 	i2c_unregister_device(client);
-	return 0;
 }
 
 static int ts2020_sleep(struct dvb_frontend *fe)

commit 14c4bf3c6f7d76d2b2b50cc82f6830d6948f6faa
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Sun Sep 11 11:44:12 2016 -0300

    [media] dvb-frontends: constify dvb_tuner_ops structures
    
    These structures are only used to copy into other structures, so declare
    them as const.
    
    The semantic patch that makes this change is as follows:
    (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @r disable optional_qualifier@
    identifier i;
    position p;
    @@
    static struct dvb_tuner_ops i@p = { ... };
    
    @ok1@
    identifier r.i;
    expression e;
    position p;
    @@
    e = i@p
    
    @ok2@
    identifier r.i;
    expression e1, e2;
    position p;
    @@
    memcpy(e1, &i@p, e2)
    
    @bad@
    position p != {r.p,ok1.p,ok2.p};
    identifier r.i;
    struct dvb_tuner_ops e;
    @@
    e@i@p
    
    @depends on !bad disable optional_qualifier@
    identifier r.i;
    @@
    static
    +const
     struct dvb_tuner_ops i = { ... };
    // </smpl>
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/ts2020.c b/drivers/media/dvb-frontends/ts2020.c
index 14b410ffe612..a9f6bbea6df3 100644
--- a/drivers/media/dvb-frontends/ts2020.c
+++ b/drivers/media/dvb-frontends/ts2020.c
@@ -496,7 +496,7 @@ static int ts2020_read_signal_strength(struct dvb_frontend *fe,
 	return 0;
 }
 
-static struct dvb_tuner_ops ts2020_tuner_ops = {
+static const struct dvb_tuner_ops ts2020_tuner_ops = {
 	.info = {
 		.name = "TS2020",
 		.frequency_min = 950000,

commit 41ff9142df375ac319b1d9fe50d88e4247da6f1a
Author: Ernst Martin Witte <emw-linux-kernel@nocabal.de>
Date:   Sat Jan 9 18:18:44 2016 -0200

    [media] ts2020: cancel_delayed_work_sync before device removal / kfree
    
    ts2020_remove  was  calling  kfree(dev)  with  possibly  still  active
    schedule_delayed_work(dev->stat_work).  A similar bug in si2157 caused
    kernel panics in call_timer_fn e.g. after rmmod cx23885.
    
    Signed-off-by: Ernst Martin Witte <emw-linux-kernel@nocabal.de>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/ts2020.c b/drivers/media/dvb-frontends/ts2020.c
index 7979e5d6498b..14b410ffe612 100644
--- a/drivers/media/dvb-frontends/ts2020.c
+++ b/drivers/media/dvb-frontends/ts2020.c
@@ -712,6 +712,10 @@ static int ts2020_remove(struct i2c_client *client)
 
 	dev_dbg(&client->dev, "\n");
 
+	/* stop statistics polling */
+	if (!dev->dont_poll)
+		cancel_delayed_work_sync(&dev->stat_work);
+
 	regmap_exit(dev->regmap);
 	kfree(dev);
 	return 0;

commit 04d8be053fbeac656f8db2acb768179be9997b0a
Author: Krzysztof Kozlowski <k.kozlowski@samsung.com>
Date:   Fri Jul 10 03:19:42 2015 -0300

    [media] dvb-frontends: Drop owner assignment from i2c_driver
    
    i2c_driver does not need to set an owner because i2c_register_driver()
    will set it.
    
    Signed-off-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/ts2020.c b/drivers/media/dvb-frontends/ts2020.c
index f61b143a0052..7979e5d6498b 100644
--- a/drivers/media/dvb-frontends/ts2020.c
+++ b/drivers/media/dvb-frontends/ts2020.c
@@ -726,7 +726,6 @@ MODULE_DEVICE_TABLE(i2c, ts2020_id_table);
 
 static struct i2c_driver ts2020_driver = {
 	.driver = {
-		.owner	= THIS_MODULE,
 		.name	= "ts2020",
 	},
 	.probe		= ts2020_probe,

commit 87b09bd048924f5b830d57f719b0c62ec25bac32
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Wed Jun 10 12:26:18 2015 -0300

    ts2020: fix compilation on i386
    
    drivers/built-in.o: In function `ts2020_read_signal_strength':
    ts2020.c:(.text+0x298ff94): undefined reference to `__divdi3'
    ts2020.c:(.text+0x298ffd4): undefined reference to `__divdi3'
    ts2020.c:(.text+0x298fffd): undefined reference to `__divdi3'
    Makefile:921: recipe for target 'vmlinux' failed
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/ts2020.c b/drivers/media/dvb-frontends/ts2020.c
index 946d8e9502fd..f61b143a0052 100644
--- a/drivers/media/dvb-frontends/ts2020.c
+++ b/drivers/media/dvb-frontends/ts2020.c
@@ -22,6 +22,7 @@
 #include "dvb_frontend.h"
 #include "ts2020.h"
 #include <linux/regmap.h>
+#include <linux/math64.h>
 
 #define TS2020_XTAL_FREQ   27000 /* in kHz */
 #define FREQ_OFFSET_LOW_SYM_RATE 3000
@@ -483,13 +484,13 @@ static int ts2020_read_signal_strength(struct dvb_frontend *fe,
 		strength = 0;
 	else if (gain < -65000)
 		/* 0% - 60%: weak signal */
-		strength = 0 + (85000 + gain) * 3 / 1000;
+		strength = 0 + div64_s64((85000 + gain) * 3, 1000);
 	else if (gain < -45000)
 		/* 60% - 90%: normal signal */
-		strength = 60 + (65000 + gain) * 3 / 2000;
+		strength = 60 + div64_s64((65000 + gain) * 3, 2000);
 	else
 		/* 90% - 99%: strong signal */
-		strength = 90 + (45000 + gain) / 5000;
+		strength = 90 + div64_s64((45000 + gain), 5000);
 
 	*_signal_strength = strength * 65535 / 100;
 	return 0;

commit c7275ae16114bd6be4cb83ee02bf801c303a2225
Author: David Howells <dhowells@redhat.com>
Date:   Wed Jun 3 08:35:08 2015 -0300

    [media] ts2020: Allow stats polling to be suppressed
    
    Statistics polling can not be done by lmedm04 driver's implementation of
    M88RS2000/TS2020 because I2C messages stop the device's demuxer, so allow
    polling for statistics to be suppressed in the ts2020 driver by setting
    dont_poll in the ts2020_config struct.
    
    Reported-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/ts2020.c b/drivers/media/dvb-frontends/ts2020.c
index 8c997d064beb..946d8e9502fd 100644
--- a/drivers/media/dvb-frontends/ts2020.c
+++ b/drivers/media/dvb-frontends/ts2020.c
@@ -40,6 +40,7 @@ struct ts2020_priv {
 	bool loop_through:1;
 	u8 clk_out:2;
 	u8 clk_out_div:5;
+	bool dont_poll:1;
 	u32 frequency_div; /* LO output divider switch frequency */
 	u32 frequency_khz; /* actual used LO frequency */
 #define TS2020_M88TS2020 0
@@ -52,6 +53,8 @@ struct ts2020_reg_val {
 	u8 val;
 };
 
+static void ts2020_stat_work(struct work_struct *work);
+
 static int ts2020_release(struct dvb_frontend *fe)
 {
 	struct ts2020_priv *priv = fe->tuner_priv;
@@ -79,7 +82,8 @@ static int ts2020_sleep(struct dvb_frontend *fe)
 		return ret;
 
 	/* stop statistics polling */
-	cancel_delayed_work_sync(&priv->stat_work);
+	if (!priv->dont_poll)
+		cancel_delayed_work_sync(&priv->stat_work);
 	return 0;
 }
 
@@ -152,8 +156,8 @@ static int ts2020_init(struct dvb_frontend *fe)
 	c->strength.stat[0].scale = FE_SCALE_DECIBEL;
 	c->strength.stat[0].uvalue = 0;
 
-	/* Start statistics polling */
-	schedule_delayed_work(&priv->stat_work, 0);
+	/* Start statistics polling by invoking the work function */
+	ts2020_stat_work(&priv->stat_work.work);
 	return 0;
 }
 
@@ -445,7 +449,8 @@ static void ts2020_stat_work(struct work_struct *work)
 
 	c->strength.stat[0].scale = FE_SCALE_DECIBEL;
 
-	schedule_delayed_work(&priv->stat_work, msecs_to_jiffies(2000));
+	if (!priv->dont_poll)
+		schedule_delayed_work(&priv->stat_work, msecs_to_jiffies(2000));
 	return;
 err:
 	dev_dbg(&client->dev, "failed=%d\n", ret);
@@ -458,9 +463,13 @@ static int ts2020_read_signal_strength(struct dvb_frontend *fe,
 				       u16 *_signal_strength)
 {
 	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	struct ts2020_priv *priv = fe->tuner_priv;
 	unsigned strength;
 	__s64 gain;
 
+	if (priv->dont_poll)
+		ts2020_stat_work(&priv->stat_work.work);
+
 	if (c->strength.stat[0].scale == FE_SCALE_NOT_AVAILABLE) {
 		*_signal_strength = 0;
 		return 0;
@@ -585,6 +594,7 @@ static int ts2020_probe(struct i2c_client *client,
 	dev->loop_through = pdata->loop_through;
 	dev->clk_out = pdata->clk_out;
 	dev->clk_out_div = pdata->clk_out_div;
+	dev->dont_poll = pdata->dont_poll;
 	dev->frequency_div = pdata->frequency_div;
 	dev->fe = fe;
 	dev->get_agc_pwm = pdata->get_agc_pwm;

commit 0f20baad24f97c3390ae869661408bb3ee12764e
Author: David Howells <dhowells@redhat.com>
Date:   Wed Jun 3 08:34:13 2015 -0300

    [media] ts2020: Copy loop_through from the config to the internal data
    
    Copy the loop_through setting from the ts2020_config struct to the internal
    ts2020_priv struct so that it can actually be used.
    
    Whilst we're at it, group the bitfields together in the same order in both
    structs so that the compiler has a good chance to copy them in one go.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/ts2020.c b/drivers/media/dvb-frontends/ts2020.c
index 80ae0397b05c..8c997d064beb 100644
--- a/drivers/media/dvb-frontends/ts2020.c
+++ b/drivers/media/dvb-frontends/ts2020.c
@@ -37,6 +37,7 @@ struct ts2020_priv {
 	/* i2c details */
 	struct i2c_adapter *i2c;
 	int i2c_address;
+	bool loop_through:1;
 	u8 clk_out:2;
 	u8 clk_out_div:5;
 	u32 frequency_div; /* LO output divider switch frequency */
@@ -44,7 +45,6 @@ struct ts2020_priv {
 #define TS2020_M88TS2020 0
 #define TS2020_M88TS2022 1
 	u8 tuner;
-	u8 loop_through:1;
 };
 
 struct ts2020_reg_val {
@@ -582,6 +582,7 @@ static int ts2020_probe(struct i2c_client *client,
 
 	dev->i2c = client->adapter;
 	dev->i2c_address = client->addr;
+	dev->loop_through = pdata->loop_through;
 	dev->clk_out = pdata->clk_out;
 	dev->clk_out_div = pdata->clk_out_div;
 	dev->frequency_div = pdata->frequency_div;

commit 3366cd5d72c664aa5e447f41ed2f7dac69f6a94e
Author: David Howells <dhowells@redhat.com>
Date:   Tue May 26 12:04:07 2015 -0300

    [media] ts2020: Provide DVBv5 API signal strength
    
    Provide a DVBv5 API signal strength.  This is in units of 0.001 dBm rather
    than a percentage.
    
    >From Antti Palosaari's testing with a signal generator, it appears that the
    gain calculated according to Montage's specification if negated is a
    reasonable representation of the signal strength of the generator.
    
    To this end:
    
     (1) Polled statistic gathering needed to be implemented in the TS2020 driver.
         This is done in the ts2020_stat_work() function.
    
     (2) The calculated gain is placed as the signal strength in the
         dtv_property_cache associated with the front end with the scale set to
         FE_SCALE_DECIBEL.
    
     (3) The DVBv3 format signal strength then needed to be calculated from the
         signal strength stored in the dtv_property_cache rather than accessing
         the value when ts2020_read_signal_strength() is called.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/ts2020.c b/drivers/media/dvb-frontends/ts2020.c
index 277e1cff627b..80ae0397b05c 100644
--- a/drivers/media/dvb-frontends/ts2020.c
+++ b/drivers/media/dvb-frontends/ts2020.c
@@ -32,10 +32,11 @@ struct ts2020_priv {
 	struct regmap_config regmap_config;
 	struct regmap *regmap;
 	struct dvb_frontend *fe;
+	struct delayed_work stat_work;
 	int (*get_agc_pwm)(struct dvb_frontend *fe, u8 *_agc_pwm);
 	/* i2c details */
-	int i2c_address;
 	struct i2c_adapter *i2c;
+	int i2c_address;
 	u8 clk_out:2;
 	u8 clk_out_div:5;
 	u32 frequency_div; /* LO output divider switch frequency */
@@ -65,6 +66,7 @@ static int ts2020_release(struct dvb_frontend *fe)
 static int ts2020_sleep(struct dvb_frontend *fe)
 {
 	struct ts2020_priv *priv = fe->tuner_priv;
+	int ret;
 	u8 u8tmp;
 
 	if (priv->tuner == TS2020_M88TS2020)
@@ -72,11 +74,18 @@ static int ts2020_sleep(struct dvb_frontend *fe)
 	else
 		u8tmp = 0x00;
 
-	return regmap_write(priv->regmap, u8tmp, 0x00);
+	ret = regmap_write(priv->regmap, u8tmp, 0x00);
+	if (ret < 0)
+		return ret;
+
+	/* stop statistics polling */
+	cancel_delayed_work_sync(&priv->stat_work);
+	return 0;
 }
 
 static int ts2020_init(struct dvb_frontend *fe)
 {
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
 	struct ts2020_priv *priv = fe->tuner_priv;
 	int i;
 	u8 u8tmp;
@@ -138,6 +147,13 @@ static int ts2020_init(struct dvb_frontend *fe)
 				     reg_vals[i].val);
 	}
 
+	/* Initialise v5 stats here */
+	c->strength.len = 1;
+	c->strength.stat[0].scale = FE_SCALE_DECIBEL;
+	c->strength.stat[0].uvalue = 0;
+
+	/* Start statistics polling */
+	schedule_delayed_work(&priv->stat_work, 0);
 	return 0;
 }
 
@@ -410,20 +426,47 @@ static int ts2020_get_tuner_gain(struct dvb_frontend *fe, __s64 *_gain)
 	return ts2020_read_tuner_gain(fe, v_agc, _gain);
 }
 
+/*
+ * Gather statistics on a regular basis
+ */
+static void ts2020_stat_work(struct work_struct *work)
+{
+	struct ts2020_priv *priv = container_of(work, struct ts2020_priv,
+					       stat_work.work);
+	struct i2c_client *client = priv->client;
+	struct dtv_frontend_properties *c = &priv->fe->dtv_property_cache;
+	int ret;
+
+	dev_dbg(&client->dev, "\n");
+
+	ret = ts2020_get_tuner_gain(priv->fe, &c->strength.stat[0].svalue);
+	if (ret < 0)
+		goto err;
+
+	c->strength.stat[0].scale = FE_SCALE_DECIBEL;
+
+	schedule_delayed_work(&priv->stat_work, msecs_to_jiffies(2000));
+	return;
+err:
+	dev_dbg(&client->dev, "failed=%d\n", ret);
+}
+
 /*
  * Read TS2020 signal strength in v3 format.
  */
 static int ts2020_read_signal_strength(struct dvb_frontend *fe,
-						u16 *signal_strength)
+				       u16 *_signal_strength)
 {
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
 	unsigned strength;
 	__s64 gain;
-	int ret;
 
-	/* Determine the total gain of the tuner */
-	ret = ts2020_get_tuner_gain(fe, &gain);
-	if (ret < 0)
-		return ret;
+	if (c->strength.stat[0].scale == FE_SCALE_NOT_AVAILABLE) {
+		*_signal_strength = 0;
+		return 0;
+	}
+
+	gain = c->strength.stat[0].svalue;
 
 	/* Calculate the signal strength based on the total gain of the tuner */
 	if (gain < -85000)
@@ -439,7 +482,7 @@ static int ts2020_read_signal_strength(struct dvb_frontend *fe,
 		/* 90% - 99%: strong signal */
 		strength = 90 + (45000 + gain) / 5000;
 
-	*signal_strength = strength * 65535 / 100;
+	*_signal_strength = strength * 65535 / 100;
 	return 0;
 }
 
@@ -546,6 +589,7 @@ static int ts2020_probe(struct i2c_client *client,
 	dev->get_agc_pwm = pdata->get_agc_pwm;
 	fe->tuner_priv = dev;
 	dev->client = client;
+	INIT_DELAYED_WORK(&dev->stat_work, ts2020_stat_work);
 
 	/* check if the tuner is there */
 	ret = regmap_read(dev->regmap, 0x00, &utmp);

commit 0f91c9d6bab956fe55c32f143b21cbcc3538f699
Author: David Howells <dhowells@redhat.com>
Date:   Tue May 26 12:04:00 2015 -0300

    [media] TS2020: Calculate tuner gain correctly
    
    The TS2020 and TS2022 tuners take an input from the demodulator indicating the
    AGC setting on that component that is then used to influence the tuner's own
    gain.  This should be taken into account when calculating the gain and signal
    strength.
    
    Further, the existing TS2020 driver miscalculates the signal strength as the
    result of its calculations can exceed the storage capacity of the 16-bit word
    used to return it to userspace.
    
    To this end:
    
     (1) Add a callback function (->get_agc_pwm()) in the ts2020_config struct that
         the tuner can call to get the AGC PWM value from the demodulator.
    
     (2) Modify the TS2020 driver to calculate the gain according to Montage's
         specification with the adjustment that we produce a negative value and
         scale it to 0.001dB units (which is what the DVBv5 API will require):
    
         (a) Callback to the demodulator to retrieve the AGC PWM value and then
             turn that into Vagc for incorporation in the calculations.  If the
             callback is unset, assume a Vagc of 0.
    
         (b) Calculate the tuner gain from a combination of Vagc and the tuner's RF
             gain and baseband gain settings.
    
     (3) Turn this into a percentage signal strength as per Montage's
         specification for return to userspace with the DVBv3 API.
    
     (4) Provide a function in the M88DS3103 demodulator driver that can be used to
         get the AGC PWM value on behalf of the tuner.
    
     (5) The ts2020_config.get_agc_pwm function should be set by the code that
         stitches together the drivers for each card.
    
         For the DVBSky cards that use the M88DS3103 with the TS2020 or the TS2022,
         set the get_agc_pwm function to point to m88ds3103_get_agc_pwm.
    
    I have tested this with a DVBSky S952 card which has an M88DS3103 and a TS2022.
    
    Thanks to Montage for providing access to information about the workings of
    these parts.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/ts2020.c b/drivers/media/dvb-frontends/ts2020.c
index f674717fa921..277e1cff627b 100644
--- a/drivers/media/dvb-frontends/ts2020.c
+++ b/drivers/media/dvb-frontends/ts2020.c
@@ -32,6 +32,7 @@ struct ts2020_priv {
 	struct regmap_config regmap_config;
 	struct regmap *regmap;
 	struct dvb_frontend *fe;
+	int (*get_agc_pwm)(struct dvb_frontend *fe, u8 *_agc_pwm);
 	/* i2c details */
 	int i2c_address;
 	struct i2c_adapter *i2c;
@@ -313,32 +314,132 @@ static int ts2020_get_if_frequency(struct dvb_frontend *fe, u32 *frequency)
 	return 0;
 }
 
-/* read TS2020 signal strength */
-static int ts2020_read_signal_strength(struct dvb_frontend *fe,
-						u16 *signal_strength)
+/*
+ * Get the tuner gain.
+ * @fe: The front end for which we're determining the gain
+ * @v_agc: The voltage of the AGC from the demodulator (0-2600mV)
+ * @_gain: Where to store the gain (in 0.001dB units)
+ *
+ * Returns 0 or a negative error code.
+ */
+static int ts2020_read_tuner_gain(struct dvb_frontend *fe, unsigned v_agc,
+				  __s64 *_gain)
 {
 	struct ts2020_priv *priv = fe->tuner_priv;
-	unsigned int utmp;
-	u16 sig_reading, sig_strength;
-	u8 rfgain, bbgain;
+	unsigned long gain1, gain2, gain3;
+	unsigned utmp;
+	int ret;
+
+	/* Read the RF gain */
+	ret = regmap_read(priv->regmap, 0x3d, &utmp);
+	if (ret < 0)
+		return ret;
+	gain1 = utmp & 0x1f;
+
+	/* Read the baseband gain */
+	ret = regmap_read(priv->regmap, 0x21, &utmp);
+	if (ret < 0)
+		return ret;
+	gain2 = utmp & 0x1f;
+
+	switch (priv->tuner) {
+	case TS2020_M88TS2020:
+		gain1 = clamp_t(long, gain1, 0, 15);
+		gain2 = clamp_t(long, gain2, 0, 13);
+		v_agc = clamp_t(long, v_agc, 400, 1100);
+
+		*_gain = -(gain1 * 2330 +
+			   gain2 * 3500 +
+			   v_agc * 24 / 10 * 10 +
+			   10000);
+		/* gain in range -19600 to -116850 in units of 0.001dB */
+		break;
+
+	case TS2020_M88TS2022:
+		ret = regmap_read(priv->regmap, 0x66, &utmp);
+		if (ret < 0)
+			return ret;
+		gain3 = (utmp >> 3) & 0x07;
+
+		gain1 = clamp_t(long, gain1, 0, 15);
+		gain2 = clamp_t(long, gain2, 2, 16);
+		gain3 = clamp_t(long, gain3, 0, 6);
+		v_agc = clamp_t(long, v_agc, 600, 1600);
+
+		*_gain = -(gain1 * 2650 +
+			   gain2 * 3380 +
+			   gain3 * 2850 +
+			   v_agc * 176 / 100 * 10 -
+			   30000);
+		/* gain in range -47320 to -158950 in units of 0.001dB */
+		break;
+	}
+
+	return 0;
+}
+
+/*
+ * Get the AGC information from the demodulator and use that to calculate the
+ * tuner gain.
+ */
+static int ts2020_get_tuner_gain(struct dvb_frontend *fe, __s64 *_gain)
+{
+	struct ts2020_priv *priv = fe->tuner_priv;
+	int v_agc = 0, ret;
+	u8 agc_pwm;
 
-	regmap_read(priv->regmap, 0x3d, &utmp);
-	rfgain = utmp & 0x1f;
-	regmap_read(priv->regmap, 0x21, &utmp);
-	bbgain = utmp & 0x1f;
+	/* Read the AGC PWM rate from the demodulator */
+	if (priv->get_agc_pwm) {
+		ret = priv->get_agc_pwm(fe, &agc_pwm);
+		if (ret < 0)
+			return ret;
 
-	if (rfgain > 15)
-		rfgain = 15;
-	if (bbgain > 13)
-		bbgain = 13;
+		switch (priv->tuner) {
+		case TS2020_M88TS2020:
+			v_agc = (int)agc_pwm * 20 - 1166;
+			break;
+		case TS2020_M88TS2022:
+			v_agc = (int)agc_pwm * 16 - 670;
+			break;
+		}
 
-	sig_reading = rfgain * 2 + bbgain * 3;
+		if (v_agc < 0)
+			v_agc = 0;
+	}
 
-	sig_strength = 40 + (64 - sig_reading) * 50 / 64 ;
+	return ts2020_read_tuner_gain(fe, v_agc, _gain);
+}
 
-	/* cook the value to be suitable for szap-s2 human readable output */
-	*signal_strength = sig_strength * 1000;
+/*
+ * Read TS2020 signal strength in v3 format.
+ */
+static int ts2020_read_signal_strength(struct dvb_frontend *fe,
+						u16 *signal_strength)
+{
+	unsigned strength;
+	__s64 gain;
+	int ret;
+
+	/* Determine the total gain of the tuner */
+	ret = ts2020_get_tuner_gain(fe, &gain);
+	if (ret < 0)
+		return ret;
+
+	/* Calculate the signal strength based on the total gain of the tuner */
+	if (gain < -85000)
+		/* 0%: no signal or weak signal */
+		strength = 0;
+	else if (gain < -65000)
+		/* 0% - 60%: weak signal */
+		strength = 0 + (85000 + gain) * 3 / 1000;
+	else if (gain < -45000)
+		/* 60% - 90%: normal signal */
+		strength = 60 + (65000 + gain) * 3 / 2000;
+	else
+		/* 90% - 99%: strong signal */
+		strength = 90 + (45000 + gain) / 5000;
 
+	*signal_strength = strength * 65535 / 100;
 	return 0;
 }
 
@@ -442,6 +543,7 @@ static int ts2020_probe(struct i2c_client *client,
 	dev->clk_out_div = pdata->clk_out_div;
 	dev->frequency_div = pdata->frequency_div;
 	dev->fe = fe;
+	dev->get_agc_pwm = pdata->get_agc_pwm;
 	fe->tuner_priv = dev;
 	dev->client = client;
 

commit 80868c8e5c04bb725e411b078881b65ebbecd142
Author: David Howells <dhowells@redhat.com>
Date:   Thu Apr 2 08:03:11 2015 -0300

    [media] ts2020: Add a comment about lifetime of on-stack pdata in ts2020_attach()
    
    ts2020_attach() allocates a variable pdata on the stack and then passes a
    pointer to it to i2c_new_device() which stashes the pointer in persistent
    structures.
    
    Add a comment to the effect that this isn't actually an error because the
    contents of the variable are only used in ts2020_probe() and this is only
    called ts2020_attach()'s stack frame exists.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/ts2020.c b/drivers/media/dvb-frontends/ts2020.c
index 797112bbbaa8..f674717fa921 100644
--- a/drivers/media/dvb-frontends/ts2020.c
+++ b/drivers/media/dvb-frontends/ts2020.c
@@ -363,6 +363,8 @@ struct dvb_frontend *ts2020_attach(struct dvb_frontend *fe,
 {
 	struct i2c_client *client;
 	struct i2c_board_info board_info;
+
+	/* This is only used by ts2020_probe() so can be on the stack */
 	struct ts2020_config pdata;
 
 	memcpy(&pdata, config, sizeof(pdata));

commit f158cbceb165f318a89a8bb831dc3ea27823b3f8
Author: Antti Palosaari <crope@iki.fi>
Date:   Fri Mar 27 18:14:25 2015 -0300

    [media] ts2020: convert to regmap I2C API
    
    Use regmap to cover I2C register access.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/ts2020.c b/drivers/media/dvb-frontends/ts2020.c
index 7b2f301b1d5c..797112bbbaa8 100644
--- a/drivers/media/dvb-frontends/ts2020.c
+++ b/drivers/media/dvb-frontends/ts2020.c
@@ -21,12 +21,16 @@
 
 #include "dvb_frontend.h"
 #include "ts2020.h"
+#include <linux/regmap.h>
 
 #define TS2020_XTAL_FREQ   27000 /* in kHz */
 #define FREQ_OFFSET_LOW_SYM_RATE 3000
 
 struct ts2020_priv {
 	struct i2c_client *client;
+	struct mutex regmap_mutex;
+	struct regmap_config regmap_config;
+	struct regmap *regmap;
 	struct dvb_frontend *fe;
 	/* i2c details */
 	int i2c_address;
@@ -57,74 +61,6 @@ static int ts2020_release(struct dvb_frontend *fe)
 	return 0;
 }
 
-static int ts2020_writereg(struct dvb_frontend *fe, int reg, int data)
-{
-	struct ts2020_priv *priv = fe->tuner_priv;
-	u8 buf[] = { reg, data };
-	struct i2c_msg msg[] = {
-		{
-			.addr = priv->i2c_address,
-			.flags = 0,
-			.buf = buf,
-			.len = 2
-		}
-	};
-	int err;
-
-	if (fe->ops.i2c_gate_ctrl)
-		fe->ops.i2c_gate_ctrl(fe, 1);
-
-	err = i2c_transfer(priv->i2c, msg, 1);
-	if (err != 1) {
-		printk(KERN_ERR
-		       "%s: writereg error(err == %i, reg == 0x%02x, value == 0x%02x)\n",
-		       __func__, err, reg, data);
-		return -EREMOTEIO;
-	}
-
-	if (fe->ops.i2c_gate_ctrl)
-		fe->ops.i2c_gate_ctrl(fe, 0);
-
-	return 0;
-}
-
-static int ts2020_readreg(struct dvb_frontend *fe, u8 reg)
-{
-	struct ts2020_priv *priv = fe->tuner_priv;
-	int ret;
-	u8 b0[] = { reg };
-	u8 b1[] = { 0 };
-	struct i2c_msg msg[] = {
-		{
-			.addr = priv->i2c_address,
-			.flags = 0,
-			.buf = b0,
-			.len = 1
-		}, {
-			.addr = priv->i2c_address,
-			.flags = I2C_M_RD,
-			.buf = b1,
-			.len = 1
-		}
-	};
-
-	if (fe->ops.i2c_gate_ctrl)
-		fe->ops.i2c_gate_ctrl(fe, 1);
-
-	ret = i2c_transfer(priv->i2c, msg, 2);
-
-	if (ret != 2) {
-		printk(KERN_ERR "%s: reg=0x%x(error=%d)\n",
-		       __func__, reg, ret);
-		return ret;
-	}
-
-	if (fe->ops.i2c_gate_ctrl)
-		fe->ops.i2c_gate_ctrl(fe, 0);
-
-	return b1[0];
-}
-
 static int ts2020_sleep(struct dvb_frontend *fe)
 {
 	struct ts2020_priv *priv = fe->tuner_priv;
@@ -135,7 +71,7 @@ static int ts2020_sleep(struct dvb_frontend *fe)
 	else
 		u8tmp = 0x00;
 
-	return ts2020_writereg(fe, u8tmp, 0x00);
+	return regmap_write(priv->regmap, u8tmp, 0x00);
 }
 
 static int ts2020_init(struct dvb_frontend *fe)
@@ -145,14 +81,14 @@ static int ts2020_init(struct dvb_frontend *fe)
 	u8 u8tmp;
 
 	if (priv->tuner == TS2020_M88TS2020) {
-		ts2020_writereg(fe, 0x42, 0x73);
-		ts2020_writereg(fe, 0x05, priv->clk_out_div);
-		ts2020_writereg(fe, 0x20, 0x27);
-		ts2020_writereg(fe, 0x07, 0x02);
-		ts2020_writereg(fe, 0x11, 0xff);
-		ts2020_writereg(fe, 0x60, 0xf9);
-		ts2020_writereg(fe, 0x08, 0x01);
-		ts2020_writereg(fe, 0x00, 0x41);
+		regmap_write(priv->regmap, 0x42, 0x73);
+		regmap_write(priv->regmap, 0x05, priv->clk_out_div);
+		regmap_write(priv->regmap, 0x20, 0x27);
+		regmap_write(priv->regmap, 0x07, 0x02);
+		regmap_write(priv->regmap, 0x11, 0xff);
+		regmap_write(priv->regmap, 0x60, 0xf9);
+		regmap_write(priv->regmap, 0x08, 0x01);
+		regmap_write(priv->regmap, 0x00, 0x41);
 	} else {
 		static const struct ts2020_reg_val reg_vals[] = {
 			{0x7d, 0x9d},
@@ -168,8 +104,8 @@ static int ts2020_init(struct dvb_frontend *fe)
 			{0x12, 0xa0},
 		};
 
-		ts2020_writereg(fe, 0x00, 0x01);
-		ts2020_writereg(fe, 0x00, 0x03);
+		regmap_write(priv->regmap, 0x00, 0x01);
+		regmap_write(priv->regmap, 0x00, 0x03);
 
 		switch (priv->clk_out) {
 		case TS2020_CLK_OUT_DISABLED:
@@ -177,7 +113,7 @@ static int ts2020_init(struct dvb_frontend *fe)
 			break;
 		case TS2020_CLK_OUT_ENABLED:
 			u8tmp = 0x70;
-			ts2020_writereg(fe, 0x05, priv->clk_out_div);
+			regmap_write(priv->regmap, 0x05, priv->clk_out_div);
 			break;
 		case TS2020_CLK_OUT_ENABLED_XTALOUT:
 			u8tmp = 0x6c;
@@ -187,17 +123,18 @@ static int ts2020_init(struct dvb_frontend *fe)
 			break;
 		}
 
-		ts2020_writereg(fe, 0x42, u8tmp);
+		regmap_write(priv->regmap, 0x42, u8tmp);
 
 		if (priv->loop_through)
 			u8tmp = 0xec;
 		else
 			u8tmp = 0x6c;
 
-		ts2020_writereg(fe, 0x62, u8tmp);
+		regmap_write(priv->regmap, 0x62, u8tmp);
 
 		for (i = 0; i < ARRAY_SIZE(reg_vals); i++)
-			ts2020_writereg(fe, reg_vals[i].reg, reg_vals[i].val);
+			regmap_write(priv->regmap, reg_vals[i].reg,
+				     reg_vals[i].val);
 	}
 
 	return 0;
@@ -205,32 +142,35 @@ static int ts2020_init(struct dvb_frontend *fe)
 
 static int ts2020_tuner_gate_ctrl(struct dvb_frontend *fe, u8 offset)
 {
+	struct ts2020_priv *priv = fe->tuner_priv;
 	int ret;
-	ret = ts2020_writereg(fe, 0x51, 0x1f - offset);
-	ret |= ts2020_writereg(fe, 0x51, 0x1f);
-	ret |= ts2020_writereg(fe, 0x50, offset);
-	ret |= ts2020_writereg(fe, 0x50, 0x00);
+	ret = regmap_write(priv->regmap, 0x51, 0x1f - offset);
+	ret |= regmap_write(priv->regmap, 0x51, 0x1f);
+	ret |= regmap_write(priv->regmap, 0x50, offset);
+	ret |= regmap_write(priv->regmap, 0x50, 0x00);
 	msleep(20);
 	return ret;
 }
 
 static int ts2020_set_tuner_rf(struct dvb_frontend *fe)
 {
-	int reg;
-
-	reg = ts2020_readreg(fe, 0x3d);
-	reg &= 0x7f;
-	if (reg < 0x16)
-		reg = 0xa1;
-	else if (reg == 0x16)
-		reg = 0x99;
+	struct ts2020_priv *dev = fe->tuner_priv;
+	int ret;
+	unsigned int utmp;
+
+	ret = regmap_read(dev->regmap, 0x3d, &utmp);
+	utmp &= 0x7f;
+	if (utmp < 0x16)
+		utmp = 0xa1;
+	else if (utmp == 0x16)
+		utmp = 0x99;
 	else
-		reg = 0xf9;
+		utmp = 0xf9;
 
-	ts2020_writereg(fe, 0x60, reg);
-	reg = ts2020_tuner_gate_ctrl(fe, 0x08);
+	regmap_write(dev->regmap, 0x60, utmp);
+	ret = ts2020_tuner_gate_ctrl(fe, 0x08);
 
-	return reg;
+	return ret;
 }
 
 static int ts2020_set_params(struct dvb_frontend *fe)
@@ -238,6 +178,7 @@ static int ts2020_set_params(struct dvb_frontend *fe)
 	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
 	struct ts2020_priv *priv = fe->tuner_priv;
 	int ret;
+	unsigned int utmp;
 	u32 f3db, gdiv28;
 	u16 u16tmp, value, lpf_coeff;
 	u8 buf[3], reg10, lpf_mxdiv, mlpf_max, mlpf_min, nlpf;
@@ -272,12 +213,12 @@ static int ts2020_set_params(struct dvb_frontend *fe)
 	if (priv->tuner == TS2020_M88TS2020) {
 		lpf_coeff = 2766;
 		reg10 |= 0x01;
-		ret = ts2020_writereg(fe, 0x10, reg10);
+		ret = regmap_write(priv->regmap, 0x10, reg10);
 	} else {
 		lpf_coeff = 3200;
 		reg10 |= 0x0b;
-		ret = ts2020_writereg(fe, 0x10, reg10);
-		ret |= ts2020_writereg(fe, 0x11, 0x40);
+		ret = regmap_write(priv->regmap, 0x10, reg10);
+		ret |= regmap_write(priv->regmap, 0x11, 0x40);
 	}
 
 	u16tmp = pll_n - 1024;
@@ -285,9 +226,9 @@ static int ts2020_set_params(struct dvb_frontend *fe)
 	buf[1] = (u16tmp >> 0) & 0xff;
 	buf[2] = div_ref - 8;
 
-	ret |= ts2020_writereg(fe, 0x01, buf[0]);
-	ret |= ts2020_writereg(fe, 0x02, buf[1]);
-	ret |= ts2020_writereg(fe, 0x03, buf[2]);
+	ret |= regmap_write(priv->regmap, 0x01, buf[0]);
+	ret |= regmap_write(priv->regmap, 0x02, buf[1]);
+	ret |= regmap_write(priv->regmap, 0x03, buf[2]);
 
 	ret |= ts2020_tuner_gate_ctrl(fe, 0x10);
 	if (ret < 0)
@@ -300,21 +241,22 @@ static int ts2020_set_params(struct dvb_frontend *fe)
 		ret |= ts2020_set_tuner_rf(fe);
 
 	gdiv28 = (TS2020_XTAL_FREQ / 1000 * 1694 + 500) / 1000;
-	ret |= ts2020_writereg(fe, 0x04, gdiv28 & 0xff);
+	ret |= regmap_write(priv->regmap, 0x04, gdiv28 & 0xff);
 	ret |= ts2020_tuner_gate_ctrl(fe, 0x04);
 	if (ret < 0)
 		return -ENODEV;
 
 	if (priv->tuner == TS2020_M88TS2022) {
-		ret = ts2020_writereg(fe, 0x25, 0x00);
-		ret |= ts2020_writereg(fe, 0x27, 0x70);
-		ret |= ts2020_writereg(fe, 0x41, 0x09);
-		ret |= ts2020_writereg(fe, 0x08, 0x0b);
+		ret = regmap_write(priv->regmap, 0x25, 0x00);
+		ret |= regmap_write(priv->regmap, 0x27, 0x70);
+		ret |= regmap_write(priv->regmap, 0x41, 0x09);
+		ret |= regmap_write(priv->regmap, 0x08, 0x0b);
 		if (ret < 0)
 			return -ENODEV;
 	}
 
-	value = ts2020_readreg(fe, 0x26);
+	regmap_read(priv->regmap, 0x26, &utmp);
+	value = utmp;
 
 	f3db = (c->bandwidth_hz / 1000 / 2) + 2000;
 	f3db += FREQ_OFFSET_LOW_SYM_RATE; /* FIXME: ~always too wide filter */
@@ -345,8 +287,8 @@ static int ts2020_set_params(struct dvb_frontend *fe)
 	if (lpf_mxdiv > mlpf_max)
 		lpf_mxdiv = mlpf_max;
 
-	ret = ts2020_writereg(fe, 0x04, lpf_mxdiv);
-	ret |= ts2020_writereg(fe, 0x06, nlpf);
+	ret = regmap_write(priv->regmap, 0x04, lpf_mxdiv);
+	ret |= regmap_write(priv->regmap, 0x06, nlpf);
 
 	ret |= ts2020_tuner_gate_ctrl(fe, 0x04);
 
@@ -375,11 +317,15 @@ static int ts2020_get_if_frequency(struct dvb_frontend *fe, u32 *frequency)
 static int ts2020_read_signal_strength(struct dvb_frontend *fe,
 						u16 *signal_strength)
 {
+	struct ts2020_priv *priv = fe->tuner_priv;
+	unsigned int utmp;
 	u16 sig_reading, sig_strength;
 	u8 rfgain, bbgain;
 
-	rfgain = ts2020_readreg(fe, 0x3d) & 0x1f;
-	bbgain = ts2020_readreg(fe, 0x21) & 0x1f;
+	regmap_read(priv->regmap, 0x3d, &utmp);
+	rfgain = utmp & 0x1f;
+	regmap_read(priv->regmap, 0x21, &utmp);
+	bbgain = utmp & 0x1f;
 
 	if (rfgain > 15)
 		rfgain = 15;
@@ -435,6 +381,29 @@ struct dvb_frontend *ts2020_attach(struct dvb_frontend *fe,
 }
 EXPORT_SYMBOL(ts2020_attach);
 
+/*
+ * We implement own regmap locking due to legacy DVB attach which uses frontend
+ * gate control callback to control I2C bus access. We can open / close gate and
+ * serialize whole open / I2C-operation / close sequence at the same.
+ */
+static void ts2020_regmap_lock(void *__dev)
+{
+	struct ts2020_priv *dev = __dev;
+
+	mutex_lock(&dev->regmap_mutex);
+	if (dev->fe->ops.i2c_gate_ctrl)
+		dev->fe->ops.i2c_gate_ctrl(dev->fe, 1);
+}
+
+static void ts2020_regmap_unlock(void *__dev)
+{
+	struct ts2020_priv *dev = __dev;
+
+	if (dev->fe->ops.i2c_gate_ctrl)
+		dev->fe->ops.i2c_gate_ctrl(dev->fe, 0);
+	mutex_unlock(&dev->regmap_mutex);
+}
+
 static int ts2020_probe(struct i2c_client *client,
 		const struct i2c_device_id *id)
 {
@@ -452,6 +421,19 @@ static int ts2020_probe(struct i2c_client *client,
 		goto err;
 	}
 
+	/* create regmap */
+	mutex_init(&dev->regmap_mutex);
+	dev->regmap_config.reg_bits = 8,
+	dev->regmap_config.val_bits = 8,
+	dev->regmap_config.lock = ts2020_regmap_lock,
+	dev->regmap_config.unlock = ts2020_regmap_unlock,
+	dev->regmap_config.lock_arg = dev,
+	dev->regmap = regmap_init_i2c(client, &dev->regmap_config);
+	if (IS_ERR(dev->regmap)) {
+		ret = PTR_ERR(dev->regmap);
+		goto err_kfree;
+	}
+
 	dev->i2c = client->adapter;
 	dev->i2c_address = client->addr;
 	dev->clk_out = pdata->clk_out;
@@ -462,29 +444,27 @@ static int ts2020_probe(struct i2c_client *client,
 	dev->client = client;
 
 	/* check if the tuner is there */
-	ret = ts2020_readreg(fe, 0x00);
-	if (ret < 0)
-		goto err;
-	utmp = ret;
+	ret = regmap_read(dev->regmap, 0x00, &utmp);
+	if (ret)
+		goto err_regmap_exit;
 
 	if ((utmp & 0x03) == 0x00) {
-		ret = ts2020_writereg(fe, 0x00, 0x01);
+		ret = regmap_write(dev->regmap, 0x00, 0x01);
 		if (ret)
-			goto err;
+			goto err_regmap_exit;
 
 		usleep_range(2000, 50000);
 	}
 
-	ret = ts2020_writereg(fe, 0x00, 0x03);
+	ret = regmap_write(dev->regmap, 0x00, 0x03);
 	if (ret)
-		goto err;
+		goto err_regmap_exit;
 
 	usleep_range(2000, 50000);
 
-	ret = ts2020_readreg(fe, 0x00);
-	if (ret < 0)
-		goto err;
-	utmp = ret;
+	ret = regmap_read(dev->regmap, 0x00, &utmp);
+	if (ret)
+		goto err_regmap_exit;
 
 	dev_dbg(&client->dev, "chip_id=%02x\n", utmp);
 
@@ -506,7 +486,7 @@ static int ts2020_probe(struct i2c_client *client,
 		break;
 	default:
 		ret = -ENODEV;
-		goto err;
+		goto err_regmap_exit;
 	}
 
 	if (dev->tuner == TS2020_M88TS2022) {
@@ -516,36 +496,36 @@ static int ts2020_probe(struct i2c_client *client,
 			break;
 		case TS2020_CLK_OUT_ENABLED:
 			u8tmp = 0x70;
-			ret = ts2020_writereg(fe, 0x05, dev->clk_out_div);
+			ret = regmap_write(dev->regmap, 0x05, dev->clk_out_div);
 			if (ret)
-				goto err;
+				goto err_regmap_exit;
 			break;
 		case TS2020_CLK_OUT_ENABLED_XTALOUT:
 			u8tmp = 0x6c;
 			break;
 		default:
 			ret = -EINVAL;
-			goto err;
+			goto err_regmap_exit;
 		}
 
-		ret = ts2020_writereg(fe, 0x42, u8tmp);
+		ret = regmap_write(dev->regmap, 0x42, u8tmp);
 		if (ret)
-			goto err;
+			goto err_regmap_exit;
 
 		if (dev->loop_through)
 			u8tmp = 0xec;
 		else
 			u8tmp = 0x6c;
 
-		ret = ts2020_writereg(fe, 0x62, u8tmp);
+		ret = regmap_write(dev->regmap, 0x62, u8tmp);
 		if (ret)
-			goto err;
+			goto err_regmap_exit;
 	}
 
 	/* sleep */
-	ret = ts2020_writereg(fe, 0x00, 0x00);
+	ret = regmap_write(dev->regmap, 0x00, 0x00);
 	if (ret)
-		goto err;
+		goto err_regmap_exit;
 
 	dev_info(&client->dev,
 		 "Montage Technology %s successfully identified\n", chip_str);
@@ -557,9 +537,12 @@ static int ts2020_probe(struct i2c_client *client,
 
 	i2c_set_clientdata(client, dev);
 	return 0;
+err_regmap_exit:
+	regmap_exit(dev->regmap);
+err_kfree:
+	kfree(dev);
 err:
 	dev_dbg(&client->dev, "failed=%d\n", ret);
-	kfree(dev);
 	return ret;
 }
 
@@ -569,6 +552,7 @@ static int ts2020_remove(struct i2c_client *client)
 
 	dev_dbg(&client->dev, "\n");
 
+	regmap_exit(dev->regmap);
 	kfree(dev);
 	return 0;
 }

commit e6ad9ce3e96bb446c6cf0e83a43888e7f30b84ad
Author: Antti Palosaari <crope@iki.fi>
Date:   Thu Mar 26 20:20:42 2015 -0300

    [media] ts2020: register I2C driver from legacy media attach
    
    Register driver using I2C bindings internally when legacy media
    attach is used. That is done by registering driver using I2C binding
    from legacy attach. That way we can get valid I2C client, which is
    needed for proper dev_() logging and regmap for example even legacy
    binding is used.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/ts2020.c b/drivers/media/dvb-frontends/ts2020.c
index 590f7e1b56f3..7b2f301b1d5c 100644
--- a/drivers/media/dvb-frontends/ts2020.c
+++ b/drivers/media/dvb-frontends/ts2020.c
@@ -26,6 +26,7 @@
 #define FREQ_OFFSET_LOW_SYM_RATE 3000
 
 struct ts2020_priv {
+	struct i2c_client *client;
 	struct dvb_frontend *fe;
 	/* i2c details */
 	int i2c_address;
@@ -47,8 +48,12 @@ struct ts2020_reg_val {
 
 static int ts2020_release(struct dvb_frontend *fe)
 {
-	kfree(fe->tuner_priv);
-	fe->tuner_priv = NULL;
+	struct ts2020_priv *priv = fe->tuner_priv;
+	struct i2c_client *client = priv->client;
+
+	dev_dbg(&client->dev, "\n");
+
+	i2c_unregister_device(client);
 	return 0;
 }
 
@@ -410,50 +415,22 @@ struct dvb_frontend *ts2020_attach(struct dvb_frontend *fe,
 					const struct ts2020_config *config,
 					struct i2c_adapter *i2c)
 {
-	struct ts2020_priv *priv = NULL;
-	u8 buf;
-
-	priv = kzalloc(sizeof(struct ts2020_priv), GFP_KERNEL);
-	if (priv == NULL)
+	struct i2c_client *client;
+	struct i2c_board_info board_info;
+	struct ts2020_config pdata;
+
+	memcpy(&pdata, config, sizeof(pdata));
+	pdata.fe = fe;
+	pdata.attach_in_use = true;
+
+	memset(&board_info, 0, sizeof(board_info));
+	strlcpy(board_info.type, "ts2020", I2C_NAME_SIZE);
+	board_info.addr = config->tuner_address;
+	board_info.platform_data = &pdata;
+	client = i2c_new_device(i2c, &board_info);
+	if (!client || !client->dev.driver)
 		return NULL;
 
-	priv->i2c_address = config->tuner_address;
-	priv->i2c = i2c;
-	priv->clk_out = config->clk_out;
-	priv->clk_out_div = config->clk_out_div;
-	priv->frequency_div = config->frequency_div;
-	priv->fe = fe;
-	fe->tuner_priv = priv;
-
-	if (!priv->frequency_div)
-		priv->frequency_div = 1060000;
-
-	/* Wake Up the tuner */
-	if ((0x03 & ts2020_readreg(fe, 0x00)) == 0x00) {
-		ts2020_writereg(fe, 0x00, 0x01);
-		msleep(2);
-	}
-
-	ts2020_writereg(fe, 0x00, 0x03);
-	msleep(2);
-
-	/* Check the tuner version */
-	buf = ts2020_readreg(fe, 0x00);
-	if ((buf == 0x01) || (buf == 0x41) || (buf == 0x81)) {
-		printk(KERN_INFO "%s: Find tuner TS2020!\n", __func__);
-		priv->tuner = TS2020_M88TS2020;
-	} else if ((buf == 0x83) || (buf == 0xc3)) {
-		printk(KERN_INFO "%s: Find tuner TS2022!\n", __func__);
-		priv->tuner = TS2020_M88TS2022;
-	} else {
-		printk(KERN_ERR "%s: Read tuner reg[0] = %d\n", __func__, buf);
-		kfree(priv);
-		return NULL;
-	}
-
-	memcpy(&fe->ops.tuner_ops, &ts2020_tuner_ops,
-				sizeof(struct dvb_tuner_ops));
-
 	return fe;
 }
 EXPORT_SYMBOL(ts2020_attach);
@@ -482,6 +459,7 @@ static int ts2020_probe(struct i2c_client *client,
 	dev->frequency_div = pdata->frequency_div;
 	dev->fe = fe;
 	fe->tuner_priv = dev;
+	dev->client = client;
 
 	/* check if the tuner is there */
 	ret = ts2020_readreg(fe, 0x00);
@@ -574,7 +552,8 @@ static int ts2020_probe(struct i2c_client *client,
 
 	memcpy(&fe->ops.tuner_ops, &ts2020_tuner_ops,
 			sizeof(struct dvb_tuner_ops));
-	fe->ops.tuner_ops.release = NULL;
+	if (!pdata->attach_in_use)
+		fe->ops.tuner_ops.release = NULL;
 
 	i2c_set_clientdata(client, dev);
 	return 0;
@@ -587,14 +566,10 @@ static int ts2020_probe(struct i2c_client *client,
 static int ts2020_remove(struct i2c_client *client)
 {
 	struct ts2020_priv *dev = i2c_get_clientdata(client);
-	struct dvb_frontend *fe = dev->fe;
 
 	dev_dbg(&client->dev, "\n");
 
-	memset(&fe->ops.tuner_ops, 0, sizeof(struct dvb_tuner_ops));
-	fe->tuner_priv = NULL;
 	kfree(dev);
-
 	return 0;
 }
 

commit 2ca58f45cc986952dc2b2942fb170d9d7644735a
Author: Antti Palosaari <crope@iki.fi>
Date:   Thu Mar 26 10:49:17 2015 -0300

    [media] ts2020: improve filter limit calc
    
    * We don't need calculate channel bandwidth from symbol rate as it
    is calculated by DVB core.
    
    * Use clamp() to force upper/lower limit of filter 3dB frequency.
    Upper limit should never exceeded 40MHz (80MHz BW) in any case,
    though...
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/ts2020.c b/drivers/media/dvb-frontends/ts2020.c
index bc48388906d3..590f7e1b56f3 100644
--- a/drivers/media/dvb-frontends/ts2020.c
+++ b/drivers/media/dvb-frontends/ts2020.c
@@ -233,7 +233,6 @@ static int ts2020_set_params(struct dvb_frontend *fe)
 	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
 	struct ts2020_priv *priv = fe->tuner_priv;
 	int ret;
-	u32 symbol_rate = (c->symbol_rate / 1000);
 	u32 f3db, gdiv28;
 	u16 u16tmp, value, lpf_coeff;
 	u8 buf[3], reg10, lpf_mxdiv, mlpf_max, mlpf_min, nlpf;
@@ -312,12 +311,9 @@ static int ts2020_set_params(struct dvb_frontend *fe)
 
 	value = ts2020_readreg(fe, 0x26);
 
-	f3db = (symbol_rate * 135) / 200 + 2000;
-	f3db += FREQ_OFFSET_LOW_SYM_RATE;
-	if (f3db < 7000)
-		f3db = 7000;
-	if (f3db > 40000)
-		f3db = 40000;
+	f3db = (c->bandwidth_hz / 1000 / 2) + 2000;
+	f3db += FREQ_OFFSET_LOW_SYM_RATE; /* FIXME: ~always too wide filter */
+	f3db = clamp(f3db, 7000U, 40000U);
 
 	gdiv28 = gdiv28 * 207 / (value * 2 + 151);
 	mlpf_max = gdiv28 * 135 / 100;

commit af9d52555304979c7a3ce254e026bc76bd878f74
Author: Antti Palosaari <crope@iki.fi>
Date:   Thu Mar 26 10:04:09 2015 -0300

    [media] ts2020: re-implement PLL calculations
    
    Used frequency synthesizer is simple Integer-N PLL, with configurable
    reference divider, output divider and of course N itself. Old
    calculations were working fine, but not so easy to understand.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/ts2020.c b/drivers/media/dvb-frontends/ts2020.c
index 90164a38cd36..bc48388906d3 100644
--- a/drivers/media/dvb-frontends/ts2020.c
+++ b/drivers/media/dvb-frontends/ts2020.c
@@ -32,8 +32,8 @@ struct ts2020_priv {
 	struct i2c_adapter *i2c;
 	u8 clk_out:2;
 	u8 clk_out_div:5;
-	u32 frequency;
-	u32 frequency_div;
+	u32 frequency_div; /* LO output divider switch frequency */
+	u32 frequency_khz; /* actual used LO frequency */
 #define TS2020_M88TS2020 0
 #define TS2020_M88TS2022 1
 	u8 tuner;
@@ -233,45 +233,62 @@ static int ts2020_set_params(struct dvb_frontend *fe)
 	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
 	struct ts2020_priv *priv = fe->tuner_priv;
 	int ret;
-	u32 frequency = c->frequency;
-	s32 offset_khz;
 	u32 symbol_rate = (c->symbol_rate / 1000);
 	u32 f3db, gdiv28;
-	u16 value, ndiv, lpf_coeff;
-	u8 lpf_mxdiv, mlpf_max, mlpf_min, nlpf;
-	u8 lo = 0x01, div4 = 0x0;
-
-	/* Calculate frequency divider */
-	if (frequency < priv->frequency_div) {
-		lo |= 0x10;
-		div4 = 0x1;
-		ndiv = (frequency * 14 * 4) / TS2020_XTAL_FREQ;
-	} else
-		ndiv = (frequency * 14 * 2) / TS2020_XTAL_FREQ;
-	ndiv = ndiv + ndiv % 2;
-	ndiv = ndiv - 1024;
+	u16 u16tmp, value, lpf_coeff;
+	u8 buf[3], reg10, lpf_mxdiv, mlpf_max, mlpf_min, nlpf;
+	unsigned int f_ref_khz, f_vco_khz, div_ref, div_out, pll_n;
+	unsigned int frequency_khz = c->frequency;
+
+	/*
+	 * Integer-N PLL synthesizer
+	 * kHz is used for all calculations to keep calculations within 32-bit
+	 */
+	f_ref_khz = TS2020_XTAL_FREQ;
+	div_ref = DIV_ROUND_CLOSEST(f_ref_khz, 2000);
+
+	/* select LO output divider */
+	if (frequency_khz < priv->frequency_div) {
+		div_out = 4;
+		reg10 = 0x10;
+	} else {
+		div_out = 2;
+		reg10 = 0x00;
+	}
+
+	f_vco_khz = frequency_khz * div_out;
+	pll_n = f_vco_khz * div_ref / f_ref_khz;
+	pll_n += pll_n % 2;
+	priv->frequency_khz = pll_n * f_ref_khz / div_ref / div_out;
+
+	pr_debug("frequency=%u offset=%d f_vco_khz=%u pll_n=%u div_ref=%u div_out=%u\n",
+		 priv->frequency_khz, priv->frequency_khz - c->frequency,
+		 f_vco_khz, pll_n, div_ref, div_out);
 
 	if (priv->tuner == TS2020_M88TS2020) {
 		lpf_coeff = 2766;
-		ret = ts2020_writereg(fe, 0x10, 0x80 | lo);
+		reg10 |= 0x01;
+		ret = ts2020_writereg(fe, 0x10, reg10);
 	} else {
 		lpf_coeff = 3200;
-		ret = ts2020_writereg(fe, 0x10, 0x0b);
+		reg10 |= 0x0b;
+		ret = ts2020_writereg(fe, 0x10, reg10);
 		ret |= ts2020_writereg(fe, 0x11, 0x40);
 	}
 
-	/* Set frequency divider */
-	ret |= ts2020_writereg(fe, 0x01, (ndiv >> 8) & 0xf);
-	ret |= ts2020_writereg(fe, 0x02, ndiv & 0xff);
+	u16tmp = pll_n - 1024;
+	buf[0] = (u16tmp >> 8) & 0xff;
+	buf[1] = (u16tmp >> 0) & 0xff;
+	buf[2] = div_ref - 8;
+
+	ret |= ts2020_writereg(fe, 0x01, buf[0]);
+	ret |= ts2020_writereg(fe, 0x02, buf[1]);
+	ret |= ts2020_writereg(fe, 0x03, buf[2]);
 
-	ret |= ts2020_writereg(fe, 0x03, 0x06);
 	ret |= ts2020_tuner_gate_ctrl(fe, 0x10);
 	if (ret < 0)
 		return -ENODEV;
 
-	/* Tuner Frequency Range */
-	ret = ts2020_writereg(fe, 0x10, lo);
-
 	ret |= ts2020_tuner_gate_ctrl(fe, 0x08);
 
 	/* Tuner RF */
@@ -335,11 +352,6 @@ static int ts2020_set_params(struct dvb_frontend *fe)
 	ret |= ts2020_tuner_gate_ctrl(fe, 0x01);
 
 	msleep(80);
-	/* calculate offset assuming 96000kHz*/
-	offset_khz = (ndiv - ndiv % 2 + 1024) * TS2020_XTAL_FREQ
-		/ (6 + 8) / (div4 + 1) / 2;
-
-	priv->frequency = offset_khz;
 
 	return (ret < 0) ? -EINVAL : 0;
 }
@@ -347,8 +359,8 @@ static int ts2020_set_params(struct dvb_frontend *fe)
 static int ts2020_get_frequency(struct dvb_frontend *fe, u32 *frequency)
 {
 	struct ts2020_priv *priv = fe->tuner_priv;
-	*frequency = priv->frequency;
 
+	*frequency = priv->frequency_khz;
 	return 0;
 }
 

commit b3226f961aa91eb94971939400c7506e7dcc86c0
Author: Antti Palosaari <crope@iki.fi>
Date:   Tue Mar 24 09:40:58 2015 -0300

    [media] ts2020: do not use i2c_transfer() on sleep()
    
    There is no need to use bulk i2c_transfer() to write single register.
    Use write register function instead.
    
    Tested-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/ts2020.c b/drivers/media/dvb-frontends/ts2020.c
index b1d91dc46a47..90164a38cd36 100644
--- a/drivers/media/dvb-frontends/ts2020.c
+++ b/drivers/media/dvb-frontends/ts2020.c
@@ -123,29 +123,14 @@ static int ts2020_readreg(struct dvb_frontend *fe, u8 reg)
 static int ts2020_sleep(struct dvb_frontend *fe)
 {
 	struct ts2020_priv *priv = fe->tuner_priv;
-	int ret;
-	u8 buf[] = { 10, 0 };
-	struct i2c_msg msg = {
-		.addr = priv->i2c_address,
-		.flags = 0,
-		.buf = buf,
-		.len = 2
-	};
-
-	if (priv->tuner == TS2020_M88TS2022)
-		buf[0] = 0x00;
-
-	if (fe->ops.i2c_gate_ctrl)
-		fe->ops.i2c_gate_ctrl(fe, 1);
-
-	ret = i2c_transfer(priv->i2c, &msg, 1);
-	if (ret != 1)
-		printk(KERN_ERR "%s: i2c error\n", __func__);
+	u8 u8tmp;
 
-	if (fe->ops.i2c_gate_ctrl)
-		fe->ops.i2c_gate_ctrl(fe, 0);
+	if (priv->tuner == TS2020_M88TS2020)
+		u8tmp = 0x0a; /* XXX: probably wrong */
+	else
+		u8tmp = 0x00;
 
-	return (ret == 1) ? 0 : ret;
+	return ts2020_writereg(fe, u8tmp, 0x00);
 }
 
 static int ts2020_init(struct dvb_frontend *fe)

commit dc245a5f9b5163511e0c164c8aa47848f07b75a9
Author: Antti Palosaari <crope@iki.fi>
Date:   Mon Mar 23 18:26:55 2015 -0300

    [media] ts2020: implement I2C client bindings
    
    Implement I2C binding model.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/ts2020.c b/drivers/media/dvb-frontends/ts2020.c
index 24c4712b77fe..b1d91dc46a47 100644
--- a/drivers/media/dvb-frontends/ts2020.c
+++ b/drivers/media/dvb-frontends/ts2020.c
@@ -26,6 +26,7 @@
 #define FREQ_OFFSET_LOW_SYM_RATE 3000
 
 struct ts2020_priv {
+	struct dvb_frontend *fe;
 	/* i2c details */
 	int i2c_address;
 	struct i2c_adapter *i2c;
@@ -428,6 +429,7 @@ struct dvb_frontend *ts2020_attach(struct dvb_frontend *fe,
 	priv->clk_out = config->clk_out;
 	priv->clk_out_div = config->clk_out_div;
 	priv->frequency_div = config->frequency_div;
+	priv->fe = fe;
 	fe->tuner_priv = priv;
 
 	if (!priv->frequency_div)
@@ -463,6 +465,165 @@ struct dvb_frontend *ts2020_attach(struct dvb_frontend *fe,
 }
 EXPORT_SYMBOL(ts2020_attach);
 
+static int ts2020_probe(struct i2c_client *client,
+		const struct i2c_device_id *id)
+{
+	struct ts2020_config *pdata = client->dev.platform_data;
+	struct dvb_frontend *fe = pdata->fe;
+	struct ts2020_priv *dev;
+	int ret;
+	u8 u8tmp;
+	unsigned int utmp;
+	char *chip_str;
+
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev) {
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	dev->i2c = client->adapter;
+	dev->i2c_address = client->addr;
+	dev->clk_out = pdata->clk_out;
+	dev->clk_out_div = pdata->clk_out_div;
+	dev->frequency_div = pdata->frequency_div;
+	dev->fe = fe;
+	fe->tuner_priv = dev;
+
+	/* check if the tuner is there */
+	ret = ts2020_readreg(fe, 0x00);
+	if (ret < 0)
+		goto err;
+	utmp = ret;
+
+	if ((utmp & 0x03) == 0x00) {
+		ret = ts2020_writereg(fe, 0x00, 0x01);
+		if (ret)
+			goto err;
+
+		usleep_range(2000, 50000);
+	}
+
+	ret = ts2020_writereg(fe, 0x00, 0x03);
+	if (ret)
+		goto err;
+
+	usleep_range(2000, 50000);
+
+	ret = ts2020_readreg(fe, 0x00);
+	if (ret < 0)
+		goto err;
+	utmp = ret;
+
+	dev_dbg(&client->dev, "chip_id=%02x\n", utmp);
+
+	switch (utmp) {
+	case 0x01:
+	case 0x41:
+	case 0x81:
+		dev->tuner = TS2020_M88TS2020;
+		chip_str = "TS2020";
+		if (!dev->frequency_div)
+			dev->frequency_div = 1060000;
+		break;
+	case 0xc3:
+	case 0x83:
+		dev->tuner = TS2020_M88TS2022;
+		chip_str = "TS2022";
+		if (!dev->frequency_div)
+			dev->frequency_div = 1103000;
+		break;
+	default:
+		ret = -ENODEV;
+		goto err;
+	}
+
+	if (dev->tuner == TS2020_M88TS2022) {
+		switch (dev->clk_out) {
+		case TS2020_CLK_OUT_DISABLED:
+			u8tmp = 0x60;
+			break;
+		case TS2020_CLK_OUT_ENABLED:
+			u8tmp = 0x70;
+			ret = ts2020_writereg(fe, 0x05, dev->clk_out_div);
+			if (ret)
+				goto err;
+			break;
+		case TS2020_CLK_OUT_ENABLED_XTALOUT:
+			u8tmp = 0x6c;
+			break;
+		default:
+			ret = -EINVAL;
+			goto err;
+		}
+
+		ret = ts2020_writereg(fe, 0x42, u8tmp);
+		if (ret)
+			goto err;
+
+		if (dev->loop_through)
+			u8tmp = 0xec;
+		else
+			u8tmp = 0x6c;
+
+		ret = ts2020_writereg(fe, 0x62, u8tmp);
+		if (ret)
+			goto err;
+	}
+
+	/* sleep */
+	ret = ts2020_writereg(fe, 0x00, 0x00);
+	if (ret)
+		goto err;
+
+	dev_info(&client->dev,
+		 "Montage Technology %s successfully identified\n", chip_str);
+
+	memcpy(&fe->ops.tuner_ops, &ts2020_tuner_ops,
+			sizeof(struct dvb_tuner_ops));
+	fe->ops.tuner_ops.release = NULL;
+
+	i2c_set_clientdata(client, dev);
+	return 0;
+err:
+	dev_dbg(&client->dev, "failed=%d\n", ret);
+	kfree(dev);
+	return ret;
+}
+
+static int ts2020_remove(struct i2c_client *client)
+{
+	struct ts2020_priv *dev = i2c_get_clientdata(client);
+	struct dvb_frontend *fe = dev->fe;
+
+	dev_dbg(&client->dev, "\n");
+
+	memset(&fe->ops.tuner_ops, 0, sizeof(struct dvb_tuner_ops));
+	fe->tuner_priv = NULL;
+	kfree(dev);
+
+	return 0;
+}
+
+static const struct i2c_device_id ts2020_id_table[] = {
+	{"ts2020", 0},
+	{"ts2022", 0},
+	{}
+};
+MODULE_DEVICE_TABLE(i2c, ts2020_id_table);
+
+static struct i2c_driver ts2020_driver = {
+	.driver = {
+		.owner	= THIS_MODULE,
+		.name	= "ts2020",
+	},
+	.probe		= ts2020_probe,
+	.remove		= ts2020_remove,
+	.id_table	= ts2020_id_table,
+};
+
+module_i2c_driver(ts2020_driver);
+
 MODULE_AUTHOR("Konstantin Dimitrov <kosio.dimitrov@gmail.com>");
 MODULE_DESCRIPTION("Montage Technology TS2020 - Silicon tuner driver module");
 MODULE_LICENSE("GPL");

commit abd9025b95619c02f83583c9659298bc65dcdf50
Author: Antti Palosaari <crope@iki.fi>
Date:   Mon Mar 23 14:14:40 2015 -0300

    [media] ts2020: add support for TS2022
    
    TS2022 is slightly newer and different version of same tuner, which
    could be supported with rather small changes. Tuner type is
    auto-detected.
    
    Tested-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/ts2020.c b/drivers/media/dvb-frontends/ts2020.c
index 9aba044dabed..24c4712b77fe 100644
--- a/drivers/media/dvb-frontends/ts2020.c
+++ b/drivers/media/dvb-frontends/ts2020.c
@@ -29,9 +29,19 @@ struct ts2020_priv {
 	/* i2c details */
 	int i2c_address;
 	struct i2c_adapter *i2c;
-	u8 clk_out_div;
+	u8 clk_out:2;
+	u8 clk_out_div:5;
 	u32 frequency;
 	u32 frequency_div;
+#define TS2020_M88TS2020 0
+#define TS2020_M88TS2022 1
+	u8 tuner;
+	u8 loop_through:1;
+};
+
+struct ts2020_reg_val {
+	u8 reg;
+	u8 val;
 };
 
 static int ts2020_release(struct dvb_frontend *fe)
@@ -121,6 +131,9 @@ static int ts2020_sleep(struct dvb_frontend *fe)
 		.len = 2
 	};
 
+	if (priv->tuner == TS2020_M88TS2022)
+		buf[0] = 0x00;
+
 	if (fe->ops.i2c_gate_ctrl)
 		fe->ops.i2c_gate_ctrl(fe, 1);
 
@@ -137,15 +150,64 @@ static int ts2020_sleep(struct dvb_frontend *fe)
 static int ts2020_init(struct dvb_frontend *fe)
 {
 	struct ts2020_priv *priv = fe->tuner_priv;
+	int i;
+	u8 u8tmp;
+
+	if (priv->tuner == TS2020_M88TS2020) {
+		ts2020_writereg(fe, 0x42, 0x73);
+		ts2020_writereg(fe, 0x05, priv->clk_out_div);
+		ts2020_writereg(fe, 0x20, 0x27);
+		ts2020_writereg(fe, 0x07, 0x02);
+		ts2020_writereg(fe, 0x11, 0xff);
+		ts2020_writereg(fe, 0x60, 0xf9);
+		ts2020_writereg(fe, 0x08, 0x01);
+		ts2020_writereg(fe, 0x00, 0x41);
+	} else {
+		static const struct ts2020_reg_val reg_vals[] = {
+			{0x7d, 0x9d},
+			{0x7c, 0x9a},
+			{0x7a, 0x76},
+			{0x3b, 0x01},
+			{0x63, 0x88},
+			{0x61, 0x85},
+			{0x22, 0x30},
+			{0x30, 0x40},
+			{0x20, 0x23},
+			{0x24, 0x02},
+			{0x12, 0xa0},
+		};
+
+		ts2020_writereg(fe, 0x00, 0x01);
+		ts2020_writereg(fe, 0x00, 0x03);
+
+		switch (priv->clk_out) {
+		case TS2020_CLK_OUT_DISABLED:
+			u8tmp = 0x60;
+			break;
+		case TS2020_CLK_OUT_ENABLED:
+			u8tmp = 0x70;
+			ts2020_writereg(fe, 0x05, priv->clk_out_div);
+			break;
+		case TS2020_CLK_OUT_ENABLED_XTALOUT:
+			u8tmp = 0x6c;
+			break;
+		default:
+			u8tmp = 0x60;
+			break;
+		}
+
+		ts2020_writereg(fe, 0x42, u8tmp);
+
+		if (priv->loop_through)
+			u8tmp = 0xec;
+		else
+			u8tmp = 0x6c;
 
-	ts2020_writereg(fe, 0x42, 0x73);
-	ts2020_writereg(fe, 0x05, priv->clk_out_div);
-	ts2020_writereg(fe, 0x20, 0x27);
-	ts2020_writereg(fe, 0x07, 0x02);
-	ts2020_writereg(fe, 0x11, 0xff);
-	ts2020_writereg(fe, 0x60, 0xf9);
-	ts2020_writereg(fe, 0x08, 0x01);
-	ts2020_writereg(fe, 0x00, 0x41);
+		ts2020_writereg(fe, 0x62, u8tmp);
+
+		for (i = 0; i < ARRAY_SIZE(reg_vals); i++)
+			ts2020_writereg(fe, reg_vals[i].reg, reg_vals[i].val);
+	}
 
 	return 0;
 }
@@ -203,7 +265,14 @@ static int ts2020_set_params(struct dvb_frontend *fe)
 	ndiv = ndiv + ndiv % 2;
 	ndiv = ndiv - 1024;
 
-	ret = ts2020_writereg(fe, 0x10, 0x80 | lo);
+	if (priv->tuner == TS2020_M88TS2020) {
+		lpf_coeff = 2766;
+		ret = ts2020_writereg(fe, 0x10, 0x80 | lo);
+	} else {
+		lpf_coeff = 3200;
+		ret = ts2020_writereg(fe, 0x10, 0x0b);
+		ret |= ts2020_writereg(fe, 0x11, 0x40);
+	}
 
 	/* Set frequency divider */
 	ret |= ts2020_writereg(fe, 0x01, (ndiv >> 8) & 0xf);
@@ -220,7 +289,8 @@ static int ts2020_set_params(struct dvb_frontend *fe)
 	ret |= ts2020_tuner_gate_ctrl(fe, 0x08);
 
 	/* Tuner RF */
-	ret |= ts2020_set_tuner_rf(fe);
+	if (priv->tuner == TS2020_M88TS2020)
+		ret |= ts2020_set_tuner_rf(fe);
 
 	gdiv28 = (TS2020_XTAL_FREQ / 1000 * 1694 + 500) / 1000;
 	ret |= ts2020_writereg(fe, 0x04, gdiv28 & 0xff);
@@ -228,6 +298,15 @@ static int ts2020_set_params(struct dvb_frontend *fe)
 	if (ret < 0)
 		return -ENODEV;
 
+	if (priv->tuner == TS2020_M88TS2022) {
+		ret = ts2020_writereg(fe, 0x25, 0x00);
+		ret |= ts2020_writereg(fe, 0x27, 0x70);
+		ret |= ts2020_writereg(fe, 0x41, 0x09);
+		ret |= ts2020_writereg(fe, 0x08, 0x0b);
+		if (ret < 0)
+			return -ENODEV;
+	}
+
 	value = ts2020_readreg(fe, 0x26);
 
 	f3db = (symbol_rate * 135) / 200 + 2000;
@@ -243,8 +322,6 @@ static int ts2020_set_params(struct dvb_frontend *fe)
 	if (mlpf_max > 63)
 		mlpf_max = 63;
 
-	lpf_coeff = 2766;
-
 	nlpf = (f3db * gdiv28 * 2 / lpf_coeff /
 		(TS2020_XTAL_FREQ / 1000)  + 1) / 2;
 	if (nlpf > 23)
@@ -285,6 +362,13 @@ static int ts2020_get_frequency(struct dvb_frontend *fe, u32 *frequency)
 {
 	struct ts2020_priv *priv = fe->tuner_priv;
 	*frequency = priv->frequency;
+
+	return 0;
+}
+
+static int ts2020_get_if_frequency(struct dvb_frontend *fe, u32 *frequency)
+{
+	*frequency = 0; /* Zero-IF */
 	return 0;
 }
 
@@ -324,6 +408,7 @@ static struct dvb_tuner_ops ts2020_tuner_ops = {
 	.sleep = ts2020_sleep,
 	.set_params = ts2020_set_params,
 	.get_frequency = ts2020_get_frequency,
+	.get_if_frequency = ts2020_get_if_frequency,
 	.get_rf_strength = ts2020_read_signal_strength,
 };
 
@@ -340,6 +425,7 @@ struct dvb_frontend *ts2020_attach(struct dvb_frontend *fe,
 
 	priv->i2c_address = config->tuner_address;
 	priv->i2c = i2c;
+	priv->clk_out = config->clk_out;
 	priv->clk_out_div = config->clk_out_div;
 	priv->frequency_div = config->frequency_div;
 	fe->tuner_priv = priv;
@@ -358,9 +444,13 @@ struct dvb_frontend *ts2020_attach(struct dvb_frontend *fe,
 
 	/* Check the tuner version */
 	buf = ts2020_readreg(fe, 0x00);
-	if ((buf == 0x01) || (buf == 0x41) || (buf == 0x81))
+	if ((buf == 0x01) || (buf == 0x41) || (buf == 0x81)) {
 		printk(KERN_INFO "%s: Find tuner TS2020!\n", __func__);
-	else {
+		priv->tuner = TS2020_M88TS2020;
+	} else if ((buf == 0x83) || (buf == 0xc3)) {
+		printk(KERN_INFO "%s: Find tuner TS2022!\n", __func__);
+		priv->tuner = TS2020_M88TS2022;
+	} else {
 		printk(KERN_ERR "%s: Read tuner reg[0] = %d\n", __func__, buf);
 		kfree(priv);
 		return NULL;

commit b4559ace2ca8c88666584279f582b998c6591fb0
Author: Mauro Carvalho Chehab <m.chehab@samsung.com>
Date:   Wed Oct 2 06:43:37 2013 -0300

    [media] ts2020: keep 1.06 MHz as default value for frequency_div
    
    Changeset 9e8da9e8 added a parameter to specify the frequency
    divisor, used by the driver. However, not all places are passing
    this parameter. So, preserve the previous default, to avoid breaking
    the existing drivers.
    
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/drivers/media/dvb-frontends/ts2020.c b/drivers/media/dvb-frontends/ts2020.c
index 678f13ac4503..9aba044dabed 100644
--- a/drivers/media/dvb-frontends/ts2020.c
+++ b/drivers/media/dvb-frontends/ts2020.c
@@ -344,6 +344,9 @@ struct dvb_frontend *ts2020_attach(struct dvb_frontend *fe,
 	priv->frequency_div = config->frequency_div;
 	fe->tuner_priv = priv;
 
+	if (!priv->frequency_div)
+		priv->frequency_div = 1060000;
+
 	/* Wake Up the tuner */
 	if ((0x03 & ts2020_readreg(fe, 0x00)) == 0x00) {
 		ts2020_writereg(fe, 0x00, 0x01);

commit 03a6727995df6dbef6e0054761e75ecc68b3a6d2
Author: John Horan <knasher@gmail.com>
Date:   Wed Aug 28 09:37:37 2013 -0300

    [media] media: dvb-frontends: ts2020: Added in a option for frequency divider value for s600 devices
    
    When the tuner part of the ds3000 driver was split to share code with the m88rs2000 driver, the ts2020 driver used
    the frequency divider value from the m88rs2000 driver.  However the ds3000 driver requires a different value, and this
    resulted in some frequecies being invisible to the tuner.  This patch adds back in the value needed for the ds3000 driver
    and configured as an option in the dw2102 frontend driver.
    It may also apply to su3000 devices, which use the same ds3000 driver, but for now it is only applied to the s660 device.
    
    Signed-off-by: John Horan <knasher@gmail.com>
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/drivers/media/dvb-frontends/ts2020.c b/drivers/media/dvb-frontends/ts2020.c
index ad7ad857ab2a..678f13ac4503 100644
--- a/drivers/media/dvb-frontends/ts2020.c
+++ b/drivers/media/dvb-frontends/ts2020.c
@@ -31,6 +31,7 @@ struct ts2020_priv {
 	struct i2c_adapter *i2c;
 	u8 clk_out_div;
 	u32 frequency;
+	u32 frequency_div;
 };
 
 static int ts2020_release(struct dvb_frontend *fe)
@@ -193,7 +194,7 @@ static int ts2020_set_params(struct dvb_frontend *fe)
 	u8 lo = 0x01, div4 = 0x0;
 
 	/* Calculate frequency divider */
-	if (frequency < 1060000) {
+	if (frequency < priv->frequency_div) {
 		lo |= 0x10;
 		div4 = 0x1;
 		ndiv = (frequency * 14 * 4) / TS2020_XTAL_FREQ;
@@ -340,6 +341,7 @@ struct dvb_frontend *ts2020_attach(struct dvb_frontend *fe,
 	priv->i2c_address = config->tuner_address;
 	priv->i2c = i2c;
 	priv->clk_out_div = config->clk_out_div;
+	priv->frequency_div = config->frequency_div;
 	fe->tuner_priv = priv;
 
 	/* Wake Up the tuner */

commit a0a030bdbe612b7d8a941fba672300f7fc21b275
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sun Jan 6 08:40:42 2013 -0300

    [media] ts2020: call get_rf_strength from frontend
    
    Restore ds3000.c read_signal_strength.
    Call tuner get_rf_strength from frontend read_signal_strength.
    We are able to do a NULL check and doesn't limit the tuner
    attach to the frontend attach area.
    At the moment the lmedm04 tuner attach is stuck in frontend
    attach area.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/dvb-frontends/ts2020.c b/drivers/media/dvb-frontends/ts2020.c
index f50e237e1464..ad7ad857ab2a 100644
--- a/drivers/media/dvb-frontends/ts2020.c
+++ b/drivers/media/dvb-frontends/ts2020.c
@@ -363,7 +363,6 @@ struct dvb_frontend *ts2020_attach(struct dvb_frontend *fe,
 
 	memcpy(&fe->ops.tuner_ops, &ts2020_tuner_ops,
 				sizeof(struct dvb_tuner_ops));
-	fe->ops.read_signal_strength = fe->ops.tuner_ops.get_rf_strength;
 
 	return fe;
 }

commit 9898df6482f71fa0d27b029789ef2f37988c06b3
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Thu Jan 3 16:37:25 2013 -0300

    [media] ts2020.c: ts2020_set_params [BUG] point to fe->tuner_priv
    
    Fixes corruption of fe->demodulator_priv
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/dvb-frontends/ts2020.c b/drivers/media/dvb-frontends/ts2020.c
index 94e3fe21eefb..f50e237e1464 100644
--- a/drivers/media/dvb-frontends/ts2020.c
+++ b/drivers/media/dvb-frontends/ts2020.c
@@ -182,7 +182,7 @@ static int ts2020_set_tuner_rf(struct dvb_frontend *fe)
 static int ts2020_set_params(struct dvb_frontend *fe)
 {
 	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
-	struct ts2020_priv *priv = fe->demodulator_priv;
+	struct ts2020_priv *priv = fe->tuner_priv;
 	int ret;
 	u32 frequency = c->frequency;
 	s32 offset_khz;

commit b858c331cdf402853be2c48c8f4f77173ef04da8
Author: Igor M. Liplianin <liplianin@me.by>
Date:   Fri Dec 28 19:40:33 2012 -0300

    [media] m88rs2000: make use ts2020
    
    Tuner part of Montage rs2000 chip is similar to ts2020 tuner.
    Patch to use ts2020 code.
    
    [mchehab@redhat.com: a few CodingStyle fixes]
    Signed-off-by: Igor M. Liplianin <liplianin@me.by>
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/dvb-frontends/ts2020.c b/drivers/media/dvb-frontends/ts2020.c
index 73010ecb9866..94e3fe21eefb 100644
--- a/drivers/media/dvb-frontends/ts2020.c
+++ b/drivers/media/dvb-frontends/ts2020.c
@@ -23,27 +23,68 @@
 #include "ts2020.h"
 
 #define TS2020_XTAL_FREQ   27000 /* in kHz */
+#define FREQ_OFFSET_LOW_SYM_RATE 3000
 
-struct ts2020_state {
-	u8 tuner_address;
+struct ts2020_priv {
+	/* i2c details */
+	int i2c_address;
 	struct i2c_adapter *i2c;
+	u8 clk_out_div;
+	u32 frequency;
 };
 
-static int ts2020_readreg(struct dvb_frontend *fe, u8 reg)
+static int ts2020_release(struct dvb_frontend *fe)
 {
-	struct ts2020_state *state = fe->tuner_priv;
+	kfree(fe->tuner_priv);
+	fe->tuner_priv = NULL;
+	return 0;
+}
+
+static int ts2020_writereg(struct dvb_frontend *fe, int reg, int data)
+{
+	struct ts2020_priv *priv = fe->tuner_priv;
+	u8 buf[] = { reg, data };
+	struct i2c_msg msg[] = {
+		{
+			.addr = priv->i2c_address,
+			.flags = 0,
+			.buf = buf,
+			.len = 2
+		}
+	};
+	int err;
+
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 1);
+
+	err = i2c_transfer(priv->i2c, msg, 1);
+	if (err != 1) {
+		printk(KERN_ERR
+		       "%s: writereg error(err == %i, reg == 0x%02x, value == 0x%02x)\n",
+		       __func__, err, reg, data);
+		return -EREMOTEIO;
+	}
 
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 0);
+
+	return 0;
+}
+
+static int ts2020_readreg(struct dvb_frontend *fe, u8 reg)
+{
+	struct ts2020_priv *priv = fe->tuner_priv;
 	int ret;
 	u8 b0[] = { reg };
 	u8 b1[] = { 0 };
 	struct i2c_msg msg[] = {
 		{
-			.addr = state->tuner_address,
+			.addr = priv->i2c_address,
 			.flags = 0,
 			.buf = b0,
 			.len = 1
 		}, {
-			.addr = state->tuner_address,
+			.addr = priv->i2c_address,
 			.flags = I2C_M_RD,
 			.buf = b1,
 			.len = 1
@@ -53,212 +94,202 @@ static int ts2020_readreg(struct dvb_frontend *fe, u8 reg)
 	if (fe->ops.i2c_gate_ctrl)
 		fe->ops.i2c_gate_ctrl(fe, 1);
 
-	ret = i2c_transfer(state->i2c, msg, 2);
-
-	if (fe->ops.i2c_gate_ctrl)
-		fe->ops.i2c_gate_ctrl(fe, 0);
+	ret = i2c_transfer(priv->i2c, msg, 2);
 
 	if (ret != 2) {
-		printk(KERN_ERR "%s: reg=0x%x(error=%d)\n", __func__, reg, ret);
+		printk(KERN_ERR "%s: reg=0x%x(error=%d)\n",
+		       __func__, reg, ret);
 		return ret;
 	}
 
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 0);
+
 	return b1[0];
 }
 
-static int ts2020_writereg(struct dvb_frontend *fe, int reg, int data)
+static int ts2020_sleep(struct dvb_frontend *fe)
 {
-	struct ts2020_state *state = fe->tuner_priv;
-
-	u8 buf[] = { reg, data };
-	struct i2c_msg msg = { .addr = state->tuner_address,
-		.flags = 0, .buf = buf, .len = 2 };
-	int err;
-
+	struct ts2020_priv *priv = fe->tuner_priv;
+	int ret;
+	u8 buf[] = { 10, 0 };
+	struct i2c_msg msg = {
+		.addr = priv->i2c_address,
+		.flags = 0,
+		.buf = buf,
+		.len = 2
+	};
 
 	if (fe->ops.i2c_gate_ctrl)
 		fe->ops.i2c_gate_ctrl(fe, 1);
 
-	err = i2c_transfer(state->i2c, &msg, 1);
+	ret = i2c_transfer(priv->i2c, &msg, 1);
+	if (ret != 1)
+		printk(KERN_ERR "%s: i2c error\n", __func__);
 
 	if (fe->ops.i2c_gate_ctrl)
 		fe->ops.i2c_gate_ctrl(fe, 0);
 
-	if (err != 1) {
-		printk(KERN_ERR "%s: writereg error(err == %i, reg == 0x%02x,"
-			 " value == 0x%02x)\n", __func__, err, reg, data);
-		return -EREMOTEIO;
-	}
-
-	return 0;
+	return (ret == 1) ? 0 : ret;
 }
 
 static int ts2020_init(struct dvb_frontend *fe)
 {
+	struct ts2020_priv *priv = fe->tuner_priv;
+
 	ts2020_writereg(fe, 0x42, 0x73);
-	ts2020_writereg(fe, 0x05, 0x01);
-	ts2020_writereg(fe, 0x62, 0xf5);
+	ts2020_writereg(fe, 0x05, priv->clk_out_div);
+	ts2020_writereg(fe, 0x20, 0x27);
+	ts2020_writereg(fe, 0x07, 0x02);
+	ts2020_writereg(fe, 0x11, 0xff);
+	ts2020_writereg(fe, 0x60, 0xf9);
+	ts2020_writereg(fe, 0x08, 0x01);
+	ts2020_writereg(fe, 0x00, 0x41);
+
 	return 0;
 }
 
-static int ts2020_get_frequency(struct dvb_frontend *fe, u32 *frequency)
+static int ts2020_tuner_gate_ctrl(struct dvb_frontend *fe, u8 offset)
 {
-	u16 ndiv, div4;
+	int ret;
+	ret = ts2020_writereg(fe, 0x51, 0x1f - offset);
+	ret |= ts2020_writereg(fe, 0x51, 0x1f);
+	ret |= ts2020_writereg(fe, 0x50, offset);
+	ret |= ts2020_writereg(fe, 0x50, 0x00);
+	msleep(20);
+	return ret;
+}
 
-	div4 = (ts2020_readreg(fe, 0x10) & 0x10) >> 4;
+static int ts2020_set_tuner_rf(struct dvb_frontend *fe)
+{
+	int reg;
 
-	ndiv = ts2020_readreg(fe, 0x01);
-	ndiv &= 0x0f;
-	ndiv <<= 8;
-	ndiv |= ts2020_readreg(fe, 0x02);
+	reg = ts2020_readreg(fe, 0x3d);
+	reg &= 0x7f;
+	if (reg < 0x16)
+		reg = 0xa1;
+	else if (reg == 0x16)
+		reg = 0x99;
+	else
+		reg = 0xf9;
 
-	/* actual tuned frequency, i.e. including the offset */
-	*frequency = (ndiv - ndiv % 2 + 1024) * TS2020_XTAL_FREQ
-		/ (6 + 8) / (div4 + 1) / 2;
+	ts2020_writereg(fe, 0x60, reg);
+	reg = ts2020_tuner_gate_ctrl(fe, 0x08);
 
-	return 0;
+	return reg;
 }
 
 static int ts2020_set_params(struct dvb_frontend *fe)
 {
 	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	struct ts2020_priv *priv = fe->demodulator_priv;
+	int ret;
+	u32 frequency = c->frequency;
+	s32 offset_khz;
+	u32 symbol_rate = (c->symbol_rate / 1000);
+	u32 f3db, gdiv28;
+	u16 value, ndiv, lpf_coeff;
+	u8 lpf_mxdiv, mlpf_max, mlpf_min, nlpf;
+	u8 lo = 0x01, div4 = 0x0;
+
+	/* Calculate frequency divider */
+	if (frequency < 1060000) {
+		lo |= 0x10;
+		div4 = 0x1;
+		ndiv = (frequency * 14 * 4) / TS2020_XTAL_FREQ;
+	} else
+		ndiv = (frequency * 14 * 2) / TS2020_XTAL_FREQ;
+	ndiv = ndiv + ndiv % 2;
+	ndiv = ndiv - 1024;
+
+	ret = ts2020_writereg(fe, 0x10, 0x80 | lo);
+
+	/* Set frequency divider */
+	ret |= ts2020_writereg(fe, 0x01, (ndiv >> 8) & 0xf);
+	ret |= ts2020_writereg(fe, 0x02, ndiv & 0xff);
+
+	ret |= ts2020_writereg(fe, 0x03, 0x06);
+	ret |= ts2020_tuner_gate_ctrl(fe, 0x10);
+	if (ret < 0)
+		return -ENODEV;
+
+	/* Tuner Frequency Range */
+	ret = ts2020_writereg(fe, 0x10, lo);
+
+	ret |= ts2020_tuner_gate_ctrl(fe, 0x08);
+
+	/* Tuner RF */
+	ret |= ts2020_set_tuner_rf(fe);
+
+	gdiv28 = (TS2020_XTAL_FREQ / 1000 * 1694 + 500) / 1000;
+	ret |= ts2020_writereg(fe, 0x04, gdiv28 & 0xff);
+	ret |= ts2020_tuner_gate_ctrl(fe, 0x04);
+	if (ret < 0)
+		return -ENODEV;
 
-	u8 mlpf, mlpf_new, mlpf_max, mlpf_min, nlpf;
-	u16 value, ndiv;
-	u32 srate = 0, f3db;
-
-	ts2020_init(fe);
-
-	/* unknown */
-	ts2020_writereg(fe, 0x07, 0x02);
-	ts2020_writereg(fe, 0x10, 0x00);
-	ts2020_writereg(fe, 0x60, 0x79);
-	ts2020_writereg(fe, 0x08, 0x01);
-	ts2020_writereg(fe, 0x00, 0x01);
-
-	/* calculate and set freq divider */
-	if (c->frequency < 1146000) {
-		ts2020_writereg(fe, 0x10, 0x11);
-		ndiv = ((c->frequency * (6 + 8) * 4) +
-				(TS2020_XTAL_FREQ / 2)) /
-				TS2020_XTAL_FREQ - 1024;
-	} else {
-		ts2020_writereg(fe, 0x10, 0x01);
-		ndiv = ((c->frequency * (6 + 8) * 2) +
-				(TS2020_XTAL_FREQ / 2)) /
-				TS2020_XTAL_FREQ - 1024;
-	}
-
-	ts2020_writereg(fe, 0x01, (ndiv & 0x0f00) >> 8);
-	ts2020_writereg(fe, 0x02, ndiv & 0x00ff);
-
-	/* set pll */
-	ts2020_writereg(fe, 0x03, 0x06);
-	ts2020_writereg(fe, 0x51, 0x0f);
-	ts2020_writereg(fe, 0x51, 0x1f);
-	ts2020_writereg(fe, 0x50, 0x10);
-	ts2020_writereg(fe, 0x50, 0x00);
-	msleep(5);
-
-	/* unknown */
-	ts2020_writereg(fe, 0x51, 0x17);
-	ts2020_writereg(fe, 0x51, 0x1f);
-	ts2020_writereg(fe, 0x50, 0x08);
-	ts2020_writereg(fe, 0x50, 0x00);
-	msleep(5);
-
-	value = ts2020_readreg(fe, 0x3d);
-	value &= 0x0f;
-	if ((value > 4) && (value < 15)) {
-		value -= 3;
-		if (value < 4)
-			value = 4;
-		value = ((value << 3) | 0x01) & 0x79;
-	}
+	value = ts2020_readreg(fe, 0x26);
 
-	ts2020_writereg(fe, 0x60, value);
-	ts2020_writereg(fe, 0x51, 0x17);
-	ts2020_writereg(fe, 0x51, 0x1f);
-	ts2020_writereg(fe, 0x50, 0x08);
-	ts2020_writereg(fe, 0x50, 0x00);
-
-	/* set low-pass filter period */
-	ts2020_writereg(fe, 0x04, 0x2e);
-	ts2020_writereg(fe, 0x51, 0x1b);
-	ts2020_writereg(fe, 0x51, 0x1f);
-	ts2020_writereg(fe, 0x50, 0x04);
-	ts2020_writereg(fe, 0x50, 0x00);
-	msleep(5);
-
-	srate = c->symbol_rate / 1000;
-
-	f3db = (srate << 2) / 5 + 2000;
-	if (srate < 5000)
-		f3db += 3000;
+	f3db = (symbol_rate * 135) / 200 + 2000;
+	f3db += FREQ_OFFSET_LOW_SYM_RATE;
 	if (f3db < 7000)
 		f3db = 7000;
 	if (f3db > 40000)
 		f3db = 40000;
 
-	/* set low-pass filter baseband */
-	value = ts2020_readreg(fe, 0x26);
-	mlpf = 0x2e * 207 / ((value << 1) + 151);
-	mlpf_max = mlpf * 135 / 100;
-	mlpf_min = mlpf * 78 / 100;
+	gdiv28 = gdiv28 * 207 / (value * 2 + 151);
+	mlpf_max = gdiv28 * 135 / 100;
+	mlpf_min = gdiv28 * 78 / 100;
 	if (mlpf_max > 63)
 		mlpf_max = 63;
 
-	/* rounded to the closest integer */
-	nlpf = ((mlpf * f3db * 1000) + (2766 * TS2020_XTAL_FREQ / 2))
-			/ (2766 * TS2020_XTAL_FREQ);
+	lpf_coeff = 2766;
+
+	nlpf = (f3db * gdiv28 * 2 / lpf_coeff /
+		(TS2020_XTAL_FREQ / 1000)  + 1) / 2;
 	if (nlpf > 23)
 		nlpf = 23;
 	if (nlpf < 1)
 		nlpf = 1;
 
-	/* rounded to the closest integer */
-	mlpf_new = ((TS2020_XTAL_FREQ * nlpf * 2766) +
-			(1000 * f3db / 2)) / (1000 * f3db);
+	lpf_mxdiv = (nlpf * (TS2020_XTAL_FREQ / 1000)
+		* lpf_coeff * 2  / f3db + 1) / 2;
 
-	if (mlpf_new < mlpf_min) {
+	if (lpf_mxdiv < mlpf_min) {
 		nlpf++;
-		mlpf_new = ((TS2020_XTAL_FREQ * nlpf * 2766) +
-				(1000 * f3db / 2)) / (1000 * f3db);
+		lpf_mxdiv = (nlpf * (TS2020_XTAL_FREQ / 1000)
+			* lpf_coeff * 2  / f3db + 1) / 2;
 	}
 
-	if (mlpf_new > mlpf_max)
-		mlpf_new = mlpf_max;
+	if (lpf_mxdiv > mlpf_max)
+		lpf_mxdiv = mlpf_max;
 
-	ts2020_writereg(fe, 0x04, mlpf_new);
-	ts2020_writereg(fe, 0x06, nlpf);
-	ts2020_writereg(fe, 0x51, 0x1b);
-	ts2020_writereg(fe, 0x51, 0x1f);
-	ts2020_writereg(fe, 0x50, 0x04);
-	ts2020_writereg(fe, 0x50, 0x00);
-	msleep(5);
+	ret = ts2020_writereg(fe, 0x04, lpf_mxdiv);
+	ret |= ts2020_writereg(fe, 0x06, nlpf);
 
-	/* unknown */
-	ts2020_writereg(fe, 0x51, 0x1e);
-	ts2020_writereg(fe, 0x51, 0x1f);
-	ts2020_writereg(fe, 0x50, 0x01);
-	ts2020_writereg(fe, 0x50, 0x00);
-	msleep(60);
+	ret |= ts2020_tuner_gate_ctrl(fe, 0x04);
 
-	return 0;
-}
+	ret |= ts2020_tuner_gate_ctrl(fe, 0x01);
 
-static int ts2020_release(struct dvb_frontend *fe)
-{
-	struct ts2020_state *state = fe->tuner_priv;
+	msleep(80);
+	/* calculate offset assuming 96000kHz*/
+	offset_khz = (ndiv - ndiv % 2 + 1024) * TS2020_XTAL_FREQ
+		/ (6 + 8) / (div4 + 1) / 2;
 
-	fe->tuner_priv = NULL;
-	kfree(state);
+	priv->frequency = offset_khz;
+
+	return (ret < 0) ? -EINVAL : 0;
+}
 
+static int ts2020_get_frequency(struct dvb_frontend *fe, u32 *frequency)
+{
+	struct ts2020_priv *priv = fe->tuner_priv;
+	*frequency = priv->frequency;
 	return 0;
 }
 
-static int ts2020_get_signal_strength(struct dvb_frontend *fe,
-	u16 *signal_strength)
+/* read TS2020 signal strength */
+static int ts2020_read_signal_strength(struct dvb_frontend *fe,
+						u16 *signal_strength)
 {
 	u16 sig_reading, sig_strength;
 	u8 rfgain, bbgain;
@@ -281,35 +312,57 @@ static int ts2020_get_signal_strength(struct dvb_frontend *fe,
 	return 0;
 }
 
-static struct dvb_tuner_ops ts2020_ops = {
+static struct dvb_tuner_ops ts2020_tuner_ops = {
 	.info = {
-		.name = "Montage Technology TS2020 Silicon Tuner",
+		.name = "TS2020",
 		.frequency_min = 950000,
-		.frequency_max = 2150000,
+		.frequency_max = 2150000
 	},
-
 	.init = ts2020_init,
 	.release = ts2020_release,
+	.sleep = ts2020_sleep,
 	.set_params = ts2020_set_params,
 	.get_frequency = ts2020_get_frequency,
-	.get_rf_strength = ts2020_get_signal_strength
+	.get_rf_strength = ts2020_read_signal_strength,
 };
 
 struct dvb_frontend *ts2020_attach(struct dvb_frontend *fe,
-	const struct ts2020_config *config, struct i2c_adapter *i2c)
+					const struct ts2020_config *config,
+					struct i2c_adapter *i2c)
 {
-	struct ts2020_state *state = NULL;
+	struct ts2020_priv *priv = NULL;
+	u8 buf;
+
+	priv = kzalloc(sizeof(struct ts2020_priv), GFP_KERNEL);
+	if (priv == NULL)
+		return NULL;
 
-	/* allocate memory for the internal state */
-	state = kzalloc(sizeof(struct ts2020_state), GFP_KERNEL);
-	if (!state)
+	priv->i2c_address = config->tuner_address;
+	priv->i2c = i2c;
+	priv->clk_out_div = config->clk_out_div;
+	fe->tuner_priv = priv;
+
+	/* Wake Up the tuner */
+	if ((0x03 & ts2020_readreg(fe, 0x00)) == 0x00) {
+		ts2020_writereg(fe, 0x00, 0x01);
+		msleep(2);
+	}
+
+	ts2020_writereg(fe, 0x00, 0x03);
+	msleep(2);
+
+	/* Check the tuner version */
+	buf = ts2020_readreg(fe, 0x00);
+	if ((buf == 0x01) || (buf == 0x41) || (buf == 0x81))
+		printk(KERN_INFO "%s: Find tuner TS2020!\n", __func__);
+	else {
+		printk(KERN_ERR "%s: Read tuner reg[0] = %d\n", __func__, buf);
+		kfree(priv);
 		return NULL;
+	}
 
-	/* setup the state */
-	state->tuner_address = config->tuner_address;
-	state->i2c = i2c;
-	fe->tuner_priv = state;
-	fe->ops.tuner_ops = ts2020_ops;
+	memcpy(&fe->ops.tuner_ops, &ts2020_tuner_ops,
+				sizeof(struct dvb_tuner_ops));
 	fe->ops.read_signal_strength = fe->ops.tuner_ops.get_rf_strength;
 
 	return fe;

commit f8c30b6f3bbea7eb8b25db7df61f8a7c24072480
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Thu Dec 27 19:35:44 2012 -0200

    [media] ts2020: fix two warnings added by changeset 73f0af4
    
    drivers/media/dvb-frontends/ts2020.c: In function 'ts2020_set_params':
    drivers/media/dvb-frontends/ts2020.c:126:47: warning: variable 'div4' set but not used [-Wunused-but-set-variable]
    drivers/media/dvb-frontends/ts2020.c: At top level:
    drivers/media/dvb-frontends/ts2020.c:262:5: warning: no previous prototype for 'ts2020_get_signal_strength' [-Wmissing-prototypes]
    
    Cc: Konstantin Dimitrov <kosio.dimitrov@gmail.com>
    Cc: Igor M. Liplianin <liplianin@me.by>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/dvb-frontends/ts2020.c b/drivers/media/dvb-frontends/ts2020.c
index 8dce4ae55f09..73010ecb9866 100644
--- a/drivers/media/dvb-frontends/ts2020.c
+++ b/drivers/media/dvb-frontends/ts2020.c
@@ -123,7 +123,7 @@ static int ts2020_set_params(struct dvb_frontend *fe)
 {
 	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
 
-	u8 mlpf, mlpf_new, mlpf_max, mlpf_min, nlpf, div4;
+	u8 mlpf, mlpf_new, mlpf_max, mlpf_min, nlpf;
 	u16 value, ndiv;
 	u32 srate = 0, f3db;
 
@@ -135,12 +135,10 @@ static int ts2020_set_params(struct dvb_frontend *fe)
 	ts2020_writereg(fe, 0x60, 0x79);
 	ts2020_writereg(fe, 0x08, 0x01);
 	ts2020_writereg(fe, 0x00, 0x01);
-	div4 = 0;
 
 	/* calculate and set freq divider */
 	if (c->frequency < 1146000) {
 		ts2020_writereg(fe, 0x10, 0x11);
-		div4 = 1;
 		ndiv = ((c->frequency * (6 + 8) * 4) +
 				(TS2020_XTAL_FREQ / 2)) /
 				TS2020_XTAL_FREQ - 1024;
@@ -259,7 +257,7 @@ static int ts2020_release(struct dvb_frontend *fe)
 	return 0;
 }
 
-int ts2020_get_signal_strength(struct dvb_frontend *fe,
+static int ts2020_get_signal_strength(struct dvb_frontend *fe,
 	u16 *signal_strength)
 {
 	u16 sig_reading, sig_strength;

commit 6fef4fc71e79282b673d7613cfc63da6bdeec5bd
Author: Konstantin Dimitrov <kosio.dimitrov@gmail.com>
Date:   Sun Dec 23 19:25:27 2012 -0300

    [media] ts2020: add ts2020 tuner driver
    
    add separate ts2020 tuner driver
    
    Signed-off-by: Konstantin Dimitrov <kosio.dimitrov@gmail.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/dvb-frontends/ts2020.c b/drivers/media/dvb-frontends/ts2020.c
new file mode 100644
index 000000000000..8dce4ae55f09
--- /dev/null
+++ b/drivers/media/dvb-frontends/ts2020.c
@@ -0,0 +1,323 @@
+/*
+    Montage Technology TS2020 - Silicon Tuner driver
+    Copyright (C) 2009-2012 Konstantin Dimitrov <kosio.dimitrov@gmail.com>
+
+    Copyright (C) 2009-2012 TurboSight.com
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include "dvb_frontend.h"
+#include "ts2020.h"
+
+#define TS2020_XTAL_FREQ   27000 /* in kHz */
+
+struct ts2020_state {
+	u8 tuner_address;
+	struct i2c_adapter *i2c;
+};
+
+static int ts2020_readreg(struct dvb_frontend *fe, u8 reg)
+{
+	struct ts2020_state *state = fe->tuner_priv;
+
+	int ret;
+	u8 b0[] = { reg };
+	u8 b1[] = { 0 };
+	struct i2c_msg msg[] = {
+		{
+			.addr = state->tuner_address,
+			.flags = 0,
+			.buf = b0,
+			.len = 1
+		}, {
+			.addr = state->tuner_address,
+			.flags = I2C_M_RD,
+			.buf = b1,
+			.len = 1
+		}
+	};
+
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 1);
+
+	ret = i2c_transfer(state->i2c, msg, 2);
+
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 0);
+
+	if (ret != 2) {
+		printk(KERN_ERR "%s: reg=0x%x(error=%d)\n", __func__, reg, ret);
+		return ret;
+	}
+
+	return b1[0];
+}
+
+static int ts2020_writereg(struct dvb_frontend *fe, int reg, int data)
+{
+	struct ts2020_state *state = fe->tuner_priv;
+
+	u8 buf[] = { reg, data };
+	struct i2c_msg msg = { .addr = state->tuner_address,
+		.flags = 0, .buf = buf, .len = 2 };
+	int err;
+
+
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 1);
+
+	err = i2c_transfer(state->i2c, &msg, 1);
+
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 0);
+
+	if (err != 1) {
+		printk(KERN_ERR "%s: writereg error(err == %i, reg == 0x%02x,"
+			 " value == 0x%02x)\n", __func__, err, reg, data);
+		return -EREMOTEIO;
+	}
+
+	return 0;
+}
+
+static int ts2020_init(struct dvb_frontend *fe)
+{
+	ts2020_writereg(fe, 0x42, 0x73);
+	ts2020_writereg(fe, 0x05, 0x01);
+	ts2020_writereg(fe, 0x62, 0xf5);
+	return 0;
+}
+
+static int ts2020_get_frequency(struct dvb_frontend *fe, u32 *frequency)
+{
+	u16 ndiv, div4;
+
+	div4 = (ts2020_readreg(fe, 0x10) & 0x10) >> 4;
+
+	ndiv = ts2020_readreg(fe, 0x01);
+	ndiv &= 0x0f;
+	ndiv <<= 8;
+	ndiv |= ts2020_readreg(fe, 0x02);
+
+	/* actual tuned frequency, i.e. including the offset */
+	*frequency = (ndiv - ndiv % 2 + 1024) * TS2020_XTAL_FREQ
+		/ (6 + 8) / (div4 + 1) / 2;
+
+	return 0;
+}
+
+static int ts2020_set_params(struct dvb_frontend *fe)
+{
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+
+	u8 mlpf, mlpf_new, mlpf_max, mlpf_min, nlpf, div4;
+	u16 value, ndiv;
+	u32 srate = 0, f3db;
+
+	ts2020_init(fe);
+
+	/* unknown */
+	ts2020_writereg(fe, 0x07, 0x02);
+	ts2020_writereg(fe, 0x10, 0x00);
+	ts2020_writereg(fe, 0x60, 0x79);
+	ts2020_writereg(fe, 0x08, 0x01);
+	ts2020_writereg(fe, 0x00, 0x01);
+	div4 = 0;
+
+	/* calculate and set freq divider */
+	if (c->frequency < 1146000) {
+		ts2020_writereg(fe, 0x10, 0x11);
+		div4 = 1;
+		ndiv = ((c->frequency * (6 + 8) * 4) +
+				(TS2020_XTAL_FREQ / 2)) /
+				TS2020_XTAL_FREQ - 1024;
+	} else {
+		ts2020_writereg(fe, 0x10, 0x01);
+		ndiv = ((c->frequency * (6 + 8) * 2) +
+				(TS2020_XTAL_FREQ / 2)) /
+				TS2020_XTAL_FREQ - 1024;
+	}
+
+	ts2020_writereg(fe, 0x01, (ndiv & 0x0f00) >> 8);
+	ts2020_writereg(fe, 0x02, ndiv & 0x00ff);
+
+	/* set pll */
+	ts2020_writereg(fe, 0x03, 0x06);
+	ts2020_writereg(fe, 0x51, 0x0f);
+	ts2020_writereg(fe, 0x51, 0x1f);
+	ts2020_writereg(fe, 0x50, 0x10);
+	ts2020_writereg(fe, 0x50, 0x00);
+	msleep(5);
+
+	/* unknown */
+	ts2020_writereg(fe, 0x51, 0x17);
+	ts2020_writereg(fe, 0x51, 0x1f);
+	ts2020_writereg(fe, 0x50, 0x08);
+	ts2020_writereg(fe, 0x50, 0x00);
+	msleep(5);
+
+	value = ts2020_readreg(fe, 0x3d);
+	value &= 0x0f;
+	if ((value > 4) && (value < 15)) {
+		value -= 3;
+		if (value < 4)
+			value = 4;
+		value = ((value << 3) | 0x01) & 0x79;
+	}
+
+	ts2020_writereg(fe, 0x60, value);
+	ts2020_writereg(fe, 0x51, 0x17);
+	ts2020_writereg(fe, 0x51, 0x1f);
+	ts2020_writereg(fe, 0x50, 0x08);
+	ts2020_writereg(fe, 0x50, 0x00);
+
+	/* set low-pass filter period */
+	ts2020_writereg(fe, 0x04, 0x2e);
+	ts2020_writereg(fe, 0x51, 0x1b);
+	ts2020_writereg(fe, 0x51, 0x1f);
+	ts2020_writereg(fe, 0x50, 0x04);
+	ts2020_writereg(fe, 0x50, 0x00);
+	msleep(5);
+
+	srate = c->symbol_rate / 1000;
+
+	f3db = (srate << 2) / 5 + 2000;
+	if (srate < 5000)
+		f3db += 3000;
+	if (f3db < 7000)
+		f3db = 7000;
+	if (f3db > 40000)
+		f3db = 40000;
+
+	/* set low-pass filter baseband */
+	value = ts2020_readreg(fe, 0x26);
+	mlpf = 0x2e * 207 / ((value << 1) + 151);
+	mlpf_max = mlpf * 135 / 100;
+	mlpf_min = mlpf * 78 / 100;
+	if (mlpf_max > 63)
+		mlpf_max = 63;
+
+	/* rounded to the closest integer */
+	nlpf = ((mlpf * f3db * 1000) + (2766 * TS2020_XTAL_FREQ / 2))
+			/ (2766 * TS2020_XTAL_FREQ);
+	if (nlpf > 23)
+		nlpf = 23;
+	if (nlpf < 1)
+		nlpf = 1;
+
+	/* rounded to the closest integer */
+	mlpf_new = ((TS2020_XTAL_FREQ * nlpf * 2766) +
+			(1000 * f3db / 2)) / (1000 * f3db);
+
+	if (mlpf_new < mlpf_min) {
+		nlpf++;
+		mlpf_new = ((TS2020_XTAL_FREQ * nlpf * 2766) +
+				(1000 * f3db / 2)) / (1000 * f3db);
+	}
+
+	if (mlpf_new > mlpf_max)
+		mlpf_new = mlpf_max;
+
+	ts2020_writereg(fe, 0x04, mlpf_new);
+	ts2020_writereg(fe, 0x06, nlpf);
+	ts2020_writereg(fe, 0x51, 0x1b);
+	ts2020_writereg(fe, 0x51, 0x1f);
+	ts2020_writereg(fe, 0x50, 0x04);
+	ts2020_writereg(fe, 0x50, 0x00);
+	msleep(5);
+
+	/* unknown */
+	ts2020_writereg(fe, 0x51, 0x1e);
+	ts2020_writereg(fe, 0x51, 0x1f);
+	ts2020_writereg(fe, 0x50, 0x01);
+	ts2020_writereg(fe, 0x50, 0x00);
+	msleep(60);
+
+	return 0;
+}
+
+static int ts2020_release(struct dvb_frontend *fe)
+{
+	struct ts2020_state *state = fe->tuner_priv;
+
+	fe->tuner_priv = NULL;
+	kfree(state);
+
+	return 0;
+}
+
+int ts2020_get_signal_strength(struct dvb_frontend *fe,
+	u16 *signal_strength)
+{
+	u16 sig_reading, sig_strength;
+	u8 rfgain, bbgain;
+
+	rfgain = ts2020_readreg(fe, 0x3d) & 0x1f;
+	bbgain = ts2020_readreg(fe, 0x21) & 0x1f;
+
+	if (rfgain > 15)
+		rfgain = 15;
+	if (bbgain > 13)
+		bbgain = 13;
+
+	sig_reading = rfgain * 2 + bbgain * 3;
+
+	sig_strength = 40 + (64 - sig_reading) * 50 / 64 ;
+
+	/* cook the value to be suitable for szap-s2 human readable output */
+	*signal_strength = sig_strength * 1000;
+
+	return 0;
+}
+
+static struct dvb_tuner_ops ts2020_ops = {
+	.info = {
+		.name = "Montage Technology TS2020 Silicon Tuner",
+		.frequency_min = 950000,
+		.frequency_max = 2150000,
+	},
+
+	.init = ts2020_init,
+	.release = ts2020_release,
+	.set_params = ts2020_set_params,
+	.get_frequency = ts2020_get_frequency,
+	.get_rf_strength = ts2020_get_signal_strength
+};
+
+struct dvb_frontend *ts2020_attach(struct dvb_frontend *fe,
+	const struct ts2020_config *config, struct i2c_adapter *i2c)
+{
+	struct ts2020_state *state = NULL;
+
+	/* allocate memory for the internal state */
+	state = kzalloc(sizeof(struct ts2020_state), GFP_KERNEL);
+	if (!state)
+		return NULL;
+
+	/* setup the state */
+	state->tuner_address = config->tuner_address;
+	state->i2c = i2c;
+	fe->tuner_priv = state;
+	fe->ops.tuner_ops = ts2020_ops;
+	fe->ops.read_signal_strength = fe->ops.tuner_ops.get_rf_strength;
+
+	return fe;
+}
+EXPORT_SYMBOL(ts2020_attach);
+
+MODULE_AUTHOR("Konstantin Dimitrov <kosio.dimitrov@gmail.com>");
+MODULE_DESCRIPTION("Montage Technology TS2020 - Silicon tuner driver module");
+MODULE_LICENSE("GPL");
