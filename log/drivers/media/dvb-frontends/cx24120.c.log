commit c942fddf8793b2013be8c901b47d0a8dc02bf99f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:06 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 157
    
    Based on 3 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [kishon] [vijay] [abraham]
      [i] [kishon]@[ti] [com] this program is distributed in the hope that
      it will be useful but without any warranty without even the implied
      warranty of merchantability or fitness for a particular purpose see
      the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [graeme] [gregory]
      [gg]@[slimlogic] [co] [uk] [author] [kishon] [vijay] [abraham] [i]
      [kishon]@[ti] [com] [based] [on] [twl6030]_[usb] [c] [author] [hema]
      [hk] [hemahk]@[ti] [com] this program is distributed in the hope
      that it will be useful but without any warranty without even the
      implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1105 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.202006027@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/media/dvb-frontends/cx24120.c b/drivers/media/dvb-frontends/cx24120.c
index dd3ec316e7c2..2464b63fe0cf 100644
--- a/drivers/media/dvb-frontends/cx24120.c
+++ b/drivers/media/dvb-frontends/cx24120.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
     Conexant cx24120/cx24118 - DVBS/S2 Satellite demod/tuner driver
 
@@ -12,15 +13,6 @@
 
 	Cards supported: Technisat Skystar S2
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
 */
 
 #include <linux/slab.h>

commit f1b1eabff0eb3fc46b06668de8174c0f23b271fd
Author: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
Date:   Thu Jul 5 18:59:36 2018 -0400

    media: dvb: represent min/max/step/tolerance freqs in Hz
    
    Right now, satellite frontend drivers specify frequencies in kHz,
    while terrestrial/cable ones specify in Hz. That's confusing
    for developers.
    
    However, the main problem is that universal frontends capable
    of handling both satellite and non-satelite delivery systems
    are appearing. We end by needing to hack the drivers in
    order to support such hybrid frontends.
    
    So, convert everything to specify frontend frequencies in Hz.
    
    Tested-by: Katsuhiro Suzuki <suzuki.katsuhiro@socionext.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/dvb-frontends/cx24120.c b/drivers/media/dvb-frontends/cx24120.c
index ccbabdae6a69..dd3ec316e7c2 100644
--- a/drivers/media/dvb-frontends/cx24120.c
+++ b/drivers/media/dvb-frontends/cx24120.c
@@ -1555,10 +1555,10 @@ static const struct dvb_frontend_ops cx24120_ops = {
 	.delsys = { SYS_DVBS, SYS_DVBS2 },
 	.info = {
 		.name = "Conexant CX24120/CX24118",
-		.frequency_min = 950000,
-		.frequency_max = 2150000,
-		.frequency_stepsize = 1011, /* kHz for QPSK frontends */
-		.frequency_tolerance = 5000,
+		.frequency_min_hz =  950 * MHz,
+		.frequency_max_hz = 2150 * MHz,
+		.frequency_stepsize_hz = 1011 * kHz,
+		.frequency_tolerance_hz = 5 * MHz,
 		.symbol_rate_min = 1000000,
 		.symbol_rate_max = 45000000,
 		.caps =	FE_CAN_INVERSION_AUTO |

commit 8d718e5376c602dfd41b599dcc2a7b1be07c7b6b
Author: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
Date:   Tue Apr 24 09:19:18 2018 -0400

    media: frontends: fix ops get_algo()'s return type
    
    The method dvb_frontend_ops::get_frontend_algo() is defined as
    returning an 'enum dvbfe_algo', but the implementation in this
    driver returns an 'int'.
    
    Fix this by returning 'enum dvbfe_algo' on drivers.
    
    [mchehab+samsung@kernel.org: merge similar patches and patch
     ddbridge-mci.c the same way]
    Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/dvb-frontends/cx24120.c b/drivers/media/dvb-frontends/cx24120.c
index 810f68acd69b..ccbabdae6a69 100644
--- a/drivers/media/dvb-frontends/cx24120.c
+++ b/drivers/media/dvb-frontends/cx24120.c
@@ -1491,7 +1491,7 @@ static int cx24120_tune(struct dvb_frontend *fe, bool re_tune,
 	return cx24120_read_status(fe, status);
 }
 
-static int cx24120_get_algo(struct dvb_frontend *fe)
+static enum dvbfe_algo cx24120_get_algo(struct dvb_frontend *fe)
 {
 	return DVBFE_ALGO_HW;
 }

commit fada1935590f66dc6784981e0d557ca09013c847
Author: Mauro Carvalho Chehab <mchehab@s-opensource.com>
Date:   Thu Dec 28 13:03:51 2017 -0500

    media: move dvb kAPI headers to include/media
    
    Except for DVB, all media kAPI headers are at include/media.
    
    Move the headers to it.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/cx24120.c b/drivers/media/dvb-frontends/cx24120.c
index 7f11dcc94d85..810f68acd69b 100644
--- a/drivers/media/dvb-frontends/cx24120.c
+++ b/drivers/media/dvb-frontends/cx24120.c
@@ -29,7 +29,7 @@
 #include <linux/moduleparam.h>
 #include <linux/init.h>
 #include <linux/firmware.h>
-#include "dvb_frontend.h"
+#include <media/dvb_frontend.h>
 #include "cx24120.h"
 
 #define CX24120_SEARCH_RANGE_KHZ 5000

commit bd336e63441bcdeeccca6a698087d913a32478c5
Author: Max Kellermann <max.kellermann@gmail.com>
Date:   Tue Aug 9 18:32:21 2016 -0300

    [media] dvb: make DVB frontend *_ops instances "const"
    
    These are immutable.  Making them "const" allows the compiler to move
    them to the "rodata" section.
    
    Note that cxd2841er_t_c_ops cannot be made "const", because
    cxd2841er_attach() modifies it.  Ouch!
    
    [mchehab@s-opensource.com: fix merge conflicts]
    Signed-off-by: Max Kellermann <max.kellermann@gmail.com>
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/cx24120.c b/drivers/media/dvb-frontends/cx24120.c
index 3112a3206d46..7f11dcc94d85 100644
--- a/drivers/media/dvb-frontends/cx24120.c
+++ b/drivers/media/dvb-frontends/cx24120.c
@@ -267,7 +267,7 @@ static int cx24120_writeregs(struct cx24120_state *state,
 	return ret;
 }
 
-static struct dvb_frontend_ops cx24120_ops;
+static const struct dvb_frontend_ops cx24120_ops;
 
 struct dvb_frontend *cx24120_attach(const struct cx24120_config *config,
 				    struct i2c_adapter *i2c)
@@ -1551,7 +1551,7 @@ static int cx24120_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)
 	return 0;
 }
 
-static struct dvb_frontend_ops cx24120_ops = {
+static const struct dvb_frontend_ops cx24120_ops = {
 	.delsys = { SYS_DVBS, SYS_DVBS2 },
 	.info = {
 		.name = "Conexant CX24120/CX24118",

commit c0b34ab141505087d7d66f447d77e6023f34501e
Author: Colin Ian King <colin.king@canonical.com>
Date:   Sat Sep 3 14:04:17 2016 -0300

    [media] cx24120: do not allow an invalid delivery system types
    
    cx24120_set_frontend currently allows invalid delivery system types
    other than SYS_DVBS2 and SYS_DVBS.  Fix this by returning -EINVAL
    for invalid values.
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Acked-by: Jemma Denson <jdenson@gmail.com>

diff --git a/drivers/media/dvb-frontends/cx24120.c b/drivers/media/dvb-frontends/cx24120.c
index 066ee387bf25..3112a3206d46 100644
--- a/drivers/media/dvb-frontends/cx24120.c
+++ b/drivers/media/dvb-frontends/cx24120.c
@@ -1154,8 +1154,7 @@ static int cx24120_set_frontend(struct dvb_frontend *fe)
 		dev_dbg(&state->i2c->dev,
 			"delivery system(%d) not supported\n",
 			c->delivery_system);
-		ret = -EINVAL;
-		break;
+		return -EINVAL;
 	}
 
 	state->dnxt.delsys = c->delivery_system;

commit 035cad576d4e8c472a97b8913f92f73c93205fd3
Author: Jemma Denson <jdenson@gmail.com>
Date:   Sun Feb 28 15:29:50 2016 -0300

    [media] cx24120: make sure tuner is locked at get_frontend
    
    Change get_frontend to re-check current lock status rather than relying
    on a cached value from get_status. Removes potential for tuning failure
    if get_frontend is called during tuning.
    
    Probably not too essential as other changes work around this:
    https://patchwork.linuxtv.org/patch/32845/
    
    Signed-off-by: Jemma Denson <jdenson@gmail.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/cx24120.c b/drivers/media/dvb-frontends/cx24120.c
index 6ccbd86c9490..066ee387bf25 100644
--- a/drivers/media/dvb-frontends/cx24120.c
+++ b/drivers/media/dvb-frontends/cx24120.c
@@ -1507,11 +1507,13 @@ static int cx24120_get_frontend(struct dvb_frontend *fe,
 {
 	struct cx24120_state *state = fe->demodulator_priv;
 	u8 freq1, freq2, freq3;
+	int status;
 
 	dev_dbg(&state->i2c->dev, "\n");
 
 	/* don't return empty data if we're not tuned in */
-	if ((state->fe_status & FE_HAS_LOCK) == 0)
+	status = cx24120_readreg(state, CX24120_REG_STATUS);
+	if (!(status & CX24120_HAS_LOCK))
 		return 0;
 
 	/* Get frequency */

commit 7e3e68bcfd7713fb1470070c8fa0f108609dd76b
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Thu Feb 4 12:58:30 2016 -0200

    [media] dvb_frontend: pass the props cache to get_frontend() as arg
    
    Instead of using the DTV properties cache directly, pass the get
    frontend data as an argument. For now, everything should remain
    the same, but the next patch will prevent get_frontend to
    affect the global cache.
    
    This is needed because several drivers don't care enough to only
    change the properties if locked. Due to that, calling
    G_PROPERTY before locking on those drivers will make them to
    never lock. Ok, those drivers are crap and should never be
    merged like that, but the core should not rely that the drivers
    would be doing the right thing.
    
    Reviewed-by: Michael Ira Krufky <mkrufky@linuxtv.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/cx24120.c b/drivers/media/dvb-frontends/cx24120.c
index 3b0ef52bb834..6ccbd86c9490 100644
--- a/drivers/media/dvb-frontends/cx24120.c
+++ b/drivers/media/dvb-frontends/cx24120.c
@@ -1502,9 +1502,9 @@ static int cx24120_sleep(struct dvb_frontend *fe)
 	return 0;
 }
 
-static int cx24120_get_frontend(struct dvb_frontend *fe)
+static int cx24120_get_frontend(struct dvb_frontend *fe,
+				struct dtv_frontend_properties *c)
 {
-	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
 	struct cx24120_state *state = fe->demodulator_priv;
 	u8 freq1, freq2, freq3;
 

commit 0df289a209e02f0926042ab07d7d2595ea2d2e9b
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Sun Jun 7 14:53:52 2015 -0300

    [media] dvb: Get rid of typedev usage for enums
    
    The DVB API was originally defined using typedefs. This is against
    Kernel CodingStyle, and there's no good usage here. While we can't
    remove its usage on userspace, we can avoid its usage in Kernelspace.
    
    So, let's do it.
    
    This patch was generated by this shell script:
    
            for j in $(grep typedef include/uapi/linux/dvb/frontend.h |cut -d' ' -f 3); do for i in $(find drivers/media -name '*.[ch]' -type f) $(find drivers/staging/media -name '*.[ch]' -type f); do sed "s,${j}_t,enum $j," <$i >a && mv a $i; done; done
    
    While here, make CodingStyle fixes on the affected lines.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
    Acked-by: Stefan Richter <stefanr@s5r6.in-berlin.de> # for drivers/media/firewire/*

diff --git a/drivers/media/dvb-frontends/cx24120.c b/drivers/media/dvb-frontends/cx24120.c
index a1d1b1c44b40..3b0ef52bb834 100644
--- a/drivers/media/dvb-frontends/cx24120.c
+++ b/drivers/media/dvb-frontends/cx24120.c
@@ -118,12 +118,12 @@ enum command_message_id {
 struct cx24120_tuning {
 	u32 frequency;
 	u32 symbol_rate;
-	fe_spectral_inversion_t inversion;
-	fe_code_rate_t fec;
+	enum fe_spectral_inversion inversion;
+	enum fe_code_rate fec;
 
-	fe_delivery_system_t delsys;
-	fe_modulation_t modulation;
-	fe_pilot_t pilot;
+	enum fe_delivery_system delsys;
+	enum fe_modulation modulation;
+	enum fe_pilot pilot;
 
 	/* Demod values */
 	u8 fec_val;
@@ -148,7 +148,7 @@ struct cx24120_state {
 	struct cx24120_tuning dcur;
 	struct cx24120_tuning dnxt;
 
-	fe_status_t fe_status;
+	enum fe_status fe_status;
 
 	/* dvbv5 stats calculations */
 	u32 bitrate;
@@ -491,7 +491,7 @@ static int cx24120_msg_mpeg_output_config(struct cx24120_state *state, u8 seq)
 }
 
 static int cx24120_diseqc_send_burst(struct dvb_frontend *fe,
-				     fe_sec_mini_cmd_t burst)
+				     enum fe_sec_mini_cmd burst)
 {
 	struct cx24120_state *state = fe->demodulator_priv;
 	struct cx24120_cmd cmd;
@@ -513,7 +513,7 @@ static int cx24120_diseqc_send_burst(struct dvb_frontend *fe,
 	return cx24120_message_send(state, &cmd);
 }
 
-static int cx24120_set_tone(struct dvb_frontend *fe, fe_sec_tone_mode_t tone)
+static int cx24120_set_tone(struct dvb_frontend *fe, enum fe_sec_tone_mode tone)
 {
 	struct cx24120_state *state = fe->demodulator_priv;
 	struct cx24120_cmd cmd;
@@ -536,7 +536,7 @@ static int cx24120_set_tone(struct dvb_frontend *fe, fe_sec_tone_mode_t tone)
 }
 
 static int cx24120_set_voltage(struct dvb_frontend *fe,
-			       fe_sec_voltage_t voltage)
+			       enum fe_sec_voltage voltage)
 {
 	struct cx24120_state *state = fe->demodulator_priv;
 	struct cx24120_cmd cmd;
@@ -713,7 +713,7 @@ static void cx24120_get_stats(struct cx24120_state *state)
 static void cx24120_set_clock_ratios(struct dvb_frontend *fe);
 
 /* Read current tuning status */
-static int cx24120_read_status(struct dvb_frontend *fe, fe_status_t *status)
+static int cx24120_read_status(struct dvb_frontend *fe, enum fe_status *status)
 {
 	struct cx24120_state *state = fe->demodulator_priv;
 	int lock;
@@ -765,9 +765,9 @@ static int cx24120_read_status(struct dvb_frontend *fe, fe_status_t *status)
  * once tuned in.
  */
 struct cx24120_modfec {
-	fe_delivery_system_t delsys;
-	fe_modulation_t mod;
-	fe_code_rate_t fec;
+	enum fe_delivery_system delsys;
+	enum fe_modulation mod;
+	enum fe_code_rate fec;
 	u8 val;
 };
 
@@ -871,10 +871,10 @@ static void cx24120_calculate_ber_window(struct cx24120_state *state, u32 rate)
  * can't determine the pattern
  */
 struct cx24120_clock_ratios_table {
-	fe_delivery_system_t delsys;
-	fe_pilot_t pilot;
-	fe_modulation_t mod;
-	fe_code_rate_t fec;
+	enum fe_delivery_system delsys;
+	enum fe_pilot pilot;
+	enum fe_modulation mod;
+	enum fe_code_rate fec;
 	u32 m_rat;
 	u32 n_rat;
 	u32 rate;
@@ -988,7 +988,7 @@ static void cx24120_set_clock_ratios(struct dvb_frontend *fe)
 
 /* Set inversion value */
 static int cx24120_set_inversion(struct cx24120_state *state,
-				 fe_spectral_inversion_t inversion)
+				 enum fe_spectral_inversion inversion)
 {
 	dev_dbg(&state->i2c->dev, "(%d)\n", inversion);
 
@@ -1013,9 +1013,9 @@ static int cx24120_set_inversion(struct cx24120_state *state,
 
 /* FEC lookup table for tuning */
 struct cx24120_modfec_table {
-	fe_delivery_system_t delsys;
-	fe_modulation_t mod;
-	fe_code_rate_t fec;
+	enum fe_delivery_system delsys;
+	enum fe_modulation mod;
+	enum fe_code_rate fec;
 	u8 val;
 };
 
@@ -1046,8 +1046,8 @@ static const struct cx24120_modfec_table modfec_table[] = {
 };
 
 /* Set fec_val & fec_mask values from delsys, modulation & fec */
-static int cx24120_set_fec(struct cx24120_state *state, fe_modulation_t mod,
-			   fe_code_rate_t fec)
+static int cx24120_set_fec(struct cx24120_state *state, enum fe_modulation mod,
+			   enum fe_code_rate fec)
 {
 	int idx;
 
@@ -1084,7 +1084,7 @@ static int cx24120_set_fec(struct cx24120_state *state, fe_modulation_t mod,
 }
 
 /* Set pilot */
-static int cx24120_set_pilot(struct cx24120_state *state, fe_pilot_t pilot)
+static int cx24120_set_pilot(struct cx24120_state *state, enum fe_pilot pilot)
 {
 	dev_dbg(&state->i2c->dev, "(%d)\n", pilot);
 
@@ -1474,7 +1474,7 @@ static int cx24120_init(struct dvb_frontend *fe)
 
 static int cx24120_tune(struct dvb_frontend *fe, bool re_tune,
 			unsigned int mode_flags, unsigned int *delay,
-			fe_status_t *status)
+			enum fe_status *status)
 {
 	struct cx24120_state *state = fe->demodulator_priv;
 	int ret;

commit edff2bac9d3c3b94c0e790a49289824ff2c0a68c
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Fri May 22 10:44:49 2015 -0300

    [media] cx24120: fix sparse warning
    
    drivers/media/dvb-frontends/cx24120.c:837:6: warning: symbol 'cx24120_calculate_ber_window' was not declared. Should it be static?
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/cx24120.c b/drivers/media/dvb-frontends/cx24120.c
index 10a948ef8440..a1d1b1c44b40 100644
--- a/drivers/media/dvb-frontends/cx24120.c
+++ b/drivers/media/dvb-frontends/cx24120.c
@@ -838,7 +838,7 @@ static int cx24120_get_fec(struct dvb_frontend *fe)
 }
 
 /* Calculate ber window time */
-void cx24120_calculate_ber_window(struct cx24120_state *state, u32 rate)
+static void cx24120_calculate_ber_window(struct cx24120_state *state, u32 rate)
 {
 	struct dvb_frontend *fe = &state->frontend;
 	struct dtv_frontend_properties *c = &fe->dtv_property_cache;

commit bf8de2d38a4ba82a69db221915375199c9e5d761
Author: Jemma Denson <jdenson@gmail.com>
Date:   Wed May 20 11:57:49 2015 -0300

    [media] cx24120: Assume ucb registers is a counter
    
    The ucblocks register is probably a counter and not a rate; assume
    it is so and change the calculations as required.
    
    Signed-off-by: Jemma Denson <jdenson@gmail.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/cx24120.c b/drivers/media/dvb-frontends/cx24120.c
index a14d0f1cc71e..10a948ef8440 100644
--- a/drivers/media/dvb-frontends/cx24120.c
+++ b/drivers/media/dvb-frontends/cx24120.c
@@ -154,7 +154,7 @@ struct cx24120_state {
 	u32 bitrate;
 	u32 berw_usecs;
 	u32 ber_prev;
-	u32 per_prev;
+	u32 ucb_offset;
 	unsigned long ber_jiffies_stats;
 	unsigned long per_jiffies_stats;
 };
@@ -698,8 +698,12 @@ static void cx24120_get_stats(struct cx24120_state *state)
 		ucb |= cx24120_readreg(state, CX24120_REG_UCB_L);
 		dev_dbg(&state->i2c->dev, "ucblocks = %d\n", ucb);
 
+		/* handle reset */
+		if (ucb < state->ucb_offset)
+			state->ucb_offset = c->block_error.stat[0].uvalue;
+
 		c->block_error.stat[0].scale = FE_SCALE_COUNTER;
-		c->block_error.stat[0].uvalue += ucb;
+		c->block_error.stat[0].uvalue = ucb + state->ucb_offset;
 
 		c->block_count.stat[0].scale = FE_SCALE_COUNTER;
 		c->block_count.stat[0].uvalue += state->bitrate / 8 / 208;
@@ -1541,8 +1545,7 @@ static int cx24120_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)
 		return 0;
 	}
 
-	*ucblocks = c->block_error.stat[0].uvalue - state->per_prev;
-	state->per_prev = c->block_error.stat[0].uvalue;
+	*ucblocks = c->block_error.stat[0].uvalue - state->ucb_offset;
 
 	return 0;
 }

commit 71df673132cd5eef9ae2d9c79e3a446249de4961
Author: Patrick Boettcher <patrick.boettcher@posteo.de>
Date:   Wed May 20 04:58:49 2015 -0300

    [media] cx24120: fix minor checkpatch-error
    
    Remove multiple blank likes.
    
    Signed-off-by: Patrick Boettcher <patrick.boettcher@posteo.de>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/cx24120.c b/drivers/media/dvb-frontends/cx24120.c
index d1c7ccb94c22..a14d0f1cc71e 100644
--- a/drivers/media/dvb-frontends/cx24120.c
+++ b/drivers/media/dvb-frontends/cx24120.c
@@ -1463,8 +1463,8 @@ static int cx24120_init(struct dvb_frontend *fe)
 	c->block_count.len = 1;
 	c->block_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
 
-
 	state->cold_init = 1;
+
 	return 0;
 }
 

commit c9adafa3b2fd4bc5f15cdf95e6cbd25256ae0f28
Author: Jemma Denson <jdenson@gmail.com>
Date:   Tue May 19 17:32:55 2015 -0300

    [media] cx24120: Update comment & fix typo
    
    These state vars are used for more than just ber calculation, also
    fix typo.
    
    Signed-off-by: Jemma Denson <jdenson@gmail.com>
    Signed-off-by: Patrick Boettcher <patrick.boettcher@posteo.de>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/cx24120.c b/drivers/media/dvb-frontends/cx24120.c
index dc80e6affeae..d1c7ccb94c22 100644
--- a/drivers/media/dvb-frontends/cx24120.c
+++ b/drivers/media/dvb-frontends/cx24120.c
@@ -150,7 +150,7 @@ struct cx24120_state {
 
 	fe_status_t fe_status;
 
-	/* ber stats calulations */
+	/* dvbv5 stats calculations */
 	u32 bitrate;
 	u32 berw_usecs;
 	u32 ber_prev;

commit e3f2f63e8cc8a9b9a16f351b55a108ab82de6d2e
Author: Jemma Denson <jdenson@gmail.com>
Date:   Tue May 19 17:23:14 2015 -0300

    [media] cx24120: Check for lock before updating BER & UCB
    
    BER & UCB aren't available unless we're locked; don't update dvbv5
    stats when not locked and mark these counters as unavailable.
    
    Signed-off-by: Jemma Denson <jdenson@gmail.com>
    Signed-off-by: Patrick Boettcher <patrick.boettcher@posteo.de>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/cx24120.c b/drivers/media/dvb-frontends/cx24120.c
index ce784248b328..dc80e6affeae 100644
--- a/drivers/media/dvb-frontends/cx24120.c
+++ b/drivers/media/dvb-frontends/cx24120.c
@@ -663,6 +663,15 @@ static void cx24120_get_stats(struct cx24120_state *state)
 		c->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
 	}
 
+	/* BER & UCB require lock */
+	if (!(state->fe_status & FE_HAS_LOCK)) {
+		c->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+		c->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+		c->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+		c->block_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+		return;
+	}
+
 	/* BER */
 	if (time_after(jiffies, state->ber_jiffies_stats)) {
 		msecs = (state->berw_usecs + 500) / 1000;

commit 80e9710b34550ae906424feb2cf40dee0422ce46
Author: Jemma Denson <jdenson@gmail.com>
Date:   Tue May 19 15:52:46 2015 -0300

    [media] cx24120: Convert ucblocks to dvbv5 stats
    
    DVBv3 is a legacy API. Drivers should use DVBv5, in order to support
    modern applications. So, implement UCB using dvbv5.
    
    Signed-off-by: Jemma Denson <jdenson@gmail.com>
    Signed-off-by: Patrick Boettcher <patrick.boettcher@posteo.de>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/cx24120.c b/drivers/media/dvb-frontends/cx24120.c
index 3fe9da28e978..ce784248b328 100644
--- a/drivers/media/dvb-frontends/cx24120.c
+++ b/drivers/media/dvb-frontends/cx24120.c
@@ -151,9 +151,12 @@ struct cx24120_state {
 	fe_status_t fe_status;
 
 	/* ber stats calulations */
+	u32 bitrate;
 	u32 berw_usecs;
 	u32 ber_prev;
+	u32 per_prev;
 	unsigned long ber_jiffies_stats;
+	unsigned long per_jiffies_stats;
 };
 
 /* Command message to firmware */
@@ -612,7 +615,7 @@ static void cx24120_get_stats(struct cx24120_state *state)
 	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
 	struct cx24120_cmd cmd;
 	int ret, cnr, msecs;
-	u16 sig;
+	u16 sig, ucb;
 	u32 ber;
 
 	dev_dbg(&state->i2c->dev, "\n");
@@ -678,7 +681,20 @@ static void cx24120_get_stats(struct cx24120_state *state)
 		c->post_bit_count.stat[0].uvalue += CX24120_BER_WSIZE;
 	}
 
-	/* FIXME: add UCB */
+	/* UCB */
+	if (time_after(jiffies, state->per_jiffies_stats)) {
+		state->per_jiffies_stats = jiffies + msecs_to_jiffies(1000);
+
+		ucb = cx24120_readreg(state, CX24120_REG_UCB_H) << 8;
+		ucb |= cx24120_readreg(state, CX24120_REG_UCB_L);
+		dev_dbg(&state->i2c->dev, "ucblocks = %d\n", ucb);
+
+		c->block_error.stat[0].scale = FE_SCALE_COUNTER;
+		c->block_error.stat[0].uvalue += ucb;
+
+		c->block_count.stat[0].scale = FE_SCALE_COUNTER;
+		c->block_count.stat[0].uvalue += state->bitrate / 8 / 208;
+	}
 }
 
 static void cx24120_set_clock_ratios(struct dvb_frontend *fe);
@@ -813,22 +829,23 @@ void cx24120_calculate_ber_window(struct cx24120_state *state, u32 rate)
 {
 	struct dvb_frontend *fe = &state->frontend;
 	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
-	u64 bitrate, tmp;
+	u64 tmp;
 
 	/*
 	 * Calculate bitrate from rate in the clock ratios table.
 	 * This isn't *exactly* right but close enough.
 	 */
-	bitrate = (u64)c->symbol_rate * rate;
-	do_div(bitrate, 256);
+	tmp = (u64)c->symbol_rate * rate;
+	do_div(tmp, 256);
+	state->bitrate = tmp;
 
 	/* usecs per ber window */
 	tmp = 1000000ULL * CX24120_BER_WSIZE;
-	do_div(tmp, bitrate);
+	do_div(tmp, state->bitrate);
 	state->berw_usecs = tmp;
 
-	dev_dbg(&state->i2c->dev, "bitrate: %llu, berw_usecs: %u\n",
-		bitrate, state->berw_usecs);
+	dev_dbg(&state->i2c->dev, "bitrate: %u, berw_usecs: %u\n",
+		state->bitrate, state->berw_usecs);
 }
 
 /*
@@ -1432,6 +1449,11 @@ static int cx24120_init(struct dvb_frontend *fe)
 	c->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
 	c->post_bit_count.len = 1;
 	c->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	c->block_error.len = 1;
+	c->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	c->block_count.len = 1;
+	c->block_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+
 
 	state->cold_init = 1;
 	return 0;
@@ -1503,11 +1525,16 @@ static void cx24120_release(struct dvb_frontend *fe)
 static int cx24120_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)
 {
 	struct cx24120_state *state = fe->demodulator_priv;
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+
+	if (c->block_error.stat[0].scale != FE_SCALE_COUNTER) {
+		*ucblocks = 0;
+		return 0;
+	}
 
-	*ucblocks = (cx24120_readreg(state, CX24120_REG_UCB_H) << 8) |
-		     cx24120_readreg(state, CX24120_REG_UCB_L);
+	*ucblocks = c->block_error.stat[0].uvalue - state->per_prev;
+	state->per_prev = c->block_error.stat[0].uvalue;
 
-	dev_dbg(&state->i2c->dev, "ucblocks = %d\n", *ucblocks);
 	return 0;
 }
 

commit fc4432847866baf1d3ad3348cce976c0299be081
Author: Jemma Denson <jdenson@gmail.com>
Date:   Tue May 19 15:29:44 2015 -0300

    [media] cx24120: Convert read_ber to retrieve from cache
    
    Instead of reading BER again for DVBv3 call, use the value from the cache.
    
    Signed-off-by: Jemma Denson <jdenson@gmail.com>
    Signed-off-by: Patrick Boettcher <patrick.boettcher@posteo.de>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/cx24120.c b/drivers/media/dvb-frontends/cx24120.c
index 2d4678091d7a..3fe9da28e978 100644
--- a/drivers/media/dvb-frontends/cx24120.c
+++ b/drivers/media/dvb-frontends/cx24120.c
@@ -152,6 +152,7 @@ struct cx24120_state {
 
 	/* ber stats calulations */
 	u32 berw_usecs;
+	u32 ber_prev;
 	unsigned long ber_jiffies_stats;
 };
 
@@ -338,12 +339,15 @@ static int cx24120_read_snr(struct dvb_frontend *fe, u16 *snr)
 static int cx24120_read_ber(struct dvb_frontend *fe, u32 *ber)
 {
 	struct cx24120_state *state = fe->demodulator_priv;
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+
+	if (c->post_bit_error.stat[0].scale != FE_SCALE_COUNTER) {
+		*ber = 0;
+		return 0;
+	}
 
-	*ber =  (cx24120_readreg(state, CX24120_REG_BER_HH) << 24)	|
-		(cx24120_readreg(state, CX24120_REG_BER_HL) << 16)	|
-		(cx24120_readreg(state, CX24120_REG_BER_LH) <<  8)	|
-		 cx24120_readreg(state, CX24120_REG_BER_LL);
-	dev_dbg(&state->i2c->dev, "read BER index = %d\n", *ber);
+	*ber = c->post_bit_error.stat[0].uvalue - state->ber_prev;
+	state->ber_prev = c->post_bit_error.stat[0].uvalue;
 
 	return 0;
 }
@@ -661,9 +665,11 @@ static void cx24120_get_stats(struct cx24120_state *state)
 		msecs = (state->berw_usecs + 500) / 1000;
 		state->ber_jiffies_stats = jiffies + msecs_to_jiffies(msecs);
 
-		ret = cx24120_read_ber(fe, &ber);
-		if (ret != 0)
-			return;
+		ber = cx24120_readreg(state, CX24120_REG_BER_HH) << 24;
+		ber |= cx24120_readreg(state, CX24120_REG_BER_HL) << 16;
+		ber |= cx24120_readreg(state, CX24120_REG_BER_LH) << 8;
+		ber |= cx24120_readreg(state, CX24120_REG_BER_LL);
+		dev_dbg(&state->i2c->dev, "read BER index = %d\n", ber);
 
 		c->post_bit_error.stat[0].scale = FE_SCALE_COUNTER;
 		c->post_bit_error.stat[0].uvalue += ber;

commit ddcb252e41c15b360c0e9a172fbd29d3f0ed18cd
Author: Jemma Denson <jdenson@gmail.com>
Date:   Tue May 19 15:17:23 2015 -0300

    [media] cx24120: Add in dvbv5 stats for bit error rate
    
    DVBv3 is a legacy API. Drivers should use DVBv5, in order to support
    modern applications. So, implement BER using dvbv5.
    
    Signed-off-by: Jemma Denson <jdenson@gmail.com>
    Signed-off-by: Patrick Boettcher <patrick.boettcher@posteo.de>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/cx24120.c b/drivers/media/dvb-frontends/cx24120.c
index 2b3f83d5b997..2d4678091d7a 100644
--- a/drivers/media/dvb-frontends/cx24120.c
+++ b/drivers/media/dvb-frontends/cx24120.c
@@ -87,7 +87,7 @@ enum command_message_id {
 
 	CMD_FWVERSION		= 0x35,
 
-	CMD_TUNER_INIT		= 0x3c,		/* cmd.len = 0x03; */
+	CMD_BER_CTRL		= 0x3c,		/* cmd.len = 0x03; */
 };
 
 #define CX24120_MAX_CMD_LEN	30
@@ -107,6 +107,10 @@ enum command_message_id {
 #define CX24120_STATUS_MASK	0x0f
 #define CX24120_SIGNAL_MASK	0xc0
 
+/* ber window */
+#define CX24120_BER_WINDOW	16
+#define CX24120_BER_WSIZE	((1 << CX24120_BER_WINDOW) * 208 * 8)
+
 #define info(args...) pr_info("cx24120: " args)
 #define err(args...)  pr_err("cx24120: ### ERROR: " args)
 
@@ -145,6 +149,10 @@ struct cx24120_state {
 	struct cx24120_tuning dnxt;
 
 	fe_status_t fe_status;
+
+	/* ber stats calulations */
+	u32 berw_usecs;
+	unsigned long ber_jiffies_stats;
 };
 
 /* Command message to firmware */
@@ -599,8 +607,9 @@ static void cx24120_get_stats(struct cx24120_state *state)
 	struct dvb_frontend *fe = &state->frontend;
 	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
 	struct cx24120_cmd cmd;
-	int ret, cnr;
+	int ret, cnr, msecs;
 	u16 sig;
+	u32 ber;
 
 	dev_dbg(&state->i2c->dev, "\n");
 
@@ -647,7 +656,23 @@ static void cx24120_get_stats(struct cx24120_state *state)
 		c->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
 	}
 
-	/* FIXME: add UCB/BER */
+	/* BER */
+	if (time_after(jiffies, state->ber_jiffies_stats)) {
+		msecs = (state->berw_usecs + 500) / 1000;
+		state->ber_jiffies_stats = jiffies + msecs_to_jiffies(msecs);
+
+		ret = cx24120_read_ber(fe, &ber);
+		if (ret != 0)
+			return;
+
+		c->post_bit_error.stat[0].scale = FE_SCALE_COUNTER;
+		c->post_bit_error.stat[0].uvalue += ber;
+
+		c->post_bit_count.stat[0].scale = FE_SCALE_COUNTER;
+		c->post_bit_count.stat[0].uvalue += CX24120_BER_WSIZE;
+	}
+
+	/* FIXME: add UCB */
 }
 
 static void cx24120_set_clock_ratios(struct dvb_frontend *fe);
@@ -777,6 +802,29 @@ static int cx24120_get_fec(struct dvb_frontend *fe)
 	return 0;
 }
 
+/* Calculate ber window time */
+void cx24120_calculate_ber_window(struct cx24120_state *state, u32 rate)
+{
+	struct dvb_frontend *fe = &state->frontend;
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	u64 bitrate, tmp;
+
+	/*
+	 * Calculate bitrate from rate in the clock ratios table.
+	 * This isn't *exactly* right but close enough.
+	 */
+	bitrate = (u64)c->symbol_rate * rate;
+	do_div(bitrate, 256);
+
+	/* usecs per ber window */
+	tmp = 1000000ULL * CX24120_BER_WSIZE;
+	do_div(tmp, bitrate);
+	state->berw_usecs = tmp;
+
+	dev_dbg(&state->i2c->dev, "bitrate: %llu, berw_usecs: %u\n",
+		bitrate, state->berw_usecs);
+}
+
 /*
  * Clock ratios lookup table
  *
@@ -897,6 +945,9 @@ static void cx24120_set_clock_ratios(struct dvb_frontend *fe)
 	cmd.arg[9] = (clock_ratios_table[idx].rate >> 0) & 0xff;
 
 	cx24120_message_send(state, &cmd);
+
+	/* Calculate ber window rates for stat work */
+	cx24120_calculate_ber_window(state, clock_ratios_table[idx].rate);
 }
 
 /* Set inversion value */
@@ -1343,14 +1394,14 @@ static int cx24120_init(struct dvb_frontend *fe)
 		return -EREMOTEIO;
 	}
 
-	/* ???? */
-	cmd.id = CMD_TUNER_INIT;
+	/* Set size of BER window */
+	cmd.id = CMD_BER_CTRL;
 	cmd.len = 3;
 	cmd.arg[0] = 0x00;
-	cmd.arg[1] = 0x10;
-	cmd.arg[2] = 0x10;
+	cmd.arg[1] = CX24120_BER_WINDOW;
+	cmd.arg[2] = CX24120_BER_WINDOW;
 	if (cx24120_message_send(state, &cmd)) {
-		err("Error sending final init message. :(\n");
+		err("Error setting ber window\n");
 		return -EREMOTEIO;
 	}
 
@@ -1371,6 +1422,10 @@ static int cx24120_init(struct dvb_frontend *fe)
 	c->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
 	c->cnr.len = 1;
 	c->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	c->post_bit_error.len = 1;
+	c->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	c->post_bit_count.len = 1;
+	c->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
 
 	state->cold_init = 1;
 	return 0;

commit ec8fe6c92576a0d6e2b04df2ef139125c3f341b5
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Tue May 19 08:19:47 2015 -0300

    [media] cx24120: constify static data
    
    Use const on the static data, as gcc may optimize better the
    code. Also, would prevent that some code would override the
    data there.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
    Signed-off-by: Patrick Boettcher <patrick.boettcher@posteo.de>

diff --git a/drivers/media/dvb-frontends/cx24120.c b/drivers/media/dvb-frontends/cx24120.c
index 2dcd93f63408..2b3f83d5b997 100644
--- a/drivers/media/dvb-frontends/cx24120.c
+++ b/drivers/media/dvb-frontends/cx24120.c
@@ -704,12 +704,14 @@ static int cx24120_read_status(struct dvb_frontend *fe, fe_status_t *status)
  * Used for decoding the REG_FECMODE register
  * once tuned in.
  */
-static struct cx24120_modfec {
+struct cx24120_modfec {
 	fe_delivery_system_t delsys;
 	fe_modulation_t mod;
 	fe_code_rate_t fec;
 	u8 val;
-} modfec_lookup_table[] = {
+};
+
+static const struct cx24120_modfec modfec_lookup_table[] = {
 	/*delsys     mod    fec       val */
 	{ SYS_DVBS,  QPSK,  FEC_1_2,  0x01 },
 	{ SYS_DVBS,  QPSK,  FEC_2_3,  0x02 },
@@ -784,7 +786,7 @@ static int cx24120_get_fec(struct dvb_frontend *fe)
  * There's probably some way of calculating these but I
  * can't determine the pattern
  */
-static struct cx24120_clock_ratios_table {
+struct cx24120_clock_ratios_table {
 	fe_delivery_system_t delsys;
 	fe_pilot_t pilot;
 	fe_modulation_t mod;
@@ -792,7 +794,9 @@ static struct cx24120_clock_ratios_table {
 	u32 m_rat;
 	u32 n_rat;
 	u32 rate;
-} clock_ratios_table[] = {
+};
+
+static const struct cx24120_clock_ratios_table clock_ratios_table[] = {
 	/*delsys     pilot      mod    fec       m_rat    n_rat   rate */
 	{ SYS_DVBS2, PILOT_OFF, QPSK,  FEC_1_2,  273088,  254505, 274 },
 	{ SYS_DVBS2, PILOT_OFF, QPSK,  FEC_3_5,  17272,   13395,  330 },
@@ -921,12 +925,14 @@ static int cx24120_set_inversion(struct cx24120_state *state,
 }
 
 /* FEC lookup table for tuning */
-static struct cx24120_modfec_table {
+struct cx24120_modfec_table {
 	fe_delivery_system_t delsys;
 	fe_modulation_t mod;
 	fe_code_rate_t fec;
 	u8 val;
-} modfec_table[] = {
+};
+
+static const struct cx24120_modfec_table modfec_table[] = {
 	/*delsys     mod    fec       val */
 	{ SYS_DVBS,  QPSK,  FEC_1_2,  0x2e },
 	{ SYS_DVBS,  QPSK,  FEC_2_3,  0x2f },

commit 5b8bc802e79f4f1df7fcf6999c910d6e231e3c95
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Tue May 19 08:06:52 2015 -0300

    [media] cx24120: declare cx24120_init() as static
    
    drivers/media/dvb-frontends/cx24120.c:1182:5: warning: no previous prototype for 'cx24120_init' [-Wmissing-prototypes]
     int cx24120_init(struct dvb_frontend *fe)
         ^
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
    Signed-off-by: Patrick Boettcher <patrick.boettcher@posteo.de>

diff --git a/drivers/media/dvb-frontends/cx24120.c b/drivers/media/dvb-frontends/cx24120.c
index 3ab8582e233b..2dcd93f63408 100644
--- a/drivers/media/dvb-frontends/cx24120.c
+++ b/drivers/media/dvb-frontends/cx24120.c
@@ -1179,7 +1179,7 @@ static int cx24120_set_vco(struct cx24120_state *state)
 	return cx24120_message_send(state, &cmd);
 }
 
-int cx24120_init(struct dvb_frontend *fe)
+static int cx24120_init(struct dvb_frontend *fe)
 {
 	const struct firmware *fw;
 	struct dtv_frontend_properties *c = &fe->dtv_property_cache;

commit 65b01665a98a8738371d945230f4bd6fb41a3594
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Tue May 19 08:04:35 2015 -0300

    [media] cx24120: don't initialize a var that won't be used
    
    As reported by smatch:
    drivers/media/dvb-frontends/cx24120.c: In function 'cx24120_message_send':
    drivers/media/dvb-frontends/cx24120.c:368:6: warning: variable 'ret' set but not used [-Wunused-but-set-variable]
      int ret, ficus;
          ^
    
    The values written by cx24120 are never checked. So, remove the
    check here too. That's said, the best would be to do the reverse,
    but globally: to properly handle the error codes.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
    Signed-off-by: Patrick Boettcher <patrick.boettcher@posteo.de>

diff --git a/drivers/media/dvb-frontends/cx24120.c b/drivers/media/dvb-frontends/cx24120.c
index da50b9e1e9f8..3ab8582e233b 100644
--- a/drivers/media/dvb-frontends/cx24120.c
+++ b/drivers/media/dvb-frontends/cx24120.c
@@ -365,17 +365,17 @@ static void cx24120_check_cmd(struct cx24120_state *state, u8 id)
 static int cx24120_message_send(struct cx24120_state *state,
 				struct cx24120_cmd *cmd)
 {
-	int ret, ficus;
+	int ficus;
 
 	if (state->mpeg_enabled) {
 		/* Disable mpeg out on certain commands */
 		cx24120_check_cmd(state, cmd->id);
 	}
 
-	ret = cx24120_writereg(state, CX24120_REG_CMD_START, cmd->id);
-	ret = cx24120_writeregs(state, CX24120_REG_CMD_ARGS, &cmd->arg[0],
-				cmd->len, 1);
-	ret = cx24120_writereg(state, CX24120_REG_CMD_END, 0x01);
+	cx24120_writereg(state, CX24120_REG_CMD_START, cmd->id);
+	cx24120_writeregs(state, CX24120_REG_CMD_ARGS, &cmd->arg[0],
+			  cmd->len, 1);
+	cx24120_writereg(state, CX24120_REG_CMD_END, 0x01);
 
 	ficus = 1000;
 	while (cx24120_readreg(state, CX24120_REG_CMD_END)) {

commit 5c0a1c28c064e5998f6d6f48826e9701e9f68af2
Author: Jemma Denson <jdenson@gmail.com>
Date:   Fri May 15 16:08:26 2015 -0300

    [media] cx24120: Complete modfec_table
    
    Add in all the likely values for setting fec on tuning. Some values
    yet to be tested but very likely to be correct.
    In the very unlikely event that these are wrong tuning with
    FEC_AUTO will still work.
    
    Signed-off-by: Jemma Denson <jdenson@gmail.com>
    Signed-off-by: Patrick Boettcher <patrick.boettcher@posteo.de>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/cx24120.c b/drivers/media/dvb-frontends/cx24120.c
index bc8d0ebb63b6..da50b9e1e9f8 100644
--- a/drivers/media/dvb-frontends/cx24120.c
+++ b/drivers/media/dvb-frontends/cx24120.c
@@ -920,32 +920,36 @@ static int cx24120_set_inversion(struct cx24120_state *state,
 	return 0;
 }
 
-/*
- * FEC lookup table for tuning Some DVB-S2 val's have been found by
- * trial and error. Sofar it seems to match up with the contents of
- * the REG_FECMODE after tuning The rest will probably be the same but
- * would need testing.  Anything not in the table will run with
- * FEC_AUTO and take a while longer to tune in ( c.500ms instead of
- * 30ms )
- */
+/* FEC lookup table for tuning */
 static struct cx24120_modfec_table {
 	fe_delivery_system_t delsys;
 	fe_modulation_t mod;
 	fe_code_rate_t fec;
 	u8 val;
 } modfec_table[] = {
-	/*delsys	mod	fec	 val */
-	{ SYS_DVBS,  QPSK,  FEC_1_2, 0x2e },
-	{ SYS_DVBS,  QPSK,  FEC_2_3, 0x2f },
-	{ SYS_DVBS,  QPSK,  FEC_3_4, 0x30 },
-	{ SYS_DVBS,  QPSK,  FEC_5_6, 0x31 },
-	{ SYS_DVBS,  QPSK,  FEC_6_7, 0x32 },
-	{ SYS_DVBS,  QPSK,  FEC_7_8, 0x33 },
-
-	{ SYS_DVBS2, QPSK,  FEC_3_4, 0x07 },
-
-	{ SYS_DVBS2, PSK_8, FEC_2_3, 0x0d },
-	{ SYS_DVBS2, PSK_8, FEC_3_4, 0x0e },
+	/*delsys     mod    fec       val */
+	{ SYS_DVBS,  QPSK,  FEC_1_2,  0x2e },
+	{ SYS_DVBS,  QPSK,  FEC_2_3,  0x2f },
+	{ SYS_DVBS,  QPSK,  FEC_3_4,  0x30 },
+	{ SYS_DVBS,  QPSK,  FEC_5_6,  0x31 },
+	{ SYS_DVBS,  QPSK,  FEC_6_7,  0x32 },
+	{ SYS_DVBS,  QPSK,  FEC_7_8,  0x33 },
+
+	{ SYS_DVBS2, QPSK,  FEC_1_2,  0x04 },
+	{ SYS_DVBS2, QPSK,  FEC_3_5,  0x05 },
+	{ SYS_DVBS2, QPSK,  FEC_2_3,  0x06 },
+	{ SYS_DVBS2, QPSK,  FEC_3_4,  0x07 },
+	{ SYS_DVBS2, QPSK,  FEC_4_5,  0x08 },
+	{ SYS_DVBS2, QPSK,  FEC_5_6,  0x09 },
+	{ SYS_DVBS2, QPSK,  FEC_8_9,  0x0a },
+	{ SYS_DVBS2, QPSK,  FEC_9_10, 0x0b },
+
+	{ SYS_DVBS2, PSK_8, FEC_3_5,  0x0c },
+	{ SYS_DVBS2, PSK_8, FEC_2_3,  0x0d },
+	{ SYS_DVBS2, PSK_8, FEC_3_4,  0x0e },
+	{ SYS_DVBS2, PSK_8, FEC_5_6,  0x0f },
+	{ SYS_DVBS2, PSK_8, FEC_8_9,  0x10 },
+	{ SYS_DVBS2, PSK_8, FEC_9_10, 0x11 },
 };
 
 /* Set fec_val & fec_mask values from delsys, modulation & fec */

commit 4133601c31adcbcd3affc40e1035c25787cc5cd1
Author: Jemma Denson <jdenson@gmail.com>
Date:   Fri May 8 17:36:19 2015 -0300

    [media] cx24120: More tidying in cx24120_init
    
    Remove reg1 by refactoring for loops
    Change ret into an int as it's only used for return values now,
    and remove reset_result by using ret instead.
    
    Signed-off-by: Jemma Denson <jdenson@gmail.com>
    Signed-off-by: Patrick Boettcher <patrick.boettcher@posteo.de>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/cx24120.c b/drivers/media/dvb-frontends/cx24120.c
index 8f195afe4ecc..bc8d0ebb63b6 100644
--- a/drivers/media/dvb-frontends/cx24120.c
+++ b/drivers/media/dvb-frontends/cx24120.c
@@ -1181,10 +1181,8 @@ int cx24120_init(struct dvb_frontend *fe)
 	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
 	struct cx24120_state *state = fe->demodulator_priv;
 	struct cx24120_cmd cmd;
-	u8 ret, reg, reg1;
-	int reset_result;
-
-	int i;
+	u8 reg;
+	int ret, i;
 	unsigned char vers[4];
 
 	if (state->cold_init)
@@ -1211,15 +1209,15 @@ int cx24120_init(struct dvb_frontend *fe)
 	cx24120_writereg(state, 0xf3, 0x03);
 	cx24120_writereg(state, 0xf4, 0x44);
 
-	for (reg1 = 0xf0; reg1 < 0xf3; reg1++) {
-		cx24120_writereg(state, reg1, 0x04);
-		cx24120_writereg(state, reg1 - 10, 0x02);
+	for (i = 0; i < 3; i++) {
+		cx24120_writereg(state, 0xf0 + i, 0x04);
+		cx24120_writereg(state, 0xe6 + i, 0x02);
 	}
 
 	cx24120_writereg(state, 0xea, (reg | 0x01));
-	for (reg1 = 0xc5; reg1 < 0xcb; reg1 += 2) {
-		cx24120_writereg(state, reg1, 0x00);
-		cx24120_writereg(state, reg1 + 1, 0x00);
+	for (i = 0; i < 6; i += 2) {
+		cx24120_writereg(state, 0xc5 + i, 0x00);
+		cx24120_writereg(state, 0xc6 + i, 0x00);
 	}
 
 	cx24120_writereg(state, 0xe4, 0x03);
@@ -1266,15 +1264,15 @@ int cx24120_init(struct dvb_frontend *fe)
 	reg = cx24120_readreg(state, 0xe1);
 	if (reg == fw->data[fw->size - 1]) {
 		dev_dbg(&state->i2c->dev, "Firmware uploaded successfully\n");
-		reset_result = 0;
+		ret = 0;
 	} else {
 		err("Firmware upload failed. Last byte returned=0x%x\n", ret);
-		reset_result = -EREMOTEIO;
+		ret = -EREMOTEIO;
 	}
 	cx24120_writereg(state, 0xdc, 0x00);
 	release_firmware(fw);
-	if (reset_result != 0)
-		return reset_result;
+	if (ret != 0)
+		return ret;
 
 	/* Start tuner */
 	cmd.id = CMD_START_TUNER;

commit 1668797d176d384c5148bd903b534125eae8d377
Author: Jemma Denson <jdenson@gmail.com>
Date:   Fri May 8 17:26:34 2015 -0300

    [media] cx24120: Tidy cx24120_init
    
    Use reg instead of ret for all calls to readreg, remove ret_EA
    as it doesn't need to be a separate var anymore.
    
    Signed-off-by: Jemma Denson <jdenson@gmail.com>
    Signed-off-by: Patrick Boettcher <patrick.boettcher@posteo.de>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/cx24120.c b/drivers/media/dvb-frontends/cx24120.c
index 0db03f301756..8f195afe4ecc 100644
--- a/drivers/media/dvb-frontends/cx24120.c
+++ b/drivers/media/dvb-frontends/cx24120.c
@@ -1181,7 +1181,7 @@ int cx24120_init(struct dvb_frontend *fe)
 	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
 	struct cx24120_state *state = fe->demodulator_priv;
 	struct cx24120_cmd cmd;
-	u8 ret, ret_EA, reg1;
+	u8 ret, reg, reg1;
 	int reset_result;
 
 	int i;
@@ -1193,16 +1193,16 @@ int cx24120_init(struct dvb_frontend *fe)
 	/* ???? */
 	cx24120_writereg(state, 0xea, 0x00);
 	cx24120_test_rom(state);
-	ret = cx24120_readreg(state, 0xfb) & 0xfe;
-	cx24120_writereg(state, 0xfb, ret);
-	ret = cx24120_readreg(state, 0xfc) & 0xfe;
-	cx24120_writereg(state, 0xfc, ret);
+	reg = cx24120_readreg(state, 0xfb) & 0xfe;
+	cx24120_writereg(state, 0xfb, reg);
+	reg = cx24120_readreg(state, 0xfc) & 0xfe;
+	cx24120_writereg(state, 0xfc, reg);
 	cx24120_writereg(state, 0xc3, 0x04);
 	cx24120_writereg(state, 0xc4, 0x04);
 	cx24120_writereg(state, 0xce, 0x00);
 	cx24120_writereg(state, 0xcf, 0x00);
-	ret_EA = cx24120_readreg(state, 0xea) & 0xfe;
-	cx24120_writereg(state, 0xea, ret_EA);
+	reg = cx24120_readreg(state, 0xea) & 0xfe;
+	cx24120_writereg(state, 0xea, reg);
 	cx24120_writereg(state, 0xeb, 0x0c);
 	cx24120_writereg(state, 0xec, 0x06);
 	cx24120_writereg(state, 0xed, 0x05);
@@ -1216,7 +1216,7 @@ int cx24120_init(struct dvb_frontend *fe)
 		cx24120_writereg(state, reg1 - 10, 0x02);
 	}
 
-	cx24120_writereg(state, 0xea, (ret_EA | 0x01));
+	cx24120_writereg(state, 0xea, (reg | 0x01));
 	for (reg1 = 0xc5; reg1 < 0xcb; reg1 += 2) {
 		cx24120_writereg(state, reg1, 0x00);
 		cx24120_writereg(state, reg1 + 1, 0x00);
@@ -1244,8 +1244,8 @@ int cx24120_init(struct dvb_frontend *fe)
 		fw->data[fw->size - 1]);	/* fw last byte */
 
 	cx24120_test_rom(state);
-	ret = cx24120_readreg(state, 0xfb) & 0xfe;
-	cx24120_writereg(state, 0xfb, ret);
+	reg = cx24120_readreg(state, 0xfb) & 0xfe;
+	cx24120_writereg(state, 0xfb, reg);
 	cx24120_writereg(state, 0xe0, 0x76);
 	cx24120_writereg(state, 0xf7, 0x81);
 	cx24120_writereg(state, 0xf8, 0x00);
@@ -1253,18 +1253,18 @@ int cx24120_init(struct dvb_frontend *fe)
 	cx24120_writeregs(state, 0xfa, fw->data, (fw->size - 1), 0x00);
 	cx24120_writereg(state, 0xf7, 0xc0);
 	cx24120_writereg(state, 0xe0, 0x00);
-	ret = (fw->size - 2) & 0x00ff;
-	cx24120_writereg(state, 0xf8, ret);
-	ret = ((fw->size - 2) >> 8) & 0x00ff;
-	cx24120_writereg(state, 0xf9, ret);
+	reg = (fw->size - 2) & 0x00ff;
+	cx24120_writereg(state, 0xf8, reg);
+	reg = ((fw->size - 2) >> 8) & 0x00ff;
+	cx24120_writereg(state, 0xf9, reg);
 	cx24120_writereg(state, 0xf7, 0x00);
 	cx24120_writereg(state, 0xdc, 0x00);
 	cx24120_writereg(state, 0xdc, 0x07);
 	msleep(500);
 
 	/* Check final byte matches final byte of firmware */
-	ret = cx24120_readreg(state, 0xe1);
-	if (ret == fw->data[fw->size - 1]) {
+	reg = cx24120_readreg(state, 0xe1);
+	if (reg == fw->data[fw->size - 1]) {
 		dev_dbg(&state->i2c->dev, "Firmware uploaded successfully\n");
 		reset_result = 0;
 	} else {
@@ -1316,8 +1316,8 @@ int cx24120_init(struct dvb_frontend *fe)
 		return -EREMOTEIO;
 	}
 
-	ret = cx24120_readreg(state, 0xba);
-	if (ret > 3) {
+	reg = cx24120_readreg(state, 0xba);
+	if (reg > 3) {
 		dev_dbg(&state->i2c->dev, "Reset-readreg 0xba: %x\n", ret);
 		err("Error initialising tuner!\n");
 		return -EREMOTEIO;

commit 92443cdb2362557e879ddcea10cb65bafe47153f
Author: Jemma Denson <jdenson@gmail.com>
Date:   Fri May 8 16:57:56 2015 -0300

    [media] cx24120: Remove unneccesary assignments in cx24120_init
    
    Probably a remnant of this driver being reverse engineered,
    cx24120_init assigned ret on each call to writereg - they're not
    used for anything so remove them to clear up the codebase.
    
    Signed-off-by: Jemma Denson <jdenson@gmail.com>
    Signed-off-by: Patrick Boettcher <patrick.boettcher@posteo.de>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/cx24120.c b/drivers/media/dvb-frontends/cx24120.c
index dc5c69ce166b..0db03f301756 100644
--- a/drivers/media/dvb-frontends/cx24120.c
+++ b/drivers/media/dvb-frontends/cx24120.c
@@ -1191,39 +1191,39 @@ int cx24120_init(struct dvb_frontend *fe)
 		return 0;
 
 	/* ???? */
-	ret = cx24120_writereg(state, 0xea, 0x00);
-	ret = cx24120_test_rom(state);
+	cx24120_writereg(state, 0xea, 0x00);
+	cx24120_test_rom(state);
 	ret = cx24120_readreg(state, 0xfb) & 0xfe;
-	ret = cx24120_writereg(state, 0xfb, ret);
+	cx24120_writereg(state, 0xfb, ret);
 	ret = cx24120_readreg(state, 0xfc) & 0xfe;
-	ret = cx24120_writereg(state, 0xfc, ret);
-	ret = cx24120_writereg(state, 0xc3, 0x04);
-	ret = cx24120_writereg(state, 0xc4, 0x04);
-	ret = cx24120_writereg(state, 0xce, 0x00);
-	ret = cx24120_writereg(state, 0xcf, 0x00);
+	cx24120_writereg(state, 0xfc, ret);
+	cx24120_writereg(state, 0xc3, 0x04);
+	cx24120_writereg(state, 0xc4, 0x04);
+	cx24120_writereg(state, 0xce, 0x00);
+	cx24120_writereg(state, 0xcf, 0x00);
 	ret_EA = cx24120_readreg(state, 0xea) & 0xfe;
-	ret = cx24120_writereg(state, 0xea, ret_EA);
-	ret = cx24120_writereg(state, 0xeb, 0x0c);
-	ret = cx24120_writereg(state, 0xec, 0x06);
-	ret = cx24120_writereg(state, 0xed, 0x05);
-	ret = cx24120_writereg(state, 0xee, 0x03);
-	ret = cx24120_writereg(state, 0xef, 0x05);
-	ret = cx24120_writereg(state, 0xf3, 0x03);
-	ret = cx24120_writereg(state, 0xf4, 0x44);
+	cx24120_writereg(state, 0xea, ret_EA);
+	cx24120_writereg(state, 0xeb, 0x0c);
+	cx24120_writereg(state, 0xec, 0x06);
+	cx24120_writereg(state, 0xed, 0x05);
+	cx24120_writereg(state, 0xee, 0x03);
+	cx24120_writereg(state, 0xef, 0x05);
+	cx24120_writereg(state, 0xf3, 0x03);
+	cx24120_writereg(state, 0xf4, 0x44);
 
 	for (reg1 = 0xf0; reg1 < 0xf3; reg1++) {
 		cx24120_writereg(state, reg1, 0x04);
 		cx24120_writereg(state, reg1 - 10, 0x02);
 	}
 
-	ret = cx24120_writereg(state, 0xea, (ret_EA | 0x01));
+	cx24120_writereg(state, 0xea, (ret_EA | 0x01));
 	for (reg1 = 0xc5; reg1 < 0xcb; reg1 += 2) {
-		ret = cx24120_writereg(state, reg1, 0x00);
-		ret = cx24120_writereg(state, reg1 + 1, 0x00);
+		cx24120_writereg(state, reg1, 0x00);
+		cx24120_writereg(state, reg1 + 1, 0x00);
 	}
 
-	ret = cx24120_writereg(state, 0xe4, 0x03);
-	ret = cx24120_writereg(state, 0xeb, 0x0a);
+	cx24120_writereg(state, 0xe4, 0x03);
+	cx24120_writereg(state, 0xeb, 0x0a);
 
 	dev_dbg(&state->i2c->dev, "requesting firmware (%s) to download...\n",
 		CX24120_FIRMWARE);
@@ -1243,23 +1243,23 @@ int cx24120_init(struct dvb_frontend *fe)
 		fw->data[fw->size - 2],		/* fw before last byte */
 		fw->data[fw->size - 1]);	/* fw last byte */
 
-	ret = cx24120_test_rom(state);
+	cx24120_test_rom(state);
 	ret = cx24120_readreg(state, 0xfb) & 0xfe;
-	ret = cx24120_writereg(state, 0xfb, ret);
-	ret = cx24120_writereg(state, 0xe0, 0x76);
-	ret = cx24120_writereg(state, 0xf7, 0x81);
-	ret = cx24120_writereg(state, 0xf8, 0x00);
-	ret = cx24120_writereg(state, 0xf9, 0x00);
-	ret = cx24120_writeregs(state, 0xfa, fw->data, (fw->size - 1), 0x00);
-	ret = cx24120_writereg(state, 0xf7, 0xc0);
-	ret = cx24120_writereg(state, 0xe0, 0x00);
+	cx24120_writereg(state, 0xfb, ret);
+	cx24120_writereg(state, 0xe0, 0x76);
+	cx24120_writereg(state, 0xf7, 0x81);
+	cx24120_writereg(state, 0xf8, 0x00);
+	cx24120_writereg(state, 0xf9, 0x00);
+	cx24120_writeregs(state, 0xfa, fw->data, (fw->size - 1), 0x00);
+	cx24120_writereg(state, 0xf7, 0xc0);
+	cx24120_writereg(state, 0xe0, 0x00);
 	ret = (fw->size - 2) & 0x00ff;
-	ret = cx24120_writereg(state, 0xf8, ret);
+	cx24120_writereg(state, 0xf8, ret);
 	ret = ((fw->size - 2) >> 8) & 0x00ff;
-	ret = cx24120_writereg(state, 0xf9, ret);
-	ret = cx24120_writereg(state, 0xf7, 0x00);
-	ret = cx24120_writereg(state, 0xdc, 0x00);
-	ret = cx24120_writereg(state, 0xdc, 0x07);
+	cx24120_writereg(state, 0xf9, ret);
+	cx24120_writereg(state, 0xf7, 0x00);
+	cx24120_writereg(state, 0xdc, 0x00);
+	cx24120_writereg(state, 0xdc, 0x07);
 	msleep(500);
 
 	/* Check final byte matches final byte of firmware */
@@ -1271,7 +1271,7 @@ int cx24120_init(struct dvb_frontend *fe)
 		err("Firmware upload failed. Last byte returned=0x%x\n", ret);
 		reset_result = -EREMOTEIO;
 	}
-	ret = cx24120_writereg(state, 0xdc, 0x00);
+	cx24120_writereg(state, 0xdc, 0x00);
 	release_firmware(fw);
 	if (reset_result != 0)
 		return reset_result;
@@ -1326,7 +1326,7 @@ int cx24120_init(struct dvb_frontend *fe)
 	dev_dbg(&state->i2c->dev, "Tuner initialised correctly.\n");
 
 	/* Initialise mpeg outputs */
-	ret = cx24120_writereg(state, 0xeb, 0x0a);
+	cx24120_writereg(state, 0xeb, 0x0a);
 	if (cx24120_msg_mpeg_output_global_config(state, 0) ||
 	    cx24120_msg_mpeg_output_config(state, 0) ||
 	    cx24120_msg_mpeg_output_config(state, 1) ||

commit 2f3f07fbe28c245bc4a86c735664d57a6e3b197d
Author: Jemma Denson <jdenson@gmail.com>
Date:   Fri May 8 16:34:31 2015 -0300

    [media] cx24120: Tidy up calls to dev_dbg
    
    Remove __func__ from calls to dev_dbg as dynamic debug can add in
    the function name anyway.
    Remove debug call in dvbv3 read_signal_strength as userspace has
    this value anyway.
    Reword some strings to make them simpler / more obvious.
    
    Signed-off-by: Jemma Denson <jdenson@gmail.com>
    Signed-off-by: Patrick Boettcher <patrick.boettcher@posteo.de>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/cx24120.c b/drivers/media/dvb-frontends/cx24120.c
index 9009a4f9a1fc..dc5c69ce166b 100644
--- a/drivers/media/dvb-frontends/cx24120.c
+++ b/drivers/media/dvb-frontends/cx24120.c
@@ -179,8 +179,7 @@ static int cx24120_readreg(struct cx24120_state *state, u8 reg)
 		return ret;
 	}
 
-	dev_dbg(&state->i2c->dev, "%s: reg=0x%02x; data=0x%02x\n",
-		__func__, reg, buf);
+	dev_dbg(&state->i2c->dev, "reg=0x%02x; data=0x%02x\n", reg, buf);
 
 	return buf;
 }
@@ -204,8 +203,7 @@ static int cx24120_writereg(struct cx24120_state *state, u8 reg, u8 data)
 		return ret;
 	}
 
-	dev_dbg(&state->i2c->dev, "%s: reg=0x%02x; data=0x%02x\n",
-		__func__, reg, data);
+	dev_dbg(&state->i2c->dev, "reg=0x%02x; data=0x%02x\n", reg, data);
 
 	return 0;
 }
@@ -246,9 +244,8 @@ static int cx24120_writeregs(struct cx24120_state *state,
 			goto out;
 		}
 
-		dev_dbg(&state->i2c->dev,
-			"%s: reg=0x%02x; data=%*ph\n",
-			__func__, reg, msg.len - 1, msg.buf + 1);
+		dev_dbg(&state->i2c->dev, "reg=0x%02x; data=%*ph\n",
+			reg, msg.len - 1, msg.buf + 1);
 	}
 
 	ret = 0;
@@ -338,7 +335,7 @@ static int cx24120_read_ber(struct dvb_frontend *fe, u32 *ber)
 		(cx24120_readreg(state, CX24120_REG_BER_HL) << 16)	|
 		(cx24120_readreg(state, CX24120_REG_BER_LH) <<  8)	|
 		 cx24120_readreg(state, CX24120_REG_BER_LL);
-	dev_dbg(&state->i2c->dev, "%s: read BER index = %d\n", __func__, *ber);
+	dev_dbg(&state->i2c->dev, "read BER index = %d\n", *ber);
 
 	return 0;
 }
@@ -389,8 +386,7 @@ static int cx24120_message_send(struct cx24120_state *state,
 			return -EREMOTEIO;
 		}
 	}
-	dev_dbg(&state->i2c->dev, "%s: Successfully send message 0x%02x\n",
-		__func__, cmd->id);
+	dev_dbg(&state->i2c->dev, "sent message 0x%02x\n", cmd->id);
 
 	return 0;
 }
@@ -423,7 +419,6 @@ static int cx24120_message_sendrcv(struct cx24120_state *state,
 static int cx24120_read_signal_strength(struct dvb_frontend *fe,
 					u16 *signal_strength)
 {
-	struct cx24120_state *state = fe->demodulator_priv;
 	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
 
 	if (c->strength.stat[0].scale != FE_SCALE_RELATIVE)
@@ -431,9 +426,6 @@ static int cx24120_read_signal_strength(struct dvb_frontend *fe,
 	else
 		*signal_strength = c->strength.stat[0].uvalue;
 
-	dev_dbg(&state->i2c->dev, "%s: Signal strength from cache: 0x%x\n",
-		__func__, *signal_strength);
-
 	return 0;
 }
 
@@ -452,15 +444,14 @@ static int cx24120_msg_mpeg_output_global_config(struct cx24120_state *state,
 
 	ret = cx24120_message_send(state, &cmd);
 	if (ret != 0) {
-		dev_dbg(&state->i2c->dev,
-			"%s: Failed to set MPEG output to %s\n",
-			__func__, enable ? "enabled" : "disabled");
+		dev_dbg(&state->i2c->dev, "failed to %s MPEG output\n",
+			enable ? "enable" : "disable");
 		return ret;
 	}
 
 	state->mpeg_enabled = enable;
-	dev_dbg(&state->i2c->dev, "%s: MPEG output %s\n",
-		__func__, enable ? "enabled" : "disabled");
+	dev_dbg(&state->i2c->dev, "MPEG output %s\n",
+		enable ? "enabled" : "disabled");
 
 	return 0;
 }
@@ -490,6 +481,8 @@ static int cx24120_diseqc_send_burst(struct dvb_frontend *fe,
 	struct cx24120_state *state = fe->demodulator_priv;
 	struct cx24120_cmd cmd;
 
+	dev_dbg(&state->i2c->dev, "\n");
+
 	/*
 	 * Yes, cmd.len is set to zero. The old driver
 	 * didn't specify any len, but also had a
@@ -502,8 +495,6 @@ static int cx24120_diseqc_send_burst(struct dvb_frontend *fe,
 	cmd.arg[0] = 0x00;
 	cmd.arg[1] = (burst == SEC_MINI_B) ? 0x01 : 0x00;
 
-	dev_dbg(&state->i2c->dev, "%s: burst sent.\n", __func__);
-
 	return cx24120_message_send(state, &cmd);
 }
 
@@ -512,7 +503,7 @@ static int cx24120_set_tone(struct dvb_frontend *fe, fe_sec_tone_mode_t tone)
 	struct cx24120_state *state = fe->demodulator_priv;
 	struct cx24120_cmd cmd;
 
-	dev_dbg(&state->i2c->dev, "%s(%d)\n", __func__, tone);
+	dev_dbg(&state->i2c->dev, "(%d)\n", tone);
 
 	if ((tone != SEC_TONE_ON) && (tone != SEC_TONE_OFF)) {
 		err("Invalid tone=%d\n", tone);
@@ -535,7 +526,7 @@ static int cx24120_set_voltage(struct dvb_frontend *fe,
 	struct cx24120_state *state = fe->demodulator_priv;
 	struct cx24120_cmd cmd;
 
-	dev_dbg(&state->i2c->dev, "%s(%d)\n", __func__, voltage);
+	dev_dbg(&state->i2c->dev, "(%d)\n", voltage);
 
 	cmd.id = CMD_SETVOLTAGE;
 	cmd.len = 2;
@@ -552,7 +543,7 @@ static int cx24120_send_diseqc_msg(struct dvb_frontend *fe,
 	struct cx24120_cmd cmd;
 	int back_count;
 
-	dev_dbg(&state->i2c->dev, "%s()\n", __func__);
+	dev_dbg(&state->i2c->dev, "\n");
 
 	cmd.id = CMD_DISEQC_MSG1;
 	cmd.len = 11;
@@ -592,9 +583,7 @@ static int cx24120_send_diseqc_msg(struct dvb_frontend *fe,
 	back_count = 500;
 	do {
 		if (!(cx24120_readreg(state, 0x93) & 0x01)) {
-			dev_dbg(&state->i2c->dev,
-				"%s: diseqc sequence sent success\n",
-				__func__);
+			dev_dbg(&state->i2c->dev, "diseqc sequence sent\n");
 			return 0;
 		}
 		msleep(20);
@@ -613,7 +602,7 @@ static void cx24120_get_stats(struct cx24120_state *state)
 	int ret, cnr;
 	u16 sig;
 
-	dev_dbg(&state->i2c->dev, "%s()\n", __func__);
+	dev_dbg(&state->i2c->dev, "\n");
 
 	/* signal strength */
 	if (state->fe_status & FE_HAS_SIGNAL) {
@@ -632,8 +621,7 @@ static void cx24120_get_stats(struct cx24120_state *state)
 		sig = sig << 8;
 		sig |= cx24120_readreg(state, CX24120_REG_SIGSTR_L);
 		dev_dbg(&state->i2c->dev,
-			"%s: Signal strength from firmware= 0x%x\n",
-			__func__, sig);
+			"signal strength from firmware = 0x%x\n", sig);
 
 		/* cooked */
 		sig = -100 * sig + 94324;
@@ -648,8 +636,7 @@ static void cx24120_get_stats(struct cx24120_state *state)
 	if (state->fe_status & FE_HAS_VITERBI) {
 		cnr = cx24120_readreg(state, CX24120_REG_QUALITY_H) << 8;
 		cnr |= cx24120_readreg(state, CX24120_REG_QUALITY_L);
-		dev_dbg(&state->i2c->dev, "%s: read SNR index = %d\n",
-			__func__, cnr);
+		dev_dbg(&state->i2c->dev, "read SNR index = %d\n", cnr);
 
 		/* guessed - seems about right */
 		cnr = cnr * 100;
@@ -673,8 +660,7 @@ static int cx24120_read_status(struct dvb_frontend *fe, fe_status_t *status)
 
 	lock = cx24120_readreg(state, CX24120_REG_STATUS);
 
-	dev_dbg(&state->i2c->dev, "%s() status = 0x%02x\n",
-		__func__, lock);
+	dev_dbg(&state->i2c->dev, "status = 0x%02x\n", lock);
 
 	*status = 0;
 
@@ -759,12 +745,10 @@ static int cx24120_get_fec(struct dvb_frontend *fe)
 	int ret;
 	int fec;
 
-	dev_dbg(&state->i2c->dev, "%s()\n", __func__);
-
 	ret = cx24120_readreg(state, CX24120_REG_FECMODE);
 	fec = ret & 0x3f; /* Lower 6 bits */
 
-	dev_dbg(&state->i2c->dev, "%s: Get FEC: %d\n", __func__, fec);
+	dev_dbg(&state->i2c->dev, "raw fec = %d\n", fec);
 
 	for (idx = 0; idx < ARRAY_SIZE(modfec_lookup_table); idx++) {
 		if (modfec_lookup_table[idx].delsys != state->dcur.delsys)
@@ -776,8 +760,7 @@ static int cx24120_get_fec(struct dvb_frontend *fe)
 	}
 
 	if (idx >= ARRAY_SIZE(modfec_lookup_table)) {
-		dev_dbg(&state->i2c->dev, "%s: Couldn't find fec!\n",
-			__func__);
+		dev_dbg(&state->i2c->dev, "couldn't find fec!\n");
 		return -EINVAL;
 	}
 
@@ -786,9 +769,7 @@ static int cx24120_get_fec(struct dvb_frontend *fe)
 	c->fec_inner = modfec_lookup_table[idx].fec;
 	c->pilot = (ret & 0x80) ? PILOT_ON : PILOT_OFF;
 
-	dev_dbg(&state->i2c->dev,
-		"%s: mod(%d), fec(%d), pilot(%d)\n",
-		__func__,
+	dev_dbg(&state->i2c->dev, "mod(%d), fec(%d), pilot(%d)\n",
 		c->modulation, c->fec_inner, c->pilot);
 
 	return 0;
@@ -889,9 +870,7 @@ static void cx24120_set_clock_ratios(struct dvb_frontend *fe)
 		return;
 	/* in cmd[0]-[5] - result */
 
-	dev_dbg(&state->i2c->dev,
-		"%s: m=%d, n=%d; idx: %d m=%d, n=%d, rate=%d\n",
-		__func__,
+	dev_dbg(&state->i2c->dev, "m=%d, n=%d; idx: %d m=%d, n=%d, rate=%d\n",
 		cmd.arg[2] | (cmd.arg[1] << 8) | (cmd.arg[0] << 16),
 		cmd.arg[5] | (cmd.arg[4] << 8) | (cmd.arg[3] << 16),
 		idx,
@@ -920,7 +899,7 @@ static void cx24120_set_clock_ratios(struct dvb_frontend *fe)
 static int cx24120_set_inversion(struct cx24120_state *state,
 				 fe_spectral_inversion_t inversion)
 {
-	dev_dbg(&state->i2c->dev, "%s(%d)\n", __func__, inversion);
+	dev_dbg(&state->i2c->dev, "(%d)\n", inversion);
 
 	switch (inversion) {
 	case INVERSION_OFF:
@@ -975,7 +954,7 @@ static int cx24120_set_fec(struct cx24120_state *state, fe_modulation_t mod,
 {
 	int idx;
 
-	dev_dbg(&state->i2c->dev, "%s(0x%02x,0x%02x)\n", __func__, mod, fec);
+	dev_dbg(&state->i2c->dev, "(0x%02x,0x%02x)\n", mod, fec);
 
 	state->dnxt.fec = fec;
 
@@ -1010,7 +989,7 @@ static int cx24120_set_fec(struct cx24120_state *state, fe_modulation_t mod,
 /* Set pilot */
 static int cx24120_set_pilot(struct cx24120_state *state, fe_pilot_t pilot)
 {
-	dev_dbg(&state->i2c->dev, "%s(%d)\n", __func__, pilot);
+	dev_dbg(&state->i2c->dev, "(%d)\n", pilot);
 
 	/* Pilot only valid in DVBS2 */
 	if (state->dnxt.delsys != SYS_DVBS2) {
@@ -1036,8 +1015,7 @@ static int cx24120_set_pilot(struct cx24120_state *state, fe_pilot_t pilot)
 /* Set symbol rate */
 static int cx24120_set_symbolrate(struct cx24120_state *state, u32 rate)
 {
-	dev_dbg(&state->i2c->dev, "%s(%d)\n",
-		__func__, rate);
+	dev_dbg(&state->i2c->dev, "(%d)\n", rate);
 
 	state->dnxt.symbol_rate = rate;
 
@@ -1070,17 +1048,15 @@ static int cx24120_set_frontend(struct dvb_frontend *fe)
 
 	switch (c->delivery_system) {
 	case SYS_DVBS2:
-		dev_dbg(&state->i2c->dev, "%s() DVB-S2\n",
-			__func__);
+		dev_dbg(&state->i2c->dev, "DVB-S2\n");
 		break;
 	case SYS_DVBS:
-		dev_dbg(&state->i2c->dev, "%s() DVB-S\n",
-			__func__);
+		dev_dbg(&state->i2c->dev, "DVB-S\n");
 		break;
 	default:
 		dev_dbg(&state->i2c->dev,
-			"%s() Delivery system(%d) not supported\n",
-			__func__, c->delivery_system);
+			"delivery system(%d) not supported\n",
+			c->delivery_system);
 		ret = -EINVAL;
 		break;
 	}
@@ -1110,23 +1086,23 @@ static int cx24120_set_frontend(struct dvb_frontend *fe)
 	cx24120_clone_params(fe);
 
 	dev_dbg(&state->i2c->dev,
-		"%s: delsys      = %d\n", __func__, state->dcur.delsys);
+		"delsys      = %d\n", state->dcur.delsys);
 	dev_dbg(&state->i2c->dev,
-		"%s: modulation  = %d\n", __func__, state->dcur.modulation);
+		"modulation  = %d\n", state->dcur.modulation);
 	dev_dbg(&state->i2c->dev,
-		"%s: frequency   = %d\n", __func__, state->dcur.frequency);
+		"frequency   = %d\n", state->dcur.frequency);
 	dev_dbg(&state->i2c->dev,
-		"%s: pilot       = %d (val = 0x%02x)\n", __func__,
+		"pilot       = %d (val = 0x%02x)\n",
 		state->dcur.pilot, state->dcur.pilot_val);
 	dev_dbg(&state->i2c->dev,
-		"%s: symbol_rate = %d (clkdiv/ratediv = 0x%02x/0x%02x)\n",
-		 __func__, state->dcur.symbol_rate,
+		"symbol_rate = %d (clkdiv/ratediv = 0x%02x/0x%02x)\n",
+		 state->dcur.symbol_rate,
 		 state->dcur.clkdiv, state->dcur.ratediv);
 	dev_dbg(&state->i2c->dev,
-		"%s: FEC         = %d (mask/val = 0x%02x/0x%02x)\n", __func__,
+		"FEC         = %d (mask/val = 0x%02x/0x%02x)\n",
 		state->dcur.fec, state->dcur.fec_mask, state->dcur.fec_val);
 	dev_dbg(&state->i2c->dev,
-		"%s: Inversion   = %d (val = 0x%02x)\n", __func__,
+		"Inversion   = %d (val = 0x%02x)\n",
 		state->dcur.inversion, state->dcur.inversion_val);
 
 	/* Flag that clock needs to be set after tune */
@@ -1178,9 +1154,8 @@ static int cx24120_set_vco(struct cx24120_state *state)
 	vco = nxtal_khz * 10;
 	inv_vco = DIV_ROUND_CLOSEST_ULL(0x400000000ULL, vco);
 
-	dev_dbg(&state->i2c->dev,
-		"%s: xtal=%d, vco=%d, inv_vco=%lld\n",
-		__func__, xtal_khz, vco, inv_vco);
+	dev_dbg(&state->i2c->dev, "xtal=%d, vco=%d, inv_vco=%lld\n",
+		xtal_khz, vco, inv_vco);
 
 	cmd.id = CMD_VCO_SET;
 	cmd.len = 12;
@@ -1250,9 +1225,8 @@ int cx24120_init(struct dvb_frontend *fe)
 	ret = cx24120_writereg(state, 0xe4, 0x03);
 	ret = cx24120_writereg(state, 0xeb, 0x0a);
 
-	dev_dbg(&state->i2c->dev,
-		"%s: Requesting firmware (%s) to download...\n",
-		__func__, CX24120_FIRMWARE);
+	dev_dbg(&state->i2c->dev, "requesting firmware (%s) to download...\n",
+		CX24120_FIRMWARE);
 
 	ret = state->config->request_firmware(fe, &fw, CX24120_FIRMWARE);
 	if (ret) {
@@ -1262,8 +1236,7 @@ int cx24120_init(struct dvb_frontend *fe)
 	}
 
 	dev_dbg(&state->i2c->dev,
-		"%s: Firmware found, size %d bytes (%02x %02x .. %02x %02x)\n",
-		__func__,
+		"Firmware found, size %d bytes (%02x %02x .. %02x %02x)\n",
 		(int)fw->size,			/* firmware_size in bytes */
 		fw->data[0],			/* fw 1st byte */
 		fw->data[1],			/* fw 2d byte */
@@ -1292,9 +1265,7 @@ int cx24120_init(struct dvb_frontend *fe)
 	/* Check final byte matches final byte of firmware */
 	ret = cx24120_readreg(state, 0xe1);
 	if (ret == fw->data[fw->size - 1]) {
-		dev_dbg(&state->i2c->dev,
-			"%s: Firmware uploaded successfully\n",
-			__func__);
+		dev_dbg(&state->i2c->dev, "Firmware uploaded successfully\n");
 		reset_result = 0;
 	} else {
 		err("Firmware upload failed. Last byte returned=0x%x\n", ret);
@@ -1347,14 +1318,12 @@ int cx24120_init(struct dvb_frontend *fe)
 
 	ret = cx24120_readreg(state, 0xba);
 	if (ret > 3) {
-		dev_dbg(&state->i2c->dev, "%s: Reset-readreg 0xba: %x\n",
-			__func__, ret);
+		dev_dbg(&state->i2c->dev, "Reset-readreg 0xba: %x\n", ret);
 		err("Error initialising tuner!\n");
 		return -EREMOTEIO;
 	}
 
-	dev_dbg(&state->i2c->dev, "%s: Tuner initialised correctly.\n",
-		__func__);
+	dev_dbg(&state->i2c->dev, "Tuner initialised correctly.\n");
 
 	/* Initialise mpeg outputs */
 	ret = cx24120_writereg(state, 0xeb, 0x0a);
@@ -1406,7 +1375,7 @@ static int cx24120_tune(struct dvb_frontend *fe, bool re_tune,
 	struct cx24120_state *state = fe->demodulator_priv;
 	int ret;
 
-	dev_dbg(&state->i2c->dev, "%s(%d)\n", __func__, re_tune);
+	dev_dbg(&state->i2c->dev, "(%d)\n", re_tune);
 
 	/* TODO: Do we need to set delay? */
 
@@ -1435,7 +1404,7 @@ static int cx24120_get_frontend(struct dvb_frontend *fe)
 	struct cx24120_state *state = fe->demodulator_priv;
 	u8 freq1, freq2, freq3;
 
-	dev_dbg(&state->i2c->dev, "%s()", __func__);
+	dev_dbg(&state->i2c->dev, "\n");
 
 	/* don't return empty data if we're not tuned in */
 	if ((state->fe_status & FE_HAS_LOCK) == 0)
@@ -1446,8 +1415,7 @@ static int cx24120_get_frontend(struct dvb_frontend *fe)
 	freq2 = cx24120_readreg(state, CX24120_REG_FREQ2);
 	freq3 = cx24120_readreg(state, CX24120_REG_FREQ3);
 	c->frequency = (freq3 << 16) | (freq2 << 8) | freq1;
-	dev_dbg(&state->i2c->dev, "%s frequency = %d\n", __func__,
-		c->frequency);
+	dev_dbg(&state->i2c->dev, "frequency = %d\n", c->frequency);
 
 	/* Get modulation, fec, pilot */
 	cx24120_get_fec(fe);
@@ -1459,7 +1427,7 @@ static void cx24120_release(struct dvb_frontend *fe)
 {
 	struct cx24120_state *state = fe->demodulator_priv;
 
-	dev_dbg(&state->i2c->dev, "%s: Clear state structure\n", __func__);
+	dev_dbg(&state->i2c->dev, "Clear state structure\n");
 	kfree(state);
 }
 
@@ -1470,7 +1438,7 @@ static int cx24120_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)
 	*ucblocks = (cx24120_readreg(state, CX24120_REG_UCB_H) << 8) |
 		     cx24120_readreg(state, CX24120_REG_UCB_L);
 
-	dev_dbg(&state->i2c->dev, "%s: Blocks = %d\n", __func__, *ucblocks);
+	dev_dbg(&state->i2c->dev, "ucblocks = %d\n", *ucblocks);
 	return 0;
 }
 

commit 3b5eb504fe7efc0637f43f6a641ee6e163800f98
Author: Jemma Denson <jdenson@gmail.com>
Date:   Fri May 8 15:52:45 2015 -0300

    [media] cx24120: Move CNR to DVBv5 stats
    
    Better to report CNR via DVBv5 stats, as scale can be used.
    
    Signed-off-by: Jemma Denson <jdenson@gmail.com>
    Signed-off-by: Patrick Boettcher <patrick.boettcher@posteo.de>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/cx24120.c b/drivers/media/dvb-frontends/cx24120.c
index 2fa196a889d7..9009a4f9a1fc 100644
--- a/drivers/media/dvb-frontends/cx24120.c
+++ b/drivers/media/dvb-frontends/cx24120.c
@@ -320,11 +320,12 @@ static int cx24120_test_rom(struct cx24120_state *state)
 
 static int cx24120_read_snr(struct dvb_frontend *fe, u16 *snr)
 {
-	struct cx24120_state *state = fe->demodulator_priv;
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
 
-	*snr =  (cx24120_readreg(state, CX24120_REG_QUALITY_H) << 8) |
-		(cx24120_readreg(state, CX24120_REG_QUALITY_L));
-	dev_dbg(&state->i2c->dev, "%s: read SNR index = %d\n", __func__, *snr);
+	if (c->cnr.stat[0].scale != FE_SCALE_DECIBEL)
+		*snr = 0;
+	else
+		*snr = div_s64(c->cnr.stat[0].svalue, 100);
 
 	return 0;
 }
@@ -609,7 +610,7 @@ static void cx24120_get_stats(struct cx24120_state *state)
 	struct dvb_frontend *fe = &state->frontend;
 	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
 	struct cx24120_cmd cmd;
-	int ret;
+	int ret, cnr;
 	u16 sig;
 
 	dev_dbg(&state->i2c->dev, "%s()\n", __func__);
@@ -643,7 +644,21 @@ static void cx24120_get_stats(struct cx24120_state *state)
 		c->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
 	}
 
-	/* FIXME: add CNR */
+	/* CNR */
+	if (state->fe_status & FE_HAS_VITERBI) {
+		cnr = cx24120_readreg(state, CX24120_REG_QUALITY_H) << 8;
+		cnr |= cx24120_readreg(state, CX24120_REG_QUALITY_L);
+		dev_dbg(&state->i2c->dev, "%s: read SNR index = %d\n",
+			__func__, cnr);
+
+		/* guessed - seems about right */
+		cnr = cnr * 100;
+
+		c->cnr.stat[0].scale = FE_SCALE_DECIBEL;
+		c->cnr.stat[0].svalue = cnr;
+	} else {
+		c->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	}
 
 	/* FIXME: add UCB/BER */
 }
@@ -1377,6 +1392,8 @@ int cx24120_init(struct dvb_frontend *fe)
 	/* init stats here in order signal app which stats are supported */
 	c->strength.len = 1;
 	c->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	c->cnr.len = 1;
+	c->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
 
 	state->cold_init = 1;
 	return 0;

commit 7c95e25e38c03a64659343ddbb64fdbb5ff2e25a
Author: Jemma Denson <jdenson@gmail.com>
Date:   Tue May 5 18:33:27 2015 -0300

    [media] cx24120: Fix disecq_send_burst command
    
    Previous version of this driver had a memset before every call
    to cmd. This meant the default value of cmd.arg[1] was zero unless
    burst is set. Make sure it remains zero.
    Also fe_sec_mini_cmd_t is an enum, so test against it.
    
    Signed-off-by: Jemma Denson <jdenson@gmail.com>
    Signed-off-by: Patrick Boettcher <patrick.boettcher@posteo.de>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/cx24120.c b/drivers/media/dvb-frontends/cx24120.c
index 2876b8aae90a..2fa196a889d7 100644
--- a/drivers/media/dvb-frontends/cx24120.c
+++ b/drivers/media/dvb-frontends/cx24120.c
@@ -499,8 +499,7 @@ static int cx24120_diseqc_send_burst(struct dvb_frontend *fe,
 	cmd.id = CMD_DISEQC_BURST;
 	cmd.len = 0;
 	cmd.arg[0] = 0x00;
-	if (burst)
-		cmd.arg[1] = 0x01;
+	cmd.arg[1] = (burst == SEC_MINI_B) ? 0x01 : 0x00;
 
 	dev_dbg(&state->i2c->dev, "%s: burst sent.\n", __func__);
 

commit fbdbab72969b48367dcf5f0d42112b6f78fae794
Author: Jemma Denson <jdenson@gmail.com>
Date:   Tue May 5 18:31:10 2015 -0300

    [media] cx24120: More coding style fixes
    
    Signed-off-by: Jemma Denson <jdenson@gmail.com>
    Signed-off-by: Patrick Boettcher <patrick.boettcher@posteo.de>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/cx24120.c b/drivers/media/dvb-frontends/cx24120.c
index acdda036fe13..2876b8aae90a 100644
--- a/drivers/media/dvb-frontends/cx24120.c
+++ b/drivers/media/dvb-frontends/cx24120.c
@@ -160,7 +160,8 @@ static int cx24120_readreg(struct cx24120_state *state, u8 reg)
 	int ret;
 	u8 buf = 0;
 	struct i2c_msg msg[] = {
-		{	.addr = state->config->i2c_addr,
+		{
+			.addr = state->config->i2c_addr,
 			.flags = 0,
 			.len = 1,
 			.buf = &reg
@@ -488,7 +489,8 @@ static int cx24120_diseqc_send_burst(struct dvb_frontend *fe,
 	struct cx24120_state *state = fe->demodulator_priv;
 	struct cx24120_cmd cmd;
 
-	/* Yes, cmd.len is set to zero. The old driver
+	/*
+	 * Yes, cmd.len is set to zero. The old driver
 	 * didn't specify any len, but also had a
 	 * memset 0 before every use of the cmd struct
 	 * which would have set it to zero.
@@ -671,9 +673,11 @@ static int cx24120_read_status(struct dvb_frontend *fe, fe_status_t *status)
 	if (lock & CX24120_HAS_LOCK)
 		*status |= FE_HAS_LOCK;
 
-	/* TODO: is FE_HAS_SYNC in the right place?
+	/*
+	 * TODO: is FE_HAS_SYNC in the right place?
 	 * Other cx241xx drivers have this slightly
-	 * different */
+	 * different
+	 */
 
 	state->fe_status = *status;
 	cx24120_get_stats(state);
@@ -695,7 +699,8 @@ static int cx24120_read_status(struct dvb_frontend *fe, fe_status_t *status)
 	return 0;
 }
 
-/* FEC & modulation lookup table
+/*
+ * FEC & modulation lookup table
  * Used for decoding the REG_FECMODE register
  * once tuned in.
  */
@@ -775,14 +780,15 @@ static int cx24120_get_fec(struct dvb_frontend *fe)
 	return 0;
 }
 
-/* Clock ratios lookup table
+/*
+ * Clock ratios lookup table
  *
  * Values obtained from much larger table in old driver
  * which had numerous entries which would never match.
  *
  * There's probably some way of calculating these but I
  * can't determine the pattern
-*/
+ */
 static struct cx24120_clock_ratios_table {
 	fe_delivery_system_t delsys;
 	fe_pilot_t pilot;
@@ -935,7 +941,7 @@ static struct cx24120_modfec_table {
 	fe_code_rate_t fec;
 	u8 val;
 } modfec_table[] = {
-/*delsys	mod	fec	 val */
+	/*delsys	mod	fec	 val */
 	{ SYS_DVBS,  QPSK,  FEC_1_2, 0x2e },
 	{ SYS_DVBS,  QPSK,  FEC_2_3, 0x2f },
 	{ SYS_DVBS,  QPSK,  FEC_3_4, 0x30 },

commit b0cdf1a16f4058ac1c6c595455f276c5e3c54db3
Author: Jemma Denson <jdenson@gmail.com>
Date:   Tue May 5 18:09:45 2015 -0300

    [media] cx24120: Improve cooked signal strength value
    
    Algorithm copied from cx24117.c - it seems to work. Showing 95% on
    a signal I know to be somewhere around 74dBuV.
    
    [mchehab@osg.samsung.net: merged two patches, to avoid breaking compilation]
    Signed-off-by: Jemma Denson <jdenson@gmail.com>
    Signed-off-by: Patrick Boettcher <patrick.boettcher@posteo.de>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/cx24120.c b/drivers/media/dvb-frontends/cx24120.c
index eecfe2284c91..acdda036fe13 100644
--- a/drivers/media/dvb-frontends/cx24120.c
+++ b/drivers/media/dvb-frontends/cx24120.c
@@ -608,8 +608,8 @@ static void cx24120_get_stats(struct cx24120_state *state)
 	struct dvb_frontend *fe = &state->frontend;
 	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
 	struct cx24120_cmd cmd;
-	int ret, sigstr_h, sigstr_l;
-	u16 u16tmp;
+	int ret;
+	u16 sig;
 
 	dev_dbg(&state->i2c->dev, "%s()\n", __func__);
 
@@ -626,18 +626,18 @@ static void cx24120_get_stats(struct cx24120_state *state)
 		}
 
 		/* raw */
-		sigstr_h = (cx24120_readreg(state, CX24120_REG_SIGSTR_H) >> 6) << 8;
-		sigstr_l = cx24120_readreg(state, CX24120_REG_SIGSTR_L);
-		dev_dbg(&state->i2c->dev, "%s: Signal strength from firmware= 0x%x\n",
-			__func__, (sigstr_h | sigstr_l));
+		sig = cx24120_readreg(state, CX24120_REG_SIGSTR_H) >> 6;
+		sig = sig << 8;
+		sig |= cx24120_readreg(state, CX24120_REG_SIGSTR_L);
+		dev_dbg(&state->i2c->dev,
+			"%s: Signal strength from firmware= 0x%x\n",
+			__func__, sig);
 
 		/* cooked */
-		u16tmp = ((sigstr_h | sigstr_l)  << 5) & 0x0000ffff;
-		dev_dbg(&state->i2c->dev, "%s: Signal strength= 0x%x\n",
-			__func__, u16tmp);
+		sig = -100 * sig + 94324;
 
 		c->strength.stat[0].scale = FE_SCALE_RELATIVE;
-		c->strength.stat[0].uvalue = u16tmp;
+		c->strength.stat[0].uvalue = sig;
 	} else {
 		c->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
 	}

commit 34ce475d3272f3645561eb67048faf5537bae621
Author: Jemma Denson <jdenson@gmail.com>
Date:   Tue May 5 17:47:55 2015 -0300

    [media] cx24120: Return DVBv3 signal strength from cache
    
    This patch changes DVBv3 signal strength to read from the cache by
    moving the signal strength reading routine into get_stat, and
    reducing read_signal_strength to just returning the cached value.
    
    Signed-off-by: Jemma Denson <jdenson@gmail.com>
    Signed-off-by: Patrick Boettcher <patrick.boettcher@posteo.de>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/cx24120.c b/drivers/media/dvb-frontends/cx24120.c
index dfa2b6de481c..eecfe2284c91 100644
--- a/drivers/media/dvb-frontends/cx24120.c
+++ b/drivers/media/dvb-frontends/cx24120.c
@@ -422,28 +422,14 @@ static int cx24120_read_signal_strength(struct dvb_frontend *fe,
 					u16 *signal_strength)
 {
 	struct cx24120_state *state = fe->demodulator_priv;
-	struct cx24120_cmd cmd;
-	int ret, sigstr_h, sigstr_l;
-
-	cmd.id = CMD_READ_SNR;
-	cmd.len = 1;
-	cmd.arg[0] = 0x00;
-
-	ret = cx24120_message_send(state, &cmd);
-	if (ret != 0) {
-		err("error reading signal strength\n");
-		return -EREMOTEIO;
-	}
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
 
-	/* raw */
-	sigstr_h = (cx24120_readreg(state, CX24120_REG_SIGSTR_H) >> 6) << 8;
-	sigstr_l = cx24120_readreg(state, CX24120_REG_SIGSTR_L);
-	dev_dbg(&state->i2c->dev, "%s: Signal strength from firmware= 0x%x\n",
-		__func__, (sigstr_h | sigstr_l));
+	if (c->strength.stat[0].scale != FE_SCALE_RELATIVE)
+		*signal_strength = 0;
+	else
+		*signal_strength = c->strength.stat[0].uvalue;
 
-	/* cooked */
-	*signal_strength = ((sigstr_h | sigstr_l)  << 5) & 0x0000ffff;
-	dev_dbg(&state->i2c->dev, "%s: Signal strength= 0x%x\n",
+	dev_dbg(&state->i2c->dev, "%s: Signal strength from cache: 0x%x\n",
 		__func__, *signal_strength);
 
 	return 0;
@@ -621,16 +607,34 @@ static void cx24120_get_stats(struct cx24120_state *state)
 {
 	struct dvb_frontend *fe = &state->frontend;
 	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
-	int ret;
+	struct cx24120_cmd cmd;
+	int ret, sigstr_h, sigstr_l;
 	u16 u16tmp;
 
 	dev_dbg(&state->i2c->dev, "%s()\n", __func__);
 
 	/* signal strength */
 	if (state->fe_status & FE_HAS_SIGNAL) {
-		ret = cx24120_read_signal_strength(fe, &u16tmp);
-		if (ret != 0)
+		cmd.id = CMD_READ_SNR;
+		cmd.len = 1;
+		cmd.arg[0] = 0x00;
+
+		ret = cx24120_message_send(state, &cmd);
+		if (ret != 0) {
+			err("error reading signal strength\n");
 			return;
+		}
+
+		/* raw */
+		sigstr_h = (cx24120_readreg(state, CX24120_REG_SIGSTR_H) >> 6) << 8;
+		sigstr_l = cx24120_readreg(state, CX24120_REG_SIGSTR_L);
+		dev_dbg(&state->i2c->dev, "%s: Signal strength from firmware= 0x%x\n",
+			__func__, (sigstr_h | sigstr_l));
+
+		/* cooked */
+		u16tmp = ((sigstr_h | sigstr_l)  << 5) & 0x0000ffff;
+		dev_dbg(&state->i2c->dev, "%s: Signal strength= 0x%x\n",
+			__func__, u16tmp);
 
 		c->strength.stat[0].scale = FE_SCALE_RELATIVE;
 		c->strength.stat[0].uvalue = u16tmp;

commit 1462612cb3172068c3f4dca1778e5fb115191c70
Author: Jemma Denson <jdenson@gmail.com>
Date:   Tue May 5 17:18:11 2015 -0300

    [media] cx24120: Remove additional calls to read_status
    
    get_frontend was making a call to read_status, which is being
    called periodically anyway. Have read_status store fe_status in
    the state struct instead and use that within get_frontend.
    
    Signed-off-by: Jemma Denson <jdenson@gmail.com>
    Signed-off-by: Patrick Boettcher <patrick.boettcher@posteo.de>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/cx24120.c b/drivers/media/dvb-frontends/cx24120.c
index 57634c618d63..dfa2b6de481c 100644
--- a/drivers/media/dvb-frontends/cx24120.c
+++ b/drivers/media/dvb-frontends/cx24120.c
@@ -143,6 +143,8 @@ struct cx24120_state {
 	/* current and next tuning parameters */
 	struct cx24120_tuning dcur;
 	struct cx24120_tuning dnxt;
+
+	fe_status_t fe_status;
 };
 
 /* Command message to firmware */
@@ -615,7 +617,7 @@ static int cx24120_send_diseqc_msg(struct dvb_frontend *fe,
 	return -ETIMEDOUT;
 }
 
-static void cx24120_get_stats(struct cx24120_state *state, fe_status_t status)
+static void cx24120_get_stats(struct cx24120_state *state)
 {
 	struct dvb_frontend *fe = &state->frontend;
 	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
@@ -625,7 +627,7 @@ static void cx24120_get_stats(struct cx24120_state *state, fe_status_t status)
 	dev_dbg(&state->i2c->dev, "%s()\n", __func__);
 
 	/* signal strength */
-	if (status & FE_HAS_SIGNAL) {
+	if (state->fe_status & FE_HAS_SIGNAL) {
 		ret = cx24120_read_signal_strength(fe, &u16tmp);
 		if (ret != 0)
 			return;
@@ -669,7 +671,8 @@ static int cx24120_read_status(struct dvb_frontend *fe, fe_status_t *status)
 	 * Other cx241xx drivers have this slightly
 	 * different */
 
-	cx24120_get_stats(state, *status);
+	state->fe_status = *status;
+	cx24120_get_stats(state);
 
 	/* Set the clock once tuned in */
 	if (state->need_clock_set && *status & FE_HAS_LOCK) {
@@ -1405,13 +1408,11 @@ static int cx24120_get_frontend(struct dvb_frontend *fe)
 	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
 	struct cx24120_state *state = fe->demodulator_priv;
 	u8 freq1, freq2, freq3;
-	fe_status_t status;
 
 	dev_dbg(&state->i2c->dev, "%s()", __func__);
 
 	/* don't return empty data if we're not tuned in */
-	cx24120_read_status(fe, &status);
-	if ((status & FE_HAS_LOCK) == 0)
+	if ((state->fe_status & FE_HAS_LOCK) == 0)
 		return 0;
 
 	/* Get frequency */

commit d3cf06bbe3088e0b6ede1cc0a91ff9b60d837be9
Author: Jemma Denson <jdenson@gmail.com>
Date:   Tue May 5 17:10:13 2015 -0300

    [media] cx24120: Enable DVBv5 signal strength stats
    
    Previous patch added in collection, this patch enables them by
    signalling they are available.
    
    Signed-off-by: Jemma Denson <jdenson@gmail.com>
    Signed-off-by: Patrick Boettcher <patrick.boettcher@posteo.de>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/cx24120.c b/drivers/media/dvb-frontends/cx24120.c
index ff16611b5eb4..57634c618d63 100644
--- a/drivers/media/dvb-frontends/cx24120.c
+++ b/drivers/media/dvb-frontends/cx24120.c
@@ -1176,6 +1176,7 @@ static int cx24120_set_vco(struct cx24120_state *state)
 int cx24120_init(struct dvb_frontend *fe)
 {
 	const struct firmware *fw;
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
 	struct cx24120_state *state = fe->demodulator_priv;
 	struct cx24120_cmd cmd;
 	u8 ret, ret_EA, reg1;
@@ -1361,6 +1362,10 @@ int cx24120_init(struct dvb_frontend *fe)
 	}
 	info("FW version %i.%i.%i.%i\n", vers[0], vers[1], vers[2], vers[3]);
 
+	/* init stats here in order signal app which stats are supported */
+	c->strength.len = 1;
+	c->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+
 	state->cold_init = 1;
 	return 0;
 }

commit 9fc18f18a568a944e93de6f6c2148a688623429b
Author: Jemma Denson <jdenson@gmail.com>
Date:   Tue May 5 16:59:27 2015 -0300

    [media] cx24120: Add DVBv5 signal strength stats
    
    Add new get_stats function, called from read_status, for
    collecting DVBv5 stats into the frontend cache. Only signal
    strength for now, can add others later.
    Not currently marked as available, future patch will enable.
    
    Signed-off-by: Jemma Denson <jdenson@gmail.com>
    Signed-off-by: Patrick Boettcher <patrick.boettcher@posteo.de>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/cx24120.c b/drivers/media/dvb-frontends/cx24120.c
index 8238f80ea98e..ff16611b5eb4 100644
--- a/drivers/media/dvb-frontends/cx24120.c
+++ b/drivers/media/dvb-frontends/cx24120.c
@@ -615,6 +615,32 @@ static int cx24120_send_diseqc_msg(struct dvb_frontend *fe,
 	return -ETIMEDOUT;
 }
 
+static void cx24120_get_stats(struct cx24120_state *state, fe_status_t status)
+{
+	struct dvb_frontend *fe = &state->frontend;
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	int ret;
+	u16 u16tmp;
+
+	dev_dbg(&state->i2c->dev, "%s()\n", __func__);
+
+	/* signal strength */
+	if (status & FE_HAS_SIGNAL) {
+		ret = cx24120_read_signal_strength(fe, &u16tmp);
+		if (ret != 0)
+			return;
+
+		c->strength.stat[0].scale = FE_SCALE_RELATIVE;
+		c->strength.stat[0].uvalue = u16tmp;
+	} else {
+		c->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	}
+
+	/* FIXME: add CNR */
+
+	/* FIXME: add UCB/BER */
+}
+
 static void cx24120_set_clock_ratios(struct dvb_frontend *fe);
 
 /* Read current tuning status */
@@ -643,6 +669,8 @@ static int cx24120_read_status(struct dvb_frontend *fe, fe_status_t *status)
 	 * Other cx241xx drivers have this slightly
 	 * different */
 
+	cx24120_get_stats(state, *status);
+
 	/* Set the clock once tuned in */
 	if (state->need_clock_set && *status & FE_HAS_LOCK) {
 		/* Set clock ratios */

commit c84251bb122d6abcb0178f2c922f9ef51740e7ad
Author: Jemma Denson <jdenson@gmail.com>
Date:   Sun May 3 08:55:15 2015 -0300

    [media] cx24120: Rework vco function to remove xxyyzz variable
    
    Change calculate_vco function to send_vco to tidy up cx24120_init
    function.
    xxyyzz variable is remnants of a manual div & remainder codepath
    to perform a u64 rounded div; replace with kernel macro
    DIV_ROUND_CLOSEST_ULL
    Hex values provided to the message are mainly variables calculated
    within this function, replace with these to remove hardcoding.
    
    Signed-off-by: Jemma Denson <jdenson@gmail.com>
    Signed-off-by: Patrick Boettcher <patrick.boettcher@posteo.de>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/cx24120.c b/drivers/media/dvb-frontends/cx24120.c
index 74ce7a75a961..8238f80ea98e 100644
--- a/drivers/media/dvb-frontends/cx24120.c
+++ b/drivers/media/dvb-frontends/cx24120.c
@@ -1111,26 +1111,38 @@ static int cx24120_set_frontend(struct dvb_frontend *fe)
 	return 0;
 }
 
-/* Calculate vco from config */
-static u64 cx24120_calculate_vco(struct cx24120_state *state)
+/* Set vco from config */
+static int cx24120_set_vco(struct cx24120_state *state)
 {
-	u32 vco;
-	u64 inv_vco, res, xxyyzz;
+	struct cx24120_cmd cmd;
+	u32 nxtal_khz, vco;
+	u64 inv_vco;
 	u32 xtal_khz = state->config->xtal_khz;
 
-	xxyyzz = 0x400000000ULL;
-	vco = xtal_khz * 10 * 4;
-	inv_vco = xxyyzz / vco;
-	res = xxyyzz % vco;
-
-	if (inv_vco > xtal_khz * 10 * 2)
-		++inv_vco;
+	nxtal_khz = xtal_khz * 4;
+	vco = nxtal_khz * 10;
+	inv_vco = DIV_ROUND_CLOSEST_ULL(0x400000000ULL, vco);
 
 	dev_dbg(&state->i2c->dev,
-		"%s: xtal=%d, vco=%d, inv_vco=%lld, res=%lld\n",
-		__func__, xtal_khz, vco, inv_vco, res);
+		"%s: xtal=%d, vco=%d, inv_vco=%lld\n",
+		__func__, xtal_khz, vco, inv_vco);
 
-	return inv_vco;
+	cmd.id = CMD_VCO_SET;
+	cmd.len = 12;
+	cmd.arg[0] = (vco >> 16) & 0xff;
+	cmd.arg[1] = (vco >> 8) & 0xff;
+	cmd.arg[2] = vco & 0xff;
+	cmd.arg[3] = (inv_vco >> 8) & 0xff;
+	cmd.arg[4] = (inv_vco) & 0xff;
+	cmd.arg[5] = 0x03;
+	cmd.arg[6] = (nxtal_khz >> 8) & 0xff;
+	cmd.arg[7] = nxtal_khz & 0xff;
+	cmd.arg[8] = 0x06;
+	cmd.arg[9] = 0x03;
+	cmd.arg[10] = (xtal_khz >> 16) & 0xff;
+	cmd.arg[11] = xtal_khz & 0xff;
+
+	return cx24120_message_send(state, &cmd);
 }
 
 int cx24120_init(struct dvb_frontend *fe)
@@ -1139,7 +1151,6 @@ int cx24120_init(struct dvb_frontend *fe)
 	struct cx24120_state *state = fe->demodulator_priv;
 	struct cx24120_cmd cmd;
 	u8 ret, ret_EA, reg1;
-	u64 inv_vco;
 	int reset_result;
 
 	int i;
@@ -1251,26 +1262,10 @@ int cx24120_init(struct dvb_frontend *fe)
 	}
 
 	/* Set VCO */
-	inv_vco = cx24120_calculate_vco(state);
-
-	cmd.id = CMD_VCO_SET;
-	cmd.len = 12;
-	cmd.arg[0] = 0x06;
-	cmd.arg[1] = 0x2b;
-	cmd.arg[2] = 0xd8;
-	cmd.arg[3] = (inv_vco >> 8) & 0xff;
-	cmd.arg[4] = (inv_vco) & 0xff;
-	cmd.arg[5] = 0x03;
-	cmd.arg[6] = 0x9d;
-	cmd.arg[7] = 0xfc;
-	cmd.arg[8] = 0x06;
-	cmd.arg[9] = 0x03;
-	cmd.arg[10] = 0x27;
-	cmd.arg[11] = 0x7f;
-
-	if (cx24120_message_send(state, &cmd)) {
+	ret = cx24120_set_vco(state);
+	if (ret != 0) {
 		err("Error set VCO! :(\n");
-		return -EREMOTEIO;
+		return ret;
 	}
 
 	/* set bandwidth */

commit 6ce412292a2ae15eea55c70f43449a9857404c00
Author: Jemma Denson <jdenson@gmail.com>
Date:   Fri May 1 16:20:16 2015 -0300

    [media] cx24120: Fix hexdump length in writeregs
    
    msg.len has been ++'d so msg.len is one too many.
    
    Signed-off-by: Jemma Denson <jdenson@gmail.com>
    Signed-off-by: Patrick Boettcher <patrick.boettcher@posteo.de>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/cx24120.c b/drivers/media/dvb-frontends/cx24120.c
index 095af2e6f59f..74ce7a75a961 100644
--- a/drivers/media/dvb-frontends/cx24120.c
+++ b/drivers/media/dvb-frontends/cx24120.c
@@ -245,7 +245,7 @@ static int cx24120_writeregs(struct cx24120_state *state,
 
 		dev_dbg(&state->i2c->dev,
 			"%s: reg=0x%02x; data=%*ph\n",
-			__func__, reg, msg.len, msg.buf + 1);
+			__func__, reg, msg.len - 1, msg.buf + 1);
 	}
 
 	ret = 0;

commit 270e70713b3a52fcd0a2f39f14b78b109ccfb944
Author: Jemma Denson <jdenson@gmail.com>
Date:   Thu Apr 30 17:05:14 2015 -0300

    [media] cx24120: Add missing command to cx24120_check_cmd
    
    This patch adds in a missing command to cx24120_check_cmd. This part
    of the old reverse engineered driver was quite hard to follow - it's
    presumed the compiler did some neat optimisation that wasn't easy to
    decode. This command was checked for in that version but not copied
    across to the new switch statement.
    
    For reference, old reverse engineered code:
    xxzz = cmd->id - 0x11;                  // look for specific message id
    if ( xxzz <= 0x13 ) {
            msg_cmd_mask = 1 << xxzz;
            //0x0F8021 // if cmd_id 17 or 22 or 33-36, 42, 47, 57-61 etc. disable mpeg output
            if ( msg_cmd_mask & 0x0F8021 ) {        // 000011111000000000100001b
                    cx24120_msg_mpeg_output_global_config(state, 0);
                    msleep(100);
                    state->dvb_s2_mode &=  0xFD;    // reset mpeg out enable flag
            }
    }
    
    Signed-off-by: Jemma Denson <jdenson@gmail.com>
    Signed-off-by: Patrick Boettcher <patrick.boettcher@posteo.de>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/cx24120.c b/drivers/media/dvb-frontends/cx24120.c
index 554601512ee4..095af2e6f59f 100644
--- a/drivers/media/dvb-frontends/cx24120.c
+++ b/drivers/media/dvb-frontends/cx24120.c
@@ -352,6 +352,7 @@ static void cx24120_check_cmd(struct cx24120_state *state, u8 id)
 	case CMD_DISEQC_MSG2:
 	case CMD_SETVOLTAGE:
 	case CMD_SETTONE:
+	case CMD_DISEQC_BURST:
 		cx24120_msg_mpeg_output_global_config(state, 0);
 		/* Old driver would do a msleep(100) here */
 	default:

commit 6138dc2f5f4f1eb02ac05a002de267d4e130c0cd
Author: Jemma Denson <jdenson@gmail.com>
Date:   Thu Apr 30 16:37:42 2015 -0300

    [media] cx24120: Move clock set to read_status
    
    This patch removes the requirement of waiting for tune in
    set_frontend by moving the clock set call into read_status
    
    Signed-off-by: Jemma Denson <jdenson@gmail.com>
    Signed-off-by: Patrick Boettcher <patrick.boettcher@posteo.de>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/cx24120.c b/drivers/media/dvb-frontends/cx24120.c
index 441a963e7acf..554601512ee4 100644
--- a/drivers/media/dvb-frontends/cx24120.c
+++ b/drivers/media/dvb-frontends/cx24120.c
@@ -138,6 +138,7 @@ struct cx24120_state {
 
 	u8 cold_init;
 	u8 mpeg_enabled;
+	u8 need_clock_set;
 
 	/* current and next tuning parameters */
 	struct cx24120_tuning dcur;
@@ -613,6 +614,8 @@ static int cx24120_send_diseqc_msg(struct dvb_frontend *fe,
 	return -ETIMEDOUT;
 }
 
+static void cx24120_set_clock_ratios(struct dvb_frontend *fe);
+
 /* Read current tuning status */
 static int cx24120_read_status(struct dvb_frontend *fe, fe_status_t *status)
 {
@@ -639,6 +642,20 @@ static int cx24120_read_status(struct dvb_frontend *fe, fe_status_t *status)
 	 * Other cx241xx drivers have this slightly
 	 * different */
 
+	/* Set the clock once tuned in */
+	if (state->need_clock_set && *status & FE_HAS_LOCK) {
+		/* Set clock ratios */
+		cx24120_set_clock_ratios(fe);
+
+		/* Old driver would do a msleep(200) here */
+
+		/* Renable mpeg output */
+		if (!state->mpeg_enabled)
+			cx24120_msg_mpeg_output_global_config(state, 1);
+
+		state->need_clock_set = 0;
+	}
+
 	return 0;
 }
 
@@ -988,32 +1005,12 @@ static void cx24120_clone_params(struct dvb_frontend *fe)
 	state->dcur = state->dnxt;
 }
 
-/* Table of time to tune for different symrates */
-static struct cx24120_symrate_delay {
-	fe_delivery_system_t delsys;
-	u32 symrate;		/* Check for >= this symrate */
-	u32 delay;		/* Timeout in ms */
-} symrates_delay_table[] = {
-	{ SYS_DVBS,  10000000,   400 },
-	{ SYS_DVBS,   8000000,  2000 },
-	{ SYS_DVBS,   6000000,  5000 },
-	{ SYS_DVBS,   3000000, 10000 },
-	{ SYS_DVBS,         0, 15000 },
-	{ SYS_DVBS2, 10000000,   600 }, /* DVBS2 needs a little longer */
-	{ SYS_DVBS2,  8000000,  2000 }, /* (so these might need bumping too) */
-	{ SYS_DVBS2,  6000000,  5000 },
-	{ SYS_DVBS2,  3000000, 10000 },
-	{ SYS_DVBS2,        0, 15000 },
-};
-
 static int cx24120_set_frontend(struct dvb_frontend *fe)
 {
 	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
 	struct cx24120_state *state = fe->demodulator_priv;
 	struct cx24120_cmd cmd;
 	int ret;
-	int delay_cnt, sd_idx = 0;
-	fe_status_t status;
 
 	switch (c->delivery_system) {
 	case SYS_DVBS2:
@@ -1076,6 +1073,9 @@ static int cx24120_set_frontend(struct dvb_frontend *fe)
 		"%s: Inversion   = %d (val = 0x%02x)\n", __func__,
 		state->dcur.inversion, state->dcur.inversion_val);
 
+	/* Flag that clock needs to be set after tune */
+	state->need_clock_set = 1;
+
 	/* Tune in */
 	cmd.id = CMD_TUNEREQUEST;
 	cmd.len = 15;
@@ -1107,49 +1107,6 @@ static int cx24120_set_frontend(struct dvb_frontend *fe)
 	ret |= state->dcur.ratediv;
 	ret = cx24120_writereg(state, CX24120_REG_RATEDIV, ret);
 
-	/* Default time to tune */
-	delay_cnt = 500;
-
-	/* Establish time to tune from symrates_delay_table */
-	for (sd_idx = 0; sd_idx < ARRAY_SIZE(symrates_delay_table); sd_idx++) {
-		if (state->dcur.delsys != symrates_delay_table[sd_idx].delsys)
-			continue;
-		if (c->symbol_rate < symrates_delay_table[sd_idx].symrate)
-			continue;
-
-		/* found */
-		delay_cnt = symrates_delay_table[sd_idx].delay;
-		dev_dbg(&state->i2c->dev, "%s: Found symrate delay = %d\n",
-			__func__, delay_cnt);
-		break;
-	}
-
-	/* Wait for tuning */
-	while (delay_cnt >= 0) {
-		cx24120_read_status(fe, &status);
-		if (status & FE_HAS_LOCK)
-			goto tuned;
-		msleep(20);
-		delay_cnt -= 20;
-	}
-
-	/* Fail to tune */
-	dev_dbg(&state->i2c->dev, "%s: Tuning failed\n", __func__);
-
-	return -EINVAL;
-
-tuned:
-	dev_dbg(&state->i2c->dev, "%s: Tuning successful\n", __func__);
-
-	/* Set clock ratios */
-	cx24120_set_clock_ratios(fe);
-
-	/* Old driver would do a msleep(200) here */
-
-	/* Renable mpeg output */
-	if (!state->mpeg_enabled)
-		cx24120_msg_mpeg_output_global_config(state, 1);
-
 	return 0;
 }
 
@@ -1419,11 +1376,13 @@ static int cx24120_get_frontend(struct dvb_frontend *fe)
 	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
 	struct cx24120_state *state = fe->demodulator_priv;
 	u8 freq1, freq2, freq3;
+	fe_status_t status;
 
 	dev_dbg(&state->i2c->dev, "%s()", __func__);
 
 	/* don't return empty data if we're not tuned in */
-	if (state->mpeg_enabled)
+	cx24120_read_status(fe, &status);
+	if ((status & FE_HAS_LOCK) == 0)
 		return 0;
 
 	/* Get frequency */

commit 1ff2e8ed28e96f49b0f98b9a86e755ddd1a1078b
Author: Patrick Boettcher <patrick.boettcher@posteo.de>
Date:   Tue Apr 28 13:39:20 2015 -0300

    [media] cx24120: fix strict checkpatch-errors
    
    This patches fixes all checkpatch-errors.
    Even the ones created --strict.
    
    Signed-off-by: Patrick Boettcher <patrick.boettcher@posteo.de>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/cx24120.c b/drivers/media/dvb-frontends/cx24120.c
index e09cab62b2c6..441a963e7acf 100644
--- a/drivers/media/dvb-frontends/cx24120.c
+++ b/drivers/media/dvb-frontends/cx24120.c
@@ -65,7 +65,6 @@
 
 #define CX24120_REG_REVISION	0xff		/* Chip revision (ro) */
 
-
 /* Command messages */
 enum command_message_id {
 	CMD_VCO_SET		= 0x10,		/* cmd.len = 12; */
@@ -131,7 +130,6 @@ struct cx24120_tuning {
 	u8 pilot_val;
 };
 
-
 /* Private state */
 struct cx24120_state {
 	struct i2c_adapter *i2c;
@@ -146,7 +144,6 @@ struct cx24120_state {
 	struct cx24120_tuning dnxt;
 };
 
-
 /* Command message to firmware */
 struct cx24120_cmd {
 	u8 id;
@@ -154,7 +151,6 @@ struct cx24120_cmd {
 	u8 arg[CX24120_MAX_CMD_LEN];
 };
 
-
 /* Read single register */
 static int cx24120_readreg(struct cx24120_state *state, u8 reg)
 {
@@ -185,7 +181,6 @@ static int cx24120_readreg(struct cx24120_state *state, u8 reg)
 	return buf;
 }
 
-
 /* Write single register */
 static int cx24120_writereg(struct cx24120_state *state, u8 reg, u8 data)
 {
@@ -201,7 +196,7 @@ static int cx24120_writereg(struct cx24120_state *state, u8 reg, u8 data)
 	ret = i2c_transfer(state->i2c, &msg, 1);
 	if (ret != 1) {
 		err("Write error: i2c_write error(err == %i, 0x%02x: 0x%02x)\n",
-				 ret, reg, data);
+		    ret, reg, data);
 		return ret;
 	}
 
@@ -211,10 +206,9 @@ static int cx24120_writereg(struct cx24120_state *state, u8 reg, u8 data)
 	return 0;
 }
 
-
 /* Write multiple registers in chunks of i2c_wr_max-sized buffers */
-static int cx24120_writeregN(struct cx24120_state *state,
-			u8 reg, const u8 *values, u16 len, u8 incr)
+static int cx24120_writeregs(struct cx24120_state *state,
+			     u8 reg, const u8 *values, u16 len, u8 incr)
 {
 	int ret;
 	u16 max = state->config->i2c_wr_max > 0 ?
@@ -227,7 +221,7 @@ static int cx24120_writeregN(struct cx24120_state *state,
 	};
 
 	msg.buf = kmalloc(max + 1, GFP_KERNEL);
-	if (msg.buf == NULL)
+	if (!msg.buf)
 		return -ENOMEM;
 
 	while (len) {
@@ -250,7 +244,7 @@ static int cx24120_writeregN(struct cx24120_state *state,
 
 		dev_dbg(&state->i2c->dev,
 			"%s: reg=0x%02x; data=%*ph\n",
-			__func__, reg, msg.len, msg.buf+1);
+			__func__, reg, msg.len, msg.buf + 1);
 	}
 
 	ret = 0;
@@ -260,18 +254,17 @@ static int cx24120_writeregN(struct cx24120_state *state,
 	return ret;
 }
 
-
 static struct dvb_frontend_ops cx24120_ops;
 
 struct dvb_frontend *cx24120_attach(const struct cx24120_config *config,
-			struct i2c_adapter *i2c)
+				    struct i2c_adapter *i2c)
 {
-	struct cx24120_state *state = NULL;
+	struct cx24120_state *state;
 	int demod_rev;
 
 	info("Conexant cx24120/cx24118 - DVBS/S2 Satellite demod/tuner\n");
-	state = kzalloc(sizeof(struct cx24120_state), GFP_KERNEL);
-	if (state == NULL) {
+	state = kzalloc(sizeof(*state), GFP_KERNEL);
+	if (!state) {
 		err("Unable to allocate memory for cx24120_state\n");
 		goto error;
 	}
@@ -290,8 +283,7 @@ struct dvb_frontend *cx24120_attach(const struct cx24120_config *config,
 		info("Demod cx24120 rev. 0x05 detected.\n");
 		break;
 	default:
-		err("Unsupported demod revision: 0x%x detected.\n",
-			demod_rev);
+		err("Unsupported demod revision: 0x%x detected.\n", demod_rev);
 		goto error;
 	}
 
@@ -322,36 +314,32 @@ static int cx24120_test_rom(struct cx24120_state *state)
 	return err;
 }
 
-
 static int cx24120_read_snr(struct dvb_frontend *fe, u16 *snr)
 {
 	struct cx24120_state *state = fe->demodulator_priv;
 
-	*snr =  (cx24120_readreg(state, CX24120_REG_QUALITY_H)<<8) |
+	*snr =  (cx24120_readreg(state, CX24120_REG_QUALITY_H) << 8) |
 		(cx24120_readreg(state, CX24120_REG_QUALITY_L));
-	dev_dbg(&state->i2c->dev, "%s: read SNR index = %d\n",
-			__func__, *snr);
+	dev_dbg(&state->i2c->dev, "%s: read SNR index = %d\n", __func__, *snr);
 
 	return 0;
 }
 
-
 static int cx24120_read_ber(struct dvb_frontend *fe, u32 *ber)
 {
 	struct cx24120_state *state = fe->demodulator_priv;
 
 	*ber =  (cx24120_readreg(state, CX24120_REG_BER_HH) << 24)	|
 		(cx24120_readreg(state, CX24120_REG_BER_HL) << 16)	|
-		(cx24120_readreg(state, CX24120_REG_BER_LH)  << 8)	|
+		(cx24120_readreg(state, CX24120_REG_BER_LH) <<  8)	|
 		 cx24120_readreg(state, CX24120_REG_BER_LL);
-	dev_dbg(&state->i2c->dev, "%s: read BER index = %d\n",
-			__func__, *ber);
+	dev_dbg(&state->i2c->dev, "%s: read BER index = %d\n", __func__, *ber);
 
 	return 0;
 }
 
 static int cx24120_msg_mpeg_output_global_config(struct cx24120_state *state,
-			u8 flag);
+						 u8 flag);
 
 /* Check if we're running a command that needs to disable mpeg out */
 static void cx24120_check_cmd(struct cx24120_state *state, u8 id)
@@ -370,10 +358,9 @@ static void cx24120_check_cmd(struct cx24120_state *state, u8 id)
 	}
 }
 
-
 /* Send a message to the firmware */
 static int cx24120_message_send(struct cx24120_state *state,
-			struct cx24120_cmd *cmd)
+				struct cx24120_cmd *cmd)
 {
 	int ret, ficus;
 
@@ -383,7 +370,7 @@ static int cx24120_message_send(struct cx24120_state *state,
 	}
 
 	ret = cx24120_writereg(state, CX24120_REG_CMD_START, cmd->id);
-	ret = cx24120_writeregN(state, CX24120_REG_CMD_ARGS, &cmd->arg[0],
+	ret = cx24120_writeregs(state, CX24120_REG_CMD_ARGS, &cmd->arg[0],
 				cmd->len, 1);
 	ret = cx24120_writereg(state, CX24120_REG_CMD_END, 0x01);
 
@@ -404,7 +391,7 @@ static int cx24120_message_send(struct cx24120_state *state,
 
 /* Send a message and fill arg[] with the results */
 static int cx24120_message_sendrcv(struct cx24120_state *state,
-			struct cx24120_cmd *cmd, u8 numreg)
+				   struct cx24120_cmd *cmd, u8 numreg)
 {
 	int ret, i;
 
@@ -422,15 +409,13 @@ static int cx24120_message_sendrcv(struct cx24120_state *state,
 
 	/* Read numreg registers starting from register cmd->len */
 	for (i = 0; i < numreg; i++)
-		cmd->arg[i] = cx24120_readreg(state, (cmd->len+i+1));
+		cmd->arg[i] = cx24120_readreg(state, (cmd->len + i + 1));
 
 	return 0;
 }
 
-
-
 static int cx24120_read_signal_strength(struct dvb_frontend *fe,
-			u16 *signal_strength)
+					u16 *signal_strength)
 {
 	struct cx24120_state *state = fe->demodulator_priv;
 	struct cx24120_cmd cmd;
@@ -450,19 +435,18 @@ static int cx24120_read_signal_strength(struct dvb_frontend *fe,
 	sigstr_h = (cx24120_readreg(state, CX24120_REG_SIGSTR_H) >> 6) << 8;
 	sigstr_l = cx24120_readreg(state, CX24120_REG_SIGSTR_L);
 	dev_dbg(&state->i2c->dev, "%s: Signal strength from firmware= 0x%x\n",
-			__func__, (sigstr_h | sigstr_l));
+		__func__, (sigstr_h | sigstr_l));
 
 	/* cooked */
 	*signal_strength = ((sigstr_h | sigstr_l)  << 5) & 0x0000ffff;
 	dev_dbg(&state->i2c->dev, "%s: Signal strength= 0x%x\n",
-			__func__, *signal_strength);
+		__func__, *signal_strength);
 
 	return 0;
 }
 
-
 static int cx24120_msg_mpeg_output_global_config(struct cx24120_state *state,
-			u8 enable)
+						 u8 enable)
 {
 	struct cx24120_cmd cmd;
 	int ret;
@@ -478,20 +462,17 @@ static int cx24120_msg_mpeg_output_global_config(struct cx24120_state *state,
 	if (ret != 0) {
 		dev_dbg(&state->i2c->dev,
 			"%s: Failed to set MPEG output to %s\n",
-			__func__,
-			(enable)?"enabled":"disabled");
+			__func__, enable ? "enabled" : "disabled");
 		return ret;
 	}
 
 	state->mpeg_enabled = enable;
 	dev_dbg(&state->i2c->dev, "%s: MPEG output %s\n",
-		__func__,
-		(enable)?"enabled":"disabled");
+		__func__, enable ? "enabled" : "disabled");
 
 	return 0;
 }
 
-
 static int cx24120_msg_mpeg_output_config(struct cx24120_state *state, u8 seq)
 {
 	struct cx24120_cmd cmd;
@@ -500,7 +481,7 @@ static int cx24120_msg_mpeg_output_config(struct cx24120_state *state, u8 seq)
 
 	cmd.id = CMD_MPEG_INIT;
 	cmd.len = 7;
-	cmd.arg[0] = seq;		/* sequental number - can be 0,1,2 */
+	cmd.arg[0] = seq; /* sequental number - can be 0,1,2 */
 	cmd.arg[1] = ((i.x1 & 0x01) << 1) | ((i.x1 >> 1) & 0x01);
 	cmd.arg[2] = 0x05;
 	cmd.arg[3] = 0x02;
@@ -511,9 +492,8 @@ static int cx24120_msg_mpeg_output_config(struct cx24120_state *state, u8 seq)
 	return cx24120_message_send(state, &cmd);
 }
 
-
 static int cx24120_diseqc_send_burst(struct dvb_frontend *fe,
-			fe_sec_mini_cmd_t burst)
+				     fe_sec_mini_cmd_t burst)
 {
 	struct cx24120_state *state = fe->demodulator_priv;
 	struct cx24120_cmd cmd;
@@ -529,19 +509,18 @@ static int cx24120_diseqc_send_burst(struct dvb_frontend *fe,
 	cmd.arg[0] = 0x00;
 	if (burst)
 		cmd.arg[1] = 0x01;
+
 	dev_dbg(&state->i2c->dev, "%s: burst sent.\n", __func__);
 
 	return cx24120_message_send(state, &cmd);
 }
 
-
 static int cx24120_set_tone(struct dvb_frontend *fe, fe_sec_tone_mode_t tone)
 {
 	struct cx24120_state *state = fe->demodulator_priv;
 	struct cx24120_cmd cmd;
 
-	dev_dbg(&state->i2c->dev, "%s(%d)\n",
-			__func__, tone);
+	dev_dbg(&state->i2c->dev, "%s(%d)\n", __func__, tone);
 
 	if ((tone != SEC_TONE_ON) && (tone != SEC_TONE_OFF)) {
 		err("Invalid tone=%d\n", tone);
@@ -553,32 +532,29 @@ static int cx24120_set_tone(struct dvb_frontend *fe, fe_sec_tone_mode_t tone)
 	cmd.arg[0] = 0x00;
 	cmd.arg[1] = 0x00;
 	cmd.arg[2] = 0x00;
-	cmd.arg[3] = (tone == SEC_TONE_ON)?0x01:0x00;
+	cmd.arg[3] = (tone == SEC_TONE_ON) ? 0x01 : 0x00;
 
 	return cx24120_message_send(state, &cmd);
 }
 
-
 static int cx24120_set_voltage(struct dvb_frontend *fe,
-			fe_sec_voltage_t voltage)
+			       fe_sec_voltage_t voltage)
 {
 	struct cx24120_state *state = fe->demodulator_priv;
 	struct cx24120_cmd cmd;
 
-	dev_dbg(&state->i2c->dev, "%s(%d)\n",
-			__func__, voltage);
+	dev_dbg(&state->i2c->dev, "%s(%d)\n", __func__, voltage);
 
 	cmd.id = CMD_SETVOLTAGE;
 	cmd.len = 2;
 	cmd.arg[0] = 0x00;
-	cmd.arg[1] = (voltage == SEC_VOLTAGE_18)?0x01:0x00;
+	cmd.arg[1] = (voltage == SEC_VOLTAGE_18) ? 0x01 : 0x00;
 
 	return cx24120_message_send(state, &cmd);
 }
 
-
 static int cx24120_send_diseqc_msg(struct dvb_frontend *fe,
-			struct dvb_diseqc_master_cmd *d)
+				   struct dvb_diseqc_master_cmd *d)
 {
 	struct cx24120_state *state = fe->demodulator_priv;
 	struct cx24120_cmd cmd;
@@ -637,7 +613,6 @@ static int cx24120_send_diseqc_msg(struct dvb_frontend *fe,
 	return -ETIMEDOUT;
 }
 
-
 /* Read current tuning status */
 static int cx24120_read_status(struct dvb_frontend *fe, fe_status_t *status)
 {
@@ -667,7 +642,6 @@ static int cx24120_read_status(struct dvb_frontend *fe, fe_status_t *status)
 	return 0;
 }
 
-
 /* FEC & modulation lookup table
  * Used for decoding the REG_FECMODE register
  * once tuned in.
@@ -704,7 +678,6 @@ static struct cx24120_modfec {
 	{ SYS_DVBS2, PSK_8, FEC_9_10, 0x11 },
 };
 
-
 /* Retrieve current fec, modulation & pilot values */
 static int cx24120_get_fec(struct dvb_frontend *fe)
 {
@@ -712,19 +685,19 @@ static int cx24120_get_fec(struct dvb_frontend *fe)
 	struct cx24120_state *state = fe->demodulator_priv;
 	int idx;
 	int ret;
-	int GettedFEC;
+	int fec;
 
 	dev_dbg(&state->i2c->dev, "%s()\n", __func__);
 
 	ret = cx24120_readreg(state, CX24120_REG_FECMODE);
-	GettedFEC = ret & 0x3f; /* Lower 6 bits */
+	fec = ret & 0x3f; /* Lower 6 bits */
 
-	dev_dbg(&state->i2c->dev, "%s: Get FEC: %d\n", __func__, GettedFEC);
+	dev_dbg(&state->i2c->dev, "%s: Get FEC: %d\n", __func__, fec);
 
 	for (idx = 0; idx < ARRAY_SIZE(modfec_lookup_table); idx++) {
 		if (modfec_lookup_table[idx].delsys != state->dcur.delsys)
 			continue;
-		if (modfec_lookup_table[idx].val != GettedFEC)
+		if (modfec_lookup_table[idx].val != fec)
 			continue;
 
 		break; /* found */
@@ -749,7 +722,6 @@ static int cx24120_get_fec(struct dvb_frontend *fe)
 	return 0;
 }
 
-
 /* Clock ratios lookup table
  *
  * Values obtained from much larger table in old driver
@@ -803,7 +775,6 @@ static struct cx24120_clock_ratios_table {
 	{ SYS_DVBS,  PILOT_OFF, QPSK,  FEC_7_8,  1068144, 610368, 448 },
 };
 
-
 /* Set clock ratio from lookup table */
 static void cx24120_set_clock_ratios(struct dvb_frontend *fe)
 {
@@ -872,13 +843,11 @@ static void cx24120_set_clock_ratios(struct dvb_frontend *fe)
 	cx24120_message_send(state, &cmd);
 }
 
-
 /* Set inversion value */
 static int cx24120_set_inversion(struct cx24120_state *state,
-	fe_spectral_inversion_t inversion)
+				 fe_spectral_inversion_t inversion)
 {
-	dev_dbg(&state->i2c->dev, "%s(%d)\n",
-		__func__, inversion);
+	dev_dbg(&state->i2c->dev, "%s(%d)\n", __func__, inversion);
 
 	switch (inversion) {
 	case INVERSION_OFF:
@@ -928,13 +897,12 @@ static struct cx24120_modfec_table {
 };
 
 /* Set fec_val & fec_mask values from delsys, modulation & fec */
-static int cx24120_set_fec(struct cx24120_state *state,
-	fe_modulation_t mod, fe_code_rate_t fec)
+static int cx24120_set_fec(struct cx24120_state *state, fe_modulation_t mod,
+			   fe_code_rate_t fec)
 {
 	int idx;
 
-	dev_dbg(&state->i2c->dev,
-		"%s(0x%02x,0x%02x)\n", __func__, mod, fec);
+	dev_dbg(&state->i2c->dev, "%s(0x%02x,0x%02x)\n", __func__, mod, fec);
 
 	state->dnxt.fec = fec;
 
@@ -966,11 +934,9 @@ static int cx24120_set_fec(struct cx24120_state *state,
 	return 0;
 }
 
-
 /* Set pilot */
-static int cx24120_set_pilot(struct cx24120_state *state,
-		fe_pilot_t pilot) {
-
+static int cx24120_set_pilot(struct cx24120_state *state, fe_pilot_t pilot)
+{
 	dev_dbg(&state->i2c->dev, "%s(%d)\n", __func__, pilot);
 
 	/* Pilot only valid in DVBS2 */
@@ -1014,7 +980,6 @@ static int cx24120_set_symbolrate(struct cx24120_state *state, u32 rate)
 	return 0;
 }
 
-
 /* Overwrite the current tuning params, we are about to tune */
 static void cx24120_clone_params(struct dvb_frontend *fe)
 {
@@ -1023,7 +988,6 @@ static void cx24120_clone_params(struct dvb_frontend *fe)
 	state->dcur = state->dnxt;
 }
 
-
 /* Table of time to tune for different symrates */
 static struct cx24120_symrate_delay {
 	fe_delivery_system_t delsys;
@@ -1042,7 +1006,6 @@ static struct cx24120_symrate_delay {
 	{ SYS_DVBS2,        0, 15000 },
 };
 
-
 static int cx24120_set_frontend(struct dvb_frontend *fe)
 {
 	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
@@ -1120,8 +1083,8 @@ static int cx24120_set_frontend(struct dvb_frontend *fe)
 	cmd.arg[1]  = (state->dcur.frequency & 0xff0000) >> 16;
 	cmd.arg[2]  = (state->dcur.frequency & 0x00ff00) >> 8;
 	cmd.arg[3]  = (state->dcur.frequency & 0x0000ff);
-	cmd.arg[4]  = ((state->dcur.symbol_rate/1000) & 0xff00) >> 8;
-	cmd.arg[5]  = ((state->dcur.symbol_rate/1000) & 0x00ff);
+	cmd.arg[4]  = ((state->dcur.symbol_rate / 1000) & 0xff00) >> 8;
+	cmd.arg[5]  = ((state->dcur.symbol_rate / 1000) & 0x00ff);
 	cmd.arg[6]  = state->dcur.inversion;
 	cmd.arg[7]  = state->dcur.fec_val | state->dcur.pilot_val;
 	cmd.arg[8]  = CX24120_SEARCH_RANGE_KHZ >> 8;
@@ -1190,7 +1153,6 @@ static int cx24120_set_frontend(struct dvb_frontend *fe)
 	return 0;
 }
 
-
 /* Calculate vco from config */
 static u64 cx24120_calculate_vco(struct cx24120_state *state)
 {
@@ -1213,7 +1175,6 @@ static u64 cx24120_calculate_vco(struct cx24120_state *state)
 	return inv_vco;
 }
 
-
 int cx24120_init(struct dvb_frontend *fe)
 {
 	const struct firmware *fw;
@@ -1270,8 +1231,8 @@ int cx24120_init(struct dvb_frontend *fe)
 
 	ret = state->config->request_firmware(fe, &fw, CX24120_FIRMWARE);
 	if (ret) {
-		err("Could not load firmware (%s): %d\n",
-			CX24120_FIRMWARE, ret);
+		err("Could not load firmware (%s): %d\n", CX24120_FIRMWARE,
+		    ret);
 		return ret;
 	}
 
@@ -1291,7 +1252,7 @@ int cx24120_init(struct dvb_frontend *fe)
 	ret = cx24120_writereg(state, 0xf7, 0x81);
 	ret = cx24120_writereg(state, 0xf8, 0x00);
 	ret = cx24120_writereg(state, 0xf9, 0x00);
-	ret = cx24120_writeregN(state, 0xfa, fw->data, (fw->size - 1), 0x00);
+	ret = cx24120_writeregs(state, 0xfa, fw->data, (fw->size - 1), 0x00);
 	ret = cx24120_writereg(state, 0xf7, 0xc0);
 	ret = cx24120_writereg(state, 0xe0, 0x00);
 	ret = (fw->size - 2) & 0x00ff;
@@ -1319,7 +1280,6 @@ int cx24120_init(struct dvb_frontend *fe)
 	if (reset_result != 0)
 		return reset_result;
 
-
 	/* Start tuner */
 	cmd.id = CMD_START_TUNER;
 	cmd.len = 3;
@@ -1355,7 +1315,6 @@ int cx24120_init(struct dvb_frontend *fe)
 		return -EREMOTEIO;
 	}
 
-
 	/* set bandwidth */
 	cmd.id = CMD_BANDWIDTH;
 	cmd.len = 12;
@@ -1386,8 +1345,7 @@ int cx24120_init(struct dvb_frontend *fe)
 	}
 
 	dev_dbg(&state->i2c->dev, "%s: Tuner initialised correctly.\n",
-			__func__);
-
+		__func__);
 
 	/* Initialise mpeg outputs */
 	ret = cx24120_writereg(state, 0xeb, 0x0a);
@@ -1399,7 +1357,6 @@ int cx24120_init(struct dvb_frontend *fe)
 		return -EREMOTEIO;
 	}
 
-
 	/* ???? */
 	cmd.id = CMD_TUNER_INIT;
 	cmd.len = 3;
@@ -1411,7 +1368,6 @@ int cx24120_init(struct dvb_frontend *fe)
 		return -EREMOTEIO;
 	}
 
-
 	/* Firmware CMD 35: Get firmware version */
 	cmd.id = CMD_FWVERSION;
 	cmd.len = 1;
@@ -1428,9 +1384,9 @@ int cx24120_init(struct dvb_frontend *fe)
 	return 0;
 }
 
-
 static int cx24120_tune(struct dvb_frontend *fe, bool re_tune,
-	unsigned int mode_flags, unsigned int *delay, fe_status_t *status)
+			unsigned int mode_flags, unsigned int *delay,
+			fe_status_t *status)
 {
 	struct cx24120_state *state = fe->demodulator_priv;
 	int ret;
@@ -1448,27 +1404,16 @@ static int cx24120_tune(struct dvb_frontend *fe, bool re_tune,
 	return cx24120_read_status(fe, status);
 }
 
-
-
 static int cx24120_get_algo(struct dvb_frontend *fe)
 {
 	return DVBFE_ALGO_HW;
 }
 
-
 static int cx24120_sleep(struct dvb_frontend *fe)
 {
 	return 0;
 }
 
-
-/*static int cx24120_wakeup(struct dvb_frontend *fe)
- * {
- *   return 0;
- * }
-*/
-
-
 static int cx24120_get_frontend(struct dvb_frontend *fe)
 {
 	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
@@ -1495,7 +1440,6 @@ static int cx24120_get_frontend(struct dvb_frontend *fe)
 	return 0;
 }
 
-
 static void cx24120_release(struct dvb_frontend *fe)
 {
 	struct cx24120_state *state = fe->demodulator_priv;
@@ -1504,7 +1448,6 @@ static void cx24120_release(struct dvb_frontend *fe)
 	kfree(state);
 }
 
-
 static int cx24120_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)
 {
 	struct cx24120_state *state = fe->demodulator_priv;
@@ -1512,12 +1455,10 @@ static int cx24120_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)
 	*ucblocks = (cx24120_readreg(state, CX24120_REG_UCB_H) << 8) |
 		     cx24120_readreg(state, CX24120_REG_UCB_L);
 
-	dev_dbg(&state->i2c->dev, "%s: Blocks = %d\n",
-			__func__, *ucblocks);
+	dev_dbg(&state->i2c->dev, "%s: Blocks = %d\n", __func__, *ucblocks);
 	return 0;
 }
 
-
 static struct dvb_frontend_ops cx24120_ops = {
 	.delsys = { SYS_DVBS, SYS_DVBS2 },
 	.info = {

commit 2e89a5e085ca301506fb28793dd16f9f147ccc06
Author: Patrick Boettcher <patrick.boettcher@posteo.de>
Date:   Tue Apr 28 13:18:05 2015 -0300

    [media] cx24120: fix codingstyle issue first round
    
    Mauro pointed out some coding style issues in his review.
    This patch fixes them.
    
    Signed-off-by: Patrick Boettcher <patrick.boettcher@posteo.de>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/cx24120.c b/drivers/media/dvb-frontends/cx24120.c
index 2ed3fbc81e29..e09cab62b2c6 100644
--- a/drivers/media/dvb-frontends/cx24120.c
+++ b/drivers/media/dvb-frontends/cx24120.c
@@ -36,34 +36,34 @@
 #define CX24120_FIRMWARE "dvb-fe-cx24120-1.20.58.2.fw"
 
 /* cx24120 i2c registers  */
-#define CX24120_REG_CMD_START	(0x00)		/* write cmd_id */
-#define CX24120_REG_CMD_ARGS	(0x01)		/* write command arguments */
-#define CX24120_REG_CMD_END	(0x1f)		/* write 0x01 for end */
+#define CX24120_REG_CMD_START	0x00		/* write cmd_id */
+#define CX24120_REG_CMD_ARGS	0x01		/* write command arguments */
+#define CX24120_REG_CMD_END	0x1f		/* write 0x01 for end */
 
-#define CX24120_REG_MAILBOX	(0x33)
-#define CX24120_REG_FREQ3	(0x34)		/* frequency */
-#define CX24120_REG_FREQ2	(0x35)
-#define CX24120_REG_FREQ1	(0x36)
+#define CX24120_REG_MAILBOX	0x33
+#define CX24120_REG_FREQ3	0x34		/* frequency */
+#define CX24120_REG_FREQ2	0x35
+#define CX24120_REG_FREQ1	0x36
 
-#define CX24120_REG_FECMODE	(0x39)		/* FEC status */
-#define CX24120_REG_STATUS	(0x3a)		/* Tuner status */
-#define CX24120_REG_SIGSTR_H	(0x3a)		/* Signal strength high */
-#define CX24120_REG_SIGSTR_L	(0x3b)		/* Signal strength low byte */
-#define CX24120_REG_QUALITY_H	(0x40)		/* SNR high byte */
-#define CX24120_REG_QUALITY_L	(0x41)		/* SNR low byte */
+#define CX24120_REG_FECMODE	0x39		/* FEC status */
+#define CX24120_REG_STATUS	0x3a		/* Tuner status */
+#define CX24120_REG_SIGSTR_H	0x3a		/* Signal strength high */
+#define CX24120_REG_SIGSTR_L	0x3b		/* Signal strength low byte */
+#define CX24120_REG_QUALITY_H	0x40		/* SNR high byte */
+#define CX24120_REG_QUALITY_L	0x41		/* SNR low byte */
 
-#define CX24120_REG_BER_HH	(0x47)		/* BER high byte of high word */
-#define CX24120_REG_BER_HL	(0x48)		/* BER low byte of high word */
-#define CX24120_REG_BER_LH	(0x49)		/* BER high byte of low word */
-#define CX24120_REG_BER_LL	(0x4a)		/* BER low byte of low word */
+#define CX24120_REG_BER_HH	0x47		/* BER high byte of high word */
+#define CX24120_REG_BER_HL	0x48		/* BER low byte of high word */
+#define CX24120_REG_BER_LH	0x49		/* BER high byte of low word */
+#define CX24120_REG_BER_LL	0x4a		/* BER low byte of low word */
 
-#define CX24120_REG_UCB_H	(0x50)		/* UCB high byte */
-#define CX24120_REG_UCB_L	(0x51)		/* UCB low byte  */
+#define CX24120_REG_UCB_H	0x50		/* UCB high byte */
+#define CX24120_REG_UCB_L	0x51		/* UCB low byte  */
 
-#define CX24120_REG_CLKDIV	(0xe6)
-#define CX24120_REG_RATEDIV	(0xf0)
+#define CX24120_REG_CLKDIV	0xe6
+#define CX24120_REG_RATEDIV	0xf0
 
-#define CX24120_REG_REVISION	(0xff)		/* Chip revision (ro) */
+#define CX24120_REG_REVISION	0xff		/* Chip revision (ro) */
 
 
 /* Command messages */
@@ -94,19 +94,19 @@ enum command_message_id {
 #define CX24120_MAX_CMD_LEN	30
 
 /* pilot mask */
-#define CX24120_PILOT_OFF	(0x00)
-#define CX24120_PILOT_ON	(0x40)
-#define CX24120_PILOT_AUTO	(0x80)
+#define CX24120_PILOT_OFF	0x00
+#define CX24120_PILOT_ON	0x40
+#define CX24120_PILOT_AUTO	0x80
 
 /* signal status */
-#define CX24120_HAS_SIGNAL	(0x01)
-#define CX24120_HAS_CARRIER	(0x02)
-#define CX24120_HAS_VITERBI	(0x04)
-#define CX24120_HAS_LOCK	(0x08)
-#define CX24120_HAS_UNK1	(0x10)
-#define CX24120_HAS_UNK2	(0x20)
-#define CX24120_STATUS_MASK	(0x0f)
-#define CX24120_SIGNAL_MASK	(0xc0)
+#define CX24120_HAS_SIGNAL	0x01
+#define CX24120_HAS_CARRIER	0x02
+#define CX24120_HAS_VITERBI	0x04
+#define CX24120_HAS_LOCK	0x08
+#define CX24120_HAS_UNK1	0x10
+#define CX24120_HAS_UNK2	0x20
+#define CX24120_STATUS_MASK	0x0f
+#define CX24120_SIGNAL_MASK	0xc0
 
 #define info(args...) pr_info("cx24120: " args)
 #define err(args...)  pr_err("cx24120: ### ERROR: " args)
@@ -164,16 +164,18 @@ static int cx24120_readreg(struct cx24120_state *state, u8 reg)
 		{	.addr = state->config->i2c_addr,
 			.flags = 0,
 			.len = 1,
-			.buf = &reg	},
-
-		{	.addr = state->config->i2c_addr,
+			.buf = &reg
+		}, {
+			.addr = state->config->i2c_addr,
 			.flags = I2C_M_RD,
 			.len = 1,
-			.buf = &buf	}
+			.buf = &buf
+		}
 	};
+
 	ret = i2c_transfer(state->i2c, msg, 2);
 	if (ret != 2) {
-		err("Read error: reg=0x%02x, ret=0x%02x)\n", reg, ret);
+		err("Read error: reg=0x%02x, ret=%i)\n", reg, ret);
 		return ret;
 	}
 
@@ -192,7 +194,8 @@ static int cx24120_writereg(struct cx24120_state *state, u8 reg, u8 data)
 		.addr = state->config->i2c_addr,
 		.flags = 0,
 		.buf = buf,
-		.len = 2 };
+		.len = 2
+	};
 	int ret;
 
 	ret = i2c_transfer(state->i2c, &msg, 1);
@@ -246,9 +249,8 @@ static int cx24120_writeregN(struct cx24120_state *state,
 		}
 
 		dev_dbg(&state->i2c->dev,
-			"%s: reg=0x%02x; data=0x%02x,0x%02x,0x%02x,0x%02x\n",
-			__func__, reg,
-			msg.buf[1], msg.buf[2], msg.buf[3], msg.buf[4]);
+			"%s: reg=0x%02x; data=%*ph\n",
+			__func__, reg, msg.len, msg.buf+1);
 	}
 
 	ret = 0;
@@ -268,8 +270,7 @@ struct dvb_frontend *cx24120_attach(const struct cx24120_config *config,
 	int demod_rev;
 
 	info("Conexant cx24120/cx24118 - DVBS/S2 Satellite demod/tuner\n");
-	state = kzalloc(sizeof(struct cx24120_state),
-						GFP_KERNEL);
+	state = kzalloc(sizeof(struct cx24120_state), GFP_KERNEL);
 	if (state == NULL) {
 		err("Unable to allocate memory for cx24120_state\n");
 		goto error;
@@ -297,7 +298,7 @@ struct dvb_frontend *cx24120_attach(const struct cx24120_config *config,
 	/* create dvb_frontend */
 	state->cold_init = 0;
 	memcpy(&state->frontend.ops, &cx24120_ops,
-			sizeof(struct dvb_frontend_ops));
+	       sizeof(struct dvb_frontend_ops));
 	state->frontend.demodulator_priv = state;
 
 	info("Conexant cx24120/cx24118 attached.\n");
@@ -677,30 +678,30 @@ static struct cx24120_modfec {
 	fe_code_rate_t fec;
 	u8 val;
 } modfec_lookup_table[] = {
-/*delsys	mod	fec		val */
-{ SYS_DVBS,	QPSK,	FEC_1_2,	0x01 },
-{ SYS_DVBS,	QPSK,	FEC_2_3,	0x02 },
-{ SYS_DVBS,	QPSK,	FEC_3_4,	0x03 },
-{ SYS_DVBS,	QPSK,	FEC_4_5,	0x04 },
-{ SYS_DVBS,	QPSK,	FEC_5_6,	0x05 },
-{ SYS_DVBS,	QPSK,	FEC_6_7,	0x06 },
-{ SYS_DVBS,	QPSK,	FEC_7_8,	0x07 },
-
-{ SYS_DVBS2,	QPSK,	FEC_1_2,	0x04 },
-{ SYS_DVBS2,	QPSK,	FEC_3_5,	0x05 },
-{ SYS_DVBS2,	QPSK,	FEC_2_3,	0x06 },
-{ SYS_DVBS2,	QPSK,	FEC_3_4,	0x07 },
-{ SYS_DVBS2,	QPSK,	FEC_4_5,	0x08 },
-{ SYS_DVBS2,	QPSK,	FEC_5_6,	0x09 },
-{ SYS_DVBS2,	QPSK,	FEC_8_9,	0x0a },
-{ SYS_DVBS2,	QPSK,	FEC_9_10,	0x0b },
-
-{ SYS_DVBS2,	PSK_8,	FEC_3_5,	0x0c },
-{ SYS_DVBS2,	PSK_8,	FEC_2_3,	0x0d },
-{ SYS_DVBS2,	PSK_8,	FEC_3_4,	0x0e },
-{ SYS_DVBS2,	PSK_8,	FEC_5_6,	0x0f },
-{ SYS_DVBS2,	PSK_8,	FEC_8_9,	0x10 },
-{ SYS_DVBS2,	PSK_8,	FEC_9_10,	0x11 },
+	/*delsys     mod    fec       val */
+	{ SYS_DVBS,  QPSK,  FEC_1_2,  0x01 },
+	{ SYS_DVBS,  QPSK,  FEC_2_3,  0x02 },
+	{ SYS_DVBS,  QPSK,  FEC_3_4,  0x03 },
+	{ SYS_DVBS,  QPSK,  FEC_4_5,  0x04 },
+	{ SYS_DVBS,  QPSK,  FEC_5_6,  0x05 },
+	{ SYS_DVBS,  QPSK,  FEC_6_7,  0x06 },
+	{ SYS_DVBS,  QPSK,  FEC_7_8,  0x07 },
+
+	{ SYS_DVBS2, QPSK,  FEC_1_2,  0x04 },
+	{ SYS_DVBS2, QPSK,  FEC_3_5,  0x05 },
+	{ SYS_DVBS2, QPSK,  FEC_2_3,  0x06 },
+	{ SYS_DVBS2, QPSK,  FEC_3_4,  0x07 },
+	{ SYS_DVBS2, QPSK,  FEC_4_5,  0x08 },
+	{ SYS_DVBS2, QPSK,  FEC_5_6,  0x09 },
+	{ SYS_DVBS2, QPSK,  FEC_8_9,  0x0a },
+	{ SYS_DVBS2, QPSK,  FEC_9_10, 0x0b },
+
+	{ SYS_DVBS2, PSK_8, FEC_3_5,  0x0c },
+	{ SYS_DVBS2, PSK_8, FEC_2_3,  0x0d },
+	{ SYS_DVBS2, PSK_8, FEC_3_4,  0x0e },
+	{ SYS_DVBS2, PSK_8, FEC_5_6,  0x0f },
+	{ SYS_DVBS2, PSK_8, FEC_8_9,  0x10 },
+	{ SYS_DVBS2, PSK_8, FEC_9_10, 0x11 },
 };
 
 
@@ -716,7 +717,7 @@ static int cx24120_get_fec(struct dvb_frontend *fe)
 	dev_dbg(&state->i2c->dev, "%s()\n", __func__);
 
 	ret = cx24120_readreg(state, CX24120_REG_FECMODE);
-	GettedFEC = ret & 0x3f;		/* Lower 6 bits */
+	GettedFEC = ret & 0x3f; /* Lower 6 bits */
 
 	dev_dbg(&state->i2c->dev, "%s: Get FEC: %d\n", __func__, GettedFEC);
 
@@ -726,7 +727,7 @@ static int cx24120_get_fec(struct dvb_frontend *fe)
 		if (modfec_lookup_table[idx].val != GettedFEC)
 			continue;
 
-		break;	/* found */
+		break; /* found */
 	}
 
 	if (idx >= ARRAY_SIZE(modfec_lookup_table)) {
@@ -766,40 +767,40 @@ static struct cx24120_clock_ratios_table {
 	u32 n_rat;
 	u32 rate;
 } clock_ratios_table[] = {
-/*delsys	pilot		mod	fec		m_rat	n_rat	rate */
-{ SYS_DVBS2,	PILOT_OFF,	QPSK,	FEC_1_2,	273088,	254505,	274 },
-{ SYS_DVBS2,	PILOT_OFF,	QPSK,	FEC_3_5,	17272,	13395,	330 },
-{ SYS_DVBS2,	PILOT_OFF,	QPSK,	FEC_2_3,	24344,	16967,	367 },
-{ SYS_DVBS2,	PILOT_OFF,	QPSK,	FEC_3_4,	410788,	254505,	413 },
-{ SYS_DVBS2,	PILOT_OFF,	QPSK,	FEC_4_5,	438328,	254505,	440 },
-{ SYS_DVBS2,	PILOT_OFF,	QPSK,	FEC_5_6,	30464,	16967,	459 },
-{ SYS_DVBS2,	PILOT_OFF,	QPSK,	FEC_8_9,	487832,	254505,	490 },
-{ SYS_DVBS2,	PILOT_OFF,	QPSK,	FEC_9_10,	493952,	254505,	496 },
-{ SYS_DVBS2,	PILOT_OFF,	PSK_8,	FEC_3_5,	328168,	169905,	494 },
-{ SYS_DVBS2,	PILOT_OFF,	PSK_8,	FEC_2_3,	24344,	11327,	550 },
-{ SYS_DVBS2,	PILOT_OFF,	PSK_8,	FEC_3_4,	410788,	169905,	618 },
-{ SYS_DVBS2,	PILOT_OFF,	PSK_8,	FEC_5_6,	30464,	11327,	688 },
-{ SYS_DVBS2,	PILOT_OFF,	PSK_8,	FEC_8_9,	487832,	169905,	735 },
-{ SYS_DVBS2,	PILOT_OFF,	PSK_8,	FEC_9_10,	493952,	169905,	744 },
-{ SYS_DVBS2,	PILOT_ON,	QPSK,	FEC_1_2,	273088,	260709,	268 },
-{ SYS_DVBS2,	PILOT_ON,	QPSK,	FEC_3_5,	328168,	260709,	322 },
-{ SYS_DVBS2,	PILOT_ON,	QPSK,	FEC_2_3,	121720,	86903,	358 },
-{ SYS_DVBS2,	PILOT_ON,	QPSK,	FEC_3_4,	410788,	260709,	403 },
-{ SYS_DVBS2,	PILOT_ON,	QPSK,	FEC_4_5,	438328,	260709,	430 },
-{ SYS_DVBS2,	PILOT_ON,	QPSK,	FEC_5_6,	152320,	86903,	448 },
-{ SYS_DVBS2,	PILOT_ON,	QPSK,	FEC_8_9,	487832,	260709,	479 },
-{ SYS_DVBS2,	PILOT_ON,	QPSK,	FEC_9_10,	493952,	260709,	485 },
-{ SYS_DVBS2,	PILOT_ON,	PSK_8,	FEC_3_5,	328168,	173853,	483 },
-{ SYS_DVBS2,	PILOT_ON,	PSK_8,	FEC_2_3,	121720,	57951,	537 },
-{ SYS_DVBS2,	PILOT_ON,	PSK_8,	FEC_3_4,	410788,	173853,	604 },
-{ SYS_DVBS2,	PILOT_ON,	PSK_8,	FEC_5_6,	152320,	57951,	672 },
-{ SYS_DVBS2,	PILOT_ON,	PSK_8,	FEC_8_9,	487832,	173853,	718 },
-{ SYS_DVBS2,	PILOT_ON,	PSK_8,	FEC_9_10,	493952,	173853,	727 },
-{ SYS_DVBS,	PILOT_OFF,	QPSK,	FEC_1_2,	152592,	152592,	256 },
-{ SYS_DVBS,	PILOT_OFF,	QPSK,	FEC_2_3,	305184,	228888,	341 },
-{ SYS_DVBS,	PILOT_OFF,	QPSK,	FEC_3_4,	457776,	305184,	384 },
-{ SYS_DVBS,	PILOT_OFF,	QPSK,	FEC_5_6,	762960,	457776,	427 },
-{ SYS_DVBS,	PILOT_OFF,	QPSK,	FEC_7_8,	1068144, 610368, 448 },
+	/*delsys     pilot      mod    fec       m_rat    n_rat   rate */
+	{ SYS_DVBS2, PILOT_OFF, QPSK,  FEC_1_2,  273088,  254505, 274 },
+	{ SYS_DVBS2, PILOT_OFF, QPSK,  FEC_3_5,  17272,   13395,  330 },
+	{ SYS_DVBS2, PILOT_OFF, QPSK,  FEC_2_3,  24344,   16967,  367 },
+	{ SYS_DVBS2, PILOT_OFF, QPSK,  FEC_3_4,  410788,  254505, 413 },
+	{ SYS_DVBS2, PILOT_OFF, QPSK,  FEC_4_5,  438328,  254505, 440 },
+	{ SYS_DVBS2, PILOT_OFF, QPSK,  FEC_5_6,  30464,   16967,  459 },
+	{ SYS_DVBS2, PILOT_OFF, QPSK,  FEC_8_9,  487832,  254505, 490 },
+	{ SYS_DVBS2, PILOT_OFF, QPSK,  FEC_9_10, 493952,  254505, 496 },
+	{ SYS_DVBS2, PILOT_OFF, PSK_8, FEC_3_5,  328168,  169905, 494 },
+	{ SYS_DVBS2, PILOT_OFF, PSK_8, FEC_2_3,  24344,   11327,  550 },
+	{ SYS_DVBS2, PILOT_OFF, PSK_8, FEC_3_4,  410788,  169905, 618 },
+	{ SYS_DVBS2, PILOT_OFF, PSK_8, FEC_5_6,  30464,   11327,  688 },
+	{ SYS_DVBS2, PILOT_OFF, PSK_8, FEC_8_9,  487832,  169905, 735 },
+	{ SYS_DVBS2, PILOT_OFF, PSK_8, FEC_9_10, 493952,  169905, 744 },
+	{ SYS_DVBS2, PILOT_ON,  QPSK,  FEC_1_2,  273088,  260709, 268 },
+	{ SYS_DVBS2, PILOT_ON,  QPSK,  FEC_3_5,  328168,  260709, 322 },
+	{ SYS_DVBS2, PILOT_ON,  QPSK,  FEC_2_3,  121720,  86903,  358 },
+	{ SYS_DVBS2, PILOT_ON,  QPSK,  FEC_3_4,  410788,  260709, 403 },
+	{ SYS_DVBS2, PILOT_ON,  QPSK,  FEC_4_5,  438328,  260709, 430 },
+	{ SYS_DVBS2, PILOT_ON,  QPSK,  FEC_5_6,  152320,  86903,  448 },
+	{ SYS_DVBS2, PILOT_ON,  QPSK,  FEC_8_9,  487832,  260709, 479 },
+	{ SYS_DVBS2, PILOT_ON,  QPSK,  FEC_9_10, 493952,  260709, 485 },
+	{ SYS_DVBS2, PILOT_ON,  PSK_8, FEC_3_5,  328168,  173853, 483 },
+	{ SYS_DVBS2, PILOT_ON,  PSK_8, FEC_2_3,  121720,  57951,  537 },
+	{ SYS_DVBS2, PILOT_ON,  PSK_8, FEC_3_4,  410788,  173853, 604 },
+	{ SYS_DVBS2, PILOT_ON,  PSK_8, FEC_5_6,  152320,  57951,  672 },
+	{ SYS_DVBS2, PILOT_ON,  PSK_8, FEC_8_9,  487832,  173853, 718 },
+	{ SYS_DVBS2, PILOT_ON,  PSK_8, FEC_9_10, 493952,  173853, 727 },
+	{ SYS_DVBS,  PILOT_OFF, QPSK,  FEC_1_2,  152592,  152592, 256 },
+	{ SYS_DVBS,  PILOT_OFF, QPSK,  FEC_2_3,  305184,  228888, 341 },
+	{ SYS_DVBS,  PILOT_OFF, QPSK,  FEC_3_4,  457776,  305184, 384 },
+	{ SYS_DVBS,  PILOT_OFF, QPSK,  FEC_5_6,  762960,  457776, 427 },
+	{ SYS_DVBS,  PILOT_OFF, QPSK,  FEC_7_8,  1068144, 610368, 448 },
 };
 
 
@@ -835,7 +836,6 @@ static void cx24120_set_clock_ratios(struct dvb_frontend *fe)
 		return;
 	}
 
-
 	/* Read current values? */
 	cmd.id = CMD_CLOCK_READ;
 	cmd.len = 1;
@@ -855,8 +855,6 @@ static void cx24120_set_clock_ratios(struct dvb_frontend *fe)
 		clock_ratios_table[idx].n_rat,
 		clock_ratios_table[idx].rate);
 
-
-
 	/* Set the clock */
 	cmd.id = CMD_CLOCK_SET;
 	cmd.len = 10;
@@ -872,7 +870,6 @@ static void cx24120_set_clock_ratios(struct dvb_frontend *fe)
 	cmd.arg[9] = (clock_ratios_table[idx].rate >> 0) & 0xff;
 
 	cx24120_message_send(state, &cmd);
-
 }
 
 
@@ -902,15 +899,13 @@ static int cx24120_set_inversion(struct cx24120_state *state,
 	return 0;
 }
 
-/* FEC lookup table for tuning
- * Some DVB-S2 val's have been found by trial
- * and error. Sofar it seems to match up with
- * the contents of the REG_FECMODE after tuning
- * The rest will probably be the same but would
- * need testing.
- * Anything not in the table will run with
- * FEC_AUTO and take a while longer to tune in
- * ( c.500ms instead of 30ms )
+/*
+ * FEC lookup table for tuning Some DVB-S2 val's have been found by
+ * trial and error. Sofar it seems to match up with the contents of
+ * the REG_FECMODE after tuning The rest will probably be the same but
+ * would need testing.  Anything not in the table will run with
+ * FEC_AUTO and take a while longer to tune in ( c.500ms instead of
+ * 30ms )
  */
 static struct cx24120_modfec_table {
 	fe_delivery_system_t delsys;
@@ -919,17 +914,17 @@ static struct cx24120_modfec_table {
 	u8 val;
 } modfec_table[] = {
 /*delsys	mod	fec	 val */
-{ SYS_DVBS,	QPSK,	FEC_1_2, 0x2e },
-{ SYS_DVBS,	QPSK,	FEC_2_3, 0x2f },
-{ SYS_DVBS,	QPSK,	FEC_3_4, 0x30 },
-{ SYS_DVBS,	QPSK,	FEC_5_6, 0x31 },
-{ SYS_DVBS,	QPSK,	FEC_6_7, 0x32 },
-{ SYS_DVBS,	QPSK,	FEC_7_8, 0x33 },
+	{ SYS_DVBS,  QPSK,  FEC_1_2, 0x2e },
+	{ SYS_DVBS,  QPSK,  FEC_2_3, 0x2f },
+	{ SYS_DVBS,  QPSK,  FEC_3_4, 0x30 },
+	{ SYS_DVBS,  QPSK,  FEC_5_6, 0x31 },
+	{ SYS_DVBS,  QPSK,  FEC_6_7, 0x32 },
+	{ SYS_DVBS,  QPSK,  FEC_7_8, 0x33 },
 
-{ SYS_DVBS2,	QPSK,	FEC_3_4, 0x07 },
+	{ SYS_DVBS2, QPSK,  FEC_3_4, 0x07 },
 
-{ SYS_DVBS2,	PSK_8,	FEC_2_3, 0x0d },
-{ SYS_DVBS2,	PSK_8,	FEC_3_4, 0x0e },
+	{ SYS_DVBS2, PSK_8, FEC_2_3, 0x0d },
+	{ SYS_DVBS2, PSK_8, FEC_3_4, 0x0e },
 };
 
 /* Set fec_val & fec_mask values from delsys, modulation & fec */
@@ -958,7 +953,6 @@ static int cx24120_set_fec(struct cx24120_state *state,
 		return 0;
 	}
 
-
 	if (state->dnxt.delsys == SYS_DVBS2) {
 		/* DVBS2 auto is 0x00/0x00 */
 		state->dnxt.fec_mask = 0x00;
@@ -977,8 +971,7 @@ static int cx24120_set_fec(struct cx24120_state *state,
 static int cx24120_set_pilot(struct cx24120_state *state,
 		fe_pilot_t pilot) {
 
-	dev_dbg(&state->i2c->dev,
-		"%s(%d)\n", __func__, pilot);
+	dev_dbg(&state->i2c->dev, "%s(%d)\n", __func__, pilot);
 
 	/* Pilot only valid in DVBS2 */
 	if (state->dnxt.delsys != SYS_DVBS2) {
@@ -986,7 +979,6 @@ static int cx24120_set_pilot(struct cx24120_state *state,
 		return 0;
 	}
 
-
 	switch (pilot) {
 	case PILOT_OFF:
 		state->dnxt.pilot_val = CX24120_PILOT_OFF;
@@ -1038,16 +1030,16 @@ static struct cx24120_symrate_delay {
 	u32 symrate;		/* Check for >= this symrate */
 	u32 delay;		/* Timeout in ms */
 } symrates_delay_table[] = {
-{ SYS_DVBS,	10000000,	400   },
-{ SYS_DVBS,	8000000,	2000  },
-{ SYS_DVBS,	6000000,	5000  },
-{ SYS_DVBS,	3000000,	10000 },
-{ SYS_DVBS,	0,		15000 },
-{ SYS_DVBS2,	10000000,	600   }, /* DVBS2 needs a little longer */
-{ SYS_DVBS2,	8000000,	2000  }, /* (so these might need bumping too) */
-{ SYS_DVBS2,	6000000,	5000  },
-{ SYS_DVBS2,	3000000,	10000 },
-{ SYS_DVBS2,	0,		15000 },
+	{ SYS_DVBS,  10000000,   400 },
+	{ SYS_DVBS,   8000000,  2000 },
+	{ SYS_DVBS,   6000000,  5000 },
+	{ SYS_DVBS,   3000000, 10000 },
+	{ SYS_DVBS,         0, 15000 },
+	{ SYS_DVBS2, 10000000,   600 }, /* DVBS2 needs a little longer */
+	{ SYS_DVBS2,  8000000,  2000 }, /* (so these might need bumping too) */
+	{ SYS_DVBS2,  6000000,  5000 },
+	{ SYS_DVBS2,  3000000, 10000 },
+	{ SYS_DVBS2,        0, 15000 },
 };
 
 
@@ -1077,7 +1069,6 @@ static int cx24120_set_frontend(struct dvb_frontend *fe)
 		break;
 	}
 
-
 	state->dnxt.delsys = c->delivery_system;
 	state->dnxt.modulation = c->modulation;
 	state->dnxt.frequency = c->frequency;
@@ -1099,7 +1090,6 @@ static int cx24120_set_frontend(struct dvb_frontend *fe)
 	if (ret !=  0)
 		return ret;
 
-
 	/* discard the 'current' tuning parameters and prepare to tune */
 	cx24120_clone_params(fe);
 
@@ -1123,8 +1113,6 @@ static int cx24120_set_frontend(struct dvb_frontend *fe)
 		"%s: Inversion   = %d (val = 0x%02x)\n", __func__,
 		state->dcur.inversion, state->dcur.inversion_val);
 
-
-
 	/* Tune in */
 	cmd.id = CMD_TUNEREQUEST;
 	cmd.len = 15;
@@ -1144,7 +1132,6 @@ static int cx24120_set_frontend(struct dvb_frontend *fe)
 	cmd.arg[13] = state->dcur.clkdiv;
 	cmd.arg[14] = 0;
 
-
 	/* Send tune command */
 	ret = cx24120_message_send(state, &cmd);
 	if (ret != 0)
@@ -1183,17 +1170,13 @@ static int cx24120_set_frontend(struct dvb_frontend *fe)
 		delay_cnt -= 20;
 	}
 
-
 	/* Fail to tune */
-	dev_dbg(&state->i2c->dev, "%s: Tuning failed\n",
-		__func__);
+	dev_dbg(&state->i2c->dev, "%s: Tuning failed\n", __func__);
 
 	return -EINVAL;
 
-
 tuned:
-	dev_dbg(&state->i2c->dev, "%s: Tuning successful\n",
-		__func__);
+	dev_dbg(&state->i2c->dev, "%s: Tuning successful\n", __func__);
 
 	/* Set clock ratios */
 	cx24120_set_clock_ratios(fe);

commit f7a77ebf08536da5cafd4494855001be74176efb
Author: Patrick Boettcher <patrick.boettcher@posteo.de>
Date:   Tue Apr 28 02:47:42 2015 -0300

    [media] cx24120: i2c-max-write-size is now configurable
    
    Some i2c-hosts are quite limited regarding maximum
    i2c-burst-write-sizes. This patch makes the previously
    hardcoded field configurable by users of the driver.
    
    Signed-off-by: Patrick Boettcher <patrick.boettcher@posteo.de>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/cx24120.c b/drivers/media/dvb-frontends/cx24120.c
index ff7f21496186..2ed3fbc81e29 100644
--- a/drivers/media/dvb-frontends/cx24120.c
+++ b/drivers/media/dvb-frontends/cx24120.c
@@ -209,46 +209,53 @@ static int cx24120_writereg(struct cx24120_state *state, u8 reg, u8 data)
 }
 
 
-/* Write multiple registers */
+/* Write multiple registers in chunks of i2c_wr_max-sized buffers */
 static int cx24120_writeregN(struct cx24120_state *state,
 			u8 reg, const u8 *values, u16 len, u8 incr)
 {
 	int ret;
-	u8 buf[5]; /* maximum 4 data bytes at once - flexcop limitation
-			(very limited i2c-interface this one) */
+	u16 max = state->config->i2c_wr_max > 0 ?
+				state->config->i2c_wr_max :
+				len;
 
 	struct i2c_msg msg = {
 		.addr = state->config->i2c_addr,
 		.flags = 0,
-		.buf = buf,
-		.len = len };
+	};
+
+	msg.buf = kmalloc(max + 1, GFP_KERNEL);
+	if (msg.buf == NULL)
+		return -ENOMEM;
 
 	while (len) {
-		buf[0] = reg;
-		msg.len = len > 4 ? 4 : len;
-		memcpy(&buf[1], values, msg.len);
+		msg.buf[0] = reg;
+		msg.len = len > max ? max : len;
+		memcpy(&msg.buf[1], values, msg.len);
 
-		len  -= msg.len;		/* data length revers counter */
-		values += msg.len;		/* incr data pointer */
+		len    -= msg.len;      /* data length revers counter */
+		values += msg.len;      /* incr data pointer */
 
 		if (incr)
 			reg += msg.len;
-		msg.len++;			/* don't forget the addr byte */
+		msg.len++;              /* don't forget the addr byte */
 
 		ret = i2c_transfer(state->i2c, &msg, 1);
 		if (ret != 1) {
 			err("i2c_write error(err == %i, 0x%02x)\n", ret, reg);
-			return ret;
+			goto out;
 		}
 
 		dev_dbg(&state->i2c->dev,
 			"%s: reg=0x%02x; data=0x%02x,0x%02x,0x%02x,0x%02x\n",
 			__func__, reg,
-			buf[1], buf[2], buf[3], buf[4]);
-
+			msg.buf[1], msg.buf[2], msg.buf[3], msg.buf[4]);
 	}
 
-	return 0;
+	ret = 0;
+
+out:
+	kfree(msg.buf);
+	return ret;
 }
 
 
@@ -1434,7 +1441,6 @@ int cx24120_init(struct dvb_frontend *fe)
 	}
 	info("FW version %i.%i.%i.%i\n", vers[0], vers[1], vers[2], vers[3]);
 
-
 	state->cold_init = 1;
 	return 0;
 }

commit c5fb0f5f545cdf90c451ea7c9a6fb98ae4c64e49
Author: Patrick Boettcher <patrick.boettcher@posteo.de>
Date:   Fri Apr 17 06:04:53 2015 -0300

    [media] cx24120: minor checkpatch fixes
    
    This patch fixes printk-related checkpatch warnings. All printks
    have been converted to pr_warn or pr_info or pr_err.
    
    Signed-off-by: Patrick.Boettcher <patrick.boettcher@posteo.de>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/cx24120.c b/drivers/media/dvb-frontends/cx24120.c
index 344d8b8e37e5..ff7f21496186 100644
--- a/drivers/media/dvb-frontends/cx24120.c
+++ b/drivers/media/dvb-frontends/cx24120.c
@@ -108,11 +108,8 @@ enum command_message_id {
 #define CX24120_STATUS_MASK	(0x0f)
 #define CX24120_SIGNAL_MASK	(0xc0)
 
-#define info(args...) do { printk(KERN_INFO "cx24120: "); \
-			printk(args); } while (0)
-#define err(args...) do {  printk(KERN_ERR "cx24120: ### ERROR: "); \
-			printk(args); } while (0)
-
+#define info(args...) pr_info("cx24120: " args)
+#define err(args...)  pr_err("cx24120: ### ERROR: " args)
 
 /* The Demod/Tuner can't easily provide these, we cache them */
 struct cx24120_tuning {

commit 5afc9a25be8d4e627cf07aa8a7500eafe3664b94
Author: Jemma Denson <jdenson@gmail.com>
Date:   Tue Apr 14 09:04:50 2015 -0300

    [media] Add support for TechniSat Skystar S2
    
    This patch adds support for the Technisat Skystar S2 - this
    has been tried before but the cx24120 driver was a bit out of shape
    and it didn't got any further:
    
    https://patchwork.linuxtv.org/patch/10575/
    
    It is an old card, but currently being sold off for next to nothing,
    so it's proving quite popular of late. Noticing it's quite similar
    to the cx24116 and cx24117 I've rewritten the driver in a similar way.
    
    There were a few registers and commands from those drivers
    missing from this one I've tested out and found they do something so
    they've been added in to speed up tuning and to make get_frontend
    return something useful.
    
    Signed-off-by: Jemma Denson <jdenson@gmail.com>
    Signed-off-by: Patrick.Boettcher <patrick.boettcher@posteo.de>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/cx24120.c b/drivers/media/dvb-frontends/cx24120.c
new file mode 100644
index 000000000000..344d8b8e37e5
--- /dev/null
+++ b/drivers/media/dvb-frontends/cx24120.c
@@ -0,0 +1,1577 @@
+/*
+    Conexant cx24120/cx24118 - DVBS/S2 Satellite demod/tuner driver
+
+    Copyright (C) 2008 Patrick Boettcher <pb@linuxtv.org>
+    Copyright (C) 2009 Sergey Tyurin <forum.free-x.de>
+    Updated 2012 by Jannis Achstetter <jannis_achstetter@web.de>
+    Copyright (C) 2015 Jemma Denson <jdenson@gmail.com>
+	April 2015
+	    Refactored & simplified driver
+	    Updated to work with delivery system supplied by DVBv5
+	    Add frequency, fec & pilot to get_frontend
+
+	Cards supported: Technisat Skystar S2
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+*/
+
+#include <linux/slab.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/firmware.h>
+#include "dvb_frontend.h"
+#include "cx24120.h"
+
+#define CX24120_SEARCH_RANGE_KHZ 5000
+#define CX24120_FIRMWARE "dvb-fe-cx24120-1.20.58.2.fw"
+
+/* cx24120 i2c registers  */
+#define CX24120_REG_CMD_START	(0x00)		/* write cmd_id */
+#define CX24120_REG_CMD_ARGS	(0x01)		/* write command arguments */
+#define CX24120_REG_CMD_END	(0x1f)		/* write 0x01 for end */
+
+#define CX24120_REG_MAILBOX	(0x33)
+#define CX24120_REG_FREQ3	(0x34)		/* frequency */
+#define CX24120_REG_FREQ2	(0x35)
+#define CX24120_REG_FREQ1	(0x36)
+
+#define CX24120_REG_FECMODE	(0x39)		/* FEC status */
+#define CX24120_REG_STATUS	(0x3a)		/* Tuner status */
+#define CX24120_REG_SIGSTR_H	(0x3a)		/* Signal strength high */
+#define CX24120_REG_SIGSTR_L	(0x3b)		/* Signal strength low byte */
+#define CX24120_REG_QUALITY_H	(0x40)		/* SNR high byte */
+#define CX24120_REG_QUALITY_L	(0x41)		/* SNR low byte */
+
+#define CX24120_REG_BER_HH	(0x47)		/* BER high byte of high word */
+#define CX24120_REG_BER_HL	(0x48)		/* BER low byte of high word */
+#define CX24120_REG_BER_LH	(0x49)		/* BER high byte of low word */
+#define CX24120_REG_BER_LL	(0x4a)		/* BER low byte of low word */
+
+#define CX24120_REG_UCB_H	(0x50)		/* UCB high byte */
+#define CX24120_REG_UCB_L	(0x51)		/* UCB low byte  */
+
+#define CX24120_REG_CLKDIV	(0xe6)
+#define CX24120_REG_RATEDIV	(0xf0)
+
+#define CX24120_REG_REVISION	(0xff)		/* Chip revision (ro) */
+
+
+/* Command messages */
+enum command_message_id {
+	CMD_VCO_SET		= 0x10,		/* cmd.len = 12; */
+	CMD_TUNEREQUEST		= 0x11,		/* cmd.len = 15; */
+
+	CMD_MPEG_ONOFF		= 0x13,		/* cmd.len = 4; */
+	CMD_MPEG_INIT		= 0x14,		/* cmd.len = 7; */
+	CMD_BANDWIDTH		= 0x15,		/* cmd.len = 12; */
+	CMD_CLOCK_READ		= 0x16,		/* read clock */
+	CMD_CLOCK_SET		= 0x17,		/* cmd.len = 10; */
+
+	CMD_DISEQC_MSG1		= 0x20,		/* cmd.len = 11; */
+	CMD_DISEQC_MSG2		= 0x21,		/* cmd.len = d->msg_len + 6; */
+	CMD_SETVOLTAGE		= 0x22,		/* cmd.len = 2; */
+	CMD_SETTONE		= 0x23,		/* cmd.len = 4; */
+	CMD_DISEQC_BURST	= 0x24,		/* cmd.len not used !!! */
+
+	CMD_READ_SNR		= 0x1a,		/* Read signal strength */
+	CMD_START_TUNER		= 0x1b,		/* ??? */
+
+	CMD_FWVERSION		= 0x35,
+
+	CMD_TUNER_INIT		= 0x3c,		/* cmd.len = 0x03; */
+};
+
+#define CX24120_MAX_CMD_LEN	30
+
+/* pilot mask */
+#define CX24120_PILOT_OFF	(0x00)
+#define CX24120_PILOT_ON	(0x40)
+#define CX24120_PILOT_AUTO	(0x80)
+
+/* signal status */
+#define CX24120_HAS_SIGNAL	(0x01)
+#define CX24120_HAS_CARRIER	(0x02)
+#define CX24120_HAS_VITERBI	(0x04)
+#define CX24120_HAS_LOCK	(0x08)
+#define CX24120_HAS_UNK1	(0x10)
+#define CX24120_HAS_UNK2	(0x20)
+#define CX24120_STATUS_MASK	(0x0f)
+#define CX24120_SIGNAL_MASK	(0xc0)
+
+#define info(args...) do { printk(KERN_INFO "cx24120: "); \
+			printk(args); } while (0)
+#define err(args...) do {  printk(KERN_ERR "cx24120: ### ERROR: "); \
+			printk(args); } while (0)
+
+
+/* The Demod/Tuner can't easily provide these, we cache them */
+struct cx24120_tuning {
+	u32 frequency;
+	u32 symbol_rate;
+	fe_spectral_inversion_t inversion;
+	fe_code_rate_t fec;
+
+	fe_delivery_system_t delsys;
+	fe_modulation_t modulation;
+	fe_pilot_t pilot;
+
+	/* Demod values */
+	u8 fec_val;
+	u8 fec_mask;
+	u8 clkdiv;
+	u8 ratediv;
+	u8 inversion_val;
+	u8 pilot_val;
+};
+
+
+/* Private state */
+struct cx24120_state {
+	struct i2c_adapter *i2c;
+	const struct cx24120_config *config;
+	struct dvb_frontend frontend;
+
+	u8 cold_init;
+	u8 mpeg_enabled;
+
+	/* current and next tuning parameters */
+	struct cx24120_tuning dcur;
+	struct cx24120_tuning dnxt;
+};
+
+
+/* Command message to firmware */
+struct cx24120_cmd {
+	u8 id;
+	u8 len;
+	u8 arg[CX24120_MAX_CMD_LEN];
+};
+
+
+/* Read single register */
+static int cx24120_readreg(struct cx24120_state *state, u8 reg)
+{
+	int ret;
+	u8 buf = 0;
+	struct i2c_msg msg[] = {
+		{	.addr = state->config->i2c_addr,
+			.flags = 0,
+			.len = 1,
+			.buf = &reg	},
+
+		{	.addr = state->config->i2c_addr,
+			.flags = I2C_M_RD,
+			.len = 1,
+			.buf = &buf	}
+	};
+	ret = i2c_transfer(state->i2c, msg, 2);
+	if (ret != 2) {
+		err("Read error: reg=0x%02x, ret=0x%02x)\n", reg, ret);
+		return ret;
+	}
+
+	dev_dbg(&state->i2c->dev, "%s: reg=0x%02x; data=0x%02x\n",
+		__func__, reg, buf);
+
+	return buf;
+}
+
+
+/* Write single register */
+static int cx24120_writereg(struct cx24120_state *state, u8 reg, u8 data)
+{
+	u8 buf[] = { reg, data };
+	struct i2c_msg msg = {
+		.addr = state->config->i2c_addr,
+		.flags = 0,
+		.buf = buf,
+		.len = 2 };
+	int ret;
+
+	ret = i2c_transfer(state->i2c, &msg, 1);
+	if (ret != 1) {
+		err("Write error: i2c_write error(err == %i, 0x%02x: 0x%02x)\n",
+				 ret, reg, data);
+		return ret;
+	}
+
+	dev_dbg(&state->i2c->dev, "%s: reg=0x%02x; data=0x%02x\n",
+		__func__, reg, data);
+
+	return 0;
+}
+
+
+/* Write multiple registers */
+static int cx24120_writeregN(struct cx24120_state *state,
+			u8 reg, const u8 *values, u16 len, u8 incr)
+{
+	int ret;
+	u8 buf[5]; /* maximum 4 data bytes at once - flexcop limitation
+			(very limited i2c-interface this one) */
+
+	struct i2c_msg msg = {
+		.addr = state->config->i2c_addr,
+		.flags = 0,
+		.buf = buf,
+		.len = len };
+
+	while (len) {
+		buf[0] = reg;
+		msg.len = len > 4 ? 4 : len;
+		memcpy(&buf[1], values, msg.len);
+
+		len  -= msg.len;		/* data length revers counter */
+		values += msg.len;		/* incr data pointer */
+
+		if (incr)
+			reg += msg.len;
+		msg.len++;			/* don't forget the addr byte */
+
+		ret = i2c_transfer(state->i2c, &msg, 1);
+		if (ret != 1) {
+			err("i2c_write error(err == %i, 0x%02x)\n", ret, reg);
+			return ret;
+		}
+
+		dev_dbg(&state->i2c->dev,
+			"%s: reg=0x%02x; data=0x%02x,0x%02x,0x%02x,0x%02x\n",
+			__func__, reg,
+			buf[1], buf[2], buf[3], buf[4]);
+
+	}
+
+	return 0;
+}
+
+
+static struct dvb_frontend_ops cx24120_ops;
+
+struct dvb_frontend *cx24120_attach(const struct cx24120_config *config,
+			struct i2c_adapter *i2c)
+{
+	struct cx24120_state *state = NULL;
+	int demod_rev;
+
+	info("Conexant cx24120/cx24118 - DVBS/S2 Satellite demod/tuner\n");
+	state = kzalloc(sizeof(struct cx24120_state),
+						GFP_KERNEL);
+	if (state == NULL) {
+		err("Unable to allocate memory for cx24120_state\n");
+		goto error;
+	}
+
+	/* setup the state */
+	state->config = config;
+	state->i2c = i2c;
+
+	/* check if the demod is present and has proper type */
+	demod_rev = cx24120_readreg(state, CX24120_REG_REVISION);
+	switch (demod_rev) {
+	case 0x07:
+		info("Demod cx24120 rev. 0x07 detected.\n");
+		break;
+	case 0x05:
+		info("Demod cx24120 rev. 0x05 detected.\n");
+		break;
+	default:
+		err("Unsupported demod revision: 0x%x detected.\n",
+			demod_rev);
+		goto error;
+	}
+
+	/* create dvb_frontend */
+	state->cold_init = 0;
+	memcpy(&state->frontend.ops, &cx24120_ops,
+			sizeof(struct dvb_frontend_ops));
+	state->frontend.demodulator_priv = state;
+
+	info("Conexant cx24120/cx24118 attached.\n");
+	return &state->frontend;
+
+error:
+	kfree(state);
+	return NULL;
+}
+EXPORT_SYMBOL(cx24120_attach);
+
+static int cx24120_test_rom(struct cx24120_state *state)
+{
+	int err, ret;
+
+	err = cx24120_readreg(state, 0xfd);
+	if (err & 4) {
+		ret = cx24120_readreg(state, 0xdf) & 0xfe;
+		err = cx24120_writereg(state, 0xdf, ret);
+	}
+	return err;
+}
+
+
+static int cx24120_read_snr(struct dvb_frontend *fe, u16 *snr)
+{
+	struct cx24120_state *state = fe->demodulator_priv;
+
+	*snr =  (cx24120_readreg(state, CX24120_REG_QUALITY_H)<<8) |
+		(cx24120_readreg(state, CX24120_REG_QUALITY_L));
+	dev_dbg(&state->i2c->dev, "%s: read SNR index = %d\n",
+			__func__, *snr);
+
+	return 0;
+}
+
+
+static int cx24120_read_ber(struct dvb_frontend *fe, u32 *ber)
+{
+	struct cx24120_state *state = fe->demodulator_priv;
+
+	*ber =  (cx24120_readreg(state, CX24120_REG_BER_HH) << 24)	|
+		(cx24120_readreg(state, CX24120_REG_BER_HL) << 16)	|
+		(cx24120_readreg(state, CX24120_REG_BER_LH)  << 8)	|
+		 cx24120_readreg(state, CX24120_REG_BER_LL);
+	dev_dbg(&state->i2c->dev, "%s: read BER index = %d\n",
+			__func__, *ber);
+
+	return 0;
+}
+
+static int cx24120_msg_mpeg_output_global_config(struct cx24120_state *state,
+			u8 flag);
+
+/* Check if we're running a command that needs to disable mpeg out */
+static void cx24120_check_cmd(struct cx24120_state *state, u8 id)
+{
+	switch (id) {
+	case CMD_TUNEREQUEST:
+	case CMD_CLOCK_READ:
+	case CMD_DISEQC_MSG1:
+	case CMD_DISEQC_MSG2:
+	case CMD_SETVOLTAGE:
+	case CMD_SETTONE:
+		cx24120_msg_mpeg_output_global_config(state, 0);
+		/* Old driver would do a msleep(100) here */
+	default:
+		return;
+	}
+}
+
+
+/* Send a message to the firmware */
+static int cx24120_message_send(struct cx24120_state *state,
+			struct cx24120_cmd *cmd)
+{
+	int ret, ficus;
+
+	if (state->mpeg_enabled) {
+		/* Disable mpeg out on certain commands */
+		cx24120_check_cmd(state, cmd->id);
+	}
+
+	ret = cx24120_writereg(state, CX24120_REG_CMD_START, cmd->id);
+	ret = cx24120_writeregN(state, CX24120_REG_CMD_ARGS, &cmd->arg[0],
+				cmd->len, 1);
+	ret = cx24120_writereg(state, CX24120_REG_CMD_END, 0x01);
+
+	ficus = 1000;
+	while (cx24120_readreg(state, CX24120_REG_CMD_END)) {
+		msleep(20);
+		ficus -= 20;
+		if (ficus == 0) {
+			err("Error sending message to firmware\n");
+			return -EREMOTEIO;
+		}
+	}
+	dev_dbg(&state->i2c->dev, "%s: Successfully send message 0x%02x\n",
+		__func__, cmd->id);
+
+	return 0;
+}
+
+/* Send a message and fill arg[] with the results */
+static int cx24120_message_sendrcv(struct cx24120_state *state,
+			struct cx24120_cmd *cmd, u8 numreg)
+{
+	int ret, i;
+
+	if (numreg > CX24120_MAX_CMD_LEN) {
+		err("Too many registers to read. cmd->reg = %d", numreg);
+		return -EREMOTEIO;
+	}
+
+	ret = cx24120_message_send(state, cmd);
+	if (ret != 0)
+		return ret;
+
+	if (!numreg)
+		return 0;
+
+	/* Read numreg registers starting from register cmd->len */
+	for (i = 0; i < numreg; i++)
+		cmd->arg[i] = cx24120_readreg(state, (cmd->len+i+1));
+
+	return 0;
+}
+
+
+
+static int cx24120_read_signal_strength(struct dvb_frontend *fe,
+			u16 *signal_strength)
+{
+	struct cx24120_state *state = fe->demodulator_priv;
+	struct cx24120_cmd cmd;
+	int ret, sigstr_h, sigstr_l;
+
+	cmd.id = CMD_READ_SNR;
+	cmd.len = 1;
+	cmd.arg[0] = 0x00;
+
+	ret = cx24120_message_send(state, &cmd);
+	if (ret != 0) {
+		err("error reading signal strength\n");
+		return -EREMOTEIO;
+	}
+
+	/* raw */
+	sigstr_h = (cx24120_readreg(state, CX24120_REG_SIGSTR_H) >> 6) << 8;
+	sigstr_l = cx24120_readreg(state, CX24120_REG_SIGSTR_L);
+	dev_dbg(&state->i2c->dev, "%s: Signal strength from firmware= 0x%x\n",
+			__func__, (sigstr_h | sigstr_l));
+
+	/* cooked */
+	*signal_strength = ((sigstr_h | sigstr_l)  << 5) & 0x0000ffff;
+	dev_dbg(&state->i2c->dev, "%s: Signal strength= 0x%x\n",
+			__func__, *signal_strength);
+
+	return 0;
+}
+
+
+static int cx24120_msg_mpeg_output_global_config(struct cx24120_state *state,
+			u8 enable)
+{
+	struct cx24120_cmd cmd;
+	int ret;
+
+	cmd.id = CMD_MPEG_ONOFF;
+	cmd.len = 4;
+	cmd.arg[0] = 0x01;
+	cmd.arg[1] = 0x00;
+	cmd.arg[2] = enable ? 0 : (u8)(-1);
+	cmd.arg[3] = 0x01;
+
+	ret = cx24120_message_send(state, &cmd);
+	if (ret != 0) {
+		dev_dbg(&state->i2c->dev,
+			"%s: Failed to set MPEG output to %s\n",
+			__func__,
+			(enable)?"enabled":"disabled");
+		return ret;
+	}
+
+	state->mpeg_enabled = enable;
+	dev_dbg(&state->i2c->dev, "%s: MPEG output %s\n",
+		__func__,
+		(enable)?"enabled":"disabled");
+
+	return 0;
+}
+
+
+static int cx24120_msg_mpeg_output_config(struct cx24120_state *state, u8 seq)
+{
+	struct cx24120_cmd cmd;
+	struct cx24120_initial_mpeg_config i =
+			state->config->initial_mpeg_config;
+
+	cmd.id = CMD_MPEG_INIT;
+	cmd.len = 7;
+	cmd.arg[0] = seq;		/* sequental number - can be 0,1,2 */
+	cmd.arg[1] = ((i.x1 & 0x01) << 1) | ((i.x1 >> 1) & 0x01);
+	cmd.arg[2] = 0x05;
+	cmd.arg[3] = 0x02;
+	cmd.arg[4] = ((i.x2 >> 1) & 0x01);
+	cmd.arg[5] = (i.x2 & 0xf0) | (i.x3 & 0x0f);
+	cmd.arg[6] = 0x10;
+
+	return cx24120_message_send(state, &cmd);
+}
+
+
+static int cx24120_diseqc_send_burst(struct dvb_frontend *fe,
+			fe_sec_mini_cmd_t burst)
+{
+	struct cx24120_state *state = fe->demodulator_priv;
+	struct cx24120_cmd cmd;
+
+	/* Yes, cmd.len is set to zero. The old driver
+	 * didn't specify any len, but also had a
+	 * memset 0 before every use of the cmd struct
+	 * which would have set it to zero.
+	 * This quite probably needs looking into.
+	 */
+	cmd.id = CMD_DISEQC_BURST;
+	cmd.len = 0;
+	cmd.arg[0] = 0x00;
+	if (burst)
+		cmd.arg[1] = 0x01;
+	dev_dbg(&state->i2c->dev, "%s: burst sent.\n", __func__);
+
+	return cx24120_message_send(state, &cmd);
+}
+
+
+static int cx24120_set_tone(struct dvb_frontend *fe, fe_sec_tone_mode_t tone)
+{
+	struct cx24120_state *state = fe->demodulator_priv;
+	struct cx24120_cmd cmd;
+
+	dev_dbg(&state->i2c->dev, "%s(%d)\n",
+			__func__, tone);
+
+	if ((tone != SEC_TONE_ON) && (tone != SEC_TONE_OFF)) {
+		err("Invalid tone=%d\n", tone);
+		return -EINVAL;
+	}
+
+	cmd.id = CMD_SETTONE;
+	cmd.len = 4;
+	cmd.arg[0] = 0x00;
+	cmd.arg[1] = 0x00;
+	cmd.arg[2] = 0x00;
+	cmd.arg[3] = (tone == SEC_TONE_ON)?0x01:0x00;
+
+	return cx24120_message_send(state, &cmd);
+}
+
+
+static int cx24120_set_voltage(struct dvb_frontend *fe,
+			fe_sec_voltage_t voltage)
+{
+	struct cx24120_state *state = fe->demodulator_priv;
+	struct cx24120_cmd cmd;
+
+	dev_dbg(&state->i2c->dev, "%s(%d)\n",
+			__func__, voltage);
+
+	cmd.id = CMD_SETVOLTAGE;
+	cmd.len = 2;
+	cmd.arg[0] = 0x00;
+	cmd.arg[1] = (voltage == SEC_VOLTAGE_18)?0x01:0x00;
+
+	return cx24120_message_send(state, &cmd);
+}
+
+
+static int cx24120_send_diseqc_msg(struct dvb_frontend *fe,
+			struct dvb_diseqc_master_cmd *d)
+{
+	struct cx24120_state *state = fe->demodulator_priv;
+	struct cx24120_cmd cmd;
+	int back_count;
+
+	dev_dbg(&state->i2c->dev, "%s()\n", __func__);
+
+	cmd.id = CMD_DISEQC_MSG1;
+	cmd.len = 11;
+	cmd.arg[0] = 0x00;
+	cmd.arg[1] = 0x00;
+	cmd.arg[2] = 0x03;
+	cmd.arg[3] = 0x16;
+	cmd.arg[4] = 0x28;
+	cmd.arg[5] = 0x01;
+	cmd.arg[6] = 0x01;
+	cmd.arg[7] = 0x14;
+	cmd.arg[8] = 0x19;
+	cmd.arg[9] = 0x14;
+	cmd.arg[10] = 0x1e;
+
+	if (cx24120_message_send(state, &cmd)) {
+		err("send 1st message(0x%x) failed\n", cmd.id);
+		return -EREMOTEIO;
+	}
+
+	cmd.id = CMD_DISEQC_MSG2;
+	cmd.len = d->msg_len + 6;
+	cmd.arg[0] = 0x00;
+	cmd.arg[1] = 0x01;
+	cmd.arg[2] = 0x02;
+	cmd.arg[3] = 0x00;
+	cmd.arg[4] = 0x00;
+	cmd.arg[5] = d->msg_len;
+
+	memcpy(&cmd.arg[6], &d->msg, d->msg_len);
+
+	if (cx24120_message_send(state, &cmd)) {
+		err("send 2nd message(0x%x) failed\n", cmd.id);
+		return -EREMOTEIO;
+	}
+
+	back_count = 500;
+	do {
+		if (!(cx24120_readreg(state, 0x93) & 0x01)) {
+			dev_dbg(&state->i2c->dev,
+				"%s: diseqc sequence sent success\n",
+				__func__);
+			return 0;
+		}
+		msleep(20);
+		back_count -= 20;
+	} while (back_count);
+
+	err("Too long waiting for diseqc.\n");
+	return -ETIMEDOUT;
+}
+
+
+/* Read current tuning status */
+static int cx24120_read_status(struct dvb_frontend *fe, fe_status_t *status)
+{
+	struct cx24120_state *state = fe->demodulator_priv;
+	int lock;
+
+	lock = cx24120_readreg(state, CX24120_REG_STATUS);
+
+	dev_dbg(&state->i2c->dev, "%s() status = 0x%02x\n",
+		__func__, lock);
+
+	*status = 0;
+
+	if (lock & CX24120_HAS_SIGNAL)
+		*status = FE_HAS_SIGNAL;
+	if (lock & CX24120_HAS_CARRIER)
+		*status |= FE_HAS_CARRIER;
+	if (lock & CX24120_HAS_VITERBI)
+		*status |= FE_HAS_VITERBI | FE_HAS_SYNC;
+	if (lock & CX24120_HAS_LOCK)
+		*status |= FE_HAS_LOCK;
+
+	/* TODO: is FE_HAS_SYNC in the right place?
+	 * Other cx241xx drivers have this slightly
+	 * different */
+
+	return 0;
+}
+
+
+/* FEC & modulation lookup table
+ * Used for decoding the REG_FECMODE register
+ * once tuned in.
+ */
+static struct cx24120_modfec {
+	fe_delivery_system_t delsys;
+	fe_modulation_t mod;
+	fe_code_rate_t fec;
+	u8 val;
+} modfec_lookup_table[] = {
+/*delsys	mod	fec		val */
+{ SYS_DVBS,	QPSK,	FEC_1_2,	0x01 },
+{ SYS_DVBS,	QPSK,	FEC_2_3,	0x02 },
+{ SYS_DVBS,	QPSK,	FEC_3_4,	0x03 },
+{ SYS_DVBS,	QPSK,	FEC_4_5,	0x04 },
+{ SYS_DVBS,	QPSK,	FEC_5_6,	0x05 },
+{ SYS_DVBS,	QPSK,	FEC_6_7,	0x06 },
+{ SYS_DVBS,	QPSK,	FEC_7_8,	0x07 },
+
+{ SYS_DVBS2,	QPSK,	FEC_1_2,	0x04 },
+{ SYS_DVBS2,	QPSK,	FEC_3_5,	0x05 },
+{ SYS_DVBS2,	QPSK,	FEC_2_3,	0x06 },
+{ SYS_DVBS2,	QPSK,	FEC_3_4,	0x07 },
+{ SYS_DVBS2,	QPSK,	FEC_4_5,	0x08 },
+{ SYS_DVBS2,	QPSK,	FEC_5_6,	0x09 },
+{ SYS_DVBS2,	QPSK,	FEC_8_9,	0x0a },
+{ SYS_DVBS2,	QPSK,	FEC_9_10,	0x0b },
+
+{ SYS_DVBS2,	PSK_8,	FEC_3_5,	0x0c },
+{ SYS_DVBS2,	PSK_8,	FEC_2_3,	0x0d },
+{ SYS_DVBS2,	PSK_8,	FEC_3_4,	0x0e },
+{ SYS_DVBS2,	PSK_8,	FEC_5_6,	0x0f },
+{ SYS_DVBS2,	PSK_8,	FEC_8_9,	0x10 },
+{ SYS_DVBS2,	PSK_8,	FEC_9_10,	0x11 },
+};
+
+
+/* Retrieve current fec, modulation & pilot values */
+static int cx24120_get_fec(struct dvb_frontend *fe)
+{
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	struct cx24120_state *state = fe->demodulator_priv;
+	int idx;
+	int ret;
+	int GettedFEC;
+
+	dev_dbg(&state->i2c->dev, "%s()\n", __func__);
+
+	ret = cx24120_readreg(state, CX24120_REG_FECMODE);
+	GettedFEC = ret & 0x3f;		/* Lower 6 bits */
+
+	dev_dbg(&state->i2c->dev, "%s: Get FEC: %d\n", __func__, GettedFEC);
+
+	for (idx = 0; idx < ARRAY_SIZE(modfec_lookup_table); idx++) {
+		if (modfec_lookup_table[idx].delsys != state->dcur.delsys)
+			continue;
+		if (modfec_lookup_table[idx].val != GettedFEC)
+			continue;
+
+		break;	/* found */
+	}
+
+	if (idx >= ARRAY_SIZE(modfec_lookup_table)) {
+		dev_dbg(&state->i2c->dev, "%s: Couldn't find fec!\n",
+			__func__);
+		return -EINVAL;
+	}
+
+	/* save values back to cache */
+	c->modulation = modfec_lookup_table[idx].mod;
+	c->fec_inner = modfec_lookup_table[idx].fec;
+	c->pilot = (ret & 0x80) ? PILOT_ON : PILOT_OFF;
+
+	dev_dbg(&state->i2c->dev,
+		"%s: mod(%d), fec(%d), pilot(%d)\n",
+		__func__,
+		c->modulation, c->fec_inner, c->pilot);
+
+	return 0;
+}
+
+
+/* Clock ratios lookup table
+ *
+ * Values obtained from much larger table in old driver
+ * which had numerous entries which would never match.
+ *
+ * There's probably some way of calculating these but I
+ * can't determine the pattern
+*/
+static struct cx24120_clock_ratios_table {
+	fe_delivery_system_t delsys;
+	fe_pilot_t pilot;
+	fe_modulation_t mod;
+	fe_code_rate_t fec;
+	u32 m_rat;
+	u32 n_rat;
+	u32 rate;
+} clock_ratios_table[] = {
+/*delsys	pilot		mod	fec		m_rat	n_rat	rate */
+{ SYS_DVBS2,	PILOT_OFF,	QPSK,	FEC_1_2,	273088,	254505,	274 },
+{ SYS_DVBS2,	PILOT_OFF,	QPSK,	FEC_3_5,	17272,	13395,	330 },
+{ SYS_DVBS2,	PILOT_OFF,	QPSK,	FEC_2_3,	24344,	16967,	367 },
+{ SYS_DVBS2,	PILOT_OFF,	QPSK,	FEC_3_4,	410788,	254505,	413 },
+{ SYS_DVBS2,	PILOT_OFF,	QPSK,	FEC_4_5,	438328,	254505,	440 },
+{ SYS_DVBS2,	PILOT_OFF,	QPSK,	FEC_5_6,	30464,	16967,	459 },
+{ SYS_DVBS2,	PILOT_OFF,	QPSK,	FEC_8_9,	487832,	254505,	490 },
+{ SYS_DVBS2,	PILOT_OFF,	QPSK,	FEC_9_10,	493952,	254505,	496 },
+{ SYS_DVBS2,	PILOT_OFF,	PSK_8,	FEC_3_5,	328168,	169905,	494 },
+{ SYS_DVBS2,	PILOT_OFF,	PSK_8,	FEC_2_3,	24344,	11327,	550 },
+{ SYS_DVBS2,	PILOT_OFF,	PSK_8,	FEC_3_4,	410788,	169905,	618 },
+{ SYS_DVBS2,	PILOT_OFF,	PSK_8,	FEC_5_6,	30464,	11327,	688 },
+{ SYS_DVBS2,	PILOT_OFF,	PSK_8,	FEC_8_9,	487832,	169905,	735 },
+{ SYS_DVBS2,	PILOT_OFF,	PSK_8,	FEC_9_10,	493952,	169905,	744 },
+{ SYS_DVBS2,	PILOT_ON,	QPSK,	FEC_1_2,	273088,	260709,	268 },
+{ SYS_DVBS2,	PILOT_ON,	QPSK,	FEC_3_5,	328168,	260709,	322 },
+{ SYS_DVBS2,	PILOT_ON,	QPSK,	FEC_2_3,	121720,	86903,	358 },
+{ SYS_DVBS2,	PILOT_ON,	QPSK,	FEC_3_4,	410788,	260709,	403 },
+{ SYS_DVBS2,	PILOT_ON,	QPSK,	FEC_4_5,	438328,	260709,	430 },
+{ SYS_DVBS2,	PILOT_ON,	QPSK,	FEC_5_6,	152320,	86903,	448 },
+{ SYS_DVBS2,	PILOT_ON,	QPSK,	FEC_8_9,	487832,	260709,	479 },
+{ SYS_DVBS2,	PILOT_ON,	QPSK,	FEC_9_10,	493952,	260709,	485 },
+{ SYS_DVBS2,	PILOT_ON,	PSK_8,	FEC_3_5,	328168,	173853,	483 },
+{ SYS_DVBS2,	PILOT_ON,	PSK_8,	FEC_2_3,	121720,	57951,	537 },
+{ SYS_DVBS2,	PILOT_ON,	PSK_8,	FEC_3_4,	410788,	173853,	604 },
+{ SYS_DVBS2,	PILOT_ON,	PSK_8,	FEC_5_6,	152320,	57951,	672 },
+{ SYS_DVBS2,	PILOT_ON,	PSK_8,	FEC_8_9,	487832,	173853,	718 },
+{ SYS_DVBS2,	PILOT_ON,	PSK_8,	FEC_9_10,	493952,	173853,	727 },
+{ SYS_DVBS,	PILOT_OFF,	QPSK,	FEC_1_2,	152592,	152592,	256 },
+{ SYS_DVBS,	PILOT_OFF,	QPSK,	FEC_2_3,	305184,	228888,	341 },
+{ SYS_DVBS,	PILOT_OFF,	QPSK,	FEC_3_4,	457776,	305184,	384 },
+{ SYS_DVBS,	PILOT_OFF,	QPSK,	FEC_5_6,	762960,	457776,	427 },
+{ SYS_DVBS,	PILOT_OFF,	QPSK,	FEC_7_8,	1068144, 610368, 448 },
+};
+
+
+/* Set clock ratio from lookup table */
+static void cx24120_set_clock_ratios(struct dvb_frontend *fe)
+{
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	struct cx24120_state *state = fe->demodulator_priv;
+	struct cx24120_cmd cmd;
+	int ret, idx;
+
+	/* Find fec, modulation, pilot */
+	ret = cx24120_get_fec(fe);
+	if (ret != 0)
+		return;
+
+	/* Find the clock ratios in the lookup table */
+	for (idx = 0; idx < ARRAY_SIZE(clock_ratios_table); idx++) {
+		if (clock_ratios_table[idx].delsys != state->dcur.delsys)
+			continue;
+		if (clock_ratios_table[idx].mod != c->modulation)
+			continue;
+		if (clock_ratios_table[idx].fec != c->fec_inner)
+			continue;
+		if (clock_ratios_table[idx].pilot != c->pilot)
+			continue;
+
+		break;		/* found */
+	}
+
+	if (idx >= ARRAY_SIZE(clock_ratios_table)) {
+		info("Clock ratio not found - data reception in danger\n");
+		return;
+	}
+
+
+	/* Read current values? */
+	cmd.id = CMD_CLOCK_READ;
+	cmd.len = 1;
+	cmd.arg[0] = 0x00;
+	ret = cx24120_message_sendrcv(state, &cmd, 6);
+	if (ret != 0)
+		return;
+	/* in cmd[0]-[5] - result */
+
+	dev_dbg(&state->i2c->dev,
+		"%s: m=%d, n=%d; idx: %d m=%d, n=%d, rate=%d\n",
+		__func__,
+		cmd.arg[2] | (cmd.arg[1] << 8) | (cmd.arg[0] << 16),
+		cmd.arg[5] | (cmd.arg[4] << 8) | (cmd.arg[3] << 16),
+		idx,
+		clock_ratios_table[idx].m_rat,
+		clock_ratios_table[idx].n_rat,
+		clock_ratios_table[idx].rate);
+
+
+
+	/* Set the clock */
+	cmd.id = CMD_CLOCK_SET;
+	cmd.len = 10;
+	cmd.arg[0] = 0;
+	cmd.arg[1] = 0x10;
+	cmd.arg[2] = (clock_ratios_table[idx].m_rat >> 16) & 0xff;
+	cmd.arg[3] = (clock_ratios_table[idx].m_rat >>  8) & 0xff;
+	cmd.arg[4] = (clock_ratios_table[idx].m_rat >>  0) & 0xff;
+	cmd.arg[5] = (clock_ratios_table[idx].n_rat >> 16) & 0xff;
+	cmd.arg[6] = (clock_ratios_table[idx].n_rat >>  8) & 0xff;
+	cmd.arg[7] = (clock_ratios_table[idx].n_rat >>  0) & 0xff;
+	cmd.arg[8] = (clock_ratios_table[idx].rate >> 8) & 0xff;
+	cmd.arg[9] = (clock_ratios_table[idx].rate >> 0) & 0xff;
+
+	cx24120_message_send(state, &cmd);
+
+}
+
+
+/* Set inversion value */
+static int cx24120_set_inversion(struct cx24120_state *state,
+	fe_spectral_inversion_t inversion)
+{
+	dev_dbg(&state->i2c->dev, "%s(%d)\n",
+		__func__, inversion);
+
+	switch (inversion) {
+	case INVERSION_OFF:
+		state->dnxt.inversion_val = 0x00;
+		break;
+	case INVERSION_ON:
+		state->dnxt.inversion_val = 0x04;
+		break;
+	case INVERSION_AUTO:
+		state->dnxt.inversion_val = 0x0c;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	state->dnxt.inversion = inversion;
+
+	return 0;
+}
+
+/* FEC lookup table for tuning
+ * Some DVB-S2 val's have been found by trial
+ * and error. Sofar it seems to match up with
+ * the contents of the REG_FECMODE after tuning
+ * The rest will probably be the same but would
+ * need testing.
+ * Anything not in the table will run with
+ * FEC_AUTO and take a while longer to tune in
+ * ( c.500ms instead of 30ms )
+ */
+static struct cx24120_modfec_table {
+	fe_delivery_system_t delsys;
+	fe_modulation_t mod;
+	fe_code_rate_t fec;
+	u8 val;
+} modfec_table[] = {
+/*delsys	mod	fec	 val */
+{ SYS_DVBS,	QPSK,	FEC_1_2, 0x2e },
+{ SYS_DVBS,	QPSK,	FEC_2_3, 0x2f },
+{ SYS_DVBS,	QPSK,	FEC_3_4, 0x30 },
+{ SYS_DVBS,	QPSK,	FEC_5_6, 0x31 },
+{ SYS_DVBS,	QPSK,	FEC_6_7, 0x32 },
+{ SYS_DVBS,	QPSK,	FEC_7_8, 0x33 },
+
+{ SYS_DVBS2,	QPSK,	FEC_3_4, 0x07 },
+
+{ SYS_DVBS2,	PSK_8,	FEC_2_3, 0x0d },
+{ SYS_DVBS2,	PSK_8,	FEC_3_4, 0x0e },
+};
+
+/* Set fec_val & fec_mask values from delsys, modulation & fec */
+static int cx24120_set_fec(struct cx24120_state *state,
+	fe_modulation_t mod, fe_code_rate_t fec)
+{
+	int idx;
+
+	dev_dbg(&state->i2c->dev,
+		"%s(0x%02x,0x%02x)\n", __func__, mod, fec);
+
+	state->dnxt.fec = fec;
+
+	/* Lookup fec_val from modfec table */
+	for (idx = 0; idx < ARRAY_SIZE(modfec_table); idx++) {
+		if (modfec_table[idx].delsys != state->dnxt.delsys)
+			continue;
+		if (modfec_table[idx].mod != mod)
+			continue;
+		if (modfec_table[idx].fec != fec)
+			continue;
+
+		/* found */
+		state->dnxt.fec_mask = 0x00;
+		state->dnxt.fec_val = modfec_table[idx].val;
+		return 0;
+	}
+
+
+	if (state->dnxt.delsys == SYS_DVBS2) {
+		/* DVBS2 auto is 0x00/0x00 */
+		state->dnxt.fec_mask = 0x00;
+		state->dnxt.fec_val  = 0x00;
+	} else {
+		/* Set DVB-S to auto */
+		state->dnxt.fec_val  = 0x2e;
+		state->dnxt.fec_mask = 0xac;
+	}
+
+	return 0;
+}
+
+
+/* Set pilot */
+static int cx24120_set_pilot(struct cx24120_state *state,
+		fe_pilot_t pilot) {
+
+	dev_dbg(&state->i2c->dev,
+		"%s(%d)\n", __func__, pilot);
+
+	/* Pilot only valid in DVBS2 */
+	if (state->dnxt.delsys != SYS_DVBS2) {
+		state->dnxt.pilot_val = CX24120_PILOT_OFF;
+		return 0;
+	}
+
+
+	switch (pilot) {
+	case PILOT_OFF:
+		state->dnxt.pilot_val = CX24120_PILOT_OFF;
+		break;
+	case PILOT_ON:
+		state->dnxt.pilot_val = CX24120_PILOT_ON;
+		break;
+	case PILOT_AUTO:
+	default:
+		state->dnxt.pilot_val = CX24120_PILOT_AUTO;
+	}
+
+	return 0;
+}
+
+/* Set symbol rate */
+static int cx24120_set_symbolrate(struct cx24120_state *state, u32 rate)
+{
+	dev_dbg(&state->i2c->dev, "%s(%d)\n",
+		__func__, rate);
+
+	state->dnxt.symbol_rate = rate;
+
+	/* Check symbol rate */
+	if (rate  > 31000000) {
+		state->dnxt.clkdiv  = (-(rate < 31000001) & 3) + 2;
+		state->dnxt.ratediv = (-(rate < 31000001) & 6) + 4;
+	} else {
+		state->dnxt.clkdiv  = 3;
+		state->dnxt.ratediv = 6;
+	}
+
+	return 0;
+}
+
+
+/* Overwrite the current tuning params, we are about to tune */
+static void cx24120_clone_params(struct dvb_frontend *fe)
+{
+	struct cx24120_state *state = fe->demodulator_priv;
+
+	state->dcur = state->dnxt;
+}
+
+
+/* Table of time to tune for different symrates */
+static struct cx24120_symrate_delay {
+	fe_delivery_system_t delsys;
+	u32 symrate;		/* Check for >= this symrate */
+	u32 delay;		/* Timeout in ms */
+} symrates_delay_table[] = {
+{ SYS_DVBS,	10000000,	400   },
+{ SYS_DVBS,	8000000,	2000  },
+{ SYS_DVBS,	6000000,	5000  },
+{ SYS_DVBS,	3000000,	10000 },
+{ SYS_DVBS,	0,		15000 },
+{ SYS_DVBS2,	10000000,	600   }, /* DVBS2 needs a little longer */
+{ SYS_DVBS2,	8000000,	2000  }, /* (so these might need bumping too) */
+{ SYS_DVBS2,	6000000,	5000  },
+{ SYS_DVBS2,	3000000,	10000 },
+{ SYS_DVBS2,	0,		15000 },
+};
+
+
+static int cx24120_set_frontend(struct dvb_frontend *fe)
+{
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	struct cx24120_state *state = fe->demodulator_priv;
+	struct cx24120_cmd cmd;
+	int ret;
+	int delay_cnt, sd_idx = 0;
+	fe_status_t status;
+
+	switch (c->delivery_system) {
+	case SYS_DVBS2:
+		dev_dbg(&state->i2c->dev, "%s() DVB-S2\n",
+			__func__);
+		break;
+	case SYS_DVBS:
+		dev_dbg(&state->i2c->dev, "%s() DVB-S\n",
+			__func__);
+		break;
+	default:
+		dev_dbg(&state->i2c->dev,
+			"%s() Delivery system(%d) not supported\n",
+			__func__, c->delivery_system);
+		ret = -EINVAL;
+		break;
+	}
+
+
+	state->dnxt.delsys = c->delivery_system;
+	state->dnxt.modulation = c->modulation;
+	state->dnxt.frequency = c->frequency;
+	state->dnxt.pilot = c->pilot;
+
+	ret = cx24120_set_inversion(state, c->inversion);
+	if (ret !=  0)
+		return ret;
+
+	ret = cx24120_set_fec(state, c->modulation, c->fec_inner);
+	if (ret !=  0)
+		return ret;
+
+	ret = cx24120_set_pilot(state, c->pilot);
+	if (ret != 0)
+		return ret;
+
+	ret = cx24120_set_symbolrate(state, c->symbol_rate);
+	if (ret !=  0)
+		return ret;
+
+
+	/* discard the 'current' tuning parameters and prepare to tune */
+	cx24120_clone_params(fe);
+
+	dev_dbg(&state->i2c->dev,
+		"%s: delsys      = %d\n", __func__, state->dcur.delsys);
+	dev_dbg(&state->i2c->dev,
+		"%s: modulation  = %d\n", __func__, state->dcur.modulation);
+	dev_dbg(&state->i2c->dev,
+		"%s: frequency   = %d\n", __func__, state->dcur.frequency);
+	dev_dbg(&state->i2c->dev,
+		"%s: pilot       = %d (val = 0x%02x)\n", __func__,
+		state->dcur.pilot, state->dcur.pilot_val);
+	dev_dbg(&state->i2c->dev,
+		"%s: symbol_rate = %d (clkdiv/ratediv = 0x%02x/0x%02x)\n",
+		 __func__, state->dcur.symbol_rate,
+		 state->dcur.clkdiv, state->dcur.ratediv);
+	dev_dbg(&state->i2c->dev,
+		"%s: FEC         = %d (mask/val = 0x%02x/0x%02x)\n", __func__,
+		state->dcur.fec, state->dcur.fec_mask, state->dcur.fec_val);
+	dev_dbg(&state->i2c->dev,
+		"%s: Inversion   = %d (val = 0x%02x)\n", __func__,
+		state->dcur.inversion, state->dcur.inversion_val);
+
+
+
+	/* Tune in */
+	cmd.id = CMD_TUNEREQUEST;
+	cmd.len = 15;
+	cmd.arg[0] = 0;
+	cmd.arg[1]  = (state->dcur.frequency & 0xff0000) >> 16;
+	cmd.arg[2]  = (state->dcur.frequency & 0x00ff00) >> 8;
+	cmd.arg[3]  = (state->dcur.frequency & 0x0000ff);
+	cmd.arg[4]  = ((state->dcur.symbol_rate/1000) & 0xff00) >> 8;
+	cmd.arg[5]  = ((state->dcur.symbol_rate/1000) & 0x00ff);
+	cmd.arg[6]  = state->dcur.inversion;
+	cmd.arg[7]  = state->dcur.fec_val | state->dcur.pilot_val;
+	cmd.arg[8]  = CX24120_SEARCH_RANGE_KHZ >> 8;
+	cmd.arg[9]  = CX24120_SEARCH_RANGE_KHZ & 0xff;
+	cmd.arg[10] = 0;		/* maybe rolloff? */
+	cmd.arg[11] = state->dcur.fec_mask;
+	cmd.arg[12] = state->dcur.ratediv;
+	cmd.arg[13] = state->dcur.clkdiv;
+	cmd.arg[14] = 0;
+
+
+	/* Send tune command */
+	ret = cx24120_message_send(state, &cmd);
+	if (ret != 0)
+		return ret;
+
+	/* Write symbol rate values */
+	ret = cx24120_writereg(state, CX24120_REG_CLKDIV, state->dcur.clkdiv);
+	ret = cx24120_readreg(state, CX24120_REG_RATEDIV);
+	ret &= 0xfffffff0;
+	ret |= state->dcur.ratediv;
+	ret = cx24120_writereg(state, CX24120_REG_RATEDIV, ret);
+
+	/* Default time to tune */
+	delay_cnt = 500;
+
+	/* Establish time to tune from symrates_delay_table */
+	for (sd_idx = 0; sd_idx < ARRAY_SIZE(symrates_delay_table); sd_idx++) {
+		if (state->dcur.delsys != symrates_delay_table[sd_idx].delsys)
+			continue;
+		if (c->symbol_rate < symrates_delay_table[sd_idx].symrate)
+			continue;
+
+		/* found */
+		delay_cnt = symrates_delay_table[sd_idx].delay;
+		dev_dbg(&state->i2c->dev, "%s: Found symrate delay = %d\n",
+			__func__, delay_cnt);
+		break;
+	}
+
+	/* Wait for tuning */
+	while (delay_cnt >= 0) {
+		cx24120_read_status(fe, &status);
+		if (status & FE_HAS_LOCK)
+			goto tuned;
+		msleep(20);
+		delay_cnt -= 20;
+	}
+
+
+	/* Fail to tune */
+	dev_dbg(&state->i2c->dev, "%s: Tuning failed\n",
+		__func__);
+
+	return -EINVAL;
+
+
+tuned:
+	dev_dbg(&state->i2c->dev, "%s: Tuning successful\n",
+		__func__);
+
+	/* Set clock ratios */
+	cx24120_set_clock_ratios(fe);
+
+	/* Old driver would do a msleep(200) here */
+
+	/* Renable mpeg output */
+	if (!state->mpeg_enabled)
+		cx24120_msg_mpeg_output_global_config(state, 1);
+
+	return 0;
+}
+
+
+/* Calculate vco from config */
+static u64 cx24120_calculate_vco(struct cx24120_state *state)
+{
+	u32 vco;
+	u64 inv_vco, res, xxyyzz;
+	u32 xtal_khz = state->config->xtal_khz;
+
+	xxyyzz = 0x400000000ULL;
+	vco = xtal_khz * 10 * 4;
+	inv_vco = xxyyzz / vco;
+	res = xxyyzz % vco;
+
+	if (inv_vco > xtal_khz * 10 * 2)
+		++inv_vco;
+
+	dev_dbg(&state->i2c->dev,
+		"%s: xtal=%d, vco=%d, inv_vco=%lld, res=%lld\n",
+		__func__, xtal_khz, vco, inv_vco, res);
+
+	return inv_vco;
+}
+
+
+int cx24120_init(struct dvb_frontend *fe)
+{
+	const struct firmware *fw;
+	struct cx24120_state *state = fe->demodulator_priv;
+	struct cx24120_cmd cmd;
+	u8 ret, ret_EA, reg1;
+	u64 inv_vco;
+	int reset_result;
+
+	int i;
+	unsigned char vers[4];
+
+	if (state->cold_init)
+		return 0;
+
+	/* ???? */
+	ret = cx24120_writereg(state, 0xea, 0x00);
+	ret = cx24120_test_rom(state);
+	ret = cx24120_readreg(state, 0xfb) & 0xfe;
+	ret = cx24120_writereg(state, 0xfb, ret);
+	ret = cx24120_readreg(state, 0xfc) & 0xfe;
+	ret = cx24120_writereg(state, 0xfc, ret);
+	ret = cx24120_writereg(state, 0xc3, 0x04);
+	ret = cx24120_writereg(state, 0xc4, 0x04);
+	ret = cx24120_writereg(state, 0xce, 0x00);
+	ret = cx24120_writereg(state, 0xcf, 0x00);
+	ret_EA = cx24120_readreg(state, 0xea) & 0xfe;
+	ret = cx24120_writereg(state, 0xea, ret_EA);
+	ret = cx24120_writereg(state, 0xeb, 0x0c);
+	ret = cx24120_writereg(state, 0xec, 0x06);
+	ret = cx24120_writereg(state, 0xed, 0x05);
+	ret = cx24120_writereg(state, 0xee, 0x03);
+	ret = cx24120_writereg(state, 0xef, 0x05);
+	ret = cx24120_writereg(state, 0xf3, 0x03);
+	ret = cx24120_writereg(state, 0xf4, 0x44);
+
+	for (reg1 = 0xf0; reg1 < 0xf3; reg1++) {
+		cx24120_writereg(state, reg1, 0x04);
+		cx24120_writereg(state, reg1 - 10, 0x02);
+	}
+
+	ret = cx24120_writereg(state, 0xea, (ret_EA | 0x01));
+	for (reg1 = 0xc5; reg1 < 0xcb; reg1 += 2) {
+		ret = cx24120_writereg(state, reg1, 0x00);
+		ret = cx24120_writereg(state, reg1 + 1, 0x00);
+	}
+
+	ret = cx24120_writereg(state, 0xe4, 0x03);
+	ret = cx24120_writereg(state, 0xeb, 0x0a);
+
+	dev_dbg(&state->i2c->dev,
+		"%s: Requesting firmware (%s) to download...\n",
+		__func__, CX24120_FIRMWARE);
+
+	ret = state->config->request_firmware(fe, &fw, CX24120_FIRMWARE);
+	if (ret) {
+		err("Could not load firmware (%s): %d\n",
+			CX24120_FIRMWARE, ret);
+		return ret;
+	}
+
+	dev_dbg(&state->i2c->dev,
+		"%s: Firmware found, size %d bytes (%02x %02x .. %02x %02x)\n",
+		__func__,
+		(int)fw->size,			/* firmware_size in bytes */
+		fw->data[0],			/* fw 1st byte */
+		fw->data[1],			/* fw 2d byte */
+		fw->data[fw->size - 2],		/* fw before last byte */
+		fw->data[fw->size - 1]);	/* fw last byte */
+
+	ret = cx24120_test_rom(state);
+	ret = cx24120_readreg(state, 0xfb) & 0xfe;
+	ret = cx24120_writereg(state, 0xfb, ret);
+	ret = cx24120_writereg(state, 0xe0, 0x76);
+	ret = cx24120_writereg(state, 0xf7, 0x81);
+	ret = cx24120_writereg(state, 0xf8, 0x00);
+	ret = cx24120_writereg(state, 0xf9, 0x00);
+	ret = cx24120_writeregN(state, 0xfa, fw->data, (fw->size - 1), 0x00);
+	ret = cx24120_writereg(state, 0xf7, 0xc0);
+	ret = cx24120_writereg(state, 0xe0, 0x00);
+	ret = (fw->size - 2) & 0x00ff;
+	ret = cx24120_writereg(state, 0xf8, ret);
+	ret = ((fw->size - 2) >> 8) & 0x00ff;
+	ret = cx24120_writereg(state, 0xf9, ret);
+	ret = cx24120_writereg(state, 0xf7, 0x00);
+	ret = cx24120_writereg(state, 0xdc, 0x00);
+	ret = cx24120_writereg(state, 0xdc, 0x07);
+	msleep(500);
+
+	/* Check final byte matches final byte of firmware */
+	ret = cx24120_readreg(state, 0xe1);
+	if (ret == fw->data[fw->size - 1]) {
+		dev_dbg(&state->i2c->dev,
+			"%s: Firmware uploaded successfully\n",
+			__func__);
+		reset_result = 0;
+	} else {
+		err("Firmware upload failed. Last byte returned=0x%x\n", ret);
+		reset_result = -EREMOTEIO;
+	}
+	ret = cx24120_writereg(state, 0xdc, 0x00);
+	release_firmware(fw);
+	if (reset_result != 0)
+		return reset_result;
+
+
+	/* Start tuner */
+	cmd.id = CMD_START_TUNER;
+	cmd.len = 3;
+	cmd.arg[0] = 0x00;
+	cmd.arg[1] = 0x00;
+	cmd.arg[2] = 0x00;
+
+	if (cx24120_message_send(state, &cmd) != 0) {
+		err("Error tuner start! :(\n");
+		return -EREMOTEIO;
+	}
+
+	/* Set VCO */
+	inv_vco = cx24120_calculate_vco(state);
+
+	cmd.id = CMD_VCO_SET;
+	cmd.len = 12;
+	cmd.arg[0] = 0x06;
+	cmd.arg[1] = 0x2b;
+	cmd.arg[2] = 0xd8;
+	cmd.arg[3] = (inv_vco >> 8) & 0xff;
+	cmd.arg[4] = (inv_vco) & 0xff;
+	cmd.arg[5] = 0x03;
+	cmd.arg[6] = 0x9d;
+	cmd.arg[7] = 0xfc;
+	cmd.arg[8] = 0x06;
+	cmd.arg[9] = 0x03;
+	cmd.arg[10] = 0x27;
+	cmd.arg[11] = 0x7f;
+
+	if (cx24120_message_send(state, &cmd)) {
+		err("Error set VCO! :(\n");
+		return -EREMOTEIO;
+	}
+
+
+	/* set bandwidth */
+	cmd.id = CMD_BANDWIDTH;
+	cmd.len = 12;
+	cmd.arg[0] = 0x00;
+	cmd.arg[1] = 0x00;
+	cmd.arg[2] = 0x00;
+	cmd.arg[3] = 0x00;
+	cmd.arg[4] = 0x05;
+	cmd.arg[5] = 0x02;
+	cmd.arg[6] = 0x02;
+	cmd.arg[7] = 0x00;
+	cmd.arg[8] = 0x05;
+	cmd.arg[9] = 0x02;
+	cmd.arg[10] = 0x02;
+	cmd.arg[11] = 0x00;
+
+	if (cx24120_message_send(state, &cmd)) {
+		err("Error set bandwidth!\n");
+		return -EREMOTEIO;
+	}
+
+	ret = cx24120_readreg(state, 0xba);
+	if (ret > 3) {
+		dev_dbg(&state->i2c->dev, "%s: Reset-readreg 0xba: %x\n",
+			__func__, ret);
+		err("Error initialising tuner!\n");
+		return -EREMOTEIO;
+	}
+
+	dev_dbg(&state->i2c->dev, "%s: Tuner initialised correctly.\n",
+			__func__);
+
+
+	/* Initialise mpeg outputs */
+	ret = cx24120_writereg(state, 0xeb, 0x0a);
+	if (cx24120_msg_mpeg_output_global_config(state, 0) ||
+	    cx24120_msg_mpeg_output_config(state, 0) ||
+	    cx24120_msg_mpeg_output_config(state, 1) ||
+	    cx24120_msg_mpeg_output_config(state, 2)) {
+		err("Error initialising mpeg output. :(\n");
+		return -EREMOTEIO;
+	}
+
+
+	/* ???? */
+	cmd.id = CMD_TUNER_INIT;
+	cmd.len = 3;
+	cmd.arg[0] = 0x00;
+	cmd.arg[1] = 0x10;
+	cmd.arg[2] = 0x10;
+	if (cx24120_message_send(state, &cmd)) {
+		err("Error sending final init message. :(\n");
+		return -EREMOTEIO;
+	}
+
+
+	/* Firmware CMD 35: Get firmware version */
+	cmd.id = CMD_FWVERSION;
+	cmd.len = 1;
+	for (i = 0; i < 4; i++) {
+		cmd.arg[0] = i;
+		ret = cx24120_message_send(state, &cmd);
+		if (ret != 0)
+			return ret;
+		vers[i] = cx24120_readreg(state, CX24120_REG_MAILBOX);
+	}
+	info("FW version %i.%i.%i.%i\n", vers[0], vers[1], vers[2], vers[3]);
+
+
+	state->cold_init = 1;
+	return 0;
+}
+
+
+static int cx24120_tune(struct dvb_frontend *fe, bool re_tune,
+	unsigned int mode_flags, unsigned int *delay, fe_status_t *status)
+{
+	struct cx24120_state *state = fe->demodulator_priv;
+	int ret;
+
+	dev_dbg(&state->i2c->dev, "%s(%d)\n", __func__, re_tune);
+
+	/* TODO: Do we need to set delay? */
+
+	if (re_tune) {
+		ret = cx24120_set_frontend(fe);
+		if (ret)
+			return ret;
+	}
+
+	return cx24120_read_status(fe, status);
+}
+
+
+
+static int cx24120_get_algo(struct dvb_frontend *fe)
+{
+	return DVBFE_ALGO_HW;
+}
+
+
+static int cx24120_sleep(struct dvb_frontend *fe)
+{
+	return 0;
+}
+
+
+/*static int cx24120_wakeup(struct dvb_frontend *fe)
+ * {
+ *   return 0;
+ * }
+*/
+
+
+static int cx24120_get_frontend(struct dvb_frontend *fe)
+{
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	struct cx24120_state *state = fe->demodulator_priv;
+	u8 freq1, freq2, freq3;
+
+	dev_dbg(&state->i2c->dev, "%s()", __func__);
+
+	/* don't return empty data if we're not tuned in */
+	if (state->mpeg_enabled)
+		return 0;
+
+	/* Get frequency */
+	freq1 = cx24120_readreg(state, CX24120_REG_FREQ1);
+	freq2 = cx24120_readreg(state, CX24120_REG_FREQ2);
+	freq3 = cx24120_readreg(state, CX24120_REG_FREQ3);
+	c->frequency = (freq3 << 16) | (freq2 << 8) | freq1;
+	dev_dbg(&state->i2c->dev, "%s frequency = %d\n", __func__,
+		c->frequency);
+
+	/* Get modulation, fec, pilot */
+	cx24120_get_fec(fe);
+
+	return 0;
+}
+
+
+static void cx24120_release(struct dvb_frontend *fe)
+{
+	struct cx24120_state *state = fe->demodulator_priv;
+
+	dev_dbg(&state->i2c->dev, "%s: Clear state structure\n", __func__);
+	kfree(state);
+}
+
+
+static int cx24120_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)
+{
+	struct cx24120_state *state = fe->demodulator_priv;
+
+	*ucblocks = (cx24120_readreg(state, CX24120_REG_UCB_H) << 8) |
+		     cx24120_readreg(state, CX24120_REG_UCB_L);
+
+	dev_dbg(&state->i2c->dev, "%s: Blocks = %d\n",
+			__func__, *ucblocks);
+	return 0;
+}
+
+
+static struct dvb_frontend_ops cx24120_ops = {
+	.delsys = { SYS_DVBS, SYS_DVBS2 },
+	.info = {
+		.name = "Conexant CX24120/CX24118",
+		.frequency_min = 950000,
+		.frequency_max = 2150000,
+		.frequency_stepsize = 1011, /* kHz for QPSK frontends */
+		.frequency_tolerance = 5000,
+		.symbol_rate_min = 1000000,
+		.symbol_rate_max = 45000000,
+		.caps =	FE_CAN_INVERSION_AUTO |
+			FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |
+			FE_CAN_FEC_4_5 | FE_CAN_FEC_5_6 | FE_CAN_FEC_6_7 |
+			FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |
+			FE_CAN_2G_MODULATION |
+			FE_CAN_QPSK | FE_CAN_RECOVER
+	},
+	.release =			cx24120_release,
+
+	.init =				cx24120_init,
+	.sleep =			cx24120_sleep,
+
+	.tune =				cx24120_tune,
+	.get_frontend_algo =		cx24120_get_algo,
+	.set_frontend =			cx24120_set_frontend,
+
+	.get_frontend =			cx24120_get_frontend,
+	.read_status =			cx24120_read_status,
+	.read_ber =			cx24120_read_ber,
+	.read_signal_strength =		cx24120_read_signal_strength,
+	.read_snr =			cx24120_read_snr,
+	.read_ucblocks =		cx24120_read_ucblocks,
+
+	.diseqc_send_master_cmd =	cx24120_send_diseqc_msg,
+
+	.diseqc_send_burst =		cx24120_diseqc_send_burst,
+	.set_tone =			cx24120_set_tone,
+	.set_voltage =			cx24120_set_voltage,
+};
+
+MODULE_DESCRIPTION("DVB Frontend module for Conexant CX24120/CX24118 hardware");
+MODULE_AUTHOR("Jemma Denson");
+MODULE_LICENSE("GPL");
