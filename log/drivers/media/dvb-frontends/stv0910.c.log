commit 868c9a17e22c89d241f12501e21ae4f104ce036c
Author: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
Date:   Mon Feb 18 14:28:55 2019 -0500

    media: dvb-frontends: fix several typos
    
    Use codespell to fix lots of typos over frontends.
    
    Manually verified to avoid false-positives.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/dvb-frontends/stv0910.c b/drivers/media/dvb-frontends/stv0910.c
index fc2440d8af36..68d7c7b41071 100644
--- a/drivers/media/dvb-frontends/stv0910.c
+++ b/drivers/media/dvb-frontends/stv0910.c
@@ -1238,7 +1238,7 @@ static int gate_ctrl(struct dvb_frontend *fe, int enable)
 	 * mutex_lock note: Concurrent I2C gate bus accesses must be
 	 * prevented (STV0910 = dual demod on a single IC with a single I2C
 	 * gate/bus, and two tuners attached), similar to most (if not all)
-	 * other I2C host interfaces/busses.
+	 * other I2C host interfaces/buses.
 	 *
 	 * enable=1 (open I2C gate) will grab the lock
 	 * enable=0 (close I2C gate) releases the lock
@@ -1500,7 +1500,7 @@ static int read_status(struct dvb_frontend *fe, enum fe_status *status)
 				  RSTV0910_P2_FBERCPT4 + state->regoff, 0x00);
 			/*
 			 * Reset the packet Error counter2 (and Set it to
-			 * infinit error count mode)
+			 * infinite error count mode)
 			 */
 			write_reg(state,
 				  RSTV0910_P2_ERRCTRL2 + state->regoff, 0xc1);

commit bbeae4304bd9f63191cc1476f136e9fe98ea30a1
Author: Daniel Scheller <d.scheller@gmx.net>
Date:   Tue Jun 19 14:50:14 2018 -0400

    media: dvb-frontends/stv0910: add SPDX license identifier
    
    As it is clear that the driver is licensed under the terms of GPLv2-only
    by now, add a matching SPDX license identifier to all driver files.
    
    Cc: Ralph Metzler <rjkm@metzlerbros.de>
    Cc: Manfred Voelkel <mvoelkel@DigitalDevices.de>
    Signed-off-by: Daniel Scheller <d.scheller@gmx.net>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/dvb-frontends/stv0910.c b/drivers/media/dvb-frontends/stv0910.c
index a94221683fb6..fc2440d8af36 100644
--- a/drivers/media/dvb-frontends/stv0910.c
+++ b/drivers/media/dvb-frontends/stv0910.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Driver for the ST STV0910 DVB-S/S2 demodulator.
  *

commit 229b6ea6894be4714e49dbcb0e2f391ea7d20d02
Author: Daniel Scheller <d.scheller@gmx.net>
Date:   Tue Jun 19 14:50:08 2018 -0400

    media: mxl5xx/stv0910/stv6111/ddbridge: fix MODULE_LICENSE to 'GPL v2'
    
    In commit 3db30defab4b ("use correct MODULE_LINCESE for GPL v2 only
    according to notice in header") in the upstream repository for the
    mentioned four drivers at https://github.com/DigitalDevices/dddvb.git
    (plus a few more which aren't part of the mainline kernel tree), the
    MODULE_LICENSE was fixed to "GPL v2" and are now in sync with the
    GPL copyright boilerplate. Apply this change to the kernel tree
    drivers as well.
    
    Cc: Ralph Metzler <rjkm@metzlerbros.de>
    Cc: Manfred Voelkel <mvoelkel@DigitalDevices.de>
    Signed-off-by: Daniel Scheller <d.scheller@gmx.net>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/dvb-frontends/stv0910.c b/drivers/media/dvb-frontends/stv0910.c
index 4c86073f1a8d..a94221683fb6 100644
--- a/drivers/media/dvb-frontends/stv0910.c
+++ b/drivers/media/dvb-frontends/stv0910.c
@@ -1839,4 +1839,4 @@ EXPORT_SYMBOL_GPL(stv0910_attach);
 
 MODULE_DESCRIPTION("ST STV0910 multistandard frontend driver");
 MODULE_AUTHOR("Ralph and Marcus Metzler, Manfred Voelkel");
-MODULE_LICENSE("GPL");
+MODULE_LICENSE("GPL v2");

commit f1b1eabff0eb3fc46b06668de8174c0f23b271fd
Author: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
Date:   Thu Jul 5 18:59:36 2018 -0400

    media: dvb: represent min/max/step/tolerance freqs in Hz
    
    Right now, satellite frontend drivers specify frequencies in kHz,
    while terrestrial/cable ones specify in Hz. That's confusing
    for developers.
    
    However, the main problem is that universal frontends capable
    of handling both satellite and non-satelite delivery systems
    are appearing. We end by needing to hack the drivers in
    order to support such hybrid frontends.
    
    So, convert everything to specify frontend frequencies in Hz.
    
    Tested-by: Katsuhiro Suzuki <suzuki.katsuhiro@socionext.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/dvb-frontends/stv0910.c b/drivers/media/dvb-frontends/stv0910.c
index 91b21eb59531..4c86073f1a8d 100644
--- a/drivers/media/dvb-frontends/stv0910.c
+++ b/drivers/media/dvb-frontends/stv0910.c
@@ -1724,10 +1724,8 @@ static const struct dvb_frontend_ops stv0910_ops = {
 	.delsys = { SYS_DVBS, SYS_DVBS2, SYS_DSS },
 	.info = {
 		.name			= "ST STV0910",
-		.frequency_min		= 950000,
-		.frequency_max		= 2150000,
-		.frequency_stepsize	= 0,
-		.frequency_tolerance	= 0,
+		.frequency_min_hz	=  950 * MHz,
+		.frequency_max_hz	= 2150 * MHz,
 		.symbol_rate_min	= 100000,
 		.symbol_rate_max	= 70000000,
 		.caps			= FE_CAN_INVERSION_AUTO |

commit f9dc3af8212b626a62103e7ba8cb3c84482334b8
Author: Daniel Scheller <d.scheller@gmx.net>
Date:   Sat Jun 23 11:35:58 2018 -0400

    media: dvb-frontends/stv0910: cast the BER denominator shift exp to ULL
    
    To avoid miscalculations related to the BER denominator, the shift
    expression needs to be casted as ULL.
    
    Picked up from the upstream dddvb GIT.
    
    Signed-off-by: Daniel Scheller <d.scheller@gmx.net>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/dvb-frontends/stv0910.c b/drivers/media/dvb-frontends/stv0910.c
index 41444fa1c0bb..91b21eb59531 100644
--- a/drivers/media/dvb-frontends/stv0910.c
+++ b/drivers/media/dvb-frontends/stv0910.c
@@ -682,8 +682,8 @@ static int get_bit_error_rate_s(struct stv *state, u32 *bernumerator,
 		return -EINVAL;
 
 	if ((regs[0] & 0x80) == 0) {
-		state->last_berdenominator = 1 << ((state->berscale * 2) +
-						  10 + 3);
+		state->last_berdenominator = 1ULL << ((state->berscale * 2) +
+						     10 + 3);
 		state->last_bernumerator = ((u32)(regs[0] & 0x7F) << 16) |
 			((u32)regs[1] << 8) | regs[2];
 		if (state->last_bernumerator < 256 && state->berscale < 6) {

commit 7069018ec3afd532ad2043d58ee87821a03d8df4
Author: Daniel Scheller <d.scheller@gmx.net>
Date:   Wed May 9 16:08:02 2018 -0400

    media: dvb-frontends/stv0910: make TS speed configurable
    
    Add a tsspeed config option to struct stv0910_cfg which can be used by
    users of the driver to set the (parallel) TS speed (higher speeds enable
    support for higher bitrate transponders). If tsspeed isn't set in the
    config, it'll default to a sane value.
    
    This commit also updates the two consumers of the stv0910 driver (ngene
    and ddbridge) to have a default tsspeed in their stv0910_cfg templates.
    
    Signed-off-by: Daniel Scheller <d.scheller@gmx.net>
    Tested-by: Richard Scobie <rascobie@slingshot.co.nz>
    Tested-by: Helmut Auer <post@helmutauer.de>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/dvb-frontends/stv0910.c b/drivers/media/dvb-frontends/stv0910.c
index 7e9b016b3b28..41444fa1c0bb 100644
--- a/drivers/media/dvb-frontends/stv0910.c
+++ b/drivers/media/dvb-frontends/stv0910.c
@@ -1200,7 +1200,6 @@ static int probe(struct stv *state)
 	write_reg(state, RSTV0910_P1_TSCFGM, 0xC0); /* Manual speed */
 	write_reg(state, RSTV0910_P1_TSCFGL, 0x20);
 
-	/* Speed = 67.5 MHz */
 	write_reg(state, RSTV0910_P1_TSSPEED, state->tsspeed);
 
 	write_reg(state, RSTV0910_P2_TSCFGH, state->tscfgh | 0x01);
@@ -1208,7 +1207,6 @@ static int probe(struct stv *state)
 	write_reg(state, RSTV0910_P2_TSCFGM, 0xC0); /* Manual speed */
 	write_reg(state, RSTV0910_P2_TSCFGL, 0x20);
 
-	/* Speed = 67.5 MHz */
 	write_reg(state, RSTV0910_P2_TSSPEED, state->tsspeed);
 
 	/* Reset stream merger */
@@ -1790,7 +1788,8 @@ struct dvb_frontend *stv0910_attach(struct i2c_adapter *i2c,
 	state->tscfgh = 0x20 | (cfg->parallel ? 0 : 0x40);
 	state->tsgeneral = (cfg->parallel == 2) ? 0x02 : 0x00;
 	state->i2crpt = 0x0A | ((cfg->rptlvl & 0x07) << 4);
-	state->tsspeed = 0x28;
+	/* use safe tsspeed value if unspecified through stv0910_cfg */
+	state->tsspeed = (cfg->tsspeed ? cfg->tsspeed : 0x28);
 	state->nr = nr;
 	state->regoff = state->nr ? 0 : 0x200;
 	state->search_range = 16000000;

commit 8d718e5376c602dfd41b599dcc2a7b1be07c7b6b
Author: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
Date:   Tue Apr 24 09:19:18 2018 -0400

    media: frontends: fix ops get_algo()'s return type
    
    The method dvb_frontend_ops::get_frontend_algo() is defined as
    returning an 'enum dvbfe_algo', but the implementation in this
    driver returns an 'int'.
    
    Fix this by returning 'enum dvbfe_algo' on drivers.
    
    [mchehab+samsung@kernel.org: merge similar patches and patch
     ddbridge-mci.c the same way]
    Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/dvb-frontends/stv0910.c b/drivers/media/dvb-frontends/stv0910.c
index 1d96ae9f9f6e..7e9b016b3b28 100644
--- a/drivers/media/dvb-frontends/stv0910.c
+++ b/drivers/media/dvb-frontends/stv0910.c
@@ -1639,7 +1639,7 @@ static int tune(struct dvb_frontend *fe, bool re_tune,
 	return 0;
 }
 
-static int get_algo(struct dvb_frontend *fe)
+static enum dvbfe_algo get_algo(struct dvb_frontend *fe)
 {
 	return DVBFE_ALGO_HW;
 }

commit cea6d2392fde9eec176538cbaee476d76e591028
Author: Daniel Scheller <d.scheller@gmx.net>
Date:   Mon Apr 9 12:47:35 2018 -0400

    media: dvb-frontends/stv0910: fix CNR reporting in read_snr()
    
    The CNR value determined in read_snr() is reported via the wrong variable.
    It uses FE_SCALE_DECIBEL, which implies the value to be reported in svalue
    instead of uvalue. Fix this accordingly.
    
    Picked up from the upstream dddvb-0.9.33 release.
    
    Signed-off-by: Daniel Scheller <d.scheller@gmx.net>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/dvb-frontends/stv0910.c b/drivers/media/dvb-frontends/stv0910.c
index f5b5ce971c0c..1d96ae9f9f6e 100644
--- a/drivers/media/dvb-frontends/stv0910.c
+++ b/drivers/media/dvb-frontends/stv0910.c
@@ -1326,7 +1326,7 @@ static int read_snr(struct dvb_frontend *fe)
 
 	if (!get_signal_to_noise(state, &snrval)) {
 		p->cnr.stat[0].scale = FE_SCALE_DECIBEL;
-		p->cnr.stat[0].uvalue = 100 * snrval; /* fix scale */
+		p->cnr.stat[0].svalue = 100 * snrval; /* fix scale */
 	} else {
 		p->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
 	}

commit e2c53c8d0b29a161c72c631b6b2a8654b9823151
Author: Daniel Scheller <d.scheller@gmx.net>
Date:   Mon Apr 9 12:47:34 2018 -0400

    media: dvb-frontends/stv0910: add init values for TSINSDELM/L
    
    The TSINSDEL registers were lacking initialisation in the stv0910 demod
    driver. Initialise them (both demods) in the probe() function.
    
    Picked up from the upstream dddvb-0.9.33 release.
    
    Signed-off-by: Daniel Scheller <d.scheller@gmx.net>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/dvb-frontends/stv0910.c b/drivers/media/dvb-frontends/stv0910.c
index 52355c14fd64..f5b5ce971c0c 100644
--- a/drivers/media/dvb-frontends/stv0910.c
+++ b/drivers/media/dvb-frontends/stv0910.c
@@ -1220,6 +1220,12 @@ static int probe(struct stv *state)
 	write_reg(state, RSTV0910_P1_I2CRPT, state->i2crpt);
 	write_reg(state, RSTV0910_P2_I2CRPT, state->i2crpt);
 
+	write_reg(state, RSTV0910_P1_TSINSDELM, 0x17);
+	write_reg(state, RSTV0910_P1_TSINSDELL, 0xff);
+
+	write_reg(state, RSTV0910_P2_TSINSDELM, 0x17);
+	write_reg(state, RSTV0910_P2_TSINSDELL, 0xff);
+
 	init_diseqc(state);
 	return 0;
 }

commit da2cf18ff883b6130b1a6e4a3e9402abcb9f5bc0
Author: Daniel Scheller <d.scheller@gmx.net>
Date:   Fri Feb 9 13:22:49 2018 -0500

    media: dvb-frontends/stv0910: rework and fix DiSEqC send
    
    Rework both DiSEqC send functions (send_master_cmd() and send_burst()) to
    utilise the new SET_REG() and SET_FIELD() macros. Esp. due to SET_FIELD(),
    this makes sure that not all bits (with unrelated purposes) are always
    rewritten, but only those needed for sending DiSEqC commands. In
    send_burst(), this makes sure that DISEQC_MODE isn't changed from 3 to 2
    inbetween when sending SEC_MINI_A. Also, change both functions to write
    DISEQC_MODE first before setting DIS_PRECHARGE. This makes diseqc control
    work more reliable for "fullblown" DiSEqC strings in VDR's diseqc.conf in
    combination with certain multiswitches.
    
    Fixes: 448461af0e19 ("media: dvb-frontends/stv0910: implement diseqc_send_burst")
    
    Reported-by: Helmut Auer <post@helmutauer.de>
    Cc: Ralph Metzler <rjkm@metzlerbros.de>
    Signed-off-by: Daniel Scheller <d.scheller@gmx.net>
    Tested-by: Helmut Auer <post@helmutauer.de>
    Tested-by: Richard Scobie <rascobie@slingshot.co.nz>
    Tested-by: Dietmar Spingler <d_spingler@freenet.de>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/stv0910.c b/drivers/media/dvb-frontends/stv0910.c
index a2f7c0c1587f..52355c14fd64 100644
--- a/drivers/media/dvb-frontends/stv0910.c
+++ b/drivers/media/dvb-frontends/stv0910.c
@@ -1673,15 +1673,15 @@ static int send_master_cmd(struct dvb_frontend *fe,
 			   struct dvb_diseqc_master_cmd *cmd)
 {
 	struct stv *state = fe->demodulator_priv;
-	u16 offs = state->nr ? 0x40 : 0;
 	int i;
 
-	write_reg(state, RSTV0910_P1_DISTXCFG + offs, 0x3E);
+	SET_FIELD(DISEQC_MODE, 2);
+	SET_FIELD(DIS_PRECHARGE, 1);
 	for (i = 0; i < cmd->msg_len; i++) {
 		wait_dis(state, 0x40, 0x00);
-		write_reg(state, RSTV0910_P1_DISTXFIFO + offs, cmd->msg[i]);
+		SET_REG(DISTXFIFO, cmd->msg[i]);
 	}
-	write_reg(state, RSTV0910_P1_DISTXCFG + offs, 0x3A);
+	SET_FIELD(DIS_PRECHARGE, 0);
 	wait_dis(state, 0x20, 0x20);
 	return 0;
 }
@@ -1689,19 +1689,20 @@ static int send_master_cmd(struct dvb_frontend *fe,
 static int send_burst(struct dvb_frontend *fe, enum fe_sec_mini_cmd burst)
 {
 	struct stv *state = fe->demodulator_priv;
-	u16 offs = state->nr ? 0x40 : 0;
 	u8 value;
 
 	if (burst == SEC_MINI_A) {
-		write_reg(state, RSTV0910_P1_DISTXCFG + offs, 0x3F);
+		SET_FIELD(DISEQC_MODE, 3);
 		value = 0x00;
 	} else {
-		write_reg(state, RSTV0910_P1_DISTXCFG + offs, 0x3E);
+		SET_FIELD(DISEQC_MODE, 2);
 		value = 0xFF;
 	}
+
+	SET_FIELD(DIS_PRECHARGE, 1);
 	wait_dis(state, 0x40, 0x00);
-	write_reg(state, RSTV0910_P1_DISTXFIFO + offs, value);
-	write_reg(state, RSTV0910_P1_DISTXCFG + offs, 0x3A);
+	SET_REG(DISTXFIFO, value);
+	SET_FIELD(DIS_PRECHARGE, 0);
 	wait_dis(state, 0x20, 0x20);
 
 	return 0;

commit 6392bc2e6cd9651f98abf55c4ccaa812d3e60c17
Author: Daniel Scheller <d.scheller@gmx.net>
Date:   Tue Dec 26 18:37:59 2017 -0500

    media: dvb-frontends/stv0910: cleanup init_search_param() and enable PLS
    
    Cleanup the mess in init_search_param() by utilising the new register
    access macros and functions. And while at it, move the ISI and PLS setup
    into separate functions, and pass the new scrambling_sequence_index (aka.
    physical layer scrambling) value to set_pls.
    
    Picked up from the dddvb upstream, adapted to the different naming of the
    pls property (pls vs. scrambling_sequence_index).
    
    Cc: Ralph Metzler <rjkm@metzlerbros.de>
    Signed-off-by: Daniel Scheller <d.scheller@gmx.net>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/stv0910.c b/drivers/media/dvb-frontends/stv0910.c
index 1a3b65e43a85..a2f7c0c1587f 100644
--- a/drivers/media/dvb-frontends/stv0910.c
+++ b/drivers/media/dvb-frontends/stv0910.c
@@ -194,7 +194,7 @@ static int write_shared_reg(struct stv *state, u16 reg, u8 mask, u8 val)
 	return status;
 }
 
-static int __maybe_unused write_field(struct stv *state, u32 field, u8 val)
+static int write_field(struct stv *state, u32 field, u8 val)
 {
 	int status;
 	u8 shift, mask, old, new;
@@ -880,45 +880,60 @@ static int stop(struct stv *state)
 	return 0;
 }
 
-static int init_search_param(struct stv *state)
+static void set_pls(struct stv *state, u32 pls_code)
 {
-	u8 tmp;
-
-	read_reg(state, RSTV0910_P2_PDELCTRL1 + state->regoff, &tmp);
-	tmp |= 0x20; /* Filter_en (no effect if SIS=non-MIS */
-	write_reg(state, RSTV0910_P2_PDELCTRL1 + state->regoff, tmp);
-
-	read_reg(state, RSTV0910_P2_PDELCTRL2 + state->regoff, &tmp);
-	tmp &= ~0x02; /* frame mode = 0 */
-	write_reg(state, RSTV0910_P2_PDELCTRL2 + state->regoff, tmp);
-
-	write_reg(state, RSTV0910_P2_UPLCCST0 + state->regoff, 0xe0);
-	write_reg(state, RSTV0910_P2_ISIBITENA + state->regoff, 0x00);
-
-	read_reg(state, RSTV0910_P2_TSSTATEM + state->regoff, &tmp);
-	tmp &= ~0x01; /* nosync = 0, in case next signal is standard TS */
-	write_reg(state, RSTV0910_P2_TSSTATEM + state->regoff, tmp);
-
-	read_reg(state, RSTV0910_P2_TSCFGL + state->regoff, &tmp);
-	tmp &= ~0x04; /* embindvb = 0 */
-	write_reg(state, RSTV0910_P2_TSCFGL + state->regoff, tmp);
-
-	read_reg(state, RSTV0910_P2_TSINSDELH + state->regoff, &tmp);
-	tmp &= ~0x80; /* syncbyte = 0 */
-	write_reg(state, RSTV0910_P2_TSINSDELH + state->regoff, tmp);
-
-	read_reg(state, RSTV0910_P2_TSINSDELM + state->regoff, &tmp);
-	tmp &= ~0x08; /* token = 0 */
-	write_reg(state, RSTV0910_P2_TSINSDELM + state->regoff, tmp);
+	if (pls_code == state->cur_scrambling_code)
+		return;
+
+	/* PLROOT2 bit 2 = gold code */
+	write_reg(state, RSTV0910_P2_PLROOT0 + state->regoff,
+		  pls_code & 0xff);
+	write_reg(state, RSTV0910_P2_PLROOT1 + state->regoff,
+		  (pls_code >> 8) & 0xff);
+	write_reg(state, RSTV0910_P2_PLROOT2 + state->regoff,
+		  0x04 | ((pls_code >> 16) & 0x03));
+	state->cur_scrambling_code = pls_code;
+}
 
-	read_reg(state, RSTV0910_P2_TSDLYSET2 + state->regoff, &tmp);
-	tmp &= ~0x30; /* hysteresis threshold = 0 */
-	write_reg(state, RSTV0910_P2_TSDLYSET2 + state->regoff, tmp);
+static void set_isi(struct stv *state, u32 isi)
+{
+	if (isi == NO_STREAM_ID_FILTER)
+		return;
+	if (isi == 0x80000000) {
+		SET_FIELD(FORCE_CONTINUOUS, 1);
+		SET_FIELD(TSOUT_NOSYNC, 1);
+	} else {
+		SET_FIELD(FILTER_EN, 1);
+		write_reg(state, RSTV0910_P2_ISIENTRY + state->regoff,
+			  isi & 0xff);
+		write_reg(state, RSTV0910_P2_ISIBITENA + state->regoff, 0xff);
+	}
+	SET_FIELD(ALGOSWRST, 1);
+	SET_FIELD(ALGOSWRST, 0);
+}
 
-	read_reg(state, RSTV0910_P2_PDELCTRL0 + state->regoff, &tmp);
-	tmp = (tmp & ~0x30) | 0x10; /* isi obs mode = 1, observe min ISI */
-	write_reg(state, RSTV0910_P2_PDELCTRL0 + state->regoff, tmp);
+static void set_stream_modes(struct stv *state,
+			     struct dtv_frontend_properties *p)
+{
+	set_isi(state, p->stream_id);
+	set_pls(state, p->scrambling_sequence_index);
+}
 
+static int init_search_param(struct stv *state,
+			     struct dtv_frontend_properties *p)
+{
+	SET_FIELD(FORCE_CONTINUOUS, 0);
+	SET_FIELD(FRAME_MODE, 0);
+	SET_FIELD(FILTER_EN, 0);
+	SET_FIELD(TSOUT_NOSYNC, 0);
+	SET_FIELD(TSFIFO_EMBINDVB, 0);
+	SET_FIELD(TSDEL_SYNCBYTE, 0);
+	SET_REG(UPLCCST0, 0xe0);
+	SET_FIELD(TSINS_TOKEN, 0);
+	SET_FIELD(HYSTERESIS_THRESHOLD, 0);
+	SET_FIELD(ISIOBS_MODE, 1);
+
+	set_stream_modes(state, p);
 	return 0;
 }
 
@@ -1005,7 +1020,6 @@ static int start(struct stv *state, struct dtv_frontend_properties *p)
 	s32 freq;
 	u8  reg_dmdcfgmd;
 	u16 symb;
-	u32 scrambling_code = 1;
 
 	if (p->symbol_rate < 100000 || p->symbol_rate > 70000000)
 		return -EINVAL;
@@ -1017,30 +1031,7 @@ static int start(struct stv *state, struct dtv_frontend_properties *p)
 	if (state->started)
 		write_reg(state, RSTV0910_P2_DMDISTATE + state->regoff, 0x5C);
 
-	init_search_param(state);
-
-	if (p->stream_id != NO_STREAM_ID_FILTER) {
-		/*
-		 * Backwards compatibility to "crazy" API.
-		 * PRBS X root cannot be 0, so this should always work.
-		 */
-		if (p->stream_id & 0xffffff00)
-			scrambling_code = p->stream_id >> 8;
-		write_reg(state, RSTV0910_P2_ISIENTRY + state->regoff,
-			  p->stream_id & 0xff);
-		write_reg(state, RSTV0910_P2_ISIBITENA + state->regoff,
-			  0xff);
-	}
-
-	if (scrambling_code != state->cur_scrambling_code) {
-		write_reg(state, RSTV0910_P2_PLROOT0 + state->regoff,
-			  scrambling_code & 0xff);
-		write_reg(state, RSTV0910_P2_PLROOT1 + state->regoff,
-			  (scrambling_code >> 8) & 0xff);
-		write_reg(state, RSTV0910_P2_PLROOT2 + state->regoff,
-			  (scrambling_code >> 16) & 0x0f);
-		state->cur_scrambling_code = scrambling_code;
-	}
+	init_search_param(state, p);
 
 	if (p->symbol_rate <= 1000000) { /* SR <=1Msps */
 		state->demod_timeout = 3000;

commit bdd7682b16988a0fac07f9cf630e4fddb73e161c
Author: Daniel Scheller <d.scheller@gmx.net>
Date:   Tue Dec 26 18:37:58 2017 -0500

    media: dvb-frontends/stv0910: field and register access helpers
    
    Add a write_field() function that acts as helper to update specific bits
    specified in the field defines (FSTV0910_*) in stv0910_regs.h, which was
    recently updated to carry the missing offset values. With that, add the
    SET_FIELD(), SET_REG() and GET_REG() macros that wrap the write_field(),
    write_reg() and read_reg() functions to allow for making all demod
    access code cleaner.
    
    The write_field() function is annotated with __maybe_unused temporarily
    to silence eventual compile warnings.
    
    Picked up from the dddvb upstream, with the macro names made uppercase
    so they are distinguishable as such.
    
    Cc: Ralph Metzler <rjkm@metzlerbros.de>
    Signed-off-by: Daniel Scheller <d.scheller@gmx.net>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/stv0910.c b/drivers/media/dvb-frontends/stv0910.c
index fa6bb7436b86..1a3b65e43a85 100644
--- a/drivers/media/dvb-frontends/stv0910.c
+++ b/drivers/media/dvb-frontends/stv0910.c
@@ -194,6 +194,34 @@ static int write_shared_reg(struct stv *state, u16 reg, u8 mask, u8 val)
 	return status;
 }
 
+static int __maybe_unused write_field(struct stv *state, u32 field, u8 val)
+{
+	int status;
+	u8 shift, mask, old, new;
+
+	status = read_reg(state, field >> 16, &old);
+	if (status)
+		return status;
+	mask = field & 0xff;
+	shift = (field >> 12) & 0xf;
+	new = ((val << shift) & mask) | (old & ~mask);
+	if (new == old)
+		return 0;
+	return write_reg(state, field >> 16, new);
+}
+
+#define SET_FIELD(_reg, _val)					\
+	write_field(state, state->nr ? FSTV0910_P2_##_reg :	\
+		    FSTV0910_P1_##_reg, _val)
+
+#define SET_REG(_reg, _val)					\
+	write_reg(state, state->nr ? RSTV0910_P2_##_reg :	\
+		  RSTV0910_P1_##_reg, _val)
+
+#define GET_REG(_reg, _val)					\
+	read_reg(state, state->nr ? RSTV0910_P2_##_reg :	\
+		 RSTV0910_P1_##_reg, _val)
+
 static const struct slookup s1_sn_lookup[] = {
 	{   0,    9242  }, /* C/N=   0dB */
 	{   5,    9105  }, /* C/N= 0.5dB */

commit 8042e98c387b02fc4239eee0075d0f318efcf1d7
Author: Daniel Scheller <d.scheller@gmx.net>
Date:   Tue Dec 26 18:37:57 2017 -0500

    media: dvb-frontends/stv0910: cleanup I2C access functions
    
    write_reg() and i2c_write_reg16() only act as a proxy to i2c_write(), which
    isn't called from anywhere else throughout the driver. Clean this up by
    moving the message setup and the i2c_transfer() into write_reg() so it
    becomes the only I2C write function. While touching those parts, fix the
    error codes from EREMOTEIO to EIO.
    
    The I2C cleanup is picked from the upstream dddvb.
    
    Cc: Ralph Metzler <rjkm@metzlerbros.de>
    Signed-off-by: Daniel Scheller <d.scheller@gmx.net>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/stv0910.c b/drivers/media/dvb-frontends/stv0910.c
index 9f38ebeec853..fa6bb7436b86 100644
--- a/drivers/media/dvb-frontends/stv0910.c
+++ b/drivers/media/dvb-frontends/stv0910.c
@@ -137,33 +137,21 @@ struct slookup {
 	u32  reg_value;
 };
 
-static inline int i2c_write(struct i2c_adapter *adap, u8 adr,
-			    u8 *data, int len)
+static int write_reg(struct stv *state, u16 reg, u8 val)
 {
-	struct i2c_msg msg = {.addr = adr, .flags = 0,
-			      .buf = data, .len = len};
+	struct i2c_adapter *adap = state->base->i2c;
+	u8 data[3] = {reg >> 8, reg & 0xff, val};
+	struct i2c_msg msg = {.addr = state->base->adr, .flags = 0,
+			      .buf = data, .len = 3};
 
 	if (i2c_transfer(adap, &msg, 1) != 1) {
 		dev_warn(&adap->dev, "i2c write error ([%02x] %04x: %02x)\n",
-			 adr, (data[0] << 8) | data[1],
-			 (len > 2 ? data[2] : 0));
-		return -EREMOTEIO;
+			 state->base->adr, reg, val);
+		return -EIO;
 	}
 	return 0;
 }
 
-static int i2c_write_reg16(struct i2c_adapter *adap, u8 adr, u16 reg, u8 val)
-{
-	u8 msg[3] = {reg >> 8, reg & 0xff, val};
-
-	return i2c_write(adap, adr, msg, 3);
-}
-
-static int write_reg(struct stv *state, u16 reg, u8 val)
-{
-	return i2c_write_reg16(state->base->i2c, state->base->adr, reg, val);
-}
-
 static inline int i2c_read_regs16(struct i2c_adapter *adapter, u8 adr,
 				  u16 reg, u8 *val, int count)
 {
@@ -176,7 +164,7 @@ static inline int i2c_read_regs16(struct i2c_adapter *adapter, u8 adr,
 	if (i2c_transfer(adapter, msgs, 2) != 2) {
 		dev_warn(&adapter->dev, "i2c read error ([%02x] %04x)\n",
 			 adr, reg);
-		return -EREMOTEIO;
+		return -EIO;
 	}
 	return 0;
 }

commit 4b596bd70a396dfeb55f38b6bd1c21b8e77ebe77
Author: Daniel Scheller <d.scheller@gmx.net>
Date:   Tue Dec 26 18:37:56 2017 -0500

    media: dvb-frontends/stv0910: deduplicate writes in enable_puncture_rate()
    
    For all code rates, the same write is performed, only with a differing
    value. Clean this up by putting that value into a variable instead and
    perform the write at the end with that value.
    
    Picked up from the dddvb upstream.
    
    Cc: Ralph Metzler <rjkm@metzlerbros.de>
    Signed-off-by: Daniel Scheller <d.scheller@gmx.net>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/stv0910.c b/drivers/media/dvb-frontends/stv0910.c
index 946e55c74afa..9f38ebeec853 100644
--- a/drivers/media/dvb-frontends/stv0910.c
+++ b/drivers/media/dvb-frontends/stv0910.c
@@ -908,27 +908,31 @@ static int init_search_param(struct stv *state)
 
 static int enable_puncture_rate(struct stv *state, enum fe_code_rate rate)
 {
+	u8 val;
+
 	switch (rate) {
 	case FEC_1_2:
-		return write_reg(state,
-				 RSTV0910_P2_PRVIT + state->regoff, 0x01);
+		val = 0x01;
+		break;
 	case FEC_2_3:
-		return write_reg(state,
-				 RSTV0910_P2_PRVIT + state->regoff, 0x02);
+		val = 0x02;
+		break;
 	case FEC_3_4:
-		return write_reg(state,
-				 RSTV0910_P2_PRVIT + state->regoff, 0x04);
+		val = 0x04;
+		break;
 	case FEC_5_6:
-		return write_reg(state,
-				 RSTV0910_P2_PRVIT + state->regoff, 0x08);
+		val = 0x08;
+		break;
 	case FEC_7_8:
-		return write_reg(state,
-				 RSTV0910_P2_PRVIT + state->regoff, 0x20);
+		val = 0x20;
+		break;
 	case FEC_NONE:
 	default:
-		return write_reg(state,
-				 RSTV0910_P2_PRVIT + state->regoff, 0x2f);
+		val = 0x2f;
+		break;
 	}
+
+	return write_reg(state, RSTV0910_P2_PRVIT + state->regoff, val);
 }
 
 static int set_vth_default(struct stv *state)

commit fada1935590f66dc6784981e0d557ca09013c847
Author: Mauro Carvalho Chehab <mchehab@s-opensource.com>
Date:   Thu Dec 28 13:03:51 2017 -0500

    media: move dvb kAPI headers to include/media
    
    Except for DVB, all media kAPI headers are at include/media.
    
    Move the headers to it.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/stv0910.c b/drivers/media/dvb-frontends/stv0910.c
index a8c99f41478b..946e55c74afa 100644
--- a/drivers/media/dvb-frontends/stv0910.c
+++ b/drivers/media/dvb-frontends/stv0910.c
@@ -24,7 +24,7 @@
 #include <linux/i2c.h>
 #include <asm/div64.h>
 
-#include "dvb_frontend.h"
+#include <media/dvb_frontend.h>
 #include "stv0910.h"
 #include "stv0910_regs.h"
 

commit 22f584c5c665461d6bb3d4e242084e4a5b87d5b6
Author: Daniel Scheller <d.scheller@gmx.net>
Date:   Sun Nov 26 08:00:09 2017 -0500

    media: dvb-frontends/stv0910: remove unneeded dvb_math.h include
    
    Since nothing from dvb_math.h is used, remove the unneeded include.
    
    Signed-off-by: Daniel Scheller <d.scheller@gmx.net>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/stv0910.c b/drivers/media/dvb-frontends/stv0910.c
index 681349a5aea8..a8c99f41478b 100644
--- a/drivers/media/dvb-frontends/stv0910.c
+++ b/drivers/media/dvb-frontends/stv0910.c
@@ -24,7 +24,6 @@
 #include <linux/i2c.h>
 #include <asm/div64.h>
 
-#include "dvb_math.h"
 #include "dvb_frontend.h"
 #include "stv0910.h"
 #include "stv0910_regs.h"

commit 5dd70f5a6a2dacf501d8b16f714455d3a35b1b11
Author: Daniel Scheller <d.scheller@gmx.net>
Date:   Sun Nov 26 08:00:08 2017 -0500

    media: dvb-frontends/stv0910: remove unneeded symbol rate inquiry
    
    tracking_optimization() doesn't make use of the symbol rate reported by
    the demodulator, so remove the unneeded inquiry and the now unneeded
    variable.
    
    Reported-by: Richard Scobie <rascobie@slingshot.co.nz>
    Cc: Ralph Metzler <rjkm@metzlerbros.de>
    Signed-off-by: Daniel Scheller <d.scheller@gmx.net>
    Tested-by: Richard Scobie <rascobie@slingshot.co.nz>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/stv0910.c b/drivers/media/dvb-frontends/stv0910.c
index 55cddd01f779..681349a5aea8 100644
--- a/drivers/media/dvb-frontends/stv0910.c
+++ b/drivers/media/dvb-frontends/stv0910.c
@@ -533,10 +533,8 @@ static int get_signal_parameters(struct stv *state)
 
 static int tracking_optimization(struct stv *state)
 {
-	u32 symbol_rate = 0;
 	u8 tmp;
 
-	get_cur_symbol_rate(state, &symbol_rate);
 	read_reg(state, RSTV0910_P2_DMDCFGMD + state->regoff, &tmp);
 	tmp &= ~0xC0;
 

commit 0b885ded9c6a9d991d217a8dacca45141cb46825
Author: Daniel Scheller <d.scheller@gmx.net>
Date:   Sun Nov 26 08:00:07 2017 -0500

    media: dvb-frontends/stv0910: read symbolrate in get_frontend()
    
    Utilise get_cur_symbol_rate() in get_frontend() to update the
    dtv_frontend_properties with the current symbol rate as reported by the
    demodulator.
    
    Reported-by: Richard Scobie <rascobie@slingshot.co.nz>
    Cc: Ralph Metzler <rjkm@metzlerbros.de>
    Signed-off-by: Daniel Scheller <d.scheller@gmx.net>
    Tested-by: Richard Scobie <rascobie@slingshot.co.nz>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/stv0910.c b/drivers/media/dvb-frontends/stv0910.c
index 299dd3533720..55cddd01f779 100644
--- a/drivers/media/dvb-frontends/stv0910.c
+++ b/drivers/media/dvb-frontends/stv0910.c
@@ -1539,6 +1539,7 @@ static int get_frontend(struct dvb_frontend *fe,
 {
 	struct stv *state = fe->demodulator_priv;
 	u8 tmp;
+	u32 symbolrate;
 
 	if (state->receive_mode == RCVMODE_DVBS2) {
 		u32 mc;
@@ -1592,6 +1593,10 @@ static int get_frontend(struct dvb_frontend *fe,
 		p->rolloff = ROLLOFF_35;
 	}
 
+	if (state->receive_mode != RCVMODE_NONE) {
+		get_cur_symbol_rate(state, &symbolrate);
+		p->symbol_rate = symbolrate;
+	}
 	return 0;
 }
 

commit 471dd695dcc04aca77aa1ad5b81a93fed8dbb7fd
Author: Daniel Scheller <d.scheller@gmx.net>
Date:   Sun Nov 26 08:00:06 2017 -0500

    media: dvb-frontends/stv0910: remove unneeded check/call to get_if_freq
    
    The result (if any) isn't used anywhere besides being assigned to a local
    variable (and the only current companion stv6111 doesn't even implement
    get_if_frequency()), thus remove the ptr check and the call, and also
    remove the now unused iffreq variable.
    
    Reported-by: Richard Scobie <rascobie@slingshot.co.nz>
    Cc: Ralph Metzler <rjkm@metzlerbros.de>
    Signed-off-by: Daniel Scheller <d.scheller@gmx.net>
    Tested-by: Richard Scobie <rascobie@slingshot.co.nz>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/stv0910.c b/drivers/media/dvb-frontends/stv0910.c
index 4b7e901220e4..299dd3533720 100644
--- a/drivers/media/dvb-frontends/stv0910.c
+++ b/drivers/media/dvb-frontends/stv0910.c
@@ -1273,14 +1273,11 @@ static int set_parameters(struct dvb_frontend *fe)
 {
 	int stat = 0;
 	struct stv *state = fe->demodulator_priv;
-	u32 iffreq;
 	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
 
 	stop(state);
 	if (fe->ops.tuner_ops.set_params)
 		fe->ops.tuner_ops.set_params(fe);
-	if (fe->ops.tuner_ops.get_if_frequency)
-		fe->ops.tuner_ops.get_if_frequency(fe, &iffreq);
 	state->symbol_rate = p->symbol_rate;
 	stat = start(state, p);
 	return stat;

commit aea16005f4081a745c2178e6e4e5825c01a6226e
Author: Daniel Scheller <d.scheller@gmx.net>
Date:   Sun Nov 26 08:00:04 2017 -0500

    media: dvb-frontends/stv0910: WARN_ON() on consecutive mutex_unlock()
    
    Stack dump when gate_ctrl() is called in a way that consecutive unlocks
    happen. This is a clear indication that other drivers interfacing with
    the stv0910 driver don't do things properly or don't check for failures,
    so dump stack so that those drivers can be identified and fixed.
    
    Signed-off-by: Daniel Scheller <d.scheller@gmx.net>
    Tested-by: Richard Scobie <rascobie@slingshot.co.nz>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/stv0910.c b/drivers/media/dvb-frontends/stv0910.c
index 73f6df0abbfe..4b7e901220e4 100644
--- a/drivers/media/dvb-frontends/stv0910.c
+++ b/drivers/media/dvb-frontends/stv0910.c
@@ -1241,7 +1241,8 @@ static int gate_ctrl(struct dvb_frontend *fe, int enable)
 	if (write_reg(state, state->nr ? RSTV0910_P2_I2CRPT :
 		      RSTV0910_P1_I2CRPT, i2crpt) < 0) {
 		/* don't hold the I2C bus lock on failure */
-		mutex_unlock(&state->base->i2c_lock);
+		if (!WARN_ON(!mutex_is_locked(&state->base->i2c_lock)))
+			mutex_unlock(&state->base->i2c_lock);
 		dev_err(&state->base->i2c->dev,
 			"%s() write_reg failure (enable=%d)\n",
 			__func__, enable);
@@ -1251,7 +1252,8 @@ static int gate_ctrl(struct dvb_frontend *fe, int enable)
 	state->i2crpt = i2crpt;
 
 	if (!enable)
-		mutex_unlock(&state->base->i2c_lock);
+		if (!WARN_ON(!mutex_is_locked(&state->base->i2c_lock)))
+			mutex_unlock(&state->base->i2c_lock);
 	return 0;
 }
 

commit 9cc6544718b738bd7dd2c3c885814304bab2d253
Author: Daniel Scheller <d.scheller@gmx.net>
Date:   Sun Oct 15 16:51:56 2017 -0400

    media: stv0910: read and update mod_cod in read_status()
    
    Add missing state->modcod update from upstream driver which needs to be
    done when manage_matype_info() sets is_vcm on certain S2 transponders.
    
    Signed-off-by: Daniel Scheller <d.scheller@gmx.net>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/stv0910.c b/drivers/media/dvb-frontends/stv0910.c
index 8bf855c301f5..73f6df0abbfe 100644
--- a/drivers/media/dvb-frontends/stv0910.c
+++ b/drivers/media/dvb-frontends/stv0910.c
@@ -1498,6 +1498,19 @@ static int read_status(struct dvb_frontend *fe, enum fe_status *status)
 				enable_puncture_rate(state,
 						     state->puncture_rate);
 		}
+
+		/* Use highest signaled ModCod for quality */
+		if (state->is_vcm) {
+			u8 tmp;
+			enum fe_stv0910_mod_cod mod_cod;
+
+			read_reg(state, RSTV0910_P2_DMDMODCOD + state->regoff,
+				 &tmp);
+			mod_cod = (enum fe_stv0910_mod_cod)((tmp & 0x7c) >> 2);
+
+			if (mod_cod > state->mod_cod)
+				state->mod_cod = mod_cod;
+		}
 	}
 
 	/* read signal statistics */

commit e5d9ce4ddea934d1243747bfc142749ba6ff0c5a
Author: Daniel Scheller <d.scheller@gmx.net>
Date:   Wed Aug 23 12:10:02 2017 -0400

    media: dvb-frontends/stv0910: change minsymrate to 100Ksyms/s
    
    The demodulator supports symbol rates as low as 100Ksyms/s - the demod
    setup in start() already handles such low symbol rates and reviewers
    of stv0910 equipped cards even found and tested transponders with
    SRs in that range. So, announce this in the fe_ops.
    
    Cc: Ralph Metzler <rjkm@metzlerbros.de>
    Cc: Richard Scobie <r.scobie@clear.net.nz>
    Signed-off-by: Daniel Scheller <d.scheller@gmx.net>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/stv0910.c b/drivers/media/dvb-frontends/stv0910.c
index 0d4a6a115159..8bf855c301f5 100644
--- a/drivers/media/dvb-frontends/stv0910.c
+++ b/drivers/media/dvb-frontends/stv0910.c
@@ -1698,7 +1698,7 @@ static const struct dvb_frontend_ops stv0910_ops = {
 		.frequency_max		= 2150000,
 		.frequency_stepsize	= 0,
 		.frequency_tolerance	= 0,
-		.symbol_rate_min	= 1000000,
+		.symbol_rate_min	= 100000,
 		.symbol_rate_max	= 70000000,
 		.caps			= FE_CAN_INVERSION_AUTO |
 					  FE_CAN_FEC_AUTO       |

commit 6b852620fa75d3137929538b4a9aec2f953ff03c
Author: Daniel Scheller <d.scheller@gmx.net>
Date:   Wed Aug 23 12:09:58 2017 -0400

    media: dvb-frontends/stv0910: release lock on gate_ctrl() failure
    
    Whenever write_reg() fails to open/close the demod's I2C gate, release the
    lock to avoid deadlocking situations. If I2c gate open failed, there's no
    need to hold a lock, and if close fails, the mutex_unlock() at the end of
    the function is never reached, leaving the mutex_lock in locked state,
    which in turn will cause potential for deadlocks. Thus, release the lock
    on failure.
    
    While we're touching gate_ctrl(), add some explanation about the need for
    locking and the shared I2C bus/gate.
    
    Cc: Julia Lawall <julia.lawall@lip6.fr>
    Signed-off-by: Daniel Scheller <d.scheller@gmx.net>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/stv0910.c b/drivers/media/dvb-frontends/stv0910.c
index d1ae9553f74c..0d4a6a115159 100644
--- a/drivers/media/dvb-frontends/stv0910.c
+++ b/drivers/media/dvb-frontends/stv0910.c
@@ -1221,17 +1221,32 @@ static int gate_ctrl(struct dvb_frontend *fe, int enable)
 	struct stv *state = fe->demodulator_priv;
 	u8 i2crpt = state->i2crpt & ~0x86;
 
-	if (enable)
-		mutex_lock(&state->base->i2c_lock);
+	/*
+	 * mutex_lock note: Concurrent I2C gate bus accesses must be
+	 * prevented (STV0910 = dual demod on a single IC with a single I2C
+	 * gate/bus, and two tuners attached), similar to most (if not all)
+	 * other I2C host interfaces/busses.
+	 *
+	 * enable=1 (open I2C gate) will grab the lock
+	 * enable=0 (close I2C gate) releases the lock
+	 */
 
-	if (enable)
+	if (enable) {
+		mutex_lock(&state->base->i2c_lock);
 		i2crpt |= 0x80;
-	else
+	} else {
 		i2crpt |= 0x02;
+	}
 
 	if (write_reg(state, state->nr ? RSTV0910_P2_I2CRPT :
-		      RSTV0910_P1_I2CRPT, i2crpt) < 0)
+		      RSTV0910_P1_I2CRPT, i2crpt) < 0) {
+		/* don't hold the I2C bus lock on failure */
+		mutex_unlock(&state->base->i2c_lock);
+		dev_err(&state->base->i2c->dev,
+			"%s() write_reg failure (enable=%d)\n",
+			__func__, enable);
 		return -EIO;
+	}
 
 	state->i2crpt = i2crpt;
 

commit c16ad5de39843e9faa02270de08feeda05850caa
Author: Daniel Scheller <d.scheller@gmx.net>
Date:   Sun Aug 20 08:59:11 2017 -0400

    media: stv0910: declare global list_head stvlist static
    
    Cleans up smatch warning:
    symbol 'stvlist' was not declared. Should it be static?
    
    Patch originally submitted by Colin Ian King <colin.king@canonical.com>,
    remainder after the merge of all other stv0910 fixes.
    
    Cc: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Daniel Scheller <d.scheller@gmx.net>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/stv0910.c b/drivers/media/dvb-frontends/stv0910.c
index d0a8ed36b899..d1ae9553f74c 100644
--- a/drivers/media/dvb-frontends/stv0910.c
+++ b/drivers/media/dvb-frontends/stv0910.c
@@ -34,7 +34,7 @@
 #define BER_SRC_S    0x20
 #define BER_SRC_S2   0x20
 
-LIST_HEAD(stvlist);
+static LIST_HEAD(stvlist);
 
 enum receive_mode { RCVMODE_NONE, RCVMODE_DVBS, RCVMODE_DVBS2, RCVMODE_AUTO };
 

commit 0758ecdbd888289a783d16122dc24be4c5f1c222
Author: Daniel Scheller <d.scheller@gmx.net>
Date:   Sun Aug 20 06:29:15 2017 -0400

    media: dvb-frontends/stv0910: fix mask for scramblingcode setup
    
    The scrambling code has 4 bits. Fix the mask accordingly.
    
    Signed-off-by: Daniel Scheller <d.scheller@gmx.net>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/stv0910.c b/drivers/media/dvb-frontends/stv0910.c
index e87a3ee6155c..d0a8ed36b899 100644
--- a/drivers/media/dvb-frontends/stv0910.c
+++ b/drivers/media/dvb-frontends/stv0910.c
@@ -1021,7 +1021,7 @@ static int start(struct stv *state, struct dtv_frontend_properties *p)
 		write_reg(state, RSTV0910_P2_PLROOT1 + state->regoff,
 			  (scrambling_code >> 8) & 0xff);
 		write_reg(state, RSTV0910_P2_PLROOT2 + state->regoff,
-			  (scrambling_code >> 16) & 0x07);
+			  (scrambling_code >> 16) & 0x0f);
 		state->cur_scrambling_code = scrambling_code;
 	}
 

commit f0e72c29fd063aca325afee25a6f9bcc22871837
Author: Daniel Scheller <d.scheller@gmx.net>
Date:   Sun Aug 20 06:29:14 2017 -0400

    media: dvb-frontends/stv0910: fix FE_HAS_LOCK check order in tune()
    
    It should first read the status and then check if FE has lock.
    
    Signed-off-by: Daniel Scheller <d.scheller@gmx.net>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/stv0910.c b/drivers/media/dvb-frontends/stv0910.c
index 45d94c3a29f2..e87a3ee6155c 100644
--- a/drivers/media/dvb-frontends/stv0910.c
+++ b/drivers/media/dvb-frontends/stv0910.c
@@ -1581,13 +1581,15 @@ static int tune(struct dvb_frontend *fe, bool re_tune,
 			return r;
 		state->tune_time = jiffies;
 	}
-	if (*status & FE_HAS_LOCK)
-		return 0;
-	*delay = HZ;
 
 	r = read_status(fe, status);
 	if (r)
 		return r;
+
+	if (*status & FE_HAS_LOCK)
+		return 0;
+	*delay = HZ;
+
 	return 0;
 }
 

commit 20e671dff9e40fa882574de29be9cc647737aee8
Author: Daniel Scheller <d.scheller@gmx.net>
Date:   Sun Jul 23 06:13:15 2017 -0400

    media: dvb-frontends/stv{0910,6111}: constify tables
    
    Mark lookup tables and fe_ops things const so the compiler can put them
    into .rodata.
    
    While at it, improve name and identifier strings (moddesc, fe_ops).
    
    Signed-off-by: Daniel Scheller <d.scheller@gmx.net>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/stv0910.c b/drivers/media/dvb-frontends/stv0910.c
index 08a5a3ec5391..45d94c3a29f2 100644
--- a/drivers/media/dvb-frontends/stv0910.c
+++ b/drivers/media/dvb-frontends/stv0910.c
@@ -207,7 +207,7 @@ static int write_shared_reg(struct stv *state, u16 reg, u8 mask, u8 val)
 	return status;
 }
 
-static struct slookup s1_sn_lookup[] = {
+static const struct slookup s1_sn_lookup[] = {
 	{   0,    9242  }, /* C/N=   0dB */
 	{   5,    9105  }, /* C/N= 0.5dB */
 	{  10,    8950  }, /* C/N= 1.0dB */
@@ -264,7 +264,7 @@ static struct slookup s1_sn_lookup[] = {
 	{  510,    425  }  /* C/N=51.0dB */
 };
 
-static struct slookup s2_sn_lookup[] = {
+static const struct slookup s2_sn_lookup[] = {
 	{  -30,  13950  }, /* C/N=-2.5dB */
 	{  -25,  13580  }, /* C/N=-2.5dB */
 	{  -20,  13150  }, /* C/N=-2.0dB */
@@ -327,7 +327,7 @@ static struct slookup s2_sn_lookup[] = {
 	{  510,    463  }, /* C/N=51.0dB */
 };
 
-static struct slookup padc_lookup[] = {
+static const struct slookup padc_lookup[] = {
 	{    0,  118000 }, /* PADC= +0dBm */
 	{ -100,  93600  }, /* PADC= -1dBm */
 	{ -200,  74500  }, /* PADC= -2dBm */
@@ -349,7 +349,7 @@ static struct slookup padc_lookup[] = {
 /*********************************************************************
  * Tracking carrier loop carrier QPSK 1/4 to 8PSK 9/10 long Frame
  *********************************************************************/
-static u8 s2car_loop[] =	{
+static const u8 s2car_loop[] =	{
 	/*
 	 * Modcod  2MPon 2MPoff 5MPon 5MPoff 10MPon 10MPoff
 	 * 20MPon 20MPoff 30MPon 30MPoff
@@ -587,7 +587,7 @@ static int tracking_optimization(struct stv *state)
 	return 0;
 }
 
-static s32 table_lookup(struct slookup *table,
+static s32 table_lookup(const struct slookup *table,
 			int table_size, u32 reg_value)
 {
 	s32 value;
@@ -629,7 +629,7 @@ static int get_signal_to_noise(struct stv *state, s32 *signal_to_noise)
 	u8 data1;
 	u16 data;
 	int n_lookup;
-	struct slookup *lookup;
+	const struct slookup *lookup;
 
 	*signal_to_noise = 0;
 
@@ -693,7 +693,7 @@ static int get_bit_error_rate_s(struct stv *state, u32 *bernumerator,
 
 static u32 dvbs2_nbch(enum dvbs2_mod_cod mod_cod, enum dvbs2_fectype fectype)
 {
-	static u32 nbch[][2] = {
+	static const u32 nbch[][2] = {
 		{    0,     0}, /* DUMMY_PLF   */
 		{16200,  3240}, /* QPSK_1_4,   */
 		{21600,  5400}, /* QPSK_1_3,   */
@@ -953,7 +953,7 @@ static int set_vth_default(struct stv *state)
 
 static int set_vth(struct stv *state)
 {
-	static struct slookup vthlookup_table[] = {
+	static const struct slookup vthlookup_table[] = {
 		{250,	8780}, /* C/N= 1.5dB */
 		{100,	7405}, /* C/N= 4.5dB */
 		{40,	6330}, /* C/N= 6.5dB */
@@ -1515,7 +1515,7 @@ static int get_frontend(struct dvb_frontend *fe,
 
 	if (state->receive_mode == RCVMODE_DVBS2) {
 		u32 mc;
-		enum fe_modulation modcod2mod[0x20] = {
+		const enum fe_modulation modcod2mod[0x20] = {
 			QPSK, QPSK, QPSK, QPSK,
 			QPSK, QPSK, QPSK, QPSK,
 			QPSK, QPSK, QPSK, QPSK,
@@ -1525,7 +1525,7 @@ static int get_frontend(struct dvb_frontend *fe,
 			APSK_32, APSK_32, APSK_32, APSK_32,
 			APSK_32,
 		};
-		enum fe_code_rate modcod2fec[0x20] = {
+		const enum fe_code_rate modcod2fec[0x20] = {
 			FEC_NONE, FEC_NONE, FEC_NONE, FEC_2_5,
 			FEC_1_2, FEC_3_5, FEC_2_3, FEC_3_4,
 			FEC_4_5, FEC_5_6, FEC_8_9, FEC_9_10,
@@ -1673,10 +1673,10 @@ static int sleep(struct dvb_frontend *fe)
 	return 0;
 }
 
-static struct dvb_frontend_ops stv0910_ops = {
+static const struct dvb_frontend_ops stv0910_ops = {
 	.delsys = { SYS_DVBS, SYS_DVBS2, SYS_DSS },
 	.info = {
-		.name			= "STV0910",
+		.name			= "ST STV0910",
 		.frequency_min		= 950000,
 		.frequency_max		= 2150000,
 		.frequency_stepsize	= 0,

commit 4f979d5cf0a5a5f1c4257e22034dabaf6227f4e7
Author: Daniel Scheller <d.scheller@gmx.net>
Date:   Sun Jul 23 06:13:12 2017 -0400

    media: dvb-frontends/stv0910: cosmetics: fixup comments, misc
    
    Fix up block comment style, whitespaces, c++ style comments et al.
    
    Signed-off-by: Daniel Scheller <d.scheller@gmx.net>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/stv0910.c b/drivers/media/dvb-frontends/stv0910.c
index a0eb4374fe85..08a5a3ec5391 100644
--- a/drivers/media/dvb-frontends/stv0910.c
+++ b/drivers/media/dvb-frontends/stv0910.c
@@ -207,136 +207,136 @@ static int write_shared_reg(struct stv *state, u16 reg, u8 mask, u8 val)
 	return status;
 }
 
-struct slookup s1_sn_lookup[] = {
-	{   0,    9242  },  /*C/N=  0dB*/
-	{   5,    9105  },  /*C/N=0.5dB*/
-	{  10,    8950  },  /*C/N=1.0dB*/
-	{  15,    8780  },  /*C/N=1.5dB*/
-	{  20,    8566  },  /*C/N=2.0dB*/
-	{  25,    8366  },  /*C/N=2.5dB*/
-	{  30,    8146  },  /*C/N=3.0dB*/
-	{  35,    7908  },  /*C/N=3.5dB*/
-	{  40,    7666  },  /*C/N=4.0dB*/
-	{  45,    7405  },  /*C/N=4.5dB*/
-	{  50,    7136  },  /*C/N=5.0dB*/
-	{  55,    6861  },  /*C/N=5.5dB*/
-	{  60,    6576  },  /*C/N=6.0dB*/
-	{  65,    6330  },  /*C/N=6.5dB*/
-	{  70,    6048  },  /*C/N=7.0dB*/
-	{  75,    5768  },  /*C/N=7.5dB*/
-	{  80,    5492  },  /*C/N=8.0dB*/
-	{  85,    5224  },  /*C/N=8.5dB*/
-	{  90,    4959  },  /*C/N=9.0dB*/
-	{  95,    4709  },  /*C/N=9.5dB*/
-	{  100,   4467  },  /*C/N=10.0dB*/
-	{  105,   4236  },  /*C/N=10.5dB*/
-	{  110,   4013  },  /*C/N=11.0dB*/
-	{  115,   3800  },  /*C/N=11.5dB*/
-	{  120,   3598  },  /*C/N=12.0dB*/
-	{  125,   3406  },  /*C/N=12.5dB*/
-	{  130,   3225  },  /*C/N=13.0dB*/
-	{  135,   3052  },  /*C/N=13.5dB*/
-	{  140,   2889  },  /*C/N=14.0dB*/
-	{  145,   2733  },  /*C/N=14.5dB*/
-	{  150,   2587  },  /*C/N=15.0dB*/
-	{  160,   2318  },  /*C/N=16.0dB*/
-	{  170,   2077  },  /*C/N=17.0dB*/
-	{  180,   1862  },  /*C/N=18.0dB*/
-	{  190,   1670  },  /*C/N=19.0dB*/
-	{  200,   1499  },  /*C/N=20.0dB*/
-	{  210,   1347  },  /*C/N=21.0dB*/
-	{  220,   1213  },  /*C/N=22.0dB*/
-	{  230,   1095  },  /*C/N=23.0dB*/
-	{  240,    992  },  /*C/N=24.0dB*/
-	{  250,    900  },  /*C/N=25.0dB*/
-	{  260,    826  },  /*C/N=26.0dB*/
-	{  270,    758  },  /*C/N=27.0dB*/
-	{  280,    702  },  /*C/N=28.0dB*/
-	{  290,    653  },  /*C/N=29.0dB*/
-	{  300,    613  },  /*C/N=30.0dB*/
-	{  310,    579  },  /*C/N=31.0dB*/
-	{  320,    550  },  /*C/N=32.0dB*/
-	{  330,    526  },  /*C/N=33.0dB*/
-	{  350,    490  },  /*C/N=33.0dB*/
-	{  400,    445  },  /*C/N=40.0dB*/
-	{  450,    430  },  /*C/N=45.0dB*/
-	{  500,    426  },  /*C/N=50.0dB*/
-	{  510,    425  }   /*C/N=51.0dB*/
+static struct slookup s1_sn_lookup[] = {
+	{   0,    9242  }, /* C/N=   0dB */
+	{   5,    9105  }, /* C/N= 0.5dB */
+	{  10,    8950  }, /* C/N= 1.0dB */
+	{  15,    8780  }, /* C/N= 1.5dB */
+	{  20,    8566  }, /* C/N= 2.0dB */
+	{  25,    8366  }, /* C/N= 2.5dB */
+	{  30,    8146  }, /* C/N= 3.0dB */
+	{  35,    7908  }, /* C/N= 3.5dB */
+	{  40,    7666  }, /* C/N= 4.0dB */
+	{  45,    7405  }, /* C/N= 4.5dB */
+	{  50,    7136  }, /* C/N= 5.0dB */
+	{  55,    6861  }, /* C/N= 5.5dB */
+	{  60,    6576  }, /* C/N= 6.0dB */
+	{  65,    6330  }, /* C/N= 6.5dB */
+	{  70,    6048  }, /* C/N= 7.0dB */
+	{  75,    5768  }, /* C/N= 7.5dB */
+	{  80,    5492  }, /* C/N= 8.0dB */
+	{  85,    5224  }, /* C/N= 8.5dB */
+	{  90,    4959  }, /* C/N= 9.0dB */
+	{  95,    4709  }, /* C/N= 9.5dB */
+	{  100,   4467  }, /* C/N=10.0dB */
+	{  105,   4236  }, /* C/N=10.5dB */
+	{  110,   4013  }, /* C/N=11.0dB */
+	{  115,   3800  }, /* C/N=11.5dB */
+	{  120,   3598  }, /* C/N=12.0dB */
+	{  125,   3406  }, /* C/N=12.5dB */
+	{  130,   3225  }, /* C/N=13.0dB */
+	{  135,   3052  }, /* C/N=13.5dB */
+	{  140,   2889  }, /* C/N=14.0dB */
+	{  145,   2733  }, /* C/N=14.5dB */
+	{  150,   2587  }, /* C/N=15.0dB */
+	{  160,   2318  }, /* C/N=16.0dB */
+	{  170,   2077  }, /* C/N=17.0dB */
+	{  180,   1862  }, /* C/N=18.0dB */
+	{  190,   1670  }, /* C/N=19.0dB */
+	{  200,   1499  }, /* C/N=20.0dB */
+	{  210,   1347  }, /* C/N=21.0dB */
+	{  220,   1213  }, /* C/N=22.0dB */
+	{  230,   1095  }, /* C/N=23.0dB */
+	{  240,    992  }, /* C/N=24.0dB */
+	{  250,    900  }, /* C/N=25.0dB */
+	{  260,    826  }, /* C/N=26.0dB */
+	{  270,    758  }, /* C/N=27.0dB */
+	{  280,    702  }, /* C/N=28.0dB */
+	{  290,    653  }, /* C/N=29.0dB */
+	{  300,    613  }, /* C/N=30.0dB */
+	{  310,    579  }, /* C/N=31.0dB */
+	{  320,    550  }, /* C/N=32.0dB */
+	{  330,    526  }, /* C/N=33.0dB */
+	{  350,    490  }, /* C/N=33.0dB */
+	{  400,    445  }, /* C/N=40.0dB */
+	{  450,    430  }, /* C/N=45.0dB */
+	{  500,    426  }, /* C/N=50.0dB */
+	{  510,    425  }  /* C/N=51.0dB */
 };
 
-struct slookup s2_sn_lookup[] = {
-	{  -30,  13950  },  /*C/N=-2.5dB*/
-	{  -25,  13580  },  /*C/N=-2.5dB*/
-	{  -20,  13150  },  /*C/N=-2.0dB*/
-	{  -15,  12760  },  /*C/N=-1.5dB*/
-	{  -10,  12345  },  /*C/N=-1.0dB*/
-	{   -5,  11900  },  /*C/N=-0.5dB*/
-	{    0,  11520  },  /*C/N=   0dB*/
-	{    5,  11080  },  /*C/N= 0.5dB*/
-	{   10,  10630  },  /*C/N= 1.0dB*/
-	{   15,  10210  },  /*C/N= 1.5dB*/
-	{   20,   9790  },  /*C/N= 2.0dB*/
-	{   25,   9390  },  /*C/N= 2.5dB*/
-	{   30,   8970  },  /*C/N= 3.0dB*/
-	{   35,   8575  },  /*C/N= 3.5dB*/
-	{   40,   8180  },  /*C/N= 4.0dB*/
-	{   45,   7800  },  /*C/N= 4.5dB*/
-	{   50,   7430  },  /*C/N= 5.0dB*/
-	{   55,   7080  },  /*C/N= 5.5dB*/
-	{   60,   6720  },  /*C/N= 6.0dB*/
-	{   65,   6320  },  /*C/N= 6.5dB*/
-	{   70,   6060  },  /*C/N= 7.0dB*/
-	{   75,   5760  },  /*C/N= 7.5dB*/
-	{   80,   5480  },  /*C/N= 8.0dB*/
-	{   85,   5200  },  /*C/N= 8.5dB*/
-	{   90,   4930  },  /*C/N= 9.0dB*/
-	{   95,   4680  },  /*C/N= 9.5dB*/
-	{  100,   4425  },  /*C/N=10.0dB*/
-	{  105,   4210  },  /*C/N=10.5dB*/
-	{  110,   3980  },  /*C/N=11.0dB*/
-	{  115,   3765  },  /*C/N=11.5dB*/
-	{  120,   3570  },  /*C/N=12.0dB*/
-	{  125,   3315  },  /*C/N=12.5dB*/
-	{  130,   3140  },  /*C/N=13.0dB*/
-	{  135,   2980  },  /*C/N=13.5dB*/
-	{  140,   2820  },  /*C/N=14.0dB*/
-	{  145,   2670  },  /*C/N=14.5dB*/
-	{  150,   2535  },  /*C/N=15.0dB*/
-	{  160,   2270  },  /*C/N=16.0dB*/
-	{  170,   2035  },  /*C/N=17.0dB*/
-	{  180,   1825  },  /*C/N=18.0dB*/
-	{  190,   1650  },  /*C/N=19.0dB*/
-	{  200,   1485  },  /*C/N=20.0dB*/
-	{  210,   1340  },  /*C/N=21.0dB*/
-	{  220,   1212  },  /*C/N=22.0dB*/
-	{  230,   1100  },  /*C/N=23.0dB*/
-	{  240,   1000  },  /*C/N=24.0dB*/
-	{  250,    910  },  /*C/N=25.0dB*/
-	{  260,    836  },  /*C/N=26.0dB*/
-	{  270,    772  },  /*C/N=27.0dB*/
-	{  280,    718  },  /*C/N=28.0dB*/
-	{  290,    671  },  /*C/N=29.0dB*/
-	{  300,    635  },  /*C/N=30.0dB*/
-	{  310,    602  },  /*C/N=31.0dB*/
-	{  320,    575  },  /*C/N=32.0dB*/
-	{  330,    550  },  /*C/N=33.0dB*/
-	{  350,    517  },  /*C/N=35.0dB*/
-	{  400,    480  },  /*C/N=40.0dB*/
-	{  450,    466  },  /*C/N=45.0dB*/
-	{  500,    464  },  /*C/N=50.0dB*/
-	{  510,    463  },  /*C/N=51.0dB*/
+static struct slookup s2_sn_lookup[] = {
+	{  -30,  13950  }, /* C/N=-2.5dB */
+	{  -25,  13580  }, /* C/N=-2.5dB */
+	{  -20,  13150  }, /* C/N=-2.0dB */
+	{  -15,  12760  }, /* C/N=-1.5dB */
+	{  -10,  12345  }, /* C/N=-1.0dB */
+	{   -5,  11900  }, /* C/N=-0.5dB */
+	{    0,  11520  }, /* C/N=   0dB */
+	{    5,  11080  }, /* C/N= 0.5dB */
+	{   10,  10630  }, /* C/N= 1.0dB */
+	{   15,  10210  }, /* C/N= 1.5dB */
+	{   20,   9790  }, /* C/N= 2.0dB */
+	{   25,   9390  }, /* C/N= 2.5dB */
+	{   30,   8970  }, /* C/N= 3.0dB */
+	{   35,   8575  }, /* C/N= 3.5dB */
+	{   40,   8180  }, /* C/N= 4.0dB */
+	{   45,   7800  }, /* C/N= 4.5dB */
+	{   50,   7430  }, /* C/N= 5.0dB */
+	{   55,   7080  }, /* C/N= 5.5dB */
+	{   60,   6720  }, /* C/N= 6.0dB */
+	{   65,   6320  }, /* C/N= 6.5dB */
+	{   70,   6060  }, /* C/N= 7.0dB */
+	{   75,   5760  }, /* C/N= 7.5dB */
+	{   80,   5480  }, /* C/N= 8.0dB */
+	{   85,   5200  }, /* C/N= 8.5dB */
+	{   90,   4930  }, /* C/N= 9.0dB */
+	{   95,   4680  }, /* C/N= 9.5dB */
+	{  100,   4425  }, /* C/N=10.0dB */
+	{  105,   4210  }, /* C/N=10.5dB */
+	{  110,   3980  }, /* C/N=11.0dB */
+	{  115,   3765  }, /* C/N=11.5dB */
+	{  120,   3570  }, /* C/N=12.0dB */
+	{  125,   3315  }, /* C/N=12.5dB */
+	{  130,   3140  }, /* C/N=13.0dB */
+	{  135,   2980  }, /* C/N=13.5dB */
+	{  140,   2820  }, /* C/N=14.0dB */
+	{  145,   2670  }, /* C/N=14.5dB */
+	{  150,   2535  }, /* C/N=15.0dB */
+	{  160,   2270  }, /* C/N=16.0dB */
+	{  170,   2035  }, /* C/N=17.0dB */
+	{  180,   1825  }, /* C/N=18.0dB */
+	{  190,   1650  }, /* C/N=19.0dB */
+	{  200,   1485  }, /* C/N=20.0dB */
+	{  210,   1340  }, /* C/N=21.0dB */
+	{  220,   1212  }, /* C/N=22.0dB */
+	{  230,   1100  }, /* C/N=23.0dB */
+	{  240,   1000  }, /* C/N=24.0dB */
+	{  250,    910  }, /* C/N=25.0dB */
+	{  260,    836  }, /* C/N=26.0dB */
+	{  270,    772  }, /* C/N=27.0dB */
+	{  280,    718  }, /* C/N=28.0dB */
+	{  290,    671  }, /* C/N=29.0dB */
+	{  300,    635  }, /* C/N=30.0dB */
+	{  310,    602  }, /* C/N=31.0dB */
+	{  320,    575  }, /* C/N=32.0dB */
+	{  330,    550  }, /* C/N=33.0dB */
+	{  350,    517  }, /* C/N=35.0dB */
+	{  400,    480  }, /* C/N=40.0dB */
+	{  450,    466  }, /* C/N=45.0dB */
+	{  500,    464  }, /* C/N=50.0dB */
+	{  510,    463  }, /* C/N=51.0dB */
 };
 
-struct slookup padc_lookup[] = {
-	{    0,  118000 }, /* PADC=+0dBm  */
-	{ -100,  93600  }, /* PADC=-1dBm  */
-	{ -200,  74500  }, /* PADC=-2dBm  */
-	{ -300,  59100  }, /* PADC=-3dBm  */
-	{ -400,  47000  }, /* PADC=-4dBm  */
-	{ -500,  37300  }, /* PADC=-5dBm  */
-	{ -600,  29650  }, /* PADC=-6dBm  */
-	{ -700,  23520  }, /* PADC=-7dBm  */
-	{ -900,  14850  }, /* PADC=-9dBm  */
+static struct slookup padc_lookup[] = {
+	{    0,  118000 }, /* PADC= +0dBm */
+	{ -100,  93600  }, /* PADC= -1dBm */
+	{ -200,  74500  }, /* PADC= -2dBm */
+	{ -300,  59100  }, /* PADC= -3dBm */
+	{ -400,  47000  }, /* PADC= -4dBm */
+	{ -500,  37300  }, /* PADC= -5dBm */
+	{ -600,  29650  }, /* PADC= -6dBm */
+	{ -700,  23520  }, /* PADC= -7dBm */
+	{ -900,  14850  }, /* PADC= -9dBm */
 	{ -1100, 9380   }, /* PADC=-11dBm */
 	{ -1300, 5910   }, /* PADC=-13dBm */
 	{ -1500, 3730   }, /* PADC=-15dBm */
@@ -350,7 +350,8 @@ struct slookup padc_lookup[] = {
  * Tracking carrier loop carrier QPSK 1/4 to 8PSK 9/10 long Frame
  *********************************************************************/
 static u8 s2car_loop[] =	{
-	/* Modcod  2MPon 2MPoff 5MPon 5MPoff 10MPon 10MPoff
+	/*
+	 * Modcod  2MPon 2MPoff 5MPon 5MPoff 10MPon 10MPoff
 	 * 20MPon 20MPoff 30MPon 30MPoff
 	 */
 
@@ -393,7 +394,8 @@ static u8 s2car_loop[] =	{
 	 * Tracking carrier loop carrier 16APSK 2/3 to 32APSK 9/10 long Frame
 	 **********************************************************************/
 
-	/* Modcod 2MPon  2MPoff 5MPon 5MPoff 10MPon 10MPoff 20MPon
+	/*
+	 * Modcod 2MPon  2MPoff 5MPon 5MPoff 10MPon 10MPoff 20MPon
 	 * 20MPoff 30MPon 30MPoff
 	 */
 
@@ -692,24 +694,24 @@ static int get_bit_error_rate_s(struct stv *state, u32 *bernumerator,
 static u32 dvbs2_nbch(enum dvbs2_mod_cod mod_cod, enum dvbs2_fectype fectype)
 {
 	static u32 nbch[][2] = {
-		{    0,     0}, /* DUMMY_PLF */
-		{16200,  3240}, /* QPSK_1_4, */
-		{21600,  5400}, /* QPSK_1_3, */
-		{25920,  6480}, /* QPSK_2_5, */
-		{32400,  7200}, /* QPSK_1_2, */
-		{38880,  9720}, /* QPSK_3_5, */
-		{43200, 10800}, /* QPSK_2_3, */
-		{48600, 11880}, /* QPSK_3_4, */
-		{51840, 12600}, /* QPSK_4_5, */
-		{54000, 13320}, /* QPSK_5_6, */
-		{57600, 14400}, /* QPSK_8_9, */
-		{58320, 16000}, /* QPSK_9_10, */
-		{43200,  9720}, /* 8PSK_3_5, */
-		{48600, 10800}, /* 8PSK_2_3, */
-		{51840, 11880}, /* 8PSK_3_4, */
-		{54000, 13320}, /* 8PSK_5_6, */
-		{57600, 14400}, /* 8PSK_8_9, */
-		{58320, 16000}, /* 8PSK_9_10, */
+		{    0,     0}, /* DUMMY_PLF   */
+		{16200,  3240}, /* QPSK_1_4,   */
+		{21600,  5400}, /* QPSK_1_3,   */
+		{25920,  6480}, /* QPSK_2_5,   */
+		{32400,  7200}, /* QPSK_1_2,   */
+		{38880,  9720}, /* QPSK_3_5,   */
+		{43200, 10800}, /* QPSK_2_3,   */
+		{48600, 11880}, /* QPSK_3_4,   */
+		{51840, 12600}, /* QPSK_4_5,   */
+		{54000, 13320}, /* QPSK_5_6,   */
+		{57600, 14400}, /* QPSK_8_9,   */
+		{58320, 16000}, /* QPSK_9_10,  */
+		{43200,  9720}, /* 8PSK_3_5,   */
+		{48600, 10800}, /* 8PSK_2_3,   */
+		{51840, 11880}, /* 8PSK_3_4,   */
+		{54000, 13320}, /* 8PSK_5_6,   */
+		{57600, 14400}, /* 8PSK_8_9,   */
+		{58320, 16000}, /* 8PSK_9_10,  */
 		{43200, 10800}, /* 16APSK_2_3, */
 		{48600, 11880}, /* 16APSK_3_4, */
 		{51840, 12600}, /* 16APSK_4_5, */
@@ -853,7 +855,7 @@ static int stop(struct stv *state)
 		write_reg(state, RSTV0910_P2_TSCFGH + state->regoff,
 			  state->tscfgh | 0x01);
 		read_reg(state, RSTV0910_P2_PDELCTRL1 + state->regoff, &tmp);
-		tmp &= ~0x01; /*release reset DVBS2 packet delin*/
+		tmp &= ~0x01; /* release reset DVBS2 packet delin */
 		write_reg(state, RSTV0910_P2_PDELCTRL1 + state->regoff, tmp);
 		/* Blind optim*/
 		write_reg(state, RSTV0910_P2_AGC2O + state->regoff, 0x5B);
@@ -870,38 +872,38 @@ static int init_search_param(struct stv *state)
 	u8 tmp;
 
 	read_reg(state, RSTV0910_P2_PDELCTRL1 + state->regoff, &tmp);
-	tmp |= 0x20; // Filter_en (no effect if SIS=non-MIS
+	tmp |= 0x20; /* Filter_en (no effect if SIS=non-MIS */
 	write_reg(state, RSTV0910_P2_PDELCTRL1 + state->regoff, tmp);
 
 	read_reg(state, RSTV0910_P2_PDELCTRL2 + state->regoff, &tmp);
-	tmp &= ~0x02; // frame mode = 0
+	tmp &= ~0x02; /* frame mode = 0 */
 	write_reg(state, RSTV0910_P2_PDELCTRL2 + state->regoff, tmp);
 
 	write_reg(state, RSTV0910_P2_UPLCCST0 + state->regoff, 0xe0);
 	write_reg(state, RSTV0910_P2_ISIBITENA + state->regoff, 0x00);
 
 	read_reg(state, RSTV0910_P2_TSSTATEM + state->regoff, &tmp);
-	tmp &= ~0x01; // nosync = 0, in case next signal is standard TS
+	tmp &= ~0x01; /* nosync = 0, in case next signal is standard TS */
 	write_reg(state, RSTV0910_P2_TSSTATEM + state->regoff, tmp);
 
 	read_reg(state, RSTV0910_P2_TSCFGL + state->regoff, &tmp);
-	tmp &= ~0x04; // embindvb = 0
+	tmp &= ~0x04; /* embindvb = 0 */
 	write_reg(state, RSTV0910_P2_TSCFGL + state->regoff, tmp);
 
 	read_reg(state, RSTV0910_P2_TSINSDELH + state->regoff, &tmp);
-	tmp &= ~0x80; // syncbyte = 0
+	tmp &= ~0x80; /* syncbyte = 0 */
 	write_reg(state, RSTV0910_P2_TSINSDELH + state->regoff, tmp);
 
 	read_reg(state, RSTV0910_P2_TSINSDELM + state->regoff, &tmp);
-	tmp &= ~0x08; // token = 0
+	tmp &= ~0x08; /* token = 0 */
 	write_reg(state, RSTV0910_P2_TSINSDELM + state->regoff, tmp);
 
 	read_reg(state, RSTV0910_P2_TSDLYSET2 + state->regoff, &tmp);
-	tmp &= ~0x30; // hysteresis threshold = 0
+	tmp &= ~0x30; /* hysteresis threshold = 0 */
 	write_reg(state, RSTV0910_P2_TSDLYSET2 + state->regoff, tmp);
 
 	read_reg(state, RSTV0910_P2_PDELCTRL0 + state->regoff, &tmp);
-	tmp = (tmp & ~0x30) | 0x10; // isi obs mode = 1, observe min ISI
+	tmp = (tmp & ~0x30) | 0x10; /* isi obs mode = 1, observe min ISI */
 	write_reg(state, RSTV0910_P2_PDELCTRL0 + state->regoff, tmp);
 
 	return 0;
@@ -952,11 +954,11 @@ static int set_vth_default(struct stv *state)
 static int set_vth(struct stv *state)
 {
 	static struct slookup vthlookup_table[] = {
-		{250,	8780}, /*C/N=1.5dB*/
-		{100,	7405}, /*C/N=4.5dB*/
-		{40,	6330}, /*C/N=6.5dB*/
-		{12,	5224}, /*C/N=8.5dB*/
-		{5,	4236} /*C/N=10.5dB*/
+		{250,	8780}, /* C/N= 1.5dB */
+		{100,	7405}, /* C/N= 4.5dB */
+		{40,	6330}, /* C/N= 6.5dB */
+		{12,	5224}, /* C/N= 8.5dB */
+		{5,	4236}  /* C/N=10.5dB */
 	};
 
 	int i;
@@ -1001,7 +1003,8 @@ static int start(struct stv *state, struct dtv_frontend_properties *p)
 	init_search_param(state);
 
 	if (p->stream_id != NO_STREAM_ID_FILTER) {
-		/* Backwards compatibility to "crazy" API.
+		/*
+		 * Backwards compatibility to "crazy" API.
 		 * PRBS X root cannot be 0, so this should always work.
 		 */
 		if (p->stream_id & 0xffffff00)
@@ -1022,22 +1025,22 @@ static int start(struct stv *state, struct dtv_frontend_properties *p)
 		state->cur_scrambling_code = scrambling_code;
 	}
 
-	if (p->symbol_rate <= 1000000) {  /* SR <=1Msps */
+	if (p->symbol_rate <= 1000000) { /* SR <=1Msps */
 		state->demod_timeout = 3000;
 		state->fec_timeout = 2000;
-	} else if (p->symbol_rate <= 2000000) {  /* 1Msps < SR <=2Msps */
+	} else if (p->symbol_rate <= 2000000) { /* 1Msps < SR <=2Msps */
 		state->demod_timeout = 2500;
 		state->fec_timeout = 1300;
-	} else if (p->symbol_rate <= 5000000) {  /* 2Msps< SR <=5Msps */
+	} else if (p->symbol_rate <= 5000000) { /* 2Msps< SR <=5Msps */
 		state->demod_timeout = 1000;
 		state->fec_timeout = 650;
-	} else if (p->symbol_rate <= 10000000) {  /* 5Msps< SR <=10Msps */
+	} else if (p->symbol_rate <= 10000000) { /* 5Msps< SR <=10Msps */
 		state->demod_timeout = 700;
 		state->fec_timeout = 350;
-	} else if (p->symbol_rate < 20000000) {  /* 10Msps< SR <=20Msps */
+	} else if (p->symbol_rate < 20000000) { /* 10Msps< SR <=20Msps */
 		state->demod_timeout = 400;
 		state->fec_timeout = 200;
-	} else {  /* SR >=20Msps */
+	} else { /* SR >=20Msps */
 		state->demod_timeout = 300;
 		state->fec_timeout = 200;
 	}
@@ -1065,7 +1068,7 @@ static int start(struct stv *state, struct dtv_frontend_properties *p)
 
 	enable_puncture_rate(state, FEC_NONE);
 
-	/* 8PSK 3/5, 8PSK 2/3 Poff tracking optimization WA*/
+	/* 8PSK 3/5, 8PSK 2/3 Poff tracking optimization WA */
 	write_reg(state, RSTV0910_P2_ACLC2S2Q + state->regoff, 0x0B);
 	write_reg(state, RSTV0910_P2_ACLC2S28 + state->regoff, 0x0A);
 	write_reg(state, RSTV0910_P2_BCLC2S2Q + state->regoff, 0x84);
@@ -1078,8 +1081,10 @@ static int start(struct stv *state, struct dtv_frontend_properties *p)
 	write_reg(state, RSTV0910_P2_BCLC2S216A + state->regoff, 0x84);
 	write_reg(state, RSTV0910_P2_BCLC2S232A + state->regoff, 0x84);
 
-	/* Reset CAR3, bug DVBS2->DVBS1 lock*/
-	/* Note: The bit is only pulsed -> no lock on shared register needed */
+	/*
+	 * Reset CAR3, bug DVBS2->DVBS1 lock
+	 * Note: The bit is only pulsed -> no lock on shared register needed
+	 */
 	write_reg(state, RSTV0910_TSTRES0, state->nr ? 0x04 : 0x08);
 	write_reg(state, RSTV0910_TSTRES0, 0);
 
@@ -1098,7 +1103,7 @@ static int start(struct stv *state, struct dtv_frontend_properties *p)
 	write_reg(state, RSTV0910_P2_CFRUP1 + state->regoff,
 		  (freq >> 8) & 0xff);
 	write_reg(state, RSTV0910_P2_CFRUP0 + state->regoff, (freq & 0xff));
-	/*CFR Low Setting*/
+	/* CFR Low Setting */
 	freq = -freq;
 	write_reg(state, RSTV0910_P2_CFRLOW1 + state->regoff,
 		  (freq >> 8) & 0xff);
@@ -1120,7 +1125,7 @@ static int start(struct stv *state, struct dtv_frontend_properties *p)
 
 static int init_diseqc(struct stv *state)
 {
-	u16 offs = state->nr ? 0x40 : 0;  /* Address offset */
+	u16 offs = state->nr ? 0x40 : 0; /* Address offset */
 	u8 freq = ((state->base->mclk + 11000 * 32) / (22000 * 32));
 
 	/* Disable receiver */
@@ -1144,26 +1149,26 @@ static int probe(struct stv *state)
 	if (id != 0x51)
 		return -EINVAL;
 
-	 /* Configure the I2C repeater to off */
+	/* Configure the I2C repeater to off */
 	write_reg(state, RSTV0910_P1_I2CRPT, 0x24);
 	/* Configure the I2C repeater to off */
 	write_reg(state, RSTV0910_P2_I2CRPT, 0x24);
 	/* Set the I2C to oversampling ratio */
 	write_reg(state, RSTV0910_I2CCFG, 0x88); /* state->i2ccfg */
 
-	write_reg(state, RSTV0910_OUTCFG,    0x00);  /* OUTCFG */
-	write_reg(state, RSTV0910_PADCFG,    0x05);  /* RFAGC Pads Dev = 05 */
-	write_reg(state, RSTV0910_SYNTCTRL,  0x02);  /* SYNTCTRL */
-	write_reg(state, RSTV0910_TSGENERAL, state->tsgeneral);  /* TSGENERAL */
-	write_reg(state, RSTV0910_CFGEXT,    0x02);  /* CFGEXT */
+	write_reg(state, RSTV0910_OUTCFG,    0x00); /* OUTCFG */
+	write_reg(state, RSTV0910_PADCFG,    0x05); /* RFAGC Pads Dev = 05 */
+	write_reg(state, RSTV0910_SYNTCTRL,  0x02); /* SYNTCTRL */
+	write_reg(state, RSTV0910_TSGENERAL, state->tsgeneral); /* TSGENERAL */
+	write_reg(state, RSTV0910_CFGEXT,    0x02); /* CFGEXT */
 
 	if (state->single)
-		write_reg(state, RSTV0910_GENCFG, 0x14);  /* GENCFG */
+		write_reg(state, RSTV0910_GENCFG, 0x14); /* GENCFG */
 	else
-		write_reg(state, RSTV0910_GENCFG, 0x15);  /* GENCFG */
+		write_reg(state, RSTV0910_GENCFG, 0x15); /* GENCFG */
 
-	write_reg(state, RSTV0910_P1_TNRCFG2, 0x02);  /* IQSWAP = 0 */
-	write_reg(state, RSTV0910_P2_TNRCFG2, 0x82);  /* IQSWAP = 1 */
+	write_reg(state, RSTV0910_P1_TNRCFG2, 0x02); /* IQSWAP = 0 */
+	write_reg(state, RSTV0910_P2_TNRCFG2, 0x82); /* IQSWAP = 1 */
 
 	write_reg(state, RSTV0910_P1_CAR3CFG, 0x02);
 	write_reg(state, RSTV0910_P2_CAR3CFG, 0x02);
@@ -1184,7 +1189,7 @@ static int probe(struct stv *state)
 	/* TS output */
 	write_reg(state, RSTV0910_P1_TSCFGH, state->tscfgh | 0x01);
 	write_reg(state, RSTV0910_P1_TSCFGH, state->tscfgh);
-	write_reg(state, RSTV0910_P1_TSCFGM, 0xC0);  /* Manual speed */
+	write_reg(state, RSTV0910_P1_TSCFGM, 0xC0); /* Manual speed */
 	write_reg(state, RSTV0910_P1_TSCFGL, 0x20);
 
 	/* Speed = 67.5 MHz */
@@ -1192,7 +1197,7 @@ static int probe(struct stv *state)
 
 	write_reg(state, RSTV0910_P2_TSCFGH, state->tscfgh | 0x01);
 	write_reg(state, RSTV0910_P2_TSCFGH, state->tscfgh);
-	write_reg(state, RSTV0910_P2_TSCFGM, 0xC0);  /* Manual speed */
+	write_reg(state, RSTV0910_P2_TSCFGM, 0xC0); /* Manual speed */
 	write_reg(state, RSTV0910_P2_TSCFGL, 0x20);
 
 	/* Speed = 67.5 MHz */
@@ -1425,7 +1430,8 @@ static int read_status(struct dvb_frontend *fe, enum fe_status *status)
 			manage_matype_info(state);
 
 			if (state->receive_mode == RCVMODE_DVBS2) {
-				/* FSTV0910_P2_MANUALSX_ROLLOFF,
+				/*
+				 * FSTV0910_P2_MANUALSX_ROLLOFF,
 				 * FSTV0910_P2_MANUALS2_ROLLOFF = 0
 				 */
 				state->demod_bits &= ~0x84;
@@ -1435,12 +1441,12 @@ static int read_status(struct dvb_frontend *fe, enum fe_status *status)
 				read_reg(state,
 					 RSTV0910_P2_PDELCTRL2 + state->regoff,
 					 &tmp);
-				/*reset DVBS2 packet delinator error counter */
+				/* reset DVBS2 packet delinator error counter */
 				tmp |= 0x40;
 				write_reg(state,
 					  RSTV0910_P2_PDELCTRL2 + state->regoff,
 					  tmp);
-				/*reset DVBS2 packet delinator error counter */
+				/* reset DVBS2 packet delinator error counter */
 				tmp &= ~0x40;
 				write_reg(state,
 					  RSTV0910_P2_PDELCTRL2 + state->regoff,
@@ -1462,11 +1468,12 @@ static int read_status(struct dvb_frontend *fe, enum fe_status *status)
 					  RSTV0910_P2_ERRCTRL1 + state->regoff,
 					  BER_SRC_S | state->berscale);
 			}
-			/*Reset the Total packet counter */
+			/* Reset the Total packet counter */
 			write_reg(state,
 				  RSTV0910_P2_FBERCPT4 + state->regoff, 0x00);
-			/* Reset the packet Error counter2 (and Set it to
-			 * infinit error count mode )
+			/*
+			 * Reset the packet Error counter2 (and Set it to
+			 * infinit error count mode)
 			 */
 			write_reg(state,
 				  RSTV0910_P2_ERRCTRL2 + state->regoff, 0xc1);
@@ -1683,17 +1690,17 @@ static struct dvb_frontend_ops stv0910_ops = {
 					  FE_CAN_MULTISTREAM
 	},
 	.sleep				= sleep,
-	.release                        = release,
-	.i2c_gate_ctrl                  = gate_ctrl,
+	.release			= release,
+	.i2c_gate_ctrl			= gate_ctrl,
 	.set_frontend			= set_parameters,
-	.get_frontend_algo              = get_algo,
-	.get_frontend                   = get_frontend,
-	.tune                           = tune,
+	.get_frontend_algo		= get_algo,
+	.get_frontend			= get_frontend,
+	.tune				= tune,
 	.read_status			= read_status,
 	.set_tone			= set_tone,
 
 	.diseqc_send_master_cmd		= send_master_cmd,
-	.diseqc_send_burst              = send_burst,
+	.diseqc_send_burst		= send_burst,
 };
 
 static struct stv_base *match_base(struct i2c_adapter *i2c, u8 adr)
@@ -1738,8 +1745,8 @@ struct dvb_frontend *stv0910_attach(struct i2c_adapter *i2c,
 	state->nr = nr;
 	state->regoff = state->nr ? 0 : 0x200;
 	state->search_range = 16000000;
-	state->demod_bits = 0x10;     /* Inversion : Auto with reset to 0 */
-	state->receive_mode   = RCVMODE_NONE;
+	state->demod_bits = 0x10; /* Inversion : Auto with reset to 0 */
+	state->receive_mode = RCVMODE_NONE;
 	state->cur_scrambling_code = (~0U);
 	state->single = cfg->single ? 1 : 0;
 
@@ -1767,8 +1774,8 @@ struct dvb_frontend *stv0910_attach(struct i2c_adapter *i2c,
 		}
 		list_add(&base->stvlist, &stvlist);
 	}
-	state->fe.ops               = stv0910_ops;
-	state->fe.demodulator_priv  = state;
+	state->fe.ops = stv0910_ops;
+	state->fe.demodulator_priv = state;
 	state->nr = nr;
 
 	dev_info(&i2c->dev, "%s demod found at adr %02X on %s\n",

commit ddb6a90dcd008c35b2c9a71a97eab69dc4c04b10
Author: Daniel Scheller <d.scheller@gmx.net>
Date:   Sun Jul 23 06:13:11 2017 -0400

    media: dvb-frontends/stv0910: further coding style cleanup
    
    Fixes up all remainders reported by "checkpatch.pl --strict"
    
    Signed-off-by: Daniel Scheller <d.scheller@gmx.net>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/stv0910.c b/drivers/media/dvb-frontends/stv0910.c
index 17c7170d9db9..a0eb4374fe85 100644
--- a/drivers/media/dvb-frontends/stv0910.c
+++ b/drivers/media/dvb-frontends/stv0910.c
@@ -71,7 +71,7 @@ static inline u32 muldiv32(u32 a, u32 b, u32 c)
 	tmp64 = (u64)a * (u64)b;
 	do_div(tmp64, c);
 
-	return (u32) tmp64;
+	return (u32)tmp64;
 }
 
 struct stv_base {
@@ -79,8 +79,8 @@ struct stv_base {
 
 	u8                   adr;
 	struct i2c_adapter  *i2c;
-	struct mutex         i2c_lock;
-	struct mutex         reg_lock;
+	struct mutex         i2c_lock; /* shared I2C access protect */
+	struct mutex         reg_lock; /* shared register write protect */
 	int                  count;
 
 	u32                  extclk;
@@ -146,8 +146,8 @@ static inline int i2c_write(struct i2c_adapter *adap, u8 adr,
 
 	if (i2c_transfer(adap, &msg, 1) != 1) {
 		dev_warn(&adap->dev, "i2c write error ([%02x] %04x: %02x)\n",
-			adr, (data[0] << 8) | data[1],
-			(len > 2 ? data[2] : 0));
+			 adr, (data[0] << 8) | data[1],
+			 (len > 2 ? data[2] : 0));
 		return -EREMOTEIO;
 	}
 	return 0;
@@ -166,7 +166,7 @@ static int write_reg(struct stv *state, u16 reg, u8 val)
 }
 
 static inline int i2c_read_regs16(struct i2c_adapter *adapter, u8 adr,
-				 u16 reg, u8 *val, int count)
+				  u16 reg, u8 *val, int count)
 {
 	u8 msg[2] = {reg >> 8, reg & 0xff};
 	struct i2c_msg msgs[2] = {{.addr = adr, .flags = 0,
@@ -176,7 +176,7 @@ static inline int i2c_read_regs16(struct i2c_adapter *adapter, u8 adr,
 
 	if (i2c_transfer(adapter, msgs, 2) != 2) {
 		dev_warn(&adapter->dev, "i2c read error ([%02x] %04x)\n",
-			adr, reg);
+			 adr, reg);
 		return -EREMOTEIO;
 	}
 	return 0;
@@ -185,7 +185,7 @@ static inline int i2c_read_regs16(struct i2c_adapter *adapter, u8 adr,
 static int read_reg(struct stv *state, u16 reg, u8 *val)
 {
 	return i2c_read_regs16(state->base->i2c, state->base->adr,
-		reg, val, 1);
+			       reg, val, 1);
 }
 
 static int read_regs(struct stv *state, u16 reg, u8 *val, int len)
@@ -473,16 +473,16 @@ static int get_cur_symbol_rate(struct stv *state, u32 *p_symbol_rate)
 	read_reg(state, RSTV0910_P2_TMGREG1 + state->regoff, &tim_offs1);
 	read_reg(state, RSTV0910_P2_TMGREG0 + state->regoff, &tim_offs0);
 
-	symbol_rate = ((u32) symb_freq3 << 24) | ((u32) symb_freq2 << 16) |
-		((u32) symb_freq1 << 8) | (u32) symb_freq0;
-	timing_offset = ((u32) tim_offs2 << 16) | ((u32) tim_offs1 << 8) |
-		(u32) tim_offs0;
+	symbol_rate = ((u32)symb_freq3 << 24) | ((u32)symb_freq2 << 16) |
+		((u32)symb_freq1 << 8) | (u32)symb_freq0;
+	timing_offset = ((u32)tim_offs2 << 16) | ((u32)tim_offs1 << 8) |
+		(u32)tim_offs0;
 
-	if ((timing_offset & (1<<23)) != 0)
+	if ((timing_offset & (1 << 23)) != 0)
 		timing_offset |= 0xFF000000; /* Sign extent */
 
-	symbol_rate = (u32) (((u64) symbol_rate * state->base->mclk) >> 32);
-	timing_offset = (s32) (((s64) symbol_rate * (s64) timing_offset) >> 29);
+	symbol_rate = (u32)(((u64)symbol_rate * state->base->mclk) >> 32);
+	timing_offset = (s32)(((s64)symbol_rate * (s64)timing_offset) >> 29);
 
 	*p_symbol_rate = symbol_rate + timing_offset;
 
@@ -498,9 +498,9 @@ static int get_signal_parameters(struct stv *state)
 
 	if (state->receive_mode == RCVMODE_DVBS2) {
 		read_reg(state, RSTV0910_P2_DMDMODCOD + state->regoff, &tmp);
-		state->mod_cod = (enum fe_stv0910_mod_cod) ((tmp & 0x7c) >> 2);
+		state->mod_cod = (enum fe_stv0910_mod_cod)((tmp & 0x7c) >> 2);
 		state->pilots = (tmp & 0x01) != 0;
-		state->fectype = (enum dvbs2_fectype) ((tmp & 0x02) >> 1);
+		state->fectype = (enum dvbs2_fectype)((tmp & 0x02) >> 1);
 
 	} else if (state->receive_mode == RCVMODE_DVBS) {
 		read_reg(state, RSTV0910_P2_VITCURPUN + state->regoff, &tmp);
@@ -586,7 +586,7 @@ static int tracking_optimization(struct stv *state)
 }
 
 static s32 table_lookup(struct slookup *table,
-		       int table_size, u32 reg_value)
+			int table_size, u32 reg_value)
 {
 	s32 value;
 	int imin = 0;
@@ -595,15 +595,15 @@ static s32 table_lookup(struct slookup *table,
 	s32 reg_diff;
 
 	/* Assumes Table[0].RegValue > Table[imax].RegValue */
-	if (reg_value >= table[0].reg_value)
+	if (reg_value >= table[0].reg_value) {
 		value = table[0].value;
-	else if (reg_value <= table[imax].reg_value)
+	} else if (reg_value <= table[imax].reg_value) {
 		value = table[imax].value;
-	else {
-		while (imax-imin > 1) {
+	} else {
+		while ((imax - imin) > 1) {
 			i = (imax + imin) / 2;
 			if ((table[imin].reg_value >= reg_value) &&
-				(reg_value >= table[i].reg_value))
+			    (reg_value >= table[i].reg_value))
 				imax = i;
 			else
 				imin = i;
@@ -649,13 +649,13 @@ static int get_signal_to_noise(struct stv *state, s32 *signal_to_noise)
 		n_lookup = ARRAY_SIZE(s1_sn_lookup);
 		lookup = s1_sn_lookup;
 	}
-	data = (((u16)data1) << 8) | (u16) data0;
+	data = (((u16)data1) << 8) | (u16)data0;
 	*signal_to_noise = table_lookup(lookup, n_lookup, data);
 	return 0;
 }
 
 static int get_bit_error_rate_s(struct stv *state, u32 *bernumerator,
-			    u32 *berdenominator)
+				u32 *berdenominator)
 {
 	u8 regs[3];
 
@@ -669,8 +669,8 @@ static int get_bit_error_rate_s(struct stv *state, u32 *bernumerator,
 	if ((regs[0] & 0x80) == 0) {
 		state->last_berdenominator = 1 << ((state->berscale * 2) +
 						  10 + 3);
-		state->last_bernumerator = ((u32) (regs[0] & 0x7F) << 16) |
-			((u32) regs[1] << 8) | regs[2];
+		state->last_bernumerator = ((u32)(regs[0] & 0x7F) << 16) |
+			((u32)regs[1] << 8) | regs[2];
 		if (state->last_bernumerator < 256 && state->berscale < 6) {
 			state->berscale += 1;
 			status = write_reg(state, RSTV0910_P2_ERRCTRL1 +
@@ -730,7 +730,7 @@ static u32 dvbs2_nbch(enum dvbs2_mod_cod mod_cod, enum dvbs2_fectype fectype)
 }
 
 static int get_bit_error_rate_s2(struct stv *state, u32 *bernumerator,
-			     u32 *berdenominator)
+				 u32 *berdenominator)
 {
 	u8 regs[3];
 
@@ -742,11 +742,11 @@ static int get_bit_error_rate_s2(struct stv *state, u32 *bernumerator,
 
 	if ((regs[0] & 0x80) == 0) {
 		state->last_berdenominator =
-			dvbs2_nbch((enum dvbs2_mod_cod) state->mod_cod,
+			dvbs2_nbch((enum dvbs2_mod_cod)state->mod_cod,
 				   state->fectype) <<
 			(state->berscale * 2);
-		state->last_bernumerator = (((u32) regs[0] & 0x7F) << 16) |
-			((u32) regs[1] << 8) | regs[2];
+		state->last_bernumerator = (((u32)regs[0] & 0x7F) << 16) |
+			((u32)regs[1] << 8) | regs[2];
 		if (state->last_bernumerator < 256 && state->berscale < 6) {
 			state->berscale += 1;
 			write_reg(state, RSTV0910_P2_ERRCTRL1 + state->regoff,
@@ -764,7 +764,7 @@ static int get_bit_error_rate_s2(struct stv *state, u32 *bernumerator,
 }
 
 static int get_bit_error_rate(struct stv *state, u32 *bernumerator,
-			   u32 *berdenominator)
+			      u32 *berdenominator)
 {
 	*bernumerator = 0;
 	*berdenominator = 1;
@@ -1211,7 +1211,6 @@ static int probe(struct stv *state)
 	return 0;
 }
 
-
 static int gate_ctrl(struct dvb_frontend *fe, int enable)
 {
 	struct stv *state = fe->demodulator_priv;
@@ -1273,9 +1272,9 @@ static int manage_matype_info(struct stv *state)
 		u8 bbheader[2];
 
 		read_regs(state, RSTV0910_P2_MATSTR1 + state->regoff,
-			bbheader, 2);
+			  bbheader, 2);
 		state->feroll_off =
-			(enum fe_stv0910_roll_off) (bbheader[0] & 0x03);
+			(enum fe_stv0910_roll_off)(bbheader[0] & 0x03);
 		state->is_vcm = (bbheader[0] & 0x10) == 0;
 		state->is_standard_broadcast = (bbheader[0] & 0xFC) == 0xF0;
 	} else if (state->receive_mode == RCVMODE_DVBS) {
@@ -1295,8 +1294,9 @@ static int read_snr(struct dvb_frontend *fe)
 	if (!get_signal_to_noise(state, &snrval)) {
 		p->cnr.stat[0].scale = FE_SCALE_DECIBEL;
 		p->cnr.stat[0].uvalue = 100 * snrval; /* fix scale */
-	} else
+	} else {
 		p->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	}
 
 	return 0;
 }
@@ -1328,12 +1328,12 @@ static void read_signal_strength(struct dvb_frontend *fe)
 
 	read_regs(state, RSTV0910_P2_AGCIQIN1 + state->regoff, reg, 2);
 
-	agc = (((u32) reg[0]) << 8) | reg[1];
+	agc = (((u32)reg[0]) << 8) | reg[1];
 
 	for (i = 0; i < 5; i += 1) {
 		read_regs(state, RSTV0910_P2_POWERI + state->regoff, reg, 2);
-		power += (u32) reg[0] * (u32) reg[0]
-			+ (u32) reg[1] * (u32) reg[1];
+		power += (u32)reg[0] * (u32)reg[0]
+			+ (u32)reg[1] * (u32)reg[1];
 		usleep_range(3000, 4000);
 	}
 	power /= 5;
@@ -1490,9 +1490,9 @@ static int read_status(struct dvb_frontend *fe, enum fe_status *status)
 		p->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
 
 	/* read ber */
-	if (*status & FE_HAS_VITERBI)
+	if (*status & FE_HAS_VITERBI) {
 		read_ber(fe);
-	else {
+	} else {
 		p->pre_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
 		p->pre_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
 	}
@@ -1584,7 +1584,6 @@ static int tune(struct dvb_frontend *fe, bool re_tune,
 	return 0;
 }
 
-
 static int get_algo(struct dvb_frontend *fe)
 {
 	return DVBFE_ALGO_HW;
@@ -1697,7 +1696,7 @@ static struct dvb_frontend_ops stv0910_ops = {
 	.diseqc_send_burst              = send_burst,
 };
 
-static struct stv_base *match_base(struct i2c_adapter  *i2c, u8 adr)
+static struct stv_base *match_base(struct i2c_adapter *i2c, u8 adr)
 {
 	struct stv_base *p;
 
@@ -1728,7 +1727,7 @@ struct dvb_frontend *stv0910_attach(struct i2c_adapter *i2c,
 	struct stv *state;
 	struct stv_base *base;
 
-	state = kzalloc(sizeof(struct stv), GFP_KERNEL);
+	state = kzalloc(sizeof(*state), GFP_KERNEL);
 	if (!state)
 		return NULL;
 
@@ -1749,7 +1748,7 @@ struct dvb_frontend *stv0910_attach(struct i2c_adapter *i2c,
 		base->count++;
 		state->base = base;
 	} else {
-		base = kzalloc(sizeof(struct stv_base), GFP_KERNEL);
+		base = kzalloc(sizeof(*base), GFP_KERNEL);
 		if (!base)
 			goto fail;
 		base->i2c = i2c;
@@ -1762,7 +1761,7 @@ struct dvb_frontend *stv0910_attach(struct i2c_adapter *i2c,
 		state->base = base;
 		if (probe(state) < 0) {
 			dev_info(&i2c->dev, "No demod found at adr %02X on %s\n",
-				cfg->adr, dev_name(&i2c->dev));
+				 cfg->adr, dev_name(&i2c->dev));
 			kfree(base);
 			goto fail;
 		}
@@ -1773,7 +1772,7 @@ struct dvb_frontend *stv0910_attach(struct i2c_adapter *i2c,
 	state->nr = nr;
 
 	dev_info(&i2c->dev, "%s demod found at adr %02X on %s\n",
-		state->fe.ops.info.name, cfg->adr, dev_name(&i2c->dev));
+		 state->fe.ops.info.name, cfg->adr, dev_name(&i2c->dev));
 
 	stv0910_init_stats(state);
 

commit 448461af0e19ca2cc91694f41735c87854df4dd9
Author: Daniel Scheller <d.scheller@gmx.net>
Date:   Sun Jul 23 06:13:10 2017 -0400

    media: dvb-frontends/stv0910: implement diseqc_send_burst
    
    This implements the diseqc_send_burst frontend op to support sending
    mini-DISEQC bursts. Picked up from dddvb's driver package where this
    specific block was disabled via #if 0/#endif, but is still working
    according to feedback from upstream, so add it.
    
    Signed-off-by: Daniel Scheller <d.scheller@gmx.net>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/stv0910.c b/drivers/media/dvb-frontends/stv0910.c
index b596ec5f309f..17c7170d9db9 100644
--- a/drivers/media/dvb-frontends/stv0910.c
+++ b/drivers/media/dvb-frontends/stv0910.c
@@ -1638,6 +1638,27 @@ static int send_master_cmd(struct dvb_frontend *fe,
 	return 0;
 }
 
+static int send_burst(struct dvb_frontend *fe, enum fe_sec_mini_cmd burst)
+{
+	struct stv *state = fe->demodulator_priv;
+	u16 offs = state->nr ? 0x40 : 0;
+	u8 value;
+
+	if (burst == SEC_MINI_A) {
+		write_reg(state, RSTV0910_P1_DISTXCFG + offs, 0x3F);
+		value = 0x00;
+	} else {
+		write_reg(state, RSTV0910_P1_DISTXCFG + offs, 0x3E);
+		value = 0xFF;
+	}
+	wait_dis(state, 0x40, 0x00);
+	write_reg(state, RSTV0910_P1_DISTXFIFO + offs, value);
+	write_reg(state, RSTV0910_P1_DISTXCFG + offs, 0x3A);
+	wait_dis(state, 0x20, 0x20);
+
+	return 0;
+}
+
 static int sleep(struct dvb_frontend *fe)
 {
 	struct stv *state = fe->demodulator_priv;
@@ -1673,6 +1694,7 @@ static struct dvb_frontend_ops stv0910_ops = {
 	.set_tone			= set_tone,
 
 	.diseqc_send_master_cmd		= send_master_cmd,
+	.diseqc_send_burst              = send_burst,
 };
 
 static struct stv_base *match_base(struct i2c_adapter  *i2c, u8 adr)

commit 399196ed0643c1067e19bb116e05608d3d5ecff3
Author: Daniel Scheller <d.scheller@gmx.net>
Date:   Sun Jul 23 06:13:09 2017 -0400

    media: dvb-frontends/stv0910: fix STR assignment, remove unneeded var
    
    According to the documentation, FE_SCALE_DECIBEL values should be assigned
    to .svalue and not .uvalue, so let's do this. While at it, remove the
    unneeded strength var from read_signal_strength().
    
    Signed-off-by: Daniel Scheller <d.scheller@gmx.net>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/stv0910.c b/drivers/media/dvb-frontends/stv0910.c
index 7e8a460449c5..b596ec5f309f 100644
--- a/drivers/media/dvb-frontends/stv0910.c
+++ b/drivers/media/dvb-frontends/stv0910.c
@@ -1321,7 +1321,6 @@ static void read_signal_strength(struct dvb_frontend *fe)
 {
 	struct stv *state = fe->demodulator_priv;
 	struct dtv_frontend_properties *p = &state->fe.dtv_property_cache;
-	s64 strength;
 	u8 reg[2];
 	u16 agc;
 	s32 padc, power = 0;
@@ -1341,10 +1340,8 @@ static void read_signal_strength(struct dvb_frontend *fe)
 
 	padc = table_lookup(padc_lookup, ARRAY_SIZE(padc_lookup), power) + 352;
 
-	strength = (padc - agc);
-
 	p->strength.stat[0].scale = FE_SCALE_DECIBEL;
-	p->strength.stat[0].uvalue = strength;
+	p->strength.stat[0].svalue = (padc - agc);
 }
 
 static int read_status(struct dvb_frontend *fe, enum fe_status *status)

commit 2f4675c00375864007968236b8f1fa6b636a809a
Author: Daniel Scheller <d.scheller@gmx.net>
Date:   Mon Jul 3 13:20:58 2017 -0400

    media: dvb-frontends/stv0910: Add missing set_frontend fe-op
    
    This was missing from the frontend_ops.
    
    Signed-off-by: Daniel Scheller <d.scheller@gmx.net>
    Tested-by: Richard Scobie <r.scobie@clear.net.nz>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/stv0910.c b/drivers/media/dvb-frontends/stv0910.c
index dc4d829bb47a..7e8a460449c5 100644
--- a/drivers/media/dvb-frontends/stv0910.c
+++ b/drivers/media/dvb-frontends/stv0910.c
@@ -1668,6 +1668,7 @@ static struct dvb_frontend_ops stv0910_ops = {
 	.sleep				= sleep,
 	.release                        = release,
 	.i2c_gate_ctrl                  = gate_ctrl,
+	.set_frontend			= set_parameters,
 	.get_frontend_algo              = get_algo,
 	.get_frontend                   = get_frontend,
 	.tune                           = tune,

commit 19bb3b718f02ff2fa38e3222cf62c9c3f46d2527
Author: Daniel Scheller <d.scheller@gmx.net>
Date:   Mon Jul 3 13:20:57 2017 -0400

    media: dvb-frontends/stv0910: Add demod-only signal strength reporting
    
    Original code at least has some signed/unsigned issues, resulting in
    values like 32dBm. Implement signal strength readout to work without
    asking the attached tuner, and use a lookup table instead of log calc.
    Values reported appear plausible, gathered from feedback from several
    testers.
    
    Signed-off-by: Daniel Scheller <d.scheller@gmx.net>
    Tested-by: Richard Scobie <r.scobie@clear.net.nz>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/stv0910.c b/drivers/media/dvb-frontends/stv0910.c
index dc848ebe1a44..dc4d829bb47a 100644
--- a/drivers/media/dvb-frontends/stv0910.c
+++ b/drivers/media/dvb-frontends/stv0910.c
@@ -135,7 +135,7 @@ struct sinit_table {
 
 struct slookup {
 	s16  value;
-	u16  reg_value;
+	u32  reg_value;
 };
 
 static inline int i2c_write(struct i2c_adapter *adap, u8 adr,
@@ -327,6 +327,25 @@ struct slookup s2_sn_lookup[] = {
 	{  510,    463  },  /*C/N=51.0dB*/
 };
 
+struct slookup padc_lookup[] = {
+	{    0,  118000 }, /* PADC=+0dBm  */
+	{ -100,  93600  }, /* PADC=-1dBm  */
+	{ -200,  74500  }, /* PADC=-2dBm  */
+	{ -300,  59100  }, /* PADC=-3dBm  */
+	{ -400,  47000  }, /* PADC=-4dBm  */
+	{ -500,  37300  }, /* PADC=-5dBm  */
+	{ -600,  29650  }, /* PADC=-6dBm  */
+	{ -700,  23520  }, /* PADC=-7dBm  */
+	{ -900,  14850  }, /* PADC=-9dBm  */
+	{ -1100, 9380   }, /* PADC=-11dBm */
+	{ -1300, 5910   }, /* PADC=-13dBm */
+	{ -1500, 3730   }, /* PADC=-15dBm */
+	{ -1700, 2354   }, /* PADC=-17dBm */
+	{ -1900, 1485   }, /* PADC=-19dBm */
+	{ -2000, 1179   }, /* PADC=-20dBm */
+	{ -2100, 1000   }, /* PADC=-21dBm */
+};
+
 /*********************************************************************
  * Tracking carrier loop carrier QPSK 1/4 to 8PSK 9/10 long Frame
  *********************************************************************/
@@ -567,7 +586,7 @@ static int tracking_optimization(struct stv *state)
 }
 
 static s32 table_lookup(struct slookup *table,
-		       int table_size, u16 reg_value)
+		       int table_size, u32 reg_value)
 {
 	s32 value;
 	int imin = 0;
@@ -1300,11 +1319,32 @@ static int read_ber(struct dvb_frontend *fe)
 
 static void read_signal_strength(struct dvb_frontend *fe)
 {
-	/* FIXME: add signal strength algo */
 	struct stv *state = fe->demodulator_priv;
 	struct dtv_frontend_properties *p = &state->fe.dtv_property_cache;
+	s64 strength;
+	u8 reg[2];
+	u16 agc;
+	s32 padc, power = 0;
+	int i;
 
-	p->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	read_regs(state, RSTV0910_P2_AGCIQIN1 + state->regoff, reg, 2);
+
+	agc = (((u32) reg[0]) << 8) | reg[1];
+
+	for (i = 0; i < 5; i += 1) {
+		read_regs(state, RSTV0910_P2_POWERI + state->regoff, reg, 2);
+		power += (u32) reg[0] * (u32) reg[0]
+			+ (u32) reg[1] * (u32) reg[1];
+		usleep_range(3000, 4000);
+	}
+	power /= 5;
+
+	padc = table_lookup(padc_lookup, ARRAY_SIZE(padc_lookup), power) + 352;
+
+	strength = (padc - agc);
+
+	p->strength.stat[0].scale = FE_SCALE_DECIBEL;
+	p->strength.stat[0].uvalue = strength;
 }
 
 static int read_status(struct dvb_frontend *fe, enum fe_status *status)

commit ea71c62bdef59004a2fd835545cd02bbeb699f83
Author: Daniel Scheller <d.scheller@gmx.net>
Date:   Mon Jul 3 13:20:56 2017 -0400

    media: dvb-frontends/stv0910: add multistream (ISI) and PLS capabilities
    
    Implements stream_id filter and scrambling code setup in start() and also
    sets FE_CAN_MULTISTREAM in frontend_ops. This enables the driver to
    properly receive and handle multistream transponders, functionality has
    been reported working fine by testers with access to such streams, in
    conjunction with VDR on the userspace side.
    
    The code snippet originates from the original vendor's dddvb driver
    package and has been made working properly with the current in-kernel
    DVB core API.
    
    Signed-off-by: Daniel Scheller <d.scheller@gmx.net>
    Tested-by: Richard Scobie <r.scobie@clear.net.nz>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/stv0910.c b/drivers/media/dvb-frontends/stv0910.c
index 85439d3b725e..dc848ebe1a44 100644
--- a/drivers/media/dvb-frontends/stv0910.c
+++ b/drivers/media/dvb-frontends/stv0910.c
@@ -119,6 +119,8 @@ struct stv {
 	int   is_standard_broadcast;
 	int   is_vcm;
 
+	u32   cur_scrambling_code;
+
 	u32   last_bernumerator;
 	u32   last_berdenominator;
 	u8    berscale;
@@ -965,6 +967,7 @@ static int start(struct stv *state, struct dtv_frontend_properties *p)
 	s32 freq;
 	u8  reg_dmdcfgmd;
 	u16 symb;
+	u32 scrambling_code = 1;
 
 	if (p->symbol_rate < 100000 || p->symbol_rate > 70000000)
 		return -EINVAL;
@@ -978,6 +981,28 @@ static int start(struct stv *state, struct dtv_frontend_properties *p)
 
 	init_search_param(state);
 
+	if (p->stream_id != NO_STREAM_ID_FILTER) {
+		/* Backwards compatibility to "crazy" API.
+		 * PRBS X root cannot be 0, so this should always work.
+		 */
+		if (p->stream_id & 0xffffff00)
+			scrambling_code = p->stream_id >> 8;
+		write_reg(state, RSTV0910_P2_ISIENTRY + state->regoff,
+			  p->stream_id & 0xff);
+		write_reg(state, RSTV0910_P2_ISIBITENA + state->regoff,
+			  0xff);
+	}
+
+	if (scrambling_code != state->cur_scrambling_code) {
+		write_reg(state, RSTV0910_P2_PLROOT0 + state->regoff,
+			  scrambling_code & 0xff);
+		write_reg(state, RSTV0910_P2_PLROOT1 + state->regoff,
+			  (scrambling_code >> 8) & 0xff);
+		write_reg(state, RSTV0910_P2_PLROOT2 + state->regoff,
+			  (scrambling_code >> 16) & 0x07);
+		state->cur_scrambling_code = scrambling_code;
+	}
+
 	if (p->symbol_rate <= 1000000) {  /* SR <=1Msps */
 		state->demod_timeout = 3000;
 		state->fec_timeout = 2000;
@@ -1597,7 +1622,8 @@ static struct dvb_frontend_ops stv0910_ops = {
 		.caps			= FE_CAN_INVERSION_AUTO |
 					  FE_CAN_FEC_AUTO       |
 					  FE_CAN_QPSK           |
-					  FE_CAN_2G_MODULATION
+					  FE_CAN_2G_MODULATION  |
+					  FE_CAN_MULTISTREAM
 	},
 	.sleep				= sleep,
 	.release                        = release,
@@ -1655,6 +1681,7 @@ struct dvb_frontend *stv0910_attach(struct i2c_adapter *i2c,
 	state->search_range = 16000000;
 	state->demod_bits = 0x10;     /* Inversion : Auto with reset to 0 */
 	state->receive_mode   = RCVMODE_NONE;
+	state->cur_scrambling_code = (~0U);
 	state->single = cfg->single ? 1 : 0;
 
 	base = match_base(i2c, cfg->adr);

commit 13c81489622b866f4b4fcbd51707ab4c09e1c8db
Author: Daniel Scheller <d.scheller@gmx.net>
Date:   Mon Jul 3 13:20:55 2017 -0400

    media: dvb-frontends/stv0910: Fix possible buffer overflow
    
    Fixes smatch error:
    
      drivers/media/dvb-frontends/stv0910.c:715 dvbs2_nbch() error: buffer overflow 'nbch[fectype]' 2 <= 28
    
    Also, fixes the nbch array table by adding the DUMMY_PLF element at the top
    to match the enums (table element order was off by one before).
    
    Patch sent upstream aswell.
    
    Cc: Ralph Metzler <rjkm@metzlerbros.de>
    Signed-off-by: Daniel Scheller <d.scheller@gmx.net>
    Tested-by: Richard Scobie <r.scobie@clear.net.nz>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/stv0910.c b/drivers/media/dvb-frontends/stv0910.c
index 9dfcaf5e067f..85439d3b725e 100644
--- a/drivers/media/dvb-frontends/stv0910.c
+++ b/drivers/media/dvb-frontends/stv0910.c
@@ -671,6 +671,7 @@ static int get_bit_error_rate_s(struct stv *state, u32 *bernumerator,
 static u32 dvbs2_nbch(enum dvbs2_mod_cod mod_cod, enum dvbs2_fectype fectype)
 {
 	static u32 nbch[][2] = {
+		{    0,     0}, /* DUMMY_PLF */
 		{16200,  3240}, /* QPSK_1_4, */
 		{21600,  5400}, /* QPSK_1_3, */
 		{25920,  6480}, /* QPSK_2_5, */
@@ -703,7 +704,7 @@ static u32 dvbs2_nbch(enum dvbs2_mod_cod mod_cod, enum dvbs2_fectype fectype)
 
 	if (mod_cod >= DVBS2_QPSK_1_4 &&
 	    mod_cod <= DVBS2_32APSK_9_10 && fectype <= DVBS2_16K)
-		return nbch[fectype][mod_cod];
+		return nbch[mod_cod][fectype];
 	return 64800;
 }
 

commit cd21b334943719f880e707eb91895fc916a88000
Author: Daniel Scheller <d.scheller@gmx.net>
Date:   Mon Jul 3 13:20:54 2017 -0400

    media: dvb-frontends: add ST STV0910 DVB-S/S2 demodulator frontend driver
    
    This adds a multi frontend driver for the ST STV0910 DVB-S/S2 demodulator
    frontends. The driver code originates from the Digital Devices' dddvb
    vendor driver package as of version 0.9.29, and has been cleaned up from
    core API usage which isn't supported yet in the kernel, and additionally
    all obvious style issues have been resolved. All camel case and allcaps
    have been converted to kernel_case and lowercase. Patches have been sent
    to the vendor package maintainers to fix this aswell. Signal statistics
    acquisition has been refactored to comply with standards.
    
    Permission to reuse and mainline the driver code was formally granted by
    Ralph Metzler <rjkm@metzlerbros.de>.
    
    Signed-off-by: Daniel Scheller <d.scheller@gmx.net>
    Tested-by: Richard Scobie <r.scobie@clear.net.nz>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/stv0910.c b/drivers/media/dvb-frontends/stv0910.c
new file mode 100644
index 000000000000..9dfcaf5e067f
--- /dev/null
+++ b/drivers/media/dvb-frontends/stv0910.c
@@ -0,0 +1,1702 @@
+/*
+ * Driver for the ST STV0910 DVB-S/S2 demodulator.
+ *
+ * Copyright (C) 2014-2015 Ralph Metzler <rjkm@metzlerbros.de>
+ *                         Marcus Metzler <mocm@metzlerbros.de>
+ *                         developed for Digital Devices GmbH
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 only, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/firmware.h>
+#include <linux/i2c.h>
+#include <asm/div64.h>
+
+#include "dvb_math.h"
+#include "dvb_frontend.h"
+#include "stv0910.h"
+#include "stv0910_regs.h"
+
+#define EXT_CLOCK    30000000
+#define TUNING_DELAY 200
+#define BER_SRC_S    0x20
+#define BER_SRC_S2   0x20
+
+LIST_HEAD(stvlist);
+
+enum receive_mode { RCVMODE_NONE, RCVMODE_DVBS, RCVMODE_DVBS2, RCVMODE_AUTO };
+
+enum dvbs2_fectype { DVBS2_64K, DVBS2_16K };
+
+enum dvbs2_mod_cod {
+	DVBS2_DUMMY_PLF, DVBS2_QPSK_1_4, DVBS2_QPSK_1_3, DVBS2_QPSK_2_5,
+	DVBS2_QPSK_1_2, DVBS2_QPSK_3_5, DVBS2_QPSK_2_3,	DVBS2_QPSK_3_4,
+	DVBS2_QPSK_4_5,	DVBS2_QPSK_5_6,	DVBS2_QPSK_8_9,	DVBS2_QPSK_9_10,
+	DVBS2_8PSK_3_5,	DVBS2_8PSK_2_3,	DVBS2_8PSK_3_4,	DVBS2_8PSK_5_6,
+	DVBS2_8PSK_8_9,	DVBS2_8PSK_9_10, DVBS2_16APSK_2_3, DVBS2_16APSK_3_4,
+	DVBS2_16APSK_4_5, DVBS2_16APSK_5_6, DVBS2_16APSK_8_9, DVBS2_16APSK_9_10,
+	DVBS2_32APSK_3_4, DVBS2_32APSK_4_5, DVBS2_32APSK_5_6, DVBS2_32APSK_8_9,
+	DVBS2_32APSK_9_10
+};
+
+enum fe_stv0910_mod_cod {
+	FE_DUMMY_PLF, FE_QPSK_14, FE_QPSK_13, FE_QPSK_25,
+	FE_QPSK_12, FE_QPSK_35, FE_QPSK_23, FE_QPSK_34,
+	FE_QPSK_45, FE_QPSK_56, FE_QPSK_89, FE_QPSK_910,
+	FE_8PSK_35, FE_8PSK_23, FE_8PSK_34, FE_8PSK_56,
+	FE_8PSK_89, FE_8PSK_910, FE_16APSK_23, FE_16APSK_34,
+	FE_16APSK_45, FE_16APSK_56, FE_16APSK_89, FE_16APSK_910,
+	FE_32APSK_34, FE_32APSK_45, FE_32APSK_56, FE_32APSK_89,
+	FE_32APSK_910
+};
+
+enum fe_stv0910_roll_off { FE_SAT_35, FE_SAT_25, FE_SAT_20, FE_SAT_15 };
+
+static inline u32 muldiv32(u32 a, u32 b, u32 c)
+{
+	u64 tmp64;
+
+	tmp64 = (u64)a * (u64)b;
+	do_div(tmp64, c);
+
+	return (u32) tmp64;
+}
+
+struct stv_base {
+	struct list_head     stvlist;
+
+	u8                   adr;
+	struct i2c_adapter  *i2c;
+	struct mutex         i2c_lock;
+	struct mutex         reg_lock;
+	int                  count;
+
+	u32                  extclk;
+	u32                  mclk;
+};
+
+struct stv {
+	struct stv_base     *base;
+	struct dvb_frontend  fe;
+	int                  nr;
+	u16                  regoff;
+	u8                   i2crpt;
+	u8                   tscfgh;
+	u8                   tsgeneral;
+	u8                   tsspeed;
+	u8                   single;
+	unsigned long        tune_time;
+
+	s32                  search_range;
+	u32                  started;
+	u32                  demod_lock_time;
+	enum receive_mode    receive_mode;
+	u32                  demod_timeout;
+	u32                  fec_timeout;
+	u32                  first_time_lock;
+	u8                   demod_bits;
+	u32                  symbol_rate;
+
+	u8                       last_viterbi_rate;
+	enum fe_code_rate        puncture_rate;
+	enum fe_stv0910_mod_cod  mod_cod;
+	enum dvbs2_fectype       fectype;
+	u32                      pilots;
+	enum fe_stv0910_roll_off feroll_off;
+
+	int   is_standard_broadcast;
+	int   is_vcm;
+
+	u32   last_bernumerator;
+	u32   last_berdenominator;
+	u8    berscale;
+
+	u8    vth[6];
+};
+
+struct sinit_table {
+	u16  address;
+	u8   data;
+};
+
+struct slookup {
+	s16  value;
+	u16  reg_value;
+};
+
+static inline int i2c_write(struct i2c_adapter *adap, u8 adr,
+			    u8 *data, int len)
+{
+	struct i2c_msg msg = {.addr = adr, .flags = 0,
+			      .buf = data, .len = len};
+
+	if (i2c_transfer(adap, &msg, 1) != 1) {
+		dev_warn(&adap->dev, "i2c write error ([%02x] %04x: %02x)\n",
+			adr, (data[0] << 8) | data[1],
+			(len > 2 ? data[2] : 0));
+		return -EREMOTEIO;
+	}
+	return 0;
+}
+
+static int i2c_write_reg16(struct i2c_adapter *adap, u8 adr, u16 reg, u8 val)
+{
+	u8 msg[3] = {reg >> 8, reg & 0xff, val};
+
+	return i2c_write(adap, adr, msg, 3);
+}
+
+static int write_reg(struct stv *state, u16 reg, u8 val)
+{
+	return i2c_write_reg16(state->base->i2c, state->base->adr, reg, val);
+}
+
+static inline int i2c_read_regs16(struct i2c_adapter *adapter, u8 adr,
+				 u16 reg, u8 *val, int count)
+{
+	u8 msg[2] = {reg >> 8, reg & 0xff};
+	struct i2c_msg msgs[2] = {{.addr = adr, .flags = 0,
+				   .buf  = msg, .len   = 2},
+				  {.addr = adr, .flags = I2C_M_RD,
+				   .buf  = val, .len   = count } };
+
+	if (i2c_transfer(adapter, msgs, 2) != 2) {
+		dev_warn(&adapter->dev, "i2c read error ([%02x] %04x)\n",
+			adr, reg);
+		return -EREMOTEIO;
+	}
+	return 0;
+}
+
+static int read_reg(struct stv *state, u16 reg, u8 *val)
+{
+	return i2c_read_regs16(state->base->i2c, state->base->adr,
+		reg, val, 1);
+}
+
+static int read_regs(struct stv *state, u16 reg, u8 *val, int len)
+{
+	return i2c_read_regs16(state->base->i2c, state->base->adr,
+			       reg, val, len);
+}
+
+static int write_shared_reg(struct stv *state, u16 reg, u8 mask, u8 val)
+{
+	int status;
+	u8 tmp;
+
+	mutex_lock(&state->base->reg_lock);
+	status = read_reg(state, reg, &tmp);
+	if (!status)
+		status = write_reg(state, reg, (tmp & ~mask) | (val & mask));
+	mutex_unlock(&state->base->reg_lock);
+	return status;
+}
+
+struct slookup s1_sn_lookup[] = {
+	{   0,    9242  },  /*C/N=  0dB*/
+	{   5,    9105  },  /*C/N=0.5dB*/
+	{  10,    8950  },  /*C/N=1.0dB*/
+	{  15,    8780  },  /*C/N=1.5dB*/
+	{  20,    8566  },  /*C/N=2.0dB*/
+	{  25,    8366  },  /*C/N=2.5dB*/
+	{  30,    8146  },  /*C/N=3.0dB*/
+	{  35,    7908  },  /*C/N=3.5dB*/
+	{  40,    7666  },  /*C/N=4.0dB*/
+	{  45,    7405  },  /*C/N=4.5dB*/
+	{  50,    7136  },  /*C/N=5.0dB*/
+	{  55,    6861  },  /*C/N=5.5dB*/
+	{  60,    6576  },  /*C/N=6.0dB*/
+	{  65,    6330  },  /*C/N=6.5dB*/
+	{  70,    6048  },  /*C/N=7.0dB*/
+	{  75,    5768  },  /*C/N=7.5dB*/
+	{  80,    5492  },  /*C/N=8.0dB*/
+	{  85,    5224  },  /*C/N=8.5dB*/
+	{  90,    4959  },  /*C/N=9.0dB*/
+	{  95,    4709  },  /*C/N=9.5dB*/
+	{  100,   4467  },  /*C/N=10.0dB*/
+	{  105,   4236  },  /*C/N=10.5dB*/
+	{  110,   4013  },  /*C/N=11.0dB*/
+	{  115,   3800  },  /*C/N=11.5dB*/
+	{  120,   3598  },  /*C/N=12.0dB*/
+	{  125,   3406  },  /*C/N=12.5dB*/
+	{  130,   3225  },  /*C/N=13.0dB*/
+	{  135,   3052  },  /*C/N=13.5dB*/
+	{  140,   2889  },  /*C/N=14.0dB*/
+	{  145,   2733  },  /*C/N=14.5dB*/
+	{  150,   2587  },  /*C/N=15.0dB*/
+	{  160,   2318  },  /*C/N=16.0dB*/
+	{  170,   2077  },  /*C/N=17.0dB*/
+	{  180,   1862  },  /*C/N=18.0dB*/
+	{  190,   1670  },  /*C/N=19.0dB*/
+	{  200,   1499  },  /*C/N=20.0dB*/
+	{  210,   1347  },  /*C/N=21.0dB*/
+	{  220,   1213  },  /*C/N=22.0dB*/
+	{  230,   1095  },  /*C/N=23.0dB*/
+	{  240,    992  },  /*C/N=24.0dB*/
+	{  250,    900  },  /*C/N=25.0dB*/
+	{  260,    826  },  /*C/N=26.0dB*/
+	{  270,    758  },  /*C/N=27.0dB*/
+	{  280,    702  },  /*C/N=28.0dB*/
+	{  290,    653  },  /*C/N=29.0dB*/
+	{  300,    613  },  /*C/N=30.0dB*/
+	{  310,    579  },  /*C/N=31.0dB*/
+	{  320,    550  },  /*C/N=32.0dB*/
+	{  330,    526  },  /*C/N=33.0dB*/
+	{  350,    490  },  /*C/N=33.0dB*/
+	{  400,    445  },  /*C/N=40.0dB*/
+	{  450,    430  },  /*C/N=45.0dB*/
+	{  500,    426  },  /*C/N=50.0dB*/
+	{  510,    425  }   /*C/N=51.0dB*/
+};
+
+struct slookup s2_sn_lookup[] = {
+	{  -30,  13950  },  /*C/N=-2.5dB*/
+	{  -25,  13580  },  /*C/N=-2.5dB*/
+	{  -20,  13150  },  /*C/N=-2.0dB*/
+	{  -15,  12760  },  /*C/N=-1.5dB*/
+	{  -10,  12345  },  /*C/N=-1.0dB*/
+	{   -5,  11900  },  /*C/N=-0.5dB*/
+	{    0,  11520  },  /*C/N=   0dB*/
+	{    5,  11080  },  /*C/N= 0.5dB*/
+	{   10,  10630  },  /*C/N= 1.0dB*/
+	{   15,  10210  },  /*C/N= 1.5dB*/
+	{   20,   9790  },  /*C/N= 2.0dB*/
+	{   25,   9390  },  /*C/N= 2.5dB*/
+	{   30,   8970  },  /*C/N= 3.0dB*/
+	{   35,   8575  },  /*C/N= 3.5dB*/
+	{   40,   8180  },  /*C/N= 4.0dB*/
+	{   45,   7800  },  /*C/N= 4.5dB*/
+	{   50,   7430  },  /*C/N= 5.0dB*/
+	{   55,   7080  },  /*C/N= 5.5dB*/
+	{   60,   6720  },  /*C/N= 6.0dB*/
+	{   65,   6320  },  /*C/N= 6.5dB*/
+	{   70,   6060  },  /*C/N= 7.0dB*/
+	{   75,   5760  },  /*C/N= 7.5dB*/
+	{   80,   5480  },  /*C/N= 8.0dB*/
+	{   85,   5200  },  /*C/N= 8.5dB*/
+	{   90,   4930  },  /*C/N= 9.0dB*/
+	{   95,   4680  },  /*C/N= 9.5dB*/
+	{  100,   4425  },  /*C/N=10.0dB*/
+	{  105,   4210  },  /*C/N=10.5dB*/
+	{  110,   3980  },  /*C/N=11.0dB*/
+	{  115,   3765  },  /*C/N=11.5dB*/
+	{  120,   3570  },  /*C/N=12.0dB*/
+	{  125,   3315  },  /*C/N=12.5dB*/
+	{  130,   3140  },  /*C/N=13.0dB*/
+	{  135,   2980  },  /*C/N=13.5dB*/
+	{  140,   2820  },  /*C/N=14.0dB*/
+	{  145,   2670  },  /*C/N=14.5dB*/
+	{  150,   2535  },  /*C/N=15.0dB*/
+	{  160,   2270  },  /*C/N=16.0dB*/
+	{  170,   2035  },  /*C/N=17.0dB*/
+	{  180,   1825  },  /*C/N=18.0dB*/
+	{  190,   1650  },  /*C/N=19.0dB*/
+	{  200,   1485  },  /*C/N=20.0dB*/
+	{  210,   1340  },  /*C/N=21.0dB*/
+	{  220,   1212  },  /*C/N=22.0dB*/
+	{  230,   1100  },  /*C/N=23.0dB*/
+	{  240,   1000  },  /*C/N=24.0dB*/
+	{  250,    910  },  /*C/N=25.0dB*/
+	{  260,    836  },  /*C/N=26.0dB*/
+	{  270,    772  },  /*C/N=27.0dB*/
+	{  280,    718  },  /*C/N=28.0dB*/
+	{  290,    671  },  /*C/N=29.0dB*/
+	{  300,    635  },  /*C/N=30.0dB*/
+	{  310,    602  },  /*C/N=31.0dB*/
+	{  320,    575  },  /*C/N=32.0dB*/
+	{  330,    550  },  /*C/N=33.0dB*/
+	{  350,    517  },  /*C/N=35.0dB*/
+	{  400,    480  },  /*C/N=40.0dB*/
+	{  450,    466  },  /*C/N=45.0dB*/
+	{  500,    464  },  /*C/N=50.0dB*/
+	{  510,    463  },  /*C/N=51.0dB*/
+};
+
+/*********************************************************************
+ * Tracking carrier loop carrier QPSK 1/4 to 8PSK 9/10 long Frame
+ *********************************************************************/
+static u8 s2car_loop[] =	{
+	/* Modcod  2MPon 2MPoff 5MPon 5MPoff 10MPon 10MPoff
+	 * 20MPon 20MPoff 30MPon 30MPoff
+	 */
+
+	/* FE_QPSK_14  */
+	0x0C,  0x3C,  0x0B,  0x3C,  0x2A,  0x2C,  0x2A,  0x1C,  0x3A,  0x3B,
+	/* FE_QPSK_13  */
+	0x0C,  0x3C,  0x0B,  0x3C,  0x2A,  0x2C,  0x3A,  0x0C,  0x3A,  0x2B,
+	/* FE_QPSK_25  */
+	0x1C,  0x3C,  0x1B,  0x3C,  0x3A,  0x1C,  0x3A,  0x3B,  0x3A,  0x2B,
+	/* FE_QPSK_12  */
+	0x0C,  0x1C,  0x2B,  0x1C,  0x0B,  0x2C,  0x0B,  0x0C,  0x2A,  0x2B,
+	/* FE_QPSK_35  */
+	0x1C,  0x1C,  0x2B,  0x1C,  0x0B,  0x2C,  0x0B,  0x0C,  0x2A,  0x2B,
+	/* FE_QPSK_23  */
+	0x2C,  0x2C,  0x2B,  0x1C,  0x0B,  0x2C,  0x0B,  0x0C,  0x2A,  0x2B,
+	/* FE_QPSK_34  */
+	0x3C,  0x2C,  0x3B,  0x2C,  0x1B,  0x1C,  0x1B,  0x3B,  0x3A,  0x1B,
+	/* FE_QPSK_45  */
+	0x0D,  0x3C,  0x3B,  0x2C,  0x1B,  0x1C,  0x1B,  0x3B,  0x3A,  0x1B,
+	/* FE_QPSK_56  */
+	0x1D,  0x3C,  0x0C,  0x2C,  0x2B,  0x1C,  0x1B,  0x3B,  0x0B,  0x1B,
+	/* FE_QPSK_89  */
+	0x3D,  0x0D,  0x0C,  0x2C,  0x2B,  0x0C,  0x2B,  0x2B,  0x0B,  0x0B,
+	/* FE_QPSK_910 */
+	0x1E,  0x0D,  0x1C,  0x2C,  0x3B,  0x0C,  0x2B,  0x2B,  0x1B,  0x0B,
+	/* FE_8PSK_35  */
+	0x28,  0x09,  0x28,  0x09,  0x28,  0x09,  0x28,  0x08,  0x28,  0x27,
+	/* FE_8PSK_23  */
+	0x19,  0x29,  0x19,  0x29,  0x19,  0x29,  0x38,  0x19,  0x28,  0x09,
+	/* FE_8PSK_34  */
+	0x1A,  0x0B,  0x1A,  0x3A,  0x0A,  0x2A,  0x39,  0x2A,  0x39,  0x1A,
+	/* FE_8PSK_56  */
+	0x2B,  0x2B,  0x1B,  0x1B,  0x0B,  0x1B,  0x1A,  0x0B,  0x1A,  0x1A,
+	/* FE_8PSK_89  */
+	0x0C,  0x0C,  0x3B,  0x3B,  0x1B,  0x1B,  0x2A,  0x0B,  0x2A,  0x2A,
+	/* FE_8PSK_910 */
+	0x0C,  0x1C,  0x0C,  0x3B,  0x2B,  0x1B,  0x3A,  0x0B,  0x2A,  0x2A,
+
+	/**********************************************************************
+	 * Tracking carrier loop carrier 16APSK 2/3 to 32APSK 9/10 long Frame
+	 **********************************************************************/
+
+	/* Modcod 2MPon  2MPoff 5MPon 5MPoff 10MPon 10MPoff 20MPon
+	 * 20MPoff 30MPon 30MPoff
+	 */
+
+	/* FE_16APSK_23  */
+	0x0A,  0x0A,  0x0A,  0x0A,  0x1A,  0x0A,  0x39,  0x0A,  0x29,  0x0A,
+	/* FE_16APSK_34  */
+	0x0A,  0x0A,  0x0A,  0x0A,  0x0B,  0x0A,  0x2A,  0x0A,  0x1A,  0x0A,
+	/* FE_16APSK_45  */
+	0x0A,  0x0A,  0x0A,  0x0A,  0x1B,  0x0A,  0x3A,  0x0A,  0x2A,  0x0A,
+	/* FE_16APSK_56  */
+	0x0A,  0x0A,  0x0A,  0x0A,  0x1B,  0x0A,  0x3A,  0x0A,  0x2A,  0x0A,
+	/* FE_16APSK_89  */
+	0x0A,  0x0A,  0x0A,  0x0A,  0x2B,  0x0A,  0x0B,  0x0A,  0x3A,  0x0A,
+	/* FE_16APSK_910 */
+	0x0A,  0x0A,  0x0A,  0x0A,  0x2B,  0x0A,  0x0B,  0x0A,  0x3A,  0x0A,
+	/* FE_32APSK_34  */
+	0x09,  0x09,  0x09,  0x09,  0x09,  0x09,  0x09,  0x09,  0x09,  0x09,
+	/* FE_32APSK_45  */
+	0x09,  0x09,  0x09,  0x09,  0x09,  0x09,  0x09,  0x09,  0x09,  0x09,
+	/* FE_32APSK_56  */
+	0x09,  0x09,  0x09,  0x09,  0x09,  0x09,  0x09,  0x09,  0x09,  0x09,
+	/* FE_32APSK_89  */
+	0x09,  0x09,  0x09,  0x09,  0x09,  0x09,  0x09,  0x09,  0x09,  0x09,
+	/* FE_32APSK_910 */
+	0x09,  0x09,  0x09,  0x09,  0x09,  0x09,  0x09,  0x09,  0x09,  0x09,
+};
+
+static u8 get_optim_cloop(struct stv *state,
+			  enum fe_stv0910_mod_cod mod_cod, u32 pilots)
+{
+	int i = 0;
+
+	if (mod_cod >= FE_32APSK_910)
+		i = ((int)FE_32APSK_910 - (int)FE_QPSK_14) * 10;
+	else if (mod_cod >= FE_QPSK_14)
+		i = ((int)mod_cod - (int)FE_QPSK_14) * 10;
+
+	if (state->symbol_rate <= 3000000)
+		i += 0;
+	else if (state->symbol_rate <=  7000000)
+		i += 2;
+	else if (state->symbol_rate <= 15000000)
+		i += 4;
+	else if (state->symbol_rate <= 25000000)
+		i += 6;
+	else
+		i += 8;
+
+	if (!pilots)
+		i += 1;
+
+	return s2car_loop[i];
+}
+
+static int get_cur_symbol_rate(struct stv *state, u32 *p_symbol_rate)
+{
+	int status = 0;
+	u8 symb_freq0;
+	u8 symb_freq1;
+	u8 symb_freq2;
+	u8 symb_freq3;
+	u8 tim_offs0;
+	u8 tim_offs1;
+	u8 tim_offs2;
+	u32 symbol_rate;
+	s32 timing_offset;
+
+	*p_symbol_rate = 0;
+	if (!state->started)
+		return status;
+
+	read_reg(state, RSTV0910_P2_SFR3 + state->regoff, &symb_freq3);
+	read_reg(state, RSTV0910_P2_SFR2 + state->regoff, &symb_freq2);
+	read_reg(state, RSTV0910_P2_SFR1 + state->regoff, &symb_freq1);
+	read_reg(state, RSTV0910_P2_SFR0 + state->regoff, &symb_freq0);
+	read_reg(state, RSTV0910_P2_TMGREG2 + state->regoff, &tim_offs2);
+	read_reg(state, RSTV0910_P2_TMGREG1 + state->regoff, &tim_offs1);
+	read_reg(state, RSTV0910_P2_TMGREG0 + state->regoff, &tim_offs0);
+
+	symbol_rate = ((u32) symb_freq3 << 24) | ((u32) symb_freq2 << 16) |
+		((u32) symb_freq1 << 8) | (u32) symb_freq0;
+	timing_offset = ((u32) tim_offs2 << 16) | ((u32) tim_offs1 << 8) |
+		(u32) tim_offs0;
+
+	if ((timing_offset & (1<<23)) != 0)
+		timing_offset |= 0xFF000000; /* Sign extent */
+
+	symbol_rate = (u32) (((u64) symbol_rate * state->base->mclk) >> 32);
+	timing_offset = (s32) (((s64) symbol_rate * (s64) timing_offset) >> 29);
+
+	*p_symbol_rate = symbol_rate + timing_offset;
+
+	return 0;
+}
+
+static int get_signal_parameters(struct stv *state)
+{
+	u8 tmp;
+
+	if (!state->started)
+		return -EINVAL;
+
+	if (state->receive_mode == RCVMODE_DVBS2) {
+		read_reg(state, RSTV0910_P2_DMDMODCOD + state->regoff, &tmp);
+		state->mod_cod = (enum fe_stv0910_mod_cod) ((tmp & 0x7c) >> 2);
+		state->pilots = (tmp & 0x01) != 0;
+		state->fectype = (enum dvbs2_fectype) ((tmp & 0x02) >> 1);
+
+	} else if (state->receive_mode == RCVMODE_DVBS) {
+		read_reg(state, RSTV0910_P2_VITCURPUN + state->regoff, &tmp);
+		state->puncture_rate = FEC_NONE;
+		switch (tmp & 0x1F) {
+		case 0x0d:
+			state->puncture_rate = FEC_1_2;
+			break;
+		case 0x12:
+			state->puncture_rate = FEC_2_3;
+			break;
+		case 0x15:
+			state->puncture_rate = FEC_3_4;
+			break;
+		case 0x18:
+			state->puncture_rate = FEC_5_6;
+			break;
+		case 0x1a:
+			state->puncture_rate = FEC_7_8;
+			break;
+		}
+		state->is_vcm = 0;
+		state->is_standard_broadcast = 1;
+		state->feroll_off = FE_SAT_35;
+	}
+	return 0;
+}
+
+static int tracking_optimization(struct stv *state)
+{
+	u32 symbol_rate = 0;
+	u8 tmp;
+
+	get_cur_symbol_rate(state, &symbol_rate);
+	read_reg(state, RSTV0910_P2_DMDCFGMD + state->regoff, &tmp);
+	tmp &= ~0xC0;
+
+	switch (state->receive_mode) {
+	case RCVMODE_DVBS:
+		tmp |= 0x40;
+		break;
+	case RCVMODE_DVBS2:
+		tmp |= 0x80;
+		break;
+	default:
+		tmp |= 0xC0;
+		break;
+	}
+	write_reg(state, RSTV0910_P2_DMDCFGMD + state->regoff, tmp);
+
+	if (state->receive_mode == RCVMODE_DVBS2) {
+		/* Disable Reed-Solomon */
+		write_shared_reg(state,
+				 RSTV0910_TSTTSRS, state->nr ? 0x02 : 0x01,
+				 0x03);
+
+		if (state->fectype == DVBS2_64K) {
+			u8 aclc = get_optim_cloop(state, state->mod_cod,
+						  state->pilots);
+
+			if (state->mod_cod <= FE_QPSK_910) {
+				write_reg(state, RSTV0910_P2_ACLC2S2Q +
+					  state->regoff, aclc);
+			} else if (state->mod_cod <= FE_8PSK_910) {
+				write_reg(state, RSTV0910_P2_ACLC2S2Q +
+					  state->regoff, 0x2a);
+				write_reg(state, RSTV0910_P2_ACLC2S28 +
+					  state->regoff, aclc);
+			} else if (state->mod_cod <= FE_16APSK_910) {
+				write_reg(state, RSTV0910_P2_ACLC2S2Q +
+					  state->regoff, 0x2a);
+				write_reg(state, RSTV0910_P2_ACLC2S216A +
+					  state->regoff, aclc);
+			} else if (state->mod_cod <= FE_32APSK_910) {
+				write_reg(state, RSTV0910_P2_ACLC2S2Q +
+					  state->regoff, 0x2a);
+				write_reg(state, RSTV0910_P2_ACLC2S232A +
+					  state->regoff, aclc);
+			}
+		}
+	}
+	return 0;
+}
+
+static s32 table_lookup(struct slookup *table,
+		       int table_size, u16 reg_value)
+{
+	s32 value;
+	int imin = 0;
+	int imax = table_size - 1;
+	int i;
+	s32 reg_diff;
+
+	/* Assumes Table[0].RegValue > Table[imax].RegValue */
+	if (reg_value >= table[0].reg_value)
+		value = table[0].value;
+	else if (reg_value <= table[imax].reg_value)
+		value = table[imax].value;
+	else {
+		while (imax-imin > 1) {
+			i = (imax + imin) / 2;
+			if ((table[imin].reg_value >= reg_value) &&
+				(reg_value >= table[i].reg_value))
+				imax = i;
+			else
+				imin = i;
+		}
+
+		reg_diff = table[imax].reg_value - table[imin].reg_value;
+		value = table[imin].value;
+		if (reg_diff != 0)
+			value += ((s32)(reg_value - table[imin].reg_value) *
+				  (s32)(table[imax].value
+					- table[imin].value))
+					/ (reg_diff);
+	}
+
+	return value;
+}
+
+static int get_signal_to_noise(struct stv *state, s32 *signal_to_noise)
+{
+	u8 data0;
+	u8 data1;
+	u16 data;
+	int n_lookup;
+	struct slookup *lookup;
+
+	*signal_to_noise = 0;
+
+	if (!state->started)
+		return -EINVAL;
+
+	if (state->receive_mode == RCVMODE_DVBS2) {
+		read_reg(state, RSTV0910_P2_NNOSPLHT1 + state->regoff,
+			 &data1);
+		read_reg(state, RSTV0910_P2_NNOSPLHT0 + state->regoff,
+			 &data0);
+		n_lookup = ARRAY_SIZE(s2_sn_lookup);
+		lookup = s2_sn_lookup;
+	} else {
+		read_reg(state, RSTV0910_P2_NNOSDATAT1 + state->regoff,
+			 &data1);
+		read_reg(state, RSTV0910_P2_NNOSDATAT0 + state->regoff,
+			 &data0);
+		n_lookup = ARRAY_SIZE(s1_sn_lookup);
+		lookup = s1_sn_lookup;
+	}
+	data = (((u16)data1) << 8) | (u16) data0;
+	*signal_to_noise = table_lookup(lookup, n_lookup, data);
+	return 0;
+}
+
+static int get_bit_error_rate_s(struct stv *state, u32 *bernumerator,
+			    u32 *berdenominator)
+{
+	u8 regs[3];
+
+	int status = read_regs(state,
+			       RSTV0910_P2_ERRCNT12 + state->regoff,
+			       regs, 3);
+
+	if (status)
+		return -EINVAL;
+
+	if ((regs[0] & 0x80) == 0) {
+		state->last_berdenominator = 1 << ((state->berscale * 2) +
+						  10 + 3);
+		state->last_bernumerator = ((u32) (regs[0] & 0x7F) << 16) |
+			((u32) regs[1] << 8) | regs[2];
+		if (state->last_bernumerator < 256 && state->berscale < 6) {
+			state->berscale += 1;
+			status = write_reg(state, RSTV0910_P2_ERRCTRL1 +
+					   state->regoff,
+					   0x20 | state->berscale);
+		} else if (state->last_bernumerator > 1024 &&
+			   state->berscale > 2) {
+			state->berscale -= 1;
+			status = write_reg(state, RSTV0910_P2_ERRCTRL1 +
+					   state->regoff, 0x20 |
+					   state->berscale);
+		}
+	}
+	*bernumerator = state->last_bernumerator;
+	*berdenominator = state->last_berdenominator;
+	return 0;
+}
+
+static u32 dvbs2_nbch(enum dvbs2_mod_cod mod_cod, enum dvbs2_fectype fectype)
+{
+	static u32 nbch[][2] = {
+		{16200,  3240}, /* QPSK_1_4, */
+		{21600,  5400}, /* QPSK_1_3, */
+		{25920,  6480}, /* QPSK_2_5, */
+		{32400,  7200}, /* QPSK_1_2, */
+		{38880,  9720}, /* QPSK_3_5, */
+		{43200, 10800}, /* QPSK_2_3, */
+		{48600, 11880}, /* QPSK_3_4, */
+		{51840, 12600}, /* QPSK_4_5, */
+		{54000, 13320}, /* QPSK_5_6, */
+		{57600, 14400}, /* QPSK_8_9, */
+		{58320, 16000}, /* QPSK_9_10, */
+		{43200,  9720}, /* 8PSK_3_5, */
+		{48600, 10800}, /* 8PSK_2_3, */
+		{51840, 11880}, /* 8PSK_3_4, */
+		{54000, 13320}, /* 8PSK_5_6, */
+		{57600, 14400}, /* 8PSK_8_9, */
+		{58320, 16000}, /* 8PSK_9_10, */
+		{43200, 10800}, /* 16APSK_2_3, */
+		{48600, 11880}, /* 16APSK_3_4, */
+		{51840, 12600}, /* 16APSK_4_5, */
+		{54000, 13320}, /* 16APSK_5_6, */
+		{57600, 14400}, /* 16APSK_8_9, */
+		{58320, 16000}, /* 16APSK_9_10 */
+		{48600, 11880}, /* 32APSK_3_4, */
+		{51840, 12600}, /* 32APSK_4_5, */
+		{54000, 13320}, /* 32APSK_5_6, */
+		{57600, 14400}, /* 32APSK_8_9, */
+		{58320, 16000}, /* 32APSK_9_10 */
+	};
+
+	if (mod_cod >= DVBS2_QPSK_1_4 &&
+	    mod_cod <= DVBS2_32APSK_9_10 && fectype <= DVBS2_16K)
+		return nbch[fectype][mod_cod];
+	return 64800;
+}
+
+static int get_bit_error_rate_s2(struct stv *state, u32 *bernumerator,
+			     u32 *berdenominator)
+{
+	u8 regs[3];
+
+	int status = read_regs(state, RSTV0910_P2_ERRCNT12 + state->regoff,
+			       regs, 3);
+
+	if (status)
+		return -EINVAL;
+
+	if ((regs[0] & 0x80) == 0) {
+		state->last_berdenominator =
+			dvbs2_nbch((enum dvbs2_mod_cod) state->mod_cod,
+				   state->fectype) <<
+			(state->berscale * 2);
+		state->last_bernumerator = (((u32) regs[0] & 0x7F) << 16) |
+			((u32) regs[1] << 8) | regs[2];
+		if (state->last_bernumerator < 256 && state->berscale < 6) {
+			state->berscale += 1;
+			write_reg(state, RSTV0910_P2_ERRCTRL1 + state->regoff,
+				  0x20 | state->berscale);
+		} else if (state->last_bernumerator > 1024 &&
+			   state->berscale > 2) {
+			state->berscale -= 1;
+			write_reg(state, RSTV0910_P2_ERRCTRL1 + state->regoff,
+				  0x20 | state->berscale);
+		}
+	}
+	*bernumerator = state->last_bernumerator;
+	*berdenominator = state->last_berdenominator;
+	return status;
+}
+
+static int get_bit_error_rate(struct stv *state, u32 *bernumerator,
+			   u32 *berdenominator)
+{
+	*bernumerator = 0;
+	*berdenominator = 1;
+
+	switch (state->receive_mode) {
+	case RCVMODE_DVBS:
+		return get_bit_error_rate_s(state,
+					    bernumerator, berdenominator);
+	case RCVMODE_DVBS2:
+		return get_bit_error_rate_s2(state,
+					     bernumerator, berdenominator);
+	default:
+		break;
+	}
+	return 0;
+}
+
+static int set_mclock(struct stv *state, u32 master_clock)
+{
+	u32 idf = 1;
+	u32 odf = 4;
+	u32 quartz = state->base->extclk / 1000000;
+	u32 fphi = master_clock / 1000000;
+	u32 ndiv = (fphi * odf * idf) / quartz;
+	u32 cp = 7;
+	u32 fvco;
+
+	if (ndiv >= 7 && ndiv <= 71)
+		cp = 7;
+	else if (ndiv >=  72 && ndiv <=  79)
+		cp = 8;
+	else if (ndiv >=  80 && ndiv <=  87)
+		cp = 9;
+	else if (ndiv >=  88 && ndiv <=  95)
+		cp = 10;
+	else if (ndiv >=  96 && ndiv <= 103)
+		cp = 11;
+	else if (ndiv >= 104 && ndiv <= 111)
+		cp = 12;
+	else if (ndiv >= 112 && ndiv <= 119)
+		cp = 13;
+	else if (ndiv >= 120 && ndiv <= 127)
+		cp = 14;
+	else if (ndiv >= 128 && ndiv <= 135)
+		cp = 15;
+	else if (ndiv >= 136 && ndiv <= 143)
+		cp = 16;
+	else if (ndiv >= 144 && ndiv <= 151)
+		cp = 17;
+	else if (ndiv >= 152 && ndiv <= 159)
+		cp = 18;
+	else if (ndiv >= 160 && ndiv <= 167)
+		cp = 19;
+	else if (ndiv >= 168 && ndiv <= 175)
+		cp = 20;
+	else if (ndiv >= 176 && ndiv <= 183)
+		cp = 21;
+	else if (ndiv >= 184 && ndiv <= 191)
+		cp = 22;
+	else if (ndiv >= 192 && ndiv <= 199)
+		cp = 23;
+	else if (ndiv >= 200 && ndiv <= 207)
+		cp = 24;
+	else if (ndiv >= 208 && ndiv <= 215)
+		cp = 25;
+	else if (ndiv >= 216 && ndiv <= 223)
+		cp = 26;
+	else if (ndiv >= 224 && ndiv <= 225)
+		cp = 27;
+
+	write_reg(state, RSTV0910_NCOARSE, (cp << 3) | idf);
+	write_reg(state, RSTV0910_NCOARSE2, odf);
+	write_reg(state, RSTV0910_NCOARSE1, ndiv);
+
+	fvco = (quartz * 2 * ndiv) / idf;
+	state->base->mclk = fvco / (2 * odf) * 1000000;
+
+	return 0;
+}
+
+static int stop(struct stv *state)
+{
+	if (state->started) {
+		u8 tmp;
+
+		write_reg(state, RSTV0910_P2_TSCFGH + state->regoff,
+			  state->tscfgh | 0x01);
+		read_reg(state, RSTV0910_P2_PDELCTRL1 + state->regoff, &tmp);
+		tmp &= ~0x01; /*release reset DVBS2 packet delin*/
+		write_reg(state, RSTV0910_P2_PDELCTRL1 + state->regoff, tmp);
+		/* Blind optim*/
+		write_reg(state, RSTV0910_P2_AGC2O + state->regoff, 0x5B);
+		/* Stop the demod */
+		write_reg(state, RSTV0910_P2_DMDISTATE + state->regoff, 0x5c);
+		state->started = 0;
+	}
+	state->receive_mode = RCVMODE_NONE;
+	return 0;
+}
+
+static int init_search_param(struct stv *state)
+{
+	u8 tmp;
+
+	read_reg(state, RSTV0910_P2_PDELCTRL1 + state->regoff, &tmp);
+	tmp |= 0x20; // Filter_en (no effect if SIS=non-MIS
+	write_reg(state, RSTV0910_P2_PDELCTRL1 + state->regoff, tmp);
+
+	read_reg(state, RSTV0910_P2_PDELCTRL2 + state->regoff, &tmp);
+	tmp &= ~0x02; // frame mode = 0
+	write_reg(state, RSTV0910_P2_PDELCTRL2 + state->regoff, tmp);
+
+	write_reg(state, RSTV0910_P2_UPLCCST0 + state->regoff, 0xe0);
+	write_reg(state, RSTV0910_P2_ISIBITENA + state->regoff, 0x00);
+
+	read_reg(state, RSTV0910_P2_TSSTATEM + state->regoff, &tmp);
+	tmp &= ~0x01; // nosync = 0, in case next signal is standard TS
+	write_reg(state, RSTV0910_P2_TSSTATEM + state->regoff, tmp);
+
+	read_reg(state, RSTV0910_P2_TSCFGL + state->regoff, &tmp);
+	tmp &= ~0x04; // embindvb = 0
+	write_reg(state, RSTV0910_P2_TSCFGL + state->regoff, tmp);
+
+	read_reg(state, RSTV0910_P2_TSINSDELH + state->regoff, &tmp);
+	tmp &= ~0x80; // syncbyte = 0
+	write_reg(state, RSTV0910_P2_TSINSDELH + state->regoff, tmp);
+
+	read_reg(state, RSTV0910_P2_TSINSDELM + state->regoff, &tmp);
+	tmp &= ~0x08; // token = 0
+	write_reg(state, RSTV0910_P2_TSINSDELM + state->regoff, tmp);
+
+	read_reg(state, RSTV0910_P2_TSDLYSET2 + state->regoff, &tmp);
+	tmp &= ~0x30; // hysteresis threshold = 0
+	write_reg(state, RSTV0910_P2_TSDLYSET2 + state->regoff, tmp);
+
+	read_reg(state, RSTV0910_P2_PDELCTRL0 + state->regoff, &tmp);
+	tmp = (tmp & ~0x30) | 0x10; // isi obs mode = 1, observe min ISI
+	write_reg(state, RSTV0910_P2_PDELCTRL0 + state->regoff, tmp);
+
+	return 0;
+}
+
+static int enable_puncture_rate(struct stv *state, enum fe_code_rate rate)
+{
+	switch (rate) {
+	case FEC_1_2:
+		return write_reg(state,
+				 RSTV0910_P2_PRVIT + state->regoff, 0x01);
+	case FEC_2_3:
+		return write_reg(state,
+				 RSTV0910_P2_PRVIT + state->regoff, 0x02);
+	case FEC_3_4:
+		return write_reg(state,
+				 RSTV0910_P2_PRVIT + state->regoff, 0x04);
+	case FEC_5_6:
+		return write_reg(state,
+				 RSTV0910_P2_PRVIT + state->regoff, 0x08);
+	case FEC_7_8:
+		return write_reg(state,
+				 RSTV0910_P2_PRVIT + state->regoff, 0x20);
+	case FEC_NONE:
+	default:
+		return write_reg(state,
+				 RSTV0910_P2_PRVIT + state->regoff, 0x2f);
+	}
+}
+
+static int set_vth_default(struct stv *state)
+{
+	state->vth[0] = 0xd7;
+	state->vth[1] = 0x85;
+	state->vth[2] = 0x58;
+	state->vth[3] = 0x3a;
+	state->vth[4] = 0x34;
+	state->vth[5] = 0x28;
+	write_reg(state, RSTV0910_P2_VTH12 + state->regoff + 0, state->vth[0]);
+	write_reg(state, RSTV0910_P2_VTH12 + state->regoff + 1, state->vth[1]);
+	write_reg(state, RSTV0910_P2_VTH12 + state->regoff + 2, state->vth[2]);
+	write_reg(state, RSTV0910_P2_VTH12 + state->regoff + 3, state->vth[3]);
+	write_reg(state, RSTV0910_P2_VTH12 + state->regoff + 4, state->vth[4]);
+	write_reg(state, RSTV0910_P2_VTH12 + state->regoff + 5, state->vth[5]);
+	return 0;
+}
+
+static int set_vth(struct stv *state)
+{
+	static struct slookup vthlookup_table[] = {
+		{250,	8780}, /*C/N=1.5dB*/
+		{100,	7405}, /*C/N=4.5dB*/
+		{40,	6330}, /*C/N=6.5dB*/
+		{12,	5224}, /*C/N=8.5dB*/
+		{5,	4236} /*C/N=10.5dB*/
+	};
+
+	int i;
+	u8 tmp[2];
+	int status = read_regs(state,
+			       RSTV0910_P2_NNOSDATAT1 + state->regoff,
+			       tmp, 2);
+	u16 reg_value = (tmp[0] << 8) | tmp[1];
+	s32 vth = table_lookup(vthlookup_table, ARRAY_SIZE(vthlookup_table),
+			      reg_value);
+
+	for (i = 0; i < 6; i += 1)
+		if (state->vth[i] > vth)
+			state->vth[i] = vth;
+
+	write_reg(state, RSTV0910_P2_VTH12 + state->regoff + 0, state->vth[0]);
+	write_reg(state, RSTV0910_P2_VTH12 + state->regoff + 1, state->vth[1]);
+	write_reg(state, RSTV0910_P2_VTH12 + state->regoff + 2, state->vth[2]);
+	write_reg(state, RSTV0910_P2_VTH12 + state->regoff + 3, state->vth[3]);
+	write_reg(state, RSTV0910_P2_VTH12 + state->regoff + 4, state->vth[4]);
+	write_reg(state, RSTV0910_P2_VTH12 + state->regoff + 5, state->vth[5]);
+	return status;
+}
+
+static int start(struct stv *state, struct dtv_frontend_properties *p)
+{
+	s32 freq;
+	u8  reg_dmdcfgmd;
+	u16 symb;
+
+	if (p->symbol_rate < 100000 || p->symbol_rate > 70000000)
+		return -EINVAL;
+
+	state->receive_mode = RCVMODE_NONE;
+	state->demod_lock_time = 0;
+
+	/* Demod Stop */
+	if (state->started)
+		write_reg(state, RSTV0910_P2_DMDISTATE + state->regoff, 0x5C);
+
+	init_search_param(state);
+
+	if (p->symbol_rate <= 1000000) {  /* SR <=1Msps */
+		state->demod_timeout = 3000;
+		state->fec_timeout = 2000;
+	} else if (p->symbol_rate <= 2000000) {  /* 1Msps < SR <=2Msps */
+		state->demod_timeout = 2500;
+		state->fec_timeout = 1300;
+	} else if (p->symbol_rate <= 5000000) {  /* 2Msps< SR <=5Msps */
+		state->demod_timeout = 1000;
+		state->fec_timeout = 650;
+	} else if (p->symbol_rate <= 10000000) {  /* 5Msps< SR <=10Msps */
+		state->demod_timeout = 700;
+		state->fec_timeout = 350;
+	} else if (p->symbol_rate < 20000000) {  /* 10Msps< SR <=20Msps */
+		state->demod_timeout = 400;
+		state->fec_timeout = 200;
+	} else {  /* SR >=20Msps */
+		state->demod_timeout = 300;
+		state->fec_timeout = 200;
+	}
+
+	/* Set the Init Symbol rate */
+	symb = muldiv32(p->symbol_rate, 65536, state->base->mclk);
+	write_reg(state, RSTV0910_P2_SFRINIT1 + state->regoff,
+		  ((symb >> 8) & 0x7F));
+	write_reg(state, RSTV0910_P2_SFRINIT0 + state->regoff, (symb & 0xFF));
+
+	state->demod_bits |= 0x80;
+	write_reg(state, RSTV0910_P2_DEMOD + state->regoff, state->demod_bits);
+
+	/* FE_STV0910_SetSearchStandard */
+	read_reg(state, RSTV0910_P2_DMDCFGMD + state->regoff, &reg_dmdcfgmd);
+	write_reg(state, RSTV0910_P2_DMDCFGMD + state->regoff,
+		  reg_dmdcfgmd |= 0xC0);
+
+	write_shared_reg(state,
+			 RSTV0910_TSTTSRS, state->nr ? 0x02 : 0x01, 0x00);
+
+	/* Disable DSS */
+	write_reg(state, RSTV0910_P2_FECM  + state->regoff, 0x00);
+	write_reg(state, RSTV0910_P2_PRVIT + state->regoff, 0x2F);
+
+	enable_puncture_rate(state, FEC_NONE);
+
+	/* 8PSK 3/5, 8PSK 2/3 Poff tracking optimization WA*/
+	write_reg(state, RSTV0910_P2_ACLC2S2Q + state->regoff, 0x0B);
+	write_reg(state, RSTV0910_P2_ACLC2S28 + state->regoff, 0x0A);
+	write_reg(state, RSTV0910_P2_BCLC2S2Q + state->regoff, 0x84);
+	write_reg(state, RSTV0910_P2_BCLC2S28 + state->regoff, 0x84);
+	write_reg(state, RSTV0910_P2_CARHDR + state->regoff, 0x1C);
+	write_reg(state, RSTV0910_P2_CARFREQ + state->regoff, 0x79);
+
+	write_reg(state, RSTV0910_P2_ACLC2S216A + state->regoff, 0x29);
+	write_reg(state, RSTV0910_P2_ACLC2S232A + state->regoff, 0x09);
+	write_reg(state, RSTV0910_P2_BCLC2S216A + state->regoff, 0x84);
+	write_reg(state, RSTV0910_P2_BCLC2S232A + state->regoff, 0x84);
+
+	/* Reset CAR3, bug DVBS2->DVBS1 lock*/
+	/* Note: The bit is only pulsed -> no lock on shared register needed */
+	write_reg(state, RSTV0910_TSTRES0, state->nr ? 0x04 : 0x08);
+	write_reg(state, RSTV0910_TSTRES0, 0);
+
+	set_vth_default(state);
+	/* Reset demod */
+	write_reg(state, RSTV0910_P2_DMDISTATE + state->regoff, 0x1F);
+
+	write_reg(state, RSTV0910_P2_CARCFG + state->regoff, 0x46);
+
+	if (p->symbol_rate <= 5000000)
+		freq = (state->search_range / 2000) + 80;
+	else
+		freq = (state->search_range / 2000) + 1600;
+	freq = (freq << 16) / (state->base->mclk / 1000);
+
+	write_reg(state, RSTV0910_P2_CFRUP1 + state->regoff,
+		  (freq >> 8) & 0xff);
+	write_reg(state, RSTV0910_P2_CFRUP0 + state->regoff, (freq & 0xff));
+	/*CFR Low Setting*/
+	freq = -freq;
+	write_reg(state, RSTV0910_P2_CFRLOW1 + state->regoff,
+		  (freq >> 8) & 0xff);
+	write_reg(state, RSTV0910_P2_CFRLOW0 + state->regoff, (freq & 0xff));
+
+	/* init the demod frequency offset to 0 */
+	write_reg(state, RSTV0910_P2_CFRINIT1 + state->regoff, 0);
+	write_reg(state, RSTV0910_P2_CFRINIT0 + state->regoff, 0);
+
+	write_reg(state, RSTV0910_P2_DMDISTATE + state->regoff, 0x1F);
+	/* Trigger acq */
+	write_reg(state, RSTV0910_P2_DMDISTATE + state->regoff, 0x15);
+
+	state->demod_lock_time += TUNING_DELAY;
+	state->started = 1;
+
+	return 0;
+}
+
+static int init_diseqc(struct stv *state)
+{
+	u16 offs = state->nr ? 0x40 : 0;  /* Address offset */
+	u8 freq = ((state->base->mclk + 11000 * 32) / (22000 * 32));
+
+	/* Disable receiver */
+	write_reg(state, RSTV0910_P1_DISRXCFG + offs, 0x00);
+	write_reg(state, RSTV0910_P1_DISTXCFG + offs, 0xBA); /* Reset = 1 */
+	write_reg(state, RSTV0910_P1_DISTXCFG + offs, 0x3A); /* Reset = 0 */
+	write_reg(state, RSTV0910_P1_DISTXF22 + offs, freq);
+	return 0;
+}
+
+static int probe(struct stv *state)
+{
+	u8 id;
+
+	state->receive_mode = RCVMODE_NONE;
+	state->started = 0;
+
+	if (read_reg(state, RSTV0910_MID, &id) < 0)
+		return -ENODEV;
+
+	if (id != 0x51)
+		return -EINVAL;
+
+	 /* Configure the I2C repeater to off */
+	write_reg(state, RSTV0910_P1_I2CRPT, 0x24);
+	/* Configure the I2C repeater to off */
+	write_reg(state, RSTV0910_P2_I2CRPT, 0x24);
+	/* Set the I2C to oversampling ratio */
+	write_reg(state, RSTV0910_I2CCFG, 0x88); /* state->i2ccfg */
+
+	write_reg(state, RSTV0910_OUTCFG,    0x00);  /* OUTCFG */
+	write_reg(state, RSTV0910_PADCFG,    0x05);  /* RFAGC Pads Dev = 05 */
+	write_reg(state, RSTV0910_SYNTCTRL,  0x02);  /* SYNTCTRL */
+	write_reg(state, RSTV0910_TSGENERAL, state->tsgeneral);  /* TSGENERAL */
+	write_reg(state, RSTV0910_CFGEXT,    0x02);  /* CFGEXT */
+
+	if (state->single)
+		write_reg(state, RSTV0910_GENCFG, 0x14);  /* GENCFG */
+	else
+		write_reg(state, RSTV0910_GENCFG, 0x15);  /* GENCFG */
+
+	write_reg(state, RSTV0910_P1_TNRCFG2, 0x02);  /* IQSWAP = 0 */
+	write_reg(state, RSTV0910_P2_TNRCFG2, 0x82);  /* IQSWAP = 1 */
+
+	write_reg(state, RSTV0910_P1_CAR3CFG, 0x02);
+	write_reg(state, RSTV0910_P2_CAR3CFG, 0x02);
+	write_reg(state, RSTV0910_P1_DMDCFG4, 0x04);
+	write_reg(state, RSTV0910_P2_DMDCFG4, 0x04);
+
+	write_reg(state, RSTV0910_TSTRES0, 0x80); /* LDPC Reset */
+	write_reg(state, RSTV0910_TSTRES0, 0x00);
+
+	write_reg(state, RSTV0910_P1_TSPIDFLT1, 0x00);
+	write_reg(state, RSTV0910_P2_TSPIDFLT1, 0x00);
+
+	write_reg(state, RSTV0910_P1_TMGCFG2, 0x80);
+	write_reg(state, RSTV0910_P2_TMGCFG2, 0x80);
+
+	set_mclock(state, 135000000);
+
+	/* TS output */
+	write_reg(state, RSTV0910_P1_TSCFGH, state->tscfgh | 0x01);
+	write_reg(state, RSTV0910_P1_TSCFGH, state->tscfgh);
+	write_reg(state, RSTV0910_P1_TSCFGM, 0xC0);  /* Manual speed */
+	write_reg(state, RSTV0910_P1_TSCFGL, 0x20);
+
+	/* Speed = 67.5 MHz */
+	write_reg(state, RSTV0910_P1_TSSPEED, state->tsspeed);
+
+	write_reg(state, RSTV0910_P2_TSCFGH, state->tscfgh | 0x01);
+	write_reg(state, RSTV0910_P2_TSCFGH, state->tscfgh);
+	write_reg(state, RSTV0910_P2_TSCFGM, 0xC0);  /* Manual speed */
+	write_reg(state, RSTV0910_P2_TSCFGL, 0x20);
+
+	/* Speed = 67.5 MHz */
+	write_reg(state, RSTV0910_P2_TSSPEED, state->tsspeed);
+
+	/* Reset stream merger */
+	write_reg(state, RSTV0910_P1_TSCFGH, state->tscfgh | 0x01);
+	write_reg(state, RSTV0910_P2_TSCFGH, state->tscfgh | 0x01);
+	write_reg(state, RSTV0910_P1_TSCFGH, state->tscfgh);
+	write_reg(state, RSTV0910_P2_TSCFGH, state->tscfgh);
+
+	write_reg(state, RSTV0910_P1_I2CRPT, state->i2crpt);
+	write_reg(state, RSTV0910_P2_I2CRPT, state->i2crpt);
+
+	init_diseqc(state);
+	return 0;
+}
+
+
+static int gate_ctrl(struct dvb_frontend *fe, int enable)
+{
+	struct stv *state = fe->demodulator_priv;
+	u8 i2crpt = state->i2crpt & ~0x86;
+
+	if (enable)
+		mutex_lock(&state->base->i2c_lock);
+
+	if (enable)
+		i2crpt |= 0x80;
+	else
+		i2crpt |= 0x02;
+
+	if (write_reg(state, state->nr ? RSTV0910_P2_I2CRPT :
+		      RSTV0910_P1_I2CRPT, i2crpt) < 0)
+		return -EIO;
+
+	state->i2crpt = i2crpt;
+
+	if (!enable)
+		mutex_unlock(&state->base->i2c_lock);
+	return 0;
+}
+
+static void release(struct dvb_frontend *fe)
+{
+	struct stv *state = fe->demodulator_priv;
+
+	state->base->count--;
+	if (state->base->count == 0) {
+		list_del(&state->base->stvlist);
+		kfree(state->base);
+	}
+	kfree(state);
+}
+
+static int set_parameters(struct dvb_frontend *fe)
+{
+	int stat = 0;
+	struct stv *state = fe->demodulator_priv;
+	u32 iffreq;
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+
+	stop(state);
+	if (fe->ops.tuner_ops.set_params)
+		fe->ops.tuner_ops.set_params(fe);
+	if (fe->ops.tuner_ops.get_if_frequency)
+		fe->ops.tuner_ops.get_if_frequency(fe, &iffreq);
+	state->symbol_rate = p->symbol_rate;
+	stat = start(state, p);
+	return stat;
+}
+
+static int manage_matype_info(struct stv *state)
+{
+	if (!state->started)
+		return -EINVAL;
+	if (state->receive_mode == RCVMODE_DVBS2) {
+		u8 bbheader[2];
+
+		read_regs(state, RSTV0910_P2_MATSTR1 + state->regoff,
+			bbheader, 2);
+		state->feroll_off =
+			(enum fe_stv0910_roll_off) (bbheader[0] & 0x03);
+		state->is_vcm = (bbheader[0] & 0x10) == 0;
+		state->is_standard_broadcast = (bbheader[0] & 0xFC) == 0xF0;
+	} else if (state->receive_mode == RCVMODE_DVBS) {
+		state->is_vcm = 0;
+		state->is_standard_broadcast = 1;
+		state->feroll_off = FE_SAT_35;
+	}
+	return 0;
+}
+
+static int read_snr(struct dvb_frontend *fe)
+{
+	struct stv *state = fe->demodulator_priv;
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+	s32 snrval;
+
+	if (!get_signal_to_noise(state, &snrval)) {
+		p->cnr.stat[0].scale = FE_SCALE_DECIBEL;
+		p->cnr.stat[0].uvalue = 100 * snrval; /* fix scale */
+	} else
+		p->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+
+	return 0;
+}
+
+static int read_ber(struct dvb_frontend *fe)
+{
+	struct stv *state = fe->demodulator_priv;
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+	u32 n, d;
+
+	get_bit_error_rate(state, &n, &d);
+
+	p->pre_bit_error.stat[0].scale = FE_SCALE_COUNTER;
+	p->pre_bit_error.stat[0].uvalue = n;
+	p->pre_bit_count.stat[0].scale = FE_SCALE_COUNTER;
+	p->pre_bit_count.stat[0].uvalue = d;
+
+	return 0;
+}
+
+static void read_signal_strength(struct dvb_frontend *fe)
+{
+	/* FIXME: add signal strength algo */
+	struct stv *state = fe->demodulator_priv;
+	struct dtv_frontend_properties *p = &state->fe.dtv_property_cache;
+
+	p->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+}
+
+static int read_status(struct dvb_frontend *fe, enum fe_status *status)
+{
+	struct stv *state = fe->demodulator_priv;
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+	u8 dmd_state = 0;
+	u8 dstatus  = 0;
+	enum receive_mode cur_receive_mode = RCVMODE_NONE;
+	u32 feclock = 0;
+
+	*status = 0;
+
+	read_reg(state, RSTV0910_P2_DMDSTATE + state->regoff, &dmd_state);
+
+	if (dmd_state & 0x40) {
+		read_reg(state, RSTV0910_P2_DSTATUS + state->regoff, &dstatus);
+		if (dstatus & 0x08)
+			cur_receive_mode = (dmd_state & 0x20) ?
+				RCVMODE_DVBS : RCVMODE_DVBS2;
+	}
+	if (cur_receive_mode == RCVMODE_NONE) {
+		set_vth(state);
+
+		/* reset signal statistics */
+		p->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+		p->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+		p->pre_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+		p->pre_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+
+		return 0;
+	}
+
+	*status |= (FE_HAS_SIGNAL
+		| FE_HAS_CARRIER
+		| FE_HAS_VITERBI
+		| FE_HAS_SYNC);
+
+	if (state->receive_mode == RCVMODE_NONE) {
+		state->receive_mode = cur_receive_mode;
+		state->demod_lock_time = jiffies;
+		state->first_time_lock = 1;
+
+		get_signal_parameters(state);
+		tracking_optimization(state);
+
+		write_reg(state, RSTV0910_P2_TSCFGH + state->regoff,
+			  state->tscfgh);
+		usleep_range(3000, 4000);
+		write_reg(state, RSTV0910_P2_TSCFGH + state->regoff,
+			  state->tscfgh | 0x01);
+		write_reg(state, RSTV0910_P2_TSCFGH + state->regoff,
+			  state->tscfgh);
+	}
+	if (dmd_state & 0x40) {
+		if (state->receive_mode == RCVMODE_DVBS2) {
+			u8 pdelstatus;
+
+			read_reg(state,
+				 RSTV0910_P2_PDELSTATUS1 + state->regoff,
+				 &pdelstatus);
+			feclock = (pdelstatus & 0x02) != 0;
+		} else {
+			u8 vstatus;
+
+			read_reg(state,
+				 RSTV0910_P2_VSTATUSVIT + state->regoff,
+				 &vstatus);
+			feclock = (vstatus & 0x08) != 0;
+		}
+	}
+
+	if (feclock) {
+		*status |= FE_HAS_LOCK;
+
+		if (state->first_time_lock) {
+			u8 tmp;
+
+			state->first_time_lock = 0;
+
+			manage_matype_info(state);
+
+			if (state->receive_mode == RCVMODE_DVBS2) {
+				/* FSTV0910_P2_MANUALSX_ROLLOFF,
+				 * FSTV0910_P2_MANUALS2_ROLLOFF = 0
+				 */
+				state->demod_bits &= ~0x84;
+				write_reg(state,
+					  RSTV0910_P2_DEMOD + state->regoff,
+					  state->demod_bits);
+				read_reg(state,
+					 RSTV0910_P2_PDELCTRL2 + state->regoff,
+					 &tmp);
+				/*reset DVBS2 packet delinator error counter */
+				tmp |= 0x40;
+				write_reg(state,
+					  RSTV0910_P2_PDELCTRL2 + state->regoff,
+					  tmp);
+				/*reset DVBS2 packet delinator error counter */
+				tmp &= ~0x40;
+				write_reg(state,
+					  RSTV0910_P2_PDELCTRL2 + state->regoff,
+					  tmp);
+
+				state->berscale = 2;
+				state->last_bernumerator = 0;
+				state->last_berdenominator = 1;
+				/* force to PRE BCH Rate */
+				write_reg(state,
+					  RSTV0910_P2_ERRCTRL1 + state->regoff,
+					  BER_SRC_S2 | state->berscale);
+			} else {
+				state->berscale = 2;
+				state->last_bernumerator = 0;
+				state->last_berdenominator = 1;
+				/* force to PRE RS Rate */
+				write_reg(state,
+					  RSTV0910_P2_ERRCTRL1 + state->regoff,
+					  BER_SRC_S | state->berscale);
+			}
+			/*Reset the Total packet counter */
+			write_reg(state,
+				  RSTV0910_P2_FBERCPT4 + state->regoff, 0x00);
+			/* Reset the packet Error counter2 (and Set it to
+			 * infinit error count mode )
+			 */
+			write_reg(state,
+				  RSTV0910_P2_ERRCTRL2 + state->regoff, 0xc1);
+
+			set_vth_default(state);
+			if (state->receive_mode == RCVMODE_DVBS)
+				enable_puncture_rate(state,
+						     state->puncture_rate);
+		}
+	}
+
+	/* read signal statistics */
+
+	/* read signal strength */
+	read_signal_strength(fe);
+
+	/* read carrier/noise on FE_HAS_CARRIER */
+	if (*status & FE_HAS_CARRIER)
+		read_snr(fe);
+	else
+		p->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+
+	/* read ber */
+	if (*status & FE_HAS_VITERBI)
+		read_ber(fe);
+	else {
+		p->pre_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+		p->pre_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	}
+
+	return 0;
+}
+
+static int get_frontend(struct dvb_frontend *fe,
+			struct dtv_frontend_properties *p)
+{
+	struct stv *state = fe->demodulator_priv;
+	u8 tmp;
+
+	if (state->receive_mode == RCVMODE_DVBS2) {
+		u32 mc;
+		enum fe_modulation modcod2mod[0x20] = {
+			QPSK, QPSK, QPSK, QPSK,
+			QPSK, QPSK, QPSK, QPSK,
+			QPSK, QPSK, QPSK, QPSK,
+			PSK_8, PSK_8, PSK_8, PSK_8,
+			PSK_8, PSK_8, APSK_16, APSK_16,
+			APSK_16, APSK_16, APSK_16, APSK_16,
+			APSK_32, APSK_32, APSK_32, APSK_32,
+			APSK_32,
+		};
+		enum fe_code_rate modcod2fec[0x20] = {
+			FEC_NONE, FEC_NONE, FEC_NONE, FEC_2_5,
+			FEC_1_2, FEC_3_5, FEC_2_3, FEC_3_4,
+			FEC_4_5, FEC_5_6, FEC_8_9, FEC_9_10,
+			FEC_3_5, FEC_2_3, FEC_3_4, FEC_5_6,
+			FEC_8_9, FEC_9_10, FEC_2_3, FEC_3_4,
+			FEC_4_5, FEC_5_6, FEC_8_9, FEC_9_10,
+			FEC_3_4, FEC_4_5, FEC_5_6, FEC_8_9,
+			FEC_9_10
+		};
+		read_reg(state, RSTV0910_P2_DMDMODCOD + state->regoff, &tmp);
+		mc = ((tmp & 0x7c) >> 2);
+		p->pilot = (tmp & 0x01) ? PILOT_ON : PILOT_OFF;
+		p->modulation = modcod2mod[mc];
+		p->fec_inner = modcod2fec[mc];
+	} else if (state->receive_mode == RCVMODE_DVBS) {
+		read_reg(state, RSTV0910_P2_VITCURPUN + state->regoff, &tmp);
+		switch (tmp & 0x1F) {
+		case 0x0d:
+			p->fec_inner = FEC_1_2;
+			break;
+		case 0x12:
+			p->fec_inner = FEC_2_3;
+			break;
+		case 0x15:
+			p->fec_inner = FEC_3_4;
+			break;
+		case 0x18:
+			p->fec_inner = FEC_5_6;
+			break;
+		case 0x1a:
+			p->fec_inner = FEC_7_8;
+			break;
+		default:
+			p->fec_inner = FEC_NONE;
+			break;
+		}
+		p->rolloff = ROLLOFF_35;
+	}
+
+	return 0;
+}
+
+static int tune(struct dvb_frontend *fe, bool re_tune,
+		unsigned int mode_flags,
+		unsigned int *delay, enum fe_status *status)
+{
+	struct stv *state = fe->demodulator_priv;
+	int r;
+
+	if (re_tune) {
+		r = set_parameters(fe);
+		if (r)
+			return r;
+		state->tune_time = jiffies;
+	}
+	if (*status & FE_HAS_LOCK)
+		return 0;
+	*delay = HZ;
+
+	r = read_status(fe, status);
+	if (r)
+		return r;
+	return 0;
+}
+
+
+static int get_algo(struct dvb_frontend *fe)
+{
+	return DVBFE_ALGO_HW;
+}
+
+static int set_tone(struct dvb_frontend *fe, enum fe_sec_tone_mode tone)
+{
+	struct stv *state = fe->demodulator_priv;
+	u16 offs = state->nr ? 0x40 : 0;
+
+	switch (tone) {
+	case SEC_TONE_ON:
+		return write_reg(state, RSTV0910_P1_DISTXCFG + offs, 0x38);
+	case SEC_TONE_OFF:
+		return write_reg(state, RSTV0910_P1_DISTXCFG + offs, 0x3a);
+	default:
+		break;
+	}
+	return -EINVAL;
+}
+
+static int wait_dis(struct stv *state, u8 flag, u8 val)
+{
+	int i;
+	u8 stat;
+	u16 offs = state->nr ? 0x40 : 0;
+
+	for (i = 0; i < 10; i++) {
+		read_reg(state, RSTV0910_P1_DISTXSTATUS + offs, &stat);
+		if ((stat & flag) == val)
+			return 0;
+		usleep_range(10000, 11000);
+	}
+	return -ETIMEDOUT;
+}
+
+static int send_master_cmd(struct dvb_frontend *fe,
+			   struct dvb_diseqc_master_cmd *cmd)
+{
+	struct stv *state = fe->demodulator_priv;
+	u16 offs = state->nr ? 0x40 : 0;
+	int i;
+
+	write_reg(state, RSTV0910_P1_DISTXCFG + offs, 0x3E);
+	for (i = 0; i < cmd->msg_len; i++) {
+		wait_dis(state, 0x40, 0x00);
+		write_reg(state, RSTV0910_P1_DISTXFIFO + offs, cmd->msg[i]);
+	}
+	write_reg(state, RSTV0910_P1_DISTXCFG + offs, 0x3A);
+	wait_dis(state, 0x20, 0x20);
+	return 0;
+}
+
+static int sleep(struct dvb_frontend *fe)
+{
+	struct stv *state = fe->demodulator_priv;
+
+	stop(state);
+	return 0;
+}
+
+static struct dvb_frontend_ops stv0910_ops = {
+	.delsys = { SYS_DVBS, SYS_DVBS2, SYS_DSS },
+	.info = {
+		.name			= "STV0910",
+		.frequency_min		= 950000,
+		.frequency_max		= 2150000,
+		.frequency_stepsize	= 0,
+		.frequency_tolerance	= 0,
+		.symbol_rate_min	= 1000000,
+		.symbol_rate_max	= 70000000,
+		.caps			= FE_CAN_INVERSION_AUTO |
+					  FE_CAN_FEC_AUTO       |
+					  FE_CAN_QPSK           |
+					  FE_CAN_2G_MODULATION
+	},
+	.sleep				= sleep,
+	.release                        = release,
+	.i2c_gate_ctrl                  = gate_ctrl,
+	.get_frontend_algo              = get_algo,
+	.get_frontend                   = get_frontend,
+	.tune                           = tune,
+	.read_status			= read_status,
+	.set_tone			= set_tone,
+
+	.diseqc_send_master_cmd		= send_master_cmd,
+};
+
+static struct stv_base *match_base(struct i2c_adapter  *i2c, u8 adr)
+{
+	struct stv_base *p;
+
+	list_for_each_entry(p, &stvlist, stvlist)
+		if (p->i2c == i2c && p->adr == adr)
+			return p;
+	return NULL;
+}
+
+static void stv0910_init_stats(struct stv *state)
+{
+	struct dtv_frontend_properties *p = &state->fe.dtv_property_cache;
+
+	p->strength.len = 1;
+	p->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	p->cnr.len = 1;
+	p->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	p->pre_bit_error.len = 1;
+	p->pre_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	p->pre_bit_count.len = 1;
+	p->pre_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+}
+
+struct dvb_frontend *stv0910_attach(struct i2c_adapter *i2c,
+				    struct stv0910_cfg *cfg,
+				    int nr)
+{
+	struct stv *state;
+	struct stv_base *base;
+
+	state = kzalloc(sizeof(struct stv), GFP_KERNEL);
+	if (!state)
+		return NULL;
+
+	state->tscfgh = 0x20 | (cfg->parallel ? 0 : 0x40);
+	state->tsgeneral = (cfg->parallel == 2) ? 0x02 : 0x00;
+	state->i2crpt = 0x0A | ((cfg->rptlvl & 0x07) << 4);
+	state->tsspeed = 0x28;
+	state->nr = nr;
+	state->regoff = state->nr ? 0 : 0x200;
+	state->search_range = 16000000;
+	state->demod_bits = 0x10;     /* Inversion : Auto with reset to 0 */
+	state->receive_mode   = RCVMODE_NONE;
+	state->single = cfg->single ? 1 : 0;
+
+	base = match_base(i2c, cfg->adr);
+	if (base) {
+		base->count++;
+		state->base = base;
+	} else {
+		base = kzalloc(sizeof(struct stv_base), GFP_KERNEL);
+		if (!base)
+			goto fail;
+		base->i2c = i2c;
+		base->adr = cfg->adr;
+		base->count = 1;
+		base->extclk = cfg->clk ? cfg->clk : 30000000;
+
+		mutex_init(&base->i2c_lock);
+		mutex_init(&base->reg_lock);
+		state->base = base;
+		if (probe(state) < 0) {
+			dev_info(&i2c->dev, "No demod found at adr %02X on %s\n",
+				cfg->adr, dev_name(&i2c->dev));
+			kfree(base);
+			goto fail;
+		}
+		list_add(&base->stvlist, &stvlist);
+	}
+	state->fe.ops               = stv0910_ops;
+	state->fe.demodulator_priv  = state;
+	state->nr = nr;
+
+	dev_info(&i2c->dev, "%s demod found at adr %02X on %s\n",
+		state->fe.ops.info.name, cfg->adr, dev_name(&i2c->dev));
+
+	stv0910_init_stats(state);
+
+	return &state->fe;
+
+fail:
+	kfree(state);
+	return NULL;
+}
+EXPORT_SYMBOL_GPL(stv0910_attach);
+
+MODULE_DESCRIPTION("ST STV0910 multistandard frontend driver");
+MODULE_AUTHOR("Ralph and Marcus Metzler, Manfred Voelkel");
+MODULE_LICENSE("GPL");
