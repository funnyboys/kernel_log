commit c942fddf8793b2013be8c901b47d0a8dc02bf99f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:06 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 157
    
    Based on 3 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [kishon] [vijay] [abraham]
      [i] [kishon]@[ti] [com] this program is distributed in the hope that
      it will be useful but without any warranty without even the implied
      warranty of merchantability or fitness for a particular purpose see
      the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [graeme] [gregory]
      [gg]@[slimlogic] [co] [uk] [author] [kishon] [vijay] [abraham] [i]
      [kishon]@[ti] [com] [based] [on] [twl6030]_[usb] [c] [author] [hema]
      [hk] [hemahk]@[ti] [com] this program is distributed in the hope
      that it will be useful but without any warranty without even the
      implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1105 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.202006027@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/media/dvb-frontends/rtl2830.c b/drivers/media/dvb-frontends/rtl2830.c
index c0659568471b..e6b8367c8cce 100644
--- a/drivers/media/dvb-frontends/rtl2830.c
+++ b/drivers/media/dvb-frontends/rtl2830.c
@@ -1,18 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Realtek RTL2830 DVB-T demodulator driver
  *
  * Copyright (C) 2011 Antti Palosaari <crope@iki.fi>
- *
- *    This program is free software; you can redistribute it and/or modify
- *    it under the terms of the GNU General Public License as published by
- *    the Free Software Foundation; either version 2 of the License, or
- *    (at your option) any later version.
- *
- *    This program is distributed in the hope that it will be useful,
- *    but WITHOUT ANY WARRANTY; without even the implied warranty of
- *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *    GNU General Public License for more details.
- *
  */
 
 #include "rtl2830_priv.h"

commit 99cc7ad46b62ef20b0478147677bebd1157bd9cf
Merge: 0214f46b3a03 19358d4488db
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Aug 21 17:40:46 2018 -0700

    Merge branch 'i2c/for-4.19' of git://git.kernel.org/pub/scm/linux/kernel/git/wsa/linux
    
    Pull i2c updates from Wolfram Sang:
    
     - the core has now a lockless variant of i2c_smbus_xfer. Some open
       coded versions of this got removed in drivers. This also enables
       proper SCCB support in regmap.
    
     - locking got a more precise naming. i2c_{un}lock_adapter() had to go,
       and we know use i2c_lock_bus() consistently with flags like
       I2C_LOCK_ROOT_ADAPTER and I2C_LOCK_SEGMENT to avoid ambiguity.
    
     - the gpio fault injector got a new delicate testcase
    
     - the bus recovery procedure got fixed to handle the new testcase
       correctly
    
     - a new quirk flag for controllers not able to handle zero length
       messages together with driver updates to use it
    
     - new drivers: FSI bus attached I2C masters, GENI I2C controller, Owl
       family S900
    
     - and a good set of driver improvements and bugfixes
    
    * 'i2c/for-4.19' of git://git.kernel.org/pub/scm/linux/kernel/git/wsa/linux: (77 commits)
      i2c: rcar: implement STOP and REP_START according to docs
      i2c: rcar: refactor private flags
      i2c: core: ACPI: Make acpi_gsb_i2c_read_bytes() check i2c_transfer return value
      i2c: core: ACPI: Properly set status byte to 0 for multi-byte writes
      dt-bindings: i2c: rcar: Add r8a774a1 support
      dt-bindings: i2c: sh_mobile: Add r8a774a1 support
      i2c: imx: Simplify stopped state tracking
      i2c: imx: Fix race condition in dma read
      i2c: pasemi: remove hardcoded bus numbers on smbus
      i2c: designware: Add SPDX license tag
      i2c: designware: Convert to use struct i2c_timings
      i2c: core: Parse SDA hold time from firmware
      i2c: designware-pcidrv: Mark expected switch fall-through
      i2c: amd8111: Mark expected switch fall-through
      i2c: sh_mobile: use core to detect 'no zero length read' quirk
      i2c: xlr: use core to detect 'no zero length' quirk
      i2c: rcar: use core to detect 'no zero length' quirk
      i2c: stu300: use core to detect 'no zero length' quirk
      i2c: pmcmsp: use core to detect 'no zero length' quirk
      i2c: mxs: use core to detect 'no zero length' quirk
      ...

commit f1b1eabff0eb3fc46b06668de8174c0f23b271fd
Author: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
Date:   Thu Jul 5 18:59:36 2018 -0400

    media: dvb: represent min/max/step/tolerance freqs in Hz
    
    Right now, satellite frontend drivers specify frequencies in kHz,
    while terrestrial/cable ones specify in Hz. That's confusing
    for developers.
    
    However, the main problem is that universal frontends capable
    of handling both satellite and non-satelite delivery systems
    are appearing. We end by needing to hack the drivers in
    order to support such hybrid frontends.
    
    So, convert everything to specify frontend frequencies in Hz.
    
    Tested-by: Katsuhiro Suzuki <suzuki.katsuhiro@socionext.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/dvb-frontends/rtl2830.c b/drivers/media/dvb-frontends/rtl2830.c
index 7bbfe11d11ed..adc9046d5a90 100644
--- a/drivers/media/dvb-frontends/rtl2830.c
+++ b/drivers/media/dvb-frontends/rtl2830.c
@@ -159,8 +159,8 @@ static int rtl2830_get_tune_settings(struct dvb_frontend *fe,
 				     struct dvb_frontend_tune_settings *s)
 {
 	s->min_delay_ms = 500;
-	s->step_size = fe->ops.info.frequency_stepsize * 2;
-	s->max_drift = (fe->ops.info.frequency_stepsize * 2) + 1;
+	s->step_size = fe->ops.info.frequency_stepsize_hz * 2;
+	s->max_drift = (fe->ops.info.frequency_stepsize_hz * 2) + 1;
 
 	return 0;
 }

commit dfecde407623b19cb9d57ebfa5abbca9741d96cb
Author: Peter Rosin <peda@axentia.se>
Date:   Wed Jun 20 07:17:59 2018 +0200

    media: rtl2830: switch to i2c_lock_bus(..., I2C_LOCK_SEGMENT)
    
    Locking the root adapter for __i2c_transfer will deadlock if the
    device sits behind a mux-locked I2C mux. Switch to the finer-grained
    i2c_lock_bus with the I2C_LOCK_SEGMENT flag. If the device does not
    sit behind a mux-locked mux, the two locking variants are equivalent.
    
    Signed-off-by: Peter Rosin <peda@axentia.se>
    Acked-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/media/dvb-frontends/rtl2830.c b/drivers/media/dvb-frontends/rtl2830.c
index 7bbfe11d11ed..91d12e6a03d5 100644
--- a/drivers/media/dvb-frontends/rtl2830.c
+++ b/drivers/media/dvb-frontends/rtl2830.c
@@ -24,9 +24,9 @@ static int rtl2830_bulk_write(struct i2c_client *client, unsigned int reg,
 	struct rtl2830_dev *dev = i2c_get_clientdata(client);
 	int ret;
 
-	i2c_lock_adapter(client->adapter);
+	i2c_lock_bus(client->adapter, I2C_LOCK_SEGMENT);
 	ret = regmap_bulk_write(dev->regmap, reg, val, val_count);
-	i2c_unlock_adapter(client->adapter);
+	i2c_unlock_bus(client->adapter, I2C_LOCK_SEGMENT);
 	return ret;
 }
 
@@ -36,9 +36,9 @@ static int rtl2830_update_bits(struct i2c_client *client, unsigned int reg,
 	struct rtl2830_dev *dev = i2c_get_clientdata(client);
 	int ret;
 
-	i2c_lock_adapter(client->adapter);
+	i2c_lock_bus(client->adapter, I2C_LOCK_SEGMENT);
 	ret = regmap_update_bits(dev->regmap, reg, mask, val);
-	i2c_unlock_adapter(client->adapter);
+	i2c_unlock_bus(client->adapter, I2C_LOCK_SEGMENT);
 	return ret;
 }
 
@@ -48,9 +48,9 @@ static int rtl2830_bulk_read(struct i2c_client *client, unsigned int reg,
 	struct rtl2830_dev *dev = i2c_get_clientdata(client);
 	int ret;
 
-	i2c_lock_adapter(client->adapter);
+	i2c_lock_bus(client->adapter, I2C_LOCK_SEGMENT);
 	ret = regmap_bulk_read(dev->regmap, reg, val, val_count);
-	i2c_unlock_adapter(client->adapter);
+	i2c_unlock_bus(client->adapter, I2C_LOCK_SEGMENT);
 	return ret;
 }
 

commit bd336e63441bcdeeccca6a698087d913a32478c5
Author: Max Kellermann <max.kellermann@gmail.com>
Date:   Tue Aug 9 18:32:21 2016 -0300

    [media] dvb: make DVB frontend *_ops instances "const"
    
    These are immutable.  Making them "const" allows the compiler to move
    them to the "rodata" section.
    
    Note that cxd2841er_t_c_ops cannot be made "const", because
    cxd2841er_attach() modifies it.  Ouch!
    
    [mchehab@s-opensource.com: fix merge conflicts]
    Signed-off-by: Max Kellermann <max.kellermann@gmail.com>
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/rtl2830.c b/drivers/media/dvb-frontends/rtl2830.c
index 87226056f226..7bbfe11d11ed 100644
--- a/drivers/media/dvb-frontends/rtl2830.c
+++ b/drivers/media/dvb-frontends/rtl2830.c
@@ -548,7 +548,7 @@ static int rtl2830_read_signal_strength(struct dvb_frontend *fe, u16 *strength)
 	return 0;
 }
 
-static struct dvb_frontend_ops rtl2830_ops = {
+static const struct dvb_frontend_ops rtl2830_ops = {
 	.delsys = {SYS_DVBT},
 	.info = {
 		.name = "Realtek RTL2830 (DVB-T)",

commit 4a7e445b1b02cc6acd051c064cae7c325e411842
Author: Antti Palosaari <crope@iki.fi>
Date:   Wed Jun 29 20:40:56 2016 -0300

    [media] rtl2830: move statistics to read_status()
    
    Move statistics polling to read_status() in order to avoid use of
    kernel work. Also replace home made sign extension used for
    statistics with kernel sign_extend32().
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/rtl2830.c b/drivers/media/dvb-frontends/rtl2830.c
index ec1e94a0a238..87226056f226 100644
--- a/drivers/media/dvb-frontends/rtl2830.c
+++ b/drivers/media/dvb-frontends/rtl2830.c
@@ -135,8 +135,6 @@ static int rtl2830_init(struct dvb_frontend *fe)
 	c->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
 	c->post_bit_count.len = 1;
 	c->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
-	/* start statistics polling */
-	schedule_delayed_work(&dev->stat_work, msecs_to_jiffies(2000));
 
 	dev->sleeping = false;
 
@@ -152,8 +150,6 @@ static int rtl2830_sleep(struct dvb_frontend *fe)
 	struct rtl2830_dev *dev = i2c_get_clientdata(client);
 
 	dev->sleeping = true;
-	/* stop statistics polling */
-	cancel_delayed_work_sync(&dev->stat_work);
 	dev->fe_status = 0;
 
 	return 0;
@@ -396,8 +392,10 @@ static int rtl2830_read_status(struct dvb_frontend *fe, enum fe_status *status)
 {
 	struct i2c_client *client = fe->demodulator_priv;
 	struct rtl2830_dev *dev = i2c_get_clientdata(client);
-	int ret;
-	u8 u8tmp;
+	struct dtv_frontend_properties *c = &dev->fe.dtv_property_cache;
+	int ret, stmp;
+	unsigned int utmp;
+	u8 u8tmp, buf[2];
 
 	*status = 0;
 
@@ -419,6 +417,89 @@ static int rtl2830_read_status(struct dvb_frontend *fe, enum fe_status *status)
 
 	dev->fe_status = *status;
 
+	/* Signal strength */
+	if (dev->fe_status & FE_HAS_SIGNAL) {
+		/* Read IF AGC */
+		ret = rtl2830_bulk_read(client, 0x359, buf, 2);
+		if (ret)
+			goto err;
+
+		stmp = buf[0] << 8 | buf[1] << 0;
+		stmp = sign_extend32(stmp, 13);
+		utmp = clamp_val(-4 * stmp + 32767, 0x0000, 0xffff);
+
+		dev_dbg(&client->dev, "IF AGC=%d\n", stmp);
+
+		c->strength.stat[0].scale = FE_SCALE_RELATIVE;
+		c->strength.stat[0].uvalue = utmp;
+	} else {
+		c->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	}
+
+	/* CNR */
+	if (dev->fe_status & FE_HAS_VITERBI) {
+		unsigned int hierarchy, constellation;
+		#define CONSTELLATION_NUM 3
+		#define HIERARCHY_NUM 4
+		static const u32 constant[CONSTELLATION_NUM][HIERARCHY_NUM] = {
+			{70705899, 70705899, 70705899, 70705899},
+			{82433173, 82433173, 87483115, 94445660},
+			{92888734, 92888734, 95487525, 99770748},
+		};
+
+		ret = rtl2830_bulk_read(client, 0x33c, &u8tmp, 1);
+		if (ret)
+			goto err;
+
+		constellation = (u8tmp >> 2) & 0x03; /* [3:2] */
+		if (constellation > CONSTELLATION_NUM - 1)
+			goto err;
+
+		hierarchy = (u8tmp >> 4) & 0x07; /* [6:4] */
+		if (hierarchy > HIERARCHY_NUM - 1)
+			goto err;
+
+		ret = rtl2830_bulk_read(client, 0x40c, buf, 2);
+		if (ret)
+			goto err;
+
+		utmp = buf[0] << 8 | buf[1] << 0;
+		if (utmp)
+			stmp = (constant[constellation][hierarchy] -
+			       intlog10(utmp)) / ((1 << 24) / 10000);
+		else
+			stmp = 0;
+
+		dev_dbg(&client->dev, "CNR raw=%u\n", utmp);
+
+		c->cnr.stat[0].scale = FE_SCALE_DECIBEL;
+		c->cnr.stat[0].svalue = stmp;
+	} else {
+		c->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	}
+
+	/* BER */
+	if (dev->fe_status & FE_HAS_LOCK) {
+		ret = rtl2830_bulk_read(client, 0x34e, buf, 2);
+		if (ret)
+			goto err;
+
+		utmp = buf[0] << 8 | buf[1] << 0;
+		dev->post_bit_error += utmp;
+		dev->post_bit_count += 1000000;
+
+		dev_dbg(&client->dev, "BER errors=%u total=1000000\n", utmp);
+
+		c->post_bit_error.stat[0].scale = FE_SCALE_COUNTER;
+		c->post_bit_error.stat[0].uvalue = dev->post_bit_error;
+		c->post_bit_count.stat[0].scale = FE_SCALE_COUNTER;
+		c->post_bit_count.stat[0].uvalue = dev->post_bit_count;
+	} else {
+		c->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+		c->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	}
+
+
 	return ret;
 err:
 	dev_dbg(&client->dev, "failed=%d\n", ret);
@@ -503,109 +584,6 @@ static struct dvb_frontend_ops rtl2830_ops = {
 	.read_signal_strength = rtl2830_read_signal_strength,
 };
 
-static void rtl2830_stat_work(struct work_struct *work)
-{
-	struct rtl2830_dev *dev = container_of(work, struct rtl2830_dev, stat_work.work);
-	struct i2c_client *client = dev->client;
-	struct dtv_frontend_properties *c = &dev->fe.dtv_property_cache;
-	int ret, tmp;
-	u8 u8tmp, buf[2];
-	u16 u16tmp;
-
-	dev_dbg(&client->dev, "\n");
-
-	/* signal strength */
-	if (dev->fe_status & FE_HAS_SIGNAL) {
-		struct {signed int x:14; } s;
-
-		/* read IF AGC */
-		ret = rtl2830_bulk_read(client, 0x359, buf, 2);
-		if (ret)
-			goto err;
-
-		u16tmp = buf[0] << 8 | buf[1] << 0;
-		u16tmp &= 0x3fff; /* [13:0] */
-		tmp = s.x = u16tmp; /* 14-bit bin to 2 complement */
-		u16tmp = clamp_val(-4 * tmp + 32767, 0x0000, 0xffff);
-
-		dev_dbg(&client->dev, "IF AGC=%d\n", tmp);
-
-		c->strength.stat[0].scale = FE_SCALE_RELATIVE;
-		c->strength.stat[0].uvalue = u16tmp;
-	} else {
-		c->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
-	}
-
-	/* CNR */
-	if (dev->fe_status & FE_HAS_VITERBI) {
-		unsigned hierarchy, constellation;
-		#define CONSTELLATION_NUM 3
-		#define HIERARCHY_NUM 4
-		static const u32 constant[CONSTELLATION_NUM][HIERARCHY_NUM] = {
-			{70705899, 70705899, 70705899, 70705899},
-			{82433173, 82433173, 87483115, 94445660},
-			{92888734, 92888734, 95487525, 99770748},
-		};
-
-		ret = rtl2830_bulk_read(client, 0x33c, &u8tmp, 1);
-		if (ret)
-			goto err;
-
-		constellation = (u8tmp >> 2) & 0x03; /* [3:2] */
-		if (constellation > CONSTELLATION_NUM - 1)
-			goto err_schedule_delayed_work;
-
-		hierarchy = (u8tmp >> 4) & 0x07; /* [6:4] */
-		if (hierarchy > HIERARCHY_NUM - 1)
-			goto err_schedule_delayed_work;
-
-		ret = rtl2830_bulk_read(client, 0x40c, buf, 2);
-		if (ret)
-			goto err;
-
-		u16tmp = buf[0] << 8 | buf[1] << 0;
-		if (u16tmp)
-			tmp = (constant[constellation][hierarchy] -
-			       intlog10(u16tmp)) / ((1 << 24) / 10000);
-		else
-			tmp = 0;
-
-		dev_dbg(&client->dev, "CNR raw=%u\n", u16tmp);
-
-		c->cnr.stat[0].scale = FE_SCALE_DECIBEL;
-		c->cnr.stat[0].svalue = tmp;
-	} else {
-		c->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
-	}
-
-	/* BER */
-	if (dev->fe_status & FE_HAS_LOCK) {
-		ret = rtl2830_bulk_read(client, 0x34e, buf, 2);
-		if (ret)
-			goto err;
-
-		u16tmp = buf[0] << 8 | buf[1] << 0;
-		dev->post_bit_error += u16tmp;
-		dev->post_bit_count += 1000000;
-
-		dev_dbg(&client->dev, "BER errors=%u total=1000000\n", u16tmp);
-
-		c->post_bit_error.stat[0].scale = FE_SCALE_COUNTER;
-		c->post_bit_error.stat[0].uvalue = dev->post_bit_error;
-		c->post_bit_count.stat[0].scale = FE_SCALE_COUNTER;
-		c->post_bit_count.stat[0].uvalue = dev->post_bit_count;
-	} else {
-		c->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
-		c->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
-	}
-
-err_schedule_delayed_work:
-	schedule_delayed_work(&dev->stat_work, msecs_to_jiffies(2000));
-	return;
-err:
-	dev_dbg(&client->dev, "failed=%d\n", ret);
-}
-
 static int rtl2830_pid_filter_ctrl(struct dvb_frontend *fe, int onoff)
 {
 	struct i2c_client *client = fe->demodulator_priv;
@@ -851,7 +829,6 @@ static int rtl2830_probe(struct i2c_client *client,
 	dev->client = client;
 	dev->pdata = client->dev.platform_data;
 	dev->sleeping = true;
-	INIT_DELAYED_WORK(&dev->stat_work, rtl2830_stat_work);
 	dev->regmap = regmap_init(&client->dev, &regmap_bus, client,
 				  &regmap_config);
 	if (IS_ERR(dev->regmap)) {
@@ -904,9 +881,6 @@ static int rtl2830_remove(struct i2c_client *client)
 
 	dev_dbg(&client->dev, "\n");
 
-	/* stop statistics polling */
-	cancel_delayed_work_sync(&dev->stat_work);
-
 	i2c_mux_del_adapters(dev->muxc);
 	regmap_exit(dev->regmap);
 	kfree(dev);

commit 95e7cdb7db5857ddb3af01d9cd9895eb24a3b93f
Author: Antti Palosaari <crope@iki.fi>
Date:   Wed Jun 29 20:40:55 2016 -0300

    [media] rtl2830: do not allow driver unbind
    
    Disable runtime unbind as driver does not support it.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/rtl2830.c b/drivers/media/dvb-frontends/rtl2830.c
index d25d1e0cd4ca..ec1e94a0a238 100644
--- a/drivers/media/dvb-frontends/rtl2830.c
+++ b/drivers/media/dvb-frontends/rtl2830.c
@@ -922,7 +922,8 @@ MODULE_DEVICE_TABLE(i2c, rtl2830_id_table);
 
 static struct i2c_driver rtl2830_driver = {
 	.driver = {
-		.name	= "rtl2830",
+		.name			= "rtl2830",
+		.suppress_bind_attrs	= true,
 	},
 	.probe		= rtl2830_probe,
 	.remove		= rtl2830_remove,

commit a0119159e66e2e67154384d7e20a0ebf46cfa32b
Author: Peter Rosin <peda@axentia.se>
Date:   Wed Apr 20 08:41:13 2016 +0200

    [media] rtl2830: convert to use an explicit i2c mux core
    
    Allocate an explicit i2c mux core to handle parent and child adapters
    etc. Update the select op to be in terms of the i2c mux core instead
    of the child adapter.
    
    Tested-by: Antti Palosaari <crope@iki.fi>
    Reviewed-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Peter Rosin <peda@axentia.se>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/media/dvb-frontends/rtl2830.c b/drivers/media/dvb-frontends/rtl2830.c
index 3f96429af0e5..d25d1e0cd4ca 100644
--- a/drivers/media/dvb-frontends/rtl2830.c
+++ b/drivers/media/dvb-frontends/rtl2830.c
@@ -677,9 +677,9 @@ static int rtl2830_pid_filter(struct dvb_frontend *fe, u8 index, u16 pid, int on
  * adapter lock is already taken by tuner driver.
  * Gate is closed automatically after single I2C transfer.
  */
-static int rtl2830_select(struct i2c_adapter *adap, void *mux_priv, u32 chan_id)
+static int rtl2830_select(struct i2c_mux_core *muxc, u32 chan_id)
 {
-	struct i2c_client *client = mux_priv;
+	struct i2c_client *client = i2c_mux_priv(muxc);
 	struct rtl2830_dev *dev = i2c_get_clientdata(client);
 	int ret;
 
@@ -712,7 +712,7 @@ static struct i2c_adapter *rtl2830_get_i2c_adapter(struct i2c_client *client)
 
 	dev_dbg(&client->dev, "\n");
 
-	return dev->adapter;
+	return dev->muxc->adapter[0];
 }
 
 /*
@@ -865,12 +865,16 @@ static int rtl2830_probe(struct i2c_client *client,
 		goto err_regmap_exit;
 
 	/* create muxed i2c adapter for tuner */
-	dev->adapter = i2c_add_mux_adapter(client->adapter, &client->dev,
-			client, 0, 0, 0, rtl2830_select, NULL);
-	if (dev->adapter == NULL) {
-		ret = -ENODEV;
+	dev->muxc = i2c_mux_alloc(client->adapter, &client->dev, 1, 0, 0,
+				  rtl2830_select, NULL);
+	if (!dev->muxc) {
+		ret = -ENOMEM;
 		goto err_regmap_exit;
 	}
+	dev->muxc->priv = client;
+	ret = i2c_mux_add_adapter(dev->muxc, 0, 0, 0);
+	if (ret)
+		goto err_regmap_exit;
 
 	/* create dvb frontend */
 	memcpy(&dev->fe.ops, &rtl2830_ops, sizeof(dev->fe.ops));
@@ -903,7 +907,7 @@ static int rtl2830_remove(struct i2c_client *client)
 	/* stop statistics polling */
 	cancel_delayed_work_sync(&dev->stat_work);
 
-	i2c_del_mux_adapter(dev->adapter);
+	i2c_mux_del_adapters(dev->muxc);
 	regmap_exit(dev->regmap);
 	kfree(dev);
 

commit 7e3e68bcfd7713fb1470070c8fa0f108609dd76b
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Thu Feb 4 12:58:30 2016 -0200

    [media] dvb_frontend: pass the props cache to get_frontend() as arg
    
    Instead of using the DTV properties cache directly, pass the get
    frontend data as an argument. For now, everything should remain
    the same, but the next patch will prevent get_frontend to
    affect the global cache.
    
    This is needed because several drivers don't care enough to only
    change the properties if locked. Due to that, calling
    G_PROPERTY before locking on those drivers will make them to
    never lock. Ok, those drivers are crap and should never be
    merged like that, but the core should not rely that the drivers
    would be doing the right thing.
    
    Reviewed-by: Michael Ira Krufky <mkrufky@linuxtv.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/rtl2830.c b/drivers/media/dvb-frontends/rtl2830.c
index 74b771218033..3f96429af0e5 100644
--- a/drivers/media/dvb-frontends/rtl2830.c
+++ b/drivers/media/dvb-frontends/rtl2830.c
@@ -279,11 +279,11 @@ static int rtl2830_set_frontend(struct dvb_frontend *fe)
 	return ret;
 }
 
-static int rtl2830_get_frontend(struct dvb_frontend *fe)
+static int rtl2830_get_frontend(struct dvb_frontend *fe,
+				struct dtv_frontend_properties *c)
 {
 	struct i2c_client *client = fe->demodulator_priv;
 	struct rtl2830_dev *dev = i2c_get_clientdata(client);
-	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
 	int ret;
 	u8 buf[3];
 

commit 4fd57ed61564bd4706e71cfd8c5a259079ddabf3
Author: Ernst Martin Witte <emw-linux-kernel@nocabal.de>
Date:   Sat Jan 9 18:18:47 2016 -0200

    [media] rtl2830: cancel_delayed_work_sync before device removal / kfree
    
    rtl2830_remove  was  calling  kfree(dev) with  possibly  still  active
    schedule_delayed_work(&dev->stat_work).   A  similar   bug  in  si2157
    caused kernel panics in call_timer_fn e.g. after rmmod cx23885.
    
    Signed-off-by: Ernst Martin Witte <emw-linux-kernel@nocabal.de>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/rtl2830.c b/drivers/media/dvb-frontends/rtl2830.c
index b792f305cf15..74b771218033 100644
--- a/drivers/media/dvb-frontends/rtl2830.c
+++ b/drivers/media/dvb-frontends/rtl2830.c
@@ -900,6 +900,9 @@ static int rtl2830_remove(struct i2c_client *client)
 
 	dev_dbg(&client->dev, "\n");
 
+	/* stop statistics polling */
+	cancel_delayed_work_sync(&dev->stat_work);
+
 	i2c_del_mux_adapter(dev->adapter);
 	regmap_exit(dev->regmap);
 	kfree(dev);

commit 04d8be053fbeac656f8db2acb768179be9997b0a
Author: Krzysztof Kozlowski <k.kozlowski@samsung.com>
Date:   Fri Jul 10 03:19:42 2015 -0300

    [media] dvb-frontends: Drop owner assignment from i2c_driver
    
    i2c_driver does not need to set an owner because i2c_register_driver()
    will set it.
    
    Signed-off-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/rtl2830.c b/drivers/media/dvb-frontends/rtl2830.c
index 3d01f4f22aca..b792f305cf15 100644
--- a/drivers/media/dvb-frontends/rtl2830.c
+++ b/drivers/media/dvb-frontends/rtl2830.c
@@ -915,7 +915,6 @@ MODULE_DEVICE_TABLE(i2c, rtl2830_id_table);
 
 static struct i2c_driver rtl2830_driver = {
 	.driver = {
-		.owner	= THIS_MODULE,
 		.name	= "rtl2830",
 	},
 	.probe		= rtl2830_probe,

commit 0df289a209e02f0926042ab07d7d2595ea2d2e9b
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Sun Jun 7 14:53:52 2015 -0300

    [media] dvb: Get rid of typedev usage for enums
    
    The DVB API was originally defined using typedefs. This is against
    Kernel CodingStyle, and there's no good usage here. While we can't
    remove its usage on userspace, we can avoid its usage in Kernelspace.
    
    So, let's do it.
    
    This patch was generated by this shell script:
    
            for j in $(grep typedef include/uapi/linux/dvb/frontend.h |cut -d' ' -f 3); do for i in $(find drivers/media -name '*.[ch]' -type f) $(find drivers/staging/media -name '*.[ch]' -type f); do sed "s,${j}_t,enum $j," <$i >a && mv a $i; done; done
    
    While here, make CodingStyle fixes on the affected lines.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
    Acked-by: Stefan Richter <stefanr@s5r6.in-berlin.de> # for drivers/media/firewire/*

diff --git a/drivers/media/dvb-frontends/rtl2830.c b/drivers/media/dvb-frontends/rtl2830.c
index e1b8df62bd59..3d01f4f22aca 100644
--- a/drivers/media/dvb-frontends/rtl2830.c
+++ b/drivers/media/dvb-frontends/rtl2830.c
@@ -392,7 +392,7 @@ static int rtl2830_get_frontend(struct dvb_frontend *fe)
 	return ret;
 }
 
-static int rtl2830_read_status(struct dvb_frontend *fe, fe_status_t *status)
+static int rtl2830_read_status(struct dvb_frontend *fe, enum fe_status *status)
 {
 	struct i2c_client *client = fe->demodulator_priv;
 	struct rtl2830_dev *dev = i2c_get_clientdata(client);

commit d858b0e787a8eef66457bcbbd9a758a327102b94
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Tue Feb 3 16:32:34 2015 -0200

    [media] rtl2830: declare functions as static
    
    drivers/media/dvb-frontends/rtl2830.c:21:5: warning: no previous prototype for ‘rtl2830_bulk_write’ [-Wmissing-prototypes]
     int rtl2830_bulk_write(struct i2c_client *client, unsigned int reg,
         ^
    drivers/media/dvb-frontends/rtl2830.c:33:5: warning: no previous prototype for ‘rtl2830_update_bits’ [-Wmissing-prototypes]
     int rtl2830_update_bits(struct i2c_client *client, unsigned int reg,
         ^
    drivers/media/dvb-frontends/rtl2830.c:45:5: warning: no previous prototype for ‘rtl2830_bulk_read’ [-Wmissing-prototypes]
     int rtl2830_bulk_read(struct i2c_client *client, unsigned int reg, void *val,
         ^
    
    Cc: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/rtl2830.c b/drivers/media/dvb-frontends/rtl2830.c
index a90f155daadf..e1b8df62bd59 100644
--- a/drivers/media/dvb-frontends/rtl2830.c
+++ b/drivers/media/dvb-frontends/rtl2830.c
@@ -18,8 +18,8 @@
 #include "rtl2830_priv.h"
 
 /* Our regmap is bypassing I2C adapter lock, thus we do it! */
-int rtl2830_bulk_write(struct i2c_client *client, unsigned int reg,
-		       const void *val, size_t val_count)
+static int rtl2830_bulk_write(struct i2c_client *client, unsigned int reg,
+			      const void *val, size_t val_count)
 {
 	struct rtl2830_dev *dev = i2c_get_clientdata(client);
 	int ret;
@@ -30,8 +30,8 @@ int rtl2830_bulk_write(struct i2c_client *client, unsigned int reg,
 	return ret;
 }
 
-int rtl2830_update_bits(struct i2c_client *client, unsigned int reg,
-			unsigned int mask, unsigned int val)
+static int rtl2830_update_bits(struct i2c_client *client, unsigned int reg,
+			       unsigned int mask, unsigned int val)
 {
 	struct rtl2830_dev *dev = i2c_get_clientdata(client);
 	int ret;
@@ -42,8 +42,8 @@ int rtl2830_update_bits(struct i2c_client *client, unsigned int reg,
 	return ret;
 }
 
-int rtl2830_bulk_read(struct i2c_client *client, unsigned int reg, void *val,
-		      size_t val_count)
+static int rtl2830_bulk_read(struct i2c_client *client, unsigned int reg,
+			     void *val, size_t val_count)
 {
 	struct rtl2830_dev *dev = i2c_get_clientdata(client);
 	int ret;

commit 15d37f382469b1f35a9fb97f839eb3122ef7bc98
Author: Antti Palosaari <crope@iki.fi>
Date:   Fri Dec 12 01:03:51 2014 -0300

    [media] rtl2830: convert to regmap API
    
    Use regmap to cover register access routines.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/rtl2830.c b/drivers/media/dvb-frontends/rtl2830.c
index 3a9e4e986fc2..a90f155daadf 100644
--- a/drivers/media/dvb-frontends/rtl2830.c
+++ b/drivers/media/dvb-frontends/rtl2830.c
@@ -17,176 +17,43 @@
 
 #include "rtl2830_priv.h"
 
-/* Max transfer size done by I2C transfer functions */
-#define MAX_XFER_SIZE  64
-
-/* write multiple hardware registers */
-static int rtl2830_wr(struct i2c_client *client, u8 reg, const u8 *val, int len)
+/* Our regmap is bypassing I2C adapter lock, thus we do it! */
+int rtl2830_bulk_write(struct i2c_client *client, unsigned int reg,
+		       const void *val, size_t val_count)
 {
+	struct rtl2830_dev *dev = i2c_get_clientdata(client);
 	int ret;
-	u8 buf[MAX_XFER_SIZE];
-	struct i2c_msg msg[1] = {
-		{
-			.addr = client->addr,
-			.flags = 0,
-			.len = 1 + len,
-			.buf = buf,
-		}
-	};
-
-	if (1 + len > sizeof(buf)) {
-		dev_warn(&client->dev, "i2c wr reg=%04x: len=%d is too big!\n",
-			 reg, len);
-		return -EINVAL;
-	}
-
-	buf[0] = reg;
-	memcpy(&buf[1], val, len);
-
-	ret = __i2c_transfer(client->adapter, msg, 1);
-	if (ret == 1) {
-		ret = 0;
-	} else {
-		dev_warn(&client->dev, "i2c wr failed=%d reg=%02x len=%d\n",
-			 ret, reg, len);
-		ret = -EREMOTEIO;
-	}
 
+	i2c_lock_adapter(client->adapter);
+	ret = regmap_bulk_write(dev->regmap, reg, val, val_count);
+	i2c_unlock_adapter(client->adapter);
 	return ret;
 }
 
-/* read multiple hardware registers */
-static int rtl2830_rd(struct i2c_client *client, u8 reg, u8 *val, int len)
-{
-	int ret;
-	struct i2c_msg msg[2] = {
-		{
-			.addr = client->addr,
-			.flags = 0,
-			.len = 1,
-			.buf = &reg,
-		}, {
-			.addr = client->addr,
-			.flags = I2C_M_RD,
-			.len = len,
-			.buf = val,
-		}
-	};
-
-	ret = __i2c_transfer(client->adapter, msg, 2);
-	if (ret == 2) {
-		ret = 0;
-	} else {
-		dev_warn(&client->dev, "i2c rd failed=%d reg=%02x len=%d\n",
-			 ret, reg, len);
-		ret = -EREMOTEIO;
-	}
-
-	return ret;
-}
-
-/* write multiple registers */
-static int rtl2830_wr_regs(struct i2c_client *client, u16 reg, const u8 *val, int len)
+int rtl2830_update_bits(struct i2c_client *client, unsigned int reg,
+			unsigned int mask, unsigned int val)
 {
 	struct rtl2830_dev *dev = i2c_get_clientdata(client);
 	int ret;
-	u8 reg2 = (reg >> 0) & 0xff;
-	u8 page = (reg >> 8) & 0xff;
-
-	mutex_lock(&dev->i2c_mutex);
-
-	/* switch bank if needed */
-	if (page != dev->page) {
-		ret = rtl2830_wr(client, 0x00, &page, 1);
-		if (ret)
-			goto err_mutex_unlock;
-
-		dev->page = page;
-	}
-
-	ret = rtl2830_wr(client, reg2, val, len);
-
-err_mutex_unlock:
-	mutex_unlock(&dev->i2c_mutex);
 
+	i2c_lock_adapter(client->adapter);
+	ret = regmap_update_bits(dev->regmap, reg, mask, val);
+	i2c_unlock_adapter(client->adapter);
 	return ret;
 }
 
-/* read multiple registers */
-static int rtl2830_rd_regs(struct i2c_client *client, u16 reg, u8 *val, int len)
+int rtl2830_bulk_read(struct i2c_client *client, unsigned int reg, void *val,
+		      size_t val_count)
 {
 	struct rtl2830_dev *dev = i2c_get_clientdata(client);
 	int ret;
-	u8 reg2 = (reg >> 0) & 0xff;
-	u8 page = (reg >> 8) & 0xff;
-
-	mutex_lock(&dev->i2c_mutex);
-
-	/* switch bank if needed */
-	if (page != dev->page) {
-		ret = rtl2830_wr(client, 0x00, &page, 1);
-		if (ret)
-			goto err_mutex_unlock;
-
-		dev->page = page;
-	}
-
-	ret = rtl2830_rd(client, reg2, val, len);
-
-err_mutex_unlock:
-	mutex_unlock(&dev->i2c_mutex);
 
+	i2c_lock_adapter(client->adapter);
+	ret = regmap_bulk_read(dev->regmap, reg, val, val_count);
+	i2c_unlock_adapter(client->adapter);
 	return ret;
 }
 
-/* read single register */
-static int rtl2830_rd_reg(struct i2c_client *client, u16 reg, u8 *val)
-{
-	return rtl2830_rd_regs(client, reg, val, 1);
-}
-
-/* write single register with mask */
-static int rtl2830_wr_reg_mask(struct i2c_client *client, u16 reg, u8 val, u8 mask)
-{
-	int ret;
-	u8 tmp;
-
-	/* no need for read if whole reg is written */
-	if (mask != 0xff) {
-		ret = rtl2830_rd_regs(client, reg, &tmp, 1);
-		if (ret)
-			return ret;
-
-		val &= mask;
-		tmp &= ~mask;
-		val |= tmp;
-	}
-
-	return rtl2830_wr_regs(client, reg, &val, 1);
-}
-
-/* read single register with mask */
-static int rtl2830_rd_reg_mask(struct i2c_client *client, u16 reg, u8 *val, u8 mask)
-{
-	int ret, i;
-	u8 tmp;
-
-	ret = rtl2830_rd_regs(client, reg, &tmp, 1);
-	if (ret)
-		return ret;
-
-	tmp &= mask;
-
-	/* find position of the first bit */
-	for (i = 0; i < 8; i++) {
-		if ((mask >> i) & 0x01)
-			break;
-	}
-	*val = tmp >> i;
-
-	return 0;
-}
-
 static int rtl2830_init(struct dvb_frontend *fe)
 {
 	struct i2c_client *client = fe->demodulator_priv;
@@ -233,29 +100,29 @@ static int rtl2830_init(struct dvb_frontend *fe)
 	};
 
 	for (i = 0; i < ARRAY_SIZE(tab); i++) {
-		ret = rtl2830_wr_reg_mask(client, tab[i].reg, tab[i].val,
-					  tab[i].mask);
+		ret = rtl2830_update_bits(client, tab[i].reg, tab[i].mask,
+					  tab[i].val);
 		if (ret)
 			goto err;
 	}
 
-	ret = rtl2830_wr_regs(client, 0x18f, "\x28\x00", 2);
+	ret = rtl2830_bulk_write(client, 0x18f, "\x28\x00", 2);
 	if (ret)
 		goto err;
 
-	ret = rtl2830_wr_regs(client, 0x195,
-			      "\x04\x06\x0a\x12\x0a\x12\x1e\x28", 8);
+	ret = rtl2830_bulk_write(client, 0x195,
+				 "\x04\x06\x0a\x12\x0a\x12\x1e\x28", 8);
 	if (ret)
 		goto err;
 
 	/* TODO: spec init */
 
 	/* soft reset */
-	ret = rtl2830_wr_reg_mask(client, 0x101, 0x04, 0x04);
+	ret = rtl2830_update_bits(client, 0x101, 0x04, 0x04);
 	if (ret)
 		goto err;
 
-	ret = rtl2830_wr_reg_mask(client, 0x101, 0x00, 0x04);
+	ret = rtl2830_update_bits(client, 0x101, 0x04, 0x00);
 	if (ret)
 		goto err;
 
@@ -309,7 +176,7 @@ static int rtl2830_set_frontend(struct dvb_frontend *fe)
 	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
 	int ret, i;
 	u64 num;
-	u8 buf[3], tmp;
+	u8 buf[3], u8tmp;
 	u32 if_ctl, if_frequency;
 	static const u8 bw_params1[3][34] = {
 		{
@@ -358,7 +225,7 @@ static int rtl2830_set_frontend(struct dvb_frontend *fe)
 		return -EINVAL;
 	}
 
-	ret = rtl2830_wr_reg_mask(client, 0x008, i << 1, 0x06);
+	ret = rtl2830_update_bits(client, 0x008, 0x06, i << 1);
 	if (ret)
 		goto err;
 
@@ -378,30 +245,31 @@ static int rtl2830_set_frontend(struct dvb_frontend *fe)
 	dev_dbg(&client->dev, "if_frequency=%d if_ctl=%08x\n",
 		if_frequency, if_ctl);
 
-	ret = rtl2830_rd_reg_mask(client, 0x119, &tmp, 0xc0); /* b[7:6] */
+	buf[0] = (if_ctl >> 16) & 0x3f;
+	buf[1] = (if_ctl >>  8) & 0xff;
+	buf[2] = (if_ctl >>  0) & 0xff;
+
+	ret = rtl2830_bulk_read(client, 0x119, &u8tmp, 1);
 	if (ret)
 		goto err;
 
-	buf[0] = tmp << 6;
-	buf[0] |= (if_ctl >> 16) & 0x3f;
-	buf[1] = (if_ctl >>  8) & 0xff;
-	buf[2] = (if_ctl >>  0) & 0xff;
+	buf[0] |= u8tmp & 0xc0;  /* [7:6] */
 
-	ret = rtl2830_wr_regs(client, 0x119, buf, 3);
+	ret = rtl2830_bulk_write(client, 0x119, buf, 3);
 	if (ret)
 		goto err;
 
 	/* 1/2 split I2C write */
-	ret = rtl2830_wr_regs(client, 0x11c, &bw_params1[i][0], 17);
+	ret = rtl2830_bulk_write(client, 0x11c, &bw_params1[i][0], 17);
 	if (ret)
 		goto err;
 
 	/* 2/2 split I2C write */
-	ret = rtl2830_wr_regs(client, 0x12d, &bw_params1[i][17], 17);
+	ret = rtl2830_bulk_write(client, 0x12d, &bw_params1[i][17], 17);
 	if (ret)
 		goto err;
 
-	ret = rtl2830_wr_regs(client, 0x19d, bw_params2[i], 6);
+	ret = rtl2830_bulk_write(client, 0x19d, bw_params2[i], 6);
 	if (ret)
 		goto err;
 
@@ -422,11 +290,11 @@ static int rtl2830_get_frontend(struct dvb_frontend *fe)
 	if (dev->sleeping)
 		return 0;
 
-	ret = rtl2830_rd_regs(client, 0x33c, buf, 2);
+	ret = rtl2830_bulk_read(client, 0x33c, buf, 2);
 	if (ret)
 		goto err;
 
-	ret = rtl2830_rd_reg(client, 0x351, &buf[2]);
+	ret = rtl2830_bulk_read(client, 0x351, &buf[2], 1);
 	if (ret)
 		goto err;
 
@@ -529,21 +397,22 @@ static int rtl2830_read_status(struct dvb_frontend *fe, fe_status_t *status)
 	struct i2c_client *client = fe->demodulator_priv;
 	struct rtl2830_dev *dev = i2c_get_clientdata(client);
 	int ret;
-	u8 tmp;
+	u8 u8tmp;
 
 	*status = 0;
 
 	if (dev->sleeping)
 		return 0;
 
-	ret = rtl2830_rd_reg_mask(client, 0x351, &tmp, 0x78); /* [6:3] */
+	ret = rtl2830_bulk_read(client, 0x351, &u8tmp, 1);
 	if (ret)
 		goto err;
 
-	if (tmp == 11) {
+	u8tmp = (u8tmp >> 3) & 0x0f; /* [6:3] */
+	if (u8tmp == 11) {
 		*status |= FE_HAS_SIGNAL | FE_HAS_CARRIER |
 			FE_HAS_VITERBI | FE_HAS_SYNC | FE_HAS_LOCK;
-	} else if (tmp == 10) {
+	} else if (u8tmp == 10) {
 		*status |= FE_HAS_SIGNAL | FE_HAS_CARRIER |
 			FE_HAS_VITERBI;
 	}
@@ -650,7 +519,7 @@ static void rtl2830_stat_work(struct work_struct *work)
 		struct {signed int x:14; } s;
 
 		/* read IF AGC */
-		ret = rtl2830_rd_regs(client, 0x359, buf, 2);
+		ret = rtl2830_bulk_read(client, 0x359, buf, 2);
 		if (ret)
 			goto err;
 
@@ -678,7 +547,7 @@ static void rtl2830_stat_work(struct work_struct *work)
 			{92888734, 92888734, 95487525, 99770748},
 		};
 
-		ret = rtl2830_rd_reg(client, 0x33c, &u8tmp);
+		ret = rtl2830_bulk_read(client, 0x33c, &u8tmp, 1);
 		if (ret)
 			goto err;
 
@@ -690,7 +559,7 @@ static void rtl2830_stat_work(struct work_struct *work)
 		if (hierarchy > HIERARCHY_NUM - 1)
 			goto err_schedule_delayed_work;
 
-		ret = rtl2830_rd_regs(client, 0x40c, buf, 2);
+		ret = rtl2830_bulk_read(client, 0x40c, buf, 2);
 		if (ret)
 			goto err;
 
@@ -711,7 +580,7 @@ static void rtl2830_stat_work(struct work_struct *work)
 
 	/* BER */
 	if (dev->fe_status & FE_HAS_LOCK) {
-		ret = rtl2830_rd_regs(client, 0x34e, buf, 2);
+		ret = rtl2830_bulk_read(client, 0x34e, buf, 2);
 		if (ret)
 			goto err;
 
@@ -751,7 +620,7 @@ static int rtl2830_pid_filter_ctrl(struct dvb_frontend *fe, int onoff)
 	else
 		u8tmp = 0x00;
 
-	ret = rtl2830_wr_reg_mask(client, 0x061, u8tmp, 0x80);
+	ret = rtl2830_update_bits(client, 0x061, 0x80, u8tmp);
 	if (ret)
 		goto err;
 
@@ -785,14 +654,14 @@ static int rtl2830_pid_filter(struct dvb_frontend *fe, u8 index, u16 pid, int on
 	buf[1] = (dev->filters >>  8) & 0xff;
 	buf[2] = (dev->filters >> 16) & 0xff;
 	buf[3] = (dev->filters >> 24) & 0xff;
-	ret = rtl2830_wr_regs(client, 0x062, buf, 4);
+	ret = rtl2830_bulk_write(client, 0x062, buf, 4);
 	if (ret)
 		goto err;
 
 	/* add PID */
 	buf[0] = (pid >> 8) & 0xff;
 	buf[1] = (pid >> 0) & 0xff;
-	ret = rtl2830_wr_regs(client, 0x066 + 2 * index, buf, 2);
+	ret = rtl2830_bulk_write(client, 0x066 + 2 * index, buf, 2);
 	if (ret)
 		goto err;
 
@@ -803,55 +672,24 @@ static int rtl2830_pid_filter(struct dvb_frontend *fe, u8 index, u16 pid, int on
 }
 
 /*
- * I2C gate/repeater logic
- * We must use unlocked i2c_transfer() here because I2C lock is already taken
- * by tuner driver. Gate is closed automatically after single I2C xfer.
+ * I2C gate/mux/repeater logic
+ * We must use unlocked __i2c_transfer() here (through regmap) because of I2C
+ * adapter lock is already taken by tuner driver.
+ * Gate is closed automatically after single I2C transfer.
  */
 static int rtl2830_select(struct i2c_adapter *adap, void *mux_priv, u32 chan_id)
 {
 	struct i2c_client *client = mux_priv;
 	struct rtl2830_dev *dev = i2c_get_clientdata(client);
-	struct i2c_msg select_reg_page_msg[1] = {
-		{
-			.addr = client->addr,
-			.flags = 0,
-			.len = 2,
-			.buf = "\x00\x01",
-		}
-	};
-	struct i2c_msg gate_open_msg[1] = {
-		{
-			.addr = client->addr,
-			.flags = 0,
-			.len = 2,
-			.buf = "\x01\x08",
-		}
-	};
 	int ret;
 
 	dev_dbg(&client->dev, "\n");
 
-	mutex_lock(&dev->i2c_mutex);
-
-	/* select register page */
-	ret = __i2c_transfer(client->adapter, select_reg_page_msg, 1);
-	if (ret != 1) {
-		dev_warn(&client->dev, "i2c write failed %d\n", ret);
-		if (ret >= 0)
-			ret = -EREMOTEIO;
+	/* open I2C repeater for 1 transfer, closes automatically */
+	/* XXX: regmap_update_bits() does not lock I2C adapter */
+	ret = regmap_update_bits(dev->regmap, 0x101, 0x08, 0x08);
+	if (ret)
 		goto err;
-	}
-
-	dev->page = 1;
-
-	/* open tuner I2C repeater for 1 xfer, closes automatically */
-	ret = __i2c_transfer(client->adapter, gate_open_msg, 1);
-	if (ret != 1) {
-		dev_warn(&client->dev, "i2c write failed %d\n", ret);
-		if (ret >= 0)
-			ret = -EREMOTEIO;
-		goto err;
-	}
 
 	return 0;
 err:
@@ -859,34 +697,107 @@ static int rtl2830_select(struct i2c_adapter *adap, void *mux_priv, u32 chan_id)
 	return ret;
 }
 
-static int rtl2830_deselect(struct i2c_adapter *adap, void *mux_priv, u32 chan)
+static struct dvb_frontend *rtl2830_get_dvb_frontend(struct i2c_client *client)
 {
-	struct i2c_client *client = mux_priv;
 	struct rtl2830_dev *dev = i2c_get_clientdata(client);
 
 	dev_dbg(&client->dev, "\n");
 
-	mutex_unlock(&dev->i2c_mutex);
-
-	return 0;
+	return &dev->fe;
 }
 
-static struct dvb_frontend *rtl2830_get_dvb_frontend(struct i2c_client *client)
+static struct i2c_adapter *rtl2830_get_i2c_adapter(struct i2c_client *client)
 {
 	struct rtl2830_dev *dev = i2c_get_clientdata(client);
 
 	dev_dbg(&client->dev, "\n");
 
-	return &dev->fe;
+	return dev->adapter;
 }
 
-static struct i2c_adapter *rtl2830_get_i2c_adapter(struct i2c_client *client)
+/*
+ * We implement own I2C access routines for regmap in order to get manual access
+ * to I2C adapter lock, which is needed for I2C mux adapter.
+ */
+static int rtl2830_regmap_read(void *context, const void *reg_buf,
+			       size_t reg_size, void *val_buf, size_t val_size)
 {
-	struct rtl2830_dev *dev = i2c_get_clientdata(client);
+	struct i2c_client *client = context;
+	int ret;
+	struct i2c_msg msg[2] = {
+		{
+			.addr = client->addr,
+			.flags = 0,
+			.len = reg_size,
+			.buf = (u8 *)reg_buf,
+		}, {
+			.addr = client->addr,
+			.flags = I2C_M_RD,
+			.len = val_size,
+			.buf = val_buf,
+		}
+	};
 
-	dev_dbg(&client->dev, "\n");
+	ret = __i2c_transfer(client->adapter, msg, 2);
+	if (ret != 2) {
+		dev_warn(&client->dev, "i2c reg read failed %d\n", ret);
+		if (ret >= 0)
+			ret = -EREMOTEIO;
+		return ret;
+	}
+	return 0;
+}
 
-	return dev->adapter;
+static int rtl2830_regmap_write(void *context, const void *data, size_t count)
+{
+	struct i2c_client *client = context;
+	int ret;
+	struct i2c_msg msg[1] = {
+		{
+			.addr = client->addr,
+			.flags = 0,
+			.len = count,
+			.buf = (u8 *)data,
+		}
+	};
+
+	ret = __i2c_transfer(client->adapter, msg, 1);
+	if (ret != 1) {
+		dev_warn(&client->dev, "i2c reg write failed %d\n", ret);
+		if (ret >= 0)
+			ret = -EREMOTEIO;
+		return ret;
+	}
+	return 0;
+}
+
+static int rtl2830_regmap_gather_write(void *context, const void *reg,
+				       size_t reg_len, const void *val,
+				       size_t val_len)
+{
+	struct i2c_client *client = context;
+	int ret;
+	u8 buf[256];
+	struct i2c_msg msg[1] = {
+		{
+			.addr = client->addr,
+			.flags = 0,
+			.len = 1 + val_len,
+			.buf = buf,
+		}
+	};
+
+	buf[0] = *(u8 const *)reg;
+	memcpy(&buf[1], val, val_len);
+
+	ret = __i2c_transfer(client->adapter, msg, 1);
+	if (ret != 1) {
+		dev_warn(&client->dev, "i2c reg write failed %d\n", ret);
+		if (ret >= 0)
+			ret = -EREMOTEIO;
+		return ret;
+	}
+	return 0;
 }
 
 static int rtl2830_probe(struct i2c_client *client,
@@ -896,6 +807,30 @@ static int rtl2830_probe(struct i2c_client *client,
 	struct rtl2830_dev *dev;
 	int ret;
 	u8 u8tmp;
+	static const struct regmap_bus regmap_bus = {
+		.read = rtl2830_regmap_read,
+		.write = rtl2830_regmap_write,
+		.gather_write = rtl2830_regmap_gather_write,
+		.val_format_endian_default = REGMAP_ENDIAN_NATIVE,
+	};
+	static const struct regmap_range_cfg regmap_range_cfg[] = {
+		{
+			.selector_reg     = 0x00,
+			.selector_mask    = 0xff,
+			.selector_shift   = 0,
+			.window_start     = 0,
+			.window_len       = 0x100,
+			.range_min        = 0 * 0x100,
+			.range_max        = 5 * 0x100,
+		},
+	};
+	static const struct regmap_config regmap_config = {
+		.reg_bits    =  8,
+		.val_bits    =  8,
+		.max_register = 5 * 0x100,
+		.ranges = regmap_range_cfg,
+		.num_ranges = ARRAY_SIZE(regmap_range_cfg),
+	};
 
 	dev_dbg(&client->dev, "\n");
 
@@ -916,20 +851,25 @@ static int rtl2830_probe(struct i2c_client *client,
 	dev->client = client;
 	dev->pdata = client->dev.platform_data;
 	dev->sleeping = true;
-	mutex_init(&dev->i2c_mutex);
 	INIT_DELAYED_WORK(&dev->stat_work, rtl2830_stat_work);
+	dev->regmap = regmap_init(&client->dev, &regmap_bus, client,
+				  &regmap_config);
+	if (IS_ERR(dev->regmap)) {
+		ret = PTR_ERR(dev->regmap);
+		goto err_kfree;
+	}
 
 	/* check if the demod is there */
-	ret = rtl2830_rd_reg(client, 0x000, &u8tmp);
+	ret = rtl2830_bulk_read(client, 0x000, &u8tmp, 1);
 	if (ret)
-		goto err_kfree;
+		goto err_regmap_exit;
 
 	/* create muxed i2c adapter for tuner */
 	dev->adapter = i2c_add_mux_adapter(client->adapter, &client->dev,
-			client, 0, 0, 0, rtl2830_select, rtl2830_deselect);
+			client, 0, 0, 0, rtl2830_select, NULL);
 	if (dev->adapter == NULL) {
 		ret = -ENODEV;
-		goto err_kfree;
+		goto err_regmap_exit;
 	}
 
 	/* create dvb frontend */
@@ -945,6 +885,8 @@ static int rtl2830_probe(struct i2c_client *client,
 	dev_info(&client->dev, "Realtek RTL2830 successfully attached\n");
 
 	return 0;
+err_regmap_exit:
+	regmap_exit(dev->regmap);
 err_kfree:
 	kfree(dev);
 err:
@@ -959,6 +901,7 @@ static int rtl2830_remove(struct i2c_client *client)
 	dev_dbg(&client->dev, "\n");
 
 	i2c_del_mux_adapter(dev->adapter);
+	regmap_exit(dev->regmap);
 	kfree(dev);
 
 	return 0;

commit fd4cfa8bb1bc0cdd385f33303b5058674ea8e24c
Author: Antti Palosaari <crope@iki.fi>
Date:   Tue Dec 9 16:14:41 2014 -0300

    [media] rtl2830: implement own I2C locking
    
    Own I2C locking is needed due to two special reasons:
    1) Chips uses multiple register pages/banks on single I2C slave.
    Page is changed via I2C register access.
    2) Chip offers muxed/gated I2C adapter for tuner. Gate/mux is
    controlled by I2C register access.
    
    Due to these reasons, I2C locking did not fit very well.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/rtl2830.c b/drivers/media/dvb-frontends/rtl2830.c
index 8abaca66e132..3a9e4e986fc2 100644
--- a/drivers/media/dvb-frontends/rtl2830.c
+++ b/drivers/media/dvb-frontends/rtl2830.c
@@ -43,7 +43,7 @@ static int rtl2830_wr(struct i2c_client *client, u8 reg, const u8 *val, int len)
 	buf[0] = reg;
 	memcpy(&buf[1], val, len);
 
-	ret = i2c_transfer(client->adapter, msg, 1);
+	ret = __i2c_transfer(client->adapter, msg, 1);
 	if (ret == 1) {
 		ret = 0;
 	} else {
@@ -73,7 +73,7 @@ static int rtl2830_rd(struct i2c_client *client, u8 reg, u8 *val, int len)
 		}
 	};
 
-	ret = i2c_transfer(client->adapter, msg, 2);
+	ret = __i2c_transfer(client->adapter, msg, 2);
 	if (ret == 2) {
 		ret = 0;
 	} else {
@@ -93,16 +93,23 @@ static int rtl2830_wr_regs(struct i2c_client *client, u16 reg, const u8 *val, in
 	u8 reg2 = (reg >> 0) & 0xff;
 	u8 page = (reg >> 8) & 0xff;
 
+	mutex_lock(&dev->i2c_mutex);
+
 	/* switch bank if needed */
 	if (page != dev->page) {
 		ret = rtl2830_wr(client, 0x00, &page, 1);
 		if (ret)
-			return ret;
+			goto err_mutex_unlock;
 
 		dev->page = page;
 	}
 
-	return rtl2830_wr(client, reg2, val, len);
+	ret = rtl2830_wr(client, reg2, val, len);
+
+err_mutex_unlock:
+	mutex_unlock(&dev->i2c_mutex);
+
+	return ret;
 }
 
 /* read multiple registers */
@@ -113,16 +120,23 @@ static int rtl2830_rd_regs(struct i2c_client *client, u16 reg, u8 *val, int len)
 	u8 reg2 = (reg >> 0) & 0xff;
 	u8 page = (reg >> 8) & 0xff;
 
+	mutex_lock(&dev->i2c_mutex);
+
 	/* switch bank if needed */
 	if (page != dev->page) {
 		ret = rtl2830_wr(client, 0x00, &page, 1);
 		if (ret)
-			return ret;
+			goto err_mutex_unlock;
 
 		dev->page = page;
 	}
 
-	return rtl2830_rd(client, reg2, val, len);
+	ret = rtl2830_rd(client, reg2, val, len);
+
+err_mutex_unlock:
+	mutex_unlock(&dev->i2c_mutex);
+
+	return ret;
 }
 
 /* read single register */
@@ -815,6 +829,10 @@ static int rtl2830_select(struct i2c_adapter *adap, void *mux_priv, u32 chan_id)
 	};
 	int ret;
 
+	dev_dbg(&client->dev, "\n");
+
+	mutex_lock(&dev->i2c_mutex);
+
 	/* select register page */
 	ret = __i2c_transfer(client->adapter, select_reg_page_msg, 1);
 	if (ret != 1) {
@@ -841,6 +859,18 @@ static int rtl2830_select(struct i2c_adapter *adap, void *mux_priv, u32 chan_id)
 	return ret;
 }
 
+static int rtl2830_deselect(struct i2c_adapter *adap, void *mux_priv, u32 chan)
+{
+	struct i2c_client *client = mux_priv;
+	struct rtl2830_dev *dev = i2c_get_clientdata(client);
+
+	dev_dbg(&client->dev, "\n");
+
+	mutex_unlock(&dev->i2c_mutex);
+
+	return 0;
+}
+
 static struct dvb_frontend *rtl2830_get_dvb_frontend(struct i2c_client *client)
 {
 	struct rtl2830_dev *dev = i2c_get_clientdata(client);
@@ -886,6 +916,7 @@ static int rtl2830_probe(struct i2c_client *client,
 	dev->client = client;
 	dev->pdata = client->dev.platform_data;
 	dev->sleeping = true;
+	mutex_init(&dev->i2c_mutex);
 	INIT_DELAYED_WORK(&dev->stat_work, rtl2830_stat_work);
 
 	/* check if the demod is there */
@@ -895,7 +926,7 @@ static int rtl2830_probe(struct i2c_client *client,
 
 	/* create muxed i2c adapter for tuner */
 	dev->adapter = i2c_add_mux_adapter(client->adapter, &client->dev,
-			client, 0, 0, 0, rtl2830_select, NULL);
+			client, 0, 0, 0, rtl2830_select, rtl2830_deselect);
 	if (dev->adapter == NULL) {
 		ret = -ENODEV;
 		goto err_kfree;

commit df70ddad81b47c57bcccffc805fbd75f2f1b2dc6
Author: Antti Palosaari <crope@iki.fi>
Date:   Tue Dec 9 16:08:44 2014 -0300

    [media] rtl2830: implement PID filter
    
    Implement PID filter.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/rtl2830.c b/drivers/media/dvb-frontends/rtl2830.c
index f1f1cfb6cb16..8abaca66e132 100644
--- a/drivers/media/dvb-frontends/rtl2830.c
+++ b/drivers/media/dvb-frontends/rtl2830.c
@@ -723,6 +723,71 @@ static void rtl2830_stat_work(struct work_struct *work)
 	dev_dbg(&client->dev, "failed=%d\n", ret);
 }
 
+static int rtl2830_pid_filter_ctrl(struct dvb_frontend *fe, int onoff)
+{
+	struct i2c_client *client = fe->demodulator_priv;
+	int ret;
+	u8 u8tmp;
+
+	dev_dbg(&client->dev, "onoff=%d\n", onoff);
+
+	/* enable / disable PID filter */
+	if (onoff)
+		u8tmp = 0x80;
+	else
+		u8tmp = 0x00;
+
+	ret = rtl2830_wr_reg_mask(client, 0x061, u8tmp, 0x80);
+	if (ret)
+		goto err;
+
+	return 0;
+err:
+	dev_dbg(&client->dev, "failed=%d\n", ret);
+	return ret;
+}
+
+static int rtl2830_pid_filter(struct dvb_frontend *fe, u8 index, u16 pid, int onoff)
+{
+	struct i2c_client *client = fe->demodulator_priv;
+	struct rtl2830_dev *dev = i2c_get_clientdata(client);
+	int ret;
+	u8 buf[4];
+
+	dev_dbg(&client->dev, "index=%d pid=%04x onoff=%d\n",
+		index, pid, onoff);
+
+	/* skip invalid PIDs (0x2000) */
+	if (pid > 0x1fff || index > 32)
+		return 0;
+
+	if (onoff)
+		set_bit(index, &dev->filters);
+	else
+		clear_bit(index, &dev->filters);
+
+	/* enable / disable PIDs */
+	buf[0] = (dev->filters >>  0) & 0xff;
+	buf[1] = (dev->filters >>  8) & 0xff;
+	buf[2] = (dev->filters >> 16) & 0xff;
+	buf[3] = (dev->filters >> 24) & 0xff;
+	ret = rtl2830_wr_regs(client, 0x062, buf, 4);
+	if (ret)
+		goto err;
+
+	/* add PID */
+	buf[0] = (pid >> 8) & 0xff;
+	buf[1] = (pid >> 0) & 0xff;
+	ret = rtl2830_wr_regs(client, 0x066 + 2 * index, buf, 2);
+	if (ret)
+		goto err;
+
+	return 0;
+err:
+	dev_dbg(&client->dev, "failed=%d\n", ret);
+	return ret;
+}
+
 /*
  * I2C gate/repeater logic
  * We must use unlocked i2c_transfer() here because I2C lock is already taken
@@ -843,6 +908,8 @@ static int rtl2830_probe(struct i2c_client *client,
 	/* setup callbacks */
 	pdata->get_dvb_frontend = rtl2830_get_dvb_frontend;
 	pdata->get_i2c_adapter = rtl2830_get_i2c_adapter;
+	pdata->pid_filter = rtl2830_pid_filter;
+	pdata->pid_filter_ctrl = rtl2830_pid_filter_ctrl;
 
 	dev_info(&client->dev, "Realtek RTL2830 successfully attached\n");
 

commit 6dcfe3cc2e33ecd04987828ccbf56d6eda9a833f
Author: Antti Palosaari <crope@iki.fi>
Date:   Tue Dec 9 10:48:10 2014 -0300

    [media] rtl2830: wrap DVBv5 CNR to DVBv3 SNR
    
    Change legacy DVBv3 read SNR to return values calculated by DVBv5
    statistics.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/rtl2830.c b/drivers/media/dvb-frontends/rtl2830.c
index 0112b3f13a4b..f1f1cfb6cb16 100644
--- a/drivers/media/dvb-frontends/rtl2830.c
+++ b/drivers/media/dvb-frontends/rtl2830.c
@@ -544,52 +544,14 @@ static int rtl2830_read_status(struct dvb_frontend *fe, fe_status_t *status)
 
 static int rtl2830_read_snr(struct dvb_frontend *fe, u16 *snr)
 {
-	struct i2c_client *client = fe->demodulator_priv;
-	struct rtl2830_dev *dev = i2c_get_clientdata(client);
-	int ret, hierarchy, constellation;
-	u8 buf[2], tmp;
-	u16 tmp16;
-#define CONSTELLATION_NUM 3
-#define HIERARCHY_NUM 4
-	static const u32 snr_constant[CONSTELLATION_NUM][HIERARCHY_NUM] = {
-		{70705899, 70705899, 70705899, 70705899},
-		{82433173, 82433173, 87483115, 94445660},
-		{92888734, 92888734, 95487525, 99770748},
-	};
-
-	if (dev->sleeping)
-		return 0;
-
-	/* reports SNR in resolution of 0.1 dB */
-
-	ret = rtl2830_rd_reg(client, 0x33c, &tmp);
-	if (ret)
-		goto err;
-
-	constellation = (tmp >> 2) & 0x03; /* [3:2] */
-	if (constellation > CONSTELLATION_NUM - 1)
-		goto err;
-
-	hierarchy = (tmp >> 4) & 0x07; /* [6:4] */
-	if (hierarchy > HIERARCHY_NUM - 1)
-		goto err;
-
-	ret = rtl2830_rd_regs(client, 0x40c, buf, 2);
-	if (ret)
-		goto err;
-
-	tmp16 = buf[0] << 8 | buf[1];
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
 
-	if (tmp16)
-		*snr = (snr_constant[constellation][hierarchy] -
-				intlog10(tmp16)) / ((1 << 24) / 100);
+	if (c->cnr.stat[0].scale == FE_SCALE_DECIBEL)
+		*snr = div_s64(c->cnr.stat[0].svalue, 100);
 	else
 		*snr = 0;
 
 	return 0;
-err:
-	dev_dbg(&client->dev, "failed=%d\n", ret);
-	return ret;
 }
 
 static int rtl2830_read_ber(struct dvb_frontend *fe, u32 *ber)

commit f491391cc331921524aed578075e93f622a5e533
Author: Antti Palosaari <crope@iki.fi>
Date:   Tue Dec 9 10:27:32 2014 -0300

    [media] rtl2830: wrap DVBv5 BER to DVBv3
    
    Change legacy DVBv3 read BER to return values calculated by DVBv5
    statistics.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/rtl2830.c b/drivers/media/dvb-frontends/rtl2830.c
index a02ccdf2fda0..0112b3f13a4b 100644
--- a/drivers/media/dvb-frontends/rtl2830.c
+++ b/drivers/media/dvb-frontends/rtl2830.c
@@ -596,22 +596,11 @@ static int rtl2830_read_ber(struct dvb_frontend *fe, u32 *ber)
 {
 	struct i2c_client *client = fe->demodulator_priv;
 	struct rtl2830_dev *dev = i2c_get_clientdata(client);
-	int ret;
-	u8 buf[2];
-
-	if (dev->sleeping)
-		return 0;
-
-	ret = rtl2830_rd_regs(client, 0x34e, buf, 2);
-	if (ret)
-		goto err;
 
-	*ber = buf[0] << 8 | buf[1];
+	*ber = (dev->post_bit_error - dev->post_bit_error_prev);
+	dev->post_bit_error_prev = dev->post_bit_error;
 
 	return 0;
-err:
-	dev_dbg(&client->dev, "failed=%d\n", ret);
-	return ret;
 }
 
 static int rtl2830_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)

commit d512e286512c38e8921317c3a2c772559a91a636
Author: Antti Palosaari <crope@iki.fi>
Date:   Tue Dec 9 10:20:01 2014 -0300

    [media] rtl2830: wrap DVBv5 signal strength to DVBv3
    
    Change legacy DVBv3 signal strength to return values calculated by
    DVBv5 statistics.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/rtl2830.c b/drivers/media/dvb-frontends/rtl2830.c
index 147b3a6898e1..a02ccdf2fda0 100644
--- a/drivers/media/dvb-frontends/rtl2830.c
+++ b/drivers/media/dvb-frontends/rtl2830.c
@@ -623,33 +623,14 @@ static int rtl2830_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)
 
 static int rtl2830_read_signal_strength(struct dvb_frontend *fe, u16 *strength)
 {
-	struct i2c_client *client = fe->demodulator_priv;
-	struct rtl2830_dev *dev = i2c_get_clientdata(client);
-	int ret;
-	u8 buf[2];
-	u16 if_agc_raw, if_agc;
-
-	if (dev->sleeping)
-		return 0;
-
-	ret = rtl2830_rd_regs(client, 0x359, buf, 2);
-	if (ret)
-		goto err;
-
-	if_agc_raw = (buf[0] << 8 | buf[1]) & 0x3fff;
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
 
-	if (if_agc_raw & (1 << 9))
-		if_agc = -(~(if_agc_raw - 1) & 0x1ff);
+	if (c->strength.stat[0].scale == FE_SCALE_RELATIVE)
+		*strength = c->strength.stat[0].uvalue;
 	else
-		if_agc = if_agc_raw;
-
-	*strength = (u8)(55 - if_agc / 182);
-	*strength |= *strength << 8;
+		*strength = 0;
 
 	return 0;
-err:
-	dev_dbg(&client->dev, "failed=%d\n", ret);
-	return ret;
 }
 
 static struct dvb_frontend_ops rtl2830_ops = {

commit 5bb11ca5864a2d4a91b0aa972bae7011314fdffc
Author: Antti Palosaari <crope@iki.fi>
Date:   Tue Dec 9 09:45:16 2014 -0300

    [media] rtl2830: implement DVBv5 BER statistic
    
    DVBv5 BER.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/rtl2830.c b/drivers/media/dvb-frontends/rtl2830.c
index 641047b89e05..147b3a6898e1 100644
--- a/drivers/media/dvb-frontends/rtl2830.c
+++ b/drivers/media/dvb-frontends/rtl2830.c
@@ -250,6 +250,10 @@ static int rtl2830_init(struct dvb_frontend *fe)
 	c->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
 	c->cnr.len = 1;
 	c->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	c->post_bit_error.len = 1;
+	c->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	c->post_bit_count.len = 1;
+	c->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
 	/* start statistics polling */
 	schedule_delayed_work(&dev->stat_work, msecs_to_jiffies(2000));
 
@@ -759,6 +763,27 @@ static void rtl2830_stat_work(struct work_struct *work)
 		c->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
 	}
 
+	/* BER */
+	if (dev->fe_status & FE_HAS_LOCK) {
+		ret = rtl2830_rd_regs(client, 0x34e, buf, 2);
+		if (ret)
+			goto err;
+
+		u16tmp = buf[0] << 8 | buf[1] << 0;
+		dev->post_bit_error += u16tmp;
+		dev->post_bit_count += 1000000;
+
+		dev_dbg(&client->dev, "BER errors=%u total=1000000\n", u16tmp);
+
+		c->post_bit_error.stat[0].scale = FE_SCALE_COUNTER;
+		c->post_bit_error.stat[0].uvalue = dev->post_bit_error;
+		c->post_bit_count.stat[0].scale = FE_SCALE_COUNTER;
+		c->post_bit_count.stat[0].uvalue = dev->post_bit_count;
+	} else {
+		c->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+		c->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	}
+
 err_schedule_delayed_work:
 	schedule_delayed_work(&dev->stat_work, msecs_to_jiffies(2000));
 	return;

commit 871f70252b6fef738cda1834200d25e343ce4825
Author: Antti Palosaari <crope@iki.fi>
Date:   Tue Dec 9 08:49:44 2014 -0300

    [media] rtl2830: implement DVBv5 signal strength statistics
    
    Estimate signal strength from IF AGC.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/rtl2830.c b/drivers/media/dvb-frontends/rtl2830.c
index c484634a9fc9..641047b89e05 100644
--- a/drivers/media/dvb-frontends/rtl2830.c
+++ b/drivers/media/dvb-frontends/rtl2830.c
@@ -246,6 +246,8 @@ static int rtl2830_init(struct dvb_frontend *fe)
 		goto err;
 
 	/* init stats here in order signal app which stats are supported */
+	c->strength.len = 1;
+	c->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
 	c->cnr.len = 1;
 	c->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
 	/* start statistics polling */
@@ -693,6 +695,28 @@ static void rtl2830_stat_work(struct work_struct *work)
 
 	dev_dbg(&client->dev, "\n");
 
+	/* signal strength */
+	if (dev->fe_status & FE_HAS_SIGNAL) {
+		struct {signed int x:14; } s;
+
+		/* read IF AGC */
+		ret = rtl2830_rd_regs(client, 0x359, buf, 2);
+		if (ret)
+			goto err;
+
+		u16tmp = buf[0] << 8 | buf[1] << 0;
+		u16tmp &= 0x3fff; /* [13:0] */
+		tmp = s.x = u16tmp; /* 14-bit bin to 2 complement */
+		u16tmp = clamp_val(-4 * tmp + 32767, 0x0000, 0xffff);
+
+		dev_dbg(&client->dev, "IF AGC=%d\n", tmp);
+
+		c->strength.stat[0].scale = FE_SCALE_RELATIVE;
+		c->strength.stat[0].uvalue = u16tmp;
+	} else {
+		c->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	}
+
 	/* CNR */
 	if (dev->fe_status & FE_HAS_VITERBI) {
 		unsigned hierarchy, constellation;

commit 47b4dbfff1f31686ac74aae7c69dec23b36005d9
Author: Antti Palosaari <crope@iki.fi>
Date:   Tue Dec 9 06:14:36 2014 -0300

    [media] rtl2830: implement DVBv5 CNR statistic
    
    DVBv5 CNR.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/rtl2830.c b/drivers/media/dvb-frontends/rtl2830.c
index 8025b19ac36d..c484634a9fc9 100644
--- a/drivers/media/dvb-frontends/rtl2830.c
+++ b/drivers/media/dvb-frontends/rtl2830.c
@@ -177,6 +177,7 @@ static int rtl2830_init(struct dvb_frontend *fe)
 {
 	struct i2c_client *client = fe->demodulator_priv;
 	struct rtl2830_dev *dev = i2c_get_clientdata(client);
+	struct dtv_frontend_properties *c = &dev->fe.dtv_property_cache;
 	int ret, i;
 	struct rtl2830_reg_val_mask tab[] = {
 		{0x00d, 0x01, 0x03},
@@ -244,6 +245,12 @@ static int rtl2830_init(struct dvb_frontend *fe)
 	if (ret)
 		goto err;
 
+	/* init stats here in order signal app which stats are supported */
+	c->cnr.len = 1;
+	c->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	/* start statistics polling */
+	schedule_delayed_work(&dev->stat_work, msecs_to_jiffies(2000));
+
 	dev->sleeping = false;
 
 	return ret;
@@ -258,6 +265,9 @@ static int rtl2830_sleep(struct dvb_frontend *fe)
 	struct rtl2830_dev *dev = i2c_get_clientdata(client);
 
 	dev->sleeping = true;
+	/* stop statistics polling */
+	cancel_delayed_work_sync(&dev->stat_work);
+	dev->fe_status = 0;
 
 	return 0;
 }
@@ -518,6 +528,8 @@ static int rtl2830_read_status(struct dvb_frontend *fe, fe_status_t *status)
 			FE_HAS_VITERBI;
 	}
 
+	dev->fe_status = *status;
+
 	return ret;
 err:
 	dev_dbg(&client->dev, "failed=%d\n", ret);
@@ -670,6 +682,66 @@ static struct dvb_frontend_ops rtl2830_ops = {
 	.read_signal_strength = rtl2830_read_signal_strength,
 };
 
+static void rtl2830_stat_work(struct work_struct *work)
+{
+	struct rtl2830_dev *dev = container_of(work, struct rtl2830_dev, stat_work.work);
+	struct i2c_client *client = dev->client;
+	struct dtv_frontend_properties *c = &dev->fe.dtv_property_cache;
+	int ret, tmp;
+	u8 u8tmp, buf[2];
+	u16 u16tmp;
+
+	dev_dbg(&client->dev, "\n");
+
+	/* CNR */
+	if (dev->fe_status & FE_HAS_VITERBI) {
+		unsigned hierarchy, constellation;
+		#define CONSTELLATION_NUM 3
+		#define HIERARCHY_NUM 4
+		static const u32 constant[CONSTELLATION_NUM][HIERARCHY_NUM] = {
+			{70705899, 70705899, 70705899, 70705899},
+			{82433173, 82433173, 87483115, 94445660},
+			{92888734, 92888734, 95487525, 99770748},
+		};
+
+		ret = rtl2830_rd_reg(client, 0x33c, &u8tmp);
+		if (ret)
+			goto err;
+
+		constellation = (u8tmp >> 2) & 0x03; /* [3:2] */
+		if (constellation > CONSTELLATION_NUM - 1)
+			goto err_schedule_delayed_work;
+
+		hierarchy = (u8tmp >> 4) & 0x07; /* [6:4] */
+		if (hierarchy > HIERARCHY_NUM - 1)
+			goto err_schedule_delayed_work;
+
+		ret = rtl2830_rd_regs(client, 0x40c, buf, 2);
+		if (ret)
+			goto err;
+
+		u16tmp = buf[0] << 8 | buf[1] << 0;
+		if (u16tmp)
+			tmp = (constant[constellation][hierarchy] -
+			       intlog10(u16tmp)) / ((1 << 24) / 10000);
+		else
+			tmp = 0;
+
+		dev_dbg(&client->dev, "CNR raw=%u\n", u16tmp);
+
+		c->cnr.stat[0].scale = FE_SCALE_DECIBEL;
+		c->cnr.stat[0].svalue = tmp;
+	} else {
+		c->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	}
+
+err_schedule_delayed_work:
+	schedule_delayed_work(&dev->stat_work, msecs_to_jiffies(2000));
+	return;
+err:
+	dev_dbg(&client->dev, "failed=%d\n", ret);
+}
+
 /*
  * I2C gate/repeater logic
  * We must use unlocked i2c_transfer() here because I2C lock is already taken
@@ -765,8 +837,10 @@ static int rtl2830_probe(struct i2c_client *client,
 
 	/* setup the state */
 	i2c_set_clientdata(client, dev);
+	dev->client = client;
 	dev->pdata = client->dev.platform_data;
 	dev->sleeping = true;
+	INIT_DELAYED_WORK(&dev->stat_work, rtl2830_stat_work);
 
 	/* check if the demod is there */
 	ret = rtl2830_rd_reg(client, 0x000, &u8tmp);

commit 947debb4f2e8aba1d1678b7b5d4753258a0b1513
Author: Antti Palosaari <crope@iki.fi>
Date:   Tue Dec 9 02:31:53 2014 -0300

    [media] rtl2830: style related changes
    
    Trivial changes proposed by checkpatch.pl and some more.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/rtl2830.c b/drivers/media/dvb-frontends/rtl2830.c
index ea68c7ef2a71..8025b19ac36d 100644
--- a/drivers/media/dvb-frontends/rtl2830.c
+++ b/drivers/media/dvb-frontends/rtl2830.c
@@ -13,16 +13,6 @@
  *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *    GNU General Public License for more details.
  *
- *    You should have received a copy of the GNU General Public License along
- *    with this program; if not, write to the Free Software Foundation, Inc.,
- *    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- */
-
-
-/*
- * Driver implements own I2C-adapter for tuner I2C access. That's since chip
- * have unusual I2C-gate control which closes gate automatically after each
- * I2C transfer. Using own I2C adapter we can workaround that.
  */
 
 #include "rtl2830_priv.h"
@@ -46,7 +36,7 @@ static int rtl2830_wr(struct i2c_client *client, u8 reg, const u8 *val, int len)
 
 	if (1 + len > sizeof(buf)) {
 		dev_warn(&client->dev, "i2c wr reg=%04x: len=%d is too big!\n",
-				reg, len);
+			 reg, len);
 		return -EINVAL;
 	}
 
@@ -58,9 +48,10 @@ static int rtl2830_wr(struct i2c_client *client, u8 reg, const u8 *val, int len)
 		ret = 0;
 	} else {
 		dev_warn(&client->dev, "i2c wr failed=%d reg=%02x len=%d\n",
-				ret, reg, len);
+			 ret, reg, len);
 		ret = -EREMOTEIO;
 	}
+
 	return ret;
 }
 
@@ -87,9 +78,10 @@ static int rtl2830_rd(struct i2c_client *client, u8 reg, u8 *val, int len)
 		ret = 0;
 	} else {
 		dev_warn(&client->dev, "i2c rd failed=%d reg=%02x len=%d\n",
-				ret, reg, len);
+			 ret, reg, len);
 		ret = -EREMOTEIO;
 	}
+
 	return ret;
 }
 
@@ -187,47 +179,47 @@ static int rtl2830_init(struct dvb_frontend *fe)
 	struct rtl2830_dev *dev = i2c_get_clientdata(client);
 	int ret, i;
 	struct rtl2830_reg_val_mask tab[] = {
-		{ 0x00d, 0x01, 0x03 },
-		{ 0x00d, 0x10, 0x10 },
-		{ 0x104, 0x00, 0x1e },
-		{ 0x105, 0x80, 0x80 },
-		{ 0x110, 0x02, 0x03 },
-		{ 0x110, 0x08, 0x0c },
-		{ 0x17b, 0x00, 0x40 },
-		{ 0x17d, 0x05, 0x0f },
-		{ 0x17d, 0x50, 0xf0 },
-		{ 0x18c, 0x08, 0x0f },
-		{ 0x18d, 0x00, 0xc0 },
-		{ 0x188, 0x05, 0x0f },
-		{ 0x189, 0x00, 0xfc },
-		{ 0x2d5, 0x02, 0x02 },
-		{ 0x2f1, 0x02, 0x06 },
-		{ 0x2f1, 0x20, 0xf8 },
-		{ 0x16d, 0x00, 0x01 },
-		{ 0x1a6, 0x00, 0x80 },
-		{ 0x106, dev->pdata->vtop, 0x3f },
-		{ 0x107, dev->pdata->krf, 0x3f },
-		{ 0x112, 0x28, 0xff },
-		{ 0x103, dev->pdata->agc_targ_val, 0xff },
-		{ 0x00a, 0x02, 0x07 },
-		{ 0x140, 0x0c, 0x3c },
-		{ 0x140, 0x40, 0xc0 },
-		{ 0x15b, 0x05, 0x07 },
-		{ 0x15b, 0x28, 0x38 },
-		{ 0x15c, 0x05, 0x07 },
-		{ 0x15c, 0x28, 0x38 },
-		{ 0x115, dev->pdata->spec_inv, 0x01 },
-		{ 0x16f, 0x01, 0x07 },
-		{ 0x170, 0x18, 0x38 },
-		{ 0x172, 0x0f, 0x0f },
-		{ 0x173, 0x08, 0x38 },
-		{ 0x175, 0x01, 0x07 },
-		{ 0x176, 0x00, 0xc0 },
+		{0x00d, 0x01, 0x03},
+		{0x00d, 0x10, 0x10},
+		{0x104, 0x00, 0x1e},
+		{0x105, 0x80, 0x80},
+		{0x110, 0x02, 0x03},
+		{0x110, 0x08, 0x0c},
+		{0x17b, 0x00, 0x40},
+		{0x17d, 0x05, 0x0f},
+		{0x17d, 0x50, 0xf0},
+		{0x18c, 0x08, 0x0f},
+		{0x18d, 0x00, 0xc0},
+		{0x188, 0x05, 0x0f},
+		{0x189, 0x00, 0xfc},
+		{0x2d5, 0x02, 0x02},
+		{0x2f1, 0x02, 0x06},
+		{0x2f1, 0x20, 0xf8},
+		{0x16d, 0x00, 0x01},
+		{0x1a6, 0x00, 0x80},
+		{0x106, dev->pdata->vtop, 0x3f},
+		{0x107, dev->pdata->krf, 0x3f},
+		{0x112, 0x28, 0xff},
+		{0x103, dev->pdata->agc_targ_val, 0xff},
+		{0x00a, 0x02, 0x07},
+		{0x140, 0x0c, 0x3c},
+		{0x140, 0x40, 0xc0},
+		{0x15b, 0x05, 0x07},
+		{0x15b, 0x28, 0x38},
+		{0x15c, 0x05, 0x07},
+		{0x15c, 0x28, 0x38},
+		{0x115, dev->pdata->spec_inv, 0x01},
+		{0x16f, 0x01, 0x07},
+		{0x170, 0x18, 0x38},
+		{0x172, 0x0f, 0x0f},
+		{0x173, 0x08, 0x38},
+		{0x175, 0x01, 0x07},
+		{0x176, 0x00, 0xc0},
 	};
 
 	for (i = 0; i < ARRAY_SIZE(tab); i++) {
 		ret = rtl2830_wr_reg_mask(client, tab[i].reg, tab[i].val,
-			tab[i].mask);
+					  tab[i].mask);
 		if (ret)
 			goto err;
 	}
@@ -237,7 +229,7 @@ static int rtl2830_init(struct dvb_frontend *fe)
 		goto err;
 
 	ret = rtl2830_wr_regs(client, 0x195,
-		"\x04\x06\x0a\x12\x0a\x12\x1e\x28", 8);
+			      "\x04\x06\x0a\x12\x0a\x12\x1e\x28", 8);
 	if (ret)
 		goto err;
 
@@ -264,12 +256,14 @@ static int rtl2830_sleep(struct dvb_frontend *fe)
 {
 	struct i2c_client *client = fe->demodulator_priv;
 	struct rtl2830_dev *dev = i2c_get_clientdata(client);
+
 	dev->sleeping = true;
+
 	return 0;
 }
 
 static int rtl2830_get_tune_settings(struct dvb_frontend *fe,
-	struct dvb_frontend_tune_settings *s)
+				     struct dvb_frontend_tune_settings *s)
 {
 	s->min_delay_ms = 500;
 	s->step_size = fe->ops.info.frequency_stepsize * 2;
@@ -312,7 +306,7 @@ static int rtl2830_set_frontend(struct dvb_frontend *fe)
 	};
 
 	dev_dbg(&client->dev, "frequency=%u bandwidth_hz=%u inversion=%u\n",
-			c->frequency, c->bandwidth_hz, c->inversion);
+		c->frequency, c->bandwidth_hz, c->inversion);
 
 	/* program tuner */
 	if (fe->ops.tuner_ops.set_params)
@@ -330,7 +324,7 @@ static int rtl2830_set_frontend(struct dvb_frontend *fe)
 		break;
 	default:
 		dev_err(&client->dev, "invalid bandwidth_hz %u\n",
-				c->bandwidth_hz);
+			c->bandwidth_hz);
 		return -EINVAL;
 	}
 
@@ -343,8 +337,7 @@ static int rtl2830_set_frontend(struct dvb_frontend *fe)
 		ret = fe->ops.tuner_ops.get_if_frequency(fe, &if_frequency);
 	else
 		ret = -EINVAL;
-
-	if (ret < 0)
+	if (ret)
 		goto err;
 
 	num = if_frequency % dev->pdata->clk;
@@ -353,7 +346,7 @@ static int rtl2830_set_frontend(struct dvb_frontend *fe)
 	num = -num;
 	if_ctl = num & 0x3fffff;
 	dev_dbg(&client->dev, "if_frequency=%d if_ctl=%08x\n",
-			if_frequency, if_ctl);
+		if_frequency, if_ctl);
 
 	ret = rtl2830_rd_reg_mask(client, 0x119, &tmp, 0xc0); /* b[7:6] */
 	if (ret)
@@ -507,6 +500,7 @@ static int rtl2830_read_status(struct dvb_frontend *fe, fe_status_t *status)
 	struct rtl2830_dev *dev = i2c_get_clientdata(client);
 	int ret;
 	u8 tmp;
+
 	*status = 0;
 
 	if (dev->sleeping)
@@ -540,9 +534,9 @@ static int rtl2830_read_snr(struct dvb_frontend *fe, u16 *snr)
 #define CONSTELLATION_NUM 3
 #define HIERARCHY_NUM 4
 	static const u32 snr_constant[CONSTELLATION_NUM][HIERARCHY_NUM] = {
-		{ 70705899, 70705899, 70705899, 70705899 },
-		{ 82433173, 82433173, 87483115, 94445660 },
-		{ 92888734, 92888734, 95487525, 99770748 },
+		{70705899, 70705899, 70705899, 70705899},
+		{82433173, 82433173, 87483115, 94445660},
+		{92888734, 92888734, 95487525, 99770748},
 	};
 
 	if (dev->sleeping)
@@ -605,6 +599,7 @@ static int rtl2830_read_ber(struct dvb_frontend *fe, u32 *ber)
 static int rtl2830_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)
 {
 	*ucblocks = 0;
+
 	return 0;
 }
 
@@ -630,7 +625,7 @@ static int rtl2830_read_signal_strength(struct dvb_frontend *fe, u16 *strength)
 	else
 		if_agc = if_agc_raw;
 
-	*strength = (u8) (55 - if_agc / 182);
+	*strength = (u8)(55 - if_agc / 182);
 	*strength |= *strength << 8;
 
 	return 0;
@@ -640,7 +635,7 @@ static int rtl2830_read_signal_strength(struct dvb_frontend *fe, u16 *strength)
 }
 
 static struct dvb_frontend_ops rtl2830_ops = {
-	.delsys = { SYS_DVBT },
+	.delsys = {SYS_DVBT},
 	.info = {
 		.name = "Realtek RTL2830 (DVB-T)",
 		.caps = FE_CAN_FEC_1_2 |
@@ -723,7 +718,6 @@ static int rtl2830_select(struct i2c_adapter *adap, void *mux_priv, u32 chan_id)
 	}
 
 	return 0;
-
 err:
 	dev_dbg(&client->dev, "failed=%d\n", ret);
 	return ret;
@@ -748,7 +742,7 @@ static struct i2c_adapter *rtl2830_get_i2c_adapter(struct i2c_client *client)
 }
 
 static int rtl2830_probe(struct i2c_client *client,
-		const struct i2c_device_id *id)
+			 const struct i2c_device_id *id)
 {
 	struct rtl2830_platform_data *pdata = client->dev.platform_data;
 	struct rtl2830_dev *dev;
@@ -796,8 +790,8 @@ static int rtl2830_probe(struct i2c_client *client,
 	pdata->get_i2c_adapter = rtl2830_get_i2c_adapter;
 
 	dev_info(&client->dev, "Realtek RTL2830 successfully attached\n");
-	return 0;
 
+	return 0;
 err_kfree:
 	kfree(dev);
 err:
@@ -813,6 +807,7 @@ static int rtl2830_remove(struct i2c_client *client)
 
 	i2c_del_mux_adapter(dev->adapter);
 	kfree(dev);
+
 	return 0;
 }
 

commit b8cb50d237ff1590e2b39031e5d7d3e1bcd49c5b
Author: Antti Palosaari <crope@iki.fi>
Date:   Tue Dec 9 00:24:13 2014 -0300

    [media] rtl2830: get rid of internal config data
    
    Remove internal config and use configuration values directly from
    the platform data.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/rtl2830.c b/drivers/media/dvb-frontends/rtl2830.c
index fa73575a6692..ea68c7ef2a71 100644
--- a/drivers/media/dvb-frontends/rtl2830.c
+++ b/drivers/media/dvb-frontends/rtl2830.c
@@ -33,12 +33,11 @@
 /* write multiple hardware registers */
 static int rtl2830_wr(struct i2c_client *client, u8 reg, const u8 *val, int len)
 {
-	struct rtl2830_dev *dev = i2c_get_clientdata(client);
 	int ret;
 	u8 buf[MAX_XFER_SIZE];
 	struct i2c_msg msg[1] = {
 		{
-			.addr = dev->cfg.i2c_addr,
+			.addr = client->addr,
 			.flags = 0,
 			.len = 1 + len,
 			.buf = buf,
@@ -54,7 +53,7 @@ static int rtl2830_wr(struct i2c_client *client, u8 reg, const u8 *val, int len)
 	buf[0] = reg;
 	memcpy(&buf[1], val, len);
 
-	ret = i2c_transfer(dev->i2c, msg, 1);
+	ret = i2c_transfer(client->adapter, msg, 1);
 	if (ret == 1) {
 		ret = 0;
 	} else {
@@ -68,23 +67,22 @@ static int rtl2830_wr(struct i2c_client *client, u8 reg, const u8 *val, int len)
 /* read multiple hardware registers */
 static int rtl2830_rd(struct i2c_client *client, u8 reg, u8 *val, int len)
 {
-	struct rtl2830_dev *dev = i2c_get_clientdata(client);
 	int ret;
 	struct i2c_msg msg[2] = {
 		{
-			.addr = dev->cfg.i2c_addr,
+			.addr = client->addr,
 			.flags = 0,
 			.len = 1,
 			.buf = &reg,
 		}, {
-			.addr = dev->cfg.i2c_addr,
+			.addr = client->addr,
 			.flags = I2C_M_RD,
 			.len = len,
 			.buf = val,
 		}
 	};
 
-	ret = i2c_transfer(dev->i2c, msg, 2);
+	ret = i2c_transfer(client->adapter, msg, 2);
 	if (ret == 2) {
 		ret = 0;
 	} else {
@@ -207,10 +205,10 @@ static int rtl2830_init(struct dvb_frontend *fe)
 		{ 0x2f1, 0x20, 0xf8 },
 		{ 0x16d, 0x00, 0x01 },
 		{ 0x1a6, 0x00, 0x80 },
-		{ 0x106, dev->cfg.vtop, 0x3f },
-		{ 0x107, dev->cfg.krf, 0x3f },
+		{ 0x106, dev->pdata->vtop, 0x3f },
+		{ 0x107, dev->pdata->krf, 0x3f },
 		{ 0x112, 0x28, 0xff },
-		{ 0x103, dev->cfg.agc_targ_val, 0xff },
+		{ 0x103, dev->pdata->agc_targ_val, 0xff },
 		{ 0x00a, 0x02, 0x07 },
 		{ 0x140, 0x0c, 0x3c },
 		{ 0x140, 0x40, 0xc0 },
@@ -218,7 +216,7 @@ static int rtl2830_init(struct dvb_frontend *fe)
 		{ 0x15b, 0x28, 0x38 },
 		{ 0x15c, 0x05, 0x07 },
 		{ 0x15c, 0x28, 0x38 },
-		{ 0x115, dev->cfg.spec_inv, 0x01 },
+		{ 0x115, dev->pdata->spec_inv, 0x01 },
 		{ 0x16f, 0x01, 0x07 },
 		{ 0x170, 0x18, 0x38 },
 		{ 0x172, 0x0f, 0x0f },
@@ -349,9 +347,9 @@ static int rtl2830_set_frontend(struct dvb_frontend *fe)
 	if (ret < 0)
 		goto err;
 
-	num = if_frequency % dev->cfg.xtal;
+	num = if_frequency % dev->pdata->clk;
 	num *= 0x400000;
-	num = div_u64(num, dev->cfg.xtal);
+	num = div_u64(num, dev->pdata->clk);
 	num = -num;
 	if_ctl = num & 0x3fffff;
 	dev_dbg(&client->dev, "if_frequency=%d if_ctl=%08x\n",
@@ -506,7 +504,7 @@ static int rtl2830_get_frontend(struct dvb_frontend *fe)
 static int rtl2830_read_status(struct dvb_frontend *fe, fe_status_t *status)
 {
 	struct i2c_client *client = fe->demodulator_priv;
-	struct rtl2830_dev *dev = fe->demodulator_priv;
+	struct rtl2830_dev *dev = i2c_get_clientdata(client);
 	int ret;
 	u8 tmp;
 	*status = 0;
@@ -688,7 +686,7 @@ static int rtl2830_select(struct i2c_adapter *adap, void *mux_priv, u32 chan_id)
 	struct rtl2830_dev *dev = i2c_get_clientdata(client);
 	struct i2c_msg select_reg_page_msg[1] = {
 		{
-			.addr = dev->cfg.i2c_addr,
+			.addr = client->addr,
 			.flags = 0,
 			.len = 2,
 			.buf = "\x00\x01",
@@ -696,7 +694,7 @@ static int rtl2830_select(struct i2c_adapter *adap, void *mux_priv, u32 chan_id)
 	};
 	struct i2c_msg gate_open_msg[1] = {
 		{
-			.addr = dev->cfg.i2c_addr,
+			.addr = client->addr,
 			.flags = 0,
 			.len = 2,
 			.buf = "\x01\x08",
@@ -705,7 +703,7 @@ static int rtl2830_select(struct i2c_adapter *adap, void *mux_priv, u32 chan_id)
 	int ret;
 
 	/* select register page */
-	ret = __i2c_transfer(adap, select_reg_page_msg, 1);
+	ret = __i2c_transfer(client->adapter, select_reg_page_msg, 1);
 	if (ret != 1) {
 		dev_warn(&client->dev, "i2c write failed %d\n", ret);
 		if (ret >= 0)
@@ -716,7 +714,7 @@ static int rtl2830_select(struct i2c_adapter *adap, void *mux_priv, u32 chan_id)
 	dev->page = 1;
 
 	/* open tuner I2C repeater for 1 xfer, closes automatically */
-	ret = __i2c_transfer(adap, gate_open_msg, 1);
+	ret = __i2c_transfer(client->adapter, gate_open_msg, 1);
 	if (ret != 1) {
 		dev_warn(&client->dev, "i2c write failed %d\n", ret);
 		if (ret >= 0)
@@ -753,7 +751,6 @@ static int rtl2830_probe(struct i2c_client *client,
 		const struct i2c_device_id *id)
 {
 	struct rtl2830_platform_data *pdata = client->dev.platform_data;
-	struct i2c_adapter *i2c = client->adapter;
 	struct rtl2830_dev *dev;
 	int ret;
 	u8 u8tmp;
@@ -774,14 +771,8 @@ static int rtl2830_probe(struct i2c_client *client,
 
 	/* setup the state */
 	i2c_set_clientdata(client, dev);
-	dev->i2c = i2c;
+	dev->pdata = client->dev.platform_data;
 	dev->sleeping = true;
-	dev->cfg.i2c_addr = client->addr;
-	dev->cfg.xtal = pdata->clk;
-	dev->cfg.spec_inv = pdata->spec_inv;
-	dev->cfg.vtop = pdata->vtop;
-	dev->cfg.krf = pdata->krf;
-	dev->cfg.agc_targ_val = pdata->agc_targ_val;
 
 	/* check if the demod is there */
 	ret = rtl2830_rd_reg(client, 0x000, &u8tmp);

commit 7cc39328898151e92eb4ff052150737558bf7887
Author: Antti Palosaari <crope@iki.fi>
Date:   Mon Dec 8 23:32:19 2014 -0300

    [media] rtl2830: fix logging
    
    Pass correct device for dev_foo() logging in order to print logs
    correctly.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/rtl2830.c b/drivers/media/dvb-frontends/rtl2830.c
index e7ba6658ac8f..fa73575a6692 100644
--- a/drivers/media/dvb-frontends/rtl2830.c
+++ b/drivers/media/dvb-frontends/rtl2830.c
@@ -46,9 +46,8 @@ static int rtl2830_wr(struct i2c_client *client, u8 reg, const u8 *val, int len)
 	};
 
 	if (1 + len > sizeof(buf)) {
-		dev_warn(&dev->i2c->dev,
-			 "%s: i2c wr reg=%04x: len=%d is too big!\n",
-			 KBUILD_MODNAME, reg, len);
+		dev_warn(&client->dev, "i2c wr reg=%04x: len=%d is too big!\n",
+				reg, len);
 		return -EINVAL;
 	}
 
@@ -59,8 +58,8 @@ static int rtl2830_wr(struct i2c_client *client, u8 reg, const u8 *val, int len)
 	if (ret == 1) {
 		ret = 0;
 	} else {
-		dev_warn(&dev->i2c->dev, "%s: i2c wr failed=%d reg=%02x " \
-				"len=%d\n", KBUILD_MODNAME, ret, reg, len);
+		dev_warn(&client->dev, "i2c wr failed=%d reg=%02x len=%d\n",
+				ret, reg, len);
 		ret = -EREMOTEIO;
 	}
 	return ret;
@@ -89,8 +88,8 @@ static int rtl2830_rd(struct i2c_client *client, u8 reg, u8 *val, int len)
 	if (ret == 2) {
 		ret = 0;
 	} else {
-		dev_warn(&dev->i2c->dev, "%s: i2c rd failed=%d reg=%02x " \
-				"len=%d\n", KBUILD_MODNAME, ret, reg, len);
+		dev_warn(&client->dev, "i2c rd failed=%d reg=%02x len=%d\n",
+				ret, reg, len);
 		ret = -EREMOTEIO;
 	}
 	return ret;
@@ -259,7 +258,7 @@ static int rtl2830_init(struct dvb_frontend *fe)
 
 	return ret;
 err:
-	dev_dbg(&dev->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	dev_dbg(&client->dev, "failed=%d\n", ret);
 	return ret;
 }
 
@@ -314,9 +313,8 @@ static int rtl2830_set_frontend(struct dvb_frontend *fe)
 		{0xae, 0xba, 0xf3, 0x26, 0x66, 0x64}, /* 8 MHz */
 	};
 
-	dev_dbg(&dev->i2c->dev,
-			"%s: frequency=%d bandwidth_hz=%d inversion=%d\n",
-			__func__, c->frequency, c->bandwidth_hz, c->inversion);
+	dev_dbg(&client->dev, "frequency=%u bandwidth_hz=%u inversion=%u\n",
+			c->frequency, c->bandwidth_hz, c->inversion);
 
 	/* program tuner */
 	if (fe->ops.tuner_ops.set_params)
@@ -333,7 +331,8 @@ static int rtl2830_set_frontend(struct dvb_frontend *fe)
 		i = 2;
 		break;
 	default:
-		dev_dbg(&dev->i2c->dev, "%s: invalid bandwidth\n", __func__);
+		dev_err(&client->dev, "invalid bandwidth_hz %u\n",
+				c->bandwidth_hz);
 		return -EINVAL;
 	}
 
@@ -355,8 +354,8 @@ static int rtl2830_set_frontend(struct dvb_frontend *fe)
 	num = div_u64(num, dev->cfg.xtal);
 	num = -num;
 	if_ctl = num & 0x3fffff;
-	dev_dbg(&dev->i2c->dev, "%s: if_frequency=%d if_ctl=%08x\n",
-			__func__, if_frequency, if_ctl);
+	dev_dbg(&client->dev, "if_frequency=%d if_ctl=%08x\n",
+			if_frequency, if_ctl);
 
 	ret = rtl2830_rd_reg_mask(client, 0x119, &tmp, 0xc0); /* b[7:6] */
 	if (ret)
@@ -387,7 +386,7 @@ static int rtl2830_set_frontend(struct dvb_frontend *fe)
 
 	return ret;
 err:
-	dev_dbg(&dev->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	dev_dbg(&client->dev, "failed=%d\n", ret);
 	return ret;
 }
 
@@ -410,7 +409,7 @@ static int rtl2830_get_frontend(struct dvb_frontend *fe)
 	if (ret)
 		goto err;
 
-	dev_dbg(&dev->i2c->dev, "%s: TPS=%*ph\n", __func__, 3, buf);
+	dev_dbg(&client->dev, "TPS=%*ph\n", 3, buf);
 
 	switch ((buf[0] >> 2) & 3) {
 	case 0:
@@ -500,7 +499,7 @@ static int rtl2830_get_frontend(struct dvb_frontend *fe)
 
 	return 0;
 err:
-	dev_dbg(&dev->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	dev_dbg(&client->dev, "failed=%d\n", ret);
 	return ret;
 }
 
@@ -529,7 +528,7 @@ static int rtl2830_read_status(struct dvb_frontend *fe, fe_status_t *status)
 
 	return ret;
 err:
-	dev_dbg(&dev->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	dev_dbg(&client->dev, "failed=%d\n", ret);
 	return ret;
 }
 
@@ -579,7 +578,7 @@ static int rtl2830_read_snr(struct dvb_frontend *fe, u16 *snr)
 
 	return 0;
 err:
-	dev_dbg(&dev->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	dev_dbg(&client->dev, "failed=%d\n", ret);
 	return ret;
 }
 
@@ -601,7 +600,7 @@ static int rtl2830_read_ber(struct dvb_frontend *fe, u32 *ber)
 
 	return 0;
 err:
-	dev_dbg(&dev->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	dev_dbg(&client->dev, "failed=%d\n", ret);
 	return ret;
 }
 
@@ -638,7 +637,7 @@ static int rtl2830_read_signal_strength(struct dvb_frontend *fe, u16 *strength)
 
 	return 0;
 err:
-	dev_dbg(&dev->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	dev_dbg(&client->dev, "failed=%d\n", ret);
 	return ret;
 }
 
@@ -728,7 +727,7 @@ static int rtl2830_select(struct i2c_adapter *adap, void *mux_priv, u32 chan_id)
 	return 0;
 
 err:
-	dev_dbg(&client->dev, "%s: failed=%d\n", __func__, ret);
+	dev_dbg(&client->dev, "failed=%d\n", ret);
 	return ret;
 }
 

commit 1f153c4d88dd3e35900440608229c0d0335a83fb
Author: Antti Palosaari <crope@iki.fi>
Date:   Mon Dec 8 22:47:21 2014 -0300

    [media] rtl2830: carry pointer to I2C client for every function
    
    As a I2C driver struct i2c_client is top level structure representing
    the driver. Use it as parameter to carry all needed information for
    each function in order to simplify things.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/rtl2830.c b/drivers/media/dvb-frontends/rtl2830.c
index 44643d9b4322..e7ba6658ac8f 100644
--- a/drivers/media/dvb-frontends/rtl2830.c
+++ b/drivers/media/dvb-frontends/rtl2830.c
@@ -31,8 +31,9 @@
 #define MAX_XFER_SIZE  64
 
 /* write multiple hardware registers */
-static int rtl2830_wr(struct rtl2830_dev *dev, u8 reg, const u8 *val, int len)
+static int rtl2830_wr(struct i2c_client *client, u8 reg, const u8 *val, int len)
 {
+	struct rtl2830_dev *dev = i2c_get_clientdata(client);
 	int ret;
 	u8 buf[MAX_XFER_SIZE];
 	struct i2c_msg msg[1] = {
@@ -66,8 +67,9 @@ static int rtl2830_wr(struct rtl2830_dev *dev, u8 reg, const u8 *val, int len)
 }
 
 /* read multiple hardware registers */
-static int rtl2830_rd(struct rtl2830_dev *dev, u8 reg, u8 *val, int len)
+static int rtl2830_rd(struct i2c_client *client, u8 reg, u8 *val, int len)
 {
+	struct rtl2830_dev *dev = i2c_get_clientdata(client);
 	int ret;
 	struct i2c_msg msg[2] = {
 		{
@@ -95,59 +97,60 @@ static int rtl2830_rd(struct rtl2830_dev *dev, u8 reg, u8 *val, int len)
 }
 
 /* write multiple registers */
-static int rtl2830_wr_regs(struct rtl2830_dev *dev, u16 reg, const u8 *val,
-		int len)
+static int rtl2830_wr_regs(struct i2c_client *client, u16 reg, const u8 *val, int len)
 {
+	struct rtl2830_dev *dev = i2c_get_clientdata(client);
 	int ret;
 	u8 reg2 = (reg >> 0) & 0xff;
 	u8 page = (reg >> 8) & 0xff;
 
 	/* switch bank if needed */
 	if (page != dev->page) {
-		ret = rtl2830_wr(dev, 0x00, &page, 1);
+		ret = rtl2830_wr(client, 0x00, &page, 1);
 		if (ret)
 			return ret;
 
 		dev->page = page;
 	}
 
-	return rtl2830_wr(dev, reg2, val, len);
+	return rtl2830_wr(client, reg2, val, len);
 }
 
 /* read multiple registers */
-static int rtl2830_rd_regs(struct rtl2830_dev *dev, u16 reg, u8 *val, int len)
+static int rtl2830_rd_regs(struct i2c_client *client, u16 reg, u8 *val, int len)
 {
+	struct rtl2830_dev *dev = i2c_get_clientdata(client);
 	int ret;
 	u8 reg2 = (reg >> 0) & 0xff;
 	u8 page = (reg >> 8) & 0xff;
 
 	/* switch bank if needed */
 	if (page != dev->page) {
-		ret = rtl2830_wr(dev, 0x00, &page, 1);
+		ret = rtl2830_wr(client, 0x00, &page, 1);
 		if (ret)
 			return ret;
 
 		dev->page = page;
 	}
 
-	return rtl2830_rd(dev, reg2, val, len);
+	return rtl2830_rd(client, reg2, val, len);
 }
 
 /* read single register */
-static int rtl2830_rd_reg(struct rtl2830_dev *dev, u16 reg, u8 *val)
+static int rtl2830_rd_reg(struct i2c_client *client, u16 reg, u8 *val)
 {
-	return rtl2830_rd_regs(dev, reg, val, 1);
+	return rtl2830_rd_regs(client, reg, val, 1);
 }
 
 /* write single register with mask */
-static int rtl2830_wr_reg_mask(struct rtl2830_dev *dev, u16 reg, u8 val, u8 mask)
+static int rtl2830_wr_reg_mask(struct i2c_client *client, u16 reg, u8 val, u8 mask)
 {
 	int ret;
 	u8 tmp;
 
 	/* no need for read if whole reg is written */
 	if (mask != 0xff) {
-		ret = rtl2830_rd_regs(dev, reg, &tmp, 1);
+		ret = rtl2830_rd_regs(client, reg, &tmp, 1);
 		if (ret)
 			return ret;
 
@@ -156,16 +159,16 @@ static int rtl2830_wr_reg_mask(struct rtl2830_dev *dev, u16 reg, u8 val, u8 mask
 		val |= tmp;
 	}
 
-	return rtl2830_wr_regs(dev, reg, &val, 1);
+	return rtl2830_wr_regs(client, reg, &val, 1);
 }
 
 /* read single register with mask */
-static int rtl2830_rd_reg_mask(struct rtl2830_dev *dev, u16 reg, u8 *val, u8 mask)
+static int rtl2830_rd_reg_mask(struct i2c_client *client, u16 reg, u8 *val, u8 mask)
 {
 	int ret, i;
 	u8 tmp;
 
-	ret = rtl2830_rd_regs(dev, reg, &tmp, 1);
+	ret = rtl2830_rd_regs(client, reg, &tmp, 1);
 	if (ret)
 		return ret;
 
@@ -183,7 +186,8 @@ static int rtl2830_rd_reg_mask(struct rtl2830_dev *dev, u16 reg, u8 *val, u8 mas
 
 static int rtl2830_init(struct dvb_frontend *fe)
 {
-	struct rtl2830_dev *dev = fe->demodulator_priv;
+	struct i2c_client *client = fe->demodulator_priv;
+	struct rtl2830_dev *dev = i2c_get_clientdata(client);
 	int ret, i;
 	struct rtl2830_reg_val_mask tab[] = {
 		{ 0x00d, 0x01, 0x03 },
@@ -225,17 +229,17 @@ static int rtl2830_init(struct dvb_frontend *fe)
 	};
 
 	for (i = 0; i < ARRAY_SIZE(tab); i++) {
-		ret = rtl2830_wr_reg_mask(dev, tab[i].reg, tab[i].val,
+		ret = rtl2830_wr_reg_mask(client, tab[i].reg, tab[i].val,
 			tab[i].mask);
 		if (ret)
 			goto err;
 	}
 
-	ret = rtl2830_wr_regs(dev, 0x18f, "\x28\x00", 2);
+	ret = rtl2830_wr_regs(client, 0x18f, "\x28\x00", 2);
 	if (ret)
 		goto err;
 
-	ret = rtl2830_wr_regs(dev, 0x195,
+	ret = rtl2830_wr_regs(client, 0x195,
 		"\x04\x06\x0a\x12\x0a\x12\x1e\x28", 8);
 	if (ret)
 		goto err;
@@ -243,11 +247,11 @@ static int rtl2830_init(struct dvb_frontend *fe)
 	/* TODO: spec init */
 
 	/* soft reset */
-	ret = rtl2830_wr_reg_mask(dev, 0x101, 0x04, 0x04);
+	ret = rtl2830_wr_reg_mask(client, 0x101, 0x04, 0x04);
 	if (ret)
 		goto err;
 
-	ret = rtl2830_wr_reg_mask(dev, 0x101, 0x00, 0x04);
+	ret = rtl2830_wr_reg_mask(client, 0x101, 0x00, 0x04);
 	if (ret)
 		goto err;
 
@@ -261,7 +265,8 @@ static int rtl2830_init(struct dvb_frontend *fe)
 
 static int rtl2830_sleep(struct dvb_frontend *fe)
 {
-	struct rtl2830_dev *dev = fe->demodulator_priv;
+	struct i2c_client *client = fe->demodulator_priv;
+	struct rtl2830_dev *dev = i2c_get_clientdata(client);
 	dev->sleeping = true;
 	return 0;
 }
@@ -278,7 +283,8 @@ static int rtl2830_get_tune_settings(struct dvb_frontend *fe,
 
 static int rtl2830_set_frontend(struct dvb_frontend *fe)
 {
-	struct rtl2830_dev *dev = fe->demodulator_priv;
+	struct i2c_client *client = fe->demodulator_priv;
+	struct rtl2830_dev *dev = i2c_get_clientdata(client);
 	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
 	int ret, i;
 	u64 num;
@@ -331,7 +337,7 @@ static int rtl2830_set_frontend(struct dvb_frontend *fe)
 		return -EINVAL;
 	}
 
-	ret = rtl2830_wr_reg_mask(dev, 0x008, i << 1, 0x06);
+	ret = rtl2830_wr_reg_mask(client, 0x008, i << 1, 0x06);
 	if (ret)
 		goto err;
 
@@ -352,7 +358,7 @@ static int rtl2830_set_frontend(struct dvb_frontend *fe)
 	dev_dbg(&dev->i2c->dev, "%s: if_frequency=%d if_ctl=%08x\n",
 			__func__, if_frequency, if_ctl);
 
-	ret = rtl2830_rd_reg_mask(dev, 0x119, &tmp, 0xc0); /* b[7:6] */
+	ret = rtl2830_rd_reg_mask(client, 0x119, &tmp, 0xc0); /* b[7:6] */
 	if (ret)
 		goto err;
 
@@ -361,21 +367,21 @@ static int rtl2830_set_frontend(struct dvb_frontend *fe)
 	buf[1] = (if_ctl >>  8) & 0xff;
 	buf[2] = (if_ctl >>  0) & 0xff;
 
-	ret = rtl2830_wr_regs(dev, 0x119, buf, 3);
+	ret = rtl2830_wr_regs(client, 0x119, buf, 3);
 	if (ret)
 		goto err;
 
 	/* 1/2 split I2C write */
-	ret = rtl2830_wr_regs(dev, 0x11c, &bw_params1[i][0], 17);
+	ret = rtl2830_wr_regs(client, 0x11c, &bw_params1[i][0], 17);
 	if (ret)
 		goto err;
 
 	/* 2/2 split I2C write */
-	ret = rtl2830_wr_regs(dev, 0x12d, &bw_params1[i][17], 17);
+	ret = rtl2830_wr_regs(client, 0x12d, &bw_params1[i][17], 17);
 	if (ret)
 		goto err;
 
-	ret = rtl2830_wr_regs(dev, 0x19d, bw_params2[i], 6);
+	ret = rtl2830_wr_regs(client, 0x19d, bw_params2[i], 6);
 	if (ret)
 		goto err;
 
@@ -387,7 +393,8 @@ static int rtl2830_set_frontend(struct dvb_frontend *fe)
 
 static int rtl2830_get_frontend(struct dvb_frontend *fe)
 {
-	struct rtl2830_dev *dev = fe->demodulator_priv;
+	struct i2c_client *client = fe->demodulator_priv;
+	struct rtl2830_dev *dev = i2c_get_clientdata(client);
 	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
 	int ret;
 	u8 buf[3];
@@ -395,11 +402,11 @@ static int rtl2830_get_frontend(struct dvb_frontend *fe)
 	if (dev->sleeping)
 		return 0;
 
-	ret = rtl2830_rd_regs(dev, 0x33c, buf, 2);
+	ret = rtl2830_rd_regs(client, 0x33c, buf, 2);
 	if (ret)
 		goto err;
 
-	ret = rtl2830_rd_reg(dev, 0x351, &buf[2]);
+	ret = rtl2830_rd_reg(client, 0x351, &buf[2]);
 	if (ret)
 		goto err;
 
@@ -499,6 +506,7 @@ static int rtl2830_get_frontend(struct dvb_frontend *fe)
 
 static int rtl2830_read_status(struct dvb_frontend *fe, fe_status_t *status)
 {
+	struct i2c_client *client = fe->demodulator_priv;
 	struct rtl2830_dev *dev = fe->demodulator_priv;
 	int ret;
 	u8 tmp;
@@ -507,7 +515,7 @@ static int rtl2830_read_status(struct dvb_frontend *fe, fe_status_t *status)
 	if (dev->sleeping)
 		return 0;
 
-	ret = rtl2830_rd_reg_mask(dev, 0x351, &tmp, 0x78); /* [6:3] */
+	ret = rtl2830_rd_reg_mask(client, 0x351, &tmp, 0x78); /* [6:3] */
 	if (ret)
 		goto err;
 
@@ -527,7 +535,8 @@ static int rtl2830_read_status(struct dvb_frontend *fe, fe_status_t *status)
 
 static int rtl2830_read_snr(struct dvb_frontend *fe, u16 *snr)
 {
-	struct rtl2830_dev *dev = fe->demodulator_priv;
+	struct i2c_client *client = fe->demodulator_priv;
+	struct rtl2830_dev *dev = i2c_get_clientdata(client);
 	int ret, hierarchy, constellation;
 	u8 buf[2], tmp;
 	u16 tmp16;
@@ -544,7 +553,7 @@ static int rtl2830_read_snr(struct dvb_frontend *fe, u16 *snr)
 
 	/* reports SNR in resolution of 0.1 dB */
 
-	ret = rtl2830_rd_reg(dev, 0x33c, &tmp);
+	ret = rtl2830_rd_reg(client, 0x33c, &tmp);
 	if (ret)
 		goto err;
 
@@ -556,7 +565,7 @@ static int rtl2830_read_snr(struct dvb_frontend *fe, u16 *snr)
 	if (hierarchy > HIERARCHY_NUM - 1)
 		goto err;
 
-	ret = rtl2830_rd_regs(dev, 0x40c, buf, 2);
+	ret = rtl2830_rd_regs(client, 0x40c, buf, 2);
 	if (ret)
 		goto err;
 
@@ -576,14 +585,15 @@ static int rtl2830_read_snr(struct dvb_frontend *fe, u16 *snr)
 
 static int rtl2830_read_ber(struct dvb_frontend *fe, u32 *ber)
 {
-	struct rtl2830_dev *dev = fe->demodulator_priv;
+	struct i2c_client *client = fe->demodulator_priv;
+	struct rtl2830_dev *dev = i2c_get_clientdata(client);
 	int ret;
 	u8 buf[2];
 
 	if (dev->sleeping)
 		return 0;
 
-	ret = rtl2830_rd_regs(dev, 0x34e, buf, 2);
+	ret = rtl2830_rd_regs(client, 0x34e, buf, 2);
 	if (ret)
 		goto err;
 
@@ -603,7 +613,8 @@ static int rtl2830_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)
 
 static int rtl2830_read_signal_strength(struct dvb_frontend *fe, u16 *strength)
 {
-	struct rtl2830_dev *dev = fe->demodulator_priv;
+	struct i2c_client *client = fe->demodulator_priv;
+	struct rtl2830_dev *dev = i2c_get_clientdata(client);
 	int ret;
 	u8 buf[2];
 	u16 if_agc_raw, if_agc;
@@ -611,7 +622,7 @@ static int rtl2830_read_signal_strength(struct dvb_frontend *fe, u16 *strength)
 	if (dev->sleeping)
 		return 0;
 
-	ret = rtl2830_rd_regs(dev, 0x359, buf, 2);
+	ret = rtl2830_rd_regs(client, 0x359, buf, 2);
 	if (ret)
 		goto err;
 
@@ -774,7 +785,7 @@ static int rtl2830_probe(struct i2c_client *client,
 	dev->cfg.agc_targ_val = pdata->agc_targ_val;
 
 	/* check if the demod is there */
-	ret = rtl2830_rd_reg(dev, 0x000, &u8tmp);
+	ret = rtl2830_rd_reg(client, 0x000, &u8tmp);
 	if (ret)
 		goto err_kfree;
 
@@ -788,7 +799,7 @@ static int rtl2830_probe(struct i2c_client *client,
 
 	/* create dvb frontend */
 	memcpy(&dev->fe.ops, &rtl2830_ops, sizeof(dev->fe.ops));
-	dev->fe.demodulator_priv = dev;
+	dev->fe.demodulator_priv = client;
 
 	/* setup callbacks */
 	pdata->get_dvb_frontend = rtl2830_get_dvb_frontend;

commit f544f100ac5f62ef288940bdfd3421ba7a22789b
Author: Antti Palosaari <crope@iki.fi>
Date:   Mon Dec 8 22:31:28 2014 -0300

    [media] rtl2830: rename 'priv' to 'dev'
    
    Use name 'dev' for device state instance as it is more common and
    also one letter shorter.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/rtl2830.c b/drivers/media/dvb-frontends/rtl2830.c
index 541e24496163..44643d9b4322 100644
--- a/drivers/media/dvb-frontends/rtl2830.c
+++ b/drivers/media/dvb-frontends/rtl2830.c
@@ -31,13 +31,13 @@
 #define MAX_XFER_SIZE  64
 
 /* write multiple hardware registers */
-static int rtl2830_wr(struct rtl2830_priv *priv, u8 reg, const u8 *val, int len)
+static int rtl2830_wr(struct rtl2830_dev *dev, u8 reg, const u8 *val, int len)
 {
 	int ret;
 	u8 buf[MAX_XFER_SIZE];
 	struct i2c_msg msg[1] = {
 		{
-			.addr = priv->cfg.i2c_addr,
+			.addr = dev->cfg.i2c_addr,
 			.flags = 0,
 			.len = 1 + len,
 			.buf = buf,
@@ -45,7 +45,7 @@ static int rtl2830_wr(struct rtl2830_priv *priv, u8 reg, const u8 *val, int len)
 	};
 
 	if (1 + len > sizeof(buf)) {
-		dev_warn(&priv->i2c->dev,
+		dev_warn(&dev->i2c->dev,
 			 "%s: i2c wr reg=%04x: len=%d is too big!\n",
 			 KBUILD_MODNAME, reg, len);
 		return -EINVAL;
@@ -54,11 +54,11 @@ static int rtl2830_wr(struct rtl2830_priv *priv, u8 reg, const u8 *val, int len)
 	buf[0] = reg;
 	memcpy(&buf[1], val, len);
 
-	ret = i2c_transfer(priv->i2c, msg, 1);
+	ret = i2c_transfer(dev->i2c, msg, 1);
 	if (ret == 1) {
 		ret = 0;
 	} else {
-		dev_warn(&priv->i2c->dev, "%s: i2c wr failed=%d reg=%02x " \
+		dev_warn(&dev->i2c->dev, "%s: i2c wr failed=%d reg=%02x " \
 				"len=%d\n", KBUILD_MODNAME, ret, reg, len);
 		ret = -EREMOTEIO;
 	}
@@ -66,28 +66,28 @@ static int rtl2830_wr(struct rtl2830_priv *priv, u8 reg, const u8 *val, int len)
 }
 
 /* read multiple hardware registers */
-static int rtl2830_rd(struct rtl2830_priv *priv, u8 reg, u8 *val, int len)
+static int rtl2830_rd(struct rtl2830_dev *dev, u8 reg, u8 *val, int len)
 {
 	int ret;
 	struct i2c_msg msg[2] = {
 		{
-			.addr = priv->cfg.i2c_addr,
+			.addr = dev->cfg.i2c_addr,
 			.flags = 0,
 			.len = 1,
 			.buf = &reg,
 		}, {
-			.addr = priv->cfg.i2c_addr,
+			.addr = dev->cfg.i2c_addr,
 			.flags = I2C_M_RD,
 			.len = len,
 			.buf = val,
 		}
 	};
 
-	ret = i2c_transfer(priv->i2c, msg, 2);
+	ret = i2c_transfer(dev->i2c, msg, 2);
 	if (ret == 2) {
 		ret = 0;
 	} else {
-		dev_warn(&priv->i2c->dev, "%s: i2c rd failed=%d reg=%02x " \
+		dev_warn(&dev->i2c->dev, "%s: i2c rd failed=%d reg=%02x " \
 				"len=%d\n", KBUILD_MODNAME, ret, reg, len);
 		ret = -EREMOTEIO;
 	}
@@ -95,7 +95,7 @@ static int rtl2830_rd(struct rtl2830_priv *priv, u8 reg, u8 *val, int len)
 }
 
 /* write multiple registers */
-static int rtl2830_wr_regs(struct rtl2830_priv *priv, u16 reg, const u8 *val,
+static int rtl2830_wr_regs(struct rtl2830_dev *dev, u16 reg, const u8 *val,
 		int len)
 {
 	int ret;
@@ -103,51 +103,51 @@ static int rtl2830_wr_regs(struct rtl2830_priv *priv, u16 reg, const u8 *val,
 	u8 page = (reg >> 8) & 0xff;
 
 	/* switch bank if needed */
-	if (page != priv->page) {
-		ret = rtl2830_wr(priv, 0x00, &page, 1);
+	if (page != dev->page) {
+		ret = rtl2830_wr(dev, 0x00, &page, 1);
 		if (ret)
 			return ret;
 
-		priv->page = page;
+		dev->page = page;
 	}
 
-	return rtl2830_wr(priv, reg2, val, len);
+	return rtl2830_wr(dev, reg2, val, len);
 }
 
 /* read multiple registers */
-static int rtl2830_rd_regs(struct rtl2830_priv *priv, u16 reg, u8 *val, int len)
+static int rtl2830_rd_regs(struct rtl2830_dev *dev, u16 reg, u8 *val, int len)
 {
 	int ret;
 	u8 reg2 = (reg >> 0) & 0xff;
 	u8 page = (reg >> 8) & 0xff;
 
 	/* switch bank if needed */
-	if (page != priv->page) {
-		ret = rtl2830_wr(priv, 0x00, &page, 1);
+	if (page != dev->page) {
+		ret = rtl2830_wr(dev, 0x00, &page, 1);
 		if (ret)
 			return ret;
 
-		priv->page = page;
+		dev->page = page;
 	}
 
-	return rtl2830_rd(priv, reg2, val, len);
+	return rtl2830_rd(dev, reg2, val, len);
 }
 
 /* read single register */
-static int rtl2830_rd_reg(struct rtl2830_priv *priv, u16 reg, u8 *val)
+static int rtl2830_rd_reg(struct rtl2830_dev *dev, u16 reg, u8 *val)
 {
-	return rtl2830_rd_regs(priv, reg, val, 1);
+	return rtl2830_rd_regs(dev, reg, val, 1);
 }
 
 /* write single register with mask */
-static int rtl2830_wr_reg_mask(struct rtl2830_priv *priv, u16 reg, u8 val, u8 mask)
+static int rtl2830_wr_reg_mask(struct rtl2830_dev *dev, u16 reg, u8 val, u8 mask)
 {
 	int ret;
 	u8 tmp;
 
 	/* no need for read if whole reg is written */
 	if (mask != 0xff) {
-		ret = rtl2830_rd_regs(priv, reg, &tmp, 1);
+		ret = rtl2830_rd_regs(dev, reg, &tmp, 1);
 		if (ret)
 			return ret;
 
@@ -156,16 +156,16 @@ static int rtl2830_wr_reg_mask(struct rtl2830_priv *priv, u16 reg, u8 val, u8 ma
 		val |= tmp;
 	}
 
-	return rtl2830_wr_regs(priv, reg, &val, 1);
+	return rtl2830_wr_regs(dev, reg, &val, 1);
 }
 
 /* read single register with mask */
-static int rtl2830_rd_reg_mask(struct rtl2830_priv *priv, u16 reg, u8 *val, u8 mask)
+static int rtl2830_rd_reg_mask(struct rtl2830_dev *dev, u16 reg, u8 *val, u8 mask)
 {
 	int ret, i;
 	u8 tmp;
 
-	ret = rtl2830_rd_regs(priv, reg, &tmp, 1);
+	ret = rtl2830_rd_regs(dev, reg, &tmp, 1);
 	if (ret)
 		return ret;
 
@@ -183,7 +183,7 @@ static int rtl2830_rd_reg_mask(struct rtl2830_priv *priv, u16 reg, u8 *val, u8 m
 
 static int rtl2830_init(struct dvb_frontend *fe)
 {
-	struct rtl2830_priv *priv = fe->demodulator_priv;
+	struct rtl2830_dev *dev = fe->demodulator_priv;
 	int ret, i;
 	struct rtl2830_reg_val_mask tab[] = {
 		{ 0x00d, 0x01, 0x03 },
@@ -204,10 +204,10 @@ static int rtl2830_init(struct dvb_frontend *fe)
 		{ 0x2f1, 0x20, 0xf8 },
 		{ 0x16d, 0x00, 0x01 },
 		{ 0x1a6, 0x00, 0x80 },
-		{ 0x106, priv->cfg.vtop, 0x3f },
-		{ 0x107, priv->cfg.krf, 0x3f },
+		{ 0x106, dev->cfg.vtop, 0x3f },
+		{ 0x107, dev->cfg.krf, 0x3f },
 		{ 0x112, 0x28, 0xff },
-		{ 0x103, priv->cfg.agc_targ_val, 0xff },
+		{ 0x103, dev->cfg.agc_targ_val, 0xff },
 		{ 0x00a, 0x02, 0x07 },
 		{ 0x140, 0x0c, 0x3c },
 		{ 0x140, 0x40, 0xc0 },
@@ -215,7 +215,7 @@ static int rtl2830_init(struct dvb_frontend *fe)
 		{ 0x15b, 0x28, 0x38 },
 		{ 0x15c, 0x05, 0x07 },
 		{ 0x15c, 0x28, 0x38 },
-		{ 0x115, priv->cfg.spec_inv, 0x01 },
+		{ 0x115, dev->cfg.spec_inv, 0x01 },
 		{ 0x16f, 0x01, 0x07 },
 		{ 0x170, 0x18, 0x38 },
 		{ 0x172, 0x0f, 0x0f },
@@ -225,17 +225,17 @@ static int rtl2830_init(struct dvb_frontend *fe)
 	};
 
 	for (i = 0; i < ARRAY_SIZE(tab); i++) {
-		ret = rtl2830_wr_reg_mask(priv, tab[i].reg, tab[i].val,
+		ret = rtl2830_wr_reg_mask(dev, tab[i].reg, tab[i].val,
 			tab[i].mask);
 		if (ret)
 			goto err;
 	}
 
-	ret = rtl2830_wr_regs(priv, 0x18f, "\x28\x00", 2);
+	ret = rtl2830_wr_regs(dev, 0x18f, "\x28\x00", 2);
 	if (ret)
 		goto err;
 
-	ret = rtl2830_wr_regs(priv, 0x195,
+	ret = rtl2830_wr_regs(dev, 0x195,
 		"\x04\x06\x0a\x12\x0a\x12\x1e\x28", 8);
 	if (ret)
 		goto err;
@@ -243,26 +243,26 @@ static int rtl2830_init(struct dvb_frontend *fe)
 	/* TODO: spec init */
 
 	/* soft reset */
-	ret = rtl2830_wr_reg_mask(priv, 0x101, 0x04, 0x04);
+	ret = rtl2830_wr_reg_mask(dev, 0x101, 0x04, 0x04);
 	if (ret)
 		goto err;
 
-	ret = rtl2830_wr_reg_mask(priv, 0x101, 0x00, 0x04);
+	ret = rtl2830_wr_reg_mask(dev, 0x101, 0x00, 0x04);
 	if (ret)
 		goto err;
 
-	priv->sleeping = false;
+	dev->sleeping = false;
 
 	return ret;
 err:
-	dev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	dev_dbg(&dev->i2c->dev, "%s: failed=%d\n", __func__, ret);
 	return ret;
 }
 
 static int rtl2830_sleep(struct dvb_frontend *fe)
 {
-	struct rtl2830_priv *priv = fe->demodulator_priv;
-	priv->sleeping = true;
+	struct rtl2830_dev *dev = fe->demodulator_priv;
+	dev->sleeping = true;
 	return 0;
 }
 
@@ -278,7 +278,7 @@ static int rtl2830_get_tune_settings(struct dvb_frontend *fe,
 
 static int rtl2830_set_frontend(struct dvb_frontend *fe)
 {
-	struct rtl2830_priv *priv = fe->demodulator_priv;
+	struct rtl2830_dev *dev = fe->demodulator_priv;
 	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
 	int ret, i;
 	u64 num;
@@ -308,7 +308,7 @@ static int rtl2830_set_frontend(struct dvb_frontend *fe)
 		{0xae, 0xba, 0xf3, 0x26, 0x66, 0x64}, /* 8 MHz */
 	};
 
-	dev_dbg(&priv->i2c->dev,
+	dev_dbg(&dev->i2c->dev,
 			"%s: frequency=%d bandwidth_hz=%d inversion=%d\n",
 			__func__, c->frequency, c->bandwidth_hz, c->inversion);
 
@@ -327,11 +327,11 @@ static int rtl2830_set_frontend(struct dvb_frontend *fe)
 		i = 2;
 		break;
 	default:
-		dev_dbg(&priv->i2c->dev, "%s: invalid bandwidth\n", __func__);
+		dev_dbg(&dev->i2c->dev, "%s: invalid bandwidth\n", __func__);
 		return -EINVAL;
 	}
 
-	ret = rtl2830_wr_reg_mask(priv, 0x008, i << 1, 0x06);
+	ret = rtl2830_wr_reg_mask(dev, 0x008, i << 1, 0x06);
 	if (ret)
 		goto err;
 
@@ -344,15 +344,15 @@ static int rtl2830_set_frontend(struct dvb_frontend *fe)
 	if (ret < 0)
 		goto err;
 
-	num = if_frequency % priv->cfg.xtal;
+	num = if_frequency % dev->cfg.xtal;
 	num *= 0x400000;
-	num = div_u64(num, priv->cfg.xtal);
+	num = div_u64(num, dev->cfg.xtal);
 	num = -num;
 	if_ctl = num & 0x3fffff;
-	dev_dbg(&priv->i2c->dev, "%s: if_frequency=%d if_ctl=%08x\n",
+	dev_dbg(&dev->i2c->dev, "%s: if_frequency=%d if_ctl=%08x\n",
 			__func__, if_frequency, if_ctl);
 
-	ret = rtl2830_rd_reg_mask(priv, 0x119, &tmp, 0xc0); /* b[7:6] */
+	ret = rtl2830_rd_reg_mask(dev, 0x119, &tmp, 0xc0); /* b[7:6] */
 	if (ret)
 		goto err;
 
@@ -361,49 +361,49 @@ static int rtl2830_set_frontend(struct dvb_frontend *fe)
 	buf[1] = (if_ctl >>  8) & 0xff;
 	buf[2] = (if_ctl >>  0) & 0xff;
 
-	ret = rtl2830_wr_regs(priv, 0x119, buf, 3);
+	ret = rtl2830_wr_regs(dev, 0x119, buf, 3);
 	if (ret)
 		goto err;
 
 	/* 1/2 split I2C write */
-	ret = rtl2830_wr_regs(priv, 0x11c, &bw_params1[i][0], 17);
+	ret = rtl2830_wr_regs(dev, 0x11c, &bw_params1[i][0], 17);
 	if (ret)
 		goto err;
 
 	/* 2/2 split I2C write */
-	ret = rtl2830_wr_regs(priv, 0x12d, &bw_params1[i][17], 17);
+	ret = rtl2830_wr_regs(dev, 0x12d, &bw_params1[i][17], 17);
 	if (ret)
 		goto err;
 
-	ret = rtl2830_wr_regs(priv, 0x19d, bw_params2[i], 6);
+	ret = rtl2830_wr_regs(dev, 0x19d, bw_params2[i], 6);
 	if (ret)
 		goto err;
 
 	return ret;
 err:
-	dev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	dev_dbg(&dev->i2c->dev, "%s: failed=%d\n", __func__, ret);
 	return ret;
 }
 
 static int rtl2830_get_frontend(struct dvb_frontend *fe)
 {
-	struct rtl2830_priv *priv = fe->demodulator_priv;
+	struct rtl2830_dev *dev = fe->demodulator_priv;
 	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
 	int ret;
 	u8 buf[3];
 
-	if (priv->sleeping)
+	if (dev->sleeping)
 		return 0;
 
-	ret = rtl2830_rd_regs(priv, 0x33c, buf, 2);
+	ret = rtl2830_rd_regs(dev, 0x33c, buf, 2);
 	if (ret)
 		goto err;
 
-	ret = rtl2830_rd_reg(priv, 0x351, &buf[2]);
+	ret = rtl2830_rd_reg(dev, 0x351, &buf[2]);
 	if (ret)
 		goto err;
 
-	dev_dbg(&priv->i2c->dev, "%s: TPS=%*ph\n", __func__, 3, buf);
+	dev_dbg(&dev->i2c->dev, "%s: TPS=%*ph\n", __func__, 3, buf);
 
 	switch ((buf[0] >> 2) & 3) {
 	case 0:
@@ -493,21 +493,21 @@ static int rtl2830_get_frontend(struct dvb_frontend *fe)
 
 	return 0;
 err:
-	dev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	dev_dbg(&dev->i2c->dev, "%s: failed=%d\n", __func__, ret);
 	return ret;
 }
 
 static int rtl2830_read_status(struct dvb_frontend *fe, fe_status_t *status)
 {
-	struct rtl2830_priv *priv = fe->demodulator_priv;
+	struct rtl2830_dev *dev = fe->demodulator_priv;
 	int ret;
 	u8 tmp;
 	*status = 0;
 
-	if (priv->sleeping)
+	if (dev->sleeping)
 		return 0;
 
-	ret = rtl2830_rd_reg_mask(priv, 0x351, &tmp, 0x78); /* [6:3] */
+	ret = rtl2830_rd_reg_mask(dev, 0x351, &tmp, 0x78); /* [6:3] */
 	if (ret)
 		goto err;
 
@@ -521,13 +521,13 @@ static int rtl2830_read_status(struct dvb_frontend *fe, fe_status_t *status)
 
 	return ret;
 err:
-	dev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	dev_dbg(&dev->i2c->dev, "%s: failed=%d\n", __func__, ret);
 	return ret;
 }
 
 static int rtl2830_read_snr(struct dvb_frontend *fe, u16 *snr)
 {
-	struct rtl2830_priv *priv = fe->demodulator_priv;
+	struct rtl2830_dev *dev = fe->demodulator_priv;
 	int ret, hierarchy, constellation;
 	u8 buf[2], tmp;
 	u16 tmp16;
@@ -539,12 +539,12 @@ static int rtl2830_read_snr(struct dvb_frontend *fe, u16 *snr)
 		{ 92888734, 92888734, 95487525, 99770748 },
 	};
 
-	if (priv->sleeping)
+	if (dev->sleeping)
 		return 0;
 
 	/* reports SNR in resolution of 0.1 dB */
 
-	ret = rtl2830_rd_reg(priv, 0x33c, &tmp);
+	ret = rtl2830_rd_reg(dev, 0x33c, &tmp);
 	if (ret)
 		goto err;
 
@@ -556,7 +556,7 @@ static int rtl2830_read_snr(struct dvb_frontend *fe, u16 *snr)
 	if (hierarchy > HIERARCHY_NUM - 1)
 		goto err;
 
-	ret = rtl2830_rd_regs(priv, 0x40c, buf, 2);
+	ret = rtl2830_rd_regs(dev, 0x40c, buf, 2);
 	if (ret)
 		goto err;
 
@@ -570,20 +570,20 @@ static int rtl2830_read_snr(struct dvb_frontend *fe, u16 *snr)
 
 	return 0;
 err:
-	dev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	dev_dbg(&dev->i2c->dev, "%s: failed=%d\n", __func__, ret);
 	return ret;
 }
 
 static int rtl2830_read_ber(struct dvb_frontend *fe, u32 *ber)
 {
-	struct rtl2830_priv *priv = fe->demodulator_priv;
+	struct rtl2830_dev *dev = fe->demodulator_priv;
 	int ret;
 	u8 buf[2];
 
-	if (priv->sleeping)
+	if (dev->sleeping)
 		return 0;
 
-	ret = rtl2830_rd_regs(priv, 0x34e, buf, 2);
+	ret = rtl2830_rd_regs(dev, 0x34e, buf, 2);
 	if (ret)
 		goto err;
 
@@ -591,7 +591,7 @@ static int rtl2830_read_ber(struct dvb_frontend *fe, u32 *ber)
 
 	return 0;
 err:
-	dev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	dev_dbg(&dev->i2c->dev, "%s: failed=%d\n", __func__, ret);
 	return ret;
 }
 
@@ -603,15 +603,15 @@ static int rtl2830_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)
 
 static int rtl2830_read_signal_strength(struct dvb_frontend *fe, u16 *strength)
 {
-	struct rtl2830_priv *priv = fe->demodulator_priv;
+	struct rtl2830_dev *dev = fe->demodulator_priv;
 	int ret;
 	u8 buf[2];
 	u16 if_agc_raw, if_agc;
 
-	if (priv->sleeping)
+	if (dev->sleeping)
 		return 0;
 
-	ret = rtl2830_rd_regs(priv, 0x359, buf, 2);
+	ret = rtl2830_rd_regs(dev, 0x359, buf, 2);
 	if (ret)
 		goto err;
 
@@ -627,7 +627,7 @@ static int rtl2830_read_signal_strength(struct dvb_frontend *fe, u16 *strength)
 
 	return 0;
 err:
-	dev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	dev_dbg(&dev->i2c->dev, "%s: failed=%d\n", __func__, ret);
 	return ret;
 }
 
@@ -675,10 +675,10 @@ static struct dvb_frontend_ops rtl2830_ops = {
 static int rtl2830_select(struct i2c_adapter *adap, void *mux_priv, u32 chan_id)
 {
 	struct i2c_client *client = mux_priv;
-	struct rtl2830_priv *priv = i2c_get_clientdata(client);
+	struct rtl2830_dev *dev = i2c_get_clientdata(client);
 	struct i2c_msg select_reg_page_msg[1] = {
 		{
-			.addr = priv->cfg.i2c_addr,
+			.addr = dev->cfg.i2c_addr,
 			.flags = 0,
 			.len = 2,
 			.buf = "\x00\x01",
@@ -686,7 +686,7 @@ static int rtl2830_select(struct i2c_adapter *adap, void *mux_priv, u32 chan_id)
 	};
 	struct i2c_msg gate_open_msg[1] = {
 		{
-			.addr = priv->cfg.i2c_addr,
+			.addr = dev->cfg.i2c_addr,
 			.flags = 0,
 			.len = 2,
 			.buf = "\x01\x08",
@@ -703,7 +703,7 @@ static int rtl2830_select(struct i2c_adapter *adap, void *mux_priv, u32 chan_id)
 		goto err;
 	}
 
-	priv->page = 1;
+	dev->page = 1;
 
 	/* open tuner I2C repeater for 1 xfer, closes automatically */
 	ret = __i2c_transfer(adap, gate_open_msg, 1);
@@ -723,20 +723,20 @@ static int rtl2830_select(struct i2c_adapter *adap, void *mux_priv, u32 chan_id)
 
 static struct dvb_frontend *rtl2830_get_dvb_frontend(struct i2c_client *client)
 {
-	struct rtl2830_priv *priv = i2c_get_clientdata(client);
+	struct rtl2830_dev *dev = i2c_get_clientdata(client);
 
 	dev_dbg(&client->dev, "\n");
 
-	return &priv->fe;
+	return &dev->fe;
 }
 
 static struct i2c_adapter *rtl2830_get_i2c_adapter(struct i2c_client *client)
 {
-	struct rtl2830_priv *priv = i2c_get_clientdata(client);
+	struct rtl2830_dev *dev = i2c_get_clientdata(client);
 
 	dev_dbg(&client->dev, "\n");
 
-	return priv->adapter;
+	return dev->adapter;
 }
 
 static int rtl2830_probe(struct i2c_client *client,
@@ -744,7 +744,7 @@ static int rtl2830_probe(struct i2c_client *client,
 {
 	struct rtl2830_platform_data *pdata = client->dev.platform_data;
 	struct i2c_adapter *i2c = client->adapter;
-	struct rtl2830_priv *priv;
+	struct rtl2830_dev *dev;
 	int ret;
 	u8 u8tmp;
 
@@ -756,39 +756,39 @@ static int rtl2830_probe(struct i2c_client *client,
 	}
 
 	/* allocate memory for the internal state */
-	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
-	if (priv == NULL) {
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (dev == NULL) {
 		ret = -ENOMEM;
 		goto err;
 	}
 
 	/* setup the state */
-	i2c_set_clientdata(client, priv);
-	priv->i2c = i2c;
-	priv->sleeping = true;
-	priv->cfg.i2c_addr = client->addr;
-	priv->cfg.xtal = pdata->clk;
-	priv->cfg.spec_inv = pdata->spec_inv;
-	priv->cfg.vtop = pdata->vtop;
-	priv->cfg.krf = pdata->krf;
-	priv->cfg.agc_targ_val = pdata->agc_targ_val;
+	i2c_set_clientdata(client, dev);
+	dev->i2c = i2c;
+	dev->sleeping = true;
+	dev->cfg.i2c_addr = client->addr;
+	dev->cfg.xtal = pdata->clk;
+	dev->cfg.spec_inv = pdata->spec_inv;
+	dev->cfg.vtop = pdata->vtop;
+	dev->cfg.krf = pdata->krf;
+	dev->cfg.agc_targ_val = pdata->agc_targ_val;
 
 	/* check if the demod is there */
-	ret = rtl2830_rd_reg(priv, 0x000, &u8tmp);
+	ret = rtl2830_rd_reg(dev, 0x000, &u8tmp);
 	if (ret)
 		goto err_kfree;
 
 	/* create muxed i2c adapter for tuner */
-	priv->adapter = i2c_add_mux_adapter(client->adapter, &client->dev,
+	dev->adapter = i2c_add_mux_adapter(client->adapter, &client->dev,
 			client, 0, 0, 0, rtl2830_select, NULL);
-	if (priv->adapter == NULL) {
+	if (dev->adapter == NULL) {
 		ret = -ENODEV;
 		goto err_kfree;
 	}
 
 	/* create dvb frontend */
-	memcpy(&priv->fe.ops, &rtl2830_ops, sizeof(priv->fe.ops));
-	priv->fe.demodulator_priv = priv;
+	memcpy(&dev->fe.ops, &rtl2830_ops, sizeof(dev->fe.ops));
+	dev->fe.demodulator_priv = dev;
 
 	/* setup callbacks */
 	pdata->get_dvb_frontend = rtl2830_get_dvb_frontend;
@@ -798,7 +798,7 @@ static int rtl2830_probe(struct i2c_client *client,
 	return 0;
 
 err_kfree:
-	kfree(priv);
+	kfree(dev);
 err:
 	dev_dbg(&client->dev, "failed=%d\n", ret);
 	return ret;
@@ -806,12 +806,12 @@ static int rtl2830_probe(struct i2c_client *client,
 
 static int rtl2830_remove(struct i2c_client *client)
 {
-	struct rtl2830_priv *priv = i2c_get_clientdata(client);
+	struct rtl2830_dev *dev = i2c_get_clientdata(client);
 
 	dev_dbg(&client->dev, "\n");
 
-	i2c_del_mux_adapter(priv->adapter);
-	kfree(priv);
+	i2c_del_mux_adapter(dev->adapter);
+	kfree(dev);
 	return 0;
 }
 

commit aba4e34a788d10a9578969ae836627400d2d21a2
Author: Antti Palosaari <crope@iki.fi>
Date:   Mon Dec 8 22:20:55 2014 -0300

    [media] rtl2830: get rid of legacy DVB driver binding
    
    Remove legacy DVB binding as all users are using I2C binding.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/rtl2830.c b/drivers/media/dvb-frontends/rtl2830.c
index ec4a19c63090..541e24496163 100644
--- a/drivers/media/dvb-frontends/rtl2830.c
+++ b/drivers/media/dvb-frontends/rtl2830.c
@@ -631,104 +631,6 @@ static int rtl2830_read_signal_strength(struct dvb_frontend *fe, u16 *strength)
 	return ret;
 }
 
-static struct dvb_frontend_ops rtl2830_ops;
-
-static u32 rtl2830_tuner_i2c_func(struct i2c_adapter *adapter)
-{
-	return I2C_FUNC_I2C;
-}
-
-static int rtl2830_tuner_i2c_xfer(struct i2c_adapter *i2c_adap,
-	struct i2c_msg msg[], int num)
-{
-	struct rtl2830_priv *priv = i2c_get_adapdata(i2c_adap);
-	int ret;
-
-	/* open i2c-gate */
-	ret = rtl2830_wr_reg_mask(priv, 0x101, 0x08, 0x08);
-	if (ret)
-		goto err;
-
-	ret = i2c_transfer(priv->i2c, msg, num);
-	if (ret < 0)
-		dev_warn(&priv->i2c->dev, "%s: tuner i2c failed=%d\n",
-			KBUILD_MODNAME, ret);
-
-	return ret;
-err:
-	dev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);
-	return ret;
-}
-
-static struct i2c_algorithm rtl2830_tuner_i2c_algo = {
-	.master_xfer   = rtl2830_tuner_i2c_xfer,
-	.functionality = rtl2830_tuner_i2c_func,
-};
-
-struct i2c_adapter *rtl2830_get_tuner_i2c_adapter(struct dvb_frontend *fe)
-{
-	struct rtl2830_priv *priv = fe->demodulator_priv;
-	return &priv->tuner_i2c_adapter;
-}
-EXPORT_SYMBOL(rtl2830_get_tuner_i2c_adapter);
-
-static void rtl2830_release(struct dvb_frontend *fe)
-{
-	struct rtl2830_priv *priv = fe->demodulator_priv;
-
-	i2c_del_adapter(&priv->tuner_i2c_adapter);
-	kfree(priv);
-}
-
-struct dvb_frontend *rtl2830_attach(const struct rtl2830_config *cfg,
-	struct i2c_adapter *i2c)
-{
-	struct rtl2830_priv *priv = NULL;
-	int ret = 0;
-	u8 tmp;
-
-	/* allocate memory for the internal state */
-	priv = kzalloc(sizeof(struct rtl2830_priv), GFP_KERNEL);
-	if (priv == NULL)
-		goto err;
-
-	/* setup the priv */
-	priv->i2c = i2c;
-	memcpy(&priv->cfg, cfg, sizeof(struct rtl2830_config));
-
-	/* check if the demod is there */
-	ret = rtl2830_rd_reg(priv, 0x000, &tmp);
-	if (ret)
-		goto err;
-
-	/* create dvb_frontend */
-	memcpy(&priv->fe.ops, &rtl2830_ops, sizeof(struct dvb_frontend_ops));
-	priv->fe.demodulator_priv = priv;
-
-	/* create tuner i2c adapter */
-	strlcpy(priv->tuner_i2c_adapter.name, "RTL2830 tuner I2C adapter",
-		sizeof(priv->tuner_i2c_adapter.name));
-	priv->tuner_i2c_adapter.algo = &rtl2830_tuner_i2c_algo;
-	priv->tuner_i2c_adapter.algo_data = NULL;
-	priv->tuner_i2c_adapter.dev.parent = &i2c->dev;
-	i2c_set_adapdata(&priv->tuner_i2c_adapter, priv);
-	if (i2c_add_adapter(&priv->tuner_i2c_adapter) < 0) {
-		dev_err(&i2c->dev,
-				"%s: tuner i2c bus could not be initialized\n",
-				KBUILD_MODNAME);
-		goto err;
-	}
-
-	priv->sleeping = true;
-
-	return &priv->fe;
-err:
-	dev_dbg(&i2c->dev, "%s: failed=%d\n", __func__, ret);
-	kfree(priv);
-	return NULL;
-}
-EXPORT_SYMBOL(rtl2830_attach);
-
 static struct dvb_frontend_ops rtl2830_ops = {
 	.delsys = { SYS_DVBT },
 	.info = {
@@ -750,8 +652,6 @@ static struct dvb_frontend_ops rtl2830_ops = {
 			FE_CAN_MUTE_TS
 	},
 
-	.release = rtl2830_release,
-
 	.init = rtl2830_init,
 	.sleep = rtl2830_sleep,
 
@@ -888,7 +788,6 @@ static int rtl2830_probe(struct i2c_client *client,
 
 	/* create dvb frontend */
 	memcpy(&priv->fe.ops, &rtl2830_ops, sizeof(priv->fe.ops));
-	priv->fe.ops.release = NULL;
 	priv->fe.demodulator_priv = priv;
 
 	/* setup callbacks */

commit 28c08799390befbf0821ad6dcc3a38ade454cef9
Author: Antti Palosaari <crope@iki.fi>
Date:   Sun Dec 7 04:07:29 2014 -0300

    [media] rtl2830: convert driver to kernel I2C model
    
    Convert driver to kernel I2C model. Old DVB proprietary model is
    still left there also.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/rtl2830.c b/drivers/media/dvb-frontends/rtl2830.c
index 50e8b63e5169..ec4a19c63090 100644
--- a/drivers/media/dvb-frontends/rtl2830.c
+++ b/drivers/media/dvb-frontends/rtl2830.c
@@ -767,6 +767,173 @@ static struct dvb_frontend_ops rtl2830_ops = {
 	.read_signal_strength = rtl2830_read_signal_strength,
 };
 
+/*
+ * I2C gate/repeater logic
+ * We must use unlocked i2c_transfer() here because I2C lock is already taken
+ * by tuner driver. Gate is closed automatically after single I2C xfer.
+ */
+static int rtl2830_select(struct i2c_adapter *adap, void *mux_priv, u32 chan_id)
+{
+	struct i2c_client *client = mux_priv;
+	struct rtl2830_priv *priv = i2c_get_clientdata(client);
+	struct i2c_msg select_reg_page_msg[1] = {
+		{
+			.addr = priv->cfg.i2c_addr,
+			.flags = 0,
+			.len = 2,
+			.buf = "\x00\x01",
+		}
+	};
+	struct i2c_msg gate_open_msg[1] = {
+		{
+			.addr = priv->cfg.i2c_addr,
+			.flags = 0,
+			.len = 2,
+			.buf = "\x01\x08",
+		}
+	};
+	int ret;
+
+	/* select register page */
+	ret = __i2c_transfer(adap, select_reg_page_msg, 1);
+	if (ret != 1) {
+		dev_warn(&client->dev, "i2c write failed %d\n", ret);
+		if (ret >= 0)
+			ret = -EREMOTEIO;
+		goto err;
+	}
+
+	priv->page = 1;
+
+	/* open tuner I2C repeater for 1 xfer, closes automatically */
+	ret = __i2c_transfer(adap, gate_open_msg, 1);
+	if (ret != 1) {
+		dev_warn(&client->dev, "i2c write failed %d\n", ret);
+		if (ret >= 0)
+			ret = -EREMOTEIO;
+		goto err;
+	}
+
+	return 0;
+
+err:
+	dev_dbg(&client->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+
+static struct dvb_frontend *rtl2830_get_dvb_frontend(struct i2c_client *client)
+{
+	struct rtl2830_priv *priv = i2c_get_clientdata(client);
+
+	dev_dbg(&client->dev, "\n");
+
+	return &priv->fe;
+}
+
+static struct i2c_adapter *rtl2830_get_i2c_adapter(struct i2c_client *client)
+{
+	struct rtl2830_priv *priv = i2c_get_clientdata(client);
+
+	dev_dbg(&client->dev, "\n");
+
+	return priv->adapter;
+}
+
+static int rtl2830_probe(struct i2c_client *client,
+		const struct i2c_device_id *id)
+{
+	struct rtl2830_platform_data *pdata = client->dev.platform_data;
+	struct i2c_adapter *i2c = client->adapter;
+	struct rtl2830_priv *priv;
+	int ret;
+	u8 u8tmp;
+
+	dev_dbg(&client->dev, "\n");
+
+	if (pdata == NULL) {
+		ret = -EINVAL;
+		goto err;
+	}
+
+	/* allocate memory for the internal state */
+	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
+	if (priv == NULL) {
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	/* setup the state */
+	i2c_set_clientdata(client, priv);
+	priv->i2c = i2c;
+	priv->sleeping = true;
+	priv->cfg.i2c_addr = client->addr;
+	priv->cfg.xtal = pdata->clk;
+	priv->cfg.spec_inv = pdata->spec_inv;
+	priv->cfg.vtop = pdata->vtop;
+	priv->cfg.krf = pdata->krf;
+	priv->cfg.agc_targ_val = pdata->agc_targ_val;
+
+	/* check if the demod is there */
+	ret = rtl2830_rd_reg(priv, 0x000, &u8tmp);
+	if (ret)
+		goto err_kfree;
+
+	/* create muxed i2c adapter for tuner */
+	priv->adapter = i2c_add_mux_adapter(client->adapter, &client->dev,
+			client, 0, 0, 0, rtl2830_select, NULL);
+	if (priv->adapter == NULL) {
+		ret = -ENODEV;
+		goto err_kfree;
+	}
+
+	/* create dvb frontend */
+	memcpy(&priv->fe.ops, &rtl2830_ops, sizeof(priv->fe.ops));
+	priv->fe.ops.release = NULL;
+	priv->fe.demodulator_priv = priv;
+
+	/* setup callbacks */
+	pdata->get_dvb_frontend = rtl2830_get_dvb_frontend;
+	pdata->get_i2c_adapter = rtl2830_get_i2c_adapter;
+
+	dev_info(&client->dev, "Realtek RTL2830 successfully attached\n");
+	return 0;
+
+err_kfree:
+	kfree(priv);
+err:
+	dev_dbg(&client->dev, "failed=%d\n", ret);
+	return ret;
+}
+
+static int rtl2830_remove(struct i2c_client *client)
+{
+	struct rtl2830_priv *priv = i2c_get_clientdata(client);
+
+	dev_dbg(&client->dev, "\n");
+
+	i2c_del_mux_adapter(priv->adapter);
+	kfree(priv);
+	return 0;
+}
+
+static const struct i2c_device_id rtl2830_id_table[] = {
+	{"rtl2830", 0},
+	{}
+};
+MODULE_DEVICE_TABLE(i2c, rtl2830_id_table);
+
+static struct i2c_driver rtl2830_driver = {
+	.driver = {
+		.owner	= THIS_MODULE,
+		.name	= "rtl2830",
+	},
+	.probe		= rtl2830_probe,
+	.remove		= rtl2830_remove,
+	.id_table	= rtl2830_id_table,
+};
+
+module_i2c_driver(rtl2830_driver);
+
 MODULE_AUTHOR("Antti Palosaari <crope@iki.fi>");
 MODULE_DESCRIPTION("Realtek RTL2830 DVB-T demodulator driver");
 MODULE_LICENSE("GPL");

commit eed5b0cfb4f1ac0715106b79b24f19fad6000416
Author: Antti Palosaari <crope@iki.fi>
Date:   Mon Oct 21 16:56:36 2013 -0300

    [media] rtl2830: add parent for I2C adapter
    
    i2c i2c-6: adapter [RTL2830 tuner I2C adapter] registered
    BUG: unable to handle kernel NULL pointer dereference at 0000000000000220
    IP: [<ffffffffa0002900>] i2c_register_adapter+0x130/0x390 [i2c_core]
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/dvb-frontends/rtl2830.c b/drivers/media/dvb-frontends/rtl2830.c
index 7efb796c472c..50e8b63e5169 100644
--- a/drivers/media/dvb-frontends/rtl2830.c
+++ b/drivers/media/dvb-frontends/rtl2830.c
@@ -710,6 +710,7 @@ struct dvb_frontend *rtl2830_attach(const struct rtl2830_config *cfg,
 		sizeof(priv->tuner_i2c_adapter.name));
 	priv->tuner_i2c_adapter.algo = &rtl2830_tuner_i2c_algo;
 	priv->tuner_i2c_adapter.algo_data = NULL;
+	priv->tuner_i2c_adapter.dev.parent = &i2c->dev;
 	i2c_set_adapdata(&priv->tuner_i2c_adapter, priv);
 	if (i2c_add_adapter(&priv->tuner_i2c_adapter) < 0) {
 		dev_err(&i2c->dev,

commit 37ebaf6891ee81687bb558e8375c0712d8264ed8
Author: Mauro Carvalho Chehab <m.chehab@samsung.com>
Date:   Sat Nov 2 05:11:47 2013 -0300

    [media] dvb-frontends: Don't use dynamic static allocation
    
    Dynamic static allocation is evil, as Kernel stack is too low, and
    compilation complains about it on some archs:
            drivers/media/dvb-frontends/af9013.c:77:1: warning: 'af9013_wr_regs_i2c' uses dynamic stack allocation [enabled by default]
            drivers/media/dvb-frontends/af9033.c:188:1: warning: 'af9033_wr_reg_val_tab' uses dynamic stack allocation [enabled by default]
            drivers/media/dvb-frontends/af9033.c:68:1: warning: 'af9033_wr_regs' uses dynamic stack allocation [enabled by default]
            drivers/media/dvb-frontends/bcm3510.c:230:1: warning: 'bcm3510_do_hab_cmd' uses dynamic stack allocation [enabled by default]
            drivers/media/dvb-frontends/cxd2820r_core.c:84:1: warning: 'cxd2820r_rd_regs_i2c.isra.1' uses dynamic stack allocation [enabled by default]
            drivers/media/dvb-frontends/rtl2830.c:56:1: warning: 'rtl2830_wr' uses dynamic stack allocation [enabled by default]
            drivers/media/dvb-frontends/rtl2832.c:187:1: warning: 'rtl2832_wr' uses dynamic stack allocation [enabled by default]
            drivers/media/dvb-frontends/tda10071.c:52:1: warning: 'tda10071_wr_regs' uses dynamic stack allocation [enabled by default]
            drivers/media/dvb-frontends/tda10071.c:84:1: warning: 'tda10071_rd_regs' uses dynamic stack allocation [enabled by default]
    Instead, let's enforce a limit for the buffer. Considering that I2C
    transfers are generally limited, and that devices used on USB has a
    max data length of 64 bytes for the control URBs.
    So, it seem safe to use 64 bytes as the hard limit for all those devices.
     On most cases, the limit is a way lower than that, but this limit
    is small enough to not affect the Kernel stack, and it is a no brain
    limit, as using smaller ones would require to either carefully each
    driver or to take a look on each datasheet.
    
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>
    Reviewed-by: Hans Verkuil <hans.verkuil@cisco.com>
    Reviewed-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/drivers/media/dvb-frontends/rtl2830.c b/drivers/media/dvb-frontends/rtl2830.c
index 362d26d11e82..7efb796c472c 100644
--- a/drivers/media/dvb-frontends/rtl2830.c
+++ b/drivers/media/dvb-frontends/rtl2830.c
@@ -27,20 +27,30 @@
 
 #include "rtl2830_priv.h"
 
+/* Max transfer size done by I2C transfer functions */
+#define MAX_XFER_SIZE  64
+
 /* write multiple hardware registers */
 static int rtl2830_wr(struct rtl2830_priv *priv, u8 reg, const u8 *val, int len)
 {
 	int ret;
-	u8 buf[1+len];
+	u8 buf[MAX_XFER_SIZE];
 	struct i2c_msg msg[1] = {
 		{
 			.addr = priv->cfg.i2c_addr,
 			.flags = 0,
-			.len = 1+len,
+			.len = 1 + len,
 			.buf = buf,
 		}
 	};
 
+	if (1 + len > sizeof(buf)) {
+		dev_warn(&priv->i2c->dev,
+			 "%s: i2c wr reg=%04x: len=%d is too big!\n",
+			 KBUILD_MODNAME, reg, len);
+		return -EINVAL;
+	}
+
 	buf[0] = reg;
 	memcpy(&buf[1], val, len);
 

commit a17ff2eed6812eff319a4a74854db55298319bbe
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Sat Oct 27 11:24:08 2012 -0300

    [media] rtl2830.c: get rid of warning: no previous prototype
    
    drivers/media/dvb-frontends/rtl2830.c:133:5: warning: no previous prototype for 'rtl2830_wr_reg_mask' [-Wmissing-prototypes]
    drivers/media/dvb-frontends/rtl2830.c:153:5: warning: no previous prototype for 'rtl2830_rd_reg_mask' [-Wmissing-prototypes]
    drivers/media/dvb-frontends/rtl2830.c:259:5: warning: no previous prototype for 'rtl2830_get_tune_settings' [-Wmissing-prototypes]
    
    Cc: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/dvb-frontends/rtl2830.c b/drivers/media/dvb-frontends/rtl2830.c
index b0f6ec03d1eb..362d26d11e82 100644
--- a/drivers/media/dvb-frontends/rtl2830.c
+++ b/drivers/media/dvb-frontends/rtl2830.c
@@ -130,7 +130,7 @@ static int rtl2830_rd_reg(struct rtl2830_priv *priv, u16 reg, u8 *val)
 }
 
 /* write single register with mask */
-int rtl2830_wr_reg_mask(struct rtl2830_priv *priv, u16 reg, u8 val, u8 mask)
+static int rtl2830_wr_reg_mask(struct rtl2830_priv *priv, u16 reg, u8 val, u8 mask)
 {
 	int ret;
 	u8 tmp;
@@ -150,7 +150,7 @@ int rtl2830_wr_reg_mask(struct rtl2830_priv *priv, u16 reg, u8 val, u8 mask)
 }
 
 /* read single register with mask */
-int rtl2830_rd_reg_mask(struct rtl2830_priv *priv, u16 reg, u8 *val, u8 mask)
+static int rtl2830_rd_reg_mask(struct rtl2830_priv *priv, u16 reg, u8 *val, u8 mask)
 {
 	int ret, i;
 	u8 tmp;
@@ -256,7 +256,7 @@ static int rtl2830_sleep(struct dvb_frontend *fe)
 	return 0;
 }
 
-int rtl2830_get_tune_settings(struct dvb_frontend *fe,
+static int rtl2830_get_tune_settings(struct dvb_frontend *fe,
 	struct dvb_frontend_tune_settings *s)
 {
 	s->min_delay_ms = 500;

commit 3a2fca2684bd8730a270197d231d8d023d759d3f
Author: Antti Palosaari <crope@iki.fi>
Date:   Wed Sep 12 20:23:49 2012 -0300

    [media] rtl2830: declare two tables as constant
    
    This optimizes few hundred bytes from data to text segment.
    Also remove one unused function that was commented out already.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/dvb-frontends/rtl2830.c b/drivers/media/dvb-frontends/rtl2830.c
index 3954760f2bde..b0f6ec03d1eb 100644
--- a/drivers/media/dvb-frontends/rtl2830.c
+++ b/drivers/media/dvb-frontends/rtl2830.c
@@ -28,7 +28,7 @@
 #include "rtl2830_priv.h"
 
 /* write multiple hardware registers */
-static int rtl2830_wr(struct rtl2830_priv *priv, u8 reg, u8 *val, int len)
+static int rtl2830_wr(struct rtl2830_priv *priv, u8 reg, const u8 *val, int len)
 {
 	int ret;
 	u8 buf[1+len];
@@ -85,7 +85,8 @@ static int rtl2830_rd(struct rtl2830_priv *priv, u8 reg, u8 *val, int len)
 }
 
 /* write multiple registers */
-static int rtl2830_wr_regs(struct rtl2830_priv *priv, u16 reg, u8 *val, int len)
+static int rtl2830_wr_regs(struct rtl2830_priv *priv, u16 reg, const u8 *val,
+		int len)
 {
 	int ret;
 	u8 reg2 = (reg >> 0) & 0xff;
@@ -122,14 +123,6 @@ static int rtl2830_rd_regs(struct rtl2830_priv *priv, u16 reg, u8 *val, int len)
 	return rtl2830_rd(priv, reg2, val, len);
 }
 
-#if 0 /* currently not used */
-/* write single register */
-static int rtl2830_wr_reg(struct rtl2830_priv *priv, u16 reg, u8 val)
-{
-	return rtl2830_wr_regs(priv, reg, &val, 1);
-}
-#endif
-
 /* read single register */
 static int rtl2830_rd_reg(struct rtl2830_priv *priv, u16 reg, u8 *val)
 {
@@ -281,7 +274,7 @@ static int rtl2830_set_frontend(struct dvb_frontend *fe)
 	u64 num;
 	u8 buf[3], tmp;
 	u32 if_ctl, if_frequency;
-	static u8 bw_params1[3][34] = {
+	static const u8 bw_params1[3][34] = {
 		{
 		0x1f, 0xf0, 0x1f, 0xf0, 0x1f, 0xfa, 0x00, 0x17, 0x00, 0x41,
 		0x00, 0x64, 0x00, 0x67, 0x00, 0x38, 0x1f, 0xde, 0x1f, 0x7a,
@@ -299,10 +292,10 @@ static int rtl2830_set_frontend(struct dvb_frontend *fe)
 		0x04, 0x24, 0x04, 0xdb, /* 8 MHz */
 		},
 	};
-	static u8 bw_params2[3][6] = {
-		{0xc3, 0x0c, 0x44, 0x33, 0x33, 0x30,}, /* 6 MHz */
-		{0xb8, 0xe3, 0x93, 0x99, 0x99, 0x98,}, /* 7 MHz */
-		{0xae, 0xba, 0xf3, 0x26, 0x66, 0x64,}, /* 8 MHz */
+	static const u8 bw_params2[3][6] = {
+		{0xc3, 0x0c, 0x44, 0x33, 0x33, 0x30}, /* 6 MHz */
+		{0xb8, 0xe3, 0x93, 0x99, 0x99, 0x98}, /* 7 MHz */
+		{0xae, 0xba, 0xf3, 0x26, 0x66, 0x64}, /* 8 MHz */
 	};
 
 	dev_dbg(&priv->i2c->dev,

commit 66b3c4deb9735e18d5b71dbcbf9532bdf080d001
Author: Antti Palosaari <crope@iki.fi>
Date:   Wed Sep 12 20:23:48 2012 -0300

    [media] rtl2830: use .get_if_frequency()
    
    Use .get_if_frequency() as all used tuner drivers
    (mt2060/qt1010/mxl5005s) supports it.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/dvb-frontends/rtl2830.c b/drivers/media/dvb-frontends/rtl2830.c
index eca1d72f0684..3954760f2bde 100644
--- a/drivers/media/dvb-frontends/rtl2830.c
+++ b/drivers/media/dvb-frontends/rtl2830.c
@@ -182,9 +182,6 @@ static int rtl2830_init(struct dvb_frontend *fe)
 {
 	struct rtl2830_priv *priv = fe->demodulator_priv;
 	int ret, i;
-	u64 num;
-	u8 buf[3], tmp;
-	u32 if_ctl;
 	struct rtl2830_reg_val_mask tab[] = {
 		{ 0x00d, 0x01, 0x03 },
 		{ 0x00d, 0x10, 0x10 },
@@ -240,26 +237,6 @@ static int rtl2830_init(struct dvb_frontend *fe)
 	if (ret)
 		goto err;
 
-	num = priv->cfg.if_dvbt % priv->cfg.xtal;
-	num *= 0x400000;
-	num = div_u64(num, priv->cfg.xtal);
-	num = -num;
-	if_ctl = num & 0x3fffff;
-	dev_dbg(&priv->i2c->dev, "%s: if_ctl=%08x\n", __func__, if_ctl);
-
-	ret = rtl2830_rd_reg_mask(priv, 0x119, &tmp, 0xc0); /* b[7:6] */
-	if (ret)
-		goto err;
-
-	buf[0] = tmp << 6;
-	buf[0] = (if_ctl >> 16) & 0x3f;
-	buf[1] = (if_ctl >>  8) & 0xff;
-	buf[2] = (if_ctl >>  0) & 0xff;
-
-	ret = rtl2830_wr_regs(priv, 0x119, buf, 3);
-	if (ret)
-		goto err;
-
 	/* TODO: spec init */
 
 	/* soft reset */
@@ -301,6 +278,9 @@ static int rtl2830_set_frontend(struct dvb_frontend *fe)
 	struct rtl2830_priv *priv = fe->demodulator_priv;
 	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
 	int ret, i;
+	u64 num;
+	u8 buf[3], tmp;
+	u32 if_ctl, if_frequency;
 	static u8 bw_params1[3][34] = {
 		{
 		0x1f, 0xf0, 0x1f, 0xf0, 0x1f, 0xfa, 0x00, 0x17, 0x00, 0x41,
@@ -325,7 +305,6 @@ static int rtl2830_set_frontend(struct dvb_frontend *fe)
 		{0xae, 0xba, 0xf3, 0x26, 0x66, 0x64,}, /* 8 MHz */
 	};
 
-
 	dev_dbg(&priv->i2c->dev,
 			"%s: frequency=%d bandwidth_hz=%d inversion=%d\n",
 			__func__, c->frequency, c->bandwidth_hz, c->inversion);
@@ -353,6 +332,36 @@ static int rtl2830_set_frontend(struct dvb_frontend *fe)
 	if (ret)
 		goto err;
 
+	/* program if frequency */
+	if (fe->ops.tuner_ops.get_if_frequency)
+		ret = fe->ops.tuner_ops.get_if_frequency(fe, &if_frequency);
+	else
+		ret = -EINVAL;
+
+	if (ret < 0)
+		goto err;
+
+	num = if_frequency % priv->cfg.xtal;
+	num *= 0x400000;
+	num = div_u64(num, priv->cfg.xtal);
+	num = -num;
+	if_ctl = num & 0x3fffff;
+	dev_dbg(&priv->i2c->dev, "%s: if_frequency=%d if_ctl=%08x\n",
+			__func__, if_frequency, if_ctl);
+
+	ret = rtl2830_rd_reg_mask(priv, 0x119, &tmp, 0xc0); /* b[7:6] */
+	if (ret)
+		goto err;
+
+	buf[0] = tmp << 6;
+	buf[0] |= (if_ctl >> 16) & 0x3f;
+	buf[1] = (if_ctl >>  8) & 0xff;
+	buf[2] = (if_ctl >>  0) & 0xff;
+
+	ret = rtl2830_wr_regs(priv, 0x119, buf, 3);
+	if (ret)
+		goto err;
+
 	/* 1/2 split I2C write */
 	ret = rtl2830_wr_regs(priv, 0x11c, &bw_params1[i][0], 17);
 	if (ret)

commit 86ad0f1dd72b39159065fdf089afe0913b9bef41
Author: Antti Palosaari <crope@iki.fi>
Date:   Wed Sep 12 20:23:47 2012 -0300

    [media] rtl2830: use Kernel dev_foo() logging
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/dvb-frontends/rtl2830.c b/drivers/media/dvb-frontends/rtl2830.c
index 8fa8b0854e76..eca1d72f0684 100644
--- a/drivers/media/dvb-frontends/rtl2830.c
+++ b/drivers/media/dvb-frontends/rtl2830.c
@@ -27,10 +27,6 @@
 
 #include "rtl2830_priv.h"
 
-int rtl2830_debug;
-module_param_named(debug, rtl2830_debug, int, 0644);
-MODULE_PARM_DESC(debug, "Turn on/off frontend debugging (default:off).");
-
 /* write multiple hardware registers */
 static int rtl2830_wr(struct rtl2830_priv *priv, u8 reg, u8 *val, int len)
 {
@@ -52,7 +48,8 @@ static int rtl2830_wr(struct rtl2830_priv *priv, u8 reg, u8 *val, int len)
 	if (ret == 1) {
 		ret = 0;
 	} else {
-		warn("i2c wr failed=%d reg=%02x len=%d", ret, reg, len);
+		dev_warn(&priv->i2c->dev, "%s: i2c wr failed=%d reg=%02x " \
+				"len=%d\n", KBUILD_MODNAME, ret, reg, len);
 		ret = -EREMOTEIO;
 	}
 	return ret;
@@ -80,7 +77,8 @@ static int rtl2830_rd(struct rtl2830_priv *priv, u8 reg, u8 *val, int len)
 	if (ret == 2) {
 		ret = 0;
 	} else {
-		warn("i2c rd failed=%d reg=%02x len=%d", ret, reg, len);
+		dev_warn(&priv->i2c->dev, "%s: i2c rd failed=%d reg=%02x " \
+				"len=%d\n", KBUILD_MODNAME, ret, reg, len);
 		ret = -EREMOTEIO;
 	}
 	return ret;
@@ -247,7 +245,7 @@ static int rtl2830_init(struct dvb_frontend *fe)
 	num = div_u64(num, priv->cfg.xtal);
 	num = -num;
 	if_ctl = num & 0x3fffff;
-	dbg("%s: if_ctl=%08x", __func__, if_ctl);
+	dev_dbg(&priv->i2c->dev, "%s: if_ctl=%08x\n", __func__, if_ctl);
 
 	ret = rtl2830_rd_reg_mask(priv, 0x119, &tmp, 0xc0); /* b[7:6] */
 	if (ret)
@@ -277,7 +275,7 @@ static int rtl2830_init(struct dvb_frontend *fe)
 
 	return ret;
 err:
-	dbg("%s: failed=%d", __func__, ret);
+	dev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);
 	return ret;
 }
 
@@ -328,8 +326,9 @@ static int rtl2830_set_frontend(struct dvb_frontend *fe)
 	};
 
 
-	dbg("%s: frequency=%d bandwidth_hz=%d inversion=%d", __func__,
-		c->frequency, c->bandwidth_hz, c->inversion);
+	dev_dbg(&priv->i2c->dev,
+			"%s: frequency=%d bandwidth_hz=%d inversion=%d\n",
+			__func__, c->frequency, c->bandwidth_hz, c->inversion);
 
 	/* program tuner */
 	if (fe->ops.tuner_ops.set_params)
@@ -346,7 +345,7 @@ static int rtl2830_set_frontend(struct dvb_frontend *fe)
 		i = 2;
 		break;
 	default:
-		dbg("invalid bandwidth");
+		dev_dbg(&priv->i2c->dev, "%s: invalid bandwidth\n", __func__);
 		return -EINVAL;
 	}
 
@@ -370,7 +369,7 @@ static int rtl2830_set_frontend(struct dvb_frontend *fe)
 
 	return ret;
 err:
-	dbg("%s: failed=%d", __func__, ret);
+	dev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);
 	return ret;
 }
 
@@ -392,7 +391,7 @@ static int rtl2830_get_frontend(struct dvb_frontend *fe)
 	if (ret)
 		goto err;
 
-	dbg("%s: TPS=%*ph", __func__, 3, buf);
+	dev_dbg(&priv->i2c->dev, "%s: TPS=%*ph\n", __func__, 3, buf);
 
 	switch ((buf[0] >> 2) & 3) {
 	case 0:
@@ -482,7 +481,7 @@ static int rtl2830_get_frontend(struct dvb_frontend *fe)
 
 	return 0;
 err:
-	dbg("%s: failed=%d", __func__, ret);
+	dev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);
 	return ret;
 }
 
@@ -510,7 +509,7 @@ static int rtl2830_read_status(struct dvb_frontend *fe, fe_status_t *status)
 
 	return ret;
 err:
-	dbg("%s: failed=%d", __func__, ret);
+	dev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);
 	return ret;
 }
 
@@ -559,7 +558,7 @@ static int rtl2830_read_snr(struct dvb_frontend *fe, u16 *snr)
 
 	return 0;
 err:
-	dbg("%s: failed=%d", __func__, ret);
+	dev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);
 	return ret;
 }
 
@@ -580,7 +579,7 @@ static int rtl2830_read_ber(struct dvb_frontend *fe, u32 *ber)
 
 	return 0;
 err:
-	dbg("%s: failed=%d", __func__, ret);
+	dev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);
 	return ret;
 }
 
@@ -616,7 +615,7 @@ static int rtl2830_read_signal_strength(struct dvb_frontend *fe, u16 *strength)
 
 	return 0;
 err:
-	dbg("%s: failed=%d", __func__, ret);
+	dev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);
 	return ret;
 }
 
@@ -640,11 +639,12 @@ static int rtl2830_tuner_i2c_xfer(struct i2c_adapter *i2c_adap,
 
 	ret = i2c_transfer(priv->i2c, msg, num);
 	if (ret < 0)
-		warn("tuner i2c failed=%d", ret);
+		dev_warn(&priv->i2c->dev, "%s: tuner i2c failed=%d\n",
+			KBUILD_MODNAME, ret);
 
 	return ret;
 err:
-	dbg("%s: failed=%d", __func__, ret);
+	dev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);
 	return ret;
 }
 
@@ -700,7 +700,9 @@ struct dvb_frontend *rtl2830_attach(const struct rtl2830_config *cfg,
 	priv->tuner_i2c_adapter.algo_data = NULL;
 	i2c_set_adapdata(&priv->tuner_i2c_adapter, priv);
 	if (i2c_add_adapter(&priv->tuner_i2c_adapter) < 0) {
-		err("tuner I2C bus could not be initialized");
+		dev_err(&i2c->dev,
+				"%s: tuner i2c bus could not be initialized\n",
+				KBUILD_MODNAME);
 		goto err;
 	}
 
@@ -708,7 +710,7 @@ struct dvb_frontend *rtl2830_attach(const struct rtl2830_config *cfg,
 
 	return &priv->fe;
 err:
-	dbg("%s: failed=%d", __func__, ret);
+	dev_dbg(&i2c->dev, "%s: failed=%d\n", __func__, ret);
 	kfree(priv);
 	return NULL;
 }

commit 9a0bf528b4d66b605f02634236da085595c22101
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Mon Aug 13 23:13:41 2012 -0300

    [media] move the dvb/frontends to drivers/media/dvb-frontends
    
    Raise the DVB frontends one level up, as the intention is to remove
    the drivers/media/dvb directory.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/dvb-frontends/rtl2830.c b/drivers/media/dvb-frontends/rtl2830.c
new file mode 100644
index 000000000000..8fa8b0854e76
--- /dev/null
+++ b/drivers/media/dvb-frontends/rtl2830.c
@@ -0,0 +1,757 @@
+/*
+ * Realtek RTL2830 DVB-T demodulator driver
+ *
+ * Copyright (C) 2011 Antti Palosaari <crope@iki.fi>
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License along
+ *    with this program; if not, write to the Free Software Foundation, Inc.,
+ *    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+
+/*
+ * Driver implements own I2C-adapter for tuner I2C access. That's since chip
+ * have unusual I2C-gate control which closes gate automatically after each
+ * I2C transfer. Using own I2C adapter we can workaround that.
+ */
+
+#include "rtl2830_priv.h"
+
+int rtl2830_debug;
+module_param_named(debug, rtl2830_debug, int, 0644);
+MODULE_PARM_DESC(debug, "Turn on/off frontend debugging (default:off).");
+
+/* write multiple hardware registers */
+static int rtl2830_wr(struct rtl2830_priv *priv, u8 reg, u8 *val, int len)
+{
+	int ret;
+	u8 buf[1+len];
+	struct i2c_msg msg[1] = {
+		{
+			.addr = priv->cfg.i2c_addr,
+			.flags = 0,
+			.len = 1+len,
+			.buf = buf,
+		}
+	};
+
+	buf[0] = reg;
+	memcpy(&buf[1], val, len);
+
+	ret = i2c_transfer(priv->i2c, msg, 1);
+	if (ret == 1) {
+		ret = 0;
+	} else {
+		warn("i2c wr failed=%d reg=%02x len=%d", ret, reg, len);
+		ret = -EREMOTEIO;
+	}
+	return ret;
+}
+
+/* read multiple hardware registers */
+static int rtl2830_rd(struct rtl2830_priv *priv, u8 reg, u8 *val, int len)
+{
+	int ret;
+	struct i2c_msg msg[2] = {
+		{
+			.addr = priv->cfg.i2c_addr,
+			.flags = 0,
+			.len = 1,
+			.buf = &reg,
+		}, {
+			.addr = priv->cfg.i2c_addr,
+			.flags = I2C_M_RD,
+			.len = len,
+			.buf = val,
+		}
+	};
+
+	ret = i2c_transfer(priv->i2c, msg, 2);
+	if (ret == 2) {
+		ret = 0;
+	} else {
+		warn("i2c rd failed=%d reg=%02x len=%d", ret, reg, len);
+		ret = -EREMOTEIO;
+	}
+	return ret;
+}
+
+/* write multiple registers */
+static int rtl2830_wr_regs(struct rtl2830_priv *priv, u16 reg, u8 *val, int len)
+{
+	int ret;
+	u8 reg2 = (reg >> 0) & 0xff;
+	u8 page = (reg >> 8) & 0xff;
+
+	/* switch bank if needed */
+	if (page != priv->page) {
+		ret = rtl2830_wr(priv, 0x00, &page, 1);
+		if (ret)
+			return ret;
+
+		priv->page = page;
+	}
+
+	return rtl2830_wr(priv, reg2, val, len);
+}
+
+/* read multiple registers */
+static int rtl2830_rd_regs(struct rtl2830_priv *priv, u16 reg, u8 *val, int len)
+{
+	int ret;
+	u8 reg2 = (reg >> 0) & 0xff;
+	u8 page = (reg >> 8) & 0xff;
+
+	/* switch bank if needed */
+	if (page != priv->page) {
+		ret = rtl2830_wr(priv, 0x00, &page, 1);
+		if (ret)
+			return ret;
+
+		priv->page = page;
+	}
+
+	return rtl2830_rd(priv, reg2, val, len);
+}
+
+#if 0 /* currently not used */
+/* write single register */
+static int rtl2830_wr_reg(struct rtl2830_priv *priv, u16 reg, u8 val)
+{
+	return rtl2830_wr_regs(priv, reg, &val, 1);
+}
+#endif
+
+/* read single register */
+static int rtl2830_rd_reg(struct rtl2830_priv *priv, u16 reg, u8 *val)
+{
+	return rtl2830_rd_regs(priv, reg, val, 1);
+}
+
+/* write single register with mask */
+int rtl2830_wr_reg_mask(struct rtl2830_priv *priv, u16 reg, u8 val, u8 mask)
+{
+	int ret;
+	u8 tmp;
+
+	/* no need for read if whole reg is written */
+	if (mask != 0xff) {
+		ret = rtl2830_rd_regs(priv, reg, &tmp, 1);
+		if (ret)
+			return ret;
+
+		val &= mask;
+		tmp &= ~mask;
+		val |= tmp;
+	}
+
+	return rtl2830_wr_regs(priv, reg, &val, 1);
+}
+
+/* read single register with mask */
+int rtl2830_rd_reg_mask(struct rtl2830_priv *priv, u16 reg, u8 *val, u8 mask)
+{
+	int ret, i;
+	u8 tmp;
+
+	ret = rtl2830_rd_regs(priv, reg, &tmp, 1);
+	if (ret)
+		return ret;
+
+	tmp &= mask;
+
+	/* find position of the first bit */
+	for (i = 0; i < 8; i++) {
+		if ((mask >> i) & 0x01)
+			break;
+	}
+	*val = tmp >> i;
+
+	return 0;
+}
+
+static int rtl2830_init(struct dvb_frontend *fe)
+{
+	struct rtl2830_priv *priv = fe->demodulator_priv;
+	int ret, i;
+	u64 num;
+	u8 buf[3], tmp;
+	u32 if_ctl;
+	struct rtl2830_reg_val_mask tab[] = {
+		{ 0x00d, 0x01, 0x03 },
+		{ 0x00d, 0x10, 0x10 },
+		{ 0x104, 0x00, 0x1e },
+		{ 0x105, 0x80, 0x80 },
+		{ 0x110, 0x02, 0x03 },
+		{ 0x110, 0x08, 0x0c },
+		{ 0x17b, 0x00, 0x40 },
+		{ 0x17d, 0x05, 0x0f },
+		{ 0x17d, 0x50, 0xf0 },
+		{ 0x18c, 0x08, 0x0f },
+		{ 0x18d, 0x00, 0xc0 },
+		{ 0x188, 0x05, 0x0f },
+		{ 0x189, 0x00, 0xfc },
+		{ 0x2d5, 0x02, 0x02 },
+		{ 0x2f1, 0x02, 0x06 },
+		{ 0x2f1, 0x20, 0xf8 },
+		{ 0x16d, 0x00, 0x01 },
+		{ 0x1a6, 0x00, 0x80 },
+		{ 0x106, priv->cfg.vtop, 0x3f },
+		{ 0x107, priv->cfg.krf, 0x3f },
+		{ 0x112, 0x28, 0xff },
+		{ 0x103, priv->cfg.agc_targ_val, 0xff },
+		{ 0x00a, 0x02, 0x07 },
+		{ 0x140, 0x0c, 0x3c },
+		{ 0x140, 0x40, 0xc0 },
+		{ 0x15b, 0x05, 0x07 },
+		{ 0x15b, 0x28, 0x38 },
+		{ 0x15c, 0x05, 0x07 },
+		{ 0x15c, 0x28, 0x38 },
+		{ 0x115, priv->cfg.spec_inv, 0x01 },
+		{ 0x16f, 0x01, 0x07 },
+		{ 0x170, 0x18, 0x38 },
+		{ 0x172, 0x0f, 0x0f },
+		{ 0x173, 0x08, 0x38 },
+		{ 0x175, 0x01, 0x07 },
+		{ 0x176, 0x00, 0xc0 },
+	};
+
+	for (i = 0; i < ARRAY_SIZE(tab); i++) {
+		ret = rtl2830_wr_reg_mask(priv, tab[i].reg, tab[i].val,
+			tab[i].mask);
+		if (ret)
+			goto err;
+	}
+
+	ret = rtl2830_wr_regs(priv, 0x18f, "\x28\x00", 2);
+	if (ret)
+		goto err;
+
+	ret = rtl2830_wr_regs(priv, 0x195,
+		"\x04\x06\x0a\x12\x0a\x12\x1e\x28", 8);
+	if (ret)
+		goto err;
+
+	num = priv->cfg.if_dvbt % priv->cfg.xtal;
+	num *= 0x400000;
+	num = div_u64(num, priv->cfg.xtal);
+	num = -num;
+	if_ctl = num & 0x3fffff;
+	dbg("%s: if_ctl=%08x", __func__, if_ctl);
+
+	ret = rtl2830_rd_reg_mask(priv, 0x119, &tmp, 0xc0); /* b[7:6] */
+	if (ret)
+		goto err;
+
+	buf[0] = tmp << 6;
+	buf[0] = (if_ctl >> 16) & 0x3f;
+	buf[1] = (if_ctl >>  8) & 0xff;
+	buf[2] = (if_ctl >>  0) & 0xff;
+
+	ret = rtl2830_wr_regs(priv, 0x119, buf, 3);
+	if (ret)
+		goto err;
+
+	/* TODO: spec init */
+
+	/* soft reset */
+	ret = rtl2830_wr_reg_mask(priv, 0x101, 0x04, 0x04);
+	if (ret)
+		goto err;
+
+	ret = rtl2830_wr_reg_mask(priv, 0x101, 0x00, 0x04);
+	if (ret)
+		goto err;
+
+	priv->sleeping = false;
+
+	return ret;
+err:
+	dbg("%s: failed=%d", __func__, ret);
+	return ret;
+}
+
+static int rtl2830_sleep(struct dvb_frontend *fe)
+{
+	struct rtl2830_priv *priv = fe->demodulator_priv;
+	priv->sleeping = true;
+	return 0;
+}
+
+int rtl2830_get_tune_settings(struct dvb_frontend *fe,
+	struct dvb_frontend_tune_settings *s)
+{
+	s->min_delay_ms = 500;
+	s->step_size = fe->ops.info.frequency_stepsize * 2;
+	s->max_drift = (fe->ops.info.frequency_stepsize * 2) + 1;
+
+	return 0;
+}
+
+static int rtl2830_set_frontend(struct dvb_frontend *fe)
+{
+	struct rtl2830_priv *priv = fe->demodulator_priv;
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	int ret, i;
+	static u8 bw_params1[3][34] = {
+		{
+		0x1f, 0xf0, 0x1f, 0xf0, 0x1f, 0xfa, 0x00, 0x17, 0x00, 0x41,
+		0x00, 0x64, 0x00, 0x67, 0x00, 0x38, 0x1f, 0xde, 0x1f, 0x7a,
+		0x1f, 0x47, 0x1f, 0x7c, 0x00, 0x30, 0x01, 0x4b, 0x02, 0x82,
+		0x03, 0x73, 0x03, 0xcf, /* 6 MHz */
+		}, {
+		0x1f, 0xfa, 0x1f, 0xda, 0x1f, 0xc1, 0x1f, 0xb3, 0x1f, 0xca,
+		0x00, 0x07, 0x00, 0x4d, 0x00, 0x6d, 0x00, 0x40, 0x1f, 0xca,
+		0x1f, 0x4d, 0x1f, 0x2a, 0x1f, 0xb2, 0x00, 0xec, 0x02, 0x7e,
+		0x03, 0xd0, 0x04, 0x53, /* 7 MHz */
+		}, {
+		0x00, 0x10, 0x00, 0x0e, 0x1f, 0xf7, 0x1f, 0xc9, 0x1f, 0xa0,
+		0x1f, 0xa6, 0x1f, 0xec, 0x00, 0x4e, 0x00, 0x7d, 0x00, 0x3a,
+		0x1f, 0x98, 0x1f, 0x10, 0x1f, 0x40, 0x00, 0x75, 0x02, 0x5f,
+		0x04, 0x24, 0x04, 0xdb, /* 8 MHz */
+		},
+	};
+	static u8 bw_params2[3][6] = {
+		{0xc3, 0x0c, 0x44, 0x33, 0x33, 0x30,}, /* 6 MHz */
+		{0xb8, 0xe3, 0x93, 0x99, 0x99, 0x98,}, /* 7 MHz */
+		{0xae, 0xba, 0xf3, 0x26, 0x66, 0x64,}, /* 8 MHz */
+	};
+
+
+	dbg("%s: frequency=%d bandwidth_hz=%d inversion=%d", __func__,
+		c->frequency, c->bandwidth_hz, c->inversion);
+
+	/* program tuner */
+	if (fe->ops.tuner_ops.set_params)
+		fe->ops.tuner_ops.set_params(fe);
+
+	switch (c->bandwidth_hz) {
+	case 6000000:
+		i = 0;
+		break;
+	case 7000000:
+		i = 1;
+		break;
+	case 8000000:
+		i = 2;
+		break;
+	default:
+		dbg("invalid bandwidth");
+		return -EINVAL;
+	}
+
+	ret = rtl2830_wr_reg_mask(priv, 0x008, i << 1, 0x06);
+	if (ret)
+		goto err;
+
+	/* 1/2 split I2C write */
+	ret = rtl2830_wr_regs(priv, 0x11c, &bw_params1[i][0], 17);
+	if (ret)
+		goto err;
+
+	/* 2/2 split I2C write */
+	ret = rtl2830_wr_regs(priv, 0x12d, &bw_params1[i][17], 17);
+	if (ret)
+		goto err;
+
+	ret = rtl2830_wr_regs(priv, 0x19d, bw_params2[i], 6);
+	if (ret)
+		goto err;
+
+	return ret;
+err:
+	dbg("%s: failed=%d", __func__, ret);
+	return ret;
+}
+
+static int rtl2830_get_frontend(struct dvb_frontend *fe)
+{
+	struct rtl2830_priv *priv = fe->demodulator_priv;
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	int ret;
+	u8 buf[3];
+
+	if (priv->sleeping)
+		return 0;
+
+	ret = rtl2830_rd_regs(priv, 0x33c, buf, 2);
+	if (ret)
+		goto err;
+
+	ret = rtl2830_rd_reg(priv, 0x351, &buf[2]);
+	if (ret)
+		goto err;
+
+	dbg("%s: TPS=%*ph", __func__, 3, buf);
+
+	switch ((buf[0] >> 2) & 3) {
+	case 0:
+		c->modulation = QPSK;
+		break;
+	case 1:
+		c->modulation = QAM_16;
+		break;
+	case 2:
+		c->modulation = QAM_64;
+		break;
+	}
+
+	switch ((buf[2] >> 2) & 1) {
+	case 0:
+		c->transmission_mode = TRANSMISSION_MODE_2K;
+		break;
+	case 1:
+		c->transmission_mode = TRANSMISSION_MODE_8K;
+	}
+
+	switch ((buf[2] >> 0) & 3) {
+	case 0:
+		c->guard_interval = GUARD_INTERVAL_1_32;
+		break;
+	case 1:
+		c->guard_interval = GUARD_INTERVAL_1_16;
+		break;
+	case 2:
+		c->guard_interval = GUARD_INTERVAL_1_8;
+		break;
+	case 3:
+		c->guard_interval = GUARD_INTERVAL_1_4;
+		break;
+	}
+
+	switch ((buf[0] >> 4) & 7) {
+	case 0:
+		c->hierarchy = HIERARCHY_NONE;
+		break;
+	case 1:
+		c->hierarchy = HIERARCHY_1;
+		break;
+	case 2:
+		c->hierarchy = HIERARCHY_2;
+		break;
+	case 3:
+		c->hierarchy = HIERARCHY_4;
+		break;
+	}
+
+	switch ((buf[1] >> 3) & 7) {
+	case 0:
+		c->code_rate_HP = FEC_1_2;
+		break;
+	case 1:
+		c->code_rate_HP = FEC_2_3;
+		break;
+	case 2:
+		c->code_rate_HP = FEC_3_4;
+		break;
+	case 3:
+		c->code_rate_HP = FEC_5_6;
+		break;
+	case 4:
+		c->code_rate_HP = FEC_7_8;
+		break;
+	}
+
+	switch ((buf[1] >> 0) & 7) {
+	case 0:
+		c->code_rate_LP = FEC_1_2;
+		break;
+	case 1:
+		c->code_rate_LP = FEC_2_3;
+		break;
+	case 2:
+		c->code_rate_LP = FEC_3_4;
+		break;
+	case 3:
+		c->code_rate_LP = FEC_5_6;
+		break;
+	case 4:
+		c->code_rate_LP = FEC_7_8;
+		break;
+	}
+
+	return 0;
+err:
+	dbg("%s: failed=%d", __func__, ret);
+	return ret;
+}
+
+static int rtl2830_read_status(struct dvb_frontend *fe, fe_status_t *status)
+{
+	struct rtl2830_priv *priv = fe->demodulator_priv;
+	int ret;
+	u8 tmp;
+	*status = 0;
+
+	if (priv->sleeping)
+		return 0;
+
+	ret = rtl2830_rd_reg_mask(priv, 0x351, &tmp, 0x78); /* [6:3] */
+	if (ret)
+		goto err;
+
+	if (tmp == 11) {
+		*status |= FE_HAS_SIGNAL | FE_HAS_CARRIER |
+			FE_HAS_VITERBI | FE_HAS_SYNC | FE_HAS_LOCK;
+	} else if (tmp == 10) {
+		*status |= FE_HAS_SIGNAL | FE_HAS_CARRIER |
+			FE_HAS_VITERBI;
+	}
+
+	return ret;
+err:
+	dbg("%s: failed=%d", __func__, ret);
+	return ret;
+}
+
+static int rtl2830_read_snr(struct dvb_frontend *fe, u16 *snr)
+{
+	struct rtl2830_priv *priv = fe->demodulator_priv;
+	int ret, hierarchy, constellation;
+	u8 buf[2], tmp;
+	u16 tmp16;
+#define CONSTELLATION_NUM 3
+#define HIERARCHY_NUM 4
+	static const u32 snr_constant[CONSTELLATION_NUM][HIERARCHY_NUM] = {
+		{ 70705899, 70705899, 70705899, 70705899 },
+		{ 82433173, 82433173, 87483115, 94445660 },
+		{ 92888734, 92888734, 95487525, 99770748 },
+	};
+
+	if (priv->sleeping)
+		return 0;
+
+	/* reports SNR in resolution of 0.1 dB */
+
+	ret = rtl2830_rd_reg(priv, 0x33c, &tmp);
+	if (ret)
+		goto err;
+
+	constellation = (tmp >> 2) & 0x03; /* [3:2] */
+	if (constellation > CONSTELLATION_NUM - 1)
+		goto err;
+
+	hierarchy = (tmp >> 4) & 0x07; /* [6:4] */
+	if (hierarchy > HIERARCHY_NUM - 1)
+		goto err;
+
+	ret = rtl2830_rd_regs(priv, 0x40c, buf, 2);
+	if (ret)
+		goto err;
+
+	tmp16 = buf[0] << 8 | buf[1];
+
+	if (tmp16)
+		*snr = (snr_constant[constellation][hierarchy] -
+				intlog10(tmp16)) / ((1 << 24) / 100);
+	else
+		*snr = 0;
+
+	return 0;
+err:
+	dbg("%s: failed=%d", __func__, ret);
+	return ret;
+}
+
+static int rtl2830_read_ber(struct dvb_frontend *fe, u32 *ber)
+{
+	struct rtl2830_priv *priv = fe->demodulator_priv;
+	int ret;
+	u8 buf[2];
+
+	if (priv->sleeping)
+		return 0;
+
+	ret = rtl2830_rd_regs(priv, 0x34e, buf, 2);
+	if (ret)
+		goto err;
+
+	*ber = buf[0] << 8 | buf[1];
+
+	return 0;
+err:
+	dbg("%s: failed=%d", __func__, ret);
+	return ret;
+}
+
+static int rtl2830_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)
+{
+	*ucblocks = 0;
+	return 0;
+}
+
+static int rtl2830_read_signal_strength(struct dvb_frontend *fe, u16 *strength)
+{
+	struct rtl2830_priv *priv = fe->demodulator_priv;
+	int ret;
+	u8 buf[2];
+	u16 if_agc_raw, if_agc;
+
+	if (priv->sleeping)
+		return 0;
+
+	ret = rtl2830_rd_regs(priv, 0x359, buf, 2);
+	if (ret)
+		goto err;
+
+	if_agc_raw = (buf[0] << 8 | buf[1]) & 0x3fff;
+
+	if (if_agc_raw & (1 << 9))
+		if_agc = -(~(if_agc_raw - 1) & 0x1ff);
+	else
+		if_agc = if_agc_raw;
+
+	*strength = (u8) (55 - if_agc / 182);
+	*strength |= *strength << 8;
+
+	return 0;
+err:
+	dbg("%s: failed=%d", __func__, ret);
+	return ret;
+}
+
+static struct dvb_frontend_ops rtl2830_ops;
+
+static u32 rtl2830_tuner_i2c_func(struct i2c_adapter *adapter)
+{
+	return I2C_FUNC_I2C;
+}
+
+static int rtl2830_tuner_i2c_xfer(struct i2c_adapter *i2c_adap,
+	struct i2c_msg msg[], int num)
+{
+	struct rtl2830_priv *priv = i2c_get_adapdata(i2c_adap);
+	int ret;
+
+	/* open i2c-gate */
+	ret = rtl2830_wr_reg_mask(priv, 0x101, 0x08, 0x08);
+	if (ret)
+		goto err;
+
+	ret = i2c_transfer(priv->i2c, msg, num);
+	if (ret < 0)
+		warn("tuner i2c failed=%d", ret);
+
+	return ret;
+err:
+	dbg("%s: failed=%d", __func__, ret);
+	return ret;
+}
+
+static struct i2c_algorithm rtl2830_tuner_i2c_algo = {
+	.master_xfer   = rtl2830_tuner_i2c_xfer,
+	.functionality = rtl2830_tuner_i2c_func,
+};
+
+struct i2c_adapter *rtl2830_get_tuner_i2c_adapter(struct dvb_frontend *fe)
+{
+	struct rtl2830_priv *priv = fe->demodulator_priv;
+	return &priv->tuner_i2c_adapter;
+}
+EXPORT_SYMBOL(rtl2830_get_tuner_i2c_adapter);
+
+static void rtl2830_release(struct dvb_frontend *fe)
+{
+	struct rtl2830_priv *priv = fe->demodulator_priv;
+
+	i2c_del_adapter(&priv->tuner_i2c_adapter);
+	kfree(priv);
+}
+
+struct dvb_frontend *rtl2830_attach(const struct rtl2830_config *cfg,
+	struct i2c_adapter *i2c)
+{
+	struct rtl2830_priv *priv = NULL;
+	int ret = 0;
+	u8 tmp;
+
+	/* allocate memory for the internal state */
+	priv = kzalloc(sizeof(struct rtl2830_priv), GFP_KERNEL);
+	if (priv == NULL)
+		goto err;
+
+	/* setup the priv */
+	priv->i2c = i2c;
+	memcpy(&priv->cfg, cfg, sizeof(struct rtl2830_config));
+
+	/* check if the demod is there */
+	ret = rtl2830_rd_reg(priv, 0x000, &tmp);
+	if (ret)
+		goto err;
+
+	/* create dvb_frontend */
+	memcpy(&priv->fe.ops, &rtl2830_ops, sizeof(struct dvb_frontend_ops));
+	priv->fe.demodulator_priv = priv;
+
+	/* create tuner i2c adapter */
+	strlcpy(priv->tuner_i2c_adapter.name, "RTL2830 tuner I2C adapter",
+		sizeof(priv->tuner_i2c_adapter.name));
+	priv->tuner_i2c_adapter.algo = &rtl2830_tuner_i2c_algo;
+	priv->tuner_i2c_adapter.algo_data = NULL;
+	i2c_set_adapdata(&priv->tuner_i2c_adapter, priv);
+	if (i2c_add_adapter(&priv->tuner_i2c_adapter) < 0) {
+		err("tuner I2C bus could not be initialized");
+		goto err;
+	}
+
+	priv->sleeping = true;
+
+	return &priv->fe;
+err:
+	dbg("%s: failed=%d", __func__, ret);
+	kfree(priv);
+	return NULL;
+}
+EXPORT_SYMBOL(rtl2830_attach);
+
+static struct dvb_frontend_ops rtl2830_ops = {
+	.delsys = { SYS_DVBT },
+	.info = {
+		.name = "Realtek RTL2830 (DVB-T)",
+		.caps = FE_CAN_FEC_1_2 |
+			FE_CAN_FEC_2_3 |
+			FE_CAN_FEC_3_4 |
+			FE_CAN_FEC_5_6 |
+			FE_CAN_FEC_7_8 |
+			FE_CAN_FEC_AUTO |
+			FE_CAN_QPSK |
+			FE_CAN_QAM_16 |
+			FE_CAN_QAM_64 |
+			FE_CAN_QAM_AUTO |
+			FE_CAN_TRANSMISSION_MODE_AUTO |
+			FE_CAN_GUARD_INTERVAL_AUTO |
+			FE_CAN_HIERARCHY_AUTO |
+			FE_CAN_RECOVER |
+			FE_CAN_MUTE_TS
+	},
+
+	.release = rtl2830_release,
+
+	.init = rtl2830_init,
+	.sleep = rtl2830_sleep,
+
+	.get_tune_settings = rtl2830_get_tune_settings,
+
+	.set_frontend = rtl2830_set_frontend,
+	.get_frontend = rtl2830_get_frontend,
+
+	.read_status = rtl2830_read_status,
+	.read_snr = rtl2830_read_snr,
+	.read_ber = rtl2830_read_ber,
+	.read_ucblocks = rtl2830_read_ucblocks,
+	.read_signal_strength = rtl2830_read_signal_strength,
+};
+
+MODULE_AUTHOR("Antti Palosaari <crope@iki.fi>");
+MODULE_DESCRIPTION("Realtek RTL2830 DVB-T demodulator driver");
+MODULE_LICENSE("GPL");
