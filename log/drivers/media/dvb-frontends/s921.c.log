commit 50acfb2b76e19f73270fef9a32726c7e18d08ec3
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 07:18:00 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 286
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation version 2 this program is distributed
      in the hope that it will be useful but without any warranty without
      even the implied warranty of merchantability or fitness for a
      particular purpose see the gnu general public license for more
      details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 97 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190529141901.025053186@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/media/dvb-frontends/s921.c b/drivers/media/dvb-frontends/s921.c
index 79276871112a..f118d8e64103 100644
--- a/drivers/media/dvb-frontends/s921.c
+++ b/drivers/media/dvb-frontends/s921.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  *   Sharp VA3A5JZ921 One Seg Broadcast Module driver
  *   This device is labeled as just S. 921 at the top of the frontend can
@@ -11,15 +12,6 @@
  *	the old s921 driver.
  *
  *   FIXME: Need to port to DVB v5.2 API
- *
- *   This program is free software; you can redistribute it and/or
- *   modify it under the terms of the GNU General Public License as
- *   published by the Free Software Foundation version 2.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *   General Public License for more details.
  */
 
 #include <linux/kernel.h>

commit f1b1eabff0eb3fc46b06668de8174c0f23b271fd
Author: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
Date:   Thu Jul 5 18:59:36 2018 -0400

    media: dvb: represent min/max/step/tolerance freqs in Hz
    
    Right now, satellite frontend drivers specify frequencies in kHz,
    while terrestrial/cable ones specify in Hz. That's confusing
    for developers.
    
    However, the main problem is that universal frontends capable
    of handling both satellite and non-satelite delivery systems
    are appearing. We end by needing to hack the drivers in
    order to support such hybrid frontends.
    
    So, convert everything to specify frontend frequencies in Hz.
    
    Tested-by: Katsuhiro Suzuki <suzuki.katsuhiro@socionext.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/dvb-frontends/s921.c b/drivers/media/dvb-frontends/s921.c
index 6c9015236655..79276871112a 100644
--- a/drivers/media/dvb-frontends/s921.c
+++ b/drivers/media/dvb-frontends/s921.c
@@ -510,15 +510,14 @@ static const struct dvb_frontend_ops s921_ops = {
 	/* Use dib8000 values per default */
 	.info = {
 		.name = "Sharp S921",
-		.frequency_min = 470000000,
+		.frequency_min_hz = 470 * MHz,
 		/*
 		 * Max should be 770MHz instead, according with Sharp docs,
 		 * but Leadership doc says it works up to 806 MHz. This is
 		 * required to get channel 69, used in Brazil
 		 */
-		.frequency_max = 806000000,
-		.frequency_tolerance = 0,
-		 .caps = FE_CAN_INVERSION_AUTO |
+		.frequency_max_hz = 806 * MHz,
+		.caps =  FE_CAN_INVERSION_AUTO |
 			 FE_CAN_FEC_1_2  | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |
 			 FE_CAN_FEC_5_6  | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |
 			 FE_CAN_QPSK     | FE_CAN_QAM_16 | FE_CAN_QAM_64 |

commit 8d718e5376c602dfd41b599dcc2a7b1be07c7b6b
Author: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
Date:   Tue Apr 24 09:19:18 2018 -0400

    media: frontends: fix ops get_algo()'s return type
    
    The method dvb_frontend_ops::get_frontend_algo() is defined as
    returning an 'enum dvbfe_algo', but the implementation in this
    driver returns an 'int'.
    
    Fix this by returning 'enum dvbfe_algo' on drivers.
    
    [mchehab+samsung@kernel.org: merge similar patches and patch
     ddbridge-mci.c the same way]
    Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/dvb-frontends/s921.c b/drivers/media/dvb-frontends/s921.c
index 2d75ede77aca..6c9015236655 100644
--- a/drivers/media/dvb-frontends/s921.c
+++ b/drivers/media/dvb-frontends/s921.c
@@ -464,7 +464,7 @@ static int s921_tune(struct dvb_frontend *fe,
 	return rc;
 }
 
-static int s921_get_algo(struct dvb_frontend *fe)
+static enum dvbfe_algo s921_get_algo(struct dvb_frontend *fe)
 {
 	return DVBFE_ALGO_HW;
 }

commit fada1935590f66dc6784981e0d557ca09013c847
Author: Mauro Carvalho Chehab <mchehab@s-opensource.com>
Date:   Thu Dec 28 13:03:51 2017 -0500

    media: move dvb kAPI headers to include/media
    
    Except for DVB, all media kAPI headers are at include/media.
    
    Move the headers to it.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/s921.c b/drivers/media/dvb-frontends/s921.c
index 274544a3ae0e..2d75ede77aca 100644
--- a/drivers/media/dvb-frontends/s921.c
+++ b/drivers/media/dvb-frontends/s921.c
@@ -25,7 +25,7 @@
 #include <linux/kernel.h>
 #include <asm/div64.h>
 
-#include "dvb_frontend.h"
+#include <media/dvb_frontend.h>
 #include "s921.h"
 
 static int debug = 1;

commit bd336e63441bcdeeccca6a698087d913a32478c5
Author: Max Kellermann <max.kellermann@gmail.com>
Date:   Tue Aug 9 18:32:21 2016 -0300

    [media] dvb: make DVB frontend *_ops instances "const"
    
    These are immutable.  Making them "const" allows the compiler to move
    them to the "rodata" section.
    
    Note that cxd2841er_t_c_ops cannot be made "const", because
    cxd2841er_attach() modifies it.  Ouch!
    
    [mchehab@s-opensource.com: fix merge conflicts]
    Signed-off-by: Max Kellermann <max.kellermann@gmail.com>
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/s921.c b/drivers/media/dvb-frontends/s921.c
index 98cceb149b91..274544a3ae0e 100644
--- a/drivers/media/dvb-frontends/s921.c
+++ b/drivers/media/dvb-frontends/s921.c
@@ -477,7 +477,7 @@ static void s921_release(struct dvb_frontend *fe)
 	kfree(state);
 }
 
-static struct dvb_frontend_ops s921_ops;
+static const struct dvb_frontend_ops s921_ops;
 
 struct dvb_frontend *s921_attach(const struct s921_config *config,
 				    struct i2c_adapter *i2c)
@@ -505,7 +505,7 @@ struct dvb_frontend *s921_attach(const struct s921_config *config,
 }
 EXPORT_SYMBOL(s921_attach);
 
-static struct dvb_frontend_ops s921_ops = {
+static const struct dvb_frontend_ops s921_ops = {
 	.delsys = { SYS_ISDBT },
 	/* Use dib8000 values per default */
 	.info = {

commit 4bd69e7b9c1b8c1a5b6cfc50a126ae0a1d926e57
Author: Mauro Carvalho Chehab <mchehab@s-opensource.com>
Date:   Tue Oct 18 17:44:22 2016 -0200

    [media] dvb-frontends: don't break long lines
    
    Due to the 80-cols restrictions, and latter due to checkpatch
    warnings, several strings were broken into multiple lines. This
    is not considered a good practice anymore, as it makes harder
    to grep for strings at the source code.
    
    As we're right now fixing other drivers due to KERN_CONT, we need
    to be able to identify what printk strings don't end with a "\n".
    It is a way easier to detect those if we don't break long lines.
    
    So, join those continuation lines.
    
    The patch was generated via the script below, and manually
    adjusted if needed.
    
    </script>
    use Text::Tabs;
    while (<>) {
            if ($next ne "") {
                    $c=$_;
                    if ($c =~ /^\s+\"(.*)/) {
                            $c2=$1;
                            $next =~ s/\"\n$//;
                            $n = expand($next);
                            $funpos = index($n, '(');
                            $pos = index($c2, '",');
                            if ($funpos && $pos > 0) {
                                    $s1 = substr $c2, 0, $pos + 2;
                                    $s2 = ' ' x ($funpos + 1) . substr $c2, $pos + 2;
                                    $s2 =~ s/^\s+//;
    
                                    $s2 = ' ' x ($funpos + 1) . $s2 if ($s2 ne "");
    
                                    print unexpand("$next$s1\n");
                                    print unexpand("$s2\n") if ($s2 ne "");
                            } else {
                                    print "$next$c2\n";
                            }
                            $next="";
                            next;
                    } else {
                            print $next;
                    }
                    $next="";
            } else {
                    if (m/\"$/) {
                            if (!m/\\n\"$/) {
                                    $next=$_;
                                    next;
                            }
                    }
            }
            print $_;
    }
    </script>
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/s921.c b/drivers/media/dvb-frontends/s921.c
index b5e3d90eba5e..98cceb149b91 100644
--- a/drivers/media/dvb-frontends/s921.c
+++ b/drivers/media/dvb-frontends/s921.c
@@ -214,8 +214,8 @@ static int s921_i2c_writereg(struct s921_state *state,
 
 	rc = i2c_transfer(state->i2c, &msg, 1);
 	if (rc != 1) {
-		printk("%s: writereg rcor(rc == %i, reg == 0x%02x,"
-			 " data == 0x%02x)\n", __func__, rc, reg, data);
+		printk("%s: writereg rcor(rc == %i, reg == 0x%02x, data == 0x%02x)\n",
+		       __func__, rc, reg, data);
 		return rc;
 	}
 

commit 7e3e68bcfd7713fb1470070c8fa0f108609dd76b
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Thu Feb 4 12:58:30 2016 -0200

    [media] dvb_frontend: pass the props cache to get_frontend() as arg
    
    Instead of using the DTV properties cache directly, pass the get
    frontend data as an argument. For now, everything should remain
    the same, but the next patch will prevent get_frontend to
    affect the global cache.
    
    This is needed because several drivers don't care enough to only
    change the properties if locked. Due to that, calling
    G_PROPERTY before locking on those drivers will make them to
    never lock. Ok, those drivers are crap and should never be
    merged like that, but the core should not rely that the drivers
    would be doing the right thing.
    
    Reviewed-by: Michael Ira Krufky <mkrufky@linuxtv.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/s921.c b/drivers/media/dvb-frontends/s921.c
index d6a8fa63040b..b5e3d90eba5e 100644
--- a/drivers/media/dvb-frontends/s921.c
+++ b/drivers/media/dvb-frontends/s921.c
@@ -433,9 +433,9 @@ static int s921_set_frontend(struct dvb_frontend *fe)
 	return 0;
 }
 
-static int s921_get_frontend(struct dvb_frontend *fe)
+static int s921_get_frontend(struct dvb_frontend *fe,
+			     struct dtv_frontend_properties *p)
 {
-	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
 	struct s921_state *state = fe->demodulator_priv;
 
 	/* FIXME: Probably it is possible to get it from regs f1 and f2 */

commit 27460adc07a3f84e671dec71ac553818d5988003
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Sat Aug 22 12:48:09 2015 -0300

    [media] dvb: Use DVBFE_ALGO_HW where applicable
    
    The dvb_frontend.c core defines a FE_ALGO_HW symbol that it is
    never used. Also, both cx24123 returns 1 to get_algo() callback
    instead of using DVBFE_ALGO_HW.
    
    Probably, those are some left overs from some code cleanup.
    
    Let's stop returning magic numbers and use the proper macro
    value.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
    Acked-by: Jonathan Corbet <corbet@lwn.net>

diff --git a/drivers/media/dvb-frontends/s921.c b/drivers/media/dvb-frontends/s921.c
index b2d9fe13e1a0..d6a8fa63040b 100644
--- a/drivers/media/dvb-frontends/s921.c
+++ b/drivers/media/dvb-frontends/s921.c
@@ -466,7 +466,7 @@ static int s921_tune(struct dvb_frontend *fe,
 
 static int s921_get_algo(struct dvb_frontend *fe)
 {
-	return 1; /* FE_ALGO_HW */
+	return DVBFE_ALGO_HW;
 }
 
 static void s921_release(struct dvb_frontend *fe)

commit 0df289a209e02f0926042ab07d7d2595ea2d2e9b
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Sun Jun 7 14:53:52 2015 -0300

    [media] dvb: Get rid of typedev usage for enums
    
    The DVB API was originally defined using typedefs. This is against
    Kernel CodingStyle, and there's no good usage here. While we can't
    remove its usage on userspace, we can avoid its usage in Kernelspace.
    
    So, let's do it.
    
    This patch was generated by this shell script:
    
            for j in $(grep typedef include/uapi/linux/dvb/frontend.h |cut -d' ' -f 3); do for i in $(find drivers/media -name '*.[ch]' -type f) $(find drivers/staging/media -name '*.[ch]' -type f); do sed "s,${j}_t,enum $j," <$i >a && mv a $i; done; done
    
    While here, make CodingStyle fixes on the affected lines.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
    Acked-by: Stefan Richter <stefanr@s5r6.in-berlin.de> # for drivers/media/firewire/*

diff --git a/drivers/media/dvb-frontends/s921.c b/drivers/media/dvb-frontends/s921.c
index 69862e1fd9e9..b2d9fe13e1a0 100644
--- a/drivers/media/dvb-frontends/s921.c
+++ b/drivers/media/dvb-frontends/s921.c
@@ -348,7 +348,7 @@ static int s921_initfe(struct dvb_frontend *fe)
 	return 0;
 }
 
-static int s921_read_status(struct dvb_frontend *fe, fe_status_t *status)
+static int s921_read_status(struct dvb_frontend *fe, enum fe_status *status)
 {
 	struct s921_state *state = fe->demodulator_priv;
 	int regstatus, rc;
@@ -389,7 +389,7 @@ static int s921_read_status(struct dvb_frontend *fe, fe_status_t *status)
 
 static int s921_read_signal_strength(struct dvb_frontend *fe, u16 *strength)
 {
-	fe_status_t	status;
+	enum fe_status	status;
 	struct s921_state *state = fe->demodulator_priv;
 	int rc;
 
@@ -449,7 +449,7 @@ static int s921_tune(struct dvb_frontend *fe,
 			bool re_tune,
 			unsigned int mode_flags,
 			unsigned int *delay,
-			fe_status_t *status)
+			enum fe_status *status)
 {
 	int rc = 0;
 

commit 37e59f876bc710d67a30b660826a5e83e07101ce
Author: Mauro Carvalho Chehab <m.chehab@samsung.com>
Date:   Fri Feb 7 08:03:07 2014 -0200

    [media, edac] Change my email address
    
    There are several left overs with my old email address.
    Remove their occurrences and add myself at CREDITS, to
    allow people to be able to reach me on my new addresses.
    
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/drivers/media/dvb-frontends/s921.c b/drivers/media/dvb-frontends/s921.c
index a271ac3eaec0..69862e1fd9e9 100644
--- a/drivers/media/dvb-frontends/s921.c
+++ b/drivers/media/dvb-frontends/s921.c
@@ -2,7 +2,7 @@
  *   Sharp VA3A5JZ921 One Seg Broadcast Module driver
  *   This device is labeled as just S. 921 at the top of the frontend can
  *
- *   Copyright (C) 2009-2010 Mauro Carvalho Chehab <mchehab@redhat.com>
+ *   Copyright (C) 2009-2010 Mauro Carvalho Chehab
  *   Copyright (C) 2009-2010 Douglas Landgraf <dougsland@redhat.com>
  *
  *   Developed for Leadership SBTVD 1seg device sold in Brazil
@@ -539,6 +539,6 @@ static struct dvb_frontend_ops s921_ops = {
 };
 
 MODULE_DESCRIPTION("DVB Frontend module for Sharp S921 hardware");
-MODULE_AUTHOR("Mauro Carvalho Chehab <mchehab@redhat.com>");
+MODULE_AUTHOR("Mauro Carvalho Chehab");
 MODULE_AUTHOR("Douglas Landgraf <dougsland@redhat.com>");
 MODULE_LICENSE("GPL");

commit 4a0543ee8d17515420d9133c0e733298d1658523
Author: Peter Senna Tschudin <peter.senna@gmail.com>
Date:   Wed Sep 12 08:56:01 2012 -0300

    [media] drivers/media/dvb-frontends/s921.c: Removes useless kfree()
    
    Remove useless kfree() and clean up code related to the removal.
    The semantic patch that finds this problem is as follows:
    (http://coccinelle.lip6.fr/)
    // <smpl>
    @r exists@
    position p1,p2;
    expression x;
    @@
    if (x@p1 == NULL) { ... kfree@p2(x); ... return ...; }
    @unchanged exists@
    position r.p1,r.p2;
    expression e <= r.x,x,e1;
    iterator I;
    statement S;
    @@
    if (x@p1 == NULL) { ... when != I(x,...) S
                            when != e = e1
                            when != e += e1
                            when != e -= e1
                            when != ++e
                            when != --e
                            when != e++
                            when != e--
                            when != &e
       kfree@p2(x); ... return ...; }
    @ok depends on unchanged exists@
    position any r.p1;
    position r.p2;
    expression x;
    @@
    ... when != true x@p1 == NULL
    kfree@p2(x);
    @depends on !ok && unchanged@
    position r.p2;
    expression x;
    @@
    *kfree@p2(x);
    // </smpl>
    
    Signed-off-by: Peter Senna Tschudin <peter.senna@gmail.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/dvb-frontends/s921.c b/drivers/media/dvb-frontends/s921.c
index cd2288c07147..a271ac3eaec0 100644
--- a/drivers/media/dvb-frontends/s921.c
+++ b/drivers/media/dvb-frontends/s921.c
@@ -487,9 +487,9 @@ struct dvb_frontend *s921_attach(const struct s921_config *config,
 		kzalloc(sizeof(struct s921_state), GFP_KERNEL);
 
 	dprintk("\n");
-	if (state == NULL) {
+	if (!state) {
 		rc("Unable to kzalloc\n");
-		goto rcor;
+		return NULL;
 	}
 
 	/* setup the state */
@@ -502,11 +502,6 @@ struct dvb_frontend *s921_attach(const struct s921_config *config,
 	state->frontend.demodulator_priv = state;
 
 	return &state->frontend;
-
-rcor:
-	kfree(state);
-
-	return NULL;
 }
 EXPORT_SYMBOL(s921_attach);
 

commit 9a0bf528b4d66b605f02634236da085595c22101
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Mon Aug 13 23:13:41 2012 -0300

    [media] move the dvb/frontends to drivers/media/dvb-frontends
    
    Raise the DVB frontends one level up, as the intention is to remove
    the drivers/media/dvb directory.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/dvb-frontends/s921.c b/drivers/media/dvb-frontends/s921.c
new file mode 100644
index 000000000000..cd2288c07147
--- /dev/null
+++ b/drivers/media/dvb-frontends/s921.c
@@ -0,0 +1,549 @@
+/*
+ *   Sharp VA3A5JZ921 One Seg Broadcast Module driver
+ *   This device is labeled as just S. 921 at the top of the frontend can
+ *
+ *   Copyright (C) 2009-2010 Mauro Carvalho Chehab <mchehab@redhat.com>
+ *   Copyright (C) 2009-2010 Douglas Landgraf <dougsland@redhat.com>
+ *
+ *   Developed for Leadership SBTVD 1seg device sold in Brazil
+ *
+ *   Frontend module based on cx24123 driver, getting some info from
+ *	the old s921 driver.
+ *
+ *   FIXME: Need to port to DVB v5.2 API
+ *
+ *   This program is free software; you can redistribute it and/or
+ *   modify it under the terms of the GNU General Public License as
+ *   published by the Free Software Foundation version 2.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *   General Public License for more details.
+ */
+
+#include <linux/kernel.h>
+#include <asm/div64.h>
+
+#include "dvb_frontend.h"
+#include "s921.h"
+
+static int debug = 1;
+module_param(debug, int, 0644);
+MODULE_PARM_DESC(debug, "Activates frontend debugging (default:0)");
+
+#define rc(args...)  do {						\
+	printk(KERN_ERR  "s921: " args);				\
+} while (0)
+
+#define dprintk(args...)						\
+	do {								\
+		if (debug) {						\
+			printk(KERN_DEBUG "s921: %s: ", __func__);	\
+			printk(args);					\
+		}							\
+	} while (0)
+
+struct s921_state {
+	struct i2c_adapter *i2c;
+	const struct s921_config *config;
+
+	struct dvb_frontend frontend;
+
+	/* The Demod can't easily provide these, we cache them */
+	u32 currentfreq;
+};
+
+/*
+ * Various tuner defaults need to be established for a given frequency kHz.
+ * fixme: The bounds on the bands do not match the doc in real life.
+ * fixme: Some of them have been moved, other might need adjustment.
+ */
+static struct s921_bandselect_val {
+	u32 freq_low;
+	u8  band_reg;
+} s921_bandselect[] = {
+	{         0, 0x7b },
+	{ 485140000, 0x5b },
+	{ 515140000, 0x3b },
+	{ 545140000, 0x1b },
+	{ 599140000, 0xfb },
+	{ 623140000, 0xdb },
+	{ 659140000, 0xbb },
+	{ 713140000, 0x9b },
+};
+
+struct regdata {
+	u8 reg;
+	u8 data;
+};
+
+static struct regdata s921_init[] = {
+	{ 0x01, 0x80 },		/* Probably, a reset sequence */
+	{ 0x01, 0x40 },
+	{ 0x01, 0x80 },
+	{ 0x01, 0x40 },
+
+	{ 0x02, 0x00 },
+	{ 0x03, 0x40 },
+	{ 0x04, 0x01 },
+	{ 0x05, 0x00 },
+	{ 0x06, 0x00 },
+	{ 0x07, 0x00 },
+	{ 0x08, 0x00 },
+	{ 0x09, 0x00 },
+	{ 0x0a, 0x00 },
+	{ 0x0b, 0x5a },
+	{ 0x0c, 0x00 },
+	{ 0x0d, 0x00 },
+	{ 0x0f, 0x00 },
+	{ 0x13, 0x1b },
+	{ 0x14, 0x80 },
+	{ 0x15, 0x40 },
+	{ 0x17, 0x70 },
+	{ 0x18, 0x01 },
+	{ 0x19, 0x12 },
+	{ 0x1a, 0x01 },
+	{ 0x1b, 0x12 },
+	{ 0x1c, 0xa0 },
+	{ 0x1d, 0x00 },
+	{ 0x1e, 0x0a },
+	{ 0x1f, 0x08 },
+	{ 0x20, 0x40 },
+	{ 0x21, 0xff },
+	{ 0x22, 0x4c },
+	{ 0x23, 0x4e },
+	{ 0x24, 0x4c },
+	{ 0x25, 0x00 },
+	{ 0x26, 0x00 },
+	{ 0x27, 0xf4 },
+	{ 0x28, 0x60 },
+	{ 0x29, 0x88 },
+	{ 0x2a, 0x40 },
+	{ 0x2b, 0x40 },
+	{ 0x2c, 0xff },
+	{ 0x2d, 0x00 },
+	{ 0x2e, 0xff },
+	{ 0x2f, 0x00 },
+	{ 0x30, 0x20 },
+	{ 0x31, 0x06 },
+	{ 0x32, 0x0c },
+	{ 0x34, 0x0f },
+	{ 0x37, 0xfe },
+	{ 0x38, 0x00 },
+	{ 0x39, 0x63 },
+	{ 0x3a, 0x10 },
+	{ 0x3b, 0x10 },
+	{ 0x47, 0x00 },
+	{ 0x49, 0xe5 },
+	{ 0x4b, 0x00 },
+	{ 0x50, 0xc0 },
+	{ 0x52, 0x20 },
+	{ 0x54, 0x5a },
+	{ 0x55, 0x5b },
+	{ 0x56, 0x40 },
+	{ 0x57, 0x70 },
+	{ 0x5c, 0x50 },
+	{ 0x5d, 0x00 },
+	{ 0x62, 0x17 },
+	{ 0x63, 0x2f },
+	{ 0x64, 0x6f },
+	{ 0x68, 0x00 },
+	{ 0x69, 0x89 },
+	{ 0x6a, 0x00 },
+	{ 0x6b, 0x00 },
+	{ 0x6c, 0x00 },
+	{ 0x6d, 0x00 },
+	{ 0x6e, 0x00 },
+	{ 0x70, 0x10 },
+	{ 0x71, 0x00 },
+	{ 0x75, 0x00 },
+	{ 0x76, 0x30 },
+	{ 0x77, 0x01 },
+	{ 0xaf, 0x00 },
+	{ 0xb0, 0xa0 },
+	{ 0xb2, 0x3d },
+	{ 0xb3, 0x25 },
+	{ 0xb4, 0x8b },
+	{ 0xb5, 0x4b },
+	{ 0xb6, 0x3f },
+	{ 0xb7, 0xff },
+	{ 0xb8, 0xff },
+	{ 0xb9, 0xfc },
+	{ 0xba, 0x00 },
+	{ 0xbb, 0x00 },
+	{ 0xbc, 0x00 },
+	{ 0xd0, 0x30 },
+	{ 0xe4, 0x84 },
+	{ 0xf0, 0x48 },
+	{ 0xf1, 0x19 },
+	{ 0xf2, 0x5a },
+	{ 0xf3, 0x8e },
+	{ 0xf4, 0x2d },
+	{ 0xf5, 0x07 },
+	{ 0xf6, 0x5a },
+	{ 0xf7, 0xba },
+	{ 0xf8, 0xd7 },
+};
+
+static struct regdata s921_prefreq[] = {
+	{ 0x47, 0x60 },
+	{ 0x68, 0x00 },
+	{ 0x69, 0x89 },
+	{ 0xf0, 0x48 },
+	{ 0xf1, 0x19 },
+};
+
+static struct regdata s921_postfreq[] = {
+	{ 0xf5, 0xae },
+	{ 0xf6, 0xb7 },
+	{ 0xf7, 0xba },
+	{ 0xf8, 0xd7 },
+	{ 0x68, 0x0a },
+	{ 0x69, 0x09 },
+};
+
+static int s921_i2c_writereg(struct s921_state *state,
+			     u8 i2c_addr, int reg, int data)
+{
+	u8 buf[] = { reg, data };
+	struct i2c_msg msg = {
+		.addr = i2c_addr, .flags = 0, .buf = buf, .len = 2
+	};
+	int rc;
+
+	rc = i2c_transfer(state->i2c, &msg, 1);
+	if (rc != 1) {
+		printk("%s: writereg rcor(rc == %i, reg == 0x%02x,"
+			 " data == 0x%02x)\n", __func__, rc, reg, data);
+		return rc;
+	}
+
+	return 0;
+}
+
+static int s921_i2c_writeregdata(struct s921_state *state, u8 i2c_addr,
+				 struct regdata *rd, int size)
+{
+	int i, rc;
+
+	for (i = 0; i < size; i++) {
+		rc = s921_i2c_writereg(state, i2c_addr, rd[i].reg, rd[i].data);
+		if (rc < 0)
+			return rc;
+	}
+	return 0;
+}
+
+static int s921_i2c_readreg(struct s921_state *state, u8 i2c_addr, u8 reg)
+{
+	u8 val;
+	int rc;
+	struct i2c_msg msg[] = {
+		{ .addr = i2c_addr, .flags = 0, .buf = &reg, .len = 1 },
+		{ .addr = i2c_addr, .flags = I2C_M_RD, .buf = &val, .len = 1 }
+	};
+
+	rc = i2c_transfer(state->i2c, msg, 2);
+
+	if (rc != 2) {
+		rc("%s: reg=0x%x (rcor=%d)\n", __func__, reg, rc);
+		return rc;
+	}
+
+	return val;
+}
+
+#define s921_readreg(state, reg) \
+	s921_i2c_readreg(state, state->config->demod_address, reg)
+#define s921_writereg(state, reg, val) \
+	s921_i2c_writereg(state, state->config->demod_address, reg, val)
+#define s921_writeregdata(state, regdata) \
+	s921_i2c_writeregdata(state, state->config->demod_address, \
+	regdata, ARRAY_SIZE(regdata))
+
+static int s921_pll_tune(struct dvb_frontend *fe)
+{
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+	struct s921_state *state = fe->demodulator_priv;
+	int band, rc, i;
+	unsigned long f_offset;
+	u8 f_switch;
+	u64 offset;
+
+	dprintk("frequency=%i\n", p->frequency);
+
+	for (band = 0; band < ARRAY_SIZE(s921_bandselect); band++)
+		if (p->frequency < s921_bandselect[band].freq_low)
+			break;
+	band--;
+
+	if (band < 0) {
+		rc("%s: frequency out of range\n", __func__);
+		return -EINVAL;
+	}
+
+	f_switch = s921_bandselect[band].band_reg;
+
+	offset = ((u64)p->frequency) * 258;
+	do_div(offset, 6000000);
+	f_offset = ((unsigned long)offset) + 2321;
+
+	rc = s921_writeregdata(state, s921_prefreq);
+	if (rc < 0)
+		return rc;
+
+	rc = s921_writereg(state, 0xf2, (f_offset >> 8) & 0xff);
+	if (rc < 0)
+		return rc;
+
+	rc = s921_writereg(state, 0xf3, f_offset & 0xff);
+	if (rc < 0)
+		return rc;
+
+	rc = s921_writereg(state, 0xf4, f_switch);
+	if (rc < 0)
+		return rc;
+
+	rc = s921_writeregdata(state, s921_postfreq);
+	if (rc < 0)
+		return rc;
+
+	for (i = 0 ; i < 6; i++) {
+		rc = s921_readreg(state, 0x80);
+		dprintk("status 0x80: %02x\n", rc);
+	}
+	rc = s921_writereg(state, 0x01, 0x40);
+	if (rc < 0)
+		return rc;
+
+	rc = s921_readreg(state, 0x01);
+	dprintk("status 0x01: %02x\n", rc);
+
+	rc = s921_readreg(state, 0x80);
+	dprintk("status 0x80: %02x\n", rc);
+
+	rc = s921_readreg(state, 0x80);
+	dprintk("status 0x80: %02x\n", rc);
+
+	rc = s921_readreg(state, 0x32);
+	dprintk("status 0x32: %02x\n", rc);
+
+	dprintk("pll tune band=%d, pll=%d\n", f_switch, (int)f_offset);
+
+	return 0;
+}
+
+static int s921_initfe(struct dvb_frontend *fe)
+{
+	struct s921_state *state = fe->demodulator_priv;
+	int rc;
+
+	dprintk("\n");
+
+	rc = s921_writeregdata(state, s921_init);
+	if (rc < 0)
+		return rc;
+
+	return 0;
+}
+
+static int s921_read_status(struct dvb_frontend *fe, fe_status_t *status)
+{
+	struct s921_state *state = fe->demodulator_priv;
+	int regstatus, rc;
+
+	*status = 0;
+
+	rc = s921_readreg(state, 0x81);
+	if (rc < 0)
+		return rc;
+
+	regstatus = rc << 8;
+
+	rc = s921_readreg(state, 0x82);
+	if (rc < 0)
+		return rc;
+
+	regstatus |= rc;
+
+	dprintk("status = %04x\n", regstatus);
+
+	/* Full Sync - We don't know what each bit means on regs 0x81/0x82 */
+	if ((regstatus & 0xff) == 0x40) {
+		*status = FE_HAS_SIGNAL  |
+			  FE_HAS_CARRIER |
+			  FE_HAS_VITERBI |
+			  FE_HAS_SYNC    |
+			  FE_HAS_LOCK;
+	} else if (regstatus & 0x40) {
+		/* This is close to Full Sync, but not enough to get useful info */
+		*status = FE_HAS_SIGNAL  |
+			  FE_HAS_CARRIER |
+			  FE_HAS_VITERBI |
+			  FE_HAS_SYNC;
+	}
+
+	return 0;
+}
+
+static int s921_read_signal_strength(struct dvb_frontend *fe, u16 *strength)
+{
+	fe_status_t	status;
+	struct s921_state *state = fe->demodulator_priv;
+	int rc;
+
+	/* FIXME: Use the proper register for it... 0x80? */
+	rc = s921_read_status(fe, &status);
+	if (rc < 0)
+		return rc;
+
+	*strength = (status & FE_HAS_LOCK) ? 0xffff : 0;
+
+	dprintk("strength = 0x%04x\n", *strength);
+
+	rc = s921_readreg(state, 0x01);
+	dprintk("status 0x01: %02x\n", rc);
+
+	rc = s921_readreg(state, 0x80);
+	dprintk("status 0x80: %02x\n", rc);
+
+	rc = s921_readreg(state, 0x32);
+	dprintk("status 0x32: %02x\n", rc);
+
+	return 0;
+}
+
+static int s921_set_frontend(struct dvb_frontend *fe)
+{
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+	struct s921_state *state = fe->demodulator_priv;
+	int rc;
+
+	dprintk("\n");
+
+	/* FIXME: We don't know how to use non-auto mode */
+
+	rc = s921_pll_tune(fe);
+	if (rc < 0)
+		return rc;
+
+	state->currentfreq = p->frequency;
+
+	return 0;
+}
+
+static int s921_get_frontend(struct dvb_frontend *fe)
+{
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+	struct s921_state *state = fe->demodulator_priv;
+
+	/* FIXME: Probably it is possible to get it from regs f1 and f2 */
+	p->frequency = state->currentfreq;
+	p->delivery_system = SYS_ISDBT;
+
+	return 0;
+}
+
+static int s921_tune(struct dvb_frontend *fe,
+			bool re_tune,
+			unsigned int mode_flags,
+			unsigned int *delay,
+			fe_status_t *status)
+{
+	int rc = 0;
+
+	dprintk("\n");
+
+	if (re_tune)
+		rc = s921_set_frontend(fe);
+
+	if (!(mode_flags & FE_TUNE_MODE_ONESHOT))
+		s921_read_status(fe, status);
+
+	return rc;
+}
+
+static int s921_get_algo(struct dvb_frontend *fe)
+{
+	return 1; /* FE_ALGO_HW */
+}
+
+static void s921_release(struct dvb_frontend *fe)
+{
+	struct s921_state *state = fe->demodulator_priv;
+
+	dprintk("\n");
+	kfree(state);
+}
+
+static struct dvb_frontend_ops s921_ops;
+
+struct dvb_frontend *s921_attach(const struct s921_config *config,
+				    struct i2c_adapter *i2c)
+{
+	/* allocate memory for the internal state */
+	struct s921_state *state =
+		kzalloc(sizeof(struct s921_state), GFP_KERNEL);
+
+	dprintk("\n");
+	if (state == NULL) {
+		rc("Unable to kzalloc\n");
+		goto rcor;
+	}
+
+	/* setup the state */
+	state->config = config;
+	state->i2c = i2c;
+
+	/* create dvb_frontend */
+	memcpy(&state->frontend.ops, &s921_ops,
+		sizeof(struct dvb_frontend_ops));
+	state->frontend.demodulator_priv = state;
+
+	return &state->frontend;
+
+rcor:
+	kfree(state);
+
+	return NULL;
+}
+EXPORT_SYMBOL(s921_attach);
+
+static struct dvb_frontend_ops s921_ops = {
+	.delsys = { SYS_ISDBT },
+	/* Use dib8000 values per default */
+	.info = {
+		.name = "Sharp S921",
+		.frequency_min = 470000000,
+		/*
+		 * Max should be 770MHz instead, according with Sharp docs,
+		 * but Leadership doc says it works up to 806 MHz. This is
+		 * required to get channel 69, used in Brazil
+		 */
+		.frequency_max = 806000000,
+		.frequency_tolerance = 0,
+		 .caps = FE_CAN_INVERSION_AUTO |
+			 FE_CAN_FEC_1_2  | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |
+			 FE_CAN_FEC_5_6  | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |
+			 FE_CAN_QPSK     | FE_CAN_QAM_16 | FE_CAN_QAM_64 |
+			 FE_CAN_QAM_AUTO | FE_CAN_TRANSMISSION_MODE_AUTO |
+			 FE_CAN_GUARD_INTERVAL_AUTO | FE_CAN_RECOVER |
+			 FE_CAN_HIERARCHY_AUTO,
+	},
+
+	.release = s921_release,
+
+	.init = s921_initfe,
+	.set_frontend = s921_set_frontend,
+	.get_frontend = s921_get_frontend,
+	.read_status = s921_read_status,
+	.read_signal_strength = s921_read_signal_strength,
+	.tune = s921_tune,
+	.get_frontend_algo = s921_get_algo,
+};
+
+MODULE_DESCRIPTION("DVB Frontend module for Sharp S921 hardware");
+MODULE_AUTHOR("Mauro Carvalho Chehab <mchehab@redhat.com>");
+MODULE_AUTHOR("Douglas Landgraf <dougsland@redhat.com>");
+MODULE_LICENSE("GPL");
