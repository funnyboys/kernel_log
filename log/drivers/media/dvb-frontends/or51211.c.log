commit c942fddf8793b2013be8c901b47d0a8dc02bf99f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:06 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 157
    
    Based on 3 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [kishon] [vijay] [abraham]
      [i] [kishon]@[ti] [com] this program is distributed in the hope that
      it will be useful but without any warranty without even the implied
      warranty of merchantability or fitness for a particular purpose see
      the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [graeme] [gregory]
      [gg]@[slimlogic] [co] [uk] [author] [kishon] [vijay] [abraham] [i]
      [kishon]@[ti] [com] [based] [on] [twl6030]_[usb] [c] [author] [hema]
      [hk] [hemahk]@[ti] [com] this program is distributed in the hope
      that it will be useful but without any warranty without even the
      implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1105 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.202006027@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/media/dvb-frontends/or51211.c b/drivers/media/dvb-frontends/or51211.c
index 7343da11a1d8..ddcaea5c9941 100644
--- a/drivers/media/dvb-frontends/or51211.c
+++ b/drivers/media/dvb-frontends/or51211.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *    Support for OR51211 (pcHDTV HD-2000) - VSB
  *
@@ -5,17 +6,6 @@
  *
  *    Based on code from Jack Kelliher (kelliher@xmission.com)
  *                           Copyright (C) 2002 & pcHDTV, inc.
- *
- *    This program is free software; you can redistribute it and/or modify
- *    it under the terms of the GNU General Public License as published by
- *    the Free Software Foundation; either version 2 of the License, or
- *    (at your option) any later version.
- *
- *    This program is distributed in the hope that it will be useful,
- *    but WITHOUT ANY WARRANTY; without even the implied warranty of
- *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *    GNU General Public License for more details.
- *
 */
 
 #define pr_fmt(fmt)	KBUILD_MODNAME ": %s: " fmt, __func__

commit 868c9a17e22c89d241f12501e21ae4f104ce036c
Author: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
Date:   Mon Feb 18 14:28:55 2019 -0500

    media: dvb-frontends: fix several typos
    
    Use codespell to fix lots of typos over frontends.
    
    Manually verified to avoid false-positives.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/dvb-frontends/or51211.c b/drivers/media/dvb-frontends/or51211.c
index a39bbd8ff1f0..7343da11a1d8 100644
--- a/drivers/media/dvb-frontends/or51211.c
+++ b/drivers/media/dvb-frontends/or51211.c
@@ -59,7 +59,7 @@ struct or51211_state {
 
 	/* Demodulator private data */
 	u8 initialized:1;
-	u32 snr; /* Result of last SNR claculation */
+	u32 snr; /* Result of last SNR calculation */
 
 	/* Tuner private data */
 	u32 current_frequency;

commit f1b1eabff0eb3fc46b06668de8174c0f23b271fd
Author: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
Date:   Thu Jul 5 18:59:36 2018 -0400

    media: dvb: represent min/max/step/tolerance freqs in Hz
    
    Right now, satellite frontend drivers specify frequencies in kHz,
    while terrestrial/cable ones specify in Hz. That's confusing
    for developers.
    
    However, the main problem is that universal frontends capable
    of handling both satellite and non-satelite delivery systems
    are appearing. We end by needing to hack the drivers in
    order to support such hybrid frontends.
    
    So, convert everything to specify frontend frequencies in Hz.
    
    Tested-by: Katsuhiro Suzuki <suzuki.katsuhiro@socionext.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/dvb-frontends/or51211.c b/drivers/media/dvb-frontends/or51211.c
index b65ba34fd00a..a39bbd8ff1f0 100644
--- a/drivers/media/dvb-frontends/or51211.c
+++ b/drivers/media/dvb-frontends/or51211.c
@@ -530,10 +530,10 @@ struct dvb_frontend* or51211_attach(const struct or51211_config* config,
 static const struct dvb_frontend_ops or51211_ops = {
 	.delsys = { SYS_ATSC, SYS_DVBC_ANNEX_B },
 	.info = {
-		.name               = "Oren OR51211 VSB Frontend",
-		.frequency_min      = 44000000,
-		.frequency_max      = 958000000,
-		.frequency_stepsize = 166666,
+		.name                  = "Oren OR51211 VSB Frontend",
+		.frequency_min_hz      =  44 * MHz,
+		.frequency_max_hz      = 958 * MHz,
+		.frequency_stepsize_hz = 166666,
 		.caps = FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |
 			FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |
 			FE_CAN_8VSB

commit fe63a1a6216749fd9d9c5b52d52b75240f9d20f3
Author: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
Date:   Tue May 8 18:10:05 2018 -0300

    media: dvb: fix location of get_dvb_firmware script
    
    This script was moved out of Documentation/dvb, but the
    links weren't updated.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
    Acked-by: Jonathan Corbet <corbet@lwn.net>

diff --git a/drivers/media/dvb-frontends/or51211.c b/drivers/media/dvb-frontends/or51211.c
index a1b7c301828f..b65ba34fd00a 100644
--- a/drivers/media/dvb-frontends/or51211.c
+++ b/drivers/media/dvb-frontends/or51211.c
@@ -22,7 +22,7 @@
 
 /*
  * This driver needs external firmware. Please use the command
- * "<kerneldir>/Documentation/dvb/get_dvb_firmware or51211" to
+ * "<kerneldir>/scripts/get_dvb_firmware or51211" to
  * download/extract it, and then copy it to /usr/lib/hotplug/firmware
  * or /lib/firmware (depending on configuration of firmware hotplug).
  */

commit fada1935590f66dc6784981e0d557ca09013c847
Author: Mauro Carvalho Chehab <mchehab@s-opensource.com>
Date:   Thu Dec 28 13:03:51 2017 -0500

    media: move dvb kAPI headers to include/media
    
    Except for DVB, all media kAPI headers are at include/media.
    
    Move the headers to it.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/or51211.c b/drivers/media/dvb-frontends/or51211.c
index d14fa9736ae5..a1b7c301828f 100644
--- a/drivers/media/dvb-frontends/or51211.c
+++ b/drivers/media/dvb-frontends/or51211.c
@@ -36,8 +36,8 @@
 #include <linux/slab.h>
 #include <asm/byteorder.h>
 
-#include "dvb_math.h"
-#include "dvb_frontend.h"
+#include <media/dvb_math.h>
+#include <media/dvb_frontend.h>
 #include "or51211.h"
 
 static int debug;

commit bcb63314e2c23f1ed622418b65f9409512659c73
Author: Sakari Ailus <sakari.ailus@linux.intel.com>
Date:   Fri Oct 28 09:31:20 2016 -0200

    [media] media: Drop FSF's postal address from the source code files
    
    Drop the FSF's postal address from the source code files that typically
    contain mostly the license text. Of the 628 removed instances, 578 are
    outdated.
    
    The patch has been created with the following command without manual edits:
    
    git grep -l "675 Mass Ave\|59 Temple Place\|51 Franklin St" -- \
            drivers/media/ include/media|while read i; do i=$i perl -e '
    open(F,"< $ENV{i}");
    $a=join("", <F>);
    $a =~ s/[ \t]*\*\n.*You should.*\n.*along with.*\n.*(\n.*USA.*$)?\n//m
            && $a =~ s/(^.*)Or, (point your browser to) /$1To obtain the license, $2\n$1/m;
    close(F);
    open(F, "> $ENV{i}");
    print F $a;
    close(F);'; done
    
    Signed-off-by: Sakari Ailus <sakari.ailus@linux.intel.com>

diff --git a/drivers/media/dvb-frontends/or51211.c b/drivers/media/dvb-frontends/or51211.c
index 27eb73aa4f62..d14fa9736ae5 100644
--- a/drivers/media/dvb-frontends/or51211.c
+++ b/drivers/media/dvb-frontends/or51211.c
@@ -16,10 +16,6 @@
  *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *    GNU General Public License for more details.
  *
- *    You should have received a copy of the GNU General Public License
- *    along with this program; if not, write to the Free Software
- *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- *
 */
 
 #define pr_fmt(fmt)	KBUILD_MODNAME ": %s: " fmt, __func__

commit bd336e63441bcdeeccca6a698087d913a32478c5
Author: Max Kellermann <max.kellermann@gmail.com>
Date:   Tue Aug 9 18:32:21 2016 -0300

    [media] dvb: make DVB frontend *_ops instances "const"
    
    These are immutable.  Making them "const" allows the compiler to move
    them to the "rodata" section.
    
    Note that cxd2841er_t_c_ops cannot be made "const", because
    cxd2841er_attach() modifies it.  Ouch!
    
    [mchehab@s-opensource.com: fix merge conflicts]
    Signed-off-by: Max Kellermann <max.kellermann@gmail.com>
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/or51211.c b/drivers/media/dvb-frontends/or51211.c
index 839479eab3b3..27eb73aa4f62 100644
--- a/drivers/media/dvb-frontends/or51211.c
+++ b/drivers/media/dvb-frontends/or51211.c
@@ -507,7 +507,7 @@ static void or51211_release(struct dvb_frontend* fe)
 	kfree(state);
 }
 
-static struct dvb_frontend_ops or51211_ops;
+static const struct dvb_frontend_ops or51211_ops;
 
 struct dvb_frontend* or51211_attach(const struct or51211_config* config,
 				    struct i2c_adapter* i2c)
@@ -531,7 +531,7 @@ struct dvb_frontend* or51211_attach(const struct or51211_config* config,
 	return &state->frontend;
 }
 
-static struct dvb_frontend_ops or51211_ops = {
+static const struct dvb_frontend_ops or51211_ops = {
 	.delsys = { SYS_ATSC, SYS_DVBC_ANNEX_B },
 	.info = {
 		.name               = "Oren OR51211 VSB Frontend",

commit 4bd69e7b9c1b8c1a5b6cfc50a126ae0a1d926e57
Author: Mauro Carvalho Chehab <mchehab@s-opensource.com>
Date:   Tue Oct 18 17:44:22 2016 -0200

    [media] dvb-frontends: don't break long lines
    
    Due to the 80-cols restrictions, and latter due to checkpatch
    warnings, several strings were broken into multiple lines. This
    is not considered a good practice anymore, as it makes harder
    to grep for strings at the source code.
    
    As we're right now fixing other drivers due to KERN_CONT, we need
    to be able to identify what printk strings don't end with a "\n".
    It is a way easier to detect those if we don't break long lines.
    
    So, join those continuation lines.
    
    The patch was generated via the script below, and manually
    adjusted if needed.
    
    </script>
    use Text::Tabs;
    while (<>) {
            if ($next ne "") {
                    $c=$_;
                    if ($c =~ /^\s+\"(.*)/) {
                            $c2=$1;
                            $next =~ s/\"\n$//;
                            $n = expand($next);
                            $funpos = index($n, '(');
                            $pos = index($c2, '",');
                            if ($funpos && $pos > 0) {
                                    $s1 = substr $c2, 0, $pos + 2;
                                    $s2 = ' ' x ($funpos + 1) . substr $c2, $pos + 2;
                                    $s2 =~ s/^\s+//;
    
                                    $s2 = ' ' x ($funpos + 1) . $s2 if ($s2 ne "");
    
                                    print unexpand("$next$s1\n");
                                    print unexpand("$s2\n") if ($s2 ne "");
                            } else {
                                    print "$next$c2\n";
                            }
                            $next="";
                            next;
                    } else {
                            print $next;
                    }
                    $next="";
            } else {
                    if (m/\"$/) {
                            if (!m/\\n\"$/) {
                                    $next=$_;
                                    next;
                            }
                    }
            }
            print $_;
    }
    </script>
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/or51211.c b/drivers/media/dvb-frontends/or51211.c
index e82413b975e6..839479eab3b3 100644
--- a/drivers/media/dvb-frontends/or51211.c
+++ b/drivers/media/dvb-frontends/or51211.c
@@ -377,8 +377,7 @@ static int or51211_init(struct dvb_frontend* fe)
 					       OR51211_DEFAULT_FIRMWARE);
 		pr_info("Got Hotplug firmware\n");
 		if (ret) {
-			pr_warn("No firmware uploaded "
-				"(timeout or file not found?)\n");
+			pr_warn("No firmware uploaded (timeout or file not found?)\n");
 			return ret;
 		}
 

commit 0df289a209e02f0926042ab07d7d2595ea2d2e9b
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Sun Jun 7 14:53:52 2015 -0300

    [media] dvb: Get rid of typedev usage for enums
    
    The DVB API was originally defined using typedefs. This is against
    Kernel CodingStyle, and there's no good usage here. While we can't
    remove its usage on userspace, we can avoid its usage in Kernelspace.
    
    So, let's do it.
    
    This patch was generated by this shell script:
    
            for j in $(grep typedef include/uapi/linux/dvb/frontend.h |cut -d' ' -f 3); do for i in $(find drivers/media -name '*.[ch]' -type f) $(find drivers/staging/media -name '*.[ch]' -type f); do sed "s,${j}_t,enum $j," <$i >a && mv a $i; done; done
    
    While here, make CodingStyle fixes on the affected lines.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
    Acked-by: Stefan Richter <stefanr@s5r6.in-berlin.de> # for drivers/media/firewire/*

diff --git a/drivers/media/dvb-frontends/or51211.c b/drivers/media/dvb-frontends/or51211.c
index 873ea1da844b..e82413b975e6 100644
--- a/drivers/media/dvb-frontends/or51211.c
+++ b/drivers/media/dvb-frontends/or51211.c
@@ -237,7 +237,7 @@ static int or51211_set_parameters(struct dvb_frontend *fe)
 	return 0;
 }
 
-static int or51211_read_status(struct dvb_frontend* fe, fe_status_t* status)
+static int or51211_read_status(struct dvb_frontend *fe, enum fe_status *status)
 {
 	struct or51211_state* state = fe->demodulator_priv;
 	unsigned char rec_buf[2];

commit 35f30f36a7e66caa0973a4db620b4245df2cf428
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Wed Sep 24 20:35:12 2014 -0300

    [media] dvb-frontends: use %zu instead of %zd
    
    size_t is unsigned.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/or51211.c b/drivers/media/dvb-frontends/or51211.c
index 10cfc0579168..873ea1da844b 100644
--- a/drivers/media/dvb-frontends/or51211.c
+++ b/drivers/media/dvb-frontends/or51211.c
@@ -111,7 +111,7 @@ static int or51211_load_firmware (struct dvb_frontend* fe,
 	u8 tudata[585];
 	int i;
 
-	dprintk("Firmware is %zd bytes\n",fw->size);
+	dprintk("Firmware is %zu bytes\n", fw->size);
 
 	/* Get eprom data */
 	tudata[0] = 17;

commit bb9e31f3928dd9b1ecb66689890d1f5f3d19227c
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue Dec 18 10:20:28 2012 -0300

    [media] or51211: apply pr_fmt and use pr_* macros instead of printk
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Michael Krufky <mkrufky@linuxtv.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/dvb-frontends/or51211.c b/drivers/media/dvb-frontends/or51211.c
index 1af997eb0578..10cfc0579168 100644
--- a/drivers/media/dvb-frontends/or51211.c
+++ b/drivers/media/dvb-frontends/or51211.c
@@ -22,6 +22,8 @@
  *
 */
 
+#define pr_fmt(fmt)	KBUILD_MODNAME ": %s: " fmt, __func__
+
 /*
  * This driver needs external firmware. Please use the command
  * "<kerneldir>/Documentation/dvb/get_dvb_firmware or51211" to
@@ -44,9 +46,7 @@
 
 static int debug;
 #define dprintk(args...) \
-	do { \
-		if (debug) printk(KERN_DEBUG "or51211: " args); \
-	} while (0)
+	do { if (debug) pr_debug(args); } while (0)
 
 static u8 run_buf[] = {0x7f,0x01};
 static u8 cmd_buf[] = {0x04,0x01,0x50,0x80,0x06}; // ATSC
@@ -80,8 +80,7 @@ static int i2c_writebytes (struct or51211_state* state, u8 reg, const u8 *buf,
 	msg.buf		= (u8 *)buf;
 
 	if ((err = i2c_transfer (state->i2c, &msg, 1)) != 1) {
-		printk(KERN_WARNING "or51211: i2c_writebytes error "
-		       "(addr %02x, err == %i)\n", reg, err);
+		pr_warn("error (addr %02x, err == %i)\n", reg, err);
 		return -EREMOTEIO;
 	}
 
@@ -98,8 +97,7 @@ static int i2c_readbytes(struct or51211_state *state, u8 reg, u8 *buf, int len)
 	msg.buf		= buf;
 
 	if ((err = i2c_transfer (state->i2c, &msg, 1)) != 1) {
-		printk(KERN_WARNING "or51211: i2c_readbytes error "
-		       "(addr %02x, err == %i)\n", reg, err);
+		pr_warn("error (addr %02x, err == %i)\n", reg, err);
 		return -EREMOTEIO;
 	}
 
@@ -118,11 +116,11 @@ static int or51211_load_firmware (struct dvb_frontend* fe,
 	/* Get eprom data */
 	tudata[0] = 17;
 	if (i2c_writebytes(state,0x50,tudata,1)) {
-		printk(KERN_WARNING "or51211:load_firmware error eprom addr\n");
+		pr_warn("error eprom addr\n");
 		return -1;
 	}
 	if (i2c_readbytes(state,0x50,&tudata[145],192)) {
-		printk(KERN_WARNING "or51211: load_firmware error eprom\n");
+		pr_warn("error eprom\n");
 		return -1;
 	}
 
@@ -136,32 +134,32 @@ static int or51211_load_firmware (struct dvb_frontend* fe,
 	state->config->reset(fe);
 
 	if (i2c_writebytes(state,state->config->demod_address,tudata,585)) {
-		printk(KERN_WARNING "or51211: load_firmware error 1\n");
+		pr_warn("error 1\n");
 		return -1;
 	}
 	msleep(1);
 
 	if (i2c_writebytes(state,state->config->demod_address,
 			   &fw->data[393],8125)) {
-		printk(KERN_WARNING "or51211: load_firmware error 2\n");
+		pr_warn("error 2\n");
 		return -1;
 	}
 	msleep(1);
 
 	if (i2c_writebytes(state,state->config->demod_address,run_buf,2)) {
-		printk(KERN_WARNING "or51211: load_firmware error 3\n");
+		pr_warn("error 3\n");
 		return -1;
 	}
 
 	/* Wait at least 5 msec */
 	msleep(10);
 	if (i2c_writebytes(state,state->config->demod_address,run_buf,2)) {
-		printk(KERN_WARNING "or51211: load_firmware error 4\n");
+		pr_warn("error 4\n");
 		return -1;
 	}
 	msleep(10);
 
-	printk("or51211: Done.\n");
+	pr_info("Done.\n");
 	return 0;
 };
 
@@ -173,14 +171,14 @@ static int or51211_setmode(struct dvb_frontend* fe, int mode)
 	state->config->setmode(fe, mode);
 
 	if (i2c_writebytes(state,state->config->demod_address,run_buf,2)) {
-		printk(KERN_WARNING "or51211: setmode error 1\n");
+		pr_warn("error 1\n");
 		return -1;
 	}
 
 	/* Wait at least 5 msec */
 	msleep(10);
 	if (i2c_writebytes(state,state->config->demod_address,run_buf,2)) {
-		printk(KERN_WARNING "or51211: setmode error 2\n");
+		pr_warn("error 2\n");
 		return -1;
 	}
 
@@ -196,7 +194,7 @@ static int or51211_setmode(struct dvb_frontend* fe, int mode)
 	 *             normal +/-150kHz Carrier acquisition range
 	 */
 	if (i2c_writebytes(state,state->config->demod_address,cmd_buf,3)) {
-		printk(KERN_WARNING "or51211: setmode error 3\n");
+		pr_warn("error 3\n");
 		return -1;
 	}
 
@@ -206,14 +204,14 @@ static int or51211_setmode(struct dvb_frontend* fe, int mode)
 	rec_buf[3] = 0x00;
 	msleep(20);
 	if (i2c_writebytes(state,state->config->demod_address,rec_buf,3)) {
-		printk(KERN_WARNING "or51211: setmode error 5\n");
+		pr_warn("error 5\n");
 	}
 	msleep(3);
 	if (i2c_readbytes(state,state->config->demod_address,&rec_buf[10],2)) {
-		printk(KERN_WARNING "or51211: setmode error 6");
+		pr_warn("error 6\n");
 		return -1;
 	}
-	dprintk("setmode rec status %02x %02x\n",rec_buf[10],rec_buf[11]);
+	dprintk("rec status %02x %02x\n", rec_buf[10], rec_buf[11]);
 
 	return 0;
 }
@@ -248,15 +246,15 @@ static int or51211_read_status(struct dvb_frontend* fe, fe_status_t* status)
 
 	/* Receiver Status */
 	if (i2c_writebytes(state,state->config->demod_address,snd_buf,3)) {
-		printk(KERN_WARNING "or51132: read_status write error\n");
+		pr_warn("write error\n");
 		return -1;
 	}
 	msleep(3);
 	if (i2c_readbytes(state,state->config->demod_address,rec_buf,2)) {
-		printk(KERN_WARNING "or51132: read_status read error\n");
+		pr_warn("read error\n");
 		return -1;
 	}
-	dprintk("read_status %x %x\n",rec_buf[0],rec_buf[1]);
+	dprintk("%x %x\n", rec_buf[0], rec_buf[1]);
 
 	if (rec_buf[0] &  0x01) { /* Receiver Lock */
 		*status |= FE_HAS_SIGNAL;
@@ -306,20 +304,18 @@ static int or51211_read_snr(struct dvb_frontend* fe, u16* snr)
 	snd_buf[2] = 0x04;
 
 	if (i2c_writebytes(state,state->config->demod_address,snd_buf,3)) {
-		printk(KERN_WARNING "%s: error writing snr reg\n",
-		       __func__);
+		pr_warn("error writing snr reg\n");
 		return -1;
 	}
 	if (i2c_readbytes(state,state->config->demod_address,rec_buf,2)) {
-		printk(KERN_WARNING "%s: read_status read error\n",
-		       __func__);
+		pr_warn("read_status read error\n");
 		return -1;
 	}
 
 	state->snr = calculate_snr(rec_buf[0], 89599047);
 	*snr = (state->snr) >> 16;
 
-	dprintk("%s: noise = 0x%02x, snr = %d.%02d dB\n", __func__, rec_buf[0],
+	dprintk("noise = 0x%02x, snr = %d.%02d dB\n", rec_buf[0],
 		state->snr >> 24, (((state->snr>>8) & 0xffff) * 100) >> 16);
 
 	return 0;
@@ -375,25 +371,24 @@ static int or51211_init(struct dvb_frontend* fe)
 
 	if (!state->initialized) {
 		/* Request the firmware, this will block until it uploads */
-		printk(KERN_INFO "or51211: Waiting for firmware upload "
-		       "(%s)...\n", OR51211_DEFAULT_FIRMWARE);
+		pr_info("Waiting for firmware upload (%s)...\n",
+			OR51211_DEFAULT_FIRMWARE);
 		ret = config->request_firmware(fe, &fw,
 					       OR51211_DEFAULT_FIRMWARE);
-		printk(KERN_INFO "or51211:Got Hotplug firmware\n");
+		pr_info("Got Hotplug firmware\n");
 		if (ret) {
-			printk(KERN_WARNING "or51211: No firmware uploaded "
-			       "(timeout or file not found?)\n");
+			pr_warn("No firmware uploaded "
+				"(timeout or file not found?)\n");
 			return ret;
 		}
 
 		ret = or51211_load_firmware(fe, fw);
 		release_firmware(fw);
 		if (ret) {
-			printk(KERN_WARNING "or51211: Writing firmware to "
-			       "device failed!\n");
+			pr_warn("Writing firmware to device failed!\n");
 			return ret;
 		}
-		printk(KERN_INFO "or51211: Firmware upload complete.\n");
+		pr_info("Firmware upload complete.\n");
 
 		/* Set operation mode in Receiver 1 register;
 		 * type 1:
@@ -406,7 +401,7 @@ static int or51211_init(struct dvb_frontend* fe)
 		 */
 		if (i2c_writebytes(state,state->config->demod_address,
 				   cmd_buf,3)) {
-			printk(KERN_WARNING "or51211: Load DVR Error 5\n");
+			pr_warn("Load DVR Error 5\n");
 			return -1;
 		}
 
@@ -419,13 +414,13 @@ static int or51211_init(struct dvb_frontend* fe)
 		msleep(30);
 		if (i2c_writebytes(state,state->config->demod_address,
 				   rec_buf,3)) {
-			printk(KERN_WARNING "or51211: Load DVR Error A\n");
+			pr_warn("Load DVR Error A\n");
 			return -1;
 		}
 		msleep(3);
 		if (i2c_readbytes(state,state->config->demod_address,
 				  &rec_buf[10],2)) {
-			printk(KERN_WARNING "or51211: Load DVR Error B\n");
+			pr_warn("Load DVR Error B\n");
 			return -1;
 		}
 
@@ -436,13 +431,13 @@ static int or51211_init(struct dvb_frontend* fe)
 		msleep(20);
 		if (i2c_writebytes(state,state->config->demod_address,
 				   rec_buf,3)) {
-			printk(KERN_WARNING "or51211: Load DVR Error C\n");
+			pr_warn("Load DVR Error C\n");
 			return -1;
 		}
 		msleep(3);
 		if (i2c_readbytes(state,state->config->demod_address,
 				  &rec_buf[12],2)) {
-			printk(KERN_WARNING "or51211: Load DVR Error D\n");
+			pr_warn("Load DVR Error D\n");
 			return -1;
 		}
 
@@ -454,16 +449,14 @@ static int or51211_init(struct dvb_frontend* fe)
 			get_ver_buf[4] = i+1;
 			if (i2c_writebytes(state,state->config->demod_address,
 					   get_ver_buf,5)) {
-				printk(KERN_WARNING "or51211:Load DVR Error 6"
-				       " - %d\n",i);
+				pr_warn("Load DVR Error 6 - %d\n", i);
 				return -1;
 			}
 			msleep(3);
 
 			if (i2c_readbytes(state,state->config->demod_address,
 					  &rec_buf[i*2],2)) {
-				printk(KERN_WARNING "or51211:Load DVR Error 7"
-				       " - %d\n",i);
+				pr_warn("Load DVR Error 7 - %d\n", i);
 				return -1;
 			}
 			/* If we didn't receive the right index, try again */
@@ -473,10 +466,9 @@ static int or51211_init(struct dvb_frontend* fe)
 		}
 		dprintk("read_fwbits %10ph\n", rec_buf);
 
-		printk(KERN_INFO "or51211: ver TU%02x%02x%02x VSB mode %02x"
-		       " Status %02x\n",
-		       rec_buf[2], rec_buf[4],rec_buf[6],
-		       rec_buf[12],rec_buf[10]);
+		pr_info("ver TU%02x%02x%02x VSB mode %02x Status %02x\n",
+			rec_buf[2], rec_buf[4], rec_buf[6], rec_buf[12],
+			rec_buf[10]);
 
 		rec_buf[0] = 0x04;
 		rec_buf[1] = 0x00;
@@ -485,13 +477,13 @@ static int or51211_init(struct dvb_frontend* fe)
 		msleep(20);
 		if (i2c_writebytes(state,state->config->demod_address,
 				   rec_buf,3)) {
-			printk(KERN_WARNING "or51211: Load DVR Error 8\n");
+			pr_warn("Load DVR Error 8\n");
 			return -1;
 		}
 		msleep(20);
 		if (i2c_readbytes(state,state->config->demod_address,
 				  &rec_buf[8],2)) {
-			printk(KERN_WARNING "or51211: Load DVR Error 9\n");
+			pr_warn("Load DVR Error 9\n");
 			return -1;
 		}
 		state->initialized = 1;

commit 870f31cbf03e0c759900eea2feb276b2fe6558f4
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Mon Dec 17 22:10:00 2012 -0300

    [media] or51211: use %*ph[N] to dump small buffers
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Michael Krufky <mkrufky@linuxtv.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/dvb-frontends/or51211.c b/drivers/media/dvb-frontends/or51211.c
index c625b57b4333..1af997eb0578 100644
--- a/drivers/media/dvb-frontends/or51211.c
+++ b/drivers/media/dvb-frontends/or51211.c
@@ -471,10 +471,7 @@ static int or51211_init(struct dvb_frontend* fe)
 			  i--;
 			}
 		}
-		dprintk("read_fwbits %x %x %x %x %x %x %x %x %x %x\n",
-			rec_buf[0], rec_buf[1], rec_buf[2], rec_buf[3],
-			rec_buf[4], rec_buf[5], rec_buf[6], rec_buf[7],
-			rec_buf[8], rec_buf[9]);
+		dprintk("read_fwbits %10ph\n", rec_buf);
 
 		printk(KERN_INFO "or51211: ver TU%02x%02x%02x VSB mode %02x"
 		       " Status %02x\n",

commit 9a0bf528b4d66b605f02634236da085595c22101
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Mon Aug 13 23:13:41 2012 -0300

    [media] move the dvb/frontends to drivers/media/dvb-frontends
    
    Raise the DVB frontends one level up, as the intention is to remove
    the drivers/media/dvb directory.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/dvb-frontends/or51211.c b/drivers/media/dvb-frontends/or51211.c
new file mode 100644
index 000000000000..c625b57b4333
--- /dev/null
+++ b/drivers/media/dvb-frontends/or51211.c
@@ -0,0 +1,581 @@
+/*
+ *    Support for OR51211 (pcHDTV HD-2000) - VSB
+ *
+ *    Copyright (C) 2005 Kirk Lapray <kirk_lapray@bigfoot.com>
+ *
+ *    Based on code from Jack Kelliher (kelliher@xmission.com)
+ *                           Copyright (C) 2002 & pcHDTV, inc.
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License
+ *    along with this program; if not, write to the Free Software
+ *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+*/
+
+/*
+ * This driver needs external firmware. Please use the command
+ * "<kerneldir>/Documentation/dvb/get_dvb_firmware or51211" to
+ * download/extract it, and then copy it to /usr/lib/hotplug/firmware
+ * or /lib/firmware (depending on configuration of firmware hotplug).
+ */
+#define OR51211_DEFAULT_FIRMWARE "dvb-fe-or51211.fw"
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/firmware.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <asm/byteorder.h>
+
+#include "dvb_math.h"
+#include "dvb_frontend.h"
+#include "or51211.h"
+
+static int debug;
+#define dprintk(args...) \
+	do { \
+		if (debug) printk(KERN_DEBUG "or51211: " args); \
+	} while (0)
+
+static u8 run_buf[] = {0x7f,0x01};
+static u8 cmd_buf[] = {0x04,0x01,0x50,0x80,0x06}; // ATSC
+
+struct or51211_state {
+
+	struct i2c_adapter* i2c;
+
+	/* Configuration settings */
+	const struct or51211_config* config;
+
+	struct dvb_frontend frontend;
+	struct bt878* bt;
+
+	/* Demodulator private data */
+	u8 initialized:1;
+	u32 snr; /* Result of last SNR claculation */
+
+	/* Tuner private data */
+	u32 current_frequency;
+};
+
+static int i2c_writebytes (struct or51211_state* state, u8 reg, const u8 *buf,
+			   int len)
+{
+	int err;
+	struct i2c_msg msg;
+	msg.addr	= reg;
+	msg.flags	= 0;
+	msg.len		= len;
+	msg.buf		= (u8 *)buf;
+
+	if ((err = i2c_transfer (state->i2c, &msg, 1)) != 1) {
+		printk(KERN_WARNING "or51211: i2c_writebytes error "
+		       "(addr %02x, err == %i)\n", reg, err);
+		return -EREMOTEIO;
+	}
+
+	return 0;
+}
+
+static int i2c_readbytes(struct or51211_state *state, u8 reg, u8 *buf, int len)
+{
+	int err;
+	struct i2c_msg msg;
+	msg.addr	= reg;
+	msg.flags	= I2C_M_RD;
+	msg.len		= len;
+	msg.buf		= buf;
+
+	if ((err = i2c_transfer (state->i2c, &msg, 1)) != 1) {
+		printk(KERN_WARNING "or51211: i2c_readbytes error "
+		       "(addr %02x, err == %i)\n", reg, err);
+		return -EREMOTEIO;
+	}
+
+	return 0;
+}
+
+static int or51211_load_firmware (struct dvb_frontend* fe,
+				  const struct firmware *fw)
+{
+	struct or51211_state* state = fe->demodulator_priv;
+	u8 tudata[585];
+	int i;
+
+	dprintk("Firmware is %zd bytes\n",fw->size);
+
+	/* Get eprom data */
+	tudata[0] = 17;
+	if (i2c_writebytes(state,0x50,tudata,1)) {
+		printk(KERN_WARNING "or51211:load_firmware error eprom addr\n");
+		return -1;
+	}
+	if (i2c_readbytes(state,0x50,&tudata[145],192)) {
+		printk(KERN_WARNING "or51211: load_firmware error eprom\n");
+		return -1;
+	}
+
+	/* Create firmware buffer */
+	for (i = 0; i < 145; i++)
+		tudata[i] = fw->data[i];
+
+	for (i = 0; i < 248; i++)
+		tudata[i+337] = fw->data[145+i];
+
+	state->config->reset(fe);
+
+	if (i2c_writebytes(state,state->config->demod_address,tudata,585)) {
+		printk(KERN_WARNING "or51211: load_firmware error 1\n");
+		return -1;
+	}
+	msleep(1);
+
+	if (i2c_writebytes(state,state->config->demod_address,
+			   &fw->data[393],8125)) {
+		printk(KERN_WARNING "or51211: load_firmware error 2\n");
+		return -1;
+	}
+	msleep(1);
+
+	if (i2c_writebytes(state,state->config->demod_address,run_buf,2)) {
+		printk(KERN_WARNING "or51211: load_firmware error 3\n");
+		return -1;
+	}
+
+	/* Wait at least 5 msec */
+	msleep(10);
+	if (i2c_writebytes(state,state->config->demod_address,run_buf,2)) {
+		printk(KERN_WARNING "or51211: load_firmware error 4\n");
+		return -1;
+	}
+	msleep(10);
+
+	printk("or51211: Done.\n");
+	return 0;
+};
+
+static int or51211_setmode(struct dvb_frontend* fe, int mode)
+{
+	struct or51211_state* state = fe->demodulator_priv;
+	u8 rec_buf[14];
+
+	state->config->setmode(fe, mode);
+
+	if (i2c_writebytes(state,state->config->demod_address,run_buf,2)) {
+		printk(KERN_WARNING "or51211: setmode error 1\n");
+		return -1;
+	}
+
+	/* Wait at least 5 msec */
+	msleep(10);
+	if (i2c_writebytes(state,state->config->demod_address,run_buf,2)) {
+		printk(KERN_WARNING "or51211: setmode error 2\n");
+		return -1;
+	}
+
+	msleep(10);
+
+	/* Set operation mode in Receiver 1 register;
+	 * type 1:
+	 * data 0x50h  Automatic sets receiver channel conditions
+	 *             Automatic NTSC rejection filter
+	 *             Enable  MPEG serial data output
+	 *             MPEG2tr
+	 *             High tuner phase noise
+	 *             normal +/-150kHz Carrier acquisition range
+	 */
+	if (i2c_writebytes(state,state->config->demod_address,cmd_buf,3)) {
+		printk(KERN_WARNING "or51211: setmode error 3\n");
+		return -1;
+	}
+
+	rec_buf[0] = 0x04;
+	rec_buf[1] = 0x00;
+	rec_buf[2] = 0x03;
+	rec_buf[3] = 0x00;
+	msleep(20);
+	if (i2c_writebytes(state,state->config->demod_address,rec_buf,3)) {
+		printk(KERN_WARNING "or51211: setmode error 5\n");
+	}
+	msleep(3);
+	if (i2c_readbytes(state,state->config->demod_address,&rec_buf[10],2)) {
+		printk(KERN_WARNING "or51211: setmode error 6");
+		return -1;
+	}
+	dprintk("setmode rec status %02x %02x\n",rec_buf[10],rec_buf[11]);
+
+	return 0;
+}
+
+static int or51211_set_parameters(struct dvb_frontend *fe)
+{
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+	struct or51211_state* state = fe->demodulator_priv;
+
+	/* Change only if we are actually changing the channel */
+	if (state->current_frequency != p->frequency) {
+		if (fe->ops.tuner_ops.set_params) {
+			fe->ops.tuner_ops.set_params(fe);
+			if (fe->ops.i2c_gate_ctrl) fe->ops.i2c_gate_ctrl(fe, 0);
+		}
+
+		/* Set to ATSC mode */
+		or51211_setmode(fe,0);
+
+		/* Update current frequency */
+		state->current_frequency = p->frequency;
+	}
+	return 0;
+}
+
+static int or51211_read_status(struct dvb_frontend* fe, fe_status_t* status)
+{
+	struct or51211_state* state = fe->demodulator_priv;
+	unsigned char rec_buf[2];
+	unsigned char snd_buf[] = {0x04,0x00,0x03,0x00};
+	*status = 0;
+
+	/* Receiver Status */
+	if (i2c_writebytes(state,state->config->demod_address,snd_buf,3)) {
+		printk(KERN_WARNING "or51132: read_status write error\n");
+		return -1;
+	}
+	msleep(3);
+	if (i2c_readbytes(state,state->config->demod_address,rec_buf,2)) {
+		printk(KERN_WARNING "or51132: read_status read error\n");
+		return -1;
+	}
+	dprintk("read_status %x %x\n",rec_buf[0],rec_buf[1]);
+
+	if (rec_buf[0] &  0x01) { /* Receiver Lock */
+		*status |= FE_HAS_SIGNAL;
+		*status |= FE_HAS_CARRIER;
+		*status |= FE_HAS_VITERBI;
+		*status |= FE_HAS_SYNC;
+		*status |= FE_HAS_LOCK;
+	}
+	return 0;
+}
+
+/* Calculate SNR estimation (scaled by 2^24)
+
+   8-VSB SNR equation from Oren datasheets
+
+   For 8-VSB:
+     SNR[dB] = 10 * log10(219037.9454 / MSE^2 )
+
+   We re-write the snr equation as:
+     SNR * 2^24 = 10*(c - 2*intlog10(MSE))
+   Where for 8-VSB, c = log10(219037.9454) * 2^24 */
+
+static u32 calculate_snr(u32 mse, u32 c)
+{
+	if (mse == 0) /* No signal */
+		return 0;
+
+	mse = 2*intlog10(mse);
+	if (mse > c) {
+		/* Negative SNR, which is possible, but realisticly the
+		demod will lose lock before the signal gets this bad.  The
+		API only allows for unsigned values, so just return 0 */
+		return 0;
+	}
+	return 10*(c - mse);
+}
+
+static int or51211_read_snr(struct dvb_frontend* fe, u16* snr)
+{
+	struct or51211_state* state = fe->demodulator_priv;
+	u8 rec_buf[2];
+	u8 snd_buf[3];
+
+	/* SNR after Equalizer */
+	snd_buf[0] = 0x04;
+	snd_buf[1] = 0x00;
+	snd_buf[2] = 0x04;
+
+	if (i2c_writebytes(state,state->config->demod_address,snd_buf,3)) {
+		printk(KERN_WARNING "%s: error writing snr reg\n",
+		       __func__);
+		return -1;
+	}
+	if (i2c_readbytes(state,state->config->demod_address,rec_buf,2)) {
+		printk(KERN_WARNING "%s: read_status read error\n",
+		       __func__);
+		return -1;
+	}
+
+	state->snr = calculate_snr(rec_buf[0], 89599047);
+	*snr = (state->snr) >> 16;
+
+	dprintk("%s: noise = 0x%02x, snr = %d.%02d dB\n", __func__, rec_buf[0],
+		state->snr >> 24, (((state->snr>>8) & 0xffff) * 100) >> 16);
+
+	return 0;
+}
+
+static int or51211_read_signal_strength(struct dvb_frontend* fe, u16* strength)
+{
+	/* Calculate Strength from SNR up to 35dB */
+	/* Even though the SNR can go higher than 35dB, there is some comfort */
+	/* factor in having a range of strong signals that can show at 100%   */
+	struct or51211_state* state = (struct or51211_state*)fe->demodulator_priv;
+	u16 snr;
+	int ret;
+
+	ret = fe->ops.read_snr(fe, &snr);
+	if (ret != 0)
+		return ret;
+	/* Rather than use the 8.8 value snr, use state->snr which is 8.24 */
+	/* scale the range 0 - 35*2^24 into 0 - 65535 */
+	if (state->snr >= 8960 * 0x10000)
+		*strength = 0xffff;
+	else
+		*strength = state->snr / 8960;
+
+	return 0;
+}
+
+static int or51211_read_ber(struct dvb_frontend* fe, u32* ber)
+{
+	*ber = -ENOSYS;
+	return 0;
+}
+
+static int or51211_read_ucblocks(struct dvb_frontend* fe, u32* ucblocks)
+{
+	*ucblocks = -ENOSYS;
+	return 0;
+}
+
+static int or51211_sleep(struct dvb_frontend* fe)
+{
+	return 0;
+}
+
+static int or51211_init(struct dvb_frontend* fe)
+{
+	struct or51211_state* state = fe->demodulator_priv;
+	const struct or51211_config* config = state->config;
+	const struct firmware* fw;
+	unsigned char get_ver_buf[] = {0x04,0x00,0x30,0x00,0x00};
+	unsigned char rec_buf[14];
+	int ret,i;
+
+	if (!state->initialized) {
+		/* Request the firmware, this will block until it uploads */
+		printk(KERN_INFO "or51211: Waiting for firmware upload "
+		       "(%s)...\n", OR51211_DEFAULT_FIRMWARE);
+		ret = config->request_firmware(fe, &fw,
+					       OR51211_DEFAULT_FIRMWARE);
+		printk(KERN_INFO "or51211:Got Hotplug firmware\n");
+		if (ret) {
+			printk(KERN_WARNING "or51211: No firmware uploaded "
+			       "(timeout or file not found?)\n");
+			return ret;
+		}
+
+		ret = or51211_load_firmware(fe, fw);
+		release_firmware(fw);
+		if (ret) {
+			printk(KERN_WARNING "or51211: Writing firmware to "
+			       "device failed!\n");
+			return ret;
+		}
+		printk(KERN_INFO "or51211: Firmware upload complete.\n");
+
+		/* Set operation mode in Receiver 1 register;
+		 * type 1:
+		 * data 0x50h  Automatic sets receiver channel conditions
+		 *             Automatic NTSC rejection filter
+		 *             Enable  MPEG serial data output
+		 *             MPEG2tr
+		 *             High tuner phase noise
+		 *             normal +/-150kHz Carrier acquisition range
+		 */
+		if (i2c_writebytes(state,state->config->demod_address,
+				   cmd_buf,3)) {
+			printk(KERN_WARNING "or51211: Load DVR Error 5\n");
+			return -1;
+		}
+
+		/* Read back ucode version to besure we loaded correctly */
+		/* and are really up and running */
+		rec_buf[0] = 0x04;
+		rec_buf[1] = 0x00;
+		rec_buf[2] = 0x03;
+		rec_buf[3] = 0x00;
+		msleep(30);
+		if (i2c_writebytes(state,state->config->demod_address,
+				   rec_buf,3)) {
+			printk(KERN_WARNING "or51211: Load DVR Error A\n");
+			return -1;
+		}
+		msleep(3);
+		if (i2c_readbytes(state,state->config->demod_address,
+				  &rec_buf[10],2)) {
+			printk(KERN_WARNING "or51211: Load DVR Error B\n");
+			return -1;
+		}
+
+		rec_buf[0] = 0x04;
+		rec_buf[1] = 0x00;
+		rec_buf[2] = 0x01;
+		rec_buf[3] = 0x00;
+		msleep(20);
+		if (i2c_writebytes(state,state->config->demod_address,
+				   rec_buf,3)) {
+			printk(KERN_WARNING "or51211: Load DVR Error C\n");
+			return -1;
+		}
+		msleep(3);
+		if (i2c_readbytes(state,state->config->demod_address,
+				  &rec_buf[12],2)) {
+			printk(KERN_WARNING "or51211: Load DVR Error D\n");
+			return -1;
+		}
+
+		for (i = 0; i < 8; i++)
+			rec_buf[i]=0xed;
+
+		for (i = 0; i < 5; i++) {
+			msleep(30);
+			get_ver_buf[4] = i+1;
+			if (i2c_writebytes(state,state->config->demod_address,
+					   get_ver_buf,5)) {
+				printk(KERN_WARNING "or51211:Load DVR Error 6"
+				       " - %d\n",i);
+				return -1;
+			}
+			msleep(3);
+
+			if (i2c_readbytes(state,state->config->demod_address,
+					  &rec_buf[i*2],2)) {
+				printk(KERN_WARNING "or51211:Load DVR Error 7"
+				       " - %d\n",i);
+				return -1;
+			}
+			/* If we didn't receive the right index, try again */
+			if ((int)rec_buf[i*2+1]!=i+1){
+			  i--;
+			}
+		}
+		dprintk("read_fwbits %x %x %x %x %x %x %x %x %x %x\n",
+			rec_buf[0], rec_buf[1], rec_buf[2], rec_buf[3],
+			rec_buf[4], rec_buf[5], rec_buf[6], rec_buf[7],
+			rec_buf[8], rec_buf[9]);
+
+		printk(KERN_INFO "or51211: ver TU%02x%02x%02x VSB mode %02x"
+		       " Status %02x\n",
+		       rec_buf[2], rec_buf[4],rec_buf[6],
+		       rec_buf[12],rec_buf[10]);
+
+		rec_buf[0] = 0x04;
+		rec_buf[1] = 0x00;
+		rec_buf[2] = 0x03;
+		rec_buf[3] = 0x00;
+		msleep(20);
+		if (i2c_writebytes(state,state->config->demod_address,
+				   rec_buf,3)) {
+			printk(KERN_WARNING "or51211: Load DVR Error 8\n");
+			return -1;
+		}
+		msleep(20);
+		if (i2c_readbytes(state,state->config->demod_address,
+				  &rec_buf[8],2)) {
+			printk(KERN_WARNING "or51211: Load DVR Error 9\n");
+			return -1;
+		}
+		state->initialized = 1;
+	}
+
+	return 0;
+}
+
+static int or51211_get_tune_settings(struct dvb_frontend* fe,
+				     struct dvb_frontend_tune_settings* fesettings)
+{
+	fesettings->min_delay_ms = 500;
+	fesettings->step_size = 0;
+	fesettings->max_drift = 0;
+	return 0;
+}
+
+static void or51211_release(struct dvb_frontend* fe)
+{
+	struct or51211_state* state = fe->demodulator_priv;
+	state->config->sleep(fe);
+	kfree(state);
+}
+
+static struct dvb_frontend_ops or51211_ops;
+
+struct dvb_frontend* or51211_attach(const struct or51211_config* config,
+				    struct i2c_adapter* i2c)
+{
+	struct or51211_state* state = NULL;
+
+	/* Allocate memory for the internal state */
+	state = kzalloc(sizeof(struct or51211_state), GFP_KERNEL);
+	if (state == NULL)
+		return NULL;
+
+	/* Setup the state */
+	state->config = config;
+	state->i2c = i2c;
+	state->initialized = 0;
+	state->current_frequency = 0;
+
+	/* Create dvb_frontend */
+	memcpy(&state->frontend.ops, &or51211_ops, sizeof(struct dvb_frontend_ops));
+	state->frontend.demodulator_priv = state;
+	return &state->frontend;
+}
+
+static struct dvb_frontend_ops or51211_ops = {
+	.delsys = { SYS_ATSC, SYS_DVBC_ANNEX_B },
+	.info = {
+		.name               = "Oren OR51211 VSB Frontend",
+		.frequency_min      = 44000000,
+		.frequency_max      = 958000000,
+		.frequency_stepsize = 166666,
+		.caps = FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |
+			FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |
+			FE_CAN_8VSB
+	},
+
+	.release = or51211_release,
+
+	.init = or51211_init,
+	.sleep = or51211_sleep,
+
+	.set_frontend = or51211_set_parameters,
+	.get_tune_settings = or51211_get_tune_settings,
+
+	.read_status = or51211_read_status,
+	.read_ber = or51211_read_ber,
+	.read_signal_strength = or51211_read_signal_strength,
+	.read_snr = or51211_read_snr,
+	.read_ucblocks = or51211_read_ucblocks,
+};
+
+module_param(debug, int, 0644);
+MODULE_PARM_DESC(debug, "Turn on/off frontend debugging (default:off).");
+
+MODULE_DESCRIPTION("Oren OR51211 VSB [pcHDTV HD-2000] Demodulator Driver");
+MODULE_AUTHOR("Kirk Lapray");
+MODULE_LICENSE("GPL");
+
+EXPORT_SYMBOL(or51211_attach);
+
