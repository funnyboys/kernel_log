commit 722b3c140dd471ee484b072793addbb7e2cbd999
Author: Brad Love <brad@nextdimension.cc>
Date:   Thu Nov 14 21:04:07 2019 +0100

    media: lgdt3306a: Add CNR v5 stat
    
    The CNR is already calculated, so populate DVBv5 CNR stat
    during read_status.
    
    Signed-off-by: Brad Love <brad@nextdimension.cc>
    Signed-off-by: Sean Young <sean@mess.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+huawei@kernel.org>

diff --git a/drivers/media/dvb-frontends/lgdt3306a.c b/drivers/media/dvb-frontends/lgdt3306a.c
index 6c4adec58174..d3c330e035c4 100644
--- a/drivers/media/dvb-frontends/lgdt3306a.c
+++ b/drivers/media/dvb-frontends/lgdt3306a.c
@@ -846,6 +846,7 @@ static int lgdt3306a_fe_sleep(struct dvb_frontend *fe)
 static int lgdt3306a_init(struct dvb_frontend *fe)
 {
 	struct lgdt3306a_state *state = fe->demodulator_priv;
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
 	u8 val;
 	int ret;
 
@@ -997,6 +998,9 @@ static int lgdt3306a_init(struct dvb_frontend *fe)
 	ret = lgdt3306a_sleep(state);
 	lg_chkerr(ret);
 
+	c->cnr.len = 1;
+	c->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+
 fail:
 	return ret;
 }
@@ -1597,6 +1601,7 @@ static int lgdt3306a_read_status(struct dvb_frontend *fe,
 				 enum fe_status *status)
 {
 	struct lgdt3306a_state *state = fe->demodulator_priv;
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
 	u16 strength = 0;
 	int ret = 0;
 
@@ -1637,6 +1642,15 @@ static int lgdt3306a_read_status(struct dvb_frontend *fe,
 		default:
 			ret = -EINVAL;
 		}
+
+		if (*status & FE_HAS_SYNC) {
+			c->cnr.len = 1;
+			c->cnr.stat[0].scale = FE_SCALE_DECIBEL;
+			c->cnr.stat[0].svalue = lgdt3306a_calculate_snr_x100(state) * 10;
+		} else {
+			c->cnr.len = 1;
+			c->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+		}
 	}
 	return ret;
 }

commit c942fddf8793b2013be8c901b47d0a8dc02bf99f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:06 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 157
    
    Based on 3 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [kishon] [vijay] [abraham]
      [i] [kishon]@[ti] [com] this program is distributed in the hope that
      it will be useful but without any warranty without even the implied
      warranty of merchantability or fitness for a particular purpose see
      the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [graeme] [gregory]
      [gg]@[slimlogic] [co] [uk] [author] [kishon] [vijay] [abraham] [i]
      [kishon]@[ti] [com] [based] [on] [twl6030]_[usb] [c] [author] [hema]
      [hk] [hemahk]@[ti] [com] this program is distributed in the hope
      that it will be useful but without any warranty without even the
      implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1105 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.202006027@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/media/dvb-frontends/lgdt3306a.c b/drivers/media/dvb-frontends/lgdt3306a.c
index 99c6289ae585..6c4adec58174 100644
--- a/drivers/media/dvb-frontends/lgdt3306a.c
+++ b/drivers/media/dvb-frontends/lgdt3306a.c
@@ -1,19 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *    Support for LGDT3306A - 8VSB/QAM-B
  *
  *    Copyright (C) 2013 Fred Richter <frichter@hauppauge.com>
  *    - driver structure based on lgdt3305.[ch] by Michael Krufky
  *    - code based on LG3306_V0.35 API by LG Electronics Inc.
- *
- *    This program is free software; you can redistribute it and/or modify
- *    it under the terms of the GNU General Public License as published by
- *    the Free Software Foundation; either version 2 of the License, or
- *    (at your option) any later version.
- *
- *    This program is distributed in the hope that it will be useful,
- *    but WITHOUT ANY WARRANTY; without even the implied warranty of
- *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *    GNU General Public License for more details.
  */
 
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt

commit c9b7d8f252a5a6f8ca6e948151367cbc7bc4b776
Author: Kangjie Lu <kjlu@umn.edu>
Date:   Thu Dec 20 02:48:42 2018 -0500

    media: lgdt3306a: fix a missing check of return value
    
    If lgdt3306a_read_reg() fails, the read data in "val" is incorrect, thus
    shouldn't be further used. The fix inserts a check for the return value
    of lgdt3306a_read_reg(). If it fails, goto fail.
    
    Signed-off-by: Kangjie Lu <kjlu@umn.edu>
    Signed-off-by: Sean Young <sean@mess.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/dvb-frontends/lgdt3306a.c b/drivers/media/dvb-frontends/lgdt3306a.c
index cee9c83e48de..99c6289ae585 100644
--- a/drivers/media/dvb-frontends/lgdt3306a.c
+++ b/drivers/media/dvb-frontends/lgdt3306a.c
@@ -1685,7 +1685,10 @@ static int lgdt3306a_read_signal_strength(struct dvb_frontend *fe,
 	case QAM_256:
 	case QAM_AUTO:
 		/* need to know actual modulation to set proper SNR baseline */
-		lgdt3306a_read_reg(state, 0x00a6, &val);
+		ret = lgdt3306a_read_reg(state, 0x00a6, &val);
+		if (lg_chkerr(ret))
+			goto fail;
+
 		if(val & 0x04)
 			ref_snr = 2800; /* QAM-256 28dB */
 		else

commit 2c4746cf45b957962c03f1c10a3d068d7db68924
Author: zhong jiang <zhongjiang@huawei.com>
Date:   Wed Sep 19 04:16:09 2018 -0400

    media: dvb-frontends: Use kmemdup instead of duplicating its function
    
    kmemdup has implemented the function that kmalloc() + memcpy().
    We prefer to kmemdup rather than code opened implementation.
    
    Signed-off-by: zhong jiang <zhongjiang@huawei.com>
    Signed-off-by: Sean Young <sean@mess.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/dvb-frontends/lgdt3306a.c b/drivers/media/dvb-frontends/lgdt3306a.c
index 0e1f5daaf20c..cee9c83e48de 100644
--- a/drivers/media/dvb-frontends/lgdt3306a.c
+++ b/drivers/media/dvb-frontends/lgdt3306a.c
@@ -2205,15 +2205,13 @@ static int lgdt3306a_probe(struct i2c_client *client,
 	struct dvb_frontend *fe;
 	int ret;
 
-	config = kzalloc(sizeof(struct lgdt3306a_config), GFP_KERNEL);
+	config = kmemdup(client->dev.platform_data,
+			 sizeof(struct lgdt3306a_config), GFP_KERNEL);
 	if (config == NULL) {
 		ret = -ENOMEM;
 		goto fail;
 	}
 
-	memcpy(config, client->dev.platform_data,
-			sizeof(struct lgdt3306a_config));
-
 	config->i2c_addr = client->addr;
 	fe = lgdt3306a_attach(config, client->adapter);
 	if (fe == NULL) {

commit f1b1eabff0eb3fc46b06668de8174c0f23b271fd
Author: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
Date:   Thu Jul 5 18:59:36 2018 -0400

    media: dvb: represent min/max/step/tolerance freqs in Hz
    
    Right now, satellite frontend drivers specify frequencies in kHz,
    while terrestrial/cable ones specify in Hz. That's confusing
    for developers.
    
    However, the main problem is that universal frontends capable
    of handling both satellite and non-satelite delivery systems
    are appearing. We end by needing to hack the drivers in
    order to support such hybrid frontends.
    
    So, convert everything to specify frontend frequencies in Hz.
    
    Tested-by: Katsuhiro Suzuki <suzuki.katsuhiro@socionext.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/dvb-frontends/lgdt3306a.c b/drivers/media/dvb-frontends/lgdt3306a.c
index 32de824476db..0e1f5daaf20c 100644
--- a/drivers/media/dvb-frontends/lgdt3306a.c
+++ b/drivers/media/dvb-frontends/lgdt3306a.c
@@ -2157,9 +2157,9 @@ static const struct dvb_frontend_ops lgdt3306a_ops = {
 	.delsys = { SYS_ATSC, SYS_DVBC_ANNEX_B },
 	.info = {
 		.name = "LG Electronics LGDT3306A VSB/QAM Frontend",
-		.frequency_min      = 54000000,
-		.frequency_max      = 858000000,
-		.frequency_stepsize = 62500,
+		.frequency_min_hz      =  54 * MHz,
+		.frequency_max_hz      = 858 * MHz,
+		.frequency_stepsize_hz = 62500,
 		.caps = FE_CAN_QAM_AUTO | FE_CAN_QAM_64 | FE_CAN_QAM_256 | FE_CAN_8VSB
 	},
 	.i2c_gate_ctrl        = lgdt3306a_i2c_gate_ctrl,

commit f172fe9fd86bf25cf0776ef7733d20576843a0d4
Author: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
Date:   Tue Apr 24 09:19:04 2018 -0400

    media: lgdt3306a: fix lgdt3306a_search()'s return type
    
    The method dvb_frontend_ops::search() is defined as
    returning an 'enum dvbfe_search', but the implementation in this
    driver returns an 'int'.
    
    Fix this by returning 'enum dvbfe_search' in this driver too.
    
    Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
    Acked-by: Brad Love <brad@nextdimension.cc>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/dvb-frontends/lgdt3306a.c b/drivers/media/dvb-frontends/lgdt3306a.c
index 7eb4e1469d20..32de824476db 100644
--- a/drivers/media/dvb-frontends/lgdt3306a.c
+++ b/drivers/media/dvb-frontends/lgdt3306a.c
@@ -1784,7 +1784,7 @@ static int lgdt3306a_get_tune_settings(struct dvb_frontend *fe,
 	return 0;
 }
 
-static int lgdt3306a_search(struct dvb_frontend *fe)
+static enum dvbfe_search lgdt3306a_search(struct dvb_frontend *fe)
 {
 	enum fe_status status = 0;
 	int ret;

commit f6618cc8b447834a8102ae6988ae45cc7835a519
Author: Brad Love <brad@nextdimension.cc>
Date:   Tue Mar 6 14:14:55 2018 -0500

    media: lgdt3306a: remove symbol count mismatch fix
    
    This symbol mismatch is handled by NULL'ing out the release
    callback if the driver is loaded as an i2c device.
    
    This patch reverts:
    - commit 94448e21cf08 ("media: lgdt3306a: Fix a double kfree on i2c
      device remove")
    - commit 835d66173a38 ("media: lgdt3306a: Fix module count mismatch
      on usb unplug")
    
    The symbol count mismatch is handled by:
    - commit 5b3a8e906973 ("media: lgdt3306a: Set fe ops.release to
      NULL if probed")
    
    Signed-off-by: Brad Love <brad@nextdimension.cc>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/lgdt3306a.c b/drivers/media/dvb-frontends/lgdt3306a.c
index 5b1903358730..7eb4e1469d20 100644
--- a/drivers/media/dvb-frontends/lgdt3306a.c
+++ b/drivers/media/dvb-frontends/lgdt3306a.c
@@ -1814,13 +1814,7 @@ static void lgdt3306a_release(struct dvb_frontend *fe)
 	struct lgdt3306a_state *state = fe->demodulator_priv;
 
 	dbg_info("\n");
-
-	/*
-	 * If state->muxc is not NULL, then we are an i2c device
-	 * and lgdt3306a_remove will clean up state
-	 */
-	if (!state->muxc)
-		kfree(state);
+	kfree(state);
 }
 
 static const struct dvb_frontend_ops lgdt3306a_ops;
@@ -2221,7 +2215,7 @@ static int lgdt3306a_probe(struct i2c_client *client,
 			sizeof(struct lgdt3306a_config));
 
 	config->i2c_addr = client->addr;
-	fe = dvb_attach(lgdt3306a_attach, config, client->adapter);
+	fe = lgdt3306a_attach(config, client->adapter);
 	if (fe == NULL) {
 		ret = -ENODEV;
 		goto err_fe;

commit e7f4d7516aa3ed912946fdf3863be8d1489fd836
Author: Brad Love <brad@nextdimension.cc>
Date:   Fri Jan 12 11:19:41 2018 -0500

    media: lgdt3306a: Announce successful creation
    
    The driver is near silent, this adds a simple announcement at the
    end of probe after the chip has been detected and upgrades a debug
    message to error if probe has failed.
    
    Signed-off-by: Brad Love <brad@nextdimension.cc>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/lgdt3306a.c b/drivers/media/dvb-frontends/lgdt3306a.c
index 0ed64604d7af..5b1903358730 100644
--- a/drivers/media/dvb-frontends/lgdt3306a.c
+++ b/drivers/media/dvb-frontends/lgdt3306a.c
@@ -2249,6 +2249,8 @@ static int lgdt3306a_probe(struct i2c_client *client,
 	*config->i2c_adapter = state->muxc->adapter[0];
 	*config->fe = fe;
 
+	dev_info(&client->dev, "LG Electronics LGDT3306A successfully identified\n");
+
 	return 0;
 
 err_kfree:
@@ -2256,7 +2258,7 @@ static int lgdt3306a_probe(struct i2c_client *client,
 err_fe:
 	kfree(config);
 fail:
-	dev_dbg(&client->dev, "failed=%d\n", ret);
+	dev_warn(&client->dev, "probe failed = %d\n", ret);
 	return ret;
 }
 

commit 94448e21cf08b10f7dc7acdaca387594370396b0
Author: Brad Love <brad@nextdimension.cc>
Date:   Fri Jan 5 09:57:13 2018 -0500

    media: lgdt3306a: Fix a double kfree on i2c device remove
    
    Both lgdt33606a_release and lgdt3306a_remove kfree state, but _release is
    called first, then _remove operates on states members before kfree'ing it.
    This can lead to random oops/GPF/etc on USB disconnect.
    
    Signed-off-by: Brad Love <brad@nextdimension.cc>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/lgdt3306a.c b/drivers/media/dvb-frontends/lgdt3306a.c
index adcaf9b20ce3..0ed64604d7af 100644
--- a/drivers/media/dvb-frontends/lgdt3306a.c
+++ b/drivers/media/dvb-frontends/lgdt3306a.c
@@ -1814,7 +1814,13 @@ static void lgdt3306a_release(struct dvb_frontend *fe)
 	struct lgdt3306a_state *state = fe->demodulator_priv;
 
 	dbg_info("\n");
-	kfree(state);
+
+	/*
+	 * If state->muxc is not NULL, then we are an i2c device
+	 * and lgdt3306a_remove will clean up state
+	 */
+	if (!state->muxc)
+		kfree(state);
 }
 
 static const struct dvb_frontend_ops lgdt3306a_ops;

commit 835d66173a38538c072a7c393d02360dcfac8582
Author: Brad Love <brad@nextdimension.cc>
Date:   Fri Jan 5 09:57:12 2018 -0500

    media: lgdt3306a: Fix module count mismatch on usb unplug
    
    When used as an i2c device there is a module usage count mismatch on
    removal, preventing the driver from being used thereafter. dvb_attach
    increments the usage count so it is properly balanced on removal.
    
    On disconnect of Hauppauge SoloHD/DualHD before:
    
    lsmod | grep lgdt3306a
    lgdt3306a              28672  -1
    i2c_mux                16384  1 lgdt3306a
    
    On disconnect of Hauppauge SoloHD/DualHD after:
    
    lsmod | grep lgdt3306a
    lgdt3306a              28672  0
    i2c_mux                16384  1 lgdt3306a
    
    Signed-off-by: Brad Love <brad@nextdimension.cc>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/lgdt3306a.c b/drivers/media/dvb-frontends/lgdt3306a.c
index fb9c7bc40a9c..adcaf9b20ce3 100644
--- a/drivers/media/dvb-frontends/lgdt3306a.c
+++ b/drivers/media/dvb-frontends/lgdt3306a.c
@@ -2215,7 +2215,7 @@ static int lgdt3306a_probe(struct i2c_client *client,
 			sizeof(struct lgdt3306a_config));
 
 	config->i2c_addr = client->addr;
-	fe = lgdt3306a_attach(config, client->adapter);
+	fe = dvb_attach(lgdt3306a_attach, config, client->adapter);
 	if (fe == NULL) {
 		ret = -ENODEV;
 		goto err_fe;

commit 4966c0c5c61c0c3a5fb0ebfed7495df02027205f
Author: Brad Love <brad@nextdimension.cc>
Date:   Thu Jan 4 19:04:19 2018 -0500

    media: lgdt3306a: Add QAM AUTO support
    
    As configured currently, modulation in the driver is set to auto detect,
    no matter what the user sets modulation to. This leads to both QAM64
    and QAM256 having the same effect. QAM AUTO is explicitly added here for
    compatibility with scanning software who can use AUTO instead of doing
    essentially the same scan twice.
    Also included is a module option to enforce a specific QAM modulation if
    desired. The true modulation is read before calculating the snr.
    Changes are backwards compatible with current behaviour.
    
    Signed-off-by: Brad Love <brad@nextdimension.cc>
    Reviewed-by: Michael Ira Krufky <mkrufky@linuxtv.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/lgdt3306a.c b/drivers/media/dvb-frontends/lgdt3306a.c
index 377271decbab..fb9c7bc40a9c 100644
--- a/drivers/media/dvb-frontends/lgdt3306a.c
+++ b/drivers/media/dvb-frontends/lgdt3306a.c
@@ -30,6 +30,17 @@ static int debug;
 module_param(debug, int, 0644);
 MODULE_PARM_DESC(debug, "set debug level (info=1, reg=2 (or-able))");
 
+/*
+ * Older drivers treated QAM64 and QAM256 the same; that is the HW always
+ * used "Auto" mode during detection.  Setting "forced_manual"=1 allows
+ * the user to treat these modes as separate.  For backwards compatibility,
+ * it's off by default.  QAM_AUTO can now be specified to achive that
+ * effect even if "forced_manual"=1
+ */
+static int forced_manual;
+module_param(forced_manual, int, 0644);
+MODULE_PARM_DESC(forced_manual, "if set, QAM64 and QAM256 will only lock to modulation specified");
+
 #define DBG_INFO 1
 #define DBG_REG  2
 #define DBG_DUMP 4 /* FGR - comment out to remove dump code */
@@ -566,7 +577,12 @@ static int lgdt3306a_set_qam(struct lgdt3306a_state *state, int modulation)
 	/* 3. : 64QAM/256QAM detection(manual, auto) */
 	ret = lgdt3306a_read_reg(state, 0x0009, &val);
 	val &= 0xfc;
-	val |= 0x02; /* STDOPDETCMODE[1:0]=1=Manual 2=Auto */
+	/* Check for forced Manual modulation modes; otherwise always "auto" */
+	if(forced_manual && (modulation != QAM_AUTO)){
+		val |= 0x01; /* STDOPDETCMODE[1:0]= 1=Manual */
+	} else {
+		val |= 0x02; /* STDOPDETCMODE[1:0]= 2=Auto */
+	}
 	ret = lgdt3306a_write_reg(state, 0x0009, val);
 	if (lg_chkerr(ret))
 		goto fail;
@@ -642,10 +658,9 @@ static int lgdt3306a_set_modulation(struct lgdt3306a_state *state,
 		ret = lgdt3306a_set_vsb(state);
 		break;
 	case QAM_64:
-		ret = lgdt3306a_set_qam(state, QAM_64);
-		break;
 	case QAM_256:
-		ret = lgdt3306a_set_qam(state, QAM_256);
+	case QAM_AUTO:
+		ret = lgdt3306a_set_qam(state, p->modulation);
 		break;
 	default:
 		return -EINVAL;
@@ -672,6 +687,7 @@ static int lgdt3306a_agc_setup(struct lgdt3306a_state *state,
 		break;
 	case QAM_64:
 	case QAM_256:
+	case QAM_AUTO:
 		break;
 	default:
 		return -EINVAL;
@@ -726,6 +742,7 @@ static int lgdt3306a_spectral_inversion(struct lgdt3306a_state *state,
 		break;
 	case QAM_64:
 	case QAM_256:
+	case QAM_AUTO:
 		/* Auto ok for QAM */
 		ret = lgdt3306a_set_inversion_auto(state, 1);
 		break;
@@ -749,6 +766,7 @@ static int lgdt3306a_set_if(struct lgdt3306a_state *state,
 		break;
 	case QAM_64:
 	case QAM_256:
+	case QAM_AUTO:
 		if_freq_khz = state->cfg->qam_if_khz;
 		break;
 	default:
@@ -1607,6 +1625,7 @@ static int lgdt3306a_read_status(struct dvb_frontend *fe,
 		switch (state->current_modulation) {
 		case QAM_256:
 		case QAM_64:
+		case QAM_AUTO:
 			if (lgdt3306a_qam_lock_poll(state) == LG3306_LOCK) {
 				*status |= FE_HAS_VITERBI;
 				*status |= FE_HAS_SYNC;
@@ -1650,6 +1669,7 @@ static int lgdt3306a_read_signal_strength(struct dvb_frontend *fe,
 	 * Calculate some sort of "strength" from SNR
 	 */
 	struct lgdt3306a_state *state = fe->demodulator_priv;
+	u8 val;
 	u16 snr; /* snr_x10 */
 	int ret;
 	u32 ref_snr; /* snr*100 */
@@ -1662,11 +1682,15 @@ static int lgdt3306a_read_signal_strength(struct dvb_frontend *fe,
 		 ref_snr = 1600; /* 16dB */
 		 break;
 	case QAM_64:
-		 ref_snr = 2200; /* 22dB */
-		 break;
 	case QAM_256:
-		 ref_snr = 2800; /* 28dB */
-		 break;
+	case QAM_AUTO:
+		/* need to know actual modulation to set proper SNR baseline */
+		lgdt3306a_read_reg(state, 0x00a6, &val);
+		if(val & 0x04)
+			ref_snr = 2800; /* QAM-256 28dB */
+		else
+			ref_snr = 2200; /* QAM-64  22dB */
+		break;
 	default:
 		return -EINVAL;
 	}
@@ -2136,7 +2160,7 @@ static const struct dvb_frontend_ops lgdt3306a_ops = {
 		.frequency_min      = 54000000,
 		.frequency_max      = 858000000,
 		.frequency_stepsize = 62500,
-		.caps = FE_CAN_QAM_64 | FE_CAN_QAM_256 | FE_CAN_8VSB
+		.caps = FE_CAN_QAM_AUTO | FE_CAN_QAM_64 | FE_CAN_QAM_256 | FE_CAN_8VSB
 	},
 	.i2c_gate_ctrl        = lgdt3306a_i2c_gate_ctrl,
 	.init                 = lgdt3306a_init,

commit 4c7c3f9b1a85d26ffd4a8a31dd661856c7482357
Author: Brad Love <brad@nextdimension.cc>
Date:   Thu Jan 4 20:30:24 2018 -0500

    media: lgdt3306a: QAM streaming improvement
    
    Add some register updates required for stable viewing
    on Cablevision in NY. Does not adversely affect other providers.
    
    Changes since v1:
    - Change upper case hex to lower case.
    
    Signed-off-by: Brad Love <brad@nextdimension.cc>
    Reviewed-by: Michael Ira Krufky <mkrufky@linuxtv.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/lgdt3306a.c b/drivers/media/dvb-frontends/lgdt3306a.c
index d2477edae197..377271decbab 100644
--- a/drivers/media/dvb-frontends/lgdt3306a.c
+++ b/drivers/media/dvb-frontends/lgdt3306a.c
@@ -598,6 +598,28 @@ static int lgdt3306a_set_qam(struct lgdt3306a_state *state, int modulation)
 	if (lg_chkerr(ret))
 		goto fail;
 
+	/* 5.1 V0.36 SRDCHKALWAYS : For better QAM detection */
+	ret = lgdt3306a_read_reg(state, 0x000a, &val);
+	val &= 0xfd;
+	val |= 0x02;
+	ret = lgdt3306a_write_reg(state, 0x000a, val);
+	if (lg_chkerr(ret))
+		goto fail;
+
+	/* 5.2 V0.36 Control of "no signal" detector function */
+	ret = lgdt3306a_read_reg(state, 0x2849, &val);
+	val &= 0xdf;
+	ret = lgdt3306a_write_reg(state, 0x2849, val);
+	if (lg_chkerr(ret))
+		goto fail;
+
+	/* 5.3 Fix for Blonder Tongue HDE-2H-QAM and AQM modulators */
+	ret = lgdt3306a_read_reg(state, 0x302b, &val);
+	val &= 0x7f;  /* SELFSYNCFINDEN_CQS=0; disable auto reset */
+	ret = lgdt3306a_write_reg(state, 0x302b, val);
+	if (lg_chkerr(ret))
+		goto fail;
+
 	/* 6. Reset */
 	ret = lgdt3306a_soft_reset(state);
 	if (lg_chkerr(ret))

commit 5b3a8e906973540b61dbf402c6b6f8d64d4ae119
Author: Brad Love <brad@nextdimension.cc>
Date:   Thu Jan 4 19:04:17 2018 -0500

    media: lgdt3306a: Set fe ops.release to NULL if probed
    
    If release is part of frontend ops then it is called in the
    course of dvb_frontend_detach. The process also decrements
    the module usage count. The problem is if the lgdt3306a
    driver is reached via i2c_new_device, then when it is
    eventually destroyed remove is called, which further
    decrements the module usage count to negative. After this
    occurs the driver is in a bad state and no longer works.
    Also fixed by NULLing out the release callback is a double
    kfree of state, which introduces arbitrary oopses/GPF.
    This problem is only currently reachable via the em28xx driver.
    
    On disconnect of Hauppauge SoloHD before:
    
    lsmod | grep lgdt3306a
    lgdt3306a              28672  -1
    i2c_mux                16384  1 lgdt3306a
    
    On disconnect of Hauppauge SoloHD after:
    
    lsmod | grep lgdt3306a
    lgdt3306a              28672  0
    i2c_mux                16384  1 lgdt3306a
    
    Signed-off-by: Brad Love <brad@nextdimension.cc>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/lgdt3306a.c b/drivers/media/dvb-frontends/lgdt3306a.c
index 6356815cf3e1..d2477edae197 100644
--- a/drivers/media/dvb-frontends/lgdt3306a.c
+++ b/drivers/media/dvb-frontends/lgdt3306a.c
@@ -2177,6 +2177,7 @@ static int lgdt3306a_probe(struct i2c_client *client,
 
 	i2c_set_clientdata(client, fe->demodulator_priv);
 	state = fe->demodulator_priv;
+	state->frontend.ops.release = NULL;
 
 	/* create mux i2c adapter for tuner */
 	state->muxc = i2c_mux_alloc(client->adapter, &client->dev,

commit fada1935590f66dc6784981e0d557ca09013c847
Author: Mauro Carvalho Chehab <mchehab@s-opensource.com>
Date:   Thu Dec 28 13:03:51 2017 -0500

    media: move dvb kAPI headers to include/media
    
    Except for DVB, all media kAPI headers are at include/media.
    
    Move the headers to it.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/lgdt3306a.c b/drivers/media/dvb-frontends/lgdt3306a.c
index 724e9aac0f11..6356815cf3e1 100644
--- a/drivers/media/dvb-frontends/lgdt3306a.c
+++ b/drivers/media/dvb-frontends/lgdt3306a.c
@@ -21,7 +21,7 @@
 #include <asm/div64.h>
 #include <linux/kernel.h>
 #include <linux/dvb/frontend.h>
-#include "dvb_math.h"
+#include <media/dvb_math.h>
 #include "lgdt3306a.h"
 #include <linux/i2c-mux.h>
 

commit 1f679ff6c761729607630c731c8bae0f8691ae79
Author: Thomas Meyer <thomas@m3y3r.de>
Date:   Sun Sep 3 08:19:31 2017 -0400

    media: lgdt3306a: Use ARRAY_SIZE macro
    
    Use ARRAY_SIZE macro, rather than explicitly coding some variant of it
    yourself.
    Found with: find -type f -name "*.c" -o -name "*.h" | xargs perl -p -i -e
    's/\bsizeof\s*\(\s*(\w+)\s*\)\s*\ /\s*sizeof\s*\(\s*\1\s*\[\s*0\s*\]\s*\)
    /ARRAY_SIZE(\1)/g' and manual check/verification.
    
    Signed-off-by: Thomas Meyer <thomas@m3y3r.de>
    Signed-off-by: Hans Verkuil <hansverk@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/lgdt3306a.c b/drivers/media/dvb-frontends/lgdt3306a.c
index c9b1eb38444e..724e9aac0f11 100644
--- a/drivers/media/dvb-frontends/lgdt3306a.c
+++ b/drivers/media/dvb-frontends/lgdt3306a.c
@@ -19,6 +19,7 @@
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
 
 #include <asm/div64.h>
+#include <linux/kernel.h>
 #include <linux/dvb/frontend.h>
 #include "dvb_math.h"
 #include "lgdt3306a.h"
@@ -2072,7 +2073,7 @@ static const short regtab[] = {
 	0x30aa, /* MPEGLOCK */
 };
 
-#define numDumpRegs (sizeof(regtab)/sizeof(regtab[0]))
+#define numDumpRegs (ARRAY_SIZE(regtab))
 static u8 regval1[numDumpRegs] = {0, };
 static u8 regval2[numDumpRegs] = {0, };
 

commit 4f75189024f4186a7ff9d56f4a8cb690774412ec
Author: Kevin Cheng <kcheng@gmail.com>
Date:   Tue Jan 10 01:14:18 2017 -0200

    [media] lgdt3306a: support i2c mux for use by em28xx
    
    Adds an i2c mux to the lgdt3306a demodulator.  This was done to support
    the Hauppauge WinTV-dualHD 01595 USB TV tuner (em28xx), which utilizes two
    si2157 tuners behind gate control.
    
    Signed-off-by: Kevin Cheng <kcheng@gmail.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/lgdt3306a.c b/drivers/media/dvb-frontends/lgdt3306a.c
index 19dca46b1171..c9b1eb38444e 100644
--- a/drivers/media/dvb-frontends/lgdt3306a.c
+++ b/drivers/media/dvb-frontends/lgdt3306a.c
@@ -22,6 +22,7 @@
 #include <linux/dvb/frontend.h>
 #include "dvb_math.h"
 #include "lgdt3306a.h"
+#include <linux/i2c-mux.h>
 
 
 static int debug;
@@ -65,6 +66,8 @@ struct lgdt3306a_state {
 	enum fe_modulation current_modulation;
 	u32 current_frequency;
 	u32 snr;
+
+	struct i2c_mux_core *muxc;
 };
 
 /*
@@ -2131,6 +2134,111 @@ static const struct dvb_frontend_ops lgdt3306a_ops = {
 	.search               = lgdt3306a_search,
 };
 
+static int lgdt3306a_select(struct i2c_mux_core *muxc, u32 chan)
+{
+	struct i2c_client *client = i2c_mux_priv(muxc);
+	struct lgdt3306a_state *state = i2c_get_clientdata(client);
+
+	return lgdt3306a_i2c_gate_ctrl(&state->frontend, 1);
+}
+
+static int lgdt3306a_deselect(struct i2c_mux_core *muxc, u32 chan)
+{
+	struct i2c_client *client = i2c_mux_priv(muxc);
+	struct lgdt3306a_state *state = i2c_get_clientdata(client);
+
+	return lgdt3306a_i2c_gate_ctrl(&state->frontend, 0);
+}
+
+static int lgdt3306a_probe(struct i2c_client *client,
+		const struct i2c_device_id *id)
+{
+	struct lgdt3306a_config *config;
+	struct lgdt3306a_state *state;
+	struct dvb_frontend *fe;
+	int ret;
+
+	config = kzalloc(sizeof(struct lgdt3306a_config), GFP_KERNEL);
+	if (config == NULL) {
+		ret = -ENOMEM;
+		goto fail;
+	}
+
+	memcpy(config, client->dev.platform_data,
+			sizeof(struct lgdt3306a_config));
+
+	config->i2c_addr = client->addr;
+	fe = lgdt3306a_attach(config, client->adapter);
+	if (fe == NULL) {
+		ret = -ENODEV;
+		goto err_fe;
+	}
+
+	i2c_set_clientdata(client, fe->demodulator_priv);
+	state = fe->demodulator_priv;
+
+	/* create mux i2c adapter for tuner */
+	state->muxc = i2c_mux_alloc(client->adapter, &client->dev,
+				  1, 0, I2C_MUX_LOCKED,
+				  lgdt3306a_select, lgdt3306a_deselect);
+	if (!state->muxc) {
+		ret = -ENOMEM;
+		goto err_kfree;
+	}
+	state->muxc->priv = client;
+	ret = i2c_mux_add_adapter(state->muxc, 0, 0, 0);
+	if (ret)
+		goto err_kfree;
+
+	/* create dvb_frontend */
+	fe->ops.i2c_gate_ctrl = NULL;
+	*config->i2c_adapter = state->muxc->adapter[0];
+	*config->fe = fe;
+
+	return 0;
+
+err_kfree:
+	kfree(state);
+err_fe:
+	kfree(config);
+fail:
+	dev_dbg(&client->dev, "failed=%d\n", ret);
+	return ret;
+}
+
+static int lgdt3306a_remove(struct i2c_client *client)
+{
+	struct lgdt3306a_state *state = i2c_get_clientdata(client);
+
+	i2c_mux_del_adapters(state->muxc);
+
+	state->frontend.ops.release = NULL;
+	state->frontend.demodulator_priv = NULL;
+
+	kfree(state->cfg);
+	kfree(state);
+
+	return 0;
+}
+
+static const struct i2c_device_id lgdt3306a_id_table[] = {
+	{"lgdt3306a", 0},
+	{}
+};
+MODULE_DEVICE_TABLE(i2c, lgdt3306a_id_table);
+
+static struct i2c_driver lgdt3306a_driver = {
+	.driver = {
+		.name                = "lgdt3306a",
+		.suppress_bind_attrs = true,
+	},
+	.probe		= lgdt3306a_probe,
+	.remove		= lgdt3306a_remove,
+	.id_table	= lgdt3306a_id_table,
+};
+
+module_i2c_driver(lgdt3306a_driver);
+
 MODULE_DESCRIPTION("LG Electronics LGDT3306A ATSC/QAM-B Demodulator Driver");
 MODULE_AUTHOR("Fred Richter <frichter@hauppauge.com>");
 MODULE_LICENSE("GPL");

commit bd336e63441bcdeeccca6a698087d913a32478c5
Author: Max Kellermann <max.kellermann@gmail.com>
Date:   Tue Aug 9 18:32:21 2016 -0300

    [media] dvb: make DVB frontend *_ops instances "const"
    
    These are immutable.  Making them "const" allows the compiler to move
    them to the "rodata" section.
    
    Note that cxd2841er_t_c_ops cannot be made "const", because
    cxd2841er_attach() modifies it.  Ouch!
    
    [mchehab@s-opensource.com: fix merge conflicts]
    Signed-off-by: Max Kellermann <max.kellermann@gmail.com>
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/lgdt3306a.c b/drivers/media/dvb-frontends/lgdt3306a.c
index 0ca4e810e9d8..19dca46b1171 100644
--- a/drivers/media/dvb-frontends/lgdt3306a.c
+++ b/drivers/media/dvb-frontends/lgdt3306a.c
@@ -1767,7 +1767,7 @@ static void lgdt3306a_release(struct dvb_frontend *fe)
 	kfree(state);
 }
 
-static struct dvb_frontend_ops lgdt3306a_ops;
+static const struct dvb_frontend_ops lgdt3306a_ops;
 
 struct dvb_frontend *lgdt3306a_attach(const struct lgdt3306a_config *config,
 				      struct i2c_adapter *i2c_adap)
@@ -2103,7 +2103,7 @@ static void lgdt3306a_DumpRegs(struct lgdt3306a_state *state)
 
 
 
-static struct dvb_frontend_ops lgdt3306a_ops = {
+static const struct dvb_frontend_ops lgdt3306a_ops = {
 	.delsys = { SYS_ATSC, SYS_DVBC_ANNEX_B },
 	.info = {
 		.name = "LG Electronics LGDT3306A VSB/QAM Frontend",

commit dd14523a8e5cf618862dcfa6635297c65f0e26ee
Author: Abylay Ospan <aospan@netup.ru>
Date:   Mon Jul 25 15:38:59 2016 -0300

    [media] lgdt3306a: remove 20*50 msec unnecessary timeout
    
    inside lgdt3306a_search we reading demod status 20 times with 50 msec sleep after each read.
    This gives us more than 1 sec of delay. Removing this delay should not affect demod functionality.
    
    Signed-off-by: Abylay Ospan <aospan@netup.ru>
    Acked-by: Michael Ira Krufky <mkrufky@linuxtv.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/lgdt3306a.c b/drivers/media/dvb-frontends/lgdt3306a.c
index afb9d731e60e..0ca4e810e9d8 100644
--- a/drivers/media/dvb-frontends/lgdt3306a.c
+++ b/drivers/media/dvb-frontends/lgdt3306a.c
@@ -1737,24 +1737,16 @@ static int lgdt3306a_get_tune_settings(struct dvb_frontend *fe,
 static int lgdt3306a_search(struct dvb_frontend *fe)
 {
 	enum fe_status status = 0;
-	int i, ret;
+	int ret;
 
 	/* set frontend */
 	ret = lgdt3306a_set_parameters(fe);
 	if (ret)
 		goto error;
 
-	/* wait frontend lock */
-	for (i = 20; i > 0; i--) {
-		dbg_info(": loop=%d\n", i);
-		msleep(50);
-		ret = lgdt3306a_read_status(fe, &status);
-		if (ret)
-			goto error;
-
-		if (status & FE_HAS_LOCK)
-			break;
-	}
+	ret = lgdt3306a_read_status(fe, &status);
+	if (ret)
+		goto error;
 
 	/* check if we have a valid signal */
 	if (status & FE_HAS_LOCK)

commit f86548cf53970abd5eed75e55e635dc77e90fd04
Author: Colin Ian King <colin.king@canonical.com>
Date:   Thu Sep 1 08:09:41 2016 -0300

    [media] lgdt3306a: fix spelling mistake "supportted" -> "supported"
    
    Trivial fix to spelling mistake in pr_warn message.
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/dvb-frontends/lgdt3306a.c b/drivers/media/dvb-frontends/lgdt3306a.c
index 179c26e5eb4e..afb9d731e60e 100644
--- a/drivers/media/dvb-frontends/lgdt3306a.c
+++ b/drivers/media/dvb-frontends/lgdt3306a.c
@@ -731,7 +731,7 @@ static int lgdt3306a_set_if(struct lgdt3306a_state *state,
 
 	switch (if_freq_khz) {
 	default:
-		pr_warn("IF=%d KHz is not supportted, 3250 assumed\n",
+		pr_warn("IF=%d KHz is not supported, 3250 assumed\n",
 			if_freq_khz);
 		/* fallthrough */
 	case 3250: /* 3.25Mhz */

commit 7e3e68bcfd7713fb1470070c8fa0f108609dd76b
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Thu Feb 4 12:58:30 2016 -0200

    [media] dvb_frontend: pass the props cache to get_frontend() as arg
    
    Instead of using the DTV properties cache directly, pass the get
    frontend data as an argument. For now, everything should remain
    the same, but the next patch will prevent get_frontend to
    affect the global cache.
    
    This is needed because several drivers don't care enough to only
    change the properties if locked. Due to that, calling
    G_PROPERTY before locking on those drivers will make them to
    never lock. Ok, those drivers are crap and should never be
    merged like that, but the core should not rely that the drivers
    would be doing the right thing.
    
    Reviewed-by: Michael Ira Krufky <mkrufky@linuxtv.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/lgdt3306a.c b/drivers/media/dvb-frontends/lgdt3306a.c
index 721fbc07e9ee..179c26e5eb4e 100644
--- a/drivers/media/dvb-frontends/lgdt3306a.c
+++ b/drivers/media/dvb-frontends/lgdt3306a.c
@@ -1040,10 +1040,10 @@ static int lgdt3306a_set_parameters(struct dvb_frontend *fe)
 	return ret;
 }
 
-static int lgdt3306a_get_frontend(struct dvb_frontend *fe)
+static int lgdt3306a_get_frontend(struct dvb_frontend *fe,
+				  struct dtv_frontend_properties *p)
 {
 	struct lgdt3306a_state *state = fe->demodulator_priv;
-	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
 
 	dbg_info("(%u, %d)\n",
 		 state->current_frequency, state->current_modulation);

commit 0df289a209e02f0926042ab07d7d2595ea2d2e9b
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Sun Jun 7 14:53:52 2015 -0300

    [media] dvb: Get rid of typedev usage for enums
    
    The DVB API was originally defined using typedefs. This is against
    Kernel CodingStyle, and there's no good usage here. While we can't
    remove its usage on userspace, we can avoid its usage in Kernelspace.
    
    So, let's do it.
    
    This patch was generated by this shell script:
    
            for j in $(grep typedef include/uapi/linux/dvb/frontend.h |cut -d' ' -f 3); do for i in $(find drivers/media -name '*.[ch]' -type f) $(find drivers/staging/media -name '*.[ch]' -type f); do sed "s,${j}_t,enum $j," <$i >a && mv a $i; done; done
    
    While here, make CodingStyle fixes on the affected lines.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
    Acked-by: Stefan Richter <stefanr@s5r6.in-berlin.de> # for drivers/media/firewire/*

diff --git a/drivers/media/dvb-frontends/lgdt3306a.c b/drivers/media/dvb-frontends/lgdt3306a.c
index 0e2e43e9ede5..721fbc07e9ee 100644
--- a/drivers/media/dvb-frontends/lgdt3306a.c
+++ b/drivers/media/dvb-frontends/lgdt3306a.c
@@ -62,7 +62,7 @@ struct lgdt3306a_state {
 
 	struct dvb_frontend frontend;
 
-	fe_modulation_t current_modulation;
+	enum fe_modulation current_modulation;
 	u32 current_frequency;
 	u32 snr;
 };
@@ -1558,7 +1558,8 @@ lgdt3306a_qam_lock_poll(struct lgdt3306a_state *state)
 	return LG3306_UNLOCK;
 }
 
-static int lgdt3306a_read_status(struct dvb_frontend *fe, fe_status_t *status)
+static int lgdt3306a_read_status(struct dvb_frontend *fe,
+				 enum fe_status *status)
 {
 	struct lgdt3306a_state *state = fe->demodulator_priv;
 	u16 strength = 0;
@@ -1705,7 +1706,7 @@ static int lgdt3306a_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)
 
 static int lgdt3306a_tune(struct dvb_frontend *fe, bool re_tune,
 			  unsigned int mode_flags, unsigned int *delay,
-			  fe_status_t *status)
+			  enum fe_status *status)
 {
 	int ret = 0;
 	struct lgdt3306a_state *state = fe->demodulator_priv;
@@ -1735,7 +1736,7 @@ static int lgdt3306a_get_tune_settings(struct dvb_frontend *fe,
 
 static int lgdt3306a_search(struct dvb_frontend *fe)
 {
-	fe_status_t status = 0;
+	enum fe_status status = 0;
 	int i, ret;
 
 	/* set frontend */

commit 16afc67216ed94c66672f36d5642e5d287d68b92
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Tue Apr 28 18:31:21 2015 -0300

    [media] lgdt3306a: fix indentation
    
    drivers/media/dvb-frontends/lgdt3306a.c:2104 lgdt3306a_DumpRegs() warn: inconsistent indenting
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/lgdt3306a.c b/drivers/media/dvb-frontends/lgdt3306a.c
index d9a2b0e768e0..0e2e43e9ede5 100644
--- a/drivers/media/dvb-frontends/lgdt3306a.c
+++ b/drivers/media/dvb-frontends/lgdt3306a.c
@@ -2101,7 +2101,7 @@ static void lgdt3306a_DumpRegs(struct lgdt3306a_state *state)
 		lgdt3306a_read_reg(state, regtab[i], &regval1[i]);
 		if (regval1[i] != regval2[i]) {
 			lg_debug(" %04X = %02X\n", regtab[i], regval1[i]);
-				 regval2[i] = regval1[i];
+			regval2[i] = regval1[i];
 		}
 	}
 	debug = sav_debug;

commit 95f22c5aaed3415ff4a2df6a1ff76b3127123430
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Tue Oct 28 12:40:20 2014 -0200

    [media] lgdt3306a: Minor source code cleanups
    
    Fix a few minor CodingStyle issues at the source code:
            - Use proper multi-line comments;
            - Align the log tables;
            - Remove the .type from dvb_frontend_ops, since this is not
              needed anymore (since the drivers conversion to DVBv5);
            - Remove emacs format macro.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/lgdt3306a.c b/drivers/media/dvb-frontends/lgdt3306a.c
index 4e0cf443b9ff..d9a2b0e768e0 100644
--- a/drivers/media/dvb-frontends/lgdt3306a.c
+++ b/drivers/media/dvb-frontends/lgdt3306a.c
@@ -67,16 +67,17 @@ struct lgdt3306a_state {
 	u32 snr;
 };
 
-/* -----------------------------------------------
- LG3306A Register Usage
-   (LG does not really name the registers, so this code does not either)
- 0000 -> 00FF Common control and status
- 1000 -> 10FF Synchronizer control and status
- 1F00 -> 1FFF Smart Antenna control and status
- 2100 -> 21FF VSB Equalizer control and status
- 2800 -> 28FF QAM Equalizer control and status
- 3000 -> 30FF FEC control and status
- ---------------------------------------------- */
+/*
+ * LG3306A Register Usage
+ *  (LG does not really name the registers, so this code does not either)
+ *
+ * 0000 -> 00FF Common control and status
+ * 1000 -> 10FF Synchronizer control and status
+ * 1F00 -> 1FFF Smart Antenna control and status
+ * 2100 -> 21FF VSB Equalizer control and status
+ * 2800 -> 28FF QAM Equalizer control and status
+ * 3000 -> 30FF FEC control and status
+ */
 
 enum lgdt3306a_lock_status {
 	LG3306_UNLOCK       = 0x00,
@@ -1431,7 +1432,7 @@ static const u32 valx_x10[] = {
 	10,  11,  13,  15,  17,  20,  25,  33,  41,  50,  59,  73,  87,  100
 };
 static const u32 log10x_x1000[] = {
-	0,  41, 114, 176, 230, 301, 398, 518, 613, 699, 771, 863, 939, 1000
+	0,   41, 114, 176, 230, 301, 398, 518, 613, 699, 771, 863, 939, 1000
 };
 
 static u32 log10_x1000(u32 x)
@@ -2113,9 +2114,6 @@ static struct dvb_frontend_ops lgdt3306a_ops = {
 	.delsys = { SYS_ATSC, SYS_DVBC_ANNEX_B },
 	.info = {
 		.name = "LG Electronics LGDT3306A VSB/QAM Frontend",
-#if 0
-		.type               = FE_ATSC,
-#endif
 		.frequency_min      = 54000000,
 		.frequency_max      = 858000000,
 		.frequency_stepsize = 62500,
@@ -2144,9 +2142,3 @@ MODULE_DESCRIPTION("LG Electronics LGDT3306A ATSC/QAM-B Demodulator Driver");
 MODULE_AUTHOR("Fred Richter <frichter@hauppauge.com>");
 MODULE_LICENSE("GPL");
 MODULE_VERSION("0.2");
-
-/*
- * Local variables:
- * c-basic-offset: 8
- * End:
- */

commit 534f4364f9baa14c8c1431c0584cf5a291d09d3c
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Tue Oct 28 12:35:18 2014 -0200

    [media] lgdt3306a: Break long lines
    
    Fix most of checkpatch warnings like:
            WARNING: line over 80 characters
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/lgdt3306a.c b/drivers/media/dvb-frontends/lgdt3306a.c
index ad483be1b64e..4e0cf443b9ff 100644
--- a/drivers/media/dvb-frontends/lgdt3306a.c
+++ b/drivers/media/dvb-frontends/lgdt3306a.c
@@ -220,13 +220,17 @@ static int lgdt3306a_mpeg_mode(struct lgdt3306a_state *state,
 	int ret;
 
 	dbg_info("(%d)\n", mode);
-	/* transport packet format */
-	ret = lgdt3306a_set_reg_bit(state, 0x0071, 7, mode == LGDT3306A_MPEG_PARALLEL?1:0); /* TPSENB=0x80 */
+	/* transport packet format - TPSENB=0x80 */
+	ret = lgdt3306a_set_reg_bit(state, 0x0071, 7,
+				     mode == LGDT3306A_MPEG_PARALLEL ? 1 : 0);
 	if (lg_chkerr(ret))
 		goto fail;
 
-	/* start of packet signal duration */
-	ret = lgdt3306a_set_reg_bit(state, 0x0071, 6, 0); /* TPSSOPBITEN=0x40; 0=byte duration, 1=bit duration */
+	/*
+	 * start of packet signal duration
+	 * TPSSOPBITEN=0x40; 0=byte duration, 1=bit duration
+	 */
+	ret = lgdt3306a_set_reg_bit(state, 0x0071, 6, 0);
 	if (lg_chkerr(ret))
 		goto fail;
 
@@ -285,17 +289,23 @@ static int lgdt3306a_mpeg_tristate(struct lgdt3306a_state *state,
 		ret = lgdt3306a_read_reg(state, 0x0070, &val);
 		if (lg_chkerr(ret))
 			goto fail;
-		val &= ~0xa8; /* Tristate bus; TPOUTEN=0x80, TPCLKOUTEN=0x20, TPDATAOUTEN=0x08 */
+		/*
+		 * Tristate bus; TPOUTEN=0x80, TPCLKOUTEN=0x20,
+		 * TPDATAOUTEN=0x08
+		 */
+		val &= ~0xa8;
 		ret = lgdt3306a_write_reg(state, 0x0070, val);
 		if (lg_chkerr(ret))
 			goto fail;
 
-		ret = lgdt3306a_set_reg_bit(state, 0x0003, 6, 1); /* AGCIFOUTENB=0x40; 1=Disable IFAGC pin */
+		/* AGCIFOUTENB=0x40; 1=Disable IFAGC pin */
+		ret = lgdt3306a_set_reg_bit(state, 0x0003, 6, 1);
 		if (lg_chkerr(ret))
 			goto fail;
 
 	} else {
-		ret = lgdt3306a_set_reg_bit(state, 0x0003, 6, 0); /* enable IFAGC pin */
+		/* enable IFAGC pin */
+		ret = lgdt3306a_set_reg_bit(state, 0x0003, 6, 0);
 		if (lg_chkerr(ret))
 			goto fail;
 
@@ -331,20 +341,24 @@ static int lgdt3306a_power(struct lgdt3306a_state *state,
 	dbg_info("(%d)\n", mode);
 
 	if (mode == 0) {
-		ret = lgdt3306a_set_reg_bit(state, 0x0000, 7, 0); /* into reset */
+		/* into reset */
+		ret = lgdt3306a_set_reg_bit(state, 0x0000, 7, 0);
 		if (lg_chkerr(ret))
 			goto fail;
 
-		ret = lgdt3306a_set_reg_bit(state, 0x0000, 0, 0); /* power down */
+		/* power down */
+		ret = lgdt3306a_set_reg_bit(state, 0x0000, 0, 0);
 		if (lg_chkerr(ret))
 			goto fail;
 
 	} else {
-		ret = lgdt3306a_set_reg_bit(state, 0x0000, 7, 1); /* out of reset */
+		/* out of reset */
+		ret = lgdt3306a_set_reg_bit(state, 0x0000, 7, 1);
 		if (lg_chkerr(ret))
 			goto fail;
 
-		ret = lgdt3306a_set_reg_bit(state, 0x0000, 0, 1); /* power up */
+		/* power up */
+		ret = lgdt3306a_set_reg_bit(state, 0x0000, 0, 1);
 		if (lg_chkerr(ret))
 			goto fail;
 	}
@@ -658,8 +672,8 @@ static int lgdt3306a_set_inversion_auto(struct lgdt3306a_state *state,
 
 	dbg_info("(%d)\n", enabled);
 
-	/* 0=Manual 1=Auto(QAM only) */
-	ret = lgdt3306a_set_reg_bit(state, 0x0002, 3, enabled);/* SPECINVAUTO=0x04 */
+	/* 0=Manual 1=Auto(QAM only) - SPECINVAUTO=0x04 */
+	ret = lgdt3306a_set_reg_bit(state, 0x0002, 3, enabled);
 	return ret;
 }
 
@@ -671,17 +685,22 @@ static int lgdt3306a_spectral_inversion(struct lgdt3306a_state *state,
 
 	dbg_info("(%d)\n", inversion);
 #if 0
-/* FGR - spectral_inversion defaults already set for VSB and QAM; can enable later if desired */
+	/*
+	 * FGR - spectral_inversion defaults already set for VSB and QAM;
+	 * can enable later if desired
+	 */
 
 	ret = lgdt3306a_set_inversion(state, inversion);
 
 	switch (p->modulation) {
 	case VSB_8:
-		ret = lgdt3306a_set_inversion_auto(state, 0); /* Manual only for VSB */
+		/* Manual only for VSB */
+		ret = lgdt3306a_set_inversion_auto(state, 0);
 		break;
 	case QAM_64:
 	case QAM_256:
-		ret = lgdt3306a_set_inversion_auto(state, 1); /* Auto ok for QAM */
+		/* Auto ok for QAM */
+		ret = lgdt3306a_set_inversion_auto(state, 1);
 		break;
 	default:
 		ret = -EINVAL;
@@ -711,7 +730,8 @@ static int lgdt3306a_set_if(struct lgdt3306a_state *state,
 
 	switch (if_freq_khz) {
 	default:
-	    pr_warn("IF=%d KHz is not supportted, 3250 assumed\n", if_freq_khz);
+		pr_warn("IF=%d KHz is not supportted, 3250 assumed\n",
+			if_freq_khz);
 		/* fallthrough */
 	case 3250: /* 3.25Mhz */
 		nco1 = 0x34;
@@ -758,7 +778,8 @@ static int lgdt3306a_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)
 	}
 	dbg_info("(%d)\n", enable);
 
-	return lgdt3306a_set_reg_bit(state, 0x0002, 7, enable ? 0 : 1); /* NI2CRPTEN=0x80 */
+	/* NI2CRPTEN=0x80 */
+	return lgdt3306a_set_reg_bit(state, 0x0002, 7, enable ? 0 : 1);
 }
 
 static int lgdt3306a_sleep(struct lgdt3306a_state *state)
@@ -810,22 +831,30 @@ static int lgdt3306a_init(struct dvb_frontend *fe)
 		goto fail;
 
 	/* 4. Peak-to-peak voltage of ADC input signal */
-	ret = lgdt3306a_set_reg_bit(state, 0x0004, 7, 1); /* ADCSEL1V=0x80=1Vpp; 0x00=2Vpp */
+
+	/* ADCSEL1V=0x80=1Vpp; 0x00=2Vpp */
+	ret = lgdt3306a_set_reg_bit(state, 0x0004, 7, 1);
 	if (lg_chkerr(ret))
 		goto fail;
 
 	/* 5. ADC output data capture clock phase */
-	ret = lgdt3306a_set_reg_bit(state, 0x0004, 2, 0); /* 0=same phase as ADC clock */
+
+	/* 0=same phase as ADC clock */
+	ret = lgdt3306a_set_reg_bit(state, 0x0004, 2, 0);
 	if (lg_chkerr(ret))
 		goto fail;
 
 	/* 5a. ADC sampling clock source */
-	ret = lgdt3306a_set_reg_bit(state, 0x0004, 3, 0); /* ADCCLKPLLSEL=0x08; 0=use ext clock, not PLL */
+
+	/* ADCCLKPLLSEL=0x08; 0=use ext clock, not PLL */
+	ret = lgdt3306a_set_reg_bit(state, 0x0004, 3, 0);
 	if (lg_chkerr(ret))
 		goto fail;
 
 	/* 6. Automatic PLL set */
-	ret = lgdt3306a_set_reg_bit(state, 0x0005, 6, 0); /* PLLSETAUTO=0x40; 0=off */
+
+	/* PLLSETAUTO=0x40; 0=off */
+	ret = lgdt3306a_set_reg_bit(state, 0x0005, 6, 0);
 	if (lg_chkerr(ret))
 		goto fail;
 
@@ -980,7 +1009,7 @@ static int lgdt3306a_set_parameters(struct dvb_frontend *fe)
 		goto fail;
 
 	ret = lgdt3306a_spectral_inversion(state, p,
-					  state->cfg->spectral_inversion ? 1 : 0);
+					state->cfg->spectral_inversion ? 1 : 0);
 	if (lg_chkerr(ret))
 		goto fail;
 
@@ -1015,7 +1044,8 @@ static int lgdt3306a_get_frontend(struct dvb_frontend *fe)
 	struct lgdt3306a_state *state = fe->demodulator_priv;
 	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
 
-	dbg_info("(%u, %d)\n", state->current_frequency, state->current_modulation);
+	dbg_info("(%u, %d)\n",
+		 state->current_frequency, state->current_modulation);
 
 	p->modulation = state->current_modulation;
 	p->frequency = state->current_frequency;
@@ -1071,7 +1101,9 @@ static int lgdt3306a_monitor_vsb(struct lgdt3306a_state *state)
 	if (ret)
 		return ret;
 	val &= 0xf8;
-	if ((snrRef > 18) && (maxPowerMan > 0x68) && (nCombDet == 0x01) && ((fbDlyCir == 0x03FF) || (fbDlyCir < 0x6C)))	{
+	if ((snrRef > 18) && (maxPowerMan > 0x68)
+	    && (nCombDet == 0x01)
+	    && ((fbDlyCir == 0x03FF) || (fbDlyCir < 0x6C))) {
 		/* SNR is over 18dB and no ghosting */
 		val |= 0x00; /* final bandwidth = 0 */
 	} else {
@@ -1104,7 +1136,8 @@ static int lgdt3306a_monitor_vsb(struct lgdt3306a_state *state)
 	return ret;
 }
 
-static enum lgdt3306a_modulation lgdt3306a_check_oper_mode(struct lgdt3306a_state *state)
+static enum lgdt3306a_modulation
+lgdt3306a_check_oper_mode(struct lgdt3306a_state *state)
 {
 	u8 val = 0;
 	int ret;
@@ -1134,8 +1167,9 @@ static enum lgdt3306a_modulation lgdt3306a_check_oper_mode(struct lgdt3306a_stat
 	return LG3306_UNKNOWN_MODE;
 }
 
-static enum lgdt3306a_lock_status lgdt3306a_check_lock_status(struct lgdt3306a_state *state,
-			enum lgdt3306a_lock_check whatLock)
+static enum lgdt3306a_lock_status
+lgdt3306a_check_lock_status(struct lgdt3306a_state *state,
+			    enum lgdt3306a_lock_check whatLock)
 {
 	u8 val = 0;
 	int ret;
@@ -1219,7 +1253,8 @@ static enum lgdt3306a_lock_status lgdt3306a_check_lock_status(struct lgdt3306a_s
 	return lockStatus;
 }
 
-static enum lgdt3306a_neverlock_status lgdt3306a_check_neverlock_status(struct lgdt3306a_state *state)
+static enum lgdt3306a_neverlock_status
+lgdt3306a_check_neverlock_status(struct lgdt3306a_state *state)
 {
 	u8 val = 0;
 	int ret;
@@ -1267,7 +1302,8 @@ static int lgdt3306a_pre_monitoring(struct lgdt3306a_state *state)
 		snrRef, mainStrong, aiccrejStatus, currChDiffACQ);
 
 #if 0
-	if ((mainStrong == 0) && (currChDiffACQ > 0x70)) /* Dynamic ghost exists */
+	/* Dynamic ghost exists */
+	if ((mainStrong == 0) && (currChDiffACQ > 0x70))
 #endif
 	if (mainStrong == 0) {
 		ret = lgdt3306a_read_reg(state, 0x2135, &val);
@@ -1317,7 +1353,8 @@ static int lgdt3306a_pre_monitoring(struct lgdt3306a_state *state)
 	return 0;
 }
 
-static enum lgdt3306a_lock_status lgdt3306a_sync_lock_poll(struct lgdt3306a_state *state)
+static enum lgdt3306a_lock_status
+lgdt3306a_sync_lock_poll(struct lgdt3306a_state *state)
 {
 	enum lgdt3306a_lock_status syncLockStatus = LG3306_UNLOCK;
 	int	i;
@@ -1325,7 +1362,8 @@ static enum lgdt3306a_lock_status lgdt3306a_sync_lock_poll(struct lgdt3306a_stat
 	for (i = 0; i < 2; i++)	{
 		msleep(30);
 
-		syncLockStatus = lgdt3306a_check_lock_status(state, LG3306_SYNC_LOCK);
+		syncLockStatus = lgdt3306a_check_lock_status(state,
+							     LG3306_SYNC_LOCK);
 
 		if (syncLockStatus == LG3306_LOCK) {
 			dbg_info("locked(%d)\n", i);
@@ -1336,7 +1374,8 @@ static enum lgdt3306a_lock_status lgdt3306a_sync_lock_poll(struct lgdt3306a_stat
 	return LG3306_UNLOCK;
 }
 
-static enum lgdt3306a_lock_status lgdt3306a_fec_lock_poll(struct lgdt3306a_state *state)
+static enum lgdt3306a_lock_status
+lgdt3306a_fec_lock_poll(struct lgdt3306a_state *state)
 {
 	enum lgdt3306a_lock_status FECLockStatus = LG3306_UNLOCK;
 	int	i;
@@ -1344,7 +1383,8 @@ static enum lgdt3306a_lock_status lgdt3306a_fec_lock_poll(struct lgdt3306a_state
 	for (i = 0; i < 2; i++)	{
 		msleep(30);
 
-		FECLockStatus = lgdt3306a_check_lock_status(state, LG3306_FEC_LOCK);
+		FECLockStatus = lgdt3306a_check_lock_status(state,
+							    LG3306_FEC_LOCK);
 
 		if (FECLockStatus == LG3306_LOCK) {
 			dbg_info("locked(%d)\n", i);
@@ -1355,7 +1395,8 @@ static enum lgdt3306a_lock_status lgdt3306a_fec_lock_poll(struct lgdt3306a_state
 	return FECLockStatus;
 }
 
-static enum lgdt3306a_neverlock_status lgdt3306a_neverlock_poll(struct lgdt3306a_state *state)
+static enum lgdt3306a_neverlock_status
+lgdt3306a_neverlock_poll(struct lgdt3306a_state *state)
 {
 	enum lgdt3306a_neverlock_status NLLockStatus = LG3306_NL_FAIL;
 	int	i;
@@ -1458,7 +1499,8 @@ static u32 lgdt3306a_calculate_snr_x100(struct lgdt3306a_state *state)
 	return snr_x100;
 }
 
-static enum lgdt3306a_lock_status lgdt3306a_vsb_lock_poll(struct lgdt3306a_state *state)
+static enum lgdt3306a_lock_status
+lgdt3306a_vsb_lock_poll(struct lgdt3306a_state *state)
 {
 	int ret;
 	u8 cnt = 0;
@@ -1488,7 +1530,8 @@ static enum lgdt3306a_lock_status lgdt3306a_vsb_lock_poll(struct lgdt3306a_state
 	return LG3306_UNLOCK;
 }
 
-static enum lgdt3306a_lock_status lgdt3306a_qam_lock_poll(struct lgdt3306a_state *state)
+static enum lgdt3306a_lock_status
+lgdt3306a_qam_lock_poll(struct lgdt3306a_state *state)
 {
 	u8 cnt;
 	u8 packet_error;
@@ -1632,7 +1675,7 @@ static int lgdt3306a_read_ber(struct dvb_frontend *fe, u32 *ber)
 
 	*ber = 0;
 #if 1
-	/* FGR - BUGBUG - I don't know what value is expected by dvb_core
+	/* FGR - FIXME - I don't know what value is expected by dvb_core
 	 * what is the scale of the value?? */
 	tmp =              read_reg(state, 0x00fc); /* NBERVALUE[24-31] */
 	tmp = (tmp << 8) | read_reg(state, 0x00fd); /* NBERVALUE[16-23] */
@@ -1650,7 +1693,7 @@ static int lgdt3306a_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)
 
 	*ucblocks = 0;
 #if 1
-	/* FGR - BUGBUG - I don't know what value is expected by dvb_core
+	/* FGR - FIXME - I don't know what value is expected by dvb_core
 	 * what happens when value wraps? */
 	*ucblocks = read_reg(state, 0x00f4); /* TPIFTPERRCNT[0-7] */
 	dbg_info("ucblocks=%u\n", *ucblocks);
@@ -1659,7 +1702,9 @@ static int lgdt3306a_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)
 	return 0;
 }
 
-static int lgdt3306a_tune(struct dvb_frontend *fe, bool re_tune, unsigned int mode_flags, unsigned int *delay, fe_status_t *status)
+static int lgdt3306a_tune(struct dvb_frontend *fe, bool re_tune,
+			  unsigned int mode_flags, unsigned int *delay,
+			  fe_status_t *status)
 {
 	int ret = 0;
 	struct lgdt3306a_state *state = fe->demodulator_priv;
@@ -1761,7 +1806,8 @@ struct dvb_frontend *lgdt3306a_attach(const struct lgdt3306a_config *config,
 	if ((val & 0x74) != 0x74) {
 		pr_warn("expected 0x74, got 0x%x\n", (val & 0x74));
 #if 0
-		goto fail;	/* BUGBUG - re-enable when we know this is right */
+		/* FIXME - re-enable when we know this is right */
+		goto fail;
 #endif
 	}
 	ret = lgdt3306a_read_reg(state, 0x0001, &val);
@@ -1770,7 +1816,8 @@ struct dvb_frontend *lgdt3306a_attach(const struct lgdt3306a_config *config,
 	if ((val & 0xf6) != 0xc6) {
 		pr_warn("expected 0xc6, got 0x%x\n", (val & 0xf6));
 #if 0
-		goto fail;	/* BUGBUG - re-enable when we know this is right */
+		/* FIXME - re-enable when we know this is right */
+		goto fail;
 #endif
 	}
 	ret = lgdt3306a_read_reg(state, 0x0002, &val);
@@ -1779,7 +1826,8 @@ struct dvb_frontend *lgdt3306a_attach(const struct lgdt3306a_config *config,
 	if ((val & 0x73) != 0x03) {
 		pr_warn("expected 0x03, got 0x%x\n", (val & 0x73));
 #if 0
-		goto fail;	/* BUGBUG - re-enable when we know this is right */
+		/* FIXME - re-enable when we know this is right */
+		goto fail;
 #endif
 	}
 

commit 9369fe012d06c4a8775984609bc068e85bfeec8f
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Tue Oct 28 12:30:44 2014 -0200

    [media] lgdt3306a: constify log tables
    
    Ideally, we should be replacing this function by intlog10().
    
    While we don't do that, let's at least constify the tables,
    in order to remove its code footfrint, and get rid of nelems.
    
    This also fixes a few 80-cols CodingStyle warnings.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/lgdt3306a.c b/drivers/media/dvb-frontends/lgdt3306a.c
index 9c80d4c26381..ad483be1b64e 100644
--- a/drivers/media/dvb-frontends/lgdt3306a.c
+++ b/drivers/media/dvb-frontends/lgdt3306a.c
@@ -1386,11 +1386,15 @@ static u8 lgdt3306a_get_packet_error(struct lgdt3306a_state *state)
 	return val;
 }
 
+static const u32 valx_x10[] = {
+	10,  11,  13,  15,  17,  20,  25,  33,  41,  50,  59,  73,  87,  100
+};
+static const u32 log10x_x1000[] = {
+	0,  41, 114, 176, 230, 301, 398, 518, 613, 699, 771, 863, 939, 1000
+};
+
 static u32 log10_x1000(u32 x)
 {
-	static u32 valx_x10[]     = {  10,  11,  13,  15,  17,  20,  25,  33,  41,  50,  59,  73,  87,  100 };
-	static u32 log10x_x1000[] = {   0,  41, 114, 176, 230, 301, 398, 518, 613, 699, 771, 863, 939, 1000 };
-	static u32 nelems = sizeof(valx_x10)/sizeof(valx_x10[0]);
 	u32 diff_val, step_val, step_log10;
 	u32 log_val = 0;
 	u32 i;
@@ -1418,11 +1422,11 @@ static u32 log10_x1000(u32 x)
 		return log_val;	/* don't need to interpolate */
 
 	/* find our place on the log curve */
-	for (i = 1; i < nelems; i++) {
+	for (i = 1; i < ARRAY_SIZE(valx_x10); i++) {
 		if (valx_x10[i] >= x)
 			break;
 	}
-	if (i == nelems)
+	if (i == ARRAY_SIZE(valx_x10))
 		return log_val + log10x_x1000[i - 1];
 
 	diff_val   = x - valx_x10[i-1];

commit c9897649db868dc7d42a92437534baa7bbe04044
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Tue Oct 28 12:07:52 2014 -0200

    [media] lbdt3306a: remove uneeded braces
    
    WARNING: braces {} are not necessary for any arm of this statement
    +               if (ret == 0) {
    [...]
    +               } else {
    [...]
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/lgdt3306a.c b/drivers/media/dvb-frontends/lgdt3306a.c
index 38b64b2c745c..9c80d4c26381 100644
--- a/drivers/media/dvb-frontends/lgdt3306a.c
+++ b/drivers/media/dvb-frontends/lgdt3306a.c
@@ -1518,11 +1518,10 @@ static int lgdt3306a_read_status(struct dvb_frontend *fe, fe_status_t *status)
 
 	if (fe->ops.tuner_ops.get_rf_strength) {
 		ret = fe->ops.tuner_ops.get_rf_strength(fe, &strength);
-		if (ret == 0) {
+		if (ret == 0)
 			dbg_info("strength=%d\n", strength);
-		} else {
+		else
 			dbg_info("fe->ops.tuner_ops.get_rf_strength() failed\n");
-		}
 	}
 
 	*status = 0;

commit b4e43e959b45549a1d5341d89571fb4d8d03b736
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Tue Oct 28 12:05:35 2014 -0200

    [media] lgdt3306a: Don't use else were not needed
    
    Get rid of the remaining checkpatch.pl warnings:
            WARNING: braces {} are not necessary for any arm of this statement
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/lgdt3306a.c b/drivers/media/dvb-frontends/lgdt3306a.c
index 0356810da444..38b64b2c745c 100644
--- a/drivers/media/dvb-frontends/lgdt3306a.c
+++ b/drivers/media/dvb-frontends/lgdt3306a.c
@@ -1125,10 +1125,9 @@ static enum lgdt3306a_modulation lgdt3306a_check_oper_mode(struct lgdt3306a_stat
 		if (val & 0x01) {
 			dbg_info("QAM256\n");
 			return LG3306_QAM256;
-		} else {
-			dbg_info("QAM64\n");
-			return LG3306_QAM64;
 		}
+		dbg_info("QAM64\n");
+		return LG3306_QAM64;
 	}
 err:
 	pr_warn("UNKNOWN\n");
@@ -1399,14 +1398,15 @@ static u32 log10_x1000(u32 x)
 	if (x <= 0)
 		return -1000000; /* signal error */
 
+	if (x == 10)
+		return 0; /* log(1)=0 */
+
 	if (x < 10) {
 		while (x < 10) {
 			x = x * 10;
 			log_val--;
 		}
-	} else if (x == 10) {
-		return 0; /* log(1)=0 */
-	} else {
+	} else {	/* x > 10 */
 		while (x >= 100) {
 			x = x / 10;
 			log_val++;

commit b1a88c713a81705fd2a86d8d8404399f8acc76ba
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Tue Oct 28 12:00:48 2014 -0200

    [media] lbdt3306a: simplify the lock status check
    
    The logic there is too complex and it looks like an inifite
    loop.
    
    So, simplify the logic and implement it as a for loop.
    
    This gets rid of the following checkpatch.pl warnings:
    
    WARNING: else is not generally useful after a break or return
    +                       return LG3306_UNLOCK;
    +               } else {
    
    WARNING: else is not generally useful after a break or return
    +                       return LG3306_UNLOCK;
    +               } else {
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/lgdt3306a.c b/drivers/media/dvb-frontends/lgdt3306a.c
index 85fc9c63e3ca..0356810da444 100644
--- a/drivers/media/dvb-frontends/lgdt3306a.c
+++ b/drivers/media/dvb-frontends/lgdt3306a.c
@@ -1461,64 +1461,52 @@ static enum lgdt3306a_lock_status lgdt3306a_vsb_lock_poll(struct lgdt3306a_state
 	u8 packet_error;
 	u32 snr;
 
-	while (1) {
+	for (cnt = 0; cnt < 10; cnt++) {
 		if (lgdt3306a_sync_lock_poll(state) == LG3306_UNLOCK) {
 			dbg_info("no sync lock!\n");
 			return LG3306_UNLOCK;
-		} else {
-			msleep(20);
-			ret = lgdt3306a_pre_monitoring(state);
-			if (ret)
-				return LG3306_UNLOCK;
+		}
 
-			packet_error = lgdt3306a_get_packet_error(state);
-			snr = lgdt3306a_calculate_snr_x100(state);
-			dbg_info("cnt=%d errors=%d snr=%d\n",
-			       cnt, packet_error, snr);
+		msleep(20);
+		ret = lgdt3306a_pre_monitoring(state);
+		if (ret)
+			break;
 
-			if ((snr < 1500) || (packet_error >= 0xff))
-				cnt++;
-			else
-				return LG3306_LOCK;
+		packet_error = lgdt3306a_get_packet_error(state);
+		snr = lgdt3306a_calculate_snr_x100(state);
+		dbg_info("cnt=%d errors=%d snr=%d\n", cnt, packet_error, snr);
 
-			if (cnt >= 10) {
-				dbg_info("not locked!\n");
-				return LG3306_UNLOCK;
-			}
-		}
+		if ((snr >= 1500) && (packet_error < 0xff))
+			return LG3306_LOCK;
 	}
+
+	dbg_info("not locked!\n");
 	return LG3306_UNLOCK;
 }
 
 static enum lgdt3306a_lock_status lgdt3306a_qam_lock_poll(struct lgdt3306a_state *state)
 {
-	u8 cnt = 0;
+	u8 cnt;
 	u8 packet_error;
 	u32	snr;
 
-	while (1) {
+	for (cnt = 0; cnt < 10; cnt++) {
 		if (lgdt3306a_fec_lock_poll(state) == LG3306_UNLOCK) {
 			dbg_info("no fec lock!\n");
 			return LG3306_UNLOCK;
-		} else {
-			msleep(20);
+		}
 
-			packet_error = lgdt3306a_get_packet_error(state);
-			snr = lgdt3306a_calculate_snr_x100(state);
-			dbg_info("cnt=%d errors=%d snr=%d\n",
-			       cnt, packet_error, snr);
+		msleep(20);
 
-			if ((snr < 1500) || (packet_error >= 0xff))
-				cnt++;
-			else
-				return LG3306_LOCK;
+		packet_error = lgdt3306a_get_packet_error(state);
+		snr = lgdt3306a_calculate_snr_x100(state);
+		dbg_info("cnt=%d errors=%d snr=%d\n", cnt, packet_error, snr);
 
-			if (cnt >= 10) {
-				dbg_info("not locked!\n");
-				return LG3306_UNLOCK;
-			}
-		}
+		if ((snr >= 1500) && (packet_error < 0xff))
+			return LG3306_LOCK;
 	}
+
+	dbg_info("not locked!\n");
 	return LG3306_UNLOCK;
 }
 

commit 097117cab5041cdd85aafc2a8af1113cbdf65e27
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Tue Oct 28 11:35:16 2014 -0200

    [media] lbdt3306a: rework at printk macros
    
    Use pr_foo() where there's a direct replacement. For debug, use
    custom-made macros, for now, as there are 3 different debug levels.
    
    We should get rid of those some day, specially since several such
    macros can be just removed, as Kernel trace would provide about
    the same output.
    
    This gets rid of some checkpatch errors:
    
    WARNING: Prefer [subsystem eg: netdev]_info([subsystem]dev, ... then dev_info(dev, ... then pr_info(...  to printk(KERN_INFO ...
    +#define lg_info(fmt, arg...)   printk(KERN_INFO "lgdt3306a: " fmt, ##arg)
    
    ERROR: Macros with complex values should be enclosed in parentheses
    +#define lg_dbg(fmt, arg...) if (debug & DBG_INFO)                      \
    +                               lg_printk(KERN_DEBUG,         fmt, ##arg)
    
    ERROR: Macros with complex values should be enclosed in parentheses
    +#define lg_reg(fmt, arg...) if (debug & DBG_REG)                       \
    +                               lg_printk(KERN_DEBUG,         fmt, ##arg)
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/lgdt3306a.c b/drivers/media/dvb-frontends/lgdt3306a.c
index 54c2c282e97e..85fc9c63e3ca 100644
--- a/drivers/media/dvb-frontends/lgdt3306a.c
+++ b/drivers/media/dvb-frontends/lgdt3306a.c
@@ -16,6 +16,8 @@
  *    GNU General Public License for more details.
  */
 
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
 #include <asm/div64.h>
 #include <linux/dvb/frontend.h>
 #include "dvb_math.h"
@@ -30,23 +32,27 @@ MODULE_PARM_DESC(debug, "set debug level (info=1, reg=2 (or-able))");
 #define DBG_REG  2
 #define DBG_DUMP 4 /* FGR - comment out to remove dump code */
 
-#define lg_printk(kern, fmt, arg...)					\
-	printk(kern "%s(): " fmt, __func__, ##arg)
+#define lg_debug(fmt, arg...) \
+	printk(KERN_DEBUG pr_fmt(fmt), ## arg)
+
+#define dbg_info(fmt, arg...)					\
+	do {							\
+		if (debug & DBG_INFO)				\
+			lg_debug(fmt, ## arg);			\
+	} while (0)
 
-#define lg_info(fmt, arg...)	printk(KERN_INFO "lgdt3306a: " fmt, ##arg)
-#define lg_warn(fmt, arg...)	lg_printk(KERN_WARNING,       fmt, ##arg)
-#define lg_err(fmt, arg...)	lg_printk(KERN_ERR,           fmt, ##arg)
-#define lg_dbg(fmt, arg...) if (debug & DBG_INFO)			\
-				lg_printk(KERN_DEBUG,         fmt, ##arg)
-#define lg_reg(fmt, arg...) if (debug & DBG_REG)			\
-				lg_printk(KERN_DEBUG,         fmt, ##arg)
+#define dbg_reg(fmt, arg...)					\
+	do {							\
+		if (debug & DBG_REG)				\
+			lg_debug(fmt, ## arg);			\
+	} while (0)
 
 #define lg_chkerr(ret)							\
 ({									\
 	int __ret;							\
 	__ret = (ret < 0);						\
 	if (__ret)							\
-		lg_err("error %d on line %d\n",	ret, __LINE__);		\
+		pr_err("error %d on line %d\n",	ret, __LINE__);		\
 	__ret;								\
 })
 
@@ -116,12 +122,12 @@ static int lgdt3306a_write_reg(struct lgdt3306a_state *state, u16 reg, u8 val)
 		.buf = buf, .len = 3,
 	};
 
-	lg_reg("reg: 0x%04x, val: 0x%02x\n", reg, val);
+	dbg_reg("reg: 0x%04x, val: 0x%02x\n", reg, val);
 
 	ret = i2c_transfer(state->i2c_adap, &msg, 1);
 
 	if (ret != 1) {
-		lg_err("error (addr %02x %02x <- %02x, err = %i)\n",
+		pr_err("error (addr %02x %02x <- %02x, err = %i)\n",
 		       msg.buf[0], msg.buf[1], msg.buf[2], ret);
 		if (ret < 0)
 			return ret;
@@ -145,14 +151,14 @@ static int lgdt3306a_read_reg(struct lgdt3306a_state *state, u16 reg, u8 *val)
 	ret = i2c_transfer(state->i2c_adap, msg, 2);
 
 	if (ret != 2) {
-		lg_err("error (addr %02x reg %04x error (ret == %i)\n",
+		pr_err("error (addr %02x reg %04x error (ret == %i)\n",
 		       state->cfg->i2c_addr, reg, ret);
 		if (ret < 0)
 			return ret;
 		else
 			return -EREMOTEIO;
 	}
-	lg_reg("reg: 0x%04x, val: 0x%02x\n", reg, *val);
+	dbg_reg("reg: 0x%04x, val: 0x%02x\n", reg, *val);
 
 	return 0;
 }
@@ -172,7 +178,7 @@ static int lgdt3306a_set_reg_bit(struct lgdt3306a_state *state,
 	u8 val;
 	int ret;
 
-	lg_reg("reg: 0x%04x, bit: %d, level: %d\n", reg, bit, onoff);
+	dbg_reg("reg: 0x%04x, bit: %d, level: %d\n", reg, bit, onoff);
 
 	ret = lgdt3306a_read_reg(state, reg, &val);
 	if (lg_chkerr(ret))
@@ -193,7 +199,7 @@ static int lgdt3306a_soft_reset(struct lgdt3306a_state *state)
 {
 	int ret;
 
-	lg_dbg("\n");
+	dbg_info("\n");
 
 	ret = lgdt3306a_set_reg_bit(state, 0x0000, 7, 0);
 	if (lg_chkerr(ret))
@@ -213,7 +219,7 @@ static int lgdt3306a_mpeg_mode(struct lgdt3306a_state *state,
 	u8 val;
 	int ret;
 
-	lg_dbg("(%d)\n", mode);
+	dbg_info("(%d)\n", mode);
 	/* transport packet format */
 	ret = lgdt3306a_set_reg_bit(state, 0x0071, 7, mode == LGDT3306A_MPEG_PARALLEL?1:0); /* TPSENB=0x80 */
 	if (lg_chkerr(ret))
@@ -247,7 +253,7 @@ static int lgdt3306a_mpeg_mode_polarity(struct lgdt3306a_state *state,
 	u8 val;
 	int ret;
 
-	lg_dbg("edge=%d, valid=%d\n", edge, valid);
+	dbg_info("edge=%d, valid=%d\n", edge, valid);
 
 	ret = lgdt3306a_read_reg(state, 0x0070, &val);
 	if (lg_chkerr(ret))
@@ -273,7 +279,7 @@ static int lgdt3306a_mpeg_tristate(struct lgdt3306a_state *state,
 	u8 val;
 	int ret;
 
-	lg_dbg("(%d)\n", mode);
+	dbg_info("(%d)\n", mode);
 
 	if (mode) {
 		ret = lgdt3306a_read_reg(state, 0x0070, &val);
@@ -311,7 +317,7 @@ static int lgdt3306a_ts_bus_ctrl(struct dvb_frontend *fe, int acquire)
 {
 	struct lgdt3306a_state *state = fe->demodulator_priv;
 
-	lg_dbg("acquire=%d\n", acquire);
+	dbg_info("acquire=%d\n", acquire);
 
 	return lgdt3306a_mpeg_tristate(state, acquire ? 0 : 1);
 
@@ -322,7 +328,7 @@ static int lgdt3306a_power(struct lgdt3306a_state *state,
 {
 	int ret;
 
-	lg_dbg("(%d)\n", mode);
+	dbg_info("(%d)\n", mode);
 
 	if (mode == 0) {
 		ret = lgdt3306a_set_reg_bit(state, 0x0000, 7, 0); /* into reset */
@@ -356,7 +362,7 @@ static int lgdt3306a_set_vsb(struct lgdt3306a_state *state)
 	u8 val;
 	int ret;
 
-	lg_dbg("\n");
+	dbg_info("\n");
 
 	/* 0. Spectrum inversion detection manual; spectrum inverted */
 	ret = lgdt3306a_read_reg(state, 0x0002, &val);
@@ -506,7 +512,7 @@ static int lgdt3306a_set_vsb(struct lgdt3306a_state *state)
 	if (lg_chkerr(ret))
 		goto fail;
 
-	lg_dbg("complete\n");
+	dbg_info("complete\n");
 fail:
 	return ret;
 }
@@ -516,7 +522,7 @@ static int lgdt3306a_set_qam(struct lgdt3306a_state *state, int modulation)
 	u8 val;
 	int ret;
 
-	lg_dbg("modulation=%d\n", modulation);
+	dbg_info("modulation=%d\n", modulation);
 
 	/* 1. Selection of standard mode(0x08=QAM, 0x80=VSB) */
 	ret = lgdt3306a_write_reg(state, 0x0008, 0x08);
@@ -578,7 +584,7 @@ static int lgdt3306a_set_qam(struct lgdt3306a_state *state, int modulation)
 	if (lg_chkerr(ret))
 		goto fail;
 
-	lg_dbg("complete\n");
+	dbg_info("complete\n");
 fail:
 	return ret;
 }
@@ -588,7 +594,7 @@ static int lgdt3306a_set_modulation(struct lgdt3306a_state *state,
 {
 	int ret;
 
-	lg_dbg("\n");
+	dbg_info("\n");
 
 	switch (p->modulation) {
 	case VSB_8:
@@ -618,7 +624,7 @@ static int lgdt3306a_agc_setup(struct lgdt3306a_state *state,
 			      struct dtv_frontend_properties *p)
 {
 	/* TODO: anything we want to do here??? */
-	lg_dbg("\n");
+	dbg_info("\n");
 
 	switch (p->modulation) {
 	case VSB_8:
@@ -639,7 +645,7 @@ static int lgdt3306a_set_inversion(struct lgdt3306a_state *state,
 {
 	int ret;
 
-	lg_dbg("(%d)\n", inversion);
+	dbg_info("(%d)\n", inversion);
 
 	ret = lgdt3306a_set_reg_bit(state, 0x0002, 2, inversion ? 1 : 0);
 	return ret;
@@ -650,7 +656,7 @@ static int lgdt3306a_set_inversion_auto(struct lgdt3306a_state *state,
 {
 	int ret;
 
-	lg_dbg("(%d)\n", enabled);
+	dbg_info("(%d)\n", enabled);
 
 	/* 0=Manual 1=Auto(QAM only) */
 	ret = lgdt3306a_set_reg_bit(state, 0x0002, 3, enabled);/* SPECINVAUTO=0x04 */
@@ -663,7 +669,7 @@ static int lgdt3306a_spectral_inversion(struct lgdt3306a_state *state,
 {
 	int ret = 0;
 
-	lg_dbg("(%d)\n", inversion);
+	dbg_info("(%d)\n", inversion);
 #if 0
 /* FGR - spectral_inversion defaults already set for VSB and QAM; can enable later if desired */
 
@@ -705,7 +711,7 @@ static int lgdt3306a_set_if(struct lgdt3306a_state *state,
 
 	switch (if_freq_khz) {
 	default:
-	    lg_warn("IF=%d KHz is not supportted, 3250 assumed\n", if_freq_khz);
+	    pr_warn("IF=%d KHz is not supportted, 3250 assumed\n", if_freq_khz);
 		/* fallthrough */
 	case 3250: /* 3.25Mhz */
 		nco1 = 0x34;
@@ -735,7 +741,7 @@ static int lgdt3306a_set_if(struct lgdt3306a_state *state,
 	if (ret)
 		return ret;
 
-	lg_dbg("if_freq=%d KHz->[%04x]\n", if_freq_khz, nco1<<8 | nco2);
+	dbg_info("if_freq=%d KHz->[%04x]\n", if_freq_khz, nco1<<8 | nco2);
 
 	return 0;
 }
@@ -747,10 +753,10 @@ static int lgdt3306a_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)
 	struct lgdt3306a_state *state = fe->demodulator_priv;
 
 	if (state->cfg->deny_i2c_rptr) {
-		lg_dbg("deny_i2c_rptr=%d\n", state->cfg->deny_i2c_rptr);
+		dbg_info("deny_i2c_rptr=%d\n", state->cfg->deny_i2c_rptr);
 		return 0;
 	}
-	lg_dbg("(%d)\n", enable);
+	dbg_info("(%d)\n", enable);
 
 	return lgdt3306a_set_reg_bit(state, 0x0002, 7, enable ? 0 : 1); /* NI2CRPTEN=0x80 */
 }
@@ -759,7 +765,7 @@ static int lgdt3306a_sleep(struct lgdt3306a_state *state)
 {
 	int ret;
 
-	lg_dbg("\n");
+	dbg_info("\n");
 	state->current_frequency = -1; /* force re-tune, when we wake */
 
 	ret = lgdt3306a_mpeg_tristate(state, 1); /* disable data bus */
@@ -786,7 +792,7 @@ static int lgdt3306a_init(struct dvb_frontend *fe)
 	u8 val;
 	int ret;
 
-	lg_dbg("\n");
+	dbg_info("\n");
 
 	/* 1. Normal operation mode */
 	ret = lgdt3306a_set_reg_bit(state, 0x0001, 0, 1); /* SIMFASTENB=0x01 */
@@ -871,7 +877,7 @@ static int lgdt3306a_init(struct dvb_frontend *fe)
 		if (lg_chkerr(ret))
 			goto fail;
 	} else {
-		lg_err("Bad xtalMHz=%d\n", state->cfg->xtalMHz);
+		pr_err("Bad xtalMHz=%d\n", state->cfg->xtalMHz);
 	}
 #if 0
 	ret = lgdt3306a_write_reg(state, 0x000e, 0x00);
@@ -936,11 +942,11 @@ static int lgdt3306a_set_parameters(struct dvb_frontend *fe)
 	struct lgdt3306a_state *state = fe->demodulator_priv;
 	int ret;
 
-	lg_dbg("(%d, %d)\n", p->frequency, p->modulation);
+	dbg_info("(%d, %d)\n", p->frequency, p->modulation);
 
 	if (state->current_frequency  == p->frequency &&
 	   state->current_modulation == p->modulation) {
-		lg_dbg(" (already set, skipping ...)\n");
+		dbg_info(" (already set, skipping ...)\n");
 		return 0;
 	}
 	state->current_frequency = -1;
@@ -1009,7 +1015,7 @@ static int lgdt3306a_get_frontend(struct dvb_frontend *fe)
 	struct lgdt3306a_state *state = fe->demodulator_priv;
 	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
 
-	lg_dbg("(%u, %d)\n", state->current_frequency, state->current_modulation);
+	dbg_info("(%u, %d)\n", state->current_frequency, state->current_modulation);
 
 	p->modulation = state->current_modulation;
 	p->frequency = state->current_frequency;
@@ -1057,7 +1063,7 @@ static int lgdt3306a_monitor_vsb(struct lgdt3306a_state *state)
 		return ret;
 	fbDlyCir |= val;
 
-	lg_dbg("snrRef=%d maxPowerMan=0x%x nCombDet=%d fbDlyCir=0x%x\n",
+	dbg_info("snrRef=%d maxPowerMan=0x%x nCombDet=%d fbDlyCir=0x%x\n",
 		snrRef, maxPowerMan, nCombDet, fbDlyCir);
 
 	/* Carrier offset sub loop bandwidth */
@@ -1108,7 +1114,7 @@ static enum lgdt3306a_modulation lgdt3306a_check_oper_mode(struct lgdt3306a_stat
 		goto err;
 
 	if (val & 0x80)	{
-		lg_dbg("VSB\n");
+		dbg_info("VSB\n");
 		return LG3306_VSB;
 	}
 	if (val & 0x08) {
@@ -1117,15 +1123,15 @@ static enum lgdt3306a_modulation lgdt3306a_check_oper_mode(struct lgdt3306a_stat
 			goto err;
 		val = val >> 2;
 		if (val & 0x01) {
-			lg_dbg("QAM256\n");
+			dbg_info("QAM256\n");
 			return LG3306_QAM256;
 		} else {
-			lg_dbg("QAM64\n");
+			dbg_info("QAM64\n");
 			return LG3306_QAM64;
 		}
 	}
 err:
-	lg_warn("UNKNOWN\n");
+	pr_warn("UNKNOWN\n");
 	return LG3306_UNKNOWN_MODE;
 }
 
@@ -1151,7 +1157,7 @@ static enum lgdt3306a_lock_status lgdt3306a_check_lock_status(struct lgdt3306a_s
 		else
 			lockStatus = LG3306_UNLOCK;
 
-		lg_dbg("SYNC_LOCK=%x\n", lockStatus);
+		dbg_info("SYNC_LOCK=%x\n", lockStatus);
 		break;
 	}
 	case LG3306_AGC_LOCK:
@@ -1165,7 +1171,7 @@ static enum lgdt3306a_lock_status lgdt3306a_check_lock_status(struct lgdt3306a_s
 		else
 			lockStatus = LG3306_UNLOCK;
 
-		lg_dbg("AGC_LOCK=%x\n", lockStatus);
+		dbg_info("AGC_LOCK=%x\n", lockStatus);
 		break;
 	}
 	case LG3306_TR_LOCK:
@@ -1183,7 +1189,7 @@ static enum lgdt3306a_lock_status lgdt3306a_check_lock_status(struct lgdt3306a_s
 		} else
 			lockStatus = LG3306_UNKNOWN_LOCK;
 
-		lg_dbg("TR_LOCK=%x\n", lockStatus);
+		dbg_info("TR_LOCK=%x\n", lockStatus);
 		break;
 	}
 	case LG3306_FEC_LOCK:
@@ -1201,13 +1207,13 @@ static enum lgdt3306a_lock_status lgdt3306a_check_lock_status(struct lgdt3306a_s
 		} else
 			lockStatus = LG3306_UNKNOWN_LOCK;
 
-		lg_dbg("FEC_LOCK=%x\n", lockStatus);
+		dbg_info("FEC_LOCK=%x\n", lockStatus);
 		break;
 	}
 
 	default:
 		lockStatus = LG3306_UNKNOWN_LOCK;
-		lg_warn("UNKNOWN whatLock=%d\n", whatLock);
+		pr_warn("UNKNOWN whatLock=%d\n", whatLock);
 		break;
 	}
 
@@ -1225,7 +1231,7 @@ static enum lgdt3306a_neverlock_status lgdt3306a_check_neverlock_status(struct l
 		return ret;
 	lockStatus = (enum lgdt3306a_neverlock_status)(val & 0x03);
 
-	lg_dbg("NeverLock=%d", lockStatus);
+	dbg_info("NeverLock=%d", lockStatus);
 
 	return lockStatus;
 }
@@ -1258,7 +1264,7 @@ static int lgdt3306a_pre_monitoring(struct lgdt3306a_state *state)
 		return ret;
 	aiccrejStatus = (val & 0xf0) >> 4;
 
-	lg_dbg("snrRef=%d mainStrong=%d aiccrejStatus=%d currChDiffACQ=0x%x\n",
+	dbg_info("snrRef=%d mainStrong=%d aiccrejStatus=%d currChDiffACQ=0x%x\n",
 		snrRef, mainStrong, aiccrejStatus, currChDiffACQ);
 
 #if 0
@@ -1323,11 +1329,11 @@ static enum lgdt3306a_lock_status lgdt3306a_sync_lock_poll(struct lgdt3306a_stat
 		syncLockStatus = lgdt3306a_check_lock_status(state, LG3306_SYNC_LOCK);
 
 		if (syncLockStatus == LG3306_LOCK) {
-			lg_dbg("locked(%d)\n", i);
+			dbg_info("locked(%d)\n", i);
 			return LG3306_LOCK;
 		}
 	}
-	lg_dbg("not locked\n");
+	dbg_info("not locked\n");
 	return LG3306_UNLOCK;
 }
 
@@ -1342,11 +1348,11 @@ static enum lgdt3306a_lock_status lgdt3306a_fec_lock_poll(struct lgdt3306a_state
 		FECLockStatus = lgdt3306a_check_lock_status(state, LG3306_FEC_LOCK);
 
 		if (FECLockStatus == LG3306_LOCK) {
-			lg_dbg("locked(%d)\n", i);
+			dbg_info("locked(%d)\n", i);
 			return FECLockStatus;
 		}
 	}
-	lg_dbg("not locked\n");
+	dbg_info("not locked\n");
 	return FECLockStatus;
 }
 
@@ -1361,11 +1367,11 @@ static enum lgdt3306a_neverlock_status lgdt3306a_neverlock_poll(struct lgdt3306a
 		NLLockStatus = lgdt3306a_check_neverlock_status(state);
 
 		if (NLLockStatus == LG3306_NL_LOCK) {
-			lg_dbg("NL_LOCK(%d)\n", i);
+			dbg_info("NL_LOCK(%d)\n", i);
 			return NLLockStatus;
 		}
 	}
-	lg_dbg("NLLockStatus=%d\n", NLLockStatus);
+	dbg_info("NLLockStatus=%d\n", NLLockStatus);
 	return NLLockStatus;
 }
 
@@ -1443,7 +1449,7 @@ static u32 lgdt3306a_calculate_snr_x100(struct lgdt3306a_state *state)
 		return 0;
 
 	snr_x100 = log10_x1000((pwr * 10000) / mse) - 3000;
-	lg_dbg("mse=%u, pwr=%u, snr_x100=%d\n", mse, pwr, snr_x100);
+	dbg_info("mse=%u, pwr=%u, snr_x100=%d\n", mse, pwr, snr_x100);
 
 	return snr_x100;
 }
@@ -1457,7 +1463,7 @@ static enum lgdt3306a_lock_status lgdt3306a_vsb_lock_poll(struct lgdt3306a_state
 
 	while (1) {
 		if (lgdt3306a_sync_lock_poll(state) == LG3306_UNLOCK) {
-			lg_dbg("no sync lock!\n");
+			dbg_info("no sync lock!\n");
 			return LG3306_UNLOCK;
 		} else {
 			msleep(20);
@@ -1467,7 +1473,7 @@ static enum lgdt3306a_lock_status lgdt3306a_vsb_lock_poll(struct lgdt3306a_state
 
 			packet_error = lgdt3306a_get_packet_error(state);
 			snr = lgdt3306a_calculate_snr_x100(state);
-			lg_dbg("cnt=%d errors=%d snr=%d\n",
+			dbg_info("cnt=%d errors=%d snr=%d\n",
 			       cnt, packet_error, snr);
 
 			if ((snr < 1500) || (packet_error >= 0xff))
@@ -1476,7 +1482,7 @@ static enum lgdt3306a_lock_status lgdt3306a_vsb_lock_poll(struct lgdt3306a_state
 				return LG3306_LOCK;
 
 			if (cnt >= 10) {
-				lg_dbg("not locked!\n");
+				dbg_info("not locked!\n");
 				return LG3306_UNLOCK;
 			}
 		}
@@ -1492,14 +1498,14 @@ static enum lgdt3306a_lock_status lgdt3306a_qam_lock_poll(struct lgdt3306a_state
 
 	while (1) {
 		if (lgdt3306a_fec_lock_poll(state) == LG3306_UNLOCK) {
-			lg_dbg("no fec lock!\n");
+			dbg_info("no fec lock!\n");
 			return LG3306_UNLOCK;
 		} else {
 			msleep(20);
 
 			packet_error = lgdt3306a_get_packet_error(state);
 			snr = lgdt3306a_calculate_snr_x100(state);
-			lg_dbg("cnt=%d errors=%d snr=%d\n",
+			dbg_info("cnt=%d errors=%d snr=%d\n",
 			       cnt, packet_error, snr);
 
 			if ((snr < 1500) || (packet_error >= 0xff))
@@ -1508,7 +1514,7 @@ static enum lgdt3306a_lock_status lgdt3306a_qam_lock_poll(struct lgdt3306a_state
 				return LG3306_LOCK;
 
 			if (cnt >= 10) {
-				lg_dbg("not locked!\n");
+				dbg_info("not locked!\n");
 				return LG3306_UNLOCK;
 			}
 		}
@@ -1525,9 +1531,9 @@ static int lgdt3306a_read_status(struct dvb_frontend *fe, fe_status_t *status)
 	if (fe->ops.tuner_ops.get_rf_strength) {
 		ret = fe->ops.tuner_ops.get_rf_strength(fe, &strength);
 		if (ret == 0) {
-			lg_dbg("strength=%d\n", strength);
+			dbg_info("strength=%d\n", strength);
 		} else {
-			lg_dbg("fe->ops.tuner_ops.get_rf_strength() failed\n");
+			dbg_info("fe->ops.tuner_ops.get_rf_strength() failed\n");
 		}
 	}
 
@@ -1620,7 +1626,7 @@ static int lgdt3306a_read_signal_strength(struct dvb_frontend *fe,
 		str = (0xffff * str) / 100;
 	}
 	*strength = (u16)str;
-	lg_dbg("strength=%u\n", *strength);
+	dbg_info("strength=%u\n", *strength);
 
 fail:
 	return ret;
@@ -1642,7 +1648,7 @@ static int lgdt3306a_read_ber(struct dvb_frontend *fe, u32 *ber)
 	tmp = (tmp << 8) | read_reg(state, 0x00fe); /* NBERVALUE[8-15] */
 	tmp = (tmp << 8) | read_reg(state, 0x00ff); /* NBERVALUE[0-7] */
 	*ber = tmp;
-	lg_dbg("ber=%u\n", tmp);
+	dbg_info("ber=%u\n", tmp);
 #endif
 	return 0;
 }
@@ -1656,7 +1662,7 @@ static int lgdt3306a_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)
 	/* FGR - BUGBUG - I don't know what value is expected by dvb_core
 	 * what happens when value wraps? */
 	*ucblocks = read_reg(state, 0x00f4); /* TPIFTPERRCNT[0-7] */
-	lg_dbg("ucblocks=%u\n", *ucblocks);
+	dbg_info("ucblocks=%u\n", *ucblocks);
 #endif
 
 	return 0;
@@ -1667,7 +1673,7 @@ static int lgdt3306a_tune(struct dvb_frontend *fe, bool re_tune, unsigned int mo
 	int ret = 0;
 	struct lgdt3306a_state *state = fe->demodulator_priv;
 
-	lg_dbg("re_tune=%u\n", re_tune);
+	dbg_info("re_tune=%u\n", re_tune);
 
 	if (re_tune) {
 		state->current_frequency = -1; /* force re-tune */
@@ -1686,7 +1692,7 @@ static int lgdt3306a_get_tune_settings(struct dvb_frontend *fe,
 				       *fe_tune_settings)
 {
 	fe_tune_settings->min_delay_ms = 100;
-	lg_dbg("\n");
+	dbg_info("\n");
 	return 0;
 }
 
@@ -1702,7 +1708,7 @@ static int lgdt3306a_search(struct dvb_frontend *fe)
 
 	/* wait frontend lock */
 	for (i = 20; i > 0; i--) {
-		lg_dbg(": loop=%d\n", i);
+		dbg_info(": loop=%d\n", i);
 		msleep(50);
 		ret = lgdt3306a_read_status(fe, &status);
 		if (ret)
@@ -1719,7 +1725,7 @@ static int lgdt3306a_search(struct dvb_frontend *fe)
 		return DVBFE_ALGO_SEARCH_AGAIN;
 
 error:
-	lg_dbg("failed (%d)\n", ret);
+	dbg_info("failed (%d)\n", ret);
 	return DVBFE_ALGO_SEARCH_ERROR;
 }
 
@@ -1727,7 +1733,7 @@ static void lgdt3306a_release(struct dvb_frontend *fe)
 {
 	struct lgdt3306a_state *state = fe->demodulator_priv;
 
-	lg_dbg("\n");
+	dbg_info("\n");
 	kfree(state);
 }
 
@@ -1740,7 +1746,7 @@ struct dvb_frontend *lgdt3306a_attach(const struct lgdt3306a_config *config,
 	int ret;
 	u8 val;
 
-	lg_dbg("(%d-%04x)\n",
+	dbg_info("(%d-%04x)\n",
 	       i2c_adap ? i2c_adapter_id(i2c_adap) : 0,
 	       config ? config->i2c_addr : 0);
 
@@ -1762,7 +1768,7 @@ struct dvb_frontend *lgdt3306a_attach(const struct lgdt3306a_config *config,
 	if (lg_chkerr(ret))
 		goto fail;
 	if ((val & 0x74) != 0x74) {
-		lg_warn("expected 0x74, got 0x%x\n", (val & 0x74));
+		pr_warn("expected 0x74, got 0x%x\n", (val & 0x74));
 #if 0
 		goto fail;	/* BUGBUG - re-enable when we know this is right */
 #endif
@@ -1771,7 +1777,7 @@ struct dvb_frontend *lgdt3306a_attach(const struct lgdt3306a_config *config,
 	if (lg_chkerr(ret))
 		goto fail;
 	if ((val & 0xf6) != 0xc6) {
-		lg_warn("expected 0xc6, got 0x%x\n", (val & 0xf6));
+		pr_warn("expected 0xc6, got 0x%x\n", (val & 0xf6));
 #if 0
 		goto fail;	/* BUGBUG - re-enable when we know this is right */
 #endif
@@ -1780,7 +1786,7 @@ struct dvb_frontend *lgdt3306a_attach(const struct lgdt3306a_config *config,
 	if (lg_chkerr(ret))
 		goto fail;
 	if ((val & 0x73) != 0x03) {
-		lg_warn("expected 0x03, got 0x%x\n", (val & 0x73));
+		pr_warn("expected 0x03, got 0x%x\n", (val & 0x73));
 #if 0
 		goto fail;	/* BUGBUG - re-enable when we know this is right */
 #endif
@@ -1794,7 +1800,7 @@ struct dvb_frontend *lgdt3306a_attach(const struct lgdt3306a_config *config,
 	return &state->frontend;
 
 fail:
-	lg_warn("unable to detect LGDT3306A hardware\n");
+	pr_warn("unable to detect LGDT3306A hardware\n");
 	kfree(state);
 	return NULL;
 }
@@ -2049,13 +2055,13 @@ static void lgdt3306a_DumpRegs(struct lgdt3306a_state *state)
 		return;
 	debug &= ~DBG_REG; /* suppress DBG_REG during reg dump */
 
-	lg_info("\n");
+	lg_debug("\n");
 
 	for (i = 0; i < numDumpRegs; i++) {
 		lgdt3306a_read_reg(state, regtab[i], &regval1[i]);
 		if (regval1[i] != regval2[i]) {
-			lg_info(" %04X = %02X\n", regtab[i], regval1[i]);
-				regval2[i] = regval1[i];
+			lg_debug(" %04X = %02X\n", regtab[i], regval1[i]);
+				 regval2[i] = regval1[i];
 		}
 	}
 	debug = sav_debug;

commit e2c47fa7dd4b38d930fe4131e65f0fa35236c9b5
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Tue Oct 28 11:27:34 2014 -0200

    [media] lgdt3306a: Remove FSF address
    
    Fix this CodingStyle error:
    
            ERROR: Do not include the paragraph about writing to the Free Software Foundation's mailing address from the sample GPL notice. The FSF has changed addresses in the past, and may do so ag$
            #56: FILE: drivers/media/dvb-frontends/lgdt3306a.c:19:
            + *    along with this program; if not, write to the Free Software$
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/lgdt3306a.c b/drivers/media/dvb-frontends/lgdt3306a.c
index d1a914de4180..54c2c282e97e 100644
--- a/drivers/media/dvb-frontends/lgdt3306a.c
+++ b/drivers/media/dvb-frontends/lgdt3306a.c
@@ -14,11 +14,6 @@
  *    but WITHOUT ANY WARRANTY; without even the implied warranty of
  *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *    GNU General Public License for more details.
- *
- *    You should have received a copy of the GNU General Public License
- *    along with this program; if not, write to the Free Software
- *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- *
  */
 
 #include <asm/div64.h>
@@ -1455,6 +1450,7 @@ static u32 lgdt3306a_calculate_snr_x100(struct lgdt3306a_state *state)
 
 static enum lgdt3306a_lock_status lgdt3306a_vsb_lock_poll(struct lgdt3306a_state *state)
 {
+	int ret;
 	u8 cnt = 0;
 	u8 packet_error;
 	u32 snr;

commit ee0133eea0238067dab19587de7d88e4a3ea77e4
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Tue Oct 28 11:21:48 2014 -0200

    [media] lgdt3306a: properly handle I/O errors
    
    Fixes the following smatch errors:
    
    drivers/media/dvb-frontends/lgdt3306a.c: In function 'lgdt3306a_set_if':
    drivers/media/dvb-frontends/lgdt3306a.c:695:6: warning: variable 'ret' set but not used [-Wunused-but-set-variable]
      int ret;
          ^
    drivers/media/dvb-frontends/lgdt3306a.c: In function 'lgdt3306a_monitor_vsb':
    drivers/media/dvb-frontends/lgdt3306a.c:1033:6: warning: variable 'ret' set but not used [-Wunused-but-set-variable]
      int ret;
          ^
    drivers/media/dvb-frontends/lgdt3306a.c: In function 'lgdt3306a_check_oper_mode':
    drivers/media/dvb-frontends/lgdt3306a.c:1082:6: warning: variable 'ret' set but not used [-Wunused-but-set-variable]
      int ret;
          ^
    drivers/media/dvb-frontends/lgdt3306a.c: In function 'lgdt3306a_check_lock_status':
    drivers/media/dvb-frontends/lgdt3306a.c:1109:6: warning: variable 'ret' set but not used [-Wunused-but-set-variable]
      int ret;
          ^
    drivers/media/dvb-frontends/lgdt3306a.c: In function 'lgdt3306a_check_neverlock_status':
    drivers/media/dvb-frontends/lgdt3306a.c:1185:6: warning: variable 'ret' set but not used [-Wunused-but-set-variable]
      int ret;
          ^
    drivers/media/dvb-frontends/lgdt3306a.c: In function 'lgdt3306a_pre_monitoring':
    drivers/media/dvb-frontends/lgdt3306a.c:1199:6: warning: variable 'ret' set but not used [-Wunused-but-set-variable]
      int ret;
          ^
    drivers/media/dvb-frontends/lgdt3306a.c: In function 'lgdt3306a_get_packet_error':
    drivers/media/dvb-frontends/lgdt3306a.c:1310:6: warning: variable 'ret' set but not used [-Wunused-but-set-variable]
      int ret;
          ^
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/lgdt3306a.c b/drivers/media/dvb-frontends/lgdt3306a.c
index 92affe124a8d..d1a914de4180 100644
--- a/drivers/media/dvb-frontends/lgdt3306a.c
+++ b/drivers/media/dvb-frontends/lgdt3306a.c
@@ -734,7 +734,11 @@ static int lgdt3306a_set_if(struct lgdt3306a_state *state,
 		break;
 	}
 	ret = lgdt3306a_write_reg(state, 0x0010, nco1);
+	if (ret)
+		return ret;
 	ret = lgdt3306a_write_reg(state, 0x0011, nco2);
+	if (ret)
+		return ret;
 
 	lg_dbg("if_freq=%d KHz->[%04x]\n", if_freq_khz, nco1<<8 | nco2);
 
@@ -1027,7 +1031,7 @@ static enum dvbfe_algo lgdt3306a_get_frontend_algo(struct dvb_frontend *fe)
 }
 
 /* ------------------------------------------------------------------------ */
-static void lgdt3306a_monitor_vsb(struct lgdt3306a_state *state)
+static int lgdt3306a_monitor_vsb(struct lgdt3306a_state *state)
 {
 	u8 val;
 	int ret;
@@ -1035,16 +1039,27 @@ static void lgdt3306a_monitor_vsb(struct lgdt3306a_state *state)
 	u16 fbDlyCir;
 
 	ret = lgdt3306a_read_reg(state, 0x21a1, &val);
+	if (ret)
+		return ret;
 	snrRef = val & 0x3f;
 
 	ret = lgdt3306a_read_reg(state, 0x2185, &maxPowerMan);
+	if (ret)
+		return ret;
 
 	ret = lgdt3306a_read_reg(state, 0x2191, &val);
+	if (ret)
+		return ret;
 	nCombDet = (val & 0x80) >> 7;
 
 	ret = lgdt3306a_read_reg(state, 0x2180, &val);
+	if (ret)
+		return ret;
 	fbDlyCir = (val & 0x03) << 8;
+
 	ret = lgdt3306a_read_reg(state, 0x2181, &val);
+	if (ret)
+		return ret;
 	fbDlyCir |= val;
 
 	lg_dbg("snrRef=%d maxPowerMan=0x%x nCombDet=%d fbDlyCir=0x%x\n",
@@ -1052,6 +1067,8 @@ static void lgdt3306a_monitor_vsb(struct lgdt3306a_state *state)
 
 	/* Carrier offset sub loop bandwidth */
 	ret = lgdt3306a_read_reg(state, 0x1061, &val);
+	if (ret)
+		return ret;
 	val &= 0xf8;
 	if ((snrRef > 18) && (maxPowerMan > 0x68) && (nCombDet == 0x01) && ((fbDlyCir == 0x03FF) || (fbDlyCir < 0x6C)))	{
 		/* SNR is over 18dB and no ghosting */
@@ -1060,20 +1077,30 @@ static void lgdt3306a_monitor_vsb(struct lgdt3306a_state *state)
 		val |= 0x04; /* final bandwidth = 4 */
 	}
 	ret = lgdt3306a_write_reg(state, 0x1061, val);
+	if (ret)
+		return ret;
 
 	/* Adjust Notch Filter */
 	ret = lgdt3306a_read_reg(state, 0x0024, &val);
+	if (ret)
+		return ret;
 	val &= 0x0f;
 	if (nCombDet == 0) { /* Turn on the Notch Filter */
 		val |= 0x50;
 	}
 	ret = lgdt3306a_write_reg(state, 0x0024, val);
+	if (ret)
+		return ret;
 
 	/* VSB Timing Recovery output normalization */
 	ret = lgdt3306a_read_reg(state, 0x103d, &val);
+	if (ret)
+		return ret;
 	val &= 0xcf;
 	val |= 0x20;
 	ret = lgdt3306a_write_reg(state, 0x103d, val);
+
+	return ret;
 }
 
 static enum lgdt3306a_modulation lgdt3306a_check_oper_mode(struct lgdt3306a_state *state)
@@ -1082,6 +1109,8 @@ static enum lgdt3306a_modulation lgdt3306a_check_oper_mode(struct lgdt3306a_stat
 	int ret;
 
 	ret = lgdt3306a_read_reg(state, 0x0081, &val);
+	if (ret)
+		goto err;
 
 	if (val & 0x80)	{
 		lg_dbg("VSB\n");
@@ -1089,6 +1118,8 @@ static enum lgdt3306a_modulation lgdt3306a_check_oper_mode(struct lgdt3306a_stat
 	}
 	if (val & 0x08) {
 		ret = lgdt3306a_read_reg(state, 0x00a6, &val);
+		if (ret)
+			goto err;
 		val = val >> 2;
 		if (val & 0x01) {
 			lg_dbg("QAM256\n");
@@ -1098,6 +1129,7 @@ static enum lgdt3306a_modulation lgdt3306a_check_oper_mode(struct lgdt3306a_stat
 			return LG3306_QAM64;
 		}
 	}
+err:
 	lg_warn("UNKNOWN\n");
 	return LG3306_UNKNOWN_MODE;
 }
@@ -1116,6 +1148,8 @@ static enum lgdt3306a_lock_status lgdt3306a_check_lock_status(struct lgdt3306a_s
 	case LG3306_SYNC_LOCK:
 	{
 		ret = lgdt3306a_read_reg(state, 0x00a6, &val);
+		if (ret)
+			return ret;
 
 		if ((val & 0x80) == 0x80)
 			lockStatus = LG3306_LOCK;
@@ -1128,6 +1162,8 @@ static enum lgdt3306a_lock_status lgdt3306a_check_lock_status(struct lgdt3306a_s
 	case LG3306_AGC_LOCK:
 	{
 		ret = lgdt3306a_read_reg(state, 0x0080, &val);
+		if (ret)
+			return ret;
 
 		if ((val & 0x40) == 0x40)
 			lockStatus = LG3306_LOCK;
@@ -1142,6 +1178,8 @@ static enum lgdt3306a_lock_status lgdt3306a_check_lock_status(struct lgdt3306a_s
 		modeOper = lgdt3306a_check_oper_mode(state);
 		if ((modeOper == LG3306_QAM64) || (modeOper == LG3306_QAM256)) {
 			ret = lgdt3306a_read_reg(state, 0x1094, &val);
+			if (ret)
+				return ret;
 
 			if ((val & 0x80) == 0x80)
 				lockStatus = LG3306_LOCK;
@@ -1158,6 +1196,8 @@ static enum lgdt3306a_lock_status lgdt3306a_check_lock_status(struct lgdt3306a_s
 		modeOper = lgdt3306a_check_oper_mode(state);
 		if ((modeOper == LG3306_QAM64) || (modeOper == LG3306_QAM256)) {
 			ret = lgdt3306a_read_reg(state, 0x0080, &val);
+			if (ret)
+				return ret;
 
 			if ((val & 0x10) == 0x10)
 				lockStatus = LG3306_LOCK;
@@ -1186,6 +1226,8 @@ static enum lgdt3306a_neverlock_status lgdt3306a_check_neverlock_status(struct l
 	enum lgdt3306a_neverlock_status lockStatus;
 
 	ret = lgdt3306a_read_reg(state, 0x0080, &val);
+	if (ret)
+		return ret;
 	lockStatus = (enum lgdt3306a_neverlock_status)(val & 0x03);
 
 	lg_dbg("NeverLock=%d", lockStatus);
@@ -1193,7 +1235,7 @@ static enum lgdt3306a_neverlock_status lgdt3306a_check_neverlock_status(struct l
 	return lockStatus;
 }
 
-static void lgdt3306a_pre_monitoring(struct lgdt3306a_state *state)
+static int lgdt3306a_pre_monitoring(struct lgdt3306a_state *state)
 {
 	u8 val = 0;
 	int ret;
@@ -1201,16 +1243,24 @@ static void lgdt3306a_pre_monitoring(struct lgdt3306a_state *state)
 
 	/* Channel variation */
 	ret = lgdt3306a_read_reg(state, 0x21bc, &currChDiffACQ);
+	if (ret)
+		return ret;
 
 	/* SNR of Frame sync */
 	ret = lgdt3306a_read_reg(state, 0x21a1, &val);
+	if (ret)
+		return ret;
 	snrRef = val & 0x3f;
 
 	/* Strong Main CIR */
 	ret = lgdt3306a_read_reg(state, 0x2199, &val);
+	if (ret)
+		return ret;
 	mainStrong = (val & 0x40) >> 6;
 
 	ret = lgdt3306a_read_reg(state, 0x0090, &val);
+	if (ret)
+		return ret;
 	aiccrejStatus = (val & 0xf0) >> 4;
 
 	lg_dbg("snrRef=%d mainStrong=%d aiccrejStatus=%d currChDiffACQ=0x%x\n",
@@ -1221,30 +1271,50 @@ static void lgdt3306a_pre_monitoring(struct lgdt3306a_state *state)
 #endif
 	if (mainStrong == 0) {
 		ret = lgdt3306a_read_reg(state, 0x2135, &val);
+		if (ret)
+			return ret;
 		val &= 0x0f;
 		val |= 0xa0;
 		ret = lgdt3306a_write_reg(state, 0x2135, val);
+		if (ret)
+			return ret;
 
 		ret = lgdt3306a_read_reg(state, 0x2141, &val);
+		if (ret)
+			return ret;
 		val &= 0x3f;
 		val |= 0x80;
 		ret = lgdt3306a_write_reg(state, 0x2141, val);
+		if (ret)
+			return ret;
 
 		ret = lgdt3306a_write_reg(state, 0x2122, 0x70);
+		if (ret)
+			return ret;
 	} else { /* Weak ghost or static channel */
 		ret = lgdt3306a_read_reg(state, 0x2135, &val);
+		if (ret)
+			return ret;
 		val &= 0x0f;
 		val |= 0x70;
 		ret = lgdt3306a_write_reg(state, 0x2135, val);
+		if (ret)
+			return ret;
 
 		ret = lgdt3306a_read_reg(state, 0x2141, &val);
+		if (ret)
+			return ret;
 		val &= 0x3f;
 		val |= 0x40;
 		ret = lgdt3306a_write_reg(state, 0x2141, val);
+		if (ret)
+			return ret;
 
 		ret = lgdt3306a_write_reg(state, 0x2122, 0x40);
+		if (ret)
+			return ret;
 	}
-
+	return 0;
 }
 
 static enum lgdt3306a_lock_status lgdt3306a_sync_lock_poll(struct lgdt3306a_state *state)
@@ -1310,6 +1380,8 @@ static u8 lgdt3306a_get_packet_error(struct lgdt3306a_state *state)
 	int ret;
 
 	ret = lgdt3306a_read_reg(state, 0x00fa, &val);
+	if (ret)
+		return ret;
 
 	return val;
 }
@@ -1393,7 +1465,9 @@ static enum lgdt3306a_lock_status lgdt3306a_vsb_lock_poll(struct lgdt3306a_state
 			return LG3306_UNLOCK;
 		} else {
 			msleep(20);
-			lgdt3306a_pre_monitoring(state);
+			ret = lgdt3306a_pre_monitoring(state);
+			if (ret)
+				return LG3306_UNLOCK;
 
 			packet_error = lgdt3306a_get_packet_error(state);
 			snr = lgdt3306a_calculate_snr_x100(state);
@@ -1483,7 +1557,7 @@ static int lgdt3306a_read_status(struct dvb_frontend *fe, fe_status_t *status)
 
 				*status |= FE_HAS_LOCK;
 
-				lgdt3306a_monitor_vsb(state);
+				ret = lgdt3306a_monitor_vsb(state);
 			}
 			break;
 		default:

commit a132fef816606ebe9d20895b1535582bfede12a4
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Tue Oct 28 11:07:03 2014 -0200

    [media] lgdt3306a: don't go past the buffer
    
    As warned by smatch:
            drivers/media/dvb-frontends/lgdt3306a.c:1354 log10_x1000() error: buffer overflow 'valx_x10' 14 <= 14
            drivers/media/dvb-frontends/lgdt3306a.c:1355 log10_x1000() error: buffer overflow 'log10x_x1000' 14 <= 14
    
    There's a potential of returning a value out of the buffer. Fix it.
    
    While here, remove the ugly braced block.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/lgdt3306a.c b/drivers/media/dvb-frontends/lgdt3306a.c
index c8af071ce40b..92affe124a8d 100644
--- a/drivers/media/dvb-frontends/lgdt3306a.c
+++ b/drivers/media/dvb-frontends/lgdt3306a.c
@@ -1319,6 +1319,7 @@ static u32 log10_x1000(u32 x)
 	static u32 valx_x10[]     = {  10,  11,  13,  15,  17,  20,  25,  33,  41,  50,  59,  73,  87,  100 };
 	static u32 log10x_x1000[] = {   0,  41, 114, 176, 230, 301, 398, 518, 613, 699, 771, 863, 939, 1000 };
 	static u32 nelems = sizeof(valx_x10)/sizeof(valx_x10[0]);
+	u32 diff_val, step_val, step_log10;
 	u32 log_val = 0;
 	u32 i;
 
@@ -1348,15 +1349,16 @@ static u32 log10_x1000(u32 x)
 		if (valx_x10[i] >= x)
 			break;
 	}
+	if (i == nelems)
+		return log_val + log10x_x1000[i - 1];
 
-	{
-		u32 diff_val   = x - valx_x10[i-1];
-		u32 step_val   = valx_x10[i] - valx_x10[i-1];
-		u32 step_log10 = log10x_x1000[i] - log10x_x1000[i-1];
-		/* do a linear interpolation to get in-between values */
-		return log_val + log10x_x1000[i-1] +
-			((diff_val*step_log10) / step_val);
-	}
+	diff_val   = x - valx_x10[i-1];
+	step_val   = valx_x10[i] - valx_x10[i - 1];
+	step_log10 = log10x_x1000[i] - log10x_x1000[i - 1];
+
+	/* do a linear interpolation to get in-between values */
+	return log_val + log10x_x1000[i - 1] +
+		((diff_val*step_log10) / step_val);
 }
 
 static u32 lgdt3306a_calculate_snr_x100(struct lgdt3306a_state *state)

commit c43e6512058d21f8c2b73856cc2c7f32b032ccdc
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Tue Oct 28 10:56:10 2014 -0200

    [media] lgdt3306a: Use IS_ENABLED() for attach function
    
    Simplify the check if CONFIG_DVB_LGDT3306A is enabled, use the
    IS_ENABLED() macro, just like the other frontend modules.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/lgdt3306a.c b/drivers/media/dvb-frontends/lgdt3306a.c
index 99128d2afebb..c8af071ce40b 100644
--- a/drivers/media/dvb-frontends/lgdt3306a.c
+++ b/drivers/media/dvb-frontends/lgdt3306a.c
@@ -1662,7 +1662,7 @@ static void lgdt3306a_release(struct dvb_frontend *fe)
 static struct dvb_frontend_ops lgdt3306a_ops;
 
 struct dvb_frontend *lgdt3306a_attach(const struct lgdt3306a_config *config,
-				     struct i2c_adapter *i2c_adap)
+				      struct i2c_adapter *i2c_adap)
 {
 	struct lgdt3306a_state *state = NULL;
 	int ret;

commit 4937ba94a0b024b15711b7c184dc4e5a660d900c
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Tue Oct 28 10:50:36 2014 -0200

    [media] lgdt3306a: Use hexadecimal values in lowercase
    
    While this is not a mandatory rule at the CodingStyle, we prefer
    hexadecimal values in lowercase. Currently, there's a mix of lowercase
    and uppercase ons at lgdt3306a. So, convert all to lowercase with this
    small script:
    
            perl -ne 'if (m,0x([\dA-F]+),) { $o=$1; $n=lc $1; s,0x($o),0x$n, } print $_'
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/lgdt3306a.c b/drivers/media/dvb-frontends/lgdt3306a.c
index 98d74f049201..99128d2afebb 100644
--- a/drivers/media/dvb-frontends/lgdt3306a.c
+++ b/drivers/media/dvb-frontends/lgdt3306a.c
@@ -80,7 +80,7 @@ struct lgdt3306a_state {
 enum lgdt3306a_lock_status {
 	LG3306_UNLOCK       = 0x00,
 	LG3306_LOCK         = 0x01,
-	LG3306_UNKNOWN_LOCK = 0xFF
+	LG3306_UNKNOWN_LOCK = 0xff
 };
 
 enum lgdt3306a_neverlock_status {
@@ -88,14 +88,14 @@ enum lgdt3306a_neverlock_status {
 	LG3306_NL_PROCESS = 0x01,
 	LG3306_NL_LOCK    = 0x02,
 	LG3306_NL_FAIL    = 0x03,
-	LG3306_NL_UNKNOWN = 0xFF
+	LG3306_NL_UNKNOWN = 0xff
 };
 
 enum lgdt3306a_modulation {
 	LG3306_VSB          = 0x00,
 	LG3306_QAM64        = 0x01,
 	LG3306_QAM256       = 0x02,
-	LG3306_UNKNOWN_MODE = 0xFF
+	LG3306_UNKNOWN_MODE = 0xff
 };
 
 enum lgdt3306a_lock_check {
@@ -284,7 +284,7 @@ static int lgdt3306a_mpeg_tristate(struct lgdt3306a_state *state,
 		ret = lgdt3306a_read_reg(state, 0x0070, &val);
 		if (lg_chkerr(ret))
 			goto fail;
-		val &= ~0xA8; /* Tristate bus; TPOUTEN=0x80, TPCLKOUTEN=0x20, TPDATAOUTEN=0x08 */
+		val &= ~0xa8; /* Tristate bus; TPOUTEN=0x80, TPCLKOUTEN=0x20, TPDATAOUTEN=0x08 */
 		ret = lgdt3306a_write_reg(state, 0x0070, val);
 		if (lg_chkerr(ret))
 			goto fail;
@@ -302,7 +302,7 @@ static int lgdt3306a_mpeg_tristate(struct lgdt3306a_state *state,
 		if (lg_chkerr(ret))
 			goto fail;
 
-		val |= 0xA8; /* enable bus */
+		val |= 0xa8; /* enable bus */
 		ret = lgdt3306a_write_reg(state, 0x0070, val);
 		if (lg_chkerr(ret))
 			goto fail;
@@ -365,7 +365,7 @@ static int lgdt3306a_set_vsb(struct lgdt3306a_state *state)
 
 	/* 0. Spectrum inversion detection manual; spectrum inverted */
 	ret = lgdt3306a_read_reg(state, 0x0002, &val);
-	val &= 0xF7; /* SPECINVAUTO Off */
+	val &= 0xf7; /* SPECINVAUTO Off */
 	val |= 0x04; /* SPECINV On */
 	ret = lgdt3306a_write_reg(state, 0x0002, val);
 	if (lg_chkerr(ret))
@@ -378,23 +378,23 @@ static int lgdt3306a_set_vsb(struct lgdt3306a_state *state)
 
 	/* 2. Bandwidth mode for VSB(6MHz) */
 	ret = lgdt3306a_read_reg(state, 0x0009, &val);
-	val &= 0xE3;
-	val |= 0x0C; /* STDOPDETTMODE[2:0]=3 */
+	val &= 0xe3;
+	val |= 0x0c; /* STDOPDETTMODE[2:0]=3 */
 	ret = lgdt3306a_write_reg(state, 0x0009, val);
 	if (lg_chkerr(ret))
 		goto fail;
 
 	/* 3. QAM mode detection mode(None) */
 	ret = lgdt3306a_read_reg(state, 0x0009, &val);
-	val &= 0xFC; /* STDOPDETCMODE[1:0]=0 */
+	val &= 0xfc; /* STDOPDETCMODE[1:0]=0 */
 	ret = lgdt3306a_write_reg(state, 0x0009, val);
 	if (lg_chkerr(ret))
 		goto fail;
 
 	/* 4. ADC sampling frequency rate(2x sampling) */
-	ret = lgdt3306a_read_reg(state, 0x000D, &val);
-	val &= 0xBF; /* SAMPLING4XFEN=0 */
-	ret = lgdt3306a_write_reg(state, 0x000D, val);
+	ret = lgdt3306a_read_reg(state, 0x000d, &val);
+	val &= 0xbf; /* SAMPLING4XFEN=0 */
+	ret = lgdt3306a_write_reg(state, 0x000d, val);
 	if (lg_chkerr(ret))
 		goto fail;
 
@@ -406,19 +406,19 @@ static int lgdt3306a_set_vsb(struct lgdt3306a_state *state)
 		goto fail;
 
 	/* AICCFIXFREQ0 NT N-1(Video rejection) */
-	ret = lgdt3306a_write_reg(state, 0x002E, 0x00);
-	ret = lgdt3306a_write_reg(state, 0x002F, 0x00);
+	ret = lgdt3306a_write_reg(state, 0x002e, 0x00);
+	ret = lgdt3306a_write_reg(state, 0x002f, 0x00);
 	ret = lgdt3306a_write_reg(state, 0x0030, 0x00);
 
 	/* AICCFIXFREQ1 NT N-1(Audio rejection) */
-	ret = lgdt3306a_write_reg(state, 0x002B, 0x00);
-	ret = lgdt3306a_write_reg(state, 0x002C, 0x00);
-	ret = lgdt3306a_write_reg(state, 0x002D, 0x00);
+	ret = lgdt3306a_write_reg(state, 0x002b, 0x00);
+	ret = lgdt3306a_write_reg(state, 0x002c, 0x00);
+	ret = lgdt3306a_write_reg(state, 0x002d, 0x00);
 
 	/* AICCFIXFREQ2 NT Co-Channel(Video rejection) */
 	ret = lgdt3306a_write_reg(state, 0x0028, 0x00);
 	ret = lgdt3306a_write_reg(state, 0x0029, 0x00);
-	ret = lgdt3306a_write_reg(state, 0x002A, 0x00);
+	ret = lgdt3306a_write_reg(state, 0x002a, 0x00);
 
 	/* AICCFIXFREQ3 NT Co-Channel(Audio rejection) */
 	ret = lgdt3306a_write_reg(state, 0x0025, 0x00);
@@ -434,19 +434,19 @@ static int lgdt3306a_set_vsb(struct lgdt3306a_state *state)
 		goto fail;
 
 	/* AICCFIXFREQ0 NT N-1(Video rejection) */
-	ret = lgdt3306a_write_reg(state, 0x002E, 0x5A);
-	ret = lgdt3306a_write_reg(state, 0x002F, 0x00);
+	ret = lgdt3306a_write_reg(state, 0x002e, 0x5A);
+	ret = lgdt3306a_write_reg(state, 0x002f, 0x00);
 	ret = lgdt3306a_write_reg(state, 0x0030, 0x00);
 
 	/* AICCFIXFREQ1 NT N-1(Audio rejection) */
-	ret = lgdt3306a_write_reg(state, 0x002B, 0x36);
-	ret = lgdt3306a_write_reg(state, 0x002C, 0x00);
-	ret = lgdt3306a_write_reg(state, 0x002D, 0x00);
+	ret = lgdt3306a_write_reg(state, 0x002b, 0x36);
+	ret = lgdt3306a_write_reg(state, 0x002c, 0x00);
+	ret = lgdt3306a_write_reg(state, 0x002d, 0x00);
 
 	/* AICCFIXFREQ2 NT Co-Channel(Video rejection) */
 	ret = lgdt3306a_write_reg(state, 0x0028, 0x2A);
 	ret = lgdt3306a_write_reg(state, 0x0029, 0x00);
-	ret = lgdt3306a_write_reg(state, 0x002A, 0x00);
+	ret = lgdt3306a_write_reg(state, 0x002a, 0x00);
 
 	/* AICCFIXFREQ3 NT Co-Channel(Audio rejection) */
 	ret = lgdt3306a_write_reg(state, 0x0025, 0x06);
@@ -454,57 +454,57 @@ static int lgdt3306a_set_vsb(struct lgdt3306a_state *state)
 	ret = lgdt3306a_write_reg(state, 0x0027, 0x00);
 #endif
 
-	ret = lgdt3306a_read_reg(state, 0x001E, &val);
-	val &= 0x0F;
-	val |= 0xA0;
-	ret = lgdt3306a_write_reg(state, 0x001E, val);
+	ret = lgdt3306a_read_reg(state, 0x001e, &val);
+	val &= 0x0f;
+	val |= 0xa0;
+	ret = lgdt3306a_write_reg(state, 0x001e, val);
 
 	ret = lgdt3306a_write_reg(state, 0x0022, 0x08);
 
 	ret = lgdt3306a_write_reg(state, 0x0023, 0xFF);
 
-	ret = lgdt3306a_read_reg(state, 0x211F, &val);
-	val &= 0xEF;
-	ret = lgdt3306a_write_reg(state, 0x211F, val);
+	ret = lgdt3306a_read_reg(state, 0x211f, &val);
+	val &= 0xef;
+	ret = lgdt3306a_write_reg(state, 0x211f, val);
 
 	ret = lgdt3306a_write_reg(state, 0x2173, 0x01);
 
 	ret = lgdt3306a_read_reg(state, 0x1061, &val);
-	val &= 0xF8;
+	val &= 0xf8;
 	val |= 0x04;
 	ret = lgdt3306a_write_reg(state, 0x1061, val);
 
-	ret = lgdt3306a_read_reg(state, 0x103D, &val);
-	val &= 0xCF;
-	ret = lgdt3306a_write_reg(state, 0x103D, val);
+	ret = lgdt3306a_read_reg(state, 0x103d, &val);
+	val &= 0xcf;
+	ret = lgdt3306a_write_reg(state, 0x103d, val);
 
 	ret = lgdt3306a_write_reg(state, 0x2122, 0x40);
 
 	ret = lgdt3306a_read_reg(state, 0x2141, &val);
-	val &= 0x3F;
+	val &= 0x3f;
 	ret = lgdt3306a_write_reg(state, 0x2141, val);
 
 	ret = lgdt3306a_read_reg(state, 0x2135, &val);
-	val &= 0x0F;
+	val &= 0x0f;
 	val |= 0x70;
 	ret = lgdt3306a_write_reg(state, 0x2135, val);
 
 	ret = lgdt3306a_read_reg(state, 0x0003, &val);
-	val &= 0xF7;
+	val &= 0xf7;
 	ret = lgdt3306a_write_reg(state, 0x0003, val);
 
-	ret = lgdt3306a_read_reg(state, 0x001C, &val);
-	val &= 0x7F;
-	ret = lgdt3306a_write_reg(state, 0x001C, val);
+	ret = lgdt3306a_read_reg(state, 0x001c, &val);
+	val &= 0x7f;
+	ret = lgdt3306a_write_reg(state, 0x001c, val);
 
 	/* 6. EQ step size */
 	ret = lgdt3306a_read_reg(state, 0x2179, &val);
-	val &= 0xF8;
+	val &= 0xf8;
 	ret = lgdt3306a_write_reg(state, 0x2179, val);
 
-	ret = lgdt3306a_read_reg(state, 0x217A, &val);
-	val &= 0xF8;
-	ret = lgdt3306a_write_reg(state, 0x217A, val);
+	ret = lgdt3306a_read_reg(state, 0x217a, &val);
+	val &= 0xf8;
+	ret = lgdt3306a_write_reg(state, 0x217a, val);
 
 	/* 7. Reset */
 	ret = lgdt3306a_soft_reset(state);
@@ -530,7 +530,7 @@ static int lgdt3306a_set_qam(struct lgdt3306a_state *state, int modulation)
 
 	/* 1a. Spectrum inversion detection to Auto */
 	ret = lgdt3306a_read_reg(state, 0x0002, &val);
-	val &= 0xFB; /* SPECINV Off */
+	val &= 0xfb; /* SPECINV Off */
 	val |= 0x08; /* SPECINVAUTO On */
 	ret = lgdt3306a_write_reg(state, 0x0002, val);
 	if (lg_chkerr(ret))
@@ -538,14 +538,14 @@ static int lgdt3306a_set_qam(struct lgdt3306a_state *state, int modulation)
 
 	/* 2. Bandwidth mode for QAM */
 	ret = lgdt3306a_read_reg(state, 0x0009, &val);
-	val &= 0xE3; /* STDOPDETTMODE[2:0]=0 VSB Off */
+	val &= 0xe3; /* STDOPDETTMODE[2:0]=0 VSB Off */
 	ret = lgdt3306a_write_reg(state, 0x0009, val);
 	if (lg_chkerr(ret))
 		goto fail;
 
 	/* 3. : 64QAM/256QAM detection(manual, auto) */
 	ret = lgdt3306a_read_reg(state, 0x0009, &val);
-	val &= 0xFC;
+	val &= 0xfc;
 	val |= 0x02; /* STDOPDETCMODE[1:0]=1=Manual 2=Auto */
 	ret = lgdt3306a_write_reg(state, 0x0009, val);
 	if (lg_chkerr(ret))
@@ -553,7 +553,7 @@ static int lgdt3306a_set_qam(struct lgdt3306a_state *state, int modulation)
 
 	/* 3a. : 64QAM/256QAM selection for manual */
 	ret = lgdt3306a_read_reg(state, 0x101a, &val);
-	val &= 0xF8;
+	val &= 0xf8;
 	if (modulation == QAM_64)
 		val |= 0x02; /* QMDQMODE[2:0]=2=QAM64 */
 	else
@@ -564,10 +564,10 @@ static int lgdt3306a_set_qam(struct lgdt3306a_state *state, int modulation)
 		goto fail;
 
 	/* 4. ADC sampling frequency rate(4x sampling) */
-	ret = lgdt3306a_read_reg(state, 0x000D, &val);
-	val &= 0xBF;
+	ret = lgdt3306a_read_reg(state, 0x000d, &val);
+	val &= 0xbf;
 	val |= 0x40; /* SAMPLING4XFEN=1 */
-	ret = lgdt3306a_write_reg(state, 0x000D, val);
+	ret = lgdt3306a_write_reg(state, 0x000d, val);
 	if (lg_chkerr(ret))
 		goto fail;
 
@@ -829,7 +829,7 @@ static int lgdt3306a_init(struct dvb_frontend *fe)
 		ret = lgdt3306a_read_reg(state, 0x0005, &val);
 		if (lg_chkerr(ret))
 			goto fail;
-		val &= 0xC0;
+		val &= 0xc0;
 		val |= 0x25;
 		ret = lgdt3306a_write_reg(state, 0x0005, val);
 		if (lg_chkerr(ret))
@@ -839,12 +839,12 @@ static int lgdt3306a_init(struct dvb_frontend *fe)
 			goto fail;
 
 		/* 8. ADC sampling frequency(0x180000 for 24MHz sampling) */
-		ret = lgdt3306a_read_reg(state, 0x000D, &val);
+		ret = lgdt3306a_read_reg(state, 0x000d, &val);
 		if (lg_chkerr(ret))
 			goto fail;
-		val &= 0xC0;
+		val &= 0xc0;
 		val |= 0x18;
-		ret = lgdt3306a_write_reg(state, 0x000D, val);
+		ret = lgdt3306a_write_reg(state, 0x000d, val);
 		if (lg_chkerr(ret))
 			goto fail;
 
@@ -853,7 +853,7 @@ static int lgdt3306a_init(struct dvb_frontend *fe)
 		ret = lgdt3306a_read_reg(state, 0x0005, &val);
 		if (lg_chkerr(ret))
 			goto fail;
-		val &= 0xC0;
+		val &= 0xc0;
 		val |= 0x25;
 		ret = lgdt3306a_write_reg(state, 0x0005, val);
 		if (lg_chkerr(ret))
@@ -863,20 +863,20 @@ static int lgdt3306a_init(struct dvb_frontend *fe)
 			goto fail;
 
 		/* 8. ADC sampling frequency(0x190000 for 25MHz sampling) */
-		ret = lgdt3306a_read_reg(state, 0x000D, &val);
+		ret = lgdt3306a_read_reg(state, 0x000d, &val);
 		if (lg_chkerr(ret))
 			goto fail;
-		val &= 0xC0;
+		val &= 0xc0;
 		val |= 0x19;
-		ret = lgdt3306a_write_reg(state, 0x000D, val);
+		ret = lgdt3306a_write_reg(state, 0x000d, val);
 		if (lg_chkerr(ret))
 			goto fail;
 	} else {
 		lg_err("Bad xtalMHz=%d\n", state->cfg->xtalMHz);
 	}
 #if 0
-	ret = lgdt3306a_write_reg(state, 0x000E, 0x00);
-	ret = lgdt3306a_write_reg(state, 0x000F, 0x00);
+	ret = lgdt3306a_write_reg(state, 0x000e, 0x00);
+	ret = lgdt3306a_write_reg(state, 0x000f, 0x00);
 #endif
 
 	/* 9. Center frequency of input signal of ADC */
@@ -887,31 +887,31 @@ static int lgdt3306a_init(struct dvb_frontend *fe)
 	ret = lgdt3306a_write_reg(state, 0x0014, 0); /* gain error=0 */
 
 	/* 10a. VSB TR BW gear shift initial step */
-	ret = lgdt3306a_read_reg(state, 0x103C, &val);
-	val &= 0x0F;
+	ret = lgdt3306a_read_reg(state, 0x103c, &val);
+	val &= 0x0f;
 	val |= 0x20; /* SAMGSAUTOSTL_V[3:0] = 2 */
-	ret = lgdt3306a_write_reg(state, 0x103C, val);
+	ret = lgdt3306a_write_reg(state, 0x103c, val);
 
 	/* 10b. Timing offset calibration in low temperature for VSB */
-	ret = lgdt3306a_read_reg(state, 0x103D, &val);
-	val &= 0xFC;
+	ret = lgdt3306a_read_reg(state, 0x103d, &val);
+	val &= 0xfc;
 	val |= 0x03;
-	ret = lgdt3306a_write_reg(state, 0x103D, val);
+	ret = lgdt3306a_write_reg(state, 0x103d, val);
 
 	/* 10c. Timing offset calibration in low temperature for QAM */
 	ret = lgdt3306a_read_reg(state, 0x1036, &val);
-	val &= 0xF0;
-	val |= 0x0C;
+	val &= 0xf0;
+	val |= 0x0c;
 	ret = lgdt3306a_write_reg(state, 0x1036, val);
 
 	/* 11. Using the imaginary part of CIR in CIR loading */
-	ret = lgdt3306a_read_reg(state, 0x211F, &val);
-	val &= 0xEF; /* do not use imaginary of CIR */
-	ret = lgdt3306a_write_reg(state, 0x211F, val);
+	ret = lgdt3306a_read_reg(state, 0x211f, &val);
+	val &= 0xef; /* do not use imaginary of CIR */
+	ret = lgdt3306a_write_reg(state, 0x211f, val);
 
 	/* 12. Control of no signal detector function */
 	ret = lgdt3306a_read_reg(state, 0x2849, &val);
-	val &= 0xEF; /* NOUSENOSIGDET=0, enable no signal detector */
+	val &= 0xef; /* NOUSENOSIGDET=0, enable no signal detector */
 	ret = lgdt3306a_write_reg(state, 0x2849, val);
 
 	/* FGR - put demod in some known mode */
@@ -1034,8 +1034,8 @@ static void lgdt3306a_monitor_vsb(struct lgdt3306a_state *state)
 	u8 snrRef, maxPowerMan, nCombDet;
 	u16 fbDlyCir;
 
-	ret = lgdt3306a_read_reg(state, 0x21A1, &val);
-	snrRef = val & 0x3F;
+	ret = lgdt3306a_read_reg(state, 0x21a1, &val);
+	snrRef = val & 0x3f;
 
 	ret = lgdt3306a_read_reg(state, 0x2185, &maxPowerMan);
 
@@ -1052,7 +1052,7 @@ static void lgdt3306a_monitor_vsb(struct lgdt3306a_state *state)
 
 	/* Carrier offset sub loop bandwidth */
 	ret = lgdt3306a_read_reg(state, 0x1061, &val);
-	val &= 0xF8;
+	val &= 0xf8;
 	if ((snrRef > 18) && (maxPowerMan > 0x68) && (nCombDet == 0x01) && ((fbDlyCir == 0x03FF) || (fbDlyCir < 0x6C)))	{
 		/* SNR is over 18dB and no ghosting */
 		val |= 0x00; /* final bandwidth = 0 */
@@ -1063,17 +1063,17 @@ static void lgdt3306a_monitor_vsb(struct lgdt3306a_state *state)
 
 	/* Adjust Notch Filter */
 	ret = lgdt3306a_read_reg(state, 0x0024, &val);
-	val &= 0x0F;
+	val &= 0x0f;
 	if (nCombDet == 0) { /* Turn on the Notch Filter */
 		val |= 0x50;
 	}
 	ret = lgdt3306a_write_reg(state, 0x0024, val);
 
 	/* VSB Timing Recovery output normalization */
-	ret = lgdt3306a_read_reg(state, 0x103D, &val);
-	val &= 0xCF;
+	ret = lgdt3306a_read_reg(state, 0x103d, &val);
+	val &= 0xcf;
 	val |= 0x20;
-	ret = lgdt3306a_write_reg(state, 0x103D, val);
+	ret = lgdt3306a_write_reg(state, 0x103d, val);
 }
 
 static enum lgdt3306a_modulation lgdt3306a_check_oper_mode(struct lgdt3306a_state *state)
@@ -1088,7 +1088,7 @@ static enum lgdt3306a_modulation lgdt3306a_check_oper_mode(struct lgdt3306a_stat
 		return LG3306_VSB;
 	}
 	if (val & 0x08) {
-		ret = lgdt3306a_read_reg(state, 0x00A6, &val);
+		ret = lgdt3306a_read_reg(state, 0x00a6, &val);
 		val = val >> 2;
 		if (val & 0x01) {
 			lg_dbg("QAM256\n");
@@ -1115,7 +1115,7 @@ static enum lgdt3306a_lock_status lgdt3306a_check_lock_status(struct lgdt3306a_s
 	switch (whatLock) {
 	case LG3306_SYNC_LOCK:
 	{
-		ret = lgdt3306a_read_reg(state, 0x00A6, &val);
+		ret = lgdt3306a_read_reg(state, 0x00a6, &val);
 
 		if ((val & 0x80) == 0x80)
 			lockStatus = LG3306_LOCK;
@@ -1200,18 +1200,18 @@ static void lgdt3306a_pre_monitoring(struct lgdt3306a_state *state)
 	u8 currChDiffACQ, snrRef, mainStrong, aiccrejStatus;
 
 	/* Channel variation */
-	ret = lgdt3306a_read_reg(state, 0x21BC, &currChDiffACQ);
+	ret = lgdt3306a_read_reg(state, 0x21bc, &currChDiffACQ);
 
 	/* SNR of Frame sync */
-	ret = lgdt3306a_read_reg(state, 0x21A1, &val);
-	snrRef = val & 0x3F;
+	ret = lgdt3306a_read_reg(state, 0x21a1, &val);
+	snrRef = val & 0x3f;
 
 	/* Strong Main CIR */
 	ret = lgdt3306a_read_reg(state, 0x2199, &val);
 	mainStrong = (val & 0x40) >> 6;
 
 	ret = lgdt3306a_read_reg(state, 0x0090, &val);
-	aiccrejStatus = (val & 0xF0) >> 4;
+	aiccrejStatus = (val & 0xf0) >> 4;
 
 	lg_dbg("snrRef=%d mainStrong=%d aiccrejStatus=%d currChDiffACQ=0x%x\n",
 		snrRef, mainStrong, aiccrejStatus, currChDiffACQ);
@@ -1221,24 +1221,24 @@ static void lgdt3306a_pre_monitoring(struct lgdt3306a_state *state)
 #endif
 	if (mainStrong == 0) {
 		ret = lgdt3306a_read_reg(state, 0x2135, &val);
-		val &= 0x0F;
-		val |= 0xA0;
+		val &= 0x0f;
+		val |= 0xa0;
 		ret = lgdt3306a_write_reg(state, 0x2135, val);
 
 		ret = lgdt3306a_read_reg(state, 0x2141, &val);
-		val &= 0x3F;
+		val &= 0x3f;
 		val |= 0x80;
 		ret = lgdt3306a_write_reg(state, 0x2141, val);
 
 		ret = lgdt3306a_write_reg(state, 0x2122, 0x70);
 	} else { /* Weak ghost or static channel */
 		ret = lgdt3306a_read_reg(state, 0x2135, &val);
-		val &= 0x0F;
+		val &= 0x0f;
 		val |= 0x70;
 		ret = lgdt3306a_write_reg(state, 0x2135, val);
 
 		ret = lgdt3306a_read_reg(state, 0x2141, &val);
-		val &= 0x3F;
+		val &= 0x3f;
 		val |= 0x40;
 		ret = lgdt3306a_write_reg(state, 0x2141, val);
 
@@ -1309,7 +1309,7 @@ static u8 lgdt3306a_get_packet_error(struct lgdt3306a_state *state)
 	u8 val;
 	int ret;
 
-	ret = lgdt3306a_read_reg(state, 0x00FA, &val);
+	ret = lgdt3306a_read_reg(state, 0x00fa, &val);
 
 	return val;
 }
@@ -1365,10 +1365,10 @@ static u32 lgdt3306a_calculate_snr_x100(struct lgdt3306a_state *state)
 	u32 pwr; /* Constelation power */
 	u32 snr_x100;
 
-	mse = (read_reg(state, 0x00EC) << 8) |
-	      (read_reg(state, 0x00ED));
-	pwr = (read_reg(state, 0x00E8) << 8) |
-	      (read_reg(state, 0x00E9));
+	mse = (read_reg(state, 0x00ec) << 8) |
+	      (read_reg(state, 0x00ed));
+	pwr = (read_reg(state, 0x00e8) << 8) |
+	      (read_reg(state, 0x00e9));
 
 	if (mse == 0) /* no signal */
 		return 0;
@@ -1565,10 +1565,10 @@ static int lgdt3306a_read_ber(struct dvb_frontend *fe, u32 *ber)
 #if 1
 	/* FGR - BUGBUG - I don't know what value is expected by dvb_core
 	 * what is the scale of the value?? */
-	tmp =              read_reg(state, 0x00FC); /* NBERVALUE[24-31] */
-	tmp = (tmp << 8) | read_reg(state, 0x00FD); /* NBERVALUE[16-23] */
-	tmp = (tmp << 8) | read_reg(state, 0x00FE); /* NBERVALUE[8-15] */
-	tmp = (tmp << 8) | read_reg(state, 0x00FF); /* NBERVALUE[0-7] */
+	tmp =              read_reg(state, 0x00fc); /* NBERVALUE[24-31] */
+	tmp = (tmp << 8) | read_reg(state, 0x00fd); /* NBERVALUE[16-23] */
+	tmp = (tmp << 8) | read_reg(state, 0x00fe); /* NBERVALUE[8-15] */
+	tmp = (tmp << 8) | read_reg(state, 0x00ff); /* NBERVALUE[0-7] */
 	*ber = tmp;
 	lg_dbg("ber=%u\n", tmp);
 #endif
@@ -1583,7 +1583,7 @@ static int lgdt3306a_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)
 #if 1
 	/* FGR - BUGBUG - I don't know what value is expected by dvb_core
 	 * what happens when value wraps? */
-	*ucblocks = read_reg(state, 0x00F4); /* TPIFTPERRCNT[0-7] */
+	*ucblocks = read_reg(state, 0x00f4); /* TPIFTPERRCNT[0-7] */
 	lg_dbg("ucblocks=%u\n", *ucblocks);
 #endif
 
@@ -1698,8 +1698,8 @@ struct dvb_frontend *lgdt3306a_attach(const struct lgdt3306a_config *config,
 	ret = lgdt3306a_read_reg(state, 0x0001, &val);
 	if (lg_chkerr(ret))
 		goto fail;
-	if ((val & 0xF6) != 0xC6) {
-		lg_warn("expected 0xC6, got 0x%x\n", (val & 0xF6));
+	if ((val & 0xf6) != 0xc6) {
+		lg_warn("expected 0xc6, got 0x%x\n", (val & 0xf6));
 #if 0
 		goto fail;	/* BUGBUG - re-enable when we know this is right */
 #endif
@@ -1741,11 +1741,11 @@ static const short regtab[] = {
 	0x0007, /* SYSINITWAITTIME[7:0] (msec) 00001000 */
 	0x0008, /* STDOPMODE[7:0] 10000000 */
 	0x0009, /* 1'b0 1'b0 1'b0 STDOPDETTMODE[2:0] STDOPDETCMODE[1:0] 00011110 */
-	0x000A, /* DAFTEN 1'b1 x x SCSYSLOCK */
-	0x000B, /* SCSYSLOCKCHKTIME[7:0] (10msec) 01100100 */
-	0x000D, /* x SAMPLING4 */
-	0x000E, /* SAMFREQ[15:8] 00000000 */
-	0x000F, /* SAMFREQ[7:0] 00000000 */
+	0x000a, /* DAFTEN 1'b1 x x SCSYSLOCK */
+	0x000b, /* SCSYSLOCKCHKTIME[7:0] (10msec) 01100100 */
+	0x000d, /* x SAMPLING4 */
+	0x000e, /* SAMFREQ[15:8] 00000000 */
+	0x000f, /* SAMFREQ[7:0] 00000000 */
 	0x0010, /* IFFREQ[15:8] 01100000 */
 	0x0011, /* IFFREQ[7:0] 00000000 */
 	0x0012, /* AGCEN AGCREFMO */
@@ -1756,10 +1756,10 @@ static const short regtab[] = {
 	0x0017, /* AGCDELAY[7:0] 00100000 */
 	0x0018, /* AGCRFBW[3:0] AGCIFBW[3:0] 10001000 */
 	0x0019, /* AGCUDOUTMODE[1:0] AGCUDCTRLLEN[1:0] AGCUDCTRL */
-	0x001C, /* 1'b1 PFEN MFEN AICCVSYNC */
-	0x001D, /* 1'b0 1'b1 1'b0 1'b1 AICCVSYNC */
-	0x001E, /* AICCALPHA[3:0] 1'b1 1'b0 1'b1 1'b0 01111010 */
-	0x001F, /* AICCDETTH[19:16] AICCOFFTH[19:16] 00000000 */
+	0x001c, /* 1'b1 PFEN MFEN AICCVSYNC */
+	0x001d, /* 1'b0 1'b1 1'b0 1'b1 AICCVSYNC */
+	0x001e, /* AICCALPHA[3:0] 1'b1 1'b0 1'b1 1'b0 01111010 */
+	0x001f, /* AICCDETTH[19:16] AICCOFFTH[19:16] 00000000 */
 	0x0020, /* AICCDETTH[15:8] 01111100 */
 	0x0021, /* AICCDETTH[7:0] 00000000 */
 	0x0022, /* AICCOFFTH[15:8] 00000101 */
@@ -1770,12 +1770,12 @@ static const short regtab[] = {
 	0x0027, /* AICCFIXFREQ3[7:0] 00000000 */
 	0x0028, /* AICCFIXFREQ2[23:16] 00000000 */
 	0x0029, /* AICCFIXFREQ2[15:8] 00000000 */
-	0x002A, /* AICCFIXFREQ2[7:0] 00000000 */
-	0x002B, /* AICCFIXFREQ1[23:16] 00000000 */
-	0x002C, /* AICCFIXFREQ1[15:8] 00000000 */
-	0x002D, /* AICCFIXFREQ1[7:0] 00000000 */
-	0x002E, /* AICCFIXFREQ0[23:16] 00000000 */
-	0x002F, /* AICCFIXFREQ0[15:8] 00000000 */
+	0x002a, /* AICCFIXFREQ2[7:0] 00000000 */
+	0x002b, /* AICCFIXFREQ1[23:16] 00000000 */
+	0x002c, /* AICCFIXFREQ1[15:8] 00000000 */
+	0x002d, /* AICCFIXFREQ1[7:0] 00000000 */
+	0x002e, /* AICCFIXFREQ0[23:16] 00000000 */
+	0x002f, /* AICCFIXFREQ0[15:8] 00000000 */
 	0x0030, /* AICCFIXFREQ0[7:0] 00000000 */
 	0x0031, /* 1'b0 1'b1 1'b0 1'b0 x DAGC1STER */
 	0x0032, /* DAGC1STEN DAGC1STER */
@@ -1785,7 +1785,7 @@ static const short regtab[] = {
 	0x0036, /* DAGC2NDREF[15:8] 00001010 */
 	0x0037, /* DAGC2NDREF[7:0] 10000000 */
 	0x0038, /* DAGC2NDLOCKDETRNGSEL[1:0] */
-	0x003D, /* 1'b1 SAMGEARS */
+	0x003d, /* 1'b1 SAMGEARS */
 	0x0040, /* SAMLFGMA */
 	0x0041, /* SAMLFBWM */
 	0x0044, /* 1'b1 CRGEARSHE */
@@ -1794,7 +1794,7 @@ static const short regtab[] = {
 	0x0047, /* CRLFGMAN */
 	0x0048, /* x x x x CRLFGSTEP_VS[3:0] xxxx1001 */
 	0x0049, /* CRLFBWMA */
-	0x004A, /* CRLFBWMA */
+	0x004a, /* CRLFBWMA */
 	0x0050, /* 1'b0 1'b1 1'b1 1'b0 MSECALCDA */
 	0x0070, /* TPOUTEN TPIFEN TPCLKOUTE */
 	0x0071, /* TPSENB TPSSOPBITE */
@@ -1804,158 +1804,158 @@ static const short regtab[] = {
 	0x0077, /* x NBERLOSTTH[2:0] NBERACQTH[3:0] x0000000 */
 	0x0078, /* NBERPOLY[31:24] 00000000 */
 	0x0079, /* NBERPOLY[23:16] 00000000 */
-	0x007A, /* NBERPOLY[15:8] 00000000 */
-	0x007B, /* NBERPOLY[7:0] 00000000 */
-	0x007C, /* NBERPED[31:24] 00000000 */
-	0x007D, /* NBERPED[23:16] 00000000 */
-	0x007E, /* NBERPED[15:8] 00000000 */
-	0x007F, /* NBERPED[7:0] 00000000 */
+	0x007a, /* NBERPOLY[15:8] 00000000 */
+	0x007b, /* NBERPOLY[7:0] 00000000 */
+	0x007c, /* NBERPED[31:24] 00000000 */
+	0x007d, /* NBERPED[23:16] 00000000 */
+	0x007e, /* NBERPED[15:8] 00000000 */
+	0x007f, /* NBERPED[7:0] 00000000 */
 	0x0080, /* x AGCLOCK DAGCLOCK SYSLOCK x x NEVERLOCK[1:0] */
 	0x0085, /* SPECINVST */
 	0x0088, /* SYSLOCKTIME[15:8] */
 	0x0089, /* SYSLOCKTIME[7:0] */
-	0x008C, /* FECLOCKTIME[15:8] */
-	0x008D, /* FECLOCKTIME[7:0] */
-	0x008E, /* AGCACCOUT[15:8] */
-	0x008F, /* AGCACCOUT[7:0] */
+	0x008c, /* FECLOCKTIME[15:8] */
+	0x008d, /* FECLOCKTIME[7:0] */
+	0x008e, /* AGCACCOUT[15:8] */
+	0x008f, /* AGCACCOUT[7:0] */
 	0x0090, /* AICCREJSTATUS[3:0] AICCREJBUSY[3:0] */
 	0x0091, /* AICCVSYNC */
-	0x009C, /* CARRFREQOFFSET[15:8] */
-	0x009D, /* CARRFREQOFFSET[7:0] */
-	0x00A1, /* SAMFREQOFFSET[23:16] */
-	0x00A2, /* SAMFREQOFFSET[15:8] */
-	0x00A3, /* SAMFREQOFFSET[7:0] */
-	0x00A6, /* SYNCLOCK SYNCLOCKH */
+	0x009c, /* CARRFREQOFFSET[15:8] */
+	0x009d, /* CARRFREQOFFSET[7:0] */
+	0x00a1, /* SAMFREQOFFSET[23:16] */
+	0x00a2, /* SAMFREQOFFSET[15:8] */
+	0x00a3, /* SAMFREQOFFSET[7:0] */
+	0x00a6, /* SYNCLOCK SYNCLOCKH */
 #if 0 /* covered elsewhere */
-	0x00E8, /* CONSTPWR[15:8] */
-	0x00E9, /* CONSTPWR[7:0] */
-	0x00EA, /* BMSE[15:8] */
-	0x00EB, /* BMSE[7:0] */
-	0x00EC, /* MSE[15:8] */
-	0x00ED, /* MSE[7:0] */
-	0x00EE, /* CONSTI[7:0] */
-	0x00EF, /* CONSTQ[7:0] */
+	0x00e8, /* CONSTPWR[15:8] */
+	0x00e9, /* CONSTPWR[7:0] */
+	0x00ea, /* BMSE[15:8] */
+	0x00eb, /* BMSE[7:0] */
+	0x00ec, /* MSE[15:8] */
+	0x00ed, /* MSE[7:0] */
+	0x00ee, /* CONSTI[7:0] */
+	0x00ef, /* CONSTQ[7:0] */
 #endif
-	0x00F4, /* TPIFTPERRCNT[7:0] */
-	0x00F5, /* TPCORREC */
-	0x00F6, /* VBBER[15:8] */
-	0x00F7, /* VBBER[7:0] */
-	0x00F8, /* VABER[15:8] */
-	0x00F9, /* VABER[7:0] */
-	0x00FA, /* TPERRCNT[7:0] */
-	0x00FB, /* NBERLOCK x x x x x x x */
-	0x00FC, /* NBERVALUE[31:24] */
-	0x00FD, /* NBERVALUE[23:16] */
-	0x00FE, /* NBERVALUE[15:8] */
-	0x00FF, /* NBERVALUE[7:0] */
+	0x00f4, /* TPIFTPERRCNT[7:0] */
+	0x00f5, /* TPCORREC */
+	0x00f6, /* VBBER[15:8] */
+	0x00f7, /* VBBER[7:0] */
+	0x00f8, /* VABER[15:8] */
+	0x00f9, /* VABER[7:0] */
+	0x00fa, /* TPERRCNT[7:0] */
+	0x00fb, /* NBERLOCK x x x x x x x */
+	0x00fc, /* NBERVALUE[31:24] */
+	0x00fd, /* NBERVALUE[23:16] */
+	0x00fe, /* NBERVALUE[15:8] */
+	0x00ff, /* NBERVALUE[7:0] */
 	0x1000, /* 1'b0 WODAGCOU */
 	0x1005, /* x x 1'b1 1'b1 x SRD_Q_QM */
 	0x1009, /* SRDWAITTIME[7:0] (10msec) 00100011 */
-	0x100A, /* SRDWAITTIME_CQS[7:0] (msec) 01100100 */
-	0x101A, /* x 1'b1 1'b0 1'b0 x QMDQAMMODE[2:0] x100x010 */
+	0x100a, /* SRDWAITTIME_CQS[7:0] (msec) 01100100 */
+	0x101a, /* x 1'b1 1'b0 1'b0 x QMDQAMMODE[2:0] x100x010 */
 	0x1036, /* 1'b0 1'b1 1'b0 1'b0 SAMGSEND_CQS[3:0] 01001110 */
-	0x103C, /* SAMGSAUTOSTL_V[3:0] SAMGSAUTOEDL_V[3:0] 01000110 */
-	0x103D, /* 1'b1 1'b1 SAMCNORMBP_V[1:0] 1'b0 1'b0 SAMMODESEL_V[1:0] 11100001 */
-	0x103F, /* SAMZTEDSE */
-	0x105D, /* EQSTATUSE */
-	0x105F, /* x PMAPG2_V[2:0] x DMAPG2_V[2:0] x001x011 */
+	0x103c, /* SAMGSAUTOSTL_V[3:0] SAMGSAUTOEDL_V[3:0] 01000110 */
+	0x103d, /* 1'b1 1'b1 SAMCNORMBP_V[1:0] 1'b0 1'b0 SAMMODESEL_V[1:0] 11100001 */
+	0x103f, /* SAMZTEDSE */
+	0x105d, /* EQSTATUSE */
+	0x105f, /* x PMAPG2_V[2:0] x DMAPG2_V[2:0] x001x011 */
 	0x1060, /* 1'b1 EQSTATUSE */
 	0x1061, /* CRMAPBWSTL_V[3:0] CRMAPBWEDL_V[3:0] 00000100 */
 	0x1065, /* 1'b0 x CRMODE_V[1:0] 1'b1 x 1'b1 x 0x111x1x */
 	0x1066, /* 1'b0 1'b0 1'b1 1'b0 1'b1 PNBOOSTSE */
 	0x1068, /* CREPHNGAIN2_V[3:0] CREPHNPBW_V[3:0] 10010001 */
-	0x106E, /* x x x x x CREPHNEN_ */
-	0x106F, /* CREPHNTH_V[7:0] 00010101 */
+	0x106e, /* x x x x x CREPHNEN_ */
+	0x106f, /* CREPHNTH_V[7:0] 00010101 */
 	0x1072, /* CRSWEEPN */
 	0x1073, /* CRPGAIN_V[3:0] x x 1'b1 1'b1 1001xx11 */
 	0x1074, /* CRPBW_V[3:0] x x 1'b1 1'b1 0001xx11 */
 	0x1080, /* DAFTSTATUS[1:0] x x x x x x */
 	0x1081, /* SRDSTATUS[1:0] x x x x x SRDLOCK */
-	0x10A9, /* EQSTATUS_CQS[1:0] x x x x x x */
-	0x10B7, /* EQSTATUS_V[1:0] x x x x x x */
+	0x10a9, /* EQSTATUS_CQS[1:0] x x x x x x */
+	0x10b7, /* EQSTATUS_V[1:0] x x x x x x */
 #if 0 /* SMART_ANT */
-	0x1F00, /* MODEDETE */
-	0x1F01, /* x x x x x x x SFNRST xxxxxxx0 */
-	0x1F03, /* NUMOFANT[7:0] 10000000 */
-	0x1F04, /* x SELMASK[6:0] x0000000 */
-	0x1F05, /* x SETMASK[6:0] x0000000 */
-	0x1F06, /* x TXDATA[6:0] x0000000 */
-	0x1F07, /* x CHNUMBER[6:0] x0000000 */
-	0x1F09, /* AGCTIME[23:16] 10011000 */
-	0x1F0A, /* AGCTIME[15:8] 10010110 */
-	0x1F0B, /* AGCTIME[7:0] 10000000 */
-	0x1F0C, /* ANTTIME[31:24] 00000000 */
-	0x1F0D, /* ANTTIME[23:16] 00000011 */
-	0x1F0E, /* ANTTIME[15:8] 10010000 */
-	0x1F0F, /* ANTTIME[7:0] 10010000 */
-	0x1F11, /* SYNCTIME[23:16] 10011000 */
-	0x1F12, /* SYNCTIME[15:8] 10010110 */
-	0x1F13, /* SYNCTIME[7:0] 10000000 */
-	0x1F14, /* SNRTIME[31:24] 00000001 */
-	0x1F15, /* SNRTIME[23:16] 01111101 */
-	0x1F16, /* SNRTIME[15:8] 01111000 */
-	0x1F17, /* SNRTIME[7:0] 01000000 */
-	0x1F19, /* FECTIME[23:16] 00000000 */
-	0x1F1A, /* FECTIME[15:8] 01110010 */
-	0x1F1B, /* FECTIME[7:0] 01110000 */
-	0x1F1D, /* FECTHD[7:0] 00000011 */
-	0x1F1F, /* SNRTHD[23:16] 00001000 */
-	0x1F20, /* SNRTHD[15:8] 01111111 */
-	0x1F21, /* SNRTHD[7:0] 10000101 */
-	0x1F80, /* IRQFLG x x SFSDRFLG MODEBFLG SAVEFLG SCANFLG TRACKFLG */
-	0x1F81, /* x SYNCCON SNRCON FECCON x STDBUSY SYNCRST AGCFZCO */
-	0x1F82, /* x x x SCANOPCD[4:0] */
-	0x1F83, /* x x x x MAINOPCD[3:0] */
-	0x1F84, /* x x RXDATA[13:8] */
-	0x1F85, /* RXDATA[7:0] */
-	0x1F86, /* x x SDTDATA[13:8] */
-	0x1F87, /* SDTDATA[7:0] */
-	0x1F89, /* ANTSNR[23:16] */
-	0x1F8A, /* ANTSNR[15:8] */
-	0x1F8B, /* ANTSNR[7:0] */
-	0x1F8C, /* x x x x ANTFEC[13:8] */
-	0x1F8D, /* ANTFEC[7:0] */
-	0x1F8E, /* MAXCNT[7:0] */
-	0x1F8F, /* SCANCNT[7:0] */
-	0x1F91, /* MAXPW[23:16] */
-	0x1F92, /* MAXPW[15:8] */
-	0x1F93, /* MAXPW[7:0] */
-	0x1F95, /* CURPWMSE[23:16] */
-	0x1F96, /* CURPWMSE[15:8] */
-	0x1F97, /* CURPWMSE[7:0] */
+	0x1f00, /* MODEDETE */
+	0x1f01, /* x x x x x x x SFNRST xxxxxxx0 */
+	0x1f03, /* NUMOFANT[7:0] 10000000 */
+	0x1f04, /* x SELMASK[6:0] x0000000 */
+	0x1f05, /* x SETMASK[6:0] x0000000 */
+	0x1f06, /* x TXDATA[6:0] x0000000 */
+	0x1f07, /* x CHNUMBER[6:0] x0000000 */
+	0x1f09, /* AGCTIME[23:16] 10011000 */
+	0x1f0a, /* AGCTIME[15:8] 10010110 */
+	0x1f0b, /* AGCTIME[7:0] 10000000 */
+	0x1f0c, /* ANTTIME[31:24] 00000000 */
+	0x1f0d, /* ANTTIME[23:16] 00000011 */
+	0x1f0e, /* ANTTIME[15:8] 10010000 */
+	0x1f0f, /* ANTTIME[7:0] 10010000 */
+	0x1f11, /* SYNCTIME[23:16] 10011000 */
+	0x1f12, /* SYNCTIME[15:8] 10010110 */
+	0x1f13, /* SYNCTIME[7:0] 10000000 */
+	0x1f14, /* SNRTIME[31:24] 00000001 */
+	0x1f15, /* SNRTIME[23:16] 01111101 */
+	0x1f16, /* SNRTIME[15:8] 01111000 */
+	0x1f17, /* SNRTIME[7:0] 01000000 */
+	0x1f19, /* FECTIME[23:16] 00000000 */
+	0x1f1a, /* FECTIME[15:8] 01110010 */
+	0x1f1b, /* FECTIME[7:0] 01110000 */
+	0x1f1d, /* FECTHD[7:0] 00000011 */
+	0x1f1f, /* SNRTHD[23:16] 00001000 */
+	0x1f20, /* SNRTHD[15:8] 01111111 */
+	0x1f21, /* SNRTHD[7:0] 10000101 */
+	0x1f80, /* IRQFLG x x SFSDRFLG MODEBFLG SAVEFLG SCANFLG TRACKFLG */
+	0x1f81, /* x SYNCCON SNRCON FECCON x STDBUSY SYNCRST AGCFZCO */
+	0x1f82, /* x x x SCANOPCD[4:0] */
+	0x1f83, /* x x x x MAINOPCD[3:0] */
+	0x1f84, /* x x RXDATA[13:8] */
+	0x1f85, /* RXDATA[7:0] */
+	0x1f86, /* x x SDTDATA[13:8] */
+	0x1f87, /* SDTDATA[7:0] */
+	0x1f89, /* ANTSNR[23:16] */
+	0x1f8a, /* ANTSNR[15:8] */
+	0x1f8b, /* ANTSNR[7:0] */
+	0x1f8c, /* x x x x ANTFEC[13:8] */
+	0x1f8d, /* ANTFEC[7:0] */
+	0x1f8e, /* MAXCNT[7:0] */
+	0x1f8f, /* SCANCNT[7:0] */
+	0x1f91, /* MAXPW[23:16] */
+	0x1f92, /* MAXPW[15:8] */
+	0x1f93, /* MAXPW[7:0] */
+	0x1f95, /* CURPWMSE[23:16] */
+	0x1f96, /* CURPWMSE[15:8] */
+	0x1f97, /* CURPWMSE[7:0] */
 #endif /* SMART_ANT */
-	0x211F, /* 1'b1 1'b1 1'b1 CIRQEN x x 1'b0 1'b0 1111xx00 */
-	0x212A, /* EQAUTOST */
+	0x211f, /* 1'b1 1'b1 1'b1 CIRQEN x x 1'b0 1'b0 1111xx00 */
+	0x212a, /* EQAUTOST */
 	0x2122, /* CHFAST[7:0] 01100000 */
-	0x212B, /* FFFSTEP_V[3:0] x FBFSTEP_V[2:0] 0001x001 */
-	0x212C, /* PHDEROTBWSEL[3:0] 1'b1 1'b1 1'b1 1'b0 10001110 */
-	0x212D, /* 1'b1 1'b1 1'b1 1'b1 x x TPIFLOCKS */
+	0x212b, /* FFFSTEP_V[3:0] x FBFSTEP_V[2:0] 0001x001 */
+	0x212c, /* PHDEROTBWSEL[3:0] 1'b1 1'b1 1'b1 1'b0 10001110 */
+	0x212d, /* 1'b1 1'b1 1'b1 1'b1 x x TPIFLOCKS */
 	0x2135, /* DYNTRACKFDEQ[3:0] x 1'b0 1'b0 1'b0 1010x000 */
 	0x2141, /* TRMODE[1:0] 1'b1 1'b1 1'b0 1'b1 1'b1 1'b1 01110111 */
 	0x2162, /* AICCCTRLE */
 	0x2173, /* PHNCNFCNT[7:0] 00000100 */
 	0x2179, /* 1'b0 1'b0 1'b0 1'b1 x BADSINGLEDYNTRACKFBF[2:0] 0001x001 */
-	0x217A, /* 1'b0 1'b0 1'b0 1'b1 x BADSLOWSINGLEDYNTRACKFBF[2:0] 0001x001 */
-	0x217E, /* CNFCNTTPIF[7:0] 00001000 */
-	0x217F, /* TPERRCNTTPIF[7:0] 00000001 */
+	0x217a, /* 1'b0 1'b0 1'b0 1'b1 x BADSLOWSINGLEDYNTRACKFBF[2:0] 0001x001 */
+	0x217e, /* CNFCNTTPIF[7:0] 00001000 */
+	0x217f, /* TPERRCNTTPIF[7:0] 00000001 */
 	0x2180, /* x x x x x x FBDLYCIR[9:8] */
 	0x2181, /* FBDLYCIR[7:0] */
 	0x2185, /* MAXPWRMAIN[7:0] */
 	0x2191, /* NCOMBDET x x x x x x x */
 	0x2199, /* x MAINSTRON */
-	0x219A, /* FFFEQSTEPOUT_V[3:0] FBFSTEPOUT_V[2:0] */
-	0x21A1, /* x x SNRREF[5:0] */
+	0x219a, /* FFFEQSTEPOUT_V[3:0] FBFSTEPOUT_V[2:0] */
+	0x21a1, /* x x SNRREF[5:0] */
 	0x2845, /* 1'b0 1'b1 x x FFFSTEP_CQS[1:0] FFFCENTERTAP[1:0] 01xx1110 */
 	0x2846, /* 1'b0 x 1'b0 1'b1 FBFSTEP_CQS[1:0] 1'b1 1'b0 0x011110 */
 	0x2847, /* ENNOSIGDE */
 	0x2849, /* 1'b1 1'b1 NOUSENOSI */
-	0x284A, /* EQINITWAITTIME[7:0] 01100100 */
+	0x284a, /* EQINITWAITTIME[7:0] 01100100 */
 	0x3000, /* 1'b1 1'b1 1'b1 x x x 1'b0 RPTRSTM */
 	0x3001, /* RPTRSTWAITTIME[7:0] (100msec) 00110010 */
 	0x3031, /* FRAMELOC */
 	0x3032, /* 1'b1 1'b0 1'b0 1'b0 x x FRAMELOCKMODE_CQS[1:0] 1000xx11 */
-	0x30A9, /* VDLOCK_Q FRAMELOCK */
-	0x30AA, /* MPEGLOCK */
+	0x30a9, /* VDLOCK_Q FRAMELOCK */
+	0x30aa, /* MPEGLOCK */
 };
 
 #define numDumpRegs (sizeof(regtab)/sizeof(regtab[0]))

commit 34a5a2f8115620f91de0bf442cacc9fb9d92874d
Author: Michael Ira Krufky <mkrufky@linuxtv.org>
Date:   Sat Oct 25 11:26:15 2014 -0300

    [media] lgdt3306a: more small whitespace cleanups
    
    Just CodingStyle. No functional changes.
    
    Signed-off-by: Michael Ira Krufky <mkrufky@linuxtv.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/lgdt3306a.c b/drivers/media/dvb-frontends/lgdt3306a.c
index 9b7c36c109ca..98d74f049201 100644
--- a/drivers/media/dvb-frontends/lgdt3306a.c
+++ b/drivers/media/dvb-frontends/lgdt3306a.c
@@ -712,19 +712,19 @@ static int lgdt3306a_set_if(struct lgdt3306a_state *state,
 	default:
 	    lg_warn("IF=%d KHz is not supportted, 3250 assumed\n", if_freq_khz);
 		/* fallthrough */
-	case 3250:  /* 3.25Mhz */
+	case 3250: /* 3.25Mhz */
 		nco1 = 0x34;
 		nco2 = 0x00;
 		break;
-	case 3500:  /* 3.50Mhz */
+	case 3500: /* 3.50Mhz */
 		nco1 = 0x38;
 		nco2 = 0x00;
 		break;
-	case 4000:  /* 4.00Mhz */
+	case 4000: /* 4.00Mhz */
 		nco1 = 0x40;
 		nco2 = 0x00;
 		break;
-	case 5000:  /* 5.00Mhz */
+	case 5000: /* 5.00Mhz */
 		nco1 = 0x50;
 		nco2 = 0x00;
 		break;
@@ -1361,8 +1361,8 @@ static u32 log10_x1000(u32 x)
 
 static u32 lgdt3306a_calculate_snr_x100(struct lgdt3306a_state *state)
 {
-	u32 mse;  /* Mean-Square Error */
-	u32 pwr;  /* Constelation power */
+	u32 mse; /* Mean-Square Error */
+	u32 pwr; /* Constelation power */
 	u32 snr_x100;
 
 	mse = (read_reg(state, 0x00EC) << 8) |
@@ -1510,7 +1510,7 @@ static int lgdt3306a_read_signal_strength(struct dvb_frontend *fe,
 	 * Calculate some sort of "strength" from SNR
 	 */
 	struct lgdt3306a_state *state = fe->demodulator_priv;
-	u16 snr;  /* snr_x10 */
+	u16 snr; /* snr_x10 */
 	int ret;
 	u32 ref_snr; /* snr*100 */
 	u32 str;
@@ -1958,7 +1958,7 @@ static const short regtab[] = {
 	0x30AA, /* MPEGLOCK */
 };
 
-#define numDumpRegs  (sizeof(regtab)/sizeof(regtab[0]))
+#define numDumpRegs (sizeof(regtab)/sizeof(regtab[0]))
 static u8 regval1[numDumpRegs] = {0, };
 static u8 regval2[numDumpRegs] = {0, };
 

commit 831a91120a9399a061f0cb0a4562ecf7c83b3926
Author: Michael Ira Krufky <mkrufky@linuxtv.org>
Date:   Sat Oct 25 11:20:57 2014 -0300

    [media] lgdt3306a: typo fix
    
    fix WARNING: 'supress' may be misspelled - perhaps 'suppress'?
    
    Signed-off-by: Michael Ira Krufky <mkrufky@linuxtv.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/lgdt3306a.c b/drivers/media/dvb-frontends/lgdt3306a.c
index a0200dd48479..9b7c36c109ca 100644
--- a/drivers/media/dvb-frontends/lgdt3306a.c
+++ b/drivers/media/dvb-frontends/lgdt3306a.c
@@ -1975,7 +1975,7 @@ static void lgdt3306a_DumpRegs(struct lgdt3306a_state *state)
 
 	if ((debug & DBG_DUMP) == 0)
 		return;
-	debug &= ~DBG_REG; /* supress DBG_REG during reg dump */
+	debug &= ~DBG_REG; /* suppress DBG_REG during reg dump */
 
 	lg_info("\n");
 

commit cb4671c87f795c22a159507b0e47bea16da1ac26
Author: Michael Ira Krufky <mkrufky@linuxtv.org>
Date:   Sat Oct 25 11:12:25 2014 -0300

    [media] lgdt3306a: fix WARNING: please, no spaces at the start of a line
    
    Properly indent register initialization tables.
    
    Signed-off-by: Michael Ira Krufky <mkrufky@linuxtv.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/lgdt3306a.c b/drivers/media/dvb-frontends/lgdt3306a.c
index eb008988bcb7..a0200dd48479 100644
--- a/drivers/media/dvb-frontends/lgdt3306a.c
+++ b/drivers/media/dvb-frontends/lgdt3306a.c
@@ -1731,231 +1731,231 @@ EXPORT_SYMBOL(lgdt3306a_attach);
 #ifdef DBG_DUMP
 
 static const short regtab[] = {
-  0x0000, /* SOFTRSTB 1'b1 1'b1 1'b1 ADCPDB 1'b1 PLLPDB GBBPDB 11111111 */
-  0x0001, /* 1'b1 1'b1 1'b0 1'b0 AUTORPTRS */
-  0x0002, /* NI2CRPTEN 1'b0 1'b0 1'b0 SPECINVAUT */
-  0x0003, /* AGCRFOUT */
-  0x0004, /* ADCSEL1V ADCCNT ADCCNF ADCCNS ADCCLKPLL */
-  0x0005, /* PLLINDIVSE */
-  0x0006, /* PLLCTRL[7:0] 11100001 */
-  0x0007, /* SYSINITWAITTIME[7:0] (msec) 00001000 */
-  0x0008, /* STDOPMODE[7:0] 10000000 */
-  0x0009, /* 1'b0 1'b0 1'b0 STDOPDETTMODE[2:0] STDOPDETCMODE[1:0] 00011110 */
-  0x000A, /* DAFTEN 1'b1 x x SCSYSLOCK */
-  0x000B, /* SCSYSLOCKCHKTIME[7:0] (10msec) 01100100 */
-  0x000D, /* x SAMPLING4 */
-  0x000E, /* SAMFREQ[15:8] 00000000 */
-  0x000F, /* SAMFREQ[7:0] 00000000 */
-  0x0010, /* IFFREQ[15:8] 01100000 */
-  0x0011, /* IFFREQ[7:0] 00000000 */
-  0x0012, /* AGCEN AGCREFMO */
-  0x0013, /* AGCRFFIXB AGCIFFIXB AGCLOCKDETRNGSEL[1:0] 1'b1 1'b0 1'b0 1'b0 11101000 */
-  0x0014, /* AGCFIXVALUE[7:0] 01111111 */
-  0x0015, /* AGCREF[15:8] 00001010 */
-  0x0016, /* AGCREF[7:0] 11100100 */
-  0x0017, /* AGCDELAY[7:0] 00100000 */
-  0x0018, /* AGCRFBW[3:0] AGCIFBW[3:0] 10001000 */
-  0x0019, /* AGCUDOUTMODE[1:0] AGCUDCTRLLEN[1:0] AGCUDCTRL */
-  0x001C, /* 1'b1 PFEN MFEN AICCVSYNC */
-  0x001D, /* 1'b0 1'b1 1'b0 1'b1 AICCVSYNC */
-  0x001E, /* AICCALPHA[3:0] 1'b1 1'b0 1'b1 1'b0 01111010 */
-  0x001F, /* AICCDETTH[19:16] AICCOFFTH[19:16] 00000000 */
-  0x0020, /* AICCDETTH[15:8] 01111100 */
-  0x0021, /* AICCDETTH[7:0] 00000000 */
-  0x0022, /* AICCOFFTH[15:8] 00000101 */
-  0x0023, /* AICCOFFTH[7:0] 11100000 */
-  0x0024, /* AICCOPMODE3[1:0] AICCOPMODE2[1:0] AICCOPMODE1[1:0] AICCOPMODE0[1:0] 00000000 */
-  0x0025, /* AICCFIXFREQ3[23:16] 00000000 */
-  0x0026, /* AICCFIXFREQ3[15:8] 00000000 */
-  0x0027, /* AICCFIXFREQ3[7:0] 00000000 */
-  0x0028, /* AICCFIXFREQ2[23:16] 00000000 */
-  0x0029, /* AICCFIXFREQ2[15:8] 00000000 */
-  0x002A, /* AICCFIXFREQ2[7:0] 00000000 */
-  0x002B, /* AICCFIXFREQ1[23:16] 00000000 */
-  0x002C, /* AICCFIXFREQ1[15:8] 00000000 */
-  0x002D, /* AICCFIXFREQ1[7:0] 00000000 */
-  0x002E, /* AICCFIXFREQ0[23:16] 00000000 */
-  0x002F, /* AICCFIXFREQ0[15:8] 00000000 */
-  0x0030, /* AICCFIXFREQ0[7:0] 00000000 */
-  0x0031, /* 1'b0 1'b1 1'b0 1'b0 x DAGC1STER */
-  0x0032, /* DAGC1STEN DAGC1STER */
-  0x0033, /* DAGC1STREF[15:8] 00001010 */
-  0x0034, /* DAGC1STREF[7:0] 11100100 */
-  0x0035, /* DAGC2NDE */
-  0x0036, /* DAGC2NDREF[15:8] 00001010 */
-  0x0037, /* DAGC2NDREF[7:0] 10000000 */
-  0x0038, /* DAGC2NDLOCKDETRNGSEL[1:0] */
-  0x003D, /* 1'b1 SAMGEARS */
-  0x0040, /* SAMLFGMA */
-  0x0041, /* SAMLFBWM */
-  0x0044, /* 1'b1 CRGEARSHE */
-  0x0045, /* CRLFGMAN */
-  0x0046, /* CFLFBWMA */
-  0x0047, /* CRLFGMAN */
-  0x0048, /* x x x x CRLFGSTEP_VS[3:0] xxxx1001 */
-  0x0049, /* CRLFBWMA */
-  0x004A, /* CRLFBWMA */
-  0x0050, /* 1'b0 1'b1 1'b1 1'b0 MSECALCDA */
-  0x0070, /* TPOUTEN TPIFEN TPCLKOUTE */
-  0x0071, /* TPSENB TPSSOPBITE */
-  0x0073, /* TP47HINS x x CHBERINT PERMODE[1:0] PERINT[1:0] 1xx11100 */
-  0x0075, /* x x x x x IQSWAPCTRL[2:0] xxxxx000 */
-  0x0076, /* NBERCON NBERST NBERPOL NBERWSYN */
-  0x0077, /* x NBERLOSTTH[2:0] NBERACQTH[3:0] x0000000 */
-  0x0078, /* NBERPOLY[31:24] 00000000 */
-  0x0079, /* NBERPOLY[23:16] 00000000 */
-  0x007A, /* NBERPOLY[15:8] 00000000 */
-  0x007B, /* NBERPOLY[7:0] 00000000 */
-  0x007C, /* NBERPED[31:24] 00000000 */
-  0x007D, /* NBERPED[23:16] 00000000 */
-  0x007E, /* NBERPED[15:8] 00000000 */
-  0x007F, /* NBERPED[7:0] 00000000 */
-  0x0080, /* x AGCLOCK DAGCLOCK SYSLOCK x x NEVERLOCK[1:0] */
-  0x0085, /* SPECINVST */
-  0x0088, /* SYSLOCKTIME[15:8] */
-  0x0089, /* SYSLOCKTIME[7:0] */
-  0x008C, /* FECLOCKTIME[15:8] */
-  0x008D, /* FECLOCKTIME[7:0] */
-  0x008E, /* AGCACCOUT[15:8] */
-  0x008F, /* AGCACCOUT[7:0] */
-  0x0090, /* AICCREJSTATUS[3:0] AICCREJBUSY[3:0] */
-  0x0091, /* AICCVSYNC */
-  0x009C, /* CARRFREQOFFSET[15:8] */
-  0x009D, /* CARRFREQOFFSET[7:0] */
-  0x00A1, /* SAMFREQOFFSET[23:16] */
-  0x00A2, /* SAMFREQOFFSET[15:8] */
-  0x00A3, /* SAMFREQOFFSET[7:0] */
-  0x00A6, /* SYNCLOCK SYNCLOCKH */
+	0x0000, /* SOFTRSTB 1'b1 1'b1 1'b1 ADCPDB 1'b1 PLLPDB GBBPDB 11111111 */
+	0x0001, /* 1'b1 1'b1 1'b0 1'b0 AUTORPTRS */
+	0x0002, /* NI2CRPTEN 1'b0 1'b0 1'b0 SPECINVAUT */
+	0x0003, /* AGCRFOUT */
+	0x0004, /* ADCSEL1V ADCCNT ADCCNF ADCCNS ADCCLKPLL */
+	0x0005, /* PLLINDIVSE */
+	0x0006, /* PLLCTRL[7:0] 11100001 */
+	0x0007, /* SYSINITWAITTIME[7:0] (msec) 00001000 */
+	0x0008, /* STDOPMODE[7:0] 10000000 */
+	0x0009, /* 1'b0 1'b0 1'b0 STDOPDETTMODE[2:0] STDOPDETCMODE[1:0] 00011110 */
+	0x000A, /* DAFTEN 1'b1 x x SCSYSLOCK */
+	0x000B, /* SCSYSLOCKCHKTIME[7:0] (10msec) 01100100 */
+	0x000D, /* x SAMPLING4 */
+	0x000E, /* SAMFREQ[15:8] 00000000 */
+	0x000F, /* SAMFREQ[7:0] 00000000 */
+	0x0010, /* IFFREQ[15:8] 01100000 */
+	0x0011, /* IFFREQ[7:0] 00000000 */
+	0x0012, /* AGCEN AGCREFMO */
+	0x0013, /* AGCRFFIXB AGCIFFIXB AGCLOCKDETRNGSEL[1:0] 1'b1 1'b0 1'b0 1'b0 11101000 */
+	0x0014, /* AGCFIXVALUE[7:0] 01111111 */
+	0x0015, /* AGCREF[15:8] 00001010 */
+	0x0016, /* AGCREF[7:0] 11100100 */
+	0x0017, /* AGCDELAY[7:0] 00100000 */
+	0x0018, /* AGCRFBW[3:0] AGCIFBW[3:0] 10001000 */
+	0x0019, /* AGCUDOUTMODE[1:0] AGCUDCTRLLEN[1:0] AGCUDCTRL */
+	0x001C, /* 1'b1 PFEN MFEN AICCVSYNC */
+	0x001D, /* 1'b0 1'b1 1'b0 1'b1 AICCVSYNC */
+	0x001E, /* AICCALPHA[3:0] 1'b1 1'b0 1'b1 1'b0 01111010 */
+	0x001F, /* AICCDETTH[19:16] AICCOFFTH[19:16] 00000000 */
+	0x0020, /* AICCDETTH[15:8] 01111100 */
+	0x0021, /* AICCDETTH[7:0] 00000000 */
+	0x0022, /* AICCOFFTH[15:8] 00000101 */
+	0x0023, /* AICCOFFTH[7:0] 11100000 */
+	0x0024, /* AICCOPMODE3[1:0] AICCOPMODE2[1:0] AICCOPMODE1[1:0] AICCOPMODE0[1:0] 00000000 */
+	0x0025, /* AICCFIXFREQ3[23:16] 00000000 */
+	0x0026, /* AICCFIXFREQ3[15:8] 00000000 */
+	0x0027, /* AICCFIXFREQ3[7:0] 00000000 */
+	0x0028, /* AICCFIXFREQ2[23:16] 00000000 */
+	0x0029, /* AICCFIXFREQ2[15:8] 00000000 */
+	0x002A, /* AICCFIXFREQ2[7:0] 00000000 */
+	0x002B, /* AICCFIXFREQ1[23:16] 00000000 */
+	0x002C, /* AICCFIXFREQ1[15:8] 00000000 */
+	0x002D, /* AICCFIXFREQ1[7:0] 00000000 */
+	0x002E, /* AICCFIXFREQ0[23:16] 00000000 */
+	0x002F, /* AICCFIXFREQ0[15:8] 00000000 */
+	0x0030, /* AICCFIXFREQ0[7:0] 00000000 */
+	0x0031, /* 1'b0 1'b1 1'b0 1'b0 x DAGC1STER */
+	0x0032, /* DAGC1STEN DAGC1STER */
+	0x0033, /* DAGC1STREF[15:8] 00001010 */
+	0x0034, /* DAGC1STREF[7:0] 11100100 */
+	0x0035, /* DAGC2NDE */
+	0x0036, /* DAGC2NDREF[15:8] 00001010 */
+	0x0037, /* DAGC2NDREF[7:0] 10000000 */
+	0x0038, /* DAGC2NDLOCKDETRNGSEL[1:0] */
+	0x003D, /* 1'b1 SAMGEARS */
+	0x0040, /* SAMLFGMA */
+	0x0041, /* SAMLFBWM */
+	0x0044, /* 1'b1 CRGEARSHE */
+	0x0045, /* CRLFGMAN */
+	0x0046, /* CFLFBWMA */
+	0x0047, /* CRLFGMAN */
+	0x0048, /* x x x x CRLFGSTEP_VS[3:0] xxxx1001 */
+	0x0049, /* CRLFBWMA */
+	0x004A, /* CRLFBWMA */
+	0x0050, /* 1'b0 1'b1 1'b1 1'b0 MSECALCDA */
+	0x0070, /* TPOUTEN TPIFEN TPCLKOUTE */
+	0x0071, /* TPSENB TPSSOPBITE */
+	0x0073, /* TP47HINS x x CHBERINT PERMODE[1:0] PERINT[1:0] 1xx11100 */
+	0x0075, /* x x x x x IQSWAPCTRL[2:0] xxxxx000 */
+	0x0076, /* NBERCON NBERST NBERPOL NBERWSYN */
+	0x0077, /* x NBERLOSTTH[2:0] NBERACQTH[3:0] x0000000 */
+	0x0078, /* NBERPOLY[31:24] 00000000 */
+	0x0079, /* NBERPOLY[23:16] 00000000 */
+	0x007A, /* NBERPOLY[15:8] 00000000 */
+	0x007B, /* NBERPOLY[7:0] 00000000 */
+	0x007C, /* NBERPED[31:24] 00000000 */
+	0x007D, /* NBERPED[23:16] 00000000 */
+	0x007E, /* NBERPED[15:8] 00000000 */
+	0x007F, /* NBERPED[7:0] 00000000 */
+	0x0080, /* x AGCLOCK DAGCLOCK SYSLOCK x x NEVERLOCK[1:0] */
+	0x0085, /* SPECINVST */
+	0x0088, /* SYSLOCKTIME[15:8] */
+	0x0089, /* SYSLOCKTIME[7:0] */
+	0x008C, /* FECLOCKTIME[15:8] */
+	0x008D, /* FECLOCKTIME[7:0] */
+	0x008E, /* AGCACCOUT[15:8] */
+	0x008F, /* AGCACCOUT[7:0] */
+	0x0090, /* AICCREJSTATUS[3:0] AICCREJBUSY[3:0] */
+	0x0091, /* AICCVSYNC */
+	0x009C, /* CARRFREQOFFSET[15:8] */
+	0x009D, /* CARRFREQOFFSET[7:0] */
+	0x00A1, /* SAMFREQOFFSET[23:16] */
+	0x00A2, /* SAMFREQOFFSET[15:8] */
+	0x00A3, /* SAMFREQOFFSET[7:0] */
+	0x00A6, /* SYNCLOCK SYNCLOCKH */
 #if 0 /* covered elsewhere */
-  0x00E8, /* CONSTPWR[15:8] */
-  0x00E9, /* CONSTPWR[7:0] */
-  0x00EA, /* BMSE[15:8] */
-  0x00EB, /* BMSE[7:0] */
-  0x00EC, /* MSE[15:8] */
-  0x00ED, /* MSE[7:0] */
-  0x00EE, /* CONSTI[7:0] */
-  0x00EF, /* CONSTQ[7:0] */
+	0x00E8, /* CONSTPWR[15:8] */
+	0x00E9, /* CONSTPWR[7:0] */
+	0x00EA, /* BMSE[15:8] */
+	0x00EB, /* BMSE[7:0] */
+	0x00EC, /* MSE[15:8] */
+	0x00ED, /* MSE[7:0] */
+	0x00EE, /* CONSTI[7:0] */
+	0x00EF, /* CONSTQ[7:0] */
 #endif
-  0x00F4, /* TPIFTPERRCNT[7:0] */
-  0x00F5, /* TPCORREC */
-  0x00F6, /* VBBER[15:8] */
-  0x00F7, /* VBBER[7:0] */
-  0x00F8, /* VABER[15:8] */
-  0x00F9, /* VABER[7:0] */
-  0x00FA, /* TPERRCNT[7:0] */
-  0x00FB, /* NBERLOCK x x x x x x x */
-  0x00FC, /* NBERVALUE[31:24] */
-  0x00FD, /* NBERVALUE[23:16] */
-  0x00FE, /* NBERVALUE[15:8] */
-  0x00FF, /* NBERVALUE[7:0] */
-  0x1000, /* 1'b0 WODAGCOU */
-  0x1005, /* x x 1'b1 1'b1 x SRD_Q_QM */
-  0x1009, /* SRDWAITTIME[7:0] (10msec) 00100011 */
-  0x100A, /* SRDWAITTIME_CQS[7:0] (msec) 01100100 */
-  0x101A, /* x 1'b1 1'b0 1'b0 x QMDQAMMODE[2:0] x100x010 */
-  0x1036, /* 1'b0 1'b1 1'b0 1'b0 SAMGSEND_CQS[3:0] 01001110 */
-  0x103C, /* SAMGSAUTOSTL_V[3:0] SAMGSAUTOEDL_V[3:0] 01000110 */
-  0x103D, /* 1'b1 1'b1 SAMCNORMBP_V[1:0] 1'b0 1'b0 SAMMODESEL_V[1:0] 11100001 */
-  0x103F, /* SAMZTEDSE */
-  0x105D, /* EQSTATUSE */
-  0x105F, /* x PMAPG2_V[2:0] x DMAPG2_V[2:0] x001x011 */
-  0x1060, /* 1'b1 EQSTATUSE */
-  0x1061, /* CRMAPBWSTL_V[3:0] CRMAPBWEDL_V[3:0] 00000100 */
-  0x1065, /* 1'b0 x CRMODE_V[1:0] 1'b1 x 1'b1 x 0x111x1x */
-  0x1066, /* 1'b0 1'b0 1'b1 1'b0 1'b1 PNBOOSTSE */
-  0x1068, /* CREPHNGAIN2_V[3:0] CREPHNPBW_V[3:0] 10010001 */
-  0x106E, /* x x x x x CREPHNEN_ */
-  0x106F, /* CREPHNTH_V[7:0] 00010101 */
-  0x1072, /* CRSWEEPN */
-  0x1073, /* CRPGAIN_V[3:0] x x 1'b1 1'b1 1001xx11 */
-  0x1074, /* CRPBW_V[3:0] x x 1'b1 1'b1 0001xx11 */
-  0x1080, /* DAFTSTATUS[1:0] x x x x x x */
-  0x1081, /* SRDSTATUS[1:0] x x x x x SRDLOCK */
-  0x10A9, /* EQSTATUS_CQS[1:0] x x x x x x */
-  0x10B7, /* EQSTATUS_V[1:0] x x x x x x */
+	0x00F4, /* TPIFTPERRCNT[7:0] */
+	0x00F5, /* TPCORREC */
+	0x00F6, /* VBBER[15:8] */
+	0x00F7, /* VBBER[7:0] */
+	0x00F8, /* VABER[15:8] */
+	0x00F9, /* VABER[7:0] */
+	0x00FA, /* TPERRCNT[7:0] */
+	0x00FB, /* NBERLOCK x x x x x x x */
+	0x00FC, /* NBERVALUE[31:24] */
+	0x00FD, /* NBERVALUE[23:16] */
+	0x00FE, /* NBERVALUE[15:8] */
+	0x00FF, /* NBERVALUE[7:0] */
+	0x1000, /* 1'b0 WODAGCOU */
+	0x1005, /* x x 1'b1 1'b1 x SRD_Q_QM */
+	0x1009, /* SRDWAITTIME[7:0] (10msec) 00100011 */
+	0x100A, /* SRDWAITTIME_CQS[7:0] (msec) 01100100 */
+	0x101A, /* x 1'b1 1'b0 1'b0 x QMDQAMMODE[2:0] x100x010 */
+	0x1036, /* 1'b0 1'b1 1'b0 1'b0 SAMGSEND_CQS[3:0] 01001110 */
+	0x103C, /* SAMGSAUTOSTL_V[3:0] SAMGSAUTOEDL_V[3:0] 01000110 */
+	0x103D, /* 1'b1 1'b1 SAMCNORMBP_V[1:0] 1'b0 1'b0 SAMMODESEL_V[1:0] 11100001 */
+	0x103F, /* SAMZTEDSE */
+	0x105D, /* EQSTATUSE */
+	0x105F, /* x PMAPG2_V[2:0] x DMAPG2_V[2:0] x001x011 */
+	0x1060, /* 1'b1 EQSTATUSE */
+	0x1061, /* CRMAPBWSTL_V[3:0] CRMAPBWEDL_V[3:0] 00000100 */
+	0x1065, /* 1'b0 x CRMODE_V[1:0] 1'b1 x 1'b1 x 0x111x1x */
+	0x1066, /* 1'b0 1'b0 1'b1 1'b0 1'b1 PNBOOSTSE */
+	0x1068, /* CREPHNGAIN2_V[3:0] CREPHNPBW_V[3:0] 10010001 */
+	0x106E, /* x x x x x CREPHNEN_ */
+	0x106F, /* CREPHNTH_V[7:0] 00010101 */
+	0x1072, /* CRSWEEPN */
+	0x1073, /* CRPGAIN_V[3:0] x x 1'b1 1'b1 1001xx11 */
+	0x1074, /* CRPBW_V[3:0] x x 1'b1 1'b1 0001xx11 */
+	0x1080, /* DAFTSTATUS[1:0] x x x x x x */
+	0x1081, /* SRDSTATUS[1:0] x x x x x SRDLOCK */
+	0x10A9, /* EQSTATUS_CQS[1:0] x x x x x x */
+	0x10B7, /* EQSTATUS_V[1:0] x x x x x x */
 #if 0 /* SMART_ANT */
-  0x1F00, /* MODEDETE */
-  0x1F01, /* x x x x x x x SFNRST xxxxxxx0 */
-  0x1F03, /* NUMOFANT[7:0] 10000000 */
-  0x1F04, /* x SELMASK[6:0] x0000000 */
-  0x1F05, /* x SETMASK[6:0] x0000000 */
-  0x1F06, /* x TXDATA[6:0] x0000000 */
-  0x1F07, /* x CHNUMBER[6:0] x0000000 */
-  0x1F09, /* AGCTIME[23:16] 10011000 */
-  0x1F0A, /* AGCTIME[15:8] 10010110 */
-  0x1F0B, /* AGCTIME[7:0] 10000000 */
-  0x1F0C, /* ANTTIME[31:24] 00000000 */
-  0x1F0D, /* ANTTIME[23:16] 00000011 */
-  0x1F0E, /* ANTTIME[15:8] 10010000 */
-  0x1F0F, /* ANTTIME[7:0] 10010000 */
-  0x1F11, /* SYNCTIME[23:16] 10011000 */
-  0x1F12, /* SYNCTIME[15:8] 10010110 */
-  0x1F13, /* SYNCTIME[7:0] 10000000 */
-  0x1F14, /* SNRTIME[31:24] 00000001 */
-  0x1F15, /* SNRTIME[23:16] 01111101 */
-  0x1F16, /* SNRTIME[15:8] 01111000 */
-  0x1F17, /* SNRTIME[7:0] 01000000 */
-  0x1F19, /* FECTIME[23:16] 00000000 */
-  0x1F1A, /* FECTIME[15:8] 01110010 */
-  0x1F1B, /* FECTIME[7:0] 01110000 */
-  0x1F1D, /* FECTHD[7:0] 00000011 */
-  0x1F1F, /* SNRTHD[23:16] 00001000 */
-  0x1F20, /* SNRTHD[15:8] 01111111 */
-  0x1F21, /* SNRTHD[7:0] 10000101 */
-  0x1F80, /* IRQFLG x x SFSDRFLG MODEBFLG SAVEFLG SCANFLG TRACKFLG */
-  0x1F81, /* x SYNCCON SNRCON FECCON x STDBUSY SYNCRST AGCFZCO */
-  0x1F82, /* x x x SCANOPCD[4:0] */
-  0x1F83, /* x x x x MAINOPCD[3:0] */
-  0x1F84, /* x x RXDATA[13:8] */
-  0x1F85, /* RXDATA[7:0] */
-  0x1F86, /* x x SDTDATA[13:8] */
-  0x1F87, /* SDTDATA[7:0] */
-  0x1F89, /* ANTSNR[23:16] */
-  0x1F8A, /* ANTSNR[15:8] */
-  0x1F8B, /* ANTSNR[7:0] */
-  0x1F8C, /* x x x x ANTFEC[13:8] */
-  0x1F8D, /* ANTFEC[7:0] */
-  0x1F8E, /* MAXCNT[7:0] */
-  0x1F8F, /* SCANCNT[7:0] */
-  0x1F91, /* MAXPW[23:16] */
-  0x1F92, /* MAXPW[15:8] */
-  0x1F93, /* MAXPW[7:0] */
-  0x1F95, /* CURPWMSE[23:16] */
-  0x1F96, /* CURPWMSE[15:8] */
-  0x1F97, /* CURPWMSE[7:0] */
+	0x1F00, /* MODEDETE */
+	0x1F01, /* x x x x x x x SFNRST xxxxxxx0 */
+	0x1F03, /* NUMOFANT[7:0] 10000000 */
+	0x1F04, /* x SELMASK[6:0] x0000000 */
+	0x1F05, /* x SETMASK[6:0] x0000000 */
+	0x1F06, /* x TXDATA[6:0] x0000000 */
+	0x1F07, /* x CHNUMBER[6:0] x0000000 */
+	0x1F09, /* AGCTIME[23:16] 10011000 */
+	0x1F0A, /* AGCTIME[15:8] 10010110 */
+	0x1F0B, /* AGCTIME[7:0] 10000000 */
+	0x1F0C, /* ANTTIME[31:24] 00000000 */
+	0x1F0D, /* ANTTIME[23:16] 00000011 */
+	0x1F0E, /* ANTTIME[15:8] 10010000 */
+	0x1F0F, /* ANTTIME[7:0] 10010000 */
+	0x1F11, /* SYNCTIME[23:16] 10011000 */
+	0x1F12, /* SYNCTIME[15:8] 10010110 */
+	0x1F13, /* SYNCTIME[7:0] 10000000 */
+	0x1F14, /* SNRTIME[31:24] 00000001 */
+	0x1F15, /* SNRTIME[23:16] 01111101 */
+	0x1F16, /* SNRTIME[15:8] 01111000 */
+	0x1F17, /* SNRTIME[7:0] 01000000 */
+	0x1F19, /* FECTIME[23:16] 00000000 */
+	0x1F1A, /* FECTIME[15:8] 01110010 */
+	0x1F1B, /* FECTIME[7:0] 01110000 */
+	0x1F1D, /* FECTHD[7:0] 00000011 */
+	0x1F1F, /* SNRTHD[23:16] 00001000 */
+	0x1F20, /* SNRTHD[15:8] 01111111 */
+	0x1F21, /* SNRTHD[7:0] 10000101 */
+	0x1F80, /* IRQFLG x x SFSDRFLG MODEBFLG SAVEFLG SCANFLG TRACKFLG */
+	0x1F81, /* x SYNCCON SNRCON FECCON x STDBUSY SYNCRST AGCFZCO */
+	0x1F82, /* x x x SCANOPCD[4:0] */
+	0x1F83, /* x x x x MAINOPCD[3:0] */
+	0x1F84, /* x x RXDATA[13:8] */
+	0x1F85, /* RXDATA[7:0] */
+	0x1F86, /* x x SDTDATA[13:8] */
+	0x1F87, /* SDTDATA[7:0] */
+	0x1F89, /* ANTSNR[23:16] */
+	0x1F8A, /* ANTSNR[15:8] */
+	0x1F8B, /* ANTSNR[7:0] */
+	0x1F8C, /* x x x x ANTFEC[13:8] */
+	0x1F8D, /* ANTFEC[7:0] */
+	0x1F8E, /* MAXCNT[7:0] */
+	0x1F8F, /* SCANCNT[7:0] */
+	0x1F91, /* MAXPW[23:16] */
+	0x1F92, /* MAXPW[15:8] */
+	0x1F93, /* MAXPW[7:0] */
+	0x1F95, /* CURPWMSE[23:16] */
+	0x1F96, /* CURPWMSE[15:8] */
+	0x1F97, /* CURPWMSE[7:0] */
 #endif /* SMART_ANT */
-  0x211F, /* 1'b1 1'b1 1'b1 CIRQEN x x 1'b0 1'b0 1111xx00 */
-  0x212A, /* EQAUTOST */
-  0x2122, /* CHFAST[7:0] 01100000 */
-  0x212B, /* FFFSTEP_V[3:0] x FBFSTEP_V[2:0] 0001x001 */
-  0x212C, /* PHDEROTBWSEL[3:0] 1'b1 1'b1 1'b1 1'b0 10001110 */
-  0x212D, /* 1'b1 1'b1 1'b1 1'b1 x x TPIFLOCKS */
-  0x2135, /* DYNTRACKFDEQ[3:0] x 1'b0 1'b0 1'b0 1010x000 */
-  0x2141, /* TRMODE[1:0] 1'b1 1'b1 1'b0 1'b1 1'b1 1'b1 01110111 */
-  0x2162, /* AICCCTRLE */
-  0x2173, /* PHNCNFCNT[7:0] 00000100 */
-  0x2179, /* 1'b0 1'b0 1'b0 1'b1 x BADSINGLEDYNTRACKFBF[2:0] 0001x001 */
-  0x217A, /* 1'b0 1'b0 1'b0 1'b1 x BADSLOWSINGLEDYNTRACKFBF[2:0] 0001x001 */
-  0x217E, /* CNFCNTTPIF[7:0] 00001000 */
-  0x217F, /* TPERRCNTTPIF[7:0] 00000001 */
-  0x2180, /* x x x x x x FBDLYCIR[9:8] */
-  0x2181, /* FBDLYCIR[7:0] */
-  0x2185, /* MAXPWRMAIN[7:0] */
-  0x2191, /* NCOMBDET x x x x x x x */
-  0x2199, /* x MAINSTRON */
-  0x219A, /* FFFEQSTEPOUT_V[3:0] FBFSTEPOUT_V[2:0] */
-  0x21A1, /* x x SNRREF[5:0] */
-  0x2845, /* 1'b0 1'b1 x x FFFSTEP_CQS[1:0] FFFCENTERTAP[1:0] 01xx1110 */
-  0x2846, /* 1'b0 x 1'b0 1'b1 FBFSTEP_CQS[1:0] 1'b1 1'b0 0x011110 */
-  0x2847, /* ENNOSIGDE */
-  0x2849, /* 1'b1 1'b1 NOUSENOSI */
-  0x284A, /* EQINITWAITTIME[7:0] 01100100 */
-  0x3000, /* 1'b1 1'b1 1'b1 x x x 1'b0 RPTRSTM */
-  0x3001, /* RPTRSTWAITTIME[7:0] (100msec) 00110010 */
-  0x3031, /* FRAMELOC */
-  0x3032, /* 1'b1 1'b0 1'b0 1'b0 x x FRAMELOCKMODE_CQS[1:0] 1000xx11 */
-  0x30A9, /* VDLOCK_Q FRAMELOCK */
-  0x30AA, /* MPEGLOCK */
+	0x211F, /* 1'b1 1'b1 1'b1 CIRQEN x x 1'b0 1'b0 1111xx00 */
+	0x212A, /* EQAUTOST */
+	0x2122, /* CHFAST[7:0] 01100000 */
+	0x212B, /* FFFSTEP_V[3:0] x FBFSTEP_V[2:0] 0001x001 */
+	0x212C, /* PHDEROTBWSEL[3:0] 1'b1 1'b1 1'b1 1'b0 10001110 */
+	0x212D, /* 1'b1 1'b1 1'b1 1'b1 x x TPIFLOCKS */
+	0x2135, /* DYNTRACKFDEQ[3:0] x 1'b0 1'b0 1'b0 1010x000 */
+	0x2141, /* TRMODE[1:0] 1'b1 1'b1 1'b0 1'b1 1'b1 1'b1 01110111 */
+	0x2162, /* AICCCTRLE */
+	0x2173, /* PHNCNFCNT[7:0] 00000100 */
+	0x2179, /* 1'b0 1'b0 1'b0 1'b1 x BADSINGLEDYNTRACKFBF[2:0] 0001x001 */
+	0x217A, /* 1'b0 1'b0 1'b0 1'b1 x BADSLOWSINGLEDYNTRACKFBF[2:0] 0001x001 */
+	0x217E, /* CNFCNTTPIF[7:0] 00001000 */
+	0x217F, /* TPERRCNTTPIF[7:0] 00000001 */
+	0x2180, /* x x x x x x FBDLYCIR[9:8] */
+	0x2181, /* FBDLYCIR[7:0] */
+	0x2185, /* MAXPWRMAIN[7:0] */
+	0x2191, /* NCOMBDET x x x x x x x */
+	0x2199, /* x MAINSTRON */
+	0x219A, /* FFFEQSTEPOUT_V[3:0] FBFSTEPOUT_V[2:0] */
+	0x21A1, /* x x SNRREF[5:0] */
+	0x2845, /* 1'b0 1'b1 x x FFFSTEP_CQS[1:0] FFFCENTERTAP[1:0] 01xx1110 */
+	0x2846, /* 1'b0 x 1'b0 1'b1 FBFSTEP_CQS[1:0] 1'b1 1'b0 0x011110 */
+	0x2847, /* ENNOSIGDE */
+	0x2849, /* 1'b1 1'b1 NOUSENOSI */
+	0x284A, /* EQINITWAITTIME[7:0] 01100100 */
+	0x3000, /* 1'b1 1'b1 1'b1 x x x 1'b0 RPTRSTM */
+	0x3001, /* RPTRSTWAITTIME[7:0] (100msec) 00110010 */
+	0x3031, /* FRAMELOC */
+	0x3032, /* 1'b1 1'b0 1'b0 1'b0 x x FRAMELOCKMODE_CQS[1:0] 1000xx11 */
+	0x30A9, /* VDLOCK_Q FRAMELOCK */
+	0x30AA, /* MPEGLOCK */
 };
 
 #define numDumpRegs  (sizeof(regtab)/sizeof(regtab[0]))

commit 6da7ac985779937903ffb7147e3fe3ef33ff48f3
Author: Michael Ira Krufky <mkrufky@linuxtv.org>
Date:   Sat Oct 25 11:05:05 2014 -0300

    [media] lgdt3306a: fix ERROR: do not use C99 // comments
    
    Replace C99 comments by /* */ blocks.
    
    Signed-off-by: Michael Ira Krufky <mkrufky@linuxtv.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/lgdt3306a.c b/drivers/media/dvb-frontends/lgdt3306a.c
index 33d76b6c5c67..eb008988bcb7 100644
--- a/drivers/media/dvb-frontends/lgdt3306a.c
+++ b/drivers/media/dvb-frontends/lgdt3306a.c
@@ -1731,231 +1731,231 @@ EXPORT_SYMBOL(lgdt3306a_attach);
 #ifdef DBG_DUMP
 
 static const short regtab[] = {
-  0x0000, //SOFTRSTB 1'b1 1'b1 1'b1 ADCPDB 1'b1 PLLPDB GBBPDB 11111111
-  0x0001, //1'b1 1'b1 1'b0 1'b0 AUTORPTRS
-  0x0002, //NI2CRPTEN 1'b0 1'b0 1'b0 SPECINVAUT
-  0x0003, //AGCRFOUT
-  0x0004, //ADCSEL1V ADCCNT ADCCNF ADCCNS ADCCLKPLL
-  0x0005, //PLLINDIVSE
-  0x0006, //PLLCTRL[7:0] 11100001
-  0x0007, //SYSINITWAITTIME[7:0] (msec) 00001000
-  0x0008, //STDOPMODE[7:0] 10000000
-  0x0009, //1'b0 1'b0 1'b0 STDOPDETTMODE[2:0] STDOPDETCMODE[1:0] 00011110
-  0x000A, //DAFTEN 1'b1 x x SCSYSLOCK
-  0x000B, //SCSYSLOCKCHKTIME[7:0] (10msec) 01100100
-  0x000D, //x SAMPLING4
-  0x000E, //SAMFREQ[15:8] 00000000
-  0x000F, //SAMFREQ[7:0] 00000000
-  0x0010, //IFFREQ[15:8] 01100000
-  0x0011, //IFFREQ[7:0] 00000000
-  0x0012, //AGCEN AGCREFMO
-  0x0013, //AGCRFFIXB AGCIFFIXB AGCLOCKDETRNGSEL[1:0] 1'b1 1'b0 1'b0 1'b0 11101000
-  0x0014, //AGCFIXVALUE[7:0] 01111111
-  0x0015, //AGCREF[15:8] 00001010
-  0x0016, //AGCREF[7:0] 11100100
-  0x0017, //AGCDELAY[7:0] 00100000
-  0x0018, //AGCRFBW[3:0] AGCIFBW[3:0] 10001000
-  0x0019, //AGCUDOUTMODE[1:0] AGCUDCTRLLEN[1:0] AGCUDCTRL
-  0x001C, //1'b1 PFEN MFEN AICCVSYNC
-  0x001D, //1'b0 1'b1 1'b0 1'b1 AICCVSYNC
-  0x001E, //AICCALPHA[3:0] 1'b1 1'b0 1'b1 1'b0 01111010
-  0x001F, //AICCDETTH[19:16] AICCOFFTH[19:16] 00000000
-  0x0020, //AICCDETTH[15:8] 01111100
-  0x0021, //AICCDETTH[7:0] 00000000
-  0x0022, //AICCOFFTH[15:8] 00000101
-  0x0023, //AICCOFFTH[7:0] 11100000
-  0x0024, //AICCOPMODE3[1:0] AICCOPMODE2[1:0] AICCOPMODE1[1:0] AICCOPMODE0[1:0] 00000000
-  0x0025, //AICCFIXFREQ3[23:16] 00000000
-  0x0026, //AICCFIXFREQ3[15:8] 00000000
-  0x0027, //AICCFIXFREQ3[7:0] 00000000
-  0x0028, //AICCFIXFREQ2[23:16] 00000000
-  0x0029, //AICCFIXFREQ2[15:8] 00000000
-  0x002A, //AICCFIXFREQ2[7:0] 00000000
-  0x002B, //AICCFIXFREQ1[23:16] 00000000
-  0x002C, //AICCFIXFREQ1[15:8] 00000000
-  0x002D, //AICCFIXFREQ1[7:0] 00000000
-  0x002E, //AICCFIXFREQ0[23:16] 00000000
-  0x002F, //AICCFIXFREQ0[15:8] 00000000
-  0x0030, //AICCFIXFREQ0[7:0] 00000000
-  0x0031, //1'b0 1'b1 1'b0 1'b0 x DAGC1STER
-  0x0032, //DAGC1STEN DAGC1STER
-  0x0033, //DAGC1STREF[15:8] 00001010
-  0x0034, //DAGC1STREF[7:0] 11100100
-  0x0035, //DAGC2NDE
-  0x0036, //DAGC2NDREF[15:8] 00001010
-  0x0037, //DAGC2NDREF[7:0] 10000000
-  0x0038, //DAGC2NDLOCKDETRNGSEL[1:0]
-  0x003D, //1'b1 SAMGEARS
-  0x0040, //SAMLFGMA
-  0x0041, //SAMLFBWM
-  0x0044, //1'b1 CRGEARSHE
-  0x0045, //CRLFGMAN
-  0x0046, //CFLFBWMA
-  0x0047, //CRLFGMAN
-  0x0048, //x x x x CRLFGSTEP_VS[3:0] xxxx1001
-  0x0049, //CRLFBWMA
-  0x004A, //CRLFBWMA
-  0x0050, //1'b0 1'b1 1'b1 1'b0 MSECALCDA
-  0x0070, //TPOUTEN TPIFEN TPCLKOUTE
-  0x0071, //TPSENB TPSSOPBITE
-  0x0073, //TP47HINS x x CHBERINT PERMODE[1:0] PERINT[1:0] 1xx11100
-  0x0075, //x x x x x IQSWAPCTRL[2:0] xxxxx000
-  0x0076, //NBERCON NBERST NBERPOL NBERWSYN
-  0x0077, //x NBERLOSTTH[2:0] NBERACQTH[3:0] x0000000
-  0x0078, //NBERPOLY[31:24] 00000000
-  0x0079, //NBERPOLY[23:16] 00000000
-  0x007A, //NBERPOLY[15:8] 00000000
-  0x007B, //NBERPOLY[7:0] 00000000
-  0x007C, //NBERPED[31:24] 00000000
-  0x007D, //NBERPED[23:16] 00000000
-  0x007E, //NBERPED[15:8] 00000000
-  0x007F, //NBERPED[7:0] 00000000
-  0x0080, //x AGCLOCK DAGCLOCK SYSLOCK x x NEVERLOCK[1:0]
-  0x0085, //SPECINVST
-  0x0088, //SYSLOCKTIME[15:8]
-  0x0089, //SYSLOCKTIME[7:0]
-  0x008C, //FECLOCKTIME[15:8]
-  0x008D, //FECLOCKTIME[7:0]
-  0x008E, //AGCACCOUT[15:8]
-  0x008F, //AGCACCOUT[7:0]
-  0x0090, //AICCREJSTATUS[3:0] AICCREJBUSY[3:0]
-  0x0091, //AICCVSYNC
-  0x009C, //CARRFREQOFFSET[15:8]
-  0x009D, //CARRFREQOFFSET[7:0]
-  0x00A1, //SAMFREQOFFSET[23:16]
-  0x00A2, //SAMFREQOFFSET[15:8]
-  0x00A3, //SAMFREQOFFSET[7:0]
-  0x00A6, //SYNCLOCK SYNCLOCKH
-#if 0//covered elsewhere
-  0x00E8, //CONSTPWR[15:8]
-  0x00E9, //CONSTPWR[7:0]
-  0x00EA, //BMSE[15:8]
-  0x00EB, //BMSE[7:0]
-  0x00EC, //MSE[15:8]
-  0x00ED, //MSE[7:0]
-  0x00EE, //CONSTI[7:0]
-  0x00EF, //CONSTQ[7:0]
+  0x0000, /* SOFTRSTB 1'b1 1'b1 1'b1 ADCPDB 1'b1 PLLPDB GBBPDB 11111111 */
+  0x0001, /* 1'b1 1'b1 1'b0 1'b0 AUTORPTRS */
+  0x0002, /* NI2CRPTEN 1'b0 1'b0 1'b0 SPECINVAUT */
+  0x0003, /* AGCRFOUT */
+  0x0004, /* ADCSEL1V ADCCNT ADCCNF ADCCNS ADCCLKPLL */
+  0x0005, /* PLLINDIVSE */
+  0x0006, /* PLLCTRL[7:0] 11100001 */
+  0x0007, /* SYSINITWAITTIME[7:0] (msec) 00001000 */
+  0x0008, /* STDOPMODE[7:0] 10000000 */
+  0x0009, /* 1'b0 1'b0 1'b0 STDOPDETTMODE[2:0] STDOPDETCMODE[1:0] 00011110 */
+  0x000A, /* DAFTEN 1'b1 x x SCSYSLOCK */
+  0x000B, /* SCSYSLOCKCHKTIME[7:0] (10msec) 01100100 */
+  0x000D, /* x SAMPLING4 */
+  0x000E, /* SAMFREQ[15:8] 00000000 */
+  0x000F, /* SAMFREQ[7:0] 00000000 */
+  0x0010, /* IFFREQ[15:8] 01100000 */
+  0x0011, /* IFFREQ[7:0] 00000000 */
+  0x0012, /* AGCEN AGCREFMO */
+  0x0013, /* AGCRFFIXB AGCIFFIXB AGCLOCKDETRNGSEL[1:0] 1'b1 1'b0 1'b0 1'b0 11101000 */
+  0x0014, /* AGCFIXVALUE[7:0] 01111111 */
+  0x0015, /* AGCREF[15:8] 00001010 */
+  0x0016, /* AGCREF[7:0] 11100100 */
+  0x0017, /* AGCDELAY[7:0] 00100000 */
+  0x0018, /* AGCRFBW[3:0] AGCIFBW[3:0] 10001000 */
+  0x0019, /* AGCUDOUTMODE[1:0] AGCUDCTRLLEN[1:0] AGCUDCTRL */
+  0x001C, /* 1'b1 PFEN MFEN AICCVSYNC */
+  0x001D, /* 1'b0 1'b1 1'b0 1'b1 AICCVSYNC */
+  0x001E, /* AICCALPHA[3:0] 1'b1 1'b0 1'b1 1'b0 01111010 */
+  0x001F, /* AICCDETTH[19:16] AICCOFFTH[19:16] 00000000 */
+  0x0020, /* AICCDETTH[15:8] 01111100 */
+  0x0021, /* AICCDETTH[7:0] 00000000 */
+  0x0022, /* AICCOFFTH[15:8] 00000101 */
+  0x0023, /* AICCOFFTH[7:0] 11100000 */
+  0x0024, /* AICCOPMODE3[1:0] AICCOPMODE2[1:0] AICCOPMODE1[1:0] AICCOPMODE0[1:0] 00000000 */
+  0x0025, /* AICCFIXFREQ3[23:16] 00000000 */
+  0x0026, /* AICCFIXFREQ3[15:8] 00000000 */
+  0x0027, /* AICCFIXFREQ3[7:0] 00000000 */
+  0x0028, /* AICCFIXFREQ2[23:16] 00000000 */
+  0x0029, /* AICCFIXFREQ2[15:8] 00000000 */
+  0x002A, /* AICCFIXFREQ2[7:0] 00000000 */
+  0x002B, /* AICCFIXFREQ1[23:16] 00000000 */
+  0x002C, /* AICCFIXFREQ1[15:8] 00000000 */
+  0x002D, /* AICCFIXFREQ1[7:0] 00000000 */
+  0x002E, /* AICCFIXFREQ0[23:16] 00000000 */
+  0x002F, /* AICCFIXFREQ0[15:8] 00000000 */
+  0x0030, /* AICCFIXFREQ0[7:0] 00000000 */
+  0x0031, /* 1'b0 1'b1 1'b0 1'b0 x DAGC1STER */
+  0x0032, /* DAGC1STEN DAGC1STER */
+  0x0033, /* DAGC1STREF[15:8] 00001010 */
+  0x0034, /* DAGC1STREF[7:0] 11100100 */
+  0x0035, /* DAGC2NDE */
+  0x0036, /* DAGC2NDREF[15:8] 00001010 */
+  0x0037, /* DAGC2NDREF[7:0] 10000000 */
+  0x0038, /* DAGC2NDLOCKDETRNGSEL[1:0] */
+  0x003D, /* 1'b1 SAMGEARS */
+  0x0040, /* SAMLFGMA */
+  0x0041, /* SAMLFBWM */
+  0x0044, /* 1'b1 CRGEARSHE */
+  0x0045, /* CRLFGMAN */
+  0x0046, /* CFLFBWMA */
+  0x0047, /* CRLFGMAN */
+  0x0048, /* x x x x CRLFGSTEP_VS[3:0] xxxx1001 */
+  0x0049, /* CRLFBWMA */
+  0x004A, /* CRLFBWMA */
+  0x0050, /* 1'b0 1'b1 1'b1 1'b0 MSECALCDA */
+  0x0070, /* TPOUTEN TPIFEN TPCLKOUTE */
+  0x0071, /* TPSENB TPSSOPBITE */
+  0x0073, /* TP47HINS x x CHBERINT PERMODE[1:0] PERINT[1:0] 1xx11100 */
+  0x0075, /* x x x x x IQSWAPCTRL[2:0] xxxxx000 */
+  0x0076, /* NBERCON NBERST NBERPOL NBERWSYN */
+  0x0077, /* x NBERLOSTTH[2:0] NBERACQTH[3:0] x0000000 */
+  0x0078, /* NBERPOLY[31:24] 00000000 */
+  0x0079, /* NBERPOLY[23:16] 00000000 */
+  0x007A, /* NBERPOLY[15:8] 00000000 */
+  0x007B, /* NBERPOLY[7:0] 00000000 */
+  0x007C, /* NBERPED[31:24] 00000000 */
+  0x007D, /* NBERPED[23:16] 00000000 */
+  0x007E, /* NBERPED[15:8] 00000000 */
+  0x007F, /* NBERPED[7:0] 00000000 */
+  0x0080, /* x AGCLOCK DAGCLOCK SYSLOCK x x NEVERLOCK[1:0] */
+  0x0085, /* SPECINVST */
+  0x0088, /* SYSLOCKTIME[15:8] */
+  0x0089, /* SYSLOCKTIME[7:0] */
+  0x008C, /* FECLOCKTIME[15:8] */
+  0x008D, /* FECLOCKTIME[7:0] */
+  0x008E, /* AGCACCOUT[15:8] */
+  0x008F, /* AGCACCOUT[7:0] */
+  0x0090, /* AICCREJSTATUS[3:0] AICCREJBUSY[3:0] */
+  0x0091, /* AICCVSYNC */
+  0x009C, /* CARRFREQOFFSET[15:8] */
+  0x009D, /* CARRFREQOFFSET[7:0] */
+  0x00A1, /* SAMFREQOFFSET[23:16] */
+  0x00A2, /* SAMFREQOFFSET[15:8] */
+  0x00A3, /* SAMFREQOFFSET[7:0] */
+  0x00A6, /* SYNCLOCK SYNCLOCKH */
+#if 0 /* covered elsewhere */
+  0x00E8, /* CONSTPWR[15:8] */
+  0x00E9, /* CONSTPWR[7:0] */
+  0x00EA, /* BMSE[15:8] */
+  0x00EB, /* BMSE[7:0] */
+  0x00EC, /* MSE[15:8] */
+  0x00ED, /* MSE[7:0] */
+  0x00EE, /* CONSTI[7:0] */
+  0x00EF, /* CONSTQ[7:0] */
 #endif
-  0x00F4, //TPIFTPERRCNT[7:0]
-  0x00F5, //TPCORREC
-  0x00F6, //VBBER[15:8]
-  0x00F7, //VBBER[7:0]
-  0x00F8, //VABER[15:8]
-  0x00F9, //VABER[7:0]
-  0x00FA, //TPERRCNT[7:0]
-  0x00FB, //NBERLOCK x x x x x x x
-  0x00FC, //NBERVALUE[31:24]
-  0x00FD, //NBERVALUE[23:16]
-  0x00FE, //NBERVALUE[15:8]
-  0x00FF, //NBERVALUE[7:0]
-  0x1000, //1'b0 WODAGCOU
-  0x1005, //x x 1'b1 1'b1 x SRD_Q_QM
-  0x1009, //SRDWAITTIME[7:0] (10msec) 00100011
-  0x100A, //SRDWAITTIME_CQS[7:0] (msec) 01100100
-  0x101A, //x 1'b1 1'b0 1'b0 x QMDQAMMODE[2:0] x100x010
-  0x1036, //1'b0 1'b1 1'b0 1'b0 SAMGSEND_CQS[3:0] 01001110
-  0x103C, //SAMGSAUTOSTL_V[3:0] SAMGSAUTOEDL_V[3:0] 01000110
-  0x103D, //1'b1 1'b1 SAMCNORMBP_V[1:0] 1'b0 1'b0 SAMMODESEL_V[1:0] 11100001
-  0x103F, //SAMZTEDSE
-  0x105D, //EQSTATUSE
-  0x105F, //x PMAPG2_V[2:0] x DMAPG2_V[2:0] x001x011
-  0x1060, //1'b1 EQSTATUSE
-  0x1061, //CRMAPBWSTL_V[3:0] CRMAPBWEDL_V[3:0] 00000100
-  0x1065, //1'b0 x CRMODE_V[1:0] 1'b1 x 1'b1 x 0x111x1x
-  0x1066, //1'b0 1'b0 1'b1 1'b0 1'b1 PNBOOSTSE
-  0x1068, //CREPHNGAIN2_V[3:0] CREPHNPBW_V[3:0] 10010001
-  0x106E, //x x x x x CREPHNEN_
-  0x106F, //CREPHNTH_V[7:0] 00010101
-  0x1072, //CRSWEEPN
-  0x1073, //CRPGAIN_V[3:0] x x 1'b1 1'b1 1001xx11
-  0x1074, //CRPBW_V[3:0] x x 1'b1 1'b1 0001xx11
-  0x1080, //DAFTSTATUS[1:0] x x x x x x
-  0x1081, //SRDSTATUS[1:0] x x x x x SRDLOCK
-  0x10A9, //EQSTATUS_CQS[1:0] x x x x x x
-  0x10B7, //EQSTATUS_V[1:0] x x x x x x
-#if 0//SMART_ANT
-  0x1F00, //MODEDETE
-  0x1F01, //x x x x x x x SFNRST xxxxxxx0
-  0x1F03, //NUMOFANT[7:0] 10000000
-  0x1F04, //x SELMASK[6:0] x0000000
-  0x1F05, //x SETMASK[6:0] x0000000
-  0x1F06, //x TXDATA[6:0] x0000000
-  0x1F07, //x CHNUMBER[6:0] x0000000
-  0x1F09, //AGCTIME[23:16] 10011000
-  0x1F0A, //AGCTIME[15:8] 10010110
-  0x1F0B, //AGCTIME[7:0] 10000000
-  0x1F0C, //ANTTIME[31:24] 00000000
-  0x1F0D, //ANTTIME[23:16] 00000011
-  0x1F0E, //ANTTIME[15:8] 10010000
-  0x1F0F, //ANTTIME[7:0] 10010000
-  0x1F11, //SYNCTIME[23:16] 10011000
-  0x1F12, //SYNCTIME[15:8] 10010110
-  0x1F13, //SYNCTIME[7:0] 10000000
-  0x1F14, //SNRTIME[31:24] 00000001
-  0x1F15, //SNRTIME[23:16] 01111101
-  0x1F16, //SNRTIME[15:8] 01111000
-  0x1F17, //SNRTIME[7:0] 01000000
-  0x1F19, //FECTIME[23:16] 00000000
-  0x1F1A, //FECTIME[15:8] 01110010
-  0x1F1B, //FECTIME[7:0] 01110000
-  0x1F1D, //FECTHD[7:0] 00000011
-  0x1F1F, //SNRTHD[23:16] 00001000
-  0x1F20, //SNRTHD[15:8] 01111111
-  0x1F21, //SNRTHD[7:0] 10000101
-  0x1F80, //IRQFLG x x SFSDRFLG MODEBFLG SAVEFLG SCANFLG TRACKFLG
-  0x1F81, //x SYNCCON SNRCON FECCON x STDBUSY SYNCRST AGCFZCO
-  0x1F82, //x x x SCANOPCD[4:0]
-  0x1F83, //x x x x MAINOPCD[3:0]
-  0x1F84, //x x RXDATA[13:8]
-  0x1F85, //RXDATA[7:0]
-  0x1F86, //x x SDTDATA[13:8]
-  0x1F87, //SDTDATA[7:0]
-  0x1F89, //ANTSNR[23:16]
-  0x1F8A, //ANTSNR[15:8]
-  0x1F8B, //ANTSNR[7:0]
-  0x1F8C, //x x x x ANTFEC[13:8]
-  0x1F8D, //ANTFEC[7:0]
-  0x1F8E, //MAXCNT[7:0]
-  0x1F8F, //SCANCNT[7:0]
-  0x1F91, //MAXPW[23:16]
-  0x1F92, //MAXPW[15:8]
-  0x1F93, //MAXPW[7:0]
-  0x1F95, //CURPWMSE[23:16]
-  0x1F96, //CURPWMSE[15:8]
-  0x1F97, //CURPWMSE[7:0]
-#endif//SMART_ANT
-  0x211F, //1'b1 1'b1 1'b1 CIRQEN x x 1'b0 1'b0 1111xx00
-  0x212A, //EQAUTOST
-  0x2122, //CHFAST[7:0] 01100000
-  0x212B, //FFFSTEP_V[3:0] x FBFSTEP_V[2:0] 0001x001
-  0x212C, //PHDEROTBWSEL[3:0] 1'b1 1'b1 1'b1 1'b0 10001110
-  0x212D, //1'b1 1'b1 1'b1 1'b1 x x TPIFLOCKS
-  0x2135, //DYNTRACKFDEQ[3:0] x 1'b0 1'b0 1'b0 1010x000
-  0x2141, //TRMODE[1:0] 1'b1 1'b1 1'b0 1'b1 1'b1 1'b1 01110111
-  0x2162, //AICCCTRLE
-  0x2173, //PHNCNFCNT[7:0] 00000100
-  0x2179, //1'b0 1'b0 1'b0 1'b1 x BADSINGLEDYNTRACKFBF[2:0] 0001x001
-  0x217A, //1'b0 1'b0 1'b0 1'b1 x BADSLOWSINGLEDYNTRACKFBF[2:0] 0001x001
-  0x217E, //CNFCNTTPIF[7:0] 00001000
-  0x217F, //TPERRCNTTPIF[7:0] 00000001
-  0x2180, //x x x x x x FBDLYCIR[9:8]
-  0x2181, //FBDLYCIR[7:0]
-  0x2185, //MAXPWRMAIN[7:0]
-  0x2191, //NCOMBDET x x x x x x x
-  0x2199, //x MAINSTRON
-  0x219A, //FFFEQSTEPOUT_V[3:0] FBFSTEPOUT_V[2:0]
-  0x21A1, //x x SNRREF[5:0]
-  0x2845, //1'b0 1'b1 x x FFFSTEP_CQS[1:0] FFFCENTERTAP[1:0] 01xx1110
-  0x2846, //1'b0 x 1'b0 1'b1 FBFSTEP_CQS[1:0] 1'b1 1'b0 0x011110
-  0x2847, //ENNOSIGDE
-  0x2849, //1'b1 1'b1 NOUSENOSI
-  0x284A, //EQINITWAITTIME[7:0] 01100100
-  0x3000, //1'b1 1'b1 1'b1 x x x 1'b0 RPTRSTM
-  0x3001, //RPTRSTWAITTIME[7:0] (100msec) 00110010
-  0x3031, //FRAMELOC
-  0x3032, //1'b1 1'b0 1'b0 1'b0 x x FRAMELOCKMODE_CQS[1:0] 1000xx11
-  0x30A9, //VDLOCK_Q FRAMELOCK
-  0x30AA, //MPEGLOCK
+  0x00F4, /* TPIFTPERRCNT[7:0] */
+  0x00F5, /* TPCORREC */
+  0x00F6, /* VBBER[15:8] */
+  0x00F7, /* VBBER[7:0] */
+  0x00F8, /* VABER[15:8] */
+  0x00F9, /* VABER[7:0] */
+  0x00FA, /* TPERRCNT[7:0] */
+  0x00FB, /* NBERLOCK x x x x x x x */
+  0x00FC, /* NBERVALUE[31:24] */
+  0x00FD, /* NBERVALUE[23:16] */
+  0x00FE, /* NBERVALUE[15:8] */
+  0x00FF, /* NBERVALUE[7:0] */
+  0x1000, /* 1'b0 WODAGCOU */
+  0x1005, /* x x 1'b1 1'b1 x SRD_Q_QM */
+  0x1009, /* SRDWAITTIME[7:0] (10msec) 00100011 */
+  0x100A, /* SRDWAITTIME_CQS[7:0] (msec) 01100100 */
+  0x101A, /* x 1'b1 1'b0 1'b0 x QMDQAMMODE[2:0] x100x010 */
+  0x1036, /* 1'b0 1'b1 1'b0 1'b0 SAMGSEND_CQS[3:0] 01001110 */
+  0x103C, /* SAMGSAUTOSTL_V[3:0] SAMGSAUTOEDL_V[3:0] 01000110 */
+  0x103D, /* 1'b1 1'b1 SAMCNORMBP_V[1:0] 1'b0 1'b0 SAMMODESEL_V[1:0] 11100001 */
+  0x103F, /* SAMZTEDSE */
+  0x105D, /* EQSTATUSE */
+  0x105F, /* x PMAPG2_V[2:0] x DMAPG2_V[2:0] x001x011 */
+  0x1060, /* 1'b1 EQSTATUSE */
+  0x1061, /* CRMAPBWSTL_V[3:0] CRMAPBWEDL_V[3:0] 00000100 */
+  0x1065, /* 1'b0 x CRMODE_V[1:0] 1'b1 x 1'b1 x 0x111x1x */
+  0x1066, /* 1'b0 1'b0 1'b1 1'b0 1'b1 PNBOOSTSE */
+  0x1068, /* CREPHNGAIN2_V[3:0] CREPHNPBW_V[3:0] 10010001 */
+  0x106E, /* x x x x x CREPHNEN_ */
+  0x106F, /* CREPHNTH_V[7:0] 00010101 */
+  0x1072, /* CRSWEEPN */
+  0x1073, /* CRPGAIN_V[3:0] x x 1'b1 1'b1 1001xx11 */
+  0x1074, /* CRPBW_V[3:0] x x 1'b1 1'b1 0001xx11 */
+  0x1080, /* DAFTSTATUS[1:0] x x x x x x */
+  0x1081, /* SRDSTATUS[1:0] x x x x x SRDLOCK */
+  0x10A9, /* EQSTATUS_CQS[1:0] x x x x x x */
+  0x10B7, /* EQSTATUS_V[1:0] x x x x x x */
+#if 0 /* SMART_ANT */
+  0x1F00, /* MODEDETE */
+  0x1F01, /* x x x x x x x SFNRST xxxxxxx0 */
+  0x1F03, /* NUMOFANT[7:0] 10000000 */
+  0x1F04, /* x SELMASK[6:0] x0000000 */
+  0x1F05, /* x SETMASK[6:0] x0000000 */
+  0x1F06, /* x TXDATA[6:0] x0000000 */
+  0x1F07, /* x CHNUMBER[6:0] x0000000 */
+  0x1F09, /* AGCTIME[23:16] 10011000 */
+  0x1F0A, /* AGCTIME[15:8] 10010110 */
+  0x1F0B, /* AGCTIME[7:0] 10000000 */
+  0x1F0C, /* ANTTIME[31:24] 00000000 */
+  0x1F0D, /* ANTTIME[23:16] 00000011 */
+  0x1F0E, /* ANTTIME[15:8] 10010000 */
+  0x1F0F, /* ANTTIME[7:0] 10010000 */
+  0x1F11, /* SYNCTIME[23:16] 10011000 */
+  0x1F12, /* SYNCTIME[15:8] 10010110 */
+  0x1F13, /* SYNCTIME[7:0] 10000000 */
+  0x1F14, /* SNRTIME[31:24] 00000001 */
+  0x1F15, /* SNRTIME[23:16] 01111101 */
+  0x1F16, /* SNRTIME[15:8] 01111000 */
+  0x1F17, /* SNRTIME[7:0] 01000000 */
+  0x1F19, /* FECTIME[23:16] 00000000 */
+  0x1F1A, /* FECTIME[15:8] 01110010 */
+  0x1F1B, /* FECTIME[7:0] 01110000 */
+  0x1F1D, /* FECTHD[7:0] 00000011 */
+  0x1F1F, /* SNRTHD[23:16] 00001000 */
+  0x1F20, /* SNRTHD[15:8] 01111111 */
+  0x1F21, /* SNRTHD[7:0] 10000101 */
+  0x1F80, /* IRQFLG x x SFSDRFLG MODEBFLG SAVEFLG SCANFLG TRACKFLG */
+  0x1F81, /* x SYNCCON SNRCON FECCON x STDBUSY SYNCRST AGCFZCO */
+  0x1F82, /* x x x SCANOPCD[4:0] */
+  0x1F83, /* x x x x MAINOPCD[3:0] */
+  0x1F84, /* x x RXDATA[13:8] */
+  0x1F85, /* RXDATA[7:0] */
+  0x1F86, /* x x SDTDATA[13:8] */
+  0x1F87, /* SDTDATA[7:0] */
+  0x1F89, /* ANTSNR[23:16] */
+  0x1F8A, /* ANTSNR[15:8] */
+  0x1F8B, /* ANTSNR[7:0] */
+  0x1F8C, /* x x x x ANTFEC[13:8] */
+  0x1F8D, /* ANTFEC[7:0] */
+  0x1F8E, /* MAXCNT[7:0] */
+  0x1F8F, /* SCANCNT[7:0] */
+  0x1F91, /* MAXPW[23:16] */
+  0x1F92, /* MAXPW[15:8] */
+  0x1F93, /* MAXPW[7:0] */
+  0x1F95, /* CURPWMSE[23:16] */
+  0x1F96, /* CURPWMSE[15:8] */
+  0x1F97, /* CURPWMSE[7:0] */
+#endif /* SMART_ANT */
+  0x211F, /* 1'b1 1'b1 1'b1 CIRQEN x x 1'b0 1'b0 1111xx00 */
+  0x212A, /* EQAUTOST */
+  0x2122, /* CHFAST[7:0] 01100000 */
+  0x212B, /* FFFSTEP_V[3:0] x FBFSTEP_V[2:0] 0001x001 */
+  0x212C, /* PHDEROTBWSEL[3:0] 1'b1 1'b1 1'b1 1'b0 10001110 */
+  0x212D, /* 1'b1 1'b1 1'b1 1'b1 x x TPIFLOCKS */
+  0x2135, /* DYNTRACKFDEQ[3:0] x 1'b0 1'b0 1'b0 1010x000 */
+  0x2141, /* TRMODE[1:0] 1'b1 1'b1 1'b0 1'b1 1'b1 1'b1 01110111 */
+  0x2162, /* AICCCTRLE */
+  0x2173, /* PHNCNFCNT[7:0] 00000100 */
+  0x2179, /* 1'b0 1'b0 1'b0 1'b1 x BADSINGLEDYNTRACKFBF[2:0] 0001x001 */
+  0x217A, /* 1'b0 1'b0 1'b0 1'b1 x BADSLOWSINGLEDYNTRACKFBF[2:0] 0001x001 */
+  0x217E, /* CNFCNTTPIF[7:0] 00001000 */
+  0x217F, /* TPERRCNTTPIF[7:0] 00000001 */
+  0x2180, /* x x x x x x FBDLYCIR[9:8] */
+  0x2181, /* FBDLYCIR[7:0] */
+  0x2185, /* MAXPWRMAIN[7:0] */
+  0x2191, /* NCOMBDET x x x x x x x */
+  0x2199, /* x MAINSTRON */
+  0x219A, /* FFFEQSTEPOUT_V[3:0] FBFSTEPOUT_V[2:0] */
+  0x21A1, /* x x SNRREF[5:0] */
+  0x2845, /* 1'b0 1'b1 x x FFFSTEP_CQS[1:0] FFFCENTERTAP[1:0] 01xx1110 */
+  0x2846, /* 1'b0 x 1'b0 1'b1 FBFSTEP_CQS[1:0] 1'b1 1'b0 0x011110 */
+  0x2847, /* ENNOSIGDE */
+  0x2849, /* 1'b1 1'b1 NOUSENOSI */
+  0x284A, /* EQINITWAITTIME[7:0] 01100100 */
+  0x3000, /* 1'b1 1'b1 1'b1 x x x 1'b0 RPTRSTM */
+  0x3001, /* RPTRSTWAITTIME[7:0] (100msec) 00110010 */
+  0x3031, /* FRAMELOC */
+  0x3032, /* 1'b1 1'b0 1'b0 1'b0 x x FRAMELOCKMODE_CQS[1:0] 1000xx11 */
+  0x30A9, /* VDLOCK_Q FRAMELOCK */
+  0x30AA, /* MPEGLOCK */
 };
 
 #define numDumpRegs  (sizeof(regtab)/sizeof(regtab[0]))

commit f883d603d4ba0485529c733e7232249f0cc8c938
Author: Michael Ira Krufky <mkrufky@linuxtv.org>
Date:   Sun Aug 3 15:29:04 2014 -0300

    [media] lgdt3306a: do not add new typedefs
    
    We should not be using typedefs at the Kernel, as this makes harder
    for reviewers to understand the code.
    
    Signed-off-by: Michael Ira Krufky <mkrufky@linuxtv.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/lgdt3306a.c b/drivers/media/dvb-frontends/lgdt3306a.c
index 91d986297e02..33d76b6c5c67 100644
--- a/drivers/media/dvb-frontends/lgdt3306a.c
+++ b/drivers/media/dvb-frontends/lgdt3306a.c
@@ -77,34 +77,33 @@ struct lgdt3306a_state {
  3000 -> 30FF FEC control and status
  ---------------------------------------------- */
 
-typedef enum{
-	LG3306_UNLOCK	    = 0x00,
-	LG3306_LOCK	        = 0x01,
-	LG3306_UNKNOWN_LOCK	= 0xFF
-}LG3306_LOCK_STATUS;
+enum lgdt3306a_lock_status {
+	LG3306_UNLOCK       = 0x00,
+	LG3306_LOCK         = 0x01,
+	LG3306_UNKNOWN_LOCK = 0xFF
+};
 
-typedef enum{
+enum lgdt3306a_neverlock_status {
 	LG3306_NL_INIT    = 0x00,
 	LG3306_NL_PROCESS = 0x01,
 	LG3306_NL_LOCK    = 0x02,
 	LG3306_NL_FAIL    = 0x03,
 	LG3306_NL_UNKNOWN = 0xFF
-}LG3306_NEVERLOCK_STATUS;
+};
 
-typedef enum{
-	LG3306_VSB	        = 0x00,
-	LG3306_QAM64	    = 0x01,
-	LG3306_QAM256	    = 0x02,
-	LG3306_UNKNOWN_MODE	= 0xFF
-}LG3306_MODULATION;
+enum lgdt3306a_modulation {
+	LG3306_VSB          = 0x00,
+	LG3306_QAM64        = 0x01,
+	LG3306_QAM256       = 0x02,
+	LG3306_UNKNOWN_MODE = 0xFF
+};
 
-typedef enum
-{
+enum lgdt3306a_lock_check {
 	LG3306_SYNC_LOCK,
 	LG3306_FEC_LOCK,
 	LG3306_TR_LOCK,
 	LG3306_AGC_LOCK,
-} LG3306_LOCK_CHECK;
+};
 
 
 #ifdef DBG_DUMP
@@ -1077,7 +1076,7 @@ static void lgdt3306a_monitor_vsb(struct lgdt3306a_state *state)
 	ret = lgdt3306a_write_reg(state, 0x103D, val);
 }
 
-static LG3306_MODULATION lgdt3306a_check_oper_mode(struct lgdt3306a_state *state)
+static enum lgdt3306a_modulation lgdt3306a_check_oper_mode(struct lgdt3306a_state *state)
 {
 	u8 val = 0;
 	int ret;
@@ -1103,13 +1102,13 @@ static LG3306_MODULATION lgdt3306a_check_oper_mode(struct lgdt3306a_state *state
 	return LG3306_UNKNOWN_MODE;
 }
 
-static LG3306_LOCK_STATUS lgdt3306a_check_lock_status(struct lgdt3306a_state *state,
-			LG3306_LOCK_CHECK whatLock)
+static enum lgdt3306a_lock_status lgdt3306a_check_lock_status(struct lgdt3306a_state *state,
+			enum lgdt3306a_lock_check whatLock)
 {
 	u8 val = 0;
 	int ret;
-	LG3306_MODULATION	modeOper;
-	LG3306_LOCK_STATUS lockStatus;
+	enum lgdt3306a_modulation	modeOper;
+	enum lgdt3306a_lock_status lockStatus;
 
 	modeOper = LG3306_UNKNOWN_MODE;
 
@@ -1180,14 +1179,14 @@ static LG3306_LOCK_STATUS lgdt3306a_check_lock_status(struct lgdt3306a_state *st
 	return lockStatus;
 }
 
-static LG3306_NEVERLOCK_STATUS lgdt3306a_check_neverlock_status(struct lgdt3306a_state *state)
+static enum lgdt3306a_neverlock_status lgdt3306a_check_neverlock_status(struct lgdt3306a_state *state)
 {
 	u8 val = 0;
 	int ret;
-	LG3306_NEVERLOCK_STATUS lockStatus;
+	enum lgdt3306a_neverlock_status lockStatus;
 
 	ret = lgdt3306a_read_reg(state, 0x0080, &val);
-	lockStatus = (LG3306_NEVERLOCK_STATUS)(val & 0x03);
+	lockStatus = (enum lgdt3306a_neverlock_status)(val & 0x03);
 
 	lg_dbg("NeverLock=%d", lockStatus);
 
@@ -1248,9 +1247,9 @@ static void lgdt3306a_pre_monitoring(struct lgdt3306a_state *state)
 
 }
 
-static LG3306_LOCK_STATUS lgdt3306a_sync_lock_poll(struct lgdt3306a_state *state)
+static enum lgdt3306a_lock_status lgdt3306a_sync_lock_poll(struct lgdt3306a_state *state)
 {
-	LG3306_LOCK_STATUS syncLockStatus = LG3306_UNLOCK;
+	enum lgdt3306a_lock_status syncLockStatus = LG3306_UNLOCK;
 	int	i;
 
 	for (i = 0; i < 2; i++)	{
@@ -1267,9 +1266,9 @@ static LG3306_LOCK_STATUS lgdt3306a_sync_lock_poll(struct lgdt3306a_state *state
 	return LG3306_UNLOCK;
 }
 
-static LG3306_LOCK_STATUS lgdt3306a_fec_lock_poll(struct lgdt3306a_state *state)
+static enum lgdt3306a_lock_status lgdt3306a_fec_lock_poll(struct lgdt3306a_state *state)
 {
-	LG3306_LOCK_STATUS FECLockStatus = LG3306_UNLOCK;
+	enum lgdt3306a_lock_status FECLockStatus = LG3306_UNLOCK;
 	int	i;
 
 	for (i = 0; i < 2; i++)	{
@@ -1286,9 +1285,9 @@ static LG3306_LOCK_STATUS lgdt3306a_fec_lock_poll(struct lgdt3306a_state *state)
 	return FECLockStatus;
 }
 
-static LG3306_NEVERLOCK_STATUS lgdt3306a_neverlock_poll(struct lgdt3306a_state *state)
+static enum lgdt3306a_neverlock_status lgdt3306a_neverlock_poll(struct lgdt3306a_state *state)
 {
-	LG3306_NEVERLOCK_STATUS NLLockStatus = LG3306_NL_FAIL;
+	enum lgdt3306a_neverlock_status NLLockStatus = LG3306_NL_FAIL;
 	int	i;
 
 	for (i = 0; i < 5; i++) {
@@ -1380,7 +1379,7 @@ static u32 lgdt3306a_calculate_snr_x100(struct lgdt3306a_state *state)
 	return snr_x100;
 }
 
-static LG3306_LOCK_STATUS lgdt3306a_vsb_lock_poll(struct lgdt3306a_state *state)
+static enum lgdt3306a_lock_status lgdt3306a_vsb_lock_poll(struct lgdt3306a_state *state)
 {
 	u8 cnt = 0;
 	u8 packet_error;
@@ -1413,7 +1412,7 @@ static LG3306_LOCK_STATUS lgdt3306a_vsb_lock_poll(struct lgdt3306a_state *state)
 	return LG3306_UNLOCK;
 }
 
-static LG3306_LOCK_STATUS lgdt3306a_qam_lock_poll(struct lgdt3306a_state *state)
+static enum lgdt3306a_lock_status lgdt3306a_qam_lock_poll(struct lgdt3306a_state *state)
 {
 	u8 cnt = 0;
 	u8 packet_error;

commit ae21e447773f17b61014c286ed5e0fc3db874df6
Author: Michael Ira Krufky <mkrufky@linuxtv.org>
Date:   Sun Aug 3 15:18:23 2014 -0300

    [media] lgdt3306a: fix ERROR: do not use assignment in if condition
    
    Just CodingStyle fix.
    
    Signed-off-by: Michael Ira Krufky <mkrufky@linuxtv.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/lgdt3306a.c b/drivers/media/dvb-frontends/lgdt3306a.c
index 3451e77a2771..91d986297e02 100644
--- a/drivers/media/dvb-frontends/lgdt3306a.c
+++ b/drivers/media/dvb-frontends/lgdt3306a.c
@@ -1600,7 +1600,8 @@ static int lgdt3306a_tune(struct dvb_frontend *fe, bool re_tune, unsigned int mo
 
 	if (re_tune) {
 		state->current_frequency = -1; /* force re-tune */
-		if ((ret = lgdt3306a_set_parameters(fe)) != 0)
+		ret = lgdt3306a_set_parameters(fe);
+		if (ret != 0)
 			return ret;
 	}
 	*delay = 125;

commit ebd9175ea4c0b818cf14ef1074b5d5a93e57916a
Author: Michael Ira Krufky <mkrufky@linuxtv.org>
Date:   Sun Aug 3 15:05:59 2014 -0300

    [media] lgdt3306a: move EXPORT_SYMBOL to be just after function
    
    Fixes CodingStyle error:
            WARNING: EXPORT_SYMBOL(foo); should immediately follow its function/variable.
    
    Signed-off-by: Michael Ira Krufky <mkrufky@linuxtv.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/lgdt3306a.c b/drivers/media/dvb-frontends/lgdt3306a.c
index b0d94d734d72..3451e77a2771 100644
--- a/drivers/media/dvb-frontends/lgdt3306a.c
+++ b/drivers/media/dvb-frontends/lgdt3306a.c
@@ -1726,6 +1726,7 @@ struct dvb_frontend *lgdt3306a_attach(const struct lgdt3306a_config *config,
 	kfree(state);
 	return NULL;
 }
+EXPORT_SYMBOL(lgdt3306a_attach);
 
 #ifdef DBG_DUMP
 
@@ -1991,8 +1992,6 @@ static void lgdt3306a_DumpRegs(struct lgdt3306a_state *state)
 
 
 
-EXPORT_SYMBOL(lgdt3306a_attach);
-
 static struct dvb_frontend_ops lgdt3306a_ops = {
 	.delsys = { SYS_ATSC, SYS_DVBC_ANNEX_B },
 	.info = {

commit c714efe458e72a84cf898074269d40a575034464
Author: Michael Ira Krufky <mkrufky@linuxtv.org>
Date:   Sun Aug 3 14:51:49 2014 -0300

    [media] lgdt3306a: remove unnecessary 'else'
    
    No need for an else, as the previous if will return.
    
    Signed-off-by: Michael Ira Krufky <mkrufky@linuxtv.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/lgdt3306a.c b/drivers/media/dvb-frontends/lgdt3306a.c
index 3664da53996b..b0d94d734d72 100644
--- a/drivers/media/dvb-frontends/lgdt3306a.c
+++ b/drivers/media/dvb-frontends/lgdt3306a.c
@@ -1088,7 +1088,7 @@ static LG3306_MODULATION lgdt3306a_check_oper_mode(struct lgdt3306a_state *state
 		lg_dbg("VSB\n");
 		return LG3306_VSB;
 	}
-	else if (val & 0x08) {
+	if (val & 0x08) {
 		ret = lgdt3306a_read_reg(state, 0x00A6, &val);
 		val = val >> 2;
 		if (val & 0x01) {

commit 8e8cd34eaaf96c4bfc472ec0b4d6f7d3951c051f
Author: Michael Ira Krufky <mkrufky@linuxtv.org>
Date:   Sun Jul 27 19:24:24 2014 -0300

    [media] lgdt3306a: clean up whitespace & unneeded brackets
    
    No functional changes.
    
    Signed-off-by: Michael Ira Krufky <mkrufky@linuxtv.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/lgdt3306a.c b/drivers/media/dvb-frontends/lgdt3306a.c
index c6597b487fd0..3664da53996b 100644
--- a/drivers/media/dvb-frontends/lgdt3306a.c
+++ b/drivers/media/dvb-frontends/lgdt3306a.c
@@ -33,7 +33,7 @@ MODULE_PARM_DESC(debug, "set debug level (info=1, reg=2 (or-able))");
 
 #define DBG_INFO 1
 #define DBG_REG  2
-#define DBG_DUMP 4 //FGR - comment out to remove dump code
+#define DBG_DUMP 4 /* FGR - comment out to remove dump code */
 
 #define lg_printk(kern, fmt, arg...)					\
 	printk(kern "%s(): " fmt, __func__, ##arg)
@@ -220,13 +220,13 @@ static int lgdt3306a_mpeg_mode(struct lgdt3306a_state *state,
 	int ret;
 
 	lg_dbg("(%d)\n", mode);
-	//transport packet format
-	ret = lgdt3306a_set_reg_bit(state, 0x0071, 7, mode==LGDT3306A_MPEG_PARALLEL?1:0); //TPSENB=0x80
+	/* transport packet format */
+	ret = lgdt3306a_set_reg_bit(state, 0x0071, 7, mode == LGDT3306A_MPEG_PARALLEL?1:0); /* TPSENB=0x80 */
 	if (lg_chkerr(ret))
 		goto fail;
 
-	//start of packet signal duration
-	ret = lgdt3306a_set_reg_bit(state, 0x0071, 6, 0); //TPSSOPBITEN=0x40; 0=byte duration, 1=bit duration
+	/* start of packet signal duration */
+	ret = lgdt3306a_set_reg_bit(state, 0x0071, 6, 0); /* TPSSOPBITEN=0x40; 0=byte duration, 1=bit duration */
 	if (lg_chkerr(ret))
 		goto fail;
 
@@ -234,9 +234,9 @@ static int lgdt3306a_mpeg_mode(struct lgdt3306a_state *state,
 	if (lg_chkerr(ret))
 		goto fail;
 
-	val |= 0x10;//TPCLKSUPB=0x10
+	val |= 0x10; /* TPCLKSUPB=0x10 */
 
-	if (mode==LGDT3306A_MPEG_PARALLEL)
+	if (mode == LGDT3306A_MPEG_PARALLEL)
 		val &= ~0x10;
 
 	ret = lgdt3306a_write_reg(state, 0x0070, val);
@@ -259,11 +259,11 @@ static int lgdt3306a_mpeg_mode_polarity(struct lgdt3306a_state *state,
 	if (lg_chkerr(ret))
 		goto fail;
 
-	val &= ~0x06;//TPCLKPOL=0x04, TPVALPOL=0x02
+	val &= ~0x06; /* TPCLKPOL=0x04, TPVALPOL=0x02 */
 
-	if (edge==LGDT3306A_TPCLK_RISING_EDGE)
+	if (edge == LGDT3306A_TPCLK_RISING_EDGE)
 		val |= 0x04;
-	if (valid==LGDT3306A_TP_VALID_HIGH)
+	if (valid == LGDT3306A_TP_VALID_HIGH)
 		val |= 0x02;
 
 	ret = lgdt3306a_write_reg(state, 0x0070, val);
@@ -281,21 +281,21 @@ static int lgdt3306a_mpeg_tristate(struct lgdt3306a_state *state,
 
 	lg_dbg("(%d)\n", mode);
 
-	if(mode){
+	if (mode) {
 		ret = lgdt3306a_read_reg(state, 0x0070, &val);
 		if (lg_chkerr(ret))
 			goto fail;
-		val &= ~0xA8; //Tristate bus; TPOUTEN=0x80, TPCLKOUTEN=0x20, TPDATAOUTEN=0x08
+		val &= ~0xA8; /* Tristate bus; TPOUTEN=0x80, TPCLKOUTEN=0x20, TPDATAOUTEN=0x08 */
 		ret = lgdt3306a_write_reg(state, 0x0070, val);
 		if (lg_chkerr(ret))
 			goto fail;
 
-		ret = lgdt3306a_set_reg_bit(state, 0x0003, 6, 1);//AGCIFOUTENB=0x40; 1=Disable IFAGC pin
+		ret = lgdt3306a_set_reg_bit(state, 0x0003, 6, 1); /* AGCIFOUTENB=0x40; 1=Disable IFAGC pin */
 		if (lg_chkerr(ret))
 			goto fail;
 
 	} else {
-		ret = lgdt3306a_set_reg_bit(state, 0x0003, 6, 0);//enable IFAGC pin
+		ret = lgdt3306a_set_reg_bit(state, 0x0003, 6, 0); /* enable IFAGC pin */
 		if (lg_chkerr(ret))
 			goto fail;
 
@@ -303,7 +303,7 @@ static int lgdt3306a_mpeg_tristate(struct lgdt3306a_state *state,
 		if (lg_chkerr(ret))
 			goto fail;
 
-		val |= 0xA8; //Enable bus
+		val |= 0xA8; /* enable bus */
 		ret = lgdt3306a_write_reg(state, 0x0070, val);
 		if (lg_chkerr(ret))
 			goto fail;
@@ -313,7 +313,7 @@ static int lgdt3306a_mpeg_tristate(struct lgdt3306a_state *state,
 	return ret;
 }
 
-static int lgdt3306a_ts_bus_ctrl(struct dvb_frontend* fe, int acquire)
+static int lgdt3306a_ts_bus_ctrl(struct dvb_frontend *fe, int acquire)
 {
 	struct lgdt3306a_state *state = fe->demodulator_priv;
 
@@ -330,21 +330,21 @@ static int lgdt3306a_power(struct lgdt3306a_state *state,
 
 	lg_dbg("(%d)\n", mode);
 
-	if(mode == 0){
-		ret = lgdt3306a_set_reg_bit(state, 0x0000, 7, 0); //into reset
+	if (mode == 0) {
+		ret = lgdt3306a_set_reg_bit(state, 0x0000, 7, 0); /* into reset */
 		if (lg_chkerr(ret))
 			goto fail;
 
-		ret = lgdt3306a_set_reg_bit(state, 0x0000, 0, 0); //power down
+		ret = lgdt3306a_set_reg_bit(state, 0x0000, 0, 0); /* power down */
 		if (lg_chkerr(ret))
 			goto fail;
 
 	} else {
-		ret = lgdt3306a_set_reg_bit(state, 0x0000, 7, 1); //out of reset
+		ret = lgdt3306a_set_reg_bit(state, 0x0000, 7, 1); /* out of reset */
 		if (lg_chkerr(ret))
 			goto fail;
 
-		ret = lgdt3306a_set_reg_bit(state, 0x0000, 0, 1); //power up
+		ret = lgdt3306a_set_reg_bit(state, 0x0000, 0, 1); /* power up */
 		if (lg_chkerr(ret))
 			goto fail;
 	}
@@ -364,88 +364,92 @@ static int lgdt3306a_set_vsb(struct lgdt3306a_state *state)
 
 	lg_dbg("\n");
 
-	// 0. Spectrum inversion detection manual; spectrum inverted
+	/* 0. Spectrum inversion detection manual; spectrum inverted */
 	ret = lgdt3306a_read_reg(state, 0x0002, &val);
-	val &= 0xF7; //SPECINVAUTO Off
-	val |= 0x04; //SPECINV On
+	val &= 0xF7; /* SPECINVAUTO Off */
+	val |= 0x04; /* SPECINV On */
 	ret = lgdt3306a_write_reg(state, 0x0002, val);
 	if (lg_chkerr(ret))
 		goto fail;
 
-	// 1. Selection of standard mode(0x08=QAM, 0x80=VSB)
+	/* 1. Selection of standard mode(0x08=QAM, 0x80=VSB) */
 	ret = lgdt3306a_write_reg(state, 0x0008, 0x80);
 	if (lg_chkerr(ret))
 		goto fail;
 
-	// 2. Bandwidth mode for VSB(6MHz)
+	/* 2. Bandwidth mode for VSB(6MHz) */
 	ret = lgdt3306a_read_reg(state, 0x0009, &val);
 	val &= 0xE3;
-	val |= 0x0C; //STDOPDETTMODE[2:0]=3
+	val |= 0x0C; /* STDOPDETTMODE[2:0]=3 */
 	ret = lgdt3306a_write_reg(state, 0x0009, val);
 	if (lg_chkerr(ret))
 		goto fail;
 
-	// 3. QAM mode detection mode(None)
+	/* 3. QAM mode detection mode(None) */
 	ret = lgdt3306a_read_reg(state, 0x0009, &val);
-	val &= 0xFC; //STDOPDETCMODE[1:0]=0
+	val &= 0xFC; /* STDOPDETCMODE[1:0]=0 */
 	ret = lgdt3306a_write_reg(state, 0x0009, val);
 	if (lg_chkerr(ret))
 		goto fail;
 
-	// 4. ADC sampling frequency rate(2x sampling)
+	/* 4. ADC sampling frequency rate(2x sampling) */
 	ret = lgdt3306a_read_reg(state, 0x000D, &val);
-	val &= 0xBF; //SAMPLING4XFEN=0
+	val &= 0xBF; /* SAMPLING4XFEN=0 */
 	ret = lgdt3306a_write_reg(state, 0x000D, val);
 	if (lg_chkerr(ret))
 		goto fail;
 
-#if 0 //FGR - disable any AICC filtering, testing only
+#if 0
+	/* FGR - disable any AICC filtering, testing only */
+
 	ret = lgdt3306a_write_reg(state, 0x0024, 0x00);
 	if (lg_chkerr(ret))
 		goto fail;
 
-	//AICCFIXFREQ0 NT N-1(Video rejection)
+	/* AICCFIXFREQ0 NT N-1(Video rejection) */
 	ret = lgdt3306a_write_reg(state, 0x002E, 0x00);
 	ret = lgdt3306a_write_reg(state, 0x002F, 0x00);
 	ret = lgdt3306a_write_reg(state, 0x0030, 0x00);
 
-	//AICCFIXFREQ1 NT N-1(Audio rejection)
+	/* AICCFIXFREQ1 NT N-1(Audio rejection) */
 	ret = lgdt3306a_write_reg(state, 0x002B, 0x00);
 	ret = lgdt3306a_write_reg(state, 0x002C, 0x00);
 	ret = lgdt3306a_write_reg(state, 0x002D, 0x00);
 
-	//AICCFIXFREQ2 NT Co-Channel(Video rejection)
+	/* AICCFIXFREQ2 NT Co-Channel(Video rejection) */
 	ret = lgdt3306a_write_reg(state, 0x0028, 0x00);
 	ret = lgdt3306a_write_reg(state, 0x0029, 0x00);
 	ret = lgdt3306a_write_reg(state, 0x002A, 0x00);
 
-	//AICCFIXFREQ3 NT Co-Channel(Audio rejection)
+	/* AICCFIXFREQ3 NT Co-Channel(Audio rejection) */
 	ret = lgdt3306a_write_reg(state, 0x0025, 0x00);
 	ret = lgdt3306a_write_reg(state, 0x0026, 0x00);
 	ret = lgdt3306a_write_reg(state, 0x0027, 0x00);
 
-#else //FGR - this works well for HVR-1955,1975
-	// 5. AICCOPMODE  NT N-1 Adj.
+#else
+	/* FGR - this works well for HVR-1955,1975 */
+
+	/* 5. AICCOPMODE  NT N-1 Adj. */
 	ret = lgdt3306a_write_reg(state, 0x0024, 0x5A);
 	if (lg_chkerr(ret))
 		goto fail;
 
-	//AICCFIXFREQ0 NT N-1(Video rejection)
+	/* AICCFIXFREQ0 NT N-1(Video rejection) */
 	ret = lgdt3306a_write_reg(state, 0x002E, 0x5A);
 	ret = lgdt3306a_write_reg(state, 0x002F, 0x00);
 	ret = lgdt3306a_write_reg(state, 0x0030, 0x00);
 
-	//AICCFIXFREQ1 NT N-1(Audio rejection)
+	/* AICCFIXFREQ1 NT N-1(Audio rejection) */
 	ret = lgdt3306a_write_reg(state, 0x002B, 0x36);
 	ret = lgdt3306a_write_reg(state, 0x002C, 0x00);
 	ret = lgdt3306a_write_reg(state, 0x002D, 0x00);
 
-	//AICCFIXFREQ2 NT Co-Channel(Video rejection)
+	/* AICCFIXFREQ2 NT Co-Channel(Video rejection) */
 	ret = lgdt3306a_write_reg(state, 0x0028, 0x2A);
 	ret = lgdt3306a_write_reg(state, 0x0029, 0x00);
 	ret = lgdt3306a_write_reg(state, 0x002A, 0x00);
 
-	//AICCFIXFREQ3 NT Co-Channel(Audio rejection)
+	/* AICCFIXFREQ3 NT Co-Channel(Audio rejection) */
 	ret = lgdt3306a_write_reg(state, 0x0025, 0x06);
 	ret = lgdt3306a_write_reg(state, 0x0026, 0x00);
 	ret = lgdt3306a_write_reg(state, 0x0027, 0x00);
@@ -494,7 +498,7 @@ static int lgdt3306a_set_vsb(struct lgdt3306a_state *state)
 	val &= 0x7F;
 	ret = lgdt3306a_write_reg(state, 0x001C, val);
 
-	// 6. EQ step size
+	/* 6. EQ step size */
 	ret = lgdt3306a_read_reg(state, 0x2179, &val);
 	val &= 0xF8;
 	ret = lgdt3306a_write_reg(state, 0x2179, val);
@@ -503,7 +507,7 @@ static int lgdt3306a_set_vsb(struct lgdt3306a_state *state)
 	val &= 0xF8;
 	ret = lgdt3306a_write_reg(state, 0x217A, val);
 
-	// 7. Reset
+	/* 7. Reset */
 	ret = lgdt3306a_soft_reset(state);
 	if (lg_chkerr(ret))
 		goto fail;
@@ -520,62 +524,62 @@ static int lgdt3306a_set_qam(struct lgdt3306a_state *state, int modulation)
 
 	lg_dbg("modulation=%d\n", modulation);
 
-	// 1. Selection of standard mode(0x08=QAM, 0x80=VSB)
+	/* 1. Selection of standard mode(0x08=QAM, 0x80=VSB) */
 	ret = lgdt3306a_write_reg(state, 0x0008, 0x08);
 	if (lg_chkerr(ret))
 		goto fail;
 
-	// 1a. Spectrum inversion detection to Auto
+	/* 1a. Spectrum inversion detection to Auto */
 	ret = lgdt3306a_read_reg(state, 0x0002, &val);
-	val &= 0xFB; //SPECINV Off
-	val |= 0x08; //SPECINVAUTO On
+	val &= 0xFB; /* SPECINV Off */
+	val |= 0x08; /* SPECINVAUTO On */
 	ret = lgdt3306a_write_reg(state, 0x0002, val);
 	if (lg_chkerr(ret))
 		goto fail;
 
-	// 2. Bandwidth mode for QAM
+	/* 2. Bandwidth mode for QAM */
 	ret = lgdt3306a_read_reg(state, 0x0009, &val);
-	val &= 0xE3; //STDOPDETTMODE[2:0]=0	VSB Off
+	val &= 0xE3; /* STDOPDETTMODE[2:0]=0 VSB Off */
 	ret = lgdt3306a_write_reg(state, 0x0009, val);
 	if (lg_chkerr(ret))
 		goto fail;
 
-	// 3. : 64QAM/256QAM detection(manual, auto)
+	/* 3. : 64QAM/256QAM detection(manual, auto) */
 	ret = lgdt3306a_read_reg(state, 0x0009, &val);
 	val &= 0xFC;
-	val |= 0x02; //STDOPDETCMODE[1:0]=1=Manual 2=Auto
+	val |= 0x02; /* STDOPDETCMODE[1:0]=1=Manual 2=Auto */
 	ret = lgdt3306a_write_reg(state, 0x0009, val);
 	if (lg_chkerr(ret))
 		goto fail;
 
-	// 3a. : 64QAM/256QAM selection for manual
+	/* 3a. : 64QAM/256QAM selection for manual */
 	ret = lgdt3306a_read_reg(state, 0x101a, &val);
 	val &= 0xF8;
-	if(modulation == QAM_64){
-		val |= 0x02; //QMDQMODE[2:0]=2=QAM64
-	} else {
-		val |= 0x04; //QMDQMODE[2:0]=4=QAM256
-	}
+	if (modulation == QAM_64)
+		val |= 0x02; /* QMDQMODE[2:0]=2=QAM64 */
+	else
+		val |= 0x04; /* QMDQMODE[2:0]=4=QAM256 */
+
 	ret = lgdt3306a_write_reg(state, 0x101a, val);
 	if (lg_chkerr(ret))
 		goto fail;
 
-	// 4. ADC sampling frequency rate(4x sampling)
+	/* 4. ADC sampling frequency rate(4x sampling) */
 	ret = lgdt3306a_read_reg(state, 0x000D, &val);
 	val &= 0xBF;
-	val |= 0x40; //SAMPLING4XFEN=1
+	val |= 0x40; /* SAMPLING4XFEN=1 */
 	ret = lgdt3306a_write_reg(state, 0x000D, val);
 	if (lg_chkerr(ret))
 		goto fail;
 
-	// 5. No AICC operation in QAM mode
+	/* 5. No AICC operation in QAM mode */
 	ret = lgdt3306a_read_reg(state, 0x0024, &val);
 	val &= 0x00;
 	ret = lgdt3306a_write_reg(state, 0x0024, val);
 	if (lg_chkerr(ret))
 		goto fail;
 
-	// 6. Reset
+	/* 6. Reset */
 	ret = lgdt3306a_soft_reset(state);
 	if (lg_chkerr(ret))
 		goto fail;
@@ -619,7 +623,7 @@ static int lgdt3306a_set_modulation(struct lgdt3306a_state *state,
 static int lgdt3306a_agc_setup(struct lgdt3306a_state *state,
 			      struct dtv_frontend_properties *p)
 {
-	//TODO: anything we want to do here???
+	/* TODO: anything we want to do here??? */
 	lg_dbg("\n");
 
 	switch (p->modulation) {
@@ -643,7 +647,7 @@ static int lgdt3306a_set_inversion(struct lgdt3306a_state *state,
 
 	lg_dbg("(%d)\n", inversion);
 
-	ret = lgdt3306a_set_reg_bit(state, 0x0002, 2, inversion?1:0);
+	ret = lgdt3306a_set_reg_bit(state, 0x0002, 2, inversion ? 1 : 0);
 	return ret;
 }
 
@@ -654,8 +658,8 @@ static int lgdt3306a_set_inversion_auto(struct lgdt3306a_state *state,
 
 	lg_dbg("(%d)\n", enabled);
 
-	//0=Manual 1=Auto(QAM only)
-	ret = lgdt3306a_set_reg_bit(state, 0x0002, 3, enabled);//SPECINVAUTO=0x04
+	/* 0=Manual 1=Auto(QAM only) */
+	ret = lgdt3306a_set_reg_bit(state, 0x0002, 3, enabled);/* SPECINVAUTO=0x04 */
 	return ret;
 }
 
@@ -666,17 +670,18 @@ static int lgdt3306a_spectral_inversion(struct lgdt3306a_state *state,
 	int ret = 0;
 
 	lg_dbg("(%d)\n", inversion);
-#if 0//FGR - spectral_inversion defaults already set for VSB and QAM; can enable later if desired
+#if 0
+/* FGR - spectral_inversion defaults already set for VSB and QAM; can enable later if desired */
 
 	ret = lgdt3306a_set_inversion(state, inversion);
 
 	switch (p->modulation) {
 	case VSB_8:
-		ret = lgdt3306a_set_inversion_auto(state, 0);//Manual only for VSB
+		ret = lgdt3306a_set_inversion_auto(state, 0); /* Manual only for VSB */
 		break;
 	case QAM_64:
 	case QAM_256:
-		ret = lgdt3306a_set_inversion_auto(state, 1);//Auto ok for QAM
+		ret = lgdt3306a_set_inversion_auto(state, 1); /* Auto ok for QAM */
 		break;
 	default:
 		ret = -EINVAL;
@@ -704,27 +709,27 @@ static int lgdt3306a_set_if(struct lgdt3306a_state *state,
 		return -EINVAL;
 	}
 
-	switch(if_freq_khz){
+	switch (if_freq_khz) {
 	default:
 	    lg_warn("IF=%d KHz is not supportted, 3250 assumed\n", if_freq_khz);
-		//fallthrough
-	case 3250:  //3.25Mhz
+		/* fallthrough */
+	case 3250:  /* 3.25Mhz */
 		nco1 = 0x34;
 		nco2 = 0x00;
 		break;
-	case 3500:  //3.50Mhz
+	case 3500:  /* 3.50Mhz */
 		nco1 = 0x38;
 		nco2 = 0x00;
 		break;
-	case 4000:  //4.00Mhz
+	case 4000:  /* 4.00Mhz */
 		nco1 = 0x40;
 		nco2 = 0x00;
 		break;
-	case 5000:  //5.00Mhz
+	case 5000:  /* 5.00Mhz */
 		nco1 = 0x50;
 		nco2 = 0x00;
 		break;
-	case 5380: //5.38Mhz
+	case 5380: /* 5.38Mhz */
 		nco1 = 0x56;
 		nco2 = 0x14;
 		break;
@@ -743,13 +748,13 @@ static int lgdt3306a_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)
 {
 	struct lgdt3306a_state *state = fe->demodulator_priv;
 
-	if (state->cfg->deny_i2c_rptr){
+	if (state->cfg->deny_i2c_rptr) {
 		lg_dbg("deny_i2c_rptr=%d\n", state->cfg->deny_i2c_rptr);
 		return 0;
 	}
 	lg_dbg("(%d)\n", enable);
 
-	return lgdt3306a_set_reg_bit(state, 0x0002, 7, enable? 0 : 1); //NI2CRPTEN=0x80
+	return lgdt3306a_set_reg_bit(state, 0x0002, 7, enable ? 0 : 1); /* NI2CRPTEN=0x80 */
 }
 
 static int lgdt3306a_sleep(struct lgdt3306a_state *state)
@@ -757,13 +762,13 @@ static int lgdt3306a_sleep(struct lgdt3306a_state *state)
 	int ret;
 
 	lg_dbg("\n");
-	state->current_frequency = -1; //force re-tune, when we wake
+	state->current_frequency = -1; /* force re-tune, when we wake */
 
-	ret = lgdt3306a_mpeg_tristate(state, 1); //disable data bus
+	ret = lgdt3306a_mpeg_tristate(state, 1); /* disable data bus */
 	if (lg_chkerr(ret))
 		goto fail;
 
-	ret = lgdt3306a_power(state, 0); //power down
+	ret = lgdt3306a_power(state, 0); /* power down */
 	lg_chkerr(ret);
 
 fail:
@@ -785,43 +790,43 @@ static int lgdt3306a_init(struct dvb_frontend *fe)
 
 	lg_dbg("\n");
 
-	// 1. Normal operation mode
-	ret = lgdt3306a_set_reg_bit(state, 0x0001, 0, 1); //SIMFASTENB=0x01
+	/* 1. Normal operation mode */
+	ret = lgdt3306a_set_reg_bit(state, 0x0001, 0, 1); /* SIMFASTENB=0x01 */
 	if (lg_chkerr(ret))
 		goto fail;
 
-	// 2. Spectrum inversion auto detection (Not valid for VSB)
+	/* 2. Spectrum inversion auto detection (Not valid for VSB) */
 	ret = lgdt3306a_set_inversion_auto(state, 0);
 	if (lg_chkerr(ret))
 		goto fail;
 
-	// 3. Spectrum inversion(According to the tuner configuration)
+	/* 3. Spectrum inversion(According to the tuner configuration) */
 	ret = lgdt3306a_set_inversion(state, 1);
 	if (lg_chkerr(ret))
 		goto fail;
 
-	// 4. Peak-to-peak voltage of ADC input signal
-	ret = lgdt3306a_set_reg_bit(state, 0x0004, 7, 1); //ADCSEL1V=0x80=1Vpp; 0x00=2Vpp
+	/* 4. Peak-to-peak voltage of ADC input signal */
+	ret = lgdt3306a_set_reg_bit(state, 0x0004, 7, 1); /* ADCSEL1V=0x80=1Vpp; 0x00=2Vpp */
 	if (lg_chkerr(ret))
 		goto fail;
 
-	// 5. ADC output data capture clock phase
-	ret = lgdt3306a_set_reg_bit(state, 0x0004, 2, 0); //0=same phase as ADC clock
+	/* 5. ADC output data capture clock phase */
+	ret = lgdt3306a_set_reg_bit(state, 0x0004, 2, 0); /* 0=same phase as ADC clock */
 	if (lg_chkerr(ret))
 		goto fail;
 
-	// 5a. ADC sampling clock source
-	ret = lgdt3306a_set_reg_bit(state, 0x0004, 3, 0); //ADCCLKPLLSEL=0x08; 0=use ext clock, not PLL
+	/* 5a. ADC sampling clock source */
+	ret = lgdt3306a_set_reg_bit(state, 0x0004, 3, 0); /* ADCCLKPLLSEL=0x08; 0=use ext clock, not PLL */
 	if (lg_chkerr(ret))
 		goto fail;
 
-	// 6. Automatic PLL set
-	ret = lgdt3306a_set_reg_bit(state, 0x0005, 6, 0); //PLLSETAUTO=0x40; 0=off
+	/* 6. Automatic PLL set */
+	ret = lgdt3306a_set_reg_bit(state, 0x0005, 6, 0); /* PLLSETAUTO=0x40; 0=off */
 	if (lg_chkerr(ret))
 		goto fail;
 
-	if (state->cfg->xtalMHz == 24){	// 24MHz
-		// 7. Frequency for PLL output(0x2564 for 192MHz for 24MHz)
+	if (state->cfg->xtalMHz == 24) {	/* 24MHz */
+		/* 7. Frequency for PLL output(0x2564 for 192MHz for 24MHz) */
 		ret = lgdt3306a_read_reg(state, 0x0005, &val);
 		if (lg_chkerr(ret))
 			goto fail;
@@ -834,7 +839,7 @@ static int lgdt3306a_init(struct dvb_frontend *fe)
 		if (lg_chkerr(ret))
 			goto fail;
 
-		// 8. ADC sampling frequency(0x180000 for 24MHz sampling)
+		/* 8. ADC sampling frequency(0x180000 for 24MHz sampling) */
 		ret = lgdt3306a_read_reg(state, 0x000D, &val);
 		if (lg_chkerr(ret))
 			goto fail;
@@ -844,8 +849,8 @@ static int lgdt3306a_init(struct dvb_frontend *fe)
 		if (lg_chkerr(ret))
 			goto fail;
 
-	} else if (state->cfg->xtalMHz == 25){// 25MHz
-		// 7. Frequency for PLL output
+	} else if (state->cfg->xtalMHz == 25) { /* 25MHz */
+		/* 7. Frequency for PLL output */
 		ret = lgdt3306a_read_reg(state, 0x0005, &val);
 		if (lg_chkerr(ret))
 			goto fail;
@@ -858,7 +863,7 @@ static int lgdt3306a_init(struct dvb_frontend *fe)
 		if (lg_chkerr(ret))
 			goto fail;
 
-		// 8. ADC sampling frequency(0x190000 for 25MHz sampling)
+		/* 8. ADC sampling frequency(0x190000 for 25MHz sampling) */
 		ret = lgdt3306a_read_reg(state, 0x000D, &val);
 		if (lg_chkerr(ret))
 			goto fail;
@@ -870,54 +875,56 @@ static int lgdt3306a_init(struct dvb_frontend *fe)
 	} else {
 		lg_err("Bad xtalMHz=%d\n", state->cfg->xtalMHz);
 	}
-//	ret = lgdt3306a_write_reg(state, 0x000E, 0x00);
-//	ret = lgdt3306a_write_reg(state, 0x000F, 0x00);
+#if 0
+	ret = lgdt3306a_write_reg(state, 0x000E, 0x00);
+	ret = lgdt3306a_write_reg(state, 0x000F, 0x00);
+#endif
 
-	// 9. Center frequency of input signal of ADC
-	ret = lgdt3306a_write_reg(state, 0x0010, 0x34); //3.25MHz
-    ret = lgdt3306a_write_reg(state, 0x0011, 0x00);
+	/* 9. Center frequency of input signal of ADC */
+	ret = lgdt3306a_write_reg(state, 0x0010, 0x34); /* 3.25MHz */
+	ret = lgdt3306a_write_reg(state, 0x0011, 0x00);
 
-	// 10. Fixed gain error value
-	ret = lgdt3306a_write_reg(state, 0x0014, 0); //gain error=0
+	/* 10. Fixed gain error value */
+	ret = lgdt3306a_write_reg(state, 0x0014, 0); /* gain error=0 */
 
-	// 10a. VSB TR BW gear shift initial step
+	/* 10a. VSB TR BW gear shift initial step */
 	ret = lgdt3306a_read_reg(state, 0x103C, &val);
 	val &= 0x0F;
-	val |= 0x20; //SAMGSAUTOSTL_V[3:0] = 2
+	val |= 0x20; /* SAMGSAUTOSTL_V[3:0] = 2 */
 	ret = lgdt3306a_write_reg(state, 0x103C, val);
 
-	// 10b. Timing offset calibration in low temperature for VSB
+	/* 10b. Timing offset calibration in low temperature for VSB */
 	ret = lgdt3306a_read_reg(state, 0x103D, &val);
 	val &= 0xFC;
 	val |= 0x03;
 	ret = lgdt3306a_write_reg(state, 0x103D, val);
 
-	// 10c. Timing offset calibration in low temperature for QAM
+	/* 10c. Timing offset calibration in low temperature for QAM */
 	ret = lgdt3306a_read_reg(state, 0x1036, &val);
 	val &= 0xF0;
 	val |= 0x0C;
 	ret = lgdt3306a_write_reg(state, 0x1036, val);
 
-	// 11. Using the imaginary part of CIR in CIR loading
+	/* 11. Using the imaginary part of CIR in CIR loading */
 	ret = lgdt3306a_read_reg(state, 0x211F, &val);
-	val &= 0xEF; //do not use imaginary of CIR
+	val &= 0xEF; /* do not use imaginary of CIR */
 	ret = lgdt3306a_write_reg(state, 0x211F, val);
 
-	// 12. Control of no signal detector function
+	/* 12. Control of no signal detector function */
 	ret = lgdt3306a_read_reg(state, 0x2849, &val);
-	val &= 0xEF; //NOUSENOSIGDET=0, enable no signal detector
+	val &= 0xEF; /* NOUSENOSIGDET=0, enable no signal detector */
 	ret = lgdt3306a_write_reg(state, 0x2849, val);
 
-	//FGR - put demod in some known mode
+	/* FGR - put demod in some known mode */
 	ret = lgdt3306a_set_vsb(state);
 
-	// 13. TP stream format
+	/* 13. TP stream format */
 	ret = lgdt3306a_mpeg_mode(state, state->cfg->mpeg_mode);
 
-	// 14. disable output buses
+	/* 14. disable output buses */
 	ret = lgdt3306a_mpeg_tristate(state, 1);
 
-	// 15. Sleep (in reset)
+	/* 15. Sleep (in reset) */
 	ret = lgdt3306a_sleep(state);
 	lg_chkerr(ret);
 
@@ -933,15 +940,15 @@ static int lgdt3306a_set_parameters(struct dvb_frontend *fe)
 
 	lg_dbg("(%d, %d)\n", p->frequency, p->modulation);
 
-	if(state->current_frequency  == p->frequency &&
-	   state->current_modulation == p->modulation ){
+	if (state->current_frequency  == p->frequency &&
+	   state->current_modulation == p->modulation) {
 		lg_dbg(" (already set, skipping ...)\n");
 		return 0;
 	}
 	state->current_frequency = -1;
 	state->current_modulation = -1;
 
-	ret = lgdt3306a_power(state, 1); //power up
+	ret = lgdt3306a_power(state, 1); /* power up */
 	if (lg_chkerr(ret))
 		goto fail;
 
@@ -949,9 +956,11 @@ static int lgdt3306a_set_parameters(struct dvb_frontend *fe)
 		ret = fe->ops.tuner_ops.set_params(fe);
 		if (fe->ops.i2c_gate_ctrl)
 			fe->ops.i2c_gate_ctrl(fe, 0);
-//		if (lg_chkerr(ret))
-//			goto fail;
-//		state->current_frequency = p->frequency;
+#if 0
+		if (lg_chkerr(ret))
+			goto fail;
+		state->current_frequency = p->frequency;
+#endif
 	}
 
 	ret = lgdt3306a_set_modulation(state, p);
@@ -967,7 +976,7 @@ static int lgdt3306a_set_parameters(struct dvb_frontend *fe)
 		goto fail;
 
 	ret = lgdt3306a_spectral_inversion(state, p,
-					  state->cfg->spectral_inversion? 1 : 0);
+					  state->cfg->spectral_inversion ? 1 : 0);
 	if (lg_chkerr(ret))
 		goto fail;
 
@@ -981,7 +990,7 @@ static int lgdt3306a_set_parameters(struct dvb_frontend *fe)
 	if (lg_chkerr(ret))
 		goto fail;
 
-	ret = lgdt3306a_mpeg_tristate(state, 0); //enable data bus
+	ret = lgdt3306a_mpeg_tristate(state, 0); /* enable data bus */
 	if (lg_chkerr(ret))
 		goto fail;
 
@@ -1023,8 +1032,8 @@ static void lgdt3306a_monitor_vsb(struct lgdt3306a_state *state)
 {
 	u8 val;
 	int ret;
-	u8 	snrRef, maxPowerMan, nCombDet;
-    u16 fbDlyCir;
+	u8 snrRef, maxPowerMan, nCombDet;
+	u16 fbDlyCir;
 
 	ret = lgdt3306a_read_reg(state, 0x21A1, &val);
 	snrRef = val & 0x3F;
@@ -1042,26 +1051,26 @@ static void lgdt3306a_monitor_vsb(struct lgdt3306a_state *state)
 	lg_dbg("snrRef=%d maxPowerMan=0x%x nCombDet=%d fbDlyCir=0x%x\n",
 		snrRef, maxPowerMan, nCombDet, fbDlyCir);
 
-	//Carrier offset sub loop bandwidth
+	/* Carrier offset sub loop bandwidth */
 	ret = lgdt3306a_read_reg(state, 0x1061, &val);
 	val &= 0xF8;
 	if ((snrRef > 18) && (maxPowerMan > 0x68) && (nCombDet == 0x01) && ((fbDlyCir == 0x03FF) || (fbDlyCir < 0x6C)))	{
-		//SNR is over 18dB and no ghosting
-		val |= 0x00; //final bandwidth = 0
+		/* SNR is over 18dB and no ghosting */
+		val |= 0x00; /* final bandwidth = 0 */
 	} else {
-		val |= 0x04; //final bandwidth = 4
+		val |= 0x04; /* final bandwidth = 4 */
 	}
 	ret = lgdt3306a_write_reg(state, 0x1061, val);
 
-	// Adjust Notch Filter
+	/* Adjust Notch Filter */
 	ret = lgdt3306a_read_reg(state, 0x0024, &val);
 	val &= 0x0F;
-	if (nCombDet == 0){ // Turn on the Notch Filter
+	if (nCombDet == 0) { /* Turn on the Notch Filter */
 		val |= 0x50;
 	}
 	ret = lgdt3306a_write_reg(state, 0x0024, val);
 
-	//VSB Timing Recovery output normalization
+	/* VSB Timing Recovery output normalization */
 	ret = lgdt3306a_read_reg(state, 0x103D, &val);
 	val &= 0xCF;
 	val |= 0x20;
@@ -1077,21 +1086,21 @@ static LG3306_MODULATION lgdt3306a_check_oper_mode(struct lgdt3306a_state *state
 
 	if (val & 0x80)	{
 		lg_dbg("VSB\n");
-		return(LG3306_VSB);
+		return LG3306_VSB;
 	}
 	else if (val & 0x08) {
 		ret = lgdt3306a_read_reg(state, 0x00A6, &val);
 		val = val >> 2;
 		if (val & 0x01) {
 			lg_dbg("QAM256\n");
-			return(LG3306_QAM256);
+			return LG3306_QAM256;
 		} else {
 			lg_dbg("QAM64\n");
-			return(LG3306_QAM64);
+			return LG3306_QAM64;
 		}
 	}
 	lg_warn("UNKNOWN\n");
-	return(LG3306_UNKNOWN_MODE);
+	return LG3306_UNKNOWN_MODE;
 }
 
 static LG3306_LOCK_STATUS lgdt3306a_check_lock_status(struct lgdt3306a_state *state,
@@ -1104,76 +1113,71 @@ static LG3306_LOCK_STATUS lgdt3306a_check_lock_status(struct lgdt3306a_state *st
 
 	modeOper = LG3306_UNKNOWN_MODE;
 
-	switch (whatLock)
+	switch (whatLock) {
+	case LG3306_SYNC_LOCK:
+	{
+		ret = lgdt3306a_read_reg(state, 0x00A6, &val);
+
+		if ((val & 0x80) == 0x80)
+			lockStatus = LG3306_LOCK;
+		else
+			lockStatus = LG3306_UNLOCK;
+
+		lg_dbg("SYNC_LOCK=%x\n", lockStatus);
+		break;
+	}
+	case LG3306_AGC_LOCK:
+	{
+		ret = lgdt3306a_read_reg(state, 0x0080, &val);
+
+		if ((val & 0x40) == 0x40)
+			lockStatus = LG3306_LOCK;
+		else
+			lockStatus = LG3306_UNLOCK;
+
+		lg_dbg("AGC_LOCK=%x\n", lockStatus);
+		break;
+	}
+	case LG3306_TR_LOCK:
 	{
-		case LG3306_SYNC_LOCK :
-		{
-			ret = lgdt3306a_read_reg(state, 0x00A6, &val);
+		modeOper = lgdt3306a_check_oper_mode(state);
+		if ((modeOper == LG3306_QAM64) || (modeOper == LG3306_QAM256)) {
+			ret = lgdt3306a_read_reg(state, 0x1094, &val);
 
 			if ((val & 0x80) == 0x80)
 				lockStatus = LG3306_LOCK;
 			else
 				lockStatus = LG3306_UNLOCK;
+		} else
+			lockStatus = LG3306_UNKNOWN_LOCK;
 
-			lg_dbg("SYNC_LOCK=%x\n", lockStatus);
-			break;
-		}
-		case LG3306_AGC_LOCK :
-		{
+		lg_dbg("TR_LOCK=%x\n", lockStatus);
+		break;
+	}
+	case LG3306_FEC_LOCK:
+	{
+		modeOper = lgdt3306a_check_oper_mode(state);
+		if ((modeOper == LG3306_QAM64) || (modeOper == LG3306_QAM256)) {
 			ret = lgdt3306a_read_reg(state, 0x0080, &val);
 
-			if ((val & 0x40) == 0x40)
+			if ((val & 0x10) == 0x10)
 				lockStatus = LG3306_LOCK;
 			else
 				lockStatus = LG3306_UNLOCK;
+		} else
+			lockStatus = LG3306_UNKNOWN_LOCK;
 
-			lg_dbg("AGC_LOCK=%x\n", lockStatus);
-			break;
-		}
-		case LG3306_TR_LOCK :
-		{
-			modeOper = lgdt3306a_check_oper_mode(state);
-			if ((modeOper == LG3306_QAM64) || (modeOper == LG3306_QAM256))
-			{
-				ret = lgdt3306a_read_reg(state, 0x1094, &val);
-
-				if ((val & 0x80) == 0x80)
-					lockStatus = LG3306_LOCK;
-				else
-					lockStatus = LG3306_UNLOCK;
-			}
-			else
-				lockStatus = LG3306_UNKNOWN_LOCK;
-
-			lg_dbg("TR_LOCK=%x\n", lockStatus);
-			break;
-		}
-		case LG3306_FEC_LOCK :
-		{
-			modeOper = lgdt3306a_check_oper_mode(state);
-			if ((modeOper == LG3306_QAM64) || (modeOper == LG3306_QAM256))
-			{
-				ret = lgdt3306a_read_reg(state, 0x0080, &val);
-
-				if ((val & 0x10) == 0x10)
-					lockStatus = LG3306_LOCK;
-				else
-					lockStatus = LG3306_UNLOCK;
-			}
-			else
-				lockStatus = LG3306_UNKNOWN_LOCK;
-
-			lg_dbg("FEC_LOCK=%x\n", lockStatus);
-			break;
-		}
+		lg_dbg("FEC_LOCK=%x\n", lockStatus);
+		break;
+	}
 
-		default :
-			lockStatus = LG3306_UNKNOWN_LOCK;
-			lg_warn("UNKNOWN whatLock=%d\n", whatLock);
-			break;
+	default:
+		lockStatus = LG3306_UNKNOWN_LOCK;
+		lg_warn("UNKNOWN whatLock=%d\n", whatLock);
+		break;
 	}
 
-	return(lockStatus);
+	return lockStatus;
 }
 
 static LG3306_NEVERLOCK_STATUS lgdt3306a_check_neverlock_status(struct lgdt3306a_state *state)
@@ -1187,7 +1191,7 @@ static LG3306_NEVERLOCK_STATUS lgdt3306a_check_neverlock_status(struct lgdt3306a
 
 	lg_dbg("NeverLock=%d", lockStatus);
 
-	return(lockStatus);
+	return lockStatus;
 }
 
 static void lgdt3306a_pre_monitoring(struct lgdt3306a_state *state)
@@ -1196,14 +1200,14 @@ static void lgdt3306a_pre_monitoring(struct lgdt3306a_state *state)
 	int ret;
 	u8 currChDiffACQ, snrRef, mainStrong, aiccrejStatus;
 
-	//Channel variation
+	/* Channel variation */
 	ret = lgdt3306a_read_reg(state, 0x21BC, &currChDiffACQ);
 
-	//SNR of Frame sync
+	/* SNR of Frame sync */
 	ret = lgdt3306a_read_reg(state, 0x21A1, &val);
 	snrRef = val & 0x3F;
 
-	//Strong Main CIR
+	/* Strong Main CIR */
 	ret = lgdt3306a_read_reg(state, 0x2199, &val);
 	mainStrong = (val & 0x40) >> 6;
 
@@ -1213,9 +1217,10 @@ static void lgdt3306a_pre_monitoring(struct lgdt3306a_state *state)
 	lg_dbg("snrRef=%d mainStrong=%d aiccrejStatus=%d currChDiffACQ=0x%x\n",
 		snrRef, mainStrong, aiccrejStatus, currChDiffACQ);
 
-//	if ((mainStrong == 0) && (currChDiffACQ > 0x70)) //Dynamic ghost exists
-	if (mainStrong == 0)
-	{
+#if 0
+	if ((mainStrong == 0) && (currChDiffACQ > 0x70)) /* Dynamic ghost exists */
+#endif
+	if (mainStrong == 0) {
 		ret = lgdt3306a_read_reg(state, 0x2135, &val);
 		val &= 0x0F;
 		val |= 0xA0;
@@ -1227,9 +1232,7 @@ static void lgdt3306a_pre_monitoring(struct lgdt3306a_state *state)
 		ret = lgdt3306a_write_reg(state, 0x2141, val);
 
 		ret = lgdt3306a_write_reg(state, 0x2122, 0x70);
-	}
-	else // Weak ghost or static channel
-	{
+	} else { /* Weak ghost or static channel */
 		ret = lgdt3306a_read_reg(state, 0x2135, &val);
 		val &= 0x0F;
 		val |= 0x70;
@@ -1247,7 +1250,7 @@ static void lgdt3306a_pre_monitoring(struct lgdt3306a_state *state)
 
 static LG3306_LOCK_STATUS lgdt3306a_sync_lock_poll(struct lgdt3306a_state *state)
 {
-	LG3306_LOCK_STATUS 	syncLockStatus = LG3306_UNLOCK;
+	LG3306_LOCK_STATUS syncLockStatus = LG3306_UNLOCK;
 	int	i;
 
 	for (i = 0; i < 2; i++)	{
@@ -1257,11 +1260,11 @@ static LG3306_LOCK_STATUS lgdt3306a_sync_lock_poll(struct lgdt3306a_state *state
 
 		if (syncLockStatus == LG3306_LOCK) {
 			lg_dbg("locked(%d)\n", i);
-			return(LG3306_LOCK);
+			return LG3306_LOCK;
 		}
 	}
 	lg_dbg("not locked\n");
-	return(LG3306_UNLOCK);
+	return LG3306_UNLOCK;
 }
 
 static LG3306_LOCK_STATUS lgdt3306a_fec_lock_poll(struct lgdt3306a_state *state)
@@ -1276,11 +1279,11 @@ static LG3306_LOCK_STATUS lgdt3306a_fec_lock_poll(struct lgdt3306a_state *state)
 
 		if (FECLockStatus == LG3306_LOCK) {
 			lg_dbg("locked(%d)\n", i);
-			return(FECLockStatus);
+			return FECLockStatus;
 		}
 	}
 	lg_dbg("not locked\n");
-	return(FECLockStatus);
+	return FECLockStatus;
 }
 
 static LG3306_NEVERLOCK_STATUS lgdt3306a_neverlock_poll(struct lgdt3306a_state *state)
@@ -1288,18 +1291,18 @@ static LG3306_NEVERLOCK_STATUS lgdt3306a_neverlock_poll(struct lgdt3306a_state *
 	LG3306_NEVERLOCK_STATUS NLLockStatus = LG3306_NL_FAIL;
 	int	i;
 
-	for (i = 0; i < 5; i++){
+	for (i = 0; i < 5; i++) {
 		msleep(30);
 
 		NLLockStatus = lgdt3306a_check_neverlock_status(state);
 
 		if (NLLockStatus == LG3306_NL_LOCK) {
 			lg_dbg("NL_LOCK(%d)\n", i);
-			return(NLLockStatus);
+			return NLLockStatus;
 		}
 	}
 	lg_dbg("NLLockStatus=%d\n", NLLockStatus);
-	return(NLLockStatus);
+	return NLLockStatus;
 }
 
 static u8 lgdt3306a_get_packet_error(struct lgdt3306a_state *state)
@@ -1309,49 +1312,51 @@ static u8 lgdt3306a_get_packet_error(struct lgdt3306a_state *state)
 
 	ret = lgdt3306a_read_reg(state, 0x00FA, &val);
 
-	return(val);
+	return val;
 }
 
 static u32 log10_x1000(u32 x)
 {
-    static u32 valx_x10[]     = {  10,  11,  13,  15,  17,  20,  25,  33,  41,  50,  59,  73,  87,  100 };
-    static u32 log10x_x1000[] = {   0,  41, 114, 176, 230, 301, 398, 518, 613, 699, 771, 863, 939, 1000 };
-    static u32 nelems = sizeof(valx_x10)/sizeof(valx_x10[0]);
+	static u32 valx_x10[]     = {  10,  11,  13,  15,  17,  20,  25,  33,  41,  50,  59,  73,  87,  100 };
+	static u32 log10x_x1000[] = {   0,  41, 114, 176, 230, 301, 398, 518, 613, 699, 771, 863, 939, 1000 };
+	static u32 nelems = sizeof(valx_x10)/sizeof(valx_x10[0]);
 	u32 log_val = 0;
-    u32 i;
+	u32 i;
 
-    if (x<=0)
-		return -1000000;//signal error
+	if (x <= 0)
+		return -1000000; /* signal error */
 
-    if (x<10) {
-		while (x<10) {
-			x = x*10;
+	if (x < 10) {
+		while (x < 10) {
+			x = x * 10;
 			log_val--;
 		}
-	} else if (x==10) {
-		return 0; //log(1)=0
+	} else if (x == 10) {
+		return 0; /* log(1)=0 */
 	} else {
-		while (x>=100) {
-			x = x/10;
+		while (x >= 100) {
+			x = x / 10;
 			log_val++;
 		}
-    }
+	}
 	log_val *= 1000;
 
-    if (x==10) //was our input an exact multiple of 10
-	return log_val;	//don't need to interpolate
+	if (x == 10) /* was our input an exact multiple of 10 */
+		return log_val;	/* don't need to interpolate */
 
-    //find our place on the log curve
-    for (i=1; i < nelems; i++){
-		if (valx_x10[i] >= x) break;
+	/* find our place on the log curve */
+	for (i = 1; i < nelems; i++) {
+		if (valx_x10[i] >= x)
+			break;
 	}
 
 	{
 		u32 diff_val   = x - valx_x10[i-1];
 		u32 step_val   = valx_x10[i] - valx_x10[i-1];
 		u32 step_log10 = log10x_x1000[i] - log10x_x1000[i-1];
-		//do a linear interpolation to get in-between values
-		return log_val + log10x_x1000[i-1] + ((diff_val*step_log10)/step_val);
+		/* do a linear interpolation to get in-between values */
+		return log_val + log10x_x1000[i-1] +
+			((diff_val*step_log10) / step_val);
 	}
 }
 
@@ -1369,7 +1374,7 @@ static u32 lgdt3306a_calculate_snr_x100(struct lgdt3306a_state *state)
 	if (mse == 0) /* no signal */
 		return 0;
 
-	snr_x100 = log10_x1000((pwr*10000)/mse) - 3000;
+	snr_x100 = log10_x1000((pwr * 10000) / mse) - 3000;
 	lg_dbg("mse=%u, pwr=%u, snr_x100=%d\n", mse, pwr, snr_x100);
 
 	return snr_x100;
@@ -1377,35 +1382,35 @@ static u32 lgdt3306a_calculate_snr_x100(struct lgdt3306a_state *state)
 
 static LG3306_LOCK_STATUS lgdt3306a_vsb_lock_poll(struct lgdt3306a_state *state)
 {
-	u8 	cnt = 0;
-	u8  packet_error;
-	u32	snr;
+	u8 cnt = 0;
+	u8 packet_error;
+	u32 snr;
 
-	while(1) {
+	while (1) {
 		if (lgdt3306a_sync_lock_poll(state) == LG3306_UNLOCK) {
 			lg_dbg("no sync lock!\n");
-			return(LG3306_UNLOCK);
+			return LG3306_UNLOCK;
 		} else {
 			msleep(20);
 			lgdt3306a_pre_monitoring(state);
 
 			packet_error = lgdt3306a_get_packet_error(state);
 			snr = lgdt3306a_calculate_snr_x100(state);
-			lg_dbg("cnt=%d errors=%d snr=%d\n", cnt, packet_error, snr);
+			lg_dbg("cnt=%d errors=%d snr=%d\n",
+			       cnt, packet_error, snr);
 
-			if((snr < 1500) || (packet_error >= 0xff)) {
+			if ((snr < 1500) || (packet_error >= 0xff))
 				cnt++;
-			} else {
-				return(LG3306_LOCK);
-			}
+			else
+				return LG3306_LOCK;
 
-			if(cnt >= 10) {
+			if (cnt >= 10) {
 				lg_dbg("not locked!\n");
-				return(LG3306_UNLOCK);
+				return LG3306_UNLOCK;
 			}
 		}
 	}
-	return(LG3306_UNLOCK);
+	return LG3306_UNLOCK;
 }
 
 static LG3306_LOCK_STATUS lgdt3306a_qam_lock_poll(struct lgdt3306a_state *state)
@@ -1414,41 +1419,41 @@ static LG3306_LOCK_STATUS lgdt3306a_qam_lock_poll(struct lgdt3306a_state *state)
 	u8 packet_error;
 	u32	snr;
 
-	while(1) {
-		if(lgdt3306a_fec_lock_poll(state) == LG3306_UNLOCK) {
+	while (1) {
+		if (lgdt3306a_fec_lock_poll(state) == LG3306_UNLOCK) {
 			lg_dbg("no fec lock!\n");
-			return(LG3306_UNLOCK);
+			return LG3306_UNLOCK;
 		} else {
 			msleep(20);
 
 			packet_error = lgdt3306a_get_packet_error(state);
 			snr = lgdt3306a_calculate_snr_x100(state);
-			lg_dbg("cnt=%d errors=%d snr=%d\n", cnt, packet_error, snr);
+			lg_dbg("cnt=%d errors=%d snr=%d\n",
+			       cnt, packet_error, snr);
 
-			if((snr < 1500) || (packet_error >= 0xff)) {
+			if ((snr < 1500) || (packet_error >= 0xff))
 				cnt++;
-			} else 	{
-				return(LG3306_LOCK);
-			}
+			else
+				return LG3306_LOCK;
 
-			if(cnt >= 10) {
+			if (cnt >= 10) {
 				lg_dbg("not locked!\n");
-				return(LG3306_UNLOCK);
+				return LG3306_UNLOCK;
 			}
 		}
 	}
-	return(LG3306_UNLOCK);
+	return LG3306_UNLOCK;
 }
 
 static int lgdt3306a_read_status(struct dvb_frontend *fe, fe_status_t *status)
 {
-	int ret = 0;
 	struct lgdt3306a_state *state = fe->demodulator_priv;
-
 	u16 strength = 0;
+	int ret = 0;
+
 	if (fe->ops.tuner_ops.get_rf_strength) {
 		ret = fe->ops.tuner_ops.get_rf_strength(fe, &strength);
-		if (ret==0) {
+		if (ret == 0) {
 			lg_dbg("strength=%d\n", strength);
 		} else {
 			lg_dbg("fe->ops.tuner_ops.get_rf_strength() failed\n");
@@ -1456,14 +1461,14 @@ static int lgdt3306a_read_status(struct dvb_frontend *fe, fe_status_t *status)
 	}
 
 	*status = 0;
-	if(lgdt3306a_neverlock_poll(state) == LG3306_NL_LOCK) {
+	if (lgdt3306a_neverlock_poll(state) == LG3306_NL_LOCK) {
 		*status |= FE_HAS_SIGNAL;
 		*status |= FE_HAS_CARRIER;
 
 		switch (state->current_modulation) {
 		case QAM_256:
 		case QAM_64:
-			if(lgdt3306a_qam_lock_poll(state) == LG3306_LOCK){
+			if (lgdt3306a_qam_lock_poll(state) == LG3306_LOCK) {
 				*status |= FE_HAS_VITERBI;
 				*status |= FE_HAS_SYNC;
 
@@ -1471,7 +1476,7 @@ static int lgdt3306a_read_status(struct dvb_frontend *fe, fe_status_t *status)
 			}
 			break;
 		case VSB_8:
-			if(lgdt3306a_vsb_lock_poll(state) == LG3306_LOCK){
+			if (lgdt3306a_vsb_lock_poll(state) == LG3306_LOCK) {
 				*status |= FE_HAS_VITERBI;
 				*status |= FE_HAS_SYNC;
 
@@ -1506,22 +1511,22 @@ static int lgdt3306a_read_signal_strength(struct dvb_frontend *fe,
 	 * Calculate some sort of "strength" from SNR
 	 */
 	struct lgdt3306a_state *state = fe->demodulator_priv;
-	u16 snr;  //snr_x10
+	u16 snr;  /* snr_x10 */
 	int ret;
-	u32 ref_snr; //snr*100
+	u32 ref_snr; /* snr*100 */
 	u32 str;
 
 	*strength = 0;
 
 	switch (state->current_modulation) {
 	case VSB_8:
-		 ref_snr = 1600; //16dB
+		 ref_snr = 1600; /* 16dB */
 		 break;
 	case QAM_64:
-		 ref_snr = 2200; //22dB
+		 ref_snr = 2200; /* 22dB */
 		 break;
 	case QAM_256:
-		 ref_snr = 2800; //28dB
+		 ref_snr = 2800; /* 28dB */
 		 break;
 	default:
 		return -EINVAL;
@@ -1531,15 +1536,15 @@ static int lgdt3306a_read_signal_strength(struct dvb_frontend *fe,
 	if (lg_chkerr(ret))
 		goto fail;
 
-	if(state->snr <= (ref_snr-100))
+	if (state->snr <= (ref_snr - 100))
 		str = 0;
-	else if(state->snr <= ref_snr)
-		str = (0xffff*65) / 100; //65%
+	else if (state->snr <= ref_snr)
+		str = (0xffff * 65) / 100; /* 65% */
 	else {
 		str = state->snr - ref_snr;
 		str /= 50;
-		str += 78; //78%-100%
-		if(str > 100)
+		str += 78; /* 78%-100% */
+		if (str > 100)
 			str = 100;
 		str = (0xffff * str) / 100;
 	}
@@ -1559,12 +1564,12 @@ static int lgdt3306a_read_ber(struct dvb_frontend *fe, u32 *ber)
 
 	*ber = 0;
 #if 1
-	//FGR - BUGBUG - I don't know what value is expected by dvb_core
-	// what is the scale of the value??
-	tmp =            read_reg(state, 0x00FC);//NBERVALUE[24-31]
-	tmp = (tmp<<8) | read_reg(state, 0x00FD);//NBERVALUE[16-23]
-	tmp = (tmp<<8) | read_reg(state, 0x00FE);//NBERVALUE[8-15]
-	tmp = (tmp<<8) | read_reg(state, 0x00FF);//NBERVALUE[0-7]
+	/* FGR - BUGBUG - I don't know what value is expected by dvb_core
+	 * what is the scale of the value?? */
+	tmp =              read_reg(state, 0x00FC); /* NBERVALUE[24-31] */
+	tmp = (tmp << 8) | read_reg(state, 0x00FD); /* NBERVALUE[16-23] */
+	tmp = (tmp << 8) | read_reg(state, 0x00FE); /* NBERVALUE[8-15] */
+	tmp = (tmp << 8) | read_reg(state, 0x00FF); /* NBERVALUE[0-7] */
 	*ber = tmp;
 	lg_dbg("ber=%u\n", tmp);
 #endif
@@ -1575,11 +1580,11 @@ static int lgdt3306a_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)
 {
 	struct lgdt3306a_state *state = fe->demodulator_priv;
 
-	*ucblocks =	0;
+	*ucblocks = 0;
 #if 1
-	//FGR - BUGBUG - I don't know what value is expected by dvb_core
-	// what happens when value wraps?
-	*ucblocks = read_reg(state, 0x00F4);//TPIFTPERRCNT[0-7]
+	/* FGR - BUGBUG - I don't know what value is expected by dvb_core
+	 * what happens when value wraps? */
+	*ucblocks = read_reg(state, 0x00F4); /* TPIFTPERRCNT[0-7] */
 	lg_dbg("ucblocks=%u\n", *ucblocks);
 #endif
 
@@ -1594,10 +1599,9 @@ static int lgdt3306a_tune(struct dvb_frontend *fe, bool re_tune, unsigned int mo
 	lg_dbg("re_tune=%u\n", re_tune);
 
 	if (re_tune) {
-		state->current_frequency = -1; //force re-tune
-		if ((ret = lgdt3306a_set_parameters(fe)) != 0) {
+		state->current_frequency = -1; /* force re-tune */
+		if ((ret = lgdt3306a_set_parameters(fe)) != 0)
 			return ret;
-		}
 	}
 	*delay = 125;
 	ret = lgdt3306a_read_status(fe, status);
@@ -1606,8 +1610,8 @@ static int lgdt3306a_tune(struct dvb_frontend *fe, bool re_tune, unsigned int mo
 }
 
 static int lgdt3306a_get_tune_settings(struct dvb_frontend *fe,
-				      struct dvb_frontend_tune_settings
-					*fe_tune_settings)
+				       struct dvb_frontend_tune_settings
+				       *fe_tune_settings)
 {
 	fe_tune_settings->min_delay_ms = 100;
 	lg_dbg("\n");
@@ -1637,11 +1641,10 @@ static int lgdt3306a_search(struct dvb_frontend *fe)
 	}
 
 	/* check if we have a valid signal */
-	if (status & FE_HAS_LOCK) {
+	if (status & FE_HAS_LOCK)
 		return DVBFE_ALGO_SEARCH_SUCCESS;
-	} else {
+	else
 		return DVBFE_ALGO_SEARCH_AGAIN;
-	}
 
 error:
 	lg_dbg("failed (%d)\n", ret);
@@ -1651,6 +1654,7 @@ static int lgdt3306a_search(struct dvb_frontend *fe)
 static void lgdt3306a_release(struct dvb_frontend *fe)
 {
 	struct lgdt3306a_state *state = fe->demodulator_priv;
+
 	lg_dbg("\n");
 	kfree(state);
 }
@@ -1680,28 +1684,34 @@ struct dvb_frontend *lgdt3306a_attach(const struct lgdt3306a_config *config,
 	state->frontend.demodulator_priv = state;
 
 	/* verify that we're talking to a lg3306a */
-	//FGR - NOTE - there is no obvious ChipId to check; we check
-	//  some "known" bits after reset, but it's still just a guess
+	/* FGR - NOTE - there is no obvious ChipId to check; we check
+	 * some "known" bits after reset, but it's still just a guess */
 	ret = lgdt3306a_read_reg(state, 0x0000, &val);
 	if (lg_chkerr(ret))
 		goto fail;
-	if((val & 0x74) != 0x74){
+	if ((val & 0x74) != 0x74) {
 		lg_warn("expected 0x74, got 0x%x\n", (val & 0x74));
-//	  	goto fail;	//BUGBUG - re-enable when we know this is right
+#if 0
+		goto fail;	/* BUGBUG - re-enable when we know this is right */
+#endif
 	}
 	ret = lgdt3306a_read_reg(state, 0x0001, &val);
 	if (lg_chkerr(ret))
 		goto fail;
-	if((val & 0xF6) != 0xC6){
+	if ((val & 0xF6) != 0xC6) {
 		lg_warn("expected 0xC6, got 0x%x\n", (val & 0xF6));
-//	  	goto fail;	//BUGBUG - re-enable when we know this is right
+#if 0
+		goto fail;	/* BUGBUG - re-enable when we know this is right */
+#endif
 	}
 	ret = lgdt3306a_read_reg(state, 0x0002, &val);
 	if (lg_chkerr(ret))
 		goto fail;
-	if((val & 0x73) != 0x03){
+	if ((val & 0x73) != 0x03) {
 		lg_warn("expected 0x03, got 0x%x\n", (val & 0x73));
-//	  	goto fail;	//BUGBUG - re-enable when we know this is right
+#if 0
+		goto fail;	/* BUGBUG - re-enable when we know this is right */
+#endif
 	}
 
 	state->current_frequency = -1;
@@ -1961,22 +1971,23 @@ static void lgdt3306a_DumpRegs(struct lgdt3306a_state *state)
 {
 	int i;
 	int sav_debug = debug;
+
 	if ((debug & DBG_DUMP) == 0)
 		return;
-	debug &= ~DBG_REG;//supress DBG_REG during reg dump
+	debug &= ~DBG_REG; /* supress DBG_REG during reg dump */
 
 	lg_info("\n");
 
-	for(i=0; i<numDumpRegs; i++){
+	for (i = 0; i < numDumpRegs; i++) {
 		lgdt3306a_read_reg(state, regtab[i], &regval1[i]);
-		if(regval1[i] != regval2[i]){
-		lg_info(" %04X = %02X\n", regtab[i], regval1[i]);
-			regval2[i] = regval1[i];
+		if (regval1[i] != regval2[i]) {
+			lg_info(" %04X = %02X\n", regtab[i], regval1[i]);
+				regval2[i] = regval1[i];
 		}
 	}
 	debug = sav_debug;
 }
-#endif//DBG_DUMP
+#endif /* DBG_DUMP */
 
 
 
@@ -1986,10 +1997,11 @@ static struct dvb_frontend_ops lgdt3306a_ops = {
 	.delsys = { SYS_ATSC, SYS_DVBC_ANNEX_B },
 	.info = {
 		.name = "LG Electronics LGDT3306A VSB/QAM Frontend",
-//		.type               = FE_ATSC,
+#if 0
+		.type               = FE_ATSC,
+#endif
 		.frequency_min      = 54000000,
-		.frequency_max      = 858000000, //FGR - BUGBUG - why does the demod have a freq limit??
-										 //  also, it's too high for ATSC Ch 52, and too low for Ch 158 Cable
+		.frequency_max      = 858000000,
 		.frequency_stepsize = 62500,
 		.caps = FE_CAN_QAM_64 | FE_CAN_QAM_256 | FE_CAN_8VSB
 	},

commit b63b36fa44d0225de994a535307f941ca87fa908
Author: Fred Richter <frichter@hauppauge.com>
Date:   Mon Mar 24 19:56:00 2014 -0300

    [media] DVB: add support for LG Electronics LGDT3306A ATSC/QAM-B Demodulator
    
    This ATSC/QAM-B demodulator is used by several new devices.
    
    Add support for it. Other patches will fix CodingStyle issues.
    
    Signed-off-by: Fred Richter <frichter@hauppauge.com>
    Signed-off-by: Michael Ira Krufky <mkrufky@linuxtv.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/dvb-frontends/lgdt3306a.c b/drivers/media/dvb-frontends/lgdt3306a.c
new file mode 100644
index 000000000000..c6597b487fd0
--- /dev/null
+++ b/drivers/media/dvb-frontends/lgdt3306a.c
@@ -0,0 +1,2024 @@
+/*
+ *    Support for LGDT3306A - 8VSB/QAM-B
+ *
+ *    Copyright (C) 2013 Fred Richter <frichter@hauppauge.com>
+ *    - driver structure based on lgdt3305.[ch] by Michael Krufky
+ *    - code based on LG3306_V0.35 API by LG Electronics Inc.
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License
+ *    along with this program; if not, write to the Free Software
+ *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#include <asm/div64.h>
+#include <linux/dvb/frontend.h>
+#include "dvb_math.h"
+#include "lgdt3306a.h"
+
+
+static int debug;
+module_param(debug, int, 0644);
+MODULE_PARM_DESC(debug, "set debug level (info=1, reg=2 (or-able))");
+
+#define DBG_INFO 1
+#define DBG_REG  2
+#define DBG_DUMP 4 //FGR - comment out to remove dump code
+
+#define lg_printk(kern, fmt, arg...)					\
+	printk(kern "%s(): " fmt, __func__, ##arg)
+
+#define lg_info(fmt, arg...)	printk(KERN_INFO "lgdt3306a: " fmt, ##arg)
+#define lg_warn(fmt, arg...)	lg_printk(KERN_WARNING,       fmt, ##arg)
+#define lg_err(fmt, arg...)	lg_printk(KERN_ERR,           fmt, ##arg)
+#define lg_dbg(fmt, arg...) if (debug & DBG_INFO)			\
+				lg_printk(KERN_DEBUG,         fmt, ##arg)
+#define lg_reg(fmt, arg...) if (debug & DBG_REG)			\
+				lg_printk(KERN_DEBUG,         fmt, ##arg)
+
+#define lg_chkerr(ret)							\
+({									\
+	int __ret;							\
+	__ret = (ret < 0);						\
+	if (__ret)							\
+		lg_err("error %d on line %d\n",	ret, __LINE__);		\
+	__ret;								\
+})
+
+struct lgdt3306a_state {
+	struct i2c_adapter *i2c_adap;
+	const struct lgdt3306a_config *cfg;
+
+	struct dvb_frontend frontend;
+
+	fe_modulation_t current_modulation;
+	u32 current_frequency;
+	u32 snr;
+};
+
+/* -----------------------------------------------
+ LG3306A Register Usage
+   (LG does not really name the registers, so this code does not either)
+ 0000 -> 00FF Common control and status
+ 1000 -> 10FF Synchronizer control and status
+ 1F00 -> 1FFF Smart Antenna control and status
+ 2100 -> 21FF VSB Equalizer control and status
+ 2800 -> 28FF QAM Equalizer control and status
+ 3000 -> 30FF FEC control and status
+ ---------------------------------------------- */
+
+typedef enum{
+	LG3306_UNLOCK	    = 0x00,
+	LG3306_LOCK	        = 0x01,
+	LG3306_UNKNOWN_LOCK	= 0xFF
+}LG3306_LOCK_STATUS;
+
+typedef enum{
+	LG3306_NL_INIT    = 0x00,
+	LG3306_NL_PROCESS = 0x01,
+	LG3306_NL_LOCK    = 0x02,
+	LG3306_NL_FAIL    = 0x03,
+	LG3306_NL_UNKNOWN = 0xFF
+}LG3306_NEVERLOCK_STATUS;
+
+typedef enum{
+	LG3306_VSB	        = 0x00,
+	LG3306_QAM64	    = 0x01,
+	LG3306_QAM256	    = 0x02,
+	LG3306_UNKNOWN_MODE	= 0xFF
+}LG3306_MODULATION;
+
+typedef enum
+{
+	LG3306_SYNC_LOCK,
+	LG3306_FEC_LOCK,
+	LG3306_TR_LOCK,
+	LG3306_AGC_LOCK,
+} LG3306_LOCK_CHECK;
+
+
+#ifdef DBG_DUMP
+static void lgdt3306a_DumpAllRegs(struct lgdt3306a_state *state);
+static void lgdt3306a_DumpRegs(struct lgdt3306a_state *state);
+#endif
+
+
+static int lgdt3306a_write_reg(struct lgdt3306a_state *state, u16 reg, u8 val)
+{
+	int ret;
+	u8 buf[] = { reg >> 8, reg & 0xff, val };
+	struct i2c_msg msg = {
+		.addr = state->cfg->i2c_addr, .flags = 0,
+		.buf = buf, .len = 3,
+	};
+
+	lg_reg("reg: 0x%04x, val: 0x%02x\n", reg, val);
+
+	ret = i2c_transfer(state->i2c_adap, &msg, 1);
+
+	if (ret != 1) {
+		lg_err("error (addr %02x %02x <- %02x, err = %i)\n",
+		       msg.buf[0], msg.buf[1], msg.buf[2], ret);
+		if (ret < 0)
+			return ret;
+		else
+			return -EREMOTEIO;
+	}
+	return 0;
+}
+
+static int lgdt3306a_read_reg(struct lgdt3306a_state *state, u16 reg, u8 *val)
+{
+	int ret;
+	u8 reg_buf[] = { reg >> 8, reg & 0xff };
+	struct i2c_msg msg[] = {
+		{ .addr = state->cfg->i2c_addr,
+		  .flags = 0, .buf = reg_buf, .len = 2 },
+		{ .addr = state->cfg->i2c_addr,
+		  .flags = I2C_M_RD, .buf = val, .len = 1 },
+	};
+
+	ret = i2c_transfer(state->i2c_adap, msg, 2);
+
+	if (ret != 2) {
+		lg_err("error (addr %02x reg %04x error (ret == %i)\n",
+		       state->cfg->i2c_addr, reg, ret);
+		if (ret < 0)
+			return ret;
+		else
+			return -EREMOTEIO;
+	}
+	lg_reg("reg: 0x%04x, val: 0x%02x\n", reg, *val);
+
+	return 0;
+}
+
+#define read_reg(state, reg)						\
+({									\
+	u8 __val;							\
+	int ret = lgdt3306a_read_reg(state, reg, &__val);		\
+	if (lg_chkerr(ret))						\
+		__val = 0;						\
+	__val;								\
+})
+
+static int lgdt3306a_set_reg_bit(struct lgdt3306a_state *state,
+				u16 reg, int bit, int onoff)
+{
+	u8 val;
+	int ret;
+
+	lg_reg("reg: 0x%04x, bit: %d, level: %d\n", reg, bit, onoff);
+
+	ret = lgdt3306a_read_reg(state, reg, &val);
+	if (lg_chkerr(ret))
+		goto fail;
+
+	val &= ~(1 << bit);
+	val |= (onoff & 1) << bit;
+
+	ret = lgdt3306a_write_reg(state, reg, val);
+	lg_chkerr(ret);
+fail:
+	return ret;
+}
+
+/* ------------------------------------------------------------------------ */
+
+static int lgdt3306a_soft_reset(struct lgdt3306a_state *state)
+{
+	int ret;
+
+	lg_dbg("\n");
+
+	ret = lgdt3306a_set_reg_bit(state, 0x0000, 7, 0);
+	if (lg_chkerr(ret))
+		goto fail;
+
+	msleep(20);
+	ret = lgdt3306a_set_reg_bit(state, 0x0000, 7, 1);
+	lg_chkerr(ret);
+
+fail:
+	return ret;
+}
+
+static int lgdt3306a_mpeg_mode(struct lgdt3306a_state *state,
+				     enum lgdt3306a_mpeg_mode mode)
+{
+	u8 val;
+	int ret;
+
+	lg_dbg("(%d)\n", mode);
+	//transport packet format
+	ret = lgdt3306a_set_reg_bit(state, 0x0071, 7, mode==LGDT3306A_MPEG_PARALLEL?1:0); //TPSENB=0x80
+	if (lg_chkerr(ret))
+		goto fail;
+
+	//start of packet signal duration
+	ret = lgdt3306a_set_reg_bit(state, 0x0071, 6, 0); //TPSSOPBITEN=0x40; 0=byte duration, 1=bit duration
+	if (lg_chkerr(ret))
+		goto fail;
+
+	ret = lgdt3306a_read_reg(state, 0x0070, &val);
+	if (lg_chkerr(ret))
+		goto fail;
+
+	val |= 0x10;//TPCLKSUPB=0x10
+
+	if (mode==LGDT3306A_MPEG_PARALLEL)
+		val &= ~0x10;
+
+	ret = lgdt3306a_write_reg(state, 0x0070, val);
+	lg_chkerr(ret);
+
+fail:
+	return ret;
+}
+
+static int lgdt3306a_mpeg_mode_polarity(struct lgdt3306a_state *state,
+				       enum lgdt3306a_tp_clock_edge edge,
+				       enum lgdt3306a_tp_valid_polarity valid)
+{
+	u8 val;
+	int ret;
+
+	lg_dbg("edge=%d, valid=%d\n", edge, valid);
+
+	ret = lgdt3306a_read_reg(state, 0x0070, &val);
+	if (lg_chkerr(ret))
+		goto fail;
+
+	val &= ~0x06;//TPCLKPOL=0x04, TPVALPOL=0x02
+
+	if (edge==LGDT3306A_TPCLK_RISING_EDGE)
+		val |= 0x04;
+	if (valid==LGDT3306A_TP_VALID_HIGH)
+		val |= 0x02;
+
+	ret = lgdt3306a_write_reg(state, 0x0070, val);
+	lg_chkerr(ret);
+
+fail:
+	return ret;
+}
+
+static int lgdt3306a_mpeg_tristate(struct lgdt3306a_state *state,
+				     int mode)
+{
+	u8 val;
+	int ret;
+
+	lg_dbg("(%d)\n", mode);
+
+	if(mode){
+		ret = lgdt3306a_read_reg(state, 0x0070, &val);
+		if (lg_chkerr(ret))
+			goto fail;
+		val &= ~0xA8; //Tristate bus; TPOUTEN=0x80, TPCLKOUTEN=0x20, TPDATAOUTEN=0x08
+		ret = lgdt3306a_write_reg(state, 0x0070, val);
+		if (lg_chkerr(ret))
+			goto fail;
+
+		ret = lgdt3306a_set_reg_bit(state, 0x0003, 6, 1);//AGCIFOUTENB=0x40; 1=Disable IFAGC pin
+		if (lg_chkerr(ret))
+			goto fail;
+
+	} else {
+		ret = lgdt3306a_set_reg_bit(state, 0x0003, 6, 0);//enable IFAGC pin
+		if (lg_chkerr(ret))
+			goto fail;
+
+		ret = lgdt3306a_read_reg(state, 0x0070, &val);
+		if (lg_chkerr(ret))
+			goto fail;
+
+		val |= 0xA8; //Enable bus
+		ret = lgdt3306a_write_reg(state, 0x0070, val);
+		if (lg_chkerr(ret))
+			goto fail;
+	}
+
+fail:
+	return ret;
+}
+
+static int lgdt3306a_ts_bus_ctrl(struct dvb_frontend* fe, int acquire)
+{
+	struct lgdt3306a_state *state = fe->demodulator_priv;
+
+	lg_dbg("acquire=%d\n", acquire);
+
+	return lgdt3306a_mpeg_tristate(state, acquire ? 0 : 1);
+
+}
+
+static int lgdt3306a_power(struct lgdt3306a_state *state,
+				     int mode)
+{
+	int ret;
+
+	lg_dbg("(%d)\n", mode);
+
+	if(mode == 0){
+		ret = lgdt3306a_set_reg_bit(state, 0x0000, 7, 0); //into reset
+		if (lg_chkerr(ret))
+			goto fail;
+
+		ret = lgdt3306a_set_reg_bit(state, 0x0000, 0, 0); //power down
+		if (lg_chkerr(ret))
+			goto fail;
+
+	} else {
+		ret = lgdt3306a_set_reg_bit(state, 0x0000, 7, 1); //out of reset
+		if (lg_chkerr(ret))
+			goto fail;
+
+		ret = lgdt3306a_set_reg_bit(state, 0x0000, 0, 1); //power up
+		if (lg_chkerr(ret))
+			goto fail;
+	}
+
+#ifdef DBG_DUMP
+	lgdt3306a_DumpAllRegs(state);
+#endif
+fail:
+	return ret;
+}
+
+
+static int lgdt3306a_set_vsb(struct lgdt3306a_state *state)
+{
+	u8 val;
+	int ret;
+
+	lg_dbg("\n");
+
+	// 0. Spectrum inversion detection manual; spectrum inverted
+	ret = lgdt3306a_read_reg(state, 0x0002, &val);
+	val &= 0xF7; //SPECINVAUTO Off
+	val |= 0x04; //SPECINV On
+	ret = lgdt3306a_write_reg(state, 0x0002, val);
+	if (lg_chkerr(ret))
+		goto fail;
+
+	// 1. Selection of standard mode(0x08=QAM, 0x80=VSB)
+	ret = lgdt3306a_write_reg(state, 0x0008, 0x80);
+	if (lg_chkerr(ret))
+		goto fail;
+
+	// 2. Bandwidth mode for VSB(6MHz)
+	ret = lgdt3306a_read_reg(state, 0x0009, &val);
+	val &= 0xE3;
+	val |= 0x0C; //STDOPDETTMODE[2:0]=3
+	ret = lgdt3306a_write_reg(state, 0x0009, val);
+	if (lg_chkerr(ret))
+		goto fail;
+
+	// 3. QAM mode detection mode(None)
+	ret = lgdt3306a_read_reg(state, 0x0009, &val);
+	val &= 0xFC; //STDOPDETCMODE[1:0]=0
+	ret = lgdt3306a_write_reg(state, 0x0009, val);
+	if (lg_chkerr(ret))
+		goto fail;
+
+	// 4. ADC sampling frequency rate(2x sampling)
+	ret = lgdt3306a_read_reg(state, 0x000D, &val);
+	val &= 0xBF; //SAMPLING4XFEN=0
+	ret = lgdt3306a_write_reg(state, 0x000D, val);
+	if (lg_chkerr(ret))
+		goto fail;
+
+#if 0 //FGR - disable any AICC filtering, testing only
+	ret = lgdt3306a_write_reg(state, 0x0024, 0x00);
+	if (lg_chkerr(ret))
+		goto fail;
+
+	//AICCFIXFREQ0 NT N-1(Video rejection)
+	ret = lgdt3306a_write_reg(state, 0x002E, 0x00);
+	ret = lgdt3306a_write_reg(state, 0x002F, 0x00);
+	ret = lgdt3306a_write_reg(state, 0x0030, 0x00);
+
+	//AICCFIXFREQ1 NT N-1(Audio rejection)
+	ret = lgdt3306a_write_reg(state, 0x002B, 0x00);
+	ret = lgdt3306a_write_reg(state, 0x002C, 0x00);
+	ret = lgdt3306a_write_reg(state, 0x002D, 0x00);
+
+	//AICCFIXFREQ2 NT Co-Channel(Video rejection)
+	ret = lgdt3306a_write_reg(state, 0x0028, 0x00);
+	ret = lgdt3306a_write_reg(state, 0x0029, 0x00);
+	ret = lgdt3306a_write_reg(state, 0x002A, 0x00);
+
+	//AICCFIXFREQ3 NT Co-Channel(Audio rejection)
+	ret = lgdt3306a_write_reg(state, 0x0025, 0x00);
+	ret = lgdt3306a_write_reg(state, 0x0026, 0x00);
+	ret = lgdt3306a_write_reg(state, 0x0027, 0x00);
+
+#else //FGR - this works well for HVR-1955,1975
+	// 5. AICCOPMODE  NT N-1 Adj.
+	ret = lgdt3306a_write_reg(state, 0x0024, 0x5A);
+	if (lg_chkerr(ret))
+		goto fail;
+
+	//AICCFIXFREQ0 NT N-1(Video rejection)
+	ret = lgdt3306a_write_reg(state, 0x002E, 0x5A);
+	ret = lgdt3306a_write_reg(state, 0x002F, 0x00);
+	ret = lgdt3306a_write_reg(state, 0x0030, 0x00);
+
+	//AICCFIXFREQ1 NT N-1(Audio rejection)
+	ret = lgdt3306a_write_reg(state, 0x002B, 0x36);
+	ret = lgdt3306a_write_reg(state, 0x002C, 0x00);
+	ret = lgdt3306a_write_reg(state, 0x002D, 0x00);
+
+	//AICCFIXFREQ2 NT Co-Channel(Video rejection)
+	ret = lgdt3306a_write_reg(state, 0x0028, 0x2A);
+	ret = lgdt3306a_write_reg(state, 0x0029, 0x00);
+	ret = lgdt3306a_write_reg(state, 0x002A, 0x00);
+
+	//AICCFIXFREQ3 NT Co-Channel(Audio rejection)
+	ret = lgdt3306a_write_reg(state, 0x0025, 0x06);
+	ret = lgdt3306a_write_reg(state, 0x0026, 0x00);
+	ret = lgdt3306a_write_reg(state, 0x0027, 0x00);
+#endif
+
+	ret = lgdt3306a_read_reg(state, 0x001E, &val);
+	val &= 0x0F;
+	val |= 0xA0;
+	ret = lgdt3306a_write_reg(state, 0x001E, val);
+
+	ret = lgdt3306a_write_reg(state, 0x0022, 0x08);
+
+	ret = lgdt3306a_write_reg(state, 0x0023, 0xFF);
+
+	ret = lgdt3306a_read_reg(state, 0x211F, &val);
+	val &= 0xEF;
+	ret = lgdt3306a_write_reg(state, 0x211F, val);
+
+	ret = lgdt3306a_write_reg(state, 0x2173, 0x01);
+
+	ret = lgdt3306a_read_reg(state, 0x1061, &val);
+	val &= 0xF8;
+	val |= 0x04;
+	ret = lgdt3306a_write_reg(state, 0x1061, val);
+
+	ret = lgdt3306a_read_reg(state, 0x103D, &val);
+	val &= 0xCF;
+	ret = lgdt3306a_write_reg(state, 0x103D, val);
+
+	ret = lgdt3306a_write_reg(state, 0x2122, 0x40);
+
+	ret = lgdt3306a_read_reg(state, 0x2141, &val);
+	val &= 0x3F;
+	ret = lgdt3306a_write_reg(state, 0x2141, val);
+
+	ret = lgdt3306a_read_reg(state, 0x2135, &val);
+	val &= 0x0F;
+	val |= 0x70;
+	ret = lgdt3306a_write_reg(state, 0x2135, val);
+
+	ret = lgdt3306a_read_reg(state, 0x0003, &val);
+	val &= 0xF7;
+	ret = lgdt3306a_write_reg(state, 0x0003, val);
+
+	ret = lgdt3306a_read_reg(state, 0x001C, &val);
+	val &= 0x7F;
+	ret = lgdt3306a_write_reg(state, 0x001C, val);
+
+	// 6. EQ step size
+	ret = lgdt3306a_read_reg(state, 0x2179, &val);
+	val &= 0xF8;
+	ret = lgdt3306a_write_reg(state, 0x2179, val);
+
+	ret = lgdt3306a_read_reg(state, 0x217A, &val);
+	val &= 0xF8;
+	ret = lgdt3306a_write_reg(state, 0x217A, val);
+
+	// 7. Reset
+	ret = lgdt3306a_soft_reset(state);
+	if (lg_chkerr(ret))
+		goto fail;
+
+	lg_dbg("complete\n");
+fail:
+	return ret;
+}
+
+static int lgdt3306a_set_qam(struct lgdt3306a_state *state, int modulation)
+{
+	u8 val;
+	int ret;
+
+	lg_dbg("modulation=%d\n", modulation);
+
+	// 1. Selection of standard mode(0x08=QAM, 0x80=VSB)
+	ret = lgdt3306a_write_reg(state, 0x0008, 0x08);
+	if (lg_chkerr(ret))
+		goto fail;
+
+	// 1a. Spectrum inversion detection to Auto
+	ret = lgdt3306a_read_reg(state, 0x0002, &val);
+	val &= 0xFB; //SPECINV Off
+	val |= 0x08; //SPECINVAUTO On
+	ret = lgdt3306a_write_reg(state, 0x0002, val);
+	if (lg_chkerr(ret))
+		goto fail;
+
+	// 2. Bandwidth mode for QAM
+	ret = lgdt3306a_read_reg(state, 0x0009, &val);
+	val &= 0xE3; //STDOPDETTMODE[2:0]=0	VSB Off
+	ret = lgdt3306a_write_reg(state, 0x0009, val);
+	if (lg_chkerr(ret))
+		goto fail;
+
+	// 3. : 64QAM/256QAM detection(manual, auto)
+	ret = lgdt3306a_read_reg(state, 0x0009, &val);
+	val &= 0xFC;
+	val |= 0x02; //STDOPDETCMODE[1:0]=1=Manual 2=Auto
+	ret = lgdt3306a_write_reg(state, 0x0009, val);
+	if (lg_chkerr(ret))
+		goto fail;
+
+	// 3a. : 64QAM/256QAM selection for manual
+	ret = lgdt3306a_read_reg(state, 0x101a, &val);
+	val &= 0xF8;
+	if(modulation == QAM_64){
+		val |= 0x02; //QMDQMODE[2:0]=2=QAM64
+	} else {
+		val |= 0x04; //QMDQMODE[2:0]=4=QAM256
+	}
+	ret = lgdt3306a_write_reg(state, 0x101a, val);
+	if (lg_chkerr(ret))
+		goto fail;
+
+	// 4. ADC sampling frequency rate(4x sampling)
+	ret = lgdt3306a_read_reg(state, 0x000D, &val);
+	val &= 0xBF;
+	val |= 0x40; //SAMPLING4XFEN=1
+	ret = lgdt3306a_write_reg(state, 0x000D, val);
+	if (lg_chkerr(ret))
+		goto fail;
+
+	// 5. No AICC operation in QAM mode
+	ret = lgdt3306a_read_reg(state, 0x0024, &val);
+	val &= 0x00;
+	ret = lgdt3306a_write_reg(state, 0x0024, val);
+	if (lg_chkerr(ret))
+		goto fail;
+
+	// 6. Reset
+	ret = lgdt3306a_soft_reset(state);
+	if (lg_chkerr(ret))
+		goto fail;
+
+	lg_dbg("complete\n");
+fail:
+	return ret;
+}
+
+static int lgdt3306a_set_modulation(struct lgdt3306a_state *state,
+				   struct dtv_frontend_properties *p)
+{
+	int ret;
+
+	lg_dbg("\n");
+
+	switch (p->modulation) {
+	case VSB_8:
+		ret = lgdt3306a_set_vsb(state);
+		break;
+	case QAM_64:
+		ret = lgdt3306a_set_qam(state, QAM_64);
+		break;
+	case QAM_256:
+		ret = lgdt3306a_set_qam(state, QAM_256);
+		break;
+	default:
+		return -EINVAL;
+	}
+	if (lg_chkerr(ret))
+		goto fail;
+
+	state->current_modulation = p->modulation;
+
+fail:
+	return ret;
+}
+
+/* ------------------------------------------------------------------------ */
+
+static int lgdt3306a_agc_setup(struct lgdt3306a_state *state,
+			      struct dtv_frontend_properties *p)
+{
+	//TODO: anything we want to do here???
+	lg_dbg("\n");
+
+	switch (p->modulation) {
+	case VSB_8:
+		break;
+	case QAM_64:
+	case QAM_256:
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+/* ------------------------------------------------------------------------ */
+
+static int lgdt3306a_set_inversion(struct lgdt3306a_state *state,
+				       int inversion)
+{
+	int ret;
+
+	lg_dbg("(%d)\n", inversion);
+
+	ret = lgdt3306a_set_reg_bit(state, 0x0002, 2, inversion?1:0);
+	return ret;
+}
+
+static int lgdt3306a_set_inversion_auto(struct lgdt3306a_state *state,
+				       int enabled)
+{
+	int ret;
+
+	lg_dbg("(%d)\n", enabled);
+
+	//0=Manual 1=Auto(QAM only)
+	ret = lgdt3306a_set_reg_bit(state, 0x0002, 3, enabled);//SPECINVAUTO=0x04
+	return ret;
+}
+
+static int lgdt3306a_spectral_inversion(struct lgdt3306a_state *state,
+				       struct dtv_frontend_properties *p,
+				       int inversion)
+{
+	int ret = 0;
+
+	lg_dbg("(%d)\n", inversion);
+#if 0//FGR - spectral_inversion defaults already set for VSB and QAM; can enable later if desired
+
+	ret = lgdt3306a_set_inversion(state, inversion);
+
+	switch (p->modulation) {
+	case VSB_8:
+		ret = lgdt3306a_set_inversion_auto(state, 0);//Manual only for VSB
+		break;
+	case QAM_64:
+	case QAM_256:
+		ret = lgdt3306a_set_inversion_auto(state, 1);//Auto ok for QAM
+		break;
+	default:
+		ret = -EINVAL;
+	}
+#endif
+	return ret;
+}
+
+static int lgdt3306a_set_if(struct lgdt3306a_state *state,
+			   struct dtv_frontend_properties *p)
+{
+	int ret;
+	u16 if_freq_khz;
+	u8 nco1, nco2;
+
+	switch (p->modulation) {
+	case VSB_8:
+		if_freq_khz = state->cfg->vsb_if_khz;
+		break;
+	case QAM_64:
+	case QAM_256:
+		if_freq_khz = state->cfg->qam_if_khz;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	switch(if_freq_khz){
+	default:
+	    lg_warn("IF=%d KHz is not supportted, 3250 assumed\n", if_freq_khz);
+		//fallthrough
+	case 3250:  //3.25Mhz
+		nco1 = 0x34;
+		nco2 = 0x00;
+		break;
+	case 3500:  //3.50Mhz
+		nco1 = 0x38;
+		nco2 = 0x00;
+		break;
+	case 4000:  //4.00Mhz
+		nco1 = 0x40;
+		nco2 = 0x00;
+		break;
+	case 5000:  //5.00Mhz
+		nco1 = 0x50;
+		nco2 = 0x00;
+		break;
+	case 5380: //5.38Mhz
+		nco1 = 0x56;
+		nco2 = 0x14;
+		break;
+	}
+	ret = lgdt3306a_write_reg(state, 0x0010, nco1);
+	ret = lgdt3306a_write_reg(state, 0x0011, nco2);
+
+	lg_dbg("if_freq=%d KHz->[%04x]\n", if_freq_khz, nco1<<8 | nco2);
+
+	return 0;
+}
+
+/* ------------------------------------------------------------------------ */
+
+static int lgdt3306a_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)
+{
+	struct lgdt3306a_state *state = fe->demodulator_priv;
+
+	if (state->cfg->deny_i2c_rptr){
+		lg_dbg("deny_i2c_rptr=%d\n", state->cfg->deny_i2c_rptr);
+		return 0;
+	}
+	lg_dbg("(%d)\n", enable);
+
+	return lgdt3306a_set_reg_bit(state, 0x0002, 7, enable? 0 : 1); //NI2CRPTEN=0x80
+}
+
+static int lgdt3306a_sleep(struct lgdt3306a_state *state)
+{
+	int ret;
+
+	lg_dbg("\n");
+	state->current_frequency = -1; //force re-tune, when we wake
+
+	ret = lgdt3306a_mpeg_tristate(state, 1); //disable data bus
+	if (lg_chkerr(ret))
+		goto fail;
+
+	ret = lgdt3306a_power(state, 0); //power down
+	lg_chkerr(ret);
+
+fail:
+	return 0;
+}
+
+static int lgdt3306a_fe_sleep(struct dvb_frontend *fe)
+{
+	struct lgdt3306a_state *state = fe->demodulator_priv;
+
+	return lgdt3306a_sleep(state);
+}
+
+static int lgdt3306a_init(struct dvb_frontend *fe)
+{
+	struct lgdt3306a_state *state = fe->demodulator_priv;
+	u8 val;
+	int ret;
+
+	lg_dbg("\n");
+
+	// 1. Normal operation mode
+	ret = lgdt3306a_set_reg_bit(state, 0x0001, 0, 1); //SIMFASTENB=0x01
+	if (lg_chkerr(ret))
+		goto fail;
+
+	// 2. Spectrum inversion auto detection (Not valid for VSB)
+	ret = lgdt3306a_set_inversion_auto(state, 0);
+	if (lg_chkerr(ret))
+		goto fail;
+
+	// 3. Spectrum inversion(According to the tuner configuration)
+	ret = lgdt3306a_set_inversion(state, 1);
+	if (lg_chkerr(ret))
+		goto fail;
+
+	// 4. Peak-to-peak voltage of ADC input signal
+	ret = lgdt3306a_set_reg_bit(state, 0x0004, 7, 1); //ADCSEL1V=0x80=1Vpp; 0x00=2Vpp
+	if (lg_chkerr(ret))
+		goto fail;
+
+	// 5. ADC output data capture clock phase
+	ret = lgdt3306a_set_reg_bit(state, 0x0004, 2, 0); //0=same phase as ADC clock
+	if (lg_chkerr(ret))
+		goto fail;
+
+	// 5a. ADC sampling clock source
+	ret = lgdt3306a_set_reg_bit(state, 0x0004, 3, 0); //ADCCLKPLLSEL=0x08; 0=use ext clock, not PLL
+	if (lg_chkerr(ret))
+		goto fail;
+
+	// 6. Automatic PLL set
+	ret = lgdt3306a_set_reg_bit(state, 0x0005, 6, 0); //PLLSETAUTO=0x40; 0=off
+	if (lg_chkerr(ret))
+		goto fail;
+
+	if (state->cfg->xtalMHz == 24){	// 24MHz
+		// 7. Frequency for PLL output(0x2564 for 192MHz for 24MHz)
+		ret = lgdt3306a_read_reg(state, 0x0005, &val);
+		if (lg_chkerr(ret))
+			goto fail;
+		val &= 0xC0;
+		val |= 0x25;
+		ret = lgdt3306a_write_reg(state, 0x0005, val);
+		if (lg_chkerr(ret))
+			goto fail;
+		ret = lgdt3306a_write_reg(state, 0x0006, 0x64);
+		if (lg_chkerr(ret))
+			goto fail;
+
+		// 8. ADC sampling frequency(0x180000 for 24MHz sampling)
+		ret = lgdt3306a_read_reg(state, 0x000D, &val);
+		if (lg_chkerr(ret))
+			goto fail;
+		val &= 0xC0;
+		val |= 0x18;
+		ret = lgdt3306a_write_reg(state, 0x000D, val);
+		if (lg_chkerr(ret))
+			goto fail;
+
+	} else if (state->cfg->xtalMHz == 25){// 25MHz
+		// 7. Frequency for PLL output
+		ret = lgdt3306a_read_reg(state, 0x0005, &val);
+		if (lg_chkerr(ret))
+			goto fail;
+		val &= 0xC0;
+		val |= 0x25;
+		ret = lgdt3306a_write_reg(state, 0x0005, val);
+		if (lg_chkerr(ret))
+			goto fail;
+		ret = lgdt3306a_write_reg(state, 0x0006, 0x64);
+		if (lg_chkerr(ret))
+			goto fail;
+
+		// 8. ADC sampling frequency(0x190000 for 25MHz sampling)
+		ret = lgdt3306a_read_reg(state, 0x000D, &val);
+		if (lg_chkerr(ret))
+			goto fail;
+		val &= 0xC0;
+		val |= 0x19;
+		ret = lgdt3306a_write_reg(state, 0x000D, val);
+		if (lg_chkerr(ret))
+			goto fail;
+	} else {
+		lg_err("Bad xtalMHz=%d\n", state->cfg->xtalMHz);
+	}
+//	ret = lgdt3306a_write_reg(state, 0x000E, 0x00);
+//	ret = lgdt3306a_write_reg(state, 0x000F, 0x00);
+
+	// 9. Center frequency of input signal of ADC
+	ret = lgdt3306a_write_reg(state, 0x0010, 0x34); //3.25MHz
+    ret = lgdt3306a_write_reg(state, 0x0011, 0x00);
+
+	// 10. Fixed gain error value
+	ret = lgdt3306a_write_reg(state, 0x0014, 0); //gain error=0
+
+	// 10a. VSB TR BW gear shift initial step
+	ret = lgdt3306a_read_reg(state, 0x103C, &val);
+	val &= 0x0F;
+	val |= 0x20; //SAMGSAUTOSTL_V[3:0] = 2
+	ret = lgdt3306a_write_reg(state, 0x103C, val);
+
+	// 10b. Timing offset calibration in low temperature for VSB
+	ret = lgdt3306a_read_reg(state, 0x103D, &val);
+	val &= 0xFC;
+	val |= 0x03;
+	ret = lgdt3306a_write_reg(state, 0x103D, val);
+
+	// 10c. Timing offset calibration in low temperature for QAM
+	ret = lgdt3306a_read_reg(state, 0x1036, &val);
+	val &= 0xF0;
+	val |= 0x0C;
+	ret = lgdt3306a_write_reg(state, 0x1036, val);
+
+	// 11. Using the imaginary part of CIR in CIR loading
+	ret = lgdt3306a_read_reg(state, 0x211F, &val);
+	val &= 0xEF; //do not use imaginary of CIR
+	ret = lgdt3306a_write_reg(state, 0x211F, val);
+
+	// 12. Control of no signal detector function
+	ret = lgdt3306a_read_reg(state, 0x2849, &val);
+	val &= 0xEF; //NOUSENOSIGDET=0, enable no signal detector
+	ret = lgdt3306a_write_reg(state, 0x2849, val);
+
+	//FGR - put demod in some known mode
+	ret = lgdt3306a_set_vsb(state);
+
+	// 13. TP stream format
+	ret = lgdt3306a_mpeg_mode(state, state->cfg->mpeg_mode);
+
+	// 14. disable output buses
+	ret = lgdt3306a_mpeg_tristate(state, 1);
+
+	// 15. Sleep (in reset)
+	ret = lgdt3306a_sleep(state);
+	lg_chkerr(ret);
+
+fail:
+	return ret;
+}
+
+static int lgdt3306a_set_parameters(struct dvb_frontend *fe)
+{
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+	struct lgdt3306a_state *state = fe->demodulator_priv;
+	int ret;
+
+	lg_dbg("(%d, %d)\n", p->frequency, p->modulation);
+
+	if(state->current_frequency  == p->frequency &&
+	   state->current_modulation == p->modulation ){
+		lg_dbg(" (already set, skipping ...)\n");
+		return 0;
+	}
+	state->current_frequency = -1;
+	state->current_modulation = -1;
+
+	ret = lgdt3306a_power(state, 1); //power up
+	if (lg_chkerr(ret))
+		goto fail;
+
+	if (fe->ops.tuner_ops.set_params) {
+		ret = fe->ops.tuner_ops.set_params(fe);
+		if (fe->ops.i2c_gate_ctrl)
+			fe->ops.i2c_gate_ctrl(fe, 0);
+//		if (lg_chkerr(ret))
+//			goto fail;
+//		state->current_frequency = p->frequency;
+	}
+
+	ret = lgdt3306a_set_modulation(state, p);
+	if (lg_chkerr(ret))
+		goto fail;
+
+	ret = lgdt3306a_agc_setup(state, p);
+	if (lg_chkerr(ret))
+		goto fail;
+
+	ret = lgdt3306a_set_if(state, p);
+	if (lg_chkerr(ret))
+		goto fail;
+
+	ret = lgdt3306a_spectral_inversion(state, p,
+					  state->cfg->spectral_inversion? 1 : 0);
+	if (lg_chkerr(ret))
+		goto fail;
+
+	ret = lgdt3306a_mpeg_mode(state, state->cfg->mpeg_mode);
+	if (lg_chkerr(ret))
+		goto fail;
+
+	ret = lgdt3306a_mpeg_mode_polarity(state,
+					  state->cfg->tpclk_edge,
+					  state->cfg->tpvalid_polarity);
+	if (lg_chkerr(ret))
+		goto fail;
+
+	ret = lgdt3306a_mpeg_tristate(state, 0); //enable data bus
+	if (lg_chkerr(ret))
+		goto fail;
+
+	ret = lgdt3306a_soft_reset(state);
+	if (lg_chkerr(ret))
+		goto fail;
+
+#ifdef DBG_DUMP
+	lgdt3306a_DumpAllRegs(state);
+#endif
+	state->current_frequency = p->frequency;
+fail:
+	return ret;
+}
+
+static int lgdt3306a_get_frontend(struct dvb_frontend *fe)
+{
+	struct lgdt3306a_state *state = fe->demodulator_priv;
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+
+	lg_dbg("(%u, %d)\n", state->current_frequency, state->current_modulation);
+
+	p->modulation = state->current_modulation;
+	p->frequency = state->current_frequency;
+	return 0;
+}
+
+static enum dvbfe_algo lgdt3306a_get_frontend_algo(struct dvb_frontend *fe)
+{
+#if 1
+	return DVBFE_ALGO_CUSTOM;
+#else
+	return DVBFE_ALGO_HW;
+#endif
+}
+
+/* ------------------------------------------------------------------------ */
+static void lgdt3306a_monitor_vsb(struct lgdt3306a_state *state)
+{
+	u8 val;
+	int ret;
+	u8 	snrRef, maxPowerMan, nCombDet;
+    u16 fbDlyCir;
+
+	ret = lgdt3306a_read_reg(state, 0x21A1, &val);
+	snrRef = val & 0x3F;
+
+	ret = lgdt3306a_read_reg(state, 0x2185, &maxPowerMan);
+
+	ret = lgdt3306a_read_reg(state, 0x2191, &val);
+	nCombDet = (val & 0x80) >> 7;
+
+	ret = lgdt3306a_read_reg(state, 0x2180, &val);
+	fbDlyCir = (val & 0x03) << 8;
+	ret = lgdt3306a_read_reg(state, 0x2181, &val);
+	fbDlyCir |= val;
+
+	lg_dbg("snrRef=%d maxPowerMan=0x%x nCombDet=%d fbDlyCir=0x%x\n",
+		snrRef, maxPowerMan, nCombDet, fbDlyCir);
+
+	//Carrier offset sub loop bandwidth
+	ret = lgdt3306a_read_reg(state, 0x1061, &val);
+	val &= 0xF8;
+	if ((snrRef > 18) && (maxPowerMan > 0x68) && (nCombDet == 0x01) && ((fbDlyCir == 0x03FF) || (fbDlyCir < 0x6C)))	{
+		//SNR is over 18dB and no ghosting
+		val |= 0x00; //final bandwidth = 0
+	} else {
+		val |= 0x04; //final bandwidth = 4
+	}
+	ret = lgdt3306a_write_reg(state, 0x1061, val);
+
+	// Adjust Notch Filter
+	ret = lgdt3306a_read_reg(state, 0x0024, &val);
+	val &= 0x0F;
+	if (nCombDet == 0){ // Turn on the Notch Filter
+		val |= 0x50;
+	}
+	ret = lgdt3306a_write_reg(state, 0x0024, val);
+
+	//VSB Timing Recovery output normalization
+	ret = lgdt3306a_read_reg(state, 0x103D, &val);
+	val &= 0xCF;
+	val |= 0x20;
+	ret = lgdt3306a_write_reg(state, 0x103D, val);
+}
+
+static LG3306_MODULATION lgdt3306a_check_oper_mode(struct lgdt3306a_state *state)
+{
+	u8 val = 0;
+	int ret;
+
+	ret = lgdt3306a_read_reg(state, 0x0081, &val);
+
+	if (val & 0x80)	{
+		lg_dbg("VSB\n");
+		return(LG3306_VSB);
+	}
+	else if (val & 0x08) {
+		ret = lgdt3306a_read_reg(state, 0x00A6, &val);
+		val = val >> 2;
+		if (val & 0x01) {
+			lg_dbg("QAM256\n");
+			return(LG3306_QAM256);
+		} else {
+			lg_dbg("QAM64\n");
+			return(LG3306_QAM64);
+		}
+	}
+	lg_warn("UNKNOWN\n");
+	return(LG3306_UNKNOWN_MODE);
+}
+
+static LG3306_LOCK_STATUS lgdt3306a_check_lock_status(struct lgdt3306a_state *state,
+			LG3306_LOCK_CHECK whatLock)
+{
+	u8 val = 0;
+	int ret;
+	LG3306_MODULATION	modeOper;
+	LG3306_LOCK_STATUS lockStatus;
+
+	modeOper = LG3306_UNKNOWN_MODE;
+
+	switch (whatLock)
+	{
+		case LG3306_SYNC_LOCK :
+		{
+			ret = lgdt3306a_read_reg(state, 0x00A6, &val);
+
+			if ((val & 0x80) == 0x80)
+				lockStatus = LG3306_LOCK;
+			else
+				lockStatus = LG3306_UNLOCK;
+
+			lg_dbg("SYNC_LOCK=%x\n", lockStatus);
+			break;
+		}
+		case LG3306_AGC_LOCK :
+		{
+			ret = lgdt3306a_read_reg(state, 0x0080, &val);
+
+			if ((val & 0x40) == 0x40)
+				lockStatus = LG3306_LOCK;
+			else
+				lockStatus = LG3306_UNLOCK;
+
+			lg_dbg("AGC_LOCK=%x\n", lockStatus);
+			break;
+		}
+		case LG3306_TR_LOCK :
+		{
+			modeOper = lgdt3306a_check_oper_mode(state);
+			if ((modeOper == LG3306_QAM64) || (modeOper == LG3306_QAM256))
+			{
+				ret = lgdt3306a_read_reg(state, 0x1094, &val);
+
+				if ((val & 0x80) == 0x80)
+					lockStatus = LG3306_LOCK;
+				else
+					lockStatus = LG3306_UNLOCK;
+			}
+			else
+				lockStatus = LG3306_UNKNOWN_LOCK;
+
+			lg_dbg("TR_LOCK=%x\n", lockStatus);
+			break;
+		}
+		case LG3306_FEC_LOCK :
+		{
+			modeOper = lgdt3306a_check_oper_mode(state);
+			if ((modeOper == LG3306_QAM64) || (modeOper == LG3306_QAM256))
+			{
+				ret = lgdt3306a_read_reg(state, 0x0080, &val);
+
+				if ((val & 0x10) == 0x10)
+					lockStatus = LG3306_LOCK;
+				else
+					lockStatus = LG3306_UNLOCK;
+			}
+			else
+				lockStatus = LG3306_UNKNOWN_LOCK;
+
+			lg_dbg("FEC_LOCK=%x\n", lockStatus);
+			break;
+		}
+
+		default :
+			lockStatus = LG3306_UNKNOWN_LOCK;
+			lg_warn("UNKNOWN whatLock=%d\n", whatLock);
+			break;
+	}
+
+	return(lockStatus);
+}
+
+static LG3306_NEVERLOCK_STATUS lgdt3306a_check_neverlock_status(struct lgdt3306a_state *state)
+{
+	u8 val = 0;
+	int ret;
+	LG3306_NEVERLOCK_STATUS lockStatus;
+
+	ret = lgdt3306a_read_reg(state, 0x0080, &val);
+	lockStatus = (LG3306_NEVERLOCK_STATUS)(val & 0x03);
+
+	lg_dbg("NeverLock=%d", lockStatus);
+
+	return(lockStatus);
+}
+
+static void lgdt3306a_pre_monitoring(struct lgdt3306a_state *state)
+{
+	u8 val = 0;
+	int ret;
+	u8 currChDiffACQ, snrRef, mainStrong, aiccrejStatus;
+
+	//Channel variation
+	ret = lgdt3306a_read_reg(state, 0x21BC, &currChDiffACQ);
+
+	//SNR of Frame sync
+	ret = lgdt3306a_read_reg(state, 0x21A1, &val);
+	snrRef = val & 0x3F;
+
+	//Strong Main CIR
+	ret = lgdt3306a_read_reg(state, 0x2199, &val);
+	mainStrong = (val & 0x40) >> 6;
+
+	ret = lgdt3306a_read_reg(state, 0x0090, &val);
+	aiccrejStatus = (val & 0xF0) >> 4;
+
+	lg_dbg("snrRef=%d mainStrong=%d aiccrejStatus=%d currChDiffACQ=0x%x\n",
+		snrRef, mainStrong, aiccrejStatus, currChDiffACQ);
+
+//	if ((mainStrong == 0) && (currChDiffACQ > 0x70)) //Dynamic ghost exists
+	if (mainStrong == 0)
+	{
+		ret = lgdt3306a_read_reg(state, 0x2135, &val);
+		val &= 0x0F;
+		val |= 0xA0;
+		ret = lgdt3306a_write_reg(state, 0x2135, val);
+
+		ret = lgdt3306a_read_reg(state, 0x2141, &val);
+		val &= 0x3F;
+		val |= 0x80;
+		ret = lgdt3306a_write_reg(state, 0x2141, val);
+
+		ret = lgdt3306a_write_reg(state, 0x2122, 0x70);
+	}
+	else // Weak ghost or static channel
+	{
+		ret = lgdt3306a_read_reg(state, 0x2135, &val);
+		val &= 0x0F;
+		val |= 0x70;
+		ret = lgdt3306a_write_reg(state, 0x2135, val);
+
+		ret = lgdt3306a_read_reg(state, 0x2141, &val);
+		val &= 0x3F;
+		val |= 0x40;
+		ret = lgdt3306a_write_reg(state, 0x2141, val);
+
+		ret = lgdt3306a_write_reg(state, 0x2122, 0x40);
+	}
+
+}
+
+static LG3306_LOCK_STATUS lgdt3306a_sync_lock_poll(struct lgdt3306a_state *state)
+{
+	LG3306_LOCK_STATUS 	syncLockStatus = LG3306_UNLOCK;
+	int	i;
+
+	for (i = 0; i < 2; i++)	{
+		msleep(30);
+
+		syncLockStatus = lgdt3306a_check_lock_status(state, LG3306_SYNC_LOCK);
+
+		if (syncLockStatus == LG3306_LOCK) {
+			lg_dbg("locked(%d)\n", i);
+			return(LG3306_LOCK);
+		}
+	}
+	lg_dbg("not locked\n");
+	return(LG3306_UNLOCK);
+}
+
+static LG3306_LOCK_STATUS lgdt3306a_fec_lock_poll(struct lgdt3306a_state *state)
+{
+	LG3306_LOCK_STATUS FECLockStatus = LG3306_UNLOCK;
+	int	i;
+
+	for (i = 0; i < 2; i++)	{
+		msleep(30);
+
+		FECLockStatus = lgdt3306a_check_lock_status(state, LG3306_FEC_LOCK);
+
+		if (FECLockStatus == LG3306_LOCK) {
+			lg_dbg("locked(%d)\n", i);
+			return(FECLockStatus);
+		}
+	}
+	lg_dbg("not locked\n");
+	return(FECLockStatus);
+}
+
+static LG3306_NEVERLOCK_STATUS lgdt3306a_neverlock_poll(struct lgdt3306a_state *state)
+{
+	LG3306_NEVERLOCK_STATUS NLLockStatus = LG3306_NL_FAIL;
+	int	i;
+
+	for (i = 0; i < 5; i++){
+		msleep(30);
+
+		NLLockStatus = lgdt3306a_check_neverlock_status(state);
+
+		if (NLLockStatus == LG3306_NL_LOCK) {
+			lg_dbg("NL_LOCK(%d)\n", i);
+			return(NLLockStatus);
+		}
+	}
+	lg_dbg("NLLockStatus=%d\n", NLLockStatus);
+	return(NLLockStatus);
+}
+
+static u8 lgdt3306a_get_packet_error(struct lgdt3306a_state *state)
+{
+	u8 val;
+	int ret;
+
+	ret = lgdt3306a_read_reg(state, 0x00FA, &val);
+
+	return(val);
+}
+
+static u32 log10_x1000(u32 x)
+{
+    static u32 valx_x10[]     = {  10,  11,  13,  15,  17,  20,  25,  33,  41,  50,  59,  73,  87,  100 };
+    static u32 log10x_x1000[] = {   0,  41, 114, 176, 230, 301, 398, 518, 613, 699, 771, 863, 939, 1000 };
+    static u32 nelems = sizeof(valx_x10)/sizeof(valx_x10[0]);
+	u32 log_val = 0;
+    u32 i;
+
+    if (x<=0)
+		return -1000000;//signal error
+
+    if (x<10) {
+		while (x<10) {
+			x = x*10;
+			log_val--;
+		}
+	} else if (x==10) {
+		return 0; //log(1)=0
+	} else {
+		while (x>=100) {
+			x = x/10;
+			log_val++;
+		}
+    }
+	log_val *= 1000;
+
+    if (x==10) //was our input an exact multiple of 10
+	return log_val;	//don't need to interpolate
+
+    //find our place on the log curve
+    for (i=1; i < nelems; i++){
+		if (valx_x10[i] >= x) break;
+	}
+
+	{
+		u32 diff_val   = x - valx_x10[i-1];
+		u32 step_val   = valx_x10[i] - valx_x10[i-1];
+		u32 step_log10 = log10x_x1000[i] - log10x_x1000[i-1];
+		//do a linear interpolation to get in-between values
+		return log_val + log10x_x1000[i-1] + ((diff_val*step_log10)/step_val);
+	}
+}
+
+static u32 lgdt3306a_calculate_snr_x100(struct lgdt3306a_state *state)
+{
+	u32 mse;  /* Mean-Square Error */
+	u32 pwr;  /* Constelation power */
+	u32 snr_x100;
+
+	mse = (read_reg(state, 0x00EC) << 8) |
+	      (read_reg(state, 0x00ED));
+	pwr = (read_reg(state, 0x00E8) << 8) |
+	      (read_reg(state, 0x00E9));
+
+	if (mse == 0) /* no signal */
+		return 0;
+
+	snr_x100 = log10_x1000((pwr*10000)/mse) - 3000;
+	lg_dbg("mse=%u, pwr=%u, snr_x100=%d\n", mse, pwr, snr_x100);
+
+	return snr_x100;
+}
+
+static LG3306_LOCK_STATUS lgdt3306a_vsb_lock_poll(struct lgdt3306a_state *state)
+{
+	u8 	cnt = 0;
+	u8  packet_error;
+	u32	snr;
+
+	while(1) {
+		if (lgdt3306a_sync_lock_poll(state) == LG3306_UNLOCK) {
+			lg_dbg("no sync lock!\n");
+			return(LG3306_UNLOCK);
+		} else {
+			msleep(20);
+			lgdt3306a_pre_monitoring(state);
+
+			packet_error = lgdt3306a_get_packet_error(state);
+			snr = lgdt3306a_calculate_snr_x100(state);
+			lg_dbg("cnt=%d errors=%d snr=%d\n", cnt, packet_error, snr);
+
+			if((snr < 1500) || (packet_error >= 0xff)) {
+				cnt++;
+			} else {
+				return(LG3306_LOCK);
+			}
+
+			if(cnt >= 10) {
+				lg_dbg("not locked!\n");
+				return(LG3306_UNLOCK);
+			}
+		}
+	}
+	return(LG3306_UNLOCK);
+}
+
+static LG3306_LOCK_STATUS lgdt3306a_qam_lock_poll(struct lgdt3306a_state *state)
+{
+	u8 cnt = 0;
+	u8 packet_error;
+	u32	snr;
+
+	while(1) {
+		if(lgdt3306a_fec_lock_poll(state) == LG3306_UNLOCK) {
+			lg_dbg("no fec lock!\n");
+			return(LG3306_UNLOCK);
+		} else {
+			msleep(20);
+
+			packet_error = lgdt3306a_get_packet_error(state);
+			snr = lgdt3306a_calculate_snr_x100(state);
+			lg_dbg("cnt=%d errors=%d snr=%d\n", cnt, packet_error, snr);
+
+			if((snr < 1500) || (packet_error >= 0xff)) {
+				cnt++;
+			} else 	{
+				return(LG3306_LOCK);
+			}
+
+			if(cnt >= 10) {
+				lg_dbg("not locked!\n");
+				return(LG3306_UNLOCK);
+			}
+		}
+	}
+	return(LG3306_UNLOCK);
+}
+
+static int lgdt3306a_read_status(struct dvb_frontend *fe, fe_status_t *status)
+{
+	int ret = 0;
+	struct lgdt3306a_state *state = fe->demodulator_priv;
+
+	u16 strength = 0;
+	if (fe->ops.tuner_ops.get_rf_strength) {
+		ret = fe->ops.tuner_ops.get_rf_strength(fe, &strength);
+		if (ret==0) {
+			lg_dbg("strength=%d\n", strength);
+		} else {
+			lg_dbg("fe->ops.tuner_ops.get_rf_strength() failed\n");
+		}
+	}
+
+	*status = 0;
+	if(lgdt3306a_neverlock_poll(state) == LG3306_NL_LOCK) {
+		*status |= FE_HAS_SIGNAL;
+		*status |= FE_HAS_CARRIER;
+
+		switch (state->current_modulation) {
+		case QAM_256:
+		case QAM_64:
+			if(lgdt3306a_qam_lock_poll(state) == LG3306_LOCK){
+				*status |= FE_HAS_VITERBI;
+				*status |= FE_HAS_SYNC;
+
+				*status |= FE_HAS_LOCK;
+			}
+			break;
+		case VSB_8:
+			if(lgdt3306a_vsb_lock_poll(state) == LG3306_LOCK){
+				*status |= FE_HAS_VITERBI;
+				*status |= FE_HAS_SYNC;
+
+				*status |= FE_HAS_LOCK;
+
+				lgdt3306a_monitor_vsb(state);
+			}
+			break;
+		default:
+			ret = -EINVAL;
+		}
+	}
+	return ret;
+}
+
+
+static int lgdt3306a_read_snr(struct dvb_frontend *fe, u16 *snr)
+{
+	struct lgdt3306a_state *state = fe->demodulator_priv;
+
+	state->snr = lgdt3306a_calculate_snr_x100(state);
+	/* report SNR in dB * 10 */
+	*snr = state->snr/10;
+
+	return 0;
+}
+
+static int lgdt3306a_read_signal_strength(struct dvb_frontend *fe,
+					 u16 *strength)
+{
+	/*
+	 * Calculate some sort of "strength" from SNR
+	 */
+	struct lgdt3306a_state *state = fe->demodulator_priv;
+	u16 snr;  //snr_x10
+	int ret;
+	u32 ref_snr; //snr*100
+	u32 str;
+
+	*strength = 0;
+
+	switch (state->current_modulation) {
+	case VSB_8:
+		 ref_snr = 1600; //16dB
+		 break;
+	case QAM_64:
+		 ref_snr = 2200; //22dB
+		 break;
+	case QAM_256:
+		 ref_snr = 2800; //28dB
+		 break;
+	default:
+		return -EINVAL;
+	}
+
+	ret = fe->ops.read_snr(fe, &snr);
+	if (lg_chkerr(ret))
+		goto fail;
+
+	if(state->snr <= (ref_snr-100))
+		str = 0;
+	else if(state->snr <= ref_snr)
+		str = (0xffff*65) / 100; //65%
+	else {
+		str = state->snr - ref_snr;
+		str /= 50;
+		str += 78; //78%-100%
+		if(str > 100)
+			str = 100;
+		str = (0xffff * str) / 100;
+	}
+	*strength = (u16)str;
+	lg_dbg("strength=%u\n", *strength);
+
+fail:
+	return ret;
+}
+
+/* ------------------------------------------------------------------------ */
+
+static int lgdt3306a_read_ber(struct dvb_frontend *fe, u32 *ber)
+{
+	struct lgdt3306a_state *state = fe->demodulator_priv;
+	u32 tmp;
+
+	*ber = 0;
+#if 1
+	//FGR - BUGBUG - I don't know what value is expected by dvb_core
+	// what is the scale of the value??
+	tmp =            read_reg(state, 0x00FC);//NBERVALUE[24-31]
+	tmp = (tmp<<8) | read_reg(state, 0x00FD);//NBERVALUE[16-23]
+	tmp = (tmp<<8) | read_reg(state, 0x00FE);//NBERVALUE[8-15]
+	tmp = (tmp<<8) | read_reg(state, 0x00FF);//NBERVALUE[0-7]
+	*ber = tmp;
+	lg_dbg("ber=%u\n", tmp);
+#endif
+	return 0;
+}
+
+static int lgdt3306a_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)
+{
+	struct lgdt3306a_state *state = fe->demodulator_priv;
+
+	*ucblocks =	0;
+#if 1
+	//FGR - BUGBUG - I don't know what value is expected by dvb_core
+	// what happens when value wraps?
+	*ucblocks = read_reg(state, 0x00F4);//TPIFTPERRCNT[0-7]
+	lg_dbg("ucblocks=%u\n", *ucblocks);
+#endif
+
+	return 0;
+}
+
+static int lgdt3306a_tune(struct dvb_frontend *fe, bool re_tune, unsigned int mode_flags, unsigned int *delay, fe_status_t *status)
+{
+	int ret = 0;
+	struct lgdt3306a_state *state = fe->demodulator_priv;
+
+	lg_dbg("re_tune=%u\n", re_tune);
+
+	if (re_tune) {
+		state->current_frequency = -1; //force re-tune
+		if ((ret = lgdt3306a_set_parameters(fe)) != 0) {
+			return ret;
+		}
+	}
+	*delay = 125;
+	ret = lgdt3306a_read_status(fe, status);
+
+	return ret;
+}
+
+static int lgdt3306a_get_tune_settings(struct dvb_frontend *fe,
+				      struct dvb_frontend_tune_settings
+					*fe_tune_settings)
+{
+	fe_tune_settings->min_delay_ms = 100;
+	lg_dbg("\n");
+	return 0;
+}
+
+static int lgdt3306a_search(struct dvb_frontend *fe)
+{
+	fe_status_t status = 0;
+	int i, ret;
+
+	/* set frontend */
+	ret = lgdt3306a_set_parameters(fe);
+	if (ret)
+		goto error;
+
+	/* wait frontend lock */
+	for (i = 20; i > 0; i--) {
+		lg_dbg(": loop=%d\n", i);
+		msleep(50);
+		ret = lgdt3306a_read_status(fe, &status);
+		if (ret)
+			goto error;
+
+		if (status & FE_HAS_LOCK)
+			break;
+	}
+
+	/* check if we have a valid signal */
+	if (status & FE_HAS_LOCK) {
+		return DVBFE_ALGO_SEARCH_SUCCESS;
+	} else {
+		return DVBFE_ALGO_SEARCH_AGAIN;
+	}
+
+error:
+	lg_dbg("failed (%d)\n", ret);
+	return DVBFE_ALGO_SEARCH_ERROR;
+}
+
+static void lgdt3306a_release(struct dvb_frontend *fe)
+{
+	struct lgdt3306a_state *state = fe->demodulator_priv;
+	lg_dbg("\n");
+	kfree(state);
+}
+
+static struct dvb_frontend_ops lgdt3306a_ops;
+
+struct dvb_frontend *lgdt3306a_attach(const struct lgdt3306a_config *config,
+				     struct i2c_adapter *i2c_adap)
+{
+	struct lgdt3306a_state *state = NULL;
+	int ret;
+	u8 val;
+
+	lg_dbg("(%d-%04x)\n",
+	       i2c_adap ? i2c_adapter_id(i2c_adap) : 0,
+	       config ? config->i2c_addr : 0);
+
+	state = kzalloc(sizeof(struct lgdt3306a_state), GFP_KERNEL);
+	if (state == NULL)
+		goto fail;
+
+	state->cfg = config;
+	state->i2c_adap = i2c_adap;
+
+	memcpy(&state->frontend.ops, &lgdt3306a_ops,
+	       sizeof(struct dvb_frontend_ops));
+	state->frontend.demodulator_priv = state;
+
+	/* verify that we're talking to a lg3306a */
+	//FGR - NOTE - there is no obvious ChipId to check; we check
+	//  some "known" bits after reset, but it's still just a guess
+	ret = lgdt3306a_read_reg(state, 0x0000, &val);
+	if (lg_chkerr(ret))
+		goto fail;
+	if((val & 0x74) != 0x74){
+		lg_warn("expected 0x74, got 0x%x\n", (val & 0x74));
+//	  	goto fail;	//BUGBUG - re-enable when we know this is right
+	}
+	ret = lgdt3306a_read_reg(state, 0x0001, &val);
+	if (lg_chkerr(ret))
+		goto fail;
+	if((val & 0xF6) != 0xC6){
+		lg_warn("expected 0xC6, got 0x%x\n", (val & 0xF6));
+//	  	goto fail;	//BUGBUG - re-enable when we know this is right
+	}
+	ret = lgdt3306a_read_reg(state, 0x0002, &val);
+	if (lg_chkerr(ret))
+		goto fail;
+	if((val & 0x73) != 0x03){
+		lg_warn("expected 0x03, got 0x%x\n", (val & 0x73));
+//	  	goto fail;	//BUGBUG - re-enable when we know this is right
+	}
+
+	state->current_frequency = -1;
+	state->current_modulation = -1;
+
+	lgdt3306a_sleep(state);
+
+	return &state->frontend;
+
+fail:
+	lg_warn("unable to detect LGDT3306A hardware\n");
+	kfree(state);
+	return NULL;
+}
+
+#ifdef DBG_DUMP
+
+static const short regtab[] = {
+  0x0000, //SOFTRSTB 1'b1 1'b1 1'b1 ADCPDB 1'b1 PLLPDB GBBPDB 11111111
+  0x0001, //1'b1 1'b1 1'b0 1'b0 AUTORPTRS
+  0x0002, //NI2CRPTEN 1'b0 1'b0 1'b0 SPECINVAUT
+  0x0003, //AGCRFOUT
+  0x0004, //ADCSEL1V ADCCNT ADCCNF ADCCNS ADCCLKPLL
+  0x0005, //PLLINDIVSE
+  0x0006, //PLLCTRL[7:0] 11100001
+  0x0007, //SYSINITWAITTIME[7:0] (msec) 00001000
+  0x0008, //STDOPMODE[7:0] 10000000
+  0x0009, //1'b0 1'b0 1'b0 STDOPDETTMODE[2:0] STDOPDETCMODE[1:0] 00011110
+  0x000A, //DAFTEN 1'b1 x x SCSYSLOCK
+  0x000B, //SCSYSLOCKCHKTIME[7:0] (10msec) 01100100
+  0x000D, //x SAMPLING4
+  0x000E, //SAMFREQ[15:8] 00000000
+  0x000F, //SAMFREQ[7:0] 00000000
+  0x0010, //IFFREQ[15:8] 01100000
+  0x0011, //IFFREQ[7:0] 00000000
+  0x0012, //AGCEN AGCREFMO
+  0x0013, //AGCRFFIXB AGCIFFIXB AGCLOCKDETRNGSEL[1:0] 1'b1 1'b0 1'b0 1'b0 11101000
+  0x0014, //AGCFIXVALUE[7:0] 01111111
+  0x0015, //AGCREF[15:8] 00001010
+  0x0016, //AGCREF[7:0] 11100100
+  0x0017, //AGCDELAY[7:0] 00100000
+  0x0018, //AGCRFBW[3:0] AGCIFBW[3:0] 10001000
+  0x0019, //AGCUDOUTMODE[1:0] AGCUDCTRLLEN[1:0] AGCUDCTRL
+  0x001C, //1'b1 PFEN MFEN AICCVSYNC
+  0x001D, //1'b0 1'b1 1'b0 1'b1 AICCVSYNC
+  0x001E, //AICCALPHA[3:0] 1'b1 1'b0 1'b1 1'b0 01111010
+  0x001F, //AICCDETTH[19:16] AICCOFFTH[19:16] 00000000
+  0x0020, //AICCDETTH[15:8] 01111100
+  0x0021, //AICCDETTH[7:0] 00000000
+  0x0022, //AICCOFFTH[15:8] 00000101
+  0x0023, //AICCOFFTH[7:0] 11100000
+  0x0024, //AICCOPMODE3[1:0] AICCOPMODE2[1:0] AICCOPMODE1[1:0] AICCOPMODE0[1:0] 00000000
+  0x0025, //AICCFIXFREQ3[23:16] 00000000
+  0x0026, //AICCFIXFREQ3[15:8] 00000000
+  0x0027, //AICCFIXFREQ3[7:0] 00000000
+  0x0028, //AICCFIXFREQ2[23:16] 00000000
+  0x0029, //AICCFIXFREQ2[15:8] 00000000
+  0x002A, //AICCFIXFREQ2[7:0] 00000000
+  0x002B, //AICCFIXFREQ1[23:16] 00000000
+  0x002C, //AICCFIXFREQ1[15:8] 00000000
+  0x002D, //AICCFIXFREQ1[7:0] 00000000
+  0x002E, //AICCFIXFREQ0[23:16] 00000000
+  0x002F, //AICCFIXFREQ0[15:8] 00000000
+  0x0030, //AICCFIXFREQ0[7:0] 00000000
+  0x0031, //1'b0 1'b1 1'b0 1'b0 x DAGC1STER
+  0x0032, //DAGC1STEN DAGC1STER
+  0x0033, //DAGC1STREF[15:8] 00001010
+  0x0034, //DAGC1STREF[7:0] 11100100
+  0x0035, //DAGC2NDE
+  0x0036, //DAGC2NDREF[15:8] 00001010
+  0x0037, //DAGC2NDREF[7:0] 10000000
+  0x0038, //DAGC2NDLOCKDETRNGSEL[1:0]
+  0x003D, //1'b1 SAMGEARS
+  0x0040, //SAMLFGMA
+  0x0041, //SAMLFBWM
+  0x0044, //1'b1 CRGEARSHE
+  0x0045, //CRLFGMAN
+  0x0046, //CFLFBWMA
+  0x0047, //CRLFGMAN
+  0x0048, //x x x x CRLFGSTEP_VS[3:0] xxxx1001
+  0x0049, //CRLFBWMA
+  0x004A, //CRLFBWMA
+  0x0050, //1'b0 1'b1 1'b1 1'b0 MSECALCDA
+  0x0070, //TPOUTEN TPIFEN TPCLKOUTE
+  0x0071, //TPSENB TPSSOPBITE
+  0x0073, //TP47HINS x x CHBERINT PERMODE[1:0] PERINT[1:0] 1xx11100
+  0x0075, //x x x x x IQSWAPCTRL[2:0] xxxxx000
+  0x0076, //NBERCON NBERST NBERPOL NBERWSYN
+  0x0077, //x NBERLOSTTH[2:0] NBERACQTH[3:0] x0000000
+  0x0078, //NBERPOLY[31:24] 00000000
+  0x0079, //NBERPOLY[23:16] 00000000
+  0x007A, //NBERPOLY[15:8] 00000000
+  0x007B, //NBERPOLY[7:0] 00000000
+  0x007C, //NBERPED[31:24] 00000000
+  0x007D, //NBERPED[23:16] 00000000
+  0x007E, //NBERPED[15:8] 00000000
+  0x007F, //NBERPED[7:0] 00000000
+  0x0080, //x AGCLOCK DAGCLOCK SYSLOCK x x NEVERLOCK[1:0]
+  0x0085, //SPECINVST
+  0x0088, //SYSLOCKTIME[15:8]
+  0x0089, //SYSLOCKTIME[7:0]
+  0x008C, //FECLOCKTIME[15:8]
+  0x008D, //FECLOCKTIME[7:0]
+  0x008E, //AGCACCOUT[15:8]
+  0x008F, //AGCACCOUT[7:0]
+  0x0090, //AICCREJSTATUS[3:0] AICCREJBUSY[3:0]
+  0x0091, //AICCVSYNC
+  0x009C, //CARRFREQOFFSET[15:8]
+  0x009D, //CARRFREQOFFSET[7:0]
+  0x00A1, //SAMFREQOFFSET[23:16]
+  0x00A2, //SAMFREQOFFSET[15:8]
+  0x00A3, //SAMFREQOFFSET[7:0]
+  0x00A6, //SYNCLOCK SYNCLOCKH
+#if 0//covered elsewhere
+  0x00E8, //CONSTPWR[15:8]
+  0x00E9, //CONSTPWR[7:0]
+  0x00EA, //BMSE[15:8]
+  0x00EB, //BMSE[7:0]
+  0x00EC, //MSE[15:8]
+  0x00ED, //MSE[7:0]
+  0x00EE, //CONSTI[7:0]
+  0x00EF, //CONSTQ[7:0]
+#endif
+  0x00F4, //TPIFTPERRCNT[7:0]
+  0x00F5, //TPCORREC
+  0x00F6, //VBBER[15:8]
+  0x00F7, //VBBER[7:0]
+  0x00F8, //VABER[15:8]
+  0x00F9, //VABER[7:0]
+  0x00FA, //TPERRCNT[7:0]
+  0x00FB, //NBERLOCK x x x x x x x
+  0x00FC, //NBERVALUE[31:24]
+  0x00FD, //NBERVALUE[23:16]
+  0x00FE, //NBERVALUE[15:8]
+  0x00FF, //NBERVALUE[7:0]
+  0x1000, //1'b0 WODAGCOU
+  0x1005, //x x 1'b1 1'b1 x SRD_Q_QM
+  0x1009, //SRDWAITTIME[7:0] (10msec) 00100011
+  0x100A, //SRDWAITTIME_CQS[7:0] (msec) 01100100
+  0x101A, //x 1'b1 1'b0 1'b0 x QMDQAMMODE[2:0] x100x010
+  0x1036, //1'b0 1'b1 1'b0 1'b0 SAMGSEND_CQS[3:0] 01001110
+  0x103C, //SAMGSAUTOSTL_V[3:0] SAMGSAUTOEDL_V[3:0] 01000110
+  0x103D, //1'b1 1'b1 SAMCNORMBP_V[1:0] 1'b0 1'b0 SAMMODESEL_V[1:0] 11100001
+  0x103F, //SAMZTEDSE
+  0x105D, //EQSTATUSE
+  0x105F, //x PMAPG2_V[2:0] x DMAPG2_V[2:0] x001x011
+  0x1060, //1'b1 EQSTATUSE
+  0x1061, //CRMAPBWSTL_V[3:0] CRMAPBWEDL_V[3:0] 00000100
+  0x1065, //1'b0 x CRMODE_V[1:0] 1'b1 x 1'b1 x 0x111x1x
+  0x1066, //1'b0 1'b0 1'b1 1'b0 1'b1 PNBOOSTSE
+  0x1068, //CREPHNGAIN2_V[3:0] CREPHNPBW_V[3:0] 10010001
+  0x106E, //x x x x x CREPHNEN_
+  0x106F, //CREPHNTH_V[7:0] 00010101
+  0x1072, //CRSWEEPN
+  0x1073, //CRPGAIN_V[3:0] x x 1'b1 1'b1 1001xx11
+  0x1074, //CRPBW_V[3:0] x x 1'b1 1'b1 0001xx11
+  0x1080, //DAFTSTATUS[1:0] x x x x x x
+  0x1081, //SRDSTATUS[1:0] x x x x x SRDLOCK
+  0x10A9, //EQSTATUS_CQS[1:0] x x x x x x
+  0x10B7, //EQSTATUS_V[1:0] x x x x x x
+#if 0//SMART_ANT
+  0x1F00, //MODEDETE
+  0x1F01, //x x x x x x x SFNRST xxxxxxx0
+  0x1F03, //NUMOFANT[7:0] 10000000
+  0x1F04, //x SELMASK[6:0] x0000000
+  0x1F05, //x SETMASK[6:0] x0000000
+  0x1F06, //x TXDATA[6:0] x0000000
+  0x1F07, //x CHNUMBER[6:0] x0000000
+  0x1F09, //AGCTIME[23:16] 10011000
+  0x1F0A, //AGCTIME[15:8] 10010110
+  0x1F0B, //AGCTIME[7:0] 10000000
+  0x1F0C, //ANTTIME[31:24] 00000000
+  0x1F0D, //ANTTIME[23:16] 00000011
+  0x1F0E, //ANTTIME[15:8] 10010000
+  0x1F0F, //ANTTIME[7:0] 10010000
+  0x1F11, //SYNCTIME[23:16] 10011000
+  0x1F12, //SYNCTIME[15:8] 10010110
+  0x1F13, //SYNCTIME[7:0] 10000000
+  0x1F14, //SNRTIME[31:24] 00000001
+  0x1F15, //SNRTIME[23:16] 01111101
+  0x1F16, //SNRTIME[15:8] 01111000
+  0x1F17, //SNRTIME[7:0] 01000000
+  0x1F19, //FECTIME[23:16] 00000000
+  0x1F1A, //FECTIME[15:8] 01110010
+  0x1F1B, //FECTIME[7:0] 01110000
+  0x1F1D, //FECTHD[7:0] 00000011
+  0x1F1F, //SNRTHD[23:16] 00001000
+  0x1F20, //SNRTHD[15:8] 01111111
+  0x1F21, //SNRTHD[7:0] 10000101
+  0x1F80, //IRQFLG x x SFSDRFLG MODEBFLG SAVEFLG SCANFLG TRACKFLG
+  0x1F81, //x SYNCCON SNRCON FECCON x STDBUSY SYNCRST AGCFZCO
+  0x1F82, //x x x SCANOPCD[4:0]
+  0x1F83, //x x x x MAINOPCD[3:0]
+  0x1F84, //x x RXDATA[13:8]
+  0x1F85, //RXDATA[7:0]
+  0x1F86, //x x SDTDATA[13:8]
+  0x1F87, //SDTDATA[7:0]
+  0x1F89, //ANTSNR[23:16]
+  0x1F8A, //ANTSNR[15:8]
+  0x1F8B, //ANTSNR[7:0]
+  0x1F8C, //x x x x ANTFEC[13:8]
+  0x1F8D, //ANTFEC[7:0]
+  0x1F8E, //MAXCNT[7:0]
+  0x1F8F, //SCANCNT[7:0]
+  0x1F91, //MAXPW[23:16]
+  0x1F92, //MAXPW[15:8]
+  0x1F93, //MAXPW[7:0]
+  0x1F95, //CURPWMSE[23:16]
+  0x1F96, //CURPWMSE[15:8]
+  0x1F97, //CURPWMSE[7:0]
+#endif//SMART_ANT
+  0x211F, //1'b1 1'b1 1'b1 CIRQEN x x 1'b0 1'b0 1111xx00
+  0x212A, //EQAUTOST
+  0x2122, //CHFAST[7:0] 01100000
+  0x212B, //FFFSTEP_V[3:0] x FBFSTEP_V[2:0] 0001x001
+  0x212C, //PHDEROTBWSEL[3:0] 1'b1 1'b1 1'b1 1'b0 10001110
+  0x212D, //1'b1 1'b1 1'b1 1'b1 x x TPIFLOCKS
+  0x2135, //DYNTRACKFDEQ[3:0] x 1'b0 1'b0 1'b0 1010x000
+  0x2141, //TRMODE[1:0] 1'b1 1'b1 1'b0 1'b1 1'b1 1'b1 01110111
+  0x2162, //AICCCTRLE
+  0x2173, //PHNCNFCNT[7:0] 00000100
+  0x2179, //1'b0 1'b0 1'b0 1'b1 x BADSINGLEDYNTRACKFBF[2:0] 0001x001
+  0x217A, //1'b0 1'b0 1'b0 1'b1 x BADSLOWSINGLEDYNTRACKFBF[2:0] 0001x001
+  0x217E, //CNFCNTTPIF[7:0] 00001000
+  0x217F, //TPERRCNTTPIF[7:0] 00000001
+  0x2180, //x x x x x x FBDLYCIR[9:8]
+  0x2181, //FBDLYCIR[7:0]
+  0x2185, //MAXPWRMAIN[7:0]
+  0x2191, //NCOMBDET x x x x x x x
+  0x2199, //x MAINSTRON
+  0x219A, //FFFEQSTEPOUT_V[3:0] FBFSTEPOUT_V[2:0]
+  0x21A1, //x x SNRREF[5:0]
+  0x2845, //1'b0 1'b1 x x FFFSTEP_CQS[1:0] FFFCENTERTAP[1:0] 01xx1110
+  0x2846, //1'b0 x 1'b0 1'b1 FBFSTEP_CQS[1:0] 1'b1 1'b0 0x011110
+  0x2847, //ENNOSIGDE
+  0x2849, //1'b1 1'b1 NOUSENOSI
+  0x284A, //EQINITWAITTIME[7:0] 01100100
+  0x3000, //1'b1 1'b1 1'b1 x x x 1'b0 RPTRSTM
+  0x3001, //RPTRSTWAITTIME[7:0] (100msec) 00110010
+  0x3031, //FRAMELOC
+  0x3032, //1'b1 1'b0 1'b0 1'b0 x x FRAMELOCKMODE_CQS[1:0] 1000xx11
+  0x30A9, //VDLOCK_Q FRAMELOCK
+  0x30AA, //MPEGLOCK
+};
+
+#define numDumpRegs  (sizeof(regtab)/sizeof(regtab[0]))
+static u8 regval1[numDumpRegs] = {0, };
+static u8 regval2[numDumpRegs] = {0, };
+
+static void lgdt3306a_DumpAllRegs(struct lgdt3306a_state *state)
+{
+		memset(regval2, 0xff, sizeof(regval2));
+		lgdt3306a_DumpRegs(state);
+}
+
+static void lgdt3306a_DumpRegs(struct lgdt3306a_state *state)
+{
+	int i;
+	int sav_debug = debug;
+	if ((debug & DBG_DUMP) == 0)
+		return;
+	debug &= ~DBG_REG;//supress DBG_REG during reg dump
+
+	lg_info("\n");
+
+	for(i=0; i<numDumpRegs; i++){
+		lgdt3306a_read_reg(state, regtab[i], &regval1[i]);
+		if(regval1[i] != regval2[i]){
+		lg_info(" %04X = %02X\n", regtab[i], regval1[i]);
+			regval2[i] = regval1[i];
+		}
+	}
+	debug = sav_debug;
+}
+#endif//DBG_DUMP
+
+
+
+EXPORT_SYMBOL(lgdt3306a_attach);
+
+static struct dvb_frontend_ops lgdt3306a_ops = {
+	.delsys = { SYS_ATSC, SYS_DVBC_ANNEX_B },
+	.info = {
+		.name = "LG Electronics LGDT3306A VSB/QAM Frontend",
+//		.type               = FE_ATSC,
+		.frequency_min      = 54000000,
+		.frequency_max      = 858000000, //FGR - BUGBUG - why does the demod have a freq limit??
+										 //  also, it's too high for ATSC Ch 52, and too low for Ch 158 Cable
+		.frequency_stepsize = 62500,
+		.caps = FE_CAN_QAM_64 | FE_CAN_QAM_256 | FE_CAN_8VSB
+	},
+	.i2c_gate_ctrl        = lgdt3306a_i2c_gate_ctrl,
+	.init                 = lgdt3306a_init,
+	.sleep                = lgdt3306a_fe_sleep,
+	/* if this is set, it overrides the default swzigzag */
+	.tune                 = lgdt3306a_tune,
+	.set_frontend         = lgdt3306a_set_parameters,
+	.get_frontend         = lgdt3306a_get_frontend,
+	.get_frontend_algo    = lgdt3306a_get_frontend_algo,
+	.get_tune_settings    = lgdt3306a_get_tune_settings,
+	.read_status          = lgdt3306a_read_status,
+	.read_ber             = lgdt3306a_read_ber,
+	.read_signal_strength = lgdt3306a_read_signal_strength,
+	.read_snr             = lgdt3306a_read_snr,
+	.read_ucblocks        = lgdt3306a_read_ucblocks,
+	.release              = lgdt3306a_release,
+	.ts_bus_ctrl          = lgdt3306a_ts_bus_ctrl,
+	.search               = lgdt3306a_search,
+};
+
+MODULE_DESCRIPTION("LG Electronics LGDT3306A ATSC/QAM-B Demodulator Driver");
+MODULE_AUTHOR("Fred Richter <frichter@hauppauge.com>");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("0.2");
+
+/*
+ * Local variables:
+ * c-basic-offset: 8
+ * End:
+ */
