commit 85872f861d4cc535b0dbfd0a9062bdbdcbed20c3
Author: Stanimir Varbanov <stanimir.varbanov@linaro.org>
Date:   Fri Apr 3 17:56:29 2020 +0200

    media: venus: Mark last capture buffer
    
    According to stateful Codec API the decoder will process all
    remaining buffers from before the source change event in
    dynamic-resolution-change state and mark the last buffer with
    V4L2_BUF_FLAG_LAST.
    
    In Venus case the firmware doesn't mark that last buffer and
    some mechanism have to be created in v4l decoder driver.
    Fortunately the firmware interface (HFI) claims that the
    decoder output buffers will be returned to v4l decoder
    driver before it send the insufficient event.
    
    In order to do that we save last queued in the driver capture
    buffer in the event_notify and issue flush on output firmware
    buffers queue. Once the saved buffer is returned (as a result of
    flush command) we mark it as LAST. For all that possible we
    extend HFI flush command with one more argument and one more
    flush_done HFI driver callback.
    
    Signed-off-by: Stanimir Varbanov <stanimir.varbanov@linaro.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+huawei@kernel.org>

diff --git a/drivers/media/platform/qcom/venus/core.h b/drivers/media/platform/qcom/venus/core.h
index 3ab644a39786..7118612673c9 100644
--- a/drivers/media/platform/qcom/venus/core.h
+++ b/drivers/media/platform/qcom/venus/core.h
@@ -261,7 +261,8 @@ enum venus_dec_state {
 	VENUS_DEC_STATE_SEEK		= 4,
 	VENUS_DEC_STATE_DRAIN		= 5,
 	VENUS_DEC_STATE_DECODING	= 6,
-	VENUS_DEC_STATE_DRC		= 7
+	VENUS_DEC_STATE_DRC		= 7,
+	VENUS_DEC_STATE_DRC_FLUSH_DONE	= 8,
 };
 
 struct venus_ts_metadata {
@@ -326,6 +327,7 @@ struct venus_ts_metadata {
  * @priv:	a private for HFI operations callbacks
  * @session_type:	the type of the session (decoder or encoder)
  * @hprop:	a union used as a holder by get property
+ * @last_buf:	last capture buffer for dynamic-resoluton-change
  */
 struct venus_inst {
 	struct list_head list;
@@ -387,6 +389,7 @@ struct venus_inst {
 	union hfi_get_property hprop;
 	unsigned int core_acquired: 1;
 	unsigned int bit_depth;
+	struct vb2_buffer *last_buf;
 };
 
 #define IS_V1(core)	((core)->res->hfi_version == HFI_VERSION_1XX)

commit 63342afea65e9efa06889775c27001745e157770
Author: Stanimir Varbanov <stanimir.varbanov@linaro.org>
Date:   Thu Jan 30 16:44:24 2020 +0100

    media: venus: vdec: Use pmruntime autosuspend
    
    Implement pmruntime autosuspend in video decoder. This will
    allow to save power while the userspace is inactive for some
    reasonable period of time. Here we power-off venus core clocks
    and power domain and don't touch vcodec because it is under
    hardware control. The later decision is made to simplify the
    code and avoid a mess in the power management code.
    
    Signed-off-by: Stanimir Varbanov <stanimir.varbanov@linaro.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+huawei@kernel.org>

diff --git a/drivers/media/platform/qcom/venus/core.h b/drivers/media/platform/qcom/venus/core.h
index bd3ac6a4501f..3ab644a39786 100644
--- a/drivers/media/platform/qcom/venus/core.h
+++ b/drivers/media/platform/qcom/venus/core.h
@@ -128,6 +128,7 @@ struct venus_caps {
  * @error:	an error returned during last HFI sync operations
  * @sys_error:	an error flag that signal system error event
  * @core_ops:	the core operations
+ * @pm_lock:	a lock for PM operations
  * @enc_codecs:	encoders supported by this core
  * @dec_codecs:	decoders supported by this core
  * @max_sessions_supported:	holds the maximum number of sessions
@@ -168,6 +169,7 @@ struct venus_core {
 	bool sys_error;
 	const struct hfi_core_ops *core_ops;
 	const struct venus_pm_ops *pm_ops;
+	struct mutex pm_lock;
 	unsigned long enc_codecs;
 	unsigned long dec_codecs;
 	unsigned int max_sessions_supported;

commit 6f704b2fbbde0c9893ea59d54d76195d72ac63a1
Author: Jeffrey Kardatzke <jkardatzke@google.com>
Date:   Sat Feb 22 01:33:11 2020 +0100

    media: venus: support frame rate control
    
    Add encoder control for enabling/disabling frame rate control via
    V4L2_CID_MPEG_VIDEO_FRAME_RC_ENABLE. It is enabled by default.
    
    Signed-off-by: Jeffrey Kardatzke <jkardatzke@google.com>
    Signed-off-by: Stanimir Varbanov <stanimir.varbanov@linaro.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+huawei@kernel.org>

diff --git a/drivers/media/platform/qcom/venus/core.h b/drivers/media/platform/qcom/venus/core.h
index ab7c360fa484..bd3ac6a4501f 100644
--- a/drivers/media/platform/qcom/venus/core.h
+++ b/drivers/media/platform/qcom/venus/core.h
@@ -198,6 +198,7 @@ struct venc_controls {
 	u32 bitrate_mode;
 	u32 bitrate;
 	u32 bitrate_peak;
+	u32 rc_enable;
 
 	u32 h264_i_period;
 	u32 h264_entropy_mode;

commit ab1eda449c6eef5067538b034c7561eb9e053362
Author: Aniket Masule <amasule@codeaurora.org>
Date:   Wed Dec 4 11:18:40 2019 +0100

    media: venus: vdec: handle 10bit bitstreams
    
    Handle 10bit video streams in the decoder by using dithering, i.e
    the decoder output buffers will be in 8bit format.
    
    The runtime handling is implemented by sending v4l2 event to
    userspace application, then the application should stop the
    streaming on capture queue and initiate format negotiation, and
    start streaming again.
    
    Signed-off-by: Aniket Masule <amasule@codeaurora.org>
    Co-developed-by: Stanimir Varbanov <stanimir.varbanov@linaro.org>
    Signed-off-by: Stanimir Varbanov <stanimir.varbanov@linaro.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+huawei@kernel.org>

diff --git a/drivers/media/platform/qcom/venus/core.h b/drivers/media/platform/qcom/venus/core.h
index bba29e4680f9..ab7c360fa484 100644
--- a/drivers/media/platform/qcom/venus/core.h
+++ b/drivers/media/platform/qcom/venus/core.h
@@ -383,6 +383,7 @@ struct venus_inst {
 	u32 session_type;
 	union hfi_get_property hprop;
 	unsigned int core_acquired: 1;
+	unsigned int bit_depth;
 };
 
 #define IS_V1(core)	((core)->res->hfi_version == HFI_VERSION_1XX)

commit 4ebf969375bca2cef03573d23416423cec1af814
Author: Aniket Masule <amasule@codeaurora.org>
Date:   Mon Dec 2 17:44:41 2019 +0100

    media: venus: introduce core selection
    
    Presently the core (vcodec pipelines) assignment is static. Here we
    introduce dynamic load balancing across the cores depending on the
    current session load. The load on earch core is calculated and core
    with minimum load is assigned to given instance. This will be
    applicable on Venus v4 with more than one vcodec cores.
    
    Signed-off-by: Aniket Masule <amasule@codeaurora.org>
    Co-developed-by: Stanimir Varbanov <stanimir.varbanov@linaro.org>
    Signed-off-by: Stanimir Varbanov <stanimir.varbanov@linaro.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+huawei@kernel.org>

diff --git a/drivers/media/platform/qcom/venus/core.h b/drivers/media/platform/qcom/venus/core.h
index e587fd7e13c3..bba29e4680f9 100644
--- a/drivers/media/platform/qcom/venus/core.h
+++ b/drivers/media/platform/qcom/venus/core.h
@@ -181,6 +181,8 @@ struct venus_core {
 	struct delayed_work work;
 	struct venus_caps caps[MAX_CODEC_NUM];
 	unsigned int codecs_count;
+	unsigned int core0_usage_count;
+	unsigned int core1_usage_count;
 };
 
 struct vdec_controls {
@@ -380,6 +382,7 @@ struct venus_inst {
 	const struct hfi_inst_ops *ops;
 	u32 session_type;
 	union hfi_get_property hprop;
+	unsigned int core_acquired: 1;
 };
 
 #define IS_V1(core)	((core)->res->hfi_version == HFI_VERSION_1XX)

commit 7482a983dea3b8dc7590096f2afd532af6a5f2d2
Author: Stanimir Varbanov <stanimir.varbanov@linaro.org>
Date:   Thu Dec 5 16:29:48 2019 +0100

    media: venus: redesign clocks and pm domains control
    
    Redesign core (vcodec) clock control to give the venus core more
    freedom to control them in order to make possible to use core
    selection feature on Venus IP v4.
    
    Move all clock and pmdomain functions in separate file and abstract
    power control with common operations per Venus IP version.
    
    Signed-off-by: Stanimir Varbanov <stanimir.varbanov@linaro.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+huawei@kernel.org>

diff --git a/drivers/media/platform/qcom/venus/core.h b/drivers/media/platform/qcom/venus/core.h
index 2f661af7f873..e587fd7e13c3 100644
--- a/drivers/media/platform/qcom/venus/core.h
+++ b/drivers/media/platform/qcom/venus/core.h
@@ -14,7 +14,9 @@
 
 #include "hfi.h"
 
-#define VIDC_CLKS_NUM_MAX	4
+#define VIDC_CLKS_NUM_MAX		4
+#define VIDC_VCODEC_CLKS_NUM_MAX	2
+#define VIDC_PMDOMAINS_NUM_MAX		3
 
 struct freq_tbl {
 	unsigned int load;
@@ -55,6 +57,12 @@ struct venus_resources {
 	unsigned int codec_freq_data_size;
 	const char * const clks[VIDC_CLKS_NUM_MAX];
 	unsigned int clks_num;
+	const char * const vcodec0_clks[VIDC_VCODEC_CLKS_NUM_MAX];
+	const char * const vcodec1_clks[VIDC_VCODEC_CLKS_NUM_MAX];
+	unsigned int vcodec_clks_num;
+	const char * const vcodec_pmdomains[VIDC_PMDOMAINS_NUM_MAX];
+	unsigned int vcodec_pmdomains_num;
+	unsigned int vcodec_num;
 	enum hfi_version hfi_version;
 	u32 max_load;
 	unsigned int vmem_id;
@@ -100,10 +108,10 @@ struct venus_caps {
  * @base:	IO memory base address
  * @irq:		Venus irq
  * @clks:	an array of struct clk pointers
- * @core0_clk:	a struct clk pointer for core0
- * @core1_clk:	a struct clk pointer for core1
- * @core0_bus_clk: a struct clk pointer for core0 bus clock
- * @core1_bus_clk: a struct clk pointer for core1 bus clock
+ * @vcodec0_clks: an array of vcodec0 struct clk pointers
+ * @vcodec1_clks: an array of vcodec1 struct clk pointers
+ * @pd_dl_venus: pmdomain device-link for venus domain
+ * @pmdomains:	an array of pmdomains struct device pointers
  * @vdev_dec:	a reference to video device structure for decoder instances
  * @vdev_enc:	a reference to video device structure for encoder instances
  * @v4l2_dev:	a holder for v4l2 device structure
@@ -132,12 +140,12 @@ struct venus_core {
 	void __iomem *base;
 	int irq;
 	struct clk *clks[VIDC_CLKS_NUM_MAX];
-	struct clk *core0_clk;
-	struct clk *core1_clk;
-	struct clk *core0_bus_clk;
-	struct clk *core1_bus_clk;
+	struct clk *vcodec0_clks[VIDC_VCODEC_CLKS_NUM_MAX];
+	struct clk *vcodec1_clks[VIDC_VCODEC_CLKS_NUM_MAX];
 	struct icc_path *video_path;
 	struct icc_path *cpucfg_path;
+	struct device_link *pd_dl_venus;
+	struct device *pmdomains[VIDC_PMDOMAINS_NUM_MAX];
 	struct video_device *vdev_dec;
 	struct video_device *vdev_enc;
 	struct v4l2_device v4l2_dev;
@@ -159,6 +167,7 @@ struct venus_core {
 	unsigned int error;
 	bool sys_error;
 	const struct hfi_core_ops *core_ops;
+	const struct venus_pm_ops *pm_ops;
 	unsigned long enc_codecs;
 	unsigned long dec_codecs;
 	unsigned int max_sessions_supported;

commit fd1ee315dcd4a0f913a74939eb88f6d9b0bd9250
Author: Stanimir Varbanov <stanimir.varbanov@linaro.org>
Date:   Thu Feb 13 10:55:14 2020 +0100

    media: venus: cache vb payload to be used by clock scaling
    
    Instead of iterate over previously queued buffers in clock
    scaling code do cache the payload in instance context structure
    for later use when calculating new clock rate.
    
    This will avoid to use spin locks during buffer list iteration
    in clock_scaling.
    
    This fixes following kernel Oops:
    
     Unable to handle kernel paging request at virtual address deacfffffffffd6c
     Mem abort info:
       ESR = 0x96000004
       EC = 0x25: DABT (current EL), IL = 32 bits
       SET = 0, FnV = 0
       EA = 0, S1PTW = 0
     Data abort info:
       ISV = 0, ISS = 0x00000004
       CM = 0, WnR = 0
     [deacfffffffffd6c] address between user and kernel address ranges
     Internal error: Oops: 96000004 [#1] PREEMPT SMP
     CPU: 7 PID: 5763 Comm: V4L2DecoderThre Tainted: G S      W         5.4.11 #8
     pstate: 20400009 (nzCv daif +PAN -UAO)
     pc : load_scale_v4+0x4c/0x2bc [venus_core]
     lr : session_process_buf+0x18c/0x1c0 [venus_core]
     sp : ffffffc01376b8d0
     x29: ffffffc01376b8d0 x28: ffffff80cf1b0220
     x27: ffffffc01376bba0 x26: ffffffd8f562b2d8
     x25: ffffff80cf1b0220 x24: 0000000000000005
     x23: ffffffd8f5620d98 x22: ffffff80ca01c800
     x21: ffffff80cf1b0000 x20: ffffff8149490080
     x19: ffffff8174b2c010 x18: 0000000000000000
     x17: 0000000000000000 x16: ffffffd96ee3a0dc
     x15: 0000000000000026 x14: 0000000000000026
     x13: 00000000000055ac x12: 0000000000000001
     x11: deacfffffffffd6c x10: dead000000000100
     x9 : ffffff80ca01cf28 x8 : 0000000000000026
     x7 : 0000000000000000 x6 : ffffff80cdd899c0
     x5 : ffffff80cdd899c0 x4 : 0000000000000008
     x3 : ffffff80ca01cf28 x2 : ffffff80ca01cf28
     x1 : ffffff80d47ffc00 x0 : ffffff80cf1b0000
     Call trace:
      load_scale_v4+0x4c/0x2bc [venus_core]
      session_process_buf+0x18c/0x1c0 [venus_core]
      venus_helper_vb2_buf_queue+0x7c/0xf0 [venus_core]
      __enqueue_in_driver+0xe4/0xfc [videobuf2_common]
      vb2_core_qbuf+0x15c/0x338 [videobuf2_common]
      vb2_qbuf+0x78/0xb8 [videobuf2_v4l2]
      v4l2_m2m_qbuf+0x80/0xf8 [v4l2_mem2mem]
      v4l2_m2m_ioctl_qbuf+0x2c/0x38 [v4l2_mem2mem]
      v4l_qbuf+0x48/0x58
      __video_do_ioctl+0x2b0/0x39c
      video_usercopy+0x394/0x710
      video_ioctl2+0x38/0x48
      v4l2_ioctl+0x6c/0x80
      do_video_ioctl+0xb00/0x2874
      v4l2_compat_ioctl32+0x5c/0xcc
      __se_compat_sys_ioctl+0x100/0x2074
      __arm64_compat_sys_ioctl+0x20/0x2c
      el0_svc_common+0xa4/0x154
      el0_svc_compat_handler+0x2c/0x38
      el0_svc_compat+0x8/0x10
     Code: eb0a013f 54000200 aa1f03e8 d10e514b (b940016c)
     ---[ end trace e11304b46552e0b9 ]---
    
    Fixes: c0e284ccfeda ("media: venus: Update clock scaling")
    
    Cc: stable@vger.kernel.org # v5.5+
    Signed-off-by: Stanimir Varbanov <stanimir.varbanov@linaro.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+huawei@kernel.org>

diff --git a/drivers/media/platform/qcom/venus/core.h b/drivers/media/platform/qcom/venus/core.h
index 11585fb3cae3..2f661af7f873 100644
--- a/drivers/media/platform/qcom/venus/core.h
+++ b/drivers/media/platform/qcom/venus/core.h
@@ -344,6 +344,7 @@ struct venus_inst {
 	unsigned int subscriptions;
 	int buf_count;
 	struct venus_ts_metadata tss[VIDEO_MAX_FRAME];
+	unsigned long payloads[VIDEO_MAX_FRAME];
 	u64 fps;
 	struct v4l2_fract timeperframe;
 	const struct venus_format *fmt_out;

commit e5b7fabb78f2793146104cba525d24d3236d400b
Author: Aniket Masule <amasule@codeaurora.org>
Date:   Tue Sep 24 02:47:48 2019 -0300

    media: venus: Add codec data table
    
    Add vpp cycles for different types of codec.
    It indicates the cycles required by video hardware
    to process each macroblock. Add vsp cycles, cycles
    required by stream processor. Initialize the codec
    data with core resources.
    
    Signed-off-by: Aniket Masule <amasule@codeaurora.org>
    Signed-off-by: Stanimir Varbanov <stanimir.varbanov@linaro.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/platform/qcom/venus/core.h b/drivers/media/platform/qcom/venus/core.h
index 661eaa7b81ec..11585fb3cae3 100644
--- a/drivers/media/platform/qcom/venus/core.h
+++ b/drivers/media/platform/qcom/venus/core.h
@@ -26,6 +26,13 @@ struct reg_val {
 	u32 value;
 };
 
+struct codec_freq_data {
+	u32 pixfmt;
+	u32 session_type;
+	unsigned long vpp_freq;
+	unsigned long vsp_freq;
+};
+
 struct bw_tbl {
 	u32 mbs_per_sec;
 	u32 avg;
@@ -44,6 +51,8 @@ struct venus_resources {
 	unsigned int bw_tbl_dec_size;
 	const struct reg_val *reg_tbl;
 	unsigned int reg_tbl_size;
+	const struct codec_freq_data *codec_freq_data;
+	unsigned int codec_freq_data_size;
 	const char * const clks[VIDC_CLKS_NUM_MAX];
 	unsigned int clks_num;
 	enum hfi_version hfi_version;
@@ -222,6 +231,12 @@ struct venus_buffer {
 	struct list_head ref_list;
 };
 
+struct clock_data {
+	u32 core_id;
+	unsigned long freq;
+	const struct codec_freq_data *codec_freq_data;
+};
+
 #define to_venus_buffer(ptr)	container_of(ptr, struct venus_buffer, vb)
 
 enum venus_dec_state {
@@ -302,6 +317,7 @@ struct venus_inst {
 	struct list_head list;
 	struct mutex lock;
 	struct venus_core *core;
+	struct clock_data clk_data;
 	struct list_head dpbbufs;
 	struct list_head internalbufs;
 	struct list_head registeredbufs;

commit 32f0a6ddc8c98a1aade2bf3d07c79d5d2c6ceb9a
Author: Stanimir Varbanov <stanimir.varbanov@linaro.org>
Date:   Tue Aug 13 12:25:08 2019 -0300

    media: venus: Use on-chip interconnect API
    
    This aims to add a requests for bandwidth scaling depending
    on the resolution and framerate (macroblocks per second). The
    exact value of the requested bandwidth is get from a
    pre-calculated tables for encoder and decoder.
    
    Acked-by: Georgi Djakov <georgi.djakov@linaro.org>
    Signed-off-by: Stanimir Varbanov <stanimir.varbanov@linaro.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/platform/qcom/venus/core.h b/drivers/media/platform/qcom/venus/core.h
index 922cb7e64bfa..661eaa7b81ec 100644
--- a/drivers/media/platform/qcom/venus/core.h
+++ b/drivers/media/platform/qcom/venus/core.h
@@ -26,10 +26,22 @@ struct reg_val {
 	u32 value;
 };
 
+struct bw_tbl {
+	u32 mbs_per_sec;
+	u32 avg;
+	u32 peak;
+	u32 avg_10bit;
+	u32 peak_10bit;
+};
+
 struct venus_resources {
 	u64 dma_mask;
 	const struct freq_tbl *freq_tbl;
 	unsigned int freq_tbl_size;
+	const struct bw_tbl *bw_tbl_enc;
+	unsigned int bw_tbl_enc_size;
+	const struct bw_tbl *bw_tbl_dec;
+	unsigned int bw_tbl_dec_size;
 	const struct reg_val *reg_tbl;
 	unsigned int reg_tbl_size;
 	const char * const clks[VIDC_CLKS_NUM_MAX];
@@ -115,6 +127,8 @@ struct venus_core {
 	struct clk *core1_clk;
 	struct clk *core0_bus_clk;
 	struct clk *core1_bus_clk;
+	struct icc_path *video_path;
+	struct icc_path *cpucfg_path;
 	struct video_device *vdev_dec;
 	struct video_device *vdev_enc;
 	struct v4l2_device v4l2_dev;

commit 5aecb7d030370fc76cfd15649c218ba702c46b29
Author: Maxime Jourdan <mjourdan@baylibre.com>
Date:   Thu Aug 15 11:44:47 2019 -0300

    media: venus: vdec: flag OUTPUT formats with V4L2_FMT_FLAG_DYN_RESOLUTION
    
    Tag all the coded formats where the venus vdec supports dynamic
    resolution switching.
    
    Signed-off-by: Maxime Jourdan <mjourdan@baylibre.com>
    Acked-by: Stanimir Varbanov <stanimir.varbanov@linaro.org>
    Reviewed-by: Paul Kocialkowski <paul.kocialkowski@bootlin.com>
    Signed-off-by: Hans Verkuil <hverkuil-cisco@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/platform/qcom/venus/core.h b/drivers/media/platform/qcom/venus/core.h
index 959eaa550f4e..922cb7e64bfa 100644
--- a/drivers/media/platform/qcom/venus/core.h
+++ b/drivers/media/platform/qcom/venus/core.h
@@ -46,6 +46,7 @@ struct venus_format {
 	u32 pixfmt;
 	unsigned int num_planes;
 	u32 type;
+	u32 flags;
 };
 
 #define MAX_PLANES		4

commit d42974e438feebda372fe4a39d7761cc596abc57
Author: Stanimir Varbanov <stanimir.varbanov@linaro.org>
Date:   Thu Jun 27 12:59:11 2019 -0300

    media: venus: dec: populate properly timestamps and flags for capture buffers
    
    Cache flags, timestamps and timecode structure of OUTPUT buffers
    in per-instance structure array and fill correctly the same when
    the CAPTURE buffers are done.
    
    This will make v4l2-compliance decoder streaming test happy.
    
    Signed-off-by: Stanimir Varbanov <stanimir.varbanov@linaro.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/platform/qcom/venus/core.h b/drivers/media/platform/qcom/venus/core.h
index 1a28ca07cd84..959eaa550f4e 100644
--- a/drivers/media/platform/qcom/venus/core.h
+++ b/drivers/media/platform/qcom/venus/core.h
@@ -220,6 +220,14 @@ enum venus_dec_state {
 	VENUS_DEC_STATE_DRC		= 7
 };
 
+struct venus_ts_metadata {
+	bool used;
+	u64 ts_ns;
+	u64 ts_us;
+	u32 flags;
+	struct v4l2_timecode tc;
+};
+
 /**
  * struct venus_inst - holds per instance parameters
  *
@@ -304,6 +312,7 @@ struct venus_inst {
 	wait_queue_head_t reconf_wait;
 	unsigned int subscriptions;
 	int buf_count;
+	struct venus_ts_metadata tss[VIDEO_MAX_FRAME];
 	u64 fps;
 	struct v4l2_fract timeperframe;
 	const struct venus_format *fmt_out;

commit beac82904a870b220d45b883e493b869d8d0dce5
Author: Stanimir Varbanov <stanimir.varbanov@linaro.org>
Date:   Thu Jan 17 07:43:31 2019 -0200

    media: venus: make decoder compliant with stateful codec API
    
    This refactors code for start/stop streaming vb2 operations and
    adds a state machine handling similar to the one in stateful codec
    API documentation. One major change is that now the HFI session is
    started on STREAMON(OUTPUT) and stopped on REQBUF(OUTPUT,count=0),
    during that time STREAMOFF(CAP,OUT) just flush buffers but doesn't
    stop the session. The other major change is that now the capture
    and output queues are completely separated.
    
    Signed-off-by: Stanimir Varbanov <stanimir.varbanov@linaro.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/platform/qcom/venus/core.h b/drivers/media/platform/qcom/venus/core.h
index 9ab95fd57760..1a28ca07cd84 100644
--- a/drivers/media/platform/qcom/venus/core.h
+++ b/drivers/media/platform/qcom/venus/core.h
@@ -209,6 +209,17 @@ struct venus_buffer {
 
 #define to_venus_buffer(ptr)	container_of(ptr, struct venus_buffer, vb)
 
+enum venus_dec_state {
+	VENUS_DEC_STATE_DEINIT		= 0,
+	VENUS_DEC_STATE_INIT		= 1,
+	VENUS_DEC_STATE_CAPTURE_SETUP	= 2,
+	VENUS_DEC_STATE_STOPPED		= 3,
+	VENUS_DEC_STATE_SEEK		= 4,
+	VENUS_DEC_STATE_DRAIN		= 5,
+	VENUS_DEC_STATE_DECODING	= 6,
+	VENUS_DEC_STATE_DRC		= 7
+};
+
 /**
  * struct venus_inst - holds per instance parameters
  *
@@ -232,6 +243,10 @@ struct venus_buffer {
  * @colorspace:	current color space
  * @quantization:	current quantization
  * @xfer_func:	current xfer function
+ * @codec_state:	current codec API state (see DEC/ENC_STATE_)
+ * @reconf_wait:	wait queue for resolution change event
+ * @subscriptions:	used to hold current events subscriptions
+ * @buf_count:		used to count number of buffers (reqbuf(0))
  * @fps:		holds current FPS
  * @timeperframe:	holds current time per frame structure
  * @fmt_out:	a reference to output format structure
@@ -246,8 +261,6 @@ struct venus_buffer {
  * @opb_buftype:	output picture buffer type
  * @opb_fmt:		output picture buffer raw format
  * @reconfig:	a flag raised by decoder when the stream resolution changed
- * @reconfig_width:	holds the new width
- * @reconfig_height:	holds the new height
  * @hfi_codec:		current codec for this instance in HFI space
  * @sequence_cap:	a sequence counter for capture queue
  * @sequence_out:	a sequence counter for output queue
@@ -287,6 +300,10 @@ struct venus_inst {
 	u8 ycbcr_enc;
 	u8 quantization;
 	u8 xfer_func;
+	enum venus_dec_state codec_state;
+	wait_queue_head_t reconf_wait;
+	unsigned int subscriptions;
+	int buf_count;
 	u64 fps;
 	struct v4l2_fract timeperframe;
 	const struct venus_format *fmt_out;
@@ -301,8 +318,6 @@ struct venus_inst {
 	u32 opb_buftype;
 	u32 opb_fmt;
 	bool reconfig;
-	u32 reconfig_width;
-	u32 reconfig_height;
 	u32 hfi_codec;
 	u32 sequence_cap;
 	u32 sequence_out;

commit 97fb5e8d9b57f10f294303c9a5d1bd033eded6bf
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 07:17:58 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 284
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 and
      only version 2 as published by the free software foundation this
      program is distributed in the hope that it will be useful but
      without any warranty without even the implied warranty of
      merchantability or fitness for a particular purpose see the gnu
      general public license for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 294 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190529141900.825281744@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/media/platform/qcom/venus/core.h b/drivers/media/platform/qcom/venus/core.h
index 7a3feb5cee00..9ab95fd57760 100644
--- a/drivers/media/platform/qcom/venus/core.h
+++ b/drivers/media/platform/qcom/venus/core.h
@@ -1,16 +1,7 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * Copyright (c) 2012-2016, The Linux Foundation. All rights reserved.
  * Copyright (C) 2017 Linaro Ltd.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 and
- * only version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
  */
 
 #ifndef __VENUS_CORE_H_

commit 8b72c18d467fad497fe73c59915556e32bc5241d
Author: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
Date:   Mon Feb 18 14:29:00 2019 -0500

    media: platform: fix several typos
    
    Use codespell to fix lots of typos over frontends.
    
    Manually verified to avoid false-positives.
    
    Reviewed-by: Niklas SÃ¶derlund <niklas.soderlund+renesas@ragnatech.se>
    Acked-by: Andrzej Pietrasiewicz <andrzejtp2010@gmail.com>
    Reviewed-by: Benoit Parrot <bparrot@ti.com>
    Reviewed-by: Kieran Bingham <kieran.bingham+renesas@ideasonboard.com>
    Reviewed-by: Lad, Prabhakar <prabhakar.csengg@gmail.com>
    Acked-by: Philipp Zabel <p.zabel@pengutronix.de>
    Reviewed-by: Houlong Wei <houlong.wei@mediatek.com>
    Reviewed-by: Yong Deng <yong.deng@magewell.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/platform/qcom/venus/core.h b/drivers/media/platform/qcom/venus/core.h
index 79c7e816c706..7a3feb5cee00 100644
--- a/drivers/media/platform/qcom/venus/core.h
+++ b/drivers/media/platform/qcom/venus/core.h
@@ -219,7 +219,7 @@ struct venus_buffer {
 #define to_venus_buffer(ptr)	container_of(ptr, struct venus_buffer, vb)
 
 /**
- * struct venus_inst - holds per instance paramerters
+ * struct venus_inst - holds per instance parameters
  *
  * @list:	used for attach an instance to the core
  * @lock:	instance lock

commit 5792ae7c3dd41883cdfa91284b802104b75c59d4
Author: Stanimir Varbanov <stanimir.varbanov@linaro.org>
Date:   Thu Dec 6 11:28:43 2018 -0200

    media: venus: firmware: check fw size against DT memory region size
    
    By historical reasons we defined firmware memory size to be 6MB even
    that the firmware size for all supported Venus versions is 5MBs. Correct
    that by compare the required firmware size returned from mdt loader and
    the one provided by DT reserved memory region. We proceed further if the
    required firmware size is smaller than provided by DT memory region.
    
    Reviewed-by: Alexandre Courbot <acourbot@chromium.org>
    Tested-by: Alexandre Courbot <acourbot@chromium.org>
    Signed-off-by: Stanimir Varbanov <stanimir.varbanov@linaro.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/platform/qcom/venus/core.h b/drivers/media/platform/qcom/venus/core.h
index 6382cea29185..79c7e816c706 100644
--- a/drivers/media/platform/qcom/venus/core.h
+++ b/drivers/media/platform/qcom/venus/core.h
@@ -134,6 +134,7 @@ struct venus_core {
 	struct video_firmware {
 		struct device *dev;
 		struct iommu_domain *iommu_domain;
+		size_t mapped_mem_size;
 	} fw;
 	struct mutex lock;
 	struct list_head instances;

commit df381dc8e475204fbcc58302ae2eb7860f4e4e1e
Author: Vikash Garodia <vgarodia@codeaurora.org>
Date:   Wed Oct 17 09:18:22 2018 -0400

    media: venus: firmware: add no TZ boot and shutdown routine
    
    Video hardware is mainly comprised of vcodec subsystem and video
    control subsystem. Video control has ARM9 which executes the video
    firmware instructions whereas vcodec does the video frame processing.
    This change adds support to load the video firmware and bring ARM9
    out of reset for platforms which does not have trustzone.
    An iommu domain is associated and managed with the firmware device.
    
    Signed-off-by: Vikash Garodia <vgarodia@codeaurora.org>
    Acked-by: Stanimir Varbanov <stanimir.varbanov@linaro.org>
    Reviewed-by: Alexandre Courbot <acourbot@chromium.org>
    Tested-by: Alexandre Courbot <acourbot@chromium.org>
    Signed-off-by: Hans Verkuil <hverkuil-cisco@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/platform/qcom/venus/core.h b/drivers/media/platform/qcom/venus/core.h
index c629666df234..6382cea29185 100644
--- a/drivers/media/platform/qcom/venus/core.h
+++ b/drivers/media/platform/qcom/venus/core.h
@@ -133,6 +133,7 @@ struct venus_core {
 	unsigned int use_tz;
 	struct video_firmware {
 		struct device *dev;
+		struct iommu_domain *iommu_domain;
 	} fw;
 	struct mutex lock;
 	struct list_head instances;

commit f9799fcce4bb383206c08a2ac960039efdfa4a2f
Author: Stanimir Varbanov <stanimir.varbanov@linaro.org>
Date:   Wed Oct 17 09:18:21 2018 -0400

    media: venus: firmware: register separate platform_device for firmware loader
    
    This registers a firmware platform_device and associate it with
    video-firmware DT subnode. Then calls dma configure to initialize
    dma and iommu.
    
    Signed-off-by: Stanimir Varbanov <stanimir.varbanov@linaro.org>
    Reviewed-by: Alexandre Courbot <acourbot@chromium.org>
    Tested-by: Alexandre Courbot <acourbot@chromium.org>
    Signed-off-by: Hans Verkuil <hverkuil-cisco@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/platform/qcom/venus/core.h b/drivers/media/platform/qcom/venus/core.h
index 8b85dc847b83..c629666df234 100644
--- a/drivers/media/platform/qcom/venus/core.h
+++ b/drivers/media/platform/qcom/venus/core.h
@@ -131,6 +131,9 @@ struct venus_core {
 	struct device *dev_dec;
 	struct device *dev_enc;
 	unsigned int use_tz;
+	struct video_firmware {
+		struct device *dev;
+	} fw;
 	struct mutex lock;
 	struct list_head instances;
 	atomic_t insts_count;

commit 5df317c8786b5ecef9ccb2d8df7b4f6f1bc5dcd1
Author: Vikash Garodia <vgarodia@codeaurora.org>
Date:   Wed Oct 17 09:18:19 2018 -0400

    media: venus: firmware: add routine to reset ARM9
    
    Add routine to reset the ARM9 and brings it out of reset. Also
    abstract the Venus CPU state handling with a new function. This
    is in preparation to add PIL functionality in venus driver.
    
    Signed-off-by: Vikash Garodia <vgarodia@codeaurora.org>
    Acked-by: Stanimir Varbanov <stanimir.varbanov@linaro.org>
    Reviewed-by: Alexandre Courbot <acourbot@chromium.org>
    Tested-by: Alexandre Courbot <acourbot@chromium.org>
    Signed-off-by: Hans Verkuil <hverkuil-cisco@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/platform/qcom/venus/core.h b/drivers/media/platform/qcom/venus/core.h
index 2f02365f4818..8b85dc847b83 100644
--- a/drivers/media/platform/qcom/venus/core.h
+++ b/drivers/media/platform/qcom/venus/core.h
@@ -98,6 +98,7 @@ struct venus_caps {
  * @dev:		convenience struct device pointer
  * @dev_dec:	convenience struct device pointer for decoder device
  * @dev_enc:	convenience struct device pointer for encoder device
+ * @use_tz:	a flag that suggests presence of trustzone
  * @lock:	a lock for this strucure
  * @instances:	a list_head of all instances
  * @insts_count:	num of instances
@@ -129,6 +130,7 @@ struct venus_core {
 	struct device *dev;
 	struct device *dev_dec;
 	struct device *dev_enc;
+	unsigned int use_tz;
 	struct mutex lock;
 	struct list_head instances;
 	atomic_t insts_count;

commit 1fb9a6055561c1e77e1660aba51b1075a4a06475
Author: Stanimir Varbanov <stanimir.varbanov@linaro.org>
Date:   Thu Jul 5 09:04:01 2018 -0400

    media: venus: add HEVC codec support
    
    This add HEVC codec support for venus versions 3xx and 4xx.
    
    Signed-off-by: Stanimir Varbanov <stanimir.varbanov@linaro.org>
    Reviewed-by: Tomasz Figa <tfiga@chromium.org>
    Reviewed-by: Alexandre Courbot <acourbot@chromium.org>
    Tested-by: Alexandre Courbot <acourbot@chromium.org>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/platform/qcom/venus/core.h b/drivers/media/platform/qcom/venus/core.h
index 8cc49f30a363..2f02365f4818 100644
--- a/drivers/media/platform/qcom/venus/core.h
+++ b/drivers/media/platform/qcom/venus/core.h
@@ -190,10 +190,12 @@ struct venc_controls {
 		u32 mpeg4;
 		u32 h264;
 		u32 vpx;
+		u32 hevc;
 	} profile;
 	struct {
 		u32 mpeg4;
 		u32 h264;
+		u32 hevc;
 	} level;
 };
 

commit f012b23d64e9879eca987627d9b9da3d9de56746
Author: Stanimir Varbanov <stanimir.varbanov@linaro.org>
Date:   Thu Jul 5 09:03:59 2018 -0400

    media: venus: implementing multi-stream support
    
    This is implementing multi-stream decoder support. The multi-stream
    will be used to enable/disable the primary/secondary decoder
    outputs. Depending on formats on both decoder outputs we could
    implement downscale, dithering and supporting UBWC (universal
    bandwidth compression) formats. The UBWC compressed raw format is
    used to optimize interconnect bandwidth for bigger resolutions
    like 4K and hence we will get some power-saving benefits as well.
    
    Both decoder outputs are distinguished by buffer_type field in
    the HFI packets. For example HFI_BUFFER_OUTPUT is the buffer type
    for primary decoder output and HFI_BUFFER_OUTPUT2 is for secondary
    decoder output.
    
    Starting from Venus 4xx the DPB buffers format must be UBWC, so
    the multi-stream becomes mandatory for this Venus version. That
    means that we need to allocate internally in the driver a set of
    DPB buffers (with UBWC NV12 format) and give them to the firmware.
    The other decoder output (we called it OPB) format will be NV12
    linear format and with the same resolution (or smaller in case
    the user wants to downscale).
    
    The DPB buffers are used for decoder reference frames and those
    have to be in a specific format (UBWC). So one decoder output is
    used to fill those reference buffers while the other output is
    used to fill the userspace buffers with the user requested format.
    
    Signed-off-by: Stanimir Varbanov <stanimir.varbanov@linaro.org>
    Reviewed-by: Tomasz Figa <tfiga@chromium.org>
    Reviewed-by: Alexandre Courbot <acourbot@chromium.org>
    Tested-by: Alexandre Courbot <acourbot@chromium.org>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/platform/qcom/venus/core.h b/drivers/media/platform/qcom/venus/core.h
index f8e4d92ff0e1..8cc49f30a363 100644
--- a/drivers/media/platform/qcom/venus/core.h
+++ b/drivers/media/platform/qcom/venus/core.h
@@ -215,6 +215,7 @@ struct venus_buffer {
  * @list:	used for attach an instance to the core
  * @lock:	instance lock
  * @core:	a reference to the core struct
+ * @dpbbufs:	a list of decoded picture buffers
  * @internalbufs:	a list of internal bufferes
  * @registeredbufs:	a list of registered capture bufferes
  * @delayed_process	a list of delayed buffers
@@ -240,6 +241,8 @@ struct venus_buffer {
  * @input_buf_size	holds input buffer size
  * @output_buf_size:	holds output buffer size
  * @output2_buf_size:	holds secondary decoder output buffer size
+ * @dpb_buftype:	decoded picture buffer type
+ * @dpb_fmt:		decoded picture buffer raw format
  * @opb_buftype:	output picture buffer type
  * @opb_fmt:		output picture buffer raw format
  * @reconfig:	a flag raised by decoder when the stream resolution changed
@@ -263,6 +266,7 @@ struct venus_inst {
 	struct list_head list;
 	struct mutex lock;
 	struct venus_core *core;
+	struct list_head dpbbufs;
 	struct list_head internalbufs;
 	struct list_head registeredbufs;
 	struct list_head delayed_process;
@@ -292,6 +296,8 @@ struct venus_inst {
 	unsigned int input_buf_size;
 	unsigned int output_buf_size;
 	unsigned int output2_buf_size;
+	u32 dpb_buftype;
+	u32 dpb_fmt;
 	u32 opb_buftype;
 	u32 opb_fmt;
 	bool reconfig;

commit 130c0117e853a3561d083fd4039b630ca35ce167
Author: Stanimir Varbanov <stanimir.varbanov@linaro.org>
Date:   Thu Jul 5 09:03:55 2018 -0400

    media: venus: helpers: add a helper to return opb buffer sizes
    
    Add a helper function to return current output picture buffer size.
    OPB sizes can vary depending on the selected decoder output(s).
    
    Signed-off-by: Stanimir Varbanov <stanimir.varbanov@linaro.org>
    Reviewed-by: Tomasz Figa <tfiga@chromium.org>
    Reviewed-by: Alexandre Courbot <acourbot@chromium.org>
    Tested-by: Alexandre Courbot <acourbot@chromium.org>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/platform/qcom/venus/core.h b/drivers/media/platform/qcom/venus/core.h
index 1d1a59a5d343..f8e4d92ff0e1 100644
--- a/drivers/media/platform/qcom/venus/core.h
+++ b/drivers/media/platform/qcom/venus/core.h
@@ -239,6 +239,9 @@ struct venus_buffer {
  * @num_output_bufs:	holds number of output buffers
  * @input_buf_size	holds input buffer size
  * @output_buf_size:	holds output buffer size
+ * @output2_buf_size:	holds secondary decoder output buffer size
+ * @opb_buftype:	output picture buffer type
+ * @opb_fmt:		output picture buffer raw format
  * @reconfig:	a flag raised by decoder when the stream resolution changed
  * @reconfig_width:	holds the new width
  * @reconfig_height:	holds the new height
@@ -288,6 +291,9 @@ struct venus_inst {
 	unsigned int num_output_bufs;
 	unsigned int input_buf_size;
 	unsigned int output_buf_size;
+	unsigned int output2_buf_size;
+	u32 opb_buftype;
+	u32 opb_fmt;
 	bool reconfig;
 	u32 reconfig_width;
 	u32 reconfig_height;

commit bf26670aeae8f7f407e05f5da044e48cf9854a1b
Author: Stanimir Varbanov <stanimir.varbanov@linaro.org>
Date:   Thu Jul 5 09:03:50 2018 -0400

    media: venus: core: delete not used buffer mode flags
    
    Delete not used flag for capture buffer allocation mode and
    no longer used cap_bufs_mode_dynamic from instance structure.
    
    Signed-off-by: Stanimir Varbanov <stanimir.varbanov@linaro.org>
    Reviewed-by: Tomasz Figa <tfiga@chromium.org>
    Reviewed-by: Alexandre Courbot <acourbot@chromium.org>
    Tested-by: Alexandre Courbot <acourbot@chromium.org>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/platform/qcom/venus/core.h b/drivers/media/platform/qcom/venus/core.h
index b995d1601c87..1d1a59a5d343 100644
--- a/drivers/media/platform/qcom/venus/core.h
+++ b/drivers/media/platform/qcom/venus/core.h
@@ -255,8 +255,6 @@ struct venus_buffer {
  * @priv:	a private for HFI operations callbacks
  * @session_type:	the type of the session (decoder or encoder)
  * @hprop:	a union used as a holder by get property
- * @cap_bufs_mode_static:	buffers allocation mode capability
- * @cap_bufs_mode_dynamic:	buffers allocation mode capability
  */
 struct venus_inst {
 	struct list_head list;
@@ -305,8 +303,6 @@ struct venus_inst {
 	const struct hfi_inst_ops *ops;
 	u32 session_type;
 	union hfi_get_property hprop;
-	bool cap_bufs_mode_static;
-	bool cap_bufs_mode_dynamic;
 };
 
 #define IS_V1(core)	((core)->res->hfi_version == HFI_VERSION_1XX)

commit 1a73374a04e555103e5369429a30999114001dda
Author: Stanimir Varbanov <stanimir.varbanov@linaro.org>
Date:   Fri Jul 6 08:47:58 2018 -0400

    media: venus: hfi_parser: add common capability parser
    
    This adds common capability parser for all supported Venus
    versions. Having it will help to enumerate better the supported
    raw formats and codecs and also the capabilities for every
    codec like max/min width/height, framerate, bitrate and so on.
    
    Signed-off-by: Stanimir Varbanov <stanimir.varbanov@linaro.org>
    Reviewed-by: Tomasz Figa <tfiga@chromium.org>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/platform/qcom/venus/core.h b/drivers/media/platform/qcom/venus/core.h
index 2bf8839784fa..b995d1601c87 100644
--- a/drivers/media/platform/qcom/venus/core.h
+++ b/drivers/media/platform/qcom/venus/core.h
@@ -57,6 +57,30 @@ struct venus_format {
 	u32 type;
 };
 
+#define MAX_PLANES		4
+#define MAX_FMT_ENTRIES		32
+#define MAX_CAP_ENTRIES		32
+#define MAX_ALLOC_MODE_ENTRIES	16
+#define MAX_CODEC_NUM		32
+
+struct raw_formats {
+	u32 buftype;
+	u32 fmt;
+};
+
+struct venus_caps {
+	u32 codec;
+	u32 domain;
+	bool cap_bufs_mode_dynamic;
+	unsigned int num_caps;
+	struct hfi_capability caps[MAX_CAP_ENTRIES];
+	unsigned int num_pl;
+	struct hfi_profile_level pl[HFI_MAX_PROFILE_COUNT];
+	unsigned int num_fmts;
+	struct raw_formats fmts[MAX_FMT_ENTRIES];
+	bool valid;	/* used only for Venus v1xx */
+};
+
 /**
  * struct venus_core - holds core parameters valid for all instances
  *
@@ -113,8 +137,8 @@ struct venus_core {
 	unsigned int error;
 	bool sys_error;
 	const struct hfi_core_ops *core_ops;
-	u32 enc_codecs;
-	u32 dec_codecs;
+	unsigned long enc_codecs;
+	unsigned long dec_codecs;
 	unsigned int max_sessions_supported;
 #define ENC_ROTATION_CAPABILITY		0x1
 #define ENC_SCALING_CAPABILITY		0x2
@@ -124,6 +148,8 @@ struct venus_core {
 	void *priv;
 	const struct hfi_ops *ops;
 	struct delayed_work work;
+	struct venus_caps caps[MAX_CODEC_NUM];
+	unsigned int codecs_count;
 };
 
 struct vdec_controls {
@@ -216,6 +242,7 @@ struct venus_buffer {
  * @reconfig:	a flag raised by decoder when the stream resolution changed
  * @reconfig_width:	holds the new width
  * @reconfig_height:	holds the new height
+ * @hfi_codec:		current codec for this instance in HFI space
  * @sequence_cap:	a sequence counter for capture queue
  * @sequence_out:	a sequence counter for output queue
  * @m2m_dev:	a reference to m2m device structure
@@ -228,22 +255,8 @@ struct venus_buffer {
  * @priv:	a private for HFI operations callbacks
  * @session_type:	the type of the session (decoder or encoder)
  * @hprop:	a union used as a holder by get property
- * @cap_width:	width capability
- * @cap_height:	height capability
- * @cap_mbs_per_frame:	macroblocks per frame capability
- * @cap_mbs_per_sec:	macroblocks per second capability
- * @cap_framerate:	framerate capability
- * @cap_scale_x:		horizontal scaling capability
- * @cap_scale_y:		vertical scaling capability
- * @cap_bitrate:		bitrate capability
- * @cap_hier_p:		hier capability
- * @cap_ltr_count:	LTR count capability
- * @cap_secure_output2_threshold: secure OUTPUT2 threshold capability
  * @cap_bufs_mode_static:	buffers allocation mode capability
  * @cap_bufs_mode_dynamic:	buffers allocation mode capability
- * @pl_count:	count of supported profiles/levels
- * @pl:		supported profiles/levels
- * @bufreq:	holds buffer requirements
  */
 struct venus_inst {
 	struct list_head list;
@@ -280,6 +293,7 @@ struct venus_inst {
 	bool reconfig;
 	u32 reconfig_width;
 	u32 reconfig_height;
+	u32 hfi_codec;
 	u32 sequence_cap;
 	u32 sequence_out;
 	struct v4l2_m2m_dev *m2m_dev;
@@ -291,22 +305,8 @@ struct venus_inst {
 	const struct hfi_inst_ops *ops;
 	u32 session_type;
 	union hfi_get_property hprop;
-	struct hfi_capability cap_width;
-	struct hfi_capability cap_height;
-	struct hfi_capability cap_mbs_per_frame;
-	struct hfi_capability cap_mbs_per_sec;
-	struct hfi_capability cap_framerate;
-	struct hfi_capability cap_scale_x;
-	struct hfi_capability cap_scale_y;
-	struct hfi_capability cap_bitrate;
-	struct hfi_capability cap_hier_p;
-	struct hfi_capability cap_ltr_count;
-	struct hfi_capability cap_secure_output2_threshold;
 	bool cap_bufs_mode_static;
 	bool cap_bufs_mode_dynamic;
-	unsigned int pl_count;
-	struct hfi_profile_level pl[HFI_MAX_PROFILE_COUNT];
-	struct hfi_buffer_requirements bufreq[HFI_BUFFER_TYPE_MAX];
 };
 
 #define IS_V1(core)	((core)->res->hfi_version == HFI_VERSION_1XX)
@@ -326,4 +326,18 @@ static inline void *to_hfi_priv(struct venus_core *core)
 	return core->priv;
 }
 
+static inline struct venus_caps *
+venus_caps_by_codec(struct venus_core *core, u32 codec, u32 domain)
+{
+	unsigned int c;
+
+	for (c = 0; c < core->codecs_count; c++) {
+		if (core->caps[c].codec == codec &&
+		    core->caps[c].domain == domain)
+			return &core->caps[c];
+	}
+
+	return NULL;
+}
+
 #endif

commit aa3a8414ccea5b9412419db11f5d76ae9a4997a4
Author: Stanimir Varbanov <stanimir.varbanov@linaro.org>
Date:   Thu Jul 5 09:03:45 2018 -0400

    media: venus: core, helpers: add two more clocks found in Venus 4xx
    
    Add two more clocks for Venus 4xx in core structure and create
    a new power enable function to handle it for 3xx/4xx versions.
    
    Signed-off-by: Stanimir Varbanov <stanimir.varbanov@linaro.org>
    Reviewed-by: Tomasz Figa <tfiga@chromium.org>
    Reviewed-by: Alexandre Courbot <acourbot@chromium.org>
    Tested-by: Alexandre Courbot <acourbot@chromium.org>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/platform/qcom/venus/core.h b/drivers/media/platform/qcom/venus/core.h
index 8d3e150800c9..2bf8839784fa 100644
--- a/drivers/media/platform/qcom/venus/core.h
+++ b/drivers/media/platform/qcom/venus/core.h
@@ -65,6 +65,8 @@ struct venus_format {
  * @clks:	an array of struct clk pointers
  * @core0_clk:	a struct clk pointer for core0
  * @core1_clk:	a struct clk pointer for core1
+ * @core0_bus_clk: a struct clk pointer for core0 bus clock
+ * @core1_bus_clk: a struct clk pointer for core1 bus clock
  * @vdev_dec:	a reference to video device structure for decoder instances
  * @vdev_enc:	a reference to video device structure for encoder instances
  * @v4l2_dev:	a holder for v4l2 device structure
@@ -94,6 +96,8 @@ struct venus_core {
 	struct clk *clks[VIDC_CLKS_NUM_MAX];
 	struct clk *core0_clk;
 	struct clk *core1_clk;
+	struct clk *core0_bus_clk;
+	struct clk *core1_bus_clk;
 	struct video_device *vdev_dec;
 	struct video_device *vdev_enc;
 	struct v4l2_device v4l2_dev;

commit f04997bdca34221c5e953df40999c4c92edb4e0b
Author: Stanimir Varbanov <stanimir.varbanov@linaro.org>
Date:   Thu Jul 5 09:03:36 2018 -0400

    media: venus: hfi: preparation to support venus 4xx
    
    This covers the differences between 1xx,3xx and 4xx.
    
    Signed-off-by: Stanimir Varbanov <stanimir.varbanov@linaro.org>
    Reviewed-by: Tomasz Figa <tfiga@chromium.org>
    Reviewed-by: Alexandre Courbot <acourbot@chromium.org>
    Tested-by: Alexandre Courbot <acourbot@chromium.org>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/platform/qcom/venus/core.h b/drivers/media/platform/qcom/venus/core.h
index 0360d295f4c8..8d3e150800c9 100644
--- a/drivers/media/platform/qcom/venus/core.h
+++ b/drivers/media/platform/qcom/venus/core.h
@@ -305,6 +305,10 @@ struct venus_inst {
 	struct hfi_buffer_requirements bufreq[HFI_BUFFER_TYPE_MAX];
 };
 
+#define IS_V1(core)	((core)->res->hfi_version == HFI_VERSION_1XX)
+#define IS_V3(core)	((core)->res->hfi_version == HFI_VERSION_3XX)
+#define IS_V4(core)	((core)->res->hfi_version == HFI_VERSION_4XX)
+
 #define ctrl_to_inst(ctrl)	\
 	container_of((ctrl)->handler, struct venus_inst, ctrl_handler)
 

commit f7d12fea16cbcc38d08092c6267e75fabeaa9093
Author: Loic Poulain <loic.poulain@linaro.org>
Date:   Fri Nov 24 04:34:02 2017 -0500

    media: venus: venc: Apply inloop deblocking filter
    
    Deblocking filter allows to reduce blocking artifacts and improve
    visual quality. This is configurable via the V4L2 API but eventually
    not applied to the encoder.
    
    Note that alpha and beta deblocking values are 32-bit signed (-6;+6).
    
    Signed-off-by: Loic Poulain <loic.poulain@linaro.org>
    Reviewed-by: Stanimir Varbanov <stanimir.varbanov@linaro.org>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/platform/qcom/venus/core.h b/drivers/media/platform/qcom/venus/core.h
index a0fe80df0cbd..0360d295f4c8 100644
--- a/drivers/media/platform/qcom/venus/core.h
+++ b/drivers/media/platform/qcom/venus/core.h
@@ -144,8 +144,8 @@ struct venc_controls {
 	u32 h264_min_qp;
 	u32 h264_max_qp;
 	u32 h264_loop_filter_mode;
-	u32 h264_loop_filter_alpha;
-	u32 h264_loop_filter_beta;
+	s32 h264_loop_filter_alpha;
+	s32 h264_loop_filter_beta;
 
 	u32 vp8_min_qp;
 	u32 vp8_max_qp;

commit e69b987a97599456b95b5fef4aca8dcdb1505aea
Author: Stanimir Varbanov <stanimir.varbanov@linaro.org>
Date:   Fri Oct 13 16:13:17 2017 +0200

    media: venus: reimplement decoder stop command
    
    This addresses the wrong behavior of decoder stop command by
    rewriting it. These new implementation enqueue an empty buffer
    on the decoder input buffer queue to signal end-of-stream. The
    client should stop queuing buffers on the V4L2 Output queue
    and continue queuing/dequeuing buffers on Capture queue. This
    process will continue until the client receives a buffer with
    V4L2_BUF_FLAG_LAST flag raised, which means that this is last
    decoded buffer with data.
    
    Signed-off-by: Stanimir Varbanov <stanimir.varbanov@linaro.org>
    Tested-by: Nicolas Dufresne <nicolas.dufresne@collabora.com>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Cc: <stable@vger.kernel.org>      # for v4.13 and up
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/platform/qcom/venus/core.h b/drivers/media/platform/qcom/venus/core.h
index cba092bcb76d..a0fe80df0cbd 100644
--- a/drivers/media/platform/qcom/venus/core.h
+++ b/drivers/media/platform/qcom/venus/core.h
@@ -194,7 +194,6 @@ struct venus_buffer {
  * @fh:	 a holder of v4l file handle structure
  * @streamon_cap: stream on flag for capture queue
  * @streamon_out: stream on flag for output queue
- * @cmd_stop:	a flag to signal encoder/decoder commands
  * @width:	current capture width
  * @height:	current capture height
  * @out_width:	current output width
@@ -258,7 +257,6 @@ struct venus_inst {
 	} controls;
 	struct v4l2_fh fh;
 	unsigned int streamon_cap, streamon_out;
-	bool cmd_stop;
 	u32 width;
 	u32 height;
 	u32 out_width;

commit a6e2d36bf6b7e2f821ce89dc6e5fb9b4dfe2970c
Author: Stanimir Varbanov <stanimir.varbanov@linaro.org>
Date:   Wed Jul 19 07:51:37 2017 -0400

    media: venus: don't abuse dma_alloc for non-DMA allocations
    
    In venus_boot(), we pass a pointer to a phys_addr_t
    into dmam_alloc_coherent, which the compiler warns about:
    
    platform/qcom/venus/firmware.c: In function 'venus_boot':
    platform/qcom/venus/firmware.c:63:49: error: passing argument 3 of 'dmam_alloc_coherent' from incompatible pointer type [-Werror=incompatible-pointer-types]
    
    To avoid the error refactor venus_boot function by discard
    dma_alloc_coherent invocation because we don't want to map the
    memory for the device.  Something more, the usage of
    DMA mapping API is actually wrong and the current
    implementation relies on several bugs in DMA mapping code.
    When these bugs are fixed that will break firmware loading,
    so fix this now to avoid future troubles.
    
    The meaning of venus_boot is to copy the content of the
    firmware buffer into reserved (and memblock removed)
    block of memory and pass that physical address to the
    trusted zone for authentication and mapping through iommu
    form the secure world. After iommu mapping is done the iova
    is passed as ane entry point to the remote processor.
    
    After this change memory-region property is parsed manually
    and the physical address is memremap to CPU, call mdt_load to
    load firmware segments into proper places and unmap
    reserved memory.
    
    Fixes: af2c3834c8ca ("[media] media: venus: adding core part and helper functions")
    
    Signed-off-by: Stanimir Varbanov <stanimir.varbanov@linaro.org>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/platform/qcom/venus/core.h b/drivers/media/platform/qcom/venus/core.h
index e542700eee32..cba092bcb76d 100644
--- a/drivers/media/platform/qcom/venus/core.h
+++ b/drivers/media/platform/qcom/venus/core.h
@@ -101,7 +101,6 @@ struct venus_core {
 	struct device *dev;
 	struct device *dev_dec;
 	struct device *dev_enc;
-	struct device dev_fw;
 	struct mutex lock;
 	struct list_head instances;
 	atomic_t insts_count;

commit 50058a9a589154121a798dd16ef9199bf607bdc5
Author: Stanimir Varbanov <stanimir.varbanov@linaro.org>
Date:   Thu Jun 15 13:31:59 2017 -0300

    [media] media: venus: update firmware path with linux-firmware place
    
    This makes firmware name and path part of venus_resources
    structure and initialize it properly depending on the SoC and
    firmware version.
    
    Signed-off-by: Stanimir Varbanov <stanimir.varbanov@linaro.org>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/platform/qcom/venus/core.h b/drivers/media/platform/qcom/venus/core.h
index 2f8492090224..e542700eee32 100644
--- a/drivers/media/platform/qcom/venus/core.h
+++ b/drivers/media/platform/qcom/venus/core.h
@@ -48,6 +48,7 @@ struct venus_resources {
 	unsigned int vmem_id;
 	u32 vmem_size;
 	u32 vmem_addr;
+	const char *fwname;
 };
 
 struct venus_format {

commit af2c3834c8ca7cc65d15592ac671933df8848115
Author: Stanimir Varbanov <stanimir.varbanov@linaro.org>
Date:   Thu Jun 15 13:31:45 2017 -0300

    [media] media: venus: adding core part and helper functions
    
    * core.c has implemented the platform driver methods, file
    operations and v4l2 registration.
    
     * helpers.c has implemented common helper functions for:
       - buffer management
    
       - vb2_ops and functions for format propagation,
    
       - functions for allocating and freeing buffers for
       internal usage. The buffer parameters describing internal
       buffers depends on current format, resolution and codec.
    
       - functions for calculation of current load of the
       hardware. Depending on the count of instances and
       resolutions it selects the best clock rate for the video
       core.
    
     * firmware loader
    
    Signed-off-by: Stanimir Varbanov <stanimir.varbanov@linaro.org>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/platform/qcom/venus/core.h b/drivers/media/platform/qcom/venus/core.h
new file mode 100644
index 000000000000..2f8492090224
--- /dev/null
+++ b/drivers/media/platform/qcom/venus/core.h
@@ -0,0 +1,323 @@
+/*
+ * Copyright (c) 2012-2016, The Linux Foundation. All rights reserved.
+ * Copyright (C) 2017 Linaro Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __VENUS_CORE_H_
+#define __VENUS_CORE_H_
+
+#include <linux/list.h>
+#include <media/videobuf2-v4l2.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+
+#include "hfi.h"
+
+#define VIDC_CLKS_NUM_MAX	4
+
+struct freq_tbl {
+	unsigned int load;
+	unsigned long freq;
+};
+
+struct reg_val {
+	u32 reg;
+	u32 value;
+};
+
+struct venus_resources {
+	u64 dma_mask;
+	const struct freq_tbl *freq_tbl;
+	unsigned int freq_tbl_size;
+	const struct reg_val *reg_tbl;
+	unsigned int reg_tbl_size;
+	const char * const clks[VIDC_CLKS_NUM_MAX];
+	unsigned int clks_num;
+	enum hfi_version hfi_version;
+	u32 max_load;
+	unsigned int vmem_id;
+	u32 vmem_size;
+	u32 vmem_addr;
+};
+
+struct venus_format {
+	u32 pixfmt;
+	unsigned int num_planes;
+	u32 type;
+};
+
+/**
+ * struct venus_core - holds core parameters valid for all instances
+ *
+ * @base:	IO memory base address
+ * @irq:		Venus irq
+ * @clks:	an array of struct clk pointers
+ * @core0_clk:	a struct clk pointer for core0
+ * @core1_clk:	a struct clk pointer for core1
+ * @vdev_dec:	a reference to video device structure for decoder instances
+ * @vdev_enc:	a reference to video device structure for encoder instances
+ * @v4l2_dev:	a holder for v4l2 device structure
+ * @res:		a reference to venus resources structure
+ * @dev:		convenience struct device pointer
+ * @dev_dec:	convenience struct device pointer for decoder device
+ * @dev_enc:	convenience struct device pointer for encoder device
+ * @lock:	a lock for this strucure
+ * @instances:	a list_head of all instances
+ * @insts_count:	num of instances
+ * @state:	the state of the venus core
+ * @done:	a completion for sync HFI operations
+ * @error:	an error returned during last HFI sync operations
+ * @sys_error:	an error flag that signal system error event
+ * @core_ops:	the core operations
+ * @enc_codecs:	encoders supported by this core
+ * @dec_codecs:	decoders supported by this core
+ * @max_sessions_supported:	holds the maximum number of sessions
+ * @core_caps:	core capabilities
+ * @priv:	a private filed for HFI operations
+ * @ops:		the core HFI operations
+ * @work:	a delayed work for handling system fatal error
+ */
+struct venus_core {
+	void __iomem *base;
+	int irq;
+	struct clk *clks[VIDC_CLKS_NUM_MAX];
+	struct clk *core0_clk;
+	struct clk *core1_clk;
+	struct video_device *vdev_dec;
+	struct video_device *vdev_enc;
+	struct v4l2_device v4l2_dev;
+	const struct venus_resources *res;
+	struct device *dev;
+	struct device *dev_dec;
+	struct device *dev_enc;
+	struct device dev_fw;
+	struct mutex lock;
+	struct list_head instances;
+	atomic_t insts_count;
+	unsigned int state;
+	struct completion done;
+	unsigned int error;
+	bool sys_error;
+	const struct hfi_core_ops *core_ops;
+	u32 enc_codecs;
+	u32 dec_codecs;
+	unsigned int max_sessions_supported;
+#define ENC_ROTATION_CAPABILITY		0x1
+#define ENC_SCALING_CAPABILITY		0x2
+#define ENC_DEINTERLACE_CAPABILITY	0x4
+#define DEC_MULTI_STREAM_CAPABILITY	0x8
+	unsigned int core_caps;
+	void *priv;
+	const struct hfi_ops *ops;
+	struct delayed_work work;
+};
+
+struct vdec_controls {
+	u32 post_loop_deb_mode;
+	u32 profile;
+	u32 level;
+};
+
+struct venc_controls {
+	u16 gop_size;
+	u32 num_p_frames;
+	u32 num_b_frames;
+	u32 bitrate_mode;
+	u32 bitrate;
+	u32 bitrate_peak;
+
+	u32 h264_i_period;
+	u32 h264_entropy_mode;
+	u32 h264_i_qp;
+	u32 h264_p_qp;
+	u32 h264_b_qp;
+	u32 h264_min_qp;
+	u32 h264_max_qp;
+	u32 h264_loop_filter_mode;
+	u32 h264_loop_filter_alpha;
+	u32 h264_loop_filter_beta;
+
+	u32 vp8_min_qp;
+	u32 vp8_max_qp;
+
+	u32 multi_slice_mode;
+	u32 multi_slice_max_bytes;
+	u32 multi_slice_max_mb;
+
+	u32 header_mode;
+
+	struct {
+		u32 mpeg4;
+		u32 h264;
+		u32 vpx;
+	} profile;
+	struct {
+		u32 mpeg4;
+		u32 h264;
+	} level;
+};
+
+struct venus_buffer {
+	struct vb2_v4l2_buffer vb;
+	struct list_head list;
+	dma_addr_t dma_addr;
+	u32 size;
+	struct list_head reg_list;
+	u32 flags;
+	struct list_head ref_list;
+};
+
+#define to_venus_buffer(ptr)	container_of(ptr, struct venus_buffer, vb)
+
+/**
+ * struct venus_inst - holds per instance paramerters
+ *
+ * @list:	used for attach an instance to the core
+ * @lock:	instance lock
+ * @core:	a reference to the core struct
+ * @internalbufs:	a list of internal bufferes
+ * @registeredbufs:	a list of registered capture bufferes
+ * @delayed_process	a list of delayed buffers
+ * @delayed_process_work:	a work_struct for process delayed buffers
+ * @ctrl_handler:	v4l control handler
+ * @controls:	a union of decoder and encoder control parameters
+ * @fh:	 a holder of v4l file handle structure
+ * @streamon_cap: stream on flag for capture queue
+ * @streamon_out: stream on flag for output queue
+ * @cmd_stop:	a flag to signal encoder/decoder commands
+ * @width:	current capture width
+ * @height:	current capture height
+ * @out_width:	current output width
+ * @out_height:	current output height
+ * @colorspace:	current color space
+ * @quantization:	current quantization
+ * @xfer_func:	current xfer function
+ * @fps:		holds current FPS
+ * @timeperframe:	holds current time per frame structure
+ * @fmt_out:	a reference to output format structure
+ * @fmt_cap:	a reference to capture format structure
+ * @num_input_bufs:	holds number of input buffers
+ * @num_output_bufs:	holds number of output buffers
+ * @input_buf_size	holds input buffer size
+ * @output_buf_size:	holds output buffer size
+ * @reconfig:	a flag raised by decoder when the stream resolution changed
+ * @reconfig_width:	holds the new width
+ * @reconfig_height:	holds the new height
+ * @sequence_cap:	a sequence counter for capture queue
+ * @sequence_out:	a sequence counter for output queue
+ * @m2m_dev:	a reference to m2m device structure
+ * @m2m_ctx:	a reference to m2m context structure
+ * @state:	current state of the instance
+ * @done:	a completion for sync HFI operation
+ * @error:	an error returned during last HFI sync operation
+ * @session_error:	a flag rised by HFI interface in case of session error
+ * @ops:		HFI operations
+ * @priv:	a private for HFI operations callbacks
+ * @session_type:	the type of the session (decoder or encoder)
+ * @hprop:	a union used as a holder by get property
+ * @cap_width:	width capability
+ * @cap_height:	height capability
+ * @cap_mbs_per_frame:	macroblocks per frame capability
+ * @cap_mbs_per_sec:	macroblocks per second capability
+ * @cap_framerate:	framerate capability
+ * @cap_scale_x:		horizontal scaling capability
+ * @cap_scale_y:		vertical scaling capability
+ * @cap_bitrate:		bitrate capability
+ * @cap_hier_p:		hier capability
+ * @cap_ltr_count:	LTR count capability
+ * @cap_secure_output2_threshold: secure OUTPUT2 threshold capability
+ * @cap_bufs_mode_static:	buffers allocation mode capability
+ * @cap_bufs_mode_dynamic:	buffers allocation mode capability
+ * @pl_count:	count of supported profiles/levels
+ * @pl:		supported profiles/levels
+ * @bufreq:	holds buffer requirements
+ */
+struct venus_inst {
+	struct list_head list;
+	struct mutex lock;
+	struct venus_core *core;
+	struct list_head internalbufs;
+	struct list_head registeredbufs;
+	struct list_head delayed_process;
+	struct work_struct delayed_process_work;
+
+	struct v4l2_ctrl_handler ctrl_handler;
+	union {
+		struct vdec_controls dec;
+		struct venc_controls enc;
+	} controls;
+	struct v4l2_fh fh;
+	unsigned int streamon_cap, streamon_out;
+	bool cmd_stop;
+	u32 width;
+	u32 height;
+	u32 out_width;
+	u32 out_height;
+	u32 colorspace;
+	u8 ycbcr_enc;
+	u8 quantization;
+	u8 xfer_func;
+	u64 fps;
+	struct v4l2_fract timeperframe;
+	const struct venus_format *fmt_out;
+	const struct venus_format *fmt_cap;
+	unsigned int num_input_bufs;
+	unsigned int num_output_bufs;
+	unsigned int input_buf_size;
+	unsigned int output_buf_size;
+	bool reconfig;
+	u32 reconfig_width;
+	u32 reconfig_height;
+	u32 sequence_cap;
+	u32 sequence_out;
+	struct v4l2_m2m_dev *m2m_dev;
+	struct v4l2_m2m_ctx *m2m_ctx;
+	unsigned int state;
+	struct completion done;
+	unsigned int error;
+	bool session_error;
+	const struct hfi_inst_ops *ops;
+	u32 session_type;
+	union hfi_get_property hprop;
+	struct hfi_capability cap_width;
+	struct hfi_capability cap_height;
+	struct hfi_capability cap_mbs_per_frame;
+	struct hfi_capability cap_mbs_per_sec;
+	struct hfi_capability cap_framerate;
+	struct hfi_capability cap_scale_x;
+	struct hfi_capability cap_scale_y;
+	struct hfi_capability cap_bitrate;
+	struct hfi_capability cap_hier_p;
+	struct hfi_capability cap_ltr_count;
+	struct hfi_capability cap_secure_output2_threshold;
+	bool cap_bufs_mode_static;
+	bool cap_bufs_mode_dynamic;
+	unsigned int pl_count;
+	struct hfi_profile_level pl[HFI_MAX_PROFILE_COUNT];
+	struct hfi_buffer_requirements bufreq[HFI_BUFFER_TYPE_MAX];
+};
+
+#define ctrl_to_inst(ctrl)	\
+	container_of((ctrl)->handler, struct venus_inst, ctrl_handler)
+
+static inline struct venus_inst *to_inst(struct file *filp)
+{
+	return container_of(filp->private_data, struct venus_inst, fh);
+}
+
+static inline void *to_hfi_priv(struct venus_core *core)
+{
+	return core->priv;
+}
+
+#endif
