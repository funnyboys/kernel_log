commit 4ebf969375bca2cef03573d23416423cec1af814
Author: Aniket Masule <amasule@codeaurora.org>
Date:   Mon Dec 2 17:44:41 2019 +0100

    media: venus: introduce core selection
    
    Presently the core (vcodec pipelines) assignment is static. Here we
    introduce dynamic load balancing across the cores depending on the
    current session load. The load on earch core is calculated and core
    with minimum load is assigned to given instance. This will be
    applicable on Venus v4 with more than one vcodec cores.
    
    Signed-off-by: Aniket Masule <amasule@codeaurora.org>
    Co-developed-by: Stanimir Varbanov <stanimir.varbanov@linaro.org>
    Signed-off-by: Stanimir Varbanov <stanimir.varbanov@linaro.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+huawei@kernel.org>

diff --git a/drivers/media/platform/qcom/venus/hfi_parser.h b/drivers/media/platform/qcom/venus/hfi_parser.h
index 3e931c747e19..264e6dd2415f 100644
--- a/drivers/media/platform/qcom/venus/hfi_parser.h
+++ b/drivers/media/platform/qcom/venus/hfi_parser.h
@@ -107,4 +107,9 @@ static inline u32 frate_step(struct venus_inst *inst)
 	return cap_step(inst, HFI_CAPABILITY_FRAMERATE);
 }
 
+static inline u32 core_num_max(struct venus_inst *inst)
+{
+	return cap_max(inst, HFI_CAPABILITY_MAX_VIDEOCORES);
+}
+
 #endif

commit 1a73374a04e555103e5369429a30999114001dda
Author: Stanimir Varbanov <stanimir.varbanov@linaro.org>
Date:   Fri Jul 6 08:47:58 2018 -0400

    media: venus: hfi_parser: add common capability parser
    
    This adds common capability parser for all supported Venus
    versions. Having it will help to enumerate better the supported
    raw formats and codecs and also the capabilities for every
    codec like max/min width/height, framerate, bitrate and so on.
    
    Signed-off-by: Stanimir Varbanov <stanimir.varbanov@linaro.org>
    Reviewed-by: Tomasz Figa <tfiga@chromium.org>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/platform/qcom/venus/hfi_parser.h b/drivers/media/platform/qcom/venus/hfi_parser.h
new file mode 100644
index 000000000000..3e931c747e19
--- /dev/null
+++ b/drivers/media/platform/qcom/venus/hfi_parser.h
@@ -0,0 +1,110 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (C) 2018 Linaro Ltd. */
+#ifndef __VENUS_HFI_PARSER_H__
+#define __VENUS_HFI_PARSER_H__
+
+#include "core.h"
+
+u32 hfi_parser(struct venus_core *core, struct venus_inst *inst,
+	       void *buf, u32 size);
+
+#define WHICH_CAP_MIN	0
+#define WHICH_CAP_MAX	1
+#define WHICH_CAP_STEP	2
+
+static inline u32 get_cap(struct venus_inst *inst, u32 type, u32 which)
+{
+	struct venus_core *core = inst->core;
+	struct hfi_capability *cap = NULL;
+	struct venus_caps *caps;
+	unsigned int i;
+
+	caps = venus_caps_by_codec(core, inst->hfi_codec, inst->session_type);
+	if (!caps)
+		return 0;
+
+	for (i = 0; i < caps->num_caps; i++) {
+		if (caps->caps[i].capability_type == type) {
+			cap = &caps->caps[i];
+			break;
+		}
+	}
+
+	if (!cap)
+		return 0;
+
+	switch (which) {
+	case WHICH_CAP_MIN:
+		return cap->min;
+	case WHICH_CAP_MAX:
+		return cap->max;
+	case WHICH_CAP_STEP:
+		return cap->step_size;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static inline u32 cap_min(struct venus_inst *inst, u32 type)
+{
+	return get_cap(inst, type, WHICH_CAP_MIN);
+}
+
+static inline u32 cap_max(struct venus_inst *inst, u32 type)
+{
+	return get_cap(inst, type, WHICH_CAP_MAX);
+}
+
+static inline u32 cap_step(struct venus_inst *inst, u32 type)
+{
+	return get_cap(inst, type, WHICH_CAP_STEP);
+}
+
+static inline u32 frame_width_min(struct venus_inst *inst)
+{
+	return cap_min(inst, HFI_CAPABILITY_FRAME_WIDTH);
+}
+
+static inline u32 frame_width_max(struct venus_inst *inst)
+{
+	return cap_max(inst, HFI_CAPABILITY_FRAME_WIDTH);
+}
+
+static inline u32 frame_width_step(struct venus_inst *inst)
+{
+	return cap_step(inst, HFI_CAPABILITY_FRAME_WIDTH);
+}
+
+static inline u32 frame_height_min(struct venus_inst *inst)
+{
+	return cap_min(inst, HFI_CAPABILITY_FRAME_HEIGHT);
+}
+
+static inline u32 frame_height_max(struct venus_inst *inst)
+{
+	return cap_max(inst, HFI_CAPABILITY_FRAME_HEIGHT);
+}
+
+static inline u32 frame_height_step(struct venus_inst *inst)
+{
+	return cap_step(inst, HFI_CAPABILITY_FRAME_HEIGHT);
+}
+
+static inline u32 frate_min(struct venus_inst *inst)
+{
+	return cap_min(inst, HFI_CAPABILITY_FRAMERATE);
+}
+
+static inline u32 frate_max(struct venus_inst *inst)
+{
+	return cap_max(inst, HFI_CAPABILITY_FRAMERATE);
+}
+
+static inline u32 frate_step(struct venus_inst *inst)
+{
+	return cap_step(inst, HFI_CAPABILITY_FRAMERATE);
+}
+
+#endif
