commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/media/platform/ti-vpe/sc.h b/drivers/media/platform/ti-vpe/sc.h
index f1fe80b38c9f..d55de44d5257 100644
--- a/drivers/media/platform/ti-vpe/sc.h
+++ b/drivers/media/platform/ti-vpe/sc.h
@@ -1,13 +1,10 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * Copyright (c) 2013 Texas Instruments Inc.
  *
  * David Griego, <dagriego@biglakesoftware.com>
  * Dale Farnsworth, <dale@farnsworth.org>
  * Archit Taneja, <archit@ti.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published by
- * the Free Software Foundation.
  */
 #ifndef TI_SC_H
 #define TI_SC_H

commit 35be6d865c2b6c0866164fef14832ecc5def9d2b
Author: Benoit Parrot <bparrot@ti.com>
Date:   Fri Nov 18 21:20:41 2016 -0200

    [media] media: ti-vpe: vpe: Make sure frame size dont exceed scaler capacity
    
    When scaler is to be used we need to make sure that the input and
    output frame size do not exceed the maximum frame sizes that the
    scaler h/w can handle otherwise streaming stall as the scaler
    cannot proceed.
    
    The scaler buffer is limited to 2047 pixels (i.e. 11 bits) when
    attempting anything larger (2048 for example) the scaler stalls.
    
    Realistically in an mem2mem device we can only check for this type
    of issue when start_streaming is called. We can't do it during the
    try_fmt/s_fmt because we do not have all of the info needed at that
    point. So instead when start_streaming is called we need to check
    that the input and output frames size do not exceed the scaler's
    capability. The only time larger frame size are allowed is when
    the input frame szie is the same as the output frame size.
    
    Now in the case where we need to fail, start_streaming must return
    all previously queued buffer back otherwise the vb2 framework
    will issue kernel WARN messages.
    In this case we also give an error message.
    
    Signed-off-by: Benoit Parrot <bparrot@ti.com>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/platform/ti-vpe/sc.h b/drivers/media/platform/ti-vpe/sc.h
index d0aab5ef0eca..f1fe80b38c9f 100644
--- a/drivers/media/platform/ti-vpe/sc.h
+++ b/drivers/media/platform/ti-vpe/sc.h
@@ -173,6 +173,12 @@
 /* number of taps expected by the scaler in it's coefficient memory */
 #define SC_NUM_TAPS_MEM_ALIGN		8
 
+/* Maximum frame width the scaler can handle (in pixels) */
+#define SC_MAX_PIXEL_WIDTH		2047
+
+/* Maximum frame height the scaler can handle (in lines) */
+#define SC_MAX_PIXEL_HEIGHT		2047
+
 /*
  * coefficient memory size in bytes:
  * num phases x num sets(luma and chroma) x num taps(aligned) x coeff size

commit 1c6e81783cff1a54e05b08691f5ae034af82ba0a
Author: Benoit Parrot <bparrot@ti.com>
Date:   Fri Nov 18 21:20:39 2016 -0200

    [media] media: ti-vpe: Make scaler library into its own module
    
    In preparation to add scaler support into VIP we need to
    turn sc.c into its own kernel module.
    
    Add support for multiple SC memory block as VIP contains
    2 scaler instances.
    This is done by passing the resource name to sc_create() and
    modify the vpe invocation accordingly.
    
    Signed-off-by: Benoit Parrot <bparrot@ti.com>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/platform/ti-vpe/sc.h b/drivers/media/platform/ti-vpe/sc.h
index de947db98990..d0aab5ef0eca 100644
--- a/drivers/media/platform/ti-vpe/sc.h
+++ b/drivers/media/platform/ti-vpe/sc.h
@@ -200,6 +200,6 @@ void sc_set_vs_coeffs(struct sc_data *sc, void *addr, unsigned int src_h,
 void sc_config_scaler(struct sc_data *sc, u32 *sc_reg0, u32 *sc_reg8,
 		u32 *sc_reg17, unsigned int src_w, unsigned int src_h,
 		unsigned int dst_w, unsigned int dst_h);
-struct sc_data *sc_create(struct platform_device *pdev);
+struct sc_data *sc_create(struct platform_device *pdev, const char *res_name);
 
 #endif

commit bc809bfc1796accdd0c15c3bccd4e8af33922018
Author: Nikhil Devshatwar <nikhil.nd@ti.com>
Date:   Fri Nov 18 21:20:33 2016 -0200

    [media] media: ti-vpe: sc: Fix incorrect optimization
    
    Current scaler library implementation of sc_set_hs_coeffs and
    sc_set_vs_coeffs tries to return immediately if the calculated
    coefficient index is already being used.
    
    As the same scaler block is going to be used for all the VPE contexts,
    even if the calculated index is same, the parameters have to be
    reconfigured for each of the context.
    
    Because of this, when multiple contexts use the same coefficients,
    all other contexts would have zero scaling coefficients.
    Fix this and also remove the unnecessary hs_index and vs_index fields.
    
    Signed-off-by: Nikhil Devshatwar <nikhil.nd@ti.com>
    Signed-off-by: Benoit Parrot <bparrot@ti.com>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/platform/ti-vpe/sc.h b/drivers/media/platform/ti-vpe/sc.h
index 60e411e05c30..de947db98990 100644
--- a/drivers/media/platform/ti-vpe/sc.h
+++ b/drivers/media/platform/ti-vpe/sc.h
@@ -189,9 +189,6 @@ struct sc_data {
 	bool			load_coeff_h;	/* have new h SC coeffs */
 	bool			load_coeff_v;	/* have new v SC coeffs */
 
-	unsigned int		hs_index;	/* h SC coeffs selector */
-	unsigned int		vs_index;	/* v SC coeffs selector */
-
 	struct platform_device *pdev;
 };
 

commit bbee8b3933f5ddff85904aed9190eaca52c54d13
Author: Archit Taneja <archit@ti.com>
Date:   Thu Dec 12 05:36:00 2013 -0300

    [media] v4l: ti-vpe: enable basic scaler support
    
    Add the required SC register configurations which lets us perform linear scaling
    for the supported range of horizontal and vertical scaling ratios.
    
    The horizontal scaler performs polyphase scaling using it's 8 tap 32 phase
    filter, decimation is performed when downscaling passes beyond 2x or 4x.
    
    The vertical scaler performs polyphase scaling using it's 5 tap 32 phase filter,
    it switches to a simpler form of scaling using the running average filter when
    the downscale ratio is more than 4x.
    
    Many of the SC features like peaking, trimming and non-linear scaling aren't
    implemented for now. Only the minimal register fields required for basic scaling
    operation are configured.
    
    The function to configure SC registers takes the sc_data handle, the source and
    destination widths and heights, and the scaler address data block offsets for
    the current context so that they can be configured.
    
    Signed-off-by: Archit Taneja <archit@ti.com>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/drivers/media/platform/ti-vpe/sc.h b/drivers/media/platform/ti-vpe/sc.h
index c89f3d1a3bad..60e411e05c30 100644
--- a/drivers/media/platform/ti-vpe/sc.h
+++ b/drivers/media/platform/ti-vpe/sc.h
@@ -195,12 +195,14 @@ struct sc_data {
 	struct platform_device *pdev;
 };
 
-void sc_set_regs_bypass(struct sc_data *sc, u32 *sc_reg0);
 void sc_dump_regs(struct sc_data *sc);
 void sc_set_hs_coeffs(struct sc_data *sc, void *addr, unsigned int src_w,
 		unsigned int dst_w);
 void sc_set_vs_coeffs(struct sc_data *sc, void *addr, unsigned int src_h,
 		unsigned int dst_h);
+void sc_config_scaler(struct sc_data *sc, u32 *sc_reg0, u32 *sc_reg8,
+		u32 *sc_reg17, unsigned int src_w, unsigned int src_h,
+		unsigned int dst_w, unsigned int dst_h);
 struct sc_data *sc_create(struct platform_device *pdev);
 
 #endif

commit 0df20f9657693c420b10e8d18f1472e0dd47d634
Author: Archit Taneja <archit@ti.com>
Date:   Thu Dec 12 05:35:58 2013 -0300

    [media] v4l: ti-vpe: support loading of scaler coefficients
    
    The SC block in VPE/VIP contains a SRAM within it. This internal memory
    requires to be loaded with appropriate scaler coefficients from a contiguous
    block of memory through VPDMA.
    
    The horizontal and vertical scaler each require 2 sets of scaler coefficients
    for luma and chroma scaling. The horizontal polyphase scaler requires
    coefficients for a 32 phase and 8 tap filter. Similarly, the vertical scaler
    requires coefficients for a 5 tap filter.
    
    The choice of the scaler coefficients depends on the scaling ratio. Add
    coefficient tables for different scaling ratios in sc_coeffs.h. In the case of
    horizontal downscaling, we need to consider the change in ratio caused by
    decimation performed by the horizontal scaler.
    
    In order to load the scaler coefficients via VPDMA, a configuration descriptor
    is used in block mode. The payload for the descriptor is the scaler coefficients
    copied to memory. Coefficients for each phase have to be placed in memory in a
    particular order understood by the scaler hardware.
    
    The choice of the scaler coefficients, and the loading of the coefficients from
    our tables to a contiguous buffer is managed by the functions
    sc_set_hs_coefficients and sc_set_vs_coefficients.
    
    The sc_data handle is now added with some parameters to describe the state of
    the coefficients loaded in the SC block. 'loaded_coeff_h' and 'loaded_coeff_v'
    hold the address of the last dma buffer which was used by VPDMA to copy
    coefficients. This information can be used by a vpe mem-to-mem context to decide
    whether it should load coefficients or not. 'hs_index' and 'vs_index' provide
    some optimization by preventing loading of coefficients if the scaling ratio
    didn't change between 2 contexts. 'load_coeff_h' and 'load_coeff_v' tell the
    vpe/vip driver whether we need to load the coefficients through VPDMA or not.
    
    Signed-off-by: Archit Taneja <archit@ti.com>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/drivers/media/platform/ti-vpe/sc.h b/drivers/media/platform/ti-vpe/sc.h
index 924854465c5d..c89f3d1a3bad 100644
--- a/drivers/media/platform/ti-vpe/sc.h
+++ b/drivers/media/platform/ti-vpe/sc.h
@@ -161,15 +161,46 @@
 #define CFG_OFF_W_MASK			0x07ff
 #define CFG_OFF_W_SHIFT			16
 
+/* number of phases supported by the polyphase scalers */
+#define SC_NUM_PHASES			32
+
+/* number of taps used by horizontal polyphase scaler */
+#define SC_H_NUM_TAPS			7
+
+/* number of taps used by vertical polyphase scaler */
+#define SC_V_NUM_TAPS			5
+
+/* number of taps expected by the scaler in it's coefficient memory */
+#define SC_NUM_TAPS_MEM_ALIGN		8
+
+/*
+ * coefficient memory size in bytes:
+ * num phases x num sets(luma and chroma) x num taps(aligned) x coeff size
+ */
+#define SC_COEF_SRAM_SIZE	(SC_NUM_PHASES * 2 * SC_NUM_TAPS_MEM_ALIGN * 2)
+
 struct sc_data {
 	void __iomem		*base;
 	struct resource		*res;
 
+	dma_addr_t		loaded_coeff_h; /* loaded h coeffs in SC */
+	dma_addr_t		loaded_coeff_v; /* loaded v coeffs in SC */
+
+	bool			load_coeff_h;	/* have new h SC coeffs */
+	bool			load_coeff_v;	/* have new v SC coeffs */
+
+	unsigned int		hs_index;	/* h SC coeffs selector */
+	unsigned int		vs_index;	/* v SC coeffs selector */
+
 	struct platform_device *pdev;
 };
 
 void sc_set_regs_bypass(struct sc_data *sc, u32 *sc_reg0);
 void sc_dump_regs(struct sc_data *sc);
+void sc_set_hs_coeffs(struct sc_data *sc, void *addr, unsigned int src_w,
+		unsigned int dst_w);
+void sc_set_vs_coeffs(struct sc_data *sc, void *addr, unsigned int src_h,
+		unsigned int dst_h);
 struct sc_data *sc_create(struct platform_device *pdev);
 
 #endif

commit 44687b2e81165164d3b921e383592cc0f5e062a0
Author: Archit Taneja <archit@ti.com>
Date:   Thu Dec 12 05:35:57 2013 -0300

    [media] v4l: ti-vpe: create a scaler block library
    
    VPE and VIP IPs in DAR7x contain a scaler(SC) sub block. Create a library which
    will perform scaler block related configurations and hold SC register
    definitions. The functions provided by this library will be called by the vpe
    and vip drivers using a sc_data handle.
    
    The vpe_dev holds the sc_data handle. The handle represents an instance of the
    SC hardware, and the vpe driver uses it to access the scaler register offsets
    or helper functions to configure these registers.
    
    We move the SC register definitions to sc.h so that they aren't specific to
    VPE anymore. The register offsets are now relative to the sub-block, and not the
    VPE IP as a whole. In order for VPDMA to configure registers, it requires it's
    offset from the top level VPE module. A macro called GET_OFFSET_TOP is added to
    return the offset of the register relative to the VPE IP.
    
    Signed-off-by: Archit Taneja <archit@ti.com>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/drivers/media/platform/ti-vpe/sc.h b/drivers/media/platform/ti-vpe/sc.h
new file mode 100644
index 000000000000..924854465c5d
--- /dev/null
+++ b/drivers/media/platform/ti-vpe/sc.h
@@ -0,0 +1,175 @@
+/*
+ * Copyright (c) 2013 Texas Instruments Inc.
+ *
+ * David Griego, <dagriego@biglakesoftware.com>
+ * Dale Farnsworth, <dale@farnsworth.org>
+ * Archit Taneja, <archit@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+#ifndef TI_SC_H
+#define TI_SC_H
+
+/* Scaler regs */
+#define CFG_SC0				0x0
+#define CFG_INTERLACE_O			(1 << 0)
+#define CFG_LINEAR			(1 << 1)
+#define CFG_SC_BYPASS			(1 << 2)
+#define CFG_INVT_FID			(1 << 3)
+#define CFG_USE_RAV			(1 << 4)
+#define CFG_ENABLE_EV			(1 << 5)
+#define CFG_AUTO_HS			(1 << 6)
+#define CFG_DCM_2X			(1 << 7)
+#define CFG_DCM_4X			(1 << 8)
+#define CFG_HP_BYPASS			(1 << 9)
+#define CFG_INTERLACE_I			(1 << 10)
+#define CFG_ENABLE_SIN2_VER_INTP	(1 << 11)
+#define CFG_Y_PK_EN			(1 << 14)
+#define CFG_TRIM			(1 << 15)
+#define CFG_SELFGEN_FID			(1 << 16)
+
+#define CFG_SC1				0x4
+#define CFG_ROW_ACC_INC_MASK		0x07ffffff
+#define CFG_ROW_ACC_INC_SHIFT		0
+
+#define CFG_SC2				0x08
+#define CFG_ROW_ACC_OFFSET_MASK		0x0fffffff
+#define CFG_ROW_ACC_OFFSET_SHIFT	0
+
+#define CFG_SC3				0x0c
+#define CFG_ROW_ACC_OFFSET_B_MASK	0x0fffffff
+#define CFG_ROW_ACC_OFFSET_B_SHIFT	0
+
+#define CFG_SC4				0x10
+#define CFG_TAR_H_MASK			0x07ff
+#define CFG_TAR_H_SHIFT			0
+#define CFG_TAR_W_MASK			0x07ff
+#define CFG_TAR_W_SHIFT			12
+#define CFG_LIN_ACC_INC_U_MASK		0x07
+#define CFG_LIN_ACC_INC_U_SHIFT		24
+#define CFG_NLIN_ACC_INIT_U_MASK	0x07
+#define CFG_NLIN_ACC_INIT_U_SHIFT	28
+
+#define CFG_SC5				0x14
+#define CFG_SRC_H_MASK			0x07ff
+#define CFG_SRC_H_SHIFT			0
+#define CFG_SRC_W_MASK			0x07ff
+#define CFG_SRC_W_SHIFT			12
+#define CFG_NLIN_ACC_INC_U_MASK		0x07
+#define CFG_NLIN_ACC_INC_U_SHIFT	24
+
+#define CFG_SC6				0x18
+#define CFG_ROW_ACC_INIT_RAV_MASK	0x03ff
+#define CFG_ROW_ACC_INIT_RAV_SHIFT	0
+#define CFG_ROW_ACC_INIT_RAV_B_MASK	0x03ff
+#define CFG_ROW_ACC_INIT_RAV_B_SHIFT	10
+
+#define CFG_SC8				0x20
+#define CFG_NLIN_LEFT_MASK		0x07ff
+#define CFG_NLIN_LEFT_SHIFT		0
+#define CFG_NLIN_RIGHT_MASK		0x07ff
+#define CFG_NLIN_RIGHT_SHIFT		12
+
+#define CFG_SC9				0x24
+#define CFG_LIN_ACC_INC			CFG_SC9
+
+#define CFG_SC10			0x28
+#define CFG_NLIN_ACC_INIT		CFG_SC10
+
+#define CFG_SC11			0x2c
+#define CFG_NLIN_ACC_INC		CFG_SC11
+
+#define CFG_SC12			0x30
+#define CFG_COL_ACC_OFFSET_MASK		0x01ffffff
+#define CFG_COL_ACC_OFFSET_SHIFT	0
+
+#define CFG_SC13			0x34
+#define CFG_SC_FACTOR_RAV_MASK		0xff
+#define CFG_SC_FACTOR_RAV_SHIFT		0
+#define CFG_CHROMA_INTP_THR_MASK	0x03ff
+#define CFG_CHROMA_INTP_THR_SHIFT	12
+#define CFG_DELTA_CHROMA_THR_MASK	0x0f
+#define CFG_DELTA_CHROMA_THR_SHIFT	24
+
+#define CFG_SC17			0x44
+#define CFG_EV_THR_MASK			0x03ff
+#define CFG_EV_THR_SHIFT		12
+#define CFG_DELTA_LUMA_THR_MASK		0x0f
+#define CFG_DELTA_LUMA_THR_SHIFT	24
+#define CFG_DELTA_EV_THR_MASK		0x0f
+#define CFG_DELTA_EV_THR_SHIFT		28
+
+#define CFG_SC18			0x48
+#define CFG_HS_FACTOR_MASK		0x03ff
+#define CFG_HS_FACTOR_SHIFT		0
+#define CFG_CONF_DEFAULT_MASK		0x01ff
+#define CFG_CONF_DEFAULT_SHIFT		16
+
+#define CFG_SC19			0x4c
+#define CFG_HPF_COEFF0_MASK		0xff
+#define CFG_HPF_COEFF0_SHIFT		0
+#define CFG_HPF_COEFF1_MASK		0xff
+#define CFG_HPF_COEFF1_SHIFT		8
+#define CFG_HPF_COEFF2_MASK		0xff
+#define CFG_HPF_COEFF2_SHIFT		16
+#define CFG_HPF_COEFF3_MASK		0xff
+#define CFG_HPF_COEFF3_SHIFT		23
+
+#define CFG_SC20			0x50
+#define CFG_HPF_COEFF4_MASK		0xff
+#define CFG_HPF_COEFF4_SHIFT		0
+#define CFG_HPF_COEFF5_MASK		0xff
+#define CFG_HPF_COEFF5_SHIFT		8
+#define CFG_HPF_NORM_SHIFT_MASK		0x07
+#define CFG_HPF_NORM_SHIFT_SHIFT	16
+#define CFG_NL_LIMIT_MASK		0x1ff
+#define CFG_NL_LIMIT_SHIFT		20
+
+#define CFG_SC21			0x54
+#define CFG_NL_LO_THR_MASK		0x01ff
+#define CFG_NL_LO_THR_SHIFT		0
+#define CFG_NL_LO_SLOPE_MASK		0xff
+#define CFG_NL_LO_SLOPE_SHIFT		16
+
+#define CFG_SC22			0x58
+#define CFG_NL_HI_THR_MASK		0x01ff
+#define CFG_NL_HI_THR_SHIFT		0
+#define CFG_NL_HI_SLOPE_SH_MASK		0x07
+#define CFG_NL_HI_SLOPE_SH_SHIFT	16
+
+#define CFG_SC23			0x5c
+#define CFG_GRADIENT_THR_MASK		0x07ff
+#define CFG_GRADIENT_THR_SHIFT		0
+#define CFG_GRADIENT_THR_RANGE_MASK	0x0f
+#define CFG_GRADIENT_THR_RANGE_SHIFT	12
+#define CFG_MIN_GY_THR_MASK		0xff
+#define CFG_MIN_GY_THR_SHIFT		16
+#define CFG_MIN_GY_THR_RANGE_MASK	0x0f
+#define CFG_MIN_GY_THR_RANGE_SHIFT	28
+
+#define CFG_SC24			0x60
+#define CFG_ORG_H_MASK			0x07ff
+#define CFG_ORG_H_SHIFT			0
+#define CFG_ORG_W_MASK			0x07ff
+#define CFG_ORG_W_SHIFT			16
+
+#define CFG_SC25			0x64
+#define CFG_OFF_H_MASK			0x07ff
+#define CFG_OFF_H_SHIFT			0
+#define CFG_OFF_W_MASK			0x07ff
+#define CFG_OFF_W_SHIFT			16
+
+struct sc_data {
+	void __iomem		*base;
+	struct resource		*res;
+
+	struct platform_device *pdev;
+};
+
+void sc_set_regs_bypass(struct sc_data *sc, u32 *sc_reg0);
+void sc_dump_regs(struct sc_data *sc);
+struct sc_data *sc_create(struct platform_device *pdev);
+
+#endif
