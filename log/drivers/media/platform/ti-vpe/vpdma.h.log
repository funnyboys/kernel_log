commit 0bac73adea4df8d34048b38f6ff24dc3e73e90b6
Author: Benoit Parrot <bparrot@ti.com>
Date:   Mon Oct 7 12:09:59 2019 -0300

    media: ti-vpe: vpe: fix a v4l2-compliance failure about invalid sizeimage
    
    v4l2-compliance fails with this message:
    
       fail: v4l2-test-formats.cpp(463): !pfmt.sizeimage
       fail: v4l2-test-formats.cpp(736): \
            Video Capture Multiplanar is valid, \
            but TRY_FMT failed to return a format
       test VIDIOC_TRY_FMT: FAIL
    
    This failure is causd by the driver failing to handle out range
    'bytesperline' values from user space applications.
    
    VPDMA hardware is limited to 64k line stride (16 bytes aligned, so 65520
    bytes). So make sure the provided or calculated 'bytesperline' is
    smaller than the maximum value.
    
    Signed-off-by: Benoit Parrot <bparrot@ti.com>
    Reviewed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Signed-off-by: Hans Verkuil <hverkuil-cisco@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/platform/ti-vpe/vpdma.h b/drivers/media/platform/ti-vpe/vpdma.h
index bce17329c4c9..393fcbb3cb40 100644
--- a/drivers/media/platform/ti-vpe/vpdma.h
+++ b/drivers/media/platform/ti-vpe/vpdma.h
@@ -57,6 +57,7 @@ struct vpdma_data_format {
 						 * line stride of source and dest
 						 * buffers should be 16 byte aligned
 						 */
+#define VPDMA_MAX_STRIDE		65520	/* Max line stride 16 byte aligned */
 #define VPDMA_DTD_DESC_SIZE		32	/* 8 words */
 #define VPDMA_CFD_CTD_DESC_SIZE		16	/* 4 words */
 

commit b2bb3d822f2c9e27236ea32bc5ef18a9f22c8a80
Author: Nikhil Devshatwar <nikhil.nd@ti.com>
Date:   Mon Oct 7 12:09:54 2019 -0300

    media: ti-vpe: Add support for NV21 format
    
    In NV21 format, the chroma plane is written to memory such that the U
    and V components are swapped for NV12.
    
    Create a new entry in the VPDMA formats to describe the correct data
    types used in the data descriptors.
    
    Update all checks for NV12 and add NV21 there as well.
    
    Add support for V4L2_PIX_FMT_NV21 format for both capture and output
    streams.
    
    Signed-off-by: Nikhil Devshatwar <nikhil.nd@ti.com>
    Signed-off-by: Benoit Parrot <bparrot@ti.com>
    Reviewed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Signed-off-by: Hans Verkuil <hverkuil-cisco@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/platform/ti-vpe/vpdma.h b/drivers/media/platform/ti-vpe/vpdma.h
index 28bc94129348..bce17329c4c9 100644
--- a/drivers/media/platform/ti-vpe/vpdma.h
+++ b/drivers/media/platform/ti-vpe/vpdma.h
@@ -71,6 +71,7 @@ enum vpdma_yuv_formats {
 	VPDMA_DATA_FMT_C444,
 	VPDMA_DATA_FMT_C422,
 	VPDMA_DATA_FMT_C420,
+	VPDMA_DATA_FMT_CB420,
 	VPDMA_DATA_FMT_YCR422,
 	VPDMA_DATA_FMT_YC444,
 	VPDMA_DATA_FMT_CRY422,

commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/media/platform/ti-vpe/vpdma.h b/drivers/media/platform/ti-vpe/vpdma.h
index 7e611501c291..28bc94129348 100644
--- a/drivers/media/platform/ti-vpe/vpdma.h
+++ b/drivers/media/platform/ti-vpe/vpdma.h
@@ -1,13 +1,10 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * Copyright (c) 2013 Texas Instruments Inc.
  *
  * David Griego, <dagriego@biglakesoftware.com>
  * Dale Farnsworth, <dale@farnsworth.org>
  * Archit Taneja, <archit@ti.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published by
- * the Free Software Foundation.
  */
 
 #ifndef __TI_VPDMA_H_

commit da4414eaed15f9f800b37e2e5c04da35dc863dd4
Author: Benoit Parrot <bparrot@ti.com>
Date:   Mon Feb 13 11:06:57 2017 -0200

    [media] media: ti-vpe: vpdma: add support for user specified stride
    
    This patch introduce the needed vpdma API changes to support
    user space specified stride instead of forcing a driver calculated
    one.
    
    Signed-off-by: Benoit Parrot <bparrot@ti.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/platform/ti-vpe/vpdma.h b/drivers/media/platform/ti-vpe/vpdma.h
index 131700c112b2..7e611501c291 100644
--- a/drivers/media/platform/ti-vpe/vpdma.h
+++ b/drivers/media/platform/ti-vpe/vpdma.h
@@ -242,16 +242,16 @@ void vpdma_add_sync_on_channel_ctd(struct vpdma_desc_list *list,
 void vpdma_add_abort_channel_ctd(struct vpdma_desc_list *list,
 		int chan_num);
 void vpdma_add_out_dtd(struct vpdma_desc_list *list, int width,
-		const struct v4l2_rect *c_rect,
+		int stride, const struct v4l2_rect *c_rect,
 		const struct vpdma_data_format *fmt, dma_addr_t dma_addr,
 		int max_w, int max_h, enum vpdma_channel chan, u32 flags);
 void vpdma_rawchan_add_out_dtd(struct vpdma_desc_list *list, int width,
-		const struct v4l2_rect *c_rect,
+		int stride, const struct v4l2_rect *c_rect,
 		const struct vpdma_data_format *fmt, dma_addr_t dma_addr,
 		int max_w, int max_h, int raw_vpdma_chan, u32 flags);
 
 void vpdma_add_in_dtd(struct vpdma_desc_list *list, int width,
-		const struct v4l2_rect *c_rect,
+		int stride, const struct v4l2_rect *c_rect,
 		const struct vpdma_data_format *fmt, dma_addr_t dma_addr,
 		enum vpdma_channel chan, int field, u32 flags, int frame_width,
 		int frame_height, int start_h, int start_v);

commit ee1c02949d99be22485c790fe1c26aaa88e77837
Author: Benoit Parrot <bparrot@ti.com>
Date:   Fri Nov 18 21:20:42 2016 -0200

    [media] media: ti-vpe: vpdma: Add RAW8 and RAW16 data types
    
    Add RAW8 and RAW16 data type to VPDMA.
    To handle RAW format we are re-using the YUV CBY422
    vpdma data type so that we use the vpdma to re-order
    the incoming bytes, as the VIP parser assumes that the
    first byte presented on the bus is the MSB of a 2
    bytes value.
    
    RAW8 handles from 1 to 8 bits.
    RAW16 handles from 9 to 16 bits.
    
    Signed-off-by: Benoit Parrot <bparrot@ti.com>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/platform/ti-vpe/vpdma.h b/drivers/media/platform/ti-vpe/vpdma.h
index 0df156b7c1cf..131700c112b2 100644
--- a/drivers/media/platform/ti-vpe/vpdma.h
+++ b/drivers/media/platform/ti-vpe/vpdma.h
@@ -104,12 +104,18 @@ enum vpdma_rgb_formats {
 	VPDMA_DATA_FMT_BGRA32,
 };
 
+enum vpdma_raw_formats {
+	VPDMA_DATA_FMT_RAW8 = 0,
+	VPDMA_DATA_FMT_RAW16,
+};
+
 enum vpdma_misc_formats {
 	VPDMA_DATA_FMT_MV = 0,
 };
 
 extern const struct vpdma_data_format vpdma_yuv_fmts[];
 extern const struct vpdma_data_format vpdma_rgb_fmts[];
+extern const struct vpdma_data_format vpdma_raw_fmts[];
 extern const struct vpdma_data_format vpdma_misc_fmts[];
 
 enum vpdma_frame_start_event {

commit c786595beb89d74ff709b2ee382f34a1e0040d88
Author: Nikhil Devshatwar <nikhil.nd@ti.com>
Date:   Fri Nov 18 21:20:35 2016 -0200

    [media] media: ti-vpe: vpdma: Fix race condition for firmware loading
    
    vpdma_create API is supposed to allocated the struct vpdma_data and
    return it to the driver. Also, it would call the callback function
    when the VPDMA firmware is loaded.
    
    Typically, VPE driver have following function call:
        dev->vpdma = vpdma_create(pdev, firmware_load_callback);
    And the callback implementation would continue the probe further.
    Also, the dev->vpdma is accessed from the callback implementation.
    
    This may lead to race condition between assignment of dev->vpdma
    and the callback function being triggered.
    This would lead to kernel crash because of NULL pointer access.
    
    Fix this by passing a driver wrapped &vpdma_data instead of allocating
    inside vpdma_create.
    Change the vpdma_create prototype accordingly and fix return paths.
    
    Also, update the VPE driver to use the updated API and
    initialize the dev->vpdma before hand so that the race condition
    is avoided.
    
    Signed-off-by: Nikhil Devshatwar <nikhil.nd@ti.com>
    Signed-off-by: Benoit Parrot <bparrot@ti.com>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/platform/ti-vpe/vpdma.h b/drivers/media/platform/ti-vpe/vpdma.h
index 405a6febc254..0df156b7c1cf 100644
--- a/drivers/media/platform/ti-vpe/vpdma.h
+++ b/drivers/media/platform/ti-vpe/vpdma.h
@@ -273,7 +273,7 @@ void vpdma_set_bg_color(struct vpdma_data *vpdma,
 void vpdma_dump_regs(struct vpdma_data *vpdma);
 
 /* initialize vpdma, passed with VPE's platform device pointer */
-struct vpdma_data *vpdma_create(struct platform_device *pdev,
+int vpdma_create(struct platform_device *pdev, struct vpdma_data *vpdma,
 		void (*cb)(struct platform_device *pdev));
 
 #endif

commit eaa6808d1d815d8d25c7a47649503da678e48e2e
Author: Benoit Parrot <bparrot@ti.com>
Date:   Fri Nov 18 21:20:31 2016 -0200

    [media] media: ti-vpe: vpdma: Corrected YUV422 data type label
    
    The YUV data type definition below are taken from
    both the TRM and i839 Errata information.
    Use the correct data type considering byte
    reordering of components.
    
    Added the 2 missing YUV422 variant.
    Also since the single use of "C" in the 422 case
    to mean "Cr" (i.e. V component). It was decided
    to explicitly label them CR to remove any confusion.
    Bear in mind that the type label refer to the memory
    packed order (LSB - MSB).
    
    Signed-off-by: Benoit Parrot <bparrot@ti.com>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/platform/ti-vpe/vpdma.h b/drivers/media/platform/ti-vpe/vpdma.h
index ccf871ad8800..405a6febc254 100644
--- a/drivers/media/platform/ti-vpe/vpdma.h
+++ b/drivers/media/platform/ti-vpe/vpdma.h
@@ -74,9 +74,11 @@ enum vpdma_yuv_formats {
 	VPDMA_DATA_FMT_C444,
 	VPDMA_DATA_FMT_C422,
 	VPDMA_DATA_FMT_C420,
-	VPDMA_DATA_FMT_YC422,
+	VPDMA_DATA_FMT_YCR422,
 	VPDMA_DATA_FMT_YC444,
-	VPDMA_DATA_FMT_CY422,
+	VPDMA_DATA_FMT_CRY422,
+	VPDMA_DATA_FMT_CBY422,
+	VPDMA_DATA_FMT_YCB422,
 };
 
 enum vpdma_rgb_formats {

commit c1cd15ea4283454f98ef22c5d1d02a59e4510b0e
Author: Nikhil Devshatwar <nikhil.nd@ti.com>
Date:   Fri Nov 18 21:20:29 2016 -0200

    [media] media: ti-vpe: vpdma: allocate and maintain hwlist
    
    VPDMA block used in ti-vip and ti-vpe modules have support for
    up to 8 hardware descriptor lists. A descriptor list can be
    submitted to any of the 8 lists (as long as it's not busy).
    
    When multiple clients want to transfer data in parallel, its easier
    to allocate one list per client and let it use it. This way, the
    list numbers need not be hard-coded into the driver.
    
    Add support for allocating hwlist and maintain them with a priv data.
    
    Signed-off-by: Nikhil Devshatwar <nikhil.nd@ti.com>
    Signed-off-by: Benoit Parrot <bparrot@ti.com>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/platform/ti-vpe/vpdma.h b/drivers/media/platform/ti-vpe/vpdma.h
index 65961147e8f7..ccf871ad8800 100644
--- a/drivers/media/platform/ti-vpe/vpdma.h
+++ b/drivers/media/platform/ti-vpe/vpdma.h
@@ -13,6 +13,7 @@
 #ifndef __TI_VPDMA_H_
 #define __TI_VPDMA_H_
 
+#define VPDMA_MAX_NUM_LIST		8
 /*
  * A vpdma_buf tracks the size, DMA address and mapping status of each
  * driver DMA area.
@@ -36,6 +37,8 @@ struct vpdma_data {
 	struct platform_device	*pdev;
 
 	spinlock_t		lock;
+	bool			hwlist_used[VPDMA_MAX_NUM_LIST];
+	void			*hwlist_priv[VPDMA_MAX_NUM_LIST];
 	/* callback to VPE driver when the firmware is loaded */
 	void (*cb)(struct platform_device *pdev);
 };
@@ -215,6 +218,12 @@ bool vpdma_list_busy(struct vpdma_data *vpdma, int list_num);
 void vpdma_update_dma_addr(struct vpdma_data *vpdma,
 	struct vpdma_desc_list *list, dma_addr_t dma_addr,
 	void *write_dtd, int drop, int idx);
+
+/* VPDMA hardware list funcs */
+int vpdma_hwlist_alloc(struct vpdma_data *vpdma, void *priv);
+void *vpdma_hwlist_get_priv(struct vpdma_data *vpdma, int list_num);
+void *vpdma_hwlist_release(struct vpdma_data *vpdma, int list_num);
+
 /* helpers for creating vpdma descriptors */
 void vpdma_add_cfd_block(struct vpdma_desc_list *list, int client,
 		struct vpdma_buf *blk, u32 dest_offset);

commit afbc0ae9a42e3a447365edc47ba4a206183566ac
Author: Nikhil Devshatwar <nikhil.nd@ti.com>
Date:   Fri Nov 18 21:20:24 2016 -0200

    [media] media: ti-vpe: vpdma: Clear IRQs for individual lists
    
    VPDMA IRQs are registered for multiple lists
    When clearing an IRQ for a list interrupt, all the
    IRQs for the individual lists are to be cleared separately.
    
    Signed-off-by: Nikhil Devshatwar <nikhil.nd@ti.com>
    Signed-off-by: Benoit Parrot <bparrot@ti.com>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/platform/ti-vpe/vpdma.h b/drivers/media/platform/ti-vpe/vpdma.h
index f08f4370ce4a..65961147e8f7 100644
--- a/drivers/media/platform/ti-vpe/vpdma.h
+++ b/drivers/media/platform/ti-vpe/vpdma.h
@@ -244,7 +244,8 @@ int vpdma_list_cleanup(struct vpdma_data *vpdma, int list_num,
 /* vpdma list interrupt management */
 void vpdma_enable_list_complete_irq(struct vpdma_data *vpdma, int irq_num,
 		int list_num, bool enable);
-void vpdma_clear_list_stat(struct vpdma_data *vpdma, int irq_num);
+void vpdma_clear_list_stat(struct vpdma_data *vpdma, int irq_num,
+			   int list_num);
 unsigned int vpdma_get_list_stat(struct vpdma_data *vpdma, int irq_num);
 unsigned int vpdma_get_list_mask(struct vpdma_data *vpdma, int irq_num);
 

commit 4e4676d250efbc81c70e699fc1c805d3ab370e70
Author: Nikhil Devshatwar <nikhil.nd@ti.com>
Date:   Fri Nov 18 21:20:23 2016 -0200

    [media] media: ti-vpe: vpdma: Make list post atomic operation
    
    Writing to the "VPDMA list attribute" register is considered as a list
    post. This informs the VPDMA firmware to load the list from the address
    which should be taken from the "VPDMA list address" register.
    
    As these two register writes are dependent, it is important that the two
    writes happen in atomic manner. This ensures multiple slices (which share
    same VPDMA) can post lists asynchronously and all of them point to the
    correct addresses.
    
    Slightly modified to implementation for the original patch to use
    spin_lock instead of mutex as the list post is also called from
    interrupt context.
    
    Signed-off-by: Nikhil Devshatwar <nikhil.nd@ti.com>
    Signed-off-by: Benoit Parrot <bparrot@ti.com>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/platform/ti-vpe/vpdma.h b/drivers/media/platform/ti-vpe/vpdma.h
index 4dafc1bcf116..f08f4370ce4a 100644
--- a/drivers/media/platform/ti-vpe/vpdma.h
+++ b/drivers/media/platform/ti-vpe/vpdma.h
@@ -35,6 +35,7 @@ struct vpdma_data {
 
 	struct platform_device	*pdev;
 
+	spinlock_t		lock;
 	/* callback to VPE driver when the firmware is loaded */
 	void (*cb)(struct platform_device *pdev);
 };

commit dc12b124353b2b4d8d46b2d0826f4f7905d44612
Author: Nikhil Devshatwar <nikhil.nd@ti.com>
Date:   Fri Nov 18 21:20:22 2016 -0200

    [media] media: ti-vpe: vpdma: Add abort channel desc and cleanup APIs
    
    Whenever VPDMA processes a data descriptor of a list, it processes it
    and sets up the channel for the DMA transaction. List manager holds the
    descriptor in the list until the DMA is complete. If sync_on_channel
    descriptor, or another descriptor for the same channel is present in
    the FIFO, list manager keeps them until the current channel is free.
    
    When the capture stream is closed suddenly while there are pending
    descriptors in the FIFO (streamON failed, application killed), it would
    keep the VPDMA in a busy state. Any further list post would fail with
    EBUSY.
    
    To avoid this, drivers need to stop the current processing list and
    cleanup all the resources VPDMA has taken and also clear the internal FSM
    of list manager. The state machine is cleared by issuing channel specific
    abort descriptor.
    
    Therefore, the vpdma_list_cleanup accepts an array of channels for which
    abort_channel descriptors should be posted. It is driver's responsibility
    to post for all the channels or the channels which were used in the last
    context.
    
    Signed-off-by: Nikhil Devshatwar <nikhil.nd@ti.com>
    Signed-off-by: Benoit Parrot <bparrot@ti.com>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/platform/ti-vpe/vpdma.h b/drivers/media/platform/ti-vpe/vpdma.h
index 32b9ed5191c5..4dafc1bcf116 100644
--- a/drivers/media/platform/ti-vpe/vpdma.h
+++ b/drivers/media/platform/ti-vpe/vpdma.h
@@ -163,6 +163,8 @@ enum vpdma_channel {
 #define VIP_CHAN_YUV_PORTB_OFFSET	2
 #define VIP_CHAN_RGB_PORTB_OFFSET	1
 
+#define VPDMA_MAX_CHANNELS		256
+
 /* flags for VPDMA data descriptors */
 #define VPDMA_DATA_ODD_LINE_SKIP	(1 << 0)
 #define VPDMA_DATA_EVEN_LINE_SKIP	(1 << 1)
@@ -219,6 +221,8 @@ void vpdma_add_cfd_adb(struct vpdma_desc_list *list, int client,
 		struct vpdma_buf *adb);
 void vpdma_add_sync_on_channel_ctd(struct vpdma_desc_list *list,
 		enum vpdma_channel chan);
+void vpdma_add_abort_channel_ctd(struct vpdma_desc_list *list,
+		int chan_num);
 void vpdma_add_out_dtd(struct vpdma_desc_list *list, int width,
 		const struct v4l2_rect *c_rect,
 		const struct vpdma_data_format *fmt, dma_addr_t dma_addr,
@@ -233,6 +237,8 @@ void vpdma_add_in_dtd(struct vpdma_desc_list *list, int width,
 		const struct vpdma_data_format *fmt, dma_addr_t dma_addr,
 		enum vpdma_channel chan, int field, u32 flags, int frame_width,
 		int frame_height, int start_h, int start_v);
+int vpdma_list_cleanup(struct vpdma_data *vpdma, int list_num,
+		int *channels, int size);
 
 /* vpdma list interrupt management */
 void vpdma_enable_list_complete_irq(struct vpdma_data *vpdma, int irq_num,

commit 634271f8f67532d48db6bf0fcacd5423e941bb5e
Author: Nikhil Devshatwar <nikhil.nd@ti.com>
Date:   Fri Nov 18 21:20:21 2016 -0200

    [media] media: ti-vpe: vpdma: Add support for setting max width height
    
    Add a helper function to be able to set the maximum
    VPDMA transfer size to limit potential buffer overrun.
    
    Added enums for max_width and max_height fields of the
    outbound data descriptor.
    
    Changed vpdma_add_out_dtd to accept two more arguments
    for max width and height.
    
    Make use of different max width & height sets for different
    of capture module (i.e. slices).
    
    Signed-off-by: Nikhil Devshatwar <nikhil.nd@ti.com>
    Signed-off-by: Benoit Parrot <bparrot@ti.com>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/platform/ti-vpe/vpdma.h b/drivers/media/platform/ti-vpe/vpdma.h
index 220dc7e793f6..32b9ed5191c5 100644
--- a/drivers/media/platform/ti-vpe/vpdma.h
+++ b/drivers/media/platform/ti-vpe/vpdma.h
@@ -117,6 +117,30 @@ enum vpdma_frame_start_event {
 	VPDMA_FSEVENT_CHANNEL_ACTIVE,
 };
 
+/* max width configurations */
+enum vpdma_max_width {
+	MAX_OUT_WIDTH_UNLIMITED = 0,
+	MAX_OUT_WIDTH_REG1,
+	MAX_OUT_WIDTH_REG2,
+	MAX_OUT_WIDTH_REG3,
+	MAX_OUT_WIDTH_352,
+	MAX_OUT_WIDTH_768,
+	MAX_OUT_WIDTH_1280,
+	MAX_OUT_WIDTH_1920,
+};
+
+/* max height configurations */
+enum vpdma_max_height {
+	MAX_OUT_HEIGHT_UNLIMITED = 0,
+	MAX_OUT_HEIGHT_REG1,
+	MAX_OUT_HEIGHT_REG2,
+	MAX_OUT_HEIGHT_REG3,
+	MAX_OUT_HEIGHT_288,
+	MAX_OUT_HEIGHT_576,
+	MAX_OUT_HEIGHT_720,
+	MAX_OUT_HEIGHT_1080,
+};
+
 /*
  * VPDMA channel numbers
  */
@@ -198,11 +222,12 @@ void vpdma_add_sync_on_channel_ctd(struct vpdma_desc_list *list,
 void vpdma_add_out_dtd(struct vpdma_desc_list *list, int width,
 		const struct v4l2_rect *c_rect,
 		const struct vpdma_data_format *fmt, dma_addr_t dma_addr,
-		enum vpdma_channel chan, u32 flags);
+		int max_w, int max_h, enum vpdma_channel chan, u32 flags);
 void vpdma_rawchan_add_out_dtd(struct vpdma_desc_list *list, int width,
 		const struct v4l2_rect *c_rect,
 		const struct vpdma_data_format *fmt, dma_addr_t dma_addr,
-		int raw_vpdma_chan, u32 flags);
+		int max_w, int max_h, int raw_vpdma_chan, u32 flags);
+
 void vpdma_add_in_dtd(struct vpdma_desc_list *list, int width,
 		const struct v4l2_rect *c_rect,
 		const struct vpdma_data_format *fmt, dma_addr_t dma_addr,
@@ -221,6 +246,9 @@ void vpdma_set_line_mode(struct vpdma_data *vpdma, int line_mode,
 		enum vpdma_channel chan);
 void vpdma_set_frame_start_event(struct vpdma_data *vpdma,
 		enum vpdma_frame_start_event fs_event, enum vpdma_channel chan);
+void vpdma_set_max_size(struct vpdma_data *vpdma, int reg_addr,
+			u32 width, u32 height);
+
 void vpdma_set_bg_color(struct vpdma_data *vpdma,
 			struct vpdma_data_format *fmt, u32 color);
 void vpdma_dump_regs(struct vpdma_data *vpdma);

commit 3f43554c0a3c2a311f484b9131a7b9edf183f6e0
Author: Benoit Parrot <bparrot@ti.com>
Date:   Fri Nov 18 21:20:13 2016 -0200

    [media] media: ti-vpe: vpdma: Add helper to set a background color
    
    Add a helper to set the background color during vpdma transfer.
    This is needed when VPDMA is generating 32 bits RGB format
    to have the Alpha channel set to an appropriate value.
    
    Signed-off-by: Benoit Parrot <bparrot@ti.com>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/platform/ti-vpe/vpdma.h b/drivers/media/platform/ti-vpe/vpdma.h
index 83325d887546..220dc7e793f6 100644
--- a/drivers/media/platform/ti-vpe/vpdma.h
+++ b/drivers/media/platform/ti-vpe/vpdma.h
@@ -221,7 +221,8 @@ void vpdma_set_line_mode(struct vpdma_data *vpdma, int line_mode,
 		enum vpdma_channel chan);
 void vpdma_set_frame_start_event(struct vpdma_data *vpdma,
 		enum vpdma_frame_start_event fs_event, enum vpdma_channel chan);
-
+void vpdma_set_bg_color(struct vpdma_data *vpdma,
+			struct vpdma_data_format *fmt, u32 color);
 void vpdma_dump_regs(struct vpdma_data *vpdma);
 
 /* initialize vpdma, passed with VPE's platform device pointer */

commit 2f88703a0bfd1a4e88e1a7cf2542880ef72fdcc0
Author: Benoit Parrot <bparrot@ti.com>
Date:   Fri Nov 18 21:20:12 2016 -0200

    [media] media: ti-vpe: vpdma: Add multi-instance and multi-client support
    
    The VPDMA (Video Port DMA) as found in devices such as DRA7xx is
    used for both the Video Processing Engine (VPE) and the Video Input
    Port (VIP). Some devices may have multiple VIP instances each with
    its own VPDMA engine. Within VIP two slices can use a single VPDMA
    engine simultaneously. So support for multi instances and multiple
    clients has been added to VPDMA. Needed modification to the existing
    helper functions were then reflected to VPE.
    
    Multi-clients registers offset have also been added in preparation.
    
    Signed-off-by: Benoit Parrot <bparrot@ti.com>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/platform/ti-vpe/vpdma.h b/drivers/media/platform/ti-vpe/vpdma.h
index 2bd8fb050381..83325d887546 100644
--- a/drivers/media/platform/ti-vpe/vpdma.h
+++ b/drivers/media/platform/ti-vpe/vpdma.h
@@ -134,6 +134,11 @@ enum vpdma_channel {
 	VPE_CHAN_RGB_OUT,
 };
 
+#define VIP_CHAN_VIP2_OFFSET		70
+#define VIP_CHAN_MULT_PORTB_OFFSET	16
+#define VIP_CHAN_YUV_PORTB_OFFSET	2
+#define VIP_CHAN_RGB_PORTB_OFFSET	1
+
 /* flags for VPDMA data descriptors */
 #define VPDMA_DATA_ODD_LINE_SKIP	(1 << 0)
 #define VPDMA_DATA_EVEN_LINE_SKIP	(1 << 1)
@@ -177,8 +182,12 @@ void vpdma_unmap_desc_buf(struct vpdma_data *vpdma, struct vpdma_buf *buf);
 int vpdma_create_desc_list(struct vpdma_desc_list *list, size_t size, int type);
 void vpdma_reset_desc_list(struct vpdma_desc_list *list);
 void vpdma_free_desc_list(struct vpdma_desc_list *list);
-int vpdma_submit_descs(struct vpdma_data *vpdma, struct vpdma_desc_list *list);
-
+int vpdma_submit_descs(struct vpdma_data *vpdma, struct vpdma_desc_list *list,
+		       int list_num);
+bool vpdma_list_busy(struct vpdma_data *vpdma, int list_num);
+void vpdma_update_dma_addr(struct vpdma_data *vpdma,
+	struct vpdma_desc_list *list, dma_addr_t dma_addr,
+	void *write_dtd, int drop, int idx);
 /* helpers for creating vpdma descriptors */
 void vpdma_add_cfd_block(struct vpdma_desc_list *list, int client,
 		struct vpdma_buf *blk, u32 dest_offset);
@@ -190,6 +199,10 @@ void vpdma_add_out_dtd(struct vpdma_desc_list *list, int width,
 		const struct v4l2_rect *c_rect,
 		const struct vpdma_data_format *fmt, dma_addr_t dma_addr,
 		enum vpdma_channel chan, u32 flags);
+void vpdma_rawchan_add_out_dtd(struct vpdma_desc_list *list, int width,
+		const struct v4l2_rect *c_rect,
+		const struct vpdma_data_format *fmt, dma_addr_t dma_addr,
+		int raw_vpdma_chan, u32 flags);
 void vpdma_add_in_dtd(struct vpdma_desc_list *list, int width,
 		const struct v4l2_rect *c_rect,
 		const struct vpdma_data_format *fmt, dma_addr_t dma_addr,
@@ -197,9 +210,11 @@ void vpdma_add_in_dtd(struct vpdma_desc_list *list, int width,
 		int frame_height, int start_h, int start_v);
 
 /* vpdma list interrupt management */
-void vpdma_enable_list_complete_irq(struct vpdma_data *vpdma, int list_num,
-		bool enable);
-void vpdma_clear_list_stat(struct vpdma_data *vpdma);
+void vpdma_enable_list_complete_irq(struct vpdma_data *vpdma, int irq_num,
+		int list_num, bool enable);
+void vpdma_clear_list_stat(struct vpdma_data *vpdma, int irq_num);
+unsigned int vpdma_get_list_stat(struct vpdma_data *vpdma, int irq_num);
+unsigned int vpdma_get_list_mask(struct vpdma_data *vpdma, int irq_num);
 
 /* vpdma client configuration */
 void vpdma_set_line_mode(struct vpdma_data *vpdma, int line_mode,

commit 928bf2ba2f0e65a971a60e940c69af0b02ae4a57
Author: Archit Taneja <archit@ti.com>
Date:   Thu Mar 13 08:44:08 2014 -0300

    [media] v4l: ti-vpe: Fix some params in VPE data descriptors
    
    Some parameters of the VPE descriptors were understood incorrectly. They are now
    fixed. The fixes are explained as follows:
    
    - When adding an inbound data descriptor to the VPDMA descriptor list, we intend
      to use c_rect as the cropped region fetched by VPDMA. Therefore, c_rect->width
      shouldn't be used to calculate the line stride, the original image width
      should be used for that. We add a 'width' argument which gives the buffer
      width in memory.
    
    - frame_width and frame_height describe the complete width and height of the
      client to which the channel is connected. If there are multiple channels
      fetching data and providing to the same client, the above 2 arguments should
      be the width and height of the region covered by all the channels. In the case
      where there is only one channel providing pixel data to the client
      (like in VPE), frame_width and frame_height should be the cropped width and
      cropped height respectively. The calculation of these params is done in the
      vpe driver now.
    
    - start_h and start_v is also used in the case of multiple channels to describe
      where each channel should start filling pixel data. We don't use this in VPE,
      and pass 0s to the vpdma_add_in_dtd() helper.
    
    - Some minor changes are made to the vpdma_add_out_dtd() helper. The c_rect
      param is used for specifying the 'composition' target, and 'width'  is added
      to calculate the line stride.
    
    Signed-off-by: Archit Taneja <archit@ti.com>
    Acked-by: Kamil Debski <k.debski@samsung.com>
    Signed-off-by: Kamil Debski <k.debski@samsung.com>
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/drivers/media/platform/ti-vpe/vpdma.h b/drivers/media/platform/ti-vpe/vpdma.h
index bf5f8bbcf917..2bd8fb050381 100644
--- a/drivers/media/platform/ti-vpe/vpdma.h
+++ b/drivers/media/platform/ti-vpe/vpdma.h
@@ -186,13 +186,15 @@ void vpdma_add_cfd_adb(struct vpdma_desc_list *list, int client,
 		struct vpdma_buf *adb);
 void vpdma_add_sync_on_channel_ctd(struct vpdma_desc_list *list,
 		enum vpdma_channel chan);
-void vpdma_add_out_dtd(struct vpdma_desc_list *list, struct v4l2_rect *c_rect,
+void vpdma_add_out_dtd(struct vpdma_desc_list *list, int width,
+		const struct v4l2_rect *c_rect,
 		const struct vpdma_data_format *fmt, dma_addr_t dma_addr,
 		enum vpdma_channel chan, u32 flags);
-void vpdma_add_in_dtd(struct vpdma_desc_list *list, int frame_width,
-		int frame_height, struct v4l2_rect *c_rect,
+void vpdma_add_in_dtd(struct vpdma_desc_list *list, int width,
+		const struct v4l2_rect *c_rect,
 		const struct vpdma_data_format *fmt, dma_addr_t dma_addr,
-		enum vpdma_channel chan, int field, u32 flags);
+		enum vpdma_channel chan, int field, u32 flags, int frame_width,
+		int frame_height, int start_h, int start_v);
 
 /* vpdma list interrupt management */
 void vpdma_enable_list_complete_irq(struct vpdma_data *vpdma, int list_num,

commit b2c9472f0559ba23fa0c2cf565577d1cd9421e50
Author: Archit Taneja <archit@ti.com>
Date:   Thu Mar 13 08:44:04 2014 -0300

    [media] v4l: ti-vpe: register video device only when firmware is loaded
    
    vpe fops(vpe_open in particular) should be called only when VPDMA firmware
    is loaded. File operations on the video device are possible the moment it is
    registered.
    
    Currently, we register the video device for VPE at driver probe, after calling
    a vpdma helper to initialize VPDMA and load firmware. This function is
    non-blocking(it calls request_firmware_nowait()), and doesn't ensure that the
    firmware is actually loaded when it returns.
    
    We remove the device registration from vpe probe, and move it to a callback
    provided by the vpe driver to the vpdma library, through vpdma_create().
    
    The ready field in vpdma_data is no longer needed since we always have firmware
    loaded before the device is registered.
    
    A minor problem with this approach is that if the video_register_device
    fails(which doesn't really happen), the vpe platform device would be registered.
    however, there won't be any v4l2 device corresponding to it.
    
    Signed-off-by: Archit Taneja <archit@ti.com>
    Signed-off-by: Kamil Debski <k.debski@samsung.com>
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/drivers/media/platform/ti-vpe/vpdma.h b/drivers/media/platform/ti-vpe/vpdma.h
index cf40f11b3c8f..bf5f8bbcf917 100644
--- a/drivers/media/platform/ti-vpe/vpdma.h
+++ b/drivers/media/platform/ti-vpe/vpdma.h
@@ -35,8 +35,8 @@ struct vpdma_data {
 
 	struct platform_device	*pdev;
 
-	/* tells whether vpdma firmware is loaded or not */
-	bool ready;
+	/* callback to VPE driver when the firmware is loaded */
+	void (*cb)(struct platform_device *pdev);
 };
 
 enum vpdma_data_format_type {
@@ -208,6 +208,7 @@ void vpdma_set_frame_start_event(struct vpdma_data *vpdma,
 void vpdma_dump_regs(struct vpdma_data *vpdma);
 
 /* initialize vpdma, passed with VPE's platform device pointer */
-struct vpdma_data *vpdma_create(struct platform_device *pdev);
+struct vpdma_data *vpdma_create(struct platform_device *pdev,
+		void (*cb)(struct platform_device *pdev));
 
 #endif

commit b4fcdaf7654f9506f80d4e3f2b045a78333d62dc
Author: Archit Taneja <archit@ti.com>
Date:   Thu Dec 12 05:36:04 2013 -0300

    [media] v4l: ti-vpe: Add a type specifier to describe vpdma data format type
    
    The struct vpdma_data_format holds the color format depth and the data_type
    value needed to be programmed in the data descriptors. However, it doesn't
    tell what type of color format is it, i.e, whether it is RGB, YUV or Misc.
    
    This information is needed when by vpdma library when forming descriptors. We
    modify the depth parameter for the chroma portion of the NV12 format. For this,
    we check if the data_type value is C420. This isn't sufficient as there are
    many YUV and RGB vpdma formats which have the same data_type value. Hence, we
    need to hold the type of the color format for the above case, and possibly more
    cases in the future.
    
    Signed-off-by: Archit Taneja <archit@ti.com>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/drivers/media/platform/ti-vpe/vpdma.h b/drivers/media/platform/ti-vpe/vpdma.h
index 62dd14305e81..cf40f11b3c8f 100644
--- a/drivers/media/platform/ti-vpe/vpdma.h
+++ b/drivers/media/platform/ti-vpe/vpdma.h
@@ -39,7 +39,14 @@ struct vpdma_data {
 	bool ready;
 };
 
+enum vpdma_data_format_type {
+	VPDMA_DATA_FMT_TYPE_YUV,
+	VPDMA_DATA_FMT_TYPE_RGB,
+	VPDMA_DATA_FMT_TYPE_MISC,
+};
+
 struct vpdma_data_format {
+	enum vpdma_data_format_type type;
 	int data_type;
 	u8 depth;
 };

commit a51cd8f5d0a21ccc8d313a9992293ab2541b40a8
Author: Archit Taneja <archit@ti.com>
Date:   Tue Dec 3 08:51:13 2013 -0300

    [media] v4l: ti-vpe: make sure VPDMA line stride constraints are met
    
    When VPDMA fetches or writes to an image buffer, the line stride must be a
    multiple of 16 bytes. If it isn't, VPDMA HW will write/fetch until the next
    16 byte boundry. This causes VPE to work incorrectly for source or destination
    widths which don't satisfy the above alignment requirement.
    In order to prevent this, we now make sure that when we set pix format for the
    input and output buffers, the VPE source and destination image line strides are
    16 byte aligned. Also, the motion vector buffers for the de-interlacer are
    allocated in such a way that it ensures the same alignment.
    
    Signed-off-by: Archit Taneja <archit@ti.com>
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/drivers/media/platform/ti-vpe/vpdma.h b/drivers/media/platform/ti-vpe/vpdma.h
index eaa2a71a5db9..62dd14305e81 100644
--- a/drivers/media/platform/ti-vpe/vpdma.h
+++ b/drivers/media/platform/ti-vpe/vpdma.h
@@ -45,7 +45,10 @@ struct vpdma_data_format {
 };
 
 #define VPDMA_DESC_ALIGN		16	/* 16-byte descriptor alignment */
-
+#define VPDMA_STRIDE_ALIGN		16	/*
+						 * line stride of source and dest
+						 * buffers should be 16 byte aligned
+						 */
 #define VPDMA_DTD_DESC_SIZE		32	/* 8 words */
 #define VPDMA_CFD_CTD_DESC_SIZE		16	/* 4 words */
 

commit 213b8ee4001895dd60910c440f76682fb881b5cc
Author: Archit Taneja <archit@ti.com>
Date:   Wed Oct 16 02:36:46 2013 -0300

    [media] v4l: ti-vpe: Add helpers for creating VPDMA descriptors
    
    Create functions which the VPE driver can use to create a VPDMA
    descriptor and add it to a VPDMA descriptor list. These functions take a
    pointer to an existing list, and append the configuration/data/control
    descriptor header to the list.
    
    In the case of configuration descriptors, the creation of a payload
    block may be required(the payloads can hold VPE MMR values, or scaler
    coefficients). The allocation of the payload buffer and it's content is
    left to the VPE driver. However, the VPDMA library provides helper
    macros to create payload in the correct format.
    
    Add debug functions to dump the descriptors in a way such that it's easy
    to see the values of different fields in the descriptors.
    
    Signed-off-by: Archit Taneja <archit@ti.com>
    Acked-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Kamil Debski <k.debski@samsung.com>
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/drivers/media/platform/ti-vpe/vpdma.h b/drivers/media/platform/ti-vpe/vpdma.h
index 80566892c6cb..eaa2a71a5db9 100644
--- a/drivers/media/platform/ti-vpe/vpdma.h
+++ b/drivers/media/platform/ti-vpe/vpdma.h
@@ -124,6 +124,39 @@ enum vpdma_channel {
 	VPE_CHAN_RGB_OUT,
 };
 
+/* flags for VPDMA data descriptors */
+#define VPDMA_DATA_ODD_LINE_SKIP	(1 << 0)
+#define VPDMA_DATA_EVEN_LINE_SKIP	(1 << 1)
+#define VPDMA_DATA_FRAME_1D		(1 << 2)
+#define VPDMA_DATA_MODE_TILED		(1 << 3)
+
+/*
+ * client identifiers used for configuration descriptors
+ */
+#define CFD_MMR_CLIENT		0
+#define CFD_SC_CLIENT		4
+
+/* Address data block header format */
+struct vpdma_adb_hdr {
+	u32			offset;
+	u32			nwords;
+	u32			reserved0;
+	u32			reserved1;
+};
+
+/* helpers for creating ADB headers for config descriptors MMRs as client */
+#define ADB_ADDR(dma_buf, str, fld)	((dma_buf)->addr + offsetof(str, fld))
+#define MMR_ADB_ADDR(buf, str, fld)	ADB_ADDR(&(buf), struct str, fld)
+
+#define VPDMA_SET_MMR_ADB_HDR(buf, str, hdr, regs, offset_a)	\
+	do {							\
+		struct vpdma_adb_hdr *h;			\
+		struct str *adb = NULL;				\
+		h = MMR_ADB_ADDR(buf, str, hdr);		\
+		h->offset = (offset_a);				\
+		h->nwords = sizeof(adb->regs) >> 2;		\
+	} while (0)
+
 /* vpdma descriptor buffer allocation and management */
 int vpdma_alloc_desc_buf(struct vpdma_buf *buf, size_t size);
 void vpdma_free_desc_buf(struct vpdma_buf *buf);
@@ -136,6 +169,21 @@ void vpdma_reset_desc_list(struct vpdma_desc_list *list);
 void vpdma_free_desc_list(struct vpdma_desc_list *list);
 int vpdma_submit_descs(struct vpdma_data *vpdma, struct vpdma_desc_list *list);
 
+/* helpers for creating vpdma descriptors */
+void vpdma_add_cfd_block(struct vpdma_desc_list *list, int client,
+		struct vpdma_buf *blk, u32 dest_offset);
+void vpdma_add_cfd_adb(struct vpdma_desc_list *list, int client,
+		struct vpdma_buf *adb);
+void vpdma_add_sync_on_channel_ctd(struct vpdma_desc_list *list,
+		enum vpdma_channel chan);
+void vpdma_add_out_dtd(struct vpdma_desc_list *list, struct v4l2_rect *c_rect,
+		const struct vpdma_data_format *fmt, dma_addr_t dma_addr,
+		enum vpdma_channel chan, u32 flags);
+void vpdma_add_in_dtd(struct vpdma_desc_list *list, int frame_width,
+		int frame_height, struct v4l2_rect *c_rect,
+		const struct vpdma_data_format *fmt, dma_addr_t dma_addr,
+		enum vpdma_channel chan, int field, u32 flags);
+
 /* vpdma list interrupt management */
 void vpdma_enable_list_complete_irq(struct vpdma_data *vpdma, int list_num,
 		bool enable);

commit 9262e5a2253ad055d465fcf0905a5b5f160ce6f8
Author: Archit Taneja <archit@ti.com>
Date:   Wed Oct 16 02:36:45 2013 -0300

    [media] v4l: ti-vpe: Create a vpdma helper library
    
    The primary function of VPDMA is to move data between external memory
    and internal processing modules(in our case, VPE) that source or sink
    data. VPDMA is capable of buffering this data and then delivering the
    data as demanded to the modules as programmed. The modules that source
    or sink data are referred to as clients or ports. A channel is setup
    inside the VPDMA to connect a specific memory buffer to a specific
    client. The VPDMA centralizes the DMA control functions and buffering
    required to allow all the clients to minimize the effect of long latency
    times.
    
    Add the following to the VPDMA helper:
    
    - A data struct which describe VPDMA channels. For now, these channels
      are the ones used only by VPE, the list of channels will increase when
      VIP(Video Input Port) also uses the VPDMA library. This channel
      information will be used to populate fields required by data
      descriptors.
    
    - Data structs which describe the different data types supported by
      VPDMA. This data type information will be used to populate fields
      required by data descriptors and used by the VPE driver to map a V4L2
      format to the corresponding VPDMA data type.
    
    - Provide VPDMA register offset definitions, functions to read, write
      and modify VPDMA registers.
    
    - Functions to create and submit a VPDMA list. A list is a group of
      descriptors that makes up a set of DMA transfers that need to be
      completed. Each descriptor will either perform a DMA transaction to
      fetch input buffers and write to output buffers(data descriptors), or
      configure the MMRs of sub blocks of VPE(configuration descriptors), or
      provide control information to VPDMA (control descriptors).
    
    - Functions to allocate, map and unmap buffers needed for the descriptor
      list, payloads containing MMR values and scaler coefficients. These use
      the DMA mapping APIs to ensure exclusive access to VPDMA.
    
    - Functions to enable VPDMA interrupts. VPDMA can trigger an interrupt
      on the VPE interrupt line when a descriptor list is parsed completely
      and the DMA transactions are completed. This requires masking the events
      in VPDMA registers and configuring some top level VPE interrupt
      registers.
    
    - Enable some VPDMA specific parameters: frame start event(when to start
      DMA for a client) and line mode(whether each line fetched should be
      mirrored or not).
    
    - Function to load firmware required by VPDMA. VPDMA requires a firmware
      for it's internal list manager. We add the required request_firmware
      apis to fetch this firmware from user space.
    
    - Function to dump VPDMA registers.
    
    - A function to initialize and create a VPDMA instance, this will be
      called by the VPE driver with it's platform device pointer, this
      function will take care of loading VPDMA firmware and returning a
      vpdma_data instance back to the VPE driver. The VIP driver will also
      call the same init function to initialize it's own VPDMA instance.
    
    Signed-off-by: Archit Taneja <archit@ti.com>
    Acked-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Kamil Debski <k.debski@samsung.com>
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/drivers/media/platform/ti-vpe/vpdma.h b/drivers/media/platform/ti-vpe/vpdma.h
new file mode 100644
index 000000000000..80566892c6cb
--- /dev/null
+++ b/drivers/media/platform/ti-vpe/vpdma.h
@@ -0,0 +1,155 @@
+/*
+ * Copyright (c) 2013 Texas Instruments Inc.
+ *
+ * David Griego, <dagriego@biglakesoftware.com>
+ * Dale Farnsworth, <dale@farnsworth.org>
+ * Archit Taneja, <archit@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+
+#ifndef __TI_VPDMA_H_
+#define __TI_VPDMA_H_
+
+/*
+ * A vpdma_buf tracks the size, DMA address and mapping status of each
+ * driver DMA area.
+ */
+struct vpdma_buf {
+	void			*addr;
+	dma_addr_t		dma_addr;
+	size_t			size;
+	bool			mapped;
+};
+
+struct vpdma_desc_list {
+	struct vpdma_buf buf;
+	void *next;
+	int type;
+};
+
+struct vpdma_data {
+	void __iomem		*base;
+
+	struct platform_device	*pdev;
+
+	/* tells whether vpdma firmware is loaded or not */
+	bool ready;
+};
+
+struct vpdma_data_format {
+	int data_type;
+	u8 depth;
+};
+
+#define VPDMA_DESC_ALIGN		16	/* 16-byte descriptor alignment */
+
+#define VPDMA_DTD_DESC_SIZE		32	/* 8 words */
+#define VPDMA_CFD_CTD_DESC_SIZE		16	/* 4 words */
+
+#define VPDMA_LIST_TYPE_NORMAL		0
+#define VPDMA_LIST_TYPE_SELF_MODIFYING	1
+#define VPDMA_LIST_TYPE_DOORBELL	2
+
+enum vpdma_yuv_formats {
+	VPDMA_DATA_FMT_Y444 = 0,
+	VPDMA_DATA_FMT_Y422,
+	VPDMA_DATA_FMT_Y420,
+	VPDMA_DATA_FMT_C444,
+	VPDMA_DATA_FMT_C422,
+	VPDMA_DATA_FMT_C420,
+	VPDMA_DATA_FMT_YC422,
+	VPDMA_DATA_FMT_YC444,
+	VPDMA_DATA_FMT_CY422,
+};
+
+enum vpdma_rgb_formats {
+	VPDMA_DATA_FMT_RGB565 = 0,
+	VPDMA_DATA_FMT_ARGB16_1555,
+	VPDMA_DATA_FMT_ARGB16,
+	VPDMA_DATA_FMT_RGBA16_5551,
+	VPDMA_DATA_FMT_RGBA16,
+	VPDMA_DATA_FMT_ARGB24,
+	VPDMA_DATA_FMT_RGB24,
+	VPDMA_DATA_FMT_ARGB32,
+	VPDMA_DATA_FMT_RGBA24,
+	VPDMA_DATA_FMT_RGBA32,
+	VPDMA_DATA_FMT_BGR565,
+	VPDMA_DATA_FMT_ABGR16_1555,
+	VPDMA_DATA_FMT_ABGR16,
+	VPDMA_DATA_FMT_BGRA16_5551,
+	VPDMA_DATA_FMT_BGRA16,
+	VPDMA_DATA_FMT_ABGR24,
+	VPDMA_DATA_FMT_BGR24,
+	VPDMA_DATA_FMT_ABGR32,
+	VPDMA_DATA_FMT_BGRA24,
+	VPDMA_DATA_FMT_BGRA32,
+};
+
+enum vpdma_misc_formats {
+	VPDMA_DATA_FMT_MV = 0,
+};
+
+extern const struct vpdma_data_format vpdma_yuv_fmts[];
+extern const struct vpdma_data_format vpdma_rgb_fmts[];
+extern const struct vpdma_data_format vpdma_misc_fmts[];
+
+enum vpdma_frame_start_event {
+	VPDMA_FSEVENT_HDMI_FID = 0,
+	VPDMA_FSEVENT_DVO2_FID,
+	VPDMA_FSEVENT_HDCOMP_FID,
+	VPDMA_FSEVENT_SD_FID,
+	VPDMA_FSEVENT_LM_FID0,
+	VPDMA_FSEVENT_LM_FID1,
+	VPDMA_FSEVENT_LM_FID2,
+	VPDMA_FSEVENT_CHANNEL_ACTIVE,
+};
+
+/*
+ * VPDMA channel numbers
+ */
+enum vpdma_channel {
+	VPE_CHAN_LUMA1_IN,
+	VPE_CHAN_CHROMA1_IN,
+	VPE_CHAN_LUMA2_IN,
+	VPE_CHAN_CHROMA2_IN,
+	VPE_CHAN_LUMA3_IN,
+	VPE_CHAN_CHROMA3_IN,
+	VPE_CHAN_MV_IN,
+	VPE_CHAN_MV_OUT,
+	VPE_CHAN_LUMA_OUT,
+	VPE_CHAN_CHROMA_OUT,
+	VPE_CHAN_RGB_OUT,
+};
+
+/* vpdma descriptor buffer allocation and management */
+int vpdma_alloc_desc_buf(struct vpdma_buf *buf, size_t size);
+void vpdma_free_desc_buf(struct vpdma_buf *buf);
+int vpdma_map_desc_buf(struct vpdma_data *vpdma, struct vpdma_buf *buf);
+void vpdma_unmap_desc_buf(struct vpdma_data *vpdma, struct vpdma_buf *buf);
+
+/* vpdma descriptor list funcs */
+int vpdma_create_desc_list(struct vpdma_desc_list *list, size_t size, int type);
+void vpdma_reset_desc_list(struct vpdma_desc_list *list);
+void vpdma_free_desc_list(struct vpdma_desc_list *list);
+int vpdma_submit_descs(struct vpdma_data *vpdma, struct vpdma_desc_list *list);
+
+/* vpdma list interrupt management */
+void vpdma_enable_list_complete_irq(struct vpdma_data *vpdma, int list_num,
+		bool enable);
+void vpdma_clear_list_stat(struct vpdma_data *vpdma);
+
+/* vpdma client configuration */
+void vpdma_set_line_mode(struct vpdma_data *vpdma, int line_mode,
+		enum vpdma_channel chan);
+void vpdma_set_frame_start_event(struct vpdma_data *vpdma,
+		enum vpdma_frame_start_event fs_event, enum vpdma_channel chan);
+
+void vpdma_dump_regs(struct vpdma_data *vpdma);
+
+/* initialize vpdma, passed with VPE's platform device pointer */
+struct vpdma_data *vpdma_create(struct platform_device *pdev);
+
+#endif
