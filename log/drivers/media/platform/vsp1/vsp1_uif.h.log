commit 33025a5c661a9cc9a48af5e00b7fd4ea0bd36008
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Mon Nov 27 15:45:42 2017 -0500

    media: v4l: vsp1: Add support for the DISCOM entity
    
    The DISCOM calculates a CRC on a configurable window of the frame. It
    interfaces to the VSP through the UIF glue, hence the name used in the
    code.
    
    The module supports configuration of the CRC window through the crop
    rectangle on the sink pad of the corresponding entity. However, unlike
    the traditional V4L2 subdevice model, the crop rectangle does not
    influence the format on the source pad.
    
    Modeling the DISCOM as a sink-only entity would allow adhering to the
    V4L2 subdevice model at the expense of more complex code in the driver,
    as at the hardware level the UIF is handled as a sink+source entity. As
    the DISCOM is only present in R-Car Gen3 VSP-D and VSP-DL instances it
    is not exposed to userspace through V4L2 but controlled through the DU
    driver. We can thus change this model later if needed without fear of
    affecting userspace.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Reviewed-by: Jacopo Mondi <jacopo@jmondi.org>
    Reviewed-by: Kieran Bingham <kieran.bingham+renesas@ideasonboard.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/platform/vsp1/vsp1_uif.h b/drivers/media/platform/vsp1/vsp1_uif.h
new file mode 100644
index 000000000000..c71ab5f6a6f8
--- /dev/null
+++ b/drivers/media/platform/vsp1/vsp1_uif.h
@@ -0,0 +1,32 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * vsp1_uif.h  --  R-Car VSP1 User Logic Interface
+ *
+ * Copyright (C) 2017-2018 Laurent Pinchart
+ *
+ * Contact: Laurent Pinchart (laurent.pinchart@ideasonboard.com)
+ */
+#ifndef __VSP1_UIF_H__
+#define __VSP1_UIF_H__
+
+#include "vsp1_entity.h"
+
+struct vsp1_device;
+
+#define UIF_PAD_SINK				0
+#define UIF_PAD_SOURCE				1
+
+struct vsp1_uif {
+	struct vsp1_entity entity;
+	bool m3w_quirk;
+};
+
+static inline struct vsp1_uif *to_uif(struct v4l2_subdev *subdev)
+{
+	return container_of(subdev, struct vsp1_uif, entity.subdev);
+}
+
+struct vsp1_uif *vsp1_uif_create(struct vsp1_device *vsp1, unsigned int index);
+u32 vsp1_uif_get_crc(struct vsp1_uif *uif);
+
+#endif /* __VSP1_UIF_H__ */
