commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/media/platform/exynos4-is/fimc-is-param.c b/drivers/media/platform/exynos4-is/fimc-is-param.c
index 72b9b436c5c0..9c816ae3b3e5 100644
--- a/drivers/media/platform/exynos4-is/fimc-is-param.c
+++ b/drivers/media/platform/exynos4-is/fimc-is-param.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Samsung EXYNOS4x12 FIMC-IS (Imaging Subsystem) driver
  *
@@ -5,10 +6,6 @@
  *
  * Authors: Younghwan Joo <yhwan.joo@samsung.com>
  *          Sylwester Nawrocki <s.nawrocki@samsung.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 #define pr_fmt(fmt) "%s:%d " fmt, __func__, __LINE__
 

commit 2ff1d4c13b2881e9276a00bd3032d9afe7d15ef1
Author: Mauro Carvalho Chehab <m.chehab@samsung.com>
Date:   Tue Aug 26 10:56:24 2014 -0300

    [media] fimc-is-param: get rid of warnings
    
    In file included from drivers/media/platform/exynos4-is/fimc-is-param.c:31:0:
    drivers/media/platform/exynos4-is/fimc-is-errno.h:245:20: warning: type qualifiers ignored on function return type [-Wignored-qualifiers]
     const char * const fimc_is_strerr(unsigned int error);
                        ^
    drivers/media/platform/exynos4-is/fimc-is-errno.h:246:20: warning: type qualifiers ignored on function return type [-Wignored-qualifiers]
     const char * const fimc_is_param_strerr(unsigned int error);
                        ^
    drivers/media/platform/exynos4-is/fimc-is-param.c: In function 'fimc_is_set_initial_params':
    drivers/media/platform/exynos4-is/fimc-is-param.c:670:23: warning: variable 'sensor' set but not used [-Wunused-but-set-variable]
      struct sensor_param *sensor;
                           ^
    
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/drivers/media/platform/exynos4-is/fimc-is-param.c b/drivers/media/platform/exynos4-is/fimc-is-param.c
index bf1465d1bf6d..72b9b436c5c0 100644
--- a/drivers/media/platform/exynos4-is/fimc-is-param.c
+++ b/drivers/media/platform/exynos4-is/fimc-is-param.c
@@ -667,7 +667,6 @@ void __is_set_fd_config_orientation_val(struct fimc_is *is, u32 val)
 void fimc_is_set_initial_params(struct fimc_is *is)
 {
 	struct global_param *global;
-	struct sensor_param *sensor;
 	struct isp_param *isp;
 	struct drc_param *drc;
 	struct fd_param *fd;
@@ -676,7 +675,6 @@ void fimc_is_set_initial_params(struct fimc_is *is)
 
 	index = is->config_index;
 	global = &is->config[index].global;
-	sensor = &is->config[index].sensor;
 	isp = &is->config[index].isp;
 	drc = &is->config[index].drc;
 	fd = &is->config[index].fd;

commit 34947b8aebe3f2d4eceb65fceafa92bf8dc97d96
Author: Sylwester Nawrocki <s.nawrocki@samsung.com>
Date:   Fri Dec 20 19:35:06 2013 -0300

    [media] exynos4-is: Add the FIMC-IS ISP capture DMA driver
    
    Add a video capture node for the FIMC-IS ISP IP block. The Exynos4x12
    FIMC-IS ISP IP block has 2 DMA interfaces that allow to capture raw
    Bayer and YUV data to memory.  Currently only the DMA2 output is and
    raw Bayer data capture is supported.
    
    Signed-off-by: Sylwester Nawrocki <s.nawrocki@samsung.com>
    Acked-by: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/drivers/media/platform/exynos4-is/fimc-is-param.c b/drivers/media/platform/exynos4-is/fimc-is-param.c
index 9bf3ddd9e028..bf1465d1bf6d 100644
--- a/drivers/media/platform/exynos4-is/fimc-is-param.c
+++ b/drivers/media/platform/exynos4-is/fimc-is-param.c
@@ -56,7 +56,7 @@ static void __fimc_is_hw_update_param_sensor_framerate(struct fimc_is *is)
 	__hw_param_copy(dst, src);
 }
 
-static int __fimc_is_hw_update_param(struct fimc_is *is, u32 offset)
+int __fimc_is_hw_update_param(struct fimc_is *is, u32 offset)
 {
 	struct is_param_region *par = &is->is_p_region->parameter;
 	struct chain_config *cfg = &is->config[is->config_index];

commit 3263f741e45bd6571a81528a771b863dad449af0
Author: Sachin Kamat <sachin.kamat@linaro.org>
Date:   Fri Aug 2 02:32:13 2013 -0300

    [media] exynos4-is: Annotate unused functions
    
    __is_set_init_isp_aa and fimc_is_hw_set_tune currently do not have
    any callers. However these functions may be used in the future. Hence
    instead of deleting them, staticize and annotate them with __maybe_unused
    flag to avoid compiler warnings.
    
    Signed-off-by: Sachin Kamat <sachin.kamat@linaro.org>
    Signed-off-by: Sylwester Nawrocki <s.nawrocki@samsung.com>
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/drivers/media/platform/exynos4-is/fimc-is-param.c b/drivers/media/platform/exynos4-is/fimc-is-param.c
index a353be091a22..9bf3ddd9e028 100644
--- a/drivers/media/platform/exynos4-is/fimc-is-param.c
+++ b/drivers/media/platform/exynos4-is/fimc-is-param.c
@@ -287,7 +287,7 @@ void __is_set_sensor(struct fimc_is *is, int fps)
 	fimc_is_set_param_bit(is, PARAM_ISP_OTF_INPUT);
 }
 
-void __is_set_init_isp_aa(struct fimc_is *is)
+static void __maybe_unused __is_set_init_isp_aa(struct fimc_is *is)
 {
 	struct isp_param *isp;
 

commit ae796c78684c1679b82eaafcd236d6fc1de099a2
Author: Sachin Kamat <sachin.kamat@linaro.org>
Date:   Fri Aug 2 02:32:12 2013 -0300

    [media] exynos4-is: Staticize local symbol
    
    __fimc_is_hw_update_param is used only in this file. Make it static.
    
    Signed-off-by: Sachin Kamat <sachin.kamat@linaro.org>
    Signed-off-by: Sylwester Nawrocki <s.nawrocki@samsung.com>
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/drivers/media/platform/exynos4-is/fimc-is-param.c b/drivers/media/platform/exynos4-is/fimc-is-param.c
index c7e7f694c6ed..a353be091a22 100644
--- a/drivers/media/platform/exynos4-is/fimc-is-param.c
+++ b/drivers/media/platform/exynos4-is/fimc-is-param.c
@@ -56,7 +56,7 @@ static void __fimc_is_hw_update_param_sensor_framerate(struct fimc_is *is)
 	__hw_param_copy(dst, src);
 }
 
-int __fimc_is_hw_update_param(struct fimc_is *is, u32 offset)
+static int __fimc_is_hw_update_param(struct fimc_is *is, u32 offset)
 {
 	struct is_param_region *par = &is->is_p_region->parameter;
 	struct chain_config *cfg = &is->config[is->config_index];

commit 0e761b21b9d6c7a95a8e2b858af85d07f6c62d99
Author: Phil Carmody <phil.carmody@partner.samsung.com>
Date:   Fri May 31 13:47:00 2013 -0300

    [media] exynos4-is: Simplify bitmask usage
    
    Merge the two sets of flags into one array to simplify accessing
    arbitrary bits from them.
    
    Signed-off-by: Phil Carmody <phil.carmody@partner.samsung.com>
    Signed-off-by: Sylwester Nawrocki <s.nawrocki@samsung.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/platform/exynos4-is/fimc-is-param.c b/drivers/media/platform/exynos4-is/fimc-is-param.c
index c435db0da673..c7e7f694c6ed 100644
--- a/drivers/media/platform/exynos4-is/fimc-is-param.c
+++ b/drivers/media/platform/exynos4-is/fimc-is-param.c
@@ -168,8 +168,8 @@ unsigned int __get_pending_param_count(struct fimc_is *is)
 	unsigned int count;
 
 	spin_lock_irqsave(&is->slock, flags);
-	count = hweight32(config->p_region_index1);
-	count += hweight32(config->p_region_index2);
+	count = hweight32(config->p_region_index[0]);
+	count += hweight32(config->p_region_index[1]);
 	spin_unlock_irqrestore(&is->slock, flags);
 
 	return count;
@@ -177,31 +177,30 @@ unsigned int __get_pending_param_count(struct fimc_is *is)
 
 int __is_hw_update_params(struct fimc_is *is)
 {
-	unsigned long *p_index1, *p_index2;
+	unsigned long *p_index;
 	int i, id, ret = 0;
 
 	id = is->config_index;
-	p_index1 = &is->config[id].p_region_index1;
-	p_index2 = &is->config[id].p_region_index2;
+	p_index = &is->config[id].p_region_index[0];
 
-	if (test_bit(PARAM_GLOBAL_SHOTMODE, p_index1))
+	if (test_bit(PARAM_GLOBAL_SHOTMODE, p_index))
 		__fimc_is_hw_update_param_global_shotmode(is);
 
-	if (test_bit(PARAM_SENSOR_FRAME_RATE, p_index1))
+	if (test_bit(PARAM_SENSOR_FRAME_RATE, p_index))
 		__fimc_is_hw_update_param_sensor_framerate(is);
 
 	for (i = PARAM_ISP_CONTROL; i < PARAM_DRC_CONTROL; i++) {
-		if (test_bit(i, p_index1))
+		if (test_bit(i, p_index))
 			ret = __fimc_is_hw_update_param(is, i);
 	}
 
 	for (i = PARAM_DRC_CONTROL; i < PARAM_SCALERC_CONTROL; i++) {
-		if (test_bit(i, p_index1))
+		if (test_bit(i, p_index))
 			ret = __fimc_is_hw_update_param(is, i);
 	}
 
 	for (i = PARAM_FD_CONTROL; i <= PARAM_FD_CONFIG; i++) {
-		if (test_bit((i - 32), p_index2))
+		if (test_bit(i, p_index))
 			ret = __fimc_is_hw_update_param(is, i);
 	}
 
@@ -243,7 +242,7 @@ void __is_set_frame_size(struct fimc_is *is, struct v4l2_mbus_framefmt *mf)
 	fd->otf_input.height = mf->height;
 
 	if (test_bit(PARAM_ISP_OTF_INPUT,
-		      &is->config[index].p_region_index1))
+		      &is->config[index].p_region_index[0]))
 		return;
 
 	/* Update field */
@@ -368,7 +367,7 @@ void __is_set_isp_adjust(struct fimc_is *is, u32 cmd, u32 val)
 	unsigned long *p_index;
 	struct isp_param *isp;
 
-	p_index = &is->config[index].p_region_index1;
+	p_index = &is->config[index].p_region_index[0];
 	isp = &is->config[index].isp;
 
 	switch (cmd) {
@@ -415,7 +414,7 @@ void __is_set_isp_metering(struct fimc_is *is, u32 id, u32 val)
 	struct isp_param *isp;
 	unsigned long *p_index;
 
-	p_index = &is->config[index].p_region_index1;
+	p_index = &is->config[index].p_region_index[0];
 	isp = &is->config[index].isp;
 
 	switch (id) {
@@ -476,7 +475,7 @@ void __is_set_fd_control(struct fimc_is *is, u32 val)
 	struct fd_param *fd;
 	unsigned long *p_index;
 
-	p_index = &is->config[index].p_region_index2;
+	p_index = &is->config[index].p_region_index[1];
 	fd = &is->config[index].fd;
 
 	fd->control.cmd = val;
@@ -491,7 +490,7 @@ void __is_set_fd_config_maxface(struct fimc_is *is, u32 val)
 	struct fd_param *fd;
 	unsigned long *p_index;
 
-	p_index = &is->config[index].p_region_index2;
+	p_index = &is->config[index].p_region_index[1];
 	fd = &is->config[index].fd;
 
 	fd->config.max_number = val;
@@ -511,7 +510,7 @@ void __is_set_fd_config_rollangle(struct fimc_is *is, u32 val)
 	struct fd_param *fd;
 	unsigned long *p_index;
 
-	p_index = &is->config[index].p_region_index2;
+	p_index = &is->config[index].p_region_index[1];
 	fd = &is->config[index].fd;
 
 	fd->config.roll_angle = val;
@@ -531,7 +530,7 @@ void __is_set_fd_config_yawangle(struct fimc_is *is, u32 val)
 	struct fd_param *fd;
 	unsigned long *p_index;
 
-	p_index = &is->config[index].p_region_index2;
+	p_index = &is->config[index].p_region_index[1];
 	fd = &is->config[index].fd;
 
 	fd->config.yaw_angle = val;
@@ -551,7 +550,7 @@ void __is_set_fd_config_smilemode(struct fimc_is *is, u32 val)
 	struct fd_param *fd;
 	unsigned long *p_index;
 
-	p_index = &is->config[index].p_region_index2;
+	p_index = &is->config[index].p_region_index[1];
 	fd = &is->config[index].fd;
 
 	fd->config.smile_mode = val;
@@ -571,7 +570,7 @@ void __is_set_fd_config_blinkmode(struct fimc_is *is, u32 val)
 	struct fd_param *fd;
 	unsigned long *p_index;
 
-	p_index = &is->config[index].p_region_index2;
+	p_index = &is->config[index].p_region_index[1];
 	fd = &is->config[index].fd;
 
 	fd->config.blink_mode = val;
@@ -591,7 +590,7 @@ void __is_set_fd_config_eyedetect(struct fimc_is *is, u32 val)
 	struct fd_param *fd;
 	unsigned long *p_index;
 
-	p_index = &is->config[index].p_region_index2;
+	p_index = &is->config[index].p_region_index[1];
 	fd = &is->config[index].fd;
 
 	fd->config.eye_detect = val;
@@ -611,7 +610,7 @@ void __is_set_fd_config_mouthdetect(struct fimc_is *is, u32 val)
 	struct fd_param *fd;
 	unsigned long *p_index;
 
-	p_index = &is->config[index].p_region_index2;
+	p_index = &is->config[index].p_region_index[1];
 	fd = &is->config[index].fd;
 
 	fd->config.mouth_detect = val;
@@ -631,7 +630,7 @@ void __is_set_fd_config_orientation(struct fimc_is *is, u32 val)
 	struct fd_param *fd;
 	unsigned long *p_index;
 
-	p_index = &is->config[index].p_region_index2;
+	p_index = &is->config[index].p_region_index[1];
 	fd = &is->config[index].fd;
 
 	fd->config.orientation = val;
@@ -651,7 +650,7 @@ void __is_set_fd_config_orientation_val(struct fimc_is *is, u32 val)
 	struct fd_param *fd;
 	unsigned long *p_index;
 
-	p_index = &is->config[index].p_region_index2;
+	p_index = &is->config[index].p_region_index[1];
 	fd = &is->config[index].fd;
 
 	fd->config.orientation_value = val;
@@ -672,7 +671,7 @@ void fimc_is_set_initial_params(struct fimc_is *is)
 	struct isp_param *isp;
 	struct drc_param *drc;
 	struct fd_param *fd;
-	unsigned long *p_index1, *p_index2;
+	unsigned long *p_index;
 	unsigned int index;
 
 	index = is->config_index;
@@ -681,8 +680,7 @@ void fimc_is_set_initial_params(struct fimc_is *is)
 	isp = &is->config[index].isp;
 	drc = &is->config[index].drc;
 	fd = &is->config[index].fd;
-	p_index1 = &is->config[index].p_region_index1;
-	p_index2 = &is->config[index].p_region_index2;
+	p_index = &is->config[index].p_region_index[0];
 
 	/* Global */
 	global->shotmode.cmd = 1;
@@ -695,7 +693,7 @@ void fimc_is_set_initial_params(struct fimc_is *is)
 	fimc_is_set_param_bit(is, PARAM_ISP_CONTROL);
 
 	isp->otf_input.cmd = OTF_INPUT_COMMAND_ENABLE;
-	if (!test_bit(PARAM_ISP_OTF_INPUT, p_index1)) {
+	if (!test_bit(PARAM_ISP_OTF_INPUT, p_index)) {
 		isp->otf_input.width = DEFAULT_PREVIEW_STILL_WIDTH;
 		isp->otf_input.height = DEFAULT_PREVIEW_STILL_HEIGHT;
 		fimc_is_set_param_bit(is, PARAM_ISP_OTF_INPUT);
@@ -738,20 +736,20 @@ void fimc_is_set_initial_params(struct fimc_is *is)
 	isp->aa.target = ISP_AA_TARGET_AE | ISP_AA_TARGET_AWB;
 	fimc_is_set_param_bit(is, PARAM_ISP_AA);
 
-	if (!test_bit(PARAM_ISP_FLASH, p_index1))
+	if (!test_bit(PARAM_ISP_FLASH, p_index))
 		__is_set_isp_flash(is, ISP_FLASH_COMMAND_DISABLE,
 						ISP_FLASH_REDEYE_DISABLE);
 
-	if (!test_bit(PARAM_ISP_AWB, p_index1))
+	if (!test_bit(PARAM_ISP_AWB, p_index))
 		__is_set_isp_awb(is, ISP_AWB_COMMAND_AUTO, 0);
 
-	if (!test_bit(PARAM_ISP_IMAGE_EFFECT, p_index1))
+	if (!test_bit(PARAM_ISP_IMAGE_EFFECT, p_index))
 		__is_set_isp_effect(is, ISP_IMAGE_EFFECT_DISABLE);
 
-	if (!test_bit(PARAM_ISP_ISO, p_index1))
+	if (!test_bit(PARAM_ISP_ISO, p_index))
 		__is_set_isp_iso(is, ISP_ISO_COMMAND_AUTO, 0);
 
-	if (!test_bit(PARAM_ISP_ADJUST, p_index1)) {
+	if (!test_bit(PARAM_ISP_ADJUST, p_index)) {
 		__is_set_isp_adjust(is, ISP_ADJUST_COMMAND_MANUAL_CONTRAST, 0);
 		__is_set_isp_adjust(is,
 				ISP_ADJUST_COMMAND_MANUAL_SATURATION, 0);
@@ -762,7 +760,7 @@ void fimc_is_set_initial_params(struct fimc_is *is)
 		__is_set_isp_adjust(is, ISP_ADJUST_COMMAND_MANUAL_HUE, 0);
 	}
 
-	if (!test_bit(PARAM_ISP_METERING, p_index1)) {
+	if (!test_bit(PARAM_ISP_METERING, p_index)) {
 		__is_set_isp_metering(is, 0, ISP_METERING_COMMAND_CENTER);
 		__is_set_isp_metering(is, 1, 0);
 		__is_set_isp_metering(is, 2, 0);
@@ -770,11 +768,11 @@ void fimc_is_set_initial_params(struct fimc_is *is)
 		__is_set_isp_metering(is, 4, 0);
 	}
 
-	if (!test_bit(PARAM_ISP_AFC, p_index1))
+	if (!test_bit(PARAM_ISP_AFC, p_index))
 		__is_set_isp_afc(is, ISP_AFC_COMMAND_AUTO, 0);
 
 	isp->otf_output.cmd = OTF_OUTPUT_COMMAND_ENABLE;
-	if (!test_bit(PARAM_ISP_OTF_OUTPUT, p_index1)) {
+	if (!test_bit(PARAM_ISP_OTF_OUTPUT, p_index)) {
 		isp->otf_output.width = DEFAULT_PREVIEW_STILL_WIDTH;
 		isp->otf_output.height = DEFAULT_PREVIEW_STILL_HEIGHT;
 		fimc_is_set_param_bit(is, PARAM_ISP_OTF_OUTPUT);
@@ -784,7 +782,7 @@ void fimc_is_set_initial_params(struct fimc_is *is)
 	isp->otf_output.order = 0;
 	isp->otf_output.err = OTF_OUTPUT_ERROR_NONE;
 
-	if (!test_bit(PARAM_ISP_DMA1_OUTPUT, p_index1)) {
+	if (!test_bit(PARAM_ISP_DMA1_OUTPUT, p_index)) {
 		isp->dma1_output.cmd = DMA_OUTPUT_COMMAND_DISABLE;
 		isp->dma1_output.width = 0;
 		isp->dma1_output.height = 0;
@@ -800,7 +798,7 @@ void fimc_is_set_initial_params(struct fimc_is *is)
 		fimc_is_set_param_bit(is, PARAM_ISP_DMA1_OUTPUT);
 	}
 
-	if (!test_bit(PARAM_ISP_DMA2_OUTPUT, p_index1)) {
+	if (!test_bit(PARAM_ISP_DMA2_OUTPUT, p_index)) {
 		isp->dma2_output.cmd = DMA_OUTPUT_COMMAND_DISABLE;
 		isp->dma2_output.width = 0;
 		isp->dma2_output.height = 0;
@@ -817,7 +815,7 @@ void fimc_is_set_initial_params(struct fimc_is *is)
 	}
 
 	/* Sensor */
-	if (!test_bit(PARAM_SENSOR_FRAME_RATE, p_index1)) {
+	if (!test_bit(PARAM_SENSOR_FRAME_RATE, p_index)) {
 		if (is->config_index == 0)
 			__is_set_sensor(is, 0);
 	}
@@ -827,7 +825,7 @@ void fimc_is_set_initial_params(struct fimc_is *is)
 	__is_set_drc_control(is, CONTROL_BYPASS_ENABLE);
 
 	drc->otf_input.cmd = OTF_INPUT_COMMAND_ENABLE;
-	if (!test_bit(PARAM_DRC_OTF_INPUT, p_index1)) {
+	if (!test_bit(PARAM_DRC_OTF_INPUT, p_index)) {
 		drc->otf_input.width = DEFAULT_PREVIEW_STILL_WIDTH;
 		drc->otf_input.height = DEFAULT_PREVIEW_STILL_HEIGHT;
 		fimc_is_set_param_bit(is, PARAM_DRC_OTF_INPUT);
@@ -850,7 +848,7 @@ void fimc_is_set_initial_params(struct fimc_is *is)
 	fimc_is_set_param_bit(is, PARAM_DRC_DMA_INPUT);
 
 	drc->otf_output.cmd = OTF_OUTPUT_COMMAND_ENABLE;
-	if (!test_bit(PARAM_DRC_OTF_OUTPUT, p_index1)) {
+	if (!test_bit(PARAM_DRC_OTF_OUTPUT, p_index)) {
 		drc->otf_output.width = DEFAULT_PREVIEW_STILL_WIDTH;
 		drc->otf_output.height = DEFAULT_PREVIEW_STILL_HEIGHT;
 		fimc_is_set_param_bit(is, PARAM_DRC_OTF_OUTPUT);
@@ -865,7 +863,7 @@ void fimc_is_set_initial_params(struct fimc_is *is)
 	fd->control.bypass = CONTROL_BYPASS_DISABLE;
 
 	fd->otf_input.cmd = OTF_INPUT_COMMAND_ENABLE;
-	if (!test_bit((PARAM_FD_OTF_INPUT - 32), p_index2)) {
+	if (!test_bit(PARAM_FD_OTF_INPUT, p_index)) {
 		fd->otf_input.width = DEFAULT_PREVIEW_STILL_WIDTH;
 		fd->otf_input.height = DEFAULT_PREVIEW_STILL_HEIGHT;
 		fimc_is_set_param_bit(is, PARAM_FD_OTF_INPUT);

commit e0e9f67afcd5e06bc1ff6ecbf130635673a41d48
Author: Sachin Kamat <sachin.kamat@linaro.org>
Date:   Tue Apr 16 02:02:21 2013 -0300

    [media] exynos4-is: Staticize local symbols
    
    These symbols are used only in their respective files and hence
    should be made static.
    [s.nawrocki@samsung.com: dropped the __fimc_is_hw_update_param()
     function change]
    
    Signed-off-by: Sachin Kamat <sachin.kamat@linaro.org>
    Signed-off-by: Sylwester Nawrocki <s.nawrocki@samsung.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/platform/exynos4-is/fimc-is-param.c b/drivers/media/platform/exynos4-is/fimc-is-param.c
index 53fe2a2b4db3..c435db0da673 100644
--- a/drivers/media/platform/exynos4-is/fimc-is-param.c
+++ b/drivers/media/platform/exynos4-is/fimc-is-param.c
@@ -38,7 +38,7 @@ static void __hw_param_copy(void *dst, void *src)
 	memcpy(dst, src, FIMC_IS_PARAM_MAX_SIZE);
 }
 
-void __fimc_is_hw_update_param_global_shotmode(struct fimc_is *is)
+static void __fimc_is_hw_update_param_global_shotmode(struct fimc_is *is)
 {
 	struct param_global_shotmode *dst, *src;
 
@@ -47,7 +47,7 @@ void __fimc_is_hw_update_param_global_shotmode(struct fimc_is *is)
 	__hw_param_copy(dst, src);
 }
 
-void __fimc_is_hw_update_param_sensor_framerate(struct fimc_is *is)
+static void __fimc_is_hw_update_param_sensor_framerate(struct fimc_is *is)
 {
 	struct param_sensor_framerate *dst, *src;
 

commit 03385b8e9d7a9f361c178ea33fa76b39793f85b2
Author: Sylwester Nawrocki <s.nawrocki@samsung.com>
Date:   Wed Apr 10 06:27:22 2013 -0300

    [media] exynos4-is: Remove meaningless test before bit setting
    
    There is no need to check same bit before setting it, since we
    always end up with a bit set. Remove some of the tests and make
    set unconditional, in every place where all that needs to be done
    is just setting a bit.
    
    Signed-off-by: Sylwester Nawrocki <s.nawrocki@samsung.com>
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/platform/exynos4-is/fimc-is-param.c b/drivers/media/platform/exynos4-is/fimc-is-param.c
index 254740f5e418..53fe2a2b4db3 100644
--- a/drivers/media/platform/exynos4-is/fimc-is-param.c
+++ b/drivers/media/platform/exynos4-is/fimc-is-param.c
@@ -269,9 +269,7 @@ void __is_set_sensor(struct fimc_is *is, int fps)
 	unsigned int index = is->config_index;
 	struct sensor_param *sensor;
 	struct isp_param *isp;
-	unsigned long *p_index;
 
-	p_index = &is->config[index].p_region_index1;
 	sensor = &is->config[index].sensor;
 	isp = &is->config[index].isp;
 
@@ -286,11 +284,8 @@ void __is_set_sensor(struct fimc_is *is, int fps)
 		isp->otf_input.frametime_max = (u32)1000000 / fps;
 	}
 
-	if (!test_bit(PARAM_SENSOR_FRAME_RATE, p_index))
-		fimc_is_set_param_bit(is, PARAM_SENSOR_FRAME_RATE);
-
-	if (!test_bit(PARAM_ISP_OTF_INPUT, p_index))
-		fimc_is_set_param_bit(is, PARAM_ISP_OTF_INPUT);
+	fimc_is_set_param_bit(is, PARAM_SENSOR_FRAME_RATE);
+	fimc_is_set_param_bit(is, PARAM_ISP_OTF_INPUT);
 }
 
 void __is_set_init_isp_aa(struct fimc_is *is)
@@ -317,65 +312,54 @@ void __is_set_init_isp_aa(struct fimc_is *is)
 void __is_set_isp_flash(struct fimc_is *is, u32 cmd, u32 redeye)
 {
 	unsigned int index = is->config_index;
-	struct chain_config *cfg = &is->config[index];
-	struct isp_param *isp = &cfg->isp;
+	struct isp_param *isp = &is->config[index].isp;
 
 	isp->flash.cmd = cmd;
 	isp->flash.redeye = redeye;
 	isp->flash.err = ISP_FLASH_ERROR_NONE;
 
-	if (!test_bit(PARAM_ISP_FLASH, &cfg->p_region_index1))
-		fimc_is_set_param_bit(is, PARAM_ISP_FLASH);
+	fimc_is_set_param_bit(is, PARAM_ISP_FLASH);
 }
 
 void __is_set_isp_awb(struct fimc_is *is, u32 cmd, u32 val)
 {
 	unsigned int index = is->config_index;
 	struct isp_param *isp;
-	unsigned long *p_index;
 
-	p_index = &is->config[index].p_region_index1;
 	isp = &is->config[index].isp;
 
 	isp->awb.cmd = cmd;
 	isp->awb.illumination = val;
 	isp->awb.err = ISP_AWB_ERROR_NONE;
 
-	if (!test_bit(PARAM_ISP_AWB, p_index))
-		fimc_is_set_param_bit(is, PARAM_ISP_AWB);
+	fimc_is_set_param_bit(is, PARAM_ISP_AWB);
 }
 
 void __is_set_isp_effect(struct fimc_is *is, u32 cmd)
 {
 	unsigned int index = is->config_index;
 	struct isp_param *isp;
-	unsigned long *p_index;
 
-	p_index = &is->config[index].p_region_index1;
 	isp = &is->config[index].isp;
 
 	isp->effect.cmd = cmd;
 	isp->effect.err = ISP_IMAGE_EFFECT_ERROR_NONE;
 
-	if (!test_bit(PARAM_ISP_IMAGE_EFFECT, p_index))
-		fimc_is_set_param_bit(is, PARAM_ISP_IMAGE_EFFECT);
+	fimc_is_set_param_bit(is, PARAM_ISP_IMAGE_EFFECT);
 }
 
 void __is_set_isp_iso(struct fimc_is *is, u32 cmd, u32 val)
 {
 	unsigned int index = is->config_index;
 	struct isp_param *isp;
-	unsigned long *p_index;
 
-	p_index = &is->config[index].p_region_index1;
 	isp = &is->config[index].isp;
 
 	isp->iso.cmd = cmd;
 	isp->iso.value = val;
 	isp->iso.err = ISP_ISO_ERROR_NONE;
 
-	if (!test_bit(PARAM_ISP_ISO, p_index))
-		fimc_is_set_param_bit(is, PARAM_ISP_ISO);
+	fimc_is_set_param_bit(is, PARAM_ISP_ISO);
 }
 
 void __is_set_isp_adjust(struct fimc_is *is, u32 cmd, u32 val)
@@ -464,32 +448,26 @@ void __is_set_isp_afc(struct fimc_is *is, u32 cmd, u32 val)
 {
 	unsigned int index = is->config_index;
 	struct isp_param *isp;
-	unsigned long *p_index;
 
-	p_index = &is->config[index].p_region_index1;
 	isp = &is->config[index].isp;
 
 	isp->afc.cmd = cmd;
 	isp->afc.manual = val;
 	isp->afc.err = ISP_AFC_ERROR_NONE;
 
-	if (!test_bit(PARAM_ISP_AFC, p_index))
-		fimc_is_set_param_bit(is, PARAM_ISP_AFC);
+	fimc_is_set_param_bit(is, PARAM_ISP_AFC);
 }
 
 void __is_set_drc_control(struct fimc_is *is, u32 val)
 {
 	unsigned int index = is->config_index;
 	struct drc_param *drc;
-	unsigned long *p_index;
 
-	p_index = &is->config[index].p_region_index1;
 	drc = &is->config[index].drc;
 
 	drc->control.bypass = val;
 
-	if (!test_bit(PARAM_DRC_CONTROL, p_index))
-		fimc_is_set_param_bit(is, PARAM_DRC_CONTROL);
+	fimc_is_set_param_bit(is, PARAM_DRC_CONTROL);
 }
 
 void __is_set_fd_control(struct fimc_is *is, u32 val)

commit 3530ef0a6ea56636b23b5a15ff645632f7596c04
Author: Sylwester Nawrocki <s.nawrocki@samsung.com>
Date:   Wed Apr 10 06:24:46 2013 -0300

    [media] exynos4-is: Rename the ISP chain configuration data structure
    
    More appropriate names for the ISP chain data structure.
    
    Signed-off-by: Sylwester Nawrocki <s.nawrocki@samsung.com>
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/platform/exynos4-is/fimc-is-param.c b/drivers/media/platform/exynos4-is/fimc-is-param.c
index 58123e3e1b62..254740f5e418 100644
--- a/drivers/media/platform/exynos4-is/fimc-is-param.c
+++ b/drivers/media/platform/exynos4-is/fimc-is-param.c
@@ -43,7 +43,7 @@ void __fimc_is_hw_update_param_global_shotmode(struct fimc_is *is)
 	struct param_global_shotmode *dst, *src;
 
 	dst = &is->is_p_region->parameter.global.shotmode;
-	src = &is->cfg_param[is->scenario_id].global.shotmode;
+	src = &is->config[is->config_index].global.shotmode;
 	__hw_param_copy(dst, src);
 }
 
@@ -52,14 +52,14 @@ void __fimc_is_hw_update_param_sensor_framerate(struct fimc_is *is)
 	struct param_sensor_framerate *dst, *src;
 
 	dst = &is->is_p_region->parameter.sensor.frame_rate;
-	src = &is->cfg_param[is->scenario_id].sensor.frame_rate;
+	src = &is->config[is->config_index].sensor.frame_rate;
 	__hw_param_copy(dst, src);
 }
 
 int __fimc_is_hw_update_param(struct fimc_is *is, u32 offset)
 {
 	struct is_param_region *par = &is->is_p_region->parameter;
-	struct is_config_param *cfg = &is->cfg_param[is->scenario_id];
+	struct chain_config *cfg = &is->config[is->config_index];
 
 	switch (offset) {
 	case PARAM_ISP_CONTROL:
@@ -163,7 +163,7 @@ int __fimc_is_hw_update_param(struct fimc_is *is, u32 offset)
 
 unsigned int __get_pending_param_count(struct fimc_is *is)
 {
-	struct is_config_param *config = &is->cfg_param[is->scenario_id];
+	struct chain_config *config = &is->config[is->config_index];
 	unsigned long flags;
 	unsigned int count;
 
@@ -180,9 +180,9 @@ int __is_hw_update_params(struct fimc_is *is)
 	unsigned long *p_index1, *p_index2;
 	int i, id, ret = 0;
 
-	id = is->scenario_id;
-	p_index1 = &is->cfg_param[id].p_region_index1;
-	p_index2 = &is->cfg_param[id].p_region_index2;
+	id = is->config_index;
+	p_index1 = &is->config[id].p_region_index1;
+	p_index2 = &is->config[id].p_region_index2;
 
 	if (test_bit(PARAM_GLOBAL_SHOTMODE, p_index1))
 		__fimc_is_hw_update_param_global_shotmode(is);
@@ -212,22 +212,21 @@ void __is_get_frame_size(struct fimc_is *is, struct v4l2_mbus_framefmt *mf)
 {
 	struct isp_param *isp;
 
-	isp = &is->cfg_param[is->scenario_id].isp;
+	isp = &is->config[is->config_index].isp;
 	mf->width = isp->otf_input.width;
 	mf->height = isp->otf_input.height;
 }
 
 void __is_set_frame_size(struct fimc_is *is, struct v4l2_mbus_framefmt *mf)
 {
+	unsigned int index = is->config_index;
 	struct isp_param *isp;
 	struct drc_param *drc;
 	struct fd_param *fd;
-	unsigned int mode;
 
-	mode = is->scenario_id;
-	isp = &is->cfg_param[mode].isp;
-	drc = &is->cfg_param[mode].drc;
-	fd = &is->cfg_param[mode].fd;
+	isp = &is->config[index].isp;
+	drc = &is->config[index].drc;
+	fd = &is->config[index].fd;
 
 	/* Update isp size info (OTF only) */
 	isp->otf_input.width = mf->width;
@@ -244,7 +243,7 @@ void __is_set_frame_size(struct fimc_is *is, struct v4l2_mbus_framefmt *mf)
 	fd->otf_input.height = mf->height;
 
 	if (test_bit(PARAM_ISP_OTF_INPUT,
-		      &is->cfg_param[mode].p_region_index1))
+		      &is->config[index].p_region_index1))
 		return;
 
 	/* Update field */
@@ -267,14 +266,14 @@ int fimc_is_hw_get_sensor_max_framerate(struct fimc_is *is)
 
 void __is_set_sensor(struct fimc_is *is, int fps)
 {
+	unsigned int index = is->config_index;
 	struct sensor_param *sensor;
 	struct isp_param *isp;
-	unsigned long *p_index, mode;
+	unsigned long *p_index;
 
-	mode = is->scenario_id;
-	p_index = &is->cfg_param[mode].p_region_index1;
-	sensor = &is->cfg_param[mode].sensor;
-	isp = &is->cfg_param[mode].isp;
+	p_index = &is->config[index].p_region_index1;
+	sensor = &is->config[index].sensor;
+	isp = &is->config[index].isp;
 
 	if (fps == 0) {
 		sensor->frame_rate.frame_rate =
@@ -298,7 +297,7 @@ void __is_set_init_isp_aa(struct fimc_is *is)
 {
 	struct isp_param *isp;
 
-	isp = &is->cfg_param[is->scenario_id].isp;
+	isp = &is->config[is->config_index].isp;
 
 	isp->aa.cmd = ISP_AA_COMMAND_START;
 	isp->aa.target = ISP_AA_TARGET_AF | ISP_AA_TARGET_AE |
@@ -317,8 +316,8 @@ void __is_set_init_isp_aa(struct fimc_is *is)
 
 void __is_set_isp_flash(struct fimc_is *is, u32 cmd, u32 redeye)
 {
-	unsigned int mode = is->scenario_id;
-	struct is_config_param *cfg = &is->cfg_param[mode];
+	unsigned int index = is->config_index;
+	struct chain_config *cfg = &is->config[index];
 	struct isp_param *isp = &cfg->isp;
 
 	isp->flash.cmd = cmd;
@@ -331,12 +330,12 @@ void __is_set_isp_flash(struct fimc_is *is, u32 cmd, u32 redeye)
 
 void __is_set_isp_awb(struct fimc_is *is, u32 cmd, u32 val)
 {
-	unsigned int mode = is->scenario_id;
+	unsigned int index = is->config_index;
 	struct isp_param *isp;
 	unsigned long *p_index;
 
-	p_index = &is->cfg_param[mode].p_region_index1;
-	isp = &is->cfg_param[mode].isp;
+	p_index = &is->config[index].p_region_index1;
+	isp = &is->config[index].isp;
 
 	isp->awb.cmd = cmd;
 	isp->awb.illumination = val;
@@ -348,12 +347,12 @@ void __is_set_isp_awb(struct fimc_is *is, u32 cmd, u32 val)
 
 void __is_set_isp_effect(struct fimc_is *is, u32 cmd)
 {
-	unsigned int mode = is->scenario_id;
+	unsigned int index = is->config_index;
 	struct isp_param *isp;
 	unsigned long *p_index;
 
-	p_index = &is->cfg_param[mode].p_region_index1;
-	isp = &is->cfg_param[mode].isp;
+	p_index = &is->config[index].p_region_index1;
+	isp = &is->config[index].isp;
 
 	isp->effect.cmd = cmd;
 	isp->effect.err = ISP_IMAGE_EFFECT_ERROR_NONE;
@@ -364,12 +363,12 @@ void __is_set_isp_effect(struct fimc_is *is, u32 cmd)
 
 void __is_set_isp_iso(struct fimc_is *is, u32 cmd, u32 val)
 {
-	unsigned int mode = is->scenario_id;
+	unsigned int index = is->config_index;
 	struct isp_param *isp;
 	unsigned long *p_index;
 
-	p_index = &is->cfg_param[mode].p_region_index1;
-	isp = &is->cfg_param[mode].isp;
+	p_index = &is->config[index].p_region_index1;
+	isp = &is->config[index].isp;
 
 	isp->iso.cmd = cmd;
 	isp->iso.value = val;
@@ -381,12 +380,12 @@ void __is_set_isp_iso(struct fimc_is *is, u32 cmd, u32 val)
 
 void __is_set_isp_adjust(struct fimc_is *is, u32 cmd, u32 val)
 {
-	unsigned int mode = is->scenario_id;
+	unsigned int index = is->config_index;
 	unsigned long *p_index;
 	struct isp_param *isp;
 
-	p_index = &is->cfg_param[mode].p_region_index1;
-	isp = &is->cfg_param[mode].isp;
+	p_index = &is->config[index].p_region_index1;
+	isp = &is->config[index].isp;
 
 	switch (cmd) {
 	case ISP_ADJUST_COMMAND_MANUAL_CONTRAST:
@@ -428,12 +427,12 @@ void __is_set_isp_adjust(struct fimc_is *is, u32 cmd, u32 val)
 
 void __is_set_isp_metering(struct fimc_is *is, u32 id, u32 val)
 {
+	unsigned int index = is->config_index;
 	struct isp_param *isp;
-	unsigned long *p_index, mode;
+	unsigned long *p_index;
 
-	mode = is->scenario_id;
-	p_index = &is->cfg_param[mode].p_region_index1;
-	isp = &is->cfg_param[mode].isp;
+	p_index = &is->config[index].p_region_index1;
+	isp = &is->config[index].isp;
 
 	switch (id) {
 	case IS_METERING_CONFIG_CMD:
@@ -463,12 +462,12 @@ void __is_set_isp_metering(struct fimc_is *is, u32 id, u32 val)
 
 void __is_set_isp_afc(struct fimc_is *is, u32 cmd, u32 val)
 {
+	unsigned int index = is->config_index;
 	struct isp_param *isp;
-	unsigned long *p_index, mode;
+	unsigned long *p_index;
 
-	mode = is->scenario_id;
-	p_index = &is->cfg_param[mode].p_region_index1;
-	isp = &is->cfg_param[mode].isp;
+	p_index = &is->config[index].p_region_index1;
+	isp = &is->config[index].isp;
 
 	isp->afc.cmd = cmd;
 	isp->afc.manual = val;
@@ -480,12 +479,12 @@ void __is_set_isp_afc(struct fimc_is *is, u32 cmd, u32 val)
 
 void __is_set_drc_control(struct fimc_is *is, u32 val)
 {
+	unsigned int index = is->config_index;
 	struct drc_param *drc;
-	unsigned long *p_index, mode;
+	unsigned long *p_index;
 
-	mode = is->scenario_id;
-	p_index = &is->cfg_param[mode].p_region_index1;
-	drc = &is->cfg_param[mode].drc;
+	p_index = &is->config[index].p_region_index1;
+	drc = &is->config[index].drc;
 
 	drc->control.bypass = val;
 
@@ -495,12 +494,12 @@ void __is_set_drc_control(struct fimc_is *is, u32 val)
 
 void __is_set_fd_control(struct fimc_is *is, u32 val)
 {
+	unsigned int index = is->config_index;
 	struct fd_param *fd;
-	unsigned long *p_index, mode;
+	unsigned long *p_index;
 
-	mode = is->scenario_id;
-	p_index = &is->cfg_param[mode].p_region_index2;
-	fd = &is->cfg_param[mode].fd;
+	p_index = &is->config[index].p_region_index2;
+	fd = &is->config[index].fd;
 
 	fd->control.cmd = val;
 
@@ -510,12 +509,12 @@ void __is_set_fd_control(struct fimc_is *is, u32 val)
 
 void __is_set_fd_config_maxface(struct fimc_is *is, u32 val)
 {
+	unsigned int index = is->config_index;
 	struct fd_param *fd;
-	unsigned long *p_index, mode;
+	unsigned long *p_index;
 
-	mode = is->scenario_id;
-	p_index = &is->cfg_param[mode].p_region_index2;
-	fd = &is->cfg_param[mode].fd;
+	p_index = &is->config[index].p_region_index2;
+	fd = &is->config[index].fd;
 
 	fd->config.max_number = val;
 
@@ -530,12 +529,12 @@ void __is_set_fd_config_maxface(struct fimc_is *is, u32 val)
 
 void __is_set_fd_config_rollangle(struct fimc_is *is, u32 val)
 {
+	unsigned int index = is->config_index;
 	struct fd_param *fd;
-	unsigned long *p_index, mode;
+	unsigned long *p_index;
 
-	mode = is->scenario_id;
-	p_index = &is->cfg_param[mode].p_region_index2;
-	fd = &is->cfg_param[mode].fd;
+	p_index = &is->config[index].p_region_index2;
+	fd = &is->config[index].fd;
 
 	fd->config.roll_angle = val;
 
@@ -550,12 +549,12 @@ void __is_set_fd_config_rollangle(struct fimc_is *is, u32 val)
 
 void __is_set_fd_config_yawangle(struct fimc_is *is, u32 val)
 {
+	unsigned int index = is->config_index;
 	struct fd_param *fd;
-	unsigned long *p_index, mode;
+	unsigned long *p_index;
 
-	mode = is->scenario_id;
-	p_index = &is->cfg_param[mode].p_region_index2;
-	fd = &is->cfg_param[mode].fd;
+	p_index = &is->config[index].p_region_index2;
+	fd = &is->config[index].fd;
 
 	fd->config.yaw_angle = val;
 
@@ -570,12 +569,12 @@ void __is_set_fd_config_yawangle(struct fimc_is *is, u32 val)
 
 void __is_set_fd_config_smilemode(struct fimc_is *is, u32 val)
 {
+	unsigned int index = is->config_index;
 	struct fd_param *fd;
-	unsigned long *p_index, mode;
+	unsigned long *p_index;
 
-	mode = is->scenario_id;
-	p_index = &is->cfg_param[mode].p_region_index2;
-	fd = &is->cfg_param[mode].fd;
+	p_index = &is->config[index].p_region_index2;
+	fd = &is->config[index].fd;
 
 	fd->config.smile_mode = val;
 
@@ -590,12 +589,12 @@ void __is_set_fd_config_smilemode(struct fimc_is *is, u32 val)
 
 void __is_set_fd_config_blinkmode(struct fimc_is *is, u32 val)
 {
+	unsigned int index = is->config_index;
 	struct fd_param *fd;
-	unsigned long *p_index, mode;
+	unsigned long *p_index;
 
-	mode = is->scenario_id;
-	p_index = &is->cfg_param[mode].p_region_index2;
-	fd = &is->cfg_param[mode].fd;
+	p_index = &is->config[index].p_region_index2;
+	fd = &is->config[index].fd;
 
 	fd->config.blink_mode = val;
 
@@ -610,12 +609,12 @@ void __is_set_fd_config_blinkmode(struct fimc_is *is, u32 val)
 
 void __is_set_fd_config_eyedetect(struct fimc_is *is, u32 val)
 {
+	unsigned int index = is->config_index;
 	struct fd_param *fd;
-	unsigned long *p_index, mode;
+	unsigned long *p_index;
 
-	mode = is->scenario_id;
-	p_index = &is->cfg_param[mode].p_region_index2;
-	fd = &is->cfg_param[mode].fd;
+	p_index = &is->config[index].p_region_index2;
+	fd = &is->config[index].fd;
 
 	fd->config.eye_detect = val;
 
@@ -630,12 +629,12 @@ void __is_set_fd_config_eyedetect(struct fimc_is *is, u32 val)
 
 void __is_set_fd_config_mouthdetect(struct fimc_is *is, u32 val)
 {
+	unsigned int index = is->config_index;
 	struct fd_param *fd;
-	unsigned long *p_index, mode;
+	unsigned long *p_index;
 
-	mode = is->scenario_id;
-	p_index = &is->cfg_param[mode].p_region_index2;
-	fd = &is->cfg_param[mode].fd;
+	p_index = &is->config[index].p_region_index2;
+	fd = &is->config[index].fd;
 
 	fd->config.mouth_detect = val;
 
@@ -650,12 +649,12 @@ void __is_set_fd_config_mouthdetect(struct fimc_is *is, u32 val)
 
 void __is_set_fd_config_orientation(struct fimc_is *is, u32 val)
 {
+	unsigned int index = is->config_index;
 	struct fd_param *fd;
-	unsigned long *p_index, mode;
+	unsigned long *p_index;
 
-	mode = is->scenario_id;
-	p_index = &is->cfg_param[mode].p_region_index2;
-	fd = &is->cfg_param[mode].fd;
+	p_index = &is->config[index].p_region_index2;
+	fd = &is->config[index].fd;
 
 	fd->config.orientation = val;
 
@@ -670,12 +669,12 @@ void __is_set_fd_config_orientation(struct fimc_is *is, u32 val)
 
 void __is_set_fd_config_orientation_val(struct fimc_is *is, u32 val)
 {
+	unsigned int index = is->config_index;
 	struct fd_param *fd;
-	unsigned long *p_index, mode;
+	unsigned long *p_index;
 
-	mode = is->scenario_id;
-	p_index = &is->cfg_param[mode].p_region_index2;
-	fd = &is->cfg_param[mode].fd;
+	p_index = &is->config[index].p_region_index2;
+	fd = &is->config[index].fd;
 
 	fd->config.orientation_value = val;
 
@@ -696,16 +695,16 @@ void fimc_is_set_initial_params(struct fimc_is *is)
 	struct drc_param *drc;
 	struct fd_param *fd;
 	unsigned long *p_index1, *p_index2;
-	unsigned int mode;
+	unsigned int index;
 
-	mode = is->scenario_id;
-	global = &is->cfg_param[mode].global;
-	sensor = &is->cfg_param[mode].sensor;
-	isp = &is->cfg_param[mode].isp;
-	drc = &is->cfg_param[mode].drc;
-	fd = &is->cfg_param[mode].fd;
-	p_index1 = &is->cfg_param[mode].p_region_index1;
-	p_index2 = &is->cfg_param[mode].p_region_index2;
+	index = is->config_index;
+	global = &is->config[index].global;
+	sensor = &is->config[index].sensor;
+	isp = &is->config[index].isp;
+	drc = &is->config[index].drc;
+	fd = &is->config[index].fd;
+	p_index1 = &is->config[index].p_region_index1;
+	p_index2 = &is->config[index].p_region_index2;
 
 	/* Global */
 	global->shotmode.cmd = 1;
@@ -841,7 +840,7 @@ void fimc_is_set_initial_params(struct fimc_is *is)
 
 	/* Sensor */
 	if (!test_bit(PARAM_SENSOR_FRAME_RATE, p_index1)) {
-		if (!mode)
+		if (is->config_index == 0)
 			__is_set_sensor(is, 0);
 	}
 

commit a6f5635e63ffa02c30a22ea4af21f3daa1e98cdf
Author: Sylwester Nawrocki <s.nawrocki@samsung.com>
Date:   Wed Apr 10 06:23:05 2013 -0300

    [media] exynos4-is: Improve the ISP chain parameter count calculation
    
    Instead of incrementing p_region_num field each time we set a bit
    in the parameter mask calculate the number of bits set only when
    this information is needed.
    
    Signed-off-by: Sylwester Nawrocki <s.nawrocki@samsung.com>
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/platform/exynos4-is/fimc-is-param.c b/drivers/media/platform/exynos4-is/fimc-is-param.c
index 37fd5fe68eef..58123e3e1b62 100644
--- a/drivers/media/platform/exynos4-is/fimc-is-param.c
+++ b/drivers/media/platform/exynos4-is/fimc-is-param.c
@@ -12,14 +12,15 @@
  */
 #define pr_fmt(fmt) "%s:%d " fmt, __func__, __LINE__
 
+#include <linux/bitops.h>
 #include <linux/bug.h>
 #include <linux/device.h>
 #include <linux/errno.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
-#include <linux/types.h>
 #include <linux/platform_device.h>
 #include <linux/slab.h>
+#include <linux/types.h>
 #include <linux/videodev2.h>
 
 #include <media/v4l2-device.h>
@@ -160,6 +161,20 @@ int __fimc_is_hw_update_param(struct fimc_is *is, u32 offset)
 	return 0;
 }
 
+unsigned int __get_pending_param_count(struct fimc_is *is)
+{
+	struct is_config_param *config = &is->cfg_param[is->scenario_id];
+	unsigned long flags;
+	unsigned int count;
+
+	spin_lock_irqsave(&is->slock, flags);
+	count = hweight32(config->p_region_index1);
+	count += hweight32(config->p_region_index2);
+	spin_unlock_irqrestore(&is->slock, flags);
+
+	return count;
+}
+
 int __is_hw_update_params(struct fimc_is *is)
 {
 	unsigned long *p_index1, *p_index2;
@@ -234,15 +249,10 @@ void __is_set_frame_size(struct fimc_is *is, struct v4l2_mbus_framefmt *mf)
 
 	/* Update field */
 	fimc_is_set_param_bit(is, PARAM_ISP_OTF_INPUT);
-	fimc_is_inc_param_num(is);
 	fimc_is_set_param_bit(is, PARAM_ISP_OTF_OUTPUT);
-	fimc_is_inc_param_num(is);
 	fimc_is_set_param_bit(is, PARAM_DRC_OTF_INPUT);
-	fimc_is_inc_param_num(is);
 	fimc_is_set_param_bit(is, PARAM_DRC_OTF_OUTPUT);
-	fimc_is_inc_param_num(is);
 	fimc_is_set_param_bit(is, PARAM_FD_OTF_INPUT);
-	fimc_is_inc_param_num(is);
 }
 
 int fimc_is_hw_get_sensor_max_framerate(struct fimc_is *is)
@@ -277,14 +287,11 @@ void __is_set_sensor(struct fimc_is *is, int fps)
 		isp->otf_input.frametime_max = (u32)1000000 / fps;
 	}
 
-	if (!test_bit(PARAM_SENSOR_FRAME_RATE, p_index)) {
+	if (!test_bit(PARAM_SENSOR_FRAME_RATE, p_index))
 		fimc_is_set_param_bit(is, PARAM_SENSOR_FRAME_RATE);
-		fimc_is_inc_param_num(is);
-	}
-	if (!test_bit(PARAM_ISP_OTF_INPUT, p_index)) {
+
+	if (!test_bit(PARAM_ISP_OTF_INPUT, p_index))
 		fimc_is_set_param_bit(is, PARAM_ISP_OTF_INPUT);
-		fimc_is_inc_param_num(is);
-	}
 }
 
 void __is_set_init_isp_aa(struct fimc_is *is)
@@ -306,7 +313,6 @@ void __is_set_init_isp_aa(struct fimc_is *is)
 	isp->aa.err = ISP_AF_ERROR_NONE;
 
 	fimc_is_set_param_bit(is, PARAM_ISP_AA);
-	fimc_is_inc_param_num(is);
 }
 
 void __is_set_isp_flash(struct fimc_is *is, u32 cmd, u32 redeye)
@@ -319,10 +325,8 @@ void __is_set_isp_flash(struct fimc_is *is, u32 cmd, u32 redeye)
 	isp->flash.redeye = redeye;
 	isp->flash.err = ISP_FLASH_ERROR_NONE;
 
-	if (!test_bit(PARAM_ISP_FLASH, &cfg->p_region_index1)) {
+	if (!test_bit(PARAM_ISP_FLASH, &cfg->p_region_index1))
 		fimc_is_set_param_bit(is, PARAM_ISP_FLASH);
-		fimc_is_inc_param_num(is);
-	}
 }
 
 void __is_set_isp_awb(struct fimc_is *is, u32 cmd, u32 val)
@@ -338,10 +342,8 @@ void __is_set_isp_awb(struct fimc_is *is, u32 cmd, u32 val)
 	isp->awb.illumination = val;
 	isp->awb.err = ISP_AWB_ERROR_NONE;
 
-	if (!test_bit(PARAM_ISP_AWB, p_index)) {
+	if (!test_bit(PARAM_ISP_AWB, p_index))
 		fimc_is_set_param_bit(is, PARAM_ISP_AWB);
-		fimc_is_inc_param_num(is);
-	}
 }
 
 void __is_set_isp_effect(struct fimc_is *is, u32 cmd)
@@ -356,10 +358,8 @@ void __is_set_isp_effect(struct fimc_is *is, u32 cmd)
 	isp->effect.cmd = cmd;
 	isp->effect.err = ISP_IMAGE_EFFECT_ERROR_NONE;
 
-	if (!test_bit(PARAM_ISP_IMAGE_EFFECT, p_index)) {
+	if (!test_bit(PARAM_ISP_IMAGE_EFFECT, p_index))
 		fimc_is_set_param_bit(is, PARAM_ISP_IMAGE_EFFECT);
-		fimc_is_inc_param_num(is);
-	}
 }
 
 void __is_set_isp_iso(struct fimc_is *is, u32 cmd, u32 val)
@@ -375,10 +375,8 @@ void __is_set_isp_iso(struct fimc_is *is, u32 cmd, u32 val)
 	isp->iso.value = val;
 	isp->iso.err = ISP_ISO_ERROR_NONE;
 
-	if (!test_bit(PARAM_ISP_ISO, p_index)) {
+	if (!test_bit(PARAM_ISP_ISO, p_index))
 		fimc_is_set_param_bit(is, PARAM_ISP_ISO);
-		fimc_is_inc_param_num(is);
-	}
 }
 
 void __is_set_isp_adjust(struct fimc_is *is, u32 cmd, u32 val)
@@ -423,7 +421,6 @@ void __is_set_isp_adjust(struct fimc_is *is, u32 cmd, u32 val)
 		isp->adjust.cmd = cmd;
 		isp->adjust.err = ISP_ADJUST_ERROR_NONE;
 		fimc_is_set_param_bit(is, PARAM_ISP_ADJUST);
-		fimc_is_inc_param_num(is);
 	} else {
 		isp->adjust.cmd |= cmd;
 	}
@@ -461,7 +458,6 @@ void __is_set_isp_metering(struct fimc_is *is, u32 id, u32 val)
 	if (!test_bit(PARAM_ISP_METERING, p_index)) {
 		isp->metering.err = ISP_METERING_ERROR_NONE;
 		fimc_is_set_param_bit(is, PARAM_ISP_METERING);
-		fimc_is_inc_param_num(is);
 	}
 }
 
@@ -478,10 +474,8 @@ void __is_set_isp_afc(struct fimc_is *is, u32 cmd, u32 val)
 	isp->afc.manual = val;
 	isp->afc.err = ISP_AFC_ERROR_NONE;
 
-	if (!test_bit(PARAM_ISP_AFC, p_index)) {
+	if (!test_bit(PARAM_ISP_AFC, p_index))
 		fimc_is_set_param_bit(is, PARAM_ISP_AFC);
-		fimc_is_inc_param_num(is);
-	}
 }
 
 void __is_set_drc_control(struct fimc_is *is, u32 val)
@@ -495,10 +489,8 @@ void __is_set_drc_control(struct fimc_is *is, u32 val)
 
 	drc->control.bypass = val;
 
-	if (!test_bit(PARAM_DRC_CONTROL, p_index)) {
+	if (!test_bit(PARAM_DRC_CONTROL, p_index))
 		fimc_is_set_param_bit(is, PARAM_DRC_CONTROL);
-		fimc_is_inc_param_num(is);
-	}
 }
 
 void __is_set_fd_control(struct fimc_is *is, u32 val)
@@ -512,10 +504,8 @@ void __is_set_fd_control(struct fimc_is *is, u32 val)
 
 	fd->control.cmd = val;
 
-	if (!test_bit((PARAM_FD_CONFIG - 32), p_index)) {
+	if (!test_bit((PARAM_FD_CONFIG - 32), p_index))
 		fimc_is_set_param_bit(is, PARAM_FD_CONTROL);
-		fimc_is_inc_param_num(is);
-	}
 }
 
 void __is_set_fd_config_maxface(struct fimc_is *is, u32 val)
@@ -533,7 +523,6 @@ void __is_set_fd_config_maxface(struct fimc_is *is, u32 val)
 		fd->config.cmd = FD_CONFIG_COMMAND_MAXIMUM_NUMBER;
 		fd->config.err = ERROR_FD_NONE;
 		fimc_is_set_param_bit(is, PARAM_FD_CONFIG);
-		fimc_is_inc_param_num(is);
 	} else {
 		fd->config.cmd |= FD_CONFIG_COMMAND_MAXIMUM_NUMBER;
 	}
@@ -554,7 +543,6 @@ void __is_set_fd_config_rollangle(struct fimc_is *is, u32 val)
 		fd->config.cmd = FD_CONFIG_COMMAND_ROLL_ANGLE;
 		fd->config.err = ERROR_FD_NONE;
 		fimc_is_set_param_bit(is, PARAM_FD_CONFIG);
-		fimc_is_inc_param_num(is);
 	} else {
 		fd->config.cmd |= FD_CONFIG_COMMAND_ROLL_ANGLE;
 	}
@@ -575,7 +563,6 @@ void __is_set_fd_config_yawangle(struct fimc_is *is, u32 val)
 		fd->config.cmd = FD_CONFIG_COMMAND_YAW_ANGLE;
 		fd->config.err = ERROR_FD_NONE;
 		fimc_is_set_param_bit(is, PARAM_FD_CONFIG);
-		fimc_is_inc_param_num(is);
 	} else {
 		fd->config.cmd |= FD_CONFIG_COMMAND_YAW_ANGLE;
 	}
@@ -596,7 +583,6 @@ void __is_set_fd_config_smilemode(struct fimc_is *is, u32 val)
 		fd->config.cmd = FD_CONFIG_COMMAND_SMILE_MODE;
 		fd->config.err = ERROR_FD_NONE;
 		fimc_is_set_param_bit(is, PARAM_FD_CONFIG);
-		fimc_is_inc_param_num(is);
 	} else {
 		fd->config.cmd |= FD_CONFIG_COMMAND_SMILE_MODE;
 	}
@@ -617,7 +603,6 @@ void __is_set_fd_config_blinkmode(struct fimc_is *is, u32 val)
 		fd->config.cmd = FD_CONFIG_COMMAND_BLINK_MODE;
 		fd->config.err = ERROR_FD_NONE;
 		fimc_is_set_param_bit(is, PARAM_FD_CONFIG);
-		fimc_is_inc_param_num(is);
 	} else {
 		fd->config.cmd |= FD_CONFIG_COMMAND_BLINK_MODE;
 	}
@@ -638,7 +623,6 @@ void __is_set_fd_config_eyedetect(struct fimc_is *is, u32 val)
 		fd->config.cmd = FD_CONFIG_COMMAND_EYES_DETECT;
 		fd->config.err = ERROR_FD_NONE;
 		fimc_is_set_param_bit(is, PARAM_FD_CONFIG);
-		fimc_is_inc_param_num(is);
 	} else {
 		fd->config.cmd |= FD_CONFIG_COMMAND_EYES_DETECT;
 	}
@@ -659,7 +643,6 @@ void __is_set_fd_config_mouthdetect(struct fimc_is *is, u32 val)
 		fd->config.cmd = FD_CONFIG_COMMAND_MOUTH_DETECT;
 		fd->config.err = ERROR_FD_NONE;
 		fimc_is_set_param_bit(is, PARAM_FD_CONFIG);
-		fimc_is_inc_param_num(is);
 	} else {
 		fd->config.cmd |= FD_CONFIG_COMMAND_MOUTH_DETECT;
 	}
@@ -680,7 +663,6 @@ void __is_set_fd_config_orientation(struct fimc_is *is, u32 val)
 		fd->config.cmd = FD_CONFIG_COMMAND_ORIENTATION;
 		fd->config.err = ERROR_FD_NONE;
 		fimc_is_set_param_bit(is, PARAM_FD_CONFIG);
-		fimc_is_inc_param_num(is);
 	} else {
 		fd->config.cmd |= FD_CONFIG_COMMAND_ORIENTATION;
 	}
@@ -701,7 +683,6 @@ void __is_set_fd_config_orientation_val(struct fimc_is *is, u32 val)
 		fd->config.cmd = FD_CONFIG_COMMAND_ORIENTATION_VALUE;
 		fd->config.err = ERROR_FD_NONE;
 		fimc_is_set_param_bit(is, PARAM_FD_CONFIG);
-		fimc_is_inc_param_num(is);
 	} else {
 		fd->config.cmd |= FD_CONFIG_COMMAND_ORIENTATION_VALUE;
 	}
@@ -729,21 +710,18 @@ void fimc_is_set_initial_params(struct fimc_is *is)
 	/* Global */
 	global->shotmode.cmd = 1;
 	fimc_is_set_param_bit(is, PARAM_GLOBAL_SHOTMODE);
-	fimc_is_inc_param_num(is);
 
 	/* ISP */
 	isp->control.cmd = CONTROL_COMMAND_START;
 	isp->control.bypass = CONTROL_BYPASS_DISABLE;
 	isp->control.err = CONTROL_ERROR_NONE;
 	fimc_is_set_param_bit(is, PARAM_ISP_CONTROL);
-	fimc_is_inc_param_num(is);
 
 	isp->otf_input.cmd = OTF_INPUT_COMMAND_ENABLE;
 	if (!test_bit(PARAM_ISP_OTF_INPUT, p_index1)) {
 		isp->otf_input.width = DEFAULT_PREVIEW_STILL_WIDTH;
 		isp->otf_input.height = DEFAULT_PREVIEW_STILL_HEIGHT;
 		fimc_is_set_param_bit(is, PARAM_ISP_OTF_INPUT);
-		fimc_is_inc_param_num(is);
 	}
 	if (is->sensor->test_pattern)
 		isp->otf_input.format = OTF_INPUT_FORMAT_STRGEN_COLORBAR_BAYER;
@@ -766,7 +744,6 @@ void fimc_is_set_initial_params(struct fimc_is *is)
 	isp->dma1_input.width = 0;
 	isp->dma1_input.err = DMA_INPUT_ERROR_NONE;
 	fimc_is_set_param_bit(is, PARAM_ISP_DMA1_INPUT);
-	fimc_is_inc_param_num(is);
 
 	isp->dma2_input.cmd = DMA_INPUT_COMMAND_DISABLE;
 	isp->dma2_input.width = 0;
@@ -779,12 +756,10 @@ void fimc_is_set_initial_params(struct fimc_is *is)
 	isp->dma2_input.width = 0;
 	isp->dma2_input.err = DMA_INPUT_ERROR_NONE;
 	fimc_is_set_param_bit(is, PARAM_ISP_DMA2_INPUT);
-	fimc_is_inc_param_num(is);
 
 	isp->aa.cmd = ISP_AA_COMMAND_START;
 	isp->aa.target = ISP_AA_TARGET_AE | ISP_AA_TARGET_AWB;
 	fimc_is_set_param_bit(is, PARAM_ISP_AA);
-	fimc_is_inc_param_num(is);
 
 	if (!test_bit(PARAM_ISP_FLASH, p_index1))
 		__is_set_isp_flash(is, ISP_FLASH_COMMAND_DISABLE,
@@ -826,7 +801,6 @@ void fimc_is_set_initial_params(struct fimc_is *is)
 		isp->otf_output.width = DEFAULT_PREVIEW_STILL_WIDTH;
 		isp->otf_output.height = DEFAULT_PREVIEW_STILL_HEIGHT;
 		fimc_is_set_param_bit(is, PARAM_ISP_OTF_OUTPUT);
-		fimc_is_inc_param_num(is);
 	}
 	isp->otf_output.format = OTF_OUTPUT_FORMAT_YUV444;
 	isp->otf_output.bitwidth = 12;
@@ -847,7 +821,6 @@ void fimc_is_set_initial_params(struct fimc_is *is)
 		isp->dma1_output.dma_out_mask = 0;
 		isp->dma1_output.err = DMA_OUTPUT_ERROR_NONE;
 		fimc_is_set_param_bit(is, PARAM_ISP_DMA1_OUTPUT);
-		fimc_is_inc_param_num(is);
 	}
 
 	if (!test_bit(PARAM_ISP_DMA2_OUTPUT, p_index1)) {
@@ -864,7 +837,6 @@ void fimc_is_set_initial_params(struct fimc_is *is)
 		isp->dma2_output.dma_out_mask = 0;
 		isp->dma2_output.err = DMA_OUTPUT_ERROR_NONE;
 		fimc_is_set_param_bit(is, PARAM_ISP_DMA2_OUTPUT);
-		fimc_is_inc_param_num(is);
 	}
 
 	/* Sensor */
@@ -882,7 +854,6 @@ void fimc_is_set_initial_params(struct fimc_is *is)
 		drc->otf_input.width = DEFAULT_PREVIEW_STILL_WIDTH;
 		drc->otf_input.height = DEFAULT_PREVIEW_STILL_HEIGHT;
 		fimc_is_set_param_bit(is, PARAM_DRC_OTF_INPUT);
-		fimc_is_inc_param_num(is);
 	}
 	drc->otf_input.format = OTF_INPUT_FORMAT_YUV444;
 	drc->otf_input.bitwidth = 12;
@@ -900,14 +871,12 @@ void fimc_is_set_initial_params(struct fimc_is *is)
 	drc->dma_input.width = 0;
 	drc->dma_input.err = DMA_INPUT_ERROR_NONE;
 	fimc_is_set_param_bit(is, PARAM_DRC_DMA_INPUT);
-	fimc_is_inc_param_num(is);
 
 	drc->otf_output.cmd = OTF_OUTPUT_COMMAND_ENABLE;
 	if (!test_bit(PARAM_DRC_OTF_OUTPUT, p_index1)) {
 		drc->otf_output.width = DEFAULT_PREVIEW_STILL_WIDTH;
 		drc->otf_output.height = DEFAULT_PREVIEW_STILL_HEIGHT;
 		fimc_is_set_param_bit(is, PARAM_DRC_OTF_OUTPUT);
-		fimc_is_inc_param_num(is);
 	}
 	drc->otf_output.format = OTF_OUTPUT_FORMAT_YUV444;
 	drc->otf_output.bitwidth = 8;
@@ -923,8 +892,8 @@ void fimc_is_set_initial_params(struct fimc_is *is)
 		fd->otf_input.width = DEFAULT_PREVIEW_STILL_WIDTH;
 		fd->otf_input.height = DEFAULT_PREVIEW_STILL_HEIGHT;
 		fimc_is_set_param_bit(is, PARAM_FD_OTF_INPUT);
-		fimc_is_inc_param_num(is);
 	}
+
 	fd->otf_input.format = OTF_INPUT_FORMAT_YUV444;
 	fd->otf_input.bitwidth = 8;
 	fd->otf_input.order = 0;
@@ -941,7 +910,6 @@ void fimc_is_set_initial_params(struct fimc_is *is)
 	fd->dma_input.width = 0;
 	fd->dma_input.err = DMA_INPUT_ERROR_NONE;
 	fimc_is_set_param_bit(is, PARAM_FD_DMA_INPUT);
-	fimc_is_inc_param_num(is);
 
 	__is_set_fd_config_maxface(is, 5);
 	__is_set_fd_config_rollangle(is, FD_CONFIG_ROLL_ANGLE_FULL);

commit 294781db46155b8a64976649567538ada91131f8
Author: Sylwester Nawrocki <s.nawrocki@samsung.com>
Date:   Mon Mar 11 15:33:56 2013 -0300

    [media] exynos4-is: Add FIMC-IS parameter region definitions
    
    This patch adds the ISP processing parameters interface files.
    
    Signed-off-by: Younghwan Joo <yhwan.joo@samsung.com>
    Signed-off-by: Sylwester Nawrocki <s.nawrocki@samsung.com>
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/platform/exynos4-is/fimc-is-param.c b/drivers/media/platform/exynos4-is/fimc-is-param.c
new file mode 100644
index 000000000000..37fd5fe68eef
--- /dev/null
+++ b/drivers/media/platform/exynos4-is/fimc-is-param.c
@@ -0,0 +1,955 @@
+/*
+ * Samsung EXYNOS4x12 FIMC-IS (Imaging Subsystem) driver
+ *
+ * Copyright (C) 2013 Samsung Electronics Co., Ltd.
+ *
+ * Authors: Younghwan Joo <yhwan.joo@samsung.com>
+ *          Sylwester Nawrocki <s.nawrocki@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#define pr_fmt(fmt) "%s:%d " fmt, __func__, __LINE__
+
+#include <linux/bug.h>
+#include <linux/device.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/videodev2.h>
+
+#include <media/v4l2-device.h>
+#include <media/v4l2-ioctl.h>
+
+#include "fimc-is.h"
+#include "fimc-is-command.h"
+#include "fimc-is-errno.h"
+#include "fimc-is-param.h"
+#include "fimc-is-regs.h"
+#include "fimc-is-sensor.h"
+
+static void __hw_param_copy(void *dst, void *src)
+{
+	memcpy(dst, src, FIMC_IS_PARAM_MAX_SIZE);
+}
+
+void __fimc_is_hw_update_param_global_shotmode(struct fimc_is *is)
+{
+	struct param_global_shotmode *dst, *src;
+
+	dst = &is->is_p_region->parameter.global.shotmode;
+	src = &is->cfg_param[is->scenario_id].global.shotmode;
+	__hw_param_copy(dst, src);
+}
+
+void __fimc_is_hw_update_param_sensor_framerate(struct fimc_is *is)
+{
+	struct param_sensor_framerate *dst, *src;
+
+	dst = &is->is_p_region->parameter.sensor.frame_rate;
+	src = &is->cfg_param[is->scenario_id].sensor.frame_rate;
+	__hw_param_copy(dst, src);
+}
+
+int __fimc_is_hw_update_param(struct fimc_is *is, u32 offset)
+{
+	struct is_param_region *par = &is->is_p_region->parameter;
+	struct is_config_param *cfg = &is->cfg_param[is->scenario_id];
+
+	switch (offset) {
+	case PARAM_ISP_CONTROL:
+		__hw_param_copy(&par->isp.control, &cfg->isp.control);
+		break;
+
+	case PARAM_ISP_OTF_INPUT:
+		__hw_param_copy(&par->isp.otf_input, &cfg->isp.otf_input);
+		break;
+
+	case PARAM_ISP_DMA1_INPUT:
+		__hw_param_copy(&par->isp.dma1_input, &cfg->isp.dma1_input);
+		break;
+
+	case PARAM_ISP_DMA2_INPUT:
+		__hw_param_copy(&par->isp.dma2_input, &cfg->isp.dma2_input);
+		break;
+
+	case PARAM_ISP_AA:
+		__hw_param_copy(&par->isp.aa, &cfg->isp.aa);
+		break;
+
+	case PARAM_ISP_FLASH:
+		__hw_param_copy(&par->isp.flash, &cfg->isp.flash);
+		break;
+
+	case PARAM_ISP_AWB:
+		__hw_param_copy(&par->isp.awb, &cfg->isp.awb);
+		break;
+
+	case PARAM_ISP_IMAGE_EFFECT:
+		__hw_param_copy(&par->isp.effect, &cfg->isp.effect);
+		break;
+
+	case PARAM_ISP_ISO:
+		__hw_param_copy(&par->isp.iso, &cfg->isp.iso);
+		break;
+
+	case PARAM_ISP_ADJUST:
+		__hw_param_copy(&par->isp.adjust, &cfg->isp.adjust);
+		break;
+
+	case PARAM_ISP_METERING:
+		__hw_param_copy(&par->isp.metering, &cfg->isp.metering);
+		break;
+
+	case PARAM_ISP_AFC:
+		__hw_param_copy(&par->isp.afc, &cfg->isp.afc);
+		break;
+
+	case PARAM_ISP_OTF_OUTPUT:
+		__hw_param_copy(&par->isp.otf_output, &cfg->isp.otf_output);
+		break;
+
+	case PARAM_ISP_DMA1_OUTPUT:
+		__hw_param_copy(&par->isp.dma1_output, &cfg->isp.dma1_output);
+		break;
+
+	case PARAM_ISP_DMA2_OUTPUT:
+		__hw_param_copy(&par->isp.dma2_output, &cfg->isp.dma2_output);
+		break;
+
+	case PARAM_DRC_CONTROL:
+		__hw_param_copy(&par->drc.control, &cfg->drc.control);
+		break;
+
+	case PARAM_DRC_OTF_INPUT:
+		__hw_param_copy(&par->drc.otf_input, &cfg->drc.otf_input);
+		break;
+
+	case PARAM_DRC_DMA_INPUT:
+		__hw_param_copy(&par->drc.dma_input, &cfg->drc.dma_input);
+		break;
+
+	case PARAM_DRC_OTF_OUTPUT:
+		__hw_param_copy(&par->drc.otf_output, &cfg->drc.otf_output);
+		break;
+
+	case PARAM_FD_CONTROL:
+		__hw_param_copy(&par->fd.control, &cfg->fd.control);
+		break;
+
+	case PARAM_FD_OTF_INPUT:
+		__hw_param_copy(&par->fd.otf_input, &cfg->fd.otf_input);
+		break;
+
+	case PARAM_FD_DMA_INPUT:
+		__hw_param_copy(&par->fd.dma_input, &cfg->fd.dma_input);
+		break;
+
+	case PARAM_FD_CONFIG:
+		__hw_param_copy(&par->fd.config, &cfg->fd.config);
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+int __is_hw_update_params(struct fimc_is *is)
+{
+	unsigned long *p_index1, *p_index2;
+	int i, id, ret = 0;
+
+	id = is->scenario_id;
+	p_index1 = &is->cfg_param[id].p_region_index1;
+	p_index2 = &is->cfg_param[id].p_region_index2;
+
+	if (test_bit(PARAM_GLOBAL_SHOTMODE, p_index1))
+		__fimc_is_hw_update_param_global_shotmode(is);
+
+	if (test_bit(PARAM_SENSOR_FRAME_RATE, p_index1))
+		__fimc_is_hw_update_param_sensor_framerate(is);
+
+	for (i = PARAM_ISP_CONTROL; i < PARAM_DRC_CONTROL; i++) {
+		if (test_bit(i, p_index1))
+			ret = __fimc_is_hw_update_param(is, i);
+	}
+
+	for (i = PARAM_DRC_CONTROL; i < PARAM_SCALERC_CONTROL; i++) {
+		if (test_bit(i, p_index1))
+			ret = __fimc_is_hw_update_param(is, i);
+	}
+
+	for (i = PARAM_FD_CONTROL; i <= PARAM_FD_CONFIG; i++) {
+		if (test_bit((i - 32), p_index2))
+			ret = __fimc_is_hw_update_param(is, i);
+	}
+
+	return ret;
+}
+
+void __is_get_frame_size(struct fimc_is *is, struct v4l2_mbus_framefmt *mf)
+{
+	struct isp_param *isp;
+
+	isp = &is->cfg_param[is->scenario_id].isp;
+	mf->width = isp->otf_input.width;
+	mf->height = isp->otf_input.height;
+}
+
+void __is_set_frame_size(struct fimc_is *is, struct v4l2_mbus_framefmt *mf)
+{
+	struct isp_param *isp;
+	struct drc_param *drc;
+	struct fd_param *fd;
+	unsigned int mode;
+
+	mode = is->scenario_id;
+	isp = &is->cfg_param[mode].isp;
+	drc = &is->cfg_param[mode].drc;
+	fd = &is->cfg_param[mode].fd;
+
+	/* Update isp size info (OTF only) */
+	isp->otf_input.width = mf->width;
+	isp->otf_input.height = mf->height;
+	isp->otf_output.width = mf->width;
+	isp->otf_output.height = mf->height;
+	/* Update drc size info (OTF only) */
+	drc->otf_input.width = mf->width;
+	drc->otf_input.height = mf->height;
+	drc->otf_output.width = mf->width;
+	drc->otf_output.height = mf->height;
+	/* Update fd size info (OTF only) */
+	fd->otf_input.width = mf->width;
+	fd->otf_input.height = mf->height;
+
+	if (test_bit(PARAM_ISP_OTF_INPUT,
+		      &is->cfg_param[mode].p_region_index1))
+		return;
+
+	/* Update field */
+	fimc_is_set_param_bit(is, PARAM_ISP_OTF_INPUT);
+	fimc_is_inc_param_num(is);
+	fimc_is_set_param_bit(is, PARAM_ISP_OTF_OUTPUT);
+	fimc_is_inc_param_num(is);
+	fimc_is_set_param_bit(is, PARAM_DRC_OTF_INPUT);
+	fimc_is_inc_param_num(is);
+	fimc_is_set_param_bit(is, PARAM_DRC_OTF_OUTPUT);
+	fimc_is_inc_param_num(is);
+	fimc_is_set_param_bit(is, PARAM_FD_OTF_INPUT);
+	fimc_is_inc_param_num(is);
+}
+
+int fimc_is_hw_get_sensor_max_framerate(struct fimc_is *is)
+{
+	switch (is->sensor->drvdata->id) {
+	case FIMC_IS_SENSOR_ID_S5K6A3:
+		return 30;
+	default:
+		return 15;
+	}
+}
+
+void __is_set_sensor(struct fimc_is *is, int fps)
+{
+	struct sensor_param *sensor;
+	struct isp_param *isp;
+	unsigned long *p_index, mode;
+
+	mode = is->scenario_id;
+	p_index = &is->cfg_param[mode].p_region_index1;
+	sensor = &is->cfg_param[mode].sensor;
+	isp = &is->cfg_param[mode].isp;
+
+	if (fps == 0) {
+		sensor->frame_rate.frame_rate =
+				fimc_is_hw_get_sensor_max_framerate(is);
+		isp->otf_input.frametime_min = 0;
+		isp->otf_input.frametime_max = 66666;
+	} else {
+		sensor->frame_rate.frame_rate = fps;
+		isp->otf_input.frametime_min = 0;
+		isp->otf_input.frametime_max = (u32)1000000 / fps;
+	}
+
+	if (!test_bit(PARAM_SENSOR_FRAME_RATE, p_index)) {
+		fimc_is_set_param_bit(is, PARAM_SENSOR_FRAME_RATE);
+		fimc_is_inc_param_num(is);
+	}
+	if (!test_bit(PARAM_ISP_OTF_INPUT, p_index)) {
+		fimc_is_set_param_bit(is, PARAM_ISP_OTF_INPUT);
+		fimc_is_inc_param_num(is);
+	}
+}
+
+void __is_set_init_isp_aa(struct fimc_is *is)
+{
+	struct isp_param *isp;
+
+	isp = &is->cfg_param[is->scenario_id].isp;
+
+	isp->aa.cmd = ISP_AA_COMMAND_START;
+	isp->aa.target = ISP_AA_TARGET_AF | ISP_AA_TARGET_AE |
+			 ISP_AA_TARGET_AWB;
+	isp->aa.mode = 0;
+	isp->aa.scene = 0;
+	isp->aa.sleep = 0;
+	isp->aa.face = 0;
+	isp->aa.touch_x = 0;
+	isp->aa.touch_y = 0;
+	isp->aa.manual_af_setting = 0;
+	isp->aa.err = ISP_AF_ERROR_NONE;
+
+	fimc_is_set_param_bit(is, PARAM_ISP_AA);
+	fimc_is_inc_param_num(is);
+}
+
+void __is_set_isp_flash(struct fimc_is *is, u32 cmd, u32 redeye)
+{
+	unsigned int mode = is->scenario_id;
+	struct is_config_param *cfg = &is->cfg_param[mode];
+	struct isp_param *isp = &cfg->isp;
+
+	isp->flash.cmd = cmd;
+	isp->flash.redeye = redeye;
+	isp->flash.err = ISP_FLASH_ERROR_NONE;
+
+	if (!test_bit(PARAM_ISP_FLASH, &cfg->p_region_index1)) {
+		fimc_is_set_param_bit(is, PARAM_ISP_FLASH);
+		fimc_is_inc_param_num(is);
+	}
+}
+
+void __is_set_isp_awb(struct fimc_is *is, u32 cmd, u32 val)
+{
+	unsigned int mode = is->scenario_id;
+	struct isp_param *isp;
+	unsigned long *p_index;
+
+	p_index = &is->cfg_param[mode].p_region_index1;
+	isp = &is->cfg_param[mode].isp;
+
+	isp->awb.cmd = cmd;
+	isp->awb.illumination = val;
+	isp->awb.err = ISP_AWB_ERROR_NONE;
+
+	if (!test_bit(PARAM_ISP_AWB, p_index)) {
+		fimc_is_set_param_bit(is, PARAM_ISP_AWB);
+		fimc_is_inc_param_num(is);
+	}
+}
+
+void __is_set_isp_effect(struct fimc_is *is, u32 cmd)
+{
+	unsigned int mode = is->scenario_id;
+	struct isp_param *isp;
+	unsigned long *p_index;
+
+	p_index = &is->cfg_param[mode].p_region_index1;
+	isp = &is->cfg_param[mode].isp;
+
+	isp->effect.cmd = cmd;
+	isp->effect.err = ISP_IMAGE_EFFECT_ERROR_NONE;
+
+	if (!test_bit(PARAM_ISP_IMAGE_EFFECT, p_index)) {
+		fimc_is_set_param_bit(is, PARAM_ISP_IMAGE_EFFECT);
+		fimc_is_inc_param_num(is);
+	}
+}
+
+void __is_set_isp_iso(struct fimc_is *is, u32 cmd, u32 val)
+{
+	unsigned int mode = is->scenario_id;
+	struct isp_param *isp;
+	unsigned long *p_index;
+
+	p_index = &is->cfg_param[mode].p_region_index1;
+	isp = &is->cfg_param[mode].isp;
+
+	isp->iso.cmd = cmd;
+	isp->iso.value = val;
+	isp->iso.err = ISP_ISO_ERROR_NONE;
+
+	if (!test_bit(PARAM_ISP_ISO, p_index)) {
+		fimc_is_set_param_bit(is, PARAM_ISP_ISO);
+		fimc_is_inc_param_num(is);
+	}
+}
+
+void __is_set_isp_adjust(struct fimc_is *is, u32 cmd, u32 val)
+{
+	unsigned int mode = is->scenario_id;
+	unsigned long *p_index;
+	struct isp_param *isp;
+
+	p_index = &is->cfg_param[mode].p_region_index1;
+	isp = &is->cfg_param[mode].isp;
+
+	switch (cmd) {
+	case ISP_ADJUST_COMMAND_MANUAL_CONTRAST:
+		isp->adjust.contrast = val;
+		break;
+	case ISP_ADJUST_COMMAND_MANUAL_SATURATION:
+		isp->adjust.saturation = val;
+		break;
+	case ISP_ADJUST_COMMAND_MANUAL_SHARPNESS:
+		isp->adjust.sharpness = val;
+		break;
+	case ISP_ADJUST_COMMAND_MANUAL_EXPOSURE:
+		isp->adjust.exposure = val;
+		break;
+	case ISP_ADJUST_COMMAND_MANUAL_BRIGHTNESS:
+		isp->adjust.brightness = val;
+		break;
+	case ISP_ADJUST_COMMAND_MANUAL_HUE:
+		isp->adjust.hue = val;
+		break;
+	case ISP_ADJUST_COMMAND_AUTO:
+		isp->adjust.contrast = 0;
+		isp->adjust.saturation = 0;
+		isp->adjust.sharpness = 0;
+		isp->adjust.exposure = 0;
+		isp->adjust.brightness = 0;
+		isp->adjust.hue = 0;
+		break;
+	}
+
+	if (!test_bit(PARAM_ISP_ADJUST, p_index)) {
+		isp->adjust.cmd = cmd;
+		isp->adjust.err = ISP_ADJUST_ERROR_NONE;
+		fimc_is_set_param_bit(is, PARAM_ISP_ADJUST);
+		fimc_is_inc_param_num(is);
+	} else {
+		isp->adjust.cmd |= cmd;
+	}
+}
+
+void __is_set_isp_metering(struct fimc_is *is, u32 id, u32 val)
+{
+	struct isp_param *isp;
+	unsigned long *p_index, mode;
+
+	mode = is->scenario_id;
+	p_index = &is->cfg_param[mode].p_region_index1;
+	isp = &is->cfg_param[mode].isp;
+
+	switch (id) {
+	case IS_METERING_CONFIG_CMD:
+		isp->metering.cmd = val;
+		break;
+	case IS_METERING_CONFIG_WIN_POS_X:
+		isp->metering.win_pos_x = val;
+		break;
+	case IS_METERING_CONFIG_WIN_POS_Y:
+		isp->metering.win_pos_y = val;
+		break;
+	case IS_METERING_CONFIG_WIN_WIDTH:
+		isp->metering.win_width = val;
+		break;
+	case IS_METERING_CONFIG_WIN_HEIGHT:
+		isp->metering.win_height = val;
+		break;
+	default:
+		return;
+	}
+
+	if (!test_bit(PARAM_ISP_METERING, p_index)) {
+		isp->metering.err = ISP_METERING_ERROR_NONE;
+		fimc_is_set_param_bit(is, PARAM_ISP_METERING);
+		fimc_is_inc_param_num(is);
+	}
+}
+
+void __is_set_isp_afc(struct fimc_is *is, u32 cmd, u32 val)
+{
+	struct isp_param *isp;
+	unsigned long *p_index, mode;
+
+	mode = is->scenario_id;
+	p_index = &is->cfg_param[mode].p_region_index1;
+	isp = &is->cfg_param[mode].isp;
+
+	isp->afc.cmd = cmd;
+	isp->afc.manual = val;
+	isp->afc.err = ISP_AFC_ERROR_NONE;
+
+	if (!test_bit(PARAM_ISP_AFC, p_index)) {
+		fimc_is_set_param_bit(is, PARAM_ISP_AFC);
+		fimc_is_inc_param_num(is);
+	}
+}
+
+void __is_set_drc_control(struct fimc_is *is, u32 val)
+{
+	struct drc_param *drc;
+	unsigned long *p_index, mode;
+
+	mode = is->scenario_id;
+	p_index = &is->cfg_param[mode].p_region_index1;
+	drc = &is->cfg_param[mode].drc;
+
+	drc->control.bypass = val;
+
+	if (!test_bit(PARAM_DRC_CONTROL, p_index)) {
+		fimc_is_set_param_bit(is, PARAM_DRC_CONTROL);
+		fimc_is_inc_param_num(is);
+	}
+}
+
+void __is_set_fd_control(struct fimc_is *is, u32 val)
+{
+	struct fd_param *fd;
+	unsigned long *p_index, mode;
+
+	mode = is->scenario_id;
+	p_index = &is->cfg_param[mode].p_region_index2;
+	fd = &is->cfg_param[mode].fd;
+
+	fd->control.cmd = val;
+
+	if (!test_bit((PARAM_FD_CONFIG - 32), p_index)) {
+		fimc_is_set_param_bit(is, PARAM_FD_CONTROL);
+		fimc_is_inc_param_num(is);
+	}
+}
+
+void __is_set_fd_config_maxface(struct fimc_is *is, u32 val)
+{
+	struct fd_param *fd;
+	unsigned long *p_index, mode;
+
+	mode = is->scenario_id;
+	p_index = &is->cfg_param[mode].p_region_index2;
+	fd = &is->cfg_param[mode].fd;
+
+	fd->config.max_number = val;
+
+	if (!test_bit((PARAM_FD_CONFIG - 32), p_index)) {
+		fd->config.cmd = FD_CONFIG_COMMAND_MAXIMUM_NUMBER;
+		fd->config.err = ERROR_FD_NONE;
+		fimc_is_set_param_bit(is, PARAM_FD_CONFIG);
+		fimc_is_inc_param_num(is);
+	} else {
+		fd->config.cmd |= FD_CONFIG_COMMAND_MAXIMUM_NUMBER;
+	}
+}
+
+void __is_set_fd_config_rollangle(struct fimc_is *is, u32 val)
+{
+	struct fd_param *fd;
+	unsigned long *p_index, mode;
+
+	mode = is->scenario_id;
+	p_index = &is->cfg_param[mode].p_region_index2;
+	fd = &is->cfg_param[mode].fd;
+
+	fd->config.roll_angle = val;
+
+	if (!test_bit((PARAM_FD_CONFIG - 32), p_index)) {
+		fd->config.cmd = FD_CONFIG_COMMAND_ROLL_ANGLE;
+		fd->config.err = ERROR_FD_NONE;
+		fimc_is_set_param_bit(is, PARAM_FD_CONFIG);
+		fimc_is_inc_param_num(is);
+	} else {
+		fd->config.cmd |= FD_CONFIG_COMMAND_ROLL_ANGLE;
+	}
+}
+
+void __is_set_fd_config_yawangle(struct fimc_is *is, u32 val)
+{
+	struct fd_param *fd;
+	unsigned long *p_index, mode;
+
+	mode = is->scenario_id;
+	p_index = &is->cfg_param[mode].p_region_index2;
+	fd = &is->cfg_param[mode].fd;
+
+	fd->config.yaw_angle = val;
+
+	if (!test_bit((PARAM_FD_CONFIG - 32), p_index)) {
+		fd->config.cmd = FD_CONFIG_COMMAND_YAW_ANGLE;
+		fd->config.err = ERROR_FD_NONE;
+		fimc_is_set_param_bit(is, PARAM_FD_CONFIG);
+		fimc_is_inc_param_num(is);
+	} else {
+		fd->config.cmd |= FD_CONFIG_COMMAND_YAW_ANGLE;
+	}
+}
+
+void __is_set_fd_config_smilemode(struct fimc_is *is, u32 val)
+{
+	struct fd_param *fd;
+	unsigned long *p_index, mode;
+
+	mode = is->scenario_id;
+	p_index = &is->cfg_param[mode].p_region_index2;
+	fd = &is->cfg_param[mode].fd;
+
+	fd->config.smile_mode = val;
+
+	if (!test_bit((PARAM_FD_CONFIG - 32), p_index)) {
+		fd->config.cmd = FD_CONFIG_COMMAND_SMILE_MODE;
+		fd->config.err = ERROR_FD_NONE;
+		fimc_is_set_param_bit(is, PARAM_FD_CONFIG);
+		fimc_is_inc_param_num(is);
+	} else {
+		fd->config.cmd |= FD_CONFIG_COMMAND_SMILE_MODE;
+	}
+}
+
+void __is_set_fd_config_blinkmode(struct fimc_is *is, u32 val)
+{
+	struct fd_param *fd;
+	unsigned long *p_index, mode;
+
+	mode = is->scenario_id;
+	p_index = &is->cfg_param[mode].p_region_index2;
+	fd = &is->cfg_param[mode].fd;
+
+	fd->config.blink_mode = val;
+
+	if (!test_bit((PARAM_FD_CONFIG - 32), p_index)) {
+		fd->config.cmd = FD_CONFIG_COMMAND_BLINK_MODE;
+		fd->config.err = ERROR_FD_NONE;
+		fimc_is_set_param_bit(is, PARAM_FD_CONFIG);
+		fimc_is_inc_param_num(is);
+	} else {
+		fd->config.cmd |= FD_CONFIG_COMMAND_BLINK_MODE;
+	}
+}
+
+void __is_set_fd_config_eyedetect(struct fimc_is *is, u32 val)
+{
+	struct fd_param *fd;
+	unsigned long *p_index, mode;
+
+	mode = is->scenario_id;
+	p_index = &is->cfg_param[mode].p_region_index2;
+	fd = &is->cfg_param[mode].fd;
+
+	fd->config.eye_detect = val;
+
+	if (!test_bit((PARAM_FD_CONFIG - 32), p_index)) {
+		fd->config.cmd = FD_CONFIG_COMMAND_EYES_DETECT;
+		fd->config.err = ERROR_FD_NONE;
+		fimc_is_set_param_bit(is, PARAM_FD_CONFIG);
+		fimc_is_inc_param_num(is);
+	} else {
+		fd->config.cmd |= FD_CONFIG_COMMAND_EYES_DETECT;
+	}
+}
+
+void __is_set_fd_config_mouthdetect(struct fimc_is *is, u32 val)
+{
+	struct fd_param *fd;
+	unsigned long *p_index, mode;
+
+	mode = is->scenario_id;
+	p_index = &is->cfg_param[mode].p_region_index2;
+	fd = &is->cfg_param[mode].fd;
+
+	fd->config.mouth_detect = val;
+
+	if (!test_bit((PARAM_FD_CONFIG - 32), p_index)) {
+		fd->config.cmd = FD_CONFIG_COMMAND_MOUTH_DETECT;
+		fd->config.err = ERROR_FD_NONE;
+		fimc_is_set_param_bit(is, PARAM_FD_CONFIG);
+		fimc_is_inc_param_num(is);
+	} else {
+		fd->config.cmd |= FD_CONFIG_COMMAND_MOUTH_DETECT;
+	}
+}
+
+void __is_set_fd_config_orientation(struct fimc_is *is, u32 val)
+{
+	struct fd_param *fd;
+	unsigned long *p_index, mode;
+
+	mode = is->scenario_id;
+	p_index = &is->cfg_param[mode].p_region_index2;
+	fd = &is->cfg_param[mode].fd;
+
+	fd->config.orientation = val;
+
+	if (!test_bit((PARAM_FD_CONFIG - 32), p_index)) {
+		fd->config.cmd = FD_CONFIG_COMMAND_ORIENTATION;
+		fd->config.err = ERROR_FD_NONE;
+		fimc_is_set_param_bit(is, PARAM_FD_CONFIG);
+		fimc_is_inc_param_num(is);
+	} else {
+		fd->config.cmd |= FD_CONFIG_COMMAND_ORIENTATION;
+	}
+}
+
+void __is_set_fd_config_orientation_val(struct fimc_is *is, u32 val)
+{
+	struct fd_param *fd;
+	unsigned long *p_index, mode;
+
+	mode = is->scenario_id;
+	p_index = &is->cfg_param[mode].p_region_index2;
+	fd = &is->cfg_param[mode].fd;
+
+	fd->config.orientation_value = val;
+
+	if (!test_bit((PARAM_FD_CONFIG - 32), p_index)) {
+		fd->config.cmd = FD_CONFIG_COMMAND_ORIENTATION_VALUE;
+		fd->config.err = ERROR_FD_NONE;
+		fimc_is_set_param_bit(is, PARAM_FD_CONFIG);
+		fimc_is_inc_param_num(is);
+	} else {
+		fd->config.cmd |= FD_CONFIG_COMMAND_ORIENTATION_VALUE;
+	}
+}
+
+void fimc_is_set_initial_params(struct fimc_is *is)
+{
+	struct global_param *global;
+	struct sensor_param *sensor;
+	struct isp_param *isp;
+	struct drc_param *drc;
+	struct fd_param *fd;
+	unsigned long *p_index1, *p_index2;
+	unsigned int mode;
+
+	mode = is->scenario_id;
+	global = &is->cfg_param[mode].global;
+	sensor = &is->cfg_param[mode].sensor;
+	isp = &is->cfg_param[mode].isp;
+	drc = &is->cfg_param[mode].drc;
+	fd = &is->cfg_param[mode].fd;
+	p_index1 = &is->cfg_param[mode].p_region_index1;
+	p_index2 = &is->cfg_param[mode].p_region_index2;
+
+	/* Global */
+	global->shotmode.cmd = 1;
+	fimc_is_set_param_bit(is, PARAM_GLOBAL_SHOTMODE);
+	fimc_is_inc_param_num(is);
+
+	/* ISP */
+	isp->control.cmd = CONTROL_COMMAND_START;
+	isp->control.bypass = CONTROL_BYPASS_DISABLE;
+	isp->control.err = CONTROL_ERROR_NONE;
+	fimc_is_set_param_bit(is, PARAM_ISP_CONTROL);
+	fimc_is_inc_param_num(is);
+
+	isp->otf_input.cmd = OTF_INPUT_COMMAND_ENABLE;
+	if (!test_bit(PARAM_ISP_OTF_INPUT, p_index1)) {
+		isp->otf_input.width = DEFAULT_PREVIEW_STILL_WIDTH;
+		isp->otf_input.height = DEFAULT_PREVIEW_STILL_HEIGHT;
+		fimc_is_set_param_bit(is, PARAM_ISP_OTF_INPUT);
+		fimc_is_inc_param_num(is);
+	}
+	if (is->sensor->test_pattern)
+		isp->otf_input.format = OTF_INPUT_FORMAT_STRGEN_COLORBAR_BAYER;
+	else
+		isp->otf_input.format = OTF_INPUT_FORMAT_BAYER;
+	isp->otf_input.bitwidth = 10;
+	isp->otf_input.order = OTF_INPUT_ORDER_BAYER_GR_BG;
+	isp->otf_input.crop_offset_x = 0;
+	isp->otf_input.crop_offset_y = 0;
+	isp->otf_input.err = OTF_INPUT_ERROR_NONE;
+
+	isp->dma1_input.cmd = DMA_INPUT_COMMAND_DISABLE;
+	isp->dma1_input.width = 0;
+	isp->dma1_input.height = 0;
+	isp->dma1_input.format = 0;
+	isp->dma1_input.bitwidth = 0;
+	isp->dma1_input.plane = 0;
+	isp->dma1_input.order = 0;
+	isp->dma1_input.buffer_number = 0;
+	isp->dma1_input.width = 0;
+	isp->dma1_input.err = DMA_INPUT_ERROR_NONE;
+	fimc_is_set_param_bit(is, PARAM_ISP_DMA1_INPUT);
+	fimc_is_inc_param_num(is);
+
+	isp->dma2_input.cmd = DMA_INPUT_COMMAND_DISABLE;
+	isp->dma2_input.width = 0;
+	isp->dma2_input.height = 0;
+	isp->dma2_input.format = 0;
+	isp->dma2_input.bitwidth = 0;
+	isp->dma2_input.plane = 0;
+	isp->dma2_input.order = 0;
+	isp->dma2_input.buffer_number = 0;
+	isp->dma2_input.width = 0;
+	isp->dma2_input.err = DMA_INPUT_ERROR_NONE;
+	fimc_is_set_param_bit(is, PARAM_ISP_DMA2_INPUT);
+	fimc_is_inc_param_num(is);
+
+	isp->aa.cmd = ISP_AA_COMMAND_START;
+	isp->aa.target = ISP_AA_TARGET_AE | ISP_AA_TARGET_AWB;
+	fimc_is_set_param_bit(is, PARAM_ISP_AA);
+	fimc_is_inc_param_num(is);
+
+	if (!test_bit(PARAM_ISP_FLASH, p_index1))
+		__is_set_isp_flash(is, ISP_FLASH_COMMAND_DISABLE,
+						ISP_FLASH_REDEYE_DISABLE);
+
+	if (!test_bit(PARAM_ISP_AWB, p_index1))
+		__is_set_isp_awb(is, ISP_AWB_COMMAND_AUTO, 0);
+
+	if (!test_bit(PARAM_ISP_IMAGE_EFFECT, p_index1))
+		__is_set_isp_effect(is, ISP_IMAGE_EFFECT_DISABLE);
+
+	if (!test_bit(PARAM_ISP_ISO, p_index1))
+		__is_set_isp_iso(is, ISP_ISO_COMMAND_AUTO, 0);
+
+	if (!test_bit(PARAM_ISP_ADJUST, p_index1)) {
+		__is_set_isp_adjust(is, ISP_ADJUST_COMMAND_MANUAL_CONTRAST, 0);
+		__is_set_isp_adjust(is,
+				ISP_ADJUST_COMMAND_MANUAL_SATURATION, 0);
+		__is_set_isp_adjust(is, ISP_ADJUST_COMMAND_MANUAL_SHARPNESS, 0);
+		__is_set_isp_adjust(is, ISP_ADJUST_COMMAND_MANUAL_EXPOSURE, 0);
+		__is_set_isp_adjust(is,
+				ISP_ADJUST_COMMAND_MANUAL_BRIGHTNESS, 0);
+		__is_set_isp_adjust(is, ISP_ADJUST_COMMAND_MANUAL_HUE, 0);
+	}
+
+	if (!test_bit(PARAM_ISP_METERING, p_index1)) {
+		__is_set_isp_metering(is, 0, ISP_METERING_COMMAND_CENTER);
+		__is_set_isp_metering(is, 1, 0);
+		__is_set_isp_metering(is, 2, 0);
+		__is_set_isp_metering(is, 3, 0);
+		__is_set_isp_metering(is, 4, 0);
+	}
+
+	if (!test_bit(PARAM_ISP_AFC, p_index1))
+		__is_set_isp_afc(is, ISP_AFC_COMMAND_AUTO, 0);
+
+	isp->otf_output.cmd = OTF_OUTPUT_COMMAND_ENABLE;
+	if (!test_bit(PARAM_ISP_OTF_OUTPUT, p_index1)) {
+		isp->otf_output.width = DEFAULT_PREVIEW_STILL_WIDTH;
+		isp->otf_output.height = DEFAULT_PREVIEW_STILL_HEIGHT;
+		fimc_is_set_param_bit(is, PARAM_ISP_OTF_OUTPUT);
+		fimc_is_inc_param_num(is);
+	}
+	isp->otf_output.format = OTF_OUTPUT_FORMAT_YUV444;
+	isp->otf_output.bitwidth = 12;
+	isp->otf_output.order = 0;
+	isp->otf_output.err = OTF_OUTPUT_ERROR_NONE;
+
+	if (!test_bit(PARAM_ISP_DMA1_OUTPUT, p_index1)) {
+		isp->dma1_output.cmd = DMA_OUTPUT_COMMAND_DISABLE;
+		isp->dma1_output.width = 0;
+		isp->dma1_output.height = 0;
+		isp->dma1_output.format = 0;
+		isp->dma1_output.bitwidth = 0;
+		isp->dma1_output.plane = 0;
+		isp->dma1_output.order = 0;
+		isp->dma1_output.buffer_number = 0;
+		isp->dma1_output.buffer_address = 0;
+		isp->dma1_output.notify_dma_done = 0;
+		isp->dma1_output.dma_out_mask = 0;
+		isp->dma1_output.err = DMA_OUTPUT_ERROR_NONE;
+		fimc_is_set_param_bit(is, PARAM_ISP_DMA1_OUTPUT);
+		fimc_is_inc_param_num(is);
+	}
+
+	if (!test_bit(PARAM_ISP_DMA2_OUTPUT, p_index1)) {
+		isp->dma2_output.cmd = DMA_OUTPUT_COMMAND_DISABLE;
+		isp->dma2_output.width = 0;
+		isp->dma2_output.height = 0;
+		isp->dma2_output.format = 0;
+		isp->dma2_output.bitwidth = 0;
+		isp->dma2_output.plane = 0;
+		isp->dma2_output.order = 0;
+		isp->dma2_output.buffer_number = 0;
+		isp->dma2_output.buffer_address = 0;
+		isp->dma2_output.notify_dma_done = 0;
+		isp->dma2_output.dma_out_mask = 0;
+		isp->dma2_output.err = DMA_OUTPUT_ERROR_NONE;
+		fimc_is_set_param_bit(is, PARAM_ISP_DMA2_OUTPUT);
+		fimc_is_inc_param_num(is);
+	}
+
+	/* Sensor */
+	if (!test_bit(PARAM_SENSOR_FRAME_RATE, p_index1)) {
+		if (!mode)
+			__is_set_sensor(is, 0);
+	}
+
+	/* DRC */
+	drc->control.cmd = CONTROL_COMMAND_START;
+	__is_set_drc_control(is, CONTROL_BYPASS_ENABLE);
+
+	drc->otf_input.cmd = OTF_INPUT_COMMAND_ENABLE;
+	if (!test_bit(PARAM_DRC_OTF_INPUT, p_index1)) {
+		drc->otf_input.width = DEFAULT_PREVIEW_STILL_WIDTH;
+		drc->otf_input.height = DEFAULT_PREVIEW_STILL_HEIGHT;
+		fimc_is_set_param_bit(is, PARAM_DRC_OTF_INPUT);
+		fimc_is_inc_param_num(is);
+	}
+	drc->otf_input.format = OTF_INPUT_FORMAT_YUV444;
+	drc->otf_input.bitwidth = 12;
+	drc->otf_input.order = 0;
+	drc->otf_input.err = OTF_INPUT_ERROR_NONE;
+
+	drc->dma_input.cmd = DMA_INPUT_COMMAND_DISABLE;
+	drc->dma_input.width = 0;
+	drc->dma_input.height = 0;
+	drc->dma_input.format = 0;
+	drc->dma_input.bitwidth = 0;
+	drc->dma_input.plane = 0;
+	drc->dma_input.order = 0;
+	drc->dma_input.buffer_number = 0;
+	drc->dma_input.width = 0;
+	drc->dma_input.err = DMA_INPUT_ERROR_NONE;
+	fimc_is_set_param_bit(is, PARAM_DRC_DMA_INPUT);
+	fimc_is_inc_param_num(is);
+
+	drc->otf_output.cmd = OTF_OUTPUT_COMMAND_ENABLE;
+	if (!test_bit(PARAM_DRC_OTF_OUTPUT, p_index1)) {
+		drc->otf_output.width = DEFAULT_PREVIEW_STILL_WIDTH;
+		drc->otf_output.height = DEFAULT_PREVIEW_STILL_HEIGHT;
+		fimc_is_set_param_bit(is, PARAM_DRC_OTF_OUTPUT);
+		fimc_is_inc_param_num(is);
+	}
+	drc->otf_output.format = OTF_OUTPUT_FORMAT_YUV444;
+	drc->otf_output.bitwidth = 8;
+	drc->otf_output.order = 0;
+	drc->otf_output.err = OTF_OUTPUT_ERROR_NONE;
+
+	/* FD */
+	__is_set_fd_control(is, CONTROL_COMMAND_STOP);
+	fd->control.bypass = CONTROL_BYPASS_DISABLE;
+
+	fd->otf_input.cmd = OTF_INPUT_COMMAND_ENABLE;
+	if (!test_bit((PARAM_FD_OTF_INPUT - 32), p_index2)) {
+		fd->otf_input.width = DEFAULT_PREVIEW_STILL_WIDTH;
+		fd->otf_input.height = DEFAULT_PREVIEW_STILL_HEIGHT;
+		fimc_is_set_param_bit(is, PARAM_FD_OTF_INPUT);
+		fimc_is_inc_param_num(is);
+	}
+	fd->otf_input.format = OTF_INPUT_FORMAT_YUV444;
+	fd->otf_input.bitwidth = 8;
+	fd->otf_input.order = 0;
+	fd->otf_input.err = OTF_INPUT_ERROR_NONE;
+
+	fd->dma_input.cmd = DMA_INPUT_COMMAND_DISABLE;
+	fd->dma_input.width = 0;
+	fd->dma_input.height = 0;
+	fd->dma_input.format = 0;
+	fd->dma_input.bitwidth = 0;
+	fd->dma_input.plane = 0;
+	fd->dma_input.order = 0;
+	fd->dma_input.buffer_number = 0;
+	fd->dma_input.width = 0;
+	fd->dma_input.err = DMA_INPUT_ERROR_NONE;
+	fimc_is_set_param_bit(is, PARAM_FD_DMA_INPUT);
+	fimc_is_inc_param_num(is);
+
+	__is_set_fd_config_maxface(is, 5);
+	__is_set_fd_config_rollangle(is, FD_CONFIG_ROLL_ANGLE_FULL);
+	__is_set_fd_config_yawangle(is, FD_CONFIG_YAW_ANGLE_45_90);
+	__is_set_fd_config_smilemode(is, FD_CONFIG_SMILE_MODE_DISABLE);
+	__is_set_fd_config_blinkmode(is, FD_CONFIG_BLINK_MODE_DISABLE);
+	__is_set_fd_config_eyedetect(is, FD_CONFIG_EYES_DETECT_ENABLE);
+	__is_set_fd_config_mouthdetect(is, FD_CONFIG_MOUTH_DETECT_DISABLE);
+	__is_set_fd_config_orientation(is, FD_CONFIG_ORIENTATION_DISABLE);
+	__is_set_fd_config_orientation_val(is, 0);
+}
