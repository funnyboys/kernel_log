commit f75c431e54e2e43c91fe267097b974ff2e5dc668
Author: Jacopo Mondi <jacopo@jmondi.org>
Date:   Thu May 7 17:12:50 2020 +0200

    media: v4l2-dev: Add v4l2_device_register_ro_subdev_node()
    
    Add to the V4L2 core a function to register device nodes for video
    subdevices in read-only mode.
    
    Registering a device node in read-only mode is useful to expose to
    userspace the current sub-device configuration, without allowing
    application to change it by using the V4L2 subdevice ioctls.
    
    Acked-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Signed-off-by: Jacopo Mondi <jacopo@jmondi.org>
    Signed-off-by: Hans Verkuil <hverkuil-cisco@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+huawei@kernel.org>

diff --git a/drivers/media/v4l2-core/v4l2-device.c b/drivers/media/v4l2-core/v4l2-device.c
index c69941214bb2..de4287251a89 100644
--- a/drivers/media/v4l2-core/v4l2-device.c
+++ b/drivers/media/v4l2-core/v4l2-device.c
@@ -186,7 +186,8 @@ static void v4l2_device_release_subdev_node(struct video_device *vdev)
 	kfree(vdev);
 }
 
-int v4l2_device_register_subdev_nodes(struct v4l2_device *v4l2_dev)
+int __v4l2_device_register_subdev_nodes(struct v4l2_device *v4l2_dev,
+					bool read_only)
 {
 	struct video_device *vdev;
 	struct v4l2_subdev *sd;
@@ -215,6 +216,8 @@ int v4l2_device_register_subdev_nodes(struct v4l2_device *v4l2_dev)
 		vdev->fops = &v4l2_subdev_fops;
 		vdev->release = v4l2_device_release_subdev_node;
 		vdev->ctrl_handler = sd->ctrl_handler;
+		if (read_only)
+			set_bit(V4L2_FL_SUBDEV_RO_DEVNODE, &vdev->flags);
 		err = __video_register_device(vdev, VFL_TYPE_SUBDEV, -1, 1,
 					      sd->owner);
 		if (err < 0) {
@@ -252,7 +255,7 @@ int v4l2_device_register_subdev_nodes(struct v4l2_device *v4l2_dev)
 
 	return err;
 }
-EXPORT_SYMBOL_GPL(v4l2_device_register_subdev_nodes);
+EXPORT_SYMBOL_GPL(__v4l2_device_register_subdev_nodes);
 
 void v4l2_device_unregister_subdev(struct v4l2_subdev *sd)
 {

commit aead0ffbf078e0098ca6cfd1625029ff9347b10d
Author: Eugen Hristev <eugen.hristev@microchip.com>
Date:   Wed Feb 26 16:28:16 2020 +0100

    media: v4l2-core: fix entity initialization in device_register_subdev
    
    The entity variable was being initialized in the wrong place, before the
    parameters have been checked.
    To solve this, completely removed the entity variable and replaced it
    with the initialization value : &sd->entity.
    This will avoid dereferencing 'sd' pointer before it's being checked if
    it's NULL.
    
    Fixes: 61f5db549dde ("[media] v4l: Make v4l2_subdev inherit from media_entity")
    
    Signed-off-by: Eugen Hristev <eugen.hristev@microchip.com>
    Acked-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Signed-off-by: Hans Verkuil <hverkuil-cisco@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+huawei@kernel.org>

diff --git a/drivers/media/v4l2-core/v4l2-device.c b/drivers/media/v4l2-core/v4l2-device.c
index 41da73ce2e98..c69941214bb2 100644
--- a/drivers/media/v4l2-core/v4l2-device.c
+++ b/drivers/media/v4l2-core/v4l2-device.c
@@ -111,9 +111,6 @@ EXPORT_SYMBOL_GPL(v4l2_device_unregister);
 int v4l2_device_register_subdev(struct v4l2_device *v4l2_dev,
 				struct v4l2_subdev *sd)
 {
-#if defined(CONFIG_MEDIA_CONTROLLER)
-	struct media_entity *entity = &sd->entity;
-#endif
 	int err;
 
 	/* Check for valid input */
@@ -143,7 +140,7 @@ int v4l2_device_register_subdev(struct v4l2_device *v4l2_dev,
 #if defined(CONFIG_MEDIA_CONTROLLER)
 	/* Register the entity. */
 	if (v4l2_dev->mdev) {
-		err = media_device_register_entity(v4l2_dev->mdev, entity);
+		err = media_device_register_entity(v4l2_dev->mdev, &sd->entity);
 		if (err < 0)
 			goto error_module;
 	}
@@ -163,7 +160,7 @@ int v4l2_device_register_subdev(struct v4l2_device *v4l2_dev,
 
 error_unregister:
 #if defined(CONFIG_MEDIA_CONTROLLER)
-	media_device_unregister_entity(entity);
+	media_device_unregister_entity(&sd->entity);
 #endif
 error_module:
 	if (!sd->owner_v4l2_dev)

commit 6990570f7e0a6078e11b9c5dc13f4b6e3f49a398
Author: Dafna Hirschfeld <dafna.hirschfeld@collabora.com>
Date:   Wed Feb 19 16:25:54 2020 +0100

    media: v4l2-core: fix a use-after-free bug of sd->devnode
    
    sd->devnode is released after calling
    v4l2_subdev_release. Therefore it should be set
    to NULL so that the subdev won't hold a pointer
    to a released object. This fixes a reference
    after free bug in function
    v4l2_device_unregister_subdev
    
    Fixes: 0e43734d4c46e ("media: v4l2-subdev: add release() internal op")
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Dafna Hirschfeld <dafna.hirschfeld@collabora.com>
    Reviewed-by: Ezequiel Garcia <ezequiel@collabora.com>
    Signed-off-by: Hans Verkuil <hverkuil-cisco@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+huawei@kernel.org>

diff --git a/drivers/media/v4l2-core/v4l2-device.c b/drivers/media/v4l2-core/v4l2-device.c
index 63d6b147b21e..41da73ce2e98 100644
--- a/drivers/media/v4l2-core/v4l2-device.c
+++ b/drivers/media/v4l2-core/v4l2-device.c
@@ -179,6 +179,7 @@ static void v4l2_subdev_release(struct v4l2_subdev *sd)
 
 	if (sd->internal_ops && sd->internal_ops->release)
 		sd->internal_ops->release(sd);
+	sd->devnode = NULL;
 	module_put(owner);
 }
 

commit 51ff392c280733aa9e6bd47b3f5e83e32bfdf16a
Author: Ezequiel Garcia <ezequiel@collabora.com>
Date:   Thu Aug 15 13:48:05 2019 -0300

    media: v4l2-core: introduce a helper to unregister a i2c subdev
    
    Introduce a new video4linux2 i2c helper, to unregister a subdev.
    This allows to get rid of yet another ifdef.
    
    Signed-off-by: Ezequiel Garcia <ezequiel@collabora.com>
    Signed-off-by: Hans Verkuil <hverkuil-cisco@xs4all.nl>
    [hverkuil-cisco@xs4all.nl: fix checkpatch warning]
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/v4l2-core/v4l2-device.c b/drivers/media/v4l2-core/v4l2-device.c
index c2811238996f..63d6b147b21e 100644
--- a/drivers/media/v4l2-core/v4l2-device.c
+++ b/drivers/media/v4l2-core/v4l2-device.c
@@ -9,7 +9,6 @@
 #include <linux/types.h>
 #include <linux/ioctl.h>
 #include <linux/module.h>
-#include <linux/i2c.h>
 #include <linux/slab.h>
 #include <linux/videodev2.h>
 #include <media/v4l2-device.h>
@@ -99,28 +98,8 @@ void v4l2_device_unregister(struct v4l2_device *v4l2_dev)
 	/* Unregister subdevs */
 	list_for_each_entry_safe(sd, next, &v4l2_dev->subdevs, list) {
 		v4l2_device_unregister_subdev(sd);
-#if IS_ENABLED(CONFIG_I2C)
-		if (sd->flags & V4L2_SUBDEV_FL_IS_I2C) {
-			struct i2c_client *client = v4l2_get_subdevdata(sd);
-
-			/*
-			 * We need to unregister the i2c client
-			 * explicitly. We cannot rely on
-			 * i2c_del_adapter to always unregister
-			 * clients for us, since if the i2c bus is a
-			 * platform bus, then it is never deleted.
-			 *
-			 * Device tree or ACPI based devices must not
-			 * be unregistered as they have not been
-			 * registered by us, and would not be
-			 * re-created by just probing the V4L2 driver.
-			 */
-			if (client &&
-			    !client->dev.of_node && !client->dev.fwnode)
-				i2c_unregister_device(client);
-			continue;
-		}
-#endif
+		if (sd->flags & V4L2_SUBDEV_FL_IS_I2C)
+			v4l2_i2c_subdev_unregister(sd);
 		else if (sd->flags & V4L2_SUBDEV_FL_IS_SPI)
 			v4l2_spi_subdev_unregister(sd);
 	}

commit a9cff393c1d78ecbbc33e6196e79bb05ccb4a709
Author: Ezequiel Garcia <ezequiel@collabora.com>
Date:   Thu Aug 15 13:48:04 2019 -0300

    media: v4l2-core: introduce a helper to unregister a spi subdev
    
    Introduce a new video4linux2 spi helper, to unregister a subdev.
    This allows to get rid of some more ifdefs.
    
    Signed-off-by: Ezequiel Garcia <ezequiel@collabora.com>
    Signed-off-by: Hans Verkuil <hverkuil-cisco@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/v4l2-core/v4l2-device.c b/drivers/media/v4l2-core/v4l2-device.c
index aa277f5bc862..c2811238996f 100644
--- a/drivers/media/v4l2-core/v4l2-device.c
+++ b/drivers/media/v4l2-core/v4l2-device.c
@@ -11,9 +11,6 @@
 #include <linux/module.h>
 #include <linux/i2c.h>
 #include <linux/slab.h>
-#if defined(CONFIG_SPI)
-#include <linux/spi/spi.h>
-#endif
 #include <linux/videodev2.h>
 #include <media/v4l2-device.h>
 #include <media/v4l2-ctrls.h>
@@ -124,15 +121,8 @@ void v4l2_device_unregister(struct v4l2_device *v4l2_dev)
 			continue;
 		}
 #endif
-#if defined(CONFIG_SPI)
-		if (sd->flags & V4L2_SUBDEV_FL_IS_SPI) {
-			struct spi_device *spi = v4l2_get_subdevdata(sd);
-
-			if (spi && !spi->dev.of_node && !spi->dev.fwnode)
-				spi_unregister_device(spi);
-			continue;
-		}
-#endif
+		else if (sd->flags & V4L2_SUBDEV_FL_IS_SPI)
+			v4l2_spi_subdev_unregister(sd);
 	}
 	/* Mark as unregistered, thus preventing duplicate unregistrations */
 	v4l2_dev->name[0] = '\0';

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/media/v4l2-core/v4l2-device.c b/drivers/media/v4l2-core/v4l2-device.c
index 7cca0de1b730..aa277f5bc862 100644
--- a/drivers/media/v4l2-core/v4l2-device.c
+++ b/drivers/media/v4l2-core/v4l2-device.c
@@ -1,21 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
     V4L2 device support.
 
     Copyright (C) 2008  Hans Verkuil <hverkuil@xs4all.nl>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
 #include <linux/types.h>

commit 0e43734d4c46e156785bb1d2acc5b3c10b7d5dd5
Author: Hans Verkuil <hverkuil-cisco@xs4all.nl>
Date:   Thu Feb 21 08:37:42 2019 -0500

    media: v4l2-subdev: add release() internal op
    
    If the subdevice created a device node, then the v4l2_subdev cannot
    be freed until the last user of the device node closes it.
    
    This means that we need a release() callback in v4l2_subdev_internal_ops
    that is called from the video_device release function so the subdevice
    driver can postpone freeing memory until the that callback is called.
    
    If no video device node was created then the release callback can
    be called immediately when the subdev is unregistered.
    
    Signed-off-by: Hans Verkuil <hverkuil-cisco@xs4all.nl>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/v4l2-core/v4l2-device.c b/drivers/media/v4l2-core/v4l2-device.c
index e0ddb9a52bd1..7cca0de1b730 100644
--- a/drivers/media/v4l2-core/v4l2-device.c
+++ b/drivers/media/v4l2-core/v4l2-device.c
@@ -216,10 +216,18 @@ int v4l2_device_register_subdev(struct v4l2_device *v4l2_dev,
 }
 EXPORT_SYMBOL_GPL(v4l2_device_register_subdev);
 
+static void v4l2_subdev_release(struct v4l2_subdev *sd)
+{
+	struct module *owner = !sd->owner_v4l2_dev ? sd->owner : NULL;
+
+	if (sd->internal_ops && sd->internal_ops->release)
+		sd->internal_ops->release(sd);
+	module_put(owner);
+}
+
 static void v4l2_device_release_subdev_node(struct video_device *vdev)
 {
-	struct v4l2_subdev *sd = video_get_drvdata(vdev);
-	sd->devnode = NULL;
+	v4l2_subdev_release(video_get_drvdata(vdev));
 	kfree(vdev);
 }
 
@@ -318,8 +326,9 @@ void v4l2_device_unregister_subdev(struct v4l2_subdev *sd)
 		media_device_unregister_entity(&sd->entity);
 	}
 #endif
-	video_unregister_device(sd->devnode);
-	if (!sd->owner_v4l2_dev)
-		module_put(sd->owner);
+	if (sd->devnode)
+		video_unregister_device(sd->devnode);
+	else
+		v4l2_subdev_release(sd);
 }
 EXPORT_SYMBOL_GPL(v4l2_device_unregister_subdev);

commit ee494cf377e142f65f202fadf0d859f8e12119fb
Author: Tomasz Figa <tfiga@chromium.org>
Date:   Thu Dec 14 23:32:21 2017 -0500

    media: v4l2-device: Link subdevices to their parent devices if available
    
    Currently v4l2_device_register_subdev_nodes() does not initialize the
    dev_parent field of the video_device structs it creates for subdevices
    being registered. This leads to __video_register_device() falling back
    to the parent device of associated v4l2_device struct, which often does
    not match the physical device the subdevice is registered for.
    
    Due to the problem above, the links between real devices and v4l-subdev
    nodes cannot be obtained from sysfs, which might be confusing for the
    userspace trying to identify the hardware.
    
    Fix this by initializing the dev_parent field of the video_device struct
    with the value of dev field of the v4l2_subdev struct. In case of
    subdevices without a parent struct device, the field will be NULL and the
    old behavior will be preserved by the semantics of
    __video_register_device().
    
    Signed-off-by: Tomasz Figa <tfiga@chromium.org>
    Acked-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/v4l2-core/v4l2-device.c b/drivers/media/v4l2-core/v4l2-device.c
index df0ac38c4050..e0ddb9a52bd1 100644
--- a/drivers/media/v4l2-core/v4l2-device.c
+++ b/drivers/media/v4l2-core/v4l2-device.c
@@ -247,6 +247,7 @@ int v4l2_device_register_subdev_nodes(struct v4l2_device *v4l2_dev)
 
 		video_set_drvdata(vdev, sd);
 		strscpy(vdev->name, sd->name, sizeof(vdev->name));
+		vdev->dev_parent = sd->dev;
 		vdev->v4l2_dev = v4l2_dev;
 		vdev->fops = &v4l2_subdev_fops;
 		vdev->release = v4l2_device_release_subdev_node;

commit b3491d8430dd25f0a4e00c33d60da22a9bd9d052
Merge: 59fc453b21f7 e4183d3256e3
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Oct 31 10:53:29 2018 -0700

    Merge tag 'media/v4.20-2' of git://git.kernel.org/pub/scm/linux/kernel/git/mchehab/linux-media
    
    Pull new experimental media request API from Mauro Carvalho Chehab:
     "A new media request API
    
      This API is needed to support device drivers that can dynamically
      change their parameters for each new frame. The latest versions of
      Google camera and codec HAL depends on such feature.
    
      At this stage, it supports only stateless codecs.
    
      It has been discussed for a long time (at least over the last 3-4
      years), and we finally reached to something that seem to work.
    
      This series contain both the API and core changes required to support
      it and a new m2m decoder driver (cedrus).
    
      As the current API is still experimental, the only real driver using
      it (cedrus) was added at staging[1]. We intend to keep it there for a
      while, in order to test the API. Only when we're sure that this API
      works for other cases (like encoders), we'll move this driver out of
      staging and set the API into a stone.
    
      [1] We added support for the vivid virtual driver (used only for
      testing) to it too, as it makes easier to test the API for the ones
      that don't have the cedrus hardware"
    
    * tag 'media/v4.20-2' of git://git.kernel.org/pub/scm/linux/kernel/git/mchehab/linux-media: (53 commits)
      media: dt-bindings: Document the Rockchip VPU bindings
      media: platform: Add Cedrus VPU decoder driver
      media: dt-bindings: media: Document bindings for the Cedrus VPU driver
      media: v4l: Add definition for the Sunxi tiled NV12 format
      media: v4l: Add definitions for MPEG-2 slice format and metadata
      media: videobuf2-core: Rework and rename helper for request buffer count
      media: v4l2-ctrls.c: initialize an error return code with zero
      media: v4l2-compat-ioctl32.c: add missing documentation for a field
      media: media-request: update documentation
      media: media-request: EPERM -> EACCES/EBUSY
      media: v4l2-ctrls: improve media_request_(un)lock_for_update
      media: v4l2-ctrls: use media_request_(un)lock_for_access
      media: media-request: add media_request_(un)lock_for_access
      media: vb2: set reqbufs/create_bufs capabilities
      media: videodev2.h: add new capabilities for buffer types
      media: buffer.rst: only set V4L2_BUF_FLAG_REQUEST_FD for QBUF
      media: v4l2-ctrls: return -EACCES if request wasn't completed
      media: media-request: return -EINVAL for invalid request_fds
      media: vivid: add request support
      media: vivid: add mc
      ...

commit c0decac19da3906d9b66291e57b7759489e1170f
Author: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
Date:   Mon Sep 10 08:19:14 2018 -0400

    media: use strscpy() instead of strlcpy()
    
    The implementation of strscpy() is more robust and safer.
    
    That's now the recommended way to copy NUL terminated strings.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Acked-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/v4l2-core/v4l2-device.c b/drivers/media/v4l2-core/v4l2-device.c
index 3940e55c72f1..098562901f25 100644
--- a/drivers/media/v4l2-core/v4l2-device.c
+++ b/drivers/media/v4l2-core/v4l2-device.c
@@ -245,7 +245,7 @@ int v4l2_device_register_subdev_nodes(struct v4l2_device *v4l2_dev)
 		}
 
 		video_set_drvdata(vdev, sd);
-		strlcpy(vdev->name, sd->name, sizeof(vdev->name));
+		strscpy(vdev->name, sd->name, sizeof(vdev->name));
 		vdev->v4l2_dev = v4l2_dev;
 		vdev->fops = &v4l2_subdev_fops;
 		vdev->release = v4l2_device_release_subdev_node;

commit da1b1aeac1aced231ac85329112a592dc14d173a
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Mon May 21 04:54:36 2018 -0400

    media: v4l2-ctrls: v4l2_ctrl_add_handler: add from_other_dev
    
    Add a 'bool from_other_dev' argument: set to true if the two
    handlers refer to different devices (e.g. it is true when
    inheriting controls from a subdev into a main v4l2 bridge
    driver).
    
    This will be used later when implementing support for the
    request API since we need to skip such controls.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Alexandre Courbot <acourbot@chromium.org>
    Reviewed-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/v4l2-core/v4l2-device.c b/drivers/media/v4l2-core/v4l2-device.c
index 3940e55c72f1..5189fb9f741f 100644
--- a/drivers/media/v4l2-core/v4l2-device.c
+++ b/drivers/media/v4l2-core/v4l2-device.c
@@ -178,7 +178,8 @@ int v4l2_device_register_subdev(struct v4l2_device *v4l2_dev,
 
 	sd->v4l2_dev = v4l2_dev;
 	/* This just returns 0 if either of the two args is NULL */
-	err = v4l2_ctrl_add_handler(v4l2_dev->ctrl_handler, sd->ctrl_handler, NULL);
+	err = v4l2_ctrl_add_handler(v4l2_dev->ctrl_handler, sd->ctrl_handler,
+				    NULL, true);
 	if (err)
 		goto error_module;
 

commit 4d1e4545a65903a09f5d15d32a3fbb6131a8d11e
Author: Hans Verkuil <hverkuil@xs4all.nl>
Date:   Mon Jul 2 08:43:02 2018 -0400

    media: mark entity-intf links as IMMUTABLE
    
    Currently links between entities and an interface are just marked as
    ENABLED. But (at least today) these links cannot be disabled by userspace
    or the driver, so they should also be marked as IMMUTABLE.
    
    It might become possible that drivers can disable such links (if for some
    reason the device node cannot be used), so we might need to add a new link
    flag at some point to mark interface links that can be changed by the driver
    but not by userspace.
    
    Acked-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/v4l2-core/v4l2-device.c b/drivers/media/v4l2-core/v4l2-device.c
index 937c6de85606..3940e55c72f1 100644
--- a/drivers/media/v4l2-core/v4l2-device.c
+++ b/drivers/media/v4l2-core/v4l2-device.c
@@ -267,7 +267,8 @@ int v4l2_device_register_subdev_nodes(struct v4l2_device *v4l2_dev)
 
 			link = media_create_intf_link(&sd->entity,
 						      &vdev->intf_devnode->intf,
-						      MEDIA_LNK_FL_ENABLED);
+						      MEDIA_LNK_FL_ENABLED |
+						      MEDIA_LNK_FL_IMMUTABLE);
 			if (!link) {
 				err = -ENOMEM;
 				goto clean_up;

commit db0f4691d9749d5dd758b8636290cec8fd88aa26
Author: Sebastian Reichel <sre@kernel.org>
Date:   Tue Feb 14 20:38:49 2017 -0200

    [media] v4l: Allow calling v4l2_device_register_subdev_nodes() multiple times
    
    Previously multiple calls to v4l2_device_register_subdev_nodes() ended up
    corrupting memory and leaking some, too. This patch changes the behaviour so
    that sub-devices the device nodes of which are already registered are
    ignored.
    
    Signed-off-by: Sebastian Reichel <sre@kernel.org>
    Signed-off-by: Ivaylo Dimitrov <ivo.g.dimitrov.75@gmail.com>
    Signed-off-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/v4l2-core/v4l2-device.c b/drivers/media/v4l2-core/v4l2-device.c
index f364cc1b521d..937c6de85606 100644
--- a/drivers/media/v4l2-core/v4l2-device.c
+++ b/drivers/media/v4l2-core/v4l2-device.c
@@ -235,6 +235,9 @@ int v4l2_device_register_subdev_nodes(struct v4l2_device *v4l2_dev)
 		if (!(sd->flags & V4L2_SUBDEV_FL_HAS_DEVNODE))
 			continue;
 
+		if (sd->devnode)
+			continue;
+
 		vdev = kzalloc(sizeof(*vdev), GFP_KERNEL);
 		if (!vdev) {
 			err = -ENOMEM;

commit 909aa003eb7239161f0fa5773878035ed1754cf4
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sun Jan 15 17:05:30 2017 -0200

    [media] v4l: subdev: Clean up properly in subdev devnode registration error path
    
    Set the subdev devnode pointer right after registration to ensure that
    later errors won't skip the subdev when unregistering all devnodes.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Acked-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/v4l2-core/v4l2-device.c b/drivers/media/v4l2-core/v4l2-device.c
index 62bbed76dbbc..f364cc1b521d 100644
--- a/drivers/media/v4l2-core/v4l2-device.c
+++ b/drivers/media/v4l2-core/v4l2-device.c
@@ -253,6 +253,7 @@ int v4l2_device_register_subdev_nodes(struct v4l2_device *v4l2_dev)
 			kfree(vdev);
 			goto clean_up;
 		}
+		sd->devnode = vdev;
 #if defined(CONFIG_MEDIA_CONTROLLER)
 		sd->entity.info.dev.major = VIDEO_MAJOR;
 		sd->entity.info.dev.minor = vdev->minor;
@@ -270,7 +271,6 @@ int v4l2_device_register_subdev_nodes(struct v4l2_device *v4l2_dev)
 			}
 		}
 #endif
-		sd->devnode = vdev;
 	}
 	return 0;
 

commit fc49071766ed371268cc03b868cf97f21ad3f273
Author: Sakari Ailus <sakari.ailus@linux.intel.com>
Date:   Thu Aug 11 07:18:37 2016 -0300

    [media] v4l: Do not allow re-registering sub-devices
    
    Albeit not prohibited explicitly, re-registering sub-devices generated a
    big, loud warning which quite likely soon was followed by a crash. What
    followed was re-initialising a media entity, driver's registered() callback
    being called and re-adding a list entry to a list.
    
    Prevent this by returning an error if a sub-device is already registered.
    
    [mchehab@s-opensource.com: reorder logic to check if !sd before dereferencing it]
    Signed-off-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/v4l2-core/v4l2-device.c b/drivers/media/v4l2-core/v4l2-device.c
index 06fa5f1b2cff..62bbed76dbbc 100644
--- a/drivers/media/v4l2-core/v4l2-device.c
+++ b/drivers/media/v4l2-core/v4l2-device.c
@@ -160,12 +160,9 @@ int v4l2_device_register_subdev(struct v4l2_device *v4l2_dev,
 	int err;
 
 	/* Check for valid input */
-	if (v4l2_dev == NULL || sd == NULL || !sd->name[0])
+	if (!v4l2_dev || !sd || sd->v4l2_dev || !sd->name[0])
 		return -EINVAL;
 
-	/* Warn if we apparently re-register a subdev */
-	WARN_ON(sd->v4l2_dev != NULL);
-
 	/*
 	 * The reason to acquire the module here is to avoid unloading
 	 * a module of sub-device which is registered to a media

commit 1630b832355399dd0dc4fcc2cadbcad47153a748
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Tue Dec 15 09:04:14 2015 -0200

    [media] v4l2-device: fix a missing error code
    
    We need to set "err = -ENOMEM" here.
    
    Fixes: 38b11f19667a ('[media] v4l2-core: create MC interfaces for devnodes')
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/v4l2-core/v4l2-device.c b/drivers/media/v4l2-core/v4l2-device.c
index 2aa72aba4f17..06fa5f1b2cff 100644
--- a/drivers/media/v4l2-core/v4l2-device.c
+++ b/drivers/media/v4l2-core/v4l2-device.c
@@ -267,8 +267,10 @@ int v4l2_device_register_subdev_nodes(struct v4l2_device *v4l2_dev)
 			link = media_create_intf_link(&sd->entity,
 						      &vdev->intf_devnode->intf,
 						      MEDIA_LNK_FL_ENABLED);
-			if (!link)
+			if (!link) {
+				err = -ENOMEM;
 				goto clean_up;
+			}
 		}
 #endif
 		sd->devnode = vdev;

commit bdf5c198261cdda8dcc5375315afe9d8bf4d77d1
Author: Sakari Ailus <sakari.ailus@iki.fi>
Date:   Mon Dec 28 01:45:00 2015 +0200

    [media] v4l2-device: Register entity before calling subdev's registered ops
    
    Registering a V4L2 sub-device includes, among other things, registering
    the related media entity and calling the sub-device's registered op. Since
    patch "media: convert links from array to list", creating a link between
    two pads requires registering the entity first. If the registered() op
    involves link creation, the link list head will not be initialised before
    it is used.
    
    Resolve this by first registering the entity, then calling its
    registered() op.
    
    Signed-off-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/v4l2-core/v4l2-device.c b/drivers/media/v4l2-core/v4l2-device.c
index 85f724b53a14..2aa72aba4f17 100644
--- a/drivers/media/v4l2-core/v4l2-device.c
+++ b/drivers/media/v4l2-core/v4l2-device.c
@@ -180,26 +180,26 @@ int v4l2_device_register_subdev(struct v4l2_device *v4l2_dev,
 		return -ENODEV;
 
 	sd->v4l2_dev = v4l2_dev;
-	if (sd->internal_ops && sd->internal_ops->registered) {
-		err = sd->internal_ops->registered(sd);
-		if (err)
-			goto error_module;
-	}
-
 	/* This just returns 0 if either of the two args is NULL */
 	err = v4l2_ctrl_add_handler(v4l2_dev->ctrl_handler, sd->ctrl_handler, NULL);
 	if (err)
-		goto error_unregister;
+		goto error_module;
 
 #if defined(CONFIG_MEDIA_CONTROLLER)
 	/* Register the entity. */
 	if (v4l2_dev->mdev) {
 		err = media_device_register_entity(v4l2_dev->mdev, entity);
 		if (err < 0)
-			goto error_unregister;
+			goto error_module;
 	}
 #endif
 
+	if (sd->internal_ops && sd->internal_ops->registered) {
+		err = sd->internal_ops->registered(sd);
+		if (err)
+			goto error_unregister;
+	}
+
 	spin_lock(&v4l2_dev->lock);
 	list_add_tail(&sd->list, &v4l2_dev->subdevs);
 	spin_unlock(&v4l2_dev->lock);
@@ -207,8 +207,9 @@ int v4l2_device_register_subdev(struct v4l2_device *v4l2_dev,
 	return 0;
 
 error_unregister:
-	if (sd->internal_ops && sd->internal_ops->unregistered)
-		sd->internal_ops->unregistered(sd);
+#if defined(CONFIG_MEDIA_CONTROLLER)
+	media_device_unregister_entity(entity);
+#endif
 error_module:
 	if (!sd->owner_v4l2_dev)
 		module_put(sd->owner);

commit 13f6e8887a1f61764a05a3348476d38071201f08
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Fri Sep 4 15:39:43 2015 -0300

    [media] v4l2 core: enable all interface links at init
    
    Interface links are normally enabled, meaning that the interfaces are
    bound to the entities. So, any ioctl send to the interface are reflected
    at the entities managed by the interface.
    
    However, when a device is used, other interfaces for the same hardware
    could be decoupled from the entities linked to them, because the
    hardware may have some parts busy.
    
    That's for example, what happens when an hybrid TV device is in use.
    If it is streaming analog TV or capturing signals from S-Video/Composite
    connectors, typically the digital part of the hardware can't be used and
    vice-versa.
    
    This is generally due to some internal hardware or firmware limitation,
    that it is not easily mapped via data pipelines.
    
    What the Kernel drivers do internally is that they decouple the hardware
    from the interface. So, all changes, if allowed, are done only at some
    interface cache, but not physically changed at the hardware.
    
    The usage is similar to the usage of the MEDIA_LNK_FL_ENABLED on data
    links. So, let's use the same flag to indicate if either the interface
    to entity link is bound/enabled or not.
    
    Acked-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/v4l2-core/v4l2-device.c b/drivers/media/v4l2-core/v4l2-device.c
index 3c87307e56f0..85f724b53a14 100644
--- a/drivers/media/v4l2-core/v4l2-device.c
+++ b/drivers/media/v4l2-core/v4l2-device.c
@@ -265,7 +265,7 @@ int v4l2_device_register_subdev_nodes(struct v4l2_device *v4l2_dev)
 
 			link = media_create_intf_link(&sd->entity,
 						      &vdev->intf_devnode->intf,
-						      0);
+						      MEDIA_LNK_FL_ENABLED);
 			if (!link)
 				goto clean_up;
 		}

commit d9c21e3e4b459b45e11406b83ebde163181508a1
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Mon Aug 24 08:47:54 2015 -0300

    [media] v4l2-core: create MC interfaces for devnodes
    
    V4L2 device (and subdevice) nodes should create an interface, if the
    Media Controller support is enabled.
    
    Please notice that radio devices should not create an entity, as radio
    input/output is either via wires or via ALSA.
    
    Acked-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/v4l2-core/v4l2-device.c b/drivers/media/v4l2-core/v4l2-device.c
index 7129e438f29e..3c87307e56f0 100644
--- a/drivers/media/v4l2-core/v4l2-device.c
+++ b/drivers/media/v4l2-core/v4l2-device.c
@@ -258,6 +258,17 @@ int v4l2_device_register_subdev_nodes(struct v4l2_device *v4l2_dev)
 #if defined(CONFIG_MEDIA_CONTROLLER)
 		sd->entity.info.dev.major = VIDEO_MAJOR;
 		sd->entity.info.dev.minor = vdev->minor;
+
+		/* Interface is created by __video_register_device() */
+		if (vdev->v4l2_dev->mdev) {
+			struct media_link *link;
+
+			link = media_create_intf_link(&sd->entity,
+						      &vdev->intf_devnode->intf,
+						      0);
+			if (!link)
+				goto clean_up;
+		}
 #endif
 		sd->devnode = vdev;
 	}
@@ -294,7 +305,10 @@ void v4l2_device_unregister_subdev(struct v4l2_subdev *sd)
 
 #if defined(CONFIG_MEDIA_CONTROLLER)
 	if (v4l2_dev->mdev) {
-		media_entity_remove_links(&sd->entity);
+		/*
+		 * No need to explicitly remove links, as both pads and
+		 * links are removed by the function below, in the right order
+		 */
 		media_device_unregister_entity(&sd->entity);
 	}
 #endif

commit 0d51ebd3f41f195e33ed8d9b9d67ed90f6e298ec
Author: Tommi Franttila <tommi.franttila@intel.com>
Date:   Thu Nov 12 07:01:07 2015 -0200

    [media] v4l2-device: Don't unregister ACPI/Device Tree based devices
    
    When a V4L2 sub-device backed by a DT or ACPI based device was removed,
    the device was unregistered as well which certainly was not intentional,
    as the client device would not be re-created by simply reinstating the
    V4L2 sub-device (indeed the device would have to be there first!).
    
    Skip unregistering the device in case it has non-NULL of_node or fwnode.
    
    Signed-off-by: Tommi Franttila <tommi.franttila@intel.com>
    Signed-off-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/v4l2-core/v4l2-device.c b/drivers/media/v4l2-core/v4l2-device.c
index 5b0a30b9252b..7129e438f29e 100644
--- a/drivers/media/v4l2-core/v4l2-device.c
+++ b/drivers/media/v4l2-core/v4l2-device.c
@@ -118,11 +118,20 @@ void v4l2_device_unregister(struct v4l2_device *v4l2_dev)
 		if (sd->flags & V4L2_SUBDEV_FL_IS_I2C) {
 			struct i2c_client *client = v4l2_get_subdevdata(sd);
 
-			/* We need to unregister the i2c client explicitly.
-			   We cannot rely on i2c_del_adapter to always
-			   unregister clients for us, since if the i2c bus
-			   is a platform bus, then it is never deleted. */
-			if (client)
+			/*
+			 * We need to unregister the i2c client
+			 * explicitly. We cannot rely on
+			 * i2c_del_adapter to always unregister
+			 * clients for us, since if the i2c bus is a
+			 * platform bus, then it is never deleted.
+			 *
+			 * Device tree or ACPI based devices must not
+			 * be unregistered as they have not been
+			 * registered by us, and would not be
+			 * re-created by just probing the V4L2 driver.
+			 */
+			if (client &&
+			    !client->dev.of_node && !client->dev.fwnode)
 				i2c_unregister_device(client);
 			continue;
 		}
@@ -131,7 +140,7 @@ void v4l2_device_unregister(struct v4l2_device *v4l2_dev)
 		if (sd->flags & V4L2_SUBDEV_FL_IS_SPI) {
 			struct spi_device *spi = v4l2_get_subdevdata(sd);
 
-			if (spi)
+			if (spi && !spi->dev.of_node && !spi->dev.fwnode)
 				spi_unregister_device(spi);
 			continue;
 		}

commit 5cf6f7f327c95f09be859889be39e78950516556
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Tue Feb 17 05:44:09 2015 -0300

    [media] v4l2-core: remove the old .ioctl BKL replacement
    
    To keep V4L2 drivers that did not yet convert to unlocked_ioctl happy,
    the v4l2 core had a .ioctl file operation that took a V4L2 lock.
    
    The last drivers are now converted to unlocked_ioctl, so all this
    old code can now be removed.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/v4l2-core/v4l2-device.c b/drivers/media/v4l2-core/v4l2-device.c
index 204cc67c84e8..5b0a30b9252b 100644
--- a/drivers/media/v4l2-core/v4l2-device.c
+++ b/drivers/media/v4l2-core/v4l2-device.c
@@ -37,7 +37,6 @@ int v4l2_device_register(struct device *dev, struct v4l2_device *v4l2_dev)
 
 	INIT_LIST_HEAD(&v4l2_dev->subdevs);
 	spin_lock_init(&v4l2_dev->lock);
-	mutex_init(&v4l2_dev->ioctl_lock);
 	v4l2_prio_init(&v4l2_dev->prio);
 	kref_init(&v4l2_dev->ref);
 	get_device(dev);

commit e31a0ba7df6ce21ac4ed58c4182ec12ca8fd78fb
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Fri Jan 2 12:18:23 2015 -0300

    [media] media: Fix DVB devnode representation at media controller
    
    The previous provision for DVB media controller support were to
    define an ID (likely meaning the adapter number) for the DVB
    devnodes.
    
    This is just plain wrong. Just like V4L, DVB devices (and any other
    device node)) are uniquely identified via a (major, minor) tuple.
    
    This is enough to uniquely identify a devnode, no matter what
    API it implements.
    
    So, before we go too far, let's mark the old v4l, fb, dvb and alsa
    "devnode" info as deprecated, and just call it as "dev".
    
    We can latter add fields specific to each API if needed.
    
    As we don't want to break compilation on already existing apps,
    let's just keep the old definitions as-is, adding a note that
    those are deprecated at media-entity.h.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/v4l2-core/v4l2-device.c b/drivers/media/v4l2-core/v4l2-device.c
index 015f92aab44a..204cc67c84e8 100644
--- a/drivers/media/v4l2-core/v4l2-device.c
+++ b/drivers/media/v4l2-core/v4l2-device.c
@@ -248,8 +248,8 @@ int v4l2_device_register_subdev_nodes(struct v4l2_device *v4l2_dev)
 			goto clean_up;
 		}
 #if defined(CONFIG_MEDIA_CONTROLLER)
-		sd->entity.info.v4l.major = VIDEO_MAJOR;
-		sd->entity.info.v4l.minor = vdev->minor;
+		sd->entity.info.dev.major = VIDEO_MAJOR;
+		sd->entity.info.dev.minor = vdev->minor;
 #endif
 		sd->devnode = vdev;
 	}

commit b2a06aecb24329e16edc3108b8192d65ace8da75
Author: Sakari Ailus <sakari.ailus@linux.intel.com>
Date:   Thu Dec 12 09:36:46 2013 -0300

    [media] v4l: Only get module if it's different than the driver for v4l2_dev
    
    When the sub-device is registered, increment the use count of the sub-device
    owner only if it's different from the owner of the driver for the media
    device. This avoids increasing the use count by the module itself and thus
    making it possible to unload it when it's not in use.
    
    Signed-off-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/drivers/media/v4l2-core/v4l2-device.c b/drivers/media/v4l2-core/v4l2-device.c
index 02d1b6327117..015f92aab44a 100644
--- a/drivers/media/v4l2-core/v4l2-device.c
+++ b/drivers/media/v4l2-core/v4l2-device.c
@@ -158,7 +158,17 @@ int v4l2_device_register_subdev(struct v4l2_device *v4l2_dev,
 	/* Warn if we apparently re-register a subdev */
 	WARN_ON(sd->v4l2_dev != NULL);
 
-	if (!try_module_get(sd->owner))
+	/*
+	 * The reason to acquire the module here is to avoid unloading
+	 * a module of sub-device which is registered to a media
+	 * device. To make it possible to unload modules for media
+	 * devices that also register sub-devices, do not
+	 * try_module_get() such sub-device owners.
+	 */
+	sd->owner_v4l2_dev = v4l2_dev->dev && v4l2_dev->dev->driver &&
+		sd->owner == v4l2_dev->dev->driver->owner;
+
+	if (!sd->owner_v4l2_dev && !try_module_get(sd->owner))
 		return -ENODEV;
 
 	sd->v4l2_dev = v4l2_dev;
@@ -192,7 +202,8 @@ int v4l2_device_register_subdev(struct v4l2_device *v4l2_dev,
 	if (sd->internal_ops && sd->internal_ops->unregistered)
 		sd->internal_ops->unregistered(sd);
 error_module:
-	module_put(sd->owner);
+	if (!sd->owner_v4l2_dev)
+		module_put(sd->owner);
 	sd->v4l2_dev = NULL;
 	return err;
 }
@@ -280,6 +291,7 @@ void v4l2_device_unregister_subdev(struct v4l2_subdev *sd)
 	}
 #endif
 	video_unregister_device(sd->devnode);
-	module_put(sd->owner);
+	if (!sd->owner_v4l2_dev)
+		module_put(sd->owner);
 }
 EXPORT_SYMBOL_GPL(v4l2_device_unregister_subdev);

commit 9e882e3bc97c7774b93f3db483d2e75767b5cad1
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Wed Jun 12 06:04:04 2013 -0300

    [media] v4l2-device: check if already unregistered
    
    It was possible to unregister an already unregistered v4l2_device struct.
    Add a check whether that already happened and just return if that was
    the case.
    Also refuse to register a v4l2_device if both the dev and name fields are
    empty. A warning was already produced in that case, but since the name field
    is now used to detect whether or not the v4l2_device was already unregistered
    this particular combination should be rejected.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/v4l2-core/v4l2-device.c b/drivers/media/v4l2-core/v4l2-device.c
index 2dbfebc0ca85..02d1b6327117 100644
--- a/drivers/media/v4l2-core/v4l2-device.c
+++ b/drivers/media/v4l2-core/v4l2-device.c
@@ -44,7 +44,8 @@ int v4l2_device_register(struct device *dev, struct v4l2_device *v4l2_dev)
 	v4l2_dev->dev = dev;
 	if (dev == NULL) {
 		/* If dev == NULL, then name must be filled in by the caller */
-		WARN_ON(!v4l2_dev->name[0]);
+		if (WARN_ON(!v4l2_dev->name[0]))
+			return -EINVAL;
 		return 0;
 	}
 
@@ -105,7 +106,9 @@ void v4l2_device_unregister(struct v4l2_device *v4l2_dev)
 {
 	struct v4l2_subdev *sd, *next;
 
-	if (v4l2_dev == NULL)
+	/* Just return if v4l2_dev is NULL or if it was already
+	 * unregistered before. */
+	if (v4l2_dev == NULL || !v4l2_dev->name[0])
 		return;
 	v4l2_device_disconnect(v4l2_dev);
 
@@ -135,6 +138,8 @@ void v4l2_device_unregister(struct v4l2_device *v4l2_dev)
 		}
 #endif
 	}
+	/* Mark as unregistered, thus preventing duplicate unregistrations */
+	v4l2_dev->name[0] = '\0';
 }
 EXPORT_SYMBOL_GPL(v4l2_device_unregister);
 

commit c2efd3e6e04942aa8206ca26c855eabf67cfdbc0
Author: Sylwester Nawrocki <s.nawrocki@samsung.com>
Date:   Thu May 9 08:29:33 2013 -0300

    [media] V4L: Remove all links of the media entity when unregistering subdev
    
    Remove all links of the subdev's media entity after internal_ops
    'unregistered' call and right before unregistering the entity from
    a media device.
    It is assumed here that an unregistered (orphan) media entity cannot
    have links to other entities registered to a media device.
    It is also assumed the media links should be created/removed with
    the media graph's mutex held.
    The above implies that the caller of v4l2_device_unregister_subdev()
    must not hold the graph's mutex.
    
    Reviewed-by: Andrzej Hajda <a.hajda@samsung.com>
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Acked-by: Sakari Ailus <sakari.ailus@iki.fi>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Sylwester Nawrocki <s.nawrocki@samsung.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/v4l2-core/v4l2-device.c b/drivers/media/v4l2-core/v4l2-device.c
index 8ed5da2170bf..2dbfebc0ca85 100644
--- a/drivers/media/v4l2-core/v4l2-device.c
+++ b/drivers/media/v4l2-core/v4l2-device.c
@@ -269,8 +269,10 @@ void v4l2_device_unregister_subdev(struct v4l2_subdev *sd)
 	sd->v4l2_dev = NULL;
 
 #if defined(CONFIG_MEDIA_CONTROLLER)
-	if (v4l2_dev->mdev)
+	if (v4l2_dev->mdev) {
+		media_entity_remove_links(&sd->entity);
 		media_device_unregister_entity(&sd->entity);
+	}
 #endif
 	video_unregister_device(sd->devnode);
 	module_put(sd->owner);

commit 7b34be71db533f3e0cf93d53cf62d036cdb5418a
Author: Peter Senna Tschudin <peter.senna@gmail.com>
Date:   Sun Jan 20 01:32:56 2013 -0300

    [media] use IS_ENABLED() macro
    
    This patch introduces the use of IS_ENABLED() macro. For example,
    replacing:
     #if defined(CONFIG_I2C) || (defined(CONFIG_I2C_MODULE) && defined(MODULE))
    with:
     #if IS_ENABLED(CONFIG_I2C)
    All changes made by this patch respect the same replacement pattern.
    
    Reported-by: Mauro Carvalho Chehab <mchehab@redhat.com>
    Signed-off-by: Peter Senna Tschudin <peter.senna@gmail.com>
    Acked-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/v4l2-core/v4l2-device.c b/drivers/media/v4l2-core/v4l2-device.c
index 98a7f5e9cb1b..8ed5da2170bf 100644
--- a/drivers/media/v4l2-core/v4l2-device.c
+++ b/drivers/media/v4l2-core/v4l2-device.c
@@ -112,7 +112,7 @@ void v4l2_device_unregister(struct v4l2_device *v4l2_dev)
 	/* Unregister subdevs */
 	list_for_each_entry_safe(sd, next, &v4l2_dev->subdevs, list) {
 		v4l2_device_unregister_subdev(sd);
-#if defined(CONFIG_I2C) || (defined(CONFIG_I2C_MODULE) && defined(MODULE))
+#if IS_ENABLED(CONFIG_I2C)
 		if (sd->flags & V4L2_SUBDEV_FL_IS_I2C) {
 			struct i2c_client *client = v4l2_get_subdevdata(sd);
 

commit 317efce991620adc589b3005b9baed433dcb2a56
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sat Nov 24 21:35:48 2012 -0300

    [media] v4l: Reset subdev v4l2_dev field to NULL if registration fails
    
    When subdev registration fails the subdev v4l2_dev field is left to a
    non-NULL value. Later calls to v4l2_device_unregister_subdev() will
    consider the subdev as registered and will module_put() the subdev
    module without any matching module_get().
    Fix this by setting the subdev v4l2_dev field to NULL in
    v4l2_device_register_subdev() when the function fails.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Cc: stable@vger.kernel.org
    Acked-by: Sylwester Nawrocki <s.nawrocki@samsung.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/v4l2-core/v4l2-device.c b/drivers/media/v4l2-core/v4l2-device.c
index 513969fa695d..98a7f5e9cb1b 100644
--- a/drivers/media/v4l2-core/v4l2-device.c
+++ b/drivers/media/v4l2-core/v4l2-device.c
@@ -159,31 +159,21 @@ int v4l2_device_register_subdev(struct v4l2_device *v4l2_dev,
 	sd->v4l2_dev = v4l2_dev;
 	if (sd->internal_ops && sd->internal_ops->registered) {
 		err = sd->internal_ops->registered(sd);
-		if (err) {
-			module_put(sd->owner);
-			return err;
-		}
+		if (err)
+			goto error_module;
 	}
 
 	/* This just returns 0 if either of the two args is NULL */
 	err = v4l2_ctrl_add_handler(v4l2_dev->ctrl_handler, sd->ctrl_handler, NULL);
-	if (err) {
-		if (sd->internal_ops && sd->internal_ops->unregistered)
-			sd->internal_ops->unregistered(sd);
-		module_put(sd->owner);
-		return err;
-	}
+	if (err)
+		goto error_unregister;
 
 #if defined(CONFIG_MEDIA_CONTROLLER)
 	/* Register the entity. */
 	if (v4l2_dev->mdev) {
 		err = media_device_register_entity(v4l2_dev->mdev, entity);
-		if (err < 0) {
-			if (sd->internal_ops && sd->internal_ops->unregistered)
-				sd->internal_ops->unregistered(sd);
-			module_put(sd->owner);
-			return err;
-		}
+		if (err < 0)
+			goto error_unregister;
 	}
 #endif
 
@@ -192,6 +182,14 @@ int v4l2_device_register_subdev(struct v4l2_device *v4l2_dev,
 	spin_unlock(&v4l2_dev->lock);
 
 	return 0;
+
+error_unregister:
+	if (sd->internal_ops && sd->internal_ops->unregistered)
+		sd->internal_ops->unregistered(sd);
+error_module:
+	module_put(sd->owner);
+	sd->v4l2_dev = NULL;
+	return err;
 }
 EXPORT_SYMBOL_GPL(v4l2_device_register_subdev);
 

commit 34a6b7d093d8fe738ada191b36648d00bc18b7eb
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Fri Sep 14 07:15:03 2012 -0300

    [media] v4l2-ctrls: add a filter function to v4l2_ctrl_add_handler
    
    With a filter function you can control more precisely which controls
    are added. This is useful in particular for radio device nodes for
    combined TV/Radio cards where you want to show just the radio-specific
    controls and not controls like brightness.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/v4l2-core/v4l2-device.c b/drivers/media/v4l2-core/v4l2-device.c
index 1f203b85a637..513969fa695d 100644
--- a/drivers/media/v4l2-core/v4l2-device.c
+++ b/drivers/media/v4l2-core/v4l2-device.c
@@ -166,7 +166,7 @@ int v4l2_device_register_subdev(struct v4l2_device *v4l2_dev,
 	}
 
 	/* This just returns 0 if either of the two args is NULL */
-	err = v4l2_ctrl_add_handler(v4l2_dev->ctrl_handler, sd->ctrl_handler);
+	err = v4l2_ctrl_add_handler(v4l2_dev->ctrl_handler, sd->ctrl_handler, NULL);
 	if (err) {
 		if (sd->internal_ops && sd->internal_ops->unregistered)
 			sd->internal_ops->unregistered(sd);

commit 5bc3cb743bbab408792c1b4ef31adf6268aa4b7e
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Thu Jun 14 16:35:52 2012 -0300

    [media] v4l: move v4l2 core into a separate directory
    
    Currently, the v4l2 core is mixed together with other non-core drivers.
    Move them into a separate directory.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/v4l2-core/v4l2-device.c b/drivers/media/v4l2-core/v4l2-device.c
new file mode 100644
index 000000000000..1f203b85a637
--- /dev/null
+++ b/drivers/media/v4l2-core/v4l2-device.c
@@ -0,0 +1,280 @@
+/*
+    V4L2 device support.
+
+    Copyright (C) 2008  Hans Verkuil <hverkuil@xs4all.nl>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/types.h>
+#include <linux/ioctl.h>
+#include <linux/module.h>
+#include <linux/i2c.h>
+#include <linux/slab.h>
+#if defined(CONFIG_SPI)
+#include <linux/spi/spi.h>
+#endif
+#include <linux/videodev2.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-ctrls.h>
+
+int v4l2_device_register(struct device *dev, struct v4l2_device *v4l2_dev)
+{
+	if (v4l2_dev == NULL)
+		return -EINVAL;
+
+	INIT_LIST_HEAD(&v4l2_dev->subdevs);
+	spin_lock_init(&v4l2_dev->lock);
+	mutex_init(&v4l2_dev->ioctl_lock);
+	v4l2_prio_init(&v4l2_dev->prio);
+	kref_init(&v4l2_dev->ref);
+	get_device(dev);
+	v4l2_dev->dev = dev;
+	if (dev == NULL) {
+		/* If dev == NULL, then name must be filled in by the caller */
+		WARN_ON(!v4l2_dev->name[0]);
+		return 0;
+	}
+
+	/* Set name to driver name + device name if it is empty. */
+	if (!v4l2_dev->name[0])
+		snprintf(v4l2_dev->name, sizeof(v4l2_dev->name), "%s %s",
+			dev->driver->name, dev_name(dev));
+	if (!dev_get_drvdata(dev))
+		dev_set_drvdata(dev, v4l2_dev);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(v4l2_device_register);
+
+static void v4l2_device_release(struct kref *ref)
+{
+	struct v4l2_device *v4l2_dev =
+		container_of(ref, struct v4l2_device, ref);
+
+	if (v4l2_dev->release)
+		v4l2_dev->release(v4l2_dev);
+}
+
+int v4l2_device_put(struct v4l2_device *v4l2_dev)
+{
+	return kref_put(&v4l2_dev->ref, v4l2_device_release);
+}
+EXPORT_SYMBOL_GPL(v4l2_device_put);
+
+int v4l2_device_set_name(struct v4l2_device *v4l2_dev, const char *basename,
+						atomic_t *instance)
+{
+	int num = atomic_inc_return(instance) - 1;
+	int len = strlen(basename);
+
+	if (basename[len - 1] >= '0' && basename[len - 1] <= '9')
+		snprintf(v4l2_dev->name, sizeof(v4l2_dev->name),
+				"%s-%d", basename, num);
+	else
+		snprintf(v4l2_dev->name, sizeof(v4l2_dev->name),
+				"%s%d", basename, num);
+	return num;
+}
+EXPORT_SYMBOL_GPL(v4l2_device_set_name);
+
+void v4l2_device_disconnect(struct v4l2_device *v4l2_dev)
+{
+	if (v4l2_dev->dev == NULL)
+		return;
+
+	if (dev_get_drvdata(v4l2_dev->dev) == v4l2_dev)
+		dev_set_drvdata(v4l2_dev->dev, NULL);
+	put_device(v4l2_dev->dev);
+	v4l2_dev->dev = NULL;
+}
+EXPORT_SYMBOL_GPL(v4l2_device_disconnect);
+
+void v4l2_device_unregister(struct v4l2_device *v4l2_dev)
+{
+	struct v4l2_subdev *sd, *next;
+
+	if (v4l2_dev == NULL)
+		return;
+	v4l2_device_disconnect(v4l2_dev);
+
+	/* Unregister subdevs */
+	list_for_each_entry_safe(sd, next, &v4l2_dev->subdevs, list) {
+		v4l2_device_unregister_subdev(sd);
+#if defined(CONFIG_I2C) || (defined(CONFIG_I2C_MODULE) && defined(MODULE))
+		if (sd->flags & V4L2_SUBDEV_FL_IS_I2C) {
+			struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+			/* We need to unregister the i2c client explicitly.
+			   We cannot rely on i2c_del_adapter to always
+			   unregister clients for us, since if the i2c bus
+			   is a platform bus, then it is never deleted. */
+			if (client)
+				i2c_unregister_device(client);
+			continue;
+		}
+#endif
+#if defined(CONFIG_SPI)
+		if (sd->flags & V4L2_SUBDEV_FL_IS_SPI) {
+			struct spi_device *spi = v4l2_get_subdevdata(sd);
+
+			if (spi)
+				spi_unregister_device(spi);
+			continue;
+		}
+#endif
+	}
+}
+EXPORT_SYMBOL_GPL(v4l2_device_unregister);
+
+int v4l2_device_register_subdev(struct v4l2_device *v4l2_dev,
+				struct v4l2_subdev *sd)
+{
+#if defined(CONFIG_MEDIA_CONTROLLER)
+	struct media_entity *entity = &sd->entity;
+#endif
+	int err;
+
+	/* Check for valid input */
+	if (v4l2_dev == NULL || sd == NULL || !sd->name[0])
+		return -EINVAL;
+
+	/* Warn if we apparently re-register a subdev */
+	WARN_ON(sd->v4l2_dev != NULL);
+
+	if (!try_module_get(sd->owner))
+		return -ENODEV;
+
+	sd->v4l2_dev = v4l2_dev;
+	if (sd->internal_ops && sd->internal_ops->registered) {
+		err = sd->internal_ops->registered(sd);
+		if (err) {
+			module_put(sd->owner);
+			return err;
+		}
+	}
+
+	/* This just returns 0 if either of the two args is NULL */
+	err = v4l2_ctrl_add_handler(v4l2_dev->ctrl_handler, sd->ctrl_handler);
+	if (err) {
+		if (sd->internal_ops && sd->internal_ops->unregistered)
+			sd->internal_ops->unregistered(sd);
+		module_put(sd->owner);
+		return err;
+	}
+
+#if defined(CONFIG_MEDIA_CONTROLLER)
+	/* Register the entity. */
+	if (v4l2_dev->mdev) {
+		err = media_device_register_entity(v4l2_dev->mdev, entity);
+		if (err < 0) {
+			if (sd->internal_ops && sd->internal_ops->unregistered)
+				sd->internal_ops->unregistered(sd);
+			module_put(sd->owner);
+			return err;
+		}
+	}
+#endif
+
+	spin_lock(&v4l2_dev->lock);
+	list_add_tail(&sd->list, &v4l2_dev->subdevs);
+	spin_unlock(&v4l2_dev->lock);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(v4l2_device_register_subdev);
+
+static void v4l2_device_release_subdev_node(struct video_device *vdev)
+{
+	struct v4l2_subdev *sd = video_get_drvdata(vdev);
+	sd->devnode = NULL;
+	kfree(vdev);
+}
+
+int v4l2_device_register_subdev_nodes(struct v4l2_device *v4l2_dev)
+{
+	struct video_device *vdev;
+	struct v4l2_subdev *sd;
+	int err;
+
+	/* Register a device node for every subdev marked with the
+	 * V4L2_SUBDEV_FL_HAS_DEVNODE flag.
+	 */
+	list_for_each_entry(sd, &v4l2_dev->subdevs, list) {
+		if (!(sd->flags & V4L2_SUBDEV_FL_HAS_DEVNODE))
+			continue;
+
+		vdev = kzalloc(sizeof(*vdev), GFP_KERNEL);
+		if (!vdev) {
+			err = -ENOMEM;
+			goto clean_up;
+		}
+
+		video_set_drvdata(vdev, sd);
+		strlcpy(vdev->name, sd->name, sizeof(vdev->name));
+		vdev->v4l2_dev = v4l2_dev;
+		vdev->fops = &v4l2_subdev_fops;
+		vdev->release = v4l2_device_release_subdev_node;
+		vdev->ctrl_handler = sd->ctrl_handler;
+		err = __video_register_device(vdev, VFL_TYPE_SUBDEV, -1, 1,
+					      sd->owner);
+		if (err < 0) {
+			kfree(vdev);
+			goto clean_up;
+		}
+#if defined(CONFIG_MEDIA_CONTROLLER)
+		sd->entity.info.v4l.major = VIDEO_MAJOR;
+		sd->entity.info.v4l.minor = vdev->minor;
+#endif
+		sd->devnode = vdev;
+	}
+	return 0;
+
+clean_up:
+	list_for_each_entry(sd, &v4l2_dev->subdevs, list) {
+		if (!sd->devnode)
+			break;
+		video_unregister_device(sd->devnode);
+	}
+
+	return err;
+}
+EXPORT_SYMBOL_GPL(v4l2_device_register_subdev_nodes);
+
+void v4l2_device_unregister_subdev(struct v4l2_subdev *sd)
+{
+	struct v4l2_device *v4l2_dev;
+
+	/* return if it isn't registered */
+	if (sd == NULL || sd->v4l2_dev == NULL)
+		return;
+
+	v4l2_dev = sd->v4l2_dev;
+
+	spin_lock(&v4l2_dev->lock);
+	list_del(&sd->list);
+	spin_unlock(&v4l2_dev->lock);
+
+	if (sd->internal_ops && sd->internal_ops->unregistered)
+		sd->internal_ops->unregistered(sd);
+	sd->v4l2_dev = NULL;
+
+#if defined(CONFIG_MEDIA_CONTROLLER)
+	if (v4l2_dev->mdev)
+		media_device_unregister_entity(&sd->entity);
+#endif
+	video_unregister_device(sd->devnode);
+	module_put(sd->owner);
+}
+EXPORT_SYMBOL_GPL(v4l2_device_unregister_subdev);
