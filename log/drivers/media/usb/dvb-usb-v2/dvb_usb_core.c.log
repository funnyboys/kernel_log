commit 6f5129e251aeec71f8928ae0668d508454fa8aff
Author: Sean Young <sean@mess.org>
Date:   Sat Aug 31 05:37:39 2019 -0300

    media: rtl28xxu: fix idle handling
    
    Currently the IR receiver is put into idle mode after each interrupt.
    However longer IR like NEC can be distributed over multiple interrupts,
    so putting the IR into idle in the middle of such a message will break
    decoding.
    
    Every IR message has a trailing space of 0xbf (one less than
    IR_IDE_LEN{0,1} which is programmed to 0xc0). So, set the timeout to that
    value and rc-core will put the IR receiver into idle mode automatically.
    
    Thanks to Jan Pieter van Woerkom <jp@jpvw.nl> for providing the hardware.
    
    Signed-off-by: Sean Young <sean@mess.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
index e5e056bf9dfa..f1c79f351ec8 100644
--- a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
+++ b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
@@ -150,6 +150,7 @@ static int dvb_usbv2_remote_init(struct dvb_usb_device *d)
 	dev->map_name = d->rc.map_name;
 	dev->allowed_protocols = d->rc.allowed_protos;
 	dev->change_protocol = d->rc.change_protocol;
+	dev->timeout = d->rc.timeout;
 	dev->priv = d;
 
 	ret = rc_register_device(dev);

commit 16216333235adf51093d0330a934a7e4a03134fe
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 15:51:31 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 1
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      51 franklin street fifth floor boston ma 02110 1301 usa
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option [no]_[pad]_[ctrl] any later version this program is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details you should have received a copy of the gnu general
      public license along with this program if not write to the free
      software foundation inc 51 franklin street fifth floor boston ma
      02110 1301 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 176 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Jilayne Lovejoy <opensource@jilayne.com>
    Reviewed-by: Steve Winslow <swinslow@gmail.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190519154040.652910950@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
index d55ef016d418..e5e056bf9dfa 100644
--- a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
+++ b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
@@ -1,22 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * DVB USB framework
  *
  * Copyright (C) 2004-6 Patrick Boettcher <patrick.boettcher@posteo.de>
  * Copyright (C) 2012 Antti Palosaari <crope@iki.fi>
- *
- *    This program is free software; you can redistribute it and/or modify
- *    it under the terms of the GNU General Public License as published by
- *    the Free Software Foundation; either version 2 of the License, or
- *    (at your option) any later version.
- *
- *    This program is distributed in the hope that it will be useful,
- *    but WITHOUT ANY WARRANTY; without even the implied warranty of
- *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *    GNU General Public License for more details.
- *
- *    You should have received a copy of the GNU General Public License along
- *    with this program; if not, write to the Free Software Foundation, Inc.,
- *    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  */
 
 #include "dvb_usb_common.h"

commit bac26a63f9bff338534610232c2827b877e0b312
Author: Victor Toso <me@victortoso.com>
Date:   Tue Oct 30 12:14:49 2018 -0400

    media: dvb: Use WARM definition from identify_state()
    
    Device should be either COLD or WARM.
    This change only make usage of the existing definition.
    
    Signed-off-by: Victor Toso <me@victortoso.com>
    Signed-off-by: Sean Young <sean@mess.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
index 3b8f7931b730..d55ef016d418 100644
--- a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
+++ b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
@@ -957,9 +957,7 @@ int dvb_usbv2_probe(struct usb_interface *intf,
 	if (d->props->identify_state) {
 		const char *name = NULL;
 		ret = d->props->identify_state(d, &name);
-		if (ret == 0) {
-			;
-		} else if (ret == COLD) {
+		if (ret == COLD) {
 			dev_info(&d->udev->dev,
 					"%s: found a '%s' in cold state\n",
 					KBUILD_MODNAME, d->name);
@@ -984,7 +982,7 @@ int dvb_usbv2_probe(struct usb_interface *intf,
 			} else {
 				goto err_free_all;
 			}
-		} else {
+		} else if (ret != WARM) {
 			goto err_free_all;
 		}
 	}

commit c0decac19da3906d9b66291e57b7759489e1170f
Author: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
Date:   Mon Sep 10 08:19:14 2018 -0400

    media: use strscpy() instead of strlcpy()
    
    The implementation of strscpy() is more robust and safer.
    
    That's now the recommended way to copy NUL terminated strings.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Acked-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
index 955318ab7f5e..3b8f7931b730 100644
--- a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
+++ b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
@@ -74,7 +74,7 @@ static int dvb_usbv2_i2c_init(struct dvb_usb_device *d)
 	if (!d->props->i2c_algo)
 		return 0;
 
-	strlcpy(d->i2c_adap.name, d->name, sizeof(d->i2c_adap.name));
+	strscpy(d->i2c_adap.name, d->name, sizeof(d->i2c_adap.name));
 	d->i2c_adap.algo = d->props->i2c_algo;
 	d->i2c_adap.dev.parent = &d->udev->dev;
 	i2c_set_adapdata(&d->i2c_adap, d);

commit fe63a1a6216749fd9d9c5b52d52b75240f9d20f3
Author: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
Date:   Tue May 8 18:10:05 2018 -0300

    media: dvb: fix location of get_dvb_firmware script
    
    This script was moved out of Documentation/dvb, but the
    links weren't updated.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
    Acked-by: Jonathan Corbet <corbet@lwn.net>

diff --git a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
index afdcdbf005e9..955318ab7f5e 100644
--- a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
+++ b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
@@ -47,7 +47,7 @@ static int dvb_usbv2_download_firmware(struct dvb_usb_device *d,
 	ret = request_firmware(&fw, name, &d->udev->dev);
 	if (ret < 0) {
 		dev_err(&d->udev->dev,
-				"%s: Did not find the firmware file '%s'. Please see linux/Documentation/dvb/ for more details on firmware-problems. Status %d\n",
+				"%s: Did not find the firmware file '%s' (status %d). You can use <kernel_dir>/scripts/get_dvb_firmware to get the firmware\n",
 				KBUILD_MODNAME, name, ret);
 		goto err;
 	}

commit 19324414c954e68921271bfc1f4a235c90a557c6
Author: Antti Palosaari <crope@iki.fi>
Date:   Mon Jul 10 15:35:59 2017 -0400

    media: dvb-usb-v2: add probe/disconnect callbacks
    
    Add probe and disconnect callbacks that behaves similarly than ones
    used commonly on Linux driver model. We need those to get early / late
    access to driver in order to use normal probe time stuff, like regmap,
    extra bus adapters and so.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
index 2bf3bd81280a..afdcdbf005e9 100644
--- a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
+++ b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
@@ -854,8 +854,6 @@ static int dvb_usbv2_exit(struct dvb_usb_device *d)
 	dvb_usbv2_remote_exit(d);
 	dvb_usbv2_adapter_exit(d);
 	dvb_usbv2_i2c_exit(d);
-	kfree(d->priv);
-	kfree(d);
 
 	return 0;
 }
@@ -934,7 +932,7 @@ int dvb_usbv2_probe(struct usb_interface *intf,
 	if (intf->cur_altsetting->desc.bInterfaceNumber !=
 			d->props->bInterfaceNumber) {
 		ret = -ENODEV;
-		goto err_free_all;
+		goto err_kfree_d;
 	}
 
 	mutex_init(&d->usb_mutex);
@@ -946,10 +944,16 @@ int dvb_usbv2_probe(struct usb_interface *intf,
 			dev_err(&d->udev->dev, "%s: kzalloc() failed\n",
 					KBUILD_MODNAME);
 			ret = -ENOMEM;
-			goto err_free_all;
+			goto err_kfree_d;
 		}
 	}
 
+	if (d->props->probe) {
+		ret = d->props->probe(d);
+		if (ret)
+			goto err_kfree_priv;
+	}
+
 	if (d->props->identify_state) {
 		const char *name = NULL;
 		ret = d->props->identify_state(d, &name);
@@ -1001,6 +1005,12 @@ int dvb_usbv2_probe(struct usb_interface *intf,
 	return 0;
 err_free_all:
 	dvb_usbv2_exit(d);
+	if (d->props->disconnect)
+		d->props->disconnect(d);
+err_kfree_priv:
+	kfree(d->priv);
+err_kfree_d:
+	kfree(d);
 err:
 	dev_dbg(&udev->dev, "%s: failed=%d\n", __func__, ret);
 	return ret;
@@ -1021,6 +1031,12 @@ void dvb_usbv2_disconnect(struct usb_interface *intf)
 
 	dvb_usbv2_exit(d);
 
+	if (d->props->disconnect)
+		d->props->disconnect(d);
+
+	kfree(d->priv);
+	kfree(d);
+
 	pr_info("%s: '%s:%s' successfully deinitialized and disconnected\n",
 		KBUILD_MODNAME, drvname, devname);
 	kfree(devname);

commit b4b138a9d31924cb9ab535138deb150d6ec418a5
Author: Gustavo A. R. Silva <garsilva@embeddedor.com>
Date:   Mon Nov 6 09:22:18 2017 -0500

    media: usb: dvb-usb-v2: dvb_usb_core: remove redundant code in dvb_usb_fe_sleep
    
    Check on return value and goto instruction is redundant as the code
    that follows is the goto label err.
    
    Addresses-Coverity-ID: 1268783
    
    Signed-off-by: Gustavo A. R. Silva <garsilva@embeddedor.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
index 096bb75a24e5..2bf3bd81280a 100644
--- a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
+++ b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
@@ -628,8 +628,7 @@ static int dvb_usb_fe_sleep(struct dvb_frontend *fe)
 	}
 
 	ret = dvb_usbv2_device_power_ctrl(d, 0);
-	if (ret < 0)
-		goto err;
+
 err:
 	if (!adap->suspend_resume_active) {
 		adap->active_fe = -1;

commit 518f4b26be1ebf6ce220c4e37b5c7e5410c4d064
Author: Sean Young <sean@mess.org>
Date:   Sat Jul 1 12:13:19 2017 -0400

    media: rc-core: rename input_name to device_name
    
    When an ir-spi is registered, you get this message.
    
    rc rc0: Unspecified device as /devices/platform/soc/3f215080.spi/spi_master/spi32766/spi32766.128/rc/rc0
    
    "Unspecified device" refers to input_name, which makes no sense for IR
    TX only devices. So, rename to device_name.
    
    Also make driver_name const char* so that no casts are needed anywhere.
    
    Now ir-spi reports:
    
    rc rc0: IR SPI as /devices/platform/soc/3f215080.spi/spi_master/spi32766/spi32766.128/rc/rc0
    
    Signed-off-by: Sean Young <sean@mess.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
index 955fb0d07507..096bb75a24e5 100644
--- a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
+++ b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
@@ -154,13 +154,12 @@ static int dvb_usbv2_remote_init(struct dvb_usb_device *d)
 	}
 
 	dev->dev.parent = &d->udev->dev;
-	dev->input_name = d->name;
+	dev->device_name = d->name;
 	usb_make_path(d->udev, d->rc_phys, sizeof(d->rc_phys));
 	strlcat(d->rc_phys, "/ir0", sizeof(d->rc_phys));
 	dev->input_phys = d->rc_phys;
 	usb_to_input_id(d->udev, &dev->input_id);
-	/* TODO: likely RC-core should took const char * */
-	dev->driver_name = (char *) d->props->driver_name;
+	dev->driver_name = d->props->driver_name;
 	dev->map_name = d->rc.map_name;
 	dev->allowed_protocols = d->rc.allowed_protos;
 	dev->change_protocol = d->rc.change_protocol;

commit 005145378c9ad7575a01b6ce1ba118fb427f583a
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu Feb 2 12:36:01 2017 -0200

    [media] dvb-usb-v2: avoid use-after-free
    
    I ran into a stack frame size warning because of the on-stack copy of
    the USB device structure:
    
    drivers/media/usb/dvb-usb-v2/dvb_usb_core.c: In function 'dvb_usbv2_disconnect':
    drivers/media/usb/dvb-usb-v2/dvb_usb_core.c:1029:1: error: the frame size of 1104 bytes is larger than 1024 bytes [-Werror=frame-larger-than=]
    
    Copying a device structure like this is wrong for a number of other reasons
    too aside from the possible stack overflow. One of them is that the
    dev_info() call will print the name of the device later, but AFAICT
    we have only copied a pointer to the name earlier and the actual name
    has been freed by the time it gets printed.
    
    This removes the on-stack copy of the device and instead copies the
    device name using kstrdup(). I'm ignoring the possible failure here
    as both printk() and kfree() are able to deal with NULL pointers.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
index 298c91a6f1f9..955fb0d07507 100644
--- a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
+++ b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
@@ -1012,8 +1012,8 @@ EXPORT_SYMBOL(dvb_usbv2_probe);
 void dvb_usbv2_disconnect(struct usb_interface *intf)
 {
 	struct dvb_usb_device *d = usb_get_intfdata(intf);
-	const char *name = d->name;
-	struct device dev = d->udev->dev;
+	const char *devname = kstrdup(dev_name(&d->udev->dev), GFP_KERNEL);
+	const char *drvname = d->name;
 
 	dev_dbg(&d->udev->dev, "%s: bInterfaceNumber=%d\n", __func__,
 			intf->cur_altsetting->desc.bInterfaceNumber);
@@ -1023,8 +1023,9 @@ void dvb_usbv2_disconnect(struct usb_interface *intf)
 
 	dvb_usbv2_exit(d);
 
-	dev_info(&dev, "%s: '%s' successfully deinitialized and disconnected\n",
-			KBUILD_MODNAME, name);
+	pr_info("%s: '%s:%s' successfully deinitialized and disconnected\n",
+		KBUILD_MODNAME, drvname, devname);
+	kfree(devname);
 }
 EXPORT_SYMBOL(dvb_usbv2_disconnect);
 

commit 0f7499fddb153a333dff3c1dc4280c178b9b5a80
Author: Andi Shyti <andi.shyti@samsung.com>
Date:   Fri Dec 16 06:50:58 2016 -0200

    [media] rc-main: assign driver type during allocation
    
    The driver type can be assigned immediately when an RC device
    requests to the framework to allocate the device.
    
    This is an 'enum rc_driver_type' data type and specifies whether
    the device is a raw receiver or scancode receiver. The type will
    be given as parameter to the rc_allocate_device device.
    
    Change accordingly all the drivers calling rc_allocate_device()
    so that the device type is specified during the rc device
    allocation. Whenever the device type is not specified, it will be
    set as RC_DRIVER_SCANCODE which was the default '0' value.
    
    Suggested-by: Sean Young <sean@mess.org>
    Signed-off-by: Andi Shyti <andi.shyti@samsung.com>
    Signed-off-by: Sean Young <sean@mess.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
index a8e6624fbe83..298c91a6f1f9 100644
--- a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
+++ b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
@@ -147,7 +147,7 @@ static int dvb_usbv2_remote_init(struct dvb_usb_device *d)
 	if (!d->rc.map_name)
 		return 0;
 
-	dev = rc_allocate_device();
+	dev = rc_allocate_device(d->rc.driver_type);
 	if (!dev) {
 		ret = -ENOMEM;
 		goto err;
@@ -162,7 +162,6 @@ static int dvb_usbv2_remote_init(struct dvb_usb_device *d)
 	/* TODO: likely RC-core should took const char * */
 	dev->driver_name = (char *) d->props->driver_name;
 	dev->map_name = d->rc.map_name;
-	dev->driver_type = d->rc.driver_type;
 	dev->allowed_protocols = d->rc.allowed_protos;
 	dev->change_protocol = d->rc.change_protocol;
 	dev->priv = d;

commit 49cd08e699c3fca1262fccd3826c7c17f2292bf1
Author: Wolfram Sang <wsa-dev@sang-engineering.com>
Date:   Tue Aug 9 08:35:16 2016 -0300

    [media] media: usb: dvb-usb-v2: dvb_usb_core: don't print error when adding adapter fails
    
    The core will do this for us now.
    
    Signed-off-by: Wolfram Sang <wsa-dev@sang-engineering.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
index 3fbb2cd19f5e..a8e6624fbe83 100644
--- a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
+++ b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
@@ -82,8 +82,6 @@ static int dvb_usbv2_i2c_init(struct dvb_usb_device *d)
 	ret = i2c_add_adapter(&d->i2c_adap);
 	if (ret < 0) {
 		d->i2c_adap.algo = NULL;
-		dev_err(&d->udev->dev, "%s: i2c_add_adapter() failed=%d\n",
-				KBUILD_MODNAME, ret);
 		goto err;
 	}
 

commit 6cf5dad17e913fce1ccb0c38e199eff15b0f03cc
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Mon Feb 22 12:10:49 2016 -0300

    [media] media_device: move allocation out of media_device_*_init
    
    Right now, media_device_pci_init and media_device_usb_init does
    media_device allocation internaly. That preents its usage when
    the media_device struct is embedded on some other structure.
    
    Move memory allocation outside it, to make it more generic.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
index 58250250a443..3fbb2cd19f5e 100644
--- a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
+++ b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
@@ -408,10 +408,12 @@ static int dvb_usbv2_media_device_init(struct dvb_usb_adapter *adap)
 	struct dvb_usb_device *d = adap_to_d(adap);
 	struct usb_device *udev = d->udev;
 
-	mdev = media_device_usb_init(udev, d->name);
+	mdev = kzalloc(sizeof(*mdev), GFP_KERNEL);
 	if (!mdev)
 		return -ENOMEM;
 
+	media_device_usb_init(mdev, udev, d->name);
+
 	dvb_register_media_controller(&adap->dvb_adap, mdev);
 
 	dev_info(&d->udev->dev, "media controller created\n");

commit 41b44e35ba9b34e50a65c05ecf7642c07bd3e8aa
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Mon Feb 22 11:42:04 2016 -0300

    [media] media-device: move PCI/USB helper functions from v4l2-mc
    
    Those ancillary functions could be called even when compiled
    without V4L2 support, as warned by ktest build robot:
    
    All errors (new ones prefixed by >>):
    
    >> ERROR: "__v4l2_mc_usb_media_device_init" [drivers/media/usb/dvb-usb/dvb-usb.ko] undefined!
    >> ERROR: "__v4l2_mc_usb_media_device_init" [drivers/media/usb/dvb-usb-v2/dvb_usb_v2.ko] undefined!
    >> ERROR: "__v4l2_mc_usb_media_device_init" [drivers/media/usb/au0828/au0828.ko] undefined!
    
    Also, there's nothing there that are specific to V4L2. So, move
    those ancillary functions to MC core.
    
    No functional changes. Just function rename.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
index 4a8769781cea..58250250a443 100644
--- a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
+++ b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
@@ -20,7 +20,7 @@
  */
 
 #include "dvb_usb_common.h"
-#include <media/v4l2-mc.h>
+#include <media/media-device.h>
 
 static int dvb_usbv2_disable_rc_polling;
 module_param_named(disable_rc_polling, dvb_usbv2_disable_rc_polling, int, 0644);
@@ -408,7 +408,7 @@ static int dvb_usbv2_media_device_init(struct dvb_usb_adapter *adap)
 	struct dvb_usb_device *d = adap_to_d(adap);
 	struct usb_device *udev = d->udev;
 
-	mdev = v4l2_mc_usb_media_device_init(udev, d->name);
+	mdev = media_device_usb_init(udev, d->name);
 	if (!mdev)
 		return -ENOMEM;
 

commit 67873d4e751e400149df7ab61ba04cbb4cc0d449
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Thu Feb 11 15:35:07 2016 -0200

    [media] use v4l2_mc_usb_media_device_init() on most USB devices
    
    Except for the usbuvc driver (with has an embedded media_device
    struct on it), the other drivers have a pointer to media_device.
    
    On those drivers, replace their own implementation for the core
    one. That warrants that those subdev drivers will fill the
    media_device info the same way.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
index 5ec159f22399..4a8769781cea 100644
--- a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
+++ b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
@@ -20,6 +20,7 @@
  */
 
 #include "dvb_usb_common.h"
+#include <media/v4l2-mc.h>
 
 static int dvb_usbv2_disable_rc_polling;
 module_param_named(disable_rc_polling, dvb_usbv2_disable_rc_polling, int, 0644);
@@ -407,20 +408,10 @@ static int dvb_usbv2_media_device_init(struct dvb_usb_adapter *adap)
 	struct dvb_usb_device *d = adap_to_d(adap);
 	struct usb_device *udev = d->udev;
 
-	mdev = kzalloc(sizeof(*mdev), GFP_KERNEL);
+	mdev = v4l2_mc_usb_media_device_init(udev, d->name);
 	if (!mdev)
 		return -ENOMEM;
 
-	mdev->dev = &udev->dev;
-	strlcpy(mdev->model, d->name, sizeof(mdev->model));
-	if (udev->serial)
-		strlcpy(mdev->serial, udev->serial, sizeof(mdev->serial));
-	strcpy(mdev->bus_info, udev->devpath);
-	mdev->hw_revision = le16_to_cpu(udev->descriptor.bcdDevice);
-	mdev->driver_version = LINUX_VERSION_CODE;
-
-	media_device_init(mdev);
-
 	dvb_register_media_controller(&adap->dvb_adap, mdev);
 
 	dev_info(&d->udev->dev, "media controller created\n");

commit 99e44da7928d4abb3028258ac3cd23a48495cd61
Author: Patrick Boettcher <patrick.boettcher@posteo.de>
Date:   Sun Jan 24 12:56:58 2016 -0200

    [media] media: change email address
    
    Soon my dibcom.fr/parrot.com-address won't respond anymore.
    Thus I'm replacing it. And, while being at it,
    let's adapt some other (old) email-addresses as well.
    
    Signed-off-by: Patrick Boettcher <patrick.boettcher@posteo.de>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
index f0565bf3673e..5ec159f22399 100644
--- a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
+++ b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
@@ -1,7 +1,7 @@
 /*
  * DVB USB framework
  *
- * Copyright (C) 2004-6 Patrick Boettcher <patrick.boettcher@desy.de>
+ * Copyright (C) 2004-6 Patrick Boettcher <patrick.boettcher@posteo.de>
  * Copyright (C) 2012 Antti Palosaari <crope@iki.fi>
  *
  *    This program is free software; you can redistribute it and/or modify
@@ -1129,7 +1129,7 @@ int dvb_usbv2_reset_resume(struct usb_interface *intf)
 EXPORT_SYMBOL(dvb_usbv2_reset_resume);
 
 MODULE_VERSION("2.0");
-MODULE_AUTHOR("Patrick Boettcher <patrick.boettcher@desy.de>");
+MODULE_AUTHOR("Patrick Boettcher <patrick.boettcher@posteo.de>");
 MODULE_AUTHOR("Antti Palosaari <crope@iki.fi>");
 MODULE_DESCRIPTION("DVB USB common");
 MODULE_LICENSE("GPL");

commit 33c6853347c13b7cf8d11c12714cd855a84bc992
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Tue Dec 29 16:45:21 2015 -0200

    [media] dvb-usb-v2: postpone removal of media_device
    
    We should not remove the media_device until its last usage,
    or we may have use after free troubles.
    
    So, move the per-adapter media_device removal to happen at
    the end of the adapter removal code.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
index e8491f73c0d9..f0565bf3673e 100644
--- a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
+++ b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
@@ -542,7 +542,6 @@ static int dvb_usbv2_adapter_dvb_exit(struct dvb_usb_adapter *adap)
 		adap->demux.dmx.close(&adap->demux.dmx);
 		dvb_dmxdev_release(&adap->dmxdev);
 		dvb_dmx_release(&adap->demux);
-		dvb_usbv2_media_device_unregister(adap);
 		dvb_unregister_adapter(&adap->dvb_adap);
 	}
 
@@ -852,6 +851,7 @@ static int dvb_usbv2_adapter_exit(struct dvb_usb_device *d)
 			dvb_usbv2_adapter_dvb_exit(&d->adapter[i]);
 			dvb_usbv2_adapter_stream_exit(&d->adapter[i]);
 			dvb_usbv2_adapter_frontend_exit(&d->adapter[i]);
+			dvb_usbv2_media_device_unregister(&d->adapter[i]);
 		}
 	}
 

commit 0230d60e4661d9ced6fb0b9a30f182ebdafbba7a
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Tue Dec 29 11:52:23 2015 -0200

    [media] dvbdev: Add RF connector if needed
    
    Several pure digital TV devices have a frontend with the tuner
    integrated on it. Add the RF connector when dvb_create_media_graph()
    is called on such devices.
    
    Tested with siano and dvb_usb_mxl111sf drivers.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
index 0fa2c45917b0..e8491f73c0d9 100644
--- a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
+++ b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
@@ -706,7 +706,7 @@ static int dvb_usbv2_adapter_frontend_init(struct dvb_usb_adapter *adap)
 		}
 	}
 
-	ret = dvb_create_media_graph(&adap->dvb_adap);
+	ret = dvb_create_media_graph(&adap->dvb_adap, true);
 	if (ret < 0)
 		goto err_dvb_unregister_frontend;
 

commit 9f80679511b0544d1ed8c9bc2d80030183e9f1ed
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Mon Dec 28 09:55:49 2015 -0200

    [media] usb: check media device errors
    
    There are now two new warnings:
    
    drivers/media/usb/dvb-usb-v2/dvb_usb_core.c: In function 'dvb_usbv2_media_device_register':
    drivers/media/usb/dvb-usb-v2/dvb_usb_core.c:433:2: warning: ignoring return value of '__media_device_register', declared with attribute warn_unused_result [-Wunused-result]
      media_device_register(adap->dvb_adap.mdev);
      ^
    drivers/media/usb/dvb-usb/dvb-usb-dvb.c: In function 'dvb_usb_media_device_register':
    drivers/media/usb/dvb-usb/dvb-usb-dvb.c:128:2: warning: ignoring return value of '__media_device_register', declared with attribute warn_unused_result [-Wunused-result]
      media_device_register(adap->dvb_adap.mdev);
      ^
    
    Those are because the drivers are not properly checking if the
    media device init and register were succeeded.
    
    Fix it.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
index 7f52bcbd8b0d..0fa2c45917b0 100644
--- a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
+++ b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
@@ -400,7 +400,7 @@ static int dvb_usb_stop_feed(struct dvb_demux_feed *dvbdmxfeed)
 	return ret;
 }
 
-static void dvb_usbv2_media_device_init(struct dvb_usb_adapter *adap)
+static int dvb_usbv2_media_device_init(struct dvb_usb_adapter *adap)
 {
 #ifdef CONFIG_MEDIA_CONTROLLER_DVB
 	struct media_device *mdev;
@@ -409,7 +409,7 @@ static void dvb_usbv2_media_device_init(struct dvb_usb_adapter *adap)
 
 	mdev = kzalloc(sizeof(*mdev), GFP_KERNEL);
 	if (!mdev)
-		return;
+		return -ENOMEM;
 
 	mdev->dev = &udev->dev;
 	strlcpy(mdev->model, d->name, sizeof(mdev->model));
@@ -425,12 +425,15 @@ static void dvb_usbv2_media_device_init(struct dvb_usb_adapter *adap)
 
 	dev_info(&d->udev->dev, "media controller created\n");
 #endif
+	return 0;
 }
 
-static void dvb_usbv2_media_device_register(struct dvb_usb_adapter *adap)
+static int dvb_usbv2_media_device_register(struct dvb_usb_adapter *adap)
 {
 #ifdef CONFIG_MEDIA_CONTROLLER_DVB
-	media_device_register(adap->dvb_adap.mdev);
+	return media_device_register(adap->dvb_adap.mdev);
+#else
+	return 0;
 #endif
 }
 
@@ -466,7 +469,12 @@ static int dvb_usbv2_adapter_dvb_init(struct dvb_usb_adapter *adap)
 
 	adap->dvb_adap.priv = adap;
 
-	dvb_usbv2_media_device_init(adap);
+	ret = dvb_usbv2_media_device_init(adap);
+	if (ret < 0) {
+		dev_dbg(&d->udev->dev, "%s: dvb_usbv2_media_device_init() failed=%d\n",
+				__func__, ret);
+		goto err_dvb_register_mc;
+	}
 
 	if (d->props->read_mac_address) {
 		ret = d->props->read_mac_address(adap,
@@ -517,6 +525,7 @@ static int dvb_usbv2_adapter_dvb_init(struct dvb_usb_adapter *adap)
 	dvb_dmx_release(&adap->demux);
 err_dvb_dmx_init:
 	dvb_usbv2_media_device_unregister(adap);
+err_dvb_register_mc:
 	dvb_unregister_adapter(&adap->dvb_adap);
 err_dvb_register_adapter:
 	adap->dvb_adap.priv = NULL;
@@ -701,9 +710,9 @@ static int dvb_usbv2_adapter_frontend_init(struct dvb_usb_adapter *adap)
 	if (ret < 0)
 		goto err_dvb_unregister_frontend;
 
-	dvb_usbv2_media_device_register(adap);
+	ret = dvb_usbv2_media_device_register(adap);
 
-	return 0;
+	return ret;
 
 err_dvb_unregister_frontend:
 	for (i = count_registered - 1; i >= 0; i--)

commit 9832e155f1ed3030fdfaa19e72c06472dc2ecb1d
Author: Javier Martinez Canillas <javier@osg.samsung.com>
Date:   Fri Dec 11 20:57:08 2015 -0200

    [media] media-device: split media initialization and registration
    
    The media device node is registered and so made visible to user-space
    before entities are registered and links created which means that the
    media graph obtained by user-space could be only partially enumerated
    if that happens too early before all the graph has been created.
    
    To avoid this race condition, split the media init and registration
    in separate functions and only register the media device node when
    all the pending subdevices have been registered, either explicitly
    by the driver or asynchronously using v4l2_async_register_subdev().
    
    The media_device_register() had a check for drivers not filling dev
    and model fields but all drivers in mainline set them and not doing
    it will be a driver bug so change the function return to void and
    add a BUG_ON() for dev being NULL instead.
    
    Also, add a media_device_cleanup() function that will destroy the
    graph_mutex that is initialized in media_device_init().
    
    [mchehab@osg.samsung.com: Fix compilation if !CONFIG_MEDIA_CONTROLLER
     and remove two warnings added by this changeset]
    Suggested-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Signed-off-by: Javier Martinez Canillas <javier@osg.samsung.com>
    Acked-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
index 6d3f61f6dc77..7f52bcbd8b0d 100644
--- a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
+++ b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
@@ -400,13 +400,12 @@ static int dvb_usb_stop_feed(struct dvb_demux_feed *dvbdmxfeed)
 	return ret;
 }
 
-static void dvb_usbv2_media_device_register(struct dvb_usb_adapter *adap)
+static void dvb_usbv2_media_device_init(struct dvb_usb_adapter *adap)
 {
 #ifdef CONFIG_MEDIA_CONTROLLER_DVB
 	struct media_device *mdev;
 	struct dvb_usb_device *d = adap_to_d(adap);
 	struct usb_device *udev = d->udev;
-	int ret;
 
 	mdev = kzalloc(sizeof(*mdev), GFP_KERNEL);
 	if (!mdev)
@@ -420,19 +419,18 @@ static void dvb_usbv2_media_device_register(struct dvb_usb_adapter *adap)
 	mdev->hw_revision = le16_to_cpu(udev->descriptor.bcdDevice);
 	mdev->driver_version = LINUX_VERSION_CODE;
 
-	ret = media_device_register(mdev);
-	if (ret) {
-		dev_err(&d->udev->dev,
-			"Couldn't create a media device. Error: %d\n",
-			ret);
-		kfree(mdev);
-		return;
-	}
+	media_device_init(mdev);
 
 	dvb_register_media_controller(&adap->dvb_adap, mdev);
 
 	dev_info(&d->udev->dev, "media controller created\n");
+#endif
+}
 
+static void dvb_usbv2_media_device_register(struct dvb_usb_adapter *adap)
+{
+#ifdef CONFIG_MEDIA_CONTROLLER_DVB
+	media_device_register(adap->dvb_adap.mdev);
 #endif
 }
 
@@ -444,6 +442,7 @@ static void dvb_usbv2_media_device_unregister(struct dvb_usb_adapter *adap)
 		return;
 
 	media_device_unregister(adap->dvb_adap.mdev);
+	media_device_cleanup(adap->dvb_adap.mdev);
 	kfree(adap->dvb_adap.mdev);
 	adap->dvb_adap.mdev = NULL;
 
@@ -467,7 +466,7 @@ static int dvb_usbv2_adapter_dvb_init(struct dvb_usb_adapter *adap)
 
 	adap->dvb_adap.priv = adap;
 
-	dvb_usbv2_media_device_register(adap);
+	dvb_usbv2_media_device_init(adap);
 
 	if (d->props->read_mac_address) {
 		ret = d->props->read_mac_address(adap,
@@ -702,6 +701,8 @@ static int dvb_usbv2_adapter_frontend_init(struct dvb_usb_adapter *adap)
 	if (ret < 0)
 		goto err_dvb_unregister_frontend;
 
+	dvb_usbv2_media_device_register(adap);
+
 	return 0;
 
 err_dvb_unregister_frontend:

commit 0d3ab8410dcb60aef2104231ba817037b3ba73bd
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Fri Sep 4 15:33:46 2015 -0300

    [media] dvb core: must check dvb_create_media_graph()
    
    If media controller is enabled and mdev is filled, it should
    ensure that the media graph will be properly initialized.
    
    Enforce that.
    
    Acked-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
index f5df9eaba04f..6d3f61f6dc77 100644
--- a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
+++ b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
@@ -698,7 +698,9 @@ static int dvb_usbv2_adapter_frontend_init(struct dvb_usb_adapter *adap)
 		}
 	}
 
-	dvb_create_media_graph(&adap->dvb_adap);
+	ret = dvb_create_media_graph(&adap->dvb_adap);
+	if (ret < 0)
+		goto err_dvb_unregister_frontend;
 
 	return 0;
 

commit 89a2c1d60aa2cfcf4c9f194b4c923d72182be431
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Mon Mar 2 11:26:14 2015 -0300

    [media] use a function for DVB media controller register
    
    This is really a simple function, but using it avoids to have
    if's inside the drivers.
    
    Also, the kABI becomes a little more clearer.
    
    This shouldn't generate any overhead, and the type check
    will happen when compiling with MC DVB enabled.
    
    So, let's do it.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
index 8bd08ba4f869..f5df9eaba04f 100644
--- a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
+++ b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
@@ -429,7 +429,7 @@ static void dvb_usbv2_media_device_register(struct dvb_usb_adapter *adap)
 		return;
 	}
 
-	adap->dvb_adap.mdev = mdev;
+	dvb_register_media_controller(&adap->dvb_adap, mdev);
 
 	dev_info(&d->udev->dev, "media controller created\n");
 

commit 872b9dbedd4040f4511c909a09d39330624f057b
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Mon Mar 2 10:53:46 2015 -0300

    [media] dvb: Avoid warnings when compiled without the media controller
    
    drivers/media/usb/dvb-usb-v2/dvb_usb_core.c: In function ‘dvb_usbv2_adapter_dvb_exit’:
    drivers/media/usb/dvb-usb-v2/dvb_usb_core.c:531:25: warning: unused variable ‘d’ [-Wunused-variable]
      struct dvb_usb_device *d = adap_to_d(adap);
                             ^
    drivers/media/usb/dvb-usb-v2/dvb_usb_core.c:403:13: warning: ‘dvb_usbv2_media_device_register’ defined but not used [-Wunused-function]
     static void dvb_usbv2_media_device_register(struct dvb_usb_adapter *adap)
    
    drivers/media/usb/dvb-usb/dvb-usb-dvb.c:97:13: warning: ‘dvb_usb_media_device_register’ defined but not used [-Wunused-function]
     static void dvb_usb_media_device_register(struct dvb_usb_adapter *adap)
                 ^
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
index 08a3cd1c8b44..8bd08ba4f869 100644
--- a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
+++ b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
@@ -467,9 +467,7 @@ static int dvb_usbv2_adapter_dvb_init(struct dvb_usb_adapter *adap)
 
 	adap->dvb_adap.priv = adap;
 
-#ifdef CONFIG_MEDIA_CONTROLLER_DVB
 	dvb_usbv2_media_device_register(adap);
-#endif
 
 	if (d->props->read_mac_address) {
 		ret = d->props->read_mac_address(adap,
@@ -528,8 +526,6 @@ static int dvb_usbv2_adapter_dvb_init(struct dvb_usb_adapter *adap)
 
 static int dvb_usbv2_adapter_dvb_exit(struct dvb_usb_adapter *adap)
 {
-	struct dvb_usb_device *d = adap_to_d(adap);
-
 	dev_dbg(&adap_to_d(adap)->udev->dev, "%s: adap=%d\n", __func__,
 			adap->id);
 

commit 480884b647c7efecb904a9ed022ee533afb9cb80
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Mon Mar 2 10:49:04 2015 -0300

    [media] dvbdev: use adapter arg for dvb_create_media_graph()
    
    Instead of using media_dev argument for dvb_create_media_graph(),
    use the adapter.
    
    That allows to create a stub for this function, if compiled
    without DVB support, avoiding to add extra if's at the drivers.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
index 0666c8f33ac7..08a3cd1c8b44 100644
--- a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
+++ b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
@@ -702,7 +702,7 @@ static int dvb_usbv2_adapter_frontend_init(struct dvb_usb_adapter *adap)
 		}
 	}
 
-	dvb_create_media_graph(adap->dvb_adap.mdev);
+	dvb_create_media_graph(&adap->dvb_adap);
 
 	return 0;
 

commit 823b460ee76d0e4e1a9d50e7c1d4aebc0e9e467b
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Wed Feb 25 14:07:42 2015 -0300

    [media] dvb-usb-v2: create one media_dev per adapter
    
    Instead of assuming just one adapter, change the code to store
    one media controller per adapter.
    
    This works fine for dvb-usb, as, on all drivers here, it is not
    possible to write a media graph that would mix resources between
    the two different adapters.
    
    Acked-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
index 94a7f6390f46..0666c8f33ac7 100644
--- a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
+++ b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
@@ -400,11 +400,11 @@ static int dvb_usb_stop_feed(struct dvb_demux_feed *dvbdmxfeed)
 	return ret;
 }
 
-static void dvb_usbv2_media_device_register(struct dvb_usb_device *d)
+static void dvb_usbv2_media_device_register(struct dvb_usb_adapter *adap)
 {
 #ifdef CONFIG_MEDIA_CONTROLLER_DVB
-
 	struct media_device *mdev;
+	struct dvb_usb_device *d = adap_to_d(adap);
 	struct usb_device *udev = d->udev;
 	int ret;
 
@@ -429,22 +429,23 @@ static void dvb_usbv2_media_device_register(struct dvb_usb_device *d)
 		return;
 	}
 
-	d->media_dev = mdev;
+	adap->dvb_adap.mdev = mdev;
 
 	dev_info(&d->udev->dev, "media controller created\n");
 
 #endif
 }
 
-static void dvb_usbv2_media_device_unregister(struct dvb_usb_device *d)
+static void dvb_usbv2_media_device_unregister(struct dvb_usb_adapter *adap)
 {
 #ifdef CONFIG_MEDIA_CONTROLLER_DVB
-	if (!d->media_dev)
+
+	if (!adap->dvb_adap.mdev)
 		return;
 
-	media_device_unregister(d->media_dev);
-	kfree(d->media_dev);
-	d->media_dev = NULL;
+	media_device_unregister(adap->dvb_adap.mdev);
+	kfree(adap->dvb_adap.mdev);
+	adap->dvb_adap.mdev = NULL;
 
 #endif
 }
@@ -453,6 +454,7 @@ static int dvb_usbv2_adapter_dvb_init(struct dvb_usb_adapter *adap)
 {
 	int ret;
 	struct dvb_usb_device *d = adap_to_d(adap);
+
 	dev_dbg(&d->udev->dev, "%s: adap=%d\n", __func__, adap->id);
 
 	ret = dvb_register_adapter(&adap->dvb_adap, d->name, d->props->owner,
@@ -466,8 +468,7 @@ static int dvb_usbv2_adapter_dvb_init(struct dvb_usb_adapter *adap)
 	adap->dvb_adap.priv = adap;
 
 #ifdef CONFIG_MEDIA_CONTROLLER_DVB
-	dvb_usbv2_media_device_register(d);
-	adap->dvb_adap.mdev = d->media_dev;
+	dvb_usbv2_media_device_register(adap);
 #endif
 
 	if (d->props->read_mac_address) {
@@ -518,7 +519,7 @@ static int dvb_usbv2_adapter_dvb_init(struct dvb_usb_adapter *adap)
 err_dvb_dmxdev_init:
 	dvb_dmx_release(&adap->demux);
 err_dvb_dmx_init:
-	dvb_usbv2_media_device_unregister(d);
+	dvb_usbv2_media_device_unregister(adap);
 	dvb_unregister_adapter(&adap->dvb_adap);
 err_dvb_register_adapter:
 	adap->dvb_adap.priv = NULL;
@@ -537,7 +538,7 @@ static int dvb_usbv2_adapter_dvb_exit(struct dvb_usb_adapter *adap)
 		adap->demux.dmx.close(&adap->demux.dmx);
 		dvb_dmxdev_release(&adap->dmxdev);
 		dvb_dmx_release(&adap->demux);
-		dvb_usbv2_media_device_unregister(d);
+		dvb_usbv2_media_device_unregister(adap);
 		dvb_unregister_adapter(&adap->dvb_adap);
 	}
 
@@ -701,7 +702,7 @@ static int dvb_usbv2_adapter_frontend_init(struct dvb_usb_adapter *adap)
 		}
 	}
 
-	dvb_create_media_graph(d->media_dev);
+	dvb_create_media_graph(adap->dvb_adap.mdev);
 
 	return 0;
 

commit 6f6c77d8d2e2fc77395d6bb9ed670161f18b6bd4
Author: Rafael Lourenço de Lima Chehab <chehabrafael@gmail.com>
Date:   Thu Feb 12 08:37:25 2015 -0300

    [media] dvb-usb-v2: add support for the media controller at USB driver
    
    Create a struct media_device and add it to the dvb adapter.
    
    Please notice that the tuner is not mapped yet by the dvb core.
    
    [mchehab@osg.samsung.com: use config option MEDIA_CONTROLLER_DVB due to a rebase]
    Signed-off-by: Rafael Lourenço de Lima Chehab <chehabrafael@gmail.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
index 9913e0f59485..94a7f6390f46 100644
--- a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
+++ b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
@@ -400,6 +400,55 @@ static int dvb_usb_stop_feed(struct dvb_demux_feed *dvbdmxfeed)
 	return ret;
 }
 
+static void dvb_usbv2_media_device_register(struct dvb_usb_device *d)
+{
+#ifdef CONFIG_MEDIA_CONTROLLER_DVB
+
+	struct media_device *mdev;
+	struct usb_device *udev = d->udev;
+	int ret;
+
+	mdev = kzalloc(sizeof(*mdev), GFP_KERNEL);
+	if (!mdev)
+		return;
+
+	mdev->dev = &udev->dev;
+	strlcpy(mdev->model, d->name, sizeof(mdev->model));
+	if (udev->serial)
+		strlcpy(mdev->serial, udev->serial, sizeof(mdev->serial));
+	strcpy(mdev->bus_info, udev->devpath);
+	mdev->hw_revision = le16_to_cpu(udev->descriptor.bcdDevice);
+	mdev->driver_version = LINUX_VERSION_CODE;
+
+	ret = media_device_register(mdev);
+	if (ret) {
+		dev_err(&d->udev->dev,
+			"Couldn't create a media device. Error: %d\n",
+			ret);
+		kfree(mdev);
+		return;
+	}
+
+	d->media_dev = mdev;
+
+	dev_info(&d->udev->dev, "media controller created\n");
+
+#endif
+}
+
+static void dvb_usbv2_media_device_unregister(struct dvb_usb_device *d)
+{
+#ifdef CONFIG_MEDIA_CONTROLLER_DVB
+	if (!d->media_dev)
+		return;
+
+	media_device_unregister(d->media_dev);
+	kfree(d->media_dev);
+	d->media_dev = NULL;
+
+#endif
+}
+
 static int dvb_usbv2_adapter_dvb_init(struct dvb_usb_adapter *adap)
 {
 	int ret;
@@ -416,6 +465,11 @@ static int dvb_usbv2_adapter_dvb_init(struct dvb_usb_adapter *adap)
 
 	adap->dvb_adap.priv = adap;
 
+#ifdef CONFIG_MEDIA_CONTROLLER_DVB
+	dvb_usbv2_media_device_register(d);
+	adap->dvb_adap.mdev = d->media_dev;
+#endif
+
 	if (d->props->read_mac_address) {
 		ret = d->props->read_mac_address(adap,
 				adap->dvb_adap.proposed_mac);
@@ -464,6 +518,7 @@ static int dvb_usbv2_adapter_dvb_init(struct dvb_usb_adapter *adap)
 err_dvb_dmxdev_init:
 	dvb_dmx_release(&adap->demux);
 err_dvb_dmx_init:
+	dvb_usbv2_media_device_unregister(d);
 	dvb_unregister_adapter(&adap->dvb_adap);
 err_dvb_register_adapter:
 	adap->dvb_adap.priv = NULL;
@@ -472,6 +527,8 @@ static int dvb_usbv2_adapter_dvb_init(struct dvb_usb_adapter *adap)
 
 static int dvb_usbv2_adapter_dvb_exit(struct dvb_usb_adapter *adap)
 {
+	struct dvb_usb_device *d = adap_to_d(adap);
+
 	dev_dbg(&adap_to_d(adap)->udev->dev, "%s: adap=%d\n", __func__,
 			adap->id);
 
@@ -480,6 +537,7 @@ static int dvb_usbv2_adapter_dvb_exit(struct dvb_usb_adapter *adap)
 		adap->demux.dmx.close(&adap->demux.dmx);
 		dvb_dmxdev_release(&adap->dmxdev);
 		dvb_dmx_release(&adap->demux);
+		dvb_usbv2_media_device_unregister(d);
 		dvb_unregister_adapter(&adap->dvb_adap);
 	}
 
@@ -643,6 +701,8 @@ static int dvb_usbv2_adapter_frontend_init(struct dvb_usb_adapter *adap)
 		}
 	}
 
+	dvb_create_media_graph(d->media_dev);
+
 	return 0;
 
 err_dvb_unregister_frontend:
@@ -955,6 +1015,7 @@ void dvb_usbv2_disconnect(struct usb_interface *intf)
 	struct dvb_usb_device *d = usb_get_intfdata(intf);
 	const char *name = d->name;
 	struct device dev = d->udev->dev;
+
 	dev_dbg(&d->udev->dev, "%s: bInterfaceNumber=%d\n", __func__,
 			intf->cur_altsetting->desc.bInterfaceNumber);
 

commit ac5361a8c8ab29d2a6d849fed05326304e9d1ef8
Author: Antti Palosaari <crope@iki.fi>
Date:   Wed Dec 17 08:10:49 2014 -0300

    [media] dvb-usb-v2: add pointer to 'struct usb_interface' for driver usage
    
    Top level pointer on USB probe is struct usb_interface *. Add that
    pointer to struct dvb_usb_device that drivers could use it, for
    dev_* logging and more.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
index 1950f37df835..9913e0f59485 100644
--- a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
+++ b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
@@ -868,6 +868,7 @@ int dvb_usbv2_probe(struct usb_interface *intf,
 		goto err;
 	}
 
+	d->intf = intf;
 	d->name = driver_info->name;
 	d->rc_map = driver_info->rc_map;
 	d->udev = udev;

commit 1066d77f682e84efb56fbd4e5c8bb236532eccc7
Author: Antti Palosaari <crope@iki.fi>
Date:   Thu Sep 4 18:31:40 2014 -0300

    [media] dvb-usb-v2: add tuner_detach callback
    
    Add tuner_detach callback in order to allow custom detach. It is
    needed when tuner driver is implemented I2C client or some other
    kernel bus, but not proprietary dvb_attach / dvb_detach.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
index 02c43b52c906..1950f37df835 100644
--- a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
+++ b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
@@ -676,6 +676,14 @@ static int dvb_usbv2_adapter_frontend_exit(struct dvb_usb_adapter *adap)
 		}
 	}
 
+	if (d->props->tuner_detach) {
+		ret = d->props->tuner_detach(adap);
+		if (ret < 0) {
+			dev_dbg(&d->udev->dev, "%s: tuner_detach() failed=%d\n",
+					__func__, ret);
+		}
+	}
+
 	if (d->props->frontend_detach) {
 		ret = d->props->frontend_detach(adap);
 		if (ret < 0) {

commit ca42129f867fbc427d709408b3ae35988cc08ed4
Author: Antti Palosaari <crope@iki.fi>
Date:   Thu Sep 4 17:04:44 2014 -0300

    [media] dvb-usb-v2: add frontend_detach callback
    
    Add frontend_detach callback in order to allow custom detach. It is
    needed when demod driver is implemented I2C client or some other
    kernel bus, but not proprietary dvb_attach / dvb_detach.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
index adca05f27fba..02c43b52c906 100644
--- a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
+++ b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
@@ -664,9 +664,10 @@ static int dvb_usbv2_adapter_frontend_init(struct dvb_usb_adapter *adap)
 
 static int dvb_usbv2_adapter_frontend_exit(struct dvb_usb_adapter *adap)
 {
-	int i;
-	dev_dbg(&adap_to_d(adap)->udev->dev, "%s: adap=%d\n", __func__,
-			adap->id);
+	int ret, i;
+	struct dvb_usb_device *d = adap_to_d(adap);
+
+	dev_dbg(&d->udev->dev, "%s: adap=%d\n", __func__, adap->id);
 
 	for (i = MAX_NO_OF_FE_PER_ADAP - 1; i >= 0; i--) {
 		if (adap->fe[i]) {
@@ -675,6 +676,15 @@ static int dvb_usbv2_adapter_frontend_exit(struct dvb_usb_adapter *adap)
 		}
 	}
 
+	if (d->props->frontend_detach) {
+		ret = d->props->frontend_detach(adap);
+		if (ret < 0) {
+			dev_dbg(&d->udev->dev,
+					"%s: frontend_detach() failed=%d\n",
+					__func__, ret);
+		}
+	}
+
 	return 0;
 }
 

commit 6812667381d4e7d1baa93464af6fd02175db96de
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Wed Aug 20 19:26:47 2014 -0300

    [media] dvb_usb_core: fix sparse warning
    
    drivers/media/usb/dvb-usb-v2/dvb_usb_core.c:24:5: warning: symbol 'dvb_usbv2_disable_rc_polling' was not declared. Should it be static?
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
index 6c33d8525454..adca05f27fba 100644
--- a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
+++ b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
@@ -21,7 +21,7 @@
 
 #include "dvb_usb_common.h"
 
-int dvb_usbv2_disable_rc_polling;
+static int dvb_usbv2_disable_rc_polling;
 module_param_named(disable_rc_polling, dvb_usbv2_disable_rc_polling, int, 0644);
 MODULE_PARM_DESC(disable_rc_polling,
 		"disable remote control polling (default: 0)");

commit 7a0af6ed97f2f08baecb452e719d9c961d117109
Author: Changbing Xiong <cb.xiong@samsung.com>
Date:   Wed Aug 20 23:04:25 2014 -0300

    [media] media: fix kernel deadlock due to tuner pull-out while playing
    
    Normally, ADAP_STREAMING bit is set in dvb_usb_start_feed and cleared in
    dvb_usb_stop_feed.
    
    But in exceptional cases, for example, when the tv is playing programs
    and the tuner is pulled out, then dvb_usbv2_disconnect is called.
    
    In such case, it will first call dvb_usbv2_adapter_frontend_exit to stop
    dvb_frontend_thread, and then call dvb_usbv2_adapter_dvb_exit to clear
    ADAP_STREAMING bit.
    
    At this point, if dvb_frontend_thread is sleeping and waiting for
    ADAP_STREAMING to be cleared to get out of sleep. then
    dvb_frontend_thread can never be stoped, because clearing ADAP_STREAMING
    bit is performed after dvb_frontend_thread is stopped (i.e. performed in
    dvb_usbv2_adapter_dvb_exit).
    
    So, deadlock:
    
    [  240.822037] INFO: task khubd:497 blocked for more than 120 seconds.
    [  240.822655] "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
    [  240.830493] khubd           D c0013b3c     0   497      2 0x00000000
    [  240.836996] [<c0013b3c>] (__schedule+0x200/0x54c) from [<c00110f4>] (schedule_timeout+0x14c/0x19c)
    [  240.845940] [<c00110f4>] (schedule_timeout+0x14c/0x19c) from [<c00137f4>] (wait_for_common+0xac/0x150)
    [  240.855234] [<c00137f4>] (wait_for_common+0xac/0x150) from [<c004989c>] (kthread_stop+0x58/0x90)
    [  240.864004] [<c004989c>] (kthread_stop+0x58/0x90) from [<c03b2ebc>] (dvb_frontend_stop+0x3c/0x9c)
    [  240.872849] [<c03b2ebc>] (dvb_frontend_stop+0x3c/0x9c) from [<c03b2f3c>] (dvb_unregister_frontend+0x20/0xd8)
    [  240.882666] [<c03b2f3c>] (dvb_unregister_frontend+0x20/0xd8) from [<c03ed938>] (dvb_usbv2_exit+0x68/0xfc)
    [  240.892204] [<c03ed938>] (dvb_usbv2_exit+0x68/0xfc) from [<c03eda18>] (dvb_usbv2_disconnect+0x4c/0x70)
    [  240.901499] [<c03eda18>] (dvb_usbv2_disconnect+0x4c/0x70) from [<c031c050>] (usb_unbind_interface+0x58/0x188)
    [  240.911395] [<c031c050>] (usb_unbind_interface+0x58/0x188) from [<c02c3e78>] (__device_release_driver+0x74/0xd0)
    [  240.921544] [<c02c3e78>] (__device_release_driver+0x74/0xd0) from [<c02c3ef0>] (device_release_driver+0x1c/0x28)
    [  240.931697] [<c02c3ef0>] (device_release_driver+0x1c/0x28) from [<c02c39b8>] (bus_remove_device+0xc4/0xe4)
    [  240.941332] [<c02c39b8>] (bus_remove_device+0xc4/0xe4) from [<c02c1344>] (device_del+0xf4/0x178)
    [  240.950106] [<c02c1344>] (device_del+0xf4/0x178) from [<c0319eb0>] (usb_disable_device+0xa0/0x1c8)
    [  240.959040] [<c0319eb0>] (usb_disable_device+0xa0/0x1c8) from [<c03128b4>] (usb_disconnect+0x88/0x188)
    [  240.968326] [<c03128b4>] (usb_disconnect+0x88/0x188) from [<c0313edc>] (hub_thread+0x4d0/0x1200)
    [  240.977100] [<c0313edc>] (hub_thread+0x4d0/0x1200) from [<c0049690>] (kthread+0xa4/0xb0)
    [  240.985174] [<c0049690>] (kthread+0xa4/0xb0) from [<c0009118>] (ret_from_fork+0x14/0x3c)
    [  240.993259] INFO: task kdvb-ad-0-fe-0:3256 blocked for more than 120 seconds.
    [  241.000349] "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
    [  241.008162] kdvb-ad-0-fe-0  D c0013b3c     0  3256      2 0x00000000
    [  241.014507] [<c0013b3c>] (__schedule+0x200/0x54c) from [<c03eda44>] (wait_schedule+0x8/0x10)
    [  241.022924] [<c03eda44>] (wait_schedule+0x8/0x10) from [<c001120c>] (__wait_on_bit+0x74/0xb8)
    [  241.031434] [<c001120c>] (__wait_on_bit+0x74/0xb8) from [<c00112b8>] (out_of_line_wait_on_bit+0x68/0x70)
    [  241.040902] [<c00112b8>] (out_of_line_wait_on_bit+0x68/0x70) from [<c03e5e88>] (dvb_usb_fe_sleep+0xf4/0xfc)
    [  241.050618] [<c03e5e88>] (dvb_usb_fe_sleep+0xf4/0xfc) from [<c03b4b74>] (dvb_frontend_thread+0x124/0x4e8)
    [  241.060164] [<c03b4b74>] (dvb_frontend_thread+0x124/0x4e8) from [<c0049690>] (kthread+0xa4/0xb0)
    [  241.068929] [<c0049690>] (kthread+0xa4/0xb0) from [<c0009118>] (ret_from_fork+0x14/0x3c)
    
    Fix it by calling dvb_usbv2_adapter_frontend_exit() latter.
    
    Test enviroment: odroidx2 + Hauppauge(WinTV-Aero-M)
    
    Signed-off-by: Changbing Xiong <cb.xiong@samsung.com>
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
index 2e90310be2af..6c33d8525454 100644
--- a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
+++ b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
@@ -762,9 +762,9 @@ static int dvb_usbv2_adapter_exit(struct dvb_usb_device *d)
 
 	for (i = MAX_NO_OF_ADAPTER_PER_DEVICE - 1; i >= 0; i--) {
 		if (d->adapter[i].props) {
-			dvb_usbv2_adapter_frontend_exit(&d->adapter[i]);
 			dvb_usbv2_adapter_dvb_exit(&d->adapter[i]);
 			dvb_usbv2_adapter_stream_exit(&d->adapter[i]);
+			dvb_usbv2_adapter_frontend_exit(&d->adapter[i]);
 		}
 	}
 

commit f4d33337eac4007793ca11fd1ab68d91ce7aa762
Merge: 91c2ff7708d4 0f3bf3dc1ca3
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Aug 5 16:36:30 2014 -0700

    Merge branch 'v4l_for_linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mchehab/linux-media
    
    Pull media updates from Mauro Carvalho Chehab:
     - removal of sn9c102.  This device driver was replaced a long time ago
       by gspca
     - solo6x10 and go7007 webcam drivers moved from staging into
       mainstream.  They were waiting for an API to allow setting the image
       detection matrix
     - SDR drivers moved from staging into mainstream: sdr-msi3101 (renamed
       as msi2500) and rtl2832
     - added SDR driver for airspy
     - added demux driver: si2165
     - rework at several RC subsystem, making the code for RC-5 SZ variant
       to be added at the standard RC5 decoder
     - added decoder for the XMP IR protocol
     - tuner driver moved from staging into mainstream: msi3101 (renamed as
       msi001)
     - added documentation for some additional SDR pixfmt
     - some device tree bindings documented
     - added support for exynos3250 at s5p-jpeg
     - remove the obsolete, unmaintained and broken mx1_camera driver
     - added support for remote controllers at au0828 driver
     - added a RC driver: sunxi-cir
     - several driver fixes, enhancements and cleanups.
    
    * 'v4l_for_linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mchehab/linux-media: (455 commits)
      [media] cx23885: fix UNSET/TUNER_ABSENT confusion
      [media] coda: fix build error by making reset control optional
      [media] radio-miropcm20: fix sparse NULL pointer warning
      [media] MAINTAINERS: Update go7007 pattern
      [media] MAINTAINERS: Update solo6x10 patterns
      [media] media: atmel-isi: add primary DT support
      [media] media: atmel-isi: convert the pdata from pointer to structure
      [media] media: atmel-isi: add v4l2 async probe support
      [media] rcar_vin: add devicetree support
      [media] media: pxa_camera device-tree support
      [media] media: mt9m111: add device-tree suppport
      [media] soc_camera: add support for dt binding soc_camera drivers
      [media] media: soc_camera: pxa_camera documentation device-tree support
      [media] media: mt9m111: add device-tree documentation
      [media] s5p-mfc: remove unnecessary calling to function video_devdata()
      [media] s5p-jpeg: add chroma subsampling adjustment for Exynos3250
      [media] s5p-jpeg: Prevent erroneous downscaling for Exynos3250 SoC
      [media] s5p-jpeg: Assure proper crop rectangle initialization
      [media] s5p-jpeg: fix g_selection op
      [media] s5p-jpeg: Adjust jpeg_bound_align_image to Exynos3250 needs
      ...

commit c5540fbb9de39ceec108a889133664a887c2f55a
Author: David Härdeman <david@hardeman.nu>
Date:   Thu Apr 3 20:32:21 2014 -0300

    [media] rc-core: remove protocol arrays
    
    The basic API of rc-core used to be:
    
            dev = rc_allocate_device();
            dev->x = a;
            dev->y = b;
            dev->z = c;
            rc_register_device();
    
    which is a pretty common pattern in the kernel, after the introduction of
    protocol arrays the API looks something like:
    
            dev = rc_allocate_device();
            dev->x = a;
            rc_set_allowed_protocols(dev, RC_BIT_X);
            dev->z = c;
            rc_register_device();
    
    There's no real need for the protocols to be an array, so change it
    back to be consistent (and in preparation for the following patches).
    
    [m.chehab@samsung.com: added missing changes at some files]
    Signed-off-by: David Härdeman <david@hardeman.nu>
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
index e35580618936..45f5ee9f46fc 100644
--- a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
+++ b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
@@ -164,7 +164,7 @@ static int dvb_usbv2_remote_init(struct dvb_usb_device *d)
 	dev->driver_name = (char *) d->props->driver_name;
 	dev->map_name = d->rc.map_name;
 	dev->driver_type = d->rc.driver_type;
-	rc_set_allowed_protocols(dev, d->rc.allowed_protos);
+	dev->allowed_protocols = d->rc.allowed_protos;
 	dev->change_protocol = d->rc.change_protocol;
 	dev->priv = d;
 

commit 743162013d40ca612b4cb53d3a200dff2d9ab26e
Author: NeilBrown <neilb@suse.de>
Date:   Mon Jul 7 15:16:04 2014 +1000

    sched: Remove proliferation of wait_on_bit() action functions
    
    The current "wait_on_bit" interface requires an 'action'
    function to be provided which does the actual waiting.
    There are over 20 such functions, many of them identical.
    Most cases can be satisfied by one of just two functions, one
    which uses io_schedule() and one which just uses schedule().
    
    So:
     Rename wait_on_bit and        wait_on_bit_lock to
            wait_on_bit_action and wait_on_bit_lock_action
     to make it explicit that they need an action function.
    
     Introduce new wait_on_bit{,_lock} and wait_on_bit{,_lock}_io
     which are *not* given an action function but implicitly use
     a standard one.
     The decision to error-out if a signal is pending is now made
     based on the 'mode' argument rather than being encoded in the action
     function.
    
     All instances of the old wait_on_bit and wait_on_bit_lock which
     can use the new version have been changed accordingly and their
     action functions have been discarded.
     wait_on_bit{_lock} does not return any specific error code in the
     event of a signal so the caller must check for non-zero and
     interpolate their own error code as appropriate.
    
    The wait_on_bit() call in __fscache_wait_on_invalidate() was
    ambiguous as it specified TASK_UNINTERRUPTIBLE but used
    fscache_wait_bit_interruptible as an action function.
    David Howells confirms this should be uniformly
    "uninterruptible"
    
    The main remaining user of wait_on_bit{,_lock}_action is NFS
    which needs to use a freezer-aware schedule() call.
    
    A comment in fs/gfs2/glock.c notes that having multiple 'action'
    functions is useful as they display differently in the 'wchan'
    field of 'ps'. (and /proc/$PID/wchan).
    As the new bit_wait{,_io} functions are tagged "__sched", they
    will not show up at all, but something higher in the stack.  So
    the distinction will still be visible, only with different
    function names (gds2_glock_wait versus gfs2_glock_dq_wait in the
    gfs2/glock.c case).
    
    Since first version of this patch (against 3.15) two new action
    functions appeared, on in NFS and one in CIFS.  CIFS also now
    uses an action function that makes the same freezer aware
    schedule call as NFS.
    
    Signed-off-by: NeilBrown <neilb@suse.de>
    Acked-by: David Howells <dhowells@redhat.com> (fscache, keys)
    Acked-by: Steven Whitehouse <swhiteho@redhat.com> (gfs2)
    Acked-by: Peter Zijlstra <peterz@infradead.org>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Steve French <sfrench@samba.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Link: http://lkml.kernel.org/r/20140707051603.28027.72349.stgit@notabene.brown
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
index e35580618936..f296394bb7c5 100644
--- a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
+++ b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
@@ -253,13 +253,6 @@ static int dvb_usbv2_adapter_stream_exit(struct dvb_usb_adapter *adap)
 	return usb_urb_exitv2(&adap->stream);
 }
 
-static int wait_schedule(void *ptr)
-{
-	schedule();
-
-	return 0;
-}
-
 static int dvb_usb_start_feed(struct dvb_demux_feed *dvbdmxfeed)
 {
 	struct dvb_usb_adapter *adap = dvbdmxfeed->demux->priv;
@@ -273,8 +266,7 @@ static int dvb_usb_start_feed(struct dvb_demux_feed *dvbdmxfeed)
 			dvbdmxfeed->pid, dvbdmxfeed->index);
 
 	/* wait init is done */
-	wait_on_bit(&adap->state_bits, ADAP_INIT, wait_schedule,
-			TASK_UNINTERRUPTIBLE);
+	wait_on_bit(&adap->state_bits, ADAP_INIT, TASK_UNINTERRUPTIBLE);
 
 	if (adap->active_fe == -1)
 		return -EINVAL;
@@ -568,7 +560,7 @@ static int dvb_usb_fe_sleep(struct dvb_frontend *fe)
 
 	if (!adap->suspend_resume_active) {
 		set_bit(ADAP_SLEEP, &adap->state_bits);
-		wait_on_bit(&adap->state_bits, ADAP_STREAMING, wait_schedule,
+		wait_on_bit(&adap->state_bits, ADAP_STREAMING,
 				TASK_UNINTERRUPTIBLE);
 	}
 

commit 4e857c58efeb99393cba5a5d0d8ec7117183137c
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Mon Mar 17 18:06:10 2014 +0100

    arch: Mass conversion of smp_mb__*()
    
    Mostly scripted conversion of the smp_mb__* barriers.
    
    Signed-off-by: Peter Zijlstra <peterz@infradead.org>
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Link: http://lkml.kernel.org/n/tip-55dhyhocezdw1dg7u19hmh1u@git.kernel.org
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: linux-arch@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
index de02db802ace..e35580618936 100644
--- a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
+++ b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
@@ -399,7 +399,7 @@ static int dvb_usb_stop_feed(struct dvb_demux_feed *dvbdmxfeed)
 
 	/* clear 'streaming' status bit */
 	clear_bit(ADAP_STREAMING, &adap->state_bits);
-	smp_mb__after_clear_bit();
+	smp_mb__after_atomic();
 	wake_up_bit(&adap->state_bits, ADAP_STREAMING);
 skip_feed_stop:
 
@@ -550,7 +550,7 @@ static int dvb_usb_fe_init(struct dvb_frontend *fe)
 err:
 	if (!adap->suspend_resume_active) {
 		clear_bit(ADAP_INIT, &adap->state_bits);
-		smp_mb__after_clear_bit();
+		smp_mb__after_atomic();
 		wake_up_bit(&adap->state_bits, ADAP_INIT);
 	}
 
@@ -591,7 +591,7 @@ static int dvb_usb_fe_sleep(struct dvb_frontend *fe)
 	if (!adap->suspend_resume_active) {
 		adap->active_fe = -1;
 		clear_bit(ADAP_SLEEP, &adap->state_bits);
-		smp_mb__after_clear_bit();
+		smp_mb__after_atomic();
 		wake_up_bit(&adap->state_bits, ADAP_SLEEP);
 	}
 

commit 1a1934fab0c920f0d3bceeb60c9fe2dae8a56be9
Author: James Hogan <james.hogan@imgtec.com>
Date:   Fri Feb 28 20:17:03 2014 -0300

    [media] rc: abstract access to allowed/enabled protocols
    
    The allowed and enabled protocol masks need to be expanded to be per
    filter type in order to support wakeup filter protocol selection. To
    ease that process abstract access to the rc_dev::allowed_protos and
    rc_dev::enabled_protocols members with inline functions.
    
    Signed-off-by: James Hogan <james.hogan@imgtec.com>
    Reviewed-by: Antti Seppälä <a.seppala@gmail.com>
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
index 8a054d66e708..de02db802ace 100644
--- a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
+++ b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
@@ -164,7 +164,7 @@ static int dvb_usbv2_remote_init(struct dvb_usb_device *d)
 	dev->driver_name = (char *) d->props->driver_name;
 	dev->map_name = d->rc.map_name;
 	dev->driver_type = d->rc.driver_type;
-	dev->allowed_protos = d->rc.allowed_protos;
+	rc_set_allowed_protocols(dev, d->rc.allowed_protos);
 	dev->change_protocol = d->rc.change_protocol;
 	dev->priv = d;
 

commit dd0f5e0b75540f7bfca99c5a664c61ac90e52514
Author: Antti Palosaari <crope@iki.fi>
Date:   Tue Jul 30 17:22:25 2013 -0300

    [media] dvb_usb_v2: get rid of deferred probe
    
    Deferred probe was added in order to avoid udev vs. Kernel firmware
    download problems. It is not needed anymore.
    https://bugzilla.redhat.com/show_bug.cgi?id=827538
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
index 19f6737d9817..8a054d66e708 100644
--- a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
+++ b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
@@ -833,20 +833,44 @@ static int dvb_usbv2_init(struct dvb_usb_device *d)
 	return ret;
 }
 
-/*
- * udev, which is used for the firmware downloading, requires we cannot
- * block during module_init(). module_init() calls USB probe() which
- * is this routine. Due to that we delay actual operation using workqueue
- * and return always success here.
- */
-static void dvb_usbv2_init_work(struct work_struct *work)
+int dvb_usbv2_probe(struct usb_interface *intf,
+		const struct usb_device_id *id)
 {
 	int ret;
-	struct dvb_usb_device *d =
-			container_of(work, struct dvb_usb_device, probe_work);
+	struct dvb_usb_device *d;
+	struct usb_device *udev = interface_to_usbdev(intf);
+	struct dvb_usb_driver_info *driver_info =
+			(struct dvb_usb_driver_info *) id->driver_info;
+
+	dev_dbg(&udev->dev, "%s: bInterfaceNumber=%d\n", __func__,
+			intf->cur_altsetting->desc.bInterfaceNumber);
+
+	if (!id->driver_info) {
+		dev_err(&udev->dev, "%s: driver_info failed\n", KBUILD_MODNAME);
+		ret = -ENODEV;
+		goto err;
+	}
+
+	d = kzalloc(sizeof(struct dvb_usb_device), GFP_KERNEL);
+	if (!d) {
+		dev_err(&udev->dev, "%s: kzalloc() failed\n", KBUILD_MODNAME);
+		ret = -ENOMEM;
+		goto err;
+	}
 
-	d->work_pid = current->pid;
-	dev_dbg(&d->udev->dev, "%s: work_pid=%d\n", __func__, d->work_pid);
+	d->name = driver_info->name;
+	d->rc_map = driver_info->rc_map;
+	d->udev = udev;
+	d->props = driver_info->props;
+
+	if (intf->cur_altsetting->desc.bInterfaceNumber !=
+			d->props->bInterfaceNumber) {
+		ret = -ENODEV;
+		goto err_free_all;
+	}
+
+	mutex_init(&d->usb_mutex);
+	mutex_init(&d->i2c_mutex);
 
 	if (d->props->size_of_priv) {
 		d->priv = kzalloc(d->props->size_of_priv, GFP_KERNEL);
@@ -854,7 +878,7 @@ static void dvb_usbv2_init_work(struct work_struct *work)
 			dev_err(&d->udev->dev, "%s: kzalloc() failed\n",
 					KBUILD_MODNAME);
 			ret = -ENOMEM;
-			goto err_usb_driver_release_interface;
+			goto err_free_all;
 		}
 	}
 
@@ -884,20 +908,12 @@ static void dvb_usbv2_init_work(struct work_struct *work)
 				 * device. As 'new' device is warm we should
 				 * never go here again.
 				 */
-				return;
+				goto exit;
 			} else {
-				/*
-				 * Unexpected error. We must unregister driver
-				 * manually from the device, because device is
-				 * already register by returning from probe()
-				 * with success. usb_driver_release_interface()
-				 * finally calls disconnect() in order to free
-				 * resources.
-				 */
-				goto err_usb_driver_release_interface;
+				goto err_free_all;
 			}
 		} else {
-			goto err_usb_driver_release_interface;
+			goto err_free_all;
 		}
 	}
 
@@ -906,73 +922,17 @@ static void dvb_usbv2_init_work(struct work_struct *work)
 
 	ret = dvb_usbv2_init(d);
 	if (ret < 0)
-		goto err_usb_driver_release_interface;
+		goto err_free_all;
 
 	dev_info(&d->udev->dev,
 			"%s: '%s' successfully initialized and connected\n",
 			KBUILD_MODNAME, d->name);
-
-	return;
-err_usb_driver_release_interface:
-	dev_info(&d->udev->dev, "%s: '%s' error while loading driver (%d)\n",
-			KBUILD_MODNAME, d->name, ret);
-	usb_driver_release_interface(to_usb_driver(d->intf->dev.driver),
-			d->intf);
-	dev_dbg(&d->udev->dev, "%s: failed=%d\n", __func__, ret);
-	return;
-}
-
-int dvb_usbv2_probe(struct usb_interface *intf,
-		const struct usb_device_id *id)
-{
-	int ret;
-	struct dvb_usb_device *d;
-	struct usb_device *udev = interface_to_usbdev(intf);
-	struct dvb_usb_driver_info *driver_info =
-			(struct dvb_usb_driver_info *) id->driver_info;
-
-	dev_dbg(&udev->dev, "%s: bInterfaceNumber=%d\n", __func__,
-			intf->cur_altsetting->desc.bInterfaceNumber);
-
-	if (!id->driver_info) {
-		dev_err(&udev->dev, "%s: driver_info failed\n", KBUILD_MODNAME);
-		ret = -ENODEV;
-		goto err;
-	}
-
-	d = kzalloc(sizeof(struct dvb_usb_device), GFP_KERNEL);
-	if (!d) {
-		dev_err(&udev->dev, "%s: kzalloc() failed\n", KBUILD_MODNAME);
-		ret = -ENOMEM;
-		goto err;
-	}
-
-	d->name = driver_info->name;
-	d->rc_map = driver_info->rc_map;
-	d->udev = udev;
-	d->intf = intf;
-	d->props = driver_info->props;
-
-	if (d->intf->cur_altsetting->desc.bInterfaceNumber !=
-			d->props->bInterfaceNumber) {
-		ret = -ENODEV;
-		goto err_kfree;
-	}
-
-	mutex_init(&d->usb_mutex);
-	mutex_init(&d->i2c_mutex);
-	INIT_WORK(&d->probe_work, dvb_usbv2_init_work);
+exit:
 	usb_set_intfdata(intf, d);
-	ret = schedule_work(&d->probe_work);
-	if (ret < 0) {
-		dev_err(&d->udev->dev, "%s: schedule_work() failed\n",
-				KBUILD_MODNAME);
-		goto err_kfree;
-	}
 
 	return 0;
-err_kfree:
-	kfree(d);
+err_free_all:
+	dvb_usbv2_exit(d);
 err:
 	dev_dbg(&udev->dev, "%s: failed=%d\n", __func__, ret);
 	return ret;
@@ -984,12 +944,8 @@ void dvb_usbv2_disconnect(struct usb_interface *intf)
 	struct dvb_usb_device *d = usb_get_intfdata(intf);
 	const char *name = d->name;
 	struct device dev = d->udev->dev;
-	dev_dbg(&d->udev->dev, "%s: pid=%d work_pid=%d\n", __func__,
-			current->pid, d->work_pid);
-
-	/* ensure initialization work is finished until release resources */
-	if (d->work_pid != current->pid)
-		cancel_work_sync(&d->probe_work);
+	dev_dbg(&d->udev->dev, "%s: bInterfaceNumber=%d\n", __func__,
+			intf->cur_altsetting->desc.bInterfaceNumber);
 
 	if (d->props->exit)
 		d->props->exit(d);

commit 96d7ca5ec9baac231ab3dfd62abcb75141d80626
Author: Antti Palosaari <crope@iki.fi>
Date:   Sat Mar 9 16:10:55 2013 -0300

    [media] dvb_usb_v2: rework USB streaming logic
    
    Control flow order changed a little bit. HW PID filter is now
    disabled also when streaming is stopped - earlier it was just
    set only when streaming was started.
    Control flow is now:
    * set streaming status bit
    * submit USB streaming packets
    * enable HW PID filter
    * ask device to start streaming
    * N x add PID to device HW PID filter
    ... streaming video ...
    * N x remove PID from device HW PID filter
    * ask device to stop streaming
    * disable HW PID filter
    * kill USB streaming packets
    * clear streaming status bit
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
index 9b24a0e9675a..19f6737d9817 100644
--- a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
+++ b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
@@ -260,135 +260,152 @@ static int wait_schedule(void *ptr)
 	return 0;
 }
 
-static inline int dvb_usb_ctrl_feed(struct dvb_demux_feed *dvbdmxfeed,
-		int count)
+static int dvb_usb_start_feed(struct dvb_demux_feed *dvbdmxfeed)
 {
 	struct dvb_usb_adapter *adap = dvbdmxfeed->demux->priv;
 	struct dvb_usb_device *d = adap_to_d(adap);
-	int ret;
-	dev_dbg(&d->udev->dev, "%s: adap=%d active_fe=%d feed_type=%d setting pid [%s]: %04x (%04d) at index %d '%s'\n",
+	int ret = 0;
+	struct usb_data_stream_properties stream_props;
+	dev_dbg(&d->udev->dev,
+			"%s: adap=%d active_fe=%d feed_type=%d setting pid [%s]: %04x (%04d) at index %d\n",
 			__func__, adap->id, adap->active_fe, dvbdmxfeed->type,
 			adap->pid_filtering ? "yes" : "no", dvbdmxfeed->pid,
-			dvbdmxfeed->pid, dvbdmxfeed->index,
-			(count == 1) ? "on" : "off");
+			dvbdmxfeed->pid, dvbdmxfeed->index);
 
+	/* wait init is done */
 	wait_on_bit(&adap->state_bits, ADAP_INIT, wait_schedule,
 			TASK_UNINTERRUPTIBLE);
 
 	if (adap->active_fe == -1)
 		return -EINVAL;
 
-	adap->feed_count += count;
-
-	/* stop feeding if it is last pid */
-	if (adap->feed_count == 0) {
-		dev_dbg(&d->udev->dev, "%s: stop feeding\n", __func__);
-
-		if (d->props->streaming_ctrl) {
-			ret = d->props->streaming_ctrl(
-					adap->fe[adap->active_fe], 0);
-			if (ret < 0) {
-				dev_err(&d->udev->dev,
-						"%s: streaming_ctrl() failed=%d\n",
-						KBUILD_MODNAME, ret);
-				usb_urb_killv2(&adap->stream);
-				goto err_clear_wait;
-			}
-		}
-		usb_urb_killv2(&adap->stream);
+	/* skip feed setup if we are already feeding */
+	if (adap->feed_count++ > 0)
+		goto skip_feed_start;
 
-		clear_bit(ADAP_STREAMING, &adap->state_bits);
-		smp_mb__after_clear_bit();
-		wake_up_bit(&adap->state_bits, ADAP_STREAMING);
+	/* set 'streaming' status bit */
+	set_bit(ADAP_STREAMING, &adap->state_bits);
+
+	/* resolve input and output streaming parameters */
+	if (d->props->get_stream_config) {
+		memcpy(&stream_props, &adap->props->stream,
+				sizeof(struct usb_data_stream_properties));
+		ret = d->props->get_stream_config(adap->fe[adap->active_fe],
+				&adap->ts_type, &stream_props);
+		if (ret)
+			dev_err(&d->udev->dev,
+					"%s: get_stream_config() failed=%d\n",
+					KBUILD_MODNAME, ret);
+	} else {
+		stream_props = adap->props->stream;
+	}
+
+	switch (adap->ts_type) {
+	case DVB_USB_FE_TS_TYPE_204:
+		adap->stream.complete = dvb_usb_data_complete_204;
+		break;
+	case DVB_USB_FE_TS_TYPE_RAW:
+		adap->stream.complete = dvb_usb_data_complete_raw;
+		break;
+	case DVB_USB_FE_TS_TYPE_188:
+	default:
+		adap->stream.complete = dvb_usb_data_complete;
+		break;
+	}
+
+	/* submit USB streaming packets */
+	usb_urb_submitv2(&adap->stream, &stream_props);
+
+	/* enable HW PID filter */
+	if (adap->pid_filtering && adap->props->pid_filter_ctrl) {
+		ret = adap->props->pid_filter_ctrl(adap, 1);
+		if (ret)
+			dev_err(&d->udev->dev,
+					"%s: pid_filter_ctrl() failed=%d\n",
+					KBUILD_MODNAME, ret);
 	}
 
-	/* activate the pid on the device pid filter */
-	if (adap->props->caps & DVB_USB_ADAP_HAS_PID_FILTER &&
-			adap->pid_filtering && adap->props->pid_filter) {
+	/* ask device to start streaming */
+	if (d->props->streaming_ctrl) {
+		ret = d->props->streaming_ctrl(adap->fe[adap->active_fe], 1);
+		if (ret)
+			dev_err(&d->udev->dev,
+					"%s: streaming_ctrl() failed=%d\n",
+					KBUILD_MODNAME, ret);
+	}
+skip_feed_start:
+
+	/* add PID to device HW PID filter */
+	if (adap->pid_filtering && adap->props->pid_filter) {
 		ret = adap->props->pid_filter(adap, dvbdmxfeed->index,
-				dvbdmxfeed->pid, (count == 1) ? 1 : 0);
-		if (ret < 0)
+				dvbdmxfeed->pid, 1);
+		if (ret)
 			dev_err(&d->udev->dev, "%s: pid_filter() failed=%d\n",
 					KBUILD_MODNAME, ret);
 	}
 
-	/* start feeding if it is first pid */
-	if (adap->feed_count == 1 && count == 1) {
-		struct usb_data_stream_properties stream_props;
-		set_bit(ADAP_STREAMING, &adap->state_bits);
-		dev_dbg(&d->udev->dev, "%s: start feeding\n", __func__);
+	if (ret)
+		dev_dbg(&d->udev->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
 
-		/* resolve input and output streaming paramters */
-		if (d->props->get_stream_config) {
-			memcpy(&stream_props, &adap->props->stream,
-				sizeof(struct usb_data_stream_properties));
-			ret = d->props->get_stream_config(
-					adap->fe[adap->active_fe],
-					&adap->ts_type, &stream_props);
-			if (ret < 0)
-				goto err_clear_wait;
-		} else {
-			stream_props = adap->props->stream;
-		}
+static int dvb_usb_stop_feed(struct dvb_demux_feed *dvbdmxfeed)
+{
+	struct dvb_usb_adapter *adap = dvbdmxfeed->demux->priv;
+	struct dvb_usb_device *d = adap_to_d(adap);
+	int ret = 0;
+	dev_dbg(&d->udev->dev,
+			"%s: adap=%d active_fe=%d feed_type=%d setting pid [%s]: %04x (%04d) at index %d\n",
+			__func__, adap->id, adap->active_fe, dvbdmxfeed->type,
+			adap->pid_filtering ? "yes" : "no", dvbdmxfeed->pid,
+			dvbdmxfeed->pid, dvbdmxfeed->index);
 
-		switch (adap->ts_type) {
-		case DVB_USB_FE_TS_TYPE_204:
-			adap->stream.complete = dvb_usb_data_complete_204;
-			break;
-		case DVB_USB_FE_TS_TYPE_RAW:
-			adap->stream.complete = dvb_usb_data_complete_raw;
-			break;
-		case DVB_USB_FE_TS_TYPE_188:
-		default:
-			adap->stream.complete = dvb_usb_data_complete;
-			break;
-		}
+	if (adap->active_fe == -1)
+		return -EINVAL;
 
-		usb_urb_submitv2(&adap->stream, &stream_props);
-
-		if (adap->props->caps & DVB_USB_ADAP_HAS_PID_FILTER &&
-				adap->props->caps &
-				DVB_USB_ADAP_PID_FILTER_CAN_BE_TURNED_OFF &&
-				adap->props->pid_filter_ctrl) {
-			ret = adap->props->pid_filter_ctrl(adap,
-					adap->pid_filtering);
-			if (ret < 0) {
-				dev_err(&d->udev->dev,
-						"%s: pid_filter_ctrl() failed=%d\n",
-						KBUILD_MODNAME, ret);
-				goto err_clear_wait;
-			}
-		}
+	/* remove PID from device HW PID filter */
+	if (adap->pid_filtering && adap->props->pid_filter) {
+		ret = adap->props->pid_filter(adap, dvbdmxfeed->index,
+				dvbdmxfeed->pid, 0);
+		if (ret)
+			dev_err(&d->udev->dev, "%s: pid_filter() failed=%d\n",
+					KBUILD_MODNAME, ret);
+	}
 
-		if (d->props->streaming_ctrl) {
-			ret = d->props->streaming_ctrl(
-					adap->fe[adap->active_fe], 1);
-			if (ret < 0) {
-				dev_err(&d->udev->dev,
-						"%s: streaming_ctrl() failed=%d\n",
-						KBUILD_MODNAME, ret);
-				goto err_clear_wait;
-			}
-		}
+	/* we cannot stop streaming until last PID is removed */
+	if (--adap->feed_count > 0)
+		goto skip_feed_stop;
+
+	/* ask device to stop streaming */
+	if (d->props->streaming_ctrl) {
+		ret = d->props->streaming_ctrl(adap->fe[adap->active_fe], 0);
+		if (ret)
+			dev_err(&d->udev->dev,
+					"%s: streaming_ctrl() failed=%d\n",
+					KBUILD_MODNAME, ret);
 	}
 
-	return 0;
-err_clear_wait:
+	/* disable HW PID filter */
+	if (adap->pid_filtering && adap->props->pid_filter_ctrl) {
+		ret = adap->props->pid_filter_ctrl(adap, 0);
+		if (ret)
+			dev_err(&d->udev->dev,
+					"%s: pid_filter_ctrl() failed=%d\n",
+					KBUILD_MODNAME, ret);
+	}
+
+	/* kill USB streaming packets */
+	usb_urb_killv2(&adap->stream);
+
+	/* clear 'streaming' status bit */
 	clear_bit(ADAP_STREAMING, &adap->state_bits);
 	smp_mb__after_clear_bit();
 	wake_up_bit(&adap->state_bits, ADAP_STREAMING);
-	dev_dbg(&d->udev->dev, "%s: failed=%d\n", __func__, ret);
-	return ret;
-}
-
-static int dvb_usb_start_feed(struct dvb_demux_feed *dvbdmxfeed)
-{
-	return dvb_usb_ctrl_feed(dvbdmxfeed, 1);
-}
+skip_feed_stop:
 
-static int dvb_usb_stop_feed(struct dvb_demux_feed *dvbdmxfeed)
-{
-	return dvb_usb_ctrl_feed(dvbdmxfeed, -1);
+	if (ret)
+		dev_dbg(&d->udev->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
 }
 
 static int dvb_usbv2_adapter_dvb_init(struct dvb_usb_adapter *adap)

commit 6d7cfec4130fdbe4b74277c91b6ba91f56eaca03
Author: Antti Palosaari <crope@iki.fi>
Date:   Sat Mar 9 11:36:35 2013 -0300

    [media] dvb_usb_v2: make checkpatch.pl happy
    
    New checkpatch version likes to see strings not to split multiple
    lines even those are exceeding 80 line length.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
index c91da3c4d332..9b24a0e9675a 100644
--- a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
+++ b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
@@ -28,10 +28,11 @@ MODULE_PARM_DESC(disable_rc_polling,
 static int dvb_usb_force_pid_filter_usage;
 module_param_named(force_pid_filter_usage, dvb_usb_force_pid_filter_usage,
 		int, 0444);
-MODULE_PARM_DESC(force_pid_filter_usage, "force all DVB USB devices to use a " \
-		"PID filter, if any (default: 0)");
+MODULE_PARM_DESC(force_pid_filter_usage,
+		"force all DVB USB devices to use a PID filter, if any (default: 0)");
 
-static int dvb_usbv2_download_firmware(struct dvb_usb_device *d, const char *name)
+static int dvb_usbv2_download_firmware(struct dvb_usb_device *d,
+		const char *name)
 {
 	int ret;
 	const struct firmware *fw;
@@ -44,10 +45,9 @@ static int dvb_usbv2_download_firmware(struct dvb_usb_device *d, const char *nam
 
 	ret = request_firmware(&fw, name, &d->udev->dev);
 	if (ret < 0) {
-		dev_err(&d->udev->dev, "%s: Did not find the firmware file "\
-				"'%s'. Please see linux/Documentation/dvb/ " \
-				"for more details on firmware-problems. " \
-				"Status %d\n", KBUILD_MODNAME, name, ret);
+		dev_err(&d->udev->dev,
+				"%s: Did not find the firmware file '%s'. Please see linux/Documentation/dvb/ for more details on firmware-problems. Status %d\n",
+				KBUILD_MODNAME, name, ret);
 		goto err;
 	}
 
@@ -181,9 +181,9 @@ static int dvb_usbv2_remote_init(struct dvb_usb_device *d)
 		/* initialize a work queue for handling polling */
 		INIT_DELAYED_WORK(&d->rc_query_work,
 				dvb_usb_read_remote_control);
-		dev_info(&d->udev->dev, "%s: schedule remote query interval " \
-				"to %d msecs\n", KBUILD_MODNAME,
-				d->rc.interval);
+		dev_info(&d->udev->dev,
+				"%s: schedule remote query interval to %d msecs\n",
+				KBUILD_MODNAME, d->rc.interval);
 		schedule_delayed_work(&d->rc_query_work,
 				msecs_to_jiffies(d->rc.interval));
 		d->rc_polling_active = true;
@@ -266,8 +266,7 @@ static inline int dvb_usb_ctrl_feed(struct dvb_demux_feed *dvbdmxfeed,
 	struct dvb_usb_adapter *adap = dvbdmxfeed->demux->priv;
 	struct dvb_usb_device *d = adap_to_d(adap);
 	int ret;
-	dev_dbg(&d->udev->dev, "%s: adap=%d active_fe=%d feed_type=%d " \
-			"setting pid [%s]: %04x (%04d) at index %d '%s'\n",
+	dev_dbg(&d->udev->dev, "%s: adap=%d active_fe=%d feed_type=%d setting pid [%s]: %04x (%04d) at index %d '%s'\n",
 			__func__, adap->id, adap->active_fe, dvbdmxfeed->type,
 			adap->pid_filtering ? "yes" : "no", dvbdmxfeed->pid,
 			dvbdmxfeed->pid, dvbdmxfeed->index,
@@ -289,9 +288,9 @@ static inline int dvb_usb_ctrl_feed(struct dvb_demux_feed *dvbdmxfeed,
 			ret = d->props->streaming_ctrl(
 					adap->fe[adap->active_fe], 0);
 			if (ret < 0) {
-				dev_err(&d->udev->dev, "%s: streaming_ctrl() " \
-						"failed=%d\n", KBUILD_MODNAME,
-						ret);
+				dev_err(&d->udev->dev,
+						"%s: streaming_ctrl() failed=%d\n",
+						KBUILD_MODNAME, ret);
 				usb_urb_killv2(&adap->stream);
 				goto err_clear_wait;
 			}
@@ -354,8 +353,8 @@ static inline int dvb_usb_ctrl_feed(struct dvb_demux_feed *dvbdmxfeed,
 			ret = adap->props->pid_filter_ctrl(adap,
 					adap->pid_filtering);
 			if (ret < 0) {
-				dev_err(&d->udev->dev, "%s: " \
-						"pid_filter_ctrl() failed=%d\n",
+				dev_err(&d->udev->dev,
+						"%s: pid_filter_ctrl() failed=%d\n",
 						KBUILD_MODNAME, ret);
 				goto err_clear_wait;
 			}
@@ -365,9 +364,9 @@ static inline int dvb_usb_ctrl_feed(struct dvb_demux_feed *dvbdmxfeed,
 			ret = d->props->streaming_ctrl(
 					adap->fe[adap->active_fe], 1);
 			if (ret < 0) {
-				dev_err(&d->udev->dev, "%s: streaming_ctrl() " \
-						"failed=%d\n", KBUILD_MODNAME,
-						ret);
+				dev_err(&d->udev->dev,
+						"%s: streaming_ctrl() failed=%d\n",
+						KBUILD_MODNAME, ret);
 				goto err_clear_wait;
 			}
 		}
@@ -595,8 +594,9 @@ static int dvb_usbv2_adapter_frontend_init(struct dvb_usb_adapter *adap)
 	if (d->props->frontend_attach) {
 		ret = d->props->frontend_attach(adap);
 		if (ret < 0) {
-			dev_dbg(&d->udev->dev, "%s: frontend_attach() " \
-					"failed=%d\n", __func__, ret);
+			dev_dbg(&d->udev->dev,
+					"%s: frontend_attach() failed=%d\n",
+					__func__, ret);
 			goto err_dvb_frontend_detach;
 		}
 	} else {
@@ -616,8 +616,9 @@ static int dvb_usbv2_adapter_frontend_init(struct dvb_usb_adapter *adap)
 
 		ret = dvb_register_frontend(&adap->dvb_adap, adap->fe[i]);
 		if (ret < 0) {
-			dev_err(&d->udev->dev, "%s: frontend%d registration " \
-					"failed\n", KBUILD_MODNAME, i);
+			dev_err(&d->udev->dev,
+					"%s: frontend%d registration failed\n",
+					KBUILD_MODNAME, i);
 			goto err_dvb_unregister_frontend;
 		}
 
@@ -691,33 +692,33 @@ static int dvb_usbv2_adapter_init(struct dvb_usb_device *d)
 		/* speed - when running at FULL speed we need a HW PID filter */
 		if (d->udev->speed == USB_SPEED_FULL &&
 				!(adap->props->caps & DVB_USB_ADAP_HAS_PID_FILTER)) {
-			dev_err(&d->udev->dev, "%s: this USB2.0 device " \
-					"cannot be run on a USB1.1 port (it " \
-					"lacks a hardware PID filter)\n",
+			dev_err(&d->udev->dev,
+					"%s: this USB2.0 device cannot be run on a USB1.1 port (it lacks a hardware PID filter)\n",
 					KBUILD_MODNAME);
 			ret = -ENODEV;
 			goto err;
 		} else if ((d->udev->speed == USB_SPEED_FULL &&
 				adap->props->caps & DVB_USB_ADAP_HAS_PID_FILTER) ||
 				(adap->props->caps & DVB_USB_ADAP_NEED_PID_FILTERING)) {
-			dev_info(&d->udev->dev, "%s: will use the device's " \
-					"hardware PID filter " \
-					"(table count: %d)\n", KBUILD_MODNAME,
+			dev_info(&d->udev->dev,
+					"%s: will use the device's hardware PID filter (table count: %d)\n",
+					KBUILD_MODNAME,
 					adap->props->pid_filter_count);
 			adap->pid_filtering  = 1;
 			adap->max_feed_count = adap->props->pid_filter_count;
 		} else {
-			dev_info(&d->udev->dev, "%s: will pass the complete " \
-					"MPEG2 transport stream to the " \
-					"software demuxer\n", KBUILD_MODNAME);
+			dev_info(&d->udev->dev,
+					"%s: will pass the complete MPEG2 transport stream to the software demuxer\n",
+					KBUILD_MODNAME);
 			adap->pid_filtering  = 0;
 			adap->max_feed_count = 255;
 		}
 
 		if (!adap->pid_filtering && dvb_usb_force_pid_filter_usage &&
 				adap->props->caps & DVB_USB_ADAP_HAS_PID_FILTER) {
-			dev_info(&d->udev->dev, "%s: PID filter enabled by " \
-					"module option\n", KBUILD_MODNAME);
+			dev_info(&d->udev->dev,
+					"%s: PID filter enabled by module option\n",
+					KBUILD_MODNAME);
 			adap->pid_filtering  = 1;
 			adap->max_feed_count = adap->props->pid_filter_count;
 		}
@@ -846,8 +847,9 @@ static void dvb_usbv2_init_work(struct work_struct *work)
 		if (ret == 0) {
 			;
 		} else if (ret == COLD) {
-			dev_info(&d->udev->dev, "%s: found a '%s' in cold " \
-					"state\n", KBUILD_MODNAME, d->name);
+			dev_info(&d->udev->dev,
+					"%s: found a '%s' in cold state\n",
+					KBUILD_MODNAME, d->name);
 
 			if (!name)
 				name = d->props->firmware;
@@ -889,8 +891,9 @@ static void dvb_usbv2_init_work(struct work_struct *work)
 	if (ret < 0)
 		goto err_usb_driver_release_interface;
 
-	dev_info(&d->udev->dev, "%s: '%s' successfully initialized and " \
-			"connected\n", KBUILD_MODNAME, d->name);
+	dev_info(&d->udev->dev,
+			"%s: '%s' successfully initialized and connected\n",
+			KBUILD_MODNAME, d->name);
 
 	return;
 err_usb_driver_release_interface:

commit bdecbe43e345d1e5a0fa82625d7beb7c3371763e
Author: Antti Palosaari <crope@iki.fi>
Date:   Sat Mar 9 00:16:32 2013 -0300

    [media] dvb_usb_v2: replace Kernel userspace lock with wait queue
    
    There was sync mutex which was held over userspace. That is very
    wrong and could cause deadlock if different userspace process is
    used to "unlock". Wait queue seems to be correct solution for
    that kind of synchronizing issue so use it instead.
    lock debug gives following bug report:
    ================================================
    [ BUG: lock held when returning to user space! ]
    3.9.0-rc1+ #38 Tainted: G           O
    ------------------------------------------------
    tzap/4614 is leaving the kernel with locks still held!
    1 lock held by tzap/4614:
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
index 086792055912..c91da3c4d332 100644
--- a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
+++ b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
@@ -253,6 +253,13 @@ static int dvb_usbv2_adapter_stream_exit(struct dvb_usb_adapter *adap)
 	return usb_urb_exitv2(&adap->stream);
 }
 
+static int wait_schedule(void *ptr)
+{
+	schedule();
+
+	return 0;
+}
+
 static inline int dvb_usb_ctrl_feed(struct dvb_demux_feed *dvbdmxfeed,
 		int count)
 {
@@ -266,6 +273,9 @@ static inline int dvb_usb_ctrl_feed(struct dvb_demux_feed *dvbdmxfeed,
 			dvbdmxfeed->pid, dvbdmxfeed->index,
 			(count == 1) ? "on" : "off");
 
+	wait_on_bit(&adap->state_bits, ADAP_INIT, wait_schedule,
+			TASK_UNINTERRUPTIBLE);
+
 	if (adap->active_fe == -1)
 		return -EINVAL;
 
@@ -283,11 +293,14 @@ static inline int dvb_usb_ctrl_feed(struct dvb_demux_feed *dvbdmxfeed,
 						"failed=%d\n", KBUILD_MODNAME,
 						ret);
 				usb_urb_killv2(&adap->stream);
-				goto err_mutex_unlock;
+				goto err_clear_wait;
 			}
 		}
 		usb_urb_killv2(&adap->stream);
-		mutex_unlock(&adap->sync_mutex);
+
+		clear_bit(ADAP_STREAMING, &adap->state_bits);
+		smp_mb__after_clear_bit();
+		wake_up_bit(&adap->state_bits, ADAP_STREAMING);
 	}
 
 	/* activate the pid on the device pid filter */
@@ -303,7 +316,7 @@ static inline int dvb_usb_ctrl_feed(struct dvb_demux_feed *dvbdmxfeed,
 	/* start feeding if it is first pid */
 	if (adap->feed_count == 1 && count == 1) {
 		struct usb_data_stream_properties stream_props;
-		mutex_lock(&adap->sync_mutex);
+		set_bit(ADAP_STREAMING, &adap->state_bits);
 		dev_dbg(&d->udev->dev, "%s: start feeding\n", __func__);
 
 		/* resolve input and output streaming paramters */
@@ -314,7 +327,7 @@ static inline int dvb_usb_ctrl_feed(struct dvb_demux_feed *dvbdmxfeed,
 					adap->fe[adap->active_fe],
 					&adap->ts_type, &stream_props);
 			if (ret < 0)
-				goto err_mutex_unlock;
+				goto err_clear_wait;
 		} else {
 			stream_props = adap->props->stream;
 		}
@@ -344,7 +357,7 @@ static inline int dvb_usb_ctrl_feed(struct dvb_demux_feed *dvbdmxfeed,
 				dev_err(&d->udev->dev, "%s: " \
 						"pid_filter_ctrl() failed=%d\n",
 						KBUILD_MODNAME, ret);
-				goto err_mutex_unlock;
+				goto err_clear_wait;
 			}
 		}
 
@@ -355,14 +368,16 @@ static inline int dvb_usb_ctrl_feed(struct dvb_demux_feed *dvbdmxfeed,
 				dev_err(&d->udev->dev, "%s: streaming_ctrl() " \
 						"failed=%d\n", KBUILD_MODNAME,
 						ret);
-				goto err_mutex_unlock;
+				goto err_clear_wait;
 			}
 		}
 	}
 
 	return 0;
-err_mutex_unlock:
-	mutex_unlock(&adap->sync_mutex);
+err_clear_wait:
+	clear_bit(ADAP_STREAMING, &adap->state_bits);
+	smp_mb__after_clear_bit();
+	wake_up_bit(&adap->state_bits, ADAP_STREAMING);
 	dev_dbg(&d->udev->dev, "%s: failed=%d\n", __func__, ret);
 	return ret;
 }
@@ -435,8 +450,6 @@ static int dvb_usbv2_adapter_dvb_init(struct dvb_usb_adapter *adap)
 		goto err_dvb_net_init;
 	}
 
-	mutex_init(&adap->sync_mutex);
-
 	return 0;
 err_dvb_net_init:
 	dvb_dmxdev_release(&adap->dmxdev);
@@ -500,7 +513,7 @@ static int dvb_usb_fe_init(struct dvb_frontend *fe)
 
 	if (!adap->suspend_resume_active) {
 		adap->active_fe = fe->id;
-		mutex_lock(&adap->sync_mutex);
+		set_bit(ADAP_INIT, &adap->state_bits);
 	}
 
 	ret = dvb_usbv2_device_power_ctrl(d, 1);
@@ -519,8 +532,11 @@ static int dvb_usb_fe_init(struct dvb_frontend *fe)
 			goto err;
 	}
 err:
-	if (!adap->suspend_resume_active)
-		mutex_unlock(&adap->sync_mutex);
+	if (!adap->suspend_resume_active) {
+		clear_bit(ADAP_INIT, &adap->state_bits);
+		smp_mb__after_clear_bit();
+		wake_up_bit(&adap->state_bits, ADAP_INIT);
+	}
 
 	dev_dbg(&d->udev->dev, "%s: ret=%d\n", __func__, ret);
 	return ret;
@@ -534,8 +550,11 @@ static int dvb_usb_fe_sleep(struct dvb_frontend *fe)
 	dev_dbg(&d->udev->dev, "%s: adap=%d fe=%d\n", __func__, adap->id,
 			fe->id);
 
-	if (!adap->suspend_resume_active)
-		mutex_lock(&adap->sync_mutex);
+	if (!adap->suspend_resume_active) {
+		set_bit(ADAP_SLEEP, &adap->state_bits);
+		wait_on_bit(&adap->state_bits, ADAP_STREAMING, wait_schedule,
+				TASK_UNINTERRUPTIBLE);
+	}
 
 	if (adap->fe_sleep[fe->id]) {
 		ret = adap->fe_sleep[fe->id](fe);
@@ -555,7 +574,9 @@ static int dvb_usb_fe_sleep(struct dvb_frontend *fe)
 err:
 	if (!adap->suspend_resume_active) {
 		adap->active_fe = -1;
-		mutex_unlock(&adap->sync_mutex);
+		clear_bit(ADAP_SLEEP, &adap->state_bits);
+		smp_mb__after_clear_bit();
+		wake_up_bit(&adap->state_bits, ADAP_SLEEP);
 	}
 
 	dev_dbg(&d->udev->dev, "%s: ret=%d\n", __func__, ret);

commit 37b44a0f04184998073633887d2f1e724aee130a
Author: Antti Palosaari <crope@iki.fi>
Date:   Fri Jan 4 15:21:26 2013 -0300

    [media] dvb_usb_v2: use IS_ENABLED() macro
    
    replace:
     #if defined(CONFIG_RC_CORE) || defined(CONFIG_RC_CORE_MODULE)
    with:
     #if IS_ENABLED(CONFIG_RC_CORE)
    
    Reported-by: Fabio Estevam <festevam@gmail.com>
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
index 95968d39c1ca..086792055912 100644
--- a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
+++ b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
@@ -102,7 +102,7 @@ static int dvb_usbv2_i2c_exit(struct dvb_usb_device *d)
 	return 0;
 }
 
-#if defined(CONFIG_RC_CORE) || defined(CONFIG_RC_CORE_MODULE)
+#if IS_ENABLED(CONFIG_RC_CORE)
 static void dvb_usb_read_remote_control(struct work_struct *work)
 {
 	struct dvb_usb_device *d = container_of(work,

commit ac1c86c857368eb727b7ca2c7a48bd6e373fa628
Author: Antti Palosaari <crope@iki.fi>
Date:   Sun Dec 9 21:23:30 2012 -0300

    [media] dvb_usb_v2: change rc polling active/deactive logic
    
    Use own flag to mark when rc polling is active/deactive and make
    decisions, like start/stop polling on suspend/resume, against that.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
index 1330c644dd8d..95968d39c1ca 100644
--- a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
+++ b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
@@ -113,13 +113,16 @@ static void dvb_usb_read_remote_control(struct work_struct *work)
 	 * When the parameter has been set to 1 via sysfs while the
 	 * driver was running, or when bulk mode is enabled after IR init.
 	 */
-	if (dvb_usbv2_disable_rc_polling || d->rc.bulk_mode)
+	if (dvb_usbv2_disable_rc_polling || d->rc.bulk_mode) {
+		d->rc_polling_active = false;
 		return;
+	}
 
 	ret = d->rc.query(d);
 	if (ret < 0) {
 		dev_err(&d->udev->dev, "%s: rc.query() failed=%d\n",
 				KBUILD_MODNAME, ret);
+		d->rc_polling_active = false;
 		return; /* stop polling */
 	}
 
@@ -183,6 +186,7 @@ static int dvb_usbv2_remote_init(struct dvb_usb_device *d)
 				d->rc.interval);
 		schedule_delayed_work(&d->rc_query_work,
 				msecs_to_jiffies(d->rc.interval));
+		d->rc_polling_active = true;
 	}
 
 	return 0;
@@ -964,7 +968,7 @@ int dvb_usbv2_suspend(struct usb_interface *intf, pm_message_t msg)
 	dev_dbg(&d->udev->dev, "%s:\n", __func__);
 
 	/* stop remote controller poll */
-	if (d->rc.query && !d->rc.bulk_mode)
+	if (d->rc_polling_active)
 		cancel_delayed_work_sync(&d->rc_query_work);
 
 	for (i = MAX_NO_OF_ADAPTER_PER_DEVICE - 1; i >= 0; i--) {
@@ -1011,7 +1015,7 @@ static int dvb_usbv2_resume_common(struct dvb_usb_device *d)
 	}
 
 	/* start remote controller poll */
-	if (d->rc.query && !d->rc.bulk_mode)
+	if (d->rc_polling_active)
 		schedule_delayed_work(&d->rc_query_work,
 				msecs_to_jiffies(d->rc.interval));
 

commit ef3824029d0f5887c065ea461157bdf8b2287bf8
Author: Antti Palosaari <crope@iki.fi>
Date:   Sun Dec 9 20:46:46 2012 -0300

    [media] dvb_usb_v2: use dummy function defines instead stub functions
    
    I think it is better (cheaper) to use dummy defines for functions
    that has no meaning when remote controller is disabled by Kconfig.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
index 94f134c4e942..1330c644dd8d 100644
--- a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
+++ b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
@@ -204,15 +204,8 @@ static int dvb_usbv2_remote_exit(struct dvb_usb_device *d)
 	return 0;
 }
 #else
-static int dvb_usbv2_remote_init(struct dvb_usb_device *d)
-{
-	return 0;
-}
-
-static int dvb_usbv2_remote_exit(struct dvb_usb_device *d)
-{
-	return 0;
-}
+	#define dvb_usbv2_remote_init(args...) 0
+	#define dvb_usbv2_remote_exit(args...)
 #endif
 
 static void dvb_usb_data_complete(struct usb_data_stream *stream, u8 *buf,

commit 0c87c66aa383b045c437e7cf456eef28a8aa7b66
Author: Antti Palosaari <crope@iki.fi>
Date:   Thu Nov 29 00:05:35 2012 -0300

    [media] dvb_usb_v2: make remote controller optional
    
    Make it possible to compile dvb_usb_v2 driver without the remote
    controller (RC-core).
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
index 671b4fa232b4..94f134c4e942 100644
--- a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
+++ b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
@@ -102,6 +102,7 @@ static int dvb_usbv2_i2c_exit(struct dvb_usb_device *d)
 	return 0;
 }
 
+#if defined(CONFIG_RC_CORE) || defined(CONFIG_RC_CORE_MODULE)
 static void dvb_usb_read_remote_control(struct work_struct *work)
 {
 	struct dvb_usb_device *d = container_of(work,
@@ -202,6 +203,17 @@ static int dvb_usbv2_remote_exit(struct dvb_usb_device *d)
 
 	return 0;
 }
+#else
+static int dvb_usbv2_remote_init(struct dvb_usb_device *d)
+{
+	return 0;
+}
+
+static int dvb_usbv2_remote_exit(struct dvb_usb_device *d)
+{
+	return 0;
+}
+#endif
 
 static void dvb_usb_data_complete(struct usb_data_stream *stream, u8 *buf,
 		size_t len)

commit d033a308d81ec83908760a15a841c2bd0d5e0ea3
Merge: c6c22955f80f e23739b4ade8
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Wed Nov 28 07:22:38 2012 -0200

    Merge remote-tracking branch 'linus/master' into staging/for_v3.8
    
    * linus/master: (1428 commits)
      futex: avoid wake_futex() for a PI futex_q
      watchdog: using u64 in get_sample_period()
      writeback: put unused inodes to LRU after writeback completion
      mm: vmscan: check for fatal signals iff the process was throttled
      Revert "mm: remove __GFP_NO_KSWAPD"
      proc: check vma->vm_file before dereferencing
      UAPI: strip the _UAPI prefix from header guards during header installation
      include/linux/bug.h: fix sparse warning related to BUILD_BUG_ON_INVALID
      Linux 3.7-rc7
      powerpc/eeh: Do not invalidate PE properly
      ALSA: hda - Fix build without CONFIG_PM
      of/address: sparc: Declare of_iomap as an extern function for sparc again
      PM / QoS: fix wrong error-checking condition
      bnx2x: remove redundant warning log
      vxlan: fix command usage in its doc
      8139cp: revert "set ring address before enabling receiver"
      MPI: Fix compilation on MIPS with GCC 4.4 and newer
      MIPS: Fix crash that occurs when function tracing is enabled
      MIPS: Merge overlapping bootmem ranges
      jbd: Fix lock ordering bug in journal_unmap_buffer()
      ...

commit 2d9e7ea690d76b95a7eb3fd8eb3823b4f5946050
Author: Antti Palosaari <crope@iki.fi>
Date:   Tue Nov 6 17:23:35 2012 +0100

    [media] dvb_usb_v2: fix pid_filter callback error logging
    
    Code block braces were missing which leds broken error logging and compiler warning.
    
    drivers/media/usb/dvb-usb-v2/dvb_usb_core.c: In function 'dvb_usb_ctrl_feed':
    drivers/media/usb/dvb-usb-v2/dvb_usb_core.c:291:12: warning: 'ret' may be used uninitialized in this function [-Wuninitialized]
    
    Reported-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Reported-by: Milan Tuma <milan.olin@seznam.cz>
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
index 9859d2a2449b..ba51f65204de 100644
--- a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
+++ b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
@@ -283,14 +283,13 @@ static inline int dvb_usb_ctrl_feed(struct dvb_demux_feed *dvbdmxfeed,
 
 	/* activate the pid on the device pid filter */
 	if (adap->props->caps & DVB_USB_ADAP_HAS_PID_FILTER &&
-			adap->pid_filtering &&
-			adap->props->pid_filter)
+			adap->pid_filtering && adap->props->pid_filter) {
 		ret = adap->props->pid_filter(adap, dvbdmxfeed->index,
 				dvbdmxfeed->pid, (count == 1) ? 1 : 0);
-			if (ret < 0)
-				dev_err(&d->udev->dev, "%s: pid_filter() " \
-						"failed=%d\n", KBUILD_MODNAME,
-						ret);
+		if (ret < 0)
+			dev_err(&d->udev->dev, "%s: pid_filter() failed=%d\n",
+					KBUILD_MODNAME, ret);
+	}
 
 	/* start feeding if it is first pid */
 	if (adap->feed_count == 1 && count == 1) {

commit 691a5502e30c81e6570e1234e68c59d525727eda
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Sat Oct 27 14:08:45 2012 -0300

    [media] dvb-usb-v2: get rid of warning: no previous prototype
    
    drivers/media/usb/dvb-usb-v2/dvb_usb_core.c:227:5: warning: no previous prototype for 'dvb_usbv2_adapter_stream_init' [-Wmissing-prototypes]
    drivers/media/usb/dvb-usb-v2/dvb_usb_core.c:239:5: warning: no previous prototype for 'dvb_usbv2_adapter_stream_exit' [-Wmissing-prototypes]
    drivers/media/usb/dvb-usb-v2/dvb_usb_core.c:372:5: warning: no previous prototype for 'dvb_usbv2_adapter_dvb_init' [-Wmissing-prototypes]
    drivers/media/usb/dvb-usb-v2/dvb_usb_core.c:444:5: warning: no previous prototype for 'dvb_usbv2_adapter_dvb_exit' [-Wmissing-prototypes]
    drivers/media/usb/dvb-usb-v2/dvb_usb_core.c:460:5: warning: no previous prototype for 'dvb_usbv2_device_power_ctrl' [-Wmissing-prototypes]
    drivers/media/usb/dvb-usb-v2/dvb_usb_core.c:557:5: warning: no previous prototype for 'dvb_usbv2_adapter_frontend_init' [-Wmissing-prototypes]
    drivers/media/usb/dvb-usb-v2/dvb_usb_core.c:626:5: warning: no previous prototype for 'dvb_usbv2_adapter_frontend_exit' [-Wmissing-prototypes]
    drivers/media/usb/dvb-usb-v2/usb_urb.c:115:5: warning: no previous prototype for 'usb_urb_free_urbs' [-Wmissing-prototypes]
    drivers/media/usb/dvb-usb-v2/usb_urb.c:208:5: warning: no previous prototype for 'usb_free_stream_buffers' [-Wmissing-prototypes]
    drivers/media/usb/dvb-usb-v2/usb_urb.c:226:5: warning: no previous prototype for 'usb_alloc_stream_buffers' [-Wmissing-prototypes]
    
    Cc: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
index 9859d2a2449b..7927f5771e17 100644
--- a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
+++ b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
@@ -224,7 +224,7 @@ static void dvb_usb_data_complete_raw(struct usb_data_stream *stream, u8 *buf,
 	dvb_dmx_swfilter_raw(&adap->demux, buf, len);
 }
 
-int dvb_usbv2_adapter_stream_init(struct dvb_usb_adapter *adap)
+static int dvb_usbv2_adapter_stream_init(struct dvb_usb_adapter *adap)
 {
 	dev_dbg(&adap_to_d(adap)->udev->dev, "%s: adap=%d\n", __func__,
 			adap->id);
@@ -236,7 +236,7 @@ int dvb_usbv2_adapter_stream_init(struct dvb_usb_adapter *adap)
 	return usb_urb_initv2(&adap->stream, &adap->props->stream);
 }
 
-int dvb_usbv2_adapter_stream_exit(struct dvb_usb_adapter *adap)
+static int dvb_usbv2_adapter_stream_exit(struct dvb_usb_adapter *adap)
 {
 	dev_dbg(&adap_to_d(adap)->udev->dev, "%s: adap=%d\n", __func__,
 			adap->id);
@@ -369,7 +369,7 @@ static int dvb_usb_stop_feed(struct dvb_demux_feed *dvbdmxfeed)
 	return dvb_usb_ctrl_feed(dvbdmxfeed, -1);
 }
 
-int dvb_usbv2_adapter_dvb_init(struct dvb_usb_adapter *adap)
+static int dvb_usbv2_adapter_dvb_init(struct dvb_usb_adapter *adap)
 {
 	int ret;
 	struct dvb_usb_device *d = adap_to_d(adap);
@@ -441,7 +441,7 @@ int dvb_usbv2_adapter_dvb_init(struct dvb_usb_adapter *adap)
 	return ret;
 }
 
-int dvb_usbv2_adapter_dvb_exit(struct dvb_usb_adapter *adap)
+static int dvb_usbv2_adapter_dvb_exit(struct dvb_usb_adapter *adap)
 {
 	dev_dbg(&adap_to_d(adap)->udev->dev, "%s: adap=%d\n", __func__,
 			adap->id);
@@ -457,7 +457,7 @@ int dvb_usbv2_adapter_dvb_exit(struct dvb_usb_adapter *adap)
 	return 0;
 }
 
-int dvb_usbv2_device_power_ctrl(struct dvb_usb_device *d, int onoff)
+static int dvb_usbv2_device_power_ctrl(struct dvb_usb_device *d, int onoff)
 {
 	int ret;
 
@@ -554,7 +554,7 @@ static int dvb_usb_fe_sleep(struct dvb_frontend *fe)
 	return ret;
 }
 
-int dvb_usbv2_adapter_frontend_init(struct dvb_usb_adapter *adap)
+static int dvb_usbv2_adapter_frontend_init(struct dvb_usb_adapter *adap)
 {
 	int ret, i, count_registered = 0;
 	struct dvb_usb_device *d = adap_to_d(adap);
@@ -623,7 +623,7 @@ int dvb_usbv2_adapter_frontend_init(struct dvb_usb_adapter *adap)
 	return ret;
 }
 
-int dvb_usbv2_adapter_frontend_exit(struct dvb_usb_adapter *adap)
+static int dvb_usbv2_adapter_frontend_exit(struct dvb_usb_adapter *adap)
 {
 	int i;
 	dev_dbg(&adap_to_d(adap)->udev->dev, "%s: adap=%d\n", __func__,

commit 2a858486e0406110541e13f07d00665ee0c08a54
Author: Antti Palosaari <crope@iki.fi>
Date:   Fri Sep 21 23:23:49 2012 -0300

    [media] dvb_usb_v2: fix error handling for .tuner_attach()
    
    fe was not set NULL after it was destroyed in tuner attach fail
    error case. Due to that it was destroyed again and Kernel oopsed.
    
    Reported-by: Oliver Schinagl <oliver@schinagl.nl>
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
index f99015937957..9859d2a2449b 100644
--- a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
+++ b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
@@ -612,8 +612,10 @@ int dvb_usbv2_adapter_frontend_init(struct dvb_usb_adapter *adap)
 
 err_dvb_frontend_detach:
 	for (i = MAX_NO_OF_FE_PER_ADAP - 1; i >= 0; i--) {
-		if (adap->fe[i])
+		if (adap->fe[i]) {
 			dvb_frontend_detach(adap->fe[i]);
+			adap->fe[i] = NULL;
+		}
 	}
 
 err:

commit 0fe688f1383917ab90747fc41e11b393f33c97e8
Author: Antti Palosaari <crope@iki.fi>
Date:   Mon Sep 10 22:04:43 2012 -0300

    [media] dvb_usb_v2: call streaming_ctrl() before kill urbs
    
    Logically it is better ask hardware to stop streaming before
    killing urbs carrying stream. Earlier it was just opposite.
    Now code runs:
    * submit urbs
    * start streaming
    ** streaming ongoing **
    * stop streaming
    * kill urbs
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
index e2d73e1a7ae0..f99015937957 100644
--- a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
+++ b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
@@ -265,7 +265,6 @@ static inline int dvb_usb_ctrl_feed(struct dvb_demux_feed *dvbdmxfeed,
 	/* stop feeding if it is last pid */
 	if (adap->feed_count == 0) {
 		dev_dbg(&d->udev->dev, "%s: stop feeding\n", __func__);
-		usb_urb_killv2(&adap->stream);
 
 		if (d->props->streaming_ctrl) {
 			ret = d->props->streaming_ctrl(
@@ -274,9 +273,11 @@ static inline int dvb_usb_ctrl_feed(struct dvb_demux_feed *dvbdmxfeed,
 				dev_err(&d->udev->dev, "%s: streaming_ctrl() " \
 						"failed=%d\n", KBUILD_MODNAME,
 						ret);
+				usb_urb_killv2(&adap->stream);
 				goto err_mutex_unlock;
 			}
 		}
+		usb_urb_killv2(&adap->stream);
 		mutex_unlock(&adap->sync_mutex);
 	}
 

commit 15d0883663edccea29eeb9790052a11dd9977157
Author: Antti Palosaari <crope@iki.fi>
Date:   Tue Aug 14 22:21:07 2012 -0300

    [media] dvb_usb_v2: .reset_resume() support
    
    Add .reset_resume() support.
    Also some other small changes for suspend / resume.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
index a0e70e91834a..e2d73e1a7ae0 100644
--- a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
+++ b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
@@ -952,7 +952,7 @@ EXPORT_SYMBOL(dvb_usbv2_disconnect);
 int dvb_usbv2_suspend(struct usb_interface *intf, pm_message_t msg)
 {
 	struct dvb_usb_device *d = usb_get_intfdata(intf);
-	int i, active_fe;
+	int ret = 0, i, active_fe;
 	struct dvb_frontend *fe;
 	dev_dbg(&d->udev->dev, "%s:\n", __func__);
 
@@ -972,18 +972,17 @@ int dvb_usbv2_suspend(struct usb_interface *intf, pm_message_t msg)
 			/* stop usb streaming */
 			usb_urb_killv2(&d->adapter[i].stream);
 
-			dvb_frontend_suspend(fe);
+			ret = dvb_frontend_suspend(fe);
 		}
 	}
 
-	return 0;
+	return ret;
 }
 EXPORT_SYMBOL(dvb_usbv2_suspend);
 
-int dvb_usbv2_resume(struct usb_interface *intf)
+static int dvb_usbv2_resume_common(struct dvb_usb_device *d)
 {
-	struct dvb_usb_device *d = usb_get_intfdata(intf);
-	int i, active_fe;
+	int ret = 0, i, active_fe;
 	struct dvb_frontend *fe;
 	dev_dbg(&d->udev->dev, "%s:\n", __func__);
 
@@ -992,7 +991,7 @@ int dvb_usbv2_resume(struct usb_interface *intf)
 		if (d->adapter[i].dvb_adap.priv && active_fe != -1) {
 			fe = d->adapter[i].fe[active_fe];
 
-			dvb_frontend_resume(fe);
+			ret = dvb_frontend_resume(fe);
 
 			/* resume usb streaming */
 			usb_urb_submitv2(&d->adapter[i].stream, NULL);
@@ -1009,10 +1008,37 @@ int dvb_usbv2_resume(struct usb_interface *intf)
 		schedule_delayed_work(&d->rc_query_work,
 				msecs_to_jiffies(d->rc.interval));
 
-	return 0;
+	return ret;
+}
+
+int dvb_usbv2_resume(struct usb_interface *intf)
+{
+	struct dvb_usb_device *d = usb_get_intfdata(intf);
+	dev_dbg(&d->udev->dev, "%s:\n", __func__);
+
+	return dvb_usbv2_resume_common(d);
 }
 EXPORT_SYMBOL(dvb_usbv2_resume);
 
+int dvb_usbv2_reset_resume(struct usb_interface *intf)
+{
+	struct dvb_usb_device *d = usb_get_intfdata(intf);
+	int ret;
+	dev_dbg(&d->udev->dev, "%s:\n", __func__);
+
+	dvb_usbv2_device_power_ctrl(d, 1);
+
+	if (d->props->init)
+		d->props->init(d);
+
+	ret = dvb_usbv2_resume_common(d);
+
+	dvb_usbv2_device_power_ctrl(d, 0);
+
+	return ret;
+}
+EXPORT_SYMBOL(dvb_usbv2_reset_resume);
+
 MODULE_VERSION("2.0");
 MODULE_AUTHOR("Patrick Boettcher <patrick.boettcher@desy.de>");
 MODULE_AUTHOR("Antti Palosaari <crope@iki.fi>");

commit 06bae1227aadf51d047f7a75834ed446e56ebae2
Author: Antti Palosaari <crope@iki.fi>
Date:   Tue Aug 14 22:21:06 2012 -0300

    [media] dvb_frontend: implement suspend / resume
    
    Move initial suspend / resume support from dvb_usb_v2 to dvb_frontend
    as it is dvb general feature that could be used all dvb devices.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
index 7ce8ffef8aca..a0e70e91834a 100644
--- a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
+++ b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
@@ -489,6 +489,11 @@ static int dvb_usb_fe_init(struct dvb_frontend *fe)
 	dev_dbg(&d->udev->dev, "%s: adap=%d fe=%d\n", __func__, adap->id,
 			fe->id);
 
+	if (!adap->suspend_resume_active) {
+		adap->active_fe = fe->id;
+		mutex_lock(&adap->sync_mutex);
+	}
+
 	ret = dvb_usbv2_device_power_ctrl(d, 1);
 	if (ret < 0)
 		goto err;
@@ -504,23 +509,11 @@ static int dvb_usb_fe_init(struct dvb_frontend *fe)
 		if (ret < 0)
 			goto err;
 	}
-
-	return 0;
 err:
-	dev_dbg(&d->udev->dev, "%s: failed=%d\n", __func__, ret);
-	return ret;
-}
-
-static int dvb_usb_fe_init_lock(struct dvb_frontend *fe)
-{
-	int ret;
-	struct dvb_usb_adapter *adap = fe->dvb->priv;
-	mutex_lock(&adap->sync_mutex);
-
-	ret = dvb_usb_fe_init(fe);
-	adap->active_fe = fe->id;
+	if (!adap->suspend_resume_active)
+		mutex_unlock(&adap->sync_mutex);
 
-	mutex_unlock(&adap->sync_mutex);
+	dev_dbg(&d->udev->dev, "%s: ret=%d\n", __func__, ret);
 	return ret;
 }
 
@@ -532,6 +525,9 @@ static int dvb_usb_fe_sleep(struct dvb_frontend *fe)
 	dev_dbg(&d->udev->dev, "%s: adap=%d fe=%d\n", __func__, adap->id,
 			fe->id);
 
+	if (!adap->suspend_resume_active)
+		mutex_lock(&adap->sync_mutex);
+
 	if (adap->fe_sleep[fe->id]) {
 		ret = adap->fe_sleep[fe->id](fe);
 		if (ret < 0)
@@ -547,23 +543,13 @@ static int dvb_usb_fe_sleep(struct dvb_frontend *fe)
 	ret = dvb_usbv2_device_power_ctrl(d, 0);
 	if (ret < 0)
 		goto err;
-
-	return 0;
 err:
-	dev_dbg(&d->udev->dev, "%s: failed=%d\n", __func__, ret);
-	return ret;
-}
-
-static int dvb_usb_fe_sleep_lock(struct dvb_frontend *fe)
-{
-	int ret;
-	struct dvb_usb_adapter *adap = fe->dvb->priv;
-	mutex_lock(&adap->sync_mutex);
-
-	ret = dvb_usb_fe_sleep(fe);
-	adap->active_fe = -1;
+	if (!adap->suspend_resume_active) {
+		adap->active_fe = -1;
+		mutex_unlock(&adap->sync_mutex);
+	}
 
-	mutex_unlock(&adap->sync_mutex);
+	dev_dbg(&d->udev->dev, "%s: ret=%d\n", __func__, ret);
 	return ret;
 }
 
@@ -594,9 +580,9 @@ int dvb_usbv2_adapter_frontend_init(struct dvb_usb_adapter *adap)
 		adap->fe[i]->id = i;
 		/* re-assign sleep and wakeup functions */
 		adap->fe_init[i] = adap->fe[i]->ops.init;
-		adap->fe[i]->ops.init = dvb_usb_fe_init_lock;
+		adap->fe[i]->ops.init = dvb_usb_fe_init;
 		adap->fe_sleep[i] = adap->fe[i]->ops.sleep;
-		adap->fe[i]->ops.sleep = dvb_usb_fe_sleep_lock;
+		adap->fe[i]->ops.sleep = dvb_usb_fe_sleep;
 
 		ret = dvb_register_frontend(&adap->dvb_adap, adap->fe[i]);
 		if (ret < 0) {
@@ -978,6 +964,7 @@ int dvb_usbv2_suspend(struct usb_interface *intf, pm_message_t msg)
 		active_fe = d->adapter[i].active_fe;
 		if (d->adapter[i].dvb_adap.priv && active_fe != -1) {
 			fe = d->adapter[i].fe[active_fe];
+			d->adapter[i].suspend_resume_active = true;
 
 			if (d->props->streaming_ctrl)
 				d->props->streaming_ctrl(fe, 0);
@@ -985,10 +972,7 @@ int dvb_usbv2_suspend(struct usb_interface *intf, pm_message_t msg)
 			/* stop usb streaming */
 			usb_urb_killv2(&d->adapter[i].stream);
 
-			if (fe->ops.tuner_ops.sleep)
-				fe->ops.tuner_ops.sleep(fe);
-
-			dvb_usb_fe_sleep(fe);
+			dvb_frontend_suspend(fe);
 		}
 	}
 
@@ -1008,19 +992,15 @@ int dvb_usbv2_resume(struct usb_interface *intf)
 		if (d->adapter[i].dvb_adap.priv && active_fe != -1) {
 			fe = d->adapter[i].fe[active_fe];
 
-			dvb_usb_fe_init(fe);
-
-			if (fe->ops.tuner_ops.init)
-				fe->ops.tuner_ops.init(fe);
-
-			/* acquire dvb-core perform retune */
-			dvb_frontend_retune(fe);
+			dvb_frontend_resume(fe);
 
 			/* resume usb streaming */
 			usb_urb_submitv2(&d->adapter[i].stream, NULL);
 
 			if (d->props->streaming_ctrl)
 				d->props->streaming_ctrl(fe, 1);
+
+			d->adapter[i].suspend_resume_active = false;
 		}
 	}
 

commit 0898b95409489abd7219f5f7ca675c84656fb94f
Author: Antti Palosaari <crope@iki.fi>
Date:   Tue Aug 14 22:21:05 2012 -0300

    [media] dvb_usb_v2: implement power-management for suspend
    
    Put device full sleep on suspend, wake-up it on resume and acquire
    retune in order to return same television channel.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
index a72f9c7de682..7ce8ffef8aca 100644
--- a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
+++ b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
@@ -486,7 +486,6 @@ static int dvb_usb_fe_init(struct dvb_frontend *fe)
 	int ret;
 	struct dvb_usb_adapter *adap = fe->dvb->priv;
 	struct dvb_usb_device *d = adap_to_d(adap);
-	mutex_lock(&adap->sync_mutex);
 	dev_dbg(&d->udev->dev, "%s: adap=%d fe=%d\n", __func__, adap->id,
 			fe->id);
 
@@ -506,22 +505,30 @@ static int dvb_usb_fe_init(struct dvb_frontend *fe)
 			goto err;
 	}
 
-	adap->active_fe = fe->id;
-	mutex_unlock(&adap->sync_mutex);
-
 	return 0;
 err:
-	mutex_unlock(&adap->sync_mutex);
 	dev_dbg(&d->udev->dev, "%s: failed=%d\n", __func__, ret);
 	return ret;
 }
 
+static int dvb_usb_fe_init_lock(struct dvb_frontend *fe)
+{
+	int ret;
+	struct dvb_usb_adapter *adap = fe->dvb->priv;
+	mutex_lock(&adap->sync_mutex);
+
+	ret = dvb_usb_fe_init(fe);
+	adap->active_fe = fe->id;
+
+	mutex_unlock(&adap->sync_mutex);
+	return ret;
+}
+
 static int dvb_usb_fe_sleep(struct dvb_frontend *fe)
 {
 	int ret;
 	struct dvb_usb_adapter *adap = fe->dvb->priv;
 	struct dvb_usb_device *d = adap_to_d(adap);
-	mutex_lock(&adap->sync_mutex);
 	dev_dbg(&d->udev->dev, "%s: adap=%d fe=%d\n", __func__, adap->id,
 			fe->id);
 
@@ -541,16 +548,25 @@ static int dvb_usb_fe_sleep(struct dvb_frontend *fe)
 	if (ret < 0)
 		goto err;
 
-	adap->active_fe = -1;
-	mutex_unlock(&adap->sync_mutex);
-
 	return 0;
 err:
-	mutex_unlock(&adap->sync_mutex);
 	dev_dbg(&d->udev->dev, "%s: failed=%d\n", __func__, ret);
 	return ret;
 }
 
+static int dvb_usb_fe_sleep_lock(struct dvb_frontend *fe)
+{
+	int ret;
+	struct dvb_usb_adapter *adap = fe->dvb->priv;
+	mutex_lock(&adap->sync_mutex);
+
+	ret = dvb_usb_fe_sleep(fe);
+	adap->active_fe = -1;
+
+	mutex_unlock(&adap->sync_mutex);
+	return ret;
+}
+
 int dvb_usbv2_adapter_frontend_init(struct dvb_usb_adapter *adap)
 {
 	int ret, i, count_registered = 0;
@@ -578,9 +594,9 @@ int dvb_usbv2_adapter_frontend_init(struct dvb_usb_adapter *adap)
 		adap->fe[i]->id = i;
 		/* re-assign sleep and wakeup functions */
 		adap->fe_init[i] = adap->fe[i]->ops.init;
-		adap->fe[i]->ops.init = dvb_usb_fe_init;
+		adap->fe[i]->ops.init = dvb_usb_fe_init_lock;
 		adap->fe_sleep[i] = adap->fe[i]->ops.sleep;
-		adap->fe[i]->ops.sleep = dvb_usb_fe_sleep;
+		adap->fe[i]->ops.sleep = dvb_usb_fe_sleep_lock;
 
 		ret = dvb_register_frontend(&adap->dvb_adap, adap->fe[i]);
 		if (ret < 0) {
@@ -950,18 +966,30 @@ EXPORT_SYMBOL(dvb_usbv2_disconnect);
 int dvb_usbv2_suspend(struct usb_interface *intf, pm_message_t msg)
 {
 	struct dvb_usb_device *d = usb_get_intfdata(intf);
-	int i;
+	int i, active_fe;
+	struct dvb_frontend *fe;
 	dev_dbg(&d->udev->dev, "%s:\n", __func__);
 
 	/* stop remote controller poll */
 	if (d->rc.query && !d->rc.bulk_mode)
 		cancel_delayed_work_sync(&d->rc_query_work);
 
-	/* stop streaming */
 	for (i = MAX_NO_OF_ADAPTER_PER_DEVICE - 1; i >= 0; i--) {
-		if (d->adapter[i].dvb_adap.priv &&
-				d->adapter[i].active_fe != -1)
+		active_fe = d->adapter[i].active_fe;
+		if (d->adapter[i].dvb_adap.priv && active_fe != -1) {
+			fe = d->adapter[i].fe[active_fe];
+
+			if (d->props->streaming_ctrl)
+				d->props->streaming_ctrl(fe, 0);
+
+			/* stop usb streaming */
 			usb_urb_killv2(&d->adapter[i].stream);
+
+			if (fe->ops.tuner_ops.sleep)
+				fe->ops.tuner_ops.sleep(fe);
+
+			dvb_usb_fe_sleep(fe);
+		}
 	}
 
 	return 0;
@@ -971,14 +999,29 @@ EXPORT_SYMBOL(dvb_usbv2_suspend);
 int dvb_usbv2_resume(struct usb_interface *intf)
 {
 	struct dvb_usb_device *d = usb_get_intfdata(intf);
-	int i;
+	int i, active_fe;
+	struct dvb_frontend *fe;
 	dev_dbg(&d->udev->dev, "%s:\n", __func__);
 
-	/* start streaming */
 	for (i = 0; i < MAX_NO_OF_ADAPTER_PER_DEVICE; i++) {
-		if (d->adapter[i].dvb_adap.priv &&
-				d->adapter[i].active_fe != -1)
+		active_fe = d->adapter[i].active_fe;
+		if (d->adapter[i].dvb_adap.priv && active_fe != -1) {
+			fe = d->adapter[i].fe[active_fe];
+
+			dvb_usb_fe_init(fe);
+
+			if (fe->ops.tuner_ops.init)
+				fe->ops.tuner_ops.init(fe);
+
+			/* acquire dvb-core perform retune */
+			dvb_frontend_retune(fe);
+
+			/* resume usb streaming */
 			usb_urb_submitv2(&d->adapter[i].stream, NULL);
+
+			if (d->props->streaming_ctrl)
+				d->props->streaming_ctrl(fe, 1);
+		}
 	}
 
 	/* start remote controller poll */

commit 786baecfe78f8e25547c628b48a60fc8e5636056
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Thu Jun 14 16:35:56 2012 -0300

    [media] dvb-usb: move it to drivers/media/usb/dvb-usb
    
    As media/dvb will be removed, move it to a proper place.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
new file mode 100644
index 000000000000..a72f9c7de682
--- /dev/null
+++ b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c
@@ -0,0 +1,997 @@
+/*
+ * DVB USB framework
+ *
+ * Copyright (C) 2004-6 Patrick Boettcher <patrick.boettcher@desy.de>
+ * Copyright (C) 2012 Antti Palosaari <crope@iki.fi>
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License along
+ *    with this program; if not, write to the Free Software Foundation, Inc.,
+ *    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include "dvb_usb_common.h"
+
+int dvb_usbv2_disable_rc_polling;
+module_param_named(disable_rc_polling, dvb_usbv2_disable_rc_polling, int, 0644);
+MODULE_PARM_DESC(disable_rc_polling,
+		"disable remote control polling (default: 0)");
+static int dvb_usb_force_pid_filter_usage;
+module_param_named(force_pid_filter_usage, dvb_usb_force_pid_filter_usage,
+		int, 0444);
+MODULE_PARM_DESC(force_pid_filter_usage, "force all DVB USB devices to use a " \
+		"PID filter, if any (default: 0)");
+
+static int dvb_usbv2_download_firmware(struct dvb_usb_device *d, const char *name)
+{
+	int ret;
+	const struct firmware *fw;
+	dev_dbg(&d->udev->dev, "%s:\n", __func__);
+
+	if (!d->props->download_firmware) {
+		ret = -EINVAL;
+		goto err;
+	}
+
+	ret = request_firmware(&fw, name, &d->udev->dev);
+	if (ret < 0) {
+		dev_err(&d->udev->dev, "%s: Did not find the firmware file "\
+				"'%s'. Please see linux/Documentation/dvb/ " \
+				"for more details on firmware-problems. " \
+				"Status %d\n", KBUILD_MODNAME, name, ret);
+		goto err;
+	}
+
+	dev_info(&d->udev->dev, "%s: downloading firmware from file '%s'\n",
+			KBUILD_MODNAME, name);
+
+	ret = d->props->download_firmware(d, fw);
+	release_firmware(fw);
+	if (ret < 0)
+		goto err;
+
+	return ret;
+err:
+	dev_dbg(&d->udev->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+
+static int dvb_usbv2_i2c_init(struct dvb_usb_device *d)
+{
+	int ret;
+	dev_dbg(&d->udev->dev, "%s:\n", __func__);
+
+	if (!d->props->i2c_algo)
+		return 0;
+
+	strlcpy(d->i2c_adap.name, d->name, sizeof(d->i2c_adap.name));
+	d->i2c_adap.algo = d->props->i2c_algo;
+	d->i2c_adap.dev.parent = &d->udev->dev;
+	i2c_set_adapdata(&d->i2c_adap, d);
+
+	ret = i2c_add_adapter(&d->i2c_adap);
+	if (ret < 0) {
+		d->i2c_adap.algo = NULL;
+		dev_err(&d->udev->dev, "%s: i2c_add_adapter() failed=%d\n",
+				KBUILD_MODNAME, ret);
+		goto err;
+	}
+
+	return 0;
+err:
+	dev_dbg(&d->udev->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+
+static int dvb_usbv2_i2c_exit(struct dvb_usb_device *d)
+{
+	dev_dbg(&d->udev->dev, "%s:\n", __func__);
+
+	if (d->i2c_adap.algo)
+		i2c_del_adapter(&d->i2c_adap);
+
+	return 0;
+}
+
+static void dvb_usb_read_remote_control(struct work_struct *work)
+{
+	struct dvb_usb_device *d = container_of(work,
+			struct dvb_usb_device, rc_query_work.work);
+	int ret;
+
+	/*
+	 * When the parameter has been set to 1 via sysfs while the
+	 * driver was running, or when bulk mode is enabled after IR init.
+	 */
+	if (dvb_usbv2_disable_rc_polling || d->rc.bulk_mode)
+		return;
+
+	ret = d->rc.query(d);
+	if (ret < 0) {
+		dev_err(&d->udev->dev, "%s: rc.query() failed=%d\n",
+				KBUILD_MODNAME, ret);
+		return; /* stop polling */
+	}
+
+	schedule_delayed_work(&d->rc_query_work,
+			msecs_to_jiffies(d->rc.interval));
+}
+
+static int dvb_usbv2_remote_init(struct dvb_usb_device *d)
+{
+	int ret;
+	struct rc_dev *dev;
+	dev_dbg(&d->udev->dev, "%s:\n", __func__);
+
+	if (dvb_usbv2_disable_rc_polling || !d->props->get_rc_config)
+		return 0;
+
+	d->rc.map_name = d->rc_map;
+	ret = d->props->get_rc_config(d, &d->rc);
+	if (ret < 0)
+		goto err;
+
+	/* disable rc when there is no keymap defined */
+	if (!d->rc.map_name)
+		return 0;
+
+	dev = rc_allocate_device();
+	if (!dev) {
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	dev->dev.parent = &d->udev->dev;
+	dev->input_name = d->name;
+	usb_make_path(d->udev, d->rc_phys, sizeof(d->rc_phys));
+	strlcat(d->rc_phys, "/ir0", sizeof(d->rc_phys));
+	dev->input_phys = d->rc_phys;
+	usb_to_input_id(d->udev, &dev->input_id);
+	/* TODO: likely RC-core should took const char * */
+	dev->driver_name = (char *) d->props->driver_name;
+	dev->map_name = d->rc.map_name;
+	dev->driver_type = d->rc.driver_type;
+	dev->allowed_protos = d->rc.allowed_protos;
+	dev->change_protocol = d->rc.change_protocol;
+	dev->priv = d;
+
+	ret = rc_register_device(dev);
+	if (ret < 0) {
+		rc_free_device(dev);
+		goto err;
+	}
+
+	d->rc_dev = dev;
+
+	/* start polling if needed */
+	if (d->rc.query && !d->rc.bulk_mode) {
+		/* initialize a work queue for handling polling */
+		INIT_DELAYED_WORK(&d->rc_query_work,
+				dvb_usb_read_remote_control);
+		dev_info(&d->udev->dev, "%s: schedule remote query interval " \
+				"to %d msecs\n", KBUILD_MODNAME,
+				d->rc.interval);
+		schedule_delayed_work(&d->rc_query_work,
+				msecs_to_jiffies(d->rc.interval));
+	}
+
+	return 0;
+err:
+	dev_dbg(&d->udev->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+
+static int dvb_usbv2_remote_exit(struct dvb_usb_device *d)
+{
+	dev_dbg(&d->udev->dev, "%s:\n", __func__);
+
+	if (d->rc_dev) {
+		cancel_delayed_work_sync(&d->rc_query_work);
+		rc_unregister_device(d->rc_dev);
+		d->rc_dev = NULL;
+	}
+
+	return 0;
+}
+
+static void dvb_usb_data_complete(struct usb_data_stream *stream, u8 *buf,
+		size_t len)
+{
+	struct dvb_usb_adapter *adap = stream->user_priv;
+	dvb_dmx_swfilter(&adap->demux, buf, len);
+}
+
+static void dvb_usb_data_complete_204(struct usb_data_stream *stream, u8 *buf,
+		size_t len)
+{
+	struct dvb_usb_adapter *adap = stream->user_priv;
+	dvb_dmx_swfilter_204(&adap->demux, buf, len);
+}
+
+static void dvb_usb_data_complete_raw(struct usb_data_stream *stream, u8 *buf,
+		size_t len)
+{
+	struct dvb_usb_adapter *adap = stream->user_priv;
+	dvb_dmx_swfilter_raw(&adap->demux, buf, len);
+}
+
+int dvb_usbv2_adapter_stream_init(struct dvb_usb_adapter *adap)
+{
+	dev_dbg(&adap_to_d(adap)->udev->dev, "%s: adap=%d\n", __func__,
+			adap->id);
+
+	adap->stream.udev = adap_to_d(adap)->udev;
+	adap->stream.user_priv = adap;
+	adap->stream.complete = dvb_usb_data_complete;
+
+	return usb_urb_initv2(&adap->stream, &adap->props->stream);
+}
+
+int dvb_usbv2_adapter_stream_exit(struct dvb_usb_adapter *adap)
+{
+	dev_dbg(&adap_to_d(adap)->udev->dev, "%s: adap=%d\n", __func__,
+			adap->id);
+
+	return usb_urb_exitv2(&adap->stream);
+}
+
+static inline int dvb_usb_ctrl_feed(struct dvb_demux_feed *dvbdmxfeed,
+		int count)
+{
+	struct dvb_usb_adapter *adap = dvbdmxfeed->demux->priv;
+	struct dvb_usb_device *d = adap_to_d(adap);
+	int ret;
+	dev_dbg(&d->udev->dev, "%s: adap=%d active_fe=%d feed_type=%d " \
+			"setting pid [%s]: %04x (%04d) at index %d '%s'\n",
+			__func__, adap->id, adap->active_fe, dvbdmxfeed->type,
+			adap->pid_filtering ? "yes" : "no", dvbdmxfeed->pid,
+			dvbdmxfeed->pid, dvbdmxfeed->index,
+			(count == 1) ? "on" : "off");
+
+	if (adap->active_fe == -1)
+		return -EINVAL;
+
+	adap->feed_count += count;
+
+	/* stop feeding if it is last pid */
+	if (adap->feed_count == 0) {
+		dev_dbg(&d->udev->dev, "%s: stop feeding\n", __func__);
+		usb_urb_killv2(&adap->stream);
+
+		if (d->props->streaming_ctrl) {
+			ret = d->props->streaming_ctrl(
+					adap->fe[adap->active_fe], 0);
+			if (ret < 0) {
+				dev_err(&d->udev->dev, "%s: streaming_ctrl() " \
+						"failed=%d\n", KBUILD_MODNAME,
+						ret);
+				goto err_mutex_unlock;
+			}
+		}
+		mutex_unlock(&adap->sync_mutex);
+	}
+
+	/* activate the pid on the device pid filter */
+	if (adap->props->caps & DVB_USB_ADAP_HAS_PID_FILTER &&
+			adap->pid_filtering &&
+			adap->props->pid_filter)
+		ret = adap->props->pid_filter(adap, dvbdmxfeed->index,
+				dvbdmxfeed->pid, (count == 1) ? 1 : 0);
+			if (ret < 0)
+				dev_err(&d->udev->dev, "%s: pid_filter() " \
+						"failed=%d\n", KBUILD_MODNAME,
+						ret);
+
+	/* start feeding if it is first pid */
+	if (adap->feed_count == 1 && count == 1) {
+		struct usb_data_stream_properties stream_props;
+		mutex_lock(&adap->sync_mutex);
+		dev_dbg(&d->udev->dev, "%s: start feeding\n", __func__);
+
+		/* resolve input and output streaming paramters */
+		if (d->props->get_stream_config) {
+			memcpy(&stream_props, &adap->props->stream,
+				sizeof(struct usb_data_stream_properties));
+			ret = d->props->get_stream_config(
+					adap->fe[adap->active_fe],
+					&adap->ts_type, &stream_props);
+			if (ret < 0)
+				goto err_mutex_unlock;
+		} else {
+			stream_props = adap->props->stream;
+		}
+
+		switch (adap->ts_type) {
+		case DVB_USB_FE_TS_TYPE_204:
+			adap->stream.complete = dvb_usb_data_complete_204;
+			break;
+		case DVB_USB_FE_TS_TYPE_RAW:
+			adap->stream.complete = dvb_usb_data_complete_raw;
+			break;
+		case DVB_USB_FE_TS_TYPE_188:
+		default:
+			adap->stream.complete = dvb_usb_data_complete;
+			break;
+		}
+
+		usb_urb_submitv2(&adap->stream, &stream_props);
+
+		if (adap->props->caps & DVB_USB_ADAP_HAS_PID_FILTER &&
+				adap->props->caps &
+				DVB_USB_ADAP_PID_FILTER_CAN_BE_TURNED_OFF &&
+				adap->props->pid_filter_ctrl) {
+			ret = adap->props->pid_filter_ctrl(adap,
+					adap->pid_filtering);
+			if (ret < 0) {
+				dev_err(&d->udev->dev, "%s: " \
+						"pid_filter_ctrl() failed=%d\n",
+						KBUILD_MODNAME, ret);
+				goto err_mutex_unlock;
+			}
+		}
+
+		if (d->props->streaming_ctrl) {
+			ret = d->props->streaming_ctrl(
+					adap->fe[adap->active_fe], 1);
+			if (ret < 0) {
+				dev_err(&d->udev->dev, "%s: streaming_ctrl() " \
+						"failed=%d\n", KBUILD_MODNAME,
+						ret);
+				goto err_mutex_unlock;
+			}
+		}
+	}
+
+	return 0;
+err_mutex_unlock:
+	mutex_unlock(&adap->sync_mutex);
+	dev_dbg(&d->udev->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+
+static int dvb_usb_start_feed(struct dvb_demux_feed *dvbdmxfeed)
+{
+	return dvb_usb_ctrl_feed(dvbdmxfeed, 1);
+}
+
+static int dvb_usb_stop_feed(struct dvb_demux_feed *dvbdmxfeed)
+{
+	return dvb_usb_ctrl_feed(dvbdmxfeed, -1);
+}
+
+int dvb_usbv2_adapter_dvb_init(struct dvb_usb_adapter *adap)
+{
+	int ret;
+	struct dvb_usb_device *d = adap_to_d(adap);
+	dev_dbg(&d->udev->dev, "%s: adap=%d\n", __func__, adap->id);
+
+	ret = dvb_register_adapter(&adap->dvb_adap, d->name, d->props->owner,
+			&d->udev->dev, d->props->adapter_nr);
+	if (ret < 0) {
+		dev_dbg(&d->udev->dev, "%s: dvb_register_adapter() failed=%d\n",
+				__func__, ret);
+		goto err_dvb_register_adapter;
+	}
+
+	adap->dvb_adap.priv = adap;
+
+	if (d->props->read_mac_address) {
+		ret = d->props->read_mac_address(adap,
+				adap->dvb_adap.proposed_mac);
+		if (ret < 0)
+			goto err_dvb_dmx_init;
+
+		dev_info(&d->udev->dev, "%s: MAC address: %pM\n",
+				KBUILD_MODNAME, adap->dvb_adap.proposed_mac);
+	}
+
+	adap->demux.dmx.capabilities = DMX_TS_FILTERING | DMX_SECTION_FILTERING;
+	adap->demux.priv             = adap;
+	adap->demux.filternum        = 0;
+	adap->demux.filternum        = adap->max_feed_count;
+	adap->demux.feednum          = adap->demux.filternum;
+	adap->demux.start_feed       = dvb_usb_start_feed;
+	adap->demux.stop_feed        = dvb_usb_stop_feed;
+	adap->demux.write_to_decoder = NULL;
+	ret = dvb_dmx_init(&adap->demux);
+	if (ret < 0) {
+		dev_err(&d->udev->dev, "%s: dvb_dmx_init() failed=%d\n",
+				KBUILD_MODNAME, ret);
+		goto err_dvb_dmx_init;
+	}
+
+	adap->dmxdev.filternum       = adap->demux.filternum;
+	adap->dmxdev.demux           = &adap->demux.dmx;
+	adap->dmxdev.capabilities    = 0;
+	ret = dvb_dmxdev_init(&adap->dmxdev, &adap->dvb_adap);
+	if (ret < 0) {
+		dev_err(&d->udev->dev, "%s: dvb_dmxdev_init() failed=%d\n",
+				KBUILD_MODNAME, ret);
+		goto err_dvb_dmxdev_init;
+	}
+
+	ret = dvb_net_init(&adap->dvb_adap, &adap->dvb_net, &adap->demux.dmx);
+	if (ret < 0) {
+		dev_err(&d->udev->dev, "%s: dvb_net_init() failed=%d\n",
+				KBUILD_MODNAME, ret);
+		goto err_dvb_net_init;
+	}
+
+	mutex_init(&adap->sync_mutex);
+
+	return 0;
+err_dvb_net_init:
+	dvb_dmxdev_release(&adap->dmxdev);
+err_dvb_dmxdev_init:
+	dvb_dmx_release(&adap->demux);
+err_dvb_dmx_init:
+	dvb_unregister_adapter(&adap->dvb_adap);
+err_dvb_register_adapter:
+	adap->dvb_adap.priv = NULL;
+	return ret;
+}
+
+int dvb_usbv2_adapter_dvb_exit(struct dvb_usb_adapter *adap)
+{
+	dev_dbg(&adap_to_d(adap)->udev->dev, "%s: adap=%d\n", __func__,
+			adap->id);
+
+	if (adap->dvb_adap.priv) {
+		dvb_net_release(&adap->dvb_net);
+		adap->demux.dmx.close(&adap->demux.dmx);
+		dvb_dmxdev_release(&adap->dmxdev);
+		dvb_dmx_release(&adap->demux);
+		dvb_unregister_adapter(&adap->dvb_adap);
+	}
+
+	return 0;
+}
+
+int dvb_usbv2_device_power_ctrl(struct dvb_usb_device *d, int onoff)
+{
+	int ret;
+
+	if (onoff)
+		d->powered++;
+	else
+		d->powered--;
+
+	if (d->powered == 0 || (onoff && d->powered == 1)) {
+		/* when switching from 1 to 0 or from 0 to 1 */
+		dev_dbg(&d->udev->dev, "%s: power=%d\n", __func__, onoff);
+		if (d->props->power_ctrl) {
+			ret = d->props->power_ctrl(d, onoff);
+			if (ret < 0)
+				goto err;
+		}
+	}
+
+	return 0;
+err:
+	dev_dbg(&d->udev->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+
+static int dvb_usb_fe_init(struct dvb_frontend *fe)
+{
+	int ret;
+	struct dvb_usb_adapter *adap = fe->dvb->priv;
+	struct dvb_usb_device *d = adap_to_d(adap);
+	mutex_lock(&adap->sync_mutex);
+	dev_dbg(&d->udev->dev, "%s: adap=%d fe=%d\n", __func__, adap->id,
+			fe->id);
+
+	ret = dvb_usbv2_device_power_ctrl(d, 1);
+	if (ret < 0)
+		goto err;
+
+	if (d->props->frontend_ctrl) {
+		ret = d->props->frontend_ctrl(fe, 1);
+		if (ret < 0)
+			goto err;
+	}
+
+	if (adap->fe_init[fe->id]) {
+		ret = adap->fe_init[fe->id](fe);
+		if (ret < 0)
+			goto err;
+	}
+
+	adap->active_fe = fe->id;
+	mutex_unlock(&adap->sync_mutex);
+
+	return 0;
+err:
+	mutex_unlock(&adap->sync_mutex);
+	dev_dbg(&d->udev->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+
+static int dvb_usb_fe_sleep(struct dvb_frontend *fe)
+{
+	int ret;
+	struct dvb_usb_adapter *adap = fe->dvb->priv;
+	struct dvb_usb_device *d = adap_to_d(adap);
+	mutex_lock(&adap->sync_mutex);
+	dev_dbg(&d->udev->dev, "%s: adap=%d fe=%d\n", __func__, adap->id,
+			fe->id);
+
+	if (adap->fe_sleep[fe->id]) {
+		ret = adap->fe_sleep[fe->id](fe);
+		if (ret < 0)
+			goto err;
+	}
+
+	if (d->props->frontend_ctrl) {
+		ret = d->props->frontend_ctrl(fe, 0);
+		if (ret < 0)
+			goto err;
+	}
+
+	ret = dvb_usbv2_device_power_ctrl(d, 0);
+	if (ret < 0)
+		goto err;
+
+	adap->active_fe = -1;
+	mutex_unlock(&adap->sync_mutex);
+
+	return 0;
+err:
+	mutex_unlock(&adap->sync_mutex);
+	dev_dbg(&d->udev->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+
+int dvb_usbv2_adapter_frontend_init(struct dvb_usb_adapter *adap)
+{
+	int ret, i, count_registered = 0;
+	struct dvb_usb_device *d = adap_to_d(adap);
+	dev_dbg(&d->udev->dev, "%s: adap=%d\n", __func__, adap->id);
+
+	memset(adap->fe, 0, sizeof(adap->fe));
+	adap->active_fe = -1;
+
+	if (d->props->frontend_attach) {
+		ret = d->props->frontend_attach(adap);
+		if (ret < 0) {
+			dev_dbg(&d->udev->dev, "%s: frontend_attach() " \
+					"failed=%d\n", __func__, ret);
+			goto err_dvb_frontend_detach;
+		}
+	} else {
+		dev_dbg(&d->udev->dev, "%s: frontend_attach() do not exists\n",
+				__func__);
+		ret = 0;
+		goto err;
+	}
+
+	for (i = 0; i < MAX_NO_OF_FE_PER_ADAP && adap->fe[i]; i++) {
+		adap->fe[i]->id = i;
+		/* re-assign sleep and wakeup functions */
+		adap->fe_init[i] = adap->fe[i]->ops.init;
+		adap->fe[i]->ops.init = dvb_usb_fe_init;
+		adap->fe_sleep[i] = adap->fe[i]->ops.sleep;
+		adap->fe[i]->ops.sleep = dvb_usb_fe_sleep;
+
+		ret = dvb_register_frontend(&adap->dvb_adap, adap->fe[i]);
+		if (ret < 0) {
+			dev_err(&d->udev->dev, "%s: frontend%d registration " \
+					"failed\n", KBUILD_MODNAME, i);
+			goto err_dvb_unregister_frontend;
+		}
+
+		count_registered++;
+	}
+
+	if (d->props->tuner_attach) {
+		ret = d->props->tuner_attach(adap);
+		if (ret < 0) {
+			dev_dbg(&d->udev->dev, "%s: tuner_attach() failed=%d\n",
+					__func__, ret);
+			goto err_dvb_unregister_frontend;
+		}
+	}
+
+	return 0;
+
+err_dvb_unregister_frontend:
+	for (i = count_registered - 1; i >= 0; i--)
+		dvb_unregister_frontend(adap->fe[i]);
+
+err_dvb_frontend_detach:
+	for (i = MAX_NO_OF_FE_PER_ADAP - 1; i >= 0; i--) {
+		if (adap->fe[i])
+			dvb_frontend_detach(adap->fe[i]);
+	}
+
+err:
+	dev_dbg(&d->udev->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+
+int dvb_usbv2_adapter_frontend_exit(struct dvb_usb_adapter *adap)
+{
+	int i;
+	dev_dbg(&adap_to_d(adap)->udev->dev, "%s: adap=%d\n", __func__,
+			adap->id);
+
+	for (i = MAX_NO_OF_FE_PER_ADAP - 1; i >= 0; i--) {
+		if (adap->fe[i]) {
+			dvb_unregister_frontend(adap->fe[i]);
+			dvb_frontend_detach(adap->fe[i]);
+		}
+	}
+
+	return 0;
+}
+
+static int dvb_usbv2_adapter_init(struct dvb_usb_device *d)
+{
+	struct dvb_usb_adapter *adap;
+	int ret, i, adapter_count;
+
+	/* resolve adapter count */
+	adapter_count = d->props->num_adapters;
+	if (d->props->get_adapter_count) {
+		ret = d->props->get_adapter_count(d);
+		if (ret < 0)
+			goto err;
+
+		adapter_count = ret;
+	}
+
+	for (i = 0; i < adapter_count; i++) {
+		adap = &d->adapter[i];
+		adap->id = i;
+		adap->props = &d->props->adapter[i];
+
+		/* speed - when running at FULL speed we need a HW PID filter */
+		if (d->udev->speed == USB_SPEED_FULL &&
+				!(adap->props->caps & DVB_USB_ADAP_HAS_PID_FILTER)) {
+			dev_err(&d->udev->dev, "%s: this USB2.0 device " \
+					"cannot be run on a USB1.1 port (it " \
+					"lacks a hardware PID filter)\n",
+					KBUILD_MODNAME);
+			ret = -ENODEV;
+			goto err;
+		} else if ((d->udev->speed == USB_SPEED_FULL &&
+				adap->props->caps & DVB_USB_ADAP_HAS_PID_FILTER) ||
+				(adap->props->caps & DVB_USB_ADAP_NEED_PID_FILTERING)) {
+			dev_info(&d->udev->dev, "%s: will use the device's " \
+					"hardware PID filter " \
+					"(table count: %d)\n", KBUILD_MODNAME,
+					adap->props->pid_filter_count);
+			adap->pid_filtering  = 1;
+			adap->max_feed_count = adap->props->pid_filter_count;
+		} else {
+			dev_info(&d->udev->dev, "%s: will pass the complete " \
+					"MPEG2 transport stream to the " \
+					"software demuxer\n", KBUILD_MODNAME);
+			adap->pid_filtering  = 0;
+			adap->max_feed_count = 255;
+		}
+
+		if (!adap->pid_filtering && dvb_usb_force_pid_filter_usage &&
+				adap->props->caps & DVB_USB_ADAP_HAS_PID_FILTER) {
+			dev_info(&d->udev->dev, "%s: PID filter enabled by " \
+					"module option\n", KBUILD_MODNAME);
+			adap->pid_filtering  = 1;
+			adap->max_feed_count = adap->props->pid_filter_count;
+		}
+
+		ret = dvb_usbv2_adapter_stream_init(adap);
+		if (ret)
+			goto err;
+
+		ret = dvb_usbv2_adapter_dvb_init(adap);
+		if (ret)
+			goto err;
+
+		ret = dvb_usbv2_adapter_frontend_init(adap);
+		if (ret)
+			goto err;
+
+		/* use exclusive FE lock if there is multiple shared FEs */
+		if (adap->fe[1])
+			adap->dvb_adap.mfe_shared = 1;
+	}
+
+	return 0;
+err:
+	dev_dbg(&d->udev->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+
+static int dvb_usbv2_adapter_exit(struct dvb_usb_device *d)
+{
+	int i;
+	dev_dbg(&d->udev->dev, "%s:\n", __func__);
+
+	for (i = MAX_NO_OF_ADAPTER_PER_DEVICE - 1; i >= 0; i--) {
+		if (d->adapter[i].props) {
+			dvb_usbv2_adapter_frontend_exit(&d->adapter[i]);
+			dvb_usbv2_adapter_dvb_exit(&d->adapter[i]);
+			dvb_usbv2_adapter_stream_exit(&d->adapter[i]);
+		}
+	}
+
+	return 0;
+}
+
+/* general initialization functions */
+static int dvb_usbv2_exit(struct dvb_usb_device *d)
+{
+	dev_dbg(&d->udev->dev, "%s:\n", __func__);
+
+	dvb_usbv2_remote_exit(d);
+	dvb_usbv2_adapter_exit(d);
+	dvb_usbv2_i2c_exit(d);
+	kfree(d->priv);
+	kfree(d);
+
+	return 0;
+}
+
+static int dvb_usbv2_init(struct dvb_usb_device *d)
+{
+	int ret;
+	dev_dbg(&d->udev->dev, "%s:\n", __func__);
+
+	dvb_usbv2_device_power_ctrl(d, 1);
+
+	if (d->props->read_config) {
+		ret = d->props->read_config(d);
+		if (ret < 0)
+			goto err;
+	}
+
+	ret = dvb_usbv2_i2c_init(d);
+	if (ret < 0)
+		goto err;
+
+	ret = dvb_usbv2_adapter_init(d);
+	if (ret < 0)
+		goto err;
+
+	if (d->props->init) {
+		ret = d->props->init(d);
+		if (ret < 0)
+			goto err;
+	}
+
+	ret = dvb_usbv2_remote_init(d);
+	if (ret < 0)
+		goto err;
+
+	dvb_usbv2_device_power_ctrl(d, 0);
+
+	return 0;
+err:
+	dvb_usbv2_device_power_ctrl(d, 0);
+	dev_dbg(&d->udev->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+
+/*
+ * udev, which is used for the firmware downloading, requires we cannot
+ * block during module_init(). module_init() calls USB probe() which
+ * is this routine. Due to that we delay actual operation using workqueue
+ * and return always success here.
+ */
+static void dvb_usbv2_init_work(struct work_struct *work)
+{
+	int ret;
+	struct dvb_usb_device *d =
+			container_of(work, struct dvb_usb_device, probe_work);
+
+	d->work_pid = current->pid;
+	dev_dbg(&d->udev->dev, "%s: work_pid=%d\n", __func__, d->work_pid);
+
+	if (d->props->size_of_priv) {
+		d->priv = kzalloc(d->props->size_of_priv, GFP_KERNEL);
+		if (!d->priv) {
+			dev_err(&d->udev->dev, "%s: kzalloc() failed\n",
+					KBUILD_MODNAME);
+			ret = -ENOMEM;
+			goto err_usb_driver_release_interface;
+		}
+	}
+
+	if (d->props->identify_state) {
+		const char *name = NULL;
+		ret = d->props->identify_state(d, &name);
+		if (ret == 0) {
+			;
+		} else if (ret == COLD) {
+			dev_info(&d->udev->dev, "%s: found a '%s' in cold " \
+					"state\n", KBUILD_MODNAME, d->name);
+
+			if (!name)
+				name = d->props->firmware;
+
+			ret = dvb_usbv2_download_firmware(d, name);
+			if (ret == 0) {
+				/* device is warm, continue initialization */
+				;
+			} else if (ret == RECONNECTS_USB) {
+				/*
+				 * USB core will call disconnect() and then
+				 * probe() as device reconnects itself from the
+				 * USB bus. disconnect() will release all driver
+				 * resources and probe() is called for 'new'
+				 * device. As 'new' device is warm we should
+				 * never go here again.
+				 */
+				return;
+			} else {
+				/*
+				 * Unexpected error. We must unregister driver
+				 * manually from the device, because device is
+				 * already register by returning from probe()
+				 * with success. usb_driver_release_interface()
+				 * finally calls disconnect() in order to free
+				 * resources.
+				 */
+				goto err_usb_driver_release_interface;
+			}
+		} else {
+			goto err_usb_driver_release_interface;
+		}
+	}
+
+	dev_info(&d->udev->dev, "%s: found a '%s' in warm state\n",
+			KBUILD_MODNAME, d->name);
+
+	ret = dvb_usbv2_init(d);
+	if (ret < 0)
+		goto err_usb_driver_release_interface;
+
+	dev_info(&d->udev->dev, "%s: '%s' successfully initialized and " \
+			"connected\n", KBUILD_MODNAME, d->name);
+
+	return;
+err_usb_driver_release_interface:
+	dev_info(&d->udev->dev, "%s: '%s' error while loading driver (%d)\n",
+			KBUILD_MODNAME, d->name, ret);
+	usb_driver_release_interface(to_usb_driver(d->intf->dev.driver),
+			d->intf);
+	dev_dbg(&d->udev->dev, "%s: failed=%d\n", __func__, ret);
+	return;
+}
+
+int dvb_usbv2_probe(struct usb_interface *intf,
+		const struct usb_device_id *id)
+{
+	int ret;
+	struct dvb_usb_device *d;
+	struct usb_device *udev = interface_to_usbdev(intf);
+	struct dvb_usb_driver_info *driver_info =
+			(struct dvb_usb_driver_info *) id->driver_info;
+
+	dev_dbg(&udev->dev, "%s: bInterfaceNumber=%d\n", __func__,
+			intf->cur_altsetting->desc.bInterfaceNumber);
+
+	if (!id->driver_info) {
+		dev_err(&udev->dev, "%s: driver_info failed\n", KBUILD_MODNAME);
+		ret = -ENODEV;
+		goto err;
+	}
+
+	d = kzalloc(sizeof(struct dvb_usb_device), GFP_KERNEL);
+	if (!d) {
+		dev_err(&udev->dev, "%s: kzalloc() failed\n", KBUILD_MODNAME);
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	d->name = driver_info->name;
+	d->rc_map = driver_info->rc_map;
+	d->udev = udev;
+	d->intf = intf;
+	d->props = driver_info->props;
+
+	if (d->intf->cur_altsetting->desc.bInterfaceNumber !=
+			d->props->bInterfaceNumber) {
+		ret = -ENODEV;
+		goto err_kfree;
+	}
+
+	mutex_init(&d->usb_mutex);
+	mutex_init(&d->i2c_mutex);
+	INIT_WORK(&d->probe_work, dvb_usbv2_init_work);
+	usb_set_intfdata(intf, d);
+	ret = schedule_work(&d->probe_work);
+	if (ret < 0) {
+		dev_err(&d->udev->dev, "%s: schedule_work() failed\n",
+				KBUILD_MODNAME);
+		goto err_kfree;
+	}
+
+	return 0;
+err_kfree:
+	kfree(d);
+err:
+	dev_dbg(&udev->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+EXPORT_SYMBOL(dvb_usbv2_probe);
+
+void dvb_usbv2_disconnect(struct usb_interface *intf)
+{
+	struct dvb_usb_device *d = usb_get_intfdata(intf);
+	const char *name = d->name;
+	struct device dev = d->udev->dev;
+	dev_dbg(&d->udev->dev, "%s: pid=%d work_pid=%d\n", __func__,
+			current->pid, d->work_pid);
+
+	/* ensure initialization work is finished until release resources */
+	if (d->work_pid != current->pid)
+		cancel_work_sync(&d->probe_work);
+
+	if (d->props->exit)
+		d->props->exit(d);
+
+	dvb_usbv2_exit(d);
+
+	dev_info(&dev, "%s: '%s' successfully deinitialized and disconnected\n",
+			KBUILD_MODNAME, name);
+}
+EXPORT_SYMBOL(dvb_usbv2_disconnect);
+
+int dvb_usbv2_suspend(struct usb_interface *intf, pm_message_t msg)
+{
+	struct dvb_usb_device *d = usb_get_intfdata(intf);
+	int i;
+	dev_dbg(&d->udev->dev, "%s:\n", __func__);
+
+	/* stop remote controller poll */
+	if (d->rc.query && !d->rc.bulk_mode)
+		cancel_delayed_work_sync(&d->rc_query_work);
+
+	/* stop streaming */
+	for (i = MAX_NO_OF_ADAPTER_PER_DEVICE - 1; i >= 0; i--) {
+		if (d->adapter[i].dvb_adap.priv &&
+				d->adapter[i].active_fe != -1)
+			usb_urb_killv2(&d->adapter[i].stream);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(dvb_usbv2_suspend);
+
+int dvb_usbv2_resume(struct usb_interface *intf)
+{
+	struct dvb_usb_device *d = usb_get_intfdata(intf);
+	int i;
+	dev_dbg(&d->udev->dev, "%s:\n", __func__);
+
+	/* start streaming */
+	for (i = 0; i < MAX_NO_OF_ADAPTER_PER_DEVICE; i++) {
+		if (d->adapter[i].dvb_adap.priv &&
+				d->adapter[i].active_fe != -1)
+			usb_urb_submitv2(&d->adapter[i].stream, NULL);
+	}
+
+	/* start remote controller poll */
+	if (d->rc.query && !d->rc.bulk_mode)
+		schedule_delayed_work(&d->rc_query_work,
+				msecs_to_jiffies(d->rc.interval));
+
+	return 0;
+}
+EXPORT_SYMBOL(dvb_usbv2_resume);
+
+MODULE_VERSION("2.0");
+MODULE_AUTHOR("Patrick Boettcher <patrick.boettcher@desy.de>");
+MODULE_AUTHOR("Antti Palosaari <crope@iki.fi>");
+MODULE_DESCRIPTION("DVB USB common");
+MODULE_LICENSE("GPL");
