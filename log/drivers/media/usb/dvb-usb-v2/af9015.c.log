commit c942fddf8793b2013be8c901b47d0a8dc02bf99f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:06 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 157
    
    Based on 3 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [kishon] [vijay] [abraham]
      [i] [kishon]@[ti] [com] this program is distributed in the hope that
      it will be useful but without any warranty without even the implied
      warranty of merchantability or fitness for a particular purpose see
      the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [graeme] [gregory]
      [gg]@[slimlogic] [co] [uk] [author] [kishon] [vijay] [abraham] [i]
      [kishon]@[ti] [com] [based] [on] [twl6030]_[usb] [c] [author] [hema]
      [hk] [hemahk]@[ti] [com] this program is distributed in the hope
      that it will be useful but without any warranty without even the
      implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1105 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.202006027@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/media/usb/dvb-usb-v2/af9015.c b/drivers/media/usb/dvb-usb-v2/af9015.c
index 39f9ffce3caa..c427b9031e42 100644
--- a/drivers/media/usb/dvb-usb-v2/af9015.c
+++ b/drivers/media/usb/dvb-usb-v2/af9015.c
@@ -1,20 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * DVB USB Linux driver for Afatech AF9015 DVB-T USB2.0 receiver
  *
  * Copyright (C) 2007 Antti Palosaari <crope@iki.fi>
  *
  * Thanks to Afatech who kindly provided information.
- *
- *    This program is free software; you can redistribute it and/or modify
- *    it under the terms of the GNU General Public License as published by
- *    the Free Software Foundation; either version 2 of the License, or
- *    (at your option) any later version.
- *
- *    This program is distributed in the hope that it will be useful,
- *    but WITHOUT ANY WARRANTY; without even the implied warranty of
- *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *    GNU General Public License for more details.
- *
  */
 
 #include "af9015.h"

commit b2d109f24aa3062b2082d93ec1771d6e92ef8032
Author: Antti Palosaari <crope@iki.fi>
Date:   Tue Mar 13 19:27:57 2018 -0400

    media: af9015: correct some coding style issues
    
    Correct coding style issues reported mostly by checkpatch.pl.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/usb/dvb-usb-v2/af9015.c b/drivers/media/usb/dvb-usb-v2/af9015.c
index 8379ef164fad..39f9ffce3caa 100644
--- a/drivers/media/usb/dvb-usb-v2/af9015.c
+++ b/drivers/media/usb/dvb-usb-v2/af9015.c
@@ -72,17 +72,19 @@ static int af9015_ctrl_msg(struct dvb_usb_device *d, struct req_t *req)
 		goto error;
 	}
 
-	/* buffer overflow check */
+	/* Buffer overflow check */
 	if ((write && (req->data_len > BUF_LEN - REQ_HDR_LEN)) ||
-			(!write && (req->data_len > BUF_LEN - ACK_HDR_LEN))) {
+	    (!write && (req->data_len > BUF_LEN - ACK_HDR_LEN))) {
 		dev_err(&intf->dev, "too much data, cmd %u, len %u\n",
 			req->cmd, req->data_len);
 		ret = -EINVAL;
 		goto error;
 	}
 
-	/* write receives seq + status = 2 bytes
-	   read receives seq + status + data = 2 + N bytes */
+	/*
+	 * Write receives seq + status = 2 bytes
+	 * Read receives seq + status + data = 2 + N bytes
+	 */
 	wlen = REQ_HDR_LEN;
 	rlen = ACK_HDR_LEN;
 	if (write) {
@@ -96,8 +98,8 @@ static int af9015_ctrl_msg(struct dvb_usb_device *d, struct req_t *req)
 	if (req->cmd == DOWNLOAD_FIRMWARE || req->cmd == RECONNECT_USB)
 		rlen = 0;
 
-	ret = dvb_usbv2_generic_rw_locked(d,
-			state->buf, wlen, state->buf, rlen);
+	ret = dvb_usbv2_generic_rw_locked(d, state->buf, wlen,
+					  state->buf, rlen);
 	if (ret)
 		goto error;
 
@@ -118,7 +120,7 @@ static int af9015_ctrl_msg(struct dvb_usb_device *d, struct req_t *req)
 }
 
 static int af9015_write_reg_i2c(struct dvb_usb_device *d, u8 addr, u16 reg,
-	u8 val)
+				u8 val)
 {
 	struct af9015_state *state = d_to_priv(d);
 	struct req_t req = {WRITE_I2C, addr, reg, 1, 1, 1, &val};
@@ -131,7 +133,7 @@ static int af9015_write_reg_i2c(struct dvb_usb_device *d, u8 addr, u16 reg,
 }
 
 static int af9015_read_reg_i2c(struct dvb_usb_device *d, u8 addr, u16 reg,
-	u8 *val)
+			       u8 *val)
 {
 	struct af9015_state *state = d_to_priv(d);
 	struct req_t req = {READ_I2C, addr, reg, 0, 1, 1, val};
@@ -144,7 +146,7 @@ static int af9015_read_reg_i2c(struct dvb_usb_device *d, u8 addr, u16 reg,
 }
 
 static int af9015_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msg[],
-	int num)
+			   int num)
 {
 	struct dvb_usb_device *d = i2c_get_adapdata(adap);
 	struct af9015_state *state = d_to_priv(d);
@@ -154,28 +156,29 @@ static int af9015_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msg[],
 	u8 mbox, addr_len;
 	struct req_t req;
 
-/*
-The bus lock is needed because there is two tuners both using same I2C-address.
-Due to that the only way to select correct tuner is use demodulator I2C-gate.
-
-................................................
-. AF9015 includes integrated AF9013 demodulator.
-. ____________                   ____________  .                ____________
-.|     uC     |                 |   demod    | .               |    tuner   |
-.|------------|                 |------------| .               |------------|
-.|   AF9015   |                 |  AF9013/5  | .               |   MXL5003  |
-.|            |--+----I2C-------|-----/ -----|-.-----I2C-------|            |
-.|            |  |              | addr 0x38  | .               |  addr 0xc6 |
-.|____________|  |              |____________| .               |____________|
-.................|..............................
-		 |               ____________                   ____________
-		 |              |   demod    |                 |    tuner   |
-		 |              |------------|                 |------------|
-		 |              |   AF9013   |                 |   MXL5003  |
-		 +----I2C-------|-----/ -----|-------I2C-------|            |
-				| addr 0x3a  |                 |  addr 0xc6 |
-				|____________|                 |____________|
-*/
+	/*
+	 * I2C multiplexing:
+	 * There could be two tuners, both using same I2C address. Demodulator
+	 * I2C-gate is only possibility to select correct tuner.
+	 *
+	 * ...........................................
+	 * . AF9015 integrates AF9013 demodulator    .
+	 * . ____________               ____________ .             ____________
+	 * .|   USB IF   |             |   demod    |.            |   tuner    |
+	 * .|------------|             |------------|.            |------------|
+	 * .|   AF9015   |             |   AF9013   |.            |   MXL5003  |
+	 * .|            |--+--I2C-----|-----/ -----|.----I2C-----|            |
+	 * .|            |  |          | addr 0x1c  |.            |  addr 0x63 |
+	 * .|____________|  |          |____________|.            |____________|
+	 * .................|.........................
+	 *                  |           ____________               ____________
+	 *                  |          |   demod    |             |   tuner    |
+	 *                  |          |------------|             |------------|
+	 *                  |          |   AF9013   |             |   MXL5003  |
+	 *                  +--I2C-----|-----/ -----|-----I2C-----|            |
+	 *                             | addr 0x1d  |             |  addr 0x63 |
+	 *                             |____________|             |____________|
+	 */
 
 	if (msg[0].len == 0 || msg[0].flags & I2C_M_RD) {
 		addr = 0x0000;
@@ -186,11 +189,11 @@ Due to that the only way to select correct tuner is use demodulator I2C-gate.
 		mbox = 0;
 		addr_len = 1;
 	} else if (msg[0].len == 2) {
-		addr = msg[0].buf[0] << 8|msg[0].buf[1] << 0;
+		addr = msg[0].buf[0] << 8 | msg[0].buf[1] << 0;
 		mbox = 0;
 		addr_len = 2;
 	} else {
-		addr = msg[0].buf[0] << 8|msg[0].buf[1] << 0;
+		addr = msg[0].buf[0] << 8 | msg[0].buf[1] << 0;
 		mbox = msg[0].buf[2];
 		addr_len = 3;
 	}
@@ -209,7 +212,7 @@ Due to that the only way to select correct tuner is use demodulator I2C-gate.
 		req.addr = addr;
 		req.mbox = mbox;
 		req.addr_len = addr_len;
-		req.data_len = msg[0].len-addr_len;
+		req.data_len = msg[0].len - addr_len;
 		req.data = &msg[0].buf[addr_len];
 		ret = af9015_ctrl_msg(d, &req);
 	} else if (num == 2 && !(msg[0].flags & I2C_M_RD) &&
@@ -313,7 +316,7 @@ static int af9015_download_firmware(struct dvb_usb_device *d,
 	#define LEN_MAX (BUF_LEN - REQ_HDR_LEN) /* Max payload size */
 	for (rem = firmware->size; rem > 0; rem -= LEN_MAX) {
 		req.data_len = min(LEN_MAX, rem);
-		req.data = (u8 *) &firmware->data[firmware->size - rem];
+		req.data = (u8 *)&firmware->data[firmware->size - rem];
 		req.addr = 0x5100 + firmware->size - rem;
 		ret = af9015_ctrl_msg(d, &req);
 		if (ret) {
@@ -522,14 +525,14 @@ static int af9015_read_config(struct dvb_usb_device *d)
 	if (ret)
 		dev_err(&intf->dev, "eeprom read failed %d\n", ret);
 
-	/* AverMedia AVerTV Volar Black HD (A850) device have bad EEPROM
-	   content :-( Override some wrong values here. Ditto for the
-	   AVerTV Red HD+ (A850T) device. */
+	/*
+	 * AverMedia AVerTV Volar Black HD (A850) device have bad EEPROM
+	 * content :-( Override some wrong values here. Ditto for the
+	 * AVerTV Red HD+ (A850T) device.
+	 */
 	if (le16_to_cpu(d->udev->descriptor.idVendor) == USB_VID_AVERMEDIA &&
-		((le16_to_cpu(d->udev->descriptor.idProduct) ==
-			USB_PID_AVERMEDIA_A850) ||
-		(le16_to_cpu(d->udev->descriptor.idProduct) ==
-			USB_PID_AVERMEDIA_A850T))) {
+	    ((le16_to_cpu(d->udev->descriptor.idProduct) == USB_PID_AVERMEDIA_A850) ||
+	    (le16_to_cpu(d->udev->descriptor.idProduct) == USB_PID_AVERMEDIA_A850T))) {
 		dev_dbg(&intf->dev, "AverMedia A850: overriding config\n");
 		/* disable dual mode */
 		state->dual_mode = 0;
@@ -542,7 +545,7 @@ static int af9015_read_config(struct dvb_usb_device *d)
 }
 
 static int af9015_get_stream_config(struct dvb_frontend *fe, u8 *ts_type,
-		struct usb_data_stream_properties *stream)
+				    struct usb_data_stream_properties *stream)
 {
 	struct dvb_usb_device *d = fe_to_d(fe);
 	struct usb_interface *intf = d->intf;
@@ -567,7 +570,7 @@ static int af9015_streaming_ctrl(struct dvb_frontend *fe, int onoff)
 
 	dev_dbg(&intf->dev, "adap id %d, onoff %d\n", adap_id, onoff);
 
-	if (state->usb_ts_if_configured[adap_id] == false) {
+	if (!state->usb_ts_if_configured[adap_id]) {
 		dev_dbg(&intf->dev, "set usb and ts interface\n");
 
 		/* USB IF stream settings */
@@ -665,6 +668,7 @@ static int af9015_streaming_ctrl(struct dvb_frontend *fe, int onoff)
 static int af9015_get_adapter_count(struct dvb_usb_device *d)
 {
 	struct af9015_state *state = d_to_priv(d);
+
 	return state->dual_mode + 1;
 }
 
@@ -686,7 +690,7 @@ static int af9015_af9013_set_frontend(struct dvb_frontend *fe)
 
 /* override demod callbacks for resource locking */
 static int af9015_af9013_read_status(struct dvb_frontend *fe,
-	enum fe_status *status)
+				     enum fe_status *status)
 {
 	int ret;
 	struct af9015_state *state = fe_to_priv(fe);
@@ -905,19 +909,12 @@ static int af9015_af9013_frontend_attach(struct dvb_usb_adapter *adap)
 	 * those "critical" paths to keep AF9015 happy.
 	 */
 	if (adap->fe[0]) {
-		state->set_frontend[adap->id] =
-			adap->fe[0]->ops.set_frontend;
-		adap->fe[0]->ops.set_frontend =
-			af9015_af9013_set_frontend;
-
-		state->read_status[adap->id] =
-			adap->fe[0]->ops.read_status;
-		adap->fe[0]->ops.read_status =
-			af9015_af9013_read_status;
-
+		state->set_frontend[adap->id] = adap->fe[0]->ops.set_frontend;
+		adap->fe[0]->ops.set_frontend = af9015_af9013_set_frontend;
+		state->read_status[adap->id] = adap->fe[0]->ops.read_status;
+		adap->fe[0]->ops.read_status = af9015_af9013_read_status;
 		state->init[adap->id] = adap->fe[0]->ops.init;
 		adap->fe[0]->ops.init = af9015_af9013_init;
-
 		state->sleep[adap->id] = adap->fe[0]->ops.sleep;
 		adap->fe[0]->ops.sleep = af9015_af9013_sleep;
 	}
@@ -1025,42 +1022,42 @@ static int af9015_tuner_attach(struct dvb_usb_adapter *adap)
 	case AF9013_TUNER_MT2060:
 	case AF9013_TUNER_MT2060_2:
 		ret = dvb_attach(mt2060_attach, adap->fe[0], adapter,
-			&af9015_mt2060_config,
-			state->mt2060_if1[adap->id]) == NULL ? -ENODEV : 0;
+				 &af9015_mt2060_config,
+				 state->mt2060_if1[adap->id]) == NULL ? -ENODEV : 0;
 		break;
 	case AF9013_TUNER_QT1010:
 	case AF9013_TUNER_QT1010A:
 		ret = dvb_attach(qt1010_attach, adap->fe[0], adapter,
-			&af9015_qt1010_config) == NULL ? -ENODEV : 0;
+				 &af9015_qt1010_config) == NULL ? -ENODEV : 0;
 		break;
 	case AF9013_TUNER_TDA18271:
 		ret = dvb_attach(tda18271_attach, adap->fe[0], 0x60, adapter,
-			&af9015_tda18271_config) == NULL ? -ENODEV : 0;
+				 &af9015_tda18271_config) == NULL ? -ENODEV : 0;
 		break;
 	case AF9013_TUNER_TDA18218:
 		ret = dvb_attach(tda18218_attach, adap->fe[0], adapter,
-			&af9015_tda18218_config) == NULL ? -ENODEV : 0;
+				 &af9015_tda18218_config) == NULL ? -ENODEV : 0;
 		break;
 	case AF9013_TUNER_MXL5003D:
 		ret = dvb_attach(mxl5005s_attach, adap->fe[0], adapter,
-			&af9015_mxl5003_config) == NULL ? -ENODEV : 0;
+				 &af9015_mxl5003_config) == NULL ? -ENODEV : 0;
 		break;
 	case AF9013_TUNER_MXL5005D:
 	case AF9013_TUNER_MXL5005R:
 		ret = dvb_attach(mxl5005s_attach, adap->fe[0], adapter,
-			&af9015_mxl5005_config) == NULL ? -ENODEV : 0;
+				 &af9015_mxl5005_config) == NULL ? -ENODEV : 0;
 		break;
 	case AF9013_TUNER_ENV77H11D5:
 		ret = dvb_attach(dvb_pll_attach, adap->fe[0], 0x60, adapter,
-			DVB_PLL_TDA665X) == NULL ? -ENODEV : 0;
+				 DVB_PLL_TDA665X) == NULL ? -ENODEV : 0;
 		break;
 	case AF9013_TUNER_MC44S803:
 		ret = dvb_attach(mc44s803_attach, adap->fe[0], adapter,
-			&af9015_mc44s803_config) == NULL ? -ENODEV : 0;
+				 &af9015_mc44s803_config) == NULL ? -ENODEV : 0;
 		break;
 	case AF9013_TUNER_MXL5007T:
 		ret = dvb_attach(mxl5007t_attach, adap->fe[0], adapter,
-			0x60, &af9015_mxl5007t_config) == NULL ? -ENODEV : 0;
+				 0x60, &af9015_mxl5007t_config) == NULL ? -ENODEV : 0;
 		break;
 	case AF9013_TUNER_UNKNOWN:
 	default:
@@ -1137,7 +1134,7 @@ struct af9015_rc_setup {
 };
 
 static char *af9015_rc_setup_match(unsigned int id,
-	const struct af9015_rc_setup *table)
+				   const struct af9015_rc_setup *table)
 {
 	for (; table->rc_codes; table++)
 		if (table->id == id)
@@ -1182,7 +1179,7 @@ static int af9015_rc_query(struct dvb_usb_device *d)
 
 	/* Check for repeat of previous code */
 	if ((state->rc_repeat != buf[6] || buf[0]) &&
-			!memcmp(&buf[12], state->rc_last, 4)) {
+	    !memcmp(&buf[12], state->rc_last, 4)) {
 		dev_dbg(&intf->dev, "key repeated\n");
 		rc_repeat(d->rc_dev);
 		state->rc_repeat = buf[6];
@@ -1192,6 +1189,7 @@ static int af9015_rc_query(struct dvb_usb_device *d)
 	/* Only process key if canary killed */
 	if (buf[16] != 0xff && buf[0] != 0x01) {
 		enum rc_proto proto;
+
 		dev_dbg(&intf->dev, "key pressed %*ph\n", 4, buf + 12);
 
 		/* Reset the canary */
@@ -1201,8 +1199,8 @@ static int af9015_rc_query(struct dvb_usb_device *d)
 
 		/* Remember this key */
 		memcpy(state->rc_last, &buf[12], 4);
-		if (buf[14] == (u8) ~buf[15]) {
-			if (buf[12] == (u8) ~buf[13]) {
+		if (buf[14] == (u8)~buf[15]) {
+			if (buf[12] == (u8)~buf[13]) {
 				/* NEC */
 				state->rc_keycode = RC_SCANCODE_NEC(buf[12],
 								    buf[14]);
@@ -1258,29 +1256,33 @@ static int af9015_get_rc_config(struct dvb_usb_device *d, struct dvb_usb_rc *rc)
 	/* try to load remote based module param */
 	if (!rc->map_name)
 		rc->map_name = af9015_rc_setup_match(dvb_usb_af9015_remote,
-				af9015_rc_setup_modparam);
+						     af9015_rc_setup_modparam);
 
 	/* try to load remote based eeprom hash */
 	if (!rc->map_name)
 		rc->map_name = af9015_rc_setup_match(state->eeprom_sum,
-				af9015_rc_setup_hashes);
+						     af9015_rc_setup_hashes);
 
 	/* try to load remote based USB iManufacturer string */
 	if (!rc->map_name && vid == USB_VID_AFATECH) {
-		/* Check USB manufacturer and product strings and try
-		   to determine correct remote in case of chip vendor
-		   reference IDs are used.
-		   DO NOT ADD ANYTHING NEW HERE. Use hashes instead. */
+		/*
+		 * Check USB manufacturer and product strings and try
+		 * to determine correct remote in case of chip vendor
+		 * reference IDs are used.
+		 * DO NOT ADD ANYTHING NEW HERE. Use hashes instead.
+		 */
 		char manufacturer[10];
+
 		memset(manufacturer, 0, sizeof(manufacturer));
 		usb_string(d->udev, d->udev->descriptor.iManufacturer,
-			manufacturer, sizeof(manufacturer));
+			   manufacturer, sizeof(manufacturer));
 		if (!strcmp("MSI", manufacturer)) {
-			/* iManufacturer 1 MSI
-			   iProduct      2 MSI K-VOX */
-			rc->map_name = af9015_rc_setup_match(
-					AF9015_REMOTE_MSI_DIGIVOX_MINI_II_V3,
-					af9015_rc_setup_modparam);
+			/*
+			 * iManufacturer 1 MSI
+			 * iProduct      2 MSI K-VOX
+			 */
+			rc->map_name = af9015_rc_setup_match(AF9015_REMOTE_MSI_DIGIVOX_MINI_II_V3,
+							     af9015_rc_setup_modparam);
 		}
 	}
 
@@ -1409,8 +1411,10 @@ static void af9015_disconnect(struct dvb_usb_device *d)
 	regmap_exit(state->regmap);
 }
 
-/* interface 0 is used by DVB-T receiver and
-   interface 1 is for remote controller (HID) */
+/*
+ * Interface 0 is used by DVB-T receiver and
+ * interface 1 is for remote controller (HID)
+ */
 static const struct dvb_usb_device_properties af9015_props = {
 	.driver_name = KBUILD_MODNAME,
 	.owner = THIS_MODULE,

commit 8b79c7ab11c4de580972042244f078a1bb9ff0cd
Author: Antti Palosaari <crope@iki.fi>
Date:   Thu Jul 13 02:42:52 2017 -0400

    media: af9015: convert to regmap api
    
    Use regmap for chip register access.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/usb/dvb-usb-v2/af9015.c b/drivers/media/usb/dvb-usb-v2/af9015.c
index 99e3b14d493e..8379ef164fad 100644
--- a/drivers/media/usb/dvb-usb-v2/af9015.c
+++ b/drivers/media/usb/dvb-usb-v2/af9015.c
@@ -117,31 +117,6 @@ static int af9015_ctrl_msg(struct dvb_usb_device *d, struct req_t *req)
 	return ret;
 }
 
-static int af9015_write_regs(struct dvb_usb_device *d, u16 addr, u8 *val,
-	u8 len)
-{
-	struct req_t req = {WRITE_MEMORY, AF9015_I2C_DEMOD, addr, 0, 0, len,
-		val};
-	return af9015_ctrl_msg(d, &req);
-}
-
-static int af9015_read_regs(struct dvb_usb_device *d, u16 addr, u8 *val, u8 len)
-{
-	struct req_t req = {READ_MEMORY, AF9015_I2C_DEMOD, addr, 0, 0, len,
-		val};
-	return af9015_ctrl_msg(d, &req);
-}
-
-static int af9015_write_reg(struct dvb_usb_device *d, u16 addr, u8 val)
-{
-	return af9015_write_regs(d, addr, &val, 1);
-}
-
-static int af9015_read_reg(struct dvb_usb_device *d, u16 addr, u8 *val)
-{
-	return af9015_read_regs(d, addr, val, 1);
-}
-
 static int af9015_write_reg_i2c(struct dvb_usb_device *d, u8 addr, u16 reg,
 	u8 val)
 {
@@ -168,38 +143,6 @@ static int af9015_read_reg_i2c(struct dvb_usb_device *d, u8 addr, u16 reg,
 	return af9015_ctrl_msg(d, &req);
 }
 
-static int af9015_do_reg_bit(struct dvb_usb_device *d, u16 addr, u8 bit, u8 op)
-{
-	int ret;
-	u8 val, mask = 0x01;
-
-	ret = af9015_read_reg(d, addr, &val);
-	if (ret)
-		return ret;
-
-	mask <<= bit;
-	if (op) {
-		/* set bit */
-		val |= mask;
-	} else {
-		/* clear bit */
-		mask ^= 0xff;
-		val &= mask;
-	}
-
-	return af9015_write_reg(d, addr, val);
-}
-
-static int af9015_set_reg_bit(struct dvb_usb_device *d, u16 addr, u8 bit)
-{
-	return af9015_do_reg_bit(d, addr, bit, 1);
-}
-
-static int af9015_clear_reg_bit(struct dvb_usb_device *d, u16 addr, u8 bit)
-{
-	return af9015_do_reg_bit(d, addr, bit, 0);
-}
-
 static int af9015_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msg[],
 	int num)
 {
@@ -642,76 +585,73 @@ static int af9015_streaming_ctrl(struct dvb_frontend *fe, int onoff)
 			reg1 = 0xdd8a;
 			reg2 = 0xdd0d;
 		}
-
-		ret = af9015_write_regs(d, reg1, buf, 2);
+		ret = regmap_bulk_write(state->regmap, reg1, buf, 2);
 		if (ret)
 			goto err;
-		ret = af9015_write_reg(d, reg2, utmp2);
+		ret = regmap_write(state->regmap, reg2, utmp2);
 		if (ret)
 			goto err;
 
 		/* TS IF settings */
 		if (state->dual_mode) {
-			ret = af9015_set_reg_bit(d, 0xd50b, 0);
-			if (ret)
-				goto err;
-			ret = af9015_set_reg_bit(d, 0xd520, 4);
-			if (ret)
-				goto err;
+			utmp1 = 0x01;
+			utmp2 = 0x10;
 		} else {
-			ret = af9015_clear_reg_bit(d, 0xd50b, 0);
-			if (ret)
-				goto err;
-			ret = af9015_clear_reg_bit(d, 0xd520, 4);
-			if (ret)
-				goto err;
+			utmp1 = 0x00;
+			utmp2 = 0x00;
 		}
+		ret = regmap_update_bits(state->regmap, 0xd50b, 0x01, utmp1);
+		if (ret)
+			goto err;
+		ret = regmap_update_bits(state->regmap, 0xd520, 0x10, utmp2);
+		if (ret)
+			goto err;
 
 		state->usb_ts_if_configured[adap_id] = true;
 	}
 
 	if (adap_id == 0 && onoff) {
 		/* Adapter 0 stream on. EP4: clear NAK, enable, clear reset */
-		ret = af9015_clear_reg_bit(d, 0xdd13, 5);
+		ret = regmap_update_bits(state->regmap, 0xdd13, 0x20, 0x00);
 		if (ret)
 			goto err;
-		ret = af9015_set_reg_bit(d, 0xdd11, 5);
+		ret = regmap_update_bits(state->regmap, 0xdd11, 0x20, 0x20);
 		if (ret)
 			goto err;
-		ret = af9015_clear_reg_bit(d, 0xd507, 2);
+		ret = regmap_update_bits(state->regmap, 0xd507, 0x04, 0x00);
 		if (ret)
 			goto err;
 	} else if (adap_id == 1 && onoff) {
 		/* Adapter 1 stream on. EP5: clear NAK, enable, clear reset */
-		ret = af9015_clear_reg_bit(d, 0xdd13, 6);
+		ret = regmap_update_bits(state->regmap, 0xdd13, 0x40, 0x00);
 		if (ret)
 			goto err;
-		ret = af9015_set_reg_bit(d, 0xdd11, 6);
+		ret = regmap_update_bits(state->regmap, 0xdd11, 0x40, 0x40);
 		if (ret)
 			goto err;
-		ret = af9015_clear_reg_bit(d, 0xd50b, 1);
+		ret = regmap_update_bits(state->regmap, 0xd50b, 0x02, 0x00);
 		if (ret)
 			goto err;
 	} else if (adap_id == 0 && !onoff) {
 		/* Adapter 0 stream off. EP4: set reset, disable, set NAK */
-		ret = af9015_set_reg_bit(d, 0xd507, 2);
+		ret = regmap_update_bits(state->regmap, 0xd507, 0x04, 0x04);
 		if (ret)
 			goto err;
-		ret = af9015_clear_reg_bit(d, 0xdd11, 5);
+		ret = regmap_update_bits(state->regmap, 0xdd11, 0x20, 0x00);
 		if (ret)
 			goto err;
-		ret = af9015_set_reg_bit(d, 0xdd13, 5);
+		ret = regmap_update_bits(state->regmap, 0xdd13, 0x20, 0x20);
 		if (ret)
 			goto err;
 	} else if (adap_id == 1 && !onoff) {
 		/* Adapter 1 stream off. EP5: set reset, disable, set NAK */
-		ret = af9015_set_reg_bit(d, 0xd50b, 1);
+		ret = regmap_update_bits(state->regmap, 0xd50b, 0x02, 0x02);
 		if (ret)
 			goto err;
-		ret = af9015_clear_reg_bit(d, 0xdd11, 6);
+		ret = regmap_update_bits(state->regmap, 0xdd11, 0x40, 0x00);
 		if (ret)
 			goto err;
-		ret = af9015_set_reg_bit(d, 0xdd13, 6);
+		ret = regmap_update_bits(state->regmap, 0xdd13, 0x40, 0x40);
 		if (ret)
 			goto err;
 	}
@@ -852,7 +792,7 @@ static int af9015_copy_firmware(struct dvb_usb_device *d)
 		return 0;
 
 	/* Set i2c clock to 625kHz to speed up firmware copy */
-	ret = af9015_write_reg(d, 0xd416, 0x04);
+	ret = regmap_write(state->regmap, 0xd416, 0x04);
 	if (ret)
 		goto err;
 
@@ -864,7 +804,7 @@ static int af9015_copy_firmware(struct dvb_usb_device *d)
 	}
 
 	/* Set i2c clock to 125kHz */
-	ret = af9015_write_reg(d, 0xd416, 0x14);
+	ret = regmap_write(state->regmap, 0xd416, 0x14);
 	if (ret)
 		goto err;
 
@@ -1182,7 +1122,7 @@ static int af9015_init(struct dvb_usb_device *d)
 	mutex_init(&state->fe_mutex);
 
 	/* init RC canary */
-	ret = af9015_write_reg(d, 0x98e9, 0xff);
+	ret = regmap_write(state->regmap, 0x98e9, 0xff);
 	if (ret)
 		goto error;
 
@@ -1230,7 +1170,7 @@ static int af9015_rc_query(struct dvb_usb_device *d)
 	u8 buf[17];
 
 	/* read registers needed to detect remote controller code */
-	ret = af9015_read_regs(d, 0x98d9, buf, sizeof(buf));
+	ret = regmap_bulk_read(state->regmap, 0x98d9, buf, sizeof(buf));
 	if (ret)
 		goto error;
 
@@ -1255,7 +1195,7 @@ static int af9015_rc_query(struct dvb_usb_device *d)
 		dev_dbg(&intf->dev, "key pressed %*ph\n", 4, buf + 12);
 
 		/* Reset the canary */
-		ret = af9015_write_reg(d, 0x98e9, 0xff);
+		ret = regmap_write(state->regmap, 0x98e9, 0xff);
 		if (ret)
 			goto error;
 
@@ -1359,15 +1299,68 @@ static int af9015_get_rc_config(struct dvb_usb_device *d, struct dvb_usb_rc *rc)
 	#define af9015_get_rc_config NULL
 #endif
 
-static int af9015_probe(struct usb_interface *intf,
-		const struct usb_device_id *id)
+static int af9015_regmap_write(void *context, const void *data, size_t count)
+{
+	struct dvb_usb_device *d = context;
+	struct usb_interface *intf = d->intf;
+	int ret;
+	u16 reg = ((u8 *)data)[0] << 8 | ((u8 *)data)[1] << 0;
+	u8 *val = &((u8 *)data)[2];
+	const unsigned int len = count - 2;
+	struct req_t req = {WRITE_MEMORY, 0, reg, 0, 0, len, val};
+
+	ret = af9015_ctrl_msg(d, &req);
+	if (ret)
+		goto err;
+
+	return 0;
+err:
+	dev_dbg(&intf->dev, "failed %d\n", ret);
+	return ret;
+}
+
+static int af9015_regmap_read(void *context, const void *reg_buf,
+			      size_t reg_size, void *val_buf, size_t val_size)
+{
+	struct dvb_usb_device *d = context;
+	struct usb_interface *intf = d->intf;
+	int ret;
+	u16 reg = ((u8 *)reg_buf)[0] << 8 | ((u8 *)reg_buf)[1] << 0;
+	u8 *val = &((u8 *)val_buf)[0];
+	const unsigned int len = val_size;
+	struct req_t req = {READ_MEMORY, 0, reg, 0, 0, len, val};
+
+	ret = af9015_ctrl_msg(d, &req);
+	if (ret)
+		goto err;
+
+	return 0;
+err:
+	dev_dbg(&intf->dev, "failed %d\n", ret);
+	return ret;
+}
+
+static int af9015_probe(struct dvb_usb_device *d)
 {
+	struct af9015_state *state = d_to_priv(d);
+	struct usb_interface *intf = d->intf;
 	struct usb_device *udev = interface_to_usbdev(intf);
+	int ret;
 	char manufacturer[sizeof("ITE Technologies, Inc.")];
+	static const struct regmap_config regmap_config = {
+		.reg_bits    =  16,
+		.val_bits    =  8,
+	};
+	static const struct regmap_bus regmap_bus = {
+		.read = af9015_regmap_read,
+		.write = af9015_regmap_write,
+	};
+
+	dev_dbg(&intf->dev, "\n");
 
 	memset(manufacturer, 0, sizeof(manufacturer));
 	usb_string(udev, udev->descriptor.iManufacturer,
-			manufacturer, sizeof(manufacturer));
+		   manufacturer, sizeof(manufacturer));
 	/*
 	 * There is two devices having same ID but different chipset. One uses
 	 * AF9015 and the other IT9135 chipset. Only difference seen on lsusb
@@ -1386,19 +1379,39 @@ static int af9015_probe(struct usb_interface *intf,
 	 * iProduct                2 DVB-T TV Stick
 	 */
 	if ((le16_to_cpu(udev->descriptor.idVendor) == USB_VID_TERRATEC) &&
-			(le16_to_cpu(udev->descriptor.idProduct) == 0x0099)) {
+	    (le16_to_cpu(udev->descriptor.idProduct) == 0x0099)) {
 		if (!strcmp("ITE Technologies, Inc.", manufacturer)) {
+			ret = -ENODEV;
 			dev_dbg(&intf->dev, "rejecting device\n");
-			return -ENODEV;
+			goto err;
 		}
 	}
 
-	return dvb_usbv2_probe(intf, id);
+	state->regmap = regmap_init(&intf->dev, &regmap_bus, d, &regmap_config);
+	if (IS_ERR(state->regmap)) {
+		ret = PTR_ERR(state->regmap);
+		goto err;
+	}
+
+	return 0;
+err:
+	dev_dbg(&intf->dev, "failed %d\n", ret);
+	return ret;
+}
+
+static void af9015_disconnect(struct dvb_usb_device *d)
+{
+	struct af9015_state *state = d_to_priv(d);
+	struct usb_interface *intf = d->intf;
+
+	dev_dbg(&intf->dev, "\n");
+
+	regmap_exit(state->regmap);
 }
 
 /* interface 0 is used by DVB-T receiver and
    interface 1 is for remote controller (HID) */
-static struct dvb_usb_device_properties af9015_props = {
+static const struct dvb_usb_device_properties af9015_props = {
 	.driver_name = KBUILD_MODNAME,
 	.owner = THIS_MODULE,
 	.adapter_nr = adapter_nr,
@@ -1407,6 +1420,8 @@ static struct dvb_usb_device_properties af9015_props = {
 	.generic_bulk_ctrl_endpoint = 0x02,
 	.generic_bulk_ctrl_endpoint_response = 0x81,
 
+	.probe = af9015_probe,
+	.disconnect = af9015_disconnect,
 	.identify_state = af9015_identify_state,
 	.firmware = AF9015_FIRMWARE,
 	.download_firmware = af9015_download_firmware,
@@ -1529,7 +1544,7 @@ MODULE_DEVICE_TABLE(usb, af9015_id_table);
 static struct usb_driver af9015_usb_driver = {
 	.name = KBUILD_MODNAME,
 	.id_table = af9015_id_table,
-	.probe = af9015_probe,
+	.probe = dvb_usbv2_probe,
 	.disconnect = dvb_usbv2_disconnect,
 	.suspend = dvb_usbv2_suspend,
 	.resume = dvb_usbv2_resume,

commit 7772e380efcde7e6a2cdb731cf03b28582d6c51c
Author: Antti Palosaari <crope@iki.fi>
Date:   Thu Jul 13 01:56:41 2017 -0400

    media: af9015: enhance streaming config
    
    Replace static stream settings by one which enables and disables
    stream interface when needed (TS streaming control).
    
    1) Configure both TS IF and USB endpoints according to current use case
    
    2) Disable streaming USB endpoints when streaming is stopped and
    enable when streaming is started. Reduces sleep power consumption
    slightly.
    
    3) Reduce USB buffersize slightly, from 130848 to 98136 bytes
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/usb/dvb-usb-v2/af9015.c b/drivers/media/usb/dvb-usb-v2/af9015.c
index 1f352307a00a..99e3b14d493e 100644
--- a/drivers/media/usb/dvb-usb-v2/af9015.c
+++ b/drivers/media/usb/dvb-usb-v2/af9015.c
@@ -607,11 +607,121 @@ static int af9015_get_stream_config(struct dvb_frontend *fe, u8 *ts_type,
 	dev_dbg(&intf->dev, "adap %u\n", fe_to_adap(fe)->id);
 
 	if (d->udev->speed == USB_SPEED_FULL)
-		stream->u.bulk.buffersize = TS_USB11_FRAME_SIZE;
+		stream->u.bulk.buffersize = 5 * 188;
 
 	return 0;
 }
 
+static int af9015_streaming_ctrl(struct dvb_frontend *fe, int onoff)
+{
+	struct dvb_usb_device *d = fe_to_d(fe);
+	struct af9015_state *state = d_to_priv(d);
+	struct usb_interface *intf = d->intf;
+	int ret;
+	unsigned int utmp1, utmp2, reg1, reg2;
+	u8 buf[2];
+	const unsigned int adap_id = fe_to_adap(fe)->id;
+
+	dev_dbg(&intf->dev, "adap id %d, onoff %d\n", adap_id, onoff);
+
+	if (state->usb_ts_if_configured[adap_id] == false) {
+		dev_dbg(&intf->dev, "set usb and ts interface\n");
+
+		/* USB IF stream settings */
+		utmp1 = (d->udev->speed == USB_SPEED_FULL ? 5 : 87) * 188 / 4;
+		utmp2 = (d->udev->speed == USB_SPEED_FULL ? 64 : 512) / 4;
+
+		buf[0] = (utmp1 >> 0) & 0xff;
+		buf[1] = (utmp1 >> 8) & 0xff;
+		if (adap_id == 0) {
+			/* 1st USB IF (EP4) stream settings */
+			reg1 = 0xdd88;
+			reg2 = 0xdd0c;
+		} else {
+			/* 2nd USB IF (EP5) stream settings */
+			reg1 = 0xdd8a;
+			reg2 = 0xdd0d;
+		}
+
+		ret = af9015_write_regs(d, reg1, buf, 2);
+		if (ret)
+			goto err;
+		ret = af9015_write_reg(d, reg2, utmp2);
+		if (ret)
+			goto err;
+
+		/* TS IF settings */
+		if (state->dual_mode) {
+			ret = af9015_set_reg_bit(d, 0xd50b, 0);
+			if (ret)
+				goto err;
+			ret = af9015_set_reg_bit(d, 0xd520, 4);
+			if (ret)
+				goto err;
+		} else {
+			ret = af9015_clear_reg_bit(d, 0xd50b, 0);
+			if (ret)
+				goto err;
+			ret = af9015_clear_reg_bit(d, 0xd520, 4);
+			if (ret)
+				goto err;
+		}
+
+		state->usb_ts_if_configured[adap_id] = true;
+	}
+
+	if (adap_id == 0 && onoff) {
+		/* Adapter 0 stream on. EP4: clear NAK, enable, clear reset */
+		ret = af9015_clear_reg_bit(d, 0xdd13, 5);
+		if (ret)
+			goto err;
+		ret = af9015_set_reg_bit(d, 0xdd11, 5);
+		if (ret)
+			goto err;
+		ret = af9015_clear_reg_bit(d, 0xd507, 2);
+		if (ret)
+			goto err;
+	} else if (adap_id == 1 && onoff) {
+		/* Adapter 1 stream on. EP5: clear NAK, enable, clear reset */
+		ret = af9015_clear_reg_bit(d, 0xdd13, 6);
+		if (ret)
+			goto err;
+		ret = af9015_set_reg_bit(d, 0xdd11, 6);
+		if (ret)
+			goto err;
+		ret = af9015_clear_reg_bit(d, 0xd50b, 1);
+		if (ret)
+			goto err;
+	} else if (adap_id == 0 && !onoff) {
+		/* Adapter 0 stream off. EP4: set reset, disable, set NAK */
+		ret = af9015_set_reg_bit(d, 0xd507, 2);
+		if (ret)
+			goto err;
+		ret = af9015_clear_reg_bit(d, 0xdd11, 5);
+		if (ret)
+			goto err;
+		ret = af9015_set_reg_bit(d, 0xdd13, 5);
+		if (ret)
+			goto err;
+	} else if (adap_id == 1 && !onoff) {
+		/* Adapter 1 stream off. EP5: set reset, disable, set NAK */
+		ret = af9015_set_reg_bit(d, 0xd50b, 1);
+		if (ret)
+			goto err;
+		ret = af9015_clear_reg_bit(d, 0xdd11, 6);
+		if (ret)
+			goto err;
+		ret = af9015_set_reg_bit(d, 0xdd13, 6);
+		if (ret)
+			goto err;
+	}
+
+	return 0;
+err:
+	dev_dbg(&intf->dev, "failed %d\n", ret);
+	return ret;
+}
+
 static int af9015_get_adapter_count(struct dvb_usb_device *d)
 {
 	struct af9015_state *state = d_to_priv(d);
@@ -1061,105 +1171,6 @@ static int af9015_pid_filter(struct dvb_usb_adapter *adap, int index,
 	return ret;
 }
 
-static int af9015_init_endpoint(struct dvb_usb_device *d)
-{
-	struct af9015_state *state = d_to_priv(d);
-	struct usb_interface *intf = d->intf;
-	int ret;
-	u16 frame_size;
-	u8  packet_size;
-
-	dev_dbg(&intf->dev, "usb speed %u\n", d->udev->speed);
-
-	if (d->udev->speed == USB_SPEED_FULL) {
-		frame_size = TS_USB11_FRAME_SIZE/4;
-		packet_size = TS_USB11_MAX_PACKET_SIZE/4;
-	} else {
-		frame_size = TS_USB20_FRAME_SIZE/4;
-		packet_size = TS_USB20_MAX_PACKET_SIZE/4;
-	}
-
-	ret = af9015_set_reg_bit(d, 0xd507, 2); /* assert EP4 reset */
-	if (ret)
-		goto error;
-	ret = af9015_set_reg_bit(d, 0xd50b, 1); /* assert EP5 reset */
-	if (ret)
-		goto error;
-	ret = af9015_clear_reg_bit(d, 0xdd11, 5); /* disable EP4 */
-	if (ret)
-		goto error;
-	ret = af9015_clear_reg_bit(d, 0xdd11, 6); /* disable EP5 */
-	if (ret)
-		goto error;
-	ret = af9015_set_reg_bit(d, 0xdd11, 5); /* enable EP4 */
-	if (ret)
-		goto error;
-	if (state->dual_mode) {
-		ret = af9015_set_reg_bit(d, 0xdd11, 6); /* enable EP5 */
-		if (ret)
-			goto error;
-	}
-	ret = af9015_clear_reg_bit(d, 0xdd13, 5); /* disable EP4 NAK */
-	if (ret)
-		goto error;
-	if (state->dual_mode) {
-		ret = af9015_clear_reg_bit(d, 0xdd13, 6); /* disable EP5 NAK */
-		if (ret)
-			goto error;
-	}
-	/* EP4 xfer length */
-	ret = af9015_write_reg(d, 0xdd88, frame_size & 0xff);
-	if (ret)
-		goto error;
-	ret = af9015_write_reg(d, 0xdd89, frame_size >> 8);
-	if (ret)
-		goto error;
-	/* EP5 xfer length */
-	ret = af9015_write_reg(d, 0xdd8a, frame_size & 0xff);
-	if (ret)
-		goto error;
-	ret = af9015_write_reg(d, 0xdd8b, frame_size >> 8);
-	if (ret)
-		goto error;
-	ret = af9015_write_reg(d, 0xdd0c, packet_size); /* EP4 packet size */
-	if (ret)
-		goto error;
-	ret = af9015_write_reg(d, 0xdd0d, packet_size); /* EP5 packet size */
-	if (ret)
-		goto error;
-	ret = af9015_clear_reg_bit(d, 0xd507, 2); /* negate EP4 reset */
-	if (ret)
-		goto error;
-	if (state->dual_mode) {
-		ret = af9015_clear_reg_bit(d, 0xd50b, 1); /* negate EP5 reset */
-		if (ret)
-			goto error;
-	}
-
-	/* enable / disable mp2if2 */
-	if (state->dual_mode) {
-		ret = af9015_set_reg_bit(d, 0xd50b, 0);
-		if (ret)
-			goto error;
-		ret = af9015_set_reg_bit(d, 0xd520, 4);
-		if (ret)
-			goto error;
-	} else {
-		ret = af9015_clear_reg_bit(d, 0xd50b, 0);
-		if (ret)
-			goto error;
-		ret = af9015_clear_reg_bit(d, 0xd520, 4);
-		if (ret)
-			goto error;
-	}
-
-error:
-	if (ret)
-		dev_err(&intf->dev, "endpoint init failed %d\n", ret);
-
-	return ret;
-}
-
 static int af9015_init(struct dvb_usb_device *d)
 {
 	struct af9015_state *state = d_to_priv(d);
@@ -1175,10 +1186,6 @@ static int af9015_init(struct dvb_usb_device *d)
 	if (ret)
 		goto error;
 
-	ret = af9015_init_endpoint(d);
-	if (ret)
-		goto error;
-
 error:
 	return ret;
 }
@@ -1412,6 +1419,7 @@ static struct dvb_usb_device_properties af9015_props = {
 	.init = af9015_init,
 	.get_rc_config = af9015_get_rc_config,
 	.get_stream_config = af9015_get_stream_config,
+	.streaming_ctrl = af9015_streaming_ctrl,
 
 	.get_adapter_count = af9015_get_adapter_count,
 	.adapter = {
@@ -1422,7 +1430,7 @@ static struct dvb_usb_device_properties af9015_props = {
 			.pid_filter = af9015_pid_filter,
 			.pid_filter_ctrl = af9015_pid_filter_ctrl,
 
-			.stream = DVB_USB_STREAM_BULK(0x84, 8, TS_USB20_FRAME_SIZE),
+			.stream = DVB_USB_STREAM_BULK(0x84, 6, 87 * 188),
 		}, {
 			.caps = DVB_USB_ADAP_HAS_PID_FILTER |
 				DVB_USB_ADAP_PID_FILTER_CAN_BE_TURNED_OFF,
@@ -1430,7 +1438,7 @@ static struct dvb_usb_device_properties af9015_props = {
 			.pid_filter = af9015_pid_filter,
 			.pid_filter_ctrl = af9015_pid_filter_ctrl,
 
-			.stream = DVB_USB_STREAM_BULK(0x85, 8, TS_USB20_FRAME_SIZE),
+			.stream = DVB_USB_STREAM_BULK(0x85, 6, 87 * 188),
 		},
 	},
 };

commit 0092293ec7981e9d46fa9103b07cfd63b3824b44
Author: Antti Palosaari <crope@iki.fi>
Date:   Mon Jun 26 07:15:27 2017 -0400

    media: af9015: refactor copy firmware to slave demod
    
    Small improvements.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/usb/dvb-usb-v2/af9015.c b/drivers/media/usb/dvb-usb-v2/af9015.c
index ffd4b225e439..1f352307a00a 100644
--- a/drivers/media/usb/dvb-usb-v2/af9015.c
+++ b/drivers/media/usb/dvb-usb-v2/af9015.c
@@ -720,79 +720,79 @@ static int af9015_copy_firmware(struct dvb_usb_device *d)
 	struct af9015_state *state = d_to_priv(d);
 	struct usb_interface *intf = d->intf;
 	int ret;
-	u8 fw_params[4];
-	u8 val, i;
-	struct req_t req = {COPY_FIRMWARE, 0, 0x5100, 0, 0, sizeof(fw_params),
-		fw_params };
+	unsigned long timeout;
+	u8 val, firmware_info[4];
+	struct req_t req = {COPY_FIRMWARE, 0, 0x5100, 0, 0, 4, firmware_info};
 
 	dev_dbg(&intf->dev, "\n");
 
-	fw_params[0] = state->firmware_size >> 8;
-	fw_params[1] = state->firmware_size & 0xff;
-	fw_params[2] = state->firmware_checksum >> 8;
-	fw_params[3] = state->firmware_checksum & 0xff;
+	firmware_info[0] = (state->firmware_size >> 8) & 0xff;
+	firmware_info[1] = (state->firmware_size >> 0) & 0xff;
+	firmware_info[2] = (state->firmware_checksum >> 8) & 0xff;
+	firmware_info[3] = (state->firmware_checksum >> 0) & 0xff;
 
-	ret = af9015_read_reg_i2c(d, state->af9013_i2c_addr[1],
-			0x98be, &val);
+	/* Check whether firmware is already running */
+	ret = af9015_read_reg_i2c(d, state->af9013_i2c_addr[1], 0x98be, &val);
 	if (ret)
-		goto error;
-	else
-		dev_dbg(&intf->dev, "firmware status %02x\n", val);
+		goto err;
 
-	if (val == 0x0c) /* fw is running, no need for download */
-		goto exit;
+	dev_dbg(&intf->dev, "firmware status %02x\n", val);
 
-	/* set I2C master clock to fast (to speed up firmware copy) */
-	ret = af9015_write_reg(d, 0xd416, 0x04); /* 0x04 * 400ns */
-	if (ret)
-		goto error;
+	if (val == 0x0c)
+		return 0;
 
-	msleep(50);
+	/* Set i2c clock to 625kHz to speed up firmware copy */
+	ret = af9015_write_reg(d, 0xd416, 0x04);
+	if (ret)
+		goto err;
 
-	/* copy firmware */
+	/* Copy firmware from master demod to slave demod */
 	ret = af9015_ctrl_msg(d, &req);
-	if (ret)
+	if (ret) {
 		dev_err(&intf->dev, "firmware copy cmd failed %d\n", ret);
+		goto err;
+	}
 
-	dev_dbg(&intf->dev, "firmware copy done\n");
-
-	/* set I2C master clock back to normal */
-	ret = af9015_write_reg(d, 0xd416, 0x14); /* 0x14 * 400ns */
+	/* Set i2c clock to 125kHz */
+	ret = af9015_write_reg(d, 0xd416, 0x14);
 	if (ret)
-		goto error;
+		goto err;
 
-	/* request boot firmware */
-	ret = af9015_write_reg_i2c(d, state->af9013_i2c_addr[1],
-			0xe205, 1);
-	dev_dbg(&intf->dev, "firmware boot cmd status %d\n", ret);
+	/* Boot firmware */
+	ret = af9015_write_reg_i2c(d, state->af9013_i2c_addr[1], 0xe205, 0x01);
 	if (ret)
-		goto error;
+		goto err;
 
-	for (i = 0; i < 15; i++) {
-		msleep(100);
+	/* Poll firmware ready */
+	for (val = 0x00, timeout = jiffies + msecs_to_jiffies(1000);
+	     !time_after(jiffies, timeout) && val != 0x0c && val != 0x04;) {
+		msleep(20);
 
-		/* check firmware status */
+		/* Check firmware status. 0c=OK, 04=fail */
 		ret = af9015_read_reg_i2c(d, state->af9013_i2c_addr[1],
-				0x98be, &val);
-		dev_dbg(&intf->dev, "firmware status cmd status %d, firmware status %02x\n",
-			ret, val);
+					  0x98be, &val);
 		if (ret)
-			goto error;
+			goto err;
 
-		if (val == 0x0c || val == 0x04) /* success or fail */
-			break;
+		dev_dbg(&intf->dev, "firmware status %02x\n", val);
 	}
 
+	dev_dbg(&intf->dev, "firmware boot took %u ms\n",
+		jiffies_to_msecs(jiffies) - (jiffies_to_msecs(timeout) - 1000));
+
 	if (val == 0x04) {
-		ret = -ETIMEDOUT;
+		ret = -ENODEV;
 		dev_err(&intf->dev, "firmware did not run\n");
+		goto err;
 	} else if (val != 0x0c) {
 		ret = -ETIMEDOUT;
 		dev_err(&intf->dev, "firmware boot timeout\n");
+		goto err;
 	}
 
-error:
-exit:
+	return 0;
+err:
+	dev_dbg(&intf->dev, "failed %d\n", ret);
 	return ret;
 }
 

commit 2ffb2fa32e5aa7685bbb6d625ad8e418d74aa440
Author: Antti Palosaari <crope@iki.fi>
Date:   Mon Jun 26 06:02:59 2017 -0400

    media: af9015: refactor firmware download
    
    Small revise, no functional changes.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/usb/dvb-usb-v2/af9015.c b/drivers/media/usb/dvb-usb-v2/af9015.c
index 8e2f704c6ca5..ffd4b225e439 100644
--- a/drivers/media/usb/dvb-usb-v2/af9015.c
+++ b/drivers/media/usb/dvb-usb-v2/af9015.c
@@ -350,52 +350,47 @@ static int af9015_identify_state(struct dvb_usb_device *d, const char **name)
 }
 
 static int af9015_download_firmware(struct dvb_usb_device *d,
-	const struct firmware *fw)
+				    const struct firmware *firmware)
 {
 	struct af9015_state *state = d_to_priv(d);
 	struct usb_interface *intf = d->intf;
-	int i, len, remaining, ret;
+	int ret, i, rem;
 	struct req_t req = {DOWNLOAD_FIRMWARE, 0, 0, 0, 0, 0, NULL};
-	u16 checksum = 0;
+	u16 checksum;
 
 	dev_dbg(&intf->dev, "\n");
 
-	/* calc checksum */
-	for (i = 0; i < fw->size; i++)
-		checksum += fw->data[i];
+	/* Calc checksum, we need it when copy firmware to slave demod */
+	for (i = 0, checksum = 0; i < firmware->size; i++)
+		checksum += firmware->data[i];
 
-	state->firmware_size = fw->size;
+	state->firmware_size = firmware->size;
 	state->firmware_checksum = checksum;
 
-	#define FW_ADDR 0x5100 /* firmware start address */
-	#define LEN_MAX 55 /* max packet size */
-	for (remaining = fw->size; remaining > 0; remaining -= LEN_MAX) {
-		len = remaining;
-		if (len > LEN_MAX)
-			len = LEN_MAX;
-
-		req.data_len = len;
-		req.data = (u8 *) &fw->data[fw->size - remaining];
-		req.addr = FW_ADDR + fw->size - remaining;
-
+	#define LEN_MAX (BUF_LEN - REQ_HDR_LEN) /* Max payload size */
+	for (rem = firmware->size; rem > 0; rem -= LEN_MAX) {
+		req.data_len = min(LEN_MAX, rem);
+		req.data = (u8 *) &firmware->data[firmware->size - rem];
+		req.addr = 0x5100 + firmware->size - rem;
 		ret = af9015_ctrl_msg(d, &req);
 		if (ret) {
 			dev_err(&intf->dev, "firmware download failed %d\n",
 				ret);
-			goto error;
+			goto err;
 		}
 	}
 
-	/* firmware loaded, request boot */
 	req.cmd = BOOT;
 	req.data_len = 0;
 	ret = af9015_ctrl_msg(d, &req);
 	if (ret) {
 		dev_err(&intf->dev, "firmware boot failed %d\n", ret);
-		goto error;
+		goto err;
 	}
 
-error:
+	return 0;
+err:
+	dev_dbg(&intf->dev, "failed %d\n", ret);
 	return ret;
 }
 

commit ba2d559b29cbaeafe012b642a53fed23b64762ea
Author: Antti Palosaari <crope@iki.fi>
Date:   Mon Jun 26 05:02:50 2017 -0400

    media: af9015: use af9013 demod pid filters
    
    PID filters are moved to af9013 demod driver as those are property of
    demod. As pid filters are now implemented correctly by demod driver,
    we could enable pid filter support for possible slave demod too on
    dual tuner configuration.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/usb/dvb-usb-v2/af9015.c b/drivers/media/usb/dvb-usb-v2/af9015.c
index f07aa42535e5..8e2f704c6ca5 100644
--- a/drivers/media/usb/dvb-usb-v2/af9015.c
+++ b/drivers/media/usb/dvb-usb-v2/af9015.c
@@ -474,10 +474,6 @@ static int af9015_read_config(struct dvb_usb_device *d)
 	state->dual_mode = val;
 	dev_dbg(&intf->dev, "ts mode %02x\n", state->dual_mode);
 
-	/* disable 2nd adapter because we don't have PID-filters */
-	if (d->udev->speed == USB_SPEED_FULL)
-		state->dual_mode = 0;
-
 	state->af9013_i2c_addr[0] = AF9015_I2C_DEMOD;
 
 	if (state->dual_mode) {
@@ -1045,43 +1041,28 @@ static int af9015_tuner_attach(struct dvb_usb_adapter *adap)
 
 static int af9015_pid_filter_ctrl(struct dvb_usb_adapter *adap, int onoff)
 {
-	struct dvb_usb_device *d = adap_to_d(adap);
-	struct usb_interface *intf = d->intf;
+	struct af9015_state *state = adap_to_priv(adap);
+	struct af9013_platform_data *pdata = &state->af9013_pdata[adap->id];
 	int ret;
 
-	dev_dbg(&intf->dev, "onoff %d\n", onoff);
-
-	if (onoff)
-		ret = af9015_set_reg_bit(d, 0xd503, 0);
-	else
-		ret = af9015_clear_reg_bit(d, 0xd503, 0);
+	mutex_lock(&state->fe_mutex);
+	ret = pdata->pid_filter_ctrl(adap->fe[0], onoff);
+	mutex_unlock(&state->fe_mutex);
 
 	return ret;
 }
 
-static int af9015_pid_filter(struct dvb_usb_adapter *adap, int index, u16 pid,
-	int onoff)
+static int af9015_pid_filter(struct dvb_usb_adapter *adap, int index,
+			     u16 pid, int onoff)
 {
-	struct dvb_usb_device *d = adap_to_d(adap);
-	struct usb_interface *intf = d->intf;
+	struct af9015_state *state = adap_to_priv(adap);
+	struct af9013_platform_data *pdata = &state->af9013_pdata[adap->id];
 	int ret;
-	u8 idx;
-
-	dev_dbg(&intf->dev, "index %d, pid %04x, onoff %d\n",
-		index, pid, onoff);
 
-	ret = af9015_write_reg(d, 0xd505, (pid & 0xff));
-	if (ret)
-		goto error;
-
-	ret = af9015_write_reg(d, 0xd506, (pid >> 8));
-	if (ret)
-		goto error;
-
-	idx = ((index & 0x1f) | (1 << 5));
-	ret = af9015_write_reg(d, 0xd504, idx);
+	mutex_lock(&state->fe_mutex);
+	ret = pdata->pid_filter(adap->fe[0], index, pid, onoff);
+	mutex_unlock(&state->fe_mutex);
 
-error:
 	return ret;
 }
 
@@ -1448,6 +1429,12 @@ static struct dvb_usb_device_properties af9015_props = {
 
 			.stream = DVB_USB_STREAM_BULK(0x84, 8, TS_USB20_FRAME_SIZE),
 		}, {
+			.caps = DVB_USB_ADAP_HAS_PID_FILTER |
+				DVB_USB_ADAP_PID_FILTER_CAN_BE_TURNED_OFF,
+			.pid_filter_count = 32,
+			.pid_filter = af9015_pid_filter,
+			.pid_filter_ctrl = af9015_pid_filter_ctrl,
+
 			.stream = DVB_USB_STREAM_BULK(0x85, 8, TS_USB20_FRAME_SIZE),
 		},
 	},

commit 04c611e3168e03702350bccaf5f9e83fb8f489db
Author: Antti Palosaari <crope@iki.fi>
Date:   Fri Jun 23 05:17:00 2017 -0400

    media: af9015: attach demod using i2c binding
    
    af9013 demod driver has i2c binding. Use it.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/usb/dvb-usb-v2/af9015.c b/drivers/media/usb/dvb-usb-v2/af9015.c
index 7e4cce05b911..f07aa42535e5 100644
--- a/drivers/media/usb/dvb-usb-v2/af9015.c
+++ b/drivers/media/usb/dvb-usb-v2/af9015.c
@@ -148,8 +148,8 @@ static int af9015_write_reg_i2c(struct dvb_usb_device *d, u8 addr, u16 reg,
 	struct af9015_state *state = d_to_priv(d);
 	struct req_t req = {WRITE_I2C, addr, reg, 1, 1, 1, &val};
 
-	if (addr == state->af9013_config[0].i2c_addr ||
-	    addr == state->af9013_config[1].i2c_addr)
+	if (addr == state->af9013_i2c_addr[0] ||
+	    addr == state->af9013_i2c_addr[1])
 		req.addr_len = 3;
 
 	return af9015_ctrl_msg(d, &req);
@@ -161,8 +161,8 @@ static int af9015_read_reg_i2c(struct dvb_usb_device *d, u8 addr, u16 reg,
 	struct af9015_state *state = d_to_priv(d);
 	struct req_t req = {READ_I2C, addr, reg, 0, 1, 1, val};
 
-	if (addr == state->af9013_config[0].i2c_addr ||
-	    addr == state->af9013_config[1].i2c_addr)
+	if (addr == state->af9013_i2c_addr[0] ||
+	    addr == state->af9013_i2c_addr[1])
 		req.addr_len = 3;
 
 	return af9015_ctrl_msg(d, &req);
@@ -258,7 +258,7 @@ Due to that the only way to select correct tuner is use demodulator I2C-gate.
 			ret = -EOPNOTSUPP;
 			goto err;
 		}
-		if (msg[0].addr == state->af9013_config[0].i2c_addr)
+		if (msg[0].addr == state->af9013_i2c_addr[0])
 			req.cmd = WRITE_MEMORY;
 		else
 			req.cmd = WRITE_I2C;
@@ -276,7 +276,7 @@ Due to that the only way to select correct tuner is use demodulator I2C-gate.
 			ret = -EOPNOTSUPP;
 			goto err;
 		}
-		if (msg[0].addr == state->af9013_config[0].i2c_addr)
+		if (msg[0].addr == state->af9013_i2c_addr[0])
 			req.cmd = READ_MEMORY;
 		else
 			req.cmd = READ_I2C;
@@ -293,7 +293,7 @@ Due to that the only way to select correct tuner is use demodulator I2C-gate.
 			ret = -EOPNOTSUPP;
 			goto err;
 		}
-		if (msg[0].addr == state->af9013_config[0].i2c_addr) {
+		if (msg[0].addr == state->af9013_i2c_addr[0]) {
 			ret = -EINVAL;
 			goto err;
 		}
@@ -478,7 +478,7 @@ static int af9015_read_config(struct dvb_usb_device *d)
 	if (d->udev->speed == USB_SPEED_FULL)
 		state->dual_mode = 0;
 
-	state->af9013_config[0].i2c_addr = AF9015_I2C_DEMOD;
+	state->af9013_i2c_addr[0] = AF9015_I2C_DEMOD;
 
 	if (state->dual_mode) {
 		/* read 2nd demodulator I2C address */
@@ -487,7 +487,7 @@ static int af9015_read_config(struct dvb_usb_device *d)
 		if (ret)
 			goto error;
 
-		state->af9013_config[1].i2c_addr = val >> 1;
+		state->af9013_i2c_addr[1] = val >> 1;
 	}
 
 	for (i = 0; i < state->dual_mode + 1; i++) {
@@ -500,20 +500,20 @@ static int af9015_read_config(struct dvb_usb_device *d)
 			goto error;
 		switch (val) {
 		case 0:
-			state->af9013_config[i].clock = 28800000;
+			state->af9013_pdata[i].clk = 28800000;
 			break;
 		case 1:
-			state->af9013_config[i].clock = 20480000;
+			state->af9013_pdata[i].clk = 20480000;
 			break;
 		case 2:
-			state->af9013_config[i].clock = 28000000;
+			state->af9013_pdata[i].clk = 28000000;
 			break;
 		case 3:
-			state->af9013_config[i].clock = 25000000;
+			state->af9013_pdata[i].clk = 25000000;
 			break;
 		}
-		dev_dbg(&intf->dev, "[%d] xtal %02x, clock %u\n",
-			i, val, state->af9013_config[i].clock);
+		dev_dbg(&intf->dev, "[%d] xtal %02x, clk %u\n",
+			i, val, state->af9013_pdata[i].clk);
 
 		/* IF frequency */
 		req.addr = AF9015_EEPROM_IF1H + offset;
@@ -521,17 +521,17 @@ static int af9015_read_config(struct dvb_usb_device *d)
 		if (ret)
 			goto error;
 
-		state->af9013_config[i].if_frequency = val << 8;
+		state->af9013_pdata[i].if_frequency = val << 8;
 
 		req.addr = AF9015_EEPROM_IF1L + offset;
 		ret = af9015_ctrl_msg(d, &req);
 		if (ret)
 			goto error;
 
-		state->af9013_config[i].if_frequency += val;
-		state->af9013_config[i].if_frequency *= 1000;
+		state->af9013_pdata[i].if_frequency += val;
+		state->af9013_pdata[i].if_frequency *= 1000;
 		dev_dbg(&intf->dev, "[%d] if frequency %u\n",
-			i, state->af9013_config[i].if_frequency);
+			i, state->af9013_pdata[i].if_frequency);
 
 		/* MT2060 IF1 */
 		req.addr = AF9015_EEPROM_MT2060_IF1H  + offset;
@@ -561,17 +561,17 @@ static int af9015_read_config(struct dvb_usb_device *d)
 		case AF9013_TUNER_TDA18271:
 		case AF9013_TUNER_QT1010A:
 		case AF9013_TUNER_TDA18218:
-			state->af9013_config[i].spec_inv = 1;
+			state->af9013_pdata[i].spec_inv = 1;
 			break;
 		case AF9013_TUNER_MXL5003D:
 		case AF9013_TUNER_MXL5005D:
 		case AF9013_TUNER_MXL5005R:
 		case AF9013_TUNER_MXL5007T:
-			state->af9013_config[i].spec_inv = 0;
+			state->af9013_pdata[i].spec_inv = 0;
 			break;
 		case AF9013_TUNER_MC44S803:
-			state->af9013_config[i].gpio[1] = AF9013_GPIO_LO;
-			state->af9013_config[i].spec_inv = 1;
+			state->af9013_pdata[i].gpio[1] = AF9013_GPIO_LO;
+			state->af9013_pdata[i].spec_inv = 1;
 			break;
 		default:
 			dev_err(&intf->dev,
@@ -580,7 +580,7 @@ static int af9015_read_config(struct dvb_usb_device *d)
 			return -ENODEV;
 		}
 
-		state->af9013_config[i].tuner = val;
+		state->af9013_pdata[i].tuner = val;
 		dev_dbg(&intf->dev, "[%d] tuner id %02x\n", i, val);
 	}
 
@@ -601,7 +601,7 @@ static int af9015_read_config(struct dvb_usb_device *d)
 		state->dual_mode = 0;
 
 		/* set correct IF */
-		state->af9013_config[0].if_frequency = 4570000;
+		state->af9013_pdata[0].if_frequency = 4570000;
 	}
 
 	return ret;
@@ -741,7 +741,7 @@ static int af9015_copy_firmware(struct dvb_usb_device *d)
 	fw_params[2] = state->firmware_checksum >> 8;
 	fw_params[3] = state->firmware_checksum & 0xff;
 
-	ret = af9015_read_reg_i2c(d, state->af9013_config[1].i2c_addr,
+	ret = af9015_read_reg_i2c(d, state->af9013_i2c_addr[1],
 			0x98be, &val);
 	if (ret)
 		goto error;
@@ -771,7 +771,7 @@ static int af9015_copy_firmware(struct dvb_usb_device *d)
 		goto error;
 
 	/* request boot firmware */
-	ret = af9015_write_reg_i2c(d, state->af9013_config[1].i2c_addr,
+	ret = af9015_write_reg_i2c(d, state->af9013_i2c_addr[1],
 			0xe205, 1);
 	dev_dbg(&intf->dev, "firmware boot cmd status %d\n", ret);
 	if (ret)
@@ -781,7 +781,7 @@ static int af9015_copy_firmware(struct dvb_usb_device *d)
 		msleep(100);
 
 		/* check firmware status */
-		ret = af9015_read_reg_i2c(d, state->af9013_config[1].i2c_addr,
+		ret = af9015_read_reg_i2c(d, state->af9013_i2c_addr[1],
 				0x98be, &val);
 		dev_dbg(&intf->dev, "firmware status cmd status %d, firmware status %02x\n",
 			ret, val);
@@ -810,18 +810,22 @@ static int af9015_af9013_frontend_attach(struct dvb_usb_adapter *adap)
 	struct af9015_state *state = adap_to_priv(adap);
 	struct dvb_usb_device *d = adap_to_d(adap);
 	struct usb_interface *intf = d->intf;
+	struct i2c_client *client;
 	int ret;
 
+	dev_dbg(&intf->dev, "adap id %u\n", adap->id);
+
 	if (adap->id == 0) {
-		state->af9013_config[0].ts_mode = AF9013_TS_USB;
-		memcpy(state->af9013_config[0].api_version, "\x0\x1\x9\x0", 4);
-		state->af9013_config[0].gpio[0] = AF9013_GPIO_HI;
-		state->af9013_config[0].gpio[3] = AF9013_GPIO_TUNER_ON;
+		state->af9013_pdata[0].ts_mode = AF9013_TS_MODE_USB;
+		memcpy(state->af9013_pdata[0].api_version, "\x0\x1\x9\x0", 4);
+		state->af9013_pdata[0].gpio[0] = AF9013_GPIO_HI;
+		state->af9013_pdata[0].gpio[3] = AF9013_GPIO_TUNER_ON;
 	} else if (adap->id == 1) {
-		state->af9013_config[1].ts_mode = AF9013_TS_SERIAL;
-		memcpy(state->af9013_config[1].api_version, "\x0\x1\x9\x0", 4);
-		state->af9013_config[1].gpio[0] = AF9013_GPIO_TUNER_ON;
-		state->af9013_config[1].gpio[1] = AF9013_GPIO_LO;
+		state->af9013_pdata[1].ts_mode = AF9013_TS_MODE_SERIAL;
+		state->af9013_pdata[1].ts_output_pin = 7;
+		memcpy(state->af9013_pdata[1].api_version, "\x0\x1\x9\x0", 4);
+		state->af9013_pdata[1].gpio[0] = AF9013_GPIO_TUNER_ON;
+		state->af9013_pdata[1].gpio[1] = AF9013_GPIO_LO;
 
 		/* copy firmware to 2nd demodulator */
 		if (state->dual_mode) {
@@ -833,16 +837,24 @@ static int af9015_af9013_frontend_attach(struct dvb_usb_adapter *adap)
 				dev_err(&intf->dev,
 					"firmware copy to 2nd frontend failed, will disable it\n");
 				state->dual_mode = 0;
-				return -ENODEV;
+				goto err;
 			}
 		} else {
-			return -ENODEV;
+			ret = -ENODEV;
+			goto err;
 		}
 	}
 
-	/* attach demodulator */
-	adap->fe[0] = dvb_attach(af9013_attach,
-		&state->af9013_config[adap->id], &adap_to_d(adap)->i2c_adap);
+	/* Add I2C demod */
+	client = dvb_module_probe("af9013", NULL, &d->i2c_adap,
+				  state->af9013_i2c_addr[adap->id],
+				  &state->af9013_pdata[adap->id]);
+	if (!client) {
+		ret = -ENODEV;
+		goto err;
+	}
+	adap->fe[0] = state->af9013_pdata[adap->id].get_dvb_frontend(client);
+	state->demod_i2c_client[adap->id] = client;
 
 	/*
 	 * AF9015 firmware does not like if it gets interrupted by I2C adapter
@@ -869,7 +881,26 @@ static int af9015_af9013_frontend_attach(struct dvb_usb_adapter *adap)
 		adap->fe[0]->ops.sleep = af9015_af9013_sleep;
 	}
 
-	return adap->fe[0] == NULL ? -ENODEV : 0;
+	return 0;
+err:
+	dev_dbg(&intf->dev, "failed %d\n", ret);
+	return ret;
+}
+
+static int af9015_frontend_detach(struct dvb_usb_adapter *adap)
+{
+	struct af9015_state *state = adap_to_priv(adap);
+	struct dvb_usb_device *d = adap_to_d(adap);
+	struct usb_interface *intf = d->intf;
+	struct i2c_client *client;
+
+	dev_dbg(&intf->dev, "adap id %u\n", adap->id);
+
+	/* Remove I2C demod */
+	client = state->demod_i2c_client[adap->id];
+	dvb_module_release(client);
+
+	return 0;
 }
 
 static struct mt2060_config af9015_mt2060_config = {
@@ -940,64 +971,60 @@ static int af9015_tuner_attach(struct dvb_usb_adapter *adap)
 	struct dvb_usb_device *d = adap_to_d(adap);
 	struct af9015_state *state = d_to_priv(d);
 	struct usb_interface *intf = d->intf;
+	struct i2c_client *client;
+	struct i2c_adapter *adapter;
 	int ret;
 
-	dev_dbg(&intf->dev, "\n");
+	dev_dbg(&intf->dev, "adap id %u\n", adap->id);
+
+	client = state->demod_i2c_client[adap->id];
+	adapter = state->af9013_pdata[adap->id].get_i2c_adapter(client);
 
-	switch (state->af9013_config[adap->id].tuner) {
+	switch (state->af9013_pdata[adap->id].tuner) {
 	case AF9013_TUNER_MT2060:
 	case AF9013_TUNER_MT2060_2:
-		ret = dvb_attach(mt2060_attach, adap->fe[0],
-			&adap_to_d(adap)->i2c_adap, &af9015_mt2060_config,
-			state->mt2060_if1[adap->id])
-			== NULL ? -ENODEV : 0;
+		ret = dvb_attach(mt2060_attach, adap->fe[0], adapter,
+			&af9015_mt2060_config,
+			state->mt2060_if1[adap->id]) == NULL ? -ENODEV : 0;
 		break;
 	case AF9013_TUNER_QT1010:
 	case AF9013_TUNER_QT1010A:
-		ret = dvb_attach(qt1010_attach, adap->fe[0],
-			&adap_to_d(adap)->i2c_adap,
+		ret = dvb_attach(qt1010_attach, adap->fe[0], adapter,
 			&af9015_qt1010_config) == NULL ? -ENODEV : 0;
 		break;
 	case AF9013_TUNER_TDA18271:
-		ret = dvb_attach(tda18271_attach, adap->fe[0], 0x60,
-			&adap_to_d(adap)->i2c_adap,
+		ret = dvb_attach(tda18271_attach, adap->fe[0], 0x60, adapter,
 			&af9015_tda18271_config) == NULL ? -ENODEV : 0;
 		break;
 	case AF9013_TUNER_TDA18218:
-		ret = dvb_attach(tda18218_attach, adap->fe[0],
-			&adap_to_d(adap)->i2c_adap,
+		ret = dvb_attach(tda18218_attach, adap->fe[0], adapter,
 			&af9015_tda18218_config) == NULL ? -ENODEV : 0;
 		break;
 	case AF9013_TUNER_MXL5003D:
-		ret = dvb_attach(mxl5005s_attach, adap->fe[0],
-			&adap_to_d(adap)->i2c_adap,
+		ret = dvb_attach(mxl5005s_attach, adap->fe[0], adapter,
 			&af9015_mxl5003_config) == NULL ? -ENODEV : 0;
 		break;
 	case AF9013_TUNER_MXL5005D:
 	case AF9013_TUNER_MXL5005R:
-		ret = dvb_attach(mxl5005s_attach, adap->fe[0],
-			&adap_to_d(adap)->i2c_adap,
+		ret = dvb_attach(mxl5005s_attach, adap->fe[0], adapter,
 			&af9015_mxl5005_config) == NULL ? -ENODEV : 0;
 		break;
 	case AF9013_TUNER_ENV77H11D5:
-		ret = dvb_attach(dvb_pll_attach, adap->fe[0], 0x60,
-			&adap_to_d(adap)->i2c_adap,
+		ret = dvb_attach(dvb_pll_attach, adap->fe[0], 0x60, adapter,
 			DVB_PLL_TDA665X) == NULL ? -ENODEV : 0;
 		break;
 	case AF9013_TUNER_MC44S803:
-		ret = dvb_attach(mc44s803_attach, adap->fe[0],
-			&adap_to_d(adap)->i2c_adap,
+		ret = dvb_attach(mc44s803_attach, adap->fe[0], adapter,
 			&af9015_mc44s803_config) == NULL ? -ENODEV : 0;
 		break;
 	case AF9013_TUNER_MXL5007T:
-		ret = dvb_attach(mxl5007t_attach, adap->fe[0],
-			&adap_to_d(adap)->i2c_adap,
+		ret = dvb_attach(mxl5007t_attach, adap->fe[0], adapter,
 			0x60, &af9015_mxl5007t_config) == NULL ? -ENODEV : 0;
 		break;
 	case AF9013_TUNER_UNKNOWN:
 	default:
 		dev_err(&intf->dev, "unknown tuner, tuner id %02x\n",
-			state->af9013_config[adap->id].tuner);
+			state->af9013_pdata[adap->id].tuner);
 		ret = -ENODEV;
 	}
 
@@ -1404,6 +1431,7 @@ static struct dvb_usb_device_properties af9015_props = {
 	.i2c_algo = &af9015_i2c_algo,
 	.read_config = af9015_read_config,
 	.frontend_attach = af9015_af9013_frontend_attach,
+	.frontend_detach = af9015_frontend_detach,
 	.tuner_attach = af9015_tuner_attach,
 	.init = af9015_init,
 	.get_rc_config = af9015_get_rc_config,

commit 49bade9f0eef207186b240e70d1eab418e4f1678
Author: Antti Palosaari <crope@iki.fi>
Date:   Wed Jun 21 16:55:54 2017 -0400

    media: af9015: fix logging
    
    Pass correct device to dev_* logging functions, which allows us to
    remove redundant KBUILD_MODNAME and __func__ parameters from log format.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/usb/dvb-usb-v2/af9015.c b/drivers/media/usb/dvb-usb-v2/af9015.c
index 8013659c41b1..7e4cce05b911 100644
--- a/drivers/media/usb/dvb-usb-v2/af9015.c
+++ b/drivers/media/usb/dvb-usb-v2/af9015.c
@@ -29,6 +29,7 @@ static int af9015_ctrl_msg(struct dvb_usb_device *d, struct req_t *req)
 #define REQ_HDR_LEN 8 /* send header size */
 #define ACK_HDR_LEN 2 /* rece header size */
 	struct af9015_state *state = d_to_priv(d);
+	struct usb_interface *intf = d->intf;
 	int ret, wlen, rlen;
 	u8 write = 1;
 
@@ -66,8 +67,7 @@ static int af9015_ctrl_msg(struct dvb_usb_device *d, struct req_t *req)
 	case BOOT:
 		break;
 	default:
-		dev_err(&d->udev->dev, "%s: unknown command=%d\n",
-				KBUILD_MODNAME, req->cmd);
+		dev_err(&intf->dev, "unknown cmd %d\n", req->cmd);
 		ret = -EIO;
 		goto error;
 	}
@@ -75,8 +75,8 @@ static int af9015_ctrl_msg(struct dvb_usb_device *d, struct req_t *req)
 	/* buffer overflow check */
 	if ((write && (req->data_len > BUF_LEN - REQ_HDR_LEN)) ||
 			(!write && (req->data_len > BUF_LEN - ACK_HDR_LEN))) {
-		dev_err(&d->udev->dev, "%s: too much data; cmd=%d len=%d\n",
-				KBUILD_MODNAME, req->cmd, req->data_len);
+		dev_err(&intf->dev, "too much data, cmd %u, len %u\n",
+			req->cmd, req->data_len);
 		ret = -EINVAL;
 		goto error;
 	}
@@ -103,8 +103,7 @@ static int af9015_ctrl_msg(struct dvb_usb_device *d, struct req_t *req)
 
 	/* check status */
 	if (rlen && state->buf[1]) {
-		dev_err(&d->udev->dev, "%s: command failed=%d\n",
-				KBUILD_MODNAME, state->buf[1]);
+		dev_err(&intf->dev, "cmd failed %u\n", state->buf[1]);
 		ret = -EIO;
 		goto error;
 	}
@@ -206,6 +205,7 @@ static int af9015_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msg[],
 {
 	struct dvb_usb_device *d = i2c_get_adapdata(adap);
 	struct af9015_state *state = d_to_priv(d);
+	struct usb_interface *intf = d->intf;
 	int ret;
 	u16 addr;
 	u8 mbox, addr_len;
@@ -307,15 +307,14 @@ Due to that the only way to select correct tuner is use demodulator I2C-gate.
 		ret = af9015_ctrl_msg(d, &req);
 	} else {
 		ret = -EOPNOTSUPP;
-		dev_dbg(&d->udev->dev, "%s: unknown msg, num %u\n",
-			__func__, num);
+		dev_dbg(&intf->dev, "unknown msg, num %u\n", num);
 	}
 	if (ret)
 		goto err;
 
 	return num;
 err:
-	dev_dbg(&d->udev->dev, "%s: failed %d\n", __func__, ret);
+	dev_dbg(&intf->dev, "failed %d\n", ret);
 	return ret;
 }
 
@@ -331,6 +330,7 @@ static struct i2c_algorithm af9015_i2c_algo = {
 
 static int af9015_identify_state(struct dvb_usb_device *d, const char **name)
 {
+	struct usb_interface *intf = d->intf;
 	int ret;
 	u8 reply;
 	struct req_t req = {GET_CONFIG, 0, 0, 0, 0, 1, &reply};
@@ -339,7 +339,7 @@ static int af9015_identify_state(struct dvb_usb_device *d, const char **name)
 	if (ret)
 		return ret;
 
-	dev_dbg(&d->udev->dev, "%s: reply=%02x\n", __func__, reply);
+	dev_dbg(&intf->dev, "reply %02x\n", reply);
 
 	if (reply == 0x02)
 		ret = WARM;
@@ -353,10 +353,12 @@ static int af9015_download_firmware(struct dvb_usb_device *d,
 	const struct firmware *fw)
 {
 	struct af9015_state *state = d_to_priv(d);
+	struct usb_interface *intf = d->intf;
 	int i, len, remaining, ret;
 	struct req_t req = {DOWNLOAD_FIRMWARE, 0, 0, 0, 0, 0, NULL};
 	u16 checksum = 0;
-	dev_dbg(&d->udev->dev, "%s:\n", __func__);
+
+	dev_dbg(&intf->dev, "\n");
 
 	/* calc checksum */
 	for (i = 0; i < fw->size; i++)
@@ -378,9 +380,8 @@ static int af9015_download_firmware(struct dvb_usb_device *d,
 
 		ret = af9015_ctrl_msg(d, &req);
 		if (ret) {
-			dev_err(&d->udev->dev,
-					"%s: firmware download failed=%d\n",
-					KBUILD_MODNAME, ret);
+			dev_err(&intf->dev, "firmware download failed %d\n",
+				ret);
 			goto error;
 		}
 	}
@@ -390,8 +391,7 @@ static int af9015_download_firmware(struct dvb_usb_device *d,
 	req.data_len = 0;
 	ret = af9015_ctrl_msg(d, &req);
 	if (ret) {
-		dev_err(&d->udev->dev, "%s: firmware boot failed=%d\n",
-				KBUILD_MODNAME, ret);
+		dev_err(&intf->dev, "firmware boot failed %d\n", ret);
 		goto error;
 	}
 
@@ -407,6 +407,7 @@ static int af9015_download_firmware(struct dvb_usb_device *d,
 static int af9015_eeprom_hash(struct dvb_usb_device *d)
 {
 	struct af9015_state *state = d_to_priv(d);
+	struct usb_interface *intf = d->intf;
 	int ret, i;
 	u8 buf[AF9015_EEPROM_SIZE];
 	struct req_t req = {READ_I2C, AF9015_I2C_EEPROM, 0, 0, 1, 1, NULL};
@@ -427,24 +428,24 @@ static int af9015_eeprom_hash(struct dvb_usb_device *d)
 	}
 
 	for (i = 0; i < AF9015_EEPROM_SIZE; i += 16)
-		dev_dbg(&d->udev->dev, "%s: %*ph\n", __func__, 16, buf + i);
+		dev_dbg(&intf->dev, "%*ph\n", 16, buf + i);
 
-	dev_dbg(&d->udev->dev, "%s: eeprom sum=%.8x\n",
-			__func__, state->eeprom_sum);
+	dev_dbg(&intf->dev, "eeprom sum %.8x\n", state->eeprom_sum);
 	return 0;
 err:
-	dev_err(&d->udev->dev, "%s: eeprom failed=%d\n", KBUILD_MODNAME, ret);
+	dev_dbg(&intf->dev, "failed %d\n", ret);
 	return ret;
 }
 
 static int af9015_read_config(struct dvb_usb_device *d)
 {
 	struct af9015_state *state = d_to_priv(d);
+	struct usb_interface *intf = d->intf;
 	int ret;
 	u8 val, i, offset = 0;
 	struct req_t req = {READ_I2C, AF9015_I2C_EEPROM, 0, 0, 1, 1, &val};
 
-	dev_dbg(&d->udev->dev, "%s:\n", __func__);
+	dev_dbg(&intf->dev, "\n");
 
 	/* IR remote controller */
 	req.addr = AF9015_EEPROM_IR_MODE;
@@ -462,7 +463,7 @@ static int af9015_read_config(struct dvb_usb_device *d)
 		goto error;
 
 	state->ir_mode = val;
-	dev_dbg(&d->udev->dev, "%s: IR mode=%d\n", __func__, val);
+	dev_dbg(&intf->dev, "ir mode %02x\n", val);
 
 	/* TS mode - one or two receivers */
 	req.addr = AF9015_EEPROM_TS_MODE;
@@ -471,7 +472,7 @@ static int af9015_read_config(struct dvb_usb_device *d)
 		goto error;
 
 	state->dual_mode = val;
-	dev_dbg(&d->udev->dev, "%s: TS mode=%d\n", __func__, state->dual_mode);
+	dev_dbg(&intf->dev, "ts mode %02x\n", state->dual_mode);
 
 	/* disable 2nd adapter because we don't have PID-filters */
 	if (d->udev->speed == USB_SPEED_FULL)
@@ -511,9 +512,8 @@ static int af9015_read_config(struct dvb_usb_device *d)
 			state->af9013_config[i].clock = 25000000;
 			break;
 		}
-		dev_dbg(&d->udev->dev, "%s: [%d] xtal=%d set clock=%d\n",
-				__func__, i, val,
-				state->af9013_config[i].clock);
+		dev_dbg(&intf->dev, "[%d] xtal %02x, clock %u\n",
+			i, val, state->af9013_config[i].clock);
 
 		/* IF frequency */
 		req.addr = AF9015_EEPROM_IF1H + offset;
@@ -530,8 +530,8 @@ static int af9015_read_config(struct dvb_usb_device *d)
 
 		state->af9013_config[i].if_frequency += val;
 		state->af9013_config[i].if_frequency *= 1000;
-		dev_dbg(&d->udev->dev, "%s: [%d] IF frequency=%d\n", __func__,
-				i, state->af9013_config[i].if_frequency);
+		dev_dbg(&intf->dev, "[%d] if frequency %u\n",
+			i, state->af9013_config[i].if_frequency);
 
 		/* MT2060 IF1 */
 		req.addr = AF9015_EEPROM_MT2060_IF1H  + offset;
@@ -544,8 +544,8 @@ static int af9015_read_config(struct dvb_usb_device *d)
 		if (ret)
 			goto error;
 		state->mt2060_if1[i] += val;
-		dev_dbg(&d->udev->dev, "%s: [%d] MT2060 IF1=%d\n", __func__, i,
-				state->mt2060_if1[i]);
+		dev_dbg(&intf->dev, "[%d] MT2060 IF1 %u\n",
+			i, state->mt2060_if1[i]);
 
 		/* tuner */
 		req.addr =  AF9015_EEPROM_TUNER_ID1 + offset;
@@ -574,21 +574,19 @@ static int af9015_read_config(struct dvb_usb_device *d)
 			state->af9013_config[i].spec_inv = 1;
 			break;
 		default:
-			dev_err(&d->udev->dev, "%s: tuner id=%d not " \
-					"supported, please report!\n",
-					KBUILD_MODNAME, val);
+			dev_err(&intf->dev,
+				"tuner id %02x not supported, please report!\n",
+				val);
 			return -ENODEV;
 		}
 
 		state->af9013_config[i].tuner = val;
-		dev_dbg(&d->udev->dev, "%s: [%d] tuner id=%d\n",
-				__func__, i, val);
+		dev_dbg(&intf->dev, "[%d] tuner id %02x\n", i, val);
 	}
 
 error:
 	if (ret)
-		dev_err(&d->udev->dev, "%s: eeprom read failed=%d\n",
-				KBUILD_MODNAME, ret);
+		dev_err(&intf->dev, "eeprom read failed %d\n", ret);
 
 	/* AverMedia AVerTV Volar Black HD (A850) device have bad EEPROM
 	   content :-( Override some wrong values here. Ditto for the
@@ -598,9 +596,7 @@ static int af9015_read_config(struct dvb_usb_device *d)
 			USB_PID_AVERMEDIA_A850) ||
 		(le16_to_cpu(d->udev->descriptor.idProduct) ==
 			USB_PID_AVERMEDIA_A850T))) {
-		dev_dbg(&d->udev->dev,
-				"%s: AverMedia A850: overriding config\n",
-				__func__);
+		dev_dbg(&intf->dev, "AverMedia A850: overriding config\n");
 		/* disable dual mode */
 		state->dual_mode = 0;
 
@@ -615,7 +611,9 @@ static int af9015_get_stream_config(struct dvb_frontend *fe, u8 *ts_type,
 		struct usb_data_stream_properties *stream)
 {
 	struct dvb_usb_device *d = fe_to_d(fe);
-	dev_dbg(&d->udev->dev, "%s: adap=%d\n", __func__, fe_to_adap(fe)->id);
+	struct usb_interface *intf = d->intf;
+
+	dev_dbg(&intf->dev, "adap %u\n", fe_to_adap(fe)->id);
 
 	if (d->udev->speed == USB_SPEED_FULL)
 		stream->u.bulk.buffersize = TS_USB11_FRAME_SIZE;
@@ -729,12 +727,14 @@ static int af9015_tuner_sleep(struct dvb_frontend *fe)
 static int af9015_copy_firmware(struct dvb_usb_device *d)
 {
 	struct af9015_state *state = d_to_priv(d);
+	struct usb_interface *intf = d->intf;
 	int ret;
 	u8 fw_params[4];
 	u8 val, i;
 	struct req_t req = {COPY_FIRMWARE, 0, 0x5100, 0, 0, sizeof(fw_params),
 		fw_params };
-	dev_dbg(&d->udev->dev, "%s:\n", __func__);
+
+	dev_dbg(&intf->dev, "\n");
 
 	fw_params[0] = state->firmware_size >> 8;
 	fw_params[1] = state->firmware_size & 0xff;
@@ -746,8 +746,7 @@ static int af9015_copy_firmware(struct dvb_usb_device *d)
 	if (ret)
 		goto error;
 	else
-		dev_dbg(&d->udev->dev, "%s: firmware status=%02x\n",
-				__func__, val);
+		dev_dbg(&intf->dev, "firmware status %02x\n", val);
 
 	if (val == 0x0c) /* fw is running, no need for download */
 		goto exit;
@@ -762,10 +761,9 @@ static int af9015_copy_firmware(struct dvb_usb_device *d)
 	/* copy firmware */
 	ret = af9015_ctrl_msg(d, &req);
 	if (ret)
-		dev_err(&d->udev->dev, "%s: firmware copy cmd failed=%d\n",
-				KBUILD_MODNAME, ret);
+		dev_err(&intf->dev, "firmware copy cmd failed %d\n", ret);
 
-	dev_dbg(&d->udev->dev, "%s: firmware copy done\n", __func__);
+	dev_dbg(&intf->dev, "firmware copy done\n");
 
 	/* set I2C master clock back to normal */
 	ret = af9015_write_reg(d, 0xd416, 0x14); /* 0x14 * 400ns */
@@ -775,8 +773,7 @@ static int af9015_copy_firmware(struct dvb_usb_device *d)
 	/* request boot firmware */
 	ret = af9015_write_reg_i2c(d, state->af9013_config[1].i2c_addr,
 			0xe205, 1);
-	dev_dbg(&d->udev->dev, "%s: firmware boot cmd status=%d\n",
-			__func__, ret);
+	dev_dbg(&intf->dev, "firmware boot cmd status %d\n", ret);
 	if (ret)
 		goto error;
 
@@ -786,8 +783,8 @@ static int af9015_copy_firmware(struct dvb_usb_device *d)
 		/* check firmware status */
 		ret = af9015_read_reg_i2c(d, state->af9013_config[1].i2c_addr,
 				0x98be, &val);
-		dev_dbg(&d->udev->dev, "%s: firmware status cmd status=%d " \
-				"firmware status=%02x\n", __func__, ret, val);
+		dev_dbg(&intf->dev, "firmware status cmd status %d, firmware status %02x\n",
+			ret, val);
 		if (ret)
 			goto error;
 
@@ -796,13 +793,11 @@ static int af9015_copy_firmware(struct dvb_usb_device *d)
 	}
 
 	if (val == 0x04) {
-		dev_err(&d->udev->dev, "%s: firmware did not run\n",
-				KBUILD_MODNAME);
 		ret = -ETIMEDOUT;
+		dev_err(&intf->dev, "firmware did not run\n");
 	} else if (val != 0x0c) {
-		dev_err(&d->udev->dev, "%s: firmware boot timeout\n",
-				KBUILD_MODNAME);
 		ret = -ETIMEDOUT;
+		dev_err(&intf->dev, "firmware boot timeout\n");
 	}
 
 error:
@@ -812,8 +807,10 @@ static int af9015_copy_firmware(struct dvb_usb_device *d)
 
 static int af9015_af9013_frontend_attach(struct dvb_usb_adapter *adap)
 {
-	int ret;
 	struct af9015_state *state = adap_to_priv(adap);
+	struct dvb_usb_device *d = adap_to_d(adap);
+	struct usb_interface *intf = d->intf;
+	int ret;
 
 	if (adap->id == 0) {
 		state->af9013_config[0].ts_mode = AF9013_TS_USB;
@@ -833,10 +830,8 @@ static int af9015_af9013_frontend_attach(struct dvb_usb_adapter *adap)
 
 			ret = af9015_copy_firmware(adap_to_d(adap));
 			if (ret) {
-				dev_err(&adap_to_d(adap)->udev->dev,
-						"%s: firmware copy to 2nd " \
-						"frontend failed, will " \
-						"disable it\n", KBUILD_MODNAME);
+				dev_err(&intf->dev,
+					"firmware copy to 2nd frontend failed, will disable it\n");
 				state->dual_mode = 0;
 				return -ENODEV;
 			}
@@ -944,8 +939,10 @@ static int af9015_tuner_attach(struct dvb_usb_adapter *adap)
 {
 	struct dvb_usb_device *d = adap_to_d(adap);
 	struct af9015_state *state = d_to_priv(d);
+	struct usb_interface *intf = d->intf;
 	int ret;
-	dev_dbg(&d->udev->dev, "%s:\n", __func__);
+
+	dev_dbg(&intf->dev, "\n");
 
 	switch (state->af9013_config[adap->id].tuner) {
 	case AF9013_TUNER_MT2060:
@@ -999,9 +996,8 @@ static int af9015_tuner_attach(struct dvb_usb_adapter *adap)
 		break;
 	case AF9013_TUNER_UNKNOWN:
 	default:
-		dev_err(&d->udev->dev, "%s: unknown tuner id=%d\n",
-				KBUILD_MODNAME,
-				state->af9013_config[adap->id].tuner);
+		dev_err(&intf->dev, "unknown tuner, tuner id %02x\n",
+			state->af9013_config[adap->id].tuner);
 		ret = -ENODEV;
 	}
 
@@ -1023,8 +1019,10 @@ static int af9015_tuner_attach(struct dvb_usb_adapter *adap)
 static int af9015_pid_filter_ctrl(struct dvb_usb_adapter *adap, int onoff)
 {
 	struct dvb_usb_device *d = adap_to_d(adap);
+	struct usb_interface *intf = d->intf;
 	int ret;
-	dev_dbg(&d->udev->dev, "%s: onoff=%d\n", __func__, onoff);
+
+	dev_dbg(&intf->dev, "onoff %d\n", onoff);
 
 	if (onoff)
 		ret = af9015_set_reg_bit(d, 0xd503, 0);
@@ -1038,10 +1036,12 @@ static int af9015_pid_filter(struct dvb_usb_adapter *adap, int index, u16 pid,
 	int onoff)
 {
 	struct dvb_usb_device *d = adap_to_d(adap);
+	struct usb_interface *intf = d->intf;
 	int ret;
 	u8 idx;
-	dev_dbg(&d->udev->dev, "%s: index=%d pid=%04x onoff=%d\n",
-			__func__, index, pid, onoff);
+
+	dev_dbg(&intf->dev, "index %d, pid %04x, onoff %d\n",
+		index, pid, onoff);
 
 	ret = af9015_write_reg(d, 0xd505, (pid & 0xff));
 	if (ret)
@@ -1061,10 +1061,12 @@ static int af9015_pid_filter(struct dvb_usb_adapter *adap, int index, u16 pid,
 static int af9015_init_endpoint(struct dvb_usb_device *d)
 {
 	struct af9015_state *state = d_to_priv(d);
+	struct usb_interface *intf = d->intf;
 	int ret;
 	u16 frame_size;
 	u8  packet_size;
-	dev_dbg(&d->udev->dev, "%s: USB speed=%d\n", __func__, d->udev->speed);
+
+	dev_dbg(&intf->dev, "usb speed %u\n", d->udev->speed);
 
 	if (d->udev->speed == USB_SPEED_FULL) {
 		frame_size = TS_USB11_FRAME_SIZE/4;
@@ -1150,8 +1152,7 @@ static int af9015_init_endpoint(struct dvb_usb_device *d)
 
 error:
 	if (ret)
-		dev_err(&d->udev->dev, "%s: endpoint init failed=%d\n",
-				KBUILD_MODNAME, ret);
+		dev_err(&intf->dev, "endpoint init failed %d\n", ret);
 
 	return ret;
 }
@@ -1159,8 +1160,10 @@ static int af9015_init_endpoint(struct dvb_usb_device *d)
 static int af9015_init(struct dvb_usb_device *d)
 {
 	struct af9015_state *state = d_to_priv(d);
+	struct usb_interface *intf = d->intf;
 	int ret;
-	dev_dbg(&d->udev->dev, "%s:\n", __func__);
+
+	dev_dbg(&intf->dev, "\n");
 
 	mutex_init(&state->fe_mutex);
 
@@ -1212,6 +1215,7 @@ static const struct af9015_rc_setup af9015_rc_setup_hashes[] = {
 static int af9015_rc_query(struct dvb_usb_device *d)
 {
 	struct af9015_state *state = d_to_priv(d);
+	struct usb_interface *intf = d->intf;
 	int ret;
 	u8 buf[17];
 
@@ -1222,14 +1226,14 @@ static int af9015_rc_query(struct dvb_usb_device *d)
 
 	/* If any of these are non-zero, assume invalid data */
 	if (buf[1] || buf[2] || buf[3]) {
-		dev_dbg(&d->udev->dev, "%s: invalid data\n", __func__);
+		dev_dbg(&intf->dev, "invalid data\n");
 		return ret;
 	}
 
 	/* Check for repeat of previous code */
 	if ((state->rc_repeat != buf[6] || buf[0]) &&
 			!memcmp(&buf[12], state->rc_last, 4)) {
-		dev_dbg(&d->udev->dev, "%s: key repeated\n", __func__);
+		dev_dbg(&intf->dev, "key repeated\n");
 		rc_repeat(d->rc_dev);
 		state->rc_repeat = buf[6];
 		return ret;
@@ -1238,8 +1242,7 @@ static int af9015_rc_query(struct dvb_usb_device *d)
 	/* Only process key if canary killed */
 	if (buf[16] != 0xff && buf[0] != 0x01) {
 		enum rc_proto proto;
-		dev_dbg(&d->udev->dev, "%s: key pressed %*ph\n",
-				__func__, 4, buf + 12);
+		dev_dbg(&intf->dev, "key pressed %*ph\n", 4, buf + 12);
 
 		/* Reset the canary */
 		ret = af9015_write_reg(d, 0x98e9, 0xff);
@@ -1271,7 +1274,7 @@ static int af9015_rc_query(struct dvb_usb_device *d)
 		}
 		rc_keydown(d->rc_dev, proto, state->rc_keycode, 0);
 	} else {
-		dev_dbg(&d->udev->dev, "%s: no key press\n", __func__);
+		dev_dbg(&intf->dev, "no key press\n");
 		/* Invalidate last keypress */
 		/* Not really needed, but helps with debug */
 		state->rc_last[2] = state->rc_last[3];
@@ -1282,8 +1285,7 @@ static int af9015_rc_query(struct dvb_usb_device *d)
 
 error:
 	if (ret) {
-		dev_warn(&d->udev->dev, "%s: rc query failed=%d\n",
-				KBUILD_MODNAME, ret);
+		dev_warn(&intf->dev, "rc query failed %d\n", ret);
 
 		/* allow random errors as dvb-usb will stop polling on error */
 		if (!state->rc_failed)
@@ -1376,7 +1378,7 @@ static int af9015_probe(struct usb_interface *intf,
 	if ((le16_to_cpu(udev->descriptor.idVendor) == USB_VID_TERRATEC) &&
 			(le16_to_cpu(udev->descriptor.idProduct) == 0x0099)) {
 		if (!strcmp("ITE Technologies, Inc.", manufacturer)) {
-			dev_dbg(&udev->dev, "%s: rejecting device\n", __func__);
+			dev_dbg(&intf->dev, "rejecting device\n");
 			return -ENODEV;
 		}
 	}

commit 6d741bfed5ed06ed42a16d30f1ed7afdcaf7f092
Author: Sean Young <sean@mess.org>
Date:   Mon Aug 7 16:20:58 2017 -0400

    media: rc: rename RC_TYPE_* to RC_PROTO_* and RC_BIT_* to RC_PROTO_BIT_*
    
    RC_TYPE is confusing and it's just the protocol. So rename it.
    
    Suggested-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Sean Young <sean@mess.org>
    Acked-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/usb/dvb-usb-v2/af9015.c b/drivers/media/usb/dvb-usb-v2/af9015.c
index 23bbbf367b51..8013659c41b1 100644
--- a/drivers/media/usb/dvb-usb-v2/af9015.c
+++ b/drivers/media/usb/dvb-usb-v2/af9015.c
@@ -1237,7 +1237,7 @@ static int af9015_rc_query(struct dvb_usb_device *d)
 
 	/* Only process key if canary killed */
 	if (buf[16] != 0xff && buf[0] != 0x01) {
-		enum rc_type proto;
+		enum rc_proto proto;
 		dev_dbg(&d->udev->dev, "%s: key pressed %*ph\n",
 				__func__, 4, buf + 12);
 
@@ -1253,13 +1253,13 @@ static int af9015_rc_query(struct dvb_usb_device *d)
 				/* NEC */
 				state->rc_keycode = RC_SCANCODE_NEC(buf[12],
 								    buf[14]);
-				proto = RC_TYPE_NEC;
+				proto = RC_PROTO_NEC;
 			} else {
 				/* NEC extended*/
 				state->rc_keycode = RC_SCANCODE_NECX(buf[12] << 8 |
 								     buf[13],
 								     buf[14]);
-				proto = RC_TYPE_NECX;
+				proto = RC_PROTO_NECX;
 			}
 		} else {
 			/* 32 bit NEC */
@@ -1267,7 +1267,7 @@ static int af9015_rc_query(struct dvb_usb_device *d)
 							      buf[13] << 16 |
 							      buf[14] << 8  |
 							      buf[15]);
-			proto = RC_TYPE_NEC32;
+			proto = RC_PROTO_NEC32;
 		}
 		rc_keydown(d->rc_dev, proto, state->rc_keycode, 0);
 	} else {
@@ -1336,7 +1336,8 @@ static int af9015_get_rc_config(struct dvb_usb_device *d, struct dvb_usb_rc *rc)
 	if (!rc->map_name)
 		rc->map_name = RC_MAP_EMPTY;
 
-	rc->allowed_protos = RC_BIT_NEC | RC_BIT_NECX | RC_BIT_NEC32;
+	rc->allowed_protos = RC_PROTO_BIT_NEC | RC_PROTO_BIT_NECX |
+						RC_PROTO_BIT_NEC32;
 	rc->query = af9015_rc_query;
 	rc->interval = 500;
 

commit b5e0e1a3177150fb4758e1ff5f78ca49041a8a8f
Author: Antti Palosaari <crope@iki.fi>
Date:   Tue Jun 13 21:32:08 2017 -0300

    [media] af9015: move 2nd demod power-up wait different location
    
    We need to wait 2nd demod power-up before download firmware. Move
    that wait to more correct location.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/usb/dvb-usb-v2/af9015.c b/drivers/media/usb/dvb-usb-v2/af9015.c
index 2b9bb81ed1f2..23bbbf367b51 100644
--- a/drivers/media/usb/dvb-usb-v2/af9015.c
+++ b/drivers/media/usb/dvb-usb-v2/af9015.c
@@ -741,9 +741,6 @@ static int af9015_copy_firmware(struct dvb_usb_device *d)
 	fw_params[2] = state->firmware_checksum >> 8;
 	fw_params[3] = state->firmware_checksum & 0xff;
 
-	/* wait 2nd demodulator ready */
-	msleep(100);
-
 	ret = af9015_read_reg_i2c(d, state->af9013_config[1].i2c_addr,
 			0x98be, &val);
 	if (ret)
@@ -831,6 +828,9 @@ static int af9015_af9013_frontend_attach(struct dvb_usb_adapter *adap)
 
 		/* copy firmware to 2nd demodulator */
 		if (state->dual_mode) {
+			/* Wait 2nd demodulator ready */
+			msleep(100);
+
 			ret = af9015_copy_firmware(adap_to_d(adap));
 			if (ret) {
 				dev_err(&adap_to_d(adap)->udev->dev,

commit e94db976b736d3cac6dc23021e2508de65190f54
Author: Antti Palosaari <crope@iki.fi>
Date:   Tue Jun 13 05:29:50 2017 -0300

    [media] af9015: enable 2nd TS flow control when dual mode
    
    It needs to be enabled in order to get stream from slave af9013 demod.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/usb/dvb-usb-v2/af9015.c b/drivers/media/usb/dvb-usb-v2/af9015.c
index 49aec2f940e9..2b9bb81ed1f2 100644
--- a/drivers/media/usb/dvb-usb-v2/af9015.c
+++ b/drivers/media/usb/dvb-usb-v2/af9015.c
@@ -1132,10 +1132,21 @@ static int af9015_init_endpoint(struct dvb_usb_device *d)
 	}
 
 	/* enable / disable mp2if2 */
-	if (state->dual_mode)
+	if (state->dual_mode) {
 		ret = af9015_set_reg_bit(d, 0xd50b, 0);
-	else
+		if (ret)
+			goto error;
+		ret = af9015_set_reg_bit(d, 0xd520, 4);
+		if (ret)
+			goto error;
+	} else {
 		ret = af9015_clear_reg_bit(d, 0xd50b, 0);
+		if (ret)
+			goto error;
+		ret = af9015_clear_reg_bit(d, 0xd520, 4);
+		if (ret)
+			goto error;
+	}
 
 error:
 	if (ret)

commit d83886ff118cd93d85617362a582beec20c9e92d
Author: Antti Palosaari <crope@iki.fi>
Date:   Mon Jun 12 17:06:19 2017 -0300

    [media] af9015: fix and refactor i2c adapter algo logic
    
    * fix write+read when write has more than one byte
    * remove lock, not needed on that case
    * remove useless i2c msg send loop, as we support only write, read and
    write+read as one go and nothing more
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/usb/dvb-usb-v2/af9015.c b/drivers/media/usb/dvb-usb-v2/af9015.c
index ea16b627cb0b..49aec2f940e9 100644
--- a/drivers/media/usb/dvb-usb-v2/af9015.c
+++ b/drivers/media/usb/dvb-usb-v2/af9015.c
@@ -206,9 +206,9 @@ static int af9015_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msg[],
 {
 	struct dvb_usb_device *d = i2c_get_adapdata(adap);
 	struct af9015_state *state = d_to_priv(d);
-	int ret = 0, i = 0;
+	int ret;
 	u16 addr;
-	u8 uninitialized_var(mbox), addr_len;
+	u8 mbox, addr_len;
 	struct req_t req;
 
 /*
@@ -233,84 +233,89 @@ Due to that the only way to select correct tuner is use demodulator I2C-gate.
 				| addr 0x3a  |                 |  addr 0xc6 |
 				|____________|                 |____________|
 */
-	if (mutex_lock_interruptible(&d->i2c_mutex) < 0)
-		return -EAGAIN;
 
-	while (i < num) {
-		if (msg[i].addr == state->af9013_config[0].i2c_addr ||
-		    msg[i].addr == state->af9013_config[1].i2c_addr) {
-			addr = msg[i].buf[0] << 8;
-			addr += msg[i].buf[1];
-			mbox = msg[i].buf[2];
-			addr_len = 3;
-		} else {
-			addr = msg[i].buf[0];
-			addr_len = 1;
-			/* mbox is don't care in that case */
-		}
+	if (msg[0].len == 0 || msg[0].flags & I2C_M_RD) {
+		addr = 0x0000;
+		mbox = 0;
+		addr_len = 0;
+	} else if (msg[0].len == 1) {
+		addr = msg[0].buf[0];
+		mbox = 0;
+		addr_len = 1;
+	} else if (msg[0].len == 2) {
+		addr = msg[0].buf[0] << 8|msg[0].buf[1] << 0;
+		mbox = 0;
+		addr_len = 2;
+	} else {
+		addr = msg[0].buf[0] << 8|msg[0].buf[1] << 0;
+		mbox = msg[0].buf[2];
+		addr_len = 3;
+	}
 
-		if (num > i + 1 && (msg[i+1].flags & I2C_M_RD)) {
-			if (msg[i].len > 3 || msg[i+1].len > 61) {
-				ret = -EOPNOTSUPP;
-				goto error;
-			}
-			if (msg[i].addr == state->af9013_config[0].i2c_addr)
-				req.cmd = READ_MEMORY;
-			else
-				req.cmd = READ_I2C;
-			req.i2c_addr = msg[i].addr;
-			req.addr = addr;
-			req.mbox = mbox;
-			req.addr_len = addr_len;
-			req.data_len = msg[i+1].len;
-			req.data = &msg[i+1].buf[0];
-			ret = af9015_ctrl_msg(d, &req);
-			i += 2;
-		} else if (msg[i].flags & I2C_M_RD) {
-			if (msg[i].len > 61) {
-				ret = -EOPNOTSUPP;
-				goto error;
-			}
-			if (msg[i].addr == state->af9013_config[0].i2c_addr) {
-				ret = -EINVAL;
-				goto error;
-			}
+	if (num == 1 && !(msg[0].flags & I2C_M_RD)) {
+		/* i2c write */
+		if (msg[0].len > 21) {
+			ret = -EOPNOTSUPP;
+			goto err;
+		}
+		if (msg[0].addr == state->af9013_config[0].i2c_addr)
+			req.cmd = WRITE_MEMORY;
+		else
+			req.cmd = WRITE_I2C;
+		req.i2c_addr = msg[0].addr;
+		req.addr = addr;
+		req.mbox = mbox;
+		req.addr_len = addr_len;
+		req.data_len = msg[0].len-addr_len;
+		req.data = &msg[0].buf[addr_len];
+		ret = af9015_ctrl_msg(d, &req);
+	} else if (num == 2 && !(msg[0].flags & I2C_M_RD) &&
+		   (msg[1].flags & I2C_M_RD)) {
+		/* i2c write + read */
+		if (msg[0].len > 3 || msg[1].len > 61) {
+			ret = -EOPNOTSUPP;
+			goto err;
+		}
+		if (msg[0].addr == state->af9013_config[0].i2c_addr)
+			req.cmd = READ_MEMORY;
+		else
 			req.cmd = READ_I2C;
-			req.i2c_addr = msg[i].addr;
-			req.addr = addr;
-			req.mbox = mbox;
-			req.addr_len = addr_len;
-			req.data_len = msg[i].len;
-			req.data = &msg[i].buf[0];
-			ret = af9015_ctrl_msg(d, &req);
-			i += 1;
-		} else {
-			if (msg[i].len > 21) {
-				ret = -EOPNOTSUPP;
-				goto error;
-			}
-			if (msg[i].addr == state->af9013_config[0].i2c_addr)
-				req.cmd = WRITE_MEMORY;
-			else
-				req.cmd = WRITE_I2C;
-			req.i2c_addr = msg[i].addr;
-			req.addr = addr;
-			req.mbox = mbox;
-			req.addr_len = addr_len;
-			req.data_len = msg[i].len-addr_len;
-			req.data = &msg[i].buf[addr_len];
-			ret = af9015_ctrl_msg(d, &req);
-			i += 1;
+		req.i2c_addr = msg[0].addr;
+		req.addr = addr;
+		req.mbox = mbox;
+		req.addr_len = addr_len;
+		req.data_len = msg[1].len;
+		req.data = &msg[1].buf[0];
+		ret = af9015_ctrl_msg(d, &req);
+	} else if (num == 1 && (msg[0].flags & I2C_M_RD)) {
+		/* i2c read */
+		if (msg[0].len > 61) {
+			ret = -EOPNOTSUPP;
+			goto err;
 		}
-		if (ret)
-			goto error;
-
+		if (msg[0].addr == state->af9013_config[0].i2c_addr) {
+			ret = -EINVAL;
+			goto err;
+		}
+		req.cmd = READ_I2C;
+		req.i2c_addr = msg[0].addr;
+		req.addr = addr;
+		req.mbox = mbox;
+		req.addr_len = addr_len;
+		req.data_len = msg[0].len;
+		req.data = &msg[0].buf[0];
+		ret = af9015_ctrl_msg(d, &req);
+	} else {
+		ret = -EOPNOTSUPP;
+		dev_dbg(&d->udev->dev, "%s: unknown msg, num %u\n",
+			__func__, num);
 	}
-	ret = i;
-
-error:
-	mutex_unlock(&d->i2c_mutex);
+	if (ret)
+		goto err;
 
+	return num;
+err:
+	dev_dbg(&d->udev->dev, "%s: failed %d\n", __func__, ret);
 	return ret;
 }
 

commit 5ded0eb7f820039f4de06b5ec2a175b5dd9ddc1a
Author: Antti Palosaari <crope@iki.fi>
Date:   Sun Feb 5 18:09:38 2017 -0200

    [media] af9015: use correct 7-bit i2c addresses
    
    Driver was using wrong "8-bit" i2c addresses for demods and tuners.
    Internal demod i2c address was not set at all. These are needed
    to be fixed before proper i2c client binding is used.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/usb/dvb-usb-v2/af9015.c b/drivers/media/usb/dvb-usb-v2/af9015.c
index 612431ab0fb3..ea16b627cb0b 100644
--- a/drivers/media/usb/dvb-usb-v2/af9015.c
+++ b/drivers/media/usb/dvb-usb-v2/af9015.c
@@ -36,7 +36,7 @@ static int af9015_ctrl_msg(struct dvb_usb_device *d, struct req_t *req)
 
 	state->buf[0] = req->cmd;
 	state->buf[1] = state->seq++;
-	state->buf[2] = req->i2c_addr;
+	state->buf[2] = req->i2c_addr << 1;
 	state->buf[3] = req->addr >> 8;
 	state->buf[4] = req->addr & 0xff;
 	state->buf[5] = req->mbox;
@@ -472,6 +472,8 @@ static int af9015_read_config(struct dvb_usb_device *d)
 	if (d->udev->speed == USB_SPEED_FULL)
 		state->dual_mode = 0;
 
+	state->af9013_config[0].i2c_addr = AF9015_I2C_DEMOD;
+
 	if (state->dual_mode) {
 		/* read 2nd demodulator I2C address */
 		req.addr = AF9015_EEPROM_DEMOD2_I2C;
@@ -479,7 +481,7 @@ static int af9015_read_config(struct dvb_usb_device *d)
 		if (ret)
 			goto error;
 
-		state->af9013_config[1].i2c_addr = val;
+		state->af9013_config[1].i2c_addr = val >> 1;
 	}
 
 	for (i = 0; i < state->dual_mode + 1; i++) {
@@ -871,12 +873,12 @@ static int af9015_af9013_frontend_attach(struct dvb_usb_adapter *adap)
 }
 
 static struct mt2060_config af9015_mt2060_config = {
-	.i2c_address = 0xc0,
+	.i2c_address = 0x60,
 	.clock_out = 0,
 };
 
 static struct qt1010_config af9015_qt1010_config = {
-	.i2c_address = 0xc4,
+	.i2c_address = 0x62,
 };
 
 static struct tda18271_config af9015_tda18271_config = {
@@ -885,7 +887,7 @@ static struct tda18271_config af9015_tda18271_config = {
 };
 
 static struct mxl5005s_config af9015_mxl5003_config = {
-	.i2c_address     = 0xc6,
+	.i2c_address     = 0x63,
 	.if_freq         = IF_FREQ_4570000HZ,
 	.xtal_freq       = CRYSTAL_FREQ_16000000HZ,
 	.agc_mode        = MXL_SINGLE_AGC,
@@ -902,7 +904,7 @@ static struct mxl5005s_config af9015_mxl5003_config = {
 };
 
 static struct mxl5005s_config af9015_mxl5005_config = {
-	.i2c_address     = 0xc6,
+	.i2c_address     = 0x63,
 	.if_freq         = IF_FREQ_4570000HZ,
 	.xtal_freq       = CRYSTAL_FREQ_16000000HZ,
 	.agc_mode        = MXL_SINGLE_AGC,
@@ -919,12 +921,12 @@ static struct mxl5005s_config af9015_mxl5005_config = {
 };
 
 static struct mc44s803_config af9015_mc44s803_config = {
-	.i2c_address = 0xc0,
+	.i2c_address = 0x60,
 	.dig_out = 1,
 };
 
 static struct tda18218_config af9015_tda18218_config = {
-	.i2c_address = 0xc0,
+	.i2c_address = 0x60,
 	.i2c_wr_max = 21, /* max wr bytes AF9015 I2C adap can handle at once */
 };
 
@@ -955,7 +957,7 @@ static int af9015_tuner_attach(struct dvb_usb_adapter *adap)
 			&af9015_qt1010_config) == NULL ? -ENODEV : 0;
 		break;
 	case AF9013_TUNER_TDA18271:
-		ret = dvb_attach(tda18271_attach, adap->fe[0], 0xc0,
+		ret = dvb_attach(tda18271_attach, adap->fe[0], 0x60,
 			&adap_to_d(adap)->i2c_adap,
 			&af9015_tda18271_config) == NULL ? -ENODEV : 0;
 		break;
@@ -976,7 +978,7 @@ static int af9015_tuner_attach(struct dvb_usb_adapter *adap)
 			&af9015_mxl5005_config) == NULL ? -ENODEV : 0;
 		break;
 	case AF9013_TUNER_ENV77H11D5:
-		ret = dvb_attach(dvb_pll_attach, adap->fe[0], 0xc0,
+		ret = dvb_attach(dvb_pll_attach, adap->fe[0], 0x60,
 			&adap_to_d(adap)->i2c_adap,
 			DVB_PLL_TDA665X) == NULL ? -ENODEV : 0;
 		break;
@@ -988,7 +990,7 @@ static int af9015_tuner_attach(struct dvb_usb_adapter *adap)
 	case AF9013_TUNER_MXL5007T:
 		ret = dvb_attach(mxl5007t_attach, adap->fe[0],
 			&adap_to_d(adap)->i2c_adap,
-			0xc0, &af9015_mxl5007t_config) == NULL ? -ENODEV : 0;
+			0x60, &af9015_mxl5007t_config) == NULL ? -ENODEV : 0;
 		break;
 	case AF9013_TUNER_UNKNOWN:
 	default:

commit 06eeefe8e310bf955da7f82547c72c43e4653d97
Author: Mauro Carvalho Chehab <mchehab@s-opensource.com>
Date:   Thu May 18 08:13:28 2017 -0300

    [media] media drivers: annotate fall-through
    
    Avoid warnings like those:
    
    drivers/media/pci/ddbridge/ddbridge-core.c: In function 'dvb_input_detach':
    drivers/media/pci/ddbridge/ddbridge-core.c:787:6: warning: this statement may fall through [-Wimplicit-fallthrough=]
       if (input->fe) {
          ^
    drivers/media/pci/ddbridge/ddbridge-core.c:792:2: note: here
      case 4:
      ^~~~
    ...
    
    On several cases, it is just that gcc 7.1 is not capable of
    understanding the comment, but on other places, we need an
    annotation.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/usb/dvb-usb-v2/af9015.c b/drivers/media/usb/dvb-usb-v2/af9015.c
index caa1e6101f58..612431ab0fb3 100644
--- a/drivers/media/usb/dvb-usb-v2/af9015.c
+++ b/drivers/media/usb/dvb-usb-v2/af9015.c
@@ -52,6 +52,7 @@ static int af9015_ctrl_msg(struct dvb_usb_device *d, struct req_t *req)
 	case READ_I2C:
 		write = 0;
 		state->buf[2] |= 0x01; /* set I2C direction */
+		/* fall through */
 	case WRITE_I2C:
 		state->buf[0] = READ_WRITE_I2C;
 		break;

commit bcb63314e2c23f1ed622418b65f9409512659c73
Author: Sakari Ailus <sakari.ailus@linux.intel.com>
Date:   Fri Oct 28 09:31:20 2016 -0200

    [media] media: Drop FSF's postal address from the source code files
    
    Drop the FSF's postal address from the source code files that typically
    contain mostly the license text. Of the 628 removed instances, 578 are
    outdated.
    
    The patch has been created with the following command without manual edits:
    
    git grep -l "675 Mass Ave\|59 Temple Place\|51 Franklin St" -- \
            drivers/media/ include/media|while read i; do i=$i perl -e '
    open(F,"< $ENV{i}");
    $a=join("", <F>);
    $a =~ s/[ \t]*\*\n.*You should.*\n.*along with.*\n.*(\n.*USA.*$)?\n//m
            && $a =~ s/(^.*)Or, (point your browser to) /$1To obtain the license, $2\n$1/m;
    close(F);
    open(F, "> $ENV{i}");
    print F $a;
    close(F);'; done
    
    Signed-off-by: Sakari Ailus <sakari.ailus@linux.intel.com>

diff --git a/drivers/media/usb/dvb-usb-v2/af9015.c b/drivers/media/usb/dvb-usb-v2/af9015.c
index 29011dfabb11..caa1e6101f58 100644
--- a/drivers/media/usb/dvb-usb-v2/af9015.c
+++ b/drivers/media/usb/dvb-usb-v2/af9015.c
@@ -15,10 +15,6 @@
  *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *    GNU General Public License for more details.
  *
- *    You should have received a copy of the GNU General Public License
- *    along with this program; if not, write to the Free Software
- *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- *
  */
 
 #include "af9015.h"

commit 9165dabb2500b3dcb98fc648d27589a5a806227e
Author: Masanari Iida <standby24x7@gmail.com>
Date:   Sat Sep 17 23:44:17 2016 +0900

    treewide: Fix printk() message errors
    
    This patch fix spelling typos in printk and kconfig.
    
    Signed-off-by: Masanari Iida <standby24x7@gmail.com>
    Acked-by: Randy Dunlap <rdunlap@infradead.org>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/media/usb/dvb-usb-v2/af9015.c b/drivers/media/usb/dvb-usb-v2/af9015.c
index 941ceff9b268..29011dfabb11 100644
--- a/drivers/media/usb/dvb-usb-v2/af9015.c
+++ b/drivers/media/usb/dvb-usb-v2/af9015.c
@@ -1455,7 +1455,7 @@ static const struct usb_device_id af9015_id_table[] = {
 	{ DVB_USB_DEVICE(USB_VID_KWORLD_2, USB_PID_CONCEPTRONIC_CTVDIGRCU,
 		&af9015_props, "Conceptronic USB2.0 DVB-T CTVDIGRCU V3.0", NULL) },
 	{ DVB_USB_DEVICE(USB_VID_KWORLD_2, USB_PID_KWORLD_MC810,
-		&af9015_props, "KWorld Digial MC-810", NULL) },
+		&af9015_props, "KWorld Digital MC-810", NULL) },
 	{ DVB_USB_DEVICE(USB_VID_KYE, USB_PID_GENIUS_TVGO_DVB_T03,
 		&af9015_props, "Genius TVGo DVB-T03", NULL) },
 	{ DVB_USB_DEVICE(USB_VID_KWORLD_2, USB_PID_KWORLD_399U_2,

commit 2ceeca0499d745213306ecd785af17adb2321b6a
Author: Sean Young <sean@mess.org>
Date:   Wed Sep 21 06:54:19 2016 -0300

    [media] rc: split nec protocol into its three variants
    
    Currently we do not know what variant (bit length) of the nec protocol
    is used, other than from guessing from the length of the scancode. Now
    nec will be handled the same way as the sony protocol or the rc6 protocol;
    one variant per bit length.
    
    In the future we might want to expose the rc protocol type to userspace
    and we don't want to be introducing this world of pain into userspace
    too.
    
    Signed-off-by: Sean Young <sean@mess.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/usb/dvb-usb-v2/af9015.c b/drivers/media/usb/dvb-usb-v2/af9015.c
index 09e0f58f6bb7..941ceff9b268 100644
--- a/drivers/media/usb/dvb-usb-v2/af9015.c
+++ b/drivers/media/usb/dvb-usb-v2/af9015.c
@@ -1222,6 +1222,7 @@ static int af9015_rc_query(struct dvb_usb_device *d)
 
 	/* Only process key if canary killed */
 	if (buf[16] != 0xff && buf[0] != 0x01) {
+		enum rc_type proto;
 		dev_dbg(&d->udev->dev, "%s: key pressed %*ph\n",
 				__func__, 4, buf + 12);
 
@@ -1237,11 +1238,13 @@ static int af9015_rc_query(struct dvb_usb_device *d)
 				/* NEC */
 				state->rc_keycode = RC_SCANCODE_NEC(buf[12],
 								    buf[14]);
+				proto = RC_TYPE_NEC;
 			} else {
 				/* NEC extended*/
 				state->rc_keycode = RC_SCANCODE_NECX(buf[12] << 8 |
 								     buf[13],
 								     buf[14]);
+				proto = RC_TYPE_NECX;
 			}
 		} else {
 			/* 32 bit NEC */
@@ -1249,8 +1252,9 @@ static int af9015_rc_query(struct dvb_usb_device *d)
 							      buf[13] << 16 |
 							      buf[14] << 8  |
 							      buf[15]);
+			proto = RC_TYPE_NEC32;
 		}
-		rc_keydown(d->rc_dev, RC_TYPE_NEC, state->rc_keycode, 0);
+		rc_keydown(d->rc_dev, proto, state->rc_keycode, 0);
 	} else {
 		dev_dbg(&d->udev->dev, "%s: no key press\n", __func__);
 		/* Invalidate last keypress */
@@ -1317,7 +1321,7 @@ static int af9015_get_rc_config(struct dvb_usb_device *d, struct dvb_usb_rc *rc)
 	if (!rc->map_name)
 		rc->map_name = RC_MAP_EMPTY;
 
-	rc->allowed_protos = RC_BIT_NEC;
+	rc->allowed_protos = RC_BIT_NEC | RC_BIT_NECX | RC_BIT_NEC32;
 	rc->query = af9015_rc_query;
 	rc->interval = 500;
 

commit ef703f49a6c5b909a85149bb6625c4ed0d697186
Author: George Spelvin <linux@sciencehorizons.net>
Date:   Thu May 26 23:00:23 2016 -0400

    Eliminate bad hash multipliers from hash_32() and  hash_64()
    
    The "simplified" prime multipliers made very bad hash functions, so get rid
    of them.  This completes the work of 689de1d6ca.
    
    To avoid the inefficiency which was the motivation for the "simplified"
    multipliers, hash_64() on 32-bit systems is changed to use a different
    algorithm.  It makes two calls to hash_32() instead.
    
    drivers/media/usb/dvb-usb-v2/af9015.c uses the old GOLDEN_RATIO_PRIME_32
    for some horrible reason, so it inherits a copy of the old definition.
    
    Signed-off-by: George Spelvin <linux@sciencehorizons.net>
    Cc: Antti Palosaari <crope@iki.fi>
    Cc: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/drivers/media/usb/dvb-usb-v2/af9015.c b/drivers/media/usb/dvb-usb-v2/af9015.c
index 95a7388e89d4..09e0f58f6bb7 100644
--- a/drivers/media/usb/dvb-usb-v2/af9015.c
+++ b/drivers/media/usb/dvb-usb-v2/af9015.c
@@ -398,6 +398,8 @@ static int af9015_download_firmware(struct dvb_usb_device *d,
 }
 
 #define AF9015_EEPROM_SIZE 256
+/* 2^31 + 2^29 - 2^25 + 2^22 - 2^19 - 2^16 + 1 */
+#define GOLDEN_RATIO_PRIME_32 0x9e370001UL
 
 /* hash (and dump) eeprom */
 static int af9015_eeprom_hash(struct dvb_usb_device *d)

commit 0df289a209e02f0926042ab07d7d2595ea2d2e9b
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Sun Jun 7 14:53:52 2015 -0300

    [media] dvb: Get rid of typedev usage for enums
    
    The DVB API was originally defined using typedefs. This is against
    Kernel CodingStyle, and there's no good usage here. While we can't
    remove its usage on userspace, we can avoid its usage in Kernelspace.
    
    So, let's do it.
    
    This patch was generated by this shell script:
    
            for j in $(grep typedef include/uapi/linux/dvb/frontend.h |cut -d' ' -f 3); do for i in $(find drivers/media -name '*.[ch]' -type f) $(find drivers/staging/media -name '*.[ch]' -type f); do sed "s,${j}_t,enum $j," <$i >a && mv a $i; done; done
    
    While here, make CodingStyle fixes on the affected lines.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
    Acked-by: Stefan Richter <stefanr@s5r6.in-berlin.de> # for drivers/media/firewire/*

diff --git a/drivers/media/usb/dvb-usb-v2/af9015.c b/drivers/media/usb/dvb-usb-v2/af9015.c
index 16c0b7d4f8e7..95a7388e89d4 100644
--- a/drivers/media/usb/dvb-usb-v2/af9015.c
+++ b/drivers/media/usb/dvb-usb-v2/af9015.c
@@ -641,7 +641,7 @@ static int af9015_af9013_set_frontend(struct dvb_frontend *fe)
 
 /* override demod callbacks for resource locking */
 static int af9015_af9013_read_status(struct dvb_frontend *fe,
-	fe_status_t *status)
+	enum fe_status *status)
 {
 	int ret;
 	struct af9015_state *state = fe_to_priv(fe);

commit 744263246d8cdb838db5bc7743f9220de016f7dc
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Wed Aug 20 16:34:27 2014 -0300

    [media] af9015: fix sparse warning
    
    drivers/media/usb/dvb-usb-v2/af9015.c:422:38: warning: cast to restricted __le32
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/drivers/media/usb/dvb-usb-v2/af9015.c b/drivers/media/usb/dvb-usb-v2/af9015.c
index 5ca738ab44e0..16c0b7d4f8e7 100644
--- a/drivers/media/usb/dvb-usb-v2/af9015.c
+++ b/drivers/media/usb/dvb-usb-v2/af9015.c
@@ -419,7 +419,7 @@ static int af9015_eeprom_hash(struct dvb_usb_device *d)
 	/* calculate checksum */
 	for (i = 0; i < AF9015_EEPROM_SIZE / sizeof(u32); i++) {
 		state->eeprom_sum *= GOLDEN_RATIO_PRIME_32;
-		state->eeprom_sum += le32_to_cpu(((u32 *)buf)[i]);
+		state->eeprom_sum += le32_to_cpu(((__le32 *)buf)[i]);
 	}
 
 	for (i = 0; i < AF9015_EEPROM_SIZE; i += 16)

commit 120703f9eb32033f0e39bdc552c0273c8ab45f33
Author: David Hrdeman <david@hardeman.nu>
Date:   Thu Apr 3 20:31:30 2014 -0300

    [media] rc-core: document the protocol type
    
    Right now the protocol information is not preserved, rc-core gets handed a
    scancode but has no idea which protocol it corresponds to.
    
    This patch (which required reading through the source/keymap for all drivers,
    not fun) makes the protocol information explicit which is important
    documentation and makes it easier to e.g. support multiple protocols with one
    decoder (think rc5 and rc-streamzap). The information isn't used yet so there
    should be no functional changes.
    
    [m.chehab@samsung.com: rebased, added cxusb and removed bad whitespacing]
    Signed-off-by: David Hrdeman <david@hardeman.nu>
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/drivers/media/usb/dvb-usb-v2/af9015.c b/drivers/media/usb/dvb-usb-v2/af9015.c
index da47d2392f2a..5ca738ab44e0 100644
--- a/drivers/media/usb/dvb-usb-v2/af9015.c
+++ b/drivers/media/usb/dvb-usb-v2/af9015.c
@@ -1213,7 +1213,7 @@ static int af9015_rc_query(struct dvb_usb_device *d)
 	if ((state->rc_repeat != buf[6] || buf[0]) &&
 			!memcmp(&buf[12], state->rc_last, 4)) {
 		dev_dbg(&d->udev->dev, "%s: key repeated\n", __func__);
-		rc_keydown(d->rc_dev, state->rc_keycode, 0);
+		rc_repeat(d->rc_dev);
 		state->rc_repeat = buf[6];
 		return ret;
 	}
@@ -1233,18 +1233,22 @@ static int af9015_rc_query(struct dvb_usb_device *d)
 		if (buf[14] == (u8) ~buf[15]) {
 			if (buf[12] == (u8) ~buf[13]) {
 				/* NEC */
-				state->rc_keycode = buf[12] << 8 | buf[14];
+				state->rc_keycode = RC_SCANCODE_NEC(buf[12],
+								    buf[14]);
 			} else {
 				/* NEC extended*/
-				state->rc_keycode = buf[12] << 16 |
-					buf[13] << 8 | buf[14];
+				state->rc_keycode = RC_SCANCODE_NECX(buf[12] << 8 |
+								     buf[13],
+								     buf[14]);
 			}
 		} else {
 			/* 32 bit NEC */
-			state->rc_keycode = buf[12] << 24 | buf[13] << 16 |
-					buf[14] << 8 | buf[15];
+			state->rc_keycode = RC_SCANCODE_NEC32(buf[12] << 24 |
+							      buf[13] << 16 |
+							      buf[14] << 8  |
+							      buf[15]);
 		}
-		rc_keydown(d->rc_dev, state->rc_keycode, 0);
+		rc_keydown(d->rc_dev, RC_TYPE_NEC, state->rc_keycode, 0);
 	} else {
 		dev_dbg(&d->udev->dev, "%s: no key press\n", __func__);
 		/* Invalidate last keypress */

commit 65e2f1cb3fe0f0630834b9517ba8f631936f325c
Author: Mauro Carvalho Chehab <m.chehab@samsung.com>
Date:   Sat Nov 2 07:52:04 2013 -0300

    [media] af9015: Don't use dynamic static allocation
    
    Dynamic static allocation is evil, as Kernel stack is too low, and
    compilation complains about it on some archs:
            drivers/media/usb/dvb-usb-v2/af9015.c:433:1: warning: 'af9015_eeprom_hash' uses dynamic stack allocation [enabled by default]
    In this specific case, it is a gcc bug, as the size is a const, but
    it is easy to just change it from const to a #define, getting rid of
    the gcc warning.
    
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>
    Reviewed-by: Hans Verkuil <hans.verkuil@cisco.com>
    Reviewed-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/drivers/media/usb/dvb-usb-v2/af9015.c b/drivers/media/usb/dvb-usb-v2/af9015.c
index d556042cf312..da47d2392f2a 100644
--- a/drivers/media/usb/dvb-usb-v2/af9015.c
+++ b/drivers/media/usb/dvb-usb-v2/af9015.c
@@ -397,12 +397,13 @@ static int af9015_download_firmware(struct dvb_usb_device *d,
 	return ret;
 }
 
+#define AF9015_EEPROM_SIZE 256
+
 /* hash (and dump) eeprom */
 static int af9015_eeprom_hash(struct dvb_usb_device *d)
 {
 	struct af9015_state *state = d_to_priv(d);
 	int ret, i;
-	static const unsigned int AF9015_EEPROM_SIZE = 256;
 	u8 buf[AF9015_EEPROM_SIZE];
 	struct req_t req = {READ_I2C, AF9015_I2C_EEPROM, 0, 0, 1, 1, NULL};
 

commit e8c7aab50ddcb84f164422b5c8e0042a6fec6649
Author: Antti Palosaari <crope@iki.fi>
Date:   Mon Jan 7 16:29:13 2013 -0300

    [media] af9015: reject device TerraTec Cinergy T Stick Dual RC (rev. 2)
    
    That same USB ID is used both AF9015 and AF9035 driver.
    iManufacturer is only thing we can select correct driver without a I/O.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/usb/dvb-usb-v2/af9015.c b/drivers/media/usb/dvb-usb-v2/af9015.c
index 2fa7c6ee5a70..d556042cf312 100644
--- a/drivers/media/usb/dvb-usb-v2/af9015.c
+++ b/drivers/media/usb/dvb-usb-v2/af9015.c
@@ -1320,6 +1320,43 @@ static int af9015_get_rc_config(struct dvb_usb_device *d, struct dvb_usb_rc *rc)
 	#define af9015_get_rc_config NULL
 #endif
 
+static int af9015_probe(struct usb_interface *intf,
+		const struct usb_device_id *id)
+{
+	struct usb_device *udev = interface_to_usbdev(intf);
+	char manufacturer[sizeof("ITE Technologies, Inc.")];
+
+	memset(manufacturer, 0, sizeof(manufacturer));
+	usb_string(udev, udev->descriptor.iManufacturer,
+			manufacturer, sizeof(manufacturer));
+	/*
+	 * There is two devices having same ID but different chipset. One uses
+	 * AF9015 and the other IT9135 chipset. Only difference seen on lsusb
+	 * is iManufacturer string.
+	 *
+	 * idVendor           0x0ccd TerraTec Electronic GmbH
+	 * idProduct          0x0099
+	 * bcdDevice            2.00
+	 * iManufacturer           1 Afatech
+	 * iProduct                2 DVB-T 2
+	 *
+	 * idVendor           0x0ccd TerraTec Electronic GmbH
+	 * idProduct          0x0099
+	 * bcdDevice            2.00
+	 * iManufacturer           1 ITE Technologies, Inc.
+	 * iProduct                2 DVB-T TV Stick
+	 */
+	if ((le16_to_cpu(udev->descriptor.idVendor) == USB_VID_TERRATEC) &&
+			(le16_to_cpu(udev->descriptor.idProduct) == 0x0099)) {
+		if (!strcmp("ITE Technologies, Inc.", manufacturer)) {
+			dev_dbg(&udev->dev, "%s: rejecting device\n", __func__);
+			return -ENODEV;
+		}
+	}
+
+	return dvb_usbv2_probe(intf, id);
+}
+
 /* interface 0 is used by DVB-T receiver and
    interface 1 is for remote controller (HID) */
 static struct dvb_usb_device_properties af9015_props = {
@@ -1428,6 +1465,7 @@ static const struct usb_device_id af9015_id_table[] = {
 		&af9015_props, "AverMedia AVerTV Volar M (A815Mac)", NULL) },
 	{ DVB_USB_DEVICE(USB_VID_TERRATEC, USB_PID_TERRATEC_CINERGY_T_STICK_RC,
 		&af9015_props, "TerraTec Cinergy T Stick RC", RC_MAP_TERRATEC_SLIM_2) },
+	/* XXX: that same ID [0ccd:0099] is used by af9035 driver too */
 	{ DVB_USB_DEVICE(USB_VID_TERRATEC, USB_PID_TERRATEC_CINERGY_T_STICK_DUAL_RC,
 		&af9015_props, "TerraTec Cinergy T Stick Dual RC", RC_MAP_TERRATEC_SLIM) },
 	{ DVB_USB_DEVICE(USB_VID_AVERMEDIA, USB_PID_AVERMEDIA_A850T,
@@ -1444,7 +1482,7 @@ MODULE_DEVICE_TABLE(usb, af9015_id_table);
 static struct usb_driver af9015_usb_driver = {
 	.name = KBUILD_MODNAME,
 	.id_table = af9015_id_table,
-	.probe = dvb_usbv2_probe,
+	.probe = af9015_probe,
 	.disconnect = dvb_usbv2_disconnect,
 	.suspend = dvb_usbv2_suspend,
 	.resume = dvb_usbv2_resume,

commit aff8c2d475cb660ee246099dd15f269e9ebb7b1d
Author: Antti Palosaari <crope@iki.fi>
Date:   Tue Feb 26 13:25:19 2013 -0300

    [media] af9015: do not use buffers from stack for usb_bulk_msg()
    
    WARNING: at lib/dma-debug.c:947 check_for_stack+0xa7/0xf0()
    ehci-pci 0000:00:04.1: DMA-API: device driver maps memory fromstack
    
    Reported-by: poma <pomidorabelisima@gmail.com>
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/usb/dvb-usb-v2/af9015.c b/drivers/media/usb/dvb-usb-v2/af9015.c
index b86d0f27a398..2fa7c6ee5a70 100644
--- a/drivers/media/usb/dvb-usb-v2/af9015.c
+++ b/drivers/media/usb/dvb-usb-v2/af9015.c
@@ -30,22 +30,22 @@ DVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);
 
 static int af9015_ctrl_msg(struct dvb_usb_device *d, struct req_t *req)
 {
-#define BUF_LEN 63
 #define REQ_HDR_LEN 8 /* send header size */
 #define ACK_HDR_LEN 2 /* rece header size */
 	struct af9015_state *state = d_to_priv(d);
 	int ret, wlen, rlen;
-	u8 buf[BUF_LEN];
 	u8 write = 1;
 
-	buf[0] = req->cmd;
-	buf[1] = state->seq++;
-	buf[2] = req->i2c_addr;
-	buf[3] = req->addr >> 8;
-	buf[4] = req->addr & 0xff;
-	buf[5] = req->mbox;
-	buf[6] = req->addr_len;
-	buf[7] = req->data_len;
+	mutex_lock(&d->usb_mutex);
+
+	state->buf[0] = req->cmd;
+	state->buf[1] = state->seq++;
+	state->buf[2] = req->i2c_addr;
+	state->buf[3] = req->addr >> 8;
+	state->buf[4] = req->addr & 0xff;
+	state->buf[5] = req->mbox;
+	state->buf[6] = req->addr_len;
+	state->buf[7] = req->data_len;
 
 	switch (req->cmd) {
 	case GET_CONFIG:
@@ -55,14 +55,14 @@ static int af9015_ctrl_msg(struct dvb_usb_device *d, struct req_t *req)
 		break;
 	case READ_I2C:
 		write = 0;
-		buf[2] |= 0x01; /* set I2C direction */
+		state->buf[2] |= 0x01; /* set I2C direction */
 	case WRITE_I2C:
-		buf[0] = READ_WRITE_I2C;
+		state->buf[0] = READ_WRITE_I2C;
 		break;
 	case WRITE_MEMORY:
 		if (((req->addr & 0xff00) == 0xff00) ||
 		    ((req->addr & 0xff00) == 0xae00))
-			buf[0] = WRITE_VIRTUAL_MEMORY;
+			state->buf[0] = WRITE_VIRTUAL_MEMORY;
 	case WRITE_VIRTUAL_MEMORY:
 	case COPY_FIRMWARE:
 	case DOWNLOAD_FIRMWARE:
@@ -90,7 +90,7 @@ static int af9015_ctrl_msg(struct dvb_usb_device *d, struct req_t *req)
 	rlen = ACK_HDR_LEN;
 	if (write) {
 		wlen += req->data_len;
-		memcpy(&buf[REQ_HDR_LEN], req->data, req->data_len);
+		memcpy(&state->buf[REQ_HDR_LEN], req->data, req->data_len);
 	} else {
 		rlen += req->data_len;
 	}
@@ -99,22 +99,25 @@ static int af9015_ctrl_msg(struct dvb_usb_device *d, struct req_t *req)
 	if (req->cmd == DOWNLOAD_FIRMWARE || req->cmd == RECONNECT_USB)
 		rlen = 0;
 
-	ret = dvb_usbv2_generic_rw(d, buf, wlen, buf, rlen);
+	ret = dvb_usbv2_generic_rw_locked(d,
+			state->buf, wlen, state->buf, rlen);
 	if (ret)
 		goto error;
 
 	/* check status */
-	if (rlen && buf[1]) {
+	if (rlen && state->buf[1]) {
 		dev_err(&d->udev->dev, "%s: command failed=%d\n",
-				KBUILD_MODNAME, buf[1]);
+				KBUILD_MODNAME, state->buf[1]);
 		ret = -EIO;
 		goto error;
 	}
 
 	/* read request, copy returned data to return buf */
 	if (!write)
-		memcpy(req->data, &buf[ACK_HDR_LEN], req->data_len);
+		memcpy(req->data, &state->buf[ACK_HDR_LEN], req->data_len);
 error:
+	mutex_unlock(&d->usb_mutex);
+
 	return ret;
 }
 

commit 37b44a0f04184998073633887d2f1e724aee130a
Author: Antti Palosaari <crope@iki.fi>
Date:   Fri Jan 4 15:21:26 2013 -0300

    [media] dvb_usb_v2: use IS_ENABLED() macro
    
    replace:
     #if defined(CONFIG_RC_CORE) || defined(CONFIG_RC_CORE_MODULE)
    with:
     #if IS_ENABLED(CONFIG_RC_CORE)
    
    Reported-by: Fabio Estevam <festevam@gmail.com>
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/usb/dvb-usb-v2/af9015.c b/drivers/media/usb/dvb-usb-v2/af9015.c
index 51505d198f44..b86d0f27a398 100644
--- a/drivers/media/usb/dvb-usb-v2/af9015.c
+++ b/drivers/media/usb/dvb-usb-v2/af9015.c
@@ -1156,7 +1156,7 @@ static int af9015_init(struct dvb_usb_device *d)
 	return ret;
 }
 
-#if defined(CONFIG_RC_CORE) || defined(CONFIG_RC_CORE_MODULE)
+#if IS_ENABLED(CONFIG_RC_CORE)
 struct af9015_rc_setup {
 	unsigned int id;
 	char *rc_codes;

commit b6215596b5912c205ed48c11deb1cbdf0aa3ac25
Author: Antti Palosaari <crope@iki.fi>
Date:   Sun Dec 9 20:15:47 2012 -0300

    [media] af9015: make remote controller optional
    
    Do not compile remote controller when RC-core is disabled by Kconfig.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/usb/dvb-usb-v2/af9015.c b/drivers/media/usb/dvb-usb-v2/af9015.c
index 943d93423705..51505d198f44 100644
--- a/drivers/media/usb/dvb-usb-v2/af9015.c
+++ b/drivers/media/usb/dvb-usb-v2/af9015.c
@@ -1156,6 +1156,7 @@ static int af9015_init(struct dvb_usb_device *d)
 	return ret;
 }
 
+#if defined(CONFIG_RC_CORE) || defined(CONFIG_RC_CORE_MODULE)
 struct af9015_rc_setup {
 	unsigned int id;
 	char *rc_codes;
@@ -1312,6 +1313,9 @@ static int af9015_get_rc_config(struct dvb_usb_device *d, struct dvb_usb_rc *rc)
 
 	return 0;
 }
+#else
+	#define af9015_get_rc_config NULL
+#endif
 
 /* interface 0 is used by DVB-T receiver and
    interface 1 is for remote controller (HID) */

commit c003ab1bedf028db15b0185b683d5c387204e8f5
Author: David Hrdeman <david@hardeman.nu>
Date:   Thu Oct 11 19:11:54 2012 -0300

    [media] rc-core: add separate defines for protocol bitmaps and numbers
    
    The RC_TYPE_* defines are currently used both where a single protocol is
    expected and where a bitmap of protocols is expected.
    
    Functions like rc_keydown() and functions which add/remove entries to the
    keytable want a single protocol. Future userspace APIs would also
    benefit from numeric protocols (rather than bitmap ones). Keytables are
    smaller if they can use a small(ish) integer rather than a bitmap.
    
    Other functions or struct members (e.g. allowed_protos,
    enabled_protocols, etc) accept multiple protocols and need a bitmap.
    
    Using different types reduces the risk of programmer error. Using a
    protocol enum whereever possible also makes for a more future-proof
    user-space API as we don't need to worry about a sufficient number of
    bits being available (e.g. in structs used for ioctl() calls).
    
    The use of both a number and a corresponding bit is dalso one in e.g.
    the input subsystem as well (see all the references to set/clear bit when
    changing keytables for example).
    
    This patch separate the different usages in preparation for
    upcoming patches.
    
    Where a single protocol is expected, enum rc_type is used; where one or more
    protocol(s) are expected, something like u64 is used.
    
    The patch has been rewritten so that the format of the sysfs "protocols"
    file is no longer altered (at the loss of some detail). The file itself
    should probably be deprecated in the future though.
    
    Signed-off-by: David Hrdeman <david@hardeman.nu>
    Cc: Andy Walls <awalls@md.metrocast.net>
    Cc: Maxim Levitsky <maximlevitsky@gmail.com>
    Cc: Antti Palosaari <crope@iki.fi>
    Cc: Mike Isely <isely@pobox.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/usb/dvb-usb-v2/af9015.c b/drivers/media/usb/dvb-usb-v2/af9015.c
index 3d7526e28d42..943d93423705 100644
--- a/drivers/media/usb/dvb-usb-v2/af9015.c
+++ b/drivers/media/usb/dvb-usb-v2/af9015.c
@@ -1306,7 +1306,7 @@ static int af9015_get_rc_config(struct dvb_usb_device *d, struct dvb_usb_rc *rc)
 	if (!rc->map_name)
 		rc->map_name = RC_MAP_EMPTY;
 
-	rc->allowed_protos = RC_TYPE_NEC;
+	rc->allowed_protos = RC_BIT_NEC;
 	rc->query = af9015_rc_query;
 	rc->interval = 500;
 

commit c2c1b4156a447f113ef4d167decce29399c2667c
Author: Peter Senna Tschudin <peter.senna@gmail.com>
Date:   Fri Sep 28 05:37:22 2012 -0300

    [media] drivers/media: Remove unnecessary semicolon
    
    A simplified version of the semantic patch that finds this problem is as
    follows: (http://coccinelle.lip6.fr/)
    // <smpl>
    @r1@
    statement S;
    position p,p1;
    @@
    S@p1;@p
    @script:python r2@
    p << r1.p;
    p1 << r1.p1;
    @@
    if p[0].line != p1[0].line_end:
            cocci.include_match(False)
    @@
    position r1.p;
    @@
    -;@p
    // </smpl>
    
    [mchehab@redhat.com: some hunks got bitroted; applied only the
     ones that succeeds]
    Signed-off-by: Peter Senna Tschudin <peter.senna@gmail.com>
    [crope@iki.fi: For my drivers a8293, af9013, af9015, af9035]
    Acked-by: Antti Palosaari <crope@iki.fi>
    Reviewed-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/usb/dvb-usb-v2/af9015.c b/drivers/media/usb/dvb-usb-v2/af9015.c
index 824f1911ee21..3d7526e28d42 100644
--- a/drivers/media/usb/dvb-usb-v2/af9015.c
+++ b/drivers/media/usb/dvb-usb-v2/af9015.c
@@ -500,7 +500,7 @@ static int af9015_read_config(struct dvb_usb_device *d)
 		case 3:
 			state->af9013_config[i].clock = 25000000;
 			break;
-		};
+		}
 		dev_dbg(&d->udev->dev, "%s: [%d] xtal=%d set clock=%d\n",
 				__func__, i, val,
 				state->af9013_config[i].clock);
@@ -568,7 +568,7 @@ static int af9015_read_config(struct dvb_usb_device *d)
 					"supported, please report!\n",
 					KBUILD_MODNAME, val);
 			return -ENODEV;
-		};
+		}
 
 		state->af9013_config[i].tuner = val;
 		dev_dbg(&d->udev->dev, "%s: [%d] tuner id=%d\n",

commit e1e9e510bb8639ace59dcd1f8e6b5754dfbb9b44
Author: Antti Palosaari <crope@iki.fi>
Date:   Wed Sep 12 20:23:52 2012 -0300

    [media] af9015: correct few error codes
    
    Plain '-1' is not very good error code. Use more suitable error
    code definitions.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/usb/dvb-usb-v2/af9015.c b/drivers/media/usb/dvb-usb-v2/af9015.c
index a4be303edb4f..824f1911ee21 100644
--- a/drivers/media/usb/dvb-usb-v2/af9015.c
+++ b/drivers/media/usb/dvb-usb-v2/af9015.c
@@ -71,7 +71,7 @@ static int af9015_ctrl_msg(struct dvb_usb_device *d, struct req_t *req)
 	default:
 		dev_err(&d->udev->dev, "%s: unknown command=%d\n",
 				KBUILD_MODNAME, req->cmd);
-		ret = -1;
+		ret = -EIO;
 		goto error;
 	}
 
@@ -107,7 +107,7 @@ static int af9015_ctrl_msg(struct dvb_usb_device *d, struct req_t *req)
 	if (rlen && buf[1]) {
 		dev_err(&d->udev->dev, "%s: command failed=%d\n",
 				KBUILD_MODNAME, buf[1]);
-		ret = -1;
+		ret = -EIO;
 		goto error;
 	}
 
@@ -791,11 +791,11 @@ static int af9015_copy_firmware(struct dvb_usb_device *d)
 	if (val == 0x04) {
 		dev_err(&d->udev->dev, "%s: firmware did not run\n",
 				KBUILD_MODNAME);
-		ret = -1;
+		ret = -ETIMEDOUT;
 	} else if (val != 0x0c) {
 		dev_err(&d->udev->dev, "%s: firmware boot timeout\n",
 				KBUILD_MODNAME);
-		ret = -1;
+		ret = -ETIMEDOUT;
 	}
 
 error:

commit 2e35c66f138c6a4f50da863a82983a541f1c2a24
Author: Antti Palosaari <crope@iki.fi>
Date:   Wed Sep 12 20:23:51 2012 -0300

    [media] af9015: improve af9015_eeprom_hash()
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/usb/dvb-usb-v2/af9015.c b/drivers/media/usb/dvb-usb-v2/af9015.c
index c429da7da95d..a4be303edb4f 100644
--- a/drivers/media/usb/dvb-usb-v2/af9015.c
+++ b/drivers/media/usb/dvb-usb-v2/af9015.c
@@ -398,43 +398,34 @@ static int af9015_download_firmware(struct dvb_usb_device *d,
 static int af9015_eeprom_hash(struct dvb_usb_device *d)
 {
 	struct af9015_state *state = d_to_priv(d);
-	int ret;
-	static const unsigned int eeprom_size = 256;
-	unsigned int reg;
-	u8 val, *eeprom;
-	struct req_t req = {READ_I2C, AF9015_I2C_EEPROM, 0, 0, 1, 1, &val};
-
-	eeprom = kmalloc(eeprom_size, GFP_KERNEL);
-	if (eeprom == NULL)
-		return -ENOMEM;
-
-	for (reg = 0; reg < eeprom_size; reg++) {
-		req.addr = reg;
+	int ret, i;
+	static const unsigned int AF9015_EEPROM_SIZE = 256;
+	u8 buf[AF9015_EEPROM_SIZE];
+	struct req_t req = {READ_I2C, AF9015_I2C_EEPROM, 0, 0, 1, 1, NULL};
+
+	/* read eeprom */
+	for (i = 0; i < AF9015_EEPROM_SIZE; i++) {
+		req.addr = i;
+		req.data = &buf[i];
 		ret = af9015_ctrl_msg(d, &req);
-		if (ret)
-			goto free;
-
-		eeprom[reg] = val;
+		if (ret < 0)
+			goto err;
 	}
 
-	for (reg = 0; reg < eeprom_size; reg += 16)
-		dev_dbg(&d->udev->dev, "%s: %*ph\n", __func__, 16,
-				eeprom + reg);
-
-	BUG_ON(eeprom_size % 4);
-
-	state->eeprom_sum = 0;
-	for (reg = 0; reg < eeprom_size / sizeof(u32); reg++) {
+	/* calculate checksum */
+	for (i = 0; i < AF9015_EEPROM_SIZE / sizeof(u32); i++) {
 		state->eeprom_sum *= GOLDEN_RATIO_PRIME_32;
-		state->eeprom_sum += le32_to_cpu(((u32 *)eeprom)[reg]);
+		state->eeprom_sum += le32_to_cpu(((u32 *)buf)[i]);
 	}
 
+	for (i = 0; i < AF9015_EEPROM_SIZE; i += 16)
+		dev_dbg(&d->udev->dev, "%s: %*ph\n", __func__, 16, buf + i);
+
 	dev_dbg(&d->udev->dev, "%s: eeprom sum=%.8x\n",
 			__func__, state->eeprom_sum);
-
-	ret = 0;
-free:
-	kfree(eeprom);
+	return 0;
+err:
+	dev_err(&d->udev->dev, "%s: eeprom failed=%d\n", KBUILD_MODNAME, ret);
 	return ret;
 }
 

commit f224749b68034619ff722576f46e4a4932d69d27
Author: Antti Palosaari <crope@iki.fi>
Date:   Wed Sep 12 20:23:50 2012 -0300

    [media] af9015: use Kernel dev_foo() logging
    
    ... and some minor logging changes.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/usb/dvb-usb-v2/af9015.c b/drivers/media/usb/dvb-usb-v2/af9015.c
index d9d3030106d4..c429da7da95d 100644
--- a/drivers/media/usb/dvb-usb-v2/af9015.c
+++ b/drivers/media/usb/dvb-usb-v2/af9015.c
@@ -23,9 +23,6 @@
 
 #include "af9015.h"
 
-static int dvb_usb_af9015_debug;
-module_param_named(debug, dvb_usb_af9015_debug, int, 0644);
-MODULE_PARM_DESC(debug, "set debugging level" DVB_USB_DEBUG_STATUS);
 static int dvb_usb_af9015_remote;
 module_param_named(remote, dvb_usb_af9015_remote, int, 0644);
 MODULE_PARM_DESC(remote, "select remote");
@@ -72,15 +69,17 @@ static int af9015_ctrl_msg(struct dvb_usb_device *d, struct req_t *req)
 	case BOOT:
 		break;
 	default:
-		err("unknown command:%d", req->cmd);
+		dev_err(&d->udev->dev, "%s: unknown command=%d\n",
+				KBUILD_MODNAME, req->cmd);
 		ret = -1;
 		goto error;
 	}
 
 	/* buffer overflow check */
 	if ((write && (req->data_len > BUF_LEN - REQ_HDR_LEN)) ||
-		(!write && (req->data_len > BUF_LEN - ACK_HDR_LEN))) {
-		err("too much data; cmd:%d len:%d", req->cmd, req->data_len);
+			(!write && (req->data_len > BUF_LEN - ACK_HDR_LEN))) {
+		dev_err(&d->udev->dev, "%s: too much data; cmd=%d len=%d\n",
+				KBUILD_MODNAME, req->cmd, req->data_len);
 		ret = -EINVAL;
 		goto error;
 	}
@@ -106,7 +105,8 @@ static int af9015_ctrl_msg(struct dvb_usb_device *d, struct req_t *req)
 
 	/* check status */
 	if (rlen && buf[1]) {
-		err("command failed:%d", buf[1]);
+		dev_err(&d->udev->dev, "%s: command failed=%d\n",
+				KBUILD_MODNAME, buf[1]);
 		ret = -1;
 		goto error;
 	}
@@ -334,7 +334,8 @@ static int af9015_identify_state(struct dvb_usb_device *d, const char **name)
 	if (ret)
 		return ret;
 
-	deb_info("%s: reply:%02x\n", __func__, reply);
+	dev_dbg(&d->udev->dev, "%s: reply=%02x\n", __func__, reply);
+
 	if (reply == 0x02)
 		ret = WARM;
 	else
@@ -350,8 +351,7 @@ static int af9015_download_firmware(struct dvb_usb_device *d,
 	int i, len, remaining, ret;
 	struct req_t req = {DOWNLOAD_FIRMWARE, 0, 0, 0, 0, 0, NULL};
 	u16 checksum = 0;
-
-	deb_info("%s:\n", __func__);
+	dev_dbg(&d->udev->dev, "%s:\n", __func__);
 
 	/* calc checksum */
 	for (i = 0; i < fw->size; i++)
@@ -373,7 +373,9 @@ static int af9015_download_firmware(struct dvb_usb_device *d,
 
 		ret = af9015_ctrl_msg(d, &req);
 		if (ret) {
-			err("firmware download failed:%d", ret);
+			dev_err(&d->udev->dev,
+					"%s: firmware download failed=%d\n",
+					KBUILD_MODNAME, ret);
 			goto error;
 		}
 	}
@@ -383,7 +385,8 @@ static int af9015_download_firmware(struct dvb_usb_device *d,
 	req.data_len = 0;
 	ret = af9015_ctrl_msg(d, &req);
 	if (ret) {
-		err("firmware boot failed:%d", ret);
+		dev_err(&d->udev->dev, "%s: firmware boot failed=%d\n",
+				KBUILD_MODNAME, ret);
 		goto error;
 	}
 
@@ -414,9 +417,9 @@ static int af9015_eeprom_hash(struct dvb_usb_device *d)
 		eeprom[reg] = val;
 	}
 
-	if (dvb_usb_af9015_debug & 0x01)
-		print_hex_dump_bytes("", DUMP_PREFIX_OFFSET, eeprom,
-				eeprom_size);
+	for (reg = 0; reg < eeprom_size; reg += 16)
+		dev_dbg(&d->udev->dev, "%s: %*ph\n", __func__, 16,
+				eeprom + reg);
 
 	BUG_ON(eeprom_size % 4);
 
@@ -426,7 +429,8 @@ static int af9015_eeprom_hash(struct dvb_usb_device *d)
 		state->eeprom_sum += le32_to_cpu(((u32 *)eeprom)[reg]);
 	}
 
-	deb_info("%s: eeprom sum=%.8x\n", __func__, state->eeprom_sum);
+	dev_dbg(&d->udev->dev, "%s: eeprom sum=%.8x\n",
+			__func__, state->eeprom_sum);
 
 	ret = 0;
 free:
@@ -441,7 +445,7 @@ static int af9015_read_config(struct dvb_usb_device *d)
 	u8 val, i, offset = 0;
 	struct req_t req = {READ_I2C, AF9015_I2C_EEPROM, 0, 0, 1, 1, &val};
 
-	deb_info("%s:\n", __func__);
+	dev_dbg(&d->udev->dev, "%s:\n", __func__);
 
 	/* IR remote controller */
 	req.addr = AF9015_EEPROM_IR_MODE;
@@ -458,8 +462,8 @@ static int af9015_read_config(struct dvb_usb_device *d)
 	if (ret)
 		goto error;
 
-	deb_info("%s: IR mode=%d\n", __func__, val);
 	state->ir_mode = val;
+	dev_dbg(&d->udev->dev, "%s: IR mode=%d\n", __func__, val);
 
 	/* TS mode - one or two receivers */
 	req.addr = AF9015_EEPROM_TS_MODE;
@@ -468,7 +472,7 @@ static int af9015_read_config(struct dvb_usb_device *d)
 		goto error;
 
 	state->dual_mode = val;
-	deb_info("%s: TS mode=%d\n", __func__, state->dual_mode);
+	dev_dbg(&d->udev->dev, "%s: TS mode=%d\n", __func__, state->dual_mode);
 
 	/* disable 2nd adapter because we don't have PID-filters */
 	if (d->udev->speed == USB_SPEED_FULL)
@@ -506,8 +510,9 @@ static int af9015_read_config(struct dvb_usb_device *d)
 			state->af9013_config[i].clock = 25000000;
 			break;
 		};
-		deb_info("%s: [%d] xtal=%d set clock=%d\n", __func__, i,
-				val, state->af9013_config[i].clock);
+		dev_dbg(&d->udev->dev, "%s: [%d] xtal=%d set clock=%d\n",
+				__func__, i, val,
+				state->af9013_config[i].clock);
 
 		/* IF frequency */
 		req.addr = AF9015_EEPROM_IF1H + offset;
@@ -524,8 +529,8 @@ static int af9015_read_config(struct dvb_usb_device *d)
 
 		state->af9013_config[i].if_frequency += val;
 		state->af9013_config[i].if_frequency *= 1000;
-		deb_info("%s: [%d] IF frequency=%d\n", __func__, i,
-				state->af9013_config[i].if_frequency);
+		dev_dbg(&d->udev->dev, "%s: [%d] IF frequency=%d\n", __func__,
+				i, state->af9013_config[i].if_frequency);
 
 		/* MT2060 IF1 */
 		req.addr = AF9015_EEPROM_MT2060_IF1H  + offset;
@@ -538,7 +543,7 @@ static int af9015_read_config(struct dvb_usb_device *d)
 		if (ret)
 			goto error;
 		state->mt2060_if1[i] += val;
-		deb_info("%s: [%d] MT2060 IF1=%d\n", __func__, i,
+		dev_dbg(&d->udev->dev, "%s: [%d] MT2060 IF1=%d\n", __func__, i,
 				state->mt2060_if1[i]);
 
 		/* tuner */
@@ -568,17 +573,21 @@ static int af9015_read_config(struct dvb_usb_device *d)
 			state->af9013_config[i].spec_inv = 1;
 			break;
 		default:
-			warn("tuner id=%d not supported, please report!", val);
+			dev_err(&d->udev->dev, "%s: tuner id=%d not " \
+					"supported, please report!\n",
+					KBUILD_MODNAME, val);
 			return -ENODEV;
 		};
 
 		state->af9013_config[i].tuner = val;
-		deb_info("%s: [%d] tuner id=%d\n", __func__, i, val);
+		dev_dbg(&d->udev->dev, "%s: [%d] tuner id=%d\n",
+				__func__, i, val);
 	}
 
 error:
 	if (ret)
-		err("eeprom read failed=%d", ret);
+		dev_err(&d->udev->dev, "%s: eeprom read failed=%d\n",
+				KBUILD_MODNAME, ret);
 
 	/* AverMedia AVerTV Volar Black HD (A850) device have bad EEPROM
 	   content :-( Override some wrong values here. Ditto for the
@@ -588,7 +597,9 @@ static int af9015_read_config(struct dvb_usb_device *d)
 			USB_PID_AVERMEDIA_A850) ||
 		(le16_to_cpu(d->udev->descriptor.idProduct) ==
 			USB_PID_AVERMEDIA_A850T))) {
-		deb_info("%s: AverMedia A850: overriding config\n", __func__);
+		dev_dbg(&d->udev->dev,
+				"%s: AverMedia A850: overriding config\n",
+				__func__);
 		/* disable dual mode */
 		state->dual_mode = 0;
 
@@ -602,9 +613,10 @@ static int af9015_read_config(struct dvb_usb_device *d)
 static int af9015_get_stream_config(struct dvb_frontend *fe, u8 *ts_type,
 		struct usb_data_stream_properties *stream)
 {
-	deb_info("%s: adap=%d\n", __func__, fe_to_adap(fe)->id);
+	struct dvb_usb_device *d = fe_to_d(fe);
+	dev_dbg(&d->udev->dev, "%s: adap=%d\n", __func__, fe_to_adap(fe)->id);
 
-	if (fe_to_d(fe)->udev->speed == USB_SPEED_FULL)
+	if (d->udev->speed == USB_SPEED_FULL)
 		stream->u.bulk.buffersize = TS_USB11_FRAME_SIZE;
 
 	return 0;
@@ -721,7 +733,7 @@ static int af9015_copy_firmware(struct dvb_usb_device *d)
 	u8 val, i;
 	struct req_t req = {COPY_FIRMWARE, 0, 0x5100, 0, 0, sizeof(fw_params),
 		fw_params };
-	deb_info("%s:\n", __func__);
+	dev_dbg(&d->udev->dev, "%s:\n", __func__);
 
 	fw_params[0] = state->firmware_size >> 8;
 	fw_params[1] = state->firmware_size & 0xff;
@@ -736,7 +748,8 @@ static int af9015_copy_firmware(struct dvb_usb_device *d)
 	if (ret)
 		goto error;
 	else
-		deb_info("%s: firmware status:%02x\n", __func__, val);
+		dev_dbg(&d->udev->dev, "%s: firmware status=%02x\n",
+				__func__, val);
 
 	if (val == 0x0c) /* fw is running, no need for download */
 		goto exit;
@@ -751,8 +764,10 @@ static int af9015_copy_firmware(struct dvb_usb_device *d)
 	/* copy firmware */
 	ret = af9015_ctrl_msg(d, &req);
 	if (ret)
-		err("firmware copy cmd failed:%d", ret);
-	deb_info("%s: firmware copy done\n", __func__);
+		dev_err(&d->udev->dev, "%s: firmware copy cmd failed=%d\n",
+				KBUILD_MODNAME, ret);
+
+	dev_dbg(&d->udev->dev, "%s: firmware copy done\n", __func__);
 
 	/* set I2C master clock back to normal */
 	ret = af9015_write_reg(d, 0xd416, 0x14); /* 0x14 * 400ns */
@@ -762,7 +777,8 @@ static int af9015_copy_firmware(struct dvb_usb_device *d)
 	/* request boot firmware */
 	ret = af9015_write_reg_i2c(d, state->af9013_config[1].i2c_addr,
 			0xe205, 1);
-	deb_info("%s: firmware boot cmd status:%d\n", __func__, ret);
+	dev_dbg(&d->udev->dev, "%s: firmware boot cmd status=%d\n",
+			__func__, ret);
 	if (ret)
 		goto error;
 
@@ -772,8 +788,8 @@ static int af9015_copy_firmware(struct dvb_usb_device *d)
 		/* check firmware status */
 		ret = af9015_read_reg_i2c(d, state->af9013_config[1].i2c_addr,
 				0x98be, &val);
-		deb_info("%s: firmware status cmd status:%d fw status:%02x\n",
-			__func__, ret, val);
+		dev_dbg(&d->udev->dev, "%s: firmware status cmd status=%d " \
+				"firmware status=%02x\n", __func__, ret, val);
 		if (ret)
 			goto error;
 
@@ -782,10 +798,12 @@ static int af9015_copy_firmware(struct dvb_usb_device *d)
 	}
 
 	if (val == 0x04) {
-		err("firmware did not run");
+		dev_err(&d->udev->dev, "%s: firmware did not run\n",
+				KBUILD_MODNAME);
 		ret = -1;
 	} else if (val != 0x0c) {
-		err("firmware boot timeout");
+		dev_err(&d->udev->dev, "%s: firmware boot timeout\n",
+				KBUILD_MODNAME);
 		ret = -1;
 	}
 
@@ -814,8 +832,10 @@ static int af9015_af9013_frontend_attach(struct dvb_usb_adapter *adap)
 		if (state->dual_mode) {
 			ret = af9015_copy_firmware(adap_to_d(adap));
 			if (ret) {
-				err("firmware copy to 2nd frontend " \
-					"failed, will disable it");
+				dev_err(&adap_to_d(adap)->udev->dev,
+						"%s: firmware copy to 2nd " \
+						"frontend failed, will " \
+						"disable it\n", KBUILD_MODNAME);
 				state->dual_mode = 0;
 				return -ENODEV;
 			}
@@ -921,9 +941,10 @@ static struct mxl5007t_config af9015_mxl5007t_config = {
 
 static int af9015_tuner_attach(struct dvb_usb_adapter *adap)
 {
-	struct af9015_state *state = adap_to_priv(adap);
+	struct dvb_usb_device *d = adap_to_d(adap);
+	struct af9015_state *state = d_to_priv(d);
 	int ret;
-	deb_info("%s:\n", __func__);
+	dev_dbg(&d->udev->dev, "%s:\n", __func__);
 
 	switch (state->af9013_config[adap->id].tuner) {
 	case AF9013_TUNER_MT2060:
@@ -977,9 +998,10 @@ static int af9015_tuner_attach(struct dvb_usb_adapter *adap)
 		break;
 	case AF9013_TUNER_UNKNOWN:
 	default:
+		dev_err(&d->udev->dev, "%s: unknown tuner id=%d\n",
+				KBUILD_MODNAME,
+				state->af9013_config[adap->id].tuner);
 		ret = -ENODEV;
-		err("Unknown tuner id:%d",
-			state->af9013_config[adap->id].tuner);
 	}
 
 	if (adap->fe[0]->ops.tuner_ops.init) {
@@ -999,13 +1021,14 @@ static int af9015_tuner_attach(struct dvb_usb_adapter *adap)
 
 static int af9015_pid_filter_ctrl(struct dvb_usb_adapter *adap, int onoff)
 {
+	struct dvb_usb_device *d = adap_to_d(adap);
 	int ret;
-	deb_info("%s: onoff:%d\n", __func__, onoff);
+	dev_dbg(&d->udev->dev, "%s: onoff=%d\n", __func__, onoff);
 
 	if (onoff)
-		ret = af9015_set_reg_bit(adap_to_d(adap), 0xd503, 0);
+		ret = af9015_set_reg_bit(d, 0xd503, 0);
 	else
-		ret = af9015_clear_reg_bit(adap_to_d(adap), 0xd503, 0);
+		ret = af9015_clear_reg_bit(d, 0xd503, 0);
 
 	return ret;
 }
@@ -1013,22 +1036,22 @@ static int af9015_pid_filter_ctrl(struct dvb_usb_adapter *adap, int onoff)
 static int af9015_pid_filter(struct dvb_usb_adapter *adap, int index, u16 pid,
 	int onoff)
 {
+	struct dvb_usb_device *d = adap_to_d(adap);
 	int ret;
 	u8 idx;
+	dev_dbg(&d->udev->dev, "%s: index=%d pid=%04x onoff=%d\n",
+			__func__, index, pid, onoff);
 
-	deb_info("%s: set pid filter, index %d, pid %x, onoff %d\n",
-		__func__, index, pid, onoff);
-
-	ret = af9015_write_reg(adap_to_d(adap), 0xd505, (pid & 0xff));
+	ret = af9015_write_reg(d, 0xd505, (pid & 0xff));
 	if (ret)
 		goto error;
 
-	ret = af9015_write_reg(adap_to_d(adap), 0xd506, (pid >> 8));
+	ret = af9015_write_reg(d, 0xd506, (pid >> 8));
 	if (ret)
 		goto error;
 
 	idx = ((index & 0x1f) | (1 << 5));
-	ret = af9015_write_reg(adap_to_d(adap), 0xd504, idx);
+	ret = af9015_write_reg(d, 0xd504, idx);
 
 error:
 	return ret;
@@ -1040,7 +1063,7 @@ static int af9015_init_endpoint(struct dvb_usb_device *d)
 	int ret;
 	u16 frame_size;
 	u8  packet_size;
-	deb_info("%s: USB speed:%d\n", __func__, d->udev->speed);
+	dev_dbg(&d->udev->dev, "%s: USB speed=%d\n", __func__, d->udev->speed);
 
 	if (d->udev->speed == USB_SPEED_FULL) {
 		frame_size = TS_USB11_FRAME_SIZE/4;
@@ -1115,7 +1138,9 @@ static int af9015_init_endpoint(struct dvb_usb_device *d)
 
 error:
 	if (ret)
-		err("endpoint init failed:%d", ret);
+		dev_err(&d->udev->dev, "%s: endpoint init failed=%d\n",
+				KBUILD_MODNAME, ret);
+
 	return ret;
 }
 
@@ -1123,7 +1148,7 @@ static int af9015_init(struct dvb_usb_device *d)
 {
 	struct af9015_state *state = d_to_priv(d);
 	int ret;
-	deb_info("%s:\n", __func__);
+	dev_dbg(&d->udev->dev, "%s:\n", __func__);
 
 	mutex_init(&state->fe_mutex);
 
@@ -1177,21 +1202,21 @@ static int af9015_rc_query(struct dvb_usb_device *d)
 	int ret;
 	u8 buf[17];
 
-	deb_info("%s:\n", __func__);
-
 	/* read registers needed to detect remote controller code */
 	ret = af9015_read_regs(d, 0x98d9, buf, sizeof(buf));
 	if (ret)
 		goto error;
 
 	/* If any of these are non-zero, assume invalid data */
-	if (buf[1] || buf[2] || buf[3])
+	if (buf[1] || buf[2] || buf[3]) {
+		dev_dbg(&d->udev->dev, "%s: invalid data\n", __func__);
 		return ret;
+	}
 
 	/* Check for repeat of previous code */
 	if ((state->rc_repeat != buf[6] || buf[0]) &&
 			!memcmp(&buf[12], state->rc_last, 4)) {
-		deb_rc("%s: key repeated\n", __func__);
+		dev_dbg(&d->udev->dev, "%s: key repeated\n", __func__);
 		rc_keydown(d->rc_dev, state->rc_keycode, 0);
 		state->rc_repeat = buf[6];
 		return ret;
@@ -1199,7 +1224,8 @@ static int af9015_rc_query(struct dvb_usb_device *d)
 
 	/* Only process key if canary killed */
 	if (buf[16] != 0xff && buf[0] != 0x01) {
-		deb_rc("%s: key pressed %*ph\n", __func__, 4, buf + 12);
+		dev_dbg(&d->udev->dev, "%s: key pressed %*ph\n",
+				__func__, 4, buf + 12);
 
 		/* Reset the canary */
 		ret = af9015_write_reg(d, 0x98e9, 0xff);
@@ -1224,7 +1250,7 @@ static int af9015_rc_query(struct dvb_usb_device *d)
 		}
 		rc_keydown(d->rc_dev, state->rc_keycode, 0);
 	} else {
-		deb_rc("%s: no key press\n", __func__);
+		dev_dbg(&d->udev->dev, "%s: no key press\n", __func__);
 		/* Invalidate last keypress */
 		/* Not really needed, but helps with debug */
 		state->rc_last[2] = state->rc_last[3];
@@ -1235,7 +1261,8 @@ static int af9015_rc_query(struct dvb_usb_device *d)
 
 error:
 	if (ret) {
-		err("%s: failed:%d", __func__, ret);
+		dev_warn(&d->udev->dev, "%s: rc query failed=%d\n",
+				KBUILD_MODNAME, ret);
 
 		/* allow random errors as dvb-usb will stop polling on error */
 		if (!state->rc_failed)

commit bab9b4fe089668ecab98547bec7e3d77e01ad206
Author: Antti Palosaari <crope@iki.fi>
Date:   Wed Sep 12 11:37:25 2012 -0300

    [media] af9015: declare MODULE_FIRMWARE
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/usb/dvb-usb-v2/af9015.c b/drivers/media/usb/dvb-usb-v2/af9015.c
index 9afceedc9d1f..d9d3030106d4 100644
--- a/drivers/media/usb/dvb-usb-v2/af9015.c
+++ b/drivers/media/usb/dvb-usb-v2/af9015.c
@@ -1307,7 +1307,7 @@ static struct dvb_usb_device_properties af9015_props = {
 	.generic_bulk_ctrl_endpoint_response = 0x81,
 
 	.identify_state = af9015_identify_state,
-	.firmware = "dvb-usb-af9015.fw",
+	.firmware = AF9015_FIRMWARE,
 	.download_firmware = af9015_download_firmware,
 
 	.i2c_algo = &af9015_i2c_algo,
@@ -1433,3 +1433,4 @@ module_usb_driver(af9015_usb_driver);
 MODULE_AUTHOR("Antti Palosaari <crope@iki.fi>");
 MODULE_DESCRIPTION("Afatech AF9015 driver");
 MODULE_LICENSE("GPL");
+MODULE_FIRMWARE(AF9015_FIRMWARE);

commit 04966aa8dc7d6201755c81cd07841ca30aa7e379
Author: Antti Palosaari <crope@iki.fi>
Date:   Tue Aug 14 22:21:08 2012 -0300

    [media] dvb_usb_v2: af9015, af9035, anysee use .reset_resume
    
    All these seems to survive .reset_resume.
    
    Signed-off-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/usb/dvb-usb-v2/af9015.c b/drivers/media/usb/dvb-usb-v2/af9015.c
index e77429b37a7d..9afceedc9d1f 100644
--- a/drivers/media/usb/dvb-usb-v2/af9015.c
+++ b/drivers/media/usb/dvb-usb-v2/af9015.c
@@ -1423,6 +1423,7 @@ static struct usb_driver af9015_usb_driver = {
 	.disconnect = dvb_usbv2_disconnect,
 	.suspend = dvb_usbv2_suspend,
 	.resume = dvb_usbv2_resume,
+	.reset_resume = dvb_usbv2_reset_resume,
 	.no_dynamic_id = 1,
 	.soft_unbind = 1,
 };

commit 786baecfe78f8e25547c628b48a60fc8e5636056
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Thu Jun 14 16:35:56 2012 -0300

    [media] dvb-usb: move it to drivers/media/usb/dvb-usb
    
    As media/dvb will be removed, move it to a proper place.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/usb/dvb-usb-v2/af9015.c b/drivers/media/usb/dvb-usb-v2/af9015.c
new file mode 100644
index 000000000000..e77429b37a7d
--- /dev/null
+++ b/drivers/media/usb/dvb-usb-v2/af9015.c
@@ -0,0 +1,1434 @@
+/*
+ * DVB USB Linux driver for Afatech AF9015 DVB-T USB2.0 receiver
+ *
+ * Copyright (C) 2007 Antti Palosaari <crope@iki.fi>
+ *
+ * Thanks to Afatech who kindly provided information.
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License
+ *    along with this program; if not, write to the Free Software
+ *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#include "af9015.h"
+
+static int dvb_usb_af9015_debug;
+module_param_named(debug, dvb_usb_af9015_debug, int, 0644);
+MODULE_PARM_DESC(debug, "set debugging level" DVB_USB_DEBUG_STATUS);
+static int dvb_usb_af9015_remote;
+module_param_named(remote, dvb_usb_af9015_remote, int, 0644);
+MODULE_PARM_DESC(remote, "select remote");
+DVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);
+
+static int af9015_ctrl_msg(struct dvb_usb_device *d, struct req_t *req)
+{
+#define BUF_LEN 63
+#define REQ_HDR_LEN 8 /* send header size */
+#define ACK_HDR_LEN 2 /* rece header size */
+	struct af9015_state *state = d_to_priv(d);
+	int ret, wlen, rlen;
+	u8 buf[BUF_LEN];
+	u8 write = 1;
+
+	buf[0] = req->cmd;
+	buf[1] = state->seq++;
+	buf[2] = req->i2c_addr;
+	buf[3] = req->addr >> 8;
+	buf[4] = req->addr & 0xff;
+	buf[5] = req->mbox;
+	buf[6] = req->addr_len;
+	buf[7] = req->data_len;
+
+	switch (req->cmd) {
+	case GET_CONFIG:
+	case READ_MEMORY:
+	case RECONNECT_USB:
+		write = 0;
+		break;
+	case READ_I2C:
+		write = 0;
+		buf[2] |= 0x01; /* set I2C direction */
+	case WRITE_I2C:
+		buf[0] = READ_WRITE_I2C;
+		break;
+	case WRITE_MEMORY:
+		if (((req->addr & 0xff00) == 0xff00) ||
+		    ((req->addr & 0xff00) == 0xae00))
+			buf[0] = WRITE_VIRTUAL_MEMORY;
+	case WRITE_VIRTUAL_MEMORY:
+	case COPY_FIRMWARE:
+	case DOWNLOAD_FIRMWARE:
+	case BOOT:
+		break;
+	default:
+		err("unknown command:%d", req->cmd);
+		ret = -1;
+		goto error;
+	}
+
+	/* buffer overflow check */
+	if ((write && (req->data_len > BUF_LEN - REQ_HDR_LEN)) ||
+		(!write && (req->data_len > BUF_LEN - ACK_HDR_LEN))) {
+		err("too much data; cmd:%d len:%d", req->cmd, req->data_len);
+		ret = -EINVAL;
+		goto error;
+	}
+
+	/* write receives seq + status = 2 bytes
+	   read receives seq + status + data = 2 + N bytes */
+	wlen = REQ_HDR_LEN;
+	rlen = ACK_HDR_LEN;
+	if (write) {
+		wlen += req->data_len;
+		memcpy(&buf[REQ_HDR_LEN], req->data, req->data_len);
+	} else {
+		rlen += req->data_len;
+	}
+
+	/* no ack for these packets */
+	if (req->cmd == DOWNLOAD_FIRMWARE || req->cmd == RECONNECT_USB)
+		rlen = 0;
+
+	ret = dvb_usbv2_generic_rw(d, buf, wlen, buf, rlen);
+	if (ret)
+		goto error;
+
+	/* check status */
+	if (rlen && buf[1]) {
+		err("command failed:%d", buf[1]);
+		ret = -1;
+		goto error;
+	}
+
+	/* read request, copy returned data to return buf */
+	if (!write)
+		memcpy(req->data, &buf[ACK_HDR_LEN], req->data_len);
+error:
+	return ret;
+}
+
+static int af9015_write_regs(struct dvb_usb_device *d, u16 addr, u8 *val,
+	u8 len)
+{
+	struct req_t req = {WRITE_MEMORY, AF9015_I2C_DEMOD, addr, 0, 0, len,
+		val};
+	return af9015_ctrl_msg(d, &req);
+}
+
+static int af9015_read_regs(struct dvb_usb_device *d, u16 addr, u8 *val, u8 len)
+{
+	struct req_t req = {READ_MEMORY, AF9015_I2C_DEMOD, addr, 0, 0, len,
+		val};
+	return af9015_ctrl_msg(d, &req);
+}
+
+static int af9015_write_reg(struct dvb_usb_device *d, u16 addr, u8 val)
+{
+	return af9015_write_regs(d, addr, &val, 1);
+}
+
+static int af9015_read_reg(struct dvb_usb_device *d, u16 addr, u8 *val)
+{
+	return af9015_read_regs(d, addr, val, 1);
+}
+
+static int af9015_write_reg_i2c(struct dvb_usb_device *d, u8 addr, u16 reg,
+	u8 val)
+{
+	struct af9015_state *state = d_to_priv(d);
+	struct req_t req = {WRITE_I2C, addr, reg, 1, 1, 1, &val};
+
+	if (addr == state->af9013_config[0].i2c_addr ||
+	    addr == state->af9013_config[1].i2c_addr)
+		req.addr_len = 3;
+
+	return af9015_ctrl_msg(d, &req);
+}
+
+static int af9015_read_reg_i2c(struct dvb_usb_device *d, u8 addr, u16 reg,
+	u8 *val)
+{
+	struct af9015_state *state = d_to_priv(d);
+	struct req_t req = {READ_I2C, addr, reg, 0, 1, 1, val};
+
+	if (addr == state->af9013_config[0].i2c_addr ||
+	    addr == state->af9013_config[1].i2c_addr)
+		req.addr_len = 3;
+
+	return af9015_ctrl_msg(d, &req);
+}
+
+static int af9015_do_reg_bit(struct dvb_usb_device *d, u16 addr, u8 bit, u8 op)
+{
+	int ret;
+	u8 val, mask = 0x01;
+
+	ret = af9015_read_reg(d, addr, &val);
+	if (ret)
+		return ret;
+
+	mask <<= bit;
+	if (op) {
+		/* set bit */
+		val |= mask;
+	} else {
+		/* clear bit */
+		mask ^= 0xff;
+		val &= mask;
+	}
+
+	return af9015_write_reg(d, addr, val);
+}
+
+static int af9015_set_reg_bit(struct dvb_usb_device *d, u16 addr, u8 bit)
+{
+	return af9015_do_reg_bit(d, addr, bit, 1);
+}
+
+static int af9015_clear_reg_bit(struct dvb_usb_device *d, u16 addr, u8 bit)
+{
+	return af9015_do_reg_bit(d, addr, bit, 0);
+}
+
+static int af9015_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msg[],
+	int num)
+{
+	struct dvb_usb_device *d = i2c_get_adapdata(adap);
+	struct af9015_state *state = d_to_priv(d);
+	int ret = 0, i = 0;
+	u16 addr;
+	u8 uninitialized_var(mbox), addr_len;
+	struct req_t req;
+
+/*
+The bus lock is needed because there is two tuners both using same I2C-address.
+Due to that the only way to select correct tuner is use demodulator I2C-gate.
+
+................................................
+. AF9015 includes integrated AF9013 demodulator.
+. ____________                   ____________  .                ____________
+.|     uC     |                 |   demod    | .               |    tuner   |
+.|------------|                 |------------| .               |------------|
+.|   AF9015   |                 |  AF9013/5  | .               |   MXL5003  |
+.|            |--+----I2C-------|-----/ -----|-.-----I2C-------|            |
+.|            |  |              | addr 0x38  | .               |  addr 0xc6 |
+.|____________|  |              |____________| .               |____________|
+.................|..............................
+		 |               ____________                   ____________
+		 |              |   demod    |                 |    tuner   |
+		 |              |------------|                 |------------|
+		 |              |   AF9013   |                 |   MXL5003  |
+		 +----I2C-------|-----/ -----|-------I2C-------|            |
+				| addr 0x3a  |                 |  addr 0xc6 |
+				|____________|                 |____________|
+*/
+	if (mutex_lock_interruptible(&d->i2c_mutex) < 0)
+		return -EAGAIN;
+
+	while (i < num) {
+		if (msg[i].addr == state->af9013_config[0].i2c_addr ||
+		    msg[i].addr == state->af9013_config[1].i2c_addr) {
+			addr = msg[i].buf[0] << 8;
+			addr += msg[i].buf[1];
+			mbox = msg[i].buf[2];
+			addr_len = 3;
+		} else {
+			addr = msg[i].buf[0];
+			addr_len = 1;
+			/* mbox is don't care in that case */
+		}
+
+		if (num > i + 1 && (msg[i+1].flags & I2C_M_RD)) {
+			if (msg[i].len > 3 || msg[i+1].len > 61) {
+				ret = -EOPNOTSUPP;
+				goto error;
+			}
+			if (msg[i].addr == state->af9013_config[0].i2c_addr)
+				req.cmd = READ_MEMORY;
+			else
+				req.cmd = READ_I2C;
+			req.i2c_addr = msg[i].addr;
+			req.addr = addr;
+			req.mbox = mbox;
+			req.addr_len = addr_len;
+			req.data_len = msg[i+1].len;
+			req.data = &msg[i+1].buf[0];
+			ret = af9015_ctrl_msg(d, &req);
+			i += 2;
+		} else if (msg[i].flags & I2C_M_RD) {
+			if (msg[i].len > 61) {
+				ret = -EOPNOTSUPP;
+				goto error;
+			}
+			if (msg[i].addr == state->af9013_config[0].i2c_addr) {
+				ret = -EINVAL;
+				goto error;
+			}
+			req.cmd = READ_I2C;
+			req.i2c_addr = msg[i].addr;
+			req.addr = addr;
+			req.mbox = mbox;
+			req.addr_len = addr_len;
+			req.data_len = msg[i].len;
+			req.data = &msg[i].buf[0];
+			ret = af9015_ctrl_msg(d, &req);
+			i += 1;
+		} else {
+			if (msg[i].len > 21) {
+				ret = -EOPNOTSUPP;
+				goto error;
+			}
+			if (msg[i].addr == state->af9013_config[0].i2c_addr)
+				req.cmd = WRITE_MEMORY;
+			else
+				req.cmd = WRITE_I2C;
+			req.i2c_addr = msg[i].addr;
+			req.addr = addr;
+			req.mbox = mbox;
+			req.addr_len = addr_len;
+			req.data_len = msg[i].len-addr_len;
+			req.data = &msg[i].buf[addr_len];
+			ret = af9015_ctrl_msg(d, &req);
+			i += 1;
+		}
+		if (ret)
+			goto error;
+
+	}
+	ret = i;
+
+error:
+	mutex_unlock(&d->i2c_mutex);
+
+	return ret;
+}
+
+static u32 af9015_i2c_func(struct i2c_adapter *adapter)
+{
+	return I2C_FUNC_I2C;
+}
+
+static struct i2c_algorithm af9015_i2c_algo = {
+	.master_xfer = af9015_i2c_xfer,
+	.functionality = af9015_i2c_func,
+};
+
+static int af9015_identify_state(struct dvb_usb_device *d, const char **name)
+{
+	int ret;
+	u8 reply;
+	struct req_t req = {GET_CONFIG, 0, 0, 0, 0, 1, &reply};
+
+	ret = af9015_ctrl_msg(d, &req);
+	if (ret)
+		return ret;
+
+	deb_info("%s: reply:%02x\n", __func__, reply);
+	if (reply == 0x02)
+		ret = WARM;
+	else
+		ret = COLD;
+
+	return ret;
+}
+
+static int af9015_download_firmware(struct dvb_usb_device *d,
+	const struct firmware *fw)
+{
+	struct af9015_state *state = d_to_priv(d);
+	int i, len, remaining, ret;
+	struct req_t req = {DOWNLOAD_FIRMWARE, 0, 0, 0, 0, 0, NULL};
+	u16 checksum = 0;
+
+	deb_info("%s:\n", __func__);
+
+	/* calc checksum */
+	for (i = 0; i < fw->size; i++)
+		checksum += fw->data[i];
+
+	state->firmware_size = fw->size;
+	state->firmware_checksum = checksum;
+
+	#define FW_ADDR 0x5100 /* firmware start address */
+	#define LEN_MAX 55 /* max packet size */
+	for (remaining = fw->size; remaining > 0; remaining -= LEN_MAX) {
+		len = remaining;
+		if (len > LEN_MAX)
+			len = LEN_MAX;
+
+		req.data_len = len;
+		req.data = (u8 *) &fw->data[fw->size - remaining];
+		req.addr = FW_ADDR + fw->size - remaining;
+
+		ret = af9015_ctrl_msg(d, &req);
+		if (ret) {
+			err("firmware download failed:%d", ret);
+			goto error;
+		}
+	}
+
+	/* firmware loaded, request boot */
+	req.cmd = BOOT;
+	req.data_len = 0;
+	ret = af9015_ctrl_msg(d, &req);
+	if (ret) {
+		err("firmware boot failed:%d", ret);
+		goto error;
+	}
+
+error:
+	return ret;
+}
+
+/* hash (and dump) eeprom */
+static int af9015_eeprom_hash(struct dvb_usb_device *d)
+{
+	struct af9015_state *state = d_to_priv(d);
+	int ret;
+	static const unsigned int eeprom_size = 256;
+	unsigned int reg;
+	u8 val, *eeprom;
+	struct req_t req = {READ_I2C, AF9015_I2C_EEPROM, 0, 0, 1, 1, &val};
+
+	eeprom = kmalloc(eeprom_size, GFP_KERNEL);
+	if (eeprom == NULL)
+		return -ENOMEM;
+
+	for (reg = 0; reg < eeprom_size; reg++) {
+		req.addr = reg;
+		ret = af9015_ctrl_msg(d, &req);
+		if (ret)
+			goto free;
+
+		eeprom[reg] = val;
+	}
+
+	if (dvb_usb_af9015_debug & 0x01)
+		print_hex_dump_bytes("", DUMP_PREFIX_OFFSET, eeprom,
+				eeprom_size);
+
+	BUG_ON(eeprom_size % 4);
+
+	state->eeprom_sum = 0;
+	for (reg = 0; reg < eeprom_size / sizeof(u32); reg++) {
+		state->eeprom_sum *= GOLDEN_RATIO_PRIME_32;
+		state->eeprom_sum += le32_to_cpu(((u32 *)eeprom)[reg]);
+	}
+
+	deb_info("%s: eeprom sum=%.8x\n", __func__, state->eeprom_sum);
+
+	ret = 0;
+free:
+	kfree(eeprom);
+	return ret;
+}
+
+static int af9015_read_config(struct dvb_usb_device *d)
+{
+	struct af9015_state *state = d_to_priv(d);
+	int ret;
+	u8 val, i, offset = 0;
+	struct req_t req = {READ_I2C, AF9015_I2C_EEPROM, 0, 0, 1, 1, &val};
+
+	deb_info("%s:\n", __func__);
+
+	/* IR remote controller */
+	req.addr = AF9015_EEPROM_IR_MODE;
+	/* first message will timeout often due to possible hw bug */
+	for (i = 0; i < 4; i++) {
+		ret = af9015_ctrl_msg(d, &req);
+		if (!ret)
+			break;
+	}
+	if (ret)
+		goto error;
+
+	ret = af9015_eeprom_hash(d);
+	if (ret)
+		goto error;
+
+	deb_info("%s: IR mode=%d\n", __func__, val);
+	state->ir_mode = val;
+
+	/* TS mode - one or two receivers */
+	req.addr = AF9015_EEPROM_TS_MODE;
+	ret = af9015_ctrl_msg(d, &req);
+	if (ret)
+		goto error;
+
+	state->dual_mode = val;
+	deb_info("%s: TS mode=%d\n", __func__, state->dual_mode);
+
+	/* disable 2nd adapter because we don't have PID-filters */
+	if (d->udev->speed == USB_SPEED_FULL)
+		state->dual_mode = 0;
+
+	if (state->dual_mode) {
+		/* read 2nd demodulator I2C address */
+		req.addr = AF9015_EEPROM_DEMOD2_I2C;
+		ret = af9015_ctrl_msg(d, &req);
+		if (ret)
+			goto error;
+
+		state->af9013_config[1].i2c_addr = val;
+	}
+
+	for (i = 0; i < state->dual_mode + 1; i++) {
+		if (i == 1)
+			offset = AF9015_EEPROM_OFFSET;
+		/* xtal */
+		req.addr = AF9015_EEPROM_XTAL_TYPE1 + offset;
+		ret = af9015_ctrl_msg(d, &req);
+		if (ret)
+			goto error;
+		switch (val) {
+		case 0:
+			state->af9013_config[i].clock = 28800000;
+			break;
+		case 1:
+			state->af9013_config[i].clock = 20480000;
+			break;
+		case 2:
+			state->af9013_config[i].clock = 28000000;
+			break;
+		case 3:
+			state->af9013_config[i].clock = 25000000;
+			break;
+		};
+		deb_info("%s: [%d] xtal=%d set clock=%d\n", __func__, i,
+				val, state->af9013_config[i].clock);
+
+		/* IF frequency */
+		req.addr = AF9015_EEPROM_IF1H + offset;
+		ret = af9015_ctrl_msg(d, &req);
+		if (ret)
+			goto error;
+
+		state->af9013_config[i].if_frequency = val << 8;
+
+		req.addr = AF9015_EEPROM_IF1L + offset;
+		ret = af9015_ctrl_msg(d, &req);
+		if (ret)
+			goto error;
+
+		state->af9013_config[i].if_frequency += val;
+		state->af9013_config[i].if_frequency *= 1000;
+		deb_info("%s: [%d] IF frequency=%d\n", __func__, i,
+				state->af9013_config[i].if_frequency);
+
+		/* MT2060 IF1 */
+		req.addr = AF9015_EEPROM_MT2060_IF1H  + offset;
+		ret = af9015_ctrl_msg(d, &req);
+		if (ret)
+			goto error;
+		state->mt2060_if1[i] = val << 8;
+		req.addr = AF9015_EEPROM_MT2060_IF1L + offset;
+		ret = af9015_ctrl_msg(d, &req);
+		if (ret)
+			goto error;
+		state->mt2060_if1[i] += val;
+		deb_info("%s: [%d] MT2060 IF1=%d\n", __func__, i,
+				state->mt2060_if1[i]);
+
+		/* tuner */
+		req.addr =  AF9015_EEPROM_TUNER_ID1 + offset;
+		ret = af9015_ctrl_msg(d, &req);
+		if (ret)
+			goto error;
+		switch (val) {
+		case AF9013_TUNER_ENV77H11D5:
+		case AF9013_TUNER_MT2060:
+		case AF9013_TUNER_QT1010:
+		case AF9013_TUNER_UNKNOWN:
+		case AF9013_TUNER_MT2060_2:
+		case AF9013_TUNER_TDA18271:
+		case AF9013_TUNER_QT1010A:
+		case AF9013_TUNER_TDA18218:
+			state->af9013_config[i].spec_inv = 1;
+			break;
+		case AF9013_TUNER_MXL5003D:
+		case AF9013_TUNER_MXL5005D:
+		case AF9013_TUNER_MXL5005R:
+		case AF9013_TUNER_MXL5007T:
+			state->af9013_config[i].spec_inv = 0;
+			break;
+		case AF9013_TUNER_MC44S803:
+			state->af9013_config[i].gpio[1] = AF9013_GPIO_LO;
+			state->af9013_config[i].spec_inv = 1;
+			break;
+		default:
+			warn("tuner id=%d not supported, please report!", val);
+			return -ENODEV;
+		};
+
+		state->af9013_config[i].tuner = val;
+		deb_info("%s: [%d] tuner id=%d\n", __func__, i, val);
+	}
+
+error:
+	if (ret)
+		err("eeprom read failed=%d", ret);
+
+	/* AverMedia AVerTV Volar Black HD (A850) device have bad EEPROM
+	   content :-( Override some wrong values here. Ditto for the
+	   AVerTV Red HD+ (A850T) device. */
+	if (le16_to_cpu(d->udev->descriptor.idVendor) == USB_VID_AVERMEDIA &&
+		((le16_to_cpu(d->udev->descriptor.idProduct) ==
+			USB_PID_AVERMEDIA_A850) ||
+		(le16_to_cpu(d->udev->descriptor.idProduct) ==
+			USB_PID_AVERMEDIA_A850T))) {
+		deb_info("%s: AverMedia A850: overriding config\n", __func__);
+		/* disable dual mode */
+		state->dual_mode = 0;
+
+		/* set correct IF */
+		state->af9013_config[0].if_frequency = 4570000;
+	}
+
+	return ret;
+}
+
+static int af9015_get_stream_config(struct dvb_frontend *fe, u8 *ts_type,
+		struct usb_data_stream_properties *stream)
+{
+	deb_info("%s: adap=%d\n", __func__, fe_to_adap(fe)->id);
+
+	if (fe_to_d(fe)->udev->speed == USB_SPEED_FULL)
+		stream->u.bulk.buffersize = TS_USB11_FRAME_SIZE;
+
+	return 0;
+}
+
+static int af9015_get_adapter_count(struct dvb_usb_device *d)
+{
+	struct af9015_state *state = d_to_priv(d);
+	return state->dual_mode + 1;
+}
+
+/* override demod callbacks for resource locking */
+static int af9015_af9013_set_frontend(struct dvb_frontend *fe)
+{
+	int ret;
+	struct af9015_state *state = fe_to_priv(fe);
+
+	if (mutex_lock_interruptible(&state->fe_mutex))
+		return -EAGAIN;
+
+	ret = state->set_frontend[fe_to_adap(fe)->id](fe);
+
+	mutex_unlock(&state->fe_mutex);
+
+	return ret;
+}
+
+/* override demod callbacks for resource locking */
+static int af9015_af9013_read_status(struct dvb_frontend *fe,
+	fe_status_t *status)
+{
+	int ret;
+	struct af9015_state *state = fe_to_priv(fe);
+
+	if (mutex_lock_interruptible(&state->fe_mutex))
+		return -EAGAIN;
+
+	ret = state->read_status[fe_to_adap(fe)->id](fe, status);
+
+	mutex_unlock(&state->fe_mutex);
+
+	return ret;
+}
+
+/* override demod callbacks for resource locking */
+static int af9015_af9013_init(struct dvb_frontend *fe)
+{
+	int ret;
+	struct af9015_state *state = fe_to_priv(fe);
+
+	if (mutex_lock_interruptible(&state->fe_mutex))
+		return -EAGAIN;
+
+	ret = state->init[fe_to_adap(fe)->id](fe);
+
+	mutex_unlock(&state->fe_mutex);
+
+	return ret;
+}
+
+/* override demod callbacks for resource locking */
+static int af9015_af9013_sleep(struct dvb_frontend *fe)
+{
+	int ret;
+	struct af9015_state *state = fe_to_priv(fe);
+
+	if (mutex_lock_interruptible(&state->fe_mutex))
+		return -EAGAIN;
+
+	ret = state->sleep[fe_to_adap(fe)->id](fe);
+
+	mutex_unlock(&state->fe_mutex);
+
+	return ret;
+}
+
+/* override tuner callbacks for resource locking */
+static int af9015_tuner_init(struct dvb_frontend *fe)
+{
+	int ret;
+	struct af9015_state *state = fe_to_priv(fe);
+
+	if (mutex_lock_interruptible(&state->fe_mutex))
+		return -EAGAIN;
+
+	ret = state->tuner_init[fe_to_adap(fe)->id](fe);
+
+	mutex_unlock(&state->fe_mutex);
+
+	return ret;
+}
+
+/* override tuner callbacks for resource locking */
+static int af9015_tuner_sleep(struct dvb_frontend *fe)
+{
+	int ret;
+	struct af9015_state *state = fe_to_priv(fe);
+
+	if (mutex_lock_interruptible(&state->fe_mutex))
+		return -EAGAIN;
+
+	ret = state->tuner_sleep[fe_to_adap(fe)->id](fe);
+
+	mutex_unlock(&state->fe_mutex);
+
+	return ret;
+}
+
+static int af9015_copy_firmware(struct dvb_usb_device *d)
+{
+	struct af9015_state *state = d_to_priv(d);
+	int ret;
+	u8 fw_params[4];
+	u8 val, i;
+	struct req_t req = {COPY_FIRMWARE, 0, 0x5100, 0, 0, sizeof(fw_params),
+		fw_params };
+	deb_info("%s:\n", __func__);
+
+	fw_params[0] = state->firmware_size >> 8;
+	fw_params[1] = state->firmware_size & 0xff;
+	fw_params[2] = state->firmware_checksum >> 8;
+	fw_params[3] = state->firmware_checksum & 0xff;
+
+	/* wait 2nd demodulator ready */
+	msleep(100);
+
+	ret = af9015_read_reg_i2c(d, state->af9013_config[1].i2c_addr,
+			0x98be, &val);
+	if (ret)
+		goto error;
+	else
+		deb_info("%s: firmware status:%02x\n", __func__, val);
+
+	if (val == 0x0c) /* fw is running, no need for download */
+		goto exit;
+
+	/* set I2C master clock to fast (to speed up firmware copy) */
+	ret = af9015_write_reg(d, 0xd416, 0x04); /* 0x04 * 400ns */
+	if (ret)
+		goto error;
+
+	msleep(50);
+
+	/* copy firmware */
+	ret = af9015_ctrl_msg(d, &req);
+	if (ret)
+		err("firmware copy cmd failed:%d", ret);
+	deb_info("%s: firmware copy done\n", __func__);
+
+	/* set I2C master clock back to normal */
+	ret = af9015_write_reg(d, 0xd416, 0x14); /* 0x14 * 400ns */
+	if (ret)
+		goto error;
+
+	/* request boot firmware */
+	ret = af9015_write_reg_i2c(d, state->af9013_config[1].i2c_addr,
+			0xe205, 1);
+	deb_info("%s: firmware boot cmd status:%d\n", __func__, ret);
+	if (ret)
+		goto error;
+
+	for (i = 0; i < 15; i++) {
+		msleep(100);
+
+		/* check firmware status */
+		ret = af9015_read_reg_i2c(d, state->af9013_config[1].i2c_addr,
+				0x98be, &val);
+		deb_info("%s: firmware status cmd status:%d fw status:%02x\n",
+			__func__, ret, val);
+		if (ret)
+			goto error;
+
+		if (val == 0x0c || val == 0x04) /* success or fail */
+			break;
+	}
+
+	if (val == 0x04) {
+		err("firmware did not run");
+		ret = -1;
+	} else if (val != 0x0c) {
+		err("firmware boot timeout");
+		ret = -1;
+	}
+
+error:
+exit:
+	return ret;
+}
+
+static int af9015_af9013_frontend_attach(struct dvb_usb_adapter *adap)
+{
+	int ret;
+	struct af9015_state *state = adap_to_priv(adap);
+
+	if (adap->id == 0) {
+		state->af9013_config[0].ts_mode = AF9013_TS_USB;
+		memcpy(state->af9013_config[0].api_version, "\x0\x1\x9\x0", 4);
+		state->af9013_config[0].gpio[0] = AF9013_GPIO_HI;
+		state->af9013_config[0].gpio[3] = AF9013_GPIO_TUNER_ON;
+	} else if (adap->id == 1) {
+		state->af9013_config[1].ts_mode = AF9013_TS_SERIAL;
+		memcpy(state->af9013_config[1].api_version, "\x0\x1\x9\x0", 4);
+		state->af9013_config[1].gpio[0] = AF9013_GPIO_TUNER_ON;
+		state->af9013_config[1].gpio[1] = AF9013_GPIO_LO;
+
+		/* copy firmware to 2nd demodulator */
+		if (state->dual_mode) {
+			ret = af9015_copy_firmware(adap_to_d(adap));
+			if (ret) {
+				err("firmware copy to 2nd frontend " \
+					"failed, will disable it");
+				state->dual_mode = 0;
+				return -ENODEV;
+			}
+		} else {
+			return -ENODEV;
+		}
+	}
+
+	/* attach demodulator */
+	adap->fe[0] = dvb_attach(af9013_attach,
+		&state->af9013_config[adap->id], &adap_to_d(adap)->i2c_adap);
+
+	/*
+	 * AF9015 firmware does not like if it gets interrupted by I2C adapter
+	 * request on some critical phases. During normal operation I2C adapter
+	 * is used only 2nd demodulator and tuner on dual tuner devices.
+	 * Override demodulator callbacks and use mutex for limit access to
+	 * those "critical" paths to keep AF9015 happy.
+	 */
+	if (adap->fe[0]) {
+		state->set_frontend[adap->id] =
+			adap->fe[0]->ops.set_frontend;
+		adap->fe[0]->ops.set_frontend =
+			af9015_af9013_set_frontend;
+
+		state->read_status[adap->id] =
+			adap->fe[0]->ops.read_status;
+		adap->fe[0]->ops.read_status =
+			af9015_af9013_read_status;
+
+		state->init[adap->id] = adap->fe[0]->ops.init;
+		adap->fe[0]->ops.init = af9015_af9013_init;
+
+		state->sleep[adap->id] = adap->fe[0]->ops.sleep;
+		adap->fe[0]->ops.sleep = af9015_af9013_sleep;
+	}
+
+	return adap->fe[0] == NULL ? -ENODEV : 0;
+}
+
+static struct mt2060_config af9015_mt2060_config = {
+	.i2c_address = 0xc0,
+	.clock_out = 0,
+};
+
+static struct qt1010_config af9015_qt1010_config = {
+	.i2c_address = 0xc4,
+};
+
+static struct tda18271_config af9015_tda18271_config = {
+	.gate = TDA18271_GATE_DIGITAL,
+	.small_i2c = TDA18271_16_BYTE_CHUNK_INIT,
+};
+
+static struct mxl5005s_config af9015_mxl5003_config = {
+	.i2c_address     = 0xc6,
+	.if_freq         = IF_FREQ_4570000HZ,
+	.xtal_freq       = CRYSTAL_FREQ_16000000HZ,
+	.agc_mode        = MXL_SINGLE_AGC,
+	.tracking_filter = MXL_TF_DEFAULT,
+	.rssi_enable     = MXL_RSSI_ENABLE,
+	.cap_select      = MXL_CAP_SEL_ENABLE,
+	.div_out         = MXL_DIV_OUT_4,
+	.clock_out       = MXL_CLOCK_OUT_DISABLE,
+	.output_load     = MXL5005S_IF_OUTPUT_LOAD_200_OHM,
+	.top		 = MXL5005S_TOP_25P2,
+	.mod_mode        = MXL_DIGITAL_MODE,
+	.if_mode         = MXL_ZERO_IF,
+	.AgcMasterByte   = 0x00,
+};
+
+static struct mxl5005s_config af9015_mxl5005_config = {
+	.i2c_address     = 0xc6,
+	.if_freq         = IF_FREQ_4570000HZ,
+	.xtal_freq       = CRYSTAL_FREQ_16000000HZ,
+	.agc_mode        = MXL_SINGLE_AGC,
+	.tracking_filter = MXL_TF_OFF,
+	.rssi_enable     = MXL_RSSI_ENABLE,
+	.cap_select      = MXL_CAP_SEL_ENABLE,
+	.div_out         = MXL_DIV_OUT_4,
+	.clock_out       = MXL_CLOCK_OUT_DISABLE,
+	.output_load     = MXL5005S_IF_OUTPUT_LOAD_200_OHM,
+	.top		 = MXL5005S_TOP_25P2,
+	.mod_mode        = MXL_DIGITAL_MODE,
+	.if_mode         = MXL_ZERO_IF,
+	.AgcMasterByte   = 0x00,
+};
+
+static struct mc44s803_config af9015_mc44s803_config = {
+	.i2c_address = 0xc0,
+	.dig_out = 1,
+};
+
+static struct tda18218_config af9015_tda18218_config = {
+	.i2c_address = 0xc0,
+	.i2c_wr_max = 21, /* max wr bytes AF9015 I2C adap can handle at once */
+};
+
+static struct mxl5007t_config af9015_mxl5007t_config = {
+	.xtal_freq_hz = MxL_XTAL_24_MHZ,
+	.if_freq_hz = MxL_IF_4_57_MHZ,
+};
+
+static int af9015_tuner_attach(struct dvb_usb_adapter *adap)
+{
+	struct af9015_state *state = adap_to_priv(adap);
+	int ret;
+	deb_info("%s:\n", __func__);
+
+	switch (state->af9013_config[adap->id].tuner) {
+	case AF9013_TUNER_MT2060:
+	case AF9013_TUNER_MT2060_2:
+		ret = dvb_attach(mt2060_attach, adap->fe[0],
+			&adap_to_d(adap)->i2c_adap, &af9015_mt2060_config,
+			state->mt2060_if1[adap->id])
+			== NULL ? -ENODEV : 0;
+		break;
+	case AF9013_TUNER_QT1010:
+	case AF9013_TUNER_QT1010A:
+		ret = dvb_attach(qt1010_attach, adap->fe[0],
+			&adap_to_d(adap)->i2c_adap,
+			&af9015_qt1010_config) == NULL ? -ENODEV : 0;
+		break;
+	case AF9013_TUNER_TDA18271:
+		ret = dvb_attach(tda18271_attach, adap->fe[0], 0xc0,
+			&adap_to_d(adap)->i2c_adap,
+			&af9015_tda18271_config) == NULL ? -ENODEV : 0;
+		break;
+	case AF9013_TUNER_TDA18218:
+		ret = dvb_attach(tda18218_attach, adap->fe[0],
+			&adap_to_d(adap)->i2c_adap,
+			&af9015_tda18218_config) == NULL ? -ENODEV : 0;
+		break;
+	case AF9013_TUNER_MXL5003D:
+		ret = dvb_attach(mxl5005s_attach, adap->fe[0],
+			&adap_to_d(adap)->i2c_adap,
+			&af9015_mxl5003_config) == NULL ? -ENODEV : 0;
+		break;
+	case AF9013_TUNER_MXL5005D:
+	case AF9013_TUNER_MXL5005R:
+		ret = dvb_attach(mxl5005s_attach, adap->fe[0],
+			&adap_to_d(adap)->i2c_adap,
+			&af9015_mxl5005_config) == NULL ? -ENODEV : 0;
+		break;
+	case AF9013_TUNER_ENV77H11D5:
+		ret = dvb_attach(dvb_pll_attach, adap->fe[0], 0xc0,
+			&adap_to_d(adap)->i2c_adap,
+			DVB_PLL_TDA665X) == NULL ? -ENODEV : 0;
+		break;
+	case AF9013_TUNER_MC44S803:
+		ret = dvb_attach(mc44s803_attach, adap->fe[0],
+			&adap_to_d(adap)->i2c_adap,
+			&af9015_mc44s803_config) == NULL ? -ENODEV : 0;
+		break;
+	case AF9013_TUNER_MXL5007T:
+		ret = dvb_attach(mxl5007t_attach, adap->fe[0],
+			&adap_to_d(adap)->i2c_adap,
+			0xc0, &af9015_mxl5007t_config) == NULL ? -ENODEV : 0;
+		break;
+	case AF9013_TUNER_UNKNOWN:
+	default:
+		ret = -ENODEV;
+		err("Unknown tuner id:%d",
+			state->af9013_config[adap->id].tuner);
+	}
+
+	if (adap->fe[0]->ops.tuner_ops.init) {
+		state->tuner_init[adap->id] =
+			adap->fe[0]->ops.tuner_ops.init;
+		adap->fe[0]->ops.tuner_ops.init = af9015_tuner_init;
+	}
+
+	if (adap->fe[0]->ops.tuner_ops.sleep) {
+		state->tuner_sleep[adap->id] =
+			adap->fe[0]->ops.tuner_ops.sleep;
+		adap->fe[0]->ops.tuner_ops.sleep = af9015_tuner_sleep;
+	}
+
+	return ret;
+}
+
+static int af9015_pid_filter_ctrl(struct dvb_usb_adapter *adap, int onoff)
+{
+	int ret;
+	deb_info("%s: onoff:%d\n", __func__, onoff);
+
+	if (onoff)
+		ret = af9015_set_reg_bit(adap_to_d(adap), 0xd503, 0);
+	else
+		ret = af9015_clear_reg_bit(adap_to_d(adap), 0xd503, 0);
+
+	return ret;
+}
+
+static int af9015_pid_filter(struct dvb_usb_adapter *adap, int index, u16 pid,
+	int onoff)
+{
+	int ret;
+	u8 idx;
+
+	deb_info("%s: set pid filter, index %d, pid %x, onoff %d\n",
+		__func__, index, pid, onoff);
+
+	ret = af9015_write_reg(adap_to_d(adap), 0xd505, (pid & 0xff));
+	if (ret)
+		goto error;
+
+	ret = af9015_write_reg(adap_to_d(adap), 0xd506, (pid >> 8));
+	if (ret)
+		goto error;
+
+	idx = ((index & 0x1f) | (1 << 5));
+	ret = af9015_write_reg(adap_to_d(adap), 0xd504, idx);
+
+error:
+	return ret;
+}
+
+static int af9015_init_endpoint(struct dvb_usb_device *d)
+{
+	struct af9015_state *state = d_to_priv(d);
+	int ret;
+	u16 frame_size;
+	u8  packet_size;
+	deb_info("%s: USB speed:%d\n", __func__, d->udev->speed);
+
+	if (d->udev->speed == USB_SPEED_FULL) {
+		frame_size = TS_USB11_FRAME_SIZE/4;
+		packet_size = TS_USB11_MAX_PACKET_SIZE/4;
+	} else {
+		frame_size = TS_USB20_FRAME_SIZE/4;
+		packet_size = TS_USB20_MAX_PACKET_SIZE/4;
+	}
+
+	ret = af9015_set_reg_bit(d, 0xd507, 2); /* assert EP4 reset */
+	if (ret)
+		goto error;
+	ret = af9015_set_reg_bit(d, 0xd50b, 1); /* assert EP5 reset */
+	if (ret)
+		goto error;
+	ret = af9015_clear_reg_bit(d, 0xdd11, 5); /* disable EP4 */
+	if (ret)
+		goto error;
+	ret = af9015_clear_reg_bit(d, 0xdd11, 6); /* disable EP5 */
+	if (ret)
+		goto error;
+	ret = af9015_set_reg_bit(d, 0xdd11, 5); /* enable EP4 */
+	if (ret)
+		goto error;
+	if (state->dual_mode) {
+		ret = af9015_set_reg_bit(d, 0xdd11, 6); /* enable EP5 */
+		if (ret)
+			goto error;
+	}
+	ret = af9015_clear_reg_bit(d, 0xdd13, 5); /* disable EP4 NAK */
+	if (ret)
+		goto error;
+	if (state->dual_mode) {
+		ret = af9015_clear_reg_bit(d, 0xdd13, 6); /* disable EP5 NAK */
+		if (ret)
+			goto error;
+	}
+	/* EP4 xfer length */
+	ret = af9015_write_reg(d, 0xdd88, frame_size & 0xff);
+	if (ret)
+		goto error;
+	ret = af9015_write_reg(d, 0xdd89, frame_size >> 8);
+	if (ret)
+		goto error;
+	/* EP5 xfer length */
+	ret = af9015_write_reg(d, 0xdd8a, frame_size & 0xff);
+	if (ret)
+		goto error;
+	ret = af9015_write_reg(d, 0xdd8b, frame_size >> 8);
+	if (ret)
+		goto error;
+	ret = af9015_write_reg(d, 0xdd0c, packet_size); /* EP4 packet size */
+	if (ret)
+		goto error;
+	ret = af9015_write_reg(d, 0xdd0d, packet_size); /* EP5 packet size */
+	if (ret)
+		goto error;
+	ret = af9015_clear_reg_bit(d, 0xd507, 2); /* negate EP4 reset */
+	if (ret)
+		goto error;
+	if (state->dual_mode) {
+		ret = af9015_clear_reg_bit(d, 0xd50b, 1); /* negate EP5 reset */
+		if (ret)
+			goto error;
+	}
+
+	/* enable / disable mp2if2 */
+	if (state->dual_mode)
+		ret = af9015_set_reg_bit(d, 0xd50b, 0);
+	else
+		ret = af9015_clear_reg_bit(d, 0xd50b, 0);
+
+error:
+	if (ret)
+		err("endpoint init failed:%d", ret);
+	return ret;
+}
+
+static int af9015_init(struct dvb_usb_device *d)
+{
+	struct af9015_state *state = d_to_priv(d);
+	int ret;
+	deb_info("%s:\n", __func__);
+
+	mutex_init(&state->fe_mutex);
+
+	/* init RC canary */
+	ret = af9015_write_reg(d, 0x98e9, 0xff);
+	if (ret)
+		goto error;
+
+	ret = af9015_init_endpoint(d);
+	if (ret)
+		goto error;
+
+error:
+	return ret;
+}
+
+struct af9015_rc_setup {
+	unsigned int id;
+	char *rc_codes;
+};
+
+static char *af9015_rc_setup_match(unsigned int id,
+	const struct af9015_rc_setup *table)
+{
+	for (; table->rc_codes; table++)
+		if (table->id == id)
+			return table->rc_codes;
+	return NULL;
+}
+
+static const struct af9015_rc_setup af9015_rc_setup_modparam[] = {
+	{ AF9015_REMOTE_A_LINK_DTU_M, RC_MAP_ALINK_DTU_M },
+	{ AF9015_REMOTE_MSI_DIGIVOX_MINI_II_V3, RC_MAP_MSI_DIGIVOX_II },
+	{ AF9015_REMOTE_MYGICTV_U718, RC_MAP_TOTAL_MEDIA_IN_HAND },
+	{ AF9015_REMOTE_DIGITTRADE_DVB_T, RC_MAP_DIGITTRADE },
+	{ AF9015_REMOTE_AVERMEDIA_KS, RC_MAP_AVERMEDIA_RM_KS },
+	{ }
+};
+
+static const struct af9015_rc_setup af9015_rc_setup_hashes[] = {
+	{ 0xb8feb708, RC_MAP_MSI_DIGIVOX_II },
+	{ 0xa3703d00, RC_MAP_ALINK_DTU_M },
+	{ 0x9b7dc64e, RC_MAP_TOTAL_MEDIA_IN_HAND }, /* MYGICTV U718 */
+	{ 0x5d49e3db, RC_MAP_DIGITTRADE }, /* LC-Power LC-USB-DVBT */
+	{ }
+};
+
+static int af9015_rc_query(struct dvb_usb_device *d)
+{
+	struct af9015_state *state = d_to_priv(d);
+	int ret;
+	u8 buf[17];
+
+	deb_info("%s:\n", __func__);
+
+	/* read registers needed to detect remote controller code */
+	ret = af9015_read_regs(d, 0x98d9, buf, sizeof(buf));
+	if (ret)
+		goto error;
+
+	/* If any of these are non-zero, assume invalid data */
+	if (buf[1] || buf[2] || buf[3])
+		return ret;
+
+	/* Check for repeat of previous code */
+	if ((state->rc_repeat != buf[6] || buf[0]) &&
+			!memcmp(&buf[12], state->rc_last, 4)) {
+		deb_rc("%s: key repeated\n", __func__);
+		rc_keydown(d->rc_dev, state->rc_keycode, 0);
+		state->rc_repeat = buf[6];
+		return ret;
+	}
+
+	/* Only process key if canary killed */
+	if (buf[16] != 0xff && buf[0] != 0x01) {
+		deb_rc("%s: key pressed %*ph\n", __func__, 4, buf + 12);
+
+		/* Reset the canary */
+		ret = af9015_write_reg(d, 0x98e9, 0xff);
+		if (ret)
+			goto error;
+
+		/* Remember this key */
+		memcpy(state->rc_last, &buf[12], 4);
+		if (buf[14] == (u8) ~buf[15]) {
+			if (buf[12] == (u8) ~buf[13]) {
+				/* NEC */
+				state->rc_keycode = buf[12] << 8 | buf[14];
+			} else {
+				/* NEC extended*/
+				state->rc_keycode = buf[12] << 16 |
+					buf[13] << 8 | buf[14];
+			}
+		} else {
+			/* 32 bit NEC */
+			state->rc_keycode = buf[12] << 24 | buf[13] << 16 |
+					buf[14] << 8 | buf[15];
+		}
+		rc_keydown(d->rc_dev, state->rc_keycode, 0);
+	} else {
+		deb_rc("%s: no key press\n", __func__);
+		/* Invalidate last keypress */
+		/* Not really needed, but helps with debug */
+		state->rc_last[2] = state->rc_last[3];
+	}
+
+	state->rc_repeat = buf[6];
+	state->rc_failed = false;
+
+error:
+	if (ret) {
+		err("%s: failed:%d", __func__, ret);
+
+		/* allow random errors as dvb-usb will stop polling on error */
+		if (!state->rc_failed)
+			ret = 0;
+
+		state->rc_failed = true;
+	}
+
+	return ret;
+}
+
+static int af9015_get_rc_config(struct dvb_usb_device *d, struct dvb_usb_rc *rc)
+{
+	struct af9015_state *state = d_to_priv(d);
+	u16 vid = le16_to_cpu(d->udev->descriptor.idVendor);
+
+	if (state->ir_mode == AF9015_IR_MODE_DISABLED)
+		return 0;
+
+	/* try to load remote based module param */
+	if (!rc->map_name)
+		rc->map_name = af9015_rc_setup_match(dvb_usb_af9015_remote,
+				af9015_rc_setup_modparam);
+
+	/* try to load remote based eeprom hash */
+	if (!rc->map_name)
+		rc->map_name = af9015_rc_setup_match(state->eeprom_sum,
+				af9015_rc_setup_hashes);
+
+	/* try to load remote based USB iManufacturer string */
+	if (!rc->map_name && vid == USB_VID_AFATECH) {
+		/* Check USB manufacturer and product strings and try
+		   to determine correct remote in case of chip vendor
+		   reference IDs are used.
+		   DO NOT ADD ANYTHING NEW HERE. Use hashes instead. */
+		char manufacturer[10];
+		memset(manufacturer, 0, sizeof(manufacturer));
+		usb_string(d->udev, d->udev->descriptor.iManufacturer,
+			manufacturer, sizeof(manufacturer));
+		if (!strcmp("MSI", manufacturer)) {
+			/* iManufacturer 1 MSI
+			   iProduct      2 MSI K-VOX */
+			rc->map_name = af9015_rc_setup_match(
+					AF9015_REMOTE_MSI_DIGIVOX_MINI_II_V3,
+					af9015_rc_setup_modparam);
+		}
+	}
+
+	/* load empty to enable rc */
+	if (!rc->map_name)
+		rc->map_name = RC_MAP_EMPTY;
+
+	rc->allowed_protos = RC_TYPE_NEC;
+	rc->query = af9015_rc_query;
+	rc->interval = 500;
+
+	return 0;
+}
+
+/* interface 0 is used by DVB-T receiver and
+   interface 1 is for remote controller (HID) */
+static struct dvb_usb_device_properties af9015_props = {
+	.driver_name = KBUILD_MODNAME,
+	.owner = THIS_MODULE,
+	.adapter_nr = adapter_nr,
+	.size_of_priv = sizeof(struct af9015_state),
+
+	.generic_bulk_ctrl_endpoint = 0x02,
+	.generic_bulk_ctrl_endpoint_response = 0x81,
+
+	.identify_state = af9015_identify_state,
+	.firmware = "dvb-usb-af9015.fw",
+	.download_firmware = af9015_download_firmware,
+
+	.i2c_algo = &af9015_i2c_algo,
+	.read_config = af9015_read_config,
+	.frontend_attach = af9015_af9013_frontend_attach,
+	.tuner_attach = af9015_tuner_attach,
+	.init = af9015_init,
+	.get_rc_config = af9015_get_rc_config,
+	.get_stream_config = af9015_get_stream_config,
+
+	.get_adapter_count = af9015_get_adapter_count,
+	.adapter = {
+		{
+			.caps = DVB_USB_ADAP_HAS_PID_FILTER |
+				DVB_USB_ADAP_PID_FILTER_CAN_BE_TURNED_OFF,
+			.pid_filter_count = 32,
+			.pid_filter = af9015_pid_filter,
+			.pid_filter_ctrl = af9015_pid_filter_ctrl,
+
+			.stream = DVB_USB_STREAM_BULK(0x84, 8, TS_USB20_FRAME_SIZE),
+		}, {
+			.stream = DVB_USB_STREAM_BULK(0x85, 8, TS_USB20_FRAME_SIZE),
+		},
+	},
+};
+
+static const struct usb_device_id af9015_id_table[] = {
+	{ DVB_USB_DEVICE(USB_VID_AFATECH, USB_PID_AFATECH_AF9015_9015,
+		&af9015_props, "Afatech AF9015 reference design", NULL) },
+	{ DVB_USB_DEVICE(USB_VID_AFATECH, USB_PID_AFATECH_AF9015_9016,
+		&af9015_props, "Afatech AF9015 reference design", NULL) },
+	{ DVB_USB_DEVICE(USB_VID_LEADTEK, USB_PID_WINFAST_DTV_DONGLE_GOLD,
+		&af9015_props, "Leadtek WinFast DTV Dongle Gold", RC_MAP_LEADTEK_Y04G0051) },
+	{ DVB_USB_DEVICE(USB_VID_PINNACLE, USB_PID_PINNACLE_PCTV71E,
+		&af9015_props, "Pinnacle PCTV 71e", NULL) },
+	{ DVB_USB_DEVICE(USB_VID_KWORLD_2, USB_PID_KWORLD_399U,
+		&af9015_props, "KWorld PlusTV Dual DVB-T Stick (DVB-T 399U)", NULL) },
+	{ DVB_USB_DEVICE(USB_VID_VISIONPLUS, USB_PID_TINYTWIN,
+		&af9015_props, "DigitalNow TinyTwin", RC_MAP_AZUREWAVE_AD_TU700) },
+	{ DVB_USB_DEVICE(USB_VID_VISIONPLUS, USB_PID_AZUREWAVE_AD_TU700,
+		&af9015_props, "TwinHan AzureWave AD-TU700(704J)", RC_MAP_AZUREWAVE_AD_TU700) },
+	{ DVB_USB_DEVICE(USB_VID_TERRATEC, USB_PID_TERRATEC_CINERGY_T_USB_XE_REV2,
+		&af9015_props, "TerraTec Cinergy T USB XE", NULL) },
+	{ DVB_USB_DEVICE(USB_VID_KWORLD_2, USB_PID_KWORLD_PC160_2T,
+		&af9015_props, "KWorld PlusTV Dual DVB-T PCI (DVB-T PC160-2T)", NULL) },
+	{ DVB_USB_DEVICE(USB_VID_AVERMEDIA, USB_PID_AVERMEDIA_VOLAR_X,
+		&af9015_props, "AVerMedia AVerTV DVB-T Volar X", RC_MAP_AVERMEDIA_M135A) },
+	{ DVB_USB_DEVICE(USB_VID_XTENSIONS, USB_PID_XTENSIONS_XD_380,
+		&af9015_props, "Xtensions XD-380", NULL) },
+	{ DVB_USB_DEVICE(USB_VID_MSI_2, USB_PID_MSI_DIGIVOX_DUO,
+		&af9015_props, "MSI DIGIVOX Duo", RC_MAP_MSI_DIGIVOX_III) },
+	{ DVB_USB_DEVICE(USB_VID_AVERMEDIA, USB_PID_AVERMEDIA_VOLAR_X_2,
+		&af9015_props, "Fujitsu-Siemens Slim Mobile USB DVB-T", NULL) },
+	{ DVB_USB_DEVICE(USB_VID_TELESTAR,  USB_PID_TELESTAR_STARSTICK_2,
+		&af9015_props, "Telestar Starstick 2", NULL) },
+	{ DVB_USB_DEVICE(USB_VID_AVERMEDIA, USB_PID_AVERMEDIA_A309,
+		&af9015_props, "AVerMedia A309", NULL) },
+	{ DVB_USB_DEVICE(USB_VID_MSI_2, USB_PID_MSI_DIGI_VOX_MINI_III,
+		&af9015_props, "MSI Digi VOX mini III", RC_MAP_MSI_DIGIVOX_III) },
+	{ DVB_USB_DEVICE(USB_VID_KWORLD_2, USB_PID_KWORLD_395U,
+		&af9015_props, "KWorld USB DVB-T TV Stick II (VS-DVB-T 395U)", NULL) },
+	{ DVB_USB_DEVICE(USB_VID_KWORLD_2, USB_PID_KWORLD_395U_2,
+		&af9015_props, "KWorld USB DVB-T TV Stick II (VS-DVB-T 395U)", NULL) },
+	{ DVB_USB_DEVICE(USB_VID_KWORLD_2, USB_PID_KWORLD_395U_3,
+		&af9015_props, "KWorld USB DVB-T TV Stick II (VS-DVB-T 395U)", NULL) },
+	{ DVB_USB_DEVICE(USB_VID_AFATECH, USB_PID_TREKSTOR_DVBT,
+		&af9015_props, "TrekStor DVB-T USB Stick", RC_MAP_TREKSTOR) },
+	{ DVB_USB_DEVICE(USB_VID_AVERMEDIA, USB_PID_AVERMEDIA_A850,
+		&af9015_props, "AverMedia AVerTV Volar Black HD (A850)", NULL) },
+	{ DVB_USB_DEVICE(USB_VID_AVERMEDIA, USB_PID_AVERMEDIA_A805,
+		&af9015_props, "AverMedia AVerTV Volar GPS 805 (A805)", NULL) },
+	{ DVB_USB_DEVICE(USB_VID_KWORLD_2, USB_PID_CONCEPTRONIC_CTVDIGRCU,
+		&af9015_props, "Conceptronic USB2.0 DVB-T CTVDIGRCU V3.0", NULL) },
+	{ DVB_USB_DEVICE(USB_VID_KWORLD_2, USB_PID_KWORLD_MC810,
+		&af9015_props, "KWorld Digial MC-810", NULL) },
+	{ DVB_USB_DEVICE(USB_VID_KYE, USB_PID_GENIUS_TVGO_DVB_T03,
+		&af9015_props, "Genius TVGo DVB-T03", NULL) },
+	{ DVB_USB_DEVICE(USB_VID_KWORLD_2, USB_PID_KWORLD_399U_2,
+		&af9015_props, "KWorld PlusTV Dual DVB-T Stick (DVB-T 399U)", NULL) },
+	{ DVB_USB_DEVICE(USB_VID_KWORLD_2, USB_PID_KWORLD_PC160_T,
+		&af9015_props, "KWorld PlusTV DVB-T PCI Pro Card (DVB-T PC160-T)", NULL) },
+	{ DVB_USB_DEVICE(USB_VID_KWORLD_2, USB_PID_SVEON_STV20,
+		&af9015_props, "Sveon STV20 Tuner USB DVB-T HDTV", NULL) },
+	{ DVB_USB_DEVICE(USB_VID_KWORLD_2, USB_PID_TINYTWIN_2,
+		&af9015_props, "DigitalNow TinyTwin v2", RC_MAP_DIGITALNOW_TINYTWIN) },
+	{ DVB_USB_DEVICE(USB_VID_LEADTEK, USB_PID_WINFAST_DTV2000DS,
+		&af9015_props, "Leadtek WinFast DTV2000DS", RC_MAP_LEADTEK_Y04G0051) },
+	{ DVB_USB_DEVICE(USB_VID_KWORLD_2, USB_PID_KWORLD_UB383_T,
+		&af9015_props, "KWorld USB DVB-T Stick Mobile (UB383-T)", NULL) },
+	{ DVB_USB_DEVICE(USB_VID_KWORLD_2, USB_PID_KWORLD_395U_4,
+		&af9015_props, "KWorld USB DVB-T TV Stick II (VS-DVB-T 395U)", NULL) },
+	{ DVB_USB_DEVICE(USB_VID_AVERMEDIA, USB_PID_AVERMEDIA_A815M,
+		&af9015_props, "AverMedia AVerTV Volar M (A815Mac)", NULL) },
+	{ DVB_USB_DEVICE(USB_VID_TERRATEC, USB_PID_TERRATEC_CINERGY_T_STICK_RC,
+		&af9015_props, "TerraTec Cinergy T Stick RC", RC_MAP_TERRATEC_SLIM_2) },
+	{ DVB_USB_DEVICE(USB_VID_TERRATEC, USB_PID_TERRATEC_CINERGY_T_STICK_DUAL_RC,
+		&af9015_props, "TerraTec Cinergy T Stick Dual RC", RC_MAP_TERRATEC_SLIM) },
+	{ DVB_USB_DEVICE(USB_VID_AVERMEDIA, USB_PID_AVERMEDIA_A850T,
+		&af9015_props, "AverMedia AVerTV Red HD+ (A850T)", NULL) },
+	{ DVB_USB_DEVICE(USB_VID_GTEK, USB_PID_TINYTWIN_3,
+		&af9015_props, "DigitalNow TinyTwin v3", RC_MAP_DIGITALNOW_TINYTWIN) },
+	{ DVB_USB_DEVICE(USB_VID_KWORLD_2, USB_PID_SVEON_STV22,
+		&af9015_props, "Sveon STV22 Dual USB DVB-T Tuner HDTV", RC_MAP_MSI_DIGIVOX_III) },
+	{ }
+};
+MODULE_DEVICE_TABLE(usb, af9015_id_table);
+
+/* usb specific object needed to register this driver with the usb subsystem */
+static struct usb_driver af9015_usb_driver = {
+	.name = KBUILD_MODNAME,
+	.id_table = af9015_id_table,
+	.probe = dvb_usbv2_probe,
+	.disconnect = dvb_usbv2_disconnect,
+	.suspend = dvb_usbv2_suspend,
+	.resume = dvb_usbv2_resume,
+	.no_dynamic_id = 1,
+	.soft_unbind = 1,
+};
+
+module_usb_driver(af9015_usb_driver);
+
+MODULE_AUTHOR("Antti Palosaari <crope@iki.fi>");
+MODULE_DESCRIPTION("Afatech AF9015 driver");
+MODULE_LICENSE("GPL");
