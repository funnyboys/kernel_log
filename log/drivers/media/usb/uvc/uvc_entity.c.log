commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/media/usb/uvc/uvc_entity.c b/drivers/media/usb/uvc/uvc_entity.c
index 06bffdf8828b..b4499cddeffe 100644
--- a/drivers/media/usb/uvc/uvc_entity.c
+++ b/drivers/media/usb/uvc/uvc_entity.c
@@ -1,14 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *      uvc_entity.c  --  USB Video Class driver
  *
  *      Copyright (C) 2005-2011
  *          Laurent Pinchart (laurent.pinchart@ideasonboard.com)
- *
- *      This program is free software; you can redistribute it and/or modify
- *      it under the terms of the GNU General Public License as published by
- *      the Free Software Foundation; either version 2 of the License, or
- *      (at your option) any later version.
- *
  */
 
 #include <linux/kernel.h>

commit c0decac19da3906d9b66291e57b7759489e1170f
Author: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
Date:   Mon Sep 10 08:19:14 2018 -0400

    media: use strscpy() instead of strlcpy()
    
    The implementation of strscpy() is more robust and safer.
    
    That's now the recommended way to copy NUL terminated strings.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Acked-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/usb/uvc/uvc_entity.c b/drivers/media/usb/uvc/uvc_entity.c
index 554063c07d7a..06bffdf8828b 100644
--- a/drivers/media/usb/uvc/uvc_entity.c
+++ b/drivers/media/usb/uvc/uvc_entity.c
@@ -79,7 +79,7 @@ static int uvc_mc_init_entity(struct uvc_video_chain *chain,
 
 	if (UVC_ENTITY_TYPE(entity) != UVC_TT_STREAMING) {
 		v4l2_subdev_init(&entity->subdev, &uvc_subdev_ops);
-		strlcpy(entity->subdev.name, entity->name,
+		strscpy(entity->subdev.name, entity->name,
 			sizeof(entity->subdev.name));
 
 		ret = media_entity_pads_init(&entity->subdev.entity,

commit 54220790149809fd48dfb999f732b345b7097a1a
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Tue Aug 8 08:56:24 2017 -0400

    media: uvcvideo: Constify video_subdev structures
    
    uvc_subdev_ops is only passed as the second argument of
    v4l2_subdev_init, which is const, so uvc_subdev_ops can be
    const as well.
    
    Done with the help of Coccinelle.
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/usb/uvc/uvc_entity.c b/drivers/media/usb/uvc/uvc_entity.c
index ac386bb547e6..554063c07d7a 100644
--- a/drivers/media/usb/uvc/uvc_entity.c
+++ b/drivers/media/usb/uvc/uvc_entity.c
@@ -61,7 +61,7 @@ static int uvc_mc_create_links(struct uvc_video_chain *chain,
 	return 0;
 }
 
-static struct v4l2_subdev_ops uvc_subdev_ops = {
+static const struct v4l2_subdev_ops uvc_subdev_ops = {
 };
 
 void uvc_mc_cleanup_entity(struct uvc_entity *entity)

commit 1cb2f6f4b1652ad4e19894a4b4b82b0c2ea8a4b6
Author: Javier Martinez Canillas <javier@osg.samsung.com>
Date:   Fri Dec 11 15:16:35 2015 -0200

    [media] uvcvideo: register entity subdev on init
    
    The uvc_mc_register_entities() function iterated over the entities three
    times to initialize the entities, register the subdev for the ones whose
    type was UVC_TT_STREAMING and to create the entities links.
    
    But this can be simplied by merging the init and registration logic in a
    single loop.
    
    Suggested-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Javier Martinez Canillas <javier@osg.samsung.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/usb/uvc/uvc_entity.c b/drivers/media/usb/uvc/uvc_entity.c
index 33119dcb7cec..ac386bb547e6 100644
--- a/drivers/media/usb/uvc/uvc_entity.c
+++ b/drivers/media/usb/uvc/uvc_entity.c
@@ -19,19 +19,6 @@
 
 #include "uvcvideo.h"
 
-/* ------------------------------------------------------------------------
- * Video subdevices registration and unregistration
- */
-
-static int uvc_mc_register_entity(struct uvc_video_chain *chain,
-	struct uvc_entity *entity)
-{
-	if (UVC_ENTITY_TYPE(entity) == UVC_TT_STREAMING)
-		return 0;
-
-	return v4l2_device_register_subdev(&chain->dev->vdev, &entity->subdev);
-}
-
 static int uvc_mc_create_links(struct uvc_video_chain *chain,
 				    struct uvc_entity *entity)
 {
@@ -85,7 +72,8 @@ void uvc_mc_cleanup_entity(struct uvc_entity *entity)
 		media_entity_cleanup(&entity->vdev->entity);
 }
 
-static int uvc_mc_init_entity(struct uvc_entity *entity)
+static int uvc_mc_init_entity(struct uvc_video_chain *chain,
+			      struct uvc_entity *entity)
 {
 	int ret;
 
@@ -96,6 +84,12 @@ static int uvc_mc_init_entity(struct uvc_entity *entity)
 
 		ret = media_entity_pads_init(&entity->subdev.entity,
 					entity->num_pads, entity->pads);
+
+		if (ret < 0)
+			return ret;
+
+		ret = v4l2_device_register_subdev(&chain->dev->vdev,
+						  &entity->subdev);
 	} else if (entity->vdev != NULL) {
 		ret = media_entity_pads_init(&entity->vdev->entity,
 					entity->num_pads, entity->pads);
@@ -113,7 +107,7 @@ int uvc_mc_register_entities(struct uvc_video_chain *chain)
 	int ret;
 
 	list_for_each_entry(entity, &chain->entities, chain) {
-		ret = uvc_mc_init_entity(entity);
+		ret = uvc_mc_init_entity(chain, entity);
 		if (ret < 0) {
 			uvc_printk(KERN_INFO, "Failed to initialize entity for "
 				   "entity %u\n", entity->id);
@@ -121,15 +115,6 @@ int uvc_mc_register_entities(struct uvc_video_chain *chain)
 		}
 	}
 
-	list_for_each_entry(entity, &chain->entities, chain) {
-		ret = uvc_mc_register_entity(chain, entity);
-		if (ret < 0) {
-			uvc_printk(KERN_INFO, "Failed to register entity for "
-				   "entity %u\n", entity->id);
-			return ret;
-		}
-	}
-
 	list_for_each_entry(entity, &chain->entities, chain) {
 		ret = uvc_mc_create_links(chain, entity);
 		if (ret < 0) {

commit 552faf4c083d8e86c6d86160ae3da0412280f690
Author: Javier Martinez Canillas <javier@osg.samsung.com>
Date:   Fri Dec 11 15:16:34 2015 -0200

    [media] uvcvideo: remove pads prefix from uvc_mc_create_pads_links()
    
    The function uvc_mc_create_pads_links() creates entities links but the
    "pads" prefix is redundant since the driver doesn't handle any other
    kind of link, so it can be removed.
    
    Suggested-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Javier Martinez Canillas <javier@osg.samsung.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/usb/uvc/uvc_entity.c b/drivers/media/usb/uvc/uvc_entity.c
index 38e893a1408b..33119dcb7cec 100644
--- a/drivers/media/usb/uvc/uvc_entity.c
+++ b/drivers/media/usb/uvc/uvc_entity.c
@@ -32,7 +32,7 @@ static int uvc_mc_register_entity(struct uvc_video_chain *chain,
 	return v4l2_device_register_subdev(&chain->dev->vdev, &entity->subdev);
 }
 
-static int uvc_mc_create_pads_links(struct uvc_video_chain *chain,
+static int uvc_mc_create_links(struct uvc_video_chain *chain,
 				    struct uvc_entity *entity)
 {
 	const u32 flags = MEDIA_LNK_FL_ENABLED | MEDIA_LNK_FL_IMMUTABLE;
@@ -131,9 +131,9 @@ int uvc_mc_register_entities(struct uvc_video_chain *chain)
 	}
 
 	list_for_each_entry(entity, &chain->entities, chain) {
-		ret = uvc_mc_create_pads_links(chain, entity);
+		ret = uvc_mc_create_links(chain, entity);
 		if (ret < 0) {
-			uvc_printk(KERN_INFO, "Failed to create pads links for "
+			uvc_printk(KERN_INFO, "Failed to create links for "
 				   "entity %u\n", entity->id);
 			return ret;
 		}

commit ab22e77cd3d3073c8cac51b59713ef635678dfbe
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Fri Dec 11 07:44:40 2015 -0200

    [media] media framework: rename pads init function to media_entity_pads_init()
    
    With the MC next gen rework, what's left for media_entity_init()
    is to just initialize the PADs. However, certain devices, like
    a FLASH led/light doesn't have any input or output PAD.
    
    So, there's no reason why calling media_entity_init() would be
    mandatory. Also, despite its name, what this function actually
    does is to initialize the PADs data. So, rename it to
    media_entity_pads_init() in order to reflect that.
    
    The media entity actual init happens during entity register,
    at media_device_register_entity(). We should move init of
    num_links and num_backlinks to it.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/usb/uvc/uvc_entity.c b/drivers/media/usb/uvc/uvc_entity.c
index 7f82b65b238e..38e893a1408b 100644
--- a/drivers/media/usb/uvc/uvc_entity.c
+++ b/drivers/media/usb/uvc/uvc_entity.c
@@ -94,10 +94,10 @@ static int uvc_mc_init_entity(struct uvc_entity *entity)
 		strlcpy(entity->subdev.name, entity->name,
 			sizeof(entity->subdev.name));
 
-		ret = media_entity_init(&entity->subdev.entity,
+		ret = media_entity_pads_init(&entity->subdev.entity,
 					entity->num_pads, entity->pads);
 	} else if (entity->vdev != NULL) {
-		ret = media_entity_init(&entity->vdev->entity,
+		ret = media_entity_pads_init(&entity->vdev->entity,
 					entity->num_pads, entity->pads);
 		if (entity->flags & UVC_ENTITY_FLAG_DEFAULT)
 			entity->vdev->entity.flags |= MEDIA_ENT_FL_DEFAULT;

commit c5a98cac6ecd78ca647c41cb25e3ea1835579d70
Author: Javier Martinez Canillas <javier@osg.samsung.com>
Date:   Thu Sep 3 08:46:06 2015 -0300

    [media] uvcvideo: create pad links after subdev registration
    
    The uvc driver creates the pads links before the media entity is
    registered with the media device. This doesn't work now that obj
    IDs are used to create links so the media_device has to be set.
    
    Move entities registration logic before pads links creation.
    
    Signed-off-by: Javier Martinez Canillas <javier@osg.samsung.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/usb/uvc/uvc_entity.c b/drivers/media/usb/uvc/uvc_entity.c
index 429e428ccd93..7f82b65b238e 100644
--- a/drivers/media/usb/uvc/uvc_entity.c
+++ b/drivers/media/usb/uvc/uvc_entity.c
@@ -25,6 +25,15 @@
 
 static int uvc_mc_register_entity(struct uvc_video_chain *chain,
 	struct uvc_entity *entity)
+{
+	if (UVC_ENTITY_TYPE(entity) == UVC_TT_STREAMING)
+		return 0;
+
+	return v4l2_device_register_subdev(&chain->dev->vdev, &entity->subdev);
+}
+
+static int uvc_mc_create_pads_links(struct uvc_video_chain *chain,
+				    struct uvc_entity *entity)
 {
 	const u32 flags = MEDIA_LNK_FL_ENABLED | MEDIA_LNK_FL_IMMUTABLE;
 	struct media_entity *sink;
@@ -62,10 +71,7 @@ static int uvc_mc_register_entity(struct uvc_video_chain *chain,
 			return ret;
 	}
 
-	if (UVC_ENTITY_TYPE(entity) == UVC_TT_STREAMING)
-		return 0;
-
-	return v4l2_device_register_subdev(&chain->dev->vdev, &entity->subdev);
+	return 0;
 }
 
 static struct v4l2_subdev_ops uvc_subdev_ops = {
@@ -124,5 +130,14 @@ int uvc_mc_register_entities(struct uvc_video_chain *chain)
 		}
 	}
 
+	list_for_each_entry(entity, &chain->entities, chain) {
+		ret = uvc_mc_create_pads_links(chain, entity);
+		if (ret < 0) {
+			uvc_printk(KERN_INFO, "Failed to create pads links for "
+				   "entity %u\n", entity->id);
+			return ret;
+		}
+	}
+
 	return 0;
 }

commit 8df00a15817e3a252510ac914870214859325189
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Fri Aug 7 08:14:38 2015 -0300

    [media] media: rename the function that create pad links
    
    With the new API, a link can be either between two PADs or between an interface
    and an entity. So, we need to use a better name for the function that create
    links between two pads.
    
    So, rename the such function to media_create_pad_link().
    
    No functional changes.
    
    This patch was created via this shell script:
            for i in $(find drivers/media -name '*.[ch]' -type f) $(find drivers/staging/media -name '*.[ch]' -type f) $(find include/ -name '*.h' -type f) ; do sed s,media_entity_create_link,media_create_pad_link,g <$i >a && mv a $i; done
    
    Acked-by: Hans Verkuil <hans.verkuil@cisco.com>
    Tested-by: Javier Martinez Canillas <javier@osg.samsung.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/usb/uvc/uvc_entity.c b/drivers/media/usb/uvc/uvc_entity.c
index 245445491516..429e428ccd93 100644
--- a/drivers/media/usb/uvc/uvc_entity.c
+++ b/drivers/media/usb/uvc/uvc_entity.c
@@ -56,7 +56,7 @@ static int uvc_mc_register_entity(struct uvc_video_chain *chain,
 			continue;
 
 		remote_pad = remote->num_pads - 1;
-		ret = media_entity_create_link(source, remote_pad,
+		ret = media_create_pad_link(source, remote_pad,
 					       sink, i, flags);
 		if (ret < 0)
 			return ret;

commit 1809510715c4187fa7338204cac53e30326d5d04
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Thu Aug 6 09:25:57 2015 -0300

    [media] media: get rid of unused "extra_links" param on media_entity_init()
    
    Currently, media_entity_init() creates an array with the links,
    allocated at init time. It provides a parameter (extra_links)
    that would allocate more links than the current needs, but this
    is not used by any driver.
    
    As we want to be able to do dynamic link allocation/removal,
    we'll need to change the implementation of the links. So,
    before doing that, let's first remove that extra unused
    parameter, in order to cleanup the interface first.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
    Acked-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/usb/uvc/uvc_entity.c b/drivers/media/usb/uvc/uvc_entity.c
index dc56a59ecadc..245445491516 100644
--- a/drivers/media/usb/uvc/uvc_entity.c
+++ b/drivers/media/usb/uvc/uvc_entity.c
@@ -89,10 +89,10 @@ static int uvc_mc_init_entity(struct uvc_entity *entity)
 			sizeof(entity->subdev.name));
 
 		ret = media_entity_init(&entity->subdev.entity,
-					entity->num_pads, entity->pads, 0);
+					entity->num_pads, entity->pads);
 	} else if (entity->vdev != NULL) {
 		ret = media_entity_init(&entity->vdev->entity,
-					entity->num_pads, entity->pads, 0);
+					entity->num_pads, entity->pads);
 		if (entity->flags & UVC_ENTITY_FLAG_DEFAULT)
 			entity->vdev->entity.flags |= MEDIA_ENT_FL_DEFAULT;
 	} else

commit 8be8ec6ea58bd77338f6ffa2f6d2acfc88b835f4
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Fri Aug 3 04:35:10 2012 -0300

    [media] uvcvideo: Mark first output terminal as default video node
    
    The MEDIA_ENT_FL_DEFAULT identifies entities that are considered as
    default for their group and type. For video nodes, it identifies the
    node that application should use by default.
    UVC devices don't report which output terminal should be considered as
    the default, use the first one. Most devices have a single output
    terminal anyway.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/usb/uvc/uvc_entity.c b/drivers/media/usb/uvc/uvc_entity.c
index 29e239911d0e..dc56a59ecadc 100644
--- a/drivers/media/usb/uvc/uvc_entity.c
+++ b/drivers/media/usb/uvc/uvc_entity.c
@@ -93,6 +93,8 @@ static int uvc_mc_init_entity(struct uvc_entity *entity)
 	} else if (entity->vdev != NULL) {
 		ret = media_entity_init(&entity->vdev->entity,
 					entity->num_pads, entity->pads, 0);
+		if (entity->flags & UVC_ENTITY_FLAG_DEFAULT)
+			entity->vdev->entity.flags |= MEDIA_ENT_FL_DEFAULT;
 	} else
 		ret = 0;
 

commit 0c0d06cac63ee327ceaab4b5ffe2206574ab86bd
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Tue Aug 14 00:13:22 2012 -0300

    [media] rename most media/video usb drivers to media/usb
    
    Rename all USB drivers with their own directory under
    drivers/media/video into drivers/media/usb and update the
    building system.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/usb/uvc/uvc_entity.c b/drivers/media/usb/uvc/uvc_entity.c
new file mode 100644
index 000000000000..29e239911d0e
--- /dev/null
+++ b/drivers/media/usb/uvc/uvc_entity.c
@@ -0,0 +1,126 @@
+/*
+ *      uvc_entity.c  --  USB Video Class driver
+ *
+ *      Copyright (C) 2005-2011
+ *          Laurent Pinchart (laurent.pinchart@ideasonboard.com)
+ *
+ *      This program is free software; you can redistribute it and/or modify
+ *      it under the terms of the GNU General Public License as published by
+ *      the Free Software Foundation; either version 2 of the License, or
+ *      (at your option) any later version.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/videodev2.h>
+
+#include <media/v4l2-common.h>
+
+#include "uvcvideo.h"
+
+/* ------------------------------------------------------------------------
+ * Video subdevices registration and unregistration
+ */
+
+static int uvc_mc_register_entity(struct uvc_video_chain *chain,
+	struct uvc_entity *entity)
+{
+	const u32 flags = MEDIA_LNK_FL_ENABLED | MEDIA_LNK_FL_IMMUTABLE;
+	struct media_entity *sink;
+	unsigned int i;
+	int ret;
+
+	sink = (UVC_ENTITY_TYPE(entity) == UVC_TT_STREAMING)
+	     ? (entity->vdev ? &entity->vdev->entity : NULL)
+	     : &entity->subdev.entity;
+	if (sink == NULL)
+		return 0;
+
+	for (i = 0; i < entity->num_pads; ++i) {
+		struct media_entity *source;
+		struct uvc_entity *remote;
+		u8 remote_pad;
+
+		if (!(entity->pads[i].flags & MEDIA_PAD_FL_SINK))
+			continue;
+
+		remote = uvc_entity_by_id(chain->dev, entity->baSourceID[i]);
+		if (remote == NULL)
+			return -EINVAL;
+
+		source = (UVC_ENTITY_TYPE(remote) == UVC_TT_STREAMING)
+		       ? (remote->vdev ? &remote->vdev->entity : NULL)
+		       : &remote->subdev.entity;
+		if (source == NULL)
+			continue;
+
+		remote_pad = remote->num_pads - 1;
+		ret = media_entity_create_link(source, remote_pad,
+					       sink, i, flags);
+		if (ret < 0)
+			return ret;
+	}
+
+	if (UVC_ENTITY_TYPE(entity) == UVC_TT_STREAMING)
+		return 0;
+
+	return v4l2_device_register_subdev(&chain->dev->vdev, &entity->subdev);
+}
+
+static struct v4l2_subdev_ops uvc_subdev_ops = {
+};
+
+void uvc_mc_cleanup_entity(struct uvc_entity *entity)
+{
+	if (UVC_ENTITY_TYPE(entity) != UVC_TT_STREAMING)
+		media_entity_cleanup(&entity->subdev.entity);
+	else if (entity->vdev != NULL)
+		media_entity_cleanup(&entity->vdev->entity);
+}
+
+static int uvc_mc_init_entity(struct uvc_entity *entity)
+{
+	int ret;
+
+	if (UVC_ENTITY_TYPE(entity) != UVC_TT_STREAMING) {
+		v4l2_subdev_init(&entity->subdev, &uvc_subdev_ops);
+		strlcpy(entity->subdev.name, entity->name,
+			sizeof(entity->subdev.name));
+
+		ret = media_entity_init(&entity->subdev.entity,
+					entity->num_pads, entity->pads, 0);
+	} else if (entity->vdev != NULL) {
+		ret = media_entity_init(&entity->vdev->entity,
+					entity->num_pads, entity->pads, 0);
+	} else
+		ret = 0;
+
+	return ret;
+}
+
+int uvc_mc_register_entities(struct uvc_video_chain *chain)
+{
+	struct uvc_entity *entity;
+	int ret;
+
+	list_for_each_entry(entity, &chain->entities, chain) {
+		ret = uvc_mc_init_entity(entity);
+		if (ret < 0) {
+			uvc_printk(KERN_INFO, "Failed to initialize entity for "
+				   "entity %u\n", entity->id);
+			return ret;
+		}
+	}
+
+	list_for_each_entry(entity, &chain->entities, chain) {
+		ret = uvc_mc_register_entity(chain, entity);
+		if (ret < 0) {
+			uvc_printk(KERN_INFO, "Failed to register entity for "
+				   "entity %u\n", entity->id);
+			return ret;
+		}
+	}
+
+	return 0;
+}
