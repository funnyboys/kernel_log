commit fd9871f70c3ae52b3ea199069ad6879645402952
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 15:51:54 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 24
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or any
      later version this program is distributed in the hope that it will
      be useful but without any warranty without even the implied warranty
      of merchantability or fitness for a particular purpose see the gnu
      general public license for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 50 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Jilayne Lovejoy <opensource@jilayne.com>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Steve Winslow <swinslow@gmail.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190519154042.917228456@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/media/usb/gspca/spca506.c b/drivers/media/usb/gspca/spca506.c
index 6332b3f0b918..0886587dc89c 100644
--- a/drivers/media/usb/gspca/spca506.c
+++ b/drivers/media/usb/gspca/spca506.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * SPCA506 chip based cameras function
  * M Xhaard 15/04/2004 based on different work Mark Taylor and others
@@ -5,16 +6,6 @@
  *                "Firma Frank Gmbh" from  Saarbruecken
  *
  * V4L2 by Jean-Francois Moine <http://moinejf.free.fr>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
  */
 
 #define MODULE_NAME "spca506"

commit 37d5efb01910752d8d3846a2c4db0528c1dfa137
Author: Joe Perches <joe@perches.com>
Date:   Fri Sep 22 15:20:33 2017 -0400

    media: gspca: Convert PDEBUG to gspca_dbg
    
    Use a more typical logging style.
    
    The current macro hides the gspca_dev argument so add it to the
    macro uses instead.
    
    Miscellanea:
    
    o Add missing '\n' terminations to formats
    o Realign arguments to open parenthesis
    o Remove commented out uses of PDEBUG
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/usb/gspca/spca506.c b/drivers/media/usb/gspca/spca506.c
index 843c93f5acf3..6332b3f0b918 100644
--- a/drivers/media/usb/gspca/spca506.c
+++ b/drivers/media/usb/gspca/spca506.c
@@ -126,7 +126,7 @@ static void spca506_SetNormeInput(struct gspca_dev *gspca_dev,
 	__u8 setbit1 = 0x00;
 	__u8 videomask = 0x00;
 
-	PDEBUG(D_STREAM, "** Open Set Norme **");
+	gspca_dbg(gspca_dev, D_STREAM, "** Open Set Norme **\n");
 	spca506_Initi2c(gspca_dev);
 	/* NTSC bit0 -> 1(525 l) PAL SECAM bit0 -> 0 (625 l) */
 	/* Composite channel bit1 -> 1 S-video bit 1 -> 0 */
@@ -153,8 +153,9 @@ static void spca506_SetNormeInput(struct gspca_dev *gspca_dev,
 
 	sd->norme = norme;
 	sd->channel = channel;
-	PDEBUG(D_STREAM, "Set Video Byte to 0x%2x", videomask);
-	PDEBUG(D_STREAM, "Set Norme: %08x Channel %d", norme, channel);
+	gspca_dbg(gspca_dev, D_STREAM, "Set Video Byte to 0x%2x\n", videomask);
+	gspca_dbg(gspca_dev, D_STREAM, "Set Norme: %08x Channel %d",
+		  norme, channel);
 }
 
 static void spca506_GetNormeInput(struct gspca_dev *gspca_dev,
@@ -166,7 +167,8 @@ static void spca506_GetNormeInput(struct gspca_dev *gspca_dev,
 	   we use your own copy in spca50x struct */
 	*norme = sd->norme;
 	*channel = sd->channel;
-	PDEBUG(D_STREAM, "Get Norme: %d Channel %d", *norme, *channel);
+	gspca_dbg(gspca_dev, D_STREAM, "Get Norme: %d Channel %d\n",
+		  *norme, *channel);
 }
 
 static void spca506_Setsize(struct gspca_dev *gspca_dev, __u16 code,
@@ -174,7 +176,7 @@ static void spca506_Setsize(struct gspca_dev *gspca_dev, __u16 code,
 {
 	struct usb_device *dev = gspca_dev->dev;
 
-	PDEBUG(D_STREAM, "** SetSize **");
+	gspca_dbg(gspca_dev, D_STREAM, "** SetSize **\n");
 	reg_w(dev, 0x04, (0x18 | (code & 0x07)), 0x0000);
 	/* Soft snap 0x40 Hard 0x41 */
 	reg_w(dev, 0x04, 0x41, 0x0001);
@@ -317,7 +319,7 @@ static int sd_init(struct gspca_dev *gspca_dev)
 	spca506_WriteI2c(gspca_dev, 0x00, 0x60);
 	spca506_WriteI2c(gspca_dev, 0x05, 0x61);
 	spca506_WriteI2c(gspca_dev, 0x9f, 0x62);
-	PDEBUG(D_STREAM, "** Close Init *");
+	gspca_dbg(gspca_dev, D_STREAM, "** Close Init *\n");
 	return 0;
 }
 
@@ -445,7 +447,7 @@ static int sd_start(struct gspca_dev *gspca_dev)
 	reg_w(dev, 0x02, 0x01, 0x0000);
 	reg_w(dev, 0x03, 0x12, 0x0000);
 	reg_r(gspca_dev, 0x04, 0x0001, 2);
-	PDEBUG(D_STREAM, "webcam started");
+	gspca_dbg(gspca_dev, D_STREAM, "webcam started\n");
 	spca506_GetNormeInput(gspca_dev, &norme, &channel);
 	spca506_SetNormeInput(gspca_dev, norme, channel);
 	return 0;

commit bcb63314e2c23f1ed622418b65f9409512659c73
Author: Sakari Ailus <sakari.ailus@linux.intel.com>
Date:   Fri Oct 28 09:31:20 2016 -0200

    [media] media: Drop FSF's postal address from the source code files
    
    Drop the FSF's postal address from the source code files that typically
    contain mostly the license text. Of the 628 removed instances, 578 are
    outdated.
    
    The patch has been created with the following command without manual edits:
    
    git grep -l "675 Mass Ave\|59 Temple Place\|51 Franklin St" -- \
            drivers/media/ include/media|while read i; do i=$i perl -e '
    open(F,"< $ENV{i}");
    $a=join("", <F>);
    $a =~ s/[ \t]*\*\n.*You should.*\n.*along with.*\n.*(\n.*USA.*$)?\n//m
            && $a =~ s/(^.*)Or, (point your browser to) /$1To obtain the license, $2\n$1/m;
    close(F);
    open(F, "> $ENV{i}");
    print F $a;
    close(F);'; done
    
    Signed-off-by: Sakari Ailus <sakari.ailus@linux.intel.com>

diff --git a/drivers/media/usb/gspca/spca506.c b/drivers/media/usb/gspca/spca506.c
index ee84863d27d4..843c93f5acf3 100644
--- a/drivers/media/usb/gspca/spca506.c
+++ b/drivers/media/usb/gspca/spca506.c
@@ -15,10 +15,6 @@
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
  */
 
 #define MODULE_NAME "spca506"

commit 0889e4a1bd569a2f1bf431170cec453b3ca4a658
Author: Mauro Carvalho Chehab <mchehab@s-opensource.com>
Date:   Sat Oct 22 20:45:23 2016 -0200

    [media] spca506: rewrite a commented line to avoid wrong parsing
    
    Keeping Documentation/media/v4l-drivers/gspca-cardlist.rst in
    sync with the gspca script requires a parser. Simplify the
    commented line, to make the parser work better.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/usb/gspca/spca506.c b/drivers/media/usb/gspca/spca506.c
index bcd2c04c770e..ee84863d27d4 100644
--- a/drivers/media/usb/gspca/spca506.c
+++ b/drivers/media/usb/gspca/spca506.c
@@ -581,8 +581,7 @@ static const struct sd_desc sd_desc = {
 /* -- module initialisation -- */
 static const struct usb_device_id device_table[] = {
 	{USB_DEVICE(0x06e1, 0xa190)},
-/*fixme: may be IntelPCCameraPro BRIDGE_SPCA505
-	{USB_DEVICE(0x0733, 0x0430)}, */
+/*	{USB_DEVICE(0x0733, 0x0430)}, FIXME: may be IntelPCCameraPro BRIDGE_SPCA505 */
 	{USB_DEVICE(0x0734, 0x043b)},
 	{USB_DEVICE(0x99fa, 0x8988)},
 	{}

commit 4c62e9764ab403d42f9b8871b1241fe7812f19d4
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Dec 21 13:17:53 2012 -0800

    Drivers: media: remove __dev* attributes.
    
    CONFIG_HOTPLUG is going away as an option.  As a result, the __dev*
    markings need to be removed.
    
    This change removes the use of __devinit, __devexit_p, __devinitdata,
    __devinitconst, and __devexit from these drivers.
    
    Based on patches originally written by Bill Pemberton, but redone by me
    in order to handle some of the coding style issues better, by hand.
    
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Mauro Carvalho Chehab <mchehab@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/media/usb/gspca/spca506.c b/drivers/media/usb/gspca/spca506.c
index bab01c86c315..bcd2c04c770e 100644
--- a/drivers/media/usb/gspca/spca506.c
+++ b/drivers/media/usb/gspca/spca506.c
@@ -590,8 +590,7 @@ static const struct usb_device_id device_table[] = {
 MODULE_DEVICE_TABLE(usb, device_table);
 
 /* -- device connect -- */
-static int __devinit sd_probe(struct usb_interface *intf,
-			const struct usb_device_id *id)
+static int sd_probe(struct usb_interface *intf, const struct usb_device_id *id)
 {
 	return gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),
 				THIS_MODULE);

commit 79e8c7bebb467bbc3f2514d75bba669a3f354324
Merge: a47b6118e134 fea7a08acb13
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Fri Aug 24 11:25:10 2012 -0300

    Merge tag 'v3.6-rc3' into staging/for_v3.7
    
    Linux 3.6-rc3
    
    * tag 'v3.6-rc3': (764 commits)
      Linux 3.6-rc3
      task_work: add a scheduling point in task_work_run()
      fs: fix fs/namei.c kernel-doc warnings
      eventpoll: use-after-possible-free in epoll_create1()
      vfio: grab vfio_device reference *before* exposing the sucker via fd_install()
      vfio: get rid of vfio_device_put()/vfio_group_get_device* races
      vfio: get rid of open-coding kref_put_mutex
      introduce kref_put_mutex()
      vfio: don't dereference after kfree...
      fbcon: fix race condition between console lock and cursor timer (v1.1)
      mm: compaction: Abort async compaction if locks are contended or taking too long
      mm: have order > 0 compaction start near a pageblock with free pages
      rapidio/tsi721: fix unused variable compiler warning
      rapidio/tsi721: fix inbound doorbell interrupt handling
      drivers/rtc/rtc-rs5c348.c: fix hour decoding in 12-hour mode
      mm: correct page->pfmemalloc to fix deactivate_slab regression
      drivers/rtc/rtc-pcf2123.c: initialize dynamic sysfs attributes
      mm/compaction.c: fix deferring compaction mistake
      drivers/misc/sgi-xp/xpc_uv.c: SGI XPC fails to load when cpu 0 is out of IRQ resources
      string: do not export memweight() to userspace
      ...

commit 0c0d06cac63ee327ceaab4b5ffe2206574ab86bd
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Tue Aug 14 00:13:22 2012 -0300

    [media] rename most media/video usb drivers to media/usb
    
    Rename all USB drivers with their own directory under
    drivers/media/video into drivers/media/usb and update the
    building system.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/usb/gspca/spca506.c b/drivers/media/usb/gspca/spca506.c
new file mode 100644
index 000000000000..969bb5a4cd93
--- /dev/null
+++ b/drivers/media/usb/gspca/spca506.c
@@ -0,0 +1,612 @@
+/*
+ * SPCA506 chip based cameras function
+ * M Xhaard 15/04/2004 based on different work Mark Taylor and others
+ * and my own snoopy file on a pv-321c donate by a german compagny
+ *                "Firma Frank Gmbh" from  Saarbruecken
+ *
+ * V4L2 by Jean-Francois Moine <http://moinejf.free.fr>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#define MODULE_NAME "spca506"
+
+#include "gspca.h"
+
+MODULE_AUTHOR("Michel Xhaard <mxhaard@users.sourceforge.net>");
+MODULE_DESCRIPTION("GSPCA/SPCA506 USB Camera Driver");
+MODULE_LICENSE("GPL");
+
+/* specific webcam descriptor */
+struct sd {
+	struct gspca_dev gspca_dev;	/* !! must be the first item */
+
+	char norme;
+	char channel;
+};
+
+static const struct v4l2_pix_format vga_mode[] = {
+	{160, 120, V4L2_PIX_FMT_SPCA505, V4L2_FIELD_NONE,
+		.bytesperline = 160,
+		.sizeimage = 160 * 120 * 3 / 2,
+		.colorspace = V4L2_COLORSPACE_SRGB,
+		.priv = 5},
+	{176, 144, V4L2_PIX_FMT_SPCA505, V4L2_FIELD_NONE,
+		.bytesperline = 176,
+		.sizeimage = 176 * 144 * 3 / 2,
+		.colorspace = V4L2_COLORSPACE_SRGB,
+		.priv = 4},
+	{320, 240, V4L2_PIX_FMT_SPCA505, V4L2_FIELD_NONE,
+		.bytesperline = 320,
+		.sizeimage = 320 * 240 * 3 / 2,
+		.colorspace = V4L2_COLORSPACE_SRGB,
+		.priv = 2},
+	{352, 288, V4L2_PIX_FMT_SPCA505, V4L2_FIELD_NONE,
+		.bytesperline = 352,
+		.sizeimage = 352 * 288 * 3 / 2,
+		.colorspace = V4L2_COLORSPACE_SRGB,
+		.priv = 1},
+	{640, 480, V4L2_PIX_FMT_SPCA505, V4L2_FIELD_NONE,
+		.bytesperline = 640,
+		.sizeimage = 640 * 480 * 3 / 2,
+		.colorspace = V4L2_COLORSPACE_SRGB,
+		.priv = 0},
+};
+
+#define SPCA50X_OFFSET_DATA 10
+
+#define SAA7113_bright 0x0a	/* defaults 0x80 */
+#define SAA7113_contrast 0x0b	/* defaults 0x47 */
+#define SAA7113_saturation 0x0c	/* defaults 0x40 */
+#define SAA7113_hue 0x0d	/* defaults 0x00 */
+#define SAA7113_I2C_BASE_WRITE 0x4a
+
+/* read 'len' bytes to gspca_dev->usb_buf */
+static void reg_r(struct gspca_dev *gspca_dev,
+		  __u16 req,
+		  __u16 index,
+		  __u16 length)
+{
+	usb_control_msg(gspca_dev->dev,
+			usb_rcvctrlpipe(gspca_dev->dev, 0),
+			req,
+			USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
+			0,		/* value */
+			index, gspca_dev->usb_buf, length,
+			500);
+}
+
+static void reg_w(struct usb_device *dev,
+		  __u16 req,
+		  __u16 value,
+		  __u16 index)
+{
+	usb_control_msg(dev,
+			usb_sndctrlpipe(dev, 0),
+			req,
+			USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
+			value, index,
+			NULL, 0, 500);
+}
+
+static void spca506_Initi2c(struct gspca_dev *gspca_dev)
+{
+	reg_w(gspca_dev->dev, 0x07, SAA7113_I2C_BASE_WRITE, 0x0004);
+}
+
+static void spca506_WriteI2c(struct gspca_dev *gspca_dev, __u16 valeur,
+			     __u16 reg)
+{
+	int retry = 60;
+
+	reg_w(gspca_dev->dev, 0x07, reg, 0x0001);
+	reg_w(gspca_dev->dev, 0x07, valeur, 0x0000);
+	while (retry--) {
+		reg_r(gspca_dev, 0x07, 0x0003, 2);
+		if ((gspca_dev->usb_buf[0] | gspca_dev->usb_buf[1]) == 0x00)
+			break;
+	}
+}
+
+static void spca506_SetNormeInput(struct gspca_dev *gspca_dev,
+				 __u16 norme,
+				 __u16 channel)
+{
+	struct sd *sd = (struct sd *) gspca_dev;
+/* fixme: check if channel == 0..3 and 6..9 (8 values) */
+	__u8 setbit0 = 0x00;
+	__u8 setbit1 = 0x00;
+	__u8 videomask = 0x00;
+
+	PDEBUG(D_STREAM, "** Open Set Norme **");
+	spca506_Initi2c(gspca_dev);
+	/* NTSC bit0 -> 1(525 l) PAL SECAM bit0 -> 0 (625 l) */
+	/* Composite channel bit1 -> 1 S-video bit 1 -> 0 */
+	/* and exclude SAA7113 reserved channel set default 0 otherwise */
+	if (norme & V4L2_STD_NTSC)
+		setbit0 = 0x01;
+	if (channel == 4 || channel == 5 || channel > 9)
+		channel = 0;
+	if (channel < 4)
+		setbit1 = 0x02;
+	videomask = (0x48 | setbit0 | setbit1);
+	reg_w(gspca_dev->dev, 0x08, videomask, 0x0000);
+	spca506_WriteI2c(gspca_dev, (0xc0 | (channel & 0x0F)), 0x02);
+
+	if (norme & V4L2_STD_NTSC)
+		spca506_WriteI2c(gspca_dev, 0x33, 0x0e);
+					/* Chrominance Control NTSC N */
+	else if (norme & V4L2_STD_SECAM)
+		spca506_WriteI2c(gspca_dev, 0x53, 0x0e);
+					/* Chrominance Control SECAM */
+	else
+		spca506_WriteI2c(gspca_dev, 0x03, 0x0e);
+					/* Chrominance Control PAL BGHIV */
+
+	sd->norme = norme;
+	sd->channel = channel;
+	PDEBUG(D_STREAM, "Set Video Byte to 0x%2x", videomask);
+	PDEBUG(D_STREAM, "Set Norme: %08x Channel %d", norme, channel);
+}
+
+static void spca506_GetNormeInput(struct gspca_dev *gspca_dev,
+				  __u16 *norme, __u16 *channel)
+{
+	struct sd *sd = (struct sd *) gspca_dev;
+
+	/* Read the register is not so good value change so
+	   we use your own copy in spca50x struct */
+	*norme = sd->norme;
+	*channel = sd->channel;
+	PDEBUG(D_STREAM, "Get Norme: %d Channel %d", *norme, *channel);
+}
+
+static void spca506_Setsize(struct gspca_dev *gspca_dev, __u16 code,
+			    __u16 xmult, __u16 ymult)
+{
+	struct usb_device *dev = gspca_dev->dev;
+
+	PDEBUG(D_STREAM, "** SetSize **");
+	reg_w(dev, 0x04, (0x18 | (code & 0x07)), 0x0000);
+	/* Soft snap 0x40 Hard 0x41 */
+	reg_w(dev, 0x04, 0x41, 0x0001);
+	reg_w(dev, 0x04, 0x00, 0x0002);
+	/* reserved */
+	reg_w(dev, 0x04, 0x00, 0x0003);
+
+	/* reserved */
+	reg_w(dev, 0x04, 0x00, 0x0004);
+	/* reserved */
+	reg_w(dev, 0x04, 0x01, 0x0005);
+	/* reserced */
+	reg_w(dev, 0x04, xmult, 0x0006);
+	/* reserved */
+	reg_w(dev, 0x04, ymult, 0x0007);
+	/* compression 1 */
+	reg_w(dev, 0x04, 0x00, 0x0008);
+	/* T=64 -> 2 */
+	reg_w(dev, 0x04, 0x00, 0x0009);
+	/* threshold2D */
+	reg_w(dev, 0x04, 0x21, 0x000a);
+	/* quantization */
+	reg_w(dev, 0x04, 0x00, 0x000b);
+}
+
+/* this function is called at probe time */
+static int sd_config(struct gspca_dev *gspca_dev,
+			const struct usb_device_id *id)
+{
+	struct cam *cam;
+
+	cam = &gspca_dev->cam;
+	cam->cam_mode = vga_mode;
+	cam->nmodes = ARRAY_SIZE(vga_mode);
+	return 0;
+}
+
+/* this function is called at probe and resume time */
+static int sd_init(struct gspca_dev *gspca_dev)
+{
+	struct usb_device *dev = gspca_dev->dev;
+
+	reg_w(dev, 0x03, 0x00, 0x0004);
+	reg_w(dev, 0x03, 0xFF, 0x0003);
+	reg_w(dev, 0x03, 0x00, 0x0000);
+	reg_w(dev, 0x03, 0x1c, 0x0001);
+	reg_w(dev, 0x03, 0x18, 0x0001);
+	/* Init on PAL and composite input0 */
+	spca506_SetNormeInput(gspca_dev, 0, 0);
+	reg_w(dev, 0x03, 0x1c, 0x0001);
+	reg_w(dev, 0x03, 0x18, 0x0001);
+	reg_w(dev, 0x05, 0x00, 0x0000);
+	reg_w(dev, 0x05, 0xef, 0x0001);
+	reg_w(dev, 0x05, 0x00, 0x00c1);
+	reg_w(dev, 0x05, 0x00, 0x00c2);
+	reg_w(dev, 0x06, 0x18, 0x0002);
+	reg_w(dev, 0x06, 0xf5, 0x0011);
+	reg_w(dev, 0x06, 0x02, 0x0012);
+	reg_w(dev, 0x06, 0xfb, 0x0013);
+	reg_w(dev, 0x06, 0x00, 0x0014);
+	reg_w(dev, 0x06, 0xa4, 0x0051);
+	reg_w(dev, 0x06, 0x40, 0x0052);
+	reg_w(dev, 0x06, 0x71, 0x0053);
+	reg_w(dev, 0x06, 0x40, 0x0054);
+	/************************************************/
+	reg_w(dev, 0x03, 0x00, 0x0004);
+	reg_w(dev, 0x03, 0x00, 0x0003);
+	reg_w(dev, 0x03, 0x00, 0x0004);
+	reg_w(dev, 0x03, 0xFF, 0x0003);
+	reg_w(dev, 0x02, 0x00, 0x0000);
+	reg_w(dev, 0x03, 0x60, 0x0000);
+	reg_w(dev, 0x03, 0x18, 0x0001);
+	/* for a better reading mx :)	  */
+	/*sdca506_WriteI2c(value,register) */
+	spca506_Initi2c(gspca_dev);
+	spca506_WriteI2c(gspca_dev, 0x08, 0x01);
+	spca506_WriteI2c(gspca_dev, 0xc0, 0x02);
+						/* input composite video */
+	spca506_WriteI2c(gspca_dev, 0x33, 0x03);
+	spca506_WriteI2c(gspca_dev, 0x00, 0x04);
+	spca506_WriteI2c(gspca_dev, 0x00, 0x05);
+	spca506_WriteI2c(gspca_dev, 0x0d, 0x06);
+	spca506_WriteI2c(gspca_dev, 0xf0, 0x07);
+	spca506_WriteI2c(gspca_dev, 0x98, 0x08);
+	spca506_WriteI2c(gspca_dev, 0x03, 0x09);
+	spca506_WriteI2c(gspca_dev, 0x80, 0x0a);
+	spca506_WriteI2c(gspca_dev, 0x47, 0x0b);
+	spca506_WriteI2c(gspca_dev, 0x48, 0x0c);
+	spca506_WriteI2c(gspca_dev, 0x00, 0x0d);
+	spca506_WriteI2c(gspca_dev, 0x03, 0x0e);	/* Chroma Pal adjust */
+	spca506_WriteI2c(gspca_dev, 0x2a, 0x0f);
+	spca506_WriteI2c(gspca_dev, 0x00, 0x10);
+	spca506_WriteI2c(gspca_dev, 0x0c, 0x11);
+	spca506_WriteI2c(gspca_dev, 0xb8, 0x12);
+	spca506_WriteI2c(gspca_dev, 0x01, 0x13);
+	spca506_WriteI2c(gspca_dev, 0x00, 0x14);
+	spca506_WriteI2c(gspca_dev, 0x00, 0x15);
+	spca506_WriteI2c(gspca_dev, 0x00, 0x16);
+	spca506_WriteI2c(gspca_dev, 0x00, 0x17);
+	spca506_WriteI2c(gspca_dev, 0x00, 0x18);
+	spca506_WriteI2c(gspca_dev, 0x00, 0x19);
+	spca506_WriteI2c(gspca_dev, 0x00, 0x1a);
+	spca506_WriteI2c(gspca_dev, 0x00, 0x1b);
+	spca506_WriteI2c(gspca_dev, 0x00, 0x1c);
+	spca506_WriteI2c(gspca_dev, 0x00, 0x1d);
+	spca506_WriteI2c(gspca_dev, 0x00, 0x1e);
+	spca506_WriteI2c(gspca_dev, 0xa1, 0x1f);
+	spca506_WriteI2c(gspca_dev, 0x02, 0x40);
+	spca506_WriteI2c(gspca_dev, 0xff, 0x41);
+	spca506_WriteI2c(gspca_dev, 0xff, 0x42);
+	spca506_WriteI2c(gspca_dev, 0xff, 0x43);
+	spca506_WriteI2c(gspca_dev, 0xff, 0x44);
+	spca506_WriteI2c(gspca_dev, 0xff, 0x45);
+	spca506_WriteI2c(gspca_dev, 0xff, 0x46);
+	spca506_WriteI2c(gspca_dev, 0xff, 0x47);
+	spca506_WriteI2c(gspca_dev, 0xff, 0x48);
+	spca506_WriteI2c(gspca_dev, 0xff, 0x49);
+	spca506_WriteI2c(gspca_dev, 0xff, 0x4a);
+	spca506_WriteI2c(gspca_dev, 0xff, 0x4b);
+	spca506_WriteI2c(gspca_dev, 0xff, 0x4c);
+	spca506_WriteI2c(gspca_dev, 0xff, 0x4d);
+	spca506_WriteI2c(gspca_dev, 0xff, 0x4e);
+	spca506_WriteI2c(gspca_dev, 0xff, 0x4f);
+	spca506_WriteI2c(gspca_dev, 0xff, 0x50);
+	spca506_WriteI2c(gspca_dev, 0xff, 0x51);
+	spca506_WriteI2c(gspca_dev, 0xff, 0x52);
+	spca506_WriteI2c(gspca_dev, 0xff, 0x53);
+	spca506_WriteI2c(gspca_dev, 0xff, 0x54);
+	spca506_WriteI2c(gspca_dev, 0xff, 0x55);
+	spca506_WriteI2c(gspca_dev, 0xff, 0x56);
+	spca506_WriteI2c(gspca_dev, 0xff, 0x57);
+	spca506_WriteI2c(gspca_dev, 0x00, 0x58);
+	spca506_WriteI2c(gspca_dev, 0x54, 0x59);
+	spca506_WriteI2c(gspca_dev, 0x07, 0x5a);
+	spca506_WriteI2c(gspca_dev, 0x83, 0x5b);
+	spca506_WriteI2c(gspca_dev, 0x00, 0x5c);
+	spca506_WriteI2c(gspca_dev, 0x00, 0x5d);
+	spca506_WriteI2c(gspca_dev, 0x00, 0x5e);
+	spca506_WriteI2c(gspca_dev, 0x00, 0x5f);
+	spca506_WriteI2c(gspca_dev, 0x00, 0x60);
+	spca506_WriteI2c(gspca_dev, 0x05, 0x61);
+	spca506_WriteI2c(gspca_dev, 0x9f, 0x62);
+	PDEBUG(D_STREAM, "** Close Init *");
+	return 0;
+}
+
+static int sd_start(struct gspca_dev *gspca_dev)
+{
+	struct usb_device *dev = gspca_dev->dev;
+	__u16 norme;
+	__u16 channel;
+
+	/**************************************/
+	reg_w(dev, 0x03, 0x00, 0x0004);
+	reg_w(dev, 0x03, 0x00, 0x0003);
+	reg_w(dev, 0x03, 0x00, 0x0004);
+	reg_w(dev, 0x03, 0xFF, 0x0003);
+	reg_w(dev, 0x02, 0x00, 0x0000);
+	reg_w(dev, 0x03, 0x60, 0x0000);
+	reg_w(dev, 0x03, 0x18, 0x0001);
+
+	/*sdca506_WriteI2c(value,register) */
+	spca506_Initi2c(gspca_dev);
+	spca506_WriteI2c(gspca_dev, 0x08, 0x01);	/* Increment Delay */
+/*	spca506_WriteI2c(gspca_dev, 0xc0, 0x02); * Analog Input Control 1 */
+	spca506_WriteI2c(gspca_dev, 0x33, 0x03);
+						/* Analog Input Control 2 */
+	spca506_WriteI2c(gspca_dev, 0x00, 0x04);
+						/* Analog Input Control 3 */
+	spca506_WriteI2c(gspca_dev, 0x00, 0x05);
+						/* Analog Input Control 4 */
+	spca506_WriteI2c(gspca_dev, 0x0d, 0x06);
+					/* Horizontal Sync Start 0xe9-0x0d */
+	spca506_WriteI2c(gspca_dev, 0xf0, 0x07);
+					/* Horizontal Sync Stop  0x0d-0xf0 */
+
+	spca506_WriteI2c(gspca_dev, 0x98, 0x08);	/* Sync Control */
+/*		Defaults value			*/
+	spca506_WriteI2c(gspca_dev, 0x03, 0x09);	/* Luminance Control */
+	spca506_WriteI2c(gspca_dev, 0x80, 0x0a);
+						/* Luminance Brightness */
+	spca506_WriteI2c(gspca_dev, 0x47, 0x0b);	/* Luminance Contrast */
+	spca506_WriteI2c(gspca_dev, 0x48, 0x0c);
+						/* Chrominance Saturation */
+	spca506_WriteI2c(gspca_dev, 0x00, 0x0d);
+						/* Chrominance Hue Control */
+	spca506_WriteI2c(gspca_dev, 0x2a, 0x0f);
+						/* Chrominance Gain Control */
+	/**************************************/
+	spca506_WriteI2c(gspca_dev, 0x00, 0x10);
+						/* Format/Delay Control */
+	spca506_WriteI2c(gspca_dev, 0x0c, 0x11);	/* Output Control 1 */
+	spca506_WriteI2c(gspca_dev, 0xb8, 0x12);	/* Output Control 2 */
+	spca506_WriteI2c(gspca_dev, 0x01, 0x13);	/* Output Control 3 */
+	spca506_WriteI2c(gspca_dev, 0x00, 0x14);	/* reserved */
+	spca506_WriteI2c(gspca_dev, 0x00, 0x15);	/* VGATE START */
+	spca506_WriteI2c(gspca_dev, 0x00, 0x16);	/* VGATE STOP */
+	spca506_WriteI2c(gspca_dev, 0x00, 0x17);    /* VGATE Control (MSB) */
+	spca506_WriteI2c(gspca_dev, 0x00, 0x18);
+	spca506_WriteI2c(gspca_dev, 0x00, 0x19);
+	spca506_WriteI2c(gspca_dev, 0x00, 0x1a);
+	spca506_WriteI2c(gspca_dev, 0x00, 0x1b);
+	spca506_WriteI2c(gspca_dev, 0x00, 0x1c);
+	spca506_WriteI2c(gspca_dev, 0x00, 0x1d);
+	spca506_WriteI2c(gspca_dev, 0x00, 0x1e);
+	spca506_WriteI2c(gspca_dev, 0xa1, 0x1f);
+	spca506_WriteI2c(gspca_dev, 0x02, 0x40);
+	spca506_WriteI2c(gspca_dev, 0xff, 0x41);
+	spca506_WriteI2c(gspca_dev, 0xff, 0x42);
+	spca506_WriteI2c(gspca_dev, 0xff, 0x43);
+	spca506_WriteI2c(gspca_dev, 0xff, 0x44);
+	spca506_WriteI2c(gspca_dev, 0xff, 0x45);
+	spca506_WriteI2c(gspca_dev, 0xff, 0x46);
+	spca506_WriteI2c(gspca_dev, 0xff, 0x47);
+	spca506_WriteI2c(gspca_dev, 0xff, 0x48);
+	spca506_WriteI2c(gspca_dev, 0xff, 0x49);
+	spca506_WriteI2c(gspca_dev, 0xff, 0x4a);
+	spca506_WriteI2c(gspca_dev, 0xff, 0x4b);
+	spca506_WriteI2c(gspca_dev, 0xff, 0x4c);
+	spca506_WriteI2c(gspca_dev, 0xff, 0x4d);
+	spca506_WriteI2c(gspca_dev, 0xff, 0x4e);
+	spca506_WriteI2c(gspca_dev, 0xff, 0x4f);
+	spca506_WriteI2c(gspca_dev, 0xff, 0x50);
+	spca506_WriteI2c(gspca_dev, 0xff, 0x51);
+	spca506_WriteI2c(gspca_dev, 0xff, 0x52);
+	spca506_WriteI2c(gspca_dev, 0xff, 0x53);
+	spca506_WriteI2c(gspca_dev, 0xff, 0x54);
+	spca506_WriteI2c(gspca_dev, 0xff, 0x55);
+	spca506_WriteI2c(gspca_dev, 0xff, 0x56);
+	spca506_WriteI2c(gspca_dev, 0xff, 0x57);
+	spca506_WriteI2c(gspca_dev, 0x00, 0x58);
+	spca506_WriteI2c(gspca_dev, 0x54, 0x59);
+	spca506_WriteI2c(gspca_dev, 0x07, 0x5a);
+	spca506_WriteI2c(gspca_dev, 0x83, 0x5b);
+	spca506_WriteI2c(gspca_dev, 0x00, 0x5c);
+	spca506_WriteI2c(gspca_dev, 0x00, 0x5d);
+	spca506_WriteI2c(gspca_dev, 0x00, 0x5e);
+	spca506_WriteI2c(gspca_dev, 0x00, 0x5f);
+	spca506_WriteI2c(gspca_dev, 0x00, 0x60);
+	spca506_WriteI2c(gspca_dev, 0x05, 0x61);
+	spca506_WriteI2c(gspca_dev, 0x9f, 0x62);
+	/**************************************/
+	reg_w(dev, 0x05, 0x00, 0x0003);
+	reg_w(dev, 0x05, 0x00, 0x0004);
+	reg_w(dev, 0x03, 0x10, 0x0001);
+	reg_w(dev, 0x03, 0x78, 0x0000);
+	switch (gspca_dev->cam.cam_mode[(int) gspca_dev->curr_mode].priv) {
+	case 0:
+		spca506_Setsize(gspca_dev, 0, 0x10, 0x10);
+		break;
+	case 1:
+		spca506_Setsize(gspca_dev, 1, 0x1a, 0x1a);
+		break;
+	case 2:
+		spca506_Setsize(gspca_dev, 2, 0x1c, 0x1c);
+		break;
+	case 4:
+		spca506_Setsize(gspca_dev, 4, 0x34, 0x34);
+		break;
+	default:
+/*	case 5: */
+		spca506_Setsize(gspca_dev, 5, 0x40, 0x40);
+		break;
+	}
+
+	/* compress setting and size */
+	/* set i2c luma */
+	reg_w(dev, 0x02, 0x01, 0x0000);
+	reg_w(dev, 0x03, 0x12, 0x0000);
+	reg_r(gspca_dev, 0x04, 0x0001, 2);
+	PDEBUG(D_STREAM, "webcam started");
+	spca506_GetNormeInput(gspca_dev, &norme, &channel);
+	spca506_SetNormeInput(gspca_dev, norme, channel);
+	return 0;
+}
+
+static void sd_stopN(struct gspca_dev *gspca_dev)
+{
+	struct usb_device *dev = gspca_dev->dev;
+
+	reg_w(dev, 0x02, 0x00, 0x0000);
+	reg_w(dev, 0x03, 0x00, 0x0004);
+	reg_w(dev, 0x03, 0x00, 0x0003);
+}
+
+static void sd_pkt_scan(struct gspca_dev *gspca_dev,
+			u8 *data,			/* isoc packet */
+			int len)			/* iso packet length */
+{
+	switch (data[0]) {
+	case 0:				/* start of frame */
+		gspca_frame_add(gspca_dev, LAST_PACKET, NULL, 0);
+		data += SPCA50X_OFFSET_DATA;
+		len -= SPCA50X_OFFSET_DATA;
+		gspca_frame_add(gspca_dev, FIRST_PACKET, data, len);
+		break;
+	case 0xff:			/* drop */
+/*		gspca_dev->last_packet_type = DISCARD_PACKET; */
+		break;
+	default:
+		data += 1;
+		len -= 1;
+		gspca_frame_add(gspca_dev, INTER_PACKET, data, len);
+		break;
+	}
+}
+
+static void setbrightness(struct gspca_dev *gspca_dev, s32 val)
+{
+	spca506_Initi2c(gspca_dev);
+	spca506_WriteI2c(gspca_dev, val, SAA7113_bright);
+	spca506_WriteI2c(gspca_dev, 0x01, 0x09);
+}
+
+static void setcontrast(struct gspca_dev *gspca_dev, s32 val)
+{
+	spca506_Initi2c(gspca_dev);
+	spca506_WriteI2c(gspca_dev, val, SAA7113_contrast);
+	spca506_WriteI2c(gspca_dev, 0x01, 0x09);
+}
+
+static void setcolors(struct gspca_dev *gspca_dev, s32 val)
+{
+	spca506_Initi2c(gspca_dev);
+	spca506_WriteI2c(gspca_dev, val, SAA7113_saturation);
+	spca506_WriteI2c(gspca_dev, 0x01, 0x09);
+}
+
+static void sethue(struct gspca_dev *gspca_dev, s32 val)
+{
+	spca506_Initi2c(gspca_dev);
+	spca506_WriteI2c(gspca_dev, val, SAA7113_hue);
+	spca506_WriteI2c(gspca_dev, 0x01, 0x09);
+}
+
+static int sd_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct gspca_dev *gspca_dev =
+		container_of(ctrl->handler, struct gspca_dev, ctrl_handler);
+
+	gspca_dev->usb_err = 0;
+
+	if (!gspca_dev->streaming)
+		return 0;
+
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+		setbrightness(gspca_dev, ctrl->val);
+		break;
+	case V4L2_CID_CONTRAST:
+		setcontrast(gspca_dev, ctrl->val);
+		break;
+	case V4L2_CID_SATURATION:
+		setcolors(gspca_dev, ctrl->val);
+		break;
+	case V4L2_CID_HUE:
+		sethue(gspca_dev, ctrl->val);
+		break;
+	}
+	return gspca_dev->usb_err;
+}
+
+static const struct v4l2_ctrl_ops sd_ctrl_ops = {
+	.s_ctrl = sd_s_ctrl,
+};
+
+static int sd_init_controls(struct gspca_dev *gspca_dev)
+{
+	struct v4l2_ctrl_handler *hdl = &gspca_dev->ctrl_handler;
+
+	gspca_dev->vdev.ctrl_handler = hdl;
+	v4l2_ctrl_handler_init(hdl, 4);
+	v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,
+			V4L2_CID_BRIGHTNESS, 0, 255, 1, 128);
+	v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,
+			V4L2_CID_CONTRAST, 0, 255, 1, 0x47);
+	v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,
+			V4L2_CID_SATURATION, 0, 255, 1, 0x40);
+	v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,
+			V4L2_CID_HUE, 0, 255, 1, 0);
+
+	if (hdl->error) {
+		pr_err("Could not initialize controls\n");
+		return hdl->error;
+	}
+	return 0;
+}
+
+/* sub-driver description */
+static const struct sd_desc sd_desc = {
+	.name = MODULE_NAME,
+	.config = sd_config,
+	.init = sd_init,
+	.init_controls = sd_init_controls,
+	.start = sd_start,
+	.stopN = sd_stopN,
+	.pkt_scan = sd_pkt_scan,
+};
+
+/* -- module initialisation -- */
+static const struct usb_device_id device_table[] __devinitconst = {
+	{USB_DEVICE(0x06e1, 0xa190)},
+/*fixme: may be IntelPCCameraPro BRIDGE_SPCA505
+	{USB_DEVICE(0x0733, 0x0430)}, */
+	{USB_DEVICE(0x0734, 0x043b)},
+	{USB_DEVICE(0x99fa, 0x8988)},
+	{}
+};
+MODULE_DEVICE_TABLE(usb, device_table);
+
+/* -- device connect -- */
+static int __devinit sd_probe(struct usb_interface *intf,
+			const struct usb_device_id *id)
+{
+	return gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),
+				THIS_MODULE);
+}
+
+static struct usb_driver sd_driver = {
+	.name = MODULE_NAME,
+	.id_table = device_table,
+	.probe = sd_probe,
+	.disconnect = gspca_disconnect,
+#ifdef CONFIG_PM
+	.suspend = gspca_suspend,
+	.resume = gspca_resume,
+	.reset_resume = gspca_resume,
+#endif
+};
+
+module_usb_driver(sd_driver);
