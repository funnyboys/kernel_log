commit 3e0a4e85803345e31ae2d0009bedf252e43278cb
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu May 23 11:14:55 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 118
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 or at your option any
      later version this program is distributed in the hope that it will
      be useful but without any warranty without even the implied warranty
      of merchantability or fitness for a particular purpose see the gnu
      general public license for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 44 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190523091651.032047323@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/media/usb/as102/as10x_cmd.c b/drivers/media/usb/as102/as10x_cmd.c
index 870617994410..1af69be01866 100644
--- a/drivers/media/usb/as102/as10x_cmd.c
+++ b/drivers/media/usb/as102/as10x_cmd.c
@@ -1,17 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Abilis Systems Single DVB-T Receiver
  * Copyright (C) 2008 Pierrick Hascoet <pierrick.hascoet@abilis.com>
  * Copyright (C) 2010 Devin Heitmueller <dheitmueller@kernellabs.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2, or (at your option)
- * any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
  */
 
 #include <linux/kernel.h>

commit d51a12c962f26fcb859203372fa196c2dfcd5f77
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Wed Sep 24 10:51:35 2014 -0300

    [media] as102: fix endiannes casts
    
    Smatch complains a lot about endiannes issues on as102:
    
    drivers/media/usb/as102/as10x_cmd_stream.c:41:47: warning: incorrect type in assignment (different base types)
    drivers/media/usb/as102/as10x_cmd_stream.c:41:47:    expected unsigned short [unsigned] [usertype] proc_id
    drivers/media/usb/as102/as10x_cmd_stream.c:41:47:    got restricted __le16 [usertype] <noident>
    drivers/media/usb/as102/as10x_cmd_stream.c:43:43: warning: incorrect type in assignment (different base types)
    drivers/media/usb/as102/as10x_cmd_stream.c:43:43:    expected unsigned short [unsigned] [usertype] pid
    drivers/media/usb/as102/as10x_cmd_stream.c:43:43:    got restricted __le16 [usertype] <noident>
    drivers/media/usb/as102/as10x_cmd_stream.c:98:47: warning: incorrect type in assignment (different base types)
    drivers/media/usb/as102/as10x_cmd_stream.c:98:47:    expected unsigned short [unsigned] [usertype] proc_id
    drivers/media/usb/as102/as10x_cmd_stream.c:98:47:    got restricted __le16 [usertype] <noident>
    drivers/media/usb/as102/as10x_cmd_stream.c:100:43: warning: incorrect type in assignment (different base types)
    drivers/media/usb/as102/as10x_cmd_stream.c:100:43:    expected unsigned short [unsigned] [usertype] pid
    drivers/media/usb/as102/as10x_cmd_stream.c:100:43:    got restricted __le16 [usertype] <noident>
    drivers/media/usb/as102/as10x_cmd_stream.c:142:48: warning: incorrect type in assignment (different base types)
    drivers/media/usb/as102/as10x_cmd_stream.c:142:48:    expected unsigned short [unsigned] [usertype] proc_id
    drivers/media/usb/as102/as10x_cmd_stream.c:142:48:    got restricted __le16 [usertype] <noident>
    drivers/media/usb/as102/as10x_cmd_stream.c:185:47: warning: incorrect type in assignment (different base types)
    drivers/media/usb/as102/as10x_cmd_stream.c:185:47:    expected unsigned short [unsigned] [usertype] proc_id
    drivers/media/usb/as102/as10x_cmd_stream.c:185:47:    got restricted __le16 [usertype] <noident>
    drivers/media/usb/as102/as10x_cmd_cfg.c:46:40: warning: incorrect type in assignment (different base types)
    drivers/media/usb/as102/as10x_cmd_cfg.c:46:40:    expected unsigned short [unsigned] [usertype] proc_id
    drivers/media/usb/as102/as10x_cmd_cfg.c:46:40:    got restricted __le16 [usertype] <noident>
    drivers/media/usb/as102/as10x_cmd_cfg.c:47:36: warning: incorrect type in assignment (different base types)
    drivers/media/usb/as102/as10x_cmd_cfg.c:47:36:    expected unsigned short [unsigned] [usertype] tag
    drivers/media/usb/as102/as10x_cmd_cfg.c:47:36:    got restricted __le16 [usertype] <noident>
    drivers/media/usb/as102/as10x_cmd_cfg.c:48:37: warning: incorrect type in assignment (different base types)
    drivers/media/usb/as102/as10x_cmd_cfg.c:48:37:    expected unsigned short [unsigned] [usertype] type
    drivers/media/usb/as102/as10x_cmd_cfg.c:48:37:    got restricted __le16 [usertype] <noident>
    drivers/media/usb/as102/as10x_cmd_cfg.c:72:27: warning: cast to restricted __le32
    drivers/media/usb/as102/as10x_cmd_cfg.c:102:40: warning: incorrect type in assignment (different base types)
    drivers/media/usb/as102/as10x_cmd_cfg.c:102:40:    expected unsigned short [unsigned] [usertype] proc_id
    drivers/media/usb/as102/as10x_cmd_cfg.c:102:40:    got restricted __le16 [usertype] <noident>
    drivers/media/usb/as102/as10x_cmd_cfg.c:104:50: warning: incorrect type in assignment (different base types)
    drivers/media/usb/as102/as10x_cmd_cfg.c:104:50:    expected unsigned int [unsigned] [usertype] value32
    drivers/media/usb/as102/as10x_cmd_cfg.c:104:50:    got restricted __le32 [usertype] <noident>
    drivers/media/usb/as102/as10x_cmd_cfg.c:105:36: warning: incorrect type in assignment (different base types)
    drivers/media/usb/as102/as10x_cmd_cfg.c:105:36:    expected unsigned short [unsigned] [usertype] tag
    drivers/media/usb/as102/as10x_cmd_cfg.c:105:36:    got restricted __le16 [usertype] <noident>
    drivers/media/usb/as102/as10x_cmd_cfg.c:106:37: warning: incorrect type in assignment (different base types)
    drivers/media/usb/as102/as10x_cmd_cfg.c:106:37:    expected unsigned short [unsigned] [usertype] type
    drivers/media/usb/as102/as10x_cmd_cfg.c:106:37:    got restricted __le16 [usertype] <noident>
    drivers/media/usb/as102/as10x_cmd_cfg.c:156:48: warning: incorrect type in assignment (different base types)
    drivers/media/usb/as102/as10x_cmd_cfg.c:156:48:    expected unsigned short [unsigned] [usertype] proc_id
    drivers/media/usb/as102/as10x_cmd_cfg.c:156:48:    got restricted __le16 [usertype] <noident>
    drivers/media/usb/as102/as10x_cmd_cfg.c:197:14: warning: cast to restricted __le16
    drivers/media/usb/as102/as10x_cmd.c:40:40: warning: incorrect type in assignment (different base types)
    drivers/media/usb/as102/as10x_cmd.c:40:40:    expected unsigned short [unsigned] [usertype] proc_id
    drivers/media/usb/as102/as10x_cmd.c:40:40:    got restricted __le16 [usertype] <noident>
    drivers/media/usb/as102/as10x_cmd.c:81:41: warning: incorrect type in assignment (different base types)
    drivers/media/usb/as102/as10x_cmd.c:81:41:    expected unsigned short [unsigned] [usertype] proc_id
    drivers/media/usb/as102/as10x_cmd.c:81:41:    got restricted __le16 [usertype] <noident>
    drivers/media/usb/as102/as10x_cmd.c:123:41: warning: incorrect type in assignment (different base types)
    drivers/media/usb/as102/as10x_cmd.c:123:41:    expected unsigned short [unsigned] [usertype] proc_id
    drivers/media/usb/as102/as10x_cmd.c:123:41:    got restricted __le16 [usertype] <noident>
    drivers/media/usb/as102/as10x_cmd.c:124:43: warning: incorrect type in assignment (different base types)
    drivers/media/usb/as102/as10x_cmd.c:124:43:    expected unsigned int [unsigned] [usertype] freq
    drivers/media/usb/as102/as10x_cmd.c:124:43:    got restricted __le32 [usertype] <noident>
    drivers/media/usb/as102/as10x_cmd.c:178:48: warning: incorrect type in assignment (different base types)
    drivers/media/usb/as102/as10x_cmd.c:178:48:    expected unsigned short [unsigned] [usertype] proc_id
    drivers/media/usb/as102/as10x_cmd.c:178:48:    got restricted __le16 [usertype] <noident>
    drivers/media/usb/as102/as10x_cmd.c:202:17: warning: cast to restricted __le16
    drivers/media/usb/as102/as10x_cmd.c:203:24: warning: cast to restricted __le16
    drivers/media/usb/as102/as10x_cmd.c:204:24: warning: cast to restricted __le16
    drivers/media/usb/as102/as10x_cmd.c:230:48: warning: incorrect type in assignment (different base types)
    drivers/media/usb/as102/as10x_cmd.c:230:48:    expected unsigned short [unsigned] [usertype] proc_id
    drivers/media/usb/as102/as10x_cmd.c:230:48:    got restricted __le16 [usertype] <noident>
    drivers/media/usb/as102/as10x_cmd.c:262:25: warning: cast to restricted __le16
    drivers/media/usb/as102/as10x_cmd.c:289:48: warning: incorrect type in assignment (different base types)
    drivers/media/usb/as102/as10x_cmd.c:289:48:    expected unsigned short [unsigned] [usertype] proc_id
    drivers/media/usb/as102/as10x_cmd.c:289:48:    got restricted __le16 [usertype] <noident>
    drivers/media/usb/as102/as10x_cmd.c:313:17: warning: cast to restricted __le32
    drivers/media/usb/as102/as10x_cmd.c:315:17: warning: cast to restricted __le32
    drivers/media/usb/as102/as10x_cmd.c:317:17: warning: cast to restricted __le32
    drivers/media/usb/as102/as10x_cmd.c:319:17: warning: cast to restricted __le16
    drivers/media/usb/as102/as10x_cmd.c:349:48: warning: incorrect type in assignment (different base types)
    drivers/media/usb/as102/as10x_cmd.c:349:48:    expected unsigned short [unsigned] [usertype] proc_id
    drivers/media/usb/as102/as10x_cmd.c:349:48:    got restricted __le16 [usertype] <noident>
    drivers/media/usb/as102/as10x_cmd.c:387:29: warning: incorrect type in assignment (different base types)
    drivers/media/usb/as102/as10x_cmd.c:387:29:    expected unsigned short [unsigned] [usertype] req_id
    drivers/media/usb/as102/as10x_cmd.c:387:29:    got restricted __le16 [usertype] <noident>
    drivers/media/usb/as102/as10x_cmd.c:388:27: warning: incorrect type in assignment (different base types)
    drivers/media/usb/as102/as10x_cmd.c:388:27:    expected unsigned short [unsigned] [usertype] prog
    drivers/media/usb/as102/as10x_cmd.c:388:27:    got restricted __le16 [usertype] <noident>
    drivers/media/usb/as102/as10x_cmd.c:389:30: warning: incorrect type in assignment (different base types)
    drivers/media/usb/as102/as10x_cmd.c:389:30:    expected unsigned short [unsigned] [usertype] version
    drivers/media/usb/as102/as10x_cmd.c:389:30:    got restricted __le16 [usertype] <noident>
    drivers/media/usb/as102/as10x_cmd.c:390:31: warning: incorrect type in assignment (different base types)
    drivers/media/usb/as102/as10x_cmd.c:390:31:    expected unsigned short [unsigned] [usertype] data_len
    drivers/media/usb/as102/as10x_cmd.c:390:31:    got restricted __le16 [usertype] <noident>
    drivers/media/usb/as102/as10x_cmd.c:408:14: warning: cast to restricted __le16
    
    This happens because of the command endiannes that are sent/received to
    the firmware. So, add the correct endiannes tags to the command fields.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/usb/as102/as10x_cmd.c b/drivers/media/usb/as102/as10x_cmd.c
index ef238022dfe5..870617994410 100644
--- a/drivers/media/usb/as102/as10x_cmd.c
+++ b/drivers/media/usb/as102/as10x_cmd.c
@@ -121,7 +121,7 @@ int as10x_cmd_set_tune(struct as10x_bus_adapter_t *adap,
 
 	/* fill command */
 	preq->body.set_tune.req.proc_id = cpu_to_le16(CONTROL_PROC_SETTUNE);
-	preq->body.set_tune.req.args.freq = cpu_to_le32(ptune->freq);
+	preq->body.set_tune.req.args.freq = (__force __u32)cpu_to_le32(ptune->freq);
 	preq->body.set_tune.req.args.bandwidth = ptune->bandwidth;
 	preq->body.set_tune.req.args.hier_select = ptune->hier_select;
 	preq->body.set_tune.req.args.modulation = ptune->modulation;
@@ -199,9 +199,9 @@ int as10x_cmd_get_tune_status(struct as10x_bus_adapter_t *adap,
 	/* Response OK -> get response data */
 	pstatus->tune_state = prsp->body.get_tune_status.rsp.sts.tune_state;
 	pstatus->signal_strength  =
-		le16_to_cpu(prsp->body.get_tune_status.rsp.sts.signal_strength);
-	pstatus->PER = le16_to_cpu(prsp->body.get_tune_status.rsp.sts.PER);
-	pstatus->BER = le16_to_cpu(prsp->body.get_tune_status.rsp.sts.BER);
+		le16_to_cpu((__force __le16)prsp->body.get_tune_status.rsp.sts.signal_strength);
+	pstatus->PER = le16_to_cpu((__force __le16)prsp->body.get_tune_status.rsp.sts.PER);
+	pstatus->BER = le16_to_cpu((__force __le16)prsp->body.get_tune_status.rsp.sts.BER);
 
 out:
 	return error;
@@ -259,7 +259,7 @@ int as10x_cmd_get_tps(struct as10x_bus_adapter_t *adap, struct as10x_tps *ptps)
 	ptps->transmission_mode  = prsp->body.get_tps.rsp.tps.transmission_mode;
 	ptps->DVBH_mask_HP = prsp->body.get_tps.rsp.tps.DVBH_mask_HP;
 	ptps->DVBH_mask_LP = prsp->body.get_tps.rsp.tps.DVBH_mask_LP;
-	ptps->cell_ID = le16_to_cpu(prsp->body.get_tps.rsp.tps.cell_ID);
+	ptps->cell_ID = le16_to_cpu((__force __le16)prsp->body.get_tps.rsp.tps.cell_ID);
 
 out:
 	return error;
@@ -310,13 +310,13 @@ int as10x_cmd_get_demod_stats(struct as10x_bus_adapter_t *adap,
 
 	/* Response OK -> get response data */
 	pdemod_stats->frame_count =
-		le32_to_cpu(prsp->body.get_demod_stats.rsp.stats.frame_count);
+		le32_to_cpu((__force __le32)prsp->body.get_demod_stats.rsp.stats.frame_count);
 	pdemod_stats->bad_frame_count =
-		le32_to_cpu(prsp->body.get_demod_stats.rsp.stats.bad_frame_count);
+		le32_to_cpu((__force __le32)prsp->body.get_demod_stats.rsp.stats.bad_frame_count);
 	pdemod_stats->bytes_fixed_by_rs =
-		le32_to_cpu(prsp->body.get_demod_stats.rsp.stats.bytes_fixed_by_rs);
+		le32_to_cpu((__force __le32)prsp->body.get_demod_stats.rsp.stats.bytes_fixed_by_rs);
 	pdemod_stats->mer =
-		le16_to_cpu(prsp->body.get_demod_stats.rsp.stats.mer);
+		le16_to_cpu((__force __le16)prsp->body.get_demod_stats.rsp.stats.mer);
 	pdemod_stats->has_started =
 		prsp->body.get_demod_stats.rsp.stats.has_started;
 

commit dcae77814865122ed411de1a4e8ebd02796cf3c4
Author: Mauro Carvalho Chehab <m.chehab@samsung.com>
Date:   Tue Aug 12 18:50:23 2014 -0300

    [media] as102-fe: make it an independent driver
    
    Move as102-fe to dvb-frontends directory and make it an
    independent driver.
    
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/drivers/media/usb/as102/as10x_cmd.c b/drivers/media/usb/as102/as10x_cmd.c
index 8868c52500ee..ef238022dfe5 100644
--- a/drivers/media/usb/as102/as10x_cmd.c
+++ b/drivers/media/usb/as102/as10x_cmd.c
@@ -16,7 +16,6 @@
 
 #include <linux/kernel.h>
 #include "as102_drv.h"
-#include "as10x_types.h"
 #include "as10x_cmd.h"
 
 /**

commit 1f2563d68cce0d45b81a47894c135f65f192b1a9
Author: Mauro Carvalho Chehab <m.chehab@samsung.com>
Date:   Tue Aug 12 18:50:16 2014 -0300

    [media] as102: get rid of FSF mail address
    
    Make checkpatch happier by removing FSF mail address.
    
    No functional changes.
    
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/drivers/media/usb/as102/as10x_cmd.c b/drivers/media/usb/as102/as10x_cmd.c
index 9e49f15a7c9f..8868c52500ee 100644
--- a/drivers/media/usb/as102/as10x_cmd.c
+++ b/drivers/media/usb/as102/as10x_cmd.c
@@ -12,10 +12,6 @@
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
 #include <linux/kernel.h>

commit d6317c68f3324e086799e12e4864231bb71829cb
Author: Mauro Carvalho Chehab <m.chehab@samsung.com>
Date:   Tue Aug 12 18:50:15 2014 -0300

    [media] as102: promote it out of staging
    
    This driver is stable and doesn't contain any really serious
    issue. Move it out of staging.
    
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/drivers/media/usb/as102/as10x_cmd.c b/drivers/media/usb/as102/as10x_cmd.c
new file mode 100644
index 000000000000..9e49f15a7c9f
--- /dev/null
+++ b/drivers/media/usb/as102/as10x_cmd.c
@@ -0,0 +1,418 @@
+/*
+ * Abilis Systems Single DVB-T Receiver
+ * Copyright (C) 2008 Pierrick Hascoet <pierrick.hascoet@abilis.com>
+ * Copyright (C) 2010 Devin Heitmueller <dheitmueller@kernellabs.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/kernel.h>
+#include "as102_drv.h"
+#include "as10x_types.h"
+#include "as10x_cmd.h"
+
+/**
+ * as10x_cmd_turn_on - send turn on command to AS10x
+ * @adap:   pointer to AS10x bus adapter
+ *
+ * Return 0 when no error, < 0 in case of error.
+ */
+int as10x_cmd_turn_on(struct as10x_bus_adapter_t *adap)
+{
+	int error = AS10X_CMD_ERROR;
+	struct as10x_cmd_t *pcmd, *prsp;
+
+	pcmd = adap->cmd;
+	prsp = adap->rsp;
+
+	/* prepare command */
+	as10x_cmd_build(pcmd, (++adap->cmd_xid),
+			sizeof(pcmd->body.turn_on.req));
+
+	/* fill command */
+	pcmd->body.turn_on.req.proc_id = cpu_to_le16(CONTROL_PROC_TURNON);
+
+	/* send command */
+	if (adap->ops->xfer_cmd) {
+		error = adap->ops->xfer_cmd(adap, (uint8_t *) pcmd,
+					    sizeof(pcmd->body.turn_on.req) +
+					    HEADER_SIZE,
+					    (uint8_t *) prsp,
+					    sizeof(prsp->body.turn_on.rsp) +
+					    HEADER_SIZE);
+	}
+
+	if (error < 0)
+		goto out;
+
+	/* parse response */
+	error = as10x_rsp_parse(prsp, CONTROL_PROC_TURNON_RSP);
+
+out:
+	return error;
+}
+
+/**
+ * as10x_cmd_turn_off - send turn off command to AS10x
+ * @adap:   pointer to AS10x bus adapter
+ *
+ * Return 0 on success or negative value in case of error.
+ */
+int as10x_cmd_turn_off(struct as10x_bus_adapter_t *adap)
+{
+	int error = AS10X_CMD_ERROR;
+	struct as10x_cmd_t *pcmd, *prsp;
+
+	pcmd = adap->cmd;
+	prsp = adap->rsp;
+
+	/* prepare command */
+	as10x_cmd_build(pcmd, (++adap->cmd_xid),
+			sizeof(pcmd->body.turn_off.req));
+
+	/* fill command */
+	pcmd->body.turn_off.req.proc_id = cpu_to_le16(CONTROL_PROC_TURNOFF);
+
+	/* send command */
+	if (adap->ops->xfer_cmd) {
+		error = adap->ops->xfer_cmd(
+			adap, (uint8_t *) pcmd,
+			sizeof(pcmd->body.turn_off.req) + HEADER_SIZE,
+			(uint8_t *) prsp,
+			sizeof(prsp->body.turn_off.rsp) + HEADER_SIZE);
+	}
+
+	if (error < 0)
+		goto out;
+
+	/* parse response */
+	error = as10x_rsp_parse(prsp, CONTROL_PROC_TURNOFF_RSP);
+
+out:
+	return error;
+}
+
+/**
+ * as10x_cmd_set_tune - send set tune command to AS10x
+ * @adap:    pointer to AS10x bus adapter
+ * @ptune:   tune parameters
+ *
+ * Return 0 on success or negative value in case of error.
+ */
+int as10x_cmd_set_tune(struct as10x_bus_adapter_t *adap,
+		       struct as10x_tune_args *ptune)
+{
+	int error = AS10X_CMD_ERROR;
+	struct as10x_cmd_t *preq, *prsp;
+
+	preq = adap->cmd;
+	prsp = adap->rsp;
+
+	/* prepare command */
+	as10x_cmd_build(preq, (++adap->cmd_xid),
+			sizeof(preq->body.set_tune.req));
+
+	/* fill command */
+	preq->body.set_tune.req.proc_id = cpu_to_le16(CONTROL_PROC_SETTUNE);
+	preq->body.set_tune.req.args.freq = cpu_to_le32(ptune->freq);
+	preq->body.set_tune.req.args.bandwidth = ptune->bandwidth;
+	preq->body.set_tune.req.args.hier_select = ptune->hier_select;
+	preq->body.set_tune.req.args.modulation = ptune->modulation;
+	preq->body.set_tune.req.args.hierarchy = ptune->hierarchy;
+	preq->body.set_tune.req.args.interleaving_mode  =
+		ptune->interleaving_mode;
+	preq->body.set_tune.req.args.code_rate  = ptune->code_rate;
+	preq->body.set_tune.req.args.guard_interval = ptune->guard_interval;
+	preq->body.set_tune.req.args.transmission_mode  =
+		ptune->transmission_mode;
+
+	/* send command */
+	if (adap->ops->xfer_cmd) {
+		error = adap->ops->xfer_cmd(adap,
+					    (uint8_t *) preq,
+					    sizeof(preq->body.set_tune.req)
+					    + HEADER_SIZE,
+					    (uint8_t *) prsp,
+					    sizeof(prsp->body.set_tune.rsp)
+					    + HEADER_SIZE);
+	}
+
+	if (error < 0)
+		goto out;
+
+	/* parse response */
+	error = as10x_rsp_parse(prsp, CONTROL_PROC_SETTUNE_RSP);
+
+out:
+	return error;
+}
+
+/**
+ * as10x_cmd_get_tune_status - send get tune status command to AS10x
+ * @adap: pointer to AS10x bus adapter
+ * @pstatus: pointer to updated status structure of the current tune
+ *
+ * Return 0 on success or negative value in case of error.
+ */
+int as10x_cmd_get_tune_status(struct as10x_bus_adapter_t *adap,
+			      struct as10x_tune_status *pstatus)
+{
+	int error = AS10X_CMD_ERROR;
+	struct as10x_cmd_t  *preq, *prsp;
+
+	preq = adap->cmd;
+	prsp = adap->rsp;
+
+	/* prepare command */
+	as10x_cmd_build(preq, (++adap->cmd_xid),
+			sizeof(preq->body.get_tune_status.req));
+
+	/* fill command */
+	preq->body.get_tune_status.req.proc_id =
+		cpu_to_le16(CONTROL_PROC_GETTUNESTAT);
+
+	/* send command */
+	if (adap->ops->xfer_cmd) {
+		error = adap->ops->xfer_cmd(
+			adap,
+			(uint8_t *) preq,
+			sizeof(preq->body.get_tune_status.req) + HEADER_SIZE,
+			(uint8_t *) prsp,
+			sizeof(prsp->body.get_tune_status.rsp) + HEADER_SIZE);
+	}
+
+	if (error < 0)
+		goto out;
+
+	/* parse response */
+	error = as10x_rsp_parse(prsp, CONTROL_PROC_GETTUNESTAT_RSP);
+	if (error < 0)
+		goto out;
+
+	/* Response OK -> get response data */
+	pstatus->tune_state = prsp->body.get_tune_status.rsp.sts.tune_state;
+	pstatus->signal_strength  =
+		le16_to_cpu(prsp->body.get_tune_status.rsp.sts.signal_strength);
+	pstatus->PER = le16_to_cpu(prsp->body.get_tune_status.rsp.sts.PER);
+	pstatus->BER = le16_to_cpu(prsp->body.get_tune_status.rsp.sts.BER);
+
+out:
+	return error;
+}
+
+/**
+ * as10x_cmd_get_tps - send get TPS command to AS10x
+ * @adap:      pointer to AS10x handle
+ * @ptps:      pointer to TPS parameters structure
+ *
+ * Return 0 on success or negative value in case of error.
+ */
+int as10x_cmd_get_tps(struct as10x_bus_adapter_t *adap, struct as10x_tps *ptps)
+{
+	int error = AS10X_CMD_ERROR;
+	struct as10x_cmd_t *pcmd, *prsp;
+
+	pcmd = adap->cmd;
+	prsp = adap->rsp;
+
+	/* prepare command */
+	as10x_cmd_build(pcmd, (++adap->cmd_xid),
+			sizeof(pcmd->body.get_tps.req));
+
+	/* fill command */
+	pcmd->body.get_tune_status.req.proc_id =
+		cpu_to_le16(CONTROL_PROC_GETTPS);
+
+	/* send command */
+	if (adap->ops->xfer_cmd) {
+		error = adap->ops->xfer_cmd(adap,
+					    (uint8_t *) pcmd,
+					    sizeof(pcmd->body.get_tps.req) +
+					    HEADER_SIZE,
+					    (uint8_t *) prsp,
+					    sizeof(prsp->body.get_tps.rsp) +
+					    HEADER_SIZE);
+	}
+
+	if (error < 0)
+		goto out;
+
+	/* parse response */
+	error = as10x_rsp_parse(prsp, CONTROL_PROC_GETTPS_RSP);
+	if (error < 0)
+		goto out;
+
+	/* Response OK -> get response data */
+	ptps->modulation = prsp->body.get_tps.rsp.tps.modulation;
+	ptps->hierarchy = prsp->body.get_tps.rsp.tps.hierarchy;
+	ptps->interleaving_mode = prsp->body.get_tps.rsp.tps.interleaving_mode;
+	ptps->code_rate_HP = prsp->body.get_tps.rsp.tps.code_rate_HP;
+	ptps->code_rate_LP = prsp->body.get_tps.rsp.tps.code_rate_LP;
+	ptps->guard_interval = prsp->body.get_tps.rsp.tps.guard_interval;
+	ptps->transmission_mode  = prsp->body.get_tps.rsp.tps.transmission_mode;
+	ptps->DVBH_mask_HP = prsp->body.get_tps.rsp.tps.DVBH_mask_HP;
+	ptps->DVBH_mask_LP = prsp->body.get_tps.rsp.tps.DVBH_mask_LP;
+	ptps->cell_ID = le16_to_cpu(prsp->body.get_tps.rsp.tps.cell_ID);
+
+out:
+	return error;
+}
+
+/**
+ * as10x_cmd_get_demod_stats - send get demod stats command to AS10x
+ * @adap:          pointer to AS10x bus adapter
+ * @pdemod_stats:  pointer to demod stats parameters structure
+ *
+ * Return 0 on success or negative value in case of error.
+ */
+int as10x_cmd_get_demod_stats(struct as10x_bus_adapter_t *adap,
+			      struct as10x_demod_stats *pdemod_stats)
+{
+	int error = AS10X_CMD_ERROR;
+	struct as10x_cmd_t *pcmd, *prsp;
+
+	pcmd = adap->cmd;
+	prsp = adap->rsp;
+
+	/* prepare command */
+	as10x_cmd_build(pcmd, (++adap->cmd_xid),
+			sizeof(pcmd->body.get_demod_stats.req));
+
+	/* fill command */
+	pcmd->body.get_demod_stats.req.proc_id =
+		cpu_to_le16(CONTROL_PROC_GET_DEMOD_STATS);
+
+	/* send command */
+	if (adap->ops->xfer_cmd) {
+		error = adap->ops->xfer_cmd(adap,
+				(uint8_t *) pcmd,
+				sizeof(pcmd->body.get_demod_stats.req)
+				+ HEADER_SIZE,
+				(uint8_t *) prsp,
+				sizeof(prsp->body.get_demod_stats.rsp)
+				+ HEADER_SIZE);
+	}
+
+	if (error < 0)
+		goto out;
+
+	/* parse response */
+	error = as10x_rsp_parse(prsp, CONTROL_PROC_GET_DEMOD_STATS_RSP);
+	if (error < 0)
+		goto out;
+
+	/* Response OK -> get response data */
+	pdemod_stats->frame_count =
+		le32_to_cpu(prsp->body.get_demod_stats.rsp.stats.frame_count);
+	pdemod_stats->bad_frame_count =
+		le32_to_cpu(prsp->body.get_demod_stats.rsp.stats.bad_frame_count);
+	pdemod_stats->bytes_fixed_by_rs =
+		le32_to_cpu(prsp->body.get_demod_stats.rsp.stats.bytes_fixed_by_rs);
+	pdemod_stats->mer =
+		le16_to_cpu(prsp->body.get_demod_stats.rsp.stats.mer);
+	pdemod_stats->has_started =
+		prsp->body.get_demod_stats.rsp.stats.has_started;
+
+out:
+	return error;
+}
+
+/**
+ * as10x_cmd_get_impulse_resp - send get impulse response command to AS10x
+ * @adap:     pointer to AS10x bus adapter
+ * @is_ready: pointer to value indicating when impulse
+ *	      response data is ready
+ *
+ * Return 0 on success or negative value in case of error.
+ */
+int as10x_cmd_get_impulse_resp(struct as10x_bus_adapter_t *adap,
+			       uint8_t *is_ready)
+{
+	int error = AS10X_CMD_ERROR;
+	struct as10x_cmd_t *pcmd, *prsp;
+
+	pcmd = adap->cmd;
+	prsp = adap->rsp;
+
+	/* prepare command */
+	as10x_cmd_build(pcmd, (++adap->cmd_xid),
+			sizeof(pcmd->body.get_impulse_rsp.req));
+
+	/* fill command */
+	pcmd->body.get_impulse_rsp.req.proc_id =
+		cpu_to_le16(CONTROL_PROC_GET_IMPULSE_RESP);
+
+	/* send command */
+	if (adap->ops->xfer_cmd) {
+		error = adap->ops->xfer_cmd(adap,
+					(uint8_t *) pcmd,
+					sizeof(pcmd->body.get_impulse_rsp.req)
+					+ HEADER_SIZE,
+					(uint8_t *) prsp,
+					sizeof(prsp->body.get_impulse_rsp.rsp)
+					+ HEADER_SIZE);
+	}
+
+	if (error < 0)
+		goto out;
+
+	/* parse response */
+	error = as10x_rsp_parse(prsp, CONTROL_PROC_GET_IMPULSE_RESP_RSP);
+	if (error < 0)
+		goto out;
+
+	/* Response OK -> get response data */
+	*is_ready = prsp->body.get_impulse_rsp.rsp.is_ready;
+
+out:
+	return error;
+}
+
+/**
+ * as10x_cmd_build - build AS10x command header
+ * @pcmd:     pointer to AS10x command buffer
+ * @xid:      sequence id of the command
+ * @cmd_len:  length of the command
+ */
+void as10x_cmd_build(struct as10x_cmd_t *pcmd,
+		     uint16_t xid, uint16_t cmd_len)
+{
+	pcmd->header.req_id = cpu_to_le16(xid);
+	pcmd->header.prog = cpu_to_le16(SERVICE_PROG_ID);
+	pcmd->header.version = cpu_to_le16(SERVICE_PROG_VERSION);
+	pcmd->header.data_len = cpu_to_le16(cmd_len);
+}
+
+/**
+ * as10x_rsp_parse - Parse command response
+ * @prsp:       pointer to AS10x command buffer
+ * @proc_id:    id of the command
+ *
+ * Return 0 on success or negative value in case of error.
+ */
+int as10x_rsp_parse(struct as10x_cmd_t *prsp, uint16_t proc_id)
+{
+	int error;
+
+	/* extract command error code */
+	error = prsp->body.common.rsp.error;
+
+	if ((error == 0) &&
+	    (le16_to_cpu(prsp->body.common.rsp.proc_id) == proc_id)) {
+		return 0;
+	}
+
+	return AS10X_CMD_ERROR;
+}
