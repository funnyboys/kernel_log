commit 0cd25448a198677d4ccd25ec4aeb946d514b1d5b
Author: Hans Verkuil <hverkuil-cisco@xs4all.nl>
Date:   Thu Feb 28 07:35:45 2019 -0500

    media: cobalt: replace VB2_BUF_STATE_REQUEUEING by _ERROR
    
    The cobalt driver is the only driver that uses VB2_BUF_STATE_REQUEUEING.
    Replace it by VB2_BUF_STATE_ERROR so we can drop support for the
    REQUEUEING state.
    
    The requeueing state was used in the cobalt driver to optimize
    buffer handling while waiting for a valid signal: by requeueing
    buffers internally there was no need for userspace to handle and
    requeue buffers with the ERROR flag set.
    
    However, requeueing also makes the buffer handling unordered, which
    is generally a bad idea. Requeueing also does not work with requests
    and any future fence support.
    
    Since it is really a minor optimization in the cobalt driver it is
    best to just return the buffer in an ERROR state. With this change
    support for requeueing can now be removed in vb2.
    
    Signed-off-by: Hans Verkuil <hverkuil-cisco@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/pci/cobalt/cobalt-irq.c b/drivers/media/pci/cobalt/cobalt-irq.c
index 04783e78cc12..a518927abae1 100644
--- a/drivers/media/pci/cobalt/cobalt-irq.c
+++ b/drivers/media/pci/cobalt/cobalt-irq.c
@@ -128,7 +128,7 @@ static void cobalt_dma_stream_queue_handler(struct cobalt_stream *s)
 	cb->vb.sequence = s->sequence++;
 	vb2_buffer_done(&cb->vb.vb2_buf,
 			(skip || s->unstable_frame) ?
-			VB2_BUF_STATE_REQUEUEING : VB2_BUF_STATE_DONE);
+			VB2_BUF_STATE_ERROR : VB2_BUF_STATE_DONE);
 }
 
 irqreturn_t cobalt_irq_handler(int irq, void *dev_id)

commit 6884db3c5f99793fef57f53a2897c0b744651d71
Author: Hans Verkuil <hansverk@cisco.com>
Date:   Wed Feb 7 09:27:12 2018 -0500

    media: cobalt: add SPDX license info
    
    Replace the old license information with the corresponding SPDX
    license.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/pci/cobalt/cobalt-irq.c b/drivers/media/pci/cobalt/cobalt-irq.c
index b190d4f81c6e..04783e78cc12 100644
--- a/drivers/media/pci/cobalt/cobalt-irq.c
+++ b/drivers/media/pci/cobalt/cobalt-irq.c
@@ -1,21 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  *  cobalt interrupt handling
  *
  *  Copyright 2012-2015 Cisco Systems, Inc. and/or its affiliates.
  *  All rights reserved.
- *
- *  This program is free software; you may redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; version 2 of the License.
- *
- *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- *  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- *  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- *  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
- *  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
- *  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- *  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- *  SOFTWARE.
  */
 
 #include <media/i2c/adv7604.h>

commit d6dd645eae76eeb42cb47d9da69cd3f56b3f2cb6
Author: Junghak Sung <jh1009.sung@samsung.com>
Date:   Tue Nov 3 08:16:37 2015 -0200

    [media] media: videobuf2: Move timestamp to vb2_buffer
    
    Move timestamp from struct vb2_v4l2_buffer to struct vb2_buffer
    for common use, and change its type to u64 in order to handling
    y2038 problem. This patch also includes all device drivers' changes related to
    this restructuring.
    
    Signed-off-by: Junghak Sung <jh1009.sung@samsung.com>
    Signed-off-by: Geunyoung Kim <nenggun.kim@samsung.com>
    Acked-by: Seung-Woo Kim <sw0312.kim@samsung.com>
    Acked-by: Inki Dae <inki.dae@samsung.com>
    Signed-off-by: Hans Verkuil <hansverk@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/pci/cobalt/cobalt-irq.c b/drivers/media/pci/cobalt/cobalt-irq.c
index c30748e76164..b190d4f81c6e 100644
--- a/drivers/media/pci/cobalt/cobalt-irq.c
+++ b/drivers/media/pci/cobalt/cobalt-irq.c
@@ -134,7 +134,7 @@ static void cobalt_dma_stream_queue_handler(struct cobalt_stream *s)
 		skip = true;
 		s->skip_first_frames--;
 	}
-	v4l2_get_timestamp(&cb->vb.timestamp);
+	cb->vb.vb2_buf.timestamp = ktime_get_ns();
 	/* TODO: the sequence number should be read from the FPGA so we
 	   also know about dropped frames. */
 	cb->vb.sequence = s->sequence++;

commit b5dcee225ce972fecb054e104be22b2a6f65303d
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Tue Nov 10 12:01:44 2015 -0200

    [media] include/media: split I2C headers from V4L2 core
    
    Currently, include/media is messy, as it contains both the V4L2 core
    headers and some driver-specific headers on the same place. That makes
    harder to identify what core headers should be documented and what
    headers belong to I2C drivers that are included only by bridge/main
    drivers that would require the functions provided by them.
    
    Let's move those i2c specific files to its own subdirectory.
    
    The files to move were produced via the following script:
            mkdir include/media/i2c
            (cd include/media; for i in *.h; do n=`echo $i|sed s/.h$/.c/`; if [ -e ../../drivers/media/i2c/$n ]; then echo $i; git mv $i i2c/; fi; done)
            (cd include/media; for i in *.h; do n=`echo $i|sed s/.h$/.c/`; if [ -e ../../drivers/media/*/i2c/$n ]; then echo $i; git mv $i i2c/; fi; done)
            for i in include/media/*.h; do n=`basename $i`;  (for j in $(git grep -l $n); do dirname $j; done)|sort|uniq|grep -ve '^.$' > list; num=$(wc -l list|cut -d' ' -f1); if [ $num == 1 ]; then if [ "`grep i2c list`" != "" ]; then git mv $i include/media/i2c; fi; fi; done
    
    And the references corrected via this script:
        MAIN_DIR="media/"
        PREV_DIR="media/"
        DIRS="i2c/"
    
        echo "Checking affected files" >&2
        for i in $DIRS; do
            for j in $(find include/$MAIN_DIR/$i -type f -name '*.h'); do
                     n=`basename $j`
                    git grep -l $n
            done
        done|sort|uniq >files && (
            echo "Handling files..." >&2;
            echo "for i in \$(cat files|grep -v Documentation); do cat \$i | \\";
            (
                    cd include/$MAIN_DIR;
                    for j in $DIRS; do
                            for i in $(ls $j); do
                                    echo "perl -ne 's,(include [\\\"\\<])$PREV_DIR($i)([\\\"\\>]),\1$MAIN_DIR$j\2\3,; print \$_' |\\";
                            done;
                    done;
                    echo "cat > a && mv a \$i; done";
            );
            echo "Handling documentation..." >&2;
            echo "for i in MAINTAINERS \$(cat files); do cat \$i | \\";
            (
                    cd include/$MAIN_DIR;
                    for j in $DIRS; do
                            for i in $(ls $j); do
                                    echo "  perl -ne 's,include/$PREV_DIR($i)\b,include/$MAIN_DIR$j\1,; print \$_' |\\";
                            done;
                    done;
                    echo "cat > a && mv a \$i; done"
            );
        ) >script && . ./script
    
    Merged Sakari Ailus patch that moves smiapp.h to include/media/i2c.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/drivers/media/pci/cobalt/cobalt-irq.c b/drivers/media/pci/cobalt/cobalt-irq.c
index 3de26d0714b5..c30748e76164 100644
--- a/drivers/media/pci/cobalt/cobalt-irq.c
+++ b/drivers/media/pci/cobalt/cobalt-irq.c
@@ -18,7 +18,7 @@
  *  SOFTWARE.
  */
 
-#include <media/adv7604.h>
+#include <media/i2c/adv7604.h>
 
 #include "cobalt-driver.h"
 #include "cobalt-irq.h"

commit 2d7007153f0c9b1dd00c01894df7d26ddc32b79f
Author: Junghak Sung <jh1009.sung@samsung.com>
Date:   Tue Sep 22 10:30:30 2015 -0300

    [media] media: videobuf2: Restructure vb2_buffer
    
    Remove v4l2 stuff - v4l2_buf, v4l2_plane - from struct vb2_buffer.
    
    Add new member variables - bytesused, length, offset, userptr, fd,
    data_offset - to struct vb2_plane in order to cover all information
    of v4l2_plane.
    struct vb2_plane {
            <snip>
            unsigned int            bytesused;
            unsigned int            length;
            union {
                    unsigned int    offset;
                    unsigned long   userptr;
                    int             fd;
            } m;
            unsigned int            data_offset;
    }
    
    Replace v4l2_buf with new member variables - index, type, memory - which
    are common fields for buffer management.
    struct vb2_buffer {
            <snip>
            unsigned int            index;
            unsigned int            type;
            unsigned int            memory;
            unsigned int            num_planes;
            struct vb2_plane        planes[VIDEO_MAX_PLANES];
            <snip>
    };
    
    v4l2 specific fields - flags, field, timestamp, timecode,
    sequence - are moved to vb2_v4l2_buffer in videobuf2-v4l2.c
    struct vb2_v4l2_buffer {
            struct vb2_buffer       vb2_buf;
    
            __u32                   flags;
            __u32                   field;
            struct timeval          timestamp;
            struct v4l2_timecode    timecode;
            __u32                   sequence;
    };
    
    Signed-off-by: Junghak Sung <jh1009.sung@samsung.com>
    Signed-off-by: Geunyoung Kim <nenggun.kim@samsung.com>
    Acked-by: Seung-Woo Kim <sw0312.kim@samsung.com>
    Acked-by: Inki Dae <inki.dae@samsung.com>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/pci/cobalt/cobalt-irq.c b/drivers/media/pci/cobalt/cobalt-irq.c
index d1f5898d11ba..3de26d0714b5 100644
--- a/drivers/media/pci/cobalt/cobalt-irq.c
+++ b/drivers/media/pci/cobalt/cobalt-irq.c
@@ -134,11 +134,12 @@ static void cobalt_dma_stream_queue_handler(struct cobalt_stream *s)
 		skip = true;
 		s->skip_first_frames--;
 	}
-	v4l2_get_timestamp(&cb->vb.v4l2_buf.timestamp);
+	v4l2_get_timestamp(&cb->vb.timestamp);
 	/* TODO: the sequence number should be read from the FPGA so we
 	   also know about dropped frames. */
-	cb->vb.v4l2_buf.sequence = s->sequence++;
-	vb2_buffer_done(&cb->vb, (skip || s->unstable_frame) ?
+	cb->vb.sequence = s->sequence++;
+	vb2_buffer_done(&cb->vb.vb2_buf,
+			(skip || s->unstable_frame) ?
 			VB2_BUF_STATE_REQUEUEING : VB2_BUF_STATE_DONE);
 }
 

commit 6d058c5643e16779ae4c001d2e893c140940e48f
Author: Sakari Ailus <sakari.ailus@linux.intel.com>
Date:   Fri Jul 3 04:37:07 2015 -0300

    [media] vb2: Only requeue buffers immediately once streaming is started
    
    Buffers can be returned back to videobuf2 in driver's streamon handler. In
    this case vb2_buffer_done() with buffer state VB2_BUF_STATE_QUEUED will
    cause the driver's buf_queue vb2 operation to be called, queueing the same
    buffer again only to be returned to videobuf2 using vb2_buffer_done() and so
    on.
    
    Add a new buffer state VB2_BUF_STATE_REQUEUEING which, when used as the
    state argument to vb2_buffer_done(), will result in buffers queued to the
    driver. Using VB2_BUF_STATE_QUEUED will leave the buffer to videobuf2, as it
    was before "[media] vb2: allow requeuing buffers while streaming".
    
    Fixes: ce0eff016f72 ("[media] vb2: allow requeuing buffers while streaming")
    
    [mchehab@osg.samsung.com: fix warning: enumeration value 'VB2_BUF_STATE_REQUEUEING' not handled in switch]
    
    Signed-off-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Acked-by: Hans Verkuil <hans.verkuil@cisco.com>
    Cc: stable@vger.kernel.org # for v4.1
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/pci/cobalt/cobalt-irq.c b/drivers/media/pci/cobalt/cobalt-irq.c
index dd4bff9cf339..d1f5898d11ba 100644
--- a/drivers/media/pci/cobalt/cobalt-irq.c
+++ b/drivers/media/pci/cobalt/cobalt-irq.c
@@ -139,7 +139,7 @@ static void cobalt_dma_stream_queue_handler(struct cobalt_stream *s)
 	   also know about dropped frames. */
 	cb->vb.v4l2_buf.sequence = s->sequence++;
 	vb2_buffer_done(&cb->vb, (skip || s->unstable_frame) ?
-			VB2_BUF_STATE_QUEUED : VB2_BUF_STATE_DONE);
+			VB2_BUF_STATE_REQUEUEING : VB2_BUF_STATE_DONE);
 }
 
 irqreturn_t cobalt_irq_handler(int irq, void *dev_id)

commit c0ce6220a5bf7ba892cd1ef9c9d4b622cf6f0894
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Fri May 22 05:44:23 2015 -0300

    [media] cobalt: fix sparse warnings
    
    drivers/media/pci/cobalt/cobalt-irq.c:62:33: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-irq.c:64:17: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-irq.c:65:23: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-irq.c:72:21: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-irq.c:73:25: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-irq.c:74:25: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-irq.c:82:33: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-irq.c:83:33: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-irq.c:91:25: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-irq.c:94:23: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-irq.c:103:25: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-irq.c:107:17: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-irq.c:109:17: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-irq.c:116:13: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-irq.c:119:17: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-irq.c:120:17: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-irq.c:122:17: warning: dereference of noderef expression
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/pci/cobalt/cobalt-irq.c b/drivers/media/pci/cobalt/cobalt-irq.c
index a133dfcb2ead..dd4bff9cf339 100644
--- a/drivers/media/pci/cobalt/cobalt-irq.c
+++ b/drivers/media/pci/cobalt/cobalt-irq.c
@@ -28,13 +28,13 @@ static void cobalt_dma_stream_queue_handler(struct cobalt_stream *s)
 {
 	struct cobalt *cobalt = s->cobalt;
 	int rx = s->video_channel;
-	volatile struct m00473_freewheel_regmap __iomem *fw =
+	struct m00473_freewheel_regmap __iomem *fw =
 		COBALT_CVI_FREEWHEEL(s->cobalt, rx);
-	volatile struct m00233_video_measure_regmap __iomem *vmr =
+	struct m00233_video_measure_regmap __iomem *vmr =
 		COBALT_CVI_VMR(s->cobalt, rx);
-	volatile struct m00389_cvi_regmap __iomem *cvi =
+	struct m00389_cvi_regmap __iomem *cvi =
 		COBALT_CVI(s->cobalt, rx);
-	volatile struct m00479_clk_loss_detector_regmap __iomem *clkloss =
+	struct m00479_clk_loss_detector_regmap __iomem *clkloss =
 		COBALT_CVI_CLK_LOSS(s->cobalt, rx);
 	struct cobalt_buffer *cb;
 	bool skip = false;
@@ -59,19 +59,21 @@ static void cobalt_dma_stream_queue_handler(struct cobalt_stream *s)
 		goto done;
 
 	if (s->unstable_frame) {
-		uint32_t stat = vmr->irq_status;
+		uint32_t stat = ioread32(&vmr->irq_status);
 
-		vmr->irq_status = stat;
-		if (!(vmr->status & M00233_STATUS_BITMAP_INIT_DONE_MSK)) {
+		iowrite32(stat, &vmr->irq_status);
+		if (!(ioread32(&vmr->status) &
+		      M00233_STATUS_BITMAP_INIT_DONE_MSK)) {
 			cobalt_dbg(1, "!init_done\n");
 			if (s->enable_freewheel)
 				goto restart_fw;
 			goto done;
 		}
 
-		if (clkloss->status & M00479_STATUS_BITMAP_CLOCK_MISSING_MSK) {
-			clkloss->ctrl = 0;
-			clkloss->ctrl = M00479_CTRL_BITMAP_ENABLE_MSK;
+		if (ioread32(&clkloss->status) &
+		    M00479_STATUS_BITMAP_CLOCK_MISSING_MSK) {
+			iowrite32(0, &clkloss->ctrl);
+			iowrite32(M00479_CTRL_BITMAP_ENABLE_MSK, &clkloss->ctrl);
 			cobalt_dbg(1, "no clock\n");
 			if (s->enable_freewheel)
 				goto restart_fw;
@@ -79,8 +81,8 @@ static void cobalt_dma_stream_queue_handler(struct cobalt_stream *s)
 		}
 		if ((stat & (M00233_IRQ_STATUS_BITMAP_VACTIVE_AREA_MSK |
 			     M00233_IRQ_STATUS_BITMAP_HACTIVE_AREA_MSK)) ||
-				vmr->vactive_area != s->timings.bt.height ||
-				vmr->hactive_area != s->timings.bt.width) {
+				ioread32(&vmr->vactive_area) != s->timings.bt.height ||
+				ioread32(&vmr->hactive_area) != s->timings.bt.width) {
 			cobalt_dbg(1, "unstable\n");
 			if (s->enable_freewheel)
 				goto restart_fw;
@@ -88,10 +90,10 @@ static void cobalt_dma_stream_queue_handler(struct cobalt_stream *s)
 		}
 		if (!s->enable_cvi) {
 			s->enable_cvi = true;
-			cvi->control = M00389_CONTROL_BITMAP_ENABLE_MSK;
+			iowrite32(M00389_CONTROL_BITMAP_ENABLE_MSK, &cvi->control);
 			goto done;
 		}
-		if (!(cvi->status & M00389_STATUS_BITMAP_LOCK_MSK)) {
+		if (!(ioread32(&cvi->status) & M00389_STATUS_BITMAP_LOCK_MSK)) {
 			cobalt_dbg(1, "cvi no lock\n");
 			if (s->enable_freewheel)
 				goto restart_fw;
@@ -100,26 +102,29 @@ static void cobalt_dma_stream_queue_handler(struct cobalt_stream *s)
 		if (!s->enable_freewheel) {
 			cobalt_dbg(1, "stable\n");
 			s->enable_freewheel = true;
-			fw->ctrl = 0;
+			iowrite32(0, &fw->ctrl);
 			goto done;
 		}
 		cobalt_dbg(1, "enabled fw\n");
-		vmr->control = M00233_CONTROL_BITMAP_ENABLE_MEASURE_MSK |
-			       M00233_CONTROL_BITMAP_ENABLE_INTERRUPT_MSK;
-		fw->ctrl = M00473_CTRL_BITMAP_ENABLE_MSK;
+		iowrite32(M00233_CONTROL_BITMAP_ENABLE_MEASURE_MSK |
+			  M00233_CONTROL_BITMAP_ENABLE_INTERRUPT_MSK,
+			  &vmr->control);
+		iowrite32(M00473_CTRL_BITMAP_ENABLE_MSK, &fw->ctrl);
 		s->enable_freewheel = false;
 		s->unstable_frame = false;
 		s->skip_first_frames = 2;
 		skip = true;
 		goto done;
 	}
-	if (fw->status & M00473_STATUS_BITMAP_FREEWHEEL_MODE_MSK) {
+	if (ioread32(&fw->status) & M00473_STATUS_BITMAP_FREEWHEEL_MODE_MSK) {
 restart_fw:
 		cobalt_dbg(1, "lost lock\n");
-		vmr->control = M00233_CONTROL_BITMAP_ENABLE_MEASURE_MSK;
-		fw->ctrl = M00473_CTRL_BITMAP_ENABLE_MSK |
-			   M00473_CTRL_BITMAP_FORCE_FREEWHEEL_MODE_MSK;
-		cvi->control = 0;
+		iowrite32(M00233_CONTROL_BITMAP_ENABLE_MEASURE_MSK,
+			  &vmr->control);
+		iowrite32(M00473_CTRL_BITMAP_ENABLE_MSK |
+			  M00473_CTRL_BITMAP_FORCE_FREEWHEEL_MODE_MSK,
+			  &fw->ctrl);
+		iowrite32(0, &cvi->control);
 		s->unstable_frame = true;
 		s->enable_freewheel = false;
 		s->enable_cvi = false;

commit 86bad00a2fd5327925417eb05a2b3d1819c42a70
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Thu May 21 06:19:28 2015 -0300

    [media] cobalt: fix irqs used for the adv7511 transmitter
    
    The interrupt bit assignments use for the adv7511 were off by one.
    This means that the current scheme (bit << (4 * stream_index)) can
    no longer be used.
    
    Fix this by precalculating and storing the correct masks in the
    cobalt_stream struct.
    
    This wasn't noticed before because the adv7511 interrupts are very
    rare. But for CEC support these interrupts are essential, so this made
    me realize that it wasn't working correctly.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/pci/cobalt/cobalt-irq.c b/drivers/media/pci/cobalt/cobalt-irq.c
index e18f49e6f0e3..a133dfcb2ead 100644
--- a/drivers/media/pci/cobalt/cobalt-irq.c
+++ b/drivers/media/pci/cobalt/cobalt-irq.c
@@ -153,8 +153,7 @@ irqreturn_t cobalt_irq_handler(int irq, void *dev_id)
 
 	for (i = 0; i < COBALT_NUM_STREAMS; i++) {
 		struct cobalt_stream *s = &cobalt->streams[i];
-		unsigned dma_fifo_mask =
-		    COBALT_SYSSTAT_VI0_LOST_DATA_MSK << (4 * s->video_channel);
+		unsigned dma_fifo_mask = s->dma_fifo_mask;
 
 		if (dma_interrupt & (1 << s->dma_channel)) {
 			cobalt->irq_dma[i]++;
@@ -169,7 +168,7 @@ irqreturn_t cobalt_irq_handler(int irq, void *dev_id)
 		}
 		if (s->is_audio)
 			continue;
-		if (edge & (0x20 << (4 * s->video_channel)))
+		if (edge & s->adv_irq_mask)
 			set_bit(COBALT_STREAM_FL_ADV_IRQ, &s->flags);
 		if ((edge & mask & dma_fifo_mask) && vb2_is_streaming(&s->q)) {
 			cobalt_info("full rx FIFO %d\n", i);
@@ -219,7 +218,7 @@ void cobalt_irq_work_handler(struct work_struct *work)
 					interrupt_service_routine, 0, NULL);
 			mask = cobalt_read_bar1(cobalt, COBALT_SYS_STAT_MASK);
 			cobalt_write_bar1(cobalt, COBALT_SYS_STAT_MASK,
-				mask | (0x20 << (4 * s->video_channel)));
+				mask | s->adv_irq_mask);
 		}
 	}
 }

commit 85756a069c55e0315ac5990806899cfb607b987f
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Tue May 12 08:52:21 2015 -0300

    [media] cobalt: add new driver
    
    The cobalt device is a PCIe card with 4 HDMI inputs (adv7604) and a
    connector that can be used to hook up an adv7511 transmitter or an
    adv7842 receiver daughterboard.
    
    This device is used within Cisco but is sadly not available outside
    of Cisco. Nevertheless it is a very interesting driver that can serve
    as an example of how to support HDMI hardware and how to use the popular
    adv devices.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/pci/cobalt/cobalt-irq.c b/drivers/media/pci/cobalt/cobalt-irq.c
new file mode 100644
index 000000000000..e18f49e6f0e3
--- /dev/null
+++ b/drivers/media/pci/cobalt/cobalt-irq.c
@@ -0,0 +1,254 @@
+/*
+ *  cobalt interrupt handling
+ *
+ *  Copyright 2012-2015 Cisco Systems, Inc. and/or its affiliates.
+ *  All rights reserved.
+ *
+ *  This program is free software; you may redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ *  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ *  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ *  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ *  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ *  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ *  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ *  SOFTWARE.
+ */
+
+#include <media/adv7604.h>
+
+#include "cobalt-driver.h"
+#include "cobalt-irq.h"
+#include "cobalt-omnitek.h"
+
+static void cobalt_dma_stream_queue_handler(struct cobalt_stream *s)
+{
+	struct cobalt *cobalt = s->cobalt;
+	int rx = s->video_channel;
+	volatile struct m00473_freewheel_regmap __iomem *fw =
+		COBALT_CVI_FREEWHEEL(s->cobalt, rx);
+	volatile struct m00233_video_measure_regmap __iomem *vmr =
+		COBALT_CVI_VMR(s->cobalt, rx);
+	volatile struct m00389_cvi_regmap __iomem *cvi =
+		COBALT_CVI(s->cobalt, rx);
+	volatile struct m00479_clk_loss_detector_regmap __iomem *clkloss =
+		COBALT_CVI_CLK_LOSS(s->cobalt, rx);
+	struct cobalt_buffer *cb;
+	bool skip = false;
+
+	spin_lock(&s->irqlock);
+
+	if (list_empty(&s->bufs)) {
+		pr_err("no buffers!\n");
+		spin_unlock(&s->irqlock);
+		return;
+	}
+
+	/* Give the fresh filled up buffer to the user.
+	 * Note that the interrupt is only sent if the DMA can continue
+	 * with a new buffer, so it is always safe to return this buffer
+	 * to userspace. */
+	cb = list_first_entry(&s->bufs, struct cobalt_buffer, list);
+	list_del(&cb->list);
+	spin_unlock(&s->irqlock);
+
+	if (s->is_audio || s->is_output)
+		goto done;
+
+	if (s->unstable_frame) {
+		uint32_t stat = vmr->irq_status;
+
+		vmr->irq_status = stat;
+		if (!(vmr->status & M00233_STATUS_BITMAP_INIT_DONE_MSK)) {
+			cobalt_dbg(1, "!init_done\n");
+			if (s->enable_freewheel)
+				goto restart_fw;
+			goto done;
+		}
+
+		if (clkloss->status & M00479_STATUS_BITMAP_CLOCK_MISSING_MSK) {
+			clkloss->ctrl = 0;
+			clkloss->ctrl = M00479_CTRL_BITMAP_ENABLE_MSK;
+			cobalt_dbg(1, "no clock\n");
+			if (s->enable_freewheel)
+				goto restart_fw;
+			goto done;
+		}
+		if ((stat & (M00233_IRQ_STATUS_BITMAP_VACTIVE_AREA_MSK |
+			     M00233_IRQ_STATUS_BITMAP_HACTIVE_AREA_MSK)) ||
+				vmr->vactive_area != s->timings.bt.height ||
+				vmr->hactive_area != s->timings.bt.width) {
+			cobalt_dbg(1, "unstable\n");
+			if (s->enable_freewheel)
+				goto restart_fw;
+			goto done;
+		}
+		if (!s->enable_cvi) {
+			s->enable_cvi = true;
+			cvi->control = M00389_CONTROL_BITMAP_ENABLE_MSK;
+			goto done;
+		}
+		if (!(cvi->status & M00389_STATUS_BITMAP_LOCK_MSK)) {
+			cobalt_dbg(1, "cvi no lock\n");
+			if (s->enable_freewheel)
+				goto restart_fw;
+			goto done;
+		}
+		if (!s->enable_freewheel) {
+			cobalt_dbg(1, "stable\n");
+			s->enable_freewheel = true;
+			fw->ctrl = 0;
+			goto done;
+		}
+		cobalt_dbg(1, "enabled fw\n");
+		vmr->control = M00233_CONTROL_BITMAP_ENABLE_MEASURE_MSK |
+			       M00233_CONTROL_BITMAP_ENABLE_INTERRUPT_MSK;
+		fw->ctrl = M00473_CTRL_BITMAP_ENABLE_MSK;
+		s->enable_freewheel = false;
+		s->unstable_frame = false;
+		s->skip_first_frames = 2;
+		skip = true;
+		goto done;
+	}
+	if (fw->status & M00473_STATUS_BITMAP_FREEWHEEL_MODE_MSK) {
+restart_fw:
+		cobalt_dbg(1, "lost lock\n");
+		vmr->control = M00233_CONTROL_BITMAP_ENABLE_MEASURE_MSK;
+		fw->ctrl = M00473_CTRL_BITMAP_ENABLE_MSK |
+			   M00473_CTRL_BITMAP_FORCE_FREEWHEEL_MODE_MSK;
+		cvi->control = 0;
+		s->unstable_frame = true;
+		s->enable_freewheel = false;
+		s->enable_cvi = false;
+	}
+done:
+	if (s->skip_first_frames) {
+		skip = true;
+		s->skip_first_frames--;
+	}
+	v4l2_get_timestamp(&cb->vb.v4l2_buf.timestamp);
+	/* TODO: the sequence number should be read from the FPGA so we
+	   also know about dropped frames. */
+	cb->vb.v4l2_buf.sequence = s->sequence++;
+	vb2_buffer_done(&cb->vb, (skip || s->unstable_frame) ?
+			VB2_BUF_STATE_QUEUED : VB2_BUF_STATE_DONE);
+}
+
+irqreturn_t cobalt_irq_handler(int irq, void *dev_id)
+{
+	struct cobalt *cobalt = (struct cobalt *)dev_id;
+	u32 dma_interrupt =
+		cobalt_read_bar0(cobalt, DMA_INTERRUPT_STATUS_REG) & 0xffff;
+	u32 mask = cobalt_read_bar1(cobalt, COBALT_SYS_STAT_MASK);
+	u32 edge = cobalt_read_bar1(cobalt, COBALT_SYS_STAT_EDGE);
+	int i;
+
+	/* Clear DMA interrupt */
+	cobalt_write_bar0(cobalt, DMA_INTERRUPT_STATUS_REG, dma_interrupt);
+	cobalt_write_bar1(cobalt, COBALT_SYS_STAT_MASK, mask & ~edge);
+	cobalt_write_bar1(cobalt, COBALT_SYS_STAT_EDGE, edge);
+
+	for (i = 0; i < COBALT_NUM_STREAMS; i++) {
+		struct cobalt_stream *s = &cobalt->streams[i];
+		unsigned dma_fifo_mask =
+		    COBALT_SYSSTAT_VI0_LOST_DATA_MSK << (4 * s->video_channel);
+
+		if (dma_interrupt & (1 << s->dma_channel)) {
+			cobalt->irq_dma[i]++;
+			/* Give fresh buffer to user and chain newly
+			 * queued buffers */
+			cobalt_dma_stream_queue_handler(s);
+			if (!s->is_audio) {
+				edge &= ~dma_fifo_mask;
+				cobalt_write_bar1(cobalt, COBALT_SYS_STAT_MASK,
+						  mask & ~edge);
+			}
+		}
+		if (s->is_audio)
+			continue;
+		if (edge & (0x20 << (4 * s->video_channel)))
+			set_bit(COBALT_STREAM_FL_ADV_IRQ, &s->flags);
+		if ((edge & mask & dma_fifo_mask) && vb2_is_streaming(&s->q)) {
+			cobalt_info("full rx FIFO %d\n", i);
+			cobalt->irq_full_fifo++;
+		}
+	}
+
+	queue_work(cobalt->irq_work_queues, &cobalt->irq_work_queue);
+
+	if (edge & mask & (COBALT_SYSSTAT_VI0_INT1_MSK |
+			   COBALT_SYSSTAT_VI1_INT1_MSK |
+			   COBALT_SYSSTAT_VI2_INT1_MSK |
+			   COBALT_SYSSTAT_VI3_INT1_MSK |
+			   COBALT_SYSSTAT_VIHSMA_INT1_MSK |
+			   COBALT_SYSSTAT_VOHSMA_INT1_MSK))
+		cobalt->irq_adv1++;
+	if (edge & mask & (COBALT_SYSSTAT_VI0_INT2_MSK |
+			   COBALT_SYSSTAT_VI1_INT2_MSK |
+			   COBALT_SYSSTAT_VI2_INT2_MSK |
+			   COBALT_SYSSTAT_VI3_INT2_MSK |
+			   COBALT_SYSSTAT_VIHSMA_INT2_MSK))
+		cobalt->irq_adv2++;
+	if (edge & mask & COBALT_SYSSTAT_VOHSMA_INT1_MSK)
+		cobalt->irq_advout++;
+	if (dma_interrupt)
+		cobalt->irq_dma_tot++;
+	if (!(edge & mask) && !dma_interrupt)
+		cobalt->irq_none++;
+	dma_interrupt = cobalt_read_bar0(cobalt, DMA_INTERRUPT_STATUS_REG);
+
+	return IRQ_HANDLED;
+}
+
+void cobalt_irq_work_handler(struct work_struct *work)
+{
+	struct cobalt *cobalt =
+		container_of(work, struct cobalt, irq_work_queue);
+	int i;
+
+	for (i = 0; i < COBALT_NUM_NODES; i++) {
+		struct cobalt_stream *s = &cobalt->streams[i];
+
+		if (test_and_clear_bit(COBALT_STREAM_FL_ADV_IRQ, &s->flags)) {
+			u32 mask;
+
+			v4l2_subdev_call(cobalt->streams[i].sd, core,
+					interrupt_service_routine, 0, NULL);
+			mask = cobalt_read_bar1(cobalt, COBALT_SYS_STAT_MASK);
+			cobalt_write_bar1(cobalt, COBALT_SYS_STAT_MASK,
+				mask | (0x20 << (4 * s->video_channel)));
+		}
+	}
+}
+
+void cobalt_irq_log_status(struct cobalt *cobalt)
+{
+	u32 mask;
+	int i;
+
+	cobalt_info("irq: adv1=%u adv2=%u advout=%u none=%u full=%u\n",
+		    cobalt->irq_adv1, cobalt->irq_adv2, cobalt->irq_advout,
+		    cobalt->irq_none, cobalt->irq_full_fifo);
+	cobalt_info("irq: dma_tot=%u (", cobalt->irq_dma_tot);
+	for (i = 0; i < COBALT_NUM_STREAMS; i++)
+		pr_cont("%s%u", i ? "/" : "", cobalt->irq_dma[i]);
+	pr_cont(")\n");
+	cobalt->irq_dma_tot = cobalt->irq_adv1 = cobalt->irq_adv2 = 0;
+	cobalt->irq_advout = cobalt->irq_none = cobalt->irq_full_fifo = 0;
+	memset(cobalt->irq_dma, 0, sizeof(cobalt->irq_dma));
+
+	mask = cobalt_read_bar1(cobalt, COBALT_SYS_STAT_MASK);
+	cobalt_write_bar1(cobalt, COBALT_SYS_STAT_MASK,
+			mask |
+			COBALT_SYSSTAT_VI0_LOST_DATA_MSK |
+			COBALT_SYSSTAT_VI1_LOST_DATA_MSK |
+			COBALT_SYSSTAT_VI2_LOST_DATA_MSK |
+			COBALT_SYSSTAT_VI3_LOST_DATA_MSK |
+			COBALT_SYSSTAT_VIHSMA_LOST_DATA_MSK |
+			COBALT_SYSSTAT_VOHSMA_LOST_DATA_MSK |
+			COBALT_SYSSTAT_AUD_IN_LOST_DATA_MSK |
+			COBALT_SYSSTAT_AUD_OUT_LOST_DATA_MSK);
+}
