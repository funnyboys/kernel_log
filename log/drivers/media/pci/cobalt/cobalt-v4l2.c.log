commit 3e30a927af3ca86f6556faf437da44ca8bcf54a4
Author: Hans Verkuil <hverkuil-cisco@xs4all.nl>
Date:   Mon Feb 3 12:41:17 2020 +0100

    media: media/pci: rename VFL_TYPE_GRABBER to _VIDEO
    
    'GRABBER' is a weird name, all other types map to the /dev
    device names. Rename to 'VIDEO' to be consistent with the
    other types.
    
    Signed-off-by: Hans Verkuil <hverkuil-cisco@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+huawei@kernel.org>

diff --git a/drivers/media/pci/cobalt/cobalt-v4l2.c b/drivers/media/pci/cobalt/cobalt-v4l2.c
index c5207501d5e0..0ff37496c9ab 100644
--- a/drivers/media/pci/cobalt/cobalt-v4l2.c
+++ b/drivers/media/pci/cobalt/cobalt-v4l2.c
@@ -1272,7 +1272,7 @@ static int cobalt_node_register(struct cobalt *cobalt, int node)
 	video_set_drvdata(vdev, s);
 	ret = vb2_queue_init(q);
 	if (!s->is_audio && ret == 0)
-		ret = video_register_device(vdev, VFL_TYPE_GRABBER, -1);
+		ret = video_register_device(vdev, VFL_TYPE_VIDEO, -1);
 	else if (!s->is_dummy)
 		ret = cobalt_alsa_init(s);
 

commit b61789f53d49db8ca1f6b8fed411b317b4e8f044
Author: Hans Verkuil <hverkuil@xs4all.nl>
Date:   Wed Jun 26 05:58:02 2019 -0400

    media: drivers/media: don't set pix->priv = 0
    
    The priv field of struct v4l2_pix_format shouldn't be set by drivers,
    it's set by the v4l2 core instead to V4L2_PIX_FMT_PRIV_MAGIC.
    
    Drop this from the few media drivers that still do this.
    
    Note that the gspca patch is slightly more involved since some of the
    sub-gspca drivers use the priv field internally.
    
    Signed-off-by: Hans Verkuil <hverkuil-cisco@xs4all.nl>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    [hverkuil-cisco@xs4all.nl: fix clash in gspca between priv arg and priv variable]
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/pci/cobalt/cobalt-v4l2.c b/drivers/media/pci/cobalt/cobalt-v4l2.c
index ea96f333ee2b..c5207501d5e0 100644
--- a/drivers/media/pci/cobalt/cobalt-v4l2.c
+++ b/drivers/media/pci/cobalt/cobalt-v4l2.c
@@ -785,7 +785,6 @@ static int cobalt_try_fmt_vid_cap(struct file *file, void *priv_fh,
 
 	pix->sizeimage = pix->bytesperline * pix->height;
 	pix->field = V4L2_FIELD_NONE;
-	pix->priv = 0;
 
 	return 0;
 }

commit 2169e6daa1ffa6e9869fcc56ff7df23c9287f1ec
Author: Hans Verkuil <hverkuil-cisco@xs4all.nl>
Date:   Tue Jun 11 09:49:53 2019 -0400

    media: media/pci: don't set description for ENUM_FMT
    
    The V4L2 core sets the description for the driver in order to ensure
    consistent naming.
    
    So drop the strscpy of the description in drivers. Also remove any
    description strings in driver-internal structures since those are
    no longer needed.
    
    Signed-off-by: Hans Verkuil <hverkuil-cisco@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/pci/cobalt/cobalt-v4l2.c b/drivers/media/pci/cobalt/cobalt-v4l2.c
index 39dabd4da60f..ea96f333ee2b 100644
--- a/drivers/media/pci/cobalt/cobalt-v4l2.c
+++ b/drivers/media/pci/cobalt/cobalt-v4l2.c
@@ -688,15 +688,12 @@ static int cobalt_enum_fmt_vid_cap(struct file *file, void *priv_fh,
 {
 	switch (f->index) {
 	case 0:
-		strscpy(f->description, "YUV 4:2:2", sizeof(f->description));
 		f->pixelformat = V4L2_PIX_FMT_YUYV;
 		break;
 	case 1:
-		strscpy(f->description, "RGB24", sizeof(f->description));
 		f->pixelformat = V4L2_PIX_FMT_RGB24;
 		break;
 	case 2:
-		strscpy(f->description, "RGB32", sizeof(f->description));
 		f->pixelformat = V4L2_PIX_FMT_BGR32;
 		break;
 	default:
@@ -893,11 +890,9 @@ static int cobalt_enum_fmt_vid_out(struct file *file, void *priv_fh,
 {
 	switch (f->index) {
 	case 0:
-		strscpy(f->description, "YUV 4:2:2", sizeof(f->description));
 		f->pixelformat = V4L2_PIX_FMT_YUYV;
 		break;
 	case 1:
-		strscpy(f->description, "RGB32", sizeof(f->description));
 		f->pixelformat = V4L2_PIX_FMT_BGR32;
 		break;
 	default:

commit 2161536516edcc0be31109eb1284939119e7ba6d
Author: Hans Verkuil <hverkuil@xs4all.nl>
Date:   Mon Jun 17 05:36:16 2019 -0400

    media: media/pci: set device_caps in struct video_device
    
    Instead of filling in the struct v4l2_capability device_caps
    field, fill in the struct video_device device_caps field.
    
    That way the V4L2 core knows what the capabilities of the
    video device are.
    
    But this only really works if all drivers use this, so convert
    all pci drivers in this patch.
    
    Tested with cx88-blackbird and ivtv PVR-350.
    
    Signed-off-by: Hans Verkuil <hverkuil-cisco@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/pci/cobalt/cobalt-v4l2.c b/drivers/media/pci/cobalt/cobalt-v4l2.c
index f9fa3a7c3b8f..39dabd4da60f 100644
--- a/drivers/media/pci/cobalt/cobalt-v4l2.c
+++ b/drivers/media/pci/cobalt/cobalt-v4l2.c
@@ -483,13 +483,8 @@ static int cobalt_querycap(struct file *file, void *priv_fh,
 	strscpy(vcap->card, "cobalt", sizeof(vcap->card));
 	snprintf(vcap->bus_info, sizeof(vcap->bus_info),
 		 "PCIe:%s", pci_name(cobalt->pci_dev));
-	vcap->device_caps = V4L2_CAP_STREAMING | V4L2_CAP_READWRITE;
-	if (s->is_output)
-		vcap->device_caps |= V4L2_CAP_VIDEO_OUTPUT;
-	else
-		vcap->device_caps |= V4L2_CAP_VIDEO_CAPTURE;
-	vcap->capabilities = vcap->device_caps | V4L2_CAP_DEVICE_CAPS |
-		V4L2_CAP_VIDEO_CAPTURE;
+	vcap->capabilities = V4L2_CAP_STREAMING | V4L2_CAP_READWRITE |
+		V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_DEVICE_CAPS;
 	if (cobalt->have_hsma_tx)
 		vcap->capabilities |= V4L2_CAP_VIDEO_OUTPUT;
 	return 0;
@@ -1274,6 +1269,11 @@ static int cobalt_node_register(struct cobalt *cobalt, int node)
 	q->lock = &s->lock;
 	q->dev = &cobalt->pci_dev->dev;
 	vdev->queue = q;
+	vdev->device_caps = V4L2_CAP_STREAMING | V4L2_CAP_READWRITE;
+	if (s->is_output)
+		vdev->device_caps |= V4L2_CAP_VIDEO_OUTPUT;
+	else
+		vdev->device_caps |= V4L2_CAP_VIDEO_CAPTURE;
 
 	video_set_drvdata(vdev, s);
 	ret = vb2_queue_init(q);

commit 167905540e08e37162adc24066427944f71bf7a4
Author: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
Date:   Mon Feb 18 14:28:59 2019 -0500

    media: pci: fix several typos
    
    Use codespell to fix lots of typos over frontends.
    
    Manually verified to avoid false-positives.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/pci/cobalt/cobalt-v4l2.c b/drivers/media/pci/cobalt/cobalt-v4l2.c
index c088de551081..f9fa3a7c3b8f 100644
--- a/drivers/media/pci/cobalt/cobalt-v4l2.c
+++ b/drivers/media/pci/cobalt/cobalt-v4l2.c
@@ -375,7 +375,7 @@ static void cobalt_dma_stop_streaming(struct cobalt_stream *s)
 	}
 	spin_unlock_irqrestore(&s->irqlock, flags);
 
-	/* Wait 100 milisecond for DMA to finish, abort on timeout. */
+	/* Wait 100 millisecond for DMA to finish, abort on timeout. */
 	if (!wait_event_timeout(s->q.done_wq, is_dma_done(s),
 				msecs_to_jiffies(timeout_msec))) {
 		omni_sg_dma_abort_channel(s);

commit 5200ab6a32d6055428896a49ec9e3b1652c1a100
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Thu Oct 4 17:38:15 2018 -0400

    media: vidioc_cropcap -> vidioc_g_pixelaspect
    
    Now vidioc_cropcap is only used to return the pixelaspect, so
    rename it accordingly.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Reviewed-by: Niklas Söderlund <niklas.soderlund+renesas@ragnatech.se>
    Tested-by: Niklas Söderlund <niklas.soderlund+renesas@ragnatech.se>
    Acked-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/pci/cobalt/cobalt-v4l2.c b/drivers/media/pci/cobalt/cobalt-v4l2.c
index 4a0205aae4b4..c088de551081 100644
--- a/drivers/media/pci/cobalt/cobalt-v4l2.c
+++ b/drivers/media/pci/cobalt/cobalt-v4l2.c
@@ -1077,20 +1077,22 @@ static int cobalt_g_parm(struct file *file, void *fh, struct v4l2_streamparm *a)
 	return 0;
 }
 
-static int cobalt_cropcap(struct file *file, void *fh, struct v4l2_cropcap *cc)
+static int cobalt_g_pixelaspect(struct file *file, void *fh,
+				int type, struct v4l2_fract *f)
 {
 	struct cobalt_stream *s = video_drvdata(file);
 	struct v4l2_dv_timings timings;
 	int err = 0;
 
-	if (cc->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+	if (type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
 		return -EINVAL;
+
 	if (s->input == 1)
 		timings = cea1080p60;
 	else
 		err = v4l2_subdev_call(s->sd, video, g_dv_timings, &timings);
 	if (!err)
-		cc->pixelaspect = v4l2_dv_timings_aspect_ratio(&timings);
+		*f = v4l2_dv_timings_aspect_ratio(&timings);
 	return err;
 }
 
@@ -1132,7 +1134,7 @@ static const struct v4l2_ioctl_ops cobalt_ioctl_ops = {
 	.vidioc_log_status		= cobalt_log_status,
 	.vidioc_streamon		= vb2_ioctl_streamon,
 	.vidioc_streamoff		= vb2_ioctl_streamoff,
-	.vidioc_cropcap			= cobalt_cropcap,
+	.vidioc_g_pixelaspect		= cobalt_g_pixelaspect,
 	.vidioc_g_selection		= cobalt_g_selection,
 	.vidioc_enum_input		= cobalt_enum_input,
 	.vidioc_g_input			= cobalt_g_input,

commit ee10dc36b485920e87eefa325d74fd8804648621
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Thu Oct 4 17:06:32 2018 -0400

    media: cropcap/g_selection split
    
    If g_selection is implemented, then the v4l2-ioctl cropcap code assumes
    that cropcap just implements the pixelaspect part and that g_selection
    provides the crop bounds and default rectangles.
    
    There are still some drivers that only implement cropcap and not
    g_selection. Split up cropcap into a cropcap and g_selection for those
    drivers.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/pci/cobalt/cobalt-v4l2.c b/drivers/media/pci/cobalt/cobalt-v4l2.c
index 0525f5e1565b..4a0205aae4b4 100644
--- a/drivers/media/pci/cobalt/cobalt-v4l2.c
+++ b/drivers/media/pci/cobalt/cobalt-v4l2.c
@@ -1089,14 +1089,43 @@ static int cobalt_cropcap(struct file *file, void *fh, struct v4l2_cropcap *cc)
 		timings = cea1080p60;
 	else
 		err = v4l2_subdev_call(s->sd, video, g_dv_timings, &timings);
-	if (!err) {
-		cc->bounds.width = cc->defrect.width = timings.bt.width;
-		cc->bounds.height = cc->defrect.height = timings.bt.height;
+	if (!err)
 		cc->pixelaspect = v4l2_dv_timings_aspect_ratio(&timings);
-	}
 	return err;
 }
 
+static int cobalt_g_selection(struct file *file, void *fh,
+			      struct v4l2_selection *sel)
+{
+	struct cobalt_stream *s = video_drvdata(file);
+	struct v4l2_dv_timings timings;
+	int err = 0;
+
+	if (sel->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;
+
+	if (s->input == 1)
+		timings = cea1080p60;
+	else
+		err = v4l2_subdev_call(s->sd, video, g_dv_timings, &timings);
+
+	if (err)
+		return err;
+
+	switch (sel->target) {
+	case V4L2_SEL_TGT_CROP_BOUNDS:
+	case V4L2_SEL_TGT_CROP_DEFAULT:
+		sel->r.top = 0;
+		sel->r.left = 0;
+		sel->r.width = timings.bt.width;
+		sel->r.height = timings.bt.height;
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
 static const struct v4l2_ioctl_ops cobalt_ioctl_ops = {
 	.vidioc_querycap		= cobalt_querycap,
 	.vidioc_g_parm			= cobalt_g_parm,
@@ -1104,6 +1133,7 @@ static const struct v4l2_ioctl_ops cobalt_ioctl_ops = {
 	.vidioc_streamon		= vb2_ioctl_streamon,
 	.vidioc_streamoff		= vb2_ioctl_streamoff,
 	.vidioc_cropcap			= cobalt_cropcap,
+	.vidioc_g_selection		= cobalt_g_selection,
 	.vidioc_enum_input		= cobalt_enum_input,
 	.vidioc_g_input			= cobalt_g_input,
 	.vidioc_s_input			= cobalt_s_input,

commit c0decac19da3906d9b66291e57b7759489e1170f
Author: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
Date:   Mon Sep 10 08:19:14 2018 -0400

    media: use strscpy() instead of strlcpy()
    
    The implementation of strscpy() is more robust and safer.
    
    That's now the recommended way to copy NUL terminated strings.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Acked-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/pci/cobalt/cobalt-v4l2.c b/drivers/media/pci/cobalt/cobalt-v4l2.c
index c8fd2d075f43..0525f5e1565b 100644
--- a/drivers/media/pci/cobalt/cobalt-v4l2.c
+++ b/drivers/media/pci/cobalt/cobalt-v4l2.c
@@ -479,8 +479,8 @@ static int cobalt_querycap(struct file *file, void *priv_fh,
 	struct cobalt_stream *s = video_drvdata(file);
 	struct cobalt *cobalt = s->cobalt;
 
-	strlcpy(vcap->driver, "cobalt", sizeof(vcap->driver));
-	strlcpy(vcap->card, "cobalt", sizeof(vcap->card));
+	strscpy(vcap->driver, "cobalt", sizeof(vcap->driver));
+	strscpy(vcap->card, "cobalt", sizeof(vcap->card));
 	snprintf(vcap->bus_info, sizeof(vcap->bus_info),
 		 "PCIe:%s", pci_name(cobalt->pci_dev));
 	vcap->device_caps = V4L2_CAP_STREAMING | V4L2_CAP_READWRITE;
@@ -693,15 +693,15 @@ static int cobalt_enum_fmt_vid_cap(struct file *file, void *priv_fh,
 {
 	switch (f->index) {
 	case 0:
-		strlcpy(f->description, "YUV 4:2:2", sizeof(f->description));
+		strscpy(f->description, "YUV 4:2:2", sizeof(f->description));
 		f->pixelformat = V4L2_PIX_FMT_YUYV;
 		break;
 	case 1:
-		strlcpy(f->description, "RGB24", sizeof(f->description));
+		strscpy(f->description, "RGB24", sizeof(f->description));
 		f->pixelformat = V4L2_PIX_FMT_RGB24;
 		break;
 	case 2:
-		strlcpy(f->description, "RGB32", sizeof(f->description));
+		strscpy(f->description, "RGB32", sizeof(f->description));
 		f->pixelformat = V4L2_PIX_FMT_BGR32;
 		break;
 	default:
@@ -898,11 +898,11 @@ static int cobalt_enum_fmt_vid_out(struct file *file, void *priv_fh,
 {
 	switch (f->index) {
 	case 0:
-		strlcpy(f->description, "YUV 4:2:2", sizeof(f->description));
+		strscpy(f->description, "YUV 4:2:2", sizeof(f->description));
 		f->pixelformat = V4L2_PIX_FMT_YUYV;
 		break;
 	case 1:
-		strlcpy(f->description, "RGB32", sizeof(f->description));
+		strscpy(f->description, "RGB32", sizeof(f->description));
 		f->pixelformat = V4L2_PIX_FMT_BGR32;
 		break;
 	default:

commit 3ae17c66ed666c5a5c627f28c9e20b2ab8fafe28
Author: Jose Abreu <Jose.Abreu@synopsys.com>
Date:   Tue Mar 21 07:49:18 2017 -0400

    media: cobalt: Use v4l2_calc_timeperframe helper
    
    Currently, cobalt driver always returns 60fps in g_parm.
    This patch uses the new v4l2_calc_timeperframe helper to
    calculate the time per frame value.
    
    Signed-off-by: Jose Abreu <joabreu@synopsys.com>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/pci/cobalt/cobalt-v4l2.c b/drivers/media/pci/cobalt/cobalt-v4l2.c
index e2a4c705d353..c8fd2d075f43 100644
--- a/drivers/media/pci/cobalt/cobalt-v4l2.c
+++ b/drivers/media/pci/cobalt/cobalt-v4l2.c
@@ -1064,10 +1064,15 @@ static int cobalt_subscribe_event(struct v4l2_fh *fh,
 
 static int cobalt_g_parm(struct file *file, void *fh, struct v4l2_streamparm *a)
 {
+	struct cobalt_stream *s = video_drvdata(file);
+	struct v4l2_fract fps;
+
 	if (a->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
 		return -EINVAL;
-	a->parm.capture.timeperframe.numerator = 1;
-	a->parm.capture.timeperframe.denominator = 60;
+
+	fps = v4l2_calc_timeperframe(&s->timings);
+	a->parm.capture.timeperframe.numerator = fps.numerator;
+	a->parm.capture.timeperframe.denominator = fps.denominator;
 	a->parm.capture.readbuffers = 3;
 	return 0;
 }

commit 6884db3c5f99793fef57f53a2897c0b744651d71
Author: Hans Verkuil <hansverk@cisco.com>
Date:   Wed Feb 7 09:27:12 2018 -0500

    media: cobalt: add SPDX license info
    
    Replace the old license information with the corresponding SPDX
    license.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/pci/cobalt/cobalt-v4l2.c b/drivers/media/pci/cobalt/cobalt-v4l2.c
index def4a3b37084..e2a4c705d353 100644
--- a/drivers/media/pci/cobalt/cobalt-v4l2.c
+++ b/drivers/media/pci/cobalt/cobalt-v4l2.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  *  cobalt V4L2 API
  *
@@ -5,19 +6,6 @@
  *
  *  Copyright 2012-2015 Cisco Systems, Inc. and/or its affiliates.
  *  All rights reserved.
- *
- *  This program is free software; you may redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; version 2 of the License.
- *
- *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- *  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- *  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- *  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
- *  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
- *  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- *  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- *  SOFTWARE.
  */
 
 #include <linux/dma-mapping.h>

commit 9f750b2b15125e842a2bd0a8c16f06ee65da26a2
Author: Hans Verkuil <hverkuil@xs4all.nl>
Date:   Fri Nov 11 08:33:05 2016 -0200

    [media] cobalt: fix copy-and-paste error
    
    The vmr_stat variable was filled with the contents of the control register,
    not the status register. Classic copy-and-paste error.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/pci/cobalt/cobalt-v4l2.c b/drivers/media/pci/cobalt/cobalt-v4l2.c
index 3fea24613059..def4a3b37084 100644
--- a/drivers/media/pci/cobalt/cobalt-v4l2.c
+++ b/drivers/media/pci/cobalt/cobalt-v4l2.c
@@ -527,7 +527,7 @@ static void cobalt_video_input_status_show(struct cobalt_stream *s)
 	cvi_ctrl = ioread32(&cvi->control);
 	cvi_stat = ioread32(&cvi->status);
 	vmr_ctrl = ioread32(&vmr->control);
-	vmr_stat = ioread32(&vmr->control);
+	vmr_stat = ioread32(&vmr->status);
 	cobalt_info("rx%d: cvi resolution: %dx%d\n", rx,
 		    ioread32(&cvi->frame_width), ioread32(&cvi->frame_height));
 	cobalt_info("rx%d: cvi control: %s%s%s\n", rx,

commit d736e348a0bcf25972c23d743821b91d3694e328
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Sun Jul 17 05:42:07 2016 -0300

    [media] cobalt: add cropcap support
    
    Now that the timings contain picture aspect ratio information,
    we can support cropcap to return the pixel aspect ratio.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/pci/cobalt/cobalt-v4l2.c b/drivers/media/pci/cobalt/cobalt-v4l2.c
index 5c76637900d0..3fea24613059 100644
--- a/drivers/media/pci/cobalt/cobalt-v4l2.c
+++ b/drivers/media/pci/cobalt/cobalt-v4l2.c
@@ -1084,12 +1084,33 @@ static int cobalt_g_parm(struct file *file, void *fh, struct v4l2_streamparm *a)
 	return 0;
 }
 
+static int cobalt_cropcap(struct file *file, void *fh, struct v4l2_cropcap *cc)
+{
+	struct cobalt_stream *s = video_drvdata(file);
+	struct v4l2_dv_timings timings;
+	int err = 0;
+
+	if (cc->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;
+	if (s->input == 1)
+		timings = cea1080p60;
+	else
+		err = v4l2_subdev_call(s->sd, video, g_dv_timings, &timings);
+	if (!err) {
+		cc->bounds.width = cc->defrect.width = timings.bt.width;
+		cc->bounds.height = cc->defrect.height = timings.bt.height;
+		cc->pixelaspect = v4l2_dv_timings_aspect_ratio(&timings);
+	}
+	return err;
+}
+
 static const struct v4l2_ioctl_ops cobalt_ioctl_ops = {
 	.vidioc_querycap		= cobalt_querycap,
 	.vidioc_g_parm			= cobalt_g_parm,
 	.vidioc_log_status		= cobalt_log_status,
 	.vidioc_streamon		= vb2_ioctl_streamon,
 	.vidioc_streamoff		= vb2_ioctl_streamoff,
+	.vidioc_cropcap			= cobalt_cropcap,
 	.vidioc_enum_input		= cobalt_enum_input,
 	.vidioc_g_input			= cobalt_g_input,
 	.vidioc_s_input			= cobalt_s_input,

commit 605a74e62809396cfcb786934f12be84a0da2282
Author: Hans Verkuil <hverkuil@xs4all.nl>
Date:   Sun Jul 17 06:03:15 2016 -0300

    [media] cobalt: support reduced fps
    
    Add support for reduced fps (i.e. 59.94 Hz instead of 60 Hz) for the
    HDMI output.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/pci/cobalt/cobalt-v4l2.c b/drivers/media/pci/cobalt/cobalt-v4l2.c
index d05672fe9ff9..5c76637900d0 100644
--- a/drivers/media/pci/cobalt/cobalt-v4l2.c
+++ b/drivers/media/pci/cobalt/cobalt-v4l2.c
@@ -161,8 +161,11 @@ static void cobalt_enable_output(struct cobalt_stream *s)
 	struct v4l2_subdev_format sd_fmt = {
 		.which = V4L2_SUBDEV_FORMAT_ACTIVE,
 	};
+	u64 clk = bt->pixelclock;
 
-	if (!cobalt_cpld_set_freq(cobalt, bt->pixelclock)) {
+	if (bt->flags & V4L2_DV_FL_REDUCED_FPS)
+		clk = div_u64(clk * 1000ULL, 1001);
+	if (!cobalt_cpld_set_freq(cobalt, clk)) {
 		cobalt_err("pixelclock out of range\n");
 		return;
 	}
@@ -644,7 +647,7 @@ static int cobalt_s_dv_timings(struct file *file, void *priv_fh,
 		return 0;
 	}
 
-	if (v4l2_match_dv_timings(timings, &s->timings, 0, false))
+	if (v4l2_match_dv_timings(timings, &s->timings, 0, true))
 		return 0;
 
 	if (vb2_is_busy(&s->q))

commit 36c0f8b32c4bd4f668cedfba6d97afaa84f055fb
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Fri Apr 15 09:15:05 2016 -0300

    [media] vb2: replace void *alloc_ctxs by struct device *alloc_devs
    
    Make this a proper typed array. Drop the old allocate context code since
    that is no longer used.
    
    Note that the memops functions now get a struct device pointer instead of
    the struct device ** that was there initially (actually a void pointer to
    a struct containing only a struct device pointer).
    
    This code is now a lot cleaner.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Cc: Sakari Ailus <sakari.ailus@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/pci/cobalt/cobalt-v4l2.c b/drivers/media/pci/cobalt/cobalt-v4l2.c
index 6c19cdfcf3b1..d05672fe9ff9 100644
--- a/drivers/media/pci/cobalt/cobalt-v4l2.c
+++ b/drivers/media/pci/cobalt/cobalt-v4l2.c
@@ -45,7 +45,7 @@ static const struct v4l2_dv_timings cea1080p60 = V4L2_DV_BT_CEA_1920X1080P60;
 
 static int cobalt_queue_setup(struct vb2_queue *q,
 			unsigned int *num_buffers, unsigned int *num_planes,
-			unsigned int sizes[], void *alloc_ctxs[])
+			unsigned int sizes[], struct device *alloc_devs[])
 {
 	struct cobalt_stream *s = q->drv_priv;
 	unsigned size = s->stride * s->height;

commit 2bc46b3ad3c15165f91459b07ff8682478683194
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Mon Feb 15 12:37:15 2016 -0200

    [media] media/pci: convert drivers to use the new vb2_queue dev field
    
    Stop using alloc_ctx and just fill in the device pointer.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Cc: Federico Vaga <federico.vaga@gmail.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/pci/cobalt/cobalt-v4l2.c b/drivers/media/pci/cobalt/cobalt-v4l2.c
index c0ba458f6cf3..6c19cdfcf3b1 100644
--- a/drivers/media/pci/cobalt/cobalt-v4l2.c
+++ b/drivers/media/pci/cobalt/cobalt-v4l2.c
@@ -54,7 +54,6 @@ static int cobalt_queue_setup(struct vb2_queue *q,
 		*num_buffers = 3;
 	if (*num_buffers > NR_BUFS)
 		*num_buffers = NR_BUFS;
-	alloc_ctxs[0] = s->cobalt->alloc_ctx;
 	if (*num_planes)
 		return sizes[0] < size ? -EINVAL : 0;
 	*num_planes = 1;
@@ -1224,6 +1223,7 @@ static int cobalt_node_register(struct cobalt *cobalt, int node)
 	q->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;
 	q->min_buffers_needed = 2;
 	q->lock = &s->lock;
+	q->dev = &cobalt->pci_dev->dev;
 	vdev->queue = q;
 
 	video_set_drvdata(vdev, s);

commit df9ecb0cad14b952a2865f8b3af86b2bbadfab45
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Wed Oct 28 00:50:37 2015 -0200

    [media] vb2: drop v4l2_format argument from queue_setup
    
    The queue_setup callback has a void pointer that is just for V4L2
    and is the pointer to the v4l2_format struct that was passed to
    VIDIOC_CREATE_BUFS. The idea was that drivers would use the information
    from that struct to buffers suitable for the requested format.
    
    After the vb2 split series this pointer is now a void pointer,
    which is ugly, and the reality is that all existing drivers will
    effectively just look at the sizeimage field of v4l2_format.
    
    To make this more generic the queue_setup callback is changed:
    the void pointer is dropped, instead if the *num_planes argument
    is 0, then use the current format size, if it is non-zero, then
    it contains the number of requested planes and the sizes array
    contains the requested sizes. If either is unsupported, then return
    -EINVAL, otherwise use the requested size(s).
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/pci/cobalt/cobalt-v4l2.c b/drivers/media/pci/cobalt/cobalt-v4l2.c
index 8cc78c522ac9..c0ba458f6cf3 100644
--- a/drivers/media/pci/cobalt/cobalt-v4l2.c
+++ b/drivers/media/pci/cobalt/cobalt-v4l2.c
@@ -43,11 +43,10 @@ static const struct v4l2_dv_timings cea1080p60 = V4L2_DV_BT_CEA_1920X1080P60;
 
 /* vb2 DMA streaming ops */
 
-static int cobalt_queue_setup(struct vb2_queue *q, const void *parg,
+static int cobalt_queue_setup(struct vb2_queue *q,
 			unsigned int *num_buffers, unsigned int *num_planes,
 			unsigned int sizes[], void *alloc_ctxs[])
 {
-	const struct v4l2_format *fmt = parg;
 	struct cobalt_stream *s = q->drv_priv;
 	unsigned size = s->stride * s->height;
 
@@ -55,14 +54,11 @@ static int cobalt_queue_setup(struct vb2_queue *q, const void *parg,
 		*num_buffers = 3;
 	if (*num_buffers > NR_BUFS)
 		*num_buffers = NR_BUFS;
+	alloc_ctxs[0] = s->cobalt->alloc_ctx;
+	if (*num_planes)
+		return sizes[0] < size ? -EINVAL : 0;
 	*num_planes = 1;
-	if (fmt) {
-		if (fmt->fmt.pix.sizeimage < size)
-			return -EINVAL;
-		size = fmt->fmt.pix.sizeimage;
-	}
 	sizes[0] = size;
-	alloc_ctxs[0] = s->cobalt->alloc_ctx;
 	return 0;
 }
 

commit 85f9e06c59cb93db93b163388d77d7aa9b6eed5a
Author: Hans Verkuil <hverkuil@xs4all.nl>
Date:   Fri Nov 13 09:46:26 2015 -0200

    [media] v4l2-dv-timings: add new arg to v4l2_match_dv_timings
    
    Add the new match_reduced_fps argument to v4l2_match_dv_timings().
    Depending on the situation you may or may not desire to match the
    reduced_fps flag. Typically only HDMI transmitters will need to
    check for this flag.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/pci/cobalt/cobalt-v4l2.c b/drivers/media/pci/cobalt/cobalt-v4l2.c
index b1cb061be68d..8cc78c522ac9 100644
--- a/drivers/media/pci/cobalt/cobalt-v4l2.c
+++ b/drivers/media/pci/cobalt/cobalt-v4l2.c
@@ -649,7 +649,7 @@ static int cobalt_s_dv_timings(struct file *file, void *priv_fh,
 		return 0;
 	}
 
-	if (v4l2_match_dv_timings(timings, &s->timings, 0))
+	if (v4l2_match_dv_timings(timings, &s->timings, 0, false))
 		return 0;
 
 	if (vb2_is_busy(&s->q))

commit b5dcee225ce972fecb054e104be22b2a6f65303d
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Tue Nov 10 12:01:44 2015 -0200

    [media] include/media: split I2C headers from V4L2 core
    
    Currently, include/media is messy, as it contains both the V4L2 core
    headers and some driver-specific headers on the same place. That makes
    harder to identify what core headers should be documented and what
    headers belong to I2C drivers that are included only by bridge/main
    drivers that would require the functions provided by them.
    
    Let's move those i2c specific files to its own subdirectory.
    
    The files to move were produced via the following script:
            mkdir include/media/i2c
            (cd include/media; for i in *.h; do n=`echo $i|sed s/.h$/.c/`; if [ -e ../../drivers/media/i2c/$n ]; then echo $i; git mv $i i2c/; fi; done)
            (cd include/media; for i in *.h; do n=`echo $i|sed s/.h$/.c/`; if [ -e ../../drivers/media/*/i2c/$n ]; then echo $i; git mv $i i2c/; fi; done)
            for i in include/media/*.h; do n=`basename $i`;  (for j in $(git grep -l $n); do dirname $j; done)|sort|uniq|grep -ve '^.$' > list; num=$(wc -l list|cut -d' ' -f1); if [ $num == 1 ]; then if [ "`grep i2c list`" != "" ]; then git mv $i include/media/i2c; fi; fi; done
    
    And the references corrected via this script:
        MAIN_DIR="media/"
        PREV_DIR="media/"
        DIRS="i2c/"
    
        echo "Checking affected files" >&2
        for i in $DIRS; do
            for j in $(find include/$MAIN_DIR/$i -type f -name '*.h'); do
                     n=`basename $j`
                    git grep -l $n
            done
        done|sort|uniq >files && (
            echo "Handling files..." >&2;
            echo "for i in \$(cat files|grep -v Documentation); do cat \$i | \\";
            (
                    cd include/$MAIN_DIR;
                    for j in $DIRS; do
                            for i in $(ls $j); do
                                    echo "perl -ne 's,(include [\\\"\\<])$PREV_DIR($i)([\\\"\\>]),\1$MAIN_DIR$j\2\3,; print \$_' |\\";
                            done;
                    done;
                    echo "cat > a && mv a \$i; done";
            );
            echo "Handling documentation..." >&2;
            echo "for i in MAINTAINERS \$(cat files); do cat \$i | \\";
            (
                    cd include/$MAIN_DIR;
                    for j in $DIRS; do
                            for i in $(ls $j); do
                                    echo "  perl -ne 's,include/$PREV_DIR($i)\b,include/$MAIN_DIR$j\1,; print \$_' |\\";
                            done;
                    done;
                    echo "cat > a && mv a \$i; done"
            );
        ) >script && . ./script
    
    Merged Sakari Ailus patch that moves smiapp.h to include/media/i2c.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/drivers/media/pci/cobalt/cobalt-v4l2.c b/drivers/media/pci/cobalt/cobalt-v4l2.c
index ff46e424262f..b1cb061be68d 100644
--- a/drivers/media/pci/cobalt/cobalt-v4l2.c
+++ b/drivers/media/pci/cobalt/cobalt-v4l2.c
@@ -29,8 +29,8 @@
 #include <media/v4l2-ctrls.h>
 #include <media/v4l2-event.h>
 #include <media/v4l2-dv-timings.h>
-#include <media/adv7604.h>
-#include <media/adv7842.h>
+#include <media/i2c/adv7604.h>
+#include <media/i2c/adv7842.h>
 
 #include "cobalt-alsa.h"
 #include "cobalt-cpld.h"

commit 33119e80c3b96ac81912677a6e86dc1890a5859f
Author: Junghak Sung <jh1009.sung@samsung.com>
Date:   Tue Oct 6 06:37:46 2015 -0300

    [media] media: videobuf2: Change queue_setup argument
    
    Replace struct v4l2_format * with void * to make queue_setup()
    for common use.
    And then, modify all device drivers related with this change.
    
    Signed-off-by: Junghak Sung <jh1009.sung@samsung.com>
    Signed-off-by: Geunyoung Kim <nenggun.kim@samsung.com>
    Acked-by: Seung-Woo Kim <sw0312.kim@samsung.com>
    Acked-by: Inki Dae <inki.dae@samsung.com>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    [hans.verkuil@cisco.com: fix missing const in fimc-lite.c]
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/pci/cobalt/cobalt-v4l2.c b/drivers/media/pci/cobalt/cobalt-v4l2.c
index 7d331a4c33a2..ff46e424262f 100644
--- a/drivers/media/pci/cobalt/cobalt-v4l2.c
+++ b/drivers/media/pci/cobalt/cobalt-v4l2.c
@@ -43,11 +43,11 @@ static const struct v4l2_dv_timings cea1080p60 = V4L2_DV_BT_CEA_1920X1080P60;
 
 /* vb2 DMA streaming ops */
 
-static int cobalt_queue_setup(struct vb2_queue *q,
-			const struct v4l2_format *fmt,
+static int cobalt_queue_setup(struct vb2_queue *q, const void *parg,
 			unsigned int *num_buffers, unsigned int *num_planes,
 			unsigned int sizes[], void *alloc_ctxs[])
 {
+	const struct v4l2_format *fmt = parg;
 	struct cobalt_stream *s = q->drv_priv;
 	unsigned size = s->stride * s->height;
 

commit 2d7007153f0c9b1dd00c01894df7d26ddc32b79f
Author: Junghak Sung <jh1009.sung@samsung.com>
Date:   Tue Sep 22 10:30:30 2015 -0300

    [media] media: videobuf2: Restructure vb2_buffer
    
    Remove v4l2 stuff - v4l2_buf, v4l2_plane - from struct vb2_buffer.
    
    Add new member variables - bytesused, length, offset, userptr, fd,
    data_offset - to struct vb2_plane in order to cover all information
    of v4l2_plane.
    struct vb2_plane {
            <snip>
            unsigned int            bytesused;
            unsigned int            length;
            union {
                    unsigned int    offset;
                    unsigned long   userptr;
                    int             fd;
            } m;
            unsigned int            data_offset;
    }
    
    Replace v4l2_buf with new member variables - index, type, memory - which
    are common fields for buffer management.
    struct vb2_buffer {
            <snip>
            unsigned int            index;
            unsigned int            type;
            unsigned int            memory;
            unsigned int            num_planes;
            struct vb2_plane        planes[VIDEO_MAX_PLANES];
            <snip>
    };
    
    v4l2 specific fields - flags, field, timestamp, timecode,
    sequence - are moved to vb2_v4l2_buffer in videobuf2-v4l2.c
    struct vb2_v4l2_buffer {
            struct vb2_buffer       vb2_buf;
    
            __u32                   flags;
            __u32                   field;
            struct timeval          timestamp;
            struct v4l2_timecode    timecode;
            __u32                   sequence;
    };
    
    Signed-off-by: Junghak Sung <jh1009.sung@samsung.com>
    Signed-off-by: Geunyoung Kim <nenggun.kim@samsung.com>
    Acked-by: Seung-Woo Kim <sw0312.kim@samsung.com>
    Acked-by: Inki Dae <inki.dae@samsung.com>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/pci/cobalt/cobalt-v4l2.c b/drivers/media/pci/cobalt/cobalt-v4l2.c
index 9756fd3e8af5..7d331a4c33a2 100644
--- a/drivers/media/pci/cobalt/cobalt-v4l2.c
+++ b/drivers/media/pci/cobalt/cobalt-v4l2.c
@@ -75,7 +75,7 @@ static int cobalt_buf_init(struct vb2_buffer *vb)
 	const size_t bytes =
 		COBALT_MAX_HEIGHT * max_pages_per_line * 0x20;
 	const size_t audio_bytes = ((1920 * 4) / PAGE_SIZE + 1) * 0x20;
-	struct sg_dma_desc_info *desc = &s->dma_desc_info[vb->v4l2_buf.index];
+	struct sg_dma_desc_info *desc = &s->dma_desc_info[vb->index];
 	struct sg_table *sg_desc = vb2_dma_sg_plane_desc(vb, 0);
 	unsigned size;
 	int ret;
@@ -105,17 +105,18 @@ static int cobalt_buf_init(struct vb2_buffer *vb)
 static void cobalt_buf_cleanup(struct vb2_buffer *vb)
 {
 	struct cobalt_stream *s = vb->vb2_queue->drv_priv;
-	struct sg_dma_desc_info *desc = &s->dma_desc_info[vb->v4l2_buf.index];
+	struct sg_dma_desc_info *desc = &s->dma_desc_info[vb->index];
 
 	descriptor_list_free(desc);
 }
 
 static int cobalt_buf_prepare(struct vb2_buffer *vb)
 {
+	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
 	struct cobalt_stream *s = vb->vb2_queue->drv_priv;
 
 	vb2_set_plane_payload(vb, 0, s->stride * s->height);
-	vb->v4l2_buf.field = V4L2_FIELD_NONE;
+	vbuf->field = V4L2_FIELD_NONE;
 	return 0;
 }
 
@@ -128,7 +129,7 @@ static void chain_all_buffers(struct cobalt_stream *s)
 
 	list_for_each(p, &s->bufs) {
 		cb = list_entry(p, struct cobalt_buffer, list);
-		desc[i] = &s->dma_desc_info[cb->vb.v4l2_buf.index];
+		desc[i] = &s->dma_desc_info[cb->vb.vb2_buf.index];
 		if (i > 0)
 			descriptor_list_chain(desc[i-1], desc[i]);
 		i++;
@@ -137,10 +138,11 @@ static void chain_all_buffers(struct cobalt_stream *s)
 
 static void cobalt_buf_queue(struct vb2_buffer *vb)
 {
+	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
 	struct vb2_queue *q = vb->vb2_queue;
 	struct cobalt_stream *s = q->drv_priv;
-	struct cobalt_buffer *cb = to_cobalt_buffer(vb);
-	struct sg_dma_desc_info *desc = &s->dma_desc_info[vb->v4l2_buf.index];
+	struct cobalt_buffer *cb = to_cobalt_buffer(vbuf);
+	struct sg_dma_desc_info *desc = &s->dma_desc_info[vb->index];
 	unsigned long flags;
 
 	/* Prepare new buffer */
@@ -284,7 +286,7 @@ static void cobalt_dma_start_streaming(struct cobalt_stream *s)
 			  &vo->control);
 	}
 	cb = list_first_entry(&s->bufs, struct cobalt_buffer, list);
-	omni_sg_dma_start(s, &s->dma_desc_info[cb->vb.v4l2_buf.index]);
+	omni_sg_dma_start(s, &s->dma_desc_info[cb->vb.vb2_buf.index]);
 	spin_unlock_irqrestore(&s->irqlock, flags);
 }
 
@@ -381,7 +383,7 @@ static void cobalt_dma_stop_streaming(struct cobalt_stream *s)
 	spin_lock_irqsave(&s->irqlock, flags);
 	list_for_each(p, &s->bufs) {
 		cb = list_entry(p, struct cobalt_buffer, list);
-		desc = &s->dma_desc_info[cb->vb.v4l2_buf.index];
+		desc = &s->dma_desc_info[cb->vb.vb2_buf.index];
 		/* Stop DMA after this descriptor chain */
 		descriptor_list_end_of_chain(desc);
 	}
@@ -416,7 +418,7 @@ static void cobalt_stop_streaming(struct vb2_queue *q)
 	list_for_each_safe(p, safe, &s->bufs) {
 		cb = list_entry(p, struct cobalt_buffer, list);
 		list_del(&cb->list);
-		vb2_buffer_done(&cb->vb, VB2_BUF_STATE_ERROR);
+		vb2_buffer_done(&cb->vb.vb2_buf, VB2_BUF_STATE_ERROR);
 	}
 	spin_unlock_irqrestore(&s->irqlock, flags);
 

commit 810c168c233fc531ecd3e7a6d9e0b5a3ffe85da7
Author: Hans Verkuil <hverkuil@xs4all.nl>
Date:   Fri Jul 17 08:29:40 2015 -0300

    [media] cobalt: accept unchanged timings when vb2_is_busy()
    
    When vb2_is_busy() it should still be possible to call S_DV_TIMINGS
    provided the new timings are the same as the current timings.
    
    For input 1 (test generator) the size is always 1080p, so just return
    that.
    
    Fixes a v4l2-compliance issue.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/pci/cobalt/cobalt-v4l2.c b/drivers/media/pci/cobalt/cobalt-v4l2.c
index b40c2d141b58..9756fd3e8af5 100644
--- a/drivers/media/pci/cobalt/cobalt-v4l2.c
+++ b/drivers/media/pci/cobalt/cobalt-v4l2.c
@@ -28,6 +28,7 @@
 
 #include <media/v4l2-ctrls.h>
 #include <media/v4l2-event.h>
+#include <media/v4l2-dv-timings.h>
 #include <media/adv7604.h>
 #include <media/adv7842.h>
 
@@ -641,13 +642,17 @@ static int cobalt_s_dv_timings(struct file *file, void *priv_fh,
 	struct cobalt_stream *s = video_drvdata(file);
 	int err;
 
-	if (vb2_is_busy(&s->q))
-		return -EBUSY;
-
 	if (s->input == 1) {
 		*timings = cea1080p60;
 		return 0;
 	}
+
+	if (v4l2_match_dv_timings(timings, &s->timings, 0))
+		return 0;
+
+	if (vb2_is_busy(&s->q))
+		return -EBUSY;
+
 	err = v4l2_subdev_call(s->sd,
 			video, s_dv_timings, timings);
 	if (!err) {

commit 95a86e43183eeeef72105372074f4ef127b27807
Author: Hans Verkuil <hverkuil@xs4all.nl>
Date:   Wed Jun 10 02:45:45 2015 -0300

    [media] cobalt: fix 64-bit division
    
    There are still some 64-bit division problems in the cobalt code.
    Replace it by div_u64.
    
    [mchehab@osg.samsung.com: folded with an additional diff sent by
     Hans via a priv e-mail]
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Reported-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/pci/cobalt/cobalt-v4l2.c b/drivers/media/pci/cobalt/cobalt-v4l2.c
index 6fb8812990f4..b40c2d141b58 100644
--- a/drivers/media/pci/cobalt/cobalt-v4l2.c
+++ b/drivers/media/pci/cobalt/cobalt-v4l2.c
@@ -327,7 +327,7 @@ static int cobalt_start_streaming(struct vb2_queue *q, unsigned int count)
 	iowrite32(clk_freq / 1000000, &clkloss->ref_clk_cnt_val);
 	/* The lower bound for the clock frequency is 0.5% lower as is
 	 * allowed by the spec */
-	iowrite32((((u64)bt->pixelclock * 995) / 1000) / 1000000,
+	iowrite32(div_u64(bt->pixelclock * 995, 1000000000),
 		  &clkloss->test_clk_cnt_val);
 	/* will be enabled after the first frame has been received */
 	iowrite32(bt->width * bt->height, &fw->active_length);

commit e1dedcfff1bbaa6b56a40116ee402b6d222e20c9
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Sun May 31 07:51:51 2015 -0300

    [media] cobalt: simplify colorspace code
    
    Simplify cobalt_g/try_fmt_vid_cap by not setting the colorspace fields in
    pix again (since v4l2_fill_pix_format does that already), and by using
    v4l2_fill_mbus_format in cobalt_s_fmt_vid_out which allows the get_fmt
    call to be dropped as well.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/pci/cobalt/cobalt-v4l2.c b/drivers/media/pci/cobalt/cobalt-v4l2.c
index 72b081f9cde3..6fb8812990f4 100644
--- a/drivers/media/pci/cobalt/cobalt-v4l2.c
+++ b/drivers/media/pci/cobalt/cobalt-v4l2.c
@@ -737,10 +737,6 @@ static int cobalt_g_fmt_vid_cap(struct file *file, void *priv_fh,
 		sd_fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;
 		v4l2_subdev_call(s->sd, pad, get_fmt, NULL, &sd_fmt);
 		v4l2_fill_pix_format(pix, &sd_fmt.format);
-		pix->colorspace = sd_fmt.format.colorspace;
-		pix->xfer_func = sd_fmt.format.xfer_func;
-		pix->ycbcr_enc = sd_fmt.format.ycbcr_enc;
-		pix->quantization = sd_fmt.format.quantization;
 	}
 
 	pix->pixelformat = s->pixfmt;
@@ -783,10 +779,6 @@ static int cobalt_try_fmt_vid_cap(struct file *file, void *priv_fh,
 		sd_fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;
 		v4l2_subdev_call(s->sd, pad, get_fmt, NULL, &sd_fmt);
 		v4l2_fill_pix_format(pix, &sd_fmt.format);
-		pix->colorspace = sd_fmt.format.colorspace;
-		pix->xfer_func = sd_fmt.format.xfer_func;
-		pix->ycbcr_enc = sd_fmt.format.ycbcr_enc;
-		pix->quantization = sd_fmt.format.quantization;
 	}
 
 	switch (pix->pixelformat) {
@@ -933,6 +925,7 @@ static int cobalt_s_fmt_vid_out(struct file *file, void *priv_fh,
 	struct cobalt_stream *s = video_drvdata(file);
 	struct v4l2_pix_format *pix = &f->fmt.pix;
 	struct v4l2_subdev_format sd_fmt = { 0 };
+	u32 code;
 
 	if (cobalt_try_fmt_vid_out(file, priv_fh, f))
 		return -EINVAL;
@@ -945,9 +938,11 @@ static int cobalt_s_fmt_vid_out(struct file *file, void *priv_fh,
 	switch (pix->pixelformat) {
 	case V4L2_PIX_FMT_YUYV:
 		s->bpp = COBALT_BYTES_PER_PIXEL_YUYV;
+		code = MEDIA_BUS_FMT_UYVY8_1X16;
 		break;
 	case V4L2_PIX_FMT_BGR32:
 		s->bpp = COBALT_BYTES_PER_PIXEL_RGB32;
+		code = MEDIA_BUS_FMT_RGB888_1X24;
 		break;
 	default:
 		return -EINVAL;
@@ -961,11 +956,7 @@ static int cobalt_s_fmt_vid_out(struct file *file, void *priv_fh,
 	s->ycbcr_enc = pix->ycbcr_enc;
 	s->quantization = pix->quantization;
 	sd_fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;
-	v4l2_subdev_call(s->sd, pad, get_fmt, NULL, &sd_fmt);
-	sd_fmt.format.colorspace = pix->colorspace;
-	sd_fmt.format.xfer_func = pix->xfer_func;
-	sd_fmt.format.ycbcr_enc = pix->ycbcr_enc;
-	sd_fmt.format.quantization = pix->quantization;
+	v4l2_fill_mbus_format(&sd_fmt.format, pix, code);
 	v4l2_subdev_call(s->sd, pad, set_fmt, NULL, &sd_fmt);
 	return 0;
 }

commit 136a5e9e01ed89d8891845027b3ee731bb662926
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Sun May 31 06:48:00 2015 -0300

    [media] cobalt: support transfer function
    
    Add support for the transfer function to the cobalt driver: make sure it is
    passed on to/retrieved from the sub-device correctly.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/pci/cobalt/cobalt-v4l2.c b/drivers/media/pci/cobalt/cobalt-v4l2.c
index 8b14bec123eb..72b081f9cde3 100644
--- a/drivers/media/pci/cobalt/cobalt-v4l2.c
+++ b/drivers/media/pci/cobalt/cobalt-v4l2.c
@@ -170,6 +170,7 @@ static void cobalt_enable_output(struct cobalt_stream *s)
 	}
 
 	sd_fmt.format.colorspace = s->colorspace;
+	sd_fmt.format.xfer_func = s->xfer_func;
 	sd_fmt.format.ycbcr_enc = s->ycbcr_enc;
 	sd_fmt.format.quantization = s->quantization;
 	sd_fmt.format.width = bt->width;
@@ -737,6 +738,7 @@ static int cobalt_g_fmt_vid_cap(struct file *file, void *priv_fh,
 		v4l2_subdev_call(s->sd, pad, get_fmt, NULL, &sd_fmt);
 		v4l2_fill_pix_format(pix, &sd_fmt.format);
 		pix->colorspace = sd_fmt.format.colorspace;
+		pix->xfer_func = sd_fmt.format.xfer_func;
 		pix->ycbcr_enc = sd_fmt.format.ycbcr_enc;
 		pix->quantization = sd_fmt.format.quantization;
 	}
@@ -782,6 +784,7 @@ static int cobalt_try_fmt_vid_cap(struct file *file, void *priv_fh,
 		v4l2_subdev_call(s->sd, pad, get_fmt, NULL, &sd_fmt);
 		v4l2_fill_pix_format(pix, &sd_fmt.format);
 		pix->colorspace = sd_fmt.format.colorspace;
+		pix->xfer_func = sd_fmt.format.xfer_func;
 		pix->ycbcr_enc = sd_fmt.format.ycbcr_enc;
 		pix->quantization = sd_fmt.format.quantization;
 	}
@@ -897,6 +900,7 @@ static int cobalt_g_fmt_vid_out(struct file *file, void *priv_fh,
 	pix->field = V4L2_FIELD_NONE;
 	pix->pixelformat = s->pixfmt;
 	pix->colorspace = s->colorspace;
+	pix->xfer_func = s->xfer_func;
 	pix->ycbcr_enc = s->ycbcr_enc;
 	pix->quantization = s->quantization;
 	pix->sizeimage = pix->bytesperline * pix->height;
@@ -953,11 +957,13 @@ static int cobalt_s_fmt_vid_out(struct file *file, void *priv_fh,
 	s->stride = pix->bytesperline;
 	s->pixfmt = pix->pixelformat;
 	s->colorspace = pix->colorspace;
+	s->xfer_func = pix->xfer_func;
 	s->ycbcr_enc = pix->ycbcr_enc;
 	s->quantization = pix->quantization;
 	sd_fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;
 	v4l2_subdev_call(s->sd, pad, get_fmt, NULL, &sd_fmt);
 	sd_fmt.format.colorspace = pix->colorspace;
+	sd_fmt.format.xfer_func = pix->xfer_func;
 	sd_fmt.format.ycbcr_enc = pix->ycbcr_enc;
 	sd_fmt.format.quantization = pix->quantization;
 	v4l2_subdev_call(s->sd, pad, set_fmt, NULL, &sd_fmt);

commit 4da707688b1f7628efe26058dffd6dbf3343f8ba
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Fri May 22 06:30:59 2015 -0300

    [media] cobalt: fix sparse warnings
    
    drivers/media/pci/cobalt/cobalt-v4l2.c:189:9: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:191:9: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:192:9: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:193:9: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:194:9: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:195:9: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:196:9: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:197:9: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:198:9: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:199:9: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:201:9: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:202:9: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:203:9: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:234:17: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:240:17: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:246:17: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:266:17: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:267:17: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:271:28: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:275:17: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:276:17: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:312:9: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:313:9: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:314:9: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:315:9: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:317:9: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:320:9: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:321:9: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:321:36: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:324:9: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:327:9: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:328:9: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:328:41: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:329:9: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:331:9: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:332:9: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:334:9: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:335:9: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:336:9: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:362:17: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:367:17: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:368:17: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:420:9: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:421:9: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:422:9: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:423:9: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:516:9: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:516:9: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:518:9: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:518:9: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:518:9: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:525:9: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:525:9: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:531:9: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:531:9: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:531:9: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:531:9: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:531:9: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:531:9: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:531:9: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:546:9: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:546:9: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:548:9: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:549:9: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:550:9: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:551:9: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:552:9: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:553:9: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:554:9: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:555:9: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:556:9: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:556:9: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:556:9: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:563:9: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:564:9: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:564:9: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:569:9: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:595:16: warning: dereference of noderef expression
    drivers/media/pci/cobalt/cobalt-v4l2.c:602:9: warning: dereference of noderef expression
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/pci/cobalt/cobalt-v4l2.c b/drivers/media/pci/cobalt/cobalt-v4l2.c
index 6e8d25b18b4e..8b14bec123eb 100644
--- a/drivers/media/pci/cobalt/cobalt-v4l2.c
+++ b/drivers/media/pci/cobalt/cobalt-v4l2.c
@@ -156,7 +156,7 @@ static void cobalt_enable_output(struct cobalt_stream *s)
 {
 	struct cobalt *cobalt = s->cobalt;
 	struct v4l2_bt_timings *bt = &s->timings.bt;
-	volatile struct m00514_syncgen_flow_evcnt_regmap __iomem *vo =
+	struct m00514_syncgen_flow_evcnt_regmap __iomem *vo =
 		COBALT_TX_BASE(cobalt);
 	unsigned fmt = s->pixfmt != V4L2_PIX_FMT_BGR32 ?
 			M00514_CONTROL_BITMAP_FORMAT_16_BPP_MSK : 0;
@@ -186,30 +186,31 @@ static void cobalt_enable_output(struct cobalt_stream *s)
 	}
 	v4l2_subdev_call(s->sd, pad, set_fmt, NULL, &sd_fmt);
 
-	vo->control = 0;
+	iowrite32(0, &vo->control);
 	/* 1080p60 */
-	vo->sync_generator_h_sync_length = bt->hsync;
-	vo->sync_generator_h_backporch_length = bt->hbackporch;
-	vo->sync_generator_h_active_length = bt->width;
-	vo->sync_generator_h_frontporch_length = bt->hfrontporch;
-	vo->sync_generator_v_sync_length = bt->vsync;
-	vo->sync_generator_v_backporch_length = bt->vbackporch;
-	vo->sync_generator_v_active_length = bt->height;
-	vo->sync_generator_v_frontporch_length = bt->vfrontporch;
-	vo->error_color = 0x9900c1;
-
-	vo->control = M00514_CONTROL_BITMAP_SYNC_GENERATOR_LOAD_PARAM_MSK | fmt;
-	vo->control = M00514_CONTROL_BITMAP_EVCNT_CLEAR_MSK | fmt;
-	vo->control = M00514_CONTROL_BITMAP_SYNC_GENERATOR_ENABLE_MSK |
-		      M00514_CONTROL_BITMAP_FLOW_CTRL_OUTPUT_ENABLE_MSK |
-		      fmt;
+	iowrite32(bt->hsync, &vo->sync_generator_h_sync_length);
+	iowrite32(bt->hbackporch, &vo->sync_generator_h_backporch_length);
+	iowrite32(bt->width, &vo->sync_generator_h_active_length);
+	iowrite32(bt->hfrontporch, &vo->sync_generator_h_frontporch_length);
+	iowrite32(bt->vsync, &vo->sync_generator_v_sync_length);
+	iowrite32(bt->vbackporch, &vo->sync_generator_v_backporch_length);
+	iowrite32(bt->height, &vo->sync_generator_v_active_length);
+	iowrite32(bt->vfrontporch, &vo->sync_generator_v_frontporch_length);
+	iowrite32(0x9900c1, &vo->error_color);
+
+	iowrite32(M00514_CONTROL_BITMAP_SYNC_GENERATOR_LOAD_PARAM_MSK | fmt,
+		  &vo->control);
+	iowrite32(M00514_CONTROL_BITMAP_EVCNT_CLEAR_MSK | fmt, &vo->control);
+	iowrite32(M00514_CONTROL_BITMAP_SYNC_GENERATOR_ENABLE_MSK |
+		  M00514_CONTROL_BITMAP_FLOW_CTRL_OUTPUT_ENABLE_MSK |
+		  fmt, &vo->control);
 }
 
 static void cobalt_enable_input(struct cobalt_stream *s)
 {
 	struct cobalt *cobalt = s->cobalt;
 	int ch = (int)s->video_channel;
-	volatile struct m00235_fdma_packer_regmap __iomem *packer;
+	struct m00235_fdma_packer_regmap __iomem *packer;
 	struct v4l2_subdev_format sd_fmt_yuyv = {
 		.pad = s->pad_source,
 		.which = V4L2_SUBDEV_FORMAT_ACTIVE,
@@ -231,21 +232,24 @@ static void cobalt_enable_input(struct cobalt_stream *s)
 	/* Set up FDMA packer */
 	switch (s->pixfmt) {
 	case V4L2_PIX_FMT_YUYV:
-		packer->control = M00235_CONTROL_BITMAP_ENABLE_MSK |
-			(1 << M00235_CONTROL_BITMAP_PACK_FORMAT_OFST);
+		iowrite32(M00235_CONTROL_BITMAP_ENABLE_MSK |
+			  (1 << M00235_CONTROL_BITMAP_PACK_FORMAT_OFST),
+			  &packer->control);
 		v4l2_subdev_call(s->sd, pad, set_fmt, NULL,
 				 &sd_fmt_yuyv);
 		break;
 	case V4L2_PIX_FMT_RGB24:
-		packer->control = M00235_CONTROL_BITMAP_ENABLE_MSK |
-			(2 << M00235_CONTROL_BITMAP_PACK_FORMAT_OFST);
+		iowrite32(M00235_CONTROL_BITMAP_ENABLE_MSK |
+			  (2 << M00235_CONTROL_BITMAP_PACK_FORMAT_OFST),
+			  &packer->control);
 		v4l2_subdev_call(s->sd, pad, set_fmt, NULL,
 				 &sd_fmt_rgb);
 		break;
 	case V4L2_PIX_FMT_BGR32:
-		packer->control = M00235_CONTROL_BITMAP_ENABLE_MSK |
-			M00235_CONTROL_BITMAP_ENDIAN_FORMAT_MSK |
-			(3 << M00235_CONTROL_BITMAP_PACK_FORMAT_OFST);
+		iowrite32(M00235_CONTROL_BITMAP_ENABLE_MSK |
+			  M00235_CONTROL_BITMAP_ENDIAN_FORMAT_MSK |
+			  (3 << M00235_CONTROL_BITMAP_PACK_FORMAT_OFST),
+			  &packer->control);
 		v4l2_subdev_call(s->sd, pad, set_fmt, NULL,
 				 &sd_fmt_rgb);
 		break;
@@ -256,24 +260,26 @@ static void cobalt_dma_start_streaming(struct cobalt_stream *s)
 {
 	struct cobalt *cobalt = s->cobalt;
 	int rx = s->video_channel;
-	volatile struct m00460_evcnt_regmap __iomem *evcnt =
+	struct m00460_evcnt_regmap __iomem *evcnt =
 		COBALT_CVI_EVCNT(cobalt, rx);
 	struct cobalt_buffer *cb;
 	unsigned long flags;
 
 	spin_lock_irqsave(&s->irqlock, flags);
 	if (!s->is_output) {
-		evcnt->control = M00460_CONTROL_BITMAP_CLEAR_MSK;
-		evcnt->control = M00460_CONTROL_BITMAP_ENABLE_MSK;
+		iowrite32(M00460_CONTROL_BITMAP_CLEAR_MSK, &evcnt->control);
+		iowrite32(M00460_CONTROL_BITMAP_ENABLE_MSK, &evcnt->control);
 	} else {
-		volatile struct m00514_syncgen_flow_evcnt_regmap __iomem *vo =
+		struct m00514_syncgen_flow_evcnt_regmap __iomem *vo =
 			COBALT_TX_BASE(cobalt);
-		u32 ctrl = vo->control;
+		u32 ctrl = ioread32(&vo->control);
 
 		ctrl &= ~(M00514_CONTROL_BITMAP_EVCNT_ENABLE_MSK |
 			  M00514_CONTROL_BITMAP_EVCNT_CLEAR_MSK);
-		vo->control = ctrl | M00514_CONTROL_BITMAP_EVCNT_CLEAR_MSK;
-		vo->control = ctrl | M00514_CONTROL_BITMAP_EVCNT_ENABLE_MSK;
+		iowrite32(ctrl | M00514_CONTROL_BITMAP_EVCNT_CLEAR_MSK,
+			  &vo->control);
+		iowrite32(ctrl | M00514_CONTROL_BITMAP_EVCNT_ENABLE_MSK,
+			  &vo->control);
 	}
 	cb = list_first_entry(&s->bufs, struct cobalt_buffer, list);
 	omni_sg_dma_start(s, &s->dma_desc_info[cb->vb.v4l2_buf.index]);
@@ -284,16 +290,15 @@ static int cobalt_start_streaming(struct vb2_queue *q, unsigned int count)
 {
 	struct cobalt_stream *s = q->drv_priv;
 	struct cobalt *cobalt = s->cobalt;
-	volatile struct m00233_video_measure_regmap __iomem *vmr;
-	volatile struct m00473_freewheel_regmap __iomem *fw;
-	volatile struct m00479_clk_loss_detector_regmap __iomem *clkloss;
+	struct m00233_video_measure_regmap __iomem *vmr;
+	struct m00473_freewheel_regmap __iomem *fw;
+	struct m00479_clk_loss_detector_regmap __iomem *clkloss;
 	int rx = s->video_channel;
-	volatile struct m00389_cvi_regmap __iomem *cvi =
-		COBALT_CVI(cobalt, rx);
-	volatile struct m00460_evcnt_regmap __iomem *evcnt =
-		COBALT_CVI_EVCNT(cobalt, rx);
+	struct m00389_cvi_regmap __iomem *cvi = COBALT_CVI(cobalt, rx);
+	struct m00460_evcnt_regmap __iomem *evcnt = COBALT_CVI_EVCNT(cobalt, rx);
 	struct v4l2_bt_timings *bt = &s->timings.bt;
 	u64 tot_size;
+	u32 clk_freq;
 
 	if (s->is_audio)
 		goto done;
@@ -309,32 +314,34 @@ static int cobalt_start_streaming(struct vb2_queue *q, unsigned int count)
 	vmr = COBALT_CVI_VMR(cobalt, rx);
 	clkloss = COBALT_CVI_CLK_LOSS(cobalt, rx);
 
-	evcnt->control = M00460_CONTROL_BITMAP_CLEAR_MSK;
-	evcnt->control = M00460_CONTROL_BITMAP_ENABLE_MSK;
-	cvi->frame_width = bt->width;
-	cvi->frame_height = bt->height;
+	iowrite32(M00460_CONTROL_BITMAP_CLEAR_MSK, &evcnt->control);
+	iowrite32(M00460_CONTROL_BITMAP_ENABLE_MSK, &evcnt->control);
+	iowrite32(bt->width, &cvi->frame_width);
+	iowrite32(bt->height, &cvi->frame_height);
 	tot_size = V4L2_DV_BT_FRAME_WIDTH(bt) * V4L2_DV_BT_FRAME_HEIGHT(bt);
-	vmr->hsync_timeout_val =
-		div_u64((u64)V4L2_DV_BT_FRAME_WIDTH(bt) * COBALT_CLK * 4,
-			bt->pixelclock);
-	vmr->control = M00233_CONTROL_BITMAP_ENABLE_MEASURE_MSK;
-	clkloss->ref_clk_cnt_val = fw->clk_freq / 1000000;
+	iowrite32(div_u64((u64)V4L2_DV_BT_FRAME_WIDTH(bt) * COBALT_CLK * 4,
+			  bt->pixelclock), &vmr->hsync_timeout_val);
+	iowrite32(M00233_CONTROL_BITMAP_ENABLE_MEASURE_MSK, &vmr->control);
+	clk_freq = ioread32(&fw->clk_freq);
+	iowrite32(clk_freq / 1000000, &clkloss->ref_clk_cnt_val);
 	/* The lower bound for the clock frequency is 0.5% lower as is
 	 * allowed by the spec */
-	clkloss->test_clk_cnt_val =
-		(((u64)bt->pixelclock * 995) / 1000) / 1000000;
+	iowrite32((((u64)bt->pixelclock * 995) / 1000) / 1000000,
+		  &clkloss->test_clk_cnt_val);
 	/* will be enabled after the first frame has been received */
-	fw->active_length = bt->width * bt->height;
-	fw->total_length = div_u64((u64)fw->clk_freq * tot_size, bt->pixelclock);
-	vmr->irq_triggers = M00233_IRQ_TRIGGERS_BITMAP_VACTIVE_AREA_MSK |
-		M00233_IRQ_TRIGGERS_BITMAP_HACTIVE_AREA_MSK;
-	cvi->control = 0;
-	vmr->control = M00233_CONTROL_BITMAP_ENABLE_MEASURE_MSK;
-
-	fw->output_color = 0xff;
-	clkloss->ctrl = M00479_CTRL_BITMAP_ENABLE_MSK;
-	fw->ctrl = M00473_CTRL_BITMAP_ENABLE_MSK |
-		   M00473_CTRL_BITMAP_FORCE_FREEWHEEL_MODE_MSK;
+	iowrite32(bt->width * bt->height, &fw->active_length);
+	iowrite32(div_u64((u64)clk_freq * tot_size, bt->pixelclock),
+		  &fw->total_length);
+	iowrite32(M00233_IRQ_TRIGGERS_BITMAP_VACTIVE_AREA_MSK |
+		  M00233_IRQ_TRIGGERS_BITMAP_HACTIVE_AREA_MSK,
+		  &vmr->irq_triggers);
+	iowrite32(0, &cvi->control);
+	iowrite32(M00233_CONTROL_BITMAP_ENABLE_MEASURE_MSK, &vmr->control);
+
+	iowrite32(0xff, &fw->output_color);
+	iowrite32(M00479_CTRL_BITMAP_ENABLE_MSK, &clkloss->ctrl);
+	iowrite32(M00473_CTRL_BITMAP_ENABLE_MSK |
+		  M00473_CTRL_BITMAP_FORCE_FREEWHEEL_MODE_MSK, &fw->ctrl);
 	s->unstable_frame = true;
 	s->enable_freewheel = false;
 	s->enable_cvi = false;
@@ -355,17 +362,17 @@ static void cobalt_dma_stop_streaming(struct cobalt_stream *s)
 	unsigned long flags;
 	int timeout_msec = 100;
 	int rx = s->video_channel;
-	volatile struct m00460_evcnt_regmap __iomem *evcnt =
+	struct m00460_evcnt_regmap __iomem *evcnt =
 		COBALT_CVI_EVCNT(cobalt, rx);
 
 	if (!s->is_output) {
-		evcnt->control = 0;
+		iowrite32(0, &evcnt->control);
 	} else if (!s->is_audio) {
-		volatile struct m00514_syncgen_flow_evcnt_regmap __iomem *vo =
+		struct m00514_syncgen_flow_evcnt_regmap __iomem *vo =
 			COBALT_TX_BASE(cobalt);
 
-		vo->control = M00514_CONTROL_BITMAP_EVCNT_CLEAR_MSK;
-		vo->control = 0;
+		iowrite32(M00514_CONTROL_BITMAP_EVCNT_CLEAR_MSK, &vo->control);
+		iowrite32(0, &vo->control);
 	}
 
 	/* Try to stop the DMA engine gracefully */
@@ -393,9 +400,9 @@ static void cobalt_stop_streaming(struct vb2_queue *q)
 	struct cobalt_stream *s = q->drv_priv;
 	struct cobalt *cobalt = s->cobalt;
 	int rx = s->video_channel;
-	volatile struct m00233_video_measure_regmap __iomem *vmr;
-	volatile struct m00473_freewheel_regmap __iomem *fw;
-	volatile struct m00479_clk_loss_detector_regmap __iomem *clkloss;
+	struct m00233_video_measure_regmap __iomem *vmr;
+	struct m00473_freewheel_regmap __iomem *fw;
+	struct m00479_clk_loss_detector_regmap __iomem *clkloss;
 	struct cobalt_buffer *cb;
 	struct list_head *p, *safe;
 	unsigned long flags;
@@ -417,10 +424,10 @@ static void cobalt_stop_streaming(struct vb2_queue *q)
 	fw = COBALT_CVI_FREEWHEEL(cobalt, rx);
 	vmr = COBALT_CVI_VMR(cobalt, rx);
 	clkloss = COBALT_CVI_CLK_LOSS(cobalt, rx);
-	vmr->control = 0;
-	vmr->control = M00233_CONTROL_BITMAP_ENABLE_MEASURE_MSK;
-	fw->ctrl = 0;
-	clkloss->ctrl = 0;
+	iowrite32(0, &vmr->control);
+	iowrite32(M00233_CONTROL_BITMAP_ENABLE_MEASURE_MSK, &vmr->control);
+	iowrite32(0, &fw->ctrl);
+	iowrite32(0, &clkloss->ctrl);
 }
 
 static const struct vb2_ops cobalt_qops = {
@@ -500,80 +507,87 @@ static int cobalt_querycap(struct file *file, void *priv_fh,
 
 static void cobalt_video_input_status_show(struct cobalt_stream *s)
 {
-	volatile struct m00389_cvi_regmap __iomem *cvi;
-	volatile struct m00233_video_measure_regmap __iomem *vmr;
-	volatile struct m00473_freewheel_regmap __iomem *fw;
-	volatile struct m00479_clk_loss_detector_regmap __iomem *clkloss;
-	volatile struct m00235_fdma_packer_regmap __iomem *packer;
+	struct m00389_cvi_regmap __iomem *cvi;
+	struct m00233_video_measure_regmap __iomem *vmr;
+	struct m00473_freewheel_regmap __iomem *fw;
+	struct m00479_clk_loss_detector_regmap __iomem *clkloss;
+	struct m00235_fdma_packer_regmap __iomem *packer;
 	int rx = s->video_channel;
 	struct cobalt *cobalt = s->cobalt;
+	u32 cvi_ctrl, cvi_stat;
+	u32 vmr_ctrl, vmr_stat;
 
 	cvi = COBALT_CVI(cobalt, rx);
 	vmr = COBALT_CVI_VMR(cobalt, rx);
 	fw = COBALT_CVI_FREEWHEEL(cobalt, rx);
 	clkloss = COBALT_CVI_CLK_LOSS(cobalt, rx);
 	packer = COBALT_CVI_PACKER(cobalt, rx);
+	cvi_ctrl = ioread32(&cvi->control);
+	cvi_stat = ioread32(&cvi->status);
+	vmr_ctrl = ioread32(&vmr->control);
+	vmr_stat = ioread32(&vmr->control);
 	cobalt_info("rx%d: cvi resolution: %dx%d\n", rx,
-			cvi->frame_width, cvi->frame_height);
+		    ioread32(&cvi->frame_width), ioread32(&cvi->frame_height));
 	cobalt_info("rx%d: cvi control: %s%s%s\n", rx,
-		(cvi->control & M00389_CONTROL_BITMAP_ENABLE_MSK) ?
+		(cvi_ctrl & M00389_CONTROL_BITMAP_ENABLE_MSK) ?
 			"enable " : "disable ",
-		(cvi->control & M00389_CONTROL_BITMAP_HSYNC_POLARITY_LOW_MSK) ?
+		(cvi_ctrl & M00389_CONTROL_BITMAP_HSYNC_POLARITY_LOW_MSK) ?
 			"HSync- " : "HSync+ ",
-		(cvi->control & M00389_CONTROL_BITMAP_VSYNC_POLARITY_LOW_MSK) ?
+		(cvi_ctrl & M00389_CONTROL_BITMAP_VSYNC_POLARITY_LOW_MSK) ?
 			"VSync- " : "VSync+ ");
 	cobalt_info("rx%d: cvi status: %s%s\n", rx,
-		(cvi->status & M00389_STATUS_BITMAP_LOCK_MSK) ?
+		(cvi_stat & M00389_STATUS_BITMAP_LOCK_MSK) ?
 			"lock " : "no-lock ",
-		(cvi->status & M00389_STATUS_BITMAP_ERROR_MSK) ?
+		(cvi_stat & M00389_STATUS_BITMAP_ERROR_MSK) ?
 			"error " : "no-error ");
 
 	cobalt_info("rx%d: Measurements: %s%s%s%s%s%s%s\n", rx,
-		(vmr->control & M00233_CONTROL_BITMAP_HSYNC_POLARITY_LOW_MSK) ?
+		(vmr_ctrl & M00233_CONTROL_BITMAP_HSYNC_POLARITY_LOW_MSK) ?
 			"HSync- " : "HSync+ ",
-		(vmr->control & M00233_CONTROL_BITMAP_VSYNC_POLARITY_LOW_MSK) ?
+		(vmr_ctrl & M00233_CONTROL_BITMAP_VSYNC_POLARITY_LOW_MSK) ?
 			"VSync- " : "VSync+ ",
-		(vmr->control & M00233_CONTROL_BITMAP_ENABLE_MEASURE_MSK) ?
+		(vmr_ctrl & M00233_CONTROL_BITMAP_ENABLE_MEASURE_MSK) ?
 			"enabled " : "disabled ",
-		(vmr->control & M00233_CONTROL_BITMAP_ENABLE_INTERRUPT_MSK) ?
+		(vmr_ctrl & M00233_CONTROL_BITMAP_ENABLE_INTERRUPT_MSK) ?
 			"irq-enabled " : "irq-disabled ",
-		(vmr->control & M00233_CONTROL_BITMAP_UPDATE_ON_HSYNC_MSK) ?
+		(vmr_ctrl & M00233_CONTROL_BITMAP_UPDATE_ON_HSYNC_MSK) ?
 			"update-on-hsync " : "",
-		(vmr->status & M00233_STATUS_BITMAP_HSYNC_TIMEOUT_MSK) ?
+		(vmr_stat & M00233_STATUS_BITMAP_HSYNC_TIMEOUT_MSK) ?
 			"hsync-timeout " : "",
-		(vmr->status & M00233_STATUS_BITMAP_INIT_DONE_MSK) ?
+		(vmr_stat & M00233_STATUS_BITMAP_INIT_DONE_MSK) ?
 			"init-done" : "");
 	cobalt_info("rx%d: irq_status: 0x%02x irq_triggers: 0x%02x\n", rx,
-			vmr->irq_status & 0xff, vmr->irq_triggers & 0xff);
-	cobalt_info("rx%d: vsync: %d\n", rx, vmr->vsync_time);
-	cobalt_info("rx%d: vbp: %d\n", rx, vmr->vback_porch);
-	cobalt_info("rx%d: vact: %d\n", rx, vmr->vactive_area);
-	cobalt_info("rx%d: vfb: %d\n", rx, vmr->vfront_porch);
-	cobalt_info("rx%d: hsync: %d\n", rx, vmr->hsync_time);
-	cobalt_info("rx%d: hbp: %d\n", rx, vmr->hback_porch);
-	cobalt_info("rx%d: hact: %d\n", rx, vmr->hactive_area);
-	cobalt_info("rx%d: hfb: %d\n", rx, vmr->hfront_porch);
+			ioread32(&vmr->irq_status) & 0xff,
+			ioread32(&vmr->irq_triggers) & 0xff);
+	cobalt_info("rx%d: vsync: %d\n", rx, ioread32(&vmr->vsync_time));
+	cobalt_info("rx%d: vbp: %d\n", rx, ioread32(&vmr->vback_porch));
+	cobalt_info("rx%d: vact: %d\n", rx, ioread32(&vmr->vactive_area));
+	cobalt_info("rx%d: vfb: %d\n", rx, ioread32(&vmr->vfront_porch));
+	cobalt_info("rx%d: hsync: %d\n", rx, ioread32(&vmr->hsync_time));
+	cobalt_info("rx%d: hbp: %d\n", rx, ioread32(&vmr->hback_porch));
+	cobalt_info("rx%d: hact: %d\n", rx, ioread32(&vmr->hactive_area));
+	cobalt_info("rx%d: hfb: %d\n", rx, ioread32(&vmr->hfront_porch));
 	cobalt_info("rx%d: Freewheeling: %s%s%s\n", rx,
-		(fw->ctrl & M00473_CTRL_BITMAP_ENABLE_MSK) ?
+		(ioread32(&fw->ctrl) & M00473_CTRL_BITMAP_ENABLE_MSK) ?
 			"enabled " : "disabled ",
-		(fw->ctrl & M00473_CTRL_BITMAP_FORCE_FREEWHEEL_MODE_MSK) ?
+		(ioread32(&fw->ctrl) & M00473_CTRL_BITMAP_FORCE_FREEWHEEL_MODE_MSK) ?
 			"forced " : "",
-		(fw->status & M00473_STATUS_BITMAP_FREEWHEEL_MODE_MSK) ?
+		(ioread32(&fw->status) & M00473_STATUS_BITMAP_FREEWHEEL_MODE_MSK) ?
 			"freewheeling " : "video-passthrough ");
-	vmr->irq_status = 0xff;
+	iowrite32(0xff, &vmr->irq_status);
 	cobalt_info("rx%d: Clock Loss Detection: %s%s\n", rx,
-		(clkloss->ctrl & M00479_CTRL_BITMAP_ENABLE_MSK) ?
+		(ioread32(&clkloss->ctrl) & M00479_CTRL_BITMAP_ENABLE_MSK) ?
 			"enabled " : "disabled ",
-		(clkloss->status & M00479_STATUS_BITMAP_CLOCK_MISSING_MSK) ?
+		(ioread32(&clkloss->status) & M00479_STATUS_BITMAP_CLOCK_MISSING_MSK) ?
 			"clock-missing " : "found-clock ");
-	cobalt_info("rx%d: Packer: %x\n", rx, packer->control);
+	cobalt_info("rx%d: Packer: %x\n", rx, ioread32(&packer->control));
 }
 
 static int cobalt_log_status(struct file *file, void *priv_fh)
 {
 	struct cobalt_stream *s = video_drvdata(file);
 	struct cobalt *cobalt = s->cobalt;
-	volatile struct m00514_syncgen_flow_evcnt_regmap __iomem *vo =
+	struct m00514_syncgen_flow_evcnt_regmap __iomem *vo =
 		COBALT_TX_BASE(cobalt);
 	u8 stat;
 
@@ -592,14 +606,14 @@ static int cobalt_log_status(struct file *file, void *priv_fh)
 		return 0;
 	}
 
-	stat = vo->rd_status;
+	stat = ioread32(&vo->rd_status);
 
 	cobalt_info("tx: status: %s%s\n",
 		(stat & M00514_RD_STATUS_BITMAP_FLOW_CTRL_NO_DATA_ERROR_MSK) ?
 			"no_data " : "",
 		(stat & M00514_RD_STATUS_BITMAP_READY_BUFFER_FULL_MSK) ?
 			"ready_buffer_full " : "");
-	cobalt_info("tx: evcnt: %d\n", vo->rd_evcnt_count);
+	cobalt_info("tx: evcnt: %d\n", ioread32(&vo->rd_evcnt_count));
 	return 0;
 }
 

commit 99cabb187100e5bae12ec835431a2868e5d9afc9
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Thu May 21 09:37:40 2015 -0300

    [media] cobalt: fix 64-bit division link error
    
    [linuxtv-media:master 1023/1029] ERROR: "__aeabi_uldivmod" [drivers/media/pci/cobalt/cobalt.ko] undefined!
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Reported-by: kbuild test robot <fengguang.wu@intel.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/pci/cobalt/cobalt-v4l2.c b/drivers/media/pci/cobalt/cobalt-v4l2.c
index bf80f11d94d8..6e8d25b18b4e 100644
--- a/drivers/media/pci/cobalt/cobalt-v4l2.c
+++ b/drivers/media/pci/cobalt/cobalt-v4l2.c
@@ -22,6 +22,7 @@
 
 #include <linux/dma-mapping.h>
 #include <linux/delay.h>
+#include <linux/math64.h>
 #include <linux/pci.h>
 #include <linux/v4l2-dv-timings.h>
 
@@ -314,8 +315,8 @@ static int cobalt_start_streaming(struct vb2_queue *q, unsigned int count)
 	cvi->frame_height = bt->height;
 	tot_size = V4L2_DV_BT_FRAME_WIDTH(bt) * V4L2_DV_BT_FRAME_HEIGHT(bt);
 	vmr->hsync_timeout_val =
-		((u64)V4L2_DV_BT_FRAME_WIDTH(bt) * COBALT_CLK * 4) /
-		bt->pixelclock;
+		div_u64((u64)V4L2_DV_BT_FRAME_WIDTH(bt) * COBALT_CLK * 4,
+			bt->pixelclock);
 	vmr->control = M00233_CONTROL_BITMAP_ENABLE_MEASURE_MSK;
 	clkloss->ref_clk_cnt_val = fw->clk_freq / 1000000;
 	/* The lower bound for the clock frequency is 0.5% lower as is
@@ -324,7 +325,7 @@ static int cobalt_start_streaming(struct vb2_queue *q, unsigned int count)
 		(((u64)bt->pixelclock * 995) / 1000) / 1000000;
 	/* will be enabled after the first frame has been received */
 	fw->active_length = bt->width * bt->height;
-	fw->total_length = ((u64)fw->clk_freq * tot_size) / bt->pixelclock;
+	fw->total_length = div_u64((u64)fw->clk_freq * tot_size, bt->pixelclock);
 	vmr->irq_triggers = M00233_IRQ_TRIGGERS_BITMAP_VACTIVE_AREA_MSK |
 		M00233_IRQ_TRIGGERS_BITMAP_HACTIVE_AREA_MSK;
 	cvi->control = 0;

commit 85756a069c55e0315ac5990806899cfb607b987f
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Tue May 12 08:52:21 2015 -0300

    [media] cobalt: add new driver
    
    The cobalt device is a PCIe card with 4 HDMI inputs (adv7604) and a
    connector that can be used to hook up an adv7511 transmitter or an
    adv7842 receiver daughterboard.
    
    This device is used within Cisco but is sadly not available outside
    of Cisco. Nevertheless it is a very interesting driver that can serve
    as an example of how to support HDMI hardware and how to use the popular
    adv devices.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/pci/cobalt/cobalt-v4l2.c b/drivers/media/pci/cobalt/cobalt-v4l2.c
new file mode 100644
index 000000000000..bf80f11d94d8
--- /dev/null
+++ b/drivers/media/pci/cobalt/cobalt-v4l2.c
@@ -0,0 +1,1260 @@
+/*
+ *  cobalt V4L2 API
+ *
+ *  Derived from ivtv-ioctl.c and cx18-fileops.c
+ *
+ *  Copyright 2012-2015 Cisco Systems, Inc. and/or its affiliates.
+ *  All rights reserved.
+ *
+ *  This program is free software; you may redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ *  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ *  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ *  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ *  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ *  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ *  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ *  SOFTWARE.
+ */
+
+#include <linux/dma-mapping.h>
+#include <linux/delay.h>
+#include <linux/pci.h>
+#include <linux/v4l2-dv-timings.h>
+
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-event.h>
+#include <media/adv7604.h>
+#include <media/adv7842.h>
+
+#include "cobalt-alsa.h"
+#include "cobalt-cpld.h"
+#include "cobalt-driver.h"
+#include "cobalt-v4l2.h"
+#include "cobalt-irq.h"
+#include "cobalt-omnitek.h"
+
+static const struct v4l2_dv_timings cea1080p60 = V4L2_DV_BT_CEA_1920X1080P60;
+
+/* vb2 DMA streaming ops */
+
+static int cobalt_queue_setup(struct vb2_queue *q,
+			const struct v4l2_format *fmt,
+			unsigned int *num_buffers, unsigned int *num_planes,
+			unsigned int sizes[], void *alloc_ctxs[])
+{
+	struct cobalt_stream *s = q->drv_priv;
+	unsigned size = s->stride * s->height;
+
+	if (*num_buffers < 3)
+		*num_buffers = 3;
+	if (*num_buffers > NR_BUFS)
+		*num_buffers = NR_BUFS;
+	*num_planes = 1;
+	if (fmt) {
+		if (fmt->fmt.pix.sizeimage < size)
+			return -EINVAL;
+		size = fmt->fmt.pix.sizeimage;
+	}
+	sizes[0] = size;
+	alloc_ctxs[0] = s->cobalt->alloc_ctx;
+	return 0;
+}
+
+static int cobalt_buf_init(struct vb2_buffer *vb)
+{
+	struct cobalt_stream *s = vb->vb2_queue->drv_priv;
+	struct cobalt *cobalt = s->cobalt;
+	const size_t max_pages_per_line =
+		(COBALT_MAX_WIDTH * COBALT_MAX_BPP) / PAGE_SIZE + 2;
+	const size_t bytes =
+		COBALT_MAX_HEIGHT * max_pages_per_line * 0x20;
+	const size_t audio_bytes = ((1920 * 4) / PAGE_SIZE + 1) * 0x20;
+	struct sg_dma_desc_info *desc = &s->dma_desc_info[vb->v4l2_buf.index];
+	struct sg_table *sg_desc = vb2_dma_sg_plane_desc(vb, 0);
+	unsigned size;
+	int ret;
+
+	size = s->stride * s->height;
+	if (vb2_plane_size(vb, 0) < size) {
+		cobalt_info("data will not fit into plane (%lu < %u)\n",
+					vb2_plane_size(vb, 0), size);
+		return -EINVAL;
+	}
+
+	if (desc->virt == NULL) {
+		desc->dev = &cobalt->pci_dev->dev;
+		descriptor_list_allocate(desc,
+			s->is_audio ? audio_bytes : bytes);
+		if (desc->virt == NULL)
+			return -ENOMEM;
+	}
+	ret = descriptor_list_create(cobalt, sg_desc->sgl,
+			!s->is_output, sg_desc->nents, size,
+			s->width * s->bpp, s->stride, desc);
+	if (ret)
+		descriptor_list_free(desc);
+	return ret;
+}
+
+static void cobalt_buf_cleanup(struct vb2_buffer *vb)
+{
+	struct cobalt_stream *s = vb->vb2_queue->drv_priv;
+	struct sg_dma_desc_info *desc = &s->dma_desc_info[vb->v4l2_buf.index];
+
+	descriptor_list_free(desc);
+}
+
+static int cobalt_buf_prepare(struct vb2_buffer *vb)
+{
+	struct cobalt_stream *s = vb->vb2_queue->drv_priv;
+
+	vb2_set_plane_payload(vb, 0, s->stride * s->height);
+	vb->v4l2_buf.field = V4L2_FIELD_NONE;
+	return 0;
+}
+
+static void chain_all_buffers(struct cobalt_stream *s)
+{
+	struct sg_dma_desc_info *desc[NR_BUFS];
+	struct cobalt_buffer *cb;
+	struct list_head *p;
+	int i = 0;
+
+	list_for_each(p, &s->bufs) {
+		cb = list_entry(p, struct cobalt_buffer, list);
+		desc[i] = &s->dma_desc_info[cb->vb.v4l2_buf.index];
+		if (i > 0)
+			descriptor_list_chain(desc[i-1], desc[i]);
+		i++;
+	}
+}
+
+static void cobalt_buf_queue(struct vb2_buffer *vb)
+{
+	struct vb2_queue *q = vb->vb2_queue;
+	struct cobalt_stream *s = q->drv_priv;
+	struct cobalt_buffer *cb = to_cobalt_buffer(vb);
+	struct sg_dma_desc_info *desc = &s->dma_desc_info[vb->v4l2_buf.index];
+	unsigned long flags;
+
+	/* Prepare new buffer */
+	descriptor_list_loopback(desc);
+	descriptor_list_interrupt_disable(desc);
+
+	spin_lock_irqsave(&s->irqlock, flags);
+	list_add_tail(&cb->list, &s->bufs);
+	chain_all_buffers(s);
+	spin_unlock_irqrestore(&s->irqlock, flags);
+}
+
+static void cobalt_enable_output(struct cobalt_stream *s)
+{
+	struct cobalt *cobalt = s->cobalt;
+	struct v4l2_bt_timings *bt = &s->timings.bt;
+	volatile struct m00514_syncgen_flow_evcnt_regmap __iomem *vo =
+		COBALT_TX_BASE(cobalt);
+	unsigned fmt = s->pixfmt != V4L2_PIX_FMT_BGR32 ?
+			M00514_CONTROL_BITMAP_FORMAT_16_BPP_MSK : 0;
+	struct v4l2_subdev_format sd_fmt = {
+		.which = V4L2_SUBDEV_FORMAT_ACTIVE,
+	};
+
+	if (!cobalt_cpld_set_freq(cobalt, bt->pixelclock)) {
+		cobalt_err("pixelclock out of range\n");
+		return;
+	}
+
+	sd_fmt.format.colorspace = s->colorspace;
+	sd_fmt.format.ycbcr_enc = s->ycbcr_enc;
+	sd_fmt.format.quantization = s->quantization;
+	sd_fmt.format.width = bt->width;
+	sd_fmt.format.height = bt->height;
+
+	/* Set up FDMA packer */
+	switch (s->pixfmt) {
+	case V4L2_PIX_FMT_YUYV:
+		sd_fmt.format.code = MEDIA_BUS_FMT_UYVY8_1X16;
+		break;
+	case V4L2_PIX_FMT_BGR32:
+		sd_fmt.format.code = MEDIA_BUS_FMT_RGB888_1X24;
+		break;
+	}
+	v4l2_subdev_call(s->sd, pad, set_fmt, NULL, &sd_fmt);
+
+	vo->control = 0;
+	/* 1080p60 */
+	vo->sync_generator_h_sync_length = bt->hsync;
+	vo->sync_generator_h_backporch_length = bt->hbackporch;
+	vo->sync_generator_h_active_length = bt->width;
+	vo->sync_generator_h_frontporch_length = bt->hfrontporch;
+	vo->sync_generator_v_sync_length = bt->vsync;
+	vo->sync_generator_v_backporch_length = bt->vbackporch;
+	vo->sync_generator_v_active_length = bt->height;
+	vo->sync_generator_v_frontporch_length = bt->vfrontporch;
+	vo->error_color = 0x9900c1;
+
+	vo->control = M00514_CONTROL_BITMAP_SYNC_GENERATOR_LOAD_PARAM_MSK | fmt;
+	vo->control = M00514_CONTROL_BITMAP_EVCNT_CLEAR_MSK | fmt;
+	vo->control = M00514_CONTROL_BITMAP_SYNC_GENERATOR_ENABLE_MSK |
+		      M00514_CONTROL_BITMAP_FLOW_CTRL_OUTPUT_ENABLE_MSK |
+		      fmt;
+}
+
+static void cobalt_enable_input(struct cobalt_stream *s)
+{
+	struct cobalt *cobalt = s->cobalt;
+	int ch = (int)s->video_channel;
+	volatile struct m00235_fdma_packer_regmap __iomem *packer;
+	struct v4l2_subdev_format sd_fmt_yuyv = {
+		.pad = s->pad_source,
+		.which = V4L2_SUBDEV_FORMAT_ACTIVE,
+		.format.code = MEDIA_BUS_FMT_YUYV8_1X16,
+	};
+	struct v4l2_subdev_format sd_fmt_rgb = {
+		.pad = s->pad_source,
+		.which = V4L2_SUBDEV_FORMAT_ACTIVE,
+		.format.code = MEDIA_BUS_FMT_RGB888_1X24,
+	};
+
+	cobalt_dbg(1, "video_channel %d (%s, %s)\n",
+		   s->video_channel,
+		   s->input == 0 ? "hdmi" : "generator",
+		   "YUYV");
+
+	packer = COBALT_CVI_PACKER(cobalt, ch);
+
+	/* Set up FDMA packer */
+	switch (s->pixfmt) {
+	case V4L2_PIX_FMT_YUYV:
+		packer->control = M00235_CONTROL_BITMAP_ENABLE_MSK |
+			(1 << M00235_CONTROL_BITMAP_PACK_FORMAT_OFST);
+		v4l2_subdev_call(s->sd, pad, set_fmt, NULL,
+				 &sd_fmt_yuyv);
+		break;
+	case V4L2_PIX_FMT_RGB24:
+		packer->control = M00235_CONTROL_BITMAP_ENABLE_MSK |
+			(2 << M00235_CONTROL_BITMAP_PACK_FORMAT_OFST);
+		v4l2_subdev_call(s->sd, pad, set_fmt, NULL,
+				 &sd_fmt_rgb);
+		break;
+	case V4L2_PIX_FMT_BGR32:
+		packer->control = M00235_CONTROL_BITMAP_ENABLE_MSK |
+			M00235_CONTROL_BITMAP_ENDIAN_FORMAT_MSK |
+			(3 << M00235_CONTROL_BITMAP_PACK_FORMAT_OFST);
+		v4l2_subdev_call(s->sd, pad, set_fmt, NULL,
+				 &sd_fmt_rgb);
+		break;
+	}
+}
+
+static void cobalt_dma_start_streaming(struct cobalt_stream *s)
+{
+	struct cobalt *cobalt = s->cobalt;
+	int rx = s->video_channel;
+	volatile struct m00460_evcnt_regmap __iomem *evcnt =
+		COBALT_CVI_EVCNT(cobalt, rx);
+	struct cobalt_buffer *cb;
+	unsigned long flags;
+
+	spin_lock_irqsave(&s->irqlock, flags);
+	if (!s->is_output) {
+		evcnt->control = M00460_CONTROL_BITMAP_CLEAR_MSK;
+		evcnt->control = M00460_CONTROL_BITMAP_ENABLE_MSK;
+	} else {
+		volatile struct m00514_syncgen_flow_evcnt_regmap __iomem *vo =
+			COBALT_TX_BASE(cobalt);
+		u32 ctrl = vo->control;
+
+		ctrl &= ~(M00514_CONTROL_BITMAP_EVCNT_ENABLE_MSK |
+			  M00514_CONTROL_BITMAP_EVCNT_CLEAR_MSK);
+		vo->control = ctrl | M00514_CONTROL_BITMAP_EVCNT_CLEAR_MSK;
+		vo->control = ctrl | M00514_CONTROL_BITMAP_EVCNT_ENABLE_MSK;
+	}
+	cb = list_first_entry(&s->bufs, struct cobalt_buffer, list);
+	omni_sg_dma_start(s, &s->dma_desc_info[cb->vb.v4l2_buf.index]);
+	spin_unlock_irqrestore(&s->irqlock, flags);
+}
+
+static int cobalt_start_streaming(struct vb2_queue *q, unsigned int count)
+{
+	struct cobalt_stream *s = q->drv_priv;
+	struct cobalt *cobalt = s->cobalt;
+	volatile struct m00233_video_measure_regmap __iomem *vmr;
+	volatile struct m00473_freewheel_regmap __iomem *fw;
+	volatile struct m00479_clk_loss_detector_regmap __iomem *clkloss;
+	int rx = s->video_channel;
+	volatile struct m00389_cvi_regmap __iomem *cvi =
+		COBALT_CVI(cobalt, rx);
+	volatile struct m00460_evcnt_regmap __iomem *evcnt =
+		COBALT_CVI_EVCNT(cobalt, rx);
+	struct v4l2_bt_timings *bt = &s->timings.bt;
+	u64 tot_size;
+
+	if (s->is_audio)
+		goto done;
+	if (s->is_output) {
+		s->unstable_frame = false;
+		cobalt_enable_output(s);
+		goto done;
+	}
+
+	cobalt_enable_input(s);
+
+	fw = COBALT_CVI_FREEWHEEL(cobalt, rx);
+	vmr = COBALT_CVI_VMR(cobalt, rx);
+	clkloss = COBALT_CVI_CLK_LOSS(cobalt, rx);
+
+	evcnt->control = M00460_CONTROL_BITMAP_CLEAR_MSK;
+	evcnt->control = M00460_CONTROL_BITMAP_ENABLE_MSK;
+	cvi->frame_width = bt->width;
+	cvi->frame_height = bt->height;
+	tot_size = V4L2_DV_BT_FRAME_WIDTH(bt) * V4L2_DV_BT_FRAME_HEIGHT(bt);
+	vmr->hsync_timeout_val =
+		((u64)V4L2_DV_BT_FRAME_WIDTH(bt) * COBALT_CLK * 4) /
+		bt->pixelclock;
+	vmr->control = M00233_CONTROL_BITMAP_ENABLE_MEASURE_MSK;
+	clkloss->ref_clk_cnt_val = fw->clk_freq / 1000000;
+	/* The lower bound for the clock frequency is 0.5% lower as is
+	 * allowed by the spec */
+	clkloss->test_clk_cnt_val =
+		(((u64)bt->pixelclock * 995) / 1000) / 1000000;
+	/* will be enabled after the first frame has been received */
+	fw->active_length = bt->width * bt->height;
+	fw->total_length = ((u64)fw->clk_freq * tot_size) / bt->pixelclock;
+	vmr->irq_triggers = M00233_IRQ_TRIGGERS_BITMAP_VACTIVE_AREA_MSK |
+		M00233_IRQ_TRIGGERS_BITMAP_HACTIVE_AREA_MSK;
+	cvi->control = 0;
+	vmr->control = M00233_CONTROL_BITMAP_ENABLE_MEASURE_MSK;
+
+	fw->output_color = 0xff;
+	clkloss->ctrl = M00479_CTRL_BITMAP_ENABLE_MSK;
+	fw->ctrl = M00473_CTRL_BITMAP_ENABLE_MSK |
+		   M00473_CTRL_BITMAP_FORCE_FREEWHEEL_MODE_MSK;
+	s->unstable_frame = true;
+	s->enable_freewheel = false;
+	s->enable_cvi = false;
+	s->skip_first_frames = 0;
+
+done:
+	s->sequence = 0;
+	cobalt_dma_start_streaming(s);
+	return 0;
+}
+
+static void cobalt_dma_stop_streaming(struct cobalt_stream *s)
+{
+	struct cobalt *cobalt = s->cobalt;
+	struct sg_dma_desc_info *desc;
+	struct cobalt_buffer *cb;
+	struct list_head *p;
+	unsigned long flags;
+	int timeout_msec = 100;
+	int rx = s->video_channel;
+	volatile struct m00460_evcnt_regmap __iomem *evcnt =
+		COBALT_CVI_EVCNT(cobalt, rx);
+
+	if (!s->is_output) {
+		evcnt->control = 0;
+	} else if (!s->is_audio) {
+		volatile struct m00514_syncgen_flow_evcnt_regmap __iomem *vo =
+			COBALT_TX_BASE(cobalt);
+
+		vo->control = M00514_CONTROL_BITMAP_EVCNT_CLEAR_MSK;
+		vo->control = 0;
+	}
+
+	/* Try to stop the DMA engine gracefully */
+	spin_lock_irqsave(&s->irqlock, flags);
+	list_for_each(p, &s->bufs) {
+		cb = list_entry(p, struct cobalt_buffer, list);
+		desc = &s->dma_desc_info[cb->vb.v4l2_buf.index];
+		/* Stop DMA after this descriptor chain */
+		descriptor_list_end_of_chain(desc);
+	}
+	spin_unlock_irqrestore(&s->irqlock, flags);
+
+	/* Wait 100 milisecond for DMA to finish, abort on timeout. */
+	if (!wait_event_timeout(s->q.done_wq, is_dma_done(s),
+				msecs_to_jiffies(timeout_msec))) {
+		omni_sg_dma_abort_channel(s);
+		pr_warn("aborted\n");
+	}
+	cobalt_write_bar0(cobalt, DMA_INTERRUPT_STATUS_REG,
+			1 << s->dma_channel);
+}
+
+static void cobalt_stop_streaming(struct vb2_queue *q)
+{
+	struct cobalt_stream *s = q->drv_priv;
+	struct cobalt *cobalt = s->cobalt;
+	int rx = s->video_channel;
+	volatile struct m00233_video_measure_regmap __iomem *vmr;
+	volatile struct m00473_freewheel_regmap __iomem *fw;
+	volatile struct m00479_clk_loss_detector_regmap __iomem *clkloss;
+	struct cobalt_buffer *cb;
+	struct list_head *p, *safe;
+	unsigned long flags;
+
+	cobalt_dma_stop_streaming(s);
+
+	/* Return all buffers to user space */
+	spin_lock_irqsave(&s->irqlock, flags);
+	list_for_each_safe(p, safe, &s->bufs) {
+		cb = list_entry(p, struct cobalt_buffer, list);
+		list_del(&cb->list);
+		vb2_buffer_done(&cb->vb, VB2_BUF_STATE_ERROR);
+	}
+	spin_unlock_irqrestore(&s->irqlock, flags);
+
+	if (s->is_audio || s->is_output)
+		return;
+
+	fw = COBALT_CVI_FREEWHEEL(cobalt, rx);
+	vmr = COBALT_CVI_VMR(cobalt, rx);
+	clkloss = COBALT_CVI_CLK_LOSS(cobalt, rx);
+	vmr->control = 0;
+	vmr->control = M00233_CONTROL_BITMAP_ENABLE_MEASURE_MSK;
+	fw->ctrl = 0;
+	clkloss->ctrl = 0;
+}
+
+static const struct vb2_ops cobalt_qops = {
+	.queue_setup = cobalt_queue_setup,
+	.buf_init = cobalt_buf_init,
+	.buf_cleanup = cobalt_buf_cleanup,
+	.buf_prepare = cobalt_buf_prepare,
+	.buf_queue = cobalt_buf_queue,
+	.start_streaming = cobalt_start_streaming,
+	.stop_streaming = cobalt_stop_streaming,
+	.wait_prepare = vb2_ops_wait_prepare,
+	.wait_finish = vb2_ops_wait_finish,
+};
+
+/* V4L2 ioctls */
+
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+static int cobalt_cobaltc(struct cobalt *cobalt, unsigned int cmd, void *arg)
+{
+	struct v4l2_dbg_register *regs = arg;
+	void __iomem *adrs = cobalt->bar1 + regs->reg;
+
+	cobalt_info("cobalt_cobaltc: adrs = %p\n", adrs);
+
+	if (!capable(CAP_SYS_ADMIN))
+		return -EPERM;
+
+	regs->size = 4;
+	if (cmd == VIDIOC_DBG_S_REGISTER)
+		iowrite32(regs->val, adrs);
+	else
+		regs->val = ioread32(adrs);
+	return 0;
+}
+
+static int cobalt_g_register(struct file *file, void *priv_fh,
+		struct v4l2_dbg_register *reg)
+{
+	struct cobalt_stream *s = video_drvdata(file);
+	struct cobalt *cobalt = s->cobalt;
+
+	return cobalt_cobaltc(cobalt, VIDIOC_DBG_G_REGISTER, reg);
+}
+
+static int cobalt_s_register(struct file *file, void *priv_fh,
+		const struct v4l2_dbg_register *reg)
+{
+	struct cobalt_stream *s = video_drvdata(file);
+	struct cobalt *cobalt = s->cobalt;
+
+	return cobalt_cobaltc(cobalt, VIDIOC_DBG_S_REGISTER,
+			(struct v4l2_dbg_register *)reg);
+}
+#endif
+
+static int cobalt_querycap(struct file *file, void *priv_fh,
+				struct v4l2_capability *vcap)
+{
+	struct cobalt_stream *s = video_drvdata(file);
+	struct cobalt *cobalt = s->cobalt;
+
+	strlcpy(vcap->driver, "cobalt", sizeof(vcap->driver));
+	strlcpy(vcap->card, "cobalt", sizeof(vcap->card));
+	snprintf(vcap->bus_info, sizeof(vcap->bus_info),
+		 "PCIe:%s", pci_name(cobalt->pci_dev));
+	vcap->device_caps = V4L2_CAP_STREAMING | V4L2_CAP_READWRITE;
+	if (s->is_output)
+		vcap->device_caps |= V4L2_CAP_VIDEO_OUTPUT;
+	else
+		vcap->device_caps |= V4L2_CAP_VIDEO_CAPTURE;
+	vcap->capabilities = vcap->device_caps | V4L2_CAP_DEVICE_CAPS |
+		V4L2_CAP_VIDEO_CAPTURE;
+	if (cobalt->have_hsma_tx)
+		vcap->capabilities |= V4L2_CAP_VIDEO_OUTPUT;
+	return 0;
+}
+
+static void cobalt_video_input_status_show(struct cobalt_stream *s)
+{
+	volatile struct m00389_cvi_regmap __iomem *cvi;
+	volatile struct m00233_video_measure_regmap __iomem *vmr;
+	volatile struct m00473_freewheel_regmap __iomem *fw;
+	volatile struct m00479_clk_loss_detector_regmap __iomem *clkloss;
+	volatile struct m00235_fdma_packer_regmap __iomem *packer;
+	int rx = s->video_channel;
+	struct cobalt *cobalt = s->cobalt;
+
+	cvi = COBALT_CVI(cobalt, rx);
+	vmr = COBALT_CVI_VMR(cobalt, rx);
+	fw = COBALT_CVI_FREEWHEEL(cobalt, rx);
+	clkloss = COBALT_CVI_CLK_LOSS(cobalt, rx);
+	packer = COBALT_CVI_PACKER(cobalt, rx);
+	cobalt_info("rx%d: cvi resolution: %dx%d\n", rx,
+			cvi->frame_width, cvi->frame_height);
+	cobalt_info("rx%d: cvi control: %s%s%s\n", rx,
+		(cvi->control & M00389_CONTROL_BITMAP_ENABLE_MSK) ?
+			"enable " : "disable ",
+		(cvi->control & M00389_CONTROL_BITMAP_HSYNC_POLARITY_LOW_MSK) ?
+			"HSync- " : "HSync+ ",
+		(cvi->control & M00389_CONTROL_BITMAP_VSYNC_POLARITY_LOW_MSK) ?
+			"VSync- " : "VSync+ ");
+	cobalt_info("rx%d: cvi status: %s%s\n", rx,
+		(cvi->status & M00389_STATUS_BITMAP_LOCK_MSK) ?
+			"lock " : "no-lock ",
+		(cvi->status & M00389_STATUS_BITMAP_ERROR_MSK) ?
+			"error " : "no-error ");
+
+	cobalt_info("rx%d: Measurements: %s%s%s%s%s%s%s\n", rx,
+		(vmr->control & M00233_CONTROL_BITMAP_HSYNC_POLARITY_LOW_MSK) ?
+			"HSync- " : "HSync+ ",
+		(vmr->control & M00233_CONTROL_BITMAP_VSYNC_POLARITY_LOW_MSK) ?
+			"VSync- " : "VSync+ ",
+		(vmr->control & M00233_CONTROL_BITMAP_ENABLE_MEASURE_MSK) ?
+			"enabled " : "disabled ",
+		(vmr->control & M00233_CONTROL_BITMAP_ENABLE_INTERRUPT_MSK) ?
+			"irq-enabled " : "irq-disabled ",
+		(vmr->control & M00233_CONTROL_BITMAP_UPDATE_ON_HSYNC_MSK) ?
+			"update-on-hsync " : "",
+		(vmr->status & M00233_STATUS_BITMAP_HSYNC_TIMEOUT_MSK) ?
+			"hsync-timeout " : "",
+		(vmr->status & M00233_STATUS_BITMAP_INIT_DONE_MSK) ?
+			"init-done" : "");
+	cobalt_info("rx%d: irq_status: 0x%02x irq_triggers: 0x%02x\n", rx,
+			vmr->irq_status & 0xff, vmr->irq_triggers & 0xff);
+	cobalt_info("rx%d: vsync: %d\n", rx, vmr->vsync_time);
+	cobalt_info("rx%d: vbp: %d\n", rx, vmr->vback_porch);
+	cobalt_info("rx%d: vact: %d\n", rx, vmr->vactive_area);
+	cobalt_info("rx%d: vfb: %d\n", rx, vmr->vfront_porch);
+	cobalt_info("rx%d: hsync: %d\n", rx, vmr->hsync_time);
+	cobalt_info("rx%d: hbp: %d\n", rx, vmr->hback_porch);
+	cobalt_info("rx%d: hact: %d\n", rx, vmr->hactive_area);
+	cobalt_info("rx%d: hfb: %d\n", rx, vmr->hfront_porch);
+	cobalt_info("rx%d: Freewheeling: %s%s%s\n", rx,
+		(fw->ctrl & M00473_CTRL_BITMAP_ENABLE_MSK) ?
+			"enabled " : "disabled ",
+		(fw->ctrl & M00473_CTRL_BITMAP_FORCE_FREEWHEEL_MODE_MSK) ?
+			"forced " : "",
+		(fw->status & M00473_STATUS_BITMAP_FREEWHEEL_MODE_MSK) ?
+			"freewheeling " : "video-passthrough ");
+	vmr->irq_status = 0xff;
+	cobalt_info("rx%d: Clock Loss Detection: %s%s\n", rx,
+		(clkloss->ctrl & M00479_CTRL_BITMAP_ENABLE_MSK) ?
+			"enabled " : "disabled ",
+		(clkloss->status & M00479_STATUS_BITMAP_CLOCK_MISSING_MSK) ?
+			"clock-missing " : "found-clock ");
+	cobalt_info("rx%d: Packer: %x\n", rx, packer->control);
+}
+
+static int cobalt_log_status(struct file *file, void *priv_fh)
+{
+	struct cobalt_stream *s = video_drvdata(file);
+	struct cobalt *cobalt = s->cobalt;
+	volatile struct m00514_syncgen_flow_evcnt_regmap __iomem *vo =
+		COBALT_TX_BASE(cobalt);
+	u8 stat;
+
+	cobalt_info("%s", cobalt->hdl_info);
+	cobalt_info("sysctrl: %08x, sysstat: %08x\n",
+			cobalt_g_sysctrl(cobalt),
+			cobalt_g_sysstat(cobalt));
+	cobalt_info("dma channel: %d, video channel: %d\n",
+			s->dma_channel, s->video_channel);
+	cobalt_pcie_status_show(cobalt);
+	cobalt_cpld_status(cobalt);
+	cobalt_irq_log_status(cobalt);
+	v4l2_subdev_call(s->sd, core, log_status);
+	if (!s->is_output) {
+		cobalt_video_input_status_show(s);
+		return 0;
+	}
+
+	stat = vo->rd_status;
+
+	cobalt_info("tx: status: %s%s\n",
+		(stat & M00514_RD_STATUS_BITMAP_FLOW_CTRL_NO_DATA_ERROR_MSK) ?
+			"no_data " : "",
+		(stat & M00514_RD_STATUS_BITMAP_READY_BUFFER_FULL_MSK) ?
+			"ready_buffer_full " : "");
+	cobalt_info("tx: evcnt: %d\n", vo->rd_evcnt_count);
+	return 0;
+}
+
+static int cobalt_enum_dv_timings(struct file *file, void *priv_fh,
+				    struct v4l2_enum_dv_timings *timings)
+{
+	struct cobalt_stream *s = video_drvdata(file);
+
+	if (s->input == 1) {
+		if (timings->index)
+			return -EINVAL;
+		memset(timings->reserved, 0, sizeof(timings->reserved));
+		timings->timings = cea1080p60;
+		return 0;
+	}
+	timings->pad = 0;
+	return v4l2_subdev_call(s->sd,
+			pad, enum_dv_timings, timings);
+}
+
+static int cobalt_s_dv_timings(struct file *file, void *priv_fh,
+				    struct v4l2_dv_timings *timings)
+{
+	struct cobalt_stream *s = video_drvdata(file);
+	int err;
+
+	if (vb2_is_busy(&s->q))
+		return -EBUSY;
+
+	if (s->input == 1) {
+		*timings = cea1080p60;
+		return 0;
+	}
+	err = v4l2_subdev_call(s->sd,
+			video, s_dv_timings, timings);
+	if (!err) {
+		s->timings = *timings;
+		s->width = timings->bt.width;
+		s->height = timings->bt.height;
+		s->stride = timings->bt.width * s->bpp;
+	}
+	return err;
+}
+
+static int cobalt_g_dv_timings(struct file *file, void *priv_fh,
+				    struct v4l2_dv_timings *timings)
+{
+	struct cobalt_stream *s = video_drvdata(file);
+
+	if (s->input == 1) {
+		*timings = cea1080p60;
+		return 0;
+	}
+	return v4l2_subdev_call(s->sd,
+			video, g_dv_timings, timings);
+}
+
+static int cobalt_query_dv_timings(struct file *file, void *priv_fh,
+				    struct v4l2_dv_timings *timings)
+{
+	struct cobalt_stream *s = video_drvdata(file);
+
+	if (s->input == 1) {
+		*timings = cea1080p60;
+		return 0;
+	}
+	return v4l2_subdev_call(s->sd,
+			video, query_dv_timings, timings);
+}
+
+static int cobalt_dv_timings_cap(struct file *file, void *priv_fh,
+				    struct v4l2_dv_timings_cap *cap)
+{
+	struct cobalt_stream *s = video_drvdata(file);
+
+	cap->pad = 0;
+	return v4l2_subdev_call(s->sd,
+			pad, dv_timings_cap, cap);
+}
+
+static int cobalt_enum_fmt_vid_cap(struct file *file, void *priv_fh,
+		struct v4l2_fmtdesc *f)
+{
+	switch (f->index) {
+	case 0:
+		strlcpy(f->description, "YUV 4:2:2", sizeof(f->description));
+		f->pixelformat = V4L2_PIX_FMT_YUYV;
+		break;
+	case 1:
+		strlcpy(f->description, "RGB24", sizeof(f->description));
+		f->pixelformat = V4L2_PIX_FMT_RGB24;
+		break;
+	case 2:
+		strlcpy(f->description, "RGB32", sizeof(f->description));
+		f->pixelformat = V4L2_PIX_FMT_BGR32;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int cobalt_g_fmt_vid_cap(struct file *file, void *priv_fh,
+		struct v4l2_format *f)
+{
+	struct cobalt_stream *s = video_drvdata(file);
+	struct v4l2_pix_format *pix = &f->fmt.pix;
+	struct v4l2_subdev_format sd_fmt;
+
+	pix->width = s->width;
+	pix->height = s->height;
+	pix->bytesperline = s->stride;
+	pix->field = V4L2_FIELD_NONE;
+
+	if (s->input == 1) {
+		pix->colorspace = V4L2_COLORSPACE_SRGB;
+	} else {
+		sd_fmt.pad = s->pad_source;
+		sd_fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;
+		v4l2_subdev_call(s->sd, pad, get_fmt, NULL, &sd_fmt);
+		v4l2_fill_pix_format(pix, &sd_fmt.format);
+		pix->colorspace = sd_fmt.format.colorspace;
+		pix->ycbcr_enc = sd_fmt.format.ycbcr_enc;
+		pix->quantization = sd_fmt.format.quantization;
+	}
+
+	pix->pixelformat = s->pixfmt;
+	pix->sizeimage = pix->bytesperline * pix->height;
+
+	return 0;
+}
+
+static int cobalt_try_fmt_vid_cap(struct file *file, void *priv_fh,
+		struct v4l2_format *f)
+{
+	struct cobalt_stream *s = video_drvdata(file);
+	struct v4l2_pix_format *pix = &f->fmt.pix;
+	struct v4l2_subdev_format sd_fmt;
+
+	/* Check for min (QCIF) and max (Full HD) size */
+	if ((pix->width < 176) || (pix->height < 144)) {
+		pix->width = 176;
+		pix->height = 144;
+	}
+
+	if ((pix->width > 1920) || (pix->height > 1080)) {
+		pix->width = 1920;
+		pix->height = 1080;
+	}
+
+	/* Make width multiple of 4 */
+	pix->width &= ~0x3;
+
+	/* Make height multiple of 2 */
+	pix->height &= ~0x1;
+
+	if (s->input == 1) {
+		/* Generator => fixed format only */
+		pix->width = 1920;
+		pix->height = 1080;
+		pix->colorspace = V4L2_COLORSPACE_SRGB;
+	} else {
+		sd_fmt.pad = s->pad_source;
+		sd_fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;
+		v4l2_subdev_call(s->sd, pad, get_fmt, NULL, &sd_fmt);
+		v4l2_fill_pix_format(pix, &sd_fmt.format);
+		pix->colorspace = sd_fmt.format.colorspace;
+		pix->ycbcr_enc = sd_fmt.format.ycbcr_enc;
+		pix->quantization = sd_fmt.format.quantization;
+	}
+
+	switch (pix->pixelformat) {
+	case V4L2_PIX_FMT_YUYV:
+	default:
+		pix->bytesperline = max(pix->bytesperline & ~0x3,
+				pix->width * COBALT_BYTES_PER_PIXEL_YUYV);
+		pix->pixelformat = V4L2_PIX_FMT_YUYV;
+		break;
+	case V4L2_PIX_FMT_RGB24:
+		pix->bytesperline = max(pix->bytesperline & ~0x3,
+				pix->width * COBALT_BYTES_PER_PIXEL_RGB24);
+		break;
+	case V4L2_PIX_FMT_BGR32:
+		pix->bytesperline = max(pix->bytesperline & ~0x3,
+				pix->width * COBALT_BYTES_PER_PIXEL_RGB32);
+		break;
+	}
+
+	pix->sizeimage = pix->bytesperline * pix->height;
+	pix->field = V4L2_FIELD_NONE;
+	pix->priv = 0;
+
+	return 0;
+}
+
+static int cobalt_s_fmt_vid_cap(struct file *file, void *priv_fh,
+		struct v4l2_format *f)
+{
+	struct cobalt_stream *s = video_drvdata(file);
+	struct v4l2_pix_format *pix = &f->fmt.pix;
+
+	if (vb2_is_busy(&s->q))
+		return -EBUSY;
+
+	if (cobalt_try_fmt_vid_cap(file, priv_fh, f))
+		return -EINVAL;
+
+	s->width = pix->width;
+	s->height = pix->height;
+	s->stride = pix->bytesperline;
+	switch (pix->pixelformat) {
+	case V4L2_PIX_FMT_YUYV:
+		s->bpp = COBALT_BYTES_PER_PIXEL_YUYV;
+		break;
+	case V4L2_PIX_FMT_RGB24:
+		s->bpp = COBALT_BYTES_PER_PIXEL_RGB24;
+		break;
+	case V4L2_PIX_FMT_BGR32:
+		s->bpp = COBALT_BYTES_PER_PIXEL_RGB32;
+		break;
+	default:
+		return -EINVAL;
+	}
+	s->pixfmt = pix->pixelformat;
+	cobalt_enable_input(s);
+
+	return 0;
+}
+
+static int cobalt_try_fmt_vid_out(struct file *file, void *priv_fh,
+		struct v4l2_format *f)
+{
+	struct v4l2_pix_format *pix = &f->fmt.pix;
+
+	/* Check for min (QCIF) and max (Full HD) size */
+	if ((pix->width < 176) || (pix->height < 144)) {
+		pix->width = 176;
+		pix->height = 144;
+	}
+
+	if ((pix->width > 1920) || (pix->height > 1080)) {
+		pix->width = 1920;
+		pix->height = 1080;
+	}
+
+	/* Make width multiple of 4 */
+	pix->width &= ~0x3;
+
+	/* Make height multiple of 2 */
+	pix->height &= ~0x1;
+
+	switch (pix->pixelformat) {
+	case V4L2_PIX_FMT_YUYV:
+	default:
+		pix->bytesperline = max(pix->bytesperline & ~0x3,
+				pix->width * COBALT_BYTES_PER_PIXEL_YUYV);
+		pix->pixelformat = V4L2_PIX_FMT_YUYV;
+		break;
+	case V4L2_PIX_FMT_BGR32:
+		pix->bytesperline = max(pix->bytesperline & ~0x3,
+				pix->width * COBALT_BYTES_PER_PIXEL_RGB32);
+		break;
+	}
+
+	pix->sizeimage = pix->bytesperline * pix->height;
+	pix->field = V4L2_FIELD_NONE;
+
+	return 0;
+}
+
+static int cobalt_g_fmt_vid_out(struct file *file, void *priv_fh,
+		struct v4l2_format *f)
+{
+	struct cobalt_stream *s = video_drvdata(file);
+	struct v4l2_pix_format *pix = &f->fmt.pix;
+
+	pix->width = s->width;
+	pix->height = s->height;
+	pix->bytesperline = s->stride;
+	pix->field = V4L2_FIELD_NONE;
+	pix->pixelformat = s->pixfmt;
+	pix->colorspace = s->colorspace;
+	pix->ycbcr_enc = s->ycbcr_enc;
+	pix->quantization = s->quantization;
+	pix->sizeimage = pix->bytesperline * pix->height;
+
+	return 0;
+}
+
+static int cobalt_enum_fmt_vid_out(struct file *file, void *priv_fh,
+		struct v4l2_fmtdesc *f)
+{
+	switch (f->index) {
+	case 0:
+		strlcpy(f->description, "YUV 4:2:2", sizeof(f->description));
+		f->pixelformat = V4L2_PIX_FMT_YUYV;
+		break;
+	case 1:
+		strlcpy(f->description, "RGB32", sizeof(f->description));
+		f->pixelformat = V4L2_PIX_FMT_BGR32;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int cobalt_s_fmt_vid_out(struct file *file, void *priv_fh,
+		struct v4l2_format *f)
+{
+	struct cobalt_stream *s = video_drvdata(file);
+	struct v4l2_pix_format *pix = &f->fmt.pix;
+	struct v4l2_subdev_format sd_fmt = { 0 };
+
+	if (cobalt_try_fmt_vid_out(file, priv_fh, f))
+		return -EINVAL;
+
+	if (vb2_is_busy(&s->q) && (pix->pixelformat != s->pixfmt ||
+	    pix->width != s->width || pix->height != s->height ||
+	    pix->bytesperline != s->stride))
+		return -EBUSY;
+
+	switch (pix->pixelformat) {
+	case V4L2_PIX_FMT_YUYV:
+		s->bpp = COBALT_BYTES_PER_PIXEL_YUYV;
+		break;
+	case V4L2_PIX_FMT_BGR32:
+		s->bpp = COBALT_BYTES_PER_PIXEL_RGB32;
+		break;
+	default:
+		return -EINVAL;
+	}
+	s->width = pix->width;
+	s->height = pix->height;
+	s->stride = pix->bytesperline;
+	s->pixfmt = pix->pixelformat;
+	s->colorspace = pix->colorspace;
+	s->ycbcr_enc = pix->ycbcr_enc;
+	s->quantization = pix->quantization;
+	sd_fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;
+	v4l2_subdev_call(s->sd, pad, get_fmt, NULL, &sd_fmt);
+	sd_fmt.format.colorspace = pix->colorspace;
+	sd_fmt.format.ycbcr_enc = pix->ycbcr_enc;
+	sd_fmt.format.quantization = pix->quantization;
+	v4l2_subdev_call(s->sd, pad, set_fmt, NULL, &sd_fmt);
+	return 0;
+}
+
+static int cobalt_enum_input(struct file *file, void *priv_fh,
+				 struct v4l2_input *inp)
+{
+	struct cobalt_stream *s = video_drvdata(file);
+
+	if (inp->index > 1)
+		return -EINVAL;
+	if (inp->index == 0)
+		snprintf(inp->name, sizeof(inp->name),
+				"HDMI-%d", s->video_channel);
+	else
+		snprintf(inp->name, sizeof(inp->name),
+				"Generator-%d", s->video_channel);
+	inp->type = V4L2_INPUT_TYPE_CAMERA;
+	inp->capabilities = V4L2_IN_CAP_DV_TIMINGS;
+	if (inp->index == 1)
+		return 0;
+	return v4l2_subdev_call(s->sd,
+			video, g_input_status, &inp->status);
+}
+
+static int cobalt_g_input(struct file *file, void *priv_fh, unsigned int *i)
+{
+	struct cobalt_stream *s = video_drvdata(file);
+
+	*i = s->input;
+	return 0;
+}
+
+static int cobalt_s_input(struct file *file, void *priv_fh, unsigned int i)
+{
+	struct cobalt_stream *s = video_drvdata(file);
+
+	if (i >= 2)
+		return -EINVAL;
+	if (vb2_is_busy(&s->q))
+		return -EBUSY;
+	s->input = i;
+
+	cobalt_enable_input(s);
+
+	if (s->input == 1) /* Test Pattern Generator */
+		return 0;
+
+	return v4l2_subdev_call(s->sd, video, s_routing,
+			ADV76XX_PAD_HDMI_PORT_A, 0, 0);
+}
+
+static int cobalt_enum_output(struct file *file, void *priv_fh,
+				 struct v4l2_output *out)
+{
+	if (out->index)
+		return -EINVAL;
+	snprintf(out->name, sizeof(out->name), "HDMI-%d", out->index);
+	out->type = V4L2_OUTPUT_TYPE_ANALOG;
+	out->capabilities = V4L2_OUT_CAP_DV_TIMINGS;
+	return 0;
+}
+
+static int cobalt_g_output(struct file *file, void *priv_fh, unsigned int *i)
+{
+	*i = 0;
+	return 0;
+}
+
+static int cobalt_s_output(struct file *file, void *priv_fh, unsigned int i)
+{
+	return i ? -EINVAL : 0;
+}
+
+static int cobalt_g_edid(struct file *file, void *fh, struct v4l2_edid *edid)
+{
+	struct cobalt_stream *s = video_drvdata(file);
+	u32 pad = edid->pad;
+	int ret;
+
+	if (edid->pad >= (s->is_output ? 1 : 2))
+		return -EINVAL;
+	edid->pad = 0;
+	ret = v4l2_subdev_call(s->sd, pad, get_edid, edid);
+	edid->pad = pad;
+	return ret;
+}
+
+static int cobalt_s_edid(struct file *file, void *fh, struct v4l2_edid *edid)
+{
+	struct cobalt_stream *s = video_drvdata(file);
+	u32 pad = edid->pad;
+	int ret;
+
+	if (edid->pad >= 2)
+		return -EINVAL;
+	edid->pad = 0;
+	ret = v4l2_subdev_call(s->sd, pad, set_edid, edid);
+	edid->pad = pad;
+	return ret;
+}
+
+static int cobalt_subscribe_event(struct v4l2_fh *fh,
+				  const struct v4l2_event_subscription *sub)
+{
+	switch (sub->type) {
+	case V4L2_EVENT_SOURCE_CHANGE:
+		return v4l2_event_subscribe(fh, sub, 4, NULL);
+	}
+	return v4l2_ctrl_subscribe_event(fh, sub);
+}
+
+static int cobalt_g_parm(struct file *file, void *fh, struct v4l2_streamparm *a)
+{
+	if (a->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;
+	a->parm.capture.timeperframe.numerator = 1;
+	a->parm.capture.timeperframe.denominator = 60;
+	a->parm.capture.readbuffers = 3;
+	return 0;
+}
+
+static const struct v4l2_ioctl_ops cobalt_ioctl_ops = {
+	.vidioc_querycap		= cobalt_querycap,
+	.vidioc_g_parm			= cobalt_g_parm,
+	.vidioc_log_status		= cobalt_log_status,
+	.vidioc_streamon		= vb2_ioctl_streamon,
+	.vidioc_streamoff		= vb2_ioctl_streamoff,
+	.vidioc_enum_input		= cobalt_enum_input,
+	.vidioc_g_input			= cobalt_g_input,
+	.vidioc_s_input			= cobalt_s_input,
+	.vidioc_enum_fmt_vid_cap	= cobalt_enum_fmt_vid_cap,
+	.vidioc_g_fmt_vid_cap		= cobalt_g_fmt_vid_cap,
+	.vidioc_s_fmt_vid_cap		= cobalt_s_fmt_vid_cap,
+	.vidioc_try_fmt_vid_cap		= cobalt_try_fmt_vid_cap,
+	.vidioc_enum_output		= cobalt_enum_output,
+	.vidioc_g_output		= cobalt_g_output,
+	.vidioc_s_output		= cobalt_s_output,
+	.vidioc_enum_fmt_vid_out	= cobalt_enum_fmt_vid_out,
+	.vidioc_g_fmt_vid_out		= cobalt_g_fmt_vid_out,
+	.vidioc_s_fmt_vid_out		= cobalt_s_fmt_vid_out,
+	.vidioc_try_fmt_vid_out		= cobalt_try_fmt_vid_out,
+	.vidioc_s_dv_timings		= cobalt_s_dv_timings,
+	.vidioc_g_dv_timings		= cobalt_g_dv_timings,
+	.vidioc_query_dv_timings	= cobalt_query_dv_timings,
+	.vidioc_enum_dv_timings		= cobalt_enum_dv_timings,
+	.vidioc_dv_timings_cap		= cobalt_dv_timings_cap,
+	.vidioc_g_edid			= cobalt_g_edid,
+	.vidioc_s_edid			= cobalt_s_edid,
+	.vidioc_subscribe_event		= cobalt_subscribe_event,
+	.vidioc_unsubscribe_event	= v4l2_event_unsubscribe,
+	.vidioc_reqbufs			= vb2_ioctl_reqbufs,
+	.vidioc_create_bufs		= vb2_ioctl_create_bufs,
+	.vidioc_querybuf		= vb2_ioctl_querybuf,
+	.vidioc_qbuf			= vb2_ioctl_qbuf,
+	.vidioc_dqbuf			= vb2_ioctl_dqbuf,
+	.vidioc_expbuf			= vb2_ioctl_expbuf,
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+	.vidioc_g_register              = cobalt_g_register,
+	.vidioc_s_register              = cobalt_s_register,
+#endif
+};
+
+static const struct v4l2_ioctl_ops cobalt_ioctl_empty_ops = {
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+	.vidioc_g_register              = cobalt_g_register,
+	.vidioc_s_register              = cobalt_s_register,
+#endif
+};
+
+/* Register device nodes */
+
+static const struct v4l2_file_operations cobalt_fops = {
+	.owner = THIS_MODULE,
+	.open = v4l2_fh_open,
+	.unlocked_ioctl = video_ioctl2,
+	.release = vb2_fop_release,
+	.poll = vb2_fop_poll,
+	.mmap = vb2_fop_mmap,
+	.read = vb2_fop_read,
+};
+
+static const struct v4l2_file_operations cobalt_out_fops = {
+	.owner = THIS_MODULE,
+	.open = v4l2_fh_open,
+	.unlocked_ioctl = video_ioctl2,
+	.release = vb2_fop_release,
+	.poll = vb2_fop_poll,
+	.mmap = vb2_fop_mmap,
+	.write = vb2_fop_write,
+};
+
+static const struct v4l2_file_operations cobalt_empty_fops = {
+	.owner = THIS_MODULE,
+	.open = v4l2_fh_open,
+	.unlocked_ioctl = video_ioctl2,
+	.release = v4l2_fh_release,
+};
+
+static int cobalt_node_register(struct cobalt *cobalt, int node)
+{
+	static const struct v4l2_dv_timings dv1080p60 =
+		V4L2_DV_BT_CEA_1920X1080P60;
+	struct cobalt_stream *s = cobalt->streams + node;
+	struct video_device *vdev = &s->vdev;
+	struct vb2_queue *q = &s->q;
+	int ret;
+
+	mutex_init(&s->lock);
+	spin_lock_init(&s->irqlock);
+
+	snprintf(vdev->name, sizeof(vdev->name),
+			"%s-%d", cobalt->v4l2_dev.name, node);
+	s->width = 1920;
+	/* Audio frames are just 4 lines of 1920 bytes */
+	s->height = s->is_audio ? 4 : 1080;
+
+	if (s->is_audio) {
+		s->bpp = 1;
+		s->pixfmt = V4L2_PIX_FMT_GREY;
+	} else if (s->is_output) {
+		s->bpp = COBALT_BYTES_PER_PIXEL_RGB32;
+		s->pixfmt = V4L2_PIX_FMT_BGR32;
+	} else {
+		s->bpp = COBALT_BYTES_PER_PIXEL_YUYV;
+		s->pixfmt = V4L2_PIX_FMT_YUYV;
+	}
+	s->colorspace = V4L2_COLORSPACE_SRGB;
+	s->stride = s->width * s->bpp;
+
+	if (!s->is_audio) {
+		if (s->is_dummy)
+			cobalt_warn("Setting up dummy video node %d\n", node);
+		vdev->v4l2_dev = &cobalt->v4l2_dev;
+		if (s->is_dummy)
+			vdev->fops = &cobalt_empty_fops;
+		else
+			vdev->fops = s->is_output ? &cobalt_out_fops :
+						    &cobalt_fops;
+		vdev->release = video_device_release_empty;
+		vdev->vfl_dir = s->is_output ? VFL_DIR_TX : VFL_DIR_RX;
+		vdev->lock = &s->lock;
+		if (s->sd)
+			vdev->ctrl_handler = s->sd->ctrl_handler;
+		s->timings = dv1080p60;
+		v4l2_subdev_call(s->sd, video, s_dv_timings, &s->timings);
+		if (!s->is_output && s->sd)
+			cobalt_enable_input(s);
+		vdev->ioctl_ops = s->is_dummy ? &cobalt_ioctl_empty_ops :
+				  &cobalt_ioctl_ops;
+	}
+
+	INIT_LIST_HEAD(&s->bufs);
+	q->type = s->is_output ? V4L2_BUF_TYPE_VIDEO_OUTPUT :
+				 V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	q->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF;
+	q->io_modes |= s->is_output ? VB2_WRITE : VB2_READ;
+	q->drv_priv = s;
+	q->buf_struct_size = sizeof(struct cobalt_buffer);
+	q->ops = &cobalt_qops;
+	q->mem_ops = &vb2_dma_sg_memops;
+	q->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;
+	q->min_buffers_needed = 2;
+	q->lock = &s->lock;
+	vdev->queue = q;
+
+	video_set_drvdata(vdev, s);
+	ret = vb2_queue_init(q);
+	if (!s->is_audio && ret == 0)
+		ret = video_register_device(vdev, VFL_TYPE_GRABBER, -1);
+	else if (!s->is_dummy)
+		ret = cobalt_alsa_init(s);
+
+	if (ret < 0) {
+		if (!s->is_audio)
+			cobalt_err("couldn't register v4l2 device node %d\n",
+					node);
+		return ret;
+	}
+	cobalt_info("registered node %d\n", node);
+	return 0;
+}
+
+/* Initialize v4l2 variables and register v4l2 devices */
+int cobalt_nodes_register(struct cobalt *cobalt)
+{
+	int node, ret;
+
+	/* Setup V4L2 Devices */
+	for (node = 0; node < COBALT_NUM_STREAMS; node++) {
+		ret = cobalt_node_register(cobalt, node);
+		if (ret)
+			return ret;
+	}
+	return 0;
+}
+
+/* Unregister v4l2 devices */
+void cobalt_nodes_unregister(struct cobalt *cobalt)
+{
+	int node;
+
+	/* Teardown all streams */
+	for (node = 0; node < COBALT_NUM_STREAMS; node++) {
+		struct cobalt_stream *s = cobalt->streams + node;
+		struct video_device *vdev = &s->vdev;
+
+		if (!s->is_audio)
+			video_unregister_device(vdev);
+		else if (!s->is_dummy)
+			cobalt_alsa_exit(s);
+	}
+}
