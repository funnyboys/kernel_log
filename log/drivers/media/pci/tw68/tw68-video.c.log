commit 3e30a927af3ca86f6556faf437da44ca8bcf54a4
Author: Hans Verkuil <hverkuil-cisco@xs4all.nl>
Date:   Mon Feb 3 12:41:17 2020 +0100

    media: media/pci: rename VFL_TYPE_GRABBER to _VIDEO
    
    'GRABBER' is a weird name, all other types map to the /dev
    device names. Rename to 'VIDEO' to be consistent with the
    other types.
    
    Signed-off-by: Hans Verkuil <hverkuil-cisco@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+huawei@kernel.org>

diff --git a/drivers/media/pci/tw68/tw68-video.c b/drivers/media/pci/tw68/tw68-video.c
index 2fb82d50c53e..10986fcd66a5 100644
--- a/drivers/media/pci/tw68/tw68-video.c
+++ b/drivers/media/pci/tw68/tw68-video.c
@@ -962,7 +962,7 @@ int tw68_video_init2(struct tw68_dev *dev, int video_nr)
 	dev->vdev.lock = &dev->lock;
 	dev->vdev.queue = &dev->vidq;
 	video_set_drvdata(&dev->vdev, dev);
-	return video_register_device(&dev->vdev, VFL_TYPE_GRABBER, video_nr);
+	return video_register_device(&dev->vdev, VFL_TYPE_VIDEO, video_nr);
 }
 
 /*

commit b61789f53d49db8ca1f6b8fed411b317b4e8f044
Author: Hans Verkuil <hverkuil@xs4all.nl>
Date:   Wed Jun 26 05:58:02 2019 -0400

    media: drivers/media: don't set pix->priv = 0
    
    The priv field of struct v4l2_pix_format shouldn't be set by drivers,
    it's set by the v4l2 core instead to V4L2_PIX_FMT_PRIV_MAGIC.
    
    Drop this from the few media drivers that still do this.
    
    Note that the gspca patch is slightly more involved since some of the
    sub-gspca drivers use the priv field internally.
    
    Signed-off-by: Hans Verkuil <hverkuil-cisco@xs4all.nl>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    [hverkuil-cisco@xs4all.nl: fix clash in gspca between priv arg and priv variable]
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/pci/tw68/tw68-video.c b/drivers/media/pci/tw68/tw68-video.c
index 99e74c22d3be..2fb82d50c53e 100644
--- a/drivers/media/pci/tw68/tw68-video.c
+++ b/drivers/media/pci/tw68/tw68-video.c
@@ -582,7 +582,6 @@ static int tw68_g_fmt_vid_cap(struct file *file, void *priv,
 	f->fmt.pix.sizeimage =
 		f->fmt.pix.height * f->fmt.pix.bytesperline;
 	f->fmt.pix.colorspace	= V4L2_COLORSPACE_SMPTE170M;
-	f->fmt.pix.priv = 0;
 	return 0;
 }
 

commit 2169e6daa1ffa6e9869fcc56ff7df23c9287f1ec
Author: Hans Verkuil <hverkuil-cisco@xs4all.nl>
Date:   Tue Jun 11 09:49:53 2019 -0400

    media: media/pci: don't set description for ENUM_FMT
    
    The V4L2 core sets the description for the driver in order to ensure
    consistent naming.
    
    So drop the strscpy of the description in drivers. Also remove any
    description strings in driver-internal structures since those are
    no longer needed.
    
    Signed-off-by: Hans Verkuil <hverkuil-cisco@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/pci/tw68/tw68-video.c b/drivers/media/pci/tw68/tw68-video.c
index 8e0952d65ad4..99e74c22d3be 100644
--- a/drivers/media/pci/tw68/tw68-video.c
+++ b/drivers/media/pci/tw68/tw68-video.c
@@ -34,53 +34,43 @@
  */
 static const struct tw68_format formats[] = {
 	{
-		.name		= "15 bpp RGB, le",
 		.fourcc		= V4L2_PIX_FMT_RGB555,
 		.depth		= 16,
 		.twformat	= ColorFormatRGB15,
 	}, {
-		.name		= "15 bpp RGB, be",
 		.fourcc		= V4L2_PIX_FMT_RGB555X,
 		.depth		= 16,
 		.twformat	= ColorFormatRGB15 | ColorFormatBSWAP,
 	}, {
-		.name		= "16 bpp RGB, le",
 		.fourcc		= V4L2_PIX_FMT_RGB565,
 		.depth		= 16,
 		.twformat	= ColorFormatRGB16,
 	}, {
-		.name		= "16 bpp RGB, be",
 		.fourcc		= V4L2_PIX_FMT_RGB565X,
 		.depth		= 16,
 		.twformat	= ColorFormatRGB16 | ColorFormatBSWAP,
 	}, {
-		.name		= "24 bpp RGB, le",
 		.fourcc		= V4L2_PIX_FMT_BGR24,
 		.depth		= 24,
 		.twformat	= ColorFormatRGB24,
 	}, {
-		.name		= "24 bpp RGB, be",
 		.fourcc		= V4L2_PIX_FMT_RGB24,
 		.depth		= 24,
 		.twformat	= ColorFormatRGB24 | ColorFormatBSWAP,
 	}, {
-		.name		= "32 bpp RGB, le",
 		.fourcc		= V4L2_PIX_FMT_BGR32,
 		.depth		= 32,
 		.twformat	= ColorFormatRGB32,
 	}, {
-		.name		= "32 bpp RGB, be",
 		.fourcc		= V4L2_PIX_FMT_RGB32,
 		.depth		= 32,
 		.twformat	= ColorFormatRGB32 | ColorFormatBSWAP |
 				  ColorFormatWSWAP,
 	}, {
-		.name		= "4:2:2 packed, YUYV",
 		.fourcc		= V4L2_PIX_FMT_YUYV,
 		.depth		= 16,
 		.twformat	= ColorFormatYUY2,
 	}, {
-		.name		= "4:2:2 packed, UYVY",
 		.fourcc		= V4L2_PIX_FMT_UYVY,
 		.depth		= 16,
 		.twformat	= ColorFormatYUY2 | ColorFormatBSWAP,
@@ -774,9 +764,6 @@ static int tw68_enum_fmt_vid_cap(struct file *file, void  *priv,
 	if (f->index >= FORMATS)
 		return -EINVAL;
 
-	strscpy(f->description, formats[f->index].name,
-		sizeof(f->description));
-
 	f->pixelformat = formats[f->index].fourcc;
 
 	return 0;

commit 2161536516edcc0be31109eb1284939119e7ba6d
Author: Hans Verkuil <hverkuil@xs4all.nl>
Date:   Mon Jun 17 05:36:16 2019 -0400

    media: media/pci: set device_caps in struct video_device
    
    Instead of filling in the struct v4l2_capability device_caps
    field, fill in the struct video_device device_caps field.
    
    That way the V4L2 core knows what the capabilities of the
    video device are.
    
    But this only really works if all drivers use this, so convert
    all pci drivers in this patch.
    
    Tested with cx88-blackbird and ivtv PVR-350.
    
    Signed-off-by: Hans Verkuil <hverkuil-cisco@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/pci/tw68/tw68-video.c b/drivers/media/pci/tw68/tw68-video.c
index 5b469cf578f5..8e0952d65ad4 100644
--- a/drivers/media/pci/tw68/tw68-video.c
+++ b/drivers/media/pci/tw68/tw68-video.c
@@ -729,12 +729,6 @@ static int tw68_querycap(struct file *file, void  *priv,
 	strscpy(cap->card, "Techwell Capture Card",
 		sizeof(cap->card));
 	sprintf(cap->bus_info, "PCI:%s", pci_name(dev->pci));
-	cap->device_caps =
-		V4L2_CAP_VIDEO_CAPTURE |
-		V4L2_CAP_READWRITE |
-		V4L2_CAP_STREAMING;
-
-	cap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;
 	return 0;
 }
 
@@ -913,6 +907,8 @@ static const struct video_device tw68_video_template = {
 	.ioctl_ops		= &video_ioctl_ops,
 	.release		= video_device_release_empty,
 	.tvnorms		= TW68_NORMS,
+	.device_caps		= V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_READWRITE |
+				  V4L2_CAP_STREAMING,
 };
 
 /* ------------------------------------------------------------------ */

commit c942fddf8793b2013be8c901b47d0a8dc02bf99f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:06 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 157
    
    Based on 3 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [kishon] [vijay] [abraham]
      [i] [kishon]@[ti] [com] this program is distributed in the hope that
      it will be useful but without any warranty without even the implied
      warranty of merchantability or fitness for a particular purpose see
      the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [graeme] [gregory]
      [gg]@[slimlogic] [co] [uk] [author] [kishon] [vijay] [abraham] [i]
      [kishon]@[ti] [com] [based] [on] [twl6030]_[usb] [c] [author] [hema]
      [hk] [hemahk]@[ti] [com] this program is distributed in the hope
      that it will be useful but without any warranty without even the
      implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1105 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.202006027@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/media/pci/tw68/tw68-video.c b/drivers/media/pci/tw68/tw68-video.c
index 4f74b14c3b4f..5b469cf578f5 100644
--- a/drivers/media/pci/tw68/tw68-video.c
+++ b/drivers/media/pci/tw68/tw68-video.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *  tw68 functions to handle video data
  *
@@ -13,16 +14,6 @@
  *  Refactored and updated to the latest v4l core frameworks:
  *
  *  Copyright (C) 2014 Hans Verkuil <hverkuil@xs4all.nl>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
  */
 
 #include <linux/module.h>

commit 167905540e08e37162adc24066427944f71bf7a4
Author: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
Date:   Mon Feb 18 14:28:59 2019 -0500

    media: pci: fix several typos
    
    Use codespell to fix lots of typos over frontends.
    
    Manually verified to avoid false-positives.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/pci/tw68/tw68-video.c b/drivers/media/pci/tw68/tw68-video.c
index d3f727045ae8..4f74b14c3b4f 100644
--- a/drivers/media/pci/tw68/tw68-video.c
+++ b/drivers/media/pci/tw68/tw68-video.c
@@ -446,7 +446,7 @@ static void tw68_buf_queue(struct vb2_buffer *vb)
 /*
  * buffer_prepare
  *
- * Set the ancilliary information into the buffer structure.  This
+ * Set the ancillary information into the buffer structure.  This
  * includes generating the necessary risc program if it hasn't already
  * been done for the current buffer format.
  * The structure fh contains the details of the format requested by the

commit cc1e6315e83db0e517dd9279050b88adc83a7eba
Author: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
Date:   Mon Sep 10 16:20:42 2018 -0400

    media: replace strcpy() by strscpy()
    
    The strcpy() function is being deprecated upstream. Replace
    it by the safer strscpy().
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
    Reviewed-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/pci/tw68/tw68-video.c b/drivers/media/pci/tw68/tw68-video.c
index 08e7dd6ecb07..d3f727045ae8 100644
--- a/drivers/media/pci/tw68/tw68-video.c
+++ b/drivers/media/pci/tw68/tw68-video.c
@@ -734,7 +734,7 @@ static int tw68_querycap(struct file *file, void  *priv,
 {
 	struct tw68_dev *dev = video_drvdata(file);
 
-	strcpy(cap->driver, "tw68");
+	strscpy(cap->driver, "tw68", sizeof(cap->driver));
 	strscpy(cap->card, "Techwell Capture Card",
 		sizeof(cap->card));
 	sprintf(cap->bus_info, "PCI:%s", pci_name(dev->pci));

commit c0decac19da3906d9b66291e57b7759489e1170f
Author: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
Date:   Mon Sep 10 08:19:14 2018 -0400

    media: use strscpy() instead of strlcpy()
    
    The implementation of strscpy() is more robust and safer.
    
    That's now the recommended way to copy NUL terminated strings.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Acked-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/pci/tw68/tw68-video.c b/drivers/media/pci/tw68/tw68-video.c
index 8c1f4a049764..08e7dd6ecb07 100644
--- a/drivers/media/pci/tw68/tw68-video.c
+++ b/drivers/media/pci/tw68/tw68-video.c
@@ -735,7 +735,7 @@ static int tw68_querycap(struct file *file, void  *priv,
 	struct tw68_dev *dev = video_drvdata(file);
 
 	strcpy(cap->driver, "tw68");
-	strlcpy(cap->card, "Techwell Capture Card",
+	strscpy(cap->card, "Techwell Capture Card",
 		sizeof(cap->card));
 	sprintf(cap->bus_info, "PCI:%s", pci_name(dev->pci));
 	cap->device_caps =
@@ -789,7 +789,7 @@ static int tw68_enum_fmt_vid_cap(struct file *file, void  *priv,
 	if (f->index >= FORMATS)
 		return -EINVAL;
 
-	strlcpy(f->description, formats[f->index].name,
+	strscpy(f->description, formats[f->index].name,
 		sizeof(f->description));
 
 	f->pixelformat = formats[f->index].fourcc;

commit 507e190946297c34a27d9366b0661d5e506fdd03
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Sat Aug 26 09:08:11 2017 -0400

    media: pci: make video_device const
    
    Make these const as they are either used during a copy operation or
    passed to a const argument of the function cx88_vdev_init.
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/pci/tw68/tw68-video.c b/drivers/media/pci/tw68/tw68-video.c
index 58c4dd75bfa1..8c1f4a049764 100644
--- a/drivers/media/pci/tw68/tw68-video.c
+++ b/drivers/media/pci/tw68/tw68-video.c
@@ -916,7 +916,7 @@ static const struct v4l2_ioctl_ops video_ioctl_ops = {
 #endif
 };
 
-static struct video_device tw68_video_template = {
+static const struct video_device tw68_video_template = {
 	.name			= "tw68_video",
 	.fops			= &video_fops,
 	.ioctl_ops		= &video_ioctl_ops,

commit db6d8d5fdf9537641c76ba7f32e02b4bcc600972
Author: Mauro Carvalho Chehab <mchehab@s-opensource.com>
Date:   Tue Oct 18 17:44:08 2016 -0200

    [media] tw68: don't break long lines
    
    Due to the 80-cols restrictions, and latter due to checkpatch
    warnings, several strings were broken into multiple lines. This
    is not considered a good practice anymore, as it makes harder
    to grep for strings at the source code.
    
    As we're right now fixing other drivers due to KERN_CONT, we need
    to be able to identify what printk strings don't end with a "\n".
    It is a way easier to detect those if we don't break long lines.
    
    So, join those continuation lines.
    
    The patch was generated via the script below, and manually
    adjusted if needed.
    
    </script>
    use Text::Tabs;
    while (<>) {
            if ($next ne "") {
                    $c=$_;
                    if ($c =~ /^\s+\"(.*)/) {
                            $c2=$1;
                            $next =~ s/\"\n$//;
                            $n = expand($next);
                            $funpos = index($n, '(');
                            $pos = index($c2, '",');
                            if ($funpos && $pos > 0) {
                                    $s1 = substr $c2, 0, $pos + 2;
                                    $s2 = ' ' x ($funpos + 1) . substr $c2, $pos + 2;
                                    $s2 =~ s/^\s+//;
    
                                    $s2 = ' ' x ($funpos + 1) . $s2 if ($s2 ne "");
    
                                    print unexpand("$next$s1\n");
                                    print unexpand("$s2\n") if ($s2 ne "");
                            } else {
                                    print "$next$c2\n";
                            }
                            $next="";
                            next;
                    } else {
                            print $next;
                    }
                    $next="";
            } else {
                    if (m/\"$/) {
                            if (!m/\\n\"$/) {
                                    $next=$_;
                                    next;
                            }
                    }
            }
            print $_;
    }
    </script>
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/pci/tw68/tw68-video.c b/drivers/media/pci/tw68/tw68-video.c
index a45e02367321..58c4dd75bfa1 100644
--- a/drivers/media/pci/tw68/tw68-video.c
+++ b/drivers/media/pci/tw68/tw68-video.c
@@ -279,9 +279,8 @@ static int tw68_set_scale(struct tw68_dev *dev, unsigned int width,
 		height /= 2;		/* we must set for 1-frame */
 
 	pr_debug("%s: width=%d, height=%d, both=%d\n"
-		 "  tvnorm h_delay=%d, h_start=%d, h_stop=%d, "
-		 "v_delay=%d, v_start=%d, v_stop=%d\n" , __func__,
-		width, height, V4L2_FIELD_HAS_BOTH(field),
+		 "  tvnorm h_delay=%d, h_start=%d, h_stop=%d, v_delay=%d, v_start=%d, v_stop=%d\n",
+		__func__, width, height, V4L2_FIELD_HAS_BOTH(field),
 		norm->h_delay, norm->h_start, norm->h_stop,
 		norm->v_delay, norm->video_v_start,
 		norm->video_v_stop);
@@ -309,16 +308,15 @@ static int tw68_set_scale(struct tw68_dev *dev, unsigned int width,
 		V4L2_FIELD_HAS_TOP(field)    ? "T" : "",
 		V4L2_FIELD_HAS_BOTTOM(field) ? "B" : "",
 		v4l2_norm_to_name(dev->tvnorm->id));
-	pr_debug("%s: hactive=%d, hdelay=%d, hscale=%d; "
-		"vactive=%d, vdelay=%d, vscale=%d\n", __func__,
+	pr_debug("%s: hactive=%d, hdelay=%d, hscale=%d; vactive=%d, vdelay=%d, vscale=%d\n",
+		 __func__,
 		hactive, hdelay, hscale, vactive, vdelay, vscale);
 
 	comb =	((vdelay & 0x300)  >> 2) |
 		((vactive & 0x300) >> 4) |
 		((hdelay & 0x300)  >> 6) |
 		((hactive & 0x300) >> 8);
-	pr_debug("%s: setting CROP_HI=%02x, VDELAY_LO=%02x, "
-		"VACTIVE_LO=%02x, HDELAY_LO=%02x, HACTIVE_LO=%02x\n",
+	pr_debug("%s: setting CROP_HI=%02x, VDELAY_LO=%02x, VACTIVE_LO=%02x, HDELAY_LO=%02x, HACTIVE_LO=%02x\n",
 		__func__, comb, vdelay, vactive, hdelay, hactive);
 	tw_writeb(TW68_CROP_HI, comb);
 	tw_writeb(TW68_VDELAY_LO, vdelay & 0xff);
@@ -327,8 +325,8 @@ static int tw68_set_scale(struct tw68_dev *dev, unsigned int width,
 	tw_writeb(TW68_HACTIVE_LO, hactive & 0xff);
 
 	comb = ((vscale & 0xf00) >> 4) | ((hscale & 0xf00) >> 8);
-	pr_debug("%s: setting SCALE_HI=%02x, VSCALE_LO=%02x, "
-		"HSCALE_LO=%02x\n", __func__, comb, vscale, hscale);
+	pr_debug("%s: setting SCALE_HI=%02x, VSCALE_LO=%02x, HSCALE_LO=%02x\n",
+		 __func__, comb, vscale, hscale);
 	tw_writeb(TW68_SCALE_HI, comb);
 	tw_writeb(TW68_VSCALE_LO, vscale);
 	tw_writeb(TW68_HSCALE_LO, hscale);

commit 10accd2e6890b57db8e717e9aee91b791f90fe14
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Thu Sep 8 20:59:18 2016 -0300

    [media] pci: constify vb2_ops structures
    
    Check for vb2_ops structures that are only stored in the ops field of a
    vb2_queue structure.  That field is declared const, so vb2_ops structures
    that have this property can be declared as const also.
    
    The semantic patch that makes this change is as follows:
    (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @r disable optional_qualifier@
    identifier i;
    position p;
    @@
    static struct vb2_ops i@p = { ... };
    
    @ok@
    identifier r.i;
    struct vb2_queue e;
    position p;
    @@
    e.ops = &i@p;
    
    @bad@
    position p != {r.p,ok.p};
    identifier r.i;
    struct vb2_ops e;
    @@
    e@i@p
    
    @depends on !bad disable optional_qualifier@
    identifier r.i;
    @@
    static
    +const
     struct vb2_ops i = { ... };
    // </smpl>
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Acked-by: Andrey Utkin <andrey.utkin@corp.bluecherry.net>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/pci/tw68/tw68-video.c b/drivers/media/pci/tw68/tw68-video.c
index 5e8212845c87..a45e02367321 100644
--- a/drivers/media/pci/tw68/tw68-video.c
+++ b/drivers/media/pci/tw68/tw68-video.c
@@ -535,7 +535,7 @@ static void tw68_stop_streaming(struct vb2_queue *q)
 	}
 }
 
-static struct vb2_ops tw68_video_qops = {
+static const struct vb2_ops tw68_video_qops = {
 	.queue_setup	= tw68_queue_setup,
 	.buf_queue	= tw68_buf_queue,
 	.buf_prepare	= tw68_buf_prepare,

commit 36c0f8b32c4bd4f668cedfba6d97afaa84f055fb
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Fri Apr 15 09:15:05 2016 -0300

    [media] vb2: replace void *alloc_ctxs by struct device *alloc_devs
    
    Make this a proper typed array. Drop the old allocate context code since
    that is no longer used.
    
    Note that the memops functions now get a struct device pointer instead of
    the struct device ** that was there initially (actually a void pointer to
    a struct containing only a struct device pointer).
    
    This code is now a lot cleaner.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Cc: Sakari Ailus <sakari.ailus@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/pci/tw68/tw68-video.c b/drivers/media/pci/tw68/tw68-video.c
index c675f9abbb24..5e8212845c87 100644
--- a/drivers/media/pci/tw68/tw68-video.c
+++ b/drivers/media/pci/tw68/tw68-video.c
@@ -378,7 +378,7 @@ static int tw68_buffer_count(unsigned int size, unsigned int count)
 
 static int tw68_queue_setup(struct vb2_queue *q,
 			   unsigned int *num_buffers, unsigned int *num_planes,
-			   unsigned int sizes[], void *alloc_ctxs[])
+			   unsigned int sizes[], struct device *alloc_devs[])
 {
 	struct tw68_dev *dev = vb2_get_drv_priv(q);
 	unsigned tot_bufs = q->num_buffers + *num_buffers;

commit 2bc46b3ad3c15165f91459b07ff8682478683194
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Mon Feb 15 12:37:15 2016 -0200

    [media] media/pci: convert drivers to use the new vb2_queue dev field
    
    Stop using alloc_ctx and just fill in the device pointer.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Cc: Federico Vaga <federico.vaga@gmail.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/pci/tw68/tw68-video.c b/drivers/media/pci/tw68/tw68-video.c
index 07116a87a57b..c675f9abbb24 100644
--- a/drivers/media/pci/tw68/tw68-video.c
+++ b/drivers/media/pci/tw68/tw68-video.c
@@ -388,7 +388,6 @@ static int tw68_queue_setup(struct vb2_queue *q,
 		tot_bufs = 2;
 	tot_bufs = tw68_buffer_count(size, tot_bufs);
 	*num_buffers = tot_bufs - q->num_buffers;
-	alloc_ctxs[0] = dev->alloc_ctx;
 	/*
 	 * We allow create_bufs, but only if the sizeimage is >= as the
 	 * current sizeimage. The tw68_buffer_count calculation becomes quite
@@ -983,6 +982,7 @@ int tw68_video_init2(struct tw68_dev *dev, int video_nr)
 	dev->vidq.buf_struct_size = sizeof(struct tw68_buf);
 	dev->vidq.lock = &dev->lock;
 	dev->vidq.min_buffers_needed = 2;
+	dev->vidq.dev = &dev->pci->dev;
 	ret = vb2_queue_init(&dev->vidq);
 	if (ret)
 		return ret;

commit d6dd645eae76eeb42cb47d9da69cd3f56b3f2cb6
Author: Junghak Sung <jh1009.sung@samsung.com>
Date:   Tue Nov 3 08:16:37 2015 -0200

    [media] media: videobuf2: Move timestamp to vb2_buffer
    
    Move timestamp from struct vb2_v4l2_buffer to struct vb2_buffer
    for common use, and change its type to u64 in order to handling
    y2038 problem. This patch also includes all device drivers' changes related to
    this restructuring.
    
    Signed-off-by: Junghak Sung <jh1009.sung@samsung.com>
    Signed-off-by: Geunyoung Kim <nenggun.kim@samsung.com>
    Acked-by: Seung-Woo Kim <sw0312.kim@samsung.com>
    Acked-by: Inki Dae <inki.dae@samsung.com>
    Signed-off-by: Hans Verkuil <hansverk@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/pci/tw68/tw68-video.c b/drivers/media/pci/tw68/tw68-video.c
index 2e71af15ddb0..07116a87a57b 100644
--- a/drivers/media/pci/tw68/tw68-video.c
+++ b/drivers/media/pci/tw68/tw68-video.c
@@ -1016,7 +1016,7 @@ void tw68_irq_video_done(struct tw68_dev *dev, unsigned long status)
 		buf = list_entry(dev->active.next, struct tw68_buf, list);
 		list_del(&buf->list);
 		spin_unlock(&dev->slock);
-		v4l2_get_timestamp(&buf->vb.timestamp);
+		buf->vb.vb2_buf.timestamp = ktime_get_ns();
 		buf->vb.field = dev->field;
 		buf->vb.sequence = dev->seqnr++;
 		vb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_DONE);

commit df9ecb0cad14b952a2865f8b3af86b2bbadfab45
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Wed Oct 28 00:50:37 2015 -0200

    [media] vb2: drop v4l2_format argument from queue_setup
    
    The queue_setup callback has a void pointer that is just for V4L2
    and is the pointer to the v4l2_format struct that was passed to
    VIDIOC_CREATE_BUFS. The idea was that drivers would use the information
    from that struct to buffers suitable for the requested format.
    
    After the vb2 split series this pointer is now a void pointer,
    which is ugly, and the reality is that all existing drivers will
    effectively just look at the sizeimage field of v4l2_format.
    
    To make this more generic the queue_setup callback is changed:
    the void pointer is dropped, instead if the *num_planes argument
    is 0, then use the current format size, if it is non-zero, then
    it contains the number of requested planes and the sizes array
    contains the requested sizes. If either is unsupported, then return
    -EINVAL, otherwise use the requested size(s).
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/pci/tw68/tw68-video.c b/drivers/media/pci/tw68/tw68-video.c
index 46642ef9151b..2e71af15ddb0 100644
--- a/drivers/media/pci/tw68/tw68-video.c
+++ b/drivers/media/pci/tw68/tw68-video.c
@@ -376,28 +376,28 @@ static int tw68_buffer_count(unsigned int size, unsigned int count)
 /* ------------------------------------------------------------- */
 /* vb2 queue operations                                          */
 
-static int tw68_queue_setup(struct vb2_queue *q, const void *parg,
+static int tw68_queue_setup(struct vb2_queue *q,
 			   unsigned int *num_buffers, unsigned int *num_planes,
 			   unsigned int sizes[], void *alloc_ctxs[])
 {
-	const struct v4l2_format *fmt = parg;
 	struct tw68_dev *dev = vb2_get_drv_priv(q);
 	unsigned tot_bufs = q->num_buffers + *num_buffers;
+	unsigned size = (dev->fmt->depth * dev->width * dev->height) >> 3;
 
-	sizes[0] = (dev->fmt->depth * dev->width * dev->height) >> 3;
+	if (tot_bufs < 2)
+		tot_bufs = 2;
+	tot_bufs = tw68_buffer_count(size, tot_bufs);
+	*num_buffers = tot_bufs - q->num_buffers;
 	alloc_ctxs[0] = dev->alloc_ctx;
 	/*
-	 * We allow create_bufs, but only if the sizeimage is the same as the
+	 * We allow create_bufs, but only if the sizeimage is >= as the
 	 * current sizeimage. The tw68_buffer_count calculation becomes quite
 	 * difficult otherwise.
 	 */
-	if (fmt && fmt->fmt.pix.sizeimage < sizes[0])
-		return -EINVAL;
+	if (*num_planes)
+		return sizes[0] < size ? -EINVAL : 0;
 	*num_planes = 1;
-	if (tot_bufs < 2)
-		tot_bufs = 2;
-	tot_bufs = tw68_buffer_count(sizes[0], tot_bufs);
-	*num_buffers = tot_bufs - q->num_buffers;
+	sizes[0] = size;
 
 	return 0;
 }

commit d0164adc89f6bb374d304ffcc375c6d2652fe67d
Author: Mel Gorman <mgorman@techsingularity.net>
Date:   Fri Nov 6 16:28:21 2015 -0800

    mm, page_alloc: distinguish between being unable to sleep, unwilling to sleep and avoiding waking kswapd
    
    __GFP_WAIT has been used to identify atomic context in callers that hold
    spinlocks or are in interrupts.  They are expected to be high priority and
    have access one of two watermarks lower than "min" which can be referred
    to as the "atomic reserve".  __GFP_HIGH users get access to the first
    lower watermark and can be called the "high priority reserve".
    
    Over time, callers had a requirement to not block when fallback options
    were available.  Some have abused __GFP_WAIT leading to a situation where
    an optimisitic allocation with a fallback option can access atomic
    reserves.
    
    This patch uses __GFP_ATOMIC to identify callers that are truely atomic,
    cannot sleep and have no alternative.  High priority users continue to use
    __GFP_HIGH.  __GFP_DIRECT_RECLAIM identifies callers that can sleep and
    are willing to enter direct reclaim.  __GFP_KSWAPD_RECLAIM to identify
    callers that want to wake kswapd for background reclaim.  __GFP_WAIT is
    redefined as a caller that is willing to enter direct reclaim and wake
    kswapd for background reclaim.
    
    This patch then converts a number of sites
    
    o __GFP_ATOMIC is used by callers that are high priority and have memory
      pools for those requests. GFP_ATOMIC uses this flag.
    
    o Callers that have a limited mempool to guarantee forward progress clear
      __GFP_DIRECT_RECLAIM but keep __GFP_KSWAPD_RECLAIM. bio allocations fall
      into this category where kswapd will still be woken but atomic reserves
      are not used as there is a one-entry mempool to guarantee progress.
    
    o Callers that are checking if they are non-blocking should use the
      helper gfpflags_allow_blocking() where possible. This is because
      checking for __GFP_WAIT as was done historically now can trigger false
      positives. Some exceptions like dm-crypt.c exist where the code intent
      is clearer if __GFP_DIRECT_RECLAIM is used instead of the helper due to
      flag manipulations.
    
    o Callers that built their own GFP flags instead of starting with GFP_KERNEL
      and friends now also need to specify __GFP_KSWAPD_RECLAIM.
    
    The first key hazard to watch out for is callers that removed __GFP_WAIT
    and was depending on access to atomic reserves for inconspicuous reasons.
    In some cases it may be appropriate for them to use __GFP_HIGH.
    
    The second key hazard is callers that assembled their own combination of
    GFP flags instead of starting with something like GFP_KERNEL.  They may
    now wish to specify __GFP_KSWAPD_RECLAIM.  It's almost certainly harmless
    if it's missed in most cases as other activity will wake kswapd.
    
    Signed-off-by: Mel Gorman <mgorman@techsingularity.net>
    Acked-by: Vlastimil Babka <vbabka@suse.cz>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Acked-by: Johannes Weiner <hannes@cmpxchg.org>
    Cc: Christoph Lameter <cl@linux.com>
    Cc: David Rientjes <rientjes@google.com>
    Cc: Vitaly Wool <vitalywool@gmail.com>
    Cc: Rik van Riel <riel@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/media/pci/tw68/tw68-video.c b/drivers/media/pci/tw68/tw68-video.c
index 4c3293dcddbc..46642ef9151b 100644
--- a/drivers/media/pci/tw68/tw68-video.c
+++ b/drivers/media/pci/tw68/tw68-video.c
@@ -979,7 +979,7 @@ int tw68_video_init2(struct tw68_dev *dev, int video_nr)
 	dev->vidq.ops = &tw68_video_qops;
 	dev->vidq.mem_ops = &vb2_dma_sg_memops;
 	dev->vidq.drv_priv = dev;
-	dev->vidq.gfp_flags = __GFP_DMA32;
+	dev->vidq.gfp_flags = __GFP_DMA32 | __GFP_KSWAPD_RECLAIM;
 	dev->vidq.buf_struct_size = sizeof(struct tw68_buf);
 	dev->vidq.lock = &dev->lock;
 	dev->vidq.min_buffers_needed = 2;

commit 33119e80c3b96ac81912677a6e86dc1890a5859f
Author: Junghak Sung <jh1009.sung@samsung.com>
Date:   Tue Oct 6 06:37:46 2015 -0300

    [media] media: videobuf2: Change queue_setup argument
    
    Replace struct v4l2_format * with void * to make queue_setup()
    for common use.
    And then, modify all device drivers related with this change.
    
    Signed-off-by: Junghak Sung <jh1009.sung@samsung.com>
    Signed-off-by: Geunyoung Kim <nenggun.kim@samsung.com>
    Acked-by: Seung-Woo Kim <sw0312.kim@samsung.com>
    Acked-by: Inki Dae <inki.dae@samsung.com>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    [hans.verkuil@cisco.com: fix missing const in fimc-lite.c]
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/pci/tw68/tw68-video.c b/drivers/media/pci/tw68/tw68-video.c
index 323721439b8e..4c3293dcddbc 100644
--- a/drivers/media/pci/tw68/tw68-video.c
+++ b/drivers/media/pci/tw68/tw68-video.c
@@ -376,10 +376,11 @@ static int tw68_buffer_count(unsigned int size, unsigned int count)
 /* ------------------------------------------------------------- */
 /* vb2 queue operations                                          */
 
-static int tw68_queue_setup(struct vb2_queue *q, const struct v4l2_format *fmt,
+static int tw68_queue_setup(struct vb2_queue *q, const void *parg,
 			   unsigned int *num_buffers, unsigned int *num_planes,
 			   unsigned int sizes[], void *alloc_ctxs[])
 {
+	const struct v4l2_format *fmt = parg;
 	struct tw68_dev *dev = vb2_get_drv_priv(q);
 	unsigned tot_bufs = q->num_buffers + *num_buffers;
 

commit 2d7007153f0c9b1dd00c01894df7d26ddc32b79f
Author: Junghak Sung <jh1009.sung@samsung.com>
Date:   Tue Sep 22 10:30:30 2015 -0300

    [media] media: videobuf2: Restructure vb2_buffer
    
    Remove v4l2 stuff - v4l2_buf, v4l2_plane - from struct vb2_buffer.
    
    Add new member variables - bytesused, length, offset, userptr, fd,
    data_offset - to struct vb2_plane in order to cover all information
    of v4l2_plane.
    struct vb2_plane {
            <snip>
            unsigned int            bytesused;
            unsigned int            length;
            union {
                    unsigned int    offset;
                    unsigned long   userptr;
                    int             fd;
            } m;
            unsigned int            data_offset;
    }
    
    Replace v4l2_buf with new member variables - index, type, memory - which
    are common fields for buffer management.
    struct vb2_buffer {
            <snip>
            unsigned int            index;
            unsigned int            type;
            unsigned int            memory;
            unsigned int            num_planes;
            struct vb2_plane        planes[VIDEO_MAX_PLANES];
            <snip>
    };
    
    v4l2 specific fields - flags, field, timestamp, timecode,
    sequence - are moved to vb2_v4l2_buffer in videobuf2-v4l2.c
    struct vb2_v4l2_buffer {
            struct vb2_buffer       vb2_buf;
    
            __u32                   flags;
            __u32                   field;
            struct timeval          timestamp;
            struct v4l2_timecode    timecode;
            __u32                   sequence;
    };
    
    Signed-off-by: Junghak Sung <jh1009.sung@samsung.com>
    Signed-off-by: Geunyoung Kim <nenggun.kim@samsung.com>
    Acked-by: Seung-Woo Kim <sw0312.kim@samsung.com>
    Acked-by: Inki Dae <inki.dae@samsung.com>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/pci/tw68/tw68-video.c b/drivers/media/pci/tw68/tw68-video.c
index 8355e55b4e8e..323721439b8e 100644
--- a/drivers/media/pci/tw68/tw68-video.c
+++ b/drivers/media/pci/tw68/tw68-video.c
@@ -423,9 +423,10 @@ static int tw68_queue_setup(struct vb2_queue *q, const struct v4l2_format *fmt,
  */
 static void tw68_buf_queue(struct vb2_buffer *vb)
 {
+	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
 	struct vb2_queue *vq = vb->vb2_queue;
 	struct tw68_dev *dev = vb2_get_drv_priv(vq);
-	struct tw68_buf *buf = container_of(vb, struct tw68_buf, vb);
+	struct tw68_buf *buf = container_of(vbuf, struct tw68_buf, vb);
 	struct tw68_buf *prev;
 	unsigned long flags;
 
@@ -457,9 +458,10 @@ static void tw68_buf_queue(struct vb2_buffer *vb)
  */
 static int tw68_buf_prepare(struct vb2_buffer *vb)
 {
+	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
 	struct vb2_queue *vq = vb->vb2_queue;
 	struct tw68_dev *dev = vb2_get_drv_priv(vq);
-	struct tw68_buf *buf = container_of(vb, struct tw68_buf, vb);
+	struct tw68_buf *buf = container_of(vbuf, struct tw68_buf, vb);
 	struct sg_table *dma = vb2_dma_sg_plane_desc(vb, 0);
 	unsigned size, bpl;
 
@@ -499,9 +501,10 @@ static int tw68_buf_prepare(struct vb2_buffer *vb)
 
 static void tw68_buf_finish(struct vb2_buffer *vb)
 {
+	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
 	struct vb2_queue *vq = vb->vb2_queue;
 	struct tw68_dev *dev = vb2_get_drv_priv(vq);
-	struct tw68_buf *buf = container_of(vb, struct tw68_buf, vb);
+	struct tw68_buf *buf = container_of(vbuf, struct tw68_buf, vb);
 
 	pci_free_consistent(dev->pci, buf->size, buf->cpu, buf->dma);
 }
@@ -528,7 +531,7 @@ static void tw68_stop_streaming(struct vb2_queue *q)
 			container_of(dev->active.next, struct tw68_buf, list);
 
 		list_del(&buf->list);
-		vb2_buffer_done(&buf->vb, VB2_BUF_STATE_ERROR);
+		vb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);
 	}
 }
 
@@ -1012,10 +1015,10 @@ void tw68_irq_video_done(struct tw68_dev *dev, unsigned long status)
 		buf = list_entry(dev->active.next, struct tw68_buf, list);
 		list_del(&buf->list);
 		spin_unlock(&dev->slock);
-		v4l2_get_timestamp(&buf->vb.v4l2_buf.timestamp);
-		buf->vb.v4l2_buf.field = dev->field;
-		buf->vb.v4l2_buf.sequence = dev->seqnr++;
-		vb2_buffer_done(&buf->vb, VB2_BUF_STATE_DONE);
+		v4l2_get_timestamp(&buf->vb.timestamp);
+		buf->vb.field = dev->field;
+		buf->vb.sequence = dev->seqnr++;
+		vb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_DONE);
 		status &= ~(TW68_DMAPI);
 		if (0 == status)
 			return;

commit d790b7eda953df474f470169ebdf111c02fa7a2d
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Mon Nov 24 08:50:31 2014 -0300

    [media] vb2-dma-sg: move dma_(un)map_sg here
    
    This moves dma_(un)map_sg to the get_userptr/put_userptr and alloc/put
    memops of videobuf2-dma-sg.c and adds dma_sync_sg_for_device/cpu to the
    prepare/finish memops.
    
    Now that vb2-dma-sg will sync the buffers for you in the prepare/finish
    memops we can drop that from the drivers that use dma-sg.
    
    For the solo6x10 driver that was a bit more involved because it needs to
    copy JPEG or MPEG headers to the buffer before returning it to userspace,
    and that cannot be done in the old place since the buffer there is still
    setup for DMA access, not for CPU access. However, the buf_finish
    op is the ideal place to do this. By the time buf_finish is called
    the buffer is available for CPU access, so copying to the buffer is fine.
    
    [mchehab@osg.samsung.com: Fix a compilation breakage:
     drivers/media/v4l2-core/videobuf2-dma-sg.c:150:19: error: 'struct vb2_dma_sg_buf' has no member named 'dma_sgt']
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Acked-by: Pawel Osciak <pawel@osciak.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/pci/tw68/tw68-video.c b/drivers/media/pci/tw68/tw68-video.c
index 50dcce6251f6..8355e55b4e8e 100644
--- a/drivers/media/pci/tw68/tw68-video.c
+++ b/drivers/media/pci/tw68/tw68-video.c
@@ -462,17 +462,12 @@ static int tw68_buf_prepare(struct vb2_buffer *vb)
 	struct tw68_buf *buf = container_of(vb, struct tw68_buf, vb);
 	struct sg_table *dma = vb2_dma_sg_plane_desc(vb, 0);
 	unsigned size, bpl;
-	int rc;
 
 	size = (dev->width * dev->height * dev->fmt->depth) >> 3;
 	if (vb2_plane_size(vb, 0) < size)
 		return -EINVAL;
 	vb2_set_plane_payload(vb, 0, size);
 
-	rc = dma_map_sg(&dev->pci->dev, dma->sgl, dma->nents, DMA_FROM_DEVICE);
-	if (!rc)
-		return -EIO;
-
 	bpl = (dev->width * dev->fmt->depth) >> 3;
 	switch (dev->field) {
 	case V4L2_FIELD_TOP:
@@ -506,11 +501,8 @@ static void tw68_buf_finish(struct vb2_buffer *vb)
 {
 	struct vb2_queue *vq = vb->vb2_queue;
 	struct tw68_dev *dev = vb2_get_drv_priv(vq);
-	struct sg_table *dma = vb2_dma_sg_plane_desc(vb, 0);
 	struct tw68_buf *buf = container_of(vb, struct tw68_buf, vb);
 
-	dma_unmap_sg(&dev->pci->dev, dma->sgl, dma->nents, DMA_FROM_DEVICE);
-
 	pci_free_consistent(dev->pci, buf->size, buf->cpu, buf->dma);
 }
 

commit 0c3a14c177aa85afb991e7c2be3921aa9a52a893
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Tue Nov 18 09:51:01 2014 -0300

    [media] vb2-dma-sg: add allocation context to dma-sg
    
    Require that dma-sg also uses an allocation context. This is in preparation
    for adding prepare/finish memops to sync the memory between DMA and CPU.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Acked-by: Pawel Osciak <pawel@osciak.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/pci/tw68/tw68-video.c b/drivers/media/pci/tw68/tw68-video.c
index 5c94ac7c88d9..50dcce6251f6 100644
--- a/drivers/media/pci/tw68/tw68-video.c
+++ b/drivers/media/pci/tw68/tw68-video.c
@@ -384,6 +384,7 @@ static int tw68_queue_setup(struct vb2_queue *q, const struct v4l2_format *fmt,
 	unsigned tot_bufs = q->num_buffers + *num_buffers;
 
 	sizes[0] = (dev->fmt->depth * dev->width * dev->height) >> 3;
+	alloc_ctxs[0] = dev->alloc_ctx;
 	/*
 	 * We allow create_bufs, but only if the sizeimage is the same as the
 	 * current sizeimage. The tw68_buffer_count calculation becomes quite

commit 91f96e8b7255537da3a58805cf465003521d7c5f
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Thu Sep 4 13:26:53 2014 -0300

    [media] tw68: drop bogus cpu_to_le32() call
    
    tw_writel maps to writel which maps to __raw_writel(__cpu_to_le32(b),addr).
    So tw_writel already calls cpu_to_le32 and it shouldn't be called again
    in the code.
    
    Reported-by: Mauro Carvalho Chehab <m.chehab@samsung.com>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/drivers/media/pci/tw68/tw68-video.c b/drivers/media/pci/tw68/tw68-video.c
index 498ead9a956d..5c94ac7c88d9 100644
--- a/drivers/media/pci/tw68/tw68-video.c
+++ b/drivers/media/pci/tw68/tw68-video.c
@@ -348,7 +348,7 @@ int tw68_video_start_dma(struct tw68_dev *dev, struct tw68_buf *buf)
 	 *  a new address can be set.
 	 */
 	tw_clearl(TW68_DMAC, TW68_DMAP_EN);
-	tw_writel(TW68_DMAP_SA, cpu_to_le32(buf->dma));
+	tw_writel(TW68_DMAP_SA, buf->dma);
 	/* Clear any pending interrupts */
 	tw_writel(TW68_INTSTAT, dev->board_virqmask);
 	/* Enable the risc engine and the fifo */

commit 947b38bb110c90e0bc93e7afe9ab6f007b6799a7
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Thu Sep 4 13:26:52 2014 -0300

    [media] tw68: simplify tw68_buffer_count
    
    The code to calculate the maximum number of buffers allowed in 4 MB
    is 1) wrong if PAGE_SIZE != 4096 and 2) unnecessarily complex.
    
    Fix and simplify the code.
    
    Reported-by: Mauro Carvalho Chehab <m.chehab@samsung.com>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/drivers/media/pci/tw68/tw68-video.c b/drivers/media/pci/tw68/tw68-video.c
index 66fae2345fdd..498ead9a956d 100644
--- a/drivers/media/pci/tw68/tw68-video.c
+++ b/drivers/media/pci/tw68/tw68-video.c
@@ -361,22 +361,13 @@ int tw68_video_start_dma(struct tw68_dev *dev, struct tw68_buf *buf)
 
 /* ------------------------------------------------------------------ */
 
-/* nr of (tw68-)pages for the given buffer size */
-static int tw68_buffer_pages(int size)
-{
-	size  = PAGE_ALIGN(size);
-	size += PAGE_SIZE; /* for non-page-aligned buffers */
-	size /= 4096;
-	return size;
-}
-
 /* calc max # of buffers from size (must not exceed the 4MB virtual
  * address space per DMA channel) */
 static int tw68_buffer_count(unsigned int size, unsigned int count)
 {
 	unsigned int maxcount;
 
-	maxcount = 1024 / tw68_buffer_pages(size);
+	maxcount = (4 * 1024 * 1024) / roundup(size, PAGE_SIZE);
 	if (count > maxcount)
 		count = maxcount;
 	return count;

commit e15d1c12c5878b3a80d6573af1721e17264e0286
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Wed Sep 3 03:36:14 2014 -0300

    [media] tw68: refactor and cleanup the tw68 driver
    
    Refactor and clean up the tw68 driver. It's now using the proper
    V4L2 core frameworks.
    
    Tested with my Techwell tw6805a and tw6816 grabber boards.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/drivers/media/pci/tw68/tw68-video.c b/drivers/media/pci/tw68/tw68-video.c
index ca08ca38d3bd..66fae2345fdd 100644
--- a/drivers/media/pci/tw68/tw68-video.c
+++ b/drivers/media/pci/tw68/tw68-video.c
@@ -8,7 +8,11 @@
  *  acknowledged.  Full credit goes to them - any problems within this code
  *  are mine.
  *
- *  Copyright (C) 2009  William M. Brack <wbrack@mmm.com.hk>
+ *  Copyright (C) 2009  William M. Brack
+ *
+ *  Refactored and updated to the latest v4l core frameworks:
+ *
+ *  Copyright (C) 2014 Hans Verkuil <hverkuil@xs4all.nl>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
@@ -19,39 +23,16 @@
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License along
- *  with this program; if not, write to the Free Software Foundation, Inc.,
- *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  */
 
 #include <linux/module.h>
 #include <media/v4l2-common.h>
-#include <linux/sort.h>
+#include <media/v4l2-event.h>
+#include <media/videobuf2-dma-sg.h>
 
 #include "tw68.h"
 #include "tw68-reg.h"
 
-unsigned int video_debug;
-
-static unsigned int gbuffers	= 8;
-static unsigned int noninterlaced; /* 0 */
-static unsigned int gbufsz	= 768*576*4;
-static unsigned int gbufsz_max	= 768*576*4;
-static char secam[]		= "--";
-
-module_param(video_debug, int, 0644);
-MODULE_PARM_DESC(video_debug, "enable debug messages [video]");
-module_param(gbuffers, int, 0444);
-MODULE_PARM_DESC(gbuffers, "number of capture buffers, range 2-32");
-module_param(noninterlaced, int, 0644);
-MODULE_PARM_DESC(noninterlaced, "capture non interlaced video");
-module_param_string(secam, secam, sizeof(secam), 0644);
-MODULE_PARM_DESC(secam, "force SECAM variant, either DK,L or Lc");
-
-#define dprintk(level, fmt, arg...)     if (video_debug & (level)) \
-	printk(KERN_DEBUG "%s/0: " fmt, dev->name , ## arg)
-
 /* ------------------------------------------------------------------ */
 /* data structs for video                                             */
 /*
@@ -60,7 +41,7 @@ MODULE_PARM_DESC(secam, "force SECAM variant, either DK,L or Lc");
  * as "planar".  These affect overlay mode, and are flagged with a field
  * ".planar" in the format.  Do we need to implement this in this driver?
  */
-static struct tw68_format formats[] = {
+static const struct tw68_format formats[] = {
 	{
 		.name		= "15 bpp RGB, le",
 		.fourcc		= V4L2_PIX_FMT_RGB555,
@@ -145,47 +126,8 @@ static struct tw68_format formats[] = {
  * match, then for an entry which contains the desired id.  The table
  * entries should therefore be ordered in ascending order of specificity.
  */
-static struct tw68_tvnorm tvnorms[]		= {
+static const struct tw68_tvnorm tvnorms[] = {
 	{
-		.name		= "PAL-BG",
-		.id		= V4L2_STD_PAL_BG,
-		NORM_625_50,
-
-		.sync_control	= 0x18,
-		.luma_control	= 0x40,
-		.chroma_ctrl1	= 0x81,
-		.chroma_gain	= 0x2a,
-		.chroma_ctrl2	= 0x06,
-		.vgate_misc	= 0x1c,
-		.format		= VideoFormatPALBDGHI,
-
-	}, {
-		.name		= "PAL-I",
-		.id		= V4L2_STD_PAL_I,
-		NORM_625_50,
-
-		.sync_control	= 0x18,
-		.luma_control	= 0x40,
-		.chroma_ctrl1	= 0x81,
-		.chroma_gain	= 0x2a,
-		.chroma_ctrl2	= 0x06,
-		.vgate_misc	= 0x1c,
-		.format		= VideoFormatPALBDGHI,
-
-	}, {
-		.name		= "PAL-DK",
-		.id		= V4L2_STD_PAL_DK,
-		NORM_625_50,
-
-		.sync_control	= 0x18,
-		.luma_control	= 0x40,
-		.chroma_ctrl1	= 0x81,
-		.chroma_gain	= 0x2a,
-		.chroma_ctrl2	= 0x06,
-		.vgate_misc	= 0x1c,
-		.format		= VideoFormatPALBDGHI,
-
-	}, {
 		.name		= "PAL", /* autodetect */
 		.id		= V4L2_STD_PAL,
 		NORM_625_50,
@@ -197,7 +139,6 @@ static struct tw68_tvnorm tvnorms[]		= {
 		.chroma_ctrl2	= 0x06,
 		.vgate_misc	= 0x1c,
 		.format		= VideoFormatPALBDGHI,
-
 	}, {
 		.name		= "NTSC",
 		.id		= V4L2_STD_NTSC,
@@ -210,46 +151,6 @@ static struct tw68_tvnorm tvnorms[]		= {
 		.chroma_ctrl2	= 0x0e,
 		.vgate_misc	= 0x18,
 		.format		= VideoFormatNTSC,
-
-	}, {
-		.name		= "SECAM-DK",
-		.id		= V4L2_STD_SECAM_DK,
-		NORM_625_50,
-
-		.sync_control	= 0x18,
-		.luma_control	= 0x1b,
-		.chroma_ctrl1	= 0xd1,
-		.chroma_gain	= 0x80,
-		.chroma_ctrl2	= 0x00,
-		.vgate_misc	= 0x1c,
-		.format		= VideoFormatSECAM,
-
-	}, {
-		.name		= "SECAM-L",
-		.id		= V4L2_STD_SECAM_L,
-		NORM_625_50,
-
-		.sync_control	= 0x18,
-		.luma_control	= 0x1b,
-		.chroma_ctrl1	= 0xd1,
-		.chroma_gain	= 0x80,
-		.chroma_ctrl2	= 0x00,
-		.vgate_misc	= 0x1c,
-		.format		= VideoFormatSECAM,
-
-	}, {
-		.name		= "SECAM-LC",
-		.id		= V4L2_STD_SECAM_LC,
-		NORM_625_50,
-
-		.sync_control	= 0x18,
-		.luma_control	= 0x1b,
-		.chroma_ctrl1	= 0xd1,
-		.chroma_gain	= 0x80,
-		.chroma_ctrl2	= 0x00,
-		.vgate_misc	= 0x1c,
-		.format		= VideoFormatSECAM,
-
 	}, {
 		.name		= "SECAM",
 		.id		= V4L2_STD_SECAM,
@@ -262,7 +163,6 @@ static struct tw68_tvnorm tvnorms[]		= {
 		.chroma_ctrl2	= 0x00,
 		.vgate_misc	= 0x1c,
 		.format		= VideoFormatSECAM,
-
 	}, {
 		.name		= "PAL-M",
 		.id		= V4L2_STD_PAL_M,
@@ -275,7 +175,6 @@ static struct tw68_tvnorm tvnorms[]		= {
 		.chroma_ctrl2	= 0x0e,
 		.vgate_misc	= 0x18,
 		.format		= VideoFormatPALM,
-
 	}, {
 		.name		= "PAL-Nc",
 		.id		= V4L2_STD_PAL_Nc,
@@ -288,7 +187,6 @@ static struct tw68_tvnorm tvnorms[]		= {
 		.chroma_ctrl2	= 0x06,
 		.vgate_misc	= 0x1c,
 		.format		= VideoFormatPALNC,
-
 	}, {
 		.name		= "PAL-60",
 		.id		= V4L2_STD_PAL_60,
@@ -309,127 +207,11 @@ static struct tw68_tvnorm tvnorms[]		= {
 		.chroma_ctrl2	= 0x06,
 		.vgate_misc	= 0x1c,
 		.format		= VideoFormatPAL60,
-
-	}, {
-/*
- * 	FIXME:  The following are meant to be "catch-all", and need
- *		to be further thought out!
- */
-		.name		= "STD-525-60",
-		.id		= V4L2_STD_525_60,
-		NORM_525_60,
-
-		.sync_control	= 0x59,
-		.luma_control	= 0x40,
-		.chroma_ctrl1	= 0x89,
-		.chroma_gain	= 0x2a,
-		.chroma_ctrl2	= 0x0e,
-		.vgate_misc	= 0x18,
-		.format		= VideoFormatNTSC,
-
-	}, {
-		.name		= "STD-625-50",
-		.id		= V4L2_STD_625_50,
-		NORM_625_50,
-
-		.sync_control	= 0x18,
-		.luma_control	= 0x40,
-		.chroma_ctrl1	= 0x81,
-		.chroma_gain	= 0x2a,
-		.chroma_ctrl2	= 0x06,
-		.vgate_misc	= 0x1c,
-		.format		= VideoFormatPALBDGHI,
 	}
 };
 #define TVNORMS ARRAY_SIZE(tvnorms)
 
-static const struct v4l2_queryctrl no_ctrl		= {
-	.name		= "42",
-	.flags		= V4L2_CTRL_FLAG_DISABLED,
-};
-static const struct v4l2_queryctrl video_ctrls[]		= {
-	/* --- video --- */
-	{
-		.id		= V4L2_CID_BRIGHTNESS,
-		.name		= "Brightness",
-		.minimum	= -128,
-		.maximum	= 127,
-		.step		= 1,
-		.default_value	= 20,
-		.type		= V4L2_CTRL_TYPE_INTEGER,
-	}, {
-		.id		= V4L2_CID_CONTRAST,
-		.name		= "Contrast",
-		.minimum	= 0,
-		.maximum	= 255,
-		.step		= 1,
-		.default_value	= 100,
-		.type		= V4L2_CTRL_TYPE_INTEGER,
-	}, {
-		.id		= V4L2_CID_SATURATION,
-		.name		= "Saturation",
-		.minimum	= 0,
-		.maximum	= 255,
-		.step		= 1,
-		.default_value	= 128,
-		.type		= V4L2_CTRL_TYPE_INTEGER,
-	}, {
-		.id		= V4L2_CID_HUE,
-		.name		= "Hue",
-		.minimum	= -128,
-		.maximum	= 127,
-		.step		= 1,
-		.default_value	= 0,
-		.type		= V4L2_CTRL_TYPE_INTEGER,
-	}, {
-		.id		= V4L2_CID_COLOR_KILLER,
-		.name		= "Color Killer",
-		.minimum	= 0,
-		.maximum	= 1,
-		.default_value	= 1,
-		.type		= V4L2_CTRL_TYPE_BOOLEAN,
-	}, {
-		.id		= V4L2_CID_CHROMA_AGC,
-		.name		= "Chroma AGC",
-		.minimum	= 0,
-		.maximum	= 1,
-		.default_value	= 1,
-		.type		= V4L2_CTRL_TYPE_BOOLEAN,
-	},
-	/* --- audio --- */
-	{
-		.id		= V4L2_CID_AUDIO_MUTE,
-		.name		= "Mute",
-		.minimum	= 0,
-		.maximum	= 1,
-		.type		= V4L2_CTRL_TYPE_BOOLEAN,
-	}, {
-		.id		= V4L2_CID_AUDIO_VOLUME,
-		.name		= "Volume",
-		.minimum	= -15,
-		.maximum	= 15,
-		.step		= 1,
-		.default_value	= 0,
-		.type		= V4L2_CTRL_TYPE_INTEGER,
-	}
-};
-static const unsigned int CTRLS = ARRAY_SIZE(video_ctrls);
-
-/*
- * Routine to lookup a control by its ID, and return a pointer
- * to the entry in the video_ctrls array for that control.
- */
-static const struct v4l2_queryctrl *ctrl_by_id(unsigned int id)
-{
-	unsigned int i;
-
-	for (i = 0; i < CTRLS; i++)
-		if (video_ctrls[i].id == id)
-			return video_ctrls+i;
-	return NULL;
-}
-
-static struct tw68_format *format_by_fourcc(unsigned int fourcc)
+static const struct tw68_format *format_by_fourcc(unsigned int fourcc)
 {
 	unsigned int i;
 
@@ -439,99 +221,22 @@ static struct tw68_format *format_by_fourcc(unsigned int fourcc)
 	return NULL;
 }
 
-/* ----------------------------------------------------------------------- */
-/* resource management                                                     */
-
-static int res_get(struct tw68_fh *fh, unsigned int bit)
-{
-	struct tw68_dev *dev = fh->dev;
-
-	if (fh->resources & bit)
-		/* have it already allocated */
-		return 1;
-
-	/* is it free? */
-	mutex_lock(&dev->lock);
-	if (dev->resources & bit) {
-		/* no, someone else uses it */
-		mutex_unlock(&fh->dev->lock);
-		return 0;
-	}
-	/* it's free, grab it */
-	fh->resources  |= bit;
-	dev->resources |= bit;
-	dprintk(DBG_FLOW, "%s: %d\n", __func__, bit);
-	mutex_unlock(&dev->lock);
-	return 1;
-}
-
-static int res_check(struct tw68_fh *fh, unsigned int bit)
-{
-	return fh->resources & bit;
-}
-
-static int res_locked(struct tw68_dev *dev, unsigned int bit)
-{
-	return dev->resources & bit;
-}
-
-static void res_free(struct tw68_fh *fh,
-		     unsigned int bits)
-{
-	struct tw68_dev *dev = fh->dev;
-
-	BUG_ON((fh->resources & bits) != bits);
-
-	mutex_lock(&fh->dev->lock);
-	fh->resources  &= ~bits;
-	fh->dev->resources &= ~bits;
-	dprintk(DBG_FLOW, "%s: %d\n", __func__, bits);
-	mutex_unlock(&fh->dev->lock);
-}
 
 /* ------------------------------------------------------------------ */
 /*
  * Note that the cropping rectangles are described in terms of a single
  * frame, i.e. line positions are only 1/2 the interlaced equivalent
  */
-static void set_tvnorm(struct tw68_dev *dev, struct tw68_tvnorm *norm)
+static void set_tvnorm(struct tw68_dev *dev, const struct tw68_tvnorm *norm)
 {
-	dprintk(DBG_FLOW, "%s: %s\n", __func__, norm->name);
-	dev->tvnorm = norm;
-
-	/* setup cropping */
-	dev->crop_bounds.left    = norm->h_start;
-	dev->crop_defrect.left   = norm->h_start;
-	dev->crop_bounds.width   = norm->h_stop - norm->h_start + 1;
-	dev->crop_defrect.width  = norm->h_stop - norm->h_start + 1;
-
-	dev->crop_bounds.top     = norm->video_v_start;
-	dev->crop_defrect.top    = norm->video_v_start;
-	dev->crop_bounds.height  = (((norm->id & V4L2_STD_525_60) ?
-				    524 : 624)) / 2 - dev->crop_bounds.top;
-	dev->crop_defrect.height = (norm->video_v_stop -
-				    norm->video_v_start + 1);
-
-	dev->crop_current = dev->crop_defrect;
-
 	if (norm != dev->tvnorm) {
+		dev->width = 720;
+		dev->height = (norm->id & V4L2_STD_525_60) ? 480 : 576;
 		dev->tvnorm = norm;
 		tw68_set_tvnorm_hw(dev);
 	}
 }
 
-static void video_mux(struct tw68_dev *dev, int input)
-{
-	dprintk(DBG_FLOW, "%s: input = %d [%s]\n", __func__, input,
-		card_in(dev, input).name);
-	/*
-	 * dev->input shows current application request,
-	 * dev->hw_input shows current hardware setting
-	 */
-	dev->input = &card_in(dev, input);
-	tw68_tvaudio_setinput(dev, &card_in(dev, input));
-}
-
 /*
  * tw68_set_scale
  *
@@ -544,7 +249,7 @@ static void video_mux(struct tw68_dev *dev, int input)
  * before scaling.  HDELAY represents the number of pixels skipped
  * between the start of the horizontal sync and the start of the image.
  * HSCALE is calculated using the formula
- * 	HSCALE = (HACTIVE / (#pixels desired)) * 256
+ *	HSCALE = (HACTIVE / (#pixels desired)) * 256
  *
  * The vertical registers are similar, except based upon the total number
  * of lines in the image, and the first line of the image (i.e. ignoring
@@ -555,16 +260,16 @@ static void video_mux(struct tw68_dev *dev, int input)
  * these values, especially HSCALE.
  *
  * Parameters:
- * 	@dev		pointer to the device structure, needed for
- * 			getting current norm (as well as debug print)
- * 	@width		actual image width (from user buffer)
- * 	@height		actual image height
- * 	@field		indicates Top, Bottom or Interlaced
+ *	@dev		pointer to the device structure, needed for
+ *			getting current norm (as well as debug print)
+ *	@width		actual image width (from user buffer)
+ *	@height		actual image height
+ *	@field		indicates Top, Bottom or Interlaced
  */
 static int tw68_set_scale(struct tw68_dev *dev, unsigned int width,
 			  unsigned int height, enum v4l2_field field)
 {
-
+	const struct tw68_tvnorm *norm = dev->tvnorm;
 	/* set individually for debugging clarity */
 	int hactive, hdelay, hscale;
 	int vactive, vdelay, vscale;
@@ -573,41 +278,38 @@ static int tw68_set_scale(struct tw68_dev *dev, unsigned int width,
 	if (V4L2_FIELD_HAS_BOTH(field))	/* if field is interlaced */
 		height /= 2;		/* we must set for 1-frame */
 
-	dprintk(DBG_FLOW, "%s: width=%d, height=%d, both=%d\n  Crop rect: "
-		    "top=%d, left=%d, width=%d height=%d\n"
-		    "  tvnorm h_delay=%d, h_start=%d, h_stop=%d, "
-		    "v_delay=%d, v_start=%d, v_stop=%d\n" , __func__,
+	pr_debug("%s: width=%d, height=%d, both=%d\n"
+		 "  tvnorm h_delay=%d, h_start=%d, h_stop=%d, "
+		 "v_delay=%d, v_start=%d, v_stop=%d\n" , __func__,
 		width, height, V4L2_FIELD_HAS_BOTH(field),
-		dev->crop_bounds.top, dev->crop_bounds.left,
-		dev->crop_bounds.width, dev->crop_bounds.height,
-		dev->tvnorm->h_delay, dev->tvnorm->h_start, dev->tvnorm->h_stop,
-		dev->tvnorm->v_delay, dev->tvnorm->video_v_start,
-		dev->tvnorm->video_v_stop);
+		norm->h_delay, norm->h_start, norm->h_stop,
+		norm->v_delay, norm->video_v_start,
+		norm->video_v_stop);
 
 	switch (dev->vdecoder) {
 	case TW6800:
-		hdelay = dev->tvnorm->h_delay0;
+		hdelay = norm->h_delay0;
 		break;
 	default:
-		hdelay = dev->tvnorm->h_delay;
+		hdelay = norm->h_delay;
 		break;
 	}
-	hdelay += dev->crop_bounds.left;
-	hactive = dev->crop_bounds.width;
+
+	hdelay += norm->h_start;
+	hactive = norm->h_stop - norm->h_start + 1;
 
 	hscale = (hactive * 256) / (width);
 
-	vdelay = dev->tvnorm->v_delay + dev->crop_bounds.top -
-		 dev->crop_defrect.top;
-	vactive = dev->crop_bounds.height;
+	vdelay = norm->v_delay;
+	vactive = ((norm->id & V4L2_STD_525_60) ? 524 : 624) / 2 - norm->video_v_start;
 	vscale = (vactive * 256) / height;
 
-	dprintk(DBG_FLOW, "%s: %dx%d [%s%s,%s]\n", __func__,
+	pr_debug("%s: %dx%d [%s%s,%s]\n", __func__,
 		width, height,
 		V4L2_FIELD_HAS_TOP(field)    ? "T" : "",
 		V4L2_FIELD_HAS_BOTTOM(field) ? "B" : "",
 		v4l2_norm_to_name(dev->tvnorm->id));
-	dprintk(DBG_FLOW, "%s: hactive=%d, hdelay=%d, hscale=%d; "
+	pr_debug("%s: hactive=%d, hdelay=%d, hscale=%d; "
 		"vactive=%d, vdelay=%d, vscale=%d\n", __func__,
 		hactive, hdelay, hscale, vactive, vdelay, vscale);
 
@@ -615,7 +317,7 @@ static int tw68_set_scale(struct tw68_dev *dev, unsigned int width,
 		((vactive & 0x300) >> 4) |
 		((hdelay & 0x300)  >> 6) |
 		((hactive & 0x300) >> 8);
-	dprintk(DBG_FLOW, "%s: setting CROP_HI=%02x, VDELAY_LO=%02x, "
+	pr_debug("%s: setting CROP_HI=%02x, VDELAY_LO=%02x, "
 		"VACTIVE_LO=%02x, HDELAY_LO=%02x, HACTIVE_LO=%02x\n",
 		__func__, comb, vdelay, vactive, hdelay, hactive);
 	tw_writeb(TW68_CROP_HI, comb);
@@ -625,7 +327,7 @@ static int tw68_set_scale(struct tw68_dev *dev, unsigned int width,
 	tw_writeb(TW68_HACTIVE_LO, hactive & 0xff);
 
 	comb = ((vscale & 0xf00) >> 4) | ((hscale & 0xf00) >> 8);
-	dprintk(DBG_FLOW, "%s: setting SCALE_HI=%02x, VSCALE_LO=%02x, "
+	pr_debug("%s: setting SCALE_HI=%02x, VSCALE_LO=%02x, "
 		"HSCALE_LO=%02x\n", __func__, comb, vscale, hscale);
 	tw_writeb(TW68_SCALE_HI, comb);
 	tw_writeb(TW68_VSCALE_LO, vscale);
@@ -636,28 +338,21 @@ static int tw68_set_scale(struct tw68_dev *dev, unsigned int width,
 
 /* ------------------------------------------------------------------ */
 
-static int tw68_video_start_dma(struct tw68_dev *dev, struct tw68_dmaqueue *q,
-				struct tw68_buf *buf) {
-
-	dprintk(DBG_FLOW, "%s: Starting risc program\n", __func__);
-	/* Assure correct input */
-	if (dev->hw_input != dev->input) {
-		dev->hw_input = dev->input;
-		tw_andorb(TW68_INFORM, 0x03 << 2, dev->input->vmux << 2);
-	}
+int tw68_video_start_dma(struct tw68_dev *dev, struct tw68_buf *buf)
+{
 	/* Set cropping and scaling */
-	tw68_set_scale(dev, buf->vb.width, buf->vb.height, buf->vb.field);
+	tw68_set_scale(dev, dev->width, dev->height, dev->field);
 	/*
 	 *  Set start address for RISC program.  Note that if the DMAP
 	 *  processor is currently running, it must be stopped before
 	 *  a new address can be set.
 	 */
 	tw_clearl(TW68_DMAC, TW68_DMAP_EN);
-	tw_writel(TW68_DMAP_SA, cpu_to_le32(buf->risc.dma));
+	tw_writel(TW68_DMAP_SA, cpu_to_le32(buf->dma));
 	/* Clear any pending interrupts */
 	tw_writel(TW68_INTSTAT, dev->board_virqmask);
 	/* Enable the risc engine and the fifo */
-	tw_andorl(TW68_DMAC, 0xff, buf->fmt->twformat |
+	tw_andorl(TW68_DMAC, 0xff, dev->fmt->twformat |
 		ColorFormatGamma | TW68_DMAP_EN | TW68_FIFO_EN);
 	dev->pci_irqmask |= dev->board_virqmask;
 	tw_setl(TW68_INTMASK, dev->pci_irqmask);
@@ -665,693 +360,295 @@ static int tw68_video_start_dma(struct tw68_dev *dev, struct tw68_dmaqueue *q,
 }
 
 /* ------------------------------------------------------------------ */
-/* videobuf queue operations                                          */
 
-/*
- * check_buf_fmt
- *
- * callback from tw68-core buffer_queue to determine whether the
- * current buffer and the previous one are "compatible" (i.e. the
- * risc programs can be chained without requiring a format change)
- */
-static int tw68_check_video_fmt(struct tw68_buf *prev, struct tw68_buf *buf)
+/* nr of (tw68-)pages for the given buffer size */
+static int tw68_buffer_pages(int size)
 {
-	return (prev->vb.width  == buf->vb.width  &&
-		prev->vb.height == buf->vb.height &&
-		prev->fmt       == buf->fmt);
+	size  = PAGE_ALIGN(size);
+	size += PAGE_SIZE; /* for non-page-aligned buffers */
+	size /= 4096;
+	return size;
 }
 
-/*
- * buffer_setup
- *
- * Calculate required size of buffer and maximum number allowed
- */
-static int
-buffer_setup(struct videobuf_queue *q, unsigned int *count,
-	     unsigned int *size)
+/* calc max # of buffers from size (must not exceed the 4MB virtual
+ * address space per DMA channel) */
+static int tw68_buffer_count(unsigned int size, unsigned int count)
 {
-	struct tw68_fh *fh = q->priv_data;
+	unsigned int maxcount;
 
-	*size = fh->fmt->depth * fh->width * fh->height >> 3;
-	if (0 == *count)
-		*count = gbuffers;
-	*count = tw68_buffer_count(*size, *count);
-	return 0;
+	maxcount = 1024 / tw68_buffer_pages(size);
+	if (count > maxcount)
+		count = maxcount;
+	return count;
 }
 
-static int buffer_activate(struct tw68_dev *dev, struct tw68_buf *buf,
-			   struct tw68_buf *next)
-{
-	dprintk(DBG_BUFF, "%s: dev=%p, buf=%p, next=%p\n",
-		__func__, dev, buf, next);
-	if (dev->hw_input != dev->input) {
-		dev->hw_input = dev->input;
-		tw_andorb(TW68_INFORM, 0x03 << 2,
-			  dev->hw_input->vmux << 2);
-	}
-	buf->vb.state = VIDEOBUF_ACTIVE;
-	/* TODO - need to assure scaling/cropping are set correctly */
-	mod_timer(&dev->video_q.timeout, jiffies+BUFFER_TIMEOUT);
-	return 0;
-}
+/* ------------------------------------------------------------- */
+/* vb2 queue operations                                          */
 
-/*
-* buffer_prepare
-*
-* Set the ancilliary information into the buffer structure.  This
-* includes generating the necessary risc program if it hasn't already
-* been done for the current buffer format.
-* The structure fh contains the details of the format requested by the
-* user - type, width, height and #fields.  This is compared with the
-* last format set for the current buffer.  If they differ, the risc
-* code (which controls the filling of the buffer) is (re-)generated.
-*/
-static int
-buffer_prepare(struct videobuf_queue *q, struct videobuf_buffer *vb,
-	       enum v4l2_field field)
+static int tw68_queue_setup(struct vb2_queue *q, const struct v4l2_format *fmt,
+			   unsigned int *num_buffers, unsigned int *num_planes,
+			   unsigned int sizes[], void *alloc_ctxs[])
 {
-	struct tw68_fh   *fh  = q->priv_data;
-	struct tw68_dev  *dev = fh->dev;
-	struct tw68_buf *buf = container_of(vb, struct tw68_buf, vb);
-	struct videobuf_dmabuf *dma = videobuf_to_dma(&buf->vb);
-	int rc, init_buffer = 0;
-	unsigned int maxw, maxh;
-
-	BUG_ON(NULL == fh->fmt);
-	maxw = dev->tvnorm->h_stop - dev->tvnorm->h_start + 1;
-	maxh = 2*(dev->tvnorm->video_v_stop - dev->tvnorm->video_v_start + 1);
-	if (fh->width  < 48 || fh->width  > maxw || fh->height > maxh
-		|| fh->height < 16) {
-		dprintk(DBG_UNEXPECTED, "%s: invalid dimensions - "
-			"fh->width=%d, fh->height=%d, maxw=%d, maxh=%d\n",
-			__func__, fh->width, fh->height, maxw, maxh);
-		return -EINVAL;
-	}
-	buf->vb.size = (fh->width * fh->height * (fh->fmt->depth)) >> 3;
-	if (0 != buf->vb.baddr  &&  buf->vb.bsize < buf->vb.size)
-		return -EINVAL;
-
-	if (buf->fmt       != fh->fmt    ||
-	    buf->vb.width  != fh->width  ||
-	    buf->vb.height != fh->height ||
-	    buf->vb.field  != field) {
-		dprintk(DBG_BUFF, "%s: buf - fmt=%p, width=%3d, height=%3d, "
-			"field=%d\n%s: fh  - fmt=%p, width=%3d, height=%3d, "
-			"field=%d\n", __func__, buf->fmt, buf->vb.width,
-			buf->vb.height, buf->vb.field, __func__, fh->fmt,
-			fh->width, fh->height, field);
-		buf->fmt       = fh->fmt;
-		buf->vb.width  = fh->width;
-		buf->vb.height = fh->height;
-		buf->vb.field  = field;
-		init_buffer = 1;	/* force risc code re-generation */
-	}
-	buf->input = dev->input;
+	struct tw68_dev *dev = vb2_get_drv_priv(q);
+	unsigned tot_bufs = q->num_buffers + *num_buffers;
 
-	if (VIDEOBUF_NEEDS_INIT == buf->vb.state) {
-		rc = videobuf_iolock(q, &buf->vb, NULL);
-		if (0 != rc)
-			goto fail;
-		init_buffer = 1;	/* force risc code re-generation */
-	}
-	dprintk(DBG_BUFF, "%s: q=%p, vb=%p, init_buffer=%d\n",
-		__func__, q, vb, init_buffer);
-
-	if (init_buffer) {
-		buf->bpl = buf->vb.width * (buf->fmt->depth) >> 3;
-		dprintk(DBG_TESTING, "%s: Generating new risc code "
-			"[%dx%dx%d](%d)\n", __func__, buf->vb.width,
-			buf->vb.height, buf->fmt->depth, buf->bpl);
-		switch (buf->vb.field) {
-		case V4L2_FIELD_TOP:
-			tw68_risc_buffer(dev->pci, &buf->risc,
-					 dma->sglist,
-					 0, UNSET,
-					 buf->bpl, 0,
-					 buf->vb.height);
-			break;
-		case V4L2_FIELD_BOTTOM:
-			tw68_risc_buffer(dev->pci, &buf->risc,
-					 dma->sglist,
-					 UNSET, 0,
-					 buf->bpl, 0,
-					 buf->vb.height);
-			break;
-		case V4L2_FIELD_INTERLACED:
-			tw68_risc_buffer(dev->pci, &buf->risc,
-					 dma->sglist,
-					 0, buf->bpl,
-					 buf->bpl, buf->bpl,
-					 buf->vb.height >> 1);
-			break;
-		case V4L2_FIELD_SEQ_TB:
-			tw68_risc_buffer(dev->pci, &buf->risc,
-					 dma->sglist,
-					 0, buf->bpl * (buf->vb.height >> 1),
-					 buf->bpl, 0,
-					 buf->vb.height >> 1);
-			break;
-		case V4L2_FIELD_SEQ_BT:
-			tw68_risc_buffer(dev->pci, &buf->risc,
-					 dma->sglist,
-					 buf->bpl * (buf->vb.height >> 1), 0,
-					 buf->bpl, 0,
-					 buf->vb.height >> 1);
-			break;
-		default:
-			BUG();
-		}
-	}
-	dprintk(DBG_BUFF, "%s: [%p/%d] - %dx%d %dbpp \"%s\" - dma=0x%08lx\n",
-		__func__, buf, buf->vb.i, fh->width, fh->height,
-		fh->fmt->depth, fh->fmt->name, (unsigned long)buf->risc.dma);
+	sizes[0] = (dev->fmt->depth * dev->width * dev->height) >> 3;
+	/*
+	 * We allow create_bufs, but only if the sizeimage is the same as the
+	 * current sizeimage. The tw68_buffer_count calculation becomes quite
+	 * difficult otherwise.
+	 */
+	if (fmt && fmt->fmt.pix.sizeimage < sizes[0])
+		return -EINVAL;
+	*num_planes = 1;
+	if (tot_bufs < 2)
+		tot_bufs = 2;
+	tot_bufs = tw68_buffer_count(sizes[0], tot_bufs);
+	*num_buffers = tot_bufs - q->num_buffers;
 
-	buf->vb.state = VIDEOBUF_PREPARED;
-	buf->activate = buffer_activate;
 	return 0;
-
- fail:
-	tw68_dma_free(q, buf);
-	return rc;
 }
 
 /*
- * buffer_queue
+ * The risc program for each buffers works as follows: it starts with a simple
+ * 'JUMP to addr + 8', which is effectively a NOP. Then the program to DMA the
+ * buffer follows and at the end we have a JUMP back to the start + 8 (skipping
+ * the initial JUMP).
+ *
+ * This is the program of the first buffer to be queued if the active list is
+ * empty and it just keeps DMAing this buffer without generating any interrupts.
+ *
+ * If a new buffer is added then the initial JUMP in the program generates an
+ * interrupt as well which signals that the previous buffer has been DMAed
+ * successfully and that it can be returned to userspace.
+ *
+ * It also sets the final jump of the previous buffer to the start of the new
+ * buffer, thus chaining the new buffer into the DMA chain. This is a single
+ * atomic u32 write, so there is no race condition.
  *
- * Callback whenever a buffer has been requested (by read() or QBUF)
+ * The end-result of all this that you only get an interrupt when a buffer
+ * is ready, so the control flow is very easy.
  */
-static void
-buffer_queue(struct videobuf_queue *q, struct videobuf_buffer *vb)
+static void tw68_buf_queue(struct vb2_buffer *vb)
 {
-	struct tw68_fh	*fh = q->priv_data;
-	struct tw68_buf	*buf = container_of(vb, struct tw68_buf, vb);
+	struct vb2_queue *vq = vb->vb2_queue;
+	struct tw68_dev *dev = vb2_get_drv_priv(vq);
+	struct tw68_buf *buf = container_of(vb, struct tw68_buf, vb);
+	struct tw68_buf *prev;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dev->slock, flags);
 
-	tw68_buffer_queue(fh->dev, &fh->dev->video_q, buf);
+	/* append a 'JUMP to start of buffer' to the buffer risc program */
+	buf->jmp[0] = cpu_to_le32(RISC_JUMP);
+	buf->jmp[1] = cpu_to_le32(buf->dma + 8);
+
+	if (!list_empty(&dev->active)) {
+		prev = list_entry(dev->active.prev, struct tw68_buf, list);
+		buf->cpu[0] |= cpu_to_le32(RISC_INT_BIT);
+		prev->jmp[1] = cpu_to_le32(buf->dma);
+	}
+	list_add_tail(&buf->list, &dev->active);
+	spin_unlock_irqrestore(&dev->slock, flags);
 }
 
 /*
- * buffer_release
+ * buffer_prepare
  *
- * Free a buffer previously allocated.
+ * Set the ancilliary information into the buffer structure.  This
+ * includes generating the necessary risc program if it hasn't already
+ * been done for the current buffer format.
+ * The structure fh contains the details of the format requested by the
+ * user - type, width, height and #fields.  This is compared with the
+ * last format set for the current buffer.  If they differ, the risc
+ * code (which controls the filling of the buffer) is (re-)generated.
  */
-static void buffer_release(struct videobuf_queue *q,
-			   struct videobuf_buffer *vb)
+static int tw68_buf_prepare(struct vb2_buffer *vb)
 {
+	struct vb2_queue *vq = vb->vb2_queue;
+	struct tw68_dev *dev = vb2_get_drv_priv(vq);
 	struct tw68_buf *buf = container_of(vb, struct tw68_buf, vb);
+	struct sg_table *dma = vb2_dma_sg_plane_desc(vb, 0);
+	unsigned size, bpl;
+	int rc;
 
-	tw68_dma_free(q, buf);
-}
-
-static struct videobuf_queue_ops video_qops = {
-	.buf_setup    = buffer_setup,
-	.buf_prepare  = buffer_prepare,
-	.buf_queue    = buffer_queue,
-	.buf_release  = buffer_release,
-};
-
-/* ------------------------------------------------------------------ */
+	size = (dev->width * dev->height * dev->fmt->depth) >> 3;
+	if (vb2_plane_size(vb, 0) < size)
+		return -EINVAL;
+	vb2_set_plane_payload(vb, 0, size);
 
-static int tw68_g_ctrl_internal(struct tw68_dev *dev, struct tw68_fh *fh,
-				struct v4l2_control *c)
-{
-	const struct v4l2_queryctrl *ctrl;
+	rc = dma_map_sg(&dev->pci->dev, dma->sgl, dma->nents, DMA_FROM_DEVICE);
+	if (!rc)
+		return -EIO;
 
-	dprintk(DBG_FLOW, "%s\n", __func__);
-	ctrl = ctrl_by_id(c->id);
-	if (NULL == ctrl)
-		return -EINVAL;
-	switch (c->id) {
-	case V4L2_CID_BRIGHTNESS:
-		c->value = (char)tw_readb(TW68_BRIGHT);
-		break;
-	case V4L2_CID_HUE:
-		c->value = (char)tw_readb(TW68_HUE);
-		break;
-	case V4L2_CID_CONTRAST:
-		c->value = tw_readb(TW68_CONTRAST);
-		break;
-	case V4L2_CID_SATURATION:
-		c->value = tw_readb(TW68_SAT_U);
-		break;
-	case V4L2_CID_COLOR_KILLER:
-		c->value = 0 != (tw_readb(TW68_MISC2) & 0xe0);
+	bpl = (dev->width * dev->fmt->depth) >> 3;
+	switch (dev->field) {
+	case V4L2_FIELD_TOP:
+		tw68_risc_buffer(dev->pci, buf, dma->sgl,
+				 0, UNSET, bpl, 0, dev->height);
 		break;
-	case V4L2_CID_CHROMA_AGC:
-		c->value = 0 != (tw_readb(TW68_LOOP) & 0x30);
+	case V4L2_FIELD_BOTTOM:
+		tw68_risc_buffer(dev->pci, buf, dma->sgl,
+				 UNSET, 0, bpl, 0, dev->height);
 		break;
-	case V4L2_CID_AUDIO_MUTE:
-		/*hack to suppresss tvtime complaint */
-		c->value = 0;
+	case V4L2_FIELD_SEQ_TB:
+		tw68_risc_buffer(dev->pci, buf, dma->sgl,
+				 0, bpl * (dev->height >> 1),
+				 bpl, 0, dev->height >> 1);
 		break;
-#if 0
-	case V4L2_CID_AUDIO_VOLUME:
-		c->value = dev->ctl_volume;
+	case V4L2_FIELD_SEQ_BT:
+		tw68_risc_buffer(dev->pci, buf, dma->sgl,
+				 bpl * (dev->height >> 1), 0,
+				 bpl, 0, dev->height >> 1);
 		break;
-#endif
+	case V4L2_FIELD_INTERLACED:
 	default:
-		return -EINVAL;
+		tw68_risc_buffer(dev->pci, buf, dma->sgl,
+				 0, bpl, bpl, bpl, dev->height >> 1);
+		break;
 	}
 	return 0;
 }
 
-static int tw68_g_ctrl(struct file *file, void *priv, struct v4l2_control *c)
+static void tw68_buf_finish(struct vb2_buffer *vb)
+{
+	struct vb2_queue *vq = vb->vb2_queue;
+	struct tw68_dev *dev = vb2_get_drv_priv(vq);
+	struct sg_table *dma = vb2_dma_sg_plane_desc(vb, 0);
+	struct tw68_buf *buf = container_of(vb, struct tw68_buf, vb);
+
+	dma_unmap_sg(&dev->pci->dev, dma->sgl, dma->nents, DMA_FROM_DEVICE);
+
+	pci_free_consistent(dev->pci, buf->size, buf->cpu, buf->dma);
+}
+
+static int tw68_start_streaming(struct vb2_queue *q, unsigned int count)
+{
+	struct tw68_dev *dev = vb2_get_drv_priv(q);
+	struct tw68_buf *buf =
+		container_of(dev->active.next, struct tw68_buf, list);
+
+	dev->seqnr = 0;
+	tw68_video_start_dma(dev, buf);
+	return 0;
+}
+
+static void tw68_stop_streaming(struct vb2_queue *q)
 {
-	struct tw68_fh *fh = priv;
+	struct tw68_dev *dev = vb2_get_drv_priv(q);
+
+	/* Stop risc & fifo */
+	tw_clearl(TW68_DMAC, TW68_DMAP_EN | TW68_FIFO_EN);
+	while (!list_empty(&dev->active)) {
+		struct tw68_buf *buf =
+			container_of(dev->active.next, struct tw68_buf, list);
 
-	return tw68_g_ctrl_internal(fh->dev, fh, c);
+		list_del(&buf->list);
+		vb2_buffer_done(&buf->vb, VB2_BUF_STATE_ERROR);
+	}
 }
 
-static int tw68_s_ctrl_value(struct tw68_dev *dev, __u32 id, int val)
+static struct vb2_ops tw68_video_qops = {
+	.queue_setup	= tw68_queue_setup,
+	.buf_queue	= tw68_buf_queue,
+	.buf_prepare	= tw68_buf_prepare,
+	.buf_finish	= tw68_buf_finish,
+	.start_streaming = tw68_start_streaming,
+	.stop_streaming = tw68_stop_streaming,
+	.wait_prepare	= vb2_ops_wait_prepare,
+	.wait_finish	= vb2_ops_wait_finish,
+};
+
+/* ------------------------------------------------------------------ */
+
+static int tw68_s_ctrl(struct v4l2_ctrl *ctrl)
 {
-	int err = 0;
+	struct tw68_dev *dev =
+		container_of(ctrl->handler, struct tw68_dev, hdl);
 
-	dprintk(DBG_FLOW, "%s\n", __func__);
-	switch (id) {
+	switch (ctrl->id) {
 	case V4L2_CID_BRIGHTNESS:
-		tw_writeb(TW68_BRIGHT, val);
+		tw_writeb(TW68_BRIGHT, ctrl->val);
 		break;
 	case V4L2_CID_HUE:
-		tw_writeb(TW68_HUE, val);
+		tw_writeb(TW68_HUE, ctrl->val);
 		break;
 	case V4L2_CID_CONTRAST:
-		tw_writeb(TW68_CONTRAST, val);
+		tw_writeb(TW68_CONTRAST, ctrl->val);
 		break;
 	case V4L2_CID_SATURATION:
-		tw_writeb(TW68_SAT_U, val);
-		tw_writeb(TW68_SAT_V, val);
+		tw_writeb(TW68_SAT_U, ctrl->val);
+		tw_writeb(TW68_SAT_V, ctrl->val);
 		break;
 	case V4L2_CID_COLOR_KILLER:
-		if (val)
+		if (ctrl->val)
 			tw_andorb(TW68_MISC2, 0xe0, 0xe0);
 		else
 			tw_andorb(TW68_MISC2, 0xe0, 0x00);
 		break;
 	case V4L2_CID_CHROMA_AGC:
-		if (val)
+		if (ctrl->val)
 			tw_andorb(TW68_LOOP, 0x30, 0x20);
 		else
 			tw_andorb(TW68_LOOP, 0x30, 0x00);
 		break;
-	case V4L2_CID_AUDIO_MUTE:
-		/* hack to suppress tvtime complaint */
-		break;
-#if 0
-	case V4L2_CID_AUDIO_VOLUME:
-		dev->ctl_volume = val;
-		tw68_tvaudio_setvolume(dev, dev->ctl_volume);
-		break;
-	case V4L2_CID_HFLIP:
-		dev->ctl_mirror = val;
-		break;
-	case V4L2_CID_PRIVATE_AUTOMUTE:
-	{
-		struct v4l2_priv_tun_config tda9887_cfg;
-
-		tda9887_cfg.tuner = TUNER_TDA9887;
-		tda9887_cfg.priv = &dev->tda9887_conf;
-
-		dev->ctl_automute = val;
-		if (dev->tda9887_conf) {
-			if (dev->ctl_automute)
-				dev->tda9887_conf |= TDA9887_AUTOMUTE;
-			else
-				dev->tda9887_conf &= ~TDA9887_AUTOMUTE;
-
-			tw_call_all(dev, tuner, s_config, &tda9887_cfg);
-		}
-		break;
-	}
-#endif
-	default:
-		err = -EINVAL;
 	}
-	return err;
+	return 0;
 }
 
-static int tw68_s_ctrl_internal(struct tw68_dev *dev,  struct tw68_fh *fh,
-			 struct v4l2_control *c)
-{
-	const struct v4l2_queryctrl *ctrl;
-	int err;
-
-	dprintk(DBG_FLOW, "%s\n", __func__);
-	if (fh) {
-#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,34)
-		err = v4l2_prio_check(&dev->prio, &fh->prio);
-#else
-		err = v4l2_prio_check(&dev->prio, fh->prio);
-#endif
-		if (0 != err)
-			return err;
-	}
+/* ------------------------------------------------------------------ */
 
-	mutex_lock(&dev->lock);
+/*
+ * Note that this routine returns what is stored in the fh structure, and
+ * does not interrogate any of the device registers.
+ */
+static int tw68_g_fmt_vid_cap(struct file *file, void *priv,
+				struct v4l2_format *f)
+{
+	struct tw68_dev *dev = video_drvdata(file);
 
-	ctrl = ctrl_by_id(c->id);
-	if (NULL == ctrl) {
-		err = -EINVAL;
-		goto error;
-	}
-
-	dprintk(DBG_BUFF, "%s: name=%s val=%d\n", __func__,
-		ctrl->name, c->value);
-	switch (ctrl->type) {
-	case V4L2_CTRL_TYPE_BOOLEAN:
-	case V4L2_CTRL_TYPE_MENU:
-	case V4L2_CTRL_TYPE_INTEGER:
-		if (c->value < ctrl->minimum)
-			c->value = ctrl->minimum;
-		if (c->value > ctrl->maximum)
-			c->value = ctrl->maximum;
-		break;
-	default:
-		/* nothing */;
-	};
-	err = tw68_s_ctrl_value(dev, c->id, c->value);
-
-error:
-	mutex_unlock(&dev->lock);
-	return err;
-}
-
-static int tw68_s_ctrl(struct file *file, void *f, struct v4l2_control *c)
-{
-	struct tw68_fh *fh = f;
-
-	return tw68_s_ctrl_internal(fh->dev, fh, c);
-}
-
-/* ------------------------------------------------------------------ */
-
-/*
- * Returns a pointer to the currently used queue (e.g. video, vbi, etc.)
- */
-static struct videobuf_queue *tw68_queue(struct tw68_fh *fh)
-{
-	struct videobuf_queue *q = NULL;
-
-	switch (fh->type) {
-	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
-		q = &fh->cap;
-		break;
-	case V4L2_BUF_TYPE_VBI_CAPTURE:
-		q = &fh->vbi;
-		break;
-	default:
-		BUG();
-	}
-	return q;
-}
-
-static int tw68_resource(struct tw68_fh *fh)
-{
-	if (fh->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)
-		return RESOURCE_VIDEO;
-
-	if (fh->type == V4L2_BUF_TYPE_VBI_CAPTURE)
-		return RESOURCE_VBI;
-
-	BUG();
-	return 0;
-}
-
-static int video_open(struct file *file)
-{
-	int minor = video_devdata(file)->minor;
-	struct tw68_dev *dev;
-	struct tw68_fh *fh;
-	enum v4l2_buf_type type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-	int radio = 0;
-
-	mutex_lock(&tw68_devlist_lock);
-	list_for_each_entry(dev, &tw68_devlist, devlist) {
-		if (dev->video_dev && (dev->video_dev->minor == minor))
-			goto found;
-		if (dev->radio_dev && (dev->radio_dev->minor == minor)) {
-			radio = 1;
-			goto found;
-		}
-		if (dev->vbi_dev && (dev->vbi_dev->minor == minor)) {
-			type = V4L2_BUF_TYPE_VBI_CAPTURE;
-			goto found;
-		}
-	}
-	mutex_unlock(&tw68_devlist_lock);
-	return -ENODEV;
-
-found:
-	mutex_unlock(&tw68_devlist_lock);
-
-	dprintk(DBG_FLOW, "%s: minor=%d radio=%d type=%s\n", __func__, minor,
-		radio, v4l2_type_names[type]);
-
-	/* allocate + initialize per filehandle data */
-	fh = kzalloc(sizeof(*fh), GFP_KERNEL);
-	if (NULL == fh)
-		return -ENOMEM;
-
-	file->private_data = fh;
-	fh->dev      = dev;
-	fh->radio    = radio;
-	fh->type     = type;
-	fh->fmt      = format_by_fourcc(V4L2_PIX_FMT_BGR24);
-	fh->width    = 720;
-	fh->height   = 576;
-	v4l2_prio_open(&dev->prio, &fh->prio);
-
-	videobuf_queue_sg_init(&fh->cap, &video_qops,
-			    &dev->pci->dev, &dev->slock,
-			    V4L2_BUF_TYPE_VIDEO_CAPTURE,
-			    V4L2_FIELD_INTERLACED,
-			    sizeof(struct tw68_buf),
-#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,37)
-			    fh
-#else
-			    fh, &dev->lock
-#endif
-             );
-	videobuf_queue_sg_init(&fh->vbi, &tw68_vbi_qops,
-			    &dev->pci->dev, &dev->slock,
-			    V4L2_BUF_TYPE_VBI_CAPTURE,
-			    V4L2_FIELD_SEQ_TB,
-			    sizeof(struct tw68_buf),
-#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,37)
-			    fh
-#else
-			    fh, &dev->lock
-#endif
-             );
-	if (fh->radio) {
-		/* switch to radio mode */
-		tw68_tvaudio_setinput(dev, &card(dev).radio);
-		tw_call_all(dev, tuner, s_radio);
-	} else {
-		/* switch to video/vbi mode */
-		tw68_tvaudio_setinput(dev, dev->input);
-	}
-	return 0;
-}
-
-static ssize_t
-video_read(struct file *file, char __user *data, size_t count, loff_t *ppos)
-{
-	struct tw68_fh *fh = file->private_data;
-
-	switch (fh->type) {
-	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
-		if (res_locked(fh->dev, RESOURCE_VIDEO))
-			return -EBUSY;
-		return videobuf_read_one(tw68_queue(fh),
-					 data, count, ppos,
-					 file->f_flags & O_NONBLOCK);
-	case V4L2_BUF_TYPE_VBI_CAPTURE:
-		if (!res_get(fh, RESOURCE_VBI))
-			return -EBUSY;
-		return videobuf_read_stream(tw68_queue(fh),
-					    data, count, ppos, 1,
-					    file->f_flags & O_NONBLOCK);
-		break;
-	default:
-		BUG();
-		return 0;
-	}
-}
-
-static unsigned int
-video_poll(struct file *file, struct poll_table_struct *wait)
-{
-	struct tw68_fh *fh = file->private_data;
-	struct videobuf_buffer *buf = NULL;
-
-	if (V4L2_BUF_TYPE_VBI_CAPTURE == fh->type)
-		return videobuf_poll_stream(file, &fh->vbi, wait);
-
-	if (res_check(fh, RESOURCE_VIDEO)) {
-		if (!list_empty(&fh->cap.stream))
-			buf = list_entry(fh->cap.stream.next,
-				struct videobuf_buffer, stream);
-	} else {
-		mutex_lock(&fh->cap.vb_lock);
-		if (UNSET == fh->cap.read_off) {
-			/* need to capture a new frame */
-			if (res_locked(fh->dev, RESOURCE_VIDEO))
-				goto err;
-			if (0 != fh->cap.ops->buf_prepare(&fh->cap,
-					fh->cap.read_buf, fh->cap.field))
-				goto err;
-			fh->cap.ops->buf_queue(&fh->cap, fh->cap.read_buf);
-			fh->cap.read_off = 0;
-		}
-		mutex_unlock(&fh->cap.vb_lock);
-		buf = fh->cap.read_buf;
-	}
-
-	if (!buf)
-		return POLLERR;
-
-	poll_wait(file, &buf->done, wait);
-	if (buf->state == VIDEOBUF_DONE ||
-	    buf->state == VIDEOBUF_ERROR)
-		return POLLIN | POLLRDNORM;
-	return 0;
-
-err:
-	mutex_unlock(&fh->cap.vb_lock);
-	return POLLERR;
-}
-
-static int video_release(struct file *file)
-{
-	struct tw68_fh  *fh  = file->private_data;
-	struct tw68_dev *dev = fh->dev;
-
-	/* stop video capture */
-	if (res_check(fh, RESOURCE_VIDEO)) {
-		videobuf_streamoff(&fh->cap);
-		res_free(fh , RESOURCE_VIDEO);
-	}
-	if (fh->cap.read_buf) {
-		buffer_release(&fh->cap, fh->cap.read_buf);
-		kfree(fh->cap.read_buf);
-	}
-
-	/* stop vbi capture */
-	if (res_check(fh, RESOURCE_VBI)) {
-		videobuf_stop(&fh->vbi);
-		res_free(fh, RESOURCE_VBI);
-	}
-
-#if 0
-	tw_call_all(dev, core, s_standby, 0);
-#endif
-
-	/* free stuff */
-	videobuf_mmap_free(&fh->cap);
-	videobuf_mmap_free(&fh->vbi);
-
-#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,34)
-	v4l2_prio_close(&dev->prio, &fh->prio);
-#else
-	v4l2_prio_close(&dev->prio, fh->prio);
-#endif
-	file->private_data = NULL;
-	kfree(fh);
-	return 0;
-}
-
-static int video_mmap(struct file *file, struct vm_area_struct * vma)
-{
-	struct tw68_fh *fh = file->private_data;
-
-	return videobuf_mmap_mapper(tw68_queue(fh), vma);
-}
-
-/* ------------------------------------------------------------------ */
-
-#if 0
-static int tw68_try_get_set_fmt_vbi_cap(struct file *file, void *priv,
-						struct v4l2_format *f)
-{
-	struct tw68_fh *fh = priv;
-	struct tw68_dev *dev = fh->dev;
-	struct tw68_tvnorm *norm = dev->tvnorm;
-
-	f->fmt.vbi.sampling_rate = 6750000 * 4;
-	f->fmt.vbi.samples_per_line = 2048 /* VBI_LINE_LENGTH */;
-	f->fmt.vbi.sample_format = V4L2_PIX_FMT_GREY;
-	f->fmt.vbi.offset = 64 * 4;
-	f->fmt.vbi.start[0] = norm->vbi_v_start_0;
-	f->fmt.vbi.count[0] = norm->vbi_v_stop_0 - norm->vbi_v_start_0 + 1;
-	f->fmt.vbi.start[1] = norm->vbi_v_start_1;
-	f->fmt.vbi.count[1] = f->fmt.vbi.count[0];
-	f->fmt.vbi.flags = 0; /* VBI_UNSYNC VBI_INTERLACED */
-
-#if 0
-	if (V4L2_STD_PAL == norm->id) {
-		/* FIXME */
-		f->fmt.vbi.start[0] += 3;
-		f->fmt.vbi.start[1] += 3*2;
-	}
-#endif
-	return 0;
-}
-#endif
-
-/*
- * Note that this routine returns what is stored in the fh structure, and
- * does not interrogate any of the device registers.
- */
-static int tw68_g_fmt_vid_cap(struct file *file, void *priv,
-				struct v4l2_format *f)
-{
-	struct tw68_fh *fh = priv;
-	struct tw68_dev *dev = fh->dev;
-
-	dprintk(DBG_FLOW, "%s\n", __func__);
-	f->fmt.pix.width        = fh->width;
-	f->fmt.pix.height       = fh->height;
-	f->fmt.pix.field        = fh->cap.field;
-	f->fmt.pix.pixelformat  = fh->fmt->fourcc;
+	f->fmt.pix.width        = dev->width;
+	f->fmt.pix.height       = dev->height;
+	f->fmt.pix.field        = dev->field;
+	f->fmt.pix.pixelformat  = dev->fmt->fourcc;
 	f->fmt.pix.bytesperline =
-		(f->fmt.pix.width * (fh->fmt->depth)) >> 3;
+		(f->fmt.pix.width * (dev->fmt->depth)) >> 3;
 	f->fmt.pix.sizeimage =
 		f->fmt.pix.height * f->fmt.pix.bytesperline;
 	f->fmt.pix.colorspace	= V4L2_COLORSPACE_SMPTE170M;
+	f->fmt.pix.priv = 0;
 	return 0;
 }
 
 static int tw68_try_fmt_vid_cap(struct file *file, void *priv,
 						struct v4l2_format *f)
 {
-	struct tw68_fh *fh = priv;
-	struct tw68_dev *dev = fh->dev;
-	struct tw68_format *fmt;
+	struct tw68_dev *dev = video_drvdata(file);
+	const struct tw68_format *fmt;
 	enum v4l2_field field;
-	unsigned int maxw, maxh;
+	unsigned int maxh;
 
-	dprintk(DBG_FLOW, "%s\n", __func__);
 	fmt = format_by_fourcc(f->fmt.pix.pixelformat);
 	if (NULL == fmt)
 		return -EINVAL;
 
 	field = f->fmt.pix.field;
-	maxw  = min(dev->crop_current.width*4,  dev->crop_bounds.width);
-	maxh  = min(dev->crop_current.height*4, dev->crop_bounds.height);
+	maxh  = (dev->tvnorm->id & V4L2_STD_525_60) ? 480 : 576;
 
-	if (V4L2_FIELD_ANY == field) {
-		field = (f->fmt.pix.height > maxh/2)
-			? V4L2_FIELD_INTERLACED
-			: V4L2_FIELD_BOTTOM;
-	}
 	switch (field) {
 	case V4L2_FIELD_TOP:
 	case V4L2_FIELD_BOTTOM:
 		break;
 	case V4L2_FIELD_INTERLACED:
+	case V4L2_FIELD_SEQ_BT:
+	case V4L2_FIELD_SEQ_TB:
 		maxh = maxh * 2;
 		break;
 	default:
-		return -EINVAL;
+		field = (f->fmt.pix.height > maxh / 2)
+			? V4L2_FIELD_INTERLACED
+			: V4L2_FIELD_BOTTOM;
+		break;
 	}
 
 	f->fmt.pix.field = field;
@@ -1359,8 +656,8 @@ static int tw68_try_fmt_vid_cap(struct file *file, void *priv,
 		f->fmt.pix.width  = 48;
 	if (f->fmt.pix.height < 32)
 		f->fmt.pix.height = 32;
-	if (f->fmt.pix.width > maxw)
-		f->fmt.pix.width = maxw;
+	if (f->fmt.pix.width > 720)
+		f->fmt.pix.width = 720;
 	if (f->fmt.pix.height > maxh)
 		f->fmt.pix.height = maxh;
 	f->fmt.pix.width &= ~0x03;
@@ -1368,7 +665,7 @@ static int tw68_try_fmt_vid_cap(struct file *file, void *priv,
 		(f->fmt.pix.width * (fmt->depth)) >> 3;
 	f->fmt.pix.sizeimage =
 		f->fmt.pix.height * f->fmt.pix.bytesperline;
-
+	f->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;
 	return 0;
 }
 
@@ -1381,76 +678,35 @@ static int tw68_try_fmt_vid_cap(struct file *file, void *priv,
 static int tw68_s_fmt_vid_cap(struct file *file, void *priv,
 					struct v4l2_format *f)
 {
-	struct tw68_fh *fh = priv;
-	struct tw68_dev *dev = fh->dev;
+	struct tw68_dev *dev = video_drvdata(file);
 	int err;
 
-	dprintk(DBG_FLOW, "%s\n", __func__);
 	err = tw68_try_fmt_vid_cap(file, priv, f);
 	if (0 != err)
 		return err;
 
-	fh->fmt       = format_by_fourcc(f->fmt.pix.pixelformat);
-	fh->width     = f->fmt.pix.width;
-	fh->height    = f->fmt.pix.height;
-	fh->cap.field = f->fmt.pix.field;
-	/*
-	 * The following lines are to make v4l2-test program happy.
-	 * The docs should be checked to assure they make sense.
-	 */
-	f->fmt.pix.colorspace	= V4L2_COLORSPACE_SMPTE170M;
-	f->fmt.pix.priv = 0;
-	return 0;
-}
-
-static int tw68_queryctrl(struct file *file, void *priv,
-			  struct v4l2_queryctrl *c)
-{
-	const struct v4l2_queryctrl *ctrl;
-	struct tw68_fh *fh = priv;
-	struct tw68_dev *dev = fh->dev;
-
-	dprintk(DBG_FLOW, "%s\n", __func__);
-	if ((c->id <  V4L2_CID_BASE || c->id >= V4L2_CID_LASTP1)
-#if 0
-	     && (c->id <  V4L2_CID_PRIVATE_BASE ||
-	     c->id >= V4L2_CID_PRIVATE_LASTP1)
-#endif
-	)
-		return -EINVAL;
-	ctrl = ctrl_by_id(c->id);
-	if (NULL == ctrl)
-		return -EINVAL;
-	*c = *ctrl;
+	dev->fmt = format_by_fourcc(f->fmt.pix.pixelformat);
+	dev->width = f->fmt.pix.width;
+	dev->height = f->fmt.pix.height;
+	dev->field = f->fmt.pix.field;
 	return 0;
 }
 
 static int tw68_enum_input(struct file *file, void *priv,
 					struct v4l2_input *i)
 {
-	struct tw68_fh *fh = priv;
-	struct tw68_dev *dev = fh->dev;
+	struct tw68_dev *dev = video_drvdata(file);
 	unsigned int n;
 
 	n = i->index;
-	dprintk(DBG_FLOW, "%s: index is %d\n", __func__, n);
-	if (n >= TW68_INPUT_MAX) {
-		dprintk(DBG_FLOW, "%s: INPUT_MAX reached\n", __func__);
+	if (n >= TW68_INPUT_MAX)
 		return -EINVAL;
-	}
-	if (NULL == card_in(dev, n).name) {
-		dprintk(DBG_FLOW, "%s: End of list\n", __func__);
-		return -EINVAL;
-	}
-	memset(i, 0, sizeof(*i));
 	i->index = n;
-	i->type  = V4L2_INPUT_TYPE_CAMERA;
-	strcpy(i->name, card_in(dev, n).name);
-	if (card_in(dev, n).tv)
-		i->type = V4L2_INPUT_TYPE_TUNER;
-	i->audioset = 1;
+	i->type = V4L2_INPUT_TYPE_CAMERA;
+	snprintf(i->name, sizeof(i->name), "Composite %d", n);
+
 	/* If the query is for the current input, get live data */
-	if (n == dev->hw_input->vmux) {
+	if (n == dev->input) {
 		int v1 = tw_readb(TW68_STATUS1);
 		int v2 = tw_readb(TW68_MVSN);
 
@@ -1465,305 +721,86 @@ static int tw68_enum_input(struct file *file, void *priv,
 		if (0 != (v2 & (1 << 2)))
 			i->status |= V4L2_IN_ST_MACROVISION;
 	}
-	i->std = TW68_NORMS;
+	i->std = video_devdata(file)->tvnorms;
 	return 0;
 }
 
 static int tw68_g_input(struct file *file, void *priv, unsigned int *i)
 {
-	struct tw68_fh *fh = priv;
-	struct tw68_dev *dev = fh->dev;
+	struct tw68_dev *dev = video_drvdata(file);
 
-	dprintk(DBG_FLOW, "%s\n", __func__);
-	*i = dev->input->vmux;
+	*i = dev->input;
 	return 0;
 }
 
 static int tw68_s_input(struct file *file, void *priv, unsigned int i)
 {
-	struct tw68_fh *fh = priv;
-	struct tw68_dev *dev = fh->dev;
-	int err;
+	struct tw68_dev *dev = video_drvdata(file);
 
-	dprintk(DBG_FLOW, "%s\n", __func__);
-#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,34)
-		err = v4l2_prio_check(&dev->prio, &fh->prio);
-#else
-		err = v4l2_prio_check(&dev->prio, fh->prio);
-#endif
-		if (0 != err)
-	if (0 != err)
-		return err;
-
-	if (i < 0  ||  i >= TW68_INPUT_MAX)
-		return -EINVAL;
-	if (NULL == card_in(dev, i).name)
+	if (i >= TW68_INPUT_MAX)
 		return -EINVAL;
-	mutex_lock(&dev->lock);
-	video_mux(dev, i);
-	mutex_unlock(&dev->lock);
+	dev->input = i;
+	tw_andorb(TW68_INFORM, 0x03 << 2, dev->input << 2);
 	return 0;
 }
 
 static int tw68_querycap(struct file *file, void  *priv,
 					struct v4l2_capability *cap)
 {
-	struct tw68_fh *fh = priv;
-	struct tw68_dev *dev = fh->dev;
+	struct tw68_dev *dev = video_drvdata(file);
 
-	unsigned int tuner_type = dev->tuner_type;
-
-	dprintk(DBG_FLOW, "%s\n", __func__);
 	strcpy(cap->driver, "tw68");
-	strlcpy(cap->card, tw68_boards[dev->board].name,
+	strlcpy(cap->card, "Techwell Capture Card",
 		sizeof(cap->card));
 	sprintf(cap->bus_info, "PCI:%s", pci_name(dev->pci));
-	cap->version = TW68_VERSION_CODE;
-	cap->capabilities =
+	cap->device_caps =
 		V4L2_CAP_VIDEO_CAPTURE |
-		V4L2_CAP_VBI_CAPTURE |
 		V4L2_CAP_READWRITE |
-		V4L2_CAP_STREAMING |
-		V4L2_CAP_TUNER;
+		V4L2_CAP_STREAMING;
 
-	if ((tuner_type == TUNER_ABSENT) || (tuner_type == UNSET))
-		cap->capabilities &= ~V4L2_CAP_TUNER;
+	cap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;
 	return 0;
 }
 
-static int tw68_s_std_internal(struct tw68_dev *dev, struct tw68_fh *fh,
-			v4l2_std_id *id)
+static int tw68_s_std(struct file *file, void *priv, v4l2_std_id id)
 {
-/*	unsigned long flags; */
+	struct tw68_dev *dev = video_drvdata(file);
 	unsigned int i;
-	v4l2_std_id fixup;
-	int err;
 
-	dprintk(DBG_FLOW, "%s\n", __func__);
-	if (fh) {
-#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,34)
-		err = v4l2_prio_check(&dev->prio, &fh->prio);
-#else
-		err = v4l2_prio_check(&dev->prio, fh->prio);
-#endif
-		if (0 != err)
-		if (0 != err)
-			return err;
-	}
+	if (vb2_is_busy(&dev->vidq))
+		return -EBUSY;
 
 	/* Look for match on complete norm id (may have mult bits) */
 	for (i = 0; i < TVNORMS; i++) {
-		if (*id == tvnorms[i].id)
+		if (id == tvnorms[i].id)
 			break;
 	}
 
 	/* If no exact match, look for norm which contains this one */
-	if (i == TVNORMS)
-		for (i = 0; i < TVNORMS; i++) {
-			if (*id & tvnorms[i].id)
+	if (i == TVNORMS) {
+		for (i = 0; i < TVNORMS; i++)
+			if (id & tvnorms[i].id)
 				break;
-		}
+	}
 	/* If still not matched, give up */
 	if (i == TVNORMS)
 		return -EINVAL;
 
-	/* TODO - verify this additional work with SECAM applies to TW */
-	if ((*id & V4L2_STD_SECAM) && (secam[0] != '-')) {
-		if (secam[0] == 'L' || secam[0] == 'l') {
-			if (secam[1] == 'C' || secam[1] == 'c')
-				fixup = V4L2_STD_SECAM_LC;
-			else
-				fixup = V4L2_STD_SECAM_L;
-		} else {
-			if (secam[0] == 'D' || secam[0] == 'd')
-				fixup = V4L2_STD_SECAM_DK;
-			else
-				fixup = V4L2_STD_SECAM;
-		}
-		for (i = 0; i < TVNORMS; i++)
-			if (fixup == tvnorms[i].id)
-				break;
-	}
-
-	*id = tvnorms[i].id;
-	mutex_lock(&dev->lock);
 	set_tvnorm(dev, &tvnorms[i]);	/* do the actual setting */
-	tw68_tvaudio_do_scan(dev);
-	mutex_unlock(&dev->lock);
 	return 0;
 }
 
-static int tw68_s_std(struct file *file, void *priv, v4l2_std_id *id)
-{
-	struct tw68_fh *fh = priv;
-	struct tw68_dev *dev = fh->dev;
-
-	dprintk(DBG_FLOW, "%s\n", __func__);
-	return tw68_s_std_internal(fh->dev, fh, id);
-}
-
 static int tw68_g_std(struct file *file, void *priv, v4l2_std_id *id)
 {
-	struct tw68_fh *fh = priv;
-	struct tw68_dev *dev = fh->dev;
+	struct tw68_dev *dev = video_drvdata(file);
 
-	dprintk(DBG_FLOW, "%s\n", __func__);
 	*id = dev->tvnorm->id;
 	return 0;
 }
 
-static int tw68_g_tuner(struct file *file, void *priv,
-					struct v4l2_tuner *t)
-{
-	struct tw68_fh *fh = priv;
-	struct tw68_dev *dev = fh->dev;
-	int n;
-
-	if (unlikely(UNSET == dev->tuner_type))
-		return -EINVAL;
-	if (0 != t->index)
-		return -EINVAL;
-	memset(t, 0, sizeof(*t));
-	for (n = 0; n < TW68_INPUT_MAX; n++)
-		if (card_in(dev, n).tv)
-			break;
-	if (n == TW68_INPUT_MAX)
-		return -EINVAL;
-#if 0
-	if (NULL != card_in(dev, n).name) {
-		strcpy(t->name, "Television");
-		t->type = V4L2_TUNER_ANALOG_TV;
-		t->capability = V4L2_TUNER_CAP_NORM |
-			V4L2_TUNER_CAP_STEREO |
-			V4L2_TUNER_CAP_LANG1 |
-			V4L2_TUNER_CAP_LANG2;
-		t->rangehigh = 0xffffffffUL;
-		t->rxsubchans = tw68_tvaudio_getstereo(dev);
-		t->audmode = tw68_tvaudio_rx2mode(t->rxsubchans);
-	}
-	if (0 != (saa_readb(TW68_STATUS_VIDEO1) & 0x03))
-		t->signal = 0xffff;
-#endif
-	return 0;
-}
-
-static int tw68_s_tuner(struct file *file, void *priv,
-					struct v4l2_tuner *t)
-{
-	struct tw68_fh *fh = priv;
-	struct tw68_dev *dev = fh->dev;
-	int err;
-#if 0
-	int rx, mode
-#endif
-
-#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,34)
-		err = v4l2_prio_check(&dev->prio, &fh->prio);
-#else
-		err = v4l2_prio_check(&dev->prio, fh->prio);
-#endif
-		if (0 != err)
-	if (0 != err)
-		return err;
-
-#if 0
-	mode = dev->thread.mode;
-	if (UNSET == mode) {
-		rx   = tw68_tvaudio_getstereo(dev);
-		mode = tw68_tvaudio_rx2mode(t->rxsubchans);
-	}
-	if (mode != t->audmode)
-		dev->thread.mode = t->audmode;
-#endif
-	return 0;
-}
-
-static int tw68_g_frequency(struct file *file, void *priv,
-					struct v4l2_frequency *f)
-{
-	struct tw68_fh *fh = priv;
-	struct tw68_dev *dev = fh->dev;
-
-	if (unlikely(dev->tuner_type))
-		return -EINVAL;
-	f->type = fh->radio ? V4L2_TUNER_RADIO : V4L2_TUNER_ANALOG_TV;
-/*	f->frequency = dev->ctl_freq; */
-
-	return 0;
-}
-
-static int tw68_s_frequency(struct file *file, void *priv,
-					struct v4l2_frequency *f)
-{
-	struct tw68_fh *fh = priv;
-	struct tw68_dev *dev = fh->dev;
-	int err;
-
-	if (unlikely(UNSET == dev->tuner_type))
-		return -EINVAL;
-#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,34)
-		err = v4l2_prio_check(&dev->prio, &fh->prio);
-#else
-		err = v4l2_prio_check(&dev->prio, fh->prio);
-#endif
-		if (0 != err)
-	if (0 != err)
-		return err;
-
-	if (0 != f->tuner)
-		return -EINVAL;
-	if (0 == fh->radio && V4L2_TUNER_ANALOG_TV != f->type)
-		return -EINVAL;
-	if (1 == fh->radio && V4L2_TUNER_RADIO != f->type)
-		return -EINVAL;
-	mutex_lock(&dev->lock);
-/*	dev->ctl_freq = f->frequency; */
-
-	tw_call_all(dev, tuner, s_frequency, f);
-
-	tw68_tvaudio_do_scan(dev);
-	mutex_unlock(&dev->lock);
-	return 0;
-}
-
-static int tw68_g_audio(struct file *file, void *priv, struct v4l2_audio *a)
-{
-	strcpy(a->name, "audio");
-	return 0;
-}
-
-static int tw68_s_audio(struct file *file, void *priv, struct v4l2_audio *a)
-{
-	return 0;
-}
-
-static int tw68_g_priority(struct file *file, void *f, enum v4l2_priority *p)
-{
-	struct tw68_fh *fh = f;
-	struct tw68_dev *dev = fh->dev;
-
-	dprintk(DBG_FLOW, "%s\n", __func__);
-	*p = v4l2_prio_max(&dev->prio);
-	return 0;
-}
-
-static int tw68_s_priority(struct file *file, void *f,
-					enum v4l2_priority prio)
-{
-	struct tw68_fh *fh = f;
-	struct tw68_dev *dev = fh->dev;
-
-	dprintk(DBG_FLOW, "%s\n", __func__);
-	return v4l2_prio_change(&dev->prio, &fh->prio, prio);
-}
-
 static int tw68_enum_fmt_vid_cap(struct file *file, void  *priv,
 					struct v4l2_fmtdesc *f)
 {
-	struct tw68_fh *fh = priv;
-	struct tw68_dev *dev = fh->dev;
-
-	dprintk(DBG_FLOW, "%s\n", __func__);
 	if (f->index >= FORMATS)
 		return -EINVAL;
 
@@ -1775,149 +812,6 @@ static int tw68_enum_fmt_vid_cap(struct file *file, void  *priv,
 	return 0;
 }
 
-static int tw68_cropcap(struct file *file, void *priv,
-					struct v4l2_cropcap *cap)
-{
-	struct tw68_fh *fh = priv;
-	struct tw68_dev *dev = fh->dev;
-
-	dprintk(DBG_FLOW, "%s\n", __func__);
-	if (cap->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
-		return -EINVAL;
-	cap->bounds  = dev->crop_bounds;
-	cap->defrect = dev->crop_defrect;
-	cap->pixelaspect.numerator   = 1;
-	cap->pixelaspect.denominator = 1;
-	if (dev->tvnorm->id & V4L2_STD_525_60) {
-		cap->pixelaspect.numerator   = 11;
-		cap->pixelaspect.denominator = 10;
-	}
-	if (dev->tvnorm->id & V4L2_STD_625_50) {
-		cap->pixelaspect.numerator   = 54;
-		cap->pixelaspect.denominator = 59;
-	}
-	return 0;
-}
-
-static int tw68_g_crop(struct file *file, void *f, struct v4l2_crop *crop)
-{
-	struct tw68_fh *fh = f;
-	struct tw68_dev *dev = fh->dev;
-
-	dprintk(DBG_FLOW, "%s\n", __func__);
-	if (crop->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
-		return -EINVAL;
-	crop->c = dev->crop_current;
-	return 0;
-}
-
-static int tw68_s_crop(struct file *file, void *f, struct v4l2_crop *crop)
-{
-	struct tw68_fh *fh = f;
-	struct tw68_dev *dev = fh->dev;
-	struct v4l2_rect *b = &dev->crop_bounds;
-
-	dprintk(DBG_FLOW, "%s\n", __func__);
-	if (res_locked(fh->dev, RESOURCE_VIDEO))
-		return -EBUSY;
-
-	if ((crop->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) ||
-	    (crop->c.height < 0) || (crop->c.width < 0)) {
-		dprintk(DBG_UNEXPECTED, "%s: invalid request\n", __func__);
-		return -EINVAL;
-	}
-
-	if (crop->c.top < b->top)
-		crop->c.top = b->top;
-	if (crop->c.top > b->top + b->height)
-		crop->c.top = b->top + b->height;
-	if (crop->c.height > b->top - crop->c.top + b->height)
-		crop->c.height = b->top - crop->c.top + b->height;
-
-	if (crop->c.left < b->left)
-		crop->c.left = b->left;
-	if (crop->c.left > b->left + b->width)
-		crop->c.left = b->left + b->width;
-	if (crop->c.width > b->left - crop->c.left + b->width)
-		crop->c.width = b->left - crop->c.left + b->width;
-
-	dprintk(DBG_FLOW, "%s: setting cropping rectangle: top=%d, left=%d, "
-		    "width=%d, height=%d\n", __func__, crop->c.top,
-		    crop->c.left, crop->c.width, crop->c.height);
-	dev->crop_current = crop->c;
-	return 0;
-}
-
-/*
- * Wrappers for the v4l2_ioctl_ops functions
- */
-#ifdef CONFIG_VIDEO_V4L1_COMPAT
-static int vidiocgmbuf(struct file *file, void *priv, struct video_mbuf *mbuf)
-{
-	struct tw68_fh *fh = file->private_data;
-	return videobuf_cgmbuf(tw68_queue(fh), mbuf, 8);
-}
-#endif
-
-static int tw68_reqbufs(struct file *file, void *priv,
-					struct v4l2_requestbuffers *p)
-{
-	struct tw68_fh *fh = priv;
-	return videobuf_reqbufs(tw68_queue(fh), p);
-}
-
-static int tw68_querybuf(struct file *file, void *priv,
-					struct v4l2_buffer *b)
-{
-	struct tw68_fh *fh = priv;
-	return videobuf_querybuf(tw68_queue(fh), b);
-}
-
-static int tw68_qbuf(struct file *file, void *priv, struct v4l2_buffer *b)
-{
-	struct tw68_fh *fh = priv;
-	return videobuf_qbuf(tw68_queue(fh), b);
-}
-
-static int tw68_dqbuf(struct file *file, void *priv, struct v4l2_buffer *b)
-{
-	struct tw68_fh *fh = priv;
-	return videobuf_dqbuf(tw68_queue(fh), b,
-				file->f_flags & O_NONBLOCK);
-}
-
-static int tw68_streamon(struct file *file, void *priv,
-					enum v4l2_buf_type type)
-{
-	struct tw68_fh *fh = priv;
-	struct tw68_dev *dev = fh->dev;
-	int res = tw68_resource(fh);
-
-	dprintk(DBG_FLOW, "%s\n", __func__);
-	if (!res_get(fh, res))
-		return -EBUSY;
-
-	tw68_buffer_requeue(dev, &dev->video_q);
-	return videobuf_streamon(tw68_queue(fh));
-}
-
-static int tw68_streamoff(struct file *file, void *priv,
-					enum v4l2_buf_type type)
-{
-	int err;
-	struct tw68_fh *fh = priv;
-	struct tw68_dev *dev = fh->dev;
-	int res = tw68_resource(fh);
-
-	dprintk(DBG_FLOW, "%s\n", __func__);
-	err = videobuf_streamoff(tw68_queue(fh));
-	if (err < 0)
-		return err;
-	res_free(fh, res);
-	return 0;
-}
-
-#ifdef CONFIG_VIDEO_ADV_DEBUG
 /*
  * Used strictly for internal development and debugging, this routine
  * prints out the current register contents for the tw68xx device.
@@ -1928,7 +822,7 @@ static void tw68_dump_regs(struct tw68_dev *dev)
 	int i, j, k;
 	unsigned char *cptr;
 
-	printk(KERN_DEBUG "Full dump of TW68 registers:\n");
+	pr_info("Full dump of TW68 registers:\n");
 	/* First we do the PCI regs, 8 4-byte regs per line */
 	for (i = 0; i < 0x100; i += 32) {
 		cptr = line;
@@ -1941,7 +835,7 @@ static void tw68_dump_regs(struct tw68_dev *dev)
 			cptr += sprintf(cptr, "%08x ", tw_readl(j));
 		*cptr++ = '\n';
 		*cptr = 0;
-		printk(KERN_DEBUG "%s", line);
+		pr_info("%s", line);
 	}
 	/* Next the control regs, which are single-byte, address mod 4 */
 	while (i < 0x400) {
@@ -1958,29 +852,24 @@ static void tw68_dump_regs(struct tw68_dev *dev)
 		}
 		*cptr++ = '\n';
 		*cptr = 0;
-		printk(KERN_DEBUG "%s", line);
+		pr_info("%s", line);
 	}
 }
 
 static int vidioc_log_status(struct file *file, void *priv)
 {
-	struct tw68_fh *fh = priv;
-	struct tw68_dev *dev = fh->dev;
+	struct tw68_dev *dev = video_drvdata(file);
 
 	tw68_dump_regs(dev);
-	return 0;
+	return v4l2_ctrl_log_status(file, priv);
 }
 
+#ifdef CONFIG_VIDEO_ADV_DEBUG
 static int vidioc_g_register(struct file *file, void *priv,
 			      struct v4l2_dbg_register *reg)
 {
-	struct tw68_fh *fh = priv;
-	struct tw68_dev *dev = fh->dev;	/* needed for tw_readb */
+	struct tw68_dev *dev = video_drvdata(file);
 
-	dprintk(DBG_FLOW, "%s\n", __func__);
-	if (!v4l2_chip_match_host(&reg->match))
-		dprintk(DBG_UNEXPECTED, "%s: match failed\n", __func__);
-		return -EINVAL;
 	if (reg->size == 1)
 		reg->val = tw_readb(reg->reg);
 	else
@@ -1989,17 +878,10 @@ static int vidioc_g_register(struct file *file, void *priv,
 }
 
 static int vidioc_s_register(struct file *file, void *priv,
-				struct v4l2_dbg_register *reg)
+				const struct v4l2_dbg_register *reg)
 {
-	struct tw68_fh *fh = priv;
-	struct tw68_dev *dev = fh->dev;	/* needed for tw_writeb */
+	struct tw68_dev *dev = video_drvdata(file);
 
-	dprintk(DBG_FLOW, "%s: request to set reg 0x%04x to 0x%02x\n",
-		__func__, (unsigned int)reg->reg, (unsigned int)reg->val);
-	if (!v4l2_chip_match_host(&reg->match)) {
-		dprintk(DBG_UNEXPECTED, "%s: match failed\n", __func__);
-		return -EINVAL;
-	}
 	if (reg->size == 1)
 		tw_writeb(reg->reg, reg->val);
 	else
@@ -2008,151 +890,120 @@ static int vidioc_s_register(struct file *file, void *priv,
 }
 #endif
 
+static const struct v4l2_ctrl_ops tw68_ctrl_ops = {
+	.s_ctrl = tw68_s_ctrl,
+};
+
 static const struct v4l2_file_operations video_fops = {
 	.owner			= THIS_MODULE,
-	.open			= video_open,
-	.release		= video_release,
-	.read			= video_read,
-	.poll			= video_poll,
-	.mmap			= video_mmap,
-	.ioctl			= video_ioctl2,
+	.open			= v4l2_fh_open,
+	.release		= vb2_fop_release,
+	.read			= vb2_fop_read,
+	.poll			= vb2_fop_poll,
+	.mmap			= vb2_fop_mmap,
+	.unlocked_ioctl		= video_ioctl2,
 };
 
 static const struct v4l2_ioctl_ops video_ioctl_ops = {
 	.vidioc_querycap		= tw68_querycap,
 	.vidioc_enum_fmt_vid_cap	= tw68_enum_fmt_vid_cap,
-	.vidioc_reqbufs			= tw68_reqbufs,
-	.vidioc_querybuf		= tw68_querybuf,
-	.vidioc_qbuf			= tw68_qbuf,
-	.vidioc_dqbuf			= tw68_dqbuf,
+	.vidioc_reqbufs			= vb2_ioctl_reqbufs,
+	.vidioc_create_bufs		= vb2_ioctl_create_bufs,
+	.vidioc_querybuf		= vb2_ioctl_querybuf,
+	.vidioc_qbuf			= vb2_ioctl_qbuf,
+	.vidioc_dqbuf			= vb2_ioctl_dqbuf,
 	.vidioc_s_std			= tw68_s_std,
 	.vidioc_g_std			= tw68_g_std,
 	.vidioc_enum_input		= tw68_enum_input,
 	.vidioc_g_input			= tw68_g_input,
 	.vidioc_s_input			= tw68_s_input,
-	.vidioc_queryctrl		= tw68_queryctrl,
-	.vidioc_g_ctrl			= tw68_g_ctrl,
-	.vidioc_s_ctrl			= tw68_s_ctrl,
-	.vidioc_streamon		= tw68_streamon,
-	.vidioc_streamoff		= tw68_streamoff,
-	.vidioc_g_priority		= tw68_g_priority,
-	.vidioc_s_priority		= tw68_s_priority,
+	.vidioc_streamon		= vb2_ioctl_streamon,
+	.vidioc_streamoff		= vb2_ioctl_streamoff,
 	.vidioc_g_fmt_vid_cap		= tw68_g_fmt_vid_cap,
 	.vidioc_try_fmt_vid_cap		= tw68_try_fmt_vid_cap,
 	.vidioc_s_fmt_vid_cap		= tw68_s_fmt_vid_cap,
-	.vidioc_cropcap			= tw68_cropcap,
-	.vidioc_g_crop			= tw68_g_crop,
-	.vidioc_s_crop			= tw68_s_crop,
-/*
- * Functions not yet implemented / not yet passing tests.
- */
-
-#if 0
-	.vidioc_g_fmt_vbi_cap		= tw68_try_get_set_fmt_vbi_cap,
-	.vidioc_try_fmt_vbi_cap		= tw68_try_get_set_fmt_vbi_cap,
-	.vidioc_s_fmt_vbi_cap		= tw68_try_get_set_fmt_vbi_cap,
-#endif
-	.vidioc_g_audio			= tw68_g_audio,
-	.vidioc_s_audio			= tw68_s_audio,
-	.vidioc_g_tuner			= tw68_g_tuner,
-	.vidioc_s_tuner			= tw68_s_tuner,
-	.vidioc_g_frequency		= tw68_g_frequency,
-	.vidioc_s_frequency		= tw68_s_frequency,
-#ifdef CONFIG_VIDEO_V4L1_COMPAT
-	.vidiocgmbuf			= vidiocgmbuf,
-#endif
-#ifdef CONFIG_VIDEO_ADV_DEBUG
 	.vidioc_log_status		= vidioc_log_status,
+	.vidioc_subscribe_event		= v4l2_ctrl_subscribe_event,
+	.vidioc_unsubscribe_event	= v4l2_event_unsubscribe,
+#ifdef CONFIG_VIDEO_ADV_DEBUG
 	.vidioc_g_register              = vidioc_g_register,
 	.vidioc_s_register              = vidioc_s_register,
 #endif
 };
 
-/* ------------------------------------------------------------------ */
-/* exported stuff                                                     */
-struct video_device tw68_video_template = {
+static struct video_device tw68_video_template = {
 	.name			= "tw68_video",
 	.fops			= &video_fops,
 	.ioctl_ops		= &video_ioctl_ops,
-	.minor			= -1,
+	.release		= video_device_release_empty,
 	.tvnorms		= TW68_NORMS,
-	.current_norm		= V4L2_STD_PAL,
-};
-
-struct video_device tw68_radio_template = {
-	.name			= "tw68_radio",
 };
 
-int tw68_videoport_init(struct tw68_dev *dev)
-{
-	return 0;
-}
-
+/* ------------------------------------------------------------------ */
+/* exported stuff                                                     */
 void tw68_set_tvnorm_hw(struct tw68_dev *dev)
 {
 	tw_andorb(TW68_SDT, 0x07, dev->tvnorm->format);
-	return;
 }
 
 int tw68_video_init1(struct tw68_dev *dev)
 {
-	int i;
-
-	dprintk(DBG_FLOW, "%s\n", __func__);
-	/* sanitycheck insmod options */
-	if (gbuffers < 2 || gbuffers > VIDEO_MAX_FRAME)
-		gbuffers = 2;
-	if (gbufsz < 0 || gbufsz > gbufsz_max)
-		gbufsz = gbufsz_max;
-	gbufsz = (gbufsz + PAGE_SIZE - 1) & PAGE_MASK;
-
-	/* put some sensible defaults into the data structures ... */
-	for (i = 0; i < CTRLS; i++)
-		tw68_s_ctrl_value(dev, video_ctrls[i].id,
-				  video_ctrls[i].default_value);
-#if 0
-	if (dev->tda9887_conf && dev->ctl_automute)
-		dev->tda9887_conf |= TDA9887_AUTOMUTE;
-	dev->automute       = 0;
-#endif
-	INIT_LIST_HEAD(&dev->video_q.queued);
-	INIT_LIST_HEAD(&dev->video_q.active);
-	init_timer(&dev->video_q.timeout);
-	dev->video_q.timeout.function	= tw68_buffer_timeout;
-	dev->video_q.timeout.data	= (unsigned long)(&dev->video_q);
-	dev->video_q.dev		= dev;
-	dev->video_q.buf_compat		= tw68_check_video_fmt;
-	dev->video_q.start_dma		= tw68_video_start_dma;
-	tw68_risc_stopper(dev->pci, &dev->video_q.stopper);
-
-	if (tw68_boards[dev->board].video_out)
-		tw68_videoport_init(dev);
-
+	struct v4l2_ctrl_handler *hdl = &dev->hdl;
+
+	v4l2_ctrl_handler_init(hdl, 6);
+	v4l2_ctrl_new_std(hdl, &tw68_ctrl_ops,
+			V4L2_CID_BRIGHTNESS, -128, 127, 1, 20);
+	v4l2_ctrl_new_std(hdl, &tw68_ctrl_ops,
+			V4L2_CID_CONTRAST, 0, 255, 1, 100);
+	v4l2_ctrl_new_std(hdl, &tw68_ctrl_ops,
+			V4L2_CID_SATURATION, 0, 255, 1, 128);
+	/* NTSC only */
+	v4l2_ctrl_new_std(hdl, &tw68_ctrl_ops,
+			V4L2_CID_HUE, -128, 127, 1, 0);
+	v4l2_ctrl_new_std(hdl, &tw68_ctrl_ops,
+			V4L2_CID_COLOR_KILLER, 0, 1, 1, 0);
+	v4l2_ctrl_new_std(hdl, &tw68_ctrl_ops,
+			V4L2_CID_CHROMA_AGC, 0, 1, 1, 1);
+	if (hdl->error) {
+		v4l2_ctrl_handler_free(hdl);
+		return hdl->error;
+	}
+	dev->v4l2_dev.ctrl_handler = hdl;
+	v4l2_ctrl_handler_setup(hdl);
 	return 0;
 }
 
-int tw68_video_init2(struct tw68_dev *dev)
+int tw68_video_init2(struct tw68_dev *dev, int video_nr)
 {
-	dprintk(DBG_FLOW, "%s\n", __func__);
+	int ret;
+
 	set_tvnorm(dev, &tvnorms[0]);
-	video_mux(dev, 0);
-/*
-	tw68_tvaudio_setmut(dev);
-	tw68_tvaudio_setvolume(dev, dev->ctl_volume);
-*/
-	return 0;
-}
 
-/*
- * tw68_irq_video_signalchange
- *
- * TODO:
- * Check for presence of video signal.  If not present, mute audio.
- * If present, log type of signal present.
- */
-void tw68_irq_video_signalchange(struct tw68_dev *dev)
-{
-	return;
+	dev->fmt      = format_by_fourcc(V4L2_PIX_FMT_BGR24);
+	dev->width    = 720;
+	dev->height   = 576;
+	dev->field    = V4L2_FIELD_INTERLACED;
+
+	INIT_LIST_HEAD(&dev->active);
+	dev->vidq.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	dev->vidq.timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;
+	dev->vidq.io_modes = VB2_MMAP | VB2_USERPTR | VB2_READ | VB2_DMABUF;
+	dev->vidq.ops = &tw68_video_qops;
+	dev->vidq.mem_ops = &vb2_dma_sg_memops;
+	dev->vidq.drv_priv = dev;
+	dev->vidq.gfp_flags = __GFP_DMA32;
+	dev->vidq.buf_struct_size = sizeof(struct tw68_buf);
+	dev->vidq.lock = &dev->lock;
+	dev->vidq.min_buffers_needed = 2;
+	ret = vb2_queue_init(&dev->vidq);
+	if (ret)
+		return ret;
+	dev->vdev = tw68_video_template;
+	dev->vdev.v4l2_dev = &dev->v4l2_dev;
+	dev->vdev.lock = &dev->lock;
+	dev->vdev.queue = &dev->vidq;
+	video_set_drvdata(&dev->vdev, dev);
+	return video_register_device(&dev->vdev, VFL_TYPE_GRABBER, video_nr);
 }
 
 /*
@@ -2171,60 +1022,39 @@ void tw68_irq_video_done(struct tw68_dev *dev, unsigned long status)
 	 * for the current buffer.
 	 */
 	if (status & TW68_DMAPI) {
-		struct tw68_dmaqueue *q = &dev->video_q;
-		dprintk(DBG_FLOW | DBG_TESTING, "DMAPI interrupt\n");
+		struct tw68_buf *buf;
+
 		spin_lock(&dev->slock);
-		/*
-		 * tw68_wakeup will take care of the buffer handling,
-		 * plus any non-video requirements.
-		 */
-		tw68_wakeup(q, &dev->video_fieldcount);
+		buf = list_entry(dev->active.next, struct tw68_buf, list);
+		list_del(&buf->list);
 		spin_unlock(&dev->slock);
-		/* Check whether we have gotten into 'stopper' code */
-		reg = tw_readl(TW68_DMAP_PP);
-		if ((reg >= q->stopper.dma) &&
-		    (reg < q->stopper.dma + q->stopper.size)) {
-			/* Yes - log the information */
-			dprintk(DBG_FLOW | DBG_TESTING,
-				"%s: stopper risc code entered\n", __func__);
-		}
+		v4l2_get_timestamp(&buf->vb.v4l2_buf.timestamp);
+		buf->vb.v4l2_buf.field = dev->field;
+		buf->vb.v4l2_buf.sequence = dev->seqnr++;
+		vb2_buffer_done(&buf->vb, VB2_BUF_STATE_DONE);
 		status &= ~(TW68_DMAPI);
 		if (0 == status)
 			return;
 	}
-	if (status & (TW68_VLOCK | TW68_HLOCK)) { /* lost sync */
-		dprintk(DBG_UNUSUAL, "Lost sync\n");
-	}
-	if (status & TW68_PABORT) {	/* TODO - what should we do? */
-		dprintk(DBG_UNEXPECTED, "PABORT interrupt\n");
-	}
-	if (status & TW68_DMAPERR) {
-		dprintk(DBG_UNEXPECTED, "DMAPERR interrupt\n");
-#if 0
-		/* Stop risc & fifo */
-		tw_clearl(TW68_DMAC, TW68_DMAP_EN | TW68_FIFO_EN);
-		tw_clearl(TW68_INTMASK, dev->board_virqmask);
-		dev->pci_irqmask &= ~dev->board_virqmask;
-#endif
-	}
+	if (status & (TW68_VLOCK | TW68_HLOCK))
+		dev_dbg(&dev->pci->dev, "Lost sync\n");
+	if (status & TW68_PABORT)
+		dev_err(&dev->pci->dev, "PABORT interrupt\n");
+	if (status & TW68_DMAPERR)
+		dev_err(&dev->pci->dev, "DMAPERR interrupt\n");
 	/*
 	 * On TW6800, FDMIS is apparently generated if video input is switched
 	 * during operation.  Therefore, it is not enabled for that chip.
 	 */
-	if (status & TW68_FDMIS) {	/* logic error somewhere */
-		dprintk(DBG_UNEXPECTED, "FDMIS interrupt\n");
-		/* Stop risc & fifo */
-//		tw_clearl(TW68_DMAC, TW68_DMAP_EN | TW68_FIFO_EN);
-//		tw_clearl(TW68_INTMASK, dev->board_virqmask);
-//		dev->pci_irqmask &= ~dev->board_virqmask;
-	}
-	if (status & TW68_FFOF) {	/* probably a logic error */
+	if (status & TW68_FDMIS)
+		dev_dbg(&dev->pci->dev, "FDMIS interrupt\n");
+	if (status & TW68_FFOF) {
+		/* probably a logic error */
 		reg = tw_readl(TW68_DMAC) & TW68_FIFO_EN;
 		tw_clearl(TW68_DMAC, TW68_FIFO_EN);
-		dprintk(DBG_UNUSUAL, "FFOF interrupt\n");
+		dev_dbg(&dev->pci->dev, "FFOF interrupt\n");
 		tw_setl(TW68_DMAC, reg);
 	}
 	if (status & TW68_FFERR)
-		dprintk(DBG_UNEXPECTED, "FFERR interrupt\n");
-	return;
+		dev_dbg(&dev->pci->dev, "FFERR interrupt\n");
 }

commit 5740f4e75f713015067e2667a52bd3b35ef91e07
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Wed Sep 3 03:31:07 2014 -0300

    [media] tw68: add original tw68 code
    
    This tw68 driver has been out-of-tree for many years on gitorious:
    https://gitorious.org/tw68/tw68-v2.
    
    This copies that code to the kernel as a record of that original code.
    
    Note that William Brack's email address in these sources is no longer
    valid and I have not been able to contact him. However, all the code is
    standard GPL.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/drivers/media/pci/tw68/tw68-video.c b/drivers/media/pci/tw68/tw68-video.c
new file mode 100644
index 000000000000..ca08ca38d3bd
--- /dev/null
+++ b/drivers/media/pci/tw68/tw68-video.c
@@ -0,0 +1,2230 @@
+/*
+ *  tw68 functions to handle video data
+ *
+ *  Much of this code is derived from the cx88 and sa7134 drivers, which
+ *  were in turn derived from the bt87x driver.  The original work was by
+ *  Gerd Knorr; more recently the code was enhanced by Mauro Carvalho Chehab,
+ *  Hans Verkuil, Andy Walls and many others.  Their work is gratefully
+ *  acknowledged.  Full credit goes to them - any problems within this code
+ *  are mine.
+ *
+ *  Copyright (C) 2009  William M. Brack <wbrack@mmm.com.hk>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/module.h>
+#include <media/v4l2-common.h>
+#include <linux/sort.h>
+
+#include "tw68.h"
+#include "tw68-reg.h"
+
+unsigned int video_debug;
+
+static unsigned int gbuffers	= 8;
+static unsigned int noninterlaced; /* 0 */
+static unsigned int gbufsz	= 768*576*4;
+static unsigned int gbufsz_max	= 768*576*4;
+static char secam[]		= "--";
+
+module_param(video_debug, int, 0644);
+MODULE_PARM_DESC(video_debug, "enable debug messages [video]");
+module_param(gbuffers, int, 0444);
+MODULE_PARM_DESC(gbuffers, "number of capture buffers, range 2-32");
+module_param(noninterlaced, int, 0644);
+MODULE_PARM_DESC(noninterlaced, "capture non interlaced video");
+module_param_string(secam, secam, sizeof(secam), 0644);
+MODULE_PARM_DESC(secam, "force SECAM variant, either DK,L or Lc");
+
+#define dprintk(level, fmt, arg...)     if (video_debug & (level)) \
+	printk(KERN_DEBUG "%s/0: " fmt, dev->name , ## arg)
+
+/* ------------------------------------------------------------------ */
+/* data structs for video                                             */
+/*
+ * FIXME -
+ * Note that the saa7134 has formats, e.g. YUV420, which are classified
+ * as "planar".  These affect overlay mode, and are flagged with a field
+ * ".planar" in the format.  Do we need to implement this in this driver?
+ */
+static struct tw68_format formats[] = {
+	{
+		.name		= "15 bpp RGB, le",
+		.fourcc		= V4L2_PIX_FMT_RGB555,
+		.depth		= 16,
+		.twformat	= ColorFormatRGB15,
+	}, {
+		.name		= "15 bpp RGB, be",
+		.fourcc		= V4L2_PIX_FMT_RGB555X,
+		.depth		= 16,
+		.twformat	= ColorFormatRGB15 | ColorFormatBSWAP,
+	}, {
+		.name		= "16 bpp RGB, le",
+		.fourcc		= V4L2_PIX_FMT_RGB565,
+		.depth		= 16,
+		.twformat	= ColorFormatRGB16,
+	}, {
+		.name		= "16 bpp RGB, be",
+		.fourcc		= V4L2_PIX_FMT_RGB565X,
+		.depth		= 16,
+		.twformat	= ColorFormatRGB16 | ColorFormatBSWAP,
+	}, {
+		.name		= "24 bpp RGB, le",
+		.fourcc		= V4L2_PIX_FMT_BGR24,
+		.depth		= 24,
+		.twformat	= ColorFormatRGB24,
+	}, {
+		.name		= "24 bpp RGB, be",
+		.fourcc		= V4L2_PIX_FMT_RGB24,
+		.depth		= 24,
+		.twformat	= ColorFormatRGB24 | ColorFormatBSWAP,
+	}, {
+		.name		= "32 bpp RGB, le",
+		.fourcc		= V4L2_PIX_FMT_BGR32,
+		.depth		= 32,
+		.twformat	= ColorFormatRGB32,
+	}, {
+		.name		= "32 bpp RGB, be",
+		.fourcc		= V4L2_PIX_FMT_RGB32,
+		.depth		= 32,
+		.twformat	= ColorFormatRGB32 | ColorFormatBSWAP |
+				  ColorFormatWSWAP,
+	}, {
+		.name		= "4:2:2 packed, YUYV",
+		.fourcc		= V4L2_PIX_FMT_YUYV,
+		.depth		= 16,
+		.twformat	= ColorFormatYUY2,
+	}, {
+		.name		= "4:2:2 packed, UYVY",
+		.fourcc		= V4L2_PIX_FMT_UYVY,
+		.depth		= 16,
+		.twformat	= ColorFormatYUY2 | ColorFormatBSWAP,
+	}
+};
+#define FORMATS ARRAY_SIZE(formats)
+
+#define NORM_625_50			\
+		.h_delay	= 3,	\
+		.h_delay0	= 133,	\
+		.h_start	= 0,	\
+		.h_stop		= 719,	\
+		.v_delay	= 24,	\
+		.vbi_v_start_0	= 7,	\
+		.vbi_v_stop_0	= 22,	\
+		.video_v_start	= 24,	\
+		.video_v_stop	= 311,	\
+		.vbi_v_start_1	= 319
+
+#define NORM_525_60			\
+		.h_delay	= 8,	\
+		.h_delay0	= 138,	\
+		.h_start	= 0,	\
+		.h_stop		= 719,	\
+		.v_delay	= 22,	\
+		.vbi_v_start_0	= 10,	\
+		.vbi_v_stop_0	= 21,	\
+		.video_v_start	= 22,	\
+		.video_v_stop	= 262,	\
+		.vbi_v_start_1	= 273
+
+/*
+ * The following table is searched by tw68_s_std, first for a specific
+ * match, then for an entry which contains the desired id.  The table
+ * entries should therefore be ordered in ascending order of specificity.
+ */
+static struct tw68_tvnorm tvnorms[]		= {
+	{
+		.name		= "PAL-BG",
+		.id		= V4L2_STD_PAL_BG,
+		NORM_625_50,
+
+		.sync_control	= 0x18,
+		.luma_control	= 0x40,
+		.chroma_ctrl1	= 0x81,
+		.chroma_gain	= 0x2a,
+		.chroma_ctrl2	= 0x06,
+		.vgate_misc	= 0x1c,
+		.format		= VideoFormatPALBDGHI,
+
+	}, {
+		.name		= "PAL-I",
+		.id		= V4L2_STD_PAL_I,
+		NORM_625_50,
+
+		.sync_control	= 0x18,
+		.luma_control	= 0x40,
+		.chroma_ctrl1	= 0x81,
+		.chroma_gain	= 0x2a,
+		.chroma_ctrl2	= 0x06,
+		.vgate_misc	= 0x1c,
+		.format		= VideoFormatPALBDGHI,
+
+	}, {
+		.name		= "PAL-DK",
+		.id		= V4L2_STD_PAL_DK,
+		NORM_625_50,
+
+		.sync_control	= 0x18,
+		.luma_control	= 0x40,
+		.chroma_ctrl1	= 0x81,
+		.chroma_gain	= 0x2a,
+		.chroma_ctrl2	= 0x06,
+		.vgate_misc	= 0x1c,
+		.format		= VideoFormatPALBDGHI,
+
+	}, {
+		.name		= "PAL", /* autodetect */
+		.id		= V4L2_STD_PAL,
+		NORM_625_50,
+
+		.sync_control	= 0x18,
+		.luma_control	= 0x40,
+		.chroma_ctrl1	= 0x81,
+		.chroma_gain	= 0x2a,
+		.chroma_ctrl2	= 0x06,
+		.vgate_misc	= 0x1c,
+		.format		= VideoFormatPALBDGHI,
+
+	}, {
+		.name		= "NTSC",
+		.id		= V4L2_STD_NTSC,
+		NORM_525_60,
+
+		.sync_control	= 0x59,
+		.luma_control	= 0x40,
+		.chroma_ctrl1	= 0x89,
+		.chroma_gain	= 0x2a,
+		.chroma_ctrl2	= 0x0e,
+		.vgate_misc	= 0x18,
+		.format		= VideoFormatNTSC,
+
+	}, {
+		.name		= "SECAM-DK",
+		.id		= V4L2_STD_SECAM_DK,
+		NORM_625_50,
+
+		.sync_control	= 0x18,
+		.luma_control	= 0x1b,
+		.chroma_ctrl1	= 0xd1,
+		.chroma_gain	= 0x80,
+		.chroma_ctrl2	= 0x00,
+		.vgate_misc	= 0x1c,
+		.format		= VideoFormatSECAM,
+
+	}, {
+		.name		= "SECAM-L",
+		.id		= V4L2_STD_SECAM_L,
+		NORM_625_50,
+
+		.sync_control	= 0x18,
+		.luma_control	= 0x1b,
+		.chroma_ctrl1	= 0xd1,
+		.chroma_gain	= 0x80,
+		.chroma_ctrl2	= 0x00,
+		.vgate_misc	= 0x1c,
+		.format		= VideoFormatSECAM,
+
+	}, {
+		.name		= "SECAM-LC",
+		.id		= V4L2_STD_SECAM_LC,
+		NORM_625_50,
+
+		.sync_control	= 0x18,
+		.luma_control	= 0x1b,
+		.chroma_ctrl1	= 0xd1,
+		.chroma_gain	= 0x80,
+		.chroma_ctrl2	= 0x00,
+		.vgate_misc	= 0x1c,
+		.format		= VideoFormatSECAM,
+
+	}, {
+		.name		= "SECAM",
+		.id		= V4L2_STD_SECAM,
+		NORM_625_50,
+
+		.sync_control	= 0x18,
+		.luma_control	= 0x1b,
+		.chroma_ctrl1	= 0xd1,
+		.chroma_gain	= 0x80,
+		.chroma_ctrl2	= 0x00,
+		.vgate_misc	= 0x1c,
+		.format		= VideoFormatSECAM,
+
+	}, {
+		.name		= "PAL-M",
+		.id		= V4L2_STD_PAL_M,
+		NORM_525_60,
+
+		.sync_control	= 0x59,
+		.luma_control	= 0x40,
+		.chroma_ctrl1	= 0xb9,
+		.chroma_gain	= 0x2a,
+		.chroma_ctrl2	= 0x0e,
+		.vgate_misc	= 0x18,
+		.format		= VideoFormatPALM,
+
+	}, {
+		.name		= "PAL-Nc",
+		.id		= V4L2_STD_PAL_Nc,
+		NORM_625_50,
+
+		.sync_control	= 0x18,
+		.luma_control	= 0x40,
+		.chroma_ctrl1	= 0xa1,
+		.chroma_gain	= 0x2a,
+		.chroma_ctrl2	= 0x06,
+		.vgate_misc	= 0x1c,
+		.format		= VideoFormatPALNC,
+
+	}, {
+		.name		= "PAL-60",
+		.id		= V4L2_STD_PAL_60,
+		.h_delay	= 186,
+		.h_start	= 0,
+		.h_stop		= 719,
+		.v_delay	= 26,
+		.video_v_start	= 23,
+		.video_v_stop	= 262,
+		.vbi_v_start_0	= 10,
+		.vbi_v_stop_0	= 21,
+		.vbi_v_start_1	= 273,
+
+		.sync_control	= 0x18,
+		.luma_control	= 0x40,
+		.chroma_ctrl1	= 0x81,
+		.chroma_gain	= 0x2a,
+		.chroma_ctrl2	= 0x06,
+		.vgate_misc	= 0x1c,
+		.format		= VideoFormatPAL60,
+
+	}, {
+/*
+ * 	FIXME:  The following are meant to be "catch-all", and need
+ *		to be further thought out!
+ */
+		.name		= "STD-525-60",
+		.id		= V4L2_STD_525_60,
+		NORM_525_60,
+
+		.sync_control	= 0x59,
+		.luma_control	= 0x40,
+		.chroma_ctrl1	= 0x89,
+		.chroma_gain	= 0x2a,
+		.chroma_ctrl2	= 0x0e,
+		.vgate_misc	= 0x18,
+		.format		= VideoFormatNTSC,
+
+	}, {
+		.name		= "STD-625-50",
+		.id		= V4L2_STD_625_50,
+		NORM_625_50,
+
+		.sync_control	= 0x18,
+		.luma_control	= 0x40,
+		.chroma_ctrl1	= 0x81,
+		.chroma_gain	= 0x2a,
+		.chroma_ctrl2	= 0x06,
+		.vgate_misc	= 0x1c,
+		.format		= VideoFormatPALBDGHI,
+	}
+};
+#define TVNORMS ARRAY_SIZE(tvnorms)
+
+static const struct v4l2_queryctrl no_ctrl		= {
+	.name		= "42",
+	.flags		= V4L2_CTRL_FLAG_DISABLED,
+};
+static const struct v4l2_queryctrl video_ctrls[]		= {
+	/* --- video --- */
+	{
+		.id		= V4L2_CID_BRIGHTNESS,
+		.name		= "Brightness",
+		.minimum	= -128,
+		.maximum	= 127,
+		.step		= 1,
+		.default_value	= 20,
+		.type		= V4L2_CTRL_TYPE_INTEGER,
+	}, {
+		.id		= V4L2_CID_CONTRAST,
+		.name		= "Contrast",
+		.minimum	= 0,
+		.maximum	= 255,
+		.step		= 1,
+		.default_value	= 100,
+		.type		= V4L2_CTRL_TYPE_INTEGER,
+	}, {
+		.id		= V4L2_CID_SATURATION,
+		.name		= "Saturation",
+		.minimum	= 0,
+		.maximum	= 255,
+		.step		= 1,
+		.default_value	= 128,
+		.type		= V4L2_CTRL_TYPE_INTEGER,
+	}, {
+		.id		= V4L2_CID_HUE,
+		.name		= "Hue",
+		.minimum	= -128,
+		.maximum	= 127,
+		.step		= 1,
+		.default_value	= 0,
+		.type		= V4L2_CTRL_TYPE_INTEGER,
+	}, {
+		.id		= V4L2_CID_COLOR_KILLER,
+		.name		= "Color Killer",
+		.minimum	= 0,
+		.maximum	= 1,
+		.default_value	= 1,
+		.type		= V4L2_CTRL_TYPE_BOOLEAN,
+	}, {
+		.id		= V4L2_CID_CHROMA_AGC,
+		.name		= "Chroma AGC",
+		.minimum	= 0,
+		.maximum	= 1,
+		.default_value	= 1,
+		.type		= V4L2_CTRL_TYPE_BOOLEAN,
+	},
+	/* --- audio --- */
+	{
+		.id		= V4L2_CID_AUDIO_MUTE,
+		.name		= "Mute",
+		.minimum	= 0,
+		.maximum	= 1,
+		.type		= V4L2_CTRL_TYPE_BOOLEAN,
+	}, {
+		.id		= V4L2_CID_AUDIO_VOLUME,
+		.name		= "Volume",
+		.minimum	= -15,
+		.maximum	= 15,
+		.step		= 1,
+		.default_value	= 0,
+		.type		= V4L2_CTRL_TYPE_INTEGER,
+	}
+};
+static const unsigned int CTRLS = ARRAY_SIZE(video_ctrls);
+
+/*
+ * Routine to lookup a control by its ID, and return a pointer
+ * to the entry in the video_ctrls array for that control.
+ */
+static const struct v4l2_queryctrl *ctrl_by_id(unsigned int id)
+{
+	unsigned int i;
+
+	for (i = 0; i < CTRLS; i++)
+		if (video_ctrls[i].id == id)
+			return video_ctrls+i;
+	return NULL;
+}
+
+static struct tw68_format *format_by_fourcc(unsigned int fourcc)
+{
+	unsigned int i;
+
+	for (i = 0; i < FORMATS; i++)
+		if (formats[i].fourcc == fourcc)
+			return formats+i;
+	return NULL;
+}
+
+/* ----------------------------------------------------------------------- */
+/* resource management                                                     */
+
+static int res_get(struct tw68_fh *fh, unsigned int bit)
+{
+	struct tw68_dev *dev = fh->dev;
+
+	if (fh->resources & bit)
+		/* have it already allocated */
+		return 1;
+
+	/* is it free? */
+	mutex_lock(&dev->lock);
+	if (dev->resources & bit) {
+		/* no, someone else uses it */
+		mutex_unlock(&fh->dev->lock);
+		return 0;
+	}
+	/* it's free, grab it */
+	fh->resources  |= bit;
+	dev->resources |= bit;
+	dprintk(DBG_FLOW, "%s: %d\n", __func__, bit);
+	mutex_unlock(&dev->lock);
+	return 1;
+}
+
+static int res_check(struct tw68_fh *fh, unsigned int bit)
+{
+	return fh->resources & bit;
+}
+
+static int res_locked(struct tw68_dev *dev, unsigned int bit)
+{
+	return dev->resources & bit;
+}
+
+static void res_free(struct tw68_fh *fh,
+		     unsigned int bits)
+{
+	struct tw68_dev *dev = fh->dev;
+
+	BUG_ON((fh->resources & bits) != bits);
+
+	mutex_lock(&fh->dev->lock);
+	fh->resources  &= ~bits;
+	fh->dev->resources &= ~bits;
+	dprintk(DBG_FLOW, "%s: %d\n", __func__, bits);
+	mutex_unlock(&fh->dev->lock);
+}
+
+/* ------------------------------------------------------------------ */
+/*
+ * Note that the cropping rectangles are described in terms of a single
+ * frame, i.e. line positions are only 1/2 the interlaced equivalent
+ */
+static void set_tvnorm(struct tw68_dev *dev, struct tw68_tvnorm *norm)
+{
+	dprintk(DBG_FLOW, "%s: %s\n", __func__, norm->name);
+	dev->tvnorm = norm;
+
+	/* setup cropping */
+	dev->crop_bounds.left    = norm->h_start;
+	dev->crop_defrect.left   = norm->h_start;
+	dev->crop_bounds.width   = norm->h_stop - norm->h_start + 1;
+	dev->crop_defrect.width  = norm->h_stop - norm->h_start + 1;
+
+	dev->crop_bounds.top     = norm->video_v_start;
+	dev->crop_defrect.top    = norm->video_v_start;
+	dev->crop_bounds.height  = (((norm->id & V4L2_STD_525_60) ?
+				    524 : 624)) / 2 - dev->crop_bounds.top;
+	dev->crop_defrect.height = (norm->video_v_stop -
+				    norm->video_v_start + 1);
+
+	dev->crop_current = dev->crop_defrect;
+
+	if (norm != dev->tvnorm) {
+		dev->tvnorm = norm;
+		tw68_set_tvnorm_hw(dev);
+	}
+}
+
+static void video_mux(struct tw68_dev *dev, int input)
+{
+	dprintk(DBG_FLOW, "%s: input = %d [%s]\n", __func__, input,
+		card_in(dev, input).name);
+	/*
+	 * dev->input shows current application request,
+	 * dev->hw_input shows current hardware setting
+	 */
+	dev->input = &card_in(dev, input);
+	tw68_tvaudio_setinput(dev, &card_in(dev, input));
+}
+
+/*
+ * tw68_set_scale
+ *
+ * Scaling and Cropping for video decoding
+ *
+ * We are working with 3 values for horizontal and vertical - scale,
+ * delay and active.
+ *
+ * HACTIVE represent the actual number of pixels in the "usable" image,
+ * before scaling.  HDELAY represents the number of pixels skipped
+ * between the start of the horizontal sync and the start of the image.
+ * HSCALE is calculated using the formula
+ * 	HSCALE = (HACTIVE / (#pixels desired)) * 256
+ *
+ * The vertical registers are similar, except based upon the total number
+ * of lines in the image, and the first line of the image (i.e. ignoring
+ * vertical sync and VBI).
+ *
+ * Note that the number of bytes reaching the FIFO (and hence needing
+ * to be processed by the DMAP program) is completely dependent upon
+ * these values, especially HSCALE.
+ *
+ * Parameters:
+ * 	@dev		pointer to the device structure, needed for
+ * 			getting current norm (as well as debug print)
+ * 	@width		actual image width (from user buffer)
+ * 	@height		actual image height
+ * 	@field		indicates Top, Bottom or Interlaced
+ */
+static int tw68_set_scale(struct tw68_dev *dev, unsigned int width,
+			  unsigned int height, enum v4l2_field field)
+{
+
+	/* set individually for debugging clarity */
+	int hactive, hdelay, hscale;
+	int vactive, vdelay, vscale;
+	int comb;
+
+	if (V4L2_FIELD_HAS_BOTH(field))	/* if field is interlaced */
+		height /= 2;		/* we must set for 1-frame */
+
+	dprintk(DBG_FLOW, "%s: width=%d, height=%d, both=%d\n  Crop rect: "
+		    "top=%d, left=%d, width=%d height=%d\n"
+		    "  tvnorm h_delay=%d, h_start=%d, h_stop=%d, "
+		    "v_delay=%d, v_start=%d, v_stop=%d\n" , __func__,
+		width, height, V4L2_FIELD_HAS_BOTH(field),
+		dev->crop_bounds.top, dev->crop_bounds.left,
+		dev->crop_bounds.width, dev->crop_bounds.height,
+		dev->tvnorm->h_delay, dev->tvnorm->h_start, dev->tvnorm->h_stop,
+		dev->tvnorm->v_delay, dev->tvnorm->video_v_start,
+		dev->tvnorm->video_v_stop);
+
+	switch (dev->vdecoder) {
+	case TW6800:
+		hdelay = dev->tvnorm->h_delay0;
+		break;
+	default:
+		hdelay = dev->tvnorm->h_delay;
+		break;
+	}
+	hdelay += dev->crop_bounds.left;
+	hactive = dev->crop_bounds.width;
+
+	hscale = (hactive * 256) / (width);
+
+	vdelay = dev->tvnorm->v_delay + dev->crop_bounds.top -
+		 dev->crop_defrect.top;
+	vactive = dev->crop_bounds.height;
+	vscale = (vactive * 256) / height;
+
+	dprintk(DBG_FLOW, "%s: %dx%d [%s%s,%s]\n", __func__,
+		width, height,
+		V4L2_FIELD_HAS_TOP(field)    ? "T" : "",
+		V4L2_FIELD_HAS_BOTTOM(field) ? "B" : "",
+		v4l2_norm_to_name(dev->tvnorm->id));
+	dprintk(DBG_FLOW, "%s: hactive=%d, hdelay=%d, hscale=%d; "
+		"vactive=%d, vdelay=%d, vscale=%d\n", __func__,
+		hactive, hdelay, hscale, vactive, vdelay, vscale);
+
+	comb =	((vdelay & 0x300)  >> 2) |
+		((vactive & 0x300) >> 4) |
+		((hdelay & 0x300)  >> 6) |
+		((hactive & 0x300) >> 8);
+	dprintk(DBG_FLOW, "%s: setting CROP_HI=%02x, VDELAY_LO=%02x, "
+		"VACTIVE_LO=%02x, HDELAY_LO=%02x, HACTIVE_LO=%02x\n",
+		__func__, comb, vdelay, vactive, hdelay, hactive);
+	tw_writeb(TW68_CROP_HI, comb);
+	tw_writeb(TW68_VDELAY_LO, vdelay & 0xff);
+	tw_writeb(TW68_VACTIVE_LO, vactive & 0xff);
+	tw_writeb(TW68_HDELAY_LO, hdelay & 0xff);
+	tw_writeb(TW68_HACTIVE_LO, hactive & 0xff);
+
+	comb = ((vscale & 0xf00) >> 4) | ((hscale & 0xf00) >> 8);
+	dprintk(DBG_FLOW, "%s: setting SCALE_HI=%02x, VSCALE_LO=%02x, "
+		"HSCALE_LO=%02x\n", __func__, comb, vscale, hscale);
+	tw_writeb(TW68_SCALE_HI, comb);
+	tw_writeb(TW68_VSCALE_LO, vscale);
+	tw_writeb(TW68_HSCALE_LO, hscale);
+
+	return 0;
+}
+
+/* ------------------------------------------------------------------ */
+
+static int tw68_video_start_dma(struct tw68_dev *dev, struct tw68_dmaqueue *q,
+				struct tw68_buf *buf) {
+
+	dprintk(DBG_FLOW, "%s: Starting risc program\n", __func__);
+	/* Assure correct input */
+	if (dev->hw_input != dev->input) {
+		dev->hw_input = dev->input;
+		tw_andorb(TW68_INFORM, 0x03 << 2, dev->input->vmux << 2);
+	}
+	/* Set cropping and scaling */
+	tw68_set_scale(dev, buf->vb.width, buf->vb.height, buf->vb.field);
+	/*
+	 *  Set start address for RISC program.  Note that if the DMAP
+	 *  processor is currently running, it must be stopped before
+	 *  a new address can be set.
+	 */
+	tw_clearl(TW68_DMAC, TW68_DMAP_EN);
+	tw_writel(TW68_DMAP_SA, cpu_to_le32(buf->risc.dma));
+	/* Clear any pending interrupts */
+	tw_writel(TW68_INTSTAT, dev->board_virqmask);
+	/* Enable the risc engine and the fifo */
+	tw_andorl(TW68_DMAC, 0xff, buf->fmt->twformat |
+		ColorFormatGamma | TW68_DMAP_EN | TW68_FIFO_EN);
+	dev->pci_irqmask |= dev->board_virqmask;
+	tw_setl(TW68_INTMASK, dev->pci_irqmask);
+	return 0;
+}
+
+/* ------------------------------------------------------------------ */
+/* videobuf queue operations                                          */
+
+/*
+ * check_buf_fmt
+ *
+ * callback from tw68-core buffer_queue to determine whether the
+ * current buffer and the previous one are "compatible" (i.e. the
+ * risc programs can be chained without requiring a format change)
+ */
+static int tw68_check_video_fmt(struct tw68_buf *prev, struct tw68_buf *buf)
+{
+	return (prev->vb.width  == buf->vb.width  &&
+		prev->vb.height == buf->vb.height &&
+		prev->fmt       == buf->fmt);
+}
+
+/*
+ * buffer_setup
+ *
+ * Calculate required size of buffer and maximum number allowed
+ */
+static int
+buffer_setup(struct videobuf_queue *q, unsigned int *count,
+	     unsigned int *size)
+{
+	struct tw68_fh *fh = q->priv_data;
+
+	*size = fh->fmt->depth * fh->width * fh->height >> 3;
+	if (0 == *count)
+		*count = gbuffers;
+	*count = tw68_buffer_count(*size, *count);
+	return 0;
+}
+
+static int buffer_activate(struct tw68_dev *dev, struct tw68_buf *buf,
+			   struct tw68_buf *next)
+{
+	dprintk(DBG_BUFF, "%s: dev=%p, buf=%p, next=%p\n",
+		__func__, dev, buf, next);
+	if (dev->hw_input != dev->input) {
+		dev->hw_input = dev->input;
+		tw_andorb(TW68_INFORM, 0x03 << 2,
+			  dev->hw_input->vmux << 2);
+	}
+	buf->vb.state = VIDEOBUF_ACTIVE;
+	/* TODO - need to assure scaling/cropping are set correctly */
+	mod_timer(&dev->video_q.timeout, jiffies+BUFFER_TIMEOUT);
+	return 0;
+}
+
+/*
+* buffer_prepare
+*
+* Set the ancilliary information into the buffer structure.  This
+* includes generating the necessary risc program if it hasn't already
+* been done for the current buffer format.
+* The structure fh contains the details of the format requested by the
+* user - type, width, height and #fields.  This is compared with the
+* last format set for the current buffer.  If they differ, the risc
+* code (which controls the filling of the buffer) is (re-)generated.
+*/
+static int
+buffer_prepare(struct videobuf_queue *q, struct videobuf_buffer *vb,
+	       enum v4l2_field field)
+{
+	struct tw68_fh   *fh  = q->priv_data;
+	struct tw68_dev  *dev = fh->dev;
+	struct tw68_buf *buf = container_of(vb, struct tw68_buf, vb);
+	struct videobuf_dmabuf *dma = videobuf_to_dma(&buf->vb);
+	int rc, init_buffer = 0;
+	unsigned int maxw, maxh;
+
+	BUG_ON(NULL == fh->fmt);
+	maxw = dev->tvnorm->h_stop - dev->tvnorm->h_start + 1;
+	maxh = 2*(dev->tvnorm->video_v_stop - dev->tvnorm->video_v_start + 1);
+	if (fh->width  < 48 || fh->width  > maxw || fh->height > maxh
+		|| fh->height < 16) {
+		dprintk(DBG_UNEXPECTED, "%s: invalid dimensions - "
+			"fh->width=%d, fh->height=%d, maxw=%d, maxh=%d\n",
+			__func__, fh->width, fh->height, maxw, maxh);
+		return -EINVAL;
+	}
+	buf->vb.size = (fh->width * fh->height * (fh->fmt->depth)) >> 3;
+	if (0 != buf->vb.baddr  &&  buf->vb.bsize < buf->vb.size)
+		return -EINVAL;
+
+	if (buf->fmt       != fh->fmt    ||
+	    buf->vb.width  != fh->width  ||
+	    buf->vb.height != fh->height ||
+	    buf->vb.field  != field) {
+		dprintk(DBG_BUFF, "%s: buf - fmt=%p, width=%3d, height=%3d, "
+			"field=%d\n%s: fh  - fmt=%p, width=%3d, height=%3d, "
+			"field=%d\n", __func__, buf->fmt, buf->vb.width,
+			buf->vb.height, buf->vb.field, __func__, fh->fmt,
+			fh->width, fh->height, field);
+		buf->fmt       = fh->fmt;
+		buf->vb.width  = fh->width;
+		buf->vb.height = fh->height;
+		buf->vb.field  = field;
+		init_buffer = 1;	/* force risc code re-generation */
+	}
+	buf->input = dev->input;
+
+	if (VIDEOBUF_NEEDS_INIT == buf->vb.state) {
+		rc = videobuf_iolock(q, &buf->vb, NULL);
+		if (0 != rc)
+			goto fail;
+		init_buffer = 1;	/* force risc code re-generation */
+	}
+	dprintk(DBG_BUFF, "%s: q=%p, vb=%p, init_buffer=%d\n",
+		__func__, q, vb, init_buffer);
+
+	if (init_buffer) {
+		buf->bpl = buf->vb.width * (buf->fmt->depth) >> 3;
+		dprintk(DBG_TESTING, "%s: Generating new risc code "
+			"[%dx%dx%d](%d)\n", __func__, buf->vb.width,
+			buf->vb.height, buf->fmt->depth, buf->bpl);
+		switch (buf->vb.field) {
+		case V4L2_FIELD_TOP:
+			tw68_risc_buffer(dev->pci, &buf->risc,
+					 dma->sglist,
+					 0, UNSET,
+					 buf->bpl, 0,
+					 buf->vb.height);
+			break;
+		case V4L2_FIELD_BOTTOM:
+			tw68_risc_buffer(dev->pci, &buf->risc,
+					 dma->sglist,
+					 UNSET, 0,
+					 buf->bpl, 0,
+					 buf->vb.height);
+			break;
+		case V4L2_FIELD_INTERLACED:
+			tw68_risc_buffer(dev->pci, &buf->risc,
+					 dma->sglist,
+					 0, buf->bpl,
+					 buf->bpl, buf->bpl,
+					 buf->vb.height >> 1);
+			break;
+		case V4L2_FIELD_SEQ_TB:
+			tw68_risc_buffer(dev->pci, &buf->risc,
+					 dma->sglist,
+					 0, buf->bpl * (buf->vb.height >> 1),
+					 buf->bpl, 0,
+					 buf->vb.height >> 1);
+			break;
+		case V4L2_FIELD_SEQ_BT:
+			tw68_risc_buffer(dev->pci, &buf->risc,
+					 dma->sglist,
+					 buf->bpl * (buf->vb.height >> 1), 0,
+					 buf->bpl, 0,
+					 buf->vb.height >> 1);
+			break;
+		default:
+			BUG();
+		}
+	}
+	dprintk(DBG_BUFF, "%s: [%p/%d] - %dx%d %dbpp \"%s\" - dma=0x%08lx\n",
+		__func__, buf, buf->vb.i, fh->width, fh->height,
+		fh->fmt->depth, fh->fmt->name, (unsigned long)buf->risc.dma);
+
+	buf->vb.state = VIDEOBUF_PREPARED;
+	buf->activate = buffer_activate;
+	return 0;
+
+ fail:
+	tw68_dma_free(q, buf);
+	return rc;
+}
+
+/*
+ * buffer_queue
+ *
+ * Callback whenever a buffer has been requested (by read() or QBUF)
+ */
+static void
+buffer_queue(struct videobuf_queue *q, struct videobuf_buffer *vb)
+{
+	struct tw68_fh	*fh = q->priv_data;
+	struct tw68_buf	*buf = container_of(vb, struct tw68_buf, vb);
+
+	tw68_buffer_queue(fh->dev, &fh->dev->video_q, buf);
+}
+
+/*
+ * buffer_release
+ *
+ * Free a buffer previously allocated.
+ */
+static void buffer_release(struct videobuf_queue *q,
+			   struct videobuf_buffer *vb)
+{
+	struct tw68_buf *buf = container_of(vb, struct tw68_buf, vb);
+
+	tw68_dma_free(q, buf);
+}
+
+static struct videobuf_queue_ops video_qops = {
+	.buf_setup    = buffer_setup,
+	.buf_prepare  = buffer_prepare,
+	.buf_queue    = buffer_queue,
+	.buf_release  = buffer_release,
+};
+
+/* ------------------------------------------------------------------ */
+
+static int tw68_g_ctrl_internal(struct tw68_dev *dev, struct tw68_fh *fh,
+				struct v4l2_control *c)
+{
+	const struct v4l2_queryctrl *ctrl;
+
+	dprintk(DBG_FLOW, "%s\n", __func__);
+	ctrl = ctrl_by_id(c->id);
+	if (NULL == ctrl)
+		return -EINVAL;
+	switch (c->id) {
+	case V4L2_CID_BRIGHTNESS:
+		c->value = (char)tw_readb(TW68_BRIGHT);
+		break;
+	case V4L2_CID_HUE:
+		c->value = (char)tw_readb(TW68_HUE);
+		break;
+	case V4L2_CID_CONTRAST:
+		c->value = tw_readb(TW68_CONTRAST);
+		break;
+	case V4L2_CID_SATURATION:
+		c->value = tw_readb(TW68_SAT_U);
+		break;
+	case V4L2_CID_COLOR_KILLER:
+		c->value = 0 != (tw_readb(TW68_MISC2) & 0xe0);
+		break;
+	case V4L2_CID_CHROMA_AGC:
+		c->value = 0 != (tw_readb(TW68_LOOP) & 0x30);
+		break;
+	case V4L2_CID_AUDIO_MUTE:
+		/*hack to suppresss tvtime complaint */
+		c->value = 0;
+		break;
+#if 0
+	case V4L2_CID_AUDIO_VOLUME:
+		c->value = dev->ctl_volume;
+		break;
+#endif
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int tw68_g_ctrl(struct file *file, void *priv, struct v4l2_control *c)
+{
+	struct tw68_fh *fh = priv;
+
+	return tw68_g_ctrl_internal(fh->dev, fh, c);
+}
+
+static int tw68_s_ctrl_value(struct tw68_dev *dev, __u32 id, int val)
+{
+	int err = 0;
+
+	dprintk(DBG_FLOW, "%s\n", __func__);
+	switch (id) {
+	case V4L2_CID_BRIGHTNESS:
+		tw_writeb(TW68_BRIGHT, val);
+		break;
+	case V4L2_CID_HUE:
+		tw_writeb(TW68_HUE, val);
+		break;
+	case V4L2_CID_CONTRAST:
+		tw_writeb(TW68_CONTRAST, val);
+		break;
+	case V4L2_CID_SATURATION:
+		tw_writeb(TW68_SAT_U, val);
+		tw_writeb(TW68_SAT_V, val);
+		break;
+	case V4L2_CID_COLOR_KILLER:
+		if (val)
+			tw_andorb(TW68_MISC2, 0xe0, 0xe0);
+		else
+			tw_andorb(TW68_MISC2, 0xe0, 0x00);
+		break;
+	case V4L2_CID_CHROMA_AGC:
+		if (val)
+			tw_andorb(TW68_LOOP, 0x30, 0x20);
+		else
+			tw_andorb(TW68_LOOP, 0x30, 0x00);
+		break;
+	case V4L2_CID_AUDIO_MUTE:
+		/* hack to suppress tvtime complaint */
+		break;
+#if 0
+	case V4L2_CID_AUDIO_VOLUME:
+		dev->ctl_volume = val;
+		tw68_tvaudio_setvolume(dev, dev->ctl_volume);
+		break;
+	case V4L2_CID_HFLIP:
+		dev->ctl_mirror = val;
+		break;
+	case V4L2_CID_PRIVATE_AUTOMUTE:
+	{
+		struct v4l2_priv_tun_config tda9887_cfg;
+
+		tda9887_cfg.tuner = TUNER_TDA9887;
+		tda9887_cfg.priv = &dev->tda9887_conf;
+
+		dev->ctl_automute = val;
+		if (dev->tda9887_conf) {
+			if (dev->ctl_automute)
+				dev->tda9887_conf |= TDA9887_AUTOMUTE;
+			else
+				dev->tda9887_conf &= ~TDA9887_AUTOMUTE;
+
+			tw_call_all(dev, tuner, s_config, &tda9887_cfg);
+		}
+		break;
+	}
+#endif
+	default:
+		err = -EINVAL;
+	}
+	return err;
+}
+
+static int tw68_s_ctrl_internal(struct tw68_dev *dev,  struct tw68_fh *fh,
+			 struct v4l2_control *c)
+{
+	const struct v4l2_queryctrl *ctrl;
+	int err;
+
+	dprintk(DBG_FLOW, "%s\n", __func__);
+	if (fh) {
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,34)
+		err = v4l2_prio_check(&dev->prio, &fh->prio);
+#else
+		err = v4l2_prio_check(&dev->prio, fh->prio);
+#endif
+		if (0 != err)
+			return err;
+	}
+
+	mutex_lock(&dev->lock);
+
+	ctrl = ctrl_by_id(c->id);
+	if (NULL == ctrl) {
+		err = -EINVAL;
+		goto error;
+	}
+
+	dprintk(DBG_BUFF, "%s: name=%s val=%d\n", __func__,
+		ctrl->name, c->value);
+	switch (ctrl->type) {
+	case V4L2_CTRL_TYPE_BOOLEAN:
+	case V4L2_CTRL_TYPE_MENU:
+	case V4L2_CTRL_TYPE_INTEGER:
+		if (c->value < ctrl->minimum)
+			c->value = ctrl->minimum;
+		if (c->value > ctrl->maximum)
+			c->value = ctrl->maximum;
+		break;
+	default:
+		/* nothing */;
+	};
+	err = tw68_s_ctrl_value(dev, c->id, c->value);
+
+error:
+	mutex_unlock(&dev->lock);
+	return err;
+}
+
+static int tw68_s_ctrl(struct file *file, void *f, struct v4l2_control *c)
+{
+	struct tw68_fh *fh = f;
+
+	return tw68_s_ctrl_internal(fh->dev, fh, c);
+}
+
+/* ------------------------------------------------------------------ */
+
+/*
+ * Returns a pointer to the currently used queue (e.g. video, vbi, etc.)
+ */
+static struct videobuf_queue *tw68_queue(struct tw68_fh *fh)
+{
+	struct videobuf_queue *q = NULL;
+
+	switch (fh->type) {
+	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
+		q = &fh->cap;
+		break;
+	case V4L2_BUF_TYPE_VBI_CAPTURE:
+		q = &fh->vbi;
+		break;
+	default:
+		BUG();
+	}
+	return q;
+}
+
+static int tw68_resource(struct tw68_fh *fh)
+{
+	if (fh->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return RESOURCE_VIDEO;
+
+	if (fh->type == V4L2_BUF_TYPE_VBI_CAPTURE)
+		return RESOURCE_VBI;
+
+	BUG();
+	return 0;
+}
+
+static int video_open(struct file *file)
+{
+	int minor = video_devdata(file)->minor;
+	struct tw68_dev *dev;
+	struct tw68_fh *fh;
+	enum v4l2_buf_type type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	int radio = 0;
+
+	mutex_lock(&tw68_devlist_lock);
+	list_for_each_entry(dev, &tw68_devlist, devlist) {
+		if (dev->video_dev && (dev->video_dev->minor == minor))
+			goto found;
+		if (dev->radio_dev && (dev->radio_dev->minor == minor)) {
+			radio = 1;
+			goto found;
+		}
+		if (dev->vbi_dev && (dev->vbi_dev->minor == minor)) {
+			type = V4L2_BUF_TYPE_VBI_CAPTURE;
+			goto found;
+		}
+	}
+	mutex_unlock(&tw68_devlist_lock);
+	return -ENODEV;
+
+found:
+	mutex_unlock(&tw68_devlist_lock);
+
+	dprintk(DBG_FLOW, "%s: minor=%d radio=%d type=%s\n", __func__, minor,
+		radio, v4l2_type_names[type]);
+
+	/* allocate + initialize per filehandle data */
+	fh = kzalloc(sizeof(*fh), GFP_KERNEL);
+	if (NULL == fh)
+		return -ENOMEM;
+
+	file->private_data = fh;
+	fh->dev      = dev;
+	fh->radio    = radio;
+	fh->type     = type;
+	fh->fmt      = format_by_fourcc(V4L2_PIX_FMT_BGR24);
+	fh->width    = 720;
+	fh->height   = 576;
+	v4l2_prio_open(&dev->prio, &fh->prio);
+
+	videobuf_queue_sg_init(&fh->cap, &video_qops,
+			    &dev->pci->dev, &dev->slock,
+			    V4L2_BUF_TYPE_VIDEO_CAPTURE,
+			    V4L2_FIELD_INTERLACED,
+			    sizeof(struct tw68_buf),
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,37)
+			    fh
+#else
+			    fh, &dev->lock
+#endif
+             );
+	videobuf_queue_sg_init(&fh->vbi, &tw68_vbi_qops,
+			    &dev->pci->dev, &dev->slock,
+			    V4L2_BUF_TYPE_VBI_CAPTURE,
+			    V4L2_FIELD_SEQ_TB,
+			    sizeof(struct tw68_buf),
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,37)
+			    fh
+#else
+			    fh, &dev->lock
+#endif
+             );
+	if (fh->radio) {
+		/* switch to radio mode */
+		tw68_tvaudio_setinput(dev, &card(dev).radio);
+		tw_call_all(dev, tuner, s_radio);
+	} else {
+		/* switch to video/vbi mode */
+		tw68_tvaudio_setinput(dev, dev->input);
+	}
+	return 0;
+}
+
+static ssize_t
+video_read(struct file *file, char __user *data, size_t count, loff_t *ppos)
+{
+	struct tw68_fh *fh = file->private_data;
+
+	switch (fh->type) {
+	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
+		if (res_locked(fh->dev, RESOURCE_VIDEO))
+			return -EBUSY;
+		return videobuf_read_one(tw68_queue(fh),
+					 data, count, ppos,
+					 file->f_flags & O_NONBLOCK);
+	case V4L2_BUF_TYPE_VBI_CAPTURE:
+		if (!res_get(fh, RESOURCE_VBI))
+			return -EBUSY;
+		return videobuf_read_stream(tw68_queue(fh),
+					    data, count, ppos, 1,
+					    file->f_flags & O_NONBLOCK);
+		break;
+	default:
+		BUG();
+		return 0;
+	}
+}
+
+static unsigned int
+video_poll(struct file *file, struct poll_table_struct *wait)
+{
+	struct tw68_fh *fh = file->private_data;
+	struct videobuf_buffer *buf = NULL;
+
+	if (V4L2_BUF_TYPE_VBI_CAPTURE == fh->type)
+		return videobuf_poll_stream(file, &fh->vbi, wait);
+
+	if (res_check(fh, RESOURCE_VIDEO)) {
+		if (!list_empty(&fh->cap.stream))
+			buf = list_entry(fh->cap.stream.next,
+				struct videobuf_buffer, stream);
+	} else {
+		mutex_lock(&fh->cap.vb_lock);
+		if (UNSET == fh->cap.read_off) {
+			/* need to capture a new frame */
+			if (res_locked(fh->dev, RESOURCE_VIDEO))
+				goto err;
+			if (0 != fh->cap.ops->buf_prepare(&fh->cap,
+					fh->cap.read_buf, fh->cap.field))
+				goto err;
+			fh->cap.ops->buf_queue(&fh->cap, fh->cap.read_buf);
+			fh->cap.read_off = 0;
+		}
+		mutex_unlock(&fh->cap.vb_lock);
+		buf = fh->cap.read_buf;
+	}
+
+	if (!buf)
+		return POLLERR;
+
+	poll_wait(file, &buf->done, wait);
+	if (buf->state == VIDEOBUF_DONE ||
+	    buf->state == VIDEOBUF_ERROR)
+		return POLLIN | POLLRDNORM;
+	return 0;
+
+err:
+	mutex_unlock(&fh->cap.vb_lock);
+	return POLLERR;
+}
+
+static int video_release(struct file *file)
+{
+	struct tw68_fh  *fh  = file->private_data;
+	struct tw68_dev *dev = fh->dev;
+
+	/* stop video capture */
+	if (res_check(fh, RESOURCE_VIDEO)) {
+		videobuf_streamoff(&fh->cap);
+		res_free(fh , RESOURCE_VIDEO);
+	}
+	if (fh->cap.read_buf) {
+		buffer_release(&fh->cap, fh->cap.read_buf);
+		kfree(fh->cap.read_buf);
+	}
+
+	/* stop vbi capture */
+	if (res_check(fh, RESOURCE_VBI)) {
+		videobuf_stop(&fh->vbi);
+		res_free(fh, RESOURCE_VBI);
+	}
+
+#if 0
+	tw_call_all(dev, core, s_standby, 0);
+#endif
+
+	/* free stuff */
+	videobuf_mmap_free(&fh->cap);
+	videobuf_mmap_free(&fh->vbi);
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,34)
+	v4l2_prio_close(&dev->prio, &fh->prio);
+#else
+	v4l2_prio_close(&dev->prio, fh->prio);
+#endif
+	file->private_data = NULL;
+	kfree(fh);
+	return 0;
+}
+
+static int video_mmap(struct file *file, struct vm_area_struct * vma)
+{
+	struct tw68_fh *fh = file->private_data;
+
+	return videobuf_mmap_mapper(tw68_queue(fh), vma);
+}
+
+/* ------------------------------------------------------------------ */
+
+#if 0
+static int tw68_try_get_set_fmt_vbi_cap(struct file *file, void *priv,
+						struct v4l2_format *f)
+{
+	struct tw68_fh *fh = priv;
+	struct tw68_dev *dev = fh->dev;
+	struct tw68_tvnorm *norm = dev->tvnorm;
+
+	f->fmt.vbi.sampling_rate = 6750000 * 4;
+	f->fmt.vbi.samples_per_line = 2048 /* VBI_LINE_LENGTH */;
+	f->fmt.vbi.sample_format = V4L2_PIX_FMT_GREY;
+	f->fmt.vbi.offset = 64 * 4;
+	f->fmt.vbi.start[0] = norm->vbi_v_start_0;
+	f->fmt.vbi.count[0] = norm->vbi_v_stop_0 - norm->vbi_v_start_0 + 1;
+	f->fmt.vbi.start[1] = norm->vbi_v_start_1;
+	f->fmt.vbi.count[1] = f->fmt.vbi.count[0];
+	f->fmt.vbi.flags = 0; /* VBI_UNSYNC VBI_INTERLACED */
+
+#if 0
+	if (V4L2_STD_PAL == norm->id) {
+		/* FIXME */
+		f->fmt.vbi.start[0] += 3;
+		f->fmt.vbi.start[1] += 3*2;
+	}
+#endif
+	return 0;
+}
+#endif
+
+/*
+ * Note that this routine returns what is stored in the fh structure, and
+ * does not interrogate any of the device registers.
+ */
+static int tw68_g_fmt_vid_cap(struct file *file, void *priv,
+				struct v4l2_format *f)
+{
+	struct tw68_fh *fh = priv;
+	struct tw68_dev *dev = fh->dev;
+
+	dprintk(DBG_FLOW, "%s\n", __func__);
+	f->fmt.pix.width        = fh->width;
+	f->fmt.pix.height       = fh->height;
+	f->fmt.pix.field        = fh->cap.field;
+	f->fmt.pix.pixelformat  = fh->fmt->fourcc;
+	f->fmt.pix.bytesperline =
+		(f->fmt.pix.width * (fh->fmt->depth)) >> 3;
+	f->fmt.pix.sizeimage =
+		f->fmt.pix.height * f->fmt.pix.bytesperline;
+	f->fmt.pix.colorspace	= V4L2_COLORSPACE_SMPTE170M;
+	return 0;
+}
+
+static int tw68_try_fmt_vid_cap(struct file *file, void *priv,
+						struct v4l2_format *f)
+{
+	struct tw68_fh *fh = priv;
+	struct tw68_dev *dev = fh->dev;
+	struct tw68_format *fmt;
+	enum v4l2_field field;
+	unsigned int maxw, maxh;
+
+	dprintk(DBG_FLOW, "%s\n", __func__);
+	fmt = format_by_fourcc(f->fmt.pix.pixelformat);
+	if (NULL == fmt)
+		return -EINVAL;
+
+	field = f->fmt.pix.field;
+	maxw  = min(dev->crop_current.width*4,  dev->crop_bounds.width);
+	maxh  = min(dev->crop_current.height*4, dev->crop_bounds.height);
+
+	if (V4L2_FIELD_ANY == field) {
+		field = (f->fmt.pix.height > maxh/2)
+			? V4L2_FIELD_INTERLACED
+			: V4L2_FIELD_BOTTOM;
+	}
+	switch (field) {
+	case V4L2_FIELD_TOP:
+	case V4L2_FIELD_BOTTOM:
+		break;
+	case V4L2_FIELD_INTERLACED:
+		maxh = maxh * 2;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	f->fmt.pix.field = field;
+	if (f->fmt.pix.width  < 48)
+		f->fmt.pix.width  = 48;
+	if (f->fmt.pix.height < 32)
+		f->fmt.pix.height = 32;
+	if (f->fmt.pix.width > maxw)
+		f->fmt.pix.width = maxw;
+	if (f->fmt.pix.height > maxh)
+		f->fmt.pix.height = maxh;
+	f->fmt.pix.width &= ~0x03;
+	f->fmt.pix.bytesperline =
+		(f->fmt.pix.width * (fmt->depth)) >> 3;
+	f->fmt.pix.sizeimage =
+		f->fmt.pix.height * f->fmt.pix.bytesperline;
+
+	return 0;
+}
+
+/*
+ * Note that tw68_s_fmt_vid_cap sets the information into the fh structure,
+ * and it will be used for all future new buffers.  However, there could be
+ * some number of buffers on the "active" chain which will be filled before
+ * the change takes place.
+ */
+static int tw68_s_fmt_vid_cap(struct file *file, void *priv,
+					struct v4l2_format *f)
+{
+	struct tw68_fh *fh = priv;
+	struct tw68_dev *dev = fh->dev;
+	int err;
+
+	dprintk(DBG_FLOW, "%s\n", __func__);
+	err = tw68_try_fmt_vid_cap(file, priv, f);
+	if (0 != err)
+		return err;
+
+	fh->fmt       = format_by_fourcc(f->fmt.pix.pixelformat);
+	fh->width     = f->fmt.pix.width;
+	fh->height    = f->fmt.pix.height;
+	fh->cap.field = f->fmt.pix.field;
+	/*
+	 * The following lines are to make v4l2-test program happy.
+	 * The docs should be checked to assure they make sense.
+	 */
+	f->fmt.pix.colorspace	= V4L2_COLORSPACE_SMPTE170M;
+	f->fmt.pix.priv = 0;
+	return 0;
+}
+
+static int tw68_queryctrl(struct file *file, void *priv,
+			  struct v4l2_queryctrl *c)
+{
+	const struct v4l2_queryctrl *ctrl;
+	struct tw68_fh *fh = priv;
+	struct tw68_dev *dev = fh->dev;
+
+	dprintk(DBG_FLOW, "%s\n", __func__);
+	if ((c->id <  V4L2_CID_BASE || c->id >= V4L2_CID_LASTP1)
+#if 0
+	     && (c->id <  V4L2_CID_PRIVATE_BASE ||
+	     c->id >= V4L2_CID_PRIVATE_LASTP1)
+#endif
+	)
+		return -EINVAL;
+	ctrl = ctrl_by_id(c->id);
+	if (NULL == ctrl)
+		return -EINVAL;
+	*c = *ctrl;
+	return 0;
+}
+
+static int tw68_enum_input(struct file *file, void *priv,
+					struct v4l2_input *i)
+{
+	struct tw68_fh *fh = priv;
+	struct tw68_dev *dev = fh->dev;
+	unsigned int n;
+
+	n = i->index;
+	dprintk(DBG_FLOW, "%s: index is %d\n", __func__, n);
+	if (n >= TW68_INPUT_MAX) {
+		dprintk(DBG_FLOW, "%s: INPUT_MAX reached\n", __func__);
+		return -EINVAL;
+	}
+	if (NULL == card_in(dev, n).name) {
+		dprintk(DBG_FLOW, "%s: End of list\n", __func__);
+		return -EINVAL;
+	}
+	memset(i, 0, sizeof(*i));
+	i->index = n;
+	i->type  = V4L2_INPUT_TYPE_CAMERA;
+	strcpy(i->name, card_in(dev, n).name);
+	if (card_in(dev, n).tv)
+		i->type = V4L2_INPUT_TYPE_TUNER;
+	i->audioset = 1;
+	/* If the query is for the current input, get live data */
+	if (n == dev->hw_input->vmux) {
+		int v1 = tw_readb(TW68_STATUS1);
+		int v2 = tw_readb(TW68_MVSN);
+
+		if (0 != (v1 & (1 << 7)))
+			i->status |= V4L2_IN_ST_NO_SYNC;
+		if (0 != (v1 & (1 << 6)))
+			i->status |= V4L2_IN_ST_NO_H_LOCK;
+		if (0 != (v1 & (1 << 2)))
+			i->status |= V4L2_IN_ST_NO_SIGNAL;
+		if (0 != (v1 & 1 << 1))
+			i->status |= V4L2_IN_ST_NO_COLOR;
+		if (0 != (v2 & (1 << 2)))
+			i->status |= V4L2_IN_ST_MACROVISION;
+	}
+	i->std = TW68_NORMS;
+	return 0;
+}
+
+static int tw68_g_input(struct file *file, void *priv, unsigned int *i)
+{
+	struct tw68_fh *fh = priv;
+	struct tw68_dev *dev = fh->dev;
+
+	dprintk(DBG_FLOW, "%s\n", __func__);
+	*i = dev->input->vmux;
+	return 0;
+}
+
+static int tw68_s_input(struct file *file, void *priv, unsigned int i)
+{
+	struct tw68_fh *fh = priv;
+	struct tw68_dev *dev = fh->dev;
+	int err;
+
+	dprintk(DBG_FLOW, "%s\n", __func__);
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,34)
+		err = v4l2_prio_check(&dev->prio, &fh->prio);
+#else
+		err = v4l2_prio_check(&dev->prio, fh->prio);
+#endif
+		if (0 != err)
+	if (0 != err)
+		return err;
+
+	if (i < 0  ||  i >= TW68_INPUT_MAX)
+		return -EINVAL;
+	if (NULL == card_in(dev, i).name)
+		return -EINVAL;
+	mutex_lock(&dev->lock);
+	video_mux(dev, i);
+	mutex_unlock(&dev->lock);
+	return 0;
+}
+
+static int tw68_querycap(struct file *file, void  *priv,
+					struct v4l2_capability *cap)
+{
+	struct tw68_fh *fh = priv;
+	struct tw68_dev *dev = fh->dev;
+
+	unsigned int tuner_type = dev->tuner_type;
+
+	dprintk(DBG_FLOW, "%s\n", __func__);
+	strcpy(cap->driver, "tw68");
+	strlcpy(cap->card, tw68_boards[dev->board].name,
+		sizeof(cap->card));
+	sprintf(cap->bus_info, "PCI:%s", pci_name(dev->pci));
+	cap->version = TW68_VERSION_CODE;
+	cap->capabilities =
+		V4L2_CAP_VIDEO_CAPTURE |
+		V4L2_CAP_VBI_CAPTURE |
+		V4L2_CAP_READWRITE |
+		V4L2_CAP_STREAMING |
+		V4L2_CAP_TUNER;
+
+	if ((tuner_type == TUNER_ABSENT) || (tuner_type == UNSET))
+		cap->capabilities &= ~V4L2_CAP_TUNER;
+	return 0;
+}
+
+static int tw68_s_std_internal(struct tw68_dev *dev, struct tw68_fh *fh,
+			v4l2_std_id *id)
+{
+/*	unsigned long flags; */
+	unsigned int i;
+	v4l2_std_id fixup;
+	int err;
+
+	dprintk(DBG_FLOW, "%s\n", __func__);
+	if (fh) {
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,34)
+		err = v4l2_prio_check(&dev->prio, &fh->prio);
+#else
+		err = v4l2_prio_check(&dev->prio, fh->prio);
+#endif
+		if (0 != err)
+		if (0 != err)
+			return err;
+	}
+
+	/* Look for match on complete norm id (may have mult bits) */
+	for (i = 0; i < TVNORMS; i++) {
+		if (*id == tvnorms[i].id)
+			break;
+	}
+
+	/* If no exact match, look for norm which contains this one */
+	if (i == TVNORMS)
+		for (i = 0; i < TVNORMS; i++) {
+			if (*id & tvnorms[i].id)
+				break;
+		}
+	/* If still not matched, give up */
+	if (i == TVNORMS)
+		return -EINVAL;
+
+	/* TODO - verify this additional work with SECAM applies to TW */
+	if ((*id & V4L2_STD_SECAM) && (secam[0] != '-')) {
+		if (secam[0] == 'L' || secam[0] == 'l') {
+			if (secam[1] == 'C' || secam[1] == 'c')
+				fixup = V4L2_STD_SECAM_LC;
+			else
+				fixup = V4L2_STD_SECAM_L;
+		} else {
+			if (secam[0] == 'D' || secam[0] == 'd')
+				fixup = V4L2_STD_SECAM_DK;
+			else
+				fixup = V4L2_STD_SECAM;
+		}
+		for (i = 0; i < TVNORMS; i++)
+			if (fixup == tvnorms[i].id)
+				break;
+	}
+
+	*id = tvnorms[i].id;
+	mutex_lock(&dev->lock);
+	set_tvnorm(dev, &tvnorms[i]);	/* do the actual setting */
+	tw68_tvaudio_do_scan(dev);
+	mutex_unlock(&dev->lock);
+	return 0;
+}
+
+static int tw68_s_std(struct file *file, void *priv, v4l2_std_id *id)
+{
+	struct tw68_fh *fh = priv;
+	struct tw68_dev *dev = fh->dev;
+
+	dprintk(DBG_FLOW, "%s\n", __func__);
+	return tw68_s_std_internal(fh->dev, fh, id);
+}
+
+static int tw68_g_std(struct file *file, void *priv, v4l2_std_id *id)
+{
+	struct tw68_fh *fh = priv;
+	struct tw68_dev *dev = fh->dev;
+
+	dprintk(DBG_FLOW, "%s\n", __func__);
+	*id = dev->tvnorm->id;
+	return 0;
+}
+
+static int tw68_g_tuner(struct file *file, void *priv,
+					struct v4l2_tuner *t)
+{
+	struct tw68_fh *fh = priv;
+	struct tw68_dev *dev = fh->dev;
+	int n;
+
+	if (unlikely(UNSET == dev->tuner_type))
+		return -EINVAL;
+	if (0 != t->index)
+		return -EINVAL;
+	memset(t, 0, sizeof(*t));
+	for (n = 0; n < TW68_INPUT_MAX; n++)
+		if (card_in(dev, n).tv)
+			break;
+	if (n == TW68_INPUT_MAX)
+		return -EINVAL;
+#if 0
+	if (NULL != card_in(dev, n).name) {
+		strcpy(t->name, "Television");
+		t->type = V4L2_TUNER_ANALOG_TV;
+		t->capability = V4L2_TUNER_CAP_NORM |
+			V4L2_TUNER_CAP_STEREO |
+			V4L2_TUNER_CAP_LANG1 |
+			V4L2_TUNER_CAP_LANG2;
+		t->rangehigh = 0xffffffffUL;
+		t->rxsubchans = tw68_tvaudio_getstereo(dev);
+		t->audmode = tw68_tvaudio_rx2mode(t->rxsubchans);
+	}
+	if (0 != (saa_readb(TW68_STATUS_VIDEO1) & 0x03))
+		t->signal = 0xffff;
+#endif
+	return 0;
+}
+
+static int tw68_s_tuner(struct file *file, void *priv,
+					struct v4l2_tuner *t)
+{
+	struct tw68_fh *fh = priv;
+	struct tw68_dev *dev = fh->dev;
+	int err;
+#if 0
+	int rx, mode
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,34)
+		err = v4l2_prio_check(&dev->prio, &fh->prio);
+#else
+		err = v4l2_prio_check(&dev->prio, fh->prio);
+#endif
+		if (0 != err)
+	if (0 != err)
+		return err;
+
+#if 0
+	mode = dev->thread.mode;
+	if (UNSET == mode) {
+		rx   = tw68_tvaudio_getstereo(dev);
+		mode = tw68_tvaudio_rx2mode(t->rxsubchans);
+	}
+	if (mode != t->audmode)
+		dev->thread.mode = t->audmode;
+#endif
+	return 0;
+}
+
+static int tw68_g_frequency(struct file *file, void *priv,
+					struct v4l2_frequency *f)
+{
+	struct tw68_fh *fh = priv;
+	struct tw68_dev *dev = fh->dev;
+
+	if (unlikely(dev->tuner_type))
+		return -EINVAL;
+	f->type = fh->radio ? V4L2_TUNER_RADIO : V4L2_TUNER_ANALOG_TV;
+/*	f->frequency = dev->ctl_freq; */
+
+	return 0;
+}
+
+static int tw68_s_frequency(struct file *file, void *priv,
+					struct v4l2_frequency *f)
+{
+	struct tw68_fh *fh = priv;
+	struct tw68_dev *dev = fh->dev;
+	int err;
+
+	if (unlikely(UNSET == dev->tuner_type))
+		return -EINVAL;
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,34)
+		err = v4l2_prio_check(&dev->prio, &fh->prio);
+#else
+		err = v4l2_prio_check(&dev->prio, fh->prio);
+#endif
+		if (0 != err)
+	if (0 != err)
+		return err;
+
+	if (0 != f->tuner)
+		return -EINVAL;
+	if (0 == fh->radio && V4L2_TUNER_ANALOG_TV != f->type)
+		return -EINVAL;
+	if (1 == fh->radio && V4L2_TUNER_RADIO != f->type)
+		return -EINVAL;
+	mutex_lock(&dev->lock);
+/*	dev->ctl_freq = f->frequency; */
+
+	tw_call_all(dev, tuner, s_frequency, f);
+
+	tw68_tvaudio_do_scan(dev);
+	mutex_unlock(&dev->lock);
+	return 0;
+}
+
+static int tw68_g_audio(struct file *file, void *priv, struct v4l2_audio *a)
+{
+	strcpy(a->name, "audio");
+	return 0;
+}
+
+static int tw68_s_audio(struct file *file, void *priv, struct v4l2_audio *a)
+{
+	return 0;
+}
+
+static int tw68_g_priority(struct file *file, void *f, enum v4l2_priority *p)
+{
+	struct tw68_fh *fh = f;
+	struct tw68_dev *dev = fh->dev;
+
+	dprintk(DBG_FLOW, "%s\n", __func__);
+	*p = v4l2_prio_max(&dev->prio);
+	return 0;
+}
+
+static int tw68_s_priority(struct file *file, void *f,
+					enum v4l2_priority prio)
+{
+	struct tw68_fh *fh = f;
+	struct tw68_dev *dev = fh->dev;
+
+	dprintk(DBG_FLOW, "%s\n", __func__);
+	return v4l2_prio_change(&dev->prio, &fh->prio, prio);
+}
+
+static int tw68_enum_fmt_vid_cap(struct file *file, void  *priv,
+					struct v4l2_fmtdesc *f)
+{
+	struct tw68_fh *fh = priv;
+	struct tw68_dev *dev = fh->dev;
+
+	dprintk(DBG_FLOW, "%s\n", __func__);
+	if (f->index >= FORMATS)
+		return -EINVAL;
+
+	strlcpy(f->description, formats[f->index].name,
+		sizeof(f->description));
+
+	f->pixelformat = formats[f->index].fourcc;
+
+	return 0;
+}
+
+static int tw68_cropcap(struct file *file, void *priv,
+					struct v4l2_cropcap *cap)
+{
+	struct tw68_fh *fh = priv;
+	struct tw68_dev *dev = fh->dev;
+
+	dprintk(DBG_FLOW, "%s\n", __func__);
+	if (cap->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;
+	cap->bounds  = dev->crop_bounds;
+	cap->defrect = dev->crop_defrect;
+	cap->pixelaspect.numerator   = 1;
+	cap->pixelaspect.denominator = 1;
+	if (dev->tvnorm->id & V4L2_STD_525_60) {
+		cap->pixelaspect.numerator   = 11;
+		cap->pixelaspect.denominator = 10;
+	}
+	if (dev->tvnorm->id & V4L2_STD_625_50) {
+		cap->pixelaspect.numerator   = 54;
+		cap->pixelaspect.denominator = 59;
+	}
+	return 0;
+}
+
+static int tw68_g_crop(struct file *file, void *f, struct v4l2_crop *crop)
+{
+	struct tw68_fh *fh = f;
+	struct tw68_dev *dev = fh->dev;
+
+	dprintk(DBG_FLOW, "%s\n", __func__);
+	if (crop->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;
+	crop->c = dev->crop_current;
+	return 0;
+}
+
+static int tw68_s_crop(struct file *file, void *f, struct v4l2_crop *crop)
+{
+	struct tw68_fh *fh = f;
+	struct tw68_dev *dev = fh->dev;
+	struct v4l2_rect *b = &dev->crop_bounds;
+
+	dprintk(DBG_FLOW, "%s\n", __func__);
+	if (res_locked(fh->dev, RESOURCE_VIDEO))
+		return -EBUSY;
+
+	if ((crop->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) ||
+	    (crop->c.height < 0) || (crop->c.width < 0)) {
+		dprintk(DBG_UNEXPECTED, "%s: invalid request\n", __func__);
+		return -EINVAL;
+	}
+
+	if (crop->c.top < b->top)
+		crop->c.top = b->top;
+	if (crop->c.top > b->top + b->height)
+		crop->c.top = b->top + b->height;
+	if (crop->c.height > b->top - crop->c.top + b->height)
+		crop->c.height = b->top - crop->c.top + b->height;
+
+	if (crop->c.left < b->left)
+		crop->c.left = b->left;
+	if (crop->c.left > b->left + b->width)
+		crop->c.left = b->left + b->width;
+	if (crop->c.width > b->left - crop->c.left + b->width)
+		crop->c.width = b->left - crop->c.left + b->width;
+
+	dprintk(DBG_FLOW, "%s: setting cropping rectangle: top=%d, left=%d, "
+		    "width=%d, height=%d\n", __func__, crop->c.top,
+		    crop->c.left, crop->c.width, crop->c.height);
+	dev->crop_current = crop->c;
+	return 0;
+}
+
+/*
+ * Wrappers for the v4l2_ioctl_ops functions
+ */
+#ifdef CONFIG_VIDEO_V4L1_COMPAT
+static int vidiocgmbuf(struct file *file, void *priv, struct video_mbuf *mbuf)
+{
+	struct tw68_fh *fh = file->private_data;
+	return videobuf_cgmbuf(tw68_queue(fh), mbuf, 8);
+}
+#endif
+
+static int tw68_reqbufs(struct file *file, void *priv,
+					struct v4l2_requestbuffers *p)
+{
+	struct tw68_fh *fh = priv;
+	return videobuf_reqbufs(tw68_queue(fh), p);
+}
+
+static int tw68_querybuf(struct file *file, void *priv,
+					struct v4l2_buffer *b)
+{
+	struct tw68_fh *fh = priv;
+	return videobuf_querybuf(tw68_queue(fh), b);
+}
+
+static int tw68_qbuf(struct file *file, void *priv, struct v4l2_buffer *b)
+{
+	struct tw68_fh *fh = priv;
+	return videobuf_qbuf(tw68_queue(fh), b);
+}
+
+static int tw68_dqbuf(struct file *file, void *priv, struct v4l2_buffer *b)
+{
+	struct tw68_fh *fh = priv;
+	return videobuf_dqbuf(tw68_queue(fh), b,
+				file->f_flags & O_NONBLOCK);
+}
+
+static int tw68_streamon(struct file *file, void *priv,
+					enum v4l2_buf_type type)
+{
+	struct tw68_fh *fh = priv;
+	struct tw68_dev *dev = fh->dev;
+	int res = tw68_resource(fh);
+
+	dprintk(DBG_FLOW, "%s\n", __func__);
+	if (!res_get(fh, res))
+		return -EBUSY;
+
+	tw68_buffer_requeue(dev, &dev->video_q);
+	return videobuf_streamon(tw68_queue(fh));
+}
+
+static int tw68_streamoff(struct file *file, void *priv,
+					enum v4l2_buf_type type)
+{
+	int err;
+	struct tw68_fh *fh = priv;
+	struct tw68_dev *dev = fh->dev;
+	int res = tw68_resource(fh);
+
+	dprintk(DBG_FLOW, "%s\n", __func__);
+	err = videobuf_streamoff(tw68_queue(fh));
+	if (err < 0)
+		return err;
+	res_free(fh, res);
+	return 0;
+}
+
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+/*
+ * Used strictly for internal development and debugging, this routine
+ * prints out the current register contents for the tw68xx device.
+ */
+static void tw68_dump_regs(struct tw68_dev *dev)
+{
+	unsigned char line[80];
+	int i, j, k;
+	unsigned char *cptr;
+
+	printk(KERN_DEBUG "Full dump of TW68 registers:\n");
+	/* First we do the PCI regs, 8 4-byte regs per line */
+	for (i = 0; i < 0x100; i += 32) {
+		cptr = line;
+		cptr += sprintf(cptr, "%03x  ", i);
+		/* j steps through the next 4 words */
+		for (j = i; j < i + 16; j += 4)
+			cptr += sprintf(cptr, "%08x ", tw_readl(j));
+		*cptr++ = ' ';
+		for (; j < i + 32; j += 4)
+			cptr += sprintf(cptr, "%08x ", tw_readl(j));
+		*cptr++ = '\n';
+		*cptr = 0;
+		printk(KERN_DEBUG "%s", line);
+	}
+	/* Next the control regs, which are single-byte, address mod 4 */
+	while (i < 0x400) {
+		cptr = line;
+		cptr += sprintf(cptr, "%03x ", i);
+		/* Print out 4 groups of 4 bytes */
+		for (j = 0; j < 4; j++) {
+			for (k = 0; k < 4; k++) {
+				cptr += sprintf(cptr, "%02x ",
+					tw_readb(i));
+				i += 4;
+			}
+			*cptr++ = ' ';
+		}
+		*cptr++ = '\n';
+		*cptr = 0;
+		printk(KERN_DEBUG "%s", line);
+	}
+}
+
+static int vidioc_log_status(struct file *file, void *priv)
+{
+	struct tw68_fh *fh = priv;
+	struct tw68_dev *dev = fh->dev;
+
+	tw68_dump_regs(dev);
+	return 0;
+}
+
+static int vidioc_g_register(struct file *file, void *priv,
+			      struct v4l2_dbg_register *reg)
+{
+	struct tw68_fh *fh = priv;
+	struct tw68_dev *dev = fh->dev;	/* needed for tw_readb */
+
+	dprintk(DBG_FLOW, "%s\n", __func__);
+	if (!v4l2_chip_match_host(&reg->match))
+		dprintk(DBG_UNEXPECTED, "%s: match failed\n", __func__);
+		return -EINVAL;
+	if (reg->size == 1)
+		reg->val = tw_readb(reg->reg);
+	else
+		reg->val = tw_readl(reg->reg);
+	return 0;
+}
+
+static int vidioc_s_register(struct file *file, void *priv,
+				struct v4l2_dbg_register *reg)
+{
+	struct tw68_fh *fh = priv;
+	struct tw68_dev *dev = fh->dev;	/* needed for tw_writeb */
+
+	dprintk(DBG_FLOW, "%s: request to set reg 0x%04x to 0x%02x\n",
+		__func__, (unsigned int)reg->reg, (unsigned int)reg->val);
+	if (!v4l2_chip_match_host(&reg->match)) {
+		dprintk(DBG_UNEXPECTED, "%s: match failed\n", __func__);
+		return -EINVAL;
+	}
+	if (reg->size == 1)
+		tw_writeb(reg->reg, reg->val);
+	else
+		tw_writel(reg->reg & 0xffff, reg->val);
+	return 0;
+}
+#endif
+
+static const struct v4l2_file_operations video_fops = {
+	.owner			= THIS_MODULE,
+	.open			= video_open,
+	.release		= video_release,
+	.read			= video_read,
+	.poll			= video_poll,
+	.mmap			= video_mmap,
+	.ioctl			= video_ioctl2,
+};
+
+static const struct v4l2_ioctl_ops video_ioctl_ops = {
+	.vidioc_querycap		= tw68_querycap,
+	.vidioc_enum_fmt_vid_cap	= tw68_enum_fmt_vid_cap,
+	.vidioc_reqbufs			= tw68_reqbufs,
+	.vidioc_querybuf		= tw68_querybuf,
+	.vidioc_qbuf			= tw68_qbuf,
+	.vidioc_dqbuf			= tw68_dqbuf,
+	.vidioc_s_std			= tw68_s_std,
+	.vidioc_g_std			= tw68_g_std,
+	.vidioc_enum_input		= tw68_enum_input,
+	.vidioc_g_input			= tw68_g_input,
+	.vidioc_s_input			= tw68_s_input,
+	.vidioc_queryctrl		= tw68_queryctrl,
+	.vidioc_g_ctrl			= tw68_g_ctrl,
+	.vidioc_s_ctrl			= tw68_s_ctrl,
+	.vidioc_streamon		= tw68_streamon,
+	.vidioc_streamoff		= tw68_streamoff,
+	.vidioc_g_priority		= tw68_g_priority,
+	.vidioc_s_priority		= tw68_s_priority,
+	.vidioc_g_fmt_vid_cap		= tw68_g_fmt_vid_cap,
+	.vidioc_try_fmt_vid_cap		= tw68_try_fmt_vid_cap,
+	.vidioc_s_fmt_vid_cap		= tw68_s_fmt_vid_cap,
+	.vidioc_cropcap			= tw68_cropcap,
+	.vidioc_g_crop			= tw68_g_crop,
+	.vidioc_s_crop			= tw68_s_crop,
+/*
+ * Functions not yet implemented / not yet passing tests.
+ */
+
+#if 0
+	.vidioc_g_fmt_vbi_cap		= tw68_try_get_set_fmt_vbi_cap,
+	.vidioc_try_fmt_vbi_cap		= tw68_try_get_set_fmt_vbi_cap,
+	.vidioc_s_fmt_vbi_cap		= tw68_try_get_set_fmt_vbi_cap,
+#endif
+	.vidioc_g_audio			= tw68_g_audio,
+	.vidioc_s_audio			= tw68_s_audio,
+	.vidioc_g_tuner			= tw68_g_tuner,
+	.vidioc_s_tuner			= tw68_s_tuner,
+	.vidioc_g_frequency		= tw68_g_frequency,
+	.vidioc_s_frequency		= tw68_s_frequency,
+#ifdef CONFIG_VIDEO_V4L1_COMPAT
+	.vidiocgmbuf			= vidiocgmbuf,
+#endif
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+	.vidioc_log_status		= vidioc_log_status,
+	.vidioc_g_register              = vidioc_g_register,
+	.vidioc_s_register              = vidioc_s_register,
+#endif
+};
+
+/* ------------------------------------------------------------------ */
+/* exported stuff                                                     */
+struct video_device tw68_video_template = {
+	.name			= "tw68_video",
+	.fops			= &video_fops,
+	.ioctl_ops		= &video_ioctl_ops,
+	.minor			= -1,
+	.tvnorms		= TW68_NORMS,
+	.current_norm		= V4L2_STD_PAL,
+};
+
+struct video_device tw68_radio_template = {
+	.name			= "tw68_radio",
+};
+
+int tw68_videoport_init(struct tw68_dev *dev)
+{
+	return 0;
+}
+
+void tw68_set_tvnorm_hw(struct tw68_dev *dev)
+{
+	tw_andorb(TW68_SDT, 0x07, dev->tvnorm->format);
+	return;
+}
+
+int tw68_video_init1(struct tw68_dev *dev)
+{
+	int i;
+
+	dprintk(DBG_FLOW, "%s\n", __func__);
+	/* sanitycheck insmod options */
+	if (gbuffers < 2 || gbuffers > VIDEO_MAX_FRAME)
+		gbuffers = 2;
+	if (gbufsz < 0 || gbufsz > gbufsz_max)
+		gbufsz = gbufsz_max;
+	gbufsz = (gbufsz + PAGE_SIZE - 1) & PAGE_MASK;
+
+	/* put some sensible defaults into the data structures ... */
+	for (i = 0; i < CTRLS; i++)
+		tw68_s_ctrl_value(dev, video_ctrls[i].id,
+				  video_ctrls[i].default_value);
+#if 0
+	if (dev->tda9887_conf && dev->ctl_automute)
+		dev->tda9887_conf |= TDA9887_AUTOMUTE;
+	dev->automute       = 0;
+#endif
+	INIT_LIST_HEAD(&dev->video_q.queued);
+	INIT_LIST_HEAD(&dev->video_q.active);
+	init_timer(&dev->video_q.timeout);
+	dev->video_q.timeout.function	= tw68_buffer_timeout;
+	dev->video_q.timeout.data	= (unsigned long)(&dev->video_q);
+	dev->video_q.dev		= dev;
+	dev->video_q.buf_compat		= tw68_check_video_fmt;
+	dev->video_q.start_dma		= tw68_video_start_dma;
+	tw68_risc_stopper(dev->pci, &dev->video_q.stopper);
+
+	if (tw68_boards[dev->board].video_out)
+		tw68_videoport_init(dev);
+
+	return 0;
+}
+
+int tw68_video_init2(struct tw68_dev *dev)
+{
+	dprintk(DBG_FLOW, "%s\n", __func__);
+	set_tvnorm(dev, &tvnorms[0]);
+	video_mux(dev, 0);
+/*
+	tw68_tvaudio_setmut(dev);
+	tw68_tvaudio_setvolume(dev, dev->ctl_volume);
+*/
+	return 0;
+}
+
+/*
+ * tw68_irq_video_signalchange
+ *
+ * TODO:
+ * Check for presence of video signal.  If not present, mute audio.
+ * If present, log type of signal present.
+ */
+void tw68_irq_video_signalchange(struct tw68_dev *dev)
+{
+	return;
+}
+
+/*
+ * tw68_irq_video_done
+ */
+void tw68_irq_video_done(struct tw68_dev *dev, unsigned long status)
+{
+	__u32 reg;
+
+	/* reset interrupts handled by this routine */
+	tw_writel(TW68_INTSTAT, status);
+	/*
+	 * Check most likely first
+	 *
+	 * DMAPI shows we have reached the end of the risc code
+	 * for the current buffer.
+	 */
+	if (status & TW68_DMAPI) {
+		struct tw68_dmaqueue *q = &dev->video_q;
+		dprintk(DBG_FLOW | DBG_TESTING, "DMAPI interrupt\n");
+		spin_lock(&dev->slock);
+		/*
+		 * tw68_wakeup will take care of the buffer handling,
+		 * plus any non-video requirements.
+		 */
+		tw68_wakeup(q, &dev->video_fieldcount);
+		spin_unlock(&dev->slock);
+		/* Check whether we have gotten into 'stopper' code */
+		reg = tw_readl(TW68_DMAP_PP);
+		if ((reg >= q->stopper.dma) &&
+		    (reg < q->stopper.dma + q->stopper.size)) {
+			/* Yes - log the information */
+			dprintk(DBG_FLOW | DBG_TESTING,
+				"%s: stopper risc code entered\n", __func__);
+		}
+		status &= ~(TW68_DMAPI);
+		if (0 == status)
+			return;
+	}
+	if (status & (TW68_VLOCK | TW68_HLOCK)) { /* lost sync */
+		dprintk(DBG_UNUSUAL, "Lost sync\n");
+	}
+	if (status & TW68_PABORT) {	/* TODO - what should we do? */
+		dprintk(DBG_UNEXPECTED, "PABORT interrupt\n");
+	}
+	if (status & TW68_DMAPERR) {
+		dprintk(DBG_UNEXPECTED, "DMAPERR interrupt\n");
+#if 0
+		/* Stop risc & fifo */
+		tw_clearl(TW68_DMAC, TW68_DMAP_EN | TW68_FIFO_EN);
+		tw_clearl(TW68_INTMASK, dev->board_virqmask);
+		dev->pci_irqmask &= ~dev->board_virqmask;
+#endif
+	}
+	/*
+	 * On TW6800, FDMIS is apparently generated if video input is switched
+	 * during operation.  Therefore, it is not enabled for that chip.
+	 */
+	if (status & TW68_FDMIS) {	/* logic error somewhere */
+		dprintk(DBG_UNEXPECTED, "FDMIS interrupt\n");
+		/* Stop risc & fifo */
+//		tw_clearl(TW68_DMAC, TW68_DMAP_EN | TW68_FIFO_EN);
+//		tw_clearl(TW68_INTMASK, dev->board_virqmask);
+//		dev->pci_irqmask &= ~dev->board_virqmask;
+	}
+	if (status & TW68_FFOF) {	/* probably a logic error */
+		reg = tw_readl(TW68_DMAC) & TW68_FIFO_EN;
+		tw_clearl(TW68_DMAC, TW68_FIFO_EN);
+		dprintk(DBG_UNUSUAL, "FFOF interrupt\n");
+		tw_setl(TW68_DMAC, reg);
+	}
+	if (status & TW68_FFERR)
+		dprintk(DBG_UNEXPECTED, "FFERR interrupt\n");
+	return;
+}
