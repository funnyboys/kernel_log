commit c942fddf8793b2013be8c901b47d0a8dc02bf99f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:06 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 157
    
    Based on 3 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [kishon] [vijay] [abraham]
      [i] [kishon]@[ti] [com] this program is distributed in the hope that
      it will be useful but without any warranty without even the implied
      warranty of merchantability or fitness for a particular purpose see
      the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [graeme] [gregory]
      [gg]@[slimlogic] [co] [uk] [author] [kishon] [vijay] [abraham] [i]
      [kishon]@[ti] [com] [based] [on] [twl6030]_[usb] [c] [author] [hema]
      [hk] [hemahk]@[ti] [com] this program is distributed in the hope
      that it will be useful but without any warranty without even the
      implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1105 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.202006027@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/media/pci/cx88/cx88-mpeg.c b/drivers/media/pci/cx88/cx88-mpeg.c
index 52ff00ebd4bd..a57c991b165b 100644
--- a/drivers/media/pci/cx88/cx88-mpeg.c
+++ b/drivers/media/pci/cx88/cx88-mpeg.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *
  *  Support for the mpeg transport stream transfers
@@ -6,16 +7,6 @@
  *    (c) 2004 Jelle Foks <jelle@foks.us>
  *    (c) 2004 Chris Pascoe <c.pascoe@itee.uq.edu.au>
  *    (c) 2004 Gerd Knorr <kraxel@bytesex.org>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
  */
 
 #include "cx88.h"

commit 399426cadf5b0539a5b2a4d805257ce8acc6aba2
Author: Mauro Carvalho Chehab <mchehab@s-opensource.com>
Date:   Sat Nov 19 19:27:30 2016 -0200

    [media] cx88: make checkpatch.pl happy
    
    Usually, I don't like fixing coding style issues on non-staging
    drivers, as it could be a mess pretty easy, and could become like
    a snow ball. That's the case of recent changes on two changesets:
    they disalign some statements. Yet, a care a lot with cx88 driver,
    as it was the first driver I touched at the Kernel, and I've been
    maintaining it since 2005. So, several of the coding style issues
    were due to my code.
    
    Per Andrey's suggestion, I ran checkpatch.pl in strict mode, with
    fixed several other issues, did some function alinments, but broke
    other alinments.
    
    So, I had to manually apply another round of manual fixes to make
    sure that everything is ok, and to make checkpatch happy with
    this patch.
    
    With this patch, checkpatch.pl is now happy when called with:
            ./scripts/checkpatch.pl -f --max-line-length=998 --ignore PREFER_PR_LEVEL
    
    Also, the 80-cols violations that made sense were fixed.
    
    Checkpatch would be happier if we convert it to use dev_foo(),
    but this is a more complex change.
    
    NOTE: there are some places with msleep(1). As this driver was
    written at the time that the default was to sleep at least 10ms
    on such calls (e. g. CONFIG_HZ=100), I replaced those calls by
    usleep_range(10000, 20000), with should be safe to avoid breakages.
    
    Fixes: 65bc2fe86e66 ("[media] cx88: convert it to use pr_foo() macros")
    Fixes: 7b61ba8ff838 ("[media] cx88: make checkpatch happier")
    
    Suggested-by: Andrey Utkin <andrey_utkin@fastmail.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>
    Reviewed-by: Andrey Utkin <andrey_utkin@fastmail.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/pci/cx88/cx88-mpeg.c b/drivers/media/pci/cx88/cx88-mpeg.c
index 4533e2c6cb9f..52ff00ebd4bd 100644
--- a/drivers/media/pci/cx88/cx88-mpeg.c
+++ b/drivers/media/pci/cx88/cx88-mpeg.c
@@ -16,10 +16,6 @@
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
 #include "cx88.h"
@@ -30,7 +26,7 @@
 #include <linux/device.h>
 #include <linux/dma-mapping.h>
 #include <linux/interrupt.h>
-#include <asm/delay.h>
+#include <linux/delay.h>
 
 /* ------------------------------------------------------------------ */
 
@@ -54,7 +50,8 @@ MODULE_PARM_DESC(debug, "enable debug messages [mpeg]");
 #if defined(CONFIG_MODULES) && defined(MODULE)
 static void request_module_async(struct work_struct *work)
 {
-	struct cx8802_dev *dev = container_of(work, struct cx8802_dev, request_module_wk);
+	struct cx8802_dev *dev = container_of(work, struct cx8802_dev,
+					      request_module_wk);
 
 	if (dev->core->board.mpeg & CX88_MPEG_DVB)
 		request_module("cx88-dvb");
@@ -77,14 +74,13 @@ static void flush_request_modules(struct cx8802_dev *dev)
 #define flush_request_modules(dev)
 #endif /* CONFIG_MODULES */
 
-
 static LIST_HEAD(cx8802_devlist);
 static DEFINE_MUTEX(cx8802_mutex);
 /* ------------------------------------------------------------------ */
 
 int cx8802_start_dma(struct cx8802_dev    *dev,
-			    struct cx88_dmaqueue *q,
-			    struct cx88_buffer   *buf)
+		     struct cx88_dmaqueue *q,
+		     struct cx88_buffer   *buf)
 {
 	struct cx88_core *core = dev->core;
 
@@ -98,33 +94,35 @@ int cx8802_start_dma(struct cx8802_dev    *dev,
 	/* write TS length to chip */
 	cx_write(MO_TS_LNGTH, dev->ts_packet_size);
 
-	/* FIXME: this needs a review.
-	 * also: move to cx88-blackbird + cx88-dvb source files? */
+	/*
+	 * FIXME: this needs a review.
+	 * also: move to cx88-blackbird + cx88-dvb source files?
+	 */
 
 	dprintk(1, "core->active_type_id = 0x%08x\n", core->active_type_id);
 
 	if ((core->active_type_id == CX88_MPEG_DVB) &&
-		(core->board.mpeg & CX88_MPEG_DVB)) {
-
+	    (core->board.mpeg & CX88_MPEG_DVB)) {
 		dprintk(1, "cx8802_start_dma doing .dvb\n");
 		/* negedge driven & software reset */
 		cx_write(TS_GEN_CNTRL, 0x0040 | dev->ts_gen_cntrl);
 		udelay(100);
 		cx_write(MO_PINMUX_IO, 0x00);
-		cx_write(TS_HW_SOP_CNTRL, 0x47<<16|188<<4|0x01);
+		cx_write(TS_HW_SOP_CNTRL, 0x47 << 16 | 188 << 4 | 0x01);
 		switch (core->boardnr) {
 		case CX88_BOARD_DVICO_FUSIONHDTV_3_GOLD_Q:
 		case CX88_BOARD_DVICO_FUSIONHDTV_3_GOLD_T:
 		case CX88_BOARD_DVICO_FUSIONHDTV_5_GOLD:
 		case CX88_BOARD_PCHDTV_HD5500:
-			cx_write(TS_SOP_STAT, 1<<13);
+			cx_write(TS_SOP_STAT, 1 << 13);
 			break;
 		case CX88_BOARD_SAMSUNG_SMT_7020:
 			cx_write(TS_SOP_STAT, 0x00);
 			break;
 		case CX88_BOARD_HAUPPAUGE_NOVASPLUS_S1:
 		case CX88_BOARD_HAUPPAUGE_NOVASE2_S1:
-			cx_write(MO_PINMUX_IO, 0x88); /* Enable MPEG parallel IO and video signal pins */
+			/* Enable MPEG parallel IO and video signal pins */
+			cx_write(MO_PINMUX_IO, 0x88);
 			udelay(100);
 			break;
 		case CX88_BOARD_HAUPPAUGE_HVR1300:
@@ -153,13 +151,15 @@ int cx8802_start_dma(struct cx8802_dev    *dev,
 		dprintk(1, "cx8802_start_dma doing .blackbird\n");
 		cx_write(MO_PINMUX_IO, 0x88); /* enable MPEG parallel IO */
 
-		cx_write(TS_GEN_CNTRL, 0x46); /* punctured clock TS & posedge driven & software reset */
+		/* punctured clock TS & posedge driven & software reset */
+		cx_write(TS_GEN_CNTRL, 0x46);
 		udelay(100);
 
 		cx_write(TS_HW_SOP_CNTRL, 0x408); /* mpeg start byte */
 		cx_write(TS_VALERR_CNTRL, 0x2000);
 
-		cx_write(TS_GEN_CNTRL, 0x06); /* punctured clock TS & posedge driven */
+		/* punctured clock TS & posedge driven */
+		cx_write(TS_GEN_CNTRL, 0x06);
 		udelay(100);
 	} else {
 		pr_err("%s() Failed. Unsupported value in .mpeg (0x%08x)\n",
@@ -177,10 +177,11 @@ int cx8802_start_dma(struct cx8802_dev    *dev,
 	cx_set(MO_TS_INTMSK,  0x1f0011);
 
 	/* start dma */
-	cx_set(MO_DEV_CNTRL2, (1<<5));
+	cx_set(MO_DEV_CNTRL2, (1 << 5));
 	cx_set(MO_TS_DMACNTRL, 0x11);
 	return 0;
 }
+EXPORT_SYMBOL(cx8802_start_dma);
 
 static int cx8802_stop_dma(struct cx8802_dev *dev)
 {
@@ -219,7 +220,7 @@ static int cx8802_restart_queue(struct cx8802_dev    *dev,
 /* ------------------------------------------------------------------ */
 
 int cx8802_buf_prepare(struct vb2_queue *q, struct cx8802_dev *dev,
-			struct cx88_buffer *buf)
+		       struct cx88_buffer *buf)
 {
 	int size = dev->ts_packet_size * dev->ts_packet_count;
 	struct sg_table *sgt = vb2_dma_sg_plane_desc(&buf->vb.vb2_buf, 0);
@@ -231,15 +232,17 @@ int cx8802_buf_prepare(struct vb2_queue *q, struct cx8802_dev *dev,
 	vb2_set_plane_payload(&buf->vb.vb2_buf, 0, size);
 
 	rc = cx88_risc_databuffer(dev->pci, risc, sgt->sgl,
-			     dev->ts_packet_size, dev->ts_packet_count, 0);
+				  dev->ts_packet_size, dev->ts_packet_count, 0);
 	if (rc) {
 		if (risc->cpu)
-			pci_free_consistent(dev->pci, risc->size, risc->cpu, risc->dma);
+			pci_free_consistent(dev->pci, risc->size,
+					    risc->cpu, risc->dma);
 		memset(risc, 0, sizeof(*risc));
 		return rc;
 	}
 	return 0;
 }
+EXPORT_SYMBOL(cx8802_buf_prepare);
 
 void cx8802_buf_queue(struct cx8802_dev *dev, struct cx88_buffer *buf)
 {
@@ -268,6 +271,7 @@ void cx8802_buf_queue(struct cx8802_dev *dev, struct cx88_buffer *buf)
 			buf, buf->vb.vb2_buf.index, __func__);
 	}
 }
+EXPORT_SYMBOL(cx8802_buf_queue);
 
 /* ----------------------------------------------------------- */
 
@@ -292,6 +296,7 @@ void cx8802_cancel_buffers(struct cx8802_dev *dev)
 	cx8802_stop_dma(dev);
 	do_cancel_buffers(dev);
 }
+EXPORT_SYMBOL(cx8802_cancel_buffers);
 
 static const char *cx88_mpeg_irqs[32] = {
 	"ts_risci1", NULL, NULL, NULL,
@@ -324,7 +329,8 @@ static void cx8802_mpeg_irq(struct cx8802_dev *dev)
 	if (status & (1 << 16)) {
 		pr_warn("mpeg risc op code error\n");
 		cx_clear(MO_TS_DMACNTRL, 0x11);
-		cx88_sram_channel_dump(dev->core, &cx88_sram_channels[SRAM_CH28]);
+		cx88_sram_channel_dump(dev->core,
+				       &cx88_sram_channels[SRAM_CH28]);
 	}
 
 	/* risc1 y */
@@ -452,7 +458,8 @@ static int cx8802_suspend_common(struct pci_dev *pci_dev, pm_message_t state)
 	cx88_shutdown(dev->core);
 
 	pci_save_state(pci_dev);
-	if (pci_set_power_state(pci_dev, pci_choose_state(pci_dev, state)) != 0) {
+	if (pci_set_power_state(pci_dev,
+				pci_choose_state(pci_dev, state)) != 0) {
 		pci_disable_device(pci_dev);
 		dev->state.disabled = 1;
 	}
@@ -497,7 +504,8 @@ static int cx8802_resume_common(struct pci_dev *pci_dev)
 	return 0;
 }
 
-struct cx8802_driver *cx8802_get_driver(struct cx8802_dev *dev, enum cx88_board_type btype)
+struct cx8802_driver *cx8802_get_driver(struct cx8802_dev *dev,
+					enum cx88_board_type btype)
 {
 	struct cx8802_driver *d;
 
@@ -507,6 +515,7 @@ struct cx8802_driver *cx8802_get_driver(struct cx8802_dev *dev, enum cx88_board_
 
 	return NULL;
 }
+EXPORT_SYMBOL(cx8802_get_driver);
 
 /* Driver asked for hardware access. */
 static int cx8802_request_acquire(struct cx8802_driver *drv)
@@ -524,7 +533,8 @@ static int cx8802_request_acquire(struct cx8802_driver *drv)
 		core->last_analog_input = core->input;
 		core->input = 0;
 		for (i = 0;
-		     i < (sizeof(core->board.input) / sizeof(struct cx88_input));
+		     i < (sizeof(core->board.input) /
+			  sizeof(struct cx88_input));
 		     i++) {
 			if (core->board.input[i].type == CX88_VMUX_DVB) {
 				core->input = i;
@@ -533,8 +543,7 @@ static int cx8802_request_acquire(struct cx8802_driver *drv)
 		}
 	}
 
-	if (drv->advise_acquire)
-	{
+	if (drv->advise_acquire) {
 		core->active_ref++;
 		if (core->active_type_id == CX88_BOARD_NONE) {
 			core->active_type_id = drv->type_id;
@@ -552,11 +561,12 @@ static int cx8802_request_release(struct cx8802_driver *drv)
 {
 	struct cx88_core *core = drv->core;
 
-	if (drv->advise_release && --core->active_ref == 0)
-	{
+	if (drv->advise_release && --core->active_ref == 0) {
 		if (drv->type_id == CX88_MPEG_DVB) {
-			/* If the DVB driver is releasing, reset the input
-			   state to the last configured analog input */
+			/*
+			 * If the DVB driver is releasing, reset the input
+			 * state to the last configured analog input
+			 */
 			core->input = core->last_analog_input;
 		}
 
@@ -570,21 +580,21 @@ static int cx8802_request_release(struct cx8802_driver *drv)
 
 static int cx8802_check_driver(struct cx8802_driver *drv)
 {
-	if (drv == NULL)
+	if (!drv)
 		return -ENODEV;
 
 	if ((drv->type_id != CX88_MPEG_DVB) &&
-		(drv->type_id != CX88_MPEG_BLACKBIRD))
+	    (drv->type_id != CX88_MPEG_BLACKBIRD))
 		return -EINVAL;
 
 	if ((drv->hw_access != CX8802_DRVCTL_SHARED) &&
-		(drv->hw_access != CX8802_DRVCTL_EXCLUSIVE))
+	    (drv->hw_access != CX8802_DRVCTL_EXCLUSIVE))
 		return -EINVAL;
 
-	if ((drv->probe == NULL) ||
-		(drv->remove == NULL) ||
-		(drv->advise_acquire == NULL) ||
-		(drv->advise_release == NULL))
+	if ((!drv->probe) ||
+	    (!drv->remove) ||
+	    (!drv->advise_acquire) ||
+	    (!drv->advise_release))
 		return -EINVAL;
 
 	return 0;
@@ -598,9 +608,11 @@ int cx8802_register_driver(struct cx8802_driver *drv)
 
 	pr_info("registering cx8802 driver, type: %s access: %s\n",
 		drv->type_id == CX88_MPEG_DVB ? "dvb" : "blackbird",
-		drv->hw_access == CX8802_DRVCTL_SHARED ? "shared" : "exclusive");
+		drv->hw_access == CX8802_DRVCTL_SHARED ?
+				  "shared" : "exclusive");
 
-	if ((err = cx8802_check_driver(drv)) != 0) {
+	err = cx8802_check_driver(drv);
+	if (err) {
 		pr_err("cx8802_driver is invalid\n");
 		return err;
 	}
@@ -615,7 +627,7 @@ int cx8802_register_driver(struct cx8802_driver *drv)
 
 		/* Bring up a new struct for each driver instance */
 		driver = kzalloc(sizeof(*drv), GFP_KERNEL);
-		if (driver == NULL) {
+		if (!driver) {
 			err = -ENOMEM;
 			goto out;
 		}
@@ -644,6 +656,7 @@ int cx8802_register_driver(struct cx8802_driver *drv)
 	mutex_unlock(&cx8802_mutex);
 	return err;
 }
+EXPORT_SYMBOL(cx8802_register_driver);
 
 int cx8802_unregister_driver(struct cx8802_driver *drv)
 {
@@ -653,7 +666,8 @@ int cx8802_unregister_driver(struct cx8802_driver *drv)
 
 	pr_info("unregistering cx8802 driver, type: %s access: %s\n",
 		drv->type_id == CX88_MPEG_DVB ? "dvb" : "blackbird",
-		drv->hw_access == CX8802_DRVCTL_SHARED ? "shared" : "exclusive");
+		drv->hw_access == CX8802_DRVCTL_SHARED ?
+				  "shared" : "exclusive");
 
 	mutex_lock(&cx8802_mutex);
 
@@ -686,6 +700,7 @@ int cx8802_unregister_driver(struct cx8802_driver *drv)
 
 	return err;
 }
+EXPORT_SYMBOL(cx8802_unregister_driver);
 
 /* ----------------------------------------------------------- */
 static int cx8802_probe(struct pci_dev *pci_dev,
@@ -697,7 +712,7 @@ static int cx8802_probe(struct pci_dev *pci_dev,
 
 	/* general setup */
 	core = cx88_core_get(pci_dev);
-	if (core == NULL)
+	if (!core)
 		return -EINVAL;
 
 	pr_info("cx2388x 8802 Driver Manager\n");
@@ -708,7 +723,7 @@ static int cx8802_probe(struct pci_dev *pci_dev,
 
 	err = -ENOMEM;
 	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
-	if (dev == NULL)
+	if (!dev)
 		goto fail_core;
 	dev->pci = pci_dev;
 	dev->core = core;
@@ -797,12 +812,3 @@ static struct pci_driver cx8802_pci_driver = {
 };
 
 module_pci_driver(cx8802_pci_driver);
-
-EXPORT_SYMBOL(cx8802_buf_prepare);
-EXPORT_SYMBOL(cx8802_buf_queue);
-EXPORT_SYMBOL(cx8802_cancel_buffers);
-EXPORT_SYMBOL(cx8802_start_dma);
-
-EXPORT_SYMBOL(cx8802_register_driver);
-EXPORT_SYMBOL(cx8802_unregister_driver);
-EXPORT_SYMBOL(cx8802_get_driver);

commit 7b61ba8ff838dbee422d428fbd882ab83db4b2d9
Author: Mauro Carvalho Chehab <mchehab@s-opensource.com>
Date:   Wed Nov 16 06:59:49 2016 -0200

    [media] cx88: make checkpatch happier
    
    This driver is old, and have lots of checkpatch violations.
    As we're touching a lot on this driver due to the printk
    conversions, let's run checkpatch --fix on it, in order to
    solve some of those issues.
    
    Also, do a few manual adjustments:
    - remove the FSF address and use the usual coding style
      for the initial comments;
    - use WARN_ON() instead of BUG_ON();
    - remove an unused typedef;
    - break a few long lines.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/pci/cx88/cx88-mpeg.c b/drivers/media/pci/cx88/cx88-mpeg.c
index ed3fcc8149bd..4533e2c6cb9f 100644
--- a/drivers/media/pci/cx88/cx88-mpeg.c
+++ b/drivers/media/pci/cx88/cx88-mpeg.c
@@ -42,8 +42,8 @@ MODULE_LICENSE("GPL");
 MODULE_VERSION(CX88_VERSION);
 
 static unsigned int debug;
-module_param(debug,int,0644);
-MODULE_PARM_DESC(debug,"enable debug messages [mpeg]");
+module_param(debug, int, 0644);
+MODULE_PARM_DESC(debug, "enable debug messages [mpeg]");
 
 #define dprintk(level, fmt, arg...) do {				\
 	if (debug + 1 > level)						\
@@ -54,7 +54,7 @@ MODULE_PARM_DESC(debug,"enable debug messages [mpeg]");
 #if defined(CONFIG_MODULES) && defined(MODULE)
 static void request_module_async(struct work_struct *work)
 {
-	struct cx8802_dev *dev=container_of(work, struct cx8802_dev, request_module_wk);
+	struct cx8802_dev *dev = container_of(work, struct cx8802_dev, request_module_wk);
 
 	if (dev->core->board.mpeg & CX88_MPEG_DVB)
 		request_module("cx88-dvb");
@@ -103,8 +103,8 @@ int cx8802_start_dma(struct cx8802_dev    *dev,
 
 	dprintk(1, "core->active_type_id = 0x%08x\n", core->active_type_id);
 
-	if ( (core->active_type_id == CX88_MPEG_DVB) &&
-		(core->board.mpeg & CX88_MPEG_DVB) ) {
+	if ((core->active_type_id == CX88_MPEG_DVB) &&
+		(core->board.mpeg & CX88_MPEG_DVB)) {
 
 		dprintk(1, "cx8802_start_dma doing .dvb\n");
 		/* negedge driven & software reset */
@@ -148,8 +148,8 @@ int cx8802_start_dma(struct cx8802_dev    *dev,
 		}
 		cx_write(TS_GEN_CNTRL, dev->ts_gen_cntrl);
 		udelay(100);
-	} else if ( (core->active_type_id == CX88_MPEG_BLACKBIRD) &&
-		(core->board.mpeg & CX88_MPEG_BLACKBIRD) ) {
+	} else if ((core->active_type_id == CX88_MPEG_BLACKBIRD) &&
+		(core->board.mpeg & CX88_MPEG_BLACKBIRD)) {
 		dprintk(1, "cx8802_start_dma doing .blackbird\n");
 		cx_write(MO_PINMUX_IO, 0x88); /* enable MPEG parallel IO */
 
@@ -185,6 +185,7 @@ int cx8802_start_dma(struct cx8802_dev    *dev,
 static int cx8802_stop_dma(struct cx8802_dev *dev)
 {
 	struct cx88_core *core = dev->core;
+
 	dprintk(1, "\n");
 
 	/* stop dma */
@@ -209,7 +210,7 @@ static int cx8802_restart_queue(struct cx8802_dev    *dev,
 		return 0;
 
 	buf = list_entry(q->active.next, struct cx88_buffer, list);
-	dprintk(2,"restart_queue [%p/%d]: restart dma\n",
+	dprintk(2, "restart_queue [%p/%d]: restart dma\n",
 		buf, buf->vb.vb2_buf.index);
 	cx8802_start_dma(dev, q, buf);
 	return 0;
@@ -254,7 +255,7 @@ void cx8802_buf_queue(struct cx8802_dev *dev, struct cx88_buffer *buf)
 	if (list_empty(&cx88q->active)) {
 		dprintk(1, "queue is empty - first active\n");
 		list_add_tail(&buf->list, &cx88q->active);
-		dprintk(1,"[%p/%d] %s - first active\n",
+		dprintk(1, "[%p/%d] %s - first active\n",
 			buf, buf->vb.vb2_buf.index, __func__);
 
 	} else {
@@ -276,13 +277,13 @@ static void do_cancel_buffers(struct cx8802_dev *dev)
 	struct cx88_buffer *buf;
 	unsigned long flags;
 
-	spin_lock_irqsave(&dev->slock,flags);
+	spin_lock_irqsave(&dev->slock, flags);
 	while (!list_empty(&q->active)) {
 		buf = list_entry(q->active.next, struct cx88_buffer, list);
 		list_del(&buf->list);
 		vb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);
 	}
-	spin_unlock_irqrestore(&dev->slock,flags);
+	spin_unlock_irqrestore(&dev->slock, flags);
 }
 
 void cx8802_cancel_buffers(struct cx8802_dev *dev)
@@ -292,7 +293,7 @@ void cx8802_cancel_buffers(struct cx8802_dev *dev)
 	do_cancel_buffers(dev);
 }
 
-static const char * cx88_mpeg_irqs[32] = {
+static const char *cx88_mpeg_irqs[32] = {
 	"ts_risci1", NULL, NULL, NULL,
 	"ts_risci2", NULL, NULL, NULL,
 	"ts_oflow",  NULL, NULL, NULL,
@@ -356,7 +357,7 @@ static irqreturn_t cx8802_irq(int irq, void *dev_id)
 	for (loop = 0; loop < MAX_IRQ_LOOP; loop++) {
 		status = cx_read(MO_PCI_INTSTAT) &
 			(core->pci_irqmask | PCI_INT_TSINT);
-		if (0 == status)
+		if (status == 0)
 			goto out;
 		dprintk(1, "cx8802_irq\n");
 		dprintk(1, "    loop: %d/%d\n", loop, MAX_IRQ_LOOP);
@@ -365,14 +366,14 @@ static irqreturn_t cx8802_irq(int irq, void *dev_id)
 		cx_write(MO_PCI_INTSTAT, status);
 
 		if (status & core->pci_irqmask)
-			cx88_core_irq(core,status);
+			cx88_core_irq(core, status);
 		if (status & PCI_INT_TSINT)
 			cx8802_mpeg_irq(dev);
 	}
-	if (MAX_IRQ_LOOP == loop) {
+	if (loop == MAX_IRQ_LOOP) {
 		dprintk(0, "clearing mask\n");
 		pr_warn("irq loop -- clearing mask\n");
-		cx_write(MO_PCI_INTMSK,0);
+		cx_write(MO_PCI_INTMSK, 0);
 	}
 
  out:
@@ -388,7 +389,7 @@ static int cx8802_init_common(struct cx8802_dev *dev)
 	if (pci_enable_device(dev->pci))
 		return -EIO;
 	pci_set_master(dev->pci);
-	err = pci_set_dma_mask(dev->pci,DMA_BIT_MASK(32));
+	err = pci_set_dma_mask(dev->pci, DMA_BIT_MASK(32));
 	if (err) {
 		pr_err("Oops: no 32bit PCI DMA ???\n");
 		return -EIO;
@@ -417,7 +418,7 @@ static int cx8802_init_common(struct cx8802_dev *dev)
 	cx_set(MO_PCI_INTMSK, core->pci_irqmask);
 
 	/* everything worked */
-	pci_set_drvdata(dev->pci,dev);
+	pci_set_drvdata(dev->pci, dev);
 	return 0;
 }
 
@@ -451,7 +452,7 @@ static int cx8802_suspend_common(struct pci_dev *pci_dev, pm_message_t state)
 	cx88_shutdown(dev->core);
 
 	pci_save_state(pci_dev);
-	if (0 != pci_set_power_state(pci_dev, pci_choose_state(pci_dev, state))) {
+	if (pci_set_power_state(pci_dev, pci_choose_state(pci_dev, state)) != 0) {
 		pci_disable_device(pci_dev);
 		dev->state.disabled = 1;
 	}
@@ -465,14 +466,14 @@ static int cx8802_resume_common(struct pci_dev *pci_dev)
 	int err;
 
 	if (dev->state.disabled) {
-		err=pci_enable_device(pci_dev);
+		err = pci_enable_device(pci_dev);
 		if (err) {
 			pr_err("can't enable device\n");
 			return err;
 		}
 		dev->state.disabled = 0;
 	}
-	err=pci_set_power_state(pci_dev, PCI_D0);
+	err = pci_set_power_state(pci_dev, PCI_D0);
 	if (err) {
 		pr_err("can't enable device\n");
 		pci_disable_device(pci_dev);
@@ -489,14 +490,14 @@ static int cx8802_resume_common(struct pci_dev *pci_dev)
 	spin_lock_irqsave(&dev->slock, flags);
 	if (!list_empty(&dev->mpegq.active)) {
 		pr_info("resume mpeg\n");
-		cx8802_restart_queue(dev,&dev->mpegq);
+		cx8802_restart_queue(dev, &dev->mpegq);
 	}
 	spin_unlock_irqrestore(&dev->slock, flags);
 
 	return 0;
 }
 
-struct cx8802_driver * cx8802_get_driver(struct cx8802_dev *dev, enum cx88_board_type btype)
+struct cx8802_driver *cx8802_get_driver(struct cx8802_dev *dev, enum cx88_board_type btype)
 {
 	struct cx8802_driver *d;
 
@@ -613,7 +614,7 @@ int cx8802_register_driver(struct cx8802_driver *drv)
 			dev->core->boardnr);
 
 		/* Bring up a new struct for each driver instance */
-		driver = kzalloc(sizeof(*drv),GFP_KERNEL);
+		driver = kzalloc(sizeof(*drv), GFP_KERNEL);
 		if (driver == NULL) {
 			err = -ENOMEM;
 			goto out;
@@ -696,7 +697,7 @@ static int cx8802_probe(struct pci_dev *pci_dev,
 
 	/* general setup */
 	core = cx88_core_get(pci_dev);
-	if (NULL == core)
+	if (core == NULL)
 		return -EINVAL;
 
 	pr_info("cx2388x 8802 Driver Manager\n");
@@ -706,8 +707,8 @@ static int cx8802_probe(struct pci_dev *pci_dev,
 		goto fail_core;
 
 	err = -ENOMEM;
-	dev = kzalloc(sizeof(*dev),GFP_KERNEL);
-	if (NULL == dev)
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (dev == NULL)
 		goto fail_core;
 	dev->pci = pci_dev;
 	dev->core = core;
@@ -721,7 +722,7 @@ static int cx8802_probe(struct pci_dev *pci_dev,
 
 	INIT_LIST_HEAD(&dev->drvlist);
 	mutex_lock(&cx8802_mutex);
-	list_add_tail(&dev->devlist,&cx8802_devlist);
+	list_add_tail(&dev->devlist, &cx8802_devlist);
 	mutex_unlock(&cx8802_mutex);
 
 	/* now autoload cx88-dvb or cx88-blackbird */
@@ -732,7 +733,7 @@ static int cx8802_probe(struct pci_dev *pci_dev,
 	kfree(dev);
  fail_core:
 	core->dvbdev = NULL;
-	cx88_core_put(core,pci_dev);
+	cx88_core_put(core, pci_dev);
 	return err;
 }
 
@@ -772,7 +773,7 @@ static void cx8802_remove(struct pci_dev *pci_dev)
 
 	/* common */
 	cx8802_fini_common(dev);
-	cx88_core_put(dev->core,dev->pci);
+	cx88_core_put(dev->core, dev->pci);
 	kfree(dev);
 }
 
@@ -782,7 +783,7 @@ static const struct pci_device_id cx8802_pci_tbl[] = {
 		.device       = 0x8802,
 		.subvendor    = PCI_ANY_ID,
 		.subdevice    = PCI_ANY_ID,
-	},{
+	}, {
 		/* --- end of list --- */
 	}
 };

commit 65bc2fe86e667077b38a63ce6cb40677be09bc4f
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Sun Nov 13 10:07:38 2016 -0200

    [media] cx88: convert it to use pr_foo() macros
    
    Instead of calling printk() directly, use pr_foo()
    macros, as suggested at the Kernel's coding style.
    
    Please notice that a conversion to dev_foo() is not trivial,
    as several parts on this driver uses pr_cont().
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/pci/cx88/cx88-mpeg.c b/drivers/media/pci/cx88/cx88-mpeg.c
index 86b46b62d985..ed3fcc8149bd 100644
--- a/drivers/media/pci/cx88/cx88-mpeg.c
+++ b/drivers/media/pci/cx88/cx88-mpeg.c
@@ -22,6 +22,8 @@
  *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
+#include "cx88.h"
+
 #include <linux/module.h>
 #include <linux/slab.h>
 #include <linux/init.h>
@@ -30,8 +32,6 @@
 #include <linux/interrupt.h>
 #include <asm/delay.h>
 
-#include "cx88.h"
-
 /* ------------------------------------------------------------------ */
 
 MODULE_DESCRIPTION("mpeg driver for cx2388x based TV cards");
@@ -45,15 +45,11 @@ static unsigned int debug;
 module_param(debug,int,0644);
 MODULE_PARM_DESC(debug,"enable debug messages [mpeg]");
 
-#define dprintk(level, fmt, arg...) do {				       \
-	if (debug + 1 > level)						       \
-		printk(KERN_DEBUG "%s/2-mpeg: " fmt, dev->core->name, ## arg); \
-} while(0)
-
-#define mpeg_dbg(level, fmt, arg...) do {				  \
-	if (debug + 1 > level)						  \
-		printk(KERN_DEBUG "%s/2-mpeg: " fmt, core->name, ## arg); \
-} while(0)
+#define dprintk(level, fmt, arg...) do {				\
+	if (debug + 1 > level)						\
+		printk(KERN_DEBUG pr_fmt("%s: mpeg:" fmt),		\
+			__func__, ##arg);				\
+} while (0)
 
 #if defined(CONFIG_MODULES) && defined(MODULE)
 static void request_module_async(struct work_struct *work)
@@ -92,7 +88,7 @@ int cx8802_start_dma(struct cx8802_dev    *dev,
 {
 	struct cx88_core *core = dev->core;
 
-	dprintk(1, "cx8802_start_dma w: %d, h: %d, f: %d\n",
+	dprintk(1, "w: %d, h: %d, f: %d\n",
 		core->width, core->height, core->field);
 
 	/* setup fifo + format */
@@ -105,12 +101,12 @@ int cx8802_start_dma(struct cx8802_dev    *dev,
 	/* FIXME: this needs a review.
 	 * also: move to cx88-blackbird + cx88-dvb source files? */
 
-	dprintk( 1, "core->active_type_id = 0x%08x\n", core->active_type_id);
+	dprintk(1, "core->active_type_id = 0x%08x\n", core->active_type_id);
 
 	if ( (core->active_type_id == CX88_MPEG_DVB) &&
 		(core->board.mpeg & CX88_MPEG_DVB) ) {
 
-		dprintk( 1, "cx8802_start_dma doing .dvb\n");
+		dprintk(1, "cx8802_start_dma doing .dvb\n");
 		/* negedge driven & software reset */
 		cx_write(TS_GEN_CNTRL, 0x0040 | dev->ts_gen_cntrl);
 		udelay(100);
@@ -154,7 +150,7 @@ int cx8802_start_dma(struct cx8802_dev    *dev,
 		udelay(100);
 	} else if ( (core->active_type_id == CX88_MPEG_BLACKBIRD) &&
 		(core->board.mpeg & CX88_MPEG_BLACKBIRD) ) {
-		dprintk( 1, "cx8802_start_dma doing .blackbird\n");
+		dprintk(1, "cx8802_start_dma doing .blackbird\n");
 		cx_write(MO_PINMUX_IO, 0x88); /* enable MPEG parallel IO */
 
 		cx_write(TS_GEN_CNTRL, 0x46); /* punctured clock TS & posedge driven & software reset */
@@ -166,8 +162,8 @@ int cx8802_start_dma(struct cx8802_dev    *dev,
 		cx_write(TS_GEN_CNTRL, 0x06); /* punctured clock TS & posedge driven */
 		udelay(100);
 	} else {
-		printk( "%s() Failed. Unsupported value in .mpeg (0x%08x)\n", __func__,
-			core->board.mpeg );
+		pr_err("%s() Failed. Unsupported value in .mpeg (0x%08x)\n",
+		       __func__, core->board.mpeg);
 		return -EINVAL;
 	}
 
@@ -176,7 +172,7 @@ int cx8802_start_dma(struct cx8802_dev    *dev,
 	q->count = 0;
 
 	/* enable irqs */
-	dprintk( 1, "setting the interrupt mask\n" );
+	dprintk(1, "setting the interrupt mask\n");
 	cx_set(MO_PCI_INTMSK, core->pci_irqmask | PCI_INT_TSINT);
 	cx_set(MO_TS_INTMSK,  0x1f0011);
 
@@ -189,7 +185,7 @@ int cx8802_start_dma(struct cx8802_dev    *dev,
 static int cx8802_stop_dma(struct cx8802_dev *dev)
 {
 	struct cx88_core *core = dev->core;
-	dprintk( 1, "cx8802_stop_dma\n" );
+	dprintk(1, "\n");
 
 	/* stop dma */
 	cx_clear(MO_TS_DMACNTRL, 0x11);
@@ -208,7 +204,7 @@ static int cx8802_restart_queue(struct cx8802_dev    *dev,
 {
 	struct cx88_buffer *buf;
 
-	dprintk( 1, "cx8802_restart_queue\n" );
+	dprintk(1, "\n");
 	if (list_empty(&q->active))
 		return 0;
 
@@ -249,25 +245,25 @@ void cx8802_buf_queue(struct cx8802_dev *dev, struct cx88_buffer *buf)
 	struct cx88_buffer    *prev;
 	struct cx88_dmaqueue  *cx88q = &dev->mpegq;
 
-	dprintk( 1, "cx8802_buf_queue\n" );
+	dprintk(1, "\n");
 	/* add jump to start */
 	buf->risc.cpu[1] = cpu_to_le32(buf->risc.dma + 8);
 	buf->risc.jmp[0] = cpu_to_le32(RISC_JUMP | RISC_CNT_INC);
 	buf->risc.jmp[1] = cpu_to_le32(buf->risc.dma + 8);
 
 	if (list_empty(&cx88q->active)) {
-		dprintk( 1, "queue is empty - first active\n" );
+		dprintk(1, "queue is empty - first active\n");
 		list_add_tail(&buf->list, &cx88q->active);
 		dprintk(1,"[%p/%d] %s - first active\n",
 			buf, buf->vb.vb2_buf.index, __func__);
 
 	} else {
 		buf->risc.cpu[0] |= cpu_to_le32(RISC_IRQ1);
-		dprintk( 1, "queue is not empty - append to active\n" );
+		dprintk(1, "queue is not empty - append to active\n");
 		prev = list_entry(cx88q->active.prev, struct cx88_buffer, list);
 		list_add_tail(&buf->list, &cx88q->active);
 		prev->risc.jmp[1] = cpu_to_le32(buf->risc.dma);
-		dprintk( 1, "[%p/%d] %s - append to active\n",
+		dprintk(1, "[%p/%d] %s - append to active\n",
 			buf, buf->vb.vb2_buf.index, __func__);
 	}
 }
@@ -291,7 +287,7 @@ static void do_cancel_buffers(struct cx8802_dev *dev)
 
 void cx8802_cancel_buffers(struct cx8802_dev *dev)
 {
-	dprintk( 1, "cx8802_cancel_buffers" );
+	dprintk(1, "\n");
 	cx8802_stop_dma(dev);
 	do_cancel_buffers(dev);
 }
@@ -310,7 +306,7 @@ static void cx8802_mpeg_irq(struct cx8802_dev *dev)
 	struct cx88_core *core = dev->core;
 	u32 status, mask, count;
 
-	dprintk( 1, "cx8802_mpeg_irq\n" );
+	dprintk(1, "\n");
 	status = cx_read(MO_TS_INTSTAT);
 	mask   = cx_read(MO_TS_INTMSK);
 	if (0 == (status & mask))
@@ -319,20 +315,20 @@ static void cx8802_mpeg_irq(struct cx8802_dev *dev)
 	cx_write(MO_TS_INTSTAT, status);
 
 	if (debug || (status & mask & ~0xff))
-		cx88_print_irqbits(core->name, "irq mpeg ",
+		cx88_print_irqbits("irq mpeg ",
 				   cx88_mpeg_irqs, ARRAY_SIZE(cx88_mpeg_irqs),
 				   status, mask);
 
 	/* risc op code error */
 	if (status & (1 << 16)) {
-		printk(KERN_WARNING "%s: mpeg risc op code error\n",core->name);
+		pr_warn("mpeg risc op code error\n");
 		cx_clear(MO_TS_DMACNTRL, 0x11);
 		cx88_sram_channel_dump(dev->core, &cx88_sram_channels[SRAM_CH28]);
 	}
 
 	/* risc1 y */
 	if (status & 0x01) {
-		dprintk( 1, "wake up\n" );
+		dprintk(1, "wake up\n");
 		spin_lock(&dev->slock);
 		count = cx_read(MO_TS_GPCNT);
 		cx88_wakeup(dev->core, &dev->mpegq, count);
@@ -341,7 +337,7 @@ static void cx8802_mpeg_irq(struct cx8802_dev *dev)
 
 	/* other general errors */
 	if (status & 0x1f0100) {
-		dprintk( 0, "general errors: 0x%08x\n", status & 0x1f0100 );
+		dprintk(0, "general errors: 0x%08x\n", status & 0x1f0100);
 		spin_lock(&dev->slock);
 		cx8802_stop_dma(dev);
 		spin_unlock(&dev->slock);
@@ -362,9 +358,9 @@ static irqreturn_t cx8802_irq(int irq, void *dev_id)
 			(core->pci_irqmask | PCI_INT_TSINT);
 		if (0 == status)
 			goto out;
-		dprintk( 1, "cx8802_irq\n" );
-		dprintk( 1, "    loop: %d/%d\n", loop, MAX_IRQ_LOOP );
-		dprintk( 1, "    status: %d\n", status );
+		dprintk(1, "cx8802_irq\n");
+		dprintk(1, "    loop: %d/%d\n", loop, MAX_IRQ_LOOP);
+		dprintk(1, "    status: %d\n", status);
 		handled = 1;
 		cx_write(MO_PCI_INTSTAT, status);
 
@@ -374,9 +370,8 @@ static irqreturn_t cx8802_irq(int irq, void *dev_id)
 			cx8802_mpeg_irq(dev);
 	}
 	if (MAX_IRQ_LOOP == loop) {
-		dprintk( 0, "clearing mask\n" );
-		printk(KERN_WARNING "%s/0: irq loop -- clearing mask\n",
-		       core->name);
+		dprintk(0, "clearing mask\n");
+		pr_warn("irq loop -- clearing mask\n");
 		cx_write(MO_PCI_INTMSK,0);
 	}
 
@@ -395,16 +390,16 @@ static int cx8802_init_common(struct cx8802_dev *dev)
 	pci_set_master(dev->pci);
 	err = pci_set_dma_mask(dev->pci,DMA_BIT_MASK(32));
 	if (err) {
-		printk("%s/2: Oops: no 32bit PCI DMA ???\n",dev->core->name);
+		pr_err("Oops: no 32bit PCI DMA ???\n");
 		return -EIO;
 	}
 
 	dev->pci_rev = dev->pci->revision;
 	pci_read_config_byte(dev->pci, PCI_LATENCY_TIMER,  &dev->pci_lat);
-	printk(KERN_INFO "%s/2: found at %s, rev: %d, irq: %d, latency: %d, mmio: 0x%llx\n",
-	       dev->core->name,
-	       pci_name(dev->pci), dev->pci_rev, dev->pci->irq,
-	       dev->pci_lat,(unsigned long long)pci_resource_start(dev->pci,0));
+	pr_info("found at %s, rev: %d, irq: %d, latency: %d, mmio: 0x%llx\n",
+		pci_name(dev->pci), dev->pci_rev, dev->pci->irq,
+		dev->pci_lat,
+		(unsigned long long)pci_resource_start(dev->pci, 0));
 
 	/* initialize driver struct */
 	spin_lock_init(&dev->slock);
@@ -416,8 +411,7 @@ static int cx8802_init_common(struct cx8802_dev *dev)
 	err = request_irq(dev->pci->irq, cx8802_irq,
 			  IRQF_SHARED, dev->core->name, dev);
 	if (err < 0) {
-		printk(KERN_ERR "%s: can't get IRQ %d\n",
-		       dev->core->name, dev->pci->irq);
+		pr_err("can't get IRQ %d\n", dev->pci->irq);
 		return err;
 	}
 	cx_set(MO_PCI_INTMSK, core->pci_irqmask);
@@ -429,7 +423,7 @@ static int cx8802_init_common(struct cx8802_dev *dev)
 
 static void cx8802_fini_common(struct cx8802_dev *dev)
 {
-	dprintk( 2, "cx8802_fini_common\n" );
+	dprintk(2, "\n");
 	cx8802_stop_dma(dev);
 	pci_disable_device(dev->pci);
 
@@ -442,14 +436,13 @@ static void cx8802_fini_common(struct cx8802_dev *dev)
 static int cx8802_suspend_common(struct pci_dev *pci_dev, pm_message_t state)
 {
 	struct cx8802_dev *dev = pci_get_drvdata(pci_dev);
-	struct cx88_core *core = dev->core;
 	unsigned long flags;
 
 	/* stop mpeg dma */
 	spin_lock_irqsave(&dev->slock, flags);
 	if (!list_empty(&dev->mpegq.active)) {
-		dprintk( 2, "suspend\n" );
-		printk("%s: suspend mpeg\n", core->name);
+		dprintk(2, "suspend\n");
+		pr_info("suspend mpeg\n");
 		cx8802_stop_dma(dev);
 	}
 	spin_unlock_irqrestore(&dev->slock, flags);
@@ -468,23 +461,20 @@ static int cx8802_suspend_common(struct pci_dev *pci_dev, pm_message_t state)
 static int cx8802_resume_common(struct pci_dev *pci_dev)
 {
 	struct cx8802_dev *dev = pci_get_drvdata(pci_dev);
-	struct cx88_core *core = dev->core;
 	unsigned long flags;
 	int err;
 
 	if (dev->state.disabled) {
 		err=pci_enable_device(pci_dev);
 		if (err) {
-			printk(KERN_ERR "%s: can't enable device\n",
-					       dev->core->name);
+			pr_err("can't enable device\n");
 			return err;
 		}
 		dev->state.disabled = 0;
 	}
 	err=pci_set_power_state(pci_dev, PCI_D0);
 	if (err) {
-		printk(KERN_ERR "%s: can't enable device\n",
-					       dev->core->name);
+		pr_err("can't enable device\n");
 		pci_disable_device(pci_dev);
 		dev->state.disabled = 1;
 
@@ -498,7 +488,7 @@ static int cx8802_resume_common(struct pci_dev *pci_dev)
 	/* restart video+vbi capture */
 	spin_lock_irqsave(&dev->slock, flags);
 	if (!list_empty(&dev->mpegq.active)) {
-		printk("%s: resume mpeg\n", core->name);
+		pr_info("resume mpeg\n");
 		cx8802_restart_queue(dev,&dev->mpegq);
 	}
 	spin_unlock_irqrestore(&dev->slock, flags);
@@ -550,7 +540,7 @@ static int cx8802_request_acquire(struct cx8802_driver *drv)
 			drv->advise_acquire(drv);
 		}
 
-		mpeg_dbg(1,"%s() Post acquire GPIO=%x\n", __func__, cx_read(MO_GP0_IO));
+		dprintk(1, "Post acquire GPIO=%x\n", cx_read(MO_GP0_IO));
 	}
 
 	return 0;
@@ -571,7 +561,7 @@ static int cx8802_request_release(struct cx8802_driver *drv)
 
 		drv->advise_release(drv);
 		core->active_type_id = CX88_BOARD_NONE;
-		mpeg_dbg(1,"%s() Post release GPIO=%x\n", __func__, cx_read(MO_GP0_IO));
+		dprintk(1, "Post release GPIO=%x\n", cx_read(MO_GP0_IO));
 	}
 
 	return 0;
@@ -605,24 +595,22 @@ int cx8802_register_driver(struct cx8802_driver *drv)
 	struct cx8802_driver *driver;
 	int err, i = 0;
 
-	printk(KERN_INFO
-	       "cx88/2: registering cx8802 driver, type: %s access: %s\n",
-	       drv->type_id == CX88_MPEG_DVB ? "dvb" : "blackbird",
-	       drv->hw_access == CX8802_DRVCTL_SHARED ? "shared" : "exclusive");
+	pr_info("registering cx8802 driver, type: %s access: %s\n",
+		drv->type_id == CX88_MPEG_DVB ? "dvb" : "blackbird",
+		drv->hw_access == CX8802_DRVCTL_SHARED ? "shared" : "exclusive");
 
 	if ((err = cx8802_check_driver(drv)) != 0) {
-		printk(KERN_ERR "cx88/2: cx8802_driver is invalid\n");
+		pr_err("cx8802_driver is invalid\n");
 		return err;
 	}
 
 	mutex_lock(&cx8802_mutex);
 
 	list_for_each_entry(dev, &cx8802_devlist, devlist) {
-		printk(KERN_INFO
-		       "%s/2: subsystem: %04x:%04x, board: %s [card=%d]\n",
-		       dev->core->name, dev->pci->subsystem_vendor,
-		       dev->pci->subsystem_device, dev->core->board.name,
-		       dev->core->boardnr);
+		pr_info("subsystem: %04x:%04x, board: %s [card=%d]\n",
+			dev->pci->subsystem_vendor,
+			dev->pci->subsystem_device, dev->core->board.name,
+			dev->core->boardnr);
 
 		/* Bring up a new struct for each driver instance */
 		driver = kzalloc(sizeof(*drv),GFP_KERNEL);
@@ -645,9 +633,7 @@ int cx8802_register_driver(struct cx8802_driver *drv)
 			i++;
 			list_add_tail(&driver->drvlist, &dev->drvlist);
 		} else {
-			printk(KERN_ERR
-			       "%s/2: cx8802 probe failed, err = %d\n",
-			       dev->core->name, err);
+			pr_err("cx8802 probe failed, err = %d\n", err);
 		}
 		mutex_unlock(&drv->core->lock);
 	}
@@ -664,19 +650,17 @@ int cx8802_unregister_driver(struct cx8802_driver *drv)
 	struct cx8802_driver *d, *dtmp;
 	int err = 0;
 
-	printk(KERN_INFO
-	       "cx88/2: unregistering cx8802 driver, type: %s access: %s\n",
-	       drv->type_id == CX88_MPEG_DVB ? "dvb" : "blackbird",
-	       drv->hw_access == CX8802_DRVCTL_SHARED ? "shared" : "exclusive");
+	pr_info("unregistering cx8802 driver, type: %s access: %s\n",
+		drv->type_id == CX88_MPEG_DVB ? "dvb" : "blackbird",
+		drv->hw_access == CX8802_DRVCTL_SHARED ? "shared" : "exclusive");
 
 	mutex_lock(&cx8802_mutex);
 
 	list_for_each_entry(dev, &cx8802_devlist, devlist) {
-		printk(KERN_INFO
-		       "%s/2: subsystem: %04x:%04x, board: %s [card=%d]\n",
-		       dev->core->name, dev->pci->subsystem_vendor,
-		       dev->pci->subsystem_device, dev->core->board.name,
-		       dev->core->boardnr);
+		pr_info("subsystem: %04x:%04x, board: %s [card=%d]\n",
+			dev->pci->subsystem_vendor,
+			dev->pci->subsystem_device, dev->core->board.name,
+			dev->core->boardnr);
 
 		mutex_lock(&dev->core->lock);
 
@@ -690,8 +674,8 @@ int cx8802_unregister_driver(struct cx8802_driver *drv)
 				list_del(&d->drvlist);
 				kfree(d);
 			} else
-				printk(KERN_ERR "%s/2: cx8802 driver remove failed (%d)\n",
-				       dev->core->name, err);
+				pr_err("cx8802 driver remove failed (%d)\n",
+				       err);
 		}
 
 		mutex_unlock(&dev->core->lock);
@@ -715,7 +699,7 @@ static int cx8802_probe(struct pci_dev *pci_dev,
 	if (NULL == core)
 		return -EINVAL;
 
-	printk("%s/2: cx2388x 8802 Driver Manager\n", core->name);
+	pr_info("cx2388x 8802 Driver Manager\n");
 
 	err = -ENODEV;
 	if (!core->board.mpeg)
@@ -758,7 +742,7 @@ static void cx8802_remove(struct pci_dev *pci_dev)
 
 	dev = pci_get_drvdata(pci_dev);
 
-	dprintk( 1, "%s\n", __func__);
+	dprintk(1, "%s\n", __func__);
 
 	flush_request_modules(dev);
 
@@ -768,16 +752,15 @@ static void cx8802_remove(struct pci_dev *pci_dev)
 		struct cx8802_driver *drv, *tmp;
 		int err;
 
-		printk(KERN_WARNING "%s/2: Trying to remove cx8802 driver while cx8802 sub-drivers still loaded?!\n",
-		       dev->core->name);
+		pr_warn("Trying to remove cx8802 driver while cx8802 sub-drivers still loaded?!\n");
 
 		list_for_each_entry_safe(drv, tmp, &dev->drvlist, drvlist) {
 			err = drv->remove(drv);
 			if (err == 0) {
 				list_del(&drv->drvlist);
 			} else
-				printk(KERN_ERR "%s/2: cx8802 driver remove failed (%d)\n",
-				       dev->core->name, err);
+				pr_err("cx8802 driver remove failed (%d)\n",
+				       err);
 			kfree(drv);
 		}
 	}

commit e318e584f70f60170809dd975bbd480fc06cc5e4
Author: Mauro Carvalho Chehab <mchehab@s-opensource.com>
Date:   Tue Oct 18 17:44:04 2016 -0200

    [media] cx88: don't break long lines
    
    Due to the 80-cols restrictions, and latter due to checkpatch
    warnings, several strings were broken into multiple lines. This
    is not considered a good practice anymore, as it makes harder
    to grep for strings at the source code.
    
    As we're right now fixing other drivers due to KERN_CONT, we need
    to be able to identify what printk strings don't end with a "\n".
    It is a way easier to detect those if we don't break long lines.
    
    So, join those continuation lines.
    
    The patch was generated via the script below, and manually
    adjusted if needed.
    
    </script>
    use Text::Tabs;
    while (<>) {
            if ($next ne "") {
                    $c=$_;
                    if ($c =~ /^\s+\"(.*)/) {
                            $c2=$1;
                            $next =~ s/\"\n$//;
                            $n = expand($next);
                            $funpos = index($n, '(');
                            $pos = index($c2, '",');
                            if ($funpos && $pos > 0) {
                                    $s1 = substr $c2, 0, $pos + 2;
                                    $s2 = ' ' x ($funpos + 1) . substr $c2, $pos + 2;
                                    $s2 =~ s/^\s+//;
    
                                    $s2 = ' ' x ($funpos + 1) . $s2 if ($s2 ne "");
    
                                    print unexpand("$next$s1\n");
                                    print unexpand("$s2\n") if ($s2 ne "");
                            } else {
                                    print "$next$c2\n";
                            }
                            $next="";
                            next;
                    } else {
                            print $next;
                    }
                    $next="";
            } else {
                    if (m/\"$/) {
                            if (!m/\\n\"$/) {
                                    $next=$_;
                                    next;
                            }
                    }
            }
            print $_;
    }
    </script>
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/pci/cx88/cx88-mpeg.c b/drivers/media/pci/cx88/cx88-mpeg.c
index 245357adbc25..86b46b62d985 100644
--- a/drivers/media/pci/cx88/cx88-mpeg.c
+++ b/drivers/media/pci/cx88/cx88-mpeg.c
@@ -401,8 +401,8 @@ static int cx8802_init_common(struct cx8802_dev *dev)
 
 	dev->pci_rev = dev->pci->revision;
 	pci_read_config_byte(dev->pci, PCI_LATENCY_TIMER,  &dev->pci_lat);
-	printk(KERN_INFO "%s/2: found at %s, rev: %d, irq: %d, "
-	       "latency: %d, mmio: 0x%llx\n", dev->core->name,
+	printk(KERN_INFO "%s/2: found at %s, rev: %d, irq: %d, latency: %d, mmio: 0x%llx\n",
+	       dev->core->name,
 	       pci_name(dev->pci), dev->pci_rev, dev->pci->irq,
 	       dev->pci_lat,(unsigned long long)pci_resource_start(dev->pci,0));
 
@@ -690,8 +690,8 @@ int cx8802_unregister_driver(struct cx8802_driver *drv)
 				list_del(&d->drvlist);
 				kfree(d);
 			} else
-				printk(KERN_ERR "%s/2: cx8802 driver remove "
-				       "failed (%d)\n", dev->core->name, err);
+				printk(KERN_ERR "%s/2: cx8802 driver remove failed (%d)\n",
+				       dev->core->name, err);
 		}
 
 		mutex_unlock(&dev->core->lock);
@@ -768,8 +768,7 @@ static void cx8802_remove(struct pci_dev *pci_dev)
 		struct cx8802_driver *drv, *tmp;
 		int err;
 
-		printk(KERN_WARNING "%s/2: Trying to remove cx8802 driver "
-		       "while cx8802 sub-drivers still loaded?!\n",
+		printk(KERN_WARNING "%s/2: Trying to remove cx8802 driver while cx8802 sub-drivers still loaded?!\n",
 		       dev->core->name);
 
 		list_for_each_entry_safe(drv, tmp, &dev->drvlist, drvlist) {
@@ -777,8 +776,8 @@ static void cx8802_remove(struct pci_dev *pci_dev)
 			if (err == 0) {
 				list_del(&drv->drvlist);
 			} else
-				printk(KERN_ERR "%s/2: cx8802 driver remove "
-				       "failed (%d)\n", dev->core->name, err);
+				printk(KERN_ERR "%s/2: cx8802 driver remove failed (%d)\n",
+				       dev->core->name, err);
 			kfree(drv);
 		}
 	}

commit 2bc46b3ad3c15165f91459b07ff8682478683194
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Mon Feb 15 12:37:15 2016 -0200

    [media] media/pci: convert drivers to use the new vb2_queue dev field
    
    Stop using alloc_ctx and just fill in the device pointer.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Cc: Federico Vaga <federico.vaga@gmail.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/pci/cx88/cx88-mpeg.c b/drivers/media/pci/cx88/cx88-mpeg.c
index f34c229f9b37..245357adbc25 100644
--- a/drivers/media/pci/cx88/cx88-mpeg.c
+++ b/drivers/media/pci/cx88/cx88-mpeg.c
@@ -726,11 +726,6 @@ static int cx8802_probe(struct pci_dev *pci_dev,
 	if (NULL == dev)
 		goto fail_core;
 	dev->pci = pci_dev;
-	dev->alloc_ctx = vb2_dma_sg_init_ctx(&pci_dev->dev);
-	if (IS_ERR(dev->alloc_ctx)) {
-		err = PTR_ERR(dev->alloc_ctx);
-		goto fail_dev;
-	}
 	dev->core = core;
 
 	/* Maintain a reference so cx88-video can query the 8802 device. */
@@ -738,7 +733,7 @@ static int cx8802_probe(struct pci_dev *pci_dev,
 
 	err = cx8802_init_common(dev);
 	if (err != 0)
-		goto fail_free;
+		goto fail_dev;
 
 	INIT_LIST_HEAD(&dev->drvlist);
 	mutex_lock(&cx8802_mutex);
@@ -749,8 +744,6 @@ static int cx8802_probe(struct pci_dev *pci_dev,
 	request_modules(dev);
 	return 0;
 
- fail_free:
-	vb2_dma_sg_cleanup_ctx(dev->alloc_ctx);
  fail_dev:
 	kfree(dev);
  fail_core:
@@ -798,7 +791,6 @@ static void cx8802_remove(struct pci_dev *pci_dev)
 	/* common */
 	cx8802_fini_common(dev);
 	cx88_core_put(dev->core,dev->pci);
-	vb2_dma_sg_cleanup_ctx(dev->alloc_ctx);
 	kfree(dev);
 }
 

commit 1a47de6e4a8dc2aaf3c3fb544b60730b74abe0f1
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Nov 20 15:57:07 2015 -0800

    various: fix pci_set_dma_mask return value checking
    
    pci_set_dma_mask returns a negative errno value, not a bool like
    pci_dma_supported.  This of course was just a giant test for attention :)
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reported-by: Jongman Heo <jongman.heo@samsung.com>
    Tested-by: Jongman Heo <jongman.heo@samsung.com>        [pcnet32]
    Acked-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
    Cc: Hans Verkuil <hverkuil@xs4all.nl>
    Cc: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/media/pci/cx88/cx88-mpeg.c b/drivers/media/pci/cx88/cx88-mpeg.c
index 9db7767d1fe0..f34c229f9b37 100644
--- a/drivers/media/pci/cx88/cx88-mpeg.c
+++ b/drivers/media/pci/cx88/cx88-mpeg.c
@@ -393,7 +393,8 @@ static int cx8802_init_common(struct cx8802_dev *dev)
 	if (pci_enable_device(dev->pci))
 		return -EIO;
 	pci_set_master(dev->pci);
-	if (!pci_set_dma_mask(dev->pci,DMA_BIT_MASK(32))) {
+	err = pci_set_dma_mask(dev->pci,DMA_BIT_MASK(32));
+	if (err) {
 		printk("%s/2: Oops: no 32bit PCI DMA ???\n",dev->core->name);
 		return -EIO;
 	}

commit 111be8b28d87769dfbde901602d262902575805d
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Nov 10 14:45:28 2015 -0800

    cx88: use pci_set_dma_mask insted of pci_dma_supported
    
    This ensures the dma mask that is supported by the driver is recorded
    in the device structure.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Cc: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
    Cc: Hans Verkuil <hverkuil@xs4all.nl>
    Cc: Sakari Ailus <sakari.ailus@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/media/pci/cx88/cx88-mpeg.c b/drivers/media/pci/cx88/cx88-mpeg.c
index 9961b2232b97..9db7767d1fe0 100644
--- a/drivers/media/pci/cx88/cx88-mpeg.c
+++ b/drivers/media/pci/cx88/cx88-mpeg.c
@@ -393,7 +393,7 @@ static int cx8802_init_common(struct cx8802_dev *dev)
 	if (pci_enable_device(dev->pci))
 		return -EIO;
 	pci_set_master(dev->pci);
-	if (!pci_dma_supported(dev->pci,DMA_BIT_MASK(32))) {
+	if (!pci_set_dma_mask(dev->pci,DMA_BIT_MASK(32))) {
 		printk("%s/2: Oops: no 32bit PCI DMA ???\n",dev->core->name);
 		return -EIO;
 	}

commit 2d7007153f0c9b1dd00c01894df7d26ddc32b79f
Author: Junghak Sung <jh1009.sung@samsung.com>
Date:   Tue Sep 22 10:30:30 2015 -0300

    [media] media: videobuf2: Restructure vb2_buffer
    
    Remove v4l2 stuff - v4l2_buf, v4l2_plane - from struct vb2_buffer.
    
    Add new member variables - bytesused, length, offset, userptr, fd,
    data_offset - to struct vb2_plane in order to cover all information
    of v4l2_plane.
    struct vb2_plane {
            <snip>
            unsigned int            bytesused;
            unsigned int            length;
            union {
                    unsigned int    offset;
                    unsigned long   userptr;
                    int             fd;
            } m;
            unsigned int            data_offset;
    }
    
    Replace v4l2_buf with new member variables - index, type, memory - which
    are common fields for buffer management.
    struct vb2_buffer {
            <snip>
            unsigned int            index;
            unsigned int            type;
            unsigned int            memory;
            unsigned int            num_planes;
            struct vb2_plane        planes[VIDEO_MAX_PLANES];
            <snip>
    };
    
    v4l2 specific fields - flags, field, timestamp, timecode,
    sequence - are moved to vb2_v4l2_buffer in videobuf2-v4l2.c
    struct vb2_v4l2_buffer {
            struct vb2_buffer       vb2_buf;
    
            __u32                   flags;
            __u32                   field;
            struct timeval          timestamp;
            struct v4l2_timecode    timecode;
            __u32                   sequence;
    };
    
    Signed-off-by: Junghak Sung <jh1009.sung@samsung.com>
    Signed-off-by: Geunyoung Kim <nenggun.kim@samsung.com>
    Acked-by: Seung-Woo Kim <sw0312.kim@samsung.com>
    Acked-by: Inki Dae <inki.dae@samsung.com>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/pci/cx88/cx88-mpeg.c b/drivers/media/pci/cx88/cx88-mpeg.c
index 34f505744477..9961b2232b97 100644
--- a/drivers/media/pci/cx88/cx88-mpeg.c
+++ b/drivers/media/pci/cx88/cx88-mpeg.c
@@ -214,7 +214,7 @@ static int cx8802_restart_queue(struct cx8802_dev    *dev,
 
 	buf = list_entry(q->active.next, struct cx88_buffer, list);
 	dprintk(2,"restart_queue [%p/%d]: restart dma\n",
-		buf, buf->vb.v4l2_buf.index);
+		buf, buf->vb.vb2_buf.index);
 	cx8802_start_dma(dev, q, buf);
 	return 0;
 }
@@ -225,13 +225,13 @@ int cx8802_buf_prepare(struct vb2_queue *q, struct cx8802_dev *dev,
 			struct cx88_buffer *buf)
 {
 	int size = dev->ts_packet_size * dev->ts_packet_count;
-	struct sg_table *sgt = vb2_dma_sg_plane_desc(&buf->vb, 0);
+	struct sg_table *sgt = vb2_dma_sg_plane_desc(&buf->vb.vb2_buf, 0);
 	struct cx88_riscmem *risc = &buf->risc;
 	int rc;
 
-	if (vb2_plane_size(&buf->vb, 0) < size)
+	if (vb2_plane_size(&buf->vb.vb2_buf, 0) < size)
 		return -EINVAL;
-	vb2_set_plane_payload(&buf->vb, 0, size);
+	vb2_set_plane_payload(&buf->vb.vb2_buf, 0, size);
 
 	rc = cx88_risc_databuffer(dev->pci, risc, sgt->sgl,
 			     dev->ts_packet_size, dev->ts_packet_count, 0);
@@ -259,7 +259,7 @@ void cx8802_buf_queue(struct cx8802_dev *dev, struct cx88_buffer *buf)
 		dprintk( 1, "queue is empty - first active\n" );
 		list_add_tail(&buf->list, &cx88q->active);
 		dprintk(1,"[%p/%d] %s - first active\n",
-			buf, buf->vb.v4l2_buf.index, __func__);
+			buf, buf->vb.vb2_buf.index, __func__);
 
 	} else {
 		buf->risc.cpu[0] |= cpu_to_le32(RISC_IRQ1);
@@ -268,7 +268,7 @@ void cx8802_buf_queue(struct cx8802_dev *dev, struct cx88_buffer *buf)
 		list_add_tail(&buf->list, &cx88q->active);
 		prev->risc.jmp[1] = cpu_to_le32(buf->risc.dma);
 		dprintk( 1, "[%p/%d] %s - append to active\n",
-			buf, buf->vb.v4l2_buf.index, __func__);
+			buf, buf->vb.vb2_buf.index, __func__);
 	}
 }
 
@@ -284,7 +284,7 @@ static void do_cancel_buffers(struct cx8802_dev *dev)
 	while (!list_empty(&q->active)) {
 		buf = list_entry(q->active.next, struct cx88_buffer, list);
 		list_del(&buf->list);
-		vb2_buffer_done(&buf->vb, VB2_BUF_STATE_ERROR);
+		vb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);
 	}
 	spin_unlock_irqrestore(&dev->slock,flags);
 }

commit 9450684b7439202f62a37183104b31d884ff0de3
Author: Hans Verkuil <hverkuil@xs4all.nl>
Date:   Fri Apr 3 07:22:40 2015 -0300

    [media] cx88: v4l2-compliance fixes
    
    Fix three v4l2-compliance failures:
    
    - the colorspace wasn't set in vidioc_try_fmt_vid_cap().
    - the field wasn't set in v4l2_buffer when vb2_buffer_done() was called.
    - the sequence wasn't set in v4l2_buffer when vb2_buffer_done() was called.
      This fix also removes the unused buf->count field and starts the count
      at 0 instead of 1.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/pci/cx88/cx88-mpeg.c b/drivers/media/pci/cx88/cx88-mpeg.c
index 98344540c51f..34f505744477 100644
--- a/drivers/media/pci/cx88/cx88-mpeg.c
+++ b/drivers/media/pci/cx88/cx88-mpeg.c
@@ -173,7 +173,7 @@ int cx8802_start_dma(struct cx8802_dev    *dev,
 
 	/* reset counter */
 	cx_write(MO_TS_GPCNTRL, GP_COUNT_CONTROL_RESET);
-	q->count = 1;
+	q->count = 0;
 
 	/* enable irqs */
 	dprintk( 1, "setting the interrupt mask\n" );
@@ -216,8 +216,6 @@ static int cx8802_restart_queue(struct cx8802_dev    *dev,
 	dprintk(2,"restart_queue [%p/%d]: restart dma\n",
 		buf, buf->vb.v4l2_buf.index);
 	cx8802_start_dma(dev, q, buf);
-	list_for_each_entry(buf, &q->active, list)
-		buf->count = q->count++;
 	return 0;
 }
 
@@ -260,7 +258,6 @@ void cx8802_buf_queue(struct cx8802_dev *dev, struct cx88_buffer *buf)
 	if (list_empty(&cx88q->active)) {
 		dprintk( 1, "queue is empty - first active\n" );
 		list_add_tail(&buf->list, &cx88q->active);
-		buf->count    = cx88q->count++;
 		dprintk(1,"[%p/%d] %s - first active\n",
 			buf, buf->vb.v4l2_buf.index, __func__);
 
@@ -269,7 +266,6 @@ void cx8802_buf_queue(struct cx8802_dev *dev, struct cx88_buffer *buf)
 		dprintk( 1, "queue is not empty - append to active\n" );
 		prev = list_entry(cx88q->active.prev, struct cx88_buffer, list);
 		list_add_tail(&buf->list, &cx88q->active);
-		buf->count    = cx88q->count++;
 		prev->risc.jmp[1] = cpu_to_le32(buf->risc.dma);
 		dprintk( 1, "[%p/%d] %s - append to active\n",
 			buf, buf->vb.v4l2_buf.index, __func__);

commit 96df988bb935959e6380c2333e03911839079ee1
Author: Christian Engelmayer <cengelma@gmx.at>
Date:   Sat Feb 14 20:12:56 2015 -0300

    [media] cx88: Fix possible leak in cx8802_probe()
    
    In case allocation vb2_dma_sg_init_ctx() fails during cx8802_probe(), the
    already allocated cx8802 device structure memory is not freed in the used
    exit path. Thus adapt the cleanup handling accordingly. Detected by Coverity
    CID 1260065.
    
    Signed-off-by: Christian Engelmayer <cengelma@gmx.at>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/pci/cx88/cx88-mpeg.c b/drivers/media/pci/cx88/cx88-mpeg.c
index a369b0840acf..98344540c51f 100644
--- a/drivers/media/pci/cx88/cx88-mpeg.c
+++ b/drivers/media/pci/cx88/cx88-mpeg.c
@@ -732,7 +732,7 @@ static int cx8802_probe(struct pci_dev *pci_dev,
 	dev->alloc_ctx = vb2_dma_sg_init_ctx(&pci_dev->dev);
 	if (IS_ERR(dev->alloc_ctx)) {
 		err = PTR_ERR(dev->alloc_ctx);
-		goto fail_core;
+		goto fail_dev;
 	}
 	dev->core = core;
 
@@ -754,6 +754,7 @@ static int cx8802_probe(struct pci_dev *pci_dev,
 
  fail_free:
 	vb2_dma_sg_cleanup_ctx(dev->alloc_ctx);
+ fail_dev:
 	kfree(dev);
  fail_core:
 	core->dvbdev = NULL;

commit 215cedec379b69427c457104f0c36b389edc471c
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Mon Dec 1 10:10:42 2014 -0300

    [media] media: remove emacs editor variables
    
    1) This is not allowed by the kernel coding style
    2) Just configure your editor correctly
    3) It's really ugly
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Acked-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/pci/cx88/cx88-mpeg.c b/drivers/media/pci/cx88/cx88-mpeg.c
index 1c1f69e6b0b9..a369b0840acf 100644
--- a/drivers/media/pci/cx88/cx88-mpeg.c
+++ b/drivers/media/pci/cx88/cx88-mpeg.c
@@ -833,10 +833,3 @@ EXPORT_SYMBOL(cx8802_start_dma);
 EXPORT_SYMBOL(cx8802_register_driver);
 EXPORT_SYMBOL(cx8802_unregister_driver);
 EXPORT_SYMBOL(cx8802_get_driver);
-/* ----------------------------------------------------------- */
-/*
- * Local variables:
- * c-basic-offset: 8
- * End:
- * kate: eol "unix"; indent-width 3; remove-trailing-space on; replace-trailing-space-save on; tab-width 8; replace-tabs off; space-indent off; mixed-indent off
- */

commit 165d00439fa9e9da7f263dc844cbd524cf624074
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Mon Dec 8 13:23:49 2014 -0300

    [media] cx88: add missing alloc_ctx support
    
    The cx88 vb2 conversion and the vb2 dma_sg improvements were developed separately and
    were merged separately. Unfortunately, the patch updating drivers to the dma_sg
    improvements didn't take the updated cx88 driver into account. Basically two ships
    passing in the night, unaware of one another even though both ships have the same
    owner, i.e. me :-)
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Reported-by: Chris Lee <updatelee@gmail.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/pci/cx88/cx88-mpeg.c b/drivers/media/pci/cx88/cx88-mpeg.c
index f181a3a10389..1c1f69e6b0b9 100644
--- a/drivers/media/pci/cx88/cx88-mpeg.c
+++ b/drivers/media/pci/cx88/cx88-mpeg.c
@@ -235,10 +235,6 @@ int cx8802_buf_prepare(struct vb2_queue *q, struct cx8802_dev *dev,
 		return -EINVAL;
 	vb2_set_plane_payload(&buf->vb, 0, size);
 
-	rc = dma_map_sg(&dev->pci->dev, sgt->sgl, sgt->nents, DMA_FROM_DEVICE);
-	if (!rc)
-		return -EIO;
-
 	rc = cx88_risc_databuffer(dev->pci, risc, sgt->sgl,
 			     dev->ts_packet_size, dev->ts_packet_count, 0);
 	if (rc) {
@@ -733,6 +729,11 @@ static int cx8802_probe(struct pci_dev *pci_dev,
 	if (NULL == dev)
 		goto fail_core;
 	dev->pci = pci_dev;
+	dev->alloc_ctx = vb2_dma_sg_init_ctx(&pci_dev->dev);
+	if (IS_ERR(dev->alloc_ctx)) {
+		err = PTR_ERR(dev->alloc_ctx);
+		goto fail_core;
+	}
 	dev->core = core;
 
 	/* Maintain a reference so cx88-video can query the 8802 device. */
@@ -752,6 +753,7 @@ static int cx8802_probe(struct pci_dev *pci_dev,
 	return 0;
 
  fail_free:
+	vb2_dma_sg_cleanup_ctx(dev->alloc_ctx);
 	kfree(dev);
  fail_core:
 	core->dvbdev = NULL;
@@ -798,6 +800,7 @@ static void cx8802_remove(struct pci_dev *pci_dev)
 	/* common */
 	cx8802_fini_common(dev);
 	cx88_core_put(dev->core,dev->pci);
+	vb2_dma_sg_cleanup_ctx(dev->alloc_ctx);
 	kfree(dev);
 }
 

commit ccd6f1d488e7e49ca90d4255cb3f8a2f61951e55
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Sat Sep 20 09:23:44 2014 -0300

    [media] cx88: move width, height and field to core struct
    
    The width, height and field values are core fields since both vbi, video
    and blackbird use the same video input.
    
    Move those fields to the correct struct.
    
    Also fix the field checks in the try_fmt functions: add V4L2_FIELD_SEQ_BT/TB
    support and map incorrect field values to a correct field value instead of
    returning an error.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/pci/cx88/cx88-mpeg.c b/drivers/media/pci/cx88/cx88-mpeg.c
index 746c0ea13035..f181a3a10389 100644
--- a/drivers/media/pci/cx88/cx88-mpeg.c
+++ b/drivers/media/pci/cx88/cx88-mpeg.c
@@ -93,7 +93,7 @@ int cx8802_start_dma(struct cx8802_dev    *dev,
 	struct cx88_core *core = dev->core;
 
 	dprintk(1, "cx8802_start_dma w: %d, h: %d, f: %d\n",
-		dev->width, dev->height, dev->field);
+		core->width, core->height, core->field);
 
 	/* setup fifo + format */
 	cx88_sram_channel_setup(core, &cx88_sram_channels[SRAM_CH28],
@@ -224,7 +224,7 @@ static int cx8802_restart_queue(struct cx8802_dev    *dev,
 /* ------------------------------------------------------------------ */
 
 int cx8802_buf_prepare(struct vb2_queue *q, struct cx8802_dev *dev,
-			struct cx88_buffer *buf, enum v4l2_field field)
+			struct cx88_buffer *buf)
 {
 	int size = dev->ts_packet_size * dev->ts_packet_count;
 	struct sg_table *sgt = vb2_dma_sg_plane_desc(&buf->vb, 0);

commit 5e7045e3fa4976a37c6bbf337729ea47d0c886d0
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Fri Aug 29 04:11:54 2014 -0300

    [media] cx88: remove dependency on btcx-risc
    
    btcx-risc is for the bt8xx driver and other drivers shouldn't depend
    on it. There is no benefit to use that module just to do a
    pci_zalloc_consistent.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/pci/cx88/cx88-mpeg.c b/drivers/media/pci/cx88/cx88-mpeg.c
index 0589dccae3bd..746c0ea13035 100644
--- a/drivers/media/pci/cx88/cx88-mpeg.c
+++ b/drivers/media/pci/cx88/cx88-mpeg.c
@@ -228,6 +228,7 @@ int cx8802_buf_prepare(struct vb2_queue *q, struct cx8802_dev *dev,
 {
 	int size = dev->ts_packet_size * dev->ts_packet_count;
 	struct sg_table *sgt = vb2_dma_sg_plane_desc(&buf->vb, 0);
+	struct cx88_riscmem *risc = &buf->risc;
 	int rc;
 
 	if (vb2_plane_size(&buf->vb, 0) < size)
@@ -238,10 +239,12 @@ int cx8802_buf_prepare(struct vb2_queue *q, struct cx8802_dev *dev,
 	if (!rc)
 		return -EIO;
 
-	rc = cx88_risc_databuffer(dev->pci, &buf->risc, sgt->sgl,
+	rc = cx88_risc_databuffer(dev->pci, risc, sgt->sgl,
 			     dev->ts_packet_size, dev->ts_packet_count, 0);
 	if (rc) {
-		btcx_riscmem_free(dev->pci, &buf->risc);
+		if (risc->cpu)
+			pci_free_consistent(dev->pci, risc->size, risc->cpu, risc->dma);
+		memset(risc, 0, sizeof(*risc));
 		return rc;
 	}
 	return 0;

commit 999b3ceb849b5b9ed25739fea2e69adef09845c7
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Fri Aug 29 05:40:47 2014 -0300

    [media] cx88: drop cx88_free_buffer
    
    Remove this function. This makes all vb2 queues behave the same, which
    simplifies comparing the various vb2 queue op implementations.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/pci/cx88/cx88-mpeg.c b/drivers/media/pci/cx88/cx88-mpeg.c
index 7986ee037b83..0589dccae3bd 100644
--- a/drivers/media/pci/cx88/cx88-mpeg.c
+++ b/drivers/media/pci/cx88/cx88-mpeg.c
@@ -238,8 +238,12 @@ int cx8802_buf_prepare(struct vb2_queue *q, struct cx8802_dev *dev,
 	if (!rc)
 		return -EIO;
 
-	cx88_risc_databuffer(dev->pci, &buf->risc, sgt->sgl,
+	rc = cx88_risc_databuffer(dev->pci, &buf->risc, sgt->sgl,
 			     dev->ts_packet_size, dev->ts_packet_count, 0);
+	if (rc) {
+		btcx_riscmem_free(dev->pci, &buf->risc);
+		return rc;
+	}
 	return 0;
 }
 

commit 0b6b6302d983236f8b5d6d6602b91a6d1e144896
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Sat Sep 20 09:22:18 2014 -0300

    [media] cx88: convert to vb2
    
    As usual, this patch is very large due to the fact that half a vb2 conversion
    isn't possible. And since this affects blackbird, alsa, core, dvb, vbi and
    video the changes are all over.
    
    What made this more difficult was the peculiar way the risc program was setup.
    The driver allowed for running out of buffers in which case the DMA would stop
    and restart when the next buffer was queued. There was also a complicated
    timeout system for when buffers weren't filled. This was replaced by a much
    simpler scheme where there is always one buffer around and the DMA will just
    cycle that buffer until a new buffer is queued. In that case the previous
    buffer will be chained to the new buffer. An interrupt is generated at the
    start of the new buffer telling the driver that the previous buffer can be
    passed on to userspace.
    
    Much simpler and more robust.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/pci/cx88/cx88-mpeg.c b/drivers/media/pci/cx88/cx88-mpeg.c
index 5f59901b2460..7986ee037b83 100644
--- a/drivers/media/pci/cx88/cx88-mpeg.c
+++ b/drivers/media/pci/cx88/cx88-mpeg.c
@@ -86,21 +86,21 @@ static LIST_HEAD(cx8802_devlist);
 static DEFINE_MUTEX(cx8802_mutex);
 /* ------------------------------------------------------------------ */
 
-static int cx8802_start_dma(struct cx8802_dev    *dev,
+int cx8802_start_dma(struct cx8802_dev    *dev,
 			    struct cx88_dmaqueue *q,
 			    struct cx88_buffer   *buf)
 {
 	struct cx88_core *core = dev->core;
 
 	dprintk(1, "cx8802_start_dma w: %d, h: %d, f: %d\n",
-		buf->vb.width, buf->vb.height, buf->vb.field);
+		dev->width, dev->height, dev->field);
 
 	/* setup fifo + format */
 	cx88_sram_channel_setup(core, &cx88_sram_channels[SRAM_CH28],
 				dev->ts_packet_size, buf->risc.dma);
 
 	/* write TS length to chip */
-	cx_write(MO_TS_LNGTH, buf->vb.width);
+	cx_write(MO_TS_LNGTH, dev->ts_packet_size);
 
 	/* FIXME: this needs a review.
 	 * also: move to cx88-blackbird + cx88-dvb source files? */
@@ -212,47 +212,35 @@ static int cx8802_restart_queue(struct cx8802_dev    *dev,
 	if (list_empty(&q->active))
 		return 0;
 
-	buf = list_entry(q->active.next, struct cx88_buffer, vb.queue);
+	buf = list_entry(q->active.next, struct cx88_buffer, list);
 	dprintk(2,"restart_queue [%p/%d]: restart dma\n",
-		buf, buf->vb.i);
+		buf, buf->vb.v4l2_buf.index);
 	cx8802_start_dma(dev, q, buf);
-	list_for_each_entry(buf, &q->active, vb.queue)
+	list_for_each_entry(buf, &q->active, list)
 		buf->count = q->count++;
-	mod_timer(&q->timeout, jiffies+BUFFER_TIMEOUT);
 	return 0;
 }
 
 /* ------------------------------------------------------------------ */
 
-int cx8802_buf_prepare(struct videobuf_queue *q, struct cx8802_dev *dev,
+int cx8802_buf_prepare(struct vb2_queue *q, struct cx8802_dev *dev,
 			struct cx88_buffer *buf, enum v4l2_field field)
 {
 	int size = dev->ts_packet_size * dev->ts_packet_count;
-	struct videobuf_dmabuf *dma=videobuf_to_dma(&buf->vb);
+	struct sg_table *sgt = vb2_dma_sg_plane_desc(&buf->vb, 0);
 	int rc;
 
-	dprintk(1, "%s: %p\n", __func__, buf);
-	if (0 != buf->vb.baddr  &&  buf->vb.bsize < size)
+	if (vb2_plane_size(&buf->vb, 0) < size)
 		return -EINVAL;
+	vb2_set_plane_payload(&buf->vb, 0, size);
 
-	if (VIDEOBUF_NEEDS_INIT == buf->vb.state) {
-		buf->vb.width  = dev->ts_packet_size;
-		buf->vb.height = dev->ts_packet_count;
-		buf->vb.size   = size;
-		buf->vb.field  = field /*V4L2_FIELD_TOP*/;
-
-		if (0 != (rc = videobuf_iolock(q,&buf->vb,NULL)))
-			goto fail;
-		cx88_risc_databuffer(dev->pci, &buf->risc,
-				     dma->sglist,
-				     buf->vb.width, buf->vb.height, 0);
-	}
-	buf->vb.state = VIDEOBUF_PREPARED;
-	return 0;
+	rc = dma_map_sg(&dev->pci->dev, sgt->sgl, sgt->nents, DMA_FROM_DEVICE);
+	if (!rc)
+		return -EIO;
 
- fail:
-	cx88_free_buffer(q,buf);
-	return rc;
+	cx88_risc_databuffer(dev->pci, &buf->risc, sgt->sgl,
+			     dev->ts_packet_size, dev->ts_packet_count, 0);
+	return 0;
 }
 
 void cx8802_buf_queue(struct cx8802_dev *dev, struct cx88_buffer *buf)
@@ -261,35 +249,33 @@ void cx8802_buf_queue(struct cx8802_dev *dev, struct cx88_buffer *buf)
 	struct cx88_dmaqueue  *cx88q = &dev->mpegq;
 
 	dprintk( 1, "cx8802_buf_queue\n" );
-	/* add jump to stopper */
-	buf->risc.jmp[0] = cpu_to_le32(RISC_JUMP | RISC_IRQ1 | RISC_CNT_INC);
-	buf->risc.jmp[1] = cpu_to_le32(cx88q->stopper.dma);
+	/* add jump to start */
+	buf->risc.cpu[1] = cpu_to_le32(buf->risc.dma + 8);
+	buf->risc.jmp[0] = cpu_to_le32(RISC_JUMP | RISC_CNT_INC);
+	buf->risc.jmp[1] = cpu_to_le32(buf->risc.dma + 8);
 
 	if (list_empty(&cx88q->active)) {
 		dprintk( 1, "queue is empty - first active\n" );
-		list_add_tail(&buf->vb.queue,&cx88q->active);
-		cx8802_start_dma(dev, cx88q, buf);
-		buf->vb.state = VIDEOBUF_ACTIVE;
+		list_add_tail(&buf->list, &cx88q->active);
 		buf->count    = cx88q->count++;
-		mod_timer(&cx88q->timeout, jiffies+BUFFER_TIMEOUT);
 		dprintk(1,"[%p/%d] %s - first active\n",
-			buf, buf->vb.i, __func__);
+			buf, buf->vb.v4l2_buf.index, __func__);
 
 	} else {
+		buf->risc.cpu[0] |= cpu_to_le32(RISC_IRQ1);
 		dprintk( 1, "queue is not empty - append to active\n" );
-		prev = list_entry(cx88q->active.prev, struct cx88_buffer, vb.queue);
-		list_add_tail(&buf->vb.queue,&cx88q->active);
-		buf->vb.state = VIDEOBUF_ACTIVE;
+		prev = list_entry(cx88q->active.prev, struct cx88_buffer, list);
+		list_add_tail(&buf->list, &cx88q->active);
 		buf->count    = cx88q->count++;
 		prev->risc.jmp[1] = cpu_to_le32(buf->risc.dma);
 		dprintk( 1, "[%p/%d] %s - append to active\n",
-			buf, buf->vb.i, __func__);
+			buf, buf->vb.v4l2_buf.index, __func__);
 	}
 }
 
 /* ----------------------------------------------------------- */
 
-static void do_cancel_buffers(struct cx8802_dev *dev, const char *reason, int restart)
+static void do_cancel_buffers(struct cx8802_dev *dev)
 {
 	struct cx88_dmaqueue *q = &dev->mpegq;
 	struct cx88_buffer *buf;
@@ -297,41 +283,18 @@ static void do_cancel_buffers(struct cx8802_dev *dev, const char *reason, int re
 
 	spin_lock_irqsave(&dev->slock,flags);
 	while (!list_empty(&q->active)) {
-		buf = list_entry(q->active.next, struct cx88_buffer, vb.queue);
-		list_del(&buf->vb.queue);
-		buf->vb.state = VIDEOBUF_ERROR;
-		wake_up(&buf->vb.done);
-		dprintk(1,"[%p/%d] %s - dma=0x%08lx\n",
-			buf, buf->vb.i, reason, (unsigned long)buf->risc.dma);
-	}
-	if (restart)
-	{
-		dprintk(1, "restarting queue\n" );
-		cx8802_restart_queue(dev,q);
+		buf = list_entry(q->active.next, struct cx88_buffer, list);
+		list_del(&buf->list);
+		vb2_buffer_done(&buf->vb, VB2_BUF_STATE_ERROR);
 	}
 	spin_unlock_irqrestore(&dev->slock,flags);
 }
 
 void cx8802_cancel_buffers(struct cx8802_dev *dev)
 {
-	struct cx88_dmaqueue *q = &dev->mpegq;
-
 	dprintk( 1, "cx8802_cancel_buffers" );
-	del_timer_sync(&q->timeout);
-	cx8802_stop_dma(dev);
-	do_cancel_buffers(dev,"cancel",0);
-}
-
-static void cx8802_timeout(unsigned long data)
-{
-	struct cx8802_dev *dev = (struct cx8802_dev*)data;
-
-	dprintk(1, "%s\n",__func__);
-
-	if (debug)
-		cx88_sram_channel_dump(dev->core, &cx88_sram_channels[SRAM_CH28]);
 	cx8802_stop_dma(dev);
-	do_cancel_buffers(dev,"timeout",1);
+	do_cancel_buffers(dev);
 }
 
 static const char * cx88_mpeg_irqs[32] = {
@@ -377,19 +340,11 @@ static void cx8802_mpeg_irq(struct cx8802_dev *dev)
 		spin_unlock(&dev->slock);
 	}
 
-	/* risc2 y */
-	if (status & 0x10) {
-		spin_lock(&dev->slock);
-		cx8802_restart_queue(dev,&dev->mpegq);
-		spin_unlock(&dev->slock);
-	}
-
 	/* other general errors */
 	if (status & 0x1f0100) {
 		dprintk( 0, "general errors: 0x%08x\n", status & 0x1f0100 );
 		spin_lock(&dev->slock);
 		cx8802_stop_dma(dev);
-		cx8802_restart_queue(dev,&dev->mpegq);
 		spin_unlock(&dev->slock);
 	}
 }
@@ -456,11 +411,6 @@ static int cx8802_init_common(struct cx8802_dev *dev)
 
 	/* init dma queue */
 	INIT_LIST_HEAD(&dev->mpegq.active);
-	dev->mpegq.timeout.function = cx8802_timeout;
-	dev->mpegq.timeout.data     = (unsigned long)dev;
-	init_timer(&dev->mpegq.timeout);
-	cx88_risc_stopper(dev->pci,&dev->mpegq.stopper,
-			  MO_TS_DMACNTRL,0x11,0x00);
 
 	/* get irq */
 	err = request_irq(dev->pci->irq, cx8802_irq,
@@ -485,9 +435,6 @@ static void cx8802_fini_common(struct cx8802_dev *dev)
 
 	/* unregister stuff */
 	free_irq(dev->pci->irq, dev);
-
-	/* free memory */
-	btcx_riscmem_free(dev->pci,&dev->mpegq.stopper);
 }
 
 /* ----------------------------------------------------------- */
@@ -504,7 +451,6 @@ static int cx8802_suspend_common(struct pci_dev *pci_dev, pm_message_t state)
 		dprintk( 2, "suspend\n" );
 		printk("%s: suspend mpeg\n", core->name);
 		cx8802_stop_dma(dev);
-		del_timer(&dev->mpegq.timeout);
 	}
 	spin_unlock_irqrestore(&dev->slock, flags);
 
@@ -872,6 +818,7 @@ module_pci_driver(cx8802_pci_driver);
 EXPORT_SYMBOL(cx8802_buf_prepare);
 EXPORT_SYMBOL(cx8802_buf_queue);
 EXPORT_SYMBOL(cx8802_cancel_buffers);
+EXPORT_SYMBOL(cx8802_start_dma);
 
 EXPORT_SYMBOL(cx8802_register_driver);
 EXPORT_SYMBOL(cx8802_unregister_driver);

commit 6f11adc6a5e3378aeb13d9a19c427cbec05805be
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Sun Aug 10 11:56:14 2014 -0300

    [media] cx88: drop the bogus 'queue' list in dmaqueue
    
    This list is only used if the width, height and/or format of a buffer has
    changed, but that can never happen. Remove it and all associated code.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/pci/cx88/cx88-mpeg.c b/drivers/media/pci/cx88/cx88-mpeg.c
index 2803b6f17646..5f59901b2460 100644
--- a/drivers/media/pci/cx88/cx88-mpeg.c
+++ b/drivers/media/pci/cx88/cx88-mpeg.c
@@ -210,37 +210,7 @@ static int cx8802_restart_queue(struct cx8802_dev    *dev,
 
 	dprintk( 1, "cx8802_restart_queue\n" );
 	if (list_empty(&q->active))
-	{
-		struct cx88_buffer *prev;
-		prev = NULL;
-
-		dprintk(1, "cx8802_restart_queue: queue is empty\n" );
-
-		for (;;) {
-			if (list_empty(&q->queued))
-				return 0;
-			buf = list_entry(q->queued.next, struct cx88_buffer, vb.queue);
-			if (NULL == prev) {
-				list_move_tail(&buf->vb.queue, &q->active);
-				cx8802_start_dma(dev, q, buf);
-				buf->vb.state = VIDEOBUF_ACTIVE;
-				buf->count    = q->count++;
-				mod_timer(&q->timeout, jiffies+BUFFER_TIMEOUT);
-				dprintk(1,"[%p/%d] restart_queue - first active\n",
-					buf,buf->vb.i);
-
-			} else {
-				list_move_tail(&buf->vb.queue, &q->active);
-				buf->vb.state = VIDEOBUF_ACTIVE;
-				buf->count    = q->count++;
-				prev->risc.jmp[1] = cpu_to_le32(buf->risc.dma);
-				dprintk(1,"[%p/%d] restart_queue - move to active\n",
-					buf,buf->vb.i);
-			}
-			prev = buf;
-		}
 		return 0;
-	}
 
 	buf = list_entry(q->active.next, struct cx88_buffer, vb.queue);
 	dprintk(2,"restart_queue [%p/%d]: restart dma\n",
@@ -486,7 +456,6 @@ static int cx8802_init_common(struct cx8802_dev *dev)
 
 	/* init dma queue */
 	INIT_LIST_HEAD(&dev->mpegq.active);
-	INIT_LIST_HEAD(&dev->mpegq.queued);
 	dev->mpegq.timeout.function = cx8802_timeout;
 	dev->mpegq.timeout.data     = (unsigned long)dev;
 	init_timer(&dev->mpegq.timeout);

commit 637bc2079678e08476d884f02a5d5d3208b5c018
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Fri Aug 29 03:46:05 2014 -0300

    [media] cx88: remove fmt from the buffer struct
    
    This is a duplicate of dev->fmt and can be removed. As a consequence a
    lot of tests that check if the format has changed midstream can be
    removed as well: the format cannot change midstream, so this is a bogus
    check.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/pci/cx88/cx88-mpeg.c b/drivers/media/pci/cx88/cx88-mpeg.c
index 74b7b8614c23..2803b6f17646 100644
--- a/drivers/media/pci/cx88/cx88-mpeg.c
+++ b/drivers/media/pci/cx88/cx88-mpeg.c
@@ -229,17 +229,13 @@ static int cx8802_restart_queue(struct cx8802_dev    *dev,
 				dprintk(1,"[%p/%d] restart_queue - first active\n",
 					buf,buf->vb.i);
 
-			} else if (prev->vb.width  == buf->vb.width  &&
-				   prev->vb.height == buf->vb.height &&
-				   prev->fmt       == buf->fmt) {
+			} else {
 				list_move_tail(&buf->vb.queue, &q->active);
 				buf->vb.state = VIDEOBUF_ACTIVE;
 				buf->count    = q->count++;
 				prev->risc.jmp[1] = cpu_to_le32(buf->risc.dma);
 				dprintk(1,"[%p/%d] restart_queue - move to active\n",
 					buf,buf->vb.i);
-			} else {
-				return 0;
 			}
 			prev = buf;
 		}

commit 3e018fe4409eae6fb36b882cb0dfb39859b7c237
Author: Michael Opdenacker <michael.opdenacker@free-electrons.com>
Date:   Sun Oct 13 02:49:29 2013 -0300

    [media] misc drivers: remove deprecated IRQF_DISABLED
    
    This patch proposes to remove the use of the IRQF_DISABLED flag
    It's a NOOP since 2.6.35 and it will be removed one day.
    
    Signed-off-by: Michael Opdenacker <michael.opdenacker@free-electrons.com>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/drivers/media/pci/cx88/cx88-mpeg.c b/drivers/media/pci/cx88/cx88-mpeg.c
index 684eff57717f..74b7b8614c23 100644
--- a/drivers/media/pci/cx88/cx88-mpeg.c
+++ b/drivers/media/pci/cx88/cx88-mpeg.c
@@ -499,7 +499,7 @@ static int cx8802_init_common(struct cx8802_dev *dev)
 
 	/* get irq */
 	err = request_irq(dev->pci->irq, cx8802_irq,
-			  IRQF_SHARED | IRQF_DISABLED, dev->core->name, dev);
+			  IRQF_SHARED, dev->core->name, dev);
 	if (err < 0) {
 		printk(KERN_ERR "%s: can't get IRQ %d\n",
 		       dev->core->name, dev->pci->irq);

commit c0d4021f6ca04061f5b17a1468eed666ebe43e67
Author: Sachin Kamat <sachin.kamat@linaro.org>
Date:   Fri Sep 20 05:36:14 2013 -0300

    [media] pci: cx88: Remove redundant pci_set_drvdata
    
    Driver core sets driver data to NULL upon failure or remove.
    
    Signed-off-by: Sachin Kamat <sachin.kamat@linaro.org>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/drivers/media/pci/cx88/cx88-mpeg.c b/drivers/media/pci/cx88/cx88-mpeg.c
index e31a75fefbdf..684eff57717f 100644
--- a/drivers/media/pci/cx88/cx88-mpeg.c
+++ b/drivers/media/pci/cx88/cx88-mpeg.c
@@ -520,7 +520,6 @@ static void cx8802_fini_common(struct cx8802_dev *dev)
 
 	/* unregister stuff */
 	free_irq(dev->pci->irq, dev);
-	pci_set_drvdata(dev->pci, NULL);
 
 	/* free memory */
 	btcx_riscmem_free(dev->pci,&dev->mpegq.stopper);

commit 38b25adce8e5734aab4bb2eb168ee26d33186c7a
Author: Sachin Kamat <sachin.kamat@linaro.org>
Date:   Fri Sep 20 05:32:06 2013 -0300

    [media] pci: cx88-mpeg: Use module_pci_driver
    
    module_pci_driver removes some boilerplate and makes code simpler.
    
    Signed-off-by: Sachin Kamat <sachin.kamat@linaro.org>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/drivers/media/pci/cx88/cx88-mpeg.c b/drivers/media/pci/cx88/cx88-mpeg.c
index 2d3507eb4897..e31a75fefbdf 100644
--- a/drivers/media/pci/cx88/cx88-mpeg.c
+++ b/drivers/media/pci/cx88/cx88-mpeg.c
@@ -903,20 +903,8 @@ static struct pci_driver cx8802_pci_driver = {
 	.remove   = cx8802_remove,
 };
 
-static int __init cx8802_init(void)
-{
-	printk(KERN_INFO "cx88/2: cx2388x MPEG-TS Driver Manager version %s loaded\n",
-	       CX88_VERSION);
-	return pci_register_driver(&cx8802_pci_driver);
-}
-
-static void __exit cx8802_fini(void)
-{
-	pci_unregister_driver(&cx8802_pci_driver);
-}
+module_pci_driver(cx8802_pci_driver);
 
-module_init(cx8802_init);
-module_exit(cx8802_fini);
 EXPORT_SYMBOL(cx8802_buf_prepare);
 EXPORT_SYMBOL(cx8802_buf_queue);
 EXPORT_SYMBOL(cx8802_cancel_buffers);

commit 5ddfbbb9ca2e74d4b392ccef675641babba6b7f8
Author: Alexey Khoroshilov <khoroshilov@ispras.ru>
Date:   Sat Apr 13 18:52:04 2013 -0300

    [media] cx88: Fix unsafe locking in suspend-resume
    
    Legacy PCI suspend-resume handlers are called with interrupts enabled.
    
    But cx8800_suspend/cx8800_resume and
    cx8802_suspend_common/cx8802_resume_common use spin_lock/spin_unlock
    functions to acquire dev->slock, while the same lock is acquired in the
    corresponding irq-handlers: cx8800_irq and cx8802_irq.
    
    That means a deadlock is possible if an interrupt happens while suspend
    or resume owns the lock. The patch replaces spin_lock/spin_unlock with
    spin_lock_irqsave/spin_unlock_irqrestore.
    
    Found by Linux Driver Verification project (linuxtesting.org).
    
    [mchehab@redhat.com: Fix CodingStyle]
    Signed-off-by: Alexey Khoroshilov <khoroshilov@ispras.ru>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/pci/cx88/cx88-mpeg.c b/drivers/media/pci/cx88/cx88-mpeg.c
index c9d3182f79d5..2d3507eb4897 100644
--- a/drivers/media/pci/cx88/cx88-mpeg.c
+++ b/drivers/media/pci/cx88/cx88-mpeg.c
@@ -532,16 +532,17 @@ static int cx8802_suspend_common(struct pci_dev *pci_dev, pm_message_t state)
 {
 	struct cx8802_dev *dev = pci_get_drvdata(pci_dev);
 	struct cx88_core *core = dev->core;
+	unsigned long flags;
 
 	/* stop mpeg dma */
-	spin_lock(&dev->slock);
+	spin_lock_irqsave(&dev->slock, flags);
 	if (!list_empty(&dev->mpegq.active)) {
 		dprintk( 2, "suspend\n" );
 		printk("%s: suspend mpeg\n", core->name);
 		cx8802_stop_dma(dev);
 		del_timer(&dev->mpegq.timeout);
 	}
-	spin_unlock(&dev->slock);
+	spin_unlock_irqrestore(&dev->slock, flags);
 
 	/* FIXME -- shutdown device */
 	cx88_shutdown(dev->core);
@@ -558,6 +559,7 @@ static int cx8802_resume_common(struct pci_dev *pci_dev)
 {
 	struct cx8802_dev *dev = pci_get_drvdata(pci_dev);
 	struct cx88_core *core = dev->core;
+	unsigned long flags;
 	int err;
 
 	if (dev->state.disabled) {
@@ -584,12 +586,12 @@ static int cx8802_resume_common(struct pci_dev *pci_dev)
 	cx88_reset(dev->core);
 
 	/* restart video+vbi capture */
-	spin_lock(&dev->slock);
+	spin_lock_irqsave(&dev->slock, flags);
 	if (!list_empty(&dev->mpegq.active)) {
 		printk("%s: resume mpeg\n", core->name);
 		cx8802_restart_queue(dev,&dev->mpegq);
 	}
-	spin_unlock(&dev->slock);
+	spin_unlock_irqrestore(&dev->slock, flags);
 
 	return 0;
 }

commit 4c62e9764ab403d42f9b8871b1241fe7812f19d4
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Dec 21 13:17:53 2012 -0800

    Drivers: media: remove __dev* attributes.
    
    CONFIG_HOTPLUG is going away as an option.  As a result, the __dev*
    markings need to be removed.
    
    This change removes the use of __devinit, __devexit_p, __devinitdata,
    __devinitconst, and __devexit from these drivers.
    
    Based on patches originally written by Bill Pemberton, but redone by me
    in order to handle some of the coding style issues better, by hand.
    
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Mauro Carvalho Chehab <mchehab@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/media/pci/cx88/cx88-mpeg.c b/drivers/media/pci/cx88/cx88-mpeg.c
index d46b008a46b8..c9d3182f79d5 100644
--- a/drivers/media/pci/cx88/cx88-mpeg.c
+++ b/drivers/media/pci/cx88/cx88-mpeg.c
@@ -791,8 +791,8 @@ int cx8802_unregister_driver(struct cx8802_driver *drv)
 }
 
 /* ----------------------------------------------------------- */
-static int __devinit cx8802_probe(struct pci_dev *pci_dev,
-			       const struct pci_device_id *pci_id)
+static int cx8802_probe(struct pci_dev *pci_dev,
+			const struct pci_device_id *pci_id)
 {
 	struct cx8802_dev *dev;
 	struct cx88_core  *core;
@@ -840,7 +840,7 @@ static int __devinit cx8802_probe(struct pci_dev *pci_dev,
 	return err;
 }
 
-static void __devexit cx8802_remove(struct pci_dev *pci_dev)
+static void cx8802_remove(struct pci_dev *pci_dev)
 {
 	struct cx8802_dev *dev;
 
@@ -898,7 +898,7 @@ static struct pci_driver cx8802_pci_driver = {
 	.name     = "cx88-mpeg driver manager",
 	.id_table = cx8802_pci_tbl,
 	.probe    = cx8802_probe,
-	.remove   = __devexit_p(cx8802_remove),
+	.remove   = cx8802_remove,
 };
 
 static int __init cx8802_init(void)

commit db61371079f898db856b8c4537c261ba0dbe626f
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Sat Oct 27 15:25:02 2012 -0300

    [media] cx88: get rid of a warning at dprintk() macro
    
    drivers/media/pci/cx88/cx88-mpeg.c: In function 'cx8802_mpeg_irq':
    drivers/media/pci/cx88/cx88-mpeg.c:419:3: warning: comparison of unsigned expression >= 0 is always true [-Wtype-limits]
    drivers/media/pci/cx88/cx88-mpeg.c: In function 'cx8802_irq':
    drivers/media/pci/cx88/cx88-mpeg.c:453:3: warning: comparison of unsigned expression >= 0 is always true [-Wtype-limits]
    drivers/media/pci/cx88/cx88-alsa.c: In function 'snd_cx88_create':
    drivers/media/pci/cx88/cx88-alsa.c:818:3: warning: comparison of unsigned expression >= 0 is always true [-Wtype-limits]
    drivers/media/pci/cx88/cx88-alsa.c:837:3: warning: comparison of unsigned expression >= 0 is always true [-Wtype-limits]
    drivers/media/pci/cx88/cx88-alsa.c: In function 'cx88_audio_initdev':
    drivers/media/pci/cx88/cx88-alsa.c:912:2: warning: comparison of unsigned expression >= 0 is always true [-Wtype-limits]
    drivers/media/pci/cx88/cx88-blackbird.c: In function 'blackbird_mbox_func':
    drivers/media/pci/cx88/cx88-blackbird.c:327:3: warning: comparison of unsigned expression >= 0 is always true [-Wtype-limits]
    drivers/media/pci/cx88/cx88-blackbird.c:333:3: warning: comparison of unsigned expression >= 0 is always true [-Wtype-limits]
    drivers/media/pci/cx88/cx88-blackbird.c:360:4: warning: comparison of unsigned expression >= 0 is always true [-Wtype-limits]
    drivers/media/pci/cx88/cx88-blackbird.c: In function 'blackbird_find_mailbox':
    drivers/media/pci/cx88/cx88-blackbird.c:421:2: warning: comparison of unsigned expression >= 0 is always true [-Wtype-limits]
    drivers/media/pci/cx88/cx88-blackbird.c: In function 'blackbird_load_firmware':
    drivers/media/pci/cx88/cx88-blackbird.c:444:3: warning: comparison of unsigned expression >= 0 is always true [-Wtype-limits]
    drivers/media/pci/cx88/cx88-blackbird.c:451:3: warning: comparison of unsigned expression >= 0 is always true [-Wtype-limits]
    drivers/media/pci/cx88/cx88-blackbird.c:453:3: warning: comparison of unsigned expression >= 0 is always true [-Wtype-limits]
    drivers/media/pci/cx88/cx88-blackbird.c:459:3: warning: comparison of unsigned expression >= 0 is always true [-Wtype-limits]
    drivers/media/pci/cx88/cx88-blackbird.c:466:3: warning: comparison of unsigned expression >= 0 is always true [-Wtype-limits]
    drivers/media/pci/cx88/cx88-blackbird.c:487:3: warning: comparison of unsigned expression >= 0 is always true [-Wtype-limits]
    drivers/media/pci/cx88/cx88-blackbird.c:492:2: warning: comparison of unsigned expression >= 0 is always true [-Wtype-limits]
    drivers/media/pci/cx88/cx88-blackbird.c:503:3: warning: comparison of unsigned expression >= 0 is always true [-Wtype-limits]
    drivers/media/pci/cx88/cx88-blackbird.c: In function 'blackbird_initialize_codec':
    drivers/media/pci/cx88/cx88-blackbird.c:560:4: warning: comparison of unsigned expression >= 0 is always true [-Wtype-limits]
    drivers/media/pci/cx88/cx88-blackbird.c:566:4: warning: comparison of unsigned expression >= 0 is always true [-Wtype-limits]
    drivers/media/pci/cx88/cx88-blackbird.c:569:3: warning: comparison of unsigned expression >= 0 is always true [-Wtype-limits]
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/pci/cx88/cx88-mpeg.c b/drivers/media/pci/cx88/cx88-mpeg.c
index 1b7e979b87d3..d46b008a46b8 100644
--- a/drivers/media/pci/cx88/cx88-mpeg.c
+++ b/drivers/media/pci/cx88/cx88-mpeg.c
@@ -45,11 +45,15 @@ static unsigned int debug;
 module_param(debug,int,0644);
 MODULE_PARM_DESC(debug,"enable debug messages [mpeg]");
 
-#define dprintk(level,fmt, arg...)	if (debug >= level) \
-	printk(KERN_DEBUG "%s/2-mpeg: " fmt, dev->core->name, ## arg)
-
-#define mpeg_dbg(level,fmt, arg...)	if (debug >= level) \
-	printk(KERN_DEBUG "%s/2-mpeg: " fmt, core->name, ## arg)
+#define dprintk(level, fmt, arg...) do {				       \
+	if (debug + 1 > level)						       \
+		printk(KERN_DEBUG "%s/2-mpeg: " fmt, dev->core->name, ## arg); \
+} while(0)
+
+#define mpeg_dbg(level, fmt, arg...) do {				  \
+	if (debug + 1 > level)						  \
+		printk(KERN_DEBUG "%s/2-mpeg: " fmt, core->name, ## arg); \
+} while(0)
 
 #if defined(CONFIG_MODULES) && defined(MODULE)
 static void request_module_async(struct work_struct *work)

commit 8d6b12501a7ebc59c309b32457192bba93334e0b
Author: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
Date:   Mon Oct 8 08:33:49 2012 -0300

    [media] cx88: use list_move_tail instead of list_del/list_add_tail
    
    Using list_move_tail() instead of list_del() + list_add_tail().
    dpatch engine is used to auto generate this patch.
    (https://github.com/weiyj/dpatch)
    
    Signed-off-by: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/pci/cx88/cx88-mpeg.c b/drivers/media/pci/cx88/cx88-mpeg.c
index d154bc197356..1b7e979b87d3 100644
--- a/drivers/media/pci/cx88/cx88-mpeg.c
+++ b/drivers/media/pci/cx88/cx88-mpeg.c
@@ -217,8 +217,7 @@ static int cx8802_restart_queue(struct cx8802_dev    *dev,
 				return 0;
 			buf = list_entry(q->queued.next, struct cx88_buffer, vb.queue);
 			if (NULL == prev) {
-				list_del(&buf->vb.queue);
-				list_add_tail(&buf->vb.queue,&q->active);
+				list_move_tail(&buf->vb.queue, &q->active);
 				cx8802_start_dma(dev, q, buf);
 				buf->vb.state = VIDEOBUF_ACTIVE;
 				buf->count    = q->count++;
@@ -229,8 +228,7 @@ static int cx8802_restart_queue(struct cx8802_dev    *dev,
 			} else if (prev->vb.width  == buf->vb.width  &&
 				   prev->vb.height == buf->vb.height &&
 				   prev->fmt       == buf->fmt) {
-				list_del(&buf->vb.queue);
-				list_add_tail(&buf->vb.queue,&q->active);
+				list_move_tail(&buf->vb.queue, &q->active);
 				buf->vb.state = VIDEOBUF_ACTIVE;
 				buf->count    = q->count++;
 				prev->risc.jmp[1] = cpu_to_le32(buf->risc.dma);

commit bf3b202b41999f88f091632f13842b7234bd58b7
Merge: 782cd9ee985b 1fdead8ad31d
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Thu Oct 11 15:07:19 2012 -0300

    Merge branch 'staging/for_v3.7' into v4l_for_linus
    
    Applied on the top of changeset 782cd9e, as some of those patches
    depend on some fixes that went via -arm tree.
    
    * staging/for_v3.7: (109 commits)
      [media] m5mols: Add missing #include <linux/sizes.h>
      [media] stk1160: Add support for S-Video input
      Revert "[media] omap3isp: Replace cpu_is_omap3630() with ISP revision check"
      [media]  dvb: LNA implementation changes
      [media] v4l2-ioctl: fix W=1 warnings
      [media] v4l2-ioctl: add blocks check for VIDIOC_SUBDEV_G/S_EDID
      [media] omap3isp: Fix compilation error in ispreg.h
      [media] rc-msi-digivox-ii: Add full scan keycodes
      [media] cx25821: testing the wrong variable
      [media] tda18271-common: hold the I2C adapter during write transfers
      [media] ds3000: add module parameter to force firmware upload
      [media] drivers/media: Remove unnecessary semicolon
      [media] winbond: remove space from driver name
      [media] iguanair: cannot send data from the stack
      [media] omap3isp: Replace cpu_is_omap3630() with ISP revision check
      [media] dvb-usb: print small buffers via %*ph
      [media] uvc: Add return code check at vb2_queue_init()
      [media] em28xx: Replace memcpy with struct assignment
      [media] bt8xx: Add video4linux control V4L2_CID_COLOR_KILLER
      [media] mem2mem_testdev: Use devm_kzalloc() in probe
      ...

commit c2c1b4156a447f113ef4d167decce29399c2667c
Author: Peter Senna Tschudin <peter.senna@gmail.com>
Date:   Fri Sep 28 05:37:22 2012 -0300

    [media] drivers/media: Remove unnecessary semicolon
    
    A simplified version of the semantic patch that finds this problem is as
    follows: (http://coccinelle.lip6.fr/)
    // <smpl>
    @r1@
    statement S;
    position p,p1;
    @@
    S@p1;@p
    @script:python r2@
    p << r1.p;
    p1 << r1.p1;
    @@
    if p[0].line != p1[0].line_end:
            cocci.include_match(False)
    @@
    position r1.p;
    @@
    -;@p
    // </smpl>
    
    [mchehab@redhat.com: some hunks got bitroted; applied only the
     ones that succeeds]
    Signed-off-by: Peter Senna Tschudin <peter.senna@gmail.com>
    [crope@iki.fi: For my drivers a8293, af9013, af9015, af9035]
    Acked-by: Antti Palosaari <crope@iki.fi>
    Reviewed-by: Antti Palosaari <crope@iki.fi>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/pci/cx88/cx88-mpeg.c b/drivers/media/pci/cx88/cx88-mpeg.c
index cd5386ee210c..95c0c47718fb 100644
--- a/drivers/media/pci/cx88/cx88-mpeg.c
+++ b/drivers/media/pci/cx88/cx88-mpeg.c
@@ -450,7 +450,7 @@ static irqreturn_t cx8802_irq(int irq, void *dev_id)
 			cx88_core_irq(core,status);
 		if (status & PCI_INT_TSINT)
 			cx8802_mpeg_irq(dev);
-	};
+	}
 	if (MAX_IRQ_LOOP == loop) {
 		dprintk( 0, "clearing mask\n" );
 		printk(KERN_WARNING "%s/0: irq loop -- clearing mask\n",

commit 0b8e74c6f44094189dbe78baf4101acc7570c6af
Merge: 7f60ba388f5b bd0d10498826
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Oct 7 17:49:05 2012 +0900

    Merge branch 'v4l_for_linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mchehab/linux-media
    
    Pull media updates from Mauro Carvalho Chehab:
     "The first part of the media updates for Kernel 3.7.
    
      This series contain:
    
       - A major tree renaming patch series: now, drivers are organized
         internally by their used bus, instead of by V4L2 and/or DVB API,
         providing a cleaner driver location for hybrid drivers that
         implement both APIs, and allowing to cleanup the Kconfig items and
         make them more intuitive for the end user;
    
       - Media Kernel developers are typically very lazy with their duties
         of keeping the MAINTAINERS entries for their drivers updated.  As
         now the tree is more organized, we're doing an effort to add/update
         those entries for the drivers that aren't currently orphan;
    
       - Several DVB USB drivers got moved to a new DVB USB v2 core; the new
         core fixes several bugs (as the existing one that got bitroted).
         Now, suspend/resume finally started to work fine (at least with
         some devices - we should expect more work with regards to it);
    
       - added multistream support for DVB-T2, and unified the API for
         DVB-S2 and ISDB-S.  Backward binary support is preserved;
    
       - as usual, a few new drivers, some V4L2 core improvements and lots
         of drivers improvements and fixes.
    
      There are some points to notice on this series:
    
       1) you should expect a trivial merge conflict on your tree, with the
          removal of Documentation/feature-removal-schedule.txt: this series
          would be adding two additional entries there.  I opted to not
          rebase it due to this recent change;
    
       2) With regards to the PCTV 520e udev-related breakage, I opted to
          fix it in a way that the patches can be backported to 3.5 even
          without your firmware fix patch.  This way, Greg doesn't need to
          rush backporting your patch (as there are still the firmware cache
          and firmware path customization issues to be addressed there).
    
          I'll send later a patch (likely after the end of the merge window)
          reverting the rest of the DRX-K async firmware request, fully
          restoring its original behaviour to allow media drivers to
          initialize everything serialized as before for 3.7 and upper.
    
       3) I'm planning to work on this weekend to test the DMABUF patches
          for V4L2.  The patches are on my queue for several Kernel cycles,
          but, up to now, there is/was no way to test the series locally.
    
          I have some concerns about this particular changeset with regards
          to security issues, and with regards to the replacement of the old
          VIDIOC_OVERLAY ioctl's that is broken on modern systems, due to
          GPU drivers change.  The Overlay API allows direct PCI2PCI
          transfers from a media capture card into the GPU framebuffer, but
          its API is crappy.  Also, the only existing X11 driver that
          implements it requires a XV extension that is not available
          anymore on modern drivers.  The DMABUF can do the same thing, but
          with it is promising to be a properly-designed API.  If I can
          successfully test this series and be happy with it, I should be
          asking you to pull them next week."
    
    * 'v4l_for_linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mchehab/linux-media: (717 commits)
      em28xx: regression fix: use DRX-K sync firmware requests on em28xx
      drxk: allow loading firmware synchrousnously
      em28xx: Make all em28xx extensions to be initialized asynchronously
      [media] tda18271: properly report read errors in tda18271_get_id
      [media] tda18271: delay IR & RF calibration until init() if delay_cal is set
      [media] MAINTAINERS: add Michael Krufky as tda827x maintainer
      [media] MAINTAINERS: add Michael Krufky as tda8290 maintainer
      [media] MAINTAINERS: add Michael Krufky as cxusb maintainer
      [media] MAINTAINERS: add Michael Krufky as lg2160 maintainer
      [media] MAINTAINERS: add Michael Krufky as lgdt3305 maintainer
      [media] MAINTAINERS: add Michael Krufky as mxl111sf maintainer
      [media] MAINTAINERS: add Michael Krufky as mxl5007t maintainer
      [media] MAINTAINERS: add Michael Krufky as tda18271 maintainer
      [media] s5p-tv: Report only multi-plane capabilities in vidioc_querycap
      [media] s5p-mfc: Fix misplaced return statement in s5p_mfc_suspend()
      [media] exynos-gsc: Add missing static storage class specifiers
      [media] exynos-gsc: Remove <linux/version.h> header file inclusion
      [media] s5p-fimc: Fix incorrect condition in fimc_lite_reqbufs()
      [media] s5p-tv: Fix potential NULL pointer dereference error
      [media] s5k6aa: Fix possible NULL pointer dereference
      ...

commit b285192a43f0432d82c2c10974204e78af0da596
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Tue Aug 14 12:13:30 2012 -0300

    [media] rename most media/video pci drivers to media/pci
    
    Rename all PCI drivers with their own directory under
    drivers/media/video into drivers/media/pci and update the
    building system.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/pci/cx88/cx88-mpeg.c b/drivers/media/pci/cx88/cx88-mpeg.c
new file mode 100644
index 000000000000..cd5386ee210c
--- /dev/null
+++ b/drivers/media/pci/cx88/cx88-mpeg.c
@@ -0,0 +1,929 @@
+/*
+ *
+ *  Support for the mpeg transport stream transfers
+ *  PCI function #2 of the cx2388x.
+ *
+ *    (c) 2004 Jelle Foks <jelle@foks.us>
+ *    (c) 2004 Chris Pascoe <c.pascoe@itee.uq.edu.au>
+ *    (c) 2004 Gerd Knorr <kraxel@bytesex.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/dma-mapping.h>
+#include <linux/interrupt.h>
+#include <asm/delay.h>
+
+#include "cx88.h"
+
+/* ------------------------------------------------------------------ */
+
+MODULE_DESCRIPTION("mpeg driver for cx2388x based TV cards");
+MODULE_AUTHOR("Jelle Foks <jelle@foks.us>");
+MODULE_AUTHOR("Chris Pascoe <c.pascoe@itee.uq.edu.au>");
+MODULE_AUTHOR("Gerd Knorr <kraxel@bytesex.org> [SuSE Labs]");
+MODULE_LICENSE("GPL");
+MODULE_VERSION(CX88_VERSION);
+
+static unsigned int debug;
+module_param(debug,int,0644);
+MODULE_PARM_DESC(debug,"enable debug messages [mpeg]");
+
+#define dprintk(level,fmt, arg...)	if (debug >= level) \
+	printk(KERN_DEBUG "%s/2-mpeg: " fmt, dev->core->name, ## arg)
+
+#define mpeg_dbg(level,fmt, arg...)	if (debug >= level) \
+	printk(KERN_DEBUG "%s/2-mpeg: " fmt, core->name, ## arg)
+
+#if defined(CONFIG_MODULES) && defined(MODULE)
+static void request_module_async(struct work_struct *work)
+{
+	struct cx8802_dev *dev=container_of(work, struct cx8802_dev, request_module_wk);
+
+	if (dev->core->board.mpeg & CX88_MPEG_DVB)
+		request_module("cx88-dvb");
+	if (dev->core->board.mpeg & CX88_MPEG_BLACKBIRD)
+		request_module("cx88-blackbird");
+}
+
+static void request_modules(struct cx8802_dev *dev)
+{
+	INIT_WORK(&dev->request_module_wk, request_module_async);
+	schedule_work(&dev->request_module_wk);
+}
+
+static void flush_request_modules(struct cx8802_dev *dev)
+{
+	flush_work_sync(&dev->request_module_wk);
+}
+#else
+#define request_modules(dev)
+#define flush_request_modules(dev)
+#endif /* CONFIG_MODULES */
+
+
+static LIST_HEAD(cx8802_devlist);
+static DEFINE_MUTEX(cx8802_mutex);
+/* ------------------------------------------------------------------ */
+
+static int cx8802_start_dma(struct cx8802_dev    *dev,
+			    struct cx88_dmaqueue *q,
+			    struct cx88_buffer   *buf)
+{
+	struct cx88_core *core = dev->core;
+
+	dprintk(1, "cx8802_start_dma w: %d, h: %d, f: %d\n",
+		buf->vb.width, buf->vb.height, buf->vb.field);
+
+	/* setup fifo + format */
+	cx88_sram_channel_setup(core, &cx88_sram_channels[SRAM_CH28],
+				dev->ts_packet_size, buf->risc.dma);
+
+	/* write TS length to chip */
+	cx_write(MO_TS_LNGTH, buf->vb.width);
+
+	/* FIXME: this needs a review.
+	 * also: move to cx88-blackbird + cx88-dvb source files? */
+
+	dprintk( 1, "core->active_type_id = 0x%08x\n", core->active_type_id);
+
+	if ( (core->active_type_id == CX88_MPEG_DVB) &&
+		(core->board.mpeg & CX88_MPEG_DVB) ) {
+
+		dprintk( 1, "cx8802_start_dma doing .dvb\n");
+		/* negedge driven & software reset */
+		cx_write(TS_GEN_CNTRL, 0x0040 | dev->ts_gen_cntrl);
+		udelay(100);
+		cx_write(MO_PINMUX_IO, 0x00);
+		cx_write(TS_HW_SOP_CNTRL, 0x47<<16|188<<4|0x01);
+		switch (core->boardnr) {
+		case CX88_BOARD_DVICO_FUSIONHDTV_3_GOLD_Q:
+		case CX88_BOARD_DVICO_FUSIONHDTV_3_GOLD_T:
+		case CX88_BOARD_DVICO_FUSIONHDTV_5_GOLD:
+		case CX88_BOARD_PCHDTV_HD5500:
+			cx_write(TS_SOP_STAT, 1<<13);
+			break;
+		case CX88_BOARD_SAMSUNG_SMT_7020:
+			cx_write(TS_SOP_STAT, 0x00);
+			break;
+		case CX88_BOARD_HAUPPAUGE_NOVASPLUS_S1:
+		case CX88_BOARD_HAUPPAUGE_NOVASE2_S1:
+			cx_write(MO_PINMUX_IO, 0x88); /* Enable MPEG parallel IO and video signal pins */
+			udelay(100);
+			break;
+		case CX88_BOARD_HAUPPAUGE_HVR1300:
+			/* Enable MPEG parallel IO and video signal pins */
+			cx_write(MO_PINMUX_IO, 0x88);
+			cx_write(TS_SOP_STAT, 0);
+			cx_write(TS_VALERR_CNTRL, 0);
+			break;
+		case CX88_BOARD_PINNACLE_PCTV_HD_800i:
+			/* Enable MPEG parallel IO and video signal pins */
+			cx_write(MO_PINMUX_IO, 0x88);
+			cx_write(TS_HW_SOP_CNTRL, (0x47 << 16) | (188 << 4));
+			dev->ts_gen_cntrl = 5;
+			cx_write(TS_SOP_STAT, 0);
+			cx_write(TS_VALERR_CNTRL, 0);
+			udelay(100);
+			break;
+		default:
+			cx_write(TS_SOP_STAT, 0x00);
+			break;
+		}
+		cx_write(TS_GEN_CNTRL, dev->ts_gen_cntrl);
+		udelay(100);
+	} else if ( (core->active_type_id == CX88_MPEG_BLACKBIRD) &&
+		(core->board.mpeg & CX88_MPEG_BLACKBIRD) ) {
+		dprintk( 1, "cx8802_start_dma doing .blackbird\n");
+		cx_write(MO_PINMUX_IO, 0x88); /* enable MPEG parallel IO */
+
+		cx_write(TS_GEN_CNTRL, 0x46); /* punctured clock TS & posedge driven & software reset */
+		udelay(100);
+
+		cx_write(TS_HW_SOP_CNTRL, 0x408); /* mpeg start byte */
+		cx_write(TS_VALERR_CNTRL, 0x2000);
+
+		cx_write(TS_GEN_CNTRL, 0x06); /* punctured clock TS & posedge driven */
+		udelay(100);
+	} else {
+		printk( "%s() Failed. Unsupported value in .mpeg (0x%08x)\n", __func__,
+			core->board.mpeg );
+		return -EINVAL;
+	}
+
+	/* reset counter */
+	cx_write(MO_TS_GPCNTRL, GP_COUNT_CONTROL_RESET);
+	q->count = 1;
+
+	/* enable irqs */
+	dprintk( 1, "setting the interrupt mask\n" );
+	cx_set(MO_PCI_INTMSK, core->pci_irqmask | PCI_INT_TSINT);
+	cx_set(MO_TS_INTMSK,  0x1f0011);
+
+	/* start dma */
+	cx_set(MO_DEV_CNTRL2, (1<<5));
+	cx_set(MO_TS_DMACNTRL, 0x11);
+	return 0;
+}
+
+static int cx8802_stop_dma(struct cx8802_dev *dev)
+{
+	struct cx88_core *core = dev->core;
+	dprintk( 1, "cx8802_stop_dma\n" );
+
+	/* stop dma */
+	cx_clear(MO_TS_DMACNTRL, 0x11);
+
+	/* disable irqs */
+	cx_clear(MO_PCI_INTMSK, PCI_INT_TSINT);
+	cx_clear(MO_TS_INTMSK, 0x1f0011);
+
+	/* Reset the controller */
+	cx_write(TS_GEN_CNTRL, 0xcd);
+	return 0;
+}
+
+static int cx8802_restart_queue(struct cx8802_dev    *dev,
+				struct cx88_dmaqueue *q)
+{
+	struct cx88_buffer *buf;
+
+	dprintk( 1, "cx8802_restart_queue\n" );
+	if (list_empty(&q->active))
+	{
+		struct cx88_buffer *prev;
+		prev = NULL;
+
+		dprintk(1, "cx8802_restart_queue: queue is empty\n" );
+
+		for (;;) {
+			if (list_empty(&q->queued))
+				return 0;
+			buf = list_entry(q->queued.next, struct cx88_buffer, vb.queue);
+			if (NULL == prev) {
+				list_del(&buf->vb.queue);
+				list_add_tail(&buf->vb.queue,&q->active);
+				cx8802_start_dma(dev, q, buf);
+				buf->vb.state = VIDEOBUF_ACTIVE;
+				buf->count    = q->count++;
+				mod_timer(&q->timeout, jiffies+BUFFER_TIMEOUT);
+				dprintk(1,"[%p/%d] restart_queue - first active\n",
+					buf,buf->vb.i);
+
+			} else if (prev->vb.width  == buf->vb.width  &&
+				   prev->vb.height == buf->vb.height &&
+				   prev->fmt       == buf->fmt) {
+				list_del(&buf->vb.queue);
+				list_add_tail(&buf->vb.queue,&q->active);
+				buf->vb.state = VIDEOBUF_ACTIVE;
+				buf->count    = q->count++;
+				prev->risc.jmp[1] = cpu_to_le32(buf->risc.dma);
+				dprintk(1,"[%p/%d] restart_queue - move to active\n",
+					buf,buf->vb.i);
+			} else {
+				return 0;
+			}
+			prev = buf;
+		}
+		return 0;
+	}
+
+	buf = list_entry(q->active.next, struct cx88_buffer, vb.queue);
+	dprintk(2,"restart_queue [%p/%d]: restart dma\n",
+		buf, buf->vb.i);
+	cx8802_start_dma(dev, q, buf);
+	list_for_each_entry(buf, &q->active, vb.queue)
+		buf->count = q->count++;
+	mod_timer(&q->timeout, jiffies+BUFFER_TIMEOUT);
+	return 0;
+}
+
+/* ------------------------------------------------------------------ */
+
+int cx8802_buf_prepare(struct videobuf_queue *q, struct cx8802_dev *dev,
+			struct cx88_buffer *buf, enum v4l2_field field)
+{
+	int size = dev->ts_packet_size * dev->ts_packet_count;
+	struct videobuf_dmabuf *dma=videobuf_to_dma(&buf->vb);
+	int rc;
+
+	dprintk(1, "%s: %p\n", __func__, buf);
+	if (0 != buf->vb.baddr  &&  buf->vb.bsize < size)
+		return -EINVAL;
+
+	if (VIDEOBUF_NEEDS_INIT == buf->vb.state) {
+		buf->vb.width  = dev->ts_packet_size;
+		buf->vb.height = dev->ts_packet_count;
+		buf->vb.size   = size;
+		buf->vb.field  = field /*V4L2_FIELD_TOP*/;
+
+		if (0 != (rc = videobuf_iolock(q,&buf->vb,NULL)))
+			goto fail;
+		cx88_risc_databuffer(dev->pci, &buf->risc,
+				     dma->sglist,
+				     buf->vb.width, buf->vb.height, 0);
+	}
+	buf->vb.state = VIDEOBUF_PREPARED;
+	return 0;
+
+ fail:
+	cx88_free_buffer(q,buf);
+	return rc;
+}
+
+void cx8802_buf_queue(struct cx8802_dev *dev, struct cx88_buffer *buf)
+{
+	struct cx88_buffer    *prev;
+	struct cx88_dmaqueue  *cx88q = &dev->mpegq;
+
+	dprintk( 1, "cx8802_buf_queue\n" );
+	/* add jump to stopper */
+	buf->risc.jmp[0] = cpu_to_le32(RISC_JUMP | RISC_IRQ1 | RISC_CNT_INC);
+	buf->risc.jmp[1] = cpu_to_le32(cx88q->stopper.dma);
+
+	if (list_empty(&cx88q->active)) {
+		dprintk( 1, "queue is empty - first active\n" );
+		list_add_tail(&buf->vb.queue,&cx88q->active);
+		cx8802_start_dma(dev, cx88q, buf);
+		buf->vb.state = VIDEOBUF_ACTIVE;
+		buf->count    = cx88q->count++;
+		mod_timer(&cx88q->timeout, jiffies+BUFFER_TIMEOUT);
+		dprintk(1,"[%p/%d] %s - first active\n",
+			buf, buf->vb.i, __func__);
+
+	} else {
+		dprintk( 1, "queue is not empty - append to active\n" );
+		prev = list_entry(cx88q->active.prev, struct cx88_buffer, vb.queue);
+		list_add_tail(&buf->vb.queue,&cx88q->active);
+		buf->vb.state = VIDEOBUF_ACTIVE;
+		buf->count    = cx88q->count++;
+		prev->risc.jmp[1] = cpu_to_le32(buf->risc.dma);
+		dprintk( 1, "[%p/%d] %s - append to active\n",
+			buf, buf->vb.i, __func__);
+	}
+}
+
+/* ----------------------------------------------------------- */
+
+static void do_cancel_buffers(struct cx8802_dev *dev, const char *reason, int restart)
+{
+	struct cx88_dmaqueue *q = &dev->mpegq;
+	struct cx88_buffer *buf;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dev->slock,flags);
+	while (!list_empty(&q->active)) {
+		buf = list_entry(q->active.next, struct cx88_buffer, vb.queue);
+		list_del(&buf->vb.queue);
+		buf->vb.state = VIDEOBUF_ERROR;
+		wake_up(&buf->vb.done);
+		dprintk(1,"[%p/%d] %s - dma=0x%08lx\n",
+			buf, buf->vb.i, reason, (unsigned long)buf->risc.dma);
+	}
+	if (restart)
+	{
+		dprintk(1, "restarting queue\n" );
+		cx8802_restart_queue(dev,q);
+	}
+	spin_unlock_irqrestore(&dev->slock,flags);
+}
+
+void cx8802_cancel_buffers(struct cx8802_dev *dev)
+{
+	struct cx88_dmaqueue *q = &dev->mpegq;
+
+	dprintk( 1, "cx8802_cancel_buffers" );
+	del_timer_sync(&q->timeout);
+	cx8802_stop_dma(dev);
+	do_cancel_buffers(dev,"cancel",0);
+}
+
+static void cx8802_timeout(unsigned long data)
+{
+	struct cx8802_dev *dev = (struct cx8802_dev*)data;
+
+	dprintk(1, "%s\n",__func__);
+
+	if (debug)
+		cx88_sram_channel_dump(dev->core, &cx88_sram_channels[SRAM_CH28]);
+	cx8802_stop_dma(dev);
+	do_cancel_buffers(dev,"timeout",1);
+}
+
+static const char * cx88_mpeg_irqs[32] = {
+	"ts_risci1", NULL, NULL, NULL,
+	"ts_risci2", NULL, NULL, NULL,
+	"ts_oflow",  NULL, NULL, NULL,
+	"ts_sync",   NULL, NULL, NULL,
+	"opc_err", "par_err", "rip_err", "pci_abort",
+	"ts_err?",
+};
+
+static void cx8802_mpeg_irq(struct cx8802_dev *dev)
+{
+	struct cx88_core *core = dev->core;
+	u32 status, mask, count;
+
+	dprintk( 1, "cx8802_mpeg_irq\n" );
+	status = cx_read(MO_TS_INTSTAT);
+	mask   = cx_read(MO_TS_INTMSK);
+	if (0 == (status & mask))
+		return;
+
+	cx_write(MO_TS_INTSTAT, status);
+
+	if (debug || (status & mask & ~0xff))
+		cx88_print_irqbits(core->name, "irq mpeg ",
+				   cx88_mpeg_irqs, ARRAY_SIZE(cx88_mpeg_irqs),
+				   status, mask);
+
+	/* risc op code error */
+	if (status & (1 << 16)) {
+		printk(KERN_WARNING "%s: mpeg risc op code error\n",core->name);
+		cx_clear(MO_TS_DMACNTRL, 0x11);
+		cx88_sram_channel_dump(dev->core, &cx88_sram_channels[SRAM_CH28]);
+	}
+
+	/* risc1 y */
+	if (status & 0x01) {
+		dprintk( 1, "wake up\n" );
+		spin_lock(&dev->slock);
+		count = cx_read(MO_TS_GPCNT);
+		cx88_wakeup(dev->core, &dev->mpegq, count);
+		spin_unlock(&dev->slock);
+	}
+
+	/* risc2 y */
+	if (status & 0x10) {
+		spin_lock(&dev->slock);
+		cx8802_restart_queue(dev,&dev->mpegq);
+		spin_unlock(&dev->slock);
+	}
+
+	/* other general errors */
+	if (status & 0x1f0100) {
+		dprintk( 0, "general errors: 0x%08x\n", status & 0x1f0100 );
+		spin_lock(&dev->slock);
+		cx8802_stop_dma(dev);
+		cx8802_restart_queue(dev,&dev->mpegq);
+		spin_unlock(&dev->slock);
+	}
+}
+
+#define MAX_IRQ_LOOP 10
+
+static irqreturn_t cx8802_irq(int irq, void *dev_id)
+{
+	struct cx8802_dev *dev = dev_id;
+	struct cx88_core *core = dev->core;
+	u32 status;
+	int loop, handled = 0;
+
+	for (loop = 0; loop < MAX_IRQ_LOOP; loop++) {
+		status = cx_read(MO_PCI_INTSTAT) &
+			(core->pci_irqmask | PCI_INT_TSINT);
+		if (0 == status)
+			goto out;
+		dprintk( 1, "cx8802_irq\n" );
+		dprintk( 1, "    loop: %d/%d\n", loop, MAX_IRQ_LOOP );
+		dprintk( 1, "    status: %d\n", status );
+		handled = 1;
+		cx_write(MO_PCI_INTSTAT, status);
+
+		if (status & core->pci_irqmask)
+			cx88_core_irq(core,status);
+		if (status & PCI_INT_TSINT)
+			cx8802_mpeg_irq(dev);
+	};
+	if (MAX_IRQ_LOOP == loop) {
+		dprintk( 0, "clearing mask\n" );
+		printk(KERN_WARNING "%s/0: irq loop -- clearing mask\n",
+		       core->name);
+		cx_write(MO_PCI_INTMSK,0);
+	}
+
+ out:
+	return IRQ_RETVAL(handled);
+}
+
+static int cx8802_init_common(struct cx8802_dev *dev)
+{
+	struct cx88_core *core = dev->core;
+	int err;
+
+	/* pci init */
+	if (pci_enable_device(dev->pci))
+		return -EIO;
+	pci_set_master(dev->pci);
+	if (!pci_dma_supported(dev->pci,DMA_BIT_MASK(32))) {
+		printk("%s/2: Oops: no 32bit PCI DMA ???\n",dev->core->name);
+		return -EIO;
+	}
+
+	dev->pci_rev = dev->pci->revision;
+	pci_read_config_byte(dev->pci, PCI_LATENCY_TIMER,  &dev->pci_lat);
+	printk(KERN_INFO "%s/2: found at %s, rev: %d, irq: %d, "
+	       "latency: %d, mmio: 0x%llx\n", dev->core->name,
+	       pci_name(dev->pci), dev->pci_rev, dev->pci->irq,
+	       dev->pci_lat,(unsigned long long)pci_resource_start(dev->pci,0));
+
+	/* initialize driver struct */
+	spin_lock_init(&dev->slock);
+
+	/* init dma queue */
+	INIT_LIST_HEAD(&dev->mpegq.active);
+	INIT_LIST_HEAD(&dev->mpegq.queued);
+	dev->mpegq.timeout.function = cx8802_timeout;
+	dev->mpegq.timeout.data     = (unsigned long)dev;
+	init_timer(&dev->mpegq.timeout);
+	cx88_risc_stopper(dev->pci,&dev->mpegq.stopper,
+			  MO_TS_DMACNTRL,0x11,0x00);
+
+	/* get irq */
+	err = request_irq(dev->pci->irq, cx8802_irq,
+			  IRQF_SHARED | IRQF_DISABLED, dev->core->name, dev);
+	if (err < 0) {
+		printk(KERN_ERR "%s: can't get IRQ %d\n",
+		       dev->core->name, dev->pci->irq);
+		return err;
+	}
+	cx_set(MO_PCI_INTMSK, core->pci_irqmask);
+
+	/* everything worked */
+	pci_set_drvdata(dev->pci,dev);
+	return 0;
+}
+
+static void cx8802_fini_common(struct cx8802_dev *dev)
+{
+	dprintk( 2, "cx8802_fini_common\n" );
+	cx8802_stop_dma(dev);
+	pci_disable_device(dev->pci);
+
+	/* unregister stuff */
+	free_irq(dev->pci->irq, dev);
+	pci_set_drvdata(dev->pci, NULL);
+
+	/* free memory */
+	btcx_riscmem_free(dev->pci,&dev->mpegq.stopper);
+}
+
+/* ----------------------------------------------------------- */
+
+static int cx8802_suspend_common(struct pci_dev *pci_dev, pm_message_t state)
+{
+	struct cx8802_dev *dev = pci_get_drvdata(pci_dev);
+	struct cx88_core *core = dev->core;
+
+	/* stop mpeg dma */
+	spin_lock(&dev->slock);
+	if (!list_empty(&dev->mpegq.active)) {
+		dprintk( 2, "suspend\n" );
+		printk("%s: suspend mpeg\n", core->name);
+		cx8802_stop_dma(dev);
+		del_timer(&dev->mpegq.timeout);
+	}
+	spin_unlock(&dev->slock);
+
+	/* FIXME -- shutdown device */
+	cx88_shutdown(dev->core);
+
+	pci_save_state(pci_dev);
+	if (0 != pci_set_power_state(pci_dev, pci_choose_state(pci_dev, state))) {
+		pci_disable_device(pci_dev);
+		dev->state.disabled = 1;
+	}
+	return 0;
+}
+
+static int cx8802_resume_common(struct pci_dev *pci_dev)
+{
+	struct cx8802_dev *dev = pci_get_drvdata(pci_dev);
+	struct cx88_core *core = dev->core;
+	int err;
+
+	if (dev->state.disabled) {
+		err=pci_enable_device(pci_dev);
+		if (err) {
+			printk(KERN_ERR "%s: can't enable device\n",
+					       dev->core->name);
+			return err;
+		}
+		dev->state.disabled = 0;
+	}
+	err=pci_set_power_state(pci_dev, PCI_D0);
+	if (err) {
+		printk(KERN_ERR "%s: can't enable device\n",
+					       dev->core->name);
+		pci_disable_device(pci_dev);
+		dev->state.disabled = 1;
+
+		return err;
+	}
+	pci_restore_state(pci_dev);
+
+	/* FIXME: re-initialize hardware */
+	cx88_reset(dev->core);
+
+	/* restart video+vbi capture */
+	spin_lock(&dev->slock);
+	if (!list_empty(&dev->mpegq.active)) {
+		printk("%s: resume mpeg\n", core->name);
+		cx8802_restart_queue(dev,&dev->mpegq);
+	}
+	spin_unlock(&dev->slock);
+
+	return 0;
+}
+
+struct cx8802_driver * cx8802_get_driver(struct cx8802_dev *dev, enum cx88_board_type btype)
+{
+	struct cx8802_driver *d;
+
+	list_for_each_entry(d, &dev->drvlist, drvlist)
+		if (d->type_id == btype)
+			return d;
+
+	return NULL;
+}
+
+/* Driver asked for hardware access. */
+static int cx8802_request_acquire(struct cx8802_driver *drv)
+{
+	struct cx88_core *core = drv->core;
+	unsigned int	i;
+
+	/* Fail a request for hardware if the device is busy. */
+	if (core->active_type_id != CX88_BOARD_NONE &&
+	    core->active_type_id != drv->type_id)
+		return -EBUSY;
+
+	if (drv->type_id == CX88_MPEG_DVB) {
+		/* When switching to DVB, always set the input to the tuner */
+		core->last_analog_input = core->input;
+		core->input = 0;
+		for (i = 0;
+		     i < (sizeof(core->board.input) / sizeof(struct cx88_input));
+		     i++) {
+			if (core->board.input[i].type == CX88_VMUX_DVB) {
+				core->input = i;
+				break;
+			}
+		}
+	}
+
+	if (drv->advise_acquire)
+	{
+		core->active_ref++;
+		if (core->active_type_id == CX88_BOARD_NONE) {
+			core->active_type_id = drv->type_id;
+			drv->advise_acquire(drv);
+		}
+
+		mpeg_dbg(1,"%s() Post acquire GPIO=%x\n", __func__, cx_read(MO_GP0_IO));
+	}
+
+	return 0;
+}
+
+/* Driver asked to release hardware. */
+static int cx8802_request_release(struct cx8802_driver *drv)
+{
+	struct cx88_core *core = drv->core;
+
+	if (drv->advise_release && --core->active_ref == 0)
+	{
+		if (drv->type_id == CX88_MPEG_DVB) {
+			/* If the DVB driver is releasing, reset the input
+			   state to the last configured analog input */
+			core->input = core->last_analog_input;
+		}
+
+		drv->advise_release(drv);
+		core->active_type_id = CX88_BOARD_NONE;
+		mpeg_dbg(1,"%s() Post release GPIO=%x\n", __func__, cx_read(MO_GP0_IO));
+	}
+
+	return 0;
+}
+
+static int cx8802_check_driver(struct cx8802_driver *drv)
+{
+	if (drv == NULL)
+		return -ENODEV;
+
+	if ((drv->type_id != CX88_MPEG_DVB) &&
+		(drv->type_id != CX88_MPEG_BLACKBIRD))
+		return -EINVAL;
+
+	if ((drv->hw_access != CX8802_DRVCTL_SHARED) &&
+		(drv->hw_access != CX8802_DRVCTL_EXCLUSIVE))
+		return -EINVAL;
+
+	if ((drv->probe == NULL) ||
+		(drv->remove == NULL) ||
+		(drv->advise_acquire == NULL) ||
+		(drv->advise_release == NULL))
+		return -EINVAL;
+
+	return 0;
+}
+
+int cx8802_register_driver(struct cx8802_driver *drv)
+{
+	struct cx8802_dev *dev;
+	struct cx8802_driver *driver;
+	int err, i = 0;
+
+	printk(KERN_INFO
+	       "cx88/2: registering cx8802 driver, type: %s access: %s\n",
+	       drv->type_id == CX88_MPEG_DVB ? "dvb" : "blackbird",
+	       drv->hw_access == CX8802_DRVCTL_SHARED ? "shared" : "exclusive");
+
+	if ((err = cx8802_check_driver(drv)) != 0) {
+		printk(KERN_ERR "cx88/2: cx8802_driver is invalid\n");
+		return err;
+	}
+
+	mutex_lock(&cx8802_mutex);
+
+	list_for_each_entry(dev, &cx8802_devlist, devlist) {
+		printk(KERN_INFO
+		       "%s/2: subsystem: %04x:%04x, board: %s [card=%d]\n",
+		       dev->core->name, dev->pci->subsystem_vendor,
+		       dev->pci->subsystem_device, dev->core->board.name,
+		       dev->core->boardnr);
+
+		/* Bring up a new struct for each driver instance */
+		driver = kzalloc(sizeof(*drv),GFP_KERNEL);
+		if (driver == NULL) {
+			err = -ENOMEM;
+			goto out;
+		}
+
+		/* Snapshot of the driver registration data */
+		drv->core = dev->core;
+		drv->suspend = cx8802_suspend_common;
+		drv->resume = cx8802_resume_common;
+		drv->request_acquire = cx8802_request_acquire;
+		drv->request_release = cx8802_request_release;
+		memcpy(driver, drv, sizeof(*driver));
+
+		mutex_lock(&drv->core->lock);
+		err = drv->probe(driver);
+		if (err == 0) {
+			i++;
+			list_add_tail(&driver->drvlist, &dev->drvlist);
+		} else {
+			printk(KERN_ERR
+			       "%s/2: cx8802 probe failed, err = %d\n",
+			       dev->core->name, err);
+		}
+		mutex_unlock(&drv->core->lock);
+	}
+
+	err = i ? 0 : -ENODEV;
+out:
+	mutex_unlock(&cx8802_mutex);
+	return err;
+}
+
+int cx8802_unregister_driver(struct cx8802_driver *drv)
+{
+	struct cx8802_dev *dev;
+	struct cx8802_driver *d, *dtmp;
+	int err = 0;
+
+	printk(KERN_INFO
+	       "cx88/2: unregistering cx8802 driver, type: %s access: %s\n",
+	       drv->type_id == CX88_MPEG_DVB ? "dvb" : "blackbird",
+	       drv->hw_access == CX8802_DRVCTL_SHARED ? "shared" : "exclusive");
+
+	mutex_lock(&cx8802_mutex);
+
+	list_for_each_entry(dev, &cx8802_devlist, devlist) {
+		printk(KERN_INFO
+		       "%s/2: subsystem: %04x:%04x, board: %s [card=%d]\n",
+		       dev->core->name, dev->pci->subsystem_vendor,
+		       dev->pci->subsystem_device, dev->core->board.name,
+		       dev->core->boardnr);
+
+		mutex_lock(&dev->core->lock);
+
+		list_for_each_entry_safe(d, dtmp, &dev->drvlist, drvlist) {
+			/* only unregister the correct driver type */
+			if (d->type_id != drv->type_id)
+				continue;
+
+			err = d->remove(d);
+			if (err == 0) {
+				list_del(&d->drvlist);
+				kfree(d);
+			} else
+				printk(KERN_ERR "%s/2: cx8802 driver remove "
+				       "failed (%d)\n", dev->core->name, err);
+		}
+
+		mutex_unlock(&dev->core->lock);
+	}
+
+	mutex_unlock(&cx8802_mutex);
+
+	return err;
+}
+
+/* ----------------------------------------------------------- */
+static int __devinit cx8802_probe(struct pci_dev *pci_dev,
+			       const struct pci_device_id *pci_id)
+{
+	struct cx8802_dev *dev;
+	struct cx88_core  *core;
+	int err;
+
+	/* general setup */
+	core = cx88_core_get(pci_dev);
+	if (NULL == core)
+		return -EINVAL;
+
+	printk("%s/2: cx2388x 8802 Driver Manager\n", core->name);
+
+	err = -ENODEV;
+	if (!core->board.mpeg)
+		goto fail_core;
+
+	err = -ENOMEM;
+	dev = kzalloc(sizeof(*dev),GFP_KERNEL);
+	if (NULL == dev)
+		goto fail_core;
+	dev->pci = pci_dev;
+	dev->core = core;
+
+	/* Maintain a reference so cx88-video can query the 8802 device. */
+	core->dvbdev = dev;
+
+	err = cx8802_init_common(dev);
+	if (err != 0)
+		goto fail_free;
+
+	INIT_LIST_HEAD(&dev->drvlist);
+	mutex_lock(&cx8802_mutex);
+	list_add_tail(&dev->devlist,&cx8802_devlist);
+	mutex_unlock(&cx8802_mutex);
+
+	/* now autoload cx88-dvb or cx88-blackbird */
+	request_modules(dev);
+	return 0;
+
+ fail_free:
+	kfree(dev);
+ fail_core:
+	core->dvbdev = NULL;
+	cx88_core_put(core,pci_dev);
+	return err;
+}
+
+static void __devexit cx8802_remove(struct pci_dev *pci_dev)
+{
+	struct cx8802_dev *dev;
+
+	dev = pci_get_drvdata(pci_dev);
+
+	dprintk( 1, "%s\n", __func__);
+
+	flush_request_modules(dev);
+
+	mutex_lock(&dev->core->lock);
+
+	if (!list_empty(&dev->drvlist)) {
+		struct cx8802_driver *drv, *tmp;
+		int err;
+
+		printk(KERN_WARNING "%s/2: Trying to remove cx8802 driver "
+		       "while cx8802 sub-drivers still loaded?!\n",
+		       dev->core->name);
+
+		list_for_each_entry_safe(drv, tmp, &dev->drvlist, drvlist) {
+			err = drv->remove(drv);
+			if (err == 0) {
+				list_del(&drv->drvlist);
+			} else
+				printk(KERN_ERR "%s/2: cx8802 driver remove "
+				       "failed (%d)\n", dev->core->name, err);
+			kfree(drv);
+		}
+	}
+
+	mutex_unlock(&dev->core->lock);
+
+	/* Destroy any 8802 reference. */
+	dev->core->dvbdev = NULL;
+
+	/* common */
+	cx8802_fini_common(dev);
+	cx88_core_put(dev->core,dev->pci);
+	kfree(dev);
+}
+
+static const struct pci_device_id cx8802_pci_tbl[] = {
+	{
+		.vendor       = 0x14f1,
+		.device       = 0x8802,
+		.subvendor    = PCI_ANY_ID,
+		.subdevice    = PCI_ANY_ID,
+	},{
+		/* --- end of list --- */
+	}
+};
+MODULE_DEVICE_TABLE(pci, cx8802_pci_tbl);
+
+static struct pci_driver cx8802_pci_driver = {
+	.name     = "cx88-mpeg driver manager",
+	.id_table = cx8802_pci_tbl,
+	.probe    = cx8802_probe,
+	.remove   = __devexit_p(cx8802_remove),
+};
+
+static int __init cx8802_init(void)
+{
+	printk(KERN_INFO "cx88/2: cx2388x MPEG-TS Driver Manager version %s loaded\n",
+	       CX88_VERSION);
+	return pci_register_driver(&cx8802_pci_driver);
+}
+
+static void __exit cx8802_fini(void)
+{
+	pci_unregister_driver(&cx8802_pci_driver);
+}
+
+module_init(cx8802_init);
+module_exit(cx8802_fini);
+EXPORT_SYMBOL(cx8802_buf_prepare);
+EXPORT_SYMBOL(cx8802_buf_queue);
+EXPORT_SYMBOL(cx8802_cancel_buffers);
+
+EXPORT_SYMBOL(cx8802_register_driver);
+EXPORT_SYMBOL(cx8802_unregister_driver);
+EXPORT_SYMBOL(cx8802_get_driver);
+/* ----------------------------------------------------------- */
+/*
+ * Local variables:
+ * c-basic-offset: 8
+ * End:
+ * kate: eol "unix"; indent-width 3; remove-trailing-space on; replace-trailing-space-save on; tab-width 8; replace-tabs off; space-indent off; mixed-indent off
+ */
