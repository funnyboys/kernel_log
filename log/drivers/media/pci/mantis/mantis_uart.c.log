commit 74ba9207e1adf1966c57450340534ae9742d00af
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 20 09:19:02 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 61
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      675 mass ave cambridge ma 02139 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 441 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Michael Ellerman <mpe@ellerman.id.au> (powerpc)
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190520071858.739733335@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/media/pci/mantis/mantis_uart.c b/drivers/media/pci/mantis/mantis_uart.c
index b7765687e0c3..42983a89e50b 100644
--- a/drivers/media/pci/mantis/mantis_uart.c
+++ b/drivers/media/pci/mantis/mantis_uart.c
@@ -1,21 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
 	Mantis PCI bridge driver
 
 	Copyright (C) Manu Abraham (abraham.manu@gmail.com)
 
-	This program is free software; you can redistribute it and/or modify
-	it under the terms of the GNU General Public License as published by
-	the Free Software Foundation; either version 2 of the License, or
-	(at your option) any later version.
-
-	This program is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-	GNU General Public License for more details.
-
-	You should have received a copy of the GNU General Public License
-	along with this program; if not, write to the Free Software
-	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
 #include <linux/kernel.h>

commit cac61a1acb1def146c3900f1c8f7af4947d98814
Author: Mauro Carvalho Chehab <mchehab@s-opensource.com>
Date:   Thu Apr 12 08:28:33 2018 -0400

    media: mantis: prevent staying forever in a loop at IRQ
    
    As warned by smatch:
            drivers/media/pci/mantis/mantis_uart.c:105 mantis_uart_work() warn: this loop depends on readl() succeeding
    
    If something goes wrong at readl(), the logic will stay there
    inside an IRQ code forever. This is not the nicest thing to
    do :-)
    
    So, add a timeout there, preventing staying inside the IRQ
    for more than 10ms.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/pci/mantis/mantis_uart.c b/drivers/media/pci/mantis/mantis_uart.c
index 18f81c135996..b7765687e0c3 100644
--- a/drivers/media/pci/mantis/mantis_uart.c
+++ b/drivers/media/pci/mantis/mantis_uart.c
@@ -92,6 +92,7 @@ static void mantis_uart_work(struct work_struct *work)
 {
 	struct mantis_pci *mantis = container_of(work, struct mantis_pci, uart_work);
 	u32 stat;
+	unsigned long timeout;
 
 	stat = mmread(MANTIS_UART_STAT);
 
@@ -102,9 +103,15 @@ static void mantis_uart_work(struct work_struct *work)
 	 * MANTIS_UART_RXFIFO_DATA is only set if at least
 	 * config->bytes + 1 bytes are in the FIFO.
 	 */
+
+	/* FIXME: is 10ms good enough ? */
+	timeout = jiffies +  msecs_to_jiffies(10);
 	while (stat & MANTIS_UART_RXFIFO_DATA) {
 		mantis_uart_read(mantis);
 		stat = mmread(MANTIS_UART_STAT);
+
+		if (!time_is_after_jiffies(timeout))
+			break;
 	}
 
 	/* re-enable UART (RX) interrupt */

commit fada1935590f66dc6784981e0d557ca09013c847
Author: Mauro Carvalho Chehab <mchehab@s-opensource.com>
Date:   Thu Dec 28 13:03:51 2017 -0500

    media: move dvb kAPI headers to include/media
    
    Except for DVB, all media kAPI headers are at include/media.
    
    Move the headers to it.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/pci/mantis/mantis_uart.c b/drivers/media/pci/mantis/mantis_uart.c
index f1c96aec8c7b..18f81c135996 100644
--- a/drivers/media/pci/mantis/mantis_uart.c
+++ b/drivers/media/pci/mantis/mantis_uart.c
@@ -27,11 +27,11 @@
 #include <linux/interrupt.h>
 #include <linux/pci.h>
 
-#include "dmxdev.h"
-#include "dvbdev.h"
-#include "dvb_demux.h"
-#include "dvb_frontend.h"
-#include "dvb_net.h"
+#include <media/dmxdev.h>
+#include <media/dvbdev.h>
+#include <media/dvb_demux.h>
+#include <media/dvb_frontend.h>
+#include <media/dvb_net.h>
 
 #include "mantis_common.h"
 #include "mantis_reg.h"

commit 9d605e6359f0808581b89350c643208586f41a06
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Wed Jun 10 12:06:34 2015 -0300

    [media] mantis: cleanup CodingStyle issues due to last commit
    
    Commit a96762da0cfc('[media] mantis: add remote control support')
    introduced some new CodingStyle issues. Fix them.
    
    No functional changes.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/pci/mantis/mantis_uart.c b/drivers/media/pci/mantis/mantis_uart.c
index 483410948995..f1c96aec8c7b 100644
--- a/drivers/media/pci/mantis/mantis_uart.c
+++ b/drivers/media/pci/mantis/mantis_uart.c
@@ -70,6 +70,7 @@ static void mantis_uart_read(struct mantis_pci *mantis)
 	dprintk(MANTIS_DEBUG, 1, "UART Reading ...");
 	for (i = 0; i < (config->bytes + 1); i++) {
 		int data = mmread(MANTIS_UART_RXD);
+
 		dprintk(MANTIS_DEBUG, 0, " <%02x>", data);
 
 		scancode = (scancode << 8) | (data & 0x3f);
@@ -98,8 +99,8 @@ static void mantis_uart_work(struct work_struct *work)
 		dprintk(MANTIS_ERROR, 1, "RX Fifo FULL");
 
 	/*
-	 * MANTIS_UART_RXFIFO_DATA is only set if at least config->bytes + 1 bytes
-	 * are in the FIFO.
+	 * MANTIS_UART_RXFIFO_DATA is only set if at least
+	 * config->bytes + 1 bytes are in the FIFO.
 	 */
 	while (stat & MANTIS_UART_RXFIFO_DATA) {
 		mantis_uart_read(mantis);

commit a96762da0cfcbe27f18febb84797269cd9faf791
Author: Jan Klötzke <jan@kloetzke.net>
Date:   Sat Jun 6 16:58:13 2015 -0300

    [media] mantis: add remote control support
    
    The embedded UART is apparently used to receive decoded IR (RC5?) codes.
    Forward these scan codes to the RC framework and (where known) add
    corresponding mapping tables to translate them into regular keys.
    
    This patch has been tested on a TechniSat CableStar HD2. The mappings of other
    rc-maps were taken from Christoph Pinkl's patch
    (http://patchwork.linuxtv.org/patch/7217/) and the s2-liplianin repository. The
    major difference to Christoph's patch is a reworked interrupt handling of the
    UART because the RX interrupt is apparently level triggered and requires
    masking until the FIFO is read by the UART worker.
    
    Signed-off-by: Jan Klötzke <jan@kloetzke.net>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/pci/mantis/mantis_uart.c b/drivers/media/pci/mantis/mantis_uart.c
index a70719218631..483410948995 100644
--- a/drivers/media/pci/mantis/mantis_uart.c
+++ b/drivers/media/pci/mantis/mantis_uart.c
@@ -25,6 +25,7 @@
 #include <linux/signal.h>
 #include <linux/sched.h>
 #include <linux/interrupt.h>
+#include <linux/pci.h>
 
 #include "dmxdev.h"
 #include "dvbdev.h"
@@ -35,6 +36,7 @@
 #include "mantis_common.h"
 #include "mantis_reg.h"
 #include "mantis_uart.h"
+#include "mantis_input.h"
 
 struct mantis_uart_params {
 	enum mantis_baud	baud_rate;
@@ -59,51 +61,53 @@ static struct {
 	{ "EVEN" }
 };
 
-#define UART_MAX_BUF			16
-
-static int mantis_uart_read(struct mantis_pci *mantis, u8 *data)
+static void mantis_uart_read(struct mantis_pci *mantis)
 {
 	struct mantis_hwconfig *config = mantis->hwconfig;
-	u32 stat = 0, i;
+	int i, scancode = 0, err = 0;
 
 	/* get data */
+	dprintk(MANTIS_DEBUG, 1, "UART Reading ...");
 	for (i = 0; i < (config->bytes + 1); i++) {
+		int data = mmread(MANTIS_UART_RXD);
+		dprintk(MANTIS_DEBUG, 0, " <%02x>", data);
 
-		stat = mmread(MANTIS_UART_STAT);
-
-		if (stat & MANTIS_UART_RXFIFO_FULL) {
-			dprintk(MANTIS_ERROR, 1, "RX Fifo FULL");
-		}
-		data[i] = mmread(MANTIS_UART_RXD) & 0x3f;
-
-		dprintk(MANTIS_DEBUG, 1, "Reading ... <%02x>", data[i] & 0x3f);
+		scancode = (scancode << 8) | (data & 0x3f);
+		err |= data;
 
-		if (data[i] & (1 << 7)) {
+		if (data & (1 << 7))
 			dprintk(MANTIS_ERROR, 1, "UART framing error");
-			return -EINVAL;
-		}
-		if (data[i] & (1 << 6)) {
+
+		if (data & (1 << 6))
 			dprintk(MANTIS_ERROR, 1, "UART parity error");
-			return -EINVAL;
-		}
 	}
+	dprintk(MANTIS_DEBUG, 0, "\n");
 
-	return 0;
+	if ((err & 0xC0) == 0)
+		mantis_input_process(mantis, scancode);
 }
 
 static void mantis_uart_work(struct work_struct *work)
 {
 	struct mantis_pci *mantis = container_of(work, struct mantis_pci, uart_work);
-	struct mantis_hwconfig *config = mantis->hwconfig;
-	u8 buf[16];
-	int i;
+	u32 stat;
 
-	mantis_uart_read(mantis, buf);
+	stat = mmread(MANTIS_UART_STAT);
 
-	for (i = 0; i < (config->bytes + 1); i++)
-		dprintk(MANTIS_INFO, 1, "UART BUF:%d <%02x> ", i, buf[i]);
+	if (stat & MANTIS_UART_RXFIFO_FULL)
+		dprintk(MANTIS_ERROR, 1, "RX Fifo FULL");
 
-	dprintk(MANTIS_DEBUG, 0, "\n");
+	/*
+	 * MANTIS_UART_RXFIFO_DATA is only set if at least config->bytes + 1 bytes
+	 * are in the FIFO.
+	 */
+	while (stat & MANTIS_UART_RXFIFO_DATA) {
+		mantis_uart_read(mantis);
+		stat = mmread(MANTIS_UART_STAT);
+	}
+
+	/* re-enable UART (RX) interrupt */
+	mantis_unmask_ints(mantis, MANTIS_INT_IRQ1);
 }
 
 static int mantis_uart_setup(struct mantis_pci *mantis,
@@ -152,9 +156,6 @@ int mantis_uart_init(struct mantis_pci *mantis)
 		rates[params.baud_rate].string,
 		parity[params.parity].string);
 
-	init_waitqueue_head(&mantis->uart_wq);
-	spin_lock_init(&mantis->uart_lock);
-
 	INIT_WORK(&mantis->uart_work, mantis_uart_work);
 
 	/* disable interrupt */
@@ -169,8 +170,8 @@ int mantis_uart_init(struct mantis_pci *mantis)
 	mmwrite((mmread(MANTIS_UART_CTL) | MANTIS_UART_RXFLUSH), MANTIS_UART_CTL);
 
 	/* enable interrupt */
-	mmwrite(mmread(MANTIS_INT_MASK) | 0x800, MANTIS_INT_MASK);
 	mmwrite(mmread(MANTIS_UART_CTL) | MANTIS_UART_RXINT, MANTIS_UART_CTL);
+	mantis_unmask_ints(mantis, MANTIS_INT_IRQ1);
 
 	schedule_work(&mantis->uart_work);
 	dprintk(MANTIS_DEBUG, 1, "UART successfully initialized");
@@ -182,6 +183,7 @@ EXPORT_SYMBOL_GPL(mantis_uart_init);
 void mantis_uart_exit(struct mantis_pci *mantis)
 {
 	/* disable interrupt */
+	mantis_mask_ints(mantis, MANTIS_INT_IRQ1);
 	mmwrite(mmread(MANTIS_UART_CTL) & 0xffef, MANTIS_UART_CTL);
 	flush_work(&mantis->uart_work);
 }

commit 6860f9ca8ce2ef801edee2156cffaf5152bd3c39
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Sat Oct 27 13:00:58 2012 -0300

    [media] mantis: get rid of warning: no previous prototype
    
    drivers/media/pci/mantis/mantis_input.c:107:5: warning: no previous prototype for 'mantis_input_init' [-Wmissing-prototypes]
    drivers/media/pci/mantis/mantis_input.c:153:5: warning: no previous prototype for 'mantis_exit' [-Wmissing-prototypes]
    drivers/media/pci/mantis/mantis_uart.c:64:5: warning: no previous prototype for 'mantis_uart_read' [-Wmissing-prototypes]
    drivers/media/pci/mantis/mantis_vp1033.c:118:5: warning: no previous prototype for 'lgtdqcs001f_set_symbol_rate' [-Wmissing-prototypes]
    drivers/media/pci/mantis/mantis_vp1033.c:86:5: warning: no previous prototype for 'lgtdqcs001f_tuner_set' [-Wmissing-prototypes]
    
    Note: there is already a mantis_exit at the mantis driver. So,
    this should be renamed to mantis_input_exit.
    
    The mantis_input code is currently unused, as it doesn't implement the RC API
    right.
    
    Patches for it are sent for discussions, but were never
    accepted. So, while this is not fixed, the entire code inside
    mantis_input can simply be commented.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/pci/mantis/mantis_uart.c b/drivers/media/pci/mantis/mantis_uart.c
index 85e977861b4a..a70719218631 100644
--- a/drivers/media/pci/mantis/mantis_uart.c
+++ b/drivers/media/pci/mantis/mantis_uart.c
@@ -61,7 +61,7 @@ static struct {
 
 #define UART_MAX_BUF			16
 
-int mantis_uart_read(struct mantis_pci *mantis, u8 *data)
+static int mantis_uart_read(struct mantis_pci *mantis, u8 *data)
 {
 	struct mantis_hwconfig *config = mantis->hwconfig;
 	u32 stat = 0, i;

commit 0b8e74c6f44094189dbe78baf4101acc7570c6af
Merge: 7f60ba388f5b bd0d10498826
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Oct 7 17:49:05 2012 +0900

    Merge branch 'v4l_for_linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mchehab/linux-media
    
    Pull media updates from Mauro Carvalho Chehab:
     "The first part of the media updates for Kernel 3.7.
    
      This series contain:
    
       - A major tree renaming patch series: now, drivers are organized
         internally by their used bus, instead of by V4L2 and/or DVB API,
         providing a cleaner driver location for hybrid drivers that
         implement both APIs, and allowing to cleanup the Kconfig items and
         make them more intuitive for the end user;
    
       - Media Kernel developers are typically very lazy with their duties
         of keeping the MAINTAINERS entries for their drivers updated.  As
         now the tree is more organized, we're doing an effort to add/update
         those entries for the drivers that aren't currently orphan;
    
       - Several DVB USB drivers got moved to a new DVB USB v2 core; the new
         core fixes several bugs (as the existing one that got bitroted).
         Now, suspend/resume finally started to work fine (at least with
         some devices - we should expect more work with regards to it);
    
       - added multistream support for DVB-T2, and unified the API for
         DVB-S2 and ISDB-S.  Backward binary support is preserved;
    
       - as usual, a few new drivers, some V4L2 core improvements and lots
         of drivers improvements and fixes.
    
      There are some points to notice on this series:
    
       1) you should expect a trivial merge conflict on your tree, with the
          removal of Documentation/feature-removal-schedule.txt: this series
          would be adding two additional entries there.  I opted to not
          rebase it due to this recent change;
    
       2) With regards to the PCTV 520e udev-related breakage, I opted to
          fix it in a way that the patches can be backported to 3.5 even
          without your firmware fix patch.  This way, Greg doesn't need to
          rush backporting your patch (as there are still the firmware cache
          and firmware path customization issues to be addressed there).
    
          I'll send later a patch (likely after the end of the merge window)
          reverting the rest of the DRX-K async firmware request, fully
          restoring its original behaviour to allow media drivers to
          initialize everything serialized as before for 3.7 and upper.
    
       3) I'm planning to work on this weekend to test the DMABUF patches
          for V4L2.  The patches are on my queue for several Kernel cycles,
          but, up to now, there is/was no way to test the series locally.
    
          I have some concerns about this particular changeset with regards
          to security issues, and with regards to the replacement of the old
          VIDIOC_OVERLAY ioctl's that is broken on modern systems, due to
          GPU drivers change.  The Overlay API allows direct PCI2PCI
          transfers from a media capture card into the GPU framebuffer, but
          its API is crappy.  Also, the only existing X11 driver that
          implements it requires a XV extension that is not available
          anymore on modern drivers.  The DMABUF can do the same thing, but
          with it is promising to be a properly-designed API.  If I can
          successfully test this series and be happy with it, I should be
          asking you to pull them next week."
    
    * 'v4l_for_linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mchehab/linux-media: (717 commits)
      em28xx: regression fix: use DRX-K sync firmware requests on em28xx
      drxk: allow loading firmware synchrousnously
      em28xx: Make all em28xx extensions to be initialized asynchronously
      [media] tda18271: properly report read errors in tda18271_get_id
      [media] tda18271: delay IR & RF calibration until init() if delay_cal is set
      [media] MAINTAINERS: add Michael Krufky as tda827x maintainer
      [media] MAINTAINERS: add Michael Krufky as tda8290 maintainer
      [media] MAINTAINERS: add Michael Krufky as cxusb maintainer
      [media] MAINTAINERS: add Michael Krufky as lg2160 maintainer
      [media] MAINTAINERS: add Michael Krufky as lgdt3305 maintainer
      [media] MAINTAINERS: add Michael Krufky as mxl111sf maintainer
      [media] MAINTAINERS: add Michael Krufky as mxl5007t maintainer
      [media] MAINTAINERS: add Michael Krufky as tda18271 maintainer
      [media] s5p-tv: Report only multi-plane capabilities in vidioc_querycap
      [media] s5p-mfc: Fix misplaced return statement in s5p_mfc_suspend()
      [media] exynos-gsc: Add missing static storage class specifiers
      [media] exynos-gsc: Remove <linux/version.h> header file inclusion
      [media] s5p-fimc: Fix incorrect condition in fimc_lite_reqbufs()
      [media] s5p-tv: Fix potential NULL pointer dereference error
      [media] s5k6aa: Fix possible NULL pointer dereference
      ...

commit 25aee3debe0464f6c680173041fa3de30ec9ff54
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Thu Jun 14 16:35:57 2012 -0300

    [media] Rename media/dvb as media/pci
    
    The remaining dvb drivers are pci, so rename them to match the
    bus.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/pci/mantis/mantis_uart.c b/drivers/media/pci/mantis/mantis_uart.c
new file mode 100644
index 000000000000..18340dafa426
--- /dev/null
+++ b/drivers/media/pci/mantis/mantis_uart.c
@@ -0,0 +1,188 @@
+/*
+	Mantis PCI bridge driver
+
+	Copyright (C) Manu Abraham (abraham.manu@gmail.com)
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program; if not, write to the Free Software
+	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+#include <linux/kernel.h>
+#include <linux/spinlock.h>
+#include <asm/io.h>
+
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+
+#include "dmxdev.h"
+#include "dvbdev.h"
+#include "dvb_demux.h"
+#include "dvb_frontend.h"
+#include "dvb_net.h"
+
+#include "mantis_common.h"
+#include "mantis_reg.h"
+#include "mantis_uart.h"
+
+struct mantis_uart_params {
+	enum mantis_baud	baud_rate;
+	enum mantis_parity	parity;
+};
+
+static struct {
+	char string[7];
+} rates[5] = {
+	{ "9600" },
+	{ "19200" },
+	{ "38400" },
+	{ "57600" },
+	{ "115200" }
+};
+
+static struct {
+	char string[5];
+} parity[3] = {
+	{ "NONE" },
+	{ "ODD" },
+	{ "EVEN" }
+};
+
+#define UART_MAX_BUF			16
+
+int mantis_uart_read(struct mantis_pci *mantis, u8 *data)
+{
+	struct mantis_hwconfig *config = mantis->hwconfig;
+	u32 stat = 0, i;
+
+	/* get data */
+	for (i = 0; i < (config->bytes + 1); i++) {
+
+		stat = mmread(MANTIS_UART_STAT);
+
+		if (stat & MANTIS_UART_RXFIFO_FULL) {
+			dprintk(MANTIS_ERROR, 1, "RX Fifo FULL");
+		}
+		data[i] = mmread(MANTIS_UART_RXD) & 0x3f;
+
+		dprintk(MANTIS_DEBUG, 1, "Reading ... <%02x>", data[i] & 0x3f);
+
+		if (data[i] & (1 << 7)) {
+			dprintk(MANTIS_ERROR, 1, "UART framing error");
+			return -EINVAL;
+		}
+		if (data[i] & (1 << 6)) {
+			dprintk(MANTIS_ERROR, 1, "UART parity error");
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+
+static void mantis_uart_work(struct work_struct *work)
+{
+	struct mantis_pci *mantis = container_of(work, struct mantis_pci, uart_work);
+	struct mantis_hwconfig *config = mantis->hwconfig;
+	u8 buf[16];
+	int i;
+
+	mantis_uart_read(mantis, buf);
+
+	for (i = 0; i < (config->bytes + 1); i++)
+		dprintk(MANTIS_INFO, 1, "UART BUF:%d <%02x> ", i, buf[i]);
+
+	dprintk(MANTIS_DEBUG, 0, "\n");
+}
+
+static int mantis_uart_setup(struct mantis_pci *mantis,
+			     struct mantis_uart_params *params)
+{
+	u32 reg;
+
+	mmwrite((mmread(MANTIS_UART_CTL) | (params->parity & 0x3)), MANTIS_UART_CTL);
+
+	reg = mmread(MANTIS_UART_BAUD);
+
+	switch (params->baud_rate) {
+	case MANTIS_BAUD_9600:
+		reg |= 0xd8;
+		break;
+	case MANTIS_BAUD_19200:
+		reg |= 0x6c;
+		break;
+	case MANTIS_BAUD_38400:
+		reg |= 0x36;
+		break;
+	case MANTIS_BAUD_57600:
+		reg |= 0x23;
+		break;
+	case MANTIS_BAUD_115200:
+		reg |= 0x11;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	mmwrite(reg, MANTIS_UART_BAUD);
+
+	return 0;
+}
+
+int mantis_uart_init(struct mantis_pci *mantis)
+{
+	struct mantis_hwconfig *config = mantis->hwconfig;
+	struct mantis_uart_params params;
+
+	/* default parity: */
+	params.baud_rate = config->baud_rate;
+	params.parity = config->parity;
+	dprintk(MANTIS_INFO, 1, "Initializing UART @ %sbps parity:%s",
+		rates[params.baud_rate].string,
+		parity[params.parity].string);
+
+	init_waitqueue_head(&mantis->uart_wq);
+	spin_lock_init(&mantis->uart_lock);
+
+	INIT_WORK(&mantis->uart_work, mantis_uart_work);
+
+	/* disable interrupt */
+	mmwrite(mmread(MANTIS_UART_CTL) & 0xffef, MANTIS_UART_CTL);
+
+	mantis_uart_setup(mantis, &params);
+
+	/* default 1 byte */
+	mmwrite((mmread(MANTIS_UART_BAUD) | (config->bytes << 8)), MANTIS_UART_BAUD);
+
+	/* flush buffer */
+	mmwrite((mmread(MANTIS_UART_CTL) | MANTIS_UART_RXFLUSH), MANTIS_UART_CTL);
+
+	/* enable interrupt */
+	mmwrite(mmread(MANTIS_INT_MASK) | 0x800, MANTIS_INT_MASK);
+	mmwrite(mmread(MANTIS_UART_CTL) | MANTIS_UART_RXINT, MANTIS_UART_CTL);
+
+	schedule_work(&mantis->uart_work);
+	dprintk(MANTIS_DEBUG, 1, "UART successfully initialized");
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(mantis_uart_init);
+
+void mantis_uart_exit(struct mantis_pci *mantis)
+{
+	/* disable interrupt */
+	mmwrite(mmread(MANTIS_UART_CTL) & 0xffef, MANTIS_UART_CTL);
+	flush_work_sync(&mantis->uart_work);
+}
+EXPORT_SYMBOL_GPL(mantis_uart_exit);
