commit 9a33a27e7fe5b1aebf045829f92fd11562ad0ac7
Author: Mauro Carvalho Chehab <mchehab+huawei@kernel.org>
Date:   Thu Mar 26 15:23:34 2020 +0100

    media: ddbridge: use the ddbridge's own dummy fe driver
    
    Cleanup the ddbridge's dummy driver by removing the parts
    that aren't needed by ddbridge, adding it to the building
    system and changing the binding at the driver to use the
    newer function name.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab+huawei@kernel.org>

diff --git a/drivers/media/pci/ddbridge/ddbridge-dummy-fe.c b/drivers/media/pci/ddbridge/ddbridge-dummy-fe.c
index ebf4d9c30a55..6868a0c4fc82 100644
--- a/drivers/media/pci/ddbridge/ddbridge-dummy-fe.c
+++ b/drivers/media/pci/ddbridge/ddbridge-dummy-fe.c
@@ -13,12 +13,10 @@
 #include <media/dvb_frontend.h>
 #include "ddbridge-dummy-fe.h"
 
-
 struct ddbridge_dummy_fe_state {
 	struct dvb_frontend frontend;
 };
 
-
 static int ddbridge_dummy_fe_read_status(struct dvb_frontend *fe,
 				    enum fe_status *status)
 {
@@ -88,18 +86,6 @@ static int ddbridge_dummy_fe_init(struct dvb_frontend *fe)
 	return 0;
 }
 
-static int ddbridge_dummy_fe_set_tone(struct dvb_frontend *fe,
-				 enum fe_sec_tone_mode tone)
-{
-	return 0;
-}
-
-static int ddbridge_dummy_fe_set_voltage(struct dvb_frontend *fe,
-				    enum fe_sec_voltage voltage)
-{
-	return 0;
-}
-
 static void ddbridge_dummy_fe_release(struct dvb_frontend *fe)
 {
 	struct ddbridge_dummy_fe_state *state = fe->demodulator_priv;
@@ -107,48 +93,6 @@ static void ddbridge_dummy_fe_release(struct dvb_frontend *fe)
 	kfree(state);
 }
 
-static const struct dvb_frontend_ops ddbridge_dummy_fe_ofdm_ops;
-
-struct dvb_frontend *ddbridge_dummy_fe_ofdm_attach(void)
-{
-	struct ddbridge_dummy_fe_state *state = NULL;
-
-	/* allocate memory for the internal state */
-	state = kzalloc(sizeof(struct ddbridge_dummy_fe_state), GFP_KERNEL);
-	if (!state)
-		return NULL;
-
-	/* create dvb_frontend */
-	memcpy(&state->frontend.ops,
-	       &ddbridge_dummy_fe_ofdm_ops,
-	       sizeof(struct dvb_frontend_ops));
-
-	state->frontend.demodulator_priv = state;
-	return &state->frontend;
-}
-EXPORT_SYMBOL(ddbridge_dummy_fe_ofdm_attach);
-
-static const struct dvb_frontend_ops ddbridge_dummy_fe_qpsk_ops;
-
-struct dvb_frontend *ddbridge_dummy_fe_qpsk_attach(void)
-{
-	struct ddbridge_dummy_fe_state *state = NULL;
-
-	/* allocate memory for the internal state */
-	state = kzalloc(sizeof(struct ddbridge_dummy_fe_state), GFP_KERNEL);
-	if (!state)
-		return NULL;
-
-	/* create dvb_frontend */
-	memcpy(&state->frontend.ops,
-	       &ddbridge_dummy_fe_qpsk_ops,
-	       sizeof(struct dvb_frontend_ops));
-
-	state->frontend.demodulator_priv = state;
-	return &state->frontend;
-}
-EXPORT_SYMBOL(ddbridge_dummy_fe_qpsk_attach);
-
 static const struct dvb_frontend_ops ddbridge_dummy_fe_qam_ops;
 
 struct dvb_frontend *ddbridge_dummy_fe_qam_attach(void)
@@ -170,45 +114,6 @@ struct dvb_frontend *ddbridge_dummy_fe_qam_attach(void)
 }
 EXPORT_SYMBOL(ddbridge_dummy_fe_qam_attach);
 
-static const struct dvb_frontend_ops ddbridge_dummy_fe_ofdm_ops = {
-	.delsys = { SYS_DVBT },
-	.info = {
-		.name			= "ddbridge dummy DVB-T",
-		.frequency_min_hz	= 0,
-		.frequency_max_hz	= 863250 * kHz,
-		.frequency_stepsize_hz	= 62500,
-		.caps = FE_CAN_FEC_1_2 |
-			FE_CAN_FEC_2_3 |
-			FE_CAN_FEC_3_4 |
-			FE_CAN_FEC_4_5 |
-			FE_CAN_FEC_5_6 |
-			FE_CAN_FEC_6_7 |
-			FE_CAN_FEC_7_8 |
-			FE_CAN_FEC_8_9 |
-			FE_CAN_FEC_AUTO |
-			FE_CAN_QAM_16 |
-			FE_CAN_QAM_64 |
-			FE_CAN_QAM_AUTO |
-			FE_CAN_TRANSMISSION_MODE_AUTO |
-			FE_CAN_GUARD_INTERVAL_AUTO |
-			FE_CAN_HIERARCHY_AUTO,
-	},
-
-	.release = ddbridge_dummy_fe_release,
-
-	.init = ddbridge_dummy_fe_init,
-	.sleep = ddbridge_dummy_fe_sleep,
-
-	.set_frontend = ddbridge_dummy_fe_set_frontend,
-	.get_frontend = ddbridge_dummy_fe_get_frontend,
-
-	.read_status = ddbridge_dummy_fe_read_status,
-	.read_ber = ddbridge_dummy_fe_read_ber,
-	.read_signal_strength = ddbridge_dummy_fe_read_signal_strength,
-	.read_snr = ddbridge_dummy_fe_read_snr,
-	.read_ucblocks = ddbridge_dummy_fe_read_ucblocks,
-};
-
 static const struct dvb_frontend_ops ddbridge_dummy_fe_qam_ops = {
 	.delsys = { SYS_DVBC_ANNEX_A },
 	.info = {
@@ -243,44 +148,6 @@ static const struct dvb_frontend_ops ddbridge_dummy_fe_qam_ops = {
 	.read_ucblocks = ddbridge_dummy_fe_read_ucblocks,
 };
 
-static const struct dvb_frontend_ops ddbridge_dummy_fe_qpsk_ops = {
-	.delsys = { SYS_DVBS },
-	.info = {
-		.name			= "ddbridge dummy DVB-S",
-		.frequency_min_hz	=  950 * MHz,
-		.frequency_max_hz	= 2150 * MHz,
-		.frequency_stepsize_hz	= 250 * kHz,
-		.frequency_tolerance_hz	= 29500 * kHz,
-		.symbol_rate_min	= 1000000,
-		.symbol_rate_max	= 45000000,
-		.caps = FE_CAN_INVERSION_AUTO |
-			FE_CAN_FEC_1_2 |
-			FE_CAN_FEC_2_3 |
-			FE_CAN_FEC_3_4 |
-			FE_CAN_FEC_5_6 |
-			FE_CAN_FEC_7_8 |
-			FE_CAN_FEC_AUTO |
-			FE_CAN_QPSK
-	},
-
-	.release = ddbridge_dummy_fe_release,
-
-	.init = ddbridge_dummy_fe_init,
-	.sleep = ddbridge_dummy_fe_sleep,
-
-	.set_frontend = ddbridge_dummy_fe_set_frontend,
-	.get_frontend = ddbridge_dummy_fe_get_frontend,
-
-	.read_status = ddbridge_dummy_fe_read_status,
-	.read_ber = ddbridge_dummy_fe_read_ber,
-	.read_signal_strength = ddbridge_dummy_fe_read_signal_strength,
-	.read_snr = ddbridge_dummy_fe_read_snr,
-	.read_ucblocks = ddbridge_dummy_fe_read_ucblocks,
-
-	.set_voltage = ddbridge_dummy_fe_set_voltage,
-	.set_tone = ddbridge_dummy_fe_set_tone,
-};
-
 MODULE_DESCRIPTION("ddbridge dummy Frontend");
 MODULE_AUTHOR("Emard");
 MODULE_LICENSE("GPL");

commit 94ab24a2c886620fd3d0c0241d98b6c448cc8b38
Author: Mauro Carvalho Chehab <mchehab+huawei@kernel.org>
Date:   Thu Mar 26 15:08:59 2020 +0100

    media: ddbridge-dummy_fe: do some vars and function renames
    
    As the name of this driver is now ddbridge-dummy, do some
    renames internally.
    
    No functional changes.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab+huawei@kernel.org>

diff --git a/drivers/media/pci/ddbridge/ddbridge-dummy-fe.c b/drivers/media/pci/ddbridge/ddbridge-dummy-fe.c
index 9ff1ebaa5e04..ebf4d9c30a55 100644
--- a/drivers/media/pci/ddbridge/ddbridge-dummy-fe.c
+++ b/drivers/media/pci/ddbridge/ddbridge-dummy-fe.c
@@ -11,15 +11,15 @@
 #include <linux/slab.h>
 
 #include <media/dvb_frontend.h>
-#include "dvb_dummy_fe.h"
+#include "ddbridge-dummy-fe.h"
 
 
-struct dvb_dummy_fe_state {
+struct ddbridge_dummy_fe_state {
 	struct dvb_frontend frontend;
 };
 
 
-static int dvb_dummy_fe_read_status(struct dvb_frontend *fe,
+static int ddbridge_dummy_fe_read_status(struct dvb_frontend *fe,
 				    enum fe_status *status)
 {
 	*status = FE_HAS_SIGNAL
@@ -31,26 +31,26 @@ static int dvb_dummy_fe_read_status(struct dvb_frontend *fe,
 	return 0;
 }
 
-static int dvb_dummy_fe_read_ber(struct dvb_frontend *fe, u32 *ber)
+static int ddbridge_dummy_fe_read_ber(struct dvb_frontend *fe, u32 *ber)
 {
 	*ber = 0;
 	return 0;
 }
 
-static int dvb_dummy_fe_read_signal_strength(struct dvb_frontend *fe,
+static int ddbridge_dummy_fe_read_signal_strength(struct dvb_frontend *fe,
 					     u16 *strength)
 {
 	*strength = 0;
 	return 0;
 }
 
-static int dvb_dummy_fe_read_snr(struct dvb_frontend *fe, u16 *snr)
+static int ddbridge_dummy_fe_read_snr(struct dvb_frontend *fe, u16 *snr)
 {
 	*snr = 0;
 	return 0;
 }
 
-static int dvb_dummy_fe_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)
+static int ddbridge_dummy_fe_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)
 {
 	*ucblocks = 0;
 	return 0;
@@ -61,13 +61,13 @@ static int dvb_dummy_fe_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)
  * Also, it should check for the locks, in order to avoid report wrong data
  * to userspace.
  */
-static int dvb_dummy_fe_get_frontend(struct dvb_frontend *fe,
+static int ddbridge_dummy_fe_get_frontend(struct dvb_frontend *fe,
 				     struct dtv_frontend_properties *p)
 {
 	return 0;
 }
 
-static int dvb_dummy_fe_set_frontend(struct dvb_frontend *fe)
+static int ddbridge_dummy_fe_set_frontend(struct dvb_frontend *fe)
 {
 	if (fe->ops.tuner_ops.set_params) {
 		fe->ops.tuner_ops.set_params(fe);
@@ -78,102 +78,102 @@ static int dvb_dummy_fe_set_frontend(struct dvb_frontend *fe)
 	return 0;
 }
 
-static int dvb_dummy_fe_sleep(struct dvb_frontend *fe)
+static int ddbridge_dummy_fe_sleep(struct dvb_frontend *fe)
 {
 	return 0;
 }
 
-static int dvb_dummy_fe_init(struct dvb_frontend *fe)
+static int ddbridge_dummy_fe_init(struct dvb_frontend *fe)
 {
 	return 0;
 }
 
-static int dvb_dummy_fe_set_tone(struct dvb_frontend *fe,
+static int ddbridge_dummy_fe_set_tone(struct dvb_frontend *fe,
 				 enum fe_sec_tone_mode tone)
 {
 	return 0;
 }
 
-static int dvb_dummy_fe_set_voltage(struct dvb_frontend *fe,
+static int ddbridge_dummy_fe_set_voltage(struct dvb_frontend *fe,
 				    enum fe_sec_voltage voltage)
 {
 	return 0;
 }
 
-static void dvb_dummy_fe_release(struct dvb_frontend *fe)
+static void ddbridge_dummy_fe_release(struct dvb_frontend *fe)
 {
-	struct dvb_dummy_fe_state *state = fe->demodulator_priv;
+	struct ddbridge_dummy_fe_state *state = fe->demodulator_priv;
 
 	kfree(state);
 }
 
-static const struct dvb_frontend_ops dvb_dummy_fe_ofdm_ops;
+static const struct dvb_frontend_ops ddbridge_dummy_fe_ofdm_ops;
 
-struct dvb_frontend *dvb_dummy_fe_ofdm_attach(void)
+struct dvb_frontend *ddbridge_dummy_fe_ofdm_attach(void)
 {
-	struct dvb_dummy_fe_state *state = NULL;
+	struct ddbridge_dummy_fe_state *state = NULL;
 
 	/* allocate memory for the internal state */
-	state = kzalloc(sizeof(struct dvb_dummy_fe_state), GFP_KERNEL);
+	state = kzalloc(sizeof(struct ddbridge_dummy_fe_state), GFP_KERNEL);
 	if (!state)
 		return NULL;
 
 	/* create dvb_frontend */
 	memcpy(&state->frontend.ops,
-	       &dvb_dummy_fe_ofdm_ops,
+	       &ddbridge_dummy_fe_ofdm_ops,
 	       sizeof(struct dvb_frontend_ops));
 
 	state->frontend.demodulator_priv = state;
 	return &state->frontend;
 }
-EXPORT_SYMBOL(dvb_dummy_fe_ofdm_attach);
+EXPORT_SYMBOL(ddbridge_dummy_fe_ofdm_attach);
 
-static const struct dvb_frontend_ops dvb_dummy_fe_qpsk_ops;
+static const struct dvb_frontend_ops ddbridge_dummy_fe_qpsk_ops;
 
-struct dvb_frontend *dvb_dummy_fe_qpsk_attach(void)
+struct dvb_frontend *ddbridge_dummy_fe_qpsk_attach(void)
 {
-	struct dvb_dummy_fe_state *state = NULL;
+	struct ddbridge_dummy_fe_state *state = NULL;
 
 	/* allocate memory for the internal state */
-	state = kzalloc(sizeof(struct dvb_dummy_fe_state), GFP_KERNEL);
+	state = kzalloc(sizeof(struct ddbridge_dummy_fe_state), GFP_KERNEL);
 	if (!state)
 		return NULL;
 
 	/* create dvb_frontend */
 	memcpy(&state->frontend.ops,
-	       &dvb_dummy_fe_qpsk_ops,
+	       &ddbridge_dummy_fe_qpsk_ops,
 	       sizeof(struct dvb_frontend_ops));
 
 	state->frontend.demodulator_priv = state;
 	return &state->frontend;
 }
-EXPORT_SYMBOL(dvb_dummy_fe_qpsk_attach);
+EXPORT_SYMBOL(ddbridge_dummy_fe_qpsk_attach);
 
-static const struct dvb_frontend_ops dvb_dummy_fe_qam_ops;
+static const struct dvb_frontend_ops ddbridge_dummy_fe_qam_ops;
 
-struct dvb_frontend *dvb_dummy_fe_qam_attach(void)
+struct dvb_frontend *ddbridge_dummy_fe_qam_attach(void)
 {
-	struct dvb_dummy_fe_state *state = NULL;
+	struct ddbridge_dummy_fe_state *state = NULL;
 
 	/* allocate memory for the internal state */
-	state = kzalloc(sizeof(struct dvb_dummy_fe_state), GFP_KERNEL);
+	state = kzalloc(sizeof(struct ddbridge_dummy_fe_state), GFP_KERNEL);
 	if (!state)
 		return NULL;
 
 	/* create dvb_frontend */
 	memcpy(&state->frontend.ops,
-	       &dvb_dummy_fe_qam_ops,
+	       &ddbridge_dummy_fe_qam_ops,
 	       sizeof(struct dvb_frontend_ops));
 
 	state->frontend.demodulator_priv = state;
 	return &state->frontend;
 }
-EXPORT_SYMBOL(dvb_dummy_fe_qam_attach);
+EXPORT_SYMBOL(ddbridge_dummy_fe_qam_attach);
 
-static const struct dvb_frontend_ops dvb_dummy_fe_ofdm_ops = {
+static const struct dvb_frontend_ops ddbridge_dummy_fe_ofdm_ops = {
 	.delsys = { SYS_DVBT },
 	.info = {
-		.name			= "Dummy DVB-T",
+		.name			= "ddbridge dummy DVB-T",
 		.frequency_min_hz	= 0,
 		.frequency_max_hz	= 863250 * kHz,
 		.frequency_stepsize_hz	= 62500,
@@ -194,25 +194,25 @@ static const struct dvb_frontend_ops dvb_dummy_fe_ofdm_ops = {
 			FE_CAN_HIERARCHY_AUTO,
 	},
 
-	.release = dvb_dummy_fe_release,
+	.release = ddbridge_dummy_fe_release,
 
-	.init = dvb_dummy_fe_init,
-	.sleep = dvb_dummy_fe_sleep,
+	.init = ddbridge_dummy_fe_init,
+	.sleep = ddbridge_dummy_fe_sleep,
 
-	.set_frontend = dvb_dummy_fe_set_frontend,
-	.get_frontend = dvb_dummy_fe_get_frontend,
+	.set_frontend = ddbridge_dummy_fe_set_frontend,
+	.get_frontend = ddbridge_dummy_fe_get_frontend,
 
-	.read_status = dvb_dummy_fe_read_status,
-	.read_ber = dvb_dummy_fe_read_ber,
-	.read_signal_strength = dvb_dummy_fe_read_signal_strength,
-	.read_snr = dvb_dummy_fe_read_snr,
-	.read_ucblocks = dvb_dummy_fe_read_ucblocks,
+	.read_status = ddbridge_dummy_fe_read_status,
+	.read_ber = ddbridge_dummy_fe_read_ber,
+	.read_signal_strength = ddbridge_dummy_fe_read_signal_strength,
+	.read_snr = ddbridge_dummy_fe_read_snr,
+	.read_ucblocks = ddbridge_dummy_fe_read_ucblocks,
 };
 
-static const struct dvb_frontend_ops dvb_dummy_fe_qam_ops = {
+static const struct dvb_frontend_ops ddbridge_dummy_fe_qam_ops = {
 	.delsys = { SYS_DVBC_ANNEX_A },
 	.info = {
-		.name			= "Dummy DVB-C",
+		.name			= "ddbridge dummy DVB-C",
 		.frequency_min_hz	=  51 * MHz,
 		.frequency_max_hz	= 858 * MHz,
 		.frequency_stepsize_hz	= 62500,
@@ -228,25 +228,25 @@ static const struct dvb_frontend_ops dvb_dummy_fe_qam_ops = {
 			FE_CAN_INVERSION_AUTO
 	},
 
-	.release = dvb_dummy_fe_release,
+	.release = ddbridge_dummy_fe_release,
 
-	.init = dvb_dummy_fe_init,
-	.sleep = dvb_dummy_fe_sleep,
+	.init = ddbridge_dummy_fe_init,
+	.sleep = ddbridge_dummy_fe_sleep,
 
-	.set_frontend = dvb_dummy_fe_set_frontend,
-	.get_frontend = dvb_dummy_fe_get_frontend,
+	.set_frontend = ddbridge_dummy_fe_set_frontend,
+	.get_frontend = ddbridge_dummy_fe_get_frontend,
 
-	.read_status = dvb_dummy_fe_read_status,
-	.read_ber = dvb_dummy_fe_read_ber,
-	.read_signal_strength = dvb_dummy_fe_read_signal_strength,
-	.read_snr = dvb_dummy_fe_read_snr,
-	.read_ucblocks = dvb_dummy_fe_read_ucblocks,
+	.read_status = ddbridge_dummy_fe_read_status,
+	.read_ber = ddbridge_dummy_fe_read_ber,
+	.read_signal_strength = ddbridge_dummy_fe_read_signal_strength,
+	.read_snr = ddbridge_dummy_fe_read_snr,
+	.read_ucblocks = ddbridge_dummy_fe_read_ucblocks,
 };
 
-static const struct dvb_frontend_ops dvb_dummy_fe_qpsk_ops = {
+static const struct dvb_frontend_ops ddbridge_dummy_fe_qpsk_ops = {
 	.delsys = { SYS_DVBS },
 	.info = {
-		.name			= "Dummy DVB-S",
+		.name			= "ddbridge dummy DVB-S",
 		.frequency_min_hz	=  950 * MHz,
 		.frequency_max_hz	= 2150 * MHz,
 		.frequency_stepsize_hz	= 250 * kHz,
@@ -263,24 +263,24 @@ static const struct dvb_frontend_ops dvb_dummy_fe_qpsk_ops = {
 			FE_CAN_QPSK
 	},
 
-	.release = dvb_dummy_fe_release,
+	.release = ddbridge_dummy_fe_release,
 
-	.init = dvb_dummy_fe_init,
-	.sleep = dvb_dummy_fe_sleep,
+	.init = ddbridge_dummy_fe_init,
+	.sleep = ddbridge_dummy_fe_sleep,
 
-	.set_frontend = dvb_dummy_fe_set_frontend,
-	.get_frontend = dvb_dummy_fe_get_frontend,
+	.set_frontend = ddbridge_dummy_fe_set_frontend,
+	.get_frontend = ddbridge_dummy_fe_get_frontend,
 
-	.read_status = dvb_dummy_fe_read_status,
-	.read_ber = dvb_dummy_fe_read_ber,
-	.read_signal_strength = dvb_dummy_fe_read_signal_strength,
-	.read_snr = dvb_dummy_fe_read_snr,
-	.read_ucblocks = dvb_dummy_fe_read_ucblocks,
+	.read_status = ddbridge_dummy_fe_read_status,
+	.read_ber = ddbridge_dummy_fe_read_ber,
+	.read_signal_strength = ddbridge_dummy_fe_read_signal_strength,
+	.read_snr = ddbridge_dummy_fe_read_snr,
+	.read_ucblocks = ddbridge_dummy_fe_read_ucblocks,
 
-	.set_voltage = dvb_dummy_fe_set_voltage,
-	.set_tone = dvb_dummy_fe_set_tone,
+	.set_voltage = ddbridge_dummy_fe_set_voltage,
+	.set_tone = ddbridge_dummy_fe_set_tone,
 };
 
-MODULE_DESCRIPTION("DVB DUMMY Frontend");
+MODULE_DESCRIPTION("ddbridge dummy Frontend");
 MODULE_AUTHOR("Emard");
 MODULE_LICENSE("GPL");

commit 3a137f81f76850b3cc024360147b1c3fb4b12c03
Author: Mauro Carvalho Chehab <mchehab+huawei@kernel.org>
Date:   Thu Mar 26 15:06:02 2020 +0100

    media: ddbridge: copy the dvb_dummy_fe driver to ddbridge
    
    As we'll be transforming the dvb-dummy-fe driver soon into a
    virtual driver, let's first copy the existing one to ddbridge
    as-is, as it is needed there.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab+huawei@kernel.org>

diff --git a/drivers/media/pci/ddbridge/ddbridge-dummy-fe.c b/drivers/media/pci/ddbridge/ddbridge-dummy-fe.c
new file mode 100644
index 000000000000..9ff1ebaa5e04
--- /dev/null
+++ b/drivers/media/pci/ddbridge/ddbridge-dummy-fe.c
@@ -0,0 +1,286 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ *  Driver for Dummy Frontend
+ *
+ *  Written by Emard <emard@softhome.net>
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+
+#include <media/dvb_frontend.h>
+#include "dvb_dummy_fe.h"
+
+
+struct dvb_dummy_fe_state {
+	struct dvb_frontend frontend;
+};
+
+
+static int dvb_dummy_fe_read_status(struct dvb_frontend *fe,
+				    enum fe_status *status)
+{
+	*status = FE_HAS_SIGNAL
+		| FE_HAS_CARRIER
+		| FE_HAS_VITERBI
+		| FE_HAS_SYNC
+		| FE_HAS_LOCK;
+
+	return 0;
+}
+
+static int dvb_dummy_fe_read_ber(struct dvb_frontend *fe, u32 *ber)
+{
+	*ber = 0;
+	return 0;
+}
+
+static int dvb_dummy_fe_read_signal_strength(struct dvb_frontend *fe,
+					     u16 *strength)
+{
+	*strength = 0;
+	return 0;
+}
+
+static int dvb_dummy_fe_read_snr(struct dvb_frontend *fe, u16 *snr)
+{
+	*snr = 0;
+	return 0;
+}
+
+static int dvb_dummy_fe_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)
+{
+	*ucblocks = 0;
+	return 0;
+}
+
+/*
+ * Should only be implemented if it actually reads something from the hardware.
+ * Also, it should check for the locks, in order to avoid report wrong data
+ * to userspace.
+ */
+static int dvb_dummy_fe_get_frontend(struct dvb_frontend *fe,
+				     struct dtv_frontend_properties *p)
+{
+	return 0;
+}
+
+static int dvb_dummy_fe_set_frontend(struct dvb_frontend *fe)
+{
+	if (fe->ops.tuner_ops.set_params) {
+		fe->ops.tuner_ops.set_params(fe);
+		if (fe->ops.i2c_gate_ctrl)
+			fe->ops.i2c_gate_ctrl(fe, 0);
+	}
+
+	return 0;
+}
+
+static int dvb_dummy_fe_sleep(struct dvb_frontend *fe)
+{
+	return 0;
+}
+
+static int dvb_dummy_fe_init(struct dvb_frontend *fe)
+{
+	return 0;
+}
+
+static int dvb_dummy_fe_set_tone(struct dvb_frontend *fe,
+				 enum fe_sec_tone_mode tone)
+{
+	return 0;
+}
+
+static int dvb_dummy_fe_set_voltage(struct dvb_frontend *fe,
+				    enum fe_sec_voltage voltage)
+{
+	return 0;
+}
+
+static void dvb_dummy_fe_release(struct dvb_frontend *fe)
+{
+	struct dvb_dummy_fe_state *state = fe->demodulator_priv;
+
+	kfree(state);
+}
+
+static const struct dvb_frontend_ops dvb_dummy_fe_ofdm_ops;
+
+struct dvb_frontend *dvb_dummy_fe_ofdm_attach(void)
+{
+	struct dvb_dummy_fe_state *state = NULL;
+
+	/* allocate memory for the internal state */
+	state = kzalloc(sizeof(struct dvb_dummy_fe_state), GFP_KERNEL);
+	if (!state)
+		return NULL;
+
+	/* create dvb_frontend */
+	memcpy(&state->frontend.ops,
+	       &dvb_dummy_fe_ofdm_ops,
+	       sizeof(struct dvb_frontend_ops));
+
+	state->frontend.demodulator_priv = state;
+	return &state->frontend;
+}
+EXPORT_SYMBOL(dvb_dummy_fe_ofdm_attach);
+
+static const struct dvb_frontend_ops dvb_dummy_fe_qpsk_ops;
+
+struct dvb_frontend *dvb_dummy_fe_qpsk_attach(void)
+{
+	struct dvb_dummy_fe_state *state = NULL;
+
+	/* allocate memory for the internal state */
+	state = kzalloc(sizeof(struct dvb_dummy_fe_state), GFP_KERNEL);
+	if (!state)
+		return NULL;
+
+	/* create dvb_frontend */
+	memcpy(&state->frontend.ops,
+	       &dvb_dummy_fe_qpsk_ops,
+	       sizeof(struct dvb_frontend_ops));
+
+	state->frontend.demodulator_priv = state;
+	return &state->frontend;
+}
+EXPORT_SYMBOL(dvb_dummy_fe_qpsk_attach);
+
+static const struct dvb_frontend_ops dvb_dummy_fe_qam_ops;
+
+struct dvb_frontend *dvb_dummy_fe_qam_attach(void)
+{
+	struct dvb_dummy_fe_state *state = NULL;
+
+	/* allocate memory for the internal state */
+	state = kzalloc(sizeof(struct dvb_dummy_fe_state), GFP_KERNEL);
+	if (!state)
+		return NULL;
+
+	/* create dvb_frontend */
+	memcpy(&state->frontend.ops,
+	       &dvb_dummy_fe_qam_ops,
+	       sizeof(struct dvb_frontend_ops));
+
+	state->frontend.demodulator_priv = state;
+	return &state->frontend;
+}
+EXPORT_SYMBOL(dvb_dummy_fe_qam_attach);
+
+static const struct dvb_frontend_ops dvb_dummy_fe_ofdm_ops = {
+	.delsys = { SYS_DVBT },
+	.info = {
+		.name			= "Dummy DVB-T",
+		.frequency_min_hz	= 0,
+		.frequency_max_hz	= 863250 * kHz,
+		.frequency_stepsize_hz	= 62500,
+		.caps = FE_CAN_FEC_1_2 |
+			FE_CAN_FEC_2_3 |
+			FE_CAN_FEC_3_4 |
+			FE_CAN_FEC_4_5 |
+			FE_CAN_FEC_5_6 |
+			FE_CAN_FEC_6_7 |
+			FE_CAN_FEC_7_8 |
+			FE_CAN_FEC_8_9 |
+			FE_CAN_FEC_AUTO |
+			FE_CAN_QAM_16 |
+			FE_CAN_QAM_64 |
+			FE_CAN_QAM_AUTO |
+			FE_CAN_TRANSMISSION_MODE_AUTO |
+			FE_CAN_GUARD_INTERVAL_AUTO |
+			FE_CAN_HIERARCHY_AUTO,
+	},
+
+	.release = dvb_dummy_fe_release,
+
+	.init = dvb_dummy_fe_init,
+	.sleep = dvb_dummy_fe_sleep,
+
+	.set_frontend = dvb_dummy_fe_set_frontend,
+	.get_frontend = dvb_dummy_fe_get_frontend,
+
+	.read_status = dvb_dummy_fe_read_status,
+	.read_ber = dvb_dummy_fe_read_ber,
+	.read_signal_strength = dvb_dummy_fe_read_signal_strength,
+	.read_snr = dvb_dummy_fe_read_snr,
+	.read_ucblocks = dvb_dummy_fe_read_ucblocks,
+};
+
+static const struct dvb_frontend_ops dvb_dummy_fe_qam_ops = {
+	.delsys = { SYS_DVBC_ANNEX_A },
+	.info = {
+		.name			= "Dummy DVB-C",
+		.frequency_min_hz	=  51 * MHz,
+		.frequency_max_hz	= 858 * MHz,
+		.frequency_stepsize_hz	= 62500,
+		/* symbol_rate_min: SACLK/64 == (XIN/2)/64 */
+		.symbol_rate_min	= (57840000 / 2) / 64,
+		.symbol_rate_max	= (57840000 / 2) / 4,   /* SACLK/4 */
+		.caps = FE_CAN_QAM_16 |
+			FE_CAN_QAM_32 |
+			FE_CAN_QAM_64 |
+			FE_CAN_QAM_128 |
+			FE_CAN_QAM_256 |
+			FE_CAN_FEC_AUTO |
+			FE_CAN_INVERSION_AUTO
+	},
+
+	.release = dvb_dummy_fe_release,
+
+	.init = dvb_dummy_fe_init,
+	.sleep = dvb_dummy_fe_sleep,
+
+	.set_frontend = dvb_dummy_fe_set_frontend,
+	.get_frontend = dvb_dummy_fe_get_frontend,
+
+	.read_status = dvb_dummy_fe_read_status,
+	.read_ber = dvb_dummy_fe_read_ber,
+	.read_signal_strength = dvb_dummy_fe_read_signal_strength,
+	.read_snr = dvb_dummy_fe_read_snr,
+	.read_ucblocks = dvb_dummy_fe_read_ucblocks,
+};
+
+static const struct dvb_frontend_ops dvb_dummy_fe_qpsk_ops = {
+	.delsys = { SYS_DVBS },
+	.info = {
+		.name			= "Dummy DVB-S",
+		.frequency_min_hz	=  950 * MHz,
+		.frequency_max_hz	= 2150 * MHz,
+		.frequency_stepsize_hz	= 250 * kHz,
+		.frequency_tolerance_hz	= 29500 * kHz,
+		.symbol_rate_min	= 1000000,
+		.symbol_rate_max	= 45000000,
+		.caps = FE_CAN_INVERSION_AUTO |
+			FE_CAN_FEC_1_2 |
+			FE_CAN_FEC_2_3 |
+			FE_CAN_FEC_3_4 |
+			FE_CAN_FEC_5_6 |
+			FE_CAN_FEC_7_8 |
+			FE_CAN_FEC_AUTO |
+			FE_CAN_QPSK
+	},
+
+	.release = dvb_dummy_fe_release,
+
+	.init = dvb_dummy_fe_init,
+	.sleep = dvb_dummy_fe_sleep,
+
+	.set_frontend = dvb_dummy_fe_set_frontend,
+	.get_frontend = dvb_dummy_fe_get_frontend,
+
+	.read_status = dvb_dummy_fe_read_status,
+	.read_ber = dvb_dummy_fe_read_ber,
+	.read_signal_strength = dvb_dummy_fe_read_signal_strength,
+	.read_snr = dvb_dummy_fe_read_snr,
+	.read_ucblocks = dvb_dummy_fe_read_ucblocks,
+
+	.set_voltage = dvb_dummy_fe_set_voltage,
+	.set_tone = dvb_dummy_fe_set_tone,
+};
+
+MODULE_DESCRIPTION("DVB DUMMY Frontend");
+MODULE_AUTHOR("Emard");
+MODULE_LICENSE("GPL");
