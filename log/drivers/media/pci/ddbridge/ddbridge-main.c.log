commit 79150ac9f35b9de532b74cf1288371091b5897ed
Author: Daniel Scheller <d.scheller@gmx.net>
Date:   Tue Jun 19 14:50:10 2018 -0400

    media: ddbridge: header/boilerplate cleanups and cosmetics
    
    Cleanup blank lines, remove wrong links to
    http://www.gnu.org/copyleft/gpl.html (the driver is licensed under the
    terms of GPLv2, but the link points to a copy of the GPLv3), and fix
    the filename reference in ddbridge-i2c.h.
    
    [mchehab@kernel.org: removed whitespace changes at the licensing text,
     as we didn't get any acks from the authors with regards to changing
     the text]
    Cc: Ralph Metzler <rjkm@metzlerbros.de>
    Cc: Manfred Voelkel <mvoelkel@DigitalDevices.de>
    Signed-off-by: Daniel Scheller <d.scheller@gmx.net>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/pci/ddbridge/ddbridge-main.c b/drivers/media/pci/ddbridge/ddbridge-main.c
index 419a30bd9c21..03dc9924fa2c 100644
--- a/drivers/media/pci/ddbridge/ddbridge-main.c
+++ b/drivers/media/pci/ddbridge/ddbridge-main.c
@@ -14,7 +14,6 @@
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- *
  */
 
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt

commit 4771d831e2f9a6f580fc0873102c0364e9349947
Author: Daniel Scheller <d.scheller@gmx.net>
Date:   Tue Jun 19 14:50:09 2018 -0400

    media: ddbridge: add SPDX license identifiers
    
    Since the boilerplates and MODULE_LICENSE are now in sync regarding the
    used license (GPL v2 only), add a matching GPLv2 SPDX license identifier
    to all files of the ddbridge driver.
    
    Cc: Ralph Metzler <rjkm@metzlerbros.de>
    Cc: Manfred Voelkel <mvoelkel@DigitalDevices.de>
    Signed-off-by: Daniel Scheller <d.scheller@gmx.net>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/pci/ddbridge/ddbridge-main.c b/drivers/media/pci/ddbridge/ddbridge-main.c
index 6f3ea927bde5..419a30bd9c21 100644
--- a/drivers/media/pci/ddbridge/ddbridge-main.c
+++ b/drivers/media/pci/ddbridge/ddbridge-main.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * ddbridge.c: Digital Devices PCIe bridge driver
  *

commit 229b6ea6894be4714e49dbcb0e2f391ea7d20d02
Author: Daniel Scheller <d.scheller@gmx.net>
Date:   Tue Jun 19 14:50:08 2018 -0400

    media: mxl5xx/stv0910/stv6111/ddbridge: fix MODULE_LICENSE to 'GPL v2'
    
    In commit 3db30defab4b ("use correct MODULE_LINCESE for GPL v2 only
    according to notice in header") in the upstream repository for the
    mentioned four drivers at https://github.com/DigitalDevices/dddvb.git
    (plus a few more which aren't part of the mainline kernel tree), the
    MODULE_LICENSE was fixed to "GPL v2" and are now in sync with the
    GPL copyright boilerplate. Apply this change to the kernel tree
    drivers as well.
    
    Cc: Ralph Metzler <rjkm@metzlerbros.de>
    Cc: Manfred Voelkel <mvoelkel@DigitalDevices.de>
    Signed-off-by: Daniel Scheller <d.scheller@gmx.net>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/pci/ddbridge/ddbridge-main.c b/drivers/media/pci/ddbridge/ddbridge-main.c
index f4748cfd904b..6f3ea927bde5 100644
--- a/drivers/media/pci/ddbridge/ddbridge-main.c
+++ b/drivers/media/pci/ddbridge/ddbridge-main.c
@@ -318,5 +318,5 @@ module_exit(module_exit_ddbridge);
 
 MODULE_DESCRIPTION("Digital Devices PCIe Bridge");
 MODULE_AUTHOR("Ralph and Marcus Metzler, Metzler Brothers Systementwicklung GbR");
-MODULE_LICENSE("GPL");
+MODULE_LICENSE("GPL v2");
 MODULE_VERSION(DDBRIDGE_VERSION);

commit c3eda33026fb81f952c77050176628e02e40218d
Author: Daniel Scheller <d.scheller@gmx.net>
Date:   Mon Apr 9 12:47:50 2018 -0400

    media: ddbridge: add hardware defs and PCI IDs for MCI cards
    
    Add PCI IDs and ddb_info for the new MCI-based MaxSX8 cards. Also add
    needed defines so the cards can be hooked up into ddbridge's probe and
    attach handling.
    
    Picked up from the upstream dddvb-0.9.33 release.
    
    Signed-off-by: Daniel Scheller <d.scheller@gmx.net>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/pci/ddbridge/ddbridge-main.c b/drivers/media/pci/ddbridge/ddbridge-main.c
index 6356b48b3874..f4748cfd904b 100644
--- a/drivers/media/pci/ddbridge/ddbridge-main.c
+++ b/drivers/media/pci/ddbridge/ddbridge-main.c
@@ -264,6 +264,7 @@ static const struct pci_device_id ddb_id_table[] = {
 	DDB_DEVICE_ANY(0x0006),
 	DDB_DEVICE_ANY(0x0007),
 	DDB_DEVICE_ANY(0x0008),
+	DDB_DEVICE_ANY(0x0009),
 	DDB_DEVICE_ANY(0x0011),
 	DDB_DEVICE_ANY(0x0012),
 	DDB_DEVICE_ANY(0x0013),

commit 60586360f14e6651d00afa826515e0addb877aeb
Author: Daniel Scheller <d.scheller@gmx.net>
Date:   Mon Apr 9 12:47:45 2018 -0400

    media: ddbridge: set devid entry for link 0
    
    Currently, /sys/class/ddbridgeX/devid always reports 0 due to devid not
    being set at all. Set the devid field alongside while storing all other
    hardware ID data.
    
    Picked up from the upstream dddvb-0.9.33 release.
    
    Signed-off-by: Daniel Scheller <d.scheller@gmx.net>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/pci/ddbridge/ddbridge-main.c b/drivers/media/pci/ddbridge/ddbridge-main.c
index 008be9066814..6356b48b3874 100644
--- a/drivers/media/pci/ddbridge/ddbridge-main.c
+++ b/drivers/media/pci/ddbridge/ddbridge-main.c
@@ -198,6 +198,7 @@ static int ddb_probe(struct pci_dev *pdev,
 	dev->link[0].ids.device = id->device;
 	dev->link[0].ids.subvendor = id->subvendor;
 	dev->link[0].ids.subdevice = pdev->subsystem_device;
+	dev->link[0].ids.devid = (id->device << 16) | id->vendor;
 
 	dev->link[0].dev = dev;
 	dev->link[0].info = get_ddb_info(id->vendor, id->device,

commit 6bf0f0512a85c0a28c2e879fc0f6f7f44008d588
Author: Daniel Scheller <d.scheller@gmx.net>
Date:   Mon Apr 9 12:47:39 2018 -0400

    media: ddbridge: request/free_irq using pci_irq_vector, enable MSI-X
    
    Instead of trying to manage IRQ numbers on itself, utilise the
    pci_irq_vector() function to do this, which will take care of correct IRQ
    numbering for MSI and non-MSI IRQs. While at it, request and enable MSI-X
    interrupts for hardware (boards and cards) that support this.
    
    Picked up from the upstream dddvb-0.9.33 release.
    
    Signed-off-by: Daniel Scheller <d.scheller@gmx.net>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/pci/ddbridge/ddbridge-main.c b/drivers/media/pci/ddbridge/ddbridge-main.c
index 77089081db1f..008be9066814 100644
--- a/drivers/media/pci/ddbridge/ddbridge-main.c
+++ b/drivers/media/pci/ddbridge/ddbridge-main.c
@@ -77,8 +77,8 @@ static void ddb_irq_exit(struct ddb *dev)
 {
 	ddb_irq_disable(dev);
 	if (dev->msi == 2)
-		free_irq(dev->pdev->irq + 1, dev);
-	free_irq(dev->pdev->irq, dev);
+		free_irq(pci_irq_vector(dev->pdev, 1), dev);
+	free_irq(pci_irq_vector(dev->pdev, 0), dev);
 }
 
 static void ddb_remove(struct pci_dev *pdev)
@@ -105,7 +105,8 @@ static void ddb_irq_msi(struct ddb *dev, int nr)
 	int stat;
 
 	if (msi && pci_msi_enabled()) {
-		stat = pci_alloc_irq_vectors(dev->pdev, 1, nr, PCI_IRQ_MSI);
+		stat = pci_alloc_irq_vectors(dev->pdev, 1, nr,
+					     PCI_IRQ_MSI | PCI_IRQ_MSIX);
 		if (stat >= 1) {
 			dev->msi = stat;
 			dev_info(dev->dev, "using %d MSI interrupt(s)\n",
@@ -137,21 +138,24 @@ static int ddb_irq_init(struct ddb *dev)
 	if (dev->msi)
 		irq_flag = 0;
 	if (dev->msi == 2) {
-		stat = request_irq(dev->pdev->irq, ddb_irq_handler0,
-				   irq_flag, "ddbridge", (void *)dev);
+		stat = request_irq(pci_irq_vector(dev->pdev, 0),
+				   ddb_irq_handler0, irq_flag, "ddbridge",
+				   (void *)dev);
 		if (stat < 0)
 			return stat;
-		stat = request_irq(dev->pdev->irq + 1, ddb_irq_handler1,
-				   irq_flag, "ddbridge", (void *)dev);
+		stat = request_irq(pci_irq_vector(dev->pdev, 1),
+				   ddb_irq_handler1, irq_flag, "ddbridge",
+				   (void *)dev);
 		if (stat < 0) {
-			free_irq(dev->pdev->irq, dev);
+			free_irq(pci_irq_vector(dev->pdev, 0), dev);
 			return stat;
 		}
 	} else
 #endif
 	{
-		stat = request_irq(dev->pdev->irq, ddb_irq_handler,
-				   irq_flag, "ddbridge", (void *)dev);
+		stat = request_irq(pci_irq_vector(dev->pdev, 0),
+				   ddb_irq_handler, irq_flag, "ddbridge",
+				   (void *)dev);
 		if (stat < 0)
 			return stat;
 	}

commit 95c2ab9e21df95ed5830f1de561301609df1c20a
Author: Daniel Scheller <d.scheller@gmx.net>
Date:   Mon Apr 9 12:47:38 2018 -0400

    media: ddbridge: move MSI IRQ cleanup to a helper function
    
    Introduce the ddb_msi_exit() helper to be used for cleaning up previously
    allocated MSI IRQ vectors. Deduplicates code and makes things look
    cleaner as for all cleanup work the CONFIG_PCI_MSI ifdeffery is only
    needed in the helper now. Also, replace the call to the deprecated
    pci_disable_msi() function with pci_free_irq_vectors().
    
    Picked up from the upstream dddvb-0.9.33 release.
    
    Signed-off-by: Daniel Scheller <d.scheller@gmx.net>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/pci/ddbridge/ddbridge-main.c b/drivers/media/pci/ddbridge/ddbridge-main.c
index 7088162af9d3..77089081db1f 100644
--- a/drivers/media/pci/ddbridge/ddbridge-main.c
+++ b/drivers/media/pci/ddbridge/ddbridge-main.c
@@ -65,16 +65,20 @@ static void ddb_irq_disable(struct ddb *dev)
 	ddbwritel(dev, 0, MSI1_ENABLE);
 }
 
+static void ddb_msi_exit(struct ddb *dev)
+{
+#ifdef CONFIG_PCI_MSI
+	if (dev->msi)
+		pci_free_irq_vectors(dev->pdev);
+#endif
+}
+
 static void ddb_irq_exit(struct ddb *dev)
 {
 	ddb_irq_disable(dev);
 	if (dev->msi == 2)
 		free_irq(dev->pdev->irq + 1, dev);
 	free_irq(dev->pdev->irq, dev);
-#ifdef CONFIG_PCI_MSI
-	if (dev->msi)
-		pci_disable_msi(dev->pdev);
-#endif
 }
 
 static void ddb_remove(struct pci_dev *pdev)
@@ -86,6 +90,7 @@ static void ddb_remove(struct pci_dev *pdev)
 	ddb_i2c_release(dev);
 
 	ddb_irq_exit(dev);
+	ddb_msi_exit(dev);
 	ddb_ports_release(dev);
 	ddb_buffers_free(dev);
 
@@ -230,8 +235,7 @@ static int ddb_probe(struct pci_dev *pdev,
 	ddb_irq_exit(dev);
 fail0:
 	dev_err(&pdev->dev, "fail0\n");
-	if (dev->msi)
-		pci_disable_msi(dev->pdev);
+	ddb_msi_exit(dev);
 fail:
 	dev_err(&pdev->dev, "fail\n");
 

commit 05ed62da032afac412690c338fb9fa5063bfa4b8
Author: Daniel Scheller <d.scheller@gmx.net>
Date:   Mon Apr 9 12:47:37 2018 -0400

    media: ddbridge: move ddb_wq and the wq+class initialisation to -core
    
    Move the ddbridge module initialisation and cleanup code to ddbridge-core
    and set up the ddb_wq workqueue there, and create and destroy the ddb
    device class there aswell. Due to this, the prototypes for ddb_wq,
    ddb_class_create() and ddb_class_destroy() aren't required in ddbridge.h
    anymore, so remove them. Also, declare ddb_wq and the ddb_class_*()
    functions static.
    
    Picked up from the upstream dddvb-0.9.33 release.
    
    Signed-off-by: Daniel Scheller <d.scheller@gmx.net>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/pci/ddbridge/ddbridge-main.c b/drivers/media/pci/ddbridge/ddbridge-main.c
index bde04dc39080..7088162af9d3 100644
--- a/drivers/media/pci/ddbridge/ddbridge-main.c
+++ b/drivers/media/pci/ddbridge/ddbridge-main.c
@@ -282,32 +282,25 @@ static struct pci_driver ddb_pci_driver = {
 
 static __init int module_init_ddbridge(void)
 {
-	int stat = -1;
+	int stat;
 
 	pr_info("Digital Devices PCIE bridge driver "
 		DDBRIDGE_VERSION
 		", Copyright (C) 2010-17 Digital Devices GmbH\n");
-	if (ddb_class_create() < 0)
-		return -1;
-	ddb_wq = create_workqueue("ddbridge");
-	if (!ddb_wq)
-		goto exit1;
+	stat = ddb_init_ddbridge();
+	if (stat < 0)
+		return stat;
 	stat = pci_register_driver(&ddb_pci_driver);
 	if (stat < 0)
-		goto exit2;
-	return stat;
-exit2:
-	destroy_workqueue(ddb_wq);
-exit1:
-	ddb_class_destroy();
+		ddb_exit_ddbridge(0, stat);
+
 	return stat;
 }
 
 static __exit void module_exit_ddbridge(void)
 {
 	pci_unregister_driver(&ddb_pci_driver);
-	destroy_workqueue(ddb_wq);
-	ddb_class_destroy();
+	ddb_exit_ddbridge(0, 0);
 }
 
 module_init(module_init_ddbridge);

commit 5589974ecdd761758f5632e4441f4d11a96a74f5
Author: Daniel Scheller <d.scheller@gmx.net>
Date:   Mon Apr 9 12:47:36 2018 -0400

    media: ddbridge: move modparams to ddbridge-core.c
    
    Besides the 'msi' module option, all options are used from within
    ddbridge-core only, so move them over from ddbridge-main, and declare the
    associated variables static. Since the prototypes in ddbridge.h aren't
    necessary anymore now, remove them. As a side effect, this has the benefit
    of aligning things more with the dddvb upstream.
    
    Signed-off-by: Daniel Scheller <d.scheller@gmx.net>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/pci/ddbridge/ddbridge-main.c b/drivers/media/pci/ddbridge/ddbridge-main.c
index 26497d6b1395..bde04dc39080 100644
--- a/drivers/media/pci/ddbridge/ddbridge-main.c
+++ b/drivers/media/pci/ddbridge/ddbridge-main.c
@@ -55,34 +55,6 @@ MODULE_PARM_DESC(msi, "Control MSI interrupts: 0-disable (default), 1-enable");
 #endif
 #endif
 
-int ci_bitrate = 70000;
-module_param(ci_bitrate, int, 0444);
-MODULE_PARM_DESC(ci_bitrate, " Bitrate in KHz for output to CI.");
-
-int ts_loop = -1;
-module_param(ts_loop, int, 0444);
-MODULE_PARM_DESC(ts_loop, "TS in/out test loop on port ts_loop");
-
-int xo2_speed = 2;
-module_param(xo2_speed, int, 0444);
-MODULE_PARM_DESC(xo2_speed, "default transfer speed for xo2 based duoflex, 0=55,1=75,2=90,3=104 MBit/s, default=2, use attribute to change for individual cards");
-
-#ifdef __arm__
-int alt_dma = 1;
-#else
-int alt_dma;
-#endif
-module_param(alt_dma, int, 0444);
-MODULE_PARM_DESC(alt_dma, "use alternative DMA buffer handling");
-
-int no_init;
-module_param(no_init, int, 0444);
-MODULE_PARM_DESC(no_init, "do not initialize most devices");
-
-int stv0910_single;
-module_param(stv0910_single, int, 0444);
-MODULE_PARM_DESC(stv0910_single, "use stv0910 cards as single demods");
-
 /****************************************************************************/
 /****************************************************************************/
 /****************************************************************************/

commit 757d78d35aeab1e53a9025128a14d8b63b1a2ba3
Author: Daniel Scheller <d.scheller@gmx.net>
Date:   Sun Oct 15 16:51:51 2017 -0400

    media: ddbridge: fixup checkpatch-strict issues
    
    Fixes several alignment, braces, space-before-cast, camelcase et al issues
    reported by checkpatch --strict, plus a few more checkpatch didn't report.
    
    Three checks are left after this though:
    - one CamelCase in ddbridge-core, related to defines/vars/enums referenced
      from the stv090x demod driver
    - one macro argument reuse in ddbridge-core aswell
    - one unbalanced braces around else in ddbridge-main, which is due to
      #ifdefs related to CONFIG_PCI_MSI, which preferrably should be kept
      as-is for readability.
    
    Signed-off-by: Daniel Scheller <d.scheller@gmx.net>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/pci/ddbridge/ddbridge-main.c b/drivers/media/pci/ddbridge/ddbridge-main.c
index ccac7fe31336..26497d6b1395 100644
--- a/drivers/media/pci/ddbridge/ddbridge-main.c
+++ b/drivers/media/pci/ddbridge/ddbridge-main.c
@@ -107,7 +107,7 @@ static void ddb_irq_exit(struct ddb *dev)
 
 static void ddb_remove(struct pci_dev *pdev)
 {
-	struct ddb *dev = (struct ddb *) pci_get_drvdata(pdev);
+	struct ddb *dev = (struct ddb *)pci_get_drvdata(pdev);
 
 	ddb_device_destroy(dev);
 	ddb_ports_detach(dev);
@@ -132,9 +132,10 @@ static void ddb_irq_msi(struct ddb *dev, int nr)
 		if (stat >= 1) {
 			dev->msi = stat;
 			dev_info(dev->dev, "using %d MSI interrupt(s)\n",
-				dev->msi);
-		} else
+				 dev->msi);
+		} else {
 			dev_info(dev->dev, "MSI not available.\n");
+		}
 	}
 }
 #endif
@@ -160,11 +161,11 @@ static int ddb_irq_init(struct ddb *dev)
 		irq_flag = 0;
 	if (dev->msi == 2) {
 		stat = request_irq(dev->pdev->irq, ddb_irq_handler0,
-				   irq_flag, "ddbridge", (void *) dev);
+				   irq_flag, "ddbridge", (void *)dev);
 		if (stat < 0)
 			return stat;
 		stat = request_irq(dev->pdev->irq + 1, ddb_irq_handler1,
-				   irq_flag, "ddbridge", (void *) dev);
+				   irq_flag, "ddbridge", (void *)dev);
 		if (stat < 0) {
 			free_irq(dev->pdev->irq, dev);
 			return stat;
@@ -173,7 +174,7 @@ static int ddb_irq_init(struct ddb *dev)
 #endif
 	{
 		stat = request_irq(dev->pdev->irq, ddb_irq_handler,
-				   irq_flag, "ddbridge", (void *) dev);
+				   irq_flag, "ddbridge", (void *)dev);
 		if (stat < 0)
 			return stat;
 	}
@@ -188,7 +189,7 @@ static int ddb_irq_init(struct ddb *dev)
 }
 
 static int ddb_probe(struct pci_dev *pdev,
-			       const struct pci_device_id *id)
+		     const struct pci_device_id *id)
 {
 	struct ddb *dev;
 	int stat = 0;
@@ -202,8 +203,8 @@ static int ddb_probe(struct pci_dev *pdev,
 		if (pci_set_dma_mask(pdev, DMA_BIT_MASK(32)))
 			return -ENODEV;
 
-	dev = vzalloc(sizeof(struct ddb));
-	if (dev == NULL)
+	dev = vzalloc(sizeof(*dev));
+	if (!dev)
 		return -ENOMEM;
 
 	mutex_init(&dev->mutex);
@@ -242,7 +243,7 @@ static int ddb_probe(struct pci_dev *pdev,
 	dev->link[0].ids.regmapid = ddbreadl(dev, 4);
 
 	dev_info(&pdev->dev, "HW %08x REGMAP %08x\n",
-		dev->link[0].ids.hwid, dev->link[0].ids.regmapid);
+		 dev->link[0].ids.hwid, dev->link[0].ids.regmapid);
 
 	ddbwritel(dev, 0, DMA_BASE_READ);
 	ddbwritel(dev, 0, DMA_BASE_WRITE);
@@ -317,7 +318,7 @@ static __init int module_init_ddbridge(void)
 	if (ddb_class_create() < 0)
 		return -1;
 	ddb_wq = create_workqueue("ddbridge");
-	if (ddb_wq == NULL)
+	if (!ddb_wq)
 		goto exit1;
 	stat = pci_register_driver(&ddb_pci_driver);
 	if (stat < 0)

commit 8e4eef225c3e5fc70c1656822dd40cb17ee9d2f6
Author: Daniel Scheller <d.scheller@gmx.net>
Date:   Sun Aug 20 06:41:10 2017 -0400

    media: ddbridge: move ddb_unmap(), cleanup modparams
    
    adapter_alloc is only used from within ddbridge-core, so move it there,
    this removes the need for prototyping/referencing the variable. While at
    it, msi isn't needed outside of ddbridge-main, so don't extref that one
    aswell.
    
    Signed-off-by: Daniel Scheller <d.scheller@gmx.net>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/pci/ddbridge/ddbridge-main.c b/drivers/media/pci/ddbridge/ddbridge-main.c
index ec608c496b69..ccac7fe31336 100644
--- a/drivers/media/pci/ddbridge/ddbridge-main.c
+++ b/drivers/media/pci/ddbridge/ddbridge-main.c
@@ -41,16 +41,11 @@
 /****************************************************************************/
 /* module parameters */
 
-int adapter_alloc;
-module_param(adapter_alloc, int, 0444);
-MODULE_PARM_DESC(adapter_alloc,
-		 "0-one adapter per io, 1-one per tab with io, 2-one per tab, 3-one for all");
-
 #ifdef CONFIG_PCI_MSI
 #ifdef CONFIG_DVB_DDBRIDGE_MSIENABLE
-int msi = 1;
+static int msi = 1;
 #else
-int msi;
+static int msi;
 #endif
 module_param(msi, int, 0444);
 #ifdef CONFIG_DVB_DDBRIDGE_MSIENABLE
@@ -88,21 +83,10 @@ int stv0910_single;
 module_param(stv0910_single, int, 0444);
 MODULE_PARM_DESC(stv0910_single, "use stv0910 cards as single demods");
 
-/****************************************************************************/
-
-struct workqueue_struct *ddb_wq;
-
 /****************************************************************************/
 /****************************************************************************/
 /****************************************************************************/
 
-static void ddb_unmap(struct ddb *dev)
-{
-	if (dev->regs)
-		iounmap(dev->regs);
-	vfree(dev);
-}
-
 static void ddb_irq_disable(struct ddb *dev)
 {
 	ddbwritel(dev, 0, INTERRUPT_ENABLE);

commit 66cc3d98ea6daa64735d6e72737d8eac0b6e5182
Author: Daniel Scheller <d.scheller@gmx.net>
Date:   Sun Aug 20 06:41:11 2017 -0400

    media: ddbridge: move device ID table to ddbridge-hw
    
    This further cleans up ddbridge-main from hardware-related data and moves
    the exact card type determination into ddbridge-hw.c:get_ddb_info(), right
    to the hardware maps/structs. Also, const'ify more structs and pointers.
    
    Signed-off-by: Daniel Scheller <d.scheller@gmx.net>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/pci/ddbridge/ddbridge-main.c b/drivers/media/pci/ddbridge/ddbridge-main.c
index 3cb6bb265172..ec608c496b69 100644
--- a/drivers/media/pci/ddbridge/ddbridge-main.c
+++ b/drivers/media/pci/ddbridge/ddbridge-main.c
@@ -231,10 +231,12 @@ static int ddb_probe(struct pci_dev *pdev,
 	dev->link[0].ids.vendor = id->vendor;
 	dev->link[0].ids.device = id->device;
 	dev->link[0].ids.subvendor = id->subvendor;
-	dev->link[0].ids.subdevice = id->subdevice;
+	dev->link[0].ids.subdevice = pdev->subsystem_device;
 
 	dev->link[0].dev = dev;
-	dev->link[0].info = (struct ddb_info *) id->driver_data;
+	dev->link[0].info = get_ddb_info(id->vendor, id->device,
+					 id->subvendor, pdev->subsystem_device);
+
 	dev_info(&pdev->dev, "detected %s\n", dev->link[0].info->name);
 
 	dev->regs_len = pci_resource_len(dev->pdev, 0);
@@ -286,46 +288,11 @@ static int ddb_probe(struct pci_dev *pdev,
 /****************************************************************************/
 /****************************************************************************/
 
-#define DDVID 0xdd01 /* Digital Devices Vendor ID */
-
-#define DDB_DEVICE(_device, _subdevice, _driver_data) { \
-		PCI_DEVICE_SUB(DDVID, _device, DDVID, _subdevice), \
-			.driver_data = (kernel_ulong_t) &_driver_data }
-
-#define DDB_DEVICE_ANY(_device) { \
-		PCI_DEVICE_SUB(DDVID, _device, DDVID, PCI_ANY_ID), \
-			.driver_data = (kernel_ulong_t) &ddb_none }
+#define DDB_DEVICE_ANY(_device) \
+		{ PCI_DEVICE_SUB(DDVID, _device, DDVID, PCI_ANY_ID) }
 
 static const struct pci_device_id ddb_id_table[] = {
-	DDB_DEVICE(0x0002, 0x0001, ddb_octopus),
-	DDB_DEVICE(0x0003, 0x0001, ddb_octopus),
-	DDB_DEVICE(0x0005, 0x0004, ddb_octopusv3),
-	DDB_DEVICE(0x0003, 0x0002, ddb_octopus_le),
-	DDB_DEVICE(0x0003, 0x0003, ddb_octopus_oem),
-	DDB_DEVICE(0x0003, 0x0010, ddb_octopus_mini),
-	DDB_DEVICE(0x0005, 0x0011, ddb_octopus_mini),
-	DDB_DEVICE(0x0003, 0x0020, ddb_v6),
-	DDB_DEVICE(0x0003, 0x0021, ddb_v6_5),
-	DDB_DEVICE(0x0006, 0x0022, ddb_v7),
-	DDB_DEVICE(0x0006, 0x0024, ddb_v7a),
-	DDB_DEVICE(0x0003, 0x0030, ddb_dvbct),
-	DDB_DEVICE(0x0003, 0xdb03, ddb_satixS2v3),
-	DDB_DEVICE(0x0006, 0x0031, ddb_ctv7),
-	DDB_DEVICE(0x0006, 0x0032, ddb_ctv7),
-	DDB_DEVICE(0x0006, 0x0033, ddb_ctv7),
-	DDB_DEVICE(0x0007, 0x0023, ddb_s2_48),
-	DDB_DEVICE(0x0008, 0x0034, ddb_ct2_8),
-	DDB_DEVICE(0x0008, 0x0035, ddb_c2t2_8),
-	DDB_DEVICE(0x0008, 0x0036, ddb_isdbt_8),
-	DDB_DEVICE(0x0008, 0x0037, ddb_c2t2i_v0_8),
-	DDB_DEVICE(0x0008, 0x0038, ddb_c2t2i_8),
-	DDB_DEVICE(0x0006, 0x0039, ddb_ctv7),
-	DDB_DEVICE(0x0011, 0x0040, ddb_ci),
-	DDB_DEVICE(0x0011, 0x0041, ddb_cis),
-	DDB_DEVICE(0x0012, 0x0042, ddb_ci),
-	DDB_DEVICE(0x0013, 0x0043, ddb_ci_s2_pro),
-	DDB_DEVICE(0x0013, 0x0044, ddb_ci_s2_pro_a),
-	/* in case sub-ids got deleted in flash */
+	DDB_DEVICE_ANY(0x0002),
 	DDB_DEVICE_ANY(0x0003),
 	DDB_DEVICE_ANY(0x0005),
 	DDB_DEVICE_ANY(0x0006),

commit bb4cec96e5d7f0ff7f397f4518399be77a2f12db
Author: Daniel Scheller <d.scheller@gmx.net>
Date:   Sun Jul 9 15:42:44 2017 -0400

    media: ddbridge: support MaxLinear MXL5xx based cards (MaxS4/8)
    
    This enables MaxS4/S8 and Octopus Max card support in ddbridge by adding
    glue code into ddbridge-core, having another PCI ID, and have the LNB IC
    control code (and all other MaxS4/8 related code) in ddbridge-maxs8.c
    (rather than another ~400 LoC in ddbridge-core.c like it's done in the
    original vendor driver package).
    
    Signed-off-by: Daniel Scheller <d.scheller@gmx.net>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/pci/ddbridge/ddbridge-main.c b/drivers/media/pci/ddbridge/ddbridge-main.c
index 181d5f17fe91..3cb6bb265172 100644
--- a/drivers/media/pci/ddbridge/ddbridge-main.c
+++ b/drivers/media/pci/ddbridge/ddbridge-main.c
@@ -313,6 +313,7 @@ static const struct pci_device_id ddb_id_table[] = {
 	DDB_DEVICE(0x0006, 0x0031, ddb_ctv7),
 	DDB_DEVICE(0x0006, 0x0032, ddb_ctv7),
 	DDB_DEVICE(0x0006, 0x0033, ddb_ctv7),
+	DDB_DEVICE(0x0007, 0x0023, ddb_s2_48),
 	DDB_DEVICE(0x0008, 0x0034, ddb_ct2_8),
 	DDB_DEVICE(0x0008, 0x0035, ddb_c2t2_8),
 	DDB_DEVICE(0x0008, 0x0036, ddb_isdbt_8),

commit adaf4df70521e656c38ace740f1d98096825a430
Author: Daniel Scheller <d.scheller@gmx.net>
Date:   Sat Aug 12 07:56:01 2017 -0400

    media: ddbridge: Kconfig option to control the MSI modparam default
    
    It is known that MSI interrupts - while working quite well so far - can
    still cause issues on some hardware platforms (causing I2C timeouts due
    to unhandled interrupts). The msi variable/option is set to 1 by default.
    So, add a Kconfig option prefixed with "EXPERIMENTAL" that will control
    the default value of that modparam, defaulting to off for a better
    user experience and (guaranteed) stable operation "per default".
    
    Cc: Ralph Metzler <rjkm@metzlerbros.de>
    Signed-off-by: Daniel Scheller <d.scheller@gmx.net>
    Tested-by: Richard Scobie <r.scobie@clear.net.nz>
    Tested-by: Jasmin Jessich <jasmin@anw.at>
    Tested-by: Dietmar Spingler <d_spingler@freenet.de>
    Tested-by: Manfred Knick <Manfred.Knick@t-online.de>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/pci/ddbridge/ddbridge-main.c b/drivers/media/pci/ddbridge/ddbridge-main.c
index 420335f4b7bf..181d5f17fe91 100644
--- a/drivers/media/pci/ddbridge/ddbridge-main.c
+++ b/drivers/media/pci/ddbridge/ddbridge-main.c
@@ -47,10 +47,17 @@ MODULE_PARM_DESC(adapter_alloc,
 		 "0-one adapter per io, 1-one per tab with io, 2-one per tab, 3-one for all");
 
 #ifdef CONFIG_PCI_MSI
+#ifdef CONFIG_DVB_DDBRIDGE_MSIENABLE
 int msi = 1;
+#else
+int msi;
+#endif
 module_param(msi, int, 0444);
-MODULE_PARM_DESC(msi,
-		 " Control MSI interrupts: 0-disable, 1-enable (default)");
+#ifdef CONFIG_DVB_DDBRIDGE_MSIENABLE
+MODULE_PARM_DESC(msi, "Control MSI interrupts: 0-disable, 1-enable (default)");
+#else
+MODULE_PARM_DESC(msi, "Control MSI interrupts: 0-disable (default), 1-enable");
+#endif
 #endif
 
 int ci_bitrate = 70000;

commit 69716934c7c5fdaf057dcbdb75da75d067f10e60
Author: Daniel Scheller <d.scheller@gmx.net>
Date:   Sat Aug 12 07:55:54 2017 -0400

    media: ddbridge: split off hardware definitions and mappings
    
    Further cleanup of ddbridge-core and ddbridge-main, and moves all such
    hw definitions into one single place, making things easier to maintain.
    
    Signed-off-by: Daniel Scheller <d.scheller@gmx.net>
    Tested-by: Richard Scobie <r.scobie@clear.net.nz>
    Tested-by: Jasmin Jessich <jasmin@anw.at>
    Tested-by: Dietmar Spingler <d_spingler@freenet.de>
    Tested-by: Manfred Knick <Manfred.Knick@t-online.de>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/pci/ddbridge/ddbridge-main.c b/drivers/media/pci/ddbridge/ddbridge-main.c
index d06543bbc393..420335f4b7bf 100644
--- a/drivers/media/pci/ddbridge/ddbridge-main.c
+++ b/drivers/media/pci/ddbridge/ddbridge-main.c
@@ -35,6 +35,7 @@
 #include "ddbridge.h"
 #include "ddbridge-i2c.h"
 #include "ddbridge-regs.h"
+#include "ddbridge-hw.h"
 #include "ddbridge-io.h"
 
 /****************************************************************************/
@@ -278,222 +279,6 @@ static int ddb_probe(struct pci_dev *pdev,
 /****************************************************************************/
 /****************************************************************************/
 
-static const struct ddb_info ddb_none = {
-	.type     = DDB_NONE,
-	.name     = "unknown Digital Devices PCIe card, install newer driver",
-	.regmap   = &octopus_map,
-};
-
-static const struct ddb_info ddb_octopus = {
-	.type     = DDB_OCTOPUS,
-	.name     = "Digital Devices Octopus DVB adapter",
-	.regmap   = &octopus_map,
-	.port_num = 4,
-	.i2c_mask = 0x0f,
-};
-
-static const struct ddb_info ddb_octopusv3 = {
-	.type     = DDB_OCTOPUS,
-	.name     = "Digital Devices Octopus V3 DVB adapter",
-	.regmap   = &octopus_map,
-	.port_num = 4,
-	.i2c_mask = 0x0f,
-};
-
-static const struct ddb_info ddb_octopus_le = {
-	.type     = DDB_OCTOPUS,
-	.name     = "Digital Devices Octopus LE DVB adapter",
-	.regmap   = &octopus_map,
-	.port_num = 2,
-	.i2c_mask = 0x03,
-};
-
-static const struct ddb_info ddb_octopus_oem = {
-	.type     = DDB_OCTOPUS,
-	.name     = "Digital Devices Octopus OEM",
-	.regmap   = &octopus_map,
-	.port_num = 4,
-	.i2c_mask = 0x0f,
-	.led_num  = 1,
-	.fan_num  = 1,
-	.temp_num = 1,
-	.temp_bus = 0,
-};
-
-static const struct ddb_info ddb_octopus_mini = {
-	.type     = DDB_OCTOPUS,
-	.name     = "Digital Devices Octopus Mini",
-	.regmap   = &octopus_map,
-	.port_num = 4,
-	.i2c_mask = 0x0f,
-};
-
-static const struct ddb_info ddb_v6 = {
-	.type     = DDB_OCTOPUS,
-	.name     = "Digital Devices Cine S2 V6 DVB adapter",
-	.regmap   = &octopus_map,
-	.port_num = 3,
-	.i2c_mask = 0x07,
-};
-
-static const struct ddb_info ddb_v6_5 = {
-	.type     = DDB_OCTOPUS,
-	.name     = "Digital Devices Cine S2 V6.5 DVB adapter",
-	.regmap   = &octopus_map,
-	.port_num = 4,
-	.i2c_mask = 0x0f,
-};
-
-static const struct ddb_info ddb_v7 = {
-	.type     = DDB_OCTOPUS,
-	.name     = "Digital Devices Cine S2 V7 DVB adapter",
-	.regmap   = &octopus_map,
-	.port_num = 4,
-	.i2c_mask = 0x0f,
-	.board_control   = 2,
-	.board_control_2 = 4,
-	.ts_quirks = TS_QUIRK_REVERSED,
-};
-
-static const struct ddb_info ddb_v7a = {
-	.type     = DDB_OCTOPUS,
-	.name     = "Digital Devices Cine S2 V7 Advanced DVB adapter",
-	.regmap   = &octopus_map,
-	.port_num = 4,
-	.i2c_mask = 0x0f,
-	.board_control   = 2,
-	.board_control_2 = 4,
-	.ts_quirks = TS_QUIRK_REVERSED,
-};
-
-static const struct ddb_info ddb_ctv7 = {
-	.type     = DDB_OCTOPUS,
-	.name     = "Digital Devices Cine CT V7 DVB adapter",
-	.regmap   = &octopus_map,
-	.port_num = 4,
-	.i2c_mask = 0x0f,
-	.board_control   = 3,
-	.board_control_2 = 4,
-};
-
-static const struct ddb_info ddb_satixS2v3 = {
-	.type     = DDB_OCTOPUS,
-	.name     = "Mystique SaTiX-S2 V3 DVB adapter",
-	.regmap   = &octopus_map,
-	.port_num = 3,
-	.i2c_mask = 0x07,
-};
-
-static const struct ddb_info ddb_ci = {
-	.type     = DDB_OCTOPUS_CI,
-	.name     = "Digital Devices Octopus CI",
-	.regmap   = &octopus_map,
-	.port_num = 4,
-	.i2c_mask = 0x03,
-};
-
-static const struct ddb_info ddb_cis = {
-	.type     = DDB_OCTOPUS_CI,
-	.name     = "Digital Devices Octopus CI single",
-	.regmap   = &octopus_map,
-	.port_num = 3,
-	.i2c_mask = 0x03,
-};
-
-static const struct ddb_info ddb_ci_s2_pro = {
-	.type     = DDB_OCTOPUS_CI,
-	.name     = "Digital Devices Octopus CI S2 Pro",
-	.regmap   = &octopus_map,
-	.port_num = 4,
-	.i2c_mask = 0x01,
-	.board_control   = 2,
-	.board_control_2 = 4,
-};
-
-static const struct ddb_info ddb_ci_s2_pro_a = {
-	.type     = DDB_OCTOPUS_CI,
-	.name     = "Digital Devices Octopus CI S2 Pro Advanced",
-	.regmap   = &octopus_map,
-	.port_num = 4,
-	.i2c_mask = 0x01,
-	.board_control   = 2,
-	.board_control_2 = 4,
-};
-
-static const struct ddb_info ddb_dvbct = {
-	.type     = DDB_OCTOPUS,
-	.name     = "Digital Devices DVBCT V6.1 DVB adapter",
-	.regmap   = &octopus_map,
-	.port_num = 3,
-	.i2c_mask = 0x07,
-};
-
-/****************************************************************************/
-
-static struct ddb_info ddb_ct2_8 = {
-	.type     = DDB_OCTOPUS_MAX_CT,
-	.name     = "Digital Devices MAX A8 CT2",
-	.regmap   = &octopus_map,
-	.port_num = 4,
-	.i2c_mask = 0x0f,
-	.board_control   = 0x0ff,
-	.board_control_2 = 0xf00,
-	.ts_quirks = TS_QUIRK_SERIAL,
-	.tempmon_irq = 24,
-};
-
-static struct ddb_info ddb_c2t2_8 = {
-	.type     = DDB_OCTOPUS_MAX_CT,
-	.name     = "Digital Devices MAX A8 C2T2",
-	.regmap   = &octopus_map,
-	.port_num = 4,
-	.i2c_mask = 0x0f,
-	.board_control   = 0x0ff,
-	.board_control_2 = 0xf00,
-	.ts_quirks = TS_QUIRK_SERIAL,
-	.tempmon_irq = 24,
-};
-
-static struct ddb_info ddb_isdbt_8 = {
-	.type     = DDB_OCTOPUS_MAX_CT,
-	.name     = "Digital Devices MAX A8 ISDBT",
-	.regmap   = &octopus_map,
-	.port_num = 4,
-	.i2c_mask = 0x0f,
-	.board_control   = 0x0ff,
-	.board_control_2 = 0xf00,
-	.ts_quirks = TS_QUIRK_SERIAL,
-	.tempmon_irq = 24,
-};
-
-static struct ddb_info ddb_c2t2i_v0_8 = {
-	.type     = DDB_OCTOPUS_MAX_CT,
-	.name     = "Digital Devices MAX A8 C2T2I V0",
-	.regmap   = &octopus_map,
-	.port_num = 4,
-	.i2c_mask = 0x0f,
-	.board_control   = 0x0ff,
-	.board_control_2 = 0xf00,
-	.ts_quirks = TS_QUIRK_SERIAL | TS_QUIRK_ALT_OSC,
-	.tempmon_irq = 24,
-};
-
-static struct ddb_info ddb_c2t2i_8 = {
-	.type     = DDB_OCTOPUS_MAX_CT,
-	.name     = "Digital Devices MAX A8 C2T2I",
-	.regmap   = &octopus_map,
-	.port_num = 4,
-	.i2c_mask = 0x0f,
-	.board_control   = 0x0ff,
-	.board_control_2 = 0xf00,
-	.ts_quirks = TS_QUIRK_SERIAL,
-	.tempmon_irq = 24,
-};
-
-/****************************************************************************/
-/****************************************************************************/
-/****************************************************************************/
-
 #define DDVID 0xdd01 /* Digital Devices Vendor ID */
 
 #define DDB_DEVICE(_device, _subdevice, _driver_data) { \

commit 14e27a106566aeb74b09117dbc073f210f27ffde
Author: Daniel Scheller <d.scheller@gmx.net>
Date:   Sat Aug 12 07:55:53 2017 -0400

    media: ddbridge: split I/O related functions off from ddbridge.h
    
    While it seems valid that headers can carry simple oneline static inline
    annotated functions, move them into their own header file to have the
    overall code more readable. Also, keep them as header (and don't put in
    a separate object) and static inline to help the compiler avoid
    generating function calls.
    
    (Thanks to Jasmin J. <jasmin@anw.at> for valuable input on this!)
    
    Cc: Jasmin J. <jasmin@anw.at>
    Signed-off-by: Daniel Scheller <d.scheller@gmx.net>
    Tested-by: Richard Scobie <r.scobie@clear.net.nz>
    Tested-by: Jasmin Jessich <jasmin@anw.at>
    Tested-by: Dietmar Spingler <d_spingler@freenet.de>
    Tested-by: Manfred Knick <Manfred.Knick@t-online.de>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/pci/ddbridge/ddbridge-main.c b/drivers/media/pci/ddbridge/ddbridge-main.c
index 73b041118bbf..d06543bbc393 100644
--- a/drivers/media/pci/ddbridge/ddbridge-main.c
+++ b/drivers/media/pci/ddbridge/ddbridge-main.c
@@ -35,6 +35,7 @@
 #include "ddbridge.h"
 #include "ddbridge-i2c.h"
 #include "ddbridge-regs.h"
+#include "ddbridge-io.h"
 
 /****************************************************************************/
 /* module parameters */

commit 22e743898dcd693cf587593781699db2fa888e23
Author: Daniel Scheller <d.scheller@gmx.net>
Date:   Sat Aug 12 07:55:52 2017 -0400

    media: ddbridge: bump ddbridge code to version 0.9.29
    
    This huge patch bumps the ddbridge driver to version 0.9.29. Compared to
    the vendor driver package, DD OctoNET including GTL link support, and all
    DVB-C Modulator card support has been removed since this requires large
    changes to the underlying DVB core API, which should eventually be done
    separately, and, after that, the functionality/device support can be added
    back rather easy.
    
    While the diff is rather large, the bump is mostly a big refactor of all
    data structures. Yet, the MSI support (message signaled interrupts) is
    greatly improved, also all currently available CI single/duo bridge cards
    are fully supported.
    
    More changes compared to the upstream driver:
     - the DDB_USE_WORKER flag/define was removed, kernel worker functionality
       will be used.
     - coding style is properly fixed (zero complaints from checkpatch)
     - all (not much though) CamelCase has been fixed to kernel_case
     - (private) IOCTLs temporarily removed (which are mainly used to provide
       rarely-used FPGA update functionality)
    
    Great care has been taken to keep all previous changes and fixes (e.g.
    kernel logging via dev_*(), pointer annotations and such) intact.
    
    Permission to reuse and mainline the driver code was formally granted by
    Ralph Metzler <rjkm@metzlerbros.de>.
    
    Signed-off-by: Daniel Scheller <d.scheller@gmx.net>
    Tested-by: Richard Scobie <r.scobie@clear.net.nz>
    Tested-by: Jasmin Jessich <jasmin@anw.at>
    Tested-by: Dietmar Spingler <d_spingler@freenet.de>
    Tested-by: Manfred Knick <Manfred.Knick@t-online.de>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/pci/ddbridge/ddbridge-main.c b/drivers/media/pci/ddbridge/ddbridge-main.c
index 41c0adc176b1..73b041118bbf 100644
--- a/drivers/media/pci/ddbridge/ddbridge-main.c
+++ b/drivers/media/pci/ddbridge/ddbridge-main.c
@@ -1,20 +1,19 @@
 /*
  * ddbridge.c: Digital Devices PCIe bridge driver
  *
- * Copyright (C) 2010-2011 Digital Devices GmbH
+ * Copyright (C) 2010-2017 Digital Devices GmbH
+ *                         Ralph Metzler <rjkm@metzlerbros.de>
+ *                         Marcus Metzler <mocm@metzlerbros.de>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
  * version 2 only, as published by the Free Software Foundation.
  *
- *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
- * To obtain the license, point your browser to
- * http://www.gnu.org/copyleft/gpl.html
  */
 
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
@@ -37,15 +36,56 @@
 #include "ddbridge-i2c.h"
 #include "ddbridge-regs.h"
 
+/****************************************************************************/
+/* module parameters */
+
+int adapter_alloc;
+module_param(adapter_alloc, int, 0444);
+MODULE_PARM_DESC(adapter_alloc,
+		 "0-one adapter per io, 1-one per tab with io, 2-one per tab, 3-one for all");
+
+#ifdef CONFIG_PCI_MSI
+int msi = 1;
+module_param(msi, int, 0444);
+MODULE_PARM_DESC(msi,
+		 " Control MSI interrupts: 0-disable, 1-enable (default)");
+#endif
+
+int ci_bitrate = 70000;
+module_param(ci_bitrate, int, 0444);
+MODULE_PARM_DESC(ci_bitrate, " Bitrate in KHz for output to CI.");
+
+int ts_loop = -1;
+module_param(ts_loop, int, 0444);
+MODULE_PARM_DESC(ts_loop, "TS in/out test loop on port ts_loop");
+
 int xo2_speed = 2;
 module_param(xo2_speed, int, 0444);
 MODULE_PARM_DESC(xo2_speed, "default transfer speed for xo2 based duoflex, 0=55,1=75,2=90,3=104 MBit/s, default=2, use attribute to change for individual cards");
 
+#ifdef __arm__
+int alt_dma = 1;
+#else
+int alt_dma;
+#endif
+module_param(alt_dma, int, 0444);
+MODULE_PARM_DESC(alt_dma, "use alternative DMA buffer handling");
+
+int no_init;
+module_param(no_init, int, 0444);
+MODULE_PARM_DESC(no_init, "do not initialize most devices");
+
 int stv0910_single;
 module_param(stv0910_single, int, 0444);
 MODULE_PARM_DESC(stv0910_single, "use stv0910 cards as single demods");
 
-/******************************************************************************/
+/****************************************************************************/
+
+struct workqueue_struct *ddb_wq;
+
+/****************************************************************************/
+/****************************************************************************/
+/****************************************************************************/
 
 static void ddb_unmap(struct ddb *dev)
 {
@@ -54,170 +94,261 @@ static void ddb_unmap(struct ddb *dev)
 	vfree(dev);
 }
 
-
-static void ddb_remove(struct pci_dev *pdev)
+static void ddb_irq_disable(struct ddb *dev)
 {
-	struct ddb *dev = pci_get_drvdata(pdev);
-
-	ddb_ports_detach(dev);
-	ddb_i2c_release(dev);
+	ddbwritel(dev, 0, INTERRUPT_ENABLE);
+	ddbwritel(dev, 0, MSI1_ENABLE);
+}
 
-	ddbwritel(0, INTERRUPT_ENABLE);
+static void ddb_irq_exit(struct ddb *dev)
+{
+	ddb_irq_disable(dev);
+	if (dev->msi == 2)
+		free_irq(dev->pdev->irq + 1, dev);
 	free_irq(dev->pdev->irq, dev);
 #ifdef CONFIG_PCI_MSI
 	if (dev->msi)
 		pci_disable_msi(dev->pdev);
 #endif
+}
+
+static void ddb_remove(struct pci_dev *pdev)
+{
+	struct ddb *dev = (struct ddb *) pci_get_drvdata(pdev);
+
+	ddb_device_destroy(dev);
+	ddb_ports_detach(dev);
+	ddb_i2c_release(dev);
+
+	ddb_irq_exit(dev);
 	ddb_ports_release(dev);
 	ddb_buffers_free(dev);
-	ddb_device_destroy(dev);
 
 	ddb_unmap(dev);
 	pci_set_drvdata(pdev, NULL);
 	pci_disable_device(pdev);
 }
 
+#ifdef CONFIG_PCI_MSI
+static void ddb_irq_msi(struct ddb *dev, int nr)
+{
+	int stat;
+
+	if (msi && pci_msi_enabled()) {
+		stat = pci_alloc_irq_vectors(dev->pdev, 1, nr, PCI_IRQ_MSI);
+		if (stat >= 1) {
+			dev->msi = stat;
+			dev_info(dev->dev, "using %d MSI interrupt(s)\n",
+				dev->msi);
+		} else
+			dev_info(dev->dev, "MSI not available.\n");
+	}
+}
+#endif
 
-static int ddb_probe(struct pci_dev *pdev, const struct pci_device_id *id)
+static int ddb_irq_init(struct ddb *dev)
+{
+	int stat;
+	int irq_flag = IRQF_SHARED;
+
+	ddbwritel(dev, 0x00000000, INTERRUPT_ENABLE);
+	ddbwritel(dev, 0x00000000, MSI1_ENABLE);
+	ddbwritel(dev, 0x00000000, MSI2_ENABLE);
+	ddbwritel(dev, 0x00000000, MSI3_ENABLE);
+	ddbwritel(dev, 0x00000000, MSI4_ENABLE);
+	ddbwritel(dev, 0x00000000, MSI5_ENABLE);
+	ddbwritel(dev, 0x00000000, MSI6_ENABLE);
+	ddbwritel(dev, 0x00000000, MSI7_ENABLE);
+
+#ifdef CONFIG_PCI_MSI
+	ddb_irq_msi(dev, 2);
+
+	if (dev->msi)
+		irq_flag = 0;
+	if (dev->msi == 2) {
+		stat = request_irq(dev->pdev->irq, ddb_irq_handler0,
+				   irq_flag, "ddbridge", (void *) dev);
+		if (stat < 0)
+			return stat;
+		stat = request_irq(dev->pdev->irq + 1, ddb_irq_handler1,
+				   irq_flag, "ddbridge", (void *) dev);
+		if (stat < 0) {
+			free_irq(dev->pdev->irq, dev);
+			return stat;
+		}
+	} else
+#endif
+	{
+		stat = request_irq(dev->pdev->irq, ddb_irq_handler,
+				   irq_flag, "ddbridge", (void *) dev);
+		if (stat < 0)
+			return stat;
+	}
+	if (dev->msi == 2) {
+		ddbwritel(dev, 0x0fffff00, INTERRUPT_ENABLE);
+		ddbwritel(dev, 0x0000000f, MSI1_ENABLE);
+	} else {
+		ddbwritel(dev, 0x0fffff0f, INTERRUPT_ENABLE);
+		ddbwritel(dev, 0x00000000, MSI1_ENABLE);
+	}
+	return stat;
+}
+
+static int ddb_probe(struct pci_dev *pdev,
+			       const struct pci_device_id *id)
 {
 	struct ddb *dev;
 	int stat = 0;
-	int irq_flag = IRQF_SHARED;
 
 	if (pci_enable_device(pdev) < 0)
 		return -ENODEV;
 
+	pci_set_master(pdev);
+
+	if (pci_set_dma_mask(pdev, DMA_BIT_MASK(64)))
+		if (pci_set_dma_mask(pdev, DMA_BIT_MASK(32)))
+			return -ENODEV;
+
 	dev = vzalloc(sizeof(struct ddb));
 	if (dev == NULL)
 		return -ENOMEM;
 
+	mutex_init(&dev->mutex);
+	dev->has_dma = 1;
 	dev->pdev = pdev;
+	dev->dev = &pdev->dev;
 	pci_set_drvdata(pdev, dev);
-	dev->info = (struct ddb_info *) id->driver_data;
-	dev_info(&pdev->dev, "Detected %s\n", dev->info->name);
 
+	dev->link[0].ids.vendor = id->vendor;
+	dev->link[0].ids.device = id->device;
+	dev->link[0].ids.subvendor = id->subvendor;
+	dev->link[0].ids.subdevice = id->subdevice;
+
+	dev->link[0].dev = dev;
+	dev->link[0].info = (struct ddb_info *) id->driver_data;
+	dev_info(&pdev->dev, "detected %s\n", dev->link[0].info->name);
+
+	dev->regs_len = pci_resource_len(dev->pdev, 0);
 	dev->regs = ioremap(pci_resource_start(dev->pdev, 0),
 			    pci_resource_len(dev->pdev, 0));
+
 	if (!dev->regs) {
+		dev_err(&pdev->dev, "not enough memory for register map\n");
 		stat = -ENOMEM;
 		goto fail;
 	}
-	dev_info(&pdev->dev, "HW %08x FW %08x\n", ddbreadl(0), ddbreadl(4));
-
-#ifdef CONFIG_PCI_MSI
-	if (pci_msi_enabled())
-		stat = pci_enable_msi(dev->pdev);
-	if (stat) {
-		dev_info(&pdev->dev, "MSI not available.\n");
-	} else {
-		irq_flag = 0;
-		dev->msi = 1;
+	if (ddbreadl(dev, 0) == 0xffffffff) {
+		dev_err(&pdev->dev, "cannot read registers\n");
+		stat = -ENODEV;
+		goto fail;
 	}
-#endif
-	stat = request_irq(dev->pdev->irq, irq_handler,
-			   irq_flag, "DDBridge", (void *) dev);
+
+	dev->link[0].ids.hwid = ddbreadl(dev, 0);
+	dev->link[0].ids.regmapid = ddbreadl(dev, 4);
+
+	dev_info(&pdev->dev, "HW %08x REGMAP %08x\n",
+		dev->link[0].ids.hwid, dev->link[0].ids.regmapid);
+
+	ddbwritel(dev, 0, DMA_BASE_READ);
+	ddbwritel(dev, 0, DMA_BASE_WRITE);
+
+	stat = ddb_irq_init(dev);
 	if (stat < 0)
-		goto fail1;
-	ddbwritel(0, DMA_BASE_WRITE);
-	ddbwritel(0, DMA_BASE_READ);
-	ddbwritel(0xffffffff, INTERRUPT_ACK);
-	ddbwritel(0xfff0f, INTERRUPT_ENABLE);
-	ddbwritel(0, MSI1_ENABLE);
-
-	/* board control */
-	if (dev->info->board_control) {
-		ddbwritel(0, DDB_LINK_TAG(0) | BOARD_CONTROL);
-		msleep(100);
-		ddbwritel(dev->info->board_control_2,
-			DDB_LINK_TAG(0) | BOARD_CONTROL);
-		usleep_range(2000, 3000);
-		ddbwritel(dev->info->board_control_2
-			| dev->info->board_control,
-			DDB_LINK_TAG(0) | BOARD_CONTROL);
-		usleep_range(2000, 3000);
-	}
+		goto fail0;
 
-	if (ddb_i2c_init(dev) < 0)
-		goto fail1;
-	ddb_ports_init(dev);
-	if (ddb_buffers_alloc(dev) < 0) {
-		dev_err(&pdev->dev, "Could not allocate buffer memory\n");
-		goto fail2;
-	}
-	if (ddb_ports_attach(dev) < 0)
-		goto fail3;
-	ddb_device_create(dev);
-	return 0;
+	if (ddb_init(dev) == 0)
+		return 0;
 
-fail3:
-	ddb_ports_detach(dev);
-	dev_err(&pdev->dev, "fail3\n");
-	ddb_ports_release(dev);
-fail2:
-	dev_err(&pdev->dev, "fail2\n");
-	ddb_buffers_free(dev);
-fail1:
-	dev_err(&pdev->dev, "fail1\n");
+	ddb_irq_exit(dev);
+fail0:
+	dev_err(&pdev->dev, "fail0\n");
 	if (dev->msi)
 		pci_disable_msi(dev->pdev);
-	if (stat == 0)
-		free_irq(dev->pdev->irq, dev);
 fail:
 	dev_err(&pdev->dev, "fail\n");
+
 	ddb_unmap(dev);
 	pci_set_drvdata(pdev, NULL);
 	pci_disable_device(pdev);
 	return -1;
 }
 
-/******************************************************************************/
-/******************************************************************************/
-/******************************************************************************/
+/****************************************************************************/
+/****************************************************************************/
+/****************************************************************************/
 
 static const struct ddb_info ddb_none = {
 	.type     = DDB_NONE,
-	.name     = "Digital Devices PCIe bridge",
+	.name     = "unknown Digital Devices PCIe card, install newer driver",
+	.regmap   = &octopus_map,
 };
 
 static const struct ddb_info ddb_octopus = {
 	.type     = DDB_OCTOPUS,
 	.name     = "Digital Devices Octopus DVB adapter",
+	.regmap   = &octopus_map,
+	.port_num = 4,
+	.i2c_mask = 0x0f,
+};
+
+static const struct ddb_info ddb_octopusv3 = {
+	.type     = DDB_OCTOPUS,
+	.name     = "Digital Devices Octopus V3 DVB adapter",
+	.regmap   = &octopus_map,
 	.port_num = 4,
+	.i2c_mask = 0x0f,
 };
 
 static const struct ddb_info ddb_octopus_le = {
 	.type     = DDB_OCTOPUS,
 	.name     = "Digital Devices Octopus LE DVB adapter",
+	.regmap   = &octopus_map,
 	.port_num = 2,
+	.i2c_mask = 0x03,
 };
 
 static const struct ddb_info ddb_octopus_oem = {
 	.type     = DDB_OCTOPUS,
 	.name     = "Digital Devices Octopus OEM",
+	.regmap   = &octopus_map,
 	.port_num = 4,
+	.i2c_mask = 0x0f,
+	.led_num  = 1,
+	.fan_num  = 1,
+	.temp_num = 1,
+	.temp_bus = 0,
 };
 
 static const struct ddb_info ddb_octopus_mini = {
 	.type     = DDB_OCTOPUS,
 	.name     = "Digital Devices Octopus Mini",
+	.regmap   = &octopus_map,
 	.port_num = 4,
+	.i2c_mask = 0x0f,
 };
 
 static const struct ddb_info ddb_v6 = {
 	.type     = DDB_OCTOPUS,
 	.name     = "Digital Devices Cine S2 V6 DVB adapter",
+	.regmap   = &octopus_map,
 	.port_num = 3,
+	.i2c_mask = 0x07,
 };
+
 static const struct ddb_info ddb_v6_5 = {
 	.type     = DDB_OCTOPUS,
 	.name     = "Digital Devices Cine S2 V6.5 DVB adapter",
+	.regmap   = &octopus_map,
 	.port_num = 4,
+	.i2c_mask = 0x0f,
 };
 
 static const struct ddb_info ddb_v7 = {
 	.type     = DDB_OCTOPUS,
 	.name     = "Digital Devices Cine S2 V7 DVB adapter",
+	.regmap   = &octopus_map,
 	.port_num = 4,
+	.i2c_mask = 0x0f,
 	.board_control   = 2,
 	.board_control_2 = 4,
 	.ts_quirks = TS_QUIRK_REVERSED,
@@ -226,22 +357,20 @@ static const struct ddb_info ddb_v7 = {
 static const struct ddb_info ddb_v7a = {
 	.type     = DDB_OCTOPUS,
 	.name     = "Digital Devices Cine S2 V7 Advanced DVB adapter",
+	.regmap   = &octopus_map,
 	.port_num = 4,
+	.i2c_mask = 0x0f,
 	.board_control   = 2,
 	.board_control_2 = 4,
 	.ts_quirks = TS_QUIRK_REVERSED,
 };
 
-static const struct ddb_info ddb_dvbct = {
-	.type     = DDB_OCTOPUS,
-	.name     = "Digital Devices DVBCT V6.1 DVB adapter",
-	.port_num = 3,
-};
-
 static const struct ddb_info ddb_ctv7 = {
 	.type     = DDB_OCTOPUS,
 	.name     = "Digital Devices Cine CT V7 DVB adapter",
+	.regmap   = &octopus_map,
 	.port_num = 4,
+	.i2c_mask = 0x0f,
 	.board_control   = 3,
 	.board_control_2 = 4,
 };
@@ -249,134 +378,217 @@ static const struct ddb_info ddb_ctv7 = {
 static const struct ddb_info ddb_satixS2v3 = {
 	.type     = DDB_OCTOPUS,
 	.name     = "Mystique SaTiX-S2 V3 DVB adapter",
+	.regmap   = &octopus_map,
 	.port_num = 3,
+	.i2c_mask = 0x07,
 };
 
-static const struct ddb_info ddb_octopusv3 = {
-	.type     = DDB_OCTOPUS,
-	.name     = "Digital Devices Octopus V3 DVB adapter",
+static const struct ddb_info ddb_ci = {
+	.type     = DDB_OCTOPUS_CI,
+	.name     = "Digital Devices Octopus CI",
+	.regmap   = &octopus_map,
 	.port_num = 4,
+	.i2c_mask = 0x03,
+};
+
+static const struct ddb_info ddb_cis = {
+	.type     = DDB_OCTOPUS_CI,
+	.name     = "Digital Devices Octopus CI single",
+	.regmap   = &octopus_map,
+	.port_num = 3,
+	.i2c_mask = 0x03,
 };
 
-/*** MaxA8 adapters ***********************************************************/
+static const struct ddb_info ddb_ci_s2_pro = {
+	.type     = DDB_OCTOPUS_CI,
+	.name     = "Digital Devices Octopus CI S2 Pro",
+	.regmap   = &octopus_map,
+	.port_num = 4,
+	.i2c_mask = 0x01,
+	.board_control   = 2,
+	.board_control_2 = 4,
+};
+
+static const struct ddb_info ddb_ci_s2_pro_a = {
+	.type     = DDB_OCTOPUS_CI,
+	.name     = "Digital Devices Octopus CI S2 Pro Advanced",
+	.regmap   = &octopus_map,
+	.port_num = 4,
+	.i2c_mask = 0x01,
+	.board_control   = 2,
+	.board_control_2 = 4,
+};
+
+static const struct ddb_info ddb_dvbct = {
+	.type     = DDB_OCTOPUS,
+	.name     = "Digital Devices DVBCT V6.1 DVB adapter",
+	.regmap   = &octopus_map,
+	.port_num = 3,
+	.i2c_mask = 0x07,
+};
+
+/****************************************************************************/
 
 static struct ddb_info ddb_ct2_8 = {
 	.type     = DDB_OCTOPUS_MAX_CT,
 	.name     = "Digital Devices MAX A8 CT2",
+	.regmap   = &octopus_map,
 	.port_num = 4,
+	.i2c_mask = 0x0f,
 	.board_control   = 0x0ff,
 	.board_control_2 = 0xf00,
 	.ts_quirks = TS_QUIRK_SERIAL,
+	.tempmon_irq = 24,
 };
 
 static struct ddb_info ddb_c2t2_8 = {
 	.type     = DDB_OCTOPUS_MAX_CT,
 	.name     = "Digital Devices MAX A8 C2T2",
+	.regmap   = &octopus_map,
 	.port_num = 4,
+	.i2c_mask = 0x0f,
 	.board_control   = 0x0ff,
 	.board_control_2 = 0xf00,
 	.ts_quirks = TS_QUIRK_SERIAL,
+	.tempmon_irq = 24,
 };
 
 static struct ddb_info ddb_isdbt_8 = {
 	.type     = DDB_OCTOPUS_MAX_CT,
 	.name     = "Digital Devices MAX A8 ISDBT",
+	.regmap   = &octopus_map,
 	.port_num = 4,
+	.i2c_mask = 0x0f,
 	.board_control   = 0x0ff,
 	.board_control_2 = 0xf00,
 	.ts_quirks = TS_QUIRK_SERIAL,
+	.tempmon_irq = 24,
 };
 
 static struct ddb_info ddb_c2t2i_v0_8 = {
 	.type     = DDB_OCTOPUS_MAX_CT,
 	.name     = "Digital Devices MAX A8 C2T2I V0",
+	.regmap   = &octopus_map,
 	.port_num = 4,
+	.i2c_mask = 0x0f,
 	.board_control   = 0x0ff,
 	.board_control_2 = 0xf00,
 	.ts_quirks = TS_QUIRK_SERIAL | TS_QUIRK_ALT_OSC,
+	.tempmon_irq = 24,
 };
 
 static struct ddb_info ddb_c2t2i_8 = {
 	.type     = DDB_OCTOPUS_MAX_CT,
 	.name     = "Digital Devices MAX A8 C2T2I",
+	.regmap   = &octopus_map,
 	.port_num = 4,
+	.i2c_mask = 0x0f,
 	.board_control   = 0x0ff,
 	.board_control_2 = 0xf00,
 	.ts_quirks = TS_QUIRK_SERIAL,
+	.tempmon_irq = 24,
 };
 
-/******************************************************************************/
+/****************************************************************************/
+/****************************************************************************/
+/****************************************************************************/
 
 #define DDVID 0xdd01 /* Digital Devices Vendor ID */
 
-#define DDB_ID(_vend, _dev, _subvend, _subdev, _driverdata) {	\
-	.vendor      = _vend,    .device    = _dev, \
-	.subvendor   = _subvend, .subdevice = _subdev, \
-	.driver_data = (unsigned long)&_driverdata }
-
-static const struct pci_device_id ddb_id_tbl[] = {
-	DDB_ID(DDVID, 0x0002, DDVID, 0x0001, ddb_octopus),
-	DDB_ID(DDVID, 0x0003, DDVID, 0x0001, ddb_octopus),
-	DDB_ID(DDVID, 0x0005, DDVID, 0x0004, ddb_octopusv3),
-	DDB_ID(DDVID, 0x0003, DDVID, 0x0002, ddb_octopus_le),
-	DDB_ID(DDVID, 0x0003, DDVID, 0x0003, ddb_octopus_oem),
-	DDB_ID(DDVID, 0x0003, DDVID, 0x0010, ddb_octopus_mini),
-	DDB_ID(DDVID, 0x0005, DDVID, 0x0011, ddb_octopus_mini),
-	DDB_ID(DDVID, 0x0003, DDVID, 0x0020, ddb_v6),
-	DDB_ID(DDVID, 0x0003, DDVID, 0x0021, ddb_v6_5),
-	DDB_ID(DDVID, 0x0006, DDVID, 0x0022, ddb_v7),
-	DDB_ID(DDVID, 0x0006, DDVID, 0x0024, ddb_v7a),
-	DDB_ID(DDVID, 0x0003, DDVID, 0x0030, ddb_dvbct),
-	DDB_ID(DDVID, 0x0003, DDVID, 0xdb03, ddb_satixS2v3),
-	DDB_ID(DDVID, 0x0006, DDVID, 0x0031, ddb_ctv7),
-	DDB_ID(DDVID, 0x0006, DDVID, 0x0032, ddb_ctv7),
-	DDB_ID(DDVID, 0x0006, DDVID, 0x0033, ddb_ctv7),
-	DDB_ID(DDVID, 0x0008, DDVID, 0x0034, ddb_ct2_8),
-	DDB_ID(DDVID, 0x0008, DDVID, 0x0035, ddb_c2t2_8),
-	DDB_ID(DDVID, 0x0008, DDVID, 0x0036, ddb_isdbt_8),
-	DDB_ID(DDVID, 0x0008, DDVID, 0x0037, ddb_c2t2i_v0_8),
-	DDB_ID(DDVID, 0x0008, DDVID, 0x0038, ddb_c2t2i_8),
-	DDB_ID(DDVID, 0x0006, DDVID, 0x0039, ddb_ctv7),
+#define DDB_DEVICE(_device, _subdevice, _driver_data) { \
+		PCI_DEVICE_SUB(DDVID, _device, DDVID, _subdevice), \
+			.driver_data = (kernel_ulong_t) &_driver_data }
+
+#define DDB_DEVICE_ANY(_device) { \
+		PCI_DEVICE_SUB(DDVID, _device, DDVID, PCI_ANY_ID), \
+			.driver_data = (kernel_ulong_t) &ddb_none }
+
+static const struct pci_device_id ddb_id_table[] = {
+	DDB_DEVICE(0x0002, 0x0001, ddb_octopus),
+	DDB_DEVICE(0x0003, 0x0001, ddb_octopus),
+	DDB_DEVICE(0x0005, 0x0004, ddb_octopusv3),
+	DDB_DEVICE(0x0003, 0x0002, ddb_octopus_le),
+	DDB_DEVICE(0x0003, 0x0003, ddb_octopus_oem),
+	DDB_DEVICE(0x0003, 0x0010, ddb_octopus_mini),
+	DDB_DEVICE(0x0005, 0x0011, ddb_octopus_mini),
+	DDB_DEVICE(0x0003, 0x0020, ddb_v6),
+	DDB_DEVICE(0x0003, 0x0021, ddb_v6_5),
+	DDB_DEVICE(0x0006, 0x0022, ddb_v7),
+	DDB_DEVICE(0x0006, 0x0024, ddb_v7a),
+	DDB_DEVICE(0x0003, 0x0030, ddb_dvbct),
+	DDB_DEVICE(0x0003, 0xdb03, ddb_satixS2v3),
+	DDB_DEVICE(0x0006, 0x0031, ddb_ctv7),
+	DDB_DEVICE(0x0006, 0x0032, ddb_ctv7),
+	DDB_DEVICE(0x0006, 0x0033, ddb_ctv7),
+	DDB_DEVICE(0x0008, 0x0034, ddb_ct2_8),
+	DDB_DEVICE(0x0008, 0x0035, ddb_c2t2_8),
+	DDB_DEVICE(0x0008, 0x0036, ddb_isdbt_8),
+	DDB_DEVICE(0x0008, 0x0037, ddb_c2t2i_v0_8),
+	DDB_DEVICE(0x0008, 0x0038, ddb_c2t2i_8),
+	DDB_DEVICE(0x0006, 0x0039, ddb_ctv7),
+	DDB_DEVICE(0x0011, 0x0040, ddb_ci),
+	DDB_DEVICE(0x0011, 0x0041, ddb_cis),
+	DDB_DEVICE(0x0012, 0x0042, ddb_ci),
+	DDB_DEVICE(0x0013, 0x0043, ddb_ci_s2_pro),
+	DDB_DEVICE(0x0013, 0x0044, ddb_ci_s2_pro_a),
 	/* in case sub-ids got deleted in flash */
-	DDB_ID(DDVID, 0x0003, PCI_ANY_ID, PCI_ANY_ID, ddb_none),
-	DDB_ID(DDVID, 0x0005, PCI_ANY_ID, PCI_ANY_ID, ddb_none),
-	DDB_ID(DDVID, 0x0006, PCI_ANY_ID, PCI_ANY_ID, ddb_none),
-	DDB_ID(DDVID, 0x0007, PCI_ANY_ID, PCI_ANY_ID, ddb_none),
-	DDB_ID(DDVID, 0x0008, PCI_ANY_ID, PCI_ANY_ID, ddb_none),
-	DDB_ID(DDVID, 0x0011, PCI_ANY_ID, PCI_ANY_ID, ddb_none),
-	DDB_ID(DDVID, 0x0013, PCI_ANY_ID, PCI_ANY_ID, ddb_none),
-	DDB_ID(DDVID, 0x0201, PCI_ANY_ID, PCI_ANY_ID, ddb_none),
-	DDB_ID(DDVID, 0x0320, PCI_ANY_ID, PCI_ANY_ID, ddb_none),
+	DDB_DEVICE_ANY(0x0003),
+	DDB_DEVICE_ANY(0x0005),
+	DDB_DEVICE_ANY(0x0006),
+	DDB_DEVICE_ANY(0x0007),
+	DDB_DEVICE_ANY(0x0008),
+	DDB_DEVICE_ANY(0x0011),
+	DDB_DEVICE_ANY(0x0012),
+	DDB_DEVICE_ANY(0x0013),
+	DDB_DEVICE_ANY(0x0201),
+	DDB_DEVICE_ANY(0x0203),
+	DDB_DEVICE_ANY(0x0210),
+	DDB_DEVICE_ANY(0x0220),
+	DDB_DEVICE_ANY(0x0320),
+	DDB_DEVICE_ANY(0x0321),
+	DDB_DEVICE_ANY(0x0322),
+	DDB_DEVICE_ANY(0x0323),
+	DDB_DEVICE_ANY(0x0328),
+	DDB_DEVICE_ANY(0x0329),
 	{0}
 };
-MODULE_DEVICE_TABLE(pci, ddb_id_tbl);
 
+MODULE_DEVICE_TABLE(pci, ddb_id_table);
 
 static struct pci_driver ddb_pci_driver = {
-	.name        = "DDBridge",
-	.id_table    = ddb_id_tbl,
+	.name        = "ddbridge",
+	.id_table    = ddb_id_table,
 	.probe       = ddb_probe,
 	.remove      = ddb_remove,
 };
 
 static __init int module_init_ddbridge(void)
 {
-	int ret;
-
-	pr_info("Digital Devices PCIE bridge driver, Copyright (C) 2010-11 Digital Devices GmbH\n");
-
-	ret = ddb_class_create();
-	if (ret < 0)
-		return ret;
-	ret = pci_register_driver(&ddb_pci_driver);
-	if (ret < 0)
-		ddb_class_destroy();
-	return ret;
+	int stat = -1;
+
+	pr_info("Digital Devices PCIE bridge driver "
+		DDBRIDGE_VERSION
+		", Copyright (C) 2010-17 Digital Devices GmbH\n");
+	if (ddb_class_create() < 0)
+		return -1;
+	ddb_wq = create_workqueue("ddbridge");
+	if (ddb_wq == NULL)
+		goto exit1;
+	stat = pci_register_driver(&ddb_pci_driver);
+	if (stat < 0)
+		goto exit2;
+	return stat;
+exit2:
+	destroy_workqueue(ddb_wq);
+exit1:
+	ddb_class_destroy();
+	return stat;
 }
 
 static __exit void module_exit_ddbridge(void)
 {
 	pci_unregister_driver(&ddb_pci_driver);
+	destroy_workqueue(ddb_wq);
 	ddb_class_destroy();
 }
 
@@ -384,6 +596,6 @@ module_init(module_init_ddbridge);
 module_exit(module_exit_ddbridge);
 
 MODULE_DESCRIPTION("Digital Devices PCIe Bridge");
-MODULE_AUTHOR("Ralph Metzler");
+MODULE_AUTHOR("Ralph and Marcus Metzler, Metzler Brothers Systementwicklung GbR");
 MODULE_LICENSE("GPL");
-MODULE_VERSION("0.5");
+MODULE_VERSION(DDBRIDGE_VERSION);

commit a96e5ab8a713e99b5d4a4b9110d7226f8dbc97ea
Author: Daniel Scheller <d.scheller@gmx.net>
Date:   Sat Jul 29 07:28:36 2017 -0400

    media: ddbridge: split code into multiple files
    
    As of 0.9.9b, the ddbridge code has been split from one single file
    (ddbridge-core.c) into multiple files, with the purpose of taking care of
    different topics, and to be able to reuse code in different kernel modules
    (ddbridge.ko and octonet.ko). This applies the same code split, with a
    notable difference:
    
    In the vendor package, the split was done by moving all code parts into
    separate files, and in the "main" code files (ddbridge.c and octonet.c),
    a simple "#include ddbridge-core.c" was done.
    
    In this patch, the same split (codewise) is done, but all resulting .c/.o
    files will be handled by the makefile, with proper prototyping of all
    shared functions done in ddbridge.h. To avoid conflicts wrt the global
    space, the I2C functions and necessary prototypes for ddbridge-i2c.c are
    moved into ddbridge-i2c.h, which is to be included wherever required.
    
    Signed-off-by: Daniel Scheller <d.scheller@gmx.net>
    Tested-by: Richard Scobie <r.scobie@clear.net.nz>
    Tested-by: Jasmin Jessich <jasmin@anw.at>
    Tested-by: Dietmar Spingler <d_spingler@freenet.de>
    Tested-by: Manfred Knick <Manfred.Knick@t-online.de>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/pci/ddbridge/ddbridge-main.c b/drivers/media/pci/ddbridge/ddbridge-main.c
new file mode 100644
index 000000000000..41c0adc176b1
--- /dev/null
+++ b/drivers/media/pci/ddbridge/ddbridge-main.c
@@ -0,0 +1,389 @@
+/*
+ * ddbridge.c: Digital Devices PCIe bridge driver
+ *
+ * Copyright (C) 2010-2011 Digital Devices GmbH
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 only, as published by the Free Software Foundation.
+ *
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * To obtain the license, point your browser to
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/poll.h>
+#include <linux/io.h>
+#include <linux/pci.h>
+#include <linux/pci_ids.h>
+#include <linux/timer.h>
+#include <linux/i2c.h>
+#include <linux/swab.h>
+#include <linux/vmalloc.h>
+
+#include "ddbridge.h"
+#include "ddbridge-i2c.h"
+#include "ddbridge-regs.h"
+
+int xo2_speed = 2;
+module_param(xo2_speed, int, 0444);
+MODULE_PARM_DESC(xo2_speed, "default transfer speed for xo2 based duoflex, 0=55,1=75,2=90,3=104 MBit/s, default=2, use attribute to change for individual cards");
+
+int stv0910_single;
+module_param(stv0910_single, int, 0444);
+MODULE_PARM_DESC(stv0910_single, "use stv0910 cards as single demods");
+
+/******************************************************************************/
+
+static void ddb_unmap(struct ddb *dev)
+{
+	if (dev->regs)
+		iounmap(dev->regs);
+	vfree(dev);
+}
+
+
+static void ddb_remove(struct pci_dev *pdev)
+{
+	struct ddb *dev = pci_get_drvdata(pdev);
+
+	ddb_ports_detach(dev);
+	ddb_i2c_release(dev);
+
+	ddbwritel(0, INTERRUPT_ENABLE);
+	free_irq(dev->pdev->irq, dev);
+#ifdef CONFIG_PCI_MSI
+	if (dev->msi)
+		pci_disable_msi(dev->pdev);
+#endif
+	ddb_ports_release(dev);
+	ddb_buffers_free(dev);
+	ddb_device_destroy(dev);
+
+	ddb_unmap(dev);
+	pci_set_drvdata(pdev, NULL);
+	pci_disable_device(pdev);
+}
+
+
+static int ddb_probe(struct pci_dev *pdev, const struct pci_device_id *id)
+{
+	struct ddb *dev;
+	int stat = 0;
+	int irq_flag = IRQF_SHARED;
+
+	if (pci_enable_device(pdev) < 0)
+		return -ENODEV;
+
+	dev = vzalloc(sizeof(struct ddb));
+	if (dev == NULL)
+		return -ENOMEM;
+
+	dev->pdev = pdev;
+	pci_set_drvdata(pdev, dev);
+	dev->info = (struct ddb_info *) id->driver_data;
+	dev_info(&pdev->dev, "Detected %s\n", dev->info->name);
+
+	dev->regs = ioremap(pci_resource_start(dev->pdev, 0),
+			    pci_resource_len(dev->pdev, 0));
+	if (!dev->regs) {
+		stat = -ENOMEM;
+		goto fail;
+	}
+	dev_info(&pdev->dev, "HW %08x FW %08x\n", ddbreadl(0), ddbreadl(4));
+
+#ifdef CONFIG_PCI_MSI
+	if (pci_msi_enabled())
+		stat = pci_enable_msi(dev->pdev);
+	if (stat) {
+		dev_info(&pdev->dev, "MSI not available.\n");
+	} else {
+		irq_flag = 0;
+		dev->msi = 1;
+	}
+#endif
+	stat = request_irq(dev->pdev->irq, irq_handler,
+			   irq_flag, "DDBridge", (void *) dev);
+	if (stat < 0)
+		goto fail1;
+	ddbwritel(0, DMA_BASE_WRITE);
+	ddbwritel(0, DMA_BASE_READ);
+	ddbwritel(0xffffffff, INTERRUPT_ACK);
+	ddbwritel(0xfff0f, INTERRUPT_ENABLE);
+	ddbwritel(0, MSI1_ENABLE);
+
+	/* board control */
+	if (dev->info->board_control) {
+		ddbwritel(0, DDB_LINK_TAG(0) | BOARD_CONTROL);
+		msleep(100);
+		ddbwritel(dev->info->board_control_2,
+			DDB_LINK_TAG(0) | BOARD_CONTROL);
+		usleep_range(2000, 3000);
+		ddbwritel(dev->info->board_control_2
+			| dev->info->board_control,
+			DDB_LINK_TAG(0) | BOARD_CONTROL);
+		usleep_range(2000, 3000);
+	}
+
+	if (ddb_i2c_init(dev) < 0)
+		goto fail1;
+	ddb_ports_init(dev);
+	if (ddb_buffers_alloc(dev) < 0) {
+		dev_err(&pdev->dev, "Could not allocate buffer memory\n");
+		goto fail2;
+	}
+	if (ddb_ports_attach(dev) < 0)
+		goto fail3;
+	ddb_device_create(dev);
+	return 0;
+
+fail3:
+	ddb_ports_detach(dev);
+	dev_err(&pdev->dev, "fail3\n");
+	ddb_ports_release(dev);
+fail2:
+	dev_err(&pdev->dev, "fail2\n");
+	ddb_buffers_free(dev);
+fail1:
+	dev_err(&pdev->dev, "fail1\n");
+	if (dev->msi)
+		pci_disable_msi(dev->pdev);
+	if (stat == 0)
+		free_irq(dev->pdev->irq, dev);
+fail:
+	dev_err(&pdev->dev, "fail\n");
+	ddb_unmap(dev);
+	pci_set_drvdata(pdev, NULL);
+	pci_disable_device(pdev);
+	return -1;
+}
+
+/******************************************************************************/
+/******************************************************************************/
+/******************************************************************************/
+
+static const struct ddb_info ddb_none = {
+	.type     = DDB_NONE,
+	.name     = "Digital Devices PCIe bridge",
+};
+
+static const struct ddb_info ddb_octopus = {
+	.type     = DDB_OCTOPUS,
+	.name     = "Digital Devices Octopus DVB adapter",
+	.port_num = 4,
+};
+
+static const struct ddb_info ddb_octopus_le = {
+	.type     = DDB_OCTOPUS,
+	.name     = "Digital Devices Octopus LE DVB adapter",
+	.port_num = 2,
+};
+
+static const struct ddb_info ddb_octopus_oem = {
+	.type     = DDB_OCTOPUS,
+	.name     = "Digital Devices Octopus OEM",
+	.port_num = 4,
+};
+
+static const struct ddb_info ddb_octopus_mini = {
+	.type     = DDB_OCTOPUS,
+	.name     = "Digital Devices Octopus Mini",
+	.port_num = 4,
+};
+
+static const struct ddb_info ddb_v6 = {
+	.type     = DDB_OCTOPUS,
+	.name     = "Digital Devices Cine S2 V6 DVB adapter",
+	.port_num = 3,
+};
+static const struct ddb_info ddb_v6_5 = {
+	.type     = DDB_OCTOPUS,
+	.name     = "Digital Devices Cine S2 V6.5 DVB adapter",
+	.port_num = 4,
+};
+
+static const struct ddb_info ddb_v7 = {
+	.type     = DDB_OCTOPUS,
+	.name     = "Digital Devices Cine S2 V7 DVB adapter",
+	.port_num = 4,
+	.board_control   = 2,
+	.board_control_2 = 4,
+	.ts_quirks = TS_QUIRK_REVERSED,
+};
+
+static const struct ddb_info ddb_v7a = {
+	.type     = DDB_OCTOPUS,
+	.name     = "Digital Devices Cine S2 V7 Advanced DVB adapter",
+	.port_num = 4,
+	.board_control   = 2,
+	.board_control_2 = 4,
+	.ts_quirks = TS_QUIRK_REVERSED,
+};
+
+static const struct ddb_info ddb_dvbct = {
+	.type     = DDB_OCTOPUS,
+	.name     = "Digital Devices DVBCT V6.1 DVB adapter",
+	.port_num = 3,
+};
+
+static const struct ddb_info ddb_ctv7 = {
+	.type     = DDB_OCTOPUS,
+	.name     = "Digital Devices Cine CT V7 DVB adapter",
+	.port_num = 4,
+	.board_control   = 3,
+	.board_control_2 = 4,
+};
+
+static const struct ddb_info ddb_satixS2v3 = {
+	.type     = DDB_OCTOPUS,
+	.name     = "Mystique SaTiX-S2 V3 DVB adapter",
+	.port_num = 3,
+};
+
+static const struct ddb_info ddb_octopusv3 = {
+	.type     = DDB_OCTOPUS,
+	.name     = "Digital Devices Octopus V3 DVB adapter",
+	.port_num = 4,
+};
+
+/*** MaxA8 adapters ***********************************************************/
+
+static struct ddb_info ddb_ct2_8 = {
+	.type     = DDB_OCTOPUS_MAX_CT,
+	.name     = "Digital Devices MAX A8 CT2",
+	.port_num = 4,
+	.board_control   = 0x0ff,
+	.board_control_2 = 0xf00,
+	.ts_quirks = TS_QUIRK_SERIAL,
+};
+
+static struct ddb_info ddb_c2t2_8 = {
+	.type     = DDB_OCTOPUS_MAX_CT,
+	.name     = "Digital Devices MAX A8 C2T2",
+	.port_num = 4,
+	.board_control   = 0x0ff,
+	.board_control_2 = 0xf00,
+	.ts_quirks = TS_QUIRK_SERIAL,
+};
+
+static struct ddb_info ddb_isdbt_8 = {
+	.type     = DDB_OCTOPUS_MAX_CT,
+	.name     = "Digital Devices MAX A8 ISDBT",
+	.port_num = 4,
+	.board_control   = 0x0ff,
+	.board_control_2 = 0xf00,
+	.ts_quirks = TS_QUIRK_SERIAL,
+};
+
+static struct ddb_info ddb_c2t2i_v0_8 = {
+	.type     = DDB_OCTOPUS_MAX_CT,
+	.name     = "Digital Devices MAX A8 C2T2I V0",
+	.port_num = 4,
+	.board_control   = 0x0ff,
+	.board_control_2 = 0xf00,
+	.ts_quirks = TS_QUIRK_SERIAL | TS_QUIRK_ALT_OSC,
+};
+
+static struct ddb_info ddb_c2t2i_8 = {
+	.type     = DDB_OCTOPUS_MAX_CT,
+	.name     = "Digital Devices MAX A8 C2T2I",
+	.port_num = 4,
+	.board_control   = 0x0ff,
+	.board_control_2 = 0xf00,
+	.ts_quirks = TS_QUIRK_SERIAL,
+};
+
+/******************************************************************************/
+
+#define DDVID 0xdd01 /* Digital Devices Vendor ID */
+
+#define DDB_ID(_vend, _dev, _subvend, _subdev, _driverdata) {	\
+	.vendor      = _vend,    .device    = _dev, \
+	.subvendor   = _subvend, .subdevice = _subdev, \
+	.driver_data = (unsigned long)&_driverdata }
+
+static const struct pci_device_id ddb_id_tbl[] = {
+	DDB_ID(DDVID, 0x0002, DDVID, 0x0001, ddb_octopus),
+	DDB_ID(DDVID, 0x0003, DDVID, 0x0001, ddb_octopus),
+	DDB_ID(DDVID, 0x0005, DDVID, 0x0004, ddb_octopusv3),
+	DDB_ID(DDVID, 0x0003, DDVID, 0x0002, ddb_octopus_le),
+	DDB_ID(DDVID, 0x0003, DDVID, 0x0003, ddb_octopus_oem),
+	DDB_ID(DDVID, 0x0003, DDVID, 0x0010, ddb_octopus_mini),
+	DDB_ID(DDVID, 0x0005, DDVID, 0x0011, ddb_octopus_mini),
+	DDB_ID(DDVID, 0x0003, DDVID, 0x0020, ddb_v6),
+	DDB_ID(DDVID, 0x0003, DDVID, 0x0021, ddb_v6_5),
+	DDB_ID(DDVID, 0x0006, DDVID, 0x0022, ddb_v7),
+	DDB_ID(DDVID, 0x0006, DDVID, 0x0024, ddb_v7a),
+	DDB_ID(DDVID, 0x0003, DDVID, 0x0030, ddb_dvbct),
+	DDB_ID(DDVID, 0x0003, DDVID, 0xdb03, ddb_satixS2v3),
+	DDB_ID(DDVID, 0x0006, DDVID, 0x0031, ddb_ctv7),
+	DDB_ID(DDVID, 0x0006, DDVID, 0x0032, ddb_ctv7),
+	DDB_ID(DDVID, 0x0006, DDVID, 0x0033, ddb_ctv7),
+	DDB_ID(DDVID, 0x0008, DDVID, 0x0034, ddb_ct2_8),
+	DDB_ID(DDVID, 0x0008, DDVID, 0x0035, ddb_c2t2_8),
+	DDB_ID(DDVID, 0x0008, DDVID, 0x0036, ddb_isdbt_8),
+	DDB_ID(DDVID, 0x0008, DDVID, 0x0037, ddb_c2t2i_v0_8),
+	DDB_ID(DDVID, 0x0008, DDVID, 0x0038, ddb_c2t2i_8),
+	DDB_ID(DDVID, 0x0006, DDVID, 0x0039, ddb_ctv7),
+	/* in case sub-ids got deleted in flash */
+	DDB_ID(DDVID, 0x0003, PCI_ANY_ID, PCI_ANY_ID, ddb_none),
+	DDB_ID(DDVID, 0x0005, PCI_ANY_ID, PCI_ANY_ID, ddb_none),
+	DDB_ID(DDVID, 0x0006, PCI_ANY_ID, PCI_ANY_ID, ddb_none),
+	DDB_ID(DDVID, 0x0007, PCI_ANY_ID, PCI_ANY_ID, ddb_none),
+	DDB_ID(DDVID, 0x0008, PCI_ANY_ID, PCI_ANY_ID, ddb_none),
+	DDB_ID(DDVID, 0x0011, PCI_ANY_ID, PCI_ANY_ID, ddb_none),
+	DDB_ID(DDVID, 0x0013, PCI_ANY_ID, PCI_ANY_ID, ddb_none),
+	DDB_ID(DDVID, 0x0201, PCI_ANY_ID, PCI_ANY_ID, ddb_none),
+	DDB_ID(DDVID, 0x0320, PCI_ANY_ID, PCI_ANY_ID, ddb_none),
+	{0}
+};
+MODULE_DEVICE_TABLE(pci, ddb_id_tbl);
+
+
+static struct pci_driver ddb_pci_driver = {
+	.name        = "DDBridge",
+	.id_table    = ddb_id_tbl,
+	.probe       = ddb_probe,
+	.remove      = ddb_remove,
+};
+
+static __init int module_init_ddbridge(void)
+{
+	int ret;
+
+	pr_info("Digital Devices PCIE bridge driver, Copyright (C) 2010-11 Digital Devices GmbH\n");
+
+	ret = ddb_class_create();
+	if (ret < 0)
+		return ret;
+	ret = pci_register_driver(&ddb_pci_driver);
+	if (ret < 0)
+		ddb_class_destroy();
+	return ret;
+}
+
+static __exit void module_exit_ddbridge(void)
+{
+	pci_unregister_driver(&ddb_pci_driver);
+	ddb_class_destroy();
+}
+
+module_init(module_init_ddbridge);
+module_exit(module_exit_ddbridge);
+
+MODULE_DESCRIPTION("Digital Devices PCIe Bridge");
+MODULE_AUTHOR("Ralph Metzler");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("0.5");
