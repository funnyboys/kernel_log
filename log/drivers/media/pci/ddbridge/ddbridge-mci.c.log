commit e552684809d601c9a6109a73322c816ce1de10bd
Author: Daniel Scheller <d.scheller@gmx.net>
Date:   Sat Jun 23 11:36:11 2018 -0400

    media: ddbridge/mci: split MaxSX8 specific code off to ddbridge-sx8.c
    
    Split off all code specific to the MaxSX8 cards to a separate ddbridge-sx8
    module and hook it up in the Makefile. This also adds evaluation of the
    mci_type to allow for using different attach handling for different cards.
    As different cards can implement things differently (ie. support differing
    frontend_ops, and have different base structs being put ontop of the
    common mci_base struct), this introduces the mci_cfg struct which is
    initially used to hold a few specifics to the -sx8 submodule. While at it,
    the handling of the i/q mode is adjusted slightly. Besides this and
    handling mci_base and sx8_base struct pointers where needed, all code
    is copied unmodified from ddbridge-mci.c.
    
    Picked up from the upstream dddvb GIT.
    
    Signed-off-by: Daniel Scheller <d.scheller@gmx.net>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/pci/ddbridge/ddbridge-mci.c b/drivers/media/pci/ddbridge/ddbridge-mci.c
index a29ff25d9029..97384ae9ad27 100644
--- a/drivers/media/pci/ddbridge/ddbridge-mci.c
+++ b/drivers/media/pci/ddbridge/ddbridge-mci.c
@@ -22,10 +22,6 @@
 
 static LIST_HEAD(mci_list);
 
-static const u32 MCLK = (1550000000 / 12);
-static const u32 MAX_DEMOD_LDPC_BITRATE = (1550000000 / 6);
-static const u32 MAX_LDPC_BITRATE = (720000000);
-
 static int mci_reset(struct mci *state)
 {
 	struct ddb_link *link = state->base->link;
@@ -99,7 +95,7 @@ int ddb_mci_cmd(struct mci *state,
 	mutex_lock(&state->base->mci_lock);
 	stat = _mci_cmd_unlocked(state,
 				 (u32 *)command, sizeof(*command) / sizeof(u32),
-				 (u32 *)result, sizeof(*result) / sizeof(u32));
+				 (u32 *)result,	sizeof(*result) / sizeof(u32));
 	mutex_unlock(&state->base->mci_lock);
 	return stat;
 }
@@ -111,389 +107,6 @@ static void mci_handler(void *priv)
 	complete(&base->completion);
 }
 
-static void release(struct dvb_frontend *fe)
-{
-	struct mci *state = fe->demodulator_priv;
-
-	state->base->count--;
-	if (state->base->count == 0) {
-		list_del(&state->base->mci_list);
-		kfree(state->base);
-	}
-	kfree(state);
-}
-
-static int get_info(struct dvb_frontend *fe)
-{
-	int stat;
-	struct mci *state = fe->demodulator_priv;
-	struct mci_command cmd;
-
-	memset(&cmd, 0, sizeof(cmd));
-	cmd.command = MCI_CMD_GETSIGNALINFO;
-	cmd.demod = state->demod;
-	stat = ddb_mci_cmd(state, &cmd, &state->signal_info);
-	return stat;
-}
-
-static int get_snr(struct dvb_frontend *fe)
-{
-	struct mci *state = fe->demodulator_priv;
-	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
-
-	p->cnr.len = 1;
-	p->cnr.stat[0].scale = FE_SCALE_DECIBEL;
-	p->cnr.stat[0].svalue =
-		(s64)state->signal_info.dvbs2_signal_info.signal_to_noise
-		     * 10;
-	return 0;
-}
-
-static int get_strength(struct dvb_frontend *fe)
-{
-	struct mci *state = fe->demodulator_priv;
-	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
-	s32 str;
-
-	str = 100000 -
-	      (state->signal_info.dvbs2_signal_info.channel_power
-	       * 10 + 108750);
-	p->strength.len = 1;
-	p->strength.stat[0].scale = FE_SCALE_DECIBEL;
-	p->strength.stat[0].svalue = str;
-	return 0;
-}
-
-static int read_status(struct dvb_frontend *fe, enum fe_status *status)
-{
-	int stat;
-	struct mci *state = fe->demodulator_priv;
-	struct mci_command cmd;
-	struct mci_result res;
-
-	cmd.command = MCI_CMD_GETSTATUS;
-	cmd.demod = state->demod;
-	stat = ddb_mci_cmd(state, &cmd, &res);
-	if (stat)
-		return stat;
-	*status = 0x00;
-	get_info(fe);
-	get_strength(fe);
-	if (res.status == SX8_DEMOD_WAIT_MATYPE)
-		*status = 0x0f;
-	if (res.status == SX8_DEMOD_LOCKED) {
-		*status = 0x1f;
-		get_snr(fe);
-	}
-	return stat;
-}
-
-static int mci_set_tuner(struct dvb_frontend *fe, u32 tuner, u32 on)
-{
-	struct mci *state = fe->demodulator_priv;
-	struct mci_command cmd;
-
-	memset(&cmd, 0, sizeof(cmd));
-	cmd.tuner = state->tuner;
-	cmd.command = on ? SX8_CMD_INPUT_ENABLE : SX8_CMD_INPUT_DISABLE;
-	return ddb_mci_cmd(state, &cmd, NULL);
-}
-
-static int stop(struct dvb_frontend *fe)
-{
-	struct mci *state = fe->demodulator_priv;
-	struct mci_command cmd;
-	u32 input = state->tuner;
-
-	memset(&cmd, 0, sizeof(cmd));
-	if (state->demod != DEMOD_UNUSED) {
-		cmd.command = MCI_CMD_STOP;
-		cmd.demod = state->demod;
-		ddb_mci_cmd(state, &cmd, NULL);
-		if (state->base->iq_mode) {
-			cmd.command = MCI_CMD_STOP;
-			cmd.demod = state->demod;
-			cmd.output = 0;
-			ddb_mci_cmd(state, &cmd, NULL);
-			ddb_mci_config(state, SX8_TSCONFIG_MODE_NORMAL);
-		}
-	}
-	mutex_lock(&state->base->tuner_lock);
-	state->base->tuner_use_count[input]--;
-	if (!state->base->tuner_use_count[input])
-		mci_set_tuner(fe, input, 0);
-	if (state->demod < MCI_DEMOD_MAX)
-		state->base->demod_in_use[state->demod] = 0;
-	state->base->used_ldpc_bitrate[state->nr] = 0;
-	state->demod = DEMOD_UNUSED;
-	state->base->assigned_demod[state->nr] = DEMOD_UNUSED;
-	state->base->iq_mode = 0;
-	mutex_unlock(&state->base->tuner_lock);
-	state->started = 0;
-	return 0;
-}
-
-static int start(struct dvb_frontend *fe, u32 flags, u32 modmask, u32 ts_config)
-{
-	struct mci *state = fe->demodulator_priv;
-	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
-	u32 used_ldpc_bitrate = 0, free_ldpc_bitrate;
-	u32 used_demods = 0;
-	struct mci_command cmd;
-	u32 input = state->tuner;
-	u32 bits_per_symbol = 0;
-	int i, stat = 0;
-
-	if (p->symbol_rate >= (MCLK / 2))
-		flags &= ~1;
-	if ((flags & 3) == 0)
-		return -EINVAL;
-
-	if (flags & 2) {
-		u32 tmp = modmask;
-
-		bits_per_symbol = 1;
-		while (tmp & 1) {
-			tmp >>= 1;
-			bits_per_symbol++;
-		}
-	}
-
-	mutex_lock(&state->base->tuner_lock);
-	if (state->base->iq_mode) {
-		stat = -EBUSY;
-		goto unlock;
-	}
-	for (i = 0; i < MCI_DEMOD_MAX; i++) {
-		used_ldpc_bitrate += state->base->used_ldpc_bitrate[i];
-		if (state->base->demod_in_use[i])
-			used_demods++;
-	}
-	if (used_ldpc_bitrate >= MAX_LDPC_BITRATE ||
-	    ((ts_config & SX8_TSCONFIG_MODE_MASK) >
-	     SX8_TSCONFIG_MODE_NORMAL && used_demods > 0)) {
-		stat = -EBUSY;
-		goto unlock;
-	}
-	free_ldpc_bitrate = MAX_LDPC_BITRATE - used_ldpc_bitrate;
-	if (free_ldpc_bitrate > MAX_DEMOD_LDPC_BITRATE)
-		free_ldpc_bitrate = MAX_DEMOD_LDPC_BITRATE;
-
-	while (p->symbol_rate * bits_per_symbol > free_ldpc_bitrate)
-		bits_per_symbol--;
-
-	if (bits_per_symbol < 2) {
-		stat = -EBUSY;
-		goto unlock;
-	}
-	i = (p->symbol_rate > (MCLK / 2)) ? 3 : 7;
-	while (i >= 0 && state->base->demod_in_use[i])
-		i--;
-	if (i < 0) {
-		stat = -EBUSY;
-		goto unlock;
-	}
-	state->base->demod_in_use[i] = 1;
-	state->base->used_ldpc_bitrate[state->nr] = p->symbol_rate
-						    * bits_per_symbol;
-	state->demod = i;
-	state->base->assigned_demod[state->nr] = i;
-
-	if (!state->base->tuner_use_count[input])
-		mci_set_tuner(fe, input, 1);
-	state->base->tuner_use_count[input]++;
-	state->base->iq_mode = (ts_config > 1);
-unlock:
-	mutex_unlock(&state->base->tuner_lock);
-	if (stat)
-		return stat;
-	memset(&cmd, 0, sizeof(cmd));
-
-	if (state->base->iq_mode) {
-		cmd.command = SX8_CMD_ENABLE_IQOUTPUT;
-		cmd.demod = state->demod;
-		cmd.output = 0;
-		ddb_mci_cmd(state, &cmd, NULL);
-		ddb_mci_config(state, ts_config);
-	}
-	if (p->stream_id != NO_STREAM_ID_FILTER && p->stream_id != 0x80000000)
-		flags |= 0x80;
-	dev_dbg(state->base->dev, "MCI-%d: tuner=%d demod=%d\n",
-		state->nr, state->tuner, state->demod);
-	cmd.command = MCI_CMD_SEARCH_DVBS;
-	cmd.dvbs2_search.flags = flags;
-	cmd.dvbs2_search.s2_modulation_mask =
-		modmask & ((1 << (bits_per_symbol - 1)) - 1);
-	cmd.dvbs2_search.retry = 2;
-	cmd.dvbs2_search.frequency = p->frequency * 1000;
-	cmd.dvbs2_search.symbol_rate = p->symbol_rate;
-	cmd.dvbs2_search.scrambling_sequence_index =
-		p->scrambling_sequence_index;
-	cmd.dvbs2_search.input_stream_id =
-		(p->stream_id != NO_STREAM_ID_FILTER) ? p->stream_id : 0;
-	cmd.tuner = state->tuner;
-	cmd.demod = state->demod;
-	cmd.output = state->nr;
-	if (p->stream_id == 0x80000000)
-		cmd.output |= 0x80;
-	stat = ddb_mci_cmd(state, &cmd, NULL);
-	if (stat)
-		stop(fe);
-	return stat;
-}
-
-static int start_iq(struct dvb_frontend *fe, u32 ts_config)
-{
-	struct mci *state = fe->demodulator_priv;
-	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
-	u32 used_demods = 0;
-	struct mci_command cmd;
-	u32 input = state->tuner;
-	int i, stat = 0;
-
-	mutex_lock(&state->base->tuner_lock);
-	if (state->base->iq_mode) {
-		stat = -EBUSY;
-		goto unlock;
-	}
-	for (i = 0; i < MCI_DEMOD_MAX; i++)
-		if (state->base->demod_in_use[i])
-			used_demods++;
-	if (used_demods > 0) {
-		stat = -EBUSY;
-		goto unlock;
-	}
-	state->demod = 0;
-	state->base->assigned_demod[state->nr] = 0;
-	if (!state->base->tuner_use_count[input])
-		mci_set_tuner(fe, input, 1);
-	state->base->tuner_use_count[input]++;
-	state->base->iq_mode = (ts_config > 1);
-unlock:
-	mutex_unlock(&state->base->tuner_lock);
-	if (stat)
-		return stat;
-
-	memset(&cmd, 0, sizeof(cmd));
-	cmd.command = SX8_CMD_START_IQ;
-	cmd.dvbs2_search.frequency = p->frequency * 1000;
-	cmd.dvbs2_search.symbol_rate = p->symbol_rate;
-	cmd.tuner = state->tuner;
-	cmd.demod = state->demod;
-	cmd.output = 7;
-	ddb_mci_config(state, ts_config);
-	stat = ddb_mci_cmd(state, &cmd, NULL);
-	if (stat)
-		stop(fe);
-	return stat;
-}
-
-static int set_parameters(struct dvb_frontend *fe)
-{
-	int stat = 0;
-	struct mci *state = fe->demodulator_priv;
-	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
-	u32 ts_config, iq_mode = 0, isi;
-
-	if (state->started)
-		stop(fe);
-
-	isi = p->stream_id;
-	if (isi != NO_STREAM_ID_FILTER)
-		iq_mode = (isi & 0x30000000) >> 28;
-
-	switch (iq_mode) {
-	case 1:
-		ts_config = (SX8_TSCONFIG_TSHEADER | SX8_TSCONFIG_MODE_IQ);
-		break;
-	case 2:
-		ts_config = (SX8_TSCONFIG_TSHEADER | SX8_TSCONFIG_MODE_IQ);
-		break;
-	default:
-		ts_config = SX8_TSCONFIG_MODE_NORMAL;
-		break;
-	}
-
-	if (iq_mode != 2) {
-		u32 flags = 3;
-		u32 mask = 3;
-
-		if (p->modulation == APSK_16 ||
-		    p->modulation == APSK_32) {
-			flags = 2;
-			mask = 15;
-		}
-		stat = start(fe, flags, mask, ts_config);
-	} else {
-		stat = start_iq(fe, ts_config);
-	}
-
-	if (!stat) {
-		state->started = 1;
-		state->first_time_lock = 1;
-		state->signal_info.status = SX8_DEMOD_WAIT_SIGNAL;
-	}
-
-	return stat;
-}
-
-static int tune(struct dvb_frontend *fe, bool re_tune,
-		unsigned int mode_flags,
-		unsigned int *delay, enum fe_status *status)
-{
-	int r;
-
-	if (re_tune) {
-		r = set_parameters(fe);
-		if (r)
-			return r;
-	}
-	r = read_status(fe, status);
-	if (r)
-		return r;
-
-	if (*status & FE_HAS_LOCK)
-		return 0;
-	*delay = HZ / 10;
-	return 0;
-}
-
-static enum dvbfe_algo get_algo(struct dvb_frontend *fe)
-{
-	return DVBFE_ALGO_HW;
-}
-
-static int set_input(struct dvb_frontend *fe, int input)
-{
-	struct mci *state = fe->demodulator_priv;
-
-	state->tuner = input;
-	dev_dbg(state->base->dev, "MCI-%d: input=%d\n", state->nr, input);
-	return 0;
-}
-
-static struct dvb_frontend_ops mci_ops = {
-	.delsys = { SYS_DVBS, SYS_DVBS2 },
-	.info = {
-		.name			= "Digital Devices MaxSX8 MCI DVB-S/S2/S2X",
-		.frequency_min		= 950000,
-		.frequency_max		= 2150000,
-		.frequency_stepsize	= 0,
-		.frequency_tolerance	= 0,
-		.symbol_rate_min	= 100000,
-		.symbol_rate_max	= 100000000,
-		.caps			= FE_CAN_INVERSION_AUTO |
-					  FE_CAN_FEC_AUTO       |
-					  FE_CAN_QPSK           |
-					  FE_CAN_2G_MODULATION  |
-					  FE_CAN_MULTISTREAM,
-	},
-	.get_frontend_algo		= get_algo,
-	.tune				= tune,
-	.release			= release,
-	.read_status			= read_status,
-};
-
 static struct mci_base *match_base(void *key)
 {
 	struct mci_base *p;
@@ -511,8 +124,7 @@ static int probe(struct mci *state)
 }
 
 struct dvb_frontend
-*ddb_mci_attach(struct ddb_input *input,
-		int mci_type, int nr,
+*ddb_mci_attach(struct ddb_input *input, struct mci_cfg *cfg, int nr,
 		int (**fn_set_input)(struct dvb_frontend *fe, int input))
 {
 	struct ddb_port *port = input->port;
@@ -520,9 +132,9 @@ struct dvb_frontend
 	struct ddb_link *link = &dev->link[port->lnr];
 	struct mci_base *base;
 	struct mci *state;
-	void *key = mci_type ? (void *)port : (void *)link;
+	void *key = cfg->type ? (void *)port : (void *)link;
 
-	state = kzalloc(sizeof(*state), GFP_KERNEL);
+	state = kzalloc(cfg->state_size, GFP_KERNEL);
 	if (!state)
 		return NULL;
 
@@ -531,7 +143,7 @@ struct dvb_frontend
 		base->count++;
 		state->base = base;
 	} else {
-		base = kzalloc(sizeof(*base), GFP_KERNEL);
+		base = kzalloc(cfg->base_size, GFP_KERNEL);
 		if (!base)
 			goto fail;
 		base->key = key;
@@ -548,15 +160,17 @@ struct dvb_frontend
 			goto fail;
 		}
 		list_add(&base->mci_list, &mci_list);
+		if (cfg->base_init)
+			cfg->base_init(base);
 	}
-	state->fe.ops = mci_ops;
+	memcpy(&state->fe.ops, cfg->fe_ops, sizeof(struct dvb_frontend_ops));
 	state->fe.demodulator_priv = state;
 	state->nr = nr;
-	*fn_set_input = set_input;
-
+	*fn_set_input = cfg->set_input;
 	state->tuner = nr;
 	state->demod = nr;
-
+	if (cfg->init)
+		cfg->init(state);
 	return &state->fe;
 fail:
 	kfree(state);

commit 84409a95bbae75c5396c6db9ac43f1d1626d6b75
Author: Daniel Scheller <d.scheller@gmx.net>
Date:   Sat Jun 23 11:36:10 2018 -0400

    media: ddbridge/mci: make ddb_mci_cmd() and ddb_mci_config() public
    
    In preparation for splitting all MaxSX8 related code parts from the common
    MCI code, prefix both mci_cmd() and mci_config() functions with ddb_,
    remove the static marking and add matching function prototypes to
    ddbridge-mci.h so these functions can be reused from other files within
    the ddbridge driver. As this requires the mci-related structs to be
    defined in ddbridge-mci.h, move struct mci and struct mci_base there and
    clean them up.
    
    Picked up from the upstream dddvb GIT.
    
    Signed-off-by: Daniel Scheller <d.scheller@gmx.net>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/pci/ddbridge/ddbridge-mci.c b/drivers/media/pci/ddbridge/ddbridge-mci.c
index fa0d7d0cc6f6..a29ff25d9029 100644
--- a/drivers/media/pci/ddbridge/ddbridge-mci.c
+++ b/drivers/media/pci/ddbridge/ddbridge-mci.c
@@ -26,38 +26,6 @@ static const u32 MCLK = (1550000000 / 12);
 static const u32 MAX_DEMOD_LDPC_BITRATE = (1550000000 / 6);
 static const u32 MAX_LDPC_BITRATE = (720000000);
 
-struct mci_base {
-	struct list_head     mci_list;
-	void                *key;
-	struct ddb_link     *link;
-	struct completion    completion;
-
-	struct device       *dev;
-	struct mutex         tuner_lock; /* concurrent tuner access lock */
-	u8                   adr;
-	struct mutex         mci_lock; /* concurrent MCI access lock */
-	int                  count;
-
-	u8                   tuner_use_count[MCI_TUNER_MAX];
-	u8                   assigned_demod[MCI_DEMOD_MAX];
-	u32                  used_ldpc_bitrate[MCI_DEMOD_MAX];
-	u8                   demod_in_use[MCI_DEMOD_MAX];
-	u32                  iq_mode;
-};
-
-struct mci {
-	struct mci_base     *base;
-	struct dvb_frontend  fe;
-	int                  nr;
-	int                  demod;
-	int                  tuner;
-	int                  first_time_lock;
-	int                  started;
-	struct mci_result    signal_info;
-
-	u32                  bb_mode;
-};
-
 static int mci_reset(struct mci *state)
 {
 	struct ddb_link *link = state->base->link;
@@ -84,7 +52,7 @@ static int mci_reset(struct mci *state)
 	return 0;
 }
 
-static int mci_config(struct mci *state, u32 config)
+int ddb_mci_config(struct mci *state, u32 config)
 {
 	struct ddb_link *link = state->base->link;
 
@@ -122,9 +90,9 @@ static int _mci_cmd_unlocked(struct mci *state,
 	return 0;
 }
 
-static int mci_cmd(struct mci *state,
-		   struct mci_command *command,
-		   struct mci_result *result)
+int ddb_mci_cmd(struct mci *state,
+		struct mci_command *command,
+		struct mci_result *result)
 {
 	int stat;
 
@@ -164,7 +132,7 @@ static int get_info(struct dvb_frontend *fe)
 	memset(&cmd, 0, sizeof(cmd));
 	cmd.command = MCI_CMD_GETSIGNALINFO;
 	cmd.demod = state->demod;
-	stat = mci_cmd(state, &cmd, &state->signal_info);
+	stat = ddb_mci_cmd(state, &cmd, &state->signal_info);
 	return stat;
 }
 
@@ -205,7 +173,7 @@ static int read_status(struct dvb_frontend *fe, enum fe_status *status)
 
 	cmd.command = MCI_CMD_GETSTATUS;
 	cmd.demod = state->demod;
-	stat = mci_cmd(state, &cmd, &res);
+	stat = ddb_mci_cmd(state, &cmd, &res);
 	if (stat)
 		return stat;
 	*status = 0x00;
@@ -228,7 +196,7 @@ static int mci_set_tuner(struct dvb_frontend *fe, u32 tuner, u32 on)
 	memset(&cmd, 0, sizeof(cmd));
 	cmd.tuner = state->tuner;
 	cmd.command = on ? SX8_CMD_INPUT_ENABLE : SX8_CMD_INPUT_DISABLE;
-	return mci_cmd(state, &cmd, NULL);
+	return ddb_mci_cmd(state, &cmd, NULL);
 }
 
 static int stop(struct dvb_frontend *fe)
@@ -241,13 +209,13 @@ static int stop(struct dvb_frontend *fe)
 	if (state->demod != DEMOD_UNUSED) {
 		cmd.command = MCI_CMD_STOP;
 		cmd.demod = state->demod;
-		mci_cmd(state, &cmd, NULL);
+		ddb_mci_cmd(state, &cmd, NULL);
 		if (state->base->iq_mode) {
 			cmd.command = MCI_CMD_STOP;
 			cmd.demod = state->demod;
 			cmd.output = 0;
-			mci_cmd(state, &cmd, NULL);
-			mci_config(state, SX8_TSCONFIG_MODE_NORMAL);
+			ddb_mci_cmd(state, &cmd, NULL);
+			ddb_mci_config(state, SX8_TSCONFIG_MODE_NORMAL);
 		}
 	}
 	mutex_lock(&state->base->tuner_lock);
@@ -345,8 +313,8 @@ static int start(struct dvb_frontend *fe, u32 flags, u32 modmask, u32 ts_config)
 		cmd.command = SX8_CMD_ENABLE_IQOUTPUT;
 		cmd.demod = state->demod;
 		cmd.output = 0;
-		mci_cmd(state, &cmd, NULL);
-		mci_config(state, ts_config);
+		ddb_mci_cmd(state, &cmd, NULL);
+		ddb_mci_config(state, ts_config);
 	}
 	if (p->stream_id != NO_STREAM_ID_FILTER && p->stream_id != 0x80000000)
 		flags |= 0x80;
@@ -368,7 +336,7 @@ static int start(struct dvb_frontend *fe, u32 flags, u32 modmask, u32 ts_config)
 	cmd.output = state->nr;
 	if (p->stream_id == 0x80000000)
 		cmd.output |= 0x80;
-	stat = mci_cmd(state, &cmd, NULL);
+	stat = ddb_mci_cmd(state, &cmd, NULL);
 	if (stat)
 		stop(fe);
 	return stat;
@@ -413,8 +381,8 @@ static int start_iq(struct dvb_frontend *fe, u32 ts_config)
 	cmd.tuner = state->tuner;
 	cmd.demod = state->demod;
 	cmd.output = 7;
-	mci_config(state, ts_config);
-	stat = mci_cmd(state, &cmd, NULL);
+	ddb_mci_config(state, ts_config);
+	stat = ddb_mci_cmd(state, &cmd, NULL);
 	if (stat)
 		stop(fe);
 	return stat;

commit 9b28ba016fc4a387ffefccbc6c390af3fdf37eb9
Author: Daniel Scheller <d.scheller@gmx.net>
Date:   Sat Jun 23 11:36:07 2018 -0400

    media: ddbridge/mci: rename defines and fix i/q var types
    
    Adjustments to match the FPGA firmware, and the signal I/Q values are
    reported as s16 types from the card firmware.
    
    Picked up from the upstream dddvb GIT.
    
    Signed-off-by: Daniel Scheller <d.scheller@gmx.net>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/pci/ddbridge/ddbridge-mci.c b/drivers/media/pci/ddbridge/ddbridge-mci.c
index 7d402861fa9e..fa0d7d0cc6f6 100644
--- a/drivers/media/pci/ddbridge/ddbridge-mci.c
+++ b/drivers/media/pci/ddbridge/ddbridge-mci.c
@@ -342,7 +342,7 @@ static int start(struct dvb_frontend *fe, u32 flags, u32 modmask, u32 ts_config)
 	memset(&cmd, 0, sizeof(cmd));
 
 	if (state->base->iq_mode) {
-		cmd.command = SX8_CMD_SELECT_IQOUT;
+		cmd.command = SX8_CMD_ENABLE_IQOUTPUT;
 		cmd.demod = state->demod;
 		cmd.output = 0;
 		mci_cmd(state, &cmd, NULL);

commit 3c7d591121c3f5cb97abb9c5dd2a9c2bd8532674
Author: Daniel Scheller <d.scheller@gmx.net>
Date:   Sat Jun 23 11:36:06 2018 -0400

    media: ddbridge/mci: read and report signal strength and SNR
    
    Implement querying signal statistics from the MCI and report this data
    in read_status() as DVBv5 statistics.
    
    Picked up from the upstream dddvb GIT.
    
    Signed-off-by: Daniel Scheller <d.scheller@gmx.net>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/pci/ddbridge/ddbridge-mci.c b/drivers/media/pci/ddbridge/ddbridge-mci.c
index 46b20b06e2a6..7d402861fa9e 100644
--- a/drivers/media/pci/ddbridge/ddbridge-mci.c
+++ b/drivers/media/pci/ddbridge/ddbridge-mci.c
@@ -155,6 +155,47 @@ static void release(struct dvb_frontend *fe)
 	kfree(state);
 }
 
+static int get_info(struct dvb_frontend *fe)
+{
+	int stat;
+	struct mci *state = fe->demodulator_priv;
+	struct mci_command cmd;
+
+	memset(&cmd, 0, sizeof(cmd));
+	cmd.command = MCI_CMD_GETSIGNALINFO;
+	cmd.demod = state->demod;
+	stat = mci_cmd(state, &cmd, &state->signal_info);
+	return stat;
+}
+
+static int get_snr(struct dvb_frontend *fe)
+{
+	struct mci *state = fe->demodulator_priv;
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+
+	p->cnr.len = 1;
+	p->cnr.stat[0].scale = FE_SCALE_DECIBEL;
+	p->cnr.stat[0].svalue =
+		(s64)state->signal_info.dvbs2_signal_info.signal_to_noise
+		     * 10;
+	return 0;
+}
+
+static int get_strength(struct dvb_frontend *fe)
+{
+	struct mci *state = fe->demodulator_priv;
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+	s32 str;
+
+	str = 100000 -
+	      (state->signal_info.dvbs2_signal_info.channel_power
+	       * 10 + 108750);
+	p->strength.len = 1;
+	p->strength.stat[0].scale = FE_SCALE_DECIBEL;
+	p->strength.stat[0].svalue = str;
+	return 0;
+}
+
 static int read_status(struct dvb_frontend *fe, enum fe_status *status)
 {
 	int stat;
@@ -168,10 +209,14 @@ static int read_status(struct dvb_frontend *fe, enum fe_status *status)
 	if (stat)
 		return stat;
 	*status = 0x00;
+	get_info(fe);
+	get_strength(fe);
 	if (res.status == SX8_DEMOD_WAIT_MATYPE)
 		*status = 0x0f;
-	if (res.status == SX8_DEMOD_LOCKED)
+	if (res.status == SX8_DEMOD_LOCKED) {
 		*status = 0x1f;
+		get_snr(fe);
+	}
 	return stat;
 }
 

commit 3addf0fa820b3da34e0c0e532167afcee8089a3b
Author: Daniel Scheller <d.scheller@gmx.net>
Date:   Sat Jun 23 11:36:05 2018 -0400

    media: ddbridge/mci: update copyright year in headers
    
    Update the copyright year information in the MCI headers to 2017-2018.
    
    Picked up from the upstream dddvb GIT.
    
    Signed-off-by: Daniel Scheller <d.scheller@gmx.net>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/pci/ddbridge/ddbridge-mci.c b/drivers/media/pci/ddbridge/ddbridge-mci.c
index 4ac634fc96e4..46b20b06e2a6 100644
--- a/drivers/media/pci/ddbridge/ddbridge-mci.c
+++ b/drivers/media/pci/ddbridge/ddbridge-mci.c
@@ -2,9 +2,9 @@
 /*
  * ddbridge-mci.c: Digital Devices microcode interface
  *
- * Copyright (C) 2017 Digital Devices GmbH
- *                    Ralph Metzler <rjkm@metzlerbros.de>
- *                    Marcus Metzler <mocm@metzlerbros.de>
+ * Copyright (C) 2017-2018 Digital Devices GmbH
+ *                         Ralph Metzler <rjkm@metzlerbros.de>
+ *                         Marcus Metzler <mocm@metzlerbros.de>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License

commit caf2827cfe546ae2fbc27641c619be57c23d2a9b
Author: Daniel Scheller <d.scheller@gmx.net>
Date:   Wed May 9 16:08:01 2018 -0400

    media: ddbridge/mci: add identifiers to function definition arguments
    
    Fixes two checkpatch warnings
    
      WARNING: function definition argument 'xxx' should also have an identifier name
    
    in the ddb_mci_attach() prototype definition. checkpatch keeps complaining
    on the "int (**fn_set_input)" as it seems to have issues with the
    ptr-to-ptr, though this probably needs fixing in checkpatch.
    
    Signed-off-by: Daniel Scheller <d.scheller@gmx.net>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/pci/ddbridge/ddbridge-mci.c b/drivers/media/pci/ddbridge/ddbridge-mci.c
index 8d9592e75ad5..4ac634fc96e4 100644
--- a/drivers/media/pci/ddbridge/ddbridge-mci.c
+++ b/drivers/media/pci/ddbridge/ddbridge-mci.c
@@ -500,7 +500,7 @@ static int probe(struct mci *state)
 struct dvb_frontend
 *ddb_mci_attach(struct ddb_input *input,
 		int mci_type, int nr,
-		int (**fn_set_input)(struct dvb_frontend *, int))
+		int (**fn_set_input)(struct dvb_frontend *fe, int input))
 {
 	struct ddb_port *port = input->port;
 	struct ddb *dev = port->dev;

commit 525cac75740542e23c31cd0f248f9b29ae4978e9
Author: Daniel Scheller <d.scheller@gmx.net>
Date:   Wed May 9 16:08:00 2018 -0400

    media: ddbridge/mci: protect against out-of-bounds array access in stop()
    
    In stop(), an (unlikely) out-of-bounds write error can occur when setting
    the demod_in_use element indexed by state->demod to zero, as state->demod
    isn't checked for being in the range of the array size of demod_in_use, and
    state->demod maybe carrying the magic 0xff (demod unused) value. Prevent
    this by checking state->demod not exceeding the array size before setting
    the element value. To make the code a bit easier to read, replace the magic
    value and the number of array elements with defines, and use them at a few
    more places.
    
    Detected by CoverityScan, CID#1468550 ("Out-of-bounds write")
    
    Thanks to Colin for reporting the problem and providing an initial patch.
    
    Fixes: daeeb1319e6f ("media: ddbridge: initial support for MCI-based MaxSX8 cards")
    
    Reported-by: Colin Ian King <colin.king@canonical.com>
    Cc: Ralph Metzler <rjkm@metzlerbros.de>
    Signed-off-by: Daniel Scheller <d.scheller@gmx.net>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/pci/ddbridge/ddbridge-mci.c b/drivers/media/pci/ddbridge/ddbridge-mci.c
index a85ff3e6b919..8d9592e75ad5 100644
--- a/drivers/media/pci/ddbridge/ddbridge-mci.c
+++ b/drivers/media/pci/ddbridge/ddbridge-mci.c
@@ -38,10 +38,10 @@ struct mci_base {
 	struct mutex         mci_lock; /* concurrent MCI access lock */
 	int                  count;
 
-	u8                   tuner_use_count[4];
-	u8                   assigned_demod[8];
-	u32                  used_ldpc_bitrate[8];
-	u8                   demod_in_use[8];
+	u8                   tuner_use_count[MCI_TUNER_MAX];
+	u8                   assigned_demod[MCI_DEMOD_MAX];
+	u32                  used_ldpc_bitrate[MCI_DEMOD_MAX];
+	u8                   demod_in_use[MCI_DEMOD_MAX];
 	u32                  iq_mode;
 };
 
@@ -193,7 +193,7 @@ static int stop(struct dvb_frontend *fe)
 	u32 input = state->tuner;
 
 	memset(&cmd, 0, sizeof(cmd));
-	if (state->demod != 0xff) {
+	if (state->demod != DEMOD_UNUSED) {
 		cmd.command = MCI_CMD_STOP;
 		cmd.demod = state->demod;
 		mci_cmd(state, &cmd, NULL);
@@ -209,10 +209,11 @@ static int stop(struct dvb_frontend *fe)
 	state->base->tuner_use_count[input]--;
 	if (!state->base->tuner_use_count[input])
 		mci_set_tuner(fe, input, 0);
-	state->base->demod_in_use[state->demod] = 0;
+	if (state->demod < MCI_DEMOD_MAX)
+		state->base->demod_in_use[state->demod] = 0;
 	state->base->used_ldpc_bitrate[state->nr] = 0;
-	state->demod = 0xff;
-	state->base->assigned_demod[state->nr] = 0xff;
+	state->demod = DEMOD_UNUSED;
+	state->base->assigned_demod[state->nr] = DEMOD_UNUSED;
 	state->base->iq_mode = 0;
 	mutex_unlock(&state->base->tuner_lock);
 	state->started = 0;
@@ -250,7 +251,7 @@ static int start(struct dvb_frontend *fe, u32 flags, u32 modmask, u32 ts_config)
 		stat = -EBUSY;
 		goto unlock;
 	}
-	for (i = 0; i < 8; i++) {
+	for (i = 0; i < MCI_DEMOD_MAX; i++) {
 		used_ldpc_bitrate += state->base->used_ldpc_bitrate[i];
 		if (state->base->demod_in_use[i])
 			used_demods++;
@@ -342,7 +343,7 @@ static int start_iq(struct dvb_frontend *fe, u32 ts_config)
 		stat = -EBUSY;
 		goto unlock;
 	}
-	for (i = 0; i < 8; i++)
+	for (i = 0; i < MCI_DEMOD_MAX; i++)
 		if (state->base->demod_in_use[i])
 			used_demods++;
 	if (used_demods > 0) {

commit 8d718e5376c602dfd41b599dcc2a7b1be07c7b6b
Author: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
Date:   Tue Apr 24 09:19:18 2018 -0400

    media: frontends: fix ops get_algo()'s return type
    
    The method dvb_frontend_ops::get_frontend_algo() is defined as
    returning an 'enum dvbfe_algo', but the implementation in this
    driver returns an 'int'.
    
    Fix this by returning 'enum dvbfe_algo' on drivers.
    
    [mchehab+samsung@kernel.org: merge similar patches and patch
     ddbridge-mci.c the same way]
    Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/pci/ddbridge/ddbridge-mci.c b/drivers/media/pci/ddbridge/ddbridge-mci.c
index 214b301f30a5..a85ff3e6b919 100644
--- a/drivers/media/pci/ddbridge/ddbridge-mci.c
+++ b/drivers/media/pci/ddbridge/ddbridge-mci.c
@@ -444,7 +444,7 @@ static int tune(struct dvb_frontend *fe, bool re_tune,
 	return 0;
 }
 
-static int get_algo(struct dvb_frontend *fe)
+static enum dvbfe_algo get_algo(struct dvb_frontend *fe)
 {
 	return DVBFE_ALGO_HW;
 }

commit daeeb1319e6f42eee15aad3320a14389b4e35e04
Author: Daniel Scheller <d.scheller@gmx.net>
Date:   Mon Apr 9 12:47:48 2018 -0400

    media: ddbridge: initial support for MCI-based MaxSX8 cards
    
    This adds initial support for the new MCI-based (micro-code interface)
    DD cards, with the first one being the MaxSX8 eight-tuner DVB-S/S2/S2X
    PCIe card. The MCI is basically a generalized interface implemented in
    the card's FPGA firmware and usable for all kind of cards, without the
    need to implement any demod/tuner drivers as this interface "hides" any
    I2C interface to the actual ICs, in other words any required driver is
    implemented in the card firmware.
    
    At this stage, the MCI interface is quite rudimentary with things like
    signal statistics reporting missing, but is already working to serve
    DVB streams to DVB applications. Missing functionality will be enabled
    over time.
    
    This implements only the ddbridge-mci sub-object and hooks it up to the
    Makefile so the object gets build. The upcoming commits hook this module
    into all other ddbridge parts where required, including device IDs etc.
    
    Picked up from the upstream dddvb-0.9.33 release.
    
    Signed-off-by: Daniel Scheller <d.scheller@gmx.net>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/pci/ddbridge/ddbridge-mci.c b/drivers/media/pci/ddbridge/ddbridge-mci.c
new file mode 100644
index 000000000000..214b301f30a5
--- /dev/null
+++ b/drivers/media/pci/ddbridge/ddbridge-mci.c
@@ -0,0 +1,550 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * ddbridge-mci.c: Digital Devices microcode interface
+ *
+ * Copyright (C) 2017 Digital Devices GmbH
+ *                    Ralph Metzler <rjkm@metzlerbros.de>
+ *                    Marcus Metzler <mocm@metzlerbros.de>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 only, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#include "ddbridge.h"
+#include "ddbridge-io.h"
+#include "ddbridge-mci.h"
+
+static LIST_HEAD(mci_list);
+
+static const u32 MCLK = (1550000000 / 12);
+static const u32 MAX_DEMOD_LDPC_BITRATE = (1550000000 / 6);
+static const u32 MAX_LDPC_BITRATE = (720000000);
+
+struct mci_base {
+	struct list_head     mci_list;
+	void                *key;
+	struct ddb_link     *link;
+	struct completion    completion;
+
+	struct device       *dev;
+	struct mutex         tuner_lock; /* concurrent tuner access lock */
+	u8                   adr;
+	struct mutex         mci_lock; /* concurrent MCI access lock */
+	int                  count;
+
+	u8                   tuner_use_count[4];
+	u8                   assigned_demod[8];
+	u32                  used_ldpc_bitrate[8];
+	u8                   demod_in_use[8];
+	u32                  iq_mode;
+};
+
+struct mci {
+	struct mci_base     *base;
+	struct dvb_frontend  fe;
+	int                  nr;
+	int                  demod;
+	int                  tuner;
+	int                  first_time_lock;
+	int                  started;
+	struct mci_result    signal_info;
+
+	u32                  bb_mode;
+};
+
+static int mci_reset(struct mci *state)
+{
+	struct ddb_link *link = state->base->link;
+	u32 status = 0;
+	u32 timeout = 40;
+
+	ddblwritel(link, MCI_CONTROL_RESET, MCI_CONTROL);
+	ddblwritel(link, 0, MCI_CONTROL + 4); /* 1= no internal init */
+	msleep(300);
+	ddblwritel(link, 0, MCI_CONTROL);
+
+	while (1) {
+		status = ddblreadl(link, MCI_CONTROL);
+		if ((status & MCI_CONTROL_READY) == MCI_CONTROL_READY)
+			break;
+		if (--timeout == 0)
+			break;
+		msleep(50);
+	}
+	if ((status & MCI_CONTROL_READY) == 0)
+		return -1;
+	if (link->ids.device == 0x0009)
+		ddblwritel(link, SX8_TSCONFIG_MODE_NORMAL, SX8_TSCONFIG);
+	return 0;
+}
+
+static int mci_config(struct mci *state, u32 config)
+{
+	struct ddb_link *link = state->base->link;
+
+	if (link->ids.device != 0x0009)
+		return -EINVAL;
+	ddblwritel(link, config, SX8_TSCONFIG);
+	return 0;
+}
+
+static int _mci_cmd_unlocked(struct mci *state,
+			     u32 *cmd, u32 cmd_len,
+			     u32 *res, u32 res_len)
+{
+	struct ddb_link *link = state->base->link;
+	u32 i, val;
+	unsigned long stat;
+
+	val = ddblreadl(link, MCI_CONTROL);
+	if (val & (MCI_CONTROL_RESET | MCI_CONTROL_START_COMMAND))
+		return -EIO;
+	if (cmd && cmd_len)
+		for (i = 0; i < cmd_len; i++)
+			ddblwritel(link, cmd[i], MCI_COMMAND + i * 4);
+	val |= (MCI_CONTROL_START_COMMAND | MCI_CONTROL_ENABLE_DONE_INTERRUPT);
+	ddblwritel(link, val, MCI_CONTROL);
+
+	stat = wait_for_completion_timeout(&state->base->completion, HZ);
+	if (stat == 0) {
+		dev_warn(state->base->dev, "MCI-%d: MCI timeout\n", state->nr);
+		return -EIO;
+	}
+	if (res && res_len)
+		for (i = 0; i < res_len; i++)
+			res[i] = ddblreadl(link, MCI_RESULT + i * 4);
+	return 0;
+}
+
+static int mci_cmd(struct mci *state,
+		   struct mci_command *command,
+		   struct mci_result *result)
+{
+	int stat;
+
+	mutex_lock(&state->base->mci_lock);
+	stat = _mci_cmd_unlocked(state,
+				 (u32 *)command, sizeof(*command) / sizeof(u32),
+				 (u32 *)result, sizeof(*result) / sizeof(u32));
+	mutex_unlock(&state->base->mci_lock);
+	return stat;
+}
+
+static void mci_handler(void *priv)
+{
+	struct mci_base *base = (struct mci_base *)priv;
+
+	complete(&base->completion);
+}
+
+static void release(struct dvb_frontend *fe)
+{
+	struct mci *state = fe->demodulator_priv;
+
+	state->base->count--;
+	if (state->base->count == 0) {
+		list_del(&state->base->mci_list);
+		kfree(state->base);
+	}
+	kfree(state);
+}
+
+static int read_status(struct dvb_frontend *fe, enum fe_status *status)
+{
+	int stat;
+	struct mci *state = fe->demodulator_priv;
+	struct mci_command cmd;
+	struct mci_result res;
+
+	cmd.command = MCI_CMD_GETSTATUS;
+	cmd.demod = state->demod;
+	stat = mci_cmd(state, &cmd, &res);
+	if (stat)
+		return stat;
+	*status = 0x00;
+	if (res.status == SX8_DEMOD_WAIT_MATYPE)
+		*status = 0x0f;
+	if (res.status == SX8_DEMOD_LOCKED)
+		*status = 0x1f;
+	return stat;
+}
+
+static int mci_set_tuner(struct dvb_frontend *fe, u32 tuner, u32 on)
+{
+	struct mci *state = fe->demodulator_priv;
+	struct mci_command cmd;
+
+	memset(&cmd, 0, sizeof(cmd));
+	cmd.tuner = state->tuner;
+	cmd.command = on ? SX8_CMD_INPUT_ENABLE : SX8_CMD_INPUT_DISABLE;
+	return mci_cmd(state, &cmd, NULL);
+}
+
+static int stop(struct dvb_frontend *fe)
+{
+	struct mci *state = fe->demodulator_priv;
+	struct mci_command cmd;
+	u32 input = state->tuner;
+
+	memset(&cmd, 0, sizeof(cmd));
+	if (state->demod != 0xff) {
+		cmd.command = MCI_CMD_STOP;
+		cmd.demod = state->demod;
+		mci_cmd(state, &cmd, NULL);
+		if (state->base->iq_mode) {
+			cmd.command = MCI_CMD_STOP;
+			cmd.demod = state->demod;
+			cmd.output = 0;
+			mci_cmd(state, &cmd, NULL);
+			mci_config(state, SX8_TSCONFIG_MODE_NORMAL);
+		}
+	}
+	mutex_lock(&state->base->tuner_lock);
+	state->base->tuner_use_count[input]--;
+	if (!state->base->tuner_use_count[input])
+		mci_set_tuner(fe, input, 0);
+	state->base->demod_in_use[state->demod] = 0;
+	state->base->used_ldpc_bitrate[state->nr] = 0;
+	state->demod = 0xff;
+	state->base->assigned_demod[state->nr] = 0xff;
+	state->base->iq_mode = 0;
+	mutex_unlock(&state->base->tuner_lock);
+	state->started = 0;
+	return 0;
+}
+
+static int start(struct dvb_frontend *fe, u32 flags, u32 modmask, u32 ts_config)
+{
+	struct mci *state = fe->demodulator_priv;
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+	u32 used_ldpc_bitrate = 0, free_ldpc_bitrate;
+	u32 used_demods = 0;
+	struct mci_command cmd;
+	u32 input = state->tuner;
+	u32 bits_per_symbol = 0;
+	int i, stat = 0;
+
+	if (p->symbol_rate >= (MCLK / 2))
+		flags &= ~1;
+	if ((flags & 3) == 0)
+		return -EINVAL;
+
+	if (flags & 2) {
+		u32 tmp = modmask;
+
+		bits_per_symbol = 1;
+		while (tmp & 1) {
+			tmp >>= 1;
+			bits_per_symbol++;
+		}
+	}
+
+	mutex_lock(&state->base->tuner_lock);
+	if (state->base->iq_mode) {
+		stat = -EBUSY;
+		goto unlock;
+	}
+	for (i = 0; i < 8; i++) {
+		used_ldpc_bitrate += state->base->used_ldpc_bitrate[i];
+		if (state->base->demod_in_use[i])
+			used_demods++;
+	}
+	if (used_ldpc_bitrate >= MAX_LDPC_BITRATE ||
+	    ((ts_config & SX8_TSCONFIG_MODE_MASK) >
+	     SX8_TSCONFIG_MODE_NORMAL && used_demods > 0)) {
+		stat = -EBUSY;
+		goto unlock;
+	}
+	free_ldpc_bitrate = MAX_LDPC_BITRATE - used_ldpc_bitrate;
+	if (free_ldpc_bitrate > MAX_DEMOD_LDPC_BITRATE)
+		free_ldpc_bitrate = MAX_DEMOD_LDPC_BITRATE;
+
+	while (p->symbol_rate * bits_per_symbol > free_ldpc_bitrate)
+		bits_per_symbol--;
+
+	if (bits_per_symbol < 2) {
+		stat = -EBUSY;
+		goto unlock;
+	}
+	i = (p->symbol_rate > (MCLK / 2)) ? 3 : 7;
+	while (i >= 0 && state->base->demod_in_use[i])
+		i--;
+	if (i < 0) {
+		stat = -EBUSY;
+		goto unlock;
+	}
+	state->base->demod_in_use[i] = 1;
+	state->base->used_ldpc_bitrate[state->nr] = p->symbol_rate
+						    * bits_per_symbol;
+	state->demod = i;
+	state->base->assigned_demod[state->nr] = i;
+
+	if (!state->base->tuner_use_count[input])
+		mci_set_tuner(fe, input, 1);
+	state->base->tuner_use_count[input]++;
+	state->base->iq_mode = (ts_config > 1);
+unlock:
+	mutex_unlock(&state->base->tuner_lock);
+	if (stat)
+		return stat;
+	memset(&cmd, 0, sizeof(cmd));
+
+	if (state->base->iq_mode) {
+		cmd.command = SX8_CMD_SELECT_IQOUT;
+		cmd.demod = state->demod;
+		cmd.output = 0;
+		mci_cmd(state, &cmd, NULL);
+		mci_config(state, ts_config);
+	}
+	if (p->stream_id != NO_STREAM_ID_FILTER && p->stream_id != 0x80000000)
+		flags |= 0x80;
+	dev_dbg(state->base->dev, "MCI-%d: tuner=%d demod=%d\n",
+		state->nr, state->tuner, state->demod);
+	cmd.command = MCI_CMD_SEARCH_DVBS;
+	cmd.dvbs2_search.flags = flags;
+	cmd.dvbs2_search.s2_modulation_mask =
+		modmask & ((1 << (bits_per_symbol - 1)) - 1);
+	cmd.dvbs2_search.retry = 2;
+	cmd.dvbs2_search.frequency = p->frequency * 1000;
+	cmd.dvbs2_search.symbol_rate = p->symbol_rate;
+	cmd.dvbs2_search.scrambling_sequence_index =
+		p->scrambling_sequence_index;
+	cmd.dvbs2_search.input_stream_id =
+		(p->stream_id != NO_STREAM_ID_FILTER) ? p->stream_id : 0;
+	cmd.tuner = state->tuner;
+	cmd.demod = state->demod;
+	cmd.output = state->nr;
+	if (p->stream_id == 0x80000000)
+		cmd.output |= 0x80;
+	stat = mci_cmd(state, &cmd, NULL);
+	if (stat)
+		stop(fe);
+	return stat;
+}
+
+static int start_iq(struct dvb_frontend *fe, u32 ts_config)
+{
+	struct mci *state = fe->demodulator_priv;
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+	u32 used_demods = 0;
+	struct mci_command cmd;
+	u32 input = state->tuner;
+	int i, stat = 0;
+
+	mutex_lock(&state->base->tuner_lock);
+	if (state->base->iq_mode) {
+		stat = -EBUSY;
+		goto unlock;
+	}
+	for (i = 0; i < 8; i++)
+		if (state->base->demod_in_use[i])
+			used_demods++;
+	if (used_demods > 0) {
+		stat = -EBUSY;
+		goto unlock;
+	}
+	state->demod = 0;
+	state->base->assigned_demod[state->nr] = 0;
+	if (!state->base->tuner_use_count[input])
+		mci_set_tuner(fe, input, 1);
+	state->base->tuner_use_count[input]++;
+	state->base->iq_mode = (ts_config > 1);
+unlock:
+	mutex_unlock(&state->base->tuner_lock);
+	if (stat)
+		return stat;
+
+	memset(&cmd, 0, sizeof(cmd));
+	cmd.command = SX8_CMD_START_IQ;
+	cmd.dvbs2_search.frequency = p->frequency * 1000;
+	cmd.dvbs2_search.symbol_rate = p->symbol_rate;
+	cmd.tuner = state->tuner;
+	cmd.demod = state->demod;
+	cmd.output = 7;
+	mci_config(state, ts_config);
+	stat = mci_cmd(state, &cmd, NULL);
+	if (stat)
+		stop(fe);
+	return stat;
+}
+
+static int set_parameters(struct dvb_frontend *fe)
+{
+	int stat = 0;
+	struct mci *state = fe->demodulator_priv;
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+	u32 ts_config, iq_mode = 0, isi;
+
+	if (state->started)
+		stop(fe);
+
+	isi = p->stream_id;
+	if (isi != NO_STREAM_ID_FILTER)
+		iq_mode = (isi & 0x30000000) >> 28;
+
+	switch (iq_mode) {
+	case 1:
+		ts_config = (SX8_TSCONFIG_TSHEADER | SX8_TSCONFIG_MODE_IQ);
+		break;
+	case 2:
+		ts_config = (SX8_TSCONFIG_TSHEADER | SX8_TSCONFIG_MODE_IQ);
+		break;
+	default:
+		ts_config = SX8_TSCONFIG_MODE_NORMAL;
+		break;
+	}
+
+	if (iq_mode != 2) {
+		u32 flags = 3;
+		u32 mask = 3;
+
+		if (p->modulation == APSK_16 ||
+		    p->modulation == APSK_32) {
+			flags = 2;
+			mask = 15;
+		}
+		stat = start(fe, flags, mask, ts_config);
+	} else {
+		stat = start_iq(fe, ts_config);
+	}
+
+	if (!stat) {
+		state->started = 1;
+		state->first_time_lock = 1;
+		state->signal_info.status = SX8_DEMOD_WAIT_SIGNAL;
+	}
+
+	return stat;
+}
+
+static int tune(struct dvb_frontend *fe, bool re_tune,
+		unsigned int mode_flags,
+		unsigned int *delay, enum fe_status *status)
+{
+	int r;
+
+	if (re_tune) {
+		r = set_parameters(fe);
+		if (r)
+			return r;
+	}
+	r = read_status(fe, status);
+	if (r)
+		return r;
+
+	if (*status & FE_HAS_LOCK)
+		return 0;
+	*delay = HZ / 10;
+	return 0;
+}
+
+static int get_algo(struct dvb_frontend *fe)
+{
+	return DVBFE_ALGO_HW;
+}
+
+static int set_input(struct dvb_frontend *fe, int input)
+{
+	struct mci *state = fe->demodulator_priv;
+
+	state->tuner = input;
+	dev_dbg(state->base->dev, "MCI-%d: input=%d\n", state->nr, input);
+	return 0;
+}
+
+static struct dvb_frontend_ops mci_ops = {
+	.delsys = { SYS_DVBS, SYS_DVBS2 },
+	.info = {
+		.name			= "Digital Devices MaxSX8 MCI DVB-S/S2/S2X",
+		.frequency_min		= 950000,
+		.frequency_max		= 2150000,
+		.frequency_stepsize	= 0,
+		.frequency_tolerance	= 0,
+		.symbol_rate_min	= 100000,
+		.symbol_rate_max	= 100000000,
+		.caps			= FE_CAN_INVERSION_AUTO |
+					  FE_CAN_FEC_AUTO       |
+					  FE_CAN_QPSK           |
+					  FE_CAN_2G_MODULATION  |
+					  FE_CAN_MULTISTREAM,
+	},
+	.get_frontend_algo		= get_algo,
+	.tune				= tune,
+	.release			= release,
+	.read_status			= read_status,
+};
+
+static struct mci_base *match_base(void *key)
+{
+	struct mci_base *p;
+
+	list_for_each_entry(p, &mci_list, mci_list)
+		if (p->key == key)
+			return p;
+	return NULL;
+}
+
+static int probe(struct mci *state)
+{
+	mci_reset(state);
+	return 0;
+}
+
+struct dvb_frontend
+*ddb_mci_attach(struct ddb_input *input,
+		int mci_type, int nr,
+		int (**fn_set_input)(struct dvb_frontend *, int))
+{
+	struct ddb_port *port = input->port;
+	struct ddb *dev = port->dev;
+	struct ddb_link *link = &dev->link[port->lnr];
+	struct mci_base *base;
+	struct mci *state;
+	void *key = mci_type ? (void *)port : (void *)link;
+
+	state = kzalloc(sizeof(*state), GFP_KERNEL);
+	if (!state)
+		return NULL;
+
+	base = match_base(key);
+	if (base) {
+		base->count++;
+		state->base = base;
+	} else {
+		base = kzalloc(sizeof(*base), GFP_KERNEL);
+		if (!base)
+			goto fail;
+		base->key = key;
+		base->count = 1;
+		base->link = link;
+		base->dev = dev->dev;
+		mutex_init(&base->mci_lock);
+		mutex_init(&base->tuner_lock);
+		ddb_irq_set(dev, link->nr, 0, mci_handler, base);
+		init_completion(&base->completion);
+		state->base = base;
+		if (probe(state) < 0) {
+			kfree(base);
+			goto fail;
+		}
+		list_add(&base->mci_list, &mci_list);
+	}
+	state->fe.ops = mci_ops;
+	state->fe.demodulator_priv = state;
+	state->nr = nr;
+	*fn_set_input = set_input;
+
+	state->tuner = nr;
+	state->demod = nr;
+
+	return &state->fe;
+fail:
+	kfree(state);
+	return NULL;
+}
