commit 1ccea77e2a2687cae171b7987eb44730ec8c6d5f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 15:51:43 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 13
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not see http www gnu org licenses
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details [based]
      [from] [clk] [highbank] [c] you should have received a copy of the
      gnu general public license along with this program if not see http
      www gnu org licenses
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 355 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Jilayne Lovejoy <opensource@jilayne.com>
    Reviewed-by: Steve Winslow <swinslow@gmail.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190519154041.837383322@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/media/common/siano/smsdvb-main.c b/drivers/media/common/siano/smsdvb-main.c
index 43cfd1dbda01..88f90dfd368b 100644
--- a/drivers/media/common/siano/smsdvb-main.c
+++ b/drivers/media/common/siano/smsdvb-main.c
@@ -1,21 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /****************************************************************
 
 Siano Mobile Silicon, Inc.
 MDTV receiver kernel modules.
 Copyright (C) 2006-2008, Uri Shkolnik
 
-This program is free software: you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation, either version 2 of the License, or
-(at your option) any later version.
-
- This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 ****************************************************************/
 

commit f1b1eabff0eb3fc46b06668de8174c0f23b271fd
Author: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
Date:   Thu Jul 5 18:59:36 2018 -0400

    media: dvb: represent min/max/step/tolerance freqs in Hz
    
    Right now, satellite frontend drivers specify frequencies in kHz,
    while terrestrial/cable ones specify in Hz. That's confusing
    for developers.
    
    However, the main problem is that universal frontends capable
    of handling both satellite and non-satelite delivery systems
    are appearing. We end by needing to hack the drivers in
    order to support such hybrid frontends.
    
    So, convert everything to specify frontend frequencies in Hz.
    
    Tested-by: Katsuhiro Suzuki <suzuki.katsuhiro@socionext.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/media/common/siano/smsdvb-main.c b/drivers/media/common/siano/smsdvb-main.c
index c0faad1ba428..43cfd1dbda01 100644
--- a/drivers/media/common/siano/smsdvb-main.c
+++ b/drivers/media/common/siano/smsdvb-main.c
@@ -1047,9 +1047,9 @@ static void smsdvb_release(struct dvb_frontend *fe)
 static const struct dvb_frontend_ops smsdvb_fe_ops = {
 	.info = {
 		.name			= "Siano Mobile Digital MDTV Receiver",
-		.frequency_min		= 44250000,
-		.frequency_max		= 867250000,
-		.frequency_stepsize	= 250000,
+		.frequency_min_hz	=  44250 * kHz,
+		.frequency_max_hz	= 867250 * kHz,
+		.frequency_stepsize_hz	=    250 * kHz,
 		.caps = FE_CAN_INVERSION_AUTO |
 			FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |
 			FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |

commit fada1935590f66dc6784981e0d557ca09013c847
Author: Mauro Carvalho Chehab <mchehab@s-opensource.com>
Date:   Thu Dec 28 13:03:51 2017 -0500

    media: move dvb kAPI headers to include/media
    
    Except for DVB, all media kAPI headers are at include/media.
    
    Move the headers to it.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/common/siano/smsdvb-main.c b/drivers/media/common/siano/smsdvb-main.c
index 166428cbd3c8..c0faad1ba428 100644
--- a/drivers/media/common/siano/smsdvb-main.c
+++ b/drivers/media/common/siano/smsdvb-main.c
@@ -26,10 +26,10 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include <linux/init.h>
 #include <asm/div64.h>
 
-#include "dmxdev.h"
-#include "dvbdev.h"
-#include "dvb_demux.h"
-#include "dvb_frontend.h"
+#include <media/dmxdev.h>
+#include <media/dvbdev.h>
+#include <media/dvb_demux.h>
+#include <media/dvb_frontend.h>
 
 #include "sms-cards.h"
 

commit 3ee6229f1a16ad80ac83f02614f46b70b7ecf666
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Tue Sep 19 21:09:18 2017 -0400

    media: siano: fix a potential integer overflow
    
    Add suffix ULL to constant 65535 in order to avoid a potential
    integer overflow. This constant is used in a context that
    expects an expression of type u64.
    
    Addresses-Coverity-ID: 1056806
    
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/common/siano/smsdvb-main.c b/drivers/media/common/siano/smsdvb-main.c
index affde1426b7a..166428cbd3c8 100644
--- a/drivers/media/common/siano/smsdvb-main.c
+++ b/drivers/media/common/siano/smsdvb-main.c
@@ -271,7 +271,7 @@ static void smsdvb_update_per_slices(struct smsdvb_client_t *client,
 	c->post_bit_count.stat[0].uvalue += p->ber_bit_count;
 
 	/* Legacy PER/BER */
-	tmp = p->ets_packets * 65535;
+	tmp = p->ets_packets * 65535ULL;
 	if (p->ts_packets + p->ets_packets)
 		do_div(tmp, p->ts_packets + p->ets_packets);
 	client->legacy_per = tmp;

commit bd336e63441bcdeeccca6a698087d913a32478c5
Author: Max Kellermann <max.kellermann@gmail.com>
Date:   Tue Aug 9 18:32:21 2016 -0300

    [media] dvb: make DVB frontend *_ops instances "const"
    
    These are immutable.  Making them "const" allows the compiler to move
    them to the "rodata" section.
    
    Note that cxd2841er_t_c_ops cannot be made "const", because
    cxd2841er_attach() modifies it.  Ouch!
    
    [mchehab@s-opensource.com: fix merge conflicts]
    Signed-off-by: Max Kellermann <max.kellermann@gmail.com>
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/common/siano/smsdvb-main.c b/drivers/media/common/siano/smsdvb-main.c
index 9148e14c9d07..affde1426b7a 100644
--- a/drivers/media/common/siano/smsdvb-main.c
+++ b/drivers/media/common/siano/smsdvb-main.c
@@ -1044,7 +1044,7 @@ static void smsdvb_release(struct dvb_frontend *fe)
 	/* do nothing */
 }
 
-static struct dvb_frontend_ops smsdvb_fe_ops = {
+static const struct dvb_frontend_ops smsdvb_fe_ops = {
 	.info = {
 		.name			= "Siano Mobile Digital MDTV Receiver",
 		.frequency_min		= 44250000,

commit 83a74ff8e63e39d8122ff17ac000064605884127
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Thu Feb 4 09:54:25 2016 -0200

    [media] siano: remove get_frontend stub
    
    There's nothing at siano's get_frontend() callback. So,
    remove it, as the core will handle it.
    
    Reviewed-by: Javier Martinez Canillas <javier@osg.samsung.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/common/siano/smsdvb-main.c b/drivers/media/common/siano/smsdvb-main.c
index d31f468830cf..9148e14c9d07 100644
--- a/drivers/media/common/siano/smsdvb-main.c
+++ b/drivers/media/common/siano/smsdvb-main.c
@@ -1015,12 +1015,6 @@ static int smsdvb_set_frontend(struct dvb_frontend *fe)
 	}
 }
 
-/* Nothing to do here, as stats are automatically updated */
-static int smsdvb_get_frontend(struct dvb_frontend *fe)
-{
-	return 0;
-}
-
 static int smsdvb_init(struct dvb_frontend *fe)
 {
 	struct smsdvb_client_t *client =
@@ -1069,7 +1063,6 @@ static struct dvb_frontend_ops smsdvb_fe_ops = {
 	.release = smsdvb_release,
 
 	.set_frontend = smsdvb_set_frontend,
-	.get_frontend = smsdvb_get_frontend,
 	.get_tune_settings = smsdvb_get_tune_settings,
 
 	.read_status = smsdvb_read_status,

commit 0230d60e4661d9ced6fb0b9a30f182ebdafbba7a
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Tue Dec 29 11:52:23 2015 -0200

    [media] dvbdev: Add RF connector if needed
    
    Several pure digital TV devices have a frontend with the tuner
    integrated on it. Add the RF connector when dvb_create_media_graph()
    is called on such devices.
    
    Tested with siano and dvb_usb_mxl111sf drivers.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/common/siano/smsdvb-main.c b/drivers/media/common/siano/smsdvb-main.c
index 8a1ea2192439..d31f468830cf 100644
--- a/drivers/media/common/siano/smsdvb-main.c
+++ b/drivers/media/common/siano/smsdvb-main.c
@@ -1184,7 +1184,7 @@ static int smsdvb_hotplug(struct smscore_device_t *coredev,
 	if (smsdvb_debugfs_create(client) < 0)
 		pr_info("failed to create debugfs node\n");
 
-	rc = dvb_create_media_graph(&client->adapter);
+	rc = dvb_create_media_graph(&client->adapter, true);
 	if (rc < 0) {
 		pr_err("dvb_create_media_graph failed %d\n", rc);
 		goto client_error;

commit 9832e155f1ed3030fdfaa19e72c06472dc2ecb1d
Author: Javier Martinez Canillas <javier@osg.samsung.com>
Date:   Fri Dec 11 20:57:08 2015 -0200

    [media] media-device: split media initialization and registration
    
    The media device node is registered and so made visible to user-space
    before entities are registered and links created which means that the
    media graph obtained by user-space could be only partially enumerated
    if that happens too early before all the graph has been created.
    
    To avoid this race condition, split the media init and registration
    in separate functions and only register the media device node when
    all the pending subdevices have been registered, either explicitly
    by the driver or asynchronously using v4l2_async_register_subdev().
    
    The media_device_register() had a check for drivers not filling dev
    and model fields but all drivers in mainline set them and not doing
    it will be a driver bug so change the function return to void and
    add a BUG_ON() for dev being NULL instead.
    
    Also, add a media_device_cleanup() function that will destroy the
    graph_mutex that is initialized in media_device_init().
    
    [mchehab@osg.samsung.com: Fix compilation if !CONFIG_MEDIA_CONTROLLER
     and remove two warnings added by this changeset]
    Suggested-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Signed-off-by: Javier Martinez Canillas <javier@osg.samsung.com>
    Acked-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/common/siano/smsdvb-main.c b/drivers/media/common/siano/smsdvb-main.c
index ab345490a43a..8a1ea2192439 100644
--- a/drivers/media/common/siano/smsdvb-main.c
+++ b/drivers/media/common/siano/smsdvb-main.c
@@ -617,6 +617,7 @@ static void smsdvb_media_device_unregister(struct smsdvb_client_t *client)
 	if (!coredev->media_dev)
 		return;
 	media_device_unregister(coredev->media_dev);
+	media_device_cleanup(coredev->media_dev);
 	kfree(coredev->media_dev);
 	coredev->media_dev = NULL;
 #endif

commit 0d3ab8410dcb60aef2104231ba817037b3ba73bd
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Fri Sep 4 15:33:46 2015 -0300

    [media] dvb core: must check dvb_create_media_graph()
    
    If media controller is enabled and mdev is filled, it should
    ensure that the media graph will be properly initialized.
    
    Enforce that.
    
    Acked-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/common/siano/smsdvb-main.c b/drivers/media/common/siano/smsdvb-main.c
index f4305ae800f4..ab345490a43a 100644
--- a/drivers/media/common/siano/smsdvb-main.c
+++ b/drivers/media/common/siano/smsdvb-main.c
@@ -1183,7 +1183,11 @@ static int smsdvb_hotplug(struct smscore_device_t *coredev,
 	if (smsdvb_debugfs_create(client) < 0)
 		pr_info("failed to create debugfs node\n");
 
-	dvb_create_media_graph(&client->adapter);
+	rc = dvb_create_media_graph(&client->adapter);
+	if (rc < 0) {
+		pr_err("dvb_create_media_graph failed %d\n", rc);
+		goto client_error;
+	}
 
 	pr_info("DVB interface registered.\n");
 	return 0;

commit 0df289a209e02f0926042ab07d7d2595ea2d2e9b
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Sun Jun 7 14:53:52 2015 -0300

    [media] dvb: Get rid of typedev usage for enums
    
    The DVB API was originally defined using typedefs. This is against
    Kernel CodingStyle, and there's no good usage here. While we can't
    remove its usage on userspace, we can avoid its usage in Kernelspace.
    
    So, let's do it.
    
    This patch was generated by this shell script:
    
            for j in $(grep typedef include/uapi/linux/dvb/frontend.h |cut -d' ' -f 3); do for i in $(find drivers/media -name '*.[ch]' -type f) $(find drivers/staging/media -name '*.[ch]' -type f); do sed "s,${j}_t,enum $j," <$i >a && mv a $i; done; done
    
    While here, make CodingStyle fixes on the affected lines.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
    Acked-by: Stefan Richter <stefanr@s5r6.in-berlin.de> # for drivers/media/firewire/*

diff --git a/drivers/media/common/siano/smsdvb-main.c b/drivers/media/common/siano/smsdvb-main.c
index 367b8e77feb8..f4305ae800f4 100644
--- a/drivers/media/common/siano/smsdvb-main.c
+++ b/drivers/media/common/siano/smsdvb-main.c
@@ -753,7 +753,7 @@ static inline int led_feedback(struct smsdvb_client_t *client)
 				     SMS_LED_HI : SMS_LED_LO);
 }
 
-static int smsdvb_read_status(struct dvb_frontend *fe, fe_status_t *stat)
+static int smsdvb_read_status(struct dvb_frontend *fe, enum fe_status *stat)
 {
 	int rc;
 	struct smsdvb_client_t *client;
@@ -900,7 +900,7 @@ static int smsdvb_dvbt_set_frontend(struct dvb_frontend *fe)
 	/* Disable LNA, if any. An error is returned if no LNA is present */
 	ret = sms_board_lna_control(client->coredev, 0);
 	if (ret == 0) {
-		fe_status_t status;
+		enum fe_status status;
 
 		/* tune with LNA off at first */
 		ret = smsdvb_sendrequest_and_wait(client, &msg, sizeof(msg),
@@ -971,7 +971,7 @@ static int smsdvb_isdbt_set_frontend(struct dvb_frontend *fe)
 	/* Disable LNA, if any. An error is returned if no LNA is present */
 	ret = sms_board_lna_control(client->coredev, 0);
 	if (ret == 0) {
-		fe_status_t status;
+		enum fe_status status;
 
 		/* tune with LNA off at first */
 		ret = smsdvb_sendrequest_and_wait(client, &msg, sizeof(msg),

commit 89a2c1d60aa2cfcf4c9f194b4c923d72182be431
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Mon Mar 2 11:26:14 2015 -0300

    [media] use a function for DVB media controller register
    
    This is really a simple function, but using it avoids to have
    if's inside the drivers.
    
    Also, the kABI becomes a little more clearer.
    
    This shouldn't generate any overhead, and the type check
    will happen when compiling with MC DVB enabled.
    
    So, let's do it.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/common/siano/smsdvb-main.c b/drivers/media/common/siano/smsdvb-main.c
index c739725ca7ee..367b8e77feb8 100644
--- a/drivers/media/common/siano/smsdvb-main.c
+++ b/drivers/media/common/siano/smsdvb-main.c
@@ -1104,9 +1104,7 @@ static int smsdvb_hotplug(struct smscore_device_t *coredev,
 		pr_err("dvb_register_adapter() failed %d\n", rc);
 		goto adapter_error;
 	}
-#ifdef CONFIG_MEDIA_CONTROLLER_DVB
-	client->adapter.mdev = coredev->media_dev;
-#endif
+	dvb_register_media_controller(&client->adapter, coredev->media_dev);
 
 	/* init dvb demux */
 	client->demux.dmx.capabilities = DMX_TS_FILTERING;

commit 872b9dbedd4040f4511c909a09d39330624f057b
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Mon Mar 2 10:53:46 2015 -0300

    [media] dvb: Avoid warnings when compiled without the media controller
    
    drivers/media/usb/dvb-usb-v2/dvb_usb_core.c: In function ‘dvb_usbv2_adapter_dvb_exit’:
    drivers/media/usb/dvb-usb-v2/dvb_usb_core.c:531:25: warning: unused variable ‘d’ [-Wunused-variable]
      struct dvb_usb_device *d = adap_to_d(adap);
                             ^
    drivers/media/usb/dvb-usb-v2/dvb_usb_core.c:403:13: warning: ‘dvb_usbv2_media_device_register’ defined but not used [-Wunused-function]
     static void dvb_usbv2_media_device_register(struct dvb_usb_adapter *adap)
    
    drivers/media/usb/dvb-usb/dvb-usb-dvb.c:97:13: warning: ‘dvb_usb_media_device_register’ defined but not used [-Wunused-function]
     static void dvb_usb_media_device_register(struct dvb_usb_adapter *adap)
                 ^
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/common/siano/smsdvb-main.c b/drivers/media/common/siano/smsdvb-main.c
index 387db145d37e..c739725ca7ee 100644
--- a/drivers/media/common/siano/smsdvb-main.c
+++ b/drivers/media/common/siano/smsdvb-main.c
@@ -611,9 +611,9 @@ static int smsdvb_onresponse(void *context, struct smscore_buffer_t *cb)
 
 static void smsdvb_media_device_unregister(struct smsdvb_client_t *client)
 {
+#ifdef CONFIG_MEDIA_CONTROLLER_DVB
 	struct smscore_device_t *coredev = client->coredev;
 
-#ifdef CONFIG_MEDIA_CONTROLLER_DVB
 	if (!coredev->media_dev)
 		return;
 	media_device_unregister(coredev->media_dev);

commit 480884b647c7efecb904a9ed022ee533afb9cb80
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Mon Mar 2 10:49:04 2015 -0300

    [media] dvbdev: use adapter arg for dvb_create_media_graph()
    
    Instead of using media_dev argument for dvb_create_media_graph(),
    use the adapter.
    
    That allows to create a stub for this function, if compiled
    without DVB support, avoiding to add extra if's at the drivers.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/common/siano/smsdvb-main.c b/drivers/media/common/siano/smsdvb-main.c
index dd3c1516013f..387db145d37e 100644
--- a/drivers/media/common/siano/smsdvb-main.c
+++ b/drivers/media/common/siano/smsdvb-main.c
@@ -1185,7 +1185,7 @@ static int smsdvb_hotplug(struct smscore_device_t *coredev,
 	if (smsdvb_debugfs_create(client) < 0)
 		pr_info("failed to create debugfs node\n");
 
-	dvb_create_media_graph(coredev->media_dev);
+	dvb_create_media_graph(&client->adapter);
 
 	pr_info("DVB interface registered.\n");
 	return 0;

commit fb372a434d47f636bc8277e7e91e0f2855a14263
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Sun Feb 22 12:00:45 2015 -0300

    [media] siano: print a message if DVB register succeeds
    
    Right now, this is a debug message, misplaced. Promote it
    to an info message, as it helps to discover if something
    bad happened during device init.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/common/siano/smsdvb-main.c b/drivers/media/common/siano/smsdvb-main.c
index fbb0938ea213..dd3c1516013f 100644
--- a/drivers/media/common/siano/smsdvb-main.c
+++ b/drivers/media/common/siano/smsdvb-main.c
@@ -1180,7 +1180,6 @@ static int smsdvb_hotplug(struct smscore_device_t *coredev,
 	client->event_unc_state = -1;
 	sms_board_dvb3_event(client, DVB3_EVENT_HOTPLUG);
 
-	pr_debug("success\n");
 	sms_board_setup(coredev);
 
 	if (smsdvb_debugfs_create(client) < 0)
@@ -1188,6 +1187,7 @@ static int smsdvb_hotplug(struct smscore_device_t *coredev,
 
 	dvb_create_media_graph(coredev->media_dev);
 
+	pr_info("DVB interface registered.\n");
 	return 0;
 
 client_error:

commit d9f3836b7b0353ef21ab4dd0a771331b0afa46e5
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Sun Feb 22 11:51:41 2015 -0300

    [media] siano: get rid of sms_dbg parameter
    
    All siano modules have a sms_dbg parameter. Now that we're using
    the standard pr_debug() macro, we can get rid of it.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/common/siano/smsdvb-main.c b/drivers/media/common/siano/smsdvb-main.c
index e65fba160d90..fbb0938ea213 100644
--- a/drivers/media/common/siano/smsdvb-main.c
+++ b/drivers/media/common/siano/smsdvb-main.c
@@ -40,11 +40,6 @@ DVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);
 static struct list_head g_smsdvb_clients;
 static struct mutex g_smsdvb_clientslock;
 
-static int sms_dbg;
-module_param_named(debug, sms_dbg, int, 0644);
-MODULE_PARM_DESC(debug, "set debug level (info=1, adv=2 (or-able))");
-
-
 static u32 sms_to_guard_interval_table[] = {
 	[0] = GUARD_INTERVAL_1_32,
 	[1] = GUARD_INTERVAL_1_16,

commit 0dd5f20cb35b59f82b35e918658fa8ab22b9f13a
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Sun Feb 22 11:49:28 2015 -0300

    [media] siano: get rid of sms_info()
    
    On most cases, sms_info() should actually be pr_debug(), but,
    on other places, it should be pr_info().
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/common/siano/smsdvb-main.c b/drivers/media/common/siano/smsdvb-main.c
index 9dd31083296f..e65fba160d90 100644
--- a/drivers/media/common/siano/smsdvb-main.c
+++ b/drivers/media/common/siano/smsdvb-main.c
@@ -591,7 +591,7 @@ static int smsdvb_onresponse(void *context, struct smscore_buffer_t *cb)
 		is_status_update = true;
 		break;
 	default:
-		sms_info("message not handled");
+		pr_debug("message not handled\n");
 	}
 	smscore_putbuffer(client->coredev, cb);
 
@@ -884,7 +884,7 @@ static int smsdvb_dvbt_set_frontend(struct dvb_frontend *fe)
 	msg.Data[0] = c->frequency;
 	msg.Data[2] = 12000000;
 
-	sms_info("%s: freq %d band %d", __func__, c->frequency,
+	pr_debug("%s: freq %d band %d\n", __func__, c->frequency,
 		 c->bandwidth_hz);
 
 	switch (c->bandwidth_hz / 1000000) {
@@ -969,7 +969,7 @@ static int smsdvb_isdbt_set_frontend(struct dvb_frontend *fe)
 
 	c->bandwidth_hz = 6000000;
 
-	sms_info("%s: freq %d segwidth %d segindex %d", __func__,
+	pr_debug("freq %d segwidth %d segindex %d\n",
 		 c->frequency, c->isdbt_sb_segment_count,
 		 c->isdbt_sb_segment_idx);
 
@@ -1185,11 +1185,11 @@ static int smsdvb_hotplug(struct smscore_device_t *coredev,
 	client->event_unc_state = -1;
 	sms_board_dvb3_event(client, DVB3_EVENT_HOTPLUG);
 
-	sms_info("success");
+	pr_debug("success\n");
 	sms_board_setup(coredev);
 
 	if (smsdvb_debugfs_create(client) < 0)
-		sms_info("failed to create debugfs node");
+		pr_info("failed to create debugfs node\n");
 
 	dvb_create_media_graph(coredev->media_dev);
 

commit 6908368879c3e4965d849c893d3741858a8d1842
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Sun Feb 22 11:33:37 2015 -0300

    [media] siano: replace sms_debug() by pr_debug()
    
    There's no reason to use a macro here. Just replace everything,
    and let those debug messages to be activated via dynamic printk.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/common/siano/smsdvb-main.c b/drivers/media/common/siano/smsdvb-main.c
index a8538d00dfc7..9dd31083296f 100644
--- a/drivers/media/common/siano/smsdvb-main.c
+++ b/drivers/media/common/siano/smsdvb-main.c
@@ -83,42 +83,42 @@ static void sms_board_dvb3_event(struct smsdvb_client_t *client,
 	struct smscore_device_t *coredev = client->coredev;
 	switch (event) {
 	case DVB3_EVENT_INIT:
-		sms_debug("DVB3_EVENT_INIT");
+		pr_debug("DVB3_EVENT_INIT\n");
 		sms_board_event(coredev, BOARD_EVENT_BIND);
 		break;
 	case DVB3_EVENT_SLEEP:
-		sms_debug("DVB3_EVENT_SLEEP");
+		pr_debug("DVB3_EVENT_SLEEP\n");
 		sms_board_event(coredev, BOARD_EVENT_POWER_SUSPEND);
 		break;
 	case DVB3_EVENT_HOTPLUG:
-		sms_debug("DVB3_EVENT_HOTPLUG");
+		pr_debug("DVB3_EVENT_HOTPLUG\n");
 		sms_board_event(coredev, BOARD_EVENT_POWER_INIT);
 		break;
 	case DVB3_EVENT_FE_LOCK:
 		if (client->event_fe_state != DVB3_EVENT_FE_LOCK) {
 			client->event_fe_state = DVB3_EVENT_FE_LOCK;
-			sms_debug("DVB3_EVENT_FE_LOCK");
+			pr_debug("DVB3_EVENT_FE_LOCK\n");
 			sms_board_event(coredev, BOARD_EVENT_FE_LOCK);
 		}
 		break;
 	case DVB3_EVENT_FE_UNLOCK:
 		if (client->event_fe_state != DVB3_EVENT_FE_UNLOCK) {
 			client->event_fe_state = DVB3_EVENT_FE_UNLOCK;
-			sms_debug("DVB3_EVENT_FE_UNLOCK");
+			pr_debug("DVB3_EVENT_FE_UNLOCK\n");
 			sms_board_event(coredev, BOARD_EVENT_FE_UNLOCK);
 		}
 		break;
 	case DVB3_EVENT_UNC_OK:
 		if (client->event_unc_state != DVB3_EVENT_UNC_OK) {
 			client->event_unc_state = DVB3_EVENT_UNC_OK;
-			sms_debug("DVB3_EVENT_UNC_OK");
+			pr_debug("DVB3_EVENT_UNC_OK\n");
 			sms_board_event(coredev, BOARD_EVENT_MULTIPLEX_OK);
 		}
 		break;
 	case DVB3_EVENT_UNC_ERR:
 		if (client->event_unc_state != DVB3_EVENT_UNC_ERR) {
 			client->event_unc_state = DVB3_EVENT_UNC_ERR;
-			sms_debug("DVB3_EVENT_UNC_ERR");
+			pr_debug("DVB3_EVENT_UNC_ERR\n");
 			sms_board_event(coredev, BOARD_EVENT_MULTIPLEX_ERRORS);
 		}
 		break;
@@ -658,7 +658,7 @@ static int smsdvb_start_feed(struct dvb_demux_feed *feed)
 		container_of(feed->demux, struct smsdvb_client_t, demux);
 	struct sms_msg_data pid_msg;
 
-	sms_debug("add pid %d(%x)",
+	pr_debug("add pid %d(%x)\n",
 		  feed->pid, feed->pid);
 
 	client->feed_users++;
@@ -680,7 +680,7 @@ static int smsdvb_stop_feed(struct dvb_demux_feed *feed)
 		container_of(feed->demux, struct smsdvb_client_t, demux);
 	struct sms_msg_data pid_msg;
 
-	sms_debug("remove pid %d(%x)",
+	pr_debug("remove pid %d(%x)\n",
 		  feed->pid, feed->pid);
 
 	client->feed_users--;
@@ -850,7 +850,7 @@ static int smsdvb_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)
 static int smsdvb_get_tune_settings(struct dvb_frontend *fe,
 				    struct dvb_frontend_tune_settings *tune)
 {
-	sms_debug("");
+	pr_debug("\n");
 
 	tune->min_delay_ms = 400;
 	tune->step_size = 250000;
@@ -1224,7 +1224,7 @@ static int __init smsdvb_module_init(void)
 
 	rc = smscore_register_hotplug(smsdvb_hotplug);
 
-	sms_debug("");
+	pr_debug("\n");
 
 	return rc;
 }

commit 5ed0a2c7eca3265e6df3e9eebedfc2db3916dcd4
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Sun Feb 22 11:04:35 2015 -0300

    [media] siano: replace sms_err by pr_err
    
    Originally, sms_err() would be also displaying the line where
    the error occurs, but the messages are clear enough. Also,
    the function is always printed. So, no need for it.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/common/siano/smsdvb-main.c b/drivers/media/common/siano/smsdvb-main.c
index 6eb1b14092cb..a8538d00dfc7 100644
--- a/drivers/media/common/siano/smsdvb-main.c
+++ b/drivers/media/common/siano/smsdvb-main.c
@@ -124,7 +124,7 @@ static void sms_board_dvb3_event(struct smsdvb_client_t *client,
 		break;
 
 	default:
-		sms_err("Unknown dvb3 api event");
+		pr_err("Unknown dvb3 api event\n");
 		break;
 	}
 }
@@ -1097,10 +1097,8 @@ static int smsdvb_hotplug(struct smscore_device_t *coredev,
 	if (!arrival)
 		return 0;
 	client = kzalloc(sizeof(struct smsdvb_client_t), GFP_KERNEL);
-	if (!client) {
-		sms_err("kmalloc() failed");
+	if (!client)
 		return -ENOMEM;
-	}
 
 	/* register dvb adapter */
 	rc = dvb_register_adapter(&client->adapter,
@@ -1108,7 +1106,7 @@ static int smsdvb_hotplug(struct smscore_device_t *coredev,
 					smscore_get_board_id(coredev))->name,
 				  THIS_MODULE, device, adapter_nr);
 	if (rc < 0) {
-		sms_err("dvb_register_adapter() failed %d", rc);
+		pr_err("dvb_register_adapter() failed %d\n", rc);
 		goto adapter_error;
 	}
 #ifdef CONFIG_MEDIA_CONTROLLER_DVB
@@ -1124,7 +1122,7 @@ static int smsdvb_hotplug(struct smscore_device_t *coredev,
 
 	rc = dvb_dmx_init(&client->demux);
 	if (rc < 0) {
-		sms_err("dvb_dmx_init failed %d", rc);
+		pr_err("dvb_dmx_init failed %d\n", rc);
 		goto dvbdmx_error;
 	}
 
@@ -1135,7 +1133,7 @@ static int smsdvb_hotplug(struct smscore_device_t *coredev,
 
 	rc = dvb_dmxdev_init(&client->dmxdev, &client->adapter);
 	if (rc < 0) {
-		sms_err("dvb_dmxdev_init failed %d", rc);
+		pr_err("dvb_dmxdev_init failed %d\n", rc);
 		goto dmxdev_error;
 	}
 
@@ -1156,7 +1154,7 @@ static int smsdvb_hotplug(struct smscore_device_t *coredev,
 
 	rc = dvb_register_frontend(&client->adapter, &client->frontend);
 	if (rc < 0) {
-		sms_err("frontend registration failed %d", rc);
+		pr_err("frontend registration failed %d\n", rc);
 		goto frontend_error;
 	}
 
@@ -1168,7 +1166,7 @@ static int smsdvb_hotplug(struct smscore_device_t *coredev,
 
 	rc = smscore_register_client(coredev, &params, &client->smsclient);
 	if (rc < 0) {
-		sms_err("smscore_register_client() failed %d", rc);
+		pr_err("smscore_register_client() failed %d\n", rc);
 		goto client_error;
 	}
 

commit 5e022d1aa0be77d749939a56f751f62ed8ee4d2b
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Sun Feb 22 10:46:56 2015 -0300

    [media] siano: use pr_* print functions
    
    Instead of defining its own set of printk functions, let's
    use the common Kernel debug logic provided by pr_foo functions.
    
    As a first step, let's just define the existing macros as the
    Kernel ones.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/common/siano/smsdvb-main.c b/drivers/media/common/siano/smsdvb-main.c
index 042515915e20..6eb1b14092cb 100644
--- a/drivers/media/common/siano/smsdvb-main.c
+++ b/drivers/media/common/siano/smsdvb-main.c
@@ -19,6 +19,8 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 ****************************************************************/
 
+#include "smscoreapi.h"
+
 #include <linux/module.h>
 #include <linux/slab.h>
 #include <linux/init.h>
@@ -29,7 +31,6 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "dvb_demux.h"
 #include "dvb_frontend.h"
 
-#include "smscoreapi.h"
 #include "sms-cards.h"
 
 #include "smsdvb.h"

commit 46b1e21fe50f9f58ceaffc10c5aea50366cf7af5
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Wed Jan 7 08:03:03 2015 -0300

    [media] siano: add support for the media controller at USB driver
    
    Adding support for the media controller for a pure DVB device
    is simple: just create a struct media_device and add it to the
    dvb adapter. After creating all DVB devices, we need to call
    the DVB core, for it to create the media graph.
    
    More work is needed for pure DVB tuners, but this is hidden
    at the Siano driver, just like several others non-hybrid
    devices. So, this is streight forward.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/media/common/siano/smsdvb-main.c b/drivers/media/common/siano/smsdvb-main.c
index 85151efdd94c..042515915e20 100644
--- a/drivers/media/common/siano/smsdvb-main.c
+++ b/drivers/media/common/siano/smsdvb-main.c
@@ -613,6 +613,19 @@ static int smsdvb_onresponse(void *context, struct smscore_buffer_t *cb)
 	return 0;
 }
 
+static void smsdvb_media_device_unregister(struct smsdvb_client_t *client)
+{
+	struct smscore_device_t *coredev = client->coredev;
+
+#ifdef CONFIG_MEDIA_CONTROLLER_DVB
+	if (!coredev->media_dev)
+		return;
+	media_device_unregister(coredev->media_dev);
+	kfree(coredev->media_dev);
+	coredev->media_dev = NULL;
+#endif
+}
+
 static void smsdvb_unregister_client(struct smsdvb_client_t *client)
 {
 	/* must be called under clientslock */
@@ -624,6 +637,7 @@ static void smsdvb_unregister_client(struct smsdvb_client_t *client)
 	dvb_unregister_frontend(&client->frontend);
 	dvb_dmxdev_release(&client->dmxdev);
 	dvb_dmx_release(&client->demux);
+	smsdvb_media_device_unregister(client);
 	dvb_unregister_adapter(&client->adapter);
 	kfree(client);
 }
@@ -1096,6 +1110,9 @@ static int smsdvb_hotplug(struct smscore_device_t *coredev,
 		sms_err("dvb_register_adapter() failed %d", rc);
 		goto adapter_error;
 	}
+#ifdef CONFIG_MEDIA_CONTROLLER_DVB
+	client->adapter.mdev = coredev->media_dev;
+#endif
 
 	/* init dvb demux */
 	client->demux.dmx.capabilities = DMX_TS_FILTERING;
@@ -1175,6 +1192,8 @@ static int smsdvb_hotplug(struct smscore_device_t *coredev,
 	if (smsdvb_debugfs_create(client) < 0)
 		sms_info("failed to create debugfs node");
 
+	dvb_create_media_graph(coredev->media_dev);
+
 	return 0;
 
 client_error:
@@ -1187,6 +1206,7 @@ static int smsdvb_hotplug(struct smscore_device_t *coredev,
 	dvb_dmx_release(&client->demux);
 
 dvbdmx_error:
+	smsdvb_media_device_unregister(client);
 	dvb_unregister_adapter(&client->adapter);
 
 adapter_error:

commit 1668844ee642ed5734fc3e7ab5d7746ef8661961
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Fri Oct 4 11:01:52 2013 -0300

    [media] siano: fix sparse warnings
    
    drivers/media/common/siano/smsdvb-main.c:47:5: warning: symbol 'sms_to_guard_interval_table' was not declared. Should it be static?
    drivers/media/common/siano/smsdvb-main.c:54:5: warning: symbol 'sms_to_code_rate_table' was not declared. Should it be static?
    drivers/media/common/siano/smsdvb-main.c:63:5: warning: symbol 'sms_to_hierarchy_table' was not declared. Should it be static?
    drivers/media/common/siano/smsdvb-main.c:70:5: warning: symbol 'sms_to_modulation_table' was not declared. Should it be static?
    drivers/media/common/siano/smscoreapi.c:925:35: warning: cast to restricted __le32
    drivers/media/common/siano/smscoreapi.c:926:28: warning: cast to restricted __le32
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/drivers/media/common/siano/smsdvb-main.c b/drivers/media/common/siano/smsdvb-main.c
index 63676a8b024c..85151efdd94c 100644
--- a/drivers/media/common/siano/smsdvb-main.c
+++ b/drivers/media/common/siano/smsdvb-main.c
@@ -44,14 +44,14 @@ module_param_named(debug, sms_dbg, int, 0644);
 MODULE_PARM_DESC(debug, "set debug level (info=1, adv=2 (or-able))");
 
 
-u32 sms_to_guard_interval_table[] = {
+static u32 sms_to_guard_interval_table[] = {
 	[0] = GUARD_INTERVAL_1_32,
 	[1] = GUARD_INTERVAL_1_16,
 	[2] = GUARD_INTERVAL_1_8,
 	[3] = GUARD_INTERVAL_1_4,
 };
 
-u32 sms_to_code_rate_table[] = {
+static u32 sms_to_code_rate_table[] = {
 	[0] = FEC_1_2,
 	[1] = FEC_2_3,
 	[2] = FEC_3_4,
@@ -60,14 +60,14 @@ u32 sms_to_code_rate_table[] = {
 };
 
 
-u32 sms_to_hierarchy_table[] = {
+static u32 sms_to_hierarchy_table[] = {
 	[0] = HIERARCHY_NONE,
 	[1] = HIERARCHY_1,
 	[2] = HIERARCHY_2,
 	[3] = HIERARCHY_4,
 };
 
-u32 sms_to_modulation_table[] = {
+static u32 sms_to_modulation_table[] = {
 	[0] = QPSK,
 	[1] = QAM_16,
 	[2] = QAM_64,

commit ec532503209053bbee0c7dac410031e50835e01a
Author: Bjørn Mork <bjorn@mork.no>
Date:   Wed Aug 14 05:24:39 2013 -0300

    [media] siano: fix divide error on 0 counters
    
    GIT_AUTHOR_DATE=1376465691
    I took a quick look at the code and wonder if the problem is caused by
    an initial zero statistics message?  This is all just a wild guess, but
    if it is correct, then the attached untested patch might fix it...
    Bjørn
    >From d78a0599d5b5d4da384eae08bf7da316389dfbe5 Mon Sep 17 00:00:00 2001
    ts_packets and ets_packets counters can be 0.  Don't fall over
    if they are. Fixes:
    [  846.851711] divide error: 0000 [#1] SMP
    [  846.851806] Modules linked in: smsdvb dvb_core ir_lirc_codec lirc_dev ir_sanyo_decoder ir_mce_kbd_decoder ir_sony_decoder ir_jvc_decoder ir_rc6_decoder ir_rc5_decoder ir_nec_decoder rc_hauppauge smsusb smsmdtv rc_core pci_stub vboxpci(O) vboxnetadp(O) vboxnetflt(O) vboxdrv(O) parport_pc ppdev lp parport cpufreq_userspace cpufreq_powersave cpufreq_stats cpufreq_conservative rfcomm bnep binfmt_misc uinput nfsd auth_rpcgss oid_registry nfs_acl nfs lockd dns_resolver fscache sunrpc ext4 jbd2 fuse tp_smapi(O) thinkpad_ec(O) loop firewire_sbp2 dm_crypt snd_hda_codec_conexant snd_hda_intel snd_hda_codec snd_hwdep snd_pcm_oss snd_mixer_oss snd_pcm thinkpad_acpi nvram snd_page_alloc hid_generic snd_seq_midi snd_seq_midi_event arc4 usbhid snd_rawmidi uvcvideo hid iwldvm coretemp kvm_intel mac8021
     1 cdc_wdm
    [  846.853477]  cdc_acm snd_seq videobuf2_vmalloc videobuf2_memops videobuf2_core videodev media kvm radeon r852 ttm joydev cdc_ether usbnet pcmcia mii sm_common nand btusb drm_kms_helper tpm_tis acpi_cpufreq bluetooth iwlwifi nand_ecc drm nand_ids i2c_i801 mtd snd_seq_device iTCO_wdt iTCO_vendor_support r592 memstick lpc_ich mperf tpm yenta_socket pcmcia_rsrc pcmcia_core cfg80211 snd_timer snd pcspkr i2c_algo_bit crc16 i2c_core tpm_bios processor mfd_core wmi psmouse mei_me rfkill mei serio_raw soundcore evdev battery button video ac microcode ext3 mbcache jbd md_mod dm_mirror dm_region_hash dm_log dm_mod sg sr_mod sd_mod cdrom crc_t10dif firewire_ohci sdhci_pci sdhci mmc_core firewire_core crc_itu_t thermal thermal_sys ahci libahci ehci_pci uhci_hcd ehci_hcd libata scsi_mod usbcore e1000
     e usb_common
    [  846.855310]  ptp pps_core
    [  846.855356] CPU: 0 PID: 0 Comm: swapper/0 Tainted: G           O 3.10-2-amd64 #1 Debian 3.10.5-1
    [  846.855490] Hardware name: LENOVO 4061WFA/4061WFA, BIOS 6FET92WW (3.22 ) 12/14/2011
    [  846.855609] task: ffffffff81613400 ti: ffffffff81600000 task.ti: ffffffff81600000
    [  846.855636] RIP: 0010:[<ffffffffa092be0c>]  [<ffffffffa092be0c>] smsdvb_onresponse+0x264/0xa86 [smsdvb]
    [  846.863906] RSP: 0018:ffff88013bc03cf0  EFLAGS: 00010046
    [  846.863906] RAX: 0000000000000000 RBX: ffff880133bf6000 RCX: 0000000000000000
    [  846.863906] RDX: 0000000000000000 RSI: ffff88005d3b58c0 RDI: ffff880133bf6000
    [  846.863906] RBP: ffff88005d1da000 R08: 0000000000000058 R09: 0000000000000015
    [  846.863906] R10: 0000000000001a0d R11: 000000000000021a R12: ffff88005d3b58c0
    [  846.863906] R13: ffff88005d1da008 R14: 00000000ffffff8d R15: ffff880036cf5060
    [  846.863906] FS:  0000000000000000(0000) GS:ffff88013bc00000(0000) knlGS:0000000000000000
    [  846.863906] CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b
    [  846.863906] CR2: 00007f3a4b69ae50 CR3: 0000000036dac000 CR4: 00000000000407f0
    [  846.863906] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
    [  846.863906] DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400
    [  846.863906] Stack:
    [  846.863906]  ffff88007a102000 ffff88005d1da000 ffff88005d3b58c0 0000000000085824
    [  846.863906]  ffffffffa08c5aa3 ffff88005d1da000 ffff8800a6907390 ffff8800a69073b0
    [  846.863906]  ffff8800a6907000 ffffffffa08b642c 000000000000021a ffff8800a69073b0
    [  846.863906] Call Trace:
    [  846.863906]  <IRQ>
    [  846.863906]
    [  846.863906]  [<ffffffffa08c5aa3>] ? smscore_onresponse+0x1d5/0x353 [smsmdtv]
    [  846.863906]  [<ffffffffa08b642c>] ? smsusb_onresponse+0x146/0x192 [smsusb]
    [  846.863906]  [<ffffffffa004cb1a>] ? usb_hcd_giveback_urb+0x6c/0xac [usbcore]
    [  846.863906]  [<ffffffffa0217be1>] ? ehci_urb_done+0x62/0x72 [ehci_hcd]
    [  846.863906]  [<ffffffffa0217c82>] ? qh_completions+0x91/0x364 [ehci_hcd]
    [  846.863906]  [<ffffffffa0219bba>] ? ehci_work+0x8a/0x68e [ehci_hcd]
    [  846.863906]  [<ffffffff8107336c>] ? timekeeping_get_ns.constprop.10+0xd/0x31
    [  846.863906]  [<ffffffff81064d41>] ? update_cfs_rq_blocked_load+0xde/0xec
    [  846.863906]  [<ffffffff81058ec2>] ? run_posix_cpu_timers+0x25/0x575
    [  846.863906]  [<ffffffffa021aa46>] ? ehci_irq+0x211/0x23d [ehci_hcd]
    [  846.863906]  [<ffffffffa004c0c1>] ? usb_hcd_irq+0x31/0x48 [usbcore]
    [  846.863906]  [<ffffffff810996fd>] ? handle_irq_event_percpu+0x49/0x1a4
    [  846.863906]  [<ffffffff8109988a>] ? handle_irq_event+0x32/0x4b
    [  846.863906]  [<ffffffff8109bd76>] ? handle_fasteoi_irq+0x80/0xb6
    [  846.863906]  [<ffffffff8100e93e>] ? handle_irq+0x18/0x20
    [  846.863906]  [<ffffffff8100e657>] ? do_IRQ+0x40/0x95
    [  846.863906]  [<ffffffff813883ed>] ? common_interrupt+0x6d/0x6d
    [  846.863906]  <EOI>
    [  846.863906]
    [  846.863906]  [<ffffffff812a011c>] ? arch_local_irq_enable+0x4/0x8
    [  846.863906]  [<ffffffff812a04f3>] ? cpuidle_enter_state+0x52/0xc1
    [  846.863906]  [<ffffffff812a0636>] ? cpuidle_idle_call+0xd4/0x143
    [  846.863906]  [<ffffffff8101398c>] ? arch_cpu_idle+0x5/0x17
    [  846.863906]  [<ffffffff81072571>] ? cpu_startup_entry+0x10d/0x187
    [  846.863906]  [<ffffffff816b3d3d>] ? start_kernel+0x3e8/0x3f3
    [  846.863906]  [<ffffffff816b3777>] ? repair_env_string+0x54/0x54
    [  846.863906]  [<ffffffff816b3598>] ? x86_64_start_kernel+0xf2/0xfd
    [  846.863906] Code: 25 09 00 00 c6 83 da 08 00 00 03 8b 45 54 48 01 83 b6 08 00 00 8b 45 50 48 01 83 db 08 00 00 8b 4d 18 69 c1 ff ff 00 00 03 4d 14 <48> f7 f1 89 83 a8 09 00 00 e9 68 fe ff ff 48 8b 7f 10 e8 79 92
    [  846.863906] RIP  [<ffffffffa092be0c>] smsdvb_onresponse+0x264/0xa86 [smsdvb]
    [  846.863906]  RSP <ffff88013bc03cf0>
    Reference: http://bugs.debian.org/719623
    
    Reported-by: Johannes Rohr <jorohr@gmail.com>
    Signed-off-by: Bjørn Mork <bjorn@mork.no>
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/drivers/media/common/siano/smsdvb-main.c b/drivers/media/common/siano/smsdvb-main.c
index 086262252230..63676a8b024c 100644
--- a/drivers/media/common/siano/smsdvb-main.c
+++ b/drivers/media/common/siano/smsdvb-main.c
@@ -276,7 +276,8 @@ static void smsdvb_update_per_slices(struct smsdvb_client_t *client,
 
 	/* Legacy PER/BER */
 	tmp = p->ets_packets * 65535;
-	do_div(tmp, p->ts_packets + p->ets_packets);
+	if (p->ts_packets + p->ets_packets)
+		do_div(tmp, p->ts_packets + p->ets_packets);
 	client->legacy_per = tmp;
 }
 

commit 250a51caa65cc7637f3596300d3591a2c924b32e
Author: Jakob Normark <jakobnormark@gmail.com>
Date:   Sun May 19 09:30:23 2013 -0300

    [media] Missing break statement added in smsdvb-main.c
    
    Fix missing break that so that n_layers are not accidentally incorrect
    Kernel version: v3.10-rc1
    
    Signed-off-by: Jakob Normark <jakobnormark@gmail.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/common/siano/smsdvb-main.c b/drivers/media/common/siano/smsdvb-main.c
index 297f1b2f9a32..086262252230 100644
--- a/drivers/media/common/siano/smsdvb-main.c
+++ b/drivers/media/common/siano/smsdvb-main.c
@@ -140,6 +140,7 @@ static void smsdvb_stats_not_ready(struct dvb_frontend *fe)
 	case DEVICE_MODE_ISDBT:
 	case DEVICE_MODE_ISDBT_BDA:
 		n_layers = 4;
+		break;
 	default:
 		n_layers = 1;
 	}

commit f35d09db0e61009679e41cc5afa2d205b99c3816
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Fri Mar 22 06:22:45 2013 -0300

    [media] siano: use do_div() for 64-bits division
    
    As reported by Frank Schäfer <fschaefer.oss@googlemail.com>:
            ERROR: "__divdi3" [drivers/media/common/siano/smsdvb.ko] undefined!
    
    Reported-by: Frank Schäfer <fschaefer.oss@googlemail.com>
    Tested-by: Gianluca Gennari <gennarone@gmail.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/common/siano/smsdvb-main.c b/drivers/media/common/siano/smsdvb-main.c
index d965a7ae5982..297f1b2f9a32 100644
--- a/drivers/media/common/siano/smsdvb-main.c
+++ b/drivers/media/common/siano/smsdvb-main.c
@@ -22,6 +22,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include <linux/module.h>
 #include <linux/slab.h>
 #include <linux/init.h>
+#include <asm/div64.h>
 
 #include "dmxdev.h"
 #include "dvbdev.h"
@@ -244,6 +245,7 @@ static void smsdvb_update_per_slices(struct smsdvb_client_t *client,
 {
 	struct dvb_frontend *fe = &client->frontend;
 	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	u64 tmp;
 
 	client->fe_status = sms_to_status(p->is_demod_locked, p->is_rf_locked);
 	c->modulation = sms_to_modulation(p->constellation);
@@ -272,8 +274,9 @@ static void smsdvb_update_per_slices(struct smsdvb_client_t *client,
 	c->post_bit_count.stat[0].uvalue += p->ber_bit_count;
 
 	/* Legacy PER/BER */
-	client->legacy_per = (p->ets_packets * 65535) /
-			     (p->ts_packets + p->ets_packets);
+	tmp = p->ets_packets * 65535;
+	do_div(tmp, p->ts_packets + p->ets_packets);
+	client->legacy_per = tmp;
 }
 
 static void smsdvb_update_dvb_stats(struct smsdvb_client_t *client,
@@ -803,7 +806,7 @@ static int smsdvb_read_snr(struct dvb_frontend *fe, u16 *snr)
 	rc = smsdvb_send_statistics_request(client);
 
 	/* Preferred scale for SNR with legacy API: 0.1 dB */
-	*snr = c->cnr.stat[0].svalue / 100;
+	*snr = ((u32)c->cnr.stat[0].svalue) / 100;
 
 	led_feedback(client);
 

commit 28a59df4d7cb8f749ba92ad304df4063ccf108fd
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Thu Mar 21 09:27:37 2013 -0300

    [media] siano: remove the remaining CamelCase compliants
    
    Remove the remaining CamelCase checkpatch.pl compliants.
    There are still a few left, but those are due to USB and
    DVB APIs.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/common/siano/smsdvb-main.c b/drivers/media/common/siano/smsdvb-main.c
index 29d1c41bbd66..d965a7ae5982 100644
--- a/drivers/media/common/siano/smsdvb-main.c
+++ b/drivers/media/common/siano/smsdvb-main.c
@@ -265,7 +265,7 @@ static void smsdvb_update_per_slices(struct smsdvb_client_t *client,
 	c->block_error.stat[0].uvalue += p->ets_packets;
 	c->block_count.stat[0].uvalue += p->ets_packets + p->ts_packets;
 
-	/* BER */
+	/* ber */
 	c->post_bit_error.stat[0].scale = FE_SCALE_COUNTER;
 	c->post_bit_count.stat[0].scale = FE_SCALE_COUNTER;
 	c->post_bit_error.stat[0].uvalue += p->ber_error_count;
@@ -318,14 +318,14 @@ static void smsdvb_update_dvb_stats(struct smsdvb_client_t *client,
 	c->block_error.stat[0].uvalue += p->error_ts_packets;
 	c->block_count.stat[0].uvalue += p->total_ts_packets;
 
-	/* BER */
+	/* ber */
 	c->post_bit_error.stat[0].scale = FE_SCALE_COUNTER;
 	c->post_bit_count.stat[0].scale = FE_SCALE_COUNTER;
 	c->post_bit_error.stat[0].uvalue += p->ber_error_count;
 	c->post_bit_count.stat[0].uvalue += p->ber_bit_count;
 
 	/* Legacy PER/BER */
-	client->legacy_ber = p->BER;
+	client->legacy_ber = p->ber;
 };
 
 static void smsdvb_update_isdbt_stats(struct smsdvb_client_t *client,
@@ -391,7 +391,7 @@ static void smsdvb_update_isdbt_stats(struct smsdvb_client_t *client,
 	c->post_bit_count.stat[0].scale = FE_SCALE_COUNTER;
 
 	for (i = 0; i < n_layers; i++) {
-		lr = &p->LayerInfo[i];
+		lr = &p->layer_info[i];
 
 		/* Update per-layer transmission parameters */
 		if (lr->number_of_segments > 0 && lr->number_of_segments < 13) {
@@ -479,7 +479,7 @@ static void smsdvb_update_isdbt_stats_ex(struct smsdvb_client_t *client,
 	c->block_error.len = n_layers + 1;
 	c->block_count.len = n_layers + 1;
 	for (i = 0; i < n_layers; i++) {
-		lr = &p->LayerInfo[i];
+		lr = &p->layer_info[i];
 
 		/* Update per-layer transmission parameters */
 		if (lr->number_of_segments > 0 && lr->number_of_segments < 13) {
@@ -500,13 +500,13 @@ static void smsdvb_update_isdbt_stats_ex(struct smsdvb_client_t *client,
 		c->block_error.stat[0].uvalue += lr->error_ts_packets;
 		c->block_count.stat[0].uvalue += lr->total_ts_packets;
 
-		/* BER */
+		/* ber */
 		c->post_bit_error.stat[i + 1].scale = FE_SCALE_COUNTER;
 		c->post_bit_count.stat[i + 1].scale = FE_SCALE_COUNTER;
 		c->post_bit_error.stat[i + 1].uvalue += lr->ber_error_count;
 		c->post_bit_count.stat[i + 1].uvalue += lr->ber_bit_count;
 
-		/* Update global BER counter */
+		/* Update global ber counter */
 		c->post_bit_error.stat[0].uvalue += lr->ber_error_count;
 		c->post_bit_count.stat[0].uvalue += lr->ber_bit_count;
 	}
@@ -636,44 +636,44 @@ static int smsdvb_start_feed(struct dvb_demux_feed *feed)
 {
 	struct smsdvb_client_t *client =
 		container_of(feed->demux, struct smsdvb_client_t, demux);
-	struct sms_msg_data PidMsg;
+	struct sms_msg_data pid_msg;
 
 	sms_debug("add pid %d(%x)",
 		  feed->pid, feed->pid);
 
 	client->feed_users++;
 
-	PidMsg.x_msg_header.msg_src_id = DVBT_BDA_CONTROL_MSG_ID;
-	PidMsg.x_msg_header.msg_dst_id = HIF_TASK;
-	PidMsg.x_msg_header.msg_flags = 0;
-	PidMsg.x_msg_header.msg_type  = MSG_SMS_ADD_PID_FILTER_REQ;
-	PidMsg.x_msg_header.msg_length = sizeof(PidMsg);
-	PidMsg.msgData[0] = feed->pid;
+	pid_msg.x_msg_header.msg_src_id = DVBT_BDA_CONTROL_MSG_ID;
+	pid_msg.x_msg_header.msg_dst_id = HIF_TASK;
+	pid_msg.x_msg_header.msg_flags = 0;
+	pid_msg.x_msg_header.msg_type  = MSG_SMS_ADD_PID_FILTER_REQ;
+	pid_msg.x_msg_header.msg_length = sizeof(pid_msg);
+	pid_msg.msg_data[0] = feed->pid;
 
 	return smsclient_sendrequest(client->smsclient,
-				     &PidMsg, sizeof(PidMsg));
+				     &pid_msg, sizeof(pid_msg));
 }
 
 static int smsdvb_stop_feed(struct dvb_demux_feed *feed)
 {
 	struct smsdvb_client_t *client =
 		container_of(feed->demux, struct smsdvb_client_t, demux);
-	struct sms_msg_data PidMsg;
+	struct sms_msg_data pid_msg;
 
 	sms_debug("remove pid %d(%x)",
 		  feed->pid, feed->pid);
 
 	client->feed_users--;
 
-	PidMsg.x_msg_header.msg_src_id = DVBT_BDA_CONTROL_MSG_ID;
-	PidMsg.x_msg_header.msg_dst_id = HIF_TASK;
-	PidMsg.x_msg_header.msg_flags = 0;
-	PidMsg.x_msg_header.msg_type  = MSG_SMS_REMOVE_PID_FILTER_REQ;
-	PidMsg.x_msg_header.msg_length = sizeof(PidMsg);
-	PidMsg.msgData[0] = feed->pid;
+	pid_msg.x_msg_header.msg_src_id = DVBT_BDA_CONTROL_MSG_ID;
+	pid_msg.x_msg_header.msg_dst_id = HIF_TASK;
+	pid_msg.x_msg_header.msg_flags = 0;
+	pid_msg.x_msg_header.msg_type  = MSG_SMS_REMOVE_PID_FILTER_REQ;
+	pid_msg.x_msg_header.msg_length = sizeof(pid_msg);
+	pid_msg.msg_data[0] = feed->pid;
 
 	return smsclient_sendrequest(client->smsclient,
-				     &PidMsg, sizeof(PidMsg));
+				     &pid_msg, sizeof(pid_msg));
 }
 
 static int smsdvb_sendrequest_and_wait(struct smsdvb_client_t *client,
@@ -694,7 +694,7 @@ static int smsdvb_sendrequest_and_wait(struct smsdvb_client_t *client,
 static int smsdvb_send_statistics_request(struct smsdvb_client_t *client)
 {
 	int rc;
-	struct sms_msg_hdr Msg;
+	struct sms_msg_hdr msg;
 
 	/* Don't request stats too fast */
 	if (client->get_stats_jiffies &&
@@ -702,10 +702,10 @@ static int smsdvb_send_statistics_request(struct smsdvb_client_t *client)
 		return 0;
 	client->get_stats_jiffies = jiffies + msecs_to_jiffies(100);
 
-	Msg.msg_src_id = DVBT_BDA_CONTROL_MSG_ID;
-	Msg.msg_dst_id = HIF_TASK;
-	Msg.msg_flags = 0;
-	Msg.msg_length = sizeof(Msg);
+	msg.msg_src_id = DVBT_BDA_CONTROL_MSG_ID;
+	msg.msg_dst_id = HIF_TASK;
+	msg.msg_flags = 0;
+	msg.msg_length = sizeof(msg);
 
 	switch (smscore_get_device_mode(client->coredev)) {
 	case DEVICE_MODE_ISDBT:
@@ -714,15 +714,15 @@ static int smsdvb_send_statistics_request(struct smsdvb_client_t *client)
 		* Check for firmware version, to avoid breaking for old cards
 		*/
 		if (client->coredev->fw_version >= 0x800)
-			Msg.msg_type = MSG_SMS_GET_STATISTICS_EX_REQ;
+			msg.msg_type = MSG_SMS_GET_STATISTICS_EX_REQ;
 		else
-			Msg.msg_type = MSG_SMS_GET_STATISTICS_REQ;
+			msg.msg_type = MSG_SMS_GET_STATISTICS_REQ;
 		break;
 	default:
-		Msg.msg_type = MSG_SMS_GET_STATISTICS_REQ;
+		msg.msg_type = MSG_SMS_GET_STATISTICS_REQ;
 	}
 
-	rc = smsdvb_sendrequest_and_wait(client, &Msg, sizeof(Msg),
+	rc = smsdvb_sendrequest_and_wait(client, &msg, sizeof(msg),
 					 &client->stats_done);
 
 	return rc;
@@ -845,9 +845,9 @@ static int smsdvb_dvbt_set_frontend(struct dvb_frontend *fe)
 		container_of(fe, struct smsdvb_client_t, frontend);
 
 	struct {
-		struct sms_msg_hdr	Msg;
+		struct sms_msg_hdr	msg;
 		u32		Data[3];
-	} Msg;
+	} msg;
 
 	int ret;
 
@@ -856,26 +856,26 @@ static int smsdvb_dvbt_set_frontend(struct dvb_frontend *fe)
 	client->event_unc_state = -1;
 	fe->dtv_property_cache.delivery_system = SYS_DVBT;
 
-	Msg.Msg.msg_src_id = DVBT_BDA_CONTROL_MSG_ID;
-	Msg.Msg.msg_dst_id = HIF_TASK;
-	Msg.Msg.msg_flags = 0;
-	Msg.Msg.msg_type = MSG_SMS_RF_TUNE_REQ;
-	Msg.Msg.msg_length = sizeof(Msg);
-	Msg.Data[0] = c->frequency;
-	Msg.Data[2] = 12000000;
+	msg.msg.msg_src_id = DVBT_BDA_CONTROL_MSG_ID;
+	msg.msg.msg_dst_id = HIF_TASK;
+	msg.msg.msg_flags = 0;
+	msg.msg.msg_type = MSG_SMS_RF_TUNE_REQ;
+	msg.msg.msg_length = sizeof(msg);
+	msg.Data[0] = c->frequency;
+	msg.Data[2] = 12000000;
 
 	sms_info("%s: freq %d band %d", __func__, c->frequency,
 		 c->bandwidth_hz);
 
 	switch (c->bandwidth_hz / 1000000) {
 	case 8:
-		Msg.Data[1] = BW_8_MHZ;
+		msg.Data[1] = BW_8_MHZ;
 		break;
 	case 7:
-		Msg.Data[1] = BW_7_MHZ;
+		msg.Data[1] = BW_7_MHZ;
 		break;
 	case 6:
-		Msg.Data[1] = BW_6_MHZ;
+		msg.Data[1] = BW_6_MHZ;
 		break;
 	case 0:
 		return -EOPNOTSUPP;
@@ -888,7 +888,7 @@ static int smsdvb_dvbt_set_frontend(struct dvb_frontend *fe)
 		fe_status_t status;
 
 		/* tune with LNA off at first */
-		ret = smsdvb_sendrequest_and_wait(client, &Msg, sizeof(Msg),
+		ret = smsdvb_sendrequest_and_wait(client, &msg, sizeof(msg),
 						  &client->tune_done);
 
 		smsdvb_read_status(fe, &status);
@@ -900,7 +900,7 @@ static int smsdvb_dvbt_set_frontend(struct dvb_frontend *fe)
 		sms_board_lna_control(client->coredev, 1);
 	}
 
-	return smsdvb_sendrequest_and_wait(client, &Msg, sizeof(Msg),
+	return smsdvb_sendrequest_and_wait(client, &msg, sizeof(msg),
 					   &client->tune_done);
 }
 
@@ -915,17 +915,17 @@ static int smsdvb_isdbt_set_frontend(struct dvb_frontend *fe)
 	int ret;
 
 	struct {
-		struct sms_msg_hdr	Msg;
+		struct sms_msg_hdr	msg;
 		u32		Data[4];
-	} Msg;
+	} msg;
 
 	fe->dtv_property_cache.delivery_system = SYS_ISDBT;
 
-	Msg.Msg.msg_src_id  = DVBT_BDA_CONTROL_MSG_ID;
-	Msg.Msg.msg_dst_id  = HIF_TASK;
-	Msg.Msg.msg_flags  = 0;
-	Msg.Msg.msg_type   = MSG_SMS_ISDBT_TUNE_REQ;
-	Msg.Msg.msg_length = sizeof(Msg);
+	msg.msg.msg_src_id  = DVBT_BDA_CONTROL_MSG_ID;
+	msg.msg.msg_dst_id  = HIF_TASK;
+	msg.msg.msg_flags  = 0;
+	msg.msg.msg_type   = MSG_SMS_ISDBT_TUNE_REQ;
+	msg.msg.msg_length = sizeof(msg);
 
 	if (c->isdbt_sb_segment_idx == -1)
 		c->isdbt_sb_segment_idx = 0;
@@ -933,19 +933,19 @@ static int smsdvb_isdbt_set_frontend(struct dvb_frontend *fe)
 	if (!c->isdbt_layer_enabled)
 		c->isdbt_layer_enabled = 7;
 
-	Msg.Data[0] = c->frequency;
-	Msg.Data[1] = BW_ISDBT_1SEG;
-	Msg.Data[2] = 12000000;
-	Msg.Data[3] = c->isdbt_sb_segment_idx;
+	msg.Data[0] = c->frequency;
+	msg.Data[1] = BW_ISDBT_1SEG;
+	msg.Data[2] = 12000000;
+	msg.Data[3] = c->isdbt_sb_segment_idx;
 
 	if (c->isdbt_partial_reception) {
 		if ((type == SMS_PELE || type == SMS_RIO) &&
 		    c->isdbt_sb_segment_count > 3)
-			Msg.Data[1] = BW_ISDBT_13SEG;
+			msg.Data[1] = BW_ISDBT_13SEG;
 		else if (c->isdbt_sb_segment_count > 1)
-			Msg.Data[1] = BW_ISDBT_3SEG;
+			msg.Data[1] = BW_ISDBT_3SEG;
 	} else if (type == SMS_PELE || type == SMS_RIO)
-		Msg.Data[1] = BW_ISDBT_13SEG;
+		msg.Data[1] = BW_ISDBT_13SEG;
 
 	c->bandwidth_hz = 6000000;
 
@@ -959,7 +959,7 @@ static int smsdvb_isdbt_set_frontend(struct dvb_frontend *fe)
 		fe_status_t status;
 
 		/* tune with LNA off at first */
-		ret = smsdvb_sendrequest_and_wait(client, &Msg, sizeof(Msg),
+		ret = smsdvb_sendrequest_and_wait(client, &msg, sizeof(msg),
 						  &client->tune_done);
 
 		smsdvb_read_status(fe, &status);
@@ -970,7 +970,7 @@ static int smsdvb_isdbt_set_frontend(struct dvb_frontend *fe)
 		/* previous tune didn't lock - enable LNA and tune again */
 		sms_board_lna_control(client->coredev, 1);
 	}
-	return smsdvb_sendrequest_and_wait(client, &Msg, sizeof(Msg),
+	return smsdvb_sendrequest_and_wait(client, &msg, sizeof(msg),
 					   &client->tune_done);
 }
 

commit cf0e9cfcc70d8aaeabf19356f42041f8a5495301
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Thu Mar 21 09:06:03 2013 -0300

    [media] siano: convert structure names to lowercase
    
    There are several structures defined in uppercase. Convert them
    to lowercase, and simplify their names, when possible.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/common/siano/smsdvb-main.c b/drivers/media/common/siano/smsdvb-main.c
index cec85fef2a1b..29d1c41bbd66 100644
--- a/drivers/media/common/siano/smsdvb-main.c
+++ b/drivers/media/common/siano/smsdvb-main.c
@@ -223,7 +223,7 @@ static inline u32 sms_to_bw(u32 value)
 			   FEC_NONE);
 
 static void smsdvb_update_tx_params(struct smsdvb_client_t *client,
-				    struct TRANSMISSION_STATISTICS_S *p)
+				    struct sms_tx_stats *p)
 {
 	struct dvb_frontend *fe = &client->frontend;
 	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
@@ -277,7 +277,7 @@ static void smsdvb_update_per_slices(struct smsdvb_client_t *client,
 }
 
 static void smsdvb_update_dvb_stats(struct smsdvb_client_t *client,
-				    struct SMSHOSTLIB_STATISTICS_ST *p)
+				    struct sms_stats *p)
 {
 	struct dvb_frontend *fe = &client->frontend;
 	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
@@ -329,11 +329,11 @@ static void smsdvb_update_dvb_stats(struct smsdvb_client_t *client,
 };
 
 static void smsdvb_update_isdbt_stats(struct smsdvb_client_t *client,
-				      struct SMSHOSTLIB_STATISTICS_ISDBT_ST *p)
+				      struct sms_isdbt_stats *p)
 {
 	struct dvb_frontend *fe = &client->frontend;
 	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
-	struct SMSHOSTLIB_ISDBT_LAYER_STAT_ST *lr;
+	struct sms_isdbt_layer_stats *lr;
 	int i, n_layers;
 
 	if (client->prt_isdb_stats)
@@ -425,11 +425,11 @@ static void smsdvb_update_isdbt_stats(struct smsdvb_client_t *client,
 }
 
 static void smsdvb_update_isdbt_stats_ex(struct smsdvb_client_t *client,
-					 struct SMSHOSTLIB_STATISTICS_ISDBT_EX_ST *p)
+					 struct sms_isdbt_stats_ex *p)
 {
 	struct dvb_frontend *fe = &client->frontend;
 	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
-	struct SMSHOSTLIB_ISDBT_LAYER_STAT_ST *lr;
+	struct sms_isdbt_layer_stats *lr;
 	int i, n_layers;
 
 	if (client->prt_isdb_stats_ex)

commit dfef84fc135832ad5c270758b6834fcb4bf448fc
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Thu Mar 21 08:49:43 2013 -0300

    [media] siano: get rid of CammelCase from smscoreapi.h
    
    It is almost impossible to see a compliant with checkpatch.pl
    on those Siano drivers, as there are simply too much violations
    on it. So, now that a big change was done, the better is to
    cleanup the checkpatch compliants.
    
    Let's first replace all CammelCase symbols found at smscoreapi.h
    using camel_case namespace. That removed 144 checkpatch.pl
    compliants on this file. Of course, the other files need to be
    fixed accordingly.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/common/siano/smsdvb-main.c b/drivers/media/common/siano/smsdvb-main.c
index a2882f5cfdd0..cec85fef2a1b 100644
--- a/drivers/media/common/siano/smsdvb-main.c
+++ b/drivers/media/common/siano/smsdvb-main.c
@@ -228,15 +228,15 @@ static void smsdvb_update_tx_params(struct smsdvb_client_t *client,
 	struct dvb_frontend *fe = &client->frontend;
 	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
 
-	c->frequency = p->Frequency;
-	client->fe_status = sms_to_status(p->IsDemodLocked, 0);
-	c->bandwidth_hz = sms_to_bw(p->Bandwidth);
-	c->transmission_mode = sms_to_mode(p->TransmissionMode);
-	c->guard_interval = sms_to_guard_interval(p->GuardInterval);
-	c->code_rate_HP = sms_to_code_rate(p->CodeRate);
-	c->code_rate_LP = sms_to_code_rate(p->LPCodeRate);
-	c->hierarchy = sms_to_hierarchy(p->Hierarchy);
-	c->modulation = sms_to_modulation(p->Constellation);
+	c->frequency = p->frequency;
+	client->fe_status = sms_to_status(p->is_demod_locked, 0);
+	c->bandwidth_hz = sms_to_bw(p->bandwidth);
+	c->transmission_mode = sms_to_mode(p->transmission_mode);
+	c->guard_interval = sms_to_guard_interval(p->guard_interval);
+	c->code_rate_HP = sms_to_code_rate(p->code_rate);
+	c->code_rate_LP = sms_to_code_rate(p->lp_code_rate);
+	c->hierarchy = sms_to_hierarchy(p->hierarchy);
+	c->modulation = sms_to_modulation(p->constellation);
 }
 
 static void smsdvb_update_per_slices(struct smsdvb_client_t *client,
@@ -245,35 +245,35 @@ static void smsdvb_update_per_slices(struct smsdvb_client_t *client,
 	struct dvb_frontend *fe = &client->frontend;
 	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
 
-	client->fe_status = sms_to_status(p->IsDemodLocked, p->IsRfLocked);
+	client->fe_status = sms_to_status(p->is_demod_locked, p->is_rf_locked);
 	c->modulation = sms_to_modulation(p->constellation);
 
-	/* Signal Strength, in DBm */
-	c->strength.stat[0].uvalue = p->inBandPower * 1000;
+	/* signal Strength, in DBm */
+	c->strength.stat[0].uvalue = p->in_band_power * 1000;
 
-	/* Carrier to Noise ratio, in DB */
+	/* Carrier to noise ratio, in DB */
 	c->cnr.stat[0].svalue = p->snr * 1000;
 
 	/* PER/BER requires demod lock */
-	if (!p->IsDemodLocked)
+	if (!p->is_demod_locked)
 		return;
 
 	/* TS PER */
 	client->last_per = c->block_error.stat[0].uvalue;
 	c->block_error.stat[0].scale = FE_SCALE_COUNTER;
 	c->block_count.stat[0].scale = FE_SCALE_COUNTER;
-	c->block_error.stat[0].uvalue += p->etsPackets;
-	c->block_count.stat[0].uvalue += p->etsPackets + p->tsPackets;
+	c->block_error.stat[0].uvalue += p->ets_packets;
+	c->block_count.stat[0].uvalue += p->ets_packets + p->ts_packets;
 
 	/* BER */
 	c->post_bit_error.stat[0].scale = FE_SCALE_COUNTER;
 	c->post_bit_count.stat[0].scale = FE_SCALE_COUNTER;
-	c->post_bit_error.stat[0].uvalue += p->BERErrorCount;
-	c->post_bit_count.stat[0].uvalue += p->BERBitCount;
+	c->post_bit_error.stat[0].uvalue += p->ber_error_count;
+	c->post_bit_count.stat[0].uvalue += p->ber_bit_count;
 
 	/* Legacy PER/BER */
-	client->legacy_per = (p->etsPackets * 65535) /
-			     (p->tsPackets + p->etsPackets);
+	client->legacy_per = (p->ets_packets * 65535) /
+			     (p->ts_packets + p->ets_packets);
 }
 
 static void smsdvb_update_dvb_stats(struct smsdvb_client_t *client,
@@ -285,44 +285,44 @@ static void smsdvb_update_dvb_stats(struct smsdvb_client_t *client,
 	if (client->prt_dvb_stats)
 		client->prt_dvb_stats(client->debug_data, p);
 
-	client->fe_status = sms_to_status(p->IsDemodLocked, p->IsRfLocked);
+	client->fe_status = sms_to_status(p->is_demod_locked, p->is_rf_locked);
 
 	/* Update DVB modulation parameters */
-	c->frequency = p->Frequency;
-	client->fe_status = sms_to_status(p->IsDemodLocked, 0);
-	c->bandwidth_hz = sms_to_bw(p->Bandwidth);
-	c->transmission_mode = sms_to_mode(p->TransmissionMode);
-	c->guard_interval = sms_to_guard_interval(p->GuardInterval);
-	c->code_rate_HP = sms_to_code_rate(p->CodeRate);
-	c->code_rate_LP = sms_to_code_rate(p->LPCodeRate);
-	c->hierarchy = sms_to_hierarchy(p->Hierarchy);
-	c->modulation = sms_to_modulation(p->Constellation);
+	c->frequency = p->frequency;
+	client->fe_status = sms_to_status(p->is_demod_locked, 0);
+	c->bandwidth_hz = sms_to_bw(p->bandwidth);
+	c->transmission_mode = sms_to_mode(p->transmission_mode);
+	c->guard_interval = sms_to_guard_interval(p->guard_interval);
+	c->code_rate_HP = sms_to_code_rate(p->code_rate);
+	c->code_rate_LP = sms_to_code_rate(p->lp_code_rate);
+	c->hierarchy = sms_to_hierarchy(p->hierarchy);
+	c->modulation = sms_to_modulation(p->constellation);
 
 	/* update reception data */
-	c->lna = p->IsExternalLNAOn ? 1 : 0;
+	c->lna = p->is_external_lna_on ? 1 : 0;
 
-	/* Carrier to Noise ratio, in DB */
+	/* Carrier to noise ratio, in DB */
 	c->cnr.stat[0].svalue = p->SNR * 1000;
 
-	/* Signal Strength, in DBm */
-	c->strength.stat[0].uvalue = p->InBandPwr * 1000;
+	/* signal Strength, in DBm */
+	c->strength.stat[0].uvalue = p->in_band_pwr * 1000;
 
 	/* PER/BER requires demod lock */
-	if (!p->IsDemodLocked)
+	if (!p->is_demod_locked)
 		return;
 
 	/* TS PER */
 	client->last_per = c->block_error.stat[0].uvalue;
 	c->block_error.stat[0].scale = FE_SCALE_COUNTER;
 	c->block_count.stat[0].scale = FE_SCALE_COUNTER;
-	c->block_error.stat[0].uvalue += p->ErrorTSPackets;
-	c->block_count.stat[0].uvalue += p->TotalTSPackets;
+	c->block_error.stat[0].uvalue += p->error_ts_packets;
+	c->block_count.stat[0].uvalue += p->total_ts_packets;
 
 	/* BER */
 	c->post_bit_error.stat[0].scale = FE_SCALE_COUNTER;
 	c->post_bit_count.stat[0].scale = FE_SCALE_COUNTER;
-	c->post_bit_error.stat[0].uvalue += p->BERErrorCount;
-	c->post_bit_count.stat[0].uvalue += p->BERBitCount;
+	c->post_bit_error.stat[0].uvalue += p->ber_error_count;
+	c->post_bit_count.stat[0].uvalue += p->ber_bit_count;
 
 	/* Legacy PER/BER */
 	client->legacy_ber = p->BER;
@@ -339,26 +339,26 @@ static void smsdvb_update_isdbt_stats(struct smsdvb_client_t *client,
 	if (client->prt_isdb_stats)
 		client->prt_isdb_stats(client->debug_data, p);
 
-	client->fe_status = sms_to_status(p->IsDemodLocked, p->IsRfLocked);
+	client->fe_status = sms_to_status(p->is_demod_locked, p->is_rf_locked);
 
 	/*
 	 * Firmware 2.1 seems to report only lock status and
-	 * Signal strength. The signal strength indicator is at the
+	 * signal strength. The signal strength indicator is at the
 	 * wrong field.
 	 */
-	if (p->StatisticsType == 0) {
-		c->strength.stat[0].uvalue = ((s32)p->TransmissionMode) * 1000;
+	if (p->statistics_type == 0) {
+		c->strength.stat[0].uvalue = ((s32)p->transmission_mode) * 1000;
 		c->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
 		return;
 	}
 
 	/* Update ISDB-T transmission parameters */
-	c->frequency = p->Frequency;
-	c->bandwidth_hz = sms_to_bw(p->Bandwidth);
-	c->transmission_mode = sms_to_mode(p->TransmissionMode);
-	c->guard_interval = sms_to_guard_interval(p->GuardInterval);
-	c->isdbt_partial_reception = p->PartialReception ? 1 : 0;
-	n_layers = p->NumOfLayers;
+	c->frequency = p->frequency;
+	c->bandwidth_hz = sms_to_bw(p->bandwidth);
+	c->transmission_mode = sms_to_mode(p->transmission_mode);
+	c->guard_interval = sms_to_guard_interval(p->guard_interval);
+	c->isdbt_partial_reception = p->partial_reception ? 1 : 0;
+	n_layers = p->num_of_layers;
 	if (n_layers < 1)
 		n_layers = 1;
 	if (n_layers > 3)
@@ -366,16 +366,16 @@ static void smsdvb_update_isdbt_stats(struct smsdvb_client_t *client,
 	c->isdbt_layer_enabled = 0;
 
 	/* update reception data */
-	c->lna = p->IsExternalLNAOn ? 1 : 0;
+	c->lna = p->is_external_lna_on ? 1 : 0;
 
-	/* Carrier to Noise ratio, in DB */
+	/* Carrier to noise ratio, in DB */
 	c->cnr.stat[0].svalue = p->SNR * 1000;
 
-	/* Signal Strength, in DBm */
-	c->strength.stat[0].uvalue = p->InBandPwr * 1000;
+	/* signal Strength, in DBm */
+	c->strength.stat[0].uvalue = p->in_band_pwr * 1000;
 
 	/* PER/BER and per-layer stats require demod lock */
-	if (!p->IsDemodLocked)
+	if (!p->is_demod_locked)
 		return;
 
 	client->last_per = c->block_error.stat[0].uvalue;
@@ -394,33 +394,33 @@ static void smsdvb_update_isdbt_stats(struct smsdvb_client_t *client,
 		lr = &p->LayerInfo[i];
 
 		/* Update per-layer transmission parameters */
-		if (lr->NumberOfSegments > 0 && lr->NumberOfSegments < 13) {
+		if (lr->number_of_segments > 0 && lr->number_of_segments < 13) {
 			c->isdbt_layer_enabled |= 1 << i;
-			c->layer[i].segment_count = lr->NumberOfSegments;
+			c->layer[i].segment_count = lr->number_of_segments;
 		} else {
 			continue;
 		}
-		c->layer[i].modulation = sms_to_modulation(lr->Constellation);
+		c->layer[i].modulation = sms_to_modulation(lr->constellation);
 
 		/* TS PER */
 		c->block_error.stat[i + 1].scale = FE_SCALE_COUNTER;
 		c->block_count.stat[i + 1].scale = FE_SCALE_COUNTER;
-		c->block_error.stat[i + 1].uvalue += lr->ErrorTSPackets;
-		c->block_count.stat[i + 1].uvalue += lr->TotalTSPackets;
+		c->block_error.stat[i + 1].uvalue += lr->error_ts_packets;
+		c->block_count.stat[i + 1].uvalue += lr->total_ts_packets;
 
 		/* Update global PER counter */
-		c->block_error.stat[0].uvalue += lr->ErrorTSPackets;
-		c->block_count.stat[0].uvalue += lr->TotalTSPackets;
+		c->block_error.stat[0].uvalue += lr->error_ts_packets;
+		c->block_count.stat[0].uvalue += lr->total_ts_packets;
 
 		/* BER */
 		c->post_bit_error.stat[i + 1].scale = FE_SCALE_COUNTER;
 		c->post_bit_count.stat[i + 1].scale = FE_SCALE_COUNTER;
-		c->post_bit_error.stat[i + 1].uvalue += lr->BERErrorCount;
-		c->post_bit_count.stat[i + 1].uvalue += lr->BERBitCount;
+		c->post_bit_error.stat[i + 1].uvalue += lr->ber_error_count;
+		c->post_bit_count.stat[i + 1].uvalue += lr->ber_bit_count;
 
 		/* Update global BER counter */
-		c->post_bit_error.stat[0].uvalue += lr->BERErrorCount;
-		c->post_bit_count.stat[0].uvalue += lr->BERBitCount;
+		c->post_bit_error.stat[0].uvalue += lr->ber_error_count;
+		c->post_bit_count.stat[0].uvalue += lr->ber_bit_count;
 	}
 }
 
@@ -436,13 +436,13 @@ static void smsdvb_update_isdbt_stats_ex(struct smsdvb_client_t *client,
 		client->prt_isdb_stats_ex(client->debug_data, p);
 
 	/* Update ISDB-T transmission parameters */
-	c->frequency = p->Frequency;
-	client->fe_status = sms_to_status(p->IsDemodLocked, 0);
-	c->bandwidth_hz = sms_to_bw(p->Bandwidth);
-	c->transmission_mode = sms_to_mode(p->TransmissionMode);
-	c->guard_interval = sms_to_guard_interval(p->GuardInterval);
-	c->isdbt_partial_reception = p->PartialReception ? 1 : 0;
-	n_layers = p->NumOfLayers;
+	c->frequency = p->frequency;
+	client->fe_status = sms_to_status(p->is_demod_locked, 0);
+	c->bandwidth_hz = sms_to_bw(p->bandwidth);
+	c->transmission_mode = sms_to_mode(p->transmission_mode);
+	c->guard_interval = sms_to_guard_interval(p->guard_interval);
+	c->isdbt_partial_reception = p->partial_reception ? 1 : 0;
+	n_layers = p->num_of_layers;
 	if (n_layers < 1)
 		n_layers = 1;
 	if (n_layers > 3)
@@ -450,16 +450,16 @@ static void smsdvb_update_isdbt_stats_ex(struct smsdvb_client_t *client,
 	c->isdbt_layer_enabled = 0;
 
 	/* update reception data */
-	c->lna = p->IsExternalLNAOn ? 1 : 0;
+	c->lna = p->is_external_lna_on ? 1 : 0;
 
-	/* Carrier to Noise ratio, in DB */
+	/* Carrier to noise ratio, in DB */
 	c->cnr.stat[0].svalue = p->SNR * 1000;
 
-	/* Signal Strength, in DBm */
-	c->strength.stat[0].uvalue = p->InBandPwr * 1000;
+	/* signal Strength, in DBm */
+	c->strength.stat[0].uvalue = p->in_band_pwr * 1000;
 
 	/* PER/BER and per-layer stats require demod lock */
-	if (!p->IsDemodLocked)
+	if (!p->is_demod_locked)
 		return;
 
 	client->last_per = c->block_error.stat[0].uvalue;
@@ -482,47 +482,47 @@ static void smsdvb_update_isdbt_stats_ex(struct smsdvb_client_t *client,
 		lr = &p->LayerInfo[i];
 
 		/* Update per-layer transmission parameters */
-		if (lr->NumberOfSegments > 0 && lr->NumberOfSegments < 13) {
+		if (lr->number_of_segments > 0 && lr->number_of_segments < 13) {
 			c->isdbt_layer_enabled |= 1 << i;
-			c->layer[i].segment_count = lr->NumberOfSegments;
+			c->layer[i].segment_count = lr->number_of_segments;
 		} else {
 			continue;
 		}
-		c->layer[i].modulation = sms_to_modulation(lr->Constellation);
+		c->layer[i].modulation = sms_to_modulation(lr->constellation);
 
 		/* TS PER */
 		c->block_error.stat[i + 1].scale = FE_SCALE_COUNTER;
 		c->block_count.stat[i + 1].scale = FE_SCALE_COUNTER;
-		c->block_error.stat[i + 1].uvalue += lr->ErrorTSPackets;
-		c->block_count.stat[i + 1].uvalue += lr->TotalTSPackets;
+		c->block_error.stat[i + 1].uvalue += lr->error_ts_packets;
+		c->block_count.stat[i + 1].uvalue += lr->total_ts_packets;
 
 		/* Update global PER counter */
-		c->block_error.stat[0].uvalue += lr->ErrorTSPackets;
-		c->block_count.stat[0].uvalue += lr->TotalTSPackets;
+		c->block_error.stat[0].uvalue += lr->error_ts_packets;
+		c->block_count.stat[0].uvalue += lr->total_ts_packets;
 
 		/* BER */
 		c->post_bit_error.stat[i + 1].scale = FE_SCALE_COUNTER;
 		c->post_bit_count.stat[i + 1].scale = FE_SCALE_COUNTER;
-		c->post_bit_error.stat[i + 1].uvalue += lr->BERErrorCount;
-		c->post_bit_count.stat[i + 1].uvalue += lr->BERBitCount;
+		c->post_bit_error.stat[i + 1].uvalue += lr->ber_error_count;
+		c->post_bit_count.stat[i + 1].uvalue += lr->ber_bit_count;
 
 		/* Update global BER counter */
-		c->post_bit_error.stat[0].uvalue += lr->BERErrorCount;
-		c->post_bit_count.stat[0].uvalue += lr->BERBitCount;
+		c->post_bit_error.stat[0].uvalue += lr->ber_error_count;
+		c->post_bit_count.stat[0].uvalue += lr->ber_bit_count;
 	}
 }
 
 static int smsdvb_onresponse(void *context, struct smscore_buffer_t *cb)
 {
 	struct smsdvb_client_t *client = (struct smsdvb_client_t *) context;
-	struct SmsMsgHdr_ST *phdr = (struct SmsMsgHdr_ST *) (((u8 *) cb->p)
+	struct sms_msg_hdr *phdr = (struct sms_msg_hdr *) (((u8 *) cb->p)
 			+ cb->offset);
 	void *p = phdr + 1;
 	struct dvb_frontend *fe = &client->frontend;
 	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
 	bool is_status_update = false;
 
-	switch (phdr->msgType) {
+	switch (phdr->msg_type) {
 	case MSG_SMS_DVBT_BDA_DATA:
 		/*
 		 * Only feed data to dvb demux if are there any feed listening
@@ -530,7 +530,7 @@ static int smsdvb_onresponse(void *context, struct smscore_buffer_t *cb)
 		 */
 		if (client->feed_users && client->has_tuned)
 			dvb_dmx_swfilter(&client->demux, p,
-					 cb->size - sizeof(struct SmsMsgHdr_ST));
+					 cb->size - sizeof(struct sms_msg_hdr));
 		break;
 
 	case MSG_SMS_RF_TUNE_RES:
@@ -571,7 +571,7 @@ static int smsdvb_onresponse(void *context, struct smscore_buffer_t *cb)
 			smsdvb_update_isdbt_stats(client, p);
 			break;
 		default:
-			/* Skip SmsMsgStatisticsInfo_ST:RequestResult field */
+			/* Skip sms_msg_statistics_info:request_result field */
 			smsdvb_update_dvb_stats(client, p + sizeof(u32));
 		}
 
@@ -580,7 +580,7 @@ static int smsdvb_onresponse(void *context, struct smscore_buffer_t *cb)
 
 	/* Only for ISDB-T */
 	case MSG_SMS_GET_STATISTICS_EX_RES:
-		/* Skip SmsMsgStatisticsInfo_ST:RequestResult field? */
+		/* Skip sms_msg_statistics_info:request_result field? */
 		smsdvb_update_isdbt_stats_ex(client, p + sizeof(u32));
 		is_status_update = true;
 		break;
@@ -636,18 +636,18 @@ static int smsdvb_start_feed(struct dvb_demux_feed *feed)
 {
 	struct smsdvb_client_t *client =
 		container_of(feed->demux, struct smsdvb_client_t, demux);
-	struct SmsMsgData_ST PidMsg;
+	struct sms_msg_data PidMsg;
 
 	sms_debug("add pid %d(%x)",
 		  feed->pid, feed->pid);
 
 	client->feed_users++;
 
-	PidMsg.xMsgHeader.msgSrcId = DVBT_BDA_CONTROL_MSG_ID;
-	PidMsg.xMsgHeader.msgDstId = HIF_TASK;
-	PidMsg.xMsgHeader.msgFlags = 0;
-	PidMsg.xMsgHeader.msgType  = MSG_SMS_ADD_PID_FILTER_REQ;
-	PidMsg.xMsgHeader.msgLength = sizeof(PidMsg);
+	PidMsg.x_msg_header.msg_src_id = DVBT_BDA_CONTROL_MSG_ID;
+	PidMsg.x_msg_header.msg_dst_id = HIF_TASK;
+	PidMsg.x_msg_header.msg_flags = 0;
+	PidMsg.x_msg_header.msg_type  = MSG_SMS_ADD_PID_FILTER_REQ;
+	PidMsg.x_msg_header.msg_length = sizeof(PidMsg);
 	PidMsg.msgData[0] = feed->pid;
 
 	return smsclient_sendrequest(client->smsclient,
@@ -658,18 +658,18 @@ static int smsdvb_stop_feed(struct dvb_demux_feed *feed)
 {
 	struct smsdvb_client_t *client =
 		container_of(feed->demux, struct smsdvb_client_t, demux);
-	struct SmsMsgData_ST PidMsg;
+	struct sms_msg_data PidMsg;
 
 	sms_debug("remove pid %d(%x)",
 		  feed->pid, feed->pid);
 
 	client->feed_users--;
 
-	PidMsg.xMsgHeader.msgSrcId = DVBT_BDA_CONTROL_MSG_ID;
-	PidMsg.xMsgHeader.msgDstId = HIF_TASK;
-	PidMsg.xMsgHeader.msgFlags = 0;
-	PidMsg.xMsgHeader.msgType  = MSG_SMS_REMOVE_PID_FILTER_REQ;
-	PidMsg.xMsgHeader.msgLength = sizeof(PidMsg);
+	PidMsg.x_msg_header.msg_src_id = DVBT_BDA_CONTROL_MSG_ID;
+	PidMsg.x_msg_header.msg_dst_id = HIF_TASK;
+	PidMsg.x_msg_header.msg_flags = 0;
+	PidMsg.x_msg_header.msg_type  = MSG_SMS_REMOVE_PID_FILTER_REQ;
+	PidMsg.x_msg_header.msg_length = sizeof(PidMsg);
 	PidMsg.msgData[0] = feed->pid;
 
 	return smsclient_sendrequest(client->smsclient,
@@ -694,7 +694,7 @@ static int smsdvb_sendrequest_and_wait(struct smsdvb_client_t *client,
 static int smsdvb_send_statistics_request(struct smsdvb_client_t *client)
 {
 	int rc;
-	struct SmsMsgHdr_ST Msg;
+	struct sms_msg_hdr Msg;
 
 	/* Don't request stats too fast */
 	if (client->get_stats_jiffies &&
@@ -702,10 +702,10 @@ static int smsdvb_send_statistics_request(struct smsdvb_client_t *client)
 		return 0;
 	client->get_stats_jiffies = jiffies + msecs_to_jiffies(100);
 
-	Msg.msgSrcId = DVBT_BDA_CONTROL_MSG_ID;
-	Msg.msgDstId = HIF_TASK;
-	Msg.msgFlags = 0;
-	Msg.msgLength = sizeof(Msg);
+	Msg.msg_src_id = DVBT_BDA_CONTROL_MSG_ID;
+	Msg.msg_dst_id = HIF_TASK;
+	Msg.msg_flags = 0;
+	Msg.msg_length = sizeof(Msg);
 
 	switch (smscore_get_device_mode(client->coredev)) {
 	case DEVICE_MODE_ISDBT:
@@ -714,12 +714,12 @@ static int smsdvb_send_statistics_request(struct smsdvb_client_t *client)
 		* Check for firmware version, to avoid breaking for old cards
 		*/
 		if (client->coredev->fw_version >= 0x800)
-			Msg.msgType = MSG_SMS_GET_STATISTICS_EX_REQ;
+			Msg.msg_type = MSG_SMS_GET_STATISTICS_EX_REQ;
 		else
-			Msg.msgType = MSG_SMS_GET_STATISTICS_REQ;
+			Msg.msg_type = MSG_SMS_GET_STATISTICS_REQ;
 		break;
 	default:
-		Msg.msgType = MSG_SMS_GET_STATISTICS_REQ;
+		Msg.msg_type = MSG_SMS_GET_STATISTICS_REQ;
 	}
 
 	rc = smsdvb_sendrequest_and_wait(client, &Msg, sizeof(Msg),
@@ -845,7 +845,7 @@ static int smsdvb_dvbt_set_frontend(struct dvb_frontend *fe)
 		container_of(fe, struct smsdvb_client_t, frontend);
 
 	struct {
-		struct SmsMsgHdr_ST	Msg;
+		struct sms_msg_hdr	Msg;
 		u32		Data[3];
 	} Msg;
 
@@ -856,11 +856,11 @@ static int smsdvb_dvbt_set_frontend(struct dvb_frontend *fe)
 	client->event_unc_state = -1;
 	fe->dtv_property_cache.delivery_system = SYS_DVBT;
 
-	Msg.Msg.msgSrcId = DVBT_BDA_CONTROL_MSG_ID;
-	Msg.Msg.msgDstId = HIF_TASK;
-	Msg.Msg.msgFlags = 0;
-	Msg.Msg.msgType = MSG_SMS_RF_TUNE_REQ;
-	Msg.Msg.msgLength = sizeof(Msg);
+	Msg.Msg.msg_src_id = DVBT_BDA_CONTROL_MSG_ID;
+	Msg.Msg.msg_dst_id = HIF_TASK;
+	Msg.Msg.msg_flags = 0;
+	Msg.Msg.msg_type = MSG_SMS_RF_TUNE_REQ;
+	Msg.Msg.msg_length = sizeof(Msg);
 	Msg.Data[0] = c->frequency;
 	Msg.Data[2] = 12000000;
 
@@ -915,17 +915,17 @@ static int smsdvb_isdbt_set_frontend(struct dvb_frontend *fe)
 	int ret;
 
 	struct {
-		struct SmsMsgHdr_ST	Msg;
+		struct sms_msg_hdr	Msg;
 		u32		Data[4];
 	} Msg;
 
 	fe->dtv_property_cache.delivery_system = SYS_ISDBT;
 
-	Msg.Msg.msgSrcId  = DVBT_BDA_CONTROL_MSG_ID;
-	Msg.Msg.msgDstId  = HIF_TASK;
-	Msg.Msg.msgFlags  = 0;
-	Msg.Msg.msgType   = MSG_SMS_ISDBT_TUNE_REQ;
-	Msg.Msg.msgLength = sizeof(Msg);
+	Msg.Msg.msg_src_id  = DVBT_BDA_CONTROL_MSG_ID;
+	Msg.Msg.msg_dst_id  = HIF_TASK;
+	Msg.Msg.msg_flags  = 0;
+	Msg.Msg.msg_type   = MSG_SMS_ISDBT_TUNE_REQ;
+	Msg.Msg.msg_length = sizeof(Msg);
 
 	if (c->isdbt_sb_segment_idx == -1)
 		c->isdbt_sb_segment_idx = 0;

commit 98c3f94e6db3b4df21336b41c646366ea417527c
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Tue Mar 19 13:06:28 2013 -0300

    [media] siano: remove doubled new line
    
    sms_debug() and sms_info() already adds a '\n' at the printed
    strings. No need to add more.
    That helps to cleanup stuff like:
            [ 4868.205648] smscore_onresponse: message not handled.
            [ 4868.205898] smscore_onresponse: message not handled.
    and:
            [ 5467.959769] smscore_onresponse:
            data rate 143069 bytes/secs
    While here, provides the message name, when the message is not
    handled by the smsmdtv core.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/common/siano/smsdvb-main.c b/drivers/media/common/siano/smsdvb-main.c
index c53cb4e8d0c6..a2882f5cfdd0 100644
--- a/drivers/media/common/siano/smsdvb-main.c
+++ b/drivers/media/common/siano/smsdvb-main.c
@@ -949,7 +949,7 @@ static int smsdvb_isdbt_set_frontend(struct dvb_frontend *fe)
 
 	c->bandwidth_hz = 6000000;
 
-	sms_info("%s: freq %d segwidth %d segindex %d\n", __func__,
+	sms_info("%s: freq %d segwidth %d segindex %d", __func__,
 		 c->frequency, c->isdbt_sb_segment_count,
 		 c->isdbt_sb_segment_idx);
 

commit 773adad14135999380a4652b4ba01c5694827870
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Sat Mar 16 21:05:30 2013 -0300

    [media] siano: fix status report with old firmware and ISDB-T
    
    This seems to be ever broken. That's the status report with
    Firmware 2.1, before adding support for sms2270 is:
    [22273.787218] smsdvb_onresponse: MSG_SMS_GET_STATISTICS_RES
    [22273.792592] IsRfLocked = 1
    [22273.792592] IsDemodLocked = 1
    ...
    [22273.792598] TransmissionMode = -64
    ...
    (all unshown fields are filled with zeros)
    Of course, transmission mode being a negative number is wrong.
    So, we need to take a deeper look on it.
    With the debugfs patches applied, it is possible to see that, instead
    of filling StatisticsType with 5, and FullSize with the size of the
    payload (this is what happens with sms2270 and firmware 8.1),
    those fields are also initialized with zero:
    StatisticsType = 0      FullSize = 0
    IsRfLocked = 1          IsDemodLocked = 1       IsExternalLNAOn = 0
    SNR = 0 dB              RSSI = 0 dBm            InBandPwr = 0 dBm
    CarrierOffset = 0       Bandwidth = 0           Frequency = 0 Hz
    TransmissionMode = -64  ModemState = 0          GuardInterval = 0
    SystemType = 0          PartialReception = 0    NumOfLayers = 0
    SmsToHostTxErrors = 0
    The data under "TransmissionMode" varies according with the signal,
    and it is negative. It also matches the value for InBandPwr when
    the tuner is on DVB-T (ok, signal doesn't lock, but the power level
    should be about the same with the antena fixed, and measured at about
    the same time).
    So, there's a very high chance that, when StatisticsType is zero, the
    signal strength is at the same position as Transmission Mode.
    So, discard all other parameters, and provide only signal/rf lock and
    signal strength if StatisticsType is 0, for ISDB-T.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/common/siano/smsdvb-main.c b/drivers/media/common/siano/smsdvb-main.c
index 4393c688d0ad..c53cb4e8d0c6 100644
--- a/drivers/media/common/siano/smsdvb-main.c
+++ b/drivers/media/common/siano/smsdvb-main.c
@@ -339,9 +339,21 @@ static void smsdvb_update_isdbt_stats(struct smsdvb_client_t *client,
 	if (client->prt_isdb_stats)
 		client->prt_isdb_stats(client->debug_data, p);
 
+	client->fe_status = sms_to_status(p->IsDemodLocked, p->IsRfLocked);
+
+	/*
+	 * Firmware 2.1 seems to report only lock status and
+	 * Signal strength. The signal strength indicator is at the
+	 * wrong field.
+	 */
+	if (p->StatisticsType == 0) {
+		c->strength.stat[0].uvalue = ((s32)p->TransmissionMode) * 1000;
+		c->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+		return;
+	}
+
 	/* Update ISDB-T transmission parameters */
 	c->frequency = p->Frequency;
-	client->fe_status = sms_to_status(p->IsDemodLocked, 0);
 	c->bandwidth_hz = sms_to_bw(p->Bandwidth);
 	c->transmission_mode = sms_to_mode(p->TransmissionMode);
 	c->guard_interval = sms_to_guard_interval(p->GuardInterval);

commit e1b2ac4d1e6bb214823c42bb807a6cc5f21aa223
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Fri Mar 15 07:22:08 2013 -0300

    [media] siano: Only feed DVB data when there's a feed
    
    Right now, the driver sends DVB data even before tunning.
    It was noticed that this may lead into some mistakes at DVB
    decode, as the PIDs from wrong channels may be associated with
    another frequency, as they may already be inside the PID buffers.
    So, prevent it by not feeding DVB demux with data while there's no
    feed or while the device is not tuned.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/common/siano/smsdvb-main.c b/drivers/media/common/siano/smsdvb-main.c
index d83896bb98fd..4393c688d0ad 100644
--- a/drivers/media/common/siano/smsdvb-main.c
+++ b/drivers/media/common/siano/smsdvb-main.c
@@ -512,8 +512,13 @@ static int smsdvb_onresponse(void *context, struct smscore_buffer_t *cb)
 
 	switch (phdr->msgType) {
 	case MSG_SMS_DVBT_BDA_DATA:
-		dvb_dmx_swfilter(&client->demux, p,
-				 cb->size - sizeof(struct SmsMsgHdr_ST));
+		/*
+		 * Only feed data to dvb demux if are there any feed listening
+		 * to it and if the device has tuned
+		 */
+		if (client->feed_users && client->has_tuned)
+			dvb_dmx_swfilter(&client->demux, p,
+					 cb->size - sizeof(struct SmsMsgHdr_ST));
 		break;
 
 	case MSG_SMS_RF_TUNE_RES:
@@ -579,9 +584,10 @@ static int smsdvb_onresponse(void *context, struct smscore_buffer_t *cb)
 				sms_board_dvb3_event(client, DVB3_EVENT_UNC_OK);
 			else
 				sms_board_dvb3_event(client, DVB3_EVENT_UNC_ERR);
+			client->has_tuned = true;
 		} else {
 			smsdvb_stats_not_ready(fe);
-
+			client->has_tuned = false;
 			sms_board_dvb3_event(client, DVB3_EVENT_FE_UNLOCK);
 		}
 		complete(&client->stats_done);
@@ -623,6 +629,8 @@ static int smsdvb_start_feed(struct dvb_demux_feed *feed)
 	sms_debug("add pid %d(%x)",
 		  feed->pid, feed->pid);
 
+	client->feed_users++;
+
 	PidMsg.xMsgHeader.msgSrcId = DVBT_BDA_CONTROL_MSG_ID;
 	PidMsg.xMsgHeader.msgDstId = HIF_TASK;
 	PidMsg.xMsgHeader.msgFlags = 0;
@@ -643,6 +651,8 @@ static int smsdvb_stop_feed(struct dvb_demux_feed *feed)
 	sms_debug("remove pid %d(%x)",
 		  feed->pid, feed->pid);
 
+	client->feed_users--;
+
 	PidMsg.xMsgHeader.msgSrcId = DVBT_BDA_CONTROL_MSG_ID;
 	PidMsg.xMsgHeader.msgDstId = HIF_TASK;
 	PidMsg.xMsgHeader.msgFlags = 0;
@@ -963,6 +973,8 @@ static int smsdvb_set_frontend(struct dvb_frontend *fe)
 	c->strength.stat[0].uvalue = 0;
 	c->cnr.stat[0].uvalue = 0;
 
+	client->has_tuned = false;
+
 	switch (smscore_get_device_mode(coredev)) {
 	case DEVICE_MODE_DVBT:
 	case DEVICE_MODE_DVBT_BDA:

commit 5c3b87435b291efb260aec37fdbe397859e550c5
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Sun Mar 10 19:21:13 2013 -0300

    [media] siano: Fix bandwidth report
    
    It was expected that the bandwidth would be following the defines
    at smscoreapi.h. However, this doesn't work. Instead, this field
    brings just the bandwidth in MHz. Convert it to Hertz.
    It should be noticed that, on ISDB, using the _EX request, the
    field TuneBW seems to show the value that matches the bandwidth
    code.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/common/siano/smsdvb-main.c b/drivers/media/common/siano/smsdvb-main.c
index 632a250a42cf..d83896bb98fd 100644
--- a/drivers/media/common/siano/smsdvb-main.c
+++ b/drivers/media/common/siano/smsdvb-main.c
@@ -43,18 +43,6 @@ module_param_named(debug, sms_dbg, int, 0644);
 MODULE_PARM_DESC(debug, "set debug level (info=1, adv=2 (or-able))");
 
 
-u32 sms_to_bw_table[] = {
-	[BW_8_MHZ]		= 8000000,
-	[BW_7_MHZ]		= 7000000,
-	[BW_6_MHZ]		= 6000000,
-	[BW_5_MHZ]		= 5000000,
-	[BW_2_MHZ]		= 2000000,
-	[BW_1_5_MHZ]		= 1500000,
-	[BW_ISDBT_1SEG]		= 6000000,
-	[BW_ISDBT_3SEG]		= 6000000,
-	[BW_ISDBT_13SEG]	= 6000000,
-};
-
 u32 sms_to_guard_interval_table[] = {
 	[0] = GUARD_INTERVAL_1_32,
 	[1] = GUARD_INTERVAL_1_16,
@@ -204,6 +192,10 @@ static inline int sms_to_status(u32 is_demod_locked, u32 is_rf_locked)
 	return 0;
 }
 
+static inline u32 sms_to_bw(u32 value)
+{
+	return value * 1000000;
+}
 
 #define convert_from_table(value, table, defval) ({			\
 	u32 __ret;							\
@@ -214,9 +206,6 @@ static inline int sms_to_status(u32 is_demod_locked, u32 is_rf_locked)
 	__ret;								\
 })
 
-#define sms_to_bw(value)						\
-	convert_from_table(value, sms_to_bw_table, 0);
-
 #define sms_to_guard_interval(value)					\
 	convert_from_table(value, sms_to_guard_interval_table,		\
 			   GUARD_INTERVAL_AUTO);

commit 9671045f4ce7a9e5eedc669a6921aeec26bd095e
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Sun Mar 10 13:38:41 2013 -0300

    [media] siano: fix PER/BER report on DVBv5
    
    The check for lock logic is broken. Due to that, no PER/BER
    stats will ever be showed, and the DVBV3 events will be wrong.
    Also, the per-layer PER/BER stats for ISDB-T are filled with
    the wrong index.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/common/siano/smsdvb-main.c b/drivers/media/common/siano/smsdvb-main.c
index 90f6e894e593..632a250a42cf 100644
--- a/drivers/media/common/siano/smsdvb-main.c
+++ b/drivers/media/common/siano/smsdvb-main.c
@@ -382,8 +382,12 @@ static void smsdvb_update_isdbt_stats(struct smsdvb_client_t *client,
 	/* Clears global counters, as the code below will sum it again */
 	c->block_error.stat[0].uvalue = 0;
 	c->block_count.stat[0].uvalue = 0;
+	c->block_error.stat[0].scale = FE_SCALE_COUNTER;
+	c->block_count.stat[0].scale = FE_SCALE_COUNTER;
 	c->post_bit_error.stat[0].uvalue = 0;
 	c->post_bit_count.stat[0].uvalue = 0;
+	c->post_bit_error.stat[0].scale = FE_SCALE_COUNTER;
+	c->post_bit_count.stat[0].scale = FE_SCALE_COUNTER;
 
 	for (i = 0; i < n_layers; i++) {
 		lr = &p->LayerInfo[i];
@@ -398,20 +402,20 @@ static void smsdvb_update_isdbt_stats(struct smsdvb_client_t *client,
 		c->layer[i].modulation = sms_to_modulation(lr->Constellation);
 
 		/* TS PER */
-		c->block_error.stat[i].scale = FE_SCALE_COUNTER;
-		c->block_count.stat[i].scale = FE_SCALE_COUNTER;
-		c->block_error.stat[i].uvalue += lr->ErrorTSPackets;
-		c->block_count.stat[i].uvalue += lr->TotalTSPackets;
+		c->block_error.stat[i + 1].scale = FE_SCALE_COUNTER;
+		c->block_count.stat[i + 1].scale = FE_SCALE_COUNTER;
+		c->block_error.stat[i + 1].uvalue += lr->ErrorTSPackets;
+		c->block_count.stat[i + 1].uvalue += lr->TotalTSPackets;
 
 		/* Update global PER counter */
 		c->block_error.stat[0].uvalue += lr->ErrorTSPackets;
 		c->block_count.stat[0].uvalue += lr->TotalTSPackets;
 
 		/* BER */
-		c->post_bit_error.stat[i].scale = FE_SCALE_COUNTER;
-		c->post_bit_count.stat[i].scale = FE_SCALE_COUNTER;
-		c->post_bit_error.stat[i].uvalue += lr->BERErrorCount;
-		c->post_bit_count.stat[i].uvalue += lr->BERBitCount;
+		c->post_bit_error.stat[i + 1].scale = FE_SCALE_COUNTER;
+		c->post_bit_count.stat[i + 1].scale = FE_SCALE_COUNTER;
+		c->post_bit_error.stat[i + 1].uvalue += lr->BERErrorCount;
+		c->post_bit_count.stat[i + 1].uvalue += lr->BERBitCount;
 
 		/* Update global BER counter */
 		c->post_bit_error.stat[0].uvalue += lr->BERErrorCount;
@@ -462,9 +466,17 @@ static void smsdvb_update_isdbt_stats_ex(struct smsdvb_client_t *client,
 	/* Clears global counters, as the code below will sum it again */
 	c->block_error.stat[0].uvalue = 0;
 	c->block_count.stat[0].uvalue = 0;
+	c->block_error.stat[0].scale = FE_SCALE_COUNTER;
+	c->block_count.stat[0].scale = FE_SCALE_COUNTER;
 	c->post_bit_error.stat[0].uvalue = 0;
 	c->post_bit_count.stat[0].uvalue = 0;
+	c->post_bit_error.stat[0].scale = FE_SCALE_COUNTER;
+	c->post_bit_count.stat[0].scale = FE_SCALE_COUNTER;
 
+	c->post_bit_error.len = n_layers + 1;
+	c->post_bit_count.len = n_layers + 1;
+	c->block_error.len = n_layers + 1;
+	c->block_count.len = n_layers + 1;
 	for (i = 0; i < n_layers; i++) {
 		lr = &p->LayerInfo[i];
 
@@ -478,20 +490,20 @@ static void smsdvb_update_isdbt_stats_ex(struct smsdvb_client_t *client,
 		c->layer[i].modulation = sms_to_modulation(lr->Constellation);
 
 		/* TS PER */
-		c->block_error.stat[i].scale = FE_SCALE_COUNTER;
-		c->block_count.stat[i].scale = FE_SCALE_COUNTER;
-		c->block_error.stat[i].uvalue += lr->ErrorTSPackets;
-		c->block_count.stat[i].uvalue += lr->TotalTSPackets;
+		c->block_error.stat[i + 1].scale = FE_SCALE_COUNTER;
+		c->block_count.stat[i + 1].scale = FE_SCALE_COUNTER;
+		c->block_error.stat[i + 1].uvalue += lr->ErrorTSPackets;
+		c->block_count.stat[i + 1].uvalue += lr->TotalTSPackets;
 
 		/* Update global PER counter */
 		c->block_error.stat[0].uvalue += lr->ErrorTSPackets;
 		c->block_count.stat[0].uvalue += lr->TotalTSPackets;
 
 		/* BER */
-		c->post_bit_error.stat[i].scale = FE_SCALE_COUNTER;
-		c->post_bit_count.stat[i].scale = FE_SCALE_COUNTER;
-		c->post_bit_error.stat[i].uvalue += lr->BERErrorCount;
-		c->post_bit_count.stat[i].uvalue += lr->BERBitCount;
+		c->post_bit_error.stat[i + 1].scale = FE_SCALE_COUNTER;
+		c->post_bit_count.stat[i + 1].scale = FE_SCALE_COUNTER;
+		c->post_bit_error.stat[i + 1].uvalue += lr->BERErrorCount;
+		c->post_bit_count.stat[i + 1].uvalue += lr->BERBitCount;
 
 		/* Update global BER counter */
 		c->post_bit_error.stat[0].uvalue += lr->BERErrorCount;
@@ -572,7 +584,7 @@ static int smsdvb_onresponse(void *context, struct smscore_buffer_t *cb)
 	smscore_putbuffer(client->coredev, cb);
 
 	if (is_status_update) {
-		if (client->fe_status == FE_HAS_LOCK) {
+		if (client->fe_status & FE_HAS_LOCK) {
 			sms_board_dvb3_event(client, DVB3_EVENT_FE_LOCK);
 			if (client->last_per == c->block_error.stat[0].uvalue)
 				sms_board_dvb3_event(client, DVB3_EVENT_UNC_OK);

commit f5de95e2467b7b6b968e6c67489425265dd2a1c2
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Sun Mar 10 12:06:30 2013 -0300

    [media] siano: fix signal strength and CNR stats measurements
    
    There are a number of small issues with the stats refactoring:
            - InBandPwr better represents the signal strength;
            - Don't zero signal strength /cnr if no lock;
            - Fix signal strength/cnr scale;
            - Don't need to fill PER/BER if not locked, as the
              code will disable those stats anyway.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/common/siano/smsdvb-main.c b/drivers/media/common/siano/smsdvb-main.c
index 4242005082ed..90f6e894e593 100644
--- a/drivers/media/common/siano/smsdvb-main.c
+++ b/drivers/media/common/siano/smsdvb-main.c
@@ -155,11 +155,11 @@ static void smsdvb_stats_not_ready(struct dvb_frontend *fe)
 		n_layers = 1;
 	}
 
-	/* Fill the length of each status counter */
-
-	/* Only global stats */
+	/* Global stats */
 	c->strength.len = 1;
 	c->cnr.len = 1;
+	c->strength.stat[0].scale = FE_SCALE_DECIBEL;
+	c->cnr.stat[0].scale = FE_SCALE_DECIBEL;
 
 	/* Per-layer stats */
 	c->post_bit_error.len = n_layers;
@@ -167,13 +167,11 @@ static void smsdvb_stats_not_ready(struct dvb_frontend *fe)
 	c->block_error.len = n_layers;
 	c->block_count.len = n_layers;
 
-	/* Signal is always available */
-	c->strength.stat[0].scale = FE_SCALE_RELATIVE;
-	c->strength.stat[0].uvalue = 0;
-
-	/* Put all of them at FE_SCALE_NOT_AVAILABLE */
+	/*
+	 * Put all of them at FE_SCALE_NOT_AVAILABLE. They're dynamically
+	 * changed when the stats become available.
+	 */
 	for (i = 0; i < n_layers; i++) {
-		c->cnr.stat[i].scale = FE_SCALE_NOT_AVAILABLE;
 		c->post_bit_error.stat[i].scale = FE_SCALE_NOT_AVAILABLE;
 		c->post_bit_count.stat[i].scale = FE_SCALE_NOT_AVAILABLE;
 		c->block_error.stat[i].scale = FE_SCALE_NOT_AVAILABLE;
@@ -261,6 +259,16 @@ static void smsdvb_update_per_slices(struct smsdvb_client_t *client,
 	client->fe_status = sms_to_status(p->IsDemodLocked, p->IsRfLocked);
 	c->modulation = sms_to_modulation(p->constellation);
 
+	/* Signal Strength, in DBm */
+	c->strength.stat[0].uvalue = p->inBandPower * 1000;
+
+	/* Carrier to Noise ratio, in DB */
+	c->cnr.stat[0].svalue = p->snr * 1000;
+
+	/* PER/BER requires demod lock */
+	if (!p->IsDemodLocked)
+		return;
+
 	/* TS PER */
 	client->last_per = c->block_error.stat[0].uvalue;
 	c->block_error.stat[0].scale = FE_SCALE_COUNTER;
@@ -277,13 +285,6 @@ static void smsdvb_update_per_slices(struct smsdvb_client_t *client,
 	/* Legacy PER/BER */
 	client->legacy_per = (p->etsPackets * 65535) /
 			     (p->tsPackets + p->etsPackets);
-
-	/* Signal Strength, in DBm */
-	c->strength.stat[0].uvalue = p->RSSI * 1000;
-
-	/* Carrier to Noise ratio, in DB */
-	c->cnr.stat[0].scale = FE_SCALE_DECIBEL;
-	c->cnr.stat[0].svalue = p->snr * 1000;
 }
 
 static void smsdvb_update_dvb_stats(struct smsdvb_client_t *client,
@@ -312,11 +313,14 @@ static void smsdvb_update_dvb_stats(struct smsdvb_client_t *client,
 	c->lna = p->IsExternalLNAOn ? 1 : 0;
 
 	/* Carrier to Noise ratio, in DB */
-	c->cnr.stat[0].scale = FE_SCALE_DECIBEL;
 	c->cnr.stat[0].svalue = p->SNR * 1000;
 
 	/* Signal Strength, in DBm */
-	c->strength.stat[0].uvalue = p->RSSI * 1000;
+	c->strength.stat[0].uvalue = p->InBandPwr * 1000;
+
+	/* PER/BER requires demod lock */
+	if (!p->IsDemodLocked)
+		return;
 
 	/* TS PER */
 	client->last_per = c->block_error.stat[0].uvalue;
@@ -364,11 +368,14 @@ static void smsdvb_update_isdbt_stats(struct smsdvb_client_t *client,
 	c->lna = p->IsExternalLNAOn ? 1 : 0;
 
 	/* Carrier to Noise ratio, in DB */
-	c->cnr.stat[0].scale = FE_SCALE_DECIBEL;
 	c->cnr.stat[0].svalue = p->SNR * 1000;
 
 	/* Signal Strength, in DBm */
-	c->strength.stat[0].uvalue = p->RSSI * 1000;
+	c->strength.stat[0].uvalue = p->InBandPwr * 1000;
+
+	/* PER/BER and per-layer stats require demod lock */
+	if (!p->IsDemodLocked)
+		return;
 
 	client->last_per = c->block_error.stat[0].uvalue;
 
@@ -441,11 +448,14 @@ static void smsdvb_update_isdbt_stats_ex(struct smsdvb_client_t *client,
 	c->lna = p->IsExternalLNAOn ? 1 : 0;
 
 	/* Carrier to Noise ratio, in DB */
-	c->cnr.stat[0].scale = FE_SCALE_DECIBEL;
 	c->cnr.stat[0].svalue = p->SNR * 1000;
 
 	/* Signal Strength, in DBm */
-	c->strength.stat[0].uvalue = p->RSSI * 1000;
+	c->strength.stat[0].uvalue = p->InBandPwr * 1000;
+
+	/* PER/BER and per-layer stats require demod lock */
+	if (!p->IsDemodLocked)
+		return;
 
 	client->last_per = c->block_error.stat[0].uvalue;
 
@@ -943,11 +953,14 @@ static int smsdvb_isdbt_set_frontend(struct dvb_frontend *fe)
 
 static int smsdvb_set_frontend(struct dvb_frontend *fe)
 {
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
 	struct smsdvb_client_t *client =
 		container_of(fe, struct smsdvb_client_t, frontend);
 	struct smscore_device_t *coredev = client->coredev;
 
 	smsdvb_stats_not_ready(fe);
+	c->strength.stat[0].uvalue = 0;
+	c->cnr.stat[0].uvalue = 0;
 
 	switch (smscore_get_device_mode(coredev)) {
 	case DEVICE_MODE_DVBT:

commit a9b9fbdf0a6a65359cd97254a282526822de5257
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Sun Mar 10 10:51:25 2013 -0300

    [media] siano: don't request statistics too fast
    
    As each DVBv3 call may generate an stats overhead, prevent doing
    it too fast. This is specially useful if a burst of get stats
    DVBv3 call is sent.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/common/siano/smsdvb-main.c b/drivers/media/common/siano/smsdvb-main.c
index c14f10d5d6c0..4242005082ed 100644
--- a/drivers/media/common/siano/smsdvb-main.c
+++ b/drivers/media/common/siano/smsdvb-main.c
@@ -663,6 +663,11 @@ static int smsdvb_send_statistics_request(struct smsdvb_client_t *client)
 	int rc;
 	struct SmsMsgHdr_ST Msg;
 
+	/* Don't request stats too fast */
+	if (client->get_stats_jiffies &&
+	   (!time_after(jiffies, client->get_stats_jiffies)))
+		return 0;
+	client->get_stats_jiffies = jiffies + msecs_to_jiffies(100);
 
 	Msg.msgSrcId = DVBT_BDA_CONTROL_MSG_ID;
 	Msg.msgDstId = HIF_TASK;

commit 503efe5cfc9fb9f67a6659c4ab39174b442876f3
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Sun Mar 10 09:04:44 2013 -0300

    [media] siano: split debugfs code into a separate file
    
    To avoid mixing two different things at the same place, move the
    debugfs code into a separate file.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/common/siano/smsdvb-main.c b/drivers/media/common/siano/smsdvb-main.c
new file mode 100644
index 000000000000..c14f10d5d6c0
--- /dev/null
+++ b/drivers/media/common/siano/smsdvb-main.c
@@ -0,0 +1,1184 @@
+/****************************************************************
+
+Siano Mobile Silicon, Inc.
+MDTV receiver kernel modules.
+Copyright (C) 2006-2008, Uri Shkolnik
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 2 of the License, or
+(at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+****************************************************************/
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+
+#include "dmxdev.h"
+#include "dvbdev.h"
+#include "dvb_demux.h"
+#include "dvb_frontend.h"
+
+#include "smscoreapi.h"
+#include "sms-cards.h"
+
+#include "smsdvb.h"
+
+DVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);
+
+static struct list_head g_smsdvb_clients;
+static struct mutex g_smsdvb_clientslock;
+
+static int sms_dbg;
+module_param_named(debug, sms_dbg, int, 0644);
+MODULE_PARM_DESC(debug, "set debug level (info=1, adv=2 (or-able))");
+
+
+u32 sms_to_bw_table[] = {
+	[BW_8_MHZ]		= 8000000,
+	[BW_7_MHZ]		= 7000000,
+	[BW_6_MHZ]		= 6000000,
+	[BW_5_MHZ]		= 5000000,
+	[BW_2_MHZ]		= 2000000,
+	[BW_1_5_MHZ]		= 1500000,
+	[BW_ISDBT_1SEG]		= 6000000,
+	[BW_ISDBT_3SEG]		= 6000000,
+	[BW_ISDBT_13SEG]	= 6000000,
+};
+
+u32 sms_to_guard_interval_table[] = {
+	[0] = GUARD_INTERVAL_1_32,
+	[1] = GUARD_INTERVAL_1_16,
+	[2] = GUARD_INTERVAL_1_8,
+	[3] = GUARD_INTERVAL_1_4,
+};
+
+u32 sms_to_code_rate_table[] = {
+	[0] = FEC_1_2,
+	[1] = FEC_2_3,
+	[2] = FEC_3_4,
+	[3] = FEC_5_6,
+	[4] = FEC_7_8,
+};
+
+
+u32 sms_to_hierarchy_table[] = {
+	[0] = HIERARCHY_NONE,
+	[1] = HIERARCHY_1,
+	[2] = HIERARCHY_2,
+	[3] = HIERARCHY_4,
+};
+
+u32 sms_to_modulation_table[] = {
+	[0] = QPSK,
+	[1] = QAM_16,
+	[2] = QAM_64,
+	[3] = DQPSK,
+};
+
+
+/* Events that may come from DVB v3 adapter */
+static void sms_board_dvb3_event(struct smsdvb_client_t *client,
+		enum SMS_DVB3_EVENTS event) {
+
+	struct smscore_device_t *coredev = client->coredev;
+	switch (event) {
+	case DVB3_EVENT_INIT:
+		sms_debug("DVB3_EVENT_INIT");
+		sms_board_event(coredev, BOARD_EVENT_BIND);
+		break;
+	case DVB3_EVENT_SLEEP:
+		sms_debug("DVB3_EVENT_SLEEP");
+		sms_board_event(coredev, BOARD_EVENT_POWER_SUSPEND);
+		break;
+	case DVB3_EVENT_HOTPLUG:
+		sms_debug("DVB3_EVENT_HOTPLUG");
+		sms_board_event(coredev, BOARD_EVENT_POWER_INIT);
+		break;
+	case DVB3_EVENT_FE_LOCK:
+		if (client->event_fe_state != DVB3_EVENT_FE_LOCK) {
+			client->event_fe_state = DVB3_EVENT_FE_LOCK;
+			sms_debug("DVB3_EVENT_FE_LOCK");
+			sms_board_event(coredev, BOARD_EVENT_FE_LOCK);
+		}
+		break;
+	case DVB3_EVENT_FE_UNLOCK:
+		if (client->event_fe_state != DVB3_EVENT_FE_UNLOCK) {
+			client->event_fe_state = DVB3_EVENT_FE_UNLOCK;
+			sms_debug("DVB3_EVENT_FE_UNLOCK");
+			sms_board_event(coredev, BOARD_EVENT_FE_UNLOCK);
+		}
+		break;
+	case DVB3_EVENT_UNC_OK:
+		if (client->event_unc_state != DVB3_EVENT_UNC_OK) {
+			client->event_unc_state = DVB3_EVENT_UNC_OK;
+			sms_debug("DVB3_EVENT_UNC_OK");
+			sms_board_event(coredev, BOARD_EVENT_MULTIPLEX_OK);
+		}
+		break;
+	case DVB3_EVENT_UNC_ERR:
+		if (client->event_unc_state != DVB3_EVENT_UNC_ERR) {
+			client->event_unc_state = DVB3_EVENT_UNC_ERR;
+			sms_debug("DVB3_EVENT_UNC_ERR");
+			sms_board_event(coredev, BOARD_EVENT_MULTIPLEX_ERRORS);
+		}
+		break;
+
+	default:
+		sms_err("Unknown dvb3 api event");
+		break;
+	}
+}
+
+static void smsdvb_stats_not_ready(struct dvb_frontend *fe)
+{
+	struct smsdvb_client_t *client =
+		container_of(fe, struct smsdvb_client_t, frontend);
+	struct smscore_device_t *coredev = client->coredev;
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	int i, n_layers;
+
+	switch (smscore_get_device_mode(coredev)) {
+	case DEVICE_MODE_ISDBT:
+	case DEVICE_MODE_ISDBT_BDA:
+		n_layers = 4;
+	default:
+		n_layers = 1;
+	}
+
+	/* Fill the length of each status counter */
+
+	/* Only global stats */
+	c->strength.len = 1;
+	c->cnr.len = 1;
+
+	/* Per-layer stats */
+	c->post_bit_error.len = n_layers;
+	c->post_bit_count.len = n_layers;
+	c->block_error.len = n_layers;
+	c->block_count.len = n_layers;
+
+	/* Signal is always available */
+	c->strength.stat[0].scale = FE_SCALE_RELATIVE;
+	c->strength.stat[0].uvalue = 0;
+
+	/* Put all of them at FE_SCALE_NOT_AVAILABLE */
+	for (i = 0; i < n_layers; i++) {
+		c->cnr.stat[i].scale = FE_SCALE_NOT_AVAILABLE;
+		c->post_bit_error.stat[i].scale = FE_SCALE_NOT_AVAILABLE;
+		c->post_bit_count.stat[i].scale = FE_SCALE_NOT_AVAILABLE;
+		c->block_error.stat[i].scale = FE_SCALE_NOT_AVAILABLE;
+		c->block_count.stat[i].scale = FE_SCALE_NOT_AVAILABLE;
+	}
+}
+
+static inline int sms_to_mode(u32 mode)
+{
+	switch (mode) {
+	case 2:
+		return TRANSMISSION_MODE_2K;
+	case 4:
+		return TRANSMISSION_MODE_4K;
+	case 8:
+		return TRANSMISSION_MODE_8K;
+	}
+	return TRANSMISSION_MODE_AUTO;
+}
+
+static inline int sms_to_status(u32 is_demod_locked, u32 is_rf_locked)
+{
+	if (is_demod_locked)
+		return FE_HAS_SIGNAL  | FE_HAS_CARRIER | FE_HAS_VITERBI |
+		       FE_HAS_SYNC    | FE_HAS_LOCK;
+
+	if (is_rf_locked)
+		return FE_HAS_SIGNAL | FE_HAS_CARRIER;
+
+	return 0;
+}
+
+
+#define convert_from_table(value, table, defval) ({			\
+	u32 __ret;							\
+	if (value < ARRAY_SIZE(table))					\
+		__ret = table[value];					\
+	else								\
+		__ret = defval;						\
+	__ret;								\
+})
+
+#define sms_to_bw(value)						\
+	convert_from_table(value, sms_to_bw_table, 0);
+
+#define sms_to_guard_interval(value)					\
+	convert_from_table(value, sms_to_guard_interval_table,		\
+			   GUARD_INTERVAL_AUTO);
+
+#define sms_to_code_rate(value)						\
+	convert_from_table(value, sms_to_code_rate_table,		\
+			   FEC_NONE);
+
+#define sms_to_hierarchy(value)						\
+	convert_from_table(value, sms_to_hierarchy_table,		\
+			   FEC_NONE);
+
+#define sms_to_modulation(value)					\
+	convert_from_table(value, sms_to_modulation_table,		\
+			   FEC_NONE);
+
+static void smsdvb_update_tx_params(struct smsdvb_client_t *client,
+				    struct TRANSMISSION_STATISTICS_S *p)
+{
+	struct dvb_frontend *fe = &client->frontend;
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+
+	c->frequency = p->Frequency;
+	client->fe_status = sms_to_status(p->IsDemodLocked, 0);
+	c->bandwidth_hz = sms_to_bw(p->Bandwidth);
+	c->transmission_mode = sms_to_mode(p->TransmissionMode);
+	c->guard_interval = sms_to_guard_interval(p->GuardInterval);
+	c->code_rate_HP = sms_to_code_rate(p->CodeRate);
+	c->code_rate_LP = sms_to_code_rate(p->LPCodeRate);
+	c->hierarchy = sms_to_hierarchy(p->Hierarchy);
+	c->modulation = sms_to_modulation(p->Constellation);
+}
+
+static void smsdvb_update_per_slices(struct smsdvb_client_t *client,
+				     struct RECEPTION_STATISTICS_PER_SLICES_S *p)
+{
+	struct dvb_frontend *fe = &client->frontend;
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+
+	client->fe_status = sms_to_status(p->IsDemodLocked, p->IsRfLocked);
+	c->modulation = sms_to_modulation(p->constellation);
+
+	/* TS PER */
+	client->last_per = c->block_error.stat[0].uvalue;
+	c->block_error.stat[0].scale = FE_SCALE_COUNTER;
+	c->block_count.stat[0].scale = FE_SCALE_COUNTER;
+	c->block_error.stat[0].uvalue += p->etsPackets;
+	c->block_count.stat[0].uvalue += p->etsPackets + p->tsPackets;
+
+	/* BER */
+	c->post_bit_error.stat[0].scale = FE_SCALE_COUNTER;
+	c->post_bit_count.stat[0].scale = FE_SCALE_COUNTER;
+	c->post_bit_error.stat[0].uvalue += p->BERErrorCount;
+	c->post_bit_count.stat[0].uvalue += p->BERBitCount;
+
+	/* Legacy PER/BER */
+	client->legacy_per = (p->etsPackets * 65535) /
+			     (p->tsPackets + p->etsPackets);
+
+	/* Signal Strength, in DBm */
+	c->strength.stat[0].uvalue = p->RSSI * 1000;
+
+	/* Carrier to Noise ratio, in DB */
+	c->cnr.stat[0].scale = FE_SCALE_DECIBEL;
+	c->cnr.stat[0].svalue = p->snr * 1000;
+}
+
+static void smsdvb_update_dvb_stats(struct smsdvb_client_t *client,
+				    struct SMSHOSTLIB_STATISTICS_ST *p)
+{
+	struct dvb_frontend *fe = &client->frontend;
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+
+	if (client->prt_dvb_stats)
+		client->prt_dvb_stats(client->debug_data, p);
+
+	client->fe_status = sms_to_status(p->IsDemodLocked, p->IsRfLocked);
+
+	/* Update DVB modulation parameters */
+	c->frequency = p->Frequency;
+	client->fe_status = sms_to_status(p->IsDemodLocked, 0);
+	c->bandwidth_hz = sms_to_bw(p->Bandwidth);
+	c->transmission_mode = sms_to_mode(p->TransmissionMode);
+	c->guard_interval = sms_to_guard_interval(p->GuardInterval);
+	c->code_rate_HP = sms_to_code_rate(p->CodeRate);
+	c->code_rate_LP = sms_to_code_rate(p->LPCodeRate);
+	c->hierarchy = sms_to_hierarchy(p->Hierarchy);
+	c->modulation = sms_to_modulation(p->Constellation);
+
+	/* update reception data */
+	c->lna = p->IsExternalLNAOn ? 1 : 0;
+
+	/* Carrier to Noise ratio, in DB */
+	c->cnr.stat[0].scale = FE_SCALE_DECIBEL;
+	c->cnr.stat[0].svalue = p->SNR * 1000;
+
+	/* Signal Strength, in DBm */
+	c->strength.stat[0].uvalue = p->RSSI * 1000;
+
+	/* TS PER */
+	client->last_per = c->block_error.stat[0].uvalue;
+	c->block_error.stat[0].scale = FE_SCALE_COUNTER;
+	c->block_count.stat[0].scale = FE_SCALE_COUNTER;
+	c->block_error.stat[0].uvalue += p->ErrorTSPackets;
+	c->block_count.stat[0].uvalue += p->TotalTSPackets;
+
+	/* BER */
+	c->post_bit_error.stat[0].scale = FE_SCALE_COUNTER;
+	c->post_bit_count.stat[0].scale = FE_SCALE_COUNTER;
+	c->post_bit_error.stat[0].uvalue += p->BERErrorCount;
+	c->post_bit_count.stat[0].uvalue += p->BERBitCount;
+
+	/* Legacy PER/BER */
+	client->legacy_ber = p->BER;
+};
+
+static void smsdvb_update_isdbt_stats(struct smsdvb_client_t *client,
+				      struct SMSHOSTLIB_STATISTICS_ISDBT_ST *p)
+{
+	struct dvb_frontend *fe = &client->frontend;
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	struct SMSHOSTLIB_ISDBT_LAYER_STAT_ST *lr;
+	int i, n_layers;
+
+	if (client->prt_isdb_stats)
+		client->prt_isdb_stats(client->debug_data, p);
+
+	/* Update ISDB-T transmission parameters */
+	c->frequency = p->Frequency;
+	client->fe_status = sms_to_status(p->IsDemodLocked, 0);
+	c->bandwidth_hz = sms_to_bw(p->Bandwidth);
+	c->transmission_mode = sms_to_mode(p->TransmissionMode);
+	c->guard_interval = sms_to_guard_interval(p->GuardInterval);
+	c->isdbt_partial_reception = p->PartialReception ? 1 : 0;
+	n_layers = p->NumOfLayers;
+	if (n_layers < 1)
+		n_layers = 1;
+	if (n_layers > 3)
+		n_layers = 3;
+	c->isdbt_layer_enabled = 0;
+
+	/* update reception data */
+	c->lna = p->IsExternalLNAOn ? 1 : 0;
+
+	/* Carrier to Noise ratio, in DB */
+	c->cnr.stat[0].scale = FE_SCALE_DECIBEL;
+	c->cnr.stat[0].svalue = p->SNR * 1000;
+
+	/* Signal Strength, in DBm */
+	c->strength.stat[0].uvalue = p->RSSI * 1000;
+
+	client->last_per = c->block_error.stat[0].uvalue;
+
+	/* Clears global counters, as the code below will sum it again */
+	c->block_error.stat[0].uvalue = 0;
+	c->block_count.stat[0].uvalue = 0;
+	c->post_bit_error.stat[0].uvalue = 0;
+	c->post_bit_count.stat[0].uvalue = 0;
+
+	for (i = 0; i < n_layers; i++) {
+		lr = &p->LayerInfo[i];
+
+		/* Update per-layer transmission parameters */
+		if (lr->NumberOfSegments > 0 && lr->NumberOfSegments < 13) {
+			c->isdbt_layer_enabled |= 1 << i;
+			c->layer[i].segment_count = lr->NumberOfSegments;
+		} else {
+			continue;
+		}
+		c->layer[i].modulation = sms_to_modulation(lr->Constellation);
+
+		/* TS PER */
+		c->block_error.stat[i].scale = FE_SCALE_COUNTER;
+		c->block_count.stat[i].scale = FE_SCALE_COUNTER;
+		c->block_error.stat[i].uvalue += lr->ErrorTSPackets;
+		c->block_count.stat[i].uvalue += lr->TotalTSPackets;
+
+		/* Update global PER counter */
+		c->block_error.stat[0].uvalue += lr->ErrorTSPackets;
+		c->block_count.stat[0].uvalue += lr->TotalTSPackets;
+
+		/* BER */
+		c->post_bit_error.stat[i].scale = FE_SCALE_COUNTER;
+		c->post_bit_count.stat[i].scale = FE_SCALE_COUNTER;
+		c->post_bit_error.stat[i].uvalue += lr->BERErrorCount;
+		c->post_bit_count.stat[i].uvalue += lr->BERBitCount;
+
+		/* Update global BER counter */
+		c->post_bit_error.stat[0].uvalue += lr->BERErrorCount;
+		c->post_bit_count.stat[0].uvalue += lr->BERBitCount;
+	}
+}
+
+static void smsdvb_update_isdbt_stats_ex(struct smsdvb_client_t *client,
+					 struct SMSHOSTLIB_STATISTICS_ISDBT_EX_ST *p)
+{
+	struct dvb_frontend *fe = &client->frontend;
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	struct SMSHOSTLIB_ISDBT_LAYER_STAT_ST *lr;
+	int i, n_layers;
+
+	if (client->prt_isdb_stats_ex)
+		client->prt_isdb_stats_ex(client->debug_data, p);
+
+	/* Update ISDB-T transmission parameters */
+	c->frequency = p->Frequency;
+	client->fe_status = sms_to_status(p->IsDemodLocked, 0);
+	c->bandwidth_hz = sms_to_bw(p->Bandwidth);
+	c->transmission_mode = sms_to_mode(p->TransmissionMode);
+	c->guard_interval = sms_to_guard_interval(p->GuardInterval);
+	c->isdbt_partial_reception = p->PartialReception ? 1 : 0;
+	n_layers = p->NumOfLayers;
+	if (n_layers < 1)
+		n_layers = 1;
+	if (n_layers > 3)
+		n_layers = 3;
+	c->isdbt_layer_enabled = 0;
+
+	/* update reception data */
+	c->lna = p->IsExternalLNAOn ? 1 : 0;
+
+	/* Carrier to Noise ratio, in DB */
+	c->cnr.stat[0].scale = FE_SCALE_DECIBEL;
+	c->cnr.stat[0].svalue = p->SNR * 1000;
+
+	/* Signal Strength, in DBm */
+	c->strength.stat[0].uvalue = p->RSSI * 1000;
+
+	client->last_per = c->block_error.stat[0].uvalue;
+
+	/* Clears global counters, as the code below will sum it again */
+	c->block_error.stat[0].uvalue = 0;
+	c->block_count.stat[0].uvalue = 0;
+	c->post_bit_error.stat[0].uvalue = 0;
+	c->post_bit_count.stat[0].uvalue = 0;
+
+	for (i = 0; i < n_layers; i++) {
+		lr = &p->LayerInfo[i];
+
+		/* Update per-layer transmission parameters */
+		if (lr->NumberOfSegments > 0 && lr->NumberOfSegments < 13) {
+			c->isdbt_layer_enabled |= 1 << i;
+			c->layer[i].segment_count = lr->NumberOfSegments;
+		} else {
+			continue;
+		}
+		c->layer[i].modulation = sms_to_modulation(lr->Constellation);
+
+		/* TS PER */
+		c->block_error.stat[i].scale = FE_SCALE_COUNTER;
+		c->block_count.stat[i].scale = FE_SCALE_COUNTER;
+		c->block_error.stat[i].uvalue += lr->ErrorTSPackets;
+		c->block_count.stat[i].uvalue += lr->TotalTSPackets;
+
+		/* Update global PER counter */
+		c->block_error.stat[0].uvalue += lr->ErrorTSPackets;
+		c->block_count.stat[0].uvalue += lr->TotalTSPackets;
+
+		/* BER */
+		c->post_bit_error.stat[i].scale = FE_SCALE_COUNTER;
+		c->post_bit_count.stat[i].scale = FE_SCALE_COUNTER;
+		c->post_bit_error.stat[i].uvalue += lr->BERErrorCount;
+		c->post_bit_count.stat[i].uvalue += lr->BERBitCount;
+
+		/* Update global BER counter */
+		c->post_bit_error.stat[0].uvalue += lr->BERErrorCount;
+		c->post_bit_count.stat[0].uvalue += lr->BERBitCount;
+	}
+}
+
+static int smsdvb_onresponse(void *context, struct smscore_buffer_t *cb)
+{
+	struct smsdvb_client_t *client = (struct smsdvb_client_t *) context;
+	struct SmsMsgHdr_ST *phdr = (struct SmsMsgHdr_ST *) (((u8 *) cb->p)
+			+ cb->offset);
+	void *p = phdr + 1;
+	struct dvb_frontend *fe = &client->frontend;
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	bool is_status_update = false;
+
+	switch (phdr->msgType) {
+	case MSG_SMS_DVBT_BDA_DATA:
+		dvb_dmx_swfilter(&client->demux, p,
+				 cb->size - sizeof(struct SmsMsgHdr_ST));
+		break;
+
+	case MSG_SMS_RF_TUNE_RES:
+	case MSG_SMS_ISDBT_TUNE_RES:
+		complete(&client->tune_done);
+		break;
+
+	case MSG_SMS_SIGNAL_DETECTED_IND:
+		client->fe_status = FE_HAS_SIGNAL  | FE_HAS_CARRIER |
+				    FE_HAS_VITERBI | FE_HAS_SYNC    |
+				    FE_HAS_LOCK;
+
+		is_status_update = true;
+		break;
+
+	case MSG_SMS_NO_SIGNAL_IND:
+		client->fe_status = 0;
+
+		is_status_update = true;
+		break;
+
+	case MSG_SMS_TRANSMISSION_IND:
+		smsdvb_update_tx_params(client, p);
+
+		is_status_update = true;
+		break;
+
+	case MSG_SMS_HO_PER_SLICES_IND:
+		smsdvb_update_per_slices(client, p);
+
+		is_status_update = true;
+		break;
+
+	case MSG_SMS_GET_STATISTICS_RES:
+		switch (smscore_get_device_mode(client->coredev)) {
+		case DEVICE_MODE_ISDBT:
+		case DEVICE_MODE_ISDBT_BDA:
+			smsdvb_update_isdbt_stats(client, p);
+			break;
+		default:
+			/* Skip SmsMsgStatisticsInfo_ST:RequestResult field */
+			smsdvb_update_dvb_stats(client, p + sizeof(u32));
+		}
+
+		is_status_update = true;
+		break;
+
+	/* Only for ISDB-T */
+	case MSG_SMS_GET_STATISTICS_EX_RES:
+		/* Skip SmsMsgStatisticsInfo_ST:RequestResult field? */
+		smsdvb_update_isdbt_stats_ex(client, p + sizeof(u32));
+		is_status_update = true;
+		break;
+	default:
+		sms_info("message not handled");
+	}
+	smscore_putbuffer(client->coredev, cb);
+
+	if (is_status_update) {
+		if (client->fe_status == FE_HAS_LOCK) {
+			sms_board_dvb3_event(client, DVB3_EVENT_FE_LOCK);
+			if (client->last_per == c->block_error.stat[0].uvalue)
+				sms_board_dvb3_event(client, DVB3_EVENT_UNC_OK);
+			else
+				sms_board_dvb3_event(client, DVB3_EVENT_UNC_ERR);
+		} else {
+			smsdvb_stats_not_ready(fe);
+
+			sms_board_dvb3_event(client, DVB3_EVENT_FE_UNLOCK);
+		}
+		complete(&client->stats_done);
+	}
+
+	return 0;
+}
+
+static void smsdvb_unregister_client(struct smsdvb_client_t *client)
+{
+	/* must be called under clientslock */
+
+	list_del(&client->entry);
+
+	smsdvb_debugfs_release(client);
+	smscore_unregister_client(client->smsclient);
+	dvb_unregister_frontend(&client->frontend);
+	dvb_dmxdev_release(&client->dmxdev);
+	dvb_dmx_release(&client->demux);
+	dvb_unregister_adapter(&client->adapter);
+	kfree(client);
+}
+
+static void smsdvb_onremove(void *context)
+{
+	kmutex_lock(&g_smsdvb_clientslock);
+
+	smsdvb_unregister_client((struct smsdvb_client_t *) context);
+
+	kmutex_unlock(&g_smsdvb_clientslock);
+}
+
+static int smsdvb_start_feed(struct dvb_demux_feed *feed)
+{
+	struct smsdvb_client_t *client =
+		container_of(feed->demux, struct smsdvb_client_t, demux);
+	struct SmsMsgData_ST PidMsg;
+
+	sms_debug("add pid %d(%x)",
+		  feed->pid, feed->pid);
+
+	PidMsg.xMsgHeader.msgSrcId = DVBT_BDA_CONTROL_MSG_ID;
+	PidMsg.xMsgHeader.msgDstId = HIF_TASK;
+	PidMsg.xMsgHeader.msgFlags = 0;
+	PidMsg.xMsgHeader.msgType  = MSG_SMS_ADD_PID_FILTER_REQ;
+	PidMsg.xMsgHeader.msgLength = sizeof(PidMsg);
+	PidMsg.msgData[0] = feed->pid;
+
+	return smsclient_sendrequest(client->smsclient,
+				     &PidMsg, sizeof(PidMsg));
+}
+
+static int smsdvb_stop_feed(struct dvb_demux_feed *feed)
+{
+	struct smsdvb_client_t *client =
+		container_of(feed->demux, struct smsdvb_client_t, demux);
+	struct SmsMsgData_ST PidMsg;
+
+	sms_debug("remove pid %d(%x)",
+		  feed->pid, feed->pid);
+
+	PidMsg.xMsgHeader.msgSrcId = DVBT_BDA_CONTROL_MSG_ID;
+	PidMsg.xMsgHeader.msgDstId = HIF_TASK;
+	PidMsg.xMsgHeader.msgFlags = 0;
+	PidMsg.xMsgHeader.msgType  = MSG_SMS_REMOVE_PID_FILTER_REQ;
+	PidMsg.xMsgHeader.msgLength = sizeof(PidMsg);
+	PidMsg.msgData[0] = feed->pid;
+
+	return smsclient_sendrequest(client->smsclient,
+				     &PidMsg, sizeof(PidMsg));
+}
+
+static int smsdvb_sendrequest_and_wait(struct smsdvb_client_t *client,
+					void *buffer, size_t size,
+					struct completion *completion)
+{
+	int rc;
+
+	rc = smsclient_sendrequest(client->smsclient, buffer, size);
+	if (rc < 0)
+		return rc;
+
+	return wait_for_completion_timeout(completion,
+					   msecs_to_jiffies(2000)) ?
+						0 : -ETIME;
+}
+
+static int smsdvb_send_statistics_request(struct smsdvb_client_t *client)
+{
+	int rc;
+	struct SmsMsgHdr_ST Msg;
+
+
+	Msg.msgSrcId = DVBT_BDA_CONTROL_MSG_ID;
+	Msg.msgDstId = HIF_TASK;
+	Msg.msgFlags = 0;
+	Msg.msgLength = sizeof(Msg);
+
+	switch (smscore_get_device_mode(client->coredev)) {
+	case DEVICE_MODE_ISDBT:
+	case DEVICE_MODE_ISDBT_BDA:
+		/*
+		* Check for firmware version, to avoid breaking for old cards
+		*/
+		if (client->coredev->fw_version >= 0x800)
+			Msg.msgType = MSG_SMS_GET_STATISTICS_EX_REQ;
+		else
+			Msg.msgType = MSG_SMS_GET_STATISTICS_REQ;
+		break;
+	default:
+		Msg.msgType = MSG_SMS_GET_STATISTICS_REQ;
+	}
+
+	rc = smsdvb_sendrequest_and_wait(client, &Msg, sizeof(Msg),
+					 &client->stats_done);
+
+	return rc;
+}
+
+static inline int led_feedback(struct smsdvb_client_t *client)
+{
+	if (!(client->fe_status & FE_HAS_LOCK))
+		return sms_board_led_feedback(client->coredev, SMS_LED_OFF);
+
+	return sms_board_led_feedback(client->coredev,
+				     (client->legacy_ber == 0) ?
+				     SMS_LED_HI : SMS_LED_LO);
+}
+
+static int smsdvb_read_status(struct dvb_frontend *fe, fe_status_t *stat)
+{
+	int rc;
+	struct smsdvb_client_t *client;
+	client = container_of(fe, struct smsdvb_client_t, frontend);
+
+	rc = smsdvb_send_statistics_request(client);
+
+	*stat = client->fe_status;
+
+	led_feedback(client);
+
+	return rc;
+}
+
+static int smsdvb_read_ber(struct dvb_frontend *fe, u32 *ber)
+{
+	int rc;
+	struct smsdvb_client_t *client;
+
+	client = container_of(fe, struct smsdvb_client_t, frontend);
+
+	rc = smsdvb_send_statistics_request(client);
+
+	*ber = client->legacy_ber;
+
+	led_feedback(client);
+
+	return rc;
+}
+
+static int smsdvb_read_signal_strength(struct dvb_frontend *fe, u16 *strength)
+{
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	int rc;
+	s32 power = (s32) c->strength.stat[0].uvalue;
+	struct smsdvb_client_t *client;
+
+	client = container_of(fe, struct smsdvb_client_t, frontend);
+
+	rc = smsdvb_send_statistics_request(client);
+
+	if (power < -95)
+		*strength = 0;
+		else if (power > -29)
+			*strength = 65535;
+		else
+			*strength = (power + 95) * 65535 / 66;
+
+	led_feedback(client);
+
+	return rc;
+}
+
+static int smsdvb_read_snr(struct dvb_frontend *fe, u16 *snr)
+{
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	int rc;
+	struct smsdvb_client_t *client;
+
+	client = container_of(fe, struct smsdvb_client_t, frontend);
+
+	rc = smsdvb_send_statistics_request(client);
+
+	/* Preferred scale for SNR with legacy API: 0.1 dB */
+	*snr = c->cnr.stat[0].svalue / 100;
+
+	led_feedback(client);
+
+	return rc;
+}
+
+static int smsdvb_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)
+{
+	int rc;
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	struct smsdvb_client_t *client;
+
+	client = container_of(fe, struct smsdvb_client_t, frontend);
+
+	rc = smsdvb_send_statistics_request(client);
+
+	*ucblocks = c->block_error.stat[0].uvalue;
+
+	led_feedback(client);
+
+	return rc;
+}
+
+static int smsdvb_get_tune_settings(struct dvb_frontend *fe,
+				    struct dvb_frontend_tune_settings *tune)
+{
+	sms_debug("");
+
+	tune->min_delay_ms = 400;
+	tune->step_size = 250000;
+	tune->max_drift = 0;
+	return 0;
+}
+
+static int smsdvb_dvbt_set_frontend(struct dvb_frontend *fe)
+{
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	struct smsdvb_client_t *client =
+		container_of(fe, struct smsdvb_client_t, frontend);
+
+	struct {
+		struct SmsMsgHdr_ST	Msg;
+		u32		Data[3];
+	} Msg;
+
+	int ret;
+
+	client->fe_status = 0;
+	client->event_fe_state = -1;
+	client->event_unc_state = -1;
+	fe->dtv_property_cache.delivery_system = SYS_DVBT;
+
+	Msg.Msg.msgSrcId = DVBT_BDA_CONTROL_MSG_ID;
+	Msg.Msg.msgDstId = HIF_TASK;
+	Msg.Msg.msgFlags = 0;
+	Msg.Msg.msgType = MSG_SMS_RF_TUNE_REQ;
+	Msg.Msg.msgLength = sizeof(Msg);
+	Msg.Data[0] = c->frequency;
+	Msg.Data[2] = 12000000;
+
+	sms_info("%s: freq %d band %d", __func__, c->frequency,
+		 c->bandwidth_hz);
+
+	switch (c->bandwidth_hz / 1000000) {
+	case 8:
+		Msg.Data[1] = BW_8_MHZ;
+		break;
+	case 7:
+		Msg.Data[1] = BW_7_MHZ;
+		break;
+	case 6:
+		Msg.Data[1] = BW_6_MHZ;
+		break;
+	case 0:
+		return -EOPNOTSUPP;
+	default:
+		return -EINVAL;
+	}
+	/* Disable LNA, if any. An error is returned if no LNA is present */
+	ret = sms_board_lna_control(client->coredev, 0);
+	if (ret == 0) {
+		fe_status_t status;
+
+		/* tune with LNA off at first */
+		ret = smsdvb_sendrequest_and_wait(client, &Msg, sizeof(Msg),
+						  &client->tune_done);
+
+		smsdvb_read_status(fe, &status);
+
+		if (status & FE_HAS_LOCK)
+			return ret;
+
+		/* previous tune didn't lock - enable LNA and tune again */
+		sms_board_lna_control(client->coredev, 1);
+	}
+
+	return smsdvb_sendrequest_and_wait(client, &Msg, sizeof(Msg),
+					   &client->tune_done);
+}
+
+static int smsdvb_isdbt_set_frontend(struct dvb_frontend *fe)
+{
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	struct smsdvb_client_t *client =
+		container_of(fe, struct smsdvb_client_t, frontend);
+	int board_id = smscore_get_board_id(client->coredev);
+	struct sms_board *board = sms_get_board(board_id);
+	enum sms_device_type_st type = board->type;
+	int ret;
+
+	struct {
+		struct SmsMsgHdr_ST	Msg;
+		u32		Data[4];
+	} Msg;
+
+	fe->dtv_property_cache.delivery_system = SYS_ISDBT;
+
+	Msg.Msg.msgSrcId  = DVBT_BDA_CONTROL_MSG_ID;
+	Msg.Msg.msgDstId  = HIF_TASK;
+	Msg.Msg.msgFlags  = 0;
+	Msg.Msg.msgType   = MSG_SMS_ISDBT_TUNE_REQ;
+	Msg.Msg.msgLength = sizeof(Msg);
+
+	if (c->isdbt_sb_segment_idx == -1)
+		c->isdbt_sb_segment_idx = 0;
+
+	if (!c->isdbt_layer_enabled)
+		c->isdbt_layer_enabled = 7;
+
+	Msg.Data[0] = c->frequency;
+	Msg.Data[1] = BW_ISDBT_1SEG;
+	Msg.Data[2] = 12000000;
+	Msg.Data[3] = c->isdbt_sb_segment_idx;
+
+	if (c->isdbt_partial_reception) {
+		if ((type == SMS_PELE || type == SMS_RIO) &&
+		    c->isdbt_sb_segment_count > 3)
+			Msg.Data[1] = BW_ISDBT_13SEG;
+		else if (c->isdbt_sb_segment_count > 1)
+			Msg.Data[1] = BW_ISDBT_3SEG;
+	} else if (type == SMS_PELE || type == SMS_RIO)
+		Msg.Data[1] = BW_ISDBT_13SEG;
+
+	c->bandwidth_hz = 6000000;
+
+	sms_info("%s: freq %d segwidth %d segindex %d\n", __func__,
+		 c->frequency, c->isdbt_sb_segment_count,
+		 c->isdbt_sb_segment_idx);
+
+	/* Disable LNA, if any. An error is returned if no LNA is present */
+	ret = sms_board_lna_control(client->coredev, 0);
+	if (ret == 0) {
+		fe_status_t status;
+
+		/* tune with LNA off at first */
+		ret = smsdvb_sendrequest_and_wait(client, &Msg, sizeof(Msg),
+						  &client->tune_done);
+
+		smsdvb_read_status(fe, &status);
+
+		if (status & FE_HAS_LOCK)
+			return ret;
+
+		/* previous tune didn't lock - enable LNA and tune again */
+		sms_board_lna_control(client->coredev, 1);
+	}
+	return smsdvb_sendrequest_and_wait(client, &Msg, sizeof(Msg),
+					   &client->tune_done);
+}
+
+static int smsdvb_set_frontend(struct dvb_frontend *fe)
+{
+	struct smsdvb_client_t *client =
+		container_of(fe, struct smsdvb_client_t, frontend);
+	struct smscore_device_t *coredev = client->coredev;
+
+	smsdvb_stats_not_ready(fe);
+
+	switch (smscore_get_device_mode(coredev)) {
+	case DEVICE_MODE_DVBT:
+	case DEVICE_MODE_DVBT_BDA:
+		return smsdvb_dvbt_set_frontend(fe);
+	case DEVICE_MODE_ISDBT:
+	case DEVICE_MODE_ISDBT_BDA:
+		return smsdvb_isdbt_set_frontend(fe);
+	default:
+		return -EINVAL;
+	}
+}
+
+/* Nothing to do here, as stats are automatically updated */
+static int smsdvb_get_frontend(struct dvb_frontend *fe)
+{
+	return 0;
+}
+
+static int smsdvb_init(struct dvb_frontend *fe)
+{
+	struct smsdvb_client_t *client =
+		container_of(fe, struct smsdvb_client_t, frontend);
+
+	sms_board_power(client->coredev, 1);
+
+	sms_board_dvb3_event(client, DVB3_EVENT_INIT);
+	return 0;
+}
+
+static int smsdvb_sleep(struct dvb_frontend *fe)
+{
+	struct smsdvb_client_t *client =
+		container_of(fe, struct smsdvb_client_t, frontend);
+
+	sms_board_led_feedback(client->coredev, SMS_LED_OFF);
+	sms_board_power(client->coredev, 0);
+
+	sms_board_dvb3_event(client, DVB3_EVENT_SLEEP);
+
+	return 0;
+}
+
+static void smsdvb_release(struct dvb_frontend *fe)
+{
+	/* do nothing */
+}
+
+static struct dvb_frontend_ops smsdvb_fe_ops = {
+	.info = {
+		.name			= "Siano Mobile Digital MDTV Receiver",
+		.frequency_min		= 44250000,
+		.frequency_max		= 867250000,
+		.frequency_stepsize	= 250000,
+		.caps = FE_CAN_INVERSION_AUTO |
+			FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |
+			FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |
+			FE_CAN_QPSK | FE_CAN_QAM_16 | FE_CAN_QAM_64 |
+			FE_CAN_QAM_AUTO | FE_CAN_TRANSMISSION_MODE_AUTO |
+			FE_CAN_GUARD_INTERVAL_AUTO |
+			FE_CAN_RECOVER |
+			FE_CAN_HIERARCHY_AUTO,
+	},
+
+	.release = smsdvb_release,
+
+	.set_frontend = smsdvb_set_frontend,
+	.get_frontend = smsdvb_get_frontend,
+	.get_tune_settings = smsdvb_get_tune_settings,
+
+	.read_status = smsdvb_read_status,
+	.read_ber = smsdvb_read_ber,
+	.read_signal_strength = smsdvb_read_signal_strength,
+	.read_snr = smsdvb_read_snr,
+	.read_ucblocks = smsdvb_read_ucblocks,
+
+	.init = smsdvb_init,
+	.sleep = smsdvb_sleep,
+};
+
+static int smsdvb_hotplug(struct smscore_device_t *coredev,
+			  struct device *device, int arrival)
+{
+	struct smsclient_params_t params;
+	struct smsdvb_client_t *client;
+	int rc;
+
+	/* device removal handled by onremove callback */
+	if (!arrival)
+		return 0;
+	client = kzalloc(sizeof(struct smsdvb_client_t), GFP_KERNEL);
+	if (!client) {
+		sms_err("kmalloc() failed");
+		return -ENOMEM;
+	}
+
+	/* register dvb adapter */
+	rc = dvb_register_adapter(&client->adapter,
+				  sms_get_board(
+					smscore_get_board_id(coredev))->name,
+				  THIS_MODULE, device, adapter_nr);
+	if (rc < 0) {
+		sms_err("dvb_register_adapter() failed %d", rc);
+		goto adapter_error;
+	}
+
+	/* init dvb demux */
+	client->demux.dmx.capabilities = DMX_TS_FILTERING;
+	client->demux.filternum = 32; /* todo: nova ??? */
+	client->demux.feednum = 32;
+	client->demux.start_feed = smsdvb_start_feed;
+	client->demux.stop_feed = smsdvb_stop_feed;
+
+	rc = dvb_dmx_init(&client->demux);
+	if (rc < 0) {
+		sms_err("dvb_dmx_init failed %d", rc);
+		goto dvbdmx_error;
+	}
+
+	/* init dmxdev */
+	client->dmxdev.filternum = 32;
+	client->dmxdev.demux = &client->demux.dmx;
+	client->dmxdev.capabilities = 0;
+
+	rc = dvb_dmxdev_init(&client->dmxdev, &client->adapter);
+	if (rc < 0) {
+		sms_err("dvb_dmxdev_init failed %d", rc);
+		goto dmxdev_error;
+	}
+
+	/* init and register frontend */
+	memcpy(&client->frontend.ops, &smsdvb_fe_ops,
+	       sizeof(struct dvb_frontend_ops));
+
+	switch (smscore_get_device_mode(coredev)) {
+	case DEVICE_MODE_DVBT:
+	case DEVICE_MODE_DVBT_BDA:
+		client->frontend.ops.delsys[0] = SYS_DVBT;
+		break;
+	case DEVICE_MODE_ISDBT:
+	case DEVICE_MODE_ISDBT_BDA:
+		client->frontend.ops.delsys[0] = SYS_ISDBT;
+		break;
+	}
+
+	rc = dvb_register_frontend(&client->adapter, &client->frontend);
+	if (rc < 0) {
+		sms_err("frontend registration failed %d", rc);
+		goto frontend_error;
+	}
+
+	params.initial_id = 1;
+	params.data_type = MSG_SMS_DVBT_BDA_DATA;
+	params.onresponse_handler = smsdvb_onresponse;
+	params.onremove_handler = smsdvb_onremove;
+	params.context = client;
+
+	rc = smscore_register_client(coredev, &params, &client->smsclient);
+	if (rc < 0) {
+		sms_err("smscore_register_client() failed %d", rc);
+		goto client_error;
+	}
+
+	client->coredev = coredev;
+
+	init_completion(&client->tune_done);
+	init_completion(&client->stats_done);
+
+	kmutex_lock(&g_smsdvb_clientslock);
+
+	list_add(&client->entry, &g_smsdvb_clients);
+
+	kmutex_unlock(&g_smsdvb_clientslock);
+
+	client->event_fe_state = -1;
+	client->event_unc_state = -1;
+	sms_board_dvb3_event(client, DVB3_EVENT_HOTPLUG);
+
+	sms_info("success");
+	sms_board_setup(coredev);
+
+	if (smsdvb_debugfs_create(client) < 0)
+		sms_info("failed to create debugfs node");
+
+	return 0;
+
+client_error:
+	dvb_unregister_frontend(&client->frontend);
+
+frontend_error:
+	dvb_dmxdev_release(&client->dmxdev);
+
+dmxdev_error:
+	dvb_dmx_release(&client->demux);
+
+dvbdmx_error:
+	dvb_unregister_adapter(&client->adapter);
+
+adapter_error:
+	kfree(client);
+	return rc;
+}
+
+static int __init smsdvb_module_init(void)
+{
+	int rc;
+
+	INIT_LIST_HEAD(&g_smsdvb_clients);
+	kmutex_init(&g_smsdvb_clientslock);
+
+	smsdvb_debugfs_register();
+
+	rc = smscore_register_hotplug(smsdvb_hotplug);
+
+	sms_debug("");
+
+	return rc;
+}
+
+static void __exit smsdvb_module_exit(void)
+{
+	smscore_unregister_hotplug(smsdvb_hotplug);
+
+	kmutex_lock(&g_smsdvb_clientslock);
+
+	while (!list_empty(&g_smsdvb_clients))
+		smsdvb_unregister_client((struct smsdvb_client_t *)g_smsdvb_clients.next);
+
+	smsdvb_debugfs_unregister();
+
+	kmutex_unlock(&g_smsdvb_clientslock);
+}
+
+module_init(smsdvb_module_init);
+module_exit(smsdvb_module_exit);
+
+MODULE_DESCRIPTION("SMS DVB subsystem adaptation module");
+MODULE_AUTHOR("Siano Mobile Silicon, Inc. (uris@siano-ms.com)");
+MODULE_LICENSE("GPL");
