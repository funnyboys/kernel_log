commit f5d72c5c55bc392523cbdcdedd575c280203d31c
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Nov 16 09:10:06 2018 +0100

    mmc: stop abusing the request queue_lock pointer
    
    Replace the lock in mmc_blk_data that is only used through a pointer
    in struct mmc_queue and to protect fields in that structure with
    an actual lock in struct mmc_queue.
    
    Suggested-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/drivers/mmc/core/queue.h b/drivers/mmc/core/queue.h
index 5421f1542e71..fd11491ced9f 100644
--- a/drivers/mmc/core/queue.h
+++ b/drivers/mmc/core/queue.h
@@ -73,11 +73,11 @@ struct mmc_queue_req {
 
 struct mmc_queue {
 	struct mmc_card		*card;
-	spinlock_t		*lock;
 	struct mmc_ctx		ctx;
 	struct blk_mq_tag_set	tag_set;
 	struct mmc_blk_data	*blkdata;
 	struct request_queue	*queue;
+	spinlock_t		lock;
 	int			in_flight[MMC_ISSUE_MAX];
 	unsigned int		cqe_busy;
 #define MMC_CQE_DCMD_BUSY	BIT(0)
@@ -96,7 +96,7 @@ struct mmc_queue {
 	struct work_struct	complete_work;
 };
 
-extern int mmc_init_queue(struct mmc_queue *, struct mmc_card *, spinlock_t *);
+extern int mmc_init_queue(struct mmc_queue *, struct mmc_card *);
 extern void mmc_cleanup_queue(struct mmc_queue *);
 extern void mmc_queue_suspend(struct mmc_queue *);
 extern void mmc_queue_resume(struct mmc_queue *);

commit 310df020cdd7570e1a8ee43bd58999a743686eda
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Nov 14 17:02:17 2018 +0100

    mmc: stop abusing the request queue_lock pointer
    
    mmc uses the block layer struct request pointer to indirect their own
    lock to the mmc_queue structure, given that the original lock isn't
    reachable outside of block.c.  Add a lock pointer to struct mmc_queue
    instead and stop overriding the block layer lock which protects fields
    entirely separate from the mmc use.
    
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/drivers/mmc/core/queue.h b/drivers/mmc/core/queue.h
index 29218e12900d..5421f1542e71 100644
--- a/drivers/mmc/core/queue.h
+++ b/drivers/mmc/core/queue.h
@@ -73,6 +73,7 @@ struct mmc_queue_req {
 
 struct mmc_queue {
 	struct mmc_card		*card;
+	spinlock_t		*lock;
 	struct mmc_ctx		ctx;
 	struct blk_mq_tag_set	tag_set;
 	struct mmc_blk_data	*blkdata;

commit b061b326287d45aeaf313f7dddd02e88e31db14b
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Nov 14 17:02:16 2018 +0100

    mmc: simplify queue initialization
    
    Merge three functions initializing the queue into a single one, and drop
    an unused argument for it.
    
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/drivers/mmc/core/queue.h b/drivers/mmc/core/queue.h
index 9bf3c9245075..29218e12900d 100644
--- a/drivers/mmc/core/queue.h
+++ b/drivers/mmc/core/queue.h
@@ -95,8 +95,7 @@ struct mmc_queue {
 	struct work_struct	complete_work;
 };
 
-extern int mmc_init_queue(struct mmc_queue *, struct mmc_card *, spinlock_t *,
-			  const char *);
+extern int mmc_init_queue(struct mmc_queue *, struct mmc_card *, spinlock_t *);
 extern void mmc_cleanup_queue(struct mmc_queue *);
 extern void mmc_queue_suspend(struct mmc_queue *);
 extern void mmc_queue_resume(struct mmc_queue *);

commit 26caddf274cf1e89fd4ce44ab2b8dbc7a7f97681
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Tue Aug 21 15:05:55 2018 +0300

    mmc: block: Fix unsupported parallel dispatch of requests
    
    The mmc block driver does not support parallel dispatch of requests. In
    normal circumstances, all requests are anyway funneled through a single
    work item, so parallel dispatch never happens. However it can happen if
    there is no elevator.
    
    Fix that by detecting if a dispatch is in progress and returning busy
    (BLK_STS_RESOURCE) in that case
    
    Fixes: 81196976ed94 ("mmc: block: Add blk-mq support")
    Cc: stable@vger.kernel.org # v4.16+
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/queue.h b/drivers/mmc/core/queue.h
index 17e59d50b496..9bf3c9245075 100644
--- a/drivers/mmc/core/queue.h
+++ b/drivers/mmc/core/queue.h
@@ -81,6 +81,7 @@ struct mmc_queue {
 	unsigned int		cqe_busy;
 #define MMC_CQE_DCMD_BUSY	BIT(0)
 #define MMC_CQE_QUEUE_FULL	BIT(1)
+	bool			busy;
 	bool			use_cqe;
 	bool			recovery_needed;
 	bool			in_recovery;

commit 0fbfd12518303e9b32ac9fd231439459eac848f9
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Wed Nov 29 15:41:18 2017 +0200

    mmc: block: Remove code no longer needed after the switch to blk-mq
    
    Remove code no longer needed after the switch to blk-mq.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Tested-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/queue.h b/drivers/mmc/core/queue.h
index 34f601c6dd39..17e59d50b496 100644
--- a/drivers/mmc/core/queue.h
+++ b/drivers/mmc/core/queue.h
@@ -34,7 +34,6 @@ static inline struct request *mmc_queue_req_to_req(struct mmc_queue_req *mqr)
 	return blk_mq_rq_from_pdu(mqr);
 }
 
-struct task_struct;
 struct mmc_blk_data;
 struct mmc_blk_ioc_data;
 
@@ -44,7 +43,6 @@ struct mmc_blk_request {
 	struct mmc_command	cmd;
 	struct mmc_command	stop;
 	struct mmc_data		data;
-	int			retune_retry_done;
 };
 
 /**
@@ -66,7 +64,6 @@ enum mmc_drv_op {
 struct mmc_queue_req {
 	struct mmc_blk_request	brq;
 	struct scatterlist	*sg;
-	struct mmc_async_req	areq;
 	enum mmc_drv_op		drv_op;
 	int			drv_op_result;
 	void			*drv_op_data;
@@ -76,22 +73,10 @@ struct mmc_queue_req {
 
 struct mmc_queue {
 	struct mmc_card		*card;
-	struct task_struct	*thread;
-	struct semaphore	thread_sem;
 	struct mmc_ctx		ctx;
 	struct blk_mq_tag_set	tag_set;
-	bool			suspended;
-	bool			asleep;
 	struct mmc_blk_data	*blkdata;
 	struct request_queue	*queue;
-	/*
-	 * FIXME: this counter is not a very reliable way of keeping
-	 * track of how many requests that are ongoing. Switch to just
-	 * letting the block core keep track of requests and per-request
-	 * associated mmc_queue_req data.
-	 */
-	int			qcnt;
-
 	int			in_flight[MMC_ISSUE_MAX];
 	unsigned int		cqe_busy;
 #define MMC_CQE_DCMD_BUSY	BIT(0)

commit 10f21df4a23540b5da8e88d1030ff8c37818e04f
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Wed Nov 29 15:41:07 2017 +0200

    mmc: block: blk-mq: Add support for direct completion
    
    For blk-mq, add support for completing requests directly in the ->done
    callback. That means that error handling and urgent background operations
    must be handled by recovery_work in that case.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Tested-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/mmc/core/queue.h b/drivers/mmc/core/queue.h
index 1d7d3b0afff8..34f601c6dd39 100644
--- a/drivers/mmc/core/queue.h
+++ b/drivers/mmc/core/queue.h
@@ -103,6 +103,7 @@ struct mmc_queue {
 	bool			waiting;
 	struct work_struct	recovery_work;
 	wait_queue_head_t	wait;
+	struct request		*recovery_req;
 	struct request		*complete_req;
 	struct mutex		complete_lock;
 	struct work_struct	complete_work;

commit 1e8e55b67030c6a2fef893d428bdcd611f73705c
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Wed Nov 29 15:41:04 2017 +0200

    mmc: block: Add CQE support
    
    Add CQE support to the block driver, including:
        - optionally using DCMD for flush requests
        - "manually" issuing discard requests
        - issuing read / write requests to the CQE
        - supporting block-layer timeouts
        - handling recovery
        - supporting re-tuning
    
    CQE offers 25% - 50% better random multi-threaded I/O.  There is a slight
    (e.g. 2%) drop in sequential read speed but no observable change to sequential
    write.
    
    CQE automatically sends the commands to complete requests.  However it only
    supports reads / writes and so-called "direct commands" (DCMD).  Furthermore
    DCMD is limited to one command at a time, but discards require 3 commands.
    That makes issuing discards through CQE very awkward, but some CQE's don't
    support DCMD anyway.  So for discards, the existing non-CQE approach is
    taken, where the mmc core code issues the 3 commands one at a time i.e.
    mmc_erase(). Where DCMD is used, is for issuing flushes.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Tested-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/mmc/core/queue.h b/drivers/mmc/core/queue.h
index ce9249852f26..1d7d3b0afff8 100644
--- a/drivers/mmc/core/queue.h
+++ b/drivers/mmc/core/queue.h
@@ -17,6 +17,7 @@ enum mmc_issued {
 
 enum mmc_issue_type {
 	MMC_ISSUE_SYNC,
+	MMC_ISSUE_DCMD,
 	MMC_ISSUE_ASYNC,
 	MMC_ISSUE_MAX,
 };
@@ -92,8 +93,15 @@ struct mmc_queue {
 	int			qcnt;
 
 	int			in_flight[MMC_ISSUE_MAX];
+	unsigned int		cqe_busy;
+#define MMC_CQE_DCMD_BUSY	BIT(0)
+#define MMC_CQE_QUEUE_FULL	BIT(1)
+	bool			use_cqe;
+	bool			recovery_needed;
+	bool			in_recovery;
 	bool			rw_wait;
 	bool			waiting;
+	struct work_struct	recovery_work;
 	wait_queue_head_t	wait;
 	struct request		*complete_req;
 	struct mutex		complete_lock;
@@ -108,11 +116,21 @@ extern void mmc_queue_resume(struct mmc_queue *);
 extern unsigned int mmc_queue_map_sg(struct mmc_queue *,
 				     struct mmc_queue_req *);
 
+void mmc_cqe_check_busy(struct mmc_queue *mq);
+void mmc_cqe_recovery_notifier(struct mmc_request *mrq);
+
 enum mmc_issue_type mmc_issue_type(struct mmc_queue *mq, struct request *req);
 
 static inline int mmc_tot_in_flight(struct mmc_queue *mq)
 {
 	return mq->in_flight[MMC_ISSUE_SYNC] +
+	       mq->in_flight[MMC_ISSUE_DCMD] +
+	       mq->in_flight[MMC_ISSUE_ASYNC];
+}
+
+static inline int mmc_cqe_qcnt(struct mmc_queue *mq)
+{
+	return mq->in_flight[MMC_ISSUE_DCMD] +
 	       mq->in_flight[MMC_ISSUE_ASYNC];
 }
 

commit 81196976ed946cbf36bb41ddda402853c7df7cfa
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Wed Nov 29 15:41:03 2017 +0200

    mmc: block: Add blk-mq support
    
    Define and use a blk-mq queue. Discards and flushes are processed
    synchronously, but reads and writes asynchronously. In order to support
    slow DMA unmapping, DMA unmapping is not done until after the next request
    is started. That means the request is not completed until then. If there is
    no next request then the completion is done by queued work.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Tested-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/mmc/core/queue.h b/drivers/mmc/core/queue.h
index 547b457c4251..ce9249852f26 100644
--- a/drivers/mmc/core/queue.h
+++ b/drivers/mmc/core/queue.h
@@ -8,6 +8,19 @@
 #include <linux/mmc/core.h>
 #include <linux/mmc/host.h>
 
+enum mmc_issued {
+	MMC_REQ_STARTED,
+	MMC_REQ_BUSY,
+	MMC_REQ_FAILED_TO_START,
+	MMC_REQ_FINISHED,
+};
+
+enum mmc_issue_type {
+	MMC_ISSUE_SYNC,
+	MMC_ISSUE_ASYNC,
+	MMC_ISSUE_MAX,
+};
+
 static inline struct mmc_queue_req *req_to_mmc_queue_req(struct request *rq)
 {
 	return blk_mq_rq_to_pdu(rq);
@@ -57,12 +70,15 @@ struct mmc_queue_req {
 	int			drv_op_result;
 	void			*drv_op_data;
 	unsigned int		ioc_count;
+	int			retries;
 };
 
 struct mmc_queue {
 	struct mmc_card		*card;
 	struct task_struct	*thread;
 	struct semaphore	thread_sem;
+	struct mmc_ctx		ctx;
+	struct blk_mq_tag_set	tag_set;
 	bool			suspended;
 	bool			asleep;
 	struct mmc_blk_data	*blkdata;
@@ -74,6 +90,14 @@ struct mmc_queue {
 	 * associated mmc_queue_req data.
 	 */
 	int			qcnt;
+
+	int			in_flight[MMC_ISSUE_MAX];
+	bool			rw_wait;
+	bool			waiting;
+	wait_queue_head_t	wait;
+	struct request		*complete_req;
+	struct mutex		complete_lock;
+	struct work_struct	complete_work;
 };
 
 extern int mmc_init_queue(struct mmc_queue *, struct mmc_card *, spinlock_t *,
@@ -84,4 +108,12 @@ extern void mmc_queue_resume(struct mmc_queue *);
 extern unsigned int mmc_queue_map_sg(struct mmc_queue *,
 				     struct mmc_queue_req *);
 
+enum mmc_issue_type mmc_issue_type(struct mmc_queue *mq, struct request *req);
+
+static inline int mmc_tot_in_flight(struct mmc_queue *mq)
+{
+	return mq->in_flight[MMC_ISSUE_SYNC] +
+	       mq->in_flight[MMC_ISSUE_ASYNC];
+}
+
 #endif

commit dee02770cdcd8bc06a48c917ce5df2fb56cf6059
Merge: e4a8ca3baa55 06641e8deae6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Nov 13 10:17:35 2017 -0800

    Merge tag 'mmc-v4.15' of git://git.kernel.org/pub/scm/linux/kernel/git/ulfh/mmc
    
    Pull MMC updates from Ulf Hansson:
     "MMC core:
       - Introduce host claiming by context to support blkmq
       - Preparations for enabling CQE (eMMC CMDQ) requests
       - Re-factorizations to prepare for blkmq support
       - Re-factorizations to prepare for CQE support
       - Fix signal voltage switch for SD cards without power cycle
       - Convert RPMB to a character device
       - Export eMMC revision via sysfs
       - Support eMMC DT binding for fixed driver type
       - Document mmc_regulator_get_supply() API
    
     MMC host:
       - omap_hsmmc: Updated regulator management for PBIAS
       - sdhci-omap: Add new OMAP SDHCI driver
       - meson-mx-sdio: New driver for the Amlogic Meson8 and Meson8b SoCs
       - sdhci-pci: Add support for Intel CDF
       - sdhci-acpi: Fix voltage switch for some Intel host controllers
       - sdhci-msm: Enable delay circuit calibration clocks
       - sdhci-msm: Manage power IRQ properly
       - mediatek: Add support of mt2701/mt2712
       - mediatek: Updates management of clocks and tunings
       - mediatek: Upgrade eMMC HS400 support
       - rtsx_pci: Update tuning for gen3 PCI-Express
       - renesas_sdhi: Support R-Car Gen[123] fallback compatibility strings
       - Catch all errors when getting regulators
       - Various additional improvements and cleanups"
    
    * tag 'mmc-v4.15' of git://git.kernel.org/pub/scm/linux/kernel/git/ulfh/mmc: (91 commits)
      sdhci-fujitsu: add support for setting the CMD_DAT_DELAY attribute
      dt-bindings: sdhci-fujitsu: document cmd-dat-delay property
      mmc: tmio: Replace msleep() of 20ms or less with usleep_range()
      mmc: dw_mmc: Convert timers to use timer_setup()
      mmc: dw_mmc: Cleanup the DTO timer like the CTO one
      mmc: vub300: Use common code in __download_offload_pseudocode()
      mmc: tmio: Use common error handling code in tmio_mmc_host_probe()
      mmc: Convert timers to use timer_setup()
      mmc: sdhci-acpi: Fix voltage switch for some Intel host controllers
      mmc: sdhci-acpi: Let devices define their own private data
      mmc: mediatek: perfer to use rise edge latching for cmd line
      mmc: mediatek: improve eMMC hs400 mode read performance
      mmc: mediatek: add latch-ck support
      mmc: mediatek: add support of source_cg clock
      mmc: mediatek: add stop_clk fix and enhance_rx support
      mmc: mediatek: add busy_check support
      mmc: mediatek: add async fifo and data tune support
      mmc: mediatek: add pad_tune0 support
      mmc: mediatek: make hs400_tune_response only for mt8173
      arm64: dts: mt8173: remove "mediatek, mt8135-mmc" from mmc nodes
      ...

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/mmc/core/queue.h b/drivers/mmc/core/queue.h
index f18d3f656baa..6bfba32ffa66 100644
--- a/drivers/mmc/core/queue.h
+++ b/drivers/mmc/core/queue.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef MMC_QUEUE_H
 #define MMC_QUEUE_H
 

commit 14f4ca7e4d2825f9f71e22905ae177b899959f1d
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Wed Sep 20 10:02:01 2017 +0200

    mmc: block: Delete mmc_access_rpmb()
    
    This function is used by the block layer queue to bail out of
    requests if the current request is towards an RPMB
    "block device".
    
    This was done to avoid boot time scanning of this "block
    device" which was never really a block device, thus duct-taping
    over the fact that it was badly engineered.
    
    This problem is now gone as we removed the offending RPMB block
    device in another patch and replaced it with a character
    device.
    
    Cc: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/queue.h b/drivers/mmc/core/queue.h
index 5807c03dddcf..68f68ecd94ea 100644
--- a/drivers/mmc/core/queue.h
+++ b/drivers/mmc/core/queue.h
@@ -83,6 +83,4 @@ extern void mmc_queue_resume(struct mmc_queue *);
 extern unsigned int mmc_queue_map_sg(struct mmc_queue *,
 				     struct mmc_queue_req *);
 
-extern int mmc_access_rpmb(struct mmc_queue *);
-
 #endif

commit 97548575bef38abd06690a5a6f6816200c7e77f7
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Wed Sep 20 10:02:00 2017 +0200

    mmc: block: Convert RPMB to a character device
    
    The RPMB partition on the eMMC devices is a special area used
    for storing cryptographically safe information signed by a
    special secret key. To write and read records from this special
    area, authentication is needed.
    
    The RPMB area is *only* and *exclusively* accessed using
    ioctl():s from userspace. It is not really a block device,
    as blocks cannot be read or written from the device, also
    the signed chunks that can be stored on the RPMB are actually
    256 bytes, not 512 making a block device a real bad fit.
    
    Currently the RPMB partition spawns a separate block device
    named /dev/mmcblkNrpmb for each device with an RPMB partition,
    including the creation of a block queue with its own kernel
    thread and all overhead associated with this. On the Ux500
    HREFv60 platform, for example, the two eMMCs means that two
    block queues with separate threads are created for no use
    whatsoever.
    
    I have concluded that this block device design for RPMB is
    actually pretty wrong. The RPMB area should have been designed
    to be accessed from /dev/mmcblkN directly, using ioctl()s on
    the main block device. It is however way too late to change
    that, since userspace expects to open an RPMB device in
    /dev/mmcblkNrpmb and we cannot break userspace.
    
    This patch tries to amend the situation using the following
    strategy:
    
    - Stop creating a block device for the RPMB partition/area
    
    - Instead create a custom, dynamic character device with
      the same name.
    
    - Make this new character device support exactly the same
      set of ioctl()s as the old block device.
    
    - Wrap the requests back to the same ioctl() handlers, but
      issue them on the block queue of the main partition/area,
      i.e. /dev/mmcblkN
    
    We need to create a special "rpmb" bus type in order to get
    udev and/or busybox hot/coldplug to instantiate the device
    node properly.
    
    Before the patch, this appears in 'ps aux':
    
    101 root       0:00 [mmcqd/2rpmb]
    123 root       0:00 [mmcqd/3rpmb]
    
    After applying the patch these surplus block queue threads
    are gone, but RPMB is as usable as ever using the userspace
    MMC tools, such as 'mmc rpmb read-counter'.
    
    We get instead those dynamice devices in /dev:
    
    brw-rw----    1 root     root      179,   0 Jan  1  2000 mmcblk0
    brw-rw----    1 root     root      179,   1 Jan  1  2000 mmcblk0p1
    brw-rw----    1 root     root      179,   2 Jan  1  2000 mmcblk0p2
    brw-rw----    1 root     root      179,   5 Jan  1  2000 mmcblk0p5
    brw-rw----    1 root     root      179,   8 Jan  1  2000 mmcblk2
    brw-rw----    1 root     root      179,  16 Jan  1  2000 mmcblk2boot0
    brw-rw----    1 root     root      179,  24 Jan  1  2000 mmcblk2boot1
    crw-rw----    1 root     root      248,   0 Jan  1  2000 mmcblk2rpmb
    brw-rw----    1 root     root      179,  32 Jan  1  2000 mmcblk3
    brw-rw----    1 root     root      179,  40 Jan  1  2000 mmcblk3boot0
    brw-rw----    1 root     root      179,  48 Jan  1  2000 mmcblk3boot1
    brw-rw----    1 root     root      179,  33 Jan  1  2000 mmcblk3p1
    crw-rw----    1 root     root      248,   1 Jan  1  2000 mmcblk3rpmb
    
    Notice the (248,0) and (248,1) character devices for RPMB.
    
    Cc: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/queue.h b/drivers/mmc/core/queue.h
index f18d3f656baa..5807c03dddcf 100644
--- a/drivers/mmc/core/queue.h
+++ b/drivers/mmc/core/queue.h
@@ -35,12 +35,14 @@ struct mmc_blk_request {
 /**
  * enum mmc_drv_op - enumerates the operations in the mmc_queue_req
  * @MMC_DRV_OP_IOCTL: ioctl operation
+ * @MMC_DRV_OP_IOCTL_RPMB: RPMB-oriented ioctl operation
  * @MMC_DRV_OP_BOOT_WP: write protect boot partitions
  * @MMC_DRV_OP_GET_CARD_STATUS: get card status
  * @MMC_DRV_OP_GET_EXT_CSD: get the EXT CSD from an eMMC card
  */
 enum mmc_drv_op {
 	MMC_DRV_OP_IOCTL,
+	MMC_DRV_OP_IOCTL_RPMB,
 	MMC_DRV_OP_BOOT_WP,
 	MMC_DRV_OP_GET_CARD_STATUS,
 	MMC_DRV_OP_GET_EXT_CSD,

commit de3ee99b097dd51938276e3af388cd4ad0f2750a
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Wed Sep 20 10:56:14 2017 +0200

    mmc: Delete bounce buffer handling
    
    In may, Steven sent a patch deleting the bounce buffer handling
    and the CONFIG_MMC_BLOCK_BOUNCE option.
    
    I chose the less invasive path of making it a runtime config
    option, and we merged that successfully for kernel v4.12.
    
    The code is however just standing in the way and taking up
    space for seemingly no gain on any systems in wide use today.
    
    Pierre says the code was there to improve speed on TI SDHCI
    controllers on certain HP laptops and possibly some Ricoh
    controllers as well. Early SDHCI controllers lacked the
    scatter-gather feature, which made software bounce buffers
    a significant speed boost.
    
    We are clearly talking about the list of SDHCI PCI-based
    MMC/SD card readers found in the pci_ids[] list in
    drivers/mmc/host/sdhci-pci-core.c.
    
    The TI SDHCI derivative is not supported by the upstream
    kernel. This leaves the Ricoh.
    
    What we can however notice is that the x86 defconfigs in the
    kernel did not enable CONFIG_MMC_BLOCK_BOUNCE option, which
    means that any such laptop would have to have a custom
    configured kernel to actually take advantage of this
    bounce buffer speed-up. It simply seems like there was
    a speed optimization for the Ricoh controllers that noone
    was using. (I have not checked the distro defconfigs but
    I am pretty sure the situation is the same there.)
    
    Bounce buffers increased performance on the OMAP HSMMC
    at one point, and was part of the original submission in
    commit a45c6cb81647 ("[ARM] 5369/1: omap mmc: Add new
       omap hsmmc controller for 2430 and 34xx, v3")
    
    This optimization was removed in
    commit 0ccd76d4c236 ("omap_hsmmc: Implement scatter-gather
       emulation")
    which found that scatter-gather emulation provided even
    better performance.
    
    The same was introduced for SDHCI in
    commit 2134a922c6e7 ("sdhci: scatter-gather (ADMA) support")
    
    I am pretty positively convinced that software
    scatter-gather emulation will do for any host controller what
    the bounce buffers were doing. Essentially, the bounce buffer
    was a reimplementation of software scatter-gather-emulation in
    the MMC subsystem, and it should be done away with.
    
    Cc: Pierre Ossman <pierre@ossman.eu>
    Cc: Juha Yrjola <juha.yrjola@solidboot.com>
    Cc: Steven J. Hill <Steven.Hill@cavium.com>
    Cc: Shawn Lin <shawn.lin@rock-chips.com>
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Suggested-by: Steven J. Hill <Steven.Hill@cavium.com>
    Suggested-by: Shawn Lin <shawn.lin@rock-chips.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/queue.h b/drivers/mmc/core/queue.h
index 04fc89360a7a..f18d3f656baa 100644
--- a/drivers/mmc/core/queue.h
+++ b/drivers/mmc/core/queue.h
@@ -49,9 +49,6 @@ enum mmc_drv_op {
 struct mmc_queue_req {
 	struct mmc_blk_request	brq;
 	struct scatterlist	*sg;
-	char			*bounce_buf;
-	struct scatterlist	*bounce_sg;
-	unsigned int		bounce_sg_len;
 	struct mmc_async_req	areq;
 	enum mmc_drv_op		drv_op;
 	int			drv_op_result;
@@ -81,11 +78,8 @@ extern int mmc_init_queue(struct mmc_queue *, struct mmc_card *, spinlock_t *,
 extern void mmc_cleanup_queue(struct mmc_queue *);
 extern void mmc_queue_suspend(struct mmc_queue *);
 extern void mmc_queue_resume(struct mmc_queue *);
-
 extern unsigned int mmc_queue_map_sg(struct mmc_queue *,
 				     struct mmc_queue_req *);
-extern void mmc_queue_bounce_pre(struct mmc_queue_req *);
-extern void mmc_queue_bounce_post(struct mmc_queue_req *);
 
 extern int mmc_access_rpmb(struct mmc_queue *);
 

commit 627c3ccfb46ada2583eac434127ad5d75e1ac33c
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Sun Aug 20 23:39:08 2017 +0200

    mmc: debugfs: Move block debugfs into block module
    
    If we don't have the block layer enabled, we do not present card
    status and extcsd in the debugfs.
    
    Debugfs is not ABI, and maintaining files of no relevance for
    non-block devices comes at a high maintenance cost if we shall
    support it with the block layer compiled out.
    
    The debugfs entries suffer from all the same starvation
    issues as the other userspace things, under e.g. a heavy
    dd operation.
    
    The expected number of debugfs users utilizing these two
    debugfs files is already low as there is an ioctl() to get the
    same information using the mmc-tools, and of these few users
    the expected number of people using it on SDIO or combo cards
    are expected to be zero.
    
    It is therefore logical to move this over to the block layer
    when it is enabled, using the new custom requests and issue
    it using the block request queue.
    
    On the other hand it moves some debugfs code from debugfs.c
    and into block.c.
    
    Tested during heavy dd load by cat:in the status file.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/queue.h b/drivers/mmc/core/queue.h
index cf26a15a64bf..04fc89360a7a 100644
--- a/drivers/mmc/core/queue.h
+++ b/drivers/mmc/core/queue.h
@@ -36,10 +36,14 @@ struct mmc_blk_request {
  * enum mmc_drv_op - enumerates the operations in the mmc_queue_req
  * @MMC_DRV_OP_IOCTL: ioctl operation
  * @MMC_DRV_OP_BOOT_WP: write protect boot partitions
+ * @MMC_DRV_OP_GET_CARD_STATUS: get card status
+ * @MMC_DRV_OP_GET_EXT_CSD: get the EXT CSD from an eMMC card
  */
 enum mmc_drv_op {
 	MMC_DRV_OP_IOCTL,
 	MMC_DRV_OP_BOOT_WP,
+	MMC_DRV_OP_GET_CARD_STATUS,
+	MMC_DRV_OP_GET_EXT_CSD,
 };
 
 struct mmc_queue_req {

commit 69f7599e6c55b80aa34fee18217a67d16703b906
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Sun Aug 20 23:39:06 2017 +0200

    mmc: block: Anonymize the drv op data pointer
    
    We have a data pointer for the ioctl() data, but we need to
    pass other data along with the DRV_OP:s, so make this a
    void * so it can be reused.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/queue.h b/drivers/mmc/core/queue.h
index 361b46408e0f..cf26a15a64bf 100644
--- a/drivers/mmc/core/queue.h
+++ b/drivers/mmc/core/queue.h
@@ -51,7 +51,7 @@ struct mmc_queue_req {
 	struct mmc_async_req	areq;
 	enum mmc_drv_op		drv_op;
 	int			drv_op_result;
-	struct mmc_blk_ioc_data	**idata;
+	void			*drv_op_data;
 	unsigned int		ioc_count;
 };
 

commit 0493f6fe5bdee8ac101a1a0c449971c2d4665e99
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Fri May 19 15:37:30 2017 +0200

    mmc: block: Move boot partition locking into a driver op
    
    This moves the boot partition lock command (issued from sysfs)
    into a custom block layer request, just like the ioctl()s,
    getting rid of yet another instance of mmc_get_card().
    
    Since we now have two operations issuing special DRV_OP's, we
    rename the result variable ->drv_op_result.
    
    Tested by locking the boot partition from userspace:
    > cd /sys/devices/platform/soc/80114000.sdi4_per2/mmc_host/mmc3/
         mmc3:0001/block/mmcblk3/mmcblk3boot0
    > echo 1 > ro_lock_until_next_power_on
    [  178.645324] mmcblk3boot1: Locking boot partition ro until next power on
    [  178.652221] mmcblk3boot0: Locking boot partition ro until next power on
    
    Also tested this with a huge dd job in the background: it
    is now possible to lock the boot partitions on the card even
    under heavy I/O.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/queue.h b/drivers/mmc/core/queue.h
index 1e6062eb3e07..361b46408e0f 100644
--- a/drivers/mmc/core/queue.h
+++ b/drivers/mmc/core/queue.h
@@ -35,9 +35,11 @@ struct mmc_blk_request {
 /**
  * enum mmc_drv_op - enumerates the operations in the mmc_queue_req
  * @MMC_DRV_OP_IOCTL: ioctl operation
+ * @MMC_DRV_OP_BOOT_WP: write protect boot partitions
  */
 enum mmc_drv_op {
 	MMC_DRV_OP_IOCTL,
+	MMC_DRV_OP_BOOT_WP,
 };
 
 struct mmc_queue_req {
@@ -48,7 +50,7 @@ struct mmc_queue_req {
 	unsigned int		bounce_sg_len;
 	struct mmc_async_req	areq;
 	enum mmc_drv_op		drv_op;
-	int			ioc_result;
+	int			drv_op_result;
 	struct mmc_blk_ioc_data	**idata;
 	unsigned int		ioc_count;
 };

commit 02166a01f8113c6374d6f1512befa9233c837fa0
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Fri May 19 15:37:28 2017 +0200

    mmc: block: Tag DRV_OPs with a driver operation type
    
    We will expand the DRV_OP usage, so we need to know which
    operation we're performing. Tag the operations with an
    enum:ed type and rename the function so it is clear that
    it deals with any command and put a switch statement in
    it. Currently only ioctls are supported.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/queue.h b/drivers/mmc/core/queue.h
index 2793020a3c8c..1e6062eb3e07 100644
--- a/drivers/mmc/core/queue.h
+++ b/drivers/mmc/core/queue.h
@@ -32,6 +32,14 @@ struct mmc_blk_request {
 	int			retune_retry_done;
 };
 
+/**
+ * enum mmc_drv_op - enumerates the operations in the mmc_queue_req
+ * @MMC_DRV_OP_IOCTL: ioctl operation
+ */
+enum mmc_drv_op {
+	MMC_DRV_OP_IOCTL,
+};
+
 struct mmc_queue_req {
 	struct mmc_blk_request	brq;
 	struct scatterlist	*sg;
@@ -39,6 +47,7 @@ struct mmc_queue_req {
 	struct scatterlist	*bounce_sg;
 	unsigned int		bounce_sg_len;
 	struct mmc_async_req	areq;
+	enum mmc_drv_op		drv_op;
 	int			ioc_result;
 	struct mmc_blk_ioc_data	**idata;
 	unsigned int		ioc_count;

commit 67e69d5220c904238f94bb2e6001d7c590f5a0bb
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Fri May 19 15:37:27 2017 +0200

    mmc: block: remove req back pointer
    
    Just as we can use blk_mq_rq_from_pdu() to get the per-request
    tag we can use blk_mq_rq_to_pdu() to get a request from a tag.
    Introduce a static inline helper so we are on the clear what
    is happening.
    
    Suggested-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/queue.h b/drivers/mmc/core/queue.h
index dfe481a8b5ed..2793020a3c8c 100644
--- a/drivers/mmc/core/queue.h
+++ b/drivers/mmc/core/queue.h
@@ -12,6 +12,13 @@ static inline struct mmc_queue_req *req_to_mmc_queue_req(struct request *rq)
 	return blk_mq_rq_to_pdu(rq);
 }
 
+struct mmc_queue_req;
+
+static inline struct request *mmc_queue_req_to_req(struct mmc_queue_req *mqr)
+{
+	return blk_mq_rq_from_pdu(mqr);
+}
+
 struct task_struct;
 struct mmc_blk_data;
 struct mmc_blk_ioc_data;
@@ -26,7 +33,6 @@ struct mmc_blk_request {
 };
 
 struct mmc_queue_req {
-	struct request		*req;
 	struct mmc_blk_request	brq;
 	struct scatterlist	*sg;
 	char			*bounce_buf;

commit b428e712e1c684a17d788f8e29c7e61f0d92b690
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Thu May 18 11:29:36 2017 +0200

    mmc: queue: delete mmc_req_is_special()
    
    commit cdf8a6fb48882651049e468e6b16956fb83db86c
    "mmc: block: Introduce queue semantics"
    deleted the last user of mmc_req_is_special() and it was
    a horrible hack to classify requests as "special" or
    "not special" to begin with, so delete the helper.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/queue.h b/drivers/mmc/core/queue.h
index 8c76e7118c95..dfe481a8b5ed 100644
--- a/drivers/mmc/core/queue.h
+++ b/drivers/mmc/core/queue.h
@@ -12,14 +12,6 @@ static inline struct mmc_queue_req *req_to_mmc_queue_req(struct request *rq)
 	return blk_mq_rq_to_pdu(rq);
 }
 
-static inline bool mmc_req_is_special(struct request *req)
-{
-	return req &&
-		(req_op(req) == REQ_OP_FLUSH ||
-		 req_op(req) == REQ_OP_DISCARD ||
-		 req_op(req) == REQ_OP_SECURE_ERASE);
-}
-
 struct task_struct;
 struct mmc_blk_data;
 struct mmc_blk_ioc_data;

commit 3ecd8cf23f88d5df1c545a5c04217987abb28575
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Thu May 18 11:29:35 2017 +0200

    mmc: block: move multi-ioctl() to use block layer
    
    This switches also the multiple-command ioctl() call to issue
    all ioctl()s through the block layer instead of going directly
    to the device.
    
    We extend the passed argument with an argument count and loop
    over all passed commands in the ioctl() issue function called
    from the block layer.
    
    By doing this we are again loosening the grip on the big host
    lock, since two calls to mmc_get_card()/mmc_put_card() are
    removed.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Tested-by: Avri Altman <Avri.Altman@sandisk.com>

diff --git a/drivers/mmc/core/queue.h b/drivers/mmc/core/queue.h
index 005ece9ac7cb..8c76e7118c95 100644
--- a/drivers/mmc/core/queue.h
+++ b/drivers/mmc/core/queue.h
@@ -42,7 +42,8 @@ struct mmc_queue_req {
 	unsigned int		bounce_sg_len;
 	struct mmc_async_req	areq;
 	int			ioc_result;
-	struct mmc_blk_ioc_data	*idata;
+	struct mmc_blk_ioc_data	**idata;
+	unsigned int		ioc_count;
 };
 
 struct mmc_queue {

commit 614f0388f580c436d2cf6dc0855de91d13ddc23d
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Thu May 18 11:29:34 2017 +0200

    mmc: block: move single ioctl() commands to block requests
    
    This wraps single ioctl() commands into block requests using
    the custom block layer request types REQ_OP_DRV_IN and
    REQ_OP_DRV_OUT.
    
    By doing this we are loosening the grip on the big host lock,
    since two calls to mmc_get_card()/mmc_put_card() are removed.
    
    We are storing the ioctl() in/out argument as a pointer in
    the per-request struct mmc_blk_request container. Since we
    now let the block layer allocate this data, blk_get_request()
    will allocate it for us and we can immediately dereference
    it and use it to pass the argument into the block layer.
    
    We refactor the if/else/if/else ladder in mmc_blk_issue_rq()
    as part of the job, keeping some extra attention to the
    case when a NULL req is passed into this function and
    making that pipeline flush more explicit.
    
    Tested on the ux500 with the userspace:
    mmc extcsd read /dev/mmcblk3
    resulting in a successful EXTCSD info dump back to the
    console.
    
    This commit fixes a starvation issue in the MMC/SD stack
    that can be easily provoked in the following way by
    issueing the following commands in sequence:
    
    > dd if=/dev/mmcblk3 of=/dev/null bs=1M &
    > mmc extcs read /dev/mmcblk3
    
    Before this patch, the extcsd read command would hang
    (starve) while waiting for the dd command to finish since
    the block layer was holding the card/host lock.
    
    After this patch, the extcsd ioctl() command is nicely
    interpersed with the rest of the block commands and we
    can issue a bunch of ioctl()s from userspace while there
    is some busy block IO going on without any problems.
    
    Conversely userspace ioctl()s can no longer starve
    the block layer by holding the card/host lock.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Tested-by: Avri Altman <Avri.Altman@sandisk.com>

diff --git a/drivers/mmc/core/queue.h b/drivers/mmc/core/queue.h
index dae31bc0c2d3..005ece9ac7cb 100644
--- a/drivers/mmc/core/queue.h
+++ b/drivers/mmc/core/queue.h
@@ -22,6 +22,7 @@ static inline bool mmc_req_is_special(struct request *req)
 
 struct task_struct;
 struct mmc_blk_data;
+struct mmc_blk_ioc_data;
 
 struct mmc_blk_request {
 	struct mmc_request	mrq;
@@ -40,6 +41,8 @@ struct mmc_queue_req {
 	struct scatterlist	*bounce_sg;
 	unsigned int		bounce_sg_len;
 	struct mmc_async_req	areq;
+	int			ioc_result;
+	struct mmc_blk_ioc_data	*idata;
 };
 
 struct mmc_queue {

commit 304419d8a7e9204c5d19b704467b814df8c8f5b1
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Thu May 18 11:29:32 2017 +0200

    mmc: core: Allocate per-request data using the block layer core
    
    The mmc_queue_req is a per-request state container the MMC core uses
    to carry bounce buffers, pointers to asynchronous requests and so on.
    Currently allocated as a static array of objects, then as a request
    comes in, a mmc_queue_req is assigned to it, and used during the
    lifetime of the request.
    
    This is backwards compared to how other block layer drivers work:
    they usally let the block core provide a per-request struct that get
    allocated right beind the struct request, and which can be obtained
    using the blk_mq_rq_to_pdu() helper. (The _mq_ infix in this function
    name is misleading: it is used by both the old and the MQ block
    layer.)
    
    The per-request struct gets allocated to the size stored in the queue
    variable .cmd_size initialized using the .init_rq_fn() and
    cleaned up using .exit_rq_fn().
    
    The block layer code makes the MMC core rely on this mechanism to
    allocate the per-request mmc_queue_req state container.
    
    Doing this make a lot of complicated queue handling go away. We only
    need to keep the .qnct that keeps count of how many request are
    currently being processed by the MMC layer. The MQ block layer will
    replace also this once we transition to it.
    
    Doing this refactoring is necessary to move the ioctl() operations
    into custom block layer requests tagged with REQ_OP_DRV_[IN|OUT]
    instead of the custom code using the BigMMCHostLock that we have
    today: those require that per-request data be obtainable easily from
    a request after creating a custom request with e.g.:
    
    struct request *rq = blk_get_request(q, REQ_OP_DRV_IN, __GFP_RECLAIM);
    struct mmc_queue_req *mq_rq = req_to_mq_rq(rq);
    
    And this is not possible with the current construction, as the request
    is not immediately assigned the per-request state container, but
    instead it gets assigned when the request finally enters the MMC
    queue, which is way too late for custom requests.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    [Ulf: Folded in the fix to drop a call to blk_cleanup_queue()]
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Tested-by: Heiner Kallweit <hkallweit1@gmail.com>

diff --git a/drivers/mmc/core/queue.h b/drivers/mmc/core/queue.h
index 871796c3f406..dae31bc0c2d3 100644
--- a/drivers/mmc/core/queue.h
+++ b/drivers/mmc/core/queue.h
@@ -3,9 +3,15 @@
 
 #include <linux/types.h>
 #include <linux/blkdev.h>
+#include <linux/blk-mq.h>
 #include <linux/mmc/core.h>
 #include <linux/mmc/host.h>
 
+static inline struct mmc_queue_req *req_to_mmc_queue_req(struct request *rq)
+{
+	return blk_mq_rq_to_pdu(rq);
+}
+
 static inline bool mmc_req_is_special(struct request *req)
 {
 	return req &&
@@ -34,7 +40,6 @@ struct mmc_queue_req {
 	struct scatterlist	*bounce_sg;
 	unsigned int		bounce_sg_len;
 	struct mmc_async_req	areq;
-	int			task_id;
 };
 
 struct mmc_queue {
@@ -45,14 +50,15 @@ struct mmc_queue {
 	bool			asleep;
 	struct mmc_blk_data	*blkdata;
 	struct request_queue	*queue;
-	struct mmc_queue_req	*mqrq;
-	int			qdepth;
+	/*
+	 * FIXME: this counter is not a very reliable way of keeping
+	 * track of how many requests that are ongoing. Switch to just
+	 * letting the block core keep track of requests and per-request
+	 * associated mmc_queue_req data.
+	 */
 	int			qcnt;
-	unsigned long		qslots;
 };
 
-extern int mmc_queue_alloc_shared_queue(struct mmc_card *card);
-extern void mmc_queue_free_shared_queue(struct mmc_card *card);
 extern int mmc_init_queue(struct mmc_queue *, struct mmc_card *, spinlock_t *,
 			  const char *);
 extern void mmc_cleanup_queue(struct mmc_queue *);
@@ -66,8 +72,4 @@ extern void mmc_queue_bounce_post(struct mmc_queue_req *);
 
 extern int mmc_access_rpmb(struct mmc_queue *);
 
-extern struct mmc_queue_req *mmc_queue_req_find(struct mmc_queue *,
-						struct request *);
-extern void mmc_queue_req_free(struct mmc_queue *, struct mmc_queue_req *);
-
 #endif

commit 7b410d074b253a44624497a18e73f666a9574f37
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Mon Mar 13 14:36:36 2017 +0200

    mmc: queue: Share mmc request array between partitions
    
    eMMC can have multiple internal partitions that are represented as separate
    disks / queues. However switching between partitions is only done when the
    queue is empty. Consequently the array of mmc requests that are queued can
    be shared between partitions saving memory.
    
    Keep a pointer to the mmc request queue on the card, and use that instead
    of allocating a new one for each partition.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/queue.h b/drivers/mmc/core/queue.h
index 967808df45b8..871796c3f406 100644
--- a/drivers/mmc/core/queue.h
+++ b/drivers/mmc/core/queue.h
@@ -51,6 +51,8 @@ struct mmc_queue {
 	unsigned long		qslots;
 };
 
+extern int mmc_queue_alloc_shared_queue(struct mmc_card *card);
+extern void mmc_queue_free_shared_queue(struct mmc_card *card);
 extern int mmc_init_queue(struct mmc_queue *, struct mmc_card *, spinlock_t *,
 			  const char *);
 extern void mmc_cleanup_queue(struct mmc_queue *);

commit cdf8a6fb48882651049e468e6b16956fb83db86c
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Mon Mar 13 14:36:35 2017 +0200

    mmc: block: Introduce queue semantics
    
    Change from viewing the requests in progress as 'current' and 'previous',
    to viewing them as a queue. The current request is allocated to the first
    free slot. The presence of incomplete requests is determined from the
    count (mq->qcnt) of entries in the queue. Non-read-write requests (i.e.
    discards and flushes) are not added to the queue at all and require no
    special handling. Also no special handling is needed for the
    MMC_BLK_NEW_REQUEST case.
    
    As well as allowing an arbitrarily sized queue, the queue thread function
    is significantly simpler.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/queue.h b/drivers/mmc/core/queue.h
index e298f100101b..967808df45b8 100644
--- a/drivers/mmc/core/queue.h
+++ b/drivers/mmc/core/queue.h
@@ -34,21 +34,21 @@ struct mmc_queue_req {
 	struct scatterlist	*bounce_sg;
 	unsigned int		bounce_sg_len;
 	struct mmc_async_req	areq;
+	int			task_id;
 };
 
 struct mmc_queue {
 	struct mmc_card		*card;
 	struct task_struct	*thread;
 	struct semaphore	thread_sem;
-	bool			new_request;
 	bool			suspended;
 	bool			asleep;
 	struct mmc_blk_data	*blkdata;
 	struct request_queue	*queue;
 	struct mmc_queue_req	*mqrq;
-	struct mmc_queue_req	*mqrq_cur;
-	struct mmc_queue_req	*mqrq_prev;
 	int			qdepth;
+	int			qcnt;
+	unsigned long		qslots;
 };
 
 extern int mmc_init_queue(struct mmc_queue *, struct mmc_card *, spinlock_t *,
@@ -64,4 +64,8 @@ extern void mmc_queue_bounce_post(struct mmc_queue_req *);
 
 extern int mmc_access_rpmb(struct mmc_queue *);
 
+extern struct mmc_queue_req *mmc_queue_req_find(struct mmc_queue *,
+						struct request *);
+extern void mmc_queue_req_free(struct mmc_queue *, struct mmc_queue_req *);
+
 #endif

commit 9491be5ff06ff08d61e6a8d767382ea0037a6f38
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Wed Feb 1 13:47:56 2017 +0100

    mmc: queue: turn queue flags into bools
    
    Instead of masking and setting two bits in the "flags" field
    for the mmc_queue, just use two bools named "suspended" and
    "new_request".
    
    The masking and setting would likely have race conditions
    anyways, it is better to use a simple member like this.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/queue.h b/drivers/mmc/core/queue.h
index e0cd5b1f40ee..e298f100101b 100644
--- a/drivers/mmc/core/queue.h
+++ b/drivers/mmc/core/queue.h
@@ -40,9 +40,8 @@ struct mmc_queue {
 	struct mmc_card		*card;
 	struct task_struct	*thread;
 	struct semaphore	thread_sem;
-	unsigned int		flags;
-#define MMC_QUEUE_SUSPENDED	(1 << 0)
-#define MMC_QUEUE_NEW_REQUEST	(1 << 1)
+	bool			new_request;
+	bool			suspended;
 	bool			asleep;
 	struct mmc_blk_data	*blkdata;
 	struct request_queue	*queue;

commit 74f5ba357c7cd63c664e65fb7a116dbc0538a2ec
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Wed Feb 1 13:47:55 2017 +0100

    mmc: block: rename mmc_active to areq
    
    The mmc_active member of struct mmc_queue_req has a very
    confusing name: this is certainly not always "active", it is
    the asynchronous request associated by the mmc_queue_req
    but it is not guaranteed to be "active" in any sense, such
    as being running on the host.
    
    Simply rename this member to "areq".
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/queue.h b/drivers/mmc/core/queue.h
index 0cea02af79d1..e0cd5b1f40ee 100644
--- a/drivers/mmc/core/queue.h
+++ b/drivers/mmc/core/queue.h
@@ -33,7 +33,7 @@ struct mmc_queue_req {
 	char			*bounce_buf;
 	struct scatterlist	*bounce_sg;
 	unsigned int		bounce_sg_len;
-	struct mmc_async_req	mmc_active;
+	struct mmc_async_req	areq;
 };
 
 struct mmc_queue {

commit 066185d690631478b16045d152b163a51a5e4847
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri Jan 13 14:14:07 2017 +0100

    mmc: core: First step in cleaning up private mmc header files
    
    This is the first step in cleaning up the private mmc header files. In this
    change we makes sure each header file builds standalone, as that helps to
    resolve dependencies.
    
    While changing this, it also seems reasonable to stop including other
    headers from inside a header itself which it don't depend upon.
    Additionally, in some cases such dependencies are better resolved by
    forward declaring the needed struct.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Shawn Lin <shawn.lin@rock-chips.com>

diff --git a/drivers/mmc/core/queue.h b/drivers/mmc/core/queue.h
index dac8c3d010dd..0cea02af79d1 100644
--- a/drivers/mmc/core/queue.h
+++ b/drivers/mmc/core/queue.h
@@ -1,6 +1,11 @@
 #ifndef MMC_QUEUE_H
 #define MMC_QUEUE_H
 
+#include <linux/types.h>
+#include <linux/blkdev.h>
+#include <linux/mmc/core.h>
+#include <linux/mmc/host.h>
+
 static inline bool mmc_req_is_special(struct request *req)
 {
 	return req &&
@@ -9,7 +14,6 @@ static inline bool mmc_req_is_special(struct request *req)
 		 req_op(req) == REQ_OP_SECURE_ERASE);
 }
 
-struct request;
 struct task_struct;
 struct mmc_blk_data;
 

commit f397c8d80a5e413984bd9ccdf4161c7156b365ce
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu Dec 8 11:23:49 2016 +0100

    mmc: block: Move files to core
    
    Once upon a time it made sense to keep the mmc block device driver and its
    related code, in its own directory called card. Over time, more an more
    functions/structures have become shared through generic mmc header files,
    between the core and the card directory. In other words, the relationship
    between them has become closer.
    
    By sharing functions/structures via generic header files, it becomes easy
    for outside users to abuse them. In a way to avoid that from happen, let's
    move the files from card directory into the core directory, as it enables
    us to move definitions of functions/structures into mmc core specific
    header files.
    
    Note, this is only the first step in providing a cleaner mmc interface for
    outside users. Following changes will do the actual cleanup, as that is not
    part of this change.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/mmc/core/queue.h b/drivers/mmc/core/queue.h
new file mode 100644
index 000000000000..dac8c3d010dd
--- /dev/null
+++ b/drivers/mmc/core/queue.h
@@ -0,0 +1,64 @@
+#ifndef MMC_QUEUE_H
+#define MMC_QUEUE_H
+
+static inline bool mmc_req_is_special(struct request *req)
+{
+	return req &&
+		(req_op(req) == REQ_OP_FLUSH ||
+		 req_op(req) == REQ_OP_DISCARD ||
+		 req_op(req) == REQ_OP_SECURE_ERASE);
+}
+
+struct request;
+struct task_struct;
+struct mmc_blk_data;
+
+struct mmc_blk_request {
+	struct mmc_request	mrq;
+	struct mmc_command	sbc;
+	struct mmc_command	cmd;
+	struct mmc_command	stop;
+	struct mmc_data		data;
+	int			retune_retry_done;
+};
+
+struct mmc_queue_req {
+	struct request		*req;
+	struct mmc_blk_request	brq;
+	struct scatterlist	*sg;
+	char			*bounce_buf;
+	struct scatterlist	*bounce_sg;
+	unsigned int		bounce_sg_len;
+	struct mmc_async_req	mmc_active;
+};
+
+struct mmc_queue {
+	struct mmc_card		*card;
+	struct task_struct	*thread;
+	struct semaphore	thread_sem;
+	unsigned int		flags;
+#define MMC_QUEUE_SUSPENDED	(1 << 0)
+#define MMC_QUEUE_NEW_REQUEST	(1 << 1)
+	bool			asleep;
+	struct mmc_blk_data	*blkdata;
+	struct request_queue	*queue;
+	struct mmc_queue_req	*mqrq;
+	struct mmc_queue_req	*mqrq_cur;
+	struct mmc_queue_req	*mqrq_prev;
+	int			qdepth;
+};
+
+extern int mmc_init_queue(struct mmc_queue *, struct mmc_card *, spinlock_t *,
+			  const char *);
+extern void mmc_cleanup_queue(struct mmc_queue *);
+extern void mmc_queue_suspend(struct mmc_queue *);
+extern void mmc_queue_resume(struct mmc_queue *);
+
+extern unsigned int mmc_queue_map_sg(struct mmc_queue *,
+				     struct mmc_queue_req *);
+extern void mmc_queue_bounce_pre(struct mmc_queue_req *);
+extern void mmc_queue_bounce_post(struct mmc_queue_req *);
+
+extern int mmc_access_rpmb(struct mmc_queue *);
+
+#endif
