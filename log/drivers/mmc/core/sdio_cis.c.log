commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/mmc/core/sdio_cis.c b/drivers/mmc/core/sdio_cis.c
index f8c372839d24..e0655278c5c3 100644
--- a/drivers/mmc/core/sdio_cis.c
+++ b/drivers/mmc/core/sdio_cis.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * linux/drivers/mmc/core/sdio_cis.c
  *
@@ -6,11 +7,6 @@
  * Copyright:	MontaVista Software Inc.
  *
  * Copyright 2007 Pierre Ossman
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or (at
- * your option) any later version.
  */
 
 #include <linux/kernel.h>

commit 5df0e8231f9518ee5ca3f58a0777556dd03addd6
Author: Shawn Lin <shawn.lin@rock-chips.com>
Date:   Wed Nov 2 15:24:00 2016 +0800

    mmc: core: remove BUG_ONs from sdio
    
    BUG_ONs doesn't help anything except for stop the system from
    running. If it occurs, it implies we should deploy proper error
    handling for that. So this patch is gonna discard these meaningless
    BUG_ONs and deploy error handling if needed.
    
    Signed-off-by: Shawn Lin <shawn.lin@rock-chips.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sdio_cis.c b/drivers/mmc/core/sdio_cis.c
index dcb3dee59fa5..f8c372839d24 100644
--- a/drivers/mmc/core/sdio_cis.c
+++ b/drivers/mmc/core/sdio_cis.c
@@ -262,7 +262,8 @@ static int sdio_read_cis(struct mmc_card *card, struct sdio_func *func)
 	else
 		prev = &card->tuples;
 
-	BUG_ON(*prev);
+	if (*prev)
+		return -EINVAL;
 
 	do {
 		unsigned char tpl_code, tpl_link;

commit 88ea46bcbfd677b779897bbada32ec0709a6c92f
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Mon May 9 09:59:59 2016 +0200

    mmc: sdio: fall back to SDIO 1.0 for broken 1.1 cards
    
    I have two SDIO WLAN cards which specify being SDIO Rev. 1.1 cards but
    their FUNCE tuple reports the smaller size of a Rev 1.0 card. So,
    enforce 1.0 on these cards to avoid reading the not present registers.
    They are not really used anyhow. My cards initialize properly after this
    patch.
    
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sdio_cis.c b/drivers/mmc/core/sdio_cis.c
index 6f6fc527a263..dcb3dee59fa5 100644
--- a/drivers/mmc/core/sdio_cis.c
+++ b/drivers/mmc/core/sdio_cis.c
@@ -177,8 +177,13 @@ static int cistpl_funce_func(struct mmc_card *card, struct sdio_func *func,
 	vsn = func->card->cccr.sdio_vsn;
 	min_size = (vsn == SDIO_SDIO_REV_1_00) ? 28 : 42;
 
-	if (size < min_size)
+	if (size == 28 && vsn == SDIO_SDIO_REV_1_10) {
+		pr_warn("%s: card has broken SDIO 1.1 CIS, forcing SDIO 1.0\n",
+			mmc_hostname(card->host));
+		vsn = SDIO_SDIO_REV_1_00;
+	} else if (size < min_size) {
 		return -EINVAL;
+	}
 
 	/* TPLFE_MAX_BLK_SIZE */
 	func->max_blksize = buf[12] | (buf[13] << 8);

commit 07cbeea5412fa82543cbdba94ca94799fdb7bf55
Author: Shawn Lin <shawn.lin@rock-chips.com>
Date:   Wed Jan 20 16:17:04 2016 +0800

    mmc: sdio_cis: fix unknown tuple for CISTPL_SDIO_STD
    
    CISTPL_SDIO_STD(0x91) is a known tuple, but sdio_cis don't define it, so
    we get the warning below while probing several sdio wifi cards.
    
    Refer to SDIO spec, it's not needed to parse the tuple, so this patch make
    it a known one.
    
    [    4.098980] mmc2: queuing unknown CIS tuple 0x91 (3 bytes)
    [    4.099033] mmc2: new ultra high speed SDR104 SDIO card at address 0001
    
    Signed-off-by: Shawn Lin <shawn.lin@rock-chips.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sdio_cis.c b/drivers/mmc/core/sdio_cis.c
index 8e94e555b788..6f6fc527a263 100644
--- a/drivers/mmc/core/sdio_cis.c
+++ b/drivers/mmc/core/sdio_cis.c
@@ -223,6 +223,7 @@ static const struct cis_tpl cis_tpl_list[] = {
 	{	0x20,	4,	cistpl_manfid		},
 	{	0x21,	2,	/* cistpl_funcid */	},
 	{	0x22,	0,	cistpl_funce		},
+	{	0x91,	2,	/* cistpl_sdio_std */	},
 };
 
 static int sdio_read_cis(struct mmc_card *card, struct sdio_func *func)

commit aa6439daddf579b93ace8b45956a416234c3854c
Author: Liu Chuansheng <chuansheng.liu@intel.com>
Date:   Mon Jul 9 06:26:42 2012 -0400

    mmc: sdio: Change pr_warning to pr_warn_ratelimited
    
    When debugging one bad issue, got lots of pr_warning messages
    "queuing unknown CIS tuple" which caused a printk storm and
    flooded the console.
    
    This patch changes the pr_warning to use pr_warn_ratelimited.
    
    Signed-off-by: Liu Chuansheng <chuansheng.liu@intel.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sdio_cis.c b/drivers/mmc/core/sdio_cis.c
index f1c7ed8f4d85..8e94e555b788 100644
--- a/drivers/mmc/core/sdio_cis.c
+++ b/drivers/mmc/core/sdio_cis.c
@@ -313,7 +313,7 @@ static int sdio_read_cis(struct mmc_card *card, struct sdio_func *func)
 
 			if (ret == -ENOENT) {
 				/* warn about unknown tuples */
-				pr_warning("%s: queuing unknown"
+				pr_warn_ratelimited("%s: queuing unknown"
 				       " CIS tuple 0x%02x (%u bytes)\n",
 				       mmc_hostname(card->host),
 				       tpl_code, tpl_link);

commit a3c76eb9d4a1e68a69dd880cf0bcb8a52418b993
Author: Girish K S <girish.shivananjappa@linaro.org>
Date:   Tue Oct 11 11:44:09 2011 +0530

    mmc: replace printk with appropriate display macro
    
    All the files using printk function for displaying kernel messages
    in the mmc driver have been replaced with corresponding macro.
    
    Signed-off-by: Girish K S <girish.shivananjappa@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sdio_cis.c b/drivers/mmc/core/sdio_cis.c
index 541bdb89e0c5..f1c7ed8f4d85 100644
--- a/drivers/mmc/core/sdio_cis.c
+++ b/drivers/mmc/core/sdio_cis.c
@@ -132,7 +132,7 @@ static int cis_tpl_parse(struct mmc_card *card, struct sdio_func *func,
 			ret = -EINVAL;
 		}
 		if (ret && ret != -EILSEQ && ret != -ENOENT) {
-			printk(KERN_ERR "%s: bad %s tuple 0x%02x (%u bytes)\n",
+			pr_err("%s: bad %s tuple 0x%02x (%u bytes)\n",
 			       mmc_hostname(card->host), tpl_descr, code, size);
 		}
 	} else {
@@ -313,7 +313,7 @@ static int sdio_read_cis(struct mmc_card *card, struct sdio_func *func)
 
 			if (ret == -ENOENT) {
 				/* warn about unknown tuples */
-				printk(KERN_WARNING "%s: queuing unknown"
+				pr_warning("%s: queuing unknown"
 				       " CIS tuple 0x%02x (%u bytes)\n",
 				       mmc_hostname(card->host),
 				       tpl_code, tpl_link);

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/mmc/core/sdio_cis.c b/drivers/mmc/core/sdio_cis.c
index 9538389783c1..541bdb89e0c5 100644
--- a/drivers/mmc/core/sdio_cis.c
+++ b/drivers/mmc/core/sdio_cis.c
@@ -14,6 +14,7 @@
  */
 
 #include <linux/kernel.h>
+#include <linux/slab.h>
 
 #include <linux/mmc/host.h>
 #include <linux/mmc/card.h>

commit 4ec64960653c91fa86373d06a079eb7a63deb21f
Author: Albert Herranz <albert_herranz@yahoo.es>
Date:   Mon Dec 14 18:01:19 2009 -0800

    sdio: rework cis tuple parsing
    
    Rework the current CIS tuple parsing code, reusing the existing
    infrastructure and providing an easy way to add new CISTPL_FUNCE parsers
    by TPLFE_TYPE.
    
    Valid known CIS tuples are now silently queued for the SDIO function
    driver when not parsed/processed (-EILSEQ) by the SDIO core.  Unknown CIS
    tuples (-ENOENT) are queued too for the SDIO function driver without
    aborting the initialization, but emit a warning in the kernel log.
    
    CISTPL_FUNCE tuples can be "whitelisted" now by adding a matching entry to
    the cis_tpl_funce_list table.
    
    Signed-off-by: Albert Herranz <albert_herranz@yahoo.es>
    Acked-by: Pierre Ossman <pierre@ossman.eu>
    Cc: <linux-mmc@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/mmc/core/sdio_cis.c b/drivers/mmc/core/sdio_cis.c
index f85dcd536508..9538389783c1 100644
--- a/drivers/mmc/core/sdio_cis.c
+++ b/drivers/mmc/core/sdio_cis.c
@@ -97,26 +97,56 @@ static const unsigned char speed_val[16] =
 static const unsigned int speed_unit[8] =
 	{ 10000, 100000, 1000000, 10000000, 0, 0, 0, 0 };
 
-/* FUNCE tuples with these types get passed to SDIO drivers */
-static const unsigned char funce_type_whitelist[] = {
-	4 /* CISTPL_FUNCE_LAN_NODE_ID used in Broadcom cards */
+
+typedef int (tpl_parse_t)(struct mmc_card *, struct sdio_func *,
+			   const unsigned char *, unsigned);
+
+struct cis_tpl {
+	unsigned char code;
+	unsigned char min_size;
+	tpl_parse_t *parse;
 };
 
-static int cistpl_funce_whitelisted(unsigned char type)
+static int cis_tpl_parse(struct mmc_card *card, struct sdio_func *func,
+			 const char *tpl_descr,
+			 const struct cis_tpl *tpl, int tpl_count,
+			 unsigned char code,
+			 const unsigned char *buf, unsigned size)
 {
-	int i;
+	int i, ret;
 
-	for (i = 0; i < ARRAY_SIZE(funce_type_whitelist); i++) {
-		if (funce_type_whitelist[i] == type)
-			return 1;
+	/* look for a matching code in the table */
+	for (i = 0; i < tpl_count; i++, tpl++) {
+		if (tpl->code == code)
+			break;
 	}
-	return 0;
+	if (i < tpl_count) {
+		if (size >= tpl->min_size) {
+			if (tpl->parse)
+				ret = tpl->parse(card, func, buf, size);
+			else
+				ret = -EILSEQ;	/* known tuple, not parsed */
+		} else {
+			/* invalid tuple */
+			ret = -EINVAL;
+		}
+		if (ret && ret != -EILSEQ && ret != -ENOENT) {
+			printk(KERN_ERR "%s: bad %s tuple 0x%02x (%u bytes)\n",
+			       mmc_hostname(card->host), tpl_descr, code, size);
+		}
+	} else {
+		/* unknown tuple */
+		ret = -ENOENT;
+	}
+
+	return ret;
 }
 
-static int cistpl_funce_common(struct mmc_card *card,
+static int cistpl_funce_common(struct mmc_card *card, struct sdio_func *func,
 			       const unsigned char *buf, unsigned size)
 {
-	if (size < 0x04 || buf[0] != 0)
+	/* Only valid for the common CIS (function 0) */
+	if (func)
 		return -EINVAL;
 
 	/* TPLFE_FN0_BLK_SIZE */
@@ -129,20 +159,24 @@ static int cistpl_funce_common(struct mmc_card *card,
 	return 0;
 }
 
-static int cistpl_funce_func(struct sdio_func *func,
+static int cistpl_funce_func(struct mmc_card *card, struct sdio_func *func,
 			     const unsigned char *buf, unsigned size)
 {
 	unsigned vsn;
 	unsigned min_size;
 
-	/* let SDIO drivers take care of whitelisted FUNCE tuples */
-	if (cistpl_funce_whitelisted(buf[0]))
-		return -EILSEQ;
+	/* Only valid for the individual function's CIS (1-7) */
+	if (!func)
+		return -EINVAL;
 
+	/*
+	 * This tuple has a different length depending on the SDIO spec
+	 * version.
+	 */
 	vsn = func->card->cccr.sdio_vsn;
 	min_size = (vsn == SDIO_SDIO_REV_1_00) ? 28 : 42;
 
-	if (size < min_size || buf[0] != 1)
+	if (size < min_size)
 		return -EINVAL;
 
 	/* TPLFE_MAX_BLK_SIZE */
@@ -157,39 +191,32 @@ static int cistpl_funce_func(struct sdio_func *func,
 	return 0;
 }
 
+/*
+ * Known TPLFE_TYPEs table for CISTPL_FUNCE tuples.
+ *
+ * Note that, unlike PCMCIA, CISTPL_FUNCE tuples are not parsed depending
+ * on the TPLFID_FUNCTION value of the previous CISTPL_FUNCID as on SDIO
+ * TPLFID_FUNCTION is always hardcoded to 0x0C.
+ */
+static const struct cis_tpl cis_tpl_funce_list[] = {
+	{	0x00,	4,	cistpl_funce_common		},
+	{	0x01,	0,	cistpl_funce_func		},
+	{	0x04,	1+1+6,	/* CISTPL_FUNCE_LAN_NODE_ID */	},
+};
+
 static int cistpl_funce(struct mmc_card *card, struct sdio_func *func,
 			const unsigned char *buf, unsigned size)
 {
-	int ret;
-
-	/*
-	 * There should be two versions of the CISTPL_FUNCE tuple,
-	 * one for the common CIS (function 0) and a version used by
-	 * the individual function's CIS (1-7). Yet, the later has a
-	 * different length depending on the SDIO spec version.
-	 */
-	if (func)
-		ret = cistpl_funce_func(func, buf, size);
-	else
-		ret = cistpl_funce_common(card, buf, size);
-
-	if (ret && ret != -EILSEQ) {
-		printk(KERN_ERR "%s: bad CISTPL_FUNCE size %u "
-		       "type %u\n", mmc_hostname(card->host), size, buf[0]);
-	}
+	if (size < 1)
+		return -EINVAL;
 
-	return ret;
+	return cis_tpl_parse(card, func, "CISTPL_FUNCE",
+			     cis_tpl_funce_list,
+			     ARRAY_SIZE(cis_tpl_funce_list),
+			     buf[0], buf, size);
 }
 
-typedef int (tpl_parse_t)(struct mmc_card *, struct sdio_func *,
-			   const unsigned char *, unsigned);
-
-struct cis_tpl {
-	unsigned char code;
-	unsigned char min_size;
-	tpl_parse_t *parse;
-};
-
+/* Known TPL_CODEs table for CIS tuples */
 static const struct cis_tpl cis_tpl_list[] = {
 	{	0x15,	3,	cistpl_vers_1		},
 	{	0x20,	4,	cistpl_manfid		},
@@ -268,46 +295,38 @@ static int sdio_read_cis(struct mmc_card *card, struct sdio_func *func)
 			break;
 		}
 
-		for (i = 0; i < ARRAY_SIZE(cis_tpl_list); i++)
-			if (cis_tpl_list[i].code == tpl_code)
-				break;
-		if (i < ARRAY_SIZE(cis_tpl_list)) {
-			const struct cis_tpl *tpl = cis_tpl_list + i;
-			if (tpl_link < tpl->min_size) {
-				printk(KERN_ERR
-				       "%s: bad CIS tuple 0x%02x"
-				       " (length = %u, expected >= %u)\n",
-				       mmc_hostname(card->host),
-				       tpl_code, tpl_link, tpl->min_size);
-				ret = -EINVAL;
-			} else if (tpl->parse) {
-				ret = tpl->parse(card, func,
-						 this->data, tpl_link);
-			}
+		/* Try to parse the CIS tuple */
+		ret = cis_tpl_parse(card, func, "CIS",
+				    cis_tpl_list, ARRAY_SIZE(cis_tpl_list),
+				    tpl_code, this->data, tpl_link);
+		if (ret == -EILSEQ || ret == -ENOENT) {
 			/*
-			 * We don't need the tuple anymore if it was
-			 * successfully parsed by the SDIO core or if it is
-			 * not going to be parsed by SDIO drivers.
+			 * The tuple is unknown or known but not parsed.
+			 * Queue the tuple for the function driver.
 			 */
-			if (!ret || ret != -EILSEQ)
-				kfree(this);
-		} else {
-			/* unknown tuple */
-			ret = -EILSEQ;
-		}
-
-		if (ret == -EILSEQ) {
-			/* this tuple is unknown to the core or whitelisted */
 			this->next = NULL;
 			this->code = tpl_code;
 			this->size = tpl_link;
 			*prev = this;
 			prev = &this->next;
-			printk(KERN_DEBUG
-			       "%s: queuing CIS tuple 0x%02x length %u\n",
-			       mmc_hostname(card->host), tpl_code, tpl_link);
+
+			if (ret == -ENOENT) {
+				/* warn about unknown tuples */
+				printk(KERN_WARNING "%s: queuing unknown"
+				       " CIS tuple 0x%02x (%u bytes)\n",
+				       mmc_hostname(card->host),
+				       tpl_code, tpl_link);
+			}
+
 			/* keep on analyzing tuples */
 			ret = 0;
+		} else {
+			/*
+			 * We don't need the tuple anymore if it was
+			 * successfully parsed by the SDIO core or if it is
+			 * not going to be queued for a driver.
+			 */
+			kfree(this);
 		}
 
 		ptr += tpl_link;

commit a1125b1e41228bc2e5b4f023004a4280282d1dab
Author: David Vrabel <david.vrabel@csr.com>
Date:   Wed Oct 7 16:32:33 2009 -0700

    mmc: sdio: don't require CISTPL_VERS_1 to contain 4 strings
    
    The PC Card 8.0 specification (vol.  4, section 3.2.10) says the
    TPLLV1_INFO field of the CISTPL_VERS_1 tuple must contain 4 strings.  Some
    cards don't have all 4 so just parse as many as we can.
    
    [akpm@linux-foundation.org: coding-style fixes]
    Signed-off-by: David Vrabel <david.vrabel@csr.com>
    Tested-by: Jonathan Cameron <jic23@cam.ac.uk>
    Tested-by: Bing Zhao <bzhao@marvell.com>
    Cc: Roel Kluin <roel.kluin@gmail.com>
    Cc: <linux-mmc@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/mmc/core/sdio_cis.c b/drivers/mmc/core/sdio_cis.c
index e1035c895808..f85dcd536508 100644
--- a/drivers/mmc/core/sdio_cis.c
+++ b/drivers/mmc/core/sdio_cis.c
@@ -29,6 +29,8 @@ static int cistpl_vers_1(struct mmc_card *card, struct sdio_func *func,
 	unsigned i, nr_strings;
 	char **buffer, *string;
 
+	/* Find all null-terminated (including zero length) strings in
+	   the TPLLV1_INFO field. Trailing garbage is ignored. */
 	buf += 2;
 	size -= 2;
 
@@ -39,11 +41,8 @@ static int cistpl_vers_1(struct mmc_card *card, struct sdio_func *func,
 		if (buf[i] == 0)
 			nr_strings++;
 	}
-
-	if (nr_strings < 4) {
-		printk(KERN_WARNING "SDIO: ignoring broken CISTPL_VERS_1\n");
+	if (nr_strings == 0)
 		return 0;
-	}
 
 	size = i;
 

commit ed9935f4f9165fb306e59aa41a08be3eafe1486e
Author: Albert Herranz <albert_herranz@yahoo.es>
Date:   Thu Oct 1 15:44:05 2009 -0700

    sdio: pass whitelisted cis funce tuples to sdio drivers
    
    Some manufacturers provide vendor information in non-vendor specific CIS
    tuples.  For example, Broadcom uses an Extended Function tuple to provide
    the MAC address on some of their network cards, as in the case of the
    Nintendo Wii WLAN daughter card.
    
    This patch allows passing whitelisted FUNCE tuples unknown to the SDIO
    core to a matching SDIO driver instead of rejecting them and failing.
    
    Signed-off-by: Albert Herranz <albert_herranz@yahoo.es>
    Cc: <linux-mmc@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/mmc/core/sdio_cis.c b/drivers/mmc/core/sdio_cis.c
index 6636354b48ce..e1035c895808 100644
--- a/drivers/mmc/core/sdio_cis.c
+++ b/drivers/mmc/core/sdio_cis.c
@@ -98,6 +98,22 @@ static const unsigned char speed_val[16] =
 static const unsigned int speed_unit[8] =
 	{ 10000, 100000, 1000000, 10000000, 0, 0, 0, 0 };
 
+/* FUNCE tuples with these types get passed to SDIO drivers */
+static const unsigned char funce_type_whitelist[] = {
+	4 /* CISTPL_FUNCE_LAN_NODE_ID used in Broadcom cards */
+};
+
+static int cistpl_funce_whitelisted(unsigned char type)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(funce_type_whitelist); i++) {
+		if (funce_type_whitelist[i] == type)
+			return 1;
+	}
+	return 0;
+}
+
 static int cistpl_funce_common(struct mmc_card *card,
 			       const unsigned char *buf, unsigned size)
 {
@@ -120,6 +136,10 @@ static int cistpl_funce_func(struct sdio_func *func,
 	unsigned vsn;
 	unsigned min_size;
 
+	/* let SDIO drivers take care of whitelisted FUNCE tuples */
+	if (cistpl_funce_whitelisted(buf[0]))
+		return -EILSEQ;
+
 	vsn = func->card->cccr.sdio_vsn;
 	min_size = (vsn == SDIO_SDIO_REV_1_00) ? 28 : 42;
 
@@ -154,13 +174,12 @@ static int cistpl_funce(struct mmc_card *card, struct sdio_func *func,
 	else
 		ret = cistpl_funce_common(card, buf, size);
 
-	if (ret) {
+	if (ret && ret != -EILSEQ) {
 		printk(KERN_ERR "%s: bad CISTPL_FUNCE size %u "
 		       "type %u\n", mmc_hostname(card->host), size, buf[0]);
-		return ret;
 	}
 
-	return 0;
+	return ret;
 }
 
 typedef int (tpl_parse_t)(struct mmc_card *, struct sdio_func *,
@@ -253,21 +272,12 @@ static int sdio_read_cis(struct mmc_card *card, struct sdio_func *func)
 		for (i = 0; i < ARRAY_SIZE(cis_tpl_list); i++)
 			if (cis_tpl_list[i].code == tpl_code)
 				break;
-		if (i >= ARRAY_SIZE(cis_tpl_list)) {
-			/* this tuple is unknown to the core */
-			this->next = NULL;
-			this->code = tpl_code;
-			this->size = tpl_link;
-			*prev = this;
-			prev = &this->next;
-			printk(KERN_DEBUG
-			       "%s: queuing CIS tuple 0x%02x length %u\n",
-			       mmc_hostname(card->host), tpl_code, tpl_link);
-		} else {
+		if (i < ARRAY_SIZE(cis_tpl_list)) {
 			const struct cis_tpl *tpl = cis_tpl_list + i;
 			if (tpl_link < tpl->min_size) {
 				printk(KERN_ERR
-				       "%s: bad CIS tuple 0x%02x (length = %u, expected >= %u)\n",
+				       "%s: bad CIS tuple 0x%02x"
+				       " (length = %u, expected >= %u)\n",
 				       mmc_hostname(card->host),
 				       tpl_code, tpl_link, tpl->min_size);
 				ret = -EINVAL;
@@ -275,7 +285,30 @@ static int sdio_read_cis(struct mmc_card *card, struct sdio_func *func)
 				ret = tpl->parse(card, func,
 						 this->data, tpl_link);
 			}
-			kfree(this);
+			/*
+			 * We don't need the tuple anymore if it was
+			 * successfully parsed by the SDIO core or if it is
+			 * not going to be parsed by SDIO drivers.
+			 */
+			if (!ret || ret != -EILSEQ)
+				kfree(this);
+		} else {
+			/* unknown tuple */
+			ret = -EILSEQ;
+		}
+
+		if (ret == -EILSEQ) {
+			/* this tuple is unknown to the core or whitelisted */
+			this->next = NULL;
+			this->code = tpl_code;
+			this->size = tpl_link;
+			*prev = this;
+			prev = &this->next;
+			printk(KERN_DEBUG
+			       "%s: queuing CIS tuple 0x%02x length %u\n",
+			       mmc_hostname(card->host), tpl_code, tpl_link);
+			/* keep on analyzing tuples */
+			ret = 0;
 		}
 
 		ptr += tpl_link;

commit 4245c0256da0784b1f96d01ff263a71a4ca3894e
Author: Roel Kluin <roel.kluin@gmail.com>
Date:   Tue Sep 22 16:45:09 2009 -0700

    sdio: fix read buffer overflow
    
    Avoid buffer underrun when parsing an invalid CISTPL_VERS_1.
    
    Signed-off-by: Roel Kluin <roel.kluin@gmail.com>
    Cc: David Vrabel <david.vrabel@csr.com>
    Cc: <linux-mmc@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/mmc/core/sdio_cis.c b/drivers/mmc/core/sdio_cis.c
index 963f2937c5e3..6636354b48ce 100644
--- a/drivers/mmc/core/sdio_cis.c
+++ b/drivers/mmc/core/sdio_cis.c
@@ -40,7 +40,7 @@ static int cistpl_vers_1(struct mmc_card *card, struct sdio_func *func,
 			nr_strings++;
 	}
 
-	if (buf[i-1] != '\0') {
+	if (nr_strings < 4) {
 		printk(KERN_WARNING "SDIO: ignoring broken CISTPL_VERS_1\n");
 		return 0;
 	}

commit c8d718f1037950107f13607ff0b696ffe63df76a
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Thu Mar 5 19:38:38 2009 +0100

    sdio: handle null tuples
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/sdio_cis.c b/drivers/mmc/core/sdio_cis.c
index 6ba93f599281..963f2937c5e3 100644
--- a/drivers/mmc/core/sdio_cis.c
+++ b/drivers/mmc/core/sdio_cis.c
@@ -223,6 +223,10 @@ static int sdio_read_cis(struct mmc_card *card, struct sdio_func *func)
 		if (tpl_code == 0xff)
 			break;
 
+		/* null entries have no link field or data */
+		if (tpl_code == 0x00)
+			continue;
+
 		ret = mmc_io_rw_direct(card, 0, 0, ptr++, 0, &tpl_link);
 		if (ret)
 			break;

commit 0d6132ba0b006dd2bea9ba0c7b6b2f690cd95c40
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Thu Mar 5 19:37:28 2009 +0100

    sdio: handle cis end marker in link field
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/sdio_cis.c b/drivers/mmc/core/sdio_cis.c
index 956bd7677502..6ba93f599281 100644
--- a/drivers/mmc/core/sdio_cis.c
+++ b/drivers/mmc/core/sdio_cis.c
@@ -227,6 +227,10 @@ static int sdio_read_cis(struct mmc_card *card, struct sdio_func *func)
 		if (ret)
 			break;
 
+		/* a size of 0xff also means we're done */
+		if (tpl_link == 0xff)
+			break;
+
 		this = kmalloc(sizeof(*this) + tpl_link, GFP_KERNEL);
 		if (!this)
 			return -ENOMEM;

commit 62a7573ee9f31d4fdb330b3e68ebf6efaba1d57c
Author: Benzi Zbit <benzi.zbit@intel.com>
Date:   Thu Jul 10 02:41:43 2008 +0300

    sdio: fix the use of hard coded timeout value.
    
    This adds reading and using of enable_timeout from the CIS
    
    Signed-off-by: Benzi Zbit <benzi.zbit@intel.com>
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/sdio_cis.c b/drivers/mmc/core/sdio_cis.c
index d5e51b1c7b3f..956bd7677502 100644
--- a/drivers/mmc/core/sdio_cis.c
+++ b/drivers/mmc/core/sdio_cis.c
@@ -129,6 +129,12 @@ static int cistpl_funce_func(struct sdio_func *func,
 	/* TPLFE_MAX_BLK_SIZE */
 	func->max_blksize = buf[12] | (buf[13] << 8);
 
+	/* TPLFE_ENABLE_TIMEOUT_VAL, present in ver 1.1 and above */
+	if (vsn > SDIO_SDIO_REV_1_00)
+		func->enable_timeout = (buf[28] | (buf[29] << 8)) * 10;
+	else
+		func->enable_timeout = jiffies_to_msecs(HZ);
+
 	return 0;
 }
 

commit 759bdc7af450404382e937c76722ae8736daef92
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Wed Sep 19 18:42:16 2007 +0200

    sdio: store vendor strings
    
    Store vendor strings found in CISTPL_VERS_1 so that function drivers
    can access them.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/sdio_cis.c b/drivers/mmc/core/sdio_cis.c
index 1d03f12bbb38..d5e51b1c7b3f 100644
--- a/drivers/mmc/core/sdio_cis.c
+++ b/drivers/mmc/core/sdio_cis.c
@@ -23,6 +23,54 @@
 #include "sdio_cis.h"
 #include "sdio_ops.h"
 
+static int cistpl_vers_1(struct mmc_card *card, struct sdio_func *func,
+			 const unsigned char *buf, unsigned size)
+{
+	unsigned i, nr_strings;
+	char **buffer, *string;
+
+	buf += 2;
+	size -= 2;
+
+	nr_strings = 0;
+	for (i = 0; i < size; i++) {
+		if (buf[i] == 0xff)
+			break;
+		if (buf[i] == 0)
+			nr_strings++;
+	}
+
+	if (buf[i-1] != '\0') {
+		printk(KERN_WARNING "SDIO: ignoring broken CISTPL_VERS_1\n");
+		return 0;
+	}
+
+	size = i;
+
+	buffer = kzalloc(sizeof(char*) * nr_strings + size, GFP_KERNEL);
+	if (!buffer)
+		return -ENOMEM;
+
+	string = (char*)(buffer + nr_strings);
+
+	for (i = 0; i < nr_strings; i++) {
+		buffer[i] = string;
+		strcpy(string, buf);
+		string += strlen(string) + 1;
+		buf += strlen(buf) + 1;
+	}
+
+	if (func) {
+		func->num_info = nr_strings;
+		func->info = (const char**)buffer;
+	} else {
+		card->num_info = nr_strings;
+		card->info = (const char**)buffer;
+	}
+
+	return 0;
+}
+
 static int cistpl_manfid(struct mmc_card *card, struct sdio_func *func,
 			 const unsigned char *buf, unsigned size)
 {
@@ -119,7 +167,7 @@ struct cis_tpl {
 };
 
 static const struct cis_tpl cis_tpl_list[] = {
-	{	0x15,	3,	/* cistpl_vers_1 */	},
+	{	0x15,	3,	cistpl_vers_1		},
 	{	0x20,	4,	cistpl_manfid		},
 	{	0x21,	2,	/* cistpl_funcid */	},
 	{	0x22,	0,	cistpl_funce		},

commit 9a08f82b3cc522f727ace580a2aaee5402435bc8
Author: David Vrabel <david.vrabel@csr.com>
Date:   Wed Aug 8 14:23:48 2007 +0100

    sdio: set the functions' block size
    
    Before a driver is probed, set the function's block size to the default so the
    driver is sure the block size is something sensible and it needn't explicitly
    set it.
    
    The default block size is the largest that's supported by both the card and
    the host, with a maximum of 512 to ensure aribitrarily sized transfer use the
    optimal (least) number of commands.
    
    See http://lkml.org/lkml/2007/8/7/150 for reasons for the block size choice.
    
    Signed-off-by: David Vrabel <david.vrabel@csr.com>
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/sdio_cis.c b/drivers/mmc/core/sdio_cis.c
index d050c40cf046..1d03f12bbb38 100644
--- a/drivers/mmc/core/sdio_cis.c
+++ b/drivers/mmc/core/sdio_cis.c
@@ -79,7 +79,7 @@ static int cistpl_funce_func(struct sdio_func *func,
 		return -EINVAL;
 
 	/* TPLFE_MAX_BLK_SIZE */
-	func->blksize = buf[12] | (buf[13] << 8);
+	func->max_blksize = buf[12] | (buf[13] << 8);
 
 	return 0;
 }

commit 7616ee95f27a04fd5a6434e9ef4a82cec4b2807c
Author: David Vrabel <david.vrabel@csr.com>
Date:   Wed Aug 8 14:23:05 2007 +0100

    sdio: add SDIO_FBR_BASE(f) macro
    
    Signed-off-by: David Vrabel <david.vrabel@csr.com>
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/sdio_cis.c b/drivers/mmc/core/sdio_cis.c
index ec806a1229b6..d050c40cf046 100644
--- a/drivers/mmc/core/sdio_cis.c
+++ b/drivers/mmc/core/sdio_cis.c
@@ -145,7 +145,7 @@ static int sdio_read_cis(struct mmc_card *card, struct sdio_func *func)
 			fn = 0;
 
 		ret = mmc_io_rw_direct(card, 0, 0,
-				       fn * 0x100 + SDIO_FBR_CIS + i, 0, &x);
+			SDIO_FBR_BASE(fn) + SDIO_FBR_CIS + i, 0, &x);
 		if (ret)
 			return ret;
 		ptr |= x << (i * 8);

commit 1a632f8cdc33e7f8edca352164f0c96a75d08f08
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Mon Jul 30 15:15:30 2007 +0200

    sdio: split up common and function CIS parsing
    
    Add a more clean separation between global, common CIS information
    and the function specific one as we need the common information in
    places where no specific function is specified.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/sdio_cis.c b/drivers/mmc/core/sdio_cis.c
index b6c7342572c1..ec806a1229b6 100644
--- a/drivers/mmc/core/sdio_cis.c
+++ b/drivers/mmc/core/sdio_cis.c
@@ -16,60 +16,152 @@
 #include <linux/kernel.h>
 
 #include <linux/mmc/host.h>
+#include <linux/mmc/card.h>
 #include <linux/mmc/sdio.h>
 #include <linux/mmc/sdio_func.h>
 
 #include "sdio_cis.h"
 #include "sdio_ops.h"
 
-static int cistpl_manfid(struct sdio_func *func,
-			 const unsigned char *buf,
-			 unsigned size)
+static int cistpl_manfid(struct mmc_card *card, struct sdio_func *func,
+			 const unsigned char *buf, unsigned size)
 {
+	unsigned int vendor, device;
+
 	/* TPLMID_MANF */
-	func->vendor = buf[0] | (buf[1] << 8);
+	vendor = buf[0] | (buf[1] << 8);
 
 	/* TPLMID_CARD */
-	func->device = buf[2] | (buf[3] << 8);
+	device = buf[2] | (buf[3] << 8);
+
+	if (func) {
+		func->vendor = vendor;
+		func->device = device;
+	} else {
+		card->cis.vendor = vendor;
+		card->cis.device = device;
+	}
+
+	return 0;
+}
+
+static const unsigned char speed_val[16] =
+	{ 0, 10, 12, 13, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 70, 80 };
+static const unsigned int speed_unit[8] =
+	{ 10000, 100000, 1000000, 10000000, 0, 0, 0, 0 };
+
+static int cistpl_funce_common(struct mmc_card *card,
+			       const unsigned char *buf, unsigned size)
+{
+	if (size < 0x04 || buf[0] != 0)
+		return -EINVAL;
+
+	/* TPLFE_FN0_BLK_SIZE */
+	card->cis.blksize = buf[1] | (buf[2] << 8);
+
+	/* TPLFE_MAX_TRAN_SPEED */
+	card->cis.max_dtr = speed_val[(buf[3] >> 3) & 15] *
+			    speed_unit[buf[3] & 7];
+
+	return 0;
+}
+
+static int cistpl_funce_func(struct sdio_func *func,
+			     const unsigned char *buf, unsigned size)
+{
+	unsigned vsn;
+	unsigned min_size;
+
+	vsn = func->card->cccr.sdio_vsn;
+	min_size = (vsn == SDIO_SDIO_REV_1_00) ? 28 : 42;
+
+	if (size < min_size || buf[0] != 1)
+		return -EINVAL;
+
+	/* TPLFE_MAX_BLK_SIZE */
+	func->blksize = buf[12] | (buf[13] << 8);
 
 	return 0;
 }
 
+static int cistpl_funce(struct mmc_card *card, struct sdio_func *func,
+			const unsigned char *buf, unsigned size)
+{
+	int ret;
+
+	/*
+	 * There should be two versions of the CISTPL_FUNCE tuple,
+	 * one for the common CIS (function 0) and a version used by
+	 * the individual function's CIS (1-7). Yet, the later has a
+	 * different length depending on the SDIO spec version.
+	 */
+	if (func)
+		ret = cistpl_funce_func(func, buf, size);
+	else
+		ret = cistpl_funce_common(card, buf, size);
+
+	if (ret) {
+		printk(KERN_ERR "%s: bad CISTPL_FUNCE size %u "
+		       "type %u\n", mmc_hostname(card->host), size, buf[0]);
+		return ret;
+	}
+
+	return 0;
+}
+
+typedef int (tpl_parse_t)(struct mmc_card *, struct sdio_func *,
+			   const unsigned char *, unsigned);
+
 struct cis_tpl {
 	unsigned char code;
 	unsigned char min_size;
-	int (*parse)(struct sdio_func *, const unsigned char *buf, unsigned size);
+	tpl_parse_t *parse;
 };
 
 static const struct cis_tpl cis_tpl_list[] = {
 	{	0x15,	3,	/* cistpl_vers_1 */	},
 	{	0x20,	4,	cistpl_manfid		},
 	{	0x21,	2,	/* cistpl_funcid */	},
-	{	0x22,	0,	/* cistpl_funce */	},
+	{	0x22,	0,	cistpl_funce		},
 };
 
-int sdio_read_cis(struct sdio_func *func)
+static int sdio_read_cis(struct mmc_card *card, struct sdio_func *func)
 {
 	int ret;
 	struct sdio_func_tuple *this, **prev;
 	unsigned i, ptr = 0;
 
+	/*
+	 * Note that this works for the common CIS (function number 0) as
+	 * well as a function's CIS * since SDIO_CCCR_CIS and SDIO_FBR_CIS
+	 * have the same offset.
+	 */
 	for (i = 0; i < 3; i++) {
-		unsigned char x;
-		ret = mmc_io_rw_direct(func->card, 0, 0,
-				func->num * 0x100 + SDIO_FBR_CIS + i, 0, &x);
+		unsigned char x, fn;
+
+		if (func)
+			fn = func->num;
+		else
+			fn = 0;
+
+		ret = mmc_io_rw_direct(card, 0, 0,
+				       fn * 0x100 + SDIO_FBR_CIS + i, 0, &x);
 		if (ret)
 			return ret;
 		ptr |= x << (i * 8);
 	}
 
-	/* find the list tail */
-	for (prev = &func->tuples; *prev; prev = &(*prev)->next);
+	if (func)
+		prev = &func->tuples;
+	else
+		prev = &card->tuples;
+
+	BUG_ON(*prev);
 
 	do {
 		unsigned char tpl_code, tpl_link;
 
-		ret = mmc_io_rw_direct(func->card, 0, 0, ptr++, 0, &tpl_code);
+		ret = mmc_io_rw_direct(card, 0, 0, ptr++, 0, &tpl_code);
 		if (ret)
 			break;
 
@@ -77,7 +169,7 @@ int sdio_read_cis(struct sdio_func *func)
 		if (tpl_code == 0xff)
 			break;
 
-		ret = mmc_io_rw_direct(func->card, 0, 0, ptr++, 0, &tpl_link);
+		ret = mmc_io_rw_direct(card, 0, 0, ptr++, 0, &tpl_link);
 		if (ret)
 			break;
 
@@ -86,7 +178,7 @@ int sdio_read_cis(struct sdio_func *func)
 			return -ENOMEM;
 
 		for (i = 0; i < tpl_link; i++) {
-			ret = mmc_io_rw_direct(func->card, 0, 0,
+			ret = mmc_io_rw_direct(card, 0, 0,
 					       ptr + i, 0, &this->data[i]);
 			if (ret)
 				break;
@@ -108,30 +200,45 @@ int sdio_read_cis(struct sdio_func *func)
 			prev = &this->next;
 			printk(KERN_DEBUG
 			       "%s: queuing CIS tuple 0x%02x length %u\n",
-			       sdio_func_id(func), tpl_code, tpl_link);
+			       mmc_hostname(card->host), tpl_code, tpl_link);
 		} else {
 			const struct cis_tpl *tpl = cis_tpl_list + i;
 			if (tpl_link < tpl->min_size) {
 				printk(KERN_ERR
 				       "%s: bad CIS tuple 0x%02x (length = %u, expected >= %u)\n",
-				       sdio_func_id(func), tpl_code, tpl_link, tpl->min_size);
+				       mmc_hostname(card->host),
+				       tpl_code, tpl_link, tpl->min_size);
 				ret = -EINVAL;
-			} else if (tpl->parse)
-				ret = tpl->parse(func, this->data, tpl_link);
+			} else if (tpl->parse) {
+				ret = tpl->parse(card, func,
+						 this->data, tpl_link);
+			}
 			kfree(this);
 		}
 
 		ptr += tpl_link;
 	} while (!ret);
 
+	/*
+	 * Link in all unknown tuples found in the common CIS so that
+	 * drivers don't have to go digging in two places.
+	 */
+	if (func)
+		*prev = card->tuples;
+
 	return ret;
 }
 
-void sdio_free_cis(struct sdio_func *func)
+int sdio_read_common_cis(struct mmc_card *card)
+{
+	return sdio_read_cis(card, NULL);
+}
+
+void sdio_free_common_cis(struct mmc_card *card)
 {
 	struct sdio_func_tuple *tuple, *victim;
 
-	tuple = func->tuples;
+	tuple = card->tuples;
 
 	while (tuple) {
 		victim = tuple;
@@ -139,6 +246,53 @@ void sdio_free_cis(struct sdio_func *func)
 		kfree(victim);
 	}
 
+	card->tuples = NULL;
+}
+
+int sdio_read_func_cis(struct sdio_func *func)
+{
+	int ret;
+
+	ret = sdio_read_cis(func->card, func);
+	if (ret)
+		return ret;
+
+	/*
+	 * Since we've linked to tuples in the card structure,
+	 * we must make sure we have a reference to it.
+	 */
+	get_device(&func->card->dev);
+
+	/*
+	 * Vendor/device id is optional for function CIS, so
+	 * copy it from the card structure as needed.
+	 */
+	if (func->vendor == 0) {
+		func->vendor = func->card->cis.vendor;
+		func->device = func->card->cis.device;
+	}
+
+	return 0;
+}
+
+void sdio_free_func_cis(struct sdio_func *func)
+{
+	struct sdio_func_tuple *tuple, *victim;
+
+	tuple = func->tuples;
+
+	while (tuple && tuple != func->card->tuples) {
+		victim = tuple;
+		tuple = tuple->next;
+		kfree(victim);
+	}
+
 	func->tuples = NULL;
+
+	/*
+	 * We have now removed the link to the tuples in the
+	 * card structure, so remove the reference.
+	 */
+	put_device(&func->card->dev);
 }
 

commit b1538bcf75e2e11459947ec4d4329ed04fbe2b2c
Author: Nicolas Pitre <nico@cam.org>
Date:   Sat Jun 16 02:06:47 2007 -0400

    sdio: link unknown CIS tuples to the sdio_func structure
    
    This way those tuples that the core cares about are consumed by the core
    code, and tuples that only function drivers might make sense of are
    available to drivers.
    
    Signed-off-by: Nicolas Pitre <npitre@mvista.com>
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/sdio_cis.c b/drivers/mmc/core/sdio_cis.c
index 114b600cd788..b6c7342572c1 100644
--- a/drivers/mmc/core/sdio_cis.c
+++ b/drivers/mmc/core/sdio_cis.c
@@ -5,6 +5,8 @@
  * Created:	June 11, 2007
  * Copyright:	MontaVista Software Inc.
  *
+ * Copyright 2007 Pierre Ossman
+ *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or (at
@@ -49,7 +51,7 @@ static const struct cis_tpl cis_tpl_list[] = {
 int sdio_read_cis(struct sdio_func *func)
 {
 	int ret;
-	unsigned char *buf;
+	struct sdio_func_tuple *this, **prev;
 	unsigned i, ptr = 0;
 
 	for (i = 0; i < 3; i++) {
@@ -61,13 +63,11 @@ int sdio_read_cis(struct sdio_func *func)
 		ptr |= x << (i * 8);
 	}
 
-	buf = kmalloc(256, GFP_KERNEL);
-	if (!buf)
-		return -ENOMEM;
+	/* find the list tail */
+	for (prev = &func->tuples; *prev; prev = &(*prev)->next);
 
 	do {
 		unsigned char tpl_code, tpl_link;
-		const struct cis_tpl *tpl;
 
 		ret = mmc_io_rw_direct(func->card, 0, 0, ptr++, 0, &tpl_code);
 		if (ret)
@@ -81,39 +81,64 @@ int sdio_read_cis(struct sdio_func *func)
 		if (ret)
 			break;
 
-		for (i = 0; i < ARRAY_SIZE(cis_tpl_list); i++)
-			if (cis_tpl_list[i].code == tpl_code)
+		this = kmalloc(sizeof(*this) + tpl_link, GFP_KERNEL);
+		if (!this)
+			return -ENOMEM;
+
+		for (i = 0; i < tpl_link; i++) {
+			ret = mmc_io_rw_direct(func->card, 0, 0,
+					       ptr + i, 0, &this->data[i]);
+			if (ret)
 				break;
-		if (i >= ARRAY_SIZE(cis_tpl_list)) {
-			printk(KERN_WARNING
-			       "%s: unknown CIS tuple 0x%02x of length %u\n",
-			       sdio_func_id(func), tpl_code, tpl_link);
-			ptr += tpl_link;
-			continue;
 		}
-		tpl = cis_tpl_list + i;
-
-		if (tpl_link < tpl->min_size) {
-			printk(KERN_ERR
-			       "%s: bad CIS tuple 0x%02x (length = %u, expected >= %u\n",
-			       sdio_func_id(func), tpl_code, tpl_link, tpl->min_size);
-			ret = -EINVAL;
+		if (ret) {
+			kfree(this);
 			break;
 		}
 
-		for (i = 0; i < tpl_link; i++) {
-			ret = mmc_io_rw_direct(func->card, 0, 0, ptr + i, 0, &buf[i]);
-			if (ret)
+		for (i = 0; i < ARRAY_SIZE(cis_tpl_list); i++)
+			if (cis_tpl_list[i].code == tpl_code)
 				break;
+		if (i >= ARRAY_SIZE(cis_tpl_list)) {
+			/* this tuple is unknown to the core */
+			this->next = NULL;
+			this->code = tpl_code;
+			this->size = tpl_link;
+			*prev = this;
+			prev = &this->next;
+			printk(KERN_DEBUG
+			       "%s: queuing CIS tuple 0x%02x length %u\n",
+			       sdio_func_id(func), tpl_code, tpl_link);
+		} else {
+			const struct cis_tpl *tpl = cis_tpl_list + i;
+			if (tpl_link < tpl->min_size) {
+				printk(KERN_ERR
+				       "%s: bad CIS tuple 0x%02x (length = %u, expected >= %u)\n",
+				       sdio_func_id(func), tpl_code, tpl_link, tpl->min_size);
+				ret = -EINVAL;
+			} else if (tpl->parse)
+				ret = tpl->parse(func, this->data, tpl_link);
+			kfree(this);
 		}
-		if (ret)
-			break;
-		ptr += tpl_link;
 
-		if (tpl->parse)
-			ret = tpl->parse(func, buf, tpl_link);
+		ptr += tpl_link;
 	} while (!ret);
 
-	kfree(buf);
 	return ret;
 }
+
+void sdio_free_cis(struct sdio_func *func)
+{
+	struct sdio_func_tuple *tuple, *victim;
+
+	tuple = func->tuples;
+
+	while (tuple) {
+		victim = tuple;
+		tuple = tuple->next;
+		kfree(victim);
+	}
+
+	func->tuples = NULL;
+}
+

commit b726126196d54cbbba0924191e5c4dd5ba747fa2
Author: Nicolas Pitre <nico@cam.org>
Date:   Sat Jun 16 02:04:16 2007 -0400

    sdio: initial CIS parsing code
    
    Signed-off-by: Nicolas Pitre <npitre@mvista.com>
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/sdio_cis.c b/drivers/mmc/core/sdio_cis.c
new file mode 100644
index 000000000000..114b600cd788
--- /dev/null
+++ b/drivers/mmc/core/sdio_cis.c
@@ -0,0 +1,119 @@
+/*
+ * linux/drivers/mmc/core/sdio_cis.c
+ *
+ * Author:	Nicolas Pitre
+ * Created:	June 11, 2007
+ * Copyright:	MontaVista Software Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at
+ * your option) any later version.
+ */
+
+#include <linux/kernel.h>
+
+#include <linux/mmc/host.h>
+#include <linux/mmc/sdio.h>
+#include <linux/mmc/sdio_func.h>
+
+#include "sdio_cis.h"
+#include "sdio_ops.h"
+
+static int cistpl_manfid(struct sdio_func *func,
+			 const unsigned char *buf,
+			 unsigned size)
+{
+	/* TPLMID_MANF */
+	func->vendor = buf[0] | (buf[1] << 8);
+
+	/* TPLMID_CARD */
+	func->device = buf[2] | (buf[3] << 8);
+
+	return 0;
+}
+
+struct cis_tpl {
+	unsigned char code;
+	unsigned char min_size;
+	int (*parse)(struct sdio_func *, const unsigned char *buf, unsigned size);
+};
+
+static const struct cis_tpl cis_tpl_list[] = {
+	{	0x15,	3,	/* cistpl_vers_1 */	},
+	{	0x20,	4,	cistpl_manfid		},
+	{	0x21,	2,	/* cistpl_funcid */	},
+	{	0x22,	0,	/* cistpl_funce */	},
+};
+
+int sdio_read_cis(struct sdio_func *func)
+{
+	int ret;
+	unsigned char *buf;
+	unsigned i, ptr = 0;
+
+	for (i = 0; i < 3; i++) {
+		unsigned char x;
+		ret = mmc_io_rw_direct(func->card, 0, 0,
+				func->num * 0x100 + SDIO_FBR_CIS + i, 0, &x);
+		if (ret)
+			return ret;
+		ptr |= x << (i * 8);
+	}
+
+	buf = kmalloc(256, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	do {
+		unsigned char tpl_code, tpl_link;
+		const struct cis_tpl *tpl;
+
+		ret = mmc_io_rw_direct(func->card, 0, 0, ptr++, 0, &tpl_code);
+		if (ret)
+			break;
+
+		/* 0xff means we're done */
+		if (tpl_code == 0xff)
+			break;
+
+		ret = mmc_io_rw_direct(func->card, 0, 0, ptr++, 0, &tpl_link);
+		if (ret)
+			break;
+
+		for (i = 0; i < ARRAY_SIZE(cis_tpl_list); i++)
+			if (cis_tpl_list[i].code == tpl_code)
+				break;
+		if (i >= ARRAY_SIZE(cis_tpl_list)) {
+			printk(KERN_WARNING
+			       "%s: unknown CIS tuple 0x%02x of length %u\n",
+			       sdio_func_id(func), tpl_code, tpl_link);
+			ptr += tpl_link;
+			continue;
+		}
+		tpl = cis_tpl_list + i;
+
+		if (tpl_link < tpl->min_size) {
+			printk(KERN_ERR
+			       "%s: bad CIS tuple 0x%02x (length = %u, expected >= %u\n",
+			       sdio_func_id(func), tpl_code, tpl_link, tpl->min_size);
+			ret = -EINVAL;
+			break;
+		}
+
+		for (i = 0; i < tpl_link; i++) {
+			ret = mmc_io_rw_direct(func->card, 0, 0, ptr + i, 0, &buf[i]);
+			if (ret)
+				break;
+		}
+		if (ret)
+			break;
+		ptr += tpl_link;
+
+		if (tpl->parse)
+			ret = tpl->parse(func, buf, tpl_link);
+	} while (!ret);
+
+	kfree(buf);
+	return ret;
+}
