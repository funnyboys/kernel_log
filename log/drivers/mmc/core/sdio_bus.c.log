commit 2ac55d5e5ec9ad0a07e194f0eaca865fe5aa3c40
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu Oct 17 15:25:36 2019 +0200

    mmc: core: Re-work HW reset for SDIO cards
    
    It have turned out that it's not a good idea to unconditionally do a power
    cycle and then to re-initialize the SDIO card, as currently done through
    mmc_hw_reset() -> mmc_sdio_hw_reset(). This because there may be multiple
    SDIO func drivers probed, who also shares the same SDIO card.
    
    To address these scenarios, one may be tempted to use a notification
    mechanism, as to allow the core to inform each of the probed func drivers,
    about an ongoing HW reset. However, supporting such an operation from the
    func driver point of view, may not be entirely trivial.
    
    Therefore, let's use a more simplistic approach to solve the problem, by
    instead forcing the card to be removed and re-detected, via scheduling a
    rescan-work. In this way, we can rely on existing infrastructure, as the
    func driver's ->remove() and ->probe() callbacks, becomes invoked to deal
    with the cleanup and the re-initialization.
    
    This solution may be considered as rather heavy, especially if a func
    driver doesn't share its card with other func drivers. To address this,
    let's keep the current immediate HW reset option as well, but run it only
    when there is one func driver probed for the card.
    
    Finally, to allow the caller of mmc_hw_reset(), to understand if the reset
    is being asynchronously managed from a scheduled work, it returns 1
    (propagated from mmc_sdio_hw_reset()). If the HW reset is executed
    successfully and synchronously it returns 0, which maintains the existing
    behaviour.
    
    Reviewed-by: Douglas Anderson <dianders@chromium.org>
    Tested-by: Douglas Anderson <dianders@chromium.org>
    Cc: stable@vger.kernel.org # v5.4+
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sdio_bus.c b/drivers/mmc/core/sdio_bus.c
index 2963e6542958..3cc928282af7 100644
--- a/drivers/mmc/core/sdio_bus.c
+++ b/drivers/mmc/core/sdio_bus.c
@@ -138,6 +138,8 @@ static int sdio_bus_probe(struct device *dev)
 	if (ret)
 		return ret;
 
+	atomic_inc(&func->card->sdio_funcs_probed);
+
 	/* Unbound SDIO functions are always suspended.
 	 * During probe, the function is set active and the usage count
 	 * is incremented.  If the driver supports runtime PM,
@@ -153,7 +155,10 @@ static int sdio_bus_probe(struct device *dev)
 	/* Set the default block size so the driver is sure it's something
 	 * sensible. */
 	sdio_claim_host(func);
-	ret = sdio_set_block_size(func, 0);
+	if (mmc_card_removed(func->card))
+		ret = -ENOMEDIUM;
+	else
+		ret = sdio_set_block_size(func, 0);
 	sdio_release_host(func);
 	if (ret)
 		goto disable_runtimepm;
@@ -165,6 +170,7 @@ static int sdio_bus_probe(struct device *dev)
 	return 0;
 
 disable_runtimepm:
+	atomic_dec(&func->card->sdio_funcs_probed);
 	if (func->card->host->caps & MMC_CAP_POWER_OFF_CARD)
 		pm_runtime_put_noidle(dev);
 	dev_pm_domain_detach(dev, false);
@@ -181,6 +187,7 @@ static int sdio_bus_remove(struct device *dev)
 		pm_runtime_get_sync(dev);
 
 	drv->remove(func);
+	atomic_dec(&func->card->sdio_funcs_probed);
 
 	if (func->irq_handler) {
 		pr_warn("WARNING: driver %s did not remove its interrupt handler!\n",

commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/mmc/core/sdio_bus.c b/drivers/mmc/core/sdio_bus.c
index 62b0f5ecc7f7..2963e6542958 100644
--- a/drivers/mmc/core/sdio_bus.c
+++ b/drivers/mmc/core/sdio_bus.c
@@ -1,13 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *  linux/drivers/mmc/core/sdio_bus.c
  *
  *  Copyright 2007 Pierre Ossman
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or (at
- * your option) any later version.
- *
  * SDIO function driver model
  */
 

commit 7e926f42c64dccfa44229d7bbe89bf5e2f4183fe
Author: wangbo <wdjjwb@163.com>
Date:   Wed Jan 9 20:10:33 2019 +0800

    mmc:sdio: Remove unneeded variable ret
    
    In sdio_bus_remove the variable is unneeded,remove it now.
    
    Signed-off-by: wangbo <wang.bo116@zte.com.cn>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sdio_bus.c b/drivers/mmc/core/sdio_bus.c
index b6d8203e46eb..62b0f5ecc7f7 100644
--- a/drivers/mmc/core/sdio_bus.c
+++ b/drivers/mmc/core/sdio_bus.c
@@ -179,7 +179,6 @@ static int sdio_bus_remove(struct device *dev)
 {
 	struct sdio_driver *drv = to_sdio_driver(dev->driver);
 	struct sdio_func *func = dev_to_sdio_func(dev);
-	int ret = 0;
 
 	/* Make sure card is powered before invoking ->remove() */
 	if (func->card->host->caps & MMC_CAP_POWER_OFF_CARD)
@@ -205,7 +204,7 @@ static int sdio_bus_remove(struct device *dev)
 
 	dev_pm_domain_detach(dev, false);
 
-	return ret;
+	return 0;
 }
 
 static const struct dev_pm_ops sdio_bus_pm_ops = {

commit d23fc022c5a15c342d0adcd85bd54516bbf5472c
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu Apr 26 10:53:08 2018 +0200

    mmc: sdio: Respect all error codes from dev_pm_domain_attach()
    
    The limitation of being able to check only for -EPROBE_DEFER from
    dev_pm_domain_attach() has been removed. Hence let's respect all error
    codes and bail out accordingly.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/mmc/core/sdio_bus.c b/drivers/mmc/core/sdio_bus.c
index 2b32b88949ba..b6d8203e46eb 100644
--- a/drivers/mmc/core/sdio_bus.c
+++ b/drivers/mmc/core/sdio_bus.c
@@ -139,7 +139,7 @@ static int sdio_bus_probe(struct device *dev)
 		return -ENODEV;
 
 	ret = dev_pm_domain_attach(dev, false);
-	if (ret == -EPROBE_DEFER)
+	if (ret)
 		return ret;
 
 	/* Unbound SDIO functions are always suspended.

commit 5ef1ecf060f28ecef313b5723f1fd39bf5a35f56
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Wed Mar 29 20:54:37 2017 +0200

    mmc: sdio: fix alignment issue in struct sdio_func
    
    Certain 64-bit systems (e.g. Amlogic Meson GX) require buffers to be
    used for DMA to be 8-byte-aligned. struct sdio_func has an embedded
    small DMA buffer not meeting this requirement.
    When testing switching to descriptor chain mode in meson-gx driver
    SDIO is broken therefore. Fix this by allocating the small DMA buffer
    separately as kmalloc ensures that the returned memory area is
    properly aligned for every basic data type.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Tested-by: Helmut Klein <hgkr.klein@gmail.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sdio_bus.c b/drivers/mmc/core/sdio_bus.c
index e992a7f8a16f..2b32b88949ba 100644
--- a/drivers/mmc/core/sdio_bus.c
+++ b/drivers/mmc/core/sdio_bus.c
@@ -267,7 +267,7 @@ static void sdio_release_func(struct device *dev)
 	sdio_free_func_cis(func);
 
 	kfree(func->info);
-
+	kfree(func->tmpbuf);
 	kfree(func);
 }
 
@@ -282,6 +282,16 @@ struct sdio_func *sdio_alloc_func(struct mmc_card *card)
 	if (!func)
 		return ERR_PTR(-ENOMEM);
 
+	/*
+	 * allocate buffer separately to make sure it's properly aligned for
+	 * DMA usage (incl. 64 bit DMA)
+	 */
+	func->tmpbuf = kmalloc(4, GFP_KERNEL);
+	if (!func->tmpbuf) {
+		kfree(func);
+		return ERR_PTR(-ENOMEM);
+	}
+
 	func->card = card;
 
 	device_initialize(&func->dev);

commit 4facdde11394d44b3869807841042d059f074a07
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri Jan 13 14:14:14 2017 +0100

    mmc: core: Move public functions from card.h to private headers
    
    A significant amount of functions and other definitions are available
    through the public mmc card.h header file. Let's slim down this public mmc
    interface, as to prevent users from abusing it, by moving some of the
    functions/definitions to private mmc header files.
    
    This change concentrates on moving the functions into private mmc headers,
    following changes may continue with additional clean-ups.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Reviewed-by: Shawn Lin <shawn.lin@rock-chips.com>

diff --git a/drivers/mmc/core/sdio_bus.c b/drivers/mmc/core/sdio_bus.c
index 86f5b3223aae..e992a7f8a16f 100644
--- a/drivers/mmc/core/sdio_bus.c
+++ b/drivers/mmc/core/sdio_bus.c
@@ -25,6 +25,7 @@
 #include <linux/of.h>
 
 #include "core.h"
+#include "card.h"
 #include "sdio_cis.h"
 #include "sdio_bus.h"
 

commit ec076cd226c3d93565ede082a240e23b5090e36c
Author: Fu, Zhonghui <zhonghui.fu@linux.intel.com>
Date:   Fri Dec 4 21:05:56 2015 +0800

    mmc: enable MMC/SD/SDIO device to suspend/resume asynchronously
    
    Now, PM core supports asynchronous suspend/resume mode for devices
    during system suspend/resume, and the power state transition of one
    device may be completed in separate kernel thread. PM core ensures
    all power state transition dependency between devices. This patch
    enables MMC/SD/SDIO card and SDIO function devices to suspend/resume
    asynchronously. This will take advantage of multicore and improve
    system suspend/resume speed. After applying this patch and enabling
    all SDIO function's child devices to suspend/resume asynchronously
    on ASUS T100TA, the system suspend-to-idle time is reduced from
    1645ms to 1108ms, and the system resume time is reduced from 940ms
    to 918ms.
    
    Signed-off-by: Zhonghui Fu <zhonghui.fu@linux.intel.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sdio_bus.c b/drivers/mmc/core/sdio_bus.c
index 7e327a6dd53d..86f5b3223aae 100644
--- a/drivers/mmc/core/sdio_bus.c
+++ b/drivers/mmc/core/sdio_bus.c
@@ -322,6 +322,7 @@ int sdio_add_func(struct sdio_func *func)
 
 	sdio_set_of_node(func);
 	sdio_acpi_set_handle(func);
+	device_enable_async_suspend(&func->dev);
 	ret = device_add(&func->dev);
 	if (ret == 0)
 		sdio_func_set_present(func);

commit 1ef48e3ded7d25a6c382c4c74f44474e76038275
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Mon Jun 1 12:18:25 2015 +0200

    mmc: core: Attach PM domain prior probing of SDIO func driver
    
    Other subsystem buses attach PM domains during probe, but prior calling
    the driver's ->probe() method. During the removal phase, detaching the PM
    domain will be done after invoking the driver's ->remove() callback.
    
    Convert the SDIO bus to follow this behavior and add error handling.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sdio_bus.c b/drivers/mmc/core/sdio_bus.c
index bee02e644d62..7e327a6dd53d 100644
--- a/drivers/mmc/core/sdio_bus.c
+++ b/drivers/mmc/core/sdio_bus.c
@@ -137,6 +137,10 @@ static int sdio_bus_probe(struct device *dev)
 	if (!id)
 		return -ENODEV;
 
+	ret = dev_pm_domain_attach(dev, false);
+	if (ret == -EPROBE_DEFER)
+		return ret;
+
 	/* Unbound SDIO functions are always suspended.
 	 * During probe, the function is set active and the usage count
 	 * is incremented.  If the driver supports runtime PM,
@@ -166,6 +170,7 @@ static int sdio_bus_probe(struct device *dev)
 disable_runtimepm:
 	if (func->card->host->caps & MMC_CAP_POWER_OFF_CARD)
 		pm_runtime_put_noidle(dev);
+	dev_pm_domain_detach(dev, false);
 	return ret;
 }
 
@@ -197,6 +202,8 @@ static int sdio_bus_remove(struct device *dev)
 	if (func->card->host->caps & MMC_CAP_POWER_OFF_CARD)
 		pm_runtime_put_sync(dev);
 
+	dev_pm_domain_detach(dev, false);
+
 	return ret;
 }
 
@@ -316,10 +323,8 @@ int sdio_add_func(struct sdio_func *func)
 	sdio_set_of_node(func);
 	sdio_acpi_set_handle(func);
 	ret = device_add(&func->dev);
-	if (ret == 0) {
+	if (ret == 0)
 		sdio_func_set_present(func);
-		dev_pm_domain_attach(&func->dev, false);
-	}
 
 	return ret;
 }
@@ -335,7 +340,6 @@ void sdio_remove_func(struct sdio_func *func)
 	if (!sdio_func_present(func))
 		return;
 
-	dev_pm_domain_detach(&func->dev, false);
 	device_del(&func->dev);
 	of_node_put(func->dev.of_node);
 	put_device(&func->dev);

commit 25185f3f31c924eecc6ff4f55f7acceabf24de11
Author: Sascha Hauer <s.hauer@pengutronix.de>
Date:   Mon Jun 30 11:07:25 2014 +0200

    mmc: Add SDIO function devicetree subnode parsing
    
    This adds SDIO devicetree subnode parsing to the mmc core. While
    SDIO devices are runtime probable they sometimes need nonprobable
    additional information on embedded systems, like an additional gpio
    interrupt or a clock. This patch makes it possible to supply this
    information from the devicetree. SDIO drivers will find a pointer
    to the devicenode in their devices of_node pointer.
    
    Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>
    [hdegoede@redhat.com: Misc. cleanups]
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sdio_bus.c b/drivers/mmc/core/sdio_bus.c
index 60885316afba..bee02e644d62 100644
--- a/drivers/mmc/core/sdio_bus.c
+++ b/drivers/mmc/core/sdio_bus.c
@@ -22,7 +22,9 @@
 #include <linux/mmc/card.h>
 #include <linux/mmc/host.h>
 #include <linux/mmc/sdio_func.h>
+#include <linux/of.h>
 
+#include "core.h"
 #include "sdio_cis.h"
 #include "sdio_bus.h"
 
@@ -295,6 +297,13 @@ static void sdio_acpi_set_handle(struct sdio_func *func)
 static inline void sdio_acpi_set_handle(struct sdio_func *func) {}
 #endif
 
+static void sdio_set_of_node(struct sdio_func *func)
+{
+	struct mmc_host *host = func->card->host;
+
+	func->dev.of_node = mmc_of_find_child_device(host, func->num);
+}
+
 /*
  * Register a new SDIO function with the driver model.
  */
@@ -304,6 +313,7 @@ int sdio_add_func(struct sdio_func *func)
 
 	dev_set_name(&func->dev, "%s:%d", mmc_card_id(func->card), func->num);
 
+	sdio_set_of_node(func);
 	sdio_acpi_set_handle(func);
 	ret = device_add(&func->dev);
 	if (ret == 0) {
@@ -327,6 +337,7 @@ void sdio_remove_func(struct sdio_func *func)
 
 	dev_pm_domain_detach(&func->dev, false);
 	device_del(&func->dev);
+	of_node_put(func->dev.of_node);
 	put_device(&func->dev);
 }
 

commit 51d346068876bf4972efc61969d02958a087f3ee
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu Oct 23 14:37:00 2014 +0300

    mmc: core: silence a shift wrapping warning
    
    Presumably ->slotno is normally fairly small and the shift doesn't wrap
    but static checkers will complain about it.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sdio_bus.c b/drivers/mmc/core/sdio_bus.c
index 51e23f502108..60885316afba 100644
--- a/drivers/mmc/core/sdio_bus.c
+++ b/drivers/mmc/core/sdio_bus.c
@@ -287,7 +287,7 @@ struct sdio_func *sdio_alloc_func(struct mmc_card *card)
 static void sdio_acpi_set_handle(struct sdio_func *func)
 {
 	struct mmc_host *host = func->card->host;
-	u64 addr = (host->slotno << 16) | func->num;
+	u64 addr = ((u64)host->slotno << 16) | func->num;
 
 	acpi_preset_companion(&func->dev, ACPI_COMPANION(host->parent), addr);
 }

commit 433b7b1210a4ece4f2b4f1b04f31a2f0928c8aa8
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Mon Oct 6 11:00:15 2014 +0200

    mmc: core: Don't export the to_sdio_driver macro
    
    The macro is only used by the mmc core, so let's move it in there.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sdio_bus.c b/drivers/mmc/core/sdio_bus.c
index f09040bf5484..51e23f502108 100644
--- a/drivers/mmc/core/sdio_bus.c
+++ b/drivers/mmc/core/sdio_bus.c
@@ -26,6 +26,8 @@
 #include "sdio_cis.h"
 #include "sdio_bus.h"
 
+#define to_sdio_driver(d)	container_of(d, struct sdio_driver, drv)
+
 /* show configuration fields */
 #define sdio_config_attr(field, format_string)				\
 static ssize_t								\

commit d99903ca4c89c3aa325845cf87ff249d0b432261
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Mon Oct 6 10:28:35 2014 +0200

    mmc: core: Remove superfluous ifdefs for SDIO bus' PM callbacks
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sdio_bus.c b/drivers/mmc/core/sdio_bus.c
index 6da97b170563..f09040bf5484 100644
--- a/drivers/mmc/core/sdio_bus.c
+++ b/drivers/mmc/core/sdio_bus.c
@@ -196,8 +196,6 @@ static int sdio_bus_remove(struct device *dev)
 	return ret;
 }
 
-#ifdef CONFIG_PM
-
 static const struct dev_pm_ops sdio_bus_pm_ops = {
 	SET_SYSTEM_SLEEP_PM_OPS(pm_generic_suspend, pm_generic_resume)
 	SET_RUNTIME_PM_OPS(
@@ -207,14 +205,6 @@ static const struct dev_pm_ops sdio_bus_pm_ops = {
 	)
 };
 
-#define SDIO_PM_OPS_PTR	(&sdio_bus_pm_ops)
-
-#else /* !CONFIG_PM */
-
-#define SDIO_PM_OPS_PTR	NULL
-
-#endif /* !CONFIG_PM */
-
 static struct bus_type sdio_bus_type = {
 	.name		= "sdio",
 	.dev_groups	= sdio_dev_groups,
@@ -222,7 +212,7 @@ static struct bus_type sdio_bus_type = {
 	.uevent		= sdio_bus_uevent,
 	.probe		= sdio_bus_probe,
 	.remove		= sdio_bus_remove,
-	.pm		= SDIO_PM_OPS_PTR,
+	.pm		= &sdio_bus_pm_ops,
 };
 
 int sdio_register_bus(void)

commit f43b179bbd84d2106c6fb8c7f2db1bfacff19f62
Merge: a2ce35273c2f 583f958b8a23
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Oct 11 06:34:22 2014 -0400

    Merge tag 'mmc-v3.18-1' of git://git.linaro.org/people/ulf.hansson/mmc
    
    Pull MMC updates from Ulf Hansson:
     "MMC core:
       - Fix SDIO IRQ bug
       - MMC regulator improvements
       - Fix slot-gpio card detect bug
       - Add support for Driver Stage Register
       - Convert the common MMC OF parser to use GPIO descriptors
       - Convert MMC_CAP2_NO_MULTI_READ into a callback, ->multi_io_quirk()
       - Some additional minor fixes
    
      MMC host:
       - mmci: Support Qualcomm specific DML layer for DMA
       - dw_mmc: Use common MMC regulators
       - dw_mmc: Add support for Rock-chips RK3288
       - tmio: Enable runtime PM support
       - tmio: Add support for R-Car Gen2 SoCs
       - tmio: Several fixes and improvements
       - omap_hsmmc: Removed Balaji from MAINTAINERS
       - jz4740: add DMA and pre/post support
       - sdhci: Add support for Intel Braswell
       - sdhci: Several fixes and improvements"
    
    * tag 'mmc-v3.18-1' of git://git.linaro.org/people/ulf.hansson/mmc: (119 commits)
      ARM: dts: fix MMC2 regulators for Exynos5420 Arndale Octa board
      mmc: sdhci-acpi: Fix Braswell eMMC timeout clock frequency
      mmc: sdhci-acpi: Pass HID and UID to probe_slot
      mmc: sdhci-acpi: Get UID directly from acpi_device
      mmc, sdhci, bcm-kona, LLVMLinux: Remove use of __initconst
      mmc: sdhci-pci: Fix Braswell eMMC timeout clock frequency
      mmc: sdhci: Let a driver override timeout clock frequency
      mmc: sdhci-pci: Add Bay Trail and Braswell SD card detect
      mmc: sdhci-pci: Set SDHCI_QUIRK2_STOP_WITH_TC for Intel BYT host controllers
      mmc: sdhci-acpi: Add a HID and UID for a SD Card host controller
      mmc: sdhci-acpi: Set SDHCI_QUIRK2_STOP_WITH_TC for Intel host controllers
      mmc: sdhci: Add quirk for always getting TC with stop cmd
      mmc: core: restore detect line inversion semantics
      mmc: Fix incorrect warning when setting 0 Hz via debugfs
      mmc: Fix use of wrong device in mmc_gpiod_free_cd()
      mmc: atmel-mci: fix mismatched section on atmci_cleanup_slot
      mmc: rtsx_pci: Set power related cap2 macros
      mmc: core: Add new power_mode MMC_POWER_UNDEFINED
      mmc: sdhci: execute tuning when device is not busy
      mmc: atmel-mci: Release mmc resources on failure in probe
      ..

commit f48c767ce8951e30eb716b8ef69142d21aacbd1d
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Mon Sep 29 13:58:47 2014 +0200

    PM / Domains: Move dev_pm_domain_attach|detach() to pm_domain.h
    
    The commit 46420dd73b80 (PM / Domains: Add APIs to attach/detach a PM
    domain for a device) started using errno values in pm.h header file.
    It also failed to include the header for these, thus it caused
    compiler errors.
    
    Instead of including the errno header to pm.h, let's move the functions
    to pm_domain.h, since it's a better match.
    
    Fixes: 46420dd73b80 (PM / Domains: Add APIs to attach/detach a PM domain for a device)
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Acked-by: Wolfram Sang <wsa@the-dreams.de>
    Acked-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/mmc/core/sdio_bus.c b/drivers/mmc/core/sdio_bus.c
index 1df0fc63c17c..65cf7a7e05ea 100644
--- a/drivers/mmc/core/sdio_bus.c
+++ b/drivers/mmc/core/sdio_bus.c
@@ -16,6 +16,7 @@
 #include <linux/export.h>
 #include <linux/slab.h>
 #include <linux/pm_runtime.h>
+#include <linux/pm_domain.h>
 #include <linux/acpi.h>
 
 #include <linux/mmc/card.h>

commit 6606110d89aefcb21b9e70adfe064987cbd8393a
Author: Joe Perches <joe@perches.com>
Date:   Fri Sep 12 14:56:56 2014 -0700

    mmc: Convert pr_warning to pr_warn
    
    Use the much more common pr_warn instead of pr_warning.
    
    Other miscellanea:
    
    o Coalesce formats
    o Realign arguments
    o Remove extra spaces when coalescing formats
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sdio_bus.c b/drivers/mmc/core/sdio_bus.c
index 4fa8fef9147f..e4eb456df4ac 100644
--- a/drivers/mmc/core/sdio_bus.c
+++ b/drivers/mmc/core/sdio_bus.c
@@ -177,8 +177,8 @@ static int sdio_bus_remove(struct device *dev)
 	drv->remove(func);
 
 	if (func->irq_handler) {
-		pr_warning("WARNING: driver %s did not remove "
-			"its interrupt handler!\n", drv->name);
+		pr_warn("WARNING: driver %s did not remove its interrupt handler!\n",
+			drv->name);
 		sdio_claim_host(func);
 		sdio_release_irq(func);
 		sdio_release_host(func);

commit 397a0253527a578fa036d3438ad4909c65d63166
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri Sep 19 20:27:40 2014 +0200

    mmc: sdio: Convert to dev_pm_domain_attach|detach()
    
    Previously only the ACPI PM domain was supported by the sdio bus.
    
    Let's convert to the common attach/detach functions for PM domains,
    which currently means we are extending the support to include the
    generic PM domain as well.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Kevin Hilman <khilman@linaro.org>
    Reviewed-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/mmc/core/sdio_bus.c b/drivers/mmc/core/sdio_bus.c
index 4fa8fef9147f..1df0fc63c17c 100644
--- a/drivers/mmc/core/sdio_bus.c
+++ b/drivers/mmc/core/sdio_bus.c
@@ -315,7 +315,7 @@ int sdio_add_func(struct sdio_func *func)
 	ret = device_add(&func->dev);
 	if (ret == 0) {
 		sdio_func_set_present(func);
-		acpi_dev_pm_attach(&func->dev, false);
+		dev_pm_domain_attach(&func->dev, false);
 	}
 
 	return ret;
@@ -332,7 +332,7 @@ void sdio_remove_func(struct sdio_func *func)
 	if (!sdio_func_present(func))
 		return;
 
-	acpi_dev_pm_detach(&func->dev, false);
+	dev_pm_domain_detach(&func->dev, false);
 	device_del(&func->dev);
 	put_device(&func->dev);
 }

commit 573185cc7e646fdd5da12702ba5383e91cc25ef3
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri Feb 28 12:49:00 2014 +0100

    mmc: core: Invoke sdio func driver's PM callbacks from the sdio bus
    
    The sdio func device is added to the driver model after the card
    device.
    
    This means the sdio func device will be suspend before the card device
    and thus resumed after. The consequence are the mmc core don't
    explicity need to protect itself from receiving sdio requests in
    suspended state. Instead that can be handled from the sdio bus, which
    is thus invokes the PM callbacks instead of old dummy function.
    
    In the case were the sdio func driver don't implement the PM callbacks
    the mmc core will in the early phase of system suspend, remove the
    card from the driver model and thus power off it.
    
    Cc: Aaron Lu <aaron.lu@intel.com>
    Cc: NeilBrown <neilb@suse.de>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Aaron Lu <aaron.lu@intel.com>
    Tested-by: xiaoming wang <xiaoming.wang@intel.com>
    Tested-by: Chuanxiao Dong <chuanxiao.dong@intel.com>
    Signed-off-by: Chris Ball <chris@printf.net>

diff --git a/drivers/mmc/core/sdio_bus.c b/drivers/mmc/core/sdio_bus.c
index 92d1ba8e8153..4fa8fef9147f 100644
--- a/drivers/mmc/core/sdio_bus.c
+++ b/drivers/mmc/core/sdio_bus.c
@@ -197,20 +197,8 @@ static int sdio_bus_remove(struct device *dev)
 
 #ifdef CONFIG_PM
 
-#ifdef CONFIG_PM_SLEEP
-static int pm_no_operation(struct device *dev)
-{
-	/*
-	 * Prevent the PM core from calling SDIO device drivers' suspend
-	 * callback routines, which it is not supposed to do, by using this
-	 * empty function as the bus type suspend callaback for SDIO.
-	 */
-	return 0;
-}
-#endif
-
 static const struct dev_pm_ops sdio_bus_pm_ops = {
-	SET_SYSTEM_SLEEP_PM_OPS(pm_no_operation, pm_no_operation)
+	SET_SYSTEM_SLEEP_PM_OPS(pm_generic_suspend, pm_generic_resume)
 	SET_RUNTIME_PM_OPS(
 		pm_generic_runtime_suspend,
 		pm_generic_runtime_resume,

commit 9c5ad36d987a1b06f6b0b9dc7bc61a45d277455d
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Nov 28 23:58:28 2013 +0100

    ACPI / bind: Redefine acpi_preset_companion()
    
    Modify acpi_preset_companion() to take a struct acpi_device pointer
    instead of an ACPI handle as its second argument and redefine it as
    a static inline wrapper around ACPI_COMPANION_SET() passing the
    return value of acpi_find_child_device() directly as the second
    argument to it.  Update its users to pass struct acpi_device
    pointers instead of ACPI handles to it.
    
    This allows some unnecessary acpi_bus_get_device() calls to be
    avoided.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Aaron Lu <aaron.lu@intel.com>
    Tested-by: Aaron Lu <aaron.lu@intel.com> # for ATA binding

diff --git a/drivers/mmc/core/sdio_bus.c b/drivers/mmc/core/sdio_bus.c
index 157b570ba343..92d1ba8e8153 100644
--- a/drivers/mmc/core/sdio_bus.c
+++ b/drivers/mmc/core/sdio_bus.c
@@ -308,7 +308,7 @@ static void sdio_acpi_set_handle(struct sdio_func *func)
 	struct mmc_host *host = func->card->host;
 	u64 addr = (host->slotno << 16) | func->num;
 
-	acpi_preset_companion(&func->dev, ACPI_HANDLE(host->parent), addr);
+	acpi_preset_companion(&func->dev, ACPI_COMPANION(host->parent), addr);
 }
 #else
 static inline void sdio_acpi_set_handle(struct sdio_func *func) {}

commit 7b1998116bbb2f3e5dd6cb9a8ee6db479b0b50a9
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Nov 11 22:41:56 2013 +0100

    ACPI / driver core: Store an ACPI device pointer in struct acpi_dev_node
    
    Modify struct acpi_dev_node to contain a pointer to struct acpi_device
    associated with the given device object (that is, its ACPI companion
    device) instead of an ACPI handle corresponding to it.  Introduce two
    new macros for manipulating that pointer in a CONFIG_ACPI-safe way,
    ACPI_COMPANION() and ACPI_COMPANION_SET(), and rework the
    ACPI_HANDLE() macro to take the above changes into account.
    Drop the ACPI_HANDLE_SET() macro entirely and rework its users to
    use ACPI_COMPANION_SET() instead.  For some of them who used to
    pass the result of acpi_get_child() directly to ACPI_HANDLE_SET()
    introduce a helper routine acpi_preset_companion() doing an
    equivalent thing.
    
    The main motivation for doing this is that there are things
    represented by struct acpi_device objects that don't have valid
    ACPI handles (so called fixed ACPI hardware features, such as
    power and sleep buttons) and we would like to create platform
    device objects for them and "glue" them to their ACPI companions
    in the usual way (which currently is impossible due to the
    lack of valid ACPI handles).  However, there are more reasons
    why it may be useful.
    
    First, struct acpi_device pointers allow of much better type checking
    than void pointers which are ACPI handles, so it should be more
    difficult to write buggy code using modified struct acpi_dev_node
    and the new macros.  Second, the change should help to reduce (over
    time) the number of places in which the result of ACPI_HANDLE() is
    passed to acpi_bus_get_device() in order to obtain a pointer to the
    struct acpi_device associated with the given "physical" device,
    because now that pointer is returned by ACPI_COMPANION() directly.
    Finally, the change should make it easier to write generic code that
    will build both for CONFIG_ACPI set and unset without adding explicit
    compiler directives to it.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com> # on Haswell
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Reviewed-by: Aaron Lu <aaron.lu@intel.com> # for ATA and SDIO part

diff --git a/drivers/mmc/core/sdio_bus.c b/drivers/mmc/core/sdio_bus.c
index ef8956568c3a..157b570ba343 100644
--- a/drivers/mmc/core/sdio_bus.c
+++ b/drivers/mmc/core/sdio_bus.c
@@ -308,8 +308,7 @@ static void sdio_acpi_set_handle(struct sdio_func *func)
 	struct mmc_host *host = func->card->host;
 	u64 addr = (host->slotno << 16) | func->num;
 
-	ACPI_HANDLE_SET(&func->dev,
-			acpi_get_child(ACPI_HANDLE(host->parent), addr));
+	acpi_preset_companion(&func->dev, ACPI_HANDLE(host->parent), addr);
 }
 #else
 static inline void sdio_acpi_set_handle(struct sdio_func *func) {}

commit f24fc57b24444fe31fbddb5716195bb8bbc70b58
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sun Oct 6 23:55:43 2013 -0700

    MMC: convert bus code to use dev_groups
    
    The dev_attrs field of struct bus_type is going away soon, dev_groups
    should be used instead.  This converts the MMC bus code to use the
    correct field.
    
    Cc: Chris Ball <cjb@laptop.org>
    Cc: Ulf Hansson <ulf.hansson@linaro.org>
    Cc: Konstantin Dorfman <kdorfman@codeaurora.org>
    Cc: Seungwon Jeon <tgih.jun@samsung.com>
    Cc: <linux-mmc@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/mmc/core/sdio_bus.c b/drivers/mmc/core/sdio_bus.c
index 6d67492a9247..ef8956568c3a 100644
--- a/drivers/mmc/core/sdio_bus.c
+++ b/drivers/mmc/core/sdio_bus.c
@@ -34,7 +34,8 @@ field##_show(struct device *dev, struct device_attribute *attr, char *buf)				\
 									\
 	func = dev_to_sdio_func (dev);					\
 	return sprintf (buf, format_string, func->field);		\
-}
+}									\
+static DEVICE_ATTR_RO(field)
 
 sdio_config_attr(class, "0x%02x\n");
 sdio_config_attr(vendor, "0x%04x\n");
@@ -47,14 +48,16 @@ static ssize_t modalias_show(struct device *dev, struct device_attribute *attr,
 	return sprintf(buf, "sdio:c%02Xv%04Xd%04X\n",
 			func->class, func->vendor, func->device);
 }
-
-static struct device_attribute sdio_dev_attrs[] = {
-	__ATTR_RO(class),
-	__ATTR_RO(vendor),
-	__ATTR_RO(device),
-	__ATTR_RO(modalias),
-	__ATTR_NULL,
+static DEVICE_ATTR_RO(modalias);
+
+static struct attribute *sdio_dev_attrs[] = {
+	&dev_attr_class.attr,
+	&dev_attr_vendor.attr,
+	&dev_attr_device.attr,
+	&dev_attr_modalias.attr,
+	NULL,
 };
+ATTRIBUTE_GROUPS(sdio_dev);
 
 static const struct sdio_device_id *sdio_match_one(struct sdio_func *func,
 	const struct sdio_device_id *id)
@@ -225,7 +228,7 @@ static const struct dev_pm_ops sdio_bus_pm_ops = {
 
 static struct bus_type sdio_bus_type = {
 	.name		= "sdio",
-	.dev_attrs	= sdio_dev_attrs,
+	.dev_groups	= sdio_dev_groups,
 	.match		= sdio_bus_match,
 	.uevent		= sdio_bus_uevent,
 	.probe		= sdio_bus_probe,

commit 45f0a85c8258741d11bda25c0a5669c06267204a
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jun 3 21:49:52 2013 +0200

    PM / Runtime: Rework the "runtime idle" helper routine
    
    The "runtime idle" helper routine, rpm_idle(), currently ignores
    return values from .runtime_idle() callbacks executed by it.
    However, it turns out that many subsystems use
    pm_generic_runtime_idle() which checks the return value of the
    driver's callback and executes pm_runtime_suspend() for the device
    unless that value is not 0.  If that logic is moved to rpm_idle()
    instead, pm_generic_runtime_idle() can be dropped and its users
    will not need any .runtime_idle() callbacks any more.
    
    Moreover, the PCI, SCSI, and SATA subsystems' .runtime_idle()
    routines, pci_pm_runtime_idle(), scsi_runtime_idle(), and
    ata_port_runtime_idle(), respectively, as well as a few drivers'
    ones may be simplified if rpm_idle() calls rpm_suspend() after 0 has
    been returned by the .runtime_idle() callback executed by it.
    
    To reduce overall code bloat, make the changes described above.
    
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Tested-by: Kevin Hilman <khilman@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Kevin Hilman <khilman@linaro.org>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>

diff --git a/drivers/mmc/core/sdio_bus.c b/drivers/mmc/core/sdio_bus.c
index 546c67c2bbbf..6d67492a9247 100644
--- a/drivers/mmc/core/sdio_bus.c
+++ b/drivers/mmc/core/sdio_bus.c
@@ -211,7 +211,7 @@ static const struct dev_pm_ops sdio_bus_pm_ops = {
 	SET_RUNTIME_PM_OPS(
 		pm_generic_runtime_suspend,
 		pm_generic_runtime_resume,
-		pm_generic_runtime_idle
+		NULL
 	)
 };
 

commit 3bffb800b91bb128b61d83deb01ce63c455d108f
Author: Li Fei <fei.li@intel.com>
Date:   Mon Apr 8 09:36:39 2013 +0800

    mmc: core: call pm_runtime_put_noidle in pm_runtime_get_sync failed case
    
    Even in failed case of pm_runtime_get_sync, the usage_count
    is incremented. In order to keep the usage_count with correct
    value and runtime power management to behave correctly, call
    pm_runtime_put_noidle in such case.
    
    Signed-off-by: Liu Chuansheng <chuansheng.liu@intel.com>
    Signed-off-by: Li Fei <fei.li@intel.com>
    Acked-by: Ohad Ben-Cohen <ohad@wizery.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sdio_bus.c b/drivers/mmc/core/sdio_bus.c
index 8d6bb1821834..546c67c2bbbf 100644
--- a/drivers/mmc/core/sdio_bus.c
+++ b/drivers/mmc/core/sdio_bus.c
@@ -138,7 +138,7 @@ static int sdio_bus_probe(struct device *dev)
 	if (func->card->host->caps & MMC_CAP_POWER_OFF_CARD) {
 		ret = pm_runtime_get_sync(dev);
 		if (ret < 0)
-			goto out;
+			goto disable_runtimepm;
 	}
 
 	/* Set the default block size so the driver is sure it's something
@@ -158,7 +158,6 @@ static int sdio_bus_probe(struct device *dev)
 disable_runtimepm:
 	if (func->card->host->caps & MMC_CAP_POWER_OFF_CARD)
 		pm_runtime_put_noidle(dev);
-out:
 	return ret;
 }
 

commit eed222aca8d077af3600b651176f6fd04d95cce1
Author: Aaron Lu <aaron.lu@intel.com>
Date:   Tue Mar 5 11:24:52 2013 +0800

    mmc: sdio: bind acpi with sdio function device
    
    ACPI spec 5 defined the _ADR encoding for sdio bus as:
    High word - slot number (0 based)
    Low word  - function number
    
    This patch adds support for binding sdio function device with acpi node,
    and if successful, involve acpi into its power management.
    
    Signed-off-by: Aaron Lu <aaron.lu@intel.com>
    Reviewed-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sdio_bus.c b/drivers/mmc/core/sdio_bus.c
index 5e57048e2c1d..8d6bb1821834 100644
--- a/drivers/mmc/core/sdio_bus.c
+++ b/drivers/mmc/core/sdio_bus.c
@@ -16,6 +16,7 @@
 #include <linux/export.h>
 #include <linux/slab.h>
 #include <linux/pm_runtime.h>
+#include <linux/acpi.h>
 
 #include <linux/mmc/card.h>
 #include <linux/mmc/host.h>
@@ -299,6 +300,19 @@ struct sdio_func *sdio_alloc_func(struct mmc_card *card)
 	return func;
 }
 
+#ifdef CONFIG_ACPI
+static void sdio_acpi_set_handle(struct sdio_func *func)
+{
+	struct mmc_host *host = func->card->host;
+	u64 addr = (host->slotno << 16) | func->num;
+
+	ACPI_HANDLE_SET(&func->dev,
+			acpi_get_child(ACPI_HANDLE(host->parent), addr));
+}
+#else
+static inline void sdio_acpi_set_handle(struct sdio_func *func) {}
+#endif
+
 /*
  * Register a new SDIO function with the driver model.
  */
@@ -308,9 +322,12 @@ int sdio_add_func(struct sdio_func *func)
 
 	dev_set_name(&func->dev, "%s:%d", mmc_card_id(func->card), func->num);
 
+	sdio_acpi_set_handle(func);
 	ret = device_add(&func->dev);
-	if (ret == 0)
+	if (ret == 0) {
 		sdio_func_set_present(func);
+		acpi_dev_pm_attach(&func->dev, false);
+	}
 
 	return ret;
 }
@@ -326,6 +343,7 @@ void sdio_remove_func(struct sdio_func *func)
 	if (!sdio_func_present(func))
 		return;
 
+	acpi_dev_pm_detach(&func->dev, false);
 	device_del(&func->dev);
 	put_device(&func->dev);
 }

commit 4c42d6cc245e8d41eb83c724cf38cdb9342ea5ba
Author: Sachin Kamat <sachin.kamat@linaro.org>
Date:   Tue Nov 20 14:43:16 2012 +0530

    mmc: Remove redundant null check before kfree in sdio_bus.c
    
    kfree on a null pointer is a no-op.
    
    Signed-off-by: Sachin Kamat <sachin.kamat@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sdio_bus.c b/drivers/mmc/core/sdio_bus.c
index fc2d94a3b60c..5e57048e2c1d 100644
--- a/drivers/mmc/core/sdio_bus.c
+++ b/drivers/mmc/core/sdio_bus.c
@@ -272,8 +272,7 @@ static void sdio_release_func(struct device *dev)
 
 	sdio_free_func_cis(func);
 
-	if (func->info)
-		kfree(func->info);
+	kfree(func->info);
 
 	kfree(func);
 }

commit b0afd8f68adf6a9b671b0420ab9116a36409ef7f
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Dec 2 14:48:50 2012 +0100

    mmc: sdio: Add empty bus-level suspend/resume callbacks
    
    Suspend methods provided by SDIO drivers are not supposed to be called by
    the PM core.  Instead, when the SDIO core gets to suspend a device's
    ancestor, it calls the device driver's suspend routine.  However, the PM
    core executes suspend callback routines directly for device drivers whose
    bus types don't provide suspend callbacks.  In consequece, because the
    SDIO bus type doesn't provide a suspend callback, the SDIO drivers'
    suspend routines will be executed by the PM core (which shouldn't
    happen).
    
    To prevent this from happening, add empty system suspend/resume callbacks
    for the SDIO bus type.
    
    An analogous change had been made already by commit (e841a7c mmc: sdio:
    Use empty system suspend/resume callbacks at the bus level), but then it
    was reverted inadvertently by commit (d8e2ac3 mmc: sdio: Fix PM_SLEEP
    related build warnings) that attempted to fix build warnings introduced
    by commit e841a7c.
    
    Reported-by: NeilBrown <neilb@suse.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sdio_bus.c b/drivers/mmc/core/sdio_bus.c
index 6bf68799fe97..fc2d94a3b60c 100644
--- a/drivers/mmc/core/sdio_bus.c
+++ b/drivers/mmc/core/sdio_bus.c
@@ -193,7 +193,21 @@ static int sdio_bus_remove(struct device *dev)
 }
 
 #ifdef CONFIG_PM
+
+#ifdef CONFIG_PM_SLEEP
+static int pm_no_operation(struct device *dev)
+{
+	/*
+	 * Prevent the PM core from calling SDIO device drivers' suspend
+	 * callback routines, which it is not supposed to do, by using this
+	 * empty function as the bus type suspend callaback for SDIO.
+	 */
+	return 0;
+}
+#endif
+
 static const struct dev_pm_ops sdio_bus_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(pm_no_operation, pm_no_operation)
 	SET_RUNTIME_PM_OPS(
 		pm_generic_runtime_suspend,
 		pm_generic_runtime_resume,

commit d8e2ac330f65bcf47e8894fe5331a7e8ee019c06
Author: Thierry Reding <thierry.reding@avionic-design.de>
Date:   Thu Aug 9 09:32:21 2012 +0000

    mmc: sdio: Fix PM_SLEEP related build warnings
    
    Power management callbacks defined by SIMPLE_DEV_PM_OPS are only used if
    the PM_SLEEP Kconfig symbol has been defined. If not, the compiler will
    complain about them being unused. However, since the callback for this
    driver doesn't do anything it can just as well be dropped.
    
    Signed-off-by: Thierry Reding <thierry.reding@avionic-design.de>
    Acked-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sdio_bus.c b/drivers/mmc/core/sdio_bus.c
index 236842ec955a..6bf68799fe97 100644
--- a/drivers/mmc/core/sdio_bus.c
+++ b/drivers/mmc/core/sdio_bus.c
@@ -193,14 +193,7 @@ static int sdio_bus_remove(struct device *dev)
 }
 
 #ifdef CONFIG_PM
-
-static int pm_no_operation(struct device *dev)
-{
-	return 0;
-}
-
 static const struct dev_pm_ops sdio_bus_pm_ops = {
-	SET_SYSTEM_SLEEP_PM_OPS(pm_no_operation, pm_no_operation)
 	SET_RUNTIME_PM_OPS(
 		pm_generic_runtime_suspend,
 		pm_generic_runtime_resume,

commit e841a7c69b708eeaf784fd517978006e8319b03a
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Apr 1 00:34:58 2012 -0400

    mmc: sdio: Use empty system suspend/resume callbacks at the bus level
    
    Neil Brown reports that commit 35cd133c
    
       PM: Run the driver callback directly if the subsystem one is not there
    
    breaks suspend for his libertas wifi, because SDIO has a protocol
    where the suspend method can return -ENOSYS and this means "There is
    no point in suspending, just turn me off".  Moreover, the suspend
    methods provided by SDIO drivers are not supposed to be called by
    the PM core or bus-level suspend routines (which aren't presend for
    SDIO).  Instead, when the SDIO core gets to suspend the device's
    ancestor, it calls the device driver's suspend function, catches the
    ENOSYS, and turns the device off.
    
    The commit above breaks the SDIO core's assumption that the device
    drivers' callbacks won't be executed if it doesn't provide any
    bus-level callbacks.  If fact, however, this assumption has never
    been really satisfied, because device class or device type suspend
    might very well use the driver's callback even without that commit.
    
    The simplest way to address this problem is to make the SDIO core
    tell the PM core to ignore driver callbacks, for example by providing
    no-operation suspend/resume callbacks at the bus level for it,
    which is implemented by this change.
    
    Reported-and-tested-by: Neil Brown <neilb@suse.de>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    [stable: please apply to 3.3-stable only]
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sdio_bus.c b/drivers/mmc/core/sdio_bus.c
index 40989e6bb53a..236842ec955a 100644
--- a/drivers/mmc/core/sdio_bus.c
+++ b/drivers/mmc/core/sdio_bus.c
@@ -192,9 +192,15 @@ static int sdio_bus_remove(struct device *dev)
 	return ret;
 }
 
-#ifdef CONFIG_PM_RUNTIME
+#ifdef CONFIG_PM
+
+static int pm_no_operation(struct device *dev)
+{
+	return 0;
+}
 
 static const struct dev_pm_ops sdio_bus_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(pm_no_operation, pm_no_operation)
 	SET_RUNTIME_PM_OPS(
 		pm_generic_runtime_suspend,
 		pm_generic_runtime_resume,
@@ -204,11 +210,11 @@ static const struct dev_pm_ops sdio_bus_pm_ops = {
 
 #define SDIO_PM_OPS_PTR	(&sdio_bus_pm_ops)
 
-#else /* !CONFIG_PM_RUNTIME */
+#else /* !CONFIG_PM */
 
 #define SDIO_PM_OPS_PTR	NULL
 
-#endif /* !CONFIG_PM_RUNTIME */
+#endif /* !CONFIG_PM */
 
 static struct bus_type sdio_bus_type = {
 	.name		= "sdio",

commit 3ef77af154b03776c6c662c68c6332719e9eecac
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Sun Jul 10 12:42:00 2011 -0400

    mmc: Add export.h for EXPORT_SYMBOL/THIS_MODULE as required
    
    These two basic defines were everywhere, simply because module.h
    was also everywhere.   But we are cleaning up the latter.  So make
    the exporters actually call out their need for the include.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/drivers/mmc/core/sdio_bus.c b/drivers/mmc/core/sdio_bus.c
index c643b2f78bf1..40989e6bb53a 100644
--- a/drivers/mmc/core/sdio_bus.c
+++ b/drivers/mmc/core/sdio_bus.c
@@ -13,6 +13,7 @@
 
 #include <linux/device.h>
 #include <linux/err.h>
+#include <linux/export.h>
 #include <linux/slab.h>
 #include <linux/pm_runtime.h>
 

commit a3c76eb9d4a1e68a69dd880cf0bcb8a52418b993
Author: Girish K S <girish.shivananjappa@linaro.org>
Date:   Tue Oct 11 11:44:09 2011 +0530

    mmc: replace printk with appropriate display macro
    
    All the files using printk function for displaying kernel messages
    in the mmc driver have been replaced with corresponding macro.
    
    Signed-off-by: Girish K S <girish.shivananjappa@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sdio_bus.c b/drivers/mmc/core/sdio_bus.c
index e4e6822d09e3..c643b2f78bf1 100644
--- a/drivers/mmc/core/sdio_bus.c
+++ b/drivers/mmc/core/sdio_bus.c
@@ -173,7 +173,7 @@ static int sdio_bus_remove(struct device *dev)
 	drv->remove(func);
 
 	if (func->irq_handler) {
-		printk(KERN_WARNING "WARNING: driver %s did not remove "
+		pr_warning("WARNING: driver %s did not remove "
 			"its interrupt handler!\n", drv->name);
 		sdio_claim_host(func);
 		sdio_release_irq(func);

commit ecc024419a13da1e589aebc422d9d1e3c0124ba4
Author: Ohad Ben-Cohen <ohad@wizery.com>
Date:   Sun Jul 17 16:38:21 2011 +0100

    mmc: fix runtime PM with -ENOSYS suspend case
    
    In the case where a driver returns -ENOSYS from its suspend handler
    to indicate that the device should be powered down over suspend, the
    remove routine of the driver was not being called, leading to lots of
    confusion during resume.
    
    The problem is that runtime PM is disabled during this process,
    and when we reach mmc_sdio_remove, calling the runtime PM functions here
    (validly) return errors, and this was causing us to skip the remove
    function.
    
    Fix this by ignoring the error value of pm_runtime_get_sync(), which
    can return valid errors. This also matches the behaviour of
    pci_device_remove().
    
    Signed-off-by: Daniel Drake <dsd@laptop.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sdio_bus.c b/drivers/mmc/core/sdio_bus.c
index d2565df8a7fb..e4e6822d09e3 100644
--- a/drivers/mmc/core/sdio_bus.c
+++ b/drivers/mmc/core/sdio_bus.c
@@ -167,11 +167,8 @@ static int sdio_bus_remove(struct device *dev)
 	int ret = 0;
 
 	/* Make sure card is powered before invoking ->remove() */
-	if (func->card->host->caps & MMC_CAP_POWER_OFF_CARD) {
-		ret = pm_runtime_get_sync(dev);
-		if (ret < 0)
-			goto out;
-	}
+	if (func->card->host->caps & MMC_CAP_POWER_OFF_CARD)
+		pm_runtime_get_sync(dev);
 
 	drv->remove(func);
 
@@ -191,7 +188,6 @@ static int sdio_bus_remove(struct device *dev)
 	if (func->card->host->caps & MMC_CAP_POWER_OFF_CARD)
 		pm_runtime_put_sync(dev);
 
-out:
 	return ret;
 }
 

commit 297c7f2f158f7dfa9ab5813260ff954f9c2f83d2
Author: Ohad Ben-Cohen <ohad@wizery.com>
Date:   Thu Jun 9 23:40:27 2011 +0000

    mmc: sdio: fix runtime PM path during driver removal
    
    After commit e1866b3 "PM / Runtime: Rework runtime PM handling
    during driver removal" was introduced, the driver core stopped
    incrementing the runtime PM usage counter of the device during
    the invocation of the ->remove() callback.
    
    This indirectly broke SDIO's runtime PM path during driver removal,
    because no one calls _put_sync() anymore after ->remove() completes.
    
    This means that the power of runtime-PM-managed SDIO cards is kept
    high after their driver is removed (even if it was powered down
    beforehand).
    
    Fix that by directly calling _put_sync() when the last usage
    counter is downref'ed by the SDIO bus.
    
    Reported-and-tested-by: Daniel Drake <dsd@laptop.org>
    Signed-off-by: Ohad Ben-Cohen <ohad@wizery.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sdio_bus.c b/drivers/mmc/core/sdio_bus.c
index d29b9c36919a..d2565df8a7fb 100644
--- a/drivers/mmc/core/sdio_bus.c
+++ b/drivers/mmc/core/sdio_bus.c
@@ -189,7 +189,7 @@ static int sdio_bus_remove(struct device *dev)
 
 	/* Then undo the runtime PM settings in sdio_bus_probe() */
 	if (func->card->host->caps & MMC_CAP_POWER_OFF_CARD)
-		pm_runtime_put_noidle(dev);
+		pm_runtime_put_sync(dev);
 
 out:
 	return ret;

commit e594573d790bd7e269f05955d316b88f7be0c14a
Author: Ohad Ben-Cohen <ohad@wizery.com>
Date:   Sun Nov 28 07:21:30 2010 +0200

    mmc: sdio: don't power up cards on system suspend
    
    Initial SDIO runtime PM implementation took a conservative approach
    of powering up cards (and fully reinitializing them) on system suspend,
    just before the suspend handlers of the relevant drivers were executed.
    
    To avoid redundant power and reinitialization cycles, this patch removes
    this behavior: if a card is already powered off when system suspend kicks
    in, it is left at that state.
    
    If a card is active when a system sleep starts, everything is
    straightforward and works exactly like before. But if the card was
    already suspended before the sleep began, then when the MMC core powers
    it back up on resume, its run-time PM status has to be updated to reflect
    the actual post-system sleep status.
    
    The technique to do that is borrowed from the I2C runtime PM
    implementation (for more info see Documentation/power/runtime_pm.txt).
    
    Signed-off-by: Ohad Ben-Cohen <ohad@wizery.com>
    Reviewed-by: Chris Ball <cjb@laptop.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sdio_bus.c b/drivers/mmc/core/sdio_bus.c
index 203da443e339..d29b9c36919a 100644
--- a/drivers/mmc/core/sdio_bus.c
+++ b/drivers/mmc/core/sdio_bus.c
@@ -197,44 +197,12 @@ static int sdio_bus_remove(struct device *dev)
 
 #ifdef CONFIG_PM_RUNTIME
 
-static int sdio_bus_pm_prepare(struct device *dev)
-{
-	struct sdio_func *func = dev_to_sdio_func(dev);
-
-	/*
-	 * Resume an SDIO device which was suspended at run time at this
-	 * point, in order to allow standard SDIO suspend/resume paths
-	 * to keep working as usual.
-	 *
-	 * Ultimately, the SDIO driver itself will decide (in its
-	 * suspend handler, or lack thereof) whether the card should be
-	 * removed or kept, and if kept, at what power state.
-	 *
-	 * At this point, PM core have increased our use count, so it's
-	 * safe to directly resume the device. After system is resumed
-	 * again, PM core will drop back its runtime PM use count, and if
-	 * needed device will be suspended again.
-	 *
-	 * The end result is guaranteed to be a power state that is
-	 * coherent with the device's runtime PM use count.
-	 *
-	 * The return value of pm_runtime_resume is deliberately unchecked
-	 * since there is little point in failing system suspend if a
-	 * device can't be resumed.
-	 */
-	if (func->card->host->caps & MMC_CAP_POWER_OFF_CARD)
-		pm_runtime_resume(dev);
-
-	return 0;
-}
-
 static const struct dev_pm_ops sdio_bus_pm_ops = {
 	SET_RUNTIME_PM_OPS(
 		pm_generic_runtime_suspend,
 		pm_generic_runtime_resume,
 		pm_generic_runtime_idle
 	)
-	.prepare = sdio_bus_pm_prepare,
 };
 
 #define SDIO_PM_OPS_PTR	(&sdio_bus_pm_ops)

commit ed919b0125b26dcc052e44836f66e7e1f5c49c7e
Author: Ohad Ben-Cohen <ohad@wizery.com>
Date:   Fri Nov 19 09:29:09 2010 +0200

    mmc: sdio: fix runtime PM anomalies by introducing MMC_CAP_POWER_OFF_CARD
    
    Some board/card/host configurations are not capable of powering off the
    card after boot.
    
    To support such configurations, and to allow smoother transition to
    runtime PM behavior, MMC_CAP_POWER_OFF_CARD is added, so hosts need to
    explicitly indicate whether it's OK to power off their cards after boot.
    
    SDIO core will enable runtime PM for a card only if that cap is set.
    As a result, the card will be powered down after boot, and will only
    be powered up again when a driver is loaded (and then it's up to the
    driver to decide whether power will be kept or not).
    
    This will prevent sdio_bus_probe() failures with setups that do not
    support powering off the card.
    
    Reported-and-tested-by: Daniel Drake <dsd@laptop.org>
    Reported-and-tested-by: Arnd Hannemann <arnd@arndnet.de>
    Signed-off-by: Ohad Ben-Cohen <ohad@wizery.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sdio_bus.c b/drivers/mmc/core/sdio_bus.c
index 2716c7ab6bbf..203da443e339 100644
--- a/drivers/mmc/core/sdio_bus.c
+++ b/drivers/mmc/core/sdio_bus.c
@@ -17,6 +17,7 @@
 #include <linux/pm_runtime.h>
 
 #include <linux/mmc/card.h>
+#include <linux/mmc/host.h>
 #include <linux/mmc/sdio_func.h>
 
 #include "sdio_cis.h"
@@ -132,9 +133,11 @@ static int sdio_bus_probe(struct device *dev)
 	 * it should call pm_runtime_put_noidle() in its probe routine and
 	 * pm_runtime_get_noresume() in its remove routine.
 	 */
-	ret = pm_runtime_get_sync(dev);
-	if (ret < 0)
-		goto out;
+	if (func->card->host->caps & MMC_CAP_POWER_OFF_CARD) {
+		ret = pm_runtime_get_sync(dev);
+		if (ret < 0)
+			goto out;
+	}
 
 	/* Set the default block size so the driver is sure it's something
 	 * sensible. */
@@ -151,7 +154,8 @@ static int sdio_bus_probe(struct device *dev)
 	return 0;
 
 disable_runtimepm:
-	pm_runtime_put_noidle(dev);
+	if (func->card->host->caps & MMC_CAP_POWER_OFF_CARD)
+		pm_runtime_put_noidle(dev);
 out:
 	return ret;
 }
@@ -160,12 +164,14 @@ static int sdio_bus_remove(struct device *dev)
 {
 	struct sdio_driver *drv = to_sdio_driver(dev->driver);
 	struct sdio_func *func = dev_to_sdio_func(dev);
-	int ret;
+	int ret = 0;
 
 	/* Make sure card is powered before invoking ->remove() */
-	ret = pm_runtime_get_sync(dev);
-	if (ret < 0)
-		goto out;
+	if (func->card->host->caps & MMC_CAP_POWER_OFF_CARD) {
+		ret = pm_runtime_get_sync(dev);
+		if (ret < 0)
+			goto out;
+	}
 
 	drv->remove(func);
 
@@ -178,10 +184,12 @@ static int sdio_bus_remove(struct device *dev)
 	}
 
 	/* First, undo the increment made directly above */
-	pm_runtime_put_noidle(dev);
+	if (func->card->host->caps & MMC_CAP_POWER_OFF_CARD)
+		pm_runtime_put_noidle(dev);
 
 	/* Then undo the runtime PM settings in sdio_bus_probe() */
-	pm_runtime_put_noidle(dev);
+	if (func->card->host->caps & MMC_CAP_POWER_OFF_CARD)
+		pm_runtime_put_noidle(dev);
 
 out:
 	return ret;
@@ -191,6 +199,8 @@ static int sdio_bus_remove(struct device *dev)
 
 static int sdio_bus_pm_prepare(struct device *dev)
 {
+	struct sdio_func *func = dev_to_sdio_func(dev);
+
 	/*
 	 * Resume an SDIO device which was suspended at run time at this
 	 * point, in order to allow standard SDIO suspend/resume paths
@@ -212,7 +222,8 @@ static int sdio_bus_pm_prepare(struct device *dev)
 	 * since there is little point in failing system suspend if a
 	 * device can't be resumed.
 	 */
-	pm_runtime_resume(dev);
+	if (func->card->host->caps & MMC_CAP_POWER_OFF_CARD)
+		pm_runtime_resume(dev);
 
 	return 0;
 }

commit ed2a9785942b0986ac858f3f48d7fc5f7c7183de
Author: Ohad Ben-Cohen <ohad@wizery.com>
Date:   Sat Oct 2 13:54:13 2010 +0200

    mmc: sdio: support suspend/resume while runtime suspended
    
    Bring SDIO devices back to full power before their suspend
    handler is invoked.
    
    Doing so ensures that SDIO suspend/resume semantics are
    maintained (drivers still get to decide whether their
    card should be removed or kept during system suspend,
    and at what power state), and that SDIO suspend/resume
    execution paths are unchanged.
    
    This is achieved by resuming a runtime-suspended SDIO device
    in its ->prepare() PM callback (similary to the PCI subsystem).
    
    Since the PM core always increments the run-time usage
    counter before calling the ->prepare() callback and decrements
    it after calling the ->complete() callback, it is guaranteed
    that when the system will come out of suspend, our device's
    power state will reflect its runtime PM usage counter.
    
    Signed-off-by: Ohad Ben-Cohen <ohad@wizery.com>
    Tested-by: Luciano Coelho <luciano.coelho@nokia.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sdio_bus.c b/drivers/mmc/core/sdio_bus.c
index 36374834fcff..2716c7ab6bbf 100644
--- a/drivers/mmc/core/sdio_bus.c
+++ b/drivers/mmc/core/sdio_bus.c
@@ -189,12 +189,41 @@ static int sdio_bus_remove(struct device *dev)
 
 #ifdef CONFIG_PM_RUNTIME
 
+static int sdio_bus_pm_prepare(struct device *dev)
+{
+	/*
+	 * Resume an SDIO device which was suspended at run time at this
+	 * point, in order to allow standard SDIO suspend/resume paths
+	 * to keep working as usual.
+	 *
+	 * Ultimately, the SDIO driver itself will decide (in its
+	 * suspend handler, or lack thereof) whether the card should be
+	 * removed or kept, and if kept, at what power state.
+	 *
+	 * At this point, PM core have increased our use count, so it's
+	 * safe to directly resume the device. After system is resumed
+	 * again, PM core will drop back its runtime PM use count, and if
+	 * needed device will be suspended again.
+	 *
+	 * The end result is guaranteed to be a power state that is
+	 * coherent with the device's runtime PM use count.
+	 *
+	 * The return value of pm_runtime_resume is deliberately unchecked
+	 * since there is little point in failing system suspend if a
+	 * device can't be resumed.
+	 */
+	pm_runtime_resume(dev);
+
+	return 0;
+}
+
 static const struct dev_pm_ops sdio_bus_pm_ops = {
 	SET_RUNTIME_PM_OPS(
 		pm_generic_runtime_suspend,
 		pm_generic_runtime_resume,
 		pm_generic_runtime_idle
 	)
+	.prepare = sdio_bus_pm_prepare,
 };
 
 #define SDIO_PM_OPS_PTR	(&sdio_bus_pm_ops)

commit 40bba0c1ca83a370f749c8bc9afda71cf79ebd91
Author: Ohad Ben-Cohen <ohad@wizery.com>
Date:   Sat Oct 2 13:54:11 2010 +0200

    mmc: sdio: enable runtime PM for SDIO functions
    
    Enable runtime PM for SDIO functions.
    
    SDIO functions are initialized with a disabled runtime PM state,
    and are set active (and their usage count is incremented)
    only before potential drivers are probed.
    
    SDIO function drivers that support runtime PM should call
    pm_runtime_put_noidle() in their probe routine, and
    pm_runtime_get_noresume() in their remove routine (very
    similarly to PCI drivers).
    
    In case a matching driver does not support runtime PM, power will
    always be kept high (since the usage count is positive).
    
    Signed-off-by: Ohad Ben-Cohen <ohad@wizery.com>
    Tested-by: Luciano Coelho <luciano.coelho@nokia.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sdio_bus.c b/drivers/mmc/core/sdio_bus.c
index 256a968774a0..36374834fcff 100644
--- a/drivers/mmc/core/sdio_bus.c
+++ b/drivers/mmc/core/sdio_bus.c
@@ -126,21 +126,46 @@ static int sdio_bus_probe(struct device *dev)
 	if (!id)
 		return -ENODEV;
 
+	/* Unbound SDIO functions are always suspended.
+	 * During probe, the function is set active and the usage count
+	 * is incremented.  If the driver supports runtime PM,
+	 * it should call pm_runtime_put_noidle() in its probe routine and
+	 * pm_runtime_get_noresume() in its remove routine.
+	 */
+	ret = pm_runtime_get_sync(dev);
+	if (ret < 0)
+		goto out;
+
 	/* Set the default block size so the driver is sure it's something
 	 * sensible. */
 	sdio_claim_host(func);
 	ret = sdio_set_block_size(func, 0);
 	sdio_release_host(func);
 	if (ret)
-		return ret;
+		goto disable_runtimepm;
+
+	ret = drv->probe(func, id);
+	if (ret)
+		goto disable_runtimepm;
 
-	return drv->probe(func, id);
+	return 0;
+
+disable_runtimepm:
+	pm_runtime_put_noidle(dev);
+out:
+	return ret;
 }
 
 static int sdio_bus_remove(struct device *dev)
 {
 	struct sdio_driver *drv = to_sdio_driver(dev->driver);
 	struct sdio_func *func = dev_to_sdio_func(dev);
+	int ret;
+
+	/* Make sure card is powered before invoking ->remove() */
+	ret = pm_runtime_get_sync(dev);
+	if (ret < 0)
+		goto out;
 
 	drv->remove(func);
 
@@ -152,7 +177,14 @@ static int sdio_bus_remove(struct device *dev)
 		sdio_release_host(func);
 	}
 
-	return 0;
+	/* First, undo the increment made directly above */
+	pm_runtime_put_noidle(dev);
+
+	/* Then undo the runtime PM settings in sdio_bus_probe() */
+	pm_runtime_put_noidle(dev);
+
+out:
+	return ret;
 }
 
 #ifdef CONFIG_PM_RUNTIME

commit 80fd933c44557c5261b80f8f8145b4fe071aeaf3
Author: Ohad Ben-Cohen <ohad@wizery.com>
Date:   Sat Oct 2 13:54:09 2010 +0200

    mmc: sdio: use the generic runtime PM handlers
    
    Assign the generic runtime PM handlers for SDIO.
    
    These handlers invoke the relevant SDIO function drivers'
    handlers, if exist, otherwise they just return success
    (so SDIO drivers don't have to define any runtime PM handlers
    unless they need to).
    
    Runtime PM is still disabled by default, so this patch alone
    has no immediate effect.
    
    Signed-off-by: Ohad Ben-Cohen <ohad@wizery.com>
    Tested-by: Luciano Coelho <luciano.coelho@nokia.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sdio_bus.c b/drivers/mmc/core/sdio_bus.c
index 4a890dcb95ab..256a968774a0 100644
--- a/drivers/mmc/core/sdio_bus.c
+++ b/drivers/mmc/core/sdio_bus.c
@@ -14,6 +14,7 @@
 #include <linux/device.h>
 #include <linux/err.h>
 #include <linux/slab.h>
+#include <linux/pm_runtime.h>
 
 #include <linux/mmc/card.h>
 #include <linux/mmc/sdio_func.h>
@@ -154,6 +155,24 @@ static int sdio_bus_remove(struct device *dev)
 	return 0;
 }
 
+#ifdef CONFIG_PM_RUNTIME
+
+static const struct dev_pm_ops sdio_bus_pm_ops = {
+	SET_RUNTIME_PM_OPS(
+		pm_generic_runtime_suspend,
+		pm_generic_runtime_resume,
+		pm_generic_runtime_idle
+	)
+};
+
+#define SDIO_PM_OPS_PTR	(&sdio_bus_pm_ops)
+
+#else /* !CONFIG_PM_RUNTIME */
+
+#define SDIO_PM_OPS_PTR	NULL
+
+#endif /* !CONFIG_PM_RUNTIME */
+
 static struct bus_type sdio_bus_type = {
 	.name		= "sdio",
 	.dev_attrs	= sdio_dev_attrs,
@@ -161,6 +180,7 @@ static struct bus_type sdio_bus_type = {
 	.uevent		= sdio_bus_uevent,
 	.probe		= sdio_bus_probe,
 	.remove		= sdio_bus_remove,
+	.pm		= SDIO_PM_OPS_PTR,
 };
 
 int sdio_register_bus(void)

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/mmc/core/sdio_bus.c b/drivers/mmc/core/sdio_bus.c
index 9e060c87e64d..4a890dcb95ab 100644
--- a/drivers/mmc/core/sdio_bus.c
+++ b/drivers/mmc/core/sdio_bus.c
@@ -13,6 +13,7 @@
 
 #include <linux/device.h>
 #include <linux/err.h>
+#include <linux/slab.h>
 
 #include <linux/mmc/card.h>
 #include <linux/mmc/sdio_func.h>

commit 3d10a1ba0d37c8f5fd5afcdda00613fbb8a90bf5
Author: Daniel Drake <dsd@laptop.org>
Date:   Thu Dec 17 15:27:17 2009 -0800

    sdio: fix reference counting in sdio_remove_func()
    
    sdio_remove_func() needs to be more careful about reference counting.  It
    can be called in error paths where sdio_add_func() has never been called
    e.g.  mmc_attach_sdio error path --> mmc_sdio_remove --> sdio_remove_func
    
    Signed-off-by: Daniel Drake <dsd@laptop.org>
    Reviewed-by: Matt Fleming <matt@console-pimps.org>
    Cc: <linux-mmc@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/mmc/core/sdio_bus.c b/drivers/mmc/core/sdio_bus.c
index d37464e296a5..9e060c87e64d 100644
--- a/drivers/mmc/core/sdio_bus.c
+++ b/drivers/mmc/core/sdio_bus.c
@@ -248,12 +248,15 @@ int sdio_add_func(struct sdio_func *func)
 /*
  * Unregister a SDIO function with the driver model, and
  * (eventually) free it.
+ * This function can be called through error paths where sdio_add_func() was
+ * never executed (because a failure occurred at an earlier point).
  */
 void sdio_remove_func(struct sdio_func *func)
 {
-	if (sdio_func_present(func))
-		device_del(&func->dev);
+	if (!sdio_func_present(func))
+		return;
 
+	device_del(&func->dev);
 	put_device(&func->dev);
 }
 

commit 996ad5686c5f868e67557cc1bfcb2cfdde1a18b4
Author: Nicolas Pitre <nico@fluxnic.net>
Date:   Tue Sep 22 16:45:30 2009 -0700

    mmc: make SDIO device/driver struct accessors public
    
    Especially with the PM framework, those are quite handy to have in driver
    code too.
    
    Signed-off-by: Nicolas Pitre <nico@marvell.com>
    Cc: <linux-mmc@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/mmc/core/sdio_bus.c b/drivers/mmc/core/sdio_bus.c
index 46284b527397..d37464e296a5 100644
--- a/drivers/mmc/core/sdio_bus.c
+++ b/drivers/mmc/core/sdio_bus.c
@@ -20,9 +20,6 @@
 #include "sdio_cis.h"
 #include "sdio_bus.h"
 
-#define dev_to_sdio_func(d)	container_of(d, struct sdio_func, dev)
-#define to_sdio_driver(d)      container_of(d, struct sdio_driver, drv)
-
 /* show configuration fields */
 #define sdio_config_attr(field, format_string)				\
 static ssize_t								\

commit d1b268630875a7713b5d468a0c03403c5b721c8e
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Sat Nov 8 21:37:46 2008 +0100

    mmc: struct device - replace bus_id with dev_name(), dev_set_name()
    
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-Off-By: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/sdio_bus.c b/drivers/mmc/core/sdio_bus.c
index 233d0f9b3c4b..46284b527397 100644
--- a/drivers/mmc/core/sdio_bus.c
+++ b/drivers/mmc/core/sdio_bus.c
@@ -239,8 +239,7 @@ int sdio_add_func(struct sdio_func *func)
 {
 	int ret;
 
-	snprintf(func->dev.bus_id, sizeof(func->dev.bus_id),
-		 "%s:%d", mmc_card_id(func->card), func->num);
+	dev_set_name(&func->dev, "%s:%d", mmc_card_id(func->card), func->num);
 
 	ret = device_add(&func->dev);
 	if (ret == 0)

commit 7ac0326c3fd3f7cd2426dbbce896a0f8c91b962f
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Sun Oct 14 05:46:09 2007 +0100

    uevent environment changes fallout
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/mmc/core/sdio_bus.c b/drivers/mmc/core/sdio_bus.c
index 0713a8c71e54..233d0f9b3c4b 100644
--- a/drivers/mmc/core/sdio_bus.c
+++ b/drivers/mmc/core/sdio_bus.c
@@ -96,30 +96,23 @@ static int sdio_bus_match(struct device *dev, struct device_driver *drv)
 }
 
 static int
-sdio_bus_uevent(struct device *dev, char **envp, int num_envp, char *buf,
-		int buf_size)
+sdio_bus_uevent(struct device *dev, struct kobj_uevent_env *env)
 {
 	struct sdio_func *func = dev_to_sdio_func(dev);
-	int i = 0, length = 0;
 
-	if (add_uevent_var(envp, num_envp, &i,
-			buf, buf_size, &length,
+	if (add_uevent_var(env,
 			"SDIO_CLASS=%02X", func->class))
 		return -ENOMEM;
 
-	if (add_uevent_var(envp, num_envp, &i,
-			buf, buf_size, &length,
+	if (add_uevent_var(env, 
 			"SDIO_ID=%04X:%04X", func->vendor, func->device))
 		return -ENOMEM;
 
-	if (add_uevent_var(envp, num_envp, &i,
-			buf, buf_size, &length,
+	if (add_uevent_var(env,
 			"MODALIAS=sdio:c%02Xv%04Xd%04X",
 			func->class, func->vendor, func->device))
 		return -ENOMEM;
 
-	envp[i] = NULL;
-
 	return 0;
 }
 

commit 759bdc7af450404382e937c76722ae8736daef92
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Wed Sep 19 18:42:16 2007 +0200

    sdio: store vendor strings
    
    Store vendor strings found in CISTPL_VERS_1 so that function drivers
    can access them.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/sdio_bus.c b/drivers/mmc/core/sdio_bus.c
index 683d91740109..0713a8c71e54 100644
--- a/drivers/mmc/core/sdio_bus.c
+++ b/drivers/mmc/core/sdio_bus.c
@@ -211,6 +211,9 @@ static void sdio_release_func(struct device *dev)
 
 	sdio_free_func_cis(func);
 
+	if (func->info)
+		kfree(func->info);
+
 	kfree(func);
 }
 

commit 9f2fcf99394b34769e3243a7f42a0ba8d21fc774
Author: Mariusz Kozlowski <m.kozlowski@tuxland.pl>
Date:   Wed Aug 1 00:05:24 2007 +0200

    sdio: kmalloc + memset conversion to kzalloc
    
    Signed-off-by: Mariusz Kozlowski <m.kozlowski@tuxland.pl>
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/sdio_bus.c b/drivers/mmc/core/sdio_bus.c
index fcb13fb0daad..683d91740109 100644
--- a/drivers/mmc/core/sdio_bus.c
+++ b/drivers/mmc/core/sdio_bus.c
@@ -221,12 +221,10 @@ struct sdio_func *sdio_alloc_func(struct mmc_card *card)
 {
 	struct sdio_func *func;
 
-	func = kmalloc(sizeof(struct sdio_func), GFP_KERNEL);
+	func = kzalloc(sizeof(struct sdio_func), GFP_KERNEL);
 	if (!func)
 		return ERR_PTR(-ENOMEM);
 
-	memset(func, 0, sizeof(struct sdio_func));
-
 	func->card = card;
 
 	device_initialize(&func->dev);

commit 9a08f82b3cc522f727ace580a2aaee5402435bc8
Author: David Vrabel <david.vrabel@csr.com>
Date:   Wed Aug 8 14:23:48 2007 +0100

    sdio: set the functions' block size
    
    Before a driver is probed, set the function's block size to the default so the
    driver is sure the block size is something sensible and it needn't explicitly
    set it.
    
    The default block size is the largest that's supported by both the card and
    the host, with a maximum of 512 to ensure aribitrarily sized transfer use the
    optimal (least) number of commands.
    
    See http://lkml.org/lkml/2007/8/7/150 for reasons for the block size choice.
    
    Signed-off-by: David Vrabel <david.vrabel@csr.com>
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/sdio_bus.c b/drivers/mmc/core/sdio_bus.c
index d229020db4a2..fcb13fb0daad 100644
--- a/drivers/mmc/core/sdio_bus.c
+++ b/drivers/mmc/core/sdio_bus.c
@@ -128,11 +128,20 @@ static int sdio_bus_probe(struct device *dev)
 	struct sdio_driver *drv = to_sdio_driver(dev->driver);
 	struct sdio_func *func = dev_to_sdio_func(dev);
 	const struct sdio_device_id *id;
+	int ret;
 
 	id = sdio_match_device(func, drv);
 	if (!id)
 		return -ENODEV;
 
+	/* Set the default block size so the driver is sure it's something
+	 * sensible. */
+	sdio_claim_host(func);
+	ret = sdio_set_block_size(func, 0);
+	sdio_release_host(func);
+	if (ret)
+		return ret;
+
 	return drv->probe(func, id);
 }
 

commit 22bfc979d38f57d5b10d141990175d8fc47f6775
Author: Adrian Bunk <bunk@stusta.de>
Date:   Sun Jul 29 16:58:09 2007 +0200

    make struct sdio_dev_attrs[] static
    
    On Wed, Jul 25, 2007 at 04:03:04AM -0700, Andrew Morton wrote:
    >...
    > Changes since 2.6.22-rc6-mm1:
    >...
    >  git-mmc.patch
    >...
    >  git trees
    >...
    
    sdio_dev_attrs[] can become static.
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/sdio_bus.c b/drivers/mmc/core/sdio_bus.c
index 240724454914..d229020db4a2 100644
--- a/drivers/mmc/core/sdio_bus.c
+++ b/drivers/mmc/core/sdio_bus.c
@@ -46,7 +46,7 @@ static ssize_t modalias_show(struct device *dev, struct device_attribute *attr,
 			func->class, func->vendor, func->device);
 }
 
-struct device_attribute sdio_dev_attrs[] = {
+static struct device_attribute sdio_dev_attrs[] = {
 	__ATTR_RO(class),
 	__ATTR_RO(vendor),
 	__ATTR_RO(device),

commit d1496c39e500857b8949cdb91af24e0eb8aae4d0
Author: Nicolas Pitre <nico@cam.org>
Date:   Sat Jun 30 16:29:41 2007 +0200

    sdio: core support for SDIO function interrupt
    
    Signed-off-by: Nicolas Pitre <npitre@mvista.com>
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/sdio_bus.c b/drivers/mmc/core/sdio_bus.c
index 129f0719c391..240724454914 100644
--- a/drivers/mmc/core/sdio_bus.c
+++ b/drivers/mmc/core/sdio_bus.c
@@ -143,6 +143,14 @@ static int sdio_bus_remove(struct device *dev)
 
 	drv->remove(func);
 
+	if (func->irq_handler) {
+		printk(KERN_WARNING "WARNING: driver %s did not remove "
+			"its interrupt handler!\n", drv->name);
+		sdio_claim_host(func);
+		sdio_release_irq(func);
+		sdio_release_host(func);
+	}
+
 	return 0;
 }
 

commit bcfe66e21ef78a078bb0de0bab532701996695d3
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Sun Jun 17 11:42:21 2007 +0200

    sdio: add basic sysfs attributes
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/sdio_bus.c b/drivers/mmc/core/sdio_bus.c
index c834f5150888..129f0719c391 100644
--- a/drivers/mmc/core/sdio_bus.c
+++ b/drivers/mmc/core/sdio_bus.c
@@ -23,6 +23,37 @@
 #define dev_to_sdio_func(d)	container_of(d, struct sdio_func, dev)
 #define to_sdio_driver(d)      container_of(d, struct sdio_driver, drv)
 
+/* show configuration fields */
+#define sdio_config_attr(field, format_string)				\
+static ssize_t								\
+field##_show(struct device *dev, struct device_attribute *attr, char *buf)				\
+{									\
+	struct sdio_func *func;						\
+									\
+	func = dev_to_sdio_func (dev);					\
+	return sprintf (buf, format_string, func->field);		\
+}
+
+sdio_config_attr(class, "0x%02x\n");
+sdio_config_attr(vendor, "0x%04x\n");
+sdio_config_attr(device, "0x%04x\n");
+
+static ssize_t modalias_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct sdio_func *func = dev_to_sdio_func (dev);
+
+	return sprintf(buf, "sdio:c%02Xv%04Xd%04X\n",
+			func->class, func->vendor, func->device);
+}
+
+struct device_attribute sdio_dev_attrs[] = {
+	__ATTR_RO(class),
+	__ATTR_RO(vendor),
+	__ATTR_RO(device),
+	__ATTR_RO(modalias),
+	__ATTR_NULL,
+};
+
 static const struct sdio_device_id *sdio_match_one(struct sdio_func *func,
 	const struct sdio_device_id *id)
 {
@@ -117,6 +148,7 @@ static int sdio_bus_remove(struct device *dev)
 
 static struct bus_type sdio_bus_type = {
 	.name		= "sdio",
+	.dev_attrs	= sdio_dev_attrs,
 	.match		= sdio_bus_match,
 	.uevent		= sdio_bus_uevent,
 	.probe		= sdio_bus_probe,

commit d59b66c7a575cfa8e01f483875d131e42b539bbc
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Sun Jun 17 11:34:23 2007 +0200

    sdio: add modalias support
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/sdio_bus.c b/drivers/mmc/core/sdio_bus.c
index a3a89e973d94..c834f5150888 100644
--- a/drivers/mmc/core/sdio_bus.c
+++ b/drivers/mmc/core/sdio_bus.c
@@ -68,7 +68,26 @@ static int
 sdio_bus_uevent(struct device *dev, char **envp, int num_envp, char *buf,
 		int buf_size)
 {
-	envp[0] = NULL;
+	struct sdio_func *func = dev_to_sdio_func(dev);
+	int i = 0, length = 0;
+
+	if (add_uevent_var(envp, num_envp, &i,
+			buf, buf_size, &length,
+			"SDIO_CLASS=%02X", func->class))
+		return -ENOMEM;
+
+	if (add_uevent_var(envp, num_envp, &i,
+			buf, buf_size, &length,
+			"SDIO_ID=%04X:%04X", func->vendor, func->device))
+		return -ENOMEM;
+
+	if (add_uevent_var(envp, num_envp, &i,
+			buf, buf_size, &length,
+			"MODALIAS=sdio:c%02Xv%04Xd%04X",
+			func->class, func->vendor, func->device))
+		return -ENOMEM;
+
+	envp[i] = NULL;
 
 	return 0;
 }

commit 3b38bea0d976513970f947806b08b9faca418e7a
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Sat Jun 16 15:54:55 2007 +0200

    sdio: add device id table and matching
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/sdio_bus.c b/drivers/mmc/core/sdio_bus.c
index 461fe4837a9f..a3a89e973d94 100644
--- a/drivers/mmc/core/sdio_bus.c
+++ b/drivers/mmc/core/sdio_bus.c
@@ -21,14 +21,47 @@
 #include "sdio_bus.h"
 
 #define dev_to_sdio_func(d)	container_of(d, struct sdio_func, dev)
+#define to_sdio_driver(d)      container_of(d, struct sdio_driver, drv)
+
+static const struct sdio_device_id *sdio_match_one(struct sdio_func *func,
+	const struct sdio_device_id *id)
+{
+	if (id->class != (__u8)SDIO_ANY_ID && id->class != func->class)
+		return NULL;
+	if (id->vendor != (__u16)SDIO_ANY_ID && id->vendor != func->vendor)
+		return NULL;
+	if (id->device != (__u16)SDIO_ANY_ID && id->device != func->device)
+		return NULL;
+	return id;
+}
+
+static const struct sdio_device_id *sdio_match_device(struct sdio_func *func,
+	struct sdio_driver *sdrv)
+{
+	const struct sdio_device_id *ids;
+
+	ids = sdrv->id_table;
+
+	if (ids) {
+		while (ids->class || ids->vendor || ids->device) {
+			if (sdio_match_one(func, ids))
+				return ids;
+			ids++;
+		}
+	}
+
+	return NULL;
+}
 
-/*
- * This currently matches any SDIO function to any driver in order
- * to help initial development and testing.
- */
 static int sdio_bus_match(struct device *dev, struct device_driver *drv)
 {
-	return 1;
+	struct sdio_func *func = dev_to_sdio_func(dev);
+	struct sdio_driver *sdrv = to_sdio_driver(drv);
+
+	if (sdio_match_device(func, sdrv))
+		return 1;
+
+	return 0;
 }
 
 static int
@@ -42,11 +75,24 @@ sdio_bus_uevent(struct device *dev, char **envp, int num_envp, char *buf,
 
 static int sdio_bus_probe(struct device *dev)
 {
-	return -ENODEV;
+	struct sdio_driver *drv = to_sdio_driver(dev->driver);
+	struct sdio_func *func = dev_to_sdio_func(dev);
+	const struct sdio_device_id *id;
+
+	id = sdio_match_device(func, drv);
+	if (!id)
+		return -ENODEV;
+
+	return drv->probe(func, id);
 }
 
 static int sdio_bus_remove(struct device *dev)
 {
+	struct sdio_driver *drv = to_sdio_driver(dev->driver);
+	struct sdio_func *func = dev_to_sdio_func(dev);
+
+	drv->remove(func);
+
 	return 0;
 }
 

commit 1a632f8cdc33e7f8edca352164f0c96a75d08f08
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Mon Jul 30 15:15:30 2007 +0200

    sdio: split up common and function CIS parsing
    
    Add a more clean separation between global, common CIS information
    and the function specific one as we need the common information in
    places where no specific function is specified.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/sdio_bus.c b/drivers/mmc/core/sdio_bus.c
index 78e0381f55ac..461fe4837a9f 100644
--- a/drivers/mmc/core/sdio_bus.c
+++ b/drivers/mmc/core/sdio_bus.c
@@ -95,7 +95,7 @@ static void sdio_release_func(struct device *dev)
 {
 	struct sdio_func *func = dev_to_sdio_func(dev);
 
-	sdio_free_cis(func);
+	sdio_free_func_cis(func);
 
 	kfree(func);
 }

commit b1538bcf75e2e11459947ec4d4329ed04fbe2b2c
Author: Nicolas Pitre <nico@cam.org>
Date:   Sat Jun 16 02:06:47 2007 -0400

    sdio: link unknown CIS tuples to the sdio_func structure
    
    This way those tuples that the core cares about are consumed by the core
    code, and tuples that only function drivers might make sense of are
    available to drivers.
    
    Signed-off-by: Nicolas Pitre <npitre@mvista.com>
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/sdio_bus.c b/drivers/mmc/core/sdio_bus.c
index fa488cea8594..78e0381f55ac 100644
--- a/drivers/mmc/core/sdio_bus.c
+++ b/drivers/mmc/core/sdio_bus.c
@@ -17,6 +17,7 @@
 #include <linux/mmc/card.h>
 #include <linux/mmc/sdio_func.h>
 
+#include "sdio_cis.h"
 #include "sdio_bus.h"
 
 #define dev_to_sdio_func(d)	container_of(d, struct sdio_func, dev)
@@ -94,6 +95,8 @@ static void sdio_release_func(struct device *dev)
 {
 	struct sdio_func *func = dev_to_sdio_func(dev);
 
+	sdio_free_cis(func);
+
 	kfree(func);
 }
 

commit f76c85154d320497bf1a939a98d6c432edcbd4a9
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Sun May 27 12:00:02 2007 +0200

    mmc: add SDIO driver handling
    
    Add basic driver handling to the SDIO device model.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/sdio_bus.c b/drivers/mmc/core/sdio_bus.c
index 59c909e1c7c6..fa488cea8594 100644
--- a/drivers/mmc/core/sdio_bus.c
+++ b/drivers/mmc/core/sdio_bus.c
@@ -67,6 +67,29 @@ void sdio_unregister_bus(void)
 	bus_unregister(&sdio_bus_type);
 }
 
+/**
+ *	sdio_register_driver - register a function driver
+ *	@drv: SDIO function driver
+ */
+int sdio_register_driver(struct sdio_driver *drv)
+{
+	drv->drv.name = drv->name;
+	drv->drv.bus = &sdio_bus_type;
+	return driver_register(&drv->drv);
+}
+EXPORT_SYMBOL_GPL(sdio_register_driver);
+
+/**
+ *	sdio_unregister_driver - unregister a function driver
+ *	@drv: SDIO function driver
+ */
+void sdio_unregister_driver(struct sdio_driver *drv)
+{
+	drv->drv.bus = &sdio_bus_type;
+	driver_unregister(&drv->drv);
+}
+EXPORT_SYMBOL_GPL(sdio_unregister_driver);
+
 static void sdio_release_func(struct device *dev)
 {
 	struct sdio_func *func = dev_to_sdio_func(dev);

commit e29a7d73f4277eb92aa64e17017dea33460828ef
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Sat May 26 13:48:18 2007 +0200

    mmc: basic SDIO device model
    
    Add the sdio bus type and basic device handling.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/sdio_bus.c b/drivers/mmc/core/sdio_bus.c
new file mode 100644
index 000000000000..59c909e1c7c6
--- /dev/null
+++ b/drivers/mmc/core/sdio_bus.c
@@ -0,0 +1,129 @@
+/*
+ *  linux/drivers/mmc/core/sdio_bus.c
+ *
+ *  Copyright 2007 Pierre Ossman
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at
+ * your option) any later version.
+ *
+ * SDIO function driver model
+ */
+
+#include <linux/device.h>
+#include <linux/err.h>
+
+#include <linux/mmc/card.h>
+#include <linux/mmc/sdio_func.h>
+
+#include "sdio_bus.h"
+
+#define dev_to_sdio_func(d)	container_of(d, struct sdio_func, dev)
+
+/*
+ * This currently matches any SDIO function to any driver in order
+ * to help initial development and testing.
+ */
+static int sdio_bus_match(struct device *dev, struct device_driver *drv)
+{
+	return 1;
+}
+
+static int
+sdio_bus_uevent(struct device *dev, char **envp, int num_envp, char *buf,
+		int buf_size)
+{
+	envp[0] = NULL;
+
+	return 0;
+}
+
+static int sdio_bus_probe(struct device *dev)
+{
+	return -ENODEV;
+}
+
+static int sdio_bus_remove(struct device *dev)
+{
+	return 0;
+}
+
+static struct bus_type sdio_bus_type = {
+	.name		= "sdio",
+	.match		= sdio_bus_match,
+	.uevent		= sdio_bus_uevent,
+	.probe		= sdio_bus_probe,
+	.remove		= sdio_bus_remove,
+};
+
+int sdio_register_bus(void)
+{
+	return bus_register(&sdio_bus_type);
+}
+
+void sdio_unregister_bus(void)
+{
+	bus_unregister(&sdio_bus_type);
+}
+
+static void sdio_release_func(struct device *dev)
+{
+	struct sdio_func *func = dev_to_sdio_func(dev);
+
+	kfree(func);
+}
+
+/*
+ * Allocate and initialise a new SDIO function structure.
+ */
+struct sdio_func *sdio_alloc_func(struct mmc_card *card)
+{
+	struct sdio_func *func;
+
+	func = kmalloc(sizeof(struct sdio_func), GFP_KERNEL);
+	if (!func)
+		return ERR_PTR(-ENOMEM);
+
+	memset(func, 0, sizeof(struct sdio_func));
+
+	func->card = card;
+
+	device_initialize(&func->dev);
+
+	func->dev.parent = &card->dev;
+	func->dev.bus = &sdio_bus_type;
+	func->dev.release = sdio_release_func;
+
+	return func;
+}
+
+/*
+ * Register a new SDIO function with the driver model.
+ */
+int sdio_add_func(struct sdio_func *func)
+{
+	int ret;
+
+	snprintf(func->dev.bus_id, sizeof(func->dev.bus_id),
+		 "%s:%d", mmc_card_id(func->card), func->num);
+
+	ret = device_add(&func->dev);
+	if (ret == 0)
+		sdio_func_set_present(func);
+
+	return ret;
+}
+
+/*
+ * Unregister a SDIO function with the driver model, and
+ * (eventually) free it.
+ */
+void sdio_remove_func(struct sdio_func *func)
+{
+	if (sdio_func_present(func))
+		device_del(&func->dev);
+
+	put_device(&func->dev);
+}
+
