commit 94fe2580a2f3bb055fdca86a2adf156d01f15764
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri May 8 13:28:53 2020 +0200

    mmc: core: Enable erase/discard/trim support for all mmc hosts
    
    Step by step, mmc host drivers and the mmc core have been improved in
    regards to support erase/discard/trim operations. We have now reached a
    point when it no longer seems reasonable to use an opt-in approach to
    enable the functionality. Therefore, let's switch to make the operations
    always supported.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Link: https://lore.kernel.org/r/20200508112853.23525-1-ulf.hansson@linaro.org
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 4c5de6d37ac7..8d2b808e9b58 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1815,8 +1815,7 @@ int mmc_erase(struct mmc_card *card, unsigned int from, unsigned int nr,
 	unsigned int rem, to = from + nr;
 	int err;
 
-	if (!(card->host->caps & MMC_CAP_ERASE) ||
-	    !(card->csd.cmdclass & CCC_ERASE))
+	if (!(card->csd.cmdclass & CCC_ERASE))
 		return -EOPNOTSUPP;
 
 	if (!card->erase_size)
@@ -1872,8 +1871,7 @@ EXPORT_SYMBOL(mmc_erase);
 
 int mmc_can_erase(struct mmc_card *card)
 {
-	if ((card->host->caps & MMC_CAP_ERASE) &&
-	    (card->csd.cmdclass & CCC_ERASE) && card->erase_size)
+	if (card->csd.cmdclass & CCC_ERASE && card->erase_size)
 		return 1;
 	return 0;
 }

commit 55c2b8b9a383487f4f083f62d163fe3278fece1a
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Mon Mar 16 16:21:52 2020 +0100

    mmc: core: Re-work the code for eMMC sanitize
    
    The error path for sanitize operations that completes with -ETIMEDOUT, is
    tightly coupled with the internal request handling code of the core. More
    precisely, mmc_wait_for_req_done() checks for specific sanitize errors.
    This is not only inefficient as it affects all types of requests, but also
    hackish.
    
    Therefore, let's improve the behaviour by moving the error path out of the
    mmc core. To do that, retuning needs to be held while running the sanitize
    operation.
    
    Moreover, to avoid exporting unnecessary symbols to the mmc block module,
    let's move the code into the mmc_ops.c file. While updating the actual
    code, let's also take the opportunity to clean up some of the mess around
    it.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Link: https://lore.kernel.org/r/20200316152152.15122-1-ulf.hansson@linaro.org

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 3f7a31456eb4..4c5de6d37ac7 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -403,23 +403,6 @@ void mmc_wait_for_req_done(struct mmc_host *host, struct mmc_request *mrq)
 
 		cmd = mrq->cmd;
 
-		/*
-		 * If host has timed out waiting for the sanitize
-		 * to complete, card might be still in programming state
-		 * so let's try to bring the card out of programming
-		 * state.
-		 */
-		if (cmd->sanitize_busy && cmd->error == -ETIMEDOUT) {
-			if (!mmc_interrupt_hpi(host->card)) {
-				pr_warn("%s: %s: Interrupted sanitize\n",
-					mmc_hostname(host), __func__);
-				cmd->error = 0;
-				break;
-			} else {
-				pr_err("%s: %s: Failed to interrupt sanitize\n",
-				       mmc_hostname(host), __func__);
-			}
-		}
 		if (!cmd->error || !cmd->retries ||
 		    mmc_card_removed(host->card))
 			break;
@@ -1925,7 +1908,6 @@ int mmc_can_sanitize(struct mmc_card *card)
 		return 1;
 	return 0;
 }
-EXPORT_SYMBOL(mmc_can_sanitize);
 
 int mmc_can_secure_erase_trim(struct mmc_card *card)
 {

commit 0d84c3e6a5b2cd4ddd68b7ef7cf7c2dafd5146ef
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Tue Feb 4 09:54:45 2020 +0100

    mmc: core: Convert to mmc_poll_for_busy() for erase/trim/discard
    
    Rather than open coding the polling loop in mmc_do_erase(), let's convert
    to use mmc_poll_for_busy().
    
    To allow a slightly different error parsing during polling, compared to the
    __mmc_switch() case, a new in-parameter to mmc_poll_for_busy() is needed,
    but other than that the conversion is straight forward.
    
    Besides addressing the open coding issue, moving to mmc_poll_for_busy() for
    erase/trim/discard improves the behaviour according to below.
    
    - Adds support for polling via the optional ->card_busy() host ops.
    - Returns zero to indicate success when the final polling attempt finds the
      card non-busy, even if the timeout expired.
    - Exits the polling loop when state moves to R1_STATE_TRAN, rather than
      when leaving R1_STATE_PRG.
    - Decreases the starting range for throttling to 32-64us.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Tested-by: Baolin Wang <baolin.wang7@gmail.com>
    Tested-by: Ludovic Barre <ludovic.barre@st.com>
    Reviewed-by: Ludovic Barre <ludovic.barre@st.com>
    Link: https://lore.kernel.org/r/20200204085449.32585-9-ulf.hansson@linaro.org

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index a971c4bcc442..3f7a31456eb4 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1658,8 +1658,6 @@ static int mmc_do_erase(struct mmc_card *card, unsigned int from,
 	struct mmc_command cmd = {};
 	unsigned int qty = 0, busy_timeout = 0;
 	bool use_r1b_resp = false;
-	unsigned long timeout;
-	int loop_udelay=64, udelay_max=32768;
 	int err;
 
 	mmc_retune_hold(card->host);
@@ -1763,38 +1761,8 @@ static int mmc_do_erase(struct mmc_card *card, unsigned int from,
 	if ((card->host->caps & MMC_CAP_WAIT_WHILE_BUSY) && use_r1b_resp)
 		goto out;
 
-	timeout = jiffies + msecs_to_jiffies(busy_timeout);
-	do {
-		memset(&cmd, 0, sizeof(struct mmc_command));
-		cmd.opcode = MMC_SEND_STATUS;
-		cmd.arg = card->rca << 16;
-		cmd.flags = MMC_RSP_R1 | MMC_CMD_AC;
-		/* Do not retry else we can't see errors */
-		err = mmc_wait_for_cmd(card->host, &cmd, 0);
-		if (err || R1_STATUS(cmd.resp[0])) {
-			pr_err("error %d requesting status %#x\n",
-				err, cmd.resp[0]);
-			err = -EIO;
-			goto out;
-		}
-
-		/* Timeout if the device never becomes ready for data and
-		 * never leaves the program state.
-		 */
-		if (time_after(jiffies, timeout)) {
-			pr_err("%s: Card stuck in programming state! %s\n",
-				mmc_hostname(card->host), __func__);
-			err =  -EIO;
-			goto out;
-		}
-		if ((cmd.resp[0] & R1_READY_FOR_DATA) &&
-		    R1_CURRENT_STATE(cmd.resp[0]) != R1_STATE_PRG)
-			break;
-
-		usleep_range(loop_udelay, loop_udelay*2);
-		if (loop_udelay < udelay_max)
-			loop_udelay *= 2;
-	} while (1);
+	/* Let's poll to find out when the erase operation completes. */
+	err = mmc_poll_for_busy(card, busy_timeout, MMC_BUSY_ERASE);
 
 out:
 	mmc_retune_release(card->host);

commit 43cc64e5221cc6741252b64bc4531dd1eefb733d
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Tue Mar 10 14:43:00 2020 +0100

    mmc: core: Respect MMC_CAP_NEED_RSP_BUSY for erase/trim/discard
    
    The busy timeout that is computed for each erase/trim/discard operation,
    can become quite long and may thus exceed the host->max_busy_timeout. If
    that becomes the case, mmc_do_erase() converts from using an R1B response
    to an R1 response, as to prevent the host from doing HW busy detection.
    
    However, it has turned out that some hosts requires an R1B response no
    matter what, so let's respect that via checking MMC_CAP_NEED_RSP_BUSY. Note
    that, if the R1B gets enforced, the host becomes fully responsible of
    managing the needed busy timeout, in one way or the other.
    
    Suggested-by: Sowjanya Komatineni <skomatineni@nvidia.com>
    Cc: <stable@vger.kernel.org>
    Tested-by: Anders Roxell <anders.roxell@linaro.org>
    Tested-by: Sowjanya Komatineni <skomatineni@nvidia.com>
    Tested-by: Faiz Abbas <faiz_abbas@ti.com>
    Tested-By: Peter Geis <pgwipeout@gmail.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index aa54d359dab7..a971c4bcc442 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1732,8 +1732,11 @@ static int mmc_do_erase(struct mmc_card *card, unsigned int from,
 	 * the erase operation does not exceed the max_busy_timeout, we should
 	 * use R1B response. Or we need to prevent the host from doing hw busy
 	 * detection, which is done by converting to a R1 response instead.
+	 * Note, some hosts requires R1B, which also means they are on their own
+	 * when it comes to deal with the busy timeout.
 	 */
-	if (card->host->max_busy_timeout &&
+	if (!(card->host->caps & MMC_CAP_NEED_RSP_BUSY) &&
+	    card->host->max_busy_timeout &&
 	    busy_timeout > card->host->max_busy_timeout) {
 		cmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_AC;
 	} else {

commit 661cf2d8973a0211be8d4ee1430b66690b291e83
Author: Michał Mirosław <mirq-linux@rere.qmqm.pl>
Date:   Thu Jan 2 11:54:58 2020 +0100

    mmc: core: limit probe clock frequency to configured f_max
    
    Currently MMC core disregards host->f_max during card initialization
    phase. Obey upper boundary for the clock frequency and skip faster
    speeds when they are above the limit.
    
    Signed-off-by: Michał Mirosław <mirq-linux@rere.qmqm.pl>
    Link: https://lore.kernel.org/r/f471bceaf237d582d746bd289c4c4f3639cb7b45.1577962382.git.mirq-linux@rere.qmqm.pl
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index abf8f5eb0a1c..aa54d359dab7 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2330,7 +2330,13 @@ void mmc_rescan(struct work_struct *work)
 	}
 
 	for (i = 0; i < ARRAY_SIZE(freqs); i++) {
-		if (!mmc_rescan_try_freq(host, max(freqs[i], host->f_min)))
+		unsigned int freq = freqs[i];
+		if (freq > host->f_max) {
+			if (i + 1 < ARRAY_SIZE(freqs))
+				continue;
+			freq = host->f_max;
+		}
+		if (!mmc_rescan_try_freq(host, max(freq, host->f_min)))
 			break;
 		if (freqs[i] <= host->f_min)
 			break;
@@ -2344,7 +2350,7 @@ void mmc_rescan(struct work_struct *work)
 
 void mmc_start_host(struct mmc_host *host)
 {
-	host->f_init = max(freqs[0], host->f_min);
+	host->f_init = max(min(freqs[0], host->f_max), host->f_min);
 	host->rescan_disable = 0;
 	host->ios.power_mode = MMC_POWER_UNDEFINED;
 

commit 2ac55d5e5ec9ad0a07e194f0eaca865fe5aa3c40
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu Oct 17 15:25:36 2019 +0200

    mmc: core: Re-work HW reset for SDIO cards
    
    It have turned out that it's not a good idea to unconditionally do a power
    cycle and then to re-initialize the SDIO card, as currently done through
    mmc_hw_reset() -> mmc_sdio_hw_reset(). This because there may be multiple
    SDIO func drivers probed, who also shares the same SDIO card.
    
    To address these scenarios, one may be tempted to use a notification
    mechanism, as to allow the core to inform each of the probed func drivers,
    about an ongoing HW reset. However, supporting such an operation from the
    func driver point of view, may not be entirely trivial.
    
    Therefore, let's use a more simplistic approach to solve the problem, by
    instead forcing the card to be removed and re-detected, via scheduling a
    rescan-work. In this way, we can rely on existing infrastructure, as the
    func driver's ->remove() and ->probe() callbacks, becomes invoked to deal
    with the cleanup and the re-initialization.
    
    This solution may be considered as rather heavy, especially if a func
    driver doesn't share its card with other func drivers. To address this,
    let's keep the current immediate HW reset option as well, but run it only
    when there is one func driver probed for the card.
    
    Finally, to allow the caller of mmc_hw_reset(), to understand if the reset
    is being asynchronously managed from a scheduled work, it returns 1
    (propagated from mmc_sdio_hw_reset()). If the HW reset is executed
    successfully and synchronously it returns 0, which maintains the existing
    behaviour.
    
    Reviewed-by: Douglas Anderson <dianders@chromium.org>
    Tested-by: Douglas Anderson <dianders@chromium.org>
    Cc: stable@vger.kernel.org # v5.4+
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 6f8342702c73..abf8f5eb0a1c 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1469,8 +1469,7 @@ void mmc_detach_bus(struct mmc_host *host)
 	mmc_bus_put(host);
 }
 
-static void _mmc_detect_change(struct mmc_host *host, unsigned long delay,
-				bool cd_irq)
+void _mmc_detect_change(struct mmc_host *host, unsigned long delay, bool cd_irq)
 {
 	/*
 	 * If the device is configured as wakeup, we prevent a new sleep for
@@ -2129,7 +2128,7 @@ int mmc_hw_reset(struct mmc_host *host)
 	ret = host->bus_ops->hw_reset(host);
 	mmc_bus_put(host);
 
-	if (ret)
+	if (ret < 0)
 		pr_warn("%s: tried to HW reset card, got error %d\n",
 			mmc_hostname(host), ret);
 

commit 99b4ddd8b76a6f60a8c2b3775849d65d21a418fc
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu Oct 10 15:54:37 2019 +0200

    mmc: core: Drop check for mmc_card_is_removable() in mmc_rescan()
    
    Upfront in mmc_rescan() we use the host->rescan_entered flag, to allow
    scanning only once for non-removable cards. Therefore, it's also not
    possible that we can have a corresponding card bus attached (host->bus_ops
    is NULL), when we are scanning non-removable cards.
    
    For this reason, let' drop the check for mmc_card_is_removable() as it's
    redundant.
    
    Reviewed-by: Douglas Anderson <dianders@chromium.org>
    Tested-by: Douglas Anderson <dianders@chromium.org>
    Cc: stable@vger.kernel.org # v5.4+
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 221127324709..6f8342702c73 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2297,11 +2297,8 @@ void mmc_rescan(struct work_struct *work)
 
 	mmc_bus_get(host);
 
-	/*
-	 * if there is a _removable_ card registered, check whether it is
-	 * still present
-	 */
-	if (host->bus_ops && !host->bus_dead && mmc_card_is_removable(host))
+	/* Verify a registered card to be functional, else remove it. */
+	if (host->bus_ops && !host->bus_dead)
 		host->bus_ops->detect(host);
 
 	host->detect_change = 0;

commit c884d8ac7ffccc094e9674a3eb3be90d3b296c0a
Merge: 05512b0f4652 c891f3b97964
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jun 21 09:58:42 2019 -0700

    Merge tag 'spdx-5.2-rc6' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/spdx
    
    Pull still more SPDX updates from Greg KH:
     "Another round of SPDX updates for 5.2-rc6
    
      Here is what I am guessing is going to be the last "big" SPDX update
      for 5.2. It contains all of the remaining GPLv2 and GPLv2+ updates
      that were "easy" to determine by pattern matching. The ones after this
      are going to be a bit more difficult and the people on the spdx list
      will be discussing them on a case-by-case basis now.
    
      Another 5000+ files are fixed up, so our overall totals are:
            Files checked:            64545
            Files with SPDX:          45529
    
      Compared to the 5.1 kernel which was:
            Files checked:            63848
            Files with SPDX:          22576
    
      This is a huge improvement.
    
      Also, we deleted another 20000 lines of boilerplate license crud,
      always nice to see in a diffstat"
    
    * tag 'spdx-5.2-rc6' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/spdx: (65 commits)
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 507
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 506
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 505
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 504
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 503
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 502
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 501
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 499
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 498
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 497
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 496
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 495
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 491
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 490
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 489
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 488
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 487
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 486
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 485
      ...

commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 6db36dc870b5..260e2e3400bd 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  *  linux/drivers/mmc/core/core.c
  *
@@ -5,10 +6,6 @@
  *  SD support Copyright (C) 2004 Ian Molton, All Rights Reserved.
  *  Copyright (C) 2005-2008 Pierre Ossman, All Rights Reserved.
  *  MMCv4 support Copyright (C) 2006 Philip Langdale, All Rights Reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 #include <linux/module.h>
 #include <linux/init.h>

commit 0a55f4ab9678413a01e740c86e9367ba0c612b36
Author: Douglas Anderson <dianders@chromium.org>
Date:   Mon Jun 17 10:56:50 2019 -0700

    mmc: core: API to temporarily disable retuning for SDIO CRC errors
    
    Normally when the MMC core sees an "-EILSEQ" error returned by a host
    controller then it will trigger a retuning of the card.  This is
    generally a good idea.
    
    However, if a command is expected to sometimes cause transfer errors
    then these transfer errors shouldn't cause a re-tuning.  This
    re-tuning will be a needless waste of time.  One example case where a
    transfer is expected to cause errors is when transitioning between
    idle (sometimes referred to as "sleep" in Broadcom code) and active
    state on certain Broadcom WiFi SDIO cards.  Specifically if the card
    was already transitioning between states when the command was sent it
    could cause an error on the SDIO bus.
    
    Let's add an API that the SDIO function drivers can call that will
    temporarily disable the auto-tuning functionality.  Then we can add a
    call to this in the Broadcom WiFi driver and any other driver that
    might have similar needs.
    
    NOTE: this makes the assumption that the card is already tuned well
    enough that it's OK to disable the auto-retuning during one of these
    error-prone situations.  Presumably the driver code performing the
    error-prone transfer knows how to recover / retry from errors.  ...and
    after we can get back to a state where transfers are no longer
    error-prone then we can enable the auto-retuning again.  If we truly
    find ourselves in a case where the card needs to be retuned sometimes
    to handle one of these error-prone transfers then we can always try a
    few transfers first without auto-retuning and then re-try with
    auto-retuning if the first few fail.
    
    Without this change on rk3288-veyron-minnie I periodically see this in
    the logs of a machine just sitting there idle:
      dwmmc_rockchip ff0d0000.dwmmc: Successfully tuned phase to XYZ
    
    Cc: stable@vger.kernel.org #v4.18+
    Signed-off-by: Douglas Anderson <dianders@chromium.org>
    Acked-by: Adrian Hunter <adrian.hunter@intel.com>
    Acked-by: Kalle Valo <kvalo@codeaurora.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 6db36dc870b5..9020cb2490f7 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -144,8 +144,9 @@ void mmc_request_done(struct mmc_host *host, struct mmc_request *mrq)
 	int err = cmd->error;
 
 	/* Flag re-tuning needed on CRC errors */
-	if ((cmd->opcode != MMC_SEND_TUNING_BLOCK &&
-	    cmd->opcode != MMC_SEND_TUNING_BLOCK_HS200) &&
+	if (cmd->opcode != MMC_SEND_TUNING_BLOCK &&
+	    cmd->opcode != MMC_SEND_TUNING_BLOCK_HS200 &&
+	    !host->retune_crc_disable &&
 	    (err == -EILSEQ || (mrq->sbc && mrq->sbc->error == -EILSEQ) ||
 	    (mrq->data && mrq->data->error == -EILSEQ) ||
 	    (mrq->stop && mrq->stop->error == -EILSEQ)))

commit d4721339dcca7def04909a8e60da43c19a24d8bf
Author: Jiong Wu <lohengrin1024@gmail.com>
Date:   Fri Mar 1 00:18:33 2019 +0800

    mmc:fix a bug when max_discard is 0
    
    The original purpose of the code I fix is to replace max_discard with
    max_trim if max_trim is less than max_discard. When max_discard is 0
    we should replace max_discard with max_trim as well, because
    max_discard equals 0 happens only when the max_do_calc_max_discard
    process is overflowed, so if mmc_can_trim(card) is true, max_discard
    should be replaced by an available max_trim.
    However, in the original code, there are two lines of code interfere
    the right process.
    1) if (max_discard && mmc_can_trim(card))
    when max_discard is 0, it skips the process checking if max_discard
    needs to be replaced with max_trim.
    2) if (max_trim < max_discard)
    the condition is false when max_discard is 0. it also skips the process
    that replaces max_discard with max_trim, in fact, we should replace the
    0-valued max_discard with max_trim.
    
    Signed-off-by: Jiong Wu <Lohengrin1024@gmail.com>
    Fixes: b305882fbc87 (mmc: core: optimize mmc_calc_max_discard)
    Cc: stable@vger.kernel.org # v4.17+
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index ebf1a08cd359..6db36dc870b5 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2071,9 +2071,9 @@ unsigned int mmc_calc_max_discard(struct mmc_card *card)
 		return card->pref_erase;
 
 	max_discard = mmc_do_calc_max_discard(card, MMC_ERASE_ARG);
-	if (max_discard && mmc_can_trim(card)) {
+	if (mmc_can_trim(card)) {
 		max_trim = mmc_do_calc_max_discard(card, MMC_TRIM_ARG);
-		if (max_trim < max_discard)
+		if (max_trim < max_discard || max_discard == 0)
 			max_discard = max_trim;
 	} else if (max_discard < card->erase_size) {
 		max_discard = 0;

commit 82b6248705cccc4341b4c1d4a80a70f018198db0
Merge: ad9be7fff3e7 c53336c8f5f2
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu Feb 28 09:16:18 2019 +0100

    Merge branch 'fixes' into next

commit ad9be7fff3e729287f61a2a5e811c03090003fff
Author: Avri Altman <avri.altman@wdc.com>
Date:   Tue Feb 26 17:10:25 2019 +0200

    mmc: core: Add sd discard timeout
    
    The busy timeout is 250msec per discard command.
    
    Signed-off-by: Avri Altman <avri.altman@wdc.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 681b089f669a..2d415cb1889a 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -51,6 +51,7 @@
 
 /* The max erase timeout, used when host->max_busy_timeout isn't specified */
 #define MMC_ERASE_TIMEOUT_MS	(60 * 1000) /* 60 s */
+#define SD_DISCARD_TIMEOUT_MS	(250)
 
 static const unsigned freqs[] = { 400000, 300000, 200000, 100000 };
 
@@ -1619,6 +1620,12 @@ static unsigned int mmc_sd_erase_timeout(struct mmc_card *card,
 {
 	unsigned int erase_timeout;
 
+	/* for DISCARD none of the below calculation applies.
+	 * the busy timeout is 250msec per discard command.
+	 */
+	if (arg == SD_DISCARD_ARG)
+		return SD_DISCARD_TIMEOUT_MS;
+
 	if (card->ssr.erase_timeout) {
 		/* Erase timeout specified in SD Status Register (SSR) */
 		erase_timeout = card->ssr.erase_timeout * qty +

commit bc47e2f6f9e261ea07c678c3cad76eb5590c0fea
Author: Avri Altman <avri.altman@wdc.com>
Date:   Tue Feb 26 17:10:24 2019 +0200

    mmc: core: Add discard support to sd
    
    SD spec v5.1 adds discard support. The flows and commands are similar to
    mmc, so just set the discard arg in CMD38.
    
    A host which supports DISCARD shall check if the DISCARD_SUPPORT (b313)
    is set in the SD_STATUS register.  If the card does not support discard,
    the host shall not issue DISCARD command, but ERASE command instead.
    
    Post the DISCARD operation, the card may de-allocate the discarded
    blocks partially or completely. So the host mustn't make any assumptions
    concerning the content of the discarded region. This is unlike ERASE
    command, in which the region is guaranteed to contain either '0's or
    '1's, depends on the content of DATA_STAT_AFTER_ERASE (b55) in the scr
    register.
    
    One more important difference compared to ERASE is the busy timeout
    which we will address on the next patch.
    
    Signed-off-by: Avri Altman <avri.altman@wdc.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index b45aaa904107..681b089f669a 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1847,7 +1847,7 @@ static unsigned int mmc_align_erase_size(struct mmc_card *card,
  * @card: card to erase
  * @from: first sector to erase
  * @nr: number of sectors to erase
- * @arg: erase command argument (SD supports only %SD_ERASE_ARG)
+ * @arg: erase command argument
  *
  * Caller must claim host before calling this function.
  */
@@ -1864,14 +1864,14 @@ int mmc_erase(struct mmc_card *card, unsigned int from, unsigned int nr,
 	if (!card->erase_size)
 		return -EOPNOTSUPP;
 
-	if (mmc_card_sd(card) && arg != SD_ERASE_ARG)
+	if (mmc_card_sd(card) && arg != SD_ERASE_ARG && arg != SD_DISCARD_ARG)
 		return -EOPNOTSUPP;
 
-	if ((arg & MMC_SECURE_ARGS) &&
+	if (mmc_card_mmc(card) && (arg & MMC_SECURE_ARGS) &&
 	    !(card->ext_csd.sec_feature_support & EXT_CSD_SEC_ER_EN))
 		return -EOPNOTSUPP;
 
-	if ((arg & MMC_TRIM_ARGS) &&
+	if (mmc_card_mmc(card) && (arg & MMC_TRIM_ARGS) &&
 	    !(card->ext_csd.sec_feature_support & EXT_CSD_SEC_GB_CL_EN))
 		return -EOPNOTSUPP;
 

commit e5723f95d6b493dd437f1199cacb41459713b32f
Author: Ritesh Harjani <riteshh@codeaurora.org>
Date:   Fri Feb 22 19:21:34 2019 +0530

    mmc: core: Fix NULL ptr crash from mmc_should_fail_request
    
    In case of CQHCI, mrq->cmd may be NULL for data requests (non DCMD).
    In such case mmc_should_fail_request is directly dereferencing
    mrq->cmd while cmd is NULL.
    Fix this by checking for mrq->cmd pointer.
    
    Fixes: 72a5af554df8 ("mmc: core: Add support for handling CQE requests")
    Signed-off-by: Ritesh Harjani <riteshh@codeaurora.org>
    Cc: stable@vger.kernel.org
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 5bd58b95d318..b27a1e620233 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -95,7 +95,7 @@ static void mmc_should_fail_request(struct mmc_host *host,
 	if (!data)
 		return;
 
-	if (cmd->error || data->error ||
+	if ((cmd && cmd->error) || data->error ||
 	    !should_fail(&host->fail_mmc_request, data->blksz * data->blocks))
 		return;
 

commit eae343c290f78916b254972e85e0b419e55618f1
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Wed Feb 13 20:03:30 2019 +0100

    mmc: core: Convert mmc_align_data_size() into an SDIO specific function
    
    The only user of mmc_align_data_size() is sdio_align_size(), which is
    called from SDIO func drivers to let them distinguish, how to optimally
    allocate data buffers.
    
    Let's move mmc_align_data_size() close to the SDIO code as to make it
    static, rename it to _sdio_align_size() and simplify its definition, all
    with the purpose of clarifying that this is SDIO specific.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Avri Altman <avri.altman@wdc.com>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 659eb32c0246..b45aaa904107 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -757,33 +757,6 @@ void mmc_set_data_timeout(struct mmc_data *data, const struct mmc_card *card)
 }
 EXPORT_SYMBOL(mmc_set_data_timeout);
 
-/**
- *	mmc_align_data_size - pads a transfer size to a more optimal value
- *	@card: the MMC card associated with the data transfer
- *	@sz: original transfer size
- *
- *	Pads the original data size with a number of extra bytes in
- *	order to avoid controller bugs and/or performance hits
- *	(e.g. some controllers revert to PIO for certain sizes).
- *
- *	Returns the improved size, which might be unmodified.
- *
- *	Note that this function is only relevant when issuing a
- *	single scatter gather entry.
- */
-unsigned int mmc_align_data_size(struct mmc_card *card, unsigned int sz)
-{
-	/*
-	 * FIXME: We don't have a system for the controller to tell
-	 * the core about its problems yet, so for now we just 32-bit
-	 * align the size.
-	 */
-	sz = ((sz + 3) / 4) * 4;
-
-	return sz;
-}
-EXPORT_SYMBOL(mmc_align_data_size);
-
 /*
  * Allow claiming an already claimed host if the context is the same or there is
  * no context but the task is the same.

commit 9d2d24302e615e984034d2f60a4da739de6bd637
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Wed Feb 13 18:46:45 2019 +0100

    mmc: core: Move mmc_of_parse_voltage() to host.c
    
    MMC OF parsing functions, which parses various host DT properties, should
    stay close to each other. Therefore, let's move mmc_of_parse_voltage()
    close to mmc_of_parse() into host.c.
    
    Additionally, there is no reason to build the code only when CONFIG_OF is
    set, as there should be stub functions for the OF helpers that is being
    used, so let's drop this condition as well.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index f796a6afb19b..659eb32c0246 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1112,54 +1112,6 @@ u32 mmc_vddrange_to_ocrmask(int vdd_min, int vdd_max)
 	return mask;
 }
 
-#ifdef CONFIG_OF
-
-/**
- * mmc_of_parse_voltage - return mask of supported voltages
- * @np: The device node need to be parsed.
- * @mask: mask of voltages available for MMC/SD/SDIO
- *
- * Parse the "voltage-ranges" DT property, returning zero if it is not
- * found, negative errno if the voltage-range specification is invalid,
- * or one if the voltage-range is specified and successfully parsed.
- */
-int mmc_of_parse_voltage(struct device_node *np, u32 *mask)
-{
-	const u32 *voltage_ranges;
-	int num_ranges, i;
-
-	voltage_ranges = of_get_property(np, "voltage-ranges", &num_ranges);
-	num_ranges = num_ranges / sizeof(*voltage_ranges) / 2;
-	if (!voltage_ranges) {
-		pr_debug("%pOF: voltage-ranges unspecified\n", np);
-		return 0;
-	}
-	if (!num_ranges) {
-		pr_err("%pOF: voltage-ranges empty\n", np);
-		return -EINVAL;
-	}
-
-	for (i = 0; i < num_ranges; i++) {
-		const int j = i * 2;
-		u32 ocr_mask;
-
-		ocr_mask = mmc_vddrange_to_ocrmask(
-				be32_to_cpu(voltage_ranges[j]),
-				be32_to_cpu(voltage_ranges[j + 1]));
-		if (!ocr_mask) {
-			pr_err("%pOF: voltage-range #%d is invalid\n",
-				np, i);
-			return -EINVAL;
-		}
-		*mask |= ocr_mask;
-	}
-
-	return 1;
-}
-EXPORT_SYMBOL(mmc_of_parse_voltage);
-
-#endif /* CONFIG_OF */
-
 static int mmc_of_get_func_num(struct device_node *node)
 {
 	u32 reg;

commit de13d5a44e61366ab5b75c111449ca284b6e3f5d
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Wed Feb 13 18:10:37 2019 +0100

    mmc: core: Move regulator helpers to separate file
    
    The mmc regulator helper functions, are placed in the extensive core.c
    file.  In a step towards trying to create a better structure of files,
    avoiding too many lines of code per file, let's move these helpers to a new
    file, regulator.c.
    
    Moreover, this within this context it makes sense to also drop the export
    of mmc_vddrange_to_ocrmask(), but instead let's make it internal to the mmc
    core.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index de0f1a1f0a63..f796a6afb19b 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -21,7 +21,6 @@
 #include <linux/leds.h>
 #include <linux/scatterlist.h>
 #include <linux/log2.h>
-#include <linux/regulator/consumer.h>
 #include <linux/pm_runtime.h>
 #include <linux/pm_wakeup.h>
 #include <linux/suspend.h>
@@ -1112,7 +1111,6 @@ u32 mmc_vddrange_to_ocrmask(int vdd_min, int vdd_max)
 
 	return mask;
 }
-EXPORT_SYMBOL(mmc_vddrange_to_ocrmask);
 
 #ifdef CONFIG_OF
 
@@ -1190,246 +1188,6 @@ struct device_node *mmc_of_find_child_device(struct mmc_host *host,
 	return NULL;
 }
 
-#ifdef CONFIG_REGULATOR
-
-/**
- * mmc_ocrbitnum_to_vdd - Convert a OCR bit number to its voltage
- * @vdd_bit:	OCR bit number
- * @min_uV:	minimum voltage value (mV)
- * @max_uV:	maximum voltage value (mV)
- *
- * This function returns the voltage range according to the provided OCR
- * bit number. If conversion is not possible a negative errno value returned.
- */
-static int mmc_ocrbitnum_to_vdd(int vdd_bit, int *min_uV, int *max_uV)
-{
-	int		tmp;
-
-	if (!vdd_bit)
-		return -EINVAL;
-
-	/*
-	 * REVISIT mmc_vddrange_to_ocrmask() may have set some
-	 * bits this regulator doesn't quite support ... don't
-	 * be too picky, most cards and regulators are OK with
-	 * a 0.1V range goof (it's a small error percentage).
-	 */
-	tmp = vdd_bit - ilog2(MMC_VDD_165_195);
-	if (tmp == 0) {
-		*min_uV = 1650 * 1000;
-		*max_uV = 1950 * 1000;
-	} else {
-		*min_uV = 1900 * 1000 + tmp * 100 * 1000;
-		*max_uV = *min_uV + 100 * 1000;
-	}
-
-	return 0;
-}
-
-/**
- * mmc_regulator_get_ocrmask - return mask of supported voltages
- * @supply: regulator to use
- *
- * This returns either a negative errno, or a mask of voltages that
- * can be provided to MMC/SD/SDIO devices using the specified voltage
- * regulator.  This would normally be called before registering the
- * MMC host adapter.
- */
-int mmc_regulator_get_ocrmask(struct regulator *supply)
-{
-	int			result = 0;
-	int			count;
-	int			i;
-	int			vdd_uV;
-	int			vdd_mV;
-
-	count = regulator_count_voltages(supply);
-	if (count < 0)
-		return count;
-
-	for (i = 0; i < count; i++) {
-		vdd_uV = regulator_list_voltage(supply, i);
-		if (vdd_uV <= 0)
-			continue;
-
-		vdd_mV = vdd_uV / 1000;
-		result |= mmc_vddrange_to_ocrmask(vdd_mV, vdd_mV);
-	}
-
-	if (!result) {
-		vdd_uV = regulator_get_voltage(supply);
-		if (vdd_uV <= 0)
-			return vdd_uV;
-
-		vdd_mV = vdd_uV / 1000;
-		result = mmc_vddrange_to_ocrmask(vdd_mV, vdd_mV);
-	}
-
-	return result;
-}
-EXPORT_SYMBOL_GPL(mmc_regulator_get_ocrmask);
-
-/**
- * mmc_regulator_set_ocr - set regulator to match host->ios voltage
- * @mmc: the host to regulate
- * @supply: regulator to use
- * @vdd_bit: zero for power off, else a bit number (host->ios.vdd)
- *
- * Returns zero on success, else negative errno.
- *
- * MMC host drivers may use this to enable or disable a regulator using
- * a particular supply voltage.  This would normally be called from the
- * set_ios() method.
- */
-int mmc_regulator_set_ocr(struct mmc_host *mmc,
-			struct regulator *supply,
-			unsigned short vdd_bit)
-{
-	int			result = 0;
-	int			min_uV, max_uV;
-
-	if (vdd_bit) {
-		mmc_ocrbitnum_to_vdd(vdd_bit, &min_uV, &max_uV);
-
-		result = regulator_set_voltage(supply, min_uV, max_uV);
-		if (result == 0 && !mmc->regulator_enabled) {
-			result = regulator_enable(supply);
-			if (!result)
-				mmc->regulator_enabled = true;
-		}
-	} else if (mmc->regulator_enabled) {
-		result = regulator_disable(supply);
-		if (result == 0)
-			mmc->regulator_enabled = false;
-	}
-
-	if (result)
-		dev_err(mmc_dev(mmc),
-			"could not set regulator OCR (%d)\n", result);
-	return result;
-}
-EXPORT_SYMBOL_GPL(mmc_regulator_set_ocr);
-
-static int mmc_regulator_set_voltage_if_supported(struct regulator *regulator,
-						  int min_uV, int target_uV,
-						  int max_uV)
-{
-	/*
-	 * Check if supported first to avoid errors since we may try several
-	 * signal levels during power up and don't want to show errors.
-	 */
-	if (!regulator_is_supported_voltage(regulator, min_uV, max_uV))
-		return -EINVAL;
-
-	return regulator_set_voltage_triplet(regulator, min_uV, target_uV,
-					     max_uV);
-}
-
-/**
- * mmc_regulator_set_vqmmc - Set VQMMC as per the ios
- *
- * For 3.3V signaling, we try to match VQMMC to VMMC as closely as possible.
- * That will match the behavior of old boards where VQMMC and VMMC were supplied
- * by the same supply.  The Bus Operating conditions for 3.3V signaling in the
- * SD card spec also define VQMMC in terms of VMMC.
- * If this is not possible we'll try the full 2.7-3.6V of the spec.
- *
- * For 1.2V and 1.8V signaling we'll try to get as close as possible to the
- * requested voltage.  This is definitely a good idea for UHS where there's a
- * separate regulator on the card that's trying to make 1.8V and it's best if
- * we match.
- *
- * This function is expected to be used by a controller's
- * start_signal_voltage_switch() function.
- */
-int mmc_regulator_set_vqmmc(struct mmc_host *mmc, struct mmc_ios *ios)
-{
-	struct device *dev = mmc_dev(mmc);
-	int ret, volt, min_uV, max_uV;
-
-	/* If no vqmmc supply then we can't change the voltage */
-	if (IS_ERR(mmc->supply.vqmmc))
-		return -EINVAL;
-
-	switch (ios->signal_voltage) {
-	case MMC_SIGNAL_VOLTAGE_120:
-		return mmc_regulator_set_voltage_if_supported(mmc->supply.vqmmc,
-						1100000, 1200000, 1300000);
-	case MMC_SIGNAL_VOLTAGE_180:
-		return mmc_regulator_set_voltage_if_supported(mmc->supply.vqmmc,
-						1700000, 1800000, 1950000);
-	case MMC_SIGNAL_VOLTAGE_330:
-		ret = mmc_ocrbitnum_to_vdd(mmc->ios.vdd, &volt, &max_uV);
-		if (ret < 0)
-			return ret;
-
-		dev_dbg(dev, "%s: found vmmc voltage range of %d-%duV\n",
-			__func__, volt, max_uV);
-
-		min_uV = max(volt - 300000, 2700000);
-		max_uV = min(max_uV + 200000, 3600000);
-
-		/*
-		 * Due to a limitation in the current implementation of
-		 * regulator_set_voltage_triplet() which is taking the lowest
-		 * voltage possible if below the target, search for a suitable
-		 * voltage in two steps and try to stay close to vmmc
-		 * with a 0.3V tolerance at first.
-		 */
-		if (!mmc_regulator_set_voltage_if_supported(mmc->supply.vqmmc,
-						min_uV, volt, max_uV))
-			return 0;
-
-		return mmc_regulator_set_voltage_if_supported(mmc->supply.vqmmc,
-						2700000, volt, 3600000);
-	default:
-		return -EINVAL;
-	}
-}
-EXPORT_SYMBOL_GPL(mmc_regulator_set_vqmmc);
-
-#endif /* CONFIG_REGULATOR */
-
-/**
- * mmc_regulator_get_supply - try to get VMMC and VQMMC regulators for a host
- * @mmc: the host to regulate
- *
- * Returns 0 or errno. errno should be handled, it is either a critical error
- * or -EPROBE_DEFER. 0 means no critical error but it does not mean all
- * regulators have been found because they all are optional. If you require
- * certain regulators, you need to check separately in your driver if they got
- * populated after calling this function.
- */
-int mmc_regulator_get_supply(struct mmc_host *mmc)
-{
-	struct device *dev = mmc_dev(mmc);
-	int ret;
-
-	mmc->supply.vmmc = devm_regulator_get_optional(dev, "vmmc");
-	mmc->supply.vqmmc = devm_regulator_get_optional(dev, "vqmmc");
-
-	if (IS_ERR(mmc->supply.vmmc)) {
-		if (PTR_ERR(mmc->supply.vmmc) == -EPROBE_DEFER)
-			return -EPROBE_DEFER;
-		dev_dbg(dev, "No vmmc regulator found\n");
-	} else {
-		ret = mmc_regulator_get_ocrmask(mmc->supply.vmmc);
-		if (ret > 0)
-			mmc->ocr_avail = ret;
-		else
-			dev_warn(dev, "Failed getting OCR mask: %d\n", ret);
-	}
-
-	if (IS_ERR(mmc->supply.vqmmc)) {
-		if (PTR_ERR(mmc->supply.vqmmc) == -EPROBE_DEFER)
-			return -EPROBE_DEFER;
-		dev_dbg(dev, "No vqmmc regulator found\n");
-	}
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(mmc_regulator_get_supply);
-
 /*
  * Mask off any voltages we don't support and select
  * the lowest voltage

commit 01904ff77676ca6c88e972906ed204a2dfbabab6
Author: Avri Altman <avri.altman@wdc.com>
Date:   Wed Feb 6 13:28:05 2019 +0200

    mmc: core: Calculate the discard arg only once
    
    In MMC, the discard arg is a read-only ext_csd parameter - set it once
    on card init. To be consistent, do that for SD as well even though its
    discard arg is always 0x0.
    
    Signed-off-by: Avri Altman <avri.altman@wdc.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 5bd58b95d318..de0f1a1f0a63 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2164,7 +2164,7 @@ static unsigned int mmc_align_erase_size(struct mmc_card *card,
  * @card: card to erase
  * @from: first sector to erase
  * @nr: number of sectors to erase
- * @arg: erase command argument (SD supports only %MMC_ERASE_ARG)
+ * @arg: erase command argument (SD supports only %SD_ERASE_ARG)
  *
  * Caller must claim host before calling this function.
  */
@@ -2181,7 +2181,7 @@ int mmc_erase(struct mmc_card *card, unsigned int from, unsigned int nr,
 	if (!card->erase_size)
 		return -EOPNOTSUPP;
 
-	if (mmc_card_sd(card) && arg != MMC_ERASE_ARG)
+	if (mmc_card_sd(card) && arg != SD_ERASE_ARG)
 		return -EOPNOTSUPP;
 
 	if ((arg & MMC_SECURE_ARGS) &&

commit 7d5ef512575663695cf85f3aeb985a0aeb03e364
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu May 31 11:40:38 2018 +0200

    mmc: core: Introduce MMC_CAP_SYNC_RUNTIME_PM
    
    To allow mmc host drivers to inform the mmc core about rather using
    pm_runtime_put_sync_suspend() instead of pm_runtime_put_autosuspend(),
    let's introduce MMC_CAP_SYNC_RUNTIME_PM.
    
    This is especially useful for those mmc host drivers that don't benefit
    from using the runtime PM autosuspend feature. Typically this is those that
    relies on parent devices to power the card via runtime PM, like some USB
    host drivers for example.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Tested-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Tested-by: Oleksandr Natalenko <oleksandr@natalenko.name>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index d3085f70e9a4..5bd58b95d318 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -887,7 +887,10 @@ void mmc_release_host(struct mmc_host *host)
 		spin_unlock_irqrestore(&host->lock, flags);
 		wake_up(&host->wq);
 		pm_runtime_mark_last_busy(mmc_dev(host));
-		pm_runtime_put_autosuspend(mmc_dev(host));
+		if (host->caps & MMC_CAP_SYNC_RUNTIME_PM)
+			pm_runtime_put_sync_suspend(mmc_dev(host));
+		else
+			pm_runtime_put_autosuspend(mmc_dev(host));
 	}
 }
 EXPORT_SYMBOL(mmc_release_host);

commit b0715f04d0c136280da0cfd172f2bee49a64d2d2
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Mon Nov 26 14:38:14 2018 +0100

    mmc: core: remove obsolete mmc_set_blockcount() function
    
    The only user was converted to fill a sbc command which is the proper
    way to do it because of AutoCMD23 feature of some hosts.
    
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Tested-by: Clément Péron <peron.clem@gmail.com>
    Reviewed-by: Avri Altman <avri.altman@wdc.com>
    Reviewed-by: Niklas Söderlund <niklas.soderlund+renesas@ragnatech.se>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 50a5c340307b..d3085f70e9a4 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2413,20 +2413,6 @@ int mmc_set_blocklen(struct mmc_card *card, unsigned int blocklen)
 }
 EXPORT_SYMBOL(mmc_set_blocklen);
 
-int mmc_set_blockcount(struct mmc_card *card, unsigned int blockcount,
-			bool is_rel_write)
-{
-	struct mmc_command cmd = {};
-
-	cmd.opcode = MMC_SET_BLOCK_COUNT;
-	cmd.arg = blockcount & 0x0000FFFF;
-	if (is_rel_write)
-		cmd.arg |= 1 << 31;
-	cmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_AC;
-	return mmc_wait_for_cmd(card->host, &cmd, 5);
-}
-EXPORT_SYMBOL(mmc_set_blockcount);
-
 static void mmc_hw_reset_for_init(struct mmc_host *host)
 {
 	mmc_pwrseq_reset(host);

commit 29772f8a73d88a5de648177d9d822055ab7d1ba6
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Tue Jun 26 16:51:31 2018 +0200

    mmc: core: Drop the unused mmc_power_save|restore_host()
    
    The last user of mmc_power_save|restore_host() APIs is gone, hence let's
    drop them. Drop also the corresponding bus_ops callback,
    ->power_save|restore() as those becomes redundant.
    
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Eyal Reizer <eyalreizer@gmail.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 6780c2b81050..50a5c340307b 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2716,52 +2716,6 @@ void mmc_stop_host(struct mmc_host *host)
 	mmc_release_host(host);
 }
 
-int mmc_power_save_host(struct mmc_host *host)
-{
-	int ret = 0;
-
-	pr_debug("%s: %s: powering down\n", mmc_hostname(host), __func__);
-
-	mmc_bus_get(host);
-
-	if (!host->bus_ops || host->bus_dead) {
-		mmc_bus_put(host);
-		return -EINVAL;
-	}
-
-	if (host->bus_ops->power_save)
-		ret = host->bus_ops->power_save(host);
-
-	mmc_bus_put(host);
-
-	mmc_power_off(host);
-
-	return ret;
-}
-EXPORT_SYMBOL(mmc_power_save_host);
-
-int mmc_power_restore_host(struct mmc_host *host)
-{
-	int ret;
-
-	pr_debug("%s: %s: powering up\n", mmc_hostname(host), __func__);
-
-	mmc_bus_get(host);
-
-	if (!host->bus_ops || host->bus_dead) {
-		mmc_bus_put(host);
-		return -EINVAL;
-	}
-
-	mmc_power_up(host, host->card->ocr);
-	ret = host->bus_ops->power_restore(host);
-
-	mmc_bus_put(host);
-
-	return ret;
-}
-EXPORT_SYMBOL(mmc_power_restore_host);
-
 #ifdef CONFIG_PM_SLEEP
 /* Do the card removal on suspend if card is assumed removeable
  * Do that in pm notifier while userspace isn't yet frozen, so we will be able

commit a94a7483a91cb6a0d15a4413e8fc853f33a4e1b9
Author: Shawn Lin <shawn.lin@rock-chips.com>
Date:   Wed May 30 10:11:43 2018 +0800

    mmc: core: Adjust and reuse the macro of R1_STATUS(x)
    
    R1_STATUS(x) now is only used by ioctl_rpmb_card_status_poll(),
    which checks all bits as possible. But according to the spec,
    bit 17 and bit 18 should be ignored, as well bit 14 which is
    reserved(must be set to 0) quoting from the spec and these rule
    apply to all places checking the device status. So change
    its checking from 0xFFFFE000 to 0xFFF9A000.
    
    As a bonus, we reuse it for mmc_do_erase() as well as
    mmc_switch_status_error().
    (1) Currently mmc_switch_status_error() doesn't check bit 25, but
    it means device is locked but not unlocked by CMD42 prior to any
    operations which need check busy, which is also not allowed.
    (2) mmc_do_erase() also forgot to to check bit 15, WP_ERASE_SKIP.
    The spec says "Only partial address space was erased due to existing
    write protected blocks.", which obviously means we should fail this I/O.
    Otherwise, the partial erased data stored in nonvalatile flash violates
    the data integrity from the view of I/O owner, which probably confuse
    it when further used.
    
    So reusing R1_STATUS for them not only improve the readability but also
    slove real problems.
    
    Signed-off-by: Shawn Lin <shawn.lin@rock-chips.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 281826d1fcca..6780c2b81050 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2078,7 +2078,7 @@ static int mmc_do_erase(struct mmc_card *card, unsigned int from,
 		cmd.flags = MMC_RSP_R1 | MMC_CMD_AC;
 		/* Do not retry else we can't see errors */
 		err = mmc_wait_for_cmd(card->host, &cmd, 0);
-		if (err || (cmd.resp[0] & 0xFDF92000)) {
+		if (err || R1_STATUS(cmd.resp[0])) {
 			pr_err("error %d requesting status %#x\n",
 				err, cmd.resp[0]);
 			err = -EIO;

commit 833b51170feeee1718990480f792bb05cb0ca17c
Author: Martin Hicks <mort@bork.org>
Date:   Mon May 28 13:23:04 2018 +0200

    mmc: Throttle calls to MMC_SEND_STATUS during mmc_do_erase()
    
    This drastically reduces the rate at which the MMC_SEND_STATUS cmd polls
    for completion of the MMC Erase operation.  The patch does this by adding
    a backoff sleep that starts by sleeping for short intervals (128-256us),
    and ramps up to sleeping for 32-64ms.
    
    Even on very quickly completing erase operations, the loop iterates a few
    times, so not too much extra latency is added to these commands.
    
    For long running discard operarations, like a full-device secure discard,
    this change drops the interrupt rates on my single-core NXP I.MX6UL from
    45000/s to about 20/s, and greatly improves system responsiveness.
    
    Signed-off-by: Martin Hicks <mort@bork.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 9a769edbabe0..281826d1fcca 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1969,6 +1969,7 @@ static int mmc_do_erase(struct mmc_card *card, unsigned int from,
 	unsigned int qty = 0, busy_timeout = 0;
 	bool use_r1b_resp = false;
 	unsigned long timeout;
+	int loop_udelay=64, udelay_max=32768;
 	int err;
 
 	mmc_retune_hold(card->host);
@@ -2093,9 +2094,15 @@ static int mmc_do_erase(struct mmc_card *card, unsigned int from,
 			err =  -EIO;
 			goto out;
 		}
+		if ((cmd.resp[0] & R1_READY_FOR_DATA) &&
+		    R1_CURRENT_STATE(cmd.resp[0]) != R1_STATE_PRG)
+			break;
+
+		usleep_range(loop_udelay, loop_udelay*2);
+		if (loop_udelay < udelay_max)
+			loop_udelay *= 2;
+	} while (1);
 
-	} while (!(cmd.resp[0] & R1_READY_FOR_DATA) ||
-		 (R1_CURRENT_STATE(cmd.resp[0]) == R1_STATE_PRG));
 out:
 	mmc_retune_release(card->host);
 	return err;

commit 6d796c68cd15234a33a4bd2ef7231125fea2dc6c
Author: Shawn Lin <shawn.lin@rock-chips.com>
Date:   Tue May 8 09:04:20 2018 +0800

    mmc: core: add tunable delay waiting for power to be stable
    
    The hard-coded 10ms delay in mmc_power_up came from
    commit 79bccc5aefb4 ("mmc: increase power up delay"), which said "The TI
    controller on Toshiba Tecra M5 needs more time to power up or the cards
    will init incorrectly or not at all." But it's too engineering solution
    for a special board but force all platforms to wait for that long time,
    especially painful for mmc_power_up for eMMC when booting.
    
    However, it's added since 2009, and we can't tell if other platforms
    benefit from it. But in practise, the modern hardware are most likely to
    have a stable power supply with 1ms after setting it for no matter PMIC
    or discrete power. And more importnatly, most regulators implement the
    callback of ->set_voltage_time_sel() for regulator core to wait for
    specific period of time for the power supply to be stable, which means
    once regulator_set_voltage_* return, the power should reach the the
    minimum voltage that works for initialization. Of course, if there
    are some other ways for host to power the card, we should allow them
    to argue a suitable delay as well.
    
    With this patch, we could assign the delay from firmware, or we could
    assigne it via ->set_ios() callback from host drivers.
    
    Signed-off-by: Shawn Lin <shawn.lin@rock-chips.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 42cfcb64abe0..9a769edbabe0 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1660,7 +1660,7 @@ void mmc_power_up(struct mmc_host *host, u32 ocr)
 	 * This delay should be sufficient to allow the power supply
 	 * to reach the minimum voltage.
 	 */
-	mmc_delay(10);
+	mmc_delay(host->ios.power_delay_ms);
 
 	mmc_pwrseq_post_power_on(host);
 
@@ -1673,7 +1673,7 @@ void mmc_power_up(struct mmc_host *host, u32 ocr)
 	 * This delay must be at least 74 clock sizes, or 1 ms, or the
 	 * time required to reach a stable voltage.
 	 */
-	mmc_delay(10);
+	mmc_delay(host->ios.power_delay_ms);
 }
 
 void mmc_power_off(struct mmc_host *host)

commit 3ce7f76ff9033cbf966c1121ea59051b533f95ef
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Wed May 2 15:13:06 2018 +0200

    mmc: core: Drop unused define for timeout
    
    MMC_CORE_TIMEOUT_MS isn't being used no more, let's drop it.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 2c1a220531c4..42cfcb64abe0 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -50,9 +50,6 @@
 #include "sd_ops.h"
 #include "sdio_ops.h"
 
-/* If the device is not responding */
-#define MMC_CORE_TIMEOUT_MS	(10 * 60 * 1000) /* 10 minute timeout */
-
 /* The max erase timeout, used when host->max_busy_timeout isn't specified */
 #define MMC_ERASE_TIMEOUT_MS	(60 * 1000) /* 60 s */
 

commit 508c9864ccede5dd4b8a7220b3fe6998763e4407
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu Apr 5 21:24:15 2018 +0200

    mmc: core: Share internal function to set initial signal voltage
    
    Move the corresponding code for setting the initial signal voltage, from
    mmc_power_up() into a new function, mmc_set_initial_signal_voltage().
    
    Make the function internally available to the mmc core, as to allow the
    following changes to make use of it.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Tested-by: Quentin Schulz <quentin.schulz@bootlin.com>
    Reviewed-by: Shawn Lin <shawn.lin@rock-chips.com>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 7a79dc1599e5..2c1a220531c4 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1484,6 +1484,17 @@ int mmc_set_signal_voltage(struct mmc_host *host, int signal_voltage)
 
 }
 
+void mmc_set_initial_signal_voltage(struct mmc_host *host)
+{
+	/* Try to set signal voltage to 3.3V but fall back to 1.8v or 1.2v */
+	if (!mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_330))
+		dev_dbg(mmc_dev(host), "Initial signal voltage of 3.3v\n");
+	else if (!mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_180))
+		dev_dbg(mmc_dev(host), "Initial signal voltage of 1.8v\n");
+	else if (!mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_120))
+		dev_dbg(mmc_dev(host), "Initial signal voltage of 1.2v\n");
+}
+
 int mmc_host_set_uhs_voltage(struct mmc_host *host)
 {
 	u32 clock;
@@ -1646,13 +1657,7 @@ void mmc_power_up(struct mmc_host *host, u32 ocr)
 	/* Set initial state and call mmc_set_ios */
 	mmc_set_initial_state(host);
 
-	/* Try to set signal voltage to 3.3V but fall back to 1.8v or 1.2v */
-	if (!mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_330))
-		dev_dbg(mmc_dev(host), "Initial signal voltage of 3.3v\n");
-	else if (!mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_180))
-		dev_dbg(mmc_dev(host), "Initial signal voltage of 1.8v\n");
-	else if (!mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_120))
-		dev_dbg(mmc_dev(host), "Initial signal voltage of 1.2v\n");
+	mmc_set_initial_signal_voltage(host);
 
 	/*
 	 * This delay should be sufficient to allow the power supply

commit 1433269c4d2461be1f36db5dbb453976b38996ff
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu Apr 5 13:42:00 2018 +0200

    mmc: core: Export a function mmc_sw_reset() to allow soft reset of cards
    
    It's rather common that a firmware is loaded into an SDIO func device
    memory, by the corresponding SDIO func driver during ->probe() time.
    
    However, to actually start running the new firmware, sometimes a soft reset
    (no power cycle) and a re-initialization of the card is needed. This is for
    example the case with the Espressif ESP8089 WiFi chips, when connected to
    an SDIO interface.
    
    To cope with this scenario, let's add a new exported function,
    mmc_sw_reset(), which may be called when a soft reset and re-initialization
    of the card are needed.
    
    The mmc_sw_reset() is implemented on top of a new bus ops callback, similar
    to how the mmc_hw_reset() has been implemented.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Tested-by: Quentin Schulz <quentin.schulz@bootlin.com>
    Reviewed-by: Shawn Lin <shawn.lin@rock-chips.com>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 3e17c62eea86..7a79dc1599e5 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2451,6 +2451,30 @@ int mmc_hw_reset(struct mmc_host *host)
 }
 EXPORT_SYMBOL(mmc_hw_reset);
 
+int mmc_sw_reset(struct mmc_host *host)
+{
+	int ret;
+
+	if (!host->card)
+		return -EINVAL;
+
+	mmc_bus_get(host);
+	if (!host->bus_ops || host->bus_dead || !host->bus_ops->sw_reset) {
+		mmc_bus_put(host);
+		return -EOPNOTSUPP;
+	}
+
+	ret = host->bus_ops->sw_reset(host);
+	mmc_bus_put(host);
+
+	if (ret)
+		pr_warn("%s: tried to SW reset card, got error %d\n",
+			mmc_hostname(host), ret);
+
+	return ret;
+}
+EXPORT_SYMBOL(mmc_sw_reset);
+
 static int mmc_rescan_try_freq(struct mmc_host *host, unsigned freq)
 {
 	host->f_init = freq;

commit 3a3db6030b64ceb4b4e41a6811168c5d90a9f7f8
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu Apr 5 13:24:43 2018 +0200

    mmc: core: Rename ->reset() bus ops to ->hw_reset()
    
    The bus ops ->reset() executes a full HW reset of the card, as the calling
    function mmc_hw_reset() also indicates by its name. Let's convert to follow
    the similar names, for both the bus ops callback and for the corresponding
    bus ops functions, as to clarify the purpose of code.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Tested-by: Quentin Schulz <quentin.schulz@bootlin.com>
    Reviewed-by: Shawn Lin <shawn.lin@rock-chips.com>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 121ce50b6d5e..3e17c62eea86 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2435,16 +2435,16 @@ int mmc_hw_reset(struct mmc_host *host)
 		return -EINVAL;
 
 	mmc_bus_get(host);
-	if (!host->bus_ops || host->bus_dead || !host->bus_ops->reset) {
+	if (!host->bus_ops || host->bus_dead || !host->bus_ops->hw_reset) {
 		mmc_bus_put(host);
 		return -EOPNOTSUPP;
 	}
 
-	ret = host->bus_ops->reset(host);
+	ret = host->bus_ops->hw_reset(host);
 	mmc_bus_put(host);
 
 	if (ret)
-		pr_warn("%s: tried to reset card, got error %d\n",
+		pr_warn("%s: tried to HW reset card, got error %d\n",
 			mmc_hostname(host), ret);
 
 	return ret;

commit 36f1d7e817a5540f6624ce1007339688bd443308
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Tue Feb 27 14:51:25 2018 +0200

    mmc: slot-gpio: Add a function to enable/disable card detect IRQ wakeup
    
    Commit 03dbaa04a2e5 ("mmc: slot-gpio: Add support to enable irq wake on
    cd_irq") enabled wakeup at initialization. However drivers may wish to
    enable and disable based on different criteria. Add a helper function
    mmc_gpio_set_cd_wake() to make it easy for drivers to do that.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index e01910dd964b..121ce50b6d5e 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2655,8 +2655,7 @@ void mmc_start_host(struct mmc_host *host)
 void mmc_stop_host(struct mmc_host *host)
 {
 	if (host->slot.cd_irq >= 0) {
-		if (host->slot.cd_wake_enabled)
-			disable_irq_wake(host->slot.cd_irq);
+		mmc_gpio_set_cd_wake(host, false);
 		disable_irq(host->slot.cd_irq);
 	}
 

commit b305882fbc878f10ad089348da147987c330a2ee
Author: Sergio Valverde <vlvrdv@gmail.com>
Date:   Thu Feb 8 11:41:43 2018 -0600

    mmc: core: optimize mmc_calc_max_discard
    
    If the max_discard value is zero, the conditional branch that checks the
    trim capabilities will never update this value with max_trim.
    
    Change the condition statement to also check the max_discard value in order
    to avoid an unnecessary call to mmc_do_calc_max_discard.
    
    Signed-off-by: Sergio Valverde <vlvrdv@gmail.com>
    Reviewed-by: Shawn Lin <shawn.lin@rock-chip.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index c0ba6d8823b7..e01910dd964b 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2369,7 +2369,7 @@ unsigned int mmc_calc_max_discard(struct mmc_card *card)
 		return card->pref_erase;
 
 	max_discard = mmc_do_calc_max_discard(card, MMC_ERASE_ARG);
-	if (mmc_can_trim(card)) {
+	if (max_discard && mmc_can_trim(card)) {
 		max_trim = mmc_do_calc_max_discard(card, MMC_TRIM_ARG);
 		if (max_trim < max_discard)
 			max_discard = max_trim;

commit de8dcc3d2c0e08e5068ee1e26fc46415c15e3637
Author: Daniel Drake <drake@endlessm.com>
Date:   Tue Dec 12 10:49:02 2017 +0000

    mmc: avoid removing non-removable hosts during suspend
    
    The Weibu F3C MiniPC has an onboard AP6255 module, presenting
    two SDIO functions on a single MMC host (Bluetooth/btsdio and
    WiFi/brcmfmac), and the mmc layer correctly detects this as
    non-removable.
    
    After suspend/resume, the wifi and bluetooth interfaces disappear
    and do not get probed again.
    
    The conditions here are:
    
     1. During suspend, we reach mmc_pm_notify()
    
     2. mmc_pm_notify() calls mmc_sdio_pre_suspend() to see if we can
        suspend the SDIO host. However, mmc_sdio_pre_suspend() returns
        -ENOSYS because btsdio_driver does not have a suspend method.
    
     3. mmc_pm_notify() proceeds to remove the card
    
     4. Upon resume, mmc_rescan() does nothing with this host, because of
        the rescan_entered check which aims to only scan a non-removable
        device a single time (i.e. during boot).
    
    Fix the loss of functionality by detecting that we are unable to
    suspend a non-removable host, so avoid the forced removal in that
    case. The comment above this function already indicates that this
    code was only intended for removable devices.
    
    Signed-off-by: Daniel Drake <drake@endlessm.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index fd64e6d425e5..c0ba6d8823b7 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2761,6 +2761,14 @@ static int mmc_pm_notify(struct notifier_block *notify_block,
 		if (!err)
 			break;
 
+		if (!mmc_card_is_removable(host)) {
+			dev_warn(mmc_dev(host),
+				 "pre_suspend failed for non-removable host: "
+				 "%d\n", err);
+			/* Avoid removing non-removable hosts */
+			break;
+		}
+
 		/* Calling bus_ops->remove() with a claimed host can deadlock */
 		host->bus_ops->remove(host);
 		mmc_claim_host(host);

commit 126b62700386da782f83579e9b0431ea76c2da3d
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Wed Nov 29 15:41:19 2017 +0200

    mmc: core: Remove code no longer needed after the switch to blk-mq
    
    Remove code no longer needed after the switch to blk-mq.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Tested-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 2a137976107f..fd64e6d425e5 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -363,20 +363,6 @@ int mmc_start_request(struct mmc_host *host, struct mmc_request *mrq)
 }
 EXPORT_SYMBOL(mmc_start_request);
 
-/*
- * mmc_wait_data_done() - done callback for data request
- * @mrq: done data request
- *
- * Wakes up mmc context, passed as a callback to host controller driver
- */
-static void mmc_wait_data_done(struct mmc_request *mrq)
-{
-	struct mmc_context_info *context_info = &mrq->host->context_info;
-
-	context_info->is_done_rcv = true;
-	wake_up_interruptible(&context_info->wait);
-}
-
 static void mmc_wait_done(struct mmc_request *mrq)
 {
 	complete(&mrq->completion);
@@ -394,35 +380,6 @@ static inline void mmc_wait_ongoing_tfr_cmd(struct mmc_host *host)
 		wait_for_completion(&ongoing_mrq->cmd_completion);
 }
 
-/*
- *__mmc_start_data_req() - starts data request
- * @host: MMC host to start the request
- * @mrq: data request to start
- *
- * Sets the done callback to be called when request is completed by the card.
- * Starts data mmc request execution
- * If an ongoing transfer is already in progress, wait for the command line
- * to become available before sending another command.
- */
-static int __mmc_start_data_req(struct mmc_host *host, struct mmc_request *mrq)
-{
-	int err;
-
-	mmc_wait_ongoing_tfr_cmd(host);
-
-	mrq->done = mmc_wait_data_done;
-	mrq->host = host;
-
-	err = mmc_start_request(host, mrq);
-	if (err) {
-		mrq->cmd->error = err;
-		mmc_complete_cmd(mrq);
-		mmc_wait_data_done(mrq);
-	}
-
-	return err;
-}
-
 static int __mmc_start_req(struct mmc_host *host, struct mmc_request *mrq)
 {
 	int err;
@@ -648,132 +605,10 @@ EXPORT_SYMBOL(mmc_cqe_recovery);
  */
 bool mmc_is_req_done(struct mmc_host *host, struct mmc_request *mrq)
 {
-	if (host->areq)
-		return host->context_info.is_done_rcv;
-	else
-		return completion_done(&mrq->completion);
+	return completion_done(&mrq->completion);
 }
 EXPORT_SYMBOL(mmc_is_req_done);
 
-/**
- * mmc_finalize_areq() - finalize an asynchronous request
- * @host: MMC host to finalize any ongoing request on
- *
- * Returns the status of the ongoing asynchronous request, but
- * MMC_BLK_SUCCESS if no request was going on.
- */
-static enum mmc_blk_status mmc_finalize_areq(struct mmc_host *host)
-{
-	struct mmc_context_info *context_info = &host->context_info;
-	enum mmc_blk_status status;
-
-	if (!host->areq)
-		return MMC_BLK_SUCCESS;
-
-	while (1) {
-		wait_event_interruptible(context_info->wait,
-				(context_info->is_done_rcv ||
-				 context_info->is_new_req));
-
-		if (context_info->is_done_rcv) {
-			struct mmc_command *cmd;
-
-			context_info->is_done_rcv = false;
-			cmd = host->areq->mrq->cmd;
-
-			if (!cmd->error || !cmd->retries ||
-			    mmc_card_removed(host->card)) {
-				status = host->areq->err_check(host->card,
-							       host->areq);
-				break; /* return status */
-			} else {
-				mmc_retune_recheck(host);
-				pr_info("%s: req failed (CMD%u): %d, retrying...\n",
-					mmc_hostname(host),
-					cmd->opcode, cmd->error);
-				cmd->retries--;
-				cmd->error = 0;
-				__mmc_start_request(host, host->areq->mrq);
-				continue; /* wait for done/new event again */
-			}
-		}
-
-		return MMC_BLK_NEW_REQUEST;
-	}
-
-	mmc_retune_release(host);
-
-	/*
-	 * Check BKOPS urgency for each R1 response
-	 */
-	if (host->card && mmc_card_mmc(host->card) &&
-	    ((mmc_resp_type(host->areq->mrq->cmd) == MMC_RSP_R1) ||
-	     (mmc_resp_type(host->areq->mrq->cmd) == MMC_RSP_R1B)) &&
-	    (host->areq->mrq->cmd->resp[0] & R1_EXCEPTION_EVENT)) {
-		mmc_start_bkops(host->card, true);
-	}
-
-	return status;
-}
-
-/**
- *	mmc_start_areq - start an asynchronous request
- *	@host: MMC host to start command
- *	@areq: asynchronous request to start
- *	@ret_stat: out parameter for status
- *
- *	Start a new MMC custom command request for a host.
- *	If there is on ongoing async request wait for completion
- *	of that request and start the new one and return.
- *	Does not wait for the new request to complete.
- *
- *      Returns the completed request, NULL in case of none completed.
- *	Wait for the an ongoing request (previoulsy started) to complete and
- *	return the completed request. If there is no ongoing request, NULL
- *	is returned without waiting. NULL is not an error condition.
- */
-struct mmc_async_req *mmc_start_areq(struct mmc_host *host,
-				     struct mmc_async_req *areq,
-				     enum mmc_blk_status *ret_stat)
-{
-	enum mmc_blk_status status;
-	int start_err = 0;
-	struct mmc_async_req *previous = host->areq;
-
-	/* Prepare a new request */
-	if (areq)
-		mmc_pre_req(host, areq->mrq);
-
-	/* Finalize previous request */
-	status = mmc_finalize_areq(host);
-	if (ret_stat)
-		*ret_stat = status;
-
-	/* The previous request is still going on... */
-	if (status == MMC_BLK_NEW_REQUEST)
-		return NULL;
-
-	/* Fine so far, start the new request! */
-	if (status == MMC_BLK_SUCCESS && areq)
-		start_err = __mmc_start_data_req(host, areq->mrq);
-
-	/* Postprocess the old request at this point */
-	if (host->areq)
-		mmc_post_req(host, host->areq->mrq, 0);
-
-	/* Cancel a prepared request if it was not started. */
-	if ((status != MMC_BLK_SUCCESS || start_err) && areq)
-		mmc_post_req(host, areq->mrq, -EINVAL);
-
-	if (status != MMC_BLK_SUCCESS)
-		host->areq = NULL;
-	else
-		host->areq = areq;
-
-	return previous;
-}
-EXPORT_SYMBOL(mmc_start_areq);
-
 /**
  *	mmc_wait_for_req - start a request and wait for completion
  *	@host: MMC host to start command
@@ -2961,22 +2796,6 @@ void mmc_unregister_pm_notifier(struct mmc_host *host)
 }
 #endif
 
-/**
- * mmc_init_context_info() - init synchronization context
- * @host: mmc host
- *
- * Init struct context_info needed to implement asynchronous
- * request mechanism, used by mmc core, host driver and mmc requests
- * supplier.
- */
-void mmc_init_context_info(struct mmc_host *host)
-{
-	host->context_info.is_new_req = false;
-	host->context_info.is_done_rcv = false;
-	host->context_info.is_waiting_last_req = false;
-	init_waitqueue_head(&host->context_info.wait);
-}
-
 static int __init mmc_init(void)
 {
 	int ret;

commit 1bec43a3b181baebdf8a4cd739b480a9132601d7
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Wed Nov 29 15:41:17 2017 +0200

    mmc: core: Remove option not to use blk-mq
    
    Remove config option MMC_MQ_DEFAULT and parameter mmc_use_blk_mq, so that
    blk-mq must be used always.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Tested-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 455abbf4f41e..2a137976107f 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -66,13 +66,6 @@ static const unsigned freqs[] = { 400000, 300000, 200000, 100000 };
 bool use_spi_crc = 1;
 module_param(use_spi_crc, bool, 0);
 
-#ifdef CONFIG_MMC_MQ_DEFAULT
-bool mmc_use_blk_mq = true;
-#else
-bool mmc_use_blk_mq = false;
-#endif
-module_param_named(use_blk_mq, mmc_use_blk_mq, bool, S_IWUSR | S_IRUGO);
-
 static int mmc_schedule_delayed_work(struct delayed_work *work,
 				     unsigned long delay)
 {

commit d2383318c5a626312d166217e3788e54b1650c56
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Fri Dec 1 14:55:30 2017 +0200

    mmc: core: Ensure cmd_completion is initialized
    
    mmc_test now uses mmc_start_request() to test sending commands during
    "ongoing" asynchronous transfers, i.e. tests:
            Commands during non-blocking read - use Set Block Count (CMD23)
            Commands during non-blocking write - use Set Block Count (CMD23)
    
    mmc_start_request() was not initializing cmd_completion, but cmd_completion
    is used by "ongoing" transfers, so move initialization of cmd_completion
    into making mmc_start_request().
    
    Fixes: cb39f61e9b1e ("mmc: core: Export a few functions needed for blkmq support")
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 617802f45386..455abbf4f41e 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -348,6 +348,8 @@ int mmc_start_request(struct mmc_host *host, struct mmc_request *mrq)
 {
 	int err;
 
+	init_completion(&mrq->cmd_completion);
+
 	mmc_retune_hold(host);
 
 	if (mmc_card_removed(host->card))
@@ -418,8 +420,6 @@ static int __mmc_start_data_req(struct mmc_host *host, struct mmc_request *mrq)
 	mrq->done = mmc_wait_data_done;
 	mrq->host = host;
 
-	init_completion(&mrq->cmd_completion);
-
 	err = mmc_start_request(host, mrq);
 	if (err) {
 		mrq->cmd->error = err;
@@ -439,8 +439,6 @@ static int __mmc_start_req(struct mmc_host *host, struct mmc_request *mrq)
 	init_completion(&mrq->completion);
 	mrq->done = mmc_wait_done;
 
-	init_completion(&mrq->cmd_completion);
-
 	err = mmc_start_request(host, mrq);
 	if (err) {
 		mrq->cmd->error = err;

commit c3d53d0da69d127f488dc85638e9440220b268e8
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Wed Nov 29 15:41:02 2017 +0200

    mmc: core: Add parameter use_blk_mq
    
    Until mmc has blk-mq support fully implemented and tested, add a parameter
    use_blk_mq, set to true if config option MMC_MQ_DEFAULT is selected, which
    it is by default.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Tested-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 7ca6e4866a8b..617802f45386 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -66,6 +66,13 @@ static const unsigned freqs[] = { 400000, 300000, 200000, 100000 };
 bool use_spi_crc = 1;
 module_param(use_spi_crc, bool, 0);
 
+#ifdef CONFIG_MMC_MQ_DEFAULT
+bool mmc_use_blk_mq = true;
+#else
+bool mmc_use_blk_mq = false;
+#endif
+module_param_named(use_blk_mq, mmc_use_blk_mq, bool, S_IWUSR | S_IRUGO);
+
 static int mmc_schedule_delayed_work(struct delayed_work *work,
 				     unsigned long delay)
 {

commit afab1bb8b40c61458e009fdc323c9740f95fcd5b
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Wed Nov 29 15:41:00 2017 +0200

    mmc: core: Make mmc_pre_req() and mmc_post_req() available
    
    Make mmc_pre_req() and mmc_post_req() available to the card drivers. Later
    patches will make use of this.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Tested-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 1f0f44f4dd5f..7ca6e4866a8b 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -657,37 +657,6 @@ bool mmc_is_req_done(struct mmc_host *host, struct mmc_request *mrq)
 }
 EXPORT_SYMBOL(mmc_is_req_done);
 
-/**
- *	mmc_pre_req - Prepare for a new request
- *	@host: MMC host to prepare command
- *	@mrq: MMC request to prepare for
- *
- *	mmc_pre_req() is called in prior to mmc_start_req() to let
- *	host prepare for the new request. Preparation of a request may be
- *	performed while another request is running on the host.
- */
-static void mmc_pre_req(struct mmc_host *host, struct mmc_request *mrq)
-{
-	if (host->ops->pre_req)
-		host->ops->pre_req(host, mrq);
-}
-
-/**
- *	mmc_post_req - Post process a completed request
- *	@host: MMC host to post process command
- *	@mrq: MMC request to post process for
- *	@err: Error, if non zero, clean up any resources made in pre_req
- *
- *	Let the host post process a completed request. Post processing of
- *	a request may be performed while another reuqest is running.
- */
-static void mmc_post_req(struct mmc_host *host, struct mmc_request *mrq,
-			 int err)
-{
-	if (host->ops->post_req)
-		host->ops->post_req(host, mrq, err);
-}
-
 /**
  * mmc_finalize_areq() - finalize an asynchronous request
  * @host: MMC host to finalize any ongoing request on

commit 1f90e9a38c469e5abc1c7e06a8dd33dd9d2b922d
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Sat Oct 14 21:17:09 2017 +0200

    mmc: add kerneldoc to mmc_regulator_get_supply()
    
    Especially, make clear what the return value means.
    
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 12b271c2a912..1f0f44f4dd5f 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1588,6 +1588,16 @@ EXPORT_SYMBOL_GPL(mmc_regulator_set_vqmmc);
 
 #endif /* CONFIG_REGULATOR */
 
+/**
+ * mmc_regulator_get_supply - try to get VMMC and VQMMC regulators for a host
+ * @mmc: the host to regulate
+ *
+ * Returns 0 or errno. errno should be handled, it is either a critical error
+ * or -EPROBE_DEFER. 0 means no critical error but it does not mean all
+ * regulators have been found because they all are optional. If you require
+ * certain regulators, you need to check separately in your driver if they got
+ * populated after calling this function.
+ */
 int mmc_regulator_get_supply(struct mmc_host *mmc)
 {
 	struct device *dev = mmc_dev(mmc);

commit 3f496afb6fb361b282f37968ff7d3d80b0f1b5cb
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Mon Sep 25 11:29:03 2017 +0300

    mmc: core: Factor out mmc_host_set_uhs_voltage()
    
    Factor out mmc_host_set_uhs_voltage() so it can be reused.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index a9ee960fbb7e..12b271c2a912 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1672,11 +1672,33 @@ int mmc_set_signal_voltage(struct mmc_host *host, int signal_voltage)
 
 }
 
+int mmc_host_set_uhs_voltage(struct mmc_host *host)
+{
+	u32 clock;
+
+	/*
+	 * During a signal voltage level switch, the clock must be gated
+	 * for 5 ms according to the SD spec
+	 */
+	clock = host->ios.clock;
+	host->ios.clock = 0;
+	mmc_set_ios(host);
+
+	if (mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_180))
+		return -EAGAIN;
+
+	/* Keep clock gated for at least 10 ms, though spec only says 5 ms */
+	mmc_delay(10);
+	host->ios.clock = clock;
+	mmc_set_ios(host);
+
+	return 0;
+}
+
 int mmc_set_uhs_voltage(struct mmc_host *host, u32 ocr)
 {
 	struct mmc_command cmd = {};
 	int err = 0;
-	u32 clock;
 
 	/*
 	 * If we cannot switch voltages, return failure so the caller
@@ -1708,15 +1730,8 @@ int mmc_set_uhs_voltage(struct mmc_host *host, u32 ocr)
 		err = -EAGAIN;
 		goto power_cycle;
 	}
-	/*
-	 * During a signal voltage level switch, the clock must be gated
-	 * for 5 ms according to the SD spec
-	 */
-	clock = host->ios.clock;
-	host->ios.clock = 0;
-	mmc_set_ios(host);
 
-	if (mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_180)) {
+	if (mmc_host_set_uhs_voltage(host)) {
 		/*
 		 * Voltages may not have been switched, but we've already
 		 * sent CMD11, so a power cycle is required anyway
@@ -1725,11 +1740,6 @@ int mmc_set_uhs_voltage(struct mmc_host *host, u32 ocr)
 		goto power_cycle;
 	}
 
-	/* Keep clock gated for at least 10 ms, though spec only says 5 ms */
-	mmc_delay(10);
-	host->ios.clock = clock;
-	mmc_set_ios(host);
-
 	/* Wait for at least 1 ms according to spec */
 	mmc_delay(1);
 

commit cb39f61e9b1e675c8df86df69d53f08334b34077
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Fri Sep 22 15:36:59 2017 +0300

    mmc: core: Export a few functions needed for blkmq support
    
    The following functions are needed by the mmc block device driver, once it
    converts to blkmq, therefore let's export them.
    
    mmc_start_bkops()
    mmc_start_request()
    mmc_retune_hold_now()
    mmc_retune_release()
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 2ff614d4ffac..a9ee960fbb7e 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -337,7 +337,7 @@ static int mmc_mrq_prep(struct mmc_host *host, struct mmc_request *mrq)
 	return 0;
 }
 
-static int mmc_start_request(struct mmc_host *host, struct mmc_request *mrq)
+int mmc_start_request(struct mmc_host *host, struct mmc_request *mrq)
 {
 	int err;
 
@@ -359,6 +359,7 @@ static int mmc_start_request(struct mmc_host *host, struct mmc_request *mrq)
 
 	return 0;
 }
+EXPORT_SYMBOL(mmc_start_request);
 
 /*
  * mmc_wait_data_done() - done callback for data request

commit 72a5af554df837e373efb0d6c8fc68c568f9a7ac
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Fri Sep 22 15:36:52 2017 +0300

    mmc: core: Add support for handling CQE requests
    
    Add core support for handling CQE requests, including starting, completing
    and recovering.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index b997cf92ce6c..2ff614d4ffac 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -266,7 +266,8 @@ static void __mmc_start_request(struct mmc_host *host, struct mmc_request *mrq)
 	host->ops->request(host, mrq);
 }
 
-static void mmc_mrq_pr_debug(struct mmc_host *host, struct mmc_request *mrq)
+static void mmc_mrq_pr_debug(struct mmc_host *host, struct mmc_request *mrq,
+			     bool cqe)
 {
 	if (mrq->sbc) {
 		pr_debug("<%s: starting CMD%u arg %08x flags %08x>\n",
@@ -275,9 +276,12 @@ static void mmc_mrq_pr_debug(struct mmc_host *host, struct mmc_request *mrq)
 	}
 
 	if (mrq->cmd) {
-		pr_debug("%s: starting CMD%u arg %08x flags %08x\n",
-			 mmc_hostname(host), mrq->cmd->opcode, mrq->cmd->arg,
-			 mrq->cmd->flags);
+		pr_debug("%s: starting %sCMD%u arg %08x flags %08x\n",
+			 mmc_hostname(host), cqe ? "CQE direct " : "",
+			 mrq->cmd->opcode, mrq->cmd->arg, mrq->cmd->flags);
+	} else if (cqe) {
+		pr_debug("%s: starting CQE transfer for tag %d blkaddr %u\n",
+			 mmc_hostname(host), mrq->tag, mrq->data->blk_addr);
 	}
 
 	if (mrq->data) {
@@ -342,7 +346,7 @@ static int mmc_start_request(struct mmc_host *host, struct mmc_request *mrq)
 	if (mmc_card_removed(host->card))
 		return -ENOMEDIUM;
 
-	mmc_mrq_pr_debug(host, mrq);
+	mmc_mrq_pr_debug(host, mrq, false);
 
 	WARN_ON(!host->claimed);
 
@@ -482,6 +486,155 @@ void mmc_wait_for_req_done(struct mmc_host *host, struct mmc_request *mrq)
 }
 EXPORT_SYMBOL(mmc_wait_for_req_done);
 
+/*
+ * mmc_cqe_start_req - Start a CQE request.
+ * @host: MMC host to start the request
+ * @mrq: request to start
+ *
+ * Start the request, re-tuning if needed and it is possible. Returns an error
+ * code if the request fails to start or -EBUSY if CQE is busy.
+ */
+int mmc_cqe_start_req(struct mmc_host *host, struct mmc_request *mrq)
+{
+	int err;
+
+	/*
+	 * CQE cannot process re-tuning commands. Caller must hold retuning
+	 * while CQE is in use.  Re-tuning can happen here only when CQE has no
+	 * active requests i.e. this is the first.  Note, re-tuning will call
+	 * ->cqe_off().
+	 */
+	err = mmc_retune(host);
+	if (err)
+		goto out_err;
+
+	mrq->host = host;
+
+	mmc_mrq_pr_debug(host, mrq, true);
+
+	err = mmc_mrq_prep(host, mrq);
+	if (err)
+		goto out_err;
+
+	err = host->cqe_ops->cqe_request(host, mrq);
+	if (err)
+		goto out_err;
+
+	trace_mmc_request_start(host, mrq);
+
+	return 0;
+
+out_err:
+	if (mrq->cmd) {
+		pr_debug("%s: failed to start CQE direct CMD%u, error %d\n",
+			 mmc_hostname(host), mrq->cmd->opcode, err);
+	} else {
+		pr_debug("%s: failed to start CQE transfer for tag %d, error %d\n",
+			 mmc_hostname(host), mrq->tag, err);
+	}
+	return err;
+}
+EXPORT_SYMBOL(mmc_cqe_start_req);
+
+/**
+ *	mmc_cqe_request_done - CQE has finished processing an MMC request
+ *	@host: MMC host which completed request
+ *	@mrq: MMC request which completed
+ *
+ *	CQE drivers should call this function when they have completed
+ *	their processing of a request.
+ */
+void mmc_cqe_request_done(struct mmc_host *host, struct mmc_request *mrq)
+{
+	mmc_should_fail_request(host, mrq);
+
+	/* Flag re-tuning needed on CRC errors */
+	if ((mrq->cmd && mrq->cmd->error == -EILSEQ) ||
+	    (mrq->data && mrq->data->error == -EILSEQ))
+		mmc_retune_needed(host);
+
+	trace_mmc_request_done(host, mrq);
+
+	if (mrq->cmd) {
+		pr_debug("%s: CQE req done (direct CMD%u): %d\n",
+			 mmc_hostname(host), mrq->cmd->opcode, mrq->cmd->error);
+	} else {
+		pr_debug("%s: CQE transfer done tag %d\n",
+			 mmc_hostname(host), mrq->tag);
+	}
+
+	if (mrq->data) {
+		pr_debug("%s:     %d bytes transferred: %d\n",
+			 mmc_hostname(host),
+			 mrq->data->bytes_xfered, mrq->data->error);
+	}
+
+	mrq->done(mrq);
+}
+EXPORT_SYMBOL(mmc_cqe_request_done);
+
+/**
+ *	mmc_cqe_post_req - CQE post process of a completed MMC request
+ *	@host: MMC host
+ *	@mrq: MMC request to be processed
+ */
+void mmc_cqe_post_req(struct mmc_host *host, struct mmc_request *mrq)
+{
+	if (host->cqe_ops->cqe_post_req)
+		host->cqe_ops->cqe_post_req(host, mrq);
+}
+EXPORT_SYMBOL(mmc_cqe_post_req);
+
+/* Arbitrary 1 second timeout */
+#define MMC_CQE_RECOVERY_TIMEOUT	1000
+
+/*
+ * mmc_cqe_recovery - Recover from CQE errors.
+ * @host: MMC host to recover
+ *
+ * Recovery consists of stopping CQE, stopping eMMC, discarding the queue in
+ * in eMMC, and discarding the queue in CQE. CQE must call
+ * mmc_cqe_request_done() on all requests. An error is returned if the eMMC
+ * fails to discard its queue.
+ */
+int mmc_cqe_recovery(struct mmc_host *host)
+{
+	struct mmc_command cmd;
+	int err;
+
+	mmc_retune_hold_now(host);
+
+	/*
+	 * Recovery is expected seldom, if at all, but it reduces performance,
+	 * so make sure it is not completely silent.
+	 */
+	pr_warn("%s: running CQE recovery\n", mmc_hostname(host));
+
+	host->cqe_ops->cqe_recovery_start(host);
+
+	memset(&cmd, 0, sizeof(cmd));
+	cmd.opcode       = MMC_STOP_TRANSMISSION,
+	cmd.flags        = MMC_RSP_R1B | MMC_CMD_AC,
+	cmd.flags       &= ~MMC_RSP_CRC; /* Ignore CRC */
+	cmd.busy_timeout = MMC_CQE_RECOVERY_TIMEOUT,
+	mmc_wait_for_cmd(host, &cmd, 0);
+
+	memset(&cmd, 0, sizeof(cmd));
+	cmd.opcode       = MMC_CMDQ_TASK_MGMT;
+	cmd.arg          = 1; /* Discard entire queue */
+	cmd.flags        = MMC_RSP_R1B | MMC_CMD_AC;
+	cmd.flags       &= ~MMC_RSP_CRC; /* Ignore CRC */
+	cmd.busy_timeout = MMC_CQE_RECOVERY_TIMEOUT,
+	err = mmc_wait_for_cmd(host, &cmd, 0);
+
+	host->cqe_ops->cqe_recovery_finish(host);
+
+	mmc_retune_release(host);
+
+	return err;
+}
+EXPORT_SYMBOL(mmc_cqe_recovery);
+
 /**
  *	mmc_is_req_done - Determine if a 'cap_cmd_during_tfr' request is done
  *	@host: MMC host

commit 6c0cedd1ef9527ef13e66875746570e76a3188a7
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Fri Sep 22 15:36:51 2017 +0300

    mmc: core: Introduce host claiming by context
    
    Currently the host can be claimed by a task.  Change this so that the host
    can be claimed by a context that may or may not be a task.  This provides
    for the host to be claimed by a block driver queue to support blk-mq, while
    maintaining compatibility with the existing use of mmc_claim_host().
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 66c9cf49ad2f..b997cf92ce6c 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -832,9 +832,36 @@ unsigned int mmc_align_data_size(struct mmc_card *card, unsigned int sz)
 }
 EXPORT_SYMBOL(mmc_align_data_size);
 
+/*
+ * Allow claiming an already claimed host if the context is the same or there is
+ * no context but the task is the same.
+ */
+static inline bool mmc_ctx_matches(struct mmc_host *host, struct mmc_ctx *ctx,
+				   struct task_struct *task)
+{
+	return host->claimer == ctx ||
+	       (!ctx && task && host->claimer->task == task);
+}
+
+static inline void mmc_ctx_set_claimer(struct mmc_host *host,
+				       struct mmc_ctx *ctx,
+				       struct task_struct *task)
+{
+	if (!host->claimer) {
+		if (ctx)
+			host->claimer = ctx;
+		else
+			host->claimer = &host->default_ctx;
+	}
+	if (task)
+		host->claimer->task = task;
+}
+
 /**
  *	__mmc_claim_host - exclusively claim a host
  *	@host: mmc host to claim
+ *	@ctx: context that claims the host or NULL in which case the default
+ *	context will be used
  *	@abort: whether or not the operation should be aborted
  *
  *	Claim a host for a set of operations.  If @abort is non null and
@@ -842,8 +869,10 @@ EXPORT_SYMBOL(mmc_align_data_size);
  *	that non-zero value without acquiring the lock.  Returns zero
  *	with the lock held otherwise.
  */
-int __mmc_claim_host(struct mmc_host *host, atomic_t *abort)
+int __mmc_claim_host(struct mmc_host *host, struct mmc_ctx *ctx,
+		     atomic_t *abort)
 {
+	struct task_struct *task = ctx ? NULL : current;
 	DECLARE_WAITQUEUE(wait, current);
 	unsigned long flags;
 	int stop;
@@ -856,7 +885,7 @@ int __mmc_claim_host(struct mmc_host *host, atomic_t *abort)
 	while (1) {
 		set_current_state(TASK_UNINTERRUPTIBLE);
 		stop = abort ? atomic_read(abort) : 0;
-		if (stop || !host->claimed || host->claimer == current)
+		if (stop || !host->claimed || mmc_ctx_matches(host, ctx, task))
 			break;
 		spin_unlock_irqrestore(&host->lock, flags);
 		schedule();
@@ -865,7 +894,7 @@ int __mmc_claim_host(struct mmc_host *host, atomic_t *abort)
 	set_current_state(TASK_RUNNING);
 	if (!stop) {
 		host->claimed = 1;
-		host->claimer = current;
+		mmc_ctx_set_claimer(host, ctx, task);
 		host->claim_cnt += 1;
 		if (host->claim_cnt == 1)
 			pm = true;
@@ -900,6 +929,7 @@ void mmc_release_host(struct mmc_host *host)
 		spin_unlock_irqrestore(&host->lock, flags);
 	} else {
 		host->claimed = 0;
+		host->claimer->task = NULL;
 		host->claimer = NULL;
 		spin_unlock_irqrestore(&host->lock, flags);
 		wake_up(&host->wq);
@@ -913,10 +943,10 @@ EXPORT_SYMBOL(mmc_release_host);
  * This is a helper function, which fetches a runtime pm reference for the
  * card device and also claims the host.
  */
-void mmc_get_card(struct mmc_card *card)
+void mmc_get_card(struct mmc_card *card, struct mmc_ctx *ctx)
 {
 	pm_runtime_get_sync(&card->dev);
-	mmc_claim_host(card->host);
+	__mmc_claim_host(card->host, ctx, NULL);
 }
 EXPORT_SYMBOL(mmc_get_card);
 
@@ -924,9 +954,13 @@ EXPORT_SYMBOL(mmc_get_card);
  * This is a helper function, which releases the host and drops the runtime
  * pm reference for the card device.
  */
-void mmc_put_card(struct mmc_card *card)
+void mmc_put_card(struct mmc_card *card, struct mmc_ctx *ctx)
 {
-	mmc_release_host(card->host);
+	struct mmc_host *host = card->host;
+
+	WARN_ON(ctx && host->claimer != ctx);
+
+	mmc_release_host(host);
 	pm_runtime_mark_last_busy(&card->dev);
 	pm_runtime_put_autosuspend(&card->dev);
 }

commit 3e207c8cfaa900590590d2dfdbc5be155f258d7b
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Thu Aug 10 15:08:09 2017 +0300

    mmc: core: Turn off CQE before sending commands
    
    CQE needs to be off for the host controller to accept non-CQ commands. Turn
    off the CQE before sending commands, and ensure it is off in any reset or
    power management paths, or re-tuning.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 5dd1c00d95f5..66c9cf49ad2f 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -260,6 +260,9 @@ static void __mmc_start_request(struct mmc_host *host, struct mmc_request *mrq)
 
 	trace_mmc_request_start(host, mrq);
 
+	if (host->cqe_on)
+		host->cqe_ops->cqe_off(host);
+
 	host->ops->request(host, mrq);
 }
 
@@ -979,6 +982,9 @@ int mmc_execute_tuning(struct mmc_card *card)
 	if (!host->ops->execute_tuning)
 		return 0;
 
+	if (host->cqe_on)
+		host->cqe_ops->cqe_off(host);
+
 	if (mmc_card_mmc(card))
 		opcode = MMC_SEND_TUNING_BLOCK_HS200;
 	else
@@ -1018,6 +1024,9 @@ void mmc_set_bus_width(struct mmc_host *host, unsigned int width)
  */
 void mmc_set_initial_state(struct mmc_host *host)
 {
+	if (host->cqe_on)
+		host->cqe_ops->cqe_off(host);
+
 	mmc_retune_disable(host);
 
 	if (mmc_host_is_spi(host))

commit 6ca2920d8eb7bfd6d4e1bec00eca96954319cad9
Author: Shawn Lin <shawn.lin@rock-chips.com>
Date:   Mon Aug 7 10:07:14 2017 +0800

    mmc: core: remove the check of mmc_card_blockaddr for SD cards
    
    Per the SD physical layer simplified specification V4.10,
    section 4.6.2, CSD version 1.0 SD card should use taac, nsac
    and r2w_factor for calculating the data access time. But the
    taac and nsac for SDHC(CSD version 2.0) are always fixed and
    the software should use the recommended value for timeout. When
    parsing the CSD, we sanely set them to zero for SDHC(CSD version
    2.0), all the calculation for timeout_ns and timeout_clk is zero
    as well. So what we actually want to limit here is either SDHC
    case or unreasonable timeout reported by the cards. In principle
    we should at least be able to remove the bogus check for the
    mmc_card_blockaddr.
    
    Signed-off-by: Shawn Lin <shawn.lin@rock-chips.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 6177eb09bf1b..5dd1c00d95f5 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -763,7 +763,7 @@ void mmc_set_data_timeout(struct mmc_data *data, const struct mmc_card *card)
 		/*
 		 * SDHC cards always use these fixed values.
 		 */
-		if (timeout_us > limit_us || mmc_card_blockaddr(card)) {
+		if (timeout_us > limit_us) {
 			data->timeout_ns = limit_us * 1000;
 			data->timeout_clks = 0;
 		}

commit 4406ae215b5a1dd59d941c1323b9f40d241357ac
Author: Shawn Lin <shawn.lin@rock-chips.com>
Date:   Wed Aug 2 11:12:42 2017 +0800

    mmc: core: correct taac parameter according to the specification
    
    Per the spec of JESD84-B51, section 7.3, replace tacc with taac to
    fix the obvious typo.
    
    Signed-off-by: Shawn Lin <shawn.lin@rock-chips.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 15623ccdcd8a..6177eb09bf1b 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -733,8 +733,8 @@ void mmc_set_data_timeout(struct mmc_data *data, const struct mmc_card *card)
 	if (data->flags & MMC_DATA_WRITE)
 		mult <<= card->csd.r2w_factor;
 
-	data->timeout_ns = card->csd.tacc_ns * mult;
-	data->timeout_clks = card->csd.tacc_clks * mult;
+	data->timeout_ns = card->csd.taac_ns * mult;
+	data->timeout_clks = card->csd.taac_clks * mult;
 
 	/*
 	 * SD cards also have an upper limit on the timeout.
@@ -1859,14 +1859,14 @@ static unsigned int mmc_mmc_erase_timeout(struct mmc_card *card,
 	} else {
 		/* CSD Erase Group Size uses write timeout */
 		unsigned int mult = (10 << card->csd.r2w_factor);
-		unsigned int timeout_clks = card->csd.tacc_clks * mult;
+		unsigned int timeout_clks = card->csd.taac_clks * mult;
 		unsigned int timeout_us;
 
-		/* Avoid overflow: e.g. tacc_ns=80000000 mult=1280 */
-		if (card->csd.tacc_ns < 1000000)
-			timeout_us = (card->csd.tacc_ns * mult) / 1000;
+		/* Avoid overflow: e.g. taac_ns=80000000 mult=1280 */
+		if (card->csd.taac_ns < 1000000)
+			timeout_us = (card->csd.taac_ns * mult) / 1000;
 		else
-			timeout_us = (card->csd.tacc_ns / 1000) * mult;
+			timeout_us = (card->csd.taac_ns / 1000) * mult;
 
 		/*
 		 * ios.clock is only a target.  The real clock rate might be

commit bf892de9fb15b23e47fa4279b4595354661dfb19
Author: Rob Herring <robh@kernel.org>
Date:   Tue Jul 18 16:43:16 2017 -0500

    mmc: Convert to using %pOF instead of full_name
    
    Now that we have a custom printf format specifier, convert users of
    full_name to use %pOF instead. This is preparation to remove storing
    of the full path string for each node.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Cc: Ulf Hansson <ulf.hansson@linaro.org>
    Cc: Ludovic Desroches <ludovic.desroches@microchip.com>
    Cc: Jan Glauber <jglauber@cavium.com>
    Cc: David Daney <david.daney@cavium.com>
    Cc: "Steven J. Hill" <Steven.Hill@cavium.com>
    Cc: linux-mmc@vger.kernel.org
    Acked-by: David Daney <david.daney@cavium.com>
    Tested-by: Steven J. Hill <Steven.Hill@cavium.com>
    Acked-by: Ludovic Desroches <ludovic.desroches@microchip.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 731aa9f1ee8e..15623ccdcd8a 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1134,11 +1134,11 @@ int mmc_of_parse_voltage(struct device_node *np, u32 *mask)
 	voltage_ranges = of_get_property(np, "voltage-ranges", &num_ranges);
 	num_ranges = num_ranges / sizeof(*voltage_ranges) / 2;
 	if (!voltage_ranges) {
-		pr_debug("%s: voltage-ranges unspecified\n", np->full_name);
+		pr_debug("%pOF: voltage-ranges unspecified\n", np);
 		return 0;
 	}
 	if (!num_ranges) {
-		pr_err("%s: voltage-ranges empty\n", np->full_name);
+		pr_err("%pOF: voltage-ranges empty\n", np);
 		return -EINVAL;
 	}
 
@@ -1150,8 +1150,8 @@ int mmc_of_parse_voltage(struct device_node *np, u32 *mask)
 				be32_to_cpu(voltage_ranges[j]),
 				be32_to_cpu(voltage_ranges[j + 1]));
 		if (!ocr_mask) {
-			pr_err("%s: voltage-range #%d is invalid\n",
-				np->full_name, i);
+			pr_err("%pOF: voltage-range #%d is invalid\n",
+				np, i);
 			return -EINVAL;
 		}
 		*mask |= ocr_mask;

commit 69f25f9bb0cd7a59c3f1d0ecb541049c2e5fb0f9
Author: Shawn Lin <shawn.lin@rock-chips.com>
Date:   Wed Jul 19 15:55:46 2017 +0800

    mmc: core: turn the pr_info under CONFIG_MMC_DEBUG into pr_debug
    
    There are lots of debug message in core.c which use pr_debug
    for better dynamic log level control. So it doesn't make sense
    for those print to still keep working only under CONFIG_MMC_DEBUG.
    
    Signed-off-by: Shawn Lin <shawn.lin@rock-chips.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 634f9caecb88..731aa9f1ee8e 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2436,10 +2436,9 @@ static int mmc_rescan_try_freq(struct mmc_host *host, unsigned freq)
 {
 	host->f_init = freq;
 
-#ifdef CONFIG_MMC_DEBUG
-	pr_info("%s: %s: trying to init card at %u Hz\n",
+	pr_debug("%s: %s: trying to init card at %u Hz\n",
 		mmc_hostname(host), __func__, host->f_init);
-#endif
+
 	mmc_power_up(host, host->ocr_avail);
 
 	/*
@@ -2670,9 +2669,7 @@ int mmc_power_save_host(struct mmc_host *host)
 {
 	int ret = 0;
 
-#ifdef CONFIG_MMC_DEBUG
-	pr_info("%s: %s: powering down\n", mmc_hostname(host), __func__);
-#endif
+	pr_debug("%s: %s: powering down\n", mmc_hostname(host), __func__);
 
 	mmc_bus_get(host);
 
@@ -2696,9 +2693,7 @@ int mmc_power_restore_host(struct mmc_host *host)
 {
 	int ret;
 
-#ifdef CONFIG_MMC_DEBUG
-	pr_info("%s: %s: powering up\n", mmc_hostname(host), __func__);
-#endif
+	pr_debug("%s: %s: powering up\n", mmc_hostname(host), __func__);
 
 	mmc_bus_get(host);
 

commit b044b1bcc5de194688c33e5911b96ee93fd9ce48
Author: Shawn Lin <shawn.lin@rock-chips.com>
Date:   Wed Jul 19 15:55:45 2017 +0800

    mmc: core: always check the length of sglist with total data size
    
    All the check within mmc_mrq_prep seems to be all-or-none
    proposition, so it doesn't make sense to only check the
    length of sglist only under the CONFIG_MMC_DEBUG context.
    I'd prefer to always keep the check there unconditionally.
    
    Signed-off-by: Shawn Lin <shawn.lin@rock-chips.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index b311ec974c6a..634f9caecb88 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -295,10 +295,8 @@ static void mmc_mrq_pr_debug(struct mmc_host *host, struct mmc_request *mrq)
 
 static int mmc_mrq_prep(struct mmc_host *host, struct mmc_request *mrq)
 {
-#ifdef CONFIG_MMC_DEBUG
-	unsigned int i, sz;
+	unsigned int i, sz = 0;
 	struct scatterlist *sg;
-#endif
 
 	if (mrq->cmd) {
 		mrq->cmd->error = 0;
@@ -314,13 +312,12 @@ static int mmc_mrq_prep(struct mmc_host *host, struct mmc_request *mrq)
 		    mrq->data->blocks > host->max_blk_count ||
 		    mrq->data->blocks * mrq->data->blksz > host->max_req_size)
 			return -EINVAL;
-#ifdef CONFIG_MMC_DEBUG
-		sz = 0;
+
 		for_each_sg(mrq->data->sg, sg, mrq->data->sg_len, i)
 			sz += sg->length;
 		if (sz != mrq->data->blocks * mrq->data->blksz)
 			return -EINVAL;
-#endif
+
 		mrq->data->error = 0;
 		mrq->data->mrq = mrq;
 		if (mrq->stop) {

commit 1896f14006b28a7ed6881666d18a244827af0a5b
Author: Shawn Lin <shawn.lin@rock-chips.com>
Date:   Wed Jul 19 15:50:56 2017 +0800

    mmc: core: remove check of host->removed for rescan routine
    
    The intention of this check was to prevent the conflict between
    hotplug and removing driver for whatever reason. Currently it
    doesn't improve anything and the following rescan process could
    still saftly perform the scan flow. So these code seems pointless
    now and let's remove them.
    
    Signed-off-by: Shawn Lin <shawn.lin@rock-chips.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 26431267a3e2..b311ec974c6a 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1769,13 +1769,6 @@ void mmc_detach_bus(struct mmc_host *host)
 static void _mmc_detect_change(struct mmc_host *host, unsigned long delay,
 				bool cd_irq)
 {
-#ifdef CONFIG_MMC_DEBUG
-	unsigned long flags;
-	spin_lock_irqsave(&host->lock, flags);
-	WARN_ON(host->removed);
-	spin_unlock_irqrestore(&host->lock, flags);
-#endif
-
 	/*
 	 * If the device is configured as wakeup, we prevent a new sleep for
 	 * 5 s to give provision for user space to consume the event.
@@ -2646,12 +2639,6 @@ void mmc_start_host(struct mmc_host *host)
 
 void mmc_stop_host(struct mmc_host *host)
 {
-#ifdef CONFIG_MMC_DEBUG
-	unsigned long flags;
-	spin_lock_irqsave(&host->lock, flags);
-	host->removed = 1;
-	spin_unlock_irqrestore(&host->lock, flags);
-#endif
 	if (host->slot.cd_irq >= 0) {
 		if (host->slot.cd_wake_enabled)
 			disable_irq_wake(host->slot.cd_irq);

commit 03dbaa04a2e5bac0ae907a9ed31472bc4bb56fd3
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Tue Jun 13 15:07:51 2017 +0300

    mmc: slot-gpio: Add support to enable irq wake on cd_irq
    
    Add host capability MMC_CAP_CD_WAKE to enable irq wake on the card detect
    irq.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index d40697fae911..26431267a3e2 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2652,8 +2652,11 @@ void mmc_stop_host(struct mmc_host *host)
 	host->removed = 1;
 	spin_unlock_irqrestore(&host->lock, flags);
 #endif
-	if (host->slot.cd_irq >= 0)
+	if (host->slot.cd_irq >= 0) {
+		if (host->slot.cd_wake_enabled)
+			disable_irq_wake(host->slot.cd_irq);
 		disable_irq(host->slot.cd_irq);
+	}
 
 	host->rescan_disable = 1;
 	cancel_delayed_work_sync(&host->detect);

commit d9df1737583ed34bf470d87dbb6f9d0a42718b40
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu Jun 8 15:27:40 2017 +0200

    mmc: core: Move mmc_flush_cache() from core.c to mmc_ops.c
    
    The mmc_flush_cache() is a eMMC specific function, let's move it to
    mmc_ops.c to make that clear.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Reviewed-by: Shawn Lin <shawn.lin@rock-chips.com>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index de31f304f94a..d40697fae911 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2729,27 +2729,6 @@ int mmc_power_restore_host(struct mmc_host *host)
 }
 EXPORT_SYMBOL(mmc_power_restore_host);
 
-/*
- * Flush the cache to the non-volatile storage.
- */
-int mmc_flush_cache(struct mmc_card *card)
-{
-	int err = 0;
-
-	if (mmc_card_mmc(card) &&
-			(card->ext_csd.cache_size > 0) &&
-			(card->ext_csd.cache_ctrl & 1)) {
-		err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
-				EXT_CSD_FLUSH_CACHE, 1, 0);
-		if (err)
-			pr_err("%s: cache flush error %d\n",
-					mmc_hostname(card->host), err);
-	}
-
-	return err;
-}
-EXPORT_SYMBOL(mmc_flush_cache);
-
 #ifdef CONFIG_PM_SLEEP
 /* Do the card removal on suspend if card is assumed removeable
  * Do that in pm notifier while userspace isn't yet frozen, so we will be able

commit 0f2c05125ef98f062c256c6d150ff372125bf523
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu Jun 8 15:27:39 2017 +0200

    mmc: core: Move mmc_interrupt_hpi() from core.c to mmc_ops.c
    
    The mmc_interrupt_hpi() is a eMMC specific function, let's move it to
    mmc_ops.c to make that clear. The move also enables us to make
    mmc_send_hpi_cmd() static, so let's do that change as well.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Reviewed-by: Shawn Lin <shawn.lin@rock-chips.com>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index d7c934c67197..de31f304f94a 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -674,70 +674,6 @@ void mmc_wait_for_req(struct mmc_host *host, struct mmc_request *mrq)
 }
 EXPORT_SYMBOL(mmc_wait_for_req);
 
-/**
- *	mmc_interrupt_hpi - Issue for High priority Interrupt
- *	@card: the MMC card associated with the HPI transfer
- *
- *	Issued High Priority Interrupt, and check for card status
- *	until out-of prg-state.
- */
-int mmc_interrupt_hpi(struct mmc_card *card)
-{
-	int err;
-	u32 status;
-	unsigned long prg_wait;
-
-	if (!card->ext_csd.hpi_en) {
-		pr_info("%s: HPI enable bit unset\n", mmc_hostname(card->host));
-		return 1;
-	}
-
-	mmc_claim_host(card->host);
-	err = mmc_send_status(card, &status);
-	if (err) {
-		pr_err("%s: Get card status fail\n", mmc_hostname(card->host));
-		goto out;
-	}
-
-	switch (R1_CURRENT_STATE(status)) {
-	case R1_STATE_IDLE:
-	case R1_STATE_READY:
-	case R1_STATE_STBY:
-	case R1_STATE_TRAN:
-		/*
-		 * In idle and transfer states, HPI is not needed and the caller
-		 * can issue the next intended command immediately
-		 */
-		goto out;
-	case R1_STATE_PRG:
-		break;
-	default:
-		/* In all other states, it's illegal to issue HPI */
-		pr_debug("%s: HPI cannot be sent. Card state=%d\n",
-			mmc_hostname(card->host), R1_CURRENT_STATE(status));
-		err = -EINVAL;
-		goto out;
-	}
-
-	err = mmc_send_hpi_cmd(card, &status);
-	if (err)
-		goto out;
-
-	prg_wait = jiffies + msecs_to_jiffies(card->ext_csd.out_of_int_time);
-	do {
-		err = mmc_send_status(card, &status);
-
-		if (!err && R1_CURRENT_STATE(status) == R1_STATE_TRAN)
-			break;
-		if (time_after(jiffies, prg_wait))
-			err = -ETIMEDOUT;
-	} while (!err);
-
-out:
-	mmc_release_host(card->host);
-	return err;
-}
-
 /**
  *	mmc_wait_for_cmd - start a command and wait for completion
  *	@host: MMC host to start command

commit 1cf8f7e5af3910781a21b84f13a34851aa228fe3
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri Jun 9 14:15:01 2017 +0200

    mmc: core: Move mmc bkops functions from core.c to mmc_ops.c
    
    The mmc_start_bkops(), mmc_stop_bkops() and mmc_read_bkops_status()
    functions are all specific to eMMCs. To make this clear, let's move them
    from from core.c to mmc_ops.c and take the opportunity to make
    mmc_read_bkops_status() static.
    
    While moving them, get rid of MMC_BKOPS_MAX_TIMEOUT (4 min) and use the
    common default timeout MMC_OPS_TIMEOUT_MS (10 min) instead, as there is no
    need to have specific default timeout for bkops.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Reviewed-by: Shawn Lin <shawn.lin@rock-chips.com>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index d48be0b218ff..d7c934c67197 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -53,12 +53,6 @@
 /* If the device is not responding */
 #define MMC_CORE_TIMEOUT_MS	(10 * 60 * 1000) /* 10 minute timeout */
 
-/*
- * Background operations can take a long time, depending on the housekeeping
- * operations the card has to perform.
- */
-#define MMC_BKOPS_MAX_TIMEOUT	(4 * 60 * 1000) /* max time to wait in ms */
-
 /* The max erase timeout, used when host->max_busy_timeout isn't specified */
 #define MMC_ERASE_TIMEOUT_MS	(60 * 1000) /* 60 s */
 
@@ -362,73 +356,6 @@ static int mmc_start_request(struct mmc_host *host, struct mmc_request *mrq)
 	return 0;
 }
 
-/**
- *	mmc_start_bkops - start BKOPS for supported cards
- *	@card: MMC card to start BKOPS
- *	@form_exception: A flag to indicate if this function was
- *			 called due to an exception raised by the card
- *
- *	Start background operations whenever requested.
- *	When the urgent BKOPS bit is set in a R1 command response
- *	then background operations should be started immediately.
-*/
-void mmc_start_bkops(struct mmc_card *card, bool from_exception)
-{
-	int err;
-	int timeout;
-	bool use_busy_signal;
-
-	if (!card->ext_csd.man_bkops_en || mmc_card_doing_bkops(card))
-		return;
-
-	err = mmc_read_bkops_status(card);
-	if (err) {
-		pr_err("%s: Failed to read bkops status: %d\n",
-		       mmc_hostname(card->host), err);
-		return;
-	}
-
-	if (!card->ext_csd.raw_bkops_status)
-		return;
-
-	if (card->ext_csd.raw_bkops_status < EXT_CSD_BKOPS_LEVEL_2 &&
-	    from_exception)
-		return;
-
-	mmc_claim_host(card->host);
-	if (card->ext_csd.raw_bkops_status >= EXT_CSD_BKOPS_LEVEL_2) {
-		timeout = MMC_BKOPS_MAX_TIMEOUT;
-		use_busy_signal = true;
-	} else {
-		timeout = 0;
-		use_busy_signal = false;
-	}
-
-	mmc_retune_hold(card->host);
-
-	err = __mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
-			EXT_CSD_BKOPS_START, 1, timeout, 0,
-			use_busy_signal, true, false);
-	if (err) {
-		pr_warn("%s: Error %d starting bkops\n",
-			mmc_hostname(card->host), err);
-		mmc_retune_release(card->host);
-		goto out;
-	}
-
-	/*
-	 * For urgent bkops status (LEVEL_2 and more)
-	 * bkops executed synchronously, otherwise
-	 * the operation is in progress
-	 */
-	if (!use_busy_signal)
-		mmc_card_set_doing_bkops(card);
-	else
-		mmc_retune_release(card->host);
-out:
-	mmc_release_host(card->host);
-}
-
 /*
  * mmc_wait_data_done() - done callback for data request
  * @mrq: done data request
@@ -840,51 +767,6 @@ int mmc_wait_for_cmd(struct mmc_host *host, struct mmc_command *cmd, int retries
 
 EXPORT_SYMBOL(mmc_wait_for_cmd);
 
-/**
- *	mmc_stop_bkops - stop ongoing BKOPS
- *	@card: MMC card to check BKOPS
- *
- *	Send HPI command to stop ongoing background operations to
- *	allow rapid servicing of foreground operations, e.g. read/
- *	writes. Wait until the card comes out of the programming state
- *	to avoid errors in servicing read/write requests.
- */
-int mmc_stop_bkops(struct mmc_card *card)
-{
-	int err = 0;
-
-	err = mmc_interrupt_hpi(card);
-
-	/*
-	 * If err is EINVAL, we can't issue an HPI.
-	 * It should complete the BKOPS.
-	 */
-	if (!err || (err == -EINVAL)) {
-		mmc_card_clr_doing_bkops(card);
-		mmc_retune_release(card->host);
-		err = 0;
-	}
-
-	return err;
-}
-
-int mmc_read_bkops_status(struct mmc_card *card)
-{
-	int err;
-	u8 *ext_csd;
-
-	mmc_claim_host(card->host);
-	err = mmc_get_ext_csd(card, &ext_csd);
-	mmc_release_host(card->host);
-	if (err)
-		return err;
-
-	card->ext_csd.raw_bkops_status = ext_csd[EXT_CSD_BKOPS_STATUS];
-	card->ext_csd.raw_exception_status = ext_csd[EXT_CSD_EXP_EVENTS_STATUS];
-	kfree(ext_csd);
-	return 0;
-}
-
 /**
  *	mmc_set_data_timeout - set the timeout for a data command
  *	@data: data phase for command

commit 066d9cc546c20e5f4f3c3c4ca08c107506728dcb
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu Jun 8 15:27:37 2017 +0200

    mmc: core: Don't export some eMMC specific functions from core.c
    
    The mmc_start|stop_bkops(), mmc_read_bkops_status() and mmc_interrupt_hpi()
    functions are all used from within the mmc core module, thus there are no
    need to use EXPORT_SYMBOL() for them, so let's remove it.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Shawn Lin <shawn.lin@rock-chips.com>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index ad8caf49c038..d48be0b218ff 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -428,7 +428,6 @@ void mmc_start_bkops(struct mmc_card *card, bool from_exception)
 out:
 	mmc_release_host(card->host);
 }
-EXPORT_SYMBOL(mmc_start_bkops);
 
 /*
  * mmc_wait_data_done() - done callback for data request
@@ -811,7 +810,6 @@ int mmc_interrupt_hpi(struct mmc_card *card)
 	mmc_release_host(card->host);
 	return err;
 }
-EXPORT_SYMBOL(mmc_interrupt_hpi);
 
 /**
  *	mmc_wait_for_cmd - start a command and wait for completion
@@ -869,7 +867,6 @@ int mmc_stop_bkops(struct mmc_card *card)
 
 	return err;
 }
-EXPORT_SYMBOL(mmc_stop_bkops);
 
 int mmc_read_bkops_status(struct mmc_card *card)
 {
@@ -887,7 +884,6 @@ int mmc_read_bkops_status(struct mmc_card *card)
 	kfree(ext_csd);
 	return 0;
 }
-EXPORT_SYMBOL(mmc_read_bkops_status);
 
 /**
  *	mmc_set_data_timeout - set the timeout for a data command

commit 52c8212d80b69d2197bb8506384b6e6a0aef7fb7
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Mon May 8 23:52:04 2017 +0200

    mmc: core: Don't do eMMC HW reset when resuming the eMMC card
    
    In case if a pwrseq-emmc has been bound to the host, a call to
    mmc_power_up() triggers an eMMC HW reset via the pwrseq_emmc's
    ->post_power_on() callback. This isn't really what we want, as
    mmc_power_up() is called each time when resuming the card.
    
    As a matter of fact, the current approach may also violate the eMMC spec,
    as the involved delays managed in pwrseq_emmc assumes both VCC and VCCQ has
    been turned on, which isn't the case for VCCQ, unless the regulator is
    always on.
    
    Fix this behaviour by aligning to the same procedure used when the mmc host
    implements the ->hw_reset() callback and has the MMC_CAP_HW_RESET flag set.
    In this way the eMMC HW reset is issued at card detection scan, to cope
    with bogus bootloaders and in the error recovery path via the mmc specific
    bus_ops->reset() callback.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Tested-by: Marek Szyprowski <m.szyprowski@samsung.com>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 82c45ddfa202..ad8caf49c038 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2597,6 +2597,8 @@ EXPORT_SYMBOL(mmc_set_blockcount);
 
 static void mmc_hw_reset_for_init(struct mmc_host *host)
 {
+	mmc_pwrseq_reset(host);
+
 	if (!(host->caps & MMC_CAP_HW_RESET) || !host->ops->hw_reset)
 		return;
 	host->ops->hw_reset(host);

commit 33e6d74d65c358270f00d228877178964aab84b3
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Mon Apr 24 13:41:55 2017 -0500

    mmc: core: Export API to allow hosts to get the card address
    
    Some hosts controllers, like Cavium, needs to know whether the card
    operates in byte- or block-address mode. Therefore export a new API,
    mmc_card_is_blockaddr(), which provides this information.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Steven J. Hill <Steven.Hill@cavium.com>
    Acked-by: David Daney <david.daney@cavium.com>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index e5f6bbfa73dd..82c45ddfa202 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2560,6 +2560,12 @@ unsigned int mmc_calc_max_discard(struct mmc_card *card)
 }
 EXPORT_SYMBOL(mmc_calc_max_discard);
 
+bool mmc_card_is_blockaddr(struct mmc_card *card)
+{
+	return card ? mmc_card_blockaddr(card) : false;
+}
+EXPORT_SYMBOL(mmc_card_is_blockaddr);
+
 int mmc_set_blocklen(struct mmc_card *card, unsigned int blocklen)
 {
 	struct mmc_command cmd = {};

commit f328c76e568d13c9fee21b5cf7411c96285f0f89
Author: jiajie.hao@mediatek.com <jiajie.hao@mediatek.com>
Date:   Sun Apr 23 17:38:27 2017 +0800

    mmc: sdio: Fix sdio wait busy implement limitation
    
    The host may issue an I/O abort by writing to the CCCR at any time
    during I/O read operation via CMD52. And host may need suspend
    transcation during write busy stage in SDIO suspend/resume scenario.
    >From other side, a card may accept CMD52 during data transfer phase.
    
    Previous implement would block issuing above command in busy stage.
    It cause function driver can't implement as proper way and has no
    opportunity to do some coverage in error case via I/O abort etc.
    
    We need bypass some necessary operation during busy check stage.
    
    Signed-off-by: Jiajie Hao <jiajie.hao@mediatek.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 0bb39795d484..e5f6bbfa73dd 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -239,8 +239,10 @@ static void __mmc_start_request(struct mmc_host *host, struct mmc_request *mrq)
 	/*
 	 * For sdio rw commands we must wait for card busy otherwise some
 	 * sdio devices won't work properly.
+	 * And bypass I/O abort, reset and bus suspend operations.
 	 */
-	if (mmc_is_io_op(mrq->cmd->opcode) && host->ops->card_busy) {
+	if (sdio_is_io_busy(mrq->cmd->opcode, mrq->cmd->arg) &&
+	    host->ops->card_busy) {
 		int tries = 500; /* Wait aprox 500ms at maximum */
 
 		while (host->ops->card_busy(host) && --tries)

commit 67b8360acc0d717c46af3008fc10dcc5c91f7745
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Mar 28 10:40:31 2017 +0200

    mmc: core: refactor mmc_request_done()
    
    We have this construction:
    
    if (a && b && !c)
       finalize;
    else
       block;
       finalize;
    
    Which is equivalent by boolean logic to:
    
    if (!a || !b || c)
       block;
    finalize;
    
    Which is simpler code.
    
    Reviewed-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index d6831dc05d98..0bb39795d484 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -172,14 +172,16 @@ void mmc_request_done(struct mmc_host *host, struct mmc_request *mrq)
 
 	trace_mmc_request_done(host, mrq);
 
-	if (err && cmd->retries && !mmc_card_removed(host->card)) {
-		/*
-		 * Request starter must handle retries - see
-		 * mmc_wait_for_req_done().
-		 */
-		if (mrq->done)
-			mrq->done(mrq);
-	} else {
+	/*
+	 * We list various conditions for the command to be considered
+	 * properly done:
+	 *
+	 * - There was no error, OK fine then
+	 * - We are not doing some kind of retry
+	 * - The card was removed (...so just complete everything no matter
+	 *   if there are errors or retries)
+	 */
+	if (!err || !cmd->retries || mmc_card_removed(host->card)) {
 		mmc_should_fail_request(host, mrq);
 
 		if (!host->ongoing_mrq)
@@ -211,10 +213,13 @@ void mmc_request_done(struct mmc_host *host, struct mmc_request *mrq)
 				mrq->stop->resp[0], mrq->stop->resp[1],
 				mrq->stop->resp[2], mrq->stop->resp[3]);
 		}
-
-		if (mrq->done)
-			mrq->done(mrq);
 	}
+	/*
+	 * Request starter must handle retries - see
+	 * mmc_wait_for_req_done().
+	 */
+	if (mrq->done)
+		mrq->done(mrq);
 }
 
 EXPORT_SYMBOL(mmc_request_done);

commit 0e72f95bf329dea7985f0f4ac81cc888e8b79797
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Mar 28 10:40:30 2017 +0200

    mmc: core: refactor asynchronous request finalization
    
    mmc_wait_for_data_req_done() is called in exactly one place,
    and having it spread out is making things hard to oversee.
    Factor this function into mmc_finalize_areq().
    
    Reviewed-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 4c3e23f310f8..d6831dc05d98 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -506,56 +506,6 @@ static int __mmc_start_req(struct mmc_host *host, struct mmc_request *mrq)
 	return err;
 }
 
-/*
- * mmc_wait_for_data_req_done() - wait for request completed
- * @host: MMC host to prepare the command.
- * @mrq: MMC request to wait for
- *
- * Blocks MMC context till host controller will ack end of data request
- * execution or new request notification arrives from the block layer.
- * Handles command retries.
- *
- * Returns enum mmc_blk_status after checking errors.
- */
-static enum mmc_blk_status mmc_wait_for_data_req_done(struct mmc_host *host,
-						      struct mmc_request *mrq)
-{
-	struct mmc_command *cmd;
-	struct mmc_context_info *context_info = &host->context_info;
-	enum mmc_blk_status status;
-
-	while (1) {
-		wait_event_interruptible(context_info->wait,
-				(context_info->is_done_rcv ||
-				 context_info->is_new_req));
-
-		if (context_info->is_done_rcv) {
-			context_info->is_done_rcv = false;
-			cmd = mrq->cmd;
-
-			if (!cmd->error || !cmd->retries ||
-			    mmc_card_removed(host->card)) {
-				status = host->areq->err_check(host->card,
-							       host->areq);
-				break; /* return status */
-			} else {
-				mmc_retune_recheck(host);
-				pr_info("%s: req failed (CMD%u): %d, retrying...\n",
-					mmc_hostname(host),
-					cmd->opcode, cmd->error);
-				cmd->retries--;
-				cmd->error = 0;
-				__mmc_start_request(host, mrq);
-				continue; /* wait for done/new event again */
-			}
-		}
-
-		return MMC_BLK_NEW_REQUEST;
-	}
-	mmc_retune_release(host);
-	return status;
-}
-
 void mmc_wait_for_req_done(struct mmc_host *host, struct mmc_request *mrq)
 {
 	struct mmc_command *cmd;
@@ -660,14 +610,44 @@ static void mmc_post_req(struct mmc_host *host, struct mmc_request *mrq,
  */
 static enum mmc_blk_status mmc_finalize_areq(struct mmc_host *host)
 {
+	struct mmc_context_info *context_info = &host->context_info;
 	enum mmc_blk_status status;
 
 	if (!host->areq)
 		return MMC_BLK_SUCCESS;
 
-	status = mmc_wait_for_data_req_done(host, host->areq->mrq);
-	if (status == MMC_BLK_NEW_REQUEST)
-		return status;
+	while (1) {
+		wait_event_interruptible(context_info->wait,
+				(context_info->is_done_rcv ||
+				 context_info->is_new_req));
+
+		if (context_info->is_done_rcv) {
+			struct mmc_command *cmd;
+
+			context_info->is_done_rcv = false;
+			cmd = host->areq->mrq->cmd;
+
+			if (!cmd->error || !cmd->retries ||
+			    mmc_card_removed(host->card)) {
+				status = host->areq->err_check(host->card,
+							       host->areq);
+				break; /* return status */
+			} else {
+				mmc_retune_recheck(host);
+				pr_info("%s: req failed (CMD%u): %d, retrying...\n",
+					mmc_hostname(host),
+					cmd->opcode, cmd->error);
+				cmd->retries--;
+				cmd->error = 0;
+				__mmc_start_request(host, host->areq->mrq);
+				continue; /* wait for done/new event again */
+			}
+		}
+
+		return MMC_BLK_NEW_REQUEST;
+	}
+
+	mmc_retune_release(host);
 
 	/*
 	 * Check BKOPS urgency for each R1 response

commit 5744d50d2d9e7efdae4b5d13cd71f49256ada6ba
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Mar 28 10:40:29 2017 +0200

    mmc: core: move some code in mmc_start_areq()
    
    "previous" is a better name for the variable storing the previous
    asynchronous request, better than the opaque name "data" atleast.
    We see that we assign the return status to the returned variable
    on all code paths, so we might as well just do that immediately
    after calling mmc_finalize_areq().
    
    Reviewed-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index ffc263283f54..4c3e23f310f8 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -704,7 +704,7 @@ struct mmc_async_req *mmc_start_areq(struct mmc_host *host,
 {
 	enum mmc_blk_status status;
 	int start_err = 0;
-	struct mmc_async_req *data = host->areq;
+	struct mmc_async_req *previous = host->areq;
 
 	/* Prepare a new request */
 	if (areq)
@@ -712,13 +712,12 @@ struct mmc_async_req *mmc_start_areq(struct mmc_host *host,
 
 	/* Finalize previous request */
 	status = mmc_finalize_areq(host);
+	if (ret_stat)
+		*ret_stat = status;
 
 	/* The previous request is still going on... */
-	if (status == MMC_BLK_NEW_REQUEST) {
-		if (ret_stat)
-			*ret_stat = status;
+	if (status == MMC_BLK_NEW_REQUEST)
 		return NULL;
-	}
 
 	/* Fine so far, start the new request! */
 	if (status == MMC_BLK_SUCCESS && areq)
@@ -737,9 +736,7 @@ struct mmc_async_req *mmc_start_areq(struct mmc_host *host,
 	else
 		host->areq = areq;
 
-	if (ret_stat)
-		*ret_stat = status;
-	return data;
+	return previous;
 }
 EXPORT_SYMBOL(mmc_start_areq);
 

commit f34bdd2f7e2881090f566a2f93b0d8e1189091e0
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Mon Mar 13 14:36:43 2017 +0200

    mmc: core: Factor out mrq preparation from mmc_start_request()
    
    In preparation to reuse the code for CQE support.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 6b063f0c2553..ffc263283f54 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -292,23 +292,18 @@ static void mmc_mrq_pr_debug(struct mmc_host *host, struct mmc_request *mrq)
 	}
 }
 
-static int mmc_start_request(struct mmc_host *host, struct mmc_request *mrq)
+static int mmc_mrq_prep(struct mmc_host *host, struct mmc_request *mrq)
 {
 #ifdef CONFIG_MMC_DEBUG
 	unsigned int i, sz;
 	struct scatterlist *sg;
 #endif
-	mmc_retune_hold(host);
-
-	if (mmc_card_removed(host->card))
-		return -ENOMEDIUM;
-
-	mmc_mrq_pr_debug(host, mrq);
-
-	WARN_ON(!host->claimed);
 
-	mrq->cmd->error = 0;
-	mrq->cmd->mrq = mrq;
+	if (mrq->cmd) {
+		mrq->cmd->error = 0;
+		mrq->cmd->mrq = mrq;
+		mrq->cmd->data = mrq->data;
+	}
 	if (mrq->sbc) {
 		mrq->sbc->error = 0;
 		mrq->sbc->mrq = mrq;
@@ -325,8 +320,6 @@ static int mmc_start_request(struct mmc_host *host, struct mmc_request *mrq)
 		if (sz != mrq->data->blocks * mrq->data->blksz)
 			return -EINVAL;
 #endif
-
-		mrq->cmd->data = mrq->data;
 		mrq->data->error = 0;
 		mrq->data->mrq = mrq;
 		if (mrq->stop) {
@@ -335,6 +328,27 @@ static int mmc_start_request(struct mmc_host *host, struct mmc_request *mrq)
 			mrq->stop->mrq = mrq;
 		}
 	}
+
+	return 0;
+}
+
+static int mmc_start_request(struct mmc_host *host, struct mmc_request *mrq)
+{
+	int err;
+
+	mmc_retune_hold(host);
+
+	if (mmc_card_removed(host->card))
+		return -ENOMEDIUM;
+
+	mmc_mrq_pr_debug(host, mrq);
+
+	WARN_ON(!host->claimed);
+
+	err = mmc_mrq_prep(host, mrq);
+	if (err)
+		return err;
+
 	led_trigger_event(host->led, LED_FULL);
 	__mmc_start_request(host, mrq);
 

commit 4b67e63faaa21eab225bc3827a9d06e6ae54bdc7
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Mon Mar 13 14:36:42 2017 +0200

    mmc: core: Factor out debug prints from mmc_start_request()
    
    In preparation to reuse the code for CQE support.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 926e0fde07d7..6b063f0c2553 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -262,26 +262,19 @@ static void __mmc_start_request(struct mmc_host *host, struct mmc_request *mrq)
 	host->ops->request(host, mrq);
 }
 
-static int mmc_start_request(struct mmc_host *host, struct mmc_request *mrq)
+static void mmc_mrq_pr_debug(struct mmc_host *host, struct mmc_request *mrq)
 {
-#ifdef CONFIG_MMC_DEBUG
-	unsigned int i, sz;
-	struct scatterlist *sg;
-#endif
-	mmc_retune_hold(host);
-
-	if (mmc_card_removed(host->card))
-		return -ENOMEDIUM;
-
 	if (mrq->sbc) {
 		pr_debug("<%s: starting CMD%u arg %08x flags %08x>\n",
 			 mmc_hostname(host), mrq->sbc->opcode,
 			 mrq->sbc->arg, mrq->sbc->flags);
 	}
 
-	pr_debug("%s: starting CMD%u arg %08x flags %08x\n",
-		 mmc_hostname(host), mrq->cmd->opcode,
-		 mrq->cmd->arg, mrq->cmd->flags);
+	if (mrq->cmd) {
+		pr_debug("%s: starting CMD%u arg %08x flags %08x\n",
+			 mmc_hostname(host), mrq->cmd->opcode, mrq->cmd->arg,
+			 mrq->cmd->flags);
+	}
 
 	if (mrq->data) {
 		pr_debug("%s:     blksz %d blocks %d flags %08x "
@@ -297,6 +290,20 @@ static int mmc_start_request(struct mmc_host *host, struct mmc_request *mrq)
 			 mmc_hostname(host), mrq->stop->opcode,
 			 mrq->stop->arg, mrq->stop->flags);
 	}
+}
+
+static int mmc_start_request(struct mmc_host *host, struct mmc_request *mrq)
+{
+#ifdef CONFIG_MMC_DEBUG
+	unsigned int i, sz;
+	struct scatterlist *sg;
+#endif
+	mmc_retune_hold(host);
+
+	if (mmc_card_removed(host->card))
+		return -ENOMEDIUM;
+
+	mmc_mrq_pr_debug(host, mrq);
 
 	WARN_ON(!host->claimed);
 

commit 37dac0681e2be4f3c32b090a8c0591d4ce57e6f0
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Wed Feb 1 13:48:00 2017 +0100

    mmc: core: start to break apart mmc_start_areq()
    
    This function is doing to many clever things at the same time under
    too many various conditions.
    
    Start to make things clearer by refactoring: break out the
    finalization of the previous asynchronous request to its own
    function mmc_finalize_areq(). We can get rid of the default
    assignment of status and let the call deal with this.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 1985841ff1f1..926e0fde07d7 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -630,6 +630,37 @@ static void mmc_post_req(struct mmc_host *host, struct mmc_request *mrq,
 		host->ops->post_req(host, mrq, err);
 }
 
+/**
+ * mmc_finalize_areq() - finalize an asynchronous request
+ * @host: MMC host to finalize any ongoing request on
+ *
+ * Returns the status of the ongoing asynchronous request, but
+ * MMC_BLK_SUCCESS if no request was going on.
+ */
+static enum mmc_blk_status mmc_finalize_areq(struct mmc_host *host)
+{
+	enum mmc_blk_status status;
+
+	if (!host->areq)
+		return MMC_BLK_SUCCESS;
+
+	status = mmc_wait_for_data_req_done(host, host->areq->mrq);
+	if (status == MMC_BLK_NEW_REQUEST)
+		return status;
+
+	/*
+	 * Check BKOPS urgency for each R1 response
+	 */
+	if (host->card && mmc_card_mmc(host->card) &&
+	    ((mmc_resp_type(host->areq->mrq->cmd) == MMC_RSP_R1) ||
+	     (mmc_resp_type(host->areq->mrq->cmd) == MMC_RSP_R1B)) &&
+	    (host->areq->mrq->cmd->resp[0] & R1_EXCEPTION_EVENT)) {
+		mmc_start_bkops(host->card, true);
+	}
+
+	return status;
+}
+
 /**
  *	mmc_start_areq - start an asynchronous request
  *	@host: MMC host to start command
@@ -650,7 +681,7 @@ struct mmc_async_req *mmc_start_areq(struct mmc_host *host,
 				     struct mmc_async_req *areq,
 				     enum mmc_blk_status *ret_stat)
 {
-	enum mmc_blk_status status = MMC_BLK_SUCCESS;
+	enum mmc_blk_status status;
 	int start_err = 0;
 	struct mmc_async_req *data = host->areq;
 
@@ -658,35 +689,25 @@ struct mmc_async_req *mmc_start_areq(struct mmc_host *host,
 	if (areq)
 		mmc_pre_req(host, areq->mrq);
 
-	if (host->areq) {
-		status = mmc_wait_for_data_req_done(host, host->areq->mrq);
-		if (status == MMC_BLK_NEW_REQUEST) {
-			if (ret_stat)
-				*ret_stat = status;
-			/*
-			 * The previous request was not completed,
-			 * nothing to return
-			 */
-			return NULL;
-		}
-		/*
-		 * Check BKOPS urgency for each R1 response
-		 */
-		if (host->card && mmc_card_mmc(host->card) &&
-		    ((mmc_resp_type(host->areq->mrq->cmd) == MMC_RSP_R1) ||
-		     (mmc_resp_type(host->areq->mrq->cmd) == MMC_RSP_R1B)) &&
-		    (host->areq->mrq->cmd->resp[0] & R1_EXCEPTION_EVENT)) {
-			mmc_start_bkops(host->card, true);
-		}
+	/* Finalize previous request */
+	status = mmc_finalize_areq(host);
+
+	/* The previous request is still going on... */
+	if (status == MMC_BLK_NEW_REQUEST) {
+		if (ret_stat)
+			*ret_stat = status;
+		return NULL;
 	}
 
+	/* Fine so far, start the new request! */
 	if (status == MMC_BLK_SUCCESS && areq)
 		start_err = __mmc_start_data_req(host, areq->mrq);
 
+	/* Postprocess the old request at this point */
 	if (host->areq)
 		mmc_post_req(host, host->areq->mrq, 0);
 
-	 /* Cancel a prepared request if it was not started. */
+	/* Cancel a prepared request if it was not started. */
 	if ((status != MMC_BLK_SUCCESS || start_err) && areq)
 		mmc_post_req(host, areq->mrq, -EINVAL);
 

commit c3399ef55d8e8295293808eba32e3f7056526324
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Wed Feb 1 13:47:53 2017 +0100

    mmc: core: rename mmc_start_req() to *areq()
    
    With the coexisting __mmc_start_request(), mmc_start_request()
    and __mmc_start_req() it is a bit confusing that mmc_start_req()
    actually does not start a normal request, but an asynchronous
    request.
    
    Rename it to mmc_start_areq() to make it explicit what the
    function is doing, also fix the kerneldoc for this function
    while we're at it.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 3b12981e7627..1985841ff1f1 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -631,10 +631,10 @@ static void mmc_post_req(struct mmc_host *host, struct mmc_request *mrq,
 }
 
 /**
- *	mmc_start_req - start a non-blocking request
+ *	mmc_start_areq - start an asynchronous request
  *	@host: MMC host to start command
- *	@areq: async request to start
- *	@error: out parameter returns 0 for success, otherwise non zero
+ *	@areq: asynchronous request to start
+ *	@ret_stat: out parameter for status
  *
  *	Start a new MMC custom command request for a host.
  *	If there is on ongoing async request wait for completion
@@ -646,9 +646,9 @@ static void mmc_post_req(struct mmc_host *host, struct mmc_request *mrq,
  *	return the completed request. If there is no ongoing request, NULL
  *	is returned without waiting. NULL is not an error condition.
  */
-struct mmc_async_req *mmc_start_req(struct mmc_host *host,
-				    struct mmc_async_req *areq,
-				    enum mmc_blk_status *ret_stat)
+struct mmc_async_req *mmc_start_areq(struct mmc_host *host,
+				     struct mmc_async_req *areq,
+				     enum mmc_blk_status *ret_stat)
 {
 	enum mmc_blk_status status = MMC_BLK_SUCCESS;
 	int start_err = 0;
@@ -699,7 +699,7 @@ struct mmc_async_req *mmc_start_req(struct mmc_host *host,
 		*ret_stat = status;
 	return data;
 }
-EXPORT_SYMBOL(mmc_start_req);
+EXPORT_SYMBOL(mmc_start_areq);
 
 /**
  *	mmc_wait_for_req - start a request and wait for completion

commit e13934bdf45935f51243515c275629922dc43839
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Fri Jan 27 15:04:54 2017 +0100

    mmc: core/mmci: restore pre/post_req behaviour
    
    commit 64b12a68a9f74bb32d8efd7af1ad8a2ba02fc884
    "mmc: core: fix prepared requests while doing bkops"
    is fixing a bug in the wrong way. A bug in the MMCI
    device driver is fixed by amending the MMC core.
    
    Thinking about it: what the pre- and post-callbacks
    are doing is to essentially map and unmap SG lists
    for DMA transfers. Why would we not be able to do that
    just because a BKOPS command is sent inbetween?
    Having to unprepare/prepare the next asynchronous
    request for DMA seems wrong.
    
    Looking the backtrace in that commit we can see what
    the real problem actually is:
    
    mmci_data_irq() is calling mmci_dma_unmap() twice
    which is goung to call arm_dma_unmap_sg() twice
    and v7_dma_inv_range() twice for the same sglist
    and that will crash.
    
    This happens because a request is prepared, then
    a BKOPS is sent. The IRQ completing the BKOPS command
    goes through mmci_data_irq() and thinks that a DMA
    operation has just been completed because
    dma_inprogress() reports true. It then proceeds to
    unmap the sglist.
    
    But that was wrong! dma_inprogress() should NOT be
    true because no DMA was actually in progress! We had
    just prepared the sglist, and the DMA channel
    dma_current has been configured, but NOT started!
    
    Because of this, the sglist is already unmapped when
    we get our actual data completion IRQ, and we are
    unmapping the sglist once more, and we get this crash.
    
    Therefore, we need to revert this solution pushing
    the problem to the core and causing problems, and
    instead augment the implementation such that
    dma_inprogress() only reports true if some DMA has
    actually been started.
    
    After this we can keep the request prepared during the
    BKOPS and we need not unprepare/reprepare it.
    
    Fixes: 64b12a68a9f7 ("mmc: core: fix prepared requests while doing bkops")
    Cc: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Tested-by: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index b20b70fbd50d..3b12981e7627 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -676,16 +676,7 @@ struct mmc_async_req *mmc_start_req(struct mmc_host *host,
 		    ((mmc_resp_type(host->areq->mrq->cmd) == MMC_RSP_R1) ||
 		     (mmc_resp_type(host->areq->mrq->cmd) == MMC_RSP_R1B)) &&
 		    (host->areq->mrq->cmd->resp[0] & R1_EXCEPTION_EVENT)) {
-
-			/* Cancel the prepared request */
-			if (areq)
-				mmc_post_req(host, areq->mrq, -EINVAL);
-
 			mmc_start_bkops(host->card, true);
-
-			/* prepare the request again */
-			if (areq)
-				mmc_pre_req(host, areq->mrq);
 		}
 	}
 

commit 4e74b6b3c6e9adfe6a8fdebfc56a6416a996d905
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Wed Jan 25 11:12:34 2017 +0100

    mmc: core: Rename __mmc_set_signal_voltage() to mmc_set_signal_voltage()
    
    Earlier the mmc_set_signal_voltage() existed, but since it has been renamed
    to mmc_set_uhs_voltage(), we can now use that name instead.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Shawn Lin <shawn.lin@rock-chips.com>
    Tested-by: Jan Glauber <jglauber@cavium.com>
    Tested-by: Stefan Wahren <stefan.wahren@i2se.com>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 82c1a02b9c2a..b20b70fbd50d 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1631,7 +1631,7 @@ u32 mmc_select_voltage(struct mmc_host *host, u32 ocr)
 	return ocr;
 }
 
-int __mmc_set_signal_voltage(struct mmc_host *host, int signal_voltage)
+int mmc_set_signal_voltage(struct mmc_host *host, int signal_voltage)
 {
 	int err = 0;
 	int old_signal_voltage = host->ios.signal_voltage;
@@ -1691,7 +1691,7 @@ int mmc_set_uhs_voltage(struct mmc_host *host, u32 ocr)
 	host->ios.clock = 0;
 	mmc_set_ios(host);
 
-	if (__mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_180)) {
+	if (mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_180)) {
 		/*
 		 * Voltages may not have been switched, but we've already
 		 * sent CMD11, so a power cycle is required anyway
@@ -1800,11 +1800,11 @@ void mmc_power_up(struct mmc_host *host, u32 ocr)
 	mmc_set_initial_state(host);
 
 	/* Try to set signal voltage to 3.3V but fall back to 1.8v or 1.2v */
-	if (__mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_330) == 0)
+	if (!mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_330))
 		dev_dbg(mmc_dev(host), "Initial signal voltage of 3.3v\n");
-	else if (__mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_180) == 0)
+	else if (!mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_180))
 		dev_dbg(mmc_dev(host), "Initial signal voltage of 1.8v\n");
-	else if (__mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_120) == 0)
+	else if (!mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_120))
 		dev_dbg(mmc_dev(host), "Initial signal voltage of 1.2v\n");
 
 	/*

commit 2ed573b603f78289dd1435c94597aa25a97e2b76
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Wed Jan 25 10:25:01 2017 +0100

    mmc: core: Clarify usage of mmc_set_signal_voltage()
    
    The mmc_set_signal_voltage() function is used for SD/SDIO when switching to
    1.8V for UHS mode. To clarify this let's do the following changes.
    
    - We are always providing MMC_SIGNAL_VOLTAGE_180 as the signal_voltage
      parameter to the function. Then, let's just remove the parameter as it
      serves no purpose.
    - Rename the function to mmc_set_uhs_voltage().
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Shawn Lin <shawn.lin@rock-chips.com>
    Tested-by: Jan Glauber <jglauber@cavium.com>
    Tested-by: Stefan Wahren <stefan.wahren@i2se.com>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index bb819d49291e..82c1a02b9c2a 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1647,7 +1647,7 @@ int __mmc_set_signal_voltage(struct mmc_host *host, int signal_voltage)
 
 }
 
-int mmc_set_signal_voltage(struct mmc_host *host, int signal_voltage, u32 ocr)
+int mmc_set_uhs_voltage(struct mmc_host *host, u32 ocr)
 {
 	struct mmc_command cmd = {};
 	int err = 0;
@@ -1691,7 +1691,7 @@ int mmc_set_signal_voltage(struct mmc_host *host, int signal_voltage, u32 ocr)
 	host->ios.clock = 0;
 	mmc_set_ios(host);
 
-	if (__mmc_set_signal_voltage(host, signal_voltage)) {
+	if (__mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_180)) {
 		/*
 		 * Voltages may not have been switched, but we've already
 		 * sent CMD11, so a power cycle is required anyway

commit a44efa4796249c6d4341935e90e9105d6e1a5f15
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Wed Jan 25 10:12:10 2017 +0100

    mmc: core: Remove redundant code in mmc_set_signal_voltage()
    
    The mmc_set_signal_voltage() function is used for SD/SDIO when switching to
    1.8V for UHS mode. Therefore let's remove the redundant code dealing with
    MMC_SIGNAL_VOLTAGE_330.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Shawn Lin <shawn.lin@rock-chips.com>
    Tested-by: Jan Glauber <jglauber@cavium.com>
    Tested-by: Stefan Wahren <stefan.wahren@i2se.com>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 8c458255e55a..bb819d49291e 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1653,13 +1653,6 @@ int mmc_set_signal_voltage(struct mmc_host *host, int signal_voltage, u32 ocr)
 	int err = 0;
 	u32 clock;
 
-	/*
-	 * Send CMD11 only if the request is to switch the card to
-	 * 1.8V signalling.
-	 */
-	if (signal_voltage == MMC_SIGNAL_VOLTAGE_330)
-		return __mmc_set_signal_voltage(host, signal_voltage);
-
 	/*
 	 * If we cannot switch voltages, return failure so the caller
 	 * can continue without UHS mode

commit 4facdde11394d44b3869807841042d059f074a07
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri Jan 13 14:14:14 2017 +0100

    mmc: core: Move public functions from card.h to private headers
    
    A significant amount of functions and other definitions are available
    through the public mmc card.h header file. Let's slim down this public mmc
    interface, as to prevent users from abusing it, by moving some of the
    functions/definitions to private mmc header files.
    
    This change concentrates on moving the functions into private mmc headers,
    following changes may continue with additional clean-ups.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Reviewed-by: Shawn Lin <shawn.lin@rock-chips.com>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 3b34a751eea1..8c458255e55a 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -40,6 +40,7 @@
 #include <trace/events/mmc.h>
 
 #include "core.h"
+#include "card.h"
 #include "bus.h"
 #include "host.h"
 #include "sdio_bus.h"

commit c7836d1593b87cb813c58cf64e08b052ebbe2a78
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Mon Dec 19 20:51:18 2016 +0900

    mmc: use empty initializer list to zero-clear structures
    
    In the MMC subsystem, we see such initializers that only clears the
    first member explicitly.
    
    For example,
    
      struct mmc_request mrq = {NULL};
    
    sets the first member (.sbc) to NULL explicitly.  However, this is
    an unstable form because we may insert a non-pointer member at the
    top of the struct mmc_request in the future. (if we do so, the
    compiler will spit warnings.)
    
    So, using a designated initializer is preferred coding style.  The
    expression above is equivalent to:
    
      struct mmc_request mrq = { .sbc = NULL };
    
    Of course, this does not express our intention.  We want to fill
    all struct members with zeros.  Please note struct members are
    implicitly zero-cleared unless otherwise specified in the initializer.
    
    After all, the most reasonable (and stable) form is:
    
      struct mmc_request mrq = {};
    
    Do likewise for mmc_command, mmc_data as well.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 1076b9d89df3..3b34a751eea1 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -807,7 +807,7 @@ EXPORT_SYMBOL(mmc_interrupt_hpi);
  */
 int mmc_wait_for_cmd(struct mmc_host *host, struct mmc_command *cmd, int retries)
 {
-	struct mmc_request mrq = {NULL};
+	struct mmc_request mrq = {};
 
 	WARN_ON(!host->claimed);
 
@@ -1648,7 +1648,7 @@ int __mmc_set_signal_voltage(struct mmc_host *host, int signal_voltage)
 
 int mmc_set_signal_voltage(struct mmc_host *host, int signal_voltage, u32 ocr)
 {
-	struct mmc_command cmd = {0};
+	struct mmc_command cmd = {};
 	int err = 0;
 	u32 clock;
 
@@ -2129,7 +2129,7 @@ static unsigned int mmc_erase_timeout(struct mmc_card *card,
 static int mmc_do_erase(struct mmc_card *card, unsigned int from,
 			unsigned int to, unsigned int arg)
 {
-	struct mmc_command cmd = {0};
+	struct mmc_command cmd = {};
 	unsigned int qty = 0, busy_timeout = 0;
 	bool use_r1b_resp = false;
 	unsigned long timeout;
@@ -2551,7 +2551,7 @@ EXPORT_SYMBOL(mmc_calc_max_discard);
 
 int mmc_set_blocklen(struct mmc_card *card, unsigned int blocklen)
 {
-	struct mmc_command cmd = {0};
+	struct mmc_command cmd = {};
 
 	if (mmc_card_blockaddr(card) || mmc_card_ddr52(card) ||
 	    mmc_card_hs400(card) || mmc_card_hs400es(card))
@@ -2567,7 +2567,7 @@ EXPORT_SYMBOL(mmc_set_blocklen);
 int mmc_set_blockcount(struct mmc_card *card, unsigned int blockcount,
 			bool is_rel_write)
 {
-	struct mmc_command cmd = {0};
+	struct mmc_command cmd = {};
 
 	cmd.opcode = MMC_SET_BLOCK_COUNT;
 	cmd.arg = blockcount & 0x0000FFFF;

commit 15520111500c33a012aeec28ece8c5f2dcbf6b5e
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Mon Dec 19 15:57:34 2016 +0200

    mmc: core: Further fix thread wake-up
    
    Commit e0097cf5f2f1 ("mmc: queue: Fix queue thread wake-up") did not go far
    enough. mmc_wait_for_data_req_done() still contains some problems and can
    be further simplified.  First it should not touch
    context_info->is_waiting_last_req because that is a wake-up control used by
    the owner of the context. Secondly, it should always return when one of its
    wake-up conditions is met because, again, that is contolled by the owner of
    the context.
    
    While the current block driver does not have an issue, these problems were
    exposed during testing of the Software Command Queue patches.
    
    Fixes: e0097cf5f2f1 ("mmc: queue: Fix queue thread wake-up")
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Tested-by: Harjani Ritesh <riteshh@codeaurora.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 543eadd230e5..1076b9d89df3 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -496,8 +496,7 @@ static int __mmc_start_req(struct mmc_host *host, struct mmc_request *mrq)
  * Returns enum mmc_blk_status after checking errors.
  */
 static enum mmc_blk_status mmc_wait_for_data_req_done(struct mmc_host *host,
-				      struct mmc_request *mrq,
-				      struct mmc_async_req *next_req)
+						      struct mmc_request *mrq)
 {
 	struct mmc_command *cmd;
 	struct mmc_context_info *context_info = &host->context_info;
@@ -507,7 +506,7 @@ static enum mmc_blk_status mmc_wait_for_data_req_done(struct mmc_host *host,
 		wait_event_interruptible(context_info->wait,
 				(context_info->is_done_rcv ||
 				 context_info->is_new_req));
-		context_info->is_waiting_last_req = false;
+
 		if (context_info->is_done_rcv) {
 			context_info->is_done_rcv = false;
 			cmd = mrq->cmd;
@@ -527,10 +526,9 @@ static enum mmc_blk_status mmc_wait_for_data_req_done(struct mmc_host *host,
 				__mmc_start_request(host, mrq);
 				continue; /* wait for done/new event again */
 			}
-		} else if (context_info->is_new_req) {
-			if (!next_req)
-				return MMC_BLK_NEW_REQUEST;
 		}
+
+		return MMC_BLK_NEW_REQUEST;
 	}
 	mmc_retune_release(host);
 	return status;
@@ -660,7 +658,7 @@ struct mmc_async_req *mmc_start_req(struct mmc_host *host,
 		mmc_pre_req(host, areq->mrq);
 
 	if (host->areq) {
-		status = mmc_wait_for_data_req_done(host, host->areq->mrq, areq);
+		status = mmc_wait_for_data_req_done(host, host->areq->mrq);
 		if (status == MMC_BLK_NEW_REQUEST) {
 			if (ret_stat)
 				*ret_stat = status;

commit 6ff897ff5c62cd0454af39734408fcec8c4cf3f3
Author: Shawn Lin <shawn.lin@rock-chips.com>
Date:   Wed Nov 2 15:26:16 2016 +0800

    mmc: core: remove BUG_ONs from core.c
    
    BUG_ONs doesn't help anything except for stop the system from
    running. If it occurs, it implies we should deploy proper error
    handling for that. So this patch is gonna discard these meaningless
    BUG_ONs and deploy error handling if needed.
    
    Signed-off-by: Shawn Lin <shawn.lin@rock-chips.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index dc1f27ee50b8..543eadd230e5 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -306,16 +306,16 @@ static int mmc_start_request(struct mmc_host *host, struct mmc_request *mrq)
 		mrq->sbc->mrq = mrq;
 	}
 	if (mrq->data) {
-		BUG_ON(mrq->data->blksz > host->max_blk_size);
-		BUG_ON(mrq->data->blocks > host->max_blk_count);
-		BUG_ON(mrq->data->blocks * mrq->data->blksz >
-			host->max_req_size);
-
+		if (mrq->data->blksz > host->max_blk_size ||
+		    mrq->data->blocks > host->max_blk_count ||
+		    mrq->data->blocks * mrq->data->blksz > host->max_req_size)
+			return -EINVAL;
 #ifdef CONFIG_MMC_DEBUG
 		sz = 0;
 		for_each_sg(mrq->data->sg, sg, mrq->data->sg_len, i)
 			sz += sg->length;
-		BUG_ON(sz != mrq->data->blocks * mrq->data->blksz);
+		if (sz != mrq->data->blocks * mrq->data->blksz)
+			return -EINVAL;
 #endif
 
 		mrq->cmd->data = mrq->data;
@@ -349,8 +349,6 @@ void mmc_start_bkops(struct mmc_card *card, bool from_exception)
 	int timeout;
 	bool use_busy_signal;
 
-	BUG_ON(!card);
-
 	if (!card->ext_csd.man_bkops_en || mmc_card_doing_bkops(card))
 		return;
 
@@ -747,8 +745,6 @@ int mmc_interrupt_hpi(struct mmc_card *card)
 	u32 status;
 	unsigned long prg_wait;
 
-	BUG_ON(!card);
-
 	if (!card->ext_csd.hpi_en) {
 		pr_info("%s: HPI enable bit unset\n", mmc_hostname(card->host));
 		return 1;
@@ -843,7 +839,6 @@ int mmc_stop_bkops(struct mmc_card *card)
 {
 	int err = 0;
 
-	BUG_ON(!card);
 	err = mmc_interrupt_hpi(card);
 
 	/*
@@ -1659,8 +1654,6 @@ int mmc_set_signal_voltage(struct mmc_host *host, int signal_voltage, u32 ocr)
 	int err = 0;
 	u32 clock;
 
-	BUG_ON(!host);
-
 	/*
 	 * Send CMD11 only if the request is to switch the card to
 	 * 1.8V signalling.
@@ -1877,9 +1870,7 @@ void mmc_power_cycle(struct mmc_host *host, u32 ocr)
  */
 static void __mmc_release_bus(struct mmc_host *host)
 {
-	BUG_ON(!host);
-	BUG_ON(host->bus_refs);
-	BUG_ON(!host->bus_dead);
+	WARN_ON(!host->bus_dead);
 
 	host->bus_ops = NULL;
 }
@@ -1919,15 +1910,12 @@ void mmc_attach_bus(struct mmc_host *host, const struct mmc_bus_ops *ops)
 {
 	unsigned long flags;
 
-	BUG_ON(!host);
-	BUG_ON(!ops);
-
 	WARN_ON(!host->claimed);
 
 	spin_lock_irqsave(&host->lock, flags);
 
-	BUG_ON(host->bus_ops);
-	BUG_ON(host->bus_refs);
+	WARN_ON(host->bus_ops);
+	WARN_ON(host->bus_refs);
 
 	host->bus_ops = ops;
 	host->bus_refs = 1;
@@ -1943,8 +1931,6 @@ void mmc_detach_bus(struct mmc_host *host)
 {
 	unsigned long flags;
 
-	BUG_ON(!host);
-
 	WARN_ON(!host->claimed);
 	WARN_ON(!host->bus_ops);
 
@@ -2857,8 +2843,6 @@ void mmc_stop_host(struct mmc_host *host)
 	}
 	mmc_bus_put(host);
 
-	BUG_ON(host->card);
-
 	mmc_claim_host(host);
 	mmc_power_off(host);
 	mmc_release_host(host);

commit e0097cf5f2f1b7b8a594beaa32a604776d3ca6ce
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Tue Nov 29 12:09:10 2016 +0200

    mmc: queue: Fix queue thread wake-up
    
    The only time the driver sleeps expecting to be woken upon the arrival of
    a new request, is when the dispatch queue is empty. The only time that it
    is known whether the dispatch queue is empty is after NULL is returned
    from blk_fetch_request() while under the queue lock.
    
    Recognizing those facts, simplify the synchronization between the queue
    thread and the request function. A couple of flags tell the request
    function what to do, and the queue lock and barriers associated with
    wake-ups ensure synchronization.
    
    The result is simpler and allows the removal of the context_info lock.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Reviewed-by: Harjani Ritesh <riteshh@codeaurora.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index f39397f7c8dc..dc1f27ee50b8 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -504,18 +504,14 @@ static enum mmc_blk_status mmc_wait_for_data_req_done(struct mmc_host *host,
 	struct mmc_command *cmd;
 	struct mmc_context_info *context_info = &host->context_info;
 	enum mmc_blk_status status;
-	unsigned long flags;
 
 	while (1) {
 		wait_event_interruptible(context_info->wait,
 				(context_info->is_done_rcv ||
 				 context_info->is_new_req));
-		spin_lock_irqsave(&context_info->lock, flags);
 		context_info->is_waiting_last_req = false;
-		spin_unlock_irqrestore(&context_info->lock, flags);
 		if (context_info->is_done_rcv) {
 			context_info->is_done_rcv = false;
-			context_info->is_new_req = false;
 			cmd = mrq->cmd;
 
 			if (!cmd->error || !cmd->retries ||
@@ -534,7 +530,6 @@ static enum mmc_blk_status mmc_wait_for_data_req_done(struct mmc_host *host,
 				continue; /* wait for done/new event again */
 			}
 		} else if (context_info->is_new_req) {
-			context_info->is_new_req = false;
 			if (!next_req)
 				return MMC_BLK_NEW_REQUEST;
 		}
@@ -3016,7 +3011,6 @@ void mmc_unregister_pm_notifier(struct mmc_host *host)
  */
 void mmc_init_context_info(struct mmc_host *host)
 {
-	spin_lock_init(&host->context_info.lock);
 	host->context_info.is_new_req = false;
 	host->context_info.is_done_rcv = false;
 	host->context_info.is_waiting_last_req = false;

commit d3c6aac3bdfe97b8b44db6a8aba59786cb9531dc
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Wed Nov 23 11:02:24 2016 +0100

    mmc: delete is_first_req parameter from pre-request callback
    
    The void (*pre_req) callback in the struct mmc_host_ops vtable
    is passing an argument "is_first_req" indicating whether this is
    the first request or not.
    
    None of the in-kernel users use this parameter: instead, since
    they all just do variants of dma_map* they use the DMA cookie
    to indicate whether a pre* callback has already been done for
    a request when they decide how to handle it.
    
    Delete the parameter from the callback and all users, as it is
    just pointless cruft.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Jaehoon Chung <jh80.chung@samsung.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 060f76742550..f39397f7c8dc 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -611,18 +611,15 @@ EXPORT_SYMBOL(mmc_is_req_done);
  *	mmc_pre_req - Prepare for a new request
  *	@host: MMC host to prepare command
  *	@mrq: MMC request to prepare for
- *	@is_first_req: true if there is no previous started request
- *                     that may run in parellel to this call, otherwise false
  *
  *	mmc_pre_req() is called in prior to mmc_start_req() to let
  *	host prepare for the new request. Preparation of a request may be
  *	performed while another request is running on the host.
  */
-static void mmc_pre_req(struct mmc_host *host, struct mmc_request *mrq,
-		 bool is_first_req)
+static void mmc_pre_req(struct mmc_host *host, struct mmc_request *mrq)
 {
 	if (host->ops->pre_req)
-		host->ops->pre_req(host, mrq, is_first_req);
+		host->ops->pre_req(host, mrq);
 }
 
 /**
@@ -667,7 +664,7 @@ struct mmc_async_req *mmc_start_req(struct mmc_host *host,
 
 	/* Prepare a new request */
 	if (areq)
-		mmc_pre_req(host, areq->mrq, !host->areq);
+		mmc_pre_req(host, areq->mrq);
 
 	if (host->areq) {
 		status = mmc_wait_for_data_req_done(host, host->areq->mrq, areq);
@@ -696,7 +693,7 @@ struct mmc_async_req *mmc_start_req(struct mmc_host *host,
 
 			/* prepare the request again */
 			if (areq)
-				mmc_pre_req(host, areq->mrq, !host->areq);
+				mmc_pre_req(host, areq->mrq);
 		}
 	}
 

commit aa33ce3c411ab7a1b3c56f584b27bf4b6cc523ba
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Wed Nov 9 17:33:36 2016 +0100

    mmc: core: Enable __mmc_switch() to change bus speed timing for the host
    
    In cases when a speed mode change is requested for mmc cards, a CMD6 is
    sent by calling __mmc_switch() during the card initialization. The CMD6
    leads to the card entering a busy period. When that is completed, the host
    must parse the CMD6 status to find out whether the change of the speed mode
    succeeded.
    
    To enable the mmc core to poll the card by using CMD13 to find out when the
    busy period is completed, it's reasonable to make sure polling is done by
    having the mmc host and the mmc card, being configured to operate at the
    same selected bus speed timing.
    
    Therefore, let's extend __mmc_switch() to take yet another parameter, which
    allow its callers to update the bus speed timing of the mmc host. In this
    way, __mmc_switch() also becomes capable of reading and validating the CMD6
    status by sending a CMD13, in cases when that's desired.
    
    If __mmc_switch() encounters a failure, we make sure to restores the old
    bus speed timing for the mmc host, before propagating the error code.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Tested-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Adrian Hunter <adrian.hunter@intel.com>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 50bb9a16380d..060f76742550 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -380,7 +380,7 @@ void mmc_start_bkops(struct mmc_card *card, bool from_exception)
 	mmc_retune_hold(card->host);
 
 	err = __mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
-			EXT_CSD_BKOPS_START, 1, timeout,
+			EXT_CSD_BKOPS_START, 1, timeout, 0,
 			use_busy_signal, true, false);
 	if (err) {
 		pr_warn("%s: Error %d starting bkops\n",

commit 8e8b3f514c12a3b800bba8a7766c71139ad75b89
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Fri Nov 4 11:05:19 2016 +0100

    mmc: core: use enum mmc_blk_status properly
    
    There were several instances of code using the
    enum mmc_blk_status by arbitrarily converting it to an int and
    throwing it around to different functions. This makes the code
    hard to understand to may give rise to strange errors.
    
    Especially the function prototype mmc_start_req() had to be
    modified to take a pointer to an enum mmc_blk_status and the
    function pointer .err_check() inside struct mmc_async_req
    needed to return an enum mmc_blk_status.
    
    In every case: instead of assigning the block layer error code
    to an int, use the enum, also change the signature of all
    functions actually passing this enum to use the enum.
    
    To make it possible to use the enum everywhere applicable, move
    it to <linux/mmc/core.h> so that all code actually using it can
    also see it.
    
    An interesting case was encountered in the MMC test code which
    did not return a enum mmc_blk_status at all in the .err_check
    function supposed to check whether asynchronous requests worked
    or not: instead it returned a normal -ERROR or even the test
    frameworks internal error codes.
    
    The test code would also pass on enum mmc_blk_status codes as
    error codes inside the test code instead of converting them
    to the local RESULT_* codes.
    
    I have tried to fix all instances properly and run some tests
    on the result.
    
    Cc: Chunyan Zhang <zhang.chunyan@linaro.org>
    Cc: Baolin Wang <baolin.wang@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 2ad729138bee..50bb9a16380d 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -497,13 +497,13 @@ static int __mmc_start_req(struct mmc_host *host, struct mmc_request *mrq)
  *
  * Returns enum mmc_blk_status after checking errors.
  */
-static int mmc_wait_for_data_req_done(struct mmc_host *host,
+static enum mmc_blk_status mmc_wait_for_data_req_done(struct mmc_host *host,
 				      struct mmc_request *mrq,
 				      struct mmc_async_req *next_req)
 {
 	struct mmc_command *cmd;
 	struct mmc_context_info *context_info = &host->context_info;
-	int err;
+	enum mmc_blk_status status;
 	unsigned long flags;
 
 	while (1) {
@@ -520,9 +520,9 @@ static int mmc_wait_for_data_req_done(struct mmc_host *host,
 
 			if (!cmd->error || !cmd->retries ||
 			    mmc_card_removed(host->card)) {
-				err = host->areq->err_check(host->card,
-							    host->areq);
-				break; /* return err */
+				status = host->areq->err_check(host->card,
+							       host->areq);
+				break; /* return status */
 			} else {
 				mmc_retune_recheck(host);
 				pr_info("%s: req failed (CMD%u): %d, retrying...\n",
@@ -540,7 +540,7 @@ static int mmc_wait_for_data_req_done(struct mmc_host *host,
 		}
 	}
 	mmc_retune_release(host);
-	return err;
+	return status;
 }
 
 void mmc_wait_for_req_done(struct mmc_host *host, struct mmc_request *mrq)
@@ -658,9 +658,10 @@ static void mmc_post_req(struct mmc_host *host, struct mmc_request *mrq,
  *	is returned without waiting. NULL is not an error condition.
  */
 struct mmc_async_req *mmc_start_req(struct mmc_host *host,
-				    struct mmc_async_req *areq, int *error)
+				    struct mmc_async_req *areq,
+				    enum mmc_blk_status *ret_stat)
 {
-	int err = 0;
+	enum mmc_blk_status status = MMC_BLK_SUCCESS;
 	int start_err = 0;
 	struct mmc_async_req *data = host->areq;
 
@@ -669,10 +670,10 @@ struct mmc_async_req *mmc_start_req(struct mmc_host *host,
 		mmc_pre_req(host, areq->mrq, !host->areq);
 
 	if (host->areq) {
-		err = mmc_wait_for_data_req_done(host, host->areq->mrq,	areq);
-		if (err == MMC_BLK_NEW_REQUEST) {
-			if (error)
-				*error = err;
+		status = mmc_wait_for_data_req_done(host, host->areq->mrq, areq);
+		if (status == MMC_BLK_NEW_REQUEST) {
+			if (ret_stat)
+				*ret_stat = status;
 			/*
 			 * The previous request was not completed,
 			 * nothing to return
@@ -699,23 +700,23 @@ struct mmc_async_req *mmc_start_req(struct mmc_host *host,
 		}
 	}
 
-	if (!err && areq)
+	if (status == MMC_BLK_SUCCESS && areq)
 		start_err = __mmc_start_data_req(host, areq->mrq);
 
 	if (host->areq)
 		mmc_post_req(host, host->areq->mrq, 0);
 
 	 /* Cancel a prepared request if it was not started. */
-	if ((err || start_err) && areq)
+	if ((status != MMC_BLK_SUCCESS || start_err) && areq)
 		mmc_post_req(host, areq->mrq, -EINVAL);
 
-	if (err)
+	if (status != MMC_BLK_SUCCESS)
 		host->areq = NULL;
 	else
 		host->areq = areq;
 
-	if (error)
-		*error = err;
+	if (ret_stat)
+		*ret_stat = status;
 	return data;
 }
 EXPORT_SYMBOL(mmc_start_req);

commit c2c24819b28087f2a62750957e8dfa889d1f8bb2
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu Oct 13 13:37:40 2016 +0200

    mmc: core: Don't power off the card when starting the host
    
    The MMC_CAP2_NO_PRESCAN_POWERUP was invented to avoid running the power up
    sequence, mmc_power_up(), during ->probe() of the mmc host driver, but
    instead defer this to the mmc detect work. This is especially useful for
    those hosts that suffers from a long initialization time, as this time
    would otherwise add up to the total boot time.
    
    However, due to the introduction of runtime PM of mmc host devices in the
    mmc core, this behaviour changed a bit. More precisely, it caused the mmc
    core to runtime resume the host device during ->probe() of the host driver.
    In cases like the rtsx_usb_sdmmc, runtime resuming the device may be costly
    and thus affecting the total boot time.
    
    To improve this behaviour when using MMC_CAP2_NO_PRESCAN_POWERUP, let's
    postpone also calling mmc_power_off() when starting the host. This change
    allows the mmc core to avoid runtime resuming the device, as it don't need
    to claim the host for that execution path.
    
    Cc: Ritesh Raj Sarraf <rrs@researchut.com>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 2553d903a82b..2ad729138bee 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2824,12 +2824,11 @@ void mmc_start_host(struct mmc_host *host)
 	host->rescan_disable = 0;
 	host->ios.power_mode = MMC_POWER_UNDEFINED;
 
-	mmc_claim_host(host);
-	if (host->caps2 & MMC_CAP2_NO_PRESCAN_POWERUP)
-		mmc_power_off(host);
-	else
+	if (!(host->caps2 & MMC_CAP2_NO_PRESCAN_POWERUP)) {
+		mmc_claim_host(host);
 		mmc_power_up(host, host->ocr_avail);
-	mmc_release_host(host);
+		mmc_release_host(host);
+	}
 
 	mmc_gpiod_request_cd_irq(host);
 	_mmc_detect_change(host, 0, false);

commit 1712c9373f98ae8ed41599a8d7841a6fba29c264
Author: Ziyuan Xu <xzy.xu@rock-chips.com>
Date:   Wed Sep 21 09:43:49 2016 +0800

    mmc: core: don't try to switch block size for dual rate mode
    
    Per spec, block size should always be 512 bytes for dual rate mode,
    so any attempts to switch the block size under dual rate mode should
    be neglected.
    
    Signed-off-by: Ziyuan Xu <xzy.xu@rock-chips.com>
    Signed-off-by: Shawn Lin <shawn.lin@rock-chips.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index f0ed0afe033d..2553d903a82b 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2576,7 +2576,8 @@ int mmc_set_blocklen(struct mmc_card *card, unsigned int blocklen)
 {
 	struct mmc_command cmd = {0};
 
-	if (mmc_card_blockaddr(card) || mmc_card_ddr52(card))
+	if (mmc_card_blockaddr(card) || mmc_card_ddr52(card) ||
+	    mmc_card_hs400(card) || mmc_card_hs400es(card))
 		return 0;
 
 	cmd.opcode = MMC_SET_BLOCKLEN;

commit 5163af5a5e2e69c9a5a854b92ffa7e2f7672dbf7
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Tue Aug 16 13:44:11 2016 +0300

    mmc: core: Add support for sending commands during data transfer
    
    A host controller driver exposes its capability using caps flag
    MMC_CAP_CMD_DURING_TFR. A driver with that capability can accept requests
    that are marked mrq->cap_cmd_during_tfr = true. Then the driver informs the
    upper layers when the command line is available for further commands by
    calling mmc_command_done(). Because of that, the driver will not then
    automatically send STOP commands, and it is the responsibility of the upper
    layer to send a STOP command if it is required.
    
    For requests submitted through the mmc_wait_for_req() interface, the caller
    sets mrq->cap_cmd_during_tfr = true which causes mmc_wait_for_req() in fact
    not to wait. The caller can then send commands that do not use the data
    lines. Finally the caller can wait for the transfer to complete by calling
    mmc_wait_for_req_done() which is now exported.
    
    For requests submitted through the mmc_start_req() interface, the caller
    again sets mrq->cap_cmd_during_tfr = true, but mmc_start_req() anyway does
    not wait. The caller can then send commands that do not use the data
    lines. Finally the caller can wait for the transfer to complete in the
    normal way i.e. calling mmc_start_req() again.
    
    Irrespective of how a cap_cmd_during_tfr request is started,
    mmc_is_req_done() can be called if the upper layer needs to determine if
    the request is done. However the appropriate waiting function (either
    mmc_wait_for_req_done() or mmc_start_req()) must still be called.
    
    The implementation consists primarily of a new completion
    mrq->cmd_completion which notifies when the command line is available for
    further commands. That completion is completed by mmc_command_done().
    When there is an ongoing data transfer, calls to mmc_wait_for_req() will
    automatically wait on that completion, so the caller does not have to do
    anything special.
    
    Note, in the case of errors, the driver may call mmc_request_done() without
    calling mmc_command_done() because mmc_request_done() always calls
    mmc_command_done().
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index d083d2e57abd..f0ed0afe033d 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -120,6 +120,24 @@ static inline void mmc_should_fail_request(struct mmc_host *host,
 
 #endif /* CONFIG_FAIL_MMC_REQUEST */
 
+static inline void mmc_complete_cmd(struct mmc_request *mrq)
+{
+	if (mrq->cap_cmd_during_tfr && !completion_done(&mrq->cmd_completion))
+		complete_all(&mrq->cmd_completion);
+}
+
+void mmc_command_done(struct mmc_host *host, struct mmc_request *mrq)
+{
+	if (!mrq->cap_cmd_during_tfr)
+		return;
+
+	mmc_complete_cmd(mrq);
+
+	pr_debug("%s: cmd done, tfr ongoing (CMD%u)\n",
+		 mmc_hostname(host), mrq->cmd->opcode);
+}
+EXPORT_SYMBOL(mmc_command_done);
+
 /**
  *	mmc_request_done - finish processing an MMC request
  *	@host: MMC host which completed request
@@ -146,6 +164,11 @@ void mmc_request_done(struct mmc_host *host, struct mmc_request *mrq)
 			cmd->retries = 0;
 	}
 
+	if (host->ongoing_mrq == mrq)
+		host->ongoing_mrq = NULL;
+
+	mmc_complete_cmd(mrq);
+
 	trace_mmc_request_done(host, mrq);
 
 	if (err && cmd->retries && !mmc_card_removed(host->card)) {
@@ -158,7 +181,8 @@ void mmc_request_done(struct mmc_host *host, struct mmc_request *mrq)
 	} else {
 		mmc_should_fail_request(host, mrq);
 
-		led_trigger_event(host->led, LED_OFF);
+		if (!host->ongoing_mrq)
+			led_trigger_event(host->led, LED_OFF);
 
 		if (mrq->sbc) {
 			pr_debug("%s: req done <CMD%u>: %d: %08x %08x %08x %08x\n",
@@ -223,6 +247,15 @@ static void __mmc_start_request(struct mmc_host *host, struct mmc_request *mrq)
 		}
 	}
 
+	if (mrq->cap_cmd_during_tfr) {
+		host->ongoing_mrq = mrq;
+		/*
+		 * Retry path could come through here without having waiting on
+		 * cmd_completion, so ensure it is reinitialised.
+		 */
+		reinit_completion(&mrq->cmd_completion);
+	}
+
 	trace_mmc_request_start(host, mrq);
 
 	host->ops->request(host, mrq);
@@ -389,6 +422,18 @@ static void mmc_wait_done(struct mmc_request *mrq)
 	complete(&mrq->completion);
 }
 
+static inline void mmc_wait_ongoing_tfr_cmd(struct mmc_host *host)
+{
+	struct mmc_request *ongoing_mrq = READ_ONCE(host->ongoing_mrq);
+
+	/*
+	 * If there is an ongoing transfer, wait for the command line to become
+	 * available.
+	 */
+	if (ongoing_mrq && !completion_done(&ongoing_mrq->cmd_completion))
+		wait_for_completion(&ongoing_mrq->cmd_completion);
+}
+
 /*
  *__mmc_start_data_req() - starts data request
  * @host: MMC host to start the request
@@ -396,17 +441,24 @@ static void mmc_wait_done(struct mmc_request *mrq)
  *
  * Sets the done callback to be called when request is completed by the card.
  * Starts data mmc request execution
+ * If an ongoing transfer is already in progress, wait for the command line
+ * to become available before sending another command.
  */
 static int __mmc_start_data_req(struct mmc_host *host, struct mmc_request *mrq)
 {
 	int err;
 
+	mmc_wait_ongoing_tfr_cmd(host);
+
 	mrq->done = mmc_wait_data_done;
 	mrq->host = host;
 
+	init_completion(&mrq->cmd_completion);
+
 	err = mmc_start_request(host, mrq);
 	if (err) {
 		mrq->cmd->error = err;
+		mmc_complete_cmd(mrq);
 		mmc_wait_data_done(mrq);
 	}
 
@@ -417,12 +469,17 @@ static int __mmc_start_req(struct mmc_host *host, struct mmc_request *mrq)
 {
 	int err;
 
+	mmc_wait_ongoing_tfr_cmd(host);
+
 	init_completion(&mrq->completion);
 	mrq->done = mmc_wait_done;
 
+	init_completion(&mrq->cmd_completion);
+
 	err = mmc_start_request(host, mrq);
 	if (err) {
 		mrq->cmd->error = err;
+		mmc_complete_cmd(mrq);
 		complete(&mrq->completion);
 	}
 
@@ -486,8 +543,7 @@ static int mmc_wait_for_data_req_done(struct mmc_host *host,
 	return err;
 }
 
-static void mmc_wait_for_req_done(struct mmc_host *host,
-				  struct mmc_request *mrq)
+void mmc_wait_for_req_done(struct mmc_host *host, struct mmc_request *mrq)
 {
 	struct mmc_command *cmd;
 
@@ -528,6 +584,28 @@ static void mmc_wait_for_req_done(struct mmc_host *host,
 
 	mmc_retune_release(host);
 }
+EXPORT_SYMBOL(mmc_wait_for_req_done);
+
+/**
+ *	mmc_is_req_done - Determine if a 'cap_cmd_during_tfr' request is done
+ *	@host: MMC host
+ *	@mrq: MMC request
+ *
+ *	mmc_is_req_done() is used with requests that have
+ *	mrq->cap_cmd_during_tfr = true. mmc_is_req_done() must be called after
+ *	starting a request and before waiting for it to complete. That is,
+ *	either in between calls to mmc_start_req(), or after mmc_wait_for_req()
+ *	and before mmc_wait_for_req_done(). If it is called at other times the
+ *	result is not meaningful.
+ */
+bool mmc_is_req_done(struct mmc_host *host, struct mmc_request *mrq)
+{
+	if (host->areq)
+		return host->context_info.is_done_rcv;
+	else
+		return completion_done(&mrq->completion);
+}
+EXPORT_SYMBOL(mmc_is_req_done);
 
 /**
  *	mmc_pre_req - Prepare for a new request
@@ -648,13 +726,18 @@ EXPORT_SYMBOL(mmc_start_req);
  *	@mrq: MMC request to start
  *
  *	Start a new MMC custom command request for a host, and wait
- *	for the command to complete. Does not attempt to parse the
- *	response.
+ *	for the command to complete. In the case of 'cap_cmd_during_tfr'
+ *	requests, the transfer is ongoing and the caller can issue further
+ *	commands that do not use the data lines, and then wait by calling
+ *	mmc_wait_for_req_done().
+ *	Does not attempt to parse the response.
  */
 void mmc_wait_for_req(struct mmc_host *host, struct mmc_request *mrq)
 {
 	__mmc_start_req(host, mrq);
-	mmc_wait_for_req_done(host, mrq);
+
+	if (!mrq->cap_cmd_during_tfr)
+		mmc_wait_for_req_done(host, mrq);
 }
 EXPORT_SYMBOL(mmc_wait_for_req);
 

commit 6c689886fbe41b6492bd8ee9334ff66893274810
Author: Baolin Wang <baolin.wang@linaro.org>
Date:   Wed Sep 7 10:38:25 2016 +0800

    mmc: core: Optimize the mmc erase size alignment
    
    In most cases the 'card->erase_size' is power of 2, then the round_up/down()
    function is more efficient than '%' operation when the 'card->erase_size' is
    power of 2.
    
    Signed-off-by: Baolin Wang <baolin.wang@linaro.org>
    Tested-by: Shawn Lin <shawn.lin@rock-chips.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 9ce6c25a8f54..d083d2e57abd 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2212,19 +2212,37 @@ static unsigned int mmc_align_erase_size(struct mmc_card *card,
 {
 	unsigned int from_new = *from, nr_new = nr, rem;
 
-	rem = from_new % card->erase_size;
-	if (rem) {
-		rem = card->erase_size - rem;
-		from_new += rem;
+	/*
+	 * When the 'card->erase_size' is power of 2, we can use round_up/down()
+	 * to align the erase size efficiently.
+	 */
+	if (is_power_of_2(card->erase_size)) {
+		unsigned int temp = from_new;
+
+		from_new = round_up(temp, card->erase_size);
+		rem = from_new - temp;
+
 		if (nr_new > rem)
 			nr_new -= rem;
 		else
 			return 0;
-	}
 
-	rem = nr_new % card->erase_size;
-	if (rem)
-		nr_new -= rem;
+		nr_new = round_down(nr_new, card->erase_size);
+	} else {
+		rem = from_new % card->erase_size;
+		if (rem) {
+			rem = card->erase_size - rem;
+			from_new += rem;
+			if (nr_new > rem)
+				nr_new -= rem;
+			else
+				return 0;
+		}
+
+		rem = nr_new % card->erase_size;
+		if (rem)
+			nr_new -= rem;
+	}
 
 	if (nr_new == 0)
 		return 0;

commit 71085123d27dc5d28ce523344f32ac0d20c5f0a5
Author: Baolin Wang <baolin.wang@linaro.org>
Date:   Wed Sep 7 10:38:24 2016 +0800

    mmc: core: Factor out the alignment of erase size
    
    In order to clean up the mmc_erase() function and do some optimization
    for erase size alignment, factor out the guts of erase size alignment
    into mmc_align_erase_size() function.
    
    Signed-off-by: Baolin Wang <baolin.wang@linaro.org>
    Tested-by: Shawn Lin <shawn.lin@rock-chips.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 59b452d5dc81..9ce6c25a8f54 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2205,6 +2205,36 @@ static int mmc_do_erase(struct mmc_card *card, unsigned int from,
 	return err;
 }
 
+static unsigned int mmc_align_erase_size(struct mmc_card *card,
+					 unsigned int *from,
+					 unsigned int *to,
+					 unsigned int nr)
+{
+	unsigned int from_new = *from, nr_new = nr, rem;
+
+	rem = from_new % card->erase_size;
+	if (rem) {
+		rem = card->erase_size - rem;
+		from_new += rem;
+		if (nr_new > rem)
+			nr_new -= rem;
+		else
+			return 0;
+	}
+
+	rem = nr_new % card->erase_size;
+	if (rem)
+		nr_new -= rem;
+
+	if (nr_new == 0)
+		return 0;
+
+	*to = from_new + nr_new;
+	*from = from_new;
+
+	return nr_new;
+}
+
 /**
  * mmc_erase - erase sectors.
  * @card: card to erase
@@ -2243,26 +2273,12 @@ int mmc_erase(struct mmc_card *card, unsigned int from, unsigned int nr,
 			return -EINVAL;
 	}
 
-	if (arg == MMC_ERASE_ARG) {
-		rem = from % card->erase_size;
-		if (rem) {
-			rem = card->erase_size - rem;
-			from += rem;
-			if (nr > rem)
-				nr -= rem;
-			else
-				return 0;
-		}
-		rem = nr % card->erase_size;
-		if (rem)
-			nr -= rem;
-	}
+	if (arg == MMC_ERASE_ARG)
+		nr = mmc_align_erase_size(card, &from, &to, nr);
 
 	if (nr == 0)
 		return 0;
 
-	to = from + nr;
-
 	if (to <= from)
 		return -EINVAL;
 

commit 12182affc74a8ce1e95bd4feeb1638c55d2ab6fd
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Wed Jul 27 00:04:03 2016 +0200

    mmc: core: Use a default maximum erase timeout
    
    In cases when the host->max_busy_timeout isn't specified, the calculated
    number of maximum discard sectors defaults to UINT_MAX. This may cause a
    too long timeout for a discard request.
    
    Avoid this by using a default maximum erase timeout of 60s, used when we
    calculate the maximum number of sectors that are allowed to be discarded
    per request.
    
    Do note that the minimum number of sectors to be discarded is still at
    least one "preferred erase size".
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Shawn Lin <shawn.lin@rock-chips.com>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index e55cde6d436d..59b452d5dc81 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -58,6 +58,9 @@
  */
 #define MMC_BKOPS_MAX_TIMEOUT	(4 * 60 * 1000) /* max time to wait in ms */
 
+/* The max erase timeout, used when host->max_busy_timeout isn't specified */
+#define MMC_ERASE_TIMEOUT_MS	(60 * 1000) /* 60 s */
+
 static const unsigned freqs[] = { 400000, 300000, 200000, 100000 };
 
 /*
@@ -2352,6 +2355,8 @@ static unsigned int mmc_do_calc_max_discard(struct mmc_card *card,
 	struct mmc_host *host = card->host;
 	unsigned int max_discard, x, y, qty = 0, max_qty, min_qty, timeout;
 	unsigned int last_timeout = 0;
+	unsigned int max_busy_timeout = host->max_busy_timeout ?
+			host->max_busy_timeout : MMC_ERASE_TIMEOUT_MS;
 
 	if (card->erase_shift) {
 		max_qty = UINT_MAX >> card->erase_shift;
@@ -2374,15 +2379,15 @@ static unsigned int mmc_do_calc_max_discard(struct mmc_card *card,
 	 * matter what size of 'host->max_busy_timeout', but if the
 	 * 'host->max_busy_timeout' is large enough for more discard sectors,
 	 * then we can continue to increase the max discard sectors until we
-	 * get a balance value.
+	 * get a balance value. In cases when the 'host->max_busy_timeout'
+	 * isn't specified, use the default max erase timeout.
 	 */
 	do {
 		y = 0;
 		for (x = 1; x && x <= max_qty && max_qty - x >= qty; x <<= 1) {
 			timeout = mmc_erase_timeout(card, arg, qty + x);
 
-			if (qty + x > min_qty &&
-			    timeout > host->max_busy_timeout)
+			if (qty + x > min_qty && timeout > max_busy_timeout)
 				break;
 
 			if (timeout < last_timeout)
@@ -2427,9 +2432,6 @@ unsigned int mmc_calc_max_discard(struct mmc_card *card)
 	struct mmc_host *host = card->host;
 	unsigned int max_discard, max_trim;
 
-	if (!host->max_busy_timeout)
-		return UINT_MAX;
-
 	/*
 	 * Without erase_group_def set, MMC erase timeout depends on clock
 	 * frequence which can change.  In that case, the best choice is
@@ -2447,7 +2449,8 @@ unsigned int mmc_calc_max_discard(struct mmc_card *card)
 		max_discard = 0;
 	}
 	pr_debug("%s: calculated max. discard sectors %u for timeout %u ms\n",
-		 mmc_hostname(host), max_discard, host->max_busy_timeout);
+		mmc_hostname(host), max_discard, host->max_busy_timeout ?
+		host->max_busy_timeout : MMC_ERASE_TIMEOUT_MS);
 	return max_discard;
 }
 EXPORT_SYMBOL(mmc_calc_max_discard);

commit bb4eecf23be259929f9e7d173890a83ae5f87d4c
Author: Baolin Wang <baolin.wang@linaro.org>
Date:   Mon Jul 25 16:48:39 2016 +0800

    mmc: Change the max discard sectors and erase response when HW busy detect
    
    When mmc host HW supports busy signalling (using R1B as response), don't
    use the host->max_busy_timeout as the limitation when deciding the max
    discard sectors, which we inform the generic BLOCK layer about. Instead,
    let's use at least one preferred erase size as the max discard sectors.
    
    In cases when the host controller supports HW busy signalling and the
    timeout for the erase operation doesn't exceed the max_busy_timeout, we
    keep the R1B response, otherwise we prevent the host from doing HW busy
    detection by converting to a R1 response.
    
    Signed-off-by: Baolin Wang <baolin.wang@linaro.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 94cbf4e170e3..e55cde6d436d 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2067,7 +2067,8 @@ static int mmc_do_erase(struct mmc_card *card, unsigned int from,
 			unsigned int to, unsigned int arg)
 {
 	struct mmc_command cmd = {0};
-	unsigned int qty = 0;
+	unsigned int qty = 0, busy_timeout = 0;
+	bool use_r1b_resp = false;
 	unsigned long timeout;
 	int err;
 
@@ -2135,8 +2136,22 @@ static int mmc_do_erase(struct mmc_card *card, unsigned int from,
 	memset(&cmd, 0, sizeof(struct mmc_command));
 	cmd.opcode = MMC_ERASE;
 	cmd.arg = arg;
-	cmd.flags = MMC_RSP_SPI_R1B | MMC_RSP_R1B | MMC_CMD_AC;
-	cmd.busy_timeout = mmc_erase_timeout(card, arg, qty);
+	busy_timeout = mmc_erase_timeout(card, arg, qty);
+	/*
+	 * If the host controller supports busy signalling and the timeout for
+	 * the erase operation does not exceed the max_busy_timeout, we should
+	 * use R1B response. Or we need to prevent the host from doing hw busy
+	 * detection, which is done by converting to a R1 response instead.
+	 */
+	if (card->host->max_busy_timeout &&
+	    busy_timeout > card->host->max_busy_timeout) {
+		cmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_AC;
+	} else {
+		cmd.flags = MMC_RSP_SPI_R1B | MMC_RSP_R1B | MMC_CMD_AC;
+		cmd.busy_timeout = busy_timeout;
+		use_r1b_resp = true;
+	}
+
 	err = mmc_wait_for_cmd(card->host, &cmd, 0);
 	if (err) {
 		pr_err("mmc_erase: erase error %d, status %#x\n",
@@ -2148,7 +2163,14 @@ static int mmc_do_erase(struct mmc_card *card, unsigned int from,
 	if (mmc_host_is_spi(card->host))
 		goto out;
 
-	timeout = jiffies + msecs_to_jiffies(MMC_CORE_TIMEOUT_MS);
+	/*
+	 * In case of when R1B + MMC_CAP_WAIT_WHILE_BUSY is used, the polling
+	 * shall be avoided.
+	 */
+	if ((card->host->caps & MMC_CAP_WAIT_WHILE_BUSY) && use_r1b_resp)
+		goto out;
+
+	timeout = jiffies + msecs_to_jiffies(busy_timeout);
 	do {
 		memset(&cmd, 0, sizeof(struct mmc_command));
 		cmd.opcode = MMC_SEND_STATUS;
@@ -2328,23 +2350,41 @@ static unsigned int mmc_do_calc_max_discard(struct mmc_card *card,
 					    unsigned int arg)
 {
 	struct mmc_host *host = card->host;
-	unsigned int max_discard, x, y, qty = 0, max_qty, timeout;
+	unsigned int max_discard, x, y, qty = 0, max_qty, min_qty, timeout;
 	unsigned int last_timeout = 0;
 
-	if (card->erase_shift)
+	if (card->erase_shift) {
 		max_qty = UINT_MAX >> card->erase_shift;
-	else if (mmc_card_sd(card))
+		min_qty = card->pref_erase >> card->erase_shift;
+	} else if (mmc_card_sd(card)) {
 		max_qty = UINT_MAX;
-	else
+		min_qty = card->pref_erase;
+	} else {
 		max_qty = UINT_MAX / card->erase_size;
+		min_qty = card->pref_erase / card->erase_size;
+	}
 
-	/* Find the largest qty with an OK timeout */
+	/*
+	 * We should not only use 'host->max_busy_timeout' as the limitation
+	 * when deciding the max discard sectors. We should set a balance value
+	 * to improve the erase speed, and it can not get too long timeout at
+	 * the same time.
+	 *
+	 * Here we set 'card->pref_erase' as the minimal discard sectors no
+	 * matter what size of 'host->max_busy_timeout', but if the
+	 * 'host->max_busy_timeout' is large enough for more discard sectors,
+	 * then we can continue to increase the max discard sectors until we
+	 * get a balance value.
+	 */
 	do {
 		y = 0;
 		for (x = 1; x && x <= max_qty && max_qty - x >= qty; x <<= 1) {
 			timeout = mmc_erase_timeout(card, arg, qty + x);
-			if (timeout > host->max_busy_timeout)
+
+			if (qty + x > min_qty &&
+			    timeout > host->max_busy_timeout)
 				break;
+
 			if (timeout < last_timeout)
 				break;
 			last_timeout = timeout;

commit a0c3b68c72a355f5dab33c3ddcd257e5a718de0c
Author: Shawn Lin <shawn.lin@rock-chips.com>
Date:   Fri Jul 1 15:45:28 2016 +0800

    mmc: core: Allow hosts to specify non-support for MMC commands
    
    Host drivers which needs to valdiate for non-supported MMC
    commands and returnn error code for such requests.
    
    To improve and simplify the behaviour, let's invent MMC_CAP2_NO_MMC
    which these host drivers can set to tell the mmc core to skip sending MMC
    commands during card initialization.
    
    Signed-off-by: Shawn Lin <shawn.lin@rock-chips.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 4c823df8deb4..94cbf4e170e3 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2510,8 +2510,9 @@ static int mmc_rescan_try_freq(struct mmc_host *host, unsigned freq)
 		if (!mmc_attach_sd(host))
 			return 0;
 
-	if (!mmc_attach_mmc(host))
-		return 0;
+	if (!(host->caps2 & MMC_CAP2_NO_MMC))
+		if (!mmc_attach_mmc(host))
+			return 0;
 
 	mmc_power_off(host);
 	return -EIO;

commit 1b8d79c5494484d140f2a19101412b51e2d5f6b5
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Tue Jun 21 15:12:46 2016 +0200

    mmc: core: Allow hosts to specify non-support for SD commands
    
    There are host drivers which needs to valdiate for non-supported SD
    commands and returnn error code for such requests.
    
    To improve and simplify the behaviour, let's invent MMC_CAP2_NO_SD
    which these host drivers can set to tell the mmc core to skip sending SD
    commands during card initialization.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 1d24b3ad2a5d..4c823df8deb4 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2498,15 +2498,18 @@ static int mmc_rescan_try_freq(struct mmc_host *host, unsigned freq)
 
 	mmc_go_idle(host);
 
-	mmc_send_if_cond(host, host->ocr_avail);
+	if (!(host->caps2 & MMC_CAP2_NO_SD))
+		mmc_send_if_cond(host, host->ocr_avail);
 
 	/* Order's important: probe SDIO, then SD, then MMC */
 	if (!(host->caps2 & MMC_CAP2_NO_SDIO))
 		if (!mmc_attach_sdio(host))
 			return 0;
 
-	if (!mmc_attach_sd(host))
-		return 0;
+	if (!(host->caps2 & MMC_CAP2_NO_SD))
+		if (!mmc_attach_sd(host))
+			return 0;
+
 	if (!mmc_attach_mmc(host))
 		return 0;
 

commit c6d8fd61c096e9f84c0bd0bc38ccf5856b76c772
Author: Gwendal Grignou <gwendal@chromium.org>
Date:   Fri Jun 3 09:08:52 2016 -0700

    mmc: Set pref erase size based on size
    
    If available, eMMC stack uses HC_ERASE_GRP_SIZE as the preferred erase
    size. As some high capacity eMMC (64MB) reports this size to 512kB, the
    discard operations end up taking very long time.
    
    Improve the behaviour by instead calculating the preferred erase size
    based on the eMMC size. In this way the discard operations becomes faster.
    
    Signed-off-by: Gwendal Grignou <gwendal@chromium.org>
    [Ulf: Updated changelog and improved comment in code]
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index e8641873dee7..1d24b3ad2a5d 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1934,17 +1934,15 @@ void mmc_init_erase(struct mmc_card *card)
 	 * to that size and alignment.
 	 *
 	 * For SD cards that define Allocation Unit size, limit erases to one
-	 * Allocation Unit at a time.  For MMC cards that define High Capacity
-	 * Erase Size, whether it is switched on or not, limit to that size.
-	 * Otherwise just have a stab at a good value.  For modern cards it
-	 * will end up being 4MiB.  Note that if the value is too small, it
-	 * can end up taking longer to erase.
+	 * Allocation Unit at a time.
+	 * For MMC, have a stab at ai good value and for modern cards it will
+	 * end up being 4MiB. Note that if the value is too small, it can end
+	 * up taking longer to erase. Also note, erase_size is already set to
+	 * High Capacity Erase Size if available when this function is called.
 	 */
 	if (mmc_card_sd(card) && card->ssr.au) {
 		card->pref_erase = card->ssr.au;
 		card->erase_shift = ffs(card->ssr.au) - 1;
-	} else if (card->ext_csd.hc_erase_size) {
-		card->pref_erase = card->ext_csd.hc_erase_size;
 	} else if (card->erase_size) {
 		sz = (card->csd.capacity << (card->csd.read_blkbits - 9)) >> 11;
 		if (sz < 128)

commit 81ac2af65793ecfbd79875d45043ff4adc0982b8
Author: Shawn Lin <shawn.lin@rock-chips.com>
Date:   Thu May 26 09:56:22 2016 +0800

    mmc: core: implement enhanced strobe support
    
    Controllers use data strobe line to latch data from devices
    under hs400 mode, but not for cmd line. So since emmc 5.1, JEDEC
    introduces enhanced strobe mode for latching cmd response from
    emmc devices to host controllers. This new feature is optional,
    so it depends both on device's cap and host's cap to decide
    whether to use it or not.
    
    Signed-off-by: Shawn Lin <shawn.lin@rock-chips.com>
    
    Reviewed-by: Jaehoon Chung <jh80.chung@samsung.com>
    Tested-by: Douglas Anderson <dianders@chromium.org>
    Tested-by: Jaehoon Chung <jh80.chung@samsung.com>
    Acked-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 8b4dfd45433b..e8641873dee7 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1127,6 +1127,15 @@ void mmc_set_initial_state(struct mmc_host *host)
 	host->ios.bus_width = MMC_BUS_WIDTH_1;
 	host->ios.timing = MMC_TIMING_LEGACY;
 	host->ios.drv_type = 0;
+	host->ios.enhanced_strobe = false;
+
+	/*
+	 * Make sure we are in non-enhanced strobe mode before we
+	 * actually enable it in ext_csd.
+	 */
+	if ((host->caps2 & MMC_CAP2_HS400_ES) &&
+	     host->ops->hs400_enhanced_strobe)
+		host->ops->hs400_enhanced_strobe(host, &host->ios);
 
 	mmc_set_ios(host);
 }

commit 32ecd320db39bcb007679ed42f283740641b81ea
Author: Matt Gumbel <matthew.k.gumbel@intel.com>
Date:   Fri May 20 10:33:46 2016 +0300

    mmc: longer timeout for long read time quirk
    
    008GE0 Toshiba mmc in some Intel Baytrail tablets responds to
    MMC_SEND_EXT_CSD in 450-600ms.
    
    This patch will...
    
    () Increase the long read time quirk timeout from 300ms to 600ms. Original
       author of that quirk says 300ms was only a guess and that the number
       may need to be raised in the future.
    
    () Add this specific MMC to the quirk
    
    Signed-off-by: Matt Gumbel <matthew.k.gumbel@intel.com>
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 99275e40bf2f..8b4dfd45433b 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -875,11 +875,11 @@ void mmc_set_data_timeout(struct mmc_data *data, const struct mmc_card *card)
 	/*
 	 * Some cards require longer data read timeout than indicated in CSD.
 	 * Address this by setting the read timeout to a "reasonably high"
-	 * value. For the cards tested, 300ms has proven enough. If necessary,
+	 * value. For the cards tested, 600ms has proven enough. If necessary,
 	 * this value can be increased if other problematic cards require this.
 	 */
 	if (mmc_card_long_read_time(card) && data->flags & MMC_DATA_READ) {
-		data->timeout_ns = 300000000;
+		data->timeout_ns = 600000000;
 		data->timeout_clks = 0;
 	}
 

commit 4e6c71788d6bb0e5438fc9211fa6e52dcca01474
Author: Gwendal Grignou <gwendal@chromium.org>
Date:   Fri Apr 1 16:04:22 2016 -0700

    mmc: core: Do regular power cycle when lacking eMMC HW reset support
    
    The eMMC HW reset may be implemented either via the host ops ->hw_reset()
    callback or through DT and the eMMC pwrseq. Additionally some eMMC cards
    don't support HW reset.
    
    To allow a reset to be done for the different combinations of mmc hosts
    and eMMC/MMC cards, let's implement a fallback via trying a regular power
    cycle. This improves the mmc block layer retry mechanism of failing I/O
    requests.
    
    Signed-off-by: Gwendal Grignou <gwendal@chromium.org>
    [Ulf: Rewrote changelog]
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index f80b3ab3266a..99275e40bf2f 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2456,8 +2456,9 @@ int mmc_hw_reset(struct mmc_host *host)
 	ret = host->bus_ops->reset(host);
 	mmc_bus_put(host);
 
-	if (ret != -EOPNOTSUPP)
-		pr_warn("%s: tried to reset card\n", mmc_hostname(host));
+	if (ret)
+		pr_warn("%s: tried to reset card, got error %d\n",
+			mmc_hostname(host), ret);
 
 	return ret;
 }

commit 7962fc376f603547b130c0fd7932ac6e9df4ee8b
Author: Baolin Wang <baolin.wang@linaro.org>
Date:   Thu Mar 31 11:16:27 2016 +0800

    mmc: core: Provide tracepoints for request processing
    
    This patch provides some tracepoints for the lifecycle of a mmc request
    from starting to completion to help with performance analysis of MMC
    subsystem.
    
    Signed-off-by: Baolin Wang <baolin.wang@linaro.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 41b1e761965f..f80b3ab3266a 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -36,6 +36,9 @@
 #include <linux/mmc/sd.h>
 #include <linux/mmc/slot-gpio.h>
 
+#define CREATE_TRACE_POINTS
+#include <trace/events/mmc.h>
+
 #include "core.h"
 #include "bus.h"
 #include "host.h"
@@ -140,6 +143,8 @@ void mmc_request_done(struct mmc_host *host, struct mmc_request *mrq)
 			cmd->retries = 0;
 	}
 
+	trace_mmc_request_done(host, mrq);
+
 	if (err && cmd->retries && !mmc_card_removed(host->card)) {
 		/*
 		 * Request starter must handle retries - see
@@ -215,6 +220,8 @@ static void __mmc_start_request(struct mmc_host *host, struct mmc_request *mrq)
 		}
 	}
 
+	trace_mmc_request_start(host, mrq);
+
 	host->ops->request(host, mrq);
 }
 

commit 07d97d872359d15f0f50f3bceb8f932be99a2226
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Fri Jan 29 09:44:05 2016 +0000

    mmc: core: report tuning command execution failure reason
    
    Print the error code when the tuning command fails.  This allows the
    reason for the failure to be reported, which aids debugging.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 319efdc1ad21..41b1e761965f 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1079,7 +1079,8 @@ int mmc_execute_tuning(struct mmc_card *card)
 	err = host->ops->execute_tuning(host, opcode);
 
 	if (err)
-		pr_err("%s: tuning execution failed\n", mmc_hostname(host));
+		pr_err("%s: tuning execution failed: %d\n",
+			mmc_hostname(host), err);
 	else
 		mmc_retune_enable(host);
 

commit cf925747d20b7a932db01c1f0abeaeacd0d0477d
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Fri Jan 29 09:43:55 2016 +0000

    mmc: core: improve mmc_of_parse_voltage() to return better status
    
    Improve mmc_of_parse_voltage()'s return values so that drivers can tell
    whether a voltage-range specification was present, and whether it has
    been successfully parsed, or there was an error while parsing.
    
    We return a negative errno when parsing fails, zero if no voltage-range
    specification is present, or one if a voltage-range specification is
    successfully parsed.
    
    No users need modifying as no users check the return value.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index a6ad78c3bb5e..319efdc1ad21 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1204,8 +1204,9 @@ EXPORT_SYMBOL(mmc_vddrange_to_ocrmask);
  * @np: The device node need to be parsed.
  * @mask: mask of voltages available for MMC/SD/SDIO
  *
- * 1. Return zero on success.
- * 2. Return negative errno: voltage-range is invalid.
+ * Parse the "voltage-ranges" DT property, returning zero if it is not
+ * found, negative errno if the voltage-range specification is invalid,
+ * or one if the voltage-range is specified and successfully parsed.
  */
 int mmc_of_parse_voltage(struct device_node *np, u32 *mask)
 {
@@ -1216,7 +1217,7 @@ int mmc_of_parse_voltage(struct device_node *np, u32 *mask)
 	num_ranges = num_ranges / sizeof(*voltage_ranges) / 2;
 	if (!voltage_ranges) {
 		pr_debug("%s: voltage-ranges unspecified\n", np->full_name);
-		return -EINVAL;
+		return 0;
 	}
 	if (!num_ranges) {
 		pr_err("%s: voltage-ranges empty\n", np->full_name);
@@ -1238,7 +1239,7 @@ int mmc_of_parse_voltage(struct device_node *np, u32 *mask)
 		*mask |= ocr_mask;
 	}
 
-	return 0;
+	return 1;
 }
 EXPORT_SYMBOL(mmc_of_parse_voltage);
 

commit 10a16a01d8f72e80f4780e40cf3122f4caffa411
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Fri Jan 29 09:43:50 2016 +0000

    mmc: core: shut up "voltage-ranges unspecified" pr_info()
    
    Each time a driver such as sdhci-esdhc-imx is probed, we get a info
    printk complaining that the DT voltage-ranges property has not been
    specified.
    
    However, the DT binding specifically says that the voltage-ranges
    property is optional.  That means we should not be complaining that
    DT hasn't specified this property: by indicating that it's optional,
    it is valid not to have the property in DT.
    
    Silence the warning if the property is missing.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index abd3212154d4..a6ad78c3bb5e 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1214,8 +1214,12 @@ int mmc_of_parse_voltage(struct device_node *np, u32 *mask)
 
 	voltage_ranges = of_get_property(np, "voltage-ranges", &num_ranges);
 	num_ranges = num_ranges / sizeof(*voltage_ranges) / 2;
-	if (!voltage_ranges || !num_ranges) {
-		pr_info("%s: voltage-ranges unspecified\n", np->full_name);
+	if (!voltage_ranges) {
+		pr_debug("%s: voltage-ranges unspecified\n", np->full_name);
+		return -EINVAL;
+	}
+	if (!num_ranges) {
+		pr_err("%s: voltage-ranges empty\n", np->full_name);
 		return -EINVAL;
 	}
 

commit ed9feec72fc1fa194ebfdb79e14561b35decce63
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Fri Jan 29 09:27:50 2016 +0100

    mmc: sanitize 'bus width' in debug output
    
    The bus width is sometimes the actual bus width, and sometimes indices
    to different arrays encoding the bus width. In my debugging case "2"
    could mean 8-bit as well as 4-bit, which was extremly confusing. Let's
    use the human-readable actual bus width in all places.
    
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 9da9b604b1c1..abd3212154d4 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1033,7 +1033,7 @@ static inline void mmc_set_ios(struct mmc_host *host)
 		"width %u timing %u\n",
 		 mmc_hostname(host), ios->clock, ios->bus_mode,
 		 ios->power_mode, ios->chip_select, ios->vdd,
-		 ios->bus_width, ios->timing);
+		 1 << ios->bus_width, ios->timing);
 
 	host->ops->set_ios(host, ios);
 }

commit 6067bafe44d7ce0fbbfe7aa3c463630e61d35237
Author: Jaehoon Chung <jh80.chung@samsung.com>
Date:   Fri Jan 29 08:52:57 2016 +0900

    mmc: core: use the defined function to check whether card is removable
    
    In linux/mmc/host.h, mmc_card_is_removable() is already defined.
    There is no reason that it doesn't use.
    
    Signed-off-by: Jaehoon Chung <jh80.chung@samsung.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index f95d41ffc766..9da9b604b1c1 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2532,7 +2532,7 @@ int mmc_detect_card_removed(struct mmc_host *host)
 	if (!card)
 		return 1;
 
-	if (host->caps & MMC_CAP_NONREMOVABLE)
+	if (!mmc_card_is_removable(host))
 		return 0;
 
 	ret = mmc_card_removed(card);
@@ -2570,7 +2570,7 @@ void mmc_rescan(struct work_struct *work)
 		return;
 
 	/* If there is a non-removable card registered, only scan once */
-	if ((host->caps & MMC_CAP_NONREMOVABLE) && host->rescan_entered)
+	if (!mmc_card_is_removable(host) && host->rescan_entered)
 		return;
 	host->rescan_entered = 1;
 
@@ -2587,8 +2587,7 @@ void mmc_rescan(struct work_struct *work)
 	 * if there is a _removable_ card registered, check whether it is
 	 * still present
 	 */
-	if (host->bus_ops && !host->bus_dead
-	    && !(host->caps & MMC_CAP_NONREMOVABLE))
+	if (host->bus_ops && !host->bus_dead && mmc_card_is_removable(host))
 		host->bus_ops->detect(host);
 
 	host->detect_change = 0;
@@ -2613,7 +2612,7 @@ void mmc_rescan(struct work_struct *work)
 	mmc_bus_put(host);
 
 	mmc_claim_host(host);
-	if (!(host->caps & MMC_CAP_NONREMOVABLE) && host->ops->get_cd &&
+	if (mmc_card_is_removable(host) && host->ops->get_cd &&
 			host->ops->get_cd(host) == 0) {
 		mmc_power_off(host);
 		mmc_release_host(host);

commit 520bd7a8b4152aacfbd34eb7f7a447354b631039
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Tue Dec 1 10:35:29 2015 +0100

    mmc: core: Optimize boot time by detecting cards simultaneously
    
    The mmc workqueue is an ordered workqueue, allowing only one work to
    execute per given time. As this workqueue is used for card detection, the
    conseqeunce is that cards will be detected one by one waiting for each
    other.
    
    Moreover, most of the time spent during card initialization is waiting for
    the card's internal firmware to be ready. From a CPU perspective this
    typically means waiting for a completion variable to be kicked via an
    IRQ-handler or waiting for a sleep timer to finish.
    
    This behaviour of detecting/initializing cards is sub-optimal, especially
    for SOCs having several controllers/cards.
    
    Let's convert to use the system_freezable_wq for the mmc detect works.
    This enables several works to be executed simultaneously and thus also
    cards to be detected like so.
    
    Tests on UX500, which holds two eMMC cards and an SD-card (actually also
    an SDIO card, currently not detected), shows a significant improved
    behaviour due to this change.
    
    Before this change, both the eMMC cards waited for the SD card to be
    initialized as its detect work entered the workqueue first. In some cases,
    depending on the characteristic of the SD-card, they got delayed 1-1.5 s.
    
    Additionally for the second eMMC, it needed to wait for the first eMMC to
    be initialized which added another 120-190 ms.
    
    Converting to the system_freezable_wq, removed these delays and made both
    the eMMC cards available far earlier in the boot sequence.
    
    Selecting the system_freezable_wq, in favour of for example the system_wq,
    is because we need card detection mechanism to be disabled once userspace
    are frozen during system PM. Currently the mmc core deal with this via PM
    notifiers, but following patches may utilize the behaviour of the
    system_freezable_wq, to simplify the use of the PM notifiers.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Tested-by: Alan Cooper <alcooperx@gmail.com>
    Tested-by: Shawn Lin <shawn.lin@rock-chips.com>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 910aa254f23a..f95d41ffc766 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -55,7 +55,6 @@
  */
 #define MMC_BKOPS_MAX_TIMEOUT	(4 * 60 * 1000) /* max time to wait in ms */
 
-static struct workqueue_struct *workqueue;
 static const unsigned freqs[] = { 400000, 300000, 200000, 100000 };
 
 /*
@@ -66,21 +65,16 @@ static const unsigned freqs[] = { 400000, 300000, 200000, 100000 };
 bool use_spi_crc = 1;
 module_param(use_spi_crc, bool, 0);
 
-/*
- * Internal function. Schedule delayed work in the MMC work queue.
- */
 static int mmc_schedule_delayed_work(struct delayed_work *work,
 				     unsigned long delay)
 {
-	return queue_delayed_work(workqueue, work, delay);
-}
-
-/*
- * Internal function. Flush all scheduled work from the MMC work queue.
- */
-static void mmc_flush_scheduled_work(void)
-{
-	flush_workqueue(workqueue);
+	/*
+	 * We use the system_freezable_wq, because of two reasons.
+	 * First, it allows several works (not the same work item) to be
+	 * executed simultaneously. Second, the queue becomes frozen when
+	 * userspace becomes frozen during system PM.
+	 */
+	return queue_delayed_work(system_freezable_wq, work, delay);
 }
 
 #ifdef CONFIG_FAIL_MMC_REQUEST
@@ -2669,7 +2663,6 @@ void mmc_stop_host(struct mmc_host *host)
 
 	host->rescan_disable = 1;
 	cancel_delayed_work_sync(&host->detect);
-	mmc_flush_scheduled_work();
 
 	/* clear pm flags now and let card drivers set them as needed */
 	host->pm_flags = 0;
@@ -2852,13 +2845,9 @@ static int __init mmc_init(void)
 {
 	int ret;
 
-	workqueue = alloc_ordered_workqueue("kmmcd", 0);
-	if (!workqueue)
-		return -ENOMEM;
-
 	ret = mmc_register_bus();
 	if (ret)
-		goto destroy_workqueue;
+		return ret;
 
 	ret = mmc_register_host_class();
 	if (ret)
@@ -2874,9 +2863,6 @@ static int __init mmc_init(void)
 	mmc_unregister_host_class();
 unregister_bus:
 	mmc_unregister_bus();
-destroy_workqueue:
-	destroy_workqueue(workqueue);
-
 	return ret;
 }
 
@@ -2885,7 +2871,6 @@ static void __exit mmc_exit(void)
 	sdio_unregister_bus();
 	mmc_unregister_host_class();
 	mmc_unregister_bus();
-	destroy_workqueue(workqueue);
 }
 
 subsys_initcall(mmc_init);

commit 100a606d54a087cfec54efbedba72f36e5a9cdf0
Author: Carlo Caione <carlo@endlessm.com>
Date:   Wed Nov 25 15:39:51 2015 +0100

    mmc: core: Introduce MMC_CAP2_NO_SDIO cap
    
    This patch introduce a new MMC_CAP2_NO_SDIO cap used to tell the mmc
    core to not send SDIO specific commands.
    
    Signed-off-by: Carlo Caione <carlo@endlessm.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 07b2f086213f..910aa254f23a 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2476,15 +2476,20 @@ static int mmc_rescan_try_freq(struct mmc_host *host, unsigned freq)
 	 * sdio_reset sends CMD52 to reset card.  Since we do not know
 	 * if the card is being re-initialized, just send it.  CMD52
 	 * should be ignored by SD/eMMC cards.
+	 * Skip it if we already know that we do not support SDIO commands
 	 */
-	sdio_reset(host);
+	if (!(host->caps2 & MMC_CAP2_NO_SDIO))
+		sdio_reset(host);
+
 	mmc_go_idle(host);
 
 	mmc_send_if_cond(host, host->ocr_avail);
 
 	/* Order's important: probe SDIO, then SD, then MMC */
-	if (!mmc_attach_sdio(host))
-		return 0;
+	if (!(host->caps2 & MMC_CAP2_NO_SDIO))
+		if (!mmc_attach_sdio(host))
+			return 0;
+
 	if (!mmc_attach_sd(host))
 		return 0;
 	if (!mmc_attach_mmc(host))

commit 6e1bbc51439705b834688c592e13dfa82e32ff04
Author: ludovic.desroches@atmel.com <ludovic.desroches@atmel.com>
Date:   Mon Nov 9 15:03:59 2015 +0100

    mmc: core: set regulator not found message as debug
    
    Turn the informative message about no vmmc/vqmmc regulator found in
    debug one. There is no need to indicate that something optional is
    missing. Moreover, it can bring confusion, people who doesn't know
    it is optional may consider these messages as warnings or errors.
    
    Signed-off-by: Ludovic Desroches <ludovic.desroches@atmel.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index a450e91504f3..07b2f086213f 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1485,7 +1485,7 @@ int mmc_regulator_get_supply(struct mmc_host *mmc)
 	if (IS_ERR(mmc->supply.vmmc)) {
 		if (PTR_ERR(mmc->supply.vmmc) == -EPROBE_DEFER)
 			return -EPROBE_DEFER;
-		dev_info(dev, "No vmmc regulator found\n");
+		dev_dbg(dev, "No vmmc regulator found\n");
 	} else {
 		ret = mmc_regulator_get_ocrmask(mmc->supply.vmmc);
 		if (ret > 0)
@@ -1497,7 +1497,7 @@ int mmc_regulator_get_supply(struct mmc_host *mmc)
 	if (IS_ERR(mmc->supply.vqmmc)) {
 		if (PTR_ERR(mmc->supply.vqmmc) == -EPROBE_DEFER)
 			return -EPROBE_DEFER;
-		dev_info(dev, "No vqmmc regulator found\n");
+		dev_dbg(dev, "No vqmmc regulator found\n");
 	}
 
 	return 0;

commit 1ff2575bcf42caefaaab8e2fb00e238852fac8e2
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu Nov 5 16:21:39 2015 +0100

    mmc: core: Check for non-removable cards earlier in the error path
    
    _mmc_detect_card_removed() validates that the card is removable, but when
    being called via the bus_ops ->detect() callbacks, the validation is
    redundant as it's already done in mmc_rescan().
    
    Move the validation of a removable card to the mmc_detect_card_removed()
    API, which is where it's applicable, to allow the blk error recovery path
    to get the response a bit earlier.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 18a3f2c41136..a450e91504f3 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2498,9 +2498,6 @@ int _mmc_detect_card_removed(struct mmc_host *host)
 {
 	int ret;
 
-	if (host->caps & MMC_CAP_NONREMOVABLE)
-		return 0;
-
 	if (!host->card || mmc_card_removed(host->card))
 		return 1;
 
@@ -2536,6 +2533,9 @@ int mmc_detect_card_removed(struct mmc_host *host)
 	if (!card)
 		return 1;
 
+	if (host->caps & MMC_CAP_NONREMOVABLE)
+		return 0;
+
 	ret = mmc_card_removed(card);
 	/*
 	 * The card will be considered unchanged unless we have been asked to

commit 8dede18e2e86c8e272cd74e66b0e86872cbe7e02
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu Nov 5 16:11:12 2015 +0100

    mmc: core: Refactor code to register the MMC PM notifier
    
    Instead of checking for "#ifdef" directly in the code, let's invent a pair
    of mmc core functions to deal with register/unregister the MMC PM notifier
    block. Implement stubs for these functions when CONFIG_PM_SLEEP is unset,
    as in that case the PM notifiers isn't used.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 394963d3fb18..18a3f2c41136 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2760,14 +2760,13 @@ int mmc_flush_cache(struct mmc_card *card)
 }
 EXPORT_SYMBOL(mmc_flush_cache);
 
-#ifdef CONFIG_PM
-
+#ifdef CONFIG_PM_SLEEP
 /* Do the card removal on suspend if card is assumed removeable
  * Do that in pm notifier while userspace isn't yet frozen, so we will be able
    to sync the card.
 */
-int mmc_pm_notify(struct notifier_block *notify_block,
-					unsigned long mode, void *unused)
+static int mmc_pm_notify(struct notifier_block *notify_block,
+			unsigned long mode, void *unused)
 {
 	struct mmc_host *host = container_of(
 		notify_block, struct mmc_host, pm_notify);
@@ -2814,6 +2813,17 @@ int mmc_pm_notify(struct notifier_block *notify_block,
 
 	return 0;
 }
+
+void mmc_register_pm_notifier(struct mmc_host *host)
+{
+	host->pm_notify.notifier_call = mmc_pm_notify;
+	register_pm_notifier(&host->pm_notify);
+}
+
+void mmc_unregister_pm_notifier(struct mmc_host *host)
+{
+	unregister_pm_notifier(&host->pm_notify);
+}
 #endif
 
 /**

commit d234d2123fa734c8018f7d01ed5d663cf5e6f665
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu Nov 5 16:08:08 2015 +0100

    mmc: core: Keep host claimed in mmc_rescan() while calling host ops
    
    As mmc_claim_host() invokes pm_runtime_get_sync() for the mmc host device,
    it's important that the host is kept claimed for *all* accesses to it via
    the host_ops callbacks.
    
    In mmc_rescan(), the ->card_event() and the ->get_cd() callback are being
    invoked without claiming the host, let's fix this.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index c1027a432785..394963d3fb18 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2576,7 +2576,9 @@ void mmc_rescan(struct work_struct *work)
 	host->rescan_entered = 1;
 
 	if (host->trigger_card_event && host->ops->card_event) {
+		mmc_claim_host(host);
 		host->ops->card_event(host);
+		mmc_release_host(host);
 		host->trigger_card_event = false;
 	}
 
@@ -2611,15 +2613,14 @@ void mmc_rescan(struct work_struct *work)
 	 */
 	mmc_bus_put(host);
 
+	mmc_claim_host(host);
 	if (!(host->caps & MMC_CAP_NONREMOVABLE) && host->ops->get_cd &&
 			host->ops->get_cd(host) == 0) {
-		mmc_claim_host(host);
 		mmc_power_off(host);
 		mmc_release_host(host);
 		goto out;
 	}
 
-	mmc_claim_host(host);
 	for (i = 0; i < ARRAY_SIZE(freqs); i++) {
 		if (!mmc_rescan_try_freq(host, max(freqs[i], host->f_min)))
 			break;

commit 86236813ff23e0e8afc6844d307fb84df98f6723
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu Nov 5 16:08:07 2015 +0100

    mmc: core: Invoke ->card_event() callback only when needed
    
    The ->card_event() callback may be called when re-scan is disabled and for
    non-removable cards, which both cases are unnecessary.
    
    Instead let's move the call later in mmc_rescan() where these constraints
    have been validated.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 5ae89e48fd85..c1027a432785 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2567,11 +2567,6 @@ void mmc_rescan(struct work_struct *work)
 		container_of(work, struct mmc_host, detect.work);
 	int i;
 
-	if (host->trigger_card_event && host->ops->card_event) {
-		host->ops->card_event(host);
-		host->trigger_card_event = false;
-	}
-
 	if (host->rescan_disable)
 		return;
 
@@ -2580,6 +2575,11 @@ void mmc_rescan(struct work_struct *work)
 		return;
 	host->rescan_entered = 1;
 
+	if (host->trigger_card_event && host->ops->card_event) {
+		host->ops->card_event(host);
+		host->trigger_card_event = false;
+	}
+
 	mmc_bus_get(host);
 
 	/*

commit 2086f801cb2a796279e817e68255654c4cfd3be3
Author: Douglas Anderson <dianders@chromium.org>
Date:   Mon Oct 12 14:48:25 2015 +0200

    mmc: core: Add mmc_regulator_set_vqmmc()
    
    This adds logic to the MMC core to set VQMMC.  This is expected to be
    called by MMC drivers like dw_mmc as part of (or instead of) their
    start_signal_voltage_switch() callback.
    
    A few notes:
    
    * When setting the signal voltage to 3.3V we do our best to make VQMMC
      and VMMC match.  It's been reported that this makes some old cards
      happy since they were tested back in the day before UHS when VQMMC
      and VMMC were provided by the same regulator.  A nice side effect of
      this is that we don't end up on the hairy edge of VQMMC (2.7V),
      which some EEs claim is a little too close to the minimum for
      comfort.
      This is done in two steps. At first we try to find a VQMMC within
      a 0.3V tolerance of VMMC and if this is not supported by the
      supplying regulator we try to find a suitable voltage within the
      whole 2.7V-3.6V area of the spec.
    
    * The two step approach is currently necessary, as the used
      regulator_set_voltage_triplet(min, target, max) uses a simple
      implementation that just tries two basic steps:
            regulator_set_voltage(target, max);
            regulator_set_voltage(min, target);
      So with only one step with 2.7-3.6V borders, if a suitable voltage
      is a bit below VMMC, we would directly get the lowest 2.7V
      which some boards (like Rockchips) don't like at all.
    
    * When setting the signal voltage to 1.8V or 1.2V we aim for that
      specific voltage instead of picking the lowest one in the range.
    
    * We very purposely don't print errors in mmc_regulator_set_vqmmc().
      There are cases where the MMC core will try several different
      voltages and we don't want to pollute the logs.
    
    Signed-off-by: Douglas Anderson <dianders@chromium.org>
    Signed-off-by: Heiko Stuebner <heiko@sntech.de>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 7aa3b305b65d..5ae89e48fd85 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1394,6 +1394,84 @@ int mmc_regulator_set_ocr(struct mmc_host *mmc,
 }
 EXPORT_SYMBOL_GPL(mmc_regulator_set_ocr);
 
+static int mmc_regulator_set_voltage_if_supported(struct regulator *regulator,
+						  int min_uV, int target_uV,
+						  int max_uV)
+{
+	/*
+	 * Check if supported first to avoid errors since we may try several
+	 * signal levels during power up and don't want to show errors.
+	 */
+	if (!regulator_is_supported_voltage(regulator, min_uV, max_uV))
+		return -EINVAL;
+
+	return regulator_set_voltage_triplet(regulator, min_uV, target_uV,
+					     max_uV);
+}
+
+/**
+ * mmc_regulator_set_vqmmc - Set VQMMC as per the ios
+ *
+ * For 3.3V signaling, we try to match VQMMC to VMMC as closely as possible.
+ * That will match the behavior of old boards where VQMMC and VMMC were supplied
+ * by the same supply.  The Bus Operating conditions for 3.3V signaling in the
+ * SD card spec also define VQMMC in terms of VMMC.
+ * If this is not possible we'll try the full 2.7-3.6V of the spec.
+ *
+ * For 1.2V and 1.8V signaling we'll try to get as close as possible to the
+ * requested voltage.  This is definitely a good idea for UHS where there's a
+ * separate regulator on the card that's trying to make 1.8V and it's best if
+ * we match.
+ *
+ * This function is expected to be used by a controller's
+ * start_signal_voltage_switch() function.
+ */
+int mmc_regulator_set_vqmmc(struct mmc_host *mmc, struct mmc_ios *ios)
+{
+	struct device *dev = mmc_dev(mmc);
+	int ret, volt, min_uV, max_uV;
+
+	/* If no vqmmc supply then we can't change the voltage */
+	if (IS_ERR(mmc->supply.vqmmc))
+		return -EINVAL;
+
+	switch (ios->signal_voltage) {
+	case MMC_SIGNAL_VOLTAGE_120:
+		return mmc_regulator_set_voltage_if_supported(mmc->supply.vqmmc,
+						1100000, 1200000, 1300000);
+	case MMC_SIGNAL_VOLTAGE_180:
+		return mmc_regulator_set_voltage_if_supported(mmc->supply.vqmmc,
+						1700000, 1800000, 1950000);
+	case MMC_SIGNAL_VOLTAGE_330:
+		ret = mmc_ocrbitnum_to_vdd(mmc->ios.vdd, &volt, &max_uV);
+		if (ret < 0)
+			return ret;
+
+		dev_dbg(dev, "%s: found vmmc voltage range of %d-%duV\n",
+			__func__, volt, max_uV);
+
+		min_uV = max(volt - 300000, 2700000);
+		max_uV = min(max_uV + 200000, 3600000);
+
+		/*
+		 * Due to a limitation in the current implementation of
+		 * regulator_set_voltage_triplet() which is taking the lowest
+		 * voltage possible if below the target, search for a suitable
+		 * voltage in two steps and try to stay close to vmmc
+		 * with a 0.3V tolerance at first.
+		 */
+		if (!mmc_regulator_set_voltage_if_supported(mmc->supply.vqmmc,
+						min_uV, volt, max_uV))
+			return 0;
+
+		return mmc_regulator_set_voltage_if_supported(mmc->supply.vqmmc,
+						2700000, volt, 3600000);
+	default:
+		return -EINVAL;
+	}
+}
+EXPORT_SYMBOL_GPL(mmc_regulator_set_vqmmc);
+
 #endif /* CONFIG_REGULATOR */
 
 int mmc_regulator_get_supply(struct mmc_host *mmc)

commit 310c805e7f133443cd57f880b73557a4a8f54b30
Author: Heiko Stuebner <heiko@sntech.de>
Date:   Mon Oct 12 18:00:54 2015 +0200

    mmc: core: move ocr-bit to voltage translation into separate function
    
    We will shortly need the calculation of an ocr-bit to the actual
    voltage in a second place too, so move it from mmc_regulator_set_ocr
    to a common function mmc_ocrbitnum_to_vdd to make that possible.
    
    Signed-off-by: Heiko Stuebner <heiko@sntech.de>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 1a36b021b44e..7aa3b305b65d 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1276,6 +1276,40 @@ struct device_node *mmc_of_find_child_device(struct mmc_host *host,
 
 #ifdef CONFIG_REGULATOR
 
+/**
+ * mmc_ocrbitnum_to_vdd - Convert a OCR bit number to its voltage
+ * @vdd_bit:	OCR bit number
+ * @min_uV:	minimum voltage value (mV)
+ * @max_uV:	maximum voltage value (mV)
+ *
+ * This function returns the voltage range according to the provided OCR
+ * bit number. If conversion is not possible a negative errno value returned.
+ */
+static int mmc_ocrbitnum_to_vdd(int vdd_bit, int *min_uV, int *max_uV)
+{
+	int		tmp;
+
+	if (!vdd_bit)
+		return -EINVAL;
+
+	/*
+	 * REVISIT mmc_vddrange_to_ocrmask() may have set some
+	 * bits this regulator doesn't quite support ... don't
+	 * be too picky, most cards and regulators are OK with
+	 * a 0.1V range goof (it's a small error percentage).
+	 */
+	tmp = vdd_bit - ilog2(MMC_VDD_165_195);
+	if (tmp == 0) {
+		*min_uV = 1650 * 1000;
+		*max_uV = 1950 * 1000;
+	} else {
+		*min_uV = 1900 * 1000 + tmp * 100 * 1000;
+		*max_uV = *min_uV + 100 * 1000;
+	}
+
+	return 0;
+}
+
 /**
  * mmc_regulator_get_ocrmask - return mask of supported voltages
  * @supply: regulator to use
@@ -1339,22 +1373,7 @@ int mmc_regulator_set_ocr(struct mmc_host *mmc,
 	int			min_uV, max_uV;
 
 	if (vdd_bit) {
-		int		tmp;
-
-		/*
-		 * REVISIT mmc_vddrange_to_ocrmask() may have set some
-		 * bits this regulator doesn't quite support ... don't
-		 * be too picky, most cards and regulators are OK with
-		 * a 0.1V range goof (it's a small error percentage).
-		 */
-		tmp = vdd_bit - ilog2(MMC_VDD_165_195);
-		if (tmp == 0) {
-			min_uV = 1650 * 1000;
-			max_uV = 1950 * 1000;
-		} else {
-			min_uV = 1900 * 1000 + tmp * 100 * 1000;
-			max_uV = min_uV + 100 * 1000;
-		}
+		mmc_ocrbitnum_to_vdd(vdd_bit, &min_uV, &max_uV);
 
 		result = regulator_set_voltage(supply, min_uV, max_uV);
 		if (result == 0 && !mmc->regulator_enabled) {

commit 9eadcc0581a8ccaf4c2378aa1c193fb164304f1d
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri Oct 2 10:56:11 2015 +0200

    mmc: core: Remove MMC_CLKGATE
    
    MMC_CLKGATE was once invented to save power by gating the bus clock at
    request inactivity. At that time it served its purpose. The modern way to
    deal with power saving for these scenarios, is by using runtime PM.
    
    Nowadays, several host drivers have deployed runtime PM, but for those
    that haven't and which still cares power saving at request inactivity,
    it's certainly time to deploy runtime PM as it has been around for several
    years now.
    
    To simplify code to mmc core and thus decrease maintenance efforts, this
    patch removes all code related to MMC_CLKGATE.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 21cda23b247c..1a36b021b44e 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -187,8 +187,6 @@ void mmc_request_done(struct mmc_host *host, struct mmc_request *mrq)
 
 		if (mrq->done)
 			mrq->done(mrq);
-
-		mmc_host_clk_release(host);
 	}
 }
 
@@ -292,7 +290,6 @@ static int mmc_start_request(struct mmc_host *host, struct mmc_request *mrq)
 			mrq->stop->mrq = mrq;
 		}
 	}
-	mmc_host_clk_hold(host);
 	led_trigger_event(host->led, LED_FULL);
 	__mmc_start_request(host, mrq);
 
@@ -542,11 +539,8 @@ static void mmc_wait_for_req_done(struct mmc_host *host,
 static void mmc_pre_req(struct mmc_host *host, struct mmc_request *mrq,
 		 bool is_first_req)
 {
-	if (host->ops->pre_req) {
-		mmc_host_clk_hold(host);
+	if (host->ops->pre_req)
 		host->ops->pre_req(host, mrq, is_first_req);
-		mmc_host_clk_release(host);
-	}
 }
 
 /**
@@ -561,11 +555,8 @@ static void mmc_pre_req(struct mmc_host *host, struct mmc_request *mrq,
 static void mmc_post_req(struct mmc_host *host, struct mmc_request *mrq,
 			 int err)
 {
-	if (host->ops->post_req) {
-		mmc_host_clk_hold(host);
+	if (host->ops->post_req)
 		host->ops->post_req(host, mrq, err);
-		mmc_host_clk_release(host);
-	}
 }
 
 /**
@@ -850,9 +841,9 @@ void mmc_set_data_timeout(struct mmc_data *data, const struct mmc_card *card)
 		unsigned int timeout_us, limit_us;
 
 		timeout_us = data->timeout_ns / 1000;
-		if (mmc_host_clk_rate(card->host))
+		if (card->host->ios.clock)
 			timeout_us += data->timeout_clks * 1000 /
-				(mmc_host_clk_rate(card->host) / 1000);
+				(card->host->ios.clock / 1000);
 
 		if (data->flags & MMC_DATA_WRITE)
 			/*
@@ -1050,8 +1041,6 @@ static inline void mmc_set_ios(struct mmc_host *host)
 		 ios->power_mode, ios->chip_select, ios->vdd,
 		 ios->bus_width, ios->timing);
 
-	if (ios->clock > 0)
-		mmc_set_ungated(host);
 	host->ops->set_ios(host, ios);
 }
 
@@ -1060,17 +1049,15 @@ static inline void mmc_set_ios(struct mmc_host *host)
  */
 void mmc_set_chip_select(struct mmc_host *host, int mode)
 {
-	mmc_host_clk_hold(host);
 	host->ios.chip_select = mode;
 	mmc_set_ios(host);
-	mmc_host_clk_release(host);
 }
 
 /*
  * Sets the host clock to the highest possible frequency that
  * is below "hz".
  */
-static void __mmc_set_clock(struct mmc_host *host, unsigned int hz)
+void mmc_set_clock(struct mmc_host *host, unsigned int hz)
 {
 	WARN_ON(hz && hz < host->f_min);
 
@@ -1081,68 +1068,6 @@ static void __mmc_set_clock(struct mmc_host *host, unsigned int hz)
 	mmc_set_ios(host);
 }
 
-void mmc_set_clock(struct mmc_host *host, unsigned int hz)
-{
-	mmc_host_clk_hold(host);
-	__mmc_set_clock(host, hz);
-	mmc_host_clk_release(host);
-}
-
-#ifdef CONFIG_MMC_CLKGATE
-/*
- * This gates the clock by setting it to 0 Hz.
- */
-void mmc_gate_clock(struct mmc_host *host)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&host->clk_lock, flags);
-	host->clk_old = host->ios.clock;
-	host->ios.clock = 0;
-	host->clk_gated = true;
-	spin_unlock_irqrestore(&host->clk_lock, flags);
-	mmc_set_ios(host);
-}
-
-/*
- * This restores the clock from gating by using the cached
- * clock value.
- */
-void mmc_ungate_clock(struct mmc_host *host)
-{
-	/*
-	 * We should previously have gated the clock, so the clock shall
-	 * be 0 here! The clock may however be 0 during initialization,
-	 * when some request operations are performed before setting
-	 * the frequency. When ungate is requested in that situation
-	 * we just ignore the call.
-	 */
-	if (host->clk_old) {
-		BUG_ON(host->ios.clock);
-		/* This call will also set host->clk_gated to false */
-		__mmc_set_clock(host, host->clk_old);
-	}
-}
-
-void mmc_set_ungated(struct mmc_host *host)
-{
-	unsigned long flags;
-
-	/*
-	 * We've been given a new frequency while the clock is gated,
-	 * so make sure we regard this as ungating it.
-	 */
-	spin_lock_irqsave(&host->clk_lock, flags);
-	host->clk_gated = false;
-	spin_unlock_irqrestore(&host->clk_lock, flags);
-}
-
-#else
-void mmc_set_ungated(struct mmc_host *host)
-{
-}
-#endif
-
 int mmc_execute_tuning(struct mmc_card *card)
 {
 	struct mmc_host *host = card->host;
@@ -1157,9 +1082,7 @@ int mmc_execute_tuning(struct mmc_card *card)
 	else
 		opcode = MMC_SEND_TUNING_BLOCK;
 
-	mmc_host_clk_hold(host);
 	err = host->ops->execute_tuning(host, opcode);
-	mmc_host_clk_release(host);
 
 	if (err)
 		pr_err("%s: tuning execution failed\n", mmc_hostname(host));
@@ -1174,10 +1097,8 @@ int mmc_execute_tuning(struct mmc_card *card)
  */
 void mmc_set_bus_mode(struct mmc_host *host, unsigned int mode)
 {
-	mmc_host_clk_hold(host);
 	host->ios.bus_mode = mode;
 	mmc_set_ios(host);
-	mmc_host_clk_release(host);
 }
 
 /*
@@ -1185,10 +1106,8 @@ void mmc_set_bus_mode(struct mmc_host *host, unsigned int mode)
  */
 void mmc_set_bus_width(struct mmc_host *host, unsigned int width)
 {
-	mmc_host_clk_hold(host);
 	host->ios.bus_width = width;
 	mmc_set_ios(host);
-	mmc_host_clk_release(host);
 }
 
 /*
@@ -1532,11 +1451,8 @@ int __mmc_set_signal_voltage(struct mmc_host *host, int signal_voltage)
 	int old_signal_voltage = host->ios.signal_voltage;
 
 	host->ios.signal_voltage = signal_voltage;
-	if (host->ops->start_signal_voltage_switch) {
-		mmc_host_clk_hold(host);
+	if (host->ops->start_signal_voltage_switch)
 		err = host->ops->start_signal_voltage_switch(host, &host->ios);
-		mmc_host_clk_release(host);
-	}
 
 	if (err)
 		host->ios.signal_voltage = old_signal_voltage;
@@ -1570,20 +1486,17 @@ int mmc_set_signal_voltage(struct mmc_host *host, int signal_voltage, u32 ocr)
 		pr_warn("%s: cannot verify signal voltage switch\n",
 			mmc_hostname(host));
 
-	mmc_host_clk_hold(host);
-
 	cmd.opcode = SD_SWITCH_VOLTAGE;
 	cmd.arg = 0;
 	cmd.flags = MMC_RSP_R1 | MMC_CMD_AC;
 
 	err = mmc_wait_for_cmd(host, &cmd, 0);
 	if (err)
-		goto err_command;
+		return err;
+
+	if (!mmc_host_is_spi(host) && (cmd.resp[0] & R1_ERROR))
+		return -EIO;
 
-	if (!mmc_host_is_spi(host) && (cmd.resp[0] & R1_ERROR)) {
-		err = -EIO;
-		goto err_command;
-	}
 	/*
 	 * The card should drive cmd and dat[0:3] low immediately
 	 * after the response of cmd11, but wait 1 ms to be sure
@@ -1632,9 +1545,6 @@ int mmc_set_signal_voltage(struct mmc_host *host, int signal_voltage, u32 ocr)
 		mmc_power_cycle(host, ocr);
 	}
 
-err_command:
-	mmc_host_clk_release(host);
-
 	return err;
 }
 
@@ -1643,10 +1553,8 @@ int mmc_set_signal_voltage(struct mmc_host *host, int signal_voltage, u32 ocr)
  */
 void mmc_set_timing(struct mmc_host *host, unsigned int timing)
 {
-	mmc_host_clk_hold(host);
 	host->ios.timing = timing;
 	mmc_set_ios(host);
-	mmc_host_clk_release(host);
 }
 
 /*
@@ -1654,10 +1562,8 @@ void mmc_set_timing(struct mmc_host *host, unsigned int timing)
  */
 void mmc_set_driver_type(struct mmc_host *host, unsigned int drv_type)
 {
-	mmc_host_clk_hold(host);
 	host->ios.drv_type = drv_type;
 	mmc_set_ios(host);
-	mmc_host_clk_release(host);
 }
 
 int mmc_select_drive_strength(struct mmc_card *card, unsigned int max_dtr,
@@ -1665,7 +1571,6 @@ int mmc_select_drive_strength(struct mmc_card *card, unsigned int max_dtr,
 {
 	struct mmc_host *host = card->host;
 	int host_drv_type = SD_DRIVER_TYPE_B;
-	int drive_strength;
 
 	*drv_type = 0;
 
@@ -1688,14 +1593,10 @@ int mmc_select_drive_strength(struct mmc_card *card, unsigned int max_dtr,
 	 * information and let the hardware specific code
 	 * return what is possible given the options
 	 */
-	mmc_host_clk_hold(host);
-	drive_strength = host->ops->select_drive_strength(card, max_dtr,
-							  host_drv_type,
-							  card_drv_type,
-							  drv_type);
-	mmc_host_clk_release(host);
-
-	return drive_strength;
+	return host->ops->select_drive_strength(card, max_dtr,
+						host_drv_type,
+						card_drv_type,
+						drv_type);
 }
 
 /*
@@ -1714,8 +1615,6 @@ void mmc_power_up(struct mmc_host *host, u32 ocr)
 	if (host->ios.power_mode == MMC_POWER_ON)
 		return;
 
-	mmc_host_clk_hold(host);
-
 	mmc_pwrseq_pre_power_on(host);
 
 	host->ios.vdd = fls(ocr) - 1;
@@ -1749,8 +1648,6 @@ void mmc_power_up(struct mmc_host *host, u32 ocr)
 	 * time required to reach a stable voltage.
 	 */
 	mmc_delay(10);
-
-	mmc_host_clk_release(host);
 }
 
 void mmc_power_off(struct mmc_host *host)
@@ -1758,8 +1655,6 @@ void mmc_power_off(struct mmc_host *host)
 	if (host->ios.power_mode == MMC_POWER_OFF)
 		return;
 
-	mmc_host_clk_hold(host);
-
 	mmc_pwrseq_power_off(host);
 
 	host->ios.clock = 0;
@@ -1775,8 +1670,6 @@ void mmc_power_off(struct mmc_host *host)
 	 * can be successfully turned on again.
 	 */
 	mmc_delay(1);
-
-	mmc_host_clk_release(host);
 }
 
 void mmc_power_cycle(struct mmc_host *host, u32 ocr)
@@ -1992,7 +1885,7 @@ static unsigned int mmc_mmc_erase_timeout(struct mmc_card *card,
 		 */
 		timeout_clks <<= 1;
 		timeout_us += (timeout_clks * 1000) /
-			      (mmc_host_clk_rate(card->host) / 1000);
+			      (card->host->ios.clock / 1000);
 
 		erase_timeout = timeout_us / 1000;
 
@@ -2440,9 +2333,7 @@ static void mmc_hw_reset_for_init(struct mmc_host *host)
 {
 	if (!(host->caps & MMC_CAP_HW_RESET) || !host->ops->hw_reset)
 		return;
-	mmc_host_clk_hold(host);
 	host->ops->hw_reset(host);
-	mmc_host_clk_release(host);
 }
 
 int mmc_hw_reset(struct mmc_host *host)

commit 5d3f6ef04d65dda92a3573841a7215fb05c347de
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Tue Sep 22 17:30:25 2015 +0200

    mmc: Wait for card_busy before starting sdio requests
    
    Some sdio wifi chips will not work properly if we try to start new
    sdio-rw requests while the device is signalling that it is busy.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 2092a89dcf76..21cda23b247c 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -206,6 +206,23 @@ static void __mmc_start_request(struct mmc_host *host, struct mmc_request *mrq)
 		return;
 	}
 
+	/*
+	 * For sdio rw commands we must wait for card busy otherwise some
+	 * sdio devices won't work properly.
+	 */
+	if (mmc_is_io_op(mrq->cmd->opcode) && host->ops->card_busy) {
+		int tries = 500; /* Wait aprox 500ms at maximum */
+
+		while (host->ops->card_busy(host) && --tries)
+			mmc_delay(1);
+
+		if (tries == 0) {
+			mrq->cmd->error = -EBUSY;
+			mmc_request_done(host, mrq);
+			return;
+		}
+	}
+
 	host->ops->request(host, mrq);
 }
 

commit 8d1ffc8c982e4480059ef735e8f15f631e40e80c
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri Sep 11 14:41:55 2015 +0200

    mmc: core: Keep host claimed while invoking mmc_power_off|up()
    
    As mmc_claim_host() invokes pm_runtime_get_sync() for the mmc host device,
    it's important that the host is kept claimed for *all* accesses to it via
    the host_ops callbacks.
    
    In some code paths for SDIO, particularly related to the PM support,
    mmc_power_off|up() is invoked without keeping the host claimed. Let's fix
    these.
    
    Moreover, mmc_start|stop_host() also invokes mmc_power_off|up() without
    claiming the host, let's fix these as well.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Kishon Vijay Abraham I <kishon@ti.com>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index a3eb20bdcd97..2092a89dcf76 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2633,10 +2633,14 @@ void mmc_start_host(struct mmc_host *host)
 	host->f_init = max(freqs[0], host->f_min);
 	host->rescan_disable = 0;
 	host->ios.power_mode = MMC_POWER_UNDEFINED;
+
+	mmc_claim_host(host);
 	if (host->caps2 & MMC_CAP2_NO_PRESCAN_POWERUP)
 		mmc_power_off(host);
 	else
 		mmc_power_up(host, host->ocr_avail);
+	mmc_release_host(host);
+
 	mmc_gpiod_request_cd_irq(host);
 	_mmc_detect_change(host, 0, false);
 }
@@ -2674,7 +2678,9 @@ void mmc_stop_host(struct mmc_host *host)
 
 	BUG_ON(host->card);
 
+	mmc_claim_host(host);
 	mmc_power_off(host);
+	mmc_release_host(host);
 }
 
 int mmc_power_save_host(struct mmc_host *host)

commit 031277d4d33d33f0174fbb569ca8f68238175617
Author: Chaotian Jing <chaotian.jing@mediatek.com>
Date:   Wed Sep 30 17:37:18 2015 +0800

    mmc: core: fix dead loop of mmc_retune
    
    When get a CRC error, start the mmc_retune, it will issue CMD19/CMD21
    to do tune, assume there were 10 clock phase need to try, phase 0 to
    phase 6 is ok, phase 7 to phase 9 is NG, we try it from 0 to 9, so
    the last CMD19/CMD21 will get CRC error, host->need_retune was set and
    cause mmc_retune was called, then dead loop of mmc_retune
    
    Signed-off-by: Chaotian Jing <chaotian.jing@mediatek.com>
    Acked-by: Adrian Hunter <adrian.hunter@intel.com>
    Fixes: bd11e8bd03ca ("mmc: core: Flag re-tuning is needed on CRC errors")
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 0520064dc33b..a3eb20bdcd97 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -134,9 +134,11 @@ void mmc_request_done(struct mmc_host *host, struct mmc_request *mrq)
 	int err = cmd->error;
 
 	/* Flag re-tuning needed on CRC errors */
-	if (err == -EILSEQ || (mrq->sbc && mrq->sbc->error == -EILSEQ) ||
+	if ((cmd->opcode != MMC_SEND_TUNING_BLOCK &&
+	    cmd->opcode != MMC_SEND_TUNING_BLOCK_HS200) &&
+	    (err == -EILSEQ || (mrq->sbc && mrq->sbc->error == -EILSEQ) ||
 	    (mrq->data && mrq->data->error == -EILSEQ) ||
-	    (mrq->stop && mrq->stop->error == -EILSEQ))
+	    (mrq->stop && mrq->stop->error == -EILSEQ)))
 		mmc_retune_needed(host);
 
 	if (err && cmd->retries && mmc_host_is_spi(host)) {

commit 71f8a4b81d040b3d094424197ca2f1bf811b1245
Author: Jialing Fu <jlfu@marvell.com>
Date:   Fri Aug 28 11:13:09 2015 +0800

    mmc: core: fix race condition in mmc_wait_data_done
    
    The following panic is captured in ker3.14, but the issue still exists
    in latest kernel.
    ---------------------------------------------------------------------
    [   20.738217] c0 3136 (Compiler) Unable to handle kernel NULL pointer dereference
    at virtual address 00000578
    ......
    [   20.738499] c0 3136 (Compiler) PC is at _raw_spin_lock_irqsave+0x24/0x60
    [   20.738527] c0 3136 (Compiler) LR is at _raw_spin_lock_irqsave+0x20/0x60
    [   20.740134] c0 3136 (Compiler) Call trace:
    [   20.740165] c0 3136 (Compiler) [<ffffffc0008ee900>] _raw_spin_lock_irqsave+0x24/0x60
    [   20.740200] c0 3136 (Compiler) [<ffffffc0000dd024>] __wake_up+0x1c/0x54
    [   20.740230] c0 3136 (Compiler) [<ffffffc000639414>] mmc_wait_data_done+0x28/0x34
    [   20.740262] c0 3136 (Compiler) [<ffffffc0006391a0>] mmc_request_done+0xa4/0x220
    [   20.740314] c0 3136 (Compiler) [<ffffffc000656894>] sdhci_tasklet_finish+0xac/0x264
    [   20.740352] c0 3136 (Compiler) [<ffffffc0000a2b58>] tasklet_action+0xa0/0x158
    [   20.740382] c0 3136 (Compiler) [<ffffffc0000a2078>] __do_softirq+0x10c/0x2e4
    [   20.740411] c0 3136 (Compiler) [<ffffffc0000a24bc>] irq_exit+0x8c/0xc0
    [   20.740439] c0 3136 (Compiler) [<ffffffc00008489c>] handle_IRQ+0x48/0xac
    [   20.740469] c0 3136 (Compiler) [<ffffffc000081428>] gic_handle_irq+0x38/0x7c
    ----------------------------------------------------------------------
    Because in SMP, "mrq" has race condition between below two paths:
    path1: CPU0: <tasklet context>
      static void mmc_wait_data_done(struct mmc_request *mrq)
      {
         mrq->host->context_info.is_done_rcv = true;
         //
         // If CPU0 has just finished "is_done_rcv = true" in path1, and at
         // this moment, IRQ or ICache line missing happens in CPU0.
         // What happens in CPU1 (path2)?
         //
         // If the mmcqd thread in CPU1(path2) hasn't entered to sleep mode:
         // path2 would have chance to break from wait_event_interruptible
         // in mmc_wait_for_data_req_done and continue to run for next
         // mmc_request (mmc_blk_rw_rq_prep).
         //
         // Within mmc_blk_rq_prep, mrq is cleared to 0.
         // If below line still gets host from "mrq" as the result of
         // compiler, the panic happens as we traced.
         wake_up_interruptible(&mrq->host->context_info.wait);
      }
    
    path2: CPU1: <The mmcqd thread runs mmc_queue_thread>
      static int mmc_wait_for_data_req_done(...
      {
         ...
         while (1) {
               wait_event_interruptible(context_info->wait,
                       (context_info->is_done_rcv ||
                        context_info->is_new_req));
               static void mmc_blk_rw_rq_prep(...
               {
               ...
               memset(brq, 0, sizeof(struct mmc_blk_request));
    
    This issue happens very coincidentally; however adding mdelay(1) in
    mmc_wait_data_done as below could duplicate it easily.
    
       static void mmc_wait_data_done(struct mmc_request *mrq)
       {
         mrq->host->context_info.is_done_rcv = true;
    +    mdelay(1);
         wake_up_interruptible(&mrq->host->context_info.wait);
        }
    
    At runtime, IRQ or ICache line missing may just happen at the same place
    of the mdelay(1).
    
    This patch gets the mmc_context_info at the beginning of function, it can
    avoid this race condition.
    
    Signed-off-by: Jialing Fu <jlfu@marvell.com>
    Tested-by: Shawn Lin <shawn.lin@rock-chips.com>
    Fixes: 2220eedfd7ae ("mmc: fix async request mechanism ....")
    Signed-off-by: Shawn Lin <shawn.lin@rock-chips.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 664b61729fa9..0520064dc33b 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -358,8 +358,10 @@ EXPORT_SYMBOL(mmc_start_bkops);
  */
 static void mmc_wait_data_done(struct mmc_request *mrq)
 {
-	mrq->host->context_info.is_done_rcv = true;
-	wake_up_interruptible(&mrq->host->context_info.wait);
+	struct mmc_context_info *context_info = &mrq->host->context_info;
+
+	context_info->is_done_rcv = true;
+	wake_up_interruptible(&context_info->wait);
 }
 
 static void mmc_wait_done(struct mmc_request *mrq)

commit b5b4ff0a633910b2b9dca7915fd6ab17aa10dc3e
Author: Shawn Lin <shawn.lin@rock-chips.com>
Date:   Wed Aug 12 13:08:32 2015 +0800

    mmc: block: skip trim for some kingston eMMCs
    
    For some mass production of kingston eMMCs which adopt Phison's
    firmware will meet an unrecoverable data conrruption occasionally
    if performing trim due to a firmware bug confirmed by vendor. We
    found it on Intel-C3230RK platform. So we add fixup of broken trim
    for it.
    
    Signed-off-by: Shawn Lin <shawn.lin@rock-chips.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 57edb2a9bb04..664b61729fa9 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2250,7 +2250,8 @@ EXPORT_SYMBOL(mmc_can_erase);
 
 int mmc_can_trim(struct mmc_card *card)
 {
-	if (card->ext_csd.sec_feature_support & EXT_CSD_SEC_GB_CL_EN)
+	if ((card->ext_csd.sec_feature_support & EXT_CSD_SEC_GB_CL_EN) &&
+	    (!(card->quirks & MMC_QUIRK_TRIM_BROKEN)))
 		return 1;
 	return 0;
 }

commit 22d7e85ff8e5826845e9a4fa34b4723e5a97ee9b
Author: Robin van der Gracht <robin@protonic.nl>
Date:   Tue Aug 4 08:58:33 2015 +0200

    mmc: core: Fixed bug in one erase-group budget TRIM
    
    When requesting a trim for several bytes, everything up to the next
    erase-group is erased. This causes data corruption.
    
    Signed-off-by: Robin van der Gracht <robin@protonic.nl>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 083cade3ffc5..57edb2a9bb04 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2227,9 +2227,8 @@ int mmc_erase(struct mmc_card *card, unsigned int from, unsigned int nr,
 	 * and call mmc_do_erase() twice if necessary. This special case is
 	 * identified by the card->eg_boundary flag.
 	 */
-	if ((arg & MMC_TRIM_ARGS) && (card->eg_boundary) &&
-	    (from % card->erase_size)) {
-		rem = card->erase_size - (from % card->erase_size);
+	rem = card->erase_size - (from % card->erase_size);
+	if ((arg & MMC_TRIM_ARGS) && (card->eg_boundary) && (nr > rem)) {
 		err = mmc_do_erase(card, from, from + rem - 1, arg);
 		from += rem;
 		if ((err) || (to <= from))

commit 642c28ab86f7666d2ac62a0dc391b4c3121f1d6e
Author: David Jander <david@protonic.nl>
Date:   Tue Jun 23 11:43:52 2015 +0200

    mmc: core: Optimize case for exactly one erase-group budget
    
    In the (not so unlikely) case that the mmc controller timeout budget is
    enough for exactly one erase-group, the simplification of allowing one
    sector has an enormous performance penalty. We optimize this special case
    by introducing a flag that prohibits erase-group boundary crossing, so
    that we can allow trimming more than one sector at a time.
    
    Signed-off-by: David Jander <david@protonic.nl>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 9ad73f30f744..083cade3ffc5 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2168,6 +2168,7 @@ int mmc_erase(struct mmc_card *card, unsigned int from, unsigned int nr,
 	      unsigned int arg)
 {
 	unsigned int rem, to = from + nr;
+	int err;
 
 	if (!(card->host->caps & MMC_CAP_ERASE) ||
 	    !(card->csd.cmdclass & CCC_ERASE))
@@ -2218,6 +2219,23 @@ int mmc_erase(struct mmc_card *card, unsigned int from, unsigned int nr,
 	/* 'from' and 'to' are inclusive */
 	to -= 1;
 
+	/*
+	 * Special case where only one erase-group fits in the timeout budget:
+	 * If the region crosses an erase-group boundary on this particular
+	 * case, we will be trimming more than one erase-group which, does not
+	 * fit in the timeout budget of the controller, so we need to split it
+	 * and call mmc_do_erase() twice if necessary. This special case is
+	 * identified by the card->eg_boundary flag.
+	 */
+	if ((arg & MMC_TRIM_ARGS) && (card->eg_boundary) &&
+	    (from % card->erase_size)) {
+		rem = card->erase_size - (from % card->erase_size);
+		err = mmc_do_erase(card, from, from + rem - 1, arg);
+		from += rem;
+		if ((err) || (to <= from))
+			return err;
+	}
+
 	return mmc_do_erase(card, from, to, arg);
 }
 EXPORT_SYMBOL(mmc_erase);
@@ -2313,16 +2331,28 @@ static unsigned int mmc_do_calc_max_discard(struct mmc_card *card,
 	if (!qty)
 		return 0;
 
+	/*
+	 * When specifying a sector range to trim, chances are we might cross
+	 * an erase-group boundary even if the amount of sectors is less than
+	 * one erase-group.
+	 * If we can only fit one erase-group in the controller timeout budget,
+	 * we have to care that erase-group boundaries are not crossed by a
+	 * single trim operation. We flag that special case with "eg_boundary".
+	 * In all other cases we can just decrement qty and pretend that we
+	 * always touch (qty + 1) erase-groups as a simple optimization.
+	 */
 	if (qty == 1)
-		return 1;
+		card->eg_boundary = 1;
+	else
+		qty--;
 
 	/* Convert qty to sectors */
 	if (card->erase_shift)
-		max_discard = --qty << card->erase_shift;
+		max_discard = qty << card->erase_shift;
 	else if (mmc_card_sd(card))
-		max_discard = qty;
+		max_discard = qty + 1;
 	else
-		max_discard = --qty * card->erase_size;
+		max_discard = qty * card->erase_size;
 
 	return max_discard;
 }

commit e23350b35deb77ef8e33c35dbb0ed1dab9e8ab86
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Fri Feb 6 14:12:55 2015 +0200

    mmc: core: Factor out common code in drive strength selection
    
    Make a new function out of common code used for drive
    strength selection.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 95009f90ae07..9ad73f30f744 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1639,6 +1639,44 @@ void mmc_set_driver_type(struct mmc_host *host, unsigned int drv_type)
 	mmc_host_clk_release(host);
 }
 
+int mmc_select_drive_strength(struct mmc_card *card, unsigned int max_dtr,
+			      int card_drv_type, int *drv_type)
+{
+	struct mmc_host *host = card->host;
+	int host_drv_type = SD_DRIVER_TYPE_B;
+	int drive_strength;
+
+	*drv_type = 0;
+
+	if (!host->ops->select_drive_strength)
+		return 0;
+
+	/* Use SD definition of driver strength for hosts */
+	if (host->caps & MMC_CAP_DRIVER_TYPE_A)
+		host_drv_type |= SD_DRIVER_TYPE_A;
+
+	if (host->caps & MMC_CAP_DRIVER_TYPE_C)
+		host_drv_type |= SD_DRIVER_TYPE_C;
+
+	if (host->caps & MMC_CAP_DRIVER_TYPE_D)
+		host_drv_type |= SD_DRIVER_TYPE_D;
+
+	/*
+	 * The drive strength that the hardware can support
+	 * depends on the board design.  Pass the appropriate
+	 * information and let the hardware specific code
+	 * return what is possible given the options
+	 */
+	mmc_host_clk_hold(host);
+	drive_strength = host->ops->select_drive_strength(card, max_dtr,
+							  host_drv_type,
+							  card_drv_type,
+							  drv_type);
+	mmc_host_clk_release(host);
+
+	return drive_strength;
+}
+
 /*
  * Apply power to the MMC stack.  This is a two-stage process.
  * First, we enable power to the card without the clock running.

commit 75e8a2288c4fabd6c2f752e8fd3bf7f60be7d3a4
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Fri Feb 6 14:12:51 2015 +0200

    mmc: core: Reset driver type to default
    
    IO state variable drv_type could be set during card
    initialization. Consequently, it must be reset to the
    default value when setting the initial state.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index a262a0bf2f86..95009f90ae07 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1184,6 +1184,7 @@ void mmc_set_initial_state(struct mmc_host *host)
 	host->ios.bus_mode = MMC_BUSMODE_PUSHPULL;
 	host->ios.bus_width = MMC_BUS_WIDTH_1;
 	host->ios.timing = MMC_TIMING_LEGACY;
+	host->ios.drv_type = 0;
 
 	mmc_set_ios(host);
 }

commit 7c5209c315ea0f3102413ed1d6309be94b1e792f
Author: Doug Anderson <dianders@chromium.org>
Date:   Tue May 12 14:46:11 2015 -0700

    mmc: core: Increase delay for voltage to stabilize from 3.3V to 1.8V
    
    Since the regulator used for the SDMMC IO voltage is not expected to
    draw a lot of current, most systems will probably use an inexpensive
    LDO for it.  LDO regulators apparently have the feature that they
    don't actively drive the voltage down--they wait for other components
    in the system to drag the voltage down.  Thus they will transition
    faster under heavy loads and slower under light loads.
    
    During an SDMMC voltage change from 3.3V to 1.8V, we are almost
    certainly under a light load.  To be specific:
    * The regulator is hooked through pulls to CMD0-3 and DAT.  Probably
      the CMD pulls are something like 47K and the DAT is something like
      10K.
    * The card is supposed to be driving DAT0-3 low during voltage change
      which will draw _some_ current, but not a lot.
    * The regulator is also provided to the SDMMC host controller, but the
      SDMMC host controller is in open drain mode during the voltage
      change and so shouldn't be drawing much current.
    
    In order to keep the SDMMC host working properly (or for noise
    reasons), there might also be a capacitor attached to the SDMMC IO
    regulator.  This also will have the effect of slowing down transitions
    of the regulator, especially under light loads.
    
    From experimental evidence, we've seen the voltage change fail if the
    card doesn't detect that the voltage fell to less than about 2.3V when
    we turn on the clock.  On one device (that admittedly had a 47K CMD
    pullup instead of a 10K CMD pullup) we saw that the voltage was just
    about 2.3V after 5ms and thus the voltage change would sometimes fail.
    Doubling the delay gave margin and made the voltage change work 100%
    of the time, despite the slightly weaker CMD pull.
    
    At the moment submitting this as an RFC patch since my problem _could_
    be fixed by increasing the pull strength (or using a smaller
    capacitor).  However being a little bit more lenient to strange
    hardware could also be a good thing.
    
    Signed-off-by: Doug Anderson <dianders@chromium.org>
    Acked-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 8c61ddd7748c..a262a0bf2f86 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1588,8 +1588,8 @@ int mmc_set_signal_voltage(struct mmc_host *host, int signal_voltage, u32 ocr)
 		goto power_cycle;
 	}
 
-	/* Keep clock gated for at least 5 ms */
-	mmc_delay(5);
+	/* Keep clock gated for at least 10 ms, though spec only says 5 ms */
+	mmc_delay(10);
 	host->ios.clock = clock;
 	mmc_set_ios(host);
 

commit 0250fdf257b1e5febba19b7cc536a3c9431e50bf
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Thu May 7 13:10:25 2015 +0300

    mmc: core: Don't print reset warning if reset is not supported
    
    Check the error code for EOPNOTSUPP and do not print
    reset warning in that case.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index c93062bc4f2d..8c61ddd7748c 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2371,7 +2371,8 @@ int mmc_hw_reset(struct mmc_host *host)
 	ret = host->bus_ops->reset(host);
 	mmc_bus_put(host);
 
-	pr_warn("%s: tried to reset card\n", mmc_hostname(host));
+	if (ret != -EOPNOTSUPP)
+		pr_warn("%s: tried to reset card\n", mmc_hostname(host));
 
 	return ret;
 }

commit bd11e8bd03cae9e0499c34f67c55408566f6a089
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Thu May 7 13:10:22 2015 +0300

    mmc: core: Flag re-tuning is needed on CRC errors
    
    CRC errors could possibly be alleviated by
    re-tuning so flag re-tuning needed in those cases.
    Note this has no effect if re-tuning has not been
    enabled.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index adb64087a28a..c93062bc4f2d 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -133,6 +133,12 @@ void mmc_request_done(struct mmc_host *host, struct mmc_request *mrq)
 	struct mmc_command *cmd = mrq->cmd;
 	int err = cmd->error;
 
+	/* Flag re-tuning needed on CRC errors */
+	if (err == -EILSEQ || (mrq->sbc && mrq->sbc->error == -EILSEQ) ||
+	    (mrq->data && mrq->data->error == -EILSEQ) ||
+	    (mrq->stop && mrq->stop->error == -EILSEQ))
+		mmc_retune_needed(host);
+
 	if (err && cmd->retries && mmc_host_is_spi(host)) {
 		if (cmd->resp[0] & R1_SPI_ILLEGAL_COMMAND)
 			cmd->retries = 0;

commit 66073d8671c41fb0bc8c6e36531b4eafb70c990e
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Thu May 7 13:10:17 2015 +0300

    mmc: core: Hold re-tuning while bkops ongoing
    
    Hold re-tuning during bkops to prevent
    it from conflicting with the busy state.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index ff1e38400dc5..adb64087a28a 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -318,12 +318,15 @@ void mmc_start_bkops(struct mmc_card *card, bool from_exception)
 		use_busy_signal = false;
 	}
 
+	mmc_retune_hold(card->host);
+
 	err = __mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
 			EXT_CSD_BKOPS_START, 1, timeout,
 			use_busy_signal, true, false);
 	if (err) {
 		pr_warn("%s: Error %d starting bkops\n",
 			mmc_hostname(card->host), err);
+		mmc_retune_release(card->host);
 		goto out;
 	}
 
@@ -334,6 +337,8 @@ void mmc_start_bkops(struct mmc_card *card, bool from_exception)
 	 */
 	if (!use_busy_signal)
 		mmc_card_set_doing_bkops(card);
+	else
+		mmc_retune_release(card->host);
 out:
 	mmc_release_host(card->host);
 }
@@ -749,6 +754,7 @@ int mmc_stop_bkops(struct mmc_card *card)
 	 */
 	if (!err || (err == -EINVAL)) {
 		mmc_card_clr_doing_bkops(card);
+		mmc_retune_release(card->host);
 		err = 0;
 	}
 

commit 8f11d1064e01e1c8bf33ffef86072c2cb0c05b8c
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Thu May 7 13:10:16 2015 +0300

    mmc: core: Hold re-tuning during erase commands
    
    Hold re-tuning during erase commands to prevent
    it from conflicting with the sequence of commands.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index ec3453fd39aa..ff1e38400dc5 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1995,6 +1995,8 @@ static int mmc_do_erase(struct mmc_card *card, unsigned int from,
 	unsigned long timeout;
 	int err;
 
+	mmc_retune_hold(card->host);
+
 	/*
 	 * qty is used to calculate the erase timeout which depends on how many
 	 * erase groups (or allocation units in SD terminology) are affected.
@@ -2098,6 +2100,7 @@ static int mmc_do_erase(struct mmc_card *card, unsigned int from,
 	} while (!(cmd.resp[0] & R1_READY_FOR_DATA) ||
 		 (R1_CURRENT_STATE(cmd.resp[0]) == R1_STATE_PRG));
 out:
+	mmc_retune_release(card->host);
 	return err;
 }
 

commit 90a81489b0a9d7b56df2dcf68498fd3a03deb354
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Thu May 7 13:10:14 2015 +0300

    mmc: core: Add support for re-tuning before each request
    
    At the start of each request, re-tune if needed and
    then hold off re-tuning again until the request is done.
    
    Note that though there is one function that starts
    requests (mmc_start_request) there are two that wait for
    the request to be done (mmc_wait_for_req_done and
    mmc_wait_for_data_req_done).  Also note that
    mmc_wait_for_data_req_done can return even when the
    request is not done (which allows the block driver
    to prepare a newly arrived request while still
    waiting for the previous request).
    
    This patch ensures re-tuning is held for the duration
    of a request.  Subsequent patches will also hold
    re-tuning at other times when it might cause a
    conflict.
    
    In addition, possibly a command is failing because
    re-tuning is needed. Use mmc_retune_recheck() to check
    re-tuning. At that point re-tuning is held, at least by
    the request, so mmc_retune_recheck() flags host->retune_now
    if the hold count is 1.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 007c44443332..ec3453fd39aa 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -186,12 +186,29 @@ void mmc_request_done(struct mmc_host *host, struct mmc_request *mrq)
 
 EXPORT_SYMBOL(mmc_request_done);
 
+static void __mmc_start_request(struct mmc_host *host, struct mmc_request *mrq)
+{
+	int err;
+
+	/* Assumes host controller has been runtime resumed by mmc_claim_host */
+	err = mmc_retune(host);
+	if (err) {
+		mrq->cmd->error = err;
+		mmc_request_done(host, mrq);
+		return;
+	}
+
+	host->ops->request(host, mrq);
+}
+
 static int mmc_start_request(struct mmc_host *host, struct mmc_request *mrq)
 {
 #ifdef CONFIG_MMC_DEBUG
 	unsigned int i, sz;
 	struct scatterlist *sg;
 #endif
+	mmc_retune_hold(host);
+
 	if (mmc_card_removed(host->card))
 		return -ENOMEDIUM;
 
@@ -252,7 +269,7 @@ static int mmc_start_request(struct mmc_host *host, struct mmc_request *mrq)
 	}
 	mmc_host_clk_hold(host);
 	led_trigger_event(host->led, LED_FULL);
-	host->ops->request(host, mrq);
+	__mmc_start_request(host, mrq);
 
 	return 0;
 }
@@ -417,22 +434,22 @@ static int mmc_wait_for_data_req_done(struct mmc_host *host,
 							    host->areq);
 				break; /* return err */
 			} else {
+				mmc_retune_recheck(host);
 				pr_info("%s: req failed (CMD%u): %d, retrying...\n",
 					mmc_hostname(host),
 					cmd->opcode, cmd->error);
 				cmd->retries--;
 				cmd->error = 0;
-				host->ops->request(host, mrq);
+				__mmc_start_request(host, mrq);
 				continue; /* wait for done/new event again */
 			}
 		} else if (context_info->is_new_req) {
 			context_info->is_new_req = false;
-			if (!next_req) {
-				err = MMC_BLK_NEW_REQUEST;
-				break; /* return err */
-			}
+			if (!next_req)
+				return MMC_BLK_NEW_REQUEST;
 		}
 	}
+	mmc_retune_release(host);
 	return err;
 }
 
@@ -467,12 +484,16 @@ static void mmc_wait_for_req_done(struct mmc_host *host,
 		    mmc_card_removed(host->card))
 			break;
 
+		mmc_retune_recheck(host);
+
 		pr_debug("%s: req failed (CMD%u): %d, retrying...\n",
 			 mmc_hostname(host), cmd->opcode, cmd->error);
 		cmd->retries--;
 		cmd->error = 0;
-		host->ops->request(host, mrq);
+		__mmc_start_request(host, mrq);
 	}
+
+	mmc_retune_release(host);
 }
 
 /**

commit 79d5a65aeea43920bf3ff60791f317570dd6f54f
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Thu May 7 13:10:13 2015 +0300

    mmc: core: Enable / disable re-tuning
    
    Enable re-tuning when tuning is executed and
    disable re-tuning when card is no longer initialized.
    
    In the case of SDIO suspend, the card can keep power.
    In that case, re-tuning need not be disabled, but, if
    a re-tuning timer is being used, ensure it is disabled
    and assume that re-tuning will be needed upon resume
    since it is not known how long the suspend will last.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 92e7671426eb..007c44443332 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1109,6 +1109,8 @@ int mmc_execute_tuning(struct mmc_card *card)
 
 	if (err)
 		pr_err("%s: tuning execution failed\n", mmc_hostname(host));
+	else
+		mmc_retune_enable(host);
 
 	return err;
 }
@@ -1140,6 +1142,8 @@ void mmc_set_bus_width(struct mmc_host *host, unsigned int width)
  */
 void mmc_set_initial_state(struct mmc_host *host)
 {
+	mmc_retune_disable(host);
+
 	if (mmc_host_is_spi(host))
 		host->ios.chip_select = MMC_CS_HIGH;
 	else

commit 184af16b09360d6273fd6160e6ff7f8e2482ef23
Author: Grygorii Strashko <Grygorii.Strashko@linaro.org>
Date:   Thu Apr 23 13:43:43 2015 +0300

    mmc: core: add missing pm event in mmc_pm_notify to fix hib restore
    
    The PM_RESTORE_PREPARE is not handled now in mmc_pm_notify(),
    as result mmc_rescan() could be scheduled and executed at
    late hibernation restore stages when MMC device is suspended
    already - which, in turn, will lead to system crash on TI dra7-evm board:
    
    WARNING: CPU: 0 PID: 3188 at drivers/bus/omap_l3_noc.c:148 l3_interrupt_handler+0x258/0x374()
    44000000.ocp:L3 Custom Error: MASTER MPU TARGET L4_PER1_P3 (Idle): Data Access in User mode during Functional access
    
    Hence, add missed PM_RESTORE_PREPARE PM event in mmc_pm_notify().
    
    Fixes: 4c2ef25fe0b8 (mmc: fix all hangs related to mmc/sd card...)
    Signed-off-by: Grygorii Strashko <Grygorii.Strashko@linaro.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index c296bc098fe2..92e7671426eb 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2651,6 +2651,7 @@ int mmc_pm_notify(struct notifier_block *notify_block,
 	switch (mode) {
 	case PM_HIBERNATION_PREPARE:
 	case PM_SUSPEND_PREPARE:
+	case PM_RESTORE_PREPARE:
 		spin_lock_irqsave(&host->lock, flags);
 		host->rescan_disable = 1;
 		spin_unlock_irqrestore(&host->lock, flags);

commit 9250aea76bfcbf4c2a7868e5566281bf2bb7af27
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri Mar 27 12:15:15 2015 +0100

    mmc: core: Enable runtime PM management of host devices
    
    Currently those host drivers which have deployed runtime PM, deals with
    the runtime PM reference counting entirely by themselves.
    
    Since host drivers don't know when the core will send the next request
    through some of the host_ops callbacks, they need to handle runtime PM
    get/put between each an every request.
    
    In quite many cases this has some negative effects, since it leads to a
    high frequency of scheduled runtime PM suspend operations. That due to
    the runtime PM reference count will normally reach zero in-between
    every request.
    
    We can decrease that frequency, by enabling the core to deal with
    runtime PM reference counting of the host device. Since the core often
    knows that it will send a seqeunce of requests, it makes sense for it
    to keep a runtime PM reference count during these periods.
    
    More exactly, let's increase the runtime PM reference count by invoking
    pm_runtime_get_sync() from __mmc_claim_host(). Restore that action by
    invoking pm_runtime_mark_last_busy() and pm_runtime_put_autosuspend()
    in mmc_release_host(). In this way a runtime PM reference count will be
    kept during the complete cycle of a claim -> release host.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Adrian Hunter <adrian.hunter@intel.com>
    Acked-by: Konstantin Dorfman <kdorfman@codeaurora.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 709ada9f26b5..c296bc098fe2 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -897,6 +897,7 @@ int __mmc_claim_host(struct mmc_host *host, atomic_t *abort)
 	DECLARE_WAITQUEUE(wait, current);
 	unsigned long flags;
 	int stop;
+	bool pm = false;
 
 	might_sleep();
 
@@ -916,13 +917,18 @@ int __mmc_claim_host(struct mmc_host *host, atomic_t *abort)
 		host->claimed = 1;
 		host->claimer = current;
 		host->claim_cnt += 1;
+		if (host->claim_cnt == 1)
+			pm = true;
 	} else
 		wake_up(&host->wq);
 	spin_unlock_irqrestore(&host->lock, flags);
 	remove_wait_queue(&host->wq, &wait);
+
+	if (pm)
+		pm_runtime_get_sync(mmc_dev(host));
+
 	return stop;
 }
-
 EXPORT_SYMBOL(__mmc_claim_host);
 
 /**
@@ -947,6 +953,8 @@ void mmc_release_host(struct mmc_host *host)
 		host->claimer = NULL;
 		spin_unlock_irqrestore(&host->lock, flags);
 		wake_up(&host->wq);
+		pm_runtime_mark_last_busy(mmc_dev(host));
+		pm_runtime_put_autosuspend(mmc_dev(host));
 	}
 }
 EXPORT_SYMBOL(mmc_release_host);

commit 40433267331bc6b9d70d5cdd14bfa2c8e3e5f0ec
Author: NeilBrown <neil@brown.name>
Date:   Thu Mar 26 08:43:37 2015 +1100

    mmc: core: Remove the ->enable|disable() callbacks
    
    These callbacks have been set to deprecated for some time. The last
    user (omap_hsmmc) has moved away from using them, which thus enables
    us to completely remove them.
    
    Signed-off-by: NeilBrown <neil@brown.name>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 23f10f72e5f3..709ada9f26b5 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -920,8 +920,6 @@ int __mmc_claim_host(struct mmc_host *host, atomic_t *abort)
 		wake_up(&host->wq);
 	spin_unlock_irqrestore(&host->lock, flags);
 	remove_wait_queue(&host->wq, &wait);
-	if (host->ops->enable && !stop && host->claim_cnt == 1)
-		host->ops->enable(host);
 	return stop;
 }
 
@@ -940,9 +938,6 @@ void mmc_release_host(struct mmc_host *host)
 
 	WARN_ON(!host->claimed);
 
-	if (host->ops->disable && host->claim_cnt == 1)
-		host->ops->disable(host);
-
 	spin_lock_irqsave(&host->lock, flags);
 	if (--host->claim_cnt) {
 		/* Release for nested claim */

commit 4febb7e20aa619e2b2845519dad247e4038dc383
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Mon Feb 2 16:01:14 2015 +0100

    mmc: core: Invoke mmc_pwrseq_post_power_on() prior MMC_POWER_ON state
    
    Host drivers have different ways to sends their "init stream" to the
    card. Some need to do it as part of a request, some do it from the
    ->set_ios() callback in the MMC_POWER_ON state and some don't send an
    "init stream" at all.
    
    To be able to use the reset GPIOs from the simple MMC power sequence
    provider, the card need to be powered and the "init stream" must not
    have been sent.
    
    To cope with these requirements, invoke mmc_pwrseq_post_power_on()
    prior we change the state to MMC_POWER_ON in mmc_power_up().
    
    Host drivers shall perform power up operations in the MMC_POWER_UP
    state. Unfortunate three hosts (au1xmmc, cb710-mmc and toshsd) don't
    conform to this expectation. Instead those ignore the MMC_POWER_UP
    state and delays their power up operations to the MMC_POWER_ON state.
    
    Those hosts needs to change their behavior to enable proper support for
    the simple MMC power sequence provider.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Javier Martinez Canillas <javier.martinez@collabora.co.uk>
    Tested-by: Javier Martinez Canillas <javier.martinez@collabora.co.uk>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 0dc64e6e00d4..23f10f72e5f3 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1637,6 +1637,8 @@ void mmc_power_up(struct mmc_host *host, u32 ocr)
 	 */
 	mmc_delay(10);
 
+	mmc_pwrseq_post_power_on(host);
+
 	host->ios.clock = host->f_init;
 
 	host->ios.power_mode = MMC_POWER_ON;
@@ -1648,8 +1650,6 @@ void mmc_power_up(struct mmc_host *host, u32 ocr)
 	 */
 	mmc_delay(10);
 
-	mmc_pwrseq_post_power_on(host);
-
 	mmc_host_clk_release(host);
 }
 

commit 0501be6429e4eb02f417ad83eacd84b8c57b0283
Author: Alexey Skidanov <alexey.skidanov@sandisk.com>
Date:   Thu Jan 29 10:49:43 2015 +0200

    mmc: Resolve BKOPS compatability issue
    
    This patch is coming to fix compatibility issue of BKOPS_EN  field of EXT_CSD.
    In eMMC-5.1, BKOPS_EN was changed, and now it has two operational bits:
    Bit 0 - MANUAL_EN
    Bit 1 - AUTO_EN
    In previous eMMC revisions, only Bit 0 was supported.
    
    Signed-off-by: Alexey Skidanov <alexey.skidanov@sandisk.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 1be7055548cb..0dc64e6e00d4 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -275,7 +275,7 @@ void mmc_start_bkops(struct mmc_card *card, bool from_exception)
 
 	BUG_ON(!card);
 
-	if (!card->ext_csd.bkops_en || mmc_card_doing_bkops(card))
+	if (!card->ext_csd.man_bkops_en || mmc_card_doing_bkops(card))
 		return;
 
 	err = mmc_read_bkops_status(card);

commit 3aa8793f751d4cfcaca886e75ab30dfb00cf1d88
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri Nov 28 14:38:36 2014 +0100

    mmc: core: Initial support for MMC power sequences
    
    System on chip designs may specify a specific MMC power sequence. To
    successfully detect an (e)MMC/SD/SDIO card, that power sequence must
    be followed while initializing the card.
    
    To be able to handle these SOC specific power sequences, let's add a
    MMC power sequence interface. It provides the following functions to
    help the mmc core to deal with these power sequences.
    
    mmc_pwrseq_alloc() - Invoked from mmc_of_parse(), to initialize data.
    mmc_pwrseq_pre_power_on()- Invoked in the beginning of mmc_power_up().
    mmc_pwrseq_post_power_on()- Invoked at the end in mmc_power_up().
    mmc_pwrseq_power_off()- Invoked from mmc_power_off().
    mmc_pwrseq_free() - Invoked from mmc_free_host(), to free data.
    
    Each MMC power sequence provider will be responsible to implement a set
    of callbacks. These callbacks mirrors the functions above.
    
    This patch adds the skeleton, following patches will extend the core of
    the MMC power sequence and add support for a specific simple MMC power
    sequence.
    
    Do note, since the mmc_pwrseq_alloc() is invoked from mmc_of_parse(),
    host drivers needs to make use of this API to enable the support for
    MMC power sequences. Moreover the MMC power sequence support depends on
    CONFIG_OF.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Tested-by: Javier Martinez Canillas <javier.martinez@collabora.co.uk>
    Reviewed-by: Javier Martinez Canillas <javier.martinez@collabora.co.uk>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index d5c176e87951..1be7055548cb 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -40,6 +40,7 @@
 #include "bus.h"
 #include "host.h"
 #include "sdio_bus.h"
+#include "pwrseq.h"
 
 #include "mmc_ops.h"
 #include "sd_ops.h"
@@ -1615,6 +1616,8 @@ void mmc_power_up(struct mmc_host *host, u32 ocr)
 
 	mmc_host_clk_hold(host);
 
+	mmc_pwrseq_pre_power_on(host);
+
 	host->ios.vdd = fls(ocr) - 1;
 	host->ios.power_mode = MMC_POWER_UP;
 	/* Set initial state and call mmc_set_ios */
@@ -1645,6 +1648,8 @@ void mmc_power_up(struct mmc_host *host, u32 ocr)
 	 */
 	mmc_delay(10);
 
+	mmc_pwrseq_post_power_on(host);
+
 	mmc_host_clk_release(host);
 }
 
@@ -1655,6 +1660,8 @@ void mmc_power_off(struct mmc_host *host)
 
 	mmc_host_clk_hold(host);
 
+	mmc_pwrseq_power_off(host);
+
 	host->ios.clock = 0;
 	host->ios.vdd = 0;
 

commit f100c1c2b55b08d419b7cd3985cc144b41ce9a1f
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Fri Dec 5 19:41:02 2014 +0200

    mmc: core: Move mmc_card_removed() into mmc_start_request()
    
    Both callers of mmc_start_request() call mmc_card_removed()
    so move that call into mmc_start_request().
    
    This patch is preparation for adding re-tuning support.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index dc9eb013db5f..d5c176e87951 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -185,13 +185,14 @@ void mmc_request_done(struct mmc_host *host, struct mmc_request *mrq)
 
 EXPORT_SYMBOL(mmc_request_done);
 
-static void
-mmc_start_request(struct mmc_host *host, struct mmc_request *mrq)
+static int mmc_start_request(struct mmc_host *host, struct mmc_request *mrq)
 {
 #ifdef CONFIG_MMC_DEBUG
 	unsigned int i, sz;
 	struct scatterlist *sg;
 #endif
+	if (mmc_card_removed(host->card))
+		return -ENOMEDIUM;
 
 	if (mrq->sbc) {
 		pr_debug("<%s: starting CMD%u arg %08x flags %08x>\n",
@@ -251,6 +252,8 @@ mmc_start_request(struct mmc_host *host, struct mmc_request *mrq)
 	mmc_host_clk_hold(host);
 	led_trigger_event(host->led, LED_FULL);
 	host->ops->request(host, mrq);
+
+	return 0;
 }
 
 /**
@@ -345,29 +348,34 @@ static void mmc_wait_done(struct mmc_request *mrq)
  */
 static int __mmc_start_data_req(struct mmc_host *host, struct mmc_request *mrq)
 {
+	int err;
+
 	mrq->done = mmc_wait_data_done;
 	mrq->host = host;
-	if (mmc_card_removed(host->card)) {
-		mrq->cmd->error = -ENOMEDIUM;
+
+	err = mmc_start_request(host, mrq);
+	if (err) {
+		mrq->cmd->error = err;
 		mmc_wait_data_done(mrq);
-		return -ENOMEDIUM;
 	}
-	mmc_start_request(host, mrq);
 
-	return 0;
+	return err;
 }
 
 static int __mmc_start_req(struct mmc_host *host, struct mmc_request *mrq)
 {
+	int err;
+
 	init_completion(&mrq->completion);
 	mrq->done = mmc_wait_done;
-	if (mmc_card_removed(host->card)) {
-		mrq->cmd->error = -ENOMEDIUM;
+
+	err = mmc_start_request(host, mrq);
+	if (err) {
+		mrq->cmd->error = err;
 		complete(&mrq->completion);
-		return -ENOMEDIUM;
 	}
-	mmc_start_request(host, mrq);
-	return 0;
+
+	return err;
 }
 
 /*

commit 63e415c64003fd62a302a1dc19f082e2c6f1b7cc
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Fri Dec 5 19:40:59 2014 +0200

    mmc: core: Simplify by adding mmc_execute_tuning()
    
    For each MMC, SD and SDIO there is code that
    holds the clock, calls ops->execute_tuning, and
    releases the clock. Simplify the code a bit by
    providing a separate function to do that.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 2cdb06e0643e..dc9eb013db5f 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1077,6 +1077,30 @@ void mmc_set_ungated(struct mmc_host *host)
 }
 #endif
 
+int mmc_execute_tuning(struct mmc_card *card)
+{
+	struct mmc_host *host = card->host;
+	u32 opcode;
+	int err;
+
+	if (!host->ops->execute_tuning)
+		return 0;
+
+	if (mmc_card_mmc(card))
+		opcode = MMC_SEND_TUNING_BLOCK_HS200;
+	else
+		opcode = MMC_SEND_TUNING_BLOCK;
+
+	mmc_host_clk_hold(host);
+	err = host->ops->execute_tuning(host, opcode);
+	mmc_host_clk_release(host);
+
+	if (err)
+		pr_err("%s: tuning execution failed\n", mmc_hostname(host));
+
+	return err;
+}
+
 /*
  * Change the bus mode (open drain/push-pull) of a host.
  */

commit f855a3717eaff1179837060c4796f1cd706331e7
Author: Johan Rudholm <johan.rudholm@axis.com>
Date:   Mon Jan 12 15:38:05 2015 +0100

    mmc: core: refactor the hw_reset routines
    
    Move the (e)MMC specific hw_reset code from core.c into mmc.c. Call the
    code from the new bus_ops member "reset". This also allows for adding
    a SD card specific reset procedure.
    
    Signed-off-by: Johan Rudholm <johanru@axis.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 72070f188cc5..2cdb06e0643e 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2273,50 +2273,25 @@ static void mmc_hw_reset_for_init(struct mmc_host *host)
 	mmc_host_clk_release(host);
 }
 
-int mmc_can_reset(struct mmc_card *card)
-{
-	u8 rst_n_function;
-
-	if (!mmc_card_mmc(card))
-		return 0;
-	rst_n_function = card->ext_csd.rst_n_function;
-	if ((rst_n_function & EXT_CSD_RST_N_EN_MASK) != EXT_CSD_RST_N_ENABLED)
-		return 0;
-	return 1;
-}
-EXPORT_SYMBOL(mmc_can_reset);
-
 int mmc_hw_reset(struct mmc_host *host)
 {
-	struct mmc_card *card = host->card;
-	u32 status;
-
-	if (!(host->caps & MMC_CAP_HW_RESET) || !host->ops->hw_reset)
-		return -EOPNOTSUPP;
+	int ret;
 
-	if (!card)
+	if (!host->card)
 		return -EINVAL;
 
-	if (!mmc_can_reset(card))
+	mmc_bus_get(host);
+	if (!host->bus_ops || host->bus_dead || !host->bus_ops->reset) {
+		mmc_bus_put(host);
 		return -EOPNOTSUPP;
-
-	mmc_host_clk_hold(host);
-	mmc_set_clock(host, host->f_init);
-
-	host->ops->hw_reset(host);
-
-	/* If the reset has happened, then a status command will fail */
-	if (!mmc_send_status(card, &status)) {
-		mmc_host_clk_release(host);
-		return -ENOSYS;
 	}
 
-	/* Set initial state and call mmc_set_ios */
-	mmc_set_initial_state(host);
+	ret = host->bus_ops->reset(host);
+	mmc_bus_put(host);
 
-	mmc_host_clk_release(host);
+	pr_warn("%s: tried to reset card\n", mmc_hostname(host));
 
-	return host->bus_ops->power_restore(host);
+	return ret;
 }
 EXPORT_SYMBOL(mmc_hw_reset);
 

commit 83533ab28380f6957af39a7b322e639e42dbdaf1
Author: Johan Rudholm <johan.rudholm@axis.com>
Date:   Mon Jan 12 15:38:04 2015 +0100

    mmc: core: always check status after reset
    
    Always check if the card is alive after a successful reset. This allows
    us to remove mmc_hw_reset_check(), leaving mmc_hw_reset() as the only
    card reset interface.
    
    Signed-off-by: Johan Rudholm <johanru@axis.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index d3bfbdfab052..72070f188cc5 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2286,9 +2286,10 @@ int mmc_can_reset(struct mmc_card *card)
 }
 EXPORT_SYMBOL(mmc_can_reset);
 
-static int mmc_do_hw_reset(struct mmc_host *host, int check)
+int mmc_hw_reset(struct mmc_host *host)
 {
 	struct mmc_card *card = host->card;
+	u32 status;
 
 	if (!(host->caps & MMC_CAP_HW_RESET) || !host->ops->hw_reset)
 		return -EOPNOTSUPP;
@@ -2305,13 +2306,9 @@ static int mmc_do_hw_reset(struct mmc_host *host, int check)
 	host->ops->hw_reset(host);
 
 	/* If the reset has happened, then a status command will fail */
-	if (check) {
-		u32 status;
-
-		if (!mmc_send_status(card, &status)) {
-			mmc_host_clk_release(host);
-			return -ENOSYS;
-		}
+	if (!mmc_send_status(card, &status)) {
+		mmc_host_clk_release(host);
+		return -ENOSYS;
 	}
 
 	/* Set initial state and call mmc_set_ios */
@@ -2321,19 +2318,8 @@ static int mmc_do_hw_reset(struct mmc_host *host, int check)
 
 	return host->bus_ops->power_restore(host);
 }
-
-int mmc_hw_reset(struct mmc_host *host)
-{
-	return mmc_do_hw_reset(host, 0);
-}
 EXPORT_SYMBOL(mmc_hw_reset);
 
-int mmc_hw_reset_check(struct mmc_host *host)
-{
-	return mmc_do_hw_reset(host, 1);
-}
-EXPORT_SYMBOL(mmc_hw_reset_check);
-
 static int mmc_rescan_try_freq(struct mmc_host *host, unsigned freq)
 {
 	host->f_init = freq;

commit 25185f3f31c924eecc6ff4f55f7acceabf24de11
Author: Sascha Hauer <s.hauer@pengutronix.de>
Date:   Mon Jun 30 11:07:25 2014 +0200

    mmc: Add SDIO function devicetree subnode parsing
    
    This adds SDIO devicetree subnode parsing to the mmc core. While
    SDIO devices are runtime probable they sometimes need nonprobable
    additional information on embedded systems, like an additional gpio
    interrupt or a clock. This patch makes it possible to supply this
    information from the devicetree. SDIO drivers will find a pointer
    to the devicenode in their devices of_node pointer.
    
    Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>
    [hdegoede@redhat.com: Misc. cleanups]
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 9584bffa8b22..d3bfbdfab052 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1232,6 +1232,34 @@ EXPORT_SYMBOL(mmc_of_parse_voltage);
 
 #endif /* CONFIG_OF */
 
+static int mmc_of_get_func_num(struct device_node *node)
+{
+	u32 reg;
+	int ret;
+
+	ret = of_property_read_u32(node, "reg", &reg);
+	if (ret < 0)
+		return ret;
+
+	return reg;
+}
+
+struct device_node *mmc_of_find_child_device(struct mmc_host *host,
+		unsigned func_num)
+{
+	struct device_node *node;
+
+	if (!host->parent || !host->parent->of_node)
+		return NULL;
+
+	for_each_child_of_node(host->parent->of_node, node) {
+		if (mmc_of_get_func_num(node) == func_num)
+			return node;
+	}
+
+	return NULL;
+}
+
 #ifdef CONFIG_REGULATOR
 
 /**

commit c6eb588028f8f23dae8e26312cf192f365c85b95
Author: Vincent Yang <vincent.yang.fujitsu@gmail.com>
Date:   Fri Nov 21 08:51:40 2014 +0800

    mmc: core: hold SD Clock before CMD11 during Signal
    
    Voltage Switch Procedure
    
    This patch is to fix an issue found on mb86s7x platforms.
    
    [symptom]
    There are some UHS-1 SD memory cards sometimes cannot be detected correctly,
    e.g., Transcend 600x SDXC 64GB UHS-1 memory card.
    During Signal Voltage Switch Procedure, failure to switch is indicated
    by the card holding DAT[3:0] low.
    
    [analysis]
    According to SD Host Controller Simplified Specification Version 3.00
    chapter 3.6.1, the Signal Voltage Switch Procedure should be:
    (1) Check S18A; (2) Issue CMD11; (3) Check CMD 11 response;
    (4) Stop providing SD clock; (5) Check DAT[3:0] should be 0000b;
    (6) Set 1.8V Signal Enable; (7) Wait 5ms; (8) Check 1.8V Signal Enable;
    (9) Provide SD Clock; (10) Wait 1ms; (11) Check DAT[3:0] should be 1111b;
    (12) error handling
    
    With CONFIG_MMC_CLKGATE=y, sometimes there is one more gating/un-gating
    SD clock between (2) and (3). In this case, some UHS-1 SD cards will hold
    DAT[3:0] 0000b at (11) and thus fails Signal Voltage Switch Procedure.
    
    [solution]
    By mmc_host_clk_hold() before CMD11, the additional gating/un-gating
    SD clock between (2) and (3) can be prevented and thus no failure at (11).
    It has been verified with many UHS-1 SD cards on mb86s7x platforms and
    works correctly.
    
    Signed-off-by: Vincent Yang <Vincent.Yang@tw.fujitsu.com>
    Reviewed-by: Johan Rudholm <jrudholm@gmail.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 5bda29bff8eb..9584bffa8b22 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1447,18 +1447,20 @@ int mmc_set_signal_voltage(struct mmc_host *host, int signal_voltage, u32 ocr)
 		pr_warn("%s: cannot verify signal voltage switch\n",
 			mmc_hostname(host));
 
+	mmc_host_clk_hold(host);
+
 	cmd.opcode = SD_SWITCH_VOLTAGE;
 	cmd.arg = 0;
 	cmd.flags = MMC_RSP_R1 | MMC_CMD_AC;
 
 	err = mmc_wait_for_cmd(host, &cmd, 0);
 	if (err)
-		return err;
-
-	if (!mmc_host_is_spi(host) && (cmd.resp[0] & R1_ERROR))
-		return -EIO;
+		goto err_command;
 
-	mmc_host_clk_hold(host);
+	if (!mmc_host_is_spi(host) && (cmd.resp[0] & R1_ERROR)) {
+		err = -EIO;
+		goto err_command;
+	}
 	/*
 	 * The card should drive cmd and dat[0:3] low immediately
 	 * after the response of cmd11, but wait 1 ms to be sure
@@ -1507,6 +1509,7 @@ int mmc_set_signal_voltage(struct mmc_host *host, int signal_voltage, u32 ocr)
 		mmc_power_cycle(host, ocr);
 	}
 
+err_command:
 	mmc_host_clk_release(host);
 
 	return err;

commit 2d079c43bc5ade7b41610b356bf117e14037a584
Author: Johan Rudholm <johan.rudholm@axis.com>
Date:   Thu Nov 6 14:46:54 2014 +0100

    mmc: core: consistent handling of initial values
    
    mmc_do_hw_reset(), mmc_power_up() and mmc_power_off() all set similar
    initial values for bus_mode, bus_width, chip_select and timing. Let's
    make this handling simpler and more consistent by sticking them
    together in a common function. This will introduce small changes in
    behavior in the following places:
    
    mmc_power_off():
    
      For SPI hosts, explicitly set bus_mode = MMC_BUSMODE_PUSHPULL and
      chip_select = MMC_CS_HIGH, before we left them as they were.
    
      For non-SPI hosts, set bus_mode = MMC_BUSMODE_PUSHPULL instead of
      MMC_BUSMODE_OPENDRAIN as before.
    
      These two changes should not be a problem since the device will be
      powered off anyway.
    
    mmc_do_hw_reset():
    
      Always set bus_mode = MMC_BUSMODE_PUSHPULL, as required by SD/SDIO
      cards. MMC cards require MMC_BUSMODE_OPENDRAIN, but this is taken
      care of by mmc_init_card() and mmc_attach_mmc().
    
    Signed-off-by: Johan Rudholm <johanru@axis.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index a32bea23e70c..5bda29bff8eb 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1099,6 +1099,22 @@ void mmc_set_bus_width(struct mmc_host *host, unsigned int width)
 	mmc_host_clk_release(host);
 }
 
+/*
+ * Set initial state after a power cycle or a hw_reset.
+ */
+void mmc_set_initial_state(struct mmc_host *host)
+{
+	if (mmc_host_is_spi(host))
+		host->ios.chip_select = MMC_CS_HIGH;
+	else
+		host->ios.chip_select = MMC_CS_DONTCARE;
+	host->ios.bus_mode = MMC_BUSMODE_PUSHPULL;
+	host->ios.bus_width = MMC_BUS_WIDTH_1;
+	host->ios.timing = MMC_TIMING_LEGACY;
+
+	mmc_set_ios(host);
+}
+
 /**
  * mmc_vdd_to_ocrbitnum - Convert a voltage to the OCR bit number
  * @vdd:	voltage (mV)
@@ -1537,15 +1553,9 @@ void mmc_power_up(struct mmc_host *host, u32 ocr)
 	mmc_host_clk_hold(host);
 
 	host->ios.vdd = fls(ocr) - 1;
-	if (mmc_host_is_spi(host))
-		host->ios.chip_select = MMC_CS_HIGH;
-	else
-		host->ios.chip_select = MMC_CS_DONTCARE;
-	host->ios.bus_mode = MMC_BUSMODE_PUSHPULL;
 	host->ios.power_mode = MMC_POWER_UP;
-	host->ios.bus_width = MMC_BUS_WIDTH_1;
-	host->ios.timing = MMC_TIMING_LEGACY;
-	mmc_set_ios(host);
+	/* Set initial state and call mmc_set_ios */
+	mmc_set_initial_state(host);
 
 	/* Try to set signal voltage to 3.3V but fall back to 1.8v or 1.2v */
 	if (__mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_330) == 0)
@@ -1585,14 +1595,9 @@ void mmc_power_off(struct mmc_host *host)
 	host->ios.clock = 0;
 	host->ios.vdd = 0;
 
-	if (!mmc_host_is_spi(host)) {
-		host->ios.bus_mode = MMC_BUSMODE_OPENDRAIN;
-		host->ios.chip_select = MMC_CS_DONTCARE;
-	}
 	host->ios.power_mode = MMC_POWER_OFF;
-	host->ios.bus_width = MMC_BUS_WIDTH_1;
-	host->ios.timing = MMC_TIMING_LEGACY;
-	mmc_set_ios(host);
+	/* Set initial state and call mmc_set_ios */
+	mmc_set_initial_state(host);
 
 	/*
 	 * Some configurations, such as the 802.11 SDIO card in the OLPC
@@ -2278,16 +2283,8 @@ static int mmc_do_hw_reset(struct mmc_host *host, int check)
 		}
 	}
 
-	if (mmc_host_is_spi(host)) {
-		host->ios.chip_select = MMC_CS_HIGH;
-		host->ios.bus_mode = MMC_BUSMODE_PUSHPULL;
-	} else {
-		host->ios.chip_select = MMC_CS_DONTCARE;
-		host->ios.bus_mode = MMC_BUSMODE_OPENDRAIN;
-	}
-	host->ios.bus_width = MMC_BUS_WIDTH_1;
-	host->ios.timing = MMC_TIMING_LEGACY;
-	mmc_set_ios(host);
+	/* Set initial state and call mmc_set_ios */
+	mmc_set_initial_state(host);
 
 	mmc_host_clk_release(host);
 

commit ad89fcb290b0b121a3de96d8c5d5f13a23663875
Author: Johan Rudholm <johan.rudholm@axis.com>
Date:   Tue Nov 4 16:07:03 2014 +0100

    mmc: core: use mmc_send_status to check hw_reset
    
    Signed-off-by: Johan Rudholm <johanru@axis.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 943f9051ec6d..a32bea23e70c 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2270,15 +2270,9 @@ static int mmc_do_hw_reset(struct mmc_host *host, int check)
 
 	/* If the reset has happened, then a status command will fail */
 	if (check) {
-		struct mmc_command cmd = {0};
-		int err;
+		u32 status;
 
-		cmd.opcode = MMC_SEND_STATUS;
-		if (!mmc_host_is_spi(card->host))
-			cmd.arg = card->rca << 16;
-		cmd.flags = MMC_RSP_SPI_R2 | MMC_RSP_R1 | MMC_CMD_AC;
-		err = mmc_wait_for_cmd(card->host, &cmd, 0);
-		if (!err) {
+		if (!mmc_send_status(card, &status)) {
 			mmc_host_clk_release(host);
 			return -ENOSYS;
 		}

commit b2cada73a8ff2ee9129557c724f7e53bf55e48f8
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri Oct 17 11:48:23 2014 +0200

    mmc: core: Use mmc_get_ext_csd() instead of mmc_send_ext_csd()
    
    By using mmc_get_ext_csd() in favor of mmc_send_ext_csd, we decrease
    code duplication.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 953f17c5fcde..943f9051ec6d 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -731,27 +731,16 @@ int mmc_read_bkops_status(struct mmc_card *card)
 	int err;
 	u8 *ext_csd;
 
-	/*
-	 * In future work, we should consider storing the entire ext_csd.
-	 */
-	ext_csd = kmalloc(512, GFP_KERNEL);
-	if (!ext_csd) {
-		pr_err("%s: could not allocate buffer to receive the ext_csd.\n",
-		       mmc_hostname(card->host));
-		return -ENOMEM;
-	}
-
 	mmc_claim_host(card->host);
-	err = mmc_send_ext_csd(card, ext_csd);
+	err = mmc_get_ext_csd(card, &ext_csd);
 	mmc_release_host(card->host);
 	if (err)
-		goto out;
+		return err;
 
 	card->ext_csd.raw_bkops_status = ext_csd[EXT_CSD_BKOPS_STATUS];
 	card->ext_csd.raw_exception_status = ext_csd[EXT_CSD_EXP_EVENTS_STATUS];
-out:
 	kfree(ext_csd);
-	return err;
+	return 0;
 }
 EXPORT_SYMBOL(mmc_read_bkops_status);
 

commit 64b12a68a9f74bb32d8efd7af1ad8a2ba02fc884
Author: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
Date:   Wed Oct 8 12:24:24 2014 +0100

    mmc: core: fix prepared requests while doing bkops
    
    While starting the bkops the previously prepared request should be canceled
    and restarted after the bkops. As the prepared resource might already
    setup the dma channels and ready to be started. Now with the arrival of bkops
    request this prepared request can be serviced ONLY after the bkops. So
    holding on to the prepared request in the host driver is confusing at
    this point in time, so it makes sense to cleanup such dangling requests and
    reissue this request once bkops is done.
    Canceling the prepared request would give opportunity to the host drivers
    to perform cleanup on the prepared request.
    
    Without this patch host drivers like mmci gets confused when a blocking
    request like send_ext_csd(CMD8) is issued while there is already a prepared
    request. With the help of this patch, the driver can better manage such
    blocking requests and cleanup the prepared requests which are not started yet.
    
    Without this patch I hit below crash on Qualcomm APQ8064 based IFC6410 board
    with mmci host driver.
    
    mmci-pl18x 12400000.sdcc: error during DMA transfer!
    Unable to handle kernel paging request at virtual address 40000000
    pgd = c0204000
    [40000000] *pgd=00000000
    Internal error: Oops: 805 [#1] SMP ARM
    Modules linked in: ipv6 ath6kl_sdio ath6kl_core
    CPU: 0 PID: 0 Comm: swapper/0 Tainted: G        W      3.17.0-rc7-linaro-multi-v7 #1
    task: c0c9d7e0 ti: c0c92000 task.ti: c0c92000
    PC is at v7_dma_inv_range+0x34/0x4c
    LR is at __dma_page_dev_to_cpu+0x80/0x100
    pc : [<c021efc0>]    lr : [<c021af18>]    psr: 400f0193
    sp : c0c93e20  ip : c0c9a478  fp : c08ea538
    r10: c0c9f548  r9 : 00000002  r8 : e97d9000
    r7 : 00000200  r6 : c0c9d504  r5 : c0db0880  r4 : 00000000
    r3 : 0000003f  r2 : 00000040  r1 : 40000200  r0 : 40000000
    Flags: nZcv  IRQs off  FIQs on  Mode SVC_32  ISA ARM  Segment kernel
    Control: 10c5787d  Table: a9ef406a  DAC: 00000015
    Process swapper/0 (pid: 0, stack limit = 0xc0c92250)
    Stack: (0xc0c93e20 to 0xc0c94000)
    3e20: c021f058 e9a17178 e9a171bc e99dfd6c 00000001 00000001 e995de10 00000002
    3e40: 00000000 c021b574 00000000 c04bc4a4 00000000 e9b49ac0 c0ce6e6c e99dfda4
    3e60: 00000088 e9810780 c0d8291c c072ea58 00000000 c072d3fc 00000000 c072f534
    3e80: 00000000 e9b49ac0 00000100 c0c9a444 00000088 c072f6b4 c072f5d4 e9d40080
    3ea0: e98107dc 00000000 00000000 c0280a60 00000000 7d55bf61 e9810780 e98107dc
    3ec0: 00000000 f0002000 c0d460e8 c0d460e8 c0c92000 c0280b60 e9810780 c0ce7190
    3ee0: 00000000 c028369c c02835f4 00000088 00000088 c0280278 c0c8ec70 c020f080
    3f00: f000200c c0c9a958 c0c93f28 c02088e4 c04bd630 c04bd5bc 200f0013 ffffffff
    3f20: c0c93f5c c0212800 00000001 a987c000 c0c93f3c c04bd574 00000000 0000015b
    3f40: ea7a0e40 00000000 c0d460e8 c0d460e8 c0c92000 c08ea538 29b12000 c0c93f70
    3f60: c04bd630 c04bd5bc 200f0013 ffffffff c04bd574 c071bd24 7d50c9b4 c0719a44
    3f80: 7d50c9b4 0000015b c0c9a498 c0c92028 c0c9a498 c0c9a4fc ea7a0e40 c0c8ee38
    3fa0: c0d460e8 c0276198 00000000 c0d8291a 00000000 c0c9a400 00000000 c0be0bc4
    3fc0: ffffffff ffffffff c0be05f8 00000000 00000000 c0c533d8 c0d82ed4 c0c9a47c
    3fe0: c0c533d4 c0c9e870 8020406a 511f06f0 00000000 80208074 00000000 00000000
    [<c021efc0>] (v7_dma_inv_range) from [<c021af18>] (__dma_page_dev_to_cpu+0x80/0x100)
    [<c021af18>] (__dma_page_dev_to_cpu) from [<c021b574>] (arm_dma_unmap_sg+0x5c/0x84)
    [<c021b574>] (arm_dma_unmap_sg) from [<c072ea58>] (mmci_dma_unmap.isra.16+0x60/0x74)
    [<c072ea58>] (mmci_dma_unmap.isra.16) from [<c072f534>] (mmci_data_irq+0x1fc/0x29c)
    [<c072f534>] (mmci_data_irq) from [<c072f6b4>] (mmci_irq+0xe0/0x114)
    [<c072f6b4>] (mmci_irq) from [<c0280a60>] (handle_irq_event_percpu+0x78/0x134)
    [<c0280a60>] (handle_irq_event_percpu) from [<c0280b60>] (handle_irq_event+0x44/0x64)
    [<c0280b60>] (handle_irq_event) from [<c028369c>] (handle_fasteoi_irq+0xa8/0x1a8)
    [<c028369c>] (handle_fasteoi_irq) from [<c0280278>] (generic_handle_irq+0x2c/0x3c)
    [<c0280278>] (generic_handle_irq) from [<c020f080>] (handle_IRQ+0x40/0x90)
    [<c020f080>] (handle_IRQ) from [<c02088e4>] (gic_handle_irq+0x38/0x68)
    [<c02088e4>] (gic_handle_irq) from [<c0212800>] (__irq_svc+0x40/0x54)
    Exception stack(0xc0c93f28 to 0xc0c93f70)
    3f20:                   00000001 a987c000 c0c93f3c c04bd574 00000000 0000015b
    3f40: ea7a0e40 00000000 c0d460e8 c0d460e8 c0c92000 c08ea538 29b12000 c0c93f70
    3f60: c04bd630 c04bd5bc 200f0013 ffffffff
    [<c0212800>] (__irq_svc) from [<c04bd5bc>] (msm_cpu_pm_enter_sleep+0x48/0x4c)
    [<c04bd5bc>] (msm_cpu_pm_enter_sleep) from [<c071bd24>] (qcom_lpm_enter_spc+0x20/0x2c)
    [<c071bd24>] (qcom_lpm_enter_spc) from [<c0719a44>] (cpuidle_enter_state+0x44/0xf0)
    [<c0719a44>] (cpuidle_enter_state) from [<c0276198>] (cpu_startup_entry+0x1f4/0x238)
    [<c0276198>] (cpu_startup_entry) from [<c0be0bc4>] (start_kernel+0x384/0x390)
    Code: 1e070f3e e1110003 e1c11003 1e071f3e (ee070f36)
    ---[ end trace cf6cb3f6432c9834 ]---
    Kernel panic - not syncing: Fatal exception in interrupt
    
    Reported-by: Nicolas Dechesne <nicolas.dechesne@linaro.org>
    Signed-off-by: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index ee2e776fb8e3..953f17c5fcde 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -550,8 +550,18 @@ struct mmc_async_req *mmc_start_req(struct mmc_host *host,
 		if (host->card && mmc_card_mmc(host->card) &&
 		    ((mmc_resp_type(host->areq->mrq->cmd) == MMC_RSP_R1) ||
 		     (mmc_resp_type(host->areq->mrq->cmd) == MMC_RSP_R1B)) &&
-		    (host->areq->mrq->cmd->resp[0] & R1_EXCEPTION_EVENT))
+		    (host->areq->mrq->cmd->resp[0] & R1_EXCEPTION_EVENT)) {
+
+			/* Cancel the prepared request */
+			if (areq)
+				mmc_post_req(host, areq->mrq, -EINVAL);
+
 			mmc_start_bkops(host->card, true);
+
+			/* prepare the request again */
+			if (areq)
+				mmc_pre_req(host, areq->mrq, !host->areq);
+		}
 	}
 
 	if (!err && areq)

commit fc75b708b849fd15da162e0a806ae0dc27996400
Author: Andrew Gabbasov <andrew_gabbasov@mentor.com>
Date:   Wed Oct 1 07:14:10 2014 -0500

    mmc: core: Add debug message for SET_BLOCK_COUNT result
    
    The debug messages with commands execution results, that are printed
    after processing the request, do not include results of sbc (set block count)
    part of request. Add the debug message for that part too.
    
    Signed-off-by: Andrew Gabbasov <andrew_gabbasov@mentor.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 9f1ecc4b8c82..ee2e776fb8e3 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -149,6 +149,14 @@ void mmc_request_done(struct mmc_host *host, struct mmc_request *mrq)
 
 		led_trigger_event(host->led, LED_OFF);
 
+		if (mrq->sbc) {
+			pr_debug("%s: req done <CMD%u>: %d: %08x %08x %08x %08x\n",
+				mmc_hostname(host), mrq->sbc->opcode,
+				mrq->sbc->error,
+				mrq->sbc->resp[0], mrq->sbc->resp[1],
+				mrq->sbc->resp[2], mrq->sbc->resp[3]);
+		}
+
 		pr_debug("%s: req done (CMD%u): %d: %08x %08x %08x %08x\n",
 			mmc_hostname(host), cmd->opcode, err,
 			cmd->resp[0], cmd->resp[1],

commit cce411e68515ee14c323d0d1fef638ed0aead7a6
Author: Andrew Gabbasov <andrew_gabbasov@mentor.com>
Date:   Wed Oct 1 07:14:09 2014 -0500

    mmc: core: Initialize SET_BLOCK_COUNT request fields
    
    Some request fields are initialized just before request processing
    for sanity purposes. This is done for command, data, and stop parts
    of the request, but not for sbc (set block count) part. Add such
    initialization for that part too.
    
    Signed-off-by: Andrew Gabbasov <andrew_gabbasov@mentor.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index f26a5f1d926d..9f1ecc4b8c82 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -214,6 +214,10 @@ mmc_start_request(struct mmc_host *host, struct mmc_request *mrq)
 
 	mrq->cmd->error = 0;
 	mrq->cmd->mrq = mrq;
+	if (mrq->sbc) {
+		mrq->sbc->error = 0;
+		mrq->sbc->mrq = mrq;
+	}
 	if (mrq->data) {
 		BUG_ON(mrq->data->blksz > host->max_blk_size);
 		BUG_ON(mrq->data->blocks > host->max_blk_count);

commit 6a98f1e83a2874a189754ded5254ae687828739e
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Tue Sep 23 23:00:26 2014 +0300

    mmc: Fix incorrect warning when setting 0 Hz via debugfs
    
    It is possible to turn off the card clock by setting
    the frequency to zero via debugfs e.g.
    
            echo 0 > /sys/kernel/debug/mmc0/clock
    
    However that produces an incorrect warning that is
    designed to warn if the frequency is below the minimum
    operating frequency.  So correct the warning.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index cbb23215ad87..f26a5f1d926d 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -995,7 +995,7 @@ void mmc_set_chip_select(struct mmc_host *host, int mode)
  */
 static void __mmc_set_clock(struct mmc_host *host, unsigned int hz)
 {
-	WARN_ON(hz < host->f_min);
+	WARN_ON(hz && hz < host->f_min);
 
 	if (hz > host->f_max)
 		hz = host->f_max;

commit 8af465db967bf25a4617416c0cbaaaa506d444f5
Author: Roger Tseng <rogerable@realtek.com>
Date:   Wed Sep 24 17:07:13 2014 +0800

    mmc: core: Add new power_mode MMC_POWER_UNDEFINED
    
    Add MMC_POWER_UNDEFINED for power_mode in struct mmc_ios and use it as
    the initial value of host->ios.power_mode.
    
    For hosts with MMC_CAP2_NO_PRESCAN_POWERUP, this makes the later
    mmc_power_off() do real power-off things instead of NOP, and further
    prevents state messed up in cards that was already initialized (eg. by
    BIOS of UEFI driver).
    
    Signed-off-by: Roger Tseng <rogerable@realtek.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index b1e209f479ad..cbb23215ad87 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2482,6 +2482,7 @@ void mmc_start_host(struct mmc_host *host)
 {
 	host->f_init = max(freqs[0], host->f_min);
 	host->rescan_disable = 0;
+	host->ios.power_mode = MMC_POWER_UNDEFINED;
 	if (host->caps2 & MMC_CAP2_NO_PRESCAN_POWERUP)
 		mmc_power_off(host);
 	else

commit 6606110d89aefcb21b9e70adfe064987cbd8393a
Author: Joe Perches <joe@perches.com>
Date:   Fri Sep 12 14:56:56 2014 -0700

    mmc: Convert pr_warning to pr_warn
    
    Use the much more common pr_warn instead of pr_warning.
    
    Other miscellanea:
    
    o Coalesce formats
    o Realign arguments
    o Remove extra spaces when coalescing formats
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index e2e1dd40fb11..b1e209f479ad 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -433,8 +433,8 @@ static void mmc_wait_for_req_done(struct mmc_host *host,
 		 */
 		if (cmd->sanitize_busy && cmd->error == -ETIMEDOUT) {
 			if (!mmc_interrupt_hpi(host->card)) {
-				pr_warning("%s: %s: Interrupted sanitize\n",
-					   mmc_hostname(host), __func__);
+				pr_warn("%s: %s: Interrupted sanitize\n",
+					mmc_hostname(host), __func__);
 				cmd->error = 0;
 				break;
 			} else {
@@ -1417,8 +1417,8 @@ int mmc_set_signal_voltage(struct mmc_host *host, int signal_voltage, u32 ocr)
 	if (!host->ops->start_signal_voltage_switch)
 		return -EPERM;
 	if (!host->ops->card_busy)
-		pr_warning("%s: cannot verify signal voltage switch\n",
-				mmc_hostname(host));
+		pr_warn("%s: cannot verify signal voltage switch\n",
+			mmc_hostname(host));
 
 	cmd.opcode = SD_SWITCH_VOLTAGE;
 	cmd.arg = 0;

commit cc8aa7de48277f62fe3fced762d75f01ce57e909
Author: Chuanxiao Dong <chuanxiao.dong@intel.com>
Date:   Thu Aug 14 18:29:24 2014 +0800

    mmc: core: resolve divded by zero panic
    
    With one special SD card, below divide by zero error observed:
    ...
    [    2.144300] divide error: 0000 [#1] PREEMPT SMP
    [    2.148860] Modules linked in:
    [    2.151898]
    [    2.152685] Set up 4031 stolen pages starting at 0x0001f000, GTT offset 0K
    [    2.157330] Set up 0 CI stolen pages starting at 0x00000000, GTT offset 131072K
    [    2.167581] Pid: 5, comm: kworker/u:0 Not tainted 3.0.8-138216-g974a2ab #1
    [    2.169506] [drm] PSB GTT mem manager ready, tt_start 4031, tt_size 28737 pages
    [    2.169906] [drm] SGX core id = 0x00000000
    [    2.169920] [drm] SGX core rev major = 0x00, minor = 0x00
    [    2.169934] [drm] SGX core rev maintenance = 0x00, designer = 0x00
    [    2.197370]  Intel Corporation Medfield/iCDKB
    [    2.201716] EIP: 0060:[<c1697ca6>] EFLAGS: 00010246 CPU: 1
    [    2.207198] EIP is at mmc_init_erase+0x76/0x150
    [    2.211704] EAX: 00002000 EBX: dcd1b400 ECX: 00002000 EDX: 00000000
    [    2.217957] ESI: 00000000 EDI: dcd5c800 EBP: dd867e84 ESP: dd867e7c
    [    2.224214]  DS: 007b ES: 007b FS: 00d8 GS: 0000 SS: 0068
    [    2.229605] Process kworker/u:0 (pid: 5, ti=dd866000 task=dd868000 task.ti=dd866000)
    [    2.237325] Stack:
    [    2.239322]  dcd1b400 00000000 dd867eb0 c16a06da c1ab7c44 dd995aa8 00000003 00000000
    [    2.247054]  00000000 00000000 dcd5c800 00000000 dcd1b400 dd867ef8 c16a1012 c1698b00
    [    2.254785]  00000029 00000001 c194eb80 dcd5c9ec dd867e00 c1239b00 00000000 00000000
    [    2.262519] Call Trace:
    [    2.264975]  [<c16a06da>] mmc_sd_setup_card+0x1da/0x4f0
    [    2.270183]  [<c16a1012>] mmc_sd_init_card+0x192/0xc40
    [    2.275304]  [<c1698b00>] ? __mmc_claim_host+0x160/0x160
    [    2.280610]  [<c1239b00>] ? __schedule_bug+0x50/0x80
    [    2.285556]  [<c16a1b89>] mmc_attach_sd+0xc9/0x230
    [    2.290333]  [<c169b6ef>] mmc_rescan+0x25f/0x2c0
    [    2.294943]  [<c1274223>] process_one_work+0x103/0x400
    [    2.300065]  [<c12670fd>] ? mod_timer+0x1ad/0x3c0
    [    2.304756]  [<c169b490>] ? mmc_suspend_host+0x1a0/0x1a0
    [    2.310056]  [<c127502d>] worker_thread+0x12d/0x4a0
    [    2.314921]  [<c18fcfbd>] ? preempt_schedule+0x2d/0x50
    [    2.320047]  [<c1274f00[    2.323976] ---[ end trace 5398ec2720494438 ]---
    ...
    
    So, seems this bad SD card does not set valid value in related SSR / CSD register fields.
    And then the driver will set card->erase_size to 0.
    Then it triggered this divided by zero error when calculate card->pref_erase.
    
    Submit this patch to fix the issue.
    
    Signed-off-by: Yunpeng Gao <yunpeng.gao@intel.com>
    Signed-off-by: Chuanxiao Dong <chuanxiao.dong@intel.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 68f5f4ba57e9..e2e1dd40fb11 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1753,7 +1753,7 @@ void mmc_init_erase(struct mmc_card *card)
 		card->erase_shift = ffs(card->ssr.au) - 1;
 	} else if (card->ext_csd.hc_erase_size) {
 		card->pref_erase = card->ext_csd.hc_erase_size;
-	} else {
+	} else if (card->erase_size) {
 		sz = (card->csd.capacity << (card->csd.read_blkbits - 9)) >> 11;
 		if (sz < 128)
 			card->pref_erase = 512 * 1024 / 512;
@@ -1770,7 +1770,8 @@ void mmc_init_erase(struct mmc_card *card)
 			if (sz)
 				card->pref_erase += card->erase_size - sz;
 		}
-	}
+	} else
+		card->pref_erase = 0;
 }
 
 static unsigned int mmc_mmc_erase_timeout(struct mmc_card *card,

commit 9ed7ca89e0d287e054d3816b8c0c57514eb23726
Author: Javier Martinez Canillas <javier.martinez@collabora.co.uk>
Date:   Thu Aug 14 14:39:00 2014 +0200

    mmc: core: Use regulator_get_voltage() if OCR mask is empty.
    
    The operation conditions register (OCR) stores the voltage
    profile of the card, however the list of possible voltages
    is restricted by the voltage range supported by the supply
    used as VCC/VDD. So in mmc_vddrange_to_ocrmask() a OCR mask
    is obtained to filter the not supported voltages, from the
    value read in the host controller OCR register.
    
    For fixed regulators, regulator_list_voltage() returns the
    fixed output for the first selector but this doesn't happen
    for switch (FET) regulators that obtain their voltage from
    their parent supply. A call to regulator_get_voltage() is
    needed in this case so the regulator core can return the
    FET's parent supply voltage output.
    
    This change is consistent with the fact that for other
    fixed regulators (that are not FETs) the OCR mask is
    returned even when mmc_regulator_set_ocr() checks if the
    regulator is fixed before calling regulator_set_voltage().
    
    Without this patch, the following warning is reported when
    a FET is used as a vmmc-supply:
    
    dwmmc_exynos 12220000.mmc: Failed getting OCR mask: -22
    
    Signed-off-by: Javier Martinez Canillas <javier.martinez@collabora.co.uk>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 2eb7c82ba4a2..68f5f4ba57e9 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1221,15 +1221,14 @@ int mmc_regulator_get_ocrmask(struct regulator *supply)
 	int			result = 0;
 	int			count;
 	int			i;
+	int			vdd_uV;
+	int			vdd_mV;
 
 	count = regulator_count_voltages(supply);
 	if (count < 0)
 		return count;
 
 	for (i = 0; i < count; i++) {
-		int		vdd_uV;
-		int		vdd_mV;
-
 		vdd_uV = regulator_list_voltage(supply, i);
 		if (vdd_uV <= 0)
 			continue;
@@ -1238,6 +1237,15 @@ int mmc_regulator_get_ocrmask(struct regulator *supply)
 		result |= mmc_vddrange_to_ocrmask(vdd_mV, vdd_mV);
 	}
 
+	if (!result) {
+		vdd_uV = regulator_get_voltage(supply);
+		if (vdd_uV <= 0)
+			return vdd_uV;
+
+		vdd_mV = vdd_uV / 1000;
+		result = mmc_vddrange_to_ocrmask(vdd_mV, vdd_mV);
+	}
+
 	return result;
 }
 EXPORT_SYMBOL_GPL(mmc_regulator_get_ocrmask);

commit ca6429d4952398570a3963bd4b5842b519087df8
Author: Tim Kryger <tim.kryger@gmail.com>
Date:   Mon Aug 11 22:05:12 2014 -0700

    mmc: core: Remove fixed voltage regulator logic
    
    There is no need for regulator consumers to include special logic for
    fixed voltage regulators as they support regulator_set_voltage() just
    like their non-fixed regulator counterparts.
    
    Signed-off-by: Tim Kryger <tim.kryger@gmail.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index d03a080fb9cd..2eb7c82ba4a2 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1263,7 +1263,6 @@ int mmc_regulator_set_ocr(struct mmc_host *mmc,
 
 	if (vdd_bit) {
 		int		tmp;
-		int		voltage;
 
 		/*
 		 * REVISIT mmc_vddrange_to_ocrmask() may have set some
@@ -1280,22 +1279,7 @@ int mmc_regulator_set_ocr(struct mmc_host *mmc,
 			max_uV = min_uV + 100 * 1000;
 		}
 
-		/*
-		 * If we're using a fixed/static regulator, don't call
-		 * regulator_set_voltage; it would fail.
-		 */
-		voltage = regulator_get_voltage(supply);
-
-		if (!regulator_can_change_voltage(supply))
-			min_uV = max_uV = voltage;
-
-		if (voltage < 0)
-			result = voltage;
-		else if (voltage < min_uV || voltage > max_uV)
-			result = regulator_set_voltage(supply, min_uV, max_uV);
-		else
-			result = 0;
-
+		result = regulator_set_voltage(supply, min_uV, max_uV);
 		if (result == 0 && !mmc->regulator_enabled) {
 			result = regulator_enable(supply);
 			if (!result)

commit 5204d00f06ac9af4ef9c469cce7f9bbe179739b1
Author: Lukas Czerner <lczerner@redhat.com>
Date:   Wed Jun 18 13:18:07 2014 +0200

    mmc: Do not advertise secure discard if it is blacklisted
    
    Currently when the device secure discard implementation is
    blacklisted (MMC_QUIRK_SEC_ERASE_TRIM_BROKEN quirk is set)
    instead of secure discard we're going to do normal discard,
    which is wrong.
    
    When the secure discard is known to be broken we should just
    disallow it entirely and not advertise this functionality to
    the user. Fix it.
    
    Also move mmc_fixup_device() in from of mmc_blk_alloc() so we
    can get quirks set before we attempt to set queue information.
    
    Signed-off-by: Lukas Czerner <lczerner@redhat.com>
    Acked-by: Jaehoon Chung <jh80.chung@samsung.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 7dc0c85fdb60..d03a080fb9cd 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2102,7 +2102,8 @@ EXPORT_SYMBOL(mmc_can_sanitize);
 
 int mmc_can_secure_erase_trim(struct mmc_card *card)
 {
-	if (card->ext_csd.sec_feature_support & EXT_CSD_SEC_ER_EN)
+	if ((card->ext_csd.sec_feature_support & EXT_CSD_SEC_ER_EN) &&
+	    !(card->quirks & MMC_QUIRK_SEC_ERASE_TRIM_BROKEN))
 		return 1;
 	return 0;
 }

commit 4d1f52f9a9f9a63371dba589093b3ae90fc80c3d
Author: Tim Kryger <tim.kryger@linaro.org>
Date:   Tue May 6 15:57:01 2014 -0700

    mmc: core: Improve support for deferred regulators
    
    Callers of mmc_regulator_get_supply could benefit from knowing if either
    of the regulators are present but not yet available.  Since callers do
    not currently examine the return value, modify this function to return
    zero or -EPROBE_DEFER if either regulator get returns the same.
    
    Furthermore, since callers check vmmc/vqmmc using IS_ERR and can deal
    with absent regulators, switch to devm_regulator_get_optional. This has
    the added benefit of allowing this function to behave correctly even in
    the !CONFIG_REGULATOR case such that the stub can be removed.
    
    Signed-off-by: Tim Kryger <tim.kryger@linaro.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <chris@printf.net>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 02baa30653fa..7dc0c85fdb60 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1314,31 +1314,38 @@ int mmc_regulator_set_ocr(struct mmc_host *mmc,
 }
 EXPORT_SYMBOL_GPL(mmc_regulator_set_ocr);
 
+#endif /* CONFIG_REGULATOR */
+
 int mmc_regulator_get_supply(struct mmc_host *mmc)
 {
 	struct device *dev = mmc_dev(mmc);
-	struct regulator *supply;
 	int ret;
 
-	supply = devm_regulator_get(dev, "vmmc");
-	mmc->supply.vmmc = supply;
+	mmc->supply.vmmc = devm_regulator_get_optional(dev, "vmmc");
 	mmc->supply.vqmmc = devm_regulator_get_optional(dev, "vqmmc");
 
-	if (IS_ERR(supply))
-		return PTR_ERR(supply);
+	if (IS_ERR(mmc->supply.vmmc)) {
+		if (PTR_ERR(mmc->supply.vmmc) == -EPROBE_DEFER)
+			return -EPROBE_DEFER;
+		dev_info(dev, "No vmmc regulator found\n");
+	} else {
+		ret = mmc_regulator_get_ocrmask(mmc->supply.vmmc);
+		if (ret > 0)
+			mmc->ocr_avail = ret;
+		else
+			dev_warn(dev, "Failed getting OCR mask: %d\n", ret);
+	}
 
-	ret = mmc_regulator_get_ocrmask(supply);
-	if (ret > 0)
-		mmc->ocr_avail = ret;
-	else
-		dev_warn(mmc_dev(mmc), "Failed getting OCR mask: %d\n", ret);
+	if (IS_ERR(mmc->supply.vqmmc)) {
+		if (PTR_ERR(mmc->supply.vqmmc) == -EPROBE_DEFER)
+			return -EPROBE_DEFER;
+		dev_info(dev, "No vqmmc regulator found\n");
+	}
 
 	return 0;
 }
 EXPORT_SYMBOL_GPL(mmc_regulator_get_supply);
 
-#endif /* CONFIG_REGULATOR */
-
 /*
  * Mask off any voltages we don't support and select
  * the lowest voltage

commit cdc991790c51c693d0c347a5286af017826a5d01
Author: Seungwon Jeon <tgih.jun@samsung.com>
Date:   Wed Apr 23 17:07:35 2014 +0900

    mmc: drop the speed mode of card's state
    
    Timing mode identifier has same role and can take the place
    of speed mode. This change removes all related speed mode.
    
    Signed-off-by: Seungwon Jeon <tgih.jun@samsung.com>
    Tested-by: Jaehoon Chung <jh80.chung@samsung.com>
    Acked-by: Jaehoon Chung <jh80.chung@samsung.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <chris@printf.net>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index d97dff5fab62..02baa30653fa 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2192,7 +2192,7 @@ int mmc_set_blocklen(struct mmc_card *card, unsigned int blocklen)
 {
 	struct mmc_command cmd = {0};
 
-	if (mmc_card_blockaddr(card) || mmc_card_ddr_mode(card))
+	if (mmc_card_blockaddr(card) || mmc_card_ddr52(card))
 		return 0;
 
 	cmd.opcode = MMC_SET_BLOCKLEN;
@@ -2272,7 +2272,6 @@ static int mmc_do_hw_reset(struct mmc_host *host, int check)
 		}
 	}
 
-	host->card->state &= ~(MMC_STATE_HIGHSPEED | MMC_STATE_HIGHSPEED_DDR);
 	if (mmc_host_is_spi(host)) {
 		host->ios.chip_select = MMC_CS_HIGH;
 		host->ios.bus_mode = MMC_BUSMODE_PUSHPULL;

commit ceae98f20e36ffcf579fd5ae74c8f24b00c0f383
Author: Tim Kryger <tim.kryger@linaro.org>
Date:   Thu Apr 24 14:44:26 2014 -0700

    mmc: core: Try other signal levels during power up
    
    The eMMC signalling voltage is determined by VCCQ which is provided to
    the card by the host.  Signalling is not required to begin at 3.3v and,
    if the host and card both support a particular VCC/VCCQ combination, it
    can be used immediately.
    
    In contrast, SD Cards must begin with 3.3v signalling and may switch to
    a lower voltage signalling if instructed to do so in CMD11.  A message
    is required to coordinate this operation because the card only receives
    a 3.3v VDD and must know when to use the 1.8v produced by its internal
    regulator.
    
    It makes sense for the core to begin with 3.3v signalling but when that
    can't be set, 1.8v and 1.2v signalling also should be attempted.  This
    is especially important when an external regulator with a limited range
    is used to supply VCCQ to an eMMC part.
    
    Signed-off-by: Tim Kryger <tim.kryger@linaro.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <chris@printf.net>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 79ba3a5bbf17..d97dff5fab62 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1537,8 +1537,13 @@ void mmc_power_up(struct mmc_host *host, u32 ocr)
 	host->ios.timing = MMC_TIMING_LEGACY;
 	mmc_set_ios(host);
 
-	/* Set signal voltage to 3.3V */
-	__mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_330);
+	/* Try to set signal voltage to 3.3V but fall back to 1.8v or 1.2v */
+	if (__mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_330) == 0)
+		dev_dbg(mmc_dev(host), "Initial signal voltage of 3.3v\n");
+	else if (__mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_180) == 0)
+		dev_dbg(mmc_dev(host), "Initial signal voltage of 1.8v\n");
+	else if (__mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_120) == 0)
+		dev_dbg(mmc_dev(host), "Initial signal voltage of 1.2v\n");
 
 	/*
 	 * This delay should be sufficient to allow the power supply

commit f7bf11a3a2e0ee829a262b4b0bb09c2bb40cf6fa
Author: Stefan Wahren <stefan.wahren@i2se.com>
Date:   Thu Apr 3 17:32:05 2014 +0200

    mmc: core: Use maximum timeout values in case TACC field is zero
    
    When plugging a specific micro SD card at MMC socket of a custom i.MX28 board,
    we get the following kernel warning:
    
    WARNING: CPU: 0 PID: 30 at drivers/mmc/host/mxs-mmc.c:342 mxs_mmc_start_cmd+0x34c/0x378()
    Modules linked in:
    CPU: 0 PID: 30 Comm: kworker/u2:1 Not tainted 3.14.0-rc5 #8
    Workqueue: kmmcd mmc_rescan
    [<c0015420>] (unwind_backtrace) from [<c0012cb0>] (show_stack+0x10/0x14)
    [<c0012cb0>] (show_stack) from [<c001daf8>] (warn_slowpath_common+0x6c/0x8c)
    [<c001daf8>] (warn_slowpath_common) from [<c001db34>] (warn_slowpath_null+0x1c/0x24)
    [<c001db34>] (warn_slowpath_null) from [<c0349478>] (mxs_mmc_start_cmd+0x34c/0x378)
    [<c0349478>] (mxs_mmc_start_cmd) from [<c0338fa0>] (mmc_start_request+0xc4/0xf4)
    [<c0338fa0>] (mmc_start_request) from [<c03390b4>] (mmc_wait_for_req+0x50/0x164)
    [<c03390b4>] (mmc_wait_for_req) from [<c03405b8>] (mmc_app_send_scr+0x158/0x1c8)
    [<c03405b8>] (mmc_app_send_scr) from [<c033ee1c>] (mmc_sd_setup_card+0x80/0x3c8)
    [<c033ee1c>] (mmc_sd_setup_card) from [<c033f788>] (mmc_sd_init_card+0x124/0x66c)
    [<c033f788>] (mmc_sd_init_card) from [<c033fd7c>] (mmc_attach_sd+0xac/0x174)
    [<c033fd7c>] (mmc_attach_sd) from [<c033a658>] (mmc_rescan+0x25c/0x2d8)
    [<c033a658>] (mmc_rescan) from [<c003597c>] (process_one_work+0x1b4/0x4ec)
    [<c003597c>] (process_one_work) from [<c0035de4>] (worker_thread+0x130/0x464)
    [<c0035de4>] (worker_thread) from [<c003c824>] (kthread+0xb4/0xd0)
    [<c003c824>] (kthread) from [<c000f420>] (ret_from_fork+0x14/0x34)
    
    The error is due to an invalid value in CSD register of a specific 2GB
    micro SD card. The CSD version of this card is 1.0 but the TACC field
    has the invalid value 0.
    
    cid:0000005553442020000000000000583f
    csd:00000032535a83bfedb7ffbf1680003f
    date:08/2005
    erase_size:512
    fwrev:0x0
    hwrev:0x0
    manfid:0x000000
    name:USD
    oemid:0x0000
    preferred_erase_size:4194304
    scr:0225000000000000
    serial:0x00000000
    type:SD
    
    Since the kernel is making use of this TACC field to calculate the SD
    card timeout, an invalid value 0 leads to a warning at
    mxs_ns_to_ssp_ticks() and later the following misleading error message
    appears in a loop:
    
    mxs-mmc 80010000.ssp: card claims to support voltages below defined range
    mxs-mmc 80010000.ssp: no support for card's volts
    mmc0: error -22 whilst initialising MMC card
    
    This error is only found on this 2GB SD card on mxs platform.
    On x86 this card works without any problems.
    
    The following patch based on the work of Peter Chan and Otavio Salvador.
    It catches the case that the determined timeout is still 0 and sets it
    to a valid value.
    
    Successful tested on a i.MX28 board.
    
    Signed-off-by: Stefan Wahren <stefan.wahren@i2se.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <chris@printf.net>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index f396d1bb4ac4..79ba3a5bbf17 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -800,6 +800,10 @@ void mmc_set_data_timeout(struct mmc_data *data, const struct mmc_card *card)
 			data->timeout_ns = limit_us * 1000;
 			data->timeout_clks = 0;
 		}
+
+		/* assign limit value if invalid */
+		if (timeout_us == 0)
+			data->timeout_ns = limit_us * 1000;
 	}
 
 	/*

commit fa372a51cb5f93800f711473e5a36e0e0c9a8f00
Author: Markus Mayer <markus.mayer@linaro.org>
Date:   Tue Apr 8 15:19:43 2014 -0700

    mmc: Delay the card_event callback into the mmc_rescan worker
    
    This change removes the callback from atomic context which it doesn't
    need to be in, and puts it in line with the debounced rescan.
    
    This code is based on these e-mail threads with Christian Daudt:
    
      https://lkml.org/lkml/2013/8/19/539
      https://lkml.org/lkml/2014/3/19/79
    
    Signed-off-by: Markus Mayer <markus.mayer@linaro.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <chris@printf.net>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index acbc3f2aaaf9..f396d1bb4ac4 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2403,6 +2403,11 @@ void mmc_rescan(struct work_struct *work)
 		container_of(work, struct mmc_host, detect.work);
 	int i;
 
+	if (host->trigger_card_event && host->ops->card_event) {
+		host->ops->card_event(host);
+		host->trigger_card_event = false;
+	}
+
 	if (host->rescan_disable)
 		return;
 

commit 740a221ef0e579dc7c675cf6b90f5313509788f7
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Mon Mar 10 15:02:41 2014 +0200

    mmc: slot-gpio: Add GPIO descriptor based CD GPIO API
    
    Add functions to request a CD GPIO using the GPIO descriptor API.
    Note that the new request function is paired with mmc_gpiod_free_cd()
    not mmc_gpio_free_cd().  Note also that it must be called prior to
    mmc_add_host() otherwise the caller must also call
    mmc_gpiod_request_cd_irq().
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Chris Ball <chris@printf.net>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index dc7a5fb81a5c..acbc3f2aaaf9 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -34,6 +34,7 @@
 #include <linux/mmc/host.h>
 #include <linux/mmc/mmc.h>
 #include <linux/mmc/sd.h>
+#include <linux/mmc/slot-gpio.h>
 
 #include "core.h"
 #include "bus.h"
@@ -2471,6 +2472,7 @@ void mmc_start_host(struct mmc_host *host)
 		mmc_power_off(host);
 	else
 		mmc_power_up(host, host->ocr_avail);
+	mmc_gpiod_request_cd_irq(host);
 	_mmc_detect_change(host, 0, false);
 }
 
@@ -2482,6 +2484,8 @@ void mmc_stop_host(struct mmc_host *host)
 	host->removed = 1;
 	spin_unlock_irqrestore(&host->lock, flags);
 #endif
+	if (host->slot.cd_irq >= 0)
+		disable_irq(host->slot.cd_irq);
 
 	host->rescan_disable = 1;
 	cancel_delayed_work_sync(&host->detect);

commit 4509f847751c9d2a724f37fe831393fbac34b80f
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Wed Jan 8 16:09:33 2014 +0100

    mmc: core: Add ignore_crc flag to __mmc_switch
    
    Instead of handle specific adaptations, releated to certain switch
    operations, inside __mmc_switch, push this to be handled by the caller
    instead.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <chris@printf.net>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 1935812e4215..dc7a5fb81a5c 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -285,7 +285,8 @@ void mmc_start_bkops(struct mmc_card *card, bool from_exception)
 	}
 
 	err = __mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
-			EXT_CSD_BKOPS_START, 1, timeout, use_busy_signal, true);
+			EXT_CSD_BKOPS_START, 1, timeout,
+			use_busy_signal, true, false);
 	if (err) {
 		pr_warn("%s: Error %d starting bkops\n",
 			mmc_hostname(card->host), err);

commit 1d4d77444bf4212c44585146a2b353ca24c815f9
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Wed Jan 8 15:06:08 2014 +0100

    mmc: core: Rename cmd_timeout_ms to busy_timeout
    
    To better reflect that the cmd_timeout_ms is directly related to the
    busy detection timeout, let's rename it.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <chris@printf.net>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index d9c1efa2ce15..1935812e4215 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1933,7 +1933,7 @@ static int mmc_do_erase(struct mmc_card *card, unsigned int from,
 	cmd.opcode = MMC_ERASE;
 	cmd.arg = arg;
 	cmd.flags = MMC_RSP_SPI_R1B | MMC_RSP_R1B | MMC_CMD_AC;
-	cmd.cmd_timeout_ms = mmc_erase_timeout(card, arg, qty);
+	cmd.busy_timeout = mmc_erase_timeout(card, arg, qty);
 	err = mmc_wait_for_cmd(card->host, &cmd, 0);
 	if (err) {
 		pr_err("mmc_erase: erase error %d, status %#x\n",

commit 68eb80e06bfa06035d0304686124974780308fae
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Wed Dec 18 09:57:38 2013 +0100

    mmc: core: Rename max_discard_to to max_busy_timeout
    
    Rename host->max_discard_to to host->max_busy_timeout, to reflect that
    it tells the mmc core layer about the maximum supported busy detection
    timeout by the host.
    
    This timeout is at the moment only applicable to erase/trim/discard
    commands. By the renaming we provide the option of make use of it for
    other commands that cares about busy detection. In other words, those
    commands that wants an R1B response, like for example the mmc switch
    command.
    
    Do note that the max_busy_timeout is supposed to be specified only by
    hosts supporting MMC_CAP_WAIT_WHILE_BUSY.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <chris@printf.net>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index f5a068d55c36..d9c1efa2ce15 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2120,7 +2120,7 @@ static unsigned int mmc_do_calc_max_discard(struct mmc_card *card,
 		y = 0;
 		for (x = 1; x && x <= max_qty && max_qty - x >= qty; x <<= 1) {
 			timeout = mmc_erase_timeout(card, arg, qty + x);
-			if (timeout > host->max_discard_to)
+			if (timeout > host->max_busy_timeout)
 				break;
 			if (timeout < last_timeout)
 				break;
@@ -2152,7 +2152,7 @@ unsigned int mmc_calc_max_discard(struct mmc_card *card)
 	struct mmc_host *host = card->host;
 	unsigned int max_discard, max_trim;
 
-	if (!host->max_discard_to)
+	if (!host->max_busy_timeout)
 		return UINT_MAX;
 
 	/*
@@ -2172,7 +2172,7 @@ unsigned int mmc_calc_max_discard(struct mmc_card *card)
 		max_discard = 0;
 	}
 	pr_debug("%s: calculated max. discard sectors %u for timeout %u ms\n",
-		 mmc_hostname(host), max_discard, host->max_discard_to);
+		 mmc_hostname(host), max_discard, host->max_busy_timeout);
 	return max_discard;
 }
 EXPORT_SYMBOL(mmc_calc_max_discard);

commit 7536d3f83aa42ba1a3b1c6b30c2b6d94a820cbb2
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Wed Dec 18 11:59:17 2013 +0100

    mmc: core: Enable MMC_CAP2_CACHE_CTRL as default
    
    There are no reason to why the use of a non-volatile internal eMMC
    cache should be controlled by a host cap. Instead let's just enable it
    if the eMMC card supports it.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Seungwon Jeon <tgih.jun@samsung.com>
    Signed-off-by: Chris Ball <chris@printf.net>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 8928f9f4cfe1..f5a068d55c36 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2562,12 +2562,8 @@ EXPORT_SYMBOL(mmc_power_restore_host);
  */
 int mmc_flush_cache(struct mmc_card *card)
 {
-	struct mmc_host *host = card->host;
 	int err = 0;
 
-	if (!(host->caps2 & MMC_CAP2_CACHE_CTRL))
-		return err;
-
 	if (mmc_card_mmc(card) &&
 			(card->ext_csd.cache_size > 0) &&
 			(card->ext_csd.cache_ctrl & 1)) {

commit 10e5d9652499a8bc0a99ffc2a96a3030fee576cb
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Mon Dec 16 16:23:22 2013 +0100

    mmc: core: Use mmc_flush_cache() during mmc suspend
    
    Earlier we disabled the cache during suspend, which meant a flush was
    internally at the eMMC performed as well.
    
    To simplify code we can make use of the mmc_flush_cache(), during mmc
    suspend, which makes the mmc_cache_ctrl() redundant so then we can
    remove it.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Seungwon Jeon <tgih.jun@samsung.com>
    Signed-off-by: Chris Ball <chris@printf.net>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 22427c684b36..8928f9f4cfe1 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2582,44 +2582,6 @@ int mmc_flush_cache(struct mmc_card *card)
 }
 EXPORT_SYMBOL(mmc_flush_cache);
 
-/*
- * Turn the cache ON/OFF.
- * Turning the cache OFF shall trigger flushing of the data
- * to the non-volatile storage.
- * This function should be called with host claimed
- */
-int mmc_cache_ctrl(struct mmc_host *host, u8 enable)
-{
-	struct mmc_card *card = host->card;
-	unsigned int timeout;
-	int err = 0;
-
-	if (!(host->caps2 & MMC_CAP2_CACHE_CTRL) ||
-			mmc_card_is_removable(host))
-		return err;
-
-	if (card && mmc_card_mmc(card) &&
-			(card->ext_csd.cache_size > 0)) {
-		enable = !!enable;
-
-		if (card->ext_csd.cache_ctrl ^ enable) {
-			timeout = enable ? card->ext_csd.generic_cmd6_time : 0;
-			err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
-					EXT_CSD_CACHE_CTRL, enable, timeout);
-			if (err)
-				pr_err("%s: cache %s error %d\n",
-						mmc_hostname(card->host),
-						enable ? "on" : "off",
-						err);
-			else
-				card->ext_csd.cache_ctrl = enable;
-		}
-	}
-
-	return err;
-}
-EXPORT_SYMBOL(mmc_cache_ctrl);
-
 #ifdef CONFIG_PM
 
 /* Do the card removal on suspend if card is assumed removeable

commit 5601aaf73e5c2f0aa5e3607fee7b7d3511edfea9
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Wed Oct 30 23:15:30 2013 +0100

    mmc: core: Remove unnecessary validations for bus_ops callbacks
    
    Due to the removal of the Kconfig option MMC_UNSAFE_RESUME, several
    validations of a present bus_ops callback became redundant. Let's
    remove these.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <chris@printf.net>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 10856ec64412..22427c684b36 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2231,9 +2231,6 @@ static int mmc_do_hw_reset(struct mmc_host *host, int check)
 {
 	struct mmc_card *card = host->card;
 
-	if (!host->bus_ops->power_restore)
-		return -EOPNOTSUPP;
-
 	if (!(host->caps & MMC_CAP_HW_RESET) || !host->ops->hw_reset)
 		return -EOPNOTSUPP;
 
@@ -2335,7 +2332,7 @@ int _mmc_detect_card_removed(struct mmc_host *host)
 {
 	int ret;
 
-	if ((host->caps & MMC_CAP_NONREMOVABLE) || !host->bus_ops->alive)
+	if (host->caps & MMC_CAP_NONREMOVABLE)
 		return 0;
 
 	if (!host->card || mmc_card_removed(host->card))
@@ -2418,7 +2415,7 @@ void mmc_rescan(struct work_struct *work)
 	 * if there is a _removable_ card registered, check whether it is
 	 * still present
 	 */
-	if (host->bus_ops && host->bus_ops->detect && !host->bus_dead
+	if (host->bus_ops && !host->bus_dead
 	    && !(host->caps & MMC_CAP_NONREMOVABLE))
 		host->bus_ops->detect(host);
 
@@ -2520,7 +2517,7 @@ int mmc_power_save_host(struct mmc_host *host)
 
 	mmc_bus_get(host);
 
-	if (!host->bus_ops || host->bus_dead || !host->bus_ops->power_restore) {
+	if (!host->bus_ops || host->bus_dead) {
 		mmc_bus_put(host);
 		return -EINVAL;
 	}
@@ -2546,7 +2543,7 @@ int mmc_power_restore_host(struct mmc_host *host)
 
 	mmc_bus_get(host);
 
-	if (!host->bus_ops || host->bus_dead || !host->bus_ops->power_restore) {
+	if (!host->bus_ops || host->bus_dead) {
 		mmc_bus_put(host);
 		return -EINVAL;
 	}
@@ -2651,7 +2648,7 @@ int mmc_pm_notify(struct notifier_block *notify_block,
 		/* Validate prerequisites for suspend */
 		if (host->bus_ops->pre_suspend)
 			err = host->bus_ops->pre_suspend(host);
-		if (!err && host->bus_ops->suspend)
+		if (!err)
 			break;
 
 		/* Calling bus_ops->remove() with a claimed host can deadlock */

commit 2501c9179dff2add6aadd3898cd729e94e777d3a
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Wed Oct 30 01:00:18 2013 +0100

    mmc: core: Use MMC_UNSAFE_RESUME as default behavior
    
    Invoking system suspend or shutdown without using the Kconfig option
    MMC_UNSAFE_RESUME, did trigger an ungraceful power cut of the card.
    
    To improve the situation, change the behavior to always make use of the
    available bus_ops callbacks that handles system suspend and shutdown
    properly.
    
    By changing the behavior MMC_UNSAFE_RESUME becomes redundant, so lets's
    remove it.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <chris@printf.net>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 098374b1ab2b..10856ec64412 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -64,23 +64,6 @@ static const unsigned freqs[] = { 400000, 300000, 200000, 100000 };
 bool use_spi_crc = 1;
 module_param(use_spi_crc, bool, 0);
 
-/*
- * We normally treat cards as removed during suspend if they are not
- * known to be on a non-removable bus, to avoid the risk of writing
- * back data to a different card after resume.  Allow this to be
- * overridden if necessary.
- */
-#ifdef CONFIG_MMC_UNSAFE_RESUME
-bool mmc_assume_removable;
-#else
-bool mmc_assume_removable = 1;
-#endif
-EXPORT_SYMBOL(mmc_assume_removable);
-module_param_named(removable, mmc_assume_removable, bool, 0644);
-MODULE_PARM_DESC(
-	removable,
-	"MMC/SD cards are removable and may be removed during suspend");
-
 /*
  * Internal function. Schedule delayed work in the MMC work queue.
  */

commit c1b55bfcb3e5599eb5e67efed70698ade02add4e
Author: Sascha Hauer <s.hauer@pengutronix.de>
Date:   Thu Dec 5 14:34:46 2013 +0100

    mmc: Do not call get_cd for non removable cards
    
    Non removable cards are always present, so do not call get_cd for them.
    
    Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>
    Acked-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 57a2b403bf8e..098374b1ab2b 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2460,7 +2460,8 @@ void mmc_rescan(struct work_struct *work)
 	 */
 	mmc_bus_put(host);
 
-	if (host->ops->get_cd && host->ops->get_cd(host) == 0) {
+	if (!(host->caps & MMC_CAP_NONREMOVABLE) && host->ops->get_cd &&
+			host->ops->get_cd(host) == 0) {
 		mmc_claim_host(host);
 		mmc_power_off(host);
 		mmc_release_host(host);

commit 3c0d22e8180b98eea412b84aa0f0c42c16159679
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu Sep 26 11:01:18 2013 +0200

    mmc: core: Remove deprecated mmc_suspend|resume_host APIs
    
    The are no more users of the deprecated mmc_suspend|resume_host API,
    so let's remove it.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 49dfafa99cc1..57a2b403bf8e 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2641,28 +2641,6 @@ EXPORT_SYMBOL(mmc_cache_ctrl);
 
 #ifdef CONFIG_PM
 
-/**
- *	mmc_suspend_host - suspend a host
- *	@host: mmc host
- */
-int mmc_suspend_host(struct mmc_host *host)
-{
-	/* This function is deprecated */
-	return 0;
-}
-EXPORT_SYMBOL(mmc_suspend_host);
-
-/**
- *	mmc_resume_host - resume a previously suspended host
- *	@host: mmc host
- */
-int mmc_resume_host(struct mmc_host *host)
-{
-	/* This function is deprecated */
-	return 0;
-}
-EXPORT_SYMBOL(mmc_resume_host);
-
 /* Do the card removal on suspend if card is assumed removeable
  * Do that in pm notifier while userspace isn't yet frozen, so we will be able
    to sync the card.

commit bbd43682eb12dab2ff4addfca04c32043dfde026
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri Sep 20 11:02:35 2013 +0200

    mmc: core: Signal wakeup event at card insert/removal
    
    We want to give user space provision to fully consume a card
    insert/remove event, when the event was caused by a wakeup irq.
    
    By signaling the wakeup event for a time of 5 s for devices configured
    as wakeup capable, we likely will be prevent a sleep long enough to let
    user space consume the event.
    
    To enable this feature, host drivers must thus configure their devices
    as wakeup capable.
    
    This is a reworked implementation of the old wakelocks for the mmc
    subsystem, originally authored by Colin Cross and San Mehat for the
    Android kernel. Zoran Markovic shall also be given cred for recently
    re-trying to upstream this feature.
    
    Cc: San Mehat <san@google.com>
    Cc: Colin Cross <ccross@android.com>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Zoran Markovic <zoran.markovic@linaro.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Zoran Markovic <zoran.markovic@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index bcb507771eeb..49dfafa99cc1 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -23,6 +23,7 @@
 #include <linux/log2.h>
 #include <linux/regulator/consumer.h>
 #include <linux/pm_runtime.h>
+#include <linux/pm_wakeup.h>
 #include <linux/suspend.h>
 #include <linux/fault-inject.h>
 #include <linux/random.h>
@@ -1692,6 +1693,28 @@ void mmc_detach_bus(struct mmc_host *host)
 	mmc_bus_put(host);
 }
 
+static void _mmc_detect_change(struct mmc_host *host, unsigned long delay,
+				bool cd_irq)
+{
+#ifdef CONFIG_MMC_DEBUG
+	unsigned long flags;
+	spin_lock_irqsave(&host->lock, flags);
+	WARN_ON(host->removed);
+	spin_unlock_irqrestore(&host->lock, flags);
+#endif
+
+	/*
+	 * If the device is configured as wakeup, we prevent a new sleep for
+	 * 5 s to give provision for user space to consume the event.
+	 */
+	if (cd_irq && !(host->caps & MMC_CAP_NEEDS_POLL) &&
+		device_can_wakeup(mmc_dev(host)))
+		pm_wakeup_event(mmc_dev(host), 5000);
+
+	host->detect_change = 1;
+	mmc_schedule_delayed_work(&host->detect, delay);
+}
+
 /**
  *	mmc_detect_change - process change of state on a MMC socket
  *	@host: host which changed state.
@@ -1704,16 +1727,8 @@ void mmc_detach_bus(struct mmc_host *host)
  */
 void mmc_detect_change(struct mmc_host *host, unsigned long delay)
 {
-#ifdef CONFIG_MMC_DEBUG
-	unsigned long flags;
-	spin_lock_irqsave(&host->lock, flags);
-	WARN_ON(host->removed);
-	spin_unlock_irqrestore(&host->lock, flags);
-#endif
-	host->detect_change = 1;
-	mmc_schedule_delayed_work(&host->detect, delay);
+	_mmc_detect_change(host, delay, true);
 }
-
 EXPORT_SYMBOL(mmc_detect_change);
 
 void mmc_init_erase(struct mmc_card *card)
@@ -2392,7 +2407,7 @@ int mmc_detect_card_removed(struct mmc_host *host)
 			 * rescan handle the card removal.
 			 */
 			cancel_delayed_work(&host->detect);
-			mmc_detect_change(host, 0);
+			_mmc_detect_change(host, 0, false);
 		}
 	}
 
@@ -2474,7 +2489,7 @@ void mmc_start_host(struct mmc_host *host)
 		mmc_power_off(host);
 	else
 		mmc_power_up(host, host->ocr_avail);
-	mmc_detect_change(host, 0);
+	_mmc_detect_change(host, 0, false);
 }
 
 void mmc_stop_host(struct mmc_host *host)
@@ -2693,7 +2708,7 @@ int mmc_pm_notify(struct notifier_block *notify_block,
 		spin_lock_irqsave(&host->lock, flags);
 		host->rescan_disable = 0;
 		spin_unlock_irqrestore(&host->lock, flags);
-		mmc_detect_change(host, 0);
+		_mmc_detect_change(host, 0, false);
 
 	}
 

commit 726d6f2374410d980341bfeb49399614e689e702
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Mon Sep 16 12:06:15 2013 +0200

    mmc: core: Collect common code for card ocr validation
    
    Since mmc_select_voltage now only gets called from the attach sequence,
    it makes sense to move the out of spec validations of the card ocr into
    this function.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 63672aba0e98..bcb507771eeb 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1357,6 +1357,16 @@ u32 mmc_select_voltage(struct mmc_host *host, u32 ocr)
 {
 	int bit;
 
+	/*
+	 * Sanity check the voltages that the card claims to
+	 * support.
+	 */
+	if (ocr & 0x7F) {
+		dev_warn(mmc_dev(host),
+		"card claims to support voltages below defined range\n");
+		ocr &= ~0x7F;
+	}
+
 	ocr &= host->ocr_avail;
 	if (!ocr) {
 		dev_warn(mmc_dev(host), "no support for card's volts\n");

commit ce69d37b7d8fa692c45d71d94aa0c921859b82ce
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Mon Sep 16 11:28:42 2013 +0200

    mmc: core: Prevent violation of specs while initializing cards
    
    According to eMMC/SD/SDIO specs, the VDD (VCC) voltage level must be
    maintained during the initialization sequence. If we want/need to tune
    the voltage level, a complete power cycle of the card must be executed.
    
    Most host drivers conforms to the specifications by only allowing to
    change VDD voltage level at the MMC_POWER_UP state, but some also cares
    about MMC_POWER_ON state, which they should'nt. This patch will not
    break those drivers, but they could clean up code to better reflect
    what is expected from the protocol layer.
    
    A big re-work of the mmc_select_voltage function is done to only change
    VDD voltage level if the host supports MMC_CAP2_FULL_PWR_CYCLE.
    Otherwise only validation of the host and card ocr mask will be done.
    
    A very nice side-effect of this patch is that we now don't need to
    reset the negotiated ocr mask at the mmc_power_off function, since now
    it will actually reflect the present voltage level, which safely can be
    used at the next power up and re-initialization. Moreover, we then only
    need to execute mmc_select_voltage from the attach sequence.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 529d2eff6095..63672aba0e98 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1358,21 +1358,20 @@ u32 mmc_select_voltage(struct mmc_host *host, u32 ocr)
 	int bit;
 
 	ocr &= host->ocr_avail;
+	if (!ocr) {
+		dev_warn(mmc_dev(host), "no support for card's volts\n");
+		return 0;
+	}
 
-	bit = ffs(ocr);
-	if (bit) {
-		bit -= 1;
-
+	if (host->caps2 & MMC_CAP2_FULL_PWR_CYCLE) {
+		bit = ffs(ocr) - 1;
 		ocr &= 3 << bit;
-
-		mmc_host_clk_hold(host);
-		host->ios.vdd = bit;
-		mmc_set_ios(host);
-		mmc_host_clk_release(host);
+		mmc_power_cycle(host, ocr);
 	} else {
-		pr_warning("%s: host doesn't support card's voltages\n",
-				mmc_hostname(host));
-		ocr = 0;
+		bit = fls(ocr) - 1;
+		ocr &= 3 << bit;
+		if (bit != host->ios.vdd)
+			dev_warn(mmc_dev(host), "exceeding card's volts\n");
 	}
 
 	return ocr;
@@ -1571,14 +1570,6 @@ void mmc_power_off(struct mmc_host *host)
 	host->ios.clock = 0;
 	host->ios.vdd = 0;
 
-
-	/*
-	 * Reset ocr mask to be the highest possible voltage supported for
-	 * this card. This value will be used at next power up.
-	 */
-	if (host->card)
-		host->card->ocr = 1 << (fls(host->ocr_avail) - 1);
-
 	if (!mmc_host_is_spi(host)) {
 		host->ios.bus_mode = MMC_BUSMODE_OPENDRAIN;
 		host->ios.chip_select = MMC_CS_DONTCARE;

commit 6904115095ad60ced638eb1e36e0e4e5e7de00b0
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri Sep 13 11:31:33 2013 +0200

    mmc: core: Move cached value of the negotiated ocr mask to card struct
    
    The negotiated ocr mask is directly related to the card. Once a card
    gets removed, the mask shall be dropped. By moving the cache of the ocr
    mask from the host struct to the card struct we have accomplished this.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 5909ba46b8f2..529d2eff6095 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1574,9 +1574,10 @@ void mmc_power_off(struct mmc_host *host)
 
 	/*
 	 * Reset ocr mask to be the highest possible voltage supported for
-	 * this mmc host. This value will be used at next power up.
+	 * this card. This value will be used at next power up.
 	 */
-	host->ocr = 1 << (fls(host->ocr_avail) - 1);
+	if (host->card)
+		host->card->ocr = 1 << (fls(host->ocr_avail) - 1);
 
 	if (!mmc_host_is_spi(host)) {
 		host->ios.bus_mode = MMC_BUSMODE_OPENDRAIN;
@@ -2550,7 +2551,7 @@ int mmc_power_restore_host(struct mmc_host *host)
 		return -EINVAL;
 	}
 
-	mmc_power_up(host, host->ocr);
+	mmc_power_up(host, host->card->ocr);
 	ret = host->bus_ops->power_restore(host);
 
 	mmc_bus_put(host);

commit 0f791fdad82a02af013e4fc8c385dc690080c366
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu Sep 12 15:36:34 2013 +0200

    mmc: core: Let mmc_set_signal_voltage take ocr as parameter
    
    This is yet another step of restructure code to be able to fixup the
    setup of the negotiated ocr mask.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index b66e7ab2ad43..5909ba46b8f2 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1397,7 +1397,7 @@ int __mmc_set_signal_voltage(struct mmc_host *host, int signal_voltage)
 
 }
 
-int mmc_set_signal_voltage(struct mmc_host *host, int signal_voltage)
+int mmc_set_signal_voltage(struct mmc_host *host, int signal_voltage, u32 ocr)
 {
 	struct mmc_command cmd = {0};
 	int err = 0;
@@ -1479,7 +1479,7 @@ int mmc_set_signal_voltage(struct mmc_host *host, int signal_voltage)
 	if (err) {
 		pr_debug("%s: Signal voltage switch failed, "
 			"power cycling card\n", mmc_hostname(host));
-		mmc_power_cycle(host, host->ocr);
+		mmc_power_cycle(host, ocr);
 	}
 
 	mmc_host_clk_release(host);

commit 4a065193c46a16f1ddf20622c7011c8f327e0478
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu Sep 12 14:36:53 2013 +0200

    mmc: core: Let mmc_power_up|cycle take ocr as parameter
    
    As a step to fixup the setup of the negotiated ocr mask, we need the
    mmc_power_up|cycle functions to take the ocr as a parameter.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 0292ad448b07..b66e7ab2ad43 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1479,7 +1479,7 @@ int mmc_set_signal_voltage(struct mmc_host *host, int signal_voltage)
 	if (err) {
 		pr_debug("%s: Signal voltage switch failed, "
 			"power cycling card\n", mmc_hostname(host));
-		mmc_power_cycle(host);
+		mmc_power_cycle(host, host->ocr);
 	}
 
 	mmc_host_clk_release(host);
@@ -1520,22 +1520,14 @@ void mmc_set_driver_type(struct mmc_host *host, unsigned int drv_type)
  * If a host does all the power sequencing itself, ignore the
  * initial MMC_POWER_UP stage.
  */
-void mmc_power_up(struct mmc_host *host)
+void mmc_power_up(struct mmc_host *host, u32 ocr)
 {
-	int bit;
-
 	if (host->ios.power_mode == MMC_POWER_ON)
 		return;
 
 	mmc_host_clk_hold(host);
 
-	/* If ocr is set, we use it */
-	if (host->ocr)
-		bit = ffs(host->ocr) - 1;
-	else
-		bit = fls(host->ocr_avail) - 1;
-
-	host->ios.vdd = bit;
+	host->ios.vdd = fls(ocr) - 1;
 	if (mmc_host_is_spi(host))
 		host->ios.chip_select = MMC_CS_HIGH;
 	else
@@ -1605,12 +1597,12 @@ void mmc_power_off(struct mmc_host *host)
 	mmc_host_clk_release(host);
 }
 
-void mmc_power_cycle(struct mmc_host *host)
+void mmc_power_cycle(struct mmc_host *host, u32 ocr)
 {
 	mmc_power_off(host);
 	/* Wait at least 1 ms according to SD spec */
 	mmc_delay(1);
-	mmc_power_up(host);
+	mmc_power_up(host, ocr);
 }
 
 /*
@@ -2309,7 +2301,7 @@ static int mmc_rescan_try_freq(struct mmc_host *host, unsigned freq)
 	pr_info("%s: %s: trying to init card at %u Hz\n",
 		mmc_hostname(host), __func__, host->f_init);
 #endif
-	mmc_power_up(host);
+	mmc_power_up(host, host->ocr_avail);
 
 	/*
 	 * Some eMMCs (with VCCQ always on) may not be reset after power up, so
@@ -2479,7 +2471,7 @@ void mmc_start_host(struct mmc_host *host)
 	if (host->caps2 & MMC_CAP2_NO_PRESCAN_POWERUP)
 		mmc_power_off(host);
 	else
-		mmc_power_up(host);
+		mmc_power_up(host, host->ocr_avail);
 	mmc_detect_change(host, 0);
 }
 
@@ -2558,7 +2550,7 @@ int mmc_power_restore_host(struct mmc_host *host)
 		return -EINVAL;
 	}
 
-	mmc_power_up(host);
+	mmc_power_up(host, host->ocr);
 	ret = host->bus_ops->power_restore(host);
 
 	mmc_bus_put(host);

commit 878e200bbb1fbde9f21582decab95b178e5a3b83
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Mon Sep 9 11:57:57 2013 +0200

    mmc: core: Do not poll for busy with status cmd for all switch cmds
    
    Some switch operations like poweroff notify, shall according to the
    spec not be followed by any other new commands. For these cases and
    when the host does'nt support MMC_CAP_WAIT_WHILE_BUSY, we must not
    send status commands to poll for busy detection. Instead wait for
    the stated timeout from the EXT_CSD before completing the request.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Cc: Jaehoon Chung <jh80.chung@samsung.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 006ead2fb701..0292ad448b07 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -301,7 +301,7 @@ void mmc_start_bkops(struct mmc_card *card, bool from_exception)
 	}
 
 	err = __mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
-			EXT_CSD_BKOPS_START, 1, timeout, use_busy_signal);
+			EXT_CSD_BKOPS_START, 1, timeout, use_busy_signal, true);
 	if (err) {
 		pr_warn("%s: Error %d starting bkops\n",
 			mmc_hostname(card->host), err);

commit b83e867026caedd6d67fccfbe6e9a621edd79b21
Author: Grant Grundler <grundler@chromium.org>
Date:   Thu Sep 19 18:21:36 2013 -0700

    mmc: core: remove dead function mmc_try_claim_host
    
    cscope says there are no callers for mmc_try_claim_host in the kernel.
    No reason to keep it.
    
    Signed-off-by: Grant Grundler <grundler@chromium.org>
    Acked-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index bf18b6bfce48..006ead2fb701 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -917,31 +917,6 @@ int __mmc_claim_host(struct mmc_host *host, atomic_t *abort)
 
 EXPORT_SYMBOL(__mmc_claim_host);
 
-/**
- *	mmc_try_claim_host - try exclusively to claim a host
- *	@host: mmc host to claim
- *
- *	Returns %1 if the host is claimed, %0 otherwise.
- */
-int mmc_try_claim_host(struct mmc_host *host)
-{
-	int claimed_host = 0;
-	unsigned long flags;
-
-	spin_lock_irqsave(&host->lock, flags);
-	if (!host->claimed || host->claimer == current) {
-		host->claimed = 1;
-		host->claimer = current;
-		host->claim_cnt += 1;
-		claimed_host = 1;
-	}
-	spin_unlock_irqrestore(&host->lock, flags);
-	if (host->ops->enable && claimed_host && host->claim_cnt == 1)
-		host->ops->enable(host);
-	return claimed_host;
-}
-EXPORT_SYMBOL(mmc_try_claim_host);
-
 /**
  *	mmc_release_host - release a host
  *	@host: mmc host to release

commit d0048f0b91ee35ab940ec6cbdfdd238c55b12a14
Merge: 7426d62871da 9d731e753971
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Sep 10 13:33:09 2013 -0700

    Merge tag 'mmc-updates-for-3.12-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/cjb/mmc
    
    Pull MMC updates from Chris Ball:
     "MMC highlights for 3.12:
    
      Core:
       - Support Allocation Units 8MB-64MB in SD3.0, previous max was 4MB.
       - The slot-gpio helper can now handle GPIO debouncing card-detect.
       - Read supported voltages from DT "voltage-ranges" property.
    
      Drivers:
       - dw_mmc: Add support for ARC architecture, and support exynos5420.
       - mmc_spi: Support CD/RO GPIOs.
       - sh_mobile_sdhi: Add compatibility for more Renesas SoCs.
       - sh_mmcif: Add DT support for DMA channels"
    
    * tag 'mmc-updates-for-3.12-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/cjb/mmc: (50 commits)
      Revert "mmc: tmio-mmc: Remove .set_pwr() callback from platform data"
      mmc: dw_mmc: Add support for ARC
      mmc: sdhci-s3c: initialize host->quirks2 for using quirks2
      mmc: sdhci-s3c: fix the wrong register value, when clock is disabled
      mmc: esdhc: add support to get voltage from device-tree
      mmc: sdhci: get voltage from sdhc host
      mmc: core: parse voltage from device-tree
      mmc: omap_hsmmc: use the generic config for omap2plus devices
      mmc: omap_hsmmc: clear status flags before starting a new command
      mmc: dw_mmc: exynos: Add a new compatible string for exynos5420
      mmc: sh_mmcif: revision-specific CLK_CTRL2 handling
      mmc: sh_mmcif: revision-specific Command Completion Signal handling
      mmc: sh_mmcif: add support for Device Tree DMA bindings
      mmc: sh_mmcif: move header include from header into .c
      mmc: SDHI: add DT compatibility strings for further SoCs
      mmc: dw_mmc-pci: enable bus-mastering mode
      mmc: dw_mmc-pci: get resources from a proper BAR
      mmc: tmio-mmc: Remove .set_pwr() callback from platform data
      mmc: tmio-mmc: Remove .get_cd() callback from platform data
      mmc: sh_mobile_sdhi: Remove .set_pwr() callback from platform data
      ...

commit 6e9e318b304fd7373a0754805a76a02ddbc69a41
Author: Haijun Zhang <Haijun.Zhang@freescale.com>
Date:   Mon Aug 26 09:19:22 2013 +0800

    mmc: core: parse voltage from device-tree
    
    Add function to support getting voltage from device-tree.
    If voltage-range is specified in device-tree node, this function
    will parse it and return the available voltage mask.
    
    Signed-off-by: Haijun Zhang <haijun.zhang@freescale.com>
    Acked-by: Anton Vorontsov <anton@enomsg.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 49a5bca418bd..b9b9fb6e4496 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -27,6 +27,7 @@
 #include <linux/fault-inject.h>
 #include <linux/random.h>
 #include <linux/slab.h>
+#include <linux/of.h>
 
 #include <linux/mmc/card.h>
 #include <linux/mmc/host.h>
@@ -1196,6 +1197,49 @@ u32 mmc_vddrange_to_ocrmask(int vdd_min, int vdd_max)
 }
 EXPORT_SYMBOL(mmc_vddrange_to_ocrmask);
 
+#ifdef CONFIG_OF
+
+/**
+ * mmc_of_parse_voltage - return mask of supported voltages
+ * @np: The device node need to be parsed.
+ * @mask: mask of voltages available for MMC/SD/SDIO
+ *
+ * 1. Return zero on success.
+ * 2. Return negative errno: voltage-range is invalid.
+ */
+int mmc_of_parse_voltage(struct device_node *np, u32 *mask)
+{
+	const u32 *voltage_ranges;
+	int num_ranges, i;
+
+	voltage_ranges = of_get_property(np, "voltage-ranges", &num_ranges);
+	num_ranges = num_ranges / sizeof(*voltage_ranges) / 2;
+	if (!voltage_ranges || !num_ranges) {
+		pr_info("%s: voltage-ranges unspecified\n", np->full_name);
+		return -EINVAL;
+	}
+
+	for (i = 0; i < num_ranges; i++) {
+		const int j = i * 2;
+		u32 ocr_mask;
+
+		ocr_mask = mmc_vddrange_to_ocrmask(
+				be32_to_cpu(voltage_ranges[j]),
+				be32_to_cpu(voltage_ranges[j + 1]));
+		if (!ocr_mask) {
+			pr_err("%s: voltage-range #%d is invalid\n",
+				np->full_name, i);
+			return -EINVAL;
+		}
+		*mask |= ocr_mask;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(mmc_of_parse_voltage);
+
+#endif /* CONFIG_OF */
+
 #ifdef CONFIG_REGULATOR
 
 /**

commit bc35d5ed5d14e63a4d6018098a129196ba4c44ae
Author: Mark Brown <broonie@linaro.org>
Date:   Mon Jul 29 21:58:01 2013 +0100

    mmc: core: Indicate that vmmcq may be absent
    
    Use regulator_get_optional() to tell the core that requests for the vmmcq
    regulator can fail in a real system.
    
    Signed-off-by: Mark Brown <broonie@linaro.org>
    Acked-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 49a5bca418bd..5d088551196b 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1313,7 +1313,7 @@ int mmc_regulator_get_supply(struct mmc_host *mmc)
 
 	supply = devm_regulator_get(dev, "vmmc");
 	mmc->supply.vmmc = supply;
-	mmc->supply.vqmmc = devm_regulator_get(dev, "vqmmc");
+	mmc->supply.vqmmc = devm_regulator_get_optional(dev, "vqmmc");
 
 	if (IS_ERR(supply))
 		return PTR_ERR(supply);

commit 986892ca78eeddd9d6b629050fea432979ddd321
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Mon Jun 10 17:03:39 2013 +0200

    mmc: core: Initiate suspend|resume from mmc bus instead of mmc host
    
    The host should be responsible to suspend|resume the host and not the
    card. This patch changes this behaviour, by moving the responsiblity
    to the mmc bus instead which already holds the card device.
    
    The exported functions mmc_suspend|resume_host are now to be considered
    as depcrecated. Once all host drivers moves away from using them, we
    can remove them. As of now, a successful error code is always returned.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Tested-by: Jaehoon Chung <jh80.chung@samsung.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index da3b9078ea65..49a5bca418bd 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2619,16 +2619,8 @@ EXPORT_SYMBOL(mmc_cache_ctrl);
  */
 int mmc_suspend_host(struct mmc_host *host)
 {
-	int err = 0;
-
-	mmc_bus_get(host);
-	if (host->bus_ops && !host->bus_dead) {
-		if (host->bus_ops->suspend)
-			err = host->bus_ops->suspend(host);
-	}
-	mmc_bus_put(host);
-
-	return err;
+	/* This function is deprecated */
+	return 0;
 }
 EXPORT_SYMBOL(mmc_suspend_host);
 
@@ -2638,19 +2630,7 @@ EXPORT_SYMBOL(mmc_suspend_host);
  */
 int mmc_resume_host(struct mmc_host *host)
 {
-	int err;
-
-	mmc_bus_get(host);
-	if (host->bus_ops && !host->bus_dead) {
-		BUG_ON(!host->bus_ops->resume);
-		err = host->bus_ops->resume(host);
-		if (err)
-			pr_warning("%s: error %d during resume "
-					    "(card was removed?)\n",
-					    mmc_hostname(host), err);
-	}
-	mmc_bus_put(host);
-
+	/* This function is deprecated */
 	return 0;
 }
 EXPORT_SYMBOL(mmc_resume_host);

commit 74590263384e5d4601de7f0ee2790477578829ea
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Mon Jun 10 17:03:38 2013 +0200

    mmc: core: Push common suspend|resume code into each bus_ops
    
    By moving code from the mmc_suspend|resume_host down into each
    .suspend|resume bus_ops callback, we get a more flexible solution.
    
    Some nice side effects are that we get a better understanding of each
    bus_ops suspend|resume sequence and the common code don't have to take
    care of specific corner cases, especially for the SDIO case.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Tested-by: Jaehoon Chung <jh80.chung@samsung.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 7a8a42d3a039..da3b9078ea65 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2621,9 +2621,6 @@ int mmc_suspend_host(struct mmc_host *host)
 {
 	int err = 0;
 
-	cancel_delayed_work(&host->detect);
-	mmc_flush_scheduled_work();
-
 	mmc_bus_get(host);
 	if (host->bus_ops && !host->bus_dead) {
 		if (host->bus_ops->suspend)
@@ -2631,9 +2628,6 @@ int mmc_suspend_host(struct mmc_host *host)
 	}
 	mmc_bus_put(host);
 
-	if (!err && !mmc_card_keep_power(host))
-		mmc_power_off(host);
-
 	return err;
 }
 EXPORT_SYMBOL(mmc_suspend_host);
@@ -2644,39 +2638,20 @@ EXPORT_SYMBOL(mmc_suspend_host);
  */
 int mmc_resume_host(struct mmc_host *host)
 {
-	int err = 0;
+	int err;
 
 	mmc_bus_get(host);
 	if (host->bus_ops && !host->bus_dead) {
-		if (!mmc_card_keep_power(host)) {
-			mmc_power_up(host);
-			mmc_select_voltage(host, host->ocr);
-			/*
-			 * Tell runtime PM core we just powered up the card,
-			 * since it still believes the card is powered off.
-			 * Note that currently runtime PM is only enabled
-			 * for SDIO cards that are MMC_CAP_POWER_OFF_CARD
-			 */
-			if (mmc_card_sdio(host->card) &&
-			    (host->caps & MMC_CAP_POWER_OFF_CARD)) {
-				pm_runtime_disable(&host->card->dev);
-				pm_runtime_set_active(&host->card->dev);
-				pm_runtime_enable(&host->card->dev);
-			}
-		}
 		BUG_ON(!host->bus_ops->resume);
 		err = host->bus_ops->resume(host);
-		if (err) {
+		if (err)
 			pr_warning("%s: error %d during resume "
 					    "(card was removed?)\n",
 					    mmc_hostname(host), err);
-			err = 0;
-		}
 	}
-	host->pm_flags &= ~MMC_PM_KEEP_POWER;
 	mmc_bus_put(host);
 
-	return err;
+	return 0;
 }
 EXPORT_SYMBOL(mmc_resume_host);
 

commit 810caddba42a54fe5db4e2664757a9a334ba359c
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Mon Jun 10 17:03:37 2013 +0200

    mmc: core: Validate suspend prerequisites for SDIO at SUSPEND_PREPARE
    
    This patch moves the validation for all the suspend prerequisites to be
    done at SUSPEND_PREPARE notification. Previously in the SDIO case parts
    of the validation was done from mmc_suspend_host.
    
    This patch invents a new pre_suspend bus_ops callback and implements it
    for SDIO. Returning an error code from it, will mean at SUSPEND_PREPARE
    notification, the card will be removed before proceeding with the
    suspend sequence.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Tested-by: Jaehoon Chung <jh80.chung@samsung.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index d2ee2829b313..7a8a42d3a039 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2628,22 +2628,6 @@ int mmc_suspend_host(struct mmc_host *host)
 	if (host->bus_ops && !host->bus_dead) {
 		if (host->bus_ops->suspend)
 			err = host->bus_ops->suspend(host);
-
-		if (err == -ENOSYS || !host->bus_ops->resume) {
-			/*
-			 * We simply "remove" the card in this case.
-			 * It will be redetected on resume.  (Calling
-			 * bus_ops->remove() with a claimed host can
-			 * deadlock.)
-			 */
-			host->bus_ops->remove(host);
-			mmc_claim_host(host);
-			mmc_detach_bus(host);
-			mmc_power_off(host);
-			mmc_release_host(host);
-			host->pm_flags = 0;
-			err = 0;
-		}
 	}
 	mmc_bus_put(host);
 
@@ -2706,6 +2690,7 @@ int mmc_pm_notify(struct notifier_block *notify_block,
 	struct mmc_host *host = container_of(
 		notify_block, struct mmc_host, pm_notify);
 	unsigned long flags;
+	int err = 0;
 
 	switch (mode) {
 	case PM_HIBERNATION_PREPARE:
@@ -2715,7 +2700,13 @@ int mmc_pm_notify(struct notifier_block *notify_block,
 		spin_unlock_irqrestore(&host->lock, flags);
 		cancel_delayed_work_sync(&host->detect);
 
-		if (!host->bus_ops || host->bus_ops->suspend)
+		if (!host->bus_ops)
+			break;
+
+		/* Validate prerequisites for suspend */
+		if (host->bus_ops->pre_suspend)
+			err = host->bus_ops->pre_suspend(host);
+		if (!err && host->bus_ops->suspend)
 			break;
 
 		/* Calling bus_ops->remove() with a claimed host can deadlock */

commit 58a8a4a1a5da4694a3a069de5e0a8c15995e7b5f
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Mon Jun 10 17:03:36 2013 +0200

    mmc: core: Remove unnecessary check for the remove callback
    
    For every bus_ops type the .remove callback always exist, thus there
    are no need to check the existence of it, before we decide to call it.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Tested-by: Jaehoon Chung <jh80.chung@samsung.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index e9a104b9e4d3..d2ee2829b313 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2483,9 +2483,7 @@ void mmc_stop_host(struct mmc_host *host)
 	mmc_bus_get(host);
 	if (host->bus_ops && !host->bus_dead) {
 		/* Calling bus_ops->remove() with a claimed host can deadlock */
-		if (host->bus_ops->remove)
-			host->bus_ops->remove(host);
-
+		host->bus_ops->remove(host);
 		mmc_claim_host(host);
 		mmc_detach_bus(host);
 		mmc_power_off(host);
@@ -2638,8 +2636,7 @@ int mmc_suspend_host(struct mmc_host *host)
 			 * bus_ops->remove() with a claimed host can
 			 * deadlock.)
 			 */
-			if (host->bus_ops->remove)
-				host->bus_ops->remove(host);
+			host->bus_ops->remove(host);
 			mmc_claim_host(host);
 			mmc_detach_bus(host);
 			mmc_power_off(host);
@@ -2722,9 +2719,7 @@ int mmc_pm_notify(struct notifier_block *notify_block,
 			break;
 
 		/* Calling bus_ops->remove() with a claimed host can deadlock */
-		if (host->bus_ops->remove)
-			host->bus_ops->remove(host);
-
+		host->bus_ops->remove(host);
 		mmc_claim_host(host);
 		mmc_detach_bus(host);
 		mmc_power_off(host);

commit 07a682160866e302d696f5c76d74024d575fb79d
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri Apr 19 15:12:11 2013 +0200

    mmc: core: Restructure and simplify code for mmc sleep|awake
    
    The mmc_card_sleep|awake APIs are not being used since the support is
    already properly encapsulated within the suspend sequence. Sleep|awake
    command is also specific for eMMC.
    
    We remove the sleep|awake bus_ops, the mmc_card_sleep|awake APIs and
    move the code into the mmc specific core instead. This also includes
    the mmc ops function, mmc_sleepawake. All releated functions have then
    become static and we have got far less code to maintain.
    
    Additionally this patch also simplifies the code from mmc_sleepawake,
    since it is only used to put the card to sleep and not awake.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 0f86144b0c51..e9a104b9e4d3 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2550,52 +2550,6 @@ int mmc_power_restore_host(struct mmc_host *host)
 }
 EXPORT_SYMBOL(mmc_power_restore_host);
 
-int mmc_card_awake(struct mmc_host *host)
-{
-	int err = -ENOSYS;
-
-	if (host->caps2 & MMC_CAP2_NO_SLEEP_CMD)
-		return 0;
-
-	mmc_bus_get(host);
-
-	if (host->bus_ops && !host->bus_dead && host->bus_ops->awake)
-		err = host->bus_ops->awake(host);
-
-	mmc_bus_put(host);
-
-	return err;
-}
-EXPORT_SYMBOL(mmc_card_awake);
-
-int mmc_card_sleep(struct mmc_host *host)
-{
-	int err = -ENOSYS;
-
-	if (host->caps2 & MMC_CAP2_NO_SLEEP_CMD)
-		return 0;
-
-	mmc_bus_get(host);
-
-	if (host->bus_ops && !host->bus_dead && host->bus_ops->sleep)
-		err = host->bus_ops->sleep(host);
-
-	mmc_bus_put(host);
-
-	return err;
-}
-EXPORT_SYMBOL(mmc_card_sleep);
-
-int mmc_card_can_sleep(struct mmc_host *host)
-{
-	struct mmc_card *card = host->card;
-
-	if (card && mmc_card_mmc(card) && card->ext_csd.rev >= 3)
-		return 1;
-	return 0;
-}
-EXPORT_SYMBOL(mmc_card_can_sleep);
-
 /*
  * Flush the cache to the non-volatile storage.
  */

commit e94cfef698aae6b209d8918dd319312e4b02118d
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu May 2 14:02:38 2013 +0200

    mmc: block: Enable runtime pm for mmc blkdevice
    
    Once the mmc blkdevice is being probed, runtime pm will be enabled.
    By using runtime autosuspend, the power save operations can be done
    when request inactivity occurs for a certain time. Right now the
    selected timeout value is set to 3 s. Obviously this value will likely
    need to be configurable somehow since it needs to be trimmed depending
    on the power save algorithm.
    
    For SD-combo cards, we are still leaving the enablement of runtime PM
    to the SDIO init sequence since it depends on the capabilities of the
    SDIO func driver.
    
    Moreover, when the blk device is being suspended, we make sure the device
    will be runtime resumed. The reason for doing this is that we want the
    host suspend sequence to be unaware of any runtime power save operations
    done for the card in this phase. Thus it can just handle the suspend as
    the card is fully powered from a runtime perspective.
    
    Finally, this patch prepares to make it possible to move BKOPS handling
    into the runtime callbacks for the mmc bus_ops. Thus IDLE BKOPS can be
    accomplished.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index dc0cb5929c64..0f86144b0c51 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -970,6 +970,29 @@ void mmc_release_host(struct mmc_host *host)
 }
 EXPORT_SYMBOL(mmc_release_host);
 
+/*
+ * This is a helper function, which fetches a runtime pm reference for the
+ * card device and also claims the host.
+ */
+void mmc_get_card(struct mmc_card *card)
+{
+	pm_runtime_get_sync(&card->dev);
+	mmc_claim_host(card->host);
+}
+EXPORT_SYMBOL(mmc_get_card);
+
+/*
+ * This is a helper function, which releases the host and drops the runtime
+ * pm reference for the card device.
+ */
+void mmc_put_card(struct mmc_card *card)
+{
+	mmc_release_host(card->host);
+	pm_runtime_mark_last_busy(&card->dev);
+	pm_runtime_put_autosuspend(&card->dev);
+}
+EXPORT_SYMBOL(mmc_put_card);
+
 /*
  * Internal function that does the actual ios call to the host driver,
  * optionally printing some debug output.

commit 12d01d0b813b93e7bde1b5f468b5c85aa8b33590
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu May 2 14:02:37 2013 +0200

    mmc: core: Add bus_ops for runtime pm callbacks
    
    SDIO is the only protocol that uses runtime pm for the card device
    right now. To provide the option for sd and mmc to use runtime pm as
    well the bus_ops callback are extended with two new functions. One for
    runtime_suspend and one for runtime_resume.
    
    This patch will also implement the callbacks for SDIO to make sure
    existing functionality is maintained. It also prepares to move
    away from using the mmc_power_restore_host API, since it is not
    needed when using runtime PM.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index d856871ed6cb..dc0cb5929c64 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1478,7 +1478,7 @@ void mmc_set_driver_type(struct mmc_host *host, unsigned int drv_type)
  * If a host does all the power sequencing itself, ignore the
  * initial MMC_POWER_UP stage.
  */
-static void mmc_power_up(struct mmc_host *host)
+void mmc_power_up(struct mmc_host *host)
 {
 	int bit;
 

commit 39b9431b0f371294dd2d1a492cf77f2f17390a1f
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu May 2 14:02:36 2013 +0200

    mmc: core: Stop bkops for eMMC only from mmc suspend
    
    Move mmc suspend specific operations to be executed from the .suspend
    callback in the mmc bus_ops. This simplifies the mmc_suspend_host
    function which is supposed to handle nothing but common suspend tasks.
    
    Since eMMC can be considered non-removable there are no need to check
    for ongoing bkops at PM_SUSPEND_PREPARE notification so remove it.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 48b9fec34737..d856871ed6cb 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2651,14 +2651,8 @@ int mmc_suspend_host(struct mmc_host *host)
 
 	mmc_bus_get(host);
 	if (host->bus_ops && !host->bus_dead) {
-		if (host->bus_ops->suspend) {
-			if (mmc_card_doing_bkops(host->card)) {
-				err = mmc_stop_bkops(host->card);
-				if (err)
-					goto out;
-			}
+		if (host->bus_ops->suspend)
 			err = host->bus_ops->suspend(host);
-		}
 
 		if (err == -ENOSYS || !host->bus_ops->resume) {
 			/*
@@ -2682,10 +2676,8 @@ int mmc_suspend_host(struct mmc_host *host)
 	if (!err && !mmc_card_keep_power(host))
 		mmc_power_off(host);
 
-out:
 	return err;
 }
-
 EXPORT_SYMBOL(mmc_suspend_host);
 
 /**
@@ -2740,22 +2732,10 @@ int mmc_pm_notify(struct notifier_block *notify_block,
 	struct mmc_host *host = container_of(
 		notify_block, struct mmc_host, pm_notify);
 	unsigned long flags;
-	int err = 0;
 
 	switch (mode) {
 	case PM_HIBERNATION_PREPARE:
 	case PM_SUSPEND_PREPARE:
-		if (host->card && mmc_card_mmc(host->card) &&
-		    mmc_card_doing_bkops(host->card)) {
-			err = mmc_stop_bkops(host->card);
-			if (err) {
-				pr_err("%s: didn't stop bkops\n",
-					mmc_hostname(host));
-				return err;
-			}
-			mmc_card_clr_doing_bkops(host->card);
-		}
-
 		spin_lock_irqsave(&host->lock, flags);
 		host->rescan_disable = 1;
 		spin_unlock_irqrestore(&host->lock, flags);

commit 775a9362b5d7e006ff6bbec5cb9c9c9d5a751696
Author: Maya Erez <merez@codeaurora.org>
Date:   Thu Apr 18 15:41:55 2013 +0300

    mmc: card: Adding support for sanitize in eMMC 4.5
    
    The sanitize support is added as a user-app ioctl call, and
    was removed from the block-device request, since its purpose is
    to be invoked not via File-System but by a user.
    
    This feature deletes the unmap memory region of the eMMC card,
    by writing to a specific register in the EXT_CSD.
    
    unmap region is the memory region that was previously deleted
    (by erase, trim or discard operation).
    
    In order to avoid timeout when sanitizing large-scale cards,
    the timeout for sanitize operation is 240 seconds.
    
    Signed-off-by: Yaniv Gardi <ygardi@codeaurora.org>
    Signed-off-by: Maya Erez <merez@codeaurora.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 6e4d04df37e0..48b9fec34737 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -402,6 +402,7 @@ static int mmc_wait_for_data_req_done(struct mmc_host *host,
 			context_info->is_done_rcv = false;
 			context_info->is_new_req = false;
 			cmd = mrq->cmd;
+
 			if (!cmd->error || !cmd->retries ||
 			    mmc_card_removed(host->card)) {
 				err = host->areq->err_check(host->card,
@@ -436,6 +437,24 @@ static void mmc_wait_for_req_done(struct mmc_host *host,
 		wait_for_completion(&mrq->completion);
 
 		cmd = mrq->cmd;
+
+		/*
+		 * If host has timed out waiting for the sanitize
+		 * to complete, card might be still in programming state
+		 * so let's try to bring the card out of programming
+		 * state.
+		 */
+		if (cmd->sanitize_busy && cmd->error == -ETIMEDOUT) {
+			if (!mmc_interrupt_hpi(host->card)) {
+				pr_warning("%s: %s: Interrupted sanitize\n",
+					   mmc_hostname(host), __func__);
+				cmd->error = 0;
+				break;
+			} else {
+				pr_err("%s: %s: Failed to interrupt sanitize\n",
+				       mmc_hostname(host), __func__);
+			}
+		}
 		if (!cmd->error || !cmd->retries ||
 		    mmc_card_removed(host->card))
 			break;

commit b689167984bc14ed06c8bcff52ef5eb1fd9cf83b
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu Apr 18 11:02:07 2013 +0200

    mmc: core: Re-use code for MMC_CAP2_DETECT_ON_ERR in polling mode
    
    Previously the MMC_CAP2_DETECT_ON_ERR was invented for detecting
    slow card removal. In was never a realy good solution and a proper
    fix has been merged using gpio debouncing instead. We remove this
    cap in this patch.
    
    Although when using polling card detect mode, the code invented for
    MMC_CAP2_DETECT_ON_ERR is re-used to complete card removal in an
    earlier phase. There are no need waiting for the polling timeout to
    elapse in this case.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Kevin Liu <kliu5@marvell.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index c40396f23202..6e4d04df37e0 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2325,14 +2325,13 @@ int mmc_detect_card_removed(struct mmc_host *host)
 	 * The card will be considered unchanged unless we have been asked to
 	 * detect a change or host requires polling to provide card detection.
 	 */
-	if (!host->detect_change && !(host->caps & MMC_CAP_NEEDS_POLL) &&
-	    !(host->caps2 & MMC_CAP2_DETECT_ON_ERR))
+	if (!host->detect_change && !(host->caps & MMC_CAP_NEEDS_POLL))
 		return ret;
 
 	host->detect_change = 0;
 	if (!ret) {
 		ret = _mmc_detect_card_removed(host);
-		if (ret && (host->caps2 & MMC_CAP2_DETECT_ON_ERR)) {
+		if (ret && (host->caps & MMC_CAP_NEEDS_POLL)) {
 			/*
 			 * Schedule a detect work as soon as possible to let a
 			 * rescan handle the card removal.

commit 173192958d06b8d1eb44f56d74373052ad6a9a60
Merge: e72a5d1ceb1c e4404fab2e0b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat May 4 13:45:17 2013 -0700

    Merge tag 'mmc-updates-for-3.10-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/cjb/mmc
    
    Pull MMC update from Chris Ball:
     "MMC highlights for 3.10:
    
      Core:
       - Introduce MMC_CAP2_NO_PRESCAN_POWERUP to allow skipping
         mmc_power_up() at boot/initialization time if it's already
         happened, for performance (faster boot time) reasons.
       - Fix a bit width test failure that resulted in old eMMC cards being
         put into 1-bit mode when 4-bit mode was available.
       - Expose fwrev/hwrev for MMCv4 parts.
       - Improve card removal logic in the case where the card's removed
         slowly; we were missing card removal events if the card retained
         contact with the slot pads for long enough to reply to a CMD13
         while being removed.
    
      Drivers:
       - davinci_mmc: Support using PIO instead of DMA.
       - dw_mmc: Add support for Exynos4412.
       - mxcmmc: DT support, use slot-gpio API.
       - mxs-mmc: Add broken-cd/cd-inverted/non-removable DT property
         support.
       - sdhci-sirf: New sdhci-pltfm driver for CSR SiRF SoCs:
           SiRFprimaII: unicore ARM Cortex-A9
           SiRFatlas6: unicore ARM Cortex-A9
           SiRFmarco: dual core ARM Cortex-A9 SMP
       - sdhci-tegra: Add support for Tegra114 platforms, use
         mmc_of_parse()"
    
    * tag 'mmc-updates-for-3.10-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/cjb/mmc: (66 commits)
      mmc: sdhci-tegra: fix MODULE_DEVICE_TABLE
      mmc: core: fix init controller performance regression, updated patch
      mmc: mxcmmc: enable DMA support on mpc512x
      mmc: mxcmmc: constify mxcmci_devtype
      mmc: mxcmmc: use slot-gpio API for write-protect detection
      mmc: mxcmmc: add mpc512x SDHC support
      mmc: mxcmmc: fix race conditions for host->req and host->data access
      mmc: mxcmmc: DT support
      mmc: dw_mmc: let device core setup the default pin configuration
      mmc: mxs-mmc: add broken-cd property
      mmc: mxs-mmc: add non-removable property
      mmc: mxs-mmc: add cd-inverted property
      mmc: core: call pm_runtime_put_noidle in pm_runtime_get_sync failed case
      mmc: mxcmmc: Fix bug when card is present during boot
      mmc: core: fix performance regression initializing MMC host controllers
      Revert "mmc: core: wait while adding MMC host to ensure root mounts successfully"
      mmc: atmel-mci: pio hang on block errors
      mmc: core: Fix bit width test failing on old eMMC cards
      mmc: dw_mmc: Use pr_info instead of printk
      mmc: dw_mmc: Check return value of regulator_enable
      ...

commit 2e744fcb90599819b43415e2e6d6a6a550248645
Author: Akinobu Mita <akinobu.mita@gmail.com>
Date:   Mon Apr 29 16:21:31 2013 -0700

    mmc: rename random32() to prandom_u32()
    
    Use preferable function name which implies using a pseudo-random
    number generator.
    
    Signed-off-by: Akinobu Mita <akinobu.mita@gmail.com>
    Cc: Chris Ball <cjb@laptop.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 08a3cf2a7610..9290bb51a06a 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -120,8 +120,8 @@ static void mmc_should_fail_request(struct mmc_host *host,
 	    !should_fail(&host->fail_mmc_request, data->blksz * data->blocks))
 		return;
 
-	data->error = data_errors[random32() % ARRAY_SIZE(data_errors)];
-	data->bytes_xfered = (random32() % (data->bytes_xfered >> 9)) << 9;
+	data->error = data_errors[prandom_u32() % ARRAY_SIZE(data_errors)];
+	data->bytes_xfered = (prandom_u32() % (data->bytes_xfered >> 9)) << 9;
 }
 
 #else /* CONFIG_FAIL_MMC_REQUEST */

commit a08b17be8b984a7c51cd5a480cd977363df353f9
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Mon Apr 15 11:27:25 2013 -0400

    mmc: core: fix init controller performance regression, updated patch
    
    Add MMC_CAP2_NO_PRESCAN_POWERUP to sdhci-pci.c also, use mmc_power_off()
    for MMC_CAP2_NO_PRESCAN_POWERUP.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    [cjb: previously applied v1 of this patch instead of v4]
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index c1893c9c3c31..65f9ca7a56ad 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2416,7 +2416,9 @@ void mmc_start_host(struct mmc_host *host)
 {
 	host->f_init = max(freqs[0], host->f_min);
 	host->rescan_disable = 0;
-	if (!(host->caps2 & MMC_CAP2_NO_PRESCAN_POWERUP))
+	if (host->caps2 & MMC_CAP2_NO_PRESCAN_POWERUP)
+		mmc_power_off(host);
+	else
 		mmc_power_up(host);
 	mmc_detect_change(host, 0);
 }

commit 0d3e3350d5871c53464be4c92d57198744247005
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Thu Apr 4 16:41:06 2013 +0300

    mmc: core: fix performance regression initializing MMC host controllers
    
    Commit fa5501890d8974301042e0202d342a6cbe8609f4 introduced a performance
    regression by adding mmc_power_up() to mmc_start_host().  mmc_power_up()
    is not necessary to host controller initialization, it is part of card
    initialization and is performed anyway asynchronously.
    
    This patch allows a driver to leave the power up in asynchronous code
    (as it was before).
    
    On my current target platform this reduces driver initialization from:
    
    [    1.313220] initcall sdhci_acpi_driver_init+0x0/0x12 returned 0 after 102008 usecs
    
    to this:
    
    [    1.217209] initcall sdhci_acpi_driver_init+0x0/0x12 returned 0 after 8331 usecs
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Acked-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 3bf1c462eded..c1893c9c3c31 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2416,7 +2416,8 @@ void mmc_start_host(struct mmc_host *host)
 {
 	host->f_init = max(freqs[0], host->f_min);
 	host->rescan_disable = 0;
-	mmc_power_up(host);
+	if (!(host->caps2 & MMC_CAP2_NO_PRESCAN_POWERUP))
+		mmc_power_up(host);
 	mmc_detect_change(host, 0);
 }
 

commit f9a94e0a3f18ae4c0245d4a16d0ee20e93fd7bad
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Thu Apr 4 16:41:05 2013 +0300

    Revert "mmc: core: wait while adding MMC host to ensure root mounts successfully"
    
    This reverts commit 3500ed90b26a9935b943b5e2e4cd3226600d6b58.
    
    The reverted patch caused a significant performance regression when
    booting with the root file system on eMMC.
    
    Before the patch:
    
    [    1.625623] VFS: Mounted root (ext4 filesystem) readonly on device 179:2.
    
    After the patch:
    
    [    1.935851] VFS: Mounted root (ext4 filesystem) readonly on device 179:2.
    
    That was an addition of 310 ms which is a 19% performance degradation.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index ad7decc3340a..3bf1c462eded 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2418,7 +2418,6 @@ void mmc_start_host(struct mmc_host *host)
 	host->rescan_disable = 0;
 	mmc_power_up(host);
 	mmc_detect_change(host, 0);
-	mmc_flush_scheduled_work();
 }
 
 void mmc_stop_host(struct mmc_host *host)

commit 3500ed90b26a9935b943b5e2e4cd3226600d6b58
Author: Sergey Yanovich <ynvich@gmail.com>
Date:   Thu Mar 14 05:23:13 2013 +0400

    mmc: core: wait while adding MMC host to ensure root mounts successfully
    
    MMC hosts are added asynchronously. We need to wait until detect returns to
    avoid failed root filesystem mounts.
    
    VFS: Cannot open root device "mmcblk0p1" or unknown-block(0,0): error -6
    Please append a correct "root=" boot option; here are the available partitions:
    mmc0: host does not support reading read-only switch. assuming write-enable.
    1f00             256 mtdblock0  (driver?)
    1f01             256 mtdblock1  (driver?)
    1f02            2560 mtdblock2 mmc0: new SDHC card at address b368
     (driver?)
    1f03           29696 mtdblock3  (driver?)
    1f04           16384 mtdblock4 mmcblk0: mmc0:b368 USD   3.72 GiB
     (driver?)
     mmcblk0: p1
    b300         3910656 mmcblk0  driver: mmcblk
      b301         3906560 mmcblk0p1 00000000-01
    Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0)
    
    Signed-off-by: Sergey Yanovich <ynvich@gmail.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 3bf1c462eded..ad7decc3340a 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2418,6 +2418,7 @@ void mmc_start_host(struct mmc_host *host)
 	host->rescan_disable = 0;
 	mmc_power_up(host);
 	mmc_detect_change(host, 0);
+	mmc_flush_scheduled_work();
 }
 
 void mmc_stop_host(struct mmc_host *host)

commit 1450734ec61cda7bbb77afc8cb412b9d64c62d9a
Author: Kevin Liu <kliu5@marvell.com>
Date:   Thu Feb 28 15:29:29 2013 +0800

    mmc: core: enhance card removal judgement for slow removal
    
    Function _mmc_detect_card_removed will be called to know whether
    the card is still present when host->bus_ops->detect is called.
    In current code, the return value of this function generally only
    depend on the result of sending cmd13 to card, which may not safe
    for card with detection support like slot gpio detection.
    Because the communication status between host and card may out of
    sync with the detect status if remove the card slowly or hands shake
    during the process. The direct reason is the async between card
    detect switch and card/slot pad contaction in hardware, which is
    defined by spec.
    
    The spec define card insert/remove sequence as below (both standard size
    SD card and MicroSD card have the same sequence):
    "Part 1 Standard Size SD Card Mechanical Addendum Ver4.00 Final,
    Appendix C: Card Detection Switch" (Take normally open type as example)
    a)SD card insertion sequence:
      The card detection switch should be turned on after all SD card
      contact pads are connected to the host connector contact pads.
    b)SD removal sequence:
      The card detection switch should be turned off when the SD card
      is just going to be removed and before any SD card contact pad is
      disconnected from the host connector contact pad.
    
    Below is the sequence when this issue occur (Take slot gpio detection
    as example and remove the card slowly during the process):
    1. gpio level changed and card detect interrupt triggered.
    2. mmc_rescan was launched.
    3. the card pads were still contacted with the slot pads because of slow
       removal. So _mmc_detect_card_removed and mmc_rescan think card was
       still present (cmd13 succeed).
    4. card pads were discontacted from the card slot pads.
    So the card was actually removed finally but the card removal event
    has been missed by system.
    The interval length between step 1 and step 4 depends on the
    card removal speed. If it's longer than the detect work schedule
    delay which is 200ms, this issue will likely happen.
    
    This patch add the card detect status check in function
    _mmc_detect_card_removed if cmd13 check succeed and host->ops->get_cd
    provided. If get_cd detect no card present then schedule another detect
    work 200ms later.
    
    Signed-off-by: Kevin Liu <kliu5@marvell.com>
    Tested-by: Johan Rudholm <johan.rudholm@stericsson.com>
    Reviewed-by: Philip Rakity <prakity@nvidia.com>
    Acked-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 08a3cf2a7610..3bf1c462eded 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2289,6 +2289,19 @@ int _mmc_detect_card_removed(struct mmc_host *host)
 		return 1;
 
 	ret = host->bus_ops->alive(host);
+
+	/*
+	 * Card detect status and alive check may be out of sync if card is
+	 * removed slowly, when card detect switch changes while card/slot
+	 * pads are still contacted in hardware (refer to "SD Card Mechanical
+	 * Addendum, Appendix C: Card Detection Switch"). So reschedule a
+	 * detect work 200ms later for this case.
+	 */
+	if (!ret && host->ops->get_cd && !host->ops->get_cd(host)) {
+		mmc_detect_change(host, msecs_to_jiffies(200));
+		pr_debug("%s: card removed too slowly\n", mmc_hostname(host));
+	}
+
 	if (ret) {
 		mmc_card_set_removed(host->card);
 		pr_debug("%s: card remove detected\n", mmc_hostname(host));

commit 5f56a8e6efb695b6ea7b56e8a33d25ec622e77bd
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Tue Dec 4 15:01:02 2012 +0100

    mmc: use regulator_can_change_voltage() instead of regulator_count_voltages
    
    mmc_regulator_set_ocr() depends on the ability of regulator to change the
    voltage value. When regulator cannot change its voltage output, some code
    is skipped to avoid reporting false errors on some boards, which use MMC
    hosts with fixed regulators (e.g. Samsung Goni and UniversalC210 boards).
    
    This patch replaces a hacky workaround based on regulator_count_voltages()
    value with the correct call to recently introduced
    regulator_can_change_voltage() function in regulators core.
    
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 6f3bc1a97ba8..08a3cf2a7610 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1235,7 +1235,7 @@ int mmc_regulator_set_ocr(struct mmc_host *mmc,
 		 */
 		voltage = regulator_get_voltage(supply);
 
-		if (regulator_count_voltages(supply) == 1)
+		if (!regulator_can_change_voltage(supply))
 			min_uV = max_uV = voltage;
 
 		if (voltage < 0)

commit f5c2758fbb3095dc0fe4725e4a2eaec3580e1eba
Author: Jaehoon Chung <jh80.chung@samsung.com>
Date:   Fri Feb 1 14:32:22 2013 +0900

    mmc: core: fix indentation
    
    This patch fixes incorrect indentation.  (Just code cleanup)
    
    Signed-off-by: Jaehoon Chung <jh80.chung@samsung.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 6e95f6f11a28..6f3bc1a97ba8 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -516,17 +516,16 @@ struct mmc_async_req *mmc_start_req(struct mmc_host *host,
 		mmc_pre_req(host, areq->mrq, !host->areq);
 
 	if (host->areq) {
-			err = mmc_wait_for_data_req_done(host, host->areq->mrq,
-					areq);
-			if (err == MMC_BLK_NEW_REQUEST) {
-				if (error)
-					*error = err;
-				/*
-				 * The previous request was not completed,
-				 * nothing to return
-				 */
-				return NULL;
-			}
+		err = mmc_wait_for_data_req_done(host, host->areq->mrq,	areq);
+		if (err == MMC_BLK_NEW_REQUEST) {
+			if (error)
+				*error = err;
+			/*
+			 * The previous request was not completed,
+			 * nothing to return
+			 */
+			return NULL;
+		}
 		/*
 		 * Check BKOPS urgency for each R1 response
 		 */
@@ -545,7 +544,7 @@ struct mmc_async_req *mmc_start_req(struct mmc_host *host,
 
 	 /* Cancel a prepared request if it was not started. */
 	if ((err || start_err) && areq)
-			mmc_post_req(host, areq->mrq, -EINVAL);
+		mmc_post_req(host, areq->mrq, -EINVAL);
 
 	if (err)
 		host->areq = NULL;

commit 9b844961c265a8ee4bdacd8404d078d7f1319957
Author: Seungwon Jeon <tgih.jun@samsung.com>
Date:   Tue Jan 22 19:48:03 2013 +0900

    mmc: core: fix permanent sleep of mmcqd during card removal
    
    This patch is derived from:
    "mmc: fix async request mechanism for sequential read scenarios".
    
    According as async transfer, a request is handled with twice mmc_start_req.
    When the card is removed, the request is actually not issued in the first
    mmc_start_req [__mmc_start_data_req]. And then mmc_wait_for_data_req_done
    will come in the next mmc_start_req. But there is no event for completions.
    wake_up_interruptible is needed in __mmc_start_data_req for the case of
    removed card.
    
    Signed-off-by: Seungwon Jeon <tgih.jun@samsung.com>
    Acked-by: Jaehoon Chung <jh80.chung@samsung.com>
    Tested-by: Konstantin Dorfman <kdorfman@codeaurora.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index e41badbf9b50..6e95f6f11a28 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -350,6 +350,7 @@ static int __mmc_start_data_req(struct mmc_host *host, struct mmc_request *mrq)
 	mrq->host = host;
 	if (mmc_card_removed(host->card)) {
 		mrq->cmd->error = -ENOMEDIUM;
+		mmc_wait_data_done(mrq);
 		return -ENOMEDIUM;
 	}
 	mmc_start_request(host, mrq);

commit 0797e5f1453b2bedc08bbcbea0ea4fbe20350823
Author: Johan Rudholm <johan.rudholm@stericsson.com>
Date:   Mon Jan 28 15:08:28 2013 +0100

    mmc: core: Fixup signal voltage switch
    
    When switching SD and SDIO cards from 3.3V to 1.8V signal levels, the
    clock should be gated for 5 ms during the step. After enabling the
    clock, the host should wait for at least 1 ms before checking for
    failure. Failure by the card to switch is indicated by dat[0:3] being
    pulled low. The host should check for this condition and power-cycle
    the card if failure is indicated.
    
    Add a retry mechanism for the SDIO case.
    
    If the voltage switch fails repeatedly, give up and continue the
    initialization using the original voltage.
    
    This patch places a couple of requirements on the host driver:
    
     1) mmc_set_ios with ios.clock = 0 must gate the clock
     2) mmc_power_off must actually cut the power to the card
     3) The card_busy host_ops member must be implemented
    
    if these requirements are not fulfilled, the 1.8V signal voltage switch
    will still be attempted but may not be successful.
    
    Signed-off-by: Johan Rudholm <johan.rudholm@stericsson.com>
    Signed-off-by: Kevin Liu <kliu5@marvell.com>
    Acked-by: Ulf Hansson <ulf.hansson@linaro.org>
    Tested-by: Wei WANG <wei_wang@realsil.com.cn>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index bb794c784597..e41badbf9b50 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1340,6 +1340,7 @@ int mmc_set_signal_voltage(struct mmc_host *host, int signal_voltage)
 {
 	struct mmc_command cmd = {0};
 	int err = 0;
+	u32 clock;
 
 	BUG_ON(!host);
 
@@ -1347,20 +1348,82 @@ int mmc_set_signal_voltage(struct mmc_host *host, int signal_voltage)
 	 * Send CMD11 only if the request is to switch the card to
 	 * 1.8V signalling.
 	 */
-	if (signal_voltage != MMC_SIGNAL_VOLTAGE_330) {
-		cmd.opcode = SD_SWITCH_VOLTAGE;
-		cmd.arg = 0;
-		cmd.flags = MMC_RSP_R1 | MMC_CMD_AC;
+	if (signal_voltage == MMC_SIGNAL_VOLTAGE_330)
+		return __mmc_set_signal_voltage(host, signal_voltage);
 
-		err = mmc_wait_for_cmd(host, &cmd, 0);
-		if (err)
-			return err;
+	/*
+	 * If we cannot switch voltages, return failure so the caller
+	 * can continue without UHS mode
+	 */
+	if (!host->ops->start_signal_voltage_switch)
+		return -EPERM;
+	if (!host->ops->card_busy)
+		pr_warning("%s: cannot verify signal voltage switch\n",
+				mmc_hostname(host));
+
+	cmd.opcode = SD_SWITCH_VOLTAGE;
+	cmd.arg = 0;
+	cmd.flags = MMC_RSP_R1 | MMC_CMD_AC;
+
+	err = mmc_wait_for_cmd(host, &cmd, 0);
+	if (err)
+		return err;
 
-		if (!mmc_host_is_spi(host) && (cmd.resp[0] & R1_ERROR))
-			return -EIO;
+	if (!mmc_host_is_spi(host) && (cmd.resp[0] & R1_ERROR))
+		return -EIO;
+
+	mmc_host_clk_hold(host);
+	/*
+	 * The card should drive cmd and dat[0:3] low immediately
+	 * after the response of cmd11, but wait 1 ms to be sure
+	 */
+	mmc_delay(1);
+	if (host->ops->card_busy && !host->ops->card_busy(host)) {
+		err = -EAGAIN;
+		goto power_cycle;
 	}
+	/*
+	 * During a signal voltage level switch, the clock must be gated
+	 * for 5 ms according to the SD spec
+	 */
+	clock = host->ios.clock;
+	host->ios.clock = 0;
+	mmc_set_ios(host);
 
-	return __mmc_set_signal_voltage(host, signal_voltage);
+	if (__mmc_set_signal_voltage(host, signal_voltage)) {
+		/*
+		 * Voltages may not have been switched, but we've already
+		 * sent CMD11, so a power cycle is required anyway
+		 */
+		err = -EAGAIN;
+		goto power_cycle;
+	}
+
+	/* Keep clock gated for at least 5 ms */
+	mmc_delay(5);
+	host->ios.clock = clock;
+	mmc_set_ios(host);
+
+	/* Wait for at least 1 ms according to spec */
+	mmc_delay(1);
+
+	/*
+	 * Failure to switch is indicated by the card holding
+	 * dat[0:3] low
+	 */
+	if (host->ops->card_busy && host->ops->card_busy(host))
+		err = -EAGAIN;
+
+power_cycle:
+	if (err) {
+		pr_debug("%s: Signal voltage switch failed, "
+			"power cycling card\n", mmc_hostname(host));
+		mmc_power_cycle(host);
+	}
+
+	mmc_host_clk_release(host);
+
+	return err;
 }
 
 /*

commit 567c89032cfdda8047562abe450947ac01f2d3c7
Author: Johan Rudholm <johan.rudholm@stericsson.com>
Date:   Mon Jan 28 15:08:27 2013 +0100

    mmc: core: Break out start_signal_voltage_switch
    
    Allow callers to access the start_signal_voltage_switch host_ops
    member without going through any cmd11 logic. This is mostly a
    preparation for the following signal voltage switch patch.
    
    Also, reset ios.signal_voltage to its original value if
    start_signal_voltage_switch fails.
    
    Signed-off-by: Johan Rudholm <johan.rudholm@stericsson.com>
    Acked-by: Ulf Hansson <ulf.hansson@linaro.org>
    Tested-by: Wei WANG <wei_wang@realsil.com.cn>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 789056fbfc93..bb794c784597 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1317,7 +1317,26 @@ u32 mmc_select_voltage(struct mmc_host *host, u32 ocr)
 	return ocr;
 }
 
-int mmc_set_signal_voltage(struct mmc_host *host, int signal_voltage, bool cmd11)
+int __mmc_set_signal_voltage(struct mmc_host *host, int signal_voltage)
+{
+	int err = 0;
+	int old_signal_voltage = host->ios.signal_voltage;
+
+	host->ios.signal_voltage = signal_voltage;
+	if (host->ops->start_signal_voltage_switch) {
+		mmc_host_clk_hold(host);
+		err = host->ops->start_signal_voltage_switch(host, &host->ios);
+		mmc_host_clk_release(host);
+	}
+
+	if (err)
+		host->ios.signal_voltage = old_signal_voltage;
+
+	return err;
+
+}
+
+int mmc_set_signal_voltage(struct mmc_host *host, int signal_voltage)
 {
 	struct mmc_command cmd = {0};
 	int err = 0;
@@ -1328,7 +1347,7 @@ int mmc_set_signal_voltage(struct mmc_host *host, int signal_voltage, bool cmd11
 	 * Send CMD11 only if the request is to switch the card to
 	 * 1.8V signalling.
 	 */
-	if ((signal_voltage != MMC_SIGNAL_VOLTAGE_330) && cmd11) {
+	if (signal_voltage != MMC_SIGNAL_VOLTAGE_330) {
 		cmd.opcode = SD_SWITCH_VOLTAGE;
 		cmd.arg = 0;
 		cmd.flags = MMC_RSP_R1 | MMC_CMD_AC;
@@ -1341,15 +1360,7 @@ int mmc_set_signal_voltage(struct mmc_host *host, int signal_voltage, bool cmd11
 			return -EIO;
 	}
 
-	host->ios.signal_voltage = signal_voltage;
-
-	if (host->ops->start_signal_voltage_switch) {
-		mmc_host_clk_hold(host);
-		err = host->ops->start_signal_voltage_switch(host, &host->ios);
-		mmc_host_clk_release(host);
-	}
-
-	return err;
+	return __mmc_set_signal_voltage(host, signal_voltage);
 }
 
 /*
@@ -1412,7 +1423,7 @@ static void mmc_power_up(struct mmc_host *host)
 	mmc_set_ios(host);
 
 	/* Set signal voltage to 3.3V */
-	mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_330, false);
+	__mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_330);
 
 	/*
 	 * This delay should be sufficient to allow the power supply

commit 276e090f9217b69e46d8255132d2667ac5eec51b
Author: Johan Rudholm <johan.rudholm@stericsson.com>
Date:   Mon Jan 28 15:08:25 2013 +0100

    mmc: core: Add mmc_power_cycle
    
    Add mmc_power_cycle which can be used to power cycle for instance
    SD-cards.
    
    Signed-off-by: Johan Rudholm <johan.rudholm@stericsson.com>
    Acked-by: Ulf Hansson <ulf.hansson@linaro.org>
    Tested-by: Wei WANG <wei_wang@realsil.com.cn>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 39f28af34cb6..789056fbfc93 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1470,6 +1470,14 @@ void mmc_power_off(struct mmc_host *host)
 	mmc_host_clk_release(host);
 }
 
+void mmc_power_cycle(struct mmc_host *host)
+{
+	mmc_power_off(host);
+	/* Wait at least 1 ms according to SD spec */
+	mmc_delay(1);
+	mmc_power_up(host);
+}
+
 /*
  * Cleanup when the last reference to the bus operator is dropped.
  */

commit 881d926d9d0bd2eb50f8f90c993bc403853382ce
Author: Maya Erez <merez@codeaurora.org>
Date:   Mon Jan 28 16:44:22 2013 -0500

    mmc: core: move the cache disabling operation to mmc_suspend
    
    Cache control is an eMMC feature and in therefore should be
    part of MMC's bus resume operations, performed in mmc_suspend,
    rather than in the generic mmc_suspend_host().
    
    Signed-off-by: Maya Erez <merez@codeaurora.org>
    Acked-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 8b3a1222e665..39f28af34cb6 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2486,6 +2486,7 @@ EXPORT_SYMBOL(mmc_flush_cache);
  * Turn the cache ON/OFF.
  * Turning the cache OFF shall trigger flushing of the data
  * to the non-volatile storage.
+ * This function should be called with host claimed
  */
 int mmc_cache_ctrl(struct mmc_host *host, u8 enable)
 {
@@ -2497,7 +2498,6 @@ int mmc_cache_ctrl(struct mmc_host *host, u8 enable)
 			mmc_card_is_removable(host))
 		return err;
 
-	mmc_claim_host(host);
 	if (card && mmc_card_mmc(card) &&
 			(card->ext_csd.cache_size > 0)) {
 		enable = !!enable;
@@ -2515,7 +2515,6 @@ int mmc_cache_ctrl(struct mmc_host *host, u8 enable)
 				card->ext_csd.cache_ctrl = enable;
 		}
 	}
-	mmc_release_host(host);
 
 	return err;
 }
@@ -2534,10 +2533,6 @@ int mmc_suspend_host(struct mmc_host *host)
 	cancel_delayed_work(&host->detect);
 	mmc_flush_scheduled_work();
 
-	err = mmc_cache_ctrl(host, 0);
-	if (err)
-		goto out;
-
 	mmc_bus_get(host);
 	if (host->bus_ops && !host->bus_dead) {
 		if (host->bus_ops->suspend) {

commit 2220eedfd7aea69008173a224975e10284fbe854
Author: Konstantin Dorfman <kdorfman@codeaurora.org>
Date:   Mon Jan 14 14:28:17 2013 -0500

    mmc: fix async request mechanism for sequential read scenarios
    
    When current request is running on the bus and if next request fetched
    by mmcqd is NULL, mmc context (mmcqd thread) gets blocked until the
    current request completes. This means that if new request comes in while
    the mmcqd thread is blocked, this new request can not be prepared in
    parallel to current ongoing request. This may result in delaying the new
    request execution and increase it's latency.
    
    This change allows to wake up the MMC thread on new request arrival.
    Now once the MMC thread is woken up, a new request can be fetched and
    prepared in parallel to the current running request which means this new
    request can be started immediately after the current running request
    completes.
    
    With this change read throughput is improved by 16%.
    
    Signed-off-by: Konstantin Dorfman <kdorfman@codeaurora.org>
    Reviewed-by: Seungwon Jeon <tgih.jun@samsung.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index aaed7687cf09..8b3a1222e665 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -319,11 +319,44 @@ void mmc_start_bkops(struct mmc_card *card, bool from_exception)
 }
 EXPORT_SYMBOL(mmc_start_bkops);
 
+/*
+ * mmc_wait_data_done() - done callback for data request
+ * @mrq: done data request
+ *
+ * Wakes up mmc context, passed as a callback to host controller driver
+ */
+static void mmc_wait_data_done(struct mmc_request *mrq)
+{
+	mrq->host->context_info.is_done_rcv = true;
+	wake_up_interruptible(&mrq->host->context_info.wait);
+}
+
 static void mmc_wait_done(struct mmc_request *mrq)
 {
 	complete(&mrq->completion);
 }
 
+/*
+ *__mmc_start_data_req() - starts data request
+ * @host: MMC host to start the request
+ * @mrq: data request to start
+ *
+ * Sets the done callback to be called when request is completed by the card.
+ * Starts data mmc request execution
+ */
+static int __mmc_start_data_req(struct mmc_host *host, struct mmc_request *mrq)
+{
+	mrq->done = mmc_wait_data_done;
+	mrq->host = host;
+	if (mmc_card_removed(host->card)) {
+		mrq->cmd->error = -ENOMEDIUM;
+		return -ENOMEDIUM;
+	}
+	mmc_start_request(host, mrq);
+
+	return 0;
+}
+
 static int __mmc_start_req(struct mmc_host *host, struct mmc_request *mrq)
 {
 	init_completion(&mrq->completion);
@@ -337,6 +370,62 @@ static int __mmc_start_req(struct mmc_host *host, struct mmc_request *mrq)
 	return 0;
 }
 
+/*
+ * mmc_wait_for_data_req_done() - wait for request completed
+ * @host: MMC host to prepare the command.
+ * @mrq: MMC request to wait for
+ *
+ * Blocks MMC context till host controller will ack end of data request
+ * execution or new request notification arrives from the block layer.
+ * Handles command retries.
+ *
+ * Returns enum mmc_blk_status after checking errors.
+ */
+static int mmc_wait_for_data_req_done(struct mmc_host *host,
+				      struct mmc_request *mrq,
+				      struct mmc_async_req *next_req)
+{
+	struct mmc_command *cmd;
+	struct mmc_context_info *context_info = &host->context_info;
+	int err;
+	unsigned long flags;
+
+	while (1) {
+		wait_event_interruptible(context_info->wait,
+				(context_info->is_done_rcv ||
+				 context_info->is_new_req));
+		spin_lock_irqsave(&context_info->lock, flags);
+		context_info->is_waiting_last_req = false;
+		spin_unlock_irqrestore(&context_info->lock, flags);
+		if (context_info->is_done_rcv) {
+			context_info->is_done_rcv = false;
+			context_info->is_new_req = false;
+			cmd = mrq->cmd;
+			if (!cmd->error || !cmd->retries ||
+			    mmc_card_removed(host->card)) {
+				err = host->areq->err_check(host->card,
+							    host->areq);
+				break; /* return err */
+			} else {
+				pr_info("%s: req failed (CMD%u): %d, retrying...\n",
+					mmc_hostname(host),
+					cmd->opcode, cmd->error);
+				cmd->retries--;
+				cmd->error = 0;
+				host->ops->request(host, mrq);
+				continue; /* wait for done/new event again */
+			}
+		} else if (context_info->is_new_req) {
+			context_info->is_new_req = false;
+			if (!next_req) {
+				err = MMC_BLK_NEW_REQUEST;
+				break; /* return err */
+			}
+		}
+	}
+	return err;
+}
+
 static void mmc_wait_for_req_done(struct mmc_host *host,
 				  struct mmc_request *mrq)
 {
@@ -426,8 +515,17 @@ struct mmc_async_req *mmc_start_req(struct mmc_host *host,
 		mmc_pre_req(host, areq->mrq, !host->areq);
 
 	if (host->areq) {
-		mmc_wait_for_req_done(host, host->areq->mrq);
-		err = host->areq->err_check(host->card, host->areq);
+			err = mmc_wait_for_data_req_done(host, host->areq->mrq,
+					areq);
+			if (err == MMC_BLK_NEW_REQUEST) {
+				if (error)
+					*error = err;
+				/*
+				 * The previous request was not completed,
+				 * nothing to return
+				 */
+				return NULL;
+			}
 		/*
 		 * Check BKOPS urgency for each R1 response
 		 */
@@ -439,7 +537,7 @@ struct mmc_async_req *mmc_start_req(struct mmc_host *host,
 	}
 
 	if (!err && areq)
-		start_err = __mmc_start_req(host, areq->mrq);
+		start_err = __mmc_start_data_req(host, areq->mrq);
 
 	if (host->areq)
 		mmc_post_req(host, host->areq->mrq, 0);
@@ -2581,6 +2679,23 @@ int mmc_pm_notify(struct notifier_block *notify_block,
 }
 #endif
 
+/**
+ * mmc_init_context_info() - init synchronization context
+ * @host: mmc host
+ *
+ * Init struct context_info needed to implement asynchronous
+ * request mechanism, used by mmc core, host driver and mmc requests
+ * supplier.
+ */
+void mmc_init_context_info(struct mmc_host *host)
+{
+	spin_lock_init(&host->context_info.lock);
+	host->context_info.is_new_req = false;
+	host->context_info.is_done_rcv = false;
+	host->context_info.is_waiting_last_req = false;
+	init_waitqueue_head(&host->context_info.wait);
+}
+
 static int __init mmc_init(void)
 {
 	int ret;

commit 67c79db8d9c0e5d2e2075c9108f42566ce0f8a6f
Author: Loic Pallardy <loic.pallardy-ext@stericsson.com>
Date:   Mon Aug 6 17:12:30 2012 +0200

    mmc: core: Add mmc_set_blockcount feature
    
    Provide support for automatically sending Set Block Count
    (CMD23) messages. Used at least for RPMB support.
    
    Signed-off-by: Alex Macro <alex.macro@stericsson.com>
    Signed-off-by: Loic Pallardy <loic.pallardy@stericsson.com>
    Reviewed-by: Namjae Jeon <linkinjeon@gmail.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Johan Rudholm <johan.rudholm@stericsson.com>
    Acked-by: Krishna Konda <kkonda@codeaurora.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index bccfd1858b08..aaed7687cf09 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1958,6 +1958,20 @@ int mmc_set_blocklen(struct mmc_card *card, unsigned int blocklen)
 }
 EXPORT_SYMBOL(mmc_set_blocklen);
 
+int mmc_set_blockcount(struct mmc_card *card, unsigned int blockcount,
+			bool is_rel_write)
+{
+	struct mmc_command cmd = {0};
+
+	cmd.opcode = MMC_SET_BLOCK_COUNT;
+	cmd.arg = blockcount & 0x0000FFFF;
+	if (is_rel_write)
+		cmd.arg |= 1 << 31;
+	cmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_AC;
+	return mmc_wait_for_cmd(card->host, &cmd, 5);
+}
+EXPORT_SYMBOL(mmc_set_blockcount);
+
 static void mmc_hw_reset_for_init(struct mmc_host *host)
 {
 	if (!(host->caps & MMC_CAP_HW_RESET) || !host->ops->hw_reset)

commit 8fee476b219d1869762d9ef5c189a0c85e919a4d
Author: Trey Ramsay <tramsay@linux.vnet.ibm.com>
Date:   Fri Nov 16 09:31:41 2012 -0600

    mmc: core: Fix some driver hangs when dealing with broken devices
    
    There are infinite loops in the mmc code that can be caused by bad
    hardware.  The code will loop forever if the device never comes back
    from program mode, R1_STATE_PRG, and it is not ready for data,
    R1_READY_FOR_DATA.
    
    A long timeout is added to prevent the code from looping forever.
    The timeout will occur if the device never comes back from program
    state or the device never becomes ready for data.
    
    It's not clear whether the timeout will do more than log a pr_err()
    and then start a fresh hang all over again.  We may need to extend
    this patch later to perform some kind of reset of the device (is
    that possible?) or rejection of new I/O to the device.
    
    Signed-off-by: Trey Ramsay <tramsay@linux.vnet.ibm.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 06c42cfb7c34..bccfd1858b08 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -42,6 +42,9 @@
 #include "sd_ops.h"
 #include "sdio_ops.h"
 
+/* If the device is not responding */
+#define MMC_CORE_TIMEOUT_MS	(10 * 60 * 1000) /* 10 minute timeout */
+
 /*
  * Background operations can take a long time, depending on the housekeeping
  * operations the card has to perform.
@@ -1631,6 +1634,7 @@ static int mmc_do_erase(struct mmc_card *card, unsigned int from,
 {
 	struct mmc_command cmd = {0};
 	unsigned int qty = 0;
+	unsigned long timeout;
 	int err;
 
 	/*
@@ -1708,6 +1712,7 @@ static int mmc_do_erase(struct mmc_card *card, unsigned int from,
 	if (mmc_host_is_spi(card->host))
 		goto out;
 
+	timeout = jiffies + msecs_to_jiffies(MMC_CORE_TIMEOUT_MS);
 	do {
 		memset(&cmd, 0, sizeof(struct mmc_command));
 		cmd.opcode = MMC_SEND_STATUS;
@@ -1721,8 +1726,19 @@ static int mmc_do_erase(struct mmc_card *card, unsigned int from,
 			err = -EIO;
 			goto out;
 		}
+
+		/* Timeout if the device never becomes ready for data and
+		 * never leaves the program state.
+		 */
+		if (time_after(jiffies, timeout)) {
+			pr_err("%s: Card stuck in programming state! %s\n",
+				mmc_hostname(card->host), __func__);
+			err =  -EIO;
+			goto out;
+		}
+
 	} while (!(cmd.resp[0] & R1_READY_FOR_DATA) ||
-		 R1_CURRENT_STATE(cmd.resp[0]) == R1_STATE_PRG);
+		 (R1_CURRENT_STATE(cmd.resp[0]) == R1_STATE_PRG));
 out:
 	return err;
 }

commit e6c085863f97f0a8f009753e1baaf83e4aac7b42
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri Oct 5 12:45:39 2012 -0400

    mmc: core: Fixup broken suspend and eMMC4.5 power off notify
    
    This patch fixes up the broken suspend sequence for eMMC with sleep
    support. Additionally it reworks the eMMC4.5 Power Off Notification
    feature so it fits together with the existing sleep feature.
    
    The CMD0 based re-initialization of the eMMC at resume is re-introduced
    to maintain compatiblity for devices using sleep.
    
    A host shall use MMC_CAP2_POWEROFF_NOTIFY to enable the Power Off
    Notification feature. We might be able to remove this cap later on,
    if we think that Power Off Notification always is preferred over
    sleep, even if the host is not able to cut the eMMC VCCQ power.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Saugata Das <saugata.das@linaro.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 66121633c9cd..06c42cfb7c34 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1273,48 +1273,6 @@ void mmc_set_driver_type(struct mmc_host *host, unsigned int drv_type)
 	mmc_host_clk_release(host);
 }
 
-static void mmc_poweroff_notify(struct mmc_host *host)
-{
-	struct mmc_card *card;
-	unsigned int timeout;
-	unsigned int notify_type = EXT_CSD_NO_POWER_NOTIFICATION;
-	int err = 0;
-
-	card = host->card;
-	mmc_claim_host(host);
-
-	/*
-	 * Send power notify command only if card
-	 * is mmc and notify state is powered ON
-	 */
-	if (card && mmc_card_mmc(card) &&
-	    (card->poweroff_notify_state == MMC_POWERED_ON)) {
-
-		if (host->power_notify_type == MMC_HOST_PW_NOTIFY_SHORT) {
-			notify_type = EXT_CSD_POWER_OFF_SHORT;
-			timeout = card->ext_csd.generic_cmd6_time;
-			card->poweroff_notify_state = MMC_POWEROFF_SHORT;
-		} else {
-			notify_type = EXT_CSD_POWER_OFF_LONG;
-			timeout = card->ext_csd.power_off_longtime;
-			card->poweroff_notify_state = MMC_POWEROFF_LONG;
-		}
-
-		err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
-				 EXT_CSD_POWER_OFF_NOTIFICATION,
-				 notify_type, timeout);
-
-		if (err && err != -EBADMSG)
-			pr_err("Device failed to respond within %d poweroff "
-			       "time. Forcefully powering down the device\n",
-			       timeout);
-
-		/* Set the card state to no notification after the poweroff */
-		card->poweroff_notify_state = MMC_NO_POWER_NOTIFICATION;
-	}
-	mmc_release_host(host);
-}
-
 /*
  * Apply power to the MMC stack.  This is a two-stage process.
  * First, we enable power to the card without the clock running.
@@ -1377,8 +1335,6 @@ static void mmc_power_up(struct mmc_host *host)
 
 void mmc_power_off(struct mmc_host *host)
 {
-	int err = 0;
-
 	if (host->ios.power_mode == MMC_POWER_OFF)
 		return;
 
@@ -1387,22 +1343,6 @@ void mmc_power_off(struct mmc_host *host)
 	host->ios.clock = 0;
 	host->ios.vdd = 0;
 
-	/*
-	 * For eMMC 4.5 device send AWAKE command before
-	 * POWER_OFF_NOTIFY command, because in sleep state
-	 * eMMC 4.5 devices respond to only RESET and AWAKE cmd
-	 */
-	if (host->card && mmc_card_is_sleep(host->card) &&
-	    host->bus_ops->resume) {
-		err = host->bus_ops->resume(host);
-
-		if (!err)
-			mmc_poweroff_notify(host);
-		else
-			pr_warning("%s: error %d during resume "
-				   "(continue with poweroff sequence)\n",
-				   mmc_hostname(host), err);
-	}
 
 	/*
 	 * Reset ocr mask to be the highest possible voltage supported for
@@ -2579,7 +2519,6 @@ int mmc_pm_notify(struct notifier_block *notify_block,
 
 		spin_lock_irqsave(&host->lock, flags);
 		host->rescan_disable = 1;
-		host->power_notify_type = MMC_HOST_PW_NOTIFY_SHORT;
 		spin_unlock_irqrestore(&host->lock, flags);
 		cancel_delayed_work_sync(&host->detect);
 
@@ -2603,7 +2542,6 @@ int mmc_pm_notify(struct notifier_block *notify_block,
 
 		spin_lock_irqsave(&host->lock, flags);
 		host->rescan_disable = 0;
-		host->power_notify_type = MMC_HOST_PW_NOTIFY_LONG;
 		spin_unlock_irqrestore(&host->lock, flags);
 		mmc_detect_change(host, 0);
 

commit 9cde5b7a49a88939d648c361ec938fa8a633a045
Author: Chris Ball <cjb@laptop.org>
Date:   Wed Sep 19 22:27:04 2012 +0800

    mmc: core: Replace MMC_CAP2_BROKEN_VOLTAGE with test for fixed regulator
    
    Before this patch, we were using MMC_CAP2_BROKEN_VOLTAGE as a way to
    avoid calling regulator_set_voltage() on a fixed regulator, but that's
    just duplicating information that already exists -- we should test
    whether the regulator is fixed directly, instead of via a capability.
    
    This patch implements that test.  We can't reclaim the capability bit
    just yet, since there are still boards in arch/arm/ that reference it;
    those references can be removed now.
    
    Reported-by: Tomasz Figa <t.figa@samsung.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 044cd016320e..66121633c9cd 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1113,7 +1113,8 @@ int mmc_regulator_set_ocr(struct mmc_host *mmc,
 		int		tmp;
 		int		voltage;
 
-		/* REVISIT mmc_vddrange_to_ocrmask() may have set some
+		/*
+		 * REVISIT mmc_vddrange_to_ocrmask() may have set some
 		 * bits this regulator doesn't quite support ... don't
 		 * be too picky, most cards and regulators are OK with
 		 * a 0.1V range goof (it's a small error percentage).
@@ -1127,12 +1128,13 @@ int mmc_regulator_set_ocr(struct mmc_host *mmc,
 			max_uV = min_uV + 100 * 1000;
 		}
 
-		/* avoid needless changes to this voltage; the regulator
-		 * might not allow this operation
+		/*
+		 * If we're using a fixed/static regulator, don't call
+		 * regulator_set_voltage; it would fail.
 		 */
 		voltage = regulator_get_voltage(supply);
 
-		if (mmc->caps2 & MMC_CAP2_BROKEN_VOLTAGE)
+		if (regulator_count_voltages(supply) == 1)
 			min_uV = max_uV = voltage;
 
 		if (voltage < 0)

commit 950d56acce5d401f477b91d0177605b543d63d07
Author: Jaehoon Chung <jh80.chung@samsung.com>
Date:   Mon Sep 17 08:42:02 2012 +0000

    mmc: support BKOPS feature for eMMC
    
    Enable eMMC background operations (BKOPS) feature.
    
    If URGENT_BKOPS is set after a response, note that BKOPS are required.
    Immediately run BKOPS if required.  Read/write operations should be
    requested during BKOPS(LEVEL-1), then issue HPI to interrupt the
    ongoing BKOPS and service the foreground operation.
    (This patch only controls the LEVEL2/3.)
    
    When repeating the writing 1GB data, at a certain time, performance is
    decreased.  At that time, card triggers the Level-3 or Level-2.  After
    running bkops, performance is recovered.
    
    Future considerations:
     * Check BKOPS_LEVEL=1 and start BKOPS in a preventive manner.
     * Interrupt ongoing BKOPS before powering off the card.
     * How do we get BKOPS_STATUS value (periodically send ext_csd command)?
     * If using periodic bkops, also consider runtime_pm control.
    
    Signed-off-by: Jaehoon Chung <jh80.chung@samsung.com>
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: Konstantin Dorfman <kdorfman@codeaurora.org>
    Reviewed-by: Maya Erez <merez@codeaurora.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index af2c4d2fd69e..044cd016320e 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -26,6 +26,7 @@
 #include <linux/suspend.h>
 #include <linux/fault-inject.h>
 #include <linux/random.h>
+#include <linux/slab.h>
 
 #include <linux/mmc/card.h>
 #include <linux/mmc/host.h>
@@ -41,6 +42,12 @@
 #include "sd_ops.h"
 #include "sdio_ops.h"
 
+/*
+ * Background operations can take a long time, depending on the housekeeping
+ * operations the card has to perform.
+ */
+#define MMC_BKOPS_MAX_TIMEOUT	(4 * 60 * 1000) /* max time to wait in ms */
+
 static struct workqueue_struct *workqueue;
 static const unsigned freqs[] = { 400000, 300000, 200000, 100000 };
 
@@ -245,6 +252,70 @@ mmc_start_request(struct mmc_host *host, struct mmc_request *mrq)
 	host->ops->request(host, mrq);
 }
 
+/**
+ *	mmc_start_bkops - start BKOPS for supported cards
+ *	@card: MMC card to start BKOPS
+ *	@form_exception: A flag to indicate if this function was
+ *			 called due to an exception raised by the card
+ *
+ *	Start background operations whenever requested.
+ *	When the urgent BKOPS bit is set in a R1 command response
+ *	then background operations should be started immediately.
+*/
+void mmc_start_bkops(struct mmc_card *card, bool from_exception)
+{
+	int err;
+	int timeout;
+	bool use_busy_signal;
+
+	BUG_ON(!card);
+
+	if (!card->ext_csd.bkops_en || mmc_card_doing_bkops(card))
+		return;
+
+	err = mmc_read_bkops_status(card);
+	if (err) {
+		pr_err("%s: Failed to read bkops status: %d\n",
+		       mmc_hostname(card->host), err);
+		return;
+	}
+
+	if (!card->ext_csd.raw_bkops_status)
+		return;
+
+	if (card->ext_csd.raw_bkops_status < EXT_CSD_BKOPS_LEVEL_2 &&
+	    from_exception)
+		return;
+
+	mmc_claim_host(card->host);
+	if (card->ext_csd.raw_bkops_status >= EXT_CSD_BKOPS_LEVEL_2) {
+		timeout = MMC_BKOPS_MAX_TIMEOUT;
+		use_busy_signal = true;
+	} else {
+		timeout = 0;
+		use_busy_signal = false;
+	}
+
+	err = __mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
+			EXT_CSD_BKOPS_START, 1, timeout, use_busy_signal);
+	if (err) {
+		pr_warn("%s: Error %d starting bkops\n",
+			mmc_hostname(card->host), err);
+		goto out;
+	}
+
+	/*
+	 * For urgent bkops status (LEVEL_2 and more)
+	 * bkops executed synchronously, otherwise
+	 * the operation is in progress
+	 */
+	if (!use_busy_signal)
+		mmc_card_set_doing_bkops(card);
+out:
+	mmc_release_host(card->host);
+}
+EXPORT_SYMBOL(mmc_start_bkops);
+
 static void mmc_wait_done(struct mmc_request *mrq)
 {
 	complete(&mrq->completion);
@@ -354,6 +425,14 @@ struct mmc_async_req *mmc_start_req(struct mmc_host *host,
 	if (host->areq) {
 		mmc_wait_for_req_done(host, host->areq->mrq);
 		err = host->areq->err_check(host->card, host->areq);
+		/*
+		 * Check BKOPS urgency for each R1 response
+		 */
+		if (host->card && mmc_card_mmc(host->card) &&
+		    ((mmc_resp_type(host->areq->mrq->cmd) == MMC_RSP_R1) ||
+		     (mmc_resp_type(host->areq->mrq->cmd) == MMC_RSP_R1B)) &&
+		    (host->areq->mrq->cmd->resp[0] & R1_EXCEPTION_EVENT))
+			mmc_start_bkops(host->card, true);
 	}
 
 	if (!err && areq)
@@ -398,7 +477,7 @@ EXPORT_SYMBOL(mmc_wait_for_req);
  *	@card: the MMC card associated with the HPI transfer
  *
  *	Issued High Priority Interrupt, and check for card status
- *	util out-of prg-state.
+ *	until out-of prg-state.
  */
 int mmc_interrupt_hpi(struct mmc_card *card)
 {
@@ -489,6 +568,64 @@ int mmc_wait_for_cmd(struct mmc_host *host, struct mmc_command *cmd, int retries
 
 EXPORT_SYMBOL(mmc_wait_for_cmd);
 
+/**
+ *	mmc_stop_bkops - stop ongoing BKOPS
+ *	@card: MMC card to check BKOPS
+ *
+ *	Send HPI command to stop ongoing background operations to
+ *	allow rapid servicing of foreground operations, e.g. read/
+ *	writes. Wait until the card comes out of the programming state
+ *	to avoid errors in servicing read/write requests.
+ */
+int mmc_stop_bkops(struct mmc_card *card)
+{
+	int err = 0;
+
+	BUG_ON(!card);
+	err = mmc_interrupt_hpi(card);
+
+	/*
+	 * If err is EINVAL, we can't issue an HPI.
+	 * It should complete the BKOPS.
+	 */
+	if (!err || (err == -EINVAL)) {
+		mmc_card_clr_doing_bkops(card);
+		err = 0;
+	}
+
+	return err;
+}
+EXPORT_SYMBOL(mmc_stop_bkops);
+
+int mmc_read_bkops_status(struct mmc_card *card)
+{
+	int err;
+	u8 *ext_csd;
+
+	/*
+	 * In future work, we should consider storing the entire ext_csd.
+	 */
+	ext_csd = kmalloc(512, GFP_KERNEL);
+	if (!ext_csd) {
+		pr_err("%s: could not allocate buffer to receive the ext_csd.\n",
+		       mmc_hostname(card->host));
+		return -ENOMEM;
+	}
+
+	mmc_claim_host(card->host);
+	err = mmc_send_ext_csd(card, ext_csd);
+	mmc_release_host(card->host);
+	if (err)
+		goto out;
+
+	card->ext_csd.raw_bkops_status = ext_csd[EXT_CSD_BKOPS_STATUS];
+	card->ext_csd.raw_exception_status = ext_csd[EXT_CSD_EXP_EVENTS_STATUS];
+out:
+	kfree(ext_csd);
+	return err;
+}
+EXPORT_SYMBOL(mmc_read_bkops_status);
+
 /**
  *	mmc_set_data_timeout - set the timeout for a data command
  *	@data: data phase for command
@@ -2333,9 +2470,14 @@ int mmc_suspend_host(struct mmc_host *host)
 
 	mmc_bus_get(host);
 	if (host->bus_ops && !host->bus_dead) {
-
-		if (host->bus_ops->suspend)
+		if (host->bus_ops->suspend) {
+			if (mmc_card_doing_bkops(host->card)) {
+				err = mmc_stop_bkops(host->card);
+				if (err)
+					goto out;
+			}
 			err = host->bus_ops->suspend(host);
+		}
 
 		if (err == -ENOSYS || !host->bus_ops->resume) {
 			/*
@@ -2417,11 +2559,21 @@ int mmc_pm_notify(struct notifier_block *notify_block,
 	struct mmc_host *host = container_of(
 		notify_block, struct mmc_host, pm_notify);
 	unsigned long flags;
-
+	int err = 0;
 
 	switch (mode) {
 	case PM_HIBERNATION_PREPARE:
 	case PM_SUSPEND_PREPARE:
+		if (host->card && mmc_card_mmc(host->card) &&
+		    mmc_card_doing_bkops(host->card)) {
+			err = mmc_stop_bkops(host->card);
+			if (err) {
+				pr_err("%s: didn't stop bkops\n",
+					mmc_hostname(host));
+				return err;
+			}
+			mmc_card_clr_doing_bkops(host->card);
+		}
 
 		spin_lock_irqsave(&host->lock, flags);
 		host->rescan_disable = 1;

commit 3339d1e33185798a45dbdb5ea6c0bec1c27ca5fd
Author: Johan Rudholm <johan.rudholm@stericsson.com>
Date:   Thu Aug 23 13:40:55 2012 +0200

    mmc: core: Do not rescan non-removable devices
    
    If MMC_CAP_NONREMOVABLE is set, only issue a detect job on init.
    
    Signed-off-by: Johan Rudholm <johan.rudholm@stericsson.com>
    Acked-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 835c9f001a10..af2c4d2fd69e 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2053,6 +2053,11 @@ void mmc_rescan(struct work_struct *work)
 	if (host->rescan_disable)
 		return;
 
+	/* If there is a non-removable card registered, only scan once */
+	if ((host->caps & MMC_CAP_NONREMOVABLE) && host->rescan_entered)
+		return;
+	host->rescan_entered = 1;
+
 	mmc_bus_get(host);
 
 	/*

commit 211d4fe580735bab850d31f9e4c0a62b47a38bb2
Author: Venkatraman S <svenkatr@ti.com>
Date:   Tue Aug 7 19:24:45 2012 +0530

    mmc: core: Add TRANsfer state to non-HPI state
    
    HPI can be issued only in programming state to bring the card to
    transfer state. If the card is already in transfer state, doing
    a HPI is redundant.
    Fix this by adding transfer state to the list of exceptions to
    doing HPI and return without error.
    
    Signed-off-by: Venkatraman S <svenkatr@ti.com>
    Acked-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 8ac5246e2ab2..835c9f001a10 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -424,8 +424,9 @@ int mmc_interrupt_hpi(struct mmc_card *card)
 	case R1_STATE_IDLE:
 	case R1_STATE_READY:
 	case R1_STATE_STBY:
+	case R1_STATE_TRAN:
 		/*
-		 * In idle states, HPI is not needed and the caller
+		 * In idle and transfer states, HPI is not needed and the caller
 		 * can issue the next intended command immediately
 		 */
 		goto out;

commit 108ecc4cf9c46a4caabaf18efc42d19818c95b70
Author: Aaron Lu <aaron.lu@amd.com>
Date:   Tue Jul 10 16:55:37 2012 +0800

    mmc: core: reset signal voltage on power up
    
    Add a call to mmc_set_signal_voltage() to set signal voltage to 3.3v in
    mmc_power_up so that we do not need to touch signal voltage setting in
    mmc/sd/sdio init functions and rescan function.
    
    For mmc/sd cards, when doing a suspend/resume cycle, consider the unsafe
    resume case, the card will lose its power and when powered on again, we
    will set signal voltage to 3.3v in mmc_power_up before its resume function
    gets called, which will re-init the card.
    
    And for sdio cards, when doing a suspend/resume cycle, consider the unsafe
    resume case, the card will either lose its power or not depending on if it
    wants to wakeup the host. If power is not maintained, it is the same case as
    mmc/sd cards. If power is maintained, mmc_power_up will not be called and
    the card's signal voltage will remain at the last setting.
    
    Signed-off-by: Aaron Lu <aaron.lu@amd.com>
    Tested-by: Venkatraman S <svenkatr@ti.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 9503cabc96f1..8ac5246e2ab2 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1212,6 +1212,9 @@ static void mmc_power_up(struct mmc_host *host)
 	host->ios.timing = MMC_TIMING_LEGACY;
 	mmc_set_ios(host);
 
+	/* Set signal voltage to 3.3V */
+	mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_330, false);
+
 	/*
 	 * This delay should be sufficient to allow the power supply
 	 * to reach the minimum voltage.
@@ -1963,9 +1966,6 @@ static int mmc_rescan_try_freq(struct mmc_host *host, unsigned freq)
 	 */
 	mmc_hw_reset_for_init(host);
 
-	/* Initialization should be done at 3.3 V I/O voltage. */
-	mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_330, 0);
-
 	/*
 	 * sdio_reset sends CMD52 to reset card.  Since we do not know
 	 * if the card is being re-initialized, just send it.  CMD52

commit d9adcc12860d76cf3401c6ab7c0406b15b356b7a
Author: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
Date:   Thu Jun 14 10:17:39 2012 +0200

    mmc: prohibit card detection when host is not ready
    
    Currently mmc host drivers have to decide whether to enable card
    detection before calling mmc_add_host() -- in which case a card
    insertion event can arrive before the host has been completely
    initialised -- or after mmc_add_host(), in which case the initial
    card detection can be problematic.
    
    This patch adds an explicit indication of when card detection should
    not be carried out. With it in place enabling card detection before
    calling mmc_add_host() should be safe. Similarly, disabling it again
    after calling mmc_remove_host() will avoid any races.
    
    Signed-off-by: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 8d00aef9523e..9503cabc96f1 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2107,6 +2107,7 @@ void mmc_rescan(struct work_struct *work)
 void mmc_start_host(struct mmc_host *host)
 {
 	host->f_init = max(freqs[0], host->f_min);
+	host->rescan_disable = 0;
 	mmc_power_up(host);
 	mmc_detect_change(host, 0);
 }
@@ -2120,6 +2121,7 @@ void mmc_stop_host(struct mmc_host *host)
 	spin_unlock_irqrestore(&host->lock, flags);
 #endif
 
+	host->rescan_disable = 1;
 	cancel_delayed_work_sync(&host->detect);
 	mmc_flush_scheduled_work();
 

commit e137788dd115dd9d21759a768dba5fff9685e587
Author: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
Date:   Wed Jun 20 02:28:43 2012 -0400

    mmc: add a function to get regulators, supplying card's power
    
    Add a function to get regulators, supplying card's Vdd and Vccq on a
    specific host. If a Vdd supplying regulator is found, the function checks,
    whether a valid OCR mask can be obtained from it. The Vccq regulator is
    optional. A failure to get it is not fatal.
    
    Signed-off-by: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
    Reviwed-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 28b1ffaf0bd1..8d00aef9523e 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1022,6 +1022,29 @@ int mmc_regulator_set_ocr(struct mmc_host *mmc,
 }
 EXPORT_SYMBOL_GPL(mmc_regulator_set_ocr);
 
+int mmc_regulator_get_supply(struct mmc_host *mmc)
+{
+	struct device *dev = mmc_dev(mmc);
+	struct regulator *supply;
+	int ret;
+
+	supply = devm_regulator_get(dev, "vmmc");
+	mmc->supply.vmmc = supply;
+	mmc->supply.vqmmc = devm_regulator_get(dev, "vqmmc");
+
+	if (IS_ERR(supply))
+		return PTR_ERR(supply);
+
+	ret = mmc_regulator_get_ocrmask(supply);
+	if (ret > 0)
+		mmc->ocr_avail = ret;
+	else
+		dev_warn(mmc_dev(mmc), "Failed getting OCR mask: %d\n", ret);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(mmc_regulator_get_supply);
+
 #endif /* CONFIG_REGULATOR */
 
 /*

commit 45a6b32e24003d9749d8c6d1c83dfb64d6994ca7
Author: Chris Ball <cjb@laptop.org>
Date:   Mon Jun 11 09:39:12 2012 -0400

    mmc: core: Export regulator_* functions as GPL
    
    The regulator API functions we're wrapping are exported as GPL, so our
    wrappers for the same functions should be too.
    
    Reported-by: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index a7e2c4b2f18c..28b1ffaf0bd1 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -950,7 +950,7 @@ int mmc_regulator_get_ocrmask(struct regulator *supply)
 
 	return result;
 }
-EXPORT_SYMBOL(mmc_regulator_get_ocrmask);
+EXPORT_SYMBOL_GPL(mmc_regulator_get_ocrmask);
 
 /**
  * mmc_regulator_set_ocr - set regulator to match host->ios voltage
@@ -1020,7 +1020,7 @@ int mmc_regulator_set_ocr(struct mmc_host *mmc,
 			"could not set regulator OCR (%d)\n", result);
 	return result;
 }
-EXPORT_SYMBOL(mmc_regulator_set_ocr);
+EXPORT_SYMBOL_GPL(mmc_regulator_set_ocr);
 
 #endif /* CONFIG_REGULATOR */
 

commit 6af9e96e052a6d1a760c60cb340c5a6584cb92db
Author: Venkatraman S <svenkatr@ti.com>
Date:   Fri Jun 22 11:42:36 2012 +0530

    mmc: core: Fix the HPI execution sequence
    
    mmc_execute_hpi should send the HPI command only once, and only
    if the card is in PRG state.
    
    According to eMMC spec, the command's completion time is
    not dependent on OUT_OF_INTERRUPT_TIME. Only the transition
    out of PRG STATE is guarded by OUT_OF_INTERRUPT_TIME - which
    is defined to begin at the end of sending the command itself.
    
    Specify the default timeout for the actual sending of HPI
    command, and then use OUT_OF_INTERRUPT_TIME to wait for
    the transition out of PRG state.
    
    Reported-by: Alex Lemberg <Alex.Lemberg@sandisk.com>
    Signed-off-by: Venkatraman S <svenkatr@ti.com>
    Reviewed-by: Namjae Jeon <linkinjeon@gmail.com>
    Reviewed-by: Subhash Jadavani <subhashj@codeaurora.org>
    Acked-by: Jaehoon Chung <jh80.chung@samsung.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 0b6141d29dbd..a7e2c4b2f18c 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -404,6 +404,7 @@ int mmc_interrupt_hpi(struct mmc_card *card)
 {
 	int err;
 	u32 status;
+	unsigned long prg_wait;
 
 	BUG_ON(!card);
 
@@ -419,30 +420,38 @@ int mmc_interrupt_hpi(struct mmc_card *card)
 		goto out;
 	}
 
-	/*
-	 * If the card status is in PRG-state, we can send the HPI command.
-	 */
-	if (R1_CURRENT_STATE(status) == R1_STATE_PRG) {
-		do {
-			/*
-			 * We don't know when the HPI command will finish
-			 * processing, so we need to resend HPI until out
-			 * of prg-state, and keep checking the card status
-			 * with SEND_STATUS.  If a timeout error occurs when
-			 * sending the HPI command, we are already out of
-			 * prg-state.
-			 */
-			err = mmc_send_hpi_cmd(card, &status);
-			if (err)
-				pr_debug("%s: abort HPI (%d error)\n",
-					 mmc_hostname(card->host), err);
+	switch (R1_CURRENT_STATE(status)) {
+	case R1_STATE_IDLE:
+	case R1_STATE_READY:
+	case R1_STATE_STBY:
+		/*
+		 * In idle states, HPI is not needed and the caller
+		 * can issue the next intended command immediately
+		 */
+		goto out;
+	case R1_STATE_PRG:
+		break;
+	default:
+		/* In all other states, it's illegal to issue HPI */
+		pr_debug("%s: HPI cannot be sent. Card state=%d\n",
+			mmc_hostname(card->host), R1_CURRENT_STATE(status));
+		err = -EINVAL;
+		goto out;
+	}
 
-			err = mmc_send_status(card, &status);
-			if (err)
-				break;
-		} while (R1_CURRENT_STATE(status) == R1_STATE_PRG);
-	} else
-		pr_debug("%s: Left prg-state\n", mmc_hostname(card->host));
+	err = mmc_send_hpi_cmd(card, &status);
+	if (err)
+		goto out;
+
+	prg_wait = jiffies + msecs_to_jiffies(card->ext_csd.out_of_int_time);
+	do {
+		err = mmc_send_status(card, &status);
+
+		if (!err && R1_CURRENT_STATE(status) == R1_STATE_TRAN)
+			break;
+		if (time_after(jiffies, prg_wait))
+			err = -ETIMEDOUT;
+	} while (!err);
 
 out:
 	mmc_release_host(card->host);

commit fa5501890d8974301042e0202d342a6cbe8609f4
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Wed May 9 16:15:26 2012 +0200

    mmc: core: Prevent eMMC VCC supply to be cut from late init
    
    For eMMC cards that has been initialized from a bootloader,
    the VCC voltage supply must not be cut in an uncontrolled
    manner, without first sending SLEEP or POWEROFF_NOTIFY.
    
    The regulator_init_complete late initcall, may cut the VCC
    regulator if it's reference counter is zero. To be able to
    prevent the regulator from being cut, mmc_start_host, which
    should execute at device init and thus before late init,
    calls mmc_power_up. Then the host driver is able to increase
    the reference to the regulator.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index ba821fe70bca..0b6141d29dbd 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -42,6 +42,7 @@
 #include "sdio_ops.h"
 
 static struct workqueue_struct *workqueue;
+static const unsigned freqs[] = { 400000, 300000, 200000, 100000 };
 
 /*
  * Enabling software CRCs on the data blocks can be a significant (30%)
@@ -1157,6 +1158,9 @@ static void mmc_power_up(struct mmc_host *host)
 {
 	int bit;
 
+	if (host->ios.power_mode == MMC_POWER_ON)
+		return;
+
 	mmc_host_clk_hold(host);
 
 	/* If ocr is set, we use it */
@@ -1199,6 +1203,10 @@ static void mmc_power_up(struct mmc_host *host)
 void mmc_power_off(struct mmc_host *host)
 {
 	int err = 0;
+
+	if (host->ios.power_mode == MMC_POWER_OFF)
+		return;
+
 	mmc_host_clk_hold(host);
 
 	host->ios.clock = 0;
@@ -2005,7 +2013,6 @@ EXPORT_SYMBOL(mmc_detect_card_removed);
 
 void mmc_rescan(struct work_struct *work)
 {
-	static const unsigned freqs[] = { 400000, 300000, 200000, 100000 };
 	struct mmc_host *host =
 		container_of(work, struct mmc_host, detect.work);
 	int i;
@@ -2044,8 +2051,12 @@ void mmc_rescan(struct work_struct *work)
 	 */
 	mmc_bus_put(host);
 
-	if (host->ops->get_cd && host->ops->get_cd(host) == 0)
+	if (host->ops->get_cd && host->ops->get_cd(host) == 0) {
+		mmc_claim_host(host);
+		mmc_power_off(host);
+		mmc_release_host(host);
 		goto out;
+	}
 
 	mmc_claim_host(host);
 	for (i = 0; i < ARRAY_SIZE(freqs); i++) {
@@ -2063,7 +2074,8 @@ void mmc_rescan(struct work_struct *work)
 
 void mmc_start_host(struct mmc_host *host)
 {
-	mmc_power_off(host);
+	host->f_init = max(freqs[0], host->f_min);
+	mmc_power_up(host);
 	mmc_detect_change(host, 0);
 }
 

commit 7c5709194096beea1ab6e6db46768d70a068efb0
Author: Ulf Hansson <ulf.hansson@stericsson.com>
Date:   Thu Apr 19 11:55:25 2012 +0200

    mmc: core: Do not pre-claim host in suspend
    
    Since SDIO drivers may want to do some SDIO operations in their suspend
    callback functions, we must not keep the host claimed when calling them.
    
    Daniel Drake reported that libertas_sdio encountered a deadlock in its
    suspend function.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@stericsson.com>
    Tested-by: Daniel Drake <dsd@laptop.org>
    [stable@: please apply to 3.2-stable and 3.3-stable]
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index e541efbf3256..ba821fe70bca 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2238,6 +2238,7 @@ int mmc_cache_ctrl(struct mmc_host *host, u8 enable)
 			mmc_card_is_removable(host))
 		return err;
 
+	mmc_claim_host(host);
 	if (card && mmc_card_mmc(card) &&
 			(card->ext_csd.cache_size > 0)) {
 		enable = !!enable;
@@ -2255,6 +2256,7 @@ int mmc_cache_ctrl(struct mmc_host *host, u8 enable)
 				card->ext_csd.cache_ctrl = enable;
 		}
 	}
+	mmc_release_host(host);
 
 	return err;
 }
@@ -2272,49 +2274,32 @@ int mmc_suspend_host(struct mmc_host *host)
 
 	cancel_delayed_work(&host->detect);
 	mmc_flush_scheduled_work();
-	if (mmc_try_claim_host(host)) {
-		err = mmc_cache_ctrl(host, 0);
-		mmc_release_host(host);
-	} else {
-		err = -EBUSY;
-	}
 
+	err = mmc_cache_ctrl(host, 0);
 	if (err)
 		goto out;
 
 	mmc_bus_get(host);
 	if (host->bus_ops && !host->bus_dead) {
 
-		/*
-		 * A long response time is not acceptable for device drivers
-		 * when doing suspend. Prevent mmc_claim_host in the suspend
-		 * sequence, to potentially wait "forever" by trying to
-		 * pre-claim the host.
-		 */
-		if (mmc_try_claim_host(host)) {
-			if (host->bus_ops->suspend) {
-				err = host->bus_ops->suspend(host);
-			}
-			mmc_release_host(host);
+		if (host->bus_ops->suspend)
+			err = host->bus_ops->suspend(host);
 
-			if (err == -ENOSYS || !host->bus_ops->resume) {
-				/*
-				 * We simply "remove" the card in this case.
-				 * It will be redetected on resume.  (Calling
-				 * bus_ops->remove() with a claimed host can
-				 * deadlock.)
-				 */
-				if (host->bus_ops->remove)
-					host->bus_ops->remove(host);
-				mmc_claim_host(host);
-				mmc_detach_bus(host);
-				mmc_power_off(host);
-				mmc_release_host(host);
-				host->pm_flags = 0;
-				err = 0;
-			}
-		} else {
-			err = -EBUSY;
+		if (err == -ENOSYS || !host->bus_ops->resume) {
+			/*
+			 * We simply "remove" the card in this case.
+			 * It will be redetected on resume.  (Calling
+			 * bus_ops->remove() with a claimed host can
+			 * deadlock.)
+			 */
+			if (host->bus_ops->remove)
+				host->bus_ops->remove(host);
+			mmc_claim_host(host);
+			mmc_detach_bus(host);
+			mmc_power_off(host);
+			mmc_release_host(host);
+			host->pm_flags = 0;
+			err = 0;
 		}
 	}
 	mmc_bus_put(host);

commit 283028122db37621b124f079ca8eae5b64807ad4
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Thu Apr 5 14:45:48 2012 +0300

    mmc: fixes for eMMC v4.5 sanitize operation
    
    eMMC v4.5 sanitize operation erases all copies of unmapped
    data.  However trim or erase operations must be used first
    to unmap the required sectors.  That was not being done.
    
    Fixes apply to linux 3.2 on.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Cc: <stable@vger.kernel.org>
    Acked-by: Jaehoon Chung <jh80.chung@samsung.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 83db5ef96bb0..e541efbf3256 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1702,6 +1702,8 @@ EXPORT_SYMBOL(mmc_can_discard);
 
 int mmc_can_sanitize(struct mmc_card *card)
 {
+	if (!mmc_can_trim(card) && !mmc_can_erase(card))
+		return 0;
 	if (card->ext_csd.sec_feature_support & EXT_CSD_SEC_SANITIZE)
 		return 1;
 	return 0;

commit 7194efb8f063ee3aa0cb50d9002348887e68ec10
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Thu Apr 5 14:45:47 2012 +0300

    mmc: fixes for eMMC v4.5 discard operation
    
    eMMC v4.5 discard operation is significantly different from the
    existing trim operation because it is not guaranteed to work with
    the new sanitize operation.  Consequently mmc_can_trim() is
    separated from mmc_can_discard().
    
    Also the new discard operation does not result in the sectors being
    set to all-zeros, so discard_zeroes_data must not be set.
    
    In addition, the new discard has the same timeout as trim, but from
    v4.5 trim is defined to use the hc timeout.  The timeout calculation
    is adjusted accordingly.
    
    Fixes apply to linux 3.2 on.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Cc: <stable@vger.kernel.org>
    Acked-by: Jaehoon Chung <jh80.chung@samsung.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 7474c47b9c08..83db5ef96bb0 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1409,7 +1409,10 @@ static unsigned int mmc_mmc_erase_timeout(struct mmc_card *card,
 {
 	unsigned int erase_timeout;
 
-	if (card->ext_csd.erase_group_def & 1) {
+	if (arg == MMC_DISCARD_ARG ||
+	    (arg == MMC_TRIM_ARG && card->ext_csd.rev >= 6)) {
+		erase_timeout = card->ext_csd.trim_timeout;
+	} else if (card->ext_csd.erase_group_def & 1) {
 		/* High Capacity Erase Group Size uses HC timeouts */
 		if (arg == MMC_TRIM_ARG)
 			erase_timeout = card->ext_csd.trim_timeout;
@@ -1681,8 +1684,6 @@ int mmc_can_trim(struct mmc_card *card)
 {
 	if (card->ext_csd.sec_feature_support & EXT_CSD_SEC_GB_CL_EN)
 		return 1;
-	if (mmc_can_discard(card))
-		return 1;
 	return 0;
 }
 EXPORT_SYMBOL(mmc_can_trim);

commit 3bdc9ba892d6a294d16e9e6e0c4041926aa3d58c
Author: Paul Walmsley <paul@pwsan.com>
Date:   Mon Mar 12 04:58:00 2012 -0600

    mmc: use really long write timeout to deal with crappy cards
    
    Several people have noticed that crappy SD cards take much longer to
    complete multiple block writes than the 300ms that Linux specifies.
    Try to work around this by using a three second write timeout instead.
    
    This is a generalized version of a patch from Chase Maupin
    <Chase.Maupin@ti.com>, whose patch description said:
    
    * With certain SD cards timeouts like the following have been seen
      due to an improper calculation of the dto value:
        mmcblk0: error -110 transferring data, sector 4126233, nr 8,
        card status 0xc00
    * By removing the dto calculation and setting the timeout value
      to the maximum specified by the SD card specification part A2
      section 2.2.15 these timeouts can be avoided.
    * This change has been used by beagleboard users as well as the
      Texas Instruments SDK without a negative impact.
    * There are multiple discussion threads about this but the most
      relevant ones are:
        * http://talk.maemo.org/showthread.php?p=1000707#post1000707
        * http://www.mail-archive.com/linux-omap@vger.kernel.org/msg42213.html
    * Original proposal for this fix was done by Sukumar Ghoral of
      Texas Instruments
    * Tested using a Texas Instruments AM335x EVM
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Tested-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 14f262e9246d..7474c47b9c08 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -527,10 +527,14 @@ void mmc_set_data_timeout(struct mmc_data *data, const struct mmc_card *card)
 
 		if (data->flags & MMC_DATA_WRITE)
 			/*
-			 * The limit is really 250 ms, but that is
-			 * insufficient for some crappy cards.
+			 * The MMC spec "It is strongly recommended
+			 * for hosts to implement more than 500ms
+			 * timeout value even if the card indicates
+			 * the 250ms maximum busy length."  Even the
+			 * previous value of 300ms is known to be
+			 * insufficient for some cards.
 			 */
-			limit_us = 300000;
+			limit_us = 3000000;
 		else
 			limit_us = 100000;
 

commit 956d9fd5eb3cbb322440844ed341145707bd71f8
Author: Ulf Hansson <ulf.hansson@stericsson.com>
Date:   Mon Mar 5 15:52:43 2012 +0100

    mmc: core: Clean up after mmc_pre_req if card was removed
    
    Make sure mmc_start_req cancels the prepared job, if the request
    was prevented to be started due to the card has been removed.
    
    This bug was introduced in commit:
    mmc: allow upper layers to know immediately if card has been removed
    
    Signed-off-by: Ulf Hansson <ulf.hansson@stericsson.com>
    Reviewed-by: Per Forlin <per.forlin@stericsson.com>
    Tested-by: Jaehoon Chung <jh80.chung@samsung.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 9b56674ddc2a..14f262e9246d 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -249,16 +249,17 @@ static void mmc_wait_done(struct mmc_request *mrq)
 	complete(&mrq->completion);
 }
 
-static void __mmc_start_req(struct mmc_host *host, struct mmc_request *mrq)
+static int __mmc_start_req(struct mmc_host *host, struct mmc_request *mrq)
 {
 	init_completion(&mrq->completion);
 	mrq->done = mmc_wait_done;
 	if (mmc_card_removed(host->card)) {
 		mrq->cmd->error = -ENOMEDIUM;
 		complete(&mrq->completion);
-		return;
+		return -ENOMEDIUM;
 	}
 	mmc_start_request(host, mrq);
+	return 0;
 }
 
 static void mmc_wait_for_req_done(struct mmc_host *host,
@@ -342,6 +343,7 @@ struct mmc_async_req *mmc_start_req(struct mmc_host *host,
 				    struct mmc_async_req *areq, int *error)
 {
 	int err = 0;
+	int start_err = 0;
 	struct mmc_async_req *data = host->areq;
 
 	/* Prepare a new request */
@@ -351,30 +353,23 @@ struct mmc_async_req *mmc_start_req(struct mmc_host *host,
 	if (host->areq) {
 		mmc_wait_for_req_done(host, host->areq->mrq);
 		err = host->areq->err_check(host->card, host->areq);
-		if (err) {
-			/* post process the completed failed request */
-			mmc_post_req(host, host->areq->mrq, 0);
-			if (areq)
-				/*
-				 * Cancel the new prepared request, because
-				 * it can't run until the failed
-				 * request has been properly handled.
-				 */
-				mmc_post_req(host, areq->mrq, -EINVAL);
-
-			host->areq = NULL;
-			goto out;
-		}
 	}
 
-	if (areq)
-		__mmc_start_req(host, areq->mrq);
+	if (!err && areq)
+		start_err = __mmc_start_req(host, areq->mrq);
 
 	if (host->areq)
 		mmc_post_req(host, host->areq->mrq, 0);
 
-	host->areq = areq;
- out:
+	 /* Cancel a prepared request if it was not started. */
+	if ((err || start_err) && areq)
+			mmc_post_req(host, areq->mrq, -EINVAL);
+
+	if (err)
+		host->areq = NULL;
+	else
+		host->areq = areq;
+
 	if (error)
 		*error = err;
 	return data;

commit 907d2e7cc7ebba4ab398422a7f0435e1802be65b
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Wed Feb 29 09:17:21 2012 +0200

    mmc: start removing enable / disable API
    
    Most parts of the enable / disable API are no longer used and
    can be removed.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Tested-by: Venkatraman S <svenkatr@ti.com>
    Tested-by: Jaehoon Chung <jh80.chung@samsung.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 436409f7f7bd..9b56674ddc2a 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -604,105 +604,6 @@ unsigned int mmc_align_data_size(struct mmc_card *card, unsigned int sz)
 }
 EXPORT_SYMBOL(mmc_align_data_size);
 
-/**
- *	mmc_host_enable - enable a host.
- *	@host: mmc host to enable
- *
- *	Hosts that support power saving can use the 'enable' and 'disable'
- *	methods to exit and enter power saving states. For more information
- *	see comments for struct mmc_host_ops.
- */
-int mmc_host_enable(struct mmc_host *host)
-{
-	if (!(host->caps & MMC_CAP_DISABLE))
-		return 0;
-
-	if (host->en_dis_recurs)
-		return 0;
-
-	if (host->nesting_cnt++)
-		return 0;
-
-	cancel_delayed_work_sync(&host->disable);
-
-	if (host->enabled)
-		return 0;
-
-	if (host->ops->enable) {
-		int err;
-
-		host->en_dis_recurs = 1;
-		mmc_host_clk_hold(host);
-		err = host->ops->enable(host);
-		mmc_host_clk_release(host);
-		host->en_dis_recurs = 0;
-
-		if (err) {
-			pr_debug("%s: enable error %d\n",
-				 mmc_hostname(host), err);
-			return err;
-		}
-	}
-	host->enabled = 1;
-	return 0;
-}
-EXPORT_SYMBOL(mmc_host_enable);
-
-static int mmc_host_do_disable(struct mmc_host *host, int lazy)
-{
-	if (host->ops->disable) {
-		int err;
-
-		host->en_dis_recurs = 1;
-		mmc_host_clk_hold(host);
-		err = host->ops->disable(host, lazy);
-		mmc_host_clk_release(host);
-		host->en_dis_recurs = 0;
-
-		if (err < 0) {
-			pr_debug("%s: disable error %d\n",
-				 mmc_hostname(host), err);
-			return err;
-		}
-		if (err > 0) {
-			unsigned long delay = msecs_to_jiffies(err);
-
-			mmc_schedule_delayed_work(&host->disable, delay);
-		}
-	}
-	host->enabled = 0;
-	return 0;
-}
-
-/**
- *	mmc_host_disable - disable a host.
- *	@host: mmc host to disable
- *
- *	Hosts that support power saving can use the 'enable' and 'disable'
- *	methods to exit and enter power saving states. For more information
- *	see comments for struct mmc_host_ops.
- */
-int mmc_host_disable(struct mmc_host *host)
-{
-	int err;
-
-	if (!(host->caps & MMC_CAP_DISABLE))
-		return 0;
-
-	if (host->en_dis_recurs)
-		return 0;
-
-	if (--host->nesting_cnt)
-		return 0;
-
-	if (!host->enabled)
-		return 0;
-
-	err = mmc_host_do_disable(host, 0);
-	return err;
-}
-EXPORT_SYMBOL(mmc_host_disable);
-
 /**
  *	__mmc_claim_host - exclusively claim a host
  *	@host: mmc host to claim
@@ -741,8 +642,8 @@ int __mmc_claim_host(struct mmc_host *host, atomic_t *abort)
 		wake_up(&host->wq);
 	spin_unlock_irqrestore(&host->lock, flags);
 	remove_wait_queue(&host->wq, &wait);
-	if (!stop)
-		mmc_host_enable(host);
+	if (host->ops->enable && !stop && host->claim_cnt == 1)
+		host->ops->enable(host);
 	return stop;
 }
 
@@ -767,21 +668,28 @@ int mmc_try_claim_host(struct mmc_host *host)
 		claimed_host = 1;
 	}
 	spin_unlock_irqrestore(&host->lock, flags);
+	if (host->ops->enable && claimed_host && host->claim_cnt == 1)
+		host->ops->enable(host);
 	return claimed_host;
 }
 EXPORT_SYMBOL(mmc_try_claim_host);
 
 /**
- *	mmc_do_release_host - release a claimed host
+ *	mmc_release_host - release a host
  *	@host: mmc host to release
  *
- *	If you successfully claimed a host, this function will
- *	release it again.
+ *	Release a MMC host, allowing others to claim the host
+ *	for their operations.
  */
-void mmc_do_release_host(struct mmc_host *host)
+void mmc_release_host(struct mmc_host *host)
 {
 	unsigned long flags;
 
+	WARN_ON(!host->claimed);
+
+	if (host->ops->disable && host->claim_cnt == 1)
+		host->ops->disable(host);
+
 	spin_lock_irqsave(&host->lock, flags);
 	if (--host->claim_cnt) {
 		/* Release for nested claim */
@@ -793,67 +701,6 @@ void mmc_do_release_host(struct mmc_host *host)
 		wake_up(&host->wq);
 	}
 }
-EXPORT_SYMBOL(mmc_do_release_host);
-
-void mmc_host_deeper_disable(struct work_struct *work)
-{
-	struct mmc_host *host =
-		container_of(work, struct mmc_host, disable.work);
-
-	/* If the host is claimed then we do not want to disable it anymore */
-	if (!mmc_try_claim_host(host))
-		return;
-	mmc_host_do_disable(host, 1);
-	mmc_do_release_host(host);
-}
-
-/**
- *	mmc_host_lazy_disable - lazily disable a host.
- *	@host: mmc host to disable
- *
- *	Hosts that support power saving can use the 'enable' and 'disable'
- *	methods to exit and enter power saving states. For more information
- *	see comments for struct mmc_host_ops.
- */
-int mmc_host_lazy_disable(struct mmc_host *host)
-{
-	if (!(host->caps & MMC_CAP_DISABLE))
-		return 0;
-
-	if (host->en_dis_recurs)
-		return 0;
-
-	if (--host->nesting_cnt)
-		return 0;
-
-	if (!host->enabled)
-		return 0;
-
-	if (host->disable_delay) {
-		mmc_schedule_delayed_work(&host->disable,
-				msecs_to_jiffies(host->disable_delay));
-		return 0;
-	} else
-		return mmc_host_do_disable(host, 1);
-}
-EXPORT_SYMBOL(mmc_host_lazy_disable);
-
-/**
- *	mmc_release_host - release a host
- *	@host: mmc host to release
- *
- *	Release a MMC host, allowing others to claim the host
- *	for their operations.
- */
-void mmc_release_host(struct mmc_host *host)
-{
-	WARN_ON(!host->claimed);
-
-	mmc_host_lazy_disable(host);
-
-	mmc_do_release_host(host);
-}
-
 EXPORT_SYMBOL(mmc_release_host);
 
 /*
@@ -2227,8 +2074,6 @@ void mmc_stop_host(struct mmc_host *host)
 	spin_unlock_irqrestore(&host->lock, flags);
 #endif
 
-	if (host->caps & MMC_CAP_DISABLE)
-		cancel_delayed_work(&host->disable);
 	cancel_delayed_work_sync(&host->detect);
 	mmc_flush_scheduled_work();
 
@@ -2423,13 +2268,11 @@ int mmc_suspend_host(struct mmc_host *host)
 {
 	int err = 0;
 
-	if (host->caps & MMC_CAP_DISABLE)
-		cancel_delayed_work(&host->disable);
 	cancel_delayed_work(&host->detect);
 	mmc_flush_scheduled_work();
 	if (mmc_try_claim_host(host)) {
 		err = mmc_cache_ctrl(host, 0);
-		mmc_do_release_host(host);
+		mmc_release_host(host);
 	} else {
 		err = -EBUSY;
 	}
@@ -2450,7 +2293,7 @@ int mmc_suspend_host(struct mmc_host *host)
 			if (host->bus_ops->suspend) {
 				err = host->bus_ops->suspend(host);
 			}
-			mmc_do_release_host(host);
+			mmc_release_host(host);
 
 			if (err == -ENOSYS || !host->bus_ops->resume) {
 				/*

commit f0cc9cf99326926fd76f77645c48d16d647802eb
Author: Ulf Hansson <ulf.hansson@stericsson.com>
Date:   Mon Feb 6 10:42:39 2012 +0100

    mmc: core: Detect card removal on I/O error
    
    To prevent I/O as soon as possible at card removal, a new detect work is
    re-scheduled without a delay to let a rescan remove the card device as
    soon as possible.
    
    Additionally, MMC_CAP2_DETECT_ON_ERR can now be used to handle "slowly"
    removed cards that a scheduled detect work did not detect as removed.
    To prevent further I/O requests for these lingering removed cards,
    check if card has been removed and then schedule a detect work to
    properly remove it.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@stericsson.com>
    Reviewed-by: Namjae Jeon <linkinjeon@gmail.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index faa0af10d334..436409f7f7bd 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2121,18 +2121,36 @@ int _mmc_detect_card_removed(struct mmc_host *host)
 int mmc_detect_card_removed(struct mmc_host *host)
 {
 	struct mmc_card *card = host->card;
+	int ret;
 
 	WARN_ON(!host->claimed);
+
+	if (!card)
+		return 1;
+
+	ret = mmc_card_removed(card);
 	/*
 	 * The card will be considered unchanged unless we have been asked to
 	 * detect a change or host requires polling to provide card detection.
 	 */
-	if (card && !host->detect_change && !(host->caps & MMC_CAP_NEEDS_POLL))
-		return mmc_card_removed(card);
+	if (!host->detect_change && !(host->caps & MMC_CAP_NEEDS_POLL) &&
+	    !(host->caps2 & MMC_CAP2_DETECT_ON_ERR))
+		return ret;
 
 	host->detect_change = 0;
+	if (!ret) {
+		ret = _mmc_detect_card_removed(host);
+		if (ret && (host->caps2 & MMC_CAP2_DETECT_ON_ERR)) {
+			/*
+			 * Schedule a detect work as soon as possible to let a
+			 * rescan handle the card removal.
+			 */
+			cancel_delayed_work(&host->detect);
+			mmc_detect_change(host, 0);
+		}
+	}
 
-	return _mmc_detect_card_removed(host);
+	return ret;
 }
 EXPORT_SYMBOL(mmc_detect_card_removed);
 

commit 7b2fd4f23f72c13a78c0892d330dde305ef2fb80
Author: Jaehoon Chung <jh80.chung@samsung.com>
Date:   Tue Feb 7 14:13:10 2012 +0900

    mmc: core: add a debug message for SET_BLOCK_COUNT
    
    This patch is added just debug message.  Almost features need to use the
    CMD23.  But we didn't see the debug message for sbc.  If sbc's message
    can see, should be help for debugging.  (We can check whether use the
    cmd23 or not.)
    
    Signed-off-by: Jaehoon Chung <jh80.chung@samsung.com>
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 132378b89d76..faa0af10d334 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -188,6 +188,12 @@ mmc_start_request(struct mmc_host *host, struct mmc_request *mrq)
 	struct scatterlist *sg;
 #endif
 
+	if (mrq->sbc) {
+		pr_debug("<%s: starting CMD%u arg %08x flags %08x>\n",
+			 mmc_hostname(host), mrq->sbc->opcode,
+			 mrq->sbc->arg, mrq->sbc->flags);
+	}
+
 	pr_debug("%s: starting CMD%u arg %08x flags %08x\n",
 		 mmc_hostname(host), mrq->cmd->opcode,
 		 mrq->cmd->arg, mrq->cmd->flags);

commit e7747475b61fdc2a4a412475a9d64d8c309916e3
Author: Ulf Hansson <ulf.hansson@stericsson.com>
Date:   Thu Mar 1 13:18:05 2012 +0100

    mmc: core: Fixup suspend/resume issues for UHS-I cards
    
    Even if cards supports 1.8V I/O voltage those should anyway be
    initialized at 3.3V I/O according to (e)MMC, SD and SDIO specs.
    Some eMMC and embedded SDIO devices are able to be initialized
    at 1.8V as well, but it is better to be safe.
    
    Do note that initialization in this context means that the card
    has been completely powered off, otherwise the card will remain
    at the last I/O voltage level that were negotitiated.
    
    Due to the above being taken care of the suspend/resume issues
    for UHS-I SD-cards has been fixed.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@stericsson.com>
    Acked-by: Philip Rakity <prakity@marvell.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Tested-by: Subhash Jadavani <subhashj@codeaurora.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 690255c7d4dc..132378b89d76 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2068,6 +2068,9 @@ static int mmc_rescan_try_freq(struct mmc_host *host, unsigned freq)
 	 */
 	mmc_hw_reset_for_init(host);
 
+	/* Initialization should be done at 3.3 V I/O voltage. */
+	mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_330, 0);
+
 	/*
 	 * sdio_reset sends CMD52 to reset card.  Since we do not know
 	 * if the card is being re-initialized, just send it.  CMD52

commit 3e73c36b4dc224529d0b0c0d5d69c0dacd793c42
Author: Girish K S <girish.shivananjappa@linaro.org>
Date:   Tue Jan 31 15:44:03 2012 +0530

    mmc: core: Fix PowerOff Notify suspend/resume
    
    Modified the mmc_poweroff to resume before sending the poweroff
    notification command. In sleep mode only AWAKE and RESET commands are
    allowed, so before sending the poweroff notification command resume from
    sleep mode and then send the notification command.
    
    PowerOff Notify is tested on a Synopsis Designware Host Controller
    (eMMC 4.5). The suspend to RAM and resume works fine.
    
    Signed-off-by: Girish K S <girish.shivananjappa@linaro.org>
    Tested-by: Girish K S <girish.shivananjappa@linaro.org>
    Reviewed-by: Saugata Das <saugata.das@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 18661554e79c..690255c7d4dc 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1256,6 +1256,7 @@ static void mmc_poweroff_notify(struct mmc_host *host)
 	int err = 0;
 
 	card = host->card;
+	mmc_claim_host(host);
 
 	/*
 	 * Send power notify command only if card
@@ -1286,6 +1287,7 @@ static void mmc_poweroff_notify(struct mmc_host *host)
 		/* Set the card state to no notification after the poweroff */
 		card->poweroff_notify_state = MMC_NO_POWER_NOTIFICATION;
 	}
+	mmc_release_host(host);
 }
 
 /*
@@ -1344,12 +1346,28 @@ static void mmc_power_up(struct mmc_host *host)
 
 void mmc_power_off(struct mmc_host *host)
 {
+	int err = 0;
 	mmc_host_clk_hold(host);
 
 	host->ios.clock = 0;
 	host->ios.vdd = 0;
 
-	mmc_poweroff_notify(host);
+	/*
+	 * For eMMC 4.5 device send AWAKE command before
+	 * POWER_OFF_NOTIFY command, because in sleep state
+	 * eMMC 4.5 devices respond to only RESET and AWAKE cmd
+	 */
+	if (host->card && mmc_card_is_sleep(host->card) &&
+	    host->bus_ops->resume) {
+		err = host->bus_ops->resume(host);
+
+		if (!err)
+			mmc_poweroff_notify(host);
+		else
+			pr_warning("%s: error %d during resume "
+				   "(continue with poweroff sequence)\n",
+				   mmc_hostname(host), err);
+	}
 
 	/*
 	 * Reset ocr mask to be the highest possible voltage supported for
@@ -2403,12 +2421,6 @@ int mmc_suspend_host(struct mmc_host *host)
 		 */
 		if (mmc_try_claim_host(host)) {
 			if (host->bus_ops->suspend) {
-				/*
-				 * For eMMC 4.5 device send notify command
-				 * before sleep, because in sleep state eMMC 4.5
-				 * devices respond to only RESET and AWAKE cmd
-				 */
-				mmc_poweroff_notify(host);
 				err = host->bus_ops->suspend(host);
 			}
 			mmc_do_release_host(host);

commit 6e8201f57c9359c9c5dc8f9805c15a4392492a10
Author: Jaehoon Chung <jh80.chung@samsung.com>
Date:   Mon Jan 16 17:49:01 2012 +0900

    mmc: core: add the capability for broken voltage
    
    There is an understood mismatch between the voltage the host controller is
    set to and the voltage supplied to the card by a fixed voltage regulator.
    Teaching the driver to accept the mismatch is overly complicated.  Instead
    just accept the regulator's voltage.
    
    This patch adds MMC_CAP2_BROKEN_VOLTAGE.
    
    If the voltage didn't satisfy between min_uV and max_uV, try to change
    the voltage in core.c.  When changing the voltage, maybe use
    regulator_set_voltage().
    
    In regulator_set_voltage(), check the below condition.
    
            /* sanity check */
            if (!rdev->desc->ops->set_voltage &&
                !rdev->desc->ops->set_voltage_sel) {
                    ret = -EINVAL;
                    goto out;
            }
    
    If some board should use the fixed-regulator, always return -EINVAL.
    Then, eMMC didn't initialize always.
    
    So if use a fixed-regulator, we need to add the MMC_CAP2_BROKEN_VOLTAGE.
    
    Signed-off-by: Jaehoon Chung <jh80.chung@samsung.com>
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Acked-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index b3063b741df3..18661554e79c 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1131,6 +1131,10 @@ int mmc_regulator_set_ocr(struct mmc_host *mmc,
 		 * might not allow this operation
 		 */
 		voltage = regulator_get_voltage(supply);
+
+		if (mmc->caps2 & MMC_CAP2_BROKEN_VOLTAGE)
+			min_uV = max_uV = voltage;
+
 		if (voltage < 0)
 			result = voltage;
 		else if (voltage < min_uV || voltage > max_uV)

commit 2c4967f741e87cdd63de7271b97807041dccbf3b
Author: Sujit Reddy Thumma <sthumma@codeaurora.org>
Date:   Sat Feb 4 16:14:50 2012 -0500

    mmc: core: Ensure clocks are always enabled before host interaction
    
    Ensure clocks are always enabled before any interaction with the
    host controller driver. This makes sure that there is no race
    between host execution and the core layer turning off clocks
    in different context with clock gating framework.
    
    Signed-off-by: Sujit Reddy Thumma <sthumma@codeaurora.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Per Forlin <per.forlin@stericsson.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index f545a3e6eb80..b3063b741df3 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -290,8 +290,11 @@ static void mmc_wait_for_req_done(struct mmc_host *host,
 static void mmc_pre_req(struct mmc_host *host, struct mmc_request *mrq,
 		 bool is_first_req)
 {
-	if (host->ops->pre_req)
+	if (host->ops->pre_req) {
+		mmc_host_clk_hold(host);
 		host->ops->pre_req(host, mrq, is_first_req);
+		mmc_host_clk_release(host);
+	}
 }
 
 /**
@@ -306,8 +309,11 @@ static void mmc_pre_req(struct mmc_host *host, struct mmc_request *mrq,
 static void mmc_post_req(struct mmc_host *host, struct mmc_request *mrq,
 			 int err)
 {
-	if (host->ops->post_req)
+	if (host->ops->post_req) {
+		mmc_host_clk_hold(host);
 		host->ops->post_req(host, mrq, err);
+		mmc_host_clk_release(host);
+	}
 }
 
 /**
@@ -620,7 +626,9 @@ int mmc_host_enable(struct mmc_host *host)
 		int err;
 
 		host->en_dis_recurs = 1;
+		mmc_host_clk_hold(host);
 		err = host->ops->enable(host);
+		mmc_host_clk_release(host);
 		host->en_dis_recurs = 0;
 
 		if (err) {
@@ -640,7 +648,9 @@ static int mmc_host_do_disable(struct mmc_host *host, int lazy)
 		int err;
 
 		host->en_dis_recurs = 1;
+		mmc_host_clk_hold(host);
 		err = host->ops->disable(host, lazy);
+		mmc_host_clk_release(host);
 		host->en_dis_recurs = 0;
 
 		if (err < 0) {
@@ -1203,8 +1213,11 @@ int mmc_set_signal_voltage(struct mmc_host *host, int signal_voltage, bool cmd11
 
 	host->ios.signal_voltage = signal_voltage;
 
-	if (host->ops->start_signal_voltage_switch)
+	if (host->ops->start_signal_voltage_switch) {
+		mmc_host_clk_hold(host);
 		err = host->ops->start_signal_voltage_switch(host, &host->ios);
+		mmc_host_clk_release(host);
+	}
 
 	return err;
 }

commit 0a80939b3e6af4b0dc93bf88ec02fd7e90a16f1b
Merge: 0b48d42235ca 72db395ffadb
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jan 14 12:32:16 2012 -0800

    Merge tag 'for-linus' of git://github.com/rustyrussell/linux
    
    Autogenerated GPG tag for Rusty D1ADB8F1: 15EE 8D6C AB0E 7F0C F999  BFCB D920 0E6C D1AD B8F1
    
    * tag 'for-linus' of git://github.com/rustyrussell/linux:
      module_param: check that bool parameters really are bool.
      intelfbdrv.c: bailearly is an int module_param
      paride/pcd: fix bool verbose module parameter.
      module_param: make bool parameters really bool (drivers & misc)
      module_param: make bool parameters really bool (arch)
      module_param: make bool parameters really bool (core code)
      kernel/async: remove redundant declaration.
      printk: fix unnecessary module_param_name.
      lirc_parallel: fix module parameter description.
      module_param: avoid bool abuse, add bint for special cases.
      module_param: check type correctness for module_param_array
      modpost: use linker section to generate table.
      modpost: use a table rather than a giant if/else statement.
      modules: sysfs - export: taint, coresize, initsize
      kernel/params: replace DEBUGP with pr_debug
      module: replace DEBUGP with pr_debug
      module: struct module_ref should contains long fields
      module: Fix performance regression on modules with large symbol tables
      module: Add comments describing how the "strmap" logic works
    
    Fix up conflicts in scripts/mod/file2alias.c due to the new linker-
    generated table approach to adding __mod_*_device_table entries.  The
    ARM sa11x0 mcp bus needed to be converted to that too.

commit 90ab5ee94171b3e28de6bb42ee30b527014e0be7
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Fri Jan 13 09:32:20 2012 +1030

    module_param: make bool parameters really bool (drivers & misc)
    
    module_param(bool) used to counter-intuitively take an int.  In
    fddd5201 (mid-2009) we allowed bool or int/unsigned int using a messy
    trick.
    
    It's time to remove the int/unsigned int option.  For this version
    it'll simply give a warning, but it'll break next kernel version.
    
    Acked-by: Mauro Carvalho Chehab <mchehab@redhat.com>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 950b97d7412a..75d7d7e17366 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -48,7 +48,7 @@ static struct workqueue_struct *workqueue;
  * performance cost, and for other reasons may not always be desired.
  * So we allow it it to be disabled.
  */
-int use_spi_crc = 1;
+bool use_spi_crc = 1;
 module_param(use_spi_crc, bool, 0);
 
 /*
@@ -58,9 +58,9 @@ module_param(use_spi_crc, bool, 0);
  * overridden if necessary.
  */
 #ifdef CONFIG_MMC_UNSAFE_RESUME
-int mmc_assume_removable;
+bool mmc_assume_removable;
 #else
-int mmc_assume_removable = 1;
+bool mmc_assume_removable = 1;
 #endif
 EXPORT_SYMBOL(mmc_assume_removable);
 module_param_named(removable, mmc_assume_removable, bool, 0644);

commit 0db13fc2abbb0b1a8d8efee20dfbd7f3c5d54022
Author: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
Date:   Wed Jan 4 15:28:45 2012 +0100

    mmc: fix a deadlock between system suspend and MMC block IO
    
    Performing MMC block IO with simultaneous STR can lead to a deadlock: the
    mmc_pm_notify() function claims the host and then calls bus .remove()
    method, which lands in mmc_blk_remove(), which calls mmc_blk_remove_req()
    then it goes to -> mmc_cleanup_queue() -> kthread_stop(), which waits for
    the mmc-block thread to stop. If the mmc-block thread at that time is
    processing block requests, it will also try to claim the host in
    mmc_blk_issue_rq() and block there. This patch fixes the problem by
    calling .remove() before claiming the host.
    
    Signed-off-by: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
    Acked-by: Arindam Nath <arindam.nath@amd.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 1da45e051328..bec0bf21c879 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2175,6 +2175,7 @@ void mmc_stop_host(struct mmc_host *host)
 
 	mmc_bus_get(host);
 	if (host->bus_ops && !host->bus_dead) {
+		/* Calling bus_ops->remove() with a claimed host can deadlock */
 		if (host->bus_ops->remove)
 			host->bus_ops->remove(host);
 
@@ -2398,7 +2399,9 @@ int mmc_suspend_host(struct mmc_host *host)
 			if (err == -ENOSYS || !host->bus_ops->resume) {
 				/*
 				 * We simply "remove" the card in this case.
-				 * It will be redetected on resume.
+				 * It will be redetected on resume.  (Calling
+				 * bus_ops->remove() with a claimed host can
+				 * deadlock.)
 				 */
 				if (host->bus_ops->remove)
 					host->bus_ops->remove(host);
@@ -2491,11 +2494,11 @@ int mmc_pm_notify(struct notifier_block *notify_block,
 		if (!host->bus_ops || host->bus_ops->suspend)
 			break;
 
-		mmc_claim_host(host);
-
+		/* Calling bus_ops->remove() with a claimed host can deadlock */
 		if (host->bus_ops->remove)
 			host->bus_ops->remove(host);
 
+		mmc_claim_host(host);
 		mmc_detach_bus(host);
 		mmc_power_off(host);
 		mmc_release_host(host);

commit 8bc0678b845531221ba2ea6efe34db66e587705b
Author: Seungwon Jeon <tgih.jun@samsung.com>
Date:   Fri Dec 9 17:47:17 2011 +0900

    mmc: core: Separate the timeout value for cache-ctrl
    
    Turning the cache off implies flushing cache which doesn't define
    maximum timeout unlike cache-on. This patch will apply the generic
    CMD6 timeout only for cache-on. Additionally the kernel message is
    added for checking failure case of cache-on.
    
    Signed-off-by: Seungwon Jeon <tgih.jun@samsung.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index be7569f3fb56..1da45e051328 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2321,6 +2321,7 @@ EXPORT_SYMBOL(mmc_flush_cache);
 int mmc_cache_ctrl(struct mmc_host *host, u8 enable)
 {
 	struct mmc_card *card = host->card;
+	unsigned int timeout;
 	int err = 0;
 
 	if (!(host->caps2 & MMC_CAP2_CACHE_CTRL) ||
@@ -2331,16 +2332,18 @@ int mmc_cache_ctrl(struct mmc_host *host, u8 enable)
 			(card->ext_csd.cache_size > 0)) {
 		enable = !!enable;
 
-		if (card->ext_csd.cache_ctrl ^ enable)
+		if (card->ext_csd.cache_ctrl ^ enable) {
+			timeout = enable ? card->ext_csd.generic_cmd6_time : 0;
 			err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
-					EXT_CSD_CACHE_CTRL, enable, 0);
-		if (err)
-			pr_err("%s: cache %s error %d\n",
-					mmc_hostname(card->host),
-					enable ? "on" : "off",
-					err);
-		else
-			card->ext_csd.cache_ctrl = enable;
+					EXT_CSD_CACHE_CTRL, enable, timeout);
+			if (err)
+				pr_err("%s: cache %s error %d\n",
+						mmc_hostname(card->host),
+						enable ? "on" : "off",
+						err);
+			else
+				card->ext_csd.cache_ctrl = enable;
+		}
 	}
 
 	return err;

commit aa9df4fb2adcc73d36fa41e23059519be770aaa5
Author: Ulf Hansson <ulf.hansson@stericsson.com>
Date:   Mon Dec 19 16:24:19 2011 +0100

    mmc: core: Add option to prevent eMMC sleep command
    
    Host may now use MMC_CAP2_NO_SLEEP_CMD to disable the use
    of eMMC sleep/awake command.
    
    This option can be used when your platform has a buggy
    kernel crash dump software, which is supposed to store
    the dump on the eMMC, but is not able to wake up the eMMC
    from sleep state.
    
    In particular, failures have been seen with u-boot; even if
    it is fixed there, platforms will be slow to update their
    bootloader binaries.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@stericsson.com>
    Reviewed-by: Hanumath Prasad <hanumath.prasad@stericsson.com>
    Reviewed-by: Srinidhi Kasagar <srinidhi.kasagar@stericsson.com>
    Acked-by: Subhash Jadavani <subhashj@codeaurora.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 22050525be84..be7569f3fb56 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2246,6 +2246,9 @@ int mmc_card_awake(struct mmc_host *host)
 {
 	int err = -ENOSYS;
 
+	if (host->caps2 & MMC_CAP2_NO_SLEEP_CMD)
+		return 0;
+
 	mmc_bus_get(host);
 
 	if (host->bus_ops && !host->bus_dead && host->bus_ops->awake)
@@ -2261,6 +2264,9 @@ int mmc_card_sleep(struct mmc_host *host)
 {
 	int err = -ENOSYS;
 
+	if (host->caps2 & MMC_CAP2_NO_SLEEP_CMD)
+		return 0;
+
 	mmc_bus_get(host);
 
 	if (host->bus_ops && !host->bus_dead && host->bus_ops->sleep)

commit 17e9ff559a7dbb7a6df332007d2ffcd3e7d83fba
Author: Seungwon Jeon <tgih.jun@samsung.com>
Date:   Mon Dec 26 18:03:05 2011 +0900

    mmc: core: Add claiming of hosts during mmc_cache_ctrl
    
    While calling mmc_cache_ctrl() a host is not claimed. This patch
    adds the mmc_try_claim_host() for quick response in suspend.
    
    Signed-off-by: Seungwon Jeon <tgih.jun@samsung.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index a2aa860956ef..22050525be84 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2355,7 +2355,13 @@ int mmc_suspend_host(struct mmc_host *host)
 		cancel_delayed_work(&host->disable);
 	cancel_delayed_work(&host->detect);
 	mmc_flush_scheduled_work();
-	err = mmc_cache_ctrl(host, 0);
+	if (mmc_try_claim_host(host)) {
+		err = mmc_cache_ctrl(host, 0);
+		mmc_do_release_host(host);
+	} else {
+		err = -EBUSY;
+	}
+
 	if (err)
 		goto out;
 

commit d30495048892980e5d453328d1cc9343b3f7e917
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Mon Nov 28 16:22:00 2011 +0200

    mmc: allow upper layers to know immediately if card has been removed
    
    Add a function mmc_detect_card_removed() which upper layers can use to
    determine immediately if a card has been removed. This function should
    be called after an I/O request fails so that all queued I/O requests
    can be errored out immediately instead of waiting for the card device
    to be removed.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Acked-by: Sujit Reddy Thumma <sthumma@codeaurora.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 950b97d7412a..a2aa860956ef 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -140,7 +140,7 @@ void mmc_request_done(struct mmc_host *host, struct mmc_request *mrq)
 			cmd->retries = 0;
 	}
 
-	if (err && cmd->retries) {
+	if (err && cmd->retries && !mmc_card_removed(host->card)) {
 		/*
 		 * Request starter must handle retries - see
 		 * mmc_wait_for_req_done().
@@ -247,6 +247,11 @@ static void __mmc_start_req(struct mmc_host *host, struct mmc_request *mrq)
 {
 	init_completion(&mrq->completion);
 	mrq->done = mmc_wait_done;
+	if (mmc_card_removed(host->card)) {
+		mrq->cmd->error = -ENOMEDIUM;
+		complete(&mrq->completion);
+		return;
+	}
 	mmc_start_request(host, mrq);
 }
 
@@ -259,7 +264,8 @@ static void mmc_wait_for_req_done(struct mmc_host *host,
 		wait_for_completion(&mrq->completion);
 
 		cmd = mrq->cmd;
-		if (!cmd->error || !cmd->retries)
+		if (!cmd->error || !cmd->retries ||
+		    mmc_card_removed(host->card))
 			break;
 
 		pr_debug("%s: req failed (CMD%u): %d, retrying...\n",
@@ -1456,7 +1462,7 @@ void mmc_detect_change(struct mmc_host *host, unsigned long delay)
 	WARN_ON(host->removed);
 	spin_unlock_irqrestore(&host->lock, flags);
 #endif
-
+	host->detect_change = 1;
 	mmc_schedule_delayed_work(&host->detect, delay);
 }
 
@@ -2049,6 +2055,43 @@ static int mmc_rescan_try_freq(struct mmc_host *host, unsigned freq)
 	return -EIO;
 }
 
+int _mmc_detect_card_removed(struct mmc_host *host)
+{
+	int ret;
+
+	if ((host->caps & MMC_CAP_NONREMOVABLE) || !host->bus_ops->alive)
+		return 0;
+
+	if (!host->card || mmc_card_removed(host->card))
+		return 1;
+
+	ret = host->bus_ops->alive(host);
+	if (ret) {
+		mmc_card_set_removed(host->card);
+		pr_debug("%s: card remove detected\n", mmc_hostname(host));
+	}
+
+	return ret;
+}
+
+int mmc_detect_card_removed(struct mmc_host *host)
+{
+	struct mmc_card *card = host->card;
+
+	WARN_ON(!host->claimed);
+	/*
+	 * The card will be considered unchanged unless we have been asked to
+	 * detect a change or host requires polling to provide card detection.
+	 */
+	if (card && !host->detect_change && !(host->caps & MMC_CAP_NEEDS_POLL))
+		return mmc_card_removed(card);
+
+	host->detect_change = 0;
+
+	return _mmc_detect_card_removed(host);
+}
+EXPORT_SYMBOL(mmc_detect_card_removed);
+
 void mmc_rescan(struct work_struct *work)
 {
 	static const unsigned freqs[] = { 400000, 300000, 200000, 100000 };
@@ -2069,6 +2112,8 @@ void mmc_rescan(struct work_struct *work)
 	    && !(host->caps & MMC_CAP_NONREMOVABLE))
 		host->bus_ops->detect(host);
 
+	host->detect_change = 0;
+
 	/*
 	 * Let mmc_bus_put() free the bus/bus_ops if we've found that
 	 * the card is no longer present.

commit 49df78074963c97e25debc3c67b72f059111607d
Author: Sujit Reddy Thumma <sthumma@codeaurora.org>
Date:   Wed Nov 23 08:43:18 2011 +0530

    mmc: core: Fix deadlock when the CONFIG_MMC_UNSAFE_RESUME is not defined
    
    mmc_suspend_host() tries to claim host during suspend
    and release it only when the bus suspend operation is
    compeleted. If CONFIG_MMC_UNSAFE_RESUME is defined and
    the host is flagged as removable, mmc_suspend_host()
    tries to remove the card. In this process, the file system
    sync can get blocked trying to acquire host which is already
    claimed by mmc_suspend_host() causing deadlock.
    
    Fix this deadlock by releasing host before ->remove() is called.
    
    Signed-off-by: Sujit Reddy Thumma <sthumma@codeaurora.org>
    Acked-by: Ulf Hansson <ulf.hansson@stericsson.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 271efeac860b..950b97d7412a 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2333,6 +2333,8 @@ int mmc_suspend_host(struct mmc_host *host)
 				mmc_poweroff_notify(host);
 				err = host->bus_ops->suspend(host);
 			}
+			mmc_do_release_host(host);
+
 			if (err == -ENOSYS || !host->bus_ops->resume) {
 				/*
 				 * We simply "remove" the card in this case.
@@ -2347,7 +2349,6 @@ int mmc_suspend_host(struct mmc_host *host)
 				host->pm_flags = 0;
 				err = 0;
 			}
-			mmc_do_release_host(host);
 		} else {
 			err = -EBUSY;
 		}

commit c99872a16fa7642987f30c750dc166674b0d8060
Author: Kyungmin Park <kyungmin.park@samsung.com>
Date:   Thu Nov 17 13:34:33 2011 +0900

    mmc: core: Fix typo at mmc_card_sleep
    
    Fix wrong bus_ops->sleep check.  (This isn't expected to have real-world
    consequences, because the mmc core always defines both 'awake' and
    'sleep' ops.)
    
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 7ee2e07f36f4..271efeac860b 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2218,7 +2218,7 @@ int mmc_card_sleep(struct mmc_host *host)
 
 	mmc_bus_get(host);
 
-	if (host->bus_ops && !host->bus_dead && host->bus_ops->awake)
+	if (host->bus_ops && !host->bus_dead && host->bus_ops->sleep)
 		err = host->bus_ops->sleep(host);
 
 	mmc_bus_put(host);

commit a80f16276388a177199204aa5b60f328d4464110
Author: Girish K S <girish.shivananjappa@linaro.org>
Date:   Tue Nov 15 11:55:46 2011 +0530

    mmc: core: Fix power_off_notify during suspend
    
    The eMMC 4.5 devices respond to only RESET and AWAKE command in the
    sleep state. Hence the mmc switch command to notify power off state
    should be sent before the device enters sleep state.
    
    This patch fixes the same.
    
    Signed-off-by: Girish K S <girish.shivananjappa@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 74a012ad2bab..7ee2e07f36f4 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1225,6 +1225,46 @@ void mmc_set_driver_type(struct mmc_host *host, unsigned int drv_type)
 	mmc_host_clk_release(host);
 }
 
+static void mmc_poweroff_notify(struct mmc_host *host)
+{
+	struct mmc_card *card;
+	unsigned int timeout;
+	unsigned int notify_type = EXT_CSD_NO_POWER_NOTIFICATION;
+	int err = 0;
+
+	card = host->card;
+
+	/*
+	 * Send power notify command only if card
+	 * is mmc and notify state is powered ON
+	 */
+	if (card && mmc_card_mmc(card) &&
+	    (card->poweroff_notify_state == MMC_POWERED_ON)) {
+
+		if (host->power_notify_type == MMC_HOST_PW_NOTIFY_SHORT) {
+			notify_type = EXT_CSD_POWER_OFF_SHORT;
+			timeout = card->ext_csd.generic_cmd6_time;
+			card->poweroff_notify_state = MMC_POWEROFF_SHORT;
+		} else {
+			notify_type = EXT_CSD_POWER_OFF_LONG;
+			timeout = card->ext_csd.power_off_longtime;
+			card->poweroff_notify_state = MMC_POWEROFF_LONG;
+		}
+
+		err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
+				 EXT_CSD_POWER_OFF_NOTIFICATION,
+				 notify_type, timeout);
+
+		if (err && err != -EBADMSG)
+			pr_err("Device failed to respond within %d poweroff "
+			       "time. Forcefully powering down the device\n",
+			       timeout);
+
+		/* Set the card state to no notification after the poweroff */
+		card->poweroff_notify_state = MMC_NO_POWER_NOTIFICATION;
+	}
+}
+
 /*
  * Apply power to the MMC stack.  This is a two-stage process.
  * First, we enable power to the card without the clock running.
@@ -1281,42 +1321,12 @@ static void mmc_power_up(struct mmc_host *host)
 
 void mmc_power_off(struct mmc_host *host)
 {
-	struct mmc_card *card;
-	unsigned int notify_type;
-	unsigned int timeout;
-	int err;
-
 	mmc_host_clk_hold(host);
 
-	card = host->card;
 	host->ios.clock = 0;
 	host->ios.vdd = 0;
 
-	if (card && mmc_card_mmc(card) &&
-	    (card->poweroff_notify_state == MMC_POWERED_ON)) {
-
-		if (host->power_notify_type == MMC_HOST_PW_NOTIFY_SHORT) {
-			notify_type = EXT_CSD_POWER_OFF_SHORT;
-			timeout = card->ext_csd.generic_cmd6_time;
-			card->poweroff_notify_state = MMC_POWEROFF_SHORT;
-		} else {
-			notify_type = EXT_CSD_POWER_OFF_LONG;
-			timeout = card->ext_csd.power_off_longtime;
-			card->poweroff_notify_state = MMC_POWEROFF_LONG;
-		}
-
-		err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
-				 EXT_CSD_POWER_OFF_NOTIFICATION,
-				 notify_type, timeout);
-
-		if (err && err != -EBADMSG)
-			pr_err("Device failed to respond within %d poweroff "
-			       "time. Forcefully powering down the device\n",
-			       timeout);
-
-		/* Set the card state to no notification after the poweroff */
-		card->poweroff_notify_state = MMC_NO_POWER_NOTIFICATION;
-	}
+	mmc_poweroff_notify(host);
 
 	/*
 	 * Reset ocr mask to be the highest possible voltage supported for
@@ -2314,8 +2324,15 @@ int mmc_suspend_host(struct mmc_host *host)
 		 * pre-claim the host.
 		 */
 		if (mmc_try_claim_host(host)) {
-			if (host->bus_ops->suspend)
+			if (host->bus_ops->suspend) {
+				/*
+				 * For eMMC 4.5 device send notify command
+				 * before sleep, because in sleep state eMMC 4.5
+				 * devices respond to only RESET and AWAKE cmd
+				 */
+				mmc_poweroff_notify(host);
 				err = host->bus_ops->suspend(host);
+			}
 			if (err == -ENOSYS || !host->bus_ops->resume) {
 				/*
 				 * We simply "remove" the card in this case.

commit 6de5fc9cf7de334912de4cfd2d06eb2d744d2afe
Author: Stefan Nilsson XK <stefan.xk.nilsson@stericsson.com>
Date:   Thu Nov 3 09:44:12 2011 +0100

    mmc: core: Add quirk for long data read time
    
    Adds a quirk that sets the data read timeout to a fixed value instead
    of relying on the information in the CSD. The timeout value chosen
    is 300ms since that has proven enough for the problematic cards found,
    but could be increased if other cards require this.
    
    This patch also enables this quirk for certain Micron cards known to
    have this problem.
    
    Signed-off-by: Stefan Nilsson XK <stefan.xk.nilsson@stericsson.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@stericsson.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Cc: <stable@kernel.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 5278ffb20e74..74a012ad2bab 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -529,6 +529,18 @@ void mmc_set_data_timeout(struct mmc_data *data, const struct mmc_card *card)
 			data->timeout_clks = 0;
 		}
 	}
+
+	/*
+	 * Some cards require longer data read timeout than indicated in CSD.
+	 * Address this by setting the read timeout to a "reasonably high"
+	 * value. For the cards tested, 300ms has proven enough. If necessary,
+	 * this value can be increased if other problematic cards require this.
+	 */
+	if (mmc_card_long_read_time(card) && data->flags & MMC_DATA_READ) {
+		data->timeout_ns = 300000000;
+		data->timeout_clks = 0;
+	}
+
 	/*
 	 * Some cards need very high timeouts if driven in SPI mode.
 	 * The worst observed timeout was 900ms after writing a

commit b6ad726e3fe69e1ff3c3b2ad272ba3e4c376cd6a
Author: Ulf Hansson <ulf.hansson@stericsson.com>
Date:   Thu Oct 13 16:03:58 2011 +0200

    mmc: core: Prevent too long response times for suspend
    
    While trying to suspend the mmc host there could still be
    ongoing requests that we need to wait for. At the same time
    a device driver must respond to a suspend request rather quickly.
    
    Instead of potentially wait "forever" by claiming the host we now
    "try" to claim the host instead. If it fails, -EBUSY is returned.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@stericsson.com>
    Reviewed-by: Sujit Reddy Thumma <sthumma@codeaurora.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index fe65bb377e25..5278ffb20e74 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2294,21 +2294,33 @@ int mmc_suspend_host(struct mmc_host *host)
 
 	mmc_bus_get(host);
 	if (host->bus_ops && !host->bus_dead) {
-		if (host->bus_ops->suspend)
-			err = host->bus_ops->suspend(host);
-		if (err == -ENOSYS || !host->bus_ops->resume) {
-			/*
-			 * We simply "remove" the card in this case.
-			 * It will be redetected on resume.
-			 */
-			if (host->bus_ops->remove)
-				host->bus_ops->remove(host);
-			mmc_claim_host(host);
-			mmc_detach_bus(host);
-			mmc_power_off(host);
-			mmc_release_host(host);
-			host->pm_flags = 0;
-			err = 0;
+
+		/*
+		 * A long response time is not acceptable for device drivers
+		 * when doing suspend. Prevent mmc_claim_host in the suspend
+		 * sequence, to potentially wait "forever" by trying to
+		 * pre-claim the host.
+		 */
+		if (mmc_try_claim_host(host)) {
+			if (host->bus_ops->suspend)
+				err = host->bus_ops->suspend(host);
+			if (err == -ENOSYS || !host->bus_ops->resume) {
+				/*
+				 * We simply "remove" the card in this case.
+				 * It will be redetected on resume.
+				 */
+				if (host->bus_ops->remove)
+					host->bus_ops->remove(host);
+				mmc_claim_host(host);
+				mmc_detach_bus(host);
+				mmc_power_off(host);
+				mmc_release_host(host);
+				host->pm_flags = 0;
+				err = 0;
+			}
+			mmc_do_release_host(host);
+		} else {
+			err = -EBUSY;
 		}
 	}
 	mmc_bus_put(host);

commit eb0d8f135b6730d6d0324a064664d121334290e7
Author: Jaehoon Chung <jh80.chung@samsung.com>
Date:   Tue Oct 18 01:26:42 2011 -0400

    mmc: core: support HPI send command
    
    HPI command is defined in eMMC4.41.
    This feature is important for eMMC4.5 devices.
    
    Signed-off-by: Jaehoon Chung <jh80.chung@samsung.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 235bb6a1f973..fe65bb377e25 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -379,6 +379,63 @@ void mmc_wait_for_req(struct mmc_host *host, struct mmc_request *mrq)
 }
 EXPORT_SYMBOL(mmc_wait_for_req);
 
+/**
+ *	mmc_interrupt_hpi - Issue for High priority Interrupt
+ *	@card: the MMC card associated with the HPI transfer
+ *
+ *	Issued High Priority Interrupt, and check for card status
+ *	util out-of prg-state.
+ */
+int mmc_interrupt_hpi(struct mmc_card *card)
+{
+	int err;
+	u32 status;
+
+	BUG_ON(!card);
+
+	if (!card->ext_csd.hpi_en) {
+		pr_info("%s: HPI enable bit unset\n", mmc_hostname(card->host));
+		return 1;
+	}
+
+	mmc_claim_host(card->host);
+	err = mmc_send_status(card, &status);
+	if (err) {
+		pr_err("%s: Get card status fail\n", mmc_hostname(card->host));
+		goto out;
+	}
+
+	/*
+	 * If the card status is in PRG-state, we can send the HPI command.
+	 */
+	if (R1_CURRENT_STATE(status) == R1_STATE_PRG) {
+		do {
+			/*
+			 * We don't know when the HPI command will finish
+			 * processing, so we need to resend HPI until out
+			 * of prg-state, and keep checking the card status
+			 * with SEND_STATUS.  If a timeout error occurs when
+			 * sending the HPI command, we are already out of
+			 * prg-state.
+			 */
+			err = mmc_send_hpi_cmd(card, &status);
+			if (err)
+				pr_debug("%s: abort HPI (%d error)\n",
+					 mmc_hostname(card->host), err);
+
+			err = mmc_send_status(card, &status);
+			if (err)
+				break;
+		} while (R1_CURRENT_STATE(status) == R1_STATE_PRG);
+	} else
+		pr_debug("%s: Left prg-state\n", mmc_hostname(card->host));
+
+out:
+	mmc_release_host(card->host);
+	return err;
+}
+EXPORT_SYMBOL(mmc_interrupt_hpi);
+
 /**
  *	mmc_wait_for_cmd - start a command and wait for completion
  *	@host: MMC host to start command

commit 881d1c25f765938a95def5afe39486ce39f9fc96
Author: Seungwon Jeon <tgih.jun@samsung.com>
Date:   Fri Oct 14 14:03:21 2011 +0900

    mmc: core: Add cache control for eMMC4.5 device
    
    This patch adds cache feature of eMMC4.5 Spec.
    If device supports cache capability, host can utilize some specific
    operations.
    
    Signed-off-by: Seungwon Jeon <tgih.jun@samsung.com>
    Signed-off-by: Jaehoon Chung <jh80.chung@samsung.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 772de2cdfd1d..235bb6a1f973 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2158,6 +2158,65 @@ int mmc_card_can_sleep(struct mmc_host *host)
 }
 EXPORT_SYMBOL(mmc_card_can_sleep);
 
+/*
+ * Flush the cache to the non-volatile storage.
+ */
+int mmc_flush_cache(struct mmc_card *card)
+{
+	struct mmc_host *host = card->host;
+	int err = 0;
+
+	if (!(host->caps2 & MMC_CAP2_CACHE_CTRL))
+		return err;
+
+	if (mmc_card_mmc(card) &&
+			(card->ext_csd.cache_size > 0) &&
+			(card->ext_csd.cache_ctrl & 1)) {
+		err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
+				EXT_CSD_FLUSH_CACHE, 1, 0);
+		if (err)
+			pr_err("%s: cache flush error %d\n",
+					mmc_hostname(card->host), err);
+	}
+
+	return err;
+}
+EXPORT_SYMBOL(mmc_flush_cache);
+
+/*
+ * Turn the cache ON/OFF.
+ * Turning the cache OFF shall trigger flushing of the data
+ * to the non-volatile storage.
+ */
+int mmc_cache_ctrl(struct mmc_host *host, u8 enable)
+{
+	struct mmc_card *card = host->card;
+	int err = 0;
+
+	if (!(host->caps2 & MMC_CAP2_CACHE_CTRL) ||
+			mmc_card_is_removable(host))
+		return err;
+
+	if (card && mmc_card_mmc(card) &&
+			(card->ext_csd.cache_size > 0)) {
+		enable = !!enable;
+
+		if (card->ext_csd.cache_ctrl ^ enable)
+			err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
+					EXT_CSD_CACHE_CTRL, enable, 0);
+		if (err)
+			pr_err("%s: cache %s error %d\n",
+					mmc_hostname(card->host),
+					enable ? "on" : "off",
+					err);
+		else
+			card->ext_csd.cache_ctrl = enable;
+	}
+
+	return err;
+}
+EXPORT_SYMBOL(mmc_cache_ctrl);
+
 #ifdef CONFIG_PM
 
 /**
@@ -2172,6 +2231,9 @@ int mmc_suspend_host(struct mmc_host *host)
 		cancel_delayed_work(&host->disable);
 	cancel_delayed_work(&host->detect);
 	mmc_flush_scheduled_work();
+	err = mmc_cache_ctrl(host, 0);
+	if (err)
+		goto out;
 
 	mmc_bus_get(host);
 	if (host->bus_ops && !host->bus_dead) {
@@ -2197,6 +2259,7 @@ int mmc_suspend_host(struct mmc_host *host)
 	if (!err && !mmc_card_keep_power(host))
 		mmc_power_off(host);
 
+out:
 	return err;
 }
 

commit b3bf915308ca2b50f3beec6cc824083870f0f4b5
Author: Kyungmin Park <kyungmin.park@samsung.com>
Date:   Tue Oct 18 09:34:04 2011 +0900

    mmc: core: new discard feature support at eMMC v4.5
    
    MMC v4.5 supports the DISCARD feature (CMD38).  It's different from
    trim and there's no check bit.  Currently it's only supported at v4.5.
    
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: Jaehoon Chung <jh80.chung@samsung.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index d9836e5a4e59..772de2cdfd1d 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1709,10 +1709,24 @@ int mmc_can_trim(struct mmc_card *card)
 {
 	if (card->ext_csd.sec_feature_support & EXT_CSD_SEC_GB_CL_EN)
 		return 1;
+	if (mmc_can_discard(card))
+		return 1;
 	return 0;
 }
 EXPORT_SYMBOL(mmc_can_trim);
 
+int mmc_can_discard(struct mmc_card *card)
+{
+	/*
+	 * As there's no way to detect the discard support bit at v4.5
+	 * use the s/w feature support filed.
+	 */
+	if (card->ext_csd.feature_support & MMC_DISCARD_FEATURE)
+		return 1;
+	return 0;
+}
+EXPORT_SYMBOL(mmc_can_discard);
+
 int mmc_can_sanitize(struct mmc_card *card)
 {
 	if (card->ext_csd.sec_feature_support & EXT_CSD_SEC_SANITIZE)

commit d9ddd62943ee07a75d0428ffcf52f1a747a28c39
Author: Kyungmin Park <kyungmin.park@samsung.com>
Date:   Fri Oct 14 14:15:48 2011 +0900

    mmc: core: mmc sanitize feature support for v4.5
    
    In the v4.5, there's no secure erase & trim support.
    Instead it supports the sanitize feature.
    
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: Jaehoon Chung <jh80.chung@samsung.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index a3c4e0fe9434..d9836e5a4e59 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1713,6 +1713,14 @@ int mmc_can_trim(struct mmc_card *card)
 }
 EXPORT_SYMBOL(mmc_can_trim);
 
+int mmc_can_sanitize(struct mmc_card *card)
+{
+	if (card->ext_csd.sec_feature_support & EXT_CSD_SEC_SANITIZE)
+		return 1;
+	return 0;
+}
+EXPORT_SYMBOL(mmc_can_sanitize);
+
 int mmc_can_secure_erase_trim(struct mmc_card *card)
 {
 	if (card->ext_csd.sec_feature_support & EXT_CSD_SEC_ER_EN)

commit bec8726abc72bf30d2743a722aa37cd69e7a0580
Author: Girish K S <girish.shivananjappa@linaro.org>
Date:   Thu Oct 13 12:04:16 2011 +0530

    mmc: core: Add Power Off Notify Feature eMMC 4.5
    
    This patch adds support for the power off notify feature, available in
    eMMC 4.5 devices. If the host has support for this feature, then the
    mmc core will notify the device by setting the POWER_OFF_NOTIFICATION
    byte in the extended csd register with a value of 1 (POWER_ON).
    
    For suspend mode short timeout is used, whereas for the normal poweroff
    long timeout is used.
    
    Signed-off-by: Girish K S <girish.shivananjappa@linaro.org>
    Signed-off-by: Jaehoon Chung <jh80.chung@samsung.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 61d7730bc8b2..a3c4e0fe9434 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1212,11 +1212,43 @@ static void mmc_power_up(struct mmc_host *host)
 
 void mmc_power_off(struct mmc_host *host)
 {
+	struct mmc_card *card;
+	unsigned int notify_type;
+	unsigned int timeout;
+	int err;
+
 	mmc_host_clk_hold(host);
 
+	card = host->card;
 	host->ios.clock = 0;
 	host->ios.vdd = 0;
 
+	if (card && mmc_card_mmc(card) &&
+	    (card->poweroff_notify_state == MMC_POWERED_ON)) {
+
+		if (host->power_notify_type == MMC_HOST_PW_NOTIFY_SHORT) {
+			notify_type = EXT_CSD_POWER_OFF_SHORT;
+			timeout = card->ext_csd.generic_cmd6_time;
+			card->poweroff_notify_state = MMC_POWEROFF_SHORT;
+		} else {
+			notify_type = EXT_CSD_POWER_OFF_LONG;
+			timeout = card->ext_csd.power_off_longtime;
+			card->poweroff_notify_state = MMC_POWEROFF_LONG;
+		}
+
+		err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
+				 EXT_CSD_POWER_OFF_NOTIFICATION,
+				 notify_type, timeout);
+
+		if (err && err != -EBADMSG)
+			pr_err("Device failed to respond within %d poweroff "
+			       "time. Forcefully powering down the device\n",
+			       timeout);
+
+		/* Set the card state to no notification after the poweroff */
+		card->poweroff_notify_state = MMC_NO_POWER_NOTIFICATION;
+	}
+
 	/*
 	 * Reset ocr mask to be the highest possible voltage supported for
 	 * this mmc host. This value will be used at next power up.
@@ -2208,6 +2240,7 @@ int mmc_pm_notify(struct notifier_block *notify_block,
 
 		spin_lock_irqsave(&host->lock, flags);
 		host->rescan_disable = 1;
+		host->power_notify_type = MMC_HOST_PW_NOTIFY_SHORT;
 		spin_unlock_irqrestore(&host->lock, flags);
 		cancel_delayed_work_sync(&host->detect);
 
@@ -2231,6 +2264,7 @@ int mmc_pm_notify(struct notifier_block *notify_block,
 
 		spin_lock_irqsave(&host->lock, flags);
 		host->rescan_disable = 0;
+		host->power_notify_type = MMC_HOST_PW_NOTIFY_LONG;
 		spin_unlock_irqrestore(&host->lock, flags);
 		mmc_detect_change(host, 0);
 

commit a3c76eb9d4a1e68a69dd880cf0bcb8a52418b993
Author: Girish K S <girish.shivananjappa@linaro.org>
Date:   Tue Oct 11 11:44:09 2011 +0530

    mmc: replace printk with appropriate display macro
    
    All the files using printk function for displaying kernel messages
    in the mmc driver have been replaced with corresponding macro.
    
    Signed-off-by: Girish K S <girish.shivananjappa@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index ec7694903008..61d7730bc8b2 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1541,7 +1541,7 @@ static int mmc_do_erase(struct mmc_card *card, unsigned int from,
 	cmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_AC;
 	err = mmc_wait_for_cmd(card->host, &cmd, 0);
 	if (err) {
-		printk(KERN_ERR "mmc_erase: group start error %d, "
+		pr_err("mmc_erase: group start error %d, "
 		       "status %#x\n", err, cmd.resp[0]);
 		err = -EIO;
 		goto out;
@@ -1556,7 +1556,7 @@ static int mmc_do_erase(struct mmc_card *card, unsigned int from,
 	cmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_AC;
 	err = mmc_wait_for_cmd(card->host, &cmd, 0);
 	if (err) {
-		printk(KERN_ERR "mmc_erase: group end error %d, status %#x\n",
+		pr_err("mmc_erase: group end error %d, status %#x\n",
 		       err, cmd.resp[0]);
 		err = -EIO;
 		goto out;
@@ -1569,7 +1569,7 @@ static int mmc_do_erase(struct mmc_card *card, unsigned int from,
 	cmd.cmd_timeout_ms = mmc_erase_timeout(card, arg, qty);
 	err = mmc_wait_for_cmd(card->host, &cmd, 0);
 	if (err) {
-		printk(KERN_ERR "mmc_erase: erase error %d, status %#x\n",
+		pr_err("mmc_erase: erase error %d, status %#x\n",
 		       err, cmd.resp[0]);
 		err = -EIO;
 		goto out;
@@ -1586,7 +1586,7 @@ static int mmc_do_erase(struct mmc_card *card, unsigned int from,
 		/* Do not retry else we can't see errors */
 		err = mmc_wait_for_cmd(card->host, &cmd, 0);
 		if (err || (cmd.resp[0] & 0xFDF92000)) {
-			printk(KERN_ERR "error %d requesting status %#x\n",
+			pr_err("error %d requesting status %#x\n",
 				err, cmd.resp[0]);
 			err = -EIO;
 			goto out;
@@ -2177,7 +2177,7 @@ int mmc_resume_host(struct mmc_host *host)
 		BUG_ON(!host->bus_ops->resume);
 		err = host->bus_ops->resume(host);
 		if (err) {
-			printk(KERN_WARNING "%s: error %d during resume "
+			pr_warning("%s: error %d during resume "
 					    "(card was removed?)\n",
 					    mmc_hostname(host), err);
 			err = 0;

commit 08a7e1dfaa63bf5132b5b7231fcf9a33473c78f5
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Mon Oct 3 15:33:33 2011 +0300

    mmc: core: move ->request() call from atomic context
    
    mmc_request_done() is sometimes called from interrupt or other atomic
    context.  Mostly all mmc_request_done() does is complete(), however it
    contains code to retry on error, which uses ->request().  As the error
    path is certainly not performance critical, this may be moved to the
    waiting function mmc_wait_for_req_done().
    
    This allows ->request() to use runtime PM get_sync() and guarantee it
    is never in an atomic context.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Acked-by: Ulf Hansson <ulf.hansson@stericsson.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 9698d8a2e166..ec7694903008 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -141,12 +141,12 @@ void mmc_request_done(struct mmc_host *host, struct mmc_request *mrq)
 	}
 
 	if (err && cmd->retries) {
-		pr_debug("%s: req failed (CMD%u): %d, retrying...\n",
-			mmc_hostname(host), cmd->opcode, err);
-
-		cmd->retries--;
-		cmd->error = 0;
-		host->ops->request(host, mrq);
+		/*
+		 * Request starter must handle retries - see
+		 * mmc_wait_for_req_done().
+		 */
+		if (mrq->done)
+			mrq->done(mrq);
 	} else {
 		mmc_should_fail_request(host, mrq);
 
@@ -253,7 +253,21 @@ static void __mmc_start_req(struct mmc_host *host, struct mmc_request *mrq)
 static void mmc_wait_for_req_done(struct mmc_host *host,
 				  struct mmc_request *mrq)
 {
-	wait_for_completion(&mrq->completion);
+	struct mmc_command *cmd;
+
+	while (1) {
+		wait_for_completion(&mrq->completion);
+
+		cmd = mrq->cmd;
+		if (!cmd->error || !cmd->retries)
+			break;
+
+		pr_debug("%s: req failed (CMD%u): %d, retrying...\n",
+			 mmc_hostname(host), cmd->opcode, cmd->error);
+		cmd->retries--;
+		cmd->error = 0;
+		host->ops->request(host, mrq);
+	}
 }
 
 /**

commit 67716327eec7e9d573e7cb2d806545d6f7c1a38d
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Mon Aug 29 16:42:15 2011 +0300

    mmc: block: add eMMC hardware reset support
    
    For cards that support hardware reset (just eMMC), try a reset and
    retry before returning an I/O error.  However this is not done for
    ECC errors and is never done twice for the same operation type
    (READ, WRITE, DISCARD, SECURE DISCARD) until that type of operation
    again succeeds.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index da6bd95fa4bb..9698d8a2e166 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1529,7 +1529,7 @@ static int mmc_do_erase(struct mmc_card *card, unsigned int from,
 	if (err) {
 		printk(KERN_ERR "mmc_erase: group start error %d, "
 		       "status %#x\n", err, cmd.resp[0]);
-		err = -EINVAL;
+		err = -EIO;
 		goto out;
 	}
 
@@ -1544,7 +1544,7 @@ static int mmc_do_erase(struct mmc_card *card, unsigned int from,
 	if (err) {
 		printk(KERN_ERR "mmc_erase: group end error %d, status %#x\n",
 		       err, cmd.resp[0]);
-		err = -EINVAL;
+		err = -EIO;
 		goto out;
 	}
 

commit b2499518b5ad7e28bb3ed348fd3f370eeb1e36c0
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Mon Aug 29 16:42:11 2011 +0300

    mmc: core: add eMMC hardware reset support
    
    eMMC's may have a hardware reset line.  This patch provides a
    host controller operation to implement hardware reset and
    a function to reset and reinitialize the card.  Also, for MMC,
    the reset is always performed before initialization.
    
    The host must set the new host capability MMC_CAP_HW_RESET
    to enable hardware reset.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 0b4c2ed22bce..da6bd95fa4bb 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1776,6 +1776,94 @@ int mmc_set_blocklen(struct mmc_card *card, unsigned int blocklen)
 }
 EXPORT_SYMBOL(mmc_set_blocklen);
 
+static void mmc_hw_reset_for_init(struct mmc_host *host)
+{
+	if (!(host->caps & MMC_CAP_HW_RESET) || !host->ops->hw_reset)
+		return;
+	mmc_host_clk_hold(host);
+	host->ops->hw_reset(host);
+	mmc_host_clk_release(host);
+}
+
+int mmc_can_reset(struct mmc_card *card)
+{
+	u8 rst_n_function;
+
+	if (!mmc_card_mmc(card))
+		return 0;
+	rst_n_function = card->ext_csd.rst_n_function;
+	if ((rst_n_function & EXT_CSD_RST_N_EN_MASK) != EXT_CSD_RST_N_ENABLED)
+		return 0;
+	return 1;
+}
+EXPORT_SYMBOL(mmc_can_reset);
+
+static int mmc_do_hw_reset(struct mmc_host *host, int check)
+{
+	struct mmc_card *card = host->card;
+
+	if (!host->bus_ops->power_restore)
+		return -EOPNOTSUPP;
+
+	if (!(host->caps & MMC_CAP_HW_RESET) || !host->ops->hw_reset)
+		return -EOPNOTSUPP;
+
+	if (!card)
+		return -EINVAL;
+
+	if (!mmc_can_reset(card))
+		return -EOPNOTSUPP;
+
+	mmc_host_clk_hold(host);
+	mmc_set_clock(host, host->f_init);
+
+	host->ops->hw_reset(host);
+
+	/* If the reset has happened, then a status command will fail */
+	if (check) {
+		struct mmc_command cmd = {0};
+		int err;
+
+		cmd.opcode = MMC_SEND_STATUS;
+		if (!mmc_host_is_spi(card->host))
+			cmd.arg = card->rca << 16;
+		cmd.flags = MMC_RSP_SPI_R2 | MMC_RSP_R1 | MMC_CMD_AC;
+		err = mmc_wait_for_cmd(card->host, &cmd, 0);
+		if (!err) {
+			mmc_host_clk_release(host);
+			return -ENOSYS;
+		}
+	}
+
+	host->card->state &= ~(MMC_STATE_HIGHSPEED | MMC_STATE_HIGHSPEED_DDR);
+	if (mmc_host_is_spi(host)) {
+		host->ios.chip_select = MMC_CS_HIGH;
+		host->ios.bus_mode = MMC_BUSMODE_PUSHPULL;
+	} else {
+		host->ios.chip_select = MMC_CS_DONTCARE;
+		host->ios.bus_mode = MMC_BUSMODE_OPENDRAIN;
+	}
+	host->ios.bus_width = MMC_BUS_WIDTH_1;
+	host->ios.timing = MMC_TIMING_LEGACY;
+	mmc_set_ios(host);
+
+	mmc_host_clk_release(host);
+
+	return host->bus_ops->power_restore(host);
+}
+
+int mmc_hw_reset(struct mmc_host *host)
+{
+	return mmc_do_hw_reset(host, 0);
+}
+EXPORT_SYMBOL(mmc_hw_reset);
+
+int mmc_hw_reset_check(struct mmc_host *host)
+{
+	return mmc_do_hw_reset(host, 1);
+}
+EXPORT_SYMBOL(mmc_hw_reset_check);
+
 static int mmc_rescan_try_freq(struct mmc_host *host, unsigned freq)
 {
 	host->f_init = freq;
@@ -1786,6 +1874,12 @@ static int mmc_rescan_try_freq(struct mmc_host *host, unsigned freq)
 #endif
 	mmc_power_up(host);
 
+	/*
+	 * Some eMMCs (with VCCQ always on) may not be reset after power up, so
+	 * do a hardware reset if possible.
+	 */
+	mmc_hw_reset_for_init(host);
+
 	/*
 	 * sdio_reset sends CMD52 to reset card.  Since we do not know
 	 * if the card is being re-initialized, just send it.  CMD52

commit 7c8a2829c22a270acadc6aa3a937e2e7956b19f5
Author: Per Forlin <per.forlin@linaro.org>
Date:   Mon Aug 29 15:35:58 2011 +0200

    mmc: core: clarify how to use post_req in case of errors
    
    The err condition in post_req() is set to undo a call made to pre_req()
    that hasn't been started yet.  The err condition is not set if an MMC
    request returns an error.
    
    Signed-off-by: Per Forlin <per.forlin@linaro.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 45ea968e7dd1..0b4c2ed22bce 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -320,8 +320,14 @@ struct mmc_async_req *mmc_start_req(struct mmc_host *host,
 		mmc_wait_for_req_done(host, host->areq->mrq);
 		err = host->areq->err_check(host->card, host->areq);
 		if (err) {
+			/* post process the completed failed request */
 			mmc_post_req(host, host->areq->mrq, 0);
 			if (areq)
+				/*
+				 * Cancel the new prepared request, because
+				 * it can't run until the failed
+				 * request has been properly handled.
+				 */
 				mmc_post_req(host, areq->mrq, -EINVAL);
 
 			host->areq = NULL;

commit 44669034815a7ad263542ac605c581a10b22d146
Author: Stefan Nilsson XK <stefan.xk.nilsson@stericsson.com>
Date:   Thu Sep 15 17:50:38 2011 +0200

    mmc: core: Set correct bus mode before card init
    
    Earlier all cards where initiated with bus mode set as OPENDRAIN, and then
    later switched to PUSHPULL. According to the MMC/SD/SDIO specifications
    only MMC cards use OPENDRAIN during init. For both SD and SDIO the bus
    mode shall be PUSHPULL before attempting to init the card.
    
    The consequence of having incorrect bus mode can lead to not being able
    to detect the card. Therefore the default behavior have now been changed
    to PUSHPULL in mmc_power_up, and will only be temporarily switched when
    trying to attach or init a MMC card.
    
    Signed-off-by: Stefan Nilsson XK <stefan.xk.nilsson@stericsson.com>
    Signed-off-by: Ulf HANSSON <ulf.hansson@stericsson.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 5ae6b159dbea..45ea968e7dd1 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1160,13 +1160,11 @@ static void mmc_power_up(struct mmc_host *host)
 		bit = fls(host->ocr_avail) - 1;
 
 	host->ios.vdd = bit;
-	if (mmc_host_is_spi(host)) {
+	if (mmc_host_is_spi(host))
 		host->ios.chip_select = MMC_CS_HIGH;
-		host->ios.bus_mode = MMC_BUSMODE_PUSHPULL;
-	} else {
+	else
 		host->ios.chip_select = MMC_CS_DONTCARE;
-		host->ios.bus_mode = MMC_BUSMODE_OPENDRAIN;
-	}
+	host->ios.bus_mode = MMC_BUSMODE_PUSHPULL;
 	host->ios.power_mode = MMC_POWER_UP;
 	host->ios.bus_width = MMC_BUS_WIDTH_1;
 	host->ios.timing = MMC_TIMING_LEGACY;

commit 7f7e4129c23f0419257184dff6fec89d2d5a8964
Author: Ulf Hansson <ulf.hansson@stericsson.com>
Date:   Wed Sep 21 14:08:13 2011 -0400

    mmc: core: Fix hangs related to insert/remove of cards
    
    During a rescan operation mmc_attach(sd|mmc|sdio) functions are
    called. The error handling in these function can trigger a detach
    of the bus, which also meant a power off. This is not notified by
    the rescan operation which then continues to the next attach function.
    
    If a power off has been done, the framework must never send any
    new commands to the host driver, without first doing a new power up.
    This will most likely trigger any host driver to hang.
    
    Moving power off out of detach and instead handle power off
    separately when it is actually needed, solves the issue.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@stericsson.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Cc: <stable@kernel.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 7289e999d1fc..5ae6b159dbea 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1192,7 +1192,7 @@ static void mmc_power_up(struct mmc_host *host)
 	mmc_host_clk_release(host);
 }
 
-static void mmc_power_off(struct mmc_host *host)
+void mmc_power_off(struct mmc_host *host)
 {
 	mmc_host_clk_hold(host);
 
@@ -1289,8 +1289,7 @@ void mmc_attach_bus(struct mmc_host *host, const struct mmc_bus_ops *ops)
 }
 
 /*
- * Remove the current bus handler from a host. Assumes that there are
- * no interesting cards left, so the bus is powered down.
+ * Remove the current bus handler from a host.
  */
 void mmc_detach_bus(struct mmc_host *host)
 {
@@ -1307,8 +1306,6 @@ void mmc_detach_bus(struct mmc_host *host)
 
 	spin_unlock_irqrestore(&host->lock, flags);
 
-	mmc_power_off(host);
-
 	mmc_bus_put(host);
 }
 
@@ -1893,6 +1890,7 @@ void mmc_stop_host(struct mmc_host *host)
 
 		mmc_claim_host(host);
 		mmc_detach_bus(host);
+		mmc_power_off(host);
 		mmc_release_host(host);
 		mmc_bus_put(host);
 		return;
@@ -2022,6 +2020,7 @@ int mmc_suspend_host(struct mmc_host *host)
 				host->bus_ops->remove(host);
 			mmc_claim_host(host);
 			mmc_detach_bus(host);
+			mmc_power_off(host);
 			mmc_release_host(host);
 			host->pm_flags = 0;
 			err = 0;
@@ -2109,6 +2108,7 @@ int mmc_pm_notify(struct notifier_block *notify_block,
 			host->bus_ops->remove(host);
 
 		mmc_detach_bus(host);
+		mmc_power_off(host);
 		mmc_release_host(host);
 		host->pm_flags = 0;
 		break;

commit 041beb1d531f538bf62377e2ca2b4ecbaa479d75
Author: Daniel Drake <dsd@laptop.org>
Date:   Wed Sep 7 10:22:09 2011 +0100

    mmc: core: add a short delay in mmc_power_off
    
    Stress-testing the runtime power management of libertas_sdio
    through a rmmod/insmod loop revealed that it is quite easy to
    cause an ETIMEDOUT failure in mmc_sdio_power_restore() leading to:
       libertas_sdio: probe of mmc1:0001:1 failed with error -16
    
    Experimentation shows that a very short delay (100us) is needed in
    the power down path before the card can be successfully booted again.
    We know that this setup is lacking poweroff clamps on the card's power
    lines, but as only a short delay is needed, apply this unconditionally.
    Also bump up to 1ms sleep for extra legroom.
    
    Signed-off-by: Daniel Drake <dsd@laptop.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 557856b6f95c..7289e999d1fc 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1214,6 +1214,13 @@ static void mmc_power_off(struct mmc_host *host)
 	host->ios.timing = MMC_TIMING_LEGACY;
 	mmc_set_ios(host);
 
+	/*
+	 * Some configurations, such as the 802.11 SDIO card in the OLPC
+	 * XO-1.5, require a short delay after poweroff before the card
+	 * can be successfully turned on again.
+	 */
+	mmc_delay(1);
+
 	mmc_host_clk_release(host);
 }
 

commit ad5fd97288655b5628052c1fa906419417c86100
Author: Venkatraman S <svenkatr@ti.com>
Date:   Thu Aug 25 00:30:50 2011 +0530

    mmc: fix integer assignments to pointer
    
    Fix the sparse warning output "warning: Using plain integer as NULL pointer"
    
    Signed-off-by: Venkatraman S <svenkatr@ti.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index eb3069dfea8e..557856b6f95c 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -371,7 +371,7 @@ EXPORT_SYMBOL(mmc_wait_for_req);
  */
 int mmc_wait_for_cmd(struct mmc_host *host, struct mmc_command *cmd, int retries)
 {
-	struct mmc_request mrq = {0};
+	struct mmc_request mrq = {NULL};
 
 	WARN_ON(!host->claimed);
 

commit 1b676f70c108cda90cf9d114d16c677584400efc
Author: Per Forlin <per.forlin@linaro.org>
Date:   Fri Aug 19 14:52:37 2011 +0200

    mmc: core: add random fault injection
    
    This adds support to inject data errors after a completed host transfer.
    The mmc core will return error even though the host transfer is successful.
    This simple fault injection proved to be very useful to test the
    non-blocking error handling in the mmc_blk_issue_rw_rq().
    Random faults can also test how the host driver handles pre_req()
    and post_req() in case of errors.
    
    Signed-off-by: Per Forlin <per.forlin@linaro.org>
    Acked-by: Akinobu Mita <akinobu.mita@gmail.com>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index b27b94078c21..eb3069dfea8e 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -24,6 +24,8 @@
 #include <linux/regulator/consumer.h>
 #include <linux/pm_runtime.h>
 #include <linux/suspend.h>
+#include <linux/fault-inject.h>
+#include <linux/random.h>
 
 #include <linux/mmc/card.h>
 #include <linux/mmc/host.h>
@@ -83,6 +85,43 @@ static void mmc_flush_scheduled_work(void)
 	flush_workqueue(workqueue);
 }
 
+#ifdef CONFIG_FAIL_MMC_REQUEST
+
+/*
+ * Internal function. Inject random data errors.
+ * If mmc_data is NULL no errors are injected.
+ */
+static void mmc_should_fail_request(struct mmc_host *host,
+				    struct mmc_request *mrq)
+{
+	struct mmc_command *cmd = mrq->cmd;
+	struct mmc_data *data = mrq->data;
+	static const int data_errors[] = {
+		-ETIMEDOUT,
+		-EILSEQ,
+		-EIO,
+	};
+
+	if (!data)
+		return;
+
+	if (cmd->error || data->error ||
+	    !should_fail(&host->fail_mmc_request, data->blksz * data->blocks))
+		return;
+
+	data->error = data_errors[random32() % ARRAY_SIZE(data_errors)];
+	data->bytes_xfered = (random32() % (data->bytes_xfered >> 9)) << 9;
+}
+
+#else /* CONFIG_FAIL_MMC_REQUEST */
+
+static inline void mmc_should_fail_request(struct mmc_host *host,
+					   struct mmc_request *mrq)
+{
+}
+
+#endif /* CONFIG_FAIL_MMC_REQUEST */
+
 /**
  *	mmc_request_done - finish processing an MMC request
  *	@host: MMC host which completed request
@@ -109,6 +148,8 @@ void mmc_request_done(struct mmc_host *host, struct mmc_request *mrq)
 		cmd->error = 0;
 		host->ops->request(host, mrq);
 	} else {
+		mmc_should_fail_request(host, mrq);
+
 		led_trigger_event(host->led, LED_OFF);
 
 		pr_debug("%s: req done (CMD%u): %d: %08x %08x %08x %08x\n",

commit 778e277cb82411c9002ca28ccbd216c4d9eb9158
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Thu Aug 18 15:23:48 2011 +0300

    mmc: core: prevent aggressive clock gating racing with ios updates
    
    We have seen at least two different races when clock gating kicks in in a
    middle of ios structure update.
    
    First one happens when ios->clock is changed outside of aggressive clock
    gating framework, for example via mmc_set_clock(). The race might happen
    when we run following code:
    
    mmc_set_ios():
            ...
            if (ios->clock > 0)
                    mmc_set_ungated(host);
    
    Now if gating kicks in right after the condition check we end up setting
    host->clk_gated to false even though we have just gated the clock. Next
    time a request is started we try to ungate and restore the clock in
    mmc_host_clk_hold(). However since we have host->clk_gated set to false the
    original clock is not restored.
    
    This eventually will cause the host controller to hang since its clock is
    disabled while we are trying to issue a request. For example on Intel
    Medfield platform we see:
    
    [   13.818610] mmc2: Timeout waiting for hardware interrupt.
    [   13.818698] sdhci: =========== REGISTER DUMP (mmc2)===========
    [   13.818753] sdhci: Sys addr: 0x00000000 | Version:  0x00008901
    [   13.818804] sdhci: Blk size: 0x00000000 | Blk cnt:  0x00000000
    [   13.818853] sdhci: Argument: 0x00000000 | Trn mode: 0x00000000
    [   13.818903] sdhci: Present:  0x1fff0000 | Host ctl: 0x00000001
    [   13.818951] sdhci: Power:    0x0000000d | Blk gap:  0x00000000
    [   13.819000] sdhci: Wake-up:  0x00000000 | Clock:    0x00000000
    [   13.819049] sdhci: Timeout:  0x00000000 | Int stat: 0x00000000
    [   13.819098] sdhci: Int enab: 0x00ff00c3 | Sig enab: 0x00ff00c3
    [   13.819147] sdhci: AC12 err: 0x00000000 | Slot int: 0x00000000
    [   13.819196] sdhci: Caps:     0x6bee32b2 | Caps_1:   0x00000000
    [   13.819245] sdhci: Cmd:      0x00000000 | Max curr: 0x00000000
    [   13.819292] sdhci: Host ctl2: 0x00000000
    [   13.819331] sdhci: ADMA Err: 0x00000000 | ADMA Ptr: 0x00000000
    [   13.819377] sdhci: ===========================================
    [   13.919605] mmc2: Reset 0x2 never completed.
    
    and it never recovers.
    
    Second race might happen while running mmc_power_off():
    
    static void mmc_power_off(struct mmc_host *host)
    {
            host->ios.clock = 0;
            host->ios.vdd = 0;
    
    [ clock gating kicks in here ]
    
            /*
             * Reset ocr mask to be the highest possible voltage supported for
             * this mmc host. This value will be used at next power up.
             */
            host->ocr = 1 << (fls(host->ocr_avail) - 1);
    
            if (!mmc_host_is_spi(host)) {
                    host->ios.bus_mode = MMC_BUSMODE_OPENDRAIN;
                    host->ios.chip_select = MMC_CS_DONTCARE;
            }
            host->ios.power_mode = MMC_POWER_OFF;
            host->ios.bus_width = MMC_BUS_WIDTH_1;
            host->ios.timing = MMC_TIMING_LEGACY;
            mmc_set_ios(host);
    }
    
    If the clock gating worker kicks in while we are only partially updated the
    ios structure the host controller gets incomplete ios and might not work as
    supposed. Again on Intel Medfield platform we get:
    
    [    4.185349] kernel BUG at drivers/mmc/host/sdhci.c:1155!
    [    4.185422] invalid opcode: 0000 [#1] PREEMPT SMP
    [    4.185509] Modules linked in:
    [    4.185565]
    [    4.185608] Pid: 4, comm: kworker/0:0 Not tainted 3.0.0+ #240 Intel Corporation Medfield/iCDKA
    [    4.185742] EIP: 0060:[<c136364e>] EFLAGS: 00010083 CPU: 0
    [    4.185827] EIP is at sdhci_set_power+0x3e/0xd0
    [    4.185891] EAX: f5ff98e0 EBX: f5ff98e0 ECX: 00000000 EDX: 00000001
    [    4.185970] ESI: f5ff977c EDI: f5ff9904 EBP: f644fe98 ESP: f644fe94
    [    4.186049]  DS: 007b ES: 007b FS: 00d8 GS: 0000 SS: 0068
    [    4.186125] Process kworker/0:0 (pid: 4, ti=f644e000 task=f644c0e0 task.ti=f644e000)
    [    4.186219] Stack:
    [    4.186257]  f5ff98e0 f644feb0 c1365173 00000282 f5ff9460 f5ff96e0 f5ff96e0 f644feec
    [    4.186418]  c1355bd8 f644c0e0 c1499c3d f5ff96e0 f644fed4 00000006 f5ff96e0 00000286
    [    4.186579]  f644fedc c107922b f644feec 00000286 f5ff9460 f5ff9700 f644ff10 c135839e
    [    4.186739] Call Trace:
    [    4.186802]  [<c1365173>] sdhci_set_ios+0x1c3/0x340
    [    4.186883]  [<c1355bd8>] mmc_gate_clock+0x68/0x120
    [    4.186963]  [<c1499c3d>] ? _raw_spin_unlock_irqrestore+0x4d/0x60
    [    4.187052]  [<c107922b>] ? trace_hardirqs_on+0xb/0x10
    [    4.187134]  [<c135839e>] mmc_host_clk_gate_delayed+0xbe/0x130
    [    4.187219]  [<c105ec09>] ? process_one_work+0xf9/0x5b0
    [    4.187300]  [<c135841d>] mmc_host_clk_gate_work+0xd/0x10
    [    4.187379]  [<c105ec82>] process_one_work+0x172/0x5b0
    [    4.187457]  [<c105ec09>] ? process_one_work+0xf9/0x5b0
    [    4.187538]  [<c1358410>] ? mmc_host_clk_gate_delayed+0x130/0x130
    [    4.187625]  [<c105f3c8>] worker_thread+0x118/0x330
    [    4.187700]  [<c1496cee>] ? preempt_schedule+0x2e/0x50
    [    4.187779]  [<c105f2b0>] ? rescuer_thread+0x1f0/0x1f0
    [    4.187857]  [<c1062cf4>] kthread+0x74/0x80
    [    4.187931]  [<c1062c80>] ? __init_kthread_worker+0x60/0x60
    [    4.188015]  [<c149acfa>] kernel_thread_helper+0x6/0xd
    [    4.188079] Code: 81 fa 00 00 04 00 0f 84 a7 00 00 00 7f 21 81 fa 80 00 00 00 0f 84 92 00 00 00 81 fa 00 00 0
    [    4.188780] EIP: [<c136364e>] sdhci_set_power+0x3e/0xd0 SS:ESP 0068:f644fe94
    [    4.188898] ---[ end trace a7b23eecc71777e4 ]---
    
    This BUG() comes from the fact that ios.power_mode was still in previous
    value (MMC_POWER_ON) and ios.vdd was set to zero.
    
    We prevent these by inhibiting the clock gating while we update the ios
    structure.
    
    Both problems can be reproduced by simply running the device in a reboot
    loop.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Tested-by: Chris Ball <cjb@laptop.org>
    Cc: <stable@kernel.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 63ffc65f84af..b27b94078c21 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -728,15 +728,17 @@ static inline void mmc_set_ios(struct mmc_host *host)
  */
 void mmc_set_chip_select(struct mmc_host *host, int mode)
 {
+	mmc_host_clk_hold(host);
 	host->ios.chip_select = mode;
 	mmc_set_ios(host);
+	mmc_host_clk_release(host);
 }
 
 /*
  * Sets the host clock to the highest possible frequency that
  * is below "hz".
  */
-void mmc_set_clock(struct mmc_host *host, unsigned int hz)
+static void __mmc_set_clock(struct mmc_host *host, unsigned int hz)
 {
 	WARN_ON(hz < host->f_min);
 
@@ -747,6 +749,13 @@ void mmc_set_clock(struct mmc_host *host, unsigned int hz)
 	mmc_set_ios(host);
 }
 
+void mmc_set_clock(struct mmc_host *host, unsigned int hz)
+{
+	mmc_host_clk_hold(host);
+	__mmc_set_clock(host, hz);
+	mmc_host_clk_release(host);
+}
+
 #ifdef CONFIG_MMC_CLKGATE
 /*
  * This gates the clock by setting it to 0 Hz.
@@ -779,7 +788,7 @@ void mmc_ungate_clock(struct mmc_host *host)
 	if (host->clk_old) {
 		BUG_ON(host->ios.clock);
 		/* This call will also set host->clk_gated to false */
-		mmc_set_clock(host, host->clk_old);
+		__mmc_set_clock(host, host->clk_old);
 	}
 }
 
@@ -807,8 +816,10 @@ void mmc_set_ungated(struct mmc_host *host)
  */
 void mmc_set_bus_mode(struct mmc_host *host, unsigned int mode)
 {
+	mmc_host_clk_hold(host);
 	host->ios.bus_mode = mode;
 	mmc_set_ios(host);
+	mmc_host_clk_release(host);
 }
 
 /*
@@ -816,8 +827,10 @@ void mmc_set_bus_mode(struct mmc_host *host, unsigned int mode)
  */
 void mmc_set_bus_width(struct mmc_host *host, unsigned int width)
 {
+	mmc_host_clk_hold(host);
 	host->ios.bus_width = width;
 	mmc_set_ios(host);
+	mmc_host_clk_release(host);
 }
 
 /**
@@ -1015,8 +1028,10 @@ u32 mmc_select_voltage(struct mmc_host *host, u32 ocr)
 
 		ocr &= 3 << bit;
 
+		mmc_host_clk_hold(host);
 		host->ios.vdd = bit;
 		mmc_set_ios(host);
+		mmc_host_clk_release(host);
 	} else {
 		pr_warning("%s: host doesn't support card's voltages\n",
 				mmc_hostname(host));
@@ -1063,8 +1078,10 @@ int mmc_set_signal_voltage(struct mmc_host *host, int signal_voltage, bool cmd11
  */
 void mmc_set_timing(struct mmc_host *host, unsigned int timing)
 {
+	mmc_host_clk_hold(host);
 	host->ios.timing = timing;
 	mmc_set_ios(host);
+	mmc_host_clk_release(host);
 }
 
 /*
@@ -1072,8 +1089,10 @@ void mmc_set_timing(struct mmc_host *host, unsigned int timing)
  */
 void mmc_set_driver_type(struct mmc_host *host, unsigned int drv_type)
 {
+	mmc_host_clk_hold(host);
 	host->ios.drv_type = drv_type;
 	mmc_set_ios(host);
+	mmc_host_clk_release(host);
 }
 
 /*
@@ -1091,6 +1110,8 @@ static void mmc_power_up(struct mmc_host *host)
 {
 	int bit;
 
+	mmc_host_clk_hold(host);
+
 	/* If ocr is set, we use it */
 	if (host->ocr)
 		bit = ffs(host->ocr) - 1;
@@ -1126,10 +1147,14 @@ static void mmc_power_up(struct mmc_host *host)
 	 * time required to reach a stable voltage.
 	 */
 	mmc_delay(10);
+
+	mmc_host_clk_release(host);
 }
 
 static void mmc_power_off(struct mmc_host *host)
 {
+	mmc_host_clk_hold(host);
+
 	host->ios.clock = 0;
 	host->ios.vdd = 0;
 
@@ -1147,6 +1172,8 @@ static void mmc_power_off(struct mmc_host *host)
 	host->ios.bus_width = MMC_BUS_WIDTH_1;
 	host->ios.timing = MMC_TIMING_LEGACY;
 	mmc_set_ios(host);
+
+	mmc_host_clk_release(host);
 }
 
 /*

commit 08c14071fda4e69abb9d5b1566651cd092b158d3
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Thu Aug 18 15:23:47 2011 +0300

    mmc: rename mmc_host_clk_{ungate|gate} to mmc_host_clk_{hold|release}
    
    As per suggestion by Linus Walleij:
    
      > If you think the names of the functions are confusing then
      > you may rename them, say like this:
      >
      > mmc_host_clk_ungate() -> mmc_host_clk_hold()
      > mmc_host_clk_gate() -> mmc_host_clk_release()
      >
      > Which would make the usecases more clear
    
    (This is CC'd to stable@ because the next two patches, which fix
    observable races, depend on it.)
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Cc: <stable@kernel.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 91a0a7460ebb..63ffc65f84af 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -133,7 +133,7 @@ void mmc_request_done(struct mmc_host *host, struct mmc_request *mrq)
 		if (mrq->done)
 			mrq->done(mrq);
 
-		mmc_host_clk_gate(host);
+		mmc_host_clk_release(host);
 	}
 }
 
@@ -192,7 +192,7 @@ mmc_start_request(struct mmc_host *host, struct mmc_request *mrq)
 			mrq->stop->mrq = mrq;
 		}
 	}
-	mmc_host_clk_ungate(host);
+	mmc_host_clk_hold(host);
 	led_trigger_event(host->led, LED_FULL);
 	host->ops->request(host, mrq);
 }

commit 7435bb7950ba8a3cbfa6d0c01e92588562533a3f
Author: Jaehoon Chung <jh80.chung@samsung.com>
Date:   Wed Aug 10 18:46:28 2011 +0900

    mmc: core: use defined R1_STATE_PRG macro for card status
    
    Signed-off-by: Jaehoon Chung <jh80.chung@samsung.com>
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 89bdeaec7182..91a0a7460ebb 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1502,7 +1502,7 @@ static int mmc_do_erase(struct mmc_card *card, unsigned int from,
 			goto out;
 		}
 	} while (!(cmd.resp[0] & R1_READY_FOR_DATA) ||
-		 R1_CURRENT_STATE(cmd.resp[0]) == 7);
+		 R1_CURRENT_STATE(cmd.resp[0]) == R1_STATE_PRG);
 out:
 	return err;
 }

commit 35eb6db11ed9cbf9702ec90a28779a51fe4a21a9
Author: Amerigo Wang <amwang@redhat.com>
Date:   Mon Jul 25 17:13:11 2011 -0700

    notifiers: pm: move pm notifiers into suspend.h
    
    It is not necessary to share the same notifier.h.
    
    Signed-off-by: WANG Cong <amwang@redhat.com>
    Cc: David Miller <davem@davemloft.net>
    Acked-by: "Rafael J. Wysocki" <rjw@sisk.pl>
    Cc: Greg KH <greg@kroah.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index f091b43d00c4..89bdeaec7182 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -23,6 +23,7 @@
 #include <linux/log2.h>
 #include <linux/regulator/consumer.h>
 #include <linux/pm_runtime.h>
+#include <linux/suspend.h>
 
 #include <linux/mmc/card.h>
 #include <linux/mmc/host.h>

commit bb9cab941c7139304899fa7922f3069bb2097f4e
Author: Daniel Drake <dsd@laptop.org>
Date:   Sun Jul 17 16:38:41 2011 +0100

    mmc: print debug messages for runtime PM actions
    
    At http://www.mail-archive.com/linux-mmc@vger.kernel.org/msg08371.html
    (thread: "mmc: sdio: reset card during power_restore") we found and
    fixed a bug where mmc's runtime power management functions were not being
    called. We have now also made improvements to the SDIO powerup routine
    which could possibly mask this kind of issue in future.
    
    Add debug messages to the runtime PM hooks so that it is easy to verify
    if and when runtime PM is happening.
    
    Signed-off-by: Daniel Drake <dsd@laptop.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index ab36c7b491f3..f091b43d00c4 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1832,6 +1832,10 @@ int mmc_power_save_host(struct mmc_host *host)
 {
 	int ret = 0;
 
+#ifdef CONFIG_MMC_DEBUG
+	pr_info("%s: %s: powering down\n", mmc_hostname(host), __func__);
+#endif
+
 	mmc_bus_get(host);
 
 	if (!host->bus_ops || host->bus_dead || !host->bus_ops->power_restore) {
@@ -1854,6 +1858,10 @@ int mmc_power_restore_host(struct mmc_host *host)
 {
 	int ret;
 
+#ifdef CONFIG_MMC_DEBUG
+	pr_info("%s: %s: powering up\n", mmc_hostname(host), __func__);
+#endif
+
 	mmc_bus_get(host);
 
 	if (!host->bus_ops || host->bus_dead || !host->bus_ops->power_restore) {

commit aa8b683a7d392271ed349c6ab9f36b8c313794b7
Author: Per Forlin <per.forlin@linaro.org>
Date:   Fri Jul 1 18:55:22 2011 +0200

    mmc: core: add non-blocking mmc request function
    
    Previously there has only been one function mmc_wait_for_req()
    to start and wait for a request. This patch adds:
    
     * mmc_start_req() - starts a request wihtout waiting
       If there is on ongoing request wait for completion
       of that request and start the new one and return.
       Does not wait for the new command to complete.
    
    This patch also adds new function members in struct mmc_host_ops
    only called from core.c:
    
     * pre_req - asks the host driver to prepare for the next job
     * post_req - asks the host driver to clean up after a completed job
    
    The intention is to use pre_req() and post_req() to do cache maintenance
    while a request is active. pre_req() can be called while a request is
    active to minimize latency to start next job. post_req() can be used after
    the next job is started to clean up the request. This will minimize the
    host driver request end latency. post_req() is typically used before
    ending the block request and handing over the buffer to the block layer.
    
    Add a host-private member in mmc_data to be used by pre_req to mark the
    data. The host driver will then check this mark to see if the data is
    prepared or not.
    
    Signed-off-by: Per Forlin <per.forlin@linaro.org>
    Acked-by: Kyungmin Park <kyungmin.park@samsung.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Reviewed-by: Venkatraman S <svenkatr@ti.com>
    Tested-by: Sourav Poddar <sourav.poddar@ti.com>
    Tested-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index ac82865b8c2f..ab36c7b491f3 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -198,9 +198,109 @@ mmc_start_request(struct mmc_host *host, struct mmc_request *mrq)
 
 static void mmc_wait_done(struct mmc_request *mrq)
 {
-	complete(mrq->done_data);
+	complete(&mrq->completion);
 }
 
+static void __mmc_start_req(struct mmc_host *host, struct mmc_request *mrq)
+{
+	init_completion(&mrq->completion);
+	mrq->done = mmc_wait_done;
+	mmc_start_request(host, mrq);
+}
+
+static void mmc_wait_for_req_done(struct mmc_host *host,
+				  struct mmc_request *mrq)
+{
+	wait_for_completion(&mrq->completion);
+}
+
+/**
+ *	mmc_pre_req - Prepare for a new request
+ *	@host: MMC host to prepare command
+ *	@mrq: MMC request to prepare for
+ *	@is_first_req: true if there is no previous started request
+ *                     that may run in parellel to this call, otherwise false
+ *
+ *	mmc_pre_req() is called in prior to mmc_start_req() to let
+ *	host prepare for the new request. Preparation of a request may be
+ *	performed while another request is running on the host.
+ */
+static void mmc_pre_req(struct mmc_host *host, struct mmc_request *mrq,
+		 bool is_first_req)
+{
+	if (host->ops->pre_req)
+		host->ops->pre_req(host, mrq, is_first_req);
+}
+
+/**
+ *	mmc_post_req - Post process a completed request
+ *	@host: MMC host to post process command
+ *	@mrq: MMC request to post process for
+ *	@err: Error, if non zero, clean up any resources made in pre_req
+ *
+ *	Let the host post process a completed request. Post processing of
+ *	a request may be performed while another reuqest is running.
+ */
+static void mmc_post_req(struct mmc_host *host, struct mmc_request *mrq,
+			 int err)
+{
+	if (host->ops->post_req)
+		host->ops->post_req(host, mrq, err);
+}
+
+/**
+ *	mmc_start_req - start a non-blocking request
+ *	@host: MMC host to start command
+ *	@areq: async request to start
+ *	@error: out parameter returns 0 for success, otherwise non zero
+ *
+ *	Start a new MMC custom command request for a host.
+ *	If there is on ongoing async request wait for completion
+ *	of that request and start the new one and return.
+ *	Does not wait for the new request to complete.
+ *
+ *      Returns the completed request, NULL in case of none completed.
+ *	Wait for the an ongoing request (previoulsy started) to complete and
+ *	return the completed request. If there is no ongoing request, NULL
+ *	is returned without waiting. NULL is not an error condition.
+ */
+struct mmc_async_req *mmc_start_req(struct mmc_host *host,
+				    struct mmc_async_req *areq, int *error)
+{
+	int err = 0;
+	struct mmc_async_req *data = host->areq;
+
+	/* Prepare a new request */
+	if (areq)
+		mmc_pre_req(host, areq->mrq, !host->areq);
+
+	if (host->areq) {
+		mmc_wait_for_req_done(host, host->areq->mrq);
+		err = host->areq->err_check(host->card, host->areq);
+		if (err) {
+			mmc_post_req(host, host->areq->mrq, 0);
+			if (areq)
+				mmc_post_req(host, areq->mrq, -EINVAL);
+
+			host->areq = NULL;
+			goto out;
+		}
+	}
+
+	if (areq)
+		__mmc_start_req(host, areq->mrq);
+
+	if (host->areq)
+		mmc_post_req(host, host->areq->mrq, 0);
+
+	host->areq = areq;
+ out:
+	if (error)
+		*error = err;
+	return data;
+}
+EXPORT_SYMBOL(mmc_start_req);
+
 /**
  *	mmc_wait_for_req - start a request and wait for completion
  *	@host: MMC host to start command
@@ -212,16 +312,9 @@ static void mmc_wait_done(struct mmc_request *mrq)
  */
 void mmc_wait_for_req(struct mmc_host *host, struct mmc_request *mrq)
 {
-	DECLARE_COMPLETION_ONSTACK(complete);
-
-	mrq->done_data = &complete;
-	mrq->done = mmc_wait_done;
-
-	mmc_start_request(host, mrq);
-
-	wait_for_completion(&complete);
+	__mmc_start_req(host, mrq);
+	mmc_wait_for_req_done(host, mrq);
 }
-
 EXPORT_SYMBOL(mmc_wait_for_req);
 
 /**

commit e056a1b5b67b4e4bfad00bf143ab14f634777705
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Tue Jun 28 17:16:02 2011 +0300

    mmc: queue: let host controllers specify maximum discard timeout
    
    Some host controllers will not operate without a hardware
    timeout that is limited in value.  However large discards
    require large timeouts, so there needs to be a way to
    specify the maximum discard size.
    
    A host controller driver may now specify the maximum discard
    timeout possible so that max_discard_sectors can be calculated.
    
    However, for eMMC when the High Capacity Erase Group Size
    is not in use, the timeout calculation depends on clock
    rate which may change.  For that case Preferred Erase Size
    is used instead.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 7843efe22359..ac82865b8c2f 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1516,6 +1516,82 @@ int mmc_erase_group_aligned(struct mmc_card *card, unsigned int from,
 }
 EXPORT_SYMBOL(mmc_erase_group_aligned);
 
+static unsigned int mmc_do_calc_max_discard(struct mmc_card *card,
+					    unsigned int arg)
+{
+	struct mmc_host *host = card->host;
+	unsigned int max_discard, x, y, qty = 0, max_qty, timeout;
+	unsigned int last_timeout = 0;
+
+	if (card->erase_shift)
+		max_qty = UINT_MAX >> card->erase_shift;
+	else if (mmc_card_sd(card))
+		max_qty = UINT_MAX;
+	else
+		max_qty = UINT_MAX / card->erase_size;
+
+	/* Find the largest qty with an OK timeout */
+	do {
+		y = 0;
+		for (x = 1; x && x <= max_qty && max_qty - x >= qty; x <<= 1) {
+			timeout = mmc_erase_timeout(card, arg, qty + x);
+			if (timeout > host->max_discard_to)
+				break;
+			if (timeout < last_timeout)
+				break;
+			last_timeout = timeout;
+			y = x;
+		}
+		qty += y;
+	} while (y);
+
+	if (!qty)
+		return 0;
+
+	if (qty == 1)
+		return 1;
+
+	/* Convert qty to sectors */
+	if (card->erase_shift)
+		max_discard = --qty << card->erase_shift;
+	else if (mmc_card_sd(card))
+		max_discard = qty;
+	else
+		max_discard = --qty * card->erase_size;
+
+	return max_discard;
+}
+
+unsigned int mmc_calc_max_discard(struct mmc_card *card)
+{
+	struct mmc_host *host = card->host;
+	unsigned int max_discard, max_trim;
+
+	if (!host->max_discard_to)
+		return UINT_MAX;
+
+	/*
+	 * Without erase_group_def set, MMC erase timeout depends on clock
+	 * frequence which can change.  In that case, the best choice is
+	 * just the preferred erase size.
+	 */
+	if (mmc_card_mmc(card) && !(card->ext_csd.erase_group_def & 1))
+		return card->pref_erase;
+
+	max_discard = mmc_do_calc_max_discard(card, MMC_ERASE_ARG);
+	if (mmc_can_trim(card)) {
+		max_trim = mmc_do_calc_max_discard(card, MMC_TRIM_ARG);
+		if (max_trim < max_discard)
+			max_discard = max_trim;
+	} else if (max_discard < card->erase_size) {
+		max_discard = 0;
+	}
+	pr_debug("%s: calculated max. discard sectors %u for timeout %u ms\n",
+		 mmc_hostname(host), max_discard, host->max_discard_to);
+	return max_discard;
+}
+EXPORT_SYMBOL(mmc_calc_max_discard);
+
 int mmc_set_blocklen(struct mmc_card *card, unsigned int blocklen)
 {
 	struct mmc_command cmd = {0};

commit 4cf8c6dd2e261da94b87c4deadcc136ab022b6ac
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Thu Jun 23 13:40:27 2011 +0300

    mmc: core: make erase timeout calculation allow for gated clock
    
    The erase timeout calculation may depend on clock rate
    which is zero if the clock is gated, so use
    mmc_host_clk_rate() which allows for that case.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 68091dda3f31..7843efe22359 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1245,7 +1245,7 @@ static unsigned int mmc_mmc_erase_timeout(struct mmc_card *card,
 		 */
 		timeout_clks <<= 1;
 		timeout_us += (timeout_clks * 1000) /
-			      (card->host->ios.clock / 1000);
+			      (mmc_host_clk_rate(card->host) / 1000);
 
 		erase_timeout = timeout_us / 1000;
 

commit 06b2233a20bf25c8ee57b7c6e13f528309ac6edc
Author: Jaehoon Chung <jh80.chung@samsung.com>
Date:   Thu May 12 17:18:59 2011 +0900

    mmc: core: duplicated trial with same freq in mmc_rescan_try_freq()
    
    mmc_rescan_try_freq() tries to init two times with the last frequency.
    For example, if host->f_min is 400KHz, we see the message below:
    
    mmc1: mmc_rescan_try_freq: trying to init card at 400000 Hz
    mmc1: mmc_rescan_try_freq: trying to init card at 400000 Hz
    
    Andy Ross says that he didn't try this code on a board with an f_min
    that exactly matches one of the table entries, which explains why the
    bug wasn't detected.
    
    Signed-off-by: Jaehoon Chung <jh80.chung@samsung.com>
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Cc: Andy Ross <andy.ross@windriver.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 7863eedf3d9a..68091dda3f31 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1608,7 +1608,7 @@ void mmc_rescan(struct work_struct *work)
 	for (i = 0; i < ARRAY_SIZE(freqs); i++) {
 		if (!mmc_rescan_try_freq(host, max(freqs[i], host->f_min)))
 			break;
-		if (freqs[i] < host->f_min)
+		if (freqs[i] <= host->f_min)
 			break;
 	}
 	mmc_release_host(host);

commit 4c4cb171054230c2e58ed6574d7faa1871c75bbe
Author: Philip Rakity <prakity@marvell.com>
Date:   Fri May 13 11:17:18 2011 +0530

    mmc: core: add support for eMMC Dual Data Rate
    
    eMMC voltage change not required for 1.8V.  3.3V and 1.8V vcc
    are capable of doing DDR. vccq of 1.8v is not required.
    
    Signed-off-by: Philip Rakity <prakity@marvell.com>
    Reviewed-by: Arindam Nath <arindam.nath@amd.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 94c8d5a9ecae..7863eedf3d9a 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -717,23 +717,13 @@ void mmc_set_bus_mode(struct mmc_host *host, unsigned int mode)
 	mmc_set_ios(host);
 }
 
-/*
- * Change data bus width and DDR mode of a host.
- */
-void mmc_set_bus_width_ddr(struct mmc_host *host, unsigned int width,
-			   unsigned int ddr)
-{
-	host->ios.bus_width = width;
-	host->ios.ddr = ddr;
-	mmc_set_ios(host);
-}
-
 /*
  * Change data bus width of a host.
  */
 void mmc_set_bus_width(struct mmc_host *host, unsigned int width)
 {
-	mmc_set_bus_width_ddr(host, width, MMC_SDR_MODE);
+	host->ios.bus_width = width;
+	mmc_set_ios(host);
 }
 
 /**

commit 261bbd463a091b939770255d559bbc89b1bad568
Author: Philip Rakity <prakity@marvell.com>
Date:   Fri May 13 11:17:17 2011 +0530

    mmc: core: eMMC signal voltage does not use CMD11
    
    eMMC chips do not use CMD11 when changing voltage.  Add extra
    argument to call to indicate if CMD11 needs to be sent.
    
    Signed-off-by: Philip Rakity <prakity@marvell.com>
    Reviewed-by: Arindam Nath <arindam.nath@amd.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 72e113e7f253..94c8d5a9ecae 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -942,7 +942,7 @@ u32 mmc_select_voltage(struct mmc_host *host, u32 ocr)
 	return ocr;
 }
 
-int mmc_set_signal_voltage(struct mmc_host *host, int signal_voltage)
+int mmc_set_signal_voltage(struct mmc_host *host, int signal_voltage, bool cmd11)
 {
 	struct mmc_command cmd = {0};
 	int err = 0;
@@ -953,7 +953,7 @@ int mmc_set_signal_voltage(struct mmc_host *host, int signal_voltage)
 	 * Send CMD11 only if the request is to switch the card to
 	 * 1.8V signalling.
 	 */
-	if (signal_voltage == MMC_SIGNAL_VOLTAGE_180) {
+	if ((signal_voltage != MMC_SIGNAL_VOLTAGE_330) && cmd11) {
 		cmd.opcode = SD_SWITCH_VOLTAGE;
 		cmd.arg = 0;
 		cmd.flags = MMC_RSP_R1 | MMC_CMD_AC;

commit a8e6df7343cf67c9104955da0de70075a6ee1dfd
Author: Eliad Peller <eliad@wizery.com>
Date:   Mon May 9 11:32:31 2011 +0300

    mmc: core: clear MMC_PM_KEEP_POWER flag on resume
    
    Since the MMC_PM_KEEP_POWER flag should be set on each suspend,
    it should also cleared on each resume.
    
    Upon resuming, we have to know if power was kept
    (for re-initialization, etc.), so clear it just after resuming.
    
    Signed-off-by: Eliad Peller <eliad@wizery.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 61c6c0b8f0e0..72e113e7f253 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1829,6 +1829,7 @@ int mmc_resume_host(struct mmc_host *host)
 			err = 0;
 		}
 	}
+	host->pm_flags &= ~MMC_PM_KEEP_POWER;
 	mmc_bus_put(host);
 
 	return err;

commit d6d50a15a2897d4133d536dd4343b5cf21163db3
Author: Arindam Nath <arindam.nath@amd.com>
Date:   Thu May 5 12:18:59 2011 +0530

    mmc: sd: add support for driver type selection
    
    This patch adds support for setting driver strength during UHS-I
    initialization procedure. Since UHS-I cards set S18A (bit 24) in
    response to ACMD41, we use this as a base for UHS-I initialization.
    We modify the parameter list of mmc_sd_get_cid() so that we can
    save the ROCR from ACMD41 to check whether bit 24 is set.
    
    We decide whether the Host Controller supports A, C, or D driver
    type depending on the Capabilities register. Driver type B is
    suported by default. We then set the appropriate driver type for
    the card using CMD6 mode 1. As per Host Controller spec v3.00, we
    set driver type for the host only if Preset Value Enable in the
    Host Control2 register is not set. SDHCI_HOST_CONTROL has been
    renamed to SDHCI_HOST_CONTROL1 to conform to the spec.
    
    Tested by Zhangfei Gao with a Toshiba uhs card and general hs card,
    on mmp2 in SDMA mode.
    
    Signed-off-by: Arindam Nath <arindam.nath@amd.com>
    Reviewed-by: Philip Rakity <prakity@marvell.com>
    Tested-by: Philip Rakity <prakity@marvell.com>
    Acked-by: Zhangfei Gao <zhangfei.gao@marvell.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 5005a6323165..61c6c0b8f0e0 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -983,6 +983,15 @@ void mmc_set_timing(struct mmc_host *host, unsigned int timing)
 	mmc_set_ios(host);
 }
 
+/*
+ * Select appropriate driver type for host.
+ */
+void mmc_set_driver_type(struct mmc_host *host, unsigned int drv_type)
+{
+	host->ios.drv_type = drv_type;
+	mmc_set_ios(host);
+}
+
 /*
  * Apply power to the MMC stack.  This is a two-stage process.
  * First, we enable power to the card without the clock running.

commit f2119df6b764609af4baceb68caf1e848c1c8aa7
Author: Arindam Nath <arindam.nath@amd.com>
Date:   Thu May 5 12:18:57 2011 +0530

    mmc: sd: add support for signal voltage switch procedure
    
    Host Controller v3.00 adds another Capabilities register. Apart
    from other things, this new register indicates whether the Host
    Controller supports SDR50, SDR104, and DDR50 UHS-I modes. The spec
    doesn't mention about explicit support for SDR12 and SDR25 UHS-I
    modes, so the Host Controller v3.00 should support them by default.
    Also if the controller supports SDR104 mode, it will also support
    SDR50 mode as well. So depending on the host support, we set the
    corresponding MMC_CAP_* flags. One more new register. Host Control2
    is added in v3.00, which is used during Signal Voltage Switch
    procedure described below.
    
    Since as per v3.00 spec, UHS-I supported hosts should set S18R
    to 1, we set S18R (bit 24) of OCR before sending ACMD41. We also
    need to set XPC (bit 28) of OCR in case the host can supply >150mA.
    This support is indicated by the Maximum Current Capabilities
    register of the Host Controller.
    
    If the response of ACMD41 has both CCS and S18A set, we start the
    signal voltage switch procedure, which if successfull, will switch
    the card from 3.3V signalling to 1.8V signalling. Signal voltage
    switch procedure adds support for a new command CMD11 in the
    Physical Layer Spec v3.01. As part of this procedure, we need to
    set 1.8V Signalling Enable (bit 3) of Host Control2 register, which
    if remains set after 5ms, means the switch to 1.8V signalling is
    successfull. Otherwise, we clear bit 24 of OCR and retry the
    initialization sequence. When we remove the card, and insert the
    same or another card, we need to make sure that we start with 3.3V
    signalling voltage. So we call mmc_set_signal_voltage() with
    MMC_SIGNAL_VOLTAGE_330 set so that we are back to 3.3V signalling
    voltage before we actually start initializing the card.
    
    Tested by Zhangfei Gao with a Toshiba uhs card and general hs card,
    on mmp2 in SDMA mode.
    
    Signed-off-by: Arindam Nath <arindam.nath@amd.com>
    Reviewed-by: Philip Rakity <prakity@marvell.com>
    Tested-by: Philip Rakity <prakity@marvell.com>
    Acked-by: Zhangfei Gao <zhangfei.gao@marvell.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 1dbc18576219..5005a6323165 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -942,6 +942,38 @@ u32 mmc_select_voltage(struct mmc_host *host, u32 ocr)
 	return ocr;
 }
 
+int mmc_set_signal_voltage(struct mmc_host *host, int signal_voltage)
+{
+	struct mmc_command cmd = {0};
+	int err = 0;
+
+	BUG_ON(!host);
+
+	/*
+	 * Send CMD11 only if the request is to switch the card to
+	 * 1.8V signalling.
+	 */
+	if (signal_voltage == MMC_SIGNAL_VOLTAGE_180) {
+		cmd.opcode = SD_SWITCH_VOLTAGE;
+		cmd.arg = 0;
+		cmd.flags = MMC_RSP_R1 | MMC_CMD_AC;
+
+		err = mmc_wait_for_cmd(host, &cmd, 0);
+		if (err)
+			return err;
+
+		if (!mmc_host_is_spi(host) && (cmd.resp[0] & R1_ERROR))
+			return -EIO;
+	}
+
+	host->ios.signal_voltage = signal_voltage;
+
+	if (host->ops->start_signal_voltage_switch)
+		err = host->ops->start_signal_voltage_switch(host, &host->ios);
+
+	return err;
+}
+
 /*
  * Select timing parameters for host.
  */

commit 24f5b53ba076e983bc64fa48534ca795d7813d51
Author: Chris Ball <cjb@laptop.org>
Date:   Wed Apr 13 23:49:45 2011 -0400

    mmc: initialize struct mmc_request at declaration time
    
    Converts from:
            struct mmc_request mrq;
            memset(&mrq, 0, sizeof(struct mmc_request));
    
    to:
            struct mmc_request mrq = {0};
    
    because it's shorter, as performant, and easier to work out whether
    initialization has happened.
    
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index f273ffd6557a..1dbc18576219 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -236,12 +236,10 @@ EXPORT_SYMBOL(mmc_wait_for_req);
  */
 int mmc_wait_for_cmd(struct mmc_host *host, struct mmc_command *cmd, int retries)
 {
-	struct mmc_request mrq;
+	struct mmc_request mrq = {0};
 
 	WARN_ON(!host->claimed);
 
-	memset(&mrq, 0, sizeof(struct mmc_request));
-
 	memset(cmd->resp, 0, sizeof(cmd->resp));
 	cmd->retries = retries;
 

commit 1278dba167f01bb3c6626d16450d31129d041087
Author: Chris Ball <cjb@laptop.org>
Date:   Wed Apr 13 23:40:30 2011 -0400

    mmc: initialize struct mmc_command at declaration time
    
    Converts from:
            struct mmc_command cmd;
            memset(&cmd, 0, sizeof(struct mmc_command));
    
    to:
            struct mmc_command cmd = {0};
    
    because it's shorter, as performant, and easier to work out whether
    initialization has happened.
    
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 5178d5daa5f4..f273ffd6557a 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1286,7 +1286,7 @@ static unsigned int mmc_erase_timeout(struct mmc_card *card,
 static int mmc_do_erase(struct mmc_card *card, unsigned int from,
 			unsigned int to, unsigned int arg)
 {
-	struct mmc_command cmd;
+	struct mmc_command cmd = {0};
 	unsigned int qty = 0;
 	int err;
 
@@ -1320,7 +1320,6 @@ static int mmc_do_erase(struct mmc_card *card, unsigned int from,
 		to <<= 9;
 	}
 
-	memset(&cmd, 0, sizeof(struct mmc_command));
 	if (mmc_card_sd(card))
 		cmd.opcode = SD_ERASE_WR_BLK_START;
 	else
@@ -1490,12 +1489,11 @@ EXPORT_SYMBOL(mmc_erase_group_aligned);
 
 int mmc_set_blocklen(struct mmc_card *card, unsigned int blocklen)
 {
-	struct mmc_command cmd;
+	struct mmc_command cmd = {0};
 
 	if (mmc_card_blockaddr(card) || mmc_card_ddr_mode(card))
 		return 0;
 
-	memset(&cmd, 0, sizeof(struct mmc_command));
 	cmd.opcode = MMC_SET_BLOCKLEN;
 	cmd.arg = blocklen;
 	cmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_AC;

commit eaa02f751ff4f8abfc2e55a15c20a5a274244418
Author: Andrei Warkentin <andreiw@motorola.com>
Date:   Mon Apr 11 16:13:41 2011 -0500

    mmc: core: Rename erase_timeout to cmd_timeout_ms.
    
    Renames erase_timeout to cmd_timeout_ms inside struct mmc_command.
    First step to making host honor timeouts for non-data-transfer
    commands. Cleans up erase timeout code.
    
    Signed-off-by: Andrei Warkentin <andreiw@motorola.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index c2350e474159..5178d5daa5f4 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1187,9 +1187,8 @@ void mmc_init_erase(struct mmc_card *card)
 	}
 }
 
-static void mmc_set_mmc_erase_timeout(struct mmc_card *card,
-				      struct mmc_command *cmd,
-				      unsigned int arg, unsigned int qty)
+static unsigned int mmc_mmc_erase_timeout(struct mmc_card *card,
+				          unsigned int arg, unsigned int qty)
 {
 	unsigned int erase_timeout;
 
@@ -1246,38 +1245,42 @@ static void mmc_set_mmc_erase_timeout(struct mmc_card *card,
 	if (mmc_host_is_spi(card->host) && erase_timeout < 1000)
 		erase_timeout = 1000;
 
-	cmd->erase_timeout = erase_timeout;
+	return erase_timeout;
 }
 
-static void mmc_set_sd_erase_timeout(struct mmc_card *card,
-				     struct mmc_command *cmd, unsigned int arg,
-				     unsigned int qty)
+static unsigned int mmc_sd_erase_timeout(struct mmc_card *card,
+					 unsigned int arg,
+					 unsigned int qty)
 {
+	unsigned int erase_timeout;
+
 	if (card->ssr.erase_timeout) {
 		/* Erase timeout specified in SD Status Register (SSR) */
-		cmd->erase_timeout = card->ssr.erase_timeout * qty +
-				     card->ssr.erase_offset;
+		erase_timeout = card->ssr.erase_timeout * qty +
+				card->ssr.erase_offset;
 	} else {
 		/*
 		 * Erase timeout not specified in SD Status Register (SSR) so
 		 * use 250ms per write block.
 		 */
-		cmd->erase_timeout = 250 * qty;
+		erase_timeout = 250 * qty;
 	}
 
 	/* Must not be less than 1 second */
-	if (cmd->erase_timeout < 1000)
-		cmd->erase_timeout = 1000;
+	if (erase_timeout < 1000)
+		erase_timeout = 1000;
+
+	return erase_timeout;
 }
 
-static void mmc_set_erase_timeout(struct mmc_card *card,
-				  struct mmc_command *cmd, unsigned int arg,
-				  unsigned int qty)
+static unsigned int mmc_erase_timeout(struct mmc_card *card,
+				      unsigned int arg,
+				      unsigned int qty)
 {
 	if (mmc_card_sd(card))
-		mmc_set_sd_erase_timeout(card, cmd, arg, qty);
+		return mmc_sd_erase_timeout(card, arg, qty);
 	else
-		mmc_set_mmc_erase_timeout(card, cmd, arg, qty);
+		return mmc_mmc_erase_timeout(card, arg, qty);
 }
 
 static int mmc_do_erase(struct mmc_card *card, unsigned int from,
@@ -1351,7 +1354,7 @@ static int mmc_do_erase(struct mmc_card *card, unsigned int from,
 	cmd.opcode = MMC_ERASE;
 	cmd.arg = arg;
 	cmd.flags = MMC_RSP_SPI_R1B | MMC_RSP_R1B | MMC_CMD_AC;
-	mmc_set_erase_timeout(card, &cmd, arg, qty);
+	cmd.cmd_timeout_ms = mmc_erase_timeout(card, arg, qty);
 	err = mmc_wait_for_cmd(card->host, &cmd, 0);
 	if (err) {
 		printk(KERN_ERR "mmc_erase: erase error %d, status %#x\n",

commit a5e9425d2010978c5f85986cc70a9fa0c0d5b912
Author: Ohad Ben-Cohen <ohad@wizery.com>
Date:   Tue Apr 5 17:43:20 2011 +0300

    mmc: mmc_card_keep_power cleanups
    
    mmc_card_is_powered_resumed is a mouthful; instead, simply use
    mmc_card_keep_power, which also better explains the purpose of
    the macro.
    
    Employ mmc_card_keep_power() where possible.
    
    Signed-off-by: Ohad Ben-Cohen <ohad@wizery.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 1f453acc8682..c2350e474159 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1746,7 +1746,7 @@ int mmc_suspend_host(struct mmc_host *host)
 	}
 	mmc_bus_put(host);
 
-	if (!err && !(host->pm_flags & MMC_PM_KEEP_POWER))
+	if (!err && !mmc_card_keep_power(host))
 		mmc_power_off(host);
 
 	return err;
@@ -1764,7 +1764,7 @@ int mmc_resume_host(struct mmc_host *host)
 
 	mmc_bus_get(host);
 	if (host->bus_ops && !host->bus_dead) {
-		if (!(host->pm_flags & MMC_PM_KEEP_POWER)) {
+		if (!mmc_card_keep_power(host)) {
 			mmc_power_up(host);
 			mmc_select_voltage(host, host->ocr);
 			/*

commit b33d46c398fd071dccd0815f33620924684860cd
Author: Ulf Hansson <ulf.hansson@stericsson.com>
Date:   Sat Mar 5 14:36:24 2011 +0100

    mmc: core: reset card voltage after power off
    
    At power off, reset OCR mask to be the highest possible voltage
    supported for the current mmc host.
    
    This solves the re-initialization during the power up sequence.
    The voltage may have been decreased due to the card accepts a lower
    voltage than the voltage used during the initialization sequence.
    We need to reset the voltage to by the host highest possible value
    since according to specification the initialization must always be
    done at high voltage.
    
    Reviewed-by: Jonas Aberg <jonas.aberg@stericsson.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@stericsson.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 4956da133be4..1f453acc8682 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1009,6 +1009,13 @@ static void mmc_power_off(struct mmc_host *host)
 {
 	host->ios.clock = 0;
 	host->ios.vdd = 0;
+
+	/*
+	 * Reset ocr mask to be the highest possible voltage supported for
+	 * this mmc host. This value will be used at next power up.
+	 */
+	host->ocr = 1 << (fls(host->ocr_avail) - 1);
+
 	if (!mmc_host_is_spi(host)) {
 		host->ios.bus_mode = MMC_BUSMODE_OPENDRAIN;
 		host->ios.chip_select = MMC_CS_DONTCARE;

commit ab1efd271704416c9e6e9cb4e5f58e7e4c4260e6
Author: Ulf Hansson <ulf.hansson@stericsson.com>
Date:   Wed Mar 9 09:11:02 2011 +0100

    mmc: core: export function mmc_do_release_host()
    
    When using mmc_try_claim_host the corresponding release
    function is mmc_do_release_host, which then also must
    be exported.
    
    Reviewed-by: Jonas Aberg <jonas.aberg@stericsson.com>
    Reviewed-by: Sebastian Rasmussen <sebastian.rasmussen@stericsson.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@stericsson.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index c47e13b79eee..4956da133be4 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -527,7 +527,14 @@ int mmc_try_claim_host(struct mmc_host *host)
 }
 EXPORT_SYMBOL(mmc_try_claim_host);
 
-static void mmc_do_release_host(struct mmc_host *host)
+/**
+ *	mmc_do_release_host - release a claimed host
+ *	@host: mmc host to release
+ *
+ *	If you successfully claimed a host, this function will
+ *	release it again.
+ */
+void mmc_do_release_host(struct mmc_host *host)
 {
 	unsigned long flags;
 
@@ -542,6 +549,7 @@ static void mmc_do_release_host(struct mmc_host *host)
 		wake_up(&host->wq);
 	}
 }
+EXPORT_SYMBOL(mmc_do_release_host);
 
 void mmc_host_deeper_disable(struct work_struct *work)
 {

commit 2f94e55ae5ddad83e661002985d2ea11b6d51d3d
Author: Philip Rakity <prakity@marvell.com>
Date:   Sun Feb 13 23:12:28 2011 -0800

    mmc: core: comment on why sdio_reset is done at init time
    
    sdio_reset sends a CMD52 to reset the sdio card.  This is highly
    recommended for sdio cards being reinitialized.  Since we do not
    know if the card is being reinitialized we just send the command.
    SD/eMMC cards are supposed to ignore the CMD before the CMD0.
    Document why we are doing this.
    
    Signed-off-by: Philip Rakity <prakity@marvell.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 2af2ee1a2265..c47e13b79eee 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1494,6 +1494,12 @@ static int mmc_rescan_try_freq(struct mmc_host *host, unsigned freq)
 		mmc_hostname(host), __func__, host->f_init);
 #endif
 	mmc_power_up(host);
+
+	/*
+	 * sdio_reset sends CMD52 to reset card.  Since we do not know
+	 * if the card is being re-initialized, just send it.  CMD52
+	 * should be ignored by SD/eMMC cards.
+	 */
 	sdio_reset(host);
 	mmc_go_idle(host);
 

commit 66c036e0142fed2484d58a2d3c7a4d21ba32b6a6
Author: Pierre Tardy <pierre.tardy@intel.com>
Date:   Sun Feb 6 19:02:48 2011 +0100

    mmc: put the led blinking code after clock ungating
    
    Since mmc clock gating can also be used as a power gating
    tip, it's better to put the led blinking after having
    ungated the clock.
    
    Signed-off-by: Pierre Tardy <pierre.tardy@intel.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 150b5f3cd401..2af2ee1a2265 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -167,8 +167,6 @@ mmc_start_request(struct mmc_host *host, struct mmc_request *mrq)
 
 	WARN_ON(!host->claimed);
 
-	led_trigger_event(host->led, LED_FULL);
-
 	mrq->cmd->error = 0;
 	mrq->cmd->mrq = mrq;
 	if (mrq->data) {
@@ -194,6 +192,7 @@ mmc_start_request(struct mmc_host *host, struct mmc_request *mrq)
 		}
 	}
 	mmc_host_clk_ungate(host);
+	led_trigger_event(host->led, LED_FULL);
 	host->ops->request(host, mrq);
 }
 

commit bad3babace2ee4d1763b4016a662a5c660ab92e9
Author: Ohad Ben-Cohen <ohad@wizery.com>
Date:   Tue Mar 8 23:32:02 2011 +0200

    mmc: fix CONFIG_MMC_UNSAFE_RESUME regression
    
    30201e7f3 ("mmc: skip detection of nonremovable cards on rescan")
    allowed skipping detection of nonremovable cards on mmc_rescan().
    The intention was to only skip detection of hardwired cards that
    cannot be removed, so make sure this is indeed the case by directly
    checking for (lack of) MMC_CAP_NONREMOVABLE, instead of using
    mmc_card_is_removable(), which is overloaded with
    CONFIG_MMC_UNSAFE_RESUME semantics.
    
    The user-visible symptom of the bug this patch fixes is that no
    "mmc: card XXXX removed" message appears in dmesg when a card is
    removed and CONFIG_MMC_UNSAFE_RESUME=y.
    
    Reported-and-tested-by: Dmitry Shmidt <dimitrysh@google.com>
    Reported-and-tested-by: Maxim Levitsky <maximlevitsky@gmail.com>
    Signed-off-by: Ohad Ben-Cohen <ohad@wizery.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 6625c057be05..150b5f3cd401 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1529,7 +1529,7 @@ void mmc_rescan(struct work_struct *work)
 	 * still present
 	 */
 	if (host->bus_ops && host->bus_ops->detect && !host->bus_dead
-	    && mmc_card_is_removable(host))
+	    && !(host->caps & MMC_CAP_NONREMOVABLE))
 		host->bus_ops->detect(host);
 
 	/*

commit e9b86841b372de01ae865080118e29159d8b7c39
Author: Linus Walleij <linus.walleij@stericsson.com>
Date:   Wed Jan 5 00:44:32 2011 +0100

    mmc: fix division by zero in MMC core
    
    The card is not always clocked and the clock frequency zero is perfectly
    legal, thus this code in mmc_set_data_timeout() may cause a division by
    zero. It will be triggered more often if you're using software clock
    gating but can be triggered under other conditions too.
    
    Reported-by: Pierre Tardy <tardyp@gmail.com>
    Signed-off-by: Linus Walleij <linus.walleij@stericsson.com>
    Reviewed-by: Chris Ball <cjb@laptop.org>
    Cc: <stable@kernel.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 4b1d8fb04e9b..6625c057be05 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -299,8 +299,9 @@ void mmc_set_data_timeout(struct mmc_data *data, const struct mmc_card *card)
 		unsigned int timeout_us, limit_us;
 
 		timeout_us = data->timeout_ns / 1000;
-		timeout_us += data->timeout_clks * 1000 /
-			(mmc_host_clk_rate(card->host) / 1000);
+		if (mmc_host_clk_rate(card->host))
+			timeout_us += data->timeout_clks * 1000 /
+				(mmc_host_clk_rate(card->host) / 1000);
 
 		if (data->flags & MMC_DATA_WRITE)
 			/*

commit c584179828b268152f5ff82dab529a2c095b09ac
Author: Chris Ball <cjb@laptop.org>
Date:   Tue Jan 4 12:20:22 2011 -0500

    mmc: Explain why we make adjacent mmc_bus_{put,get} calls during rescan.
    
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 198f70bad908..4b1d8fb04e9b 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1531,9 +1531,11 @@ void mmc_rescan(struct work_struct *work)
 	    && mmc_card_is_removable(host))
 		host->bus_ops->detect(host);
 
+	/*
+	 * Let mmc_bus_put() free the bus/bus_ops if we've found that
+	 * the card is no longer present.
+	 */
 	mmc_bus_put(host);
-
-
 	mmc_bus_get(host);
 
 	/* if there still is a card present, stop here */

commit 807e8e40673d9628fa7dcdd14423424b4ee5f43b
Author: Andy Ross <andy.ross@windriver.com>
Date:   Mon Jan 3 10:36:56 2011 -0800

    mmc: Fix sd/sdio/mmc initialization frequency retries
    
    Rewrite and clean up mmc_rescan() to properly retry frequencies lower
    than 400kHz.  Failures can happen both in sd_send_* calls and
    mmc_attach_*.  Break out "mmc_rescan_try_freq" from the frequency
    selection loop.  Symmetrize claim/release logic in mmc_attach_* API,
    and move the sd_send_* calls there to make mmc_rescan easier to read.
    
    Signed-off-by: Andy Ross <andy.ross@windriver.com>
    Reviewed-and-Tested-by: Hein Tibosch <hein_tibosch@yahoo.es>
    Reviewed-by: Chris Ball <cjb@laptop.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 97e0624eb9b6..198f70bad908 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1485,25 +1485,41 @@ int mmc_set_blocklen(struct mmc_card *card, unsigned int blocklen)
 }
 EXPORT_SYMBOL(mmc_set_blocklen);
 
+static int mmc_rescan_try_freq(struct mmc_host *host, unsigned freq)
+{
+	host->f_init = freq;
+
+#ifdef CONFIG_MMC_DEBUG
+	pr_info("%s: %s: trying to init card at %u Hz\n",
+		mmc_hostname(host), __func__, host->f_init);
+#endif
+	mmc_power_up(host);
+	sdio_reset(host);
+	mmc_go_idle(host);
+
+	mmc_send_if_cond(host, host->ocr_avail);
+
+	/* Order's important: probe SDIO, then SD, then MMC */
+	if (!mmc_attach_sdio(host))
+		return 0;
+	if (!mmc_attach_sd(host))
+		return 0;
+	if (!mmc_attach_mmc(host))
+		return 0;
+
+	mmc_power_off(host);
+	return -EIO;
+}
+
 void mmc_rescan(struct work_struct *work)
 {
+	static const unsigned freqs[] = { 400000, 300000, 200000, 100000 };
 	struct mmc_host *host =
 		container_of(work, struct mmc_host, detect.work);
-	u32 ocr;
-	int err;
-	unsigned long flags;
 	int i;
-	const unsigned freqs[] = { 400000, 300000, 200000, 100000 };
-
-	spin_lock_irqsave(&host->lock, flags);
 
-	if (host->rescan_disable) {
-		spin_unlock_irqrestore(&host->lock, flags);
+	if (host->rescan_disable)
 		return;
-	}
-
-	spin_unlock_irqrestore(&host->lock, flags);
-
 
 	mmc_bus_get(host);
 
@@ -1526,8 +1542,6 @@ void mmc_rescan(struct work_struct *work)
 		goto out;
 	}
 
-	/* detect a newly inserted card */
-
 	/*
 	 * Only we can add a new handler, so it's safe to
 	 * release the lock here.
@@ -1537,77 +1551,16 @@ void mmc_rescan(struct work_struct *work)
 	if (host->ops->get_cd && host->ops->get_cd(host) == 0)
 		goto out;
 
+	mmc_claim_host(host);
 	for (i = 0; i < ARRAY_SIZE(freqs); i++) {
-		mmc_claim_host(host);
-
-		if (freqs[i] >= host->f_min)
-			host->f_init = freqs[i];
-		else if (!i || freqs[i-1] > host->f_min)
-			host->f_init = host->f_min;
-		else {
-			mmc_release_host(host);
-			goto out;
-		}
-#ifdef CONFIG_MMC_DEBUG
-		pr_info("%s: %s: trying to init card at %u Hz\n",
-			mmc_hostname(host), __func__, host->f_init);
-#endif
-		mmc_power_up(host);
-		sdio_reset(host);
-		mmc_go_idle(host);
-
-		mmc_send_if_cond(host, host->ocr_avail);
-
-		/*
-		 * First we search for SDIO...
-		 */
-		err = mmc_send_io_op_cond(host, 0, &ocr);
-		if (!err) {
-			if (mmc_attach_sdio(host, ocr)) {
-				mmc_claim_host(host);
-				/*
-				 * Try SDMEM (but not MMC) even if SDIO
-				 * is broken.
-				 */
-				mmc_power_up(host);
-				sdio_reset(host);
-				mmc_go_idle(host);
-				mmc_send_if_cond(host, host->ocr_avail);
-
-				if (mmc_send_app_op_cond(host, 0, &ocr))
-					goto out_fail;
-
-				if (mmc_attach_sd(host, ocr))
-					mmc_power_off(host);
-			}
-			goto out;
-		}
-
-		/*
-		 * ...then normal SD...
-		 */
-		err = mmc_send_app_op_cond(host, 0, &ocr);
-		if (!err) {
-			if (mmc_attach_sd(host, ocr))
-				mmc_power_off(host);
-			goto out;
-		}
-
-		/*
-		 * ...and finally MMC.
-		 */
-		err = mmc_send_op_cond(host, 0, &ocr);
-		if (!err) {
-			if (mmc_attach_mmc(host, ocr))
-				mmc_power_off(host);
-			goto out;
-		}
-
-out_fail:
-		mmc_release_host(host);
-		mmc_power_off(host);
+		if (!mmc_rescan_try_freq(host, max(freqs[i], host->f_min)))
+			break;
+		if (freqs[i] < host->f_min)
+			break;
 	}
-out:
+	mmc_release_host(host);
+
+ out:
 	if (host->caps & MMC_CAP_NEEDS_POLL)
 		mmc_schedule_delayed_work(&host->detect, HZ);
 }

commit e6f29a8dc1602e170daf955233891a9130573a55
Author: Michal Miroslaw <mirq-linux@rere.qmqm.pl>
Date:   Thu Dec 2 23:38:12 2010 +0100

    mmc: fix detection of memory part of SD-combo card with broken SDIO
    
    In case of failure, mmc_attach_sdio() will power off the SD bus.
    Power it up and reinitialize before trying SD memory detection.
    
    Reported-by: Sahitya Tummala <stummala@codeaurora.org>
    Signed-off-by: Michał Mirosław <mirq-linux@rere.qmqm.pl>
    Reviewed-by: Chris Ball <cjb@laptop.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 241ffb28351c..97e0624eb9b6 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1569,6 +1569,11 @@ void mmc_rescan(struct work_struct *work)
 				 * Try SDMEM (but not MMC) even if SDIO
 				 * is broken.
 				 */
+				mmc_power_up(host);
+				sdio_reset(host);
+				mmc_go_idle(host);
+				mmc_send_if_cond(host, host->ocr_avail);
+
 				if (mmc_send_app_op_cond(host, 0, &ocr))
 					goto out_fail;
 

commit e594573d790bd7e269f05955d316b88f7be0c14a
Author: Ohad Ben-Cohen <ohad@wizery.com>
Date:   Sun Nov 28 07:21:30 2010 +0200

    mmc: sdio: don't power up cards on system suspend
    
    Initial SDIO runtime PM implementation took a conservative approach
    of powering up cards (and fully reinitializing them) on system suspend,
    just before the suspend handlers of the relevant drivers were executed.
    
    To avoid redundant power and reinitialization cycles, this patch removes
    this behavior: if a card is already powered off when system suspend kicks
    in, it is left at that state.
    
    If a card is active when a system sleep starts, everything is
    straightforward and works exactly like before. But if the card was
    already suspended before the sleep began, then when the MMC core powers
    it back up on resume, its run-time PM status has to be updated to reflect
    the actual post-system sleep status.
    
    The technique to do that is borrowed from the I2C runtime PM
    implementation (for more info see Documentation/power/runtime_pm.txt).
    
    Signed-off-by: Ohad Ben-Cohen <ohad@wizery.com>
    Reviewed-by: Chris Ball <cjb@laptop.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 9683d4d3fced..241ffb28351c 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -22,6 +22,7 @@
 #include <linux/scatterlist.h>
 #include <linux/log2.h>
 #include <linux/regulator/consumer.h>
+#include <linux/pm_runtime.h>
 
 #include <linux/mmc/card.h>
 #include <linux/mmc/host.h>
@@ -1785,6 +1786,18 @@ int mmc_resume_host(struct mmc_host *host)
 		if (!(host->pm_flags & MMC_PM_KEEP_POWER)) {
 			mmc_power_up(host);
 			mmc_select_voltage(host, host->ocr);
+			/*
+			 * Tell runtime PM core we just powered up the card,
+			 * since it still believes the card is powered off.
+			 * Note that currently runtime PM is only enabled
+			 * for SDIO cards that are MMC_CAP_POWER_OFF_CARD
+			 */
+			if (mmc_card_sdio(host->card) &&
+			    (host->caps & MMC_CAP_POWER_OFF_CARD)) {
+				pm_runtime_disable(&host->card->dev);
+				pm_runtime_set_active(&host->card->dev);
+				pm_runtime_enable(&host->card->dev);
+			}
 		}
 		BUG_ON(!host->bus_ops->resume);
 		err = host->bus_ops->resume(host);

commit 30201e7f3ac639fe98fcd25d40346b65dde9ecba
Author: Ohad Ben-Cohen <ohad@wizery.com>
Date:   Sun Nov 28 07:21:28 2010 +0200

    mmc: skip detection of nonremovable cards on rescan
    
    mmc_rescan() checks whether registered cards are still present before
    skipping them, by calling the bus-specific ->detect() handler.
    
    With buses that support runtime PM, the card may be powered off at
    this point, so they need to be powered on and fully reinitialized before
    ->detect() executes.
    
    This whole process is redundant with nonremovable cards; in those cases,
    we can safely skip calling ->detect() and implicitly assume its success.
    
    Signed-off-by: Ohad Ben-Cohen <ohad@wizery.com>
    Reviewed-by: Chris Ball <cjb@laptop.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 722af2dce3bb..9683d4d3fced 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1506,8 +1506,12 @@ void mmc_rescan(struct work_struct *work)
 
 	mmc_bus_get(host);
 
-	/* if there is a card registered, check whether it is still present */
-	if ((host->bus_ops != NULL) && host->bus_ops->detect && !host->bus_dead)
+	/*
+	 * if there is a _removable_ card registered, check whether it is
+	 * still present
+	 */
+	if (host->bus_ops && host->bus_ops->detect && !host->bus_dead
+	    && mmc_card_is_removable(host))
 		host->bus_ops->detect(host);
 
 	mmc_bus_put(host);

commit 04566831a703ae3ef4b49a2deae261c9ed26e020
Author: Linus Walleij <linus.walleij@stericsson.com>
Date:   Mon Nov 8 21:36:50 2010 -0500

    mmc: Aggressive clock gating framework
    
    This patch modifies the MMC core code to optionally call the set_ios()
    operation on the driver with the clock frequency set to 0 (gate) after
    a grace period of at least 8 MCLK cycles, then restore it (ungate)
    before any new request. This gives the driver the option to shut down
    the MCI clock to the MMC/SD card when the clock frequency is 0, i.e.
    the core has stated that the MCI clock does not need to be generated.
    
    It is inspired by existing clock gating code found in the OMAP and
    Atmel drivers and brings this up to the host abstraction.  Gating is
    performed before and after any MMC request.
    
    This patchset implements this for the MMCI/PL180 MMC/SD host controller,
    but it should be simple to switch OMAP/Atmel over to using this instead.
    
    mmc_set_{gated,ungated}() add variable protection to the state holders
    for the clock gating code.  This is particularly important when ordinary
    .set_ios() calls would race with the .set_ios() call resulting from a
    delayed gate operation.
    
    Signed-off-by: Linus Walleij <linus.walleij@stericsson.com>
    Reviewed-by: Chris Ball <cjb@laptop.org>
    Tested-by: Chris Ball <cjb@laptop.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index a3a780faf85a..722af2dce3bb 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -130,6 +130,8 @@ void mmc_request_done(struct mmc_host *host, struct mmc_request *mrq)
 
 		if (mrq->done)
 			mrq->done(mrq);
+
+		mmc_host_clk_gate(host);
 	}
 }
 
@@ -190,6 +192,7 @@ mmc_start_request(struct mmc_host *host, struct mmc_request *mrq)
 			mrq->stop->mrq = mrq;
 		}
 	}
+	mmc_host_clk_ungate(host);
 	host->ops->request(host, mrq);
 }
 
@@ -296,7 +299,7 @@ void mmc_set_data_timeout(struct mmc_data *data, const struct mmc_card *card)
 
 		timeout_us = data->timeout_ns / 1000;
 		timeout_us += data->timeout_clks * 1000 /
-			(card->host->ios.clock / 1000);
+			(mmc_host_clk_rate(card->host) / 1000);
 
 		if (data->flags & MMC_DATA_WRITE)
 			/*
@@ -614,6 +617,8 @@ static inline void mmc_set_ios(struct mmc_host *host)
 		 ios->power_mode, ios->chip_select, ios->vdd,
 		 ios->bus_width, ios->timing);
 
+	if (ios->clock > 0)
+		mmc_set_ungated(host);
 	host->ops->set_ios(host, ios);
 }
 
@@ -641,6 +646,61 @@ void mmc_set_clock(struct mmc_host *host, unsigned int hz)
 	mmc_set_ios(host);
 }
 
+#ifdef CONFIG_MMC_CLKGATE
+/*
+ * This gates the clock by setting it to 0 Hz.
+ */
+void mmc_gate_clock(struct mmc_host *host)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&host->clk_lock, flags);
+	host->clk_old = host->ios.clock;
+	host->ios.clock = 0;
+	host->clk_gated = true;
+	spin_unlock_irqrestore(&host->clk_lock, flags);
+	mmc_set_ios(host);
+}
+
+/*
+ * This restores the clock from gating by using the cached
+ * clock value.
+ */
+void mmc_ungate_clock(struct mmc_host *host)
+{
+	/*
+	 * We should previously have gated the clock, so the clock shall
+	 * be 0 here! The clock may however be 0 during initialization,
+	 * when some request operations are performed before setting
+	 * the frequency. When ungate is requested in that situation
+	 * we just ignore the call.
+	 */
+	if (host->clk_old) {
+		BUG_ON(host->ios.clock);
+		/* This call will also set host->clk_gated to false */
+		mmc_set_clock(host, host->clk_old);
+	}
+}
+
+void mmc_set_ungated(struct mmc_host *host)
+{
+	unsigned long flags;
+
+	/*
+	 * We've been given a new frequency while the clock is gated,
+	 * so make sure we regard this as ungating it.
+	 */
+	spin_lock_irqsave(&host->clk_lock, flags);
+	host->clk_gated = false;
+	spin_unlock_irqrestore(&host->clk_lock, flags);
+}
+
+#else
+void mmc_set_ungated(struct mmc_host *host)
+{
+}
+#endif
+
 /*
  * Change the bus mode (open drain/push-pull) of a host.
  */

commit 23d69b09b78c4876e134f104a3814c30747c53f1
Merge: e744070fd4ff 569ff2de2e1c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jan 7 16:58:04 2011 -0800

    Merge branch 'for-2.6.38' of git://git.kernel.org/pub/scm/linux/kernel/git/tj/wq
    
    * 'for-2.6.38' of git://git.kernel.org/pub/scm/linux/kernel/git/tj/wq: (33 commits)
      usb: don't use flush_scheduled_work()
      speedtch: don't abuse struct delayed_work
      media/video: don't use flush_scheduled_work()
      media/video: explicitly flush request_module work
      ioc4: use static work_struct for ioc4_load_modules()
      init: don't call flush_scheduled_work() from do_initcalls()
      s390: don't use flush_scheduled_work()
      rtc: don't use flush_scheduled_work()
      mmc: update workqueue usages
      mfd: update workqueue usages
      dvb: don't use flush_scheduled_work()
      leds-wm8350: don't use flush_scheduled_work()
      mISDN: don't use flush_scheduled_work()
      macintosh/ams: don't use flush_scheduled_work()
      vmwgfx: don't use flush_scheduled_work()
      tpm: don't use flush_scheduled_work()
      sonypi: don't use flush_scheduled_work()
      hvsi: don't use flush_scheduled_work()
      xen: don't use flush_scheduled_work()
      gdrom: don't use flush_scheduled_work()
      ...
    
    Fixed up trivial conflict in drivers/media/video/bt8xx/bttv-input.c
    as per Tejun.

commit 0d9ee5b2e9aac981fa063339daf04320eac610d1
Author: Tejun Heo <tj@kernel.org>
Date:   Fri Dec 24 16:00:17 2010 +0100

    mmc: update workqueue usages
    
    Workqueue creation API has been updated and flush_scheduled_work() is
    deprecated and scheduled to be removed.
    
    * core/core.c: Use alloc_ordered_workqueue() instead of
      create_singlethread_workqueue().  This removes an unnecessary
      rescuer.
    
    * host/omap.c: Create, use and flush mmc_omap_wq instead of the
      system_wq.
    
    * Flush host->mmc_carddetect_work directly on removal instead of using
      flush_scheduled_work().
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Chris Ball <cjb@laptop.org>
    Cc: linux-mmc@vger.kernel.org

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 8f86d702e46e..55b545fb60b4 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1789,7 +1789,7 @@ static int __init mmc_init(void)
 {
 	int ret;
 
-	workqueue = create_singlethread_workqueue("kmmcd");
+	workqueue = alloc_ordered_workqueue("kmmcd", 0);
 	if (!workqueue)
 		return -ENOMEM;
 

commit 274476f8fe0b6ac9bac542cc39de12c3dd0f43f6
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Dec 10 08:40:31 2010 +0100

    mmc: Fix re-probing with PM_POST_RESTORE notification
    
    In the error-path where PM notifies PM_POST_RESTORE, the rescan-blockage
    should be cleared as well.  Otherwise it'll be never re-probed.
    
    Also, as a bonus, this fixes a bug in S4 with user-mode suspend in the
    current code, as it sends PM_POST_RESTORE instead of
    PM_POST_HIBERNATION wrongly.
    
    Cc: <stable@kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 31ae07a36576..57dcf8fa774a 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1773,6 +1773,7 @@ int mmc_pm_notify(struct notifier_block *notify_block,
 
 	case PM_POST_SUSPEND:
 	case PM_POST_HIBERNATION:
+	case PM_POST_RESTORE:
 
 		spin_lock_irqsave(&host->lock, flags);
 		host->rescan_disable = 0;

commit d9bcbf343ec63e1104b5276195888ee06b4d086f
Author: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
Date:   Thu Nov 11 17:32:25 2010 +0100

    mmc: fix rmmod race for hosts using card-detection polling
    
    MMC hosts that poll for card detection by defining the MMC_CAP_NEEDS_POLL
    flag have a race on rmmod, where the delayed work is cancelled without
    waiting for completed polling. To prevent this a _sync version of the work
    cancellation has to be used.
    
    Signed-off-by: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
    Cc: <stable@kernel.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 8f86d702e46e..31ae07a36576 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1559,7 +1559,7 @@ void mmc_stop_host(struct mmc_host *host)
 
 	if (host->caps & MMC_CAP_DISABLE)
 		cancel_delayed_work(&host->disable);
-	cancel_delayed_work(&host->detect);
+	cancel_delayed_work_sync(&host->detect);
 	mmc_flush_scheduled_work();
 
 	/* clear pm flags now and let card drivers set them as needed */

commit 12ae637f081a7a05144af65802a7b492b9162660
Author: Ohad Ben-Cohen <ohad@wizery.com>
Date:   Sat Oct 2 13:54:06 2010 +0200

    mmc: propagate power save/restore ops return value
    
    Allow power save/restore and their relevant mmc_bus_ops handlers
    exit with a return value.
    
    Signed-off-by: Ohad Ben-Cohen <ohad@wizery.com>
    Tested-by: Luciano Coelho <luciano.coelho@nokia.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 3eb7a9be6d8d..8f86d702e46e 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1583,37 +1583,45 @@ void mmc_stop_host(struct mmc_host *host)
 	mmc_power_off(host);
 }
 
-void mmc_power_save_host(struct mmc_host *host)
+int mmc_power_save_host(struct mmc_host *host)
 {
+	int ret = 0;
+
 	mmc_bus_get(host);
 
 	if (!host->bus_ops || host->bus_dead || !host->bus_ops->power_restore) {
 		mmc_bus_put(host);
-		return;
+		return -EINVAL;
 	}
 
 	if (host->bus_ops->power_save)
-		host->bus_ops->power_save(host);
+		ret = host->bus_ops->power_save(host);
 
 	mmc_bus_put(host);
 
 	mmc_power_off(host);
+
+	return ret;
 }
 EXPORT_SYMBOL(mmc_power_save_host);
 
-void mmc_power_restore_host(struct mmc_host *host)
+int mmc_power_restore_host(struct mmc_host *host)
 {
+	int ret;
+
 	mmc_bus_get(host);
 
 	if (!host->bus_ops || host->bus_dead || !host->bus_ops->power_restore) {
 		mmc_bus_put(host);
-		return;
+		return -EINVAL;
 	}
 
 	mmc_power_up(host);
-	host->bus_ops->power_restore(host);
+	ret = host->bus_ops->power_restore(host);
 
 	mmc_bus_put(host);
+
+	return ret;
 }
 EXPORT_SYMBOL(mmc_power_restore_host);
 

commit 49e3b5a44f8abd33c8693edc575c6d06a210d778
Author: Adrian Hunter <adrian.hunter@nokia.com>
Date:   Mon Oct 11 12:43:50 2010 +0300

    mmc: refine DDR support
    
    One flaw with DDR support is that MMC core does not inform the driver
    which DDR mode it has selected.  This patch expands the ios->ddr flag
    to do that.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@nokia.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 7cb352b3b247..3eb7a9be6d8d 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -653,10 +653,11 @@ void mmc_set_bus_mode(struct mmc_host *host, unsigned int mode)
 /*
  * Change data bus width and DDR mode of a host.
  */
-void mmc_set_bus_width_ddr(struct mmc_host *host, unsigned int width, int ddr)
+void mmc_set_bus_width_ddr(struct mmc_host *host, unsigned int width,
+			   unsigned int ddr)
 {
 	host->ios.bus_width = width;
-	host->ios.ddr = ddr ? MMC_DDR_MODE : MMC_SDR_MODE;
+	host->ios.ddr = ddr;
 	mmc_set_ios(host);
 }
 
@@ -665,7 +666,7 @@ void mmc_set_bus_width_ddr(struct mmc_host *host, unsigned int width, int ddr)
  */
 void mmc_set_bus_width(struct mmc_host *host, unsigned int width)
 {
-	mmc_set_bus_width_ddr(host, width, 0);
+	mmc_set_bus_width_ddr(host, width, MMC_SDR_MODE);
 }
 
 /**

commit 0f8d8ea64ec7c77ca5beb59534d386fe0235961a
Author: Adrian Hunter <adrian.hunter@nokia.com>
Date:   Tue Aug 24 13:20:26 2010 +0300

    mmc: Fixes for Dual Data Rate (DDR) support
    
    The DDR support patch needs the following fixes:
    
    - The block driver does not need to know about DDR, any more
      than it needs to know about bus width.
    - Not only the card must be switched to DDR mode.  The host
      controller must also be configured, which is done through
      the 'set_ios()' function.
    - Do not set the DDR mode state until after the switch command
      is successful.
    - Setting block length is not supported in DDR mode.  Make that
      a core function and change the other place it is used (mmc_test)
      also.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@nokia.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 46029d5c0364..7cb352b3b247 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -651,14 +651,23 @@ void mmc_set_bus_mode(struct mmc_host *host, unsigned int mode)
 }
 
 /*
- * Change data bus width of a host.
+ * Change data bus width and DDR mode of a host.
  */
-void mmc_set_bus_width(struct mmc_host *host, unsigned int width)
+void mmc_set_bus_width_ddr(struct mmc_host *host, unsigned int width, int ddr)
 {
 	host->ios.bus_width = width;
+	host->ios.ddr = ddr ? MMC_DDR_MODE : MMC_SDR_MODE;
 	mmc_set_ios(host);
 }
 
+/*
+ * Change data bus width of a host.
+ */
+void mmc_set_bus_width(struct mmc_host *host, unsigned int width)
+{
+	mmc_set_bus_width_ddr(host, width, 0);
+}
+
 /**
  * mmc_vdd_to_ocrbitnum - Convert a voltage to the OCR bit number
  * @vdd:	voltage (mV)
@@ -1399,6 +1408,21 @@ int mmc_erase_group_aligned(struct mmc_card *card, unsigned int from,
 }
 EXPORT_SYMBOL(mmc_erase_group_aligned);
 
+int mmc_set_blocklen(struct mmc_card *card, unsigned int blocklen)
+{
+	struct mmc_command cmd;
+
+	if (mmc_card_blockaddr(card) || mmc_card_ddr_mode(card))
+		return 0;
+
+	memset(&cmd, 0, sizeof(struct mmc_command));
+	cmd.opcode = MMC_SET_BLOCKLEN;
+	cmd.arg = blocklen;
+	cmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_AC;
+	return mmc_wait_for_cmd(card->host, &cmd, 5);
+}
+EXPORT_SYMBOL(mmc_set_blocklen);
+
 void mmc_rescan(struct work_struct *work)
 {
 	struct mmc_host *host =

commit 99fc5131018cbdc3cf42ce09fb394a4e8b053c74
Author: Linus Walleij <linus.walleij@stericsson.com>
Date:   Wed Sep 29 01:08:27 2010 -0400

    mmc: Move regulator handling closer to core
    
    After discovering a problem in regulator reference counting I took Mark
    Brown's advice to move the reference count into the MMC core by making the
    regulator status a member of struct mmc_host.
    
    I took this opportunity to also implement NULL versions of
    the regulator functions so as to rid the driver code from
    some ugly #ifdef CONFIG_REGULATOR clauses.
    
    Signed-off-by: Linus Walleij <linus.walleij@stericsson.com>
    Reviewed-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Cc: Liam Girdwood <lrg@slimlogic.co.uk>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Adrian Hunter <adrian.hunter@nokia.com>
    Cc: Robert Jarzmik <robert.jarzmik@free.fr>
    Cc: Sundar Iyer <sundar.iyer@stericsson.com>
    Cc: Daniel Mack <daniel@caiaq.de>
    Cc: Pierre Ossman <pierre@ossman.eu>
    Cc: Matt Fleming <matt@console-pimps.org>
    Cc: David Brownell <dbrownell@users.sourceforge.net>
    Cc: Russell King <rmk+kernel@arm.linux.org.uk>
    Cc: Eric Miao <eric.y.miao@gmail.com>
    Cc: Cliff Brake <cbrake@bec-systems.com>
    Cc: Jarkko Lavinen <jarkko.lavinen@nokia.com>
    Cc: <linux-mmc@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index c5e3c9bf6fdd..46029d5c0364 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -772,8 +772,9 @@ EXPORT_SYMBOL(mmc_regulator_get_ocrmask);
 
 /**
  * mmc_regulator_set_ocr - set regulator to match host->ios voltage
- * @vdd_bit: zero for power off, else a bit number (host->ios.vdd)
+ * @mmc: the host to regulate
  * @supply: regulator to use
+ * @vdd_bit: zero for power off, else a bit number (host->ios.vdd)
  *
  * Returns zero on success, else negative errno.
  *
@@ -781,15 +782,12 @@ EXPORT_SYMBOL(mmc_regulator_get_ocrmask);
  * a particular supply voltage.  This would normally be called from the
  * set_ios() method.
  */
-int mmc_regulator_set_ocr(struct regulator *supply, unsigned short vdd_bit)
+int mmc_regulator_set_ocr(struct mmc_host *mmc,
+			struct regulator *supply,
+			unsigned short vdd_bit)
 {
 	int			result = 0;
 	int			min_uV, max_uV;
-	int			enabled;
-
-	enabled = regulator_is_enabled(supply);
-	if (enabled < 0)
-		return enabled;
 
 	if (vdd_bit) {
 		int		tmp;
@@ -820,17 +818,25 @@ int mmc_regulator_set_ocr(struct regulator *supply, unsigned short vdd_bit)
 		else
 			result = 0;
 
-		if (result == 0 && !enabled)
+		if (result == 0 && !mmc->regulator_enabled) {
 			result = regulator_enable(supply);
-	} else if (enabled) {
+			if (!result)
+				mmc->regulator_enabled = true;
+		}
+	} else if (mmc->regulator_enabled) {
 		result = regulator_disable(supply);
+		if (result == 0)
+			mmc->regulator_enabled = false;
 	}
 
+	if (result)
+		dev_err(mmc_dev(mmc),
+			"could not set regulator OCR (%d)\n", result);
 	return result;
 }
 EXPORT_SYMBOL(mmc_regulator_set_ocr);
 
-#endif
+#endif /* CONFIG_REGULATOR */
 
 /*
  * Mask off any voltages we don't support and select

commit 4d0b8611cd4da64f075b8e07a126f0eb498fb153
Author: Eric Bénard <eric@eukrea.com>
Date:   Tue Oct 12 09:29:37 2010 +0200

    mmc: sdhci: mmc_rescan: reduce verbosity
    
    mmc_rescan() includes a pr_info which prints 4 lines each second for
    hosts configured with MMC_CAP_NEEDS_POLL. This patch enables the message
    only if CONFIG_MMC_DEBUG is selected. Tested on i.MX51's sdhci-esdhc.
    
    Signed-off-by: Eric Bénard <eric@eukrea.com>
    Acked-by: Wolfram Sang <w.sang@pengutronix.de>
    Acked-by: Hein Tibosch <hein_tibosch@yahoo.es>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 222466df66ff..c5e3c9bf6fdd 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1452,9 +1452,10 @@ void mmc_rescan(struct work_struct *work)
 			mmc_release_host(host);
 			goto out;
 		}
+#ifdef CONFIG_MMC_DEBUG
 		pr_info("%s: %s: trying to init card at %u Hz\n",
 			mmc_hostname(host), __func__, host->f_init);
-
+#endif
 		mmc_power_up(host);
 		sdio_reset(host);
 		mmc_go_idle(host);

commit 88ae8b866488031b0e2fc05a27440fefec5e6927
Author: Hein Tibosch <hein_tibosch@yahoo.es>
Date:   Mon Sep 6 09:37:19 2010 +0800

    mmc: Make ID freq configurable
    
    In the latest releases of the mmc driver, the freq during initialization
    is set to a fixed 400 Khz.  This was reportedly too fast for several
    users.  As there doesn't seem to be an ideal frequency
    which-works-for-all, Pierre suggested to let the driver try several
    frequencies.
    
    This patch implements that idea. It will try mmc-initialization using
    several frequencies from an array 400, 300, 200 and 100.
    
    In case SDIO is broken, it'll still try to detect SDMEM, also at different
    freqs.
    
    Signed-off-by: Hein Tibosch <hein_tibosch@yahoo.es>
    Cc: Pierre Ossman <pierre@ossman.eu>
    Reviewed-by: Chris Ball <cjb@laptop.org>
    Tested-by: Chris Ball <cjb@laptop.org>
    Cc: Ben Nizette <bn@niasdigital.com>
    Cc: Sascha Hauer <s.hauer@pengutronix.de>
    Cc: Adrian Hunter <adrian.hunter@nokia.com>
    Cc: Matt Fleming <matt@console-pimps.org>
    Cc: <linux-mmc@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index ab4446c428be..222466df66ff 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -908,12 +908,7 @@ static void mmc_power_up(struct mmc_host *host)
 	 */
 	mmc_delay(10);
 
-	if (host->f_min > 400000) {
-		pr_warning("%s: Minimum clock frequency too high for "
-				"identification mode\n", mmc_hostname(host));
-		host->ios.clock = host->f_min;
-	} else
-		host->ios.clock = 400000;
+	host->ios.clock = host->f_init;
 
 	host->ios.power_mode = MMC_POWER_ON;
 	mmc_set_ios(host);
@@ -1405,6 +1400,8 @@ void mmc_rescan(struct work_struct *work)
 	u32 ocr;
 	int err;
 	unsigned long flags;
+	int i;
+	const unsigned freqs[] = { 400000, 300000, 200000, 100000 };
 
 	spin_lock_irqsave(&host->lock, flags);
 
@@ -1444,55 +1441,70 @@ void mmc_rescan(struct work_struct *work)
 	if (host->ops->get_cd && host->ops->get_cd(host) == 0)
 		goto out;
 
-	mmc_claim_host(host);
+	for (i = 0; i < ARRAY_SIZE(freqs); i++) {
+		mmc_claim_host(host);
 
-	mmc_power_up(host);
-	sdio_reset(host);
-	mmc_go_idle(host);
+		if (freqs[i] >= host->f_min)
+			host->f_init = freqs[i];
+		else if (!i || freqs[i-1] > host->f_min)
+			host->f_init = host->f_min;
+		else {
+			mmc_release_host(host);
+			goto out;
+		}
+		pr_info("%s: %s: trying to init card at %u Hz\n",
+			mmc_hostname(host), __func__, host->f_init);
 
-	mmc_send_if_cond(host, host->ocr_avail);
+		mmc_power_up(host);
+		sdio_reset(host);
+		mmc_go_idle(host);
 
-	/*
-	 * First we search for SDIO...
-	 */
-	err = mmc_send_io_op_cond(host, 0, &ocr);
-	if (!err) {
-		if (mmc_attach_sdio(host, ocr)) {
-			mmc_claim_host(host);
-			/* try SDMEM (but not MMC) even if SDIO is broken */
-			if (mmc_send_app_op_cond(host, 0, &ocr))
-				goto out_fail;
+		mmc_send_if_cond(host, host->ocr_avail);
 
+		/*
+		 * First we search for SDIO...
+		 */
+		err = mmc_send_io_op_cond(host, 0, &ocr);
+		if (!err) {
+			if (mmc_attach_sdio(host, ocr)) {
+				mmc_claim_host(host);
+				/*
+				 * Try SDMEM (but not MMC) even if SDIO
+				 * is broken.
+				 */
+				if (mmc_send_app_op_cond(host, 0, &ocr))
+					goto out_fail;
+
+				if (mmc_attach_sd(host, ocr))
+					mmc_power_off(host);
+			}
+			goto out;
+		}
+
+		/*
+		 * ...then normal SD...
+		 */
+		err = mmc_send_app_op_cond(host, 0, &ocr);
+		if (!err) {
 			if (mmc_attach_sd(host, ocr))
 				mmc_power_off(host);
+			goto out;
 		}
-		goto out;
-	}
 
-	/*
-	 * ...then normal SD...
-	 */
-	err = mmc_send_app_op_cond(host, 0, &ocr);
-	if (!err) {
-		if (mmc_attach_sd(host, ocr))
-			mmc_power_off(host);
-		goto out;
-	}
-
-	/*
-	 * ...and finally MMC.
-	 */
-	err = mmc_send_op_cond(host, 0, &ocr);
-	if (!err) {
-		if (mmc_attach_mmc(host, ocr))
-			mmc_power_off(host);
-		goto out;
-	}
+		/*
+		 * ...and finally MMC.
+		 */
+		err = mmc_send_op_cond(host, 0, &ocr);
+		if (!err) {
+			if (mmc_attach_mmc(host, ocr))
+				mmc_power_off(host);
+			goto out;
+		}
 
 out_fail:
-	mmc_release_host(host);
-	mmc_power_off(host);
-
+		mmc_release_host(host);
+		mmc_power_off(host);
+	}
 out:
 	if (host->caps & MMC_CAP_NEEDS_POLL)
 		mmc_schedule_delayed_work(&host->detect, HZ);

commit 71d7d3d190fe77588269a8febf93cd739bd91eb3
Author: Matt Fleming <matt@console-pimps.org>
Date:   Mon Sep 27 09:42:19 2010 +0100

    mmc: Add helper function to check if a card is removable
    
    There are two checks that need to be made when determining whether a
    card is removable. A host controller may set MMC_CAP_NONREMOVABLE if the
    controller does not support removing cards (e.g. eMMC), in which case
    the card is physically non-removable. Also the 'mmc_assume_removable'
    module parameter can be configured at module load time, in which case
    the card may be logically non-removable.
    
    A helper function keeps the logic in one place so that code always
    checks both conditions.
    
    Because this new function is likely to be called from modules we now
    need to export the mmc_assume_removable symbol.
    
    Signed-off-by: Matt Fleming <matt@console-pimps.org>
    Acked-by: Kyungmin Park <kyungmin.park@samsung.com>
    Tested-by: Jaehoon Chung <jh80.chung@samsung.com>
    Acked-by: Wolfram Sang <w.sang@pengutronix.de>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 09eee6df0653..ab4446c428be 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -58,6 +58,7 @@ int mmc_assume_removable;
 #else
 int mmc_assume_removable = 1;
 #endif
+EXPORT_SYMBOL(mmc_assume_removable);
 module_param_named(removable, mmc_assume_removable, bool, 0644);
 MODULE_PARM_DESC(
 	removable,

commit 1c8cf9c997a4a6b36e907c7ede5f048aeaab1644
Author: Ohad Ben-Cohen <ohad@wizery.com>
Date:   Wed Oct 13 09:31:56 2010 +0200

    mmc: sdio: fix SDIO suspend/resume regression
    
    Fix SDIO suspend/resume regression introduced by 4c2ef25fe0b "mmc: fix
    all hangs related to mmc/sd card insert/removal during suspend/resume":
    
      PM: Syncing filesystems ... done.
      Freezing user space processes ... (elapsed 0.01 seconds) done.
      Freezing remaining freezable tasks ... (elapsed 0.01 seconds) done.
      Suspending console(s) (use no_console_suspend to debug)
      pm_op(): platform_pm_suspend+0x0/0x5c returns -38
      PM: Device pxa2xx-mci.0 failed to suspend: error -38
      PM: Some devices failed to suspend
    
    4c2ef25fe0b moved the card removal/insertion mechanism out of MMC's
    suspend/resume path and into pm notifiers (mmc_pm_notify), and that
    broke SDIO's expectation that mmc_suspend_host() will remove the card,
    and squash the error, in case -ENOSYS is returned from the bus suspend
    handler (mmc_sdio_suspend() in this case).
    
    mmc_sdio_suspend() is using this whenever at least one of the card's SDIO
    function drivers does not have suspend/resume handlers - in that case
    it is agreed to force removal of the entire card.
    
    This patch fixes this regression by trivially bringing back that part of
    mmc_suspend_host(), which was removed by 4c2ef25fe0b.
    
    Reported-and-tested-by: Sven Neumann <s.neumann@raumfeld.com>
    Signed-off-by: Ohad Ben-Cohen <ohad@wizery.com>
    Cc: Maxim Levitsky <maximlevitsky@gmail.com>
    Cc: <stable@kernel.org>
    Acked-by: Nicolas Pitre <nico@fluxnic.net>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 5db49b124ffa..09eee6df0653 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1631,6 +1631,19 @@ int mmc_suspend_host(struct mmc_host *host)
 	if (host->bus_ops && !host->bus_dead) {
 		if (host->bus_ops->suspend)
 			err = host->bus_ops->suspend(host);
+		if (err == -ENOSYS || !host->bus_ops->resume) {
+			/*
+			 * We simply "remove" the card in this case.
+			 * It will be redetected on resume.
+			 */
+			if (host->bus_ops->remove)
+				host->bus_ops->remove(host);
+			mmc_claim_host(host);
+			mmc_detach_bus(host);
+			mmc_release_host(host);
+			host->pm_flags = 0;
+			err = 0;
+		}
 	}
 	mmc_bus_put(host);
 

commit dfe86cba7676d58db8de7e623f5e72f1b0d3ca35
Author: Adrian Hunter <adrian.hunter@nokia.com>
Date:   Wed Aug 11 14:17:46 2010 -0700

    mmc: add erase, secure erase, trim and secure trim operations
    
    SD/MMC cards tend to support an erase operation.  In addition, eMMC v4.4
    cards can support secure erase, trim and secure trim operations that are
    all variants of the basic erase command.
    
    SD/MMC device attributes "erase_size" and "preferred_erase_size" have been
    added.
    
    "erase_size" is the minimum size, in bytes, of an erase operation.  For
    MMC, "erase_size" is the erase group size reported by the card.  Note that
    "erase_size" does not apply to trim or secure trim operations where the
    minimum size is always one 512 byte sector.  For SD, "erase_size" is 512
    if the card is block-addressed, 0 otherwise.
    
    SD/MMC cards can erase an arbitrarily large area up to and
    including the whole card.  When erasing a large area it may
    be desirable to do it in smaller chunks for three reasons:
    
        1. A single erase command will make all other I/O on the card
           wait.  This is not a problem if the whole card is being erased, but
           erasing one partition will make I/O for another partition on the
           same card wait for the duration of the erase - which could be a
           several minutes.
    
        2. To be able to inform the user of erase progress.
    
        3. The erase timeout becomes too large to be very useful.
           Because the erase timeout contains a margin which is multiplied by
           the size of the erase area, the value can end up being several
           minutes for large areas.
    
    "erase_size" is not the most efficient unit to erase (especially for SD
    where it is just one sector), hence "preferred_erase_size" provides a good
    chunk size for erasing large areas.
    
    For MMC, "preferred_erase_size" is the high-capacity erase size if a card
    specifies one, otherwise it is based on the capacity of the card.
    
    For SD, "preferred_erase_size" is the allocation unit size specified by
    the card.
    
    "preferred_erase_size" is in bytes.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@nokia.com>
    Acked-by: Jens Axboe <axboe@kernel.dk>
    Cc: Kyungmin Park <kmpark@infradead.org>
    Cc: Madhusudhan Chikkature <madhu.cr@ti.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Ben Gardiner <bengardiner@nanometrics.ca>
    Cc: <linux-mmc@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 83240faa1dc8..5db49b124ffa 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1050,6 +1050,352 @@ void mmc_detect_change(struct mmc_host *host, unsigned long delay)
 
 EXPORT_SYMBOL(mmc_detect_change);
 
+void mmc_init_erase(struct mmc_card *card)
+{
+	unsigned int sz;
+
+	if (is_power_of_2(card->erase_size))
+		card->erase_shift = ffs(card->erase_size) - 1;
+	else
+		card->erase_shift = 0;
+
+	/*
+	 * It is possible to erase an arbitrarily large area of an SD or MMC
+	 * card.  That is not desirable because it can take a long time
+	 * (minutes) potentially delaying more important I/O, and also the
+	 * timeout calculations become increasingly hugely over-estimated.
+	 * Consequently, 'pref_erase' is defined as a guide to limit erases
+	 * to that size and alignment.
+	 *
+	 * For SD cards that define Allocation Unit size, limit erases to one
+	 * Allocation Unit at a time.  For MMC cards that define High Capacity
+	 * Erase Size, whether it is switched on or not, limit to that size.
+	 * Otherwise just have a stab at a good value.  For modern cards it
+	 * will end up being 4MiB.  Note that if the value is too small, it
+	 * can end up taking longer to erase.
+	 */
+	if (mmc_card_sd(card) && card->ssr.au) {
+		card->pref_erase = card->ssr.au;
+		card->erase_shift = ffs(card->ssr.au) - 1;
+	} else if (card->ext_csd.hc_erase_size) {
+		card->pref_erase = card->ext_csd.hc_erase_size;
+	} else {
+		sz = (card->csd.capacity << (card->csd.read_blkbits - 9)) >> 11;
+		if (sz < 128)
+			card->pref_erase = 512 * 1024 / 512;
+		else if (sz < 512)
+			card->pref_erase = 1024 * 1024 / 512;
+		else if (sz < 1024)
+			card->pref_erase = 2 * 1024 * 1024 / 512;
+		else
+			card->pref_erase = 4 * 1024 * 1024 / 512;
+		if (card->pref_erase < card->erase_size)
+			card->pref_erase = card->erase_size;
+		else {
+			sz = card->pref_erase % card->erase_size;
+			if (sz)
+				card->pref_erase += card->erase_size - sz;
+		}
+	}
+}
+
+static void mmc_set_mmc_erase_timeout(struct mmc_card *card,
+				      struct mmc_command *cmd,
+				      unsigned int arg, unsigned int qty)
+{
+	unsigned int erase_timeout;
+
+	if (card->ext_csd.erase_group_def & 1) {
+		/* High Capacity Erase Group Size uses HC timeouts */
+		if (arg == MMC_TRIM_ARG)
+			erase_timeout = card->ext_csd.trim_timeout;
+		else
+			erase_timeout = card->ext_csd.hc_erase_timeout;
+	} else {
+		/* CSD Erase Group Size uses write timeout */
+		unsigned int mult = (10 << card->csd.r2w_factor);
+		unsigned int timeout_clks = card->csd.tacc_clks * mult;
+		unsigned int timeout_us;
+
+		/* Avoid overflow: e.g. tacc_ns=80000000 mult=1280 */
+		if (card->csd.tacc_ns < 1000000)
+			timeout_us = (card->csd.tacc_ns * mult) / 1000;
+		else
+			timeout_us = (card->csd.tacc_ns / 1000) * mult;
+
+		/*
+		 * ios.clock is only a target.  The real clock rate might be
+		 * less but not that much less, so fudge it by multiplying by 2.
+		 */
+		timeout_clks <<= 1;
+		timeout_us += (timeout_clks * 1000) /
+			      (card->host->ios.clock / 1000);
+
+		erase_timeout = timeout_us / 1000;
+
+		/*
+		 * Theoretically, the calculation could underflow so round up
+		 * to 1ms in that case.
+		 */
+		if (!erase_timeout)
+			erase_timeout = 1;
+	}
+
+	/* Multiplier for secure operations */
+	if (arg & MMC_SECURE_ARGS) {
+		if (arg == MMC_SECURE_ERASE_ARG)
+			erase_timeout *= card->ext_csd.sec_erase_mult;
+		else
+			erase_timeout *= card->ext_csd.sec_trim_mult;
+	}
+
+	erase_timeout *= qty;
+
+	/*
+	 * Ensure at least a 1 second timeout for SPI as per
+	 * 'mmc_set_data_timeout()'
+	 */
+	if (mmc_host_is_spi(card->host) && erase_timeout < 1000)
+		erase_timeout = 1000;
+
+	cmd->erase_timeout = erase_timeout;
+}
+
+static void mmc_set_sd_erase_timeout(struct mmc_card *card,
+				     struct mmc_command *cmd, unsigned int arg,
+				     unsigned int qty)
+{
+	if (card->ssr.erase_timeout) {
+		/* Erase timeout specified in SD Status Register (SSR) */
+		cmd->erase_timeout = card->ssr.erase_timeout * qty +
+				     card->ssr.erase_offset;
+	} else {
+		/*
+		 * Erase timeout not specified in SD Status Register (SSR) so
+		 * use 250ms per write block.
+		 */
+		cmd->erase_timeout = 250 * qty;
+	}
+
+	/* Must not be less than 1 second */
+	if (cmd->erase_timeout < 1000)
+		cmd->erase_timeout = 1000;
+}
+
+static void mmc_set_erase_timeout(struct mmc_card *card,
+				  struct mmc_command *cmd, unsigned int arg,
+				  unsigned int qty)
+{
+	if (mmc_card_sd(card))
+		mmc_set_sd_erase_timeout(card, cmd, arg, qty);
+	else
+		mmc_set_mmc_erase_timeout(card, cmd, arg, qty);
+}
+
+static int mmc_do_erase(struct mmc_card *card, unsigned int from,
+			unsigned int to, unsigned int arg)
+{
+	struct mmc_command cmd;
+	unsigned int qty = 0;
+	int err;
+
+	/*
+	 * qty is used to calculate the erase timeout which depends on how many
+	 * erase groups (or allocation units in SD terminology) are affected.
+	 * We count erasing part of an erase group as one erase group.
+	 * For SD, the allocation units are always a power of 2.  For MMC, the
+	 * erase group size is almost certainly also power of 2, but it does not
+	 * seem to insist on that in the JEDEC standard, so we fall back to
+	 * division in that case.  SD may not specify an allocation unit size,
+	 * in which case the timeout is based on the number of write blocks.
+	 *
+	 * Note that the timeout for secure trim 2 will only be correct if the
+	 * number of erase groups specified is the same as the total of all
+	 * preceding secure trim 1 commands.  Since the power may have been
+	 * lost since the secure trim 1 commands occurred, it is generally
+	 * impossible to calculate the secure trim 2 timeout correctly.
+	 */
+	if (card->erase_shift)
+		qty += ((to >> card->erase_shift) -
+			(from >> card->erase_shift)) + 1;
+	else if (mmc_card_sd(card))
+		qty += to - from + 1;
+	else
+		qty += ((to / card->erase_size) -
+			(from / card->erase_size)) + 1;
+
+	if (!mmc_card_blockaddr(card)) {
+		from <<= 9;
+		to <<= 9;
+	}
+
+	memset(&cmd, 0, sizeof(struct mmc_command));
+	if (mmc_card_sd(card))
+		cmd.opcode = SD_ERASE_WR_BLK_START;
+	else
+		cmd.opcode = MMC_ERASE_GROUP_START;
+	cmd.arg = from;
+	cmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_AC;
+	err = mmc_wait_for_cmd(card->host, &cmd, 0);
+	if (err) {
+		printk(KERN_ERR "mmc_erase: group start error %d, "
+		       "status %#x\n", err, cmd.resp[0]);
+		err = -EINVAL;
+		goto out;
+	}
+
+	memset(&cmd, 0, sizeof(struct mmc_command));
+	if (mmc_card_sd(card))
+		cmd.opcode = SD_ERASE_WR_BLK_END;
+	else
+		cmd.opcode = MMC_ERASE_GROUP_END;
+	cmd.arg = to;
+	cmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_AC;
+	err = mmc_wait_for_cmd(card->host, &cmd, 0);
+	if (err) {
+		printk(KERN_ERR "mmc_erase: group end error %d, status %#x\n",
+		       err, cmd.resp[0]);
+		err = -EINVAL;
+		goto out;
+	}
+
+	memset(&cmd, 0, sizeof(struct mmc_command));
+	cmd.opcode = MMC_ERASE;
+	cmd.arg = arg;
+	cmd.flags = MMC_RSP_SPI_R1B | MMC_RSP_R1B | MMC_CMD_AC;
+	mmc_set_erase_timeout(card, &cmd, arg, qty);
+	err = mmc_wait_for_cmd(card->host, &cmd, 0);
+	if (err) {
+		printk(KERN_ERR "mmc_erase: erase error %d, status %#x\n",
+		       err, cmd.resp[0]);
+		err = -EIO;
+		goto out;
+	}
+
+	if (mmc_host_is_spi(card->host))
+		goto out;
+
+	do {
+		memset(&cmd, 0, sizeof(struct mmc_command));
+		cmd.opcode = MMC_SEND_STATUS;
+		cmd.arg = card->rca << 16;
+		cmd.flags = MMC_RSP_R1 | MMC_CMD_AC;
+		/* Do not retry else we can't see errors */
+		err = mmc_wait_for_cmd(card->host, &cmd, 0);
+		if (err || (cmd.resp[0] & 0xFDF92000)) {
+			printk(KERN_ERR "error %d requesting status %#x\n",
+				err, cmd.resp[0]);
+			err = -EIO;
+			goto out;
+		}
+	} while (!(cmd.resp[0] & R1_READY_FOR_DATA) ||
+		 R1_CURRENT_STATE(cmd.resp[0]) == 7);
+out:
+	return err;
+}
+
+/**
+ * mmc_erase - erase sectors.
+ * @card: card to erase
+ * @from: first sector to erase
+ * @nr: number of sectors to erase
+ * @arg: erase command argument (SD supports only %MMC_ERASE_ARG)
+ *
+ * Caller must claim host before calling this function.
+ */
+int mmc_erase(struct mmc_card *card, unsigned int from, unsigned int nr,
+	      unsigned int arg)
+{
+	unsigned int rem, to = from + nr;
+
+	if (!(card->host->caps & MMC_CAP_ERASE) ||
+	    !(card->csd.cmdclass & CCC_ERASE))
+		return -EOPNOTSUPP;
+
+	if (!card->erase_size)
+		return -EOPNOTSUPP;
+
+	if (mmc_card_sd(card) && arg != MMC_ERASE_ARG)
+		return -EOPNOTSUPP;
+
+	if ((arg & MMC_SECURE_ARGS) &&
+	    !(card->ext_csd.sec_feature_support & EXT_CSD_SEC_ER_EN))
+		return -EOPNOTSUPP;
+
+	if ((arg & MMC_TRIM_ARGS) &&
+	    !(card->ext_csd.sec_feature_support & EXT_CSD_SEC_GB_CL_EN))
+		return -EOPNOTSUPP;
+
+	if (arg == MMC_SECURE_ERASE_ARG) {
+		if (from % card->erase_size || nr % card->erase_size)
+			return -EINVAL;
+	}
+
+	if (arg == MMC_ERASE_ARG) {
+		rem = from % card->erase_size;
+		if (rem) {
+			rem = card->erase_size - rem;
+			from += rem;
+			if (nr > rem)
+				nr -= rem;
+			else
+				return 0;
+		}
+		rem = nr % card->erase_size;
+		if (rem)
+			nr -= rem;
+	}
+
+	if (nr == 0)
+		return 0;
+
+	to = from + nr;
+
+	if (to <= from)
+		return -EINVAL;
+
+	/* 'from' and 'to' are inclusive */
+	to -= 1;
+
+	return mmc_do_erase(card, from, to, arg);
+}
+EXPORT_SYMBOL(mmc_erase);
+
+int mmc_can_erase(struct mmc_card *card)
+{
+	if ((card->host->caps & MMC_CAP_ERASE) &&
+	    (card->csd.cmdclass & CCC_ERASE) && card->erase_size)
+		return 1;
+	return 0;
+}
+EXPORT_SYMBOL(mmc_can_erase);
+
+int mmc_can_trim(struct mmc_card *card)
+{
+	if (card->ext_csd.sec_feature_support & EXT_CSD_SEC_GB_CL_EN)
+		return 1;
+	return 0;
+}
+EXPORT_SYMBOL(mmc_can_trim);
+
+int mmc_can_secure_erase_trim(struct mmc_card *card)
+{
+	if (card->ext_csd.sec_feature_support & EXT_CSD_SEC_ER_EN)
+		return 1;
+	return 0;
+}
+EXPORT_SYMBOL(mmc_can_secure_erase_trim);
+
+int mmc_erase_group_aligned(struct mmc_card *card, unsigned int from,
+			    unsigned int nr)
+{
+	if (!card->erase_size)
+		return 0;
+	if (from % card->erase_size || nr % card->erase_size)
+		return 0;
+	return 1;
+}
+EXPORT_SYMBOL(mmc_erase_group_aligned);
 
 void mmc_rescan(struct work_struct *work)
 {

commit 4c2ef25fe0b847d2ae818f74758ddb0be1c27d8e
Author: Maxim Levitsky <maximlevitsky@gmail.com>
Date:   Tue Aug 10 18:01:41 2010 -0700

    mmc: fix all hangs related to mmc/sd card insert/removal during suspend/resume
    
    If you don't use CONFIG_MMC_UNSAFE_RESUME, as soon as you attempt to
    suspend, the card will be removed, therefore this patch doesn't change the
    behavior of this option.
    
    However the removal will be done by pm notifier, which runs while
    userspace is still not frozen and thus can freely use del_gendisk, without
    the risk of deadlock which would happen otherwise.
    
    Card detect workqueue is now disabled while userspace is frozen, Therefore
    if you do use CONFIG_MMC_UNSAFE_RESUME, and remove the card during
    suspend, the removal will be detected as soon as userspace is unfrozen,
    again at the moment it is safe to call del_gendisk.
    
    Tested with and without CONFIG_MMC_UNSAFE_RESUME with suspend and hibernate.
    
    [akpm@linux-foundation.org: clean up function prototype]
    [akpm@linux-foundation.org: fix CONFIG_PM-n linkage, small cleanups]
    [akpm@linux-foundation.org: coding-style fixes]
    Signed-off-by: Maxim Levitsky <maximlevitsky@gmail.com>
    Cc: David Brownell <david-b@pacbell.net>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: <linux-mmc@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index b69ce91b11e1..83240faa1dc8 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1057,6 +1057,17 @@ void mmc_rescan(struct work_struct *work)
 		container_of(work, struct mmc_host, detect.work);
 	u32 ocr;
 	int err;
+	unsigned long flags;
+
+	spin_lock_irqsave(&host->lock, flags);
+
+	if (host->rescan_disable) {
+		spin_unlock_irqrestore(&host->lock, flags);
+		return;
+	}
+
+	spin_unlock_irqrestore(&host->lock, flags);
+
 
 	mmc_bus_get(host);
 
@@ -1274,19 +1285,6 @@ int mmc_suspend_host(struct mmc_host *host)
 	if (host->bus_ops && !host->bus_dead) {
 		if (host->bus_ops->suspend)
 			err = host->bus_ops->suspend(host);
-		if (err == -ENOSYS || !host->bus_ops->resume) {
-			/*
-			 * We simply "remove" the card in this case.
-			 * It will be redetected on resume.
-			 */
-			if (host->bus_ops->remove)
-				host->bus_ops->remove(host);
-			mmc_claim_host(host);
-			mmc_detach_bus(host);
-			mmc_release_host(host);
-			host->pm_flags = 0;
-			err = 0;
-		}
 	}
 	mmc_bus_put(host);
 
@@ -1318,28 +1316,61 @@ int mmc_resume_host(struct mmc_host *host)
 			printk(KERN_WARNING "%s: error %d during resume "
 					    "(card was removed?)\n",
 					    mmc_hostname(host), err);
-			if (host->bus_ops->remove)
-				host->bus_ops->remove(host);
-			mmc_claim_host(host);
-			mmc_detach_bus(host);
-			mmc_release_host(host);
-			/* no need to bother upper layers */
 			err = 0;
 		}
 	}
 	mmc_bus_put(host);
 
-	/*
-	 * We add a slight delay here so that resume can progress
-	 * in parallel.
-	 */
-	mmc_detect_change(host, 1);
-
 	return err;
 }
-
 EXPORT_SYMBOL(mmc_resume_host);
 
+/* Do the card removal on suspend if card is assumed removeable
+ * Do that in pm notifier while userspace isn't yet frozen, so we will be able
+   to sync the card.
+*/
+int mmc_pm_notify(struct notifier_block *notify_block,
+					unsigned long mode, void *unused)
+{
+	struct mmc_host *host = container_of(
+		notify_block, struct mmc_host, pm_notify);
+	unsigned long flags;
+
+
+	switch (mode) {
+	case PM_HIBERNATION_PREPARE:
+	case PM_SUSPEND_PREPARE:
+
+		spin_lock_irqsave(&host->lock, flags);
+		host->rescan_disable = 1;
+		spin_unlock_irqrestore(&host->lock, flags);
+		cancel_delayed_work_sync(&host->detect);
+
+		if (!host->bus_ops || host->bus_ops->suspend)
+			break;
+
+		mmc_claim_host(host);
+
+		if (host->bus_ops->remove)
+			host->bus_ops->remove(host);
+
+		mmc_detach_bus(host);
+		mmc_release_host(host);
+		host->pm_flags = 0;
+		break;
+
+	case PM_POST_SUSPEND:
+	case PM_POST_HIBERNATION:
+
+		spin_lock_irqsave(&host->lock, flags);
+		host->rescan_disable = 0;
+		spin_unlock_irqrestore(&host->lock, flags);
+		mmc_detect_change(host, 0);
+
+	}
+
+	return 0;
+}
 #endif
 
 static int __init mmc_init(void)

commit 7310ece86ad7da027f85a37a0638164118a5d12f
Author: Michal Miroslaw <mirq-linux@rere.qmqm.pl>
Date:   Tue Aug 10 18:01:40 2010 -0700

    mmc: implement SD-combo (IO+mem) support
    
    Signed-off-by: Michal Miroslaw <mirq-linux@rere.qmqm.pl>
    Cc: Adrian Hunter <adrian.hunter@nokia.com>
    Cc: Chris Ball <cjb@laptop.org>
    Cc: <linux-mmc@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 569e94da844c..b69ce91b11e1 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1099,8 +1099,15 @@ void mmc_rescan(struct work_struct *work)
 	 */
 	err = mmc_send_io_op_cond(host, 0, &ocr);
 	if (!err) {
-		if (mmc_attach_sdio(host, ocr))
-			mmc_power_off(host);
+		if (mmc_attach_sdio(host, ocr)) {
+			mmc_claim_host(host);
+			/* try SDMEM (but not MMC) even if SDIO is broken */
+			if (mmc_send_app_op_cond(host, 0, &ocr))
+				goto out_fail;
+
+			if (mmc_attach_sd(host, ocr))
+				mmc_power_off(host);
+		}
 		goto out;
 	}
 
@@ -1124,6 +1131,7 @@ void mmc_rescan(struct work_struct *work)
 		goto out;
 	}
 
+out_fail:
 	mmc_release_host(host);
 	mmc_power_off(host);
 

commit 1a13f8fa76c880be41d6b1e6a2b44404bcbfdf9e
Author: Matt Fleming <matt@console-pimps.org>
Date:   Wed May 26 14:42:08 2010 -0700

    mmc: remove the "state" argument to mmc_suspend_host()
    
    Even though many mmc host drivers pass a pm_message_t argument to
    mmc_suspend_host() that argument isn't used the by MMC core.  As host
    drivers are converted to dev_pm_ops they'll have to construct
    pm_message_t's (as they won't be passed by the PM subsystem any more) just
    to appease the mmc suspend interface.
    
    We might as well just delete the unused paramter.
    
    Signed-off-by: Matt Fleming <matt@console-pimps.org>
    Acked-by: Anton Vorontsov <cbouatmailru@gmail.com>
    Acked-by: Michal Miroslaw <mirq-linux@rere.qmqm.pl>ZZ
    Acked-by: Sascha Sommer <saschasommer@freenet.de>
    Cc: <linux-mmc@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 3168ebd616b2..569e94da844c 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1252,9 +1252,8 @@ EXPORT_SYMBOL(mmc_card_can_sleep);
 /**
  *	mmc_suspend_host - suspend a host
  *	@host: mmc host
- *	@state: suspend mode (PM_SUSPEND_xxx)
  */
-int mmc_suspend_host(struct mmc_host *host, pm_message_t state)
+int mmc_suspend_host(struct mmc_host *host)
 {
 	int err = 0;
 

commit 516a82422209e078345d0ca54b16793d7bfd4782
Author: Albert Herranz <albert_herranz@yahoo.es>
Date:   Wed Mar 10 15:20:37 2010 -0800

    sdio: recognize io card without powercycle
    
    SDIO Simplified Specification V2.00 states that it is strongly recommended
    that the host executes either a power reset or issues a CMD52 (I/O Reset)
    to re-initialize an I/O only card or the I/O portion of a combo card.
    Additionally, the CMD52 must be issued first because it cannot be issued
    after a CMD0.
    
    With this patch the Nintendo Wii SDIO-based WLAN card is detected after a
    system reset, without requiring a complete system powercycle.
    
    Signed-off-by: Albert Herranz <albert_herranz@yahoo.es>
    Cc: <linux-mmc@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index f4b97d3c3d0f..3168ebd616b2 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1089,6 +1089,7 @@ void mmc_rescan(struct work_struct *work)
 	mmc_claim_host(host);
 
 	mmc_power_up(host);
+	sdio_reset(host);
 	mmc_go_idle(host);
 
 	mmc_send_if_cond(host, host->ocr_avail);

commit da68c4eb258cd9f3f0b8aeb7e46b8118bb6358b6
Author: Nicolas Pitre <nico@fluxnic.net>
Date:   Fri Mar 5 13:43:31 2010 -0800

    sdio: introduce API for special power management features
    
    This patch series provides the core changes needed to allow SDIO cards to
    remain powered and active while the host system is suspended, and let them
    wake up the host system when needed.  This is used to implement
    wake-on-lan with SDIO wireless cards at the moment.  Patches to add that
    support to the libertas driver will be posted separately.
    
    This patch:
    
    Some SDIO cards have the ability to keep on running autonomously when the
    host system is suspended, and wake it up when needed.  This however
    requires that the host controller preserve power to the card, and
    configure itself appropriately for wake-up.
    
    There is however 4 layers of abstractions involved: the host controller
    driver, the MMC core code, the SDIO card management code, and the actual
    SDIO function driver.  To make things simple and manageable, host drivers
    must advertise their PM capabilities with a feature bitmask, then function
    drivers can query and set those features from their suspend method.  Then
    each layer in the suspend call chain is expected to act upon those bits
    accordingly.
    
    [akpm@linux-foundation.org: fix typo in comment]
    Signed-off-by: Nicolas Pitre <nico@marvell.com>
    Cc: <linux-mmc@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 30acd5265821..f4b97d3c3d0f 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1151,6 +1151,9 @@ void mmc_stop_host(struct mmc_host *host)
 	cancel_delayed_work(&host->detect);
 	mmc_flush_scheduled_work();
 
+	/* clear pm flags now and let card drivers set them as needed */
+	host->pm_flags = 0;
+
 	mmc_bus_get(host);
 	if (host->bus_ops && !host->bus_dead) {
 		if (host->bus_ops->remove)
@@ -1273,12 +1276,13 @@ int mmc_suspend_host(struct mmc_host *host, pm_message_t state)
 			mmc_claim_host(host);
 			mmc_detach_bus(host);
 			mmc_release_host(host);
+			host->pm_flags = 0;
 			err = 0;
 		}
 	}
 	mmc_bus_put(host);
 
-	if (!err)
+	if (!err && !(host->pm_flags & MMC_PM_KEEP_POWER))
 		mmc_power_off(host);
 
 	return err;
@@ -1296,8 +1300,10 @@ int mmc_resume_host(struct mmc_host *host)
 
 	mmc_bus_get(host);
 	if (host->bus_ops && !host->bus_dead) {
-		mmc_power_up(host);
-		mmc_select_voltage(host, host->ocr);
+		if (!(host->pm_flags & MMC_PM_KEEP_POWER)) {
+			mmc_power_up(host);
+			mmc_select_voltage(host, host->ocr);
+		}
 		BUG_ON(!host->bus_ops->resume);
 		err = host->bus_ops->resume(host);
 		if (err) {

commit bd68e0838fe85794b06892054772fa013a8d1986
Author: Ben Hutchings <ben@decadent.org.uk>
Date:   Mon Dec 14 18:01:29 2009 -0800

    mmc: add module parameter to set whether cards are assumed removable
    
    Some people run general-purpose distribution kernels on netbooks with
    a card that is physically non-removable or logically non-removable
    (e.g. used for /home) and cannot be cleanly unmounted during suspend.
    Add a module parameter to set whether cards are assumed removable or
    non-removable, with the default set by CONFIG_MMC_UNSAFE_RESUME.
    
    In general, it is not possible to tell whether a card present in an MMC
    slot after resume is the same that was there before suspend.  So there are
    two possible behaviours, each of which will cause data loss in some cases:
    
    CONFIG_MMC_UNSAFE_RESUME=n (default): Cards are assumed to be removed
    during suspend.  Any filesystem on them must be unmounted before suspend;
    otherwise, buffered writes will be lost.
    
    CONFIG_MMC_UNSAFE_RESUME=y: Cards are assumed to remain present during
    suspend.  They must not be swapped during suspend; otherwise, buffered
    writes will be flushed to the wrong card.
    
    Currently the choice is made at compile time and this allows that to be
    overridden at module load time.
    
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>
    Cc: Wouter van Heyst <larstiq@larstiq.dyndns.org>
    Cc: <linux-mmc@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 7dab2e5f4bc9..30acd5265821 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -47,6 +47,22 @@ static struct workqueue_struct *workqueue;
 int use_spi_crc = 1;
 module_param(use_spi_crc, bool, 0);
 
+/*
+ * We normally treat cards as removed during suspend if they are not
+ * known to be on a non-removable bus, to avoid the risk of writing
+ * back data to a different card after resume.  Allow this to be
+ * overridden if necessary.
+ */
+#ifdef CONFIG_MMC_UNSAFE_RESUME
+int mmc_assume_removable;
+#else
+int mmc_assume_removable = 1;
+#endif
+module_param_named(removable, mmc_assume_removable, bool, 0644);
+MODULE_PARM_DESC(
+	removable,
+	"MMC/SD cards are removable and may be removed during suspend");
+
 /*
  * Internal function. Schedule delayed work in the MMC work queue.
  */

commit 95cdfb72b9bc568803f395c266152c71b034b461
Author: Nicolas Pitre <nico@fluxnic.net>
Date:   Tue Sep 22 16:45:29 2009 -0700

    mmc: propagate error codes back from bus drivers' suspend/resume methods
    
    Especially for SDIO drivers which may have special conditions/errors to
    report, it is a good thing to relay the returned error code back to upper
    layers.
    
    This also allows for the rationalization of the resume path where code to
    "remove" a no-longer-existing or replaced card was duplicated into the
    MMC, SD and SDIO bus drivers.
    
    In the SDIO case, if a function suspend method returns an error, then all
    previously suspended functions are resumed and the error returned.  An
    exception is made for -ENOSYS which the core interprets as "we don't
    support suspend so just kick the card out for suspend and return success".
    
    When resuming SDIO cards, the core code only validates the manufacturer
    and product IDs to make sure the same kind of card is still present before
    invoking functions resume methods.  It's the function driver's
    responsibility to perform further tests to confirm that the actual same
    card is present (same MAC address, etc.) and return an error otherwise.
    
    Signed-off-by: Nicolas Pitre <nico@marvell.com>
    Cc: <linux-mmc@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 0842f6829250..7dab2e5f4bc9 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1236,6 +1236,8 @@ EXPORT_SYMBOL(mmc_card_can_sleep);
  */
 int mmc_suspend_host(struct mmc_host *host, pm_message_t state)
 {
+	int err = 0;
+
 	if (host->caps & MMC_CAP_DISABLE)
 		cancel_delayed_work(&host->disable);
 	cancel_delayed_work(&host->detect);
@@ -1244,21 +1246,26 @@ int mmc_suspend_host(struct mmc_host *host, pm_message_t state)
 	mmc_bus_get(host);
 	if (host->bus_ops && !host->bus_dead) {
 		if (host->bus_ops->suspend)
-			host->bus_ops->suspend(host);
-		if (!host->bus_ops->resume) {
+			err = host->bus_ops->suspend(host);
+		if (err == -ENOSYS || !host->bus_ops->resume) {
+			/*
+			 * We simply "remove" the card in this case.
+			 * It will be redetected on resume.
+			 */
 			if (host->bus_ops->remove)
 				host->bus_ops->remove(host);
-
 			mmc_claim_host(host);
 			mmc_detach_bus(host);
 			mmc_release_host(host);
+			err = 0;
 		}
 	}
 	mmc_bus_put(host);
 
-	mmc_power_off(host);
+	if (!err)
+		mmc_power_off(host);
 
-	return 0;
+	return err;
 }
 
 EXPORT_SYMBOL(mmc_suspend_host);
@@ -1269,12 +1276,26 @@ EXPORT_SYMBOL(mmc_suspend_host);
  */
 int mmc_resume_host(struct mmc_host *host)
 {
+	int err = 0;
+
 	mmc_bus_get(host);
 	if (host->bus_ops && !host->bus_dead) {
 		mmc_power_up(host);
 		mmc_select_voltage(host, host->ocr);
 		BUG_ON(!host->bus_ops->resume);
-		host->bus_ops->resume(host);
+		err = host->bus_ops->resume(host);
+		if (err) {
+			printk(KERN_WARNING "%s: error %d during resume "
+					    "(card was removed?)\n",
+					    mmc_hostname(host), err);
+			if (host->bus_ops->remove)
+				host->bus_ops->remove(host);
+			mmc_claim_host(host);
+			mmc_detach_bus(host);
+			mmc_release_host(host);
+			/* no need to bother upper layers */
+			err = 0;
+		}
 	}
 	mmc_bus_put(host);
 
@@ -1284,7 +1305,7 @@ int mmc_resume_host(struct mmc_host *host)
 	 */
 	mmc_detect_change(host, 1);
 
-	return 0;
+	return err;
 }
 
 EXPORT_SYMBOL(mmc_resume_host);

commit 53509f0fe28e049e772897aa8fa1f5183b6823a2
Author: Denis Karpov <ext-denis.2.karpov@nokia.com>
Date:   Tue Sep 22 16:44:36 2009 -0700

    mmc: power off once at removal
    
    Fix MMC host stop sequence: power off once.
    
    Signed-off-by: Denis Karpov <ext-denis.2.karpov@nokia.com>
    Signed-off-by: Adrian Hunter <adrian.hunter@nokia.com>
    Acked-by: Matt Fleming <matt@console-pimps.org>
    Cc: Ian Molton <ian@mnementh.co.uk>
    Cc: "Roberto A. Foglietta" <roberto.foglietta@gmail.com>
    Cc: Jarkko Lavinen <jarkko.lavinen@nokia.com>
    Cc: Denis Karpov <ext-denis.2.karpov@nokia.com>
    Cc: Pierre Ossman <pierre@ossman.eu>
    Cc: Philip Langdale <philipl@overt.org>
    Cc: "Madhusudhan" <madhu.cr@ti.com>
    Cc: <linux-mmc@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 828e60ea528c..0842f6829250 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1143,6 +1143,8 @@ void mmc_stop_host(struct mmc_host *host)
 		mmc_claim_host(host);
 		mmc_detach_bus(host);
 		mmc_release_host(host);
+		mmc_bus_put(host);
+		return;
 	}
 	mmc_bus_put(host);
 

commit b1ebe38456f7fe61a88af2844361e763ac6ea5ae
Author: Jarkko Lavinen <jarkko.lavinen@nokia.com>
Date:   Tue Sep 22 16:44:34 2009 -0700

    mmc: add mmc card sleep and awake support
    
    Add support for the new MMC command SLEEP_AWAKE.
    
    Signed-off-by: Jarkko Lavinen <jarkko.lavinen@nokia.com>
    Signed-off-by: Adrian Hunter <adrian.hunter@nokia.com>
    Acked-by: Matt Fleming <matt@console-pimps.org>
    Cc: Ian Molton <ian@mnementh.co.uk>
    Cc: "Roberto A. Foglietta" <roberto.foglietta@gmail.com>
    Cc: Jarkko Lavinen <jarkko.lavinen@nokia.com>
    Cc: Denis Karpov <ext-denis.2.karpov@nokia.com>
    Cc: Pierre Ossman <pierre@ossman.eu>
    Cc: Philip Langdale <philipl@overt.org>
    Cc: "Madhusudhan" <madhu.cr@ti.com>
    Cc: <linux-mmc@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index be1fc013fbe9..828e60ea528c 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1185,6 +1185,46 @@ void mmc_power_restore_host(struct mmc_host *host)
 }
 EXPORT_SYMBOL(mmc_power_restore_host);
 
+int mmc_card_awake(struct mmc_host *host)
+{
+	int err = -ENOSYS;
+
+	mmc_bus_get(host);
+
+	if (host->bus_ops && !host->bus_dead && host->bus_ops->awake)
+		err = host->bus_ops->awake(host);
+
+	mmc_bus_put(host);
+
+	return err;
+}
+EXPORT_SYMBOL(mmc_card_awake);
+
+int mmc_card_sleep(struct mmc_host *host)
+{
+	int err = -ENOSYS;
+
+	mmc_bus_get(host);
+
+	if (host->bus_ops && !host->bus_dead && host->bus_ops->awake)
+		err = host->bus_ops->sleep(host);
+
+	mmc_bus_put(host);
+
+	return err;
+}
+EXPORT_SYMBOL(mmc_card_sleep);
+
+int mmc_card_can_sleep(struct mmc_host *host)
+{
+	struct mmc_card *card = host->card;
+
+	if (card && mmc_card_mmc(card) && card->ext_csd.rev >= 3)
+		return 1;
+	return 0;
+}
+EXPORT_SYMBOL(mmc_card_can_sleep);
+
 #ifdef CONFIG_PM
 
 /**

commit eae1aeeed852aae37621b82a9e7f6c05096a18fd
Author: Adrian Hunter <adrian.hunter@nokia.com>
Date:   Tue Sep 22 16:44:33 2009 -0700

    mmc: add ability to save power by powering off cards
    
    Power can be saved by powering off cards that are not in use.  This is
    similar to suspend / resume except it is under the control of the driver,
    and does not require any power management support.  It can only be used
    when the driver can monitor whether the card is removed, otherwise it is
    unsafe.  This is possible because, unlike suspend, the driver still
    receives card detect and / or cover switch interrupts.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@nokia.com>
    Acked-by: Matt Fleming <matt@console-pimps.org>
    Cc: Ian Molton <ian@mnementh.co.uk>
    Cc: "Roberto A. Foglietta" <roberto.foglietta@gmail.com>
    Cc: Jarkko Lavinen <jarkko.lavinen@nokia.com>
    Cc: Denis Karpov <ext-denis.2.karpov@nokia.com>
    Cc: Pierre Ossman <pierre@ossman.eu>
    Cc: Philip Langdale <philipl@overt.org>
    Cc: "Madhusudhan" <madhu.cr@ti.com>
    Cc: <linux-mmc@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 02f2b1871a38..be1fc013fbe9 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1151,6 +1151,40 @@ void mmc_stop_host(struct mmc_host *host)
 	mmc_power_off(host);
 }
 
+void mmc_power_save_host(struct mmc_host *host)
+{
+	mmc_bus_get(host);
+
+	if (!host->bus_ops || host->bus_dead || !host->bus_ops->power_restore) {
+		mmc_bus_put(host);
+		return;
+	}
+
+	if (host->bus_ops->power_save)
+		host->bus_ops->power_save(host);
+
+	mmc_bus_put(host);
+
+	mmc_power_off(host);
+}
+EXPORT_SYMBOL(mmc_power_save_host);
+
+void mmc_power_restore_host(struct mmc_host *host)
+{
+	mmc_bus_get(host);
+
+	if (!host->bus_ops || host->bus_dead || !host->bus_ops->power_restore) {
+		mmc_bus_put(host);
+		return;
+	}
+
+	mmc_power_up(host);
+	host->bus_ops->power_restore(host);
+
+	mmc_bus_put(host);
+}
+EXPORT_SYMBOL(mmc_power_restore_host);
+
 #ifdef CONFIG_PM
 
 /**

commit 319a3f1429c91147058ac26c5f5bac8ec1730bc6
Author: Adrian Hunter <adrian.hunter@nokia.com>
Date:   Tue Sep 22 16:44:30 2009 -0700

    mmc: allow host claim / release nesting
    
    This change allows the MMC host to be claimed in situations where the host
    may or may not have already been claimed.  Also 'mmc_try_claim_host()' is
    now exported.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@nokia.com>
    Acked-by: Matt Fleming <matt@console-pimps.org>
    Cc: Ian Molton <ian@mnementh.co.uk>
    Cc: "Roberto A. Foglietta" <roberto.foglietta@gmail.com>
    Cc: Jarkko Lavinen <jarkko.lavinen@nokia.com>
    Cc: Denis Karpov <ext-denis.2.karpov@nokia.com>
    Cc: Pierre Ossman <pierre@ossman.eu>
    Cc: Philip Langdale <philipl@overt.org>
    Cc: "Madhusudhan" <madhu.cr@ti.com>
    Cc: <linux-mmc@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index fb24a096dba8..02f2b1871a38 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -461,16 +461,18 @@ int __mmc_claim_host(struct mmc_host *host, atomic_t *abort)
 	while (1) {
 		set_current_state(TASK_UNINTERRUPTIBLE);
 		stop = abort ? atomic_read(abort) : 0;
-		if (stop || !host->claimed)
+		if (stop || !host->claimed || host->claimer == current)
 			break;
 		spin_unlock_irqrestore(&host->lock, flags);
 		schedule();
 		spin_lock_irqsave(&host->lock, flags);
 	}
 	set_current_state(TASK_RUNNING);
-	if (!stop)
+	if (!stop) {
 		host->claimed = 1;
-	else
+		host->claimer = current;
+		host->claim_cnt += 1;
+	} else
 		wake_up(&host->wq);
 	spin_unlock_irqrestore(&host->lock, flags);
 	remove_wait_queue(&host->wq, &wait);
@@ -481,29 +483,43 @@ int __mmc_claim_host(struct mmc_host *host, atomic_t *abort)
 
 EXPORT_SYMBOL(__mmc_claim_host);
 
-static int mmc_try_claim_host(struct mmc_host *host)
+/**
+ *	mmc_try_claim_host - try exclusively to claim a host
+ *	@host: mmc host to claim
+ *
+ *	Returns %1 if the host is claimed, %0 otherwise.
+ */
+int mmc_try_claim_host(struct mmc_host *host)
 {
 	int claimed_host = 0;
 	unsigned long flags;
 
 	spin_lock_irqsave(&host->lock, flags);
-	if (!host->claimed) {
+	if (!host->claimed || host->claimer == current) {
 		host->claimed = 1;
+		host->claimer = current;
+		host->claim_cnt += 1;
 		claimed_host = 1;
 	}
 	spin_unlock_irqrestore(&host->lock, flags);
 	return claimed_host;
 }
+EXPORT_SYMBOL(mmc_try_claim_host);
 
 static void mmc_do_release_host(struct mmc_host *host)
 {
 	unsigned long flags;
 
 	spin_lock_irqsave(&host->lock, flags);
-	host->claimed = 0;
-	spin_unlock_irqrestore(&host->lock, flags);
-
-	wake_up(&host->wq);
+	if (--host->claim_cnt) {
+		/* Release for nested claim */
+		spin_unlock_irqrestore(&host->lock, flags);
+	} else {
+		host->claimed = 0;
+		host->claimer = NULL;
+		spin_unlock_irqrestore(&host->lock, flags);
+		wake_up(&host->wq);
+	}
 }
 
 void mmc_host_deeper_disable(struct work_struct *work)

commit 8ea926b22e2d13238e4d65d8f61c48fe424e6f4f
Author: Adrian Hunter <adrian.hunter@nokia.com>
Date:   Tue Sep 22 16:44:29 2009 -0700

    mmc: add 'enable' and 'disable' methods to mmc host
    
    MMC hosts that support power saving can use the 'enable' and 'disable'
    methods to exit and enter power saving states.  An explanation of their
    use is provided in the comments added to include/linux/mmc/host.h.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@nokia.com>
    Acked-by: Matt Fleming <matt@console-pimps.org>
    Cc: Ian Molton <ian@mnementh.co.uk>
    Cc: "Roberto A. Foglietta" <roberto.foglietta@gmail.com>
    Cc: Jarkko Lavinen <jarkko.lavinen@nokia.com>
    Cc: Denis Karpov <ext-denis.2.karpov@nokia.com>
    Cc: Pierre Ossman <pierre@ossman.eu>
    Cc: Philip Langdale <philipl@overt.org>
    Cc: "Madhusudhan" <madhu.cr@ti.com>
    Cc: <linux-mmc@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index e22d2b5576ec..fb24a096dba8 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -343,6 +343,101 @@ unsigned int mmc_align_data_size(struct mmc_card *card, unsigned int sz)
 }
 EXPORT_SYMBOL(mmc_align_data_size);
 
+/**
+ *	mmc_host_enable - enable a host.
+ *	@host: mmc host to enable
+ *
+ *	Hosts that support power saving can use the 'enable' and 'disable'
+ *	methods to exit and enter power saving states. For more information
+ *	see comments for struct mmc_host_ops.
+ */
+int mmc_host_enable(struct mmc_host *host)
+{
+	if (!(host->caps & MMC_CAP_DISABLE))
+		return 0;
+
+	if (host->en_dis_recurs)
+		return 0;
+
+	if (host->nesting_cnt++)
+		return 0;
+
+	cancel_delayed_work_sync(&host->disable);
+
+	if (host->enabled)
+		return 0;
+
+	if (host->ops->enable) {
+		int err;
+
+		host->en_dis_recurs = 1;
+		err = host->ops->enable(host);
+		host->en_dis_recurs = 0;
+
+		if (err) {
+			pr_debug("%s: enable error %d\n",
+				 mmc_hostname(host), err);
+			return err;
+		}
+	}
+	host->enabled = 1;
+	return 0;
+}
+EXPORT_SYMBOL(mmc_host_enable);
+
+static int mmc_host_do_disable(struct mmc_host *host, int lazy)
+{
+	if (host->ops->disable) {
+		int err;
+
+		host->en_dis_recurs = 1;
+		err = host->ops->disable(host, lazy);
+		host->en_dis_recurs = 0;
+
+		if (err < 0) {
+			pr_debug("%s: disable error %d\n",
+				 mmc_hostname(host), err);
+			return err;
+		}
+		if (err > 0) {
+			unsigned long delay = msecs_to_jiffies(err);
+
+			mmc_schedule_delayed_work(&host->disable, delay);
+		}
+	}
+	host->enabled = 0;
+	return 0;
+}
+
+/**
+ *	mmc_host_disable - disable a host.
+ *	@host: mmc host to disable
+ *
+ *	Hosts that support power saving can use the 'enable' and 'disable'
+ *	methods to exit and enter power saving states. For more information
+ *	see comments for struct mmc_host_ops.
+ */
+int mmc_host_disable(struct mmc_host *host)
+{
+	int err;
+
+	if (!(host->caps & MMC_CAP_DISABLE))
+		return 0;
+
+	if (host->en_dis_recurs)
+		return 0;
+
+	if (--host->nesting_cnt)
+		return 0;
+
+	if (!host->enabled)
+		return 0;
+
+	err = mmc_host_do_disable(host, 0);
+	return err;
+}
+EXPORT_SYMBOL(mmc_host_disable);
+
 /**
  *	__mmc_claim_host - exclusively claim a host
  *	@host: mmc host to claim
@@ -379,11 +474,81 @@ int __mmc_claim_host(struct mmc_host *host, atomic_t *abort)
 		wake_up(&host->wq);
 	spin_unlock_irqrestore(&host->lock, flags);
 	remove_wait_queue(&host->wq, &wait);
+	if (!stop)
+		mmc_host_enable(host);
 	return stop;
 }
 
 EXPORT_SYMBOL(__mmc_claim_host);
 
+static int mmc_try_claim_host(struct mmc_host *host)
+{
+	int claimed_host = 0;
+	unsigned long flags;
+
+	spin_lock_irqsave(&host->lock, flags);
+	if (!host->claimed) {
+		host->claimed = 1;
+		claimed_host = 1;
+	}
+	spin_unlock_irqrestore(&host->lock, flags);
+	return claimed_host;
+}
+
+static void mmc_do_release_host(struct mmc_host *host)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&host->lock, flags);
+	host->claimed = 0;
+	spin_unlock_irqrestore(&host->lock, flags);
+
+	wake_up(&host->wq);
+}
+
+void mmc_host_deeper_disable(struct work_struct *work)
+{
+	struct mmc_host *host =
+		container_of(work, struct mmc_host, disable.work);
+
+	/* If the host is claimed then we do not want to disable it anymore */
+	if (!mmc_try_claim_host(host))
+		return;
+	mmc_host_do_disable(host, 1);
+	mmc_do_release_host(host);
+}
+
+/**
+ *	mmc_host_lazy_disable - lazily disable a host.
+ *	@host: mmc host to disable
+ *
+ *	Hosts that support power saving can use the 'enable' and 'disable'
+ *	methods to exit and enter power saving states. For more information
+ *	see comments for struct mmc_host_ops.
+ */
+int mmc_host_lazy_disable(struct mmc_host *host)
+{
+	if (!(host->caps & MMC_CAP_DISABLE))
+		return 0;
+
+	if (host->en_dis_recurs)
+		return 0;
+
+	if (--host->nesting_cnt)
+		return 0;
+
+	if (!host->enabled)
+		return 0;
+
+	if (host->disable_delay) {
+		mmc_schedule_delayed_work(&host->disable,
+				msecs_to_jiffies(host->disable_delay));
+		return 0;
+	} else
+		return mmc_host_do_disable(host, 1);
+}
+EXPORT_SYMBOL(mmc_host_lazy_disable);
+
 /**
  *	mmc_release_host - release a host
  *	@host: mmc host to release
@@ -393,15 +558,11 @@ EXPORT_SYMBOL(__mmc_claim_host);
  */
 void mmc_release_host(struct mmc_host *host)
 {
-	unsigned long flags;
-
 	WARN_ON(!host->claimed);
 
-	spin_lock_irqsave(&host->lock, flags);
-	host->claimed = 0;
-	spin_unlock_irqrestore(&host->lock, flags);
+	mmc_host_lazy_disable(host);
 
-	wake_up(&host->wq);
+	mmc_do_release_host(host);
 }
 
 EXPORT_SYMBOL(mmc_release_host);
@@ -953,6 +1114,8 @@ void mmc_stop_host(struct mmc_host *host)
 	spin_unlock_irqrestore(&host->lock, flags);
 #endif
 
+	if (host->caps & MMC_CAP_DISABLE)
+		cancel_delayed_work(&host->disable);
 	cancel_delayed_work(&host->detect);
 	mmc_flush_scheduled_work();
 
@@ -981,6 +1144,8 @@ void mmc_stop_host(struct mmc_host *host)
  */
 int mmc_suspend_host(struct mmc_host *host, pm_message_t state)
 {
+	if (host->caps & MMC_CAP_DISABLE)
+		cancel_delayed_work(&host->disable);
 	cancel_delayed_work(&host->detect);
 	mmc_flush_scheduled_work();
 

commit 500f35648e5ebd04be00f974738a9db959a892b8
Author: Balaji Rao <balajirrao@openmoko.org>
Date:   Tue Sep 22 16:44:18 2009 -0700

    mmc: in mmc_power_up(), use previously selected ocr if available
    
    When mmc_power_up is called during unsafe resume, host->ocr should be used
    instead of host->ocr_avail.
    
    Signed-off-by: Balaji Rao <balajirrao@openmoko.org>
    Cc: Andy Green <andy@openmoko.com>
    Cc: Pierre Ossman <drzeus-mmc@drzeus.cx>
    Cc: Ian Molton <ian@mnementh.co.uk>
    Cc: "Roberto A. Foglietta" <roberto.foglietta@gmail.com>
    Cc: Philip Langdale <philipl@overt.org>
    Acked-by: Matt Fleming <matt@console-pimps.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index d84c880fac84..e22d2b5576ec 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -687,7 +687,13 @@ void mmc_set_timing(struct mmc_host *host, unsigned int timing)
  */
 static void mmc_power_up(struct mmc_host *host)
 {
-	int bit = fls(host->ocr_avail) - 1;
+	int bit;
+
+	/* If ocr is set, we use it */
+	if (host->ocr)
+		bit = ffs(host->ocr) - 1;
+	else
+		bit = fls(host->ocr_avail) - 1;
 
 	host->ios.vdd = bit;
 	if (mmc_host_is_spi(host)) {

commit 8dfd0374be84793360db7fff2e635d2cd3bbcb21
Author: Sascha Hauer <s.hauer@pengutronix.de>
Date:   Thu Apr 9 08:32:02 2009 +0200

    MMC core: limit minimum initialization frequency to 400kHz
    
    Some controllers allow a much lower frequency than 400kHz.
    Keep the minimum frequency within sensible limits.
    
    Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 23fb2c39d9ed..d84c880fac84 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -708,7 +708,13 @@ static void mmc_power_up(struct mmc_host *host)
 	 */
 	mmc_delay(10);
 
-	host->ios.clock = host->f_min;
+	if (host->f_min > 400000) {
+		pr_warning("%s: Minimum clock frequency too high for "
+				"identification mode\n", mmc_hostname(host));
+		host->ios.clock = host->f_min;
+	} else
+		host->ios.clock = 400000;
+
 	host->ios.power_mode = MMC_POWER_ON;
 	mmc_set_ios(host);
 

commit 94d89efb2c347a82a08a61dbac8565b1087c3259
Author: Jorg Schummer <ext-jorg.2.schummer@nokia.com>
Date:   Tue Mar 31 17:51:21 2009 +0300

    mmc: mmc_rescan detects card change in one run
    
    With this patch, mmc_rescan can detect the removal of an mmc card and
    the insertion of (possibly another) card in the same run. This means
    that a card change can be detected without having to call
    mmc_detect_change multiple times.
    
    This change generalises the core such that it can be easily used by
    hosts which provide a mechanism to detect only the presence of a card
    reader cover, which has to be taken off in order to insert a card. Other
    hosts ("card detect" or "MMC_CAP_NEEDS_POLL") each receive an event when
    a card is removed and when a card is inserted, so it is sufficient for
    them if mmc_rescan handles only one event at a time. "Cover detect"
    hosts, however, only receive events about the cover status. This means
    that between 2 subsequent events, both a card removal and a card
    insertion can occur. In this case, the pre-patch version of mmc_rescan
    would only detect the removal of the previous card but not the insertion
    of the new card.
    
    Signed-off-by: Jorg Schummer <ext-jorg.2.schummer@nokia.com>
    Signed-off-by: Pierre Ossman <pierre@ossman.eu>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 264911732756..23fb2c39d9ed 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -855,61 +855,72 @@ void mmc_rescan(struct work_struct *work)
 
 	mmc_bus_get(host);
 
-	if (host->bus_ops == NULL) {
-		/*
-		 * Only we can add a new handler, so it's safe to
-		 * release the lock here.
-		 */
+	/* if there is a card registered, check whether it is still present */
+	if ((host->bus_ops != NULL) && host->bus_ops->detect && !host->bus_dead)
+		host->bus_ops->detect(host);
+
+	mmc_bus_put(host);
+
+
+	mmc_bus_get(host);
+
+	/* if there still is a card present, stop here */
+	if (host->bus_ops != NULL) {
 		mmc_bus_put(host);
+		goto out;
+	}
 
-		if (host->ops->get_cd && host->ops->get_cd(host) == 0)
-			goto out;
+	/* detect a newly inserted card */
 
-		mmc_claim_host(host);
+	/*
+	 * Only we can add a new handler, so it's safe to
+	 * release the lock here.
+	 */
+	mmc_bus_put(host);
 
-		mmc_power_up(host);
-		mmc_go_idle(host);
+	if (host->ops->get_cd && host->ops->get_cd(host) == 0)
+		goto out;
 
-		mmc_send_if_cond(host, host->ocr_avail);
+	mmc_claim_host(host);
 
-		/*
-		 * First we search for SDIO...
-		 */
-		err = mmc_send_io_op_cond(host, 0, &ocr);
-		if (!err) {
-			if (mmc_attach_sdio(host, ocr))
-				mmc_power_off(host);
-			goto out;
-		}
+	mmc_power_up(host);
+	mmc_go_idle(host);
 
-		/*
-		 * ...then normal SD...
-		 */
-		err = mmc_send_app_op_cond(host, 0, &ocr);
-		if (!err) {
-			if (mmc_attach_sd(host, ocr))
-				mmc_power_off(host);
-			goto out;
-		}
+	mmc_send_if_cond(host, host->ocr_avail);
 
-		/*
-		 * ...and finally MMC.
-		 */
-		err = mmc_send_op_cond(host, 0, &ocr);
-		if (!err) {
-			if (mmc_attach_mmc(host, ocr))
-				mmc_power_off(host);
-			goto out;
-		}
+	/*
+	 * First we search for SDIO...
+	 */
+	err = mmc_send_io_op_cond(host, 0, &ocr);
+	if (!err) {
+		if (mmc_attach_sdio(host, ocr))
+			mmc_power_off(host);
+		goto out;
+	}
 
-		mmc_release_host(host);
-		mmc_power_off(host);
-	} else {
-		if (host->bus_ops->detect && !host->bus_dead)
-			host->bus_ops->detect(host);
+	/*
+	 * ...then normal SD...
+	 */
+	err = mmc_send_app_op_cond(host, 0, &ocr);
+	if (!err) {
+		if (mmc_attach_sd(host, ocr))
+			mmc_power_off(host);
+		goto out;
+	}
 
-		mmc_bus_put(host);
+	/*
+	 * ...and finally MMC.
+	 */
+	err = mmc_send_op_cond(host, 0, &ocr);
+	if (!err) {
+		if (mmc_attach_mmc(host, ocr))
+			mmc_power_off(host);
+		goto out;
 	}
+
+	mmc_release_host(host);
+	mmc_power_off(host);
+
 out:
 	if (host->caps & MMC_CAP_NEEDS_POLL)
 		mmc_schedule_delayed_work(&host->detect, HZ);

commit 79bccc5aefb4e64e651abe04f78c3e6bf8acd6f0
Author: José M. Fernández <josemariafg@gmail.com>
Date:   Tue Mar 10 02:21:21 2009 +0100

    mmc: increase power up delay
    
    The TI controller on Toshiba Tecra M5 needs more time to power up or
    the cards will init incorrectly or not at all.
    
    Signed-off-by: José M. Fernández <josemariafg@gmail.com>
    Signed-off-by: Pierre Ossman <pierre@ossman.eu>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index fa073ab3fa34..264911732756 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -706,7 +706,7 @@ static void mmc_power_up(struct mmc_host *host)
 	 * This delay should be sufficient to allow the power supply
 	 * to reach the minimum voltage.
 	 */
-	mmc_delay(2);
+	mmc_delay(10);
 
 	host->ios.clock = host->f_min;
 	host->ios.power_mode = MMC_POWER_ON;
@@ -716,7 +716,7 @@ static void mmc_power_up(struct mmc_host *host)
 	 * This delay must be at least 74 clock sizes, or 1 ms, or the
 	 * time required to reach a stable voltage.
 	 */
-	mmc_delay(2);
+	mmc_delay(10);
 }
 
 static void mmc_power_off(struct mmc_host *host)

commit 0a053e8c71d666daf30da2d407147b1293923d8b
Merge: 601cc11d054a 32ab83a56fdf
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Apr 5 10:18:21 2009 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/drzeus/mmc
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/drzeus/mmc: (42 commits)
      atmel-mci: fix sdc_reg typo
      tmio_mmc: add maintainer
      mmc: Add OpenFirmware bindings for SDHCI driver
      sdhci: Add quirk for forcing maximum block size to 2048 bytes
      sdhci: Add quirk for controllers that need IRQ re-init after reset
      sdhci: Add quirk for controllers that need small delays for PIO
      sdhci: Add set_clock callback and a quirk for nonstandard clocks
      sdhci: Add get_{max,timeout}_clock callbacks
      sdhci: Add support for hosts reporting inverted write-protect state
      sdhci: Add support for card-detection polling
      sdhci: Enable only relevant (DMA/PIO) interrupts during transfers
      sdhci: Split card-detection IRQs management from sdhci_init()
      sdhci: Add support for bus-specific IO memory accessors
      mmc_spi: adjust for delayed data token response
      omap_hsmmc: Wait for SDBP
      omap_hsmmc: Fix MMC3 dma
      omap_hsmmc: Disable SDBP at suspend
      omap_hsmmc: Do not prefix slot name
      omap_hsmmc: Allow cover switch to cause rescan
      omap_hsmmc: Add 8-bit bus width mode support
      ...

commit 5c13941acc513669c7d07b28789c3f9ba66ddddf
Author: David Brownell <dbrownell@users.sourceforge.net>
Date:   Wed Mar 11 03:30:43 2009 -0800

    MMC: regulator utilities
    
    Glue between MMC and regulator stacks ... verified with
    some OMAP3 boards using adjustable and configured-as-fixed
    regulators on several MMC controllers.
    
    These calls are intended to be used by MMC host adapters
    using at least one regulator per host.  Examples include
    slots with regulators supporting multiple voltages and
    ones using multiple voltage rails (e.g. DAT4..DAT7 using a
    separate supply, or a split rail chip like certain SDIO
    WLAN or eMMC solutions).
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Acked-by: Pierre Ossman <drzeus@drzeus.cx>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index df6ce4a06cf3..1445ea8f10a6 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -21,6 +21,7 @@
 #include <linux/leds.h>
 #include <linux/scatterlist.h>
 #include <linux/log2.h>
+#include <linux/regulator/consumer.h>
 
 #include <linux/mmc/card.h>
 #include <linux/mmc/host.h>
@@ -523,6 +524,105 @@ u32 mmc_vddrange_to_ocrmask(int vdd_min, int vdd_max)
 }
 EXPORT_SYMBOL(mmc_vddrange_to_ocrmask);
 
+#ifdef CONFIG_REGULATOR
+
+/**
+ * mmc_regulator_get_ocrmask - return mask of supported voltages
+ * @supply: regulator to use
+ *
+ * This returns either a negative errno, or a mask of voltages that
+ * can be provided to MMC/SD/SDIO devices using the specified voltage
+ * regulator.  This would normally be called before registering the
+ * MMC host adapter.
+ */
+int mmc_regulator_get_ocrmask(struct regulator *supply)
+{
+	int			result = 0;
+	int			count;
+	int			i;
+
+	count = regulator_count_voltages(supply);
+	if (count < 0)
+		return count;
+
+	for (i = 0; i < count; i++) {
+		int		vdd_uV;
+		int		vdd_mV;
+
+		vdd_uV = regulator_list_voltage(supply, i);
+		if (vdd_uV <= 0)
+			continue;
+
+		vdd_mV = vdd_uV / 1000;
+		result |= mmc_vddrange_to_ocrmask(vdd_mV, vdd_mV);
+	}
+
+	return result;
+}
+EXPORT_SYMBOL(mmc_regulator_get_ocrmask);
+
+/**
+ * mmc_regulator_set_ocr - set regulator to match host->ios voltage
+ * @vdd_bit: zero for power off, else a bit number (host->ios.vdd)
+ * @supply: regulator to use
+ *
+ * Returns zero on success, else negative errno.
+ *
+ * MMC host drivers may use this to enable or disable a regulator using
+ * a particular supply voltage.  This would normally be called from the
+ * set_ios() method.
+ */
+int mmc_regulator_set_ocr(struct regulator *supply, unsigned short vdd_bit)
+{
+	int			result = 0;
+	int			min_uV, max_uV;
+	int			enabled;
+
+	enabled = regulator_is_enabled(supply);
+	if (enabled < 0)
+		return enabled;
+
+	if (vdd_bit) {
+		int		tmp;
+		int		voltage;
+
+		/* REVISIT mmc_vddrange_to_ocrmask() may have set some
+		 * bits this regulator doesn't quite support ... don't
+		 * be too picky, most cards and regulators are OK with
+		 * a 0.1V range goof (it's a small error percentage).
+		 */
+		tmp = vdd_bit - ilog2(MMC_VDD_165_195);
+		if (tmp == 0) {
+			min_uV = 1650 * 1000;
+			max_uV = 1950 * 1000;
+		} else {
+			min_uV = 1900 * 1000 + tmp * 100 * 1000;
+			max_uV = min_uV + 100 * 1000;
+		}
+
+		/* avoid needless changes to this voltage; the regulator
+		 * might not allow this operation
+		 */
+		voltage = regulator_get_voltage(supply);
+		if (voltage < 0)
+			result = voltage;
+		else if (voltage < min_uV || voltage > max_uV)
+			result = regulator_set_voltage(supply, min_uV, max_uV);
+		else
+			result = 0;
+
+		if (result == 0 && !enabled)
+			result = regulator_enable(supply);
+	} else if (enabled) {
+		result = regulator_disable(supply);
+	}
+
+	return result;
+}
+EXPORT_SYMBOL(mmc_regulator_set_ocr);
+
+#endif
+
 /*
  * Mask off any voltages we don't support and select
  * the lowest voltage

commit c0c88871574ccb4ee53dde1bbb678931b38ed47b
Author: Wolfgang Muees <wolfgang.mues@auerswald.de>
Date:   Wed Mar 11 14:28:39 2009 +0100

    mmc_spi: allow higher timeouts for SPI mode
    
    Some SD cards have very high timeouts in SPI mode.
    So adjust the timeouts from theory to practice.
    
    Signed-off-by: Wolfgang Muees <wolfgang.mues@auerswald.de>
    Acked-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 4a18d90556d9..5c83c67b186c 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -297,6 +297,21 @@ void mmc_set_data_timeout(struct mmc_data *data, const struct mmc_card *card)
 			data->timeout_clks = 0;
 		}
 	}
+	/*
+	 * Some cards need very high timeouts if driven in SPI mode.
+	 * The worst observed timeout was 900ms after writing a
+	 * continuous stream of data until the internal logic
+	 * overflowed.
+	 */
+	if (mmc_host_is_spi(card->host)) {
+		if (data->flags & MMC_DATA_WRITE) {
+			if (data->timeout_ns < 1000000000)
+				data->timeout_ns = 1000000000;	/* 1s */
+		} else {
+			if (data->timeout_ns < 100000000)
+				data->timeout_ns =  100000000;	/* 100ms */
+		}
+	}
 }
 EXPORT_SYMBOL(mmc_set_data_timeout);
 

commit d3096f88ac4596a509fc5fbe6fa7e7a5497eb399
Author: Balaji Rao <balajirrao@openmoko.org>
Date:   Wed Feb 25 15:28:09 2009 +0530

    mmc: During unsafe resume, select the right volatge for the card
    
    During mmc unsafe resume, choose the right voltage for the card after
    powerup.
    
    Although this has not seen to cause trouble, it's the wrong behaviour.
    
    Signed-off-by: Balaji Rao <balajirrao@openmoko.org>
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index b5899e33b687..4a18d90556d9 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -877,6 +877,7 @@ int mmc_resume_host(struct mmc_host *host)
 	mmc_bus_get(host);
 	if (host->bus_ops && !host->bus_dead) {
 		mmc_power_up(host);
+		mmc_select_voltage(host, host->ocr);
 		BUG_ON(!host->bus_ops->resume);
 		host->bus_ops->resume(host);
 	}

commit 7de427d088a967d2173739e21e744921d5496a8b
Author: Jorg Schummer <ext-jorg.2.schummer@nokia.com>
Date:   Thu Feb 19 13:17:03 2009 +0200

    mmc: delayed_work was never cancelled
    
    The delayed work item mmc_host.detect is now cancelled before flushing
    the work queue. This takes care of cases when delayed_work was scheduled
    for mmc_host.detect, but not yet placed in the work queue.
    
    Signed-off-by: Jorg Schummer <ext-jorg.2.schummer@nokia.com>
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index df6ce4a06cf3..b5899e33b687 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -815,6 +815,7 @@ void mmc_stop_host(struct mmc_host *host)
 	spin_unlock_irqrestore(&host->lock, flags);
 #endif
 
+	cancel_delayed_work(&host->detect);
 	mmc_flush_scheduled_work();
 
 	mmc_bus_get(host);
@@ -842,6 +843,7 @@ void mmc_stop_host(struct mmc_host *host)
  */
 int mmc_suspend_host(struct mmc_host *host, pm_message_t state)
 {
+	cancel_delayed_work(&host->detect);
 	mmc_flush_scheduled_work();
 
 	mmc_bus_get(host);

commit f6e10b865c3ea56bdaa8c6ecfee313b997900dbb
Author: David Brownell <dbrownell@users.sourceforge.net>
Date:   Wed Dec 31 09:50:30 2008 -0800

    mmc: warn about voltage mismatches
    
    Get rid of a silent failure mode when the MMC/SD host doesn't
    support the voltages needed to operate a given card, by
    adding a warning.  A 3.3V host and a 3.0V card, for example,
    no longer need to mysteriously just not work at all.
    
    This isn't the best diagnostic; ideally it would also tell
    what voltage the card and host support (and not just by
    dumping the bitmasks).
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 5f288aeeb721..df6ce4a06cf3 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -542,6 +542,8 @@ u32 mmc_select_voltage(struct mmc_host *host, u32 ocr)
 		host->ios.vdd = bit;
 		mmc_set_ios(host);
 	} else {
+		pr_warning("%s: host doesn't support card's voltages\n",
+				mmc_hostname(host));
 		ocr = 0;
 	}
 

commit 86e8286a0e48663e1e86a5884b30a6d05de2993a
Author: Anton Vorontsov <avorontsov@ru.mvista.com>
Date:   Wed Nov 26 22:54:17 2008 +0300

    mmc: Add mmc_vddrange_to_ocrmask() helper function
    
    This function sets the OCR mask bits according to provided voltage
    ranges. Will be used by the mmc_spi OpenFirmware bindings.
    
    Signed-off-by: Anton Vorontsov <avorontsov@ru.mvista.com>
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index f7284b905eb3..5f288aeeb721 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -20,6 +20,7 @@
 #include <linux/err.h>
 #include <linux/leds.h>
 #include <linux/scatterlist.h>
+#include <linux/log2.h>
 
 #include <linux/mmc/card.h>
 #include <linux/mmc/host.h>
@@ -448,6 +449,80 @@ void mmc_set_bus_width(struct mmc_host *host, unsigned int width)
 	mmc_set_ios(host);
 }
 
+/**
+ * mmc_vdd_to_ocrbitnum - Convert a voltage to the OCR bit number
+ * @vdd:	voltage (mV)
+ * @low_bits:	prefer low bits in boundary cases
+ *
+ * This function returns the OCR bit number according to the provided @vdd
+ * value. If conversion is not possible a negative errno value returned.
+ *
+ * Depending on the @low_bits flag the function prefers low or high OCR bits
+ * on boundary voltages. For example,
+ * with @low_bits = true, 3300 mV translates to ilog2(MMC_VDD_32_33);
+ * with @low_bits = false, 3300 mV translates to ilog2(MMC_VDD_33_34);
+ *
+ * Any value in the [1951:1999] range translates to the ilog2(MMC_VDD_20_21).
+ */
+static int mmc_vdd_to_ocrbitnum(int vdd, bool low_bits)
+{
+	const int max_bit = ilog2(MMC_VDD_35_36);
+	int bit;
+
+	if (vdd < 1650 || vdd > 3600)
+		return -EINVAL;
+
+	if (vdd >= 1650 && vdd <= 1950)
+		return ilog2(MMC_VDD_165_195);
+
+	if (low_bits)
+		vdd -= 1;
+
+	/* Base 2000 mV, step 100 mV, bit's base 8. */
+	bit = (vdd - 2000) / 100 + 8;
+	if (bit > max_bit)
+		return max_bit;
+	return bit;
+}
+
+/**
+ * mmc_vddrange_to_ocrmask - Convert a voltage range to the OCR mask
+ * @vdd_min:	minimum voltage value (mV)
+ * @vdd_max:	maximum voltage value (mV)
+ *
+ * This function returns the OCR mask bits according to the provided @vdd_min
+ * and @vdd_max values. If conversion is not possible the function returns 0.
+ *
+ * Notes wrt boundary cases:
+ * This function sets the OCR bits for all boundary voltages, for example
+ * [3300:3400] range is translated to MMC_VDD_32_33 | MMC_VDD_33_34 |
+ * MMC_VDD_34_35 mask.
+ */
+u32 mmc_vddrange_to_ocrmask(int vdd_min, int vdd_max)
+{
+	u32 mask = 0;
+
+	if (vdd_max < vdd_min)
+		return 0;
+
+	/* Prefer high bits for the boundary vdd_max values. */
+	vdd_max = mmc_vdd_to_ocrbitnum(vdd_max, false);
+	if (vdd_max < 0)
+		return 0;
+
+	/* Prefer low bits for the boundary vdd_min values. */
+	vdd_min = mmc_vdd_to_ocrbitnum(vdd_min, true);
+	if (vdd_min < 0)
+		return 0;
+
+	/* Fill the mask, from max bit to min bit. */
+	while (vdd_max >= vdd_min)
+		mask |= 1 << vdd_max--;
+
+	return mask;
+}
+EXPORT_SYMBOL(mmc_vddrange_to_ocrmask);
+
 /*
  * Mask off any voltages we don't support and select
  * the lowest voltage

commit 493890e75d98810a3470b4aae23be628ee5e9667
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Sun Oct 26 12:37:25 2008 +0100

    mmc: increase SD write timeout for crappy cards
    
    It seems that some cards are slightly out of spec and occasionally
    will not be able to complete a write in the alloted 250 ms [1].
    Incease the timeout slightly to allow even these cards to function
    properly.
    
    [1] http://lkml.org/lkml/2008/9/23/390
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 044d84eeed7c..f7284b905eb3 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -280,7 +280,11 @@ void mmc_set_data_timeout(struct mmc_data *data, const struct mmc_card *card)
 			(card->host->ios.clock / 1000);
 
 		if (data->flags & MMC_DATA_WRITE)
-			limit_us = 250000;
+			/*
+			 * The limit is really 250 ms, but that is
+			 * insufficient for some crappy cards.
+			 */
+			limit_us = 300000;
 		else
 			limit_us = 100000;
 

commit a84756c5735f28bf000617f18734a9e94426386a
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Tue Jul 29 01:09:37 2008 +0200

    mmc: properly iterate over sg list in debug check
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 3ee5b8c3b5ce..044d84eeed7c 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -121,6 +121,7 @@ mmc_start_request(struct mmc_host *host, struct mmc_request *mrq)
 {
 #ifdef CONFIG_MMC_DEBUG
 	unsigned int i, sz;
+	struct scatterlist *sg;
 #endif
 
 	pr_debug("%s: starting CMD%u arg %08x flags %08x\n",
@@ -156,8 +157,8 @@ mmc_start_request(struct mmc_host *host, struct mmc_request *mrq)
 
 #ifdef CONFIG_MMC_DEBUG
 		sz = 0;
-		for (i = 0;i < mrq->data->sg_len;i++)
-			sz += mrq->data->sg[i].length;
+		for_each_sg(mrq->data->sg, sg, mrq->data->sg_len, i)
+			sz += sg->length;
 		BUG_ON(sz != mrq->data->blocks * mrq->data->blksz);
 #endif
 

commit ad3868b2ec96ec14a1549c9e33f5f9a2a3c6ab15
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Sat Jun 28 12:52:45 2008 +0200

    mmc,sdio: helper function for transfer padding
    
    There are a lot of crappy controllers out there that cannot handle
    all the request sizes that the MMC/SD/SDIO specifications require.
    In case the card driver can pad the data to overcome the problems,
    this commit adds a helper that calculates how much that padding
    should be.
    
    A corresponding helper is also added for SDIO, but it can also deal
    with all the complexities of splitting up a large transfer efficiently.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index ede5d1e2e20d..3ee5b8c3b5ce 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -3,7 +3,7 @@
  *
  *  Copyright (C) 2003-2004 Russell King, All Rights Reserved.
  *  SD support Copyright (C) 2004 Ian Molton, All Rights Reserved.
- *  Copyright (C) 2005-2007 Pierre Ossman, All Rights Reserved.
+ *  Copyright (C) 2005-2008 Pierre Ossman, All Rights Reserved.
  *  MMCv4 support Copyright (C) 2006 Philip Langdale, All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
@@ -294,6 +294,33 @@ void mmc_set_data_timeout(struct mmc_data *data, const struct mmc_card *card)
 }
 EXPORT_SYMBOL(mmc_set_data_timeout);
 
+/**
+ *	mmc_align_data_size - pads a transfer size to a more optimal value
+ *	@card: the MMC card associated with the data transfer
+ *	@sz: original transfer size
+ *
+ *	Pads the original data size with a number of extra bytes in
+ *	order to avoid controller bugs and/or performance hits
+ *	(e.g. some controllers revert to PIO for certain sizes).
+ *
+ *	Returns the improved size, which might be unmodified.
+ *
+ *	Note that this function is only relevant when issuing a
+ *	single scatter gather entry.
+ */
+unsigned int mmc_align_data_size(struct mmc_card *card, unsigned int sz)
+{
+	/*
+	 * FIXME: We don't have a system for the controller to tell
+	 * the core about its problems yet, so for now we just 32-bit
+	 * align the size.
+	 */
+	sz = ((sz + 3) / 4) * 4;
+
+	return sz;
+}
+EXPORT_SYMBOL(mmc_align_data_size);
+
 /**
  *	__mmc_claim_host - exclusively claim a host
  *	@host: mmc host to claim

commit 28f52482b41edc88cdf575aa6ed414c6e116ce10
Author: Anton Vorontsov <avorontsov@ru.mvista.com>
Date:   Tue Jun 17 18:17:15 2008 +0400

    mmc: add support for card-detection polling
    
    Some hosts (and boards that use mmc_spi) do not use interrupts on the CD
    line, so they can't trigger mmc_detect_change. We want to poll the card
    and see if there was a change. 1 second poll interval seems resonable.
    
    This patch also implements .get_cd() host operation, that could be used
    by the hosts that are able to report card-detect status without need to
    talk MMC.
    
    Signed-off-by: Anton Vorontsov <avorontsov@ru.mvista.com>
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 01ced4c5a61d..ede5d1e2e20d 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -638,6 +638,9 @@ void mmc_rescan(struct work_struct *work)
 		 */
 		mmc_bus_put(host);
 
+		if (host->ops->get_cd && host->ops->get_cd(host) == 0)
+			goto out;
+
 		mmc_claim_host(host);
 
 		mmc_power_up(host);
@@ -652,7 +655,7 @@ void mmc_rescan(struct work_struct *work)
 		if (!err) {
 			if (mmc_attach_sdio(host, ocr))
 				mmc_power_off(host);
-			return;
+			goto out;
 		}
 
 		/*
@@ -662,7 +665,7 @@ void mmc_rescan(struct work_struct *work)
 		if (!err) {
 			if (mmc_attach_sd(host, ocr))
 				mmc_power_off(host);
-			return;
+			goto out;
 		}
 
 		/*
@@ -672,7 +675,7 @@ void mmc_rescan(struct work_struct *work)
 		if (!err) {
 			if (mmc_attach_mmc(host, ocr))
 				mmc_power_off(host);
-			return;
+			goto out;
 		}
 
 		mmc_release_host(host);
@@ -683,6 +686,9 @@ void mmc_rescan(struct work_struct *work)
 
 		mmc_bus_put(host);
 	}
+out:
+	if (host->caps & MMC_CAP_NEEDS_POLL)
+		mmc_schedule_delayed_work(&host->detect, HZ);
 }
 
 void mmc_start_host(struct mmc_host *host)

commit 98b843be56079ad26fe4b9e421fd11b0598b85f3
Author: Adrian Bunk <bunk@kernel.org>
Date:   Sun Apr 13 21:15:50 2008 +0300

    mmc: proper prototypes for mmc_attach_*()
    
    This patch adds proper prototypes for mmc_attach_*() in
    drivers/mmc/core/core.h
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index ab91b02b2bff..01ced4c5a61d 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -35,10 +35,6 @@
 #include "sd_ops.h"
 #include "sdio_ops.h"
 
-extern int mmc_attach_mmc(struct mmc_host *host, u32 ocr);
-extern int mmc_attach_sd(struct mmc_host *host, u32 ocr);
-extern int mmc_attach_sdio(struct mmc_host *host, u32 ocr);
-
 static struct workqueue_struct *workqueue;
 
 /*

commit 261172fd1b23769bc7632047e2cb826c9b8b1a50
Author: Adrian Bunk <bunk@kernel.org>
Date:   Sun Apr 13 21:15:47 2008 +0300

    mmc: make __mmc_release_bus() static
    
    This patch makes the needlessly global __mmc_release_bus() static.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index b96667448eb5..ab91b02b2bff 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -516,7 +516,7 @@ static void mmc_power_off(struct mmc_host *host)
 /*
  * Cleanup when the last reference to the bus operator is dropped.
  */
-void __mmc_release_bus(struct mmc_host *host)
+static void __mmc_release_bus(struct mmc_host *host)
 {
 	BUG_ON(!host);
 	BUG_ON(host->bus_refs);

commit 87ae9afdcada236d0a1b38ce2c465a65916961dc
Author: Adrian Bunk <bunk@kernel.org>
Date:   Tue Oct 30 10:35:04 2007 +0100

    cleanup asm/scatterlist.h includes
    
    Not architecture specific code should not #include <asm/scatterlist.h>.
    
    This patch therefore either replaces them with
    #include <linux/scatterlist.h> or simply removes them if they were
    unused.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 09435e0ec680..b96667448eb5 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -19,7 +19,6 @@
 #include <linux/pagemap.h>
 #include <linux/err.h>
 #include <linux/leds.h>
-#include <asm/scatterlist.h>
 #include <linux/scatterlist.h>
 
 #include <linux/mmc/card.h>

commit af8350c756cb48a738474738f7bf8c0e572fa057
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Mon Sep 24 07:15:48 2007 +0200

    mmc: add led trigger
    
    Add a led trigger for each host controller that indicates if there
    is a request active on the controller.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index bad39442f8fe..09435e0ec680 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -18,6 +18,7 @@
 #include <linux/delay.h>
 #include <linux/pagemap.h>
 #include <linux/err.h>
+#include <linux/leds.h>
 #include <asm/scatterlist.h>
 #include <linux/scatterlist.h>
 
@@ -92,6 +93,8 @@ void mmc_request_done(struct mmc_host *host, struct mmc_request *mrq)
 		cmd->error = 0;
 		host->ops->request(host, mrq);
 	} else {
+		led_trigger_event(host->led, LED_OFF);
+
 		pr_debug("%s: req done (CMD%u): %d: %08x %08x %08x %08x\n",
 			mmc_hostname(host), cmd->opcode, err,
 			cmd->resp[0], cmd->resp[1],
@@ -146,6 +149,8 @@ mmc_start_request(struct mmc_host *host, struct mmc_request *mrq)
 
 	WARN_ON(!host->claimed);
 
+	led_trigger_event(host->led, LED_FULL);
+
 	mrq->cmd->error = 0;
 	mrq->cmd->mrq = mrq;
 	if (mrq->data) {

commit af51715079e7fb6b290e1881d63d815dc4de5011
Author: David Brownell <david-b@pacbell.net>
Date:   Wed Aug 8 09:11:32 2007 -0700

    MMC core learns about SPI
    
    Teach the MMC/SD/SDIO core about using SPI mode.
    
     - Use mmc_host_is_spi() so enumeration works through SPI signaling
       and protocols, not just the native versions.
    
     - Provide the SPI response type flags with each request issued,
       including requests from the new lock/unlock code.
    
     - Understand that cmd->resp[0] and mmc_get_status() results for SPI
       return different values than for "native" MMC/SD protocol; this
       affects resetting, checking card lock status, and some others.
    
     - Understand that some commands act a bit differently ... notably:
         * OP_COND command doesn't return the OCR
         * APP_CMD status doesn't have an R1_APP_CMD analogue
    
    Those changes required some new and updated primitives:
    
     - Provide utilities to access two SPI-only requests, and one
       request that wasn't previously needed:
         * mmc_spi_read_ocr() ... SPI only
         * mmc_spi_set_crc() ... SPI only (override by module parm)
         * mmc_send_cid() ... for use without broadcast mode
    
     - Updated internal routines:
         * Previous mmc_send_csd() modified into mmc_send_cxd_native();
           it uses native "R2" responses, which include 16 bytes of data.
         * Previous mmc_send_ext_csd() becomes new mmc_send_cxd_data()
           helper for command-and-data access
         * Bugfix to that mmc_send_cxd_data() code:  dma-to-stack is
           unsafe/nonportable, so kmalloc a bounce buffer instead.
    
     - Modified mmc_send_ext_csd() now uses mmc_send_cxd_data() helper
    
     - Modified mmc_send_csd(), and new mmc_spi_send_cid(), routines use
       those helper routines based on whether they're native or SPI
    
    The newest categories of cards supported by the MMC stack aren't expected
    to work yet with SPI:  MMC or SD cards with over 4GB data, and SDIO.
    All those cards support SPI mode, so eventually they should work too.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index bffcaf8df352..bad39442f8fe 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -41,6 +41,14 @@ extern int mmc_attach_sdio(struct mmc_host *host, u32 ocr);
 
 static struct workqueue_struct *workqueue;
 
+/*
+ * Enabling software CRCs on the data blocks can be a significant (30%)
+ * performance cost, and for other reasons may not always be desired.
+ * So we allow it it to be disabled.
+ */
+int use_spi_crc = 1;
+module_param(use_spi_crc, bool, 0);
+
 /*
  * Internal function. Schedule delayed work in the MMC work queue.
  */
@@ -71,6 +79,11 @@ void mmc_request_done(struct mmc_host *host, struct mmc_request *mrq)
 	struct mmc_command *cmd = mrq->cmd;
 	int err = cmd->error;
 
+	if (err && cmd->retries && mmc_host_is_spi(host)) {
+		if (cmd->resp[0] & R1_SPI_ILLEGAL_COMMAND)
+			cmd->retries = 0;
+	}
+
 	if (err && cmd->retries) {
 		pr_debug("%s: req failed (CMD%u): %d, retrying...\n",
 			mmc_hostname(host), cmd->opcode, err);
@@ -453,8 +466,13 @@ static void mmc_power_up(struct mmc_host *host)
 	int bit = fls(host->ocr_avail) - 1;
 
 	host->ios.vdd = bit;
-	host->ios.bus_mode = MMC_BUSMODE_OPENDRAIN;
-	host->ios.chip_select = MMC_CS_DONTCARE;
+	if (mmc_host_is_spi(host)) {
+		host->ios.chip_select = MMC_CS_HIGH;
+		host->ios.bus_mode = MMC_BUSMODE_PUSHPULL;
+	} else {
+		host->ios.chip_select = MMC_CS_DONTCARE;
+		host->ios.bus_mode = MMC_BUSMODE_OPENDRAIN;
+	}
 	host->ios.power_mode = MMC_POWER_UP;
 	host->ios.bus_width = MMC_BUS_WIDTH_1;
 	host->ios.timing = MMC_TIMING_LEGACY;
@@ -481,8 +499,10 @@ static void mmc_power_off(struct mmc_host *host)
 {
 	host->ios.clock = 0;
 	host->ios.vdd = 0;
-	host->ios.bus_mode = MMC_BUSMODE_OPENDRAIN;
-	host->ios.chip_select = MMC_CS_DONTCARE;
+	if (!mmc_host_is_spi(host)) {
+		host->ios.bus_mode = MMC_BUSMODE_OPENDRAIN;
+		host->ios.chip_select = MMC_CS_DONTCARE;
+	}
 	host->ios.power_mode = MMC_POWER_OFF;
 	host->ios.bus_width = MMC_BUS_WIDTH_1;
 	host->ios.timing = MMC_TIMING_LEGACY;

commit f9996aee36921e8f1d499de1b2ea380855cf6d97
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Wed Sep 19 18:38:50 2007 +0200

    mmc: increase power up delay
    
    Increase delay for power up in order to support some slower boards.
    
    Also add some comments about why the delays are there.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 3bebd3b55dc5..bffcaf8df352 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -460,12 +460,20 @@ static void mmc_power_up(struct mmc_host *host)
 	host->ios.timing = MMC_TIMING_LEGACY;
 	mmc_set_ios(host);
 
-	mmc_delay(1);
+	/*
+	 * This delay should be sufficient to allow the power supply
+	 * to reach the minimum voltage.
+	 */
+	mmc_delay(2);
 
 	host->ios.clock = host->f_min;
 	host->ios.power_mode = MMC_POWER_ON;
 	mmc_set_ios(host);
 
+	/*
+	 * This delay must be at least 74 clock sizes, or 1 ms, or the
+	 * time required to reach a stable voltage.
+	 */
 	mmc_delay(2);
 }
 

commit d84075c8aed771d47d7ac6e96b098559da361c25
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Thu Aug 9 13:23:56 2007 +0200

    mmc: replace BUG_ON with WARN_ON
    
    Replace all cases of BUG_ON with WARN_ON where there is a chance
    (with varying degrees of slim) that the kernel can continue without
    incidence.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 9d29bed820a1..3bebd3b55dc5 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -202,7 +202,7 @@ int mmc_wait_for_cmd(struct mmc_host *host, struct mmc_command *cmd, int retries
 {
 	struct mmc_request mrq;
 
-	BUG_ON(!host->claimed);
+	WARN_ON(!host->claimed);
 
 	memset(&mrq, 0, sizeof(struct mmc_request));
 
@@ -333,7 +333,7 @@ void mmc_release_host(struct mmc_host *host)
 {
 	unsigned long flags;
 
-	BUG_ON(!host->claimed);
+	WARN_ON(!host->claimed);
 
 	spin_lock_irqsave(&host->lock, flags);
 	host->claimed = 0;
@@ -531,7 +531,7 @@ void mmc_attach_bus(struct mmc_host *host, const struct mmc_bus_ops *ops)
 	BUG_ON(!host);
 	BUG_ON(!ops);
 
-	BUG_ON(!host->claimed);
+	WARN_ON(!host->claimed);
 
 	spin_lock_irqsave(&host->lock, flags);
 
@@ -555,8 +555,8 @@ void mmc_detach_bus(struct mmc_host *host)
 
 	BUG_ON(!host);
 
-	BUG_ON(!host->claimed);
-	BUG_ON(!host->bus_ops);
+	WARN_ON(!host->claimed);
+	WARN_ON(!host->bus_ops);
 
 	spin_lock_irqsave(&host->lock, flags);
 
@@ -584,7 +584,7 @@ void mmc_detect_change(struct mmc_host *host, unsigned long delay)
 #ifdef CONFIG_MMC_DEBUG
 	unsigned long flags;
 	spin_lock_irqsave(&host->lock, flags);
-	BUG_ON(host->removed);
+	WARN_ON(host->removed);
 	spin_unlock_irqrestore(&host->lock, flags);
 #endif
 

commit e6f918bf39773d712ab5b457bff54ade3bda0cb1
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Tue Aug 7 14:11:55 2007 +0200

    mmc: fix sdio timeout calculation
    
    SDIO doesn't have a CSD so it uses different timeout values than
    SD memory.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 07c03cb677b6..9d29bed820a1 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -231,6 +231,15 @@ void mmc_set_data_timeout(struct mmc_data *data, const struct mmc_card *card)
 {
 	unsigned int mult;
 
+	/*
+	 * SDIO cards only define an upper 1 s limit on access.
+	 */
+	if (mmc_card_sdio(card)) {
+		data->timeout_ns = 1000000000;
+		data->timeout_clks = 0;
+		return;
+	}
+
 	/*
 	 * SD cards use a 100 multiplier rather than 10
 	 */

commit ce252edd869ba1fee6a9a6f83e20f349d4c4d669
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Tue Aug 7 14:06:18 2007 +0200

    mmc: fix incorrect divisor in debug output
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index d1e4b0849e39..07c03cb677b6 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -121,7 +121,7 @@ mmc_start_request(struct mmc_host *host, struct mmc_request *mrq)
 			"tsac %d ms nsac %d\n",
 			mmc_hostname(host), mrq->data->blksz,
 			mrq->data->blocks, mrq->data->flags,
-			mrq->data->timeout_ns / 10000000,
+			mrq->data->timeout_ns / 1000000,
 			mrq->data->timeout_clks);
 	}
 

commit 2342f3323c9a76367a1d7f9a35525ee3cb3911df
Author: Nicolas Pitre <nico@cam.org>
Date:   Sat Jun 30 16:21:52 2007 +0200

    sdio: allow for mmc_claim_host to be aborted
    
    It is sometimes necessary to give up on trying to claim the host lock,
    especially if that happens in a thread that has to be stopped.
    
    While at it, fix the description for mmc_claim_host() which was wrong.
    
    Signed-off-by: Nicolas Pitre <npitre@mvista.com>
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index b8f27e5ade97..d1e4b0849e39 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -273,15 +273,20 @@ void mmc_set_data_timeout(struct mmc_data *data, const struct mmc_card *card)
 EXPORT_SYMBOL(mmc_set_data_timeout);
 
 /**
- *	mmc_claim_host - exclusively claim a host
+ *	__mmc_claim_host - exclusively claim a host
  *	@host: mmc host to claim
+ *	@abort: whether or not the operation should be aborted
  *
- *	Claim a host for a set of operations.
+ *	Claim a host for a set of operations.  If @abort is non null and
+ *	dereference a non-zero value then this will return prematurely with
+ *	that non-zero value without acquiring the lock.  Returns zero
+ *	with the lock held otherwise.
  */
-void mmc_claim_host(struct mmc_host *host)
+int __mmc_claim_host(struct mmc_host *host, atomic_t *abort)
 {
 	DECLARE_WAITQUEUE(wait, current);
 	unsigned long flags;
+	int stop;
 
 	might_sleep();
 
@@ -289,19 +294,24 @@ void mmc_claim_host(struct mmc_host *host)
 	spin_lock_irqsave(&host->lock, flags);
 	while (1) {
 		set_current_state(TASK_UNINTERRUPTIBLE);
-		if (!host->claimed)
+		stop = abort ? atomic_read(abort) : 0;
+		if (stop || !host->claimed)
 			break;
 		spin_unlock_irqrestore(&host->lock, flags);
 		schedule();
 		spin_lock_irqsave(&host->lock, flags);
 	}
 	set_current_state(TASK_RUNNING);
-	host->claimed = 1;
+	if (!stop)
+		host->claimed = 1;
+	else
+		wake_up(&host->wq);
 	spin_unlock_irqrestore(&host->lock, flags);
 	remove_wait_queue(&host->wq, &wait);
+	return stop;
 }
 
-EXPORT_SYMBOL(mmc_claim_host);
+EXPORT_SYMBOL(__mmc_claim_host);
 
 /**
  *	mmc_release_host - release a host

commit 26074962e8f547b96614dbe248748ba2a1996ca3
Author: Nicolas Pitre <nico@cam.org>
Date:   Sat Jun 16 02:07:53 2007 -0400

    mmc: initialize mmc subsystem with subsys_initcall()
    
    The problem is that the sdio_bus must be registered before any SDIO
    drivers are registered against it otherwise the kernel sulks.  Because
    the sdio_bus registration happens through module_init (equivalent to
    device_initcall), then any SDIO
    drivers linked before the SDIO core code in the kernel will be initialized
    first.
    
    Upcoming SDIO function drivers are likely to be located outside the
    drivers/mmc directory as it is common practice to group drivers according
    to their function rather than the bus they use.  SDIO drivers are therefore
    likely to appear at random location in the kernel link.
    
    To make sure the sdio_bus is always initialized before any SDIO drivers,
    let's move the MMC init to the subsys_initcall level.
    
    Signed-off-by: Nicolas Pitre <npitre@mvista.com>
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 9747455928da..b8f27e5ade97 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -771,7 +771,7 @@ static void __exit mmc_exit(void)
 	destroy_workqueue(workqueue);
 }
 
-module_init(mmc_init);
+subsys_initcall(mmc_init);
 module_exit(mmc_exit);
 
 MODULE_LICENSE("GPL");

commit e29a7d73f4277eb92aa64e17017dea33460828ef
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Sat May 26 13:48:18 2007 +0200

    mmc: basic SDIO device model
    
    Add the sdio bus type and basic device handling.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 092fa906ab86..9747455928da 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -29,6 +29,7 @@
 #include "core.h"
 #include "bus.h"
 #include "host.h"
+#include "sdio_bus.h"
 
 #include "mmc_ops.h"
 #include "sd_ops.h"
@@ -739,16 +740,32 @@ static int __init mmc_init(void)
 		return -ENOMEM;
 
 	ret = mmc_register_bus();
-	if (ret == 0) {
-		ret = mmc_register_host_class();
-		if (ret)
-			mmc_unregister_bus();
-	}
+	if (ret)
+		goto destroy_workqueue;
+
+	ret = mmc_register_host_class();
+	if (ret)
+		goto unregister_bus;
+
+	ret = sdio_register_bus();
+	if (ret)
+		goto unregister_host_class;
+
+	return 0;
+
+unregister_host_class:
+	mmc_unregister_host_class();
+unregister_bus:
+	mmc_unregister_bus();
+destroy_workqueue:
+	destroy_workqueue(workqueue);
+
 	return ret;
 }
 
 static void __exit mmc_exit(void)
 {
+	sdio_unregister_bus();
 	mmc_unregister_host_class();
 	mmc_unregister_bus();
 	destroy_workqueue(workqueue);

commit 5c4e6f1301649d5b29dd0f70e6da83e728ab5ca5
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Mon May 21 20:23:20 2007 +0200

    mmc: detect SDIO cards
    
    Really basic init sequence for SDIO cards.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 51e611f2f33d..092fa906ab86 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -32,9 +32,11 @@
 
 #include "mmc_ops.h"
 #include "sd_ops.h"
+#include "sdio_ops.h"
 
 extern int mmc_attach_mmc(struct mmc_host *host, u32 ocr);
 extern int mmc_attach_sd(struct mmc_host *host, u32 ocr);
+extern int mmc_attach_sdio(struct mmc_host *host, u32 ocr);
 
 static struct workqueue_struct *workqueue;
 
@@ -595,24 +597,38 @@ void mmc_rescan(struct work_struct *work)
 
 		mmc_send_if_cond(host, host->ocr_avail);
 
+		/*
+		 * First we search for SDIO...
+		 */
+		err = mmc_send_io_op_cond(host, 0, &ocr);
+		if (!err) {
+			if (mmc_attach_sdio(host, ocr))
+				mmc_power_off(host);
+			return;
+		}
+
+		/*
+		 * ...then normal SD...
+		 */
 		err = mmc_send_app_op_cond(host, 0, &ocr);
 		if (!err) {
 			if (mmc_attach_sd(host, ocr))
 				mmc_power_off(host);
-		} else {
-			/*
-			 * If we fail to detect any SD cards then try
-			 * searching for MMC cards.
-			 */
-			err = mmc_send_op_cond(host, 0, &ocr);
-			if (!err) {
-				if (mmc_attach_mmc(host, ocr))
-					mmc_power_off(host);
-			} else {
+			return;
+		}
+
+		/*
+		 * ...and finally MMC.
+		 */
+		err = mmc_send_op_cond(host, 0, &ocr);
+		if (!err) {
+			if (mmc_attach_mmc(host, ocr))
 				mmc_power_off(host);
-				mmc_release_host(host);
-			}
+			return;
 		}
+
+		mmc_release_host(host);
+		mmc_power_off(host);
 	} else {
 		if (host->bus_ops->detect && !host->bus_dead)
 			host->bus_ops->detect(host);

commit b146d26a61e0feab2f12a98ae83fd352830899c0
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Tue Jul 24 19:16:54 2007 +0200

    mmc: mmc_set_data_timeout() parameter write is redundant
    
    The write parameter in mmc_set_data_timeout() is redundant as the
    data structure contains information about the direction of the
    transfer.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 63b67296e92d..51e611f2f33d 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -220,13 +220,11 @@ EXPORT_SYMBOL(mmc_wait_for_cmd);
  *	mmc_set_data_timeout - set the timeout for a data command
  *	@data: data phase for command
  *	@card: the MMC card associated with the data transfer
- *	@write: flag to differentiate reads from writes
  *
  *	Computes the data timeout parameters according to the
  *	correct algorithm given the card type.
  */
-void mmc_set_data_timeout(struct mmc_data *data, const struct mmc_card *card,
-			  int write)
+void mmc_set_data_timeout(struct mmc_data *data, const struct mmc_card *card)
 {
 	unsigned int mult;
 
@@ -239,7 +237,7 @@ void mmc_set_data_timeout(struct mmc_data *data, const struct mmc_card *card,
 	 * Scale up the multiplier (and therefore the timeout) by
 	 * the r2w factor for writes.
 	 */
-	if (write)
+	if (data->flags & MMC_DATA_WRITE)
 		mult <<= card->csd.r2w_factor;
 
 	data->timeout_ns = card->csd.tacc_ns * mult;
@@ -255,7 +253,7 @@ void mmc_set_data_timeout(struct mmc_data *data, const struct mmc_card *card,
 		timeout_us += data->timeout_clks * 1000 /
 			(card->host->ios.clock / 1000);
 
-		if (write)
+		if (data->flags & MMC_DATA_WRITE)
 			limit_us = 250000;
 		else
 			limit_us = 100000;

commit 17b0429dde9ab60f9cee8e07ab28c7dc6cfe6efd
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Sun Jul 22 22:18:46 2007 +0200

    mmc: remove custom error codes
    
    Convert the MMC layer to use standard error codes and not its own,
    incompatible values.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index bfd2ae5bd669..63b67296e92d 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -598,7 +598,7 @@ void mmc_rescan(struct work_struct *work)
 		mmc_send_if_cond(host, host->ocr_avail);
 
 		err = mmc_send_app_op_cond(host, 0, &ocr);
-		if (err == MMC_ERR_NONE) {
+		if (!err) {
 			if (mmc_attach_sd(host, ocr))
 				mmc_power_off(host);
 		} else {
@@ -607,7 +607,7 @@ void mmc_rescan(struct work_struct *work)
 			 * searching for MMC cards.
 			 */
 			err = mmc_send_op_cond(host, 0, &ocr);
-			if (err == MMC_ERR_NONE) {
+			if (!err) {
 				if (mmc_attach_mmc(host, ocr))
 					mmc_power_off(host);
 			} else {

commit 393618510d5349e07d71dc28fb6fc49baf0d96a0
Author: Adrian Bunk <bunk@stusta.de>
Date:   Wed Jul 25 00:40:58 2007 +0200

    drivers/mmc/core/: make 3 functions static
    
    This patch makes the following needlessly global functions static:
    - sd_ops.c: mmc_app_cmd()
    - core.c: __mmc_release_bus()
    - core.c: mmc_start_request()
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index d08968470c41..bfd2ae5bd669 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -102,15 +102,7 @@ void mmc_request_done(struct mmc_host *host, struct mmc_request *mrq)
 
 EXPORT_SYMBOL(mmc_request_done);
 
-/**
- *	mmc_start_request - start a command on a host
- *	@host: MMC host to start command on
- *	@mrq: MMC request to start
- *
- *	Queue a command on the specified host.  We expect the
- *	caller to be holding the host lock with interrupts disabled.
- */
-void
+static void
 mmc_start_request(struct mmc_host *host, struct mmc_request *mrq)
 {
 #ifdef CONFIG_MMC_DEBUG
@@ -165,8 +157,6 @@ mmc_start_request(struct mmc_host *host, struct mmc_request *mrq)
 	host->ops->request(host, mrq);
 }
 
-EXPORT_SYMBOL(mmc_start_request);
-
 static void mmc_wait_done(struct mmc_request *mrq)
 {
 	complete(mrq->done_data);
@@ -471,6 +461,45 @@ static void mmc_power_off(struct mmc_host *host)
 	mmc_set_ios(host);
 }
 
+/*
+ * Cleanup when the last reference to the bus operator is dropped.
+ */
+void __mmc_release_bus(struct mmc_host *host)
+{
+	BUG_ON(!host);
+	BUG_ON(host->bus_refs);
+	BUG_ON(!host->bus_dead);
+
+	host->bus_ops = NULL;
+}
+
+/*
+ * Increase reference count of bus operator
+ */
+static inline void mmc_bus_get(struct mmc_host *host)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&host->lock, flags);
+	host->bus_refs++;
+	spin_unlock_irqrestore(&host->lock, flags);
+}
+
+/*
+ * Decrease reference count of bus operator and free it if
+ * it is the last reference.
+ */
+static inline void mmc_bus_put(struct mmc_host *host)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&host->lock, flags);
+	host->bus_refs--;
+	if ((host->bus_refs == 0) && host->bus_ops)
+		__mmc_release_bus(host);
+	spin_unlock_irqrestore(&host->lock, flags);
+}
+
 /*
  * Assign a mmc bus handler to a host. Only one bus handler may control a
  * host at any given time.
@@ -520,18 +549,6 @@ void mmc_detach_bus(struct mmc_host *host)
 	mmc_bus_put(host);
 }
 
-/*
- * Cleanup when the last reference to the bus operator is dropped.
- */
-void __mmc_release_bus(struct mmc_host *host)
-{
-	BUG_ON(!host);
-	BUG_ON(host->bus_refs);
-	BUG_ON(!host->bus_dead);
-
-	host->bus_ops = NULL;
-}
-
 /**
  *	mmc_detect_change - process change of state on a MMC socket
  *	@host: host which changed state.

commit e4d217087458914a6d5d9fd034d7237e6530c619
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Tue Jul 24 21:46:49 2007 +0200

    mmc: proper debugging output in core
    
    Make sure that the debugging output in the core is complete.
    This should allow us to clean up all the extra debug output
    that each and every other host driver seems to contain.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 3208890b10b3..d08968470c41 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -68,18 +68,35 @@ void mmc_request_done(struct mmc_host *host, struct mmc_request *mrq)
 	struct mmc_command *cmd = mrq->cmd;
 	int err = cmd->error;
 
-	pr_debug("%s: req done (CMD%u): %d/%d/%d: %08x %08x %08x %08x\n",
-		 mmc_hostname(host), cmd->opcode, err,
-		 mrq->data ? mrq->data->error : 0,
-		 mrq->stop ? mrq->stop->error : 0,
-		 cmd->resp[0], cmd->resp[1], cmd->resp[2], cmd->resp[3]);
-
 	if (err && cmd->retries) {
+		pr_debug("%s: req failed (CMD%u): %d, retrying...\n",
+			mmc_hostname(host), cmd->opcode, err);
+
 		cmd->retries--;
 		cmd->error = 0;
 		host->ops->request(host, mrq);
-	} else if (mrq->done) {
-		mrq->done(mrq);
+	} else {
+		pr_debug("%s: req done (CMD%u): %d: %08x %08x %08x %08x\n",
+			mmc_hostname(host), cmd->opcode, err,
+			cmd->resp[0], cmd->resp[1],
+			cmd->resp[2], cmd->resp[3]);
+
+		if (mrq->data) {
+			pr_debug("%s:     %d bytes transferred: %d\n",
+				mmc_hostname(host),
+				mrq->data->bytes_xfered, mrq->data->error);
+		}
+
+		if (mrq->stop) {
+			pr_debug("%s:     (CMD%u): %d: %08x %08x %08x %08x\n",
+				mmc_hostname(host), mrq->stop->opcode,
+				mrq->stop->error,
+				mrq->stop->resp[0], mrq->stop->resp[1],
+				mrq->stop->resp[2], mrq->stop->resp[3]);
+		}
+
+		if (mrq->done)
+			mrq->done(mrq);
 	}
 }
 
@@ -104,6 +121,21 @@ mmc_start_request(struct mmc_host *host, struct mmc_request *mrq)
 		 mmc_hostname(host), mrq->cmd->opcode,
 		 mrq->cmd->arg, mrq->cmd->flags);
 
+	if (mrq->data) {
+		pr_debug("%s:     blksz %d blocks %d flags %08x "
+			"tsac %d ms nsac %d\n",
+			mmc_hostname(host), mrq->data->blksz,
+			mrq->data->blocks, mrq->data->flags,
+			mrq->data->timeout_ns / 10000000,
+			mrq->data->timeout_clks);
+	}
+
+	if (mrq->stop) {
+		pr_debug("%s:     CMD%u arg %08x flags %08x\n",
+			 mmc_hostname(host), mrq->stop->opcode,
+			 mrq->stop->arg, mrq->stop->flags);
+	}
+
 	WARN_ON(!host->claimed);
 
 	mrq->cmd->error = 0;

commit cf795bfb3ad4e2f8f6bb346aa8edb8272d4c70a2
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Wed Jul 11 20:28:02 2007 +0200

    mmc: add a might_sleep() to mmc_claim_host()
    
    In the normal case, the host lock can be claimed directly.
    When it cannot, the caller will sleep. Make sure we don't
    have any latent bugs by always calling might_sleep().
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index e08aa352bd50..3208890b10b3 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -260,6 +260,8 @@ void mmc_claim_host(struct mmc_host *host)
 	DECLARE_WAITQUEUE(wait, current);
 	unsigned long flags;
 
+	might_sleep();
+
 	add_wait_queue(&host->wq, &wait);
 	spin_lock_irqsave(&host->lock, flags);
 	while (1) {

commit 67a61c484735de9bf4f099830ecb4ef2eca95c38
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Wed Jul 11 20:22:11 2007 +0200

    mmc: update kerneldoc
    
    Make sure the kerneldoc comments are up to date and relevant.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index b5d8a6d90cca..e08aa352bd50 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -140,7 +140,16 @@ static void mmc_wait_done(struct mmc_request *mrq)
 	complete(mrq->done_data);
 }
 
-int mmc_wait_for_req(struct mmc_host *host, struct mmc_request *mrq)
+/**
+ *	mmc_wait_for_req - start a request and wait for completion
+ *	@host: MMC host to start command
+ *	@mrq: MMC request to start
+ *
+ *	Start a new MMC custom command request for a host, and wait
+ *	for the command to complete. Does not attempt to parse the
+ *	response.
+ */
+void mmc_wait_for_req(struct mmc_host *host, struct mmc_request *mrq)
 {
 	DECLARE_COMPLETION_ONSTACK(complete);
 
@@ -150,8 +159,6 @@ int mmc_wait_for_req(struct mmc_host *host, struct mmc_request *mrq)
 	mmc_start_request(host, mrq);
 
 	wait_for_completion(&complete);
-
-	return 0;
 }
 
 EXPORT_SYMBOL(mmc_wait_for_req);
@@ -192,6 +199,9 @@ EXPORT_SYMBOL(mmc_wait_for_cmd);
  *	@data: data phase for command
  *	@card: the MMC card associated with the data transfer
  *	@write: flag to differentiate reads from writes
+ *
+ *	Computes the data timeout parameters according to the
+ *	correct algorithm given the card type.
  */
 void mmc_set_data_timeout(struct mmc_data *data, const struct mmc_card *card,
 			  int write)
@@ -240,15 +250,10 @@ void mmc_set_data_timeout(struct mmc_data *data, const struct mmc_card *card,
 EXPORT_SYMBOL(mmc_set_data_timeout);
 
 /**
- *	__mmc_claim_host - exclusively claim a host
+ *	mmc_claim_host - exclusively claim a host
  *	@host: mmc host to claim
- *	@card: mmc card to claim host for
- *
- *	Claim a host for a set of operations.  If a valid card
- *	is passed and this wasn't the last card selected, select
- *	the card before returning.
  *
- *	Note: you should use mmc_card_claim_host or mmc_claim_host.
+ *	Claim a host for a set of operations.
  */
 void mmc_claim_host(struct mmc_host *host)
 {
@@ -498,8 +503,10 @@ void __mmc_release_bus(struct mmc_host *host)
  *	@host: host which changed state.
  *	@delay: optional delay to wait before detection (jiffies)
  *
- *	All we know is that card(s) have been inserted or removed
- *	from the socket(s).  We don't know which socket or cards.
+ *	MMC drivers should call this when they detect a card has been
+ *	inserted or removed. The MMC layer will confirm that any
+ *	present card is still functional, and initialize any newly
+ *	inserted.
  */
 void mmc_detect_change(struct mmc_host *host, unsigned long delay)
 {

commit ffce2e7e7060c949ccd703dacc9b3dd81b377373
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Sat May 19 14:32:22 2007 +0200

    mmc: move layer init and workqueue to core file
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 66e463d100c5..b5d8a6d90cca 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -27,7 +27,8 @@
 #include <linux/mmc/sd.h>
 
 #include "core.h"
-#include "sysfs.h"
+#include "bus.h"
+#include "host.h"
 
 #include "mmc_ops.h"
 #include "sd_ops.h"
@@ -35,6 +36,25 @@
 extern int mmc_attach_mmc(struct mmc_host *host, u32 ocr);
 extern int mmc_attach_sd(struct mmc_host *host, u32 ocr);
 
+static struct workqueue_struct *workqueue;
+
+/*
+ * Internal function. Schedule delayed work in the MMC work queue.
+ */
+static int mmc_schedule_delayed_work(struct delayed_work *work,
+				     unsigned long delay)
+{
+	return queue_delayed_work(workqueue, work, delay);
+}
+
+/*
+ * Internal function. Flush all scheduled work from the MMC work queue.
+ */
+static void mmc_flush_scheduled_work(void)
+{
+	flush_workqueue(workqueue);
+}
+
 /**
  *	mmc_request_done - finish processing an MMC request
  *	@host: MMC host which completed request
@@ -638,4 +658,31 @@ EXPORT_SYMBOL(mmc_resume_host);
 
 #endif
 
+static int __init mmc_init(void)
+{
+	int ret;
+
+	workqueue = create_singlethread_workqueue("kmmcd");
+	if (!workqueue)
+		return -ENOMEM;
+
+	ret = mmc_register_bus();
+	if (ret == 0) {
+		ret = mmc_register_host_class();
+		if (ret)
+			mmc_unregister_bus();
+	}
+	return ret;
+}
+
+static void __exit mmc_exit(void)
+{
+	mmc_unregister_host_class();
+	mmc_unregister_bus();
+	destroy_workqueue(workqueue);
+}
+
+module_init(mmc_init);
+module_exit(mmc_exit);
+
 MODULE_LICENSE("GPL");

commit b93931a61a119575f84c33af2438b9384fde9eb7
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Sat May 19 14:06:24 2007 +0200

    mmc: refactor host class handling
    
    Move basic host class device handling to its own file for clarity.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index d876adf4bd4e..66e463d100c5 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -496,7 +496,7 @@ void mmc_detect_change(struct mmc_host *host, unsigned long delay)
 EXPORT_SYMBOL(mmc_detect_change);
 
 
-static void mmc_rescan(struct work_struct *work)
+void mmc_rescan(struct work_struct *work)
 {
 	struct mmc_host *host =
 		container_of(work, struct mmc_host, detect.work);
@@ -545,69 +545,13 @@ static void mmc_rescan(struct work_struct *work)
 	}
 }
 
-
-/**
- *	mmc_alloc_host - initialise the per-host structure.
- *	@extra: sizeof private data structure
- *	@dev: pointer to host device model structure
- *
- *	Initialise the per-host structure.
- */
-struct mmc_host *mmc_alloc_host(int extra, struct device *dev)
-{
-	struct mmc_host *host;
-
-	host = mmc_alloc_host_sysfs(extra, dev);
-	if (host) {
-		spin_lock_init(&host->lock);
-		init_waitqueue_head(&host->wq);
-		INIT_DELAYED_WORK(&host->detect, mmc_rescan);
-
-		/*
-		 * By default, hosts do not support SGIO or large requests.
-		 * They have to set these according to their abilities.
-		 */
-		host->max_hw_segs = 1;
-		host->max_phys_segs = 1;
-		host->max_seg_size = PAGE_CACHE_SIZE;
-
-		host->max_req_size = PAGE_CACHE_SIZE;
-		host->max_blk_size = 512;
-		host->max_blk_count = PAGE_CACHE_SIZE / 512;
-	}
-
-	return host;
-}
-
-EXPORT_SYMBOL(mmc_alloc_host);
-
-/**
- *	mmc_add_host - initialise host hardware
- *	@host: mmc host
- */
-int mmc_add_host(struct mmc_host *host)
+void mmc_start_host(struct mmc_host *host)
 {
-	int ret;
-
-	ret = mmc_add_host_sysfs(host);
-	if (ret == 0) {
-		mmc_power_off(host);
-		mmc_detect_change(host, 0);
-	}
-
-	return ret;
+	mmc_power_off(host);
+	mmc_detect_change(host, 0);
 }
 
-EXPORT_SYMBOL(mmc_add_host);
-
-/**
- *	mmc_remove_host - remove host hardware
- *	@host: mmc host
- *
- *	Unregister and remove all cards associated with this host,
- *	and power down the MMC bus.
- */
-void mmc_remove_host(struct mmc_host *host)
+void mmc_stop_host(struct mmc_host *host)
 {
 #ifdef CONFIG_MMC_DEBUG
 	unsigned long flags;
@@ -632,24 +576,8 @@ void mmc_remove_host(struct mmc_host *host)
 	BUG_ON(host->card);
 
 	mmc_power_off(host);
-	mmc_remove_host_sysfs(host);
 }
 
-EXPORT_SYMBOL(mmc_remove_host);
-
-/**
- *	mmc_free_host - free the host structure
- *	@host: mmc host
- *
- *	Free the host once all references to it have been dropped.
- */
-void mmc_free_host(struct mmc_host *host)
-{
-	mmc_free_host_sysfs(host);
-}
-
-EXPORT_SYMBOL(mmc_free_host);
-
 #ifdef CONFIG_PM
 
 /**

commit 4101c16a910b15afd190c6bc7d45864461cf5c25
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Sat May 19 13:39:01 2007 +0200

    mmc: refactor bus operations
    
    Move bus operations to its own file for the sake of clarity. Also
    delegate sysfs attributes to bus handlers in preparation for other
    more exotic types.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 7385acfa1dd9..d876adf4bd4e 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -368,22 +368,6 @@ void mmc_set_timing(struct mmc_host *host, unsigned int timing)
 	mmc_set_ios(host);
 }
 
-/*
- * Allocate a new MMC card
- */
-struct mmc_card *mmc_alloc_card(struct mmc_host *host)
-{
-	struct mmc_card *card;
-
-	card = kmalloc(sizeof(struct mmc_card), GFP_KERNEL);
-	if (!card)
-		return ERR_PTR(-ENOMEM);
-
-	mmc_init_card(card, host);
-
-	return card;
-}
-
 /*
  * Apply power to the MMC stack.  This is a two-stage process.
  * First, we enable power to the card without the clock running.

commit 01f41ec7b36e14da18a4e162ef697ae358f36e37
Author: Andrew Morton <akpm@linux-foundation.org>
Date:   Wed May 9 02:32:34 2007 -0700

    mmc build fix
    
    Cc: Pierre Ossman <drzeus@drzeus.cx>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index b6c16704aaab..7385acfa1dd9 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -501,9 +501,9 @@ void mmc_detect_change(struct mmc_host *host, unsigned long delay)
 {
 #ifdef CONFIG_MMC_DEBUG
 	unsigned long flags;
-	spin_lock_irqsave(host->lock, flags);
+	spin_lock_irqsave(&host->lock, flags);
 	BUG_ON(host->removed);
-	spin_unlock_irqrestore(host->lock, flags);
+	spin_unlock_irqrestore(&host->lock, flags);
 #endif
 
 	mmc_schedule_delayed_work(&host->detect, delay);

commit 1efd48b3ae8f89a1d04f1e36be96764d7bf43ae9
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Tue May 8 22:35:17 2007 +0200

    mmc: use lock instead of claim in debug check
    
    As mmc_detect_change() can be called from irq context, using
    claim (which can sleep) is inherently unsafe. Use the host
    spinlock instead, which also is faster.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 72c7cf4a9f9d..b6c16704aaab 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -500,9 +500,10 @@ void __mmc_release_bus(struct mmc_host *host)
 void mmc_detect_change(struct mmc_host *host, unsigned long delay)
 {
 #ifdef CONFIG_MMC_DEBUG
-	mmc_claim_host(host);
+	unsigned long flags;
+	spin_lock_irqsave(host->lock, flags);
 	BUG_ON(host->removed);
-	mmc_release_host(host);
+	spin_unlock_irqrestore(host->lock, flags);
 #endif
 
 	mmc_schedule_delayed_work(&host->detect, delay);
@@ -625,9 +626,10 @@ EXPORT_SYMBOL(mmc_add_host);
 void mmc_remove_host(struct mmc_host *host)
 {
 #ifdef CONFIG_MMC_DEBUG
-	mmc_claim_host(host);
+	unsigned long flags;
+	spin_lock_irqsave(&host->lock, flags);
 	host->removed = 1;
-	mmc_release_host(host);
+	spin_unlock_irqrestore(&host->lock, flags);
 #endif
 
 	mmc_flush_scheduled_work();

commit 6abaa0c9fec563538f2a28a682af8c89bb9b125c
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Tue May 1 16:00:02 2007 +0200

    mmc: support unsafe resume of cards
    
    Since many have the system root on MMC/SD we must allow some foot
    shooting when it comes to resume.
    
    We cannot detect if a card is removed and reinserted during suspend,
    so the safe approach would be to assume it was, avoiding potential
    filesystem corruption. This will of course not work if you cannot
    release the card before suspend.
    
    This commit adds a compile time option that makes the MMC layer
    assume the card wasn't touched if it is redetected upon resume.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 75333a2461df..72c7cf4a9f9d 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -677,14 +677,19 @@ int mmc_suspend_host(struct mmc_host *host, pm_message_t state)
 
 	mmc_bus_get(host);
 	if (host->bus_ops && !host->bus_dead) {
-		if (host->bus_ops->remove)
-			host->bus_ops->remove(host);
-		mmc_detach_bus(host);
+		if (host->bus_ops->suspend)
+			host->bus_ops->suspend(host);
+		if (!host->bus_ops->resume) {
+			if (host->bus_ops->remove)
+				host->bus_ops->remove(host);
+
+			mmc_claim_host(host);
+			mmc_detach_bus(host);
+			mmc_release_host(host);
+		}
 	}
 	mmc_bus_put(host);
 
-	BUG_ON(host->card);
-
 	mmc_power_off(host);
 
 	return 0;
@@ -698,7 +703,19 @@ EXPORT_SYMBOL(mmc_suspend_host);
  */
 int mmc_resume_host(struct mmc_host *host)
 {
-	mmc_rescan(&host->detect.work);
+	mmc_bus_get(host);
+	if (host->bus_ops && !host->bus_dead) {
+		mmc_power_up(host);
+		BUG_ON(!host->bus_ops->resume);
+		host->bus_ops->resume(host);
+	}
+	mmc_bus_put(host);
+
+	/*
+	 * We add a slight delay here so that resume can progress
+	 * in parallel.
+	 */
+	mmc_detect_change(host, 1);
 
 	return 0;
 }

commit 7ea239d9e6d6993469a6a8ca83ff23834dfc3fce
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Sun Dec 31 00:11:32 2006 +0100

    mmc: add bus handler
    
    Delegate protocol handling to "bus handlers". This allows the core to
    just handle the task of arbitrating the bus. Initialisation and
    pampering of cards is now done by the different bus handlers.
    
    This design also allows MMC and SD (and later SDIO) to be more cleanly
    separated, allowing easier maintenance.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 310be2fe1944..75333a2461df 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -32,36 +32,8 @@
 #include "mmc_ops.h"
 #include "sd_ops.h"
 
-#define CMD_RETRIES	3
-
-/*
- * OCR Bit positions to 10s of Vdd mV.
- */
-static const unsigned short mmc_ocr_bit_to_vdd[] = {
-	150,	155,	160,	165,	170,	180,	190,	200,
-	210,	220,	230,	240,	250,	260,	270,	280,
-	290,	300,	310,	320,	330,	340,	350,	360
-};
-
-static const unsigned int tran_exp[] = {
-	10000,		100000,		1000000,	10000000,
-	0,		0,		0,		0
-};
-
-static const unsigned char tran_mant[] = {
-	0,	10,	12,	13,	15,	20,	25,	30,
-	35,	40,	45,	50,	55,	60,	70,	80,
-};
-
-static const unsigned int tacc_exp[] = {
-	1,	10,	100,	1000,	10000,	100000,	1000000, 10000000,
-};
-
-static const unsigned int tacc_mant[] = {
-	0,	10,	12,	13,	15,	20,	25,	30,
-	35,	40,	45,	50,	55,	60,	70,	80,
-};
-
+extern int mmc_attach_mmc(struct mmc_host *host, u32 ocr);
+extern int mmc_attach_sd(struct mmc_host *host, u32 ocr);
 
 /**
  *	mmc_request_done - finish processing an MMC request
@@ -303,6 +275,10 @@ void mmc_release_host(struct mmc_host *host)
 
 EXPORT_SYMBOL(mmc_release_host);
 
+/*
+ * Internal function that does the actual ios call to the host driver,
+ * optionally printing some debug output.
+ */
 static inline void mmc_set_ios(struct mmc_host *host)
 {
 	struct mmc_ios *ios = &host->ios;
@@ -316,17 +292,53 @@ static inline void mmc_set_ios(struct mmc_host *host)
 	host->ops->set_ios(host, ios);
 }
 
+/*
+ * Control chip select pin on a host.
+ */
 void mmc_set_chip_select(struct mmc_host *host, int mode)
 {
 	host->ios.chip_select = mode;
 	mmc_set_ios(host);
 }
 
+/*
+ * Sets the host clock to the highest possible frequency that
+ * is below "hz".
+ */
+void mmc_set_clock(struct mmc_host *host, unsigned int hz)
+{
+	WARN_ON(hz < host->f_min);
+
+	if (hz > host->f_max)
+		hz = host->f_max;
+
+	host->ios.clock = hz;
+	mmc_set_ios(host);
+}
+
+/*
+ * Change the bus mode (open drain/push-pull) of a host.
+ */
+void mmc_set_bus_mode(struct mmc_host *host, unsigned int mode)
+{
+	host->ios.bus_mode = mode;
+	mmc_set_ios(host);
+}
+
+/*
+ * Change data bus width of a host.
+ */
+void mmc_set_bus_width(struct mmc_host *host, unsigned int width)
+{
+	host->ios.bus_width = width;
+	mmc_set_ios(host);
+}
+
 /*
  * Mask off any voltages we don't support and select
  * the lowest voltage
  */
-static u32 mmc_select_voltage(struct mmc_host *host, u32 ocr)
+u32 mmc_select_voltage(struct mmc_host *host, u32 ocr)
 {
 	int bit;
 
@@ -347,235 +359,19 @@ static u32 mmc_select_voltage(struct mmc_host *host, u32 ocr)
 	return ocr;
 }
 
-#define UNSTUFF_BITS(resp,start,size)					\
-	({								\
-		const int __size = size;				\
-		const u32 __mask = (__size < 32 ? 1 << __size : 0) - 1;	\
-		const int __off = 3 - ((start) / 32);			\
-		const int __shft = (start) & 31;			\
-		u32 __res;						\
-									\
-		__res = resp[__off] >> __shft;				\
-		if (__size + __shft > 32)				\
-			__res |= resp[__off-1] << ((32 - __shft) % 32);	\
-		__res & __mask;						\
-	})
-
-/*
- * Given the decoded CSD structure, decode the raw CID to our CID structure.
- */
-static void mmc_decode_cid(struct mmc_card *card)
-{
-	u32 *resp = card->raw_cid;
-
-	memset(&card->cid, 0, sizeof(struct mmc_cid));
-
-	if (mmc_card_sd(card)) {
-		/*
-		 * SD doesn't currently have a version field so we will
-		 * have to assume we can parse this.
-		 */
-		card->cid.manfid		= UNSTUFF_BITS(resp, 120, 8);
-		card->cid.oemid			= UNSTUFF_BITS(resp, 104, 16);
-		card->cid.prod_name[0]		= UNSTUFF_BITS(resp, 96, 8);
-		card->cid.prod_name[1]		= UNSTUFF_BITS(resp, 88, 8);
-		card->cid.prod_name[2]		= UNSTUFF_BITS(resp, 80, 8);
-		card->cid.prod_name[3]		= UNSTUFF_BITS(resp, 72, 8);
-		card->cid.prod_name[4]		= UNSTUFF_BITS(resp, 64, 8);
-		card->cid.hwrev			= UNSTUFF_BITS(resp, 60, 4);
-		card->cid.fwrev			= UNSTUFF_BITS(resp, 56, 4);
-		card->cid.serial		= UNSTUFF_BITS(resp, 24, 32);
-		card->cid.year			= UNSTUFF_BITS(resp, 12, 8);
-		card->cid.month			= UNSTUFF_BITS(resp, 8, 4);
-
-		card->cid.year += 2000; /* SD cards year offset */
-	} else {
-		/*
-		 * The selection of the format here is based upon published
-		 * specs from sandisk and from what people have reported.
-		 */
-		switch (card->csd.mmca_vsn) {
-		case 0: /* MMC v1.0 - v1.2 */
-		case 1: /* MMC v1.4 */
-			card->cid.manfid	= UNSTUFF_BITS(resp, 104, 24);
-			card->cid.prod_name[0]	= UNSTUFF_BITS(resp, 96, 8);
-			card->cid.prod_name[1]	= UNSTUFF_BITS(resp, 88, 8);
-			card->cid.prod_name[2]	= UNSTUFF_BITS(resp, 80, 8);
-			card->cid.prod_name[3]	= UNSTUFF_BITS(resp, 72, 8);
-			card->cid.prod_name[4]	= UNSTUFF_BITS(resp, 64, 8);
-			card->cid.prod_name[5]	= UNSTUFF_BITS(resp, 56, 8);
-			card->cid.prod_name[6]	= UNSTUFF_BITS(resp, 48, 8);
-			card->cid.hwrev		= UNSTUFF_BITS(resp, 44, 4);
-			card->cid.fwrev		= UNSTUFF_BITS(resp, 40, 4);
-			card->cid.serial	= UNSTUFF_BITS(resp, 16, 24);
-			card->cid.month		= UNSTUFF_BITS(resp, 12, 4);
-			card->cid.year		= UNSTUFF_BITS(resp, 8, 4) + 1997;
-			break;
-
-		case 2: /* MMC v2.0 - v2.2 */
-		case 3: /* MMC v3.1 - v3.3 */
-		case 4: /* MMC v4 */
-			card->cid.manfid	= UNSTUFF_BITS(resp, 120, 8);
-			card->cid.oemid		= UNSTUFF_BITS(resp, 104, 16);
-			card->cid.prod_name[0]	= UNSTUFF_BITS(resp, 96, 8);
-			card->cid.prod_name[1]	= UNSTUFF_BITS(resp, 88, 8);
-			card->cid.prod_name[2]	= UNSTUFF_BITS(resp, 80, 8);
-			card->cid.prod_name[3]	= UNSTUFF_BITS(resp, 72, 8);
-			card->cid.prod_name[4]	= UNSTUFF_BITS(resp, 64, 8);
-			card->cid.prod_name[5]	= UNSTUFF_BITS(resp, 56, 8);
-			card->cid.serial	= UNSTUFF_BITS(resp, 16, 32);
-			card->cid.month		= UNSTUFF_BITS(resp, 12, 4);
-			card->cid.year		= UNSTUFF_BITS(resp, 8, 4) + 1997;
-			break;
-
-		default:
-			printk("%s: card has unknown MMCA version %d\n",
-				mmc_hostname(card->host), card->csd.mmca_vsn);
-			mmc_card_set_bad(card);
-			break;
-		}
-	}
-}
-
-/*
- * Given a 128-bit response, decode to our card CSD structure.
- */
-static void mmc_decode_csd(struct mmc_card *card)
-{
-	struct mmc_csd *csd = &card->csd;
-	unsigned int e, m, csd_struct;
-	u32 *resp = card->raw_csd;
-
-	if (mmc_card_sd(card)) {
-		csd_struct = UNSTUFF_BITS(resp, 126, 2);
-
-		switch (csd_struct) {
-		case 0:
-			m = UNSTUFF_BITS(resp, 115, 4);
-			e = UNSTUFF_BITS(resp, 112, 3);
-			csd->tacc_ns	 = (tacc_exp[e] * tacc_mant[m] + 9) / 10;
-			csd->tacc_clks	 = UNSTUFF_BITS(resp, 104, 8) * 100;
-
-			m = UNSTUFF_BITS(resp, 99, 4);
-			e = UNSTUFF_BITS(resp, 96, 3);
-			csd->max_dtr	  = tran_exp[e] * tran_mant[m];
-			csd->cmdclass	  = UNSTUFF_BITS(resp, 84, 12);
-
-			e = UNSTUFF_BITS(resp, 47, 3);
-			m = UNSTUFF_BITS(resp, 62, 12);
-			csd->capacity	  = (1 + m) << (e + 2);
-
-			csd->read_blkbits = UNSTUFF_BITS(resp, 80, 4);
-			csd->read_partial = UNSTUFF_BITS(resp, 79, 1);
-			csd->write_misalign = UNSTUFF_BITS(resp, 78, 1);
-			csd->read_misalign = UNSTUFF_BITS(resp, 77, 1);
-			csd->r2w_factor = UNSTUFF_BITS(resp, 26, 3);
-			csd->write_blkbits = UNSTUFF_BITS(resp, 22, 4);
-			csd->write_partial = UNSTUFF_BITS(resp, 21, 1);
-			break;
-		case 1:
-			/*
-			 * This is a block-addressed SDHC card. Most
-			 * interesting fields are unused and have fixed
-			 * values. To avoid getting tripped by buggy cards,
-			 * we assume those fixed values ourselves.
-			 */
-			mmc_card_set_blockaddr(card);
-
-			csd->tacc_ns	 = 0; /* Unused */
-			csd->tacc_clks	 = 0; /* Unused */
-
-			m = UNSTUFF_BITS(resp, 99, 4);
-			e = UNSTUFF_BITS(resp, 96, 3);
-			csd->max_dtr	  = tran_exp[e] * tran_mant[m];
-			csd->cmdclass	  = UNSTUFF_BITS(resp, 84, 12);
-
-			m = UNSTUFF_BITS(resp, 48, 22);
-			csd->capacity     = (1 + m) << 10;
-
-			csd->read_blkbits = 9;
-			csd->read_partial = 0;
-			csd->write_misalign = 0;
-			csd->read_misalign = 0;
-			csd->r2w_factor = 4; /* Unused */
-			csd->write_blkbits = 9;
-			csd->write_partial = 0;
-			break;
-		default:
-			printk("%s: unrecognised CSD structure version %d\n",
-				mmc_hostname(card->host), csd_struct);
-			mmc_card_set_bad(card);
-			return;
-		}
-	} else {
-		/*
-		 * We only understand CSD structure v1.1 and v1.2.
-		 * v1.2 has extra information in bits 15, 11 and 10.
-		 */
-		csd_struct = UNSTUFF_BITS(resp, 126, 2);
-		if (csd_struct != 1 && csd_struct != 2) {
-			printk("%s: unrecognised CSD structure version %d\n",
-				mmc_hostname(card->host), csd_struct);
-			mmc_card_set_bad(card);
-			return;
-		}
-
-		csd->mmca_vsn	 = UNSTUFF_BITS(resp, 122, 4);
-		m = UNSTUFF_BITS(resp, 115, 4);
-		e = UNSTUFF_BITS(resp, 112, 3);
-		csd->tacc_ns	 = (tacc_exp[e] * tacc_mant[m] + 9) / 10;
-		csd->tacc_clks	 = UNSTUFF_BITS(resp, 104, 8) * 100;
-
-		m = UNSTUFF_BITS(resp, 99, 4);
-		e = UNSTUFF_BITS(resp, 96, 3);
-		csd->max_dtr	  = tran_exp[e] * tran_mant[m];
-		csd->cmdclass	  = UNSTUFF_BITS(resp, 84, 12);
-
-		e = UNSTUFF_BITS(resp, 47, 3);
-		m = UNSTUFF_BITS(resp, 62, 12);
-		csd->capacity	  = (1 + m) << (e + 2);
-
-		csd->read_blkbits = UNSTUFF_BITS(resp, 80, 4);
-		csd->read_partial = UNSTUFF_BITS(resp, 79, 1);
-		csd->write_misalign = UNSTUFF_BITS(resp, 78, 1);
-		csd->read_misalign = UNSTUFF_BITS(resp, 77, 1);
-		csd->r2w_factor = UNSTUFF_BITS(resp, 26, 3);
-		csd->write_blkbits = UNSTUFF_BITS(resp, 22, 4);
-		csd->write_partial = UNSTUFF_BITS(resp, 21, 1);
-	}
-}
-
 /*
- * Given a 64-bit response, decode to our card SCR structure.
+ * Select timing parameters for host.
  */
-static void mmc_decode_scr(struct mmc_card *card)
+void mmc_set_timing(struct mmc_host *host, unsigned int timing)
 {
-	struct sd_scr *scr = &card->scr;
-	unsigned int scr_struct;
-	u32 resp[4];
-
-	BUG_ON(!mmc_card_sd(card));
-
-	resp[3] = card->raw_scr[1];
-	resp[2] = card->raw_scr[0];
-
-	scr_struct = UNSTUFF_BITS(resp, 60, 4);
-	if (scr_struct != 0) {
-		printk("%s: unrecognised SCR structure version %d\n",
-			mmc_hostname(card->host), scr_struct);
-		mmc_card_set_bad(card);
-		return;
-	}
-
-	scr->sda_vsn = UNSTUFF_BITS(resp, 56, 4);
-	scr->bus_widths = UNSTUFF_BITS(resp, 48, 4);
+	host->ios.timing = timing;
+	mmc_set_ios(host);
 }
 
 /*
  * Allocate a new MMC card
  */
-static struct mmc_card *
-mmc_alloc_card(struct mmc_host *host, u32 *raw_cid)
+struct mmc_card *mmc_alloc_card(struct mmc_host *host)
 {
 	struct mmc_card *card;
 
@@ -584,7 +380,6 @@ mmc_alloc_card(struct mmc_host *host, u32 *raw_cid)
 		return ERR_PTR(-ENOMEM);
 
 	mmc_init_card(card, host);
-	memcpy(card->raw_cid, raw_cid, sizeof(card->raw_cid));
 
 	return card;
 }
@@ -634,406 +429,66 @@ static void mmc_power_off(struct mmc_host *host)
 }
 
 /*
- * Discover the card by requesting its CID.
- *
- * Create a mmc_card entry for the discovered card, assigning
- * it an RCA, and save the raw CID for decoding later.
+ * Assign a mmc bus handler to a host. Only one bus handler may control a
+ * host at any given time.
  */
-static void mmc_discover_card(struct mmc_host *host)
+void mmc_attach_bus(struct mmc_host *host, const struct mmc_bus_ops *ops)
 {
-	unsigned int err;
-	u32 cid[4];
-
-	BUG_ON(host->card);
-
-	err = mmc_all_send_cid(host, cid);
-	if (err != MMC_ERR_NONE) {
-		printk(KERN_ERR "%s: error requesting CID: %d\n",
-			mmc_hostname(host), err);
-		return;
-	}
-
-	host->card = mmc_alloc_card(host, cid);
-	if (IS_ERR(host->card)) {
-		err = PTR_ERR(host->card);
-		host->card = NULL;
-		return;
-	}
-
-	if (host->mode == MMC_MODE_SD) {
-		host->card->type = MMC_TYPE_SD;
-
-		err = mmc_send_relative_addr(host, &host->card->rca);
-		if (err != MMC_ERR_NONE)
-			mmc_card_set_dead(host->card);
-		else {
-			if (!host->ops->get_ro) {
-				printk(KERN_WARNING "%s: host does not "
-					"support reading read-only "
-					"switch. assuming write-enable.\n",
-					mmc_hostname(host));
-			} else {
-				if (host->ops->get_ro(host))
-					mmc_card_set_readonly(host->card);
-			}
-		}
-	} else {
-		host->card->type = MMC_TYPE_MMC;
-		host->card->rca = 1;
-
-		err = mmc_set_relative_addr(host->card);
-		if (err != MMC_ERR_NONE)
-			mmc_card_set_dead(host->card);
-	}
-}
-
-static void mmc_read_csd(struct mmc_host *host)
-{
-	int err;
-
-	if (!host->card)
-		return;
-	if (mmc_card_dead(host->card))
-		return;
-
-	err = mmc_send_csd(host->card, host->card->raw_csd);
-	if (err != MMC_ERR_NONE) {
-		mmc_card_set_dead(host->card);
-		return;
-	}
-
-	mmc_decode_csd(host->card);
-	mmc_decode_cid(host->card);
-}
-
-static void mmc_process_ext_csd(struct mmc_host *host)
-{
-	int err;
-	u8 *ext_csd;
-
-	if (!host->card)
-		return;
-	if (mmc_card_dead(host->card))
-		return;
-	if (mmc_card_sd(host->card))
-		return;
-	if (host->card->csd.mmca_vsn < CSD_SPEC_VER_4)
-		return;
-
-	/*
-	 * As the ext_csd is so large and mostly unused, we don't store the
-	 * raw block in mmc_card.
-	 */
-	ext_csd = kmalloc(512, GFP_KERNEL);
-	if (!ext_csd) {
-		printk("%s: could not allocate a buffer to receive the ext_csd."
-		       "mmc v4 cards will be treated as v3.\n",
-			mmc_hostname(host));
-		return;
-	}
-
-	err = mmc_send_ext_csd(host->card, ext_csd);
-	if (err != MMC_ERR_NONE) {
-		if (host->card->csd.capacity == (4096 * 512)) {
-			printk(KERN_ERR "%s: unable to read EXT_CSD "
-				"on a possible high capacity card. "
-				"Card will be ignored.\n",
-				mmc_hostname(host));
-			mmc_card_set_dead(host->card);
-		} else {
-			printk(KERN_WARNING "%s: unable to read "
-				"EXT_CSD, performance might "
-				"suffer.\n",
-				mmc_hostname(host));
-		}
-		goto out;
-	}
-
-	host->card->ext_csd.sectors =
-		ext_csd[EXT_CSD_SEC_CNT + 0] << 0 |
-		ext_csd[EXT_CSD_SEC_CNT + 1] << 8 |
-		ext_csd[EXT_CSD_SEC_CNT + 2] << 16 |
-		ext_csd[EXT_CSD_SEC_CNT + 3] << 24;
-	if (host->card->ext_csd.sectors)
-		mmc_card_set_blockaddr(host->card);
-
-	switch (ext_csd[EXT_CSD_CARD_TYPE]) {
-	case EXT_CSD_CARD_TYPE_52 | EXT_CSD_CARD_TYPE_26:
-		host->card->ext_csd.hs_max_dtr = 52000000;
-		break;
-	case EXT_CSD_CARD_TYPE_26:
-		host->card->ext_csd.hs_max_dtr = 26000000;
-		break;
-	default:
-		/* MMC v4 spec says this cannot happen */
-		printk("%s: card is mmc v4 but doesn't support "
-		       "any high-speed modes.\n",
-			mmc_hostname(host));
-		goto out;
-	}
-
-	if (host->caps & MMC_CAP_MMC_HIGHSPEED) {
-		/* Activate highspeed support. */
-		err = mmc_switch(host->card, MMC_SWITCH_MODE_WRITE_BYTE,
-			EXT_CSD_HS_TIMING, 1);
-		if (err != MMC_ERR_NONE) {
-			printk("%s: failed to switch card to mmc v4 "
-			       "high-speed mode.\n",
-			       mmc_hostname(host));
-			goto out;
-		}
-
-		mmc_card_set_highspeed(host->card);
-
-		host->ios.timing = MMC_TIMING_MMC_HS;
-		mmc_set_ios(host);
-	}
+	unsigned long flags;
 
-	/* Check for host support for wide-bus modes. */
-	if (host->caps & MMC_CAP_4_BIT_DATA) {
-		/* Activate 4-bit support. */
-		err = mmc_switch(host->card, MMC_SWITCH_MODE_WRITE_BYTE,
-			EXT_CSD_BUS_WIDTH, EXT_CSD_BUS_WIDTH_4 |
-			EXT_CSD_CMD_SET_NORMAL);
-		if (err != MMC_ERR_NONE) {
-			printk("%s: failed to switch card to "
-			       "mmc v4 4-bit bus mode.\n",
-			       mmc_hostname(host));
-			goto out;
-		}
+	BUG_ON(!host);
+	BUG_ON(!ops);
 
-		host->ios.bus_width = MMC_BUS_WIDTH_4;
-		mmc_set_ios(host);
-	}
+	BUG_ON(!host->claimed);
 
-out:
-	kfree(ext_csd);
-}
+	spin_lock_irqsave(&host->lock, flags);
 
-static void mmc_read_scr(struct mmc_host *host)
-{
-	int err;
+	BUG_ON(host->bus_ops);
+	BUG_ON(host->bus_refs);
 
-	if (!host->card)
-		return;
-	if (mmc_card_dead(host->card))
-		return;
-	if (!mmc_card_sd(host->card))
-		return;
-
-	err = mmc_app_send_scr(host->card, host->card->raw_scr);
-	if (err != MMC_ERR_NONE) {
-		mmc_card_set_dead(host->card);
-		return;
-	}
+	host->bus_ops = ops;
+	host->bus_refs = 1;
+	host->bus_dead = 0;
 
-	mmc_decode_scr(host->card);
+	spin_unlock_irqrestore(&host->lock, flags);
 }
 
-static void mmc_read_switch_caps(struct mmc_host *host)
+/*
+ * Remove the current bus handler from a host. Assumes that there are
+ * no interesting cards left, so the bus is powered down.
+ */
+void mmc_detach_bus(struct mmc_host *host)
 {
-	int err;
-	unsigned char *status;
-
-	if (!(host->caps & MMC_CAP_SD_HIGHSPEED))
-		return;
-
-	if (!host->card)
-		return;
-	if (mmc_card_dead(host->card))
-		return;
-	if (!mmc_card_sd(host->card))
-		return;
-	if (host->card->scr.sda_vsn < SCR_SPEC_VER_1)
-		return;
-
-	status = kmalloc(64, GFP_KERNEL);
-	if (!status) {
-		printk(KERN_WARNING "%s: Unable to allocate buffer for "
-			"reading switch capabilities.\n",
-			mmc_hostname(host));
-		return;
-	}
-
-	err = mmc_sd_switch(host->card, SD_SWITCH_CHECK,
-		SD_SWITCH_GRP_ACCESS, SD_SWITCH_ACCESS_HS, status);
-	if (err != MMC_ERR_NONE) {
-		printk("%s: unable to read switch capabilities, "
-			"performance might suffer.\n",
-			mmc_hostname(host));
-		goto out;
-	}
-
-	if (status[13] & 0x02)
-		host->card->sw_caps.hs_max_dtr = 50000000;
+	unsigned long flags;
 
-	err = mmc_sd_switch(host->card, SD_SWITCH_SET,
-		SD_SWITCH_GRP_ACCESS, SD_SWITCH_ACCESS_HS, status);
-	if (err != MMC_ERR_NONE || (status[16] & 0xF) != 1) {
-		printk(KERN_WARNING "%s: Problem switching card "
-			"into high-speed mode!\n",
-			mmc_hostname(host));
-		goto out;
-	}
+	BUG_ON(!host);
 
-	mmc_card_set_highspeed(host->card);
+	BUG_ON(!host->claimed);
+	BUG_ON(!host->bus_ops);
 
-	host->ios.timing = MMC_TIMING_SD_HS;
-	mmc_set_ios(host);
+	spin_lock_irqsave(&host->lock, flags);
 
-out:
-	kfree(status);
-}
+	host->bus_dead = 1;
 
-static unsigned int mmc_calculate_clock(struct mmc_host *host)
-{
-	unsigned int max_dtr = host->f_max;
-
-	if (host->card && !mmc_card_dead(host->card)) {
-		if (mmc_card_highspeed(host->card) && mmc_card_sd(host->card)) {
-			if (max_dtr > host->card->sw_caps.hs_max_dtr)
-				max_dtr = host->card->sw_caps.hs_max_dtr;
-		} else if (mmc_card_highspeed(host->card) && !mmc_card_sd(host->card)) {
-			if (max_dtr > host->card->ext_csd.hs_max_dtr)
-				max_dtr = host->card->ext_csd.hs_max_dtr;
-		} else if (max_dtr > host->card->csd.max_dtr) {
-			max_dtr = host->card->csd.max_dtr;
-		}
-	}
+	spin_unlock_irqrestore(&host->lock, flags);
 
-	pr_debug("%s: selected %d.%03dMHz transfer rate\n",
-		 mmc_hostname(host),
-		 max_dtr / 1000000, (max_dtr / 1000) % 1000);
+	mmc_power_off(host);
 
-	return max_dtr;
+	mmc_bus_put(host);
 }
 
 /*
- * Check whether cards we already know about are still present.
- * We do this by requesting status, and checking whether a card
- * responds.
- *
- * A request for status does not cause a state change in data
- * transfer mode.
+ * Cleanup when the last reference to the bus operator is dropped.
  */
-static void mmc_check_card(struct mmc_card *card)
+void __mmc_release_bus(struct mmc_host *host)
 {
-	int err;
-
-	BUG_ON(!card);
+	BUG_ON(!host);
+	BUG_ON(host->bus_refs);
+	BUG_ON(!host->bus_dead);
 
-	err = mmc_send_status(card, NULL);
-	if (err == MMC_ERR_NONE)
-		return;
-
-	mmc_card_set_dead(card);
+	host->bus_ops = NULL;
 }
 
-static void mmc_setup(struct mmc_host *host)
-{
-	int err;
-	u32 ocr;
-
-	host->mode = MMC_MODE_SD;
-
-	mmc_power_up(host);
-	mmc_go_idle(host);
-
-	err = mmc_send_if_cond(host, host->ocr_avail);
-	if (err != MMC_ERR_NONE) {
-		return;
-	}
-	err = mmc_send_app_op_cond(host, 0, &ocr);
-
-	/*
-	 * If we fail to detect any SD cards then try
-	 * searching for MMC cards.
-	 */
-	if (err != MMC_ERR_NONE) {
-		host->mode = MMC_MODE_MMC;
-
-		err = mmc_send_op_cond(host, 0, &ocr);
-		if (err != MMC_ERR_NONE)
-			return;
-	}
-
-	host->ocr = mmc_select_voltage(host, ocr);
-
-	if (host->ocr == 0)
-		return;
-
-	/*
-	 * Since we're changing the OCR value, we seem to
-	 * need to tell some cards to go back to the idle
-	 * state.  We wait 1ms to give cards time to
-	 * respond.
-	 */
-	mmc_go_idle(host);
-
-	/*
-	 * Send the selected OCR multiple times... until the cards
-	 * all get the idea that they should be ready for CMD2.
-	 * (My SanDisk card seems to need this.)
-	 */
-	if (host->mode == MMC_MODE_SD) {
-		/*
-		 * If SD_SEND_IF_COND indicates an SD 2.0
-		 * compliant card and we should set bit 30
-		 * of the ocr to indicate that we can handle
-		 * block-addressed SDHC cards.
-		 */
-		err = mmc_send_if_cond(host, host->ocr);
-		if (err == MMC_ERR_NONE)
-			ocr = host->ocr | (1 << 30);
-
-		mmc_send_app_op_cond(host, ocr, NULL);
-	} else {
-		/* The extra bit indicates that we support high capacity */
-		mmc_send_op_cond(host, host->ocr | (1 << 30), NULL);
-	}
-
-	mmc_discover_card(host);
-
-	/*
-	 * Ok, now switch to push-pull mode.
-	 */
-	host->ios.bus_mode = MMC_BUSMODE_PUSHPULL;
-	mmc_set_ios(host);
-
-	mmc_read_csd(host);
-
-	if (host->card && !mmc_card_dead(host->card)) {
-		err = mmc_select_card(host->card);
-		if (err != MMC_ERR_NONE)
-			mmc_card_set_dead(host->card);
-	}
-
-	/*
-	 * The card is in 1 bit mode by default so
-	 * we only need to change if it supports the
-	 * wider version.
-	 */
-	if (host->card && !mmc_card_dead(host->card) && 
-		mmc_card_sd(host->card) &&
-		(host->card->scr.bus_widths & SD_SCR_BUS_WIDTH_4) &&
-		(host->card->host->caps & MMC_CAP_4_BIT_DATA)) {
-		err = mmc_app_set_bus_width(host->card, SD_BUS_WIDTH_4);
-		if (err != MMC_ERR_NONE)
-			mmc_card_set_dead(host->card);
-		else {
-			host->ios.bus_width = MMC_BUS_WIDTH_4;
-			mmc_set_ios(host);
-		}
-	}
-
-	if (host->mode == MMC_MODE_SD) {
-		mmc_read_scr(host);
-		mmc_read_switch_caps(host);
-	} else
-		mmc_process_ext_csd(host);
-}
-
-
 /**
  *	mmc_detect_change - process change of state on a MMC socket
  *	@host: host which changed state.
@@ -1060,62 +515,49 @@ static void mmc_rescan(struct work_struct *work)
 {
 	struct mmc_host *host =
 		container_of(work, struct mmc_host, detect.work);
+	u32 ocr;
+	int err;
 
-	mmc_claim_host(host);
-
-	/*
-	 * Check for removed card and newly inserted ones. We check for
-	 * removed cards first so we can intelligently re-select the VDD.
-	 */
-	if (host->card) {
-		mmc_check_card(host->card);
-
-		mmc_release_host(host);
-
-		if (mmc_card_dead(host->card)) {
-			mmc_remove_card(host->card);
-			host->card = NULL;
-		}
-
-		goto out;
-	}
-
-	mmc_setup(host);
+	mmc_bus_get(host);
 
-	if (host->card && !mmc_card_dead(host->card)) {
+	if (host->bus_ops == NULL) {
 		/*
-		 * (Re-)calculate the fastest clock rate which the
-		 * attached cards and the host support.
+		 * Only we can add a new handler, so it's safe to
+		 * release the lock here.
 		 */
-		host->ios.clock = mmc_calculate_clock(host);
-		mmc_set_ios(host);
-	}
+		mmc_bus_put(host);
 
-	mmc_release_host(host);
+		mmc_claim_host(host);
 
-	/*
-	 * If this is a new and good card, register it.
-	 */
-	if (host->card && !mmc_card_dead(host->card)) {
-		if (mmc_register_card(host->card))
-			mmc_card_set_dead(host->card);
-	}
+		mmc_power_up(host);
+		mmc_go_idle(host);
 
-	/*
-	 * If this card is dead, destroy it.
-	 */
-	if (host->card && mmc_card_dead(host->card)) {
-		mmc_remove_card(host->card);
-		host->card = NULL;
-	}
+		mmc_send_if_cond(host, host->ocr_avail);
 
-out:
-	/*
-	 * If we discover that there are no cards on the
-	 * bus, turn off the clock and power down.
-	 */
-	if (!host->card)
-		mmc_power_off(host);
+		err = mmc_send_app_op_cond(host, 0, &ocr);
+		if (err == MMC_ERR_NONE) {
+			if (mmc_attach_sd(host, ocr))
+				mmc_power_off(host);
+		} else {
+			/*
+			 * If we fail to detect any SD cards then try
+			 * searching for MMC cards.
+			 */
+			err = mmc_send_op_cond(host, 0, &ocr);
+			if (err == MMC_ERR_NONE) {
+				if (mmc_attach_mmc(host, ocr))
+					mmc_power_off(host);
+			} else {
+				mmc_power_off(host);
+				mmc_release_host(host);
+			}
+		}
+	} else {
+		if (host->bus_ops->detect && !host->bus_dead)
+			host->bus_ops->detect(host);
+
+		mmc_bus_put(host);
+	}
 }
 
 
@@ -1190,10 +632,18 @@ void mmc_remove_host(struct mmc_host *host)
 
 	mmc_flush_scheduled_work();
 
-	if (host->card) {
-		mmc_remove_card(host->card);
-		host->card = NULL;
+	mmc_bus_get(host);
+	if (host->bus_ops && !host->bus_dead) {
+		if (host->bus_ops->remove)
+			host->bus_ops->remove(host);
+
+		mmc_claim_host(host);
+		mmc_detach_bus(host);
+		mmc_release_host(host);
 	}
+	mmc_bus_put(host);
+
+	BUG_ON(host->card);
 
 	mmc_power_off(host);
 	mmc_remove_host_sysfs(host);
@@ -1225,10 +675,15 @@ int mmc_suspend_host(struct mmc_host *host, pm_message_t state)
 {
 	mmc_flush_scheduled_work();
 
-	if (host->card) {
-		mmc_remove_card(host->card);
-		host->card = NULL;
+	mmc_bus_get(host);
+	if (host->bus_ops && !host->bus_dead) {
+		if (host->bus_ops->remove)
+			host->bus_ops->remove(host);
+		mmc_detach_bus(host);
 	}
+	mmc_bus_put(host);
+
+	BUG_ON(host->card);
 
 	mmc_power_off(host);
 

commit da7fbe58d2d347e95af699ddf04d885be6362bbe
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Sun Dec 24 22:46:55 2006 +0100

    mmc: Separate out protocol ops
    
    Move protocol operations and definitions into their own files
    in an effort to separate protocol handling and bus
    arbitration more clearly.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 334e663e465b..310be2fe1944 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -23,9 +23,14 @@
 
 #include <linux/mmc/card.h>
 #include <linux/mmc/host.h>
-#include <linux/mmc/protocol.h>
+#include <linux/mmc/mmc.h>
+#include <linux/mmc/sd.h>
 
 #include "core.h"
+#include "sysfs.h"
+
+#include "mmc_ops.h"
+#include "sd_ops.h"
 
 #define CMD_RETRIES	3
 
@@ -190,80 +195,6 @@ int mmc_wait_for_cmd(struct mmc_host *host, struct mmc_command *cmd, int retries
 
 EXPORT_SYMBOL(mmc_wait_for_cmd);
 
-/**
- *	mmc_wait_for_app_cmd - start an application command and wait for
- 			       completion
- *	@host: MMC host to start command
- *	@rca: RCA to send MMC_APP_CMD to
- *	@cmd: MMC command to start
- *	@retries: maximum number of retries
- *
- *	Sends a MMC_APP_CMD, checks the card response, sends the command
- *	in the parameter and waits for it to complete. Return any error
- *	that occurred while the command was executing.  Do not attempt to
- *	parse the response.
- */
-int mmc_wait_for_app_cmd(struct mmc_host *host, unsigned int rca,
-	struct mmc_command *cmd, int retries)
-{
-	struct mmc_request mrq;
-	struct mmc_command appcmd;
-
-	int i, err;
-
-	BUG_ON(!host->claimed);
-	BUG_ON(retries < 0);
-
-	err = MMC_ERR_INVALID;
-
-	/*
-	 * We have to resend MMC_APP_CMD for each attempt so
-	 * we cannot use the retries field in mmc_command.
-	 */
-	for (i = 0;i <= retries;i++) {
-		memset(&mrq, 0, sizeof(struct mmc_request));
-
-		appcmd.opcode = MMC_APP_CMD;
-		appcmd.arg = rca << 16;
-		appcmd.flags = MMC_RSP_R1 | MMC_CMD_AC;
-		appcmd.retries = 0;
-		memset(appcmd.resp, 0, sizeof(appcmd.resp));
-		appcmd.data = NULL;
-
-		mrq.cmd = &appcmd;
-		appcmd.data = NULL;
-
-		mmc_wait_for_req(host, &mrq);
-
-		if (appcmd.error) {
-			err = appcmd.error;
-			continue;
-		}
-
-		/* Check that card supported application commands */
-		if (!(appcmd.resp[0] & R1_APP_CMD))
-			return MMC_ERR_FAILED;
-
-		memset(&mrq, 0, sizeof(struct mmc_request));
-
-		memset(cmd->resp, 0, sizeof(cmd->resp));
-		cmd->retries = 0;
-
-		mrq.cmd = cmd;
-		cmd->data = NULL;
-
-		mmc_wait_for_req(host, &mrq);
-
-		err = cmd->error;
-		if (cmd->error == MMC_ERR_NONE)
-			break;
-	}
-
-	return err;
-}
-
-EXPORT_SYMBOL(mmc_wait_for_app_cmd);
-
 /**
  *	mmc_set_data_timeout - set the timeout for a data command
  *	@data: data phase for command
@@ -385,60 +316,10 @@ static inline void mmc_set_ios(struct mmc_host *host)
 	host->ops->set_ios(host, ios);
 }
 
-static int mmc_select_card(struct mmc_card *card)
-{
-	int err;
-	struct mmc_command cmd;
-
-	BUG_ON(!card->host->claimed);
-
-	cmd.opcode = MMC_SELECT_CARD;
-	cmd.arg = card->rca << 16;
-	cmd.flags = MMC_RSP_R1 | MMC_CMD_AC;
-
-	err = mmc_wait_for_cmd(card->host, &cmd, CMD_RETRIES);
-	if (err != MMC_ERR_NONE)
-		return err;
-
-	/*
-	 * We can only change the bus width of SD cards when
-	 * they are selected so we have to put the handling
-	 * here.
-	 *
-	 * The card is in 1 bit mode by default so
-	 * we only need to change if it supports the
-	 * wider version.
-	 */
-	if (mmc_card_sd(card) &&
-		(card->scr.bus_widths & SD_SCR_BUS_WIDTH_4) &&
-		(card->host->caps & MMC_CAP_4_BIT_DATA)) {
-
-		struct mmc_command cmd;
-		cmd.opcode = SD_APP_SET_BUS_WIDTH;
-		cmd.arg = SD_BUS_WIDTH_4;
-		cmd.flags = MMC_RSP_R1 | MMC_CMD_AC;
-
-		err = mmc_wait_for_app_cmd(card->host, card->rca,
-			&cmd, CMD_RETRIES);
-		if (err != MMC_ERR_NONE)
-			return err;
-
-		card->host->ios.bus_width = MMC_BUS_WIDTH_4;
-		mmc_set_ios(card->host);
-	}
-
-	return MMC_ERR_NONE;
-}
-
-
-static inline void mmc_delay(unsigned int ms)
+void mmc_set_chip_select(struct mmc_host *host, int mode)
 {
-	if (ms < 1000 / HZ) {
-		cond_resched();
-		mdelay(ms);
-	} else {
-		msleep(ms);
-	}
+	host->ios.chip_select = mode;
+	mmc_set_ios(host);
 }
 
 /*
@@ -708,32 +589,6 @@ mmc_alloc_card(struct mmc_host *host, u32 *raw_cid)
 	return card;
 }
 
-/*
- * Tell attached cards to go to IDLE state
- */
-static void mmc_idle_cards(struct mmc_host *host)
-{
-	struct mmc_command cmd;
-
-	host->ios.chip_select = MMC_CS_HIGH;
-	mmc_set_ios(host);
-
-	mmc_delay(1);
-
-	cmd.opcode = MMC_GO_IDLE_STATE;
-	cmd.arg = 0;
-	cmd.flags = MMC_RSP_NONE | MMC_CMD_BC;
-
-	mmc_wait_for_cmd(host, &cmd, 0);
-
-	mmc_delay(1);
-
-	host->ios.chip_select = MMC_CS_DONTCARE;
-	mmc_set_ios(host);
-
-	mmc_delay(1);
-}
-
 /*
  * Apply power to the MMC stack.  This is a two-stage process.
  * First, we enable power to the card without the clock running.
@@ -778,97 +633,6 @@ static void mmc_power_off(struct mmc_host *host)
 	mmc_set_ios(host);
 }
 
-static int mmc_send_op_cond(struct mmc_host *host, u32 ocr, u32 *rocr)
-{
-	struct mmc_command cmd;
-	int i, err = 0;
-
-	cmd.opcode = MMC_SEND_OP_COND;
-	cmd.arg = ocr;
-	cmd.flags = MMC_RSP_R3 | MMC_CMD_BCR;
-
-	for (i = 100; i; i--) {
-		err = mmc_wait_for_cmd(host, &cmd, 0);
-		if (err != MMC_ERR_NONE)
-			break;
-
-		if (cmd.resp[0] & MMC_CARD_BUSY || ocr == 0)
-			break;
-
-		err = MMC_ERR_TIMEOUT;
-
-		mmc_delay(10);
-	}
-
-	if (rocr)
-		*rocr = cmd.resp[0];
-
-	return err;
-}
-
-static int mmc_send_app_op_cond(struct mmc_host *host, u32 ocr, u32 *rocr)
-{
-	struct mmc_command cmd;
-	int i, err = 0;
-
-	cmd.opcode = SD_APP_OP_COND;
-	cmd.arg = ocr;
-	cmd.flags = MMC_RSP_R3 | MMC_CMD_BCR;
-
-	for (i = 100; i; i--) {
-		err = mmc_wait_for_app_cmd(host, 0, &cmd, CMD_RETRIES);
-		if (err != MMC_ERR_NONE)
-			break;
-
-		if (cmd.resp[0] & MMC_CARD_BUSY || ocr == 0)
-			break;
-
-		err = MMC_ERR_TIMEOUT;
-
-		mmc_delay(10);
-	}
-
-	if (rocr)
-		*rocr = cmd.resp[0];
-
-	return err;
-}
-
-static int mmc_send_if_cond(struct mmc_host *host, u32 ocr, int *rsd2)
-{
-	struct mmc_command cmd;
-	int err, sd2;
-	static const u8 test_pattern = 0xAA;
-
-	/*
-	* To support SD 2.0 cards, we must always invoke SD_SEND_IF_COND
-	* before SD_APP_OP_COND. This command will harmlessly fail for
-	* SD 1.0 cards.
-	*/
-	cmd.opcode = SD_SEND_IF_COND;
-	cmd.arg = ((ocr & 0xFF8000) != 0) << 8 | test_pattern;
-	cmd.flags = MMC_RSP_R7 | MMC_CMD_BCR;
-
-	err = mmc_wait_for_cmd(host, &cmd, 0);
-	if (err == MMC_ERR_NONE) {
-		if ((cmd.resp[0] & 0xFF) == test_pattern) {
-			sd2 = 1;
-		} else {
-			sd2 = 0;
-			err = MMC_ERR_FAILED;
-		}
-	} else {
-		/*
-		 * Treat errors as SD 1.0 card.
-		 */
-		sd2 = 0;
-		err = MMC_ERR_NONE;
-	}
-	if (rsd2)
-		*rsd2 = sd2;
-	return err;
-}
-
 /*
  * Discover the card by requesting its CID.
  *
@@ -878,27 +642,18 @@ static int mmc_send_if_cond(struct mmc_host *host, u32 ocr, int *rsd2)
 static void mmc_discover_card(struct mmc_host *host)
 {
 	unsigned int err;
-
-	struct mmc_command cmd;
+	u32 cid[4];
 
 	BUG_ON(host->card);
 
-	cmd.opcode = MMC_ALL_SEND_CID;
-	cmd.arg = 0;
-	cmd.flags = MMC_RSP_R2 | MMC_CMD_BCR;
-
-	err = mmc_wait_for_cmd(host, &cmd, CMD_RETRIES);
-	if (err == MMC_ERR_TIMEOUT) {
-		err = MMC_ERR_NONE;
-		return;
-	}
+	err = mmc_all_send_cid(host, cid);
 	if (err != MMC_ERR_NONE) {
 		printk(KERN_ERR "%s: error requesting CID: %d\n",
 			mmc_hostname(host), err);
 		return;
 	}
 
-	host->card = mmc_alloc_card(host, cmd.resp);
+	host->card = mmc_alloc_card(host, cid);
 	if (IS_ERR(host->card)) {
 		err = PTR_ERR(host->card);
 		host->card = NULL;
@@ -908,16 +663,10 @@ static void mmc_discover_card(struct mmc_host *host)
 	if (host->mode == MMC_MODE_SD) {
 		host->card->type = MMC_TYPE_SD;
 
-		cmd.opcode = SD_SEND_RELATIVE_ADDR;
-		cmd.arg = 0;
-		cmd.flags = MMC_RSP_R6 | MMC_CMD_BCR;
-
-		err = mmc_wait_for_cmd(host, &cmd, CMD_RETRIES);
+		err = mmc_send_relative_addr(host, &host->card->rca);
 		if (err != MMC_ERR_NONE)
 			mmc_card_set_dead(host->card);
 		else {
-			host->card->rca = cmd.resp[0] >> 16;
-
 			if (!host->ops->get_ro) {
 				printk(KERN_WARNING "%s: host does not "
 					"support reading read-only "
@@ -932,11 +681,7 @@ static void mmc_discover_card(struct mmc_host *host)
 		host->card->type = MMC_TYPE_MMC;
 		host->card->rca = 1;
 
-		cmd.opcode = MMC_SET_RELATIVE_ADDR;
-		cmd.arg = host->card->rca << 16;
-		cmd.flags = MMC_RSP_R1 | MMC_CMD_AC;
-
-		err = mmc_wait_for_cmd(host, &cmd, CMD_RETRIES);
+		err = mmc_set_relative_addr(host->card);
 		if (err != MMC_ERR_NONE)
 			mmc_card_set_dead(host->card);
 	}
@@ -944,7 +689,6 @@ static void mmc_discover_card(struct mmc_host *host)
 
 static void mmc_read_csd(struct mmc_host *host)
 {
-	struct mmc_command cmd;
 	int err;
 
 	if (!host->card)
@@ -952,18 +696,12 @@ static void mmc_read_csd(struct mmc_host *host)
 	if (mmc_card_dead(host->card))
 		return;
 
-	cmd.opcode = MMC_SEND_CSD;
-	cmd.arg = host->card->rca << 16;
-	cmd.flags = MMC_RSP_R2 | MMC_CMD_AC;
-
-	err = mmc_wait_for_cmd(host, &cmd, CMD_RETRIES);
+	err = mmc_send_csd(host->card, host->card->raw_csd);
 	if (err != MMC_ERR_NONE) {
 		mmc_card_set_dead(host->card);
 		return;
 	}
 
-	memcpy(host->card->raw_csd, cmd.resp, sizeof(host->card->raw_csd));
-
 	mmc_decode_csd(host->card);
 	mmc_decode_cid(host->card);
 }
@@ -971,13 +709,7 @@ static void mmc_read_csd(struct mmc_host *host)
 static void mmc_process_ext_csd(struct mmc_host *host)
 {
 	int err;
-
-	struct mmc_request mrq;
-	struct mmc_command cmd;
-	struct mmc_data data;
-
 	u8 *ext_csd;
-	struct scatterlist sg;
 
 	if (!host->card)
 		return;
@@ -1000,32 +732,8 @@ static void mmc_process_ext_csd(struct mmc_host *host)
 		return;
 	}
 
-	memset(&cmd, 0, sizeof(struct mmc_command));
-
-	cmd.opcode = MMC_SEND_EXT_CSD;
-	cmd.arg = 0;
-	cmd.flags = MMC_RSP_R1 | MMC_CMD_ADTC;
-
-	memset(&data, 0, sizeof(struct mmc_data));
-
-	mmc_set_data_timeout(&data, host->card, 0);
-
-	data.blksz = 512;
-	data.blocks = 1;
-	data.flags = MMC_DATA_READ;
-	data.sg = &sg;
-	data.sg_len = 1;
-
-	memset(&mrq, 0, sizeof(struct mmc_request));
-
-	mrq.cmd = &cmd;
-	mrq.data = &data;
-
-	sg_init_one(&sg, ext_csd, 512);
-
-	mmc_wait_for_req(host, &mrq);
-
-	if (cmd.error != MMC_ERR_NONE || data.error != MMC_ERR_NONE) {
+	err = mmc_send_ext_csd(host->card, ext_csd);
+	if (err != MMC_ERR_NONE) {
 		if (host->card->csd.capacity == (4096 * 512)) {
 			printk(KERN_ERR "%s: unable to read EXT_CSD "
 				"on a possible high capacity card. "
@@ -1066,14 +774,8 @@ static void mmc_process_ext_csd(struct mmc_host *host)
 
 	if (host->caps & MMC_CAP_MMC_HIGHSPEED) {
 		/* Activate highspeed support. */
-		cmd.opcode = MMC_SWITCH;
-		cmd.arg = (MMC_SWITCH_MODE_WRITE_BYTE << 24) |
-			  (EXT_CSD_HS_TIMING << 16) |
-			  (1 << 8) |
-			  EXT_CSD_CMD_SET_NORMAL;
-		cmd.flags = MMC_RSP_R1B | MMC_CMD_AC;
-
-		err = mmc_wait_for_cmd(host, &cmd, CMD_RETRIES);
+		err = mmc_switch(host->card, MMC_SWITCH_MODE_WRITE_BYTE,
+			EXT_CSD_HS_TIMING, 1);
 		if (err != MMC_ERR_NONE) {
 			printk("%s: failed to switch card to mmc v4 "
 			       "high-speed mode.\n",
@@ -1090,14 +792,9 @@ static void mmc_process_ext_csd(struct mmc_host *host)
 	/* Check for host support for wide-bus modes. */
 	if (host->caps & MMC_CAP_4_BIT_DATA) {
 		/* Activate 4-bit support. */
-		cmd.opcode = MMC_SWITCH;
-		cmd.arg = (MMC_SWITCH_MODE_WRITE_BYTE << 24) |
-			  (EXT_CSD_BUS_WIDTH << 16) |
-			  (EXT_CSD_BUS_WIDTH_4 << 8) |
-			  EXT_CSD_CMD_SET_NORMAL;
-		cmd.flags = MMC_RSP_R1B | MMC_CMD_AC;
-
-		err = mmc_wait_for_cmd(host, &cmd, CMD_RETRIES);
+		err = mmc_switch(host->card, MMC_SWITCH_MODE_WRITE_BYTE,
+			EXT_CSD_BUS_WIDTH, EXT_CSD_BUS_WIDTH_4 |
+			EXT_CSD_CMD_SET_NORMAL);
 		if (err != MMC_ERR_NONE) {
 			printk("%s: failed to switch card to "
 			       "mmc v4 4-bit bus mode.\n",
@@ -1116,10 +813,6 @@ static void mmc_process_ext_csd(struct mmc_host *host)
 static void mmc_read_scr(struct mmc_host *host)
 {
 	int err;
-	struct mmc_request mrq;
-	struct mmc_command cmd;
-	struct mmc_data data;
-	struct scatterlist sg;
 
 	if (!host->card)
 		return;
@@ -1128,61 +821,19 @@ static void mmc_read_scr(struct mmc_host *host)
 	if (!mmc_card_sd(host->card))
 		return;
 
-	memset(&cmd, 0, sizeof(struct mmc_command));
-
-	cmd.opcode = MMC_APP_CMD;
-	cmd.arg = host->card->rca << 16;
-	cmd.flags = MMC_RSP_R1 | MMC_CMD_AC;
-
-	err = mmc_wait_for_cmd(host, &cmd, 0);
-	if ((err != MMC_ERR_NONE) || !(cmd.resp[0] & R1_APP_CMD)) {
-		mmc_card_set_dead(host->card);
-		return;
-	}
-
-	memset(&cmd, 0, sizeof(struct mmc_command));
-
-	cmd.opcode = SD_APP_SEND_SCR;
-	cmd.arg = 0;
-	cmd.flags = MMC_RSP_R1 | MMC_CMD_ADTC;
-
-	memset(&data, 0, sizeof(struct mmc_data));
-
-	mmc_set_data_timeout(&data, host->card, 0);
-
-	data.blksz = 1 << 3;
-	data.blocks = 1;
-	data.flags = MMC_DATA_READ;
-	data.sg = &sg;
-	data.sg_len = 1;
-
-	memset(&mrq, 0, sizeof(struct mmc_request));
-
-	mrq.cmd = &cmd;
-	mrq.data = &data;
-
-	sg_init_one(&sg, (u8*)host->card->raw_scr, 8);
-
-	mmc_wait_for_req(host, &mrq);
-
-	if (cmd.error != MMC_ERR_NONE || data.error != MMC_ERR_NONE) {
+	err = mmc_app_send_scr(host->card, host->card->raw_scr);
+	if (err != MMC_ERR_NONE) {
 		mmc_card_set_dead(host->card);
 		return;
 	}
 
-	host->card->raw_scr[0] = ntohl(host->card->raw_scr[0]);
-	host->card->raw_scr[1] = ntohl(host->card->raw_scr[1]);
-
 	mmc_decode_scr(host->card);
 }
 
 static void mmc_read_switch_caps(struct mmc_host *host)
 {
-	struct mmc_request mrq;
-	struct mmc_command cmd;
-	struct mmc_data data;
+	int err;
 	unsigned char *status;
-	struct scatterlist sg;
 
 	if (!(host->caps & MMC_CAP_SD_HIGHSPEED))
 		return;
@@ -1204,32 +855,9 @@ static void mmc_read_switch_caps(struct mmc_host *host)
 		return;
 	}
 
-	memset(&cmd, 0, sizeof(struct mmc_command));
-
-	cmd.opcode = SD_SWITCH;
-	cmd.arg = 0x00FFFFF1;
-	cmd.flags = MMC_RSP_R1 | MMC_CMD_ADTC;
-
-	memset(&data, 0, sizeof(struct mmc_data));
-
-	mmc_set_data_timeout(&data, host->card, 0);
-
-	data.blksz = 64;
-	data.blocks = 1;
-	data.flags = MMC_DATA_READ;
-	data.sg = &sg;
-	data.sg_len = 1;
-
-	memset(&mrq, 0, sizeof(struct mmc_request));
-
-	mrq.cmd = &cmd;
-	mrq.data = &data;
-
-	sg_init_one(&sg, status, 64);
-
-	mmc_wait_for_req(host, &mrq);
-
-	if (cmd.error != MMC_ERR_NONE || data.error != MMC_ERR_NONE) {
+	err = mmc_sd_switch(host->card, SD_SWITCH_CHECK,
+		SD_SWITCH_GRP_ACCESS, SD_SWITCH_ACCESS_HS, status);
+	if (err != MMC_ERR_NONE) {
 		printk("%s: unable to read switch capabilities, "
 			"performance might suffer.\n",
 			mmc_hostname(host));
@@ -1239,33 +867,9 @@ static void mmc_read_switch_caps(struct mmc_host *host)
 	if (status[13] & 0x02)
 		host->card->sw_caps.hs_max_dtr = 50000000;
 
-	memset(&cmd, 0, sizeof(struct mmc_command));
-
-	cmd.opcode = SD_SWITCH;
-	cmd.arg = 0x80FFFFF1;
-	cmd.flags = MMC_RSP_R1 | MMC_CMD_ADTC;
-
-	memset(&data, 0, sizeof(struct mmc_data));
-
-	mmc_set_data_timeout(&data, host->card, 0);
-
-	data.blksz = 64;
-	data.blocks = 1;
-	data.flags = MMC_DATA_READ;
-	data.sg = &sg;
-	data.sg_len = 1;
-
-	memset(&mrq, 0, sizeof(struct mmc_request));
-
-	mrq.cmd = &cmd;
-	mrq.data = &data;
-
-	sg_init_one(&sg, status, 64);
-
-	mmc_wait_for_req(host, &mrq);
-
-	if (cmd.error != MMC_ERR_NONE || data.error != MMC_ERR_NONE ||
-		(status[16] & 0xF) != 1) {
+	err = mmc_sd_switch(host->card, SD_SWITCH_SET,
+		SD_SWITCH_GRP_ACCESS, SD_SWITCH_ACCESS_HS, status);
+	if (err != MMC_ERR_NONE || (status[16] & 0xF) != 1) {
 		printk(KERN_WARNING "%s: Problem switching card "
 			"into high-speed mode!\n",
 			mmc_hostname(host));
@@ -1314,16 +918,11 @@ static unsigned int mmc_calculate_clock(struct mmc_host *host)
  */
 static void mmc_check_card(struct mmc_card *card)
 {
-	struct mmc_command cmd;
 	int err;
 
 	BUG_ON(!card);
 
-	cmd.opcode = MMC_SEND_STATUS;
-	cmd.arg = card->rca << 16;
-	cmd.flags = MMC_RSP_R1 | MMC_CMD_AC;
-
-	err = mmc_wait_for_cmd(card->host, &cmd, CMD_RETRIES);
+	err = mmc_send_status(card, NULL);
 	if (err == MMC_ERR_NONE)
 		return;
 
@@ -1338,9 +937,9 @@ static void mmc_setup(struct mmc_host *host)
 	host->mode = MMC_MODE_SD;
 
 	mmc_power_up(host);
-	mmc_idle_cards(host);
+	mmc_go_idle(host);
 
-	err = mmc_send_if_cond(host, host->ocr_avail, NULL);
+	err = mmc_send_if_cond(host, host->ocr_avail);
 	if (err != MMC_ERR_NONE) {
 		return;
 	}
@@ -1369,7 +968,7 @@ static void mmc_setup(struct mmc_host *host)
 	 * state.  We wait 1ms to give cards time to
 	 * respond.
 	 */
-	mmc_idle_cards(host);
+	mmc_go_idle(host);
 
 	/*
 	 * Send the selected OCR multiple times... until the cards
@@ -1377,17 +976,17 @@ static void mmc_setup(struct mmc_host *host)
 	 * (My SanDisk card seems to need this.)
 	 */
 	if (host->mode == MMC_MODE_SD) {
-		int err, sd2;
-		err = mmc_send_if_cond(host, host->ocr, &sd2);
-		if (err == MMC_ERR_NONE) {
-			/*
-			* If SD_SEND_IF_COND indicates an SD 2.0
-			* compliant card and we should set bit 30
-			* of the ocr to indicate that we can handle
-			* block-addressed SDHC cards.
-			*/
-			mmc_send_app_op_cond(host, host->ocr | (sd2 << 30), NULL);
-		}
+		/*
+		 * If SD_SEND_IF_COND indicates an SD 2.0
+		 * compliant card and we should set bit 30
+		 * of the ocr to indicate that we can handle
+		 * block-addressed SDHC cards.
+		 */
+		err = mmc_send_if_cond(host, host->ocr);
+		if (err == MMC_ERR_NONE)
+			ocr = host->ocr | (1 << 30);
+
+		mmc_send_app_op_cond(host, ocr, NULL);
 	} else {
 		/* The extra bit indicates that we support high capacity */
 		mmc_send_op_cond(host, host->ocr | (1 << 30), NULL);
@@ -1409,6 +1008,24 @@ static void mmc_setup(struct mmc_host *host)
 			mmc_card_set_dead(host->card);
 	}
 
+	/*
+	 * The card is in 1 bit mode by default so
+	 * we only need to change if it supports the
+	 * wider version.
+	 */
+	if (host->card && !mmc_card_dead(host->card) && 
+		mmc_card_sd(host->card) &&
+		(host->card->scr.bus_widths & SD_SCR_BUS_WIDTH_4) &&
+		(host->card->host->caps & MMC_CAP_4_BIT_DATA)) {
+		err = mmc_app_set_bus_width(host->card, SD_BUS_WIDTH_4);
+		if (err != MMC_ERR_NONE)
+			mmc_card_set_dead(host->card);
+		else {
+			host->ios.bus_width = MMC_BUS_WIDTH_4;
+			mmc_set_ios(host);
+		}
+	}
+
 	if (host->mode == MMC_MODE_SD) {
 		mmc_read_scr(host);
 		mmc_read_switch_caps(host);

commit aaac1b470bd0dccb30912356617069dc6199cc80
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Wed Feb 28 15:33:10 2007 +0100

    mmc: Move core functions to subdir
    
    Create a "core" subdirectory to house the central bus handling
    functions.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
new file mode 100644
index 000000000000..334e663e465b
--- /dev/null
+++ b/drivers/mmc/core/core.c
@@ -0,0 +1,1638 @@
+/*
+ *  linux/drivers/mmc/core/core.c
+ *
+ *  Copyright (C) 2003-2004 Russell King, All Rights Reserved.
+ *  SD support Copyright (C) 2004 Ian Molton, All Rights Reserved.
+ *  Copyright (C) 2005-2007 Pierre Ossman, All Rights Reserved.
+ *  MMCv4 support Copyright (C) 2006 Philip Langdale, All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/completion.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/pagemap.h>
+#include <linux/err.h>
+#include <asm/scatterlist.h>
+#include <linux/scatterlist.h>
+
+#include <linux/mmc/card.h>
+#include <linux/mmc/host.h>
+#include <linux/mmc/protocol.h>
+
+#include "core.h"
+
+#define CMD_RETRIES	3
+
+/*
+ * OCR Bit positions to 10s of Vdd mV.
+ */
+static const unsigned short mmc_ocr_bit_to_vdd[] = {
+	150,	155,	160,	165,	170,	180,	190,	200,
+	210,	220,	230,	240,	250,	260,	270,	280,
+	290,	300,	310,	320,	330,	340,	350,	360
+};
+
+static const unsigned int tran_exp[] = {
+	10000,		100000,		1000000,	10000000,
+	0,		0,		0,		0
+};
+
+static const unsigned char tran_mant[] = {
+	0,	10,	12,	13,	15,	20,	25,	30,
+	35,	40,	45,	50,	55,	60,	70,	80,
+};
+
+static const unsigned int tacc_exp[] = {
+	1,	10,	100,	1000,	10000,	100000,	1000000, 10000000,
+};
+
+static const unsigned int tacc_mant[] = {
+	0,	10,	12,	13,	15,	20,	25,	30,
+	35,	40,	45,	50,	55,	60,	70,	80,
+};
+
+
+/**
+ *	mmc_request_done - finish processing an MMC request
+ *	@host: MMC host which completed request
+ *	@mrq: MMC request which request
+ *
+ *	MMC drivers should call this function when they have completed
+ *	their processing of a request.
+ */
+void mmc_request_done(struct mmc_host *host, struct mmc_request *mrq)
+{
+	struct mmc_command *cmd = mrq->cmd;
+	int err = cmd->error;
+
+	pr_debug("%s: req done (CMD%u): %d/%d/%d: %08x %08x %08x %08x\n",
+		 mmc_hostname(host), cmd->opcode, err,
+		 mrq->data ? mrq->data->error : 0,
+		 mrq->stop ? mrq->stop->error : 0,
+		 cmd->resp[0], cmd->resp[1], cmd->resp[2], cmd->resp[3]);
+
+	if (err && cmd->retries) {
+		cmd->retries--;
+		cmd->error = 0;
+		host->ops->request(host, mrq);
+	} else if (mrq->done) {
+		mrq->done(mrq);
+	}
+}
+
+EXPORT_SYMBOL(mmc_request_done);
+
+/**
+ *	mmc_start_request - start a command on a host
+ *	@host: MMC host to start command on
+ *	@mrq: MMC request to start
+ *
+ *	Queue a command on the specified host.  We expect the
+ *	caller to be holding the host lock with interrupts disabled.
+ */
+void
+mmc_start_request(struct mmc_host *host, struct mmc_request *mrq)
+{
+#ifdef CONFIG_MMC_DEBUG
+	unsigned int i, sz;
+#endif
+
+	pr_debug("%s: starting CMD%u arg %08x flags %08x\n",
+		 mmc_hostname(host), mrq->cmd->opcode,
+		 mrq->cmd->arg, mrq->cmd->flags);
+
+	WARN_ON(!host->claimed);
+
+	mrq->cmd->error = 0;
+	mrq->cmd->mrq = mrq;
+	if (mrq->data) {
+		BUG_ON(mrq->data->blksz > host->max_blk_size);
+		BUG_ON(mrq->data->blocks > host->max_blk_count);
+		BUG_ON(mrq->data->blocks * mrq->data->blksz >
+			host->max_req_size);
+
+#ifdef CONFIG_MMC_DEBUG
+		sz = 0;
+		for (i = 0;i < mrq->data->sg_len;i++)
+			sz += mrq->data->sg[i].length;
+		BUG_ON(sz != mrq->data->blocks * mrq->data->blksz);
+#endif
+
+		mrq->cmd->data = mrq->data;
+		mrq->data->error = 0;
+		mrq->data->mrq = mrq;
+		if (mrq->stop) {
+			mrq->data->stop = mrq->stop;
+			mrq->stop->error = 0;
+			mrq->stop->mrq = mrq;
+		}
+	}
+	host->ops->request(host, mrq);
+}
+
+EXPORT_SYMBOL(mmc_start_request);
+
+static void mmc_wait_done(struct mmc_request *mrq)
+{
+	complete(mrq->done_data);
+}
+
+int mmc_wait_for_req(struct mmc_host *host, struct mmc_request *mrq)
+{
+	DECLARE_COMPLETION_ONSTACK(complete);
+
+	mrq->done_data = &complete;
+	mrq->done = mmc_wait_done;
+
+	mmc_start_request(host, mrq);
+
+	wait_for_completion(&complete);
+
+	return 0;
+}
+
+EXPORT_SYMBOL(mmc_wait_for_req);
+
+/**
+ *	mmc_wait_for_cmd - start a command and wait for completion
+ *	@host: MMC host to start command
+ *	@cmd: MMC command to start
+ *	@retries: maximum number of retries
+ *
+ *	Start a new MMC command for a host, and wait for the command
+ *	to complete.  Return any error that occurred while the command
+ *	was executing.  Do not attempt to parse the response.
+ */
+int mmc_wait_for_cmd(struct mmc_host *host, struct mmc_command *cmd, int retries)
+{
+	struct mmc_request mrq;
+
+	BUG_ON(!host->claimed);
+
+	memset(&mrq, 0, sizeof(struct mmc_request));
+
+	memset(cmd->resp, 0, sizeof(cmd->resp));
+	cmd->retries = retries;
+
+	mrq.cmd = cmd;
+	cmd->data = NULL;
+
+	mmc_wait_for_req(host, &mrq);
+
+	return cmd->error;
+}
+
+EXPORT_SYMBOL(mmc_wait_for_cmd);
+
+/**
+ *	mmc_wait_for_app_cmd - start an application command and wait for
+ 			       completion
+ *	@host: MMC host to start command
+ *	@rca: RCA to send MMC_APP_CMD to
+ *	@cmd: MMC command to start
+ *	@retries: maximum number of retries
+ *
+ *	Sends a MMC_APP_CMD, checks the card response, sends the command
+ *	in the parameter and waits for it to complete. Return any error
+ *	that occurred while the command was executing.  Do not attempt to
+ *	parse the response.
+ */
+int mmc_wait_for_app_cmd(struct mmc_host *host, unsigned int rca,
+	struct mmc_command *cmd, int retries)
+{
+	struct mmc_request mrq;
+	struct mmc_command appcmd;
+
+	int i, err;
+
+	BUG_ON(!host->claimed);
+	BUG_ON(retries < 0);
+
+	err = MMC_ERR_INVALID;
+
+	/*
+	 * We have to resend MMC_APP_CMD for each attempt so
+	 * we cannot use the retries field in mmc_command.
+	 */
+	for (i = 0;i <= retries;i++) {
+		memset(&mrq, 0, sizeof(struct mmc_request));
+
+		appcmd.opcode = MMC_APP_CMD;
+		appcmd.arg = rca << 16;
+		appcmd.flags = MMC_RSP_R1 | MMC_CMD_AC;
+		appcmd.retries = 0;
+		memset(appcmd.resp, 0, sizeof(appcmd.resp));
+		appcmd.data = NULL;
+
+		mrq.cmd = &appcmd;
+		appcmd.data = NULL;
+
+		mmc_wait_for_req(host, &mrq);
+
+		if (appcmd.error) {
+			err = appcmd.error;
+			continue;
+		}
+
+		/* Check that card supported application commands */
+		if (!(appcmd.resp[0] & R1_APP_CMD))
+			return MMC_ERR_FAILED;
+
+		memset(&mrq, 0, sizeof(struct mmc_request));
+
+		memset(cmd->resp, 0, sizeof(cmd->resp));
+		cmd->retries = 0;
+
+		mrq.cmd = cmd;
+		cmd->data = NULL;
+
+		mmc_wait_for_req(host, &mrq);
+
+		err = cmd->error;
+		if (cmd->error == MMC_ERR_NONE)
+			break;
+	}
+
+	return err;
+}
+
+EXPORT_SYMBOL(mmc_wait_for_app_cmd);
+
+/**
+ *	mmc_set_data_timeout - set the timeout for a data command
+ *	@data: data phase for command
+ *	@card: the MMC card associated with the data transfer
+ *	@write: flag to differentiate reads from writes
+ */
+void mmc_set_data_timeout(struct mmc_data *data, const struct mmc_card *card,
+			  int write)
+{
+	unsigned int mult;
+
+	/*
+	 * SD cards use a 100 multiplier rather than 10
+	 */
+	mult = mmc_card_sd(card) ? 100 : 10;
+
+	/*
+	 * Scale up the multiplier (and therefore the timeout) by
+	 * the r2w factor for writes.
+	 */
+	if (write)
+		mult <<= card->csd.r2w_factor;
+
+	data->timeout_ns = card->csd.tacc_ns * mult;
+	data->timeout_clks = card->csd.tacc_clks * mult;
+
+	/*
+	 * SD cards also have an upper limit on the timeout.
+	 */
+	if (mmc_card_sd(card)) {
+		unsigned int timeout_us, limit_us;
+
+		timeout_us = data->timeout_ns / 1000;
+		timeout_us += data->timeout_clks * 1000 /
+			(card->host->ios.clock / 1000);
+
+		if (write)
+			limit_us = 250000;
+		else
+			limit_us = 100000;
+
+		/*
+		 * SDHC cards always use these fixed values.
+		 */
+		if (timeout_us > limit_us || mmc_card_blockaddr(card)) {
+			data->timeout_ns = limit_us * 1000;
+			data->timeout_clks = 0;
+		}
+	}
+}
+EXPORT_SYMBOL(mmc_set_data_timeout);
+
+/**
+ *	__mmc_claim_host - exclusively claim a host
+ *	@host: mmc host to claim
+ *	@card: mmc card to claim host for
+ *
+ *	Claim a host for a set of operations.  If a valid card
+ *	is passed and this wasn't the last card selected, select
+ *	the card before returning.
+ *
+ *	Note: you should use mmc_card_claim_host or mmc_claim_host.
+ */
+void mmc_claim_host(struct mmc_host *host)
+{
+	DECLARE_WAITQUEUE(wait, current);
+	unsigned long flags;
+
+	add_wait_queue(&host->wq, &wait);
+	spin_lock_irqsave(&host->lock, flags);
+	while (1) {
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		if (!host->claimed)
+			break;
+		spin_unlock_irqrestore(&host->lock, flags);
+		schedule();
+		spin_lock_irqsave(&host->lock, flags);
+	}
+	set_current_state(TASK_RUNNING);
+	host->claimed = 1;
+	spin_unlock_irqrestore(&host->lock, flags);
+	remove_wait_queue(&host->wq, &wait);
+}
+
+EXPORT_SYMBOL(mmc_claim_host);
+
+/**
+ *	mmc_release_host - release a host
+ *	@host: mmc host to release
+ *
+ *	Release a MMC host, allowing others to claim the host
+ *	for their operations.
+ */
+void mmc_release_host(struct mmc_host *host)
+{
+	unsigned long flags;
+
+	BUG_ON(!host->claimed);
+
+	spin_lock_irqsave(&host->lock, flags);
+	host->claimed = 0;
+	spin_unlock_irqrestore(&host->lock, flags);
+
+	wake_up(&host->wq);
+}
+
+EXPORT_SYMBOL(mmc_release_host);
+
+static inline void mmc_set_ios(struct mmc_host *host)
+{
+	struct mmc_ios *ios = &host->ios;
+
+	pr_debug("%s: clock %uHz busmode %u powermode %u cs %u Vdd %u "
+		"width %u timing %u\n",
+		 mmc_hostname(host), ios->clock, ios->bus_mode,
+		 ios->power_mode, ios->chip_select, ios->vdd,
+		 ios->bus_width, ios->timing);
+
+	host->ops->set_ios(host, ios);
+}
+
+static int mmc_select_card(struct mmc_card *card)
+{
+	int err;
+	struct mmc_command cmd;
+
+	BUG_ON(!card->host->claimed);
+
+	cmd.opcode = MMC_SELECT_CARD;
+	cmd.arg = card->rca << 16;
+	cmd.flags = MMC_RSP_R1 | MMC_CMD_AC;
+
+	err = mmc_wait_for_cmd(card->host, &cmd, CMD_RETRIES);
+	if (err != MMC_ERR_NONE)
+		return err;
+
+	/*
+	 * We can only change the bus width of SD cards when
+	 * they are selected so we have to put the handling
+	 * here.
+	 *
+	 * The card is in 1 bit mode by default so
+	 * we only need to change if it supports the
+	 * wider version.
+	 */
+	if (mmc_card_sd(card) &&
+		(card->scr.bus_widths & SD_SCR_BUS_WIDTH_4) &&
+		(card->host->caps & MMC_CAP_4_BIT_DATA)) {
+
+		struct mmc_command cmd;
+		cmd.opcode = SD_APP_SET_BUS_WIDTH;
+		cmd.arg = SD_BUS_WIDTH_4;
+		cmd.flags = MMC_RSP_R1 | MMC_CMD_AC;
+
+		err = mmc_wait_for_app_cmd(card->host, card->rca,
+			&cmd, CMD_RETRIES);
+		if (err != MMC_ERR_NONE)
+			return err;
+
+		card->host->ios.bus_width = MMC_BUS_WIDTH_4;
+		mmc_set_ios(card->host);
+	}
+
+	return MMC_ERR_NONE;
+}
+
+
+static inline void mmc_delay(unsigned int ms)
+{
+	if (ms < 1000 / HZ) {
+		cond_resched();
+		mdelay(ms);
+	} else {
+		msleep(ms);
+	}
+}
+
+/*
+ * Mask off any voltages we don't support and select
+ * the lowest voltage
+ */
+static u32 mmc_select_voltage(struct mmc_host *host, u32 ocr)
+{
+	int bit;
+
+	ocr &= host->ocr_avail;
+
+	bit = ffs(ocr);
+	if (bit) {
+		bit -= 1;
+
+		ocr &= 3 << bit;
+
+		host->ios.vdd = bit;
+		mmc_set_ios(host);
+	} else {
+		ocr = 0;
+	}
+
+	return ocr;
+}
+
+#define UNSTUFF_BITS(resp,start,size)					\
+	({								\
+		const int __size = size;				\
+		const u32 __mask = (__size < 32 ? 1 << __size : 0) - 1;	\
+		const int __off = 3 - ((start) / 32);			\
+		const int __shft = (start) & 31;			\
+		u32 __res;						\
+									\
+		__res = resp[__off] >> __shft;				\
+		if (__size + __shft > 32)				\
+			__res |= resp[__off-1] << ((32 - __shft) % 32);	\
+		__res & __mask;						\
+	})
+
+/*
+ * Given the decoded CSD structure, decode the raw CID to our CID structure.
+ */
+static void mmc_decode_cid(struct mmc_card *card)
+{
+	u32 *resp = card->raw_cid;
+
+	memset(&card->cid, 0, sizeof(struct mmc_cid));
+
+	if (mmc_card_sd(card)) {
+		/*
+		 * SD doesn't currently have a version field so we will
+		 * have to assume we can parse this.
+		 */
+		card->cid.manfid		= UNSTUFF_BITS(resp, 120, 8);
+		card->cid.oemid			= UNSTUFF_BITS(resp, 104, 16);
+		card->cid.prod_name[0]		= UNSTUFF_BITS(resp, 96, 8);
+		card->cid.prod_name[1]		= UNSTUFF_BITS(resp, 88, 8);
+		card->cid.prod_name[2]		= UNSTUFF_BITS(resp, 80, 8);
+		card->cid.prod_name[3]		= UNSTUFF_BITS(resp, 72, 8);
+		card->cid.prod_name[4]		= UNSTUFF_BITS(resp, 64, 8);
+		card->cid.hwrev			= UNSTUFF_BITS(resp, 60, 4);
+		card->cid.fwrev			= UNSTUFF_BITS(resp, 56, 4);
+		card->cid.serial		= UNSTUFF_BITS(resp, 24, 32);
+		card->cid.year			= UNSTUFF_BITS(resp, 12, 8);
+		card->cid.month			= UNSTUFF_BITS(resp, 8, 4);
+
+		card->cid.year += 2000; /* SD cards year offset */
+	} else {
+		/*
+		 * The selection of the format here is based upon published
+		 * specs from sandisk and from what people have reported.
+		 */
+		switch (card->csd.mmca_vsn) {
+		case 0: /* MMC v1.0 - v1.2 */
+		case 1: /* MMC v1.4 */
+			card->cid.manfid	= UNSTUFF_BITS(resp, 104, 24);
+			card->cid.prod_name[0]	= UNSTUFF_BITS(resp, 96, 8);
+			card->cid.prod_name[1]	= UNSTUFF_BITS(resp, 88, 8);
+			card->cid.prod_name[2]	= UNSTUFF_BITS(resp, 80, 8);
+			card->cid.prod_name[3]	= UNSTUFF_BITS(resp, 72, 8);
+			card->cid.prod_name[4]	= UNSTUFF_BITS(resp, 64, 8);
+			card->cid.prod_name[5]	= UNSTUFF_BITS(resp, 56, 8);
+			card->cid.prod_name[6]	= UNSTUFF_BITS(resp, 48, 8);
+			card->cid.hwrev		= UNSTUFF_BITS(resp, 44, 4);
+			card->cid.fwrev		= UNSTUFF_BITS(resp, 40, 4);
+			card->cid.serial	= UNSTUFF_BITS(resp, 16, 24);
+			card->cid.month		= UNSTUFF_BITS(resp, 12, 4);
+			card->cid.year		= UNSTUFF_BITS(resp, 8, 4) + 1997;
+			break;
+
+		case 2: /* MMC v2.0 - v2.2 */
+		case 3: /* MMC v3.1 - v3.3 */
+		case 4: /* MMC v4 */
+			card->cid.manfid	= UNSTUFF_BITS(resp, 120, 8);
+			card->cid.oemid		= UNSTUFF_BITS(resp, 104, 16);
+			card->cid.prod_name[0]	= UNSTUFF_BITS(resp, 96, 8);
+			card->cid.prod_name[1]	= UNSTUFF_BITS(resp, 88, 8);
+			card->cid.prod_name[2]	= UNSTUFF_BITS(resp, 80, 8);
+			card->cid.prod_name[3]	= UNSTUFF_BITS(resp, 72, 8);
+			card->cid.prod_name[4]	= UNSTUFF_BITS(resp, 64, 8);
+			card->cid.prod_name[5]	= UNSTUFF_BITS(resp, 56, 8);
+			card->cid.serial	= UNSTUFF_BITS(resp, 16, 32);
+			card->cid.month		= UNSTUFF_BITS(resp, 12, 4);
+			card->cid.year		= UNSTUFF_BITS(resp, 8, 4) + 1997;
+			break;
+
+		default:
+			printk("%s: card has unknown MMCA version %d\n",
+				mmc_hostname(card->host), card->csd.mmca_vsn);
+			mmc_card_set_bad(card);
+			break;
+		}
+	}
+}
+
+/*
+ * Given a 128-bit response, decode to our card CSD structure.
+ */
+static void mmc_decode_csd(struct mmc_card *card)
+{
+	struct mmc_csd *csd = &card->csd;
+	unsigned int e, m, csd_struct;
+	u32 *resp = card->raw_csd;
+
+	if (mmc_card_sd(card)) {
+		csd_struct = UNSTUFF_BITS(resp, 126, 2);
+
+		switch (csd_struct) {
+		case 0:
+			m = UNSTUFF_BITS(resp, 115, 4);
+			e = UNSTUFF_BITS(resp, 112, 3);
+			csd->tacc_ns	 = (tacc_exp[e] * tacc_mant[m] + 9) / 10;
+			csd->tacc_clks	 = UNSTUFF_BITS(resp, 104, 8) * 100;
+
+			m = UNSTUFF_BITS(resp, 99, 4);
+			e = UNSTUFF_BITS(resp, 96, 3);
+			csd->max_dtr	  = tran_exp[e] * tran_mant[m];
+			csd->cmdclass	  = UNSTUFF_BITS(resp, 84, 12);
+
+			e = UNSTUFF_BITS(resp, 47, 3);
+			m = UNSTUFF_BITS(resp, 62, 12);
+			csd->capacity	  = (1 + m) << (e + 2);
+
+			csd->read_blkbits = UNSTUFF_BITS(resp, 80, 4);
+			csd->read_partial = UNSTUFF_BITS(resp, 79, 1);
+			csd->write_misalign = UNSTUFF_BITS(resp, 78, 1);
+			csd->read_misalign = UNSTUFF_BITS(resp, 77, 1);
+			csd->r2w_factor = UNSTUFF_BITS(resp, 26, 3);
+			csd->write_blkbits = UNSTUFF_BITS(resp, 22, 4);
+			csd->write_partial = UNSTUFF_BITS(resp, 21, 1);
+			break;
+		case 1:
+			/*
+			 * This is a block-addressed SDHC card. Most
+			 * interesting fields are unused and have fixed
+			 * values. To avoid getting tripped by buggy cards,
+			 * we assume those fixed values ourselves.
+			 */
+			mmc_card_set_blockaddr(card);
+
+			csd->tacc_ns	 = 0; /* Unused */
+			csd->tacc_clks	 = 0; /* Unused */
+
+			m = UNSTUFF_BITS(resp, 99, 4);
+			e = UNSTUFF_BITS(resp, 96, 3);
+			csd->max_dtr	  = tran_exp[e] * tran_mant[m];
+			csd->cmdclass	  = UNSTUFF_BITS(resp, 84, 12);
+
+			m = UNSTUFF_BITS(resp, 48, 22);
+			csd->capacity     = (1 + m) << 10;
+
+			csd->read_blkbits = 9;
+			csd->read_partial = 0;
+			csd->write_misalign = 0;
+			csd->read_misalign = 0;
+			csd->r2w_factor = 4; /* Unused */
+			csd->write_blkbits = 9;
+			csd->write_partial = 0;
+			break;
+		default:
+			printk("%s: unrecognised CSD structure version %d\n",
+				mmc_hostname(card->host), csd_struct);
+			mmc_card_set_bad(card);
+			return;
+		}
+	} else {
+		/*
+		 * We only understand CSD structure v1.1 and v1.2.
+		 * v1.2 has extra information in bits 15, 11 and 10.
+		 */
+		csd_struct = UNSTUFF_BITS(resp, 126, 2);
+		if (csd_struct != 1 && csd_struct != 2) {
+			printk("%s: unrecognised CSD structure version %d\n",
+				mmc_hostname(card->host), csd_struct);
+			mmc_card_set_bad(card);
+			return;
+		}
+
+		csd->mmca_vsn	 = UNSTUFF_BITS(resp, 122, 4);
+		m = UNSTUFF_BITS(resp, 115, 4);
+		e = UNSTUFF_BITS(resp, 112, 3);
+		csd->tacc_ns	 = (tacc_exp[e] * tacc_mant[m] + 9) / 10;
+		csd->tacc_clks	 = UNSTUFF_BITS(resp, 104, 8) * 100;
+
+		m = UNSTUFF_BITS(resp, 99, 4);
+		e = UNSTUFF_BITS(resp, 96, 3);
+		csd->max_dtr	  = tran_exp[e] * tran_mant[m];
+		csd->cmdclass	  = UNSTUFF_BITS(resp, 84, 12);
+
+		e = UNSTUFF_BITS(resp, 47, 3);
+		m = UNSTUFF_BITS(resp, 62, 12);
+		csd->capacity	  = (1 + m) << (e + 2);
+
+		csd->read_blkbits = UNSTUFF_BITS(resp, 80, 4);
+		csd->read_partial = UNSTUFF_BITS(resp, 79, 1);
+		csd->write_misalign = UNSTUFF_BITS(resp, 78, 1);
+		csd->read_misalign = UNSTUFF_BITS(resp, 77, 1);
+		csd->r2w_factor = UNSTUFF_BITS(resp, 26, 3);
+		csd->write_blkbits = UNSTUFF_BITS(resp, 22, 4);
+		csd->write_partial = UNSTUFF_BITS(resp, 21, 1);
+	}
+}
+
+/*
+ * Given a 64-bit response, decode to our card SCR structure.
+ */
+static void mmc_decode_scr(struct mmc_card *card)
+{
+	struct sd_scr *scr = &card->scr;
+	unsigned int scr_struct;
+	u32 resp[4];
+
+	BUG_ON(!mmc_card_sd(card));
+
+	resp[3] = card->raw_scr[1];
+	resp[2] = card->raw_scr[0];
+
+	scr_struct = UNSTUFF_BITS(resp, 60, 4);
+	if (scr_struct != 0) {
+		printk("%s: unrecognised SCR structure version %d\n",
+			mmc_hostname(card->host), scr_struct);
+		mmc_card_set_bad(card);
+		return;
+	}
+
+	scr->sda_vsn = UNSTUFF_BITS(resp, 56, 4);
+	scr->bus_widths = UNSTUFF_BITS(resp, 48, 4);
+}
+
+/*
+ * Allocate a new MMC card
+ */
+static struct mmc_card *
+mmc_alloc_card(struct mmc_host *host, u32 *raw_cid)
+{
+	struct mmc_card *card;
+
+	card = kmalloc(sizeof(struct mmc_card), GFP_KERNEL);
+	if (!card)
+		return ERR_PTR(-ENOMEM);
+
+	mmc_init_card(card, host);
+	memcpy(card->raw_cid, raw_cid, sizeof(card->raw_cid));
+
+	return card;
+}
+
+/*
+ * Tell attached cards to go to IDLE state
+ */
+static void mmc_idle_cards(struct mmc_host *host)
+{
+	struct mmc_command cmd;
+
+	host->ios.chip_select = MMC_CS_HIGH;
+	mmc_set_ios(host);
+
+	mmc_delay(1);
+
+	cmd.opcode = MMC_GO_IDLE_STATE;
+	cmd.arg = 0;
+	cmd.flags = MMC_RSP_NONE | MMC_CMD_BC;
+
+	mmc_wait_for_cmd(host, &cmd, 0);
+
+	mmc_delay(1);
+
+	host->ios.chip_select = MMC_CS_DONTCARE;
+	mmc_set_ios(host);
+
+	mmc_delay(1);
+}
+
+/*
+ * Apply power to the MMC stack.  This is a two-stage process.
+ * First, we enable power to the card without the clock running.
+ * We then wait a bit for the power to stabilise.  Finally,
+ * enable the bus drivers and clock to the card.
+ *
+ * We must _NOT_ enable the clock prior to power stablising.
+ *
+ * If a host does all the power sequencing itself, ignore the
+ * initial MMC_POWER_UP stage.
+ */
+static void mmc_power_up(struct mmc_host *host)
+{
+	int bit = fls(host->ocr_avail) - 1;
+
+	host->ios.vdd = bit;
+	host->ios.bus_mode = MMC_BUSMODE_OPENDRAIN;
+	host->ios.chip_select = MMC_CS_DONTCARE;
+	host->ios.power_mode = MMC_POWER_UP;
+	host->ios.bus_width = MMC_BUS_WIDTH_1;
+	host->ios.timing = MMC_TIMING_LEGACY;
+	mmc_set_ios(host);
+
+	mmc_delay(1);
+
+	host->ios.clock = host->f_min;
+	host->ios.power_mode = MMC_POWER_ON;
+	mmc_set_ios(host);
+
+	mmc_delay(2);
+}
+
+static void mmc_power_off(struct mmc_host *host)
+{
+	host->ios.clock = 0;
+	host->ios.vdd = 0;
+	host->ios.bus_mode = MMC_BUSMODE_OPENDRAIN;
+	host->ios.chip_select = MMC_CS_DONTCARE;
+	host->ios.power_mode = MMC_POWER_OFF;
+	host->ios.bus_width = MMC_BUS_WIDTH_1;
+	host->ios.timing = MMC_TIMING_LEGACY;
+	mmc_set_ios(host);
+}
+
+static int mmc_send_op_cond(struct mmc_host *host, u32 ocr, u32 *rocr)
+{
+	struct mmc_command cmd;
+	int i, err = 0;
+
+	cmd.opcode = MMC_SEND_OP_COND;
+	cmd.arg = ocr;
+	cmd.flags = MMC_RSP_R3 | MMC_CMD_BCR;
+
+	for (i = 100; i; i--) {
+		err = mmc_wait_for_cmd(host, &cmd, 0);
+		if (err != MMC_ERR_NONE)
+			break;
+
+		if (cmd.resp[0] & MMC_CARD_BUSY || ocr == 0)
+			break;
+
+		err = MMC_ERR_TIMEOUT;
+
+		mmc_delay(10);
+	}
+
+	if (rocr)
+		*rocr = cmd.resp[0];
+
+	return err;
+}
+
+static int mmc_send_app_op_cond(struct mmc_host *host, u32 ocr, u32 *rocr)
+{
+	struct mmc_command cmd;
+	int i, err = 0;
+
+	cmd.opcode = SD_APP_OP_COND;
+	cmd.arg = ocr;
+	cmd.flags = MMC_RSP_R3 | MMC_CMD_BCR;
+
+	for (i = 100; i; i--) {
+		err = mmc_wait_for_app_cmd(host, 0, &cmd, CMD_RETRIES);
+		if (err != MMC_ERR_NONE)
+			break;
+
+		if (cmd.resp[0] & MMC_CARD_BUSY || ocr == 0)
+			break;
+
+		err = MMC_ERR_TIMEOUT;
+
+		mmc_delay(10);
+	}
+
+	if (rocr)
+		*rocr = cmd.resp[0];
+
+	return err;
+}
+
+static int mmc_send_if_cond(struct mmc_host *host, u32 ocr, int *rsd2)
+{
+	struct mmc_command cmd;
+	int err, sd2;
+	static const u8 test_pattern = 0xAA;
+
+	/*
+	* To support SD 2.0 cards, we must always invoke SD_SEND_IF_COND
+	* before SD_APP_OP_COND. This command will harmlessly fail for
+	* SD 1.0 cards.
+	*/
+	cmd.opcode = SD_SEND_IF_COND;
+	cmd.arg = ((ocr & 0xFF8000) != 0) << 8 | test_pattern;
+	cmd.flags = MMC_RSP_R7 | MMC_CMD_BCR;
+
+	err = mmc_wait_for_cmd(host, &cmd, 0);
+	if (err == MMC_ERR_NONE) {
+		if ((cmd.resp[0] & 0xFF) == test_pattern) {
+			sd2 = 1;
+		} else {
+			sd2 = 0;
+			err = MMC_ERR_FAILED;
+		}
+	} else {
+		/*
+		 * Treat errors as SD 1.0 card.
+		 */
+		sd2 = 0;
+		err = MMC_ERR_NONE;
+	}
+	if (rsd2)
+		*rsd2 = sd2;
+	return err;
+}
+
+/*
+ * Discover the card by requesting its CID.
+ *
+ * Create a mmc_card entry for the discovered card, assigning
+ * it an RCA, and save the raw CID for decoding later.
+ */
+static void mmc_discover_card(struct mmc_host *host)
+{
+	unsigned int err;
+
+	struct mmc_command cmd;
+
+	BUG_ON(host->card);
+
+	cmd.opcode = MMC_ALL_SEND_CID;
+	cmd.arg = 0;
+	cmd.flags = MMC_RSP_R2 | MMC_CMD_BCR;
+
+	err = mmc_wait_for_cmd(host, &cmd, CMD_RETRIES);
+	if (err == MMC_ERR_TIMEOUT) {
+		err = MMC_ERR_NONE;
+		return;
+	}
+	if (err != MMC_ERR_NONE) {
+		printk(KERN_ERR "%s: error requesting CID: %d\n",
+			mmc_hostname(host), err);
+		return;
+	}
+
+	host->card = mmc_alloc_card(host, cmd.resp);
+	if (IS_ERR(host->card)) {
+		err = PTR_ERR(host->card);
+		host->card = NULL;
+		return;
+	}
+
+	if (host->mode == MMC_MODE_SD) {
+		host->card->type = MMC_TYPE_SD;
+
+		cmd.opcode = SD_SEND_RELATIVE_ADDR;
+		cmd.arg = 0;
+		cmd.flags = MMC_RSP_R6 | MMC_CMD_BCR;
+
+		err = mmc_wait_for_cmd(host, &cmd, CMD_RETRIES);
+		if (err != MMC_ERR_NONE)
+			mmc_card_set_dead(host->card);
+		else {
+			host->card->rca = cmd.resp[0] >> 16;
+
+			if (!host->ops->get_ro) {
+				printk(KERN_WARNING "%s: host does not "
+					"support reading read-only "
+					"switch. assuming write-enable.\n",
+					mmc_hostname(host));
+			} else {
+				if (host->ops->get_ro(host))
+					mmc_card_set_readonly(host->card);
+			}
+		}
+	} else {
+		host->card->type = MMC_TYPE_MMC;
+		host->card->rca = 1;
+
+		cmd.opcode = MMC_SET_RELATIVE_ADDR;
+		cmd.arg = host->card->rca << 16;
+		cmd.flags = MMC_RSP_R1 | MMC_CMD_AC;
+
+		err = mmc_wait_for_cmd(host, &cmd, CMD_RETRIES);
+		if (err != MMC_ERR_NONE)
+			mmc_card_set_dead(host->card);
+	}
+}
+
+static void mmc_read_csd(struct mmc_host *host)
+{
+	struct mmc_command cmd;
+	int err;
+
+	if (!host->card)
+		return;
+	if (mmc_card_dead(host->card))
+		return;
+
+	cmd.opcode = MMC_SEND_CSD;
+	cmd.arg = host->card->rca << 16;
+	cmd.flags = MMC_RSP_R2 | MMC_CMD_AC;
+
+	err = mmc_wait_for_cmd(host, &cmd, CMD_RETRIES);
+	if (err != MMC_ERR_NONE) {
+		mmc_card_set_dead(host->card);
+		return;
+	}
+
+	memcpy(host->card->raw_csd, cmd.resp, sizeof(host->card->raw_csd));
+
+	mmc_decode_csd(host->card);
+	mmc_decode_cid(host->card);
+}
+
+static void mmc_process_ext_csd(struct mmc_host *host)
+{
+	int err;
+
+	struct mmc_request mrq;
+	struct mmc_command cmd;
+	struct mmc_data data;
+
+	u8 *ext_csd;
+	struct scatterlist sg;
+
+	if (!host->card)
+		return;
+	if (mmc_card_dead(host->card))
+		return;
+	if (mmc_card_sd(host->card))
+		return;
+	if (host->card->csd.mmca_vsn < CSD_SPEC_VER_4)
+		return;
+
+	/*
+	 * As the ext_csd is so large and mostly unused, we don't store the
+	 * raw block in mmc_card.
+	 */
+	ext_csd = kmalloc(512, GFP_KERNEL);
+	if (!ext_csd) {
+		printk("%s: could not allocate a buffer to receive the ext_csd."
+		       "mmc v4 cards will be treated as v3.\n",
+			mmc_hostname(host));
+		return;
+	}
+
+	memset(&cmd, 0, sizeof(struct mmc_command));
+
+	cmd.opcode = MMC_SEND_EXT_CSD;
+	cmd.arg = 0;
+	cmd.flags = MMC_RSP_R1 | MMC_CMD_ADTC;
+
+	memset(&data, 0, sizeof(struct mmc_data));
+
+	mmc_set_data_timeout(&data, host->card, 0);
+
+	data.blksz = 512;
+	data.blocks = 1;
+	data.flags = MMC_DATA_READ;
+	data.sg = &sg;
+	data.sg_len = 1;
+
+	memset(&mrq, 0, sizeof(struct mmc_request));
+
+	mrq.cmd = &cmd;
+	mrq.data = &data;
+
+	sg_init_one(&sg, ext_csd, 512);
+
+	mmc_wait_for_req(host, &mrq);
+
+	if (cmd.error != MMC_ERR_NONE || data.error != MMC_ERR_NONE) {
+		if (host->card->csd.capacity == (4096 * 512)) {
+			printk(KERN_ERR "%s: unable to read EXT_CSD "
+				"on a possible high capacity card. "
+				"Card will be ignored.\n",
+				mmc_hostname(host));
+			mmc_card_set_dead(host->card);
+		} else {
+			printk(KERN_WARNING "%s: unable to read "
+				"EXT_CSD, performance might "
+				"suffer.\n",
+				mmc_hostname(host));
+		}
+		goto out;
+	}
+
+	host->card->ext_csd.sectors =
+		ext_csd[EXT_CSD_SEC_CNT + 0] << 0 |
+		ext_csd[EXT_CSD_SEC_CNT + 1] << 8 |
+		ext_csd[EXT_CSD_SEC_CNT + 2] << 16 |
+		ext_csd[EXT_CSD_SEC_CNT + 3] << 24;
+	if (host->card->ext_csd.sectors)
+		mmc_card_set_blockaddr(host->card);
+
+	switch (ext_csd[EXT_CSD_CARD_TYPE]) {
+	case EXT_CSD_CARD_TYPE_52 | EXT_CSD_CARD_TYPE_26:
+		host->card->ext_csd.hs_max_dtr = 52000000;
+		break;
+	case EXT_CSD_CARD_TYPE_26:
+		host->card->ext_csd.hs_max_dtr = 26000000;
+		break;
+	default:
+		/* MMC v4 spec says this cannot happen */
+		printk("%s: card is mmc v4 but doesn't support "
+		       "any high-speed modes.\n",
+			mmc_hostname(host));
+		goto out;
+	}
+
+	if (host->caps & MMC_CAP_MMC_HIGHSPEED) {
+		/* Activate highspeed support. */
+		cmd.opcode = MMC_SWITCH;
+		cmd.arg = (MMC_SWITCH_MODE_WRITE_BYTE << 24) |
+			  (EXT_CSD_HS_TIMING << 16) |
+			  (1 << 8) |
+			  EXT_CSD_CMD_SET_NORMAL;
+		cmd.flags = MMC_RSP_R1B | MMC_CMD_AC;
+
+		err = mmc_wait_for_cmd(host, &cmd, CMD_RETRIES);
+		if (err != MMC_ERR_NONE) {
+			printk("%s: failed to switch card to mmc v4 "
+			       "high-speed mode.\n",
+			       mmc_hostname(host));
+			goto out;
+		}
+
+		mmc_card_set_highspeed(host->card);
+
+		host->ios.timing = MMC_TIMING_MMC_HS;
+		mmc_set_ios(host);
+	}
+
+	/* Check for host support for wide-bus modes. */
+	if (host->caps & MMC_CAP_4_BIT_DATA) {
+		/* Activate 4-bit support. */
+		cmd.opcode = MMC_SWITCH;
+		cmd.arg = (MMC_SWITCH_MODE_WRITE_BYTE << 24) |
+			  (EXT_CSD_BUS_WIDTH << 16) |
+			  (EXT_CSD_BUS_WIDTH_4 << 8) |
+			  EXT_CSD_CMD_SET_NORMAL;
+		cmd.flags = MMC_RSP_R1B | MMC_CMD_AC;
+
+		err = mmc_wait_for_cmd(host, &cmd, CMD_RETRIES);
+		if (err != MMC_ERR_NONE) {
+			printk("%s: failed to switch card to "
+			       "mmc v4 4-bit bus mode.\n",
+			       mmc_hostname(host));
+			goto out;
+		}
+
+		host->ios.bus_width = MMC_BUS_WIDTH_4;
+		mmc_set_ios(host);
+	}
+
+out:
+	kfree(ext_csd);
+}
+
+static void mmc_read_scr(struct mmc_host *host)
+{
+	int err;
+	struct mmc_request mrq;
+	struct mmc_command cmd;
+	struct mmc_data data;
+	struct scatterlist sg;
+
+	if (!host->card)
+		return;
+	if (mmc_card_dead(host->card))
+		return;
+	if (!mmc_card_sd(host->card))
+		return;
+
+	memset(&cmd, 0, sizeof(struct mmc_command));
+
+	cmd.opcode = MMC_APP_CMD;
+	cmd.arg = host->card->rca << 16;
+	cmd.flags = MMC_RSP_R1 | MMC_CMD_AC;
+
+	err = mmc_wait_for_cmd(host, &cmd, 0);
+	if ((err != MMC_ERR_NONE) || !(cmd.resp[0] & R1_APP_CMD)) {
+		mmc_card_set_dead(host->card);
+		return;
+	}
+
+	memset(&cmd, 0, sizeof(struct mmc_command));
+
+	cmd.opcode = SD_APP_SEND_SCR;
+	cmd.arg = 0;
+	cmd.flags = MMC_RSP_R1 | MMC_CMD_ADTC;
+
+	memset(&data, 0, sizeof(struct mmc_data));
+
+	mmc_set_data_timeout(&data, host->card, 0);
+
+	data.blksz = 1 << 3;
+	data.blocks = 1;
+	data.flags = MMC_DATA_READ;
+	data.sg = &sg;
+	data.sg_len = 1;
+
+	memset(&mrq, 0, sizeof(struct mmc_request));
+
+	mrq.cmd = &cmd;
+	mrq.data = &data;
+
+	sg_init_one(&sg, (u8*)host->card->raw_scr, 8);
+
+	mmc_wait_for_req(host, &mrq);
+
+	if (cmd.error != MMC_ERR_NONE || data.error != MMC_ERR_NONE) {
+		mmc_card_set_dead(host->card);
+		return;
+	}
+
+	host->card->raw_scr[0] = ntohl(host->card->raw_scr[0]);
+	host->card->raw_scr[1] = ntohl(host->card->raw_scr[1]);
+
+	mmc_decode_scr(host->card);
+}
+
+static void mmc_read_switch_caps(struct mmc_host *host)
+{
+	struct mmc_request mrq;
+	struct mmc_command cmd;
+	struct mmc_data data;
+	unsigned char *status;
+	struct scatterlist sg;
+
+	if (!(host->caps & MMC_CAP_SD_HIGHSPEED))
+		return;
+
+	if (!host->card)
+		return;
+	if (mmc_card_dead(host->card))
+		return;
+	if (!mmc_card_sd(host->card))
+		return;
+	if (host->card->scr.sda_vsn < SCR_SPEC_VER_1)
+		return;
+
+	status = kmalloc(64, GFP_KERNEL);
+	if (!status) {
+		printk(KERN_WARNING "%s: Unable to allocate buffer for "
+			"reading switch capabilities.\n",
+			mmc_hostname(host));
+		return;
+	}
+
+	memset(&cmd, 0, sizeof(struct mmc_command));
+
+	cmd.opcode = SD_SWITCH;
+	cmd.arg = 0x00FFFFF1;
+	cmd.flags = MMC_RSP_R1 | MMC_CMD_ADTC;
+
+	memset(&data, 0, sizeof(struct mmc_data));
+
+	mmc_set_data_timeout(&data, host->card, 0);
+
+	data.blksz = 64;
+	data.blocks = 1;
+	data.flags = MMC_DATA_READ;
+	data.sg = &sg;
+	data.sg_len = 1;
+
+	memset(&mrq, 0, sizeof(struct mmc_request));
+
+	mrq.cmd = &cmd;
+	mrq.data = &data;
+
+	sg_init_one(&sg, status, 64);
+
+	mmc_wait_for_req(host, &mrq);
+
+	if (cmd.error != MMC_ERR_NONE || data.error != MMC_ERR_NONE) {
+		printk("%s: unable to read switch capabilities, "
+			"performance might suffer.\n",
+			mmc_hostname(host));
+		goto out;
+	}
+
+	if (status[13] & 0x02)
+		host->card->sw_caps.hs_max_dtr = 50000000;
+
+	memset(&cmd, 0, sizeof(struct mmc_command));
+
+	cmd.opcode = SD_SWITCH;
+	cmd.arg = 0x80FFFFF1;
+	cmd.flags = MMC_RSP_R1 | MMC_CMD_ADTC;
+
+	memset(&data, 0, sizeof(struct mmc_data));
+
+	mmc_set_data_timeout(&data, host->card, 0);
+
+	data.blksz = 64;
+	data.blocks = 1;
+	data.flags = MMC_DATA_READ;
+	data.sg = &sg;
+	data.sg_len = 1;
+
+	memset(&mrq, 0, sizeof(struct mmc_request));
+
+	mrq.cmd = &cmd;
+	mrq.data = &data;
+
+	sg_init_one(&sg, status, 64);
+
+	mmc_wait_for_req(host, &mrq);
+
+	if (cmd.error != MMC_ERR_NONE || data.error != MMC_ERR_NONE ||
+		(status[16] & 0xF) != 1) {
+		printk(KERN_WARNING "%s: Problem switching card "
+			"into high-speed mode!\n",
+			mmc_hostname(host));
+		goto out;
+	}
+
+	mmc_card_set_highspeed(host->card);
+
+	host->ios.timing = MMC_TIMING_SD_HS;
+	mmc_set_ios(host);
+
+out:
+	kfree(status);
+}
+
+static unsigned int mmc_calculate_clock(struct mmc_host *host)
+{
+	unsigned int max_dtr = host->f_max;
+
+	if (host->card && !mmc_card_dead(host->card)) {
+		if (mmc_card_highspeed(host->card) && mmc_card_sd(host->card)) {
+			if (max_dtr > host->card->sw_caps.hs_max_dtr)
+				max_dtr = host->card->sw_caps.hs_max_dtr;
+		} else if (mmc_card_highspeed(host->card) && !mmc_card_sd(host->card)) {
+			if (max_dtr > host->card->ext_csd.hs_max_dtr)
+				max_dtr = host->card->ext_csd.hs_max_dtr;
+		} else if (max_dtr > host->card->csd.max_dtr) {
+			max_dtr = host->card->csd.max_dtr;
+		}
+	}
+
+	pr_debug("%s: selected %d.%03dMHz transfer rate\n",
+		 mmc_hostname(host),
+		 max_dtr / 1000000, (max_dtr / 1000) % 1000);
+
+	return max_dtr;
+}
+
+/*
+ * Check whether cards we already know about are still present.
+ * We do this by requesting status, and checking whether a card
+ * responds.
+ *
+ * A request for status does not cause a state change in data
+ * transfer mode.
+ */
+static void mmc_check_card(struct mmc_card *card)
+{
+	struct mmc_command cmd;
+	int err;
+
+	BUG_ON(!card);
+
+	cmd.opcode = MMC_SEND_STATUS;
+	cmd.arg = card->rca << 16;
+	cmd.flags = MMC_RSP_R1 | MMC_CMD_AC;
+
+	err = mmc_wait_for_cmd(card->host, &cmd, CMD_RETRIES);
+	if (err == MMC_ERR_NONE)
+		return;
+
+	mmc_card_set_dead(card);
+}
+
+static void mmc_setup(struct mmc_host *host)
+{
+	int err;
+	u32 ocr;
+
+	host->mode = MMC_MODE_SD;
+
+	mmc_power_up(host);
+	mmc_idle_cards(host);
+
+	err = mmc_send_if_cond(host, host->ocr_avail, NULL);
+	if (err != MMC_ERR_NONE) {
+		return;
+	}
+	err = mmc_send_app_op_cond(host, 0, &ocr);
+
+	/*
+	 * If we fail to detect any SD cards then try
+	 * searching for MMC cards.
+	 */
+	if (err != MMC_ERR_NONE) {
+		host->mode = MMC_MODE_MMC;
+
+		err = mmc_send_op_cond(host, 0, &ocr);
+		if (err != MMC_ERR_NONE)
+			return;
+	}
+
+	host->ocr = mmc_select_voltage(host, ocr);
+
+	if (host->ocr == 0)
+		return;
+
+	/*
+	 * Since we're changing the OCR value, we seem to
+	 * need to tell some cards to go back to the idle
+	 * state.  We wait 1ms to give cards time to
+	 * respond.
+	 */
+	mmc_idle_cards(host);
+
+	/*
+	 * Send the selected OCR multiple times... until the cards
+	 * all get the idea that they should be ready for CMD2.
+	 * (My SanDisk card seems to need this.)
+	 */
+	if (host->mode == MMC_MODE_SD) {
+		int err, sd2;
+		err = mmc_send_if_cond(host, host->ocr, &sd2);
+		if (err == MMC_ERR_NONE) {
+			/*
+			* If SD_SEND_IF_COND indicates an SD 2.0
+			* compliant card and we should set bit 30
+			* of the ocr to indicate that we can handle
+			* block-addressed SDHC cards.
+			*/
+			mmc_send_app_op_cond(host, host->ocr | (sd2 << 30), NULL);
+		}
+	} else {
+		/* The extra bit indicates that we support high capacity */
+		mmc_send_op_cond(host, host->ocr | (1 << 30), NULL);
+	}
+
+	mmc_discover_card(host);
+
+	/*
+	 * Ok, now switch to push-pull mode.
+	 */
+	host->ios.bus_mode = MMC_BUSMODE_PUSHPULL;
+	mmc_set_ios(host);
+
+	mmc_read_csd(host);
+
+	if (host->card && !mmc_card_dead(host->card)) {
+		err = mmc_select_card(host->card);
+		if (err != MMC_ERR_NONE)
+			mmc_card_set_dead(host->card);
+	}
+
+	if (host->mode == MMC_MODE_SD) {
+		mmc_read_scr(host);
+		mmc_read_switch_caps(host);
+	} else
+		mmc_process_ext_csd(host);
+}
+
+
+/**
+ *	mmc_detect_change - process change of state on a MMC socket
+ *	@host: host which changed state.
+ *	@delay: optional delay to wait before detection (jiffies)
+ *
+ *	All we know is that card(s) have been inserted or removed
+ *	from the socket(s).  We don't know which socket or cards.
+ */
+void mmc_detect_change(struct mmc_host *host, unsigned long delay)
+{
+#ifdef CONFIG_MMC_DEBUG
+	mmc_claim_host(host);
+	BUG_ON(host->removed);
+	mmc_release_host(host);
+#endif
+
+	mmc_schedule_delayed_work(&host->detect, delay);
+}
+
+EXPORT_SYMBOL(mmc_detect_change);
+
+
+static void mmc_rescan(struct work_struct *work)
+{
+	struct mmc_host *host =
+		container_of(work, struct mmc_host, detect.work);
+
+	mmc_claim_host(host);
+
+	/*
+	 * Check for removed card and newly inserted ones. We check for
+	 * removed cards first so we can intelligently re-select the VDD.
+	 */
+	if (host->card) {
+		mmc_check_card(host->card);
+
+		mmc_release_host(host);
+
+		if (mmc_card_dead(host->card)) {
+			mmc_remove_card(host->card);
+			host->card = NULL;
+		}
+
+		goto out;
+	}
+
+	mmc_setup(host);
+
+	if (host->card && !mmc_card_dead(host->card)) {
+		/*
+		 * (Re-)calculate the fastest clock rate which the
+		 * attached cards and the host support.
+		 */
+		host->ios.clock = mmc_calculate_clock(host);
+		mmc_set_ios(host);
+	}
+
+	mmc_release_host(host);
+
+	/*
+	 * If this is a new and good card, register it.
+	 */
+	if (host->card && !mmc_card_dead(host->card)) {
+		if (mmc_register_card(host->card))
+			mmc_card_set_dead(host->card);
+	}
+
+	/*
+	 * If this card is dead, destroy it.
+	 */
+	if (host->card && mmc_card_dead(host->card)) {
+		mmc_remove_card(host->card);
+		host->card = NULL;
+	}
+
+out:
+	/*
+	 * If we discover that there are no cards on the
+	 * bus, turn off the clock and power down.
+	 */
+	if (!host->card)
+		mmc_power_off(host);
+}
+
+
+/**
+ *	mmc_alloc_host - initialise the per-host structure.
+ *	@extra: sizeof private data structure
+ *	@dev: pointer to host device model structure
+ *
+ *	Initialise the per-host structure.
+ */
+struct mmc_host *mmc_alloc_host(int extra, struct device *dev)
+{
+	struct mmc_host *host;
+
+	host = mmc_alloc_host_sysfs(extra, dev);
+	if (host) {
+		spin_lock_init(&host->lock);
+		init_waitqueue_head(&host->wq);
+		INIT_DELAYED_WORK(&host->detect, mmc_rescan);
+
+		/*
+		 * By default, hosts do not support SGIO or large requests.
+		 * They have to set these according to their abilities.
+		 */
+		host->max_hw_segs = 1;
+		host->max_phys_segs = 1;
+		host->max_seg_size = PAGE_CACHE_SIZE;
+
+		host->max_req_size = PAGE_CACHE_SIZE;
+		host->max_blk_size = 512;
+		host->max_blk_count = PAGE_CACHE_SIZE / 512;
+	}
+
+	return host;
+}
+
+EXPORT_SYMBOL(mmc_alloc_host);
+
+/**
+ *	mmc_add_host - initialise host hardware
+ *	@host: mmc host
+ */
+int mmc_add_host(struct mmc_host *host)
+{
+	int ret;
+
+	ret = mmc_add_host_sysfs(host);
+	if (ret == 0) {
+		mmc_power_off(host);
+		mmc_detect_change(host, 0);
+	}
+
+	return ret;
+}
+
+EXPORT_SYMBOL(mmc_add_host);
+
+/**
+ *	mmc_remove_host - remove host hardware
+ *	@host: mmc host
+ *
+ *	Unregister and remove all cards associated with this host,
+ *	and power down the MMC bus.
+ */
+void mmc_remove_host(struct mmc_host *host)
+{
+#ifdef CONFIG_MMC_DEBUG
+	mmc_claim_host(host);
+	host->removed = 1;
+	mmc_release_host(host);
+#endif
+
+	mmc_flush_scheduled_work();
+
+	if (host->card) {
+		mmc_remove_card(host->card);
+		host->card = NULL;
+	}
+
+	mmc_power_off(host);
+	mmc_remove_host_sysfs(host);
+}
+
+EXPORT_SYMBOL(mmc_remove_host);
+
+/**
+ *	mmc_free_host - free the host structure
+ *	@host: mmc host
+ *
+ *	Free the host once all references to it have been dropped.
+ */
+void mmc_free_host(struct mmc_host *host)
+{
+	mmc_free_host_sysfs(host);
+}
+
+EXPORT_SYMBOL(mmc_free_host);
+
+#ifdef CONFIG_PM
+
+/**
+ *	mmc_suspend_host - suspend a host
+ *	@host: mmc host
+ *	@state: suspend mode (PM_SUSPEND_xxx)
+ */
+int mmc_suspend_host(struct mmc_host *host, pm_message_t state)
+{
+	mmc_flush_scheduled_work();
+
+	if (host->card) {
+		mmc_remove_card(host->card);
+		host->card = NULL;
+	}
+
+	mmc_power_off(host);
+
+	return 0;
+}
+
+EXPORT_SYMBOL(mmc_suspend_host);
+
+/**
+ *	mmc_resume_host - resume a previously suspended host
+ *	@host: mmc host
+ */
+int mmc_resume_host(struct mmc_host *host)
+{
+	mmc_rescan(&host->detect.work);
+
+	return 0;
+}
+
+EXPORT_SYMBOL(mmc_resume_host);
+
+#endif
+
+MODULE_LICENSE("GPL");
