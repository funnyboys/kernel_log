commit 254e175448b7dc2f40e41d8941ac925f07c5862b
Author: Pali Rohár <pali@kernel.org>
Date:   Wed May 27 13:08:58 2020 +0200

    mmc: core: Export device/vendor ids from Common CIS for SDIO cards
    
    Device/vendor ids from Common CIS (Card Information Structure) may be
    different as device/vendor ids from CIS on particular SDIO function.
    
    Kernel currently exports only device/vendor ids from SDIO functions and not
    "main" device/vendor ids from Common CIS.
    
    This patch exports "main" device/vendor ids for SDIO and SD combo cards at
    top level mmc device in sysfs hierarchy.
    
    Userspace can use e.g. udev rules to correctly match whole SDIO card based
    on Common CIS device/vendor id and not only one particular SDIO function.
    Having this information in userspace also helps developers to debug whole
    SDIO card as e.g. kernel mmc quirks use device/vendor ids from Common CIS
    and not from particular SDIO function. Also it allows to write userspace
    applications which list all connected SDIO cards based on CIS ids.
    
    Signed-off-by: Pali Rohár <pali@kernel.org>
    Reviewed-by: Marek Behún <marek.behun@nic.cz>
    Link: https://lore.kernel.org/r/20200527110858.17504-2-pali@kernel.org
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 43de3190d718..5a2210c25aa7 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -707,7 +707,12 @@ static ssize_t mmc_dsr_show(struct device *dev,
 
 static DEVICE_ATTR(dsr, S_IRUGO, mmc_dsr_show, NULL);
 
+MMC_DEV_ATTR(vendor, "0x%04x\n", card->cis.vendor);
+MMC_DEV_ATTR(device, "0x%04x\n", card->cis.device);
+
 static struct attribute *sd_std_attrs[] = {
+	&dev_attr_vendor.attr,
+	&dev_attr_device.attr,
 	&dev_attr_cid.attr,
 	&dev_attr_csd.attr,
 	&dev_attr_scr.attr,
@@ -726,7 +731,26 @@ static struct attribute *sd_std_attrs[] = {
 	&dev_attr_dsr.attr,
 	NULL,
 };
-ATTRIBUTE_GROUPS(sd_std);
+
+static umode_t sd_std_is_visible(struct kobject *kobj, struct attribute *attr,
+				 int index)
+{
+	struct device *dev = container_of(kobj, struct device, kobj);
+	struct mmc_card *card = mmc_dev_to_card(dev);
+
+	/* CIS vendor and device ids are available only for Combo cards */
+	if ((attr == &dev_attr_vendor.attr || attr == &dev_attr_device.attr) &&
+	    card->type != MMC_TYPE_SD_COMBO)
+		return 0;
+
+	return attr->mode;
+}
+
+static const struct attribute_group sd_std_group = {
+	.attrs = sd_std_attrs,
+	.is_visible = sd_std_is_visible,
+};
+__ATTRIBUTE_GROUPS(sd_std);
 
 struct device_type sd_type = {
 	.groups = sd_std_groups,

commit 9d624f4f6df5d358b5ab7eb99ef3ae5e2f091f0c
Author: Jisheng Zhang <Jisheng.Zhang@synaptics.com>
Date:   Fri Apr 10 14:57:12 2020 +0800

    mmc: sd: use HIGH_SPEED_BUS_SPEED in mmc_sd_switch_hs()
    
    Use the well defined HIGH_SPEED_BUS_SPEED macro in mmc_sd_switch_hs()
    to make code more readable.
    
    Signed-off-by: Jisheng Zhang <Jisheng.Zhang@synaptics.com>
    Link: https://lore.kernel.org/r/20200410145643.630b0731@xhacker.debian
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 76c7add367d5..43de3190d718 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -376,11 +376,11 @@ int mmc_sd_switch_hs(struct mmc_card *card)
 	if (!status)
 		return -ENOMEM;
 
-	err = mmc_sd_switch(card, 1, 0, 1, status);
+	err = mmc_sd_switch(card, 1, 0, HIGH_SPEED_BUS_SPEED, status);
 	if (err)
 		goto out;
 
-	if ((status[16] & 0xF) != 1) {
+	if ((status[16] & 0xF) != HIGH_SPEED_BUS_SPEED) {
 		pr_warn("%s: Problem switching card into high-speed mode!\n",
 			mmc_hostname(card->host));
 		err = 0;

commit 045d705dc1fba0d881fe22ad76ebe1b44647cdac
Author: Baolin Wang <baolin.wang@linaro.org>
Date:   Wed Feb 12 12:12:57 2020 +0800

    mmc: core: Enable the MMC host software queue for the SD card
    
    Enable the MMC host software queue for the SD card if the host controller
    supports the MMC host software queue.
    
    On my Spreadtrum platform, I did not see any obvious performance changes
    in 4K block size when changing to use hsq for the SD cards, I think the
    reason is the SD card works at a low speed on my platform, and most of
    time is spent in the hardware. But we can see some obvious improvements
    when enabling the packed request based on hsq, that's why we still add hsq
    support for the SD cards.
    
    Signed-off-by: Baolin Wang <baolin.wang@linaro.org>
    Signed-off-by: Baolin Wang <baolin.wang7@gmail.com>
    Link: https://lore.kernel.org/r/0065b4631fef2d61c3b89d14a4ea4f2b7499ea56.1581478568.git.baolin.wang7@gmail.com
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index fe914ff5f5d6..76c7add367d5 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -1082,6 +1082,16 @@ static int mmc_sd_init_card(struct mmc_host *host, u32 ocr,
 		}
 	}
 
+	if (host->cqe_ops && !host->cqe_enabled) {
+		err = host->cqe_ops->cqe_enable(host, card);
+		if (!err) {
+			host->cqe_enabled = true;
+			host->hsq_enabled = true;
+			pr_info("%s: Host Software Queue enabled\n",
+				mmc_hostname(host));
+		}
+	}
+
 	if (host->caps2 & MMC_CAP2_AVOID_3_3V &&
 	    host->ios.signal_voltage == MMC_SIGNAL_VOLTAGE_330) {
 		pr_err("%s: Host failed to negotiate down from 3.3V\n",

commit 72741084d903e65e121c27bd29494d941729d4a1
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Tue Aug 27 10:10:43 2019 +0200

    mmc: core: Fix init of SD cards reporting an invalid VDD range
    
    The OCR register defines the supported range of VDD voltages for SD cards.
    However, it has turned out that some SD cards reports an invalid voltage
    range, for example having bit7 set.
    
    When a host supports MMC_CAP2_FULL_PWR_CYCLE and some of the voltages from
    the invalid VDD range, this triggers the core to run a power cycle of the
    card to try to initialize it at the lowest common supported voltage.
    Obviously this fails, since the card can't support it.
    
    Let's fix this problem, by clearing invalid bits from the read OCR register
    for SD cards, before proceeding with the VDD voltage negotiation.
    
    Cc: stable@vger.kernel.org
    Reported-by: Philip Langdale <philipl@overt.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Philip Langdale <philipl@overt.org>
    Tested-by: Philip Langdale <philipl@overt.org>
    Tested-by: Manuel Presnitz <mail@mpy.de>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index d681e8aaca83..fe914ff5f5d6 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -1292,6 +1292,12 @@ int mmc_attach_sd(struct mmc_host *host)
 			goto err;
 	}
 
+	/*
+	 * Some SD cards claims an out of spec VDD voltage range. Let's treat
+	 * these bits as being in-valid and especially also bit7.
+	 */
+	ocr &= ~0x7FFF;
+
 	rocr = mmc_select_voltage(host, ocr);
 
 	/*

commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index d3d32f9a2cb1..d681e8aaca83 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -1,13 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  *  linux/drivers/mmc/core/sd.c
  *
  *  Copyright (C) 2003-2004 Russell King, All Rights Reserved.
  *  SD support Copyright (C) 2004 Ian Molton, All Rights Reserved.
  *  Copyright (C) 2005-2007 Pierre Ossman, All Rights Reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 
 #include <linux/err.h>

commit 9e4be8d03f50d1b25c38e2b59e73b194c130df7d
Author: Raul E Rangel <rrangel@chromium.org>
Date:   Mon Apr 29 11:32:39 2019 -0600

    mmc: core: Verify SD bus width
    
    The SD Physical Layer Spec says the following: Since the SD Memory Card
    shall support at least the two bus modes 1-bit or 4-bit width, then any SD
    Card shall set at least bits 0 and 2 (SD_BUS_WIDTH="0101").
    
    This change verifies the card has specified a bus width.
    
    AMD SDHC Device 7806 can get into a bad state after a card disconnect
    where anything transferred via the DATA lines will always result in a
    zero filled buffer. Currently the driver will continue without error if
    the HC is in this condition. A block device will be created, but reading
    from it will result in a zero buffer. This makes it seem like the SD
    device has been erased, when in actuality the data is never getting
    copied from the DATA lines to the data buffer.
    
    SCR is the first command in the SD initialization sequence that uses the
    DATA lines. By checking that the response was invalid, we can abort
    mounting the card.
    
    Reviewed-by: Avri Altman <avri.altman@wdc.com>
    Signed-off-by: Raul E Rangel <rrangel@chromium.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 265e1aeeb9d8..d3d32f9a2cb1 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -221,6 +221,14 @@ static int mmc_decode_scr(struct mmc_card *card)
 
 	if (scr->sda_spec3)
 		scr->cmds = UNSTUFF_BITS(resp, 32, 2);
+
+	/* SD Spec says: any SD Card shall set at least bits 0 and 2 */
+	if (!(scr->bus_widths & SD_SCR_BUS_WIDTH_1) ||
+	    !(scr->bus_widths & SD_SCR_BUS_WIDTH_4)) {
+		pr_err("%s: invalid bus width\n", mmc_hostname(card->host));
+		return -EINVAL;
+	}
+
 	return 0;
 }
 

commit 099b648116090acf0c65c8df867aa1cb42476f3b
Author: hongjiefang <hongjiefang@asrmicro.com>
Date:   Thu Feb 28 14:08:28 2019 +0800

    mmc: core: Add a debug print when the card may have been replaced
    
    If the card was removed in suspended state and a new one was inserted,
    print a debug log when the check detects that it's not the old card.
    
    Signed-off-by: hongjiefang <hongjiefang@asrmicro.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 2b4fc2205b53..265e1aeeb9d8 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -951,8 +951,11 @@ static int mmc_sd_init_card(struct mmc_host *host, u32 ocr,
 		return err;
 
 	if (oldcard) {
-		if (memcmp(cid, oldcard->raw_cid, sizeof(cid)) != 0)
+		if (memcmp(cid, oldcard->raw_cid, sizeof(cid)) != 0) {
+			pr_debug("%s: Perhaps the card was replaced\n",
+				mmc_hostname(host));
 			return -ENOENT;
+		}
 
 		card = oldcard;
 	} else {

commit bc47e2f6f9e261ea07c678c3cad76eb5590c0fea
Author: Avri Altman <avri.altman@wdc.com>
Date:   Tue Feb 26 17:10:24 2019 +0200

    mmc: core: Add discard support to sd
    
    SD spec v5.1 adds discard support. The flows and commands are similar to
    mmc, so just set the discard arg in CMD38.
    
    A host which supports DISCARD shall check if the DISCARD_SUPPORT (b313)
    is set in the SD_STATUS register.  If the card does not support discard,
    the host shall not issue DISCARD command, but ERASE command instead.
    
    Post the DISCARD operation, the card may de-allocate the discarded
    blocks partially or completely. So the host mustn't make any assumptions
    concerning the content of the discarded region. This is unlike ERASE
    command, in which the region is guaranteed to contain either '0's or
    '1's, depends on the content of DATA_STAT_AFTER_ERASE (b55) in the scr
    register.
    
    One more important difference compared to ERASE is the busy timeout
    which we will address on the next patch.
    
    Signed-off-by: Avri Altman <avri.altman@wdc.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index c2db94dab711..2b4fc2205b53 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -231,6 +231,8 @@ static int mmc_read_ssr(struct mmc_card *card)
 {
 	unsigned int au, es, et, eo;
 	__be32 *raw_ssr;
+	u32 resp[4] = {};
+	u8 discard_support;
 	int i;
 
 	if (!(card->csd.cmdclass & CCC_APP_SPEC)) {
@@ -276,7 +278,13 @@ static int mmc_read_ssr(struct mmc_card *card)
 		}
 	}
 
-	card->erase_arg = SD_ERASE_ARG;
+	/*
+	 * starting SD5.1 discard is supported if DISCARD_SUPPORT (b313) is set
+	 */
+	resp[3] = card->raw_ssr[6];
+	discard_support = UNSTUFF_BITS(resp, 313 - 288, 1);
+	card->erase_arg = (card->scr.sda_specx && discard_support) ?
+			    SD_DISCARD_ARG : SD_ERASE_ARG;
 
 	return 0;
 }

commit 68539e2bc34437d8c5fbcc234dddcc40bd6bb1cb
Author: Avri Altman <avri.altman@wdc.com>
Date:   Wed Feb 6 13:28:06 2019 +0200

    mmc: core: Indicate SD specs higher than 4.0
    
    SD specs version 4.x and 5.x have a dedicated slices in the SCR register.
    Higher versions will rely on a combination of the existing fields.
    
    Signed-off-by: Avri Altman <avri.altman@wdc.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index bd48b28d641b..c2db94dab711 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -209,6 +209,11 @@ static int mmc_decode_scr(struct mmc_card *card)
 		/* Check if Physical Layer Spec v3.0 is supported */
 		scr->sda_spec3 = UNSTUFF_BITS(resp, 47, 1);
 
+	if (scr->sda_spec3) {
+		scr->sda_spec4 = UNSTUFF_BITS(resp, 42, 1);
+		scr->sda_specx = UNSTUFF_BITS(resp, 38, 4);
+	}
+
 	if (UNSTUFF_BITS(resp, 55, 1))
 		card->erased_byte = 0xFF;
 	else

commit 01904ff77676ca6c88e972906ed204a2dfbabab6
Author: Avri Altman <avri.altman@wdc.com>
Date:   Wed Feb 6 13:28:05 2019 +0200

    mmc: core: Calculate the discard arg only once
    
    In MMC, the discard arg is a read-only ext_csd parameter - set it once
    on card init. To be consistent, do that for SD as well even though its
    discard arg is always 0x0.
    
    Signed-off-by: Avri Altman <avri.altman@wdc.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index d0d9f90e7cdf..bd48b28d641b 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -271,6 +271,8 @@ static int mmc_read_ssr(struct mmc_card *card)
 		}
 	}
 
+	card->erase_arg = SD_ERASE_ARG;
+
 	return 0;
 }
 

commit 3a3db6030b64ceb4b4e41a6811168c5d90a9f7f8
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu Apr 5 13:24:43 2018 +0200

    mmc: core: Rename ->reset() bus ops to ->hw_reset()
    
    The bus ops ->reset() executes a full HW reset of the card, as the calling
    function mmc_hw_reset() also indicates by its name. Let's convert to follow
    the similar names, for both the bus ops callback and for the corresponding
    bus ops functions, as to clarify the purpose of code.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Tested-by: Quentin Schulz <quentin.schulz@bootlin.com>
    Reviewed-by: Shawn Lin <shawn.lin@rock-chips.com>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 7f87a5354f9f..d0d9f90e7cdf 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -1222,7 +1222,7 @@ static int mmc_sd_runtime_resume(struct mmc_host *host)
 	return 0;
 }
 
-static int mmc_sd_reset(struct mmc_host *host)
+static int mmc_sd_hw_reset(struct mmc_host *host)
 {
 	mmc_power_cycle(host, host->card->ocr);
 	return mmc_sd_init_card(host, host->card->ocr, host->card);
@@ -1237,7 +1237,7 @@ static const struct mmc_bus_ops mmc_sd_ops = {
 	.resume = mmc_sd_resume,
 	.alive = mmc_sd_alive,
 	.shutdown = mmc_sd_suspend,
-	.reset = mmc_sd_reset,
+	.hw_reset = mmc_sd_hw_reset,
 };
 
 /*

commit 247cfe53557524a94dd1001d19e5aa50bd5aca81
Author: Kyle Roeschley <kyle.roeschley@ni.com>
Date:   Fri Apr 13 16:54:57 2018 -0500

    mmc: core: Add capability to avoid 3.3V signaling
    
    Some SD host controllers cannot handle extended use of 3.3V signaling.
    To accommodate these controllers, add a capability that requires us to
    negotiate the voltage down from 3.3V during card initialization.
    
    Signed-off-by: Kyle Roeschley <kyle.roeschley@ni.com>
    Signed-off-by: Jennifer Dahm <jennifer.dahm@ni.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index baf3d5da4ccb..7f87a5354f9f 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -1058,6 +1058,14 @@ static int mmc_sd_init_card(struct mmc_host *host, u32 ocr,
 			mmc_set_bus_width(host, MMC_BUS_WIDTH_4);
 		}
 	}
+
+	if (host->caps2 & MMC_CAP2_AVOID_3_3V &&
+	    host->ios.signal_voltage == MMC_SIGNAL_VOLTAGE_330) {
+		pr_err("%s: Host failed to negotiate down from 3.3V\n",
+			mmc_hostname(host));
+		err = -EINVAL;
+		goto free_card;
+	}
 done:
 	host->card = card;
 	return 0;

commit 974e85e90c84a32f49b70c6615f1e8f156f38a3c
Author: Harish Jenny K N <harish_kandiga@mentor.com>
Date:   Wed Mar 7 10:31:42 2018 +0530

    mmc: core: Export card RCA register via sysfs
    
    This patch exports RCA register to sysfs which will help in reading the
    disk identification information.
    
    Reviewed-by: Shawn Lin <shawn.lin@rock-chips.com>
    Signed-off-by: Harish Jenny K N <harish_kandiga@mentor.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 329e6005d9ad..baf3d5da4ccb 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -668,6 +668,7 @@ MMC_DEV_ATTR(name, "%s\n", card->cid.prod_name);
 MMC_DEV_ATTR(oemid, "0x%04x\n", card->cid.oemid);
 MMC_DEV_ATTR(serial, "0x%08x\n", card->cid.serial);
 MMC_DEV_ATTR(ocr, "0x%08x\n", card->ocr);
+MMC_DEV_ATTR(rca, "0x%04x\n", card->rca);
 
 
 static ssize_t mmc_dsr_show(struct device *dev,
@@ -701,6 +702,7 @@ static struct attribute *sd_std_attrs[] = {
 	&dev_attr_oemid.attr,
 	&dev_attr_serial.attr,
 	&dev_attr_ocr.attr,
+	&dev_attr_rca.attr,
 	&dev_attr_dsr.attr,
 	NULL,
 };

commit 3715ce57f4d26d09fc1813d157286abc5aa319a5
Author: Shawn Lin <shawn.lin@rock-chips.com>
Date:   Tue Feb 27 09:26:35 2018 +0800

    mmc: sd: Remove redundant err assignment from mmc_read_switch
    
    Variable err would be firstly initialized by the return value of
    mmc_sd_switch().
    
    Signed-off-by: Shawn Lin <shawn.lin@rock-chips.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index d094497480ca..329e6005d9ad 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -291,8 +291,6 @@ static int mmc_read_switch(struct mmc_card *card)
 		return 0;
 	}
 
-	err = -EIO;
-
 	status = kmalloc(64, GFP_KERNEL);
 	if (!status)
 		return -ENOMEM;

commit d6743a8a1ae38269a41094ad14d7ef86199f661d
Author: Shawn Lin <shawn.lin@rock-chips.com>
Date:   Tue Feb 27 08:49:25 2018 +0800

    mmc: core: Don't try UHS-I mode if 4-bit mode isn't supported
    
    Per SD specification physical layer v4.0, section 3.9.4, it
    says "UHS-I supports only 4-bit mode. Host shall select 4-bit
    mode by ACMD6. However mmc_sd_init_uhs_card() still go ahead
    to initialize the cards anyway, whether card or host won't
    support 4-bit mode.
    
      This breaks the platforms which could support UHS-I mode but on
    some certain boards only support 1-bit mode with a UHS-I card inserted,
    as all the tuning process is broken due to this. Alternatively, we
    should check the return value from mmc_set_bus_width() to see if host
    could finish the request to switch the bus width on its side. But that
    needs more thing to do than this patch that just bails out early to try
    high speed mode if 4-bit mode isn't available for whatever reason. And
    this patch could also fix the same problem for sdio since R4_18V_PRESENT
    won't be set for ocr when mmc_sdio_init_card() finds mmc_host_uhs()
    is false.
    
      Note that this patch doesn't keep the checking of card->scr.sda_spec3
    and comparing card->scr.bus_widths with SD_SCR_BUS_WIDTH_4 within
    mmc_sd_init_uhs_card() since if the sd cards response with SD_ROCR_S18A,
    it definitely supports UHS-I mode, which implicitly means these checkings
    are always true.
    
    Signed-off-by: Shawn Lin <shawn.lin@rock-chips.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 62b84dd8f9fe..d094497480ca 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -582,9 +582,6 @@ static int mmc_sd_init_uhs_card(struct mmc_card *card)
 	int err;
 	u8 *status;
 
-	if (!card->scr.sda_spec3)
-		return 0;
-
 	if (!(card->csd.cmdclass & CCC_SWITCH))
 		return 0;
 
@@ -593,14 +590,11 @@ static int mmc_sd_init_uhs_card(struct mmc_card *card)
 		return -ENOMEM;
 
 	/* Set 4-bit bus width */
-	if ((card->host->caps & MMC_CAP_4_BIT_DATA) &&
-	    (card->scr.bus_widths & SD_SCR_BUS_WIDTH_4)) {
-		err = mmc_app_set_bus_width(card, MMC_BUS_WIDTH_4);
-		if (err)
-			goto out;
+	err = mmc_app_set_bus_width(card, MMC_BUS_WIDTH_4);
+	if (err)
+		goto out;
 
-		mmc_set_bus_width(card->host, MMC_BUS_WIDTH_4);
-	}
+	mmc_set_bus_width(card->host, MMC_BUS_WIDTH_4);
 
 	/*
 	 * Select the bus speed mode depending on host
@@ -1033,7 +1027,7 @@ static int mmc_sd_init_card(struct mmc_host *host, u32 ocr,
 	}
 
 	/* Initialization sequence for UHS-I cards */
-	if (rocr & SD_ROCR_S18A) {
+	if (rocr & SD_ROCR_S18A && mmc_host_uhs(host)) {
 		err = mmc_sd_init_uhs_card(card);
 		if (err)
 			goto free_card;

commit c892b0d81705c566f575e489efc3c50762db1bde
Author: Bastian Stender <bst@pengutronix.de>
Date:   Tue Nov 28 09:24:07 2017 +0100

    mmc: core: prepend 0x to OCR entry in sysfs
    
    The sysfs entry "ocr" was missing the 0x prefix to identify it as hex
    formatted.
    
    Fixes: 5fb06af7a33b ("mmc: core: Extend sysfs with OCR register")
    Signed-off-by: Bastian Stender <bst@pengutronix.de>
    Cc: <stable@vger.kernel.org> # v4.8+
    [Ulf: Amended change to also cover SD-cards]
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 45bf78f32716..62b84dd8f9fe 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -675,7 +675,7 @@ MMC_DEV_ATTR(manfid, "0x%06x\n", card->cid.manfid);
 MMC_DEV_ATTR(name, "%s\n", card->cid.prod_name);
 MMC_DEV_ATTR(oemid, "0x%04x\n", card->cid.oemid);
 MMC_DEV_ATTR(serial, "0x%08x\n", card->cid.serial);
-MMC_DEV_ATTR(ocr, "%08x\n", card->ocr);
+MMC_DEV_ATTR(ocr, "0x%08x\n", card->ocr);
 
 
 static ssize_t mmc_dsr_show(struct device *dev,

commit 6a11fc47f175c8d87018e89cb58e2d36c66534cb
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Mon Sep 25 11:29:04 2017 +0300

    mmc: sd: Fix signal voltage when there is no power cycle
    
    Some boards have SD card connectors where the power rail cannot be switched
    off by the driver. However there are various circumstances when a card
    might be re-initialized, such as after system resume, warm re-boot, or
    error handling. However, a UHS card will continue to use 1.8V signaling
    unless it is power cycled.
    
    If the card has not been power cycled, it may still be using 1.8V
    signaling. According to the SD spec., the Bus Speed Mode (function group 1)
    bits 2 to 4 are zero if the card is initialized at 3.3V signal level. Thus
    they can be used to determine if the card has already switched to 1.8V
    signaling. Detect that situation and try to initialize a UHS-I (1.8V)
    transfer mode.
    
    Tested with the following cards:
      Transcend 4GB High Speed
      Kingston 64GB SDR104
      Lexar by Micron HIGH-PERFORMANCE 300x 16GB DDR50
      SanDisk Ultra 8GB DDR50
      Transcend Ultimate 600x 16GB SDR104
      Transcend Premium 300x 64GB SDR104
      Lexar by Micron Professional 1000x 32GB UHS-II SDR104
      SanDisk Extreme Pro 16GB SDR104
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Tested-by: Zhoujie Wu <zjwu@marvell.com>
    Reviewed-by: Shawn Lin <shawn.lin@rock-chips.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 2036b2b4835c..45bf78f32716 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -908,6 +908,18 @@ unsigned mmc_sd_get_max_clock(struct mmc_card *card)
 	return max_dtr;
 }
 
+static bool mmc_sd_card_using_v18(struct mmc_card *card)
+{
+	/*
+	 * According to the SD spec., the Bus Speed Mode (function group 1) bits
+	 * 2 to 4 are zero if the card is initialized at 3.3V signal level. Thus
+	 * they can be used to determine if the card has already switched to
+	 * 1.8V signaling.
+	 */
+	return card->sw_caps.sd3_bus_mode &
+	       (SD_MODE_UHS_SDR50 | SD_MODE_UHS_SDR104 | SD_MODE_UHS_DDR50);
+}
+
 /*
  * Handle the detection and initialisation of a card.
  *
@@ -921,9 +933,10 @@ static int mmc_sd_init_card(struct mmc_host *host, u32 ocr,
 	int err;
 	u32 cid[4];
 	u32 rocr = 0;
+	bool v18_fixup_failed = false;
 
 	WARN_ON(!host->claimed);
-
+retry:
 	err = mmc_sd_get_cid(host, ocr, cid, &rocr);
 	if (err)
 		return err;
@@ -989,6 +1002,36 @@ static int mmc_sd_init_card(struct mmc_host *host, u32 ocr,
 	if (err)
 		goto free_card;
 
+	/*
+	 * If the card has not been power cycled, it may still be using 1.8V
+	 * signaling. Detect that situation and try to initialize a UHS-I (1.8V)
+	 * transfer mode.
+	 */
+	if (!v18_fixup_failed && !mmc_host_is_spi(host) && mmc_host_uhs(host) &&
+	    mmc_sd_card_using_v18(card) &&
+	    host->ios.signal_voltage != MMC_SIGNAL_VOLTAGE_180) {
+		/*
+		 * Re-read switch information in case it has changed since
+		 * oldcard was initialized.
+		 */
+		if (oldcard) {
+			err = mmc_read_switch(card);
+			if (err)
+				goto free_card;
+		}
+		if (mmc_sd_card_using_v18(card)) {
+			if (mmc_host_set_uhs_voltage(host) ||
+			    mmc_sd_init_uhs_card(card)) {
+				v18_fixup_failed = true;
+				mmc_power_cycle(host, ocr);
+				if (!oldcard)
+					mmc_remove_card(card);
+				goto retry;
+			}
+			goto done;
+		}
+	}
+
 	/* Initialization sequence for UHS-I cards */
 	if (rocr & SD_ROCR_S18A) {
 		err = mmc_sd_init_uhs_card(card);
@@ -1021,7 +1064,7 @@ static int mmc_sd_init_card(struct mmc_host *host, u32 ocr,
 			mmc_set_bus_width(host, MMC_BUS_WIDTH_4);
 		}
 	}
-
+done:
 	host->card = card;
 	return 0;
 

commit 6c0cedd1ef9527ef13e66875746570e76a3188a7
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Fri Sep 22 15:36:51 2017 +0300

    mmc: core: Introduce host claiming by context
    
    Currently the host can be claimed by a task.  Change this so that the host
    can be claimed by a context that may or may not be a task.  This provides
    for the host to be claimed by a block driver queue to support blk-mq, while
    maintaining compatibility with the existing use of mmc_claim_host().
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 4fd1620b732d..2036b2b4835c 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -1056,14 +1056,14 @@ static void mmc_sd_detect(struct mmc_host *host)
 {
 	int err;
 
-	mmc_get_card(host->card);
+	mmc_get_card(host->card, NULL);
 
 	/*
 	 * Just check if our card has been removed.
 	 */
 	err = _mmc_detect_card_removed(host);
 
-	mmc_put_card(host->card);
+	mmc_put_card(host->card, NULL);
 
 	if (err) {
 		mmc_sd_remove(host);

commit 4406ae215b5a1dd59d941c1323b9f40d241357ac
Author: Shawn Lin <shawn.lin@rock-chips.com>
Date:   Wed Aug 2 11:12:42 2017 +0800

    mmc: core: correct taac parameter according to the specification
    
    Per the spec of JESD84-B51, section 7.3, replace tacc with taac to
    fix the obvious typo.
    
    Signed-off-by: Shawn Lin <shawn.lin@rock-chips.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index a1b0aa14d5e3..4fd1620b732d 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -39,11 +39,11 @@ static const unsigned char tran_mant[] = {
 	35,	40,	45,	50,	55,	60,	70,	80,
 };
 
-static const unsigned int tacc_exp[] = {
+static const unsigned int taac_exp[] = {
 	1,	10,	100,	1000,	10000,	100000,	1000000, 10000000,
 };
 
-static const unsigned int tacc_mant[] = {
+static const unsigned int taac_mant[] = {
 	0,	10,	12,	13,	15,	20,	25,	30,
 	35,	40,	45,	50,	55,	60,	70,	80,
 };
@@ -111,8 +111,8 @@ static int mmc_decode_csd(struct mmc_card *card)
 	case 0:
 		m = UNSTUFF_BITS(resp, 115, 4);
 		e = UNSTUFF_BITS(resp, 112, 3);
-		csd->tacc_ns	 = (tacc_exp[e] * tacc_mant[m] + 9) / 10;
-		csd->tacc_clks	 = UNSTUFF_BITS(resp, 104, 8) * 100;
+		csd->taac_ns	 = (taac_exp[e] * taac_mant[m] + 9) / 10;
+		csd->taac_clks	 = UNSTUFF_BITS(resp, 104, 8) * 100;
 
 		m = UNSTUFF_BITS(resp, 99, 4);
 		e = UNSTUFF_BITS(resp, 96, 3);
@@ -148,8 +148,8 @@ static int mmc_decode_csd(struct mmc_card *card)
 		 */
 		mmc_card_set_blockaddr(card);
 
-		csd->tacc_ns	 = 0; /* Unused */
-		csd->tacc_clks	 = 0; /* Unused */
+		csd->taac_ns	 = 0; /* Unused */
+		csd->taac_clks	 = 0; /* Unused */
 
 		m = UNSTUFF_BITS(resp, 99, 4);
 		e = UNSTUFF_BITS(resp, 96, 3);

commit a1473732507499ec4002ad8cd33e645579d61a26
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu Jun 8 15:27:43 2017 +0200

    mmc: core: Re-factor code for sending CID
    
    Instead of having the caller to check for SPI mode, let's leave that to
    internals of mmc_send_cid(). In this way the code gets cleaner and it
    becomes clear what is specific to SPI and non-SPI mode.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Reviewed-by: Shawn Lin <shawn.lin@rock-chips.com>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 1d7542daecbe..a1b0aa14d5e3 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -788,11 +788,7 @@ int mmc_sd_get_cid(struct mmc_host *host, u32 ocr, u32 *cid, u32 *rocr)
 		}
 	}
 
-	if (mmc_host_is_spi(host))
-		err = mmc_send_cid(host, cid);
-	else
-		err = mmc_all_send_cid(host, cid);
-
+	err = mmc_send_cid(host, cid);
 	return err;
 }
 

commit e1df7ae30b430a3183d2a0a9b3e0b802f9d5ff49
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Fri May 19 13:15:27 2017 +0200

    mmc: core: Delete error messages for failed memory allocations
    
    Omit an extra message for memory allocation failures.
    
    This issue was detected by using the Coccinelle software.
    
    Link: http://events.linuxfoundation.org/sites/events/files/slides/LCJ16-Refactor_Strings-WSang_0.pdf
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index d109634fbfce..1d7542daecbe 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -294,12 +294,8 @@ static int mmc_read_switch(struct mmc_card *card)
 	err = -EIO;
 
 	status = kmalloc(64, GFP_KERNEL);
-	if (!status) {
-		pr_err("%s: could not allocate a buffer for "
-			"switch capabilities.\n",
-			mmc_hostname(card->host));
+	if (!status)
 		return -ENOMEM;
-	}
 
 	/*
 	 * Find out the card's support bits with a mode 0 operation.
@@ -359,11 +355,8 @@ int mmc_sd_switch_hs(struct mmc_card *card)
 		return 0;
 
 	status = kmalloc(64, GFP_KERNEL);
-	if (!status) {
-		pr_err("%s: could not allocate a buffer for "
-			"switch capabilities.\n", mmc_hostname(card->host));
+	if (!status)
 		return -ENOMEM;
-	}
 
 	err = mmc_sd_switch(card, 1, 0, 1, status);
 	if (err)
@@ -596,11 +589,8 @@ static int mmc_sd_init_uhs_card(struct mmc_card *card)
 		return 0;
 
 	status = kmalloc(64, GFP_KERNEL);
-	if (!status) {
-		pr_err("%s: could not allocate a buffer for "
-			"switch capabilities.\n", mmc_hostname(card->host));
+	if (!status)
 		return -ENOMEM;
-	}
 
 	/* Set 4-bit bus width */
 	if ((card->host->caps & MMC_CAP_4_BIT_DATA) &&

commit 06c9ccb78e68e2e9b69e736fc0a39fb13be49b74
Author: Winkler, Tomas <tomas.winkler@intel.com>
Date:   Sun Apr 2 23:56:03 2017 +0300

    mmc: core: add proper be32 annotation
    
    Annotate big endian values correctly and make sparse happy.
    In mmc_app_send_scr remove scr function parameter as it was
    updating card->raw_scr anyway.
    
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 89531b48ae84..d109634fbfce 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -225,7 +225,7 @@ static int mmc_decode_scr(struct mmc_card *card)
 static int mmc_read_ssr(struct mmc_card *card)
 {
 	unsigned int au, es, et, eo;
-	u32 *raw_ssr;
+	__be32 *raw_ssr;
 	int i;
 
 	if (!(card->csd.cmdclass & CCC_APP_SPEC)) {
@@ -853,7 +853,7 @@ int mmc_sd_setup_card(struct mmc_host *host, struct mmc_card *card,
 		/*
 		 * Fetch SCR from card.
 		 */
-		err = mmc_app_send_scr(card, card->raw_scr);
+		err = mmc_app_send_scr(card);
 		if (err)
 			return err;
 

commit 2ed573b603f78289dd1435c94597aa25a97e2b76
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Wed Jan 25 10:25:01 2017 +0100

    mmc: core: Clarify usage of mmc_set_signal_voltage()
    
    The mmc_set_signal_voltage() function is used for SD/SDIO when switching to
    1.8V for UHS mode. To clarify this let's do the following changes.
    
    - We are always providing MMC_SIGNAL_VOLTAGE_180 as the signal_voltage
      parameter to the function. Then, let's just remove the parameter as it
      serves no purpose.
    - Rename the function to mmc_set_uhs_voltage().
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Shawn Lin <shawn.lin@rock-chips.com>
    Tested-by: Jan Glauber <jglauber@cavium.com>
    Tested-by: Stefan Wahren <stefan.wahren@i2se.com>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 8b4f13943712..89531b48ae84 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -788,8 +788,7 @@ int mmc_sd_get_cid(struct mmc_host *host, u32 ocr, u32 *cid, u32 *rocr)
 	 */
 	if (!mmc_host_is_spi(host) && rocr &&
 	   ((*rocr & 0x41000000) == 0x41000000)) {
-		err = mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_180,
-					pocr);
+		err = mmc_set_uhs_voltage(host, pocr);
 		if (err == -EAGAIN) {
 			retries--;
 			goto try_again;

commit 5857b29b96dcf208e4903ec6f20d132e6a77cac2
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri Jan 13 14:14:15 2017 +0100

    mmc: core: Move public functions from host.h to private headers
    
    A significant amount of functions are available through the public mmc
    host.h header file. Let's slim down this public mmc interface, as to
    prevent users from abusing it, by moving some of the functions to private
    mmc host.h header file.
    
    This change concentrates on moving the functions into private mmc headers,
    following changes may continue with additional clean-ups.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Reviewed-by: Shawn Lin <shawn.lin@rock-chips.com>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index d66b08d6f509..8b4f13943712 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -23,6 +23,7 @@
 
 #include "core.h"
 #include "card.h"
+#include "host.h"
 #include "bus.h"
 #include "mmc_ops.h"
 #include "sd.h"

commit 4facdde11394d44b3869807841042d059f074a07
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri Jan 13 14:14:14 2017 +0100

    mmc: core: Move public functions from card.h to private headers
    
    A significant amount of functions and other definitions are available
    through the public mmc card.h header file. Let's slim down this public mmc
    interface, as to prevent users from abusing it, by moving some of the
    functions/definitions to private mmc header files.
    
    This change concentrates on moving the functions into private mmc headers,
    following changes may continue with additional clean-ups.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Reviewed-by: Shawn Lin <shawn.lin@rock-chips.com>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index a614f37faf27..d66b08d6f509 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -22,6 +22,7 @@
 #include <linux/mmc/sd.h>
 
 #include "core.h"
+#include "card.h"
 #include "bus.h"
 #include "mmc_ops.h"
 #include "sd.h"

commit e85baa8868b016513c0f5738362402495b1a66a5
Author: Paul Burton <paul.burton@imgtec.com>
Date:   Fri Nov 11 14:22:36 2016 +0000

    mmc: sd: Meet alignment requirements for raw_ssr DMA
    
    The mmc_read_ssr() function results in DMA to the raw_ssr member of
    struct mmc_card, which is not guaranteed to be cache line aligned & thus
    might not meet the requirements set out in Documentation/DMA-API.txt:
    
      Warnings:  Memory coherency operates at a granularity called the cache
      line width.  In order for memory mapped by this API to operate
      correctly, the mapped region must begin exactly on a cache line
      boundary and end exactly on one (to prevent two separately mapped
      regions from sharing a single cache line).  Since the cache line size
      may not be known at compile time, the API will not enforce this
      requirement.  Therefore, it is recommended that driver writers who
      don't take special care to determine the cache line size at run time
      only map virtual regions that begin and end on page boundaries (which
      are guaranteed also to be cache line boundaries).
    
    On some systems where DMA is non-coherent this can lead to us losing
    data that shares cache lines with the raw_ssr array.
    
    Fix this by kmalloc'ing a temporary buffer to perform DMA into. kmalloc
    will ensure the buffer is suitably aligned, allowing the DMA to be
    performed without any loss of data.
    
    Signed-off-by: Paul Burton <paul.burton@imgtec.com>
    Fixes: 5275a652d296 ("mmc: sd: Export SD Status via “ssr” device attribute")
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index deb90c2ff6b4..a614f37faf27 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -223,6 +223,7 @@ static int mmc_decode_scr(struct mmc_card *card)
 static int mmc_read_ssr(struct mmc_card *card)
 {
 	unsigned int au, es, et, eo;
+	u32 *raw_ssr;
 	int i;
 
 	if (!(card->csd.cmdclass & CCC_APP_SPEC)) {
@@ -231,14 +232,21 @@ static int mmc_read_ssr(struct mmc_card *card)
 		return 0;
 	}
 
-	if (mmc_app_sd_status(card, card->raw_ssr)) {
+	raw_ssr = kmalloc(sizeof(card->raw_ssr), GFP_KERNEL);
+	if (!raw_ssr)
+		return -ENOMEM;
+
+	if (mmc_app_sd_status(card, raw_ssr)) {
 		pr_warn("%s: problem reading SD Status register\n",
 			mmc_hostname(card->host));
+		kfree(raw_ssr);
 		return 0;
 	}
 
 	for (i = 0; i < 16; i++)
-		card->raw_ssr[i] = be32_to_cpu(card->raw_ssr[i]);
+		card->raw_ssr[i] = be32_to_cpu(raw_ssr[i]);
+
+	kfree(raw_ssr);
 
 	/*
 	 * UNSTUFF_BITS only works with four u32s so we have to offset the

commit 349583d66620a7d3eda760c82119ab7a8c253272
Author: Shawn Lin <shawn.lin@rock-chips.com>
Date:   Wed Nov 2 15:25:48 2016 +0800

    mmc: core: remove BUG_ONs from sd
    
    BUG_ONs doesn't help anything except for stop the system from
    running. If it occurs, it implies we should deploy proper error
    handling for that. So this patch is gonna discard these meaningless
    BUG_ONs and deploy error handling if needed.
    
    Signed-off-by: Shawn Lin <shawn.lin@rock-chips.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 73c762a28dfe..deb90c2ff6b4 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -927,7 +927,6 @@ static int mmc_sd_init_card(struct mmc_host *host, u32 ocr,
 	u32 cid[4];
 	u32 rocr = 0;
 
-	BUG_ON(!host);
 	WARN_ON(!host->claimed);
 
 	err = mmc_sd_get_cid(host, ocr, cid, &rocr);
@@ -1043,9 +1042,6 @@ static int mmc_sd_init_card(struct mmc_host *host, u32 ocr,
  */
 static void mmc_sd_remove(struct mmc_host *host)
 {
-	BUG_ON(!host);
-	BUG_ON(!host->card);
-
 	mmc_remove_card(host->card);
 	host->card = NULL;
 }
@@ -1065,9 +1061,6 @@ static void mmc_sd_detect(struct mmc_host *host)
 {
 	int err;
 
-	BUG_ON(!host);
-	BUG_ON(!host->card);
-
 	mmc_get_card(host->card);
 
 	/*
@@ -1091,9 +1084,6 @@ static int _mmc_sd_suspend(struct mmc_host *host)
 {
 	int err = 0;
 
-	BUG_ON(!host);
-	BUG_ON(!host->card);
-
 	mmc_claim_host(host);
 
 	if (mmc_card_suspended(host->card))
@@ -1136,9 +1126,6 @@ static int _mmc_sd_resume(struct mmc_host *host)
 {
 	int err = 0;
 
-	BUG_ON(!host);
-	BUG_ON(!host->card);
-
 	mmc_claim_host(host);
 
 	if (!mmc_card_suspended(host->card))
@@ -1221,7 +1208,6 @@ int mmc_attach_sd(struct mmc_host *host)
 	int err;
 	u32 ocr, rocr;
 
-	BUG_ON(!host);
 	WARN_ON(!host->claimed);
 
 	err = mmc_send_app_op_cond(host, 0, &ocr);

commit 5275a652d296711aaf7f2f4173c8db153e5777c3
Author: Uri Yanai <uri.yanai@sandisk.com>
Date:   Sun Aug 14 11:46:36 2016 +0300

    mmc: sd: Export SD Status via “ssr” device attribute
    
    The SD Status register contains several important fields related to the
    SD Card proprietary features.
    Those fields may be used by user space applications for vendor specific
    usage.
    None of those fields are exported today by the driver to user space.
    In this patch, we are reading the SD Status register and exporting
    (using MMC_DEV_ATTR) the SD Status register to the user space.
    
    Signed-off-by: Uri Yanai <uri.yanai@sandisk.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 0123936241b0..73c762a28dfe 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -223,8 +223,7 @@ static int mmc_decode_scr(struct mmc_card *card)
 static int mmc_read_ssr(struct mmc_card *card)
 {
 	unsigned int au, es, et, eo;
-	int err, i;
-	u32 *ssr;
+	int i;
 
 	if (!(card->csd.cmdclass & CCC_APP_SPEC)) {
 		pr_warn("%s: card lacks mandatory SD Status function\n",
@@ -232,33 +231,27 @@ static int mmc_read_ssr(struct mmc_card *card)
 		return 0;
 	}
 
-	ssr = kmalloc(64, GFP_KERNEL);
-	if (!ssr)
-		return -ENOMEM;
-
-	err = mmc_app_sd_status(card, ssr);
-	if (err) {
+	if (mmc_app_sd_status(card, card->raw_ssr)) {
 		pr_warn("%s: problem reading SD Status register\n",
 			mmc_hostname(card->host));
-		err = 0;
-		goto out;
+		return 0;
 	}
 
 	for (i = 0; i < 16; i++)
-		ssr[i] = be32_to_cpu(ssr[i]);
+		card->raw_ssr[i] = be32_to_cpu(card->raw_ssr[i]);
 
 	/*
 	 * UNSTUFF_BITS only works with four u32s so we have to offset the
 	 * bitfield positions accordingly.
 	 */
-	au = UNSTUFF_BITS(ssr, 428 - 384, 4);
+	au = UNSTUFF_BITS(card->raw_ssr, 428 - 384, 4);
 	if (au) {
 		if (au <= 9 || card->scr.sda_spec3) {
 			card->ssr.au = sd_au_size[au];
-			es = UNSTUFF_BITS(ssr, 408 - 384, 16);
-			et = UNSTUFF_BITS(ssr, 402 - 384, 6);
+			es = UNSTUFF_BITS(card->raw_ssr, 408 - 384, 16);
+			et = UNSTUFF_BITS(card->raw_ssr, 402 - 384, 6);
 			if (es && et) {
-				eo = UNSTUFF_BITS(ssr, 400 - 384, 2);
+				eo = UNSTUFF_BITS(card->raw_ssr, 400 - 384, 2);
 				card->ssr.erase_timeout = (et * 1000) / es;
 				card->ssr.erase_offset = eo * 1000;
 			}
@@ -267,9 +260,8 @@ static int mmc_read_ssr(struct mmc_card *card)
 				mmc_hostname(card->host));
 		}
 	}
-out:
-	kfree(ssr);
-	return err;
+
+	return 0;
 }
 
 /*
@@ -666,6 +658,14 @@ MMC_DEV_ATTR(cid, "%08x%08x%08x%08x\n", card->raw_cid[0], card->raw_cid[1],
 MMC_DEV_ATTR(csd, "%08x%08x%08x%08x\n", card->raw_csd[0], card->raw_csd[1],
 	card->raw_csd[2], card->raw_csd[3]);
 MMC_DEV_ATTR(scr, "%08x%08x\n", card->raw_scr[0], card->raw_scr[1]);
+MMC_DEV_ATTR(ssr,
+	"%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x\n",
+		card->raw_ssr[0], card->raw_ssr[1], card->raw_ssr[2],
+		card->raw_ssr[3], card->raw_ssr[4], card->raw_ssr[5],
+		card->raw_ssr[6], card->raw_ssr[7], card->raw_ssr[8],
+		card->raw_ssr[9], card->raw_ssr[10], card->raw_ssr[11],
+		card->raw_ssr[12], card->raw_ssr[13], card->raw_ssr[14],
+		card->raw_ssr[15]);
 MMC_DEV_ATTR(date, "%02d/%04d\n", card->cid.month, card->cid.year);
 MMC_DEV_ATTR(erase_size, "%u\n", card->erase_size << 9);
 MMC_DEV_ATTR(preferred_erase_size, "%u\n", card->pref_erase << 9);
@@ -698,6 +698,7 @@ static struct attribute *sd_std_attrs[] = {
 	&dev_attr_cid.attr,
 	&dev_attr_csd.attr,
 	&dev_attr_scr.attr,
+	&dev_attr_ssr.attr,
 	&dev_attr_date.attr,
 	&dev_attr_erase_size.attr,
 	&dev_attr_preferred_erase_size.attr,

commit 6825a606584cec455b003afec7c10a07e563c994
Author: Bojan Prtvar <prtvar.b@gmail.com>
Date:   Tue Jul 19 11:16:38 2016 +0200

    mmc: core: Extend sysfs with DSR register
    
    Export DSR register through sysfs same as we did for the CID, CSD and
    OCR registers.
    
    Signed-off-by: Bojan Prtvar <prtvar.b@gmail.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 3dd0861f4557..0123936241b0 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -678,6 +678,22 @@ MMC_DEV_ATTR(serial, "0x%08x\n", card->cid.serial);
 MMC_DEV_ATTR(ocr, "%08x\n", card->ocr);
 
 
+static ssize_t mmc_dsr_show(struct device *dev,
+                           struct device_attribute *attr,
+                           char *buf)
+{
+       struct mmc_card *card = mmc_dev_to_card(dev);
+       struct mmc_host *host = card->host;
+
+       if (card->csd.dsr_imp && host->dsr_req)
+               return sprintf(buf, "0x%x\n", host->dsr);
+       else
+               /* return default DSR value */
+               return sprintf(buf, "0x%x\n", 0x404);
+}
+
+static DEVICE_ATTR(dsr, S_IRUGO, mmc_dsr_show, NULL);
+
 static struct attribute *sd_std_attrs[] = {
 	&dev_attr_cid.attr,
 	&dev_attr_csd.attr,
@@ -692,6 +708,7 @@ static struct attribute *sd_std_attrs[] = {
 	&dev_attr_oemid.attr,
 	&dev_attr_serial.attr,
 	&dev_attr_ocr.attr,
+	&dev_attr_dsr.attr,
 	NULL,
 };
 ATTRIBUTE_GROUPS(sd_std);

commit 5fb06af7a33b4b5cedccedb611cf77568163027b
Author: Bojan Prtvar <prtvar.b@gmail.com>
Date:   Mon Jul 4 13:56:55 2016 +0200

    mmc: core: Extend sysfs with OCR register
    
    Registers CID and CSD are already exported through sysfs so let's make
    this interface complete by adding missing OCR register.
    
    Signed-off-by: Bojan Prtvar <prtvar.b@gmail.com>
    Reviewed-by: Wolfram Sang <wsa@the-dreams.de>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index b95bd24d92f4..3dd0861f4557 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -675,6 +675,7 @@ MMC_DEV_ATTR(manfid, "0x%06x\n", card->cid.manfid);
 MMC_DEV_ATTR(name, "%s\n", card->cid.prod_name);
 MMC_DEV_ATTR(oemid, "0x%04x\n", card->cid.oemid);
 MMC_DEV_ATTR(serial, "0x%08x\n", card->cid.serial);
+MMC_DEV_ATTR(ocr, "%08x\n", card->ocr);
 
 
 static struct attribute *sd_std_attrs[] = {
@@ -690,6 +691,7 @@ static struct attribute *sd_std_attrs[] = {
 	&dev_attr_name.attr,
 	&dev_attr_oemid.attr,
 	&dev_attr_serial.attr,
+	&dev_attr_ocr.attr,
 	NULL,
 };
 ATTRIBUTE_GROUPS(sd_std);

commit 0076c71e37cc9f3f0b1c0c83f9f26f31a47222b0
Author: Shawn Lin <shawn.lin@rock-chips.com>
Date:   Sat Mar 12 00:35:45 2016 +0800

    mmc: core: remove redundant memset of mmc_decode_cid
    
    When initializing sd or sdio card, we get struct mmc_card
    from mmc_alloc_card which allocates it by kzalloc. So we don't
    need another memset while decoding cid.
    
    Signed-off-by: Shawn Lin <shawn.lin@rock-chips.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index bb39a29b2db6..b95bd24d92f4 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -74,8 +74,6 @@ void mmc_decode_cid(struct mmc_card *card)
 {
 	u32 *resp = card->raw_cid;
 
-	memset(&card->cid, 0, sizeof(struct mmc_cid));
-
 	/*
 	 * SD doesn't currently have a version field so we will
 	 * have to assume we can parse this.

commit e10c321977091f163eceedec0650e0ef4b3cf4bb
Author: Carlo Caione <carlo@endlessm.com>
Date:   Wed Jan 13 09:36:55 2016 +0100

    mmc: core: Enable tuning according to the actual timing
    
    While in sdhci_execute_tuning() the choice whether or not to enable the
    tuning is done on the actual timing, in the mmc_sdio_init_uhs_card() the
    check is done on the capability of the card.
    
    This difference is causing some issues with some SDIO cards in DDR50
    mode where the CDM19 is wrongly issued.
    
    With this patch we modify the check in both
    mmc_(sd|sdio)_init_uhs_card() functions to take the proper decision
    only according to the actual timing specification.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Carlo Caione <carlo@endlessm.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index bf73e5a7b350..bb39a29b2db6 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -638,9 +638,9 @@ static int mmc_sd_init_uhs_card(struct mmc_card *card)
 	 * SDR104 mode SD-cards. Note that tuning is mandatory for SDR104.
 	 */
 	if (!mmc_host_is_spi(card->host) &&
-		(card->sd_bus_speed == UHS_SDR50_BUS_SPEED ||
-		 card->sd_bus_speed == UHS_DDR50_BUS_SPEED ||
-		 card->sd_bus_speed == UHS_SDR104_BUS_SPEED)) {
+		(card->host->ios.timing == MMC_TIMING_UHS_SDR50 ||
+		 card->host->ios.timing == MMC_TIMING_UHS_DDR50 ||
+		 card->host->ios.timing == MMC_TIMING_UHS_SDR104)) {
 		err = mmc_execute_tuning(card);
 
 		/*
@@ -650,7 +650,7 @@ static int mmc_sd_init_uhs_card(struct mmc_card *card)
 		 * difference between v3.00 and 3.01 spec means that CMD19
 		 * tuning is also available for DDR50 mode.
 		 */
-		if (err && card->sd_bus_speed == UHS_DDR50_BUS_SPEED) {
+		if (err && card->host->ios.timing == MMC_TIMING_UHS_DDR50) {
 			pr_warn("%s: ddr50 tuning failed\n",
 				mmc_hostname(card->host));
 			err = 0;

commit d9812780a020bcec44565b5950b2a8b31afb5545
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sat Jan 2 10:06:29 2016 +0000

    mmc: sd: limit SD card power limit according to cards capabilities
    
    The SD card specification allows cards to error out a SWITCH command
    where the requested function in a group is not supported.  The spec
    provides for a set of capabilities which indicate which functions are
    supported.
    
    In the case of the power limit, requesting an unsupported power level
    via the SWITCH command fails, resulting in the power level remaining at
    the power-on default of 0.72W, even though the host and card may support
    higher powers levels.
    
    This has been seen with SanDisk 8GB cards, which support the default
    0.72W and 1.44W (200mA and 400mA) in combination with an iMX6 host,
    supporting up to 2.88W (800mA).  This currently causes us to try to set
    a power limit function value of '3' (2.88W) which the card errors out
    on, and thereby causes the power level to remain at 0.72W rather than
    the desired 1.44W.
    
    Arrange to limit the selected current limit by the capabilities reported
    by the card to avoid the SWITCH command failing.  Select the highest
    current limit that the host and card combination support.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Fixes: a39ca6ae0a08 ("mmc: core: Simplify and fix for SD switch processing")
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index f2b164b214ae..bf73e5a7b350 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -329,6 +329,7 @@ static int mmc_read_switch(struct mmc_card *card)
 		card->sw_caps.sd3_bus_mode = status[13];
 		/* Driver Strengths supported by the card */
 		card->sw_caps.sd3_drv_type = status[9];
+		card->sw_caps.sd3_curr_limit = status[7] | status[6] << 8;
 	}
 
 out:
@@ -545,14 +546,25 @@ static int sd_set_current_limit(struct mmc_card *card, u8 *status)
 	 * when we set current limit to 200ma, the card will draw 200ma, and
 	 * when we set current limit to 400/600/800ma, the card will draw its
 	 * maximum 300ma from the host.
+	 *
+	 * The above is incorrect: if we try to set a current limit that is
+	 * not supported by the card, the card can rightfully error out the
+	 * attempt, and remain at the default current limit.  This results
+	 * in a 300mA card being limited to 200mA even though the host
+	 * supports 800mA. Failures seen with SanDisk 8GB UHS cards with
+	 * an iMX6 host. --rmk
 	 */
-	if (max_current >= 800)
+	if (max_current >= 800 &&
+	    card->sw_caps.sd3_curr_limit & SD_MAX_CURRENT_800)
 		current_limit = SD_SET_CURRENT_LIMIT_800;
-	else if (max_current >= 600)
+	else if (max_current >= 600 &&
+		 card->sw_caps.sd3_curr_limit & SD_MAX_CURRENT_600)
 		current_limit = SD_SET_CURRENT_LIMIT_600;
-	else if (max_current >= 400)
+	else if (max_current >= 400 &&
+		 card->sw_caps.sd3_curr_limit & SD_MAX_CURRENT_400)
 		current_limit = SD_SET_CURRENT_LIMIT_400;
-	else if (max_current >= 200)
+	else if (max_current >= 200 &&
+		 card->sw_caps.sd3_curr_limit & SD_MAX_CURRENT_200)
 		current_limit = SD_SET_CURRENT_LIMIT_200;
 
 	if (current_limit != SD_SET_CURRENT_NO_CHANGE) {

commit 520322d92eab66b6fee562557fdd201b01cd6240
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Mon Dec 14 15:51:27 2015 +0200

    mmc: It is not an error for the card to be removed while suspended
    
    A card can be removed while it is runtime suspended.
    Do not print an error message.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 8f3b46a56b3d..f2b164b214ae 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -1158,7 +1158,7 @@ static int mmc_sd_runtime_resume(struct mmc_host *host)
 	int err;
 
 	err = _mmc_sd_resume(host);
-	if (err)
+	if (err && err != -ENOMEDIUM)
 		pr_err("%s: error %d doing runtime resume\n",
 			mmc_hostname(host), err);
 

commit c29536e85b5f7cf42b2e761f7ff35bc97de7cf95
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu Nov 5 16:01:32 2015 +0100

    mmc: core: Make runtime resume default behavior for MMC/SD
    
    MMC_CAP_RUNTIME_RESUME was invented to decrease system PM resume time for
    systems that particularly needs this. As the feature has matured let's
    make it the default behavior for MMC/SD.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 141eaa923e18..8f3b46a56b3d 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -1128,16 +1128,8 @@ static int _mmc_sd_resume(struct mmc_host *host)
  */
 static int mmc_sd_resume(struct mmc_host *host)
 {
-	int err = 0;
-
-	if (!(host->caps & MMC_CAP_RUNTIME_RESUME)) {
-		err = _mmc_sd_resume(host);
-		pm_runtime_set_active(&host->card->dev);
-		pm_runtime_mark_last_busy(&host->card->dev);
-	}
 	pm_runtime_enable(&host->card->dev);
-
-	return err;
+	return 0;
 }
 
 /*
@@ -1165,12 +1157,9 @@ static int mmc_sd_runtime_resume(struct mmc_host *host)
 {
 	int err;
 
-	if (!(host->caps & (MMC_CAP_AGGRESSIVE_PM | MMC_CAP_RUNTIME_RESUME)))
-		return 0;
-
 	err = _mmc_sd_resume(host);
 	if (err)
-		pr_err("%s: error %d doing aggressive resume\n",
+		pr_err("%s: error %d doing runtime resume\n",
 			mmc_hostname(host), err);
 
 	return 0;

commit 2860d060ac902df0164cc9580f843b101e27a2c6
Author: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
Date:   Wed Oct 14 23:53:03 2015 +0300

    mmc: skip reclaiming host on mmc_add_card() error
    
    There's little sense in releasing the host on mmc_add_card() error
    immediately after reclaiming  it, so reclaim the host  only in case
    of success.
    
    Signed-off-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index b1b9200a4715..141eaa923e18 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -1243,14 +1243,13 @@ int mmc_attach_sd(struct mmc_host *host)
 
 	mmc_release_host(host);
 	err = mmc_add_card(host->card);
-	mmc_claim_host(host);
 	if (err)
 		goto remove_card;
 
+	mmc_claim_host(host);
 	return 0;
 
 remove_card:
-	mmc_release_host(host);
 	mmc_remove_card(host->card);
 	host->card = NULL;
 	mmc_claim_host(host);

commit 9eadcc0581a8ccaf4c2378aa1c193fb164304f1d
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri Oct 2 10:56:11 2015 +0200

    mmc: core: Remove MMC_CLKGATE
    
    MMC_CLKGATE was once invented to save power by gating the bus clock at
    request inactivity. At that time it served its purpose. The modern way to
    deal with power saving for these scenarios, is by using runtime PM.
    
    Nowadays, several host drivers have deployed runtime PM, but for those
    that haven't and which still cares power saving at request inactivity,
    it's certainly time to deploy runtime PM as it has been around for several
    years now.
    
    To simplify code to mmc core and thus decrease maintenance efforts, this
    patch removes all code related to MMC_CLKGATE.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index e124db0fc178..b1b9200a4715 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -800,9 +800,7 @@ static int mmc_sd_get_ro(struct mmc_host *host)
 	if (!host->ops->get_ro)
 		return -1;
 
-	mmc_host_clk_hold(host);
 	ro = host->ops->get_ro(host);
-	mmc_host_clk_release(host);
 
 	return ro;
 }

commit 4324f6de6d2eb9b232410eb0d67bfafdde8ba711
Author: Weijun Yang <york.yang@csr.com>
Date:   Sun Oct 4 12:04:11 2015 +0000

    mmc: core: enable CMD19 tuning for DDR50 mode
    
    As SD Specifications Part1 Physical Layer Specification Version
    3.01 says, CMD19 tuning is available for unlocked cards in transfer
    state of 1.8V signaling mode. The small difference between v3.00
    and 3.01 spec means that CMD19 tuning is also available for DDR50
    mode.
    
    Signed-off-by: Weijun Yang <york.yang@csr.com>
    Signed-off-by: Barry Song <Baohua.Song@csr.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index e28ebf3c1c4b..e124db0fc178 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -626,9 +626,25 @@ static int mmc_sd_init_uhs_card(struct mmc_card *card)
 	 * SDR104 mode SD-cards. Note that tuning is mandatory for SDR104.
 	 */
 	if (!mmc_host_is_spi(card->host) &&
-	    (card->sd_bus_speed == UHS_SDR50_BUS_SPEED ||
-	     card->sd_bus_speed == UHS_SDR104_BUS_SPEED))
+		(card->sd_bus_speed == UHS_SDR50_BUS_SPEED ||
+		 card->sd_bus_speed == UHS_DDR50_BUS_SPEED ||
+		 card->sd_bus_speed == UHS_SDR104_BUS_SPEED)) {
 		err = mmc_execute_tuning(card);
+
+		/*
+		 * As SD Specifications Part1 Physical Layer Specification
+		 * Version 3.01 says, CMD19 tuning is available for unlocked
+		 * cards in transfer state of 1.8V signaling mode. The small
+		 * difference between v3.00 and 3.01 spec means that CMD19
+		 * tuning is also available for DDR50 mode.
+		 */
+		if (err && card->sd_bus_speed == UHS_DDR50_BUS_SPEED) {
+			pr_warn("%s: ddr50 tuning failed\n",
+				mmc_hostname(card->host));
+			err = 0;
+		}
+	}
+
 out:
 	kfree(status);
 

commit bf8b8511af7721e6f81848a1fd1359716602f3b7
Author: Yousong Zhou <yszhou4tech@gmail.com>
Date:   Thu Sep 10 00:33:16 2015 +0800

    mmc: sd: Remove superfluous error code assignment
    
    Signed-off-by: Yousong Zhou <yszhou4tech@gmail.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 4e7366ab187f..e28ebf3c1c4b 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -357,8 +357,6 @@ int mmc_sd_switch_hs(struct mmc_card *card)
 	if (card->sw_caps.hs_max_dtr == 0)
 		return 0;
 
-	err = -EIO;
-
 	status = kmalloc(64, GFP_KERNEL);
 	if (!status) {
 		pr_err("%s: could not allocate a buffer for "

commit 3056c49c35c1e8cc303e79c7085579ff0729a83b
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Mon Jun 1 11:14:58 2015 +0200

    mmc: core: Remove redundant ->power_restore() callback for SD
    
    Since the ->reset() callback is implemented for SD, the ->power_restore()
    callback has become redundant, let's remove it.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index b99e25b9bcdc..4e7366ab187f 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -1164,21 +1164,10 @@ static int mmc_sd_runtime_resume(struct mmc_host *host)
 	return 0;
 }
 
-static int mmc_sd_power_restore(struct mmc_host *host)
-{
-	int ret;
-
-	mmc_claim_host(host);
-	ret = mmc_sd_init_card(host, host->card->ocr, host->card);
-	mmc_release_host(host);
-
-	return ret;
-}
-
 static int mmc_sd_reset(struct mmc_host *host)
 {
 	mmc_power_cycle(host, host->card->ocr);
-	return mmc_sd_power_restore(host);
+	return mmc_sd_init_card(host, host->card->ocr, host->card);
 }
 
 static const struct mmc_bus_ops mmc_sd_ops = {
@@ -1188,7 +1177,6 @@ static const struct mmc_bus_ops mmc_sd_ops = {
 	.runtime_resume = mmc_sd_runtime_resume,
 	.suspend = mmc_sd_suspend,
 	.resume = mmc_sd_resume,
-	.power_restore = mmc_sd_power_restore,
 	.alive = mmc_sd_alive,
 	.shutdown = mmc_sd_suspend,
 	.reset = mmc_sd_reset,

commit 3853a042325e8f497c199020979c4fc824528c6e
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Fri Feb 6 14:12:56 2015 +0200

    mmc: core: Record card drive strength
    
    In preparation for adding drive strength support
    for eMMC, add drive_strength to struct mmc_card
    to record the card drive strength for UHS-I modes
    and HS200 / HS400. For eMMC this will be needed
    when switching between HS200 and HS400.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 9771b84db4b3..b99e25b9bcdc 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -389,6 +389,8 @@ static int sd_select_driver_type(struct mmc_card *card, u8 *status)
 	int card_drv_type, drive_strength, drv_type;
 	int err;
 
+	card->drive_strength = 0;
+
 	card_drv_type = card->sw_caps.sd3_drv_type | SD_DRIVER_TYPE_B;
 
 	drive_strength = mmc_select_drive_strength(card,
@@ -404,6 +406,7 @@ static int sd_select_driver_type(struct mmc_card *card, u8 *status)
 				mmc_hostname(card->host));
 			return 0;
 		}
+		card->drive_strength = drive_strength;
 	}
 
 	if (drv_type)

commit e23350b35deb77ef8e33c35dbb0ed1dab9e8ab86
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Fri Feb 6 14:12:55 2015 +0200

    mmc: core: Factor out common code in drive strength selection
    
    Make a new function out of common code used for drive
    strength selection.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 63f9163b8dda..9771b84db4b3 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -386,35 +386,14 @@ int mmc_sd_switch_hs(struct mmc_card *card)
 
 static int sd_select_driver_type(struct mmc_card *card, u8 *status)
 {
-	int host_drv_type = SD_DRIVER_TYPE_B;
 	int card_drv_type, drive_strength, drv_type;
 	int err;
 
-	if (!card->host->ops->select_drive_strength)
-		return 0;
-
-	if (card->host->caps & MMC_CAP_DRIVER_TYPE_A)
-		host_drv_type |= SD_DRIVER_TYPE_A;
-
-	if (card->host->caps & MMC_CAP_DRIVER_TYPE_C)
-		host_drv_type |= SD_DRIVER_TYPE_C;
-
-	if (card->host->caps & MMC_CAP_DRIVER_TYPE_D)
-		host_drv_type |= SD_DRIVER_TYPE_D;
-
 	card_drv_type = card->sw_caps.sd3_drv_type | SD_DRIVER_TYPE_B;
 
-	/*
-	 * The drive strength that the hardware can support
-	 * depends on the board design.  Pass the appropriate
-	 * information and let the hardware specific code
-	 * return what is possible given the options
-	 */
-	mmc_host_clk_hold(card->host);
-	drive_strength = card->host->ops->select_drive_strength(card,
-		card->sw_caps.uhs_max_dtr,
-		host_drv_type, card_drv_type, &drv_type);
-	mmc_host_clk_release(card->host);
+	drive_strength = mmc_select_drive_strength(card,
+						   card->sw_caps.uhs_max_dtr,
+						   card_drv_type, &drv_type);
 
 	if (drive_strength) {
 		err = mmc_sd_switch(card, 1, 2, drive_strength, status);

commit f168359efbb99d6f8591bb666d6510bb78df2d07
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Fri Feb 6 14:12:54 2015 +0200

    mmc: core: Add 'card' to drive strength selection callback
    
    In preparation for supporting also eMMC drive strength,
    add the 'card' as a parameter so that the callback can
    distinguish different types of cards if necessary.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 9b72ea6b3177..63f9163b8dda 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -411,7 +411,7 @@ static int sd_select_driver_type(struct mmc_card *card, u8 *status)
 	 * return what is possible given the options
 	 */
 	mmc_host_clk_hold(card->host);
-	drive_strength = card->host->ops->select_drive_strength(
+	drive_strength = card->host->ops->select_drive_strength(card,
 		card->sw_caps.uhs_max_dtr,
 		host_drv_type, card_drv_type, &drv_type);
 	mmc_host_clk_release(card->host);

commit fa021cef1af64cb4ba11c3c0910ef45085c58016
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Fri Feb 6 14:12:53 2015 +0200

    mmc: core: Simplify card drive strength mask
    
    Card drive strength selection uses a callback to
    which a mask of supported drive strengths is passed.
    Currently, the bits are checked against the values
    in the SD specifications. That is not necessary
    because the callback will anyway match the mask
    against a valid value. Simplify by taking the mask
    as is but still ensuring that the default mandatory
    value (type B) is always supported.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 5edd7d8b033e..9b72ea6b3177 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -387,8 +387,7 @@ int mmc_sd_switch_hs(struct mmc_card *card)
 static int sd_select_driver_type(struct mmc_card *card, u8 *status)
 {
 	int host_drv_type = SD_DRIVER_TYPE_B;
-	int card_drv_type = SD_DRIVER_TYPE_B;
-	int drive_strength, drv_type;
+	int card_drv_type, drive_strength, drv_type;
 	int err;
 
 	if (!card->host->ops->select_drive_strength)
@@ -403,14 +402,7 @@ static int sd_select_driver_type(struct mmc_card *card, u8 *status)
 	if (card->host->caps & MMC_CAP_DRIVER_TYPE_D)
 		host_drv_type |= SD_DRIVER_TYPE_D;
 
-	if (card->sw_caps.sd3_drv_type & SD_DRIVER_TYPE_A)
-		card_drv_type |= SD_DRIVER_TYPE_A;
-
-	if (card->sw_caps.sd3_drv_type & SD_DRIVER_TYPE_C)
-		card_drv_type |= SD_DRIVER_TYPE_C;
-
-	if (card->sw_caps.sd3_drv_type & SD_DRIVER_TYPE_D)
-		card_drv_type |= SD_DRIVER_TYPE_D;
+	card_drv_type = card->sw_caps.sd3_drv_type | SD_DRIVER_TYPE_B;
 
 	/*
 	 * The drive strength that the hardware can support

commit b4f30a174e1fda8118eda038b5d8d5260db36ad5
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Fri Feb 6 14:12:52 2015 +0200

    mmc: core: Allow card drive strength to be different to host
    
    Initialization of UHS-I modes for SD and SDIO cards
    employs a callback to allow the host driver to
    choose a drive strength value. Currently that
    assumes the card drive strength and host driver
    type must be the same value. Change to let the
    callback make that decision and return both the
    card drive strength and host driver type.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 8f6864a2a055..5edd7d8b033e 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -388,18 +388,9 @@ static int sd_select_driver_type(struct mmc_card *card, u8 *status)
 {
 	int host_drv_type = SD_DRIVER_TYPE_B;
 	int card_drv_type = SD_DRIVER_TYPE_B;
-	int drive_strength;
+	int drive_strength, drv_type;
 	int err;
 
-	/*
-	 * If the host doesn't support any of the Driver Types A,C or D,
-	 * or there is no board specific handler then default Driver
-	 * Type B is used.
-	 */
-	if (!(card->host->caps & (MMC_CAP_DRIVER_TYPE_A | MMC_CAP_DRIVER_TYPE_C
-	    | MMC_CAP_DRIVER_TYPE_D)))
-		return 0;
-
 	if (!card->host->ops->select_drive_strength)
 		return 0;
 
@@ -430,20 +421,22 @@ static int sd_select_driver_type(struct mmc_card *card, u8 *status)
 	mmc_host_clk_hold(card->host);
 	drive_strength = card->host->ops->select_drive_strength(
 		card->sw_caps.uhs_max_dtr,
-		host_drv_type, card_drv_type);
+		host_drv_type, card_drv_type, &drv_type);
 	mmc_host_clk_release(card->host);
 
-	err = mmc_sd_switch(card, 1, 2, drive_strength, status);
-	if (err)
-		return err;
-
-	if ((status[15] & 0xF) != drive_strength) {
-		pr_warn("%s: Problem setting drive strength!\n",
-			mmc_hostname(card->host));
-		return 0;
+	if (drive_strength) {
+		err = mmc_sd_switch(card, 1, 2, drive_strength, status);
+		if (err)
+			return err;
+		if ((status[15] & 0xF) != drive_strength) {
+			pr_warn("%s: Problem setting drive strength!\n",
+				mmc_hostname(card->host));
+			return 0;
+		}
 	}
 
-	mmc_set_driver_type(card->host, drive_strength);
+	if (drv_type)
+		mmc_set_driver_type(card->host, drv_type);
 
 	return 0;
 }

commit 9f6e0bff2afb52a4c29f5ca8a4db01810357974e
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Wed May 6 20:31:19 2015 +0200

    mmc: Add support for disabling write-protect detection
    
    It is not uncommon to see systems where there is no physical write-protect
    signal (e.g. when using eMMC or microSD card slots). For some controllers,
    which have a dedicated write-protection detection logic (like SDHCI
    controllers), the get_ro() callback can return bogus data in such a case.
    
    Instead of handling this on a per controller basis this patch adds a new
    capability flag to the MMC core that can be set to specify that the result
    of get_ro() is invalid. When the flag is set the core will not call
    get_ro() and assume that the card is always read-write.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 31a9ef256d06..8f6864a2a055 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -804,6 +804,28 @@ int mmc_sd_get_csd(struct mmc_host *host, struct mmc_card *card)
 	return 0;
 }
 
+static int mmc_sd_get_ro(struct mmc_host *host)
+{
+	int ro;
+
+	/*
+	 * Some systems don't feature a write-protect pin and don't need one.
+	 * E.g. because they only have micro-SD card slot. For those systems
+	 * assume that the SD card is always read-write.
+	 */
+	if (host->caps2 & MMC_CAP2_NO_WRITE_PROTECT)
+		return 0;
+
+	if (!host->ops->get_ro)
+		return -1;
+
+	mmc_host_clk_hold(host);
+	ro = host->ops->get_ro(host);
+	mmc_host_clk_release(host);
+
+	return ro;
+}
+
 int mmc_sd_setup_card(struct mmc_host *host, struct mmc_card *card,
 	bool reinit)
 {
@@ -855,13 +877,7 @@ int mmc_sd_setup_card(struct mmc_host *host, struct mmc_card *card,
 	 * Check if read-only switch is active.
 	 */
 	if (!reinit) {
-		int ro = -1;
-
-		if (host->ops->get_ro) {
-			mmc_host_clk_hold(card->host);
-			ro = host->ops->get_ro(host);
-			mmc_host_clk_release(card->host);
-		}
+		int ro = mmc_sd_get_ro(host);
 
 		if (ro < 0) {
 			pr_warn("%s: host does not support reading read-only switch, assuming write-enable\n",

commit d0bbe0dd353af9521e9d8bc5236308c677b6f62a
Merge: 8de29a35dc84 0e4f93e5017d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Apr 14 09:50:27 2015 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial
    
    Pull trivial tree from Jiri Kosina:
     "Usual trivial tree updates.  Nothing outstanding -- mostly printk()
      and comment fixes and unused identifier removals"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial:
      goldfish: goldfish_tty_probe() is not using 'i' any more
      powerpc: Fix comment in smu.h
      qla2xxx: Fix printks in ql_log message
      lib: correct link to the original source for div64_u64
      si2168, tda10071, m88ds3103: Fix firmware wording
      usb: storage: Fix printk in isd200_log_config()
      qla2xxx: Fix printk in qla25xx_setup_mode
      init/main: fix reset_device comment
      ipwireless: missing assignment
      goldfish: remove unreachable line of code
      coredump: Fix do_coredump() comment
      stacktrace.h: remove duplicate declaration task_struct
      smpboot.h: Remove unused function prototype
      treewide: Fix typo in printk messages
      treewide: Fix typo in printk messages
      mod_devicetable: fix comment for match_flags

commit f42cf8d6a3ec934551ac0f20f4654dccb11fa30d
Author: Masanari Iida <standby24x7@gmail.com>
Date:   Tue Feb 24 23:11:26 2015 +0900

    treewide: Fix typo in printk messages
    
    This patch fix spelling typo in printk messages.
    
    Signed-off-by: Masanari Iida <standby24x7@gmail.com>
    Acked-by: Randy Dunlap <rdunlap@infradead.org>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index d90a6de7901d..c2cddfd99c7c 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -1156,7 +1156,7 @@ static int mmc_sd_runtime_suspend(struct mmc_host *host)
 
 	err = _mmc_sd_suspend(host);
 	if (err)
-		pr_err("%s: error %d doing aggessive suspend\n",
+		pr_err("%s: error %d doing aggressive suspend\n",
 			mmc_hostname(host), err);
 
 	return err;
@@ -1174,7 +1174,7 @@ static int mmc_sd_runtime_resume(struct mmc_host *host)
 
 	err = _mmc_sd_resume(host);
 	if (err)
-		pr_err("%s: error %d doing aggessive resume\n",
+		pr_err("%s: error %d doing aggressive resume\n",
 			mmc_hostname(host), err);
 
 	return 0;

commit 63e415c64003fd62a302a1dc19f082e2c6f1b7cc
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Fri Dec 5 19:40:59 2014 +0200

    mmc: core: Simplify by adding mmc_execute_tuning()
    
    For each MMC, SD and SDIO there is code that
    holds the clock, calls ops->execute_tuning, and
    releases the clock. Simplify the code a bit by
    providing a separate function to do that.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 36d5333838cb..ad4d43eae99d 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -660,15 +660,10 @@ static int mmc_sd_init_uhs_card(struct mmc_card *card)
 	 * SPI mode doesn't define CMD19 and tuning is only valid for SDR50 and
 	 * SDR104 mode SD-cards. Note that tuning is mandatory for SDR104.
 	 */
-	if (!mmc_host_is_spi(card->host) && card->host->ops->execute_tuning &&
-			(card->sd_bus_speed == UHS_SDR50_BUS_SPEED ||
-			 card->sd_bus_speed == UHS_SDR104_BUS_SPEED)) {
-		mmc_host_clk_hold(card->host);
-		err = card->host->ops->execute_tuning(card->host,
-						      MMC_SEND_TUNING_BLOCK);
-		mmc_host_clk_release(card->host);
-	}
-
+	if (!mmc_host_is_spi(card->host) &&
+	    (card->sd_bus_speed == UHS_SDR50_BUS_SPEED ||
+	     card->sd_bus_speed == UHS_SDR104_BUS_SPEED))
+		err = mmc_execute_tuning(card);
 out:
 	kfree(status);
 

commit dc0ecfef29c60d3765f8e7991b3a4527733238b1
Author: Johan Rudholm <johan.rudholm@axis.com>
Date:   Mon Jan 12 15:38:06 2015 +0100

    mmc: sd: add reset bus_ops callback
    
    Enable power cycle and re-initialization of SD cards via the reset
    bus_ops. Power cycling a buggy SD card sometimes helps it get back on
    track.
    
    Signed-off-by: Johan Rudholm <johanru@axis.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 29fccdcacd68..36d5333838cb 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -1197,6 +1197,12 @@ static int mmc_sd_power_restore(struct mmc_host *host)
 	return ret;
 }
 
+static int mmc_sd_reset(struct mmc_host *host)
+{
+	mmc_power_cycle(host, host->card->ocr);
+	return mmc_sd_power_restore(host);
+}
+
 static const struct mmc_bus_ops mmc_sd_ops = {
 	.remove = mmc_sd_remove,
 	.detect = mmc_sd_detect,
@@ -1207,6 +1213,7 @@ static const struct mmc_bus_ops mmc_sd_ops = {
 	.power_restore = mmc_sd_power_restore,
 	.alive = mmc_sd_alive,
 	.shutdown = mmc_sd_suspend,
+	.reset = mmc_sd_reset,
 };
 
 /*

commit eac86321b5c33e6b68aa4a4e0517c45df3ef02c0
Author: Doug Anderson <dianders@chromium.org>
Date:   Tue Dec 2 15:42:45 2014 -0800

    mmc: core: Support the optional init_card() callback for MMC and SD
    
    In (3fcb027 ARM: MXC: mxcmmc: work around a bug in the SDHC busy line
    handling) the optional init_card() callback was added.  According to
    the original change it was "for now only called from
    mmc_sdio_init_card()".
    
    This callback really ought to be called from the SD and MMC init
    functions as well.  One current user of this callback
    (mxcmci_init_card) will not work as expected if you insert an SDIO
    card, then eject it and put a normal SD card in.  Specifically the
    normal SD card will not get to run with 4-bit data.
    
    I'd like to use the init_card() callback to handle a similar quirk on
    dw_mmc when using SDIO Interrupts (the "low power" feature of the card
    needs to be disabled), so that will add a second user of the function.
    
    Signed-off-by: Doug Anderson <dianders@chromium.org>
    Reviewed-by: Grant Grundler <grundler@chromium.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index d90a6de7901d..29fccdcacd68 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -932,6 +932,12 @@ static int mmc_sd_init_card(struct mmc_host *host, u32 ocr,
 		memcpy(card->raw_cid, cid, sizeof(card->raw_cid));
 	}
 
+	/*
+	 * Call the optional HC's init_card function to handle quirks.
+	 */
+	if (host->ops->init_card)
+		host->ops->init_card(host, card);
+
 	/*
 	 * For native busses:  get card RCA and quit open drain mode.
 	 */
@@ -1271,4 +1277,3 @@ int mmc_attach_sd(struct mmc_host *host)
 
 	return err;
 }
-

commit 6606110d89aefcb21b9e70adfe064987cbd8393a
Author: Joe Perches <joe@perches.com>
Date:   Fri Sep 12 14:56:56 2014 -0700

    mmc: Convert pr_warning to pr_warn
    
    Use the much more common pr_warn instead of pr_warning.
    
    Other miscellanea:
    
    o Coalesce formats
    o Realign arguments
    o Remove extra spaces when coalescing formats
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 25913889cbaa..d90a6de7901d 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -229,8 +229,8 @@ static int mmc_read_ssr(struct mmc_card *card)
 	u32 *ssr;
 
 	if (!(card->csd.cmdclass & CCC_APP_SPEC)) {
-		pr_warning("%s: card lacks mandatory SD Status "
-			"function.\n", mmc_hostname(card->host));
+		pr_warn("%s: card lacks mandatory SD Status function\n",
+			mmc_hostname(card->host));
 		return 0;
 	}
 
@@ -240,8 +240,8 @@ static int mmc_read_ssr(struct mmc_card *card)
 
 	err = mmc_app_sd_status(card, ssr);
 	if (err) {
-		pr_warning("%s: problem reading SD Status "
-			"register.\n", mmc_hostname(card->host));
+		pr_warn("%s: problem reading SD Status register\n",
+			mmc_hostname(card->host));
 		err = 0;
 		goto out;
 	}
@@ -265,8 +265,8 @@ static int mmc_read_ssr(struct mmc_card *card)
 				card->ssr.erase_offset = eo * 1000;
 			}
 		} else {
-			pr_warning("%s: SD Status: Invalid Allocation Unit size.\n",
-				   mmc_hostname(card->host));
+			pr_warn("%s: SD Status: Invalid Allocation Unit size\n",
+				mmc_hostname(card->host));
 		}
 	}
 out:
@@ -286,8 +286,7 @@ static int mmc_read_switch(struct mmc_card *card)
 		return 0;
 
 	if (!(card->csd.cmdclass & CCC_SWITCH)) {
-		pr_warning("%s: card lacks mandatory switch "
-			"function, performance might suffer.\n",
+		pr_warn("%s: card lacks mandatory switch function, performance might suffer\n",
 			mmc_hostname(card->host));
 		return 0;
 	}
@@ -316,7 +315,7 @@ static int mmc_read_switch(struct mmc_card *card)
 		if (err != -EINVAL && err != -ENOSYS && err != -EFAULT)
 			goto out;
 
-		pr_warning("%s: problem reading Bus Speed modes.\n",
+		pr_warn("%s: problem reading Bus Speed modes\n",
 			mmc_hostname(card->host));
 		err = 0;
 
@@ -372,8 +371,7 @@ int mmc_sd_switch_hs(struct mmc_card *card)
 		goto out;
 
 	if ((status[16] & 0xF) != 1) {
-		pr_warning("%s: Problem switching card "
-			"into high-speed mode!\n",
+		pr_warn("%s: Problem switching card into high-speed mode!\n",
 			mmc_hostname(card->host));
 		err = 0;
 	} else {
@@ -440,7 +438,7 @@ static int sd_select_driver_type(struct mmc_card *card, u8 *status)
 		return err;
 
 	if ((status[15] & 0xF) != drive_strength) {
-		pr_warning("%s: Problem setting drive strength!\n",
+		pr_warn("%s: Problem setting drive strength!\n",
 			mmc_hostname(card->host));
 		return 0;
 	}
@@ -518,7 +516,7 @@ static int sd_set_bus_speed_mode(struct mmc_card *card, u8 *status)
 		return err;
 
 	if ((status[16] & 0xF) != card->sd_bus_speed)
-		pr_warning("%s: Problem setting bus speed mode!\n",
+		pr_warn("%s: Problem setting bus speed mode!\n",
 			mmc_hostname(card->host));
 	else {
 		mmc_set_timing(card->host, timing);
@@ -598,7 +596,7 @@ static int sd_set_current_limit(struct mmc_card *card, u8 *status)
 			return err;
 
 		if (((status[15] >> 4) & 0x0F) != current_limit)
-			pr_warning("%s: Problem setting current limit!\n",
+			pr_warn("%s: Problem setting current limit!\n",
 				mmc_hostname(card->host));
 
 	}
@@ -727,8 +725,7 @@ int mmc_sd_get_cid(struct mmc_host *host, u32 ocr, u32 *cid, u32 *rocr)
 try_again:
 	if (!retries) {
 		ocr &= ~SD_OCR_S18R;
-		pr_warning("%s: Skipping voltage switch\n",
-			mmc_hostname(host));
+		pr_warn("%s: Skipping voltage switch\n", mmc_hostname(host));
 	}
 
 	/*
@@ -872,9 +869,7 @@ int mmc_sd_setup_card(struct mmc_host *host, struct mmc_card *card,
 		}
 
 		if (ro < 0) {
-			pr_warning("%s: host does not "
-				"support reading read-only "
-				"switch. assuming write-enable.\n",
+			pr_warn("%s: host does not support reading read-only switch, assuming write-enable\n",
 				mmc_hostname(host));
 		} else if (ro > 0) {
 			mmc_card_set_readonly(card);

commit 3d705d14fe4c72be83bae1610680e209ee226b9d
Author: Sascha Hauer <s.hauer@pengutronix.de>
Date:   Tue Aug 19 10:45:51 2014 +0200

    mmc: implement Driver Stage Register handling
    
    Some eMMC and SD cards implement a DSR register that allows to tune
    raise/fall times and drive strength of the CMD and DATA outputs.
    The values to use depend on the card in use and the host.
    It might be needed to reduce the drive strength to prevent voltage peaks
    above the host's specification.
    
    Implement a 'dsr' devicetree property that allows to specify the value
    to set the DSR to. For non-dt setups the new members of mmc_host can be
    set by board code.
    
    This patch was initially authored by Sascha Hauer. It contains
    improvements authored by Markus Niebel and Uwe Kleine-König.
    
    Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>
    Signed-off-by: Markus Niebel <Markus.Niebel@tq-group.com>
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 0c44510bf717..25913889cbaa 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -127,6 +127,7 @@ static int mmc_decode_csd(struct mmc_card *card)
 		csd->read_partial = UNSTUFF_BITS(resp, 79, 1);
 		csd->write_misalign = UNSTUFF_BITS(resp, 78, 1);
 		csd->read_misalign = UNSTUFF_BITS(resp, 77, 1);
+		csd->dsr_imp = UNSTUFF_BITS(resp, 76, 1);
 		csd->r2w_factor = UNSTUFF_BITS(resp, 26, 3);
 		csd->write_blkbits = UNSTUFF_BITS(resp, 22, 4);
 		csd->write_partial = UNSTUFF_BITS(resp, 21, 1);
@@ -953,6 +954,13 @@ static int mmc_sd_init_card(struct mmc_host *host, u32 ocr,
 		mmc_decode_cid(card);
 	}
 
+	/*
+	 * handling only for cards supporting DSR and hosts requesting
+	 * DSR configuration
+	 */
+	if (card->csd.dsr_imp && host->dsr_req)
+		mmc_set_dsr(host);
+
 	/*
 	 * Select card, as all following commands rely on that.
 	 */

commit cdc991790c51c693d0c347a5286af017826a5d01
Author: Seungwon Jeon <tgih.jun@samsung.com>
Date:   Wed Apr 23 17:07:35 2014 +0900

    mmc: drop the speed mode of card's state
    
    Timing mode identifier has same role and can take the place
    of speed mode. This change removes all related speed mode.
    
    Signed-off-by: Seungwon Jeon <tgih.jun@samsung.com>
    Tested-by: Jaehoon Chung <jh80.chung@samsung.com>
    Acked-by: Jaehoon Chung <jh80.chung@samsung.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <chris@printf.net>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index aef515755e5b..0c44510bf717 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -887,7 +887,7 @@ unsigned mmc_sd_get_max_clock(struct mmc_card *card)
 {
 	unsigned max_dtr = (unsigned int)-1;
 
-	if (mmc_card_highspeed(card)) {
+	if (mmc_card_hs(card)) {
 		if (max_dtr > card->sw_caps.hs_max_dtr)
 			max_dtr = card->sw_caps.hs_max_dtr;
 	} else if (max_dtr > card->csd.max_dtr) {
@@ -897,12 +897,6 @@ unsigned mmc_sd_get_max_clock(struct mmc_card *card)
 	return max_dtr;
 }
 
-void mmc_sd_go_highspeed(struct mmc_card *card)
-{
-	mmc_card_set_highspeed(card);
-	mmc_set_timing(card->host, MMC_TIMING_SD_HS);
-}
-
 /*
  * Handle the detection and initialisation of a card.
  *
@@ -977,16 +971,13 @@ static int mmc_sd_init_card(struct mmc_host *host, u32 ocr,
 		err = mmc_sd_init_uhs_card(card);
 		if (err)
 			goto free_card;
-
-		/* Card is an ultra-high-speed card */
-		mmc_card_set_uhs(card);
 	} else {
 		/*
 		 * Attempt to change to high-speed (if supported)
 		 */
 		err = mmc_sd_switch_hs(card);
 		if (err > 0)
-			mmc_sd_go_highspeed(card);
+			mmc_set_timing(card->host, MMC_TIMING_SD_HS);
 		else if (err)
 			goto free_card;
 
@@ -1081,7 +1072,7 @@ static int _mmc_sd_suspend(struct mmc_host *host)
 
 	if (!mmc_host_is_spi(host))
 		err = mmc_deselect_cards(host);
-	host->card->state &= ~MMC_STATE_HIGHSPEED;
+
 	if (!err) {
 		mmc_power_off(host);
 		mmc_card_set_suspended(host->card);
@@ -1190,7 +1181,6 @@ static int mmc_sd_power_restore(struct mmc_host *host)
 {
 	int ret;
 
-	host->card->state &= ~MMC_STATE_HIGHSPEED;
 	mmc_claim_host(host);
 	ret = mmc_sd_init_card(host, host->card->ocr, host->card);
 	mmc_release_host(host);

commit d1e58212caa4fdd95dfb003ba6e90aa0c9c1ac03
Author: Axel Lin <axel.lin@ingics.com>
Date:   Sat Mar 8 15:05:27 2014 +0800

    mmc: Convert to use ATTRIBUTE_GROUPS
    
    Use new ATTRIBUTE_GROUPS macro to declare attribute groups.
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <chris@printf.net>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 2dd359d2242f..aef515755e5b 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -707,18 +707,10 @@ static struct attribute *sd_std_attrs[] = {
 	&dev_attr_serial.attr,
 	NULL,
 };
-
-static struct attribute_group sd_std_attr_group = {
-	.attrs = sd_std_attrs,
-};
-
-static const struct attribute_group *sd_attr_groups[] = {
-	&sd_std_attr_group,
-	NULL,
-};
+ATTRIBUTE_GROUPS(sd_std);
 
 struct device_type sd_type = {
-	.groups = sd_attr_groups,
+	.groups = sd_std_groups,
 };
 
 /*

commit 2501c9179dff2add6aadd3898cd729e94e777d3a
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Wed Oct 30 01:00:18 2013 +0100

    mmc: core: Use MMC_UNSAFE_RESUME as default behavior
    
    Invoking system suspend or shutdown without using the Kconfig option
    MMC_UNSAFE_RESUME, did trigger an ungraceful power cut of the card.
    
    To improve the situation, change the behavior to always make use of the
    available bus_ops callbacks that handles system suspend and shutdown
    properly.
    
    By changing the behavior MMC_UNSAFE_RESUME becomes redundant, so lets's
    remove it.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <chris@printf.net>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 692fdb177294..2dd359d2242f 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -1207,16 +1207,6 @@ static int mmc_sd_power_restore(struct mmc_host *host)
 }
 
 static const struct mmc_bus_ops mmc_sd_ops = {
-	.remove = mmc_sd_remove,
-	.detect = mmc_sd_detect,
-	.suspend = NULL,
-	.resume = NULL,
-	.power_restore = mmc_sd_power_restore,
-	.alive = mmc_sd_alive,
-	.shutdown = mmc_sd_suspend,
-};
-
-static const struct mmc_bus_ops mmc_sd_ops_unsafe = {
 	.remove = mmc_sd_remove,
 	.detect = mmc_sd_detect,
 	.runtime_suspend = mmc_sd_runtime_suspend,
@@ -1228,17 +1218,6 @@ static const struct mmc_bus_ops mmc_sd_ops_unsafe = {
 	.shutdown = mmc_sd_suspend,
 };
 
-static void mmc_sd_attach_bus_ops(struct mmc_host *host)
-{
-	const struct mmc_bus_ops *bus_ops;
-
-	if (!mmc_card_is_removable(host))
-		bus_ops = &mmc_sd_ops_unsafe;
-	else
-		bus_ops = &mmc_sd_ops;
-	mmc_attach_bus(host, bus_ops);
-}
-
 /*
  * Starting point for SD card init.
  */
@@ -1254,7 +1233,7 @@ int mmc_attach_sd(struct mmc_host *host)
 	if (err)
 		return err;
 
-	mmc_sd_attach_bus_ops(host);
+	mmc_attach_bus(host, &mmc_sd_ops);
 	if (host->ocr_avail_sd)
 		host->ocr_avail = host->ocr_avail_sd;
 

commit 9288cac05405a7da406097a44721aa4004609b4d
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Tue Nov 26 02:16:25 2013 +0100

    mmc: core: sd: implement proper support for sd3.0 au sizes
    
    This reverts and updates commit 77776fd0a4cc541b9 ("mmc: sd: fix the
    maximum au_size for SD3.0"). The au_size for SD3.0 cannot be achieved
    by a simple bit shift, so this needs to be implemented differently.
    Also, don't print the warning in case of 0 since 'not defined' is
    different from 'invalid'.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>
    Acked-by: Jaehoon Chung <jh80.chung@samsung.com>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: stable <stable@vger.kernel.org> # [3.12, 3.13]
    Signed-off-by: Chris Ball <chris@printf.net>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 6f42050b7ccc..692fdb177294 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -11,6 +11,7 @@
  */
 
 #include <linux/err.h>
+#include <linux/sizes.h>
 #include <linux/slab.h>
 #include <linux/stat.h>
 #include <linux/pm_runtime.h>
@@ -45,6 +46,13 @@ static const unsigned int tacc_mant[] = {
 	35,	40,	45,	50,	55,	60,	70,	80,
 };
 
+static const unsigned int sd_au_size[] = {
+	0,		SZ_16K / 512,		SZ_32K / 512,	SZ_64K / 512,
+	SZ_128K / 512,	SZ_256K / 512,		SZ_512K / 512,	SZ_1M / 512,
+	SZ_2M / 512,	SZ_4M / 512,		SZ_8M / 512,	(SZ_8M + SZ_4M) / 512,
+	SZ_16M / 512,	(SZ_16M + SZ_8M) / 512,	SZ_32M / 512,	SZ_64M / 512,
+};
+
 #define UNSTUFF_BITS(resp,start,size)					\
 	({								\
 		const int __size = size;				\
@@ -216,7 +224,7 @@ static int mmc_decode_scr(struct mmc_card *card)
 static int mmc_read_ssr(struct mmc_card *card)
 {
 	unsigned int au, es, et, eo;
-	int err, i, max_au;
+	int err, i;
 	u32 *ssr;
 
 	if (!(card->csd.cmdclass & CCC_APP_SPEC)) {
@@ -240,26 +248,25 @@ static int mmc_read_ssr(struct mmc_card *card)
 	for (i = 0; i < 16; i++)
 		ssr[i] = be32_to_cpu(ssr[i]);
 
-	/* SD3.0 increases max AU size to 64MB (0xF) from 4MB (0x9) */
-	max_au = card->scr.sda_spec3 ? 0xF : 0x9;
-
 	/*
 	 * UNSTUFF_BITS only works with four u32s so we have to offset the
 	 * bitfield positions accordingly.
 	 */
 	au = UNSTUFF_BITS(ssr, 428 - 384, 4);
-	if (au > 0 && au <= max_au) {
-		card->ssr.au = 1 << (au + 4);
-		es = UNSTUFF_BITS(ssr, 408 - 384, 16);
-		et = UNSTUFF_BITS(ssr, 402 - 384, 6);
-		eo = UNSTUFF_BITS(ssr, 400 - 384, 2);
-		if (es && et) {
-			card->ssr.erase_timeout = (et * 1000) / es;
-			card->ssr.erase_offset = eo * 1000;
+	if (au) {
+		if (au <= 9 || card->scr.sda_spec3) {
+			card->ssr.au = sd_au_size[au];
+			es = UNSTUFF_BITS(ssr, 408 - 384, 16);
+			et = UNSTUFF_BITS(ssr, 402 - 384, 6);
+			if (es && et) {
+				eo = UNSTUFF_BITS(ssr, 400 - 384, 2);
+				card->ssr.erase_timeout = (et * 1000) / es;
+				card->ssr.erase_offset = eo * 1000;
+			}
+		} else {
+			pr_warning("%s: SD Status: Invalid Allocation Unit size.\n",
+				   mmc_hostname(card->host));
 		}
-	} else {
-		pr_warning("%s: SD Status: Invalid Allocation Unit "
-			"size.\n", mmc_hostname(card->host));
 	}
 out:
 	kfree(ssr);

commit 4d22378221bd0ed69c2e99408d31c108d72aeb80
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu Oct 10 17:22:23 2013 +0200

    mmc: core: Add MMC_CAP_RUNTIME_RESUME to resume at runtime_resume
    
    In some environments it is to prefer to postpone the resume of the card
    device until runtime_resume is being carried out, since it will mean a
    signficant decrease of the total system resume time.
    
    The reason of the decreased resume time is simply because of the actual
    re-initalization of the card, which typically takes hundreds of
    milliseconds, is performed outside the resume sequence and wont thus
    affect it.
    
    For removable card, the detect work tries to re-detect the card to make
    sure it is still present, as a part of that sequence the card will also
    be runtime_resumed and thus also fully resumed.
    
    For a non-removable card, typically a mmc blk request will trigger a
    runtime_resume and thus fully resume the card. This also means the
    first request will likely suffer from an inital latency since the
    re-initialization of the card needs to be performed.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 447fa8e9f322..6f42050b7ccc 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -1139,11 +1139,13 @@ static int _mmc_sd_resume(struct mmc_host *host)
  */
 static int mmc_sd_resume(struct mmc_host *host)
 {
-	int err;
+	int err = 0;
 
-	err = _mmc_sd_resume(host);
-	pm_runtime_set_active(&host->card->dev);
-	pm_runtime_mark_last_busy(&host->card->dev);
+	if (!(host->caps & MMC_CAP_RUNTIME_RESUME)) {
+		err = _mmc_sd_resume(host);
+		pm_runtime_set_active(&host->card->dev);
+		pm_runtime_mark_last_busy(&host->card->dev);
+	}
 	pm_runtime_enable(&host->card->dev);
 
 	return err;
@@ -1174,7 +1176,7 @@ static int mmc_sd_runtime_resume(struct mmc_host *host)
 {
 	int err;
 
-	if (!(host->caps & MMC_CAP_AGGRESSIVE_PM))
+	if (!(host->caps & (MMC_CAP_AGGRESSIVE_PM | MMC_CAP_RUNTIME_RESUME)))
 		return 0;
 
 	err = _mmc_sd_resume(host);

commit 0cb403a227774f60f6f52137ca3618805498c4e6
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu Oct 10 14:20:05 2013 +0200

    mmc: core: Improve runtime PM support during suspend/resume for sd/mmc
    
    The card device is considered as in-active after it has been suspended.
    To prevent any further runtime PM requests in suspend state, we then
    disable runtime PM.
    
    After the card device has been resumed, we shall consider it as active,
    like we also do after a probe sequence. When resumed, we can safely
    enable runtime PM again.
    
    This will make sure the PM core can request the card device to go to
    in-active state after a resume has been completed. Previously we had to
    wait for new pm_runtime_get->pm_runtime_put cycle to be executed.
    
    Additionally, once a resume has been carried out, update the last busy
    mark. At the moment this will have no effect but if the PM core will
    respect autosuspend enabled devices, when it directly triggers a
    runtime_suspend from a runtime_idle, it will mean the card device will
    be scheduled for a delayed runtime_suspend instead of done immediately.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 7b2854009e39..447fa8e9f322 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -13,6 +13,7 @@
 #include <linux/err.h>
 #include <linux/slab.h>
 #include <linux/stat.h>
+#include <linux/pm_runtime.h>
 
 #include <linux/mmc/host.h>
 #include <linux/mmc/card.h>
@@ -1067,10 +1068,7 @@ static void mmc_sd_detect(struct mmc_host *host)
 	}
 }
 
-/*
- * Suspend callback from host.
- */
-static int mmc_sd_suspend(struct mmc_host *host)
+static int _mmc_sd_suspend(struct mmc_host *host)
 {
 	int err = 0;
 
@@ -1096,12 +1094,26 @@ static int mmc_sd_suspend(struct mmc_host *host)
 }
 
 /*
- * Resume callback from host.
- *
+ * Callback for suspend
+ */
+static int mmc_sd_suspend(struct mmc_host *host)
+{
+	int err;
+
+	err = _mmc_sd_suspend(host);
+	if (!err) {
+		pm_runtime_disable(&host->card->dev);
+		pm_runtime_set_suspended(&host->card->dev);
+	}
+
+	return err;
+}
+
+/*
  * This function tries to determine if the same card is still present
  * and, if so, restore all state to it.
  */
-static int mmc_sd_resume(struct mmc_host *host)
+static int _mmc_sd_resume(struct mmc_host *host)
 {
 	int err = 0;
 
@@ -1122,6 +1134,21 @@ static int mmc_sd_resume(struct mmc_host *host)
 	return err;
 }
 
+/*
+ * Callback for resume
+ */
+static int mmc_sd_resume(struct mmc_host *host)
+{
+	int err;
+
+	err = _mmc_sd_resume(host);
+	pm_runtime_set_active(&host->card->dev);
+	pm_runtime_mark_last_busy(&host->card->dev);
+	pm_runtime_enable(&host->card->dev);
+
+	return err;
+}
+
 /*
  * Callback for runtime_suspend.
  */
@@ -1132,7 +1159,7 @@ static int mmc_sd_runtime_suspend(struct mmc_host *host)
 	if (!(host->caps & MMC_CAP_AGGRESSIVE_PM))
 		return 0;
 
-	err = mmc_sd_suspend(host);
+	err = _mmc_sd_suspend(host);
 	if (err)
 		pr_err("%s: error %d doing aggessive suspend\n",
 			mmc_hostname(host), err);
@@ -1150,7 +1177,7 @@ static int mmc_sd_runtime_resume(struct mmc_host *host)
 	if (!(host->caps & MMC_CAP_AGGRESSIVE_PM))
 		return 0;
 
-	err = mmc_sd_resume(host);
+	err = _mmc_sd_resume(host);
 	if (err)
 		pr_err("%s: error %d doing aggessive resume\n",
 			mmc_hostname(host), err);

commit 0cc81a8c6442e43618ff245948bfaa14fdf7938b
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu Oct 3 11:24:44 2013 +0200

    mmc: core: Remove redundant mmc_power_up|off at runtime callbacks
    
    Commit "mmc: core: Push common suspend|resume code into each bus_ops"
    moved the responsibility for doing mmc_power_up|off into each
    suspend/resume bus_ops. When using MMC_CAP_AGGRESSIVE_PM, through the
    runtime callbacks, calls to mmc_power_up|off became redundant.
    
    When removing them, we are also able to remove the calls to
    mmc_claim|release_host, thus simplifing code a bit more.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 685796560f8b..7b2854009e39 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -1132,18 +1132,11 @@ static int mmc_sd_runtime_suspend(struct mmc_host *host)
 	if (!(host->caps & MMC_CAP_AGGRESSIVE_PM))
 		return 0;
 
-	mmc_claim_host(host);
-
 	err = mmc_sd_suspend(host);
-	if (err) {
+	if (err)
 		pr_err("%s: error %d doing aggessive suspend\n",
 			mmc_hostname(host), err);
-		goto out;
-	}
-	mmc_power_off(host);
 
-out:
-	mmc_release_host(host);
 	return err;
 }
 
@@ -1157,15 +1150,11 @@ static int mmc_sd_runtime_resume(struct mmc_host *host)
 	if (!(host->caps & MMC_CAP_AGGRESSIVE_PM))
 		return 0;
 
-	mmc_claim_host(host);
-
-	mmc_power_up(host, host->card->ocr);
 	err = mmc_sd_resume(host);
 	if (err)
 		pr_err("%s: error %d doing aggessive resume\n",
 			mmc_hostname(host), err);
 
-	mmc_release_host(host);
 	return 0;
 }
 

commit 9ec775f7efd6d17084b4f361804d2030d50fca0e
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Wed Oct 2 17:37:09 2013 +0200

    mmc: Don't force card to active state when entering suspend/shutdown
    
    By adding a card state that records if it is suspended or resumed, we
    can accept asyncronus suspend/resume requests for the mmc and sd
    bus_ops.
    
    MMC_CAP_AGGRESSIVE_PM, will at request inactivity through the runtime
    bus_ops callbacks, execute a suspend of the the card. In the state were
    this has been done, we can receive a suspend request for the mmc bus,
    which for sd and mmc forced the card to active state by a
    pm_runtime_get_sync. In other words, the card was resumed and then
    immediately suspended again, completely unnecessary.
    
    Since the suspend/resume bus_ops callbacks for sd and mmc are now
    capable of handling asynchronous requests, we no longer need to force
    the card to active state before executing suspend. Evidently preventing
    the above sequence for MMC_CAP_AGGRESSIVE_PM.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 6ef84d0ca178..685796560f8b 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -1078,13 +1078,20 @@ static int mmc_sd_suspend(struct mmc_host *host)
 	BUG_ON(!host->card);
 
 	mmc_claim_host(host);
+
+	if (mmc_card_suspended(host->card))
+		goto out;
+
 	if (!mmc_host_is_spi(host))
 		err = mmc_deselect_cards(host);
 	host->card->state &= ~MMC_STATE_HIGHSPEED;
-	if (!err)
+	if (!err) {
 		mmc_power_off(host);
-	mmc_release_host(host);
+		mmc_card_set_suspended(host->card);
+	}
 
+out:
+	mmc_release_host(host);
 	return err;
 }
 
@@ -1096,16 +1103,22 @@ static int mmc_sd_suspend(struct mmc_host *host)
  */
 static int mmc_sd_resume(struct mmc_host *host)
 {
-	int err;
+	int err = 0;
 
 	BUG_ON(!host);
 	BUG_ON(!host->card);
 
 	mmc_claim_host(host);
+
+	if (!mmc_card_suspended(host->card))
+		goto out;
+
 	mmc_power_up(host, host->card->ocr);
 	err = mmc_sd_init_card(host, host->card->ocr, host->card);
-	mmc_release_host(host);
+	mmc_card_clr_suspended(host->card);
 
+out:
+	mmc_release_host(host);
 	return err;
 }
 

commit 726d6f2374410d980341bfeb49399614e689e702
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Mon Sep 16 12:06:15 2013 +0200

    mmc: core: Collect common code for card ocr validation
    
    Since mmc_select_voltage now only gets called from the attach sequence,
    it makes sense to move the out of spec validations of the card ocr into
    this function.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 53db60a76dae..6ef84d0ca178 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -1231,25 +1231,6 @@ int mmc_attach_sd(struct mmc_host *host)
 			goto err;
 	}
 
-	/*
-	 * Sanity check the voltages that the card claims to
-	 * support.
-	 */
-	if (ocr & 0x7F) {
-		pr_warning("%s: card claims to support voltages "
-		       "below the defined range. These will be ignored.\n",
-		       mmc_hostname(host));
-		ocr &= ~0x7F;
-	}
-
-	if ((ocr & MMC_VDD_165_195) &&
-	    !(host->ocr_avail_sd & MMC_VDD_165_195)) {
-		pr_warning("%s: SD card claims to support the "
-		       "incompletely defined 'low voltage range'. This "
-		       "will be ignored.\n", mmc_hostname(host));
-		ocr &= ~MMC_VDD_165_195;
-	}
-
 	rocr = mmc_select_voltage(host, ocr);
 
 	/*

commit ce69d37b7d8fa692c45d71d94aa0c921859b82ce
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Mon Sep 16 11:28:42 2013 +0200

    mmc: core: Prevent violation of specs while initializing cards
    
    According to eMMC/SD/SDIO specs, the VDD (VCC) voltage level must be
    maintained during the initialization sequence. If we want/need to tune
    the voltage level, a complete power cycle of the card must be executed.
    
    Most host drivers conforms to the specifications by only allowing to
    change VDD voltage level at the MMC_POWER_UP state, but some also cares
    about MMC_POWER_ON state, which they should'nt. This patch will not
    break those drivers, but they could clean up code to better reflect
    what is expected from the protocol layer.
    
    A big re-work of the mmc_select_voltage function is done to only change
    VDD voltage level if the host supports MMC_CAP2_FULL_PWR_CYCLE.
    Otherwise only validation of the host and card ocr mask will be done.
    
    A very nice side-effect of this patch is that we now don't need to
    reset the negotiated ocr mask at the mmc_power_off function, since now
    it will actually reflect the present voltage level, which safely can be
    used at the next power up and re-initialization. Moreover, we then only
    need to execute mmc_select_voltage from the attach sequence.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 398065c57edf..53db60a76dae 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -1103,7 +1103,6 @@ static int mmc_sd_resume(struct mmc_host *host)
 
 	mmc_claim_host(host);
 	mmc_power_up(host, host->card->ocr);
-	mmc_select_voltage(host, host->card->ocr);
 	err = mmc_sd_init_card(host, host->card->ocr, host->card);
 	mmc_release_host(host);
 

commit 6904115095ad60ced638eb1e36e0e4e5e7de00b0
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri Sep 13 11:31:33 2013 +0200

    mmc: core: Move cached value of the negotiated ocr mask to card struct
    
    The negotiated ocr mask is directly related to the card. Once a card
    gets removed, the mask shall be dropped. By moving the cache of the ocr
    mask from the host struct to the card struct we have accomplished this.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 5818887fffb3..398065c57edf 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -721,6 +721,7 @@ int mmc_sd_get_cid(struct mmc_host *host, u32 ocr, u32 *cid, u32 *rocr)
 	int err;
 	u32 max_current;
 	int retries = 10;
+	u32 pocr = ocr;
 
 try_again:
 	if (!retries) {
@@ -774,7 +775,7 @@ int mmc_sd_get_cid(struct mmc_host *host, u32 ocr, u32 *cid, u32 *rocr)
 	if (!mmc_host_is_spi(host) && rocr &&
 	   ((*rocr & 0x41000000) == 0x41000000)) {
 		err = mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_180,
-					host->ocr);
+					pocr);
 		if (err == -EAGAIN) {
 			retries--;
 			goto try_again;
@@ -936,6 +937,7 @@ static int mmc_sd_init_card(struct mmc_host *host, u32 ocr,
 		if (IS_ERR(card))
 			return PTR_ERR(card);
 
+		card->ocr = ocr;
 		card->type = MMC_TYPE_SD;
 		memcpy(card->raw_cid, cid, sizeof(card->raw_cid));
 	}
@@ -1100,9 +1102,9 @@ static int mmc_sd_resume(struct mmc_host *host)
 	BUG_ON(!host->card);
 
 	mmc_claim_host(host);
-	mmc_power_up(host, host->ocr);
-	mmc_select_voltage(host, host->ocr);
-	err = mmc_sd_init_card(host, host->ocr, host->card);
+	mmc_power_up(host, host->card->ocr);
+	mmc_select_voltage(host, host->card->ocr);
+	err = mmc_sd_init_card(host, host->card->ocr, host->card);
 	mmc_release_host(host);
 
 	return err;
@@ -1145,7 +1147,7 @@ static int mmc_sd_runtime_resume(struct mmc_host *host)
 
 	mmc_claim_host(host);
 
-	mmc_power_up(host, host->ocr);
+	mmc_power_up(host, host->card->ocr);
 	err = mmc_sd_resume(host);
 	if (err)
 		pr_err("%s: error %d doing aggessive resume\n",
@@ -1161,7 +1163,7 @@ static int mmc_sd_power_restore(struct mmc_host *host)
 
 	host->card->state &= ~MMC_STATE_HIGHSPEED;
 	mmc_claim_host(host);
-	ret = mmc_sd_init_card(host, host->ocr, host->card);
+	ret = mmc_sd_init_card(host, host->card->ocr, host->card);
 	mmc_release_host(host);
 
 	return ret;
@@ -1206,7 +1208,7 @@ static void mmc_sd_attach_bus_ops(struct mmc_host *host)
 int mmc_attach_sd(struct mmc_host *host)
 {
 	int err;
-	u32 ocr;
+	u32 ocr, rocr;
 
 	BUG_ON(!host);
 	WARN_ON(!host->claimed);
@@ -1249,12 +1251,12 @@ int mmc_attach_sd(struct mmc_host *host)
 		ocr &= ~MMC_VDD_165_195;
 	}
 
-	host->ocr = mmc_select_voltage(host, ocr);
+	rocr = mmc_select_voltage(host, ocr);
 
 	/*
 	 * Can we support the voltage(s) of the card(s)?
 	 */
-	if (!host->ocr) {
+	if (!rocr) {
 		err = -EINVAL;
 		goto err;
 	}
@@ -1262,7 +1264,7 @@ int mmc_attach_sd(struct mmc_host *host)
 	/*
 	 * Detect and init the card.
 	 */
-	err = mmc_sd_init_card(host, host->ocr, NULL);
+	err = mmc_sd_init_card(host, rocr, NULL);
 	if (err)
 		goto err;
 

commit 0f791fdad82a02af013e4fc8c385dc690080c366
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu Sep 12 15:36:34 2013 +0200

    mmc: core: Let mmc_set_signal_voltage take ocr as parameter
    
    This is yet another step of restructure code to be able to fixup the
    setup of the negotiated ocr mask.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index af55e9e0819c..5818887fffb3 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -773,7 +773,8 @@ int mmc_sd_get_cid(struct mmc_host *host, u32 ocr, u32 *cid, u32 *rocr)
 	 */
 	if (!mmc_host_is_spi(host) && rocr &&
 	   ((*rocr & 0x41000000) == 0x41000000)) {
-		err = mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_180);
+		err = mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_180,
+					host->ocr);
 		if (err == -EAGAIN) {
 			retries--;
 			goto try_again;

commit 4a065193c46a16f1ddf20622c7011c8f327e0478
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu Sep 12 14:36:53 2013 +0200

    mmc: core: Let mmc_power_up|cycle take ocr as parameter
    
    As a step to fixup the setup of the negotiated ocr mask, we need the
    mmc_power_up|cycle functions to take the ocr as a parameter.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 5e8823dc3ef6..af55e9e0819c 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -1099,7 +1099,7 @@ static int mmc_sd_resume(struct mmc_host *host)
 	BUG_ON(!host->card);
 
 	mmc_claim_host(host);
-	mmc_power_up(host);
+	mmc_power_up(host, host->ocr);
 	mmc_select_voltage(host, host->ocr);
 	err = mmc_sd_init_card(host, host->ocr, host->card);
 	mmc_release_host(host);
@@ -1144,7 +1144,7 @@ static int mmc_sd_runtime_resume(struct mmc_host *host)
 
 	mmc_claim_host(host);
 
-	mmc_power_up(host);
+	mmc_power_up(host, host->ocr);
 	err = mmc_sd_resume(host);
 	if (err)
 		pr_err("%s: error %d doing aggessive resume\n",

commit 77776fd0a4cc541b9a528eacc1d31ca47eb1ae7a
Author: Jaehoon Chung <jh80.chung@samsung.com>
Date:   Thu Jul 18 13:34:41 2013 +0900

    mmc: sd: fix the maximum au_size for SD3.0
    
    Since SD Physical Layer specification V3.0, AU_SIZE is supported up
    to 0xf.  So If SD-card is supported v3.0, then max_au should be 0xf.
    
    Signed-off-by: Jaehoon Chung <jh80.chung@samsung.com>
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 1240a85a9aa2..5e8823dc3ef6 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -215,7 +215,7 @@ static int mmc_decode_scr(struct mmc_card *card)
 static int mmc_read_ssr(struct mmc_card *card)
 {
 	unsigned int au, es, et, eo;
-	int err, i;
+	int err, i, max_au;
 	u32 *ssr;
 
 	if (!(card->csd.cmdclass & CCC_APP_SPEC)) {
@@ -239,12 +239,15 @@ static int mmc_read_ssr(struct mmc_card *card)
 	for (i = 0; i < 16; i++)
 		ssr[i] = be32_to_cpu(ssr[i]);
 
+	/* SD3.0 increases max AU size to 64MB (0xF) from 4MB (0x9) */
+	max_au = card->scr.sda_spec3 ? 0xF : 0x9;
+
 	/*
 	 * UNSTUFF_BITS only works with four u32s so we have to offset the
 	 * bitfield positions accordingly.
 	 */
 	au = UNSTUFF_BITS(ssr, 428 - 384, 4);
-	if (au > 0 && au <= 9) {
+	if (au > 0 && au <= max_au) {
 		card->ssr.au = 1 << (au + 4);
 		es = UNSTUFF_BITS(ssr, 408 - 384, 16);
 		et = UNSTUFF_BITS(ssr, 402 - 384, 6);

commit 7fca96758e977497c67a424006c60aaf2d3db212
Author: Wei WANG <wei_wang@realsil.com.cn>
Date:   Wed Jul 17 14:21:10 2013 +0800

    mmc: core: free mmc_card if cmd 3,9,7 fails in mmc_sd_init_card
    
    In function mmc_sd_init_card, if command 3/9/7 got failed, mmc_card
    allocated just before won't be freed. This would cause memory leak.
    
    Signed-off-by: Wei WANG <wei_wang@realsil.com.cn>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 176d125f5b57..1240a85a9aa2 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -942,13 +942,13 @@ static int mmc_sd_init_card(struct mmc_host *host, u32 ocr,
 	if (!mmc_host_is_spi(host)) {
 		err = mmc_send_relative_addr(host, &card->rca);
 		if (err)
-			return err;
+			goto free_card;
 	}
 
 	if (!oldcard) {
 		err = mmc_sd_get_csd(host, card);
 		if (err)
-			return err;
+			goto free_card;
 
 		mmc_decode_cid(card);
 	}
@@ -959,7 +959,7 @@ static int mmc_sd_init_card(struct mmc_host *host, u32 ocr,
 	if (!mmc_host_is_spi(host)) {
 		err = mmc_select_card(card);
 		if (err)
-			return err;
+			goto free_card;
 	}
 
 	err = mmc_sd_setup_card(host, card, oldcard != NULL);

commit 5992e78697484d8f58b749f87a06f89f4ba40a47
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Mon Jun 10 17:03:42 2013 +0200

    mmc: core: Add shutdown callback for SD bus_ops
    
    For the SD .shutdown callback we re-use the SD suspend function since
    it performs the relevant actions.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index cacef27b00d1..176d125f5b57 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -1170,6 +1170,7 @@ static const struct mmc_bus_ops mmc_sd_ops = {
 	.resume = NULL,
 	.power_restore = mmc_sd_power_restore,
 	.alive = mmc_sd_alive,
+	.shutdown = mmc_sd_suspend,
 };
 
 static const struct mmc_bus_ops mmc_sd_ops_unsafe = {
@@ -1181,6 +1182,7 @@ static const struct mmc_bus_ops mmc_sd_ops_unsafe = {
 	.resume = mmc_sd_resume,
 	.power_restore = mmc_sd_power_restore,
 	.alive = mmc_sd_alive,
+	.shutdown = mmc_sd_suspend,
 };
 
 static void mmc_sd_attach_bus_ops(struct mmc_host *host)

commit 74590263384e5d4601de7f0ee2790477578829ea
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Mon Jun 10 17:03:38 2013 +0200

    mmc: core: Push common suspend|resume code into each bus_ops
    
    By moving code from the mmc_suspend|resume_host down into each
    .suspend|resume bus_ops callback, we get a more flexible solution.
    
    Some nice side effects are that we get a better understanding of each
    bus_ops suspend|resume sequence and the common code don't have to take
    care of specific corner cases, especially for the SDIO case.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Tested-by: Jaehoon Chung <jh80.chung@samsung.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index aeaae7c3b22b..cacef27b00d1 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -1075,6 +1075,8 @@ static int mmc_sd_suspend(struct mmc_host *host)
 	if (!mmc_host_is_spi(host))
 		err = mmc_deselect_cards(host);
 	host->card->state &= ~MMC_STATE_HIGHSPEED;
+	if (!err)
+		mmc_power_off(host);
 	mmc_release_host(host);
 
 	return err;
@@ -1094,6 +1096,8 @@ static int mmc_sd_resume(struct mmc_host *host)
 	BUG_ON(!host->card);
 
 	mmc_claim_host(host);
+	mmc_power_up(host);
+	mmc_select_voltage(host, host->ocr);
 	err = mmc_sd_init_card(host, host->ocr, host->card);
 	mmc_release_host(host);
 

commit c4d770d72492df510077b277f21ac5f0dad9e5eb
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu May 2 14:02:39 2013 +0200

    mmc: core: Support aggressive power management for (e)MMC/SD
    
    Aggressive power management is suitable when saving power is
    essential. At request inactivity timeout, aka pm runtime
    autosuspend timeout, the card will be suspended.
    
    Once a new request arrives, the card will be re-initalized and
    thus the first request will suffer from a latency. This latency
    is card-specific, experiments has shown in general that SD-cards
    has quite poor initialization time, around 300ms-1100ms. eMMC is
    not surprisingly far better but still a couple of hundreds of ms
    has been observed.
    
    Except for the request latency, it is important to know that
    suspending the card will also prevent the card from executing
    internal house-keeping operations in idle mode. This could mean
    degradation in performance.
    
    To use this feature make sure the request inactivity timeout is
    chosen carefully. This has not been done as a part of this patch.
    
    Enable this feature by using host cap MMC_CAP_AGGRESSIVE_PM and
    by setting CONFIG_MMC_UNSAFE_RESUME.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 17fa2d271dd4..aeaae7c3b22b 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -1100,6 +1100,53 @@ static int mmc_sd_resume(struct mmc_host *host)
 	return err;
 }
 
+/*
+ * Callback for runtime_suspend.
+ */
+static int mmc_sd_runtime_suspend(struct mmc_host *host)
+{
+	int err;
+
+	if (!(host->caps & MMC_CAP_AGGRESSIVE_PM))
+		return 0;
+
+	mmc_claim_host(host);
+
+	err = mmc_sd_suspend(host);
+	if (err) {
+		pr_err("%s: error %d doing aggessive suspend\n",
+			mmc_hostname(host), err);
+		goto out;
+	}
+	mmc_power_off(host);
+
+out:
+	mmc_release_host(host);
+	return err;
+}
+
+/*
+ * Callback for runtime_resume.
+ */
+static int mmc_sd_runtime_resume(struct mmc_host *host)
+{
+	int err;
+
+	if (!(host->caps & MMC_CAP_AGGRESSIVE_PM))
+		return 0;
+
+	mmc_claim_host(host);
+
+	mmc_power_up(host);
+	err = mmc_sd_resume(host);
+	if (err)
+		pr_err("%s: error %d doing aggessive resume\n",
+			mmc_hostname(host), err);
+
+	mmc_release_host(host);
+	return 0;
+}
+
 static int mmc_sd_power_restore(struct mmc_host *host)
 {
 	int ret;
@@ -1124,6 +1171,8 @@ static const struct mmc_bus_ops mmc_sd_ops = {
 static const struct mmc_bus_ops mmc_sd_ops_unsafe = {
 	.remove = mmc_sd_remove,
 	.detect = mmc_sd_detect,
+	.runtime_suspend = mmc_sd_runtime_suspend,
+	.runtime_resume = mmc_sd_runtime_resume,
 	.suspend = mmc_sd_suspend,
 	.resume = mmc_sd_resume,
 	.power_restore = mmc_sd_power_restore,

commit e94cfef698aae6b209d8918dd319312e4b02118d
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu May 2 14:02:38 2013 +0200

    mmc: block: Enable runtime pm for mmc blkdevice
    
    Once the mmc blkdevice is being probed, runtime pm will be enabled.
    By using runtime autosuspend, the power save operations can be done
    when request inactivity occurs for a certain time. Right now the
    selected timeout value is set to 3 s. Obviously this value will likely
    need to be configurable somehow since it needs to be trimmed depending
    on the power save algorithm.
    
    For SD-combo cards, we are still leaving the enablement of runtime PM
    to the SDIO init sequence since it depends on the capabilities of the
    SDIO func driver.
    
    Moreover, when the blk device is being suspended, we make sure the device
    will be runtime resumed. The reason for doing this is that we want the
    host suspend sequence to be unaware of any runtime power save operations
    done for the card in this phase. Thus it can just handle the suspend as
    the card is fully powered from a runtime perspective.
    
    Finally, this patch prepares to make it possible to move BKOPS handling
    into the runtime callbacks for the mmc bus_ops. Thus IDLE BKOPS can be
    accomplished.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 8373d2288bb1..17fa2d271dd4 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -1042,14 +1042,14 @@ static void mmc_sd_detect(struct mmc_host *host)
 	BUG_ON(!host);
 	BUG_ON(!host->card);
 
-	mmc_claim_host(host);
+	mmc_get_card(host->card);
 
 	/*
 	 * Just check if our card has been removed.
 	 */
 	err = _mmc_detect_card_removed(host);
 
-	mmc_release_host(host);
+	mmc_put_card(host->card);
 
 	if (err) {
 		mmc_sd_remove(host);

commit 810e08ee425f8d7327e4b30069a9b2b3dccfc67d
Author: Fredrik Soderstedt <fredrik.soderstedt@stericsson.com>
Date:   Wed Apr 17 13:50:53 2013 +0200

    mmc: core: Only execute tuning for SDR50 and SDR104
    
    Only execute tuning for sd and sdio devices that are using
    SDR50 or SDR104.
    
    Make sure clock is hold during tuning for sdio devices.
    
    Signed-off-by: Fredrik Soderstedt <fredrik.soderstedt@stericsson.com>
    Acked-by: Johan Rudholm <jrudholm@gmail.com>
    Acked-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 9e645e19cec6..8373d2288bb1 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -646,8 +646,13 @@ static int mmc_sd_init_uhs_card(struct mmc_card *card)
 	if (err)
 		goto out;
 
-	/* SPI mode doesn't define CMD19 */
-	if (!mmc_host_is_spi(card->host) && card->host->ops->execute_tuning) {
+	/*
+	 * SPI mode doesn't define CMD19 and tuning is only valid for SDR50 and
+	 * SDR104 mode SD-cards. Note that tuning is mandatory for SDR104.
+	 */
+	if (!mmc_host_is_spi(card->host) && card->host->ops->execute_tuning &&
+			(card->sd_bus_speed == UHS_SDR50_BUS_SPEED ||
+			 card->sd_bus_speed == UHS_SDR104_BUS_SPEED)) {
 		mmc_host_clk_hold(card->host);
 		err = card->host->ops->execute_tuning(card->host,
 						      MMC_SEND_TUNING_BLOCK);

commit 52983382c74f59a3953e622d7661a24e1bc4388a
Author: Kevin Liu <kliu5@marvell.com>
Date:   Thu Jan 31 11:31:37 2013 +0800

    mmc: sdhci: enhance preset value function
    
    4d55c5a1 ("mmc: sdhci: enable preset value after uhs initialization")
    added preset value support and enabled it by default during sd card init.
    
    Below are the enhancements introduced by this patch:
    
    1. In current code, preset value is enabled after setting clock finished,
    which means the clock is manually set by driver firstly and then suddenly
    switched to preset value at this point. So the first setting is useless
    and unnecessary. What's more, the first clock setting may differ from the
    preset one.  The better way is enable preset value just after switch to
    UHS mode so the preset value can take effect immediately. So move preset
    value enable from mmc_sd_init_card to sdhci_set_ios which will be called
    during set timing.
    
    2. In current code, preset value is disabled at the beginning of
    mmc_attach_sd.  It's too late since low freq (400khz) should be set in
    mmc_power_up.  So move preset value disable to sdhci_set_ios which will
    be called during power up.
    
    3. host->clock and ios->drv_type should also be updated according to the
    preset value if it's enabled. Current code missed this.
    
    4. This patch also introduce a quirk to disable preset value in case
    preset value doesn't work.
    
    This patch has been verified on sdhci-pxav3 platform with both preset
    enabled and disabled.
    
    Signed-off-by: Kevin Liu <kliu5@marvell.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 03134b1e563c..9e645e19cec6 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -969,16 +969,6 @@ static int mmc_sd_init_card(struct mmc_host *host, u32 ocr,
 
 		/* Card is an ultra-high-speed card */
 		mmc_card_set_uhs(card);
-
-		/*
-		 * Since initialization is now complete, enable preset
-		 * value registers for UHS-I cards.
-		 */
-		if (host->ops->enable_preset_value) {
-			mmc_host_clk_hold(card->host);
-			host->ops->enable_preset_value(host, true);
-			mmc_host_clk_release(card->host);
-		}
 	} else {
 		/*
 		 * Attempt to change to high-speed (if supported)
@@ -1157,13 +1147,6 @@ int mmc_attach_sd(struct mmc_host *host)
 	BUG_ON(!host);
 	WARN_ON(!host->claimed);
 
-	/* Disable preset value enable if already set since last time */
-	if (host->ops->enable_preset_value) {
-		mmc_host_clk_hold(host);
-		host->ops->enable_preset_value(host, false);
-		mmc_host_clk_release(host);
-	}
-
 	err = mmc_send_app_op_cond(host, 0, &ocr);
 	if (err)
 		return err;

commit 0797e5f1453b2bedc08bbcbea0ea4fbe20350823
Author: Johan Rudholm <johan.rudholm@stericsson.com>
Date:   Mon Jan 28 15:08:28 2013 +0100

    mmc: core: Fixup signal voltage switch
    
    When switching SD and SDIO cards from 3.3V to 1.8V signal levels, the
    clock should be gated for 5 ms during the step. After enabling the
    clock, the host should wait for at least 1 ms before checking for
    failure. Failure by the card to switch is indicated by dat[0:3] being
    pulled low. The host should check for this condition and power-cycle
    the card if failure is indicated.
    
    Add a retry mechanism for the SDIO case.
    
    If the voltage switch fails repeatedly, give up and continue the
    initialization using the original voltage.
    
    This patch places a couple of requirements on the host driver:
    
     1) mmc_set_ios with ios.clock = 0 must gate the clock
     2) mmc_power_off must actually cut the power to the card
     3) The card_busy host_ops member must be implemented
    
    if these requirements are not fulfilled, the 1.8V signal voltage switch
    will still be attempted but may not be successful.
    
    Signed-off-by: Johan Rudholm <johan.rudholm@stericsson.com>
    Signed-off-by: Kevin Liu <kliu5@marvell.com>
    Acked-by: Ulf Hansson <ulf.hansson@linaro.org>
    Tested-by: Wei WANG <wei_wang@realsil.com.cn>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 9a59fcd55a75..03134b1e563c 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -712,6 +712,14 @@ int mmc_sd_get_cid(struct mmc_host *host, u32 ocr, u32 *cid, u32 *rocr)
 {
 	int err;
 	u32 max_current;
+	int retries = 10;
+
+try_again:
+	if (!retries) {
+		ocr &= ~SD_OCR_S18R;
+		pr_warning("%s: Skipping voltage switch\n",
+			mmc_hostname(host));
+	}
 
 	/*
 	 * Since we're changing the OCR value, we seem to
@@ -733,9 +741,10 @@ int mmc_sd_get_cid(struct mmc_host *host, u32 ocr, u32 *cid, u32 *rocr)
 
 	/*
 	 * If the host supports one of UHS-I modes, request the card
-	 * to switch to 1.8V signaling level.
+	 * to switch to 1.8V signaling level. If the card has failed
+	 * repeatedly to switch however, skip this.
 	 */
-	if (mmc_host_uhs(host))
+	if (retries && mmc_host_uhs(host))
 		ocr |= SD_OCR_S18R;
 
 	/*
@@ -746,7 +755,6 @@ int mmc_sd_get_cid(struct mmc_host *host, u32 ocr, u32 *cid, u32 *rocr)
 	if (max_current > 150)
 		ocr |= SD_OCR_XPC;
 
-try_again:
 	err = mmc_send_app_op_cond(host, ocr, rocr);
 	if (err)
 		return err;
@@ -758,8 +766,11 @@ int mmc_sd_get_cid(struct mmc_host *host, u32 ocr, u32 *cid, u32 *rocr)
 	if (!mmc_host_is_spi(host) && rocr &&
 	   ((*rocr & 0x41000000) == 0x41000000)) {
 		err = mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_180);
-		if (err) {
-			ocr &= ~SD_OCR_S18R;
+		if (err == -EAGAIN) {
+			retries--;
+			goto try_again;
+		} else if (err) {
+			retries = 0;
 			goto try_again;
 		}
 	}

commit 567c89032cfdda8047562abe450947ac01f2d3c7
Author: Johan Rudholm <johan.rudholm@stericsson.com>
Date:   Mon Jan 28 15:08:27 2013 +0100

    mmc: core: Break out start_signal_voltage_switch
    
    Allow callers to access the start_signal_voltage_switch host_ops
    member without going through any cmd11 logic. This is mostly a
    preparation for the following signal voltage switch patch.
    
    Also, reset ios.signal_voltage to its original value if
    start_signal_voltage_switch fails.
    
    Signed-off-by: Johan Rudholm <johan.rudholm@stericsson.com>
    Acked-by: Ulf Hansson <ulf.hansson@linaro.org>
    Tested-by: Wei WANG <wei_wang@realsil.com.cn>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 937363948079..9a59fcd55a75 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -757,7 +757,7 @@ int mmc_sd_get_cid(struct mmc_host *host, u32 ocr, u32 *cid, u32 *rocr)
 	 */
 	if (!mmc_host_is_spi(host) && rocr &&
 	   ((*rocr & 0x41000000) == 0x41000000)) {
-		err = mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_180, true);
+		err = mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_180);
 		if (err) {
 			ocr &= ~SD_OCR_S18R;
 			goto try_again;

commit 3f8a7fabd60e83eb2fb7add00d353d455c0e7a78
Author: Johan Rudholm <johan.rudholm@stericsson.com>
Date:   Mon Jan 28 15:08:24 2013 +0100

    mmc: sd: Simplify by using mmc_host_uhs
    
    Signed-off-by: Johan Rudholm <johan.rudholm@stericsson.com>
    Acked-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 74972c241dff..937363948079 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -444,8 +444,7 @@ static void sd_update_bus_speed_mode(struct mmc_card *card)
 	 * If the host doesn't support any of the UHS-I modes, fallback on
 	 * default speed.
 	 */
-	if (!(card->host->caps & (MMC_CAP_UHS_SDR12 | MMC_CAP_UHS_SDR25 |
-	    MMC_CAP_UHS_SDR50 | MMC_CAP_UHS_SDR104 | MMC_CAP_UHS_DDR50))) {
+	if (!mmc_host_uhs(card->host)) {
 		card->sd_bus_speed = 0;
 		return;
 	}
@@ -736,8 +735,7 @@ int mmc_sd_get_cid(struct mmc_host *host, u32 ocr, u32 *cid, u32 *rocr)
 	 * If the host supports one of UHS-I modes, request the card
 	 * to switch to 1.8V signaling level.
 	 */
-	if (host->caps & (MMC_CAP_UHS_SDR12 | MMC_CAP_UHS_SDR25 |
-	    MMC_CAP_UHS_SDR50 | MMC_CAP_UHS_SDR104 | MMC_CAP_UHS_DDR50))
+	if (mmc_host_uhs(host))
 		ocr |= SD_OCR_S18R;
 
 	/*

commit 108ecc4cf9c46a4caabaf18efc42d19818c95b70
Author: Aaron Lu <aaron.lu@amd.com>
Date:   Tue Jul 10 16:55:37 2012 +0800

    mmc: core: reset signal voltage on power up
    
    Add a call to mmc_set_signal_voltage() to set signal voltage to 3.3v in
    mmc_power_up so that we do not need to touch signal voltage setting in
    mmc/sd/sdio init functions and rescan function.
    
    For mmc/sd cards, when doing a suspend/resume cycle, consider the unsafe
    resume case, the card will lose its power and when powered on again, we
    will set signal voltage to 3.3v in mmc_power_up before its resume function
    gets called, which will re-init the card.
    
    And for sdio cards, when doing a suspend/resume cycle, consider the unsafe
    resume case, the card will either lose its power or not depending on if it
    wants to wakeup the host. If power is not maintained, it is the same case as
    mmc/sd cards. If power is maintained, mmc_power_up will not be called and
    the card's signal voltage will remain at the last setting.
    
    Signed-off-by: Aaron Lu <aaron.lu@amd.com>
    Tested-by: Venkatraman S <svenkatr@ti.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 441bdf472c99..74972c241dff 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -901,9 +901,6 @@ static int mmc_sd_init_card(struct mmc_host *host, u32 ocr,
 	BUG_ON(!host);
 	WARN_ON(!host->claimed);
 
-	/* The initialization should be done at 3.3 V I/O voltage. */
-	mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_330, 0);
-
 	err = mmc_sd_get_cid(host, ocr, cid, &rocr);
 	if (err)
 		return err;

commit 55c4665ea0a42fd6427826bfce96eb4b0389262a
Author: Aaron Lu <aaron.lu@amd.com>
Date:   Wed Jul 4 13:31:48 2012 +0800

    mmc: sd: Fix sd current limit setting
    
    Host has different current capabilities at different voltages, we need
    to record these settings seperately. The defined voltages are 1.8/3.0/3.3.
    For other voltages, we do not touch current limit setting.
    
    Before we set the current limit for the sd card, find out the host's
    operating voltage first and then find out the current capabilities of
    the host at that voltage to set the current limit.
    
    Signed-off-by: Aaron Lu <aaron.lu@amd.com>
    Reviewed-by: Philip Rakity <prakity@marvell.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 8460568e5213..441bdf472c99 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -517,15 +517,54 @@ static int sd_set_bus_speed_mode(struct mmc_card *card, u8 *status)
 	return 0;
 }
 
+/* Get host's max current setting at its current voltage */
+static u32 sd_get_host_max_current(struct mmc_host *host)
+{
+	u32 voltage, max_current;
+
+	voltage = 1 << host->ios.vdd;
+	switch (voltage) {
+	case MMC_VDD_165_195:
+		max_current = host->max_current_180;
+		break;
+	case MMC_VDD_29_30:
+	case MMC_VDD_30_31:
+		max_current = host->max_current_300;
+		break;
+	case MMC_VDD_32_33:
+	case MMC_VDD_33_34:
+		max_current = host->max_current_330;
+		break;
+	default:
+		max_current = 0;
+	}
+
+	return max_current;
+}
+
 static int sd_set_current_limit(struct mmc_card *card, u8 *status)
 {
 	int current_limit = SD_SET_CURRENT_NO_CHANGE;
 	int err;
+	u32 max_current;
 
 	/*
 	 * Current limit switch is only defined for SDR50, SDR104, and DDR50
 	 * bus speed modes. For other bus speed modes, we do not change the
 	 * current limit.
+	 */
+	if ((card->sd_bus_speed != UHS_SDR50_BUS_SPEED) &&
+	    (card->sd_bus_speed != UHS_SDR104_BUS_SPEED) &&
+	    (card->sd_bus_speed != UHS_DDR50_BUS_SPEED))
+		return 0;
+
+	/*
+	 * Host has different current capabilities when operating at
+	 * different voltages, so find out its max current first.
+	 */
+	max_current = sd_get_host_max_current(card->host);
+
+	/*
 	 * We only check host's capability here, if we set a limit that is
 	 * higher than the card's maximum current, the card will be using its
 	 * maximum current, e.g. if the card's maximum current is 300ma, and
@@ -533,18 +572,14 @@ static int sd_set_current_limit(struct mmc_card *card, u8 *status)
 	 * when we set current limit to 400/600/800ma, the card will draw its
 	 * maximum 300ma from the host.
 	 */
-	if ((card->sd_bus_speed == UHS_SDR50_BUS_SPEED) ||
-	    (card->sd_bus_speed == UHS_SDR104_BUS_SPEED) ||
-	    (card->sd_bus_speed == UHS_DDR50_BUS_SPEED)) {
-		if (card->host->caps & MMC_CAP_MAX_CURRENT_800)
-			current_limit = SD_SET_CURRENT_LIMIT_800;
-		else if (card->host->caps & MMC_CAP_MAX_CURRENT_600)
-			current_limit = SD_SET_CURRENT_LIMIT_600;
-		else if (card->host->caps & MMC_CAP_MAX_CURRENT_400)
-			current_limit = SD_SET_CURRENT_LIMIT_400;
-		else if (card->host->caps & MMC_CAP_MAX_CURRENT_200)
-			current_limit = SD_SET_CURRENT_LIMIT_200;
-	}
+	if (max_current >= 800)
+		current_limit = SD_SET_CURRENT_LIMIT_800;
+	else if (max_current >= 600)
+		current_limit = SD_SET_CURRENT_LIMIT_600;
+	else if (max_current >= 400)
+		current_limit = SD_SET_CURRENT_LIMIT_400;
+	else if (max_current >= 200)
+		current_limit = SD_SET_CURRENT_LIMIT_200;
 
 	if (current_limit != SD_SET_CURRENT_NO_CHANGE) {
 		err = mmc_sd_switch(card, 1, 3, current_limit, status);
@@ -677,6 +712,7 @@ struct device_type sd_type = {
 int mmc_sd_get_cid(struct mmc_host *host, u32 ocr, u32 *cid, u32 *rocr)
 {
 	int err;
+	u32 max_current;
 
 	/*
 	 * Since we're changing the OCR value, we seem to
@@ -704,9 +740,12 @@ int mmc_sd_get_cid(struct mmc_host *host, u32 ocr, u32 *cid, u32 *rocr)
 	    MMC_CAP_UHS_SDR50 | MMC_CAP_UHS_SDR104 | MMC_CAP_UHS_DDR50))
 		ocr |= SD_OCR_S18R;
 
-	/* If the host can supply more than 150mA, XPC should be set to 1. */
-	if (host->caps & (MMC_CAP_SET_XPC_330 | MMC_CAP_SET_XPC_300 |
-	    MMC_CAP_SET_XPC_180))
+	/*
+	 * If the host can supply more than 150mA at current voltage,
+	 * XPC should be set to 1.
+	 */
+	max_current = sd_get_host_max_current(host);
+	if (max_current > 150)
 		ocr |= SD_OCR_XPC;
 
 try_again:

commit a39ca6ae0a08994a59d017a445939e164bc77fd5
Author: Aaron Lu <aaron.lu@amd.com>
Date:   Tue Jul 3 14:16:11 2012 +0800

    mmc: core: Simplify and fix for SD switch processing
    
    In mmc_read_switch, just do a one time mode 0 switch command to get the
    support bits information, no need to do multiple times as the support
    bits do not change with different arguments.
    
    And no need to check current limit support bits, as these bits are
    fixed according to the signal voltage. If the signal voltage is 1.8V,
    the support bits would be 0xf and if the signal voltage is 3.3V, the
    support bits would be 0x01. We will check host's ability to set the
    current limit.
    
    Signed-off-by: Aaron Lu <aaron.lu@amd.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 33c6f26c68d0..8460568e5213 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -290,8 +290,12 @@ static int mmc_read_switch(struct mmc_card *card)
 		return -ENOMEM;
 	}
 
-	/* Find out the supported Bus Speed Modes. */
-	err = mmc_sd_switch(card, 0, 0, 1, status);
+	/*
+	 * Find out the card's support bits with a mode 0 operation.
+	 * The argument does not matter, as the support bits do not
+	 * change with the arguments.
+	 */
+	err = mmc_sd_switch(card, 0, 0, 0, status);
 	if (err) {
 		/*
 		 * If the host or the card can't do the switch,
@@ -312,46 +316,8 @@ static int mmc_read_switch(struct mmc_card *card)
 
 	if (card->scr.sda_spec3) {
 		card->sw_caps.sd3_bus_mode = status[13];
-
-		/* Find out Driver Strengths supported by the card */
-		err = mmc_sd_switch(card, 0, 2, 1, status);
-		if (err) {
-			/*
-			 * If the host or the card can't do the switch,
-			 * fail more gracefully.
-			 */
-			if (err != -EINVAL && err != -ENOSYS && err != -EFAULT)
-				goto out;
-
-			pr_warning("%s: problem reading "
-				"Driver Strength.\n",
-				mmc_hostname(card->host));
-			err = 0;
-
-			goto out;
-		}
-
+		/* Driver Strengths supported by the card */
 		card->sw_caps.sd3_drv_type = status[9];
-
-		/* Find out Current Limits supported by the card */
-		err = mmc_sd_switch(card, 0, 3, 1, status);
-		if (err) {
-			/*
-			 * If the host or the card can't do the switch,
-			 * fail more gracefully.
-			 */
-			if (err != -EINVAL && err != -ENOSYS && err != -EFAULT)
-				goto out;
-
-			pr_warning("%s: problem reading "
-				"Current Limit.\n",
-				mmc_hostname(card->host));
-			err = 0;
-
-			goto out;
-		}
-
-		card->sw_caps.sd3_curr_limit = status[7];
 	}
 
 out:
@@ -560,41 +526,24 @@ static int sd_set_current_limit(struct mmc_card *card, u8 *status)
 	 * Current limit switch is only defined for SDR50, SDR104, and DDR50
 	 * bus speed modes. For other bus speed modes, we do not change the
 	 * current limit.
+	 * We only check host's capability here, if we set a limit that is
+	 * higher than the card's maximum current, the card will be using its
+	 * maximum current, e.g. if the card's maximum current is 300ma, and
+	 * when we set current limit to 200ma, the card will draw 200ma, and
+	 * when we set current limit to 400/600/800ma, the card will draw its
+	 * maximum 300ma from the host.
 	 */
 	if ((card->sd_bus_speed == UHS_SDR50_BUS_SPEED) ||
 	    (card->sd_bus_speed == UHS_SDR104_BUS_SPEED) ||
 	    (card->sd_bus_speed == UHS_DDR50_BUS_SPEED)) {
-		if (card->host->caps & MMC_CAP_MAX_CURRENT_800) {
-			if (card->sw_caps.sd3_curr_limit & SD_MAX_CURRENT_800)
-				current_limit = SD_SET_CURRENT_LIMIT_800;
-			else if (card->sw_caps.sd3_curr_limit &
-					SD_MAX_CURRENT_600)
-				current_limit = SD_SET_CURRENT_LIMIT_600;
-			else if (card->sw_caps.sd3_curr_limit &
-					SD_MAX_CURRENT_400)
-				current_limit = SD_SET_CURRENT_LIMIT_400;
-			else if (card->sw_caps.sd3_curr_limit &
-					SD_MAX_CURRENT_200)
-				current_limit = SD_SET_CURRENT_LIMIT_200;
-		} else if (card->host->caps & MMC_CAP_MAX_CURRENT_600) {
-			if (card->sw_caps.sd3_curr_limit & SD_MAX_CURRENT_600)
-				current_limit = SD_SET_CURRENT_LIMIT_600;
-			else if (card->sw_caps.sd3_curr_limit &
-					SD_MAX_CURRENT_400)
-				current_limit = SD_SET_CURRENT_LIMIT_400;
-			else if (card->sw_caps.sd3_curr_limit &
-					SD_MAX_CURRENT_200)
-				current_limit = SD_SET_CURRENT_LIMIT_200;
-		} else if (card->host->caps & MMC_CAP_MAX_CURRENT_400) {
-			if (card->sw_caps.sd3_curr_limit & SD_MAX_CURRENT_400)
-				current_limit = SD_SET_CURRENT_LIMIT_400;
-			else if (card->sw_caps.sd3_curr_limit &
-					SD_MAX_CURRENT_200)
-				current_limit = SD_SET_CURRENT_LIMIT_200;
-		} else if (card->host->caps & MMC_CAP_MAX_CURRENT_200) {
-			if (card->sw_caps.sd3_curr_limit & SD_MAX_CURRENT_200)
-				current_limit = SD_SET_CURRENT_LIMIT_200;
-		}
+		if (card->host->caps & MMC_CAP_MAX_CURRENT_800)
+			current_limit = SD_SET_CURRENT_LIMIT_800;
+		else if (card->host->caps & MMC_CAP_MAX_CURRENT_600)
+			current_limit = SD_SET_CURRENT_LIMIT_600;
+		else if (card->host->caps & MMC_CAP_MAX_CURRENT_400)
+			current_limit = SD_SET_CURRENT_LIMIT_400;
+		else if (card->host->caps & MMC_CAP_MAX_CURRENT_200)
+			current_limit = SD_SET_CURRENT_LIMIT_200;
 	}
 
 	if (current_limit != SD_SET_CURRENT_NO_CHANGE) {
@@ -607,6 +556,7 @@ static int sd_set_current_limit(struct mmc_card *card, u8 *status)
 				mmc_hostname(card->host));
 
 	}
+
 	return 0;
 }
 

commit b63b5e819d5b21ae493c17c356018ffa98d3ee1c
Author: Alan Cox <alan@linux.intel.com>
Date:   Mon Jul 2 18:55:13 2012 +0100

    mmc: core: correct invalid error checking
    
    The effect of the existing code is that we continue blindly when we
    should warn about an invalid allocation unit.
    
    Reported-by: dcb314@hotmail.com
    Resolves-bug: https://bugzilla.kernel.org/show_bug.cgi?id=44061
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index b0b9e372f5da..33c6f26c68d0 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -244,7 +244,7 @@ static int mmc_read_ssr(struct mmc_card *card)
 	 * bitfield positions accordingly.
 	 */
 	au = UNSTUFF_BITS(ssr, 428 - 384, 4);
-	if (au > 0 || au <= 9) {
+	if (au > 0 && au <= 9) {
 		card->ssr.au = 1 << (au + 4);
 		es = UNSTUFF_BITS(ssr, 408 - 384, 16);
 		et = UNSTUFF_BITS(ssr, 402 - 384, 6);

commit 0aa6770000bafa65c17cf44b6619d328d4fc79b3
Author: Philip Rakity <prakity@marvell.com>
Date:   Sun May 27 18:36:33 2012 -0700

    mmc: sdhci: only set 200mA support for 1.8v if 200mA is available
    
    max_current_caps can return 0 if not available from the sd controller.
    If no regulator is present or the regulator specifies a current
    less then 200ma, we no longer still set the 200mA caps bit anyway.
    
    Signed-off-by: Philip Rakity <prakity@marvell.com>
    Reviewed-by: Aaron Lu <aaron_lu@amd.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index b2b43f624b9e..b0b9e372f5da 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -553,13 +553,13 @@ static int sd_set_bus_speed_mode(struct mmc_card *card, u8 *status)
 
 static int sd_set_current_limit(struct mmc_card *card, u8 *status)
 {
-	int current_limit = 0;
+	int current_limit = SD_SET_CURRENT_NO_CHANGE;
 	int err;
 
 	/*
 	 * Current limit switch is only defined for SDR50, SDR104, and DDR50
-	 * bus speed modes. For other bus speed modes, we set the default
-	 * current limit of 200mA.
+	 * bus speed modes. For other bus speed modes, we do not change the
+	 * current limit.
 	 */
 	if ((card->sd_bus_speed == UHS_SDR50_BUS_SPEED) ||
 	    (card->sd_bus_speed == UHS_SDR104_BUS_SPEED) ||
@@ -595,17 +595,18 @@ static int sd_set_current_limit(struct mmc_card *card, u8 *status)
 			if (card->sw_caps.sd3_curr_limit & SD_MAX_CURRENT_200)
 				current_limit = SD_SET_CURRENT_LIMIT_200;
 		}
-	} else
-		current_limit = SD_SET_CURRENT_LIMIT_200;
+	}
 
-	err = mmc_sd_switch(card, 1, 3, current_limit, status);
-	if (err)
-		return err;
+	if (current_limit != SD_SET_CURRENT_NO_CHANGE) {
+		err = mmc_sd_switch(card, 1, 3, current_limit, status);
+		if (err)
+			return err;
 
-	if (((status[15] >> 4) & 0x0F) != current_limit)
-		pr_warning("%s: Problem setting current limit!\n",
-			mmc_hostname(card->host));
+		if (((status[15] >> 4) & 0x0F) != current_limit)
+			pr_warning("%s: Problem setting current limit!\n",
+				mmc_hostname(card->host));
 
+	}
 	return 0;
 }
 

commit 85e727edb963459d13cdd9ce84c335d251a005a7
Author: Jaehoon Chung <jh80.chung@samsung.com>
Date:   Thu May 31 20:31:47 2012 +0900

    mmc: core: return an error on suspend if mmc_deselect_cards fails
    
    When mmc_host is not spi mode, mmc/sd is doing mmc_deselect_cards().
    mmc_deselect_cards could be returned error.
    If returned error, we can know something wrong when enter suspend.
    
    Signed-off-by: Jaehoon Chung <jh80.chung@samsung.com>
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Acked-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index c272c6868ecf..b2b43f624b9e 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -1075,16 +1075,18 @@ static void mmc_sd_detect(struct mmc_host *host)
  */
 static int mmc_sd_suspend(struct mmc_host *host)
 {
+	int err = 0;
+
 	BUG_ON(!host);
 	BUG_ON(!host->card);
 
 	mmc_claim_host(host);
 	if (!mmc_host_is_spi(host))
-		mmc_deselect_cards(host);
+		err = mmc_deselect_cards(host);
 	host->card->state &= ~MMC_STATE_HIGHSPEED;
 	mmc_release_host(host);
 
-	return 0;
+	return err;
 }
 
 /*

commit e7747475b61fdc2a4a412475a9d64d8c309916e3
Author: Ulf Hansson <ulf.hansson@stericsson.com>
Date:   Thu Mar 1 13:18:05 2012 +0100

    mmc: core: Fixup suspend/resume issues for UHS-I cards
    
    Even if cards supports 1.8V I/O voltage those should anyway be
    initialized at 3.3V I/O according to (e)MMC, SD and SDIO specs.
    Some eMMC and embedded SDIO devices are able to be initialized
    at 1.8V as well, but it is better to be safe.
    
    Do note that initialization in this context means that the card
    has been completely powered off, otherwise the card will remain
    at the last I/O voltage level that were negotitiated.
    
    Due to the above being taken care of the suspend/resume issues
    for UHS-I SD-cards has been fixed.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@stericsson.com>
    Acked-by: Philip Rakity <prakity@marvell.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Tested-by: Subhash Jadavani <subhashj@codeaurora.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 5017f9354ce2..c272c6868ecf 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -911,6 +911,9 @@ static int mmc_sd_init_card(struct mmc_host *host, u32 ocr,
 	BUG_ON(!host);
 	WARN_ON(!host->claimed);
 
+	/* The initialization should be done at 3.3 V I/O voltage. */
+	mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_330, 0);
+
 	err = mmc_sd_get_cid(host, ocr, cid, &rocr);
 	if (err)
 		return err;
@@ -1156,11 +1159,6 @@ int mmc_attach_sd(struct mmc_host *host)
 	BUG_ON(!host);
 	WARN_ON(!host->claimed);
 
-	/* Make sure we are at 3.3V signalling voltage */
-	err = mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_330, false);
-	if (err)
-		return err;
-
 	/* Disable preset value enable if already set since last time */
 	if (host->ops->enable_preset_value) {
 		mmc_host_clk_hold(host);

commit 2c4967f741e87cdd63de7271b97807041dccbf3b
Author: Sujit Reddy Thumma <sthumma@codeaurora.org>
Date:   Sat Feb 4 16:14:50 2012 -0500

    mmc: core: Ensure clocks are always enabled before host interaction
    
    Ensure clocks are always enabled before any interaction with the
    host controller driver. This makes sure that there is no race
    between host execution and the core layer turning off clocks
    in different context with clock gating framework.
    
    Signed-off-by: Sujit Reddy Thumma <sthumma@codeaurora.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Per Forlin <per.forlin@stericsson.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index c63ad03c29c7..5017f9354ce2 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -451,9 +451,11 @@ static int sd_select_driver_type(struct mmc_card *card, u8 *status)
 	 * information and let the hardware specific code
 	 * return what is possible given the options
 	 */
+	mmc_host_clk_hold(card->host);
 	drive_strength = card->host->ops->select_drive_strength(
 		card->sw_caps.uhs_max_dtr,
 		host_drv_type, card_drv_type);
+	mmc_host_clk_release(card->host);
 
 	err = mmc_sd_switch(card, 1, 2, drive_strength, status);
 	if (err)
@@ -660,9 +662,12 @@ static int mmc_sd_init_uhs_card(struct mmc_card *card)
 		goto out;
 
 	/* SPI mode doesn't define CMD19 */
-	if (!mmc_host_is_spi(card->host) && card->host->ops->execute_tuning)
+	if (!mmc_host_is_spi(card->host) && card->host->ops->execute_tuning) {
+		mmc_host_clk_hold(card->host);
 		err = card->host->ops->execute_tuning(card->host,
 						      MMC_SEND_TUNING_BLOCK);
+		mmc_host_clk_release(card->host);
+	}
 
 out:
 	kfree(status);
@@ -850,8 +855,11 @@ int mmc_sd_setup_card(struct mmc_host *host, struct mmc_card *card,
 	if (!reinit) {
 		int ro = -1;
 
-		if (host->ops->get_ro)
+		if (host->ops->get_ro) {
+			mmc_host_clk_hold(card->host);
 			ro = host->ops->get_ro(host);
+			mmc_host_clk_release(card->host);
+		}
 
 		if (ro < 0) {
 			pr_warning("%s: host does not "
@@ -967,8 +975,11 @@ static int mmc_sd_init_card(struct mmc_host *host, u32 ocr,
 		 * Since initialization is now complete, enable preset
 		 * value registers for UHS-I cards.
 		 */
-		if (host->ops->enable_preset_value)
+		if (host->ops->enable_preset_value) {
+			mmc_host_clk_hold(card->host);
 			host->ops->enable_preset_value(host, true);
+			mmc_host_clk_release(card->host);
+		}
 	} else {
 		/*
 		 * Attempt to change to high-speed (if supported)
@@ -1151,8 +1162,11 @@ int mmc_attach_sd(struct mmc_host *host)
 		return err;
 
 	/* Disable preset value enable if already set since last time */
-	if (host->ops->enable_preset_value)
+	if (host->ops->enable_preset_value) {
+		mmc_host_clk_hold(host);
 		host->ops->enable_preset_value(host, false);
+		mmc_host_clk_release(host);
+	}
 
 	err = mmc_send_app_op_cond(host, 0, &ocr);
 	if (err)

commit a4924c71aa43d4f8a3f342b1f71788349472e684
Author: Girish K S <girish.shivananjappa@linaro.org>
Date:   Wed Jan 11 14:04:52 2012 -0500

    mmc: core: HS200 mode support for eMMC 4.5
    
    This patch adds the support of the HS200 bus speed for eMMC 4.5 devices.
    The eMMC 4.5 devices have support for 200MHz bus speed. The function
    prototype of the tuning function is modified to handle the tuning
    command number which is different in sd and mmc case.
    
    Signed-off-by: Girish K S <girish.shivananjappa@linaro.org>
    Signed-off-by: Philip Rakity <prakity@marvell.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 6f27d35081b8..c63ad03c29c7 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -661,7 +661,8 @@ static int mmc_sd_init_uhs_card(struct mmc_card *card)
 
 	/* SPI mode doesn't define CMD19 */
 	if (!mmc_host_is_spi(card->host) && card->host->ops->execute_tuning)
-		err = card->host->ops->execute_tuning(card->host);
+		err = card->host->ops->execute_tuning(card->host,
+						      MMC_SEND_TUNING_BLOCK);
 
 out:
 	kfree(status);

commit d30495048892980e5d453328d1cc9343b3f7e917
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Mon Nov 28 16:22:00 2011 +0200

    mmc: allow upper layers to know immediately if card has been removed
    
    Add a function mmc_detect_card_removed() which upper layers can use to
    determine immediately if a card has been removed. This function should
    be called after an I/O request fails so that all queued I/O requests
    can be errored out immediately instead of waiting for the card device
    to be removed.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Acked-by: Sujit Reddy Thumma <sthumma@codeaurora.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 85b858f6d5d4..6f27d35081b8 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -1018,6 +1018,14 @@ static void mmc_sd_remove(struct mmc_host *host)
 	host->card = NULL;
 }
 
+/*
+ * Card detection - card is alive.
+ */
+static int mmc_sd_alive(struct mmc_host *host)
+{
+	return mmc_send_status(host->card, NULL);
+}
+
 /*
  * Card detection callback from host.
  */
@@ -1033,7 +1041,7 @@ static void mmc_sd_detect(struct mmc_host *host)
 	/*
 	 * Just check if our card has been removed.
 	 */
-	err = mmc_send_status(host->card, NULL);
+	err = _mmc_detect_card_removed(host);
 
 	mmc_release_host(host);
 
@@ -1102,6 +1110,7 @@ static const struct mmc_bus_ops mmc_sd_ops = {
 	.suspend = NULL,
 	.resume = NULL,
 	.power_restore = mmc_sd_power_restore,
+	.alive = mmc_sd_alive,
 };
 
 static const struct mmc_bus_ops mmc_sd_ops_unsafe = {
@@ -1110,6 +1119,7 @@ static const struct mmc_bus_ops mmc_sd_ops_unsafe = {
 	.suspend = mmc_sd_suspend,
 	.resume = mmc_sd_resume,
 	.power_restore = mmc_sd_power_restore,
+	.alive = mmc_sd_alive,
 };
 
 static void mmc_sd_attach_bus_ops(struct mmc_host *host)

commit a303c5319c8e6ab0e744ebca118da8420043b2c3
Author: Philip Rakity <prakity@marvell.com>
Date:   Mon Nov 14 19:14:38 2011 -0800

    mmc: sdio: support SDIO UHS cards
    
    This patch adds support for sdio UHS cards per the version 3.0
    spec.
    
    UHS mode is only enabled for version 3.0 cards when both the
    host and the controller support UHS modes.
    
    1.8v signaling support is removed if both the card and the
    host do not support UHS.  This is done to maintain
    compatibility and some system/card combinations break when
    1.8v signaling is enabled when the host does not support UHS.
    
    Signed-off-by: Philip Rakity <prakity@marvell.com>
    Signed-off-by: Aaron Lu <Aaron.lu@amd.com>
    Reviewed-by: Arindam Nath <arindam.nath@amd.com>
    Tested-by: Bing Zhao <bzhao@marvell.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index f54392c4638a..85b858f6d5d4 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -960,7 +960,7 @@ static int mmc_sd_init_card(struct mmc_host *host, u32 ocr,
 			goto free_card;
 
 		/* Card is an ultra-high-speed card */
-		mmc_sd_card_set_uhs(card);
+		mmc_card_set_uhs(card);
 
 		/*
 		 * Since initialization is now complete, enable preset

commit fffe5d5aa05b4e69f79bc75a51c5ee0fc6203fa5
Author: Qiang Liu <qiang.liu@freescale.com>
Date:   Tue Nov 8 08:43:08 2011 -0500

    mmc: sd: Macro name cleanup for high speed dtr
    
    Add new macros for the high speed 50MHz case, rather than having
    a confusing reuse of the value for UHS SDR50, which is 100MHz.
    
    Reported-by: Aaron Lu <aaron.lu@amd.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index f2a05ea40f2a..f54392c4638a 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -307,8 +307,8 @@ static int mmc_read_switch(struct mmc_card *card)
 		goto out;
 	}
 
-	if (status[13] & UHS_SDR50_BUS_SPEED)
-		card->sw_caps.hs_max_dtr = 50000000;
+	if (status[13] & SD_MODE_HIGH_SPEED)
+		card->sw_caps.hs_max_dtr = HIGH_SPEED_MAX_DTR;
 
 	if (card->scr.sda_spec3) {
 		card->sw_caps.sd3_bus_mode = status[13];

commit 0205a904df57bf2ed79571fe097b99d2940659b1
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri Jul 15 12:01:27 2011 -0400

    mmc: Fix implicit use of stat.h header in associated files
    
    Once the implicit use of module.h is prevented, these files will
    fail to find the stat.h header content.
    
    Fix up the implicit usage expectations in advance of the cleanup.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index a230e7f9d77a..f2a05ea40f2a 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -12,6 +12,7 @@
 
 #include <linux/err.h>
 #include <linux/slab.h>
+#include <linux/stat.h>
 
 #include <linux/mmc/host.h>
 #include <linux/mmc/card.h>

commit f2815f68dabbb373fd1c9f0fd4a609d486697c2b
Author: Subhash Jadavani <subhashj@codeaurora.org>
Date:   Wed Aug 10 11:16:01 2011 +0530

    mmc: sd: Handle SD3.0 cards not supporting UHS-I bus speed mode
    
    Here is Essential conditions to indicate Version 3.00 Card
    (SD_SPEC=2 and SD_SPEC3=1) :
    (1) The card shall support CMD6
    (2) The card shall support CMD8
    (3) The card shall support CMD42
    (4) User area capacity shall be up to 2GB (SDSC) or 32GB (SDHC)
        User area capacity shall be more than or equal to 32GB and
        up to 2TB (SDXC)
    (5) Speed Class shall be supported (SDHC or SDXC)
    
    So even if SD card doesn't support any of the newly defined
    UHS-I bus speed mode, it can advertise itself as SD3.0 cards
    as long as it supports all the essential conditions of
    SD3.0 cards. Given this, these type of cards should atleast
    run in High Speed mode @50MHZ if it supports HS.
    
    But current initialization sequence for SD3.0 cards is
    such that these non-UHS-I SD3.0 cards runs in Default
    Speed mode @25MHz.
    
    This patch makes sure that these non-UHS-I SD3.0 cards run
    in High Speed Mode @50MHz.
    
    Tested this patch with SanDisk Extreme SDHC 8GB Class 10 card.
    
    Reported-by: "Hiremath, Vaibhav" <hvaibhav@ti.com>
    Signed-off-by: Subhash Jadavani <subhashj@codeaurora.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 25b937294130..a230e7f9d77a 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -306,6 +306,9 @@ static int mmc_read_switch(struct mmc_card *card)
 		goto out;
 	}
 
+	if (status[13] & UHS_SDR50_BUS_SPEED)
+		card->sw_caps.hs_max_dtr = 50000000;
+
 	if (card->scr.sda_spec3) {
 		card->sw_caps.sd3_bus_mode = status[13];
 
@@ -348,9 +351,6 @@ static int mmc_read_switch(struct mmc_card *card)
 		}
 
 		card->sw_caps.sd3_curr_limit = status[7];
-	} else {
-		if (status[13] & 0x02)
-			card->sw_caps.hs_max_dtr = 50000000;
 	}
 
 out:

commit a3c76eb9d4a1e68a69dd880cf0bcb8a52418b993
Author: Girish K S <girish.shivananjappa@linaro.org>
Date:   Tue Oct 11 11:44:09 2011 +0530

    mmc: replace printk with appropriate display macro
    
    All the files using printk function for displaying kernel messages
    in the mmc driver have been replaced with corresponding macro.
    
    Signed-off-by: Girish K S <girish.shivananjappa@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 342b18c4afcb..25b937294130 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -163,7 +163,7 @@ static int mmc_decode_csd(struct mmc_card *card)
 		csd->erase_size = 1;
 		break;
 	default:
-		printk(KERN_ERR "%s: unrecognised CSD structure version %d\n",
+		pr_err("%s: unrecognised CSD structure version %d\n",
 			mmc_hostname(card->host), csd_struct);
 		return -EINVAL;
 	}
@@ -187,7 +187,7 @@ static int mmc_decode_scr(struct mmc_card *card)
 
 	scr_struct = UNSTUFF_BITS(resp, 60, 4);
 	if (scr_struct != 0) {
-		printk(KERN_ERR "%s: unrecognised SCR structure version %d\n",
+		pr_err("%s: unrecognised SCR structure version %d\n",
 			mmc_hostname(card->host), scr_struct);
 		return -EINVAL;
 	}
@@ -218,7 +218,7 @@ static int mmc_read_ssr(struct mmc_card *card)
 	u32 *ssr;
 
 	if (!(card->csd.cmdclass & CCC_APP_SPEC)) {
-		printk(KERN_WARNING "%s: card lacks mandatory SD Status "
+		pr_warning("%s: card lacks mandatory SD Status "
 			"function.\n", mmc_hostname(card->host));
 		return 0;
 	}
@@ -229,7 +229,7 @@ static int mmc_read_ssr(struct mmc_card *card)
 
 	err = mmc_app_sd_status(card, ssr);
 	if (err) {
-		printk(KERN_WARNING "%s: problem reading SD Status "
+		pr_warning("%s: problem reading SD Status "
 			"register.\n", mmc_hostname(card->host));
 		err = 0;
 		goto out;
@@ -253,7 +253,7 @@ static int mmc_read_ssr(struct mmc_card *card)
 			card->ssr.erase_offset = eo * 1000;
 		}
 	} else {
-		printk(KERN_WARNING "%s: SD Status: Invalid Allocation Unit "
+		pr_warning("%s: SD Status: Invalid Allocation Unit "
 			"size.\n", mmc_hostname(card->host));
 	}
 out:
@@ -273,7 +273,7 @@ static int mmc_read_switch(struct mmc_card *card)
 		return 0;
 
 	if (!(card->csd.cmdclass & CCC_SWITCH)) {
-		printk(KERN_WARNING "%s: card lacks mandatory switch "
+		pr_warning("%s: card lacks mandatory switch "
 			"function, performance might suffer.\n",
 			mmc_hostname(card->host));
 		return 0;
@@ -283,7 +283,7 @@ static int mmc_read_switch(struct mmc_card *card)
 
 	status = kmalloc(64, GFP_KERNEL);
 	if (!status) {
-		printk(KERN_ERR "%s: could not allocate a buffer for "
+		pr_err("%s: could not allocate a buffer for "
 			"switch capabilities.\n",
 			mmc_hostname(card->host));
 		return -ENOMEM;
@@ -299,7 +299,7 @@ static int mmc_read_switch(struct mmc_card *card)
 		if (err != -EINVAL && err != -ENOSYS && err != -EFAULT)
 			goto out;
 
-		printk(KERN_WARNING "%s: problem reading Bus Speed modes.\n",
+		pr_warning("%s: problem reading Bus Speed modes.\n",
 			mmc_hostname(card->host));
 		err = 0;
 
@@ -319,7 +319,7 @@ static int mmc_read_switch(struct mmc_card *card)
 			if (err != -EINVAL && err != -ENOSYS && err != -EFAULT)
 				goto out;
 
-			printk(KERN_WARNING "%s: problem reading "
+			pr_warning("%s: problem reading "
 				"Driver Strength.\n",
 				mmc_hostname(card->host));
 			err = 0;
@@ -339,7 +339,7 @@ static int mmc_read_switch(struct mmc_card *card)
 			if (err != -EINVAL && err != -ENOSYS && err != -EFAULT)
 				goto out;
 
-			printk(KERN_WARNING "%s: problem reading "
+			pr_warning("%s: problem reading "
 				"Current Limit.\n",
 				mmc_hostname(card->host));
 			err = 0;
@@ -383,7 +383,7 @@ int mmc_sd_switch_hs(struct mmc_card *card)
 
 	status = kmalloc(64, GFP_KERNEL);
 	if (!status) {
-		printk(KERN_ERR "%s: could not allocate a buffer for "
+		pr_err("%s: could not allocate a buffer for "
 			"switch capabilities.\n", mmc_hostname(card->host));
 		return -ENOMEM;
 	}
@@ -393,7 +393,7 @@ int mmc_sd_switch_hs(struct mmc_card *card)
 		goto out;
 
 	if ((status[16] & 0xF) != 1) {
-		printk(KERN_WARNING "%s: Problem switching card "
+		pr_warning("%s: Problem switching card "
 			"into high-speed mode!\n",
 			mmc_hostname(card->host));
 		err = 0;
@@ -459,7 +459,7 @@ static int sd_select_driver_type(struct mmc_card *card, u8 *status)
 		return err;
 
 	if ((status[15] & 0xF) != drive_strength) {
-		printk(KERN_WARNING "%s: Problem setting drive strength!\n",
+		pr_warning("%s: Problem setting drive strength!\n",
 			mmc_hostname(card->host));
 		return 0;
 	}
@@ -538,7 +538,7 @@ static int sd_set_bus_speed_mode(struct mmc_card *card, u8 *status)
 		return err;
 
 	if ((status[16] & 0xF) != card->sd_bus_speed)
-		printk(KERN_WARNING "%s: Problem setting bus speed mode!\n",
+		pr_warning("%s: Problem setting bus speed mode!\n",
 			mmc_hostname(card->host));
 	else {
 		mmc_set_timing(card->host, timing);
@@ -600,7 +600,7 @@ static int sd_set_current_limit(struct mmc_card *card, u8 *status)
 		return err;
 
 	if (((status[15] >> 4) & 0x0F) != current_limit)
-		printk(KERN_WARNING "%s: Problem setting current limit!\n",
+		pr_warning("%s: Problem setting current limit!\n",
 			mmc_hostname(card->host));
 
 	return 0;
@@ -622,7 +622,7 @@ static int mmc_sd_init_uhs_card(struct mmc_card *card)
 
 	status = kmalloc(64, GFP_KERNEL);
 	if (!status) {
-		printk(KERN_ERR "%s: could not allocate a buffer for "
+		pr_err("%s: could not allocate a buffer for "
 			"switch capabilities.\n", mmc_hostname(card->host));
 		return -ENOMEM;
 	}
@@ -852,7 +852,7 @@ int mmc_sd_setup_card(struct mmc_host *host, struct mmc_card *card,
 			ro = host->ops->get_ro(host);
 
 		if (ro < 0) {
-			printk(KERN_WARNING "%s: host does not "
+			pr_warning("%s: host does not "
 				"support reading read-only "
 				"switch. assuming write-enable.\n",
 				mmc_hostname(host));
@@ -1166,7 +1166,7 @@ int mmc_attach_sd(struct mmc_host *host)
 	 * support.
 	 */
 	if (ocr & 0x7F) {
-		printk(KERN_WARNING "%s: card claims to support voltages "
+		pr_warning("%s: card claims to support voltages "
 		       "below the defined range. These will be ignored.\n",
 		       mmc_hostname(host));
 		ocr &= ~0x7F;
@@ -1174,7 +1174,7 @@ int mmc_attach_sd(struct mmc_host *host)
 
 	if ((ocr & MMC_VDD_165_195) &&
 	    !(host->ocr_avail_sd & MMC_VDD_165_195)) {
-		printk(KERN_WARNING "%s: SD card claims to support the "
+		pr_warning("%s: SD card claims to support the "
 		       "incompletely defined 'low voltage range'. This "
 		       "will be ignored.\n", mmc_hostname(host));
 		ocr &= ~MMC_VDD_165_195;
@@ -1213,7 +1213,7 @@ int mmc_attach_sd(struct mmc_host *host)
 err:
 	mmc_detach_bus(host);
 
-	printk(KERN_ERR "%s: error %d whilst initialising SD card\n",
+	pr_err("%s: error %d whilst initialising SD card\n",
 		mmc_hostname(host), err);
 
 	return err;

commit 44669034815a7ad263542ac605c581a10b22d146
Author: Stefan Nilsson XK <stefan.xk.nilsson@stericsson.com>
Date:   Thu Sep 15 17:50:38 2011 +0200

    mmc: core: Set correct bus mode before card init
    
    Earlier all cards where initiated with bus mode set as OPENDRAIN, and then
    later switched to PUSHPULL. According to the MMC/SD/SDIO specifications
    only MMC cards use OPENDRAIN during init. For both SD and SDIO the bus
    mode shall be PUSHPULL before attempting to init the card.
    
    The consequence of having incorrect bus mode can lead to not being able
    to detect the card. Therefore the default behavior have now been changed
    to PUSHPULL in mmc_power_up, and will only be temporarily switched when
    trying to attach or init a MMC card.
    
    Signed-off-by: Stefan Nilsson XK <stefan.xk.nilsson@stericsson.com>
    Signed-off-by: Ulf HANSSON <ulf.hansson@stericsson.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 4c281a4bf058..342b18c4afcb 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -929,8 +929,6 @@ static int mmc_sd_init_card(struct mmc_host *host, u32 ocr,
 		err = mmc_send_relative_addr(host, &card->rca);
 		if (err)
 			return err;
-
-		mmc_set_bus_mode(host, MMC_BUSMODE_PUSHPULL);
 	}
 
 	if (!oldcard) {

commit 7f7e4129c23f0419257184dff6fec89d2d5a8964
Author: Ulf Hansson <ulf.hansson@stericsson.com>
Date:   Wed Sep 21 14:08:13 2011 -0400

    mmc: core: Fix hangs related to insert/remove of cards
    
    During a rescan operation mmc_attach(sd|mmc|sdio) functions are
    called. The error handling in these function can trigger a detach
    of the bus, which also meant a power off. This is not notified by
    the rescan operation which then continues to the next attach function.
    
    If a power off has been done, the framework must never send any
    new commands to the host driver, without first doing a new power up.
    This will most likely trigger any host driver to hang.
    
    Moving power off out of detach and instead handle power off
    separately when it is actually needed, solves the issue.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@stericsson.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Cc: <stable@kernel.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 0370e03e3142..4c281a4bf058 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -1043,6 +1043,7 @@ static void mmc_sd_detect(struct mmc_host *host)
 
 		mmc_claim_host(host);
 		mmc_detach_bus(host);
+		mmc_power_off(host);
 		mmc_release_host(host);
 	}
 }

commit 93c712f99d8e412b2d297edfe9f59b90636897c1
Author: Subhash Jadavani <subhashj@codeaurora.org>
Date:   Tue Aug 9 12:19:31 2011 +0530

    mmc: sd: UHS-I bus speed should be set last in UHS initialization
    
    mmc_sd_init_uhs_card function sets the driver type, current limit
    and bus speed mode on card as well as on host controller side.
    
    Currently bus speed mode is set by sending CMD6 to card and
    immediately setting the timing mode in host controller. But
    then before initiating tuning sequence, it also tries to set
    current limit by sending CMD6 to card which results in data
    timeout errors in controller if bus speed mode is SDR50/SDR104 mode.
    
    So basically bus speed mode should be set only after current limit
    is set in the card and immediately after setting the bus speed mode,
    tuning sequence should be initiated.
    
    Signed-off-by: Subhash Jadavani <subhashj@codeaurora.org>
    Reviewed-by: Arindam Nath <arindam.nath@amd.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 633975ff2bb3..0370e03e3142 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -469,56 +469,75 @@ static int sd_select_driver_type(struct mmc_card *card, u8 *status)
 	return 0;
 }
 
-static int sd_set_bus_speed_mode(struct mmc_card *card, u8 *status)
+static void sd_update_bus_speed_mode(struct mmc_card *card)
 {
-	unsigned int bus_speed = 0, timing = 0;
-	int err;
-
 	/*
 	 * If the host doesn't support any of the UHS-I modes, fallback on
 	 * default speed.
 	 */
 	if (!(card->host->caps & (MMC_CAP_UHS_SDR12 | MMC_CAP_UHS_SDR25 |
-	    MMC_CAP_UHS_SDR50 | MMC_CAP_UHS_SDR104 | MMC_CAP_UHS_DDR50)))
-		return 0;
+	    MMC_CAP_UHS_SDR50 | MMC_CAP_UHS_SDR104 | MMC_CAP_UHS_DDR50))) {
+		card->sd_bus_speed = 0;
+		return;
+	}
 
 	if ((card->host->caps & MMC_CAP_UHS_SDR104) &&
 	    (card->sw_caps.sd3_bus_mode & SD_MODE_UHS_SDR104)) {
-			bus_speed = UHS_SDR104_BUS_SPEED;
-			timing = MMC_TIMING_UHS_SDR104;
-			card->sw_caps.uhs_max_dtr = UHS_SDR104_MAX_DTR;
+			card->sd_bus_speed = UHS_SDR104_BUS_SPEED;
 	} else if ((card->host->caps & MMC_CAP_UHS_DDR50) &&
 		   (card->sw_caps.sd3_bus_mode & SD_MODE_UHS_DDR50)) {
-			bus_speed = UHS_DDR50_BUS_SPEED;
-			timing = MMC_TIMING_UHS_DDR50;
-			card->sw_caps.uhs_max_dtr = UHS_DDR50_MAX_DTR;
+			card->sd_bus_speed = UHS_DDR50_BUS_SPEED;
 	} else if ((card->host->caps & (MMC_CAP_UHS_SDR104 |
 		    MMC_CAP_UHS_SDR50)) && (card->sw_caps.sd3_bus_mode &
 		    SD_MODE_UHS_SDR50)) {
-			bus_speed = UHS_SDR50_BUS_SPEED;
-			timing = MMC_TIMING_UHS_SDR50;
-			card->sw_caps.uhs_max_dtr = UHS_SDR50_MAX_DTR;
+			card->sd_bus_speed = UHS_SDR50_BUS_SPEED;
 	} else if ((card->host->caps & (MMC_CAP_UHS_SDR104 |
 		    MMC_CAP_UHS_SDR50 | MMC_CAP_UHS_SDR25)) &&
 		   (card->sw_caps.sd3_bus_mode & SD_MODE_UHS_SDR25)) {
-			bus_speed = UHS_SDR25_BUS_SPEED;
-			timing = MMC_TIMING_UHS_SDR25;
-			card->sw_caps.uhs_max_dtr = UHS_SDR25_MAX_DTR;
+			card->sd_bus_speed = UHS_SDR25_BUS_SPEED;
 	} else if ((card->host->caps & (MMC_CAP_UHS_SDR104 |
 		    MMC_CAP_UHS_SDR50 | MMC_CAP_UHS_SDR25 |
 		    MMC_CAP_UHS_SDR12)) && (card->sw_caps.sd3_bus_mode &
 		    SD_MODE_UHS_SDR12)) {
-			bus_speed = UHS_SDR12_BUS_SPEED;
-			timing = MMC_TIMING_UHS_SDR12;
-			card->sw_caps.uhs_max_dtr = UHS_SDR12_MAX_DTR;
+			card->sd_bus_speed = UHS_SDR12_BUS_SPEED;
+	}
+}
+
+static int sd_set_bus_speed_mode(struct mmc_card *card, u8 *status)
+{
+	int err;
+	unsigned int timing = 0;
+
+	switch (card->sd_bus_speed) {
+	case UHS_SDR104_BUS_SPEED:
+		timing = MMC_TIMING_UHS_SDR104;
+		card->sw_caps.uhs_max_dtr = UHS_SDR104_MAX_DTR;
+		break;
+	case UHS_DDR50_BUS_SPEED:
+		timing = MMC_TIMING_UHS_DDR50;
+		card->sw_caps.uhs_max_dtr = UHS_DDR50_MAX_DTR;
+		break;
+	case UHS_SDR50_BUS_SPEED:
+		timing = MMC_TIMING_UHS_SDR50;
+		card->sw_caps.uhs_max_dtr = UHS_SDR50_MAX_DTR;
+		break;
+	case UHS_SDR25_BUS_SPEED:
+		timing = MMC_TIMING_UHS_SDR25;
+		card->sw_caps.uhs_max_dtr = UHS_SDR25_MAX_DTR;
+		break;
+	case UHS_SDR12_BUS_SPEED:
+		timing = MMC_TIMING_UHS_SDR12;
+		card->sw_caps.uhs_max_dtr = UHS_SDR12_MAX_DTR;
+		break;
+	default:
+		return 0;
 	}
 
-	card->sd_bus_speed = bus_speed;
-	err = mmc_sd_switch(card, 1, 0, bus_speed, status);
+	err = mmc_sd_switch(card, 1, 0, card->sd_bus_speed, status);
 	if (err)
 		return err;
 
-	if ((status[16] & 0xF) != bus_speed)
+	if ((status[16] & 0xF) != card->sd_bus_speed)
 		printk(KERN_WARNING "%s: Problem setting bus speed mode!\n",
 			mmc_hostname(card->host));
 	else {
@@ -618,18 +637,24 @@ static int mmc_sd_init_uhs_card(struct mmc_card *card)
 		mmc_set_bus_width(card->host, MMC_BUS_WIDTH_4);
 	}
 
+	/*
+	 * Select the bus speed mode depending on host
+	 * and card capability.
+	 */
+	sd_update_bus_speed_mode(card);
+
 	/* Set the driver strength for the card */
 	err = sd_select_driver_type(card, status);
 	if (err)
 		goto out;
 
-	/* Set bus speed mode of the card */
-	err = sd_set_bus_speed_mode(card, status);
+	/* Set current limit for the card */
+	err = sd_set_current_limit(card, status);
 	if (err)
 		goto out;
 
-	/* Set current limit for the card */
-	err = sd_set_current_limit(card, status);
+	/* Set bus speed mode of the card */
+	err = sd_set_bus_speed_mode(card, status);
 	if (err)
 		goto out;
 

commit ca8e99b32e3863c98ac958617cc157a00bf445b8
Author: Philip Rakity <prakity@marvell.com>
Date:   Wed Jul 6 08:51:32 2011 -0700

    mmc: core: Set non-default Drive Strength via platform hook
    
    Non default Drive Strength cannot be set automatically.  It is a function
    of the board design and only if there is a specific platform handler can
    it be set.  The platform handler needs to take into account the board
    design.  Pass to the platform code the necessary information.
    
    For example:  The card and host controller may indicate they support HIGH
    and LOW drive strength.  There is no way to know what should be chosen
    without specific board knowledge.  Setting HIGH may lead to reflections
    and setting LOW may not suffice.  There is no mechanism (like ethernet
    duplex or speed pulses) to determine what should be done automatically.
    
    If no platform handler is defined -- use the default value.
    
    Signed-off-by: Philip Rakity <prakity@marvell.com>
    Reviewed-by: Arindam Nath <arindam.nath@amd.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index ff2774128aa9..633975ff2bb3 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -409,52 +409,62 @@ int mmc_sd_switch_hs(struct mmc_card *card)
 
 static int sd_select_driver_type(struct mmc_card *card, u8 *status)
 {
-	int host_drv_type = 0, card_drv_type = 0;
+	int host_drv_type = SD_DRIVER_TYPE_B;
+	int card_drv_type = SD_DRIVER_TYPE_B;
+	int drive_strength;
 	int err;
 
 	/*
 	 * If the host doesn't support any of the Driver Types A,C or D,
-	 * default Driver Type B is used.
+	 * or there is no board specific handler then default Driver
+	 * Type B is used.
 	 */
 	if (!(card->host->caps & (MMC_CAP_DRIVER_TYPE_A | MMC_CAP_DRIVER_TYPE_C
 	    | MMC_CAP_DRIVER_TYPE_D)))
 		return 0;
 
-	if (card->host->caps & MMC_CAP_DRIVER_TYPE_A) {
-		host_drv_type = MMC_SET_DRIVER_TYPE_A;
-		if (card->sw_caps.sd3_drv_type & SD_DRIVER_TYPE_A)
-			card_drv_type = MMC_SET_DRIVER_TYPE_A;
-		else if (card->sw_caps.sd3_drv_type & SD_DRIVER_TYPE_B)
-			card_drv_type = MMC_SET_DRIVER_TYPE_B;
-		else if (card->sw_caps.sd3_drv_type & SD_DRIVER_TYPE_C)
-			card_drv_type = MMC_SET_DRIVER_TYPE_C;
-	} else if (card->host->caps & MMC_CAP_DRIVER_TYPE_C) {
-		host_drv_type = MMC_SET_DRIVER_TYPE_C;
-		if (card->sw_caps.sd3_drv_type & SD_DRIVER_TYPE_C)
-			card_drv_type = MMC_SET_DRIVER_TYPE_C;
-	} else if (!(card->host->caps & MMC_CAP_DRIVER_TYPE_D)) {
-		/*
-		 * If we are here, that means only the default driver type
-		 * B is supported by the host.
-		 */
-		host_drv_type = MMC_SET_DRIVER_TYPE_B;
-		if (card->sw_caps.sd3_drv_type & SD_DRIVER_TYPE_B)
-			card_drv_type = MMC_SET_DRIVER_TYPE_B;
-		else if (card->sw_caps.sd3_drv_type & SD_DRIVER_TYPE_C)
-			card_drv_type = MMC_SET_DRIVER_TYPE_C;
-	}
+	if (!card->host->ops->select_drive_strength)
+		return 0;
+
+	if (card->host->caps & MMC_CAP_DRIVER_TYPE_A)
+		host_drv_type |= SD_DRIVER_TYPE_A;
+
+	if (card->host->caps & MMC_CAP_DRIVER_TYPE_C)
+		host_drv_type |= SD_DRIVER_TYPE_C;
+
+	if (card->host->caps & MMC_CAP_DRIVER_TYPE_D)
+		host_drv_type |= SD_DRIVER_TYPE_D;
+
+	if (card->sw_caps.sd3_drv_type & SD_DRIVER_TYPE_A)
+		card_drv_type |= SD_DRIVER_TYPE_A;
+
+	if (card->sw_caps.sd3_drv_type & SD_DRIVER_TYPE_C)
+		card_drv_type |= SD_DRIVER_TYPE_C;
+
+	if (card->sw_caps.sd3_drv_type & SD_DRIVER_TYPE_D)
+		card_drv_type |= SD_DRIVER_TYPE_D;
+
+	/*
+	 * The drive strength that the hardware can support
+	 * depends on the board design.  Pass the appropriate
+	 * information and let the hardware specific code
+	 * return what is possible given the options
+	 */
+	drive_strength = card->host->ops->select_drive_strength(
+		card->sw_caps.uhs_max_dtr,
+		host_drv_type, card_drv_type);
 
-	err = mmc_sd_switch(card, 1, 2, card_drv_type, status);
+	err = mmc_sd_switch(card, 1, 2, drive_strength, status);
 	if (err)
 		return err;
 
-	if ((status[15] & 0xF) != card_drv_type) {
-		printk(KERN_WARNING "%s: Problem setting driver strength!\n",
+	if ((status[15] & 0xF) != drive_strength) {
+		printk(KERN_WARNING "%s: Problem setting drive strength!\n",
 			mmc_hostname(card->host));
 		return 0;
 	}
 
-	mmc_set_driver_type(card->host, host_drv_type);
+	mmc_set_driver_type(card->host, drive_strength);
 
 	return 0;
 }

commit f0d89972b01798cf9d245dfa1cacfa0ee78a3593
Author: Andrei Warkentin <andreiw@motorola.com>
Date:   Mon May 23 15:06:38 2011 -0500

    mmc: core: Block CMD23 support for UHS104/SDXC cards.
    
    SD cards operating at UHS104 or better support SET_BLOCK_COUNT.
    
    Signed-off-by: Andrei Warkentin <andreiw@motorola.com>
    Reviewed-by: Arindam Nath <arindam.nath@amd.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 596d0b9d30b8..ff2774128aa9 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -203,6 +203,8 @@ static int mmc_decode_scr(struct mmc_card *card)
 	else
 		card->erased_byte = 0x0;
 
+	if (scr->sda_spec3)
+		scr->cmds = UNSTUFF_BITS(resp, 32, 2);
 	return 0;
 }
 

commit 261bbd463a091b939770255d559bbc89b1bad568
Author: Philip Rakity <prakity@marvell.com>
Date:   Fri May 13 11:17:17 2011 +0530

    mmc: core: eMMC signal voltage does not use CMD11
    
    eMMC chips do not use CMD11 when changing voltage.  Add extra
    argument to call to indicate if CMD11 needs to be sent.
    
    Signed-off-by: Philip Rakity <prakity@marvell.com>
    Reviewed-by: Arindam Nath <arindam.nath@amd.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index b461b290ce25..596d0b9d30b8 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -725,7 +725,7 @@ int mmc_sd_get_cid(struct mmc_host *host, u32 ocr, u32 *cid, u32 *rocr)
 	 */
 	if (!mmc_host_is_spi(host) && rocr &&
 	   ((*rocr & 0x41000000) == 0x41000000)) {
-		err = mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_180);
+		err = mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_180, true);
 		if (err) {
 			ocr &= ~SD_OCR_S18R;
 			goto try_again;
@@ -1098,7 +1098,7 @@ int mmc_attach_sd(struct mmc_host *host)
 	WARN_ON(!host->claimed);
 
 	/* Make sure we are at 3.3V signalling voltage */
-	err = mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_330);
+	err = mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_330, false);
 	if (err)
 		return err;
 

commit 4d55c5a13a189a80d40383f02c8026f9a87d7c87
Author: Arindam Nath <arindam.nath@amd.com>
Date:   Thu May 5 12:19:05 2011 +0530

    mmc: sdhci: enable preset value after uhs initialization
    
    According to the Host Controller spec v3.00, setting Preset Value Enable
    in the Host Control2 register lets SDCLK Frequency Select, Clock Generator
    Select and Driver Strength Select to be set automatically by the Host
    Controller based on the UHS-I mode set. This patch enables this feature.
    Since Preset Value Enable makes sense only for UHS-I cards, we enable this
    feature after successfull UHS-I initialization. We also reset Preset Value
    Enable next time before initialization.
    
    Tested by Zhangfei Gao with a Toshiba uhs card and general hs card,
    on mmp2 in SDMA mode.
    
    Signed-off-by: Arindam Nath <arindam.nath@amd.com>
    Reviewed-by: Philip Rakity <prakity@marvell.com>
    Tested-by: Philip Rakity <prakity@marvell.com>
    Acked-by: Zhangfei Gao <zhangfei.gao@marvell.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index fc65475a26ee..b461b290ce25 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -925,6 +925,13 @@ static int mmc_sd_init_card(struct mmc_host *host, u32 ocr,
 
 		/* Card is an ultra-high-speed card */
 		mmc_sd_card_set_uhs(card);
+
+		/*
+		 * Since initialization is now complete, enable preset
+		 * value registers for UHS-I cards.
+		 */
+		if (host->ops->enable_preset_value)
+			host->ops->enable_preset_value(host, true);
 	} else {
 		/*
 		 * Attempt to change to high-speed (if supported)
@@ -1095,6 +1102,10 @@ int mmc_attach_sd(struct mmc_host *host)
 	if (err)
 		return err;
 
+	/* Disable preset value enable if already set since last time */
+	if (host->ops->enable_preset_value)
+		host->ops->enable_preset_value(host, false);
+
 	err = mmc_send_app_op_cond(host, 0, &ocr);
 	if (err)
 		return err;

commit b513ea250eb7c36a8afb3df938d632ca6b4df7cd
Author: Arindam Nath <arindam.nath@amd.com>
Date:   Thu May 5 12:19:04 2011 +0530

    mmc: sd: add support for tuning during uhs initialization
    
    Host Controller needs tuning during initialization to operate SDR50
    and SDR104 UHS-I cards. Whether SDR50 mode actually needs tuning is
    indicated by bit 45 of the Host Controller Capabilities register.
    A new command CMD19 has been defined in the Physical Layer spec
    v3.01 to request the card to send tuning pattern.
    
    We enable Buffer Read Ready interrupt at the very begining of tuning
    procedure, because that is the only interrupt generated by the Host
    Controller during tuning. We program the block size to 64 in the
    Block Size register. We make sure that DMA Enable and Multi Block
    Select in the Transfer Mode register are set to 0 before actually
    sending CMD19. The tuning block is sent by the card to the Host
    Controller using DAT lines, so we set Data Present Select (bit 5) in
    the Command register. The Host Controller is responsible for doing
    the verfication of tuning block sent by the card at the hardware
    level. After sending CMD19, we wait for Buffer Read Ready interrupt.
    In case we don't receive an interrupt after the specified timeout
    value, we fall back on fixed sampling clock by setting Execute
    Tuning (bit 6) and Sampling Clock Select (bit 7) of Host Control2
    register to 0. Before exiting the tuning procedure, we disable Buffer
    Read Ready interrupt and re-enable other interrupts.
    
    Tested by Zhangfei Gao with a Toshiba uhs card and general hs card,
    on mmp2 in SDMA mode.
    
    Signed-off-by: Arindam Nath <arindam.nath@amd.com>
    Reviewed-by: Philip Rakity <prakity@marvell.com>
    Tested-by: Philip Rakity <prakity@marvell.com>
    Acked-by: Zhangfei Gao <zhangfei.gao@marvell.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 732c3171ceca..fc65475a26ee 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -618,6 +618,12 @@ static int mmc_sd_init_uhs_card(struct mmc_card *card)
 
 	/* Set current limit for the card */
 	err = sd_set_current_limit(card, status);
+	if (err)
+		goto out;
+
+	/* SPI mode doesn't define CMD19 */
+	if (!mmc_host_is_spi(card->host) && card->host->ops->execute_tuning)
+		err = card->host->ops->execute_tuning(card->host);
 
 out:
 	kfree(status);

commit 3a3035114307cd55e024662bb295a87b849f0bd4
Author: Arindam Nath <arindam.nath@amd.com>
Date:   Thu May 5 12:19:03 2011 +0530

    mmc: sd: report correct speed and capacity of uhs cards
    
    Since only UHS-I cards respond with S18A set in response to ACMD41,
    we set the card as ultra-high-speed after successfull initialization.
    We need to decide whether a card is SDXC based on the C_SIZE field
    of CSDv2.0 register. According to Physical Layer spec v3.01, the
    minimum value of C_SIZE for SDXC card is 00FFFFh.
    
    Tested by Zhangfei Gao with a Toshiba uhs card and general hs card,
    on mmp2 in SDMA mode.
    
    Signed-off-by: Arindam Nath <arindam.nath@amd.com>
    Reviewed-by: Philip Rakity <prakity@marvell.com>
    Tested-by: Philip Rakity <prakity@marvell.com>
    Acked-by: Zhangfei Gao <zhangfei.gao@marvell.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 8e2d8012e4cb..732c3171ceca 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -130,7 +130,7 @@ static int mmc_decode_csd(struct mmc_card *card)
 		break;
 	case 1:
 		/*
-		 * This is a block-addressed SDHC card. Most
+		 * This is a block-addressed SDHC or SDXC card. Most
 		 * interesting fields are unused and have fixed
 		 * values. To avoid getting tripped by buggy cards,
 		 * we assume those fixed values ourselves.
@@ -144,6 +144,11 @@ static int mmc_decode_csd(struct mmc_card *card)
 		e = UNSTUFF_BITS(resp, 96, 3);
 		csd->max_dtr	  = tran_exp[e] * tran_mant[m];
 		csd->cmdclass	  = UNSTUFF_BITS(resp, 84, 12);
+		csd->c_size	  = UNSTUFF_BITS(resp, 48, 22);
+
+		/* SDXC cards have a minimum C_SIZE of 0x00FFFF */
+		if (csd->c_size >= 0xFFFF)
+			mmc_card_set_ext_capacity(card);
 
 		m = UNSTUFF_BITS(resp, 48, 22);
 		csd->capacity     = (1 + m) << 10;
@@ -911,6 +916,9 @@ static int mmc_sd_init_card(struct mmc_host *host, u32 ocr,
 		err = mmc_sd_init_uhs_card(card);
 		if (err)
 			goto free_card;
+
+		/* Card is an ultra-high-speed card */
+		mmc_sd_card_set_uhs(card);
 	} else {
 		/*
 		 * Attempt to change to high-speed (if supported)

commit 5371c927bcd06a5c9dd6785bab2d452b87d9abc6
Author: Arindam Nath <arindam.nath@amd.com>
Date:   Thu May 5 12:19:02 2011 +0530

    mmc: sd: set current limit for uhs cards
    
    We decide on the current limit to be set for the card based on the
    Capability of Host Controller to provide current at 1.8V signalling,
    and the maximum current limit of the card as indicated by CMD6
    mode 0. We then set the current limit for the card using CMD6 mode 1.
    As per the Physical Layer Spec v3.01, the current limit switch is
    only applicable for SDR50, SDR104, and DDR50 bus speed modes. For
    other UHS-I modes, we set the default current limit of 200mA.
    
    Tested by Zhangfei Gao with a Toshiba uhs card and general hs card,
    on mmp2 in SDMA mode.
    
    Signed-off-by: Arindam Nath <arindam.nath@amd.com>
    Reviewed-by: Philip Rakity <prakity@marvell.com>
    Tested-by: Philip Rakity <prakity@marvell.com>
    Acked-by: Zhangfei Gao <zhangfei.gao@marvell.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 6970b82171f7..8e2d8012e4cb 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -512,6 +512,64 @@ static int sd_set_bus_speed_mode(struct mmc_card *card, u8 *status)
 	return 0;
 }
 
+static int sd_set_current_limit(struct mmc_card *card, u8 *status)
+{
+	int current_limit = 0;
+	int err;
+
+	/*
+	 * Current limit switch is only defined for SDR50, SDR104, and DDR50
+	 * bus speed modes. For other bus speed modes, we set the default
+	 * current limit of 200mA.
+	 */
+	if ((card->sd_bus_speed == UHS_SDR50_BUS_SPEED) ||
+	    (card->sd_bus_speed == UHS_SDR104_BUS_SPEED) ||
+	    (card->sd_bus_speed == UHS_DDR50_BUS_SPEED)) {
+		if (card->host->caps & MMC_CAP_MAX_CURRENT_800) {
+			if (card->sw_caps.sd3_curr_limit & SD_MAX_CURRENT_800)
+				current_limit = SD_SET_CURRENT_LIMIT_800;
+			else if (card->sw_caps.sd3_curr_limit &
+					SD_MAX_CURRENT_600)
+				current_limit = SD_SET_CURRENT_LIMIT_600;
+			else if (card->sw_caps.sd3_curr_limit &
+					SD_MAX_CURRENT_400)
+				current_limit = SD_SET_CURRENT_LIMIT_400;
+			else if (card->sw_caps.sd3_curr_limit &
+					SD_MAX_CURRENT_200)
+				current_limit = SD_SET_CURRENT_LIMIT_200;
+		} else if (card->host->caps & MMC_CAP_MAX_CURRENT_600) {
+			if (card->sw_caps.sd3_curr_limit & SD_MAX_CURRENT_600)
+				current_limit = SD_SET_CURRENT_LIMIT_600;
+			else if (card->sw_caps.sd3_curr_limit &
+					SD_MAX_CURRENT_400)
+				current_limit = SD_SET_CURRENT_LIMIT_400;
+			else if (card->sw_caps.sd3_curr_limit &
+					SD_MAX_CURRENT_200)
+				current_limit = SD_SET_CURRENT_LIMIT_200;
+		} else if (card->host->caps & MMC_CAP_MAX_CURRENT_400) {
+			if (card->sw_caps.sd3_curr_limit & SD_MAX_CURRENT_400)
+				current_limit = SD_SET_CURRENT_LIMIT_400;
+			else if (card->sw_caps.sd3_curr_limit &
+					SD_MAX_CURRENT_200)
+				current_limit = SD_SET_CURRENT_LIMIT_200;
+		} else if (card->host->caps & MMC_CAP_MAX_CURRENT_200) {
+			if (card->sw_caps.sd3_curr_limit & SD_MAX_CURRENT_200)
+				current_limit = SD_SET_CURRENT_LIMIT_200;
+		}
+	} else
+		current_limit = SD_SET_CURRENT_LIMIT_200;
+
+	err = mmc_sd_switch(card, 1, 3, current_limit, status);
+	if (err)
+		return err;
+
+	if (((status[15] >> 4) & 0x0F) != current_limit)
+		printk(KERN_WARNING "%s: Problem setting current limit!\n",
+			mmc_hostname(card->host));
+
+	return 0;
+}
+
 /*
  * UHS-I specific initialization procedure
  */
@@ -550,6 +608,11 @@ static int mmc_sd_init_uhs_card(struct mmc_card *card)
 
 	/* Set bus speed mode of the card */
 	err = sd_set_bus_speed_mode(card, status);
+	if (err)
+		goto out;
+
+	/* Set current limit for the card */
+	err = sd_set_current_limit(card, status);
 
 out:
 	kfree(status);

commit 49c468fcf878d2c86e31920cf54aa90c88418a66
Author: Arindam Nath <arindam.nath@amd.com>
Date:   Thu May 5 12:19:01 2011 +0530

    mmc: sd: add support for uhs bus speed mode selection
    
    This patch adds support for setting UHS-I bus speed mode during UHS-I
    initialization procedure. Since both the host and card can support
    more than one bus speed, we select the highest speed based on both of
    their capabilities. First we set the bus speed mode for the card using
    CMD6 mode 1, and then we program the host controller to support the
    required speed mode. We also set High Speed Enable in case one of the
    UHS-I modes is selected. We take care to reset SD clock before setting
    UHS mode in the Host Control2 register, and then re-enable it as per
    the Host Controller spec v3.00. We then set the clock frequency for
    the UHS-I mode selected.
    
    Tested by Zhangfei Gao with a Toshiba uhs card and general hs card,
    on mmp2 in SDMA mode.
    
    Signed-off-by: Arindam Nath <arindam.nath@amd.com>
    Reviewed-by: Philip Rakity <prakity@marvell.com>
    Tested-by: Philip Rakity <prakity@marvell.com>
    Acked-by: Zhangfei Gao <zhangfei.gao@marvell.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 5b7c99855635..6970b82171f7 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -452,6 +452,66 @@ static int sd_select_driver_type(struct mmc_card *card, u8 *status)
 	return 0;
 }
 
+static int sd_set_bus_speed_mode(struct mmc_card *card, u8 *status)
+{
+	unsigned int bus_speed = 0, timing = 0;
+	int err;
+
+	/*
+	 * If the host doesn't support any of the UHS-I modes, fallback on
+	 * default speed.
+	 */
+	if (!(card->host->caps & (MMC_CAP_UHS_SDR12 | MMC_CAP_UHS_SDR25 |
+	    MMC_CAP_UHS_SDR50 | MMC_CAP_UHS_SDR104 | MMC_CAP_UHS_DDR50)))
+		return 0;
+
+	if ((card->host->caps & MMC_CAP_UHS_SDR104) &&
+	    (card->sw_caps.sd3_bus_mode & SD_MODE_UHS_SDR104)) {
+			bus_speed = UHS_SDR104_BUS_SPEED;
+			timing = MMC_TIMING_UHS_SDR104;
+			card->sw_caps.uhs_max_dtr = UHS_SDR104_MAX_DTR;
+	} else if ((card->host->caps & MMC_CAP_UHS_DDR50) &&
+		   (card->sw_caps.sd3_bus_mode & SD_MODE_UHS_DDR50)) {
+			bus_speed = UHS_DDR50_BUS_SPEED;
+			timing = MMC_TIMING_UHS_DDR50;
+			card->sw_caps.uhs_max_dtr = UHS_DDR50_MAX_DTR;
+	} else if ((card->host->caps & (MMC_CAP_UHS_SDR104 |
+		    MMC_CAP_UHS_SDR50)) && (card->sw_caps.sd3_bus_mode &
+		    SD_MODE_UHS_SDR50)) {
+			bus_speed = UHS_SDR50_BUS_SPEED;
+			timing = MMC_TIMING_UHS_SDR50;
+			card->sw_caps.uhs_max_dtr = UHS_SDR50_MAX_DTR;
+	} else if ((card->host->caps & (MMC_CAP_UHS_SDR104 |
+		    MMC_CAP_UHS_SDR50 | MMC_CAP_UHS_SDR25)) &&
+		   (card->sw_caps.sd3_bus_mode & SD_MODE_UHS_SDR25)) {
+			bus_speed = UHS_SDR25_BUS_SPEED;
+			timing = MMC_TIMING_UHS_SDR25;
+			card->sw_caps.uhs_max_dtr = UHS_SDR25_MAX_DTR;
+	} else if ((card->host->caps & (MMC_CAP_UHS_SDR104 |
+		    MMC_CAP_UHS_SDR50 | MMC_CAP_UHS_SDR25 |
+		    MMC_CAP_UHS_SDR12)) && (card->sw_caps.sd3_bus_mode &
+		    SD_MODE_UHS_SDR12)) {
+			bus_speed = UHS_SDR12_BUS_SPEED;
+			timing = MMC_TIMING_UHS_SDR12;
+			card->sw_caps.uhs_max_dtr = UHS_SDR12_MAX_DTR;
+	}
+
+	card->sd_bus_speed = bus_speed;
+	err = mmc_sd_switch(card, 1, 0, bus_speed, status);
+	if (err)
+		return err;
+
+	if ((status[16] & 0xF) != bus_speed)
+		printk(KERN_WARNING "%s: Problem setting bus speed mode!\n",
+			mmc_hostname(card->host));
+	else {
+		mmc_set_timing(card->host, timing);
+		mmc_set_clock(card->host, card->sw_caps.uhs_max_dtr);
+	}
+
+	return 0;
+}
+
 /*
  * UHS-I specific initialization procedure
  */
@@ -485,6 +545,11 @@ static int mmc_sd_init_uhs_card(struct mmc_card *card)
 
 	/* Set the driver strength for the card */
 	err = sd_select_driver_type(card, status);
+	if (err)
+		goto out;
+
+	/* Set bus speed mode of the card */
+	err = sd_set_bus_speed_mode(card, status);
 
 out:
 	kfree(status);

commit d6d50a15a2897d4133d536dd4343b5cf21163db3
Author: Arindam Nath <arindam.nath@amd.com>
Date:   Thu May 5 12:18:59 2011 +0530

    mmc: sd: add support for driver type selection
    
    This patch adds support for setting driver strength during UHS-I
    initialization procedure. Since UHS-I cards set S18A (bit 24) in
    response to ACMD41, we use this as a base for UHS-I initialization.
    We modify the parameter list of mmc_sd_get_cid() so that we can
    save the ROCR from ACMD41 to check whether bit 24 is set.
    
    We decide whether the Host Controller supports A, C, or D driver
    type depending on the Capabilities register. Driver type B is
    suported by default. We then set the appropriate driver type for
    the card using CMD6 mode 1. As per Host Controller spec v3.00, we
    set driver type for the host only if Preset Value Enable in the
    Host Control2 register is not set. SDHCI_HOST_CONTROL has been
    renamed to SDHCI_HOST_CONTROL1 to conform to the spec.
    
    Tested by Zhangfei Gao with a Toshiba uhs card and general hs card,
    on mmp2 in SDMA mode.
    
    Signed-off-by: Arindam Nath <arindam.nath@amd.com>
    Reviewed-by: Philip Rakity <prakity@marvell.com>
    Tested-by: Philip Rakity <prakity@marvell.com>
    Acked-by: Zhangfei Gao <zhangfei.gao@marvell.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 8285842f19e9..5b7c99855635 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -400,6 +400,98 @@ int mmc_sd_switch_hs(struct mmc_card *card)
 	return err;
 }
 
+static int sd_select_driver_type(struct mmc_card *card, u8 *status)
+{
+	int host_drv_type = 0, card_drv_type = 0;
+	int err;
+
+	/*
+	 * If the host doesn't support any of the Driver Types A,C or D,
+	 * default Driver Type B is used.
+	 */
+	if (!(card->host->caps & (MMC_CAP_DRIVER_TYPE_A | MMC_CAP_DRIVER_TYPE_C
+	    | MMC_CAP_DRIVER_TYPE_D)))
+		return 0;
+
+	if (card->host->caps & MMC_CAP_DRIVER_TYPE_A) {
+		host_drv_type = MMC_SET_DRIVER_TYPE_A;
+		if (card->sw_caps.sd3_drv_type & SD_DRIVER_TYPE_A)
+			card_drv_type = MMC_SET_DRIVER_TYPE_A;
+		else if (card->sw_caps.sd3_drv_type & SD_DRIVER_TYPE_B)
+			card_drv_type = MMC_SET_DRIVER_TYPE_B;
+		else if (card->sw_caps.sd3_drv_type & SD_DRIVER_TYPE_C)
+			card_drv_type = MMC_SET_DRIVER_TYPE_C;
+	} else if (card->host->caps & MMC_CAP_DRIVER_TYPE_C) {
+		host_drv_type = MMC_SET_DRIVER_TYPE_C;
+		if (card->sw_caps.sd3_drv_type & SD_DRIVER_TYPE_C)
+			card_drv_type = MMC_SET_DRIVER_TYPE_C;
+	} else if (!(card->host->caps & MMC_CAP_DRIVER_TYPE_D)) {
+		/*
+		 * If we are here, that means only the default driver type
+		 * B is supported by the host.
+		 */
+		host_drv_type = MMC_SET_DRIVER_TYPE_B;
+		if (card->sw_caps.sd3_drv_type & SD_DRIVER_TYPE_B)
+			card_drv_type = MMC_SET_DRIVER_TYPE_B;
+		else if (card->sw_caps.sd3_drv_type & SD_DRIVER_TYPE_C)
+			card_drv_type = MMC_SET_DRIVER_TYPE_C;
+	}
+
+	err = mmc_sd_switch(card, 1, 2, card_drv_type, status);
+	if (err)
+		return err;
+
+	if ((status[15] & 0xF) != card_drv_type) {
+		printk(KERN_WARNING "%s: Problem setting driver strength!\n",
+			mmc_hostname(card->host));
+		return 0;
+	}
+
+	mmc_set_driver_type(card->host, host_drv_type);
+
+	return 0;
+}
+
+/*
+ * UHS-I specific initialization procedure
+ */
+static int mmc_sd_init_uhs_card(struct mmc_card *card)
+{
+	int err;
+	u8 *status;
+
+	if (!card->scr.sda_spec3)
+		return 0;
+
+	if (!(card->csd.cmdclass & CCC_SWITCH))
+		return 0;
+
+	status = kmalloc(64, GFP_KERNEL);
+	if (!status) {
+		printk(KERN_ERR "%s: could not allocate a buffer for "
+			"switch capabilities.\n", mmc_hostname(card->host));
+		return -ENOMEM;
+	}
+
+	/* Set 4-bit bus width */
+	if ((card->host->caps & MMC_CAP_4_BIT_DATA) &&
+	    (card->scr.bus_widths & SD_SCR_BUS_WIDTH_4)) {
+		err = mmc_app_set_bus_width(card, MMC_BUS_WIDTH_4);
+		if (err)
+			goto out;
+
+		mmc_set_bus_width(card->host, MMC_BUS_WIDTH_4);
+	}
+
+	/* Set the driver strength for the card */
+	err = sd_select_driver_type(card, status);
+
+out:
+	kfree(status);
+
+	return err;
+}
+
 MMC_DEV_ATTR(cid, "%08x%08x%08x%08x\n", card->raw_cid[0], card->raw_cid[1],
 	card->raw_cid[2], card->raw_cid[3]);
 MMC_DEV_ATTR(csd, "%08x%08x%08x%08x\n", card->raw_csd[0], card->raw_csd[1],
@@ -448,10 +540,9 @@ struct device_type sd_type = {
 /*
  * Fetch CID from card.
  */
-int mmc_sd_get_cid(struct mmc_host *host, u32 ocr, u32 *cid)
+int mmc_sd_get_cid(struct mmc_host *host, u32 ocr, u32 *cid, u32 *rocr)
 {
 	int err;
-	u32 rocr;
 
 	/*
 	 * Since we're changing the OCR value, we seem to
@@ -485,7 +576,7 @@ int mmc_sd_get_cid(struct mmc_host *host, u32 ocr, u32 *cid)
 		ocr |= SD_OCR_XPC;
 
 try_again:
-	err = mmc_send_app_op_cond(host, ocr, &rocr);
+	err = mmc_send_app_op_cond(host, ocr, rocr);
 	if (err)
 		return err;
 
@@ -493,7 +584,8 @@ int mmc_sd_get_cid(struct mmc_host *host, u32 ocr, u32 *cid)
 	 * In case CCS and S18A in the response is set, start Signal Voltage
 	 * Switch procedure. SPI mode doesn't support CMD11.
 	 */
-	if (!mmc_host_is_spi(host) && ((rocr & 0x41000000) == 0x41000000)) {
+	if (!mmc_host_is_spi(host) && rocr &&
+	   ((*rocr & 0x41000000) == 0x41000000)) {
 		err = mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_180);
 		if (err) {
 			ocr &= ~SD_OCR_S18R;
@@ -628,11 +720,12 @@ static int mmc_sd_init_card(struct mmc_host *host, u32 ocr,
 	struct mmc_card *card;
 	int err;
 	u32 cid[4];
+	u32 rocr = 0;
 
 	BUG_ON(!host);
 	WARN_ON(!host->claimed);
 
-	err = mmc_sd_get_cid(host, ocr, cid);
+	err = mmc_sd_get_cid(host, ocr, cid, &rocr);
 	if (err)
 		return err;
 
@@ -685,30 +778,37 @@ static int mmc_sd_init_card(struct mmc_host *host, u32 ocr,
 	if (err)
 		goto free_card;
 
-	/*
-	 * Attempt to change to high-speed (if supported)
-	 */
-	err = mmc_sd_switch_hs(card);
-	if (err > 0)
-		mmc_sd_go_highspeed(card);
-	else if (err)
-		goto free_card;
-
-	/*
-	 * Set bus speed.
-	 */
-	mmc_set_clock(host, mmc_sd_get_max_clock(card));
-
-	/*
-	 * Switch to wider bus (if supported).
-	 */
-	if ((host->caps & MMC_CAP_4_BIT_DATA) &&
-		(card->scr.bus_widths & SD_SCR_BUS_WIDTH_4)) {
-		err = mmc_app_set_bus_width(card, MMC_BUS_WIDTH_4);
+	/* Initialization sequence for UHS-I cards */
+	if (rocr & SD_ROCR_S18A) {
+		err = mmc_sd_init_uhs_card(card);
 		if (err)
 			goto free_card;
+	} else {
+		/*
+		 * Attempt to change to high-speed (if supported)
+		 */
+		err = mmc_sd_switch_hs(card);
+		if (err > 0)
+			mmc_sd_go_highspeed(card);
+		else if (err)
+			goto free_card;
+
+		/*
+		 * Set bus speed.
+		 */
+		mmc_set_clock(host, mmc_sd_get_max_clock(card));
 
-		mmc_set_bus_width(host, MMC_BUS_WIDTH_4);
+		/*
+		 * Switch to wider bus (if supported).
+		 */
+		if ((host->caps & MMC_CAP_4_BIT_DATA) &&
+			(card->scr.bus_widths & SD_SCR_BUS_WIDTH_4)) {
+			err = mmc_app_set_bus_width(card, MMC_BUS_WIDTH_4);
+			if (err)
+				goto free_card;
+
+			mmc_set_bus_width(host, MMC_BUS_WIDTH_4);
+		}
 	}
 
 	host->card = card;

commit 013909c4ffd16ded4895528b856fd8782df04dc6
Author: Arindam Nath <arindam.nath@amd.com>
Date:   Thu May 5 12:18:58 2011 +0530

    mmc: sd: query function modes for uhs cards
    
    SD cards which conform to Physical Layer Spec v3.01 can support
    additional Bus Speed Modes, Driver Strength, and Current Limit
    other than the default values. We use CMD6 mode 0 to read these
    additional card functions. The values read here will be used
    during UHS-I initialization steps.
    
    Tested by Zhangfei Gao with a Toshiba uhs card and general hs card,
    on mmp2 in SDMA mode.
    
    Signed-off-by: Arindam Nath <arindam.nath@amd.com>
    Reviewed-by: Philip Rakity <prakity@marvell.com>
    Tested-by: Philip Rakity <prakity@marvell.com>
    Acked-by: Zhangfei Gao <zhangfei.gao@marvell.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index b0cd285d272a..8285842f19e9 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -189,6 +189,9 @@ static int mmc_decode_scr(struct mmc_card *card)
 
 	scr->sda_vsn = UNSTUFF_BITS(resp, 56, 4);
 	scr->bus_widths = UNSTUFF_BITS(resp, 48, 4);
+	if (scr->sda_vsn == SCR_SPEC_VER_2)
+		/* Check if Physical Layer Spec v3.0 is supported */
+		scr->sda_spec3 = UNSTUFF_BITS(resp, 47, 1);
 
 	if (UNSTUFF_BITS(resp, 55, 1))
 		card->erased_byte = 0xFF;
@@ -274,29 +277,74 @@ static int mmc_read_switch(struct mmc_card *card)
 	status = kmalloc(64, GFP_KERNEL);
 	if (!status) {
 		printk(KERN_ERR "%s: could not allocate a buffer for "
-			"switch capabilities.\n", mmc_hostname(card->host));
+			"switch capabilities.\n",
+			mmc_hostname(card->host));
 		return -ENOMEM;
 	}
 
+	/* Find out the supported Bus Speed Modes. */
 	err = mmc_sd_switch(card, 0, 0, 1, status);
 	if (err) {
-		/* If the host or the card can't do the switch,
-		 * fail more gracefully. */
-		if ((err != -EINVAL)
-		 && (err != -ENOSYS)
-		 && (err != -EFAULT))
+		/*
+		 * If the host or the card can't do the switch,
+		 * fail more gracefully.
+		 */
+		if (err != -EINVAL && err != -ENOSYS && err != -EFAULT)
 			goto out;
 
-		printk(KERN_WARNING "%s: problem reading switch "
-			"capabilities, performance might suffer.\n",
+		printk(KERN_WARNING "%s: problem reading Bus Speed modes.\n",
 			mmc_hostname(card->host));
 		err = 0;
 
 		goto out;
 	}
 
-	if (status[13] & 0x02)
-		card->sw_caps.hs_max_dtr = 50000000;
+	if (card->scr.sda_spec3) {
+		card->sw_caps.sd3_bus_mode = status[13];
+
+		/* Find out Driver Strengths supported by the card */
+		err = mmc_sd_switch(card, 0, 2, 1, status);
+		if (err) {
+			/*
+			 * If the host or the card can't do the switch,
+			 * fail more gracefully.
+			 */
+			if (err != -EINVAL && err != -ENOSYS && err != -EFAULT)
+				goto out;
+
+			printk(KERN_WARNING "%s: problem reading "
+				"Driver Strength.\n",
+				mmc_hostname(card->host));
+			err = 0;
+
+			goto out;
+		}
+
+		card->sw_caps.sd3_drv_type = status[9];
+
+		/* Find out Current Limits supported by the card */
+		err = mmc_sd_switch(card, 0, 3, 1, status);
+		if (err) {
+			/*
+			 * If the host or the card can't do the switch,
+			 * fail more gracefully.
+			 */
+			if (err != -EINVAL && err != -ENOSYS && err != -EFAULT)
+				goto out;
+
+			printk(KERN_WARNING "%s: problem reading "
+				"Current Limit.\n",
+				mmc_hostname(card->host));
+			err = 0;
+
+			goto out;
+		}
+
+		card->sw_caps.sd3_curr_limit = status[7];
+	} else {
+		if (status[13] & 0x02)
+			card->sw_caps.hs_max_dtr = 50000000;
+	}
 
 out:
 	kfree(status);

commit f2119df6b764609af4baceb68caf1e848c1c8aa7
Author: Arindam Nath <arindam.nath@amd.com>
Date:   Thu May 5 12:18:57 2011 +0530

    mmc: sd: add support for signal voltage switch procedure
    
    Host Controller v3.00 adds another Capabilities register. Apart
    from other things, this new register indicates whether the Host
    Controller supports SDR50, SDR104, and DDR50 UHS-I modes. The spec
    doesn't mention about explicit support for SDR12 and SDR25 UHS-I
    modes, so the Host Controller v3.00 should support them by default.
    Also if the controller supports SDR104 mode, it will also support
    SDR50 mode as well. So depending on the host support, we set the
    corresponding MMC_CAP_* flags. One more new register. Host Control2
    is added in v3.00, which is used during Signal Voltage Switch
    procedure described below.
    
    Since as per v3.00 spec, UHS-I supported hosts should set S18R
    to 1, we set S18R (bit 24) of OCR before sending ACMD41. We also
    need to set XPC (bit 28) of OCR in case the host can supply >150mA.
    This support is indicated by the Maximum Current Capabilities
    register of the Host Controller.
    
    If the response of ACMD41 has both CCS and S18A set, we start the
    signal voltage switch procedure, which if successfull, will switch
    the card from 3.3V signalling to 1.8V signalling. Signal voltage
    switch procedure adds support for a new command CMD11 in the
    Physical Layer Spec v3.01. As part of this procedure, we need to
    set 1.8V Signalling Enable (bit 3) of Host Control2 register, which
    if remains set after 5ms, means the switch to 1.8V signalling is
    successfull. Otherwise, we clear bit 24 of OCR and retry the
    initialization sequence. When we remove the card, and insert the
    same or another card, we need to make sure that we start with 3.3V
    signalling voltage. So we call mmc_set_signal_voltage() with
    MMC_SIGNAL_VOLTAGE_330 set so that we are back to 3.3V signalling
    voltage before we actually start initializing the card.
    
    Tested by Zhangfei Gao with a Toshiba uhs card and general hs card,
    on mmp2 in SDMA mode.
    
    Signed-off-by: Arindam Nath <arindam.nath@amd.com>
    Reviewed-by: Philip Rakity <prakity@marvell.com>
    Tested-by: Philip Rakity <prakity@marvell.com>
    Acked-by: Zhangfei Gao <zhangfei.gao@marvell.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 6dac89fe0535..b0cd285d272a 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -403,6 +403,7 @@ struct device_type sd_type = {
 int mmc_sd_get_cid(struct mmc_host *host, u32 ocr, u32 *cid)
 {
 	int err;
+	u32 rocr;
 
 	/*
 	 * Since we're changing the OCR value, we seem to
@@ -420,12 +421,38 @@ int mmc_sd_get_cid(struct mmc_host *host, u32 ocr, u32 *cid)
 	 */
 	err = mmc_send_if_cond(host, ocr);
 	if (!err)
-		ocr |= 1 << 30;
+		ocr |= SD_OCR_CCS;
 
-	err = mmc_send_app_op_cond(host, ocr, NULL);
+	/*
+	 * If the host supports one of UHS-I modes, request the card
+	 * to switch to 1.8V signaling level.
+	 */
+	if (host->caps & (MMC_CAP_UHS_SDR12 | MMC_CAP_UHS_SDR25 |
+	    MMC_CAP_UHS_SDR50 | MMC_CAP_UHS_SDR104 | MMC_CAP_UHS_DDR50))
+		ocr |= SD_OCR_S18R;
+
+	/* If the host can supply more than 150mA, XPC should be set to 1. */
+	if (host->caps & (MMC_CAP_SET_XPC_330 | MMC_CAP_SET_XPC_300 |
+	    MMC_CAP_SET_XPC_180))
+		ocr |= SD_OCR_XPC;
+
+try_again:
+	err = mmc_send_app_op_cond(host, ocr, &rocr);
 	if (err)
 		return err;
 
+	/*
+	 * In case CCS and S18A in the response is set, start Signal Voltage
+	 * Switch procedure. SPI mode doesn't support CMD11.
+	 */
+	if (!mmc_host_is_spi(host) && ((rocr & 0x41000000) == 0x41000000)) {
+		err = mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_180);
+		if (err) {
+			ocr &= ~SD_OCR_S18R;
+			goto try_again;
+		}
+	}
+
 	if (mmc_host_is_spi(host))
 		err = mmc_send_cid(host, cid);
 	else
@@ -773,6 +800,11 @@ int mmc_attach_sd(struct mmc_host *host)
 	BUG_ON(!host);
 	WARN_ON(!host->claimed);
 
+	/* Make sure we are at 3.3V signalling voltage */
+	err = mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_330);
+	if (err)
+		return err;
+
 	err = mmc_send_app_op_cond(host, 0, &ocr);
 	if (err)
 		return err;

commit ce1014965ae2538e7447b19879bd0e8109690b79
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Thu Feb 10 10:58:37 2011 +0000

    mmc: Ensure prototypes for SD API are visible in sd.c
    
    So we know the implementation and prototypes agree with each other.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Reviewed-by: Chris Ball <cjb@laptop.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index d18c32bca99b..6dac89fe0535 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -21,6 +21,7 @@
 #include "core.h"
 #include "bus.h"
 #include "mmc_ops.h"
+#include "sd.h"
 #include "sd_ops.h"
 
 static const unsigned int tran_exp[] = {

commit 807e8e40673d9628fa7dcdd14423424b4ee5f43b
Author: Andy Ross <andy.ross@windriver.com>
Date:   Mon Jan 3 10:36:56 2011 -0800

    mmc: Fix sd/sdio/mmc initialization frequency retries
    
    Rewrite and clean up mmc_rescan() to properly retry frequencies lower
    than 400kHz.  Failures can happen both in sd_send_* calls and
    mmc_attach_*.  Break out "mmc_rescan_try_freq" from the frequency
    selection loop.  Symmetrize claim/release logic in mmc_attach_* API,
    and move the sd_send_* calls there to make mmc_rescan easier to read.
    
    Signed-off-by: Andy Ross <andy.ross@windriver.com>
    Reviewed-and-Tested-by: Hein Tibosch <hein_tibosch@yahoo.es>
    Reviewed-by: Chris Ball <cjb@laptop.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index de062ebd8b26..d18c32bca99b 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -764,13 +764,18 @@ static void mmc_sd_attach_bus_ops(struct mmc_host *host)
 /*
  * Starting point for SD card init.
  */
-int mmc_attach_sd(struct mmc_host *host, u32 ocr)
+int mmc_attach_sd(struct mmc_host *host)
 {
 	int err;
+	u32 ocr;
 
 	BUG_ON(!host);
 	WARN_ON(!host->claimed);
 
+	err = mmc_send_app_op_cond(host, 0, &ocr);
+	if (err)
+		return err;
+
 	mmc_sd_attach_bus_ops(host);
 	if (host->ocr_avail_sd)
 		host->ocr_avail = host->ocr_avail_sd;
@@ -823,20 +828,20 @@ int mmc_attach_sd(struct mmc_host *host, u32 ocr)
 		goto err;
 
 	mmc_release_host(host);
-
 	err = mmc_add_card(host->card);
+	mmc_claim_host(host);
 	if (err)
 		goto remove_card;
 
 	return 0;
 
 remove_card:
+	mmc_release_host(host);
 	mmc_remove_card(host->card);
 	host->card = NULL;
 	mmc_claim_host(host);
 err:
 	mmc_detach_bus(host);
-	mmc_release_host(host);
 
 	printk(KERN_ERR "%s: error %d whilst initialising SD card\n",
 		mmc_hostname(host), err);

commit 8f230f454fe04ba326ffaead3a6b88dcf44eaf4b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Dec 8 10:04:30 2010 +0100

    mmc: Add support for JMicron 388 SD/MMC controller
    
    JMicron 388 SD/MMC combo controller supports the 1.8V low-voltage for
    SD, but MMC doesn't work with the low-voltage, resulting in an error
    at probing.
    
    This patch adds the support for multiple voltage mask per device type,
    so that SD works with 1.8V while MMC forces 3.3V.  Here new ocr_avail_*
    fields for each device are introduced, so that the actual OCR mask is
    switched dynamically.
    
    Also, the restriction of low-voltage in core/sd.c is removed when the
    bit is allowed explicitly via ocr_avail_sd mask.
    
    This patch was rewritten from scratch based on Aries' original code.
    
    Signed-off-by: Aries Lee <arieslee@jmicron.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Reviewed-by: Chris Ball <cjb@laptop.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 49da4dffd28e..de062ebd8b26 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -772,6 +772,8 @@ int mmc_attach_sd(struct mmc_host *host, u32 ocr)
 	WARN_ON(!host->claimed);
 
 	mmc_sd_attach_bus_ops(host);
+	if (host->ocr_avail_sd)
+		host->ocr_avail = host->ocr_avail_sd;
 
 	/*
 	 * We need to get OCR a different way for SPI.
@@ -795,7 +797,8 @@ int mmc_attach_sd(struct mmc_host *host, u32 ocr)
 		ocr &= ~0x7F;
 	}
 
-	if (ocr & MMC_VDD_165_195) {
+	if ((ocr & MMC_VDD_165_195) &&
+	    !(host->ocr_avail_sd & MMC_VDD_165_195)) {
 		printk(KERN_WARNING "%s: SD card claims to support the "
 		       "incompletely defined 'low voltage range'. This "
 		       "will be ignored.\n", mmc_hostname(host));

commit 12ae637f081a7a05144af65802a7b492b9162660
Author: Ohad Ben-Cohen <ohad@wizery.com>
Date:   Sat Oct 2 13:54:06 2010 +0200

    mmc: propagate power save/restore ops return value
    
    Allow power save/restore and their relevant mmc_bus_ops handlers
    exit with a return value.
    
    Signed-off-by: Ohad Ben-Cohen <ohad@wizery.com>
    Tested-by: Luciano Coelho <luciano.coelho@nokia.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index bc745e1237bf..49da4dffd28e 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -722,12 +722,16 @@ static int mmc_sd_resume(struct mmc_host *host)
 	return err;
 }
 
-static void mmc_sd_power_restore(struct mmc_host *host)
+static int mmc_sd_power_restore(struct mmc_host *host)
 {
+	int ret;
+
 	host->card->state &= ~MMC_STATE_HIGHSPEED;
 	mmc_claim_host(host);
-	mmc_sd_init_card(host, host->ocr, host->card);
+	ret = mmc_sd_init_card(host, host->ocr, host->card);
 	mmc_release_host(host);
+
+	return ret;
 }
 
 static const struct mmc_bus_ops mmc_sd_ops = {

commit 71d7d3d190fe77588269a8febf93cd739bd91eb3
Author: Matt Fleming <matt@console-pimps.org>
Date:   Mon Sep 27 09:42:19 2010 +0100

    mmc: Add helper function to check if a card is removable
    
    There are two checks that need to be made when determining whether a
    card is removable. A host controller may set MMC_CAP_NONREMOVABLE if the
    controller does not support removing cards (e.g. eMMC), in which case
    the card is physically non-removable. Also the 'mmc_assume_removable'
    module parameter can be configured at module load time, in which case
    the card may be logically non-removable.
    
    A helper function keeps the logic in one place so that code always
    checks both conditions.
    
    Because this new function is likely to be called from modules we now
    need to export the mmc_assume_removable symbol.
    
    Signed-off-by: Matt Fleming <matt@console-pimps.org>
    Acked-by: Kyungmin Park <kyungmin.park@samsung.com>
    Tested-by: Jaehoon Chung <jh80.chung@samsung.com>
    Acked-by: Wolfram Sang <w.sang@pengutronix.de>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 0f5241085557..bc745e1237bf 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -750,7 +750,7 @@ static void mmc_sd_attach_bus_ops(struct mmc_host *host)
 {
 	const struct mmc_bus_ops *bus_ops;
 
-	if (host->caps & MMC_CAP_NONREMOVABLE || !mmc_assume_removable)
+	if (!mmc_card_is_removable(host))
 		bus_ops = &mmc_sd_ops_unsafe;
 	else
 		bus_ops = &mmc_sd_ops;

commit dfe86cba7676d58db8de7e623f5e72f1b0d3ca35
Author: Adrian Hunter <adrian.hunter@nokia.com>
Date:   Wed Aug 11 14:17:46 2010 -0700

    mmc: add erase, secure erase, trim and secure trim operations
    
    SD/MMC cards tend to support an erase operation.  In addition, eMMC v4.4
    cards can support secure erase, trim and secure trim operations that are
    all variants of the basic erase command.
    
    SD/MMC device attributes "erase_size" and "preferred_erase_size" have been
    added.
    
    "erase_size" is the minimum size, in bytes, of an erase operation.  For
    MMC, "erase_size" is the erase group size reported by the card.  Note that
    "erase_size" does not apply to trim or secure trim operations where the
    minimum size is always one 512 byte sector.  For SD, "erase_size" is 512
    if the card is block-addressed, 0 otherwise.
    
    SD/MMC cards can erase an arbitrarily large area up to and
    including the whole card.  When erasing a large area it may
    be desirable to do it in smaller chunks for three reasons:
    
        1. A single erase command will make all other I/O on the card
           wait.  This is not a problem if the whole card is being erased, but
           erasing one partition will make I/O for another partition on the
           same card wait for the duration of the erase - which could be a
           several minutes.
    
        2. To be able to inform the user of erase progress.
    
        3. The erase timeout becomes too large to be very useful.
           Because the erase timeout contains a margin which is multiplied by
           the size of the erase area, the value can end up being several
           minutes for large areas.
    
    "erase_size" is not the most efficient unit to erase (especially for SD
    where it is just one sector), hence "preferred_erase_size" provides a good
    chunk size for erasing large areas.
    
    For MMC, "preferred_erase_size" is the high-capacity erase size if a card
    specifies one, otherwise it is based on the capacity of the card.
    
    For SD, "preferred_erase_size" is the allocation unit size specified by
    the card.
    
    "preferred_erase_size" is in bytes.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@nokia.com>
    Acked-by: Jens Axboe <axboe@kernel.dk>
    Cc: Kyungmin Park <kmpark@infradead.org>
    Cc: Madhusudhan Chikkature <madhu.cr@ti.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Ben Gardiner <bengardiner@nanometrics.ca>
    Cc: <linux-mmc@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index e6d7d9fab446..0f5241085557 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -119,6 +119,13 @@ static int mmc_decode_csd(struct mmc_card *card)
 		csd->r2w_factor = UNSTUFF_BITS(resp, 26, 3);
 		csd->write_blkbits = UNSTUFF_BITS(resp, 22, 4);
 		csd->write_partial = UNSTUFF_BITS(resp, 21, 1);
+
+		if (UNSTUFF_BITS(resp, 46, 1)) {
+			csd->erase_size = 1;
+		} else if (csd->write_blkbits >= 9) {
+			csd->erase_size = UNSTUFF_BITS(resp, 39, 7) + 1;
+			csd->erase_size <<= csd->write_blkbits - 9;
+		}
 		break;
 	case 1:
 		/*
@@ -147,6 +154,7 @@ static int mmc_decode_csd(struct mmc_card *card)
 		csd->r2w_factor = 4; /* Unused */
 		csd->write_blkbits = 9;
 		csd->write_partial = 0;
+		csd->erase_size = 1;
 		break;
 	default:
 		printk(KERN_ERR "%s: unrecognised CSD structure version %d\n",
@@ -154,6 +162,8 @@ static int mmc_decode_csd(struct mmc_card *card)
 		return -EINVAL;
 	}
 
+	card->erase_size = csd->erase_size;
+
 	return 0;
 }
 
@@ -179,9 +189,67 @@ static int mmc_decode_scr(struct mmc_card *card)
 	scr->sda_vsn = UNSTUFF_BITS(resp, 56, 4);
 	scr->bus_widths = UNSTUFF_BITS(resp, 48, 4);
 
+	if (UNSTUFF_BITS(resp, 55, 1))
+		card->erased_byte = 0xFF;
+	else
+		card->erased_byte = 0x0;
+
 	return 0;
 }
 
+/*
+ * Fetch and process SD Status register.
+ */
+static int mmc_read_ssr(struct mmc_card *card)
+{
+	unsigned int au, es, et, eo;
+	int err, i;
+	u32 *ssr;
+
+	if (!(card->csd.cmdclass & CCC_APP_SPEC)) {
+		printk(KERN_WARNING "%s: card lacks mandatory SD Status "
+			"function.\n", mmc_hostname(card->host));
+		return 0;
+	}
+
+	ssr = kmalloc(64, GFP_KERNEL);
+	if (!ssr)
+		return -ENOMEM;
+
+	err = mmc_app_sd_status(card, ssr);
+	if (err) {
+		printk(KERN_WARNING "%s: problem reading SD Status "
+			"register.\n", mmc_hostname(card->host));
+		err = 0;
+		goto out;
+	}
+
+	for (i = 0; i < 16; i++)
+		ssr[i] = be32_to_cpu(ssr[i]);
+
+	/*
+	 * UNSTUFF_BITS only works with four u32s so we have to offset the
+	 * bitfield positions accordingly.
+	 */
+	au = UNSTUFF_BITS(ssr, 428 - 384, 4);
+	if (au > 0 || au <= 9) {
+		card->ssr.au = 1 << (au + 4);
+		es = UNSTUFF_BITS(ssr, 408 - 384, 16);
+		et = UNSTUFF_BITS(ssr, 402 - 384, 6);
+		eo = UNSTUFF_BITS(ssr, 400 - 384, 2);
+		if (es && et) {
+			card->ssr.erase_timeout = (et * 1000) / es;
+			card->ssr.erase_offset = eo * 1000;
+		}
+	} else {
+		printk(KERN_WARNING "%s: SD Status: Invalid Allocation Unit "
+			"size.\n", mmc_hostname(card->host));
+	}
+out:
+	kfree(ssr);
+	return err;
+}
+
 /*
  * Fetches and decodes switch information
  */
@@ -289,6 +357,8 @@ MMC_DEV_ATTR(csd, "%08x%08x%08x%08x\n", card->raw_csd[0], card->raw_csd[1],
 	card->raw_csd[2], card->raw_csd[3]);
 MMC_DEV_ATTR(scr, "%08x%08x\n", card->raw_scr[0], card->raw_scr[1]);
 MMC_DEV_ATTR(date, "%02d/%04d\n", card->cid.month, card->cid.year);
+MMC_DEV_ATTR(erase_size, "%u\n", card->erase_size << 9);
+MMC_DEV_ATTR(preferred_erase_size, "%u\n", card->pref_erase << 9);
 MMC_DEV_ATTR(fwrev, "0x%x\n", card->cid.fwrev);
 MMC_DEV_ATTR(hwrev, "0x%x\n", card->cid.hwrev);
 MMC_DEV_ATTR(manfid, "0x%06x\n", card->cid.manfid);
@@ -302,6 +372,8 @@ static struct attribute *sd_std_attrs[] = {
 	&dev_attr_csd.attr,
 	&dev_attr_scr.attr,
 	&dev_attr_date.attr,
+	&dev_attr_erase_size.attr,
+	&dev_attr_preferred_erase_size.attr,
 	&dev_attr_fwrev.attr,
 	&dev_attr_hwrev.attr,
 	&dev_attr_manfid.attr,
@@ -396,6 +468,16 @@ int mmc_sd_setup_card(struct mmc_host *host, struct mmc_card *card,
 		if (err)
 			return err;
 
+		/*
+		 * Fetch and process SD Status register.
+		 */
+		err = mmc_read_ssr(card);
+		if (err)
+			return err;
+
+		/* Erase init depends on CSD and SSR */
+		mmc_init_erase(card);
+
 		/*
 		 * Fetch switch information from card.
 		 */

commit 71578a1eaa7b8b9bd3efc9c97d77ef2b63d5dc2b
Author: Michal Miroslaw <mirq-linux@rere.qmqm.pl>
Date:   Tue Aug 10 18:01:40 2010 -0700

    mmc: split mmc_sd_init_card()
    
    This series adds support for SD combo cards to MMC/SD driver stack.
    
    SD combo consists of SD memory and SDIO parts in one package.  Since the
    parts have a separate SD command sets, after initialization, they can be
    treated as independent cards on one bus.
    
    Changes are divided into two patches.  First is just moving initialization
    code around so that SD memory part init can be called from SDIO init.
    Second patch is a proper change enabling SD memory along SDIO.  I tried to
    move as much no-op changes to the first patch so that it's easier to
    follow the required changes to initialization flow for SDIO cards.
    
    This is based on Simplified SDIO spec v.2.00.  The init sequence is
    slightly modified to follow current SD memory init implementation.
    Command sequences, assuming SD memory and SDIO indeed ignore unknown
    commands, are the same as before for both parts.
    
    This patch:
    
    Prepare for SD-combo (IO+mem) support by splitting SD memory
    card init and related functions.
    
    Signed-off-by: Michal Miroslaw <mirq-linux@rere.qmqm.pl>
    Cc: Adrian Hunter <adrian.hunter@nokia.com>
    Cc: Chris Ball <cjb@laptop.org>
    Cc: <linux-mmc@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 5eac21df4809..e6d7d9fab446 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -59,7 +59,7 @@ static const unsigned int tacc_mant[] = {
 /*
  * Given the decoded CSD structure, decode the raw CID to our CID structure.
  */
-static void mmc_decode_cid(struct mmc_card *card)
+void mmc_decode_cid(struct mmc_card *card)
 {
 	u32 *resp = card->raw_cid;
 
@@ -238,7 +238,7 @@ static int mmc_read_switch(struct mmc_card *card)
 /*
  * Test if the card supports high-speed mode and, if so, switch to it.
  */
-static int mmc_switch_hs(struct mmc_card *card)
+int mmc_sd_switch_hs(struct mmc_card *card)
 {
 	int err;
 	u8 *status;
@@ -272,9 +272,9 @@ static int mmc_switch_hs(struct mmc_card *card)
 		printk(KERN_WARNING "%s: Problem switching card "
 			"into high-speed mode!\n",
 			mmc_hostname(card->host));
+		err = 0;
 	} else {
-		mmc_card_set_highspeed(card);
-		mmc_set_timing(card->host, MMC_TIMING_SD_HS);
+		err = 1;
 	}
 
 out:
@@ -320,26 +320,16 @@ static const struct attribute_group *sd_attr_groups[] = {
 	NULL,
 };
 
-static struct device_type sd_type = {
+struct device_type sd_type = {
 	.groups = sd_attr_groups,
 };
 
 /*
- * Handle the detection and initialisation of a card.
- *
- * In the case of a resume, "oldcard" will contain the card
- * we're trying to reinitialise.
+ * Fetch CID from card.
  */
-static int mmc_sd_init_card(struct mmc_host *host, u32 ocr,
-	struct mmc_card *oldcard)
+int mmc_sd_get_cid(struct mmc_host *host, u32 ocr, u32 *cid)
 {
-	struct mmc_card *card;
 	int err;
-	u32 cid[4];
-	unsigned int max_dtr;
-
-	BUG_ON(!host);
-	WARN_ON(!host->claimed);
 
 	/*
 	 * Since we're changing the OCR value, we seem to
@@ -361,23 +351,136 @@ static int mmc_sd_init_card(struct mmc_host *host, u32 ocr,
 
 	err = mmc_send_app_op_cond(host, ocr, NULL);
 	if (err)
-		goto err;
+		return err;
 
-	/*
-	 * Fetch CID from card.
-	 */
 	if (mmc_host_is_spi(host))
 		err = mmc_send_cid(host, cid);
 	else
 		err = mmc_all_send_cid(host, cid);
+
+	return err;
+}
+
+int mmc_sd_get_csd(struct mmc_host *host, struct mmc_card *card)
+{
+	int err;
+
+	/*
+	 * Fetch CSD from card.
+	 */
+	err = mmc_send_csd(card, card->raw_csd);
 	if (err)
-		goto err;
+		return err;
 
-	if (oldcard) {
-		if (memcmp(cid, oldcard->raw_cid, sizeof(cid)) != 0) {
-			err = -ENOENT;
-			goto err;
+	err = mmc_decode_csd(card);
+	if (err)
+		return err;
+
+	return 0;
+}
+
+int mmc_sd_setup_card(struct mmc_host *host, struct mmc_card *card,
+	bool reinit)
+{
+	int err;
+
+	if (!reinit) {
+		/*
+		 * Fetch SCR from card.
+		 */
+		err = mmc_app_send_scr(card, card->raw_scr);
+		if (err)
+			return err;
+
+		err = mmc_decode_scr(card);
+		if (err)
+			return err;
+
+		/*
+		 * Fetch switch information from card.
+		 */
+		err = mmc_read_switch(card);
+		if (err)
+			return err;
+	}
+
+	/*
+	 * For SPI, enable CRC as appropriate.
+	 * This CRC enable is located AFTER the reading of the
+	 * card registers because some SDHC cards are not able
+	 * to provide valid CRCs for non-512-byte blocks.
+	 */
+	if (mmc_host_is_spi(host)) {
+		err = mmc_spi_set_crc(host, use_spi_crc);
+		if (err)
+			return err;
+	}
+
+	/*
+	 * Check if read-only switch is active.
+	 */
+	if (!reinit) {
+		int ro = -1;
+
+		if (host->ops->get_ro)
+			ro = host->ops->get_ro(host);
+
+		if (ro < 0) {
+			printk(KERN_WARNING "%s: host does not "
+				"support reading read-only "
+				"switch. assuming write-enable.\n",
+				mmc_hostname(host));
+		} else if (ro > 0) {
+			mmc_card_set_readonly(card);
 		}
+	}
+
+	return 0;
+}
+
+unsigned mmc_sd_get_max_clock(struct mmc_card *card)
+{
+	unsigned max_dtr = (unsigned int)-1;
+
+	if (mmc_card_highspeed(card)) {
+		if (max_dtr > card->sw_caps.hs_max_dtr)
+			max_dtr = card->sw_caps.hs_max_dtr;
+	} else if (max_dtr > card->csd.max_dtr) {
+		max_dtr = card->csd.max_dtr;
+	}
+
+	return max_dtr;
+}
+
+void mmc_sd_go_highspeed(struct mmc_card *card)
+{
+	mmc_card_set_highspeed(card);
+	mmc_set_timing(card->host, MMC_TIMING_SD_HS);
+}
+
+/*
+ * Handle the detection and initialisation of a card.
+ *
+ * In the case of a resume, "oldcard" will contain the card
+ * we're trying to reinitialise.
+ */
+static int mmc_sd_init_card(struct mmc_host *host, u32 ocr,
+	struct mmc_card *oldcard)
+{
+	struct mmc_card *card;
+	int err;
+	u32 cid[4];
+
+	BUG_ON(!host);
+	WARN_ON(!host->claimed);
+
+	err = mmc_sd_get_cid(host, ocr, cid);
+	if (err)
+		return err;
+
+	if (oldcard) {
+		if (memcmp(cid, oldcard->raw_cid, sizeof(cid)) != 0)
+			return -ENOENT;
 
 		card = oldcard;
 	} else {
@@ -385,10 +488,8 @@ static int mmc_sd_init_card(struct mmc_host *host, u32 ocr,
 		 * Allocate card structure.
 		 */
 		card = mmc_alloc_card(host, &sd_type);
-		if (IS_ERR(card)) {
-			err = PTR_ERR(card);
-			goto err;
-		}
+		if (IS_ERR(card))
+			return PTR_ERR(card);
 
 		card->type = MMC_TYPE_SD;
 		memcpy(card->raw_cid, cid, sizeof(card->raw_cid));
@@ -400,22 +501,15 @@ static int mmc_sd_init_card(struct mmc_host *host, u32 ocr,
 	if (!mmc_host_is_spi(host)) {
 		err = mmc_send_relative_addr(host, &card->rca);
 		if (err)
-			goto free_card;
+			return err;
 
 		mmc_set_bus_mode(host, MMC_BUSMODE_PUSHPULL);
 	}
 
 	if (!oldcard) {
-		/*
-		 * Fetch CSD from card.
-		 */
-		err = mmc_send_csd(card, card->raw_csd);
+		err = mmc_sd_get_csd(host, card);
 		if (err)
-			goto free_card;
-
-		err = mmc_decode_csd(card);
-		if (err)
-			goto free_card;
+			return err;
 
 		mmc_decode_cid(card);
 	}
@@ -426,61 +520,26 @@ static int mmc_sd_init_card(struct mmc_host *host, u32 ocr,
 	if (!mmc_host_is_spi(host)) {
 		err = mmc_select_card(card);
 		if (err)
-			goto free_card;
+			return err;
 	}
 
-	if (!oldcard) {
-		/*
-		 * Fetch SCR from card.
-		 */
-		err = mmc_app_send_scr(card, card->raw_scr);
-		if (err)
-			goto free_card;
-
-		err = mmc_decode_scr(card);
-		if (err < 0)
-			goto free_card;
-
-		/*
-		 * Fetch switch information from card.
-		 */
-		err = mmc_read_switch(card);
-		if (err)
-			goto free_card;
-	}
-
-	/*
-	 * For SPI, enable CRC as appropriate.
-	 * This CRC enable is located AFTER the reading of the
-	 * card registers because some SDHC cards are not able
-	 * to provide valid CRCs for non-512-byte blocks.
-	 */
-	if (mmc_host_is_spi(host)) {
-		err = mmc_spi_set_crc(host, use_spi_crc);
-		if (err)
-			goto free_card;
-	}
+	err = mmc_sd_setup_card(host, card, oldcard != NULL);
+	if (err)
+		goto free_card;
 
 	/*
 	 * Attempt to change to high-speed (if supported)
 	 */
-	err = mmc_switch_hs(card);
-	if (err)
+	err = mmc_sd_switch_hs(card);
+	if (err > 0)
+		mmc_sd_go_highspeed(card);
+	else if (err)
 		goto free_card;
 
 	/*
-	 * Compute bus speed.
+	 * Set bus speed.
 	 */
-	max_dtr = (unsigned int)-1;
-
-	if (mmc_card_highspeed(card)) {
-		if (max_dtr > card->sw_caps.hs_max_dtr)
-			max_dtr = card->sw_caps.hs_max_dtr;
-	} else if (max_dtr > card->csd.max_dtr) {
-		max_dtr = card->csd.max_dtr;
-	}
-
-	mmc_set_clock(host, max_dtr);
+	mmc_set_clock(host, mmc_sd_get_max_clock(card));
 
 	/*
 	 * Switch to wider bus (if supported).
@@ -494,30 +553,12 @@ static int mmc_sd_init_card(struct mmc_host *host, u32 ocr,
 		mmc_set_bus_width(host, MMC_BUS_WIDTH_4);
 	}
 
-	/*
-	 * Check if read-only switch is active.
-	 */
-	if (!oldcard) {
-		if (!host->ops->get_ro || host->ops->get_ro(host) < 0) {
-			printk(KERN_WARNING "%s: host does not "
-				"support reading read-only "
-				"switch. assuming write-enable.\n",
-				mmc_hostname(host));
-		} else {
-			if (host->ops->get_ro(host) > 0)
-				mmc_card_set_readonly(card);
-		}
-	}
-
-	if (!oldcard)
-		host->card = card;
-
+	host->card = card;
 	return 0;
 
 free_card:
 	if (!oldcard)
 		mmc_remove_card(card);
-err:
 
 	return err;
 }

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index fdd414eded09..5eac21df4809 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -11,6 +11,7 @@
  */
 
 #include <linux/err.h>
+#include <linux/slab.h>
 
 #include <linux/mmc/host.h>
 #include <linux/mmc/card.h>

commit bd68e0838fe85794b06892054772fa013a8d1986
Author: Ben Hutchings <ben@decadent.org.uk>
Date:   Mon Dec 14 18:01:29 2009 -0800

    mmc: add module parameter to set whether cards are assumed removable
    
    Some people run general-purpose distribution kernels on netbooks with
    a card that is physically non-removable or logically non-removable
    (e.g. used for /home) and cannot be cleanly unmounted during suspend.
    Add a module parameter to set whether cards are assumed removable or
    non-removable, with the default set by CONFIG_MMC_UNSAFE_RESUME.
    
    In general, it is not possible to tell whether a card present in an MMC
    slot after resume is the same that was there before suspend.  So there are
    two possible behaviours, each of which will cause data loss in some cases:
    
    CONFIG_MMC_UNSAFE_RESUME=n (default): Cards are assumed to be removed
    during suspend.  Any filesystem on them must be unmounted before suspend;
    otherwise, buffered writes will be lost.
    
    CONFIG_MMC_UNSAFE_RESUME=y: Cards are assumed to remain present during
    suspend.  They must not be swapped during suspend; otherwise, buffered
    writes will be flushed to the wrong card.
    
    Currently the choice is made at compile time and this allows that to be
    overridden at module load time.
    
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>
    Cc: Wouter van Heyst <larstiq@larstiq.dyndns.org>
    Cc: <linux-mmc@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 10b2a4d20f5a..fdd414eded09 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -606,23 +606,6 @@ static void mmc_sd_power_restore(struct mmc_host *host)
 	mmc_release_host(host);
 }
 
-#ifdef CONFIG_MMC_UNSAFE_RESUME
-
-static const struct mmc_bus_ops mmc_sd_ops = {
-	.remove = mmc_sd_remove,
-	.detect = mmc_sd_detect,
-	.suspend = mmc_sd_suspend,
-	.resume = mmc_sd_resume,
-	.power_restore = mmc_sd_power_restore,
-};
-
-static void mmc_sd_attach_bus_ops(struct mmc_host *host)
-{
-	mmc_attach_bus(host, &mmc_sd_ops);
-}
-
-#else
-
 static const struct mmc_bus_ops mmc_sd_ops = {
 	.remove = mmc_sd_remove,
 	.detect = mmc_sd_detect,
@@ -643,15 +626,13 @@ static void mmc_sd_attach_bus_ops(struct mmc_host *host)
 {
 	const struct mmc_bus_ops *bus_ops;
 
-	if (host->caps & MMC_CAP_NONREMOVABLE)
+	if (host->caps & MMC_CAP_NONREMOVABLE || !mmc_assume_removable)
 		bus_ops = &mmc_sd_ops_unsafe;
 	else
 		bus_ops = &mmc_sd_ops;
 	mmc_attach_bus(host, bus_ops);
 }
 
-#endif
-
 /*
  * Starting point for SD card init.
  */

commit 95cdfb72b9bc568803f395c266152c71b034b461
Author: Nicolas Pitre <nico@fluxnic.net>
Date:   Tue Sep 22 16:45:29 2009 -0700

    mmc: propagate error codes back from bus drivers' suspend/resume methods
    
    Especially for SDIO drivers which may have special conditions/errors to
    report, it is a good thing to relay the returned error code back to upper
    layers.
    
    This also allows for the rationalization of the resume path where code to
    "remove" a no-longer-existing or replaced card was duplicated into the
    MMC, SD and SDIO bus drivers.
    
    In the SDIO case, if a function suspend method returns an error, then all
    previously suspended functions are resumed and the error returned.  An
    exception is made for -ENOSYS which the core interprets as "we don't
    support suspend so just kick the card out for suspend and return success".
    
    When resuming SDIO cards, the core code only validates the manufacturer
    and product IDs to make sure the same kind of card is still present before
    invoking functions resume methods.  It's the function driver's
    responsibility to perform further tests to confirm that the actual same
    card is present (same MAC address, etc.) and return an error otherwise.
    
    Signed-off-by: Nicolas Pitre <nico@marvell.com>
    Cc: <linux-mmc@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 13b3a6b8f5b5..10b2a4d20f5a 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -564,7 +564,7 @@ static void mmc_sd_detect(struct mmc_host *host)
 /*
  * Suspend callback from host.
  */
-static void mmc_sd_suspend(struct mmc_host *host)
+static int mmc_sd_suspend(struct mmc_host *host)
 {
 	BUG_ON(!host);
 	BUG_ON(!host->card);
@@ -574,6 +574,8 @@ static void mmc_sd_suspend(struct mmc_host *host)
 		mmc_deselect_cards(host);
 	host->card->state &= ~MMC_STATE_HIGHSPEED;
 	mmc_release_host(host);
+
+	return 0;
 }
 
 /*
@@ -582,7 +584,7 @@ static void mmc_sd_suspend(struct mmc_host *host)
  * This function tries to determine if the same card is still present
  * and, if so, restore all state to it.
  */
-static void mmc_sd_resume(struct mmc_host *host)
+static int mmc_sd_resume(struct mmc_host *host)
 {
 	int err;
 
@@ -593,14 +595,7 @@ static void mmc_sd_resume(struct mmc_host *host)
 	err = mmc_sd_init_card(host, host->ocr, host->card);
 	mmc_release_host(host);
 
-	if (err) {
-		mmc_sd_remove(host);
-
-		mmc_claim_host(host);
-		mmc_detach_bus(host);
-		mmc_release_host(host);
-	}
-
+	return err;
 }
 
 static void mmc_sd_power_restore(struct mmc_host *host)

commit d08ebeddfb3293fa4bdfca9c610daf1e8ec8b233
Author: Wolfgang Muees <wolfgang.mues@auerswald.de>
Date:   Tue Sep 22 16:45:26 2009 -0700

    mmc_spi: fail gracefully if host or card do not support the switch command
    
    Some time ago, I have send a patch to the mmc_spi subsystem changing the
    error codes.  This was after a discussion with Pierre about using EINVAL
    only for non-recoverable errors.  This patch was accepted as
    
    http://git.kernel.org/linus/fdd858db7113ca64132de390188d7ca00701013d
    
    Unfortunately, several weeks later, I realized that this patch has opened
    a little can of worms because there are SD cards on the market which
    
    a) claim that they support the switch command
    AND
    b) refuse to execute this command if operating in SPI mode.
    
    So, such a card would get unusuable in an embedded linux system in SPI
    mode, because the init sequence terminates with an error.
    
    This patch adds the missing error codes to the caller of the switch
    command and restores the old behaviour to fail gracefully if these
    commands can not execute.
    
    Signed-off-by: Wolfgang Muees <wolfgang.mues@auerswald.de>
    Cc: <linux-mmc@vger.kernel.org>
    Cc: <stable@kernel.org>         [2.6.31.x]
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 222a60928cdb..13b3a6b8f5b5 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -210,11 +210,11 @@ static int mmc_read_switch(struct mmc_card *card)
 
 	err = mmc_sd_switch(card, 0, 0, 1, status);
 	if (err) {
-		/*
-		 * We all hosts that cannot perform the command
-		 * to fail more gracefully
-		 */
-		if (err != -EINVAL)
+		/* If the host or the card can't do the switch,
+		 * fail more gracefully. */
+		if ((err != -EINVAL)
+		 && (err != -ENOSYS)
+		 && (err != -EFAULT))
 			goto out;
 
 		printk(KERN_WARNING "%s: problem reading switch "

commit eae1aeeed852aae37621b82a9e7f6c05096a18fd
Author: Adrian Hunter <adrian.hunter@nokia.com>
Date:   Tue Sep 22 16:44:33 2009 -0700

    mmc: add ability to save power by powering off cards
    
    Power can be saved by powering off cards that are not in use.  This is
    similar to suspend / resume except it is under the control of the driver,
    and does not require any power management support.  It can only be used
    when the driver can monitor whether the card is removed, otherwise it is
    unsafe.  This is possible because, unlike suspend, the driver still
    receives card detect and / or cover switch interrupts.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@nokia.com>
    Acked-by: Matt Fleming <matt@console-pimps.org>
    Cc: Ian Molton <ian@mnementh.co.uk>
    Cc: "Roberto A. Foglietta" <roberto.foglietta@gmail.com>
    Cc: Jarkko Lavinen <jarkko.lavinen@nokia.com>
    Cc: Denis Karpov <ext-denis.2.karpov@nokia.com>
    Cc: Pierre Ossman <pierre@ossman.eu>
    Cc: Philip Langdale <philipl@overt.org>
    Cc: "Madhusudhan" <madhu.cr@ti.com>
    Cc: <linux-mmc@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 92fa9dceca79..222a60928cdb 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -603,6 +603,14 @@ static void mmc_sd_resume(struct mmc_host *host)
 
 }
 
+static void mmc_sd_power_restore(struct mmc_host *host)
+{
+	host->card->state &= ~MMC_STATE_HIGHSPEED;
+	mmc_claim_host(host);
+	mmc_sd_init_card(host, host->ocr, host->card);
+	mmc_release_host(host);
+}
+
 #ifdef CONFIG_MMC_UNSAFE_RESUME
 
 static const struct mmc_bus_ops mmc_sd_ops = {
@@ -610,6 +618,7 @@ static const struct mmc_bus_ops mmc_sd_ops = {
 	.detect = mmc_sd_detect,
 	.suspend = mmc_sd_suspend,
 	.resume = mmc_sd_resume,
+	.power_restore = mmc_sd_power_restore,
 };
 
 static void mmc_sd_attach_bus_ops(struct mmc_host *host)
@@ -624,6 +633,7 @@ static const struct mmc_bus_ops mmc_sd_ops = {
 	.detect = mmc_sd_detect,
 	.suspend = NULL,
 	.resume = NULL,
+	.power_restore = mmc_sd_power_restore,
 };
 
 static const struct mmc_bus_ops mmc_sd_ops_unsafe = {
@@ -631,6 +641,7 @@ static const struct mmc_bus_ops mmc_sd_ops_unsafe = {
 	.detect = mmc_sd_detect,
 	.suspend = mmc_sd_suspend,
 	.resume = mmc_sd_resume,
+	.power_restore = mmc_sd_power_restore,
 };
 
 static void mmc_sd_attach_bus_ops(struct mmc_host *host)

commit 9feae246963c648b212abad0f0eb8938de5f5fe5
Author: Adrian Hunter <adrian.hunter@nokia.com>
Date:   Tue Sep 22 16:44:32 2009 -0700

    mmc: add MMC_CAP_NONREMOVABLE host capability
    
    eMMC's are not removable, so unsafe resume is OK always.
    
    To permit this a new host capability MMC_CAP_NONREMOVABLE has been added
    and suspend / resume updated accordingly.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@nokia.com>
    Acked-by: Matt Fleming <matt@console-pimps.org>
    Cc: Ian Molton <ian@mnementh.co.uk>
    Cc: "Roberto A. Foglietta" <roberto.foglietta@gmail.com>
    Cc: Jarkko Lavinen <jarkko.lavinen@nokia.com>
    Cc: Denis Karpov <ext-denis.2.karpov@nokia.com>
    Cc: Pierre Ossman <pierre@ossman.eu>
    Cc: Philip Langdale <philipl@overt.org>
    Cc: "Madhusudhan" <madhu.cr@ti.com>
    Cc: <linux-mmc@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 7ad646fe077e..92fa9dceca79 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -561,8 +561,6 @@ static void mmc_sd_detect(struct mmc_host *host)
 	}
 }
 
-#ifdef CONFIG_MMC_UNSAFE_RESUME
-
 /*
  * Suspend callback from host.
  */
@@ -605,20 +603,49 @@ static void mmc_sd_resume(struct mmc_host *host)
 
 }
 
-#else
+#ifdef CONFIG_MMC_UNSAFE_RESUME
 
-#define mmc_sd_suspend NULL
-#define mmc_sd_resume NULL
+static const struct mmc_bus_ops mmc_sd_ops = {
+	.remove = mmc_sd_remove,
+	.detect = mmc_sd_detect,
+	.suspend = mmc_sd_suspend,
+	.resume = mmc_sd_resume,
+};
 
-#endif
+static void mmc_sd_attach_bus_ops(struct mmc_host *host)
+{
+	mmc_attach_bus(host, &mmc_sd_ops);
+}
+
+#else
 
 static const struct mmc_bus_ops mmc_sd_ops = {
+	.remove = mmc_sd_remove,
+	.detect = mmc_sd_detect,
+	.suspend = NULL,
+	.resume = NULL,
+};
+
+static const struct mmc_bus_ops mmc_sd_ops_unsafe = {
 	.remove = mmc_sd_remove,
 	.detect = mmc_sd_detect,
 	.suspend = mmc_sd_suspend,
 	.resume = mmc_sd_resume,
 };
 
+static void mmc_sd_attach_bus_ops(struct mmc_host *host)
+{
+	const struct mmc_bus_ops *bus_ops;
+
+	if (host->caps & MMC_CAP_NONREMOVABLE)
+		bus_ops = &mmc_sd_ops_unsafe;
+	else
+		bus_ops = &mmc_sd_ops;
+	mmc_attach_bus(host, bus_ops);
+}
+
+#endif
+
 /*
  * Starting point for SD card init.
  */
@@ -629,7 +656,7 @@ int mmc_attach_sd(struct mmc_host *host, u32 ocr)
 	BUG_ON(!host);
 	WARN_ON(!host->claimed);
 
-	mmc_attach_bus(host, &mmc_sd_ops);
+	mmc_sd_attach_bus_ops(host);
 
 	/*
 	 * We need to get OCR a different way for SPI.

commit a4dbd6740df0872cdf0a86841f75beec8381964d
Author: David Brownell <dbrownell@users.sourceforge.net>
Date:   Wed Jun 24 10:06:31 2009 -0700

    driver model: constify attribute groups
    
    Let attribute group vectors be declared "const".  We'd
    like to let most attribute metadata live in read-only
    sections... this is a start.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index cd81c395e164..7ad646fe077e 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -314,7 +314,7 @@ static struct attribute_group sd_std_attr_group = {
 	.attrs = sd_std_attrs,
 };
 
-static struct attribute_group *sd_attr_groups[] = {
+static const struct attribute_group *sd_attr_groups[] = {
 	&sd_std_attr_group,
 	NULL,
 };

commit 9d9f25c036dd584db175552a7d162403d3ab54b3
Author: Wolfgang Muees <wolfgang.mues@auerswald.de>
Date:   Tue Apr 7 14:48:16 2009 +0100

    mmc_spi: do not check CID and CSD blocks with CRC16
    
    Some cards are not able to calculate a valid CRC16 value
    for CID and CSD reads (CRC for 512 byte data blocks is OK).
    By moving the CRC enable after the read of CID and CSD, these
    cards can be used. This patch was tested with a faulty 8 GByte
    takeMS Class 6 SDHC card. This patch was suggested by
    Pierre Ossman.
    
    Signed-off-by: Wolfgang Muees <wolfgang.mues@auerswald.de>
    Signed-off-by: Pierre Ossman <pierre@ossman.eu>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 26fc098d77cd..cd81c395e164 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -362,15 +362,6 @@ static int mmc_sd_init_card(struct mmc_host *host, u32 ocr,
 	if (err)
 		goto err;
 
-	/*
-	 * For SPI, enable CRC as appropriate.
-	 */
-	if (mmc_host_is_spi(host)) {
-		err = mmc_spi_set_crc(host, use_spi_crc);
-		if (err)
-			goto err;
-	}
-
 	/*
 	 * Fetch CID from card.
 	 */
@@ -457,6 +448,18 @@ static int mmc_sd_init_card(struct mmc_host *host, u32 ocr,
 			goto free_card;
 	}
 
+	/*
+	 * For SPI, enable CRC as appropriate.
+	 * This CRC enable is located AFTER the reading of the
+	 * card registers because some SDHC cards are not able
+	 * to provide valid CRCs for non-512-byte blocks.
+	 */
+	if (mmc_host_is_spi(host)) {
+		err = mmc_spi_set_crc(host, use_spi_crc);
+		if (err)
+			goto free_card;
+	}
+
 	/*
 	 * Attempt to change to high-speed (if supported)
 	 */

commit 8769392b1918ec70ab62eebc82e06c47c12f8304
Author: Deepak Saxena <dsaxena@plexity.net>
Date:   Mon Jun 16 19:20:57 2008 -0700

    MMC: Trivial comment cleanup
    
    Make the variable name in the comments match the actual name
    of the variable.
    
    Signed-off-by: Deepak Saxena <dsaxena@laptop.org>
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index b122eb9ea453..26fc098d77cd 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -326,7 +326,7 @@ static struct device_type sd_type = {
 /*
  * Handle the detection and initialisation of a card.
  *
- * In the case of a resume, "curcard" will contain the card
+ * In the case of a resume, "oldcard" will contain the card
  * we're trying to reinitialise.
  */
 static int mmc_sd_init_card(struct mmc_host *host, u32 ocr,

commit 08f80bb5196517a0dfe50dc7c10f234c0ff2f0e8
Author: Anton Vorontsov <avorontsov@ru.mvista.com>
Date:   Tue Jun 17 18:17:39 2008 +0400

    mmc: change .get_ro() callback semantics
    
    Now get_ro() callback must return 0/1 values for its logical states, and
    negative errno values in case of error. If particular host instance doesn't
    support RO/WP switch, it should return -ENOSYS.
    
    This patch changes some hosts in two ways:
    
    1. Now functions should be smart to not return negative values in
       "RO asserted" case (particularly gpio_ calls could return negative
       values for the outermost GPIOs).
    
       Also, board code usually passes get_ro() callbacks that directly return
       gpioreg & bit result, so at91_mci, imxmmc, pxamci and mmc_spi's get_ro()
       handlers need take special care when returning platform's values to the
       mmc core.
    
    2. In case of host instance didn't implement get_ro() callback, it should
       really return -ENOSYS and let the mmc core decide what to do about it
       (mmc core thinks the same way as the hosts, so it isn't functional
       change).
    
    Signed-off-by: Anton Vorontsov <avorontsov@ru.mvista.com>
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 7ef3b15c5e3d..b122eb9ea453 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -494,13 +494,13 @@ static int mmc_sd_init_card(struct mmc_host *host, u32 ocr,
 	 * Check if read-only switch is active.
 	 */
 	if (!oldcard) {
-		if (!host->ops->get_ro) {
+		if (!host->ops->get_ro || host->ops->get_ro(host) < 0) {
 			printk(KERN_WARNING "%s: host does not "
 				"support reading read-only "
 				"switch. assuming write-enable.\n",
 				mmc_hostname(host));
 		} else {
-			if (host->ops->get_ro(host))
+			if (host->ops->get_ro(host) > 0)
 				mmc_card_set_readonly(card);
 		}
 	}

commit 51ec92e295d563dd5712d198a7e46c2ae5ccccb2
Author: Pierre Ossman <drzeus-list@drzeus.cx>
Date:   Fri Mar 21 23:54:50 2008 +0100

    mmc: use sysfs groups to handle conditional attributes
    
    Suppressing uevents turned out to be a bad idea as it screws up the
    order of events, making user space very confused. Change the system to
    use sysfs groups instead.
    
    This is a regression that, for some odd reason, has gone unnoticed for
    some time. It confuses hal so that the block devices (which have the
    mmc device as a parent) are not registered. End result being that
    desktop magic when cards are inserted won't work.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index d1c1e0f592f1..7ef3b15c5e3d 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -18,7 +18,6 @@
 #include <linux/mmc/sd.h>
 
 #include "core.h"
-#include "sysfs.h"
 #include "bus.h"
 #include "mmc_ops.h"
 #include "sd_ops.h"
@@ -283,6 +282,47 @@ static int mmc_switch_hs(struct mmc_card *card)
 	return err;
 }
 
+MMC_DEV_ATTR(cid, "%08x%08x%08x%08x\n", card->raw_cid[0], card->raw_cid[1],
+	card->raw_cid[2], card->raw_cid[3]);
+MMC_DEV_ATTR(csd, "%08x%08x%08x%08x\n", card->raw_csd[0], card->raw_csd[1],
+	card->raw_csd[2], card->raw_csd[3]);
+MMC_DEV_ATTR(scr, "%08x%08x\n", card->raw_scr[0], card->raw_scr[1]);
+MMC_DEV_ATTR(date, "%02d/%04d\n", card->cid.month, card->cid.year);
+MMC_DEV_ATTR(fwrev, "0x%x\n", card->cid.fwrev);
+MMC_DEV_ATTR(hwrev, "0x%x\n", card->cid.hwrev);
+MMC_DEV_ATTR(manfid, "0x%06x\n", card->cid.manfid);
+MMC_DEV_ATTR(name, "%s\n", card->cid.prod_name);
+MMC_DEV_ATTR(oemid, "0x%04x\n", card->cid.oemid);
+MMC_DEV_ATTR(serial, "0x%08x\n", card->cid.serial);
+
+
+static struct attribute *sd_std_attrs[] = {
+	&dev_attr_cid.attr,
+	&dev_attr_csd.attr,
+	&dev_attr_scr.attr,
+	&dev_attr_date.attr,
+	&dev_attr_fwrev.attr,
+	&dev_attr_hwrev.attr,
+	&dev_attr_manfid.attr,
+	&dev_attr_name.attr,
+	&dev_attr_oemid.attr,
+	&dev_attr_serial.attr,
+	NULL,
+};
+
+static struct attribute_group sd_std_attr_group = {
+	.attrs = sd_std_attrs,
+};
+
+static struct attribute_group *sd_attr_groups[] = {
+	&sd_std_attr_group,
+	NULL,
+};
+
+static struct device_type sd_type = {
+	.groups = sd_attr_groups,
+};
+
 /*
  * Handle the detection and initialisation of a card.
  *
@@ -352,7 +392,7 @@ static int mmc_sd_init_card(struct mmc_host *host, u32 ocr,
 		/*
 		 * Allocate card structure.
 		 */
-		card = mmc_alloc_card(host);
+		card = mmc_alloc_card(host, &sd_type);
 		if (IS_ERR(card)) {
 			err = PTR_ERR(card);
 			goto err;
@@ -518,55 +558,6 @@ static void mmc_sd_detect(struct mmc_host *host)
 	}
 }
 
-MMC_ATTR_FN(cid, "%08x%08x%08x%08x\n", card->raw_cid[0], card->raw_cid[1],
-	card->raw_cid[2], card->raw_cid[3]);
-MMC_ATTR_FN(csd, "%08x%08x%08x%08x\n", card->raw_csd[0], card->raw_csd[1],
-	card->raw_csd[2], card->raw_csd[3]);
-MMC_ATTR_FN(scr, "%08x%08x\n", card->raw_scr[0], card->raw_scr[1]);
-MMC_ATTR_FN(date, "%02d/%04d\n", card->cid.month, card->cid.year);
-MMC_ATTR_FN(fwrev, "0x%x\n", card->cid.fwrev);
-MMC_ATTR_FN(hwrev, "0x%x\n", card->cid.hwrev);
-MMC_ATTR_FN(manfid, "0x%06x\n", card->cid.manfid);
-MMC_ATTR_FN(name, "%s\n", card->cid.prod_name);
-MMC_ATTR_FN(oemid, "0x%04x\n", card->cid.oemid);
-MMC_ATTR_FN(serial, "0x%08x\n", card->cid.serial);
-
-static struct device_attribute mmc_sd_dev_attrs[] = {
-	MMC_ATTR_RO(cid),
-	MMC_ATTR_RO(csd),
-	MMC_ATTR_RO(scr),
-	MMC_ATTR_RO(date),
-	MMC_ATTR_RO(fwrev),
-	MMC_ATTR_RO(hwrev),
-	MMC_ATTR_RO(manfid),
-	MMC_ATTR_RO(name),
-	MMC_ATTR_RO(oemid),
-	MMC_ATTR_RO(serial),
-	__ATTR_NULL,
-};
-
-/*
- * Adds sysfs entries as relevant.
- */
-static int mmc_sd_sysfs_add(struct mmc_host *host, struct mmc_card *card)
-{
-	int ret;
-
-	ret = mmc_add_attrs(card, mmc_sd_dev_attrs);
-	if (ret < 0)
-		return ret;
-
-	return 0;
-}
-
-/*
- * Removes the sysfs entries added by mmc_sysfs_add().
- */
-static void mmc_sd_sysfs_remove(struct mmc_host *host, struct mmc_card *card)
-{
-	mmc_remove_attrs(card, mmc_sd_dev_attrs);
-}
-
 #ifdef CONFIG_MMC_UNSAFE_RESUME
 
 /*
@@ -621,8 +612,6 @@ static void mmc_sd_resume(struct mmc_host *host)
 static const struct mmc_bus_ops mmc_sd_ops = {
 	.remove = mmc_sd_remove,
 	.detect = mmc_sd_detect,
-	.sysfs_add = mmc_sd_sysfs_add,
-	.sysfs_remove = mmc_sd_sysfs_remove,
 	.suspend = mmc_sd_suspend,
 	.resume = mmc_sd_resume,
 };

commit af51715079e7fb6b290e1881d63d815dc4de5011
Author: David Brownell <david-b@pacbell.net>
Date:   Wed Aug 8 09:11:32 2007 -0700

    MMC core learns about SPI
    
    Teach the MMC/SD/SDIO core about using SPI mode.
    
     - Use mmc_host_is_spi() so enumeration works through SPI signaling
       and protocols, not just the native versions.
    
     - Provide the SPI response type flags with each request issued,
       including requests from the new lock/unlock code.
    
     - Understand that cmd->resp[0] and mmc_get_status() results for SPI
       return different values than for "native" MMC/SD protocol; this
       affects resetting, checking card lock status, and some others.
    
     - Understand that some commands act a bit differently ... notably:
         * OP_COND command doesn't return the OCR
         * APP_CMD status doesn't have an R1_APP_CMD analogue
    
    Those changes required some new and updated primitives:
    
     - Provide utilities to access two SPI-only requests, and one
       request that wasn't previously needed:
         * mmc_spi_read_ocr() ... SPI only
         * mmc_spi_set_crc() ... SPI only (override by module parm)
         * mmc_send_cid() ... for use without broadcast mode
    
     - Updated internal routines:
         * Previous mmc_send_csd() modified into mmc_send_cxd_native();
           it uses native "R2" responses, which include 16 bytes of data.
         * Previous mmc_send_ext_csd() becomes new mmc_send_cxd_data()
           helper for command-and-data access
         * Bugfix to that mmc_send_cxd_data() code:  dma-to-stack is
           unsafe/nonportable, so kmalloc a bounce buffer instead.
    
     - Modified mmc_send_ext_csd() now uses mmc_send_cxd_data() helper
    
     - Modified mmc_send_csd(), and new mmc_spi_send_cid(), routines use
       those helper routines based on whether they're native or SPI
    
    The newest categories of cards supported by the MMC stack aren't expected
    to work yet with SPI:  MMC or SD cards with over 4GB data, and SDIO.
    All those cards support SPI mode, so eventually they should work too.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index c86588fdaae5..d1c1e0f592f1 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -322,10 +322,22 @@ static int mmc_sd_init_card(struct mmc_host *host, u32 ocr,
 	if (err)
 		goto err;
 
+	/*
+	 * For SPI, enable CRC as appropriate.
+	 */
+	if (mmc_host_is_spi(host)) {
+		err = mmc_spi_set_crc(host, use_spi_crc);
+		if (err)
+			goto err;
+	}
+
 	/*
 	 * Fetch CID from card.
 	 */
-	err = mmc_all_send_cid(host, cid);
+	if (mmc_host_is_spi(host))
+		err = mmc_send_cid(host, cid);
+	else
+		err = mmc_all_send_cid(host, cid);
 	if (err)
 		goto err;
 
@@ -351,13 +363,15 @@ static int mmc_sd_init_card(struct mmc_host *host, u32 ocr,
 	}
 
 	/*
-	 * Set card RCA.
+	 * For native busses:  get card RCA and quit open drain mode.
 	 */
-	err = mmc_send_relative_addr(host, &card->rca);
-	if (err)
-		goto free_card;
+	if (!mmc_host_is_spi(host)) {
+		err = mmc_send_relative_addr(host, &card->rca);
+		if (err)
+			goto free_card;
 
-	mmc_set_bus_mode(host, MMC_BUSMODE_PUSHPULL);
+		mmc_set_bus_mode(host, MMC_BUSMODE_PUSHPULL);
+	}
 
 	if (!oldcard) {
 		/*
@@ -377,9 +391,11 @@ static int mmc_sd_init_card(struct mmc_host *host, u32 ocr,
 	/*
 	 * Select card, as all following commands rely on that.
 	 */
-	err = mmc_select_card(card);
-	if (err)
-		goto free_card;
+	if (!mmc_host_is_spi(host)) {
+		err = mmc_select_card(card);
+		if (err)
+			goto free_card;
+	}
 
 	if (!oldcard) {
 		/*
@@ -562,7 +578,8 @@ static void mmc_sd_suspend(struct mmc_host *host)
 	BUG_ON(!host->card);
 
 	mmc_claim_host(host);
-	mmc_deselect_cards(host);
+	if (!mmc_host_is_spi(host))
+		mmc_deselect_cards(host);
 	host->card->state &= ~MMC_STATE_HIGHSPEED;
 	mmc_release_host(host);
 }
@@ -622,6 +639,17 @@ int mmc_attach_sd(struct mmc_host *host, u32 ocr)
 
 	mmc_attach_bus(host, &mmc_sd_ops);
 
+	/*
+	 * We need to get OCR a different way for SPI.
+	 */
+	if (mmc_host_is_spi(host)) {
+		mmc_go_idle(host);
+
+		err = mmc_spi_read_ocr(host, 0, &ocr);
+		if (err)
+			goto err;
+	}
+
 	/*
 	 * Sanity check the voltages that the card claims to
 	 * support.

commit d84075c8aed771d47d7ac6e96b098559da361c25
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Thu Aug 9 13:23:56 2007 +0200

    mmc: replace BUG_ON with WARN_ON
    
    Replace all cases of BUG_ON with WARN_ON where there is a chance
    (with varying degrees of slim) that the kernel can continue without
    incidence.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 0a04a6e86ca1..c86588fdaae5 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -166,8 +166,6 @@ static int mmc_decode_scr(struct mmc_card *card)
 	unsigned int scr_struct;
 	u32 resp[4];
 
-	BUG_ON(!mmc_card_sd(card));
-
 	resp[3] = card->raw_scr[1];
 	resp[2] = card->raw_scr[0];
 
@@ -300,7 +298,7 @@ static int mmc_sd_init_card(struct mmc_host *host, u32 ocr,
 	unsigned int max_dtr;
 
 	BUG_ON(!host);
-	BUG_ON(!host->claimed);
+	WARN_ON(!host->claimed);
 
 	/*
 	 * Since we're changing the OCR value, we seem to
@@ -620,7 +618,7 @@ int mmc_attach_sd(struct mmc_host *host, u32 ocr)
 	int err;
 
 	BUG_ON(!host);
-	BUG_ON(!host->claimed);
+	WARN_ON(!host->claimed);
 
 	mmc_attach_bus(host, &mmc_sd_ops);
 

commit adf66a0dc5e8be8d4e64f3c2114f9b175558235b
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Sun Jul 22 23:08:30 2007 +0200

    mmc: improve error code feedback
    
    Now that we use "normal" error codes, improve the reporting and response
    to error codes in the core.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 00895c99d9bb..0a04a6e86ca1 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -213,10 +213,18 @@ static int mmc_read_switch(struct mmc_card *card)
 
 	err = mmc_sd_switch(card, 0, 0, 1, status);
 	if (err) {
+		/*
+		 * We all hosts that cannot perform the command
+		 * to fail more gracefully
+		 */
+		if (err != -EINVAL)
+			goto out;
+
 		printk(KERN_WARNING "%s: problem reading switch "
 			"capabilities, performance might suffer.\n",
 			mmc_hostname(card->host));
 		err = 0;
+
 		goto out;
 	}
 
@@ -324,8 +332,10 @@ static int mmc_sd_init_card(struct mmc_host *host, u32 ocr,
 		goto err;
 
 	if (oldcard) {
-		if (memcmp(cid, oldcard->raw_cid, sizeof(cid)) != 0)
+		if (memcmp(cid, oldcard->raw_cid, sizeof(cid)) != 0) {
+			err = -ENOENT;
 			goto err;
+		}
 
 		card = oldcard;
 	} else {
@@ -333,8 +343,10 @@ static int mmc_sd_init_card(struct mmc_host *host, u32 ocr,
 		 * Allocate card structure.
 		 */
 		card = mmc_alloc_card(host);
-		if (IS_ERR(card))
+		if (IS_ERR(card)) {
+			err = PTR_ERR(card);
 			goto err;
+		}
 
 		card->type = MMC_TYPE_SD;
 		memcpy(card->raw_cid, cid, sizeof(card->raw_cid));
@@ -358,7 +370,7 @@ static int mmc_sd_init_card(struct mmc_host *host, u32 ocr,
 			goto free_card;
 
 		err = mmc_decode_csd(card);
-		if (err < 0)
+		if (err)
 			goto free_card;
 
 		mmc_decode_cid(card);
@@ -449,7 +461,7 @@ static int mmc_sd_init_card(struct mmc_host *host, u32 ocr,
 		mmc_remove_card(card);
 err:
 
-	return -EIO;
+	return err;
 }
 
 /*
@@ -666,6 +678,6 @@ int mmc_attach_sd(struct mmc_host *host, u32 ocr)
 	printk(KERN_ERR "%s: error %d whilst initialising SD card\n",
 		mmc_hostname(host), err);
 
-	return 0;
+	return err;
 }
 

commit 17b0429dde9ab60f9cee8e07ab28c7dc6cfe6efd
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Sun Jul 22 22:18:46 2007 +0200

    mmc: remove custom error codes
    
    Convert the MMC layer to use standard error codes and not its own,
    incompatible values.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 1edc62b1e5c6..00895c99d9bb 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -193,30 +193,30 @@ static int mmc_read_switch(struct mmc_card *card)
 	u8 *status;
 
 	if (card->scr.sda_vsn < SCR_SPEC_VER_1)
-		return MMC_ERR_NONE;
+		return 0;
 
 	if (!(card->csd.cmdclass & CCC_SWITCH)) {
 		printk(KERN_WARNING "%s: card lacks mandatory switch "
 			"function, performance might suffer.\n",
 			mmc_hostname(card->host));
-		return MMC_ERR_NONE;
+		return 0;
 	}
 
-	err = MMC_ERR_FAILED;
+	err = -EIO;
 
 	status = kmalloc(64, GFP_KERNEL);
 	if (!status) {
 		printk(KERN_ERR "%s: could not allocate a buffer for "
 			"switch capabilities.\n", mmc_hostname(card->host));
-		return err;
+		return -ENOMEM;
 	}
 
 	err = mmc_sd_switch(card, 0, 0, 1, status);
-	if (err != MMC_ERR_NONE) {
+	if (err) {
 		printk(KERN_WARNING "%s: problem reading switch "
 			"capabilities, performance might suffer.\n",
 			mmc_hostname(card->host));
-		err = MMC_ERR_NONE;
+		err = 0;
 		goto out;
 	}
 
@@ -238,28 +238,28 @@ static int mmc_switch_hs(struct mmc_card *card)
 	u8 *status;
 
 	if (card->scr.sda_vsn < SCR_SPEC_VER_1)
-		return MMC_ERR_NONE;
+		return 0;
 
 	if (!(card->csd.cmdclass & CCC_SWITCH))
-		return MMC_ERR_NONE;
+		return 0;
 
 	if (!(card->host->caps & MMC_CAP_SD_HIGHSPEED))
-		return MMC_ERR_NONE;
+		return 0;
 
 	if (card->sw_caps.hs_max_dtr == 0)
-		return MMC_ERR_NONE;
+		return 0;
 
-	err = MMC_ERR_FAILED;
+	err = -EIO;
 
 	status = kmalloc(64, GFP_KERNEL);
 	if (!status) {
 		printk(KERN_ERR "%s: could not allocate a buffer for "
 			"switch capabilities.\n", mmc_hostname(card->host));
-		return err;
+		return -ENOMEM;
 	}
 
 	err = mmc_sd_switch(card, 1, 0, 1, status);
-	if (err != MMC_ERR_NONE)
+	if (err)
 		goto out;
 
 	if ((status[16] & 0xF) != 1) {
@@ -309,18 +309,18 @@ static int mmc_sd_init_card(struct mmc_host *host, u32 ocr,
 	 * block-addressed SDHC cards.
 	 */
 	err = mmc_send_if_cond(host, ocr);
-	if (err == MMC_ERR_NONE)
+	if (!err)
 		ocr |= 1 << 30;
 
 	err = mmc_send_app_op_cond(host, ocr, NULL);
-	if (err != MMC_ERR_NONE)
+	if (err)
 		goto err;
 
 	/*
 	 * Fetch CID from card.
 	 */
 	err = mmc_all_send_cid(host, cid);
-	if (err != MMC_ERR_NONE)
+	if (err)
 		goto err;
 
 	if (oldcard) {
@@ -344,7 +344,7 @@ static int mmc_sd_init_card(struct mmc_host *host, u32 ocr,
 	 * Set card RCA.
 	 */
 	err = mmc_send_relative_addr(host, &card->rca);
-	if (err != MMC_ERR_NONE)
+	if (err)
 		goto free_card;
 
 	mmc_set_bus_mode(host, MMC_BUSMODE_PUSHPULL);
@@ -354,7 +354,7 @@ static int mmc_sd_init_card(struct mmc_host *host, u32 ocr,
 		 * Fetch CSD from card.
 		 */
 		err = mmc_send_csd(card, card->raw_csd);
-		if (err != MMC_ERR_NONE)
+		if (err)
 			goto free_card;
 
 		err = mmc_decode_csd(card);
@@ -368,7 +368,7 @@ static int mmc_sd_init_card(struct mmc_host *host, u32 ocr,
 	 * Select card, as all following commands rely on that.
 	 */
 	err = mmc_select_card(card);
-	if (err != MMC_ERR_NONE)
+	if (err)
 		goto free_card;
 
 	if (!oldcard) {
@@ -376,7 +376,7 @@ static int mmc_sd_init_card(struct mmc_host *host, u32 ocr,
 		 * Fetch SCR from card.
 		 */
 		err = mmc_app_send_scr(card, card->raw_scr);
-		if (err != MMC_ERR_NONE)
+		if (err)
 			goto free_card;
 
 		err = mmc_decode_scr(card);
@@ -387,7 +387,7 @@ static int mmc_sd_init_card(struct mmc_host *host, u32 ocr,
 		 * Fetch switch information from card.
 		 */
 		err = mmc_read_switch(card);
-		if (err != MMC_ERR_NONE)
+		if (err)
 			goto free_card;
 	}
 
@@ -395,7 +395,7 @@ static int mmc_sd_init_card(struct mmc_host *host, u32 ocr,
 	 * Attempt to change to high-speed (if supported)
 	 */
 	err = mmc_switch_hs(card);
-	if (err != MMC_ERR_NONE)
+	if (err)
 		goto free_card;
 
 	/*
@@ -418,7 +418,7 @@ static int mmc_sd_init_card(struct mmc_host *host, u32 ocr,
 	if ((host->caps & MMC_CAP_4_BIT_DATA) &&
 		(card->scr.bus_widths & SD_SCR_BUS_WIDTH_4)) {
 		err = mmc_app_set_bus_width(card, MMC_BUS_WIDTH_4);
-		if (err != MMC_ERR_NONE)
+		if (err)
 			goto free_card;
 
 		mmc_set_bus_width(host, MMC_BUS_WIDTH_4);
@@ -442,14 +442,14 @@ static int mmc_sd_init_card(struct mmc_host *host, u32 ocr,
 	if (!oldcard)
 		host->card = card;
 
-	return MMC_ERR_NONE;
+	return 0;
 
 free_card:
 	if (!oldcard)
 		mmc_remove_card(card);
 err:
 
-	return MMC_ERR_FAILED;
+	return -EIO;
 }
 
 /*
@@ -483,7 +483,7 @@ static void mmc_sd_detect(struct mmc_host *host)
 
 	mmc_release_host(host);
 
-	if (err != MMC_ERR_NONE) {
+	if (err) {
 		mmc_sd_remove(host);
 
 		mmc_claim_host(host);
@@ -574,7 +574,7 @@ static void mmc_sd_resume(struct mmc_host *host)
 	err = mmc_sd_init_card(host, host->ocr, host->card);
 	mmc_release_host(host);
 
-	if (err != MMC_ERR_NONE) {
+	if (err) {
 		mmc_sd_remove(host);
 
 		mmc_claim_host(host);
@@ -644,7 +644,7 @@ int mmc_attach_sd(struct mmc_host *host, u32 ocr)
 	 * Detect and init the card.
 	 */
 	err = mmc_sd_init_card(host, host->ocr, NULL);
-	if (err != MMC_ERR_NONE)
+	if (err)
 		goto err;
 
 	mmc_release_host(host);

commit facba9179e3cd5fa91ff40bbc555c5cd4c101092
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Tue Jul 24 21:53:43 2007 +0200

    mmc: add missing printk levels
    
    Some printk:s were missing an explicit level.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index b6a2e53c9213..1edc62b1e5c6 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -149,7 +149,7 @@ static int mmc_decode_csd(struct mmc_card *card)
 		csd->write_partial = 0;
 		break;
 	default:
-		printk("%s: unrecognised CSD structure version %d\n",
+		printk(KERN_ERR "%s: unrecognised CSD structure version %d\n",
 			mmc_hostname(card->host), csd_struct);
 		return -EINVAL;
 	}
@@ -173,7 +173,7 @@ static int mmc_decode_scr(struct mmc_card *card)
 
 	scr_struct = UNSTUFF_BITS(resp, 60, 4);
 	if (scr_struct != 0) {
-		printk("%s: unrecognised SCR structure version %d\n",
+		printk(KERN_ERR "%s: unrecognised SCR structure version %d\n",
 			mmc_hostname(card->host), scr_struct);
 		return -EINVAL;
 	}
@@ -206,9 +206,8 @@ static int mmc_read_switch(struct mmc_card *card)
 
 	status = kmalloc(64, GFP_KERNEL);
 	if (!status) {
-		printk("%s: could not allocate a buffer for switch "
-		       "capabilities.\n",
-			mmc_hostname(card->host));
+		printk(KERN_ERR "%s: could not allocate a buffer for "
+			"switch capabilities.\n", mmc_hostname(card->host));
 		return err;
 	}
 
@@ -254,9 +253,8 @@ static int mmc_switch_hs(struct mmc_card *card)
 
 	status = kmalloc(64, GFP_KERNEL);
 	if (!status) {
-		printk("%s: could not allocate a buffer for switch "
-		       "capabilities.\n",
-			mmc_hostname(card->host));
+		printk(KERN_ERR "%s: could not allocate a buffer for "
+			"switch capabilities.\n", mmc_hostname(card->host));
 		return err;
 	}
 

commit 109b5bed18441599b5ab0e1f3623efa5715a4703
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Mon Jul 23 00:12:10 2007 +0200

    mmc: be more verbose about card insertions/removal
    
    Let the user know that the kernel actually detected the card
    by printing some basic information in dmesg.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 0b478de48acc..b6a2e53c9213 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -637,8 +637,10 @@ int mmc_attach_sd(struct mmc_host *host, u32 ocr)
 	/*
 	 * Can we support the voltage(s) of the card(s)?
 	 */
-	if (!host->ocr)
+	if (!host->ocr) {
+		err = -EINVAL;
 		goto err;
+	}
 
 	/*
 	 * Detect and init the card.
@@ -663,6 +665,9 @@ int mmc_attach_sd(struct mmc_host *host, u32 ocr)
 	mmc_detach_bus(host);
 	mmc_release_host(host);
 
+	printk(KERN_ERR "%s: error %d whilst initialising SD card\n",
+		mmc_hostname(host), err);
+
 	return 0;
 }
 

commit 2986d0bf23d97d68804ccfa80965073ccf1af242
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Sun Jul 22 17:52:06 2007 +0200

    mmc: Don't hold lock when releasing an added card
    
    When the card has been added to the device model, it might be bound
    to a card driver. Therefore, we have to release the host lock when
    trying to remove it as we otherwise might deadlock with the driver.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index df3bbfea2269..0b478de48acc 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -573,14 +573,17 @@ static void mmc_sd_resume(struct mmc_host *host)
 	BUG_ON(!host->card);
 
 	mmc_claim_host(host);
-
 	err = mmc_sd_init_card(host, host->ocr, host->card);
+	mmc_release_host(host);
+
 	if (err != MMC_ERR_NONE) {
 		mmc_sd_remove(host);
+
+		mmc_claim_host(host);
 		mmc_detach_bus(host);
+		mmc_release_host(host);
 	}
 
-	mmc_release_host(host);
 }
 
 #else
@@ -648,14 +651,14 @@ int mmc_attach_sd(struct mmc_host *host, u32 ocr)
 
 	err = mmc_add_card(host->card);
 	if (err)
-		goto reclaim_host;
+		goto remove_card;
 
 	return 0;
 
-reclaim_host:
-	mmc_claim_host(host);
+remove_card:
 	mmc_remove_card(host->card);
 	host->card = NULL;
+	mmc_claim_host(host);
 err:
 	mmc_detach_bus(host);
 	mmc_release_host(host);

commit 70f10482c668301c483acded13bf68780ad352b9
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Wed Jul 11 20:04:50 2007 +0200

    mmc: update header file paths
    
    Make sure all headers in the files reflect their true position
    in the tree.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 1240684083f1..df3bbfea2269 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -1,5 +1,5 @@
 /*
- *  linux/drivers/mmc/sd.c
+ *  linux/drivers/mmc/core/sd.c
  *
  *  Copyright (C) 2003-2004 Russell King, All Rights Reserved.
  *  SD support Copyright (C) 2004 Ian Molton, All Rights Reserved.

commit 4101c16a910b15afd190c6bc7d45864461cf5c25
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Sat May 19 13:39:01 2007 +0200

    mmc: refactor bus operations
    
    Move bus operations to its own file for the sake of clarity. Also
    delegate sysfs attributes to bus handlers in preparation for other
    more exotic types.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 918477c490b0..1240684083f1 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -19,11 +19,10 @@
 
 #include "core.h"
 #include "sysfs.h"
+#include "bus.h"
 #include "mmc_ops.h"
 #include "sd_ops.h"
 
-#include "core.h"
-
 static const unsigned int tran_exp[] = {
 	10000,		100000,		1000000,	10000000,
 	0,		0,		0,		0
@@ -487,8 +486,7 @@ static void mmc_sd_detect(struct mmc_host *host)
 	mmc_release_host(host);
 
 	if (err != MMC_ERR_NONE) {
-		mmc_remove_card(host->card);
-		host->card = NULL;
+		mmc_sd_remove(host);
 
 		mmc_claim_host(host);
 		mmc_detach_bus(host);
@@ -496,6 +494,55 @@ static void mmc_sd_detect(struct mmc_host *host)
 	}
 }
 
+MMC_ATTR_FN(cid, "%08x%08x%08x%08x\n", card->raw_cid[0], card->raw_cid[1],
+	card->raw_cid[2], card->raw_cid[3]);
+MMC_ATTR_FN(csd, "%08x%08x%08x%08x\n", card->raw_csd[0], card->raw_csd[1],
+	card->raw_csd[2], card->raw_csd[3]);
+MMC_ATTR_FN(scr, "%08x%08x\n", card->raw_scr[0], card->raw_scr[1]);
+MMC_ATTR_FN(date, "%02d/%04d\n", card->cid.month, card->cid.year);
+MMC_ATTR_FN(fwrev, "0x%x\n", card->cid.fwrev);
+MMC_ATTR_FN(hwrev, "0x%x\n", card->cid.hwrev);
+MMC_ATTR_FN(manfid, "0x%06x\n", card->cid.manfid);
+MMC_ATTR_FN(name, "%s\n", card->cid.prod_name);
+MMC_ATTR_FN(oemid, "0x%04x\n", card->cid.oemid);
+MMC_ATTR_FN(serial, "0x%08x\n", card->cid.serial);
+
+static struct device_attribute mmc_sd_dev_attrs[] = {
+	MMC_ATTR_RO(cid),
+	MMC_ATTR_RO(csd),
+	MMC_ATTR_RO(scr),
+	MMC_ATTR_RO(date),
+	MMC_ATTR_RO(fwrev),
+	MMC_ATTR_RO(hwrev),
+	MMC_ATTR_RO(manfid),
+	MMC_ATTR_RO(name),
+	MMC_ATTR_RO(oemid),
+	MMC_ATTR_RO(serial),
+	__ATTR_NULL,
+};
+
+/*
+ * Adds sysfs entries as relevant.
+ */
+static int mmc_sd_sysfs_add(struct mmc_host *host, struct mmc_card *card)
+{
+	int ret;
+
+	ret = mmc_add_attrs(card, mmc_sd_dev_attrs);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+/*
+ * Removes the sysfs entries added by mmc_sysfs_add().
+ */
+static void mmc_sd_sysfs_remove(struct mmc_host *host, struct mmc_card *card)
+{
+	mmc_remove_attrs(card, mmc_sd_dev_attrs);
+}
+
 #ifdef CONFIG_MMC_UNSAFE_RESUME
 
 /*
@@ -529,9 +576,7 @@ static void mmc_sd_resume(struct mmc_host *host)
 
 	err = mmc_sd_init_card(host, host->ocr, host->card);
 	if (err != MMC_ERR_NONE) {
-		mmc_remove_card(host->card);
-		host->card = NULL;
-
+		mmc_sd_remove(host);
 		mmc_detach_bus(host);
 	}
 
@@ -548,6 +593,8 @@ static void mmc_sd_resume(struct mmc_host *host)
 static const struct mmc_bus_ops mmc_sd_ops = {
 	.remove = mmc_sd_remove,
 	.detect = mmc_sd_detect,
+	.sysfs_add = mmc_sd_sysfs_add,
+	.sysfs_remove = mmc_sd_sysfs_remove,
 	.suspend = mmc_sd_suspend,
 	.resume = mmc_sd_resume,
 };
@@ -599,7 +646,7 @@ int mmc_attach_sd(struct mmc_host *host, u32 ocr)
 
 	mmc_release_host(host);
 
-	err = mmc_register_card(host->card);
+	err = mmc_add_card(host->card);
 	if (err)
 		goto reclaim_host;
 

commit c3bff2ec10b8bf2f53c954e370f9bdae93064472
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Wed Jun 13 19:06:03 2007 +0200

    mmc: get back read-only switch function
    
    Somehow the code to read the read-only switch of SD cards got lost
    in the reorganisation.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 41bfb5dfe6ff..918477c490b0 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -427,6 +427,21 @@ static int mmc_sd_init_card(struct mmc_host *host, u32 ocr,
 		mmc_set_bus_width(host, MMC_BUS_WIDTH_4);
 	}
 
+	/*
+	 * Check if read-only switch is active.
+	 */
+	if (!oldcard) {
+		if (!host->ops->get_ro) {
+			printk(KERN_WARNING "%s: host does not "
+				"support reading read-only "
+				"switch. assuming write-enable.\n",
+				mmc_hostname(host));
+		} else {
+			if (host->ops->get_ro(host))
+				mmc_card_set_readonly(card);
+		}
+	}
+
 	if (!oldcard)
 		host->card = card;
 

commit 3373c0ae6a51085b10a95fd9d2214a9995ef7563
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Thu May 31 22:25:11 2007 +0200

    mmc: don't call switch on old cards
    
    Make sure we don't call the switch function on cards too old to
    support it. They should just ignore it, but some have been reported
    to lock up instead.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 5afac2081185..41bfb5dfe6ff 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -15,6 +15,7 @@
 #include <linux/mmc/host.h>
 #include <linux/mmc/card.h>
 #include <linux/mmc/mmc.h>
+#include <linux/mmc/sd.h>
 
 #include "core.h"
 #include "sysfs.h"
@@ -192,6 +193,16 @@ static int mmc_read_switch(struct mmc_card *card)
 	int err;
 	u8 *status;
 
+	if (card->scr.sda_vsn < SCR_SPEC_VER_1)
+		return MMC_ERR_NONE;
+
+	if (!(card->csd.cmdclass & CCC_SWITCH)) {
+		printk(KERN_WARNING "%s: card lacks mandatory switch "
+			"function, performance might suffer.\n",
+			mmc_hostname(card->host));
+		return MMC_ERR_NONE;
+	}
+
 	err = MMC_ERR_FAILED;
 
 	status = kmalloc(64, GFP_KERNEL);
@@ -204,10 +215,9 @@ static int mmc_read_switch(struct mmc_card *card)
 
 	err = mmc_sd_switch(card, 0, 0, 1, status);
 	if (err != MMC_ERR_NONE) {
-		/*
-		 * Card not supporting high-speed will ignore the
-		 * command.
-		 */
+		printk(KERN_WARNING "%s: problem reading switch "
+			"capabilities, performance might suffer.\n",
+			mmc_hostname(card->host));
 		err = MMC_ERR_NONE;
 		goto out;
 	}
@@ -229,6 +239,12 @@ static int mmc_switch_hs(struct mmc_card *card)
 	int err;
 	u8 *status;
 
+	if (card->scr.sda_vsn < SCR_SPEC_VER_1)
+		return MMC_ERR_NONE;
+
+	if (!(card->csd.cmdclass & CCC_SWITCH))
+		return MMC_ERR_NONE;
+
 	if (!(card->host->caps & MMC_CAP_SD_HIGHSPEED))
 		return MMC_ERR_NONE;
 

commit 71651297a448289353b2493c6c3c183f9be7be7c
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Wed Jun 6 20:23:25 2007 +0200

    mmc: fix broken if clause
    
    Fix a broken if clause which was causing SD cards to go into
    4-bit mode even if the host did not support it.
    
    (Reported by David Brownell and Marc Pignat)
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index c1dfd03d559a..5afac2081185 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -402,7 +402,7 @@ static int mmc_sd_init_card(struct mmc_host *host, u32 ocr,
 	/*
 	 * Switch to wider bus (if supported).
 	 */
-	if ((host->caps && MMC_CAP_4_BIT_DATA) &&
+	if ((host->caps & MMC_CAP_4_BIT_DATA) &&
 		(card->scr.bus_widths & SD_SCR_BUS_WIDTH_4)) {
 		err = mmc_app_set_bus_width(card, MMC_BUS_WIDTH_4);
 		if (err != MMC_ERR_NONE)

commit bd766312618d2ecc85bce663f95faec601447ecb
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Tue May 1 16:11:57 2007 +0200

    mmc: remove old card states
    
    Remove card states that no longer make any sense.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 6597e778f70e..c1dfd03d559a 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -88,7 +88,7 @@ static void mmc_decode_cid(struct mmc_card *card)
 /*
  * Given a 128-bit response, decode to our card CSD structure.
  */
-static void mmc_decode_csd(struct mmc_card *card)
+static int mmc_decode_csd(struct mmc_card *card)
 {
 	struct mmc_csd *csd = &card->csd;
 	unsigned int e, m, csd_struct;
@@ -151,15 +151,16 @@ static void mmc_decode_csd(struct mmc_card *card)
 	default:
 		printk("%s: unrecognised CSD structure version %d\n",
 			mmc_hostname(card->host), csd_struct);
-		mmc_card_set_bad(card);
-		return;
+		return -EINVAL;
 	}
+
+	return 0;
 }
 
 /*
  * Given a 64-bit response, decode to our card SCR structure.
  */
-static void mmc_decode_scr(struct mmc_card *card)
+static int mmc_decode_scr(struct mmc_card *card)
 {
 	struct sd_scr *scr = &card->scr;
 	unsigned int scr_struct;
@@ -174,12 +175,13 @@ static void mmc_decode_scr(struct mmc_card *card)
 	if (scr_struct != 0) {
 		printk("%s: unrecognised SCR structure version %d\n",
 			mmc_hostname(card->host), scr_struct);
-		mmc_card_set_bad(card);
-		return;
+		return -EINVAL;
 	}
 
 	scr->sda_vsn = UNSTUFF_BITS(resp, 56, 4);
 	scr->bus_widths = UNSTUFF_BITS(resp, 48, 4);
+
+	return 0;
 }
 
 /*
@@ -342,7 +344,10 @@ static int mmc_sd_init_card(struct mmc_host *host, u32 ocr,
 		if (err != MMC_ERR_NONE)
 			goto free_card;
 
-		mmc_decode_csd(card);
+		err = mmc_decode_csd(card);
+		if (err < 0)
+			goto free_card;
+
 		mmc_decode_cid(card);
 	}
 
@@ -361,7 +366,9 @@ static int mmc_sd_init_card(struct mmc_host *host, u32 ocr,
 		if (err != MMC_ERR_NONE)
 			goto free_card;
 
-		mmc_decode_scr(card);
+		err = mmc_decode_scr(card);
+		if (err < 0)
+			goto free_card;
 
 		/*
 		 * Fetch switch information from card.

commit 6abaa0c9fec563538f2a28a682af8c89bb9b125c
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Tue May 1 16:00:02 2007 +0200

    mmc: support unsafe resume of cards
    
    Since many have the system root on MMC/SD we must allow some foot
    shooting when it comes to resume.
    
    We cannot detect if a card is removed and reinserted during suspend,
    so the safe approach would be to assume it was, avoiding potential
    filesystem corruption. This will of course not work if you cannot
    release the card before suspend.
    
    This commit adds a compile time option that makes the MMC layer
    assume the card wasn't touched if it is redetected upon resume.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index ae54e8eb7fea..6597e778f70e 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -263,55 +263,13 @@ static int mmc_switch_hs(struct mmc_card *card)
 }
 
 /*
- * Host is being removed. Free up the current card.
- */
-static void mmc_sd_remove(struct mmc_host *host)
-{
-	BUG_ON(!host);
-	BUG_ON(!host->card);
-
-	mmc_remove_card(host->card);
-	host->card = NULL;
-}
-
-/*
- * Card detection callback from host.
- */
-static void mmc_sd_detect(struct mmc_host *host)
-{
-	int err;
-
-	BUG_ON(!host);
-	BUG_ON(!host->card);
-
-	mmc_claim_host(host);
-
-	/*
-	 * Just check if our card has been removed.
-	 */
-	err = mmc_send_status(host->card, NULL);
-
-	mmc_release_host(host);
-
-	if (err != MMC_ERR_NONE) {
-		mmc_remove_card(host->card);
-		host->card = NULL;
-
-		mmc_claim_host(host);
-		mmc_detach_bus(host);
-		mmc_release_host(host);
-	}
-}
-
-static const struct mmc_bus_ops mmc_sd_ops = {
-	.remove = mmc_sd_remove,
-	.detect = mmc_sd_detect,
-};
-
-/*
- * Starting point for SD card init.
+ * Handle the detection and initialisation of a card.
+ *
+ * In the case of a resume, "curcard" will contain the card
+ * we're trying to reinitialise.
  */
-int mmc_attach_sd(struct mmc_host *host, u32 ocr)
+static int mmc_sd_init_card(struct mmc_host *host, u32 ocr,
+	struct mmc_card *oldcard)
 {
 	struct mmc_card *card;
 	int err;
@@ -321,34 +279,6 @@ int mmc_attach_sd(struct mmc_host *host, u32 ocr)
 	BUG_ON(!host);
 	BUG_ON(!host->claimed);
 
-	mmc_attach_bus(host, &mmc_sd_ops);
-
-	/*
-	 * Sanity check the voltages that the card claims to
-	 * support.
-	 */
-	if (ocr & 0x7F) {
-		printk(KERN_WARNING "%s: card claims to support voltages "
-		       "below the defined range. These will be ignored.\n",
-		       mmc_hostname(host));
-		ocr &= ~0x7F;
-	}
-
-	if (ocr & MMC_VDD_165_195) {
-		printk(KERN_WARNING "%s: SD card claims to support the "
-		       "incompletely defined 'low voltage range'. This "
-		       "will be ignored.\n", mmc_hostname(host));
-		ocr &= ~MMC_VDD_165_195;
-	}
-
-	host->ocr = mmc_select_voltage(host, ocr);
-
-	/*
-	 * Can we support the voltage(s) of the card(s)?
-	 */
-	if (!host->ocr)
-		goto err;
-
 	/*
 	 * Since we're changing the OCR value, we seem to
 	 * need to tell some cards to go back to the idle
@@ -363,11 +293,13 @@ int mmc_attach_sd(struct mmc_host *host, u32 ocr)
 	 * of the ocr to indicate that we can handle
 	 * block-addressed SDHC cards.
 	 */
-	err = mmc_send_if_cond(host, host->ocr);
+	err = mmc_send_if_cond(host, ocr);
 	if (err == MMC_ERR_NONE)
-		ocr = host->ocr | (1 << 30);
+		ocr |= 1 << 30;
 
-	mmc_send_app_op_cond(host, ocr, NULL);
+	err = mmc_send_app_op_cond(host, ocr, NULL);
+	if (err != MMC_ERR_NONE)
+		goto err;
 
 	/*
 	 * Fetch CID from card.
@@ -376,15 +308,22 @@ int mmc_attach_sd(struct mmc_host *host, u32 ocr)
 	if (err != MMC_ERR_NONE)
 		goto err;
 
-	/*
-	 * Allocate card structure.
-	 */
-	card = mmc_alloc_card(host);
-	if (IS_ERR(card))
-		goto err;
+	if (oldcard) {
+		if (memcmp(cid, oldcard->raw_cid, sizeof(cid)) != 0)
+			goto err;
 
-	card->type = MMC_TYPE_SD;
-	memcpy(card->raw_cid, cid, sizeof(card->raw_cid));
+		card = oldcard;
+	} else {
+		/*
+		 * Allocate card structure.
+		 */
+		card = mmc_alloc_card(host);
+		if (IS_ERR(card))
+			goto err;
+
+		card->type = MMC_TYPE_SD;
+		memcpy(card->raw_cid, cid, sizeof(card->raw_cid));
+	}
 
 	/*
 	 * Set card RCA.
@@ -395,35 +334,42 @@ int mmc_attach_sd(struct mmc_host *host, u32 ocr)
 
 	mmc_set_bus_mode(host, MMC_BUSMODE_PUSHPULL);
 
-	/*
-	 * Fetch CSD from card.
-	 */
-	err = mmc_send_csd(card, card->raw_csd);
-	if (err != MMC_ERR_NONE)
-		goto free_card;
+	if (!oldcard) {
+		/*
+		 * Fetch CSD from card.
+		 */
+		err = mmc_send_csd(card, card->raw_csd);
+		if (err != MMC_ERR_NONE)
+			goto free_card;
 
-	mmc_decode_csd(card);
-	mmc_decode_cid(card);
+		mmc_decode_csd(card);
+		mmc_decode_cid(card);
+	}
 
 	/*
-	 * Fetch SCR from card.
+	 * Select card, as all following commands rely on that.
 	 */
 	err = mmc_select_card(card);
 	if (err != MMC_ERR_NONE)
 		goto free_card;
 
-	err = mmc_app_send_scr(card, card->raw_scr);
-	if (err != MMC_ERR_NONE)
-		goto free_card;
+	if (!oldcard) {
+		/*
+		 * Fetch SCR from card.
+		 */
+		err = mmc_app_send_scr(card, card->raw_scr);
+		if (err != MMC_ERR_NONE)
+			goto free_card;
 
-	mmc_decode_scr(card);
+		mmc_decode_scr(card);
 
-	/*
-	 * Fetch switch information from card.
-	 */
-	err = mmc_read_switch(card);
-	if (err != MMC_ERR_NONE)
-		goto free_card;
+		/*
+		 * Fetch switch information from card.
+		 */
+		err = mmc_read_switch(card);
+		if (err != MMC_ERR_NONE)
+			goto free_card;
+	}
 
 	/*
 	 * Attempt to change to high-speed (if supported)
@@ -458,11 +404,164 @@ int mmc_attach_sd(struct mmc_host *host, u32 ocr)
 		mmc_set_bus_width(host, MMC_BUS_WIDTH_4);
 	}
 
-	host->card = card;
+	if (!oldcard)
+		host->card = card;
+
+	return MMC_ERR_NONE;
+
+free_card:
+	if (!oldcard)
+		mmc_remove_card(card);
+err:
+
+	return MMC_ERR_FAILED;
+}
+
+/*
+ * Host is being removed. Free up the current card.
+ */
+static void mmc_sd_remove(struct mmc_host *host)
+{
+	BUG_ON(!host);
+	BUG_ON(!host->card);
+
+	mmc_remove_card(host->card);
+	host->card = NULL;
+}
+
+/*
+ * Card detection callback from host.
+ */
+static void mmc_sd_detect(struct mmc_host *host)
+{
+	int err;
+
+	BUG_ON(!host);
+	BUG_ON(!host->card);
+
+	mmc_claim_host(host);
+
+	/*
+	 * Just check if our card has been removed.
+	 */
+	err = mmc_send_status(host->card, NULL);
 
 	mmc_release_host(host);
 
-	err = mmc_register_card(card);
+	if (err != MMC_ERR_NONE) {
+		mmc_remove_card(host->card);
+		host->card = NULL;
+
+		mmc_claim_host(host);
+		mmc_detach_bus(host);
+		mmc_release_host(host);
+	}
+}
+
+#ifdef CONFIG_MMC_UNSAFE_RESUME
+
+/*
+ * Suspend callback from host.
+ */
+static void mmc_sd_suspend(struct mmc_host *host)
+{
+	BUG_ON(!host);
+	BUG_ON(!host->card);
+
+	mmc_claim_host(host);
+	mmc_deselect_cards(host);
+	host->card->state &= ~MMC_STATE_HIGHSPEED;
+	mmc_release_host(host);
+}
+
+/*
+ * Resume callback from host.
+ *
+ * This function tries to determine if the same card is still present
+ * and, if so, restore all state to it.
+ */
+static void mmc_sd_resume(struct mmc_host *host)
+{
+	int err;
+
+	BUG_ON(!host);
+	BUG_ON(!host->card);
+
+	mmc_claim_host(host);
+
+	err = mmc_sd_init_card(host, host->ocr, host->card);
+	if (err != MMC_ERR_NONE) {
+		mmc_remove_card(host->card);
+		host->card = NULL;
+
+		mmc_detach_bus(host);
+	}
+
+	mmc_release_host(host);
+}
+
+#else
+
+#define mmc_sd_suspend NULL
+#define mmc_sd_resume NULL
+
+#endif
+
+static const struct mmc_bus_ops mmc_sd_ops = {
+	.remove = mmc_sd_remove,
+	.detect = mmc_sd_detect,
+	.suspend = mmc_sd_suspend,
+	.resume = mmc_sd_resume,
+};
+
+/*
+ * Starting point for SD card init.
+ */
+int mmc_attach_sd(struct mmc_host *host, u32 ocr)
+{
+	int err;
+
+	BUG_ON(!host);
+	BUG_ON(!host->claimed);
+
+	mmc_attach_bus(host, &mmc_sd_ops);
+
+	/*
+	 * Sanity check the voltages that the card claims to
+	 * support.
+	 */
+	if (ocr & 0x7F) {
+		printk(KERN_WARNING "%s: card claims to support voltages "
+		       "below the defined range. These will be ignored.\n",
+		       mmc_hostname(host));
+		ocr &= ~0x7F;
+	}
+
+	if (ocr & MMC_VDD_165_195) {
+		printk(KERN_WARNING "%s: SD card claims to support the "
+		       "incompletely defined 'low voltage range'. This "
+		       "will be ignored.\n", mmc_hostname(host));
+		ocr &= ~MMC_VDD_165_195;
+	}
+
+	host->ocr = mmc_select_voltage(host, ocr);
+
+	/*
+	 * Can we support the voltage(s) of the card(s)?
+	 */
+	if (!host->ocr)
+		goto err;
+
+	/*
+	 * Detect and init the card.
+	 */
+	err = mmc_sd_init_card(host, host->ocr, NULL);
+	if (err != MMC_ERR_NONE)
+		goto err;
+
+	mmc_release_host(host);
+
+	err = mmc_register_card(host->card);
 	if (err)
 		goto reclaim_host;
 
@@ -470,8 +569,7 @@ int mmc_attach_sd(struct mmc_host *host, u32 ocr)
 
 reclaim_host:
 	mmc_claim_host(host);
-free_card:
-	mmc_remove_card(card);
+	mmc_remove_card(host->card);
 	host->card = NULL;
 err:
 	mmc_detach_bus(host);

commit 1addfcdbe4b23a20f28a097c2469d9f0c21bef23
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Tue May 1 14:46:08 2007 +0200

    mmc: break apart switch function
    
    Break apart the SD switch function into one that reads the capabilities
    and one that acts on them.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index fb18b301502e..ae54e8eb7fea 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -183,16 +183,13 @@ static void mmc_decode_scr(struct mmc_card *card)
 }
 
 /*
- * Test if the card supports high-speed mode and, if so, switch to it.
+ * Fetches and decodes switch information
  */
-static int mmc_switch_hs(struct mmc_card *card)
+static int mmc_read_switch(struct mmc_card *card)
 {
 	int err;
 	u8 *status;
 
-	if (!(card->host->caps & MMC_CAP_SD_HIGHSPEED))
-		return MMC_ERR_NONE;
-
 	err = MMC_ERR_FAILED;
 
 	status = kmalloc(64, GFP_KERNEL);
@@ -209,14 +206,43 @@ static int mmc_switch_hs(struct mmc_card *card)
 		 * Card not supporting high-speed will ignore the
 		 * command.
 		 */
-		if (err == MMC_ERR_TIMEOUT)
-			err = MMC_ERR_NONE;
+		err = MMC_ERR_NONE;
 		goto out;
 	}
 
 	if (status[13] & 0x02)
 		card->sw_caps.hs_max_dtr = 50000000;
 
+out:
+	kfree(status);
+
+	return err;
+}
+
+/*
+ * Test if the card supports high-speed mode and, if so, switch to it.
+ */
+static int mmc_switch_hs(struct mmc_card *card)
+{
+	int err;
+	u8 *status;
+
+	if (!(card->host->caps & MMC_CAP_SD_HIGHSPEED))
+		return MMC_ERR_NONE;
+
+	if (card->sw_caps.hs_max_dtr == 0)
+		return MMC_ERR_NONE;
+
+	err = MMC_ERR_FAILED;
+
+	status = kmalloc(64, GFP_KERNEL);
+	if (!status) {
+		printk("%s: could not allocate a buffer for switch "
+		       "capabilities.\n",
+			mmc_hostname(card->host));
+		return err;
+	}
+
 	err = mmc_sd_switch(card, 1, 0, 1, status);
 	if (err != MMC_ERR_NONE)
 		goto out;
@@ -393,7 +419,14 @@ int mmc_attach_sd(struct mmc_host *host, u32 ocr)
 	mmc_decode_scr(card);
 
 	/*
-	 * Check if card can be switched into high-speed mode.
+	 * Fetch switch information from card.
+	 */
+	err = mmc_read_switch(card);
+	if (err != MMC_ERR_NONE)
+		goto free_card;
+
+	/*
+	 * Attempt to change to high-speed (if supported)
 	 */
 	err = mmc_switch_hs(card);
 	if (err != MMC_ERR_NONE)

commit 55556da01284af8c2174b786b3eca8e11301b656
Author: Philip Langdale <philipl@overt.org>
Date:   Fri Mar 16 19:39:00 2007 -0700

    MMC: Fix handling of low-voltage cards
    
    Fix handling of low voltage MMC cards.
    
    The latest MMC and SD specs both agree that support for
    low-voltage operations is indicated by bit 7 in the OCR.
    The MMC spec states that the low voltage range is
    1.65-1.95V while the SD spec leaves the actual voltage
    range undefined - meaning that there is still no such
    thing as a low voltage SD card.
    
    However, an old Sandisk spec implied that bits 7.0
    represented voltages below 2.0V in 1V or 0.5V increments,
    and the code was accordingly written with that expectation.
    
    This confusion meant that host drivers attempting to support
    the typical low voltage (1.8V) would set the wrong bits in
    the host OCR mask (usually bits 5 and/or 6) resulting in the
    the low voltage mode never being used.
    
    This change corrects the low voltage range and adds sanity
    checks on the reserved bits (0-6) and for SD cards that
    claim to support low-voltage operations.
    
    Signed-off-by: Philip Langdale <philipl@overt.org>
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 6c6beb48f3a8..fb18b301502e 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -297,6 +297,24 @@ int mmc_attach_sd(struct mmc_host *host, u32 ocr)
 
 	mmc_attach_bus(host, &mmc_sd_ops);
 
+	/*
+	 * Sanity check the voltages that the card claims to
+	 * support.
+	 */
+	if (ocr & 0x7F) {
+		printk(KERN_WARNING "%s: card claims to support voltages "
+		       "below the defined range. These will be ignored.\n",
+		       mmc_hostname(host));
+		ocr &= ~0x7F;
+	}
+
+	if (ocr & MMC_VDD_165_195) {
+		printk(KERN_WARNING "%s: SD card claims to support the "
+		       "incompletely defined 'low voltage range'. This "
+		       "will be ignored.\n", mmc_hostname(host));
+		ocr &= ~MMC_VDD_165_195;
+	}
+
 	host->ocr = mmc_select_voltage(host, ocr);
 
 	/*

commit 7ea239d9e6d6993469a6a8ca83ff23834dfc3fce
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Sun Dec 31 00:11:32 2006 +0100

    mmc: add bus handler
    
    Delegate protocol handling to "bus handlers". This allows the core to
    just handle the task of arbitrating the bus. Initialisation and
    pampering of cards is now done by the different bus handlers.
    
    This design also allows MMC and SD (and later SDIO) to be more cleanly
    separated, allowing easier maintenance.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
new file mode 100644
index 000000000000..6c6beb48f3a8
--- /dev/null
+++ b/drivers/mmc/core/sd.c
@@ -0,0 +1,431 @@
+/*
+ *  linux/drivers/mmc/sd.c
+ *
+ *  Copyright (C) 2003-2004 Russell King, All Rights Reserved.
+ *  SD support Copyright (C) 2004 Ian Molton, All Rights Reserved.
+ *  Copyright (C) 2005-2007 Pierre Ossman, All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/err.h>
+
+#include <linux/mmc/host.h>
+#include <linux/mmc/card.h>
+#include <linux/mmc/mmc.h>
+
+#include "core.h"
+#include "sysfs.h"
+#include "mmc_ops.h"
+#include "sd_ops.h"
+
+#include "core.h"
+
+static const unsigned int tran_exp[] = {
+	10000,		100000,		1000000,	10000000,
+	0,		0,		0,		0
+};
+
+static const unsigned char tran_mant[] = {
+	0,	10,	12,	13,	15,	20,	25,	30,
+	35,	40,	45,	50,	55,	60,	70,	80,
+};
+
+static const unsigned int tacc_exp[] = {
+	1,	10,	100,	1000,	10000,	100000,	1000000, 10000000,
+};
+
+static const unsigned int tacc_mant[] = {
+	0,	10,	12,	13,	15,	20,	25,	30,
+	35,	40,	45,	50,	55,	60,	70,	80,
+};
+
+#define UNSTUFF_BITS(resp,start,size)					\
+	({								\
+		const int __size = size;				\
+		const u32 __mask = (__size < 32 ? 1 << __size : 0) - 1;	\
+		const int __off = 3 - ((start) / 32);			\
+		const int __shft = (start) & 31;			\
+		u32 __res;						\
+									\
+		__res = resp[__off] >> __shft;				\
+		if (__size + __shft > 32)				\
+			__res |= resp[__off-1] << ((32 - __shft) % 32);	\
+		__res & __mask;						\
+	})
+
+/*
+ * Given the decoded CSD structure, decode the raw CID to our CID structure.
+ */
+static void mmc_decode_cid(struct mmc_card *card)
+{
+	u32 *resp = card->raw_cid;
+
+	memset(&card->cid, 0, sizeof(struct mmc_cid));
+
+	/*
+	 * SD doesn't currently have a version field so we will
+	 * have to assume we can parse this.
+	 */
+	card->cid.manfid		= UNSTUFF_BITS(resp, 120, 8);
+	card->cid.oemid			= UNSTUFF_BITS(resp, 104, 16);
+	card->cid.prod_name[0]		= UNSTUFF_BITS(resp, 96, 8);
+	card->cid.prod_name[1]		= UNSTUFF_BITS(resp, 88, 8);
+	card->cid.prod_name[2]		= UNSTUFF_BITS(resp, 80, 8);
+	card->cid.prod_name[3]		= UNSTUFF_BITS(resp, 72, 8);
+	card->cid.prod_name[4]		= UNSTUFF_BITS(resp, 64, 8);
+	card->cid.hwrev			= UNSTUFF_BITS(resp, 60, 4);
+	card->cid.fwrev			= UNSTUFF_BITS(resp, 56, 4);
+	card->cid.serial		= UNSTUFF_BITS(resp, 24, 32);
+	card->cid.year			= UNSTUFF_BITS(resp, 12, 8);
+	card->cid.month			= UNSTUFF_BITS(resp, 8, 4);
+
+	card->cid.year += 2000; /* SD cards year offset */
+}
+
+/*
+ * Given a 128-bit response, decode to our card CSD structure.
+ */
+static void mmc_decode_csd(struct mmc_card *card)
+{
+	struct mmc_csd *csd = &card->csd;
+	unsigned int e, m, csd_struct;
+	u32 *resp = card->raw_csd;
+
+	csd_struct = UNSTUFF_BITS(resp, 126, 2);
+
+	switch (csd_struct) {
+	case 0:
+		m = UNSTUFF_BITS(resp, 115, 4);
+		e = UNSTUFF_BITS(resp, 112, 3);
+		csd->tacc_ns	 = (tacc_exp[e] * tacc_mant[m] + 9) / 10;
+		csd->tacc_clks	 = UNSTUFF_BITS(resp, 104, 8) * 100;
+
+		m = UNSTUFF_BITS(resp, 99, 4);
+		e = UNSTUFF_BITS(resp, 96, 3);
+		csd->max_dtr	  = tran_exp[e] * tran_mant[m];
+		csd->cmdclass	  = UNSTUFF_BITS(resp, 84, 12);
+
+		e = UNSTUFF_BITS(resp, 47, 3);
+		m = UNSTUFF_BITS(resp, 62, 12);
+		csd->capacity	  = (1 + m) << (e + 2);
+
+		csd->read_blkbits = UNSTUFF_BITS(resp, 80, 4);
+		csd->read_partial = UNSTUFF_BITS(resp, 79, 1);
+		csd->write_misalign = UNSTUFF_BITS(resp, 78, 1);
+		csd->read_misalign = UNSTUFF_BITS(resp, 77, 1);
+		csd->r2w_factor = UNSTUFF_BITS(resp, 26, 3);
+		csd->write_blkbits = UNSTUFF_BITS(resp, 22, 4);
+		csd->write_partial = UNSTUFF_BITS(resp, 21, 1);
+		break;
+	case 1:
+		/*
+		 * This is a block-addressed SDHC card. Most
+		 * interesting fields are unused and have fixed
+		 * values. To avoid getting tripped by buggy cards,
+		 * we assume those fixed values ourselves.
+		 */
+		mmc_card_set_blockaddr(card);
+
+		csd->tacc_ns	 = 0; /* Unused */
+		csd->tacc_clks	 = 0; /* Unused */
+
+		m = UNSTUFF_BITS(resp, 99, 4);
+		e = UNSTUFF_BITS(resp, 96, 3);
+		csd->max_dtr	  = tran_exp[e] * tran_mant[m];
+		csd->cmdclass	  = UNSTUFF_BITS(resp, 84, 12);
+
+		m = UNSTUFF_BITS(resp, 48, 22);
+		csd->capacity     = (1 + m) << 10;
+
+		csd->read_blkbits = 9;
+		csd->read_partial = 0;
+		csd->write_misalign = 0;
+		csd->read_misalign = 0;
+		csd->r2w_factor = 4; /* Unused */
+		csd->write_blkbits = 9;
+		csd->write_partial = 0;
+		break;
+	default:
+		printk("%s: unrecognised CSD structure version %d\n",
+			mmc_hostname(card->host), csd_struct);
+		mmc_card_set_bad(card);
+		return;
+	}
+}
+
+/*
+ * Given a 64-bit response, decode to our card SCR structure.
+ */
+static void mmc_decode_scr(struct mmc_card *card)
+{
+	struct sd_scr *scr = &card->scr;
+	unsigned int scr_struct;
+	u32 resp[4];
+
+	BUG_ON(!mmc_card_sd(card));
+
+	resp[3] = card->raw_scr[1];
+	resp[2] = card->raw_scr[0];
+
+	scr_struct = UNSTUFF_BITS(resp, 60, 4);
+	if (scr_struct != 0) {
+		printk("%s: unrecognised SCR structure version %d\n",
+			mmc_hostname(card->host), scr_struct);
+		mmc_card_set_bad(card);
+		return;
+	}
+
+	scr->sda_vsn = UNSTUFF_BITS(resp, 56, 4);
+	scr->bus_widths = UNSTUFF_BITS(resp, 48, 4);
+}
+
+/*
+ * Test if the card supports high-speed mode and, if so, switch to it.
+ */
+static int mmc_switch_hs(struct mmc_card *card)
+{
+	int err;
+	u8 *status;
+
+	if (!(card->host->caps & MMC_CAP_SD_HIGHSPEED))
+		return MMC_ERR_NONE;
+
+	err = MMC_ERR_FAILED;
+
+	status = kmalloc(64, GFP_KERNEL);
+	if (!status) {
+		printk("%s: could not allocate a buffer for switch "
+		       "capabilities.\n",
+			mmc_hostname(card->host));
+		return err;
+	}
+
+	err = mmc_sd_switch(card, 0, 0, 1, status);
+	if (err != MMC_ERR_NONE) {
+		/*
+		 * Card not supporting high-speed will ignore the
+		 * command.
+		 */
+		if (err == MMC_ERR_TIMEOUT)
+			err = MMC_ERR_NONE;
+		goto out;
+	}
+
+	if (status[13] & 0x02)
+		card->sw_caps.hs_max_dtr = 50000000;
+
+	err = mmc_sd_switch(card, 1, 0, 1, status);
+	if (err != MMC_ERR_NONE)
+		goto out;
+
+	if ((status[16] & 0xF) != 1) {
+		printk(KERN_WARNING "%s: Problem switching card "
+			"into high-speed mode!\n",
+			mmc_hostname(card->host));
+	} else {
+		mmc_card_set_highspeed(card);
+		mmc_set_timing(card->host, MMC_TIMING_SD_HS);
+	}
+
+out:
+	kfree(status);
+
+	return err;
+}
+
+/*
+ * Host is being removed. Free up the current card.
+ */
+static void mmc_sd_remove(struct mmc_host *host)
+{
+	BUG_ON(!host);
+	BUG_ON(!host->card);
+
+	mmc_remove_card(host->card);
+	host->card = NULL;
+}
+
+/*
+ * Card detection callback from host.
+ */
+static void mmc_sd_detect(struct mmc_host *host)
+{
+	int err;
+
+	BUG_ON(!host);
+	BUG_ON(!host->card);
+
+	mmc_claim_host(host);
+
+	/*
+	 * Just check if our card has been removed.
+	 */
+	err = mmc_send_status(host->card, NULL);
+
+	mmc_release_host(host);
+
+	if (err != MMC_ERR_NONE) {
+		mmc_remove_card(host->card);
+		host->card = NULL;
+
+		mmc_claim_host(host);
+		mmc_detach_bus(host);
+		mmc_release_host(host);
+	}
+}
+
+static const struct mmc_bus_ops mmc_sd_ops = {
+	.remove = mmc_sd_remove,
+	.detect = mmc_sd_detect,
+};
+
+/*
+ * Starting point for SD card init.
+ */
+int mmc_attach_sd(struct mmc_host *host, u32 ocr)
+{
+	struct mmc_card *card;
+	int err;
+	u32 cid[4];
+	unsigned int max_dtr;
+
+	BUG_ON(!host);
+	BUG_ON(!host->claimed);
+
+	mmc_attach_bus(host, &mmc_sd_ops);
+
+	host->ocr = mmc_select_voltage(host, ocr);
+
+	/*
+	 * Can we support the voltage(s) of the card(s)?
+	 */
+	if (!host->ocr)
+		goto err;
+
+	/*
+	 * Since we're changing the OCR value, we seem to
+	 * need to tell some cards to go back to the idle
+	 * state.  We wait 1ms to give cards time to
+	 * respond.
+	 */
+	mmc_go_idle(host);
+
+	/*
+	 * If SD_SEND_IF_COND indicates an SD 2.0
+	 * compliant card and we should set bit 30
+	 * of the ocr to indicate that we can handle
+	 * block-addressed SDHC cards.
+	 */
+	err = mmc_send_if_cond(host, host->ocr);
+	if (err == MMC_ERR_NONE)
+		ocr = host->ocr | (1 << 30);
+
+	mmc_send_app_op_cond(host, ocr, NULL);
+
+	/*
+	 * Fetch CID from card.
+	 */
+	err = mmc_all_send_cid(host, cid);
+	if (err != MMC_ERR_NONE)
+		goto err;
+
+	/*
+	 * Allocate card structure.
+	 */
+	card = mmc_alloc_card(host);
+	if (IS_ERR(card))
+		goto err;
+
+	card->type = MMC_TYPE_SD;
+	memcpy(card->raw_cid, cid, sizeof(card->raw_cid));
+
+	/*
+	 * Set card RCA.
+	 */
+	err = mmc_send_relative_addr(host, &card->rca);
+	if (err != MMC_ERR_NONE)
+		goto free_card;
+
+	mmc_set_bus_mode(host, MMC_BUSMODE_PUSHPULL);
+
+	/*
+	 * Fetch CSD from card.
+	 */
+	err = mmc_send_csd(card, card->raw_csd);
+	if (err != MMC_ERR_NONE)
+		goto free_card;
+
+	mmc_decode_csd(card);
+	mmc_decode_cid(card);
+
+	/*
+	 * Fetch SCR from card.
+	 */
+	err = mmc_select_card(card);
+	if (err != MMC_ERR_NONE)
+		goto free_card;
+
+	err = mmc_app_send_scr(card, card->raw_scr);
+	if (err != MMC_ERR_NONE)
+		goto free_card;
+
+	mmc_decode_scr(card);
+
+	/*
+	 * Check if card can be switched into high-speed mode.
+	 */
+	err = mmc_switch_hs(card);
+	if (err != MMC_ERR_NONE)
+		goto free_card;
+
+	/*
+	 * Compute bus speed.
+	 */
+	max_dtr = (unsigned int)-1;
+
+	if (mmc_card_highspeed(card)) {
+		if (max_dtr > card->sw_caps.hs_max_dtr)
+			max_dtr = card->sw_caps.hs_max_dtr;
+	} else if (max_dtr > card->csd.max_dtr) {
+		max_dtr = card->csd.max_dtr;
+	}
+
+	mmc_set_clock(host, max_dtr);
+
+	/*
+	 * Switch to wider bus (if supported).
+	 */
+	if ((host->caps && MMC_CAP_4_BIT_DATA) &&
+		(card->scr.bus_widths & SD_SCR_BUS_WIDTH_4)) {
+		err = mmc_app_set_bus_width(card, MMC_BUS_WIDTH_4);
+		if (err != MMC_ERR_NONE)
+			goto free_card;
+
+		mmc_set_bus_width(host, MMC_BUS_WIDTH_4);
+	}
+
+	host->card = card;
+
+	mmc_release_host(host);
+
+	err = mmc_register_card(card);
+	if (err)
+		goto reclaim_host;
+
+	return 0;
+
+reclaim_host:
+	mmc_claim_host(host);
+free_card:
+	mmc_remove_card(card);
+	host->card = NULL;
+err:
+	mmc_detach_bus(host);
+	mmc_release_host(host);
+
+	return 0;
+}
+
