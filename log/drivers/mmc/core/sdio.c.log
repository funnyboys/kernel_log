commit 254e175448b7dc2f40e41d8941ac925f07c5862b
Author: Pali Rohár <pali@kernel.org>
Date:   Wed May 27 13:08:58 2020 +0200

    mmc: core: Export device/vendor ids from Common CIS for SDIO cards
    
    Device/vendor ids from Common CIS (Card Information Structure) may be
    different as device/vendor ids from CIS on particular SDIO function.
    
    Kernel currently exports only device/vendor ids from SDIO functions and not
    "main" device/vendor ids from Common CIS.
    
    This patch exports "main" device/vendor ids for SDIO and SD combo cards at
    top level mmc device in sysfs hierarchy.
    
    Userspace can use e.g. udev rules to correctly match whole SDIO card based
    on Common CIS device/vendor id and not only one particular SDIO function.
    Having this information in userspace also helps developers to debug whole
    SDIO card as e.g. kernel mmc quirks use device/vendor ids from Common CIS
    and not from particular SDIO function. Also it allows to write userspace
    applications which list all connected SDIO cards based on CIS ids.
    
    Signed-off-by: Pali Rohár <pali@kernel.org>
    Reviewed-by: Marek Behún <marek.behun@nic.cz>
    Link: https://lore.kernel.org/r/20200527110858.17504-2-pali@kernel.org
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 435de47a6ee0..b65b26f76d71 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -27,6 +27,24 @@
 #include "sdio_ops.h"
 #include "sdio_cis.h"
 
+MMC_DEV_ATTR(vendor, "0x%04x\n", card->cis.vendor);
+MMC_DEV_ATTR(device, "0x%04x\n", card->cis.device);
+MMC_DEV_ATTR(ocr, "0x%08x\n", card->ocr);
+MMC_DEV_ATTR(rca, "0x%04x\n", card->rca);
+
+static struct attribute *sdio_std_attrs[] = {
+	&dev_attr_vendor.attr,
+	&dev_attr_device.attr,
+	&dev_attr_ocr.attr,
+	&dev_attr_rca.attr,
+	NULL,
+};
+ATTRIBUTE_GROUPS(sdio_std);
+
+static struct device_type sdio_type = {
+	.groups = sdio_std_groups,
+};
+
 static int sdio_read_fbr(struct sdio_func *func)
 {
 	int ret;
@@ -618,7 +636,7 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 	/*
 	 * Allocate card structure.
 	 */
-	card = mmc_alloc_card(host, NULL);
+	card = mmc_alloc_card(host, &sdio_type);
 	if (IS_ERR(card))
 		return PTR_ERR(card);
 

commit 1dc5a61559e73472cd84bc8aa5b297ec0deba4de
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu Apr 30 11:16:40 2020 +0200

    mmc: sdio: Align the initialization commands in retry path for UHS-I
    
    According to the comment in mmc_sdio_reinit_card(), some SDIO cards may
    require a "[CMD5,5,3,7] init sequence", which isn't always obeyed in
    mmc_sdio_init_card(). Especially, when we end up retrying the UHS-I
    specific initialization, there is a missing CMD5.
    
    Let's update the code to make the behaviour consistent and let's also take
    the opportunity to clean up the code a bit, to avoid open coding.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Link: https://lore.kernel.org/r/20200430091640.455-5-ulf.hansson@linaro.org

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 853ac65f0485..435de47a6ee0 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -543,13 +543,33 @@ static int mmc_sdio_init_uhs_card(struct mmc_card *card)
 	return err;
 }
 
-static void mmc_sdio_resend_if_cond(struct mmc_host *host, u32 ocr,
-				    struct mmc_card *card)
+static int mmc_sdio_pre_init(struct mmc_host *host, u32 ocr,
+			     struct mmc_card *card)
 {
+	if (card)
+		mmc_remove_card(card);
+
+	/*
+	 * Reset the card by performing the same steps that are taken by
+	 * mmc_rescan_try_freq() and mmc_attach_sdio() during a "normal" probe.
+	 *
+	 * sdio_reset() is technically not needed. Having just powered up the
+	 * hardware, it should already be in reset state. However, some
+	 * platforms (such as SD8686 on OLPC) do not instantly cut power,
+	 * meaning that a reset is required when restoring power soon after
+	 * powering off. It is harmless in other cases.
+	 *
+	 * The CMD5 reset (mmc_send_io_op_cond()), according to the SDIO spec,
+	 * is not necessary for non-removable cards. However, it is required
+	 * for OLPC SD8686 (which expects a [CMD5,5,3,7] init sequence), and
+	 * harmless in other situations.
+	 *
+	 */
+
 	sdio_reset(host);
 	mmc_go_idle(host);
 	mmc_send_if_cond(host, ocr);
-	mmc_remove_card(card);
+	return mmc_send_io_op_cond(host, 0, NULL);
 }
 
 /*
@@ -640,7 +660,7 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 	if (rocr & ocr & R4_18V_PRESENT) {
 		err = mmc_set_uhs_voltage(host, ocr_card);
 		if (err == -EAGAIN) {
-			mmc_sdio_resend_if_cond(host, ocr_card, card);
+			mmc_sdio_pre_init(host, ocr_card, card);
 			retries--;
 			goto try_again;
 		} else if (err) {
@@ -712,7 +732,7 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 	 */
 	err = sdio_read_cccr(card, ocr);
 	if (err) {
-		mmc_sdio_resend_if_cond(host, ocr_card, card);
+		mmc_sdio_pre_init(host, ocr_card, card);
 		if (ocr & R4_18V_PRESENT) {
 			/* Retry init sequence, but without R4_18V_PRESENT. */
 			retries = 0;
@@ -813,28 +833,7 @@ static int mmc_sdio_reinit_card(struct mmc_host *host)
 {
 	int ret;
 
-	/*
-	 * Reset the card by performing the same steps that are taken by
-	 * mmc_rescan_try_freq() and mmc_attach_sdio() during a "normal" probe.
-	 *
-	 * sdio_reset() is technically not needed. Having just powered up the
-	 * hardware, it should already be in reset state. However, some
-	 * platforms (such as SD8686 on OLPC) do not instantly cut power,
-	 * meaning that a reset is required when restoring power soon after
-	 * powering off. It is harmless in other cases.
-	 *
-	 * The CMD5 reset (mmc_send_io_op_cond()), according to the SDIO spec,
-	 * is not necessary for non-removable cards. However, it is required
-	 * for OLPC SD8686 (which expects a [CMD5,5,3,7] init sequence), and
-	 * harmless in other situations.
-	 *
-	 */
-
-	sdio_reset(host);
-	mmc_go_idle(host);
-	mmc_send_if_cond(host, host->card->ocr);
-
-	ret = mmc_send_io_op_cond(host, 0, NULL);
+	ret = mmc_sdio_pre_init(host, host->card->ocr, NULL);
 	if (ret)
 		return ret;
 

commit fa1e3191922bb6b59a64a1a03e461cde07ae1e62
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu Apr 30 11:16:39 2020 +0200

    mmc: sdio: Re-use negotiated OCR mask when re-sending CMD8
    
    While initializing an SDIO card in mmc_sdio_init_card(), we may need to
    retry the UHS-I specific initialization, in case the first attempt fails.
    
    This leads to resending a CMD8, but also to restart from scratch with the
    so called OCR mask negotiations. This is unnecessary as we already have a
    negotiated OCR mask, so let's use that instead. In this way, the behaviour
    also becomes more consistent with other similar paths.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Link: https://lore.kernel.org/r/20200430091640.455-4-ulf.hansson@linaro.org

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 20eed28ea60d..853ac65f0485 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -543,12 +543,12 @@ static int mmc_sdio_init_uhs_card(struct mmc_card *card)
 	return err;
 }
 
-static void mmc_sdio_resend_if_cond(struct mmc_host *host,
+static void mmc_sdio_resend_if_cond(struct mmc_host *host, u32 ocr,
 				    struct mmc_card *card)
 {
 	sdio_reset(host);
 	mmc_go_idle(host);
-	mmc_send_if_cond(host, host->ocr_avail);
+	mmc_send_if_cond(host, ocr);
 	mmc_remove_card(card);
 }
 
@@ -640,7 +640,7 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 	if (rocr & ocr & R4_18V_PRESENT) {
 		err = mmc_set_uhs_voltage(host, ocr_card);
 		if (err == -EAGAIN) {
-			mmc_sdio_resend_if_cond(host, card);
+			mmc_sdio_resend_if_cond(host, ocr_card, card);
 			retries--;
 			goto try_again;
 		} else if (err) {
@@ -712,7 +712,7 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 	 */
 	err = sdio_read_cccr(card, ocr);
 	if (err) {
-		mmc_sdio_resend_if_cond(host, card);
+		mmc_sdio_resend_if_cond(host, ocr_card, card);
 		if (ocr & R4_18V_PRESENT) {
 			/* Retry init sequence, but without R4_18V_PRESENT. */
 			retries = 0;

commit a94a59f43749b4f8cd81b8be87c95f9ef898d19d
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu Apr 30 11:16:38 2020 +0200

    mmc: sdio: Fix several potential memory leaks in mmc_sdio_init_card()
    
    Over the years, the code in mmc_sdio_init_card() has grown to become quite
    messy. Unfortunate this has also lead to that several paths are leaking
    memory in form of an allocated struct mmc_card, which includes additional
    data, such as initialized struct device for example.
    
    Unfortunate, it's a too complex task find each offending commit. Therefore,
    this change fixes all memory leaks at once.
    
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Link: https://lore.kernel.org/r/20200430091640.455-3-ulf.hansson@linaro.org

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index d35679e6e6aa..20eed28ea60d 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -584,7 +584,7 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 	 */
 	err = mmc_send_io_op_cond(host, ocr, &rocr);
 	if (err)
-		goto err;
+		return err;
 
 	/*
 	 * For SPI, enable CRC as appropriate.
@@ -592,17 +592,15 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 	if (mmc_host_is_spi(host)) {
 		err = mmc_spi_set_crc(host, use_spi_crc);
 		if (err)
-			goto err;
+			return err;
 	}
 
 	/*
 	 * Allocate card structure.
 	 */
 	card = mmc_alloc_card(host, NULL);
-	if (IS_ERR(card)) {
-		err = PTR_ERR(card);
-		goto err;
-	}
+	if (IS_ERR(card))
+		return PTR_ERR(card);
 
 	if ((rocr & R4_MEMORY_PRESENT) &&
 	    mmc_sd_get_cid(host, ocr & rocr, card->raw_cid, NULL) == 0) {
@@ -610,19 +608,15 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 
 		if (oldcard && (oldcard->type != MMC_TYPE_SD_COMBO ||
 		    memcmp(card->raw_cid, oldcard->raw_cid, sizeof(card->raw_cid)) != 0)) {
-			mmc_remove_card(card);
-			pr_debug("%s: Perhaps the card was replaced\n",
-				mmc_hostname(host));
-			return -ENOENT;
+			err = -ENOENT;
+			goto mismatch;
 		}
 	} else {
 		card->type = MMC_TYPE_SDIO;
 
 		if (oldcard && oldcard->type != MMC_TYPE_SDIO) {
-			mmc_remove_card(card);
-			pr_debug("%s: Perhaps the card was replaced\n",
-				mmc_hostname(host));
-			return -ENOENT;
+			err = -ENOENT;
+			goto mismatch;
 		}
 	}
 
@@ -677,7 +671,7 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 	if (!oldcard && card->type == MMC_TYPE_SD_COMBO) {
 		err = mmc_sd_get_csd(host, card);
 		if (err)
-			return err;
+			goto remove;
 
 		mmc_decode_cid(card);
 	}
@@ -704,7 +698,12 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 			mmc_set_timing(card->host, MMC_TIMING_SD_HS);
 		}
 
-		goto finish;
+		if (oldcard)
+			mmc_remove_card(card);
+		else
+			host->card = card;
+
+		return 0;
 	}
 
 	/*
@@ -730,16 +729,14 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 		goto remove;
 
 	if (oldcard) {
-		int same = (card->cis.vendor == oldcard->cis.vendor &&
-			    card->cis.device == oldcard->cis.device);
-		mmc_remove_card(card);
-		if (!same) {
-			pr_debug("%s: Perhaps the card was replaced\n",
-				mmc_hostname(host));
-			return -ENOENT;
+		if (card->cis.vendor == oldcard->cis.vendor &&
+		    card->cis.device == oldcard->cis.device) {
+			mmc_remove_card(card);
+			card = oldcard;
+		} else {
+			err = -ENOENT;
+			goto mismatch;
 		}
-
-		card = oldcard;
 	}
 	card->ocr = ocr_card;
 	mmc_fixup_device(card, sdio_fixup_methods);
@@ -800,16 +797,15 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 		err = -EINVAL;
 		goto remove;
 	}
-finish:
-	if (!oldcard)
-		host->card = card;
+
+	host->card = card;
 	return 0;
 
+mismatch:
+	pr_debug("%s: Perhaps the card was replaced\n", mmc_hostname(host));
 remove:
-	if (!oldcard)
+	if (oldcard != card)
 		mmc_remove_card(card);
-
-err:
 	return err;
 }
 

commit f04086c225da11ad16d7f9a2fbca6483ab16dded
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu Apr 30 11:16:37 2020 +0200

    mmc: sdio: Fix potential NULL pointer error in mmc_sdio_init_card()
    
    During some scenarios mmc_sdio_init_card() runs a retry path for the UHS-I
    specific initialization, which leads to removal of the previously allocated
    card. A new card is then re-allocated while retrying.
    
    However, in one of the corresponding error paths we may end up to remove an
    already removed card, which likely leads to a NULL pointer exception. So,
    let's fix this.
    
    Fixes: 5fc3d80ef496 ("mmc: sdio: don't use rocr to check if the card could support UHS mode")
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Link: https://lore.kernel.org/r/20200430091640.455-2-ulf.hansson@linaro.org

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index ebb387aa5158..d35679e6e6aa 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -718,9 +718,8 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 			/* Retry init sequence, but without R4_18V_PRESENT. */
 			retries = 0;
 			goto try_again;
-		} else {
-			goto remove;
 		}
+		return err;
 	}
 
 	/*

commit 2ac55d5e5ec9ad0a07e194f0eaca865fe5aa3c40
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu Oct 17 15:25:36 2019 +0200

    mmc: core: Re-work HW reset for SDIO cards
    
    It have turned out that it's not a good idea to unconditionally do a power
    cycle and then to re-initialize the SDIO card, as currently done through
    mmc_hw_reset() -> mmc_sdio_hw_reset(). This because there may be multiple
    SDIO func drivers probed, who also shares the same SDIO card.
    
    To address these scenarios, one may be tempted to use a notification
    mechanism, as to allow the core to inform each of the probed func drivers,
    about an ongoing HW reset. However, supporting such an operation from the
    func driver point of view, may not be entirely trivial.
    
    Therefore, let's use a more simplistic approach to solve the problem, by
    instead forcing the card to be removed and re-detected, via scheduling a
    rescan-work. In this way, we can rely on existing infrastructure, as the
    func driver's ->remove() and ->probe() callbacks, becomes invoked to deal
    with the cleanup and the re-initialization.
    
    This solution may be considered as rather heavy, especially if a func
    driver doesn't share its card with other func drivers. To address this,
    let's keep the current immediate HW reset option as well, but run it only
    when there is one func driver probed for the card.
    
    Finally, to allow the caller of mmc_hw_reset(), to understand if the reset
    is being asynchronously managed from a scheduled work, it returns 1
    (propagated from mmc_sdio_hw_reset()). If the HW reset is executed
    successfully and synchronously it returns 0, which maintains the existing
    behaviour.
    
    Reviewed-by: Douglas Anderson <dianders@chromium.org>
    Tested-by: Douglas Anderson <dianders@chromium.org>
    Cc: stable@vger.kernel.org # v5.4+
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 26cabd53ddc5..ebb387aa5158 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -1048,9 +1048,35 @@ static int mmc_sdio_runtime_resume(struct mmc_host *host)
 	return ret;
 }
 
+/*
+ * SDIO HW reset
+ *
+ * Returns 0 if the HW reset was executed synchronously, returns 1 if the HW
+ * reset was asynchronously scheduled, else a negative error code.
+ */
 static int mmc_sdio_hw_reset(struct mmc_host *host)
 {
-	mmc_power_cycle(host, host->card->ocr);
+	struct mmc_card *card = host->card;
+
+	/*
+	 * In case the card is shared among multiple func drivers, reset the
+	 * card through a rescan work. In this way it will be removed and
+	 * re-detected, thus all func drivers becomes informed about it.
+	 */
+	if (atomic_read(&card->sdio_funcs_probed) > 1) {
+		if (mmc_card_removed(card))
+			return 1;
+		host->rescan_entered = 0;
+		mmc_card_set_removed(card);
+		_mmc_detect_change(host, 0, false);
+		return 1;
+	}
+
+	/*
+	 * A single func driver has been probed, then let's skip the heavy
+	 * hotplug dance above and execute the reset immediately.
+	 */
+	mmc_power_cycle(host, card->ocr);
 	return mmc_sdio_reinit_card(host);
 }
 

commit 51133850bce2a9e5060c6931ee58ceb685578dbf
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Sun Sep 8 12:12:33 2019 +0200

    mmc: core: Fixup processing of SDIO IRQs during system suspend/resume
    
    System suspend/resume of SDIO cards, with SDIO IRQs enabled and when using
    MMC_CAP2_SDIO_IRQ_NOTHREAD is unfortunate still suffering from a fragile
    behaviour. Some problems have been taken care of so far, but more issues
    remains.
    
    For example, calling the ->ack_sdio_irq() callback to let host drivers
    re-enable the SDIO IRQs is a bad idea, unless the IRQ have been consumed,
    which may not be the case during system suspend/resume. This may lead to
    that a host driver re-signals the same SDIO IRQ over and over again,
    causing a storm of IRQs and gives a ping-pong effect towards the
    sdio_irq_work().
    
    Moreover, calling the ->enable_sdio_irq() callback at system resume to
    re-enable already enabled SDIO IRQs for the host, causes the runtime PM
    count for some host drivers to become in-balanced. This then leads to the
    host to remain runtime resumed, no matter if it's needed or not.
    
    To fix these problems, let's check if process_sdio_pending_irqs() actually
    consumed the SDIO IRQ, before we continue to ack the IRQ by invoking the
    ->ack_sdio_irq() callback.
    
    Additionally, there should be no need to re-enable SDIO IRQs as the host
    driver already knows if they were enabled at system suspend, thus also
    whether it needs to re-enable them at system resume. For this reason, drop
    the call to ->enable_sdio_irq() during system resume.
    
    In regards to these changes there is yet another issue, which is when there
    is an SDIO IRQ being signaled by the host driver, but after the SDIO card
    has been system suspended. Currently these IRQs are just thrown away, while
    we should at least make sure to try to consume them when the SDIO card has
    been system resumed. Fix this by queueing a sdio_irq_work() after we system
    resumed the SDIO card.
    
    Tested-by: Matthias Kaehlcke <mka@chromium.org>
    Reviewed-by: Matthias Kaehlcke <mka@chromium.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Douglas Anderson <dianders@chromium.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index c557f1519b77..26cabd53ddc5 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -1015,7 +1015,7 @@ static int mmc_sdio_resume(struct mmc_host *host)
 		if (!(host->caps2 & MMC_CAP2_SDIO_IRQ_NOTHREAD))
 			wake_up_process(host->sdio_irq_thread);
 		else if (host->caps & MMC_CAP_SDIO_IRQ)
-			host->ops->enable_sdio_irq(host, 1);
+			queue_delayed_work(system_wq, &host->sdio_irq_work, 0);
 	}
 
 out:

commit c5d3e8fa1a1bf28ac9997421fd18fcbecef941bd
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Sun Sep 8 12:12:32 2019 +0200

    mmc: core: WARN if SDIO IRQs are enabled for non-powered card in suspend
    
    To make sure SDIO func drivers behaves correctly during system
    suspend/resume, let add a WARN_ON in case the condition is a non-powered
    SDIO card and there are some SDIO IRQs still being claimed.
    
    Tested-by: Matthias Kaehlcke <mka@chromium.org>
    Reviewed-by: Matthias Kaehlcke <mka@chromium.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 8dd8fc32ecca..c557f1519b77 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -951,6 +951,8 @@ static int mmc_sdio_pre_suspend(struct mmc_host *host)
  */
 static int mmc_sdio_suspend(struct mmc_host *host)
 {
+	WARN_ON(host->sdio_irqs && !mmc_card_keep_power(host));
+
 	/* Prevent processing of SDIO IRQs in suspended state. */
 	mmc_card_set_suspended(host->card);
 	cancel_delayed_work_sync(&host->sdio_irq_work);

commit 4aaaf3ab150947557345aedc178dac4f5c10cc87
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Tue Jun 18 01:20:50 2019 +0200

    mmc: sdio: Drop unused in-parameter from mmc_sdio_init_card()
    
    The "powered_resume" in-parameter to mmc_sdio_init_card() has now become
    redundant as all callers set it to 0. Therefore let's just drop it.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Douglas Anderson <dianders@chromium.org>
    Tested-by: Douglas Anderson <dianders@chromium.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 0bf603670f61..8dd8fc32ecca 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -559,7 +559,7 @@ static void mmc_sdio_resend_if_cond(struct mmc_host *host,
  * we're trying to reinitialise.
  */
 static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
-			      struct mmc_card *oldcard, int powered_resume)
+			      struct mmc_card *oldcard)
 {
 	struct mmc_card *card;
 	int err;
@@ -582,11 +582,9 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 	/*
 	 * Inform the card of the voltage
 	 */
-	if (!powered_resume) {
-		err = mmc_send_io_op_cond(host, ocr, &rocr);
-		if (err)
-			goto err;
-	}
+	err = mmc_send_io_op_cond(host, ocr, &rocr);
+	if (err)
+		goto err;
 
 	/*
 	 * For SPI, enable CRC as appropriate.
@@ -645,7 +643,7 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 	 * try to init uhs card. sdio_read_cccr will take over this task
 	 * to make sure which speed mode should work.
 	 */
-	if (!powered_resume && (rocr & ocr & R4_18V_PRESENT)) {
+	if (rocr & ocr & R4_18V_PRESENT) {
 		err = mmc_set_uhs_voltage(host, ocr_card);
 		if (err == -EAGAIN) {
 			mmc_sdio_resend_if_cond(host, card);
@@ -659,7 +657,7 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 	/*
 	 * For native busses:  set card RCA and quit open drain mode.
 	 */
-	if (!powered_resume && !mmc_host_is_spi(host)) {
+	if (!mmc_host_is_spi(host)) {
 		err = mmc_send_relative_addr(host, &card->rca);
 		if (err)
 			goto remove;
@@ -687,7 +685,7 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 	/*
 	 * Select card, as all following commands rely on that.
 	 */
-	if (!powered_resume && !mmc_host_is_spi(host)) {
+	if (!mmc_host_is_spi(host)) {
 		err = mmc_select_card(card);
 		if (err)
 			goto remove;
@@ -845,7 +843,7 @@ static int mmc_sdio_reinit_card(struct mmc_host *host)
 	if (ret)
 		return ret;
 
-	return mmc_sdio_init_card(host, host->card->ocr, host->card, 0);
+	return mmc_sdio_init_card(host, host->card->ocr, host->card);
 }
 
 /*
@@ -1113,7 +1111,7 @@ int mmc_attach_sdio(struct mmc_host *host)
 	/*
 	 * Detect and init the card.
 	 */
-	err = mmc_sdio_init_card(host, rocr, NULL, 0);
+	err = mmc_sdio_init_card(host, rocr, NULL);
 	if (err)
 		goto err;
 

commit 3c30e73977e5d1a14a2969cfebcca2655a29b40a
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Tue Jun 18 01:13:02 2019 +0200

    mmc: sdio: Drop unused in-parameter to mmc_sdio_reinit_card()
    
    The "powered_resume" in-parameter to mmc_sdio_reinit_card() has now become
    redundant as all callers set it to 0. Therefore let's just drop it.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Douglas Anderson <dianders@chromium.org>
    Tested-by: Douglas Anderson <dianders@chromium.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 945416c53b56..0bf603670f61 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -816,7 +816,7 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 	return err;
 }
 
-static int mmc_sdio_reinit_card(struct mmc_host *host, bool powered_resume)
+static int mmc_sdio_reinit_card(struct mmc_host *host)
 {
 	int ret;
 
@@ -845,8 +845,7 @@ static int mmc_sdio_reinit_card(struct mmc_host *host, bool powered_resume)
 	if (ret)
 		return ret;
 
-	return mmc_sdio_init_card(host, host->card->ocr, host->card,
-				  powered_resume);
+	return mmc_sdio_init_card(host, host->card->ocr, host->card, 0);
 }
 
 /*
@@ -1000,7 +999,7 @@ static int mmc_sdio_resume(struct mmc_host *host)
 			pm_runtime_set_active(&host->card->dev);
 			pm_runtime_enable(&host->card->dev);
 		}
-		err = mmc_sdio_reinit_card(host, 0);
+		err = mmc_sdio_reinit_card(host);
 	} else if (mmc_card_wake_sdio_irq(host)) {
 		/* We may have switched to 1-bit mode during suspend */
 		err = sdio_enable_4bit_bus(host->card);
@@ -1026,11 +1025,6 @@ static int mmc_sdio_resume(struct mmc_host *host)
 	return err;
 }
 
-static int mmc_sdio_power_restore(struct mmc_host *host)
-{
-	return mmc_sdio_reinit_card(host, 0);
-}
-
 static int mmc_sdio_runtime_suspend(struct mmc_host *host)
 {
 	/* No references to the card, cut the power to it. */
@@ -1048,7 +1042,7 @@ static int mmc_sdio_runtime_resume(struct mmc_host *host)
 	/* Restore power and re-initialize. */
 	mmc_claim_host(host);
 	mmc_power_up(host, host->card->ocr);
-	ret = mmc_sdio_power_restore(host);
+	ret = mmc_sdio_reinit_card(host);
 	mmc_release_host(host);
 
 	return ret;
@@ -1057,7 +1051,7 @@ static int mmc_sdio_runtime_resume(struct mmc_host *host)
 static int mmc_sdio_hw_reset(struct mmc_host *host)
 {
 	mmc_power_cycle(host, host->card->ocr);
-	return mmc_sdio_power_restore(host);
+	return mmc_sdio_reinit_card(host);
 }
 
 static int mmc_sdio_sw_reset(struct mmc_host *host)
@@ -1069,7 +1063,7 @@ static int mmc_sdio_sw_reset(struct mmc_host *host)
 	mmc_set_initial_state(host);
 	mmc_set_initial_signal_voltage(host);
 
-	return mmc_sdio_reinit_card(host, 0);
+	return mmc_sdio_reinit_card(host);
 }
 
 static const struct mmc_bus_ops mmc_sdio_ops = {

commit 6ebc581c3f9e6fd11a1c9da492a5e05bbe96885a
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Tue Jun 18 00:52:59 2019 +0200

    mmc: sdio: Don't re-initialize powered-on removable SDIO cards at resume
    
    It looks like the original idea behind always doing a re-initialization of
    a removable SDIO card during system resume in mmc_sdio_resume(), is to try
    to play safe to detect whether the card has been removed.
    
    However, this seems like a really a bad idea as it will most likely screw
    things up, especially when the card is expected to remain powered on during
    system suspend by the SDIO func driver.
    
    Let's fix this, simply by trusting that the detect work checks if the card
    is alive and inserted, which is being scheduled at the PM_POST_SUSPEND
    notification anyway.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Tested-by: Douglas Anderson <dianders@chromium.org>
    Reviewed-by: Douglas Anderson <dianders@chromium.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index a9bfcae8db5b..945416c53b56 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -982,7 +982,11 @@ static int mmc_sdio_resume(struct mmc_host *host)
 	/* Basic card reinitialization. */
 	mmc_claim_host(host);
 
-	/* Restore power if needed */
+	/*
+	 * Restore power and reinitialize the card when needed. Note that a
+	 * removable card is checked from a detect work later on in the resume
+	 * process.
+	 */
 	if (!mmc_card_keep_power(host)) {
 		mmc_power_up(host, host->card->ocr);
 		/*
@@ -996,12 +1000,8 @@ static int mmc_sdio_resume(struct mmc_host *host)
 			pm_runtime_set_active(&host->card->dev);
 			pm_runtime_enable(&host->card->dev);
 		}
-	}
-
-	/* No need to reinitialize powered-resumed nonremovable cards */
-	if (mmc_card_is_removable(host) || !mmc_card_keep_power(host)) {
-		err = mmc_sdio_reinit_card(host, mmc_card_keep_power(host));
-	} else if (mmc_card_keep_power(host) && mmc_card_wake_sdio_irq(host)) {
+		err = mmc_sdio_reinit_card(host, 0);
+	} else if (mmc_card_wake_sdio_irq(host)) {
 		/* We may have switched to 1-bit mode during suspend */
 		err = sdio_enable_4bit_bus(host->card);
 	}

commit 7fbbe725378d62c30a076742a60a7e1812a2515a
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Mon Jun 17 23:51:31 2019 +0200

    mmc: sdio: Drop powered-on re-init at runtime resume and HW reset
    
    To use the so called powered-on re-initialization of an SDIO card, the
    power to the card must obviously have stayed on. If not, the initialization
    will simply fail.
    
    In the runtime suspend case, the card is always powered off. Hence, let's
    drop the support for powered-on re-initialization during runtime resume, as
    it doesn't make sense.
    
    Moreover, during a HW reset, the point is to cut the power to the card and
    then do fresh re-initialization. Therefore drop the support for powered-on
    re-initialization during HW reset.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Fixes: ca8971ca5753 ("mmc: dw_mmc: Prevent runtime PM suspend when SDIO IRQs are enabled")
    Tested-by: Douglas Anderson <dianders@chromium.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 29f86c1e9923..a9bfcae8db5b 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -1028,13 +1028,7 @@ static int mmc_sdio_resume(struct mmc_host *host)
 
 static int mmc_sdio_power_restore(struct mmc_host *host)
 {
-	int ret;
-
-	ret = mmc_sdio_reinit_card(host, mmc_card_keep_power(host));
-	if (!ret && host->sdio_irqs)
-		mmc_signal_sdio_irq(host);
-
-	return ret;
+	return mmc_sdio_reinit_card(host, 0);
 }
 
 static int mmc_sdio_runtime_suspend(struct mmc_host *host)

commit ee550947a0d696f7ddfe88b204d4eae7f879b583
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Mon Jun 17 23:41:15 2019 +0200

    mmc: sdio: Move comment about re-initialization to mmc_sdio_reinit_card()
    
    The comment in mmc_sdio_power_restore() belongs in mmc_sdio_reinit_card(),
    which was created during a previous commit that re-factored some code. Fix
    this by moving the comment into mmc_sdio_reinit_card().
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Douglas Anderson <dianders@chromium.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index b3303b7d9956..29f86c1e9923 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -820,6 +820,23 @@ static int mmc_sdio_reinit_card(struct mmc_host *host, bool powered_resume)
 {
 	int ret;
 
+	/*
+	 * Reset the card by performing the same steps that are taken by
+	 * mmc_rescan_try_freq() and mmc_attach_sdio() during a "normal" probe.
+	 *
+	 * sdio_reset() is technically not needed. Having just powered up the
+	 * hardware, it should already be in reset state. However, some
+	 * platforms (such as SD8686 on OLPC) do not instantly cut power,
+	 * meaning that a reset is required when restoring power soon after
+	 * powering off. It is harmless in other cases.
+	 *
+	 * The CMD5 reset (mmc_send_io_op_cond()), according to the SDIO spec,
+	 * is not necessary for non-removable cards. However, it is required
+	 * for OLPC SD8686 (which expects a [CMD5,5,3,7] init sequence), and
+	 * harmless in other situations.
+	 *
+	 */
+
 	sdio_reset(host);
 	mmc_go_idle(host);
 	mmc_send_if_cond(host, host->card->ocr);
@@ -1013,23 +1030,6 @@ static int mmc_sdio_power_restore(struct mmc_host *host)
 {
 	int ret;
 
-	/*
-	 * Reset the card by performing the same steps that are taken by
-	 * mmc_rescan_try_freq() and mmc_attach_sdio() during a "normal" probe.
-	 *
-	 * sdio_reset() is technically not needed. Having just powered up the
-	 * hardware, it should already be in reset state. However, some
-	 * platforms (such as SD8686 on OLPC) do not instantly cut power,
-	 * meaning that a reset is required when restoring power soon after
-	 * powering off. It is harmless in other cases.
-	 *
-	 * The CMD5 reset (mmc_send_io_op_cond()), according to the SDIO spec,
-	 * is not necessary for non-removable cards. However, it is required
-	 * for OLPC SD8686 (which expects a [CMD5,5,3,7] init sequence), and
-	 * harmless in other situations.
-	 *
-	 */
-
 	ret = mmc_sdio_reinit_card(host, mmc_card_keep_power(host));
 	if (!ret && host->sdio_irqs)
 		mmc_signal_sdio_irq(host);

commit cd23042d05468ab2e66e0298b46ee90a5f8d9a74
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Tue Jun 11 17:44:32 2019 +0200

    mmc: sdio: Drop mmc_claim|release_host() in mmc_sdio_power_restore()
    
    The function mmc_sdio_power_restore() is called either from
    mmc_sdio_runtime_resume() or from mmc_sdio_hw_reset(). Both callers either
    claims/releases the host or require its callers to do so. Therefore let's
    drop the redundant calls to mmc_claim|release_host() in
    mmc_sdio_power_restore().
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Douglas Anderson <dianders@chromium.org>
    Tested-by: Douglas Anderson <dianders@chromium.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 712a7742765e..b3303b7d9956 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -1030,14 +1030,10 @@ static int mmc_sdio_power_restore(struct mmc_host *host)
 	 *
 	 */
 
-	mmc_claim_host(host);
-
 	ret = mmc_sdio_reinit_card(host, mmc_card_keep_power(host));
 	if (!ret && host->sdio_irqs)
 		mmc_signal_sdio_irq(host);
 
-	mmc_release_host(host);
-
 	return ret;
 }
 

commit 83293386bc95cf5e9f0c0175794455835bd1cb4a
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Tue Jun 18 14:05:17 2019 +0200

    mmc: core: Prevent processing SDIO IRQs when the card is suspended
    
    Processing of SDIO IRQs must obviously be prevented while the card is
    system suspended, otherwise we may end up trying to communicate with an
    uninitialized SDIO card.
    
    Reports throughout the years shows that this is not only a theoretical
    problem, but a real issue. So, let's finally fix this problem, by keeping
    track of the state for the card and bail out before processing the SDIO
    IRQ, in case the card is suspended.
    
    Cc: stable@vger.kernel.org
    Reported-by: Douglas Anderson <dianders@chromium.org>
    Tested-by: Douglas Anderson <dianders@chromium.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index d1aa1c7577bb..712a7742765e 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -937,6 +937,10 @@ static int mmc_sdio_pre_suspend(struct mmc_host *host)
  */
 static int mmc_sdio_suspend(struct mmc_host *host)
 {
+	/* Prevent processing of SDIO IRQs in suspended state. */
+	mmc_card_set_suspended(host->card);
+	cancel_delayed_work_sync(&host->sdio_irq_work);
+
 	mmc_claim_host(host);
 
 	if (mmc_card_keep_power(host) && mmc_card_wake_sdio_irq(host))
@@ -985,13 +989,20 @@ static int mmc_sdio_resume(struct mmc_host *host)
 		err = sdio_enable_4bit_bus(host->card);
 	}
 
-	if (!err && host->sdio_irqs) {
+	if (err)
+		goto out;
+
+	/* Allow SDIO IRQs to be processed again. */
+	mmc_card_clr_suspended(host->card);
+
+	if (host->sdio_irqs) {
 		if (!(host->caps2 & MMC_CAP2_SDIO_IRQ_NOTHREAD))
 			wake_up_process(host->sdio_irq_thread);
 		else if (host->caps & MMC_CAP_SDIO_IRQ)
 			host->ops->enable_sdio_irq(host, 1);
 	}
 
+out:
 	mmc_release_host(host);
 
 	host->pm_flags &= ~MMC_PM_KEEP_POWER;

commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 6718fc8bb40f..d1aa1c7577bb 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -1,12 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *  linux/drivers/mmc/sdio.c
  *
  *  Copyright 2006-2007 Pierre Ossman
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or (at
- * your option) any later version.
  */
 
 #include <linux/err.h>

commit 099b648116090acf0c65c8df867aa1cb42476f3b
Author: hongjiefang <hongjiefang@asrmicro.com>
Date:   Thu Feb 28 14:08:28 2019 +0800

    mmc: core: Add a debug print when the card may have been replaced
    
    If the card was removed in suspended state and a new one was inserted,
    print a debug log when the check detects that it's not the old card.
    
    Signed-off-by: hongjiefang <hongjiefang@asrmicro.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index d8e17ea6126d..6718fc8bb40f 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -617,6 +617,8 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 		if (oldcard && (oldcard->type != MMC_TYPE_SD_COMBO ||
 		    memcmp(card->raw_cid, oldcard->raw_cid, sizeof(card->raw_cid)) != 0)) {
 			mmc_remove_card(card);
+			pr_debug("%s: Perhaps the card was replaced\n",
+				mmc_hostname(host));
 			return -ENOENT;
 		}
 	} else {
@@ -624,6 +626,8 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 
 		if (oldcard && oldcard->type != MMC_TYPE_SDIO) {
 			mmc_remove_card(card);
+			pr_debug("%s: Perhaps the card was replaced\n",
+				mmc_hostname(host));
 			return -ENOENT;
 		}
 	}
@@ -736,8 +740,11 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 		int same = (card->cis.vendor == oldcard->cis.vendor &&
 			    card->cis.device == oldcard->cis.device);
 		mmc_remove_card(card);
-		if (!same)
+		if (!same) {
+			pr_debug("%s: Perhaps the card was replaced\n",
+				mmc_hostname(host));
 			return -ENOENT;
+		}
 
 		card = oldcard;
 	}

commit 29772f8a73d88a5de648177d9d822055ab7d1ba6
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Tue Jun 26 16:51:31 2018 +0200

    mmc: core: Drop the unused mmc_power_save|restore_host()
    
    The last user of mmc_power_save|restore_host() APIs is gone, hence let's
    drop them. Drop also the corresponding bus_ops callback,
    ->power_save|restore() as those becomes redundant.
    
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Eyal Reizer <eyalreizer@gmail.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index a86490dbca70..d8e17ea6126d 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -1076,7 +1076,6 @@ static const struct mmc_bus_ops mmc_sdio_ops = {
 	.resume = mmc_sdio_resume,
 	.runtime_suspend = mmc_sdio_runtime_suspend,
 	.runtime_resume = mmc_sdio_runtime_resume,
-	.power_restore = mmc_sdio_power_restore,
 	.alive = mmc_sdio_alive,
 	.hw_reset = mmc_sdio_hw_reset,
 	.sw_reset = mmc_sdio_sw_reset,

commit 7405df4c79cd7b4204c5b4b5af2b1ad362ea85ad
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu Apr 5 16:31:25 2018 +0200

    mmc: core: Implement ->sw_reset bus ops for SDIO
    
    Let's implement the ->sw_reset() bus ops to allow SDIO func drivers, in
    particular, to make a SW reset without doing a full power cycle of the SDIO
    card.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Tested-by: Quentin Schulz <quentin.schulz@bootlin.com>
    Reviewed-by: Shawn Lin <shawn.lin@rock-chips.com>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 362737052f84..a86490dbca70 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -1056,6 +1056,18 @@ static int mmc_sdio_hw_reset(struct mmc_host *host)
 	return mmc_sdio_power_restore(host);
 }
 
+static int mmc_sdio_sw_reset(struct mmc_host *host)
+{
+	mmc_set_clock(host, host->f_init);
+	sdio_reset(host);
+	mmc_go_idle(host);
+
+	mmc_set_initial_state(host);
+	mmc_set_initial_signal_voltage(host);
+
+	return mmc_sdio_reinit_card(host, 0);
+}
+
 static const struct mmc_bus_ops mmc_sdio_ops = {
 	.remove = mmc_sdio_remove,
 	.detect = mmc_sdio_detect,
@@ -1067,6 +1079,7 @@ static const struct mmc_bus_ops mmc_sdio_ops = {
 	.power_restore = mmc_sdio_power_restore,
 	.alive = mmc_sdio_alive,
 	.hw_reset = mmc_sdio_hw_reset,
+	.sw_reset = mmc_sdio_sw_reset,
 };
 
 

commit 3a3db6030b64ceb4b4e41a6811168c5d90a9f7f8
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu Apr 5 13:24:43 2018 +0200

    mmc: core: Rename ->reset() bus ops to ->hw_reset()
    
    The bus ops ->reset() executes a full HW reset of the card, as the calling
    function mmc_hw_reset() also indicates by its name. Let's convert to follow
    the similar names, for both the bus ops callback and for the corresponding
    bus ops functions, as to clarify the purpose of code.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Tested-by: Quentin Schulz <quentin.schulz@bootlin.com>
    Reviewed-by: Shawn Lin <shawn.lin@rock-chips.com>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 34d69d0b5bf8..362737052f84 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -1050,7 +1050,7 @@ static int mmc_sdio_runtime_resume(struct mmc_host *host)
 	return ret;
 }
 
-static int mmc_sdio_reset(struct mmc_host *host)
+static int mmc_sdio_hw_reset(struct mmc_host *host)
 {
 	mmc_power_cycle(host, host->card->ocr);
 	return mmc_sdio_power_restore(host);
@@ -1066,7 +1066,7 @@ static const struct mmc_bus_ops mmc_sdio_ops = {
 	.runtime_resume = mmc_sdio_runtime_resume,
 	.power_restore = mmc_sdio_power_restore,
 	.alive = mmc_sdio_alive,
-	.reset = mmc_sdio_reset,
+	.hw_reset = mmc_sdio_hw_reset,
 };
 
 

commit fb09f44e290b1775fbeadb4289dbcfc2f954b0d2
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Mon May 11 16:46:47 2015 +0200

    mmc: core: Re-factor some code for SDIO re-initialization
    
    The mmc_sdio_init_card() function has a couple of callers. In the
    re-initialization cases, some additional reset commands are issued before
    mmc_sdio_init_card() is called. As these additional reset commands are the
    same, let's move these into a new static function, mmc_sdio_reinit_card()
    and call mmc_sdio_init_card() from there. In this way we avoid the open
    coding.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Tested-by: Quentin Schulz <quentin.schulz@bootlin.com>
    Reviewed-by: Shawn Lin <shawn.lin@rock-chips.com>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 87e53a721a10..34d69d0b5bf8 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -813,6 +813,22 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 	return err;
 }
 
+static int mmc_sdio_reinit_card(struct mmc_host *host, bool powered_resume)
+{
+	int ret;
+
+	sdio_reset(host);
+	mmc_go_idle(host);
+	mmc_send_if_cond(host, host->card->ocr);
+
+	ret = mmc_send_io_op_cond(host, 0, NULL);
+	if (ret)
+		return ret;
+
+	return mmc_sdio_init_card(host, host->card->ocr, host->card,
+				  powered_resume);
+}
+
 /*
  * Host is being removed. Free up the current card.
  */
@@ -960,14 +976,7 @@ static int mmc_sdio_resume(struct mmc_host *host)
 
 	/* No need to reinitialize powered-resumed nonremovable cards */
 	if (mmc_card_is_removable(host) || !mmc_card_keep_power(host)) {
-		sdio_reset(host);
-		mmc_go_idle(host);
-		mmc_send_if_cond(host, host->card->ocr);
-		err = mmc_send_io_op_cond(host, 0, NULL);
-		if (!err)
-			err = mmc_sdio_init_card(host, host->card->ocr,
-						 host->card,
-						 mmc_card_keep_power(host));
+		err = mmc_sdio_reinit_card(host, mmc_card_keep_power(host));
 	} else if (mmc_card_keep_power(host) && mmc_card_wake_sdio_irq(host)) {
 		/* We may have switched to 1-bit mode during suspend */
 		err = sdio_enable_4bit_bus(host->card);
@@ -990,8 +999,6 @@ static int mmc_sdio_power_restore(struct mmc_host *host)
 {
 	int ret;
 
-	mmc_claim_host(host);
-
 	/*
 	 * Reset the card by performing the same steps that are taken by
 	 * mmc_rescan_try_freq() and mmc_attach_sdio() during a "normal" probe.
@@ -1009,20 +1016,12 @@ static int mmc_sdio_power_restore(struct mmc_host *host)
 	 *
 	 */
 
-	sdio_reset(host);
-	mmc_go_idle(host);
-	mmc_send_if_cond(host, host->card->ocr);
-
-	ret = mmc_send_io_op_cond(host, 0, NULL);
-	if (ret)
-		goto out;
+	mmc_claim_host(host);
 
-	ret = mmc_sdio_init_card(host, host->card->ocr, host->card,
-				mmc_card_keep_power(host));
+	ret = mmc_sdio_reinit_card(host, mmc_card_keep_power(host));
 	if (!ret && host->sdio_irqs)
 		mmc_signal_sdio_irq(host);
 
-out:
 	mmc_release_host(host);
 
 	return ret;

commit 247cfe53557524a94dd1001d19e5aa50bd5aca81
Author: Kyle Roeschley <kyle.roeschley@ni.com>
Date:   Fri Apr 13 16:54:57 2018 -0500

    mmc: core: Add capability to avoid 3.3V signaling
    
    Some SD host controllers cannot handle extended use of 3.3V signaling.
    To accommodate these controllers, add a capability that requires us to
    negotiate the voltage down from 3.3V during card initialization.
    
    Signed-off-by: Kyle Roeschley <kyle.roeschley@ni.com>
    Signed-off-by: Jennifer Dahm <jennifer.dahm@ni.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 24b510b743da..87e53a721a10 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -792,6 +792,14 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 		if (err)
 			goto remove;
 	}
+
+	if (host->caps2 & MMC_CAP2_AVOID_3_3V &&
+	    host->ios.signal_voltage == MMC_SIGNAL_VOLTAGE_330) {
+		pr_err("%s: Host failed to negotiate down from 3.3V\n",
+			mmc_hostname(host));
+		err = -EINVAL;
+		goto remove;
+	}
 finish:
 	if (!oldcard)
 		host->card = card;

commit ebc5a1bf4f2afc2f2b348320dcfb45a8c0ac3de5
Author: harish_kandiga@mentor.com <harish_kandiga@mentor.com>
Date:   Tue Apr 10 12:30:31 2018 +0530

    mmc: core: Add a new quirk for limiting clock rate
    
    This patch adds a quirk to limit clock rate which
    can be used to reduce the SDIO clock rate for some
    chips with broken UHS.
    
    Signed-off-by: Harish Jenny K N <harish_kandiga@mentor.com>
    Reviewed-by: Shawn Lin <shawn.lin@rock-chips.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index c599a628a387..24b510b743da 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -444,6 +444,7 @@ static int sdio_set_bus_speed_mode(struct mmc_card *card)
 	unsigned int bus_speed, timing;
 	int err;
 	unsigned char speed;
+	unsigned int max_rate;
 
 	/*
 	 * If the host doesn't support any of the UHS-I modes, fallback on
@@ -500,9 +501,12 @@ static int sdio_set_bus_speed_mode(struct mmc_card *card)
 	if (err)
 		return err;
 
+	max_rate = min_not_zero(card->quirk_max_rate,
+				card->sw_caps.uhs_max_dtr);
+
 	if (bus_speed) {
 		mmc_set_timing(card->host, timing);
-		mmc_set_clock(card->host, card->sw_caps.uhs_max_dtr);
+		mmc_set_clock(card->host, max_rate);
 	}
 
 	return 0;

commit 1e178270dfcf2b576b0060b382836219dcda83b5
Author: Shawn Lin <shawn.lin@rock-chips.com>
Date:   Tue Feb 27 09:26:34 2018 +0800

    mmc: sdio: Check the return value of sdio_enable_4bit_bus
    
    Since we could move card->host->caps & MMC_CAP_4_BIT_DATA
    ahead of mmc_sdio_init_uhs_card, in mmc_host_uhs(). So there
    we could save this bit to check that. Also, if the process of
    sdio_enable_4bit_bus goes wrong, we should bails out early.
    
    Signed-off-by: Shawn Lin <shawn.lin@rock-chips.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index cc43687ca241..c599a628a387 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -518,11 +518,10 @@ static int mmc_sdio_init_uhs_card(struct mmc_card *card)
 	if (!card->scr.sda_spec3)
 		return 0;
 
-	/*
-	 * Switch to wider bus (if supported).
-	 */
-	if (card->host->caps & MMC_CAP_4_BIT_DATA)
-		err = sdio_enable_4bit_bus(card);
+	/* Switch to wider bus */
+	err = sdio_enable_4bit_bus(card);
+	if (err)
+		goto out;
 
 	/* Set the driver strength for the card */
 	sdio_select_driver_type(card);

commit 4760257cb54e29e9a90e0ce849f4efcd67718816
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Fri Jun 9 15:27:18 2017 +0300

    mmc: sdio: Keep card runtime resumed while adding function devices
    
    Drivers core will runtime suspend a device with no driver. That means the
    SDIO card will be runtime suspended as soon as it is added. It is then
    runtime resumed to add each function. That is entirely pointless, so add
    pm runtime get/put to keep the SDIO card runtime resumed until the function
    devices have been added.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index f077fc8219d0..cc43687ca241 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -1103,6 +1103,12 @@ int mmc_attach_sdio(struct mmc_host *host)
 	 * Enable runtime PM only if supported by host+card+board
 	 */
 	if (host->caps & MMC_CAP_POWER_OFF_CARD) {
+		/*
+		 * Do not allow runtime suspend until after SDIO function
+		 * devices are added.
+		 */
+		pm_runtime_get_noresume(&card->dev);
+
 		/*
 		 * Let runtime PM core know our card is active
 		 */
@@ -1155,6 +1161,9 @@ int mmc_attach_sdio(struct mmc_host *host)
 			goto remove_added;
 	}
 
+	if (host->caps & MMC_CAP_POWER_OFF_CARD)
+		pm_runtime_put(&card->dev);
+
 	mmc_claim_host(host);
 	return 0;
 
@@ -1164,7 +1173,9 @@ int mmc_attach_sdio(struct mmc_host *host)
 remove_added:
 	/*
 	 * The devices are being deleted so it is not necessary to disable
-	 * runtime PM.
+	 * runtime PM. Similarly we also don't pm_runtime_put() the SDIO card
+	 * because it needs to be active to remove any function devices that
+	 * were probed, and after that it gets deleted.
 	 */
 	mmc_sdio_remove(host);
 	mmc_claim_host(host);

commit 82e7edc216f1a066da10f224ae2e4cd83e53fc13
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Fri Jun 9 15:27:17 2017 +0300

    mmc: sdio: Tidy error path in mmc_attach_sdio()
    
    The error path deletes the device by calling mmc_sdio_remove() which must
    be called without the host claimed. Simplify the error path so it does just
    that and add a comment about why we don't disable runtime PM.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index fae732c870a9..f077fc8219d0 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -1159,15 +1159,14 @@ int mmc_attach_sdio(struct mmc_host *host)
 	return 0;
 
 
-remove_added:
-	/* Remove without lock if the device has been added. */
-	mmc_sdio_remove(host);
-	mmc_claim_host(host);
 remove:
-	/* And with lock if it hasn't been added. */
 	mmc_release_host(host);
-	if (host->card)
-		mmc_sdio_remove(host);
+remove_added:
+	/*
+	 * The devices are being deleted so it is not necessary to disable
+	 * runtime PM.
+	 */
+	mmc_sdio_remove(host);
 	mmc_claim_host(host);
 err:
 	mmc_detach_bus(host);

commit 1144c1e4ddab9339e262e2702744e8f5c6220824
Author: Shawn Lin <shawn.lin@rock-chips.com>
Date:   Wed Feb 15 16:35:30 2017 +0800

    mmc: core: improve the quirks for sdio devices
    
    Rename mmc_fixup_methods to sdio_fixup_methods to better
    reflect that it's for sdio devices. So we could also pass
    on it from sdio card's probe sequence just like what we do
    for eMMC and block there.
    
    Signed-off-by: Shawn Lin <shawn.lin@rock-chips.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index f092a55c5064..fae732c870a9 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -739,7 +739,7 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 		card = oldcard;
 	}
 	card->ocr = ocr_card;
-	mmc_fixup_device(card, NULL);
+	mmc_fixup_device(card, sdio_fixup_methods);
 
 	if (card->type == MMC_TYPE_SD_COMBO) {
 		err = mmc_sd_setup_card(host, card, oldcard != NULL);

commit 28fc64af63488d701184977481b263f31d856984
Author: Shawn Lin <shawn.lin@rock-chips.com>
Date:   Wed Feb 15 16:35:28 2017 +0800

    mmc: core: change quirks.c to be a header file
    
    Rename quirks.c to quirks.h, and include it for
    individual C files which need it.
    
    Signed-off-by: Shawn Lin <shawn.lin@rock-chips.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index a64a8709ec72..f092a55c5064 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -23,6 +23,7 @@
 #include "card.h"
 #include "host.h"
 #include "bus.h"
+#include "quirks.h"
 #include "sd.h"
 #include "sdio_bus.h"
 #include "mmc_ops.h"

commit 2ed573b603f78289dd1435c94597aa25a97e2b76
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Wed Jan 25 10:25:01 2017 +0100

    mmc: core: Clarify usage of mmc_set_signal_voltage()
    
    The mmc_set_signal_voltage() function is used for SD/SDIO when switching to
    1.8V for UHS mode. To clarify this let's do the following changes.
    
    - We are always providing MMC_SIGNAL_VOLTAGE_180 as the signal_voltage
      parameter to the function. Then, let's just remove the parameter as it
      serves no purpose.
    - Rename the function to mmc_set_uhs_voltage().
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Shawn Lin <shawn.lin@rock-chips.com>
    Tested-by: Jan Glauber <jglauber@cavium.com>
    Tested-by: Stefan Wahren <stefan.wahren@i2se.com>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 261c88632c43..a64a8709ec72 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -642,8 +642,7 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 	 * to make sure which speed mode should work.
 	 */
 	if (!powered_resume && (rocr & ocr & R4_18V_PRESENT)) {
-		err = mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_180,
-					ocr_card);
+		err = mmc_set_uhs_voltage(host, ocr_card);
 		if (err == -EAGAIN) {
 			mmc_sdio_resend_if_cond(host, card);
 			retries--;

commit 5857b29b96dcf208e4903ec6f20d132e6a77cac2
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri Jan 13 14:14:15 2017 +0100

    mmc: core: Move public functions from host.h to private headers
    
    A significant amount of functions are available through the public mmc
    host.h header file. Let's slim down this public mmc interface, as to
    prevent users from abusing it, by moving some of the functions to private
    mmc host.h header file.
    
    This change concentrates on moving the functions into private mmc headers,
    following changes may continue with additional clean-ups.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Reviewed-by: Shawn Lin <shawn.lin@rock-chips.com>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 5419c0dfad31..261c88632c43 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -21,6 +21,7 @@
 
 #include "core.h"
 #include "card.h"
+#include "host.h"
 #include "bus.h"
 #include "sd.h"
 #include "sdio_bus.h"

commit 4facdde11394d44b3869807841042d059f074a07
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri Jan 13 14:14:14 2017 +0100

    mmc: core: Move public functions from card.h to private headers
    
    A significant amount of functions and other definitions are available
    through the public mmc card.h header file. Let's slim down this public mmc
    interface, as to prevent users from abusing it, by moving some of the
    functions/definitions to private mmc header files.
    
    This change concentrates on moving the functions into private mmc headers,
    following changes may continue with additional clean-ups.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Reviewed-by: Shawn Lin <shawn.lin@rock-chips.com>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 6810b3a8e130..5419c0dfad31 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -20,6 +20,7 @@
 #include <linux/mmc/sdio_ids.h>
 
 #include "core.h"
+#include "card.h"
 #include "bus.h"
 #include "sd.h"
 #include "sdio_bus.h"

commit 5fc3d80ef496c3bc3e8c09f056e3586fb681de56
Author: Shawn Lin <shawn.lin@rock-chips.com>
Date:   Mon Jan 9 16:56:20 2017 +0800

    mmc: sdio: don't use rocr to check if the card could support UHS mode
    
    Per SDIO Simplified Specification V3, section 3.1.2, A host that
    supports UHS-I sets S18R to 1 in the argument of CMD5 to request a
    change of the signal voltage to 1.8V. If the card supports UHS-I and
    the current signal voltage is 3.3V, S18A is set to 1 in the R4 response.
    If the signal voltage is already 1.8V, the card sets S18A to 0 so that
    host maintains the current signal voltage. UHS-I is supported in SD mode
    and S18A is always 0 in SPI mode.
    
    For the current code, if the signaling voltage is fixed 1.8v, so
    the card will set S18A to 0 for rocr and thus we would clear the
    R4_18V_PRESENT from ocr, which make core won't try to use uhs mode.
    
    To fix it, we expect sdio_read_cccr would fail if the uhs mode won't
    work at all. Note that it's interesting that some sdio cards still
    response S18A even the voltage is fixed to 1.8v and the CMD11 will
    also accepted and finish enabling UHS mode successfully. I guess this
    is why folks didn't notice this problem. Anyway, fix it.
    
    Signed-off-by: Shawn Lin <shawn.lin@rock-chips.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index f417adc9feb1..6810b3a8e130 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -633,7 +633,11 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 	 * to switch to 1.8V signaling level.  No 1.8v signalling if
 	 * UHS mode is not enabled to maintain compatibility and some
 	 * systems that claim 1.8v signalling in fact do not support
-	 * it.
+	 * it. Per SDIO spec v3, section 3.1.2, if the voltage is already
+	 * 1.8v, the card sets S18A to 0 in the R4 response. So it will
+	 * fails to check rocr & R4_18V_PRESENT,  but we still need to
+	 * try to init uhs card. sdio_read_cccr will take over this task
+	 * to make sure which speed mode should work.
 	 */
 	if (!powered_resume && (rocr & ocr & R4_18V_PRESENT)) {
 		err = mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_180,
@@ -645,9 +649,6 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 		} else if (err) {
 			ocr &= ~R4_18V_PRESENT;
 		}
-		err = 0;
-	} else {
-		ocr &= ~R4_18V_PRESENT;
 	}
 
 	/*
@@ -704,11 +705,20 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 	}
 
 	/*
-	 * Read the common registers.
+	 * Read the common registers. Note that we should try to
+	 * validate whether UHS would work or not.
 	 */
 	err = sdio_read_cccr(card, ocr);
-	if (err)
-		goto remove;
+	if (err) {
+		mmc_sdio_resend_if_cond(host, card);
+		if (ocr & R4_18V_PRESENT) {
+			/* Retry init sequence, but without R4_18V_PRESENT. */
+			retries = 0;
+			goto try_again;
+		} else {
+			goto remove;
+		}
+	}
 
 	/*
 	 * Read the common CIS tuples.

commit 0eb51a58ad823b2081c69ec1cf165833dd11c450
Author: Shawn Lin <shawn.lin@rock-chips.com>
Date:   Mon Jan 9 16:56:19 2017 +0800

    mmc: sdio: Factor out retry init card helper function
    
    Add new helper function, mmc_sdio_resend_if_cond, to be
    reused when trying to retry the init sequence.
    
    Signed-off-by: Shawn Lin <shawn.lin@rock-chips.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index ecbc52981ba5..f417adc9feb1 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -541,6 +541,15 @@ static int mmc_sdio_init_uhs_card(struct mmc_card *card)
 	return err;
 }
 
+static void mmc_sdio_resend_if_cond(struct mmc_host *host,
+				    struct mmc_card *card)
+{
+	sdio_reset(host);
+	mmc_go_idle(host);
+	mmc_send_if_cond(host, host->ocr_avail);
+	mmc_remove_card(card);
+}
+
 /*
  * Handle the detection and initialisation of a card.
  *
@@ -630,10 +639,7 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 		err = mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_180,
 					ocr_card);
 		if (err == -EAGAIN) {
-			sdio_reset(host);
-			mmc_go_idle(host);
-			mmc_send_if_cond(host, host->ocr_avail);
-			mmc_remove_card(card);
+			mmc_sdio_resend_if_cond(host, card);
 			retries--;
 			goto try_again;
 		} else if (err) {

commit 5df0e8231f9518ee5ca3f58a0777556dd03addd6
Author: Shawn Lin <shawn.lin@rock-chips.com>
Date:   Wed Nov 2 15:24:00 2016 +0800

    mmc: core: remove BUG_ONs from sdio
    
    BUG_ONs doesn't help anything except for stop the system from
    running. If it occurs, it implies we should deploy proper error
    handling for that. So this patch is gonna discard these meaningless
    BUG_ONs and deploy error handling if needed.
    
    Signed-off-by: Shawn Lin <shawn.lin@rock-chips.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index bd44ba8116d1..ecbc52981ba5 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -63,7 +63,8 @@ static int sdio_init_func(struct mmc_card *card, unsigned int fn)
 	int ret;
 	struct sdio_func *func;
 
-	BUG_ON(fn > SDIO_MAX_FUNCS);
+	if (WARN_ON(fn > SDIO_MAX_FUNCS))
+		return -EINVAL;
 
 	func = sdio_alloc_func(card);
 	if (IS_ERR(func))
@@ -555,7 +556,6 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 	u32 rocr = 0;
 	u32 ocr_card = ocr;
 
-	BUG_ON(!host);
 	WARN_ON(!host->claimed);
 
 	/* to query card if 1.8V signalling is supported */
@@ -791,9 +791,6 @@ static void mmc_sdio_remove(struct mmc_host *host)
 {
 	int i;
 
-	BUG_ON(!host);
-	BUG_ON(!host->card);
-
 	for (i = 0;i < host->card->sdio_funcs;i++) {
 		if (host->card->sdio_func[i]) {
 			sdio_remove_func(host->card->sdio_func[i]);
@@ -820,9 +817,6 @@ static void mmc_sdio_detect(struct mmc_host *host)
 {
 	int err;
 
-	BUG_ON(!host);
-	BUG_ON(!host->card);
-
 	/* Make sure card is powered before detecting it */
 	if (host->caps & MMC_CAP_POWER_OFF_CARD) {
 		err = pm_runtime_get_sync(&host->card->dev);
@@ -916,9 +910,6 @@ static int mmc_sdio_resume(struct mmc_host *host)
 {
 	int err = 0;
 
-	BUG_ON(!host);
-	BUG_ON(!host->card);
-
 	/* Basic card reinitialization. */
 	mmc_claim_host(host);
 
@@ -970,9 +961,6 @@ static int mmc_sdio_power_restore(struct mmc_host *host)
 {
 	int ret;
 
-	BUG_ON(!host);
-	BUG_ON(!host->card);
-
 	mmc_claim_host(host);
 
 	/*
@@ -1063,7 +1051,6 @@ int mmc_attach_sdio(struct mmc_host *host)
 	u32 ocr, rocr;
 	struct mmc_card *card;
 
-	BUG_ON(!host);
 	WARN_ON(!host->claimed);
 
 	err = mmc_send_io_op_cond(host, 0, &ocr);

commit a0747eb81c1d106b1408d60452af75cd17a67621
Author: Shawn Lin <shawn.lin@rock-chips.com>
Date:   Mon Mar 14 12:41:33 2016 +0800

    mmc: core: remove redundant memset of sdio_read_cccr
    
    When initializing sdio card, we get struct mmc_card
    from mmc_alloc_card which allocates it by kzalloc. So we
    don't need another memset while reading cccr.
    
    Signed-off-by: Shawn Lin <shawn.lin@rock-chips.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 467b3cf80c44..bd44ba8116d1 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -106,8 +106,6 @@ static int sdio_read_cccr(struct mmc_card *card, u32 ocr)
 	unsigned char data;
 	unsigned char speed;
 
-	memset(&card->cccr, 0, sizeof(struct sdio_cccr));
-
 	ret = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_CCCR, 0, &data);
 	if (ret)
 		goto out;

commit e10c321977091f163eceedec0650e0ef4b3cf4bb
Author: Carlo Caione <carlo@endlessm.com>
Date:   Wed Jan 13 09:36:55 2016 +0100

    mmc: core: Enable tuning according to the actual timing
    
    While in sdhci_execute_tuning() the choice whether or not to enable the
    tuning is done on the actual timing, in the mmc_sdio_init_uhs_card() the
    check is done on the capability of the card.
    
    This difference is causing some issues with some SDIO cards in DDR50
    mode where the CDM19 is wrongly issued.
    
    With this patch we modify the check in both
    mmc_(sd|sdio)_init_uhs_card() functions to take the proper decision
    only according to the actual timing specification.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Carlo Caione <carlo@endlessm.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index d61ba1a0495e..467b3cf80c44 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -535,8 +535,8 @@ static int mmc_sdio_init_uhs_card(struct mmc_card *card)
 	 * SDR104 mode SD-cards. Note that tuning is mandatory for SDR104.
 	 */
 	if (!mmc_host_is_spi(card->host) &&
-	    ((card->sw_caps.sd3_bus_mode & SD_MODE_UHS_SDR50) ||
-	     (card->sw_caps.sd3_bus_mode & SD_MODE_UHS_SDR104)))
+	    ((card->host->ios.timing == MMC_TIMING_UHS_SDR50) ||
+	      (card->host->ios.timing == MMC_TIMING_UHS_SDR104)))
 		err = mmc_execute_tuning(card);
 out:
 	return err;

commit d9bfbb95ed598a09cf336adb0f190ee0ff802f0d
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Thu Nov 26 14:00:47 2015 +0200

    mmc: sdio: Fix invalid vdd in voltage switch power cycle
    
    The 'ocr' parameter passed to mmc_set_signal_voltage()
    defines the power-on voltage used when power cycling
    after a failure to set the voltage.  However, in the
    case of mmc_sdio_init_card(), the value passed has the
    R4_18V_PRESENT flag set which is not valid for power-on
    and results in an invalid vdd.  Fix by passing the card's
    ocr value which does not have the flag.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Cc: stable@vger.kernel.org # v3.13+
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 16d838e6d623..d61ba1a0495e 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -630,7 +630,7 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 	 */
 	if (!powered_resume && (rocr & ocr & R4_18V_PRESENT)) {
 		err = mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_180,
-					ocr);
+					ocr_card);
 		if (err == -EAGAIN) {
 			sdio_reset(host);
 			mmc_go_idle(host);

commit 9eadcc0581a8ccaf4c2378aa1c193fb164304f1d
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri Oct 2 10:56:11 2015 +0200

    mmc: core: Remove MMC_CLKGATE
    
    MMC_CLKGATE was once invented to save power by gating the bus clock at
    request inactivity. At that time it served its purpose. The modern way to
    deal with power saving for these scenarios, is by using runtime PM.
    
    Nowadays, several host drivers have deployed runtime PM, but for those
    that haven't and which still cares power saving at request inactivity,
    it's certainly time to deploy runtime PM as it has been around for several
    years now.
    
    To simplify code to mmc core and thus decrease maintenance efforts, this
    patch removes all code related to MMC_CLKGATE.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 95bc1014b7a2..16d838e6d623 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -956,13 +956,10 @@ static int mmc_sdio_resume(struct mmc_host *host)
 	}
 
 	if (!err && host->sdio_irqs) {
-		if (!(host->caps2 & MMC_CAP2_SDIO_IRQ_NOTHREAD)) {
+		if (!(host->caps2 & MMC_CAP2_SDIO_IRQ_NOTHREAD))
 			wake_up_process(host->sdio_irq_thread);
-		} else if (host->caps & MMC_CAP_SDIO_IRQ) {
-			mmc_host_clk_hold(host);
+		else if (host->caps & MMC_CAP_SDIO_IRQ)
 			host->ops->enable_sdio_irq(host, 1);
-			mmc_host_clk_release(host);
-		}
 	}
 
 	mmc_release_host(host);

commit 8d1ffc8c982e4480059ef735e8f15f631e40e80c
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri Sep 11 14:41:55 2015 +0200

    mmc: core: Keep host claimed while invoking mmc_power_off|up()
    
    As mmc_claim_host() invokes pm_runtime_get_sync() for the mmc host device,
    it's important that the host is kept claimed for *all* accesses to it via
    the host_ops callbacks.
    
    In some code paths for SDIO, particularly related to the PM support,
    mmc_power_off|up() is invoked without keeping the host claimed. Let's fix
    these.
    
    Moreover, mmc_start|stop_host() also invokes mmc_power_off|up() without
    claiming the host, let's fix these as well.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Kishon Vijay Abraham I <kishon@ti.com>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index b91abedcfdca..95bc1014b7a2 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -897,11 +897,10 @@ static int mmc_sdio_pre_suspend(struct mmc_host *host)
  */
 static int mmc_sdio_suspend(struct mmc_host *host)
 {
-	if (mmc_card_keep_power(host) && mmc_card_wake_sdio_irq(host)) {
-		mmc_claim_host(host);
+	mmc_claim_host(host);
+
+	if (mmc_card_keep_power(host) && mmc_card_wake_sdio_irq(host))
 		sdio_disable_wide(host->card);
-		mmc_release_host(host);
-	}
 
 	if (!mmc_card_keep_power(host)) {
 		mmc_power_off(host);
@@ -910,6 +909,8 @@ static int mmc_sdio_suspend(struct mmc_host *host)
 		mmc_retune_needed(host);
 	}
 
+	mmc_release_host(host);
+
 	return 0;
 }
 
@@ -1018,15 +1019,24 @@ static int mmc_sdio_power_restore(struct mmc_host *host)
 static int mmc_sdio_runtime_suspend(struct mmc_host *host)
 {
 	/* No references to the card, cut the power to it. */
+	mmc_claim_host(host);
 	mmc_power_off(host);
+	mmc_release_host(host);
+
 	return 0;
 }
 
 static int mmc_sdio_runtime_resume(struct mmc_host *host)
 {
+	int ret;
+
 	/* Restore power and re-initialize. */
+	mmc_claim_host(host);
 	mmc_power_up(host, host->card->ocr);
-	return mmc_sdio_power_restore(host);
+	ret = mmc_sdio_power_restore(host);
+	mmc_release_host(host);
+
+	return ret;
 }
 
 static int mmc_sdio_reset(struct mmc_host *host)

commit 3853a042325e8f497c199020979c4fc824528c6e
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Fri Feb 6 14:12:56 2015 +0200

    mmc: core: Record card drive strength
    
    In preparation for adding drive strength support
    for eMMC, add drive_strength to struct mmc_card
    to record the card drive strength for UHS-I modes
    and HS200 / HS400. For eMMC this will be needed
    when switching between HS200 and HS400.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 73b091331c96..b91abedcfdca 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -406,6 +406,8 @@ static void sdio_select_driver_type(struct mmc_card *card)
 	unsigned char card_strength;
 	int err;
 
+	card->drive_strength = 0;
+
 	card_drv_type = card->sw_caps.sd3_drv_type | SD_DRIVER_TYPE_B;
 
 	drive_strength = mmc_select_drive_strength(card,
@@ -427,6 +429,7 @@ static void sdio_select_driver_type(struct mmc_card *card)
 				       card_strength, NULL);
 		if (err)
 			return;
+		card->drive_strength = drive_strength;
 	}
 
 	if (drv_type)

commit e23350b35deb77ef8e33c35dbb0ed1dab9e8ab86
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Fri Feb 6 14:12:55 2015 +0200

    mmc: core: Factor out common code in drive strength selection
    
    Make a new function out of common code used for drive
    strength selection.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index d3d13047f316..73b091331c96 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -402,34 +402,15 @@ static unsigned char host_drive_to_sdio_drive(int host_strength)
 
 static void sdio_select_driver_type(struct mmc_card *card)
 {
-	int host_drv_type = SD_DRIVER_TYPE_B;
 	int card_drv_type, drive_strength, drv_type;
 	unsigned char card_strength;
 	int err;
 
-	if (!card->host->ops->select_drive_strength)
-		return;
-
-	if (card->host->caps & MMC_CAP_DRIVER_TYPE_A)
-		host_drv_type |= SD_DRIVER_TYPE_A;
-
-	if (card->host->caps & MMC_CAP_DRIVER_TYPE_C)
-		host_drv_type |= SD_DRIVER_TYPE_C;
-
-	if (card->host->caps & MMC_CAP_DRIVER_TYPE_D)
-		host_drv_type |= SD_DRIVER_TYPE_D;
-
 	card_drv_type = card->sw_caps.sd3_drv_type | SD_DRIVER_TYPE_B;
 
-	/*
-	 * The drive strength that the hardware can support
-	 * depends on the board design.  Pass the appropriate
-	 * information and let the hardware specific code
-	 * return what is possible given the options
-	 */
-	drive_strength = card->host->ops->select_drive_strength(card,
-		card->sw_caps.uhs_max_dtr,
-		host_drv_type, card_drv_type, &drv_type);
+	drive_strength = mmc_select_drive_strength(card,
+						   card->sw_caps.uhs_max_dtr,
+						   card_drv_type, &drv_type);
 
 	if (drive_strength) {
 		/* if error just use default for drive strength B */

commit f168359efbb99d6f8591bb666d6510bb78df2d07
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Fri Feb 6 14:12:54 2015 +0200

    mmc: core: Add 'card' to drive strength selection callback
    
    In preparation for supporting also eMMC drive strength,
    add the 'card' as a parameter so that the callback can
    distinguish different types of cards if necessary.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index ef82f3d029e8..d3d13047f316 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -427,7 +427,7 @@ static void sdio_select_driver_type(struct mmc_card *card)
 	 * information and let the hardware specific code
 	 * return what is possible given the options
 	 */
-	drive_strength = card->host->ops->select_drive_strength(
+	drive_strength = card->host->ops->select_drive_strength(card,
 		card->sw_caps.uhs_max_dtr,
 		host_drv_type, card_drv_type, &drv_type);
 

commit fa021cef1af64cb4ba11c3c0910ef45085c58016
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Fri Feb 6 14:12:53 2015 +0200

    mmc: core: Simplify card drive strength mask
    
    Card drive strength selection uses a callback to
    which a mask of supported drive strengths is passed.
    Currently, the bits are checked against the values
    in the SD specifications. That is not necessary
    because the callback will anyway match the mask
    against a valid value. Simplify by taking the mask
    as is but still ensuring that the default mandatory
    value (type B) is always supported.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 9d87aeb7c752..ef82f3d029e8 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -403,8 +403,7 @@ static unsigned char host_drive_to_sdio_drive(int host_strength)
 static void sdio_select_driver_type(struct mmc_card *card)
 {
 	int host_drv_type = SD_DRIVER_TYPE_B;
-	int card_drv_type = SD_DRIVER_TYPE_B;
-	int drive_strength, drv_type;
+	int card_drv_type, drive_strength, drv_type;
 	unsigned char card_strength;
 	int err;
 
@@ -420,14 +419,7 @@ static void sdio_select_driver_type(struct mmc_card *card)
 	if (card->host->caps & MMC_CAP_DRIVER_TYPE_D)
 		host_drv_type |= SD_DRIVER_TYPE_D;
 
-	if (card->sw_caps.sd3_drv_type & SD_DRIVER_TYPE_A)
-		card_drv_type |= SD_DRIVER_TYPE_A;
-
-	if (card->sw_caps.sd3_drv_type & SD_DRIVER_TYPE_C)
-		card_drv_type |= SD_DRIVER_TYPE_C;
-
-	if (card->sw_caps.sd3_drv_type & SD_DRIVER_TYPE_D)
-		card_drv_type |= SD_DRIVER_TYPE_D;
+	card_drv_type = card->sw_caps.sd3_drv_type | SD_DRIVER_TYPE_B;
 
 	/*
 	 * The drive strength that the hardware can support

commit b4f30a174e1fda8118eda038b5d8d5260db36ad5
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Fri Feb 6 14:12:52 2015 +0200

    mmc: core: Allow card drive strength to be different to host
    
    Initialization of UHS-I modes for SD and SDIO cards
    employs a callback to allow the host driver to
    choose a drive strength value. Currently that
    assumes the card drive strength and host driver
    type must be the same value. Change to let the
    callback make that decision and return both the
    card drive strength and host driver type.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 5c1423a3e7d7..9d87aeb7c752 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -404,21 +404,10 @@ static void sdio_select_driver_type(struct mmc_card *card)
 {
 	int host_drv_type = SD_DRIVER_TYPE_B;
 	int card_drv_type = SD_DRIVER_TYPE_B;
-	int drive_strength;
+	int drive_strength, drv_type;
 	unsigned char card_strength;
 	int err;
 
-	/*
-	 * If the host doesn't support any of the Driver Types A,C or D,
-	 * or there is no board specific handler then default Driver
-	 * Type B is used.
-	 */
-	if (!(card->host->caps &
-		(MMC_CAP_DRIVER_TYPE_A |
-		 MMC_CAP_DRIVER_TYPE_C |
-		 MMC_CAP_DRIVER_TYPE_D)))
-		return;
-
 	if (!card->host->ops->select_drive_strength)
 		return;
 
@@ -448,23 +437,27 @@ static void sdio_select_driver_type(struct mmc_card *card)
 	 */
 	drive_strength = card->host->ops->select_drive_strength(
 		card->sw_caps.uhs_max_dtr,
-		host_drv_type, card_drv_type);
+		host_drv_type, card_drv_type, &drv_type);
 
-	/* if error just use default for drive strength B */
-	err = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_DRIVE_STRENGTH, 0,
-		&card_strength);
-	if (err)
-		return;
+	if (drive_strength) {
+		/* if error just use default for drive strength B */
+		err = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_DRIVE_STRENGTH, 0,
+				       &card_strength);
+		if (err)
+			return;
 
-	card_strength &= ~(SDIO_DRIVE_DTSx_MASK<<SDIO_DRIVE_DTSx_SHIFT);
-	card_strength |= host_drive_to_sdio_drive(drive_strength);
+		card_strength &= ~(SDIO_DRIVE_DTSx_MASK<<SDIO_DRIVE_DTSx_SHIFT);
+		card_strength |= host_drive_to_sdio_drive(drive_strength);
 
-	err = mmc_io_rw_direct(card, 1, 0, SDIO_CCCR_DRIVE_STRENGTH,
-		card_strength, NULL);
+		/* if error default to drive strength B */
+		err = mmc_io_rw_direct(card, 1, 0, SDIO_CCCR_DRIVE_STRENGTH,
+				       card_strength, NULL);
+		if (err)
+			return;
+	}
 
-	/* if error default to drive strength B */
-	if (!err)
-		mmc_set_driver_type(card->host, drive_strength);
+	if (drv_type)
+		mmc_set_driver_type(card->host, drv_type);
 }
 
 

commit 79d5a65aeea43920bf3ff60791f317570dd6f54f
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Thu May 7 13:10:13 2015 +0300

    mmc: core: Enable / disable re-tuning
    
    Enable re-tuning when tuning is executed and
    disable re-tuning when card is no longer initialized.
    
    In the case of SDIO suspend, the card can keep power.
    In that case, re-tuning need not be disabled, but, if
    a re-tuning timer is being used, ensure it is disabled
    and assume that re-tuning will be needed upon resume
    since it is not known how long the suspend will last.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index f6c28a7ea8df..5c1423a3e7d7 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -934,8 +934,12 @@ static int mmc_sdio_suspend(struct mmc_host *host)
 		mmc_release_host(host);
 	}
 
-	if (!mmc_card_keep_power(host))
+	if (!mmc_card_keep_power(host)) {
 		mmc_power_off(host);
+	} else if (host->retune_period) {
+		mmc_retune_timer_stop(host);
+		mmc_retune_needed(host);
+	}
 
 	return 0;
 }

commit 1fb654fd97ff0c56ff1646dc9e73543abeb912df
Author: Andreas Fenkart <afenkart@gmail.com>
Date:   Thu Apr 23 13:15:42 2015 +0200

    mmc: sdio: add reset callback to bus operations
    
    Some drivers schedule automatic hw resets. An example is mwifiex,
    which schedules a card reset if the command handler between driver
    and card firmware becomes out of sync
    
    Signed-off-by: Andreas Fenkart <afenkart@gmail.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 5bc6c7dbbd60..f6c28a7ea8df 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -1056,6 +1056,12 @@ static int mmc_sdio_runtime_resume(struct mmc_host *host)
 	return mmc_sdio_power_restore(host);
 }
 
+static int mmc_sdio_reset(struct mmc_host *host)
+{
+	mmc_power_cycle(host, host->card->ocr);
+	return mmc_sdio_power_restore(host);
+}
+
 static const struct mmc_bus_ops mmc_sdio_ops = {
 	.remove = mmc_sdio_remove,
 	.detect = mmc_sdio_detect,
@@ -1066,6 +1072,7 @@ static const struct mmc_bus_ops mmc_sdio_ops = {
 	.runtime_resume = mmc_sdio_runtime_resume,
 	.power_restore = mmc_sdio_power_restore,
 	.alive = mmc_sdio_alive,
+	.reset = mmc_sdio_reset,
 };
 
 

commit 303dbedc3152b0a3828ea881b446c2e2a247662f
Author: NeilBrown <neilb@suse.de>
Date:   Tue Feb 24 13:42:23 2015 +1100

    mmc: core: fold mmc_set_bus_width calls into sdio_enable_4bit_bus.
    
    Every call to sdio_enable_4bit_bus is followed (on success) by a call
    to mmc_set_bus_width().
    
    To simplify the code, include those calls directly in
    sdio_enable_4bit_bus().
    
    Signed-off-by: NeilBrown <neil@brown.name>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index ce6cc47206b0..5bc6c7dbbd60 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -293,19 +293,22 @@ static int sdio_enable_4bit_bus(struct mmc_card *card)
 	int err;
 
 	if (card->type == MMC_TYPE_SDIO)
-		return sdio_enable_wide(card);
-
-	if ((card->host->caps & MMC_CAP_4_BIT_DATA) &&
-		(card->scr.bus_widths & SD_SCR_BUS_WIDTH_4)) {
+		err = sdio_enable_wide(card);
+	else if ((card->host->caps & MMC_CAP_4_BIT_DATA) &&
+		 (card->scr.bus_widths & SD_SCR_BUS_WIDTH_4)) {
 		err = mmc_app_set_bus_width(card, MMC_BUS_WIDTH_4);
 		if (err)
 			return err;
+		err = sdio_enable_wide(card);
+		if (err <= 0)
+			mmc_app_set_bus_width(card, MMC_BUS_WIDTH_1);
 	} else
 		return 0;
 
-	err = sdio_enable_wide(card);
-	if (err <= 0)
-		mmc_app_set_bus_width(card, MMC_BUS_WIDTH_1);
+	if (err > 0) {
+		mmc_set_bus_width(card->host, MMC_BUS_WIDTH_4);
+		err = 0;
+	}
 
 	return err;
 }
@@ -547,13 +550,8 @@ static int mmc_sdio_init_uhs_card(struct mmc_card *card)
 	/*
 	 * Switch to wider bus (if supported).
 	 */
-	if (card->host->caps & MMC_CAP_4_BIT_DATA) {
+	if (card->host->caps & MMC_CAP_4_BIT_DATA)
 		err = sdio_enable_4bit_bus(card);
-		if (err > 0) {
-			mmc_set_bus_width(card->host, MMC_BUS_WIDTH_4);
-			err = 0;
-		}
-	}
 
 	/* Set the driver strength for the card */
 	sdio_select_driver_type(card);
@@ -803,9 +801,7 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 		 * Switch to wider bus (if supported).
 		 */
 		err = sdio_enable_4bit_bus(card);
-		if (err > 0)
-			mmc_set_bus_width(card->host, MMC_BUS_WIDTH_4);
-		else if (err)
+		if (err)
 			goto remove;
 	}
 finish:
@@ -983,10 +979,6 @@ static int mmc_sdio_resume(struct mmc_host *host)
 	} else if (mmc_card_keep_power(host) && mmc_card_wake_sdio_irq(host)) {
 		/* We may have switched to 1-bit mode during suspend */
 		err = sdio_enable_4bit_bus(host->card);
-		if (err > 0) {
-			mmc_set_bus_width(host, MMC_BUS_WIDTH_4);
-			err = 0;
-		}
 	}
 
 	if (!err && host->sdio_irqs) {

commit 63e415c64003fd62a302a1dc19f082e2c6f1b7cc
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Fri Dec 5 19:40:59 2014 +0200

    mmc: core: Simplify by adding mmc_execute_tuning()
    
    For each MMC, SD and SDIO there is code that
    holds the clock, calls ops->execute_tuning, and
    releases the clock. Simplify the code a bit by
    providing a separate function to do that.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index fd0750b5a634..ce6cc47206b0 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -567,17 +567,11 @@ static int mmc_sdio_init_uhs_card(struct mmc_card *card)
 	 * SPI mode doesn't define CMD19 and tuning is only valid for SDR50 and
 	 * SDR104 mode SD-cards. Note that tuning is mandatory for SDR104.
 	 */
-	if (!mmc_host_is_spi(card->host) && card->host->ops->execute_tuning &&
-			((card->sw_caps.sd3_bus_mode & SD_MODE_UHS_SDR50) ||
-			 (card->sw_caps.sd3_bus_mode & SD_MODE_UHS_SDR104))) {
-		mmc_host_clk_hold(card->host);
-		err = card->host->ops->execute_tuning(card->host,
-						      MMC_SEND_TUNING_BLOCK);
-		mmc_host_clk_release(card->host);
-	}
-
+	if (!mmc_host_is_spi(card->host) &&
+	    ((card->sw_caps.sd3_bus_mode & SD_MODE_UHS_SDR50) ||
+	     (card->sw_caps.sd3_bus_mode & SD_MODE_UHS_SDR104)))
+		err = mmc_execute_tuning(card);
 out:
-
 	return err;
 }
 

commit 006fc51cb3ab42960fa4f246c772ad12e45a3a9b
Author: NeilBrown <neilb@suse.de>
Date:   Wed Nov 12 14:55:19 2014 +1100

    mmc: core: reset sdio card properly on resume.
    
    mmc_sdio_power_restore() calls
            mmc_send_if_cond(host, host->card->ocr);
    
            ret = mmc_send_io_op_cond(host, 0, NULL);
    
    between mmc_go_idle() and mmc_sdio_init_card().
    mmc_sdio_resume() needs to as well, else my libertas sdio wifi
    device doesn't resume properly from suspend.
    
    Signed-off-by: NeilBrown <neilb@suse.de>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index f0ddb0d28536..fd0750b5a634 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -980,8 +980,12 @@ static int mmc_sdio_resume(struct mmc_host *host)
 	if (mmc_card_is_removable(host) || !mmc_card_keep_power(host)) {
 		sdio_reset(host);
 		mmc_go_idle(host);
-		err = mmc_sdio_init_card(host, host->card->ocr, host->card,
-					mmc_card_keep_power(host));
+		mmc_send_if_cond(host, host->card->ocr);
+		err = mmc_send_io_op_cond(host, 0, NULL);
+		if (!err)
+			err = mmc_sdio_init_card(host, host->card->ocr,
+						 host->card,
+						 mmc_card_keep_power(host));
 	} else if (mmc_card_keep_power(host) && mmc_card_wake_sdio_irq(host)) {
 		/* We may have switched to 1-bit mode during suspend */
 		err = sdio_enable_4bit_bus(host->card);

commit 59b6c9e0ad9f2578ff8b2ef8c718bcb8b895fefb
Author: NeilBrown <neilb@suse.de>
Date:   Wed Nov 12 14:55:19 2014 +1100

    mmc: core: use card->ocr when negotiating voltage setting in mmc_sdio_power_restore
    
    As we are restoring power to a known card, it makes sense to use
    the 'ocr' value known for the card rather than the generic one
    for the host interface.
    This matches the use of card->ocr passed to mmc_power_up in
    mmc_sdio_runtime_resume  (just before mmc_sdio_power_restore is
    called), and the value passed to mmc_sdio_init_card() a little
    later in mmc_sdio_power_restore().
    
    Suggested-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: NeilBrown <neilb@suse.de>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 2439e717655b..f0ddb0d28536 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -1035,7 +1035,7 @@ static int mmc_sdio_power_restore(struct mmc_host *host)
 
 	sdio_reset(host);
 	mmc_go_idle(host);
-	mmc_send_if_cond(host, host->ocr_avail);
+	mmc_send_if_cond(host, host->card->ocr);
 
 	ret = mmc_send_io_op_cond(host, 0, NULL);
 	if (ret)

commit 6606110d89aefcb21b9e70adfe064987cbd8393a
Author: Joe Perches <joe@perches.com>
Date:   Fri Sep 12 14:56:56 2014 -0700

    mmc: Convert pr_warning to pr_warn
    
    Use the much more common pr_warn instead of pr_warning.
    
    Other miscellanea:
    
    o Coalesce formats
    o Realign arguments
    o Remove extra spaces when coalescing formats
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 3fc40a7140a8..2439e717655b 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -216,8 +216,8 @@ static int sdio_enable_wide(struct mmc_card *card)
 		return ret;
 
 	if ((ctrl & SDIO_BUS_WIDTH_MASK) == SDIO_BUS_WIDTH_RESERVED)
-		pr_warning("%s: SDIO_CCCR_IF is invalid: 0x%02x\n",
-			   mmc_hostname(card->host), ctrl);
+		pr_warn("%s: SDIO_CCCR_IF is invalid: 0x%02x\n",
+			mmc_hostname(card->host), ctrl);
 
 	/* set as 4-bit bus width */
 	ctrl &= ~SDIO_BUS_WIDTH_MASK;
@@ -605,8 +605,7 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 
 try_again:
 	if (!retries) {
-		pr_warning("%s: Skipping voltage switch\n",
-				mmc_hostname(host));
+		pr_warn("%s: Skipping voltage switch\n", mmc_hostname(host));
 		ocr &= ~R4_18V_PRESENT;
 	}
 

commit dea67c4ec8218b301d7cac7ee6e63dac0bc566cb
Author: Fu Zhonghui <zhonghui.fu@linux.intel.com>
Date:   Mon Aug 18 10:48:14 2014 +0800

    mmc: core: sdio: Fix unconditional wake_up_process() on sdio thread
    
    781e989cf59 ("mmc: sdhci: convert to new SDIO IRQ handling") and
    bf3b5ec66bd ("mmc: sdio_irq: rework sdio irq handling") disabled
    the use of our own custom threaded IRQ handler, but left in an
    unconditional wake_up_process() on that handler at resume-time.
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=80151
    
    In addition, the check for MMC_CAP_SDIO_IRQ capability is added
    before enable sdio IRQ.
    
    Signed-off-by: Jaehoon Chung <jh80.chung@samsung.com>
    Signed-off-by: Chris Ball <chris@printf.net>
    Signed-off-by: Fu Zhonghui <zhonghui.fu@linux.intel.com>
    Cc: <stable@vger.kernel.org> # v3.16+
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index e636d9e99e4a..3fc40a7140a8 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -992,8 +992,16 @@ static int mmc_sdio_resume(struct mmc_host *host)
 		}
 	}
 
-	if (!err && host->sdio_irqs)
-		wake_up_process(host->sdio_irq_thread);
+	if (!err && host->sdio_irqs) {
+		if (!(host->caps2 & MMC_CAP2_SDIO_IRQ_NOTHREAD)) {
+			wake_up_process(host->sdio_irq_thread);
+		} else if (host->caps & MMC_CAP_SDIO_IRQ) {
+			mmc_host_clk_hold(host);
+			host->ops->enable_sdio_irq(host, 1);
+			mmc_host_clk_release(host);
+		}
+	}
+
 	mmc_release_host(host);
 
 	host->pm_flags &= ~MMC_PM_KEEP_POWER;

commit cdc991790c51c693d0c347a5286af017826a5d01
Author: Seungwon Jeon <tgih.jun@samsung.com>
Date:   Wed Apr 23 17:07:35 2014 +0900

    mmc: drop the speed mode of card's state
    
    Timing mode identifier has same role and can take the place
    of speed mode. This change removes all related speed mode.
    
    Signed-off-by: Seungwon Jeon <tgih.jun@samsung.com>
    Tested-by: Jaehoon Chung <jh80.chung@samsung.com>
    Acked-by: Jaehoon Chung <jh80.chung@samsung.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <chris@printf.net>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 9933e426bc36..e636d9e99e4a 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -363,7 +363,7 @@ static unsigned mmc_sdio_get_max_clock(struct mmc_card *card)
 {
 	unsigned max_dtr;
 
-	if (mmc_card_highspeed(card)) {
+	if (mmc_card_hs(card)) {
 		/*
 		 * The SDIO specification doesn't mention how
 		 * the CIS transfer speed register relates to
@@ -733,7 +733,6 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 		mmc_set_clock(host, card->cis.max_dtr);
 
 		if (card->cccr.high_speed) {
-			mmc_card_set_highspeed(card);
 			mmc_set_timing(card->host, MMC_TIMING_SD_HS);
 		}
 
@@ -792,16 +791,13 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 		err = mmc_sdio_init_uhs_card(card);
 		if (err)
 			goto remove;
-
-		/* Card is an ultra-high-speed card */
-		mmc_card_set_uhs(card);
 	} else {
 		/*
 		 * Switch to high-speed (if supported).
 		 */
 		err = sdio_enable_hs(card);
 		if (err > 0)
-			mmc_sd_go_highspeed(card);
+			mmc_set_timing(card->host, MMC_TIMING_SD_HS);
 		else if (err)
 			goto remove;
 

commit 573185cc7e646fdd5da12702ba5383e91cc25ef3
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri Feb 28 12:49:00 2014 +0100

    mmc: core: Invoke sdio func driver's PM callbacks from the sdio bus
    
    The sdio func device is added to the driver model after the card
    device.
    
    This means the sdio func device will be suspend before the card device
    and thus resumed after. The consequence are the mmc core don't
    explicity need to protect itself from receiving sdio requests in
    suspended state. Instead that can be handled from the sdio bus, which
    is thus invokes the PM callbacks instead of old dummy function.
    
    In the case were the sdio func driver don't implement the PM callbacks
    the mmc core will in the early phase of system suspend, remove the
    card from the driver model and thus power off it.
    
    Cc: Aaron Lu <aaron.lu@intel.com>
    Cc: NeilBrown <neilb@suse.de>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Aaron Lu <aaron.lu@intel.com>
    Tested-by: xiaoming wang <xiaoming.wang@intel.com>
    Tested-by: Chuanxiao Dong <chuanxiao.dong@intel.com>
    Signed-off-by: Chris Ball <chris@printf.net>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 4d721c6e2af0..9933e426bc36 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -943,40 +943,21 @@ static int mmc_sdio_pre_suspend(struct mmc_host *host)
  */
 static int mmc_sdio_suspend(struct mmc_host *host)
 {
-	int i, err = 0;
-
-	for (i = 0; i < host->card->sdio_funcs; i++) {
-		struct sdio_func *func = host->card->sdio_func[i];
-		if (func && sdio_func_present(func) && func->dev.driver) {
-			const struct dev_pm_ops *pmops = func->dev.driver->pm;
-			err = pmops->suspend(&func->dev);
-			if (err)
-				break;
-		}
-	}
-	while (err && --i >= 0) {
-		struct sdio_func *func = host->card->sdio_func[i];
-		if (func && sdio_func_present(func) && func->dev.driver) {
-			const struct dev_pm_ops *pmops = func->dev.driver->pm;
-			pmops->resume(&func->dev);
-		}
-	}
-
-	if (!err && mmc_card_keep_power(host) && mmc_card_wake_sdio_irq(host)) {
+	if (mmc_card_keep_power(host) && mmc_card_wake_sdio_irq(host)) {
 		mmc_claim_host(host);
 		sdio_disable_wide(host->card);
 		mmc_release_host(host);
 	}
 
-	if (!err && !mmc_card_keep_power(host))
+	if (!mmc_card_keep_power(host))
 		mmc_power_off(host);
 
-	return err;
+	return 0;
 }
 
 static int mmc_sdio_resume(struct mmc_host *host)
 {
-	int i, err = 0;
+	int err = 0;
 
 	BUG_ON(!host);
 	BUG_ON(!host->card);
@@ -1019,24 +1000,6 @@ static int mmc_sdio_resume(struct mmc_host *host)
 		wake_up_process(host->sdio_irq_thread);
 	mmc_release_host(host);
 
-	/*
-	 * If the card looked to be the same as before suspending, then
-	 * we proceed to resume all card functions.  If one of them returns
-	 * an error then we simply return that error to the core and the
-	 * card will be redetected as new.  It is the responsibility of
-	 * the function driver to perform further tests with the extra
-	 * knowledge it has of the card to confirm the card is indeed the
-	 * same as before suspending (same MAC address for network cards,
-	 * etc.) and return an error otherwise.
-	 */
-	for (i = 0; !err && i < host->card->sdio_funcs; i++) {
-		struct sdio_func *func = host->card->sdio_func[i];
-		if (func && sdio_func_present(func) && func->dev.driver) {
-			const struct dev_pm_ops *pmops = func->dev.driver->pm;
-			err = pmops->resume(&func->dev);
-		}
-	}
-
 	host->pm_flags &= ~MMC_PM_KEEP_POWER;
 	return err;
 }

commit 726d6f2374410d980341bfeb49399614e689e702
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Mon Sep 16 12:06:15 2013 +0200

    mmc: core: Collect common code for card ocr validation
    
    Since mmc_select_voltage now only gets called from the attach sequence,
    it makes sense to move the out of spec validations of the card ocr into
    this function.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index b7c19e894dd3..4d721c6e2af0 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -1133,16 +1133,6 @@ int mmc_attach_sdio(struct mmc_host *host)
 	if (host->ocr_avail_sdio)
 		host->ocr_avail = host->ocr_avail_sdio;
 
-	/*
-	 * Sanity check the voltages that the card claims to
-	 * support.
-	 */
-	if (ocr & 0x7F) {
-		pr_warning("%s: card claims to support voltages "
-		       "below the defined range. These will be ignored.\n",
-		       mmc_hostname(host));
-		ocr &= ~0x7F;
-	}
 
 	rocr = mmc_select_voltage(host, ocr);
 

commit ce69d37b7d8fa692c45d71d94aa0c921859b82ce
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Mon Sep 16 11:28:42 2013 +0200

    mmc: core: Prevent violation of specs while initializing cards
    
    According to eMMC/SD/SDIO specs, the VDD (VCC) voltage level must be
    maintained during the initialization sequence. If we want/need to tune
    the voltage level, a complete power cycle of the card must be executed.
    
    Most host drivers conforms to the specifications by only allowing to
    change VDD voltage level at the MMC_POWER_UP state, but some also cares
    about MMC_POWER_ON state, which they should'nt. This patch will not
    break those drivers, but they could clean up code to better reflect
    what is expected from the protocol layer.
    
    A big re-work of the mmc_select_voltage function is done to only change
    VDD voltage level if the host supports MMC_CAP2_FULL_PWR_CYCLE.
    Otherwise only validation of the host and card ocr mask will be done.
    
    A very nice side-effect of this patch is that we now don't need to
    reset the negotiated ocr mask at the mmc_power_off function, since now
    it will actually reflect the present voltage level, which safely can be
    used at the next power up and re-initialization. Moreover, we then only
    need to execute mmc_select_voltage from the attach sequence.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index e0a135a635f5..b7c19e894dd3 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -987,7 +987,6 @@ static int mmc_sdio_resume(struct mmc_host *host)
 	/* Restore power if needed */
 	if (!mmc_card_keep_power(host)) {
 		mmc_power_up(host, host->card->ocr);
-		mmc_select_voltage(host, host->card->ocr);
 		/*
 		 * Tell runtime PM core we just powered up the card,
 		 * since it still believes the card is powered off.
@@ -1045,7 +1044,6 @@ static int mmc_sdio_resume(struct mmc_host *host)
 static int mmc_sdio_power_restore(struct mmc_host *host)
 {
 	int ret;
-	u32 ocr, rocr;
 
 	BUG_ON(!host);
 	BUG_ON(!host->card);
@@ -1067,28 +1065,17 @@ static int mmc_sdio_power_restore(struct mmc_host *host)
 	 * for OLPC SD8686 (which expects a [CMD5,5,3,7] init sequence), and
 	 * harmless in other situations.
 	 *
-	 * With these steps taken, mmc_select_voltage() is also required to
-	 * restore the correct voltage setting of the card.
 	 */
 
 	sdio_reset(host);
 	mmc_go_idle(host);
 	mmc_send_if_cond(host, host->ocr_avail);
 
-	ret = mmc_send_io_op_cond(host, 0, &ocr);
+	ret = mmc_send_io_op_cond(host, 0, NULL);
 	if (ret)
 		goto out;
 
-	if (host->ocr_avail_sdio)
-		host->ocr_avail = host->ocr_avail_sdio;
-
-	rocr = mmc_select_voltage(host, ocr & ~0x7F);
-	if (!rocr) {
-		ret = -EINVAL;
-		goto out;
-	}
-
-	ret = mmc_sdio_init_card(host, rocr, host->card,
+	ret = mmc_sdio_init_card(host, host->card->ocr, host->card,
 				mmc_card_keep_power(host));
 	if (!ret && host->sdio_irqs)
 		mmc_signal_sdio_irq(host);

commit 6904115095ad60ced638eb1e36e0e4e5e7de00b0
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri Sep 13 11:31:33 2013 +0200

    mmc: core: Move cached value of the negotiated ocr mask to card struct
    
    The negotiated ocr mask is directly related to the card. Once a card
    gets removed, the mask shall be dropped. By moving the cache of the ocr
    mask from the host struct to the card struct we have accomplished this.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 9587d9f8cf1c..e0a135a635f5 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -594,6 +594,7 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 	int err;
 	int retries = 10;
 	u32 rocr = 0;
+	u32 ocr_card = ocr;
 
 	BUG_ON(!host);
 	WARN_ON(!host->claimed);
@@ -762,6 +763,7 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 
 		card = oldcard;
 	}
+	card->ocr = ocr_card;
 	mmc_fixup_device(card, NULL);
 
 	if (card->type == MMC_TYPE_SD_COMBO) {
@@ -984,8 +986,8 @@ static int mmc_sdio_resume(struct mmc_host *host)
 
 	/* Restore power if needed */
 	if (!mmc_card_keep_power(host)) {
-		mmc_power_up(host, host->ocr);
-		mmc_select_voltage(host, host->ocr);
+		mmc_power_up(host, host->card->ocr);
+		mmc_select_voltage(host, host->card->ocr);
 		/*
 		 * Tell runtime PM core we just powered up the card,
 		 * since it still believes the card is powered off.
@@ -1003,7 +1005,7 @@ static int mmc_sdio_resume(struct mmc_host *host)
 	if (mmc_card_is_removable(host) || !mmc_card_keep_power(host)) {
 		sdio_reset(host);
 		mmc_go_idle(host);
-		err = mmc_sdio_init_card(host, host->ocr, host->card,
+		err = mmc_sdio_init_card(host, host->card->ocr, host->card,
 					mmc_card_keep_power(host));
 	} else if (mmc_card_keep_power(host) && mmc_card_wake_sdio_irq(host)) {
 		/* We may have switched to 1-bit mode during suspend */
@@ -1043,7 +1045,7 @@ static int mmc_sdio_resume(struct mmc_host *host)
 static int mmc_sdio_power_restore(struct mmc_host *host)
 {
 	int ret;
-	u32 ocr;
+	u32 ocr, rocr;
 
 	BUG_ON(!host);
 	BUG_ON(!host->card);
@@ -1080,13 +1082,13 @@ static int mmc_sdio_power_restore(struct mmc_host *host)
 	if (host->ocr_avail_sdio)
 		host->ocr_avail = host->ocr_avail_sdio;
 
-	host->ocr = mmc_select_voltage(host, ocr & ~0x7F);
-	if (!host->ocr) {
+	rocr = mmc_select_voltage(host, ocr & ~0x7F);
+	if (!rocr) {
 		ret = -EINVAL;
 		goto out;
 	}
 
-	ret = mmc_sdio_init_card(host, host->ocr, host->card,
+	ret = mmc_sdio_init_card(host, rocr, host->card,
 				mmc_card_keep_power(host));
 	if (!ret && host->sdio_irqs)
 		mmc_signal_sdio_irq(host);
@@ -1107,7 +1109,7 @@ static int mmc_sdio_runtime_suspend(struct mmc_host *host)
 static int mmc_sdio_runtime_resume(struct mmc_host *host)
 {
 	/* Restore power and re-initialize. */
-	mmc_power_up(host, host->ocr);
+	mmc_power_up(host, host->card->ocr);
 	return mmc_sdio_power_restore(host);
 }
 
@@ -1130,7 +1132,7 @@ static const struct mmc_bus_ops mmc_sdio_ops = {
 int mmc_attach_sdio(struct mmc_host *host)
 {
 	int err, i, funcs;
-	u32 ocr;
+	u32 ocr, rocr;
 	struct mmc_card *card;
 
 	BUG_ON(!host);
@@ -1155,12 +1157,12 @@ int mmc_attach_sdio(struct mmc_host *host)
 		ocr &= ~0x7F;
 	}
 
-	host->ocr = mmc_select_voltage(host, ocr);
+	rocr = mmc_select_voltage(host, ocr);
 
 	/*
 	 * Can we support the voltage(s) of the card(s)?
 	 */
-	if (!host->ocr) {
+	if (!rocr) {
 		err = -EINVAL;
 		goto err;
 	}
@@ -1168,7 +1170,7 @@ int mmc_attach_sdio(struct mmc_host *host)
 	/*
 	 * Detect and init the card.
 	 */
-	err = mmc_sdio_init_card(host, host->ocr, NULL, 0);
+	err = mmc_sdio_init_card(host, rocr, NULL, 0);
 	if (err)
 		goto err;
 

commit db4a0d0512253c23a052ae650395c07d956118b3
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri Sep 13 10:49:34 2013 +0200

    mmc: core: Cleanup code for setting ocr mask for SDIO
    
    At several places in mmc_sdio_init_card function the cached mask in
    host->ocr were being updated. To simplify code, we make use of an
    local ocr parameter instead.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 26b13169156c..9587d9f8cf1c 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -593,23 +593,27 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 	struct mmc_card *card;
 	int err;
 	int retries = 10;
+	u32 rocr = 0;
 
 	BUG_ON(!host);
 	WARN_ON(!host->claimed);
 
+	/* to query card if 1.8V signalling is supported */
+	if (mmc_host_uhs(host))
+		ocr |= R4_18V_PRESENT;
+
 try_again:
 	if (!retries) {
 		pr_warning("%s: Skipping voltage switch\n",
 				mmc_hostname(host));
 		ocr &= ~R4_18V_PRESENT;
-		host->ocr &= ~R4_18V_PRESENT;
 	}
 
 	/*
 	 * Inform the card of the voltage
 	 */
 	if (!powered_resume) {
-		err = mmc_send_io_op_cond(host, host->ocr, &ocr);
+		err = mmc_send_io_op_cond(host, ocr, &rocr);
 		if (err)
 			goto err;
 	}
@@ -632,8 +636,8 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 		goto err;
 	}
 
-	if ((ocr & R4_MEMORY_PRESENT) &&
-	    mmc_sd_get_cid(host, host->ocr & ocr, card->raw_cid, NULL) == 0) {
+	if ((rocr & R4_MEMORY_PRESENT) &&
+	    mmc_sd_get_cid(host, ocr & rocr, card->raw_cid, NULL) == 0) {
 		card->type = MMC_TYPE_SD_COMBO;
 
 		if (oldcard && (oldcard->type != MMC_TYPE_SD_COMBO ||
@@ -663,9 +667,9 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 	 * systems that claim 1.8v signalling in fact do not support
 	 * it.
 	 */
-	if (!powered_resume && (ocr & R4_18V_PRESENT) && mmc_host_uhs(host)) {
+	if (!powered_resume && (rocr & ocr & R4_18V_PRESENT)) {
 		err = mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_180,
-					host->ocr);
+					ocr);
 		if (err == -EAGAIN) {
 			sdio_reset(host);
 			mmc_go_idle(host);
@@ -675,12 +679,10 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 			goto try_again;
 		} else if (err) {
 			ocr &= ~R4_18V_PRESENT;
-			host->ocr &= ~R4_18V_PRESENT;
 		}
 		err = 0;
 	} else {
 		ocr &= ~R4_18V_PRESENT;
-		host->ocr &= ~R4_18V_PRESENT;
 	}
 
 	/*
@@ -1084,10 +1086,6 @@ static int mmc_sdio_power_restore(struct mmc_host *host)
 		goto out;
 	}
 
-	if (mmc_host_uhs(host))
-		/* to query card if 1.8V signalling is supported */
-		host->ocr |= R4_18V_PRESENT;
-
 	ret = mmc_sdio_init_card(host, host->ocr, host->card,
 				mmc_card_keep_power(host));
 	if (!ret && host->sdio_irqs)
@@ -1170,10 +1168,6 @@ int mmc_attach_sdio(struct mmc_host *host)
 	/*
 	 * Detect and init the card.
 	 */
-	if (mmc_host_uhs(host))
-		/* to query card if 1.8V signalling is supported */
-		host->ocr |= R4_18V_PRESENT;
-
 	err = mmc_sdio_init_card(host, host->ocr, NULL, 0);
 	if (err)
 		goto err;

commit ec2ed7006263bd4224083aff7833bd791ac35d65
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu Sep 12 16:38:56 2013 +0200

    mmc: core: Remove unnecessary retry mechanism at SDIO attach
    
    The retry and fallback mechanism when failing to switch to 1.8V
    signaling voltage is handled by the SDIO card init function. Thus we
    can remove the duplicated old code from the attach function.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 15cbc418c95f..26b13169156c 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -1175,17 +1175,9 @@ int mmc_attach_sdio(struct mmc_host *host)
 		host->ocr |= R4_18V_PRESENT;
 
 	err = mmc_sdio_init_card(host, host->ocr, NULL, 0);
-	if (err) {
-		if (err == -EAGAIN) {
-			/*
-			 * Retry initialization with S18R set to 0.
-			 */
-			host->ocr &= ~R4_18V_PRESENT;
-			err = mmc_sdio_init_card(host, host->ocr, NULL, 0);
-		}
-		if (err)
-			goto err;
-	}
+	if (err)
+		goto err;
+
 	card = host->card;
 
 	/*

commit 0f791fdad82a02af013e4fc8c385dc690080c366
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu Sep 12 15:36:34 2013 +0200

    mmc: core: Let mmc_set_signal_voltage take ocr as parameter
    
    This is yet another step of restructure code to be able to fixup the
    setup of the negotiated ocr mask.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 355c95270d48..15cbc418c95f 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -664,7 +664,8 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 	 * it.
 	 */
 	if (!powered_resume && (ocr & R4_18V_PRESENT) && mmc_host_uhs(host)) {
-		err = mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_180);
+		err = mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_180,
+					host->ocr);
 		if (err == -EAGAIN) {
 			sdio_reset(host);
 			mmc_go_idle(host);

commit 4a065193c46a16f1ddf20622c7011c8f327e0478
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu Sep 12 14:36:53 2013 +0200

    mmc: core: Let mmc_power_up|cycle take ocr as parameter
    
    As a step to fixup the setup of the negotiated ocr mask, we need the
    mmc_power_up|cycle functions to take the ocr as a parameter.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 80d89cff7306..355c95270d48 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -981,7 +981,7 @@ static int mmc_sdio_resume(struct mmc_host *host)
 
 	/* Restore power if needed */
 	if (!mmc_card_keep_power(host)) {
-		mmc_power_up(host);
+		mmc_power_up(host, host->ocr);
 		mmc_select_voltage(host, host->ocr);
 		/*
 		 * Tell runtime PM core we just powered up the card,
@@ -1108,7 +1108,7 @@ static int mmc_sdio_runtime_suspend(struct mmc_host *host)
 static int mmc_sdio_runtime_resume(struct mmc_host *host)
 {
 	/* Restore power and re-initialize. */
-	mmc_power_up(host);
+	mmc_power_up(host, host->ocr);
 	return mmc_sdio_power_restore(host);
 }
 

commit 74590263384e5d4601de7f0ee2790477578829ea
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Mon Jun 10 17:03:38 2013 +0200

    mmc: core: Push common suspend|resume code into each bus_ops
    
    By moving code from the mmc_suspend|resume_host down into each
    .suspend|resume bus_ops callback, we get a more flexible solution.
    
    Some nice side effects are that we get a better understanding of each
    bus_ops suspend|resume sequence and the common code don't have to take
    care of specific corner cases, especially for the SDIO case.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Tested-by: Jaehoon Chung <jh80.chung@samsung.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index be8cca8d3024..80d89cff7306 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -963,6 +963,9 @@ static int mmc_sdio_suspend(struct mmc_host *host)
 		mmc_release_host(host);
 	}
 
+	if (!err && !mmc_card_keep_power(host))
+		mmc_power_off(host);
+
 	return err;
 }
 
@@ -976,6 +979,23 @@ static int mmc_sdio_resume(struct mmc_host *host)
 	/* Basic card reinitialization. */
 	mmc_claim_host(host);
 
+	/* Restore power if needed */
+	if (!mmc_card_keep_power(host)) {
+		mmc_power_up(host);
+		mmc_select_voltage(host, host->ocr);
+		/*
+		 * Tell runtime PM core we just powered up the card,
+		 * since it still believes the card is powered off.
+		 * Note that currently runtime PM is only enabled
+		 * for SDIO cards that are MMC_CAP_POWER_OFF_CARD
+		 */
+		if (host->caps & MMC_CAP_POWER_OFF_CARD) {
+			pm_runtime_disable(&host->card->dev);
+			pm_runtime_set_active(&host->card->dev);
+			pm_runtime_enable(&host->card->dev);
+		}
+	}
+
 	/* No need to reinitialize powered-resumed nonremovable cards */
 	if (mmc_card_is_removable(host) || !mmc_card_keep_power(host)) {
 		sdio_reset(host);
@@ -1013,6 +1033,7 @@ static int mmc_sdio_resume(struct mmc_host *host)
 		}
 	}
 
+	host->pm_flags &= ~MMC_PM_KEEP_POWER;
 	return err;
 }
 

commit 810caddba42a54fe5db4e2664757a9a334ba359c
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Mon Jun 10 17:03:37 2013 +0200

    mmc: core: Validate suspend prerequisites for SDIO at SUSPEND_PREPARE
    
    This patch moves the validation for all the suspend prerequisites to be
    done at SUSPEND_PREPARE notification. Previously in the SDIO case parts
    of the validation was done from mmc_suspend_host.
    
    This patch invents a new pre_suspend bus_ops callback and implements it
    for SDIO. Returning an error code from it, will mean at SUSPEND_PREPARE
    notification, the card will be removed before proceeding with the
    suspend sequence.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Tested-by: Jaehoon Chung <jh80.chung@samsung.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 1fbbd1bc55ec..be8cca8d3024 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -910,11 +910,11 @@ static void mmc_sdio_detect(struct mmc_host *host)
 }
 
 /*
- * SDIO suspend.  We need to suspend all functions separately.
+ * SDIO pre_suspend.  We need to suspend all functions separately.
  * Therefore all registered functions must have drivers with suspend
  * and resume methods.  Failing that we simply remove the whole card.
  */
-static int mmc_sdio_suspend(struct mmc_host *host)
+static int mmc_sdio_pre_suspend(struct mmc_host *host)
 {
 	int i, err = 0;
 
@@ -925,8 +925,26 @@ static int mmc_sdio_suspend(struct mmc_host *host)
 			if (!pmops || !pmops->suspend || !pmops->resume) {
 				/* force removal of entire card in that case */
 				err = -ENOSYS;
-			} else
-				err = pmops->suspend(&func->dev);
+				break;
+			}
+		}
+	}
+
+	return err;
+}
+
+/*
+ * SDIO suspend.  Suspend all functions separately.
+ */
+static int mmc_sdio_suspend(struct mmc_host *host)
+{
+	int i, err = 0;
+
+	for (i = 0; i < host->card->sdio_funcs; i++) {
+		struct sdio_func *func = host->card->sdio_func[i];
+		if (func && sdio_func_present(func) && func->dev.driver) {
+			const struct dev_pm_ops *pmops = func->dev.driver->pm;
+			err = pmops->suspend(&func->dev);
 			if (err)
 				break;
 		}
@@ -1076,6 +1094,7 @@ static int mmc_sdio_runtime_resume(struct mmc_host *host)
 static const struct mmc_bus_ops mmc_sdio_ops = {
 	.remove = mmc_sdio_remove,
 	.detect = mmc_sdio_detect,
+	.pre_suspend = mmc_sdio_pre_suspend,
 	.suspend = mmc_sdio_suspend,
 	.resume = mmc_sdio_resume,
 	.runtime_suspend = mmc_sdio_runtime_suspend,

commit 12d01d0b813b93e7bde1b5f468b5c85aa8b33590
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu May 2 14:02:37 2013 +0200

    mmc: core: Add bus_ops for runtime pm callbacks
    
    SDIO is the only protocol that uses runtime pm for the card device
    right now. To provide the option for sd and mmc to use runtime pm as
    well the bus_ops callback are extended with two new functions. One for
    runtime_suspend and one for runtime_resume.
    
    This patch will also implement the callbacks for SDIO to make sure
    existing functionality is maintained. It also prepares to move
    away from using the mmc_power_restore_host API, since it is not
    needed when using runtime PM.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 444668c210b2..1fbbd1bc55ec 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -1059,11 +1059,27 @@ static int mmc_sdio_power_restore(struct mmc_host *host)
 	return ret;
 }
 
+static int mmc_sdio_runtime_suspend(struct mmc_host *host)
+{
+	/* No references to the card, cut the power to it. */
+	mmc_power_off(host);
+	return 0;
+}
+
+static int mmc_sdio_runtime_resume(struct mmc_host *host)
+{
+	/* Restore power and re-initialize. */
+	mmc_power_up(host);
+	return mmc_sdio_power_restore(host);
+}
+
 static const struct mmc_bus_ops mmc_sdio_ops = {
 	.remove = mmc_sdio_remove,
 	.detect = mmc_sdio_detect,
 	.suspend = mmc_sdio_suspend,
 	.resume = mmc_sdio_resume,
+	.runtime_suspend = mmc_sdio_runtime_suspend,
+	.runtime_resume = mmc_sdio_runtime_resume,
 	.power_restore = mmc_sdio_power_restore,
 	.alive = mmc_sdio_alive,
 };

commit 810e08ee425f8d7327e4b30069a9b2b3dccfc67d
Author: Fredrik Soderstedt <fredrik.soderstedt@stericsson.com>
Date:   Wed Apr 17 13:50:53 2013 +0200

    mmc: core: Only execute tuning for SDR50 and SDR104
    
    Only execute tuning for sd and sdio devices that are using
    SDR50 or SDR104.
    
    Make sure clock is hold during tuning for sdio devices.
    
    Signed-off-by: Fredrik Soderstedt <fredrik.soderstedt@stericsson.com>
    Acked-by: Johan Rudholm <jrudholm@gmail.com>
    Acked-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 6889a821c1da..444668c210b2 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -563,10 +563,18 @@ static int mmc_sdio_init_uhs_card(struct mmc_card *card)
 	if (err)
 		goto out;
 
-	/* Initialize and start re-tuning timer */
-	if (!mmc_host_is_spi(card->host) && card->host->ops->execute_tuning)
+	/*
+	 * SPI mode doesn't define CMD19 and tuning is only valid for SDR50 and
+	 * SDR104 mode SD-cards. Note that tuning is mandatory for SDR104.
+	 */
+	if (!mmc_host_is_spi(card->host) && card->host->ops->execute_tuning &&
+			((card->sw_caps.sd3_bus_mode & SD_MODE_UHS_SDR50) ||
+			 (card->sw_caps.sd3_bus_mode & SD_MODE_UHS_SDR104))) {
+		mmc_host_clk_hold(card->host);
 		err = card->host->ops->execute_tuning(card->host,
 						      MMC_SEND_TUNING_BLOCK);
+		mmc_host_clk_release(card->host);
+	}
 
 out:
 

commit 3bffb800b91bb128b61d83deb01ce63c455d108f
Author: Li Fei <fei.li@intel.com>
Date:   Mon Apr 8 09:36:39 2013 +0800

    mmc: core: call pm_runtime_put_noidle in pm_runtime_get_sync failed case
    
    Even in failed case of pm_runtime_get_sync, the usage_count
    is incremented. In order to keep the usage_count with correct
    value and runtime power management to behave correctly, call
    pm_runtime_put_noidle in such case.
    
    Signed-off-by: Liu Chuansheng <chuansheng.liu@intel.com>
    Signed-off-by: Li Fei <fei.li@intel.com>
    Acked-by: Ohad Ben-Cohen <ohad@wizery.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index aa0719a4dfd1..6889a821c1da 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -861,8 +861,10 @@ static void mmc_sdio_detect(struct mmc_host *host)
 	/* Make sure card is powered before detecting it */
 	if (host->caps & MMC_CAP_POWER_OFF_CARD) {
 		err = pm_runtime_get_sync(&host->card->dev);
-		if (err < 0)
+		if (err < 0) {
+			pm_runtime_put_noidle(&host->card->dev);
 			goto out;
+		}
 	}
 
 	mmc_claim_host(host);

commit 0797e5f1453b2bedc08bbcbea0ea4fbe20350823
Author: Johan Rudholm <johan.rudholm@stericsson.com>
Date:   Mon Jan 28 15:08:28 2013 +0100

    mmc: core: Fixup signal voltage switch
    
    When switching SD and SDIO cards from 3.3V to 1.8V signal levels, the
    clock should be gated for 5 ms during the step. After enabling the
    clock, the host should wait for at least 1 ms before checking for
    failure. Failure by the card to switch is indicated by dat[0:3] being
    pulled low. The host should check for this condition and power-cycle
    the card if failure is indicated.
    
    Add a retry mechanism for the SDIO case.
    
    If the voltage switch fails repeatedly, give up and continue the
    initialization using the original voltage.
    
    This patch places a couple of requirements on the host driver:
    
     1) mmc_set_ios with ios.clock = 0 must gate the clock
     2) mmc_power_off must actually cut the power to the card
     3) The card_busy host_ops member must be implemented
    
    if these requirements are not fulfilled, the 1.8V signal voltage switch
    will still be attempted but may not be successful.
    
    Signed-off-by: Johan Rudholm <johan.rudholm@stericsson.com>
    Signed-off-by: Kevin Liu <kliu5@marvell.com>
    Acked-by: Ulf Hansson <ulf.hansson@linaro.org>
    Tested-by: Wei WANG <wei_wang@realsil.com.cn>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 1a726aef211d..aa0719a4dfd1 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -584,10 +584,19 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 {
 	struct mmc_card *card;
 	int err;
+	int retries = 10;
 
 	BUG_ON(!host);
 	WARN_ON(!host->claimed);
 
+try_again:
+	if (!retries) {
+		pr_warning("%s: Skipping voltage switch\n",
+				mmc_hostname(host));
+		ocr &= ~R4_18V_PRESENT;
+		host->ocr &= ~R4_18V_PRESENT;
+	}
+
 	/*
 	 * Inform the card of the voltage
 	 */
@@ -646,9 +655,16 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 	 * systems that claim 1.8v signalling in fact do not support
 	 * it.
 	 */
-	if ((ocr & R4_18V_PRESENT) && mmc_host_uhs(host)) {
+	if (!powered_resume && (ocr & R4_18V_PRESENT) && mmc_host_uhs(host)) {
 		err = mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_180);
-		if (err) {
+		if (err == -EAGAIN) {
+			sdio_reset(host);
+			mmc_go_idle(host);
+			mmc_send_if_cond(host, host->ocr_avail);
+			mmc_remove_card(card);
+			retries--;
+			goto try_again;
+		} else if (err) {
 			ocr &= ~R4_18V_PRESENT;
 			host->ocr &= ~R4_18V_PRESENT;
 		}

commit 567c89032cfdda8047562abe450947ac01f2d3c7
Author: Johan Rudholm <johan.rudholm@stericsson.com>
Date:   Mon Jan 28 15:08:27 2013 +0100

    mmc: core: Break out start_signal_voltage_switch
    
    Allow callers to access the start_signal_voltage_switch host_ops
    member without going through any cmd11 logic. This is mostly a
    preparation for the following signal voltage switch patch.
    
    Also, reset ios.signal_voltage to its original value if
    start_signal_voltage_switch fails.
    
    Signed-off-by: Johan Rudholm <johan.rudholm@stericsson.com>
    Acked-by: Ulf Hansson <ulf.hansson@linaro.org>
    Tested-by: Wei WANG <wei_wang@realsil.com.cn>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 3a64933466b8..1a726aef211d 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -647,8 +647,7 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 	 * it.
 	 */
 	if ((ocr & R4_18V_PRESENT) && mmc_host_uhs(host)) {
-		err = mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_180,
-				true);
+		err = mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_180);
 		if (err) {
 			ocr &= ~R4_18V_PRESENT;
 			host->ocr &= ~R4_18V_PRESENT;

commit 77e2ff08925c7ec7267dc87c27eda2e62d585b57
Author: Subhash Jadavani <subhashj@codeaurora.org>
Date:   Tue Dec 4 17:06:20 2012 +0530

    mmc: sdio: print correct UHS mode during card detection
    
    When SDIO3.0 card is detected, incorrect bus speed mode
    is printed as part of card detection print in kernel logs.
    
    This change fixes it so that user won't be confused by
    looking at incorrect card detection message in logs.
    
    Signed-off-by: Subhash Jadavani <subhashj@codeaurora.org>
    Tested-by: Jackey Shen <Jackey.Shen@amd.com>
    Acked-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 9565d38d91a4..3a64933466b8 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -485,23 +485,27 @@ static int sdio_set_bus_speed_mode(struct mmc_card *card)
 			bus_speed = SDIO_SPEED_SDR104;
 			timing = MMC_TIMING_UHS_SDR104;
 			card->sw_caps.uhs_max_dtr = UHS_SDR104_MAX_DTR;
+			card->sd_bus_speed = UHS_SDR104_BUS_SPEED;
 	} else if ((card->host->caps & MMC_CAP_UHS_DDR50) &&
 		   (card->sw_caps.sd3_bus_mode & SD_MODE_UHS_DDR50)) {
 			bus_speed = SDIO_SPEED_DDR50;
 			timing = MMC_TIMING_UHS_DDR50;
 			card->sw_caps.uhs_max_dtr = UHS_DDR50_MAX_DTR;
+			card->sd_bus_speed = UHS_DDR50_BUS_SPEED;
 	} else if ((card->host->caps & (MMC_CAP_UHS_SDR104 |
 		    MMC_CAP_UHS_SDR50)) && (card->sw_caps.sd3_bus_mode &
 		    SD_MODE_UHS_SDR50)) {
 			bus_speed = SDIO_SPEED_SDR50;
 			timing = MMC_TIMING_UHS_SDR50;
 			card->sw_caps.uhs_max_dtr = UHS_SDR50_MAX_DTR;
+			card->sd_bus_speed = UHS_SDR50_BUS_SPEED;
 	} else if ((card->host->caps & (MMC_CAP_UHS_SDR104 |
 		    MMC_CAP_UHS_SDR50 | MMC_CAP_UHS_SDR25)) &&
 		   (card->sw_caps.sd3_bus_mode & SD_MODE_UHS_SDR25)) {
 			bus_speed = SDIO_SPEED_SDR25;
 			timing = MMC_TIMING_UHS_SDR25;
 			card->sw_caps.uhs_max_dtr = UHS_SDR25_MAX_DTR;
+			card->sd_bus_speed = UHS_SDR25_BUS_SPEED;
 	} else if ((card->host->caps & (MMC_CAP_UHS_SDR104 |
 		    MMC_CAP_UHS_SDR50 | MMC_CAP_UHS_SDR25 |
 		    MMC_CAP_UHS_SDR12)) && (card->sw_caps.sd3_bus_mode &
@@ -509,6 +513,7 @@ static int sdio_set_bus_speed_mode(struct mmc_card *card)
 			bus_speed = SDIO_SPEED_SDR12;
 			timing = MMC_TIMING_UHS_SDR12;
 			card->sw_caps.uhs_max_dtr = UHS_SDR12_MAX_DTR;
+			card->sd_bus_speed = UHS_SDR12_BUS_SPEED;
 	}
 
 	err = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_SPEED, 0, &speed);

commit 41875e388401ad97c33252d5fa39d52e0b70ee9b
Author: Sujit Reddy Thumma <sthumma@codeaurora.org>
Date:   Tue Dec 4 17:06:19 2012 +0530

    mmc: sdio: Fix SDIO 3.0 UHS-I initialization sequence
    
    According to UHS-I initialization sequence for SDIO 3.0 cards,
    the host must set bit[24] (S18R) of OCR register during OCR
    handshake to know whether the SDIO card is capable of doing
    1.8V I/O.
    
    Signed-off-by: Sujit Reddy Thumma <sthumma@codeaurora.org>
    Signed-off-by: Subhash Jadavani <subhashj@codeaurora.org>
    Reviewed-by: Johan Rudholm <johan.rudholm@stericsson.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 34ad4c877c1f..9565d38d91a4 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -157,10 +157,7 @@ static int sdio_read_cccr(struct mmc_card *card, u32 ocr)
 			if (ret)
 				goto out;
 
-			if (card->host->caps &
-				(MMC_CAP_UHS_SDR12 | MMC_CAP_UHS_SDR25 |
-				 MMC_CAP_UHS_SDR50 | MMC_CAP_UHS_SDR104 |
-				 MMC_CAP_UHS_DDR50)) {
+			if (mmc_host_uhs(card->host)) {
 				if (data & SDIO_UHS_DDR50)
 					card->sw_caps.sd3_bus_mode
 						|= SD_MODE_UHS_DDR50;
@@ -478,8 +475,7 @@ static int sdio_set_bus_speed_mode(struct mmc_card *card)
 	 * If the host doesn't support any of the UHS-I modes, fallback on
 	 * default speed.
 	 */
-	if (!(card->host->caps & (MMC_CAP_UHS_SDR12 | MMC_CAP_UHS_SDR25 |
-	    MMC_CAP_UHS_SDR50 | MMC_CAP_UHS_SDR104 | MMC_CAP_UHS_DDR50)))
+	if (!mmc_host_uhs(card->host))
 		return 0;
 
 	bus_speed = SDIO_SPEED_SDR12;
@@ -645,11 +641,7 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 	 * systems that claim 1.8v signalling in fact do not support
 	 * it.
 	 */
-	if ((ocr & R4_18V_PRESENT) &&
-		(host->caps &
-			(MMC_CAP_UHS_SDR12 | MMC_CAP_UHS_SDR25 |
-			 MMC_CAP_UHS_SDR50 | MMC_CAP_UHS_SDR104 |
-			 MMC_CAP_UHS_DDR50))) {
+	if ((ocr & R4_18V_PRESENT) && mmc_host_uhs(host)) {
 		err = mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_180,
 				true);
 		if (err) {
@@ -1022,6 +1014,10 @@ static int mmc_sdio_power_restore(struct mmc_host *host)
 		goto out;
 	}
 
+	if (mmc_host_uhs(host))
+		/* to query card if 1.8V signalling is supported */
+		host->ocr |= R4_18V_PRESENT;
+
 	ret = mmc_sdio_init_card(host, host->ocr, host->card,
 				mmc_card_keep_power(host));
 	if (!ret && host->sdio_irqs)
@@ -1087,6 +1083,10 @@ int mmc_attach_sdio(struct mmc_host *host)
 	/*
 	 * Detect and init the card.
 	 */
+	if (mmc_host_uhs(host))
+		/* to query card if 1.8V signalling is supported */
+		host->ocr |= R4_18V_PRESENT;
+
 	err = mmc_sdio_init_card(host, host->ocr, NULL, 0);
 	if (err) {
 		if (err == -EAGAIN) {

commit 51aa66a58494f869f491eedda86c409c50536c14
Author: Subhash Jadavani <subhashj@codeaurora.org>
Date:   Tue Dec 4 17:06:18 2012 +0530

    mmc: sdio: fix resume failure due to lack of CMD52 reset
    
    If SDIO keep power flag (MMC_PM_KEEP_POWER) is not set, card would
    be reinitialized during resume but as we are not resetting
    (CMD52 reset) the SDIO card during this reinitialization, card may
    fail to respond back to subsequent commands (CMD5 etc...).
    
    This change resets the card before the reinitialization of card
    during resume.
    
    Signed-off-by: Subhash Jadavani <subhashj@codeaurora.org>
    Acked-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 2273ce6b6c1a..34ad4c877c1f 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -937,10 +937,12 @@ static int mmc_sdio_resume(struct mmc_host *host)
 	mmc_claim_host(host);
 
 	/* No need to reinitialize powered-resumed nonremovable cards */
-	if (mmc_card_is_removable(host) || !mmc_card_keep_power(host))
+	if (mmc_card_is_removable(host) || !mmc_card_keep_power(host)) {
+		sdio_reset(host);
+		mmc_go_idle(host);
 		err = mmc_sdio_init_card(host, host->ocr, host->card,
 					mmc_card_keep_power(host));
-	else if (mmc_card_keep_power(host) && mmc_card_wake_sdio_irq(host)) {
+	} else if (mmc_card_keep_power(host) && mmc_card_wake_sdio_irq(host)) {
 		/* We may have switched to 1-bit mode during suspend */
 		err = sdio_enable_4bit_bus(host->card);
 		if (err > 0) {

commit 7122bbb0d14b7a6031aeef046b45d4934cb94ba7
Author: Masanari Iida <standby24x7@gmail.com>
Date:   Sun Aug 5 23:25:40 2012 +0900

    mmc: fix comment typos
    
    Correct spelling typo in drivers/mmc
    
    Signed-off-by: Masanari Iida <standby24x7@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index d4619e2ec030..2273ce6b6c1a 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -641,7 +641,7 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 	/*
 	 * If the host and card support UHS-I mode request the card
 	 * to switch to 1.8V signaling level.  No 1.8v signalling if
-	 * UHS mode is not enabled to maintain compatibilty and some
+	 * UHS mode is not enabled to maintain compatibility and some
 	 * systems that claim 1.8v signalling in fact do not support
 	 * it.
 	 */

commit 108ecc4cf9c46a4caabaf18efc42d19818c95b70
Author: Aaron Lu <aaron.lu@amd.com>
Date:   Tue Jul 10 16:55:37 2012 +0800

    mmc: core: reset signal voltage on power up
    
    Add a call to mmc_set_signal_voltage() to set signal voltage to 3.3v in
    mmc_power_up so that we do not need to touch signal voltage setting in
    mmc/sd/sdio init functions and rescan function.
    
    For mmc/sd cards, when doing a suspend/resume cycle, consider the unsafe
    resume case, the card will lose its power and when powered on again, we
    will set signal voltage to 3.3v in mmc_power_up before its resume function
    gets called, which will re-init the card.
    
    And for sdio cards, when doing a suspend/resume cycle, consider the unsafe
    resume case, the card will either lose its power or not depending on if it
    wants to wakeup the host. If power is not maintained, it is the same case as
    mmc/sd cards. If power is maintained, mmc_power_up will not be called and
    the card's signal voltage will remain at the last setting.
    
    Signed-off-by: Aaron Lu <aaron.lu@amd.com>
    Tested-by: Venkatraman S <svenkatr@ti.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 41c5fd8848f4..d4619e2ec030 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -591,9 +591,6 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 	 * Inform the card of the voltage
 	 */
 	if (!powered_resume) {
-		/* The initialization should be done at 3.3 V I/O voltage. */
-		mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_330, 0);
-
 		err = mmc_send_io_op_cond(host, host->ocr, &ocr);
 		if (err)
 			goto err;
@@ -1006,10 +1003,6 @@ static int mmc_sdio_power_restore(struct mmc_host *host)
 	 * restore the correct voltage setting of the card.
 	 */
 
-	/* The initialization should be done at 3.3 V I/O voltage. */
-	if (!mmc_card_keep_power(host))
-		mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_330, 0);
-
 	sdio_reset(host);
 	mmc_go_idle(host);
 	mmc_send_if_cond(host, host->ocr_avail);

commit 2a0fe914a38745f5b03534c4e4f4056cbd6978b8
Author: Yong Ding <yongd@marvell.com>
Date:   Tue May 15 13:09:43 2012 +0800

    mmc: sdio: fix setting card data bus width as 4-bit
    
    SDIO_CCCR_IF[1:0] in SDIO card is used for card data bus width
    setting as below:
    
         00b: 1-bit bus
         01b: Reserved
         10b: 4-bit bus
         11b: 8-bit bus (only for embedded SDIO)
    
    And sdio_enable_wide is for setting data bus width as 4-bit.
    But currently, it first reads the register, second OR' 1b with
    SDIO_CCCR_IF[1], and then writes it back.
    
    As we can see, this is based on such assumption that the
    SDIO_CCCR_IF[0] is always 0. Apparently, this is not right.
    
    Signed-off-by: Yong Ding <yongd@marvell.com>
    Acked-by: Philip Rakity <prakity@marvell.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 13d0e95380ab..41c5fd8848f4 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -218,6 +218,12 @@ static int sdio_enable_wide(struct mmc_card *card)
 	if (ret)
 		return ret;
 
+	if ((ctrl & SDIO_BUS_WIDTH_MASK) == SDIO_BUS_WIDTH_RESERVED)
+		pr_warning("%s: SDIO_CCCR_IF is invalid: 0x%02x\n",
+			   mmc_hostname(card->host), ctrl);
+
+	/* set as 4-bit bus width */
+	ctrl &= ~SDIO_BUS_WIDTH_MASK;
 	ctrl |= SDIO_BUS_WIDTH_4BIT;
 
 	ret = mmc_io_rw_direct(card, 1, 0, SDIO_CCCR_IF, ctrl, NULL);

commit bbbc4c4d8c5face097d695f9bf3a39647ba6b7e7
Author: Nicolas Pitre <nicolas.pitre@linaro.org>
Date:   Mon Apr 16 19:16:54 2012 -0400

    mmc: sdio: avoid spurious calls to interrupt handlers
    
    Commit 06e8935feb ("optimized SDIO IRQ handling for single irq")
    introduced some spurious calls to SDIO function interrupt handlers,
    such as when the SDIO IRQ thread is started, or the safety check
    performed upon a system resume.  Let's add a flag to perform the
    optimization only when a real interrupt is signaled by the host
    driver and we know there is no point confirming it.
    
    Reported-by: Sujit Reddy Thumma <sthumma@codeaurora.org>
    Signed-off-by: Nicolas Pitre <nico@linaro.org>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 2c7c83f832d2..13d0e95380ab 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -947,7 +947,7 @@ static int mmc_sdio_resume(struct mmc_host *host)
 	}
 
 	if (!err && host->sdio_irqs)
-		mmc_signal_sdio_irq(host);
+		wake_up_process(host->sdio_irq_thread);
 	mmc_release_host(host);
 
 	/*

commit e7747475b61fdc2a4a412475a9d64d8c309916e3
Author: Ulf Hansson <ulf.hansson@stericsson.com>
Date:   Thu Mar 1 13:18:05 2012 +0100

    mmc: core: Fixup suspend/resume issues for UHS-I cards
    
    Even if cards supports 1.8V I/O voltage those should anyway be
    initialized at 3.3V I/O according to (e)MMC, SD and SDIO specs.
    Some eMMC and embedded SDIO devices are able to be initialized
    at 1.8V as well, but it is better to be safe.
    
    Do note that initialization in this context means that the card
    has been completely powered off, otherwise the card will remain
    at the last I/O voltage level that were negotitiated.
    
    Due to the above being taken care of the suspend/resume issues
    for UHS-I SD-cards has been fixed.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@stericsson.com>
    Acked-by: Philip Rakity <prakity@marvell.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Tested-by: Subhash Jadavani <subhashj@codeaurora.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 12cde6ee17f5..2c7c83f832d2 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -585,6 +585,9 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 	 * Inform the card of the voltage
 	 */
 	if (!powered_resume) {
+		/* The initialization should be done at 3.3 V I/O voltage. */
+		mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_330, 0);
+
 		err = mmc_send_io_op_cond(host, host->ocr, &ocr);
 		if (err)
 			goto err;
@@ -996,6 +999,11 @@ static int mmc_sdio_power_restore(struct mmc_host *host)
 	 * With these steps taken, mmc_select_voltage() is also required to
 	 * restore the correct voltage setting of the card.
 	 */
+
+	/* The initialization should be done at 3.3 V I/O voltage. */
+	if (!mmc_card_keep_power(host))
+		mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_330, 0);
+
 	sdio_reset(host);
 	mmc_go_idle(host);
 	mmc_send_if_cond(host, host->ocr_avail);

commit 2d0d68f583279dbdcc1a2ef3f81ea8d285a0adbe
Author: Philip Rakity <prakity@marvell.com>
Date:   Thu Jan 26 06:57:10 2012 -0800

    mmc: core: UHS sdio card that fails should not exceed 50MHz
    
    A UHS sdio card that fails initialization at 1.8v signaling is not in
    UHS mode.  We cannot use the speed in the the cis to reflect the bus
    speed as this is the maxiumum value and will not reflect the fact
    that the host is operating at a lower (non uhs) bus speed.
    
    Signed-off-by: Philip Rakity <prakity@marvell.com>
    Signed-off-by: Bing Zhao <bzhao@marvell.com>
    Reviewed-by: Aaron Lu <aaron.lu@amd.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index bd7bacc950dc..12cde6ee17f5 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -98,10 +98,11 @@ static int sdio_init_func(struct mmc_card *card, unsigned int fn)
 	return ret;
 }
 
-static int sdio_read_cccr(struct mmc_card *card)
+static int sdio_read_cccr(struct mmc_card *card, u32 ocr)
 {
 	int ret;
 	int cccr_vsn;
+	int uhs = ocr & R4_18V_PRESENT;
 	unsigned char data;
 	unsigned char speed;
 
@@ -149,7 +150,7 @@ static int sdio_read_cccr(struct mmc_card *card)
 		card->scr.sda_spec3 = 0;
 		card->sw_caps.sd3_bus_mode = 0;
 		card->sw_caps.sd3_drv_type = 0;
-		if (cccr_vsn >= SDIO_CCCR_REV_3_00) {
+		if (cccr_vsn >= SDIO_CCCR_REV_3_00 && uhs) {
 			card->scr.sda_spec3 = 1;
 			ret = mmc_io_rw_direct(card, 0, 0,
 				SDIO_CCCR_UHS, 0, &data);
@@ -712,7 +713,7 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 	/*
 	 * Read the common registers.
 	 */
-	err = sdio_read_cccr(card);
+	err = sdio_read_cccr(card, ocr);
 	if (err)
 		goto remove;
 

commit a4924c71aa43d4f8a3f342b1f71788349472e684
Author: Girish K S <girish.shivananjappa@linaro.org>
Date:   Wed Jan 11 14:04:52 2012 -0500

    mmc: core: HS200 mode support for eMMC 4.5
    
    This patch adds the support of the HS200 bus speed for eMMC 4.5 devices.
    The eMMC 4.5 devices have support for 200MHz bus speed. The function
    prototype of the tuning function is modified to handle the tuning
    command number which is different in sd and mmc case.
    
    Signed-off-by: Girish K S <girish.shivananjappa@linaro.org>
    Signed-off-by: Philip Rakity <prakity@marvell.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index b77f770ce5d1..bd7bacc950dc 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -14,6 +14,7 @@
 
 #include <linux/mmc/host.h>
 #include <linux/mmc/card.h>
+#include <linux/mmc/mmc.h>
 #include <linux/mmc/sdio.h>
 #include <linux/mmc/sdio_func.h>
 #include <linux/mmc/sdio_ids.h>
@@ -556,7 +557,8 @@ static int mmc_sdio_init_uhs_card(struct mmc_card *card)
 
 	/* Initialize and start re-tuning timer */
 	if (!mmc_host_is_spi(card->host) && card->host->ops->execute_tuning)
-		err = card->host->ops->execute_tuning(card->host);
+		err = card->host->ops->execute_tuning(card->host,
+						      MMC_SEND_TUNING_BLOCK);
 
 out:
 

commit d30495048892980e5d453328d1cc9343b3f7e917
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Mon Nov 28 16:22:00 2011 +0200

    mmc: allow upper layers to know immediately if card has been removed
    
    Add a function mmc_detect_card_removed() which upper layers can use to
    determine immediately if a card has been removed. This function should
    be called after an I/O request fails so that all queued I/O requests
    can be errored out immediately instead of waiting for the card device
    to be removed.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Acked-by: Sujit Reddy Thumma <sthumma@codeaurora.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 8c04f7f46dec..b77f770ce5d1 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -819,6 +819,14 @@ static void mmc_sdio_remove(struct mmc_host *host)
 	host->card = NULL;
 }
 
+/*
+ * Card detection - card is alive.
+ */
+static int mmc_sdio_alive(struct mmc_host *host)
+{
+	return mmc_select_card(host->card);
+}
+
 /*
  * Card detection callback from host.
  */
@@ -841,7 +849,7 @@ static void mmc_sdio_detect(struct mmc_host *host)
 	/*
 	 * Just check if our card has been removed.
 	 */
-	err = mmc_select_card(host->card);
+	err = _mmc_detect_card_removed(host);
 
 	mmc_release_host(host);
 
@@ -1019,6 +1027,7 @@ static const struct mmc_bus_ops mmc_sdio_ops = {
 	.suspend = mmc_sdio_suspend,
 	.resume = mmc_sdio_resume,
 	.power_restore = mmc_sdio_power_restore,
+	.alive = mmc_sdio_alive,
 };
 
 

commit a303c5319c8e6ab0e744ebca118da8420043b2c3
Author: Philip Rakity <prakity@marvell.com>
Date:   Mon Nov 14 19:14:38 2011 -0800

    mmc: sdio: support SDIO UHS cards
    
    This patch adds support for sdio UHS cards per the version 3.0
    spec.
    
    UHS mode is only enabled for version 3.0 cards when both the
    host and the controller support UHS modes.
    
    1.8v signaling support is removed if both the card and the
    host do not support UHS.  This is done to maintain
    compatibility and some system/card combinations break when
    1.8v signaling is enabled when the host does not support UHS.
    
    Signed-off-by: Philip Rakity <prakity@marvell.com>
    Signed-off-by: Aaron Lu <Aaron.lu@amd.com>
    Reviewed-by: Arindam Nath <arindam.nath@amd.com>
    Tested-by: Bing Zhao <bzhao@marvell.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 3ab565e32a6a..8c04f7f46dec 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -102,6 +102,7 @@ static int sdio_read_cccr(struct mmc_card *card)
 	int ret;
 	int cccr_vsn;
 	unsigned char data;
+	unsigned char speed;
 
 	memset(&card->cccr, 0, sizeof(struct sdio_cccr));
 
@@ -140,12 +141,60 @@ static int sdio_read_cccr(struct mmc_card *card)
 	}
 
 	if (cccr_vsn >= SDIO_CCCR_REV_1_20) {
-		ret = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_SPEED, 0, &data);
+		ret = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_SPEED, 0, &speed);
 		if (ret)
 			goto out;
 
-		if (data & SDIO_SPEED_SHS)
-			card->cccr.high_speed = 1;
+		card->scr.sda_spec3 = 0;
+		card->sw_caps.sd3_bus_mode = 0;
+		card->sw_caps.sd3_drv_type = 0;
+		if (cccr_vsn >= SDIO_CCCR_REV_3_00) {
+			card->scr.sda_spec3 = 1;
+			ret = mmc_io_rw_direct(card, 0, 0,
+				SDIO_CCCR_UHS, 0, &data);
+			if (ret)
+				goto out;
+
+			if (card->host->caps &
+				(MMC_CAP_UHS_SDR12 | MMC_CAP_UHS_SDR25 |
+				 MMC_CAP_UHS_SDR50 | MMC_CAP_UHS_SDR104 |
+				 MMC_CAP_UHS_DDR50)) {
+				if (data & SDIO_UHS_DDR50)
+					card->sw_caps.sd3_bus_mode
+						|= SD_MODE_UHS_DDR50;
+
+				if (data & SDIO_UHS_SDR50)
+					card->sw_caps.sd3_bus_mode
+						|= SD_MODE_UHS_SDR50;
+
+				if (data & SDIO_UHS_SDR104)
+					card->sw_caps.sd3_bus_mode
+						|= SD_MODE_UHS_SDR104;
+			}
+
+			ret = mmc_io_rw_direct(card, 0, 0,
+				SDIO_CCCR_DRIVE_STRENGTH, 0, &data);
+			if (ret)
+				goto out;
+
+			if (data & SDIO_DRIVE_SDTA)
+				card->sw_caps.sd3_drv_type |= SD_DRIVER_TYPE_A;
+			if (data & SDIO_DRIVE_SDTC)
+				card->sw_caps.sd3_drv_type |= SD_DRIVER_TYPE_C;
+			if (data & SDIO_DRIVE_SDTD)
+				card->sw_caps.sd3_drv_type |= SD_DRIVER_TYPE_D;
+		}
+
+		/* if no uhs mode ensure we check for high speed */
+		if (!card->sw_caps.sd3_bus_mode) {
+			if (speed & SDIO_SPEED_SHS) {
+				card->cccr.high_speed = 1;
+				card->sw_caps.hs_max_dtr = 50000000;
+			} else {
+				card->cccr.high_speed = 0;
+				card->sw_caps.hs_max_dtr = 25000000;
+			}
+		}
 	}
 
 out:
@@ -327,6 +376,193 @@ static unsigned mmc_sdio_get_max_clock(struct mmc_card *card)
 	return max_dtr;
 }
 
+static unsigned char host_drive_to_sdio_drive(int host_strength)
+{
+	switch (host_strength) {
+	case MMC_SET_DRIVER_TYPE_A:
+		return SDIO_DTSx_SET_TYPE_A;
+	case MMC_SET_DRIVER_TYPE_B:
+		return SDIO_DTSx_SET_TYPE_B;
+	case MMC_SET_DRIVER_TYPE_C:
+		return SDIO_DTSx_SET_TYPE_C;
+	case MMC_SET_DRIVER_TYPE_D:
+		return SDIO_DTSx_SET_TYPE_D;
+	default:
+		return SDIO_DTSx_SET_TYPE_B;
+	}
+}
+
+static void sdio_select_driver_type(struct mmc_card *card)
+{
+	int host_drv_type = SD_DRIVER_TYPE_B;
+	int card_drv_type = SD_DRIVER_TYPE_B;
+	int drive_strength;
+	unsigned char card_strength;
+	int err;
+
+	/*
+	 * If the host doesn't support any of the Driver Types A,C or D,
+	 * or there is no board specific handler then default Driver
+	 * Type B is used.
+	 */
+	if (!(card->host->caps &
+		(MMC_CAP_DRIVER_TYPE_A |
+		 MMC_CAP_DRIVER_TYPE_C |
+		 MMC_CAP_DRIVER_TYPE_D)))
+		return;
+
+	if (!card->host->ops->select_drive_strength)
+		return;
+
+	if (card->host->caps & MMC_CAP_DRIVER_TYPE_A)
+		host_drv_type |= SD_DRIVER_TYPE_A;
+
+	if (card->host->caps & MMC_CAP_DRIVER_TYPE_C)
+		host_drv_type |= SD_DRIVER_TYPE_C;
+
+	if (card->host->caps & MMC_CAP_DRIVER_TYPE_D)
+		host_drv_type |= SD_DRIVER_TYPE_D;
+
+	if (card->sw_caps.sd3_drv_type & SD_DRIVER_TYPE_A)
+		card_drv_type |= SD_DRIVER_TYPE_A;
+
+	if (card->sw_caps.sd3_drv_type & SD_DRIVER_TYPE_C)
+		card_drv_type |= SD_DRIVER_TYPE_C;
+
+	if (card->sw_caps.sd3_drv_type & SD_DRIVER_TYPE_D)
+		card_drv_type |= SD_DRIVER_TYPE_D;
+
+	/*
+	 * The drive strength that the hardware can support
+	 * depends on the board design.  Pass the appropriate
+	 * information and let the hardware specific code
+	 * return what is possible given the options
+	 */
+	drive_strength = card->host->ops->select_drive_strength(
+		card->sw_caps.uhs_max_dtr,
+		host_drv_type, card_drv_type);
+
+	/* if error just use default for drive strength B */
+	err = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_DRIVE_STRENGTH, 0,
+		&card_strength);
+	if (err)
+		return;
+
+	card_strength &= ~(SDIO_DRIVE_DTSx_MASK<<SDIO_DRIVE_DTSx_SHIFT);
+	card_strength |= host_drive_to_sdio_drive(drive_strength);
+
+	err = mmc_io_rw_direct(card, 1, 0, SDIO_CCCR_DRIVE_STRENGTH,
+		card_strength, NULL);
+
+	/* if error default to drive strength B */
+	if (!err)
+		mmc_set_driver_type(card->host, drive_strength);
+}
+
+
+static int sdio_set_bus_speed_mode(struct mmc_card *card)
+{
+	unsigned int bus_speed, timing;
+	int err;
+	unsigned char speed;
+
+	/*
+	 * If the host doesn't support any of the UHS-I modes, fallback on
+	 * default speed.
+	 */
+	if (!(card->host->caps & (MMC_CAP_UHS_SDR12 | MMC_CAP_UHS_SDR25 |
+	    MMC_CAP_UHS_SDR50 | MMC_CAP_UHS_SDR104 | MMC_CAP_UHS_DDR50)))
+		return 0;
+
+	bus_speed = SDIO_SPEED_SDR12;
+	timing = MMC_TIMING_UHS_SDR12;
+	if ((card->host->caps & MMC_CAP_UHS_SDR104) &&
+	    (card->sw_caps.sd3_bus_mode & SD_MODE_UHS_SDR104)) {
+			bus_speed = SDIO_SPEED_SDR104;
+			timing = MMC_TIMING_UHS_SDR104;
+			card->sw_caps.uhs_max_dtr = UHS_SDR104_MAX_DTR;
+	} else if ((card->host->caps & MMC_CAP_UHS_DDR50) &&
+		   (card->sw_caps.sd3_bus_mode & SD_MODE_UHS_DDR50)) {
+			bus_speed = SDIO_SPEED_DDR50;
+			timing = MMC_TIMING_UHS_DDR50;
+			card->sw_caps.uhs_max_dtr = UHS_DDR50_MAX_DTR;
+	} else if ((card->host->caps & (MMC_CAP_UHS_SDR104 |
+		    MMC_CAP_UHS_SDR50)) && (card->sw_caps.sd3_bus_mode &
+		    SD_MODE_UHS_SDR50)) {
+			bus_speed = SDIO_SPEED_SDR50;
+			timing = MMC_TIMING_UHS_SDR50;
+			card->sw_caps.uhs_max_dtr = UHS_SDR50_MAX_DTR;
+	} else if ((card->host->caps & (MMC_CAP_UHS_SDR104 |
+		    MMC_CAP_UHS_SDR50 | MMC_CAP_UHS_SDR25)) &&
+		   (card->sw_caps.sd3_bus_mode & SD_MODE_UHS_SDR25)) {
+			bus_speed = SDIO_SPEED_SDR25;
+			timing = MMC_TIMING_UHS_SDR25;
+			card->sw_caps.uhs_max_dtr = UHS_SDR25_MAX_DTR;
+	} else if ((card->host->caps & (MMC_CAP_UHS_SDR104 |
+		    MMC_CAP_UHS_SDR50 | MMC_CAP_UHS_SDR25 |
+		    MMC_CAP_UHS_SDR12)) && (card->sw_caps.sd3_bus_mode &
+		    SD_MODE_UHS_SDR12)) {
+			bus_speed = SDIO_SPEED_SDR12;
+			timing = MMC_TIMING_UHS_SDR12;
+			card->sw_caps.uhs_max_dtr = UHS_SDR12_MAX_DTR;
+	}
+
+	err = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_SPEED, 0, &speed);
+	if (err)
+		return err;
+
+	speed &= ~SDIO_SPEED_BSS_MASK;
+	speed |= bus_speed;
+	err = mmc_io_rw_direct(card, 1, 0, SDIO_CCCR_SPEED, speed, NULL);
+	if (err)
+		return err;
+
+	if (bus_speed) {
+		mmc_set_timing(card->host, timing);
+		mmc_set_clock(card->host, card->sw_caps.uhs_max_dtr);
+	}
+
+	return 0;
+}
+
+/*
+ * UHS-I specific initialization procedure
+ */
+static int mmc_sdio_init_uhs_card(struct mmc_card *card)
+{
+	int err;
+
+	if (!card->scr.sda_spec3)
+		return 0;
+
+	/*
+	 * Switch to wider bus (if supported).
+	 */
+	if (card->host->caps & MMC_CAP_4_BIT_DATA) {
+		err = sdio_enable_4bit_bus(card);
+		if (err > 0) {
+			mmc_set_bus_width(card->host, MMC_BUS_WIDTH_4);
+			err = 0;
+		}
+	}
+
+	/* Set the driver strength for the card */
+	sdio_select_driver_type(card);
+
+	/* Set bus speed mode of the card */
+	err = sdio_set_bus_speed_mode(card);
+	if (err)
+		goto out;
+
+	/* Initialize and start re-tuning timer */
+	if (!mmc_host_is_spi(card->host) && card->host->ops->execute_tuning)
+		err = card->host->ops->execute_tuning(card->host);
+
+out:
+
+	return err;
+}
+
 /*
  * Handle the detection and initialisation of a card.
  *
@@ -393,6 +629,30 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 	if (host->ops->init_card)
 		host->ops->init_card(host, card);
 
+	/*
+	 * If the host and card support UHS-I mode request the card
+	 * to switch to 1.8V signaling level.  No 1.8v signalling if
+	 * UHS mode is not enabled to maintain compatibilty and some
+	 * systems that claim 1.8v signalling in fact do not support
+	 * it.
+	 */
+	if ((ocr & R4_18V_PRESENT) &&
+		(host->caps &
+			(MMC_CAP_UHS_SDR12 | MMC_CAP_UHS_SDR25 |
+			 MMC_CAP_UHS_SDR50 | MMC_CAP_UHS_SDR104 |
+			 MMC_CAP_UHS_DDR50))) {
+		err = mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_180,
+				true);
+		if (err) {
+			ocr &= ~R4_18V_PRESENT;
+			host->ocr &= ~R4_18V_PRESENT;
+		}
+		err = 0;
+	} else {
+		ocr &= ~R4_18V_PRESENT;
+		host->ocr &= ~R4_18V_PRESENT;
+	}
+
 	/*
 	 * For native busses:  set card RCA and quit open drain mode.
 	 */
@@ -492,29 +752,39 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 	if (err)
 		goto remove;
 
-	/*
-	 * Switch to high-speed (if supported).
-	 */
-	err = sdio_enable_hs(card);
-	if (err > 0)
-		mmc_sd_go_highspeed(card);
-	else if (err)
-		goto remove;
+	/* Initialization sequence for UHS-I cards */
+	/* Only if card supports 1.8v and UHS signaling */
+	if ((ocr & R4_18V_PRESENT) && card->sw_caps.sd3_bus_mode) {
+		err = mmc_sdio_init_uhs_card(card);
+		if (err)
+			goto remove;
 
-	/*
-	 * Change to the card's maximum speed.
-	 */
-	mmc_set_clock(host, mmc_sdio_get_max_clock(card));
+		/* Card is an ultra-high-speed card */
+		mmc_card_set_uhs(card);
+	} else {
+		/*
+		 * Switch to high-speed (if supported).
+		 */
+		err = sdio_enable_hs(card);
+		if (err > 0)
+			mmc_sd_go_highspeed(card);
+		else if (err)
+			goto remove;
 
-	/*
-	 * Switch to wider bus (if supported).
-	 */
-	err = sdio_enable_4bit_bus(card);
-	if (err > 0)
-		mmc_set_bus_width(card->host, MMC_BUS_WIDTH_4);
-	else if (err)
-		goto remove;
+		/*
+		 * Change to the card's maximum speed.
+		 */
+		mmc_set_clock(host, mmc_sdio_get_max_clock(card));
 
+		/*
+		 * Switch to wider bus (if supported).
+		 */
+		err = sdio_enable_4bit_bus(card);
+		if (err > 0)
+			mmc_set_bus_width(card->host, MMC_BUS_WIDTH_4);
+		else if (err)
+			goto remove;
+	}
 finish:
 	if (!oldcard)
 		host->card = card;
@@ -797,8 +1067,17 @@ int mmc_attach_sdio(struct mmc_host *host)
 	 * Detect and init the card.
 	 */
 	err = mmc_sdio_init_card(host, host->ocr, NULL, 0);
-	if (err)
-		goto err;
+	if (err) {
+		if (err == -EAGAIN) {
+			/*
+			 * Retry initialization with S18R set to 0.
+			 */
+			host->ocr &= ~R4_18V_PRESENT;
+			err = mmc_sdio_init_card(host, host->ocr, NULL, 0);
+		}
+		if (err)
+			goto err;
+	}
 	card = host->card;
 
 	/*

commit b4625dab2c618eb87e177761dda3182b4cfaa604
Author: Bing Zhao <bzhao@marvell.com>
Date:   Thu Oct 20 19:16:32 2011 -0700

    mmc: recognise SDIO cards with SDIO_CCCR_REV 3.00
    
    Table 6-2: CCCR bit Definitions, address 00h.  Part E1 SDIO Simplified
    Specification Version 3.00, Feb. 25, 2011.
    
    This patch has been tested with Marvell WLAN device SD8797.
    
    Signed-off-by: Bing Zhao <bzhao@marvell.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 925bab052b07..3ab565e32a6a 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -111,7 +111,7 @@ static int sdio_read_cccr(struct mmc_card *card)
 
 	cccr_vsn = data & 0x0f;
 
-	if (cccr_vsn > SDIO_CCCR_REV_1_20) {
+	if (cccr_vsn > SDIO_CCCR_REV_3_00) {
 		pr_err("%s: unrecognised CCCR structure version %d\n",
 			mmc_hostname(card->host), cccr_vsn);
 		return -EINVAL;

commit a3c76eb9d4a1e68a69dd880cf0bcb8a52418b993
Author: Girish K S <girish.shivananjappa@linaro.org>
Date:   Tue Oct 11 11:44:09 2011 +0530

    mmc: replace printk with appropriate display macro
    
    All the files using printk function for displaying kernel messages
    in the mmc driver have been replaced with corresponding macro.
    
    Signed-off-by: Girish K S <girish.shivananjappa@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 698d813cff3b..925bab052b07 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -112,7 +112,7 @@ static int sdio_read_cccr(struct mmc_card *card)
 	cccr_vsn = data & 0x0f;
 
 	if (cccr_vsn > SDIO_CCCR_REV_1_20) {
-		printk(KERN_ERR "%s: unrecognised CCCR structure version %d\n",
+		pr_err("%s: unrecognised CCCR structure version %d\n",
 			mmc_hostname(card->host), cccr_vsn);
 		return -EINVAL;
 	}
@@ -777,7 +777,7 @@ int mmc_attach_sdio(struct mmc_host *host)
 	 * support.
 	 */
 	if (ocr & 0x7F) {
-		printk(KERN_WARNING "%s: card claims to support voltages "
+		pr_warning("%s: card claims to support voltages "
 		       "below the defined range. These will be ignored.\n",
 		       mmc_hostname(host));
 		ocr &= ~0x7F;
@@ -874,7 +874,7 @@ int mmc_attach_sdio(struct mmc_host *host)
 err:
 	mmc_detach_bus(host);
 
-	printk(KERN_ERR "%s: error %d whilst initialising SDIO card\n",
+	pr_err("%s: error %d whilst initialising SDIO card\n",
 		mmc_hostname(host), err);
 
 	return err;

commit 44669034815a7ad263542ac605c581a10b22d146
Author: Stefan Nilsson XK <stefan.xk.nilsson@stericsson.com>
Date:   Thu Sep 15 17:50:38 2011 +0200

    mmc: core: Set correct bus mode before card init
    
    Earlier all cards where initiated with bus mode set as OPENDRAIN, and then
    later switched to PUSHPULL. According to the MMC/SD/SDIO specifications
    only MMC cards use OPENDRAIN during init. For both SD and SDIO the bus
    mode shall be PUSHPULL before attempting to init the card.
    
    The consequence of having incorrect bus mode can lead to not being able
    to detect the card. Therefore the default behavior have now been changed
    to PUSHPULL in mmc_power_up, and will only be temporarily switched when
    trying to attach or init a MMC card.
    
    Signed-off-by: Stefan Nilsson XK <stefan.xk.nilsson@stericsson.com>
    Signed-off-by: Ulf HANSSON <ulf.hansson@stericsson.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index ac492ac974e1..698d813cff3b 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -408,8 +408,6 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 		 */
 		if (oldcard)
 			oldcard->rca = card->rca;
-
-		mmc_set_bus_mode(host, MMC_BUSMODE_PUSHPULL);
 	}
 
 	/*

commit 7f7e4129c23f0419257184dff6fec89d2d5a8964
Author: Ulf Hansson <ulf.hansson@stericsson.com>
Date:   Wed Sep 21 14:08:13 2011 -0400

    mmc: core: Fix hangs related to insert/remove of cards
    
    During a rescan operation mmc_attach(sd|mmc|sdio) functions are
    called. The error handling in these function can trigger a detach
    of the bus, which also meant a power off. This is not notified by
    the rescan operation which then continues to the next attach function.
    
    If a power off has been done, the framework must never send any
    new commands to the host driver, without first doing a new power up.
    This will most likely trigger any host driver to hang.
    
    Moving power off out of detach and instead handle power off
    separately when it is actually needed, solves the issue.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@stericsson.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Cc: <stable@kernel.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 262fff019177..ac492ac974e1 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -597,6 +597,7 @@ static void mmc_sdio_detect(struct mmc_host *host)
 
 		mmc_claim_host(host);
 		mmc_detach_bus(host);
+		mmc_power_off(host);
 		mmc_release_host(host);
 	}
 }

commit c6e633ad916e2af244dbfd11abd2bc077870bdfd
Author: Daniel Drake <dsd@laptop.org>
Date:   Sat Jun 25 19:20:11 2011 +0100

    mmc: sdio: reset card during power_restore
    
    mmc_sdio_power_restore() skips some steps that are performed in other
    power-related codepaths which are necessary to fully reset the card.
    Without this, runtime PM fails for SD8686 SDIO wifi on OLPC XO-1.5.
    
    Signed-off-by: Daniel Drake <dsd@laptop.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 4d0c15bfa514..262fff019177 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -691,15 +691,54 @@ static int mmc_sdio_resume(struct mmc_host *host)
 static int mmc_sdio_power_restore(struct mmc_host *host)
 {
 	int ret;
+	u32 ocr;
 
 	BUG_ON(!host);
 	BUG_ON(!host->card);
 
 	mmc_claim_host(host);
+
+	/*
+	 * Reset the card by performing the same steps that are taken by
+	 * mmc_rescan_try_freq() and mmc_attach_sdio() during a "normal" probe.
+	 *
+	 * sdio_reset() is technically not needed. Having just powered up the
+	 * hardware, it should already be in reset state. However, some
+	 * platforms (such as SD8686 on OLPC) do not instantly cut power,
+	 * meaning that a reset is required when restoring power soon after
+	 * powering off. It is harmless in other cases.
+	 *
+	 * The CMD5 reset (mmc_send_io_op_cond()), according to the SDIO spec,
+	 * is not necessary for non-removable cards. However, it is required
+	 * for OLPC SD8686 (which expects a [CMD5,5,3,7] init sequence), and
+	 * harmless in other situations.
+	 *
+	 * With these steps taken, mmc_select_voltage() is also required to
+	 * restore the correct voltage setting of the card.
+	 */
+	sdio_reset(host);
+	mmc_go_idle(host);
+	mmc_send_if_cond(host, host->ocr_avail);
+
+	ret = mmc_send_io_op_cond(host, 0, &ocr);
+	if (ret)
+		goto out;
+
+	if (host->ocr_avail_sdio)
+		host->ocr_avail = host->ocr_avail_sdio;
+
+	host->ocr = mmc_select_voltage(host, ocr & ~0x7F);
+	if (!host->ocr) {
+		ret = -EINVAL;
+		goto out;
+	}
+
 	ret = mmc_sdio_init_card(host, host->ocr, host->card,
 				mmc_card_keep_power(host));
 	if (!ret && host->sdio_irqs)
 		mmc_signal_sdio_irq(host);
+
+out:
 	mmc_release_host(host);
 
 	return ret;

commit d6d50a15a2897d4133d536dd4343b5cf21163db3
Author: Arindam Nath <arindam.nath@amd.com>
Date:   Thu May 5 12:18:59 2011 +0530

    mmc: sd: add support for driver type selection
    
    This patch adds support for setting driver strength during UHS-I
    initialization procedure. Since UHS-I cards set S18A (bit 24) in
    response to ACMD41, we use this as a base for UHS-I initialization.
    We modify the parameter list of mmc_sd_get_cid() so that we can
    save the ROCR from ACMD41 to check whether bit 24 is set.
    
    We decide whether the Host Controller supports A, C, or D driver
    type depending on the Capabilities register. Driver type B is
    suported by default. We then set the appropriate driver type for
    the card using CMD6 mode 1. As per Host Controller spec v3.00, we
    set driver type for the host only if Preset Value Enable in the
    Host Control2 register is not set. SDHCI_HOST_CONTROL has been
    renamed to SDHCI_HOST_CONTROL1 to conform to the spec.
    
    Tested by Zhangfei Gao with a Toshiba uhs card and general hs card,
    on mmp2 in SDMA mode.
    
    Signed-off-by: Arindam Nath <arindam.nath@amd.com>
    Reviewed-by: Philip Rakity <prakity@marvell.com>
    Tested-by: Philip Rakity <prakity@marvell.com>
    Acked-by: Zhangfei Gao <zhangfei.gao@marvell.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 1e6095961500..4d0c15bfa514 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -369,8 +369,8 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 		goto err;
 	}
 
-	if (ocr & R4_MEMORY_PRESENT
-	    && mmc_sd_get_cid(host, host->ocr & ocr, card->raw_cid) == 0) {
+	if ((ocr & R4_MEMORY_PRESENT) &&
+	    mmc_sd_get_cid(host, host->ocr & ocr, card->raw_cid, NULL) == 0) {
 		card->type = MMC_TYPE_SD_COMBO;
 
 		if (oldcard && (oldcard->type != MMC_TYPE_SD_COMBO ||

commit 32780cd1350e651e68bdf33b7f5b009d21d5b794
Author: Andrei Warkentin <andreiw@motorola.com>
Date:   Mon Apr 11 17:02:15 2011 -0500

    mmc: quirks: Extends card quirks with MMC/SD quirks matching the CID.
    
    The current mechanism is SDIO-only. This allows us to create
    function-specific quirks, without creating messy Kconfig dependencies,
    or polluting core/ with function-specific code.
    
    Signed-off-by: Andrei Warkentin <andreiw@motorola.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index a5840c0de2e4..1e6095961500 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -472,7 +472,7 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 
 		card = oldcard;
 	}
-	mmc_fixup_device(card);
+	mmc_fixup_device(card, NULL);
 
 	if (card->type == MMC_TYPE_SD_COMBO) {
 		err = mmc_sd_setup_card(host, card, oldcard != NULL);

commit 2059a02dcb84236f9db9197fa9b00418d7b8465b
Author: Ohad Ben-Cohen <ohad@wizery.com>
Date:   Tue Apr 5 18:02:25 2011 +0300

    mmc: add MMC_QUIRK_DISABLE_CD
    
    006ebd5d introduced sdio_disable_cd(), which disconnects the pull-up
    resistor on CD/DAT[3] (pin 1) of the card.
    
    Make it possible to start using sdio_disable_cd() by introducing
    MMC_QUIRK_DISABLE_CD.
    
    Signed-off-by: Ohad Ben-Cohen <ohad@wizery.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index c3c2bd0874e8..a5840c0de2e4 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -187,7 +187,7 @@ static int sdio_disable_cd(struct mmc_card *card)
 	int ret;
 	u8 ctrl;
 
-	if (!card->cccr.disable_cd)
+	if (!mmc_card_disable_cd(card))
 		return 0;
 
 	ret = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_IF, 0, &ctrl);

commit eab4068795d670b065164096805cbf15a19e9690
Author: Ohad Ben-Cohen <ohad@wizery.com>
Date:   Tue Apr 5 17:50:14 2011 +0300

    mmc: add MMC_QUIRK_NONSTD_FUNC_IF
    
    Introduce MMC_QUIRK_NONSTD_FUNC_IF to ignore the "SDIO Standard Function
    interface code" as indicated by the card's FBR, and instead treat all
    functions as non-standard interfaces.
    
    This is required to prevent standard drivers from facing
    errors when trying to communicate with SDIO cards that erroneously
    indicate standard function interface codes.
    
    Signed-off-by: Ohad Ben-Cohen <ohad@wizery.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 4221670bf82e..c3c2bd0874e8 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -16,6 +16,7 @@
 #include <linux/mmc/card.h>
 #include <linux/mmc/sdio.h>
 #include <linux/mmc/sdio_func.h>
+#include <linux/mmc/sdio_ids.h>
 
 #include "core.h"
 #include "bus.h"
@@ -31,6 +32,11 @@ static int sdio_read_fbr(struct sdio_func *func)
 	int ret;
 	unsigned char data;
 
+	if (mmc_card_nonstd_func_interface(func->card)) {
+		func->class = SDIO_CLASS_NONE;
+		return 0;
+	}
+
 	ret = mmc_io_rw_direct(func->card, 0, 0,
 		SDIO_FBR_BASE(func->num) + SDIO_FBR_STD_IF, 0, &data);
 	if (ret)

commit 6b93d01fe5971951911a070f51f412d50e9536dc
Author: Ohad Ben-Cohen <ohad@wizery.com>
Date:   Tue Apr 5 17:43:21 2011 +0300

    mmc: do not switch to 1-bit mode if not required
    
    6b5eda36 followed SDIO spec part E1 section 8, which states that
    in case SDIO interrupts are being used to wake up a suspended host,
    then it is required to switch to 1-bit mode before stopping the clock.
    
    Before switching to 1-bit mode (or back to 4-bit mode on resume),
    make sure that SDIO interrupts are really being used to wake the host.
    
    This is helpful for devices which have an external irq line (e.g.
    wl1271), and do not use SDIO interrupts to wake up the host.
    
    In this case, switching to 1-bit mode (and back to 4-bit mode on resume)
    is not necessary.
    
    Reported-by: Eliad Peller <eliad@wizery.com>
    Signed-off-by: Ohad Ben-Cohen <ohad@wizery.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 0f7d4362d213..4221670bf82e 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -625,7 +625,7 @@ static int mmc_sdio_suspend(struct mmc_host *host)
 		}
 	}
 
-	if (!err && mmc_card_keep_power(host)) {
+	if (!err && mmc_card_keep_power(host) && mmc_card_wake_sdio_irq(host)) {
 		mmc_claim_host(host);
 		sdio_disable_wide(host->card);
 		mmc_release_host(host);
@@ -648,7 +648,7 @@ static int mmc_sdio_resume(struct mmc_host *host)
 	if (mmc_card_is_removable(host) || !mmc_card_keep_power(host))
 		err = mmc_sdio_init_card(host, host->ocr, host->card,
 					mmc_card_keep_power(host));
-	else if (mmc_card_keep_power(host)) {
+	else if (mmc_card_keep_power(host) && mmc_card_wake_sdio_irq(host)) {
 		/* We may have switched to 1-bit mode during suspend */
 		err = sdio_enable_4bit_bus(host->card);
 		if (err > 0) {

commit a5e9425d2010978c5f85986cc70a9fa0c0d5b912
Author: Ohad Ben-Cohen <ohad@wizery.com>
Date:   Tue Apr 5 17:43:20 2011 +0300

    mmc: mmc_card_keep_power cleanups
    
    mmc_card_is_powered_resumed is a mouthful; instead, simply use
    mmc_card_keep_power, which also better explains the purpose of
    the macro.
    
    Employ mmc_card_keep_power() where possible.
    
    Signed-off-by: Ohad Ben-Cohen <ohad@wizery.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index db0f0b44d684..0f7d4362d213 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -625,7 +625,7 @@ static int mmc_sdio_suspend(struct mmc_host *host)
 		}
 	}
 
-	if (!err && host->pm_flags & MMC_PM_KEEP_POWER) {
+	if (!err && mmc_card_keep_power(host)) {
 		mmc_claim_host(host);
 		sdio_disable_wide(host->card);
 		mmc_release_host(host);
@@ -645,10 +645,10 @@ static int mmc_sdio_resume(struct mmc_host *host)
 	mmc_claim_host(host);
 
 	/* No need to reinitialize powered-resumed nonremovable cards */
-	if (mmc_card_is_removable(host) || !mmc_card_is_powered_resumed(host))
+	if (mmc_card_is_removable(host) || !mmc_card_keep_power(host))
 		err = mmc_sdio_init_card(host, host->ocr, host->card,
-				 (host->pm_flags & MMC_PM_KEEP_POWER));
-	else if (mmc_card_is_powered_resumed(host)) {
+					mmc_card_keep_power(host));
+	else if (mmc_card_keep_power(host)) {
 		/* We may have switched to 1-bit mode during suspend */
 		err = sdio_enable_4bit_bus(host->card);
 		if (err > 0) {
@@ -691,7 +691,7 @@ static int mmc_sdio_power_restore(struct mmc_host *host)
 
 	mmc_claim_host(host);
 	ret = mmc_sdio_init_card(host, host->ocr, host->card,
-			(host->pm_flags & MMC_PM_KEEP_POWER));
+				mmc_card_keep_power(host));
 	if (!ret && host->sdio_irqs)
 		mmc_signal_sdio_irq(host);
 	mmc_release_host(host);

commit 0aab3995485b8a994bf29a995a008c9ea4a28054
Author: Stefan Nilsson XK <stefan.xk.nilsson@stericsson.com>
Date:   Tue Mar 1 14:41:04 2011 +0100

    mmc: sdio: remember new card RCA when redetecting card
    
    During redetection of a SDIO card, a request for a new card RCA
    was submitted to the card, but was then overwritten by the old RCA.
    This caused the card to be deselected instead of selected when using
    the incorrect RCA.  This bug's been present since the "oldcard"
    handling was introduced in 2.6.32.
    
    Signed-off-by: Stefan Nilsson XK <stefan.xk.nilsson@stericsson.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@stericsson.com>
    Reviewed-by: Pawel Wieczorkiewicz <pawel.wieczorkiewicz@stericsson.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Cc: <stable@kernel.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index c9fbb777440d..db0f0b44d684 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -395,6 +395,14 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 		if (err)
 			goto remove;
 
+		/*
+		 * Update oldcard with the new RCA received from the SDIO
+		 * device -- we're doing this so that it's updated in the
+		 * "card" struct when oldcard overwrites that later.
+		 */
+		if (oldcard)
+			oldcard->rca = card->rca;
+
 		mmc_set_bus_mode(host, MMC_BUSMODE_PUSHPULL);
 	}
 

commit 57f0adc7eaaf4315d568e72069dbe48aa7e20995
Author: Pierre Tardy <pierre.tardy@intel.com>
Date:   Sun Feb 6 19:03:46 2011 +0100

    mmc: add per device quirk placeholder
    
    Some cards have quirks valid for every platforms using current
    platform quirk hooks leads to a lot of code and debug duplication.
    
    So we inspire a bit from what exists in PCI subsystem and do our own
    per vendorid/deviceid quirk.  We still drop the complexity of the pci
    quirk system (with special section tables, and so on).
    That can be added later if needed.
    
    Signed-off-by: Pierre Tardy <pierre.tardy@intel.com>
    Acked-by: Linus Walleij <linus.walleij@stericsson.com>
    Acked-by: Ohad Ben-Cohen <ohad@wizery.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index ebc62ad4cc56..c9fbb777440d 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -458,6 +458,7 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 
 		card = oldcard;
 	}
+	mmc_fixup_device(card);
 
 	if (card->type == MMC_TYPE_SD_COMBO) {
 		err = mmc_sd_setup_card(host, card, oldcard != NULL);

commit 34497913f2936fd43c86b007da7224bb8e77fd15
Author: Dmitry Shmidt <dimitrysh@google.com>
Date:   Thu Mar 3 17:40:10 2011 -0500

    mmc: sdio: Allow sdio operations in other threads during sdio_add_func()
    
    This fixes a bug introduced by 807e8e40673d ("mmc: Fix sd/sdio/mmc
    initialization frequency retries") that prevented SDIO drivers from
    performing SDIO commands in their probe routines -- the above patch
    called mmc_claim_host() before sdio_add_func(), which causes a deadlock
    if an external SDIO driver calls sdio_claim_host().
    
    Fix tested on an OLPC XO-1.75 with libertas on SDIO.
    
    Signed-off-by: Dmitry Shmidt <dimitrysh@google.com>
    Reviewed-and-Tested-by: Chris Ball <cjb@laptop.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 5c4a54d9b6a4..ebc62ad4cc56 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -792,7 +792,6 @@ int mmc_attach_sdio(struct mmc_host *host)
 	 */
 	mmc_release_host(host);
 	err = mmc_add_card(host->card);
-	mmc_claim_host(host);
 	if (err)
 		goto remove_added;
 
@@ -805,12 +804,12 @@ int mmc_attach_sdio(struct mmc_host *host)
 			goto remove_added;
 	}
 
+	mmc_claim_host(host);
 	return 0;
 
 
 remove_added:
 	/* Remove without lock if the device has been added. */
-	mmc_release_host(host);
 	mmc_sdio_remove(host);
 	mmc_claim_host(host);
 remove:

commit 807e8e40673d9628fa7dcdd14423424b4ee5f43b
Author: Andy Ross <andy.ross@windriver.com>
Date:   Mon Jan 3 10:36:56 2011 -0800

    mmc: Fix sd/sdio/mmc initialization frequency retries
    
    Rewrite and clean up mmc_rescan() to properly retry frequencies lower
    than 400kHz.  Failures can happen both in sd_send_* calls and
    mmc_attach_*.  Break out "mmc_rescan_try_freq" from the frequency
    selection loop.  Symmetrize claim/release logic in mmc_attach_* API,
    and move the sd_send_* calls there to make mmc_rescan easier to read.
    
    Signed-off-by: Andy Ross <andy.ross@windriver.com>
    Reviewed-and-Tested-by: Hein Tibosch <hein_tibosch@yahoo.es>
    Reviewed-by: Chris Ball <cjb@laptop.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 82f4b9008987..5c4a54d9b6a4 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -702,15 +702,19 @@ static const struct mmc_bus_ops mmc_sdio_ops = {
 /*
  * Starting point for SDIO card init.
  */
-int mmc_attach_sdio(struct mmc_host *host, u32 ocr)
+int mmc_attach_sdio(struct mmc_host *host)
 {
-	int err;
-	int i, funcs;
+	int err, i, funcs;
+	u32 ocr;
 	struct mmc_card *card;
 
 	BUG_ON(!host);
 	WARN_ON(!host->claimed);
 
+	err = mmc_send_io_op_cond(host, 0, &ocr);
+	if (err)
+		return err;
+
 	mmc_attach_bus(host, &mmc_sdio_ops);
 	if (host->ocr_avail_sdio)
 		host->ocr_avail = host->ocr_avail_sdio;
@@ -783,12 +787,12 @@ int mmc_attach_sdio(struct mmc_host *host, u32 ocr)
 			pm_runtime_enable(&card->sdio_func[i]->dev);
 	}
 
-	mmc_release_host(host);
-
 	/*
 	 * First add the card to the driver model...
 	 */
+	mmc_release_host(host);
 	err = mmc_add_card(host->card);
+	mmc_claim_host(host);
 	if (err)
 		goto remove_added;
 
@@ -806,15 +810,17 @@ int mmc_attach_sdio(struct mmc_host *host, u32 ocr)
 
 remove_added:
 	/* Remove without lock if the device has been added. */
+	mmc_release_host(host);
 	mmc_sdio_remove(host);
 	mmc_claim_host(host);
 remove:
 	/* And with lock if it hasn't been added. */
+	mmc_release_host(host);
 	if (host->card)
 		mmc_sdio_remove(host);
+	mmc_claim_host(host);
 err:
 	mmc_detach_bus(host);
-	mmc_release_host(host);
 
 	printk(KERN_ERR "%s: error %d whilst initialising SDIO card\n",
 		mmc_hostname(host), err);

commit 080bc9774b6f1e3866747b18631bad26f47c22ce
Author: Ohad Ben-Cohen <ohad@wizery.com>
Date:   Sun Nov 28 07:21:29 2010 +0200

    mmc: sdio: don't reinitialize nonremovable powered-resumed cards
    
    Upon system resume, SDIO core must reinitialize cards that were
    powered off during suspend.
    
    If the card had its power kept during suspend (and thus it is
    'powered-resumed'), SDIO core performs only a limited reinitializing,
    mainly needed to make sure that the card wasn't removed/replaced.
    
    If a __nonremovable__ card is powered-resumed, we can safely skip the
    reinitializing phase.
    
    Note: 9b966aa (mmc: sdio: fully reconfigure oldcard on resume) removed
    the bus width reconfiguration since mmc_sdio_init_card already does it.
    It is brought back now in case mmc_sdio_init_card is skipped.
    
    Signed-off-by: Ohad Ben-Cohen <ohad@wizery.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index c18810ab6465..82f4b9008987 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -627,15 +627,27 @@ static int mmc_sdio_suspend(struct mmc_host *host)
 
 static int mmc_sdio_resume(struct mmc_host *host)
 {
-	int i, err;
+	int i, err = 0;
 
 	BUG_ON(!host);
 	BUG_ON(!host->card);
 
 	/* Basic card reinitialization. */
 	mmc_claim_host(host);
-	err = mmc_sdio_init_card(host, host->ocr, host->card,
+
+	/* No need to reinitialize powered-resumed nonremovable cards */
+	if (mmc_card_is_removable(host) || !mmc_card_is_powered_resumed(host))
+		err = mmc_sdio_init_card(host, host->ocr, host->card,
 				 (host->pm_flags & MMC_PM_KEEP_POWER));
+	else if (mmc_card_is_powered_resumed(host)) {
+		/* We may have switched to 1-bit mode during suspend */
+		err = sdio_enable_4bit_bus(host->card);
+		if (err > 0) {
+			mmc_set_bus_width(host, MMC_BUS_WIDTH_4);
+			err = 0;
+		}
+	}
+
 	if (!err && host->sdio_irqs)
 		mmc_signal_sdio_irq(host);
 	mmc_release_host(host);

commit 8f230f454fe04ba326ffaead3a6b88dcf44eaf4b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Dec 8 10:04:30 2010 +0100

    mmc: Add support for JMicron 388 SD/MMC controller
    
    JMicron 388 SD/MMC combo controller supports the 1.8V low-voltage for
    SD, but MMC doesn't work with the low-voltage, resulting in an error
    at probing.
    
    This patch adds the support for multiple voltage mask per device type,
    so that SD works with 1.8V while MMC forces 3.3V.  Here new ocr_avail_*
    fields for each device are introduced, so that the actual OCR mask is
    switched dynamically.
    
    Also, the restriction of low-voltage in core/sd.c is removed when the
    bit is allowed explicitly via ocr_avail_sd mask.
    
    This patch was rewritten from scratch based on Aries' original code.
    
    Signed-off-by: Aries Lee <arieslee@jmicron.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Reviewed-by: Chris Ball <cjb@laptop.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index efef5f94ac42..c18810ab6465 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -700,6 +700,8 @@ int mmc_attach_sdio(struct mmc_host *host, u32 ocr)
 	WARN_ON(!host->claimed);
 
 	mmc_attach_bus(host, &mmc_sdio_ops);
+	if (host->ocr_avail_sdio)
+		host->ocr_avail = host->ocr_avail_sdio;
 
 	/*
 	 * Sanity check the voltages that the card claims to

commit ed919b0125b26dcc052e44836f66e7e1f5c49c7e
Author: Ohad Ben-Cohen <ohad@wizery.com>
Date:   Fri Nov 19 09:29:09 2010 +0200

    mmc: sdio: fix runtime PM anomalies by introducing MMC_CAP_POWER_OFF_CARD
    
    Some board/card/host configurations are not capable of powering off the
    card after boot.
    
    To support such configurations, and to allow smoother transition to
    runtime PM behavior, MMC_CAP_POWER_OFF_CARD is added, so hosts need to
    explicitly indicate whether it's OK to power off their cards after boot.
    
    SDIO core will enable runtime PM for a card only if that cap is set.
    As a result, the card will be powered down after boot, and will only
    be powered up again when a driver is loaded (and then it's up to the
    driver to decide whether power will be kept or not).
    
    This will prevent sdio_bus_probe() failures with setups that do not
    support powering off the card.
    
    Reported-and-tested-by: Daniel Drake <dsd@laptop.org>
    Reported-and-tested-by: Arnd Hannemann <arnd@arndnet.de>
    Signed-off-by: Ohad Ben-Cohen <ohad@wizery.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 42a949b723b8..efef5f94ac42 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -547,9 +547,11 @@ static void mmc_sdio_detect(struct mmc_host *host)
 	BUG_ON(!host->card);
 
 	/* Make sure card is powered before detecting it */
-	err = pm_runtime_get_sync(&host->card->dev);
-	if (err < 0)
-		goto out;
+	if (host->caps & MMC_CAP_POWER_OFF_CARD) {
+		err = pm_runtime_get_sync(&host->card->dev);
+		if (err < 0)
+			goto out;
+	}
 
 	mmc_claim_host(host);
 
@@ -571,7 +573,8 @@ static void mmc_sdio_detect(struct mmc_host *host)
 	 * is about to show up at this point, the _sync variant is
 	 * desirable anyway.
 	 */
-	pm_runtime_put_sync(&host->card->dev);
+	if (host->caps & MMC_CAP_POWER_OFF_CARD)
+		pm_runtime_put_sync(&host->card->dev);
 
 out:
 	if (err) {
@@ -728,16 +731,21 @@ int mmc_attach_sdio(struct mmc_host *host, u32 ocr)
 	card = host->card;
 
 	/*
-	 * Let runtime PM core know our card is active
+	 * Enable runtime PM only if supported by host+card+board
 	 */
-	err = pm_runtime_set_active(&card->dev);
-	if (err)
-		goto remove;
+	if (host->caps & MMC_CAP_POWER_OFF_CARD) {
+		/*
+		 * Let runtime PM core know our card is active
+		 */
+		err = pm_runtime_set_active(&card->dev);
+		if (err)
+			goto remove;
 
-	/*
-	 * Enable runtime PM for this card
-	 */
-	pm_runtime_enable(&card->dev);
+		/*
+		 * Enable runtime PM for this card
+		 */
+		pm_runtime_enable(&card->dev);
+	}
 
 	/*
 	 * The number of functions on the card is encoded inside
@@ -755,9 +763,10 @@ int mmc_attach_sdio(struct mmc_host *host, u32 ocr)
 			goto remove;
 
 		/*
-		 * Enable Runtime PM for this func
+		 * Enable Runtime PM for this func (if supported)
 		 */
-		pm_runtime_enable(&card->sdio_func[i]->dev);
+		if (host->caps & MMC_CAP_POWER_OFF_CARD)
+			pm_runtime_enable(&card->sdio_func[i]->dev);
 	}
 
 	mmc_release_host(host);

commit 4d0812c37f2f6cf6fc7ca086b5a5e572cbbe7f6d
Author: Ohad Ben-Cohen <ohad@wizery.com>
Date:   Sun Nov 14 12:40:33 2010 +0200

    mmc: sdio: fix nasty oops in mmc_sdio_detect
    
    Power off the card in mmc_sdio_detect __before__ a potential error
    handler, which completely removes the card, executes, and only if the
    card was successfully powered on beforehand.
    
    While we're at it, use the _sync variant of the runtime PM put API, in
    order to ensure that the card is left powered off in case an error
    occurred, and the card is going to be removed.
    
    Reproduced and tested on the OLPC XO-1.5.
    
    Reported-by: Daniel Drake <dsd@laptop.org>
    Signed-off-by: Ohad Ben-Cohen <ohad@wizery.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index c3ad1058cd31..42a949b723b8 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -560,6 +560,19 @@ static void mmc_sdio_detect(struct mmc_host *host)
 
 	mmc_release_host(host);
 
+	/*
+	 * Tell PM core it's OK to power off the card now.
+	 *
+	 * The _sync variant is used in order to ensure that the card
+	 * is left powered off in case an error occurred, and the card
+	 * is going to be removed.
+	 *
+	 * Since there is no specific reason to believe a new user
+	 * is about to show up at this point, the _sync variant is
+	 * desirable anyway.
+	 */
+	pm_runtime_put_sync(&host->card->dev);
+
 out:
 	if (err) {
 		mmc_sdio_remove(host);
@@ -568,9 +581,6 @@ static void mmc_sdio_detect(struct mmc_host *host)
 		mmc_detach_bus(host);
 		mmc_release_host(host);
 	}
-
-	/* Tell PM core that we're done */
-	pm_runtime_put(&host->card->dev);
 }
 
 /*

commit 87973ba27b751353e2915cb3aa5c0e0dc6a79a4f
Author: Ohad Ben-Cohen <ohad@wizery.com>
Date:   Sat Oct 2 13:54:12 2010 +0200

    mmc: sdio: ensure mmc_sdio_detect is powered
    
    To prevent an erroneous removal of the card, make sure
    the device is powered when it is mmc_sdio_detect()ed.
    
    This is required since mmc_sdio_detect may be invoked
    while the device is runtime suspended (e.g., MMC core
    is rescanning when system comes out of suspend).
    
    Signed-off-by: Ohad Ben-Cohen <ohad@wizery.com>
    Tested-by: Luciano Coelho <luciano.coelho@nokia.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 85561dde4c9d..c3ad1058cd31 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -546,6 +546,11 @@ static void mmc_sdio_detect(struct mmc_host *host)
 	BUG_ON(!host);
 	BUG_ON(!host->card);
 
+	/* Make sure card is powered before detecting it */
+	err = pm_runtime_get_sync(&host->card->dev);
+	if (err < 0)
+		goto out;
+
 	mmc_claim_host(host);
 
 	/*
@@ -555,6 +560,7 @@ static void mmc_sdio_detect(struct mmc_host *host)
 
 	mmc_release_host(host);
 
+out:
 	if (err) {
 		mmc_sdio_remove(host);
 
@@ -562,6 +568,9 @@ static void mmc_sdio_detect(struct mmc_host *host)
 		mmc_detach_bus(host);
 		mmc_release_host(host);
 	}
+
+	/* Tell PM core that we're done */
+	pm_runtime_put(&host->card->dev);
 }
 
 /*

commit 40bba0c1ca83a370f749c8bc9afda71cf79ebd91
Author: Ohad Ben-Cohen <ohad@wizery.com>
Date:   Sat Oct 2 13:54:11 2010 +0200

    mmc: sdio: enable runtime PM for SDIO functions
    
    Enable runtime PM for SDIO functions.
    
    SDIO functions are initialized with a disabled runtime PM state,
    and are set active (and their usage count is incremented)
    only before potential drivers are probed.
    
    SDIO function drivers that support runtime PM should call
    pm_runtime_put_noidle() in their probe routine, and
    pm_runtime_get_noresume() in their remove routine (very
    similarly to PCI drivers).
    
    In case a matching driver does not support runtime PM, power will
    always be kept high (since the usage count is positive).
    
    Signed-off-by: Ohad Ben-Cohen <ohad@wizery.com>
    Tested-by: Luciano Coelho <luciano.coelho@nokia.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 0dbd6fe66660..85561dde4c9d 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -734,6 +734,11 @@ int mmc_attach_sdio(struct mmc_host *host, u32 ocr)
 		err = sdio_init_func(host->card, i + 1);
 		if (err)
 			goto remove;
+
+		/*
+		 * Enable Runtime PM for this func
+		 */
+		pm_runtime_enable(&card->sdio_func[i]->dev);
 	}
 
 	mmc_release_host(host);

commit 81968561bd69536c82be7ee654b04c68cd3e1746
Author: Ohad Ben-Cohen <ohad@wizery.com>
Date:   Sat Oct 2 13:54:10 2010 +0200

    mmc: sdio: enable runtime PM for SDIO cards
    
    Enable runtime PM for new SDIO cards.
    
    As soon as the card will be added to the device tree, runtime PM core
    will release its power, since it doesn't have any users yet.
    
    Signed-off-by: Ohad Ben-Cohen <ohad@wizery.com>
    Tested-by: Luciano Coelho <luciano.coelho@nokia.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index f17e0e0bd9d1..0dbd6fe66660 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -10,6 +10,7 @@
  */
 
 #include <linux/err.h>
+#include <linux/pm_runtime.h>
 
 #include <linux/mmc/host.h>
 #include <linux/mmc/card.h>
@@ -707,6 +708,18 @@ int mmc_attach_sdio(struct mmc_host *host, u32 ocr)
 		goto err;
 	card = host->card;
 
+	/*
+	 * Let runtime PM core know our card is active
+	 */
+	err = pm_runtime_set_active(&card->dev);
+	if (err)
+		goto remove;
+
+	/*
+	 * Enable runtime PM for this card
+	 */
+	pm_runtime_enable(&card->dev);
+
 	/*
 	 * The number of functions on the card is encoded inside
 	 * the ocr.

commit d3fe37b1a1d98f060279bfa32fcf5a134851a91a
Author: Ohad Ben-Cohen <ohad@wizery.com>
Date:   Sat Oct 2 13:54:07 2010 +0200

    mmc: sdio: add power_restore support
    
    Add a power_restore handler to the SDIO bus ops,
    in order to support waking up SDIO cards that
    were powered off by runtime pm.
    
    Signed-off-by: Ohad Ben-Cohen <ohad@wizery.com>
    Tested-by: Luciano Coelho <luciano.coelho@nokia.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 3be1571e4a51..f17e0e0bd9d1 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -638,11 +638,29 @@ static int mmc_sdio_resume(struct mmc_host *host)
 	return err;
 }
 
+static int mmc_sdio_power_restore(struct mmc_host *host)
+{
+	int ret;
+
+	BUG_ON(!host);
+	BUG_ON(!host->card);
+
+	mmc_claim_host(host);
+	ret = mmc_sdio_init_card(host, host->ocr, host->card,
+			(host->pm_flags & MMC_PM_KEEP_POWER));
+	if (!ret && host->sdio_irqs)
+		mmc_signal_sdio_irq(host);
+	mmc_release_host(host);
+
+	return ret;
+}
+
 static const struct mmc_bus_ops mmc_sdio_ops = {
 	.remove = mmc_sdio_remove,
 	.detect = mmc_sdio_detect,
 	.suspend = mmc_sdio_suspend,
 	.resume = mmc_sdio_resume,
+	.power_restore = mmc_sdio_power_restore,
 };
 
 

commit 9b966aae6419f7d75a87114c4d82bfb8f8699132
Author: Ohad Ben-Cohen <ohad@wizery.com>
Date:   Sat Oct 2 13:54:05 2010 +0200

    mmc: sdio: fully reconfigure oldcard on resume
    
    On resume, let mmc_sdio_init_card go all the way, instead
    of skipping the reconfiguration of the card's speed and width.
    
    This is needed to ensure cards wake up with their clock
    reconfigured (otherwise it's kept low).
    
    This patch also removes the explicit bus width reconfiguration
    on resume, since now this is part of mmc_sdio_init_card.
    
    Signed-off-by: Ohad Ben-Cohen <ohad@wizery.com>
    Tested-by: Luciano Coelho <luciano.coelho@nokia.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index f332c52968b7..3be1571e4a51 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -456,7 +456,6 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 			return -ENOENT;
 
 		card = oldcard;
-		return 0;
 	}
 
 	if (card->type == MMC_TYPE_SD_COMBO) {
@@ -614,14 +613,6 @@ static int mmc_sdio_resume(struct mmc_host *host)
 	mmc_claim_host(host);
 	err = mmc_sdio_init_card(host, host->ocr, host->card,
 				 (host->pm_flags & MMC_PM_KEEP_POWER));
-	if (!err) {
-		/* We may have switched to 1-bit mode during suspend. */
-		err = sdio_enable_4bit_bus(host->card);
-		if (err > 0) {
-			mmc_set_bus_width(host, MMC_BUS_WIDTH_4);
-			err = 0;
-		}
-	}
 	if (!err && host->sdio_irqs)
 		mmc_signal_sdio_irq(host);
 	mmc_release_host(host);

commit f3c65b2870f2481f3646bc410a58a12989ecc704
Author: David Vrabel <david.vrabel@csr.com>
Date:   Thu Sep 9 16:37:24 2010 -0700

    mmc: avoid getting CID on SDIO-only cards
    
    The introduction of support for SD combo cards breaks the initialization
    of all CSR SDIO chips.  The GO_IDLE (CMD0) in mmc_sd_get_cid() causes CSR
    chips to be reset (this is non-standard behavior).
    
    When initializing an SDIO card check for a combo card by using the memory
    present bit in the R4 response to IO_SEND_OP_COND (CMD5).  This avoids the
    call to mmc_sd_get_cid() on an SDIO-only card.
    
    Signed-off-by: David Vrabel <david.vrabel@csr.com>
    Acked-by: Michal Mirolaw <mirq-linux@rere.qmqm.pl>
    Cc: <linux-mmc@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index bd2755e8d9a3..f332c52968b7 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -362,9 +362,8 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 		goto err;
 	}
 
-	err = mmc_sd_get_cid(host, host->ocr & ocr, card->raw_cid);
-
-	if (!err) {
+	if (ocr & R4_MEMORY_PRESENT
+	    && mmc_sd_get_cid(host, host->ocr & ocr, card->raw_cid) == 0) {
 		card->type = MMC_TYPE_SD_COMBO;
 
 		if (oldcard && (oldcard->type != MMC_TYPE_SD_COMBO ||

commit 6f51be3d37dff73cf8db771df4169f4c2f1cbf66
Author: Grazvydas Ignotas <notasas@gmail.com>
Date:   Tue Aug 10 18:01:50 2010 -0700

    sdio: allow non-standard SDIO cards
    
    There are some chips (like TI WL12xx series) that can be interfaced over
    SDIO but don't support the SDIO specification, meaning that they are
    missing CIA (Common I/O Area) with all it's registers.  Current Linux SDIO
    implementation relies on those registers to identify and configure the
    card, so non-standard cards can not function and cause lots of warnings
    from the core when it reads invalid data from non-existent registers.
    
    After this patch, init_card() host callback can now set new quirk
    MMC_QUIRK_NONSTD_SDIO, which means that SDIO core should not try to access
    any standard SDIO registers and rely on init_card() to fill all SDIO
    structures instead.  As those cards are usually embedded chips, all the
    required information can be obtained from machine board files by the host
    driver when it's called through init_card() callback.
    
    Signed-off-by: Grazvydas Ignotas <notasas@gmail.com>
    Cc: Adrian Hunter <adrian.hunter@nokia.com>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Bob Copeland <me@bobcopeland.com>
    Cc: Kalle Valo <kvalo@adurom.com>
    Cc: Madhusudhan Chikkature <madhu.cr@ti.com>
    Cc: Kishore Kadiyala <kishore.kadiyala@ti.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: <linux-mmc@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index b0b6ce93e519..bd2755e8d9a3 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -63,13 +63,19 @@ static int sdio_init_func(struct mmc_card *card, unsigned int fn)
 
 	func->num = fn;
 
-	ret = sdio_read_fbr(func);
-	if (ret)
-		goto fail;
+	if (!(card->quirks & MMC_QUIRK_NONSTD_SDIO)) {
+		ret = sdio_read_fbr(func);
+		if (ret)
+			goto fail;
 
-	ret = sdio_read_func_cis(func);
-	if (ret)
-		goto fail;
+		ret = sdio_read_func_cis(func);
+		if (ret)
+			goto fail;
+	} else {
+		func->vendor = func->card->cis.vendor;
+		func->device = func->card->cis.device;
+		func->max_blksize = func->card->cis.blksize;
+	}
 
 	card->sdio_func[fn - 1] = func;
 
@@ -412,6 +418,23 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 			goto remove;
 	}
 
+	if (card->quirks & MMC_QUIRK_NONSTD_SDIO) {
+		/*
+		 * This is non-standard SDIO device, meaning it doesn't
+		 * have any CIA (Common I/O area) registers present.
+		 * It's host's responsibility to fill cccr and cis
+		 * structures in init_card().
+		 */
+		mmc_set_clock(host, card->cis.max_dtr);
+
+		if (card->cccr.high_speed) {
+			mmc_card_set_highspeed(card);
+			mmc_set_timing(card->host, MMC_TIMING_SD_HS);
+		}
+
+		goto finish;
+	}
+
 	/*
 	 * Read the common registers.
 	 */
@@ -480,6 +503,7 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 	else if (err)
 		goto remove;
 
+finish:
 	if (!oldcard)
 		host->card = card;
 	return 0;

commit 7310ece86ad7da027f85a37a0638164118a5d12f
Author: Michal Miroslaw <mirq-linux@rere.qmqm.pl>
Date:   Tue Aug 10 18:01:40 2010 -0700

    mmc: implement SD-combo (IO+mem) support
    
    Signed-off-by: Michal Miroslaw <mirq-linux@rere.qmqm.pl>
    Cc: Adrian Hunter <adrian.hunter@nokia.com>
    Cc: Chris Ball <cjb@laptop.org>
    Cc: <linux-mmc@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 47d1708810bd..b0b6ce93e519 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -160,9 +160,7 @@ static int sdio_enable_wide(struct mmc_card *card)
 	if (ret)
 		return ret;
 
-	mmc_set_bus_width(card->host, MMC_BUS_WIDTH_4);
-
-	return 0;
+	return 1;
 }
 
 /*
@@ -222,10 +220,34 @@ static int sdio_disable_wide(struct mmc_card *card)
 	return 0;
 }
 
+
+static int sdio_enable_4bit_bus(struct mmc_card *card)
+{
+	int err;
+
+	if (card->type == MMC_TYPE_SDIO)
+		return sdio_enable_wide(card);
+
+	if ((card->host->caps & MMC_CAP_4_BIT_DATA) &&
+		(card->scr.bus_widths & SD_SCR_BUS_WIDTH_4)) {
+		err = mmc_app_set_bus_width(card, MMC_BUS_WIDTH_4);
+		if (err)
+			return err;
+	} else
+		return 0;
+
+	err = sdio_enable_wide(card);
+	if (err <= 0)
+		mmc_app_set_bus_width(card, MMC_BUS_WIDTH_1);
+
+	return err;
+}
+
+
 /*
  * Test if the card supports high-speed mode and, if so, switch to it.
  */
-static int sdio_enable_hs(struct mmc_card *card)
+static int mmc_sdio_switch_hs(struct mmc_card *card, int enable)
 {
 	int ret;
 	u8 speed;
@@ -240,7 +262,10 @@ static int sdio_enable_hs(struct mmc_card *card)
 	if (ret)
 		return ret;
 
-	speed |= SDIO_SPEED_EHS;
+	if (enable)
+		speed |= SDIO_SPEED_EHS;
+	else
+		speed &= ~SDIO_SPEED_EHS;
 
 	ret = mmc_io_rw_direct(card, 1, 0, SDIO_CCCR_SPEED, speed, NULL);
 	if (ret)
@@ -249,6 +274,24 @@ static int sdio_enable_hs(struct mmc_card *card)
 	return 1;
 }
 
+/*
+ * Enable SDIO/combo card's high-speed mode. Return 0/1 if [not]supported.
+ */
+static int sdio_enable_hs(struct mmc_card *card)
+{
+	int ret;
+
+	ret = mmc_sdio_switch_hs(card, true);
+	if (ret <= 0 || card->type == MMC_TYPE_SDIO)
+		return ret;
+
+	ret = mmc_sd_switch_hs(card);
+	if (ret <= 0)
+		mmc_sdio_switch_hs(card, false);
+
+	return ret;
+}
+
 static unsigned mmc_sdio_get_max_clock(struct mmc_card *card)
 {
 	unsigned max_dtr;
@@ -265,6 +308,9 @@ static unsigned mmc_sdio_get_max_clock(struct mmc_card *card)
 		max_dtr = card->cis.max_dtr;
 	}
 
+	if (card->type == MMC_TYPE_SD_COMBO)
+		max_dtr = min(max_dtr, mmc_sd_get_max_clock(card));
+
 	return max_dtr;
 }
 
@@ -310,7 +356,24 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 		goto err;
 	}
 
-	card->type = MMC_TYPE_SDIO;
+	err = mmc_sd_get_cid(host, host->ocr & ocr, card->raw_cid);
+
+	if (!err) {
+		card->type = MMC_TYPE_SD_COMBO;
+
+		if (oldcard && (oldcard->type != MMC_TYPE_SD_COMBO ||
+		    memcmp(card->raw_cid, oldcard->raw_cid, sizeof(card->raw_cid)) != 0)) {
+			mmc_remove_card(card);
+			return -ENOENT;
+		}
+	} else {
+		card->type = MMC_TYPE_SDIO;
+
+		if (oldcard && oldcard->type != MMC_TYPE_SDIO) {
+			mmc_remove_card(card);
+			return -ENOENT;
+		}
+	}
 
 	/*
 	 * Call the optional HC's init_card function to handle quirks.
@@ -329,6 +392,17 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 		mmc_set_bus_mode(host, MMC_BUSMODE_PUSHPULL);
 	}
 
+	/*
+	 * Read CSD, before selecting the card
+	 */
+	if (!oldcard && card->type == MMC_TYPE_SD_COMBO) {
+		err = mmc_sd_get_csd(host, card);
+		if (err)
+			return err;
+
+		mmc_decode_cid(card);
+	}
+
 	/*
 	 * Select card, as all following commands rely on that.
 	 */
@@ -356,14 +430,33 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 		int same = (card->cis.vendor == oldcard->cis.vendor &&
 			    card->cis.device == oldcard->cis.device);
 		mmc_remove_card(card);
-		if (!same) {
-			err = -ENOENT;
-			goto err;
-		}
+		if (!same)
+			return -ENOENT;
+
 		card = oldcard;
 		return 0;
 	}
 
+	if (card->type == MMC_TYPE_SD_COMBO) {
+		err = mmc_sd_setup_card(host, card, oldcard != NULL);
+		/* handle as SDIO-only card if memory init failed */
+		if (err) {
+			mmc_go_idle(host);
+			if (mmc_host_is_spi(host))
+				/* should not fail, as it worked previously */
+				mmc_spi_set_crc(host, use_spi_crc);
+			card->type = MMC_TYPE_SDIO;
+		} else
+			card->dev.type = &sd_type;
+	}
+
+	/*
+	 * If needed, disconnect card detection pull-up resistor.
+	 */
+	err = sdio_disable_cd(card);
+	if (err)
+		goto remove;
+
 	/*
 	 * Switch to high-speed (if supported).
 	 */
@@ -381,8 +474,10 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 	/*
 	 * Switch to wider bus (if supported).
 	 */
-	err = sdio_enable_wide(card);
-	if (err)
+	err = sdio_enable_4bit_bus(card);
+	if (err > 0)
+		mmc_set_bus_width(card->host, MMC_BUS_WIDTH_4);
+	else if (err)
 		goto remove;
 
 	if (!oldcard)
@@ -496,9 +591,14 @@ static int mmc_sdio_resume(struct mmc_host *host)
 	mmc_claim_host(host);
 	err = mmc_sdio_init_card(host, host->ocr, host->card,
 				 (host->pm_flags & MMC_PM_KEEP_POWER));
-	if (!err)
+	if (!err) {
 		/* We may have switched to 1-bit mode during suspend. */
-		err = sdio_enable_wide(host->card);
+		err = sdio_enable_4bit_bus(host->card);
+		if (err > 0) {
+			mmc_set_bus_width(host, MMC_BUS_WIDTH_4);
+			err = 0;
+		}
+	}
 	if (!err && host->sdio_irqs)
 		mmc_signal_sdio_irq(host);
 	mmc_release_host(host);
@@ -582,13 +682,6 @@ int mmc_attach_sdio(struct mmc_host *host, u32 ocr)
 	funcs = (ocr & 0x70000000) >> 28;
 	card->sdio_funcs = 0;
 
-	/*
-	 * If needed, disconnect card detection pull-up resistor.
-	 */
-	err = sdio_disable_cd(card);
-	if (err)
-		goto remove;
-
 	/*
 	 * Initialize (but don't add) all present functions.
 	 */

commit 71578a1eaa7b8b9bd3efc9c97d77ef2b63d5dc2b
Author: Michal Miroslaw <mirq-linux@rere.qmqm.pl>
Date:   Tue Aug 10 18:01:40 2010 -0700

    mmc: split mmc_sd_init_card()
    
    This series adds support for SD combo cards to MMC/SD driver stack.
    
    SD combo consists of SD memory and SDIO parts in one package.  Since the
    parts have a separate SD command sets, after initialization, they can be
    treated as independent cards on one bus.
    
    Changes are divided into two patches.  First is just moving initialization
    code around so that SD memory part init can be called from SDIO init.
    Second patch is a proper change enabling SD memory along SDIO.  I tried to
    move as much no-op changes to the first patch so that it's easier to
    follow the required changes to initialization flow for SDIO cards.
    
    This is based on Simplified SDIO spec v.2.00.  The init sequence is
    slightly modified to follow current SD memory init implementation.
    Command sequences, assuming SD memory and SDIO indeed ignore unknown
    commands, are the same as before for both parts.
    
    This patch:
    
    Prepare for SD-combo (IO+mem) support by splitting SD memory
    card init and related functions.
    
    Signed-off-by: Michal Miroslaw <mirq-linux@rere.qmqm.pl>
    Cc: Adrian Hunter <adrian.hunter@nokia.com>
    Cc: Chris Ball <cjb@laptop.org>
    Cc: <linux-mmc@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index b9dee28ee7d0..47d1708810bd 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -18,6 +18,7 @@
 
 #include "core.h"
 #include "bus.h"
+#include "sd.h"
 #include "sdio_bus.h"
 #include "mmc_ops.h"
 #include "sd_ops.h"
@@ -245,10 +246,26 @@ static int sdio_enable_hs(struct mmc_card *card)
 	if (ret)
 		return ret;
 
-	mmc_card_set_highspeed(card);
-	mmc_set_timing(card->host, MMC_TIMING_SD_HS);
+	return 1;
+}
 
-	return 0;
+static unsigned mmc_sdio_get_max_clock(struct mmc_card *card)
+{
+	unsigned max_dtr;
+
+	if (mmc_card_highspeed(card)) {
+		/*
+		 * The SDIO specification doesn't mention how
+		 * the CIS transfer speed register relates to
+		 * high-speed, but it seems that 50 MHz is
+		 * mandatory.
+		 */
+		max_dtr = 50000000;
+	} else {
+		max_dtr = card->cis.max_dtr;
+	}
+
+	return max_dtr;
 }
 
 /*
@@ -351,23 +368,15 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 	 * Switch to high-speed (if supported).
 	 */
 	err = sdio_enable_hs(card);
-	if (err)
+	if (err > 0)
+		mmc_sd_go_highspeed(card);
+	else if (err)
 		goto remove;
 
 	/*
 	 * Change to the card's maximum speed.
 	 */
-	if (mmc_card_highspeed(card)) {
-		/*
-		 * The SDIO specification doesn't mention how
-		 * the CIS transfer speed register relates to
-		 * high-speed, but it seems that 50 MHz is
-		 * mandatory.
-		 */
-		mmc_set_clock(host, 50000000);
-	} else {
-		mmc_set_clock(host, card->cis.max_dtr);
-	}
+	mmc_set_clock(host, mmc_sdio_get_max_clock(card));
 
 	/*
 	 * Switch to wider bus (if supported).

commit 3fcb027d7fd749569665d34a79ce2a8e00bc2ed6
Author: Daniel Mack <daniel@caiaq.de>
Date:   Thu Apr 1 10:03:25 2010 +0200

    ARM: MXC: mxcmmc: work around a bug in the SDHC busy line handling
    
    MX3 SoCs have a silicon bug which corrupts CRC calculation of
    multi-block transfers when connected SDIO peripheral doesn't drive the
    BUSY line as required by the specs.
    
    One way to prevent this is to only allow 1-bit transfers.
    
    Another way is playing tricks with the DMA engine, but this isn't
    mainline yet. So for now, we live with the performance drawback of 1-bit
    transfers until a nicer solution is found.
    
    This patch introduces a new host controller callback 'init_card' which
    is for now only called from mmc_sdio_init_card().
    
    Signed-off-by: Daniel Mack <daniel@caiaq.de>
    Cc: Sascha Hauer <s.hauer@pengutronix.de>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Volker Ernst <volker.ernst@txtr.com>
    Cc: Jiri Kosina <jkosina@suse.cz>
    Cc: Michał Mirosław <mirqus@gmail.com>
    Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 2dd4cfe7ca17..b9dee28ee7d0 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -295,6 +295,12 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 
 	card->type = MMC_TYPE_SDIO;
 
+	/*
+	 * Call the optional HC's init_card function to handle quirks.
+	 */
+	if (host->ops->init_card)
+		host->ops->init_card(host, card);
+
 	/*
 	 * For native busses:  set card RCA and quit open drain mode.
 	 */

commit 6b5eda369ac3772dad416ef96d86064204d74770
Author: Daniel Drake <dsd@laptop.org>
Date:   Fri Mar 5 13:43:34 2010 -0800

    sdio: put active devices into 1-bit mode during suspend
    
    And bring them back to 4-bit mode during resume.
    
    Signed-off-by: Daniel Drake <dsd@laptop.org>
    Signed-off-by: Nicolas Pitre <nico@marvell.com>
    Cc: <linux-mmc@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 5840de106b69..2dd4cfe7ca17 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -187,6 +187,40 @@ static int sdio_disable_cd(struct mmc_card *card)
 	return mmc_io_rw_direct(card, 1, 0, SDIO_CCCR_IF, ctrl, NULL);
 }
 
+/*
+ * Devices that remain active during a system suspend are
+ * put back into 1-bit mode.
+ */
+static int sdio_disable_wide(struct mmc_card *card)
+{
+	int ret;
+	u8 ctrl;
+
+	if (!(card->host->caps & MMC_CAP_4_BIT_DATA))
+		return 0;
+
+	if (card->cccr.low_speed && !card->cccr.wide_bus)
+		return 0;
+
+	ret = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_IF, 0, &ctrl);
+	if (ret)
+		return ret;
+
+	if (!(ctrl & SDIO_BUS_WIDTH_4BIT))
+		return 0;
+
+	ctrl &= ~SDIO_BUS_WIDTH_4BIT;
+	ctrl |= SDIO_BUS_ASYNC_INT;
+
+	ret = mmc_io_rw_direct(card, 1, 0, SDIO_CCCR_IF, ctrl, NULL);
+	if (ret)
+		return ret;
+
+	mmc_set_bus_width(card->host, MMC_BUS_WIDTH_1);
+
+	return 0;
+}
+
 /*
  * Test if the card supports high-speed mode and, if so, switch to it.
  */
@@ -427,6 +461,12 @@ static int mmc_sdio_suspend(struct mmc_host *host)
 		}
 	}
 
+	if (!err && host->pm_flags & MMC_PM_KEEP_POWER) {
+		mmc_claim_host(host);
+		sdio_disable_wide(host->card);
+		mmc_release_host(host);
+	}
+
 	return err;
 }
 
@@ -441,6 +481,9 @@ static int mmc_sdio_resume(struct mmc_host *host)
 	mmc_claim_host(host);
 	err = mmc_sdio_init_card(host, host->ocr, host->card,
 				 (host->pm_flags & MMC_PM_KEEP_POWER));
+	if (!err)
+		/* We may have switched to 1-bit mode during suspend. */
+		err = sdio_enable_wide(host->card);
 	if (!err && host->sdio_irqs)
 		mmc_signal_sdio_irq(host);
 	mmc_release_host(host);

commit 40216842dca4fa485cb1aa5eb231149a4a57cc85
Author: Nicolas Pitre <nico@fluxnic.net>
Date:   Fri Mar 5 13:43:34 2010 -0800

    sdio: kick the interrupt thread upon a resume
    
    Some SDIO cards may suspend while keeping function interrupts active
    especially in the powered suspend case.  Upon resume we need to kick the
    SDIO interrupt thread to check for pending interrupts and to restart card
    IRQ detection at the host controller level.
    
    Signed-off-by: Nicolas Pitre <nico@marvell.com>
    Cc: <linux-mmc@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 7d8ba64b0170..5840de106b69 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -441,6 +441,8 @@ static int mmc_sdio_resume(struct mmc_host *host)
 	mmc_claim_host(host);
 	err = mmc_sdio_init_card(host, host->ocr, host->card,
 				 (host->pm_flags & MMC_PM_KEEP_POWER));
+	if (!err && host->sdio_irqs)
+		mmc_signal_sdio_irq(host);
 	mmc_release_host(host);
 
 	/*

commit 3bca4cf703826fcb2bbabbe19c6fc7b2fc4fd7cc
Author: Chris Ball <cjb@laptop.org>
Date:   Fri Mar 5 13:43:33 2010 -0800

    sdio: don't use CMD[357] as part of a powered SDIO resume
    
    Seen on a Marvell 8686 SDIO card and Via VX855 controller: we must avoid
    sending CMD3/5/7 on a resume where power has been maintained, because the
    8686 will refuse to respond to them and the MMC stack will give up on the
    card.
    
    Signed-off-by: Chris Ball <cjb@laptop.org>
    Signed-off-by: Nicolas Pitre <nico@marvell.com>
    Cc: <linux-mmc@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 06b64085a355..7d8ba64b0170 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -224,7 +224,7 @@ static int sdio_enable_hs(struct mmc_card *card)
  * we're trying to reinitialise.
  */
 static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
-			      struct mmc_card *oldcard)
+			      struct mmc_card *oldcard, int powered_resume)
 {
 	struct mmc_card *card;
 	int err;
@@ -235,9 +235,11 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 	/*
 	 * Inform the card of the voltage
 	 */
-	err = mmc_send_io_op_cond(host, host->ocr, &ocr);
-	if (err)
-		goto err;
+	if (!powered_resume) {
+		err = mmc_send_io_op_cond(host, host->ocr, &ocr);
+		if (err)
+			goto err;
+	}
 
 	/*
 	 * For SPI, enable CRC as appropriate.
@@ -262,7 +264,7 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 	/*
 	 * For native busses:  set card RCA and quit open drain mode.
 	 */
-	if (!mmc_host_is_spi(host)) {
+	if (!powered_resume && !mmc_host_is_spi(host)) {
 		err = mmc_send_relative_addr(host, &card->rca);
 		if (err)
 			goto remove;
@@ -273,7 +275,7 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 	/*
 	 * Select card, as all following commands rely on that.
 	 */
-	if (!mmc_host_is_spi(host)) {
+	if (!powered_resume && !mmc_host_is_spi(host)) {
 		err = mmc_select_card(card);
 		if (err)
 			goto remove;
@@ -437,7 +439,8 @@ static int mmc_sdio_resume(struct mmc_host *host)
 
 	/* Basic card reinitialization. */
 	mmc_claim_host(host);
-	err = mmc_sdio_init_card(host, host->ocr, host->card);
+	err = mmc_sdio_init_card(host, host->ocr, host->card,
+				 (host->pm_flags & MMC_PM_KEEP_POWER));
 	mmc_release_host(host);
 
 	/*
@@ -507,7 +510,7 @@ int mmc_attach_sdio(struct mmc_host *host, u32 ocr)
 	/*
 	 * Detect and init the card.
 	 */
-	err = mmc_sdio_init_card(host, host->ocr, NULL);
+	err = mmc_sdio_init_card(host, host->ocr, NULL, 0);
 	if (err)
 		goto err;
 	card = host->card;

commit e8812793637b4f23f01eb46db86b5dad1fc97f2a
Author: Matt Fleming <matt@console-pimps.org>
Date:   Thu Dec 17 15:27:18 2009 -0800

    sdio: initialise SDIO functions and update card->sdio_funcs in lockstep
    
    Daniel Drake noticed a crash in the error path of mmc_attach_sdio().  This
    bug is discussed at http://dev.laptop.org/ticket/9707.
    
    BUG: unable to handle kernel paging request at 6b6b6c57
    IP: [<b066d6e2>] sdio_remove_func+0x9/0x27
    Call Trace:
    [<b066cfb4>] ? mmc_sdio_remove+0x34/0x65
    [<b066d1fc>] ? mmc_attach_sdio+0x217/0x240
    [<b066a22f>] ? mmc_rescan+0x1a2/0x20f
    [<b042e9a0>] ? worker_thread+0x156/0x1e
    
    We need to accurately track how many SDIO functions have been initialised
    (and keep card->sdio_funcs in sync) so that we don't try to remove more
    functions than we initialised if we hit the error path in
    mmc_attach_sdio().
    
    Without this patch if we hit the error path in mmc_attach_sdio() we run
    the risk of deferencing invalid memory in sdio_remove_func(), leading to a
    crash.
    
    Signed-off-by: Matt Fleming <matt@console-pimps.org>
    Cc: Daniel Drake <dsd@laptop.org>
    Cc: <linux-mmc@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index cdb845b68ab5..06b64085a355 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -516,7 +516,8 @@ int mmc_attach_sdio(struct mmc_host *host, u32 ocr)
 	 * The number of functions on the card is encoded inside
 	 * the ocr.
 	 */
-	card->sdio_funcs = funcs = (ocr & 0x70000000) >> 28;
+	funcs = (ocr & 0x70000000) >> 28;
+	card->sdio_funcs = 0;
 
 	/*
 	 * If needed, disconnect card detection pull-up resistor.
@@ -528,7 +529,7 @@ int mmc_attach_sdio(struct mmc_host *host, u32 ocr)
 	/*
 	 * Initialize (but don't add) all present functions.
 	 */
-	for (i = 0;i < funcs;i++) {
+	for (i = 0; i < funcs; i++, card->sdio_funcs++) {
 		err = sdio_init_func(host->card, i + 1);
 		if (err)
 			goto remove;

commit 95cdfb72b9bc568803f395c266152c71b034b461
Author: Nicolas Pitre <nico@fluxnic.net>
Date:   Tue Sep 22 16:45:29 2009 -0700

    mmc: propagate error codes back from bus drivers' suspend/resume methods
    
    Especially for SDIO drivers which may have special conditions/errors to
    report, it is a good thing to relay the returned error code back to upper
    layers.
    
    This also allows for the rationalization of the resume path where code to
    "remove" a no-longer-existing or replaced card was duplicated into the
    MMC, SD and SDIO bus drivers.
    
    In the SDIO case, if a function suspend method returns an error, then all
    previously suspended functions are resumed and the error returned.  An
    exception is made for -ENOSYS which the core interprets as "we don't
    support suspend so just kick the card out for suspend and return success".
    
    When resuming SDIO cards, the core code only validates the manufacturer
    and product IDs to make sure the same kind of card is still present before
    invoking functions resume methods.  It's the function driver's
    responsibility to perform further tests to confirm that the actual same
    card is present (same MAC address, etc.) and return an error otherwise.
    
    Signed-off-by: Nicolas Pitre <nico@marvell.com>
    Cc: <linux-mmc@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index f4c8637fd072..cdb845b68ab5 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -302,6 +302,7 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 			goto err;
 		}
 		card = oldcard;
+		return 0;
 	}
 
 	/*
@@ -399,62 +400,65 @@ static void mmc_sdio_detect(struct mmc_host *host)
  * Therefore all registered functions must have drivers with suspend
  * and resume methods.  Failing that we simply remove the whole card.
  */
-static void mmc_sdio_suspend(struct mmc_host *host)
+static int mmc_sdio_suspend(struct mmc_host *host)
 {
-	int i;
+	int i, err = 0;
 
-	/* make sure all registered functions can suspend/resume */
 	for (i = 0; i < host->card->sdio_funcs; i++) {
 		struct sdio_func *func = host->card->sdio_func[i];
 		if (func && sdio_func_present(func) && func->dev.driver) {
 			const struct dev_pm_ops *pmops = func->dev.driver->pm;
 			if (!pmops || !pmops->suspend || !pmops->resume) {
-				/* just remove the entire card in that case */
-				mmc_sdio_remove(host);
-				mmc_claim_host(host);
-				mmc_detach_bus(host);
-				mmc_release_host(host);
-				return;
-			}
+				/* force removal of entire card in that case */
+				err = -ENOSYS;
+			} else
+				err = pmops->suspend(&func->dev);
+			if (err)
+				break;
 		}
 	}
-
-	/* now suspend them */
-	for (i = 0; i < host->card->sdio_funcs; i++) {
+	while (err && --i >= 0) {
 		struct sdio_func *func = host->card->sdio_func[i];
 		if (func && sdio_func_present(func) && func->dev.driver) {
 			const struct dev_pm_ops *pmops = func->dev.driver->pm;
-			pmops->suspend(&func->dev);
+			pmops->resume(&func->dev);
 		}
 	}
+
+	return err;
 }
 
-static void mmc_sdio_resume(struct mmc_host *host)
+static int mmc_sdio_resume(struct mmc_host *host)
 {
 	int i, err;
 
 	BUG_ON(!host);
 	BUG_ON(!host->card);
 
+	/* Basic card reinitialization. */
 	mmc_claim_host(host);
 	err = mmc_sdio_init_card(host, host->ocr, host->card);
 	mmc_release_host(host);
-	if (err) {
-		mmc_sdio_remove(host);
-		mmc_claim_host(host);
-		mmc_detach_bus(host);
-		mmc_release_host(host);
-		return;
-	}
 
-	/* resume all functions */
-	for (i = 0; i < host->card->sdio_funcs; i++) {
+	/*
+	 * If the card looked to be the same as before suspending, then
+	 * we proceed to resume all card functions.  If one of them returns
+	 * an error then we simply return that error to the core and the
+	 * card will be redetected as new.  It is the responsibility of
+	 * the function driver to perform further tests with the extra
+	 * knowledge it has of the card to confirm the card is indeed the
+	 * same as before suspending (same MAC address for network cards,
+	 * etc.) and return an error otherwise.
+	 */
+	for (i = 0; !err && i < host->card->sdio_funcs; i++) {
 		struct sdio_func *func = host->card->sdio_func[i];
 		if (func && sdio_func_present(func) && func->dev.driver) {
 			const struct dev_pm_ops *pmops = func->dev.driver->pm;
-			pmops->resume(&func->dev);
+			err = pmops->resume(&func->dev);
 		}
 	}
+
+	return err;
 }
 
 static const struct mmc_bus_ops mmc_sdio_ops = {

commit 17d33e14f7ffc05f8c81e4a3bdb9a8003a05dcce
Author: Nicolas Pitre <nico@fluxnic.net>
Date:   Tue Sep 22 16:45:28 2009 -0700

    mmc: core SDIO suspend/resume support
    
    Currently, all SDIO cards are virtually removed upon a suspend, and
    completely reprobed upon a resume.  This adds the suspend and resume
    methods to the SDIO bus driver so to be able to dispatch those events to
    the actual SDIO function drivers for real suspend/resume instead.
    
    All active functions on a card must have a driver with both a suspend and
    a resume method though.  Failing that, we fall back to the current
    behavior of simply "removing" the card when suspending.
    
    When resuming, we make sure the same card is still inserted by comparing
    the vendor and product IDs.  If there is a mismatch, or if there is simply
    no card anymore in the slot, then the previous card is "removed" and the
    new card is detected.  This is further enhanced with the next patch.
    
    [akpm@linux-foundation.org: fix warnings]
    Signed-off-by: Nicolas Pitre <nico@marvell.com>
    Cc: <linux-mmc@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 2d24a123f0b0..f4c8637fd072 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -217,6 +217,134 @@ static int sdio_enable_hs(struct mmc_card *card)
 	return 0;
 }
 
+/*
+ * Handle the detection and initialisation of a card.
+ *
+ * In the case of a resume, "oldcard" will contain the card
+ * we're trying to reinitialise.
+ */
+static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
+			      struct mmc_card *oldcard)
+{
+	struct mmc_card *card;
+	int err;
+
+	BUG_ON(!host);
+	WARN_ON(!host->claimed);
+
+	/*
+	 * Inform the card of the voltage
+	 */
+	err = mmc_send_io_op_cond(host, host->ocr, &ocr);
+	if (err)
+		goto err;
+
+	/*
+	 * For SPI, enable CRC as appropriate.
+	 */
+	if (mmc_host_is_spi(host)) {
+		err = mmc_spi_set_crc(host, use_spi_crc);
+		if (err)
+			goto err;
+	}
+
+	/*
+	 * Allocate card structure.
+	 */
+	card = mmc_alloc_card(host, NULL);
+	if (IS_ERR(card)) {
+		err = PTR_ERR(card);
+		goto err;
+	}
+
+	card->type = MMC_TYPE_SDIO;
+
+	/*
+	 * For native busses:  set card RCA and quit open drain mode.
+	 */
+	if (!mmc_host_is_spi(host)) {
+		err = mmc_send_relative_addr(host, &card->rca);
+		if (err)
+			goto remove;
+
+		mmc_set_bus_mode(host, MMC_BUSMODE_PUSHPULL);
+	}
+
+	/*
+	 * Select card, as all following commands rely on that.
+	 */
+	if (!mmc_host_is_spi(host)) {
+		err = mmc_select_card(card);
+		if (err)
+			goto remove;
+	}
+
+	/*
+	 * Read the common registers.
+	 */
+	err = sdio_read_cccr(card);
+	if (err)
+		goto remove;
+
+	/*
+	 * Read the common CIS tuples.
+	 */
+	err = sdio_read_common_cis(card);
+	if (err)
+		goto remove;
+
+	if (oldcard) {
+		int same = (card->cis.vendor == oldcard->cis.vendor &&
+			    card->cis.device == oldcard->cis.device);
+		mmc_remove_card(card);
+		if (!same) {
+			err = -ENOENT;
+			goto err;
+		}
+		card = oldcard;
+	}
+
+	/*
+	 * Switch to high-speed (if supported).
+	 */
+	err = sdio_enable_hs(card);
+	if (err)
+		goto remove;
+
+	/*
+	 * Change to the card's maximum speed.
+	 */
+	if (mmc_card_highspeed(card)) {
+		/*
+		 * The SDIO specification doesn't mention how
+		 * the CIS transfer speed register relates to
+		 * high-speed, but it seems that 50 MHz is
+		 * mandatory.
+		 */
+		mmc_set_clock(host, 50000000);
+	} else {
+		mmc_set_clock(host, card->cis.max_dtr);
+	}
+
+	/*
+	 * Switch to wider bus (if supported).
+	 */
+	err = sdio_enable_wide(card);
+	if (err)
+		goto remove;
+
+	if (!oldcard)
+		host->card = card;
+	return 0;
+
+remove:
+	if (!oldcard)
+		mmc_remove_card(card);
+
+err:
+	return err;
+}
+
 /*
  * Host is being removed. Free up the current card.
  */
@@ -266,10 +394,74 @@ static void mmc_sdio_detect(struct mmc_host *host)
 	}
 }
 
+/*
+ * SDIO suspend.  We need to suspend all functions separately.
+ * Therefore all registered functions must have drivers with suspend
+ * and resume methods.  Failing that we simply remove the whole card.
+ */
+static void mmc_sdio_suspend(struct mmc_host *host)
+{
+	int i;
+
+	/* make sure all registered functions can suspend/resume */
+	for (i = 0; i < host->card->sdio_funcs; i++) {
+		struct sdio_func *func = host->card->sdio_func[i];
+		if (func && sdio_func_present(func) && func->dev.driver) {
+			const struct dev_pm_ops *pmops = func->dev.driver->pm;
+			if (!pmops || !pmops->suspend || !pmops->resume) {
+				/* just remove the entire card in that case */
+				mmc_sdio_remove(host);
+				mmc_claim_host(host);
+				mmc_detach_bus(host);
+				mmc_release_host(host);
+				return;
+			}
+		}
+	}
+
+	/* now suspend them */
+	for (i = 0; i < host->card->sdio_funcs; i++) {
+		struct sdio_func *func = host->card->sdio_func[i];
+		if (func && sdio_func_present(func) && func->dev.driver) {
+			const struct dev_pm_ops *pmops = func->dev.driver->pm;
+			pmops->suspend(&func->dev);
+		}
+	}
+}
+
+static void mmc_sdio_resume(struct mmc_host *host)
+{
+	int i, err;
+
+	BUG_ON(!host);
+	BUG_ON(!host->card);
+
+	mmc_claim_host(host);
+	err = mmc_sdio_init_card(host, host->ocr, host->card);
+	mmc_release_host(host);
+	if (err) {
+		mmc_sdio_remove(host);
+		mmc_claim_host(host);
+		mmc_detach_bus(host);
+		mmc_release_host(host);
+		return;
+	}
+
+	/* resume all functions */
+	for (i = 0; i < host->card->sdio_funcs; i++) {
+		struct sdio_func *func = host->card->sdio_func[i];
+		if (func && sdio_func_present(func) && func->dev.driver) {
+			const struct dev_pm_ops *pmops = func->dev.driver->pm;
+			pmops->resume(&func->dev);
+		}
+	}
+}
 
 static const struct mmc_bus_ops mmc_sdio_ops = {
 	.remove = mmc_sdio_remove,
 	.detect = mmc_sdio_detect,
+	.suspend = mmc_sdio_suspend,
+	.resume = mmc_sdio_resume,
 };
 
 
@@ -309,103 +501,18 @@ int mmc_attach_sdio(struct mmc_host *host, u32 ocr)
 	}
 
 	/*
-	 * Inform the card of the voltage
+	 * Detect and init the card.
 	 */
-	err = mmc_send_io_op_cond(host, host->ocr, &ocr);
+	err = mmc_sdio_init_card(host, host->ocr, NULL);
 	if (err)
 		goto err;
-
-	/*
-	 * For SPI, enable CRC as appropriate.
-	 */
-	if (mmc_host_is_spi(host)) {
-		err = mmc_spi_set_crc(host, use_spi_crc);
-		if (err)
-			goto err;
-	}
+	card = host->card;
 
 	/*
 	 * The number of functions on the card is encoded inside
 	 * the ocr.
 	 */
-	funcs = (ocr & 0x70000000) >> 28;
-
-	/*
-	 * Allocate card structure.
-	 */
-	card = mmc_alloc_card(host, NULL);
-	if (IS_ERR(card)) {
-		err = PTR_ERR(card);
-		goto err;
-	}
-
-	card->type = MMC_TYPE_SDIO;
-	card->sdio_funcs = funcs;
-
-	host->card = card;
-
-	/*
-	 * For native busses:  set card RCA and quit open drain mode.
-	 */
-	if (!mmc_host_is_spi(host)) {
-		err = mmc_send_relative_addr(host, &card->rca);
-		if (err)
-			goto remove;
-
-		mmc_set_bus_mode(host, MMC_BUSMODE_PUSHPULL);
-	}
-
-	/*
-	 * Select card, as all following commands rely on that.
-	 */
-	if (!mmc_host_is_spi(host)) {
-		err = mmc_select_card(card);
-		if (err)
-			goto remove;
-	}
-
-	/*
-	 * Read the common registers.
-	 */
-	err = sdio_read_cccr(card);
-	if (err)
-		goto remove;
-
-	/*
-	 * Read the common CIS tuples.
-	 */
-	err = sdio_read_common_cis(card);
-	if (err)
-		goto remove;
-
-	/*
-	 * Switch to high-speed (if supported).
-	 */
-	err = sdio_enable_hs(card);
-	if (err)
-		goto remove;
-
-	/*
-	 * Change to the card's maximum speed.
-	 */
-	if (mmc_card_highspeed(card)) {
-		/*
-		 * The SDIO specification doesn't mention how
-		 * the CIS transfer speed register relates to
-		 * high-speed, but it seems that 50 MHz is
-		 * mandatory.
-		 */
-		mmc_set_clock(host, 50000000);
-	} else {
-		mmc_set_clock(host, card->cis.max_dtr);
-	}
-
-	/*
-	 * Switch to wider bus (if supported).
-	 */
-	err = sdio_enable_wide(card);
-	if (err)
-		goto remove;
+	card->sdio_funcs = funcs = (ocr & 0x70000000) >> 28;
 
 	/*
 	 * If needed, disconnect card detection pull-up resistor.

commit 006ebd5de13854d6250eecc76866bbfad1ff7daf
Author: Ohad Ben-Cohen <ohad@wizery.com>
Date:   Tue Sep 22 16:45:07 2009 -0700

    sdio: add CD disable support
    
    Add support to disconnect the pull-up resistor on CD/DAT[3] (pin 1)
    of the card. This may be desired on certain setups of boards,
    controllers and embedded sdio devices which do not need the card's
    pull-up. As a result, card detection is disabled and power is saved.
    
    [akpm@linux-foundation.org: simplify sdio_disable_cd() a bit]
    Signed-off-by: Ohad Ben-Cohen <ohad@wizery.com>
    Acked-by: Matt Fleming <matt@console-pimps.org>
    Cc: Ian Molton <ian@mnementh.co.uk>
    Cc: "Roberto A. Foglietta" <roberto.foglietta@gmail.com>
    Cc: Philip Langdale <philipl@overt.org>
    Cc: Pierre Ossman <pierre@ossman.eu>
    Cc: David Vrabel <david.vrabel@csr.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 6f221dc029ad..2d24a123f0b0 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -164,6 +164,29 @@ static int sdio_enable_wide(struct mmc_card *card)
 	return 0;
 }
 
+/*
+ * If desired, disconnect the pull-up resistor on CD/DAT[3] (pin 1)
+ * of the card. This may be required on certain setups of boards,
+ * controllers and embedded sdio device which do not need the card's
+ * pull-up. As a result, card detection is disabled and power is saved.
+ */
+static int sdio_disable_cd(struct mmc_card *card)
+{
+	int ret;
+	u8 ctrl;
+
+	if (!card->cccr.disable_cd)
+		return 0;
+
+	ret = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_IF, 0, &ctrl);
+	if (ret)
+		return ret;
+
+	ctrl |= SDIO_BUS_CD_DISABLE;
+
+	return mmc_io_rw_direct(card, 1, 0, SDIO_CCCR_IF, ctrl, NULL);
+}
+
 /*
  * Test if the card supports high-speed mode and, if so, switch to it.
  */
@@ -384,6 +407,13 @@ int mmc_attach_sdio(struct mmc_host *host, u32 ocr)
 	if (err)
 		goto remove;
 
+	/*
+	 * If needed, disconnect card detection pull-up resistor.
+	 */
+	err = sdio_disable_cd(card);
+	if (err)
+		goto remove;
+
 	/*
 	 * Initialize (but don't add) all present functions.
 	 */

commit 27cce39f555def6f5ebe7f03d69ccc44ab25f0b2
Author: Ohad Ben-Cohen <ohad@bencohen.org>
Date:   Tue Sep 22 16:44:28 2009 -0700

    sdio: do not ignore MMC_VDD_165_195
    
    This is needed for 1.8V embedded SDIO devices and supporting host controllers
    (e.g. TI 127x and ZOOM2 boards)
    
    Signed-off-by: Ohad Ben-Cohen <ohad@bencohen.org>
    Acked-by: Matt Fleming <matt@console-pimps.org>
    Cc: Ian Molton <ian@mnementh.co.uk>
    Cc: Pierre Ossman <pierre@ossman.eu>
    Cc: Ian Molton <ian@mnementh.co.uk>
    Cc: "Roberto A. Foglietta" <roberto.foglietta@gmail.com>
    Cc: Philip Langdale <philipl@overt.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index fb99ccff9080..6f221dc029ad 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -275,13 +275,6 @@ int mmc_attach_sdio(struct mmc_host *host, u32 ocr)
 		ocr &= ~0x7F;
 	}
 
-	if (ocr & MMC_VDD_165_195) {
-		printk(KERN_WARNING "%s: SDIO card claims to support the "
-		       "incompletely defined 'low voltage range'. This "
-		       "will be ignored.\n", mmc_hostname(host));
-		ocr &= ~MMC_VDD_165_195;
-	}
-
 	host->ocr = mmc_select_voltage(host, ocr);
 
 	/*

commit d16f57700475f670ca2828c150a34fa7102a05fc
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Sun Aug 31 17:22:46 2008 +0200

    sdio: high-speed support
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 4eab79e09ccc..fb99ccff9080 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -164,6 +164,36 @@ static int sdio_enable_wide(struct mmc_card *card)
 	return 0;
 }
 
+/*
+ * Test if the card supports high-speed mode and, if so, switch to it.
+ */
+static int sdio_enable_hs(struct mmc_card *card)
+{
+	int ret;
+	u8 speed;
+
+	if (!(card->host->caps & MMC_CAP_SD_HIGHSPEED))
+		return 0;
+
+	if (!card->cccr.high_speed)
+		return 0;
+
+	ret = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_SPEED, 0, &speed);
+	if (ret)
+		return ret;
+
+	speed |= SDIO_SPEED_EHS;
+
+	ret = mmc_io_rw_direct(card, 1, 0, SDIO_CCCR_SPEED, speed, NULL);
+	if (ret)
+		return ret;
+
+	mmc_card_set_highspeed(card);
+	mmc_set_timing(card->host, MMC_TIMING_SD_HS);
+
+	return 0;
+}
+
 /*
  * Host is being removed. Free up the current card.
  */
@@ -333,10 +363,26 @@ int mmc_attach_sdio(struct mmc_host *host, u32 ocr)
 		goto remove;
 
 	/*
-	 * No support for high-speed yet, so just set
-	 * the card's maximum speed.
+	 * Switch to high-speed (if supported).
 	 */
-	mmc_set_clock(host, card->cis.max_dtr);
+	err = sdio_enable_hs(card);
+	if (err)
+		goto remove;
+
+	/*
+	 * Change to the card's maximum speed.
+	 */
+	if (mmc_card_highspeed(card)) {
+		/*
+		 * The SDIO specification doesn't mention how
+		 * the CIS transfer speed register relates to
+		 * high-speed, but it seems that 50 MHz is
+		 * mandatory.
+		 */
+		mmc_set_clock(host, 50000000);
+	} else {
+		mmc_set_clock(host, card->cis.max_dtr);
+	}
 
 	/*
 	 * Switch to wider bus (if supported).

commit 51ec92e295d563dd5712d198a7e46c2ae5ccccb2
Author: Pierre Ossman <drzeus-list@drzeus.cx>
Date:   Fri Mar 21 23:54:50 2008 +0100

    mmc: use sysfs groups to handle conditional attributes
    
    Suppressing uevents turned out to be a bad idea as it screws up the
    order of events, making user space very confused. Change the system to
    use sysfs groups instead.
    
    This is a regression that, for some odd reason, has gone unnoticed for
    some time. It confuses hal so that the block devices (which have the
    mmc device as a parent) are not registered. End result being that
    desktop magic when cards are inserted won't work.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 87a50f456efc..4eab79e09ccc 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -287,7 +287,7 @@ int mmc_attach_sdio(struct mmc_host *host, u32 ocr)
 	/*
 	 * Allocate card structure.
 	 */
-	card = mmc_alloc_card(host);
+	card = mmc_alloc_card(host, NULL);
 	if (IS_ERR(card)) {
 		err = PTR_ERR(card);
 		goto err;

commit af51715079e7fb6b290e1881d63d815dc4de5011
Author: David Brownell <david-b@pacbell.net>
Date:   Wed Aug 8 09:11:32 2007 -0700

    MMC core learns about SPI
    
    Teach the MMC/SD/SDIO core about using SPI mode.
    
     - Use mmc_host_is_spi() so enumeration works through SPI signaling
       and protocols, not just the native versions.
    
     - Provide the SPI response type flags with each request issued,
       including requests from the new lock/unlock code.
    
     - Understand that cmd->resp[0] and mmc_get_status() results for SPI
       return different values than for "native" MMC/SD protocol; this
       affects resetting, checking card lock status, and some others.
    
     - Understand that some commands act a bit differently ... notably:
         * OP_COND command doesn't return the OCR
         * APP_CMD status doesn't have an R1_APP_CMD analogue
    
    Those changes required some new and updated primitives:
    
     - Provide utilities to access two SPI-only requests, and one
       request that wasn't previously needed:
         * mmc_spi_read_ocr() ... SPI only
         * mmc_spi_set_crc() ... SPI only (override by module parm)
         * mmc_send_cid() ... for use without broadcast mode
    
     - Updated internal routines:
         * Previous mmc_send_csd() modified into mmc_send_cxd_native();
           it uses native "R2" responses, which include 16 bytes of data.
         * Previous mmc_send_ext_csd() becomes new mmc_send_cxd_data()
           helper for command-and-data access
         * Bugfix to that mmc_send_cxd_data() code:  dma-to-stack is
           unsafe/nonportable, so kmalloc a bounce buffer instead.
    
     - Modified mmc_send_ext_csd() now uses mmc_send_cxd_data() helper
    
     - Modified mmc_send_csd(), and new mmc_spi_send_cid(), routines use
       those helper routines based on whether they're native or SPI
    
    The newest categories of cards supported by the MMC stack aren't expected
    to work yet with SPI:  MMC or SD cards with over 4GB data, and SDIO.
    All those cards support SPI mode, so eventually they should work too.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 2f3fb994c383..87a50f456efc 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -269,6 +269,15 @@ int mmc_attach_sdio(struct mmc_host *host, u32 ocr)
 	if (err)
 		goto err;
 
+	/*
+	 * For SPI, enable CRC as appropriate.
+	 */
+	if (mmc_host_is_spi(host)) {
+		err = mmc_spi_set_crc(host, use_spi_crc);
+		if (err)
+			goto err;
+	}
+
 	/*
 	 * The number of functions on the card is encoded inside
 	 * the ocr.
@@ -290,20 +299,24 @@ int mmc_attach_sdio(struct mmc_host *host, u32 ocr)
 	host->card = card;
 
 	/*
-	 * Set card RCA.
+	 * For native busses:  set card RCA and quit open drain mode.
 	 */
-	err = mmc_send_relative_addr(host, &card->rca);
-	if (err)
-		goto remove;
+	if (!mmc_host_is_spi(host)) {
+		err = mmc_send_relative_addr(host, &card->rca);
+		if (err)
+			goto remove;
 
-	mmc_set_bus_mode(host, MMC_BUSMODE_PUSHPULL);
+		mmc_set_bus_mode(host, MMC_BUSMODE_PUSHPULL);
+	}
 
 	/*
 	 * Select card, as all following commands rely on that.
 	 */
-	err = mmc_select_card(card);
-	if (err)
-		goto remove;
+	if (!mmc_host_is_spi(host)) {
+		err = mmc_select_card(card);
+		if (err)
+			goto remove;
+	}
 
 	/*
 	 * Read the common registers.

commit d84075c8aed771d47d7ac6e96b098559da361c25
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Thu Aug 9 13:23:56 2007 +0200

    mmc: replace BUG_ON with WARN_ON
    
    Replace all cases of BUG_ON with WARN_ON where there is a chance
    (with varying degrees of slim) that the kernel can continue without
    incidence.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 58cf36e44678..2f3fb994c383 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -230,7 +230,7 @@ int mmc_attach_sdio(struct mmc_host *host, u32 ocr)
 	struct mmc_card *card;
 
 	BUG_ON(!host);
-	BUG_ON(!host->claimed);
+	WARN_ON(!host->claimed);
 
 	mmc_attach_bus(host, &mmc_sdio_ops);
 

commit 7616ee95f27a04fd5a6434e9ef4a82cec4b2807c
Author: David Vrabel <david.vrabel@csr.com>
Date:   Wed Aug 8 14:23:05 2007 +0100

    sdio: add SDIO_FBR_BASE(f) macro
    
    Signed-off-by: David Vrabel <david.vrabel@csr.com>
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 48c465a8e34e..58cf36e44678 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -30,7 +30,7 @@ static int sdio_read_fbr(struct sdio_func *func)
 	unsigned char data;
 
 	ret = mmc_io_rw_direct(func->card, 0, 0,
-		func->num * 0x100 + SDIO_FBR_STD_IF, 0, &data);
+		SDIO_FBR_BASE(func->num) + SDIO_FBR_STD_IF, 0, &data);
 	if (ret)
 		goto out;
 
@@ -38,7 +38,7 @@ static int sdio_read_fbr(struct sdio_func *func)
 
 	if (data == 0x0f) {
 		ret = mmc_io_rw_direct(func->card, 0, 0,
-			func->num * 0x100 + SDIO_FBR_STD_IF_EXT, 0, &data);
+			SDIO_FBR_BASE(func->num) + SDIO_FBR_STD_IF_EXT, 0, &data);
 		if (ret)
 			goto out;
 	}

commit 4ff6471c028a9885e8f09a000d87694f81190ab9
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Mon Jul 30 18:23:53 2007 +0200

    sdio: enable wide bus mode
    
    Enable 4-bit data bus mode, according to host and card
    capabilities.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 62df8e177585..48c465a8e34e 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -138,6 +138,32 @@ static int sdio_read_cccr(struct mmc_card *card)
 	return ret;
 }
 
+static int sdio_enable_wide(struct mmc_card *card)
+{
+	int ret;
+	u8 ctrl;
+
+	if (!(card->host->caps & MMC_CAP_4_BIT_DATA))
+		return 0;
+
+	if (card->cccr.low_speed && !card->cccr.wide_bus)
+		return 0;
+
+	ret = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_IF, 0, &ctrl);
+	if (ret)
+		return ret;
+
+	ctrl |= SDIO_BUS_WIDTH_4BIT;
+
+	ret = mmc_io_rw_direct(card, 1, 0, SDIO_CCCR_IF, ctrl, NULL);
+	if (ret)
+		return ret;
+
+	mmc_set_bus_width(card->host, MMC_BUS_WIDTH_4);
+
+	return 0;
+}
+
 /*
  * Host is being removed. Free up the current card.
  */
@@ -299,6 +325,13 @@ int mmc_attach_sdio(struct mmc_host *host, u32 ocr)
 	 */
 	mmc_set_clock(host, card->cis.max_dtr);
 
+	/*
+	 * Switch to wider bus (if supported).
+	 */
+	err = sdio_enable_wide(card);
+	if (err)
+		goto remove;
+
 	/*
 	 * Initialize (but don't add) all present functions.
 	 */

commit 6db5020e7386ddf17378f91eb8c445433e5b07cd
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Mon Jul 30 17:15:07 2007 +0200

    sdio: change clock speed
    
    Change clock speed to the highest supported by the card.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 1fb36a340468..62df8e177585 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -293,6 +293,12 @@ int mmc_attach_sdio(struct mmc_host *host, u32 ocr)
 	if (err)
 		goto remove;
 
+	/*
+	 * No support for high-speed yet, so just set
+	 * the card's maximum speed.
+	 */
+	mmc_set_clock(host, card->cis.max_dtr);
+
 	/*
 	 * Initialize (but don't add) all present functions.
 	 */

commit 1a632f8cdc33e7f8edca352164f0c96a75d08f08
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Mon Jul 30 15:15:30 2007 +0200

    sdio: split up common and function CIS parsing
    
    Add a more clean separation between global, common CIS information
    and the function specific one as we need the common information in
    places where no specific function is specified.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index c5baf76146b2..1fb36a340468 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -66,7 +66,7 @@ static int sdio_init_func(struct mmc_card *card, unsigned int fn)
 	if (ret)
 		goto fail;
 
-	ret = sdio_read_cis(func);
+	ret = sdio_read_func_cis(func);
 	if (ret)
 		goto fail;
 
@@ -286,6 +286,13 @@ int mmc_attach_sdio(struct mmc_host *host, u32 ocr)
 	if (err)
 		goto remove;
 
+	/*
+	 * Read the common CIS tuples.
+	 */
+	err = sdio_read_common_cis(card);
+	if (err)
+		goto remove;
+
 	/*
 	 * Initialize (but don't add) all present functions.
 	 */

commit b726126196d54cbbba0924191e5c4dd5ba747fa2
Author: Nicolas Pitre <nico@cam.org>
Date:   Sat Jun 16 02:04:16 2007 -0400

    sdio: initial CIS parsing code
    
    Signed-off-by: Nicolas Pitre <npitre@mvista.com>
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index be623856f288..c5baf76146b2 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -22,6 +22,7 @@
 #include "mmc_ops.h"
 #include "sd_ops.h"
 #include "sdio_ops.h"
+#include "sdio_cis.h"
 
 static int sdio_read_fbr(struct sdio_func *func)
 {
@@ -65,6 +66,10 @@ static int sdio_init_func(struct mmc_card *card, unsigned int fn)
 	if (ret)
 		goto fail;
 
+	ret = sdio_read_cis(func);
+	if (ret)
+		goto fail;
+
 	card->sdio_func[fn - 1] = func;
 
 	return 0;

commit 0597007f1b22bbb5d4234ca09c045f9bb2711270
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Mon Jun 11 21:01:00 2007 +0200

    sdio: basic parsing of FBR
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 7ce3e3104d21..be623856f288 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -23,8 +23,34 @@
 #include "sd_ops.h"
 #include "sdio_ops.h"
 
+static int sdio_read_fbr(struct sdio_func *func)
+{
+	int ret;
+	unsigned char data;
+
+	ret = mmc_io_rw_direct(func->card, 0, 0,
+		func->num * 0x100 + SDIO_FBR_STD_IF, 0, &data);
+	if (ret)
+		goto out;
+
+	data &= 0x0f;
+
+	if (data == 0x0f) {
+		ret = mmc_io_rw_direct(func->card, 0, 0,
+			func->num * 0x100 + SDIO_FBR_STD_IF_EXT, 0, &data);
+		if (ret)
+			goto out;
+	}
+
+	func->class = data;
+
+out:
+	return ret;
+}
+
 static int sdio_init_func(struct mmc_card *card, unsigned int fn)
 {
+	int ret;
 	struct sdio_func *func;
 
 	BUG_ON(fn > SDIO_MAX_FUNCS);
@@ -35,9 +61,21 @@ static int sdio_init_func(struct mmc_card *card, unsigned int fn)
 
 	func->num = fn;
 
+	ret = sdio_read_fbr(func);
+	if (ret)
+		goto fail;
+
 	card->sdio_func[fn - 1] = func;
 
 	return 0;
+
+fail:
+	/*
+	 * It is okay to remove the function here even though we hold
+	 * the host lock as we haven't registered the device yet.
+	 */
+	sdio_remove_func(func);
+	return ret;
 }
 
 static int sdio_read_cccr(struct mmc_card *card)

commit 35c66c19088bddb11110c124bad8abd4441a8421
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Mon Jun 11 20:25:43 2007 +0200

    sdio: read and decode interesting parts of the CCCR
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 444328581cec..7ce3e3104d21 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -13,6 +13,7 @@
 
 #include <linux/mmc/host.h>
 #include <linux/mmc/card.h>
+#include <linux/mmc/sdio.h>
 #include <linux/mmc/sdio_func.h>
 
 #include "core.h"
@@ -39,6 +40,61 @@ static int sdio_init_func(struct mmc_card *card, unsigned int fn)
 	return 0;
 }
 
+static int sdio_read_cccr(struct mmc_card *card)
+{
+	int ret;
+	int cccr_vsn;
+	unsigned char data;
+
+	memset(&card->cccr, 0, sizeof(struct sdio_cccr));
+
+	ret = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_CCCR, 0, &data);
+	if (ret)
+		goto out;
+
+	cccr_vsn = data & 0x0f;
+
+	if (cccr_vsn > SDIO_CCCR_REV_1_20) {
+		printk(KERN_ERR "%s: unrecognised CCCR structure version %d\n",
+			mmc_hostname(card->host), cccr_vsn);
+		return -EINVAL;
+	}
+
+	card->cccr.sdio_vsn = (data & 0xf0) >> 4;
+
+	ret = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_CAPS, 0, &data);
+	if (ret)
+		goto out;
+
+	if (data & SDIO_CCCR_CAP_SMB)
+		card->cccr.multi_block = 1;
+	if (data & SDIO_CCCR_CAP_LSC)
+		card->cccr.low_speed = 1;
+	if (data & SDIO_CCCR_CAP_4BLS)
+		card->cccr.wide_bus = 1;
+
+	if (cccr_vsn >= SDIO_CCCR_REV_1_10) {
+		ret = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_POWER, 0, &data);
+		if (ret)
+			goto out;
+
+		if (data & SDIO_POWER_SMPC)
+			card->cccr.high_power = 1;
+	}
+
+	if (cccr_vsn >= SDIO_CCCR_REV_1_20) {
+		ret = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_SPEED, 0, &data);
+		if (ret)
+			goto out;
+
+		if (data & SDIO_SPEED_SHS)
+			card->cccr.high_speed = 1;
+	}
+
+out:
+	return ret;
+}
+
 /*
  * Host is being removed. Free up the current card.
  */
@@ -180,6 +236,13 @@ int mmc_attach_sdio(struct mmc_host *host, u32 ocr)
 	if (err)
 		goto remove;
 
+	/*
+	 * Read the common registers.
+	 */
+	err = sdio_read_cccr(card);
+	if (err)
+		goto remove;
+
 	/*
 	 * Initialize (but don't add) all present functions.
 	 */

commit e29a7d73f4277eb92aa64e17017dea33460828ef
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Sat May 26 13:48:18 2007 +0200

    mmc: basic SDIO device model
    
    Add the sdio bus type and basic device handling.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index ac0dd68df8e7..444328581cec 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -13,21 +13,49 @@
 
 #include <linux/mmc/host.h>
 #include <linux/mmc/card.h>
+#include <linux/mmc/sdio_func.h>
 
 #include "core.h"
 #include "bus.h"
+#include "sdio_bus.h"
 #include "mmc_ops.h"
 #include "sd_ops.h"
 #include "sdio_ops.h"
 
+static int sdio_init_func(struct mmc_card *card, unsigned int fn)
+{
+	struct sdio_func *func;
+
+	BUG_ON(fn > SDIO_MAX_FUNCS);
+
+	func = sdio_alloc_func(card);
+	if (IS_ERR(func))
+		return PTR_ERR(func);
+
+	func->num = fn;
+
+	card->sdio_func[fn - 1] = func;
+
+	return 0;
+}
+
 /*
  * Host is being removed. Free up the current card.
  */
 static void mmc_sdio_remove(struct mmc_host *host)
 {
+	int i;
+
 	BUG_ON(!host);
 	BUG_ON(!host->card);
 
+	for (i = 0;i < host->card->sdio_funcs;i++) {
+		if (host->card->sdio_func[i]) {
+			sdio_remove_func(host->card->sdio_func[i]);
+			host->card->sdio_func[i] = NULL;
+		}
+	}
+
 	mmc_remove_card(host->card);
 	host->card = NULL;
 }
@@ -73,7 +101,7 @@ static const struct mmc_bus_ops mmc_sdio_ops = {
 int mmc_attach_sdio(struct mmc_host *host, u32 ocr)
 {
 	int err;
-	int funcs;
+	int i, funcs;
 	struct mmc_card *card;
 
 	BUG_ON(!host);
@@ -132,13 +160,16 @@ int mmc_attach_sdio(struct mmc_host *host, u32 ocr)
 	}
 
 	card->type = MMC_TYPE_SDIO;
+	card->sdio_funcs = funcs;
+
+	host->card = card;
 
 	/*
 	 * Set card RCA.
 	 */
 	err = mmc_send_relative_addr(host, &card->rca);
 	if (err)
-		goto free_card;
+		goto remove;
 
 	mmc_set_bus_mode(host, MMC_BUSMODE_PUSHPULL);
 
@@ -147,23 +178,46 @@ int mmc_attach_sdio(struct mmc_host *host, u32 ocr)
 	 */
 	err = mmc_select_card(card);
 	if (err)
-		goto free_card;
+		goto remove;
 
-	host->card = card;
+	/*
+	 * Initialize (but don't add) all present functions.
+	 */
+	for (i = 0;i < funcs;i++) {
+		err = sdio_init_func(host->card, i + 1);
+		if (err)
+			goto remove;
+	}
 
 	mmc_release_host(host);
 
+	/*
+	 * First add the card to the driver model...
+	 */
 	err = mmc_add_card(host->card);
 	if (err)
-		goto reclaim_host;
+		goto remove_added;
+
+	/*
+	 * ...then the SDIO functions.
+	 */
+	for (i = 0;i < funcs;i++) {
+		err = sdio_add_func(host->card->sdio_func[i]);
+		if (err)
+			goto remove_added;
+	}
 
 	return 0;
 
-reclaim_host:
+
+remove_added:
+	/* Remove without lock if the device has been added. */
+	mmc_sdio_remove(host);
 	mmc_claim_host(host);
-free_card:
-	mmc_remove_card(card);
-	host->card = NULL;
+remove:
+	/* And with lock if it hasn't been added. */
+	if (host->card)
+		mmc_sdio_remove(host);
 err:
 	mmc_detach_bus(host);
 	mmc_release_host(host);

commit 5c4e6f1301649d5b29dd0f70e6da83e728ab5ca5
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Mon May 21 20:23:20 2007 +0200

    mmc: detect SDIO cards
    
    Really basic init sequence for SDIO cards.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
new file mode 100644
index 000000000000..ac0dd68df8e7
--- /dev/null
+++ b/drivers/mmc/core/sdio.c
@@ -0,0 +1,176 @@
+/*
+ *  linux/drivers/mmc/sdio.c
+ *
+ *  Copyright 2006-2007 Pierre Ossman
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at
+ * your option) any later version.
+ */
+
+#include <linux/err.h>
+
+#include <linux/mmc/host.h>
+#include <linux/mmc/card.h>
+
+#include "core.h"
+#include "bus.h"
+#include "mmc_ops.h"
+#include "sd_ops.h"
+#include "sdio_ops.h"
+
+/*
+ * Host is being removed. Free up the current card.
+ */
+static void mmc_sdio_remove(struct mmc_host *host)
+{
+	BUG_ON(!host);
+	BUG_ON(!host->card);
+
+	mmc_remove_card(host->card);
+	host->card = NULL;
+}
+
+/*
+ * Card detection callback from host.
+ */
+static void mmc_sdio_detect(struct mmc_host *host)
+{
+	int err;
+
+	BUG_ON(!host);
+	BUG_ON(!host->card);
+
+	mmc_claim_host(host);
+
+	/*
+	 * Just check if our card has been removed.
+	 */
+	err = mmc_select_card(host->card);
+
+	mmc_release_host(host);
+
+	if (err) {
+		mmc_sdio_remove(host);
+
+		mmc_claim_host(host);
+		mmc_detach_bus(host);
+		mmc_release_host(host);
+	}
+}
+
+
+static const struct mmc_bus_ops mmc_sdio_ops = {
+	.remove = mmc_sdio_remove,
+	.detect = mmc_sdio_detect,
+};
+
+
+/*
+ * Starting point for SDIO card init.
+ */
+int mmc_attach_sdio(struct mmc_host *host, u32 ocr)
+{
+	int err;
+	int funcs;
+	struct mmc_card *card;
+
+	BUG_ON(!host);
+	BUG_ON(!host->claimed);
+
+	mmc_attach_bus(host, &mmc_sdio_ops);
+
+	/*
+	 * Sanity check the voltages that the card claims to
+	 * support.
+	 */
+	if (ocr & 0x7F) {
+		printk(KERN_WARNING "%s: card claims to support voltages "
+		       "below the defined range. These will be ignored.\n",
+		       mmc_hostname(host));
+		ocr &= ~0x7F;
+	}
+
+	if (ocr & MMC_VDD_165_195) {
+		printk(KERN_WARNING "%s: SDIO card claims to support the "
+		       "incompletely defined 'low voltage range'. This "
+		       "will be ignored.\n", mmc_hostname(host));
+		ocr &= ~MMC_VDD_165_195;
+	}
+
+	host->ocr = mmc_select_voltage(host, ocr);
+
+	/*
+	 * Can we support the voltage(s) of the card(s)?
+	 */
+	if (!host->ocr) {
+		err = -EINVAL;
+		goto err;
+	}
+
+	/*
+	 * Inform the card of the voltage
+	 */
+	err = mmc_send_io_op_cond(host, host->ocr, &ocr);
+	if (err)
+		goto err;
+
+	/*
+	 * The number of functions on the card is encoded inside
+	 * the ocr.
+	 */
+	funcs = (ocr & 0x70000000) >> 28;
+
+	/*
+	 * Allocate card structure.
+	 */
+	card = mmc_alloc_card(host);
+	if (IS_ERR(card)) {
+		err = PTR_ERR(card);
+		goto err;
+	}
+
+	card->type = MMC_TYPE_SDIO;
+
+	/*
+	 * Set card RCA.
+	 */
+	err = mmc_send_relative_addr(host, &card->rca);
+	if (err)
+		goto free_card;
+
+	mmc_set_bus_mode(host, MMC_BUSMODE_PUSHPULL);
+
+	/*
+	 * Select card, as all following commands rely on that.
+	 */
+	err = mmc_select_card(card);
+	if (err)
+		goto free_card;
+
+	host->card = card;
+
+	mmc_release_host(host);
+
+	err = mmc_add_card(host->card);
+	if (err)
+		goto reclaim_host;
+
+	return 0;
+
+reclaim_host:
+	mmc_claim_host(host);
+free_card:
+	mmc_remove_card(card);
+	host->card = NULL;
+err:
+	mmc_detach_bus(host);
+	mmc_release_host(host);
+
+	printk(KERN_ERR "%s: error %d whilst initialising SDIO card\n",
+		mmc_hostname(host), err);
+
+	return err;
+}
+
