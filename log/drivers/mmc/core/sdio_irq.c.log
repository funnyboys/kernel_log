commit 6660d0ae1255ab2142dc3c6c790f3f309f0676bd
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Fri Feb 21 17:31:47 2020 +0100

    mmc: core: Fix indentation
    
    sdio_single_irq_set() was indented with a mix of tabs and spaces.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200221163147.608677-1-Jerome.Pouiller@silabs.com
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sdio_irq.c b/drivers/mmc/core/sdio_irq.c
index 900871073bd7..3ffe4ff49aa7 100644
--- a/drivers/mmc/core/sdio_irq.c
+++ b/drivers/mmc/core/sdio_irq.c
@@ -276,14 +276,15 @@ static void sdio_single_irq_set(struct mmc_card *card)
 
 	card->sdio_single_irq = NULL;
 	if ((card->host->caps & MMC_CAP_SDIO_IRQ) &&
-	    card->host->sdio_irqs == 1)
+	    card->host->sdio_irqs == 1) {
 		for (i = 0; i < card->sdio_funcs; i++) {
-		       func = card->sdio_func[i];
-		       if (func && func->irq_handler) {
-			       card->sdio_single_irq = func;
-			       break;
-		       }
-	       }
+			func = card->sdio_func[i];
+			if (func && func->irq_handler) {
+				card->sdio_single_irq = func;
+				break;
+			}
+		}
+	}
 }
 
 /**

commit 51133850bce2a9e5060c6931ee58ceb685578dbf
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Sun Sep 8 12:12:33 2019 +0200

    mmc: core: Fixup processing of SDIO IRQs during system suspend/resume
    
    System suspend/resume of SDIO cards, with SDIO IRQs enabled and when using
    MMC_CAP2_SDIO_IRQ_NOTHREAD is unfortunate still suffering from a fragile
    behaviour. Some problems have been taken care of so far, but more issues
    remains.
    
    For example, calling the ->ack_sdio_irq() callback to let host drivers
    re-enable the SDIO IRQs is a bad idea, unless the IRQ have been consumed,
    which may not be the case during system suspend/resume. This may lead to
    that a host driver re-signals the same SDIO IRQ over and over again,
    causing a storm of IRQs and gives a ping-pong effect towards the
    sdio_irq_work().
    
    Moreover, calling the ->enable_sdio_irq() callback at system resume to
    re-enable already enabled SDIO IRQs for the host, causes the runtime PM
    count for some host drivers to become in-balanced. This then leads to the
    host to remain runtime resumed, no matter if it's needed or not.
    
    To fix these problems, let's check if process_sdio_pending_irqs() actually
    consumed the SDIO IRQ, before we continue to ack the IRQ by invoking the
    ->ack_sdio_irq() callback.
    
    Additionally, there should be no need to re-enable SDIO IRQs as the host
    driver already knows if they were enabled at system suspend, thus also
    whether it needs to re-enable them at system resume. For this reason, drop
    the call to ->enable_sdio_irq() during system resume.
    
    In regards to these changes there is yet another issue, which is when there
    is an SDIO IRQ being signaled by the host driver, but after the SDIO card
    has been system suspended. Currently these IRQs are just thrown away, while
    we should at least make sure to try to consume them when the SDIO card has
    been system resumed. Fix this by queueing a sdio_irq_work() after we system
    resumed the SDIO card.
    
    Tested-by: Matthias Kaehlcke <mka@chromium.org>
    Reviewed-by: Matthias Kaehlcke <mka@chromium.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Douglas Anderson <dianders@chromium.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sdio_irq.c b/drivers/mmc/core/sdio_irq.c
index d7965b53a6d2..900871073bd7 100644
--- a/drivers/mmc/core/sdio_irq.c
+++ b/drivers/mmc/core/sdio_irq.c
@@ -115,7 +115,8 @@ static void sdio_run_irqs(struct mmc_host *host)
 	mmc_claim_host(host);
 	if (host->sdio_irqs) {
 		process_sdio_pending_irqs(host);
-		host->ops->ack_sdio_irq(host);
+		if (!host->sdio_irq_pending)
+			host->ops->ack_sdio_irq(host);
 	}
 	mmc_release_host(host);
 }

commit 2c32dbbb5fc09a26e3a1c39bbf57537c54ed3e91
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Sun Sep 8 12:12:31 2019 +0200

    mmc: core: Clarify that the ->ack_sdio_irq() callback is mandatory
    
    For the MMC_CAP2_SDIO_IRQ_NOTHREAD case and when using sdio_signal_irq(),
    the ->ack_sdio_irq() is already mandatory, which was not the case for those
    host drivers that called sdio_run_irqs() directly.
    
    As there are no longer any drivers calling sdio_run_irqs(), let's clarify
    the code by dropping the unnecessary check and explicitly state that the
    callback is mandatory in the header file.
    
    Tested-by: Matthias Kaehlcke <mka@chromium.org>
    Reviewed-by: Matthias Kaehlcke <mka@chromium.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Douglas Anderson <dianders@chromium.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sdio_irq.c b/drivers/mmc/core/sdio_irq.c
index 0962a4357d54..d7965b53a6d2 100644
--- a/drivers/mmc/core/sdio_irq.c
+++ b/drivers/mmc/core/sdio_irq.c
@@ -115,8 +115,7 @@ static void sdio_run_irqs(struct mmc_host *host)
 	mmc_claim_host(host);
 	if (host->sdio_irqs) {
 		process_sdio_pending_irqs(host);
-		if (host->ops->ack_sdio_irq)
-			host->ops->ack_sdio_irq(host);
+		host->ops->ack_sdio_irq(host);
 	}
 	mmc_release_host(host);
 }

commit 36d57efb4af534dd6b442ea0b9a04aa6dfa37abe
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Sun Sep 8 12:12:30 2019 +0200

    mmc: core: Clarify sdio_irq_pending flag for MMC_CAP2_SDIO_IRQ_NOTHREAD
    
    The sdio_irq_pending flag is used to let host drivers indicate that it has
    signaled an IRQ. If that is the case and we only have a single SDIO func
    that have claimed an SDIO IRQ, our assumption is that we can avoid reading
    the SDIO_CCCR_INTx register and just call the SDIO func irq handler
    immediately. This makes sense, but the flag is set/cleared in a somewhat
    messy order, let's fix that up according to below.
    
    First, the flag is currently set in sdio_run_irqs(), which is executed as a
    work that was scheduled from sdio_signal_irq(). To make it more implicit
    that the host have signaled an IRQ, let's instead immediately set the flag
    in sdio_signal_irq(). This also makes the behavior consistent with host
    drivers that uses the legacy, mmc_signal_sdio_irq() API. This have no
    functional impact, because we don't expect host drivers to call
    sdio_signal_irq() until after the work (sdio_run_irqs()) have been executed
    anyways.
    
    Second, currently we never clears the flag when using the sdio_run_irqs()
    work, but only when using the sdio_irq_thread(). Let make the behavior
    consistent, by moving the flag to be cleared inside the common
    process_sdio_pending_irqs() function. Additionally, tweak the behavior of
    the flag slightly, by avoiding to clear it unless we processed the SDIO
    IRQ. The purpose with this at this point, is to keep the information about
    whether there have been an SDIO IRQ signaled by the host, so at system
    resume we can decide to process it without reading the SDIO_CCCR_INTx
    register.
    
    Tested-by: Matthias Kaehlcke <mka@chromium.org>
    Reviewed-by: Matthias Kaehlcke <mka@chromium.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Douglas Anderson <dianders@chromium.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sdio_irq.c b/drivers/mmc/core/sdio_irq.c
index f75043266984..0962a4357d54 100644
--- a/drivers/mmc/core/sdio_irq.c
+++ b/drivers/mmc/core/sdio_irq.c
@@ -59,6 +59,7 @@ static int process_sdio_pending_irqs(struct mmc_host *host)
 {
 	struct mmc_card *card = host->card;
 	int i, ret, count;
+	bool sdio_irq_pending = host->sdio_irq_pending;
 	unsigned char pending;
 	struct sdio_func *func;
 
@@ -66,13 +67,16 @@ static int process_sdio_pending_irqs(struct mmc_host *host)
 	if (mmc_card_suspended(card))
 		return 0;
 
+	/* Clear the flag to indicate that we have processed the IRQ. */
+	host->sdio_irq_pending = false;
+
 	/*
 	 * Optimization, if there is only 1 function interrupt registered
 	 * and we know an IRQ was signaled then call irq handler directly.
 	 * Otherwise do the full probe.
 	 */
 	func = card->sdio_single_irq;
-	if (func && host->sdio_irq_pending) {
+	if (func && sdio_irq_pending) {
 		func->irq_handler(func);
 		return 1;
 	}
@@ -110,7 +114,6 @@ static void sdio_run_irqs(struct mmc_host *host)
 {
 	mmc_claim_host(host);
 	if (host->sdio_irqs) {
-		host->sdio_irq_pending = true;
 		process_sdio_pending_irqs(host);
 		if (host->ops->ack_sdio_irq)
 			host->ops->ack_sdio_irq(host);
@@ -128,6 +131,7 @@ void sdio_irq_work(struct work_struct *work)
 
 void sdio_signal_irq(struct mmc_host *host)
 {
+	host->sdio_irq_pending = true;
 	queue_delayed_work(system_wq, &host->sdio_irq_work, 0);
 }
 EXPORT_SYMBOL_GPL(sdio_signal_irq);
@@ -173,7 +177,6 @@ static int sdio_irq_thread(void *_host)
 		if (ret)
 			break;
 		ret = process_sdio_pending_irqs(host);
-		host->sdio_irq_pending = false;
 		mmc_release_host(host);
 
 		/*

commit a29b5fcc3d60c2446d8aa3955acebfe2bba95fa6
Author: Matthias Kaehlcke <mka@chromium.org>
Date:   Sun Sep 8 12:12:29 2019 +0200

    mmc: core: Move code to get pending SDIO IRQs to a function
    
    To improve code quality, let's move the code that gets pending SDIO IRQs
    from process_sdio_pending_irqs() into a dedicated function.
    
    Signed-off-by: Matthias Kaehlcke <mka@chromium.org>
    [Ulf: Converted function into static]
    Tested-by: Matthias Kaehlcke <mka@chromium.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Douglas Anderson <dianders@chromium.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sdio_irq.c b/drivers/mmc/core/sdio_irq.c
index 0bcc5e83bd1a..f75043266984 100644
--- a/drivers/mmc/core/sdio_irq.c
+++ b/drivers/mmc/core/sdio_irq.c
@@ -27,6 +27,34 @@
 #include "core.h"
 #include "card.h"
 
+static int sdio_get_pending_irqs(struct mmc_host *host, u8 *pending)
+{
+	struct mmc_card *card = host->card;
+	int ret;
+
+	WARN_ON(!host->claimed);
+
+	ret = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_INTx, 0, pending);
+	if (ret) {
+		pr_debug("%s: error %d reading SDIO_CCCR_INTx\n",
+		       mmc_card_id(card), ret);
+		return ret;
+	}
+
+	if (*pending && mmc_card_broken_irq_polling(card) &&
+	    !(host->caps & MMC_CAP_SDIO_IRQ)) {
+		unsigned char dummy;
+
+		/* A fake interrupt could be created when we poll SDIO_CCCR_INTx
+		 * register with a Marvell SD8797 card. A dummy CMD52 read to
+		 * function 0 register 0xff can avoid this.
+		 */
+		mmc_io_rw_direct(card, 0, 0, 0xff, 0, &dummy);
+	}
+
+	return 0;
+}
+
 static int process_sdio_pending_irqs(struct mmc_host *host)
 {
 	struct mmc_card *card = host->card;
@@ -49,23 +77,9 @@ static int process_sdio_pending_irqs(struct mmc_host *host)
 		return 1;
 	}
 
-	ret = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_INTx, 0, &pending);
-	if (ret) {
-		pr_debug("%s: error %d reading SDIO_CCCR_INTx\n",
-		       mmc_card_id(card), ret);
+	ret = sdio_get_pending_irqs(host, &pending);
+	if (ret)
 		return ret;
-	}
-
-	if (pending && mmc_card_broken_irq_polling(card) &&
-	    !(host->caps & MMC_CAP_SDIO_IRQ)) {
-		unsigned char dummy;
-
-		/* A fake interrupt could be created when we poll SDIO_CCCR_INTx
-		 * register with a Marvell SD8797 card. A dummy CMD52 read to
-		 * function 0 register 0xff can avoid this.
-		 */
-		mmc_io_rw_direct(card, 0, 0, 0xff, 0, &dummy);
-	}
 
 	count = 0;
 	for (i = 1; i <= 7; i++) {

commit cf4b20ecfa4edc4a0e55d52bc0a735f60bdfe7eb
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Tue Jun 18 17:34:42 2019 +0200

    mmc: sdio: Turn sdio_run_irqs() into static
    
    All external users of sdio_run_irqs() have converted into using the
    preferred sdio_signal_irq() interface, thus not calling the function
    directly any more. Avoid further new users of it, by turning it into
    static.
    
    Suggested-by: Douglas Anderson <dianders@chromium.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Douglas Anderson <dianders@chromium.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sdio_irq.c b/drivers/mmc/core/sdio_irq.c
index 9f54a259a1b3..0bcc5e83bd1a 100644
--- a/drivers/mmc/core/sdio_irq.c
+++ b/drivers/mmc/core/sdio_irq.c
@@ -92,7 +92,7 @@ static int process_sdio_pending_irqs(struct mmc_host *host)
 	return ret;
 }
 
-void sdio_run_irqs(struct mmc_host *host)
+static void sdio_run_irqs(struct mmc_host *host)
 {
 	mmc_claim_host(host);
 	if (host->sdio_irqs) {
@@ -103,7 +103,6 @@ void sdio_run_irqs(struct mmc_host *host)
 	}
 	mmc_release_host(host);
 }
-EXPORT_SYMBOL_GPL(sdio_run_irqs);
 
 void sdio_irq_work(struct work_struct *work)
 {

commit 83293386bc95cf5e9f0c0175794455835bd1cb4a
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Tue Jun 18 14:05:17 2019 +0200

    mmc: core: Prevent processing SDIO IRQs when the card is suspended
    
    Processing of SDIO IRQs must obviously be prevented while the card is
    system suspended, otherwise we may end up trying to communicate with an
    uninitialized SDIO card.
    
    Reports throughout the years shows that this is not only a theoretical
    problem, but a real issue. So, let's finally fix this problem, by keeping
    track of the state for the card and bail out before processing the SDIO
    IRQ, in case the card is suspended.
    
    Cc: stable@vger.kernel.org
    Reported-by: Douglas Anderson <dianders@chromium.org>
    Tested-by: Douglas Anderson <dianders@chromium.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sdio_irq.c b/drivers/mmc/core/sdio_irq.c
index 931e6226c0b3..9f54a259a1b3 100644
--- a/drivers/mmc/core/sdio_irq.c
+++ b/drivers/mmc/core/sdio_irq.c
@@ -34,6 +34,10 @@ static int process_sdio_pending_irqs(struct mmc_host *host)
 	unsigned char pending;
 	struct sdio_func *func;
 
+	/* Don't process SDIO IRQs if the card is suspended. */
+	if (mmc_card_suspended(card))
+		return 0;
+
 	/*
 	 * Optimization, if there is only 1 function interrupt registered
 	 * and we know an IRQ was signaled then call irq handler directly.

commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/mmc/core/sdio_irq.c b/drivers/mmc/core/sdio_irq.c
index 7ca7b99413f0..931e6226c0b3 100644
--- a/drivers/mmc/core/sdio_irq.c
+++ b/drivers/mmc/core/sdio_irq.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * linux/drivers/mmc/core/sdio_irq.c
  *
@@ -6,11 +7,6 @@
  * Copyright:   MontaVista Software Inc.
  *
  * Copyright 2008 Pierre Ossman
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or (at
- * your option) any later version.
  */
 
 #include <linux/kernel.h>

commit 8647d26eb3f19ab0fa29f68a8bf648054c21e4bc
Author: Joel Cunningham <joel.cunningham@garmin.com>
Date:   Mon Mar 19 14:15:38 2018 +0000

    mmc: update sdio_claim_irq documentation
    
    Update documentation for sdio_claim_irq to downgrade the wording
    about doing recursive claims in an IRQ handler from 'must not' to
    'should not'. This clarifies that recursive claims are supported,
    but not the recommended (best) practice
    
    Signed-off-by: Joel Cunningham <joel.cunningham@garmin.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sdio_irq.c b/drivers/mmc/core/sdio_irq.c
index 7a2eaf8410a3..7ca7b99413f0 100644
--- a/drivers/mmc/core/sdio_irq.c
+++ b/drivers/mmc/core/sdio_irq.c
@@ -277,8 +277,8 @@ static void sdio_single_irq_set(struct mmc_card *card)
  *
  *	Claim and activate the IRQ for the given SDIO function. The provided
  *	handler will be called when that IRQ is asserted.  The host is always
- *	claimed already when the handler is called so the handler must not
- *	call sdio_claim_host() nor sdio_release_host().
+ *	claimed already when the handler is called so the handler should not
+ *	call sdio_claim_host() or sdio_release_host().
  */
 int sdio_claim_irq(struct sdio_func *func, sdio_irq_handler_t *handler)
 {

commit 6c0cedd1ef9527ef13e66875746570e76a3188a7
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Fri Sep 22 15:36:51 2017 +0300

    mmc: core: Introduce host claiming by context
    
    Currently the host can be claimed by a task.  Change this so that the host
    can be claimed by a context that may or may not be a task.  This provides
    for the host to be claimed by a block driver queue to support blk-mq, while
    maintaining compatibility with the existing use of mmc_claim_host().
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sdio_irq.c b/drivers/mmc/core/sdio_irq.c
index c771843e4c15..7a2eaf8410a3 100644
--- a/drivers/mmc/core/sdio_irq.c
+++ b/drivers/mmc/core/sdio_irq.c
@@ -155,7 +155,8 @@ static int sdio_irq_thread(void *_host)
 		 * holding of the host lock does not cover too much work
 		 * that doesn't require that lock to be held.
 		 */
-		ret = __mmc_claim_host(host, &host->sdio_irq_thread_abort);
+		ret = __mmc_claim_host(host, NULL,
+				       &host->sdio_irq_thread_abort);
 		if (ret)
 			break;
 		ret = process_sdio_pending_irqs(host);

commit 682696605c7093d2800c498c04166831e5aedf87
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu Apr 13 16:48:11 2017 +0200

    mmc: sdio: Add API to manage SDIO IRQs from a workqueue
    
    For hosts not supporting MMC_CAP2_SDIO_IRQ_NOTHREAD but MMC_CAP_SDIO_IRQ,
    the SDIO IRQs are processed from a dedicated kernel thread. For these
    cases, the host calls mmc_signal_sdio_irq() from its ISR to signal a new
    SDIO IRQ.
    
    Signaling an SDIO IRQ makes the host's ->enable_sdio_irq() callback to be
    invoked to temporary disable the IRQs, before the kernel thread is woken up
    to process it. When processing of the IRQs are completed, they are
    re-enabled by the kernel thread, again via invoking the host's
    ->enable_sdio_irq().
    
    The observation from this, is that the execution path is being unnecessary
    complex, as the host driver already knows that it needs to temporary
    disable the IRQs before signaling a new one. Moreover, replacing the kernel
    thread with a work/workqueue would not only greatly simplify the code, but
    also make it more robust.
    
    To address the above problems, let's continue to build upon the support for
    MMC_CAP2_SDIO_IRQ_NOTHREAD, as it already implements SDIO IRQs to be
    processed without using the clumsy kernel thread and without the ping-pong
    calls of the host's ->enable_sdio_irq() callback for each processed IRQ.
    
    Therefore, let's add new API sdio_signal_irq(), which enables hosts to
    signal/process SDIO IRQs by using a work/workqueue, rather than using the
    kernel thread.
    
    Add also a new host callback ->ack_sdio_irq(), which the work invokes when
    the SDIO IRQs have been processed. This informs the host about when it
    shall re-enable the SDIO IRQs. Potentially, we could re-use the existing
    ->enable_sdio_irq() callback instead of adding a new one, however it has
    turned out that it's more convenient for hosts to get this information via
    a separate callback.
    
    Hosts that wants to use this new method to signal/process SDIO IRQs, must
    enable MMC_CAP2_SDIO_IRQ_NOTHREAD and implement the ->ack_sdio_irq()
    callback.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Tested-by: Douglas Anderson <dianders@chromium.org>
    Reviewed-by: Douglas Anderson <dianders@chromium.org>

diff --git a/drivers/mmc/core/sdio_irq.c b/drivers/mmc/core/sdio_irq.c
index 44d9c86bd2d4..c771843e4c15 100644
--- a/drivers/mmc/core/sdio_irq.c
+++ b/drivers/mmc/core/sdio_irq.c
@@ -98,11 +98,27 @@ void sdio_run_irqs(struct mmc_host *host)
 	if (host->sdio_irqs) {
 		host->sdio_irq_pending = true;
 		process_sdio_pending_irqs(host);
+		if (host->ops->ack_sdio_irq)
+			host->ops->ack_sdio_irq(host);
 	}
 	mmc_release_host(host);
 }
 EXPORT_SYMBOL_GPL(sdio_run_irqs);
 
+void sdio_irq_work(struct work_struct *work)
+{
+	struct mmc_host *host =
+		container_of(work, struct mmc_host, sdio_irq_work.work);
+
+	sdio_run_irqs(host);
+}
+
+void sdio_signal_irq(struct mmc_host *host)
+{
+	queue_delayed_work(system_wq, &host->sdio_irq_work, 0);
+}
+EXPORT_SYMBOL_GPL(sdio_signal_irq);
+
 static int sdio_irq_thread(void *_host)
 {
 	struct mmc_host *host = _host;

commit e3a84267ab3184656929b4cbf03fca4d446125dd
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Wed Apr 19 21:52:29 2017 +0200

    mmc: core: Prevent processing SDIO IRQs when none is claimed
    
    In cases when MMC_CAP2_SDIO_IRQ_NOTHREAD is set, there is a minor window
    for when the mmc host could call sdio_run_irqs(), while in fact an SDIO
    func driver could have decided to released the SDIO IRQ via a call to
    sdio_release_irq(). In this scenario, processing of the SDIO IRQs are done
    even if there is none IRQ claimed, which is not what we want.
    
    To prevent this from happen, close the window by validating that at least
    one SDIO IRQs is claimed, before deciding to process them.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Tested-by: Douglas Anderson <dianders@chromium.org>
    Reviewed-by: Douglas Anderson <dianders@chromium.org>

diff --git a/drivers/mmc/core/sdio_irq.c b/drivers/mmc/core/sdio_irq.c
index 6d4b72080d51..44d9c86bd2d4 100644
--- a/drivers/mmc/core/sdio_irq.c
+++ b/drivers/mmc/core/sdio_irq.c
@@ -95,8 +95,10 @@ static int process_sdio_pending_irqs(struct mmc_host *host)
 void sdio_run_irqs(struct mmc_host *host)
 {
 	mmc_claim_host(host);
-	host->sdio_irq_pending = true;
-	process_sdio_pending_irqs(host);
+	if (host->sdio_irqs) {
+		host->sdio_irq_pending = true;
+		process_sdio_pending_irqs(host);
+	}
 	mmc_release_host(host);
 }
 EXPORT_SYMBOL_GPL(sdio_run_irqs);

commit ae7e81c077d60507dcec139e40a6d10cf932cf4b
Author: Ingo Molnar <mingo@kernel.org>
Date:   Wed Feb 1 18:07:51 2017 +0100

    sched/headers: Prepare for new header dependencies before moving code to <uapi/linux/sched/types.h>
    
    We are going to move scheduler ABI details to <uapi/linux/sched/types.h>,
    which will be used from a number of .c files.
    
    Create empty placeholder header that maps to <linux/types.h>.
    
    Include the new header in the files that are going to need it.
    
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/mmc/core/sdio_irq.c b/drivers/mmc/core/sdio_irq.c
index d29faf2addfe..6d4b72080d51 100644
--- a/drivers/mmc/core/sdio_irq.c
+++ b/drivers/mmc/core/sdio_irq.c
@@ -15,6 +15,7 @@
 
 #include <linux/kernel.h>
 #include <linux/sched.h>
+#include <uapi/linux/sched/types.h>
 #include <linux/kthread.h>
 #include <linux/export.h>
 #include <linux/wait.h>

commit 4facdde11394d44b3869807841042d059f074a07
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri Jan 13 14:14:14 2017 +0100

    mmc: core: Move public functions from card.h to private headers
    
    A significant amount of functions and other definitions are available
    through the public mmc card.h header file. Let's slim down this public mmc
    interface, as to prevent users from abusing it, by moving some of the
    functions/definitions to private mmc header files.
    
    This change concentrates on moving the functions into private mmc headers,
    following changes may continue with additional clean-ups.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Reviewed-by: Shawn Lin <shawn.lin@rock-chips.com>

diff --git a/drivers/mmc/core/sdio_irq.c b/drivers/mmc/core/sdio_irq.c
index d0846350e2fe..d29faf2addfe 100644
--- a/drivers/mmc/core/sdio_irq.c
+++ b/drivers/mmc/core/sdio_irq.c
@@ -28,6 +28,7 @@
 
 #include "sdio_ops.h"
 #include "core.h"
+#include "card.h"
 
 static int process_sdio_pending_irqs(struct mmc_host *host)
 {

commit 55244c5659b5e73a969b285a2e763223d8aab979
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri Jan 13 14:14:08 2017 +0100

    mmc: core: Move public functions from core.h to private headers
    
    A significant amount of functions are available through the public mmc
    core.h header file. Let's slim down this public mmc interface, as to
    prevent users from abusing it, by moving some of the functions to private
    mmc header files.
    
    This change concentrates on moving the functions into private mmc headers,
    following changes may continue with additional clean-ups, as an example
    some functions can be turned into static.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Reviewed-by: Shawn Lin <shawn.lin@rock-chips.com>

diff --git a/drivers/mmc/core/sdio_irq.c b/drivers/mmc/core/sdio_irq.c
index f1faf9acc007..d0846350e2fe 100644
--- a/drivers/mmc/core/sdio_irq.c
+++ b/drivers/mmc/core/sdio_irq.c
@@ -27,6 +27,7 @@
 #include <linux/mmc/sdio_func.h>
 
 #include "sdio_ops.h"
+#include "core.h"
 
 static int process_sdio_pending_irqs(struct mmc_host *host)
 {

commit 5df0e8231f9518ee5ca3f58a0777556dd03addd6
Author: Shawn Lin <shawn.lin@rock-chips.com>
Date:   Wed Nov 2 15:24:00 2016 +0800

    mmc: core: remove BUG_ONs from sdio
    
    BUG_ONs doesn't help anything except for stop the system from
    running. If it occurs, it implies we should deploy proper error
    handling for that. So this patch is gonna discard these meaningless
    BUG_ONs and deploy error handling if needed.
    
    Signed-off-by: Shawn Lin <shawn.lin@rock-chips.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sdio_irq.c b/drivers/mmc/core/sdio_irq.c
index 91bbbfb29f3f..f1faf9acc007 100644
--- a/drivers/mmc/core/sdio_irq.c
+++ b/drivers/mmc/core/sdio_irq.c
@@ -214,7 +214,9 @@ static int sdio_card_irq_put(struct mmc_card *card)
 	struct mmc_host *host = card->host;
 
 	WARN_ON(!host->claimed);
-	BUG_ON(host->sdio_irqs < 1);
+
+	if (host->sdio_irqs < 1)
+		return -EINVAL;
 
 	if (!--host->sdio_irqs) {
 		if (!(host->caps2 & MMC_CAP2_SDIO_IRQ_NOTHREAD)) {
@@ -261,8 +263,8 @@ int sdio_claim_irq(struct sdio_func *func, sdio_irq_handler_t *handler)
 	int ret;
 	unsigned char reg;
 
-	BUG_ON(!func);
-	BUG_ON(!func->card);
+	if (!func)
+		return -EINVAL;
 
 	pr_debug("SDIO: Enabling IRQ for %s...\n", sdio_func_id(func));
 
@@ -304,8 +306,8 @@ int sdio_release_irq(struct sdio_func *func)
 	int ret;
 	unsigned char reg;
 
-	BUG_ON(!func);
-	BUG_ON(!func->card);
+	if (!func)
+		return -EINVAL;
 
 	pr_debug("SDIO: Disabling IRQ for %s...\n", sdio_func_id(func));
 

commit 9eadcc0581a8ccaf4c2378aa1c193fb164304f1d
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri Oct 2 10:56:11 2015 +0200

    mmc: core: Remove MMC_CLKGATE
    
    MMC_CLKGATE was once invented to save power by gating the bus clock at
    request inactivity. At that time it served its purpose. The modern way to
    deal with power saving for these scenarios, is by using runtime PM.
    
    Nowadays, several host drivers have deployed runtime PM, but for those
    that haven't and which still cares power saving at request inactivity,
    it's certainly time to deploy runtime PM as it has been around for several
    years now.
    
    To simplify code to mmc core and thus decrease maintenance efforts, this
    patch removes all code related to MMC_CLKGATE.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/mmc/core/sdio_irq.c b/drivers/mmc/core/sdio_irq.c
index 09cc67d028f0..91bbbfb29f3f 100644
--- a/drivers/mmc/core/sdio_irq.c
+++ b/drivers/mmc/core/sdio_irq.c
@@ -168,21 +168,15 @@ static int sdio_irq_thread(void *_host)
 		}
 
 		set_current_state(TASK_INTERRUPTIBLE);
-		if (host->caps & MMC_CAP_SDIO_IRQ) {
-			mmc_host_clk_hold(host);
+		if (host->caps & MMC_CAP_SDIO_IRQ)
 			host->ops->enable_sdio_irq(host, 1);
-			mmc_host_clk_release(host);
-		}
 		if (!kthread_should_stop())
 			schedule_timeout(period);
 		set_current_state(TASK_RUNNING);
 	} while (!kthread_should_stop());
 
-	if (host->caps & MMC_CAP_SDIO_IRQ) {
-		mmc_host_clk_hold(host);
+	if (host->caps & MMC_CAP_SDIO_IRQ)
 		host->ops->enable_sdio_irq(host, 0);
-		mmc_host_clk_release(host);
-	}
 
 	pr_debug("%s: IRQ thread exiting with code %d\n",
 		 mmc_hostname(host), ret);
@@ -208,9 +202,7 @@ static int sdio_card_irq_get(struct mmc_card *card)
 				return err;
 			}
 		} else if (host->caps & MMC_CAP_SDIO_IRQ) {
-			mmc_host_clk_hold(host);
 			host->ops->enable_sdio_irq(host, 1);
-			mmc_host_clk_release(host);
 		}
 	}
 
@@ -229,9 +221,7 @@ static int sdio_card_irq_put(struct mmc_card *card)
 			atomic_set(&host->sdio_irq_thread_abort, 1);
 			kthread_stop(host->sdio_irq_thread);
 		} else if (host->caps & MMC_CAP_SDIO_IRQ) {
-			mmc_host_clk_hold(host);
 			host->ops->enable_sdio_irq(host, 0);
-			mmc_host_clk_release(host);
 		}
 	}
 

commit 6606110d89aefcb21b9e70adfe064987cbd8393a
Author: Joe Perches <joe@perches.com>
Date:   Fri Sep 12 14:56:56 2014 -0700

    mmc: Convert pr_warning to pr_warn
    
    Use the much more common pr_warn instead of pr_warning.
    
    Other miscellanea:
    
    o Coalesce formats
    o Realign arguments
    o Remove extra spaces when coalescing formats
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sdio_irq.c b/drivers/mmc/core/sdio_irq.c
index 696eca493844..09cc67d028f0 100644
--- a/drivers/mmc/core/sdio_irq.c
+++ b/drivers/mmc/core/sdio_irq.c
@@ -69,16 +69,15 @@ static int process_sdio_pending_irqs(struct mmc_host *host)
 		if (pending & (1 << i)) {
 			func = card->sdio_func[i - 1];
 			if (!func) {
-				pr_warning("%s: pending IRQ for "
-					"non-existent function\n",
+				pr_warn("%s: pending IRQ for non-existent function\n",
 					mmc_card_id(card));
 				ret = -EINVAL;
 			} else if (func->irq_handler) {
 				func->irq_handler(func);
 				count++;
 			} else {
-				pr_warning("%s: pending IRQ with no handler\n",
-				       sdio_func_id(func));
+				pr_warn("%s: pending IRQ with no handler\n",
+					sdio_func_id(func));
 				ret = -EINVAL;
 			}
 		}

commit dea67c4ec8218b301d7cac7ee6e63dac0bc566cb
Author: Fu Zhonghui <zhonghui.fu@linux.intel.com>
Date:   Mon Aug 18 10:48:14 2014 +0800

    mmc: core: sdio: Fix unconditional wake_up_process() on sdio thread
    
    781e989cf59 ("mmc: sdhci: convert to new SDIO IRQ handling") and
    bf3b5ec66bd ("mmc: sdio_irq: rework sdio irq handling") disabled
    the use of our own custom threaded IRQ handler, but left in an
    unconditional wake_up_process() on that handler at resume-time.
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=80151
    
    In addition, the check for MMC_CAP_SDIO_IRQ capability is added
    before enable sdio IRQ.
    
    Signed-off-by: Jaehoon Chung <jh80.chung@samsung.com>
    Signed-off-by: Chris Ball <chris@printf.net>
    Signed-off-by: Fu Zhonghui <zhonghui.fu@linux.intel.com>
    Cc: <stable@vger.kernel.org> # v3.16+
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/core/sdio_irq.c b/drivers/mmc/core/sdio_irq.c
index 5cc13c8d35bb..696eca493844 100644
--- a/drivers/mmc/core/sdio_irq.c
+++ b/drivers/mmc/core/sdio_irq.c
@@ -208,7 +208,7 @@ static int sdio_card_irq_get(struct mmc_card *card)
 				host->sdio_irqs--;
 				return err;
 			}
-		} else {
+		} else if (host->caps & MMC_CAP_SDIO_IRQ) {
 			mmc_host_clk_hold(host);
 			host->ops->enable_sdio_irq(host, 1);
 			mmc_host_clk_release(host);
@@ -229,7 +229,7 @@ static int sdio_card_irq_put(struct mmc_card *card)
 		if (!(host->caps2 & MMC_CAP2_SDIO_IRQ_NOTHREAD)) {
 			atomic_set(&host->sdio_irq_thread_abort, 1);
 			kthread_stop(host->sdio_irq_thread);
-		} else {
+		} else if (host->caps & MMC_CAP_SDIO_IRQ) {
 			mmc_host_clk_hold(host);
 			host->ops->enable_sdio_irq(host, 0);
 			mmc_host_clk_release(host);

commit bf3b5ec66bd03d66e9ea729aaca013ea1047a797
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Fri Apr 25 12:55:30 2014 +0100

    mmc: sdio_irq: rework sdio irq handling
    
    Rather than the SDIO support spawning it's own thread for handling card
    interrupts, use the generic IRQ infrastructure for this, triggering it
    from the host interface's interrupt handling directly.
    
    This avoids a race between the parent thread waiting to receive an
    interrupt response from the card, and the slow startup from the sdio
    irq thread, which can occur as a result of high system load (eg, while
    udev is running.)
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Tested-by: Markus Pargmann <mpa@pengutronix.de>
    Tested-by: Stephen Warren <swarren@nvidia.com>
    [Ulf Hansson] Resolved conflict
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <chris@printf.net>

diff --git a/drivers/mmc/core/sdio_irq.c b/drivers/mmc/core/sdio_irq.c
index aaa90460ed23..5cc13c8d35bb 100644
--- a/drivers/mmc/core/sdio_irq.c
+++ b/drivers/mmc/core/sdio_irq.c
@@ -90,6 +90,15 @@ static int process_sdio_pending_irqs(struct mmc_host *host)
 	return ret;
 }
 
+void sdio_run_irqs(struct mmc_host *host)
+{
+	mmc_claim_host(host);
+	host->sdio_irq_pending = true;
+	process_sdio_pending_irqs(host);
+	mmc_release_host(host);
+}
+EXPORT_SYMBOL_GPL(sdio_run_irqs);
+
 static int sdio_irq_thread(void *_host)
 {
 	struct mmc_host *host = _host;
@@ -189,14 +198,20 @@ static int sdio_card_irq_get(struct mmc_card *card)
 	WARN_ON(!host->claimed);
 
 	if (!host->sdio_irqs++) {
-		atomic_set(&host->sdio_irq_thread_abort, 0);
-		host->sdio_irq_thread =
-			kthread_run(sdio_irq_thread, host, "ksdioirqd/%s",
-				mmc_hostname(host));
-		if (IS_ERR(host->sdio_irq_thread)) {
-			int err = PTR_ERR(host->sdio_irq_thread);
-			host->sdio_irqs--;
-			return err;
+		if (!(host->caps2 & MMC_CAP2_SDIO_IRQ_NOTHREAD)) {
+			atomic_set(&host->sdio_irq_thread_abort, 0);
+			host->sdio_irq_thread =
+				kthread_run(sdio_irq_thread, host,
+					    "ksdioirqd/%s", mmc_hostname(host));
+			if (IS_ERR(host->sdio_irq_thread)) {
+				int err = PTR_ERR(host->sdio_irq_thread);
+				host->sdio_irqs--;
+				return err;
+			}
+		} else {
+			mmc_host_clk_hold(host);
+			host->ops->enable_sdio_irq(host, 1);
+			mmc_host_clk_release(host);
 		}
 	}
 
@@ -211,8 +226,14 @@ static int sdio_card_irq_put(struct mmc_card *card)
 	BUG_ON(host->sdio_irqs < 1);
 
 	if (!--host->sdio_irqs) {
-		atomic_set(&host->sdio_irq_thread_abort, 1);
-		kthread_stop(host->sdio_irq_thread);
+		if (!(host->caps2 & MMC_CAP2_SDIO_IRQ_NOTHREAD)) {
+			atomic_set(&host->sdio_irq_thread_abort, 1);
+			kthread_stop(host->sdio_irq_thread);
+		} else {
+			mmc_host_clk_hold(host);
+			host->ops->enable_sdio_irq(host, 0);
+			mmc_host_clk_release(host);
+		}
 	}
 
 	return 0;

commit e5624054c1726a16c13a89c08b2792aba3df06eb
Author: Bing Zhao <bzhao@marvell.com>
Date:   Tue Nov 26 15:39:20 2013 -0800

    mmc: sdio: add a quirk for broken SDIO_CCCR_INTx polling
    
    Polling SDIO_CCCR_INTx could create a fake interrupt with Marvell
    SD8797 card. Add a quirk to handle this case. The fixup here is
    to issue a dummy CMD52 read to function 0 register 0xff, and this
    dummy read must be right after SDIO_CCCR_INTx is read.
    
    Patch has been verified on a dw_mmc controller (Samsung Chromebook)
    with MMC_CAP_SDIO_IRQ disabled.
    
    Signed-off-by: Bing Zhao <bzhao@marvell.com>
    Reviewed-by: Paul Stewart <pstew@chromium.org>
    Reviewed-by: Doug Anderson <dianders@chromium.org>
    Acked-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <chris@printf.net>

diff --git a/drivers/mmc/core/sdio_irq.c b/drivers/mmc/core/sdio_irq.c
index 3d8ceb4084de..aaa90460ed23 100644
--- a/drivers/mmc/core/sdio_irq.c
+++ b/drivers/mmc/core/sdio_irq.c
@@ -53,6 +53,17 @@ static int process_sdio_pending_irqs(struct mmc_host *host)
 		return ret;
 	}
 
+	if (pending && mmc_card_broken_irq_polling(card) &&
+	    !(host->caps & MMC_CAP_SDIO_IRQ)) {
+		unsigned char dummy;
+
+		/* A fake interrupt could be created when we poll SDIO_CCCR_INTx
+		 * register with a Marvell SD8797 card. A dummy CMD52 read to
+		 * function 0 register 0xff can avoid this.
+		 */
+		mmc_io_rw_direct(card, 0, 0, 0xff, 0, &dummy);
+	}
+
 	count = 0;
 	for (i = 1; i <= 7; i++) {
 		if (pending & (1 << i)) {

commit bbbc4c4d8c5face097d695f9bf3a39647ba6b7e7
Author: Nicolas Pitre <nicolas.pitre@linaro.org>
Date:   Mon Apr 16 19:16:54 2012 -0400

    mmc: sdio: avoid spurious calls to interrupt handlers
    
    Commit 06e8935feb ("optimized SDIO IRQ handling for single irq")
    introduced some spurious calls to SDIO function interrupt handlers,
    such as when the SDIO IRQ thread is started, or the safety check
    performed upon a system resume.  Let's add a flag to perform the
    optimization only when a real interrupt is signaled by the host
    driver and we know there is no point confirming it.
    
    Reported-by: Sujit Reddy Thumma <sthumma@codeaurora.org>
    Signed-off-by: Nicolas Pitre <nico@linaro.org>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sdio_irq.c b/drivers/mmc/core/sdio_irq.c
index f573e7f9f740..3d8ceb4084de 100644
--- a/drivers/mmc/core/sdio_irq.c
+++ b/drivers/mmc/core/sdio_irq.c
@@ -28,18 +28,20 @@
 
 #include "sdio_ops.h"
 
-static int process_sdio_pending_irqs(struct mmc_card *card)
+static int process_sdio_pending_irqs(struct mmc_host *host)
 {
+	struct mmc_card *card = host->card;
 	int i, ret, count;
 	unsigned char pending;
 	struct sdio_func *func;
 
 	/*
 	 * Optimization, if there is only 1 function interrupt registered
-	 * call irq handler directly
+	 * and we know an IRQ was signaled then call irq handler directly.
+	 * Otherwise do the full probe.
 	 */
 	func = card->sdio_single_irq;
-	if (func) {
+	if (func && host->sdio_irq_pending) {
 		func->irq_handler(func);
 		return 1;
 	}
@@ -116,7 +118,8 @@ static int sdio_irq_thread(void *_host)
 		ret = __mmc_claim_host(host, &host->sdio_irq_thread_abort);
 		if (ret)
 			break;
-		ret = process_sdio_pending_irqs(host->card);
+		ret = process_sdio_pending_irqs(host);
+		host->sdio_irq_pending = false;
 		mmc_release_host(host);
 
 		/*

commit 2c4967f741e87cdd63de7271b97807041dccbf3b
Author: Sujit Reddy Thumma <sthumma@codeaurora.org>
Date:   Sat Feb 4 16:14:50 2012 -0500

    mmc: core: Ensure clocks are always enabled before host interaction
    
    Ensure clocks are always enabled before any interaction with the
    host controller driver. This makes sure that there is no race
    between host execution and the core layer turning off clocks
    in different context with clock gating framework.
    
    Signed-off-by: Sujit Reddy Thumma <sthumma@codeaurora.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Per Forlin <per.forlin@stericsson.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sdio_irq.c b/drivers/mmc/core/sdio_irq.c
index 68f81b9ee0fb..f573e7f9f740 100644
--- a/drivers/mmc/core/sdio_irq.c
+++ b/drivers/mmc/core/sdio_irq.c
@@ -146,15 +146,21 @@ static int sdio_irq_thread(void *_host)
 		}
 
 		set_current_state(TASK_INTERRUPTIBLE);
-		if (host->caps & MMC_CAP_SDIO_IRQ)
+		if (host->caps & MMC_CAP_SDIO_IRQ) {
+			mmc_host_clk_hold(host);
 			host->ops->enable_sdio_irq(host, 1);
+			mmc_host_clk_release(host);
+		}
 		if (!kthread_should_stop())
 			schedule_timeout(period);
 		set_current_state(TASK_RUNNING);
 	} while (!kthread_should_stop());
 
-	if (host->caps & MMC_CAP_SDIO_IRQ)
+	if (host->caps & MMC_CAP_SDIO_IRQ) {
+		mmc_host_clk_hold(host);
 		host->ops->enable_sdio_irq(host, 0);
+		mmc_host_clk_release(host);
+	}
 
 	pr_debug("%s: IRQ thread exiting with code %d\n",
 		 mmc_hostname(host), ret);

commit 3ef77af154b03776c6c662c68c6332719e9eecac
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Sun Jul 10 12:42:00 2011 -0400

    mmc: Add export.h for EXPORT_SYMBOL/THIS_MODULE as required
    
    These two basic defines were everywhere, simply because module.h
    was also everywhere.   But we are cleaning up the latter.  So make
    the exporters actually call out their need for the include.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/drivers/mmc/core/sdio_irq.c b/drivers/mmc/core/sdio_irq.c
index b644dd59c16e..68f81b9ee0fb 100644
--- a/drivers/mmc/core/sdio_irq.c
+++ b/drivers/mmc/core/sdio_irq.c
@@ -16,6 +16,7 @@
 #include <linux/kernel.h>
 #include <linux/sched.h>
 #include <linux/kthread.h>
+#include <linux/export.h>
 #include <linux/wait.h>
 #include <linux/delay.h>
 

commit a3c76eb9d4a1e68a69dd880cf0bcb8a52418b993
Author: Girish K S <girish.shivananjappa@linaro.org>
Date:   Tue Oct 11 11:44:09 2011 +0530

    mmc: replace printk with appropriate display macro
    
    All the files using printk function for displaying kernel messages
    in the mmc driver have been replaced with corresponding macro.
    
    Signed-off-by: Girish K S <girish.shivananjappa@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sdio_irq.c b/drivers/mmc/core/sdio_irq.c
index 03ead028d2ce..b644dd59c16e 100644
--- a/drivers/mmc/core/sdio_irq.c
+++ b/drivers/mmc/core/sdio_irq.c
@@ -45,7 +45,7 @@ static int process_sdio_pending_irqs(struct mmc_card *card)
 
 	ret = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_INTx, 0, &pending);
 	if (ret) {
-		printk(KERN_DEBUG "%s: error %d reading SDIO_CCCR_INTx\n",
+		pr_debug("%s: error %d reading SDIO_CCCR_INTx\n",
 		       mmc_card_id(card), ret);
 		return ret;
 	}
@@ -55,7 +55,7 @@ static int process_sdio_pending_irqs(struct mmc_card *card)
 		if (pending & (1 << i)) {
 			func = card->sdio_func[i - 1];
 			if (!func) {
-				printk(KERN_WARNING "%s: pending IRQ for "
+				pr_warning("%s: pending IRQ for "
 					"non-existent function\n",
 					mmc_card_id(card));
 				ret = -EINVAL;
@@ -63,7 +63,7 @@ static int process_sdio_pending_irqs(struct mmc_card *card)
 				func->irq_handler(func);
 				count++;
 			} else {
-				printk(KERN_WARNING "%s: pending IRQ with no handler\n",
+				pr_warning("%s: pending IRQ with no handler\n",
 				       sdio_func_id(func));
 				ret = -EINVAL;
 			}

commit 06e8935febe687e2a561707d4c7ca4245d261dbe
Author: Stefan Nilsson XK <stefan.xk.nilsson@stericsson.com>
Date:   Wed May 11 17:48:05 2011 +0200

    mmc: sdio: optimized SDIO IRQ handling for single irq
    
    If there is only 1 function interrupt registered it is possible to
    improve performance by directly calling the irq handler and avoiding
    the overhead of reading the CCCR registers.
    
    Signed-off-by: Per Forlin <per.forlin@linaro.org>
    Acked-by: Ulf Hansson <ulf.hansson@stericsson.com>
    Reviewed-by: Nicolas Pitre <nicolas.pitre@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/core/sdio_irq.c b/drivers/mmc/core/sdio_irq.c
index b3001617e67d..03ead028d2ce 100644
--- a/drivers/mmc/core/sdio_irq.c
+++ b/drivers/mmc/core/sdio_irq.c
@@ -31,6 +31,17 @@ static int process_sdio_pending_irqs(struct mmc_card *card)
 {
 	int i, ret, count;
 	unsigned char pending;
+	struct sdio_func *func;
+
+	/*
+	 * Optimization, if there is only 1 function interrupt registered
+	 * call irq handler directly
+	 */
+	func = card->sdio_single_irq;
+	if (func) {
+		func->irq_handler(func);
+		return 1;
+	}
 
 	ret = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_INTx, 0, &pending);
 	if (ret) {
@@ -42,7 +53,7 @@ static int process_sdio_pending_irqs(struct mmc_card *card)
 	count = 0;
 	for (i = 1; i <= 7; i++) {
 		if (pending & (1 << i)) {
-			struct sdio_func *func = card->sdio_func[i - 1];
+			func = card->sdio_func[i - 1];
 			if (!func) {
 				printk(KERN_WARNING "%s: pending IRQ for "
 					"non-existent function\n",
@@ -186,6 +197,24 @@ static int sdio_card_irq_put(struct mmc_card *card)
 	return 0;
 }
 
+/* If there is only 1 function registered set sdio_single_irq */
+static void sdio_single_irq_set(struct mmc_card *card)
+{
+	struct sdio_func *func;
+	int i;
+
+	card->sdio_single_irq = NULL;
+	if ((card->host->caps & MMC_CAP_SDIO_IRQ) &&
+	    card->host->sdio_irqs == 1)
+		for (i = 0; i < card->sdio_funcs; i++) {
+		       func = card->sdio_func[i];
+		       if (func && func->irq_handler) {
+			       card->sdio_single_irq = func;
+			       break;
+		       }
+	       }
+}
+
 /**
  *	sdio_claim_irq - claim the IRQ for a SDIO function
  *	@func: SDIO function
@@ -227,6 +256,7 @@ int sdio_claim_irq(struct sdio_func *func, sdio_irq_handler_t *handler)
 	ret = sdio_card_irq_get(func->card);
 	if (ret)
 		func->irq_handler = NULL;
+	sdio_single_irq_set(func->card);
 
 	return ret;
 }
@@ -251,6 +281,7 @@ int sdio_release_irq(struct sdio_func *func)
 	if (func->irq_handler) {
 		func->irq_handler = NULL;
 		sdio_card_irq_put(func->card);
+		sdio_single_irq_set(func->card);
 	}
 
 	ret = mmc_io_rw_direct(func->card, 0, 0, SDIO_CCCR_IENx, 0, &reg);

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/drivers/mmc/core/sdio_irq.c b/drivers/mmc/core/sdio_irq.c
index bb192f90e8e9..b3001617e67d 100644
--- a/drivers/mmc/core/sdio_irq.c
+++ b/drivers/mmc/core/sdio_irq.c
@@ -45,7 +45,7 @@ static int process_sdio_pending_irqs(struct mmc_card *card)
 			struct sdio_func *func = card->sdio_func[i - 1];
 			if (!func) {
 				printk(KERN_WARNING "%s: pending IRQ for "
-					"non-existant function\n",
+					"non-existent function\n",
 					mmc_card_id(card));
 				ret = -EINVAL;
 			} else if (func->irq_handler) {

commit 6501ff604a5ae18697c9b4cd40a7738d3a68e7fe
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Sun Aug 31 13:42:00 2008 +0200

    sdio: give sdio irq thread a host specific name
    
    There is one thread per host controller so make sure they all get
    unique names.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/sdio_irq.c b/drivers/mmc/core/sdio_irq.c
index 722924cdf595..bb192f90e8e9 100644
--- a/drivers/mmc/core/sdio_irq.c
+++ b/drivers/mmc/core/sdio_irq.c
@@ -159,7 +159,8 @@ static int sdio_card_irq_get(struct mmc_card *card)
 	if (!host->sdio_irqs++) {
 		atomic_set(&host->sdio_irq_thread_abort, 0);
 		host->sdio_irq_thread =
-			kthread_run(sdio_irq_thread, host, "ksdiorqd");
+			kthread_run(sdio_irq_thread, host, "ksdioirqd/%s",
+				mmc_hostname(host));
 		if (IS_ERR(host->sdio_irq_thread)) {
 			int err = PTR_ERR(host->sdio_irq_thread);
 			host->sdio_irqs--;

commit e633b7bcec8e26991d489a11615acf7674efbaf4
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Sun Aug 31 13:38:54 2008 +0200

    sdio: make sleep on error interruptable
    
    Make sure we can be woken from the forced sleep that is done on errors.
    Removing a card often results in -ENOMEDIUM or -EILSEQ so we previously
    locked up the removal process for a second.
    
    We could completely exit on -ENOMEDIUM, but it might be a transient
    glitch so treat it like any other error.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/sdio_irq.c b/drivers/mmc/core/sdio_irq.c
index c292e124107a..722924cdf595 100644
--- a/drivers/mmc/core/sdio_irq.c
+++ b/drivers/mmc/core/sdio_irq.c
@@ -5,6 +5,8 @@
  * Created:     June 18, 2007
  * Copyright:   MontaVista Software Inc.
  *
+ * Copyright 2008 Pierre Ossman
+ *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or (at
@@ -107,11 +109,14 @@ static int sdio_irq_thread(void *_host)
 
 		/*
 		 * Give other threads a chance to run in the presence of
-		 * errors.  FIXME: determine if due to card removal and
-		 * possibly exit this thread if so.
+		 * errors.
 		 */
-		if (ret < 0)
-			ssleep(1);
+		if (ret < 0) {
+			set_current_state(TASK_INTERRUPTIBLE);
+			if (!kthread_should_stop())
+				schedule_timeout(HZ);
+			set_current_state(TASK_RUNNING);
+		}
 
 		/*
 		 * Adaptive polling frequency based on the assumption

commit 6fee65cfde519ae811c3cde47c622271168ca449
Author: Robert P. J. Day <rpjday@crashcourse.ca>
Date:   Fri Mar 28 14:34:47 2008 -0700

    mmc: use shorter, equivalent set_current_state()
    
    Signed-off-by: Robert P. J. Day <rpjday@crashcourse.ca>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/sdio_irq.c b/drivers/mmc/core/sdio_irq.c
index 3bd3021f5e80..c292e124107a 100644
--- a/drivers/mmc/core/sdio_irq.c
+++ b/drivers/mmc/core/sdio_irq.c
@@ -128,12 +128,12 @@ static int sdio_irq_thread(void *_host)
 			}
 		}
 
-		set_task_state(current, TASK_INTERRUPTIBLE);
+		set_current_state(TASK_INTERRUPTIBLE);
 		if (host->caps & MMC_CAP_SDIO_IRQ)
 			host->ops->enable_sdio_irq(host, 1);
 		if (!kthread_should_stop())
 			schedule_timeout(period);
-		set_task_state(current, TASK_RUNNING);
+		set_current_state(TASK_RUNNING);
 	} while (!kthread_should_stop());
 
 	if (host->caps & MMC_CAP_SDIO_IRQ)

commit 599473cf15a3fae78cbc3192cfb38ca04d5abc72
Author: Nicolas Pitre <nico@cam.org>
Date:   Wed Oct 3 15:32:57 2007 -0400

    sdio: make the IRQ thread more resilient in the presence of bad states
    
    Currently we print a message about some bad states wrt function IRQ
    handlers but return 0 from process_sdio_pending_irqs() nevertheless.
    This can lead to an infinite loop as nothing might have cleared the
    condition for the pending card interrupt from the host controller by
    the time host->ops->enable_sdio_irq(host, 1) is called.
    
    Signed-off-by: Nicolas Pitre <nico@marvell.com>
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/sdio_irq.c b/drivers/mmc/core/sdio_irq.c
index e7865059e126..3bd3021f5e80 100644
--- a/drivers/mmc/core/sdio_irq.c
+++ b/drivers/mmc/core/sdio_irq.c
@@ -45,16 +45,22 @@ static int process_sdio_pending_irqs(struct mmc_card *card)
 				printk(KERN_WARNING "%s: pending IRQ for "
 					"non-existant function\n",
 					mmc_card_id(card));
+				ret = -EINVAL;
 			} else if (func->irq_handler) {
 				func->irq_handler(func);
 				count++;
-			} else
+			} else {
 				printk(KERN_WARNING "%s: pending IRQ with no handler\n",
 				       sdio_func_id(func));
+				ret = -EINVAL;
+			}
 		}
 	}
 
-	return count;
+	if (count)
+		return count;
+
+	return ret;
 }
 
 static int sdio_irq_thread(void *_host)

commit 3e01e4bcdd56209e70c39293e0c4c355d09364b8
Author: Nicolas Pitre <nico@cam.org>
Date:   Wed Oct 3 15:32:10 2007 -0400

    sdio: fix IRQ diagnostic message
    
    If func is actually null we won't get much from sdio_func_id(func).
    
    Signed-off-by: Nicolas Pitre <nico@marvell.com>
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/sdio_irq.c b/drivers/mmc/core/sdio_irq.c
index f78ffeefed52..e7865059e126 100644
--- a/drivers/mmc/core/sdio_irq.c
+++ b/drivers/mmc/core/sdio_irq.c
@@ -44,7 +44,7 @@ static int process_sdio_pending_irqs(struct mmc_card *card)
 			if (!func) {
 				printk(KERN_WARNING "%s: pending IRQ for "
 					"non-existant function\n",
-					sdio_func_id(func));
+					mmc_card_id(card));
 			} else if (func->irq_handler) {
 				func->irq_handler(func);
 				count++;

commit 6f4285d13300f1c8cd675a41ab390cea06173cd1
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Thu Sep 27 10:48:29 2007 +0200

    sdio: adaptive interrupt polling
    
    The interrupt polling frequency is a compromise between power usage and
    interrupt latency. Unfortunately, it affects throughput rather severely
    for devices which require an interrupt for every chunk of data.
    
    By making the polling frequency adaptive, we get better throughput with
    those devices without sacficing too much power. Polling will quickly
    increase when there is an actual interrupt, and slowly fall back to the
    idle frequency when the interrupts stop coming.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/sdio_irq.c b/drivers/mmc/core/sdio_irq.c
index 8843a4c2fe91..f78ffeefed52 100644
--- a/drivers/mmc/core/sdio_irq.c
+++ b/drivers/mmc/core/sdio_irq.c
@@ -27,7 +27,7 @@
 
 static int process_sdio_pending_irqs(struct mmc_card *card)
 {
-	int i, ret;
+	int i, ret, count;
 	unsigned char pending;
 
 	ret = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_INTx, 0, &pending);
@@ -37,6 +37,7 @@ static int process_sdio_pending_irqs(struct mmc_card *card)
 		return ret;
 	}
 
+	count = 0;
 	for (i = 1; i <= 7; i++) {
 		if (pending & (1 << i)) {
 			struct sdio_func *func = card->sdio_func[i - 1];
@@ -46,20 +47,21 @@ static int process_sdio_pending_irqs(struct mmc_card *card)
 					sdio_func_id(func));
 			} else if (func->irq_handler) {
 				func->irq_handler(func);
+				count++;
 			} else
 				printk(KERN_WARNING "%s: pending IRQ with no handler\n",
 				       sdio_func_id(func));
 		}
 	}
 
-	return 0;
+	return count;
 }
 
 static int sdio_irq_thread(void *_host)
 {
 	struct mmc_host *host = _host;
 	struct sched_param param = { .sched_priority = 1 };
-	unsigned long period;
+	unsigned long period, idle_period;
 	int ret;
 
 	sched_setscheduler(current, SCHED_FIFO, &param);
@@ -70,8 +72,9 @@ static int sdio_irq_thread(void *_host)
 	 * asynchronous notification of pending SDIO card interrupts
 	 * hence we poll for them in that case.
 	 */
+	idle_period = msecs_to_jiffies(10);
 	period = (host->caps & MMC_CAP_SDIO_IRQ) ?
-		MAX_SCHEDULE_TIMEOUT : msecs_to_jiffies(10);
+		MAX_SCHEDULE_TIMEOUT : idle_period;
 
 	pr_debug("%s: IRQ thread started (poll period = %lu jiffies)\n",
 		 mmc_hostname(host), period);
@@ -101,9 +104,24 @@ static int sdio_irq_thread(void *_host)
 		 * errors.  FIXME: determine if due to card removal and
 		 * possibly exit this thread if so.
 		 */
-		if (ret)
+		if (ret < 0)
 			ssleep(1);
 
+		/*
+		 * Adaptive polling frequency based on the assumption
+		 * that an interrupt will be closely followed by more.
+		 * This has a substantial benefit for network devices.
+		 */
+		if (!(host->caps & MMC_CAP_SDIO_IRQ)) {
+			if (ret > 0)
+				period /= 2;
+			else {
+				period++;
+				if (period > idle_period)
+					period = idle_period;
+			}
+		}
+
 		set_task_state(current, TASK_INTERRUPTIBLE);
 		if (host->caps & MMC_CAP_SDIO_IRQ)
 			host->ops->enable_sdio_irq(host, 1);

commit d84075c8aed771d47d7ac6e96b098559da361c25
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Thu Aug 9 13:23:56 2007 +0200

    mmc: replace BUG_ON with WARN_ON
    
    Replace all cases of BUG_ON with WARN_ON where there is a chance
    (with varying degrees of slim) that the kernel can continue without
    incidence.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/sdio_irq.c b/drivers/mmc/core/sdio_irq.c
index 01daee934d16..8843a4c2fe91 100644
--- a/drivers/mmc/core/sdio_irq.c
+++ b/drivers/mmc/core/sdio_irq.c
@@ -125,7 +125,7 @@ static int sdio_card_irq_get(struct mmc_card *card)
 {
 	struct mmc_host *host = card->host;
 
-	BUG_ON(!host->claimed);
+	WARN_ON(!host->claimed);
 
 	if (!host->sdio_irqs++) {
 		atomic_set(&host->sdio_irq_thread_abort, 0);
@@ -145,7 +145,7 @@ static int sdio_card_irq_put(struct mmc_card *card)
 {
 	struct mmc_host *host = card->host;
 
-	BUG_ON(!host->claimed);
+	WARN_ON(!host->claimed);
 	BUG_ON(host->sdio_irqs < 1);
 
 	if (!--host->sdio_irqs) {

commit 17b759aff916b4d02721e75ce5ed82b1903e5bd6
Author: Nicolas Pitre <nico@cam.org>
Date:   Tue Jul 24 02:09:39 2007 -0400

    sdio: add interface for host side SDIO interrupt reporting
    
    Signed-off-by: Nicolas Pitre <npitre@mvista.com>
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/sdio_irq.c b/drivers/mmc/core/sdio_irq.c
index 01922d29241d..01daee934d16 100644
--- a/drivers/mmc/core/sdio_irq.c
+++ b/drivers/mmc/core/sdio_irq.c
@@ -70,7 +70,8 @@ static int sdio_irq_thread(void *_host)
 	 * asynchronous notification of pending SDIO card interrupts
 	 * hence we poll for them in that case.
 	 */
-	period = msecs_to_jiffies(10);
+	period = (host->caps & MMC_CAP_SDIO_IRQ) ?
+		MAX_SCHEDULE_TIMEOUT : msecs_to_jiffies(10);
 
 	pr_debug("%s: IRQ thread started (poll period = %lu jiffies)\n",
 		 mmc_hostname(host), period);
@@ -104,11 +105,16 @@ static int sdio_irq_thread(void *_host)
 			ssleep(1);
 
 		set_task_state(current, TASK_INTERRUPTIBLE);
+		if (host->caps & MMC_CAP_SDIO_IRQ)
+			host->ops->enable_sdio_irq(host, 1);
 		if (!kthread_should_stop())
 			schedule_timeout(period);
 		set_task_state(current, TASK_RUNNING);
 	} while (!kthread_should_stop());
 
+	if (host->caps & MMC_CAP_SDIO_IRQ)
+		host->ops->enable_sdio_irq(host, 0);
+
 	pr_debug("%s: IRQ thread exiting with code %d\n",
 		 mmc_hostname(host), ret);
 

commit d1496c39e500857b8949cdb91af24e0eb8aae4d0
Author: Nicolas Pitre <nico@cam.org>
Date:   Sat Jun 30 16:29:41 2007 +0200

    sdio: core support for SDIO function interrupt
    
    Signed-off-by: Nicolas Pitre <npitre@mvista.com>
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/core/sdio_irq.c b/drivers/mmc/core/sdio_irq.c
new file mode 100644
index 000000000000..01922d29241d
--- /dev/null
+++ b/drivers/mmc/core/sdio_irq.c
@@ -0,0 +1,237 @@
+/*
+ * linux/drivers/mmc/core/sdio_irq.c
+ *
+ * Author:      Nicolas Pitre
+ * Created:     June 18, 2007
+ * Copyright:   MontaVista Software Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at
+ * your option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/kthread.h>
+#include <linux/wait.h>
+#include <linux/delay.h>
+
+#include <linux/mmc/core.h>
+#include <linux/mmc/host.h>
+#include <linux/mmc/card.h>
+#include <linux/mmc/sdio.h>
+#include <linux/mmc/sdio_func.h>
+
+#include "sdio_ops.h"
+
+static int process_sdio_pending_irqs(struct mmc_card *card)
+{
+	int i, ret;
+	unsigned char pending;
+
+	ret = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_INTx, 0, &pending);
+	if (ret) {
+		printk(KERN_DEBUG "%s: error %d reading SDIO_CCCR_INTx\n",
+		       mmc_card_id(card), ret);
+		return ret;
+	}
+
+	for (i = 1; i <= 7; i++) {
+		if (pending & (1 << i)) {
+			struct sdio_func *func = card->sdio_func[i - 1];
+			if (!func) {
+				printk(KERN_WARNING "%s: pending IRQ for "
+					"non-existant function\n",
+					sdio_func_id(func));
+			} else if (func->irq_handler) {
+				func->irq_handler(func);
+			} else
+				printk(KERN_WARNING "%s: pending IRQ with no handler\n",
+				       sdio_func_id(func));
+		}
+	}
+
+	return 0;
+}
+
+static int sdio_irq_thread(void *_host)
+{
+	struct mmc_host *host = _host;
+	struct sched_param param = { .sched_priority = 1 };
+	unsigned long period;
+	int ret;
+
+	sched_setscheduler(current, SCHED_FIFO, &param);
+
+	/*
+	 * We want to allow for SDIO cards to work even on non SDIO
+	 * aware hosts.  One thing that non SDIO host cannot do is
+	 * asynchronous notification of pending SDIO card interrupts
+	 * hence we poll for them in that case.
+	 */
+	period = msecs_to_jiffies(10);
+
+	pr_debug("%s: IRQ thread started (poll period = %lu jiffies)\n",
+		 mmc_hostname(host), period);
+
+	do {
+		/*
+		 * We claim the host here on drivers behalf for a couple
+		 * reasons:
+		 *
+		 * 1) it is already needed to retrieve the CCCR_INTx;
+		 * 2) we want the driver(s) to clear the IRQ condition ASAP;
+		 * 3) we need to control the abort condition locally.
+		 *
+		 * Just like traditional hard IRQ handlers, we expect SDIO
+		 * IRQ handlers to be quick and to the point, so that the
+		 * holding of the host lock does not cover too much work
+		 * that doesn't require that lock to be held.
+		 */
+		ret = __mmc_claim_host(host, &host->sdio_irq_thread_abort);
+		if (ret)
+			break;
+		ret = process_sdio_pending_irqs(host->card);
+		mmc_release_host(host);
+
+		/*
+		 * Give other threads a chance to run in the presence of
+		 * errors.  FIXME: determine if due to card removal and
+		 * possibly exit this thread if so.
+		 */
+		if (ret)
+			ssleep(1);
+
+		set_task_state(current, TASK_INTERRUPTIBLE);
+		if (!kthread_should_stop())
+			schedule_timeout(period);
+		set_task_state(current, TASK_RUNNING);
+	} while (!kthread_should_stop());
+
+	pr_debug("%s: IRQ thread exiting with code %d\n",
+		 mmc_hostname(host), ret);
+
+	return ret;
+}
+
+static int sdio_card_irq_get(struct mmc_card *card)
+{
+	struct mmc_host *host = card->host;
+
+	BUG_ON(!host->claimed);
+
+	if (!host->sdio_irqs++) {
+		atomic_set(&host->sdio_irq_thread_abort, 0);
+		host->sdio_irq_thread =
+			kthread_run(sdio_irq_thread, host, "ksdiorqd");
+		if (IS_ERR(host->sdio_irq_thread)) {
+			int err = PTR_ERR(host->sdio_irq_thread);
+			host->sdio_irqs--;
+			return err;
+		}
+	}
+
+	return 0;
+}
+
+static int sdio_card_irq_put(struct mmc_card *card)
+{
+	struct mmc_host *host = card->host;
+
+	BUG_ON(!host->claimed);
+	BUG_ON(host->sdio_irqs < 1);
+
+	if (!--host->sdio_irqs) {
+		atomic_set(&host->sdio_irq_thread_abort, 1);
+		kthread_stop(host->sdio_irq_thread);
+	}
+
+	return 0;
+}
+
+/**
+ *	sdio_claim_irq - claim the IRQ for a SDIO function
+ *	@func: SDIO function
+ *	@handler: IRQ handler callback
+ *
+ *	Claim and activate the IRQ for the given SDIO function. The provided
+ *	handler will be called when that IRQ is asserted.  The host is always
+ *	claimed already when the handler is called so the handler must not
+ *	call sdio_claim_host() nor sdio_release_host().
+ */
+int sdio_claim_irq(struct sdio_func *func, sdio_irq_handler_t *handler)
+{
+	int ret;
+	unsigned char reg;
+
+	BUG_ON(!func);
+	BUG_ON(!func->card);
+
+	pr_debug("SDIO: Enabling IRQ for %s...\n", sdio_func_id(func));
+
+	if (func->irq_handler) {
+		pr_debug("SDIO: IRQ for %s already in use.\n", sdio_func_id(func));
+		return -EBUSY;
+	}
+
+	ret = mmc_io_rw_direct(func->card, 0, 0, SDIO_CCCR_IENx, 0, &reg);
+	if (ret)
+		return ret;
+
+	reg |= 1 << func->num;
+
+	reg |= 1; /* Master interrupt enable */
+
+	ret = mmc_io_rw_direct(func->card, 1, 0, SDIO_CCCR_IENx, reg, NULL);
+	if (ret)
+		return ret;
+
+	func->irq_handler = handler;
+	ret = sdio_card_irq_get(func->card);
+	if (ret)
+		func->irq_handler = NULL;
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(sdio_claim_irq);
+
+/**
+ *	sdio_release_irq - release the IRQ for a SDIO function
+ *	@func: SDIO function
+ *
+ *	Disable and release the IRQ for the given SDIO function.
+ */
+int sdio_release_irq(struct sdio_func *func)
+{
+	int ret;
+	unsigned char reg;
+
+	BUG_ON(!func);
+	BUG_ON(!func->card);
+
+	pr_debug("SDIO: Disabling IRQ for %s...\n", sdio_func_id(func));
+
+	if (func->irq_handler) {
+		func->irq_handler = NULL;
+		sdio_card_irq_put(func->card);
+	}
+
+	ret = mmc_io_rw_direct(func->card, 0, 0, SDIO_CCCR_IENx, 0, &reg);
+	if (ret)
+		return ret;
+
+	reg &= ~(1 << func->num);
+
+	/* Disable master interrupt with the last function interrupt */
+	if (!(reg & 0xFE))
+		reg = 0;
+
+	ret = mmc_io_rw_direct(func->card, 1, 0, SDIO_CCCR_IENx, reg, NULL);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(sdio_release_irq);
+
