commit 04f2f45f410f4c1f591482afa1ab6a8c44f0b713
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri May 8 11:52:28 2020 +0200

    mmc: sdricoh_cs: Respect the cmd->busy_timeout from the mmc core
    
    Using a fixed 1s polling timeout for all commands is a bit problematic.
    
    For some commands it means waiting longer than needed for the polling to be
    aborted, which may not a big issue, but still. For other commands, like for
    an erase (CMD38) that uses a R1B response, may require longer timeouts than
    1s. In these cases, we may end up treating the command as it failed, while
    it just needed some more time to complete successfully.
    
    Fix the problem by respecting the cmd->busy_timeout, which is provided by
    the mmc core.
    
    Note that, even if the sdricoh_cs driver may currently not support HW busy
    detection on DAT0, some comments in the code refer to that the HW may
    support it. Therefore, it seems better to be proactive in this case.
    
    Cc: Sascha Sommer <saschasommer@freenet.de>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Link: https://lore.kernel.org/r/20200508095228.14230-1-ulf.hansson@linaro.org

diff --git a/drivers/mmc/host/sdricoh_cs.c b/drivers/mmc/host/sdricoh_cs.c
index 0594b5ffe151..76a8cd3a186f 100644
--- a/drivers/mmc/host/sdricoh_cs.c
+++ b/drivers/mmc/host/sdricoh_cs.c
@@ -157,7 +157,7 @@ static int sdricoh_query_status(struct sdricoh_host *host, unsigned int wanted)
 
 static int sdricoh_mmc_cmd(struct sdricoh_host *host, struct mmc_command *cmd)
 {
-	unsigned int status;
+	unsigned int status, timeout_us;
 	int ret;
 	unsigned char opcode = cmd->opcode;
 
@@ -179,9 +179,12 @@ static int sdricoh_mmc_cmd(struct sdricoh_host *host, struct mmc_command *cmd)
 	if (!opcode)
 		return 0;
 
+	timeout_us = cmd->busy_timeout ? cmd->busy_timeout * 1000 :
+		SDRICOH_CMD_TIMEOUT_US;
+
 	ret = read_poll_timeout(sdricoh_readl, status,
 			sdricoh_status_ok(host, status, STATUS_CMD_FINISHED),
-			32, SDRICOH_CMD_TIMEOUT_US, false,
+			32, timeout_us, false,
 			host, R21C_STATUS);
 
 	/*

commit 3eea697c1da58f169b3abfebaa6d07cff7cb1c8d
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri May 8 11:52:18 2020 +0200

    mmc: sdricoh_cs: Throttle polling rate for commands
    
    Rather than to poll in a busy-loop, let's convert into using
    read_poll_timeout() and insert a small delay between each polling attempts.
    In particular, this avoids hogging the CPU.
    
    Additionally, to convert to read_poll_timeout() we also need to switch from
    using a specific number of polling attempts, into a specific timeout in us
    instead. The previous 100000 attempts, is translated into a total timeout
    of total 1s, as that seemed like reasonable value to pick.
    
    Cc: Sascha Sommer <saschasommer@freenet.de>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Link: https://lore.kernel.org/r/20200508095218.14177-1-ulf.hansson@linaro.org

diff --git a/drivers/mmc/host/sdricoh_cs.c b/drivers/mmc/host/sdricoh_cs.c
index 8392158e2e9f..0594b5ffe151 100644
--- a/drivers/mmc/host/sdricoh_cs.c
+++ b/drivers/mmc/host/sdricoh_cs.c
@@ -59,7 +59,7 @@ static unsigned int switchlocked;
 #define STATUS_BUSY              0x40000000
 
 /* timeouts */
-#define CMD_TIMEOUT       100000
+#define SDRICOH_CMD_TIMEOUT_US	1000000
 #define SDRICOH_DATA_TIMEOUT_US	1000000
 
 /* list of supported pcmcia devices */
@@ -158,8 +158,7 @@ static int sdricoh_query_status(struct sdricoh_host *host, unsigned int wanted)
 static int sdricoh_mmc_cmd(struct sdricoh_host *host, struct mmc_command *cmd)
 {
 	unsigned int status;
-	int result = 0;
-	unsigned int loop = 0;
+	int ret;
 	unsigned char opcode = cmd->opcode;
 
 	/* reset status reg? */
@@ -175,24 +174,24 @@ static int sdricoh_mmc_cmd(struct sdricoh_host *host, struct mmc_command *cmd)
 	/* fill parameters */
 	sdricoh_writel(host, R204_CMD_ARG, cmd->arg);
 	sdricoh_writel(host, R200_CMD, (0x10000 << 8) | opcode);
+
 	/* wait for command completion */
-	if (opcode) {
-		for (loop = 0; loop < CMD_TIMEOUT; loop++) {
-			status = sdricoh_readl(host, R21C_STATUS);
-			sdricoh_writel(host, R2E4_STATUS_RESP, status);
-			if (status  & STATUS_CMD_FINISHED)
-				break;
-		}
-		/* don't check for timeout in the loop it is not always
-		   reset correctly
-		*/
-		if (loop == CMD_TIMEOUT || status & STATUS_CMD_TIMEOUT)
-			result = -ETIMEDOUT;
+	if (!opcode)
+		return 0;
 
-	}
+	ret = read_poll_timeout(sdricoh_readl, status,
+			sdricoh_status_ok(host, status, STATUS_CMD_FINISHED),
+			32, SDRICOH_CMD_TIMEOUT_US, false,
+			host, R21C_STATUS);
 
-	return result;
+	/*
+	 * Don't check for timeout status in the loop, as it's not always reset
+	 * correctly.
+	 */
+	if (ret || status & STATUS_CMD_TIMEOUT)
+		return -ETIMEDOUT;
 
+	return 0;
 }
 
 static int sdricoh_reset(struct sdricoh_host *host)

commit eadb7897652d5bf9fbab393b3774598a04846aff
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri May 8 11:52:10 2020 +0200

    mmc: sdricoh_cs: Throttle polling rate for data transfers
    
    Rather than to poll in a busy-loop, let's convert into using
    read_poll_timeout() and insert a small delay between each polling attempts.
    In particular, this avoids hogging the CPU.
    
    Additionally, to convert to read_poll_timeout() we also need to switch from
    using a specific number of polling attempts, into a specific timeout in us
    instead. The previous 100000 attempts, is translated into a total timeout
    of total 1s, as that seemed like reasonable value to pick.
    
    Cc: Sascha Sommer <saschasommer@freenet.de>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Link: https://lore.kernel.org/r/20200508095210.14123-1-ulf.hansson@linaro.org

diff --git a/drivers/mmc/host/sdricoh_cs.c b/drivers/mmc/host/sdricoh_cs.c
index 97ef7d71375a..8392158e2e9f 100644
--- a/drivers/mmc/host/sdricoh_cs.c
+++ b/drivers/mmc/host/sdricoh_cs.c
@@ -15,6 +15,7 @@
 #include <linux/module.h>
 #include <linux/pci.h>
 #include <linux/ioport.h>
+#include <linux/iopoll.h>
 #include <linux/scatterlist.h>
 
 #include <pcmcia/cistpl.h>
@@ -59,7 +60,7 @@ static unsigned int switchlocked;
 
 /* timeouts */
 #define CMD_TIMEOUT       100000
-#define TRANSFER_TIMEOUT  100000
+#define SDRICOH_DATA_TIMEOUT_US	1000000
 
 /* list of supported pcmcia devices */
 static const struct pcmcia_device_id pcmcia_ids[] = {
@@ -123,21 +124,24 @@ static inline unsigned int sdricoh_readb(struct sdricoh_host *host,
 	return value;
 }
 
+static bool sdricoh_status_ok(struct sdricoh_host *host, unsigned int status,
+			      unsigned int wanted)
+{
+	sdricoh_writel(host, R2E4_STATUS_RESP, status);
+	return status & wanted;
+}
+
 static int sdricoh_query_status(struct sdricoh_host *host, unsigned int wanted)
 {
-	unsigned int loop;
+	int ret;
 	unsigned int status = 0;
-	unsigned int timeout = TRANSFER_TIMEOUT;
 	struct device *dev = host->dev;
 
-	for (loop = 0; loop < timeout; loop++) {
-		status = sdricoh_readl(host, R21C_STATUS);
-		sdricoh_writel(host, R2E4_STATUS_RESP, status);
-		if (status & wanted)
-			break;
-	}
-
-	if (loop == timeout) {
+	ret = read_poll_timeout(sdricoh_readl, status,
+				sdricoh_status_ok(host, status, wanted),
+				32, SDRICOH_DATA_TIMEOUT_US, false,
+				host, R21C_STATUS);
+	if (ret) {
 		dev_err(dev, "query_status: timeout waiting for %x\n", wanted);
 		return -ETIMEDOUT;
 	}

commit 6ccff65a29459fbc251f471ae4e20af425b2f0b1
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Tue Apr 14 18:14:05 2020 +0200

    mmc: sdricoh_cs: Drop redundant in-parameter to sdricoh_query_status()
    
    The in-parameter timeout is always set to TRANSFER_TIMEOUT by the callers
    of sdricoh_query_status(), hence let's drop it.
    
    Cc: Sascha Sommer <saschasommer@freenet.de>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Link: https://lore.kernel.org/r/20200414161413.3036-12-ulf.hansson@linaro.org

diff --git a/drivers/mmc/host/sdricoh_cs.c b/drivers/mmc/host/sdricoh_cs.c
index e7d74db95b57..97ef7d71375a 100644
--- a/drivers/mmc/host/sdricoh_cs.c
+++ b/drivers/mmc/host/sdricoh_cs.c
@@ -123,11 +123,13 @@ static inline unsigned int sdricoh_readb(struct sdricoh_host *host,
 	return value;
 }
 
-static int sdricoh_query_status(struct sdricoh_host *host, unsigned int wanted,
-				unsigned int timeout){
+static int sdricoh_query_status(struct sdricoh_host *host, unsigned int wanted)
+{
 	unsigned int loop;
 	unsigned int status = 0;
+	unsigned int timeout = TRANSFER_TIMEOUT;
 	struct device *dev = host->dev;
+
 	for (loop = 0; loop < timeout; loop++) {
 		status = sdricoh_readl(host, R21C_STATUS);
 		sdricoh_writel(host, R2E4_STATUS_RESP, status);
@@ -215,8 +217,7 @@ static int sdricoh_blockio(struct sdricoh_host *host, int read,
 	u32 data = 0;
 	/* wait until the data is available */
 	if (read) {
-		if (sdricoh_query_status(host, STATUS_READY_TO_READ,
-						TRANSFER_TIMEOUT))
+		if (sdricoh_query_status(host, STATUS_READY_TO_READ))
 			return -ETIMEDOUT;
 		sdricoh_writel(host, R21C_STATUS, 0x18);
 		/* read data */
@@ -232,8 +233,7 @@ static int sdricoh_blockio(struct sdricoh_host *host, int read,
 			}
 		}
 	} else {
-		if (sdricoh_query_status(host, STATUS_READY_TO_WRITE,
-						TRANSFER_TIMEOUT))
+		if (sdricoh_query_status(host, STATUS_READY_TO_WRITE))
 			return -ETIMEDOUT;
 		sdricoh_writel(host, R21C_STATUS, 0x18);
 		/* write data */
@@ -323,8 +323,7 @@ static void sdricoh_request(struct mmc_host *mmc, struct mmc_request *mrq)
 
 		sdricoh_writel(host, R208_DATAIO, 1);
 
-		if (sdricoh_query_status(host, STATUS_TRANSFER_FINISHED,
-					TRANSFER_TIMEOUT)) {
+		if (sdricoh_query_status(host, STATUS_TRANSFER_FINISHED)) {
 			dev_err(dev, "sdricoh_request: transfer end error\n");
 			cmd->error = -EINVAL;
 		}

commit 4b4c7daec4f92327e321d22347076a7e4d8320b0
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Tue Apr 14 18:14:04 2020 +0200

    mmc: sdricoh_cs: Move MMC_APP_CMD handling to sdricoh_mmc_cmd()
    
    Move MMC_APP_CMD specific handling to be managed by sdricoh_mmc_cmd(), as
    this makes the code a bit cleaner.
    
    Cc: Sascha Sommer <saschasommer@freenet.de>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Link: https://lore.kernel.org/r/20200414161413.3036-11-ulf.hansson@linaro.org

diff --git a/drivers/mmc/host/sdricoh_cs.c b/drivers/mmc/host/sdricoh_cs.c
index a41c0660abbf..e7d74db95b57 100644
--- a/drivers/mmc/host/sdricoh_cs.c
+++ b/drivers/mmc/host/sdricoh_cs.c
@@ -149,16 +149,25 @@ static int sdricoh_query_status(struct sdricoh_host *host, unsigned int wanted,
 
 }
 
-static int sdricoh_mmc_cmd(struct sdricoh_host *host, unsigned char opcode,
-			   unsigned int arg)
+static int sdricoh_mmc_cmd(struct sdricoh_host *host, struct mmc_command *cmd)
 {
 	unsigned int status;
 	int result = 0;
 	unsigned int loop = 0;
+	unsigned char opcode = cmd->opcode;
+
 	/* reset status reg? */
 	sdricoh_writel(host, R21C_STATUS, 0x18);
+
+	/* MMC_APP_CMDs need some special handling */
+	if (host->app_cmd) {
+		opcode |= 64;
+		host->app_cmd = 0;
+	} else if (opcode == MMC_APP_CMD)
+		host->app_cmd = 1;
+
 	/* fill parameters */
-	sdricoh_writel(host, R204_CMD_ARG, arg);
+	sdricoh_writel(host, R204_CMD_ARG, cmd->arg);
 	sdricoh_writel(host, R200_CMD, (0x10000 << 8) | opcode);
 	/* wait for command completion */
 	if (opcode) {
@@ -250,28 +259,20 @@ static void sdricoh_request(struct mmc_host *mmc, struct mmc_request *mrq)
 	struct mmc_command *cmd = mrq->cmd;
 	struct mmc_data *data = cmd->data;
 	struct device *dev = host->dev;
-	unsigned char opcode = cmd->opcode;
 	int i;
 
 	dev_dbg(dev, "=============================\n");
-	dev_dbg(dev, "sdricoh_request opcode=%i\n", opcode);
+	dev_dbg(dev, "sdricoh_request opcode=%i\n", cmd->opcode);
 
 	sdricoh_writel(host, R21C_STATUS, 0x18);
 
-	/* MMC_APP_CMDs need some special handling */
-	if (host->app_cmd) {
-		opcode |= 64;
-		host->app_cmd = 0;
-	} else if (opcode == MMC_APP_CMD)
-		host->app_cmd = 1;
-
 	/* read/write commands seem to require this */
 	if (data) {
 		sdricoh_writew(host, R226_BLOCKSIZE, data->blksz);
 		sdricoh_writel(host, R208_DATAIO, 0);
 	}
 
-	cmd->error = sdricoh_mmc_cmd(host, opcode, cmd->arg);
+	cmd->error = sdricoh_mmc_cmd(host, cmd);
 
 	/* read response buffer */
 	if (cmd->flags & MMC_RSP_PRESENT) {

commit cfa2c1dc7bb43cf3d00f27ec90022f6fb8f0bf42
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Tue Apr 14 18:14:03 2020 +0200

    mmc: sdricoh_cs: Use MMC_APP_CMD rather than a hardcoded number
    
    Cc: Sascha Sommer <saschasommer@freenet.de>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Link: https://lore.kernel.org/r/20200414161413.3036-10-ulf.hansson@linaro.org

diff --git a/drivers/mmc/host/sdricoh_cs.c b/drivers/mmc/host/sdricoh_cs.c
index 1fc4db713ef5..a41c0660abbf 100644
--- a/drivers/mmc/host/sdricoh_cs.c
+++ b/drivers/mmc/host/sdricoh_cs.c
@@ -22,6 +22,7 @@
 #include <linux/io.h>
 
 #include <linux/mmc/host.h>
+#include <linux/mmc/mmc.h>
 
 #define DRIVER_NAME "sdricoh_cs"
 
@@ -261,7 +262,7 @@ static void sdricoh_request(struct mmc_host *mmc, struct mmc_request *mrq)
 	if (host->app_cmd) {
 		opcode |= 64;
 		host->app_cmd = 0;
-	} else if (opcode == 55)
+	} else if (opcode == MMC_APP_CMD)
 		host->app_cmd = 1;
 
 	/* read/write commands seem to require this */

commit 710c7ff9a6815ca565b6acb08501ad18ca151429
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Tue Apr 14 18:14:02 2020 +0200

    mmc: sdricoh_cs: Drop unused defines
    
    Cc: Sascha Sommer <saschasommer@freenet.de>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Link: https://lore.kernel.org/r/20200414161413.3036-9-ulf.hansson@linaro.org

diff --git a/drivers/mmc/host/sdricoh_cs.c b/drivers/mmc/host/sdricoh_cs.c
index a38b8b2a4e5c..1fc4db713ef5 100644
--- a/drivers/mmc/host/sdricoh_cs.c
+++ b/drivers/mmc/host/sdricoh_cs.c
@@ -57,10 +57,8 @@ static unsigned int switchlocked;
 #define STATUS_BUSY              0x40000000
 
 /* timeouts */
-#define INIT_TIMEOUT      100
 #define CMD_TIMEOUT       100000
 #define TRANSFER_TIMEOUT  100000
-#define BUSY_TIMEOUT      32767
 
 /* list of supported pcmcia devices */
 static const struct pcmcia_device_id pcmcia_ids[] = {

commit 74ba9207e1adf1966c57450340534ae9742d00af
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 20 09:19:02 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 61
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      675 mass ave cambridge ma 02139 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 441 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Michael Ellerman <mpe@ellerman.id.au> (powerpc)
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190520071858.739733335@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/mmc/host/sdricoh_cs.c b/drivers/mmc/host/sdricoh_cs.c
index 9e46039282d2..a38b8b2a4e5c 100644
--- a/drivers/mmc/host/sdricoh_cs.c
+++ b/drivers/mmc/host/sdricoh_cs.c
@@ -1,23 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *  sdricoh_cs.c - driver for Ricoh Secure Digital Card Readers that can be
  *     found on some Ricoh RL5c476 II cardbus bridge
  *
  *  Copyright (C) 2006 - 2008 Sascha Sommer <saschasommer@freenet.de>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- *
  */
 
 /*

commit 01fa235c6eccfad0ef9cf383f75a5428ef7a9e2e
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Sat Jul 29 07:59:39 2017 +0200

    mmc: sdricoh_cs: constify mmc_host_ops structures
    
    The mmc_host_ops structure is only stored in the ops field of an
    mmc_host structure, which is declared as const.  Thus the mmc_host_ops
    structure itself can be const.
    
    Done with the help of Coccinelle.
    
    // <smpl>
    @r disable optional_qualifier@
    identifier i;
    position p;
    @@
    static struct mmc_host_ops i@p = { ... };
    
    @ok1@
    struct mmc_host *mmc;
    identifier r.i;
    position p;
    @@
    mmc->ops = &i@p
    
    @bad@
    position p != {r.p,ok1.p};
    identifier r.i;
    struct mmc_host_ops e;
    @@
    e@i@p
    
    @depends on !bad disable optional_qualifier@
    identifier r.i;
    @@
    static
    +const
     struct mmc_host_ops i = { ... };
    // </smpl>
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/host/sdricoh_cs.c b/drivers/mmc/host/sdricoh_cs.c
index 70cb00aa79a0..9e46039282d2 100644
--- a/drivers/mmc/host/sdricoh_cs.c
+++ b/drivers/mmc/host/sdricoh_cs.c
@@ -385,7 +385,7 @@ static int sdricoh_get_ro(struct mmc_host *mmc)
 	return (status & STATUS_CARD_LOCKED);
 }
 
-static struct mmc_host_ops sdricoh_ops = {
+static const struct mmc_host_ops sdricoh_ops = {
 	.request = sdricoh_request,
 	.set_ios = sdricoh_set_ios,
 	.get_ro = sdricoh_get_ro,

commit 675a7da857146338d047d1a63247bb48e7d5fed5
Author: Colin Ian King <colin.king@canonical.com>
Date:   Tue May 9 16:45:04 2017 +0100

    mmc: sdricoh_cs: remove redundant check if len is non-zero
    
    At the end of either of the read or write loops len is always zero
    and hence the non-zero check on len and return of -EIO is redundant
    and can be removed.
    
    Detected by CoverityScan, CID#114293 ("Logically dead code")
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/host/sdricoh_cs.c b/drivers/mmc/host/sdricoh_cs.c
index 5ff26ab81eb1..70cb00aa79a0 100644
--- a/drivers/mmc/host/sdricoh_cs.c
+++ b/drivers/mmc/host/sdricoh_cs.c
@@ -256,9 +256,6 @@ static int sdricoh_blockio(struct sdricoh_host *host, int read,
 		}
 	}
 
-	if (len)
-		return -EIO;
-
 	return 0;
 }
 

commit 1856de3d3e6cd6c2fe2f53f29f6b572795e3257a
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Tue Dec 29 21:45:34 2015 +0100

    mmc: sdricoh_cs: Less checks in sdricoh_init_mmc() after, error detection
    
    This issue was detected by using the Coccinelle software.
    
    Two pointer checks could be repeated by the sdricoh_init_mmc() function
    during error handling even if the relevant properties can be determined
    for the involved variables before by source code analysis.
    
    * This implementation detail could be improved by adjustments
      for jump targets according to the Linux coding style convention.
    
    * Drop an unnecessary initialisation for the variable "mmc" then.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/host/sdricoh_cs.c b/drivers/mmc/host/sdricoh_cs.c
index 5e57d9f7f7b5..5ff26ab81eb1 100644
--- a/drivers/mmc/host/sdricoh_cs.c
+++ b/drivers/mmc/host/sdricoh_cs.c
@@ -400,7 +400,7 @@ static int sdricoh_init_mmc(struct pci_dev *pci_dev,
 {
 	int result;
 	void __iomem *iobase;
-	struct mmc_host *mmc = NULL;
+	struct mmc_host *mmc;
 	struct sdricoh_host *host;
 	struct device *dev = &pcmcia_dev->dev;
 	/* map iomem */
@@ -419,7 +419,7 @@ static int sdricoh_init_mmc(struct pci_dev *pci_dev,
 	if (readl(iobase + R104_VERSION) != 0x4000) {
 		dev_dbg(dev, "no supported mmc controller found\n");
 		result = -ENODEV;
-		goto err;
+		goto unmap_io;
 	}
 	/* allocate privdata */
 	mmc = pcmcia_dev->priv =
@@ -427,7 +427,7 @@ static int sdricoh_init_mmc(struct pci_dev *pci_dev,
 	if (!mmc) {
 		dev_err(dev, "mmc_alloc_host failed\n");
 		result = -ENOMEM;
-		goto err;
+		goto unmap_io;
 	}
 	host = mmc_priv(mmc);
 
@@ -451,8 +451,7 @@ static int sdricoh_init_mmc(struct pci_dev *pci_dev,
 	if (sdricoh_reset(host)) {
 		dev_dbg(dev, "could not reset\n");
 		result = -EIO;
-		goto err;
-
+		goto free_host;
 	}
 
 	result = mmc_add_host(mmc);
@@ -461,13 +460,10 @@ static int sdricoh_init_mmc(struct pci_dev *pci_dev,
 		dev_dbg(dev, "mmc host registered\n");
 		return 0;
 	}
-
-err:
-	if (iobase)
-		pci_iounmap(pci_dev, iobase);
-	if (mmc)
-		mmc_free_host(mmc);
-
+free_host:
+	mmc_free_host(mmc);
+unmap_io:
+	pci_iounmap(pci_dev, iobase);
 	return result;
 }
 

commit c48c5d580e2aa6c22759836759b3c01e4ee9e8c0
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Tue Dec 29 21:11:45 2015 +0100

    mmc: sdricoh_cs: Delete unnecessary variable initialisations
    
    These variables will eventually be set to an appropriate value a bit later.
    * host
    * iobase
    * result
    
    Thus let us omit the explicit initialisation at the beginning.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/host/sdricoh_cs.c b/drivers/mmc/host/sdricoh_cs.c
index b7e305775314..5e57d9f7f7b5 100644
--- a/drivers/mmc/host/sdricoh_cs.c
+++ b/drivers/mmc/host/sdricoh_cs.c
@@ -398,10 +398,10 @@ static struct mmc_host_ops sdricoh_ops = {
 static int sdricoh_init_mmc(struct pci_dev *pci_dev,
 			    struct pcmcia_device *pcmcia_dev)
 {
-	int result = 0;
-	void __iomem *iobase = NULL;
+	int result;
+	void __iomem *iobase;
 	struct mmc_host *mmc = NULL;
-	struct sdricoh_host *host = NULL;
+	struct sdricoh_host *host;
 	struct device *dev = &pcmcia_dev->dev;
 	/* map iomem */
 	if (pci_resource_len(pci_dev, SDRICOH_PCI_REGION) !=

commit b2822d372560dfffd730b974b73d77b210a71ffa
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu Sep 26 10:02:56 2013 +0200

    mmc: sdricoh_cs: Move away from using deprecated APIs
    
    Suspend and resume of cards are being handled from the protocol layer
    and consequently the mmc_suspend|resume_host APIs are deprecated.
    
    This means we can simplify the suspend|resume callbacks by removing the
    use of the deprecated APIs.
    
    Cc: Sascha Sommer <saschasommer@freenet.de>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Sascha Sommer <saschasommer@freenet.de>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/host/sdricoh_cs.c b/drivers/mmc/host/sdricoh_cs.c
index 50adbd155f35..b7e305775314 100644
--- a/drivers/mmc/host/sdricoh_cs.c
+++ b/drivers/mmc/host/sdricoh_cs.c
@@ -516,9 +516,7 @@ static void sdricoh_pcmcia_detach(struct pcmcia_device *link)
 #ifdef CONFIG_PM
 static int sdricoh_pcmcia_suspend(struct pcmcia_device *link)
 {
-	struct mmc_host *mmc = link->priv;
 	dev_dbg(&link->dev, "suspend\n");
-	mmc_suspend_host(mmc);
 	return 0;
 }
 
@@ -527,7 +525,6 @@ static int sdricoh_pcmcia_resume(struct pcmcia_device *link)
 	struct mmc_host *mmc = link->priv;
 	dev_dbg(&link->dev, "resume\n");
 	sdricoh_reset(mmc_priv(mmc));
-	mmc_resume_host(mmc);
 	return 0;
 }
 #else

commit fe141149bffeaaaae214b6fbb98b592d3c516fb5
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Mar 6 11:27:15 2013 -0700

    drivers/mmc: use module_pcmcia_driver() in pcmcia drivers
    
    Use the new module_pcmcia_driver() macro to remove the boilerplate
    module init/exit code in the pcmcia drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/mmc/host/sdricoh_cs.c b/drivers/mmc/host/sdricoh_cs.c
index 7009f17ad6cd..50adbd155f35 100644
--- a/drivers/mmc/host/sdricoh_cs.c
+++ b/drivers/mmc/host/sdricoh_cs.c
@@ -543,25 +543,7 @@ static struct pcmcia_driver sdricoh_driver = {
 	.suspend = sdricoh_pcmcia_suspend,
 	.resume = sdricoh_pcmcia_resume,
 };
-
-/*****************************************************************************\
- *                                                                           *
- * Driver init/exit                                                          *
- *                                                                           *
-\*****************************************************************************/
-
-static int __init sdricoh_drv_init(void)
-{
-	return pcmcia_register_driver(&sdricoh_driver);
-}
-
-static void __exit sdricoh_drv_exit(void)
-{
-	pcmcia_unregister_driver(&sdricoh_driver);
-}
-
-module_init(sdricoh_drv_init);
-module_exit(sdricoh_drv_exit);
+module_pcmcia_driver(sdricoh_driver);
 
 module_param(switchlocked, uint, 0444);
 

commit 88b47679746b81534002bcba42da97ab82b5d12a
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Sun Jul 3 15:15:51 2011 -0400

    mmc: Add module.h to drivers/mmc users assuming implicit presence.
    
    We are cleaning up the implicit presence of module.h; these guys are
    some of the people who just assume it will be there.  Call it out
    explitly for those that really need it.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/host/sdricoh_cs.c b/drivers/mmc/host/sdricoh_cs.c
index 496b7efbc6b0..7009f17ad6cd 100644
--- a/drivers/mmc/host/sdricoh_cs.c
+++ b/drivers/mmc/host/sdricoh_cs.c
@@ -26,6 +26,7 @@
 */
 #include <linux/delay.h>
 #include <linux/highmem.h>
+#include <linux/module.h>
 #include <linux/pci.h>
 #include <linux/ioport.h>
 #include <linux/scatterlist.h>

commit 25f8f54f6e178acfd503a95441b0ea05c525f751
Author: Joe Perches <joe@perches.com>
Date:   Tue May 3 19:29:01 2011 -0700

    pcmcia: Convert pcmcia_device_id declarations to const
    
    Saves about 50KB of data.
    
    Old/new size of all objects:
       text    data     bss     dec     hex filename
     563015   80096  130684  773795   bcea3 (TOTALS)
     610916   32256  130632  773804   bceac (TOTALS)
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Acked-by: Kurt Van Dijck <kurt.van.dijck@eia.be> (for drivers/net/can/softing/softing_cs.c)
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/mmc/host/sdricoh_cs.c b/drivers/mmc/host/sdricoh_cs.c
index bbc298fd2a15..496b7efbc6b0 100644
--- a/drivers/mmc/host/sdricoh_cs.c
+++ b/drivers/mmc/host/sdricoh_cs.c
@@ -76,7 +76,7 @@ static unsigned int switchlocked;
 #define BUSY_TIMEOUT      32767
 
 /* list of supported pcmcia devices */
-static struct pcmcia_device_id pcmcia_ids[] = {
+static const struct pcmcia_device_id pcmcia_ids[] = {
 	/* vendor and device strings followed by their crc32 hashes */
 	PCMCIA_DEVICE_PROD_ID12("RICOH", "Bay1Controller", 0xd9f522ed,
 				0xc3901202),

commit b595076a180a56d1bb170e6eceda6eb9d76f4cd3
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Mon Nov 1 15:38:34 2010 -0400

    tree-wide: fix comment/printk typos
    
    "gadget", "through", "command", "maintain", "maintain", "controller", "address",
    "between", "initiali[zs]e", "instead", "function", "select", "already",
    "equal", "access", "management", "hierarchy", "registration", "interest",
    "relative", "memory", "offset", "already",
    
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/mmc/host/sdricoh_cs.c b/drivers/mmc/host/sdricoh_cs.c
index f472c2714eb8..bbc298fd2a15 100644
--- a/drivers/mmc/host/sdricoh_cs.c
+++ b/drivers/mmc/host/sdricoh_cs.c
@@ -446,7 +446,7 @@ static int sdricoh_init_mmc(struct pci_dev *pci_dev,
 	mmc->max_seg_size = 1024 * 512;
 	mmc->max_blk_size = 512;
 
-	/* reset the controler */
+	/* reset the controller */
 	if (sdricoh_reset(host)) {
 		dev_dbg(dev, "could not reset\n");
 		result = -EIO;
@@ -478,7 +478,7 @@ static int sdricoh_pcmcia_probe(struct pcmcia_device *pcmcia_dev)
 	dev_info(&pcmcia_dev->dev, "Searching MMC controller for pcmcia device"
 		" %s %s ...\n", pcmcia_dev->prod_id[0], pcmcia_dev->prod_id[1]);
 
-	/* search pci cardbus bridge that contains the mmc controler */
+	/* search pci cardbus bridge that contains the mmc controller */
 	/* the io region is already claimed by yenta_socket... */
 	while ((pci_dev =
 		pci_get_device(PCI_VENDOR_ID_RICOH, PCI_DEVICE_ID_RICOH_RL5C476,

commit 2e9b981a7c63ee8278df6823f8389d69dad1a499
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sun Aug 8 11:36:26 2010 +0200

    pcmcia: move driver name to struct pcmcia_driver
    
    Tested-by: Wolfram Sang <w.sang@pengutronix.de>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/mmc/host/sdricoh_cs.c b/drivers/mmc/host/sdricoh_cs.c
index 7a7273b09d9a..f472c2714eb8 100644
--- a/drivers/mmc/host/sdricoh_cs.c
+++ b/drivers/mmc/host/sdricoh_cs.c
@@ -535,9 +535,7 @@ static int sdricoh_pcmcia_resume(struct pcmcia_device *link)
 #endif
 
 static struct pcmcia_driver sdricoh_driver = {
-	.drv = {
-		.name = DRIVER_NAME,
-		},
+	.name = DRIVER_NAME,
 	.probe = sdricoh_pcmcia_probe,
 	.remove = sdricoh_pcmcia_detach,
 	.id_table = pcmcia_ids,

commit 1ac71e5a35eebee60cdcf15b3980bd94498f037b
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Thu Jul 29 19:27:09 2010 +0200

    pcmcia: convert pcmcia_request_configuration to pcmcia_enable_device
    
    pcmcia_enable_device() now replaces pcmcia_request_configuration().
    Instead of config_req_t, all necessary flags are either passed as
    a parameter to pcmcia_enable_device(), or (in rare circumstances)
    set in struct pcmcia_device -> flags.
    
    With the last remaining user of include/pcmcia/cs.h gone, remove
    all references.
    
    CC: netdev@vger.kernel.org
    CC: linux-wireless@vger.kernel.org
    CC: linux-ide@vger.kernel.org
    CC: linux-usb@vger.kernel.org
    CC: laforge@gnumonks.org
    CC: linux-mtd@lists.infradead.org
    CC: alsa-devel@alsa-project.org
    CC: linux-serial@vger.kernel.org
    CC: Jiri Kosina <jkosina@suse.cz>
    CC: linux-scsi@vger.kernel.org
    Acked-by: Gustavo F. Padovan <padovan@profusion.mobi> (for drivers/bluetooth)
    Tested-by: Wolfram Sang <w.sang@pengutronix.de>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/mmc/host/sdricoh_cs.c b/drivers/mmc/host/sdricoh_cs.c
index 7aa65bb2af4a..7a7273b09d9a 100644
--- a/drivers/mmc/host/sdricoh_cs.c
+++ b/drivers/mmc/host/sdricoh_cs.c
@@ -30,7 +30,6 @@
 #include <linux/ioport.h>
 #include <linux/scatterlist.h>
 
-#include <pcmcia/cs.h>
 #include <pcmcia/cistpl.h>
 #include <pcmcia/ds.h>
 #include <linux/io.h>

commit ac8b422838046ffc26be4874a3cbae0d313f4209
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Wed Jul 21 22:38:13 2010 +0200

    pcmcia: remove cs_types.h
    
    Remove cs_types.h which is no longer needed: Most definitions aren't
    used at all, a few can be made away with, and two remaining definitions
    (typedefs, unfortunatley) may be moved to more specific places.
    
    CC: linux-ide@vger.kernel.org
    CC: linux-usb@vger.kernel.org
    CC: laforge@gnumonks.org
    CC: linux-mtd@lists.infradead.org
    CC: alsa-devel@alsa-project.org
    CC: linux-serial@vger.kernel.org
    Acked-by: Marcel Holtmann <marcel@holtmann.org> (for drivers/bluetooth/)
    Acked-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/mmc/host/sdricoh_cs.c b/drivers/mmc/host/sdricoh_cs.c
index e7507af3856e..7aa65bb2af4a 100644
--- a/drivers/mmc/host/sdricoh_cs.c
+++ b/drivers/mmc/host/sdricoh_cs.c
@@ -30,7 +30,6 @@
 #include <linux/ioport.h>
 #include <linux/scatterlist.h>
 
-#include <pcmcia/cs_types.h>
 #include <pcmcia/cs.h>
 #include <pcmcia/cistpl.h>
 #include <pcmcia/ds.h>

commit 1a13f8fa76c880be41d6b1e6a2b44404bcbfdf9e
Author: Matt Fleming <matt@console-pimps.org>
Date:   Wed May 26 14:42:08 2010 -0700

    mmc: remove the "state" argument to mmc_suspend_host()
    
    Even though many mmc host drivers pass a pm_message_t argument to
    mmc_suspend_host() that argument isn't used the by MMC core.  As host
    drivers are converted to dev_pm_ops they'll have to construct
    pm_message_t's (as they won't be passed by the PM subsystem any more) just
    to appease the mmc suspend interface.
    
    We might as well just delete the unused paramter.
    
    Signed-off-by: Matt Fleming <matt@console-pimps.org>
    Acked-by: Anton Vorontsov <cbouatmailru@gmail.com>
    Acked-by: Michal Miroslaw <mirq-linux@rere.qmqm.pl>ZZ
    Acked-by: Sascha Sommer <saschasommer@freenet.de>
    Cc: <linux-mmc@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/mmc/host/sdricoh_cs.c b/drivers/mmc/host/sdricoh_cs.c
index cb41e9c3ac07..e7507af3856e 100644
--- a/drivers/mmc/host/sdricoh_cs.c
+++ b/drivers/mmc/host/sdricoh_cs.c
@@ -519,7 +519,7 @@ static int sdricoh_pcmcia_suspend(struct pcmcia_device *link)
 {
 	struct mmc_host *mmc = link->priv;
 	dev_dbg(&link->dev, "suspend\n");
-	mmc_suspend_host(mmc, PMSG_SUSPEND);
+	mmc_suspend_host(mmc);
 	return 0;
 }
 

commit 418f19ea17a99421b22a64e101e14b6a16bed66d
Merge: 98444d3dd975 f6e10b865c3e
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Wed Dec 31 19:56:05 2008 +0100

    Merge branch 'master' of ../mmc

commit ca4f10563929b932ed8970fda41a7f99385e4b0b
Author: Roel Kluin <roel.kluin@gmail.com>
Date:   Sat Dec 13 21:21:33 2008 +0100

    mmc: balanc pci_iomap with pci_iounmap
    
    balance pci_iomap with pci_iounmap, not iounmap
    
    Signed-off-by: Roel Kluin <roel.kluin@gmail.com>
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/host/sdricoh_cs.c b/drivers/mmc/host/sdricoh_cs.c
index 1df44d966bdb..d4748a8e0ded 100644
--- a/drivers/mmc/host/sdricoh_cs.c
+++ b/drivers/mmc/host/sdricoh_cs.c
@@ -463,7 +463,7 @@ static int sdricoh_init_mmc(struct pci_dev *pci_dev,
 
 err:
 	if (iobase)
-		iounmap(iobase);
+		pci_iounmap(pci_dev, iobase);
 	if (mmc)
 		mmc_free_host(mmc);
 

commit 98444d3dd975653a4a970ecc0dfc30918da92f60
Author: Sascha Sommer <saschasommer@freenet.de>
Date:   Sat Nov 29 07:51:19 2008 +0100

    sdricoh_cs: Add support for Bay Controller devices
    
    Some Ricoh SD card readers seems to advertise themselves slightly differently.
    This patches the driver to will recognise an additional product id, and it
    appears to work perfectly.
    
      % pccardctl info
      PRODID_1="RICOH"
      PRODID_2="Bay Controller"
      PRODID_3=""
      PRODID_4=""
      MANFID=0000,0000
    
    Signed-off-by: Charles Lowe <aquasync@gmail.com>
    Acked-by: Sascha Sommer <saschasommer@freenet.de>
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/host/sdricoh_cs.c b/drivers/mmc/host/sdricoh_cs.c
index 1df44d966bdb..435863370017 100644
--- a/drivers/mmc/host/sdricoh_cs.c
+++ b/drivers/mmc/host/sdricoh_cs.c
@@ -82,6 +82,8 @@ static struct pcmcia_device_id pcmcia_ids[] = {
 	/* vendor and device strings followed by their crc32 hashes */
 	PCMCIA_DEVICE_PROD_ID12("RICOH", "Bay1Controller", 0xd9f522ed,
 				0xc3901202),
+	PCMCIA_DEVICE_PROD_ID12("RICOH", "Bay Controller", 0xd9f522ed,
+				0xace80909),
 	PCMCIA_DEVICE_NULL,
 };
 

commit fe7f962505892c7894c473cd78ade87767689c8d
Author: Huang Weiyi <weiyi.huang@gmail.com>
Date:   Sun Aug 17 07:51:10 2008 +0800

    sdricoh_cs: removed unused #include <version.h>
    
    The drivers below do not use LINUX_VERSION_CODE nor KERNEL_VERSION.
      drivers/mmc/host/sdricoh_cs.c
    
    This patch removes the said #include <version.h>.
    
    Signed-off-by: Huang Weiyi <weiyi.huang@gmail.com>
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/host/sdricoh_cs.c b/drivers/mmc/host/sdricoh_cs.c
index f99e9f721629..1df44d966bdb 100644
--- a/drivers/mmc/host/sdricoh_cs.c
+++ b/drivers/mmc/host/sdricoh_cs.c
@@ -29,7 +29,6 @@
 #include <linux/pci.h>
 #include <linux/ioport.h>
 #include <linux/scatterlist.h>
-#include <linux/version.h>
 
 #include <pcmcia/cs_types.h>
 #include <pcmcia/cs.h>

commit 6a36913a33cf3d366e124f25c486a71212d02bce
Author: Sascha Sommer <saschasommer@freenet.de>
Date:   Tue Jul 15 14:21:29 2008 +0200

    mmc: host driver for Ricoh Bay1Controllers
    
    Signed-off-by: Sascha Sommer <saschasommer@freenet.de>
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/host/sdricoh_cs.c b/drivers/mmc/host/sdricoh_cs.c
new file mode 100644
index 000000000000..f99e9f721629
--- /dev/null
+++ b/drivers/mmc/host/sdricoh_cs.c
@@ -0,0 +1,575 @@
+/*
+ *  sdricoh_cs.c - driver for Ricoh Secure Digital Card Readers that can be
+ *     found on some Ricoh RL5c476 II cardbus bridge
+ *
+ *  Copyright (C) 2006 - 2008 Sascha Sommer <saschasommer@freenet.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+/*
+#define DEBUG
+#define VERBOSE_DEBUG
+*/
+#include <linux/delay.h>
+#include <linux/highmem.h>
+#include <linux/pci.h>
+#include <linux/ioport.h>
+#include <linux/scatterlist.h>
+#include <linux/version.h>
+
+#include <pcmcia/cs_types.h>
+#include <pcmcia/cs.h>
+#include <pcmcia/cistpl.h>
+#include <pcmcia/ds.h>
+#include <linux/io.h>
+
+#include <linux/mmc/host.h>
+
+#define DRIVER_NAME "sdricoh_cs"
+
+static unsigned int switchlocked;
+
+/* i/o region */
+#define SDRICOH_PCI_REGION 0
+#define SDRICOH_PCI_REGION_SIZE 0x1000
+
+/* registers */
+#define R104_VERSION     0x104
+#define R200_CMD         0x200
+#define R204_CMD_ARG     0x204
+#define R208_DATAIO      0x208
+#define R20C_RESP        0x20c
+#define R21C_STATUS      0x21c
+#define R2E0_INIT        0x2e0
+#define R2E4_STATUS_RESP 0x2e4
+#define R2F0_RESET       0x2f0
+#define R224_MODE        0x224
+#define R226_BLOCKSIZE   0x226
+#define R228_POWER       0x228
+#define R230_DATA        0x230
+
+/* flags for the R21C_STATUS register */
+#define STATUS_CMD_FINISHED      0x00000001
+#define STATUS_TRANSFER_FINISHED 0x00000004
+#define STATUS_CARD_INSERTED     0x00000020
+#define STATUS_CARD_LOCKED       0x00000080
+#define STATUS_CMD_TIMEOUT       0x00400000
+#define STATUS_READY_TO_READ     0x01000000
+#define STATUS_READY_TO_WRITE    0x02000000
+#define STATUS_BUSY              0x40000000
+
+/* timeouts */
+#define INIT_TIMEOUT      100
+#define CMD_TIMEOUT       100000
+#define TRANSFER_TIMEOUT  100000
+#define BUSY_TIMEOUT      32767
+
+/* list of supported pcmcia devices */
+static struct pcmcia_device_id pcmcia_ids[] = {
+	/* vendor and device strings followed by their crc32 hashes */
+	PCMCIA_DEVICE_PROD_ID12("RICOH", "Bay1Controller", 0xd9f522ed,
+				0xc3901202),
+	PCMCIA_DEVICE_NULL,
+};
+
+MODULE_DEVICE_TABLE(pcmcia, pcmcia_ids);
+
+/* mmc privdata */
+struct sdricoh_host {
+	struct device *dev;
+	struct mmc_host *mmc;	/* MMC structure */
+	unsigned char __iomem *iobase;
+	struct pci_dev *pci_dev;
+	int app_cmd;
+};
+
+/***************** register i/o helper functions *****************************/
+
+static inline unsigned int sdricoh_readl(struct sdricoh_host *host,
+					 unsigned int reg)
+{
+	unsigned int value = readl(host->iobase + reg);
+	dev_vdbg(host->dev, "rl %x 0x%x\n", reg, value);
+	return value;
+}
+
+static inline void sdricoh_writel(struct sdricoh_host *host, unsigned int reg,
+				  unsigned int value)
+{
+	writel(value, host->iobase + reg);
+	dev_vdbg(host->dev, "wl %x 0x%x\n", reg, value);
+
+}
+
+static inline unsigned int sdricoh_readw(struct sdricoh_host *host,
+					 unsigned int reg)
+{
+	unsigned int value = readw(host->iobase + reg);
+	dev_vdbg(host->dev, "rb %x 0x%x\n", reg, value);
+	return value;
+}
+
+static inline void sdricoh_writew(struct sdricoh_host *host, unsigned int reg,
+					 unsigned short value)
+{
+	writew(value, host->iobase + reg);
+	dev_vdbg(host->dev, "ww %x 0x%x\n", reg, value);
+}
+
+static inline unsigned int sdricoh_readb(struct sdricoh_host *host,
+					 unsigned int reg)
+{
+	unsigned int value = readb(host->iobase + reg);
+	dev_vdbg(host->dev, "rb %x 0x%x\n", reg, value);
+	return value;
+}
+
+static int sdricoh_query_status(struct sdricoh_host *host, unsigned int wanted,
+				unsigned int timeout){
+	unsigned int loop;
+	unsigned int status = 0;
+	struct device *dev = host->dev;
+	for (loop = 0; loop < timeout; loop++) {
+		status = sdricoh_readl(host, R21C_STATUS);
+		sdricoh_writel(host, R2E4_STATUS_RESP, status);
+		if (status & wanted)
+			break;
+	}
+
+	if (loop == timeout) {
+		dev_err(dev, "query_status: timeout waiting for %x\n", wanted);
+		return -ETIMEDOUT;
+	}
+
+	/* do not do this check in the loop as some commands fail otherwise */
+	if (status & 0x7F0000) {
+		dev_err(dev, "waiting for status bit %x failed\n", wanted);
+		return -EINVAL;
+	}
+	return 0;
+
+}
+
+static int sdricoh_mmc_cmd(struct sdricoh_host *host, unsigned char opcode,
+			   unsigned int arg)
+{
+	unsigned int status;
+	int result = 0;
+	unsigned int loop = 0;
+	/* reset status reg? */
+	sdricoh_writel(host, R21C_STATUS, 0x18);
+	/* fill parameters */
+	sdricoh_writel(host, R204_CMD_ARG, arg);
+	sdricoh_writel(host, R200_CMD, (0x10000 << 8) | opcode);
+	/* wait for command completion */
+	if (opcode) {
+		for (loop = 0; loop < CMD_TIMEOUT; loop++) {
+			status = sdricoh_readl(host, R21C_STATUS);
+			sdricoh_writel(host, R2E4_STATUS_RESP, status);
+			if (status  & STATUS_CMD_FINISHED)
+				break;
+		}
+		/* don't check for timeout in the loop it is not always
+		   reset correctly
+		*/
+		if (loop == CMD_TIMEOUT || status & STATUS_CMD_TIMEOUT)
+			result = -ETIMEDOUT;
+
+	}
+
+	return result;
+
+}
+
+static int sdricoh_reset(struct sdricoh_host *host)
+{
+	dev_dbg(host->dev, "reset\n");
+	sdricoh_writel(host, R2F0_RESET, 0x10001);
+	sdricoh_writel(host, R2E0_INIT, 0x10000);
+	if (sdricoh_readl(host, R2E0_INIT) != 0x10000)
+		return -EIO;
+	sdricoh_writel(host, R2E0_INIT, 0x10007);
+
+	sdricoh_writel(host, R224_MODE, 0x2000000);
+	sdricoh_writel(host, R228_POWER, 0xe0);
+
+
+	/* status register ? */
+	sdricoh_writel(host, R21C_STATUS, 0x18);
+
+	return 0;
+}
+
+static int sdricoh_blockio(struct sdricoh_host *host, int read,
+				u8 *buf, int len)
+{
+	int size;
+	u32 data = 0;
+	/* wait until the data is available */
+	if (read) {
+		if (sdricoh_query_status(host, STATUS_READY_TO_READ,
+						TRANSFER_TIMEOUT))
+			return -ETIMEDOUT;
+		sdricoh_writel(host, R21C_STATUS, 0x18);
+		/* read data */
+		while (len) {
+			data = sdricoh_readl(host, R230_DATA);
+			size = min(len, 4);
+			len -= size;
+			while (size) {
+				*buf = data & 0xFF;
+				buf++;
+				data >>= 8;
+				size--;
+			}
+		}
+	} else {
+		if (sdricoh_query_status(host, STATUS_READY_TO_WRITE,
+						TRANSFER_TIMEOUT))
+			return -ETIMEDOUT;
+		sdricoh_writel(host, R21C_STATUS, 0x18);
+		/* write data */
+		while (len) {
+			size = min(len, 4);
+			len -= size;
+			while (size) {
+				data >>= 8;
+				data |= (u32)*buf << 24;
+				buf++;
+				size--;
+			}
+			sdricoh_writel(host, R230_DATA, data);
+		}
+	}
+
+	if (len)
+		return -EIO;
+
+	return 0;
+}
+
+static void sdricoh_request(struct mmc_host *mmc, struct mmc_request *mrq)
+{
+	struct sdricoh_host *host = mmc_priv(mmc);
+	struct mmc_command *cmd = mrq->cmd;
+	struct mmc_data *data = cmd->data;
+	struct device *dev = host->dev;
+	unsigned char opcode = cmd->opcode;
+	int i;
+
+	dev_dbg(dev, "=============================\n");
+	dev_dbg(dev, "sdricoh_request opcode=%i\n", opcode);
+
+	sdricoh_writel(host, R21C_STATUS, 0x18);
+
+	/* MMC_APP_CMDs need some special handling */
+	if (host->app_cmd) {
+		opcode |= 64;
+		host->app_cmd = 0;
+	} else if (opcode == 55)
+		host->app_cmd = 1;
+
+	/* read/write commands seem to require this */
+	if (data) {
+		sdricoh_writew(host, R226_BLOCKSIZE, data->blksz);
+		sdricoh_writel(host, R208_DATAIO, 0);
+	}
+
+	cmd->error = sdricoh_mmc_cmd(host, opcode, cmd->arg);
+
+	/* read response buffer */
+	if (cmd->flags & MMC_RSP_PRESENT) {
+		if (cmd->flags & MMC_RSP_136) {
+			/* CRC is stripped so we need to do some shifting. */
+			for (i = 0; i < 4; i++) {
+				cmd->resp[i] =
+				    sdricoh_readl(host,
+						  R20C_RESP + (3 - i) * 4) << 8;
+				if (i != 3)
+					cmd->resp[i] |=
+					    sdricoh_readb(host, R20C_RESP +
+							  (3 - i) * 4 - 1);
+			}
+		} else
+			cmd->resp[0] = sdricoh_readl(host, R20C_RESP);
+	}
+
+	/* transfer data */
+	if (data && cmd->error == 0) {
+		dev_dbg(dev, "transfer: blksz %i blocks %i sg_len %i "
+			"sg length %i\n", data->blksz, data->blocks,
+			data->sg_len, data->sg->length);
+
+		/* enter data reading mode */
+		sdricoh_writel(host, R21C_STATUS, 0x837f031e);
+		for (i = 0; i < data->blocks; i++) {
+			size_t len = data->blksz;
+			u8 *buf;
+			struct page *page;
+			int result;
+			page = sg_page(data->sg);
+
+			buf = kmap(page) + data->sg->offset + (len * i);
+			result =
+				sdricoh_blockio(host,
+					data->flags & MMC_DATA_READ, buf, len);
+			kunmap(page);
+			flush_dcache_page(page);
+			if (result) {
+				dev_err(dev, "sdricoh_request: cmd %i "
+					"block transfer failed\n", cmd->opcode);
+				cmd->error = result;
+				break;
+			} else
+				data->bytes_xfered += len;
+		}
+
+		sdricoh_writel(host, R208_DATAIO, 1);
+
+		if (sdricoh_query_status(host, STATUS_TRANSFER_FINISHED,
+					TRANSFER_TIMEOUT)) {
+			dev_err(dev, "sdricoh_request: transfer end error\n");
+			cmd->error = -EINVAL;
+		}
+	}
+	/* FIXME check busy flag */
+
+	mmc_request_done(mmc, mrq);
+	dev_dbg(dev, "=============================\n");
+}
+
+static void sdricoh_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
+{
+	struct sdricoh_host *host = mmc_priv(mmc);
+	dev_dbg(host->dev, "set_ios\n");
+
+	if (ios->power_mode == MMC_POWER_ON) {
+		sdricoh_writel(host, R228_POWER, 0xc0e0);
+
+		if (ios->bus_width == MMC_BUS_WIDTH_4) {
+			sdricoh_writel(host, R224_MODE, 0x2000300);
+			sdricoh_writel(host, R228_POWER, 0x40e0);
+		} else {
+			sdricoh_writel(host, R224_MODE, 0x2000340);
+		}
+
+	} else if (ios->power_mode == MMC_POWER_UP) {
+		sdricoh_writel(host, R224_MODE, 0x2000320);
+		sdricoh_writel(host, R228_POWER, 0xe0);
+	}
+}
+
+static int sdricoh_get_ro(struct mmc_host *mmc)
+{
+	struct sdricoh_host *host = mmc_priv(mmc);
+	unsigned int status;
+
+	status = sdricoh_readl(host, R21C_STATUS);
+	sdricoh_writel(host, R2E4_STATUS_RESP, status);
+
+	/* some notebooks seem to have the locked flag switched */
+	if (switchlocked)
+		return !(status & STATUS_CARD_LOCKED);
+
+	return (status & STATUS_CARD_LOCKED);
+}
+
+static struct mmc_host_ops sdricoh_ops = {
+	.request = sdricoh_request,
+	.set_ios = sdricoh_set_ios,
+	.get_ro = sdricoh_get_ro,
+};
+
+/* initialize the control and register it to the mmc framework */
+static int sdricoh_init_mmc(struct pci_dev *pci_dev,
+			    struct pcmcia_device *pcmcia_dev)
+{
+	int result = 0;
+	void __iomem *iobase = NULL;
+	struct mmc_host *mmc = NULL;
+	struct sdricoh_host *host = NULL;
+	struct device *dev = &pcmcia_dev->dev;
+	/* map iomem */
+	if (pci_resource_len(pci_dev, SDRICOH_PCI_REGION) !=
+	    SDRICOH_PCI_REGION_SIZE) {
+		dev_dbg(dev, "unexpected pci resource len\n");
+		return -ENODEV;
+	}
+	iobase =
+	    pci_iomap(pci_dev, SDRICOH_PCI_REGION, SDRICOH_PCI_REGION_SIZE);
+	if (!iobase) {
+		dev_err(dev, "unable to map iobase\n");
+		return -ENODEV;
+	}
+	/* check version? */
+	if (readl(iobase + R104_VERSION) != 0x4000) {
+		dev_dbg(dev, "no supported mmc controller found\n");
+		result = -ENODEV;
+		goto err;
+	}
+	/* allocate privdata */
+	mmc = pcmcia_dev->priv =
+	    mmc_alloc_host(sizeof(struct sdricoh_host), &pcmcia_dev->dev);
+	if (!mmc) {
+		dev_err(dev, "mmc_alloc_host failed\n");
+		result = -ENOMEM;
+		goto err;
+	}
+	host = mmc_priv(mmc);
+
+	host->iobase = iobase;
+	host->dev = dev;
+	host->pci_dev = pci_dev;
+
+	mmc->ops = &sdricoh_ops;
+
+	/* FIXME: frequency and voltage handling is done by the controller
+	 */
+	mmc->f_min = 450000;
+	mmc->f_max = 24000000;
+	mmc->ocr_avail = MMC_VDD_32_33 | MMC_VDD_33_34;
+	mmc->caps |= MMC_CAP_4_BIT_DATA;
+
+	mmc->max_seg_size = 1024 * 512;
+	mmc->max_blk_size = 512;
+
+	/* reset the controler */
+	if (sdricoh_reset(host)) {
+		dev_dbg(dev, "could not reset\n");
+		result = -EIO;
+		goto err;
+
+	}
+
+	result = mmc_add_host(mmc);
+
+	if (!result) {
+		dev_dbg(dev, "mmc host registered\n");
+		return 0;
+	}
+
+err:
+	if (iobase)
+		iounmap(iobase);
+	if (mmc)
+		mmc_free_host(mmc);
+
+	return result;
+}
+
+/* search for supported mmc controllers */
+static int sdricoh_pcmcia_probe(struct pcmcia_device *pcmcia_dev)
+{
+	struct pci_dev *pci_dev = NULL;
+
+	dev_info(&pcmcia_dev->dev, "Searching MMC controller for pcmcia device"
+		" %s %s ...\n", pcmcia_dev->prod_id[0], pcmcia_dev->prod_id[1]);
+
+	/* search pci cardbus bridge that contains the mmc controler */
+	/* the io region is already claimed by yenta_socket... */
+	while ((pci_dev =
+		pci_get_device(PCI_VENDOR_ID_RICOH, PCI_DEVICE_ID_RICOH_RL5C476,
+			       pci_dev))) {
+		/* try to init the device */
+		if (!sdricoh_init_mmc(pci_dev, pcmcia_dev)) {
+			dev_info(&pcmcia_dev->dev, "MMC controller found\n");
+			return 0;
+		}
+
+	}
+	dev_err(&pcmcia_dev->dev, "No MMC controller was found.\n");
+	return -ENODEV;
+}
+
+static void sdricoh_pcmcia_detach(struct pcmcia_device *link)
+{
+	struct mmc_host *mmc = link->priv;
+
+	dev_dbg(&link->dev, "detach\n");
+
+	/* remove mmc host */
+	if (mmc) {
+		struct sdricoh_host *host = mmc_priv(mmc);
+		mmc_remove_host(mmc);
+		pci_iounmap(host->pci_dev, host->iobase);
+		pci_dev_put(host->pci_dev);
+		mmc_free_host(mmc);
+	}
+	pcmcia_disable_device(link);
+
+}
+
+#ifdef CONFIG_PM
+static int sdricoh_pcmcia_suspend(struct pcmcia_device *link)
+{
+	struct mmc_host *mmc = link->priv;
+	dev_dbg(&link->dev, "suspend\n");
+	mmc_suspend_host(mmc, PMSG_SUSPEND);
+	return 0;
+}
+
+static int sdricoh_pcmcia_resume(struct pcmcia_device *link)
+{
+	struct mmc_host *mmc = link->priv;
+	dev_dbg(&link->dev, "resume\n");
+	sdricoh_reset(mmc_priv(mmc));
+	mmc_resume_host(mmc);
+	return 0;
+}
+#else
+#define sdricoh_pcmcia_suspend NULL
+#define sdricoh_pcmcia_resume NULL
+#endif
+
+static struct pcmcia_driver sdricoh_driver = {
+	.drv = {
+		.name = DRIVER_NAME,
+		},
+	.probe = sdricoh_pcmcia_probe,
+	.remove = sdricoh_pcmcia_detach,
+	.id_table = pcmcia_ids,
+	.suspend = sdricoh_pcmcia_suspend,
+	.resume = sdricoh_pcmcia_resume,
+};
+
+/*****************************************************************************\
+ *                                                                           *
+ * Driver init/exit                                                          *
+ *                                                                           *
+\*****************************************************************************/
+
+static int __init sdricoh_drv_init(void)
+{
+	return pcmcia_register_driver(&sdricoh_driver);
+}
+
+static void __exit sdricoh_drv_exit(void)
+{
+	pcmcia_unregister_driver(&sdricoh_driver);
+}
+
+module_init(sdricoh_drv_init);
+module_exit(sdricoh_drv_exit);
+
+module_param(switchlocked, uint, 0444);
+
+MODULE_AUTHOR("Sascha Sommer <saschasommer@freenet.de>");
+MODULE_DESCRIPTION("Ricoh PCMCIA Secure Digital Interface driver");
+MODULE_LICENSE("GPL");
+
+MODULE_PARM_DESC(switchlocked, "Switch the cards locked status."
+		"Use this when unlocked cards are shown readonly (default 0)");
