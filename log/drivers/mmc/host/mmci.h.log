commit 94b94a93e3554f291316263a91ada93390befa83
Author: Ludovic Barre <ludovic.barre@st.com>
Date:   Tue Jan 28 10:06:35 2020 +0100

    mmc: mmci_sdmmc: Implement signal voltage callbacks
    
    To prepare the voltage switch procedure, the VSWITCHEN bit must be set
    before sending the CMD11. To confirm completion of voltage switch, the
    VSWEND flag must be checked.
    
    Signed-off-by: Ludovic Barre <ludovic.barre@st.com>
    Link: https://lore.kernel.org/r/20200128090636.13689-9-ludovic.barre@st.com
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index c3bc0a38d4cb..e1a9b96a3396 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -165,6 +165,7 @@
 /* Extended status bits for the STM32 variants */
 #define MCI_STM32_BUSYD0	BIT(20)
 #define MCI_STM32_BUSYD0END	BIT(21)
+#define MCI_STM32_VSWEND	BIT(25)
 
 #define MMCICLEAR		0x038
 #define MCI_CMDCRCFAILCLR	(1 << 0)
@@ -182,6 +183,9 @@
 #define MCI_ST_SDIOITC		(1 << 22)
 #define MCI_ST_CEATAENDC	(1 << 23)
 #define MCI_ST_BUSYENDC		(1 << 24)
+/* Extended clear bits for the STM32 variants */
+#define MCI_STM32_VSWENDC	BIT(25)
+#define MCI_STM32_CKSTOPC	BIT(26)
 
 #define MMCIMASK0		0x03c
 #define MCI_CMDCRCFAILMASK	(1 << 0)

commit 7577316528816e8e9a49c1b4b5822bacbc62d113
Author: Ludovic Barre <ludovic.barre@st.com>
Date:   Tue Jan 28 10:06:34 2020 +0100

    mmc: mmci: Add callbacks for to manage signal voltage switch
    
    A variant may need to define some actions before and after a voltage
    switch.
    
    This patch adds 2 callbacks to manage signal voltage switch in the struct
    mmci_host_ops. ->pre_sig_volt_switch() allows to prepare a signal voltage
    switch before sending the SD_SWITCH_VOLTAGE command (CMD11).
    ->post_sig_volt_switch callback allows specific actions to be executed,
    after the I/O signal voltage level has been changed.
    
    Signed-off-by: Ludovic Barre <ludovic.barre@st.com>
    Link: https://lore.kernel.org/r/20200128090636.13689-8-ludovic.barre@st.com
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index ddcdfb827996..c3bc0a38d4cb 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -377,6 +377,8 @@ struct mmci_host_ops {
 	void (*set_clkreg)(struct mmci_host *host, unsigned int desired);
 	void (*set_pwrreg)(struct mmci_host *host, unsigned int pwr);
 	bool (*busy_complete)(struct mmci_host *host, u32 status, u32 err_msk);
+	void (*pre_sig_volt_switch)(struct mmci_host *host);
+	int (*post_sig_volt_switch)(struct mmci_host *host, struct mmc_ios *ios);
 };
 
 struct mmci_host {

commit 31b963e19491692e56da00b15fd29623f5c5d0cf
Author: Ludovic Barre <ludovic.barre@st.com>
Date:   Tue Jan 28 10:06:31 2020 +0100

    mmc: mmci: Add private pointer for variant
    
    In variant init function, some references may be allocated for variant
    specific usage. Add a private void* to mmci_host struct allows at variant
    functions to access on this references by mmci_host structure.
    
    Signed-off-by: Ludovic Barre <ludovic.barre@st.com>
    Link: https://lore.kernel.org/r/20200128090636.13689-5-ludovic.barre@st.com
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index 55acc0971a44..ddcdfb827996 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -410,6 +410,7 @@ struct mmci_host {
 	struct mmc_host_ops	*mmc_ops;
 	struct mmci_host_ops	*ops;
 	struct variant_data	*variant;
+	void			*variant_priv;
 	struct pinctrl		*pinctrl;
 	struct pinctrl_state	*pins_opendrain;
 

commit 7b9716a0f1610951f98caedac3542313a527db0e
Author: Ludovic Barre <ludovic.barre@st.com>
Date:   Tue Jan 28 10:06:30 2020 +0100

    mmc: mmci: Add a reference at mmc_host_ops in mmci struct
    
    The variant init function may need to add a mmc_host_ops, for example to
    add the execute_tuning support if this feature is available. This patch
    adds mmc_host_ops pointer in mmci struct.
    
    Signed-off-by: Ludovic Barre <ludovic.barre@st.com>
    Link: https://lore.kernel.org/r/20200128090636.13689-4-ludovic.barre@st.com
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index ea6a0b5779d4..55acc0971a44 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -407,6 +407,7 @@ struct mmci_host {
 	u32			mask1_reg;
 	u8			vqmmc_enabled:1;
 	struct mmci_platform_data *plat;
+	struct mmc_host_ops	*mmc_ops;
 	struct mmci_host_ops	*ops;
 	struct variant_data	*variant;
 	struct pinctrl		*pinctrl;

commit 2253ed4b36dc876d1598c4dab5587e537ec68c34
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Dec 17 15:39:52 2019 +0100

    mmc: mmci: Support any block sizes for ux500v2 and qcom variant
    
    For the ux500v2 variant of the PL18x block, any block sizes
    are supported. This is necessary to support some SDIO
    transfers. This also affects the QCOM MMCI variant and the
    ST micro variant.
    
    For Ux500 an additional quirk only allowing DMA on blocks
    that are a power of two is needed. This might be a bug in
    the DMA engine (DMA40) or the MMCI or in the interconnect,
    but the most likely is the MMCI, as transfers of these
    sizes work fine for other devices using the same DMA
    engine. DMA works fine also with SDIO as long as the
    blocksize is a power of 2.
    
    This patch has proven necessary for enabling SDIO for WLAN on
    PostmarketOS-based Ux500 platforms.
    
    What we managed to test in practice is Broadcom WiFi over
    SDIO on the Ux500 based Samsung GT-I8190 and GT-S7710.
    This WiFi chip, BCM4334 works fine after the patch.
    
    Before this patch:
    
    brcmfmac: brcmf_fw_alloc_request: using brcm/brcmfmac4334-sdio
              for chip BCM4334/3
    mmci-pl18x 80118000.sdi1_per2: unsupported block size (60 bytes)
    brcmfmac: brcmf_sdiod_ramrw: membytes transfer failed
    brcmfmac: brcmf_sdio_download_code_file: error -22 on writing
              434236 membytes at 0x00000000
    brcmfmac: brcmf_sdio_download_firmware: dongle image file download
              failed
    
    After this patch:
    
    brcmfmac: brcmf_c_preinit_dcmds: Firmware: BCM4334/3 wl0:
              Nov 21 2012 00:21:28 version 6.10.58.813 (B2) FWID 01-0
    
    Bringing up networks, discovering networks with "iw dev wlan0 scan"
    and connecting works fine from this point.
    
    This patch is inspired by Ulf Hansson's patch
    http://www.spinics.net/lists/linux-mmc/msg12160.html
    
    As the DMA engines on these platforms may now get block sizes
    they were not used to before, make sure to also respect if
    the DMA engine says "no" to a transfer.
    
    Make a drive-by fix for datactrl_blocksz, misspelled.
    
    Cc: Ludovic Barre <ludovic.barre@st.com>
    Cc: Brian Masney <masneyb@onstation.org>
    Cc: Stephan Gerhold <stephan@gerhold.net>
    Cc: Niklas Cassel <niklas.cassel@linaro.org>
    Cc: Russell King <rmk+kernel@armlinux.org.uk>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Tested-by: Stephan Gerhold <stephan@gerhold.net>
    Link: https://lore.kernel.org/r/20191217143952.2885-1-linus.walleij@linaro.org

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index be6cd1df2bf3..ea6a0b5779d4 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -279,7 +279,11 @@ struct mmci_host;
  * @stm32_clkdiv: true if using a STM32-specific clock divider algorithm
  * @datactrl_mask_ddrmode: ddr mode mask in datactrl register.
  * @datactrl_mask_sdio: SDIO enable mask in datactrl register
- * @datactrl_blksz: block size in power of two
+ * @datactrl_blocksz: block size in power of two
+ * @datactrl_any_blocksz: true if block any block sizes are accepted by
+ *		  hardware, such as with some SDIO traffic that send
+ *		  odd packets.
+ * @dma_power_of_2: DMA only works with blocks that are a power of 2.
  * @datactrl_first: true if data must be setup before send command
  * @datacnt_useless: true if you could not use datacnt register to read
  *		     remaining data
@@ -326,6 +330,8 @@ struct variant_data {
 	unsigned int		datactrl_mask_ddrmode;
 	unsigned int		datactrl_mask_sdio;
 	unsigned int		datactrl_blocksz;
+	u8			datactrl_any_blocksz:1;
+	u8			dma_power_of_2:1;
 	u8			datactrl_first:1;
 	u8			datacnt_useless:1;
 	u8			st_sdio:1;

commit ee157abebc0c8ddb1de9c7cb2b8d8a06c69ce17d
Author: Ludovic Barre <ludovic.barre@st.com>
Date:   Wed Dec 11 14:39:34 2019 +0100

    mmc: mmci: add threaded irq to abort DPSM of non-functional state
    
    The stm32_sdmmc variant has build-in support for datatimeout for R1B
    requests. If a corresponding IRQ is raised, this triggers the DPSM to stay
    busy and remains in a non-functional state. Only a reset can bring it back
    to a functional state.
    
    Because a reset must be issued from non-atomic context, let's defer this to
    be managed from a threaded IRQ handler. Besides the reset, the threaded
    handler also calls mmc_request_done(), to finally complete the request.
    
    Signed-off-by: Ludovic Barre <ludovic.barre@st.com>
    Link: https://lore.kernel.org/r/20191211133934.16932-1-ludovic.Barre@st.com
    [Ulf: A few minor updates to the changelog/comments]
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index 12d4ed8af88a..be6cd1df2bf3 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -411,6 +411,7 @@ struct mmci_host {
 
 	struct timer_list	timer;
 	unsigned int		oldstat;
+	u32			irq_action;
 
 	/* pio stuff */
 	struct sg_mapping_iter	sg_miter;

commit 05344ffe4b0d8fec55a722cc233348f95d689580
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri Dec 6 18:08:15 2019 +0100

    mmc: mmci: Convert to pinctrl_select_default_state()
    
    Let's drop the boilerplate code for managing the default pinctrl state and
    convert into using the new pinctrl_select_default_state().
    
    Additionally, move away from using pinctrl_pm_select_default_state() as
    it's scheduled for removal and use pinctrl_select_default_state() instead.
    
    Cc: Russell King <linux@armlinux.org.uk>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Link: https://lore.kernel.org/r/20191206170821.29711-4-ulf.hansson@linaro.org

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index 158e1231aa23..12d4ed8af88a 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -404,7 +404,6 @@ struct mmci_host {
 	struct mmci_host_ops	*ops;
 	struct variant_data	*variant;
 	struct pinctrl		*pinctrl;
-	struct pinctrl_state	*pins_default;
 	struct pinctrl_state	*pins_opendrain;
 
 	u8			hw_designer;

commit 0e68de6aa7b10eaaf8603d0e38aac62987f90682
Author: Ludovic Barre <ludovic.barre@st.com>
Date:   Tue Oct 8 11:56:04 2019 +0200

    mmc: mmci: sdmmc: add busy_complete callback
    
    This patch adds a specific busy_complete callback for sdmmc variant.
    
    sdmmc has 2 status flags:
    -busyd0: This is a hardware status flag (inverted value of d0 line).
    it does not generate an interrupt.
    -busyd0end: This indicates only end of busy following a CMD response.
    On busy to Not busy changes, an interrupt is generated (if unmask)
    and BUSYD0END status flag is set. Status flag is cleared by writing
    corresponding interrupt clear bit in MMCICLEAR.
    
    The legacy busy completion has no dedicated interrupt for the end
    of busy, so it's must monitor step by step the busy progression.
    On sdmmc variant, this procedure is not needed, it's just need
    to wait the busyd0end interrupt.
    
    Signed-off-by: Ludovic Barre <ludovic.barre@st.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index 2a0b98f98c36..158e1231aa23 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -164,6 +164,7 @@
 #define MCI_ST_CARDBUSY		(1 << 24)
 /* Extended status bits for the STM32 variants */
 #define MCI_STM32_BUSYD0	BIT(20)
+#define MCI_STM32_BUSYD0END	BIT(21)
 
 #define MMCICLEAR		0x038
 #define MCI_CMDCRCFAILCLR	(1 << 0)

commit cb0335b778c7c12a96c4360068ed344a79ea88a2
Author: Ludovic Barre <ludovic.barre@st.com>
Date:   Tue Oct 8 11:56:03 2019 +0200

    mmc: mmci: add busy_complete callback
    
    This patch adds busy_completion callback at mmci_host_ops
    to allow to define a specific busy completion by variant.
    
    The legacy code corresponding to busy completion used
    by ux500 variants is moved to ux500_busy_complete function.
    
    Signed-off-by: Ludovic Barre <ludovic.barre@st.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index d8b7f6774e8f..2a0b98f98c36 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -369,6 +369,7 @@ struct mmci_host_ops {
 	void (*dma_error)(struct mmci_host *host);
 	void (*set_clkreg)(struct mmci_host *host, unsigned int desired);
 	void (*set_pwrreg)(struct mmci_host *host, unsigned int pwr);
+	bool (*busy_complete)(struct mmci_host *host, u32 status, u32 err_msk);
 };
 
 struct mmci_host {

commit 8266c585f4897ceff0959bd64d196f164caa0601
Author: Ludovic Barre <ludovic.barre@st.com>
Date:   Tue Oct 8 11:56:02 2019 +0200

    mmc: mmci: add hardware busy timeout feature
    
    In the stm32_sdmmc variant, the datatimer is active not only during
    data transfers with the DPSM, but also while waiting for the busyend
    IRQs from commands having the MMC_RSP_BUSY flag set. This leads to an
    incorrect IRQ being raised to signal MCI_DATATIMEOUT error, which
    simply breaks the behaviour.
    
    Address this by updating the datatimer value before sending a command
    having the MMC_RSP_BUSY flag set. To inform the mmc core about the
    maximum supported busy timeout, which also depends on the current
    clock rate, set ->max_busy_timeout (in ms).
    
    Signed-off-by: Ludovic Barre <ludovic.barre@st.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index 833236ecb31e..d8b7f6774e8f 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -287,6 +287,8 @@ struct mmci_host;
  * @signal_direction: input/out direction of bus signals can be indicated
  * @pwrreg_clkgate: MMCIPOWER register must be used to gate the clock
  * @busy_detect: true if the variant supports busy detection on DAT0.
+ * @busy_timeout: true if the variant starts data timer when the DPSM
+ *		  enter in Wait_R or Busy state.
  * @busy_dpsm_flag: bitmask enabling busy detection in the DPSM
  * @busy_detect_flag: bitmask identifying the bit in the MMCISTATUS register
  *		      indicating that the card is busy
@@ -333,6 +335,7 @@ struct variant_data {
 	u8			signal_direction:1;
 	u8			pwrreg_clkgate:1;
 	u8			busy_detect:1;
+	u8			busy_timeout:1;
 	u32			busy_dpsm_flag;
 	u32			busy_detect_flag;
 	u32			busy_detect_mask;

commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index 4f071bd34e59..833236ecb31e 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -1,11 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  *  linux/drivers/mmc/host/mmci.h - ARM PrimeCell MMCI PL180/1 driver
  *
  *  Copyright (C) 2003 Deep Blue Solutions, Ltd, All Rights Reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 #define MMCIPOWER		0x000
 #define MCI_PWR_OFF		0x00

commit 41ed65e7ce8462cb80063b6dcc3150a252ccaac5
Author: Ludovic Barre <ludovic.barre@st.com>
Date:   Wed Mar 27 10:05:32 2019 +0100

    mmc: mmci: replace blksz_datactrlXX by get_datactrl_cfg callback
    
    This patch allows to get datactrl configuration specific
    at variant. This introduce more flexibility on datactlr
    value.
    
    Signed-off-by: Ludovic Barre <ludovic.barre@st.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index 82e9f94e3a16..4f071bd34e59 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -280,12 +280,8 @@ struct mmci_host;
  * @st_clkdiv: true if using a ST-specific clock divider algorithm
  * @stm32_clkdiv: true if using a STM32-specific clock divider algorithm
  * @datactrl_mask_ddrmode: ddr mode mask in datactrl register.
- * @blksz_datactrl16: true if Block size is at b16..b30 position in datactrl register
- * @blksz_datactrl4: true if Block size is at b4..b16 position in datactrl
- *		     register
  * @datactrl_mask_sdio: SDIO enable mask in datactrl register
  * @datactrl_blksz: block size in power of two
- * @datactrl_dpsm_enable: enable value for DPSM
  * @datactrl_first: true if data must be setup before send command
  * @datacnt_useless: true if you could not use datacnt register to read
  *		     remaining data
@@ -330,14 +326,11 @@ struct variant_data {
 	unsigned int		datactrl_mask_ddrmode;
 	unsigned int		datactrl_mask_sdio;
 	unsigned int		datactrl_blocksz;
-	unsigned int		datactrl_dpsm_enable;
 	u8			datactrl_first:1;
 	u8			datacnt_useless:1;
 	u8			st_sdio:1;
 	u8			st_clkdiv:1;
 	u8			stm32_clkdiv:1;
-	u8			blksz_datactrl16:1;
-	u8			blksz_datactrl4:1;
 	u32			pwrreg_powerup;
 	u32			f_max;
 	u8			signal_direction:1;

commit 8372f9d0ef0b9276439f4ff35dc4263bcddf1408
Author: Ludovic Barre <ludovic.barre@st.com>
Date:   Wed Mar 27 10:05:31 2019 +0100

    mmc: mmci: stm32: define get_dctrl_cfg
    
    This patch defines get_dctrl_cfg callback for sdmmc variant.
    sdmmc variant has specific stm32 transfer modes.
    sdmmc data transfer mode selection could be:
    -Block data transfer ending on block count.
    -SDIO multibyte data transfer.
    -MMC Stream data transfer (not used).
    -Block data transfer ending with STOP_TRANSMISSION command.
    
    Signed-off-by: Ludovic Barre <ludovic.barre@st.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index 35c91d0059b9..82e9f94e3a16 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -131,6 +131,11 @@
 /* Control register extensions in the Qualcomm versions */
 #define MCI_DPSM_QCOM_DATA_PEND	BIT(17)
 #define MCI_DPSM_QCOM_RX_DATA_PEND BIT(20)
+/* Control register extensions in STM32 versions */
+#define MCI_DPSM_STM32_MODE_BLOCK	(0 << 2)
+#define MCI_DPSM_STM32_MODE_SDIO	(1 << 2)
+#define MCI_DPSM_STM32_MODE_STREAM	(2 << 2)
+#define MCI_DPSM_STM32_MODE_BLOCK_STOP	(3 << 2)
 
 #define MMCIDATACNT		0x030
 #define MMCISTATUS		0x034

commit 0732ea75de09f0816f0604e46116ca111bc309d6
Author: Ludovic Barre <ludovic.barre@st.com>
Date:   Wed Mar 27 10:05:28 2019 +0100

    mmc: mmci: add get_datactrl_cfg callback and helper functions
    
    This patch adds get_datactrl_cfg callback in mmci_host_ops
    to allow to get datactrl configuration specific at variant.
    Common helper function is defined and could be call by variant.
    
    Signed-off-by: Ludovic Barre <ludovic.barre@st.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index 6bde28c9b302..35c91d0059b9 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -362,6 +362,7 @@ struct mmci_host_ops {
 			 bool next);
 	void (*unprep_data)(struct mmci_host *host, struct mmc_data *data,
 			    int err);
+	u32 (*get_datactrl_cfg)(struct mmci_host *host);
 	void (*get_next_data)(struct mmci_host *host, struct mmc_data *data);
 	int (*dma_setup)(struct mmci_host *host);
 	void (*dma_release)(struct mmci_host *host);
@@ -429,6 +430,11 @@ struct mmci_host {
 void mmci_write_clkreg(struct mmci_host *host, u32 clk);
 void mmci_write_pwrreg(struct mmci_host *host, u32 pwr);
 
+static inline u32 mmci_dctrl_blksz(struct mmci_host *host)
+{
+	return (ffs(host->data->blksz) - 1) << 4;
+}
+
 #ifdef CONFIG_DMA_ENGINE
 int mmci_dmae_prep_data(struct mmci_host *host, struct mmc_data *data,
 			bool next);

commit 62e546be6d9320773f5162c0a4a627392efdb6ea
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Wed Mar 6 15:04:55 2019 +0100

    mmc: mmci: Share sdmmc_variant_init() via the common header file
    
    It's good practice to share functions via header files, rather than from
    the c-files. Therefore, let's move sdmmc_variant_init() to mmci.h.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Ludovic Barre <ludovic.barre@st.com>
    Tested-by: Ludovic Barre <ludovic.barre@st.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index a76fe1085757..6bde28c9b302 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -447,3 +447,9 @@ void qcom_variant_init(struct mmci_host *host);
 #else
 static inline void qcom_variant_init(struct mmci_host *host) {}
 #endif
+
+#ifdef CONFIG_MMC_STM32_SDMMC
+void sdmmc_variant_init(struct mmci_host *host);
+#else
+static inline void sdmmc_variant_init(struct mmci_host *host) {}
+#endif

commit f7f3e7dac802e4ed11f216027fc35c189c3dba7f
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Wed Mar 6 15:04:54 2019 +0100

    mmc: mmci: Drop qcom specific header file
    
    It seems a bit silly to have a header file to share only the
    qcom_variant_init() function. So, let's just drop it and move the
    declaration of the function into the common mmci.h instead.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index b368ed3acc29..a76fe1085757 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -441,3 +441,9 @@ int mmci_dmae_start(struct mmci_host *host, unsigned int *datactrl);
 void mmci_dmae_finalize(struct mmci_host *host, struct mmc_data *data);
 void mmci_dmae_error(struct mmci_host *host);
 #endif
+
+#ifdef CONFIG_MMC_QCOM_DML
+void qcom_variant_init(struct mmci_host *host);
+#else
+static inline void qcom_variant_init(struct mmci_host *host) {}
+#endif

commit 6aa35ce74399f70b88e4c0e17c486da8ad6ef33d
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Wed Mar 6 15:04:51 2019 +0100

    mmc: mmci: Don't share un-implemented DMA functions
    
    Some of the DMA functions are shared via mmci.h, however they are not
    implemented unless CONFIG_DMA_ENGINE is set. Therefore, add that constraint
    to the header file as well.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index 14df81054438..b368ed3acc29 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -429,6 +429,7 @@ struct mmci_host {
 void mmci_write_clkreg(struct mmci_host *host, u32 clk);
 void mmci_write_pwrreg(struct mmci_host *host, u32 pwr);
 
+#ifdef CONFIG_DMA_ENGINE
 int mmci_dmae_prep_data(struct mmci_host *host, struct mmc_data *data,
 			bool next);
 void mmci_dmae_unprep_data(struct mmci_host *host, struct mmc_data *data,
@@ -439,3 +440,4 @@ void mmci_dmae_release(struct mmci_host *host);
 int mmci_dmae_start(struct mmci_host *host, unsigned int *datactrl);
 void mmci_dmae_finalize(struct mmci_host *host, struct mmc_data *data);
 void mmci_dmae_error(struct mmci_host *host);
+#endif

commit e9968c6fa8e7852184135e84116c6c77ebb2987d
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Tue Jan 29 15:35:56 2019 +0100

    mmc: mmci: Send a CMD12 to clear the DPSM at errors
    
    The current approach with sending a CMD12 (STOP_TRANSMISSION) to complete a
    data transfer request, either because of using the open-ended transmission
    type or because of receiving an error during a pre-defined data transfer,
    isn't sufficient for the STM32 sdmmc variant. More precisely, this variant
    needs to clear the DPSM ("Data Path State Machine") by sending a CMD12, for
    all failing ADTC commands.
    
    Support this, by adding a struct mmc_command inside the struct mmci_host
    and initialize it to a CMD12 during ->probe(). Let's also add checks for
    the new conditions, to enable mmci_data_irq() and mmci_cmd_irq() to
    postpone the calls to mmci_request_end(), but instead send the CMD12.
    
    Cc: Ludovic Barre <ludovic.barre@st.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Tested-by: Ludovic Barre <ludovic.barre@st.com>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index 24229097d05c..14df81054438 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -377,6 +377,7 @@ struct mmci_host {
 	void __iomem		*base;
 	struct mmc_request	*mrq;
 	struct mmc_command	*cmd;
+	struct mmc_command	stop_abort;
 	struct mmc_data		*data;
 	struct mmc_host		*mmc;
 	struct clk		*clk;

commit c8073e52851477514e98a032ae70f2dc8be19d32
Author: Ludovic Barre <ludovic.barre@st.com>
Date:   Thu Dec 6 16:13:31 2018 +0100

    mmc: mmci: add variant property to set command stop bit
    
    On cmd12 (STOP_TRANSMISSION), STM32 sdmmc variant needs to set
    cmdstop bit in command register. The CPSM ("Command Path State Machine")
    treats the command as a Stop Transmission command and signals
    abort to the DPSM ("Data Path State Machine").
    
    Signed-off-by: Ludovic Barre <ludovic.barre@st.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index 550dd3914461..24229097d05c 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -264,6 +264,7 @@ struct mmci_host;
  * @cmdreg_lrsp_crc: enable value for long response with crc
  * @cmdreg_srsp_crc: enable value for short response with crc
  * @cmdreg_srsp: enable value for short response without crc
+ * @cmdreg_stop: enable value for stop and abort transmission
  * @datalength_bits: number of bits in the MMCIDATALENGTH register
  * @fifosize: number of bytes that can be written when MMCI_TXFIFOEMPTY
  *	      is asserted (likewise for RX)
@@ -316,6 +317,7 @@ struct variant_data {
 	unsigned int		cmdreg_lrsp_crc;
 	unsigned int		cmdreg_srsp_crc;
 	unsigned int		cmdreg_srsp;
+	unsigned int		cmdreg_stop;
 	unsigned int		datalength_bits;
 	unsigned int		fifosize;
 	unsigned int		fifohalfsize;

commit 46b723dd867d599420fb640c0eaf2a866ef721d4
Author: Ludovic Barre <ludovic.barre@st.com>
Date:   Mon Oct 8 14:08:55 2018 +0200

    mmc: mmci: add stm32 sdmmc variant
    
    This patch adds a stm32 sdmmc variant, rev 1.1.
    Introduces a new Manufacturer id "0x53, ascii 'S' to define
    new stm32 sdmmc family with clean range of amba
    revision/configurations bits (corresponding to sdmmc_ver
    register with major/minor fields).
    Add 2 variants properties:
    -dma_lli, to enable link list support.
    -stm32_idmabsize_mask, defines the range of SDMMC_IDMABSIZER register
     which specify the number bytes per buffer.
    
    DT properties for sdmmc:
    -Indicate signal directions (only one property
     for d0dir, d123dir, cmd_dir)
    -Select command and data phase relation.
    -Select "clock in" from an external driver.
    
    Signed-off-by: Ludovic Barre <ludovic.barre@st.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index e242f44de78a..550dd3914461 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -304,6 +304,8 @@ struct mmci_host;
  * @start_err: bitmask identifying the STARTBITERR bit inside MMCISTATUS
  *	       register.
  * @opendrain: bitmask identifying the OPENDRAIN bit inside MMCIPOWER register
+ * @dma_lli: true if variant has dma link list feature.
+ * @stm32_idmabsize_mask: stm32 sdmmc idma buffer size.
  */
 struct variant_data {
 	unsigned int		clkreg;
@@ -346,6 +348,8 @@ struct variant_data {
 	unsigned int		irq_pio_mask;
 	u32			start_err;
 	u32			opendrain;
+	u8			dma_lli:1;
+	u32			stm32_idmabsize_mask;
 	void (*init)(struct mmci_host *host);
 };
 
@@ -387,6 +391,7 @@ struct mmci_host {
 	u32			pwr_reg;
 	u32			pwr_reg_add;
 	u32			clk_reg;
+	u32			clk_reg_add;
 	u32			datactrl_reg;
 	u32			busy_status;
 	u32			mask1_reg;

commit f3f6433468bd206bafd853f0a5b99e259d620e67
Author: Ludovic Barre <ludovic.barre@st.com>
Date:   Mon Oct 8 14:08:53 2018 +0200

    mmc: mmci: add stm32 sdmmc registers
    
    This patch adds stm32 sdmmc specific registers.
    
    Signed-off-by: Ludovic Barre <ludovic.barre@st.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index a962cfa339a3..e242f44de78a 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -23,6 +23,14 @@
 #define MCI_ST_DATA31DIREN	(1 << 5)
 #define MCI_ST_FBCLKEN		(1 << 7)
 #define MCI_ST_DATA74DIREN	(1 << 8)
+/*
+ * The STM32 sdmmc does not have PWR_UP/OD/ROD
+ * and uses the power register for
+ */
+#define MCI_STM32_PWR_CYC	0x02
+#define MCI_STM32_VSWITCH	BIT(2)
+#define MCI_STM32_VSWITCHEN	BIT(3)
+#define MCI_STM32_DIRPOL	BIT(4)
 
 #define MMCICLOCK		0x004
 #define MCI_CLK_ENABLE		(1 << 8)
@@ -50,6 +58,19 @@
 #define MCI_QCOM_CLK_SELECT_IN_FBCLK	BIT(15)
 #define MCI_QCOM_CLK_SELECT_IN_DDR_MODE	(BIT(14) | BIT(15))
 
+/* Modified on STM32 sdmmc */
+#define MCI_STM32_CLK_CLKDIV_MSK	GENMASK(9, 0)
+#define MCI_STM32_CLK_WIDEBUS_4		BIT(14)
+#define MCI_STM32_CLK_WIDEBUS_8		BIT(15)
+#define MCI_STM32_CLK_NEGEDGE		BIT(16)
+#define MCI_STM32_CLK_HWFCEN		BIT(17)
+#define MCI_STM32_CLK_DDR		BIT(18)
+#define MCI_STM32_CLK_BUSSPEED		BIT(19)
+#define MCI_STM32_CLK_SEL_MSK		GENMASK(21, 20)
+#define MCI_STM32_CLK_SELCK		(0 << 20)
+#define MCI_STM32_CLK_SELCKIN		(1 << 20)
+#define MCI_STM32_CLK_SELFBCK		(2 << 20)
+
 #define MMCIARGUMENT		0x008
 
 /* The command register controls the Command Path State Machine (CPSM) */
@@ -72,6 +93,15 @@
 #define MCI_CPSM_QCOM_CCSDISABLE	BIT(15)
 #define MCI_CPSM_QCOM_AUTO_CMD19	BIT(16)
 #define MCI_CPSM_QCOM_AUTO_CMD21	BIT(21)
+/* Command register in STM32 sdmmc versions */
+#define MCI_CPSM_STM32_CMDTRANS		BIT(6)
+#define MCI_CPSM_STM32_CMDSTOP		BIT(7)
+#define MCI_CPSM_STM32_WAITRESP_MASK	GENMASK(9, 8)
+#define MCI_CPSM_STM32_NORSP		(0 << 8)
+#define MCI_CPSM_STM32_SRSP_CRC		(1 << 8)
+#define MCI_CPSM_STM32_SRSP		(2 << 8)
+#define MCI_CPSM_STM32_LRSP_CRC		(3 << 8)
+#define MCI_CPSM_STM32_ENABLE		BIT(12)
 
 #define MMCIRESPCMD		0x010
 #define MMCIRESPONSE0		0x014
@@ -130,6 +160,8 @@
 #define MCI_ST_SDIOIT		(1 << 22)
 #define MCI_ST_CEATAEND		(1 << 23)
 #define MCI_ST_CARDBUSY		(1 << 24)
+/* Extended status bits for the STM32 variants */
+#define MCI_STM32_BUSYD0	BIT(20)
 
 #define MMCICLEAR		0x038
 #define MCI_CMDCRCFAILCLR	(1 << 0)
@@ -175,11 +207,32 @@
 #define MCI_ST_SDIOITMASK	(1 << 22)
 #define MCI_ST_CEATAENDMASK	(1 << 23)
 #define MCI_ST_BUSYENDMASK	(1 << 24)
+/* Extended status bits for the STM32 variants */
+#define MCI_STM32_BUSYD0ENDMASK	BIT(21)
 
 #define MMCIMASK1		0x040
 #define MMCIFIFOCNT		0x048
 #define MMCIFIFO		0x080 /* to 0x0bc */
 
+/* STM32 sdmmc registers for IDMA (Internal DMA) */
+#define MMCI_STM32_IDMACTRLR	0x050
+#define MMCI_STM32_IDMAEN	BIT(0)
+#define MMCI_STM32_IDMALLIEN	BIT(1)
+
+#define MMCI_STM32_IDMABSIZER		0x054
+#define MMCI_STM32_IDMABNDT_SHIFT	5
+#define MMCI_STM32_IDMABNDT_MASK	GENMASK(12, 5)
+
+#define MMCI_STM32_IDMABASE0R	0x058
+
+#define MMCI_STM32_IDMALAR	0x64
+#define MMCI_STM32_IDMALA_MASK	GENMASK(13, 0)
+#define MMCI_STM32_ABR		BIT(29)
+#define MMCI_STM32_ULS		BIT(30)
+#define MMCI_STM32_ULA		BIT(31)
+
+#define MMCI_STM32_IDMABAR	0x68
+
 #define MCI_IRQENABLE	\
 	(MCI_CMDCRCFAILMASK | MCI_DATACRCFAILMASK | MCI_CMDTIMEOUTMASK | \
 	MCI_DATATIMEOUTMASK | MCI_TXUNDERRUNMASK | MCI_RXOVERRUNMASK |	\
@@ -190,6 +243,9 @@
 	(MCI_RXFIFOHALFFULLMASK | MCI_RXDATAAVLBLMASK | \
 	 MCI_TXFIFOHALFEMPTYMASK)
 
+#define MCI_IRQ_PIO_STM32_MASK \
+	(MCI_RXFIFOHALFFULLMASK | MCI_TXFIFOHALFEMPTYMASK)
+
 #define NR_SG		128
 
 #define MMCI_PINCTRL_STATE_OPENDRAIN "opendrain"

commit 00e930d87d196ae70e225eee88957441c10ff872
Author: Ludovic Barre <ludovic.barre@st.com>
Date:   Mon Oct 8 14:08:52 2018 +0200

    mmc: mmci: add clock divider for stm32 sdmmc
    
    The STM32 sdmmc variant has a different clock divider.
    
    Signed-off-by: Ludovic Barre <ludovic.barre@st.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index 8ecb1eee001e..a962cfa339a3 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -216,6 +216,7 @@ struct mmci_host;
  * @data_cmd_enable: enable value for data commands.
  * @st_sdio: enable ST specific SDIO logic
  * @st_clkdiv: true if using a ST-specific clock divider algorithm
+ * @stm32_clkdiv: true if using a STM32-specific clock divider algorithm
  * @datactrl_mask_ddrmode: ddr mode mask in datactrl register.
  * @blksz_datactrl16: true if Block size is at b16..b30 position in datactrl register
  * @blksz_datactrl4: true if Block size is at b4..b16 position in datactrl
@@ -269,6 +270,7 @@ struct variant_data {
 	u8			datacnt_useless:1;
 	u8			st_sdio:1;
 	u8			st_clkdiv:1;
+	u8			stm32_clkdiv:1;
 	u8			blksz_datactrl16:1;
 	u8			blksz_datactrl4:1;
 	u32			pwrreg_powerup;

commit 15878e58461bbb4def541b72b835be410e1a9cf4
Author: Ludovic Barre <ludovic.barre@st.com>
Date:   Mon Oct 8 14:08:51 2018 +0200

    mmc: mmci: add optional reset property
    
    This patch adds a optional reset management.
    STM32 sdmmc variant needs to reset hardware block
    during the power cycle procedure (for re-initialization).
    
    Signed-off-by: Ludovic Barre <ludovic.barre@st.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index cdcadd29a10d..8ecb1eee001e 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -318,6 +318,8 @@ struct mmci_host {
 	struct clk		*clk;
 	u8			singleirq:1;
 
+	struct reset_control	*rst;
+
 	spinlock_t		lock;
 
 	unsigned int		mclk;

commit b79220b3e0af5037b2ae90a5d2c32bc1a1e627fb
Author: Ludovic Barre <ludovic.barre@st.com>
Date:   Mon Oct 8 14:08:49 2018 +0200

    mmc: mmci: add variant property to not read datacnt
    
    This patch adds a boolean property to not read datacnt register.
    Needed to support the STM32 sdmmc variant. MMCIDATACNT
    register should be read only after the data transfer is completed.
    When reading after an error event the read data count value may be
    different from the real number of data bytes transferred.
    
    Signed-off-by: Ludovic Barre <ludovic.barre@st.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index eef7dd5be01d..cdcadd29a10d 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -224,6 +224,8 @@ struct mmci_host;
  * @datactrl_blksz: block size in power of two
  * @datactrl_dpsm_enable: enable value for DPSM
  * @datactrl_first: true if data must be setup before send command
+ * @datacnt_useless: true if you could not use datacnt register to read
+ *		     remaining data
  * @pwrreg_powerup: power up value for MMCIPOWER register
  * @f_max: maximum clk frequency supported by the controller.
  * @signal_direction: input/out direction of bus signals can be indicated
@@ -264,6 +266,7 @@ struct variant_data {
 	unsigned int		datactrl_blocksz;
 	unsigned int		datactrl_dpsm_enable;
 	u8			datactrl_first:1;
+	u8			datacnt_useless:1;
 	u8			st_sdio:1;
 	u8			st_clkdiv:1;
 	u8			blksz_datactrl16:1;

commit d2141547f594d396f85010ba0b37d0e9491943b6
Author: Ludovic Barre <ludovic.barre@st.com>
Date:   Mon Oct 8 14:08:48 2018 +0200

    mmc: mmci: add variant property to write datactrl before command
    
    This patch adds a boolean property to allow to write datactrl
    before to send command, whatever the command type (read or write).
    Needed to support the STM32 sdmmc variant.
    
    Signed-off-by: Ludovic Barre <ludovic.barre@st.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index 783a7ada4d69..eef7dd5be01d 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -223,6 +223,7 @@ struct mmci_host;
  * @datactrl_mask_sdio: SDIO enable mask in datactrl register
  * @datactrl_blksz: block size in power of two
  * @datactrl_dpsm_enable: enable value for DPSM
+ * @datactrl_first: true if data must be setup before send command
  * @pwrreg_powerup: power up value for MMCIPOWER register
  * @f_max: maximum clk frequency supported by the controller.
  * @signal_direction: input/out direction of bus signals can be indicated
@@ -262,6 +263,7 @@ struct variant_data {
 	unsigned int		datactrl_mask_sdio;
 	unsigned int		datactrl_blocksz;
 	unsigned int		datactrl_dpsm_enable;
+	u8			datactrl_first:1;
 	u8			st_sdio:1;
 	u8			st_clkdiv:1;
 	u8			blksz_datactrl16:1;

commit 59db5e2d7f9d85ac7d62c1a67d18dc1993c935bd
Author: Ludovic Barre <ludovic.barre@st.com>
Date:   Mon Oct 8 14:08:47 2018 +0200

    mmc: mmci: add variant property to define irq pio mask
    
    This patch allows to define specific pio mask for variants.
    Needed to support the STM32 sdmmc variant which has some bits
    with different meaning (bits: 21,20,13,12,9)
    
    Signed-off-by: Ludovic Barre <ludovic.barre@st.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index 04d021e83dd0..783a7ada4d69 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -186,7 +186,7 @@
 	MCI_CMDRESPENDMASK | MCI_CMDSENTMASK)
 
 /* These interrupts are directed to IRQ1 when two IRQ lines are available */
-#define MCI_IRQ1MASK \
+#define MCI_IRQ_PIO_MASK \
 	(MCI_RXFIFOHALFFULLMASK | MCI_RXDATAAVLBLMASK | \
 	 MCI_TXFIFOHALFEMPTYMASK)
 
@@ -239,6 +239,8 @@ struct mmci_host;
  * @qcom_dml: enables qcom specific dma glue for dma transfers.
  * @reversed_irq_handling: handle data irq before cmd irq.
  * @mmcimask1: true if variant have a MMCIMASK1 register.
+ * @irq_pio_mask: bitmask used to manage interrupt pio transfert in mmcimask
+ *		  register
  * @start_err: bitmask identifying the STARTBITERR bit inside MMCISTATUS
  *	       register.
  * @opendrain: bitmask identifying the OPENDRAIN bit inside MMCIPOWER register
@@ -278,6 +280,7 @@ struct variant_data {
 	u8			qcom_dml:1;
 	u8			reversed_irq_handling:1;
 	u8			mmcimask1:1;
+	unsigned int		irq_pio_mask;
 	u32			start_err;
 	u32			opendrain;
 	void (*init)(struct mmci_host *host);

commit 9b279941244ce4eaa76d079314e9c174c80fabc3
Author: Ludovic Barre <ludovic.barre@st.com>
Date:   Mon Oct 8 14:08:46 2018 +0200

    mmc: mmci: add variant property to define dpsm bit
    
    This patch adds datactrl variant property to define
    dpsm enable bit. Needed to support the STM32 variant
    (STM32 has no dpsm enable bit).
    
    Signed-off-by: Ludovic Barre <ludovic.barre@st.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index 531c247e37be..04d021e83dd0 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -222,6 +222,7 @@ struct mmci_host;
  *		     register
  * @datactrl_mask_sdio: SDIO enable mask in datactrl register
  * @datactrl_blksz: block size in power of two
+ * @datactrl_dpsm_enable: enable value for DPSM
  * @pwrreg_powerup: power up value for MMCIPOWER register
  * @f_max: maximum clk frequency supported by the controller.
  * @signal_direction: input/out direction of bus signals can be indicated
@@ -258,6 +259,7 @@ struct variant_data {
 	unsigned int		datactrl_mask_ddrmode;
 	unsigned int		datactrl_mask_sdio;
 	unsigned int		datactrl_blocksz;
+	unsigned int		datactrl_dpsm_enable;
 	u8			st_sdio:1;
 	u8			st_clkdiv:1;
 	u8			blksz_datactrl16:1;

commit 0f2448043eab644a939fc206e93032225d3ab6ce
Author: Ludovic Barre <ludovic.barre@st.com>
Date:   Mon Oct 8 14:08:45 2018 +0200

    mmc: mmci: add variant properties to define cpsm & cmdresp bits
    
    This patch adds command variant properties to define
    cpsm enable bit and responses.
    Needed to support the STM32 variant (shift of cpsm bit,
    specific definition of commands response).
    
    Signed-off-by: Ludovic Barre <ludovic.barre@st.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index 8e7ea44dafb1..531c247e37be 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -204,6 +204,10 @@ struct mmci_host;
  * @clkreg_enable: enable value for MMCICLOCK register
  * @clkreg_8bit_bus_enable: enable value for 8 bit bus
  * @clkreg_neg_edge_enable: enable value for inverted data/cmd output
+ * @cmdreg_cpsm_enable: enable value for CPSM
+ * @cmdreg_lrsp_crc: enable value for long response with crc
+ * @cmdreg_srsp_crc: enable value for short response with crc
+ * @cmdreg_srsp: enable value for short response without crc
  * @datalength_bits: number of bits in the MMCIDATALENGTH register
  * @fifosize: number of bytes that can be written when MMCI_TXFIFOEMPTY
  *	      is asserted (likewise for RX)
@@ -243,6 +247,10 @@ struct variant_data {
 	unsigned int		clkreg_enable;
 	unsigned int		clkreg_8bit_bus_enable;
 	unsigned int		clkreg_neg_edge_enable;
+	unsigned int		cmdreg_cpsm_enable;
+	unsigned int		cmdreg_lrsp_crc;
+	unsigned int		cmdreg_srsp_crc;
+	unsigned int		cmdreg_srsp;
 	unsigned int		datalength_bits;
 	unsigned int		fifosize;
 	unsigned int		fifohalfsize;

commit daf9713c5ef8c3ffb0bdf7de11b53b2b2756c4f1
Author: Ludovic Barre <ludovic.barre@st.com>
Date:   Mon Oct 8 14:08:44 2018 +0200

    mmc: mmci: expand startbiterr to irqmask and error check
    
    All variants don't pretend to have a startbiterr.
    -While data error check, if status register return an error
    (like  MCI_DATACRCFAIL) we must avoid to check MCI_STARTBITERR
    (if not desired).
    -expand start_err to MCI_IRQENABLE to avoid to set this bit by default.
    
    Signed-off-by: Ludovic Barre <ludovic.barre@st.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index d5979e82db49..8e7ea44dafb1 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -181,9 +181,9 @@
 #define MMCIFIFO		0x080 /* to 0x0bc */
 
 #define MCI_IRQENABLE	\
-	(MCI_CMDCRCFAILMASK|MCI_DATACRCFAILMASK|MCI_CMDTIMEOUTMASK|	\
-	MCI_DATATIMEOUTMASK|MCI_TXUNDERRUNMASK|MCI_RXOVERRUNMASK|	\
-	MCI_CMDRESPENDMASK|MCI_CMDSENTMASK|MCI_STARTBITERRMASK)
+	(MCI_CMDCRCFAILMASK | MCI_DATACRCFAILMASK | MCI_CMDTIMEOUTMASK | \
+	MCI_DATATIMEOUTMASK | MCI_TXUNDERRUNMASK | MCI_RXOVERRUNMASK |	\
+	MCI_CMDRESPENDMASK | MCI_CMDSENTMASK)
 
 /* These interrupts are directed to IRQ1 when two IRQ lines are available */
 #define MCI_IRQ1MASK \

commit c931d495cd3d5f01eba5da958207d37c63edbf10
Author: Ludovic Barre <ludovic.barre@st.com>
Date:   Mon Oct 8 14:08:43 2018 +0200

    mmc: mmci: add datactrl block size variant property
    
    This patch allows to define a datactrl block size
    by variant, requested by STM32 sdmmc variant.
    
    Signed-off-by: Ludovic Barre <ludovic.barre@st.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index dbb5ad47c16a..d5979e82db49 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -217,6 +217,7 @@ struct mmci_host;
  * @blksz_datactrl4: true if Block size is at b4..b16 position in datactrl
  *		     register
  * @datactrl_mask_sdio: SDIO enable mask in datactrl register
+ * @datactrl_blksz: block size in power of two
  * @pwrreg_powerup: power up value for MMCIPOWER register
  * @f_max: maximum clk frequency supported by the controller.
  * @signal_direction: input/out direction of bus signals can be indicated
@@ -248,6 +249,7 @@ struct variant_data {
 	unsigned int		data_cmd_enable;
 	unsigned int		datactrl_mask_ddrmode;
 	unsigned int		datactrl_mask_sdio;
+	unsigned int		datactrl_blocksz;
 	u8			st_sdio:1;
 	u8			st_clkdiv:1;
 	u8			blksz_datactrl16:1;

commit cd3ee8c532ad05dac71681e0ecfa91606d0e145e
Author: Ludovic Barre <ludovic.barre@st.com>
Date:   Mon Oct 8 14:08:42 2018 +0200

    mmc: mmci: add set_clk/pwrreg callbacks
    
    This patch adds set_clkreg and set_pwrreg callbacks
    at mmci_host_ops to allow to call specific variant.
    extends visibility of mmci_write_clk/pwrreg functions
    to be used into specific file variant.
    
    Signed-off-by: Ludovic Barre <ludovic.barre@st.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index ed59baf37f0f..dbb5ad47c16a 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -284,6 +284,8 @@ struct mmci_host_ops {
 	int (*dma_start)(struct mmci_host *host, unsigned int *datactrl);
 	void (*dma_finalize)(struct mmci_host *host, struct mmc_data *data);
 	void (*dma_error)(struct mmci_host *host);
+	void (*set_clkreg)(struct mmci_host *host, unsigned int desired);
+	void (*set_pwrreg)(struct mmci_host *host, unsigned int pwr);
 };
 
 struct mmci_host {
@@ -336,6 +338,9 @@ struct mmci_host {
 
 #define dma_inprogress(host)	((host)->dma_in_progress)
 
+void mmci_write_clkreg(struct mmci_host *host, u32 clk);
+void mmci_write_pwrreg(struct mmci_host *host, u32 pwr);
+
 int mmci_dmae_prep_data(struct mmci_host *host, struct mmc_data *data,
 			bool next);
 void mmci_dmae_unprep_data(struct mmci_host *host, struct mmc_data *data,

commit e0da1721211b9016be1a1d994d97eb53c3ca29fe
Author: Ludovic Barre <ludovic.barre@st.com>
Date:   Mon Oct 8 14:08:41 2018 +0200

    mmc: mmci: add validate_data callback
    
    This patch adds validate_data callback at mmci_host_ops
    to check specific constraints of variant.
    Move mmci_validate_data function to regroup mmci_host_ops interfaces.
    
    Signed-off-by: Ludovic Barre <ludovic.barre@st.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index bcf3e8b901d7..ed59baf37f0f 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -273,6 +273,7 @@ struct variant_data {
 
 /* mmci variant callbacks */
 struct mmci_host_ops {
+	int (*validate_data)(struct mmci_host *host, struct mmc_data *data);
 	int (*prep_data)(struct mmci_host *host, struct mmc_data *data,
 			 bool next);
 	void (*unprep_data)(struct mmci_host *host, struct mmc_data *data,

commit cfccc6ac005425c4fcb44a4c48a183652751812b
Author: Ludovic Barre <ludovic.barre@st.com>
Date:   Mon Oct 8 14:08:40 2018 +0200

    mmc: mmci: add dma_error callback
    
    This patch adds dma_error callback at mmci_host_ops
    to allow to call specific variant.
    
    Signed-off-by: Ludovic Barre <ludovic.barre@st.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index 8c1493be3cf9..bcf3e8b901d7 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -282,6 +282,7 @@ struct mmci_host_ops {
 	void (*dma_release)(struct mmci_host *host);
 	int (*dma_start)(struct mmci_host *host, unsigned int *datactrl);
 	void (*dma_finalize)(struct mmci_host *host, struct mmc_data *data);
+	void (*dma_error)(struct mmci_host *host);
 };
 
 struct mmci_host {
@@ -343,3 +344,4 @@ int mmci_dmae_setup(struct mmci_host *host);
 void mmci_dmae_release(struct mmci_host *host);
 int mmci_dmae_start(struct mmci_host *host, unsigned int *datactrl);
 void mmci_dmae_finalize(struct mmci_host *host, struct mmc_data *data);
+void mmci_dmae_error(struct mmci_host *host);

commit 5a9f10c359e67403e87c48c73eda297d6e5581bf
Author: Ludovic Barre <ludovic.barre@st.com>
Date:   Mon Oct 8 14:08:39 2018 +0200

    mmc: mmci: add dma_finalize callback
    
    This patch adds dma_finalize callback at mmci_host_ops
    to allow to call specific variant.
    
    Signed-off-by: Ludovic Barre <ludovic.barre@st.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index 7bca597ee76f..8c1493be3cf9 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -281,6 +281,7 @@ struct mmci_host_ops {
 	int (*dma_setup)(struct mmci_host *host);
 	void (*dma_release)(struct mmci_host *host);
 	int (*dma_start)(struct mmci_host *host, unsigned int *datactrl);
+	void (*dma_finalize)(struct mmci_host *host, struct mmc_data *data);
 };
 
 struct mmci_host {
@@ -341,4 +342,4 @@ void mmci_dmae_get_next_data(struct mmci_host *host, struct mmc_data *data);
 int mmci_dmae_setup(struct mmci_host *host);
 void mmci_dmae_release(struct mmci_host *host);
 int mmci_dmae_start(struct mmci_host *host, unsigned int *datactrl);
-
+void mmci_dmae_finalize(struct mmci_host *host, struct mmc_data *data);

commit 135ea30e231295b0045072b48203055d6605e18b
Author: Ludovic Barre <ludovic.barre@st.com>
Date:   Mon Oct 8 14:08:38 2018 +0200

    mmc: mmci: add dma_start callback
    
    This patch adds dma_start callback to mmci_host_ops.
    Create a generic mmci_dma_start function which regroup
    common action between variant.
    
    Signed-off-by: Ludovic Barre <ludovic.barre@st.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index a6a85aa24cbb..7bca597ee76f 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -280,6 +280,7 @@ struct mmci_host_ops {
 	void (*get_next_data)(struct mmci_host *host, struct mmc_data *data);
 	int (*dma_setup)(struct mmci_host *host);
 	void (*dma_release)(struct mmci_host *host);
+	int (*dma_start)(struct mmci_host *host, unsigned int *datactrl);
 };
 
 struct mmci_host {
@@ -339,4 +340,5 @@ void mmci_dmae_unprep_data(struct mmci_host *host, struct mmc_data *data,
 void mmci_dmae_get_next_data(struct mmci_host *host, struct mmc_data *data);
 int mmci_dmae_setup(struct mmci_host *host);
 void mmci_dmae_release(struct mmci_host *host);
+int mmci_dmae_start(struct mmci_host *host, unsigned int *datactrl);
 

commit 02769968d95b32e1d14e30b54dc57fe525c06d2b
Author: Ludovic Barre <ludovic.barre@st.com>
Date:   Mon Oct 8 14:08:37 2018 +0200

    mmc: mmci: add get_next_data callback
    
    This patch adds get_next_data callback to mmci_host_ops.
    Generic mmci_get_next_data factorizes next_cookie check and
    the host ops call.
    
    Signed-off-by: Ludovic Barre <ludovic.barre@st.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index decb1c72d787..a6a85aa24cbb 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -277,6 +277,7 @@ struct mmci_host_ops {
 			 bool next);
 	void (*unprep_data)(struct mmci_host *host, struct mmc_data *data,
 			    int err);
+	void (*get_next_data)(struct mmci_host *host, struct mmc_data *data);
 	int (*dma_setup)(struct mmci_host *host);
 	void (*dma_release)(struct mmci_host *host);
 };
@@ -335,6 +336,7 @@ int mmci_dmae_prep_data(struct mmci_host *host, struct mmc_data *data,
 			bool next);
 void mmci_dmae_unprep_data(struct mmci_host *host, struct mmc_data *data,
 			   int err);
+void mmci_dmae_get_next_data(struct mmci_host *host, struct mmc_data *data);
 int mmci_dmae_setup(struct mmci_host *host);
 void mmci_dmae_release(struct mmci_host *host);
 

commit 4798351018a72deffc98cc70624dd812eff01455
Author: Ludovic Barre <ludovic.barre@st.com>
Date:   Mon Oct 8 14:08:36 2018 +0200

    mmc: mmci: add prepare/unprepare_data callbacks
    
    This patch adds prepare/unprepare callbacks to mmci_host_ops.
    Like this mmci_pre/post_request can be generic, mmci_prepare_data
    and mmci_unprepare_data provide common next_cookie management.
    
    Signed-off-by: Ludovic Barre <ludovic.barre@st.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index 1d5ba4e53341..decb1c72d787 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -273,6 +273,10 @@ struct variant_data {
 
 /* mmci variant callbacks */
 struct mmci_host_ops {
+	int (*prep_data)(struct mmci_host *host, struct mmc_data *data,
+			 bool next);
+	void (*unprep_data)(struct mmci_host *host, struct mmc_data *data,
+			    int err);
 	int (*dma_setup)(struct mmci_host *host);
 	void (*dma_release)(struct mmci_host *host);
 };
@@ -327,6 +331,10 @@ struct mmci_host {
 
 #define dma_inprogress(host)	((host)->dma_in_progress)
 
+int mmci_dmae_prep_data(struct mmci_host *host, struct mmc_data *data,
+			bool next);
+void mmci_dmae_unprep_data(struct mmci_host *host, struct mmc_data *data,
+			   int err);
 int mmci_dmae_setup(struct mmci_host *host);
 void mmci_dmae_release(struct mmci_host *host);
 

commit a813f2a2bccedb2c07fca66f4a67fc0093d35366
Author: Ludovic Barre <ludovic.barre@st.com>
Date:   Mon Oct 8 14:08:34 2018 +0200

    mmc: mmci: introduce dma_priv pointer to mmci_host
    
    -Introduces dma_priv pointer to define specific
    needs for each dma engine. This patch is needed to prepare
    sdmmc variant with internal dma which not use dmaengine API.
    -Moves next cookie to mmci host structure to share same cookie
    management between all variants.
    
    Signed-off-by: Ludovic Barre <ludovic.barre@st.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index 34bb5e6a738b..1d5ba4e53341 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -277,12 +277,6 @@ struct mmci_host_ops {
 	void (*dma_release)(struct mmci_host *host);
 };
 
-struct mmci_host_next {
-	struct dma_async_tx_descriptor	*dma_desc;
-	struct dma_chan			*dma_chan;
-	s32				cookie;
-};
-
 struct mmci_host {
 	phys_addr_t		phybase;
 	void __iomem		*base;
@@ -325,19 +319,14 @@ struct mmci_host {
 	int (*get_rx_fifocnt)(struct mmci_host *h, u32 status, int remain);
 
 	u8			use_dma:1;
-#ifdef CONFIG_DMA_ENGINE
-	/* DMA stuff */
-	struct dma_chan		*dma_current;
-	struct dma_chan		*dma_rx_channel;
-	struct dma_chan		*dma_tx_channel;
-	struct dma_async_tx_descriptor	*dma_desc_current;
-	struct mmci_host_next	next_data;
 	u8			dma_in_progress:1;
+	void			*dma_priv;
 
-#define dma_inprogress(host)	((host)->dma_in_progress)
-#endif
+	s32			next_cookie;
 };
 
+#define dma_inprogress(host)	((host)->dma_in_progress)
+
 int mmci_dmae_setup(struct mmci_host *host);
 void mmci_dmae_release(struct mmci_host *host);
 

commit c3647fdc6a5a48699a1248a7f3d9a0429369e939
Author: Ludovic Barre <ludovic.barre@st.com>
Date:   Mon Oct 8 14:08:33 2018 +0200

    mmc: mmci: create common mmci_dma_setup/release
    
    This patch creates a common mmci_dma_setup/release which calls
    dma_setup/release callbacks of mmci_host_ops and manages
    common features like use_dma... If there is a fallbacks to
    pio mode, dma functions must check use_dma.
    
    error management:
    -mmci_dmae_setup fail if Tx and Rx dma channels are not defined
    -qcom_dma_setup fail if one of both dma channels is not defined,
     Qcom has no specific resource to release, just mmci dmae resource.
    
    Signed-off-by: Ludovic Barre <ludovic.barre@st.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index 01e6c6bb5e83..34bb5e6a738b 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -273,7 +273,8 @@ struct variant_data {
 
 /* mmci variant callbacks */
 struct mmci_host_ops {
-	void (*dma_setup)(struct mmci_host *host);
+	int (*dma_setup)(struct mmci_host *host);
+	void (*dma_release)(struct mmci_host *host);
 };
 
 struct mmci_host_next {
@@ -323,6 +324,7 @@ struct mmci_host {
 	unsigned int		size;
 	int (*get_rx_fifocnt)(struct mmci_host *h, u32 status, int remain);
 
+	u8			use_dma:1;
 #ifdef CONFIG_DMA_ENGINE
 	/* DMA stuff */
 	struct dma_chan		*dma_current;
@@ -336,3 +338,6 @@ struct mmci_host {
 #endif
 };
 
+int mmci_dmae_setup(struct mmci_host *host);
+void mmci_dmae_release(struct mmci_host *host);
+

commit 19a25d57ad39c7facc878d68feeb79867e037922
Author: Ludovic Barre <ludovic.barre@st.com>
Date:   Tue Oct 2 14:09:03 2018 +0200

    mmc: mmci: Change struct members from bool to u8
    
    Recent versions of checkpatch have a new warning based on a documented
    preference of Linus to not use bool in structures due to wasted space and
    the size of bool is implementation dependent.  For more information, see
    the email thread at https://lkml.org/lkml/2017/11/21/384
    
    fix checkpatch --strict issues:
    -CHECK: Avoid using bool structure members because of possible alignment
     issues - see: https://lkml.org/lkml/2017/11/21/384
    -WARNING: Avoid using bool as bitfield. Prefer bool bitfields as
     unsigned int or u<8|16|32>
    
    Signed-off-by: Ludovic Barre <ludovic.barre@st.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index 21aaf9a261ba..01e6c6bb5e83 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -248,24 +248,24 @@ struct variant_data {
 	unsigned int		data_cmd_enable;
 	unsigned int		datactrl_mask_ddrmode;
 	unsigned int		datactrl_mask_sdio;
-	bool			st_sdio;
-	bool			st_clkdiv;
-	bool			blksz_datactrl16;
-	bool			blksz_datactrl4;
+	u8			st_sdio:1;
+	u8			st_clkdiv:1;
+	u8			blksz_datactrl16:1;
+	u8			blksz_datactrl4:1;
 	u32			pwrreg_powerup;
 	u32			f_max;
-	bool			signal_direction;
-	bool			pwrreg_clkgate;
-	bool			busy_detect;
+	u8			signal_direction:1;
+	u8			pwrreg_clkgate:1;
+	u8			busy_detect:1;
 	u32			busy_dpsm_flag;
 	u32			busy_detect_flag;
 	u32			busy_detect_mask;
-	bool			pwrreg_nopower;
-	bool			explicit_mclk_control;
-	bool			qcom_fifo;
-	bool			qcom_dml;
-	bool			reversed_irq_handling;
-	bool			mmcimask1;
+	u8			pwrreg_nopower:1;
+	u8			explicit_mclk_control:1;
+	u8			qcom_fifo:1;
+	u8			qcom_dml:1;
+	u8			reversed_irq_handling:1;
+	u8			mmcimask1:1;
 	u32			start_err;
 	u32			opendrain;
 	void (*init)(struct mmci_host *host);
@@ -290,7 +290,7 @@ struct mmci_host {
 	struct mmc_data		*data;
 	struct mmc_host		*mmc;
 	struct clk		*clk;
-	bool			singleirq;
+	u8			singleirq:1;
 
 	spinlock_t		lock;
 
@@ -304,7 +304,7 @@ struct mmci_host {
 	u32			datactrl_reg;
 	u32			busy_status;
 	u32			mask1_reg;
-	bool			vqmmc_enabled;
+	u8			vqmmc_enabled:1;
 	struct mmci_platform_data *plat;
 	struct mmci_host_ops	*ops;
 	struct variant_data	*variant;
@@ -330,7 +330,7 @@ struct mmci_host {
 	struct dma_chan		*dma_tx_channel;
 	struct dma_async_tx_descriptor	*dma_desc_current;
 	struct mmci_host_next	next_data;
-	bool			dma_in_progress;
+	u8			dma_in_progress:1;
 
 #define dma_inprogress(host)	((host)->dma_in_progress)
 #endif

commit cdea194721929d025d40cfa6c2449d5c4cd366e6
Author: Ludovic Barre <ludovic.barre@st.com>
Date:   Fri Sep 21 11:45:56 2018 +0200

    mmc: mmci: internalize dma_inprogress into mmci dma functions
    
    This patch internalizes the dma_inprogress into mmci dma interfaces.
    This allows to simplify and prepare the next dma callbacks
    for mmci host ops. dma_inprogress is called in mmci_dma_data_error
    and mmci_dma_finalize.
    
    Signed-off-by: Ludovic Barre <ludovic.barre@st.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index 517591d219e9..21aaf9a261ba 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -333,8 +333,6 @@ struct mmci_host {
 	bool			dma_in_progress;
 
 #define dma_inprogress(host)	((host)->dma_in_progress)
-#else
-#define dma_inprogress(host)	(0)
 #endif
 };
 

commit 29aba07aea0e36c996001ca3f8997316ebefe0e1
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Mon Jul 16 13:08:18 2018 +0200

    mmc: mmci: Add and implement a ->dma_setup() callback for qcom dml
    
    As a first step to improve the variant specific code for mmci, add a
    ->dma_setup() callback to the struct mmci_host_ops.
    
    To show its use, let's deploy the callback for the qcom dml, which involves
    also to the assign the mmci_host_ops pointer from the variant ->init()
    callback.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Ludovic Barre <ludovic.barre@st.com>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index f2eff0cc6934..517591d219e9 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -273,6 +273,7 @@ struct variant_data {
 
 /* mmci variant callbacks */
 struct mmci_host_ops {
+	void (*dma_setup)(struct mmci_host *host);
 };
 
 struct mmci_host_next {

commit ed9067fd5f299db7110861a0434d0e2ffb961649
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri Jul 13 13:15:23 2018 +0200

    mmc: mmci: Initial support to manage variant specific callbacks
    
    To be able to better support different mmci variants, we need to be able to
    use variant specific callbacks, rather than continue to sprinkle the code
    with additional variant data. To move in this direction, let's add an
    optional ->init() callback to the variant data struct, which variants shall
    use to assign the mmci_host_ops pointer.
    
    Using an ->init() callback enables us to partition the code between
    different files. To allow separate mmci variant files to implement the
    variant specifics, let's also move the definition of the struct
    variant_data to the common mmci header file.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Ludovic Barre <ludovic.barre@st.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index f91cdf7f6dae..f2eff0cc6934 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -195,8 +195,85 @@
 #define MMCI_PINCTRL_STATE_OPENDRAIN "opendrain"
 
 struct clk;
-struct variant_data;
 struct dma_chan;
+struct mmci_host;
+
+/**
+ * struct variant_data - MMCI variant-specific quirks
+ * @clkreg: default value for MCICLOCK register
+ * @clkreg_enable: enable value for MMCICLOCK register
+ * @clkreg_8bit_bus_enable: enable value for 8 bit bus
+ * @clkreg_neg_edge_enable: enable value for inverted data/cmd output
+ * @datalength_bits: number of bits in the MMCIDATALENGTH register
+ * @fifosize: number of bytes that can be written when MMCI_TXFIFOEMPTY
+ *	      is asserted (likewise for RX)
+ * @fifohalfsize: number of bytes that can be written when MCI_TXFIFOHALFEMPTY
+ *		  is asserted (likewise for RX)
+ * @data_cmd_enable: enable value for data commands.
+ * @st_sdio: enable ST specific SDIO logic
+ * @st_clkdiv: true if using a ST-specific clock divider algorithm
+ * @datactrl_mask_ddrmode: ddr mode mask in datactrl register.
+ * @blksz_datactrl16: true if Block size is at b16..b30 position in datactrl register
+ * @blksz_datactrl4: true if Block size is at b4..b16 position in datactrl
+ *		     register
+ * @datactrl_mask_sdio: SDIO enable mask in datactrl register
+ * @pwrreg_powerup: power up value for MMCIPOWER register
+ * @f_max: maximum clk frequency supported by the controller.
+ * @signal_direction: input/out direction of bus signals can be indicated
+ * @pwrreg_clkgate: MMCIPOWER register must be used to gate the clock
+ * @busy_detect: true if the variant supports busy detection on DAT0.
+ * @busy_dpsm_flag: bitmask enabling busy detection in the DPSM
+ * @busy_detect_flag: bitmask identifying the bit in the MMCISTATUS register
+ *		      indicating that the card is busy
+ * @busy_detect_mask: bitmask identifying the bit in the MMCIMASK0 to mask for
+ *		      getting busy end detection interrupts
+ * @pwrreg_nopower: bits in MMCIPOWER don't controls ext. power supply
+ * @explicit_mclk_control: enable explicit mclk control in driver.
+ * @qcom_fifo: enables qcom specific fifo pio read logic.
+ * @qcom_dml: enables qcom specific dma glue for dma transfers.
+ * @reversed_irq_handling: handle data irq before cmd irq.
+ * @mmcimask1: true if variant have a MMCIMASK1 register.
+ * @start_err: bitmask identifying the STARTBITERR bit inside MMCISTATUS
+ *	       register.
+ * @opendrain: bitmask identifying the OPENDRAIN bit inside MMCIPOWER register
+ */
+struct variant_data {
+	unsigned int		clkreg;
+	unsigned int		clkreg_enable;
+	unsigned int		clkreg_8bit_bus_enable;
+	unsigned int		clkreg_neg_edge_enable;
+	unsigned int		datalength_bits;
+	unsigned int		fifosize;
+	unsigned int		fifohalfsize;
+	unsigned int		data_cmd_enable;
+	unsigned int		datactrl_mask_ddrmode;
+	unsigned int		datactrl_mask_sdio;
+	bool			st_sdio;
+	bool			st_clkdiv;
+	bool			blksz_datactrl16;
+	bool			blksz_datactrl4;
+	u32			pwrreg_powerup;
+	u32			f_max;
+	bool			signal_direction;
+	bool			pwrreg_clkgate;
+	bool			busy_detect;
+	u32			busy_dpsm_flag;
+	u32			busy_detect_flag;
+	u32			busy_detect_mask;
+	bool			pwrreg_nopower;
+	bool			explicit_mclk_control;
+	bool			qcom_fifo;
+	bool			qcom_dml;
+	bool			reversed_irq_handling;
+	bool			mmcimask1;
+	u32			start_err;
+	u32			opendrain;
+	void (*init)(struct mmci_host *host);
+};
+
+/* mmci variant callbacks */
+struct mmci_host_ops {
+};
 
 struct mmci_host_next {
 	struct dma_async_tx_descriptor	*dma_desc;
@@ -228,6 +305,7 @@ struct mmci_host {
 	u32			mask1_reg;
 	bool			vqmmc_enabled;
 	struct mmci_platform_data *plat;
+	struct mmci_host_ops	*ops;
 	struct variant_data	*variant;
 	struct pinctrl		*pinctrl;
 	struct pinctrl_state	*pins_default;

commit f9bb304ce855fad615c5adffae5e129941ff0b48
Author: Patrice Chotard <patrice.chotard@st.com>
Date:   Thu Jan 18 15:34:20 2018 +0100

    mmc: mmci: Add support for setting pad type via pinctrl
    
    If variant hasn't the control bit to switch pads in opendrain mode,
    we can achieve the same result by asking to the pinmux driver to
    configure pins for us.
    
    This patch make the mmci driver able to do this whenever needed.
    
    Signed-off-by: Andrea Merello <andrea.merello@gmail.com>
    Signed-off-by: Patrice Chotard <patrice.chotard@st.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index 83160a9c4c77..f91cdf7f6dae 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -192,6 +192,8 @@
 
 #define NR_SG		128
 
+#define MMCI_PINCTRL_STATE_OPENDRAIN "opendrain"
+
 struct clk;
 struct variant_data;
 struct dma_chan;
@@ -227,6 +229,9 @@ struct mmci_host {
 	bool			vqmmc_enabled;
 	struct mmci_platform_data *plat;
 	struct variant_data	*variant;
+	struct pinctrl		*pinctrl;
+	struct pinctrl_state	*pins_default;
+	struct pinctrl_state	*pins_opendrain;
 
 	u8			hw_designer;
 	u8			hw_revision:4;

commit 6ea9cdf3912a8ca532dde5296a0e81fc75a40fa3
Author: Patrice Chotard <patrice.chotard@st.com>
Date:   Thu Jan 18 15:34:17 2018 +0100

    mmc: mmci: Don't pretend all variants to have MMCIMASK1 register
    
    Two mask registers are used in order to select which events have to
    actually generate an interrupt on each IRQ line.
    
    It seems that in the single-IRQ case it's assumed that the IRQs lines
    are simply OR-ed, while the two mask registers are still present. The
    driver still programs the two mask registers separately.
    
    However the STM32 variant has only one IRQ, and also has only one mask
    register.
    
    This patch prepares for STM32 variant support by making the driver using
    only one mask register.
    
    This patch also optimize the MMCIMASK1 mask usage by caching it into
    host->mask1_reg which avoid to read it into mmci_irq().
    
    Tested only on STM32 variant. RFT for variants other than STM32
    
    Signed-off-by: Andrea Merello <andrea.merello@gmail.com>
    Signed-off-by: Patrice Chotard <patrice.chotard@st.com>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index 4a8bef1aac8f..83160a9c4c77 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -223,6 +223,7 @@ struct mmci_host {
 	u32			clk_reg;
 	u32			datactrl_reg;
 	u32			busy_status;
+	u32			mask1_reg;
 	bool			vqmmc_enabled;
 	struct mmci_platform_data *plat;
 	struct variant_data	*variant;

commit e13934bdf45935f51243515c275629922dc43839
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Fri Jan 27 15:04:54 2017 +0100

    mmc: core/mmci: restore pre/post_req behaviour
    
    commit 64b12a68a9f74bb32d8efd7af1ad8a2ba02fc884
    "mmc: core: fix prepared requests while doing bkops"
    is fixing a bug in the wrong way. A bug in the MMCI
    device driver is fixed by amending the MMC core.
    
    Thinking about it: what the pre- and post-callbacks
    are doing is to essentially map and unmap SG lists
    for DMA transfers. Why would we not be able to do that
    just because a BKOPS command is sent inbetween?
    Having to unprepare/prepare the next asynchronous
    request for DMA seems wrong.
    
    Looking the backtrace in that commit we can see what
    the real problem actually is:
    
    mmci_data_irq() is calling mmci_dma_unmap() twice
    which is goung to call arm_dma_unmap_sg() twice
    and v7_dma_inv_range() twice for the same sglist
    and that will crash.
    
    This happens because a request is prepared, then
    a BKOPS is sent. The IRQ completing the BKOPS command
    goes through mmci_data_irq() and thinks that a DMA
    operation has just been completed because
    dma_inprogress() reports true. It then proceeds to
    unmap the sglist.
    
    But that was wrong! dma_inprogress() should NOT be
    true because no DMA was actually in progress! We had
    just prepared the sglist, and the DMA channel
    dma_current has been configured, but NOT started!
    
    Because of this, the sglist is already unmapped when
    we get our actual data completion IRQ, and we are
    unmapping the sglist once more, and we get this crash.
    
    Therefore, we need to revert this solution pushing
    the problem to the core and causing problems, and
    instead augment the implementation such that
    dma_inprogress() only reports true if some DMA has
    actually been started.
    
    After this we can keep the request prepared during the
    BKOPS and we need not unprepare/reprepare it.
    
    Fixes: 64b12a68a9f7 ("mmc: core: fix prepared requests while doing bkops")
    Cc: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Tested-by: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index 56322c6afba4..4a8bef1aac8f 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -245,8 +245,9 @@ struct mmci_host {
 	struct dma_chan		*dma_tx_channel;
 	struct dma_async_tx_descriptor	*dma_desc_current;
 	struct mmci_host_next	next_data;
+	bool			dma_in_progress;
 
-#define dma_inprogress(host)	((host)->dma_current)
+#define dma_inprogress(host)	((host)->dma_in_progress)
 #else
 #define dma_inprogress(host)	(0)
 #endif

commit 49adc0cacbe8553333883059ae183d0274d4ea17
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Oct 25 11:06:06 2016 +0200

    mmc: mmci: refactor ST Micro busy detection
    
    The ST Micro-specific busy detection was made after the assumption
    that only this variant supports busy detection. So when doing busy
    detection, the host immediately tries to use some ST-specific
    register bits.
    
    Since the qualcomm variant also supports some busy detection
    schemes, encapsulate the variant flags better in the variant struct
    and prepare to add more variants by just providing some bitmasks
    to the logic.
    
    Put the entire busy detection logic within an if()-clause in the
    mmci_cmd_irq() function so the code is only executed when busy
    detection is enabled, and so that it is kept in (almost) one
    place, and add comments describing what is going on so the
    code can be understood.
    
    Tested on the Ux500 by introducing some prints in the busy
    detection path and noticing how the IRQ is enabled, used and
    disabled successfully.
    
    Cc: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index 7cabf270050b..56322c6afba4 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -174,7 +174,7 @@
 /* Extended status bits for the ST Micro variants */
 #define MCI_ST_SDIOITMASK	(1 << 22)
 #define MCI_ST_CEATAENDMASK	(1 << 23)
-#define MCI_ST_BUSYEND		(1 << 24)
+#define MCI_ST_BUSYENDMASK	(1 << 24)
 
 #define MMCIMASK1		0x040
 #define MMCIFIFOCNT		0x048

commit 5db3eee7b914b8629b88bbad5a9ea196ce8de0cd
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Oct 25 11:06:05 2016 +0200

    mmc: mmci: clean up header defines
    
    There was some confusion in the CPSM (Command Path State Machine)
    and DPSM (Data Path State Machine) regarding the naming of the
    registers, clarify the meaning of this acronym so the naming is
    understandable, and consistently use BIT() to define these fields.
    
    Consequently name the register bit defines MCI_[C|D]PSM_* and
    adjust the driver as well.
    
    Include new definitions for a few bits found in a patch from
    Srinivas Kandagatla.
    
    Cc: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index a1f5e4f49e2a..7cabf270050b 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -51,25 +51,27 @@
 #define MCI_QCOM_CLK_SELECT_IN_DDR_MODE	(BIT(14) | BIT(15))
 
 #define MMCIARGUMENT		0x008
-#define MMCICOMMAND		0x00c
-#define MCI_CPSM_RESPONSE	(1 << 6)
-#define MCI_CPSM_LONGRSP	(1 << 7)
-#define MCI_CPSM_INTERRUPT	(1 << 8)
-#define MCI_CPSM_PENDING	(1 << 9)
-#define MCI_CPSM_ENABLE		(1 << 10)
-/* Argument flag extenstions in the ST Micro versions */
-#define MCI_ST_SDIO_SUSP	(1 << 11)
-#define MCI_ST_ENCMD_COMPL	(1 << 12)
-#define MCI_ST_NIEN		(1 << 13)
-#define MCI_ST_CE_ATACMD	(1 << 14)
 
-/* Modified on Qualcomm Integrations */
-#define MCI_QCOM_CSPM_DATCMD		BIT(12)
-#define MCI_QCOM_CSPM_MCIABORT		BIT(13)
-#define MCI_QCOM_CSPM_CCSENABLE		BIT(14)
-#define MCI_QCOM_CSPM_CCSDISABLE	BIT(15)
-#define MCI_QCOM_CSPM_AUTO_CMD19	BIT(16)
-#define MCI_QCOM_CSPM_AUTO_CMD21	BIT(21)
+/* The command register controls the Command Path State Machine (CPSM) */
+#define MMCICOMMAND		0x00c
+#define MCI_CPSM_RESPONSE	BIT(6)
+#define MCI_CPSM_LONGRSP	BIT(7)
+#define MCI_CPSM_INTERRUPT	BIT(8)
+#define MCI_CPSM_PENDING	BIT(9)
+#define MCI_CPSM_ENABLE		BIT(10)
+/* Command register flag extenstions in the ST Micro versions */
+#define MCI_CPSM_ST_SDIO_SUSP		BIT(11)
+#define MCI_CPSM_ST_ENCMD_COMPL		BIT(12)
+#define MCI_CPSM_ST_NIEN		BIT(13)
+#define MCI_CPSM_ST_CE_ATACMD		BIT(14)
+/* Command register flag extensions in the Qualcomm versions */
+#define MCI_CPSM_QCOM_PROGENA		BIT(11)
+#define MCI_CPSM_QCOM_DATCMD		BIT(12)
+#define MCI_CPSM_QCOM_MCIABORT		BIT(13)
+#define MCI_CPSM_QCOM_CCSENABLE		BIT(14)
+#define MCI_CPSM_QCOM_CCSDISABLE	BIT(15)
+#define MCI_CPSM_QCOM_AUTO_CMD19	BIT(16)
+#define MCI_CPSM_QCOM_AUTO_CMD21	BIT(21)
 
 #define MMCIRESPCMD		0x010
 #define MMCIRESPONSE0		0x014
@@ -78,22 +80,27 @@
 #define MMCIRESPONSE3		0x020
 #define MMCIDATATIMER		0x024
 #define MMCIDATALENGTH		0x028
+
+/* The data control register controls the Data Path State Machine (DPSM) */
 #define MMCIDATACTRL		0x02c
-#define MCI_DPSM_ENABLE		(1 << 0)
-#define MCI_DPSM_DIRECTION	(1 << 1)
-#define MCI_DPSM_MODE		(1 << 2)
-#define MCI_DPSM_DMAENABLE	(1 << 3)
-#define MCI_DPSM_BLOCKSIZE	(1 << 4)
+#define MCI_DPSM_ENABLE		BIT(0)
+#define MCI_DPSM_DIRECTION	BIT(1)
+#define MCI_DPSM_MODE		BIT(2)
+#define MCI_DPSM_DMAENABLE	BIT(3)
+#define MCI_DPSM_BLOCKSIZE	BIT(4)
 /* Control register extensions in the ST Micro U300 and Ux500 versions */
-#define MCI_ST_DPSM_RWSTART	(1 << 8)
-#define MCI_ST_DPSM_RWSTOP	(1 << 9)
-#define MCI_ST_DPSM_RWMOD	(1 << 10)
-#define MCI_ST_DPSM_SDIOEN	(1 << 11)
+#define MCI_DPSM_ST_RWSTART	BIT(8)
+#define MCI_DPSM_ST_RWSTOP	BIT(9)
+#define MCI_DPSM_ST_RWMOD	BIT(10)
+#define MCI_DPSM_ST_SDIOEN	BIT(11)
 /* Control register extensions in the ST Micro Ux500 versions */
-#define MCI_ST_DPSM_DMAREQCTL	(1 << 12)
-#define MCI_ST_DPSM_DBOOTMODEEN	(1 << 13)
-#define MCI_ST_DPSM_BUSYMODE	(1 << 14)
-#define MCI_ST_DPSM_DDRMODE	(1 << 15)
+#define MCI_DPSM_ST_DMAREQCTL	BIT(12)
+#define MCI_DPSM_ST_DBOOTMODEEN	BIT(13)
+#define MCI_DPSM_ST_BUSYMODE	BIT(14)
+#define MCI_DPSM_ST_DDRMODE	BIT(15)
+/* Control register extensions in the Qualcomm versions */
+#define MCI_DPSM_QCOM_DATA_PEND	BIT(17)
+#define MCI_DPSM_QCOM_RX_DATA_PEND BIT(20)
 
 #define MMCIDATACNT		0x030
 #define MMCISTATUS		0x034

commit 9c34b73deec147a042c4bd871a373f76af70e38c
Author: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
Date:   Mon Jun 2 10:10:04 2014 +0100

    mmc: mmci: Add Qcom specific rx_fifocnt logic.
    
    MCIFIFOCNT register behaviour on Qcom chips is very different than the other
    pl180 integrations. MCIFIFOCNT register contains the number of
    words that are still waiting to be transferred through the FIFO. It keeps
    decrementing once the host CPU reads the MCIFIFO. With the existing logic and
    the MCIFIFOCNT behaviour, mmci_pio_read will loop forever, as the FIFOCNT
    register will always return transfer size before reading the FIFO.
    
    Also the data sheet states that "This register is only useful for debug
    purposes and should not be used for normal operation since it does not reflect
    data which may or may not be in the pipeline".
    
    This patch implements a qcom specific get_rx_fifocnt function which is
    implemented based on status register flags. Based on qcom_fifo flag in
    variant data structure, the corresponding get_rx_fifocnt function is selected.
    
    Signed-off-by: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index ef346170b241..a1f5e4f49e2a 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -229,6 +229,7 @@ struct mmci_host {
 	/* pio stuff */
 	struct sg_mapping_iter	sg_miter;
 	unsigned int		size;
+	int (*get_rx_fifocnt)(struct mmci_host *h, u32 status, int remain);
 
 #ifdef CONFIG_DMA_ENGINE
 	/* DMA stuff */

commit 3f4e6f7b9175e2914b82134c4a6a02825f4766db
Author: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
Date:   Mon Jun 2 10:09:55 2014 +0100

    mmc: mmci: add explicit clk control
    
    On Controllers like Qcom SD card controller where cclk is mclk and mclk should
    be directly controlled by the driver.
    
    This patch adds support to control mclk directly in the driver, and also
    adds explicit_mclk_control flag in variant structure giving more flexibility
    to the driver.
    
    Signed-off-by: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    [Ulf Hansson] Fixed checkpatch warning
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index d38a99df1820..ef346170b241 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -208,6 +208,8 @@ struct mmci_host {
 	spinlock_t		lock;
 
 	unsigned int		mclk;
+	/* cached value of requested clk in set_ios */
+	unsigned int		clock_cache;
 	unsigned int		cclk;
 	u32			pwr_reg;
 	u32			pwr_reg_add;

commit 9681a4e88207bca452c39fdbf070fa7a8eea9a8a
Author: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
Date:   Mon Jun 2 10:08:48 2014 +0100

    mmc: mmci: Add Qualcomm specific register defines.
    
    This patch adds a Qualcomm SD Card controller specific register variations
    to header file. Qualcomm SDCC controller is pl180, with slight changes in
    the register layout from standard pl180 register set.
    
    Signed-off-by: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index 347d942d740b..d38a99df1820 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -41,6 +41,15 @@
 /* Modified PL180 on Versatile Express platform */
 #define MCI_ARM_HWFCEN		(1 << 12)
 
+/* Modified on Qualcomm Integrations */
+#define MCI_QCOM_CLK_WIDEBUS_8	(BIT(10) | BIT(11))
+#define MCI_QCOM_CLK_FLOWENA	BIT(12)
+#define MCI_QCOM_CLK_INVERTOUT	BIT(13)
+
+/* select in latch data and command in */
+#define MCI_QCOM_CLK_SELECT_IN_FBCLK	BIT(15)
+#define MCI_QCOM_CLK_SELECT_IN_DDR_MODE	(BIT(14) | BIT(15))
+
 #define MMCIARGUMENT		0x008
 #define MMCICOMMAND		0x00c
 #define MCI_CPSM_RESPONSE	(1 << 6)
@@ -54,6 +63,14 @@
 #define MCI_ST_NIEN		(1 << 13)
 #define MCI_ST_CE_ATACMD	(1 << 14)
 
+/* Modified on Qualcomm Integrations */
+#define MCI_QCOM_CSPM_DATCMD		BIT(12)
+#define MCI_QCOM_CSPM_MCIABORT		BIT(13)
+#define MCI_QCOM_CSPM_CCSENABLE		BIT(14)
+#define MCI_QCOM_CSPM_CCSDISABLE	BIT(15)
+#define MCI_QCOM_CSPM_AUTO_CMD19	BIT(16)
+#define MCI_QCOM_CSPM_AUTO_CMD21	BIT(21)
+
 #define MMCIRESPCMD		0x010
 #define MMCIRESPONSE0		0x014
 #define MMCIRESPONSE1		0x018

commit 4593df29b94b31de931dc20d7da2e6c468c8d473
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri Mar 21 10:13:05 2014 +0100

    mmc: mmci: Enforce DT for signal direction and feedback clock
    
    Remove the option to provide signal direction configuration and
    feeback clock as platform data, enforce it through DT.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index 8fc5814f938a..347d942d740b 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -13,6 +13,16 @@
 #define MCI_PWR_ON		0x03
 #define MCI_OD			(1 << 6)
 #define MCI_ROD			(1 << 7)
+/*
+ * The ST Micro version does not have ROD and reuse the voltage registers for
+ * direction settings.
+ */
+#define MCI_ST_DATA2DIREN	(1 << 2)
+#define MCI_ST_CMDDIREN		(1 << 3)
+#define MCI_ST_DATA0DIREN	(1 << 4)
+#define MCI_ST_DATA31DIREN	(1 << 5)
+#define MCI_ST_FBCLKEN		(1 << 7)
+#define MCI_ST_DATA74DIREN	(1 << 8)
 
 #define MMCICLOCK		0x004
 #define MCI_CLK_ENABLE		(1 << 8)
@@ -183,6 +193,7 @@ struct mmci_host {
 	unsigned int		mclk;
 	unsigned int		cclk;
 	u32			pwr_reg;
+	u32			pwr_reg_add;
 	u32			clk_reg;
 	u32			datactrl_reg;
 	u32			busy_status;

commit d2762090153053bca984ce5f8978953f63390401
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Mon Mar 17 13:56:19 2014 +0100

    mmc: mmci: Convert to the mmc gpio API
    
    To avoid duplication of code while handling card detect and write
    protect GPIO pins/irqs, let's convert to use the mmc gpio API.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index 58b1b8896bf2..8fc5814f938a 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -176,9 +176,6 @@ struct mmci_host {
 	struct mmc_data		*data;
 	struct mmc_host		*mmc;
 	struct clk		*clk;
-	int			gpio_cd;
-	int			gpio_wp;
-	int			gpio_cd_irq;
 	bool			singleirq;
 
 	spinlock_t		lock;

commit 97e18dc007546fce8e99098480b921a02ebb3037
Merge: 042f7b7cbd1e c67480173f72
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Apr 9 08:39:39 2014 -0700

    Merge tag 'mmc-updates-for-3.15-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/cjb/mmc
    
    Pull MMC updates from Chris Ball:
     "MMC highlights for 3.15:
    
      Core:
       - CONFIG_MMC_UNSAFE_RESUME=y is now default behavior
       - DT bindings for SDHCI UHS, eMMC HS200, high-speed DDR, at 1.8/1.2V
       - Add GPIO descriptor based slot-gpio card detect API
    
      Drivers:
       - dw_mmc: Refactor SOCFPGA support as a variant inside dw_mmc-pltfm.c
       - mmci: Support HW busy detection on ux500
       - omap: Support MMC_ERASE
       - omap_hsmmc: Support MMC_PM_KEEP_POWER, MMC_PM_WAKE_SDIO_IRQ, (a)cmd23
       - rtsx: Support pre-req/post-req async
       - sdhci: Add support for Realtek RTS5250 controllers
       - sdhci-acpi: Add support for 80860F16, fix 80860F14/SDIO card detect
       - sdhci-msm: Add new driver for Qualcomm SDHCI chipset support
       - sdhci-pxav3: Add support for Marvell Armada 380 and 385 SoCs"
    
    * tag 'mmc-updates-for-3.15-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/cjb/mmc: (102 commits)
      mmc: sdhci-acpi: Intel SDIO has broken card detect
      mmc: sdhci-pxav3: add support for the Armada 38x SDHCI controller
      mmc: sdhci-msm: Add platform_execute_tuning implementation
      mmc: sdhci-msm: Initial support for Qualcomm chipsets
      mmc: sdhci-msm: Qualcomm SDHCI binding documentation
      sdhci: only reprogram retuning timer when flag is set
      mmc: rename ARCH_BCM to ARCH_BCM_MOBILE
      mmc: sdhci: Allow for irq being shared
      mmc: sdhci-acpi: Add device id 80860F16
      mmc: sdhci-acpi: Fix broken card detect for ACPI HID 80860F14
      mmc: slot-gpio: Add GPIO descriptor based CD GPIO API
      mmc: slot-gpio: Split out CD IRQ request into a separate function
      mmc: slot-gpio: Record GPIO descriptors instead of GPIO numbers
      Revert "dts: socfpga: Add support for SD/MMC on the SOCFPGA platform"
      mmc: sdhci-spear: use generic card detection gpio support
      mmc: sdhci-spear: remove support for power gpio
      mmc: sdhci-spear: simplify resource handling
      mmc: sdhci-spear: fix platform_data usage
      mmc: sdhci-spear: fix error handling paths for DT
      mmc: sdhci-bcm-kona: fix build errors when built-in
      ...

commit 8d94b54d99ea968a9d188ca0e68793ebed601220
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Mon Jan 13 16:49:31 2014 +0100

    mmc: mmci: Enable support for busy detection for ux500 variant
    
    The ux500 variants have HW busy detection support, which is indicated
    by the busy_detect flag. For these variants let's enable the
    MMC_CAP_WAIT_WHILE_BUSY flag and add the support for it.
    
    The mmc core will provide the RSP_BUSY command flag for those requests
    we should care about busy detection. Regarding the max_busy_timeout,
    the HW don't support busy detection timeouts so at this initial step
    let's make it simple and set it to zero to indicate we are able to
    support any timeout.
    
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Johan Rudholm <jrudholm@gmail.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <chris@printf.net>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index 168bc72f7a94..b008ace3e8ee 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -139,6 +139,7 @@
 /* Extended status bits for the ST Micro variants */
 #define MCI_ST_SDIOITMASK	(1 << 22)
 #define MCI_ST_CEATAENDMASK	(1 << 23)
+#define MCI_ST_BUSYEND		(1 << 24)
 
 #define MMCIMASK1		0x040
 #define MMCIFIFOCNT		0x048
@@ -186,6 +187,7 @@ struct mmci_host {
 	u32			pwr_reg;
 	u32			clk_reg;
 	u32			datactrl_reg;
+	u32			busy_status;
 	bool			vqmmc_enabled;
 	struct mmci_platform_data *plat;
 	struct variant_data	*variant;

commit dfdf5f63b4380b9e719145c7cb2cb450a3d06ac4
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Feb 11 09:28:09 2014 +0100

    ARM: 7956/1: mmci: rename some extended flags
    
    These four (so far unused) flags are only found in the ST Micro
    versions of MMCI, so infix them properly with the _ST_ infix.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index 168bc72f7a94..84c0e59b792a 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -38,10 +38,11 @@
 #define MCI_CPSM_INTERRUPT	(1 << 8)
 #define MCI_CPSM_PENDING	(1 << 9)
 #define MCI_CPSM_ENABLE		(1 << 10)
-#define MCI_SDIO_SUSP		(1 << 11)
-#define MCI_ENCMD_COMPL		(1 << 12)
-#define MCI_NIEN		(1 << 13)
-#define MCI_CE_ATACMD		(1 << 14)
+/* Argument flag extenstions in the ST Micro versions */
+#define MCI_ST_SDIO_SUSP	(1 << 11)
+#define MCI_ST_ENCMD_COMPL	(1 << 12)
+#define MCI_ST_NIEN		(1 << 13)
+#define MCI_ST_CE_ATACMD	(1 << 14)
 
 #define MMCIRESPCMD		0x010
 #define MMCIRESPONSE0		0x014

commit edaf6d3d264ae9323a53a49b2a1cf42cc5df1be2
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Wed Sep 4 08:59:51 2013 +0100

    ARM: 7831/1: mmc: mmci: Adapt to new pinctrl handling
    
    There is no need for every driver to fetch a pinctrl handle and to
    select the default state. Instead this is handled by the device driver
    core, thus we can remove this piece of code from mmci.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index 69080fab6375..168bc72f7a94 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -200,10 +200,6 @@ struct mmci_host {
 	struct sg_mapping_iter	sg_miter;
 	unsigned int		size;
 
-	/* pinctrl handles */
-	struct pinctrl		*pinctrl;
-	struct pinctrl_state	*pins_default;
-
 #ifdef CONFIG_DMA_ENGINE
 	/* DMA stuff */
 	struct dma_chan		*dma_current;

commit 0125962000777cd1e2ce53deefb99779d5ee5199
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Wed May 15 20:53:22 2013 +0100

    ARM: 7726/1: mmc: mmci: Add card_busy function to improve UHS card support
    
    To verify a signal voltage switch at initialization of UHS cards the
    .card_busy callback is used. For some of the ST-variants, card busy
    detection on the DAT0 pin is supported.
    
    We extend the variant struct with a busy_detect flag to indicate
    support for it. A corresponding busy detect function, which polls the
    busy status bit, is then set to the .card_busy callback.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index 0b6cc54be966..69080fab6375 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -94,6 +94,7 @@
 /* Extended status bits for the ST Micro variants */
 #define MCI_ST_SDIOIT		(1 << 22)
 #define MCI_ST_CEATAEND		(1 << 23)
+#define MCI_ST_CARDBUSY		(1 << 24)
 
 #define MMCICLEAR		0x038
 #define MCI_CMDCRCFAILCLR	(1 << 0)
@@ -110,6 +111,7 @@
 /* Extended status bits for the ST Micro variants */
 #define MCI_ST_SDIOITC		(1 << 22)
 #define MCI_ST_CEATAENDC	(1 << 23)
+#define MCI_ST_BUSYENDC		(1 << 24)
 
 #define MMCIMASK0		0x03c
 #define MCI_CMDCRCFAILMASK	(1 << 0)

commit 9cc639a20fdc0b935e55d4992f93963f95233ca4
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Wed May 15 20:48:23 2013 +0100

    ARM: 7725/1: mmc: mmci: Cache MMCIDATACTRL register
    
    Add a cache variable in the host struct that reflects the current data in
    the MMCIDATACTRL register. This patch will not introduce any functional
    change but instead provide an easy option to keep specific bits in the
    register between each data transfer.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index 1383c9ce2646..0b6cc54be966 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -183,6 +183,7 @@ struct mmci_host {
 	unsigned int		cclk;
 	u32			pwr_reg;
 	u32			clk_reg;
+	u32			datactrl_reg;
 	bool			vqmmc_enabled;
 	struct mmci_platform_data *plat;
 	struct variant_data	*variant;

commit 7c0136ef773c206e242b9718740377a45747bd70
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Tue May 14 13:53:10 2013 +0100

    ARM: 7721/1: mmc: mmci: Fixup regulator handling for vqmmc
    
    We can not rely on regulator_is_enabled to decide whether to
    enable|disable the regulator. It would mean that the reference
    counter for it is not balanced properly.
    
    Instead keep track of our internal state by using a new flag in
    the host struct, so we can take correct decisions.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index 1f33ad5333a0..1383c9ce2646 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -183,6 +183,7 @@ struct mmci_host {
 	unsigned int		cclk;
 	u32			pwr_reg;
 	u32			clk_reg;
+	bool			vqmmc_enabled;
 	struct mmci_platform_data *plat;
 	struct variant_data	*variant;
 

commit 3a37298ada749897ec2c5c1cdcd5932218eb2928
Author: Pawel Moll <pawel.moll@arm.com>
Date:   Thu Jan 24 14:12:45 2013 +0100

    ARM: 7631/1: mmc: mmci: Add new VE MMCI variant
    
    The Versatile Express IOFPGA as shipped on VECD 5.0 (bitfiles v108/208
    and v116/216) contains a modified version of the PL180 MMCI, with
    PeriphID Configuration value changed to 0x2.
    
    This version adds an optional "hardware flow control" feature. When
    enabled MMC card clock will be automatically disabled when FIFO is
    about to over/underflow and re-enabled once the host retrieved some
    data. This makes the controller immune to over/underrun errors caused
    by big interrupt handling latencies.
    
    This patch adds relevant device variant in the driver.
    
    Signed-off-by: Pawel Moll <pawel.moll@arm.com>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index a22213eeff88..1f33ad5333a0 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -28,6 +28,8 @@
 #define MCI_ST_UX500_NEG_EDGE	(1 << 13)
 #define MCI_ST_UX500_HWFCEN	(1 << 14)
 #define MCI_ST_UX500_CLK_INV	(1 << 15)
+/* Modified PL180 on Versatile Express platform */
+#define MCI_ARM_HWFCEN		(1 << 12)
 
 #define MMCIARGUMENT		0x008
 #define MMCICOMMAND		0x00c

commit 599c1d5c750ddf528c7c6d3cdc466708f0502e66
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Mon Jan 7 16:22:50 2013 +0100

    ARM: 7620/1: mmc: mmci: Convert to use mmc_regulator_get_supply
    
    By using the mmc_regulator_get_supply API we are able to do some
    cleanups of the regulator code. Additionally let the regulator
    API handle the error printing.
    
    Cc: Chris Ball <cjb@laptop.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index d34d8c0add8e..a22213eeff88 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -193,7 +193,6 @@ struct mmci_host {
 	/* pio stuff */
 	struct sg_mapping_iter	sg_miter;
 	unsigned int		size;
-	struct regulator	*vcc;
 
 	/* pinctrl handles */
 	struct pinctrl		*pinctrl;

commit a9a83785def8bf9142b37c86ffcb0fdc93fb851e
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Mon Oct 29 14:39:30 2012 +0100

    ARM: 7562/2: MMCI: fetch pinctrl handle and set default state
    
    This fetches the pinctrl resource for the MMCI driver, and if
    a "default" state is found, it is activated.
    
    Acked-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index d437ccf62d6b..d34d8c0add8e 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -195,6 +195,10 @@ struct mmci_host {
 	unsigned int		size;
 	struct regulator	*vcc;
 
+	/* pinctrl handles */
+	struct pinctrl		*pinctrl;
+	struct pinctrl_state	*pins_default;
+
 #ifdef CONFIG_DMA_ENGINE
 	/* DMA stuff */
 	struct dma_chan		*dma_current;

commit 7437cfa532842ce75189826742bddf1ba137f58e
Author: Ulf Hansson <ulf.hansson@stericsson.com>
Date:   Wed Jan 18 09:17:27 2012 +0100

    ARM: 7280/1: mmc: mmci: Cache MMCICLOCK and MMCIPOWER register
    
    Instead of reading a register value everytime we need to
    apply a new value for it, maintain a cached copy for it.
    This also means we are able to skip writes that are not
    needed.
    
    Tested-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@stericsson.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index 89eb2e3556d3..d437ccf62d6b 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -179,7 +179,8 @@ struct mmci_host {
 
 	unsigned int		mclk;
 	unsigned int		cclk;
-	u32			pwr;
+	u32			pwr_reg;
+	u32			clk_reg;
 	struct mmci_platform_data *plat;
 	struct variant_data	*variant;
 

commit 4d1a3a0dc551cfa7304ca46e014231500f3b81a6
Author: Ulf Hansson <ulf.hansson@stericsson.com>
Date:   Tue Dec 13 16:57:07 2011 +0100

    ARM: 7218/1: mmc: mmci: Provide option to configure bus signal direction
    
    The ST Micro variant supports bus signal direction indication. A new
    member in the variant struct is added for this.
    
    Moreover the actual signal direction configuration is board specific,
    thus the amba mmci platform data is extended with a new member to be
    able provide mmci with these specific board configurations.
    
    This patch is based upon a patch from Sebastian Rasmussen.
    
    Tested-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Sebastian Rasmussen <sebastian.rasmussen@stericsson.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@stericsson.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index 49f153e6ef7a..89eb2e3556d3 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -13,16 +13,6 @@
 #define MCI_PWR_ON		0x03
 #define MCI_OD			(1 << 6)
 #define MCI_ROD			(1 << 7)
-/*
- * The ST Micro version does not have ROD and reuse the voltage registers
- * for direction settings
- */
-#define MCI_ST_DATA2DIREN	(1 << 2)
-#define MCI_ST_CMDDIREN		(1 << 3)
-#define MCI_ST_DATA0DIREN	(1 << 4)
-#define MCI_ST_DATA31DIREN	(1 << 5)
-#define MCI_ST_FBCLKEN		(1 << 7)
-#define MCI_ST_DATA74DIREN	(1 << 8)
 
 #define MMCICLOCK		0x004
 #define MCI_CLK_ENABLE		(1 << 8)

commit 859dd55d91d977090efbba15c7dfc82e7ed774ef
Author: Ulf Hansson <ulf.hansson@stericsson.com>
Date:   Tue Dec 13 16:52:00 2011 +0100

    ARM: 7215/1: mmc: mmci: Increase max_segs from 16 to 128
    
    A significant increase (10-20%) in performance throughput for
    USB mass storage is the reason for incrementing the value.
    By some reason the USB driver allocates buffers which requires
    a scattergather list to contain a lot more than 16 elements to
    get optimal performance. This change sets the maximum elements
    to 128.
    
    Tests with large reads and large writes (100 MiB) show that the
    throughput increase is significant for write (10% for this test)
    but not for read. Tests are run on a Linux host with ext4 FS on
    the gadget mass storage device. The sg-len still exceeds 16 for
    the read tests but the performance gain is low or nothing.
    
    Tested-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Per Forlin <per.forlin@stericsson.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@stericsson.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index 79e4143ab9df..49f153e6ef7a 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -160,7 +160,7 @@
 	(MCI_RXFIFOHALFFULLMASK | MCI_RXDATAAVLBLMASK | \
 	 MCI_TXFIFOHALFEMPTYMASK)
 
-#define NR_SG		16
+#define NR_SG		128
 
 struct clk;
 struct variant_data;

commit 58c7ccbf9109abcc6b7ed2f76c21ebee244d31a8
Author: Per Forlin <per.forlin@linaro.org>
Date:   Fri Jul 1 18:55:24 2011 +0200

    mmc: mmci: implement pre_req() and post_req()
    
    pre_req() runs dma_map_sg() and prepares the dma descriptor for the next
    mmc data transfer. post_req() runs dma_unmap_sg.  If not calling pre_req()
    before mmci_request(), mmci_request() will prepare the cache and dma just
    like it did it before.  It is optional to use pre_req() and post_req()
    for mmci.
    
    Signed-off-by: Per Forlin <per.forlin@linaro.org>
    Tested-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index 2164e8c6476c..79e4143ab9df 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -166,6 +166,12 @@ struct clk;
 struct variant_data;
 struct dma_chan;
 
+struct mmci_host_next {
+	struct dma_async_tx_descriptor	*dma_desc;
+	struct dma_chan			*dma_chan;
+	s32				cookie;
+};
+
 struct mmci_host {
 	phys_addr_t		phybase;
 	void __iomem		*base;
@@ -203,6 +209,8 @@ struct mmci_host {
 	struct dma_chan		*dma_current;
 	struct dma_chan		*dma_rx_channel;
 	struct dma_chan		*dma_tx_channel;
+	struct dma_async_tx_descriptor	*dma_desc_current;
+	struct mmci_host_next	next_data;
 
 #define dma_inprogress(host)	((host)->dma_current)
 #else

commit 757df746fc5db0020ddab45914617a19d149c252
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Thu Jun 30 15:10:21 2011 +0100

    ARM: 6980/1: mmci: use StartBitErr to detect bad connections
    
    Stresstesting insert/remove of SD-cards can trigger
    a StartBitErr. This made the driver to hang in forever
    waiting for a non ocurring data timeout.
    
    This bit and interrupt is documented in the original
    PL180 TRM, just never implemented until now.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@stericsson.com>
    Reviewed-by: Linus Walleij <linus.walleij@stericsson.com>
    Reviewed-by: Jonas Aberg <jonas.aberg@stericsson.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index bb32e21c09db..2164e8c6476c 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -86,6 +86,7 @@
 #define MCI_CMDRESPEND		(1 << 6)
 #define MCI_CMDSENT		(1 << 7)
 #define MCI_DATAEND		(1 << 8)
+#define MCI_STARTBITERR		(1 << 9)
 #define MCI_DATABLOCKEND	(1 << 10)
 #define MCI_CMDACTIVE		(1 << 11)
 #define MCI_TXACTIVE		(1 << 12)
@@ -112,6 +113,7 @@
 #define MCI_CMDRESPENDCLR	(1 << 6)
 #define MCI_CMDSENTCLR		(1 << 7)
 #define MCI_DATAENDCLR		(1 << 8)
+#define MCI_STARTBITERRCLR	(1 << 9)
 #define MCI_DATABLOCKENDCLR	(1 << 10)
 /* Extended status bits for the ST Micro variants */
 #define MCI_ST_SDIOITC		(1 << 22)
@@ -127,6 +129,7 @@
 #define MCI_CMDRESPENDMASK	(1 << 6)
 #define MCI_CMDSENTMASK		(1 << 7)
 #define MCI_DATAENDMASK		(1 << 8)
+#define MCI_STARTBITERRMASK	(1 << 9)
 #define MCI_DATABLOCKENDMASK	(1 << 10)
 #define MCI_CMDACTIVEMASK	(1 << 11)
 #define MCI_TXACTIVEMASK	(1 << 12)
@@ -150,7 +153,7 @@
 #define MCI_IRQENABLE	\
 	(MCI_CMDCRCFAILMASK|MCI_DATACRCFAILMASK|MCI_CMDTIMEOUTMASK|	\
 	MCI_DATATIMEOUTMASK|MCI_TXUNDERRUNMASK|MCI_RXOVERRUNMASK|	\
-	MCI_CMDRESPENDMASK|MCI_CMDSENTMASK)
+	MCI_CMDRESPENDMASK|MCI_CMDSENTMASK|MCI_STARTBITERRMASK)
 
 /* These interrupts are directed to IRQ1 when two IRQ lines are available */
 #define MCI_IRQ1MASK \

commit 49ac215e071234b2bf2cff7b8bf4f4f3d0e8cd6e
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Fri Mar 4 14:54:16 2011 +0100

    ARM: 6785/1: mmci: separate out ST Micro register defines
    
    The mmci.h header contained a few registers not clearly marked
    as ST Micro only, rectify this and remove the HWFC magic in the
    process. The idea is to make the mmci.h header file more ordered
    so other vendors with PL180 derivates can see where to put in
    their custom register defines.
    
    Includes portions of an earlier patch from Sebastian Rasmussen.
    
    Acked-by: Sebastian Rasmussen <sebastian.rasmussen@stericsson.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index ec9a7bc6d0df..bb32e21c09db 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -11,23 +11,33 @@
 #define MCI_PWR_OFF		0x00
 #define MCI_PWR_UP		0x02
 #define MCI_PWR_ON		0x03
-#define MCI_DATA2DIREN		(1 << 2)
-#define MCI_CMDDIREN		(1 << 3)
-#define MCI_DATA0DIREN		(1 << 4)
-#define MCI_DATA31DIREN		(1 << 5)
 #define MCI_OD			(1 << 6)
 #define MCI_ROD			(1 << 7)
-/* The ST Micro version does not have ROD */
-#define MCI_FBCLKEN		(1 << 7)
-#define MCI_DATA74DIREN		(1 << 8)
+/*
+ * The ST Micro version does not have ROD and reuse the voltage registers
+ * for direction settings
+ */
+#define MCI_ST_DATA2DIREN	(1 << 2)
+#define MCI_ST_CMDDIREN		(1 << 3)
+#define MCI_ST_DATA0DIREN	(1 << 4)
+#define MCI_ST_DATA31DIREN	(1 << 5)
+#define MCI_ST_FBCLKEN		(1 << 7)
+#define MCI_ST_DATA74DIREN	(1 << 8)
 
 #define MMCICLOCK		0x004
 #define MCI_CLK_ENABLE		(1 << 8)
 #define MCI_CLK_PWRSAVE		(1 << 9)
 #define MCI_CLK_BYPASS		(1 << 10)
 #define MCI_4BIT_BUS		(1 << 11)
-/* 8bit wide buses supported in ST Micro versions */
+/*
+ * 8bit wide buses, hardware flow contronl, negative edges and clock inversion
+ * supported in ST Micro U300 and Ux500 versions
+ */
 #define MCI_ST_8BIT_BUS		(1 << 12)
+#define MCI_ST_U300_HWFCEN	(1 << 13)
+#define MCI_ST_UX500_NEG_EDGE	(1 << 13)
+#define MCI_ST_UX500_HWFCEN	(1 << 14)
+#define MCI_ST_UX500_CLK_INV	(1 << 15)
 
 #define MMCIARGUMENT		0x008
 #define MMCICOMMAND		0x00c
@@ -88,8 +98,9 @@
 #define MCI_RXFIFOEMPTY		(1 << 19)
 #define MCI_TXDATAAVLBL		(1 << 20)
 #define MCI_RXDATAAVLBL		(1 << 21)
-#define MCI_SDIOIT		(1 << 22)
-#define MCI_CEATAEND		(1 << 23)
+/* Extended status bits for the ST Micro variants */
+#define MCI_ST_SDIOIT		(1 << 22)
+#define MCI_ST_CEATAEND		(1 << 23)
 
 #define MMCICLEAR		0x038
 #define MCI_CMDCRCFAILCLR	(1 << 0)
@@ -102,8 +113,9 @@
 #define MCI_CMDSENTCLR		(1 << 7)
 #define MCI_DATAENDCLR		(1 << 8)
 #define MCI_DATABLOCKENDCLR	(1 << 10)
-#define MCI_SDIOITC		(1 << 22)
-#define MCI_CEATAENDC		(1 << 23)
+/* Extended status bits for the ST Micro variants */
+#define MCI_ST_SDIOITC		(1 << 22)
+#define MCI_ST_CEATAENDC	(1 << 23)
 
 #define MMCIMASK0		0x03c
 #define MCI_CMDCRCFAILMASK	(1 << 0)
@@ -127,8 +139,9 @@
 #define MCI_RXFIFOEMPTYMASK	(1 << 19)
 #define MCI_TXDATAAVLBLMASK	(1 << 20)
 #define MCI_RXDATAAVLBLMASK	(1 << 21)
-#define MCI_SDIOITMASK		(1 << 22)
-#define MCI_CEATAENDMASK	(1 << 23)
+/* Extended status bits for the ST Micro variants */
+#define MCI_ST_SDIOITMASK	(1 << 22)
+#define MCI_ST_CEATAENDMASK	(1 << 23)
 
 #define MMCIMASK1		0x040
 #define MMCIFIFOCNT		0x048

commit c8ebae37034c0ead62eb4df8ef88e999ddb8d5cf
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Tue Jan 11 19:35:53 2011 +0000

    ARM: mmci: add dmaengine-based DMA support
    
    Based on a patch from Linus Walleij.
    
    Add dmaengine based support for DMA to the MMCI driver, using the
    Primecell DMA engine interface.  The changes over Linus' driver are:
    
    - rename txsize_threshold to dmasize_threshold, as this reflects the
      purpose more.
    - use 'mmci_dma_' as the function prefix rather than 'dma_mmci_'.
    - clean up requesting of dma channels.
    - don't release a single channel twice when it's shared between tx and rx.
    - get rid of 'dma_enable' bool - instead check whether the channel is NULL.
    - detect incomplete DMA at the end of a transfer.  Some DMA controllers
      (eg, PL08x) are unable to be configured for scatter DMA and also listen
      to all four DMA request signals [BREQ,SREQ,LBREQ,LSREQ] from the MMCI.
      They can do one or other but not both.  As MMCI uses LBREQ/LSREQ for the
      final burst/words, PL08x does not transfer the last few words.
    - map and unmap DMA buffers using the DMA engine struct device, not the
      MMCI struct device - the DMA engine is doing the DMA transfer, not us.
    - avoid double-unmapping of the DMA buffers on MMCI data errors.
    - don't check for negative values from the dmaengine tx submission
      function - Dan says this must never fail.
    - use new dmaengine helper functions rather than using the ugly function
      pointers directly.
    - allow DMA code to be fully optimized away using dma_inprogress() which
      is defined to constant 0 if DMA engine support is disabled.
    - request maximum segment size from the DMA engine struct device and
      set this appropriately.
    - removed checking of buffer alignment - the DMA engine should deal with
      its own restrictions on buffer alignment, not the individual DMA engine
      users.
    - removed setting DMAREQCTL - this confuses some DMA controllers as it
      causes LBREQ to be asserted for the last seven transfers, rather than
      six SREQ and one LSREQ.
    - removed burst setting - the DMA controller should not burst past the
      transfer size required to complete the DMA operation.
    
    Tested-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index 164ce060fc1f..ec9a7bc6d0df 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -148,8 +148,10 @@
 
 struct clk;
 struct variant_data;
+struct dma_chan;
 
 struct mmci_host {
+	phys_addr_t		phybase;
 	void __iomem		*base;
 	struct mmc_request	*mrq;
 	struct mmc_command	*cmd;
@@ -179,5 +181,16 @@ struct mmci_host {
 	struct sg_mapping_iter	sg_miter;
 	unsigned int		size;
 	struct regulator	*vcc;
+
+#ifdef CONFIG_DMA_ENGINE
+	/* DMA stuff */
+	struct dma_chan		*dma_current;
+	struct dma_chan		*dma_rx_channel;
+	struct dma_chan		*dma_tx_channel;
+
+#define dma_inprogress(host)	((host)->dma_current)
+#else
+#define dma_inprogress(host)	(0)
+#endif
 };
 

commit 51d4375dd72f352594f1a4f1d7598bf9a75b8dfe
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Thu Jan 27 10:56:52 2011 +0000

    ARM: mmci: no need for separate host->data_xfered
    
    We don't need to store the number of bytes transferred in our host
    structure - we can store this directly in data->bytes_xfered.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index c1df7b82d36c..164ce060fc1f 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -161,8 +161,6 @@ struct mmci_host {
 	int			gpio_cd_irq;
 	bool			singleirq;
 
-	unsigned int		data_xfered;
-
 	spinlock_t		lock;
 
 	unsigned int		mclk;

commit 8cb2815574278a1bf966f041cbfe5b7c91472dcd
Author: Linus Walleij <linus.walleij@stericsson.com>
Date:   Mon Jan 24 15:22:13 2011 +0100

    ARM: 6632/3: mmci: stop using the blockend interrupts
    
    Implement a suggestion from Russell to drop the use of blockend
    interrupts altogether and instead rely on the data counter.
    
    Tested with error-free cards on U300, U8500 and RealView PB1176.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@stericsson.com>
    Signed-off-by: Linus Walleij <linus.walleij@stericsson.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index df06f01aac89..c1df7b82d36c 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -137,7 +137,7 @@
 #define MCI_IRQENABLE	\
 	(MCI_CMDCRCFAILMASK|MCI_DATACRCFAILMASK|MCI_CMDTIMEOUTMASK|	\
 	MCI_DATATIMEOUTMASK|MCI_TXUNDERRUNMASK|MCI_RXOVERRUNMASK|	\
-	MCI_CMDRESPENDMASK|MCI_CMDSENTMASK|MCI_DATABLOCKENDMASK)
+	MCI_CMDRESPENDMASK|MCI_CMDSENTMASK)
 
 /* These interrupts are directed to IRQ1 when two IRQ lines are available */
 #define MCI_IRQ1MASK \
@@ -177,9 +177,6 @@ struct mmci_host {
 	struct timer_list	timer;
 	unsigned int		oldstat;
 
-	bool			blockend;
-	bool			dataend;
-
 	/* pio stuff */
 	struct sg_mapping_iter	sg_miter;
 	unsigned int		size;

commit f20f8f21e0402c785c342547f7e49eafc42cfb52
Author: Linus Walleij <linus.walleij@stericsson.com>
Date:   Tue Oct 19 13:41:24 2010 +0100

    ARM: 6399/3: mmci: handle broken MCI_DATABLOCKEND hardware
    
    On the U300 the MCI_DATAEND and MCI_DATABLOCKEND IRQs can arrive
    out-of-order. Replace an ugly #ifdef hack with a proper runtime
    solution which models what is really happening.
    
    In the U300 DMA mode and on all Ux500 models, the MCI_DATABLOCKEND
    flag isn't properly cleared in hardware following and ACK leading
    to all kind of weird behaviour when the flag is still up in
    subsequent interrupts, so we add two flags indicating the
    error and handle this runtime.
    
    Cc: Rabin Vincent <rabin.vincent@stericsson.com>
    Signed-off-by: Linus Walleij <linus.walleij@stericsson.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index b4e48bde1b4e..df06f01aac89 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -177,6 +177,9 @@ struct mmci_host {
 	struct timer_list	timer;
 	unsigned int		oldstat;
 
+	bool			blockend;
+	bool			dataend;
+
 	/* pio stuff */
 	struct sg_mapping_iter	sg_miter;
 	unsigned int		size;

commit 2686b4b408c25349aee7b35558722d5730d67224
Author: Linus Walleij <linus.walleij@stericsson.com>
Date:   Tue Oct 19 12:39:48 2010 +0100

    ARM: 6311/2: mmci: work with only one irq
    
    The DBx500 variants have only one IRQ line hooked up.  Allow these (and
    any other implementations which choose to use only one irq) to work by
    directing the PIO interrupts also to the first IRQ line.
    
    Signed-off-by: Rabin Vincent <rabin.vincent@stericsson.com>
    Signed-off-by: Linus Walleij <linus.walleij@stericsson.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index 4ae887fc0189..b4e48bde1b4e 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -139,6 +139,11 @@
 	MCI_DATATIMEOUTMASK|MCI_TXUNDERRUNMASK|MCI_RXOVERRUNMASK|	\
 	MCI_CMDRESPENDMASK|MCI_CMDSENTMASK|MCI_DATABLOCKENDMASK)
 
+/* These interrupts are directed to IRQ1 when two IRQ lines are available */
+#define MCI_IRQ1MASK \
+	(MCI_RXFIFOHALFFULLMASK | MCI_RXDATAAVLBLMASK | \
+	 MCI_TXFIFOHALFEMPTYMASK)
+
 #define NR_SG		16
 
 struct clk;
@@ -154,6 +159,7 @@ struct mmci_host {
 	int			gpio_cd;
 	int			gpio_wp;
 	int			gpio_cd_irq;
+	bool			singleirq;
 
 	unsigned int		data_xfered;
 

commit 725343fa748fc9b7c883d198e9cec391425aa478
Author: Linus Walleij <linus.walleij@stericsson.com>
Date:   Sat Oct 9 13:43:21 2010 +0100

    ARM: 6437/2: mmci: add some register defines for ST Micro variants
    
    This adds a few registers to the MMCI/PL180 derivates that
    is used for some odd control stuff like SDIO.
    
    Signed-off-by: Marcin Mielczarczyk <marcin.mielczarczyk@tieto.com>
    Signed-off-by: Linus Walleij <linus.walleij@stericsson.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index c7d373c7aec9..4ae887fc0189 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -54,10 +54,16 @@
 #define MCI_DPSM_MODE		(1 << 2)
 #define MCI_DPSM_DMAENABLE	(1 << 3)
 #define MCI_DPSM_BLOCKSIZE	(1 << 4)
-#define MCI_DPSM_RWSTART	(1 << 8)
-#define MCI_DPSM_RWSTOP		(1 << 9)
-#define MCI_DPSM_RWMOD		(1 << 10)
-#define MCI_DPSM_SDIOEN		(1 << 11)
+/* Control register extensions in the ST Micro U300 and Ux500 versions */
+#define MCI_ST_DPSM_RWSTART	(1 << 8)
+#define MCI_ST_DPSM_RWSTOP	(1 << 9)
+#define MCI_ST_DPSM_RWMOD	(1 << 10)
+#define MCI_ST_DPSM_SDIOEN	(1 << 11)
+/* Control register extensions in the ST Micro Ux500 versions */
+#define MCI_ST_DPSM_DMAREQCTL	(1 << 12)
+#define MCI_ST_DPSM_DBOOTMODEEN	(1 << 13)
+#define MCI_ST_DPSM_BUSYMODE	(1 << 14)
+#define MCI_ST_DPSM_DDRMODE	(1 << 15)
 
 #define MMCIDATACNT		0x030
 #define MMCISTATUS		0x034

commit 148b8b39c156424da22693d26adcb69800faf95e
Author: Rabin Vincent <rabin.vincent@stericsson.com>
Date:   Mon Aug 9 12:55:48 2010 +0100

    ARM: 6308/1: mmci: support card detection interrupts
    
    If an IRQ can be requested on the card detected GPIO, use it instead of
    polling.
    
    Acked-by: Linus Walleij <linus.walleij@stericsson.com>
    Signed-off-by: Rabin Vincent <rabin.vincent@stericsson.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index 4e18f5403f48..c7d373c7aec9 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -147,6 +147,7 @@ struct mmci_host {
 	struct clk		*clk;
 	int			gpio_cd;
 	int			gpio_wp;
+	int			gpio_cd_irq;
 
 	unsigned int		data_xfered;
 

commit 8301bb68c6bb9836889641a47443aeb97b763f6c
Author: Rabin Vincent <rabin.vincent@stericsson.com>
Date:   Mon Aug 9 12:57:30 2010 +0100

    ARM: 6310/1: mmci: support different FIFO sizes
    
    The Ux500 variant has a 32-word FIFO (TXFIFOEMPTY is asserted when it
    has 2 left) and TXFIFOHALFEMPTY is repurposed as TXFIFOBURSTWRITEABLE,
    with a burst being defined as 8-words.  Likewise for RX.
    
    Acked-by: Linus Walleij <linus.walleij@stericsson.com>
    Signed-off-by: Rabin Vincent <rabin.vincent@stericsson.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index 68970cfb81e1..4e18f5403f48 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -133,13 +133,6 @@
 	MCI_DATATIMEOUTMASK|MCI_TXUNDERRUNMASK|MCI_RXOVERRUNMASK|	\
 	MCI_CMDRESPENDMASK|MCI_CMDSENTMASK|MCI_DATABLOCKENDMASK)
 
-/*
- * The size of the FIFO in bytes.
- */
-#define MCI_FIFOSIZE	(16*4)
-	
-#define MCI_FIFOHALFSIZE (MCI_FIFOSIZE / 2)
-
 #define NR_SG		16
 
 struct clk;

commit 4380c14fd77338bac9d1da4dc5dd9f6eb4966c82
Author: Rabin Vincent <rabin.vincent@stericsson.com>
Date:   Wed Jul 21 12:55:18 2010 +0100

    ARM: 6245/1: mmci: enable hardware flow control on Ux500 variants
    
    Although both the U300 and Ux500 use ST variants, the HWFCEN bits are at
    different positions, so use the variant_data to store the information.
    
    Acked-by: Linus Walleij <linus.walleij@stericsson.com>
    Signed-off-by: Rabin Vincent <rabin.vincent@stericsson.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index b98cc782402a..68970cfb81e1 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -28,8 +28,6 @@
 #define MCI_4BIT_BUS		(1 << 11)
 /* 8bit wide buses supported in ST Micro versions */
 #define MCI_ST_8BIT_BUS		(1 << 12)
-/* HW flow control on the ST Micro version */
-#define MCI_ST_FCEN		(1 << 13)
 
 #define MMCIARGUMENT		0x008
 #define MMCICOMMAND		0x00c

commit 4956e10903fd3459306dd9438c1e714ba3068a2a
Author: Rabin Vincent <rabin.vincent@stericsson.com>
Date:   Wed Jul 21 12:54:40 2010 +0100

    ARM: 6244/1: mmci: add variant data and default MCICLOCK support
    
    Add a variant_data structure to handle the differences between the
    various variants of this peripheral.  Add a first quirk for a default
    MCICLOCK value, required on the Ux500 variant where the enable bit needs
    to be always set, since it controls access to some registers.
    
    Acked-by: Linus Walleij <linus.walleij@stericsson.com>
    Signed-off-by: Rabin Vincent <rabin.vincent@stericsson.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index 7cb24ab1eecc..b98cc782402a 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -145,6 +145,7 @@
 #define NR_SG		16
 
 struct clk;
+struct variant_data;
 
 struct mmci_host {
 	void __iomem		*base;
@@ -164,6 +165,7 @@ struct mmci_host {
 	unsigned int		cclk;
 	u32			pwr;
 	struct mmci_platform_data *plat;
+	struct variant_data	*variant;
 
 	u8			hw_designer;
 	u8			hw_revision:4;

commit 4ce1d6cbf07271ab8f7cc47c3e27edeac08b58a7
Author: Rabin Vincent <rabin.vincent@stericsson.com>
Date:   Wed Jul 21 12:44:58 2010 +0100

    ARM: 6237/1: mmci: use sg_miter API to fix multi-page sg handling
    
    The mmci driver's SG list iteration logic assumes that each SG entry
    spans only one page, and only maps and flushes one page of the sg.  This
    is not a valid assumption.  Fix it by converting the driver to the
    sg_miter API, which correctly handles sgs which span multiple pages.
    
    Acked-by: Linus Walleij <linus.walleij@stericsson.com>
    Signed-off-by: Rabin Vincent <rabin.vincent@stericsson.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index d77062e5e3af..7cb24ab1eecc 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -171,42 +171,9 @@ struct mmci_host {
 	struct timer_list	timer;
 	unsigned int		oldstat;
 
-	unsigned int		sg_len;
-
 	/* pio stuff */
-	struct scatterlist	*sg_ptr;
-	unsigned int		sg_off;
+	struct sg_mapping_iter	sg_miter;
 	unsigned int		size;
 	struct regulator	*vcc;
 };
 
-static inline void mmci_init_sg(struct mmci_host *host, struct mmc_data *data)
-{
-	/*
-	 * Ideally, we want the higher levels to pass us a scatter list.
-	 */
-	host->sg_len = data->sg_len;
-	host->sg_ptr = data->sg;
-	host->sg_off = 0;
-}
-
-static inline int mmci_next_sg(struct mmci_host *host)
-{
-	host->sg_ptr++;
-	host->sg_off = 0;
-	return --host->sg_len;
-}
-
-static inline char *mmci_kmap_atomic(struct mmci_host *host, unsigned long *flags)
-{
-	struct scatterlist *sg = host->sg_ptr;
-
-	local_irq_save(*flags);
-	return kmap_atomic(sg_page(sg), KM_BIO_SRC_IRQ) + sg->offset;
-}
-
-static inline void mmci_kunmap_atomic(struct mmci_host *host, void *buffer, unsigned long *flags)
-{
-	kunmap_atomic(buffer, KM_BIO_SRC_IRQ);
-	local_irq_restore(*flags);
-}

commit 771dc157e06d69fcece0b2c8a29b9010345d8e9a
Author: Linus Walleij <linus.walleij@stericsson.com>
Date:   Thu Apr 8 07:38:52 2010 +0100

    ARM: 6032/1: ARM: MMCI: support 8bit mode on the ST Micro version
    
    This adds support for an 8bit wide bus to the card (data lines
    MCIDAT0 through 7 exist) on the ST Micro version and alters the
    U300 platform to support this. Also add some ST_ prefix to the
    ST-specific registers.
    
    Signed-off-by: Linus Walleij <linus.walleij@stericsson.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index 1ceb9a90f59b..d77062e5e3af 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -25,9 +25,11 @@
 #define MCI_CLK_ENABLE		(1 << 8)
 #define MCI_CLK_PWRSAVE		(1 << 9)
 #define MCI_CLK_BYPASS		(1 << 10)
-#define MCI_WIDE_BUS		(1 << 11)
+#define MCI_4BIT_BUS		(1 << 11)
+/* 8bit wide buses supported in ST Micro versions */
+#define MCI_ST_8BIT_BUS		(1 << 12)
 /* HW flow control on the ST Micro version */
-#define MCI_FCEN		(1 << 13)
+#define MCI_ST_FCEN		(1 << 13)
 
 #define MMCIARGUMENT		0x008
 #define MMCICOMMAND		0x00c

commit 34e84f39a27d059a3e6ec6e8b94aafa702e6f220
Author: Linus Walleij <linus.walleij@stericsson.com>
Date:   Tue Sep 22 14:41:40 2009 +0100

    ARM: 5721/1: MMCI enable the use of a regulator
    
    This enables the use of a regulator to power the MMCI/PL180
    PrimeCell. The OCR mask is calculated and voltage is set using
    the new MMC core functions for discovering voltage ranges
    in regulators. The platform translate_vdd function which basically
    controls the 4 lines out of the PL180 is disabled if you use a
    regulator instead.
    
    Signed-off-by: Linus Walleij <linus.walleij@stericsson.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index a7f9a51a0a3e..1ceb9a90f59b 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -175,6 +175,7 @@ struct mmci_host {
 	struct scatterlist	*sg_ptr;
 	unsigned int		sg_off;
 	unsigned int		size;
+	struct regulator	*vcc;
 };
 
 static inline void mmci_init_sg(struct mmci_host *host, struct mmc_data *data)

commit 6ef297f86b62f187c59475784208f75c2ed8ccd8
Author: Linus Walleij <linus.walleij@stericsson.com>
Date:   Tue Sep 22 14:29:36 2009 +0100

    ARM: 5720/1: Move MMCI header to amba include dir
    
    This moves the mmci platform data definition struct away from
    arch/arm/include/asm/mach/mmc.h into the more proper place among
    the other primecells in include/linux/amba/mmci.h and at the same
    time renames it to "mmci.h", and also the struct in this file
    confusingly named mmc_platform_data has been renamed
    mmci_platform_data for clarity.
    
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Linus Walleij <linus.walleij@stericsson.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index 839f264c9725..a7f9a51a0a3e 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -161,7 +161,7 @@ struct mmci_host {
 	unsigned int		mclk;
 	unsigned int		cclk;
 	u32			pwr;
-	struct mmc_platform_data *plat;
+	struct mmci_platform_data *plat;
 
 	u8			hw_designer;
 	u8			hw_revision:4;

commit 89001446925d6da8785c3265a71316e34c6d15de
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Thu Jul 9 15:16:07 2009 +0100

    MMC: MMCI: use gpiolib for card detect/write protect
    
    Use gpiolib where available (and when valid GPIOs are provided) for
    write protect/card detect status reporting.  We fall back to the old
    'status' method where gpiolib support is not available.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index 0441bac1c0ec..839f264c9725 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -151,6 +151,8 @@ struct mmci_host {
 	struct mmc_data		*data;
 	struct mmc_host		*mmc;
 	struct clk		*clk;
+	int			gpio_cd;
+	int			gpio_wp;
 
 	unsigned int		data_xfered;
 

commit cc30d60e4ca0b68e7e3f906eddd1e5b995d349f8
Author: Linus Walleij <linus.walleij@ericsson.com>
Date:   Sun Jan 4 15:18:54 2009 +0100

    mmci: Add support for ST Micro derivate
    
    This patch adds support for the ST Microelectronics version of
    the PL180 PrimeCell. They use designer ID 0x80 and have a few
    alterations/bugfixes related to open drain and HW flow control.
    They also add some SDIO registers, I am unsure if these are
    in ST HW only or if this is things also added in later ARM
    revisions, but they are included in the mmci.h file for
    completeness.
    
    Signed-off-by: Linus Walleij <linus.walleij@ericsson.com>
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index 0f39c490f022..0441bac1c0ec 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -11,13 +11,23 @@
 #define MCI_PWR_OFF		0x00
 #define MCI_PWR_UP		0x02
 #define MCI_PWR_ON		0x03
+#define MCI_DATA2DIREN		(1 << 2)
+#define MCI_CMDDIREN		(1 << 3)
+#define MCI_DATA0DIREN		(1 << 4)
+#define MCI_DATA31DIREN		(1 << 5)
 #define MCI_OD			(1 << 6)
 #define MCI_ROD			(1 << 7)
+/* The ST Micro version does not have ROD */
+#define MCI_FBCLKEN		(1 << 7)
+#define MCI_DATA74DIREN		(1 << 8)
 
 #define MMCICLOCK		0x004
 #define MCI_CLK_ENABLE		(1 << 8)
 #define MCI_CLK_PWRSAVE		(1 << 9)
 #define MCI_CLK_BYPASS		(1 << 10)
+#define MCI_WIDE_BUS		(1 << 11)
+/* HW flow control on the ST Micro version */
+#define MCI_FCEN		(1 << 13)
 
 #define MMCIARGUMENT		0x008
 #define MMCICOMMAND		0x00c
@@ -26,6 +36,10 @@
 #define MCI_CPSM_INTERRUPT	(1 << 8)
 #define MCI_CPSM_PENDING	(1 << 9)
 #define MCI_CPSM_ENABLE		(1 << 10)
+#define MCI_SDIO_SUSP		(1 << 11)
+#define MCI_ENCMD_COMPL		(1 << 12)
+#define MCI_NIEN		(1 << 13)
+#define MCI_CE_ATACMD		(1 << 14)
 
 #define MMCIRESPCMD		0x010
 #define MMCIRESPONSE0		0x014
@@ -39,6 +53,11 @@
 #define MCI_DPSM_DIRECTION	(1 << 1)
 #define MCI_DPSM_MODE		(1 << 2)
 #define MCI_DPSM_DMAENABLE	(1 << 3)
+#define MCI_DPSM_BLOCKSIZE	(1 << 4)
+#define MCI_DPSM_RWSTART	(1 << 8)
+#define MCI_DPSM_RWSTOP		(1 << 9)
+#define MCI_DPSM_RWMOD		(1 << 10)
+#define MCI_DPSM_SDIOEN		(1 << 11)
 
 #define MMCIDATACNT		0x030
 #define MMCISTATUS		0x034
@@ -63,6 +82,8 @@
 #define MCI_RXFIFOEMPTY		(1 << 19)
 #define MCI_TXDATAAVLBL		(1 << 20)
 #define MCI_RXDATAAVLBL		(1 << 21)
+#define MCI_SDIOIT		(1 << 22)
+#define MCI_CEATAEND		(1 << 23)
 
 #define MMCICLEAR		0x038
 #define MCI_CMDCRCFAILCLR	(1 << 0)
@@ -75,6 +96,8 @@
 #define MCI_CMDSENTCLR		(1 << 7)
 #define MCI_DATAENDCLR		(1 << 8)
 #define MCI_DATABLOCKENDCLR	(1 << 10)
+#define MCI_SDIOITC		(1 << 22)
+#define MCI_CEATAENDC		(1 << 23)
 
 #define MMCIMASK0		0x03c
 #define MCI_CMDCRCFAILMASK	(1 << 0)
@@ -98,6 +121,8 @@
 #define MCI_RXFIFOEMPTYMASK	(1 << 19)
 #define MCI_TXDATAAVLBLMASK	(1 << 20)
 #define MCI_RXDATAAVLBLMASK	(1 << 21)
+#define MCI_SDIOITMASK		(1 << 22)
+#define MCI_CEATAENDMASK	(1 << 23)
 
 #define MMCIMASK1		0x040
 #define MMCIFIFOCNT		0x048
@@ -136,6 +161,9 @@ struct mmci_host {
 	u32			pwr;
 	struct mmc_platform_data *plat;
 
+	u8			hw_designer;
+	u8			hw_revision:4;
+
 	struct timer_list	timer;
 	unsigned int		oldstat;
 

commit 4e0177647a3686f3658c26d52a60d0f1231c2127
Author: Emil Medve <Emilian.Medve@Freescale.com>
Date:   Tue Oct 23 20:37:24 2007 +0200

    mmc: fix sg->page fallout
    
    Signed-off-by: Emil Medve <Emilian.Medve@Freescale.com>
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index 000e6a919782..0f39c490f022 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -169,7 +169,7 @@ static inline char *mmci_kmap_atomic(struct mmci_host *host, unsigned long *flag
 	struct scatterlist *sg = host->sg_ptr;
 
 	local_irq_save(*flags);
-	return kmap_atomic(sg->page, KM_BIO_SRC_IRQ) + sg->offset;
+	return kmap_atomic(sg_page(sg), KM_BIO_SRC_IRQ) + sg->offset;
 }
 
 static inline void mmci_kunmap_atomic(struct mmci_host *host, void *buffer, unsigned long *flags)

commit 70f10482c668301c483acded13bf68780ad352b9
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Wed Jul 11 20:04:50 2007 +0200

    mmc: update header file paths
    
    Make sure all headers in the files reflect their true position
    in the tree.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index 6d7eadc9a678..000e6a919782 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -1,5 +1,5 @@
 /*
- *  linux/drivers/mmc/mmci.h - ARM PrimeCell MMCI PL180/1 driver
+ *  linux/drivers/mmc/host/mmci.h - ARM PrimeCell MMCI PL180/1 driver
  *
  *  Copyright (C) 2003 Deep Blue Solutions, Ltd, All Rights Reserved.
  *

commit 1c6a0718f0bfdab0d9b7da5f7b74f38a0058c03a
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Sun Feb 11 19:57:36 2007 +0100

    mmc: Move host and card drivers to subdirs
    
    Clean up the drivers/mmc directory by moving card and host drivers
    into subdirectories.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
new file mode 100644
index 000000000000..6d7eadc9a678
--- /dev/null
+++ b/drivers/mmc/host/mmci.h
@@ -0,0 +1,179 @@
+/*
+ *  linux/drivers/mmc/mmci.h - ARM PrimeCell MMCI PL180/1 driver
+ *
+ *  Copyright (C) 2003 Deep Blue Solutions, Ltd, All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#define MMCIPOWER		0x000
+#define MCI_PWR_OFF		0x00
+#define MCI_PWR_UP		0x02
+#define MCI_PWR_ON		0x03
+#define MCI_OD			(1 << 6)
+#define MCI_ROD			(1 << 7)
+
+#define MMCICLOCK		0x004
+#define MCI_CLK_ENABLE		(1 << 8)
+#define MCI_CLK_PWRSAVE		(1 << 9)
+#define MCI_CLK_BYPASS		(1 << 10)
+
+#define MMCIARGUMENT		0x008
+#define MMCICOMMAND		0x00c
+#define MCI_CPSM_RESPONSE	(1 << 6)
+#define MCI_CPSM_LONGRSP	(1 << 7)
+#define MCI_CPSM_INTERRUPT	(1 << 8)
+#define MCI_CPSM_PENDING	(1 << 9)
+#define MCI_CPSM_ENABLE		(1 << 10)
+
+#define MMCIRESPCMD		0x010
+#define MMCIRESPONSE0		0x014
+#define MMCIRESPONSE1		0x018
+#define MMCIRESPONSE2		0x01c
+#define MMCIRESPONSE3		0x020
+#define MMCIDATATIMER		0x024
+#define MMCIDATALENGTH		0x028
+#define MMCIDATACTRL		0x02c
+#define MCI_DPSM_ENABLE		(1 << 0)
+#define MCI_DPSM_DIRECTION	(1 << 1)
+#define MCI_DPSM_MODE		(1 << 2)
+#define MCI_DPSM_DMAENABLE	(1 << 3)
+
+#define MMCIDATACNT		0x030
+#define MMCISTATUS		0x034
+#define MCI_CMDCRCFAIL		(1 << 0)
+#define MCI_DATACRCFAIL		(1 << 1)
+#define MCI_CMDTIMEOUT		(1 << 2)
+#define MCI_DATATIMEOUT		(1 << 3)
+#define MCI_TXUNDERRUN		(1 << 4)
+#define MCI_RXOVERRUN		(1 << 5)
+#define MCI_CMDRESPEND		(1 << 6)
+#define MCI_CMDSENT		(1 << 7)
+#define MCI_DATAEND		(1 << 8)
+#define MCI_DATABLOCKEND	(1 << 10)
+#define MCI_CMDACTIVE		(1 << 11)
+#define MCI_TXACTIVE		(1 << 12)
+#define MCI_RXACTIVE		(1 << 13)
+#define MCI_TXFIFOHALFEMPTY	(1 << 14)
+#define MCI_RXFIFOHALFFULL	(1 << 15)
+#define MCI_TXFIFOFULL		(1 << 16)
+#define MCI_RXFIFOFULL		(1 << 17)
+#define MCI_TXFIFOEMPTY		(1 << 18)
+#define MCI_RXFIFOEMPTY		(1 << 19)
+#define MCI_TXDATAAVLBL		(1 << 20)
+#define MCI_RXDATAAVLBL		(1 << 21)
+
+#define MMCICLEAR		0x038
+#define MCI_CMDCRCFAILCLR	(1 << 0)
+#define MCI_DATACRCFAILCLR	(1 << 1)
+#define MCI_CMDTIMEOUTCLR	(1 << 2)
+#define MCI_DATATIMEOUTCLR	(1 << 3)
+#define MCI_TXUNDERRUNCLR	(1 << 4)
+#define MCI_RXOVERRUNCLR	(1 << 5)
+#define MCI_CMDRESPENDCLR	(1 << 6)
+#define MCI_CMDSENTCLR		(1 << 7)
+#define MCI_DATAENDCLR		(1 << 8)
+#define MCI_DATABLOCKENDCLR	(1 << 10)
+
+#define MMCIMASK0		0x03c
+#define MCI_CMDCRCFAILMASK	(1 << 0)
+#define MCI_DATACRCFAILMASK	(1 << 1)
+#define MCI_CMDTIMEOUTMASK	(1 << 2)
+#define MCI_DATATIMEOUTMASK	(1 << 3)
+#define MCI_TXUNDERRUNMASK	(1 << 4)
+#define MCI_RXOVERRUNMASK	(1 << 5)
+#define MCI_CMDRESPENDMASK	(1 << 6)
+#define MCI_CMDSENTMASK		(1 << 7)
+#define MCI_DATAENDMASK		(1 << 8)
+#define MCI_DATABLOCKENDMASK	(1 << 10)
+#define MCI_CMDACTIVEMASK	(1 << 11)
+#define MCI_TXACTIVEMASK	(1 << 12)
+#define MCI_RXACTIVEMASK	(1 << 13)
+#define MCI_TXFIFOHALFEMPTYMASK	(1 << 14)
+#define MCI_RXFIFOHALFFULLMASK	(1 << 15)
+#define MCI_TXFIFOFULLMASK	(1 << 16)
+#define MCI_RXFIFOFULLMASK	(1 << 17)
+#define MCI_TXFIFOEMPTYMASK	(1 << 18)
+#define MCI_RXFIFOEMPTYMASK	(1 << 19)
+#define MCI_TXDATAAVLBLMASK	(1 << 20)
+#define MCI_RXDATAAVLBLMASK	(1 << 21)
+
+#define MMCIMASK1		0x040
+#define MMCIFIFOCNT		0x048
+#define MMCIFIFO		0x080 /* to 0x0bc */
+
+#define MCI_IRQENABLE	\
+	(MCI_CMDCRCFAILMASK|MCI_DATACRCFAILMASK|MCI_CMDTIMEOUTMASK|	\
+	MCI_DATATIMEOUTMASK|MCI_TXUNDERRUNMASK|MCI_RXOVERRUNMASK|	\
+	MCI_CMDRESPENDMASK|MCI_CMDSENTMASK|MCI_DATABLOCKENDMASK)
+
+/*
+ * The size of the FIFO in bytes.
+ */
+#define MCI_FIFOSIZE	(16*4)
+	
+#define MCI_FIFOHALFSIZE (MCI_FIFOSIZE / 2)
+
+#define NR_SG		16
+
+struct clk;
+
+struct mmci_host {
+	void __iomem		*base;
+	struct mmc_request	*mrq;
+	struct mmc_command	*cmd;
+	struct mmc_data		*data;
+	struct mmc_host		*mmc;
+	struct clk		*clk;
+
+	unsigned int		data_xfered;
+
+	spinlock_t		lock;
+
+	unsigned int		mclk;
+	unsigned int		cclk;
+	u32			pwr;
+	struct mmc_platform_data *plat;
+
+	struct timer_list	timer;
+	unsigned int		oldstat;
+
+	unsigned int		sg_len;
+
+	/* pio stuff */
+	struct scatterlist	*sg_ptr;
+	unsigned int		sg_off;
+	unsigned int		size;
+};
+
+static inline void mmci_init_sg(struct mmci_host *host, struct mmc_data *data)
+{
+	/*
+	 * Ideally, we want the higher levels to pass us a scatter list.
+	 */
+	host->sg_len = data->sg_len;
+	host->sg_ptr = data->sg;
+	host->sg_off = 0;
+}
+
+static inline int mmci_next_sg(struct mmci_host *host)
+{
+	host->sg_ptr++;
+	host->sg_off = 0;
+	return --host->sg_len;
+}
+
+static inline char *mmci_kmap_atomic(struct mmci_host *host, unsigned long *flags)
+{
+	struct scatterlist *sg = host->sg_ptr;
+
+	local_irq_save(*flags);
+	return kmap_atomic(sg->page, KM_BIO_SRC_IRQ) + sg->offset;
+}
+
+static inline void mmci_kunmap_atomic(struct mmci_host *host, void *buffer, unsigned long *flags)
+{
+	kunmap_atomic(buffer, KM_BIO_SRC_IRQ);
+	local_irq_restore(*flags);
+}
