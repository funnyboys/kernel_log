commit 6db96e5810e0a6a345b7d78549de7676ae5b2662
Author: Baolin Wang <baolin.wang7@gmail.com>
Date:   Mon Apr 13 10:46:03 2020 +0800

    mmc: host: Introduce the request_atomic() for the host
    
    The SD host controller can process one request in the atomic context if
    the card is nonremovable, which means we can submit next request in the
    irq hard handler when using the MMC host software queue to reduce the
    latency. Thus this patch adds a new API request_atomic() for the host
    controller, as well as adding support for host software queue to submit
    a request by the new request_atomic() API.
    
    Moreover there is an unusual case that the card is busy when trying to
    send a command, and we can not polling the card status in interrupt
    context by using request_atomic() to dispatch requests. Thus we should
    queue a work to try again in the non-atomic context in case the host
    releases the busy signal later.
    
    Suggested-by: Adrian Hunter <adrian.hunter@intel.com>
    Acked-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Baolin Wang <baolin.wang7@gmail.com>
    Link: https://lore.kernel.org/r/a344e27e506cb2329073cbd5cf65e15cc3cbeba9.1586744073.git.baolin.wang7@gmail.com
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/host/mmc_hsq.h b/drivers/mmc/host/mmc_hsq.h
index 18b9cf55925f..ffdd9cd172c3 100644
--- a/drivers/mmc/host/mmc_hsq.h
+++ b/drivers/mmc/host/mmc_hsq.h
@@ -12,6 +12,7 @@ struct mmc_hsq {
 	wait_queue_head_t wait_queue;
 	struct hsq_slot *slot;
 	spinlock_t lock;
+	struct work_struct retry_work;
 
 	int next_tag;
 	int num_slots;

commit 511ce378e16f07b66ab78118587b7cc6ac197364
Author: Baolin Wang <baolin.wang@linaro.org>
Date:   Wed Feb 12 12:12:56 2020 +0800

    mmc: Add MMC host software queue support
    
    Now the MMC read/write stack will always wait for previous request is
    completed by mmc_blk_rw_wait(), before sending a new request to hardware,
    or queue a work to complete request, that will bring context switching
    overhead and spend some extra time to poll the card for busy completion
    for I/O writes via sending CMD13, especially for high I/O per second
    rates, to affect the IO performance.
    
    Thus this patch introduces MMC software queue interface based on the
    hardware command queue engine's interfaces, which is similar with the
    hardware command queue engine's idea, that can remove the context
    switching. Moreover we set the default queue depth as 64 for software
    queue, which allows more requests to be prepared, merged and inserted
    into IO scheduler to improve performance, but we only allow 2 requests
    in flight, that is enough to let the irq handler always trigger the
    next request without a context switch, as well as avoiding a long latency.
    
    Moreover the host controller should support HW busy detection for I/O
    operations when enabling the host software queue. That means, the host
    controller must not complete a data transfer request, until after the
    card stops signals busy.
    
    From the fio testing data in cover letter, we can see the software
    queue can improve some performance with 4K block size, increasing
    about 16% for random read, increasing about 90% for random write,
    though no obvious improvement for sequential read and write.
    
    Moreover we can expand the software queue interface to support MMC
    packed request or packed command in future.
    
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Baolin Wang <baolin.wang@linaro.org>
    Signed-off-by: Baolin Wang <baolin.wang7@gmail.com>
    Link: https://lore.kernel.org/r/4409c1586a9b3ed20d57ad2faf6c262fc3ccb6e2.1581478568.git.baolin.wang7@gmail.com
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/host/mmc_hsq.h b/drivers/mmc/host/mmc_hsq.h
new file mode 100644
index 000000000000..18b9cf55925f
--- /dev/null
+++ b/drivers/mmc/host/mmc_hsq.h
@@ -0,0 +1,30 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef LINUX_MMC_HSQ_H
+#define LINUX_MMC_HSQ_H
+
+struct hsq_slot {
+	struct mmc_request *mrq;
+};
+
+struct mmc_hsq {
+	struct mmc_host *mmc;
+	struct mmc_request *mrq;
+	wait_queue_head_t wait_queue;
+	struct hsq_slot *slot;
+	spinlock_t lock;
+
+	int next_tag;
+	int num_slots;
+	int qcnt;
+
+	bool enabled;
+	bool waiting_for_idle;
+	bool recovery_halt;
+};
+
+int mmc_hsq_init(struct mmc_hsq *hsq, struct mmc_host *mmc);
+void mmc_hsq_suspend(struct mmc_host *mmc);
+int mmc_hsq_resume(struct mmc_host *mmc);
+bool mmc_hsq_finalize_request(struct mmc_host *mmc, struct mmc_request *mrq);
+
+#endif
