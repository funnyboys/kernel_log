commit 7d79735d56a2f425f8c40054da0042b35c678839
Author: Martin Blumenstingl <martin.blumenstingl@googlemail.com>
Date:   Mon May 18 00:29:07 2020 +0200

    mmc: meson-mx-sdhc: Don't use literal 0 to initialize structs
    
    Kbuild test robot reports the following warning in lines 56 and 87 of
    drivers/mmc/host/meson-mx-sdhc-clkc.c:
      Using plain integer as NULL pointer
    
    Drop the integer value from the struct initialization to fix that
    warning. This will still ensure that the compiler will zero out the
    struct so it's in a well-defined state.
    
    Reported-by: kbuild test robot <lkp@intel.com>
    Signed-off-by: Martin Blumenstingl <martin.blumenstingl@googlemail.com>
    Link: https://lore.kernel.org/r/20200517222907.1277787-2-martin.blumenstingl@googlemail.com
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/host/meson-mx-sdhc-clkc.c b/drivers/mmc/host/meson-mx-sdhc-clkc.c
index ab0d6c68a078..e1f29b279123 100644
--- a/drivers/mmc/host/meson-mx-sdhc-clkc.c
+++ b/drivers/mmc/host/meson-mx-sdhc-clkc.c
@@ -53,7 +53,7 @@ static int meson_mx_sdhc_clk_hw_register(struct device *dev,
 					 const struct clk_ops *ops,
 					 struct clk_hw *hw)
 {
-	struct clk_init_data init = { 0 };
+	struct clk_init_data init = { };
 	char clk_name[32];
 
 	snprintf(clk_name, sizeof(clk_name), "%s#%s", dev_name(dev),
@@ -84,7 +84,7 @@ static int meson_mx_sdhc_gate_clk_hw_register(struct device *dev,
 int meson_mx_sdhc_register_clkc(struct device *dev, void __iomem *base,
 				struct clk_bulk_data *clk_bulk_data)
 {
-	struct clk_parent_data div_parent = { 0 };
+	struct clk_parent_data div_parent = { };
 	struct meson_mx_sdhc_clkc *clkc_data;
 	int ret;
 

commit e4bf1b0970ef96135c78c7dcf4e14484ce3b9804
Author: Martin Blumenstingl <martin.blumenstingl@googlemail.com>
Date:   Tue May 12 22:41:47 2020 +0200

    mmc: host: meson-mx-sdhc: new driver for the Amlogic Meson SDHC host
    
    The SDHC MMC host controller on Amlogic SoCs provides an eMMC and MMC
    card interface with 1/4/8-bit bus width.
    It supports eMMC spec 4.4x/4.5x including HS200 (up to 100MHz clock).
    
    The public S805 datasheet [0] contains a short documentation about the
    registers. Unfortunately it does not describe how to use the registers
    to make the hardware work. Thus this driver is based on reading (and
    understanding) the Amlogic 3.10 GPL kernel code.
    
    Some hardware details are not easy to see. Jianxin Pan was kind enough
    to answer my questions:
    The hardware has built-in busy timeout support. The maximum timeout is
    30 seconds. This is only documented in Amlogic's internal
    documentation.
    
    The controller only works with very specific clock configurations. The
    details are not part of the public datasheet. In my own words the
    supported configurations are:
    - 399.812kHz:   clkin =  850MHz div = 2126 sd_rx_phase = 63
    - 1MHz:         clkin =  850MHz div = 850  sd_rx_phase = 55
    - 5.986MHz:     clkin =  850MHz div = 142  sd_rx_phase = 24
    - 25MHz:        clkin =  850MHz div = 34   sd_rx_phase = 15
    - 47.222MHz:    clkin =  850MHz div = 18   sd_rx_phase = 11/15 (SDR50/HS)
    - 53.125MHz:    clkin =  850MHz div = 16   sd_rx_phase = (tuning)
    - 70.833MHz:    clkin =  850MHz div = 12   sd_rx_phase = (tuning)
    - 85MHz:        clkin =  850MHz div = 10   sd_rx_phase = (tuning)
    - 94.44MHz:     clkin =  850MHz div = 9    sd_rx_phase = (tuning)
    - 106.25MHz:    clkin =  850MHz div = 8    sd_rx_phase = (tuning)
    - 127.5MHz:     clkin = 1275MHz div = 10   sd_rx_phase = (tuning)
    - 141.667MHz:   clkin =  850MHz div = 6    sd_rx_phase = (tuning)
    - 159.375MHz:   clkin = 1275MHz div = 8    sd_rx_phase = (tuning)
    - 212.5MHz:     clkin = 1275MHz div = 6    sd_rx_phase = (tuning)
    - (sd_tx_phase is always 1, 94.44MHz is not listed in the datasheet
       but this is what the 3.10 BSP kernel on Odroid-C1 actually uses)
    
    NOTE: CMD23 support is disabled for now because it results in command
    timeouts and thus decreases read performance.
    
    Tested-by: Wei Wang <lnykww@gmail.com>
    Tested-by: Xin Yin <yinxin_1989@aliyun.com>
    Reviewed-by: Xin Yin <yinxin_1989@aliyun.com>
    Tested-by: Anand Moon <linux.amoon@gmail.com>
    Signed-off-by: Martin Blumenstingl <martin.blumenstingl@googlemail.com>
    Reviewed-by: Jerome Brunet <jbrunet@baylibre.com>
    Link: https://lore.kernel.org/r/20200512204147.504087-3-martin.blumenstingl@googlemail.com
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/mmc/host/meson-mx-sdhc-clkc.c b/drivers/mmc/host/meson-mx-sdhc-clkc.c
new file mode 100644
index 000000000000..ab0d6c68a078
--- /dev/null
+++ b/drivers/mmc/host/meson-mx-sdhc-clkc.c
@@ -0,0 +1,158 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Amlogic Meson SDHC clock controller
+ *
+ * Copyright (C) 2020 Martin Blumenstingl <martin.blumenstingl@googlemail.com>
+ */
+
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+
+#include "meson-mx-sdhc.h"
+
+#define MESON_SDHC_NUM_BUILTIN_CLKS	6
+
+struct meson_mx_sdhc_clkc {
+	struct clk_mux			src_sel;
+	struct clk_divider		div;
+	struct clk_gate			mod_clk_en;
+	struct clk_gate			tx_clk_en;
+	struct clk_gate			rx_clk_en;
+	struct clk_gate			sd_clk_en;
+};
+
+static const struct clk_parent_data meson_mx_sdhc_src_sel_parents[4] = {
+	{ .fw_name = "clkin0" },
+	{ .fw_name = "clkin1" },
+	{ .fw_name = "clkin2" },
+	{ .fw_name = "clkin3" },
+};
+
+static const struct clk_div_table meson_mx_sdhc_div_table[] = {
+	{ .div = 6, .val = 5, },
+	{ .div = 8, .val = 7, },
+	{ .div = 9, .val = 8, },
+	{ .div = 10, .val = 9, },
+	{ .div = 12, .val = 11, },
+	{ .div = 16, .val = 15, },
+	{ .div = 18, .val = 17, },
+	{ .div = 34, .val = 33, },
+	{ .div = 142, .val = 141, },
+	{ .div = 850, .val = 849, },
+	{ .div = 2126, .val = 2125, },
+	{ .div = 4096, .val = 4095, },
+	{ /* sentinel */ }
+};
+
+static int meson_mx_sdhc_clk_hw_register(struct device *dev,
+					 const char *name_suffix,
+					 const struct clk_parent_data *parents,
+					 unsigned int num_parents,
+					 const struct clk_ops *ops,
+					 struct clk_hw *hw)
+{
+	struct clk_init_data init = { 0 };
+	char clk_name[32];
+
+	snprintf(clk_name, sizeof(clk_name), "%s#%s", dev_name(dev),
+		 name_suffix);
+
+	init.name = clk_name;
+	init.ops = ops;
+	init.flags = CLK_SET_RATE_PARENT;
+	init.parent_data = parents;
+	init.num_parents = num_parents;
+
+	hw->init = &init;
+
+	return devm_clk_hw_register(dev, hw);
+}
+
+static int meson_mx_sdhc_gate_clk_hw_register(struct device *dev,
+					      const char *name_suffix,
+					      struct clk_hw *parent,
+					      struct clk_hw *hw)
+{
+	struct clk_parent_data parent_data = { .hw = parent };
+
+	return meson_mx_sdhc_clk_hw_register(dev, name_suffix, &parent_data, 1,
+					     &clk_gate_ops, hw);
+}
+
+int meson_mx_sdhc_register_clkc(struct device *dev, void __iomem *base,
+				struct clk_bulk_data *clk_bulk_data)
+{
+	struct clk_parent_data div_parent = { 0 };
+	struct meson_mx_sdhc_clkc *clkc_data;
+	int ret;
+
+	clkc_data = devm_kzalloc(dev, sizeof(*clkc_data), GFP_KERNEL);
+	if (!clkc_data)
+		return -ENOMEM;
+
+	clkc_data->src_sel.reg = base + MESON_SDHC_CLKC;
+	clkc_data->src_sel.mask = 0x3;
+	clkc_data->src_sel.shift = 16;
+	ret = meson_mx_sdhc_clk_hw_register(dev, "src_sel",
+					    meson_mx_sdhc_src_sel_parents, 4,
+					    &clk_mux_ops,
+					    &clkc_data->src_sel.hw);
+	if (ret)
+		return ret;
+
+	clkc_data->div.reg = base + MESON_SDHC_CLKC;
+	clkc_data->div.shift = 0;
+	clkc_data->div.width = 12;
+	clkc_data->div.table = meson_mx_sdhc_div_table;
+	div_parent.hw = &clkc_data->src_sel.hw;
+	ret = meson_mx_sdhc_clk_hw_register(dev, "div", &div_parent, 1,
+					    &clk_divider_ops,
+					    &clkc_data->div.hw);
+	if (ret)
+		return ret;
+
+	clkc_data->mod_clk_en.reg = base + MESON_SDHC_CLKC;
+	clkc_data->mod_clk_en.bit_idx = 15;
+	ret = meson_mx_sdhc_gate_clk_hw_register(dev, "mod_clk_on",
+						 &clkc_data->div.hw,
+						 &clkc_data->mod_clk_en.hw);
+	if (ret)
+		return ret;
+
+	clkc_data->tx_clk_en.reg = base + MESON_SDHC_CLKC;
+	clkc_data->tx_clk_en.bit_idx = 14;
+	ret = meson_mx_sdhc_gate_clk_hw_register(dev, "tx_clk_on",
+						 &clkc_data->div.hw,
+						 &clkc_data->tx_clk_en.hw);
+	if (ret)
+		return ret;
+
+	clkc_data->rx_clk_en.reg = base + MESON_SDHC_CLKC;
+	clkc_data->rx_clk_en.bit_idx = 13;
+	ret = meson_mx_sdhc_gate_clk_hw_register(dev, "rx_clk_on",
+						 &clkc_data->div.hw,
+						 &clkc_data->rx_clk_en.hw);
+	if (ret)
+		return ret;
+
+	clkc_data->sd_clk_en.reg = base + MESON_SDHC_CLKC;
+	clkc_data->sd_clk_en.bit_idx = 12;
+	ret = meson_mx_sdhc_gate_clk_hw_register(dev, "sd_clk_on",
+						 &clkc_data->div.hw,
+						 &clkc_data->sd_clk_en.hw);
+	if (ret)
+		return ret;
+
+	/*
+	 * TODO: Replace clk_hw.clk with devm_clk_hw_get_clk() once that is
+	 * available.
+	 */
+	clk_bulk_data[0].clk = clkc_data->mod_clk_en.hw.clk;
+	clk_bulk_data[1].clk = clkc_data->sd_clk_en.hw.clk;
+	clk_bulk_data[2].clk = clkc_data->tx_clk_en.hw.clk;
+	clk_bulk_data[3].clk = clkc_data->rx_clk_en.hw.clk;
+
+	return 0;
+}
