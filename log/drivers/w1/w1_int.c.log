commit c942fddf8793b2013be8c901b47d0a8dc02bf99f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:06 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 157
    
    Based on 3 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [kishon] [vijay] [abraham]
      [i] [kishon]@[ti] [com] this program is distributed in the hope that
      it will be useful but without any warranty without even the implied
      warranty of merchantability or fitness for a particular purpose see
      the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [graeme] [gregory]
      [gg]@[slimlogic] [co] [uk] [author] [kishon] [vijay] [abraham] [i]
      [kishon]@[ti] [com] [based] [on] [twl6030]_[usb] [c] [author] [hema]
      [hk] [hemahk]@[ti] [com] this program is distributed in the hope
      that it will be useful but without any warranty without even the
      implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1105 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.202006027@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/w1/w1_int.c b/drivers/w1/w1_int.c
index 1c776178f598..b3e1792d9c49 100644
--- a/drivers/w1/w1_int.c
+++ b/drivers/w1/w1_int.c
@@ -1,15 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Copyright (c) 2004 Evgeniy Polyakov <zbr@ioremap.net>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
  */
 
 #include <linux/kernel.h>

commit de0d6dbdbdb23ddb85f10d54a516e794f9a873e0
Author: Andrew F. Davis <afd@ti.com>
Date:   Mon Jun 5 08:52:08 2017 -0500

    w1: Add subsystem kernel public interface
    
    Like other subsystems we should be able to define slave devices outside
    of the w1 directory. To do this we move public facing interface
    definitions to include/linux/w1.h and rename the internal definition
    file to w1_internal.h.
    
    As w1_family.h and w1_int.h contained almost entirely public
    driver interface definitions we simply removed these files and
    moved the remaining definitions into w1_internal.h.
    
    With this we can now start to move slave devices out of w1/slaves and
    into the subsystem based on the function they implement, again like
    other drivers.
    
    Signed-off-by: Andrew F. Davis <afd@ti.com>
    Reviewed-by: Sebastian Reichel <sre@kernel.org>
    Acked-by: Evgeniy Polyakov <zbr@ioremap.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/w1/w1_int.c b/drivers/w1/w1_int.c
index 4439d10709bb..1c776178f598 100644
--- a/drivers/w1/w1_int.c
+++ b/drivers/w1/w1_int.c
@@ -21,9 +21,8 @@
 #include <linux/export.h>
 #include <linux/moduleparam.h>
 
-#include "w1.h"
+#include "w1_internal.h"
 #include "w1_netlink.h"
-#include "w1_int.h"
 
 static int w1_search_count = -1; /* Default is continual scan */
 module_param_named(search_count, w1_search_count, int, 0);

commit 50fa2951bd744d2a82aa33074001efac12d4e1cf
Author: Andrew F. Davis <afd@ti.com>
Date:   Tue May 16 15:02:12 2017 -0500

    w1: Organize driver source to natural/common order
    
    Structures and functions should be ordered such that forward declaration
    use is minimized.
    
    MODULE_* macros should immediately follow the structures and functions
    upon which they act.
    
    Remaining MODULE_* macros should be at the end of the file in
    alphabetical order.
    
    Signed-off-by: Andrew F. Davis <afd@ti.com>
    Acked-by: Evgeniy Polyakov <zbr@ioremap.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/w1/w1_int.c b/drivers/w1/w1_int.c
index 1072a2e620bb..4439d10709bb 100644
--- a/drivers/w1/w1_int.c
+++ b/drivers/w1/w1_int.c
@@ -179,6 +179,7 @@ int w1_add_master_device(struct w1_bus_master *master)
 
 	return retval;
 }
+EXPORT_SYMBOL(w1_add_master_device);
 
 void __w1_remove_master_device(struct w1_master *dev)
 {
@@ -251,6 +252,4 @@ void w1_remove_master_device(struct w1_bus_master *bm)
 
 	__w1_remove_master_device(found);
 }
-
-EXPORT_SYMBOL(w1_add_master_device);
 EXPORT_SYMBOL(w1_remove_master_device);

commit 91bd2855edbc6a941bf0b16990fbf2894c41c388
Author: Andrew F. Davis <afd@ti.com>
Date:   Thu Mar 16 10:19:54 2017 -0500

    w1: Remove unneeded use of assert() and remove w1_log.h
    
    The only use of assert() is in matrox_w1.c and is used to check the input
    to probe() from the PCI subsystem for NULL values, these are guaranteed
    to be populated and no other PCI driver makes this check, remove this.
    
    As this was the only definition in w1_log.h, remove this also.
    
    Signed-off-by: Andrew F. Davis <afd@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/w1/w1_int.c b/drivers/w1/w1_int.c
index 2cae7b29bb5f..1072a2e620bb 100644
--- a/drivers/w1/w1_int.c
+++ b/drivers/w1/w1_int.c
@@ -22,7 +22,6 @@
 #include <linux/moduleparam.h>
 
 #include "w1.h"
-#include "w1_log.h"
 #include "w1_netlink.h"
 #include "w1_int.h"
 

commit 3f07c0144132e4f59d88055ac8ff3e691a5fa2b8
Author: Ingo Molnar <mingo@kernel.org>
Date:   Wed Feb 8 18:51:30 2017 +0100

    sched/headers: Prepare for new header dependencies before moving code to <linux/sched/signal.h>
    
    We are going to split <linux/sched/signal.h> out of <linux/sched.h>, which
    will have to be picked up from other headers and a couple of .c files.
    
    Create a trivial placeholder <linux/sched/signal.h> file that just
    maps to <linux/sched.h> to make this patch obviously correct and
    bisectable.
    
    Include the new header in the files that are going to need it.
    
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/w1/w1_int.c b/drivers/w1/w1_int.c
index 4ce1b66d5092..2cae7b29bb5f 100644
--- a/drivers/w1/w1_int.c
+++ b/drivers/w1/w1_int.c
@@ -17,6 +17,7 @@
 #include <linux/delay.h>
 #include <linux/kthread.h>
 #include <linux/slab.h>
+#include <linux/sched/signal.h>
 #include <linux/export.h>
 #include <linux/moduleparam.h>
 

commit 8a0934bf9b2c5d4b6ead0bf6f3f3a21c540053c1
Author: Andrew F. Davis <afd@ti.com>
Date:   Thu Jan 5 14:37:46 2017 -0600

    w1: Fixup source file headers
    
    Remove filename from file, this is not done anymore as it doesn't
    add anything and usually is incorrect as filename change often.
    
    Also shorten the GPL to the more common address-less version and
    remove excess white-space.
    
    Signed-off-by: Andrew F. Davis <afd@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/w1/w1_int.c b/drivers/w1/w1_int.c
index 20f766afa4c7..4ce1b66d5092 100644
--- a/drivers/w1/w1_int.c
+++ b/drivers/w1/w1_int.c
@@ -1,9 +1,6 @@
 /*
- *	w1_int.c
- *
  * Copyright (c) 2004 Evgeniy Polyakov <zbr@ioremap.net>
  *
- *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
@@ -13,10 +10,6 @@
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
  */
 
 #include <linux/kernel.h>

commit 5052436dcb7eac532cf2ffd6650be01d3f15e0b5
Author: Levente Kurusa <levex@linux.com>
Date:   Mon Sep 14 10:56:12 2015 -0700

    drivers/w1/w1_int.c: call put_device if device_register fails
    
    Currently, memsetting and kfreeing the device is bad behaviour.  The
    device will have a reference count of 1 and hence can cause trouble
    because it has kfree'd.  Proper way to handle a failed device_register is
    to call put_device right after it fails.
    
    Signed-off-by: Levente Kurusa <levex@linux.com>
    Acked-by: Evgeniy Polyakov <zbr@ioremap.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/w1/w1_int.c b/drivers/w1/w1_int.c
index 47249a30eae3..20f766afa4c7 100644
--- a/drivers/w1/w1_int.c
+++ b/drivers/w1/w1_int.c
@@ -91,8 +91,7 @@ static struct w1_master *w1_alloc_dev(u32 id, int slave_count, int slave_ttl,
 	err = device_register(&dev->dev);
 	if (err) {
 		pr_err("Failed to register master device. err=%d\n", err);
-		memset(dev, 0, sizeof(struct w1_master));
-		kfree(dev);
+		put_device(&dev->dev);
 		dev = NULL;
 	}
 

commit fdc9167a7853523647ed0b19d719256c56f1f685
Author: Fjodor Schelichow <fjodor.schelichow@hotmail.com>
Date:   Thu Jun 19 02:52:00 2014 +0200

    w1: use pr_* instead of printk
    
    This patch replaces all calls to the "printk" function within the main "w1"
    directory by calls to the appropriate "pr_*" function thus addressing
    the following warning generated by the checkpatch script:
    
    WARNING: Prefer [subsystem eg: netdev]_err([subsystem]dev, ...
            then dev_err(dev, ... then pr_err(...  to printk(KERN_ERR ...
    
    Signed-off-by: Fjodor Schelichow <fjodor.schelichow@hotmail.com>
    Signed-off-by: Roman Sommer <romsom2@yahoo.de>
    Acked-by: Evgeniy Polyakov <zbr@ioremap.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/w1/w1_int.c b/drivers/w1/w1_int.c
index dfb6644028c0..47249a30eae3 100644
--- a/drivers/w1/w1_int.c
+++ b/drivers/w1/w1_int.c
@@ -50,8 +50,7 @@ static struct w1_master *w1_alloc_dev(u32 id, int slave_count, int slave_ttl,
 	 */
 	dev = kzalloc(sizeof(struct w1_master) + sizeof(struct w1_bus_master), GFP_KERNEL);
 	if (!dev) {
-		printk(KERN_ERR
-			"Failed to allocate %zd bytes for new w1 device.\n",
+		pr_err("Failed to allocate %zd bytes for new w1 device.\n",
 			sizeof(struct w1_master));
 		return NULL;
 	}
@@ -91,7 +90,7 @@ static struct w1_master *w1_alloc_dev(u32 id, int slave_count, int slave_ttl,
 
 	err = device_register(&dev->dev);
 	if (err) {
-		printk(KERN_ERR "Failed to register master device. err=%d\n", err);
+		pr_err("Failed to register master device. err=%d\n", err);
 		memset(dev, 0, sizeof(struct w1_master));
 		kfree(dev);
 		dev = NULL;
@@ -120,7 +119,7 @@ int w1_add_master_device(struct w1_bus_master *master)
 	if (!(master->touch_bit && master->reset_bus) &&
 	    !(master->write_bit && master->read_bit) &&
 	    !(master->write_byte && master->read_byte && master->reset_bus)) {
-		printk(KERN_ERR "w1_add_master_device: invalid function set\n");
+		pr_err("w1_add_master_device: invalid function set\n");
 		return(-EINVAL);
 	}
 
@@ -254,7 +253,7 @@ void w1_remove_master_device(struct w1_bus_master *bm)
 	}
 
 	if (!found) {
-		printk(KERN_ERR "Device doesn't exist.\n");
+		pr_err("Device doesn't exist.\n");
 		return;
 	}
 

commit 7242d42ace30825553eabd424b41b03136d37faa
Author: Thomas Wood <tommyandrena@gmail.com>
Date:   Fri May 30 16:10:20 2014 -0700

    drivers/w1/w1_int.c: Fix style errors.
    
    Replace spaces at beginning of the string with tabs, and replace foo * bar with foo *bar in a pointer declaration.
    
    Signed-off-by: Thomas Wood <tommyandrena@gmail.com>
    Acked-by: Evgeniy Polyakov <zbr@ioremap.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/w1/w1_int.c b/drivers/w1/w1_int.c
index 728039d2efe1..dfb6644028c0 100644
--- a/drivers/w1/w1_int.c
+++ b/drivers/w1/w1_int.c
@@ -38,7 +38,7 @@ module_param_named(search_count, w1_search_count, int, 0);
 static int w1_enable_pullup = 1;
 module_param_named(enable_pullup, w1_enable_pullup, int, 0);
 
-static struct w1_master * w1_alloc_dev(u32 id, int slave_count, int slave_ttl,
+static struct w1_master *w1_alloc_dev(u32 id, int slave_count, int slave_ttl,
 				       struct device_driver *driver,
 				       struct device *device)
 {
@@ -116,13 +116,13 @@ int w1_add_master_device(struct w1_bus_master *master)
 	struct w1_netlink_msg msg;
 	int id, found;
 
-        /* validate minimum functionality */
-        if (!(master->touch_bit && master->reset_bus) &&
-            !(master->write_bit && master->read_bit) &&
+	/* validate minimum functionality */
+	if (!(master->touch_bit && master->reset_bus) &&
+	    !(master->write_bit && master->read_bit) &&
 	    !(master->write_byte && master->read_byte && master->reset_bus)) {
 		printk(KERN_ERR "w1_add_master_device: invalid function set\n");
 		return(-EINVAL);
-        }
+	}
 
 	/* Lock until the device is added (or not) to w1_masters. */
 	mutex_lock(&w1_mlock);

commit a0f104644ec27ce5bbb36e950eb426dba9a3ad44
Author: Alexey Khoroshilov <khoroshilov@ispras.ru>
Date:   Wed May 7 01:26:04 2014 +0400

    w1: do not unlock unheld list_mutex in __w1_remove_master_device()
    
    w1_process_callbacks() expects to be called with dev->list_mutex held,
    but it is the fact only in w1_process(). __w1_remove_master_device()
    calls w1_process_callbacks() after it releases list_mutex.
    
    The patch fixes __w1_remove_master_device() to acquire list_mutex
    for w1_process_callbacks().
    
    Found by Linux Driver Verification project (linuxtesting.org).
    
    Signed-off-by: Alexey Khoroshilov <khoroshilov@ispras.ru>
    Acked-by: David Fries <david@fries.net>
    Acked-by: Evgeniy Polyakov <zbr@ioremap.net>
    Cc: stable <stable@vger.kernel.org> # 3.15
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/w1/w1_int.c b/drivers/w1/w1_int.c
index 9b084db739c7..728039d2efe1 100644
--- a/drivers/w1/w1_int.c
+++ b/drivers/w1/w1_int.c
@@ -219,9 +219,13 @@ void __w1_remove_master_device(struct w1_master *dev)
 
 		if (msleep_interruptible(1000))
 			flush_signals(current);
+		mutex_lock(&dev->list_mutex);
 		w1_process_callbacks(dev);
+		mutex_unlock(&dev->list_mutex);
 	}
+	mutex_lock(&dev->list_mutex);
 	w1_process_callbacks(dev);
+	mutex_unlock(&dev->list_mutex);
 
 	memset(&msg, 0, sizeof(msg));
 	msg.id.mst.id = dev->id;

commit b3be177a19f0f9e4f0deb473cef0e95e1254f2e9
Author: David Fries <David@Fries.net>
Date:   Wed Jan 15 22:29:25 2014 -0600

    w1: format for DocBook and fixes
    
    Switch the code documentation format style to DocBook format, enable
    DocBook documentation generation, and fix some comments.
    
    Signed-off-by: David Fries <David@Fries.net>
    Acked-by: Evgeniy Polyakov <zbr@ioremap.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/w1/w1_int.c b/drivers/w1/w1_int.c
index 66b2caae48f3..9b084db739c7 100644
--- a/drivers/w1/w1_int.c
+++ b/drivers/w1/w1_int.c
@@ -105,6 +105,10 @@ static void w1_free_dev(struct w1_master *dev)
 	device_unregister(&dev->dev);
 }
 
+/**
+ * w1_add_master_device() - registers a new master device
+ * @master:	master bus device to register
+ */
 int w1_add_master_device(struct w1_bus_master *master)
 {
 	struct w1_master *dev, *entry;
@@ -227,6 +231,10 @@ void __w1_remove_master_device(struct w1_master *dev)
 	w1_free_dev(dev);
 }
 
+/**
+ * w1_remove_master_device() - unregister a master device
+ * @bm:	master bus device to remove
+ */
 void w1_remove_master_device(struct w1_bus_master *bm)
 {
 	struct w1_master *dev, *found = NULL;

commit 9fcbbac5ded489c3a4e121343db999dd51cd6c75
Author: David Fries <David@Fries.net>
Date:   Wed Jan 15 22:29:18 2014 -0600

    w1: process w1 netlink commands in w1_process thread
    
    Netlink is a socket interface and is expected to be asynchronous.
    Clients can now make w1 requests without blocking by making use of the
    w1_master thread to process netlink commands which was previously only
    used for doing an automatic bus search.
    
    Signed-off-by: David Fries <David@Fries.net>
    Acked-by: Evgeniy Polyakov <zbr@ioremap.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/w1/w1_int.c b/drivers/w1/w1_int.c
index 423f3c2b9e7d..66b2caae48f3 100644
--- a/drivers/w1/w1_int.c
+++ b/drivers/w1/w1_int.c
@@ -75,8 +75,10 @@ static struct w1_master * w1_alloc_dev(u32 id, int slave_count, int slave_ttl,
 	atomic_set(&dev->refcnt, 2);
 
 	INIT_LIST_HEAD(&dev->slist);
+	INIT_LIST_HEAD(&dev->async_list);
 	mutex_init(&dev->mutex);
 	mutex_init(&dev->bus_mutex);
+	mutex_init(&dev->list_mutex);
 
 	memcpy(&dev->dev, device, sizeof(struct device));
 	dev_set_name(&dev->dev, "w1_bus_master%u", dev->id);
@@ -188,17 +190,22 @@ void __w1_remove_master_device(struct w1_master *dev)
 	struct w1_netlink_msg msg;
 	struct w1_slave *sl, *sln;
 
-	set_bit(W1_ABORT_SEARCH, &dev->flags);
-	kthread_stop(dev->thread);
-
 	mutex_lock(&w1_mlock);
 	list_del(&dev->w1_master_entry);
 	mutex_unlock(&w1_mlock);
 
+	set_bit(W1_ABORT_SEARCH, &dev->flags);
+	kthread_stop(dev->thread);
+
 	mutex_lock(&dev->mutex);
-	list_for_each_entry_safe(sl, sln, &dev->slist, w1_slave_entry)
+	mutex_lock(&dev->list_mutex);
+	list_for_each_entry_safe(sl, sln, &dev->slist, w1_slave_entry) {
+		mutex_unlock(&dev->list_mutex);
 		w1_slave_detach(sl);
+		mutex_lock(&dev->list_mutex);
+	}
 	w1_destroy_master_attributes(dev);
+	mutex_unlock(&dev->list_mutex);
 	mutex_unlock(&dev->mutex);
 	atomic_dec(&dev->refcnt);
 
@@ -208,7 +215,9 @@ void __w1_remove_master_device(struct w1_master *dev)
 
 		if (msleep_interruptible(1000))
 			flush_signals(current);
+		w1_process_callbacks(dev);
 	}
+	w1_process_callbacks(dev);
 
 	memset(&msg, 0, sizeof(msg));
 	msg.id.mst.id = dev->id;

commit 421056987620fecb43c22c558e127085c406b7ba
Author: David Fries <David@Fries.net>
Date:   Wed Jan 15 22:29:13 2014 -0600

    w1: fixup search to support abort from netlink
    
    Before 63706172f33 "rework kthread_stop()" kthread_should_stop()
    always returned false when called from a non-kthread task, after it
    would oops as a non-kthread didn't have that structure and netlink was
    calling search from a thread which wasn't a kthread.  9d1817cab2f030
    "w1: fix oops when w1_search is called from netlink connector",
    modified the code to avoid calling kthread_stop from a netlink thread.
    
    Introduce a w1_master flag and bit W1_ABORT_SEARCH to identify abort
    to cleanly support both kthread and netlink search abort.  A search
    can take seconds to run, so it is important to abort early if the
    hardware is removed in the middle of a search.
    
    Signed-off-by: David Fries <David@Fries.net>
    Acked-by: Evgeniy Polyakov <zbr@ioremap.net>
    Cc: Marcin Jurkowski <marcin1j@gmail.com>
    Cc: Josh Boyer <jwboyer@gmail.com>
    Cc: Sven Geggus <lists@fuchsschwanzdomain.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/w1/w1_int.c b/drivers/w1/w1_int.c
index 590bd8a7cd1b..423f3c2b9e7d 100644
--- a/drivers/w1/w1_int.c
+++ b/drivers/w1/w1_int.c
@@ -172,6 +172,7 @@ int w1_add_master_device(struct w1_bus_master *master)
 
 #if 0 /* Thread cleanup code, not required currently. */
 err_out_kill_thread:
+	set_bit(W1_ABORT_SEARCH, &dev->flags);
 	kthread_stop(dev->thread);
 #endif
 err_out_rm_attr:
@@ -187,6 +188,7 @@ void __w1_remove_master_device(struct w1_master *dev)
 	struct w1_netlink_msg msg;
 	struct w1_slave *sl, *sln;
 
+	set_bit(W1_ABORT_SEARCH, &dev->flags);
 	kthread_stop(dev->thread);
 
 	mutex_lock(&w1_mlock);

commit 3089a4c8d3abc7e2ab105d1d39d415110d1566d6
Author: Evgeny Boger <boger@contactless.ru>
Date:   Thu Jan 23 15:56:18 2014 -0800

    drivers/w1/masters/w1-gpio.c: add strong pullup emulation
    
    Strong pullup is emulated by driving pin logic high after write command
    when using tri-state push-pull GPIO.
    
    Signed-off-by: Evgeny Boger <boger@contactless.ru>
    Cc: Greg KH <greg@kroah.com>
    Acked-by: David Fries <david@fries.net>
    Acked-by: Evgeniy Polyakov <zbr@ioremap.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/w1/w1_int.c b/drivers/w1/w1_int.c
index 5a98649f6abc..590bd8a7cd1b 100644
--- a/drivers/w1/w1_int.c
+++ b/drivers/w1/w1_int.c
@@ -117,18 +117,6 @@ int w1_add_master_device(struct w1_bus_master *master)
 		printk(KERN_ERR "w1_add_master_device: invalid function set\n");
 		return(-EINVAL);
         }
-	/* While it would be electrically possible to make a device that
-	 * generated a strong pullup in bit bang mode, only hardware that
-	 * controls 1-wire time frames are even expected to support a strong
-	 * pullup.  w1_io.c would need to support calling set_pullup before
-	 * the last write_bit operation of a w1_write_8 which it currently
-	 * doesn't.
-	 */
-	if (!master->write_byte && !master->touch_bit && master->set_pullup) {
-		printk(KERN_ERR "w1_add_master_device: set_pullup requires "
-			"write_byte or touch_bit, disabling\n");
-		master->set_pullup = NULL;
-	}
 
 	/* Lock until the device is added (or not) to w1_masters. */
 	mutex_lock(&w1_mlock);

commit 679012655acecfa807038ccf9237bba246f9fad8
Author: Otavio Salvador <otavio@ossystems.com.br>
Date:   Sun Jun 17 12:17:31 2012 -0300

    w1: Fix a typo in 'hardware' word
    
    Signed-off-by: Otavio Salvador <otavio@ossystems.com.br>
    Acked-by: Evgeniy Polyakov <zbr@ioremap.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/w1/w1_int.c b/drivers/w1/w1_int.c
index 531434180afd..5a98649f6abc 100644
--- a/drivers/w1/w1_int.c
+++ b/drivers/w1/w1_int.c
@@ -118,7 +118,7 @@ int w1_add_master_device(struct w1_bus_master *master)
 		return(-EINVAL);
         }
 	/* While it would be electrically possible to make a device that
-	 * generated a strong pullup in bit bang mode, only hardare that
+	 * generated a strong pullup in bit bang mode, only hardware that
 	 * controls 1-wire time frames are even expected to support a strong
 	 * pullup.  w1_io.c would need to support calling set_pullup before
 	 * the last write_bit operation of a w1_write_8 which it currently

commit b02f8bede217a4b145ecc16d3940c78d83941147
Author: NeilBrown <neilb@suse.de>
Date:   Fri May 18 15:59:52 2012 +1000

    W1: split master mutex to avoid deadlocks.
    
    The 'mutex' in struct w1_master is use for two very different
    purposes.
    
    Firstly it protects various data structures such as the list of all
    slaves.
    
    Secondly it protects the w1 buss against concurrent accesses.
    
    This can lead to deadlocks when the ->probe code called while adding a
    slave needs to talk on the bus, as is the case for power_supply
    devices.
    ds2780 and ds2781 drivers contain a work around to track which
    process hold the lock simply to avoid this deadlock.  bq27000 doesn't
    have that work around and so deadlocks.
    
    There are other possible deadlocks involving sysfs.
    When removing a device the sysfs s_active lock is held, so the lock
    that protects the slave list must take precedence over s_active.
    However when access power_supply attributes via sysfs, the s_active
    lock must take precedence over the lock that protects accesses to
    the bus.
    
    So to avoid deadlocks between w1 slaves and sysfs, these must be
    two separate locks.  Making them separate means that the work around
    in ds2780 and ds2781 can be removed.
    
    So this patch:
     - adds a new mutex: "bus_mutex" which serialises access to the bus.
     - takes in mutex in w1_search and ds1wm_search while they access
       the bus for searching.  The mutex is dropped before calling the
       callback which adds the slave.
     - changes all slaves to use bus_mutex instead of mutex to
       protect access to the bus
     - removes w1_ds2790_io_nolock and w1_ds2781_io_nolock, and the
       related code from drivers/power/ds278[01]_battery.c which
       calls them.
    
    Signed-off-by: NeilBrown <neilb@suse.de>
    Acked-by: Evgeniy Polyakov <zbr@ioremap.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/w1/w1_int.c b/drivers/w1/w1_int.c
index 68288355727a..531434180afd 100644
--- a/drivers/w1/w1_int.c
+++ b/drivers/w1/w1_int.c
@@ -76,6 +76,7 @@ static struct w1_master * w1_alloc_dev(u32 id, int slave_count, int slave_ttl,
 
 	INIT_LIST_HEAD(&dev->slist);
 	mutex_init(&dev->mutex);
+	mutex_init(&dev->bus_mutex);
 
 	memcpy(&dev->dev, device, sizeof(struct device));
 	dev_set_name(&dev->dev, "w1_bus_master%u", dev->id);

commit 32aaeffbd4a7457bf2f7448b33b5946ff2a960eb
Merge: 208bca086040 67b84999b1a8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Nov 6 19:44:47 2011 -0800

    Merge branch 'modsplit-Oct31_2011' of git://git.kernel.org/pub/scm/linux/kernel/git/paulg/linux
    
    * 'modsplit-Oct31_2011' of git://git.kernel.org/pub/scm/linux/kernel/git/paulg/linux: (230 commits)
      Revert "tracing: Include module.h in define_trace.h"
      irq: don't put module.h into irq.h for tracking irqgen modules.
      bluetooth: macroize two small inlines to avoid module.h
      ip_vs.h: fix implicit use of module_get/module_put from module.h
      nf_conntrack.h: fix up fallout from implicit moduleparam.h presence
      include: replace linux/module.h with "struct module" wherever possible
      include: convert various register fcns to macros to avoid include chaining
      crypto.h: remove unused crypto_tfm_alg_modname() inline
      uwb.h: fix implicit use of asm/page.h for PAGE_SIZE
      pm_runtime.h: explicitly requires notifier.h
      linux/dmaengine.h: fix implicit use of bitmap.h and asm/page.h
      miscdevice.h: fix up implicit use of lists and types
      stop_machine.h: fix implicit use of smp.h for smp_processor_id
      of: fix implicit use of errno.h in include/linux/of.h
      of_platform.h: delete needless include <linux/module.h>
      acpi: remove module.h include from platform/aclinux.h
      miscdevice.h: delete unnecessary inclusion of module.h
      device_cgroup.h: delete needless include <linux/module.h>
      net: sch_generic remove redundant use of <linux/module.h>
      net: inet_timewait_sock doesnt need <linux/module.h>
      ...
    
    Fix up trivial conflicts (other header files, and  removal of the ab3550 mfd driver) in
     - drivers/media/dvb/frontends/dibx000_common.c
     - drivers/media/video/{mt9m111.c,ov6650.c}
     - drivers/mfd/ab3550-core.c
     - include/linux/dmaengine.h

commit 68a436aec345c2bcd05dbdafae1f5f608ff8f61f
Author: Florian Faber <faber@faberman.de>
Date:   Wed Nov 2 13:39:59 2011 -0700

    drivers/w1/w1_int.c: multiple masters used same init_name
    
    When using multiple masters, w1_int.c would use the .init_name from w1.c
    for all entities, which will fail when creating a corresponding sysfs
    entry.  This patch uses the unique name previously generated.
    
      WARNING: at fs/sysfs/dir.c:451 sysfs_add_one+0x48/0x64()
      sysfs: cannot create duplicate filename '/devices/w1 bus master'
      Modules linked in:
      Call trace:
       [<9001a604>] warn_slowpath_common+0x34/0x44
       [<9001a64c>] warn_slowpath_fmt+0x14/0x18
       [<90078020>] sysfs_add_one+0x48/0x64
       [<900784ec>] create_dir+0x40/0x68
       [<9007857a>] sysfs_create_dir+0x66/0x78
       [<900c1a8a>] kobject_add_internal+0x6e/0x104
       [<900c1bc0>] kobject_add_varg+0x20/0x2c
       [<900c1c1c>] kobject_add+0x30/0x3c
       [<900dbd66>] device_add+0x6a/0x378
       [<900dbb4a>] device_initialize+0x12/0x48
       [<900dc080>] device_register+0xc/0x10
       [<900f99be>] w1_add_master_device+0x162/0x274
       [<90008e7a>] w1_gpio_probe+0x66/0xb4
       [<9000030c>] kernel_init+0x0/0xe8
       [<900dde54>] platform_drv_probe+0xc/0xe
       [<9000030c>] kernel_init+0x0/0xe8
       [<900dd4f8>] driver_probe_device+0x6c/0xdc
       [<900dd5fc>] __driver_attach+0x34/0x48
       [<900dcce8>] bus_for_each_dev+0x2c/0x48
       [<900dd5c8>] __driver_attach+0x0/0x48
       [<900dd38c>] driver_attach+0x10/0x14
       [<900dd16a>] bus_add_driver+0x6a/0x18c
       [<900dd768>] driver_register+0x60/0xb8
       [<90011594>] __initcall_w1_therm_init6+0x0/0x4
       [<90008e00>] w1_gpio_init+0x0/0x14
       [<9000030c>] kernel_init+0x0/0xe8
       [<900ddf48>] platform_driver_register+0x30/0x38
       [<90011594>] __initcall_w1_therm_init6+0x0/0x4
       [<90008e00>] w1_gpio_init+0x0/0x14
       [<9000030c>] kernel_init+0x0/0xe8
       [<900ddf5e>] platform_driver_probe+0xe/0x3c
       [<90008e0c>] w1_gpio_init+0xc/0x14
       [<90011594>] __initcall_w1_therm_init6+0x0/0x4
       [<90008e00>] w1_gpio_init+0x0/0x14
       [<900126d4>] do_one_initcall+0x34/0x130
       [<90000372>] kernel_init+0x66/0xe8
       [<90011594>] __initcall_w1_therm_init6+0x0/0x4
       [<9001ca3e>] do_exit+0x0/0x3a6
       [<9000030c>] kernel_init+0x0/0xe8
       [<9001ca3e>] do_exit+0x0/0x3a6
    
      ---[ end trace 5a9233884fead918 ]---
      kobject_add_internal failed for w1 bus master with -EEXIST, don't try to register things with the same name in the same directory.
    
    Signed-off-by: Florian Faber <faber@faberman.de>
    Cc: Evgeniy Polyakov <zbr@ioremap.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/w1/w1_int.c b/drivers/w1/w1_int.c
index d220bce2cee4..f79e62e54e8d 100644
--- a/drivers/w1/w1_int.c
+++ b/drivers/w1/w1_int.c
@@ -78,6 +78,7 @@ static struct w1_master * w1_alloc_dev(u32 id, int slave_count, int slave_ttl,
 	memcpy(&dev->dev, device, sizeof(struct device));
 	dev_set_name(&dev->dev, "w1_bus_master%u", dev->id);
 	snprintf(dev->name, sizeof(dev->name), "w1_bus_master%u", dev->id);
+	dev->dev.init_name = dev->name;
 
 	dev->driver = driver;
 

commit 4d184129b2f91e41d357e920a25a83317d79dfe2
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Thu Sep 15 23:09:52 2011 -0400

    drivers/w1: Add moduleparam.h to drivers/w1/w1_int.c
    
    It doesn't need the full module.h but it was getting moduleparam.h
    from the fact that module.h was everywhere.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/drivers/w1/w1_int.c b/drivers/w1/w1_int.c
index aa3971ce02b0..c1591e518073 100644
--- a/drivers/w1/w1_int.c
+++ b/drivers/w1/w1_int.c
@@ -25,6 +25,7 @@
 #include <linux/kthread.h>
 #include <linux/slab.h>
 #include <linux/export.h>
+#include <linux/moduleparam.h>
 
 #include "w1.h"
 #include "w1_log.h"

commit 9623932cd5815e280cef5ebb54b5ee92bec382ad
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Sun Jul 10 13:21:52 2011 -0400

    drivers/w1: Add export.h for EXPORT_SYMBOL/THIS_MODULE
    
    Give these files export.h so that they can reliably get the EXPORT_SYMBOL
    and THIS_MODULE macros in the future, once module.h isn't implicitly
    everywhere.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/drivers/w1/w1_int.c b/drivers/w1/w1_int.c
index d220bce2cee4..aa3971ce02b0 100644
--- a/drivers/w1/w1_int.c
+++ b/drivers/w1/w1_int.c
@@ -24,6 +24,7 @@
 #include <linux/delay.h>
 #include <linux/kthread.h>
 #include <linux/slab.h>
+#include <linux/export.h>
 
 #include "w1.h"
 #include "w1_log.h"

commit a801876638c5ce650223476c4eb8f37cea32dc1c
Author: Evgeniy Polyakov <zbr@ioremap.net>
Date:   Thu Aug 25 15:59:06 2011 -0700

    MAINTAINERS: Evgeniy has moved
    
    Signed-off-by: Evgeniy Polyakov <zbr@ioremap.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/w1/w1_int.c b/drivers/w1/w1_int.c
index b50be3f1073d..d220bce2cee4 100644
--- a/drivers/w1/w1_int.c
+++ b/drivers/w1/w1_int.c
@@ -1,7 +1,7 @@
 /*
  *	w1_int.c
  *
- * Copyright (c) 2004 Evgeniy Polyakov <johnpol@2ka.mipt.ru>
+ * Copyright (c) 2004 Evgeniy Polyakov <zbr@ioremap.net>
  *
  *
  * This program is free software; you can redistribute it and/or modify

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/w1/w1_int.c b/drivers/w1/w1_int.c
index 4a46ed58ece9..b50be3f1073d 100644
--- a/drivers/w1/w1_int.c
+++ b/drivers/w1/w1_int.c
@@ -23,6 +23,7 @@
 #include <linux/list.h>
 #include <linux/delay.h>
 #include <linux/kthread.h>
+#include <linux/slab.h>
 
 #include "w1.h"
 #include "w1_log.h"

commit 40f91de6a1d65a2d0ce8bc296ed0a2d53d63c845
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Tue Jan 6 10:44:34 2009 -0800

    w1: struct device - replace bus_id with dev_name(), dev_set_name()
    
    CC: Evgeniy Polyakov <johnpol@2ka.mipt.ru>
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/w1/w1_int.c b/drivers/w1/w1_int.c
index a3a54567bfba..4a46ed58ece9 100644
--- a/drivers/w1/w1_int.c
+++ b/drivers/w1/w1_int.c
@@ -75,8 +75,7 @@ static struct w1_master * w1_alloc_dev(u32 id, int slave_count, int slave_ttl,
 	mutex_init(&dev->mutex);
 
 	memcpy(&dev->dev, device, sizeof(struct device));
-	snprintf(dev->dev.bus_id, sizeof(dev->dev.bus_id),
-		  "w1_bus_master%u", dev->id);
+	dev_set_name(&dev->dev, "w1_bus_master%u", dev->id);
 	snprintf(dev->name, sizeof(dev->name), "w1_bus_master%u", dev->id);
 
 	dev->driver = driver;

commit af00a2d5a047455b35d1e7dc4c7d9993c2bcfb93
Author: David Fries <david@fries.net>
Date:   Wed Oct 15 22:04:53 2008 -0700

    W1: w1_int.c use first available master number
    
    Follow the example of other devices (like the joystick device).  Pick the
    first available id for each detected device.  Currently for USB devices,
    suspending and resuming would cause the number to increment.
    
    Signed-off-by: David Fries <david@fries.net>
    Signed-off-by: Evgeniy Polyakov <johnpol@2ka.mipt.ru>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/w1/w1_int.c b/drivers/w1/w1_int.c
index 3fd6e6651fbe..a3a54567bfba 100644
--- a/drivers/w1/w1_int.c
+++ b/drivers/w1/w1_int.c
@@ -29,7 +29,6 @@
 #include "w1_netlink.h"
 #include "w1_int.h"
 
-static u32 w1_ids = 1;
 static int w1_search_count = -1; /* Default is continual scan */
 module_param_named(search_count, w1_search_count, int, 0);
 
@@ -102,9 +101,10 @@ static void w1_free_dev(struct w1_master *dev)
 
 int w1_add_master_device(struct w1_bus_master *master)
 {
-	struct w1_master *dev;
+	struct w1_master *dev, *entry;
 	int retval = 0;
 	struct w1_netlink_msg msg;
+	int id, found;
 
         /* validate minimum functionality */
         if (!(master->touch_bit && master->reset_bus) &&
@@ -126,13 +126,33 @@ int w1_add_master_device(struct w1_bus_master *master)
 		master->set_pullup = NULL;
 	}
 
-	dev = w1_alloc_dev(w1_ids++, w1_max_slave_count, w1_max_slave_ttl, &w1_master_driver, &w1_master_device);
-	if (!dev)
+	/* Lock until the device is added (or not) to w1_masters. */
+	mutex_lock(&w1_mlock);
+	/* Search for the first available id (starting at 1). */
+	id = 0;
+	do {
+		++id;
+		found = 0;
+		list_for_each_entry(entry, &w1_masters, w1_master_entry) {
+			if (entry->id == id) {
+				found = 1;
+				break;
+			}
+		}
+	} while (found);
+
+	dev = w1_alloc_dev(id, w1_max_slave_count, w1_max_slave_ttl,
+		&w1_master_driver, &w1_master_device);
+	if (!dev) {
+		mutex_unlock(&w1_mlock);
 		return -ENOMEM;
+	}
 
 	retval =  w1_create_master_attributes(dev);
-	if (retval)
+	if (retval) {
+		mutex_unlock(&w1_mlock);
 		goto err_out_free_dev;
+	}
 
 	memcpy(dev->bus_master, master, sizeof(struct w1_bus_master));
 
@@ -144,10 +164,10 @@ int w1_add_master_device(struct w1_bus_master *master)
 		dev_err(&dev->dev,
 			 "Failed to create new kernel thread. err=%d\n",
 			 retval);
+		mutex_unlock(&w1_mlock);
 		goto err_out_rm_attr;
 	}
 
-	mutex_lock(&w1_mlock);
 	list_add(&dev->w1_master_entry, &w1_masters);
 	mutex_unlock(&w1_mlock);
 

commit 9141f57c7edd40a48a41b7e31427c4b2831a36af
Author: David Fries <david@fries.net>
Date:   Wed Oct 15 22:04:45 2008 -0700

    W1: new module parameter search_count
    
    Added a new module parameter search_count which allows overriding the
    default search count.  -1 continual, 0 disabled, N that many times.
    
    Signed-off-by: David Fries <david@fries.net>
    Signed-off-by: Evgeniy Polyakov <johnpol@2ka.mipt.ru>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/w1/w1_int.c b/drivers/w1/w1_int.c
index 9d723efdf915..3fd6e6651fbe 100644
--- a/drivers/w1/w1_int.c
+++ b/drivers/w1/w1_int.c
@@ -30,6 +30,8 @@
 #include "w1_int.h"
 
 static u32 w1_ids = 1;
+static int w1_search_count = -1; /* Default is continual scan */
+module_param_named(search_count, w1_search_count, int, 0);
 
 static int w1_enable_pullup = 1;
 module_param_named(enable_pullup, w1_enable_pullup, int, 0);
@@ -62,8 +64,8 @@ static struct w1_master * w1_alloc_dev(u32 id, int slave_count, int slave_ttl,
 	dev->initialized	= 0;
 	dev->id			= id;
 	dev->slave_ttl		= slave_ttl;
+	dev->search_count	= w1_search_count;
 	dev->enable_pullup	= w1_enable_pullup;
-        dev->search_count	= -1; /* continual scan */
 
 	/* 1 for w1_process to decrement
 	 * 1 for __w1_remove_master_device to decrement

commit 6a158c0de791a81eb761ccf26ead1bd0834abac2
Author: David Fries <david@fries.net>
Date:   Wed Oct 15 22:04:42 2008 -0700

    W1: feature, enable hardware strong pullup
    
    Add a strong pullup option to the w1 system.  This supplies extra power
    for parasite powered devices.  There is a w1_master_pullup sysfs entry and
    enable_pullup module parameter to enable or disable the strong pullup.
    
    The one wire bus requires at a minimum one wire and ground.  The common
    wire is used for sending and receiving data as well as supplying power to
    devices that are parasite powered of which temperature sensors can be one
    example.  The bus must be idle and left high while a temperature
    conversion is in progress, in addition the normal pullup resister on
    larger networks or even higher temperatures might not supply enough power.
     The pullup resister can't provide too much pullup current, because
    devices need to pull the bus down to write a value.  This enables the
    strong pullup for supported hardware, which can supply more current when
    requested.  Unsupported hardware will just delay with the bus high.
    
    The hardware USB 2490 one wire bus master has a bit on some commands which
    will enable the strong pullup as soon as the command finishes executing.
    To use strong pullup, call the new w1_next_pullup function to register the
    duration.  The next write command will call set_pullup before sending the
    data, and reset the duration to zero once it returns.
    
    Switched from simple_strtol to strict_strtol.
    
    Signed-off-by: David Fries <david@fries.net>
    Cc: Evgeniy Polyakov <johnpol@2ka.mipt.ru>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/w1/w1_int.c b/drivers/w1/w1_int.c
index bd877b24ce42..9d723efdf915 100644
--- a/drivers/w1/w1_int.c
+++ b/drivers/w1/w1_int.c
@@ -31,6 +31,9 @@
 
 static u32 w1_ids = 1;
 
+static int w1_enable_pullup = 1;
+module_param_named(enable_pullup, w1_enable_pullup, int, 0);
+
 static struct w1_master * w1_alloc_dev(u32 id, int slave_count, int slave_ttl,
 				       struct device_driver *driver,
 				       struct device *device)
@@ -59,6 +62,7 @@ static struct w1_master * w1_alloc_dev(u32 id, int slave_count, int slave_ttl,
 	dev->initialized	= 0;
 	dev->id			= id;
 	dev->slave_ttl		= slave_ttl;
+	dev->enable_pullup	= w1_enable_pullup;
         dev->search_count	= -1; /* continual scan */
 
 	/* 1 for w1_process to decrement
@@ -107,6 +111,18 @@ int w1_add_master_device(struct w1_bus_master *master)
 		printk(KERN_ERR "w1_add_master_device: invalid function set\n");
 		return(-EINVAL);
         }
+	/* While it would be electrically possible to make a device that
+	 * generated a strong pullup in bit bang mode, only hardare that
+	 * controls 1-wire time frames are even expected to support a strong
+	 * pullup.  w1_io.c would need to support calling set_pullup before
+	 * the last write_bit operation of a w1_write_8 which it currently
+	 * doesn't.
+	 */
+	if (!master->write_byte && !master->touch_bit && master->set_pullup) {
+		printk(KERN_ERR "w1_add_master_device: set_pullup requires "
+			"write_byte or touch_bit, disabling\n");
+		master->set_pullup = NULL;
+	}
 
 	dev = w1_alloc_dev(w1_ids++, w1_max_slave_count, w1_max_slave_ttl, &w1_master_driver, &w1_master_device);
 	if (!dev)

commit 3c52e4e627896b42152cc6ff98216c302932227e
Author: David Fries <david@fries.net>
Date:   Wed Oct 15 22:04:41 2008 -0700

    W1: w1_process, block or sleep
    
    The w1_process thread's sleeping and termination has been modified.
    msleep_interruptible was replaced by schedule_timeout and schedule to
    allow for kthread_stop and wake_up_process to interrupt the sleep and the
    unbounded sleeping when a bus search is disabled.  The W1_MASTER_NEED_EXIT
    and flags variable were removed as they were redundant with
    kthread_should_stop and kthread_stop.  If w1_process is sleeping,
    requesting a search will immediately wake it up rather than waiting for
    the end of msleep_interruptible previously.
    
    Signed-off-by: David Fries <david@fries.net>
    Signed-off-by: Evgeniy Polyakov <johnpol@2ka.mipt.ru>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/w1/w1_int.c b/drivers/w1/w1_int.c
index 36ff40250b61..bd877b24ce42 100644
--- a/drivers/w1/w1_int.c
+++ b/drivers/w1/w1_int.c
@@ -142,7 +142,6 @@ int w1_add_master_device(struct w1_bus_master *master)
 
 #if 0 /* Thread cleanup code, not required currently. */
 err_out_kill_thread:
-	set_bit(W1_MASTER_NEED_EXIT, &dev->flags);
 	kthread_stop(dev->thread);
 #endif
 err_out_rm_attr:
@@ -158,7 +157,6 @@ void __w1_remove_master_device(struct w1_master *dev)
 	struct w1_netlink_msg msg;
 	struct w1_slave *sl, *sln;
 
-	set_bit(W1_MASTER_NEED_EXIT, &dev->flags);
 	kthread_stop(dev->thread);
 
 	mutex_lock(&w1_mlock);

commit 01e14d6db9654be005a0a5384090aea2cde39976
Author: David Fries <david@fries.net>
Date:   Wed Oct 15 22:04:40 2008 -0700

    W1: don't delay search start
    
    Move the creation of the w1_process thread to after the device has been
    initialized.  This way w1_process doesn't have to check to see if it has
    been initialized and the bus search can proceed without sleeping.  That
    also eliminates two checks in the w1_process loop.  The sleep now happens
    at the end of the loop not the beginning.
    
    Also added a comment for why the atomic_set was 2.
    
    Signed-off-by: David Fries <david@fries.net>
    Signed-off-by: Evgeniy Polyakov <johnpol@2ka.mipt.ru>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/w1/w1_int.c b/drivers/w1/w1_int.c
index ed3228017dad..36ff40250b61 100644
--- a/drivers/w1/w1_int.c
+++ b/drivers/w1/w1_int.c
@@ -61,6 +61,9 @@ static struct w1_master * w1_alloc_dev(u32 id, int slave_count, int slave_ttl,
 	dev->slave_ttl		= slave_ttl;
         dev->search_count	= -1; /* continual scan */
 
+	/* 1 for w1_process to decrement
+	 * 1 for __w1_remove_master_device to decrement
+	 */
 	atomic_set(&dev->refcnt, 2);
 
 	INIT_LIST_HEAD(&dev->slist);
@@ -109,23 +112,23 @@ int w1_add_master_device(struct w1_bus_master *master)
 	if (!dev)
 		return -ENOMEM;
 
+	retval =  w1_create_master_attributes(dev);
+	if (retval)
+		goto err_out_free_dev;
+
+	memcpy(dev->bus_master, master, sizeof(struct w1_bus_master));
+
+	dev->initialized = 1;
+
 	dev->thread = kthread_run(&w1_process, dev, "%s", dev->name);
 	if (IS_ERR(dev->thread)) {
 		retval = PTR_ERR(dev->thread);
 		dev_err(&dev->dev,
 			 "Failed to create new kernel thread. err=%d\n",
 			 retval);
-		goto err_out_free_dev;
+		goto err_out_rm_attr;
 	}
 
-	retval =  w1_create_master_attributes(dev);
-	if (retval)
-		goto err_out_kill_thread;
-
-	memcpy(dev->bus_master, master, sizeof(struct w1_bus_master));
-
-	dev->initialized = 1;
-
 	mutex_lock(&w1_mlock);
 	list_add(&dev->w1_master_entry, &w1_masters);
 	mutex_unlock(&w1_mlock);
@@ -137,8 +140,13 @@ int w1_add_master_device(struct w1_bus_master *master)
 
 	return 0;
 
+#if 0 /* Thread cleanup code, not required currently. */
 err_out_kill_thread:
+	set_bit(W1_MASTER_NEED_EXIT, &dev->flags);
 	kthread_stop(dev->thread);
+#endif
+err_out_rm_attr:
+	w1_destroy_master_attributes(dev);
 err_out_free_dev:
 	w1_free_dev(dev);
 

commit c30c9b15187e977ab5928f7276e9dfcd8d6f9460
Author: David Fries <david@fries.net>
Date:   Wed Oct 15 22:04:38 2008 -0700

    W1: fix deadlocks and remove w1_control_thread
    
    w1_control_thread was removed which would wake up every second and process
    newly registered family codes and complete some final cleanup for a
    removed master.  Those routines were moved to the threads that were
    previously requesting those operations.  A new function
    w1_reconnect_slaves takes care of reconnecting existing slave devices when
    a new family code is registered or removed.  The removal case was missing
    and would cause a deadlock waiting for the family code reference count to
    decrease, which will now happen.  A problem with registering a family code
    was fixed.  A slave device would be unattached if it wasn't yet claimed,
    then attached at the end of the list, two unclaimed slaves would cause an
    infinite loop.
    
    The struct w1_bus_master.search now takes a pointer to the struct
    w1_master device to avoid searching for it, which would have caused a
    lock ordering deadlock with the removal of w1_control_thread.
    
    Signed-off-by: David Fries <david@fries.net>
    Signed-off-by: Evgeniy Polyakov <johnpol@2ka.mipt.ru>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/w1/w1_int.c b/drivers/w1/w1_int.c
index 6840dfebe4d4..ed3228017dad 100644
--- a/drivers/w1/w1_int.c
+++ b/drivers/w1/w1_int.c
@@ -148,10 +148,22 @@ int w1_add_master_device(struct w1_bus_master *master)
 void __w1_remove_master_device(struct w1_master *dev)
 {
 	struct w1_netlink_msg msg;
+	struct w1_slave *sl, *sln;
 
 	set_bit(W1_MASTER_NEED_EXIT, &dev->flags);
 	kthread_stop(dev->thread);
 
+	mutex_lock(&w1_mlock);
+	list_del(&dev->w1_master_entry);
+	mutex_unlock(&w1_mlock);
+
+	mutex_lock(&dev->mutex);
+	list_for_each_entry_safe(sl, sln, &dev->slist, w1_slave_entry)
+		w1_slave_detach(sl);
+	w1_destroy_master_attributes(dev);
+	mutex_unlock(&dev->mutex);
+	atomic_dec(&dev->refcnt);
+
 	while (atomic_read(&dev->refcnt)) {
 		dev_info(&dev->dev, "Waiting for %s to become free: refcnt=%d.\n",
 				dev->name, atomic_read(&dev->refcnt));

commit 59d9445e851976d973a5a4009f80a3d55959d231
Author: Evgeniy Polyakov <johnpol@2ka.mipt.ru>
Date:   Wed Aug 22 14:01:51 2007 -0700

    w1: fix w1_remove_master_device() searching
    
    In case bus master driver provided bogus value as its private data, search
    can be incorrect.  Problem found by Adrian Bunk.
    
    Signed-off-by: Evgeniy Polyakov <johnpol@2ka.mipt.ru>
    Cc: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/w1/w1_int.c b/drivers/w1/w1_int.c
index 2fbd8dd16df5..6840dfebe4d4 100644
--- a/drivers/w1/w1_int.c
+++ b/drivers/w1/w1_int.c
@@ -170,22 +170,24 @@ void __w1_remove_master_device(struct w1_master *dev)
 
 void w1_remove_master_device(struct w1_bus_master *bm)
 {
-	struct w1_master *dev = NULL;
+	struct w1_master *dev, *found = NULL;
 
 	list_for_each_entry(dev, &w1_masters, w1_master_entry) {
 		if (!dev->initialized)
 			continue;
 
-		if (dev->bus_master->data == bm->data)
+		if (dev->bus_master->data == bm->data) {
+			found = dev;
 			break;
+		}
 	}
 
-	if (!dev) {
+	if (!found) {
 		printk(KERN_ERR "Device doesn't exist.\n");
 		return;
 	}
 
-	__w1_remove_master_device(dev);
+	__w1_remove_master_device(found);
 }
 
 EXPORT_SYMBOL(w1_add_master_device);

commit dd00cc486ab1c17049a535413d1751ef3482141c
Author: Yoann Padioleau <padator@wanadoo.fr>
Date:   Thu Jul 19 01:49:03 2007 -0700

    some kmalloc/memset ->kzalloc (tree wide)
    
    Transform some calls to kmalloc/memset to a single kzalloc (or kcalloc).
    
    Here is a short excerpt of the semantic patch performing
    this transformation:
    
    @@
    type T2;
    expression x;
    identifier f,fld;
    expression E;
    expression E1,E2;
    expression e1,e2,e3,y;
    statement S;
    @@
    
     x =
    - kmalloc
    + kzalloc
      (E1,E2)
      ...  when != \(x->fld=E;\|y=f(...,x,...);\|f(...,x,...);\|x=E;\|while(...) S\|for(e1;e2;e3) S\)
    - memset((T2)x,0,E1);
    
    @@
    expression E1,E2,E3;
    @@
    
    - kzalloc(E1 * E2,E3)
    + kcalloc(E1,E2,E3)
    
    [akpm@linux-foundation.org: get kcalloc args the right way around]
    Signed-off-by: Yoann Padioleau <padator@wanadoo.fr>
    Cc: Richard Henderson <rth@twiddle.net>
    Cc: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
    Acked-by: Russell King <rmk@arm.linux.org.uk>
    Cc: Bryan Wu <bryan.wu@analog.com>
    Acked-by: Jiri Slaby <jirislaby@gmail.com>
    Cc: Dave Airlie <airlied@linux.ie>
    Acked-by: Roland Dreier <rolandd@cisco.com>
    Cc: Jiri Kosina <jkosina@suse.cz>
    Acked-by: Dmitry Torokhov <dtor@mail.ru>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Acked-by: Mauro Carvalho Chehab <mchehab@infradead.org>
    Acked-by: Pierre Ossman <drzeus-list@drzeus.cx>
    Cc: Jeff Garzik <jeff@garzik.org>
    Cc: "David S. Miller" <davem@davemloft.net>
    Acked-by: Greg KH <greg@kroah.com>
    Cc: James Bottomley <James.Bottomley@steeleye.com>
    Cc: "Antonino A. Daplas" <adaplas@pol.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/w1/w1_int.c b/drivers/w1/w1_int.c
index 258defdb2efd..2fbd8dd16df5 100644
--- a/drivers/w1/w1_int.c
+++ b/drivers/w1/w1_int.c
@@ -41,7 +41,7 @@ static struct w1_master * w1_alloc_dev(u32 id, int slave_count, int slave_ttl,
 	/*
 	 * We are in process context(kernel thread), so can sleep.
 	 */
-	dev = kmalloc(sizeof(struct w1_master) + sizeof(struct w1_bus_master), GFP_KERNEL);
+	dev = kzalloc(sizeof(struct w1_master) + sizeof(struct w1_bus_master), GFP_KERNEL);
 	if (!dev) {
 		printk(KERN_ERR
 			"Failed to allocate %zd bytes for new w1 device.\n",
@@ -49,7 +49,6 @@ static struct w1_master * w1_alloc_dev(u32 id, int slave_count, int slave_ttl,
 		return NULL;
 	}
 
-	memset(dev, 0, sizeof(struct w1_master) + sizeof(struct w1_bus_master));
 
 	dev->bus_master = (struct w1_bus_master *)(dev + 1);
 

commit c1f858b763de570a4ab119ade7b24ccbc8fad23a
Author: Evgeniy Polyakov <johnpol@2ka.mipt.ru>
Date:   Tue May 8 00:31:20 2007 -0700

    w1: allow bus master to have reset and byte ops
    
    Signed-off-by: Matt Reimer <mreimer@vpop.net>
    Signed-off-by: Evgeniy Polyakov <johnpol@2ka.mipt.ru>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/w1/w1_int.c b/drivers/w1/w1_int.c
index 357a2e0f637a..258defdb2efd 100644
--- a/drivers/w1/w1_int.c
+++ b/drivers/w1/w1_int.c
@@ -100,7 +100,8 @@ int w1_add_master_device(struct w1_bus_master *master)
 
         /* validate minimum functionality */
         if (!(master->touch_bit && master->reset_bus) &&
-            !(master->write_bit && master->read_bit)) {
+            !(master->write_bit && master->read_bit) &&
+	    !(master->write_byte && master->read_byte && master->reset_bus)) {
 		printk(KERN_ERR "w1_add_master_device: invalid function set\n");
 		return(-EINVAL);
         }

commit 70d484bff43013e9b08f5d970b1c5941e9d98e16
Author: Evgeniy Polyakov <johnpol@2ka.mipt.ru>
Date:   Mon Apr 24 10:46:14 2006 +0400

    [PATCH] W1: possible cleanups
    
    This patch contains the following possible cleanups:
    - the following file did't #include the header with the prototypes for
      it's global functions:
      - w1_int.c
    - #if 0 the following unused global function:
      - w1_family.c: w1_family_get()
    - make the following needlessly global functions static:
      - w1_family.c: __w1_family_put()
      - w1_io.c: w1_delay()
      - w1_io.c: w1_touch_bit()
      - w1_io.c: w1_read_8()
    - remove the following unused EXPORT_SYMBOL's:
      - w1_family.c: w1_family_put
      - w1_family.c: w1_family_registered
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Evgeniy Polyakov <johnpol@2ka.mipt.ru>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/w1/w1_int.c b/drivers/w1/w1_int.c
index 475996cd1b7d..357a2e0f637a 100644
--- a/drivers/w1/w1_int.c
+++ b/drivers/w1/w1_int.c
@@ -27,6 +27,7 @@
 #include "w1.h"
 #include "w1_log.h"
 #include "w1_netlink.h"
+#include "w1_int.h"
 
 static u32 w1_ids = 1;
 

commit 2c5bfdac33607a618d8cf1532ef235ca9eccd49e
Author: Evgeniy Polyakov <johnpol@2ka.mipt.ru>
Date:   Tue Apr 4 20:35:22 2006 +0400

    [PATCH] W1: cleanups
    
    Nice cleanup spotted by Adrian Bunk, which was lost due to moving to the
    completely new functionality.
    
    Shame-shame-shame on me.
    
    Signed-off-by: Evgeniy Polyakov <johnpol@2ka.mipt.ru>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/w1/w1_int.c b/drivers/w1/w1_int.c
index 24e7c102fa75..475996cd1b7d 100644
--- a/drivers/w1/w1_int.c
+++ b/drivers/w1/w1_int.c
@@ -30,16 +30,6 @@
 
 static u32 w1_ids = 1;
 
-extern struct device_driver w1_master_driver;
-extern struct bus_type w1_bus_type;
-extern struct device w1_master_device;
-extern int w1_max_slave_count;
-extern int w1_max_slave_ttl;
-extern struct list_head w1_masters;
-extern struct mutex w1_mlock;
-
-extern int w1_process(void *);
-
 static struct w1_master * w1_alloc_dev(u32 id, int slave_count, int slave_ttl,
 				       struct device_driver *driver,
 				       struct device *device)
@@ -96,7 +86,7 @@ static struct w1_master * w1_alloc_dev(u32 id, int slave_count, int slave_ttl,
 	return dev;
 }
 
-void w1_free_dev(struct w1_master *dev)
+static void w1_free_dev(struct w1_master *dev)
 {
 	device_unregister(&dev->dev);
 }

commit abd52a13206e02537ca1dc08fc5438c7d27bdbf1
Author: Evgeniy Polyakov <johnpol@2ka.mipt.ru>
Date:   Mon Apr 3 12:04:27 2006 +0400

    [PATCH] w1: Use mutexes instead of semaphores.
    
    Use mutexes instead of semaphores.
    Patch tested on x86_64 and i386 with test bus master driver.
    
    Signed-off-by: Evgeniy Polyakov <johnpol@2ka.mipt.ru>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/w1/w1_int.c b/drivers/w1/w1_int.c
index ae78473d11f9..24e7c102fa75 100644
--- a/drivers/w1/w1_int.c
+++ b/drivers/w1/w1_int.c
@@ -36,7 +36,7 @@ extern struct device w1_master_device;
 extern int w1_max_slave_count;
 extern int w1_max_slave_ttl;
 extern struct list_head w1_masters;
-extern struct semaphore w1_mlock;
+extern struct mutex w1_mlock;
 
 extern int w1_process(void *);
 
@@ -74,7 +74,7 @@ static struct w1_master * w1_alloc_dev(u32 id, int slave_count, int slave_ttl,
 	atomic_set(&dev->refcnt, 2);
 
 	INIT_LIST_HEAD(&dev->slist);
-	init_MUTEX(&dev->mutex);
+	mutex_init(&dev->mutex);
 
 	memcpy(&dev->dev, device, sizeof(struct device));
 	snprintf(dev->dev.bus_id, sizeof(dev->dev.bus_id),
@@ -135,9 +135,9 @@ int w1_add_master_device(struct w1_bus_master *master)
 
 	dev->initialized = 1;
 
-	down(&w1_mlock);
+	mutex_lock(&w1_mlock);
 	list_add(&dev->w1_master_entry, &w1_masters);
-	up(&w1_mlock);
+	mutex_unlock(&w1_mlock);
 
 	memset(&msg, 0, sizeof(msg));
 	msg.id.mst.id = dev->id;

commit 12003375acd879e498c6c511faf27531296f9640
Author: Evgeniy Polyakov <johnpol@2ka.mipt.ru>
Date:   Thu Mar 23 19:11:58 2006 +0300

    [PATCH] w1: Userspace communication protocol over connector.
    
    There are three types of messages between w1 core and userspace:
    1. Events. They are generated each time new master or slave device found
            either due to automatic or requested search.
    2. Userspace commands. Includes read/write and search/alarm search comamnds.
    3. Replies to userspace commands.
    
    From: Evgeniy Polyakov <johnpol@2ka.mipt.ru>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/w1/w1_int.c b/drivers/w1/w1_int.c
index 68565aacec7b..ae78473d11f9 100644
--- a/drivers/w1/w1_int.c
+++ b/drivers/w1/w1_int.c
@@ -27,10 +27,19 @@
 #include "w1.h"
 #include "w1_log.h"
 #include "w1_netlink.h"
-#include "w1_int.h"
 
 static u32 w1_ids = 1;
 
+extern struct device_driver w1_master_driver;
+extern struct bus_type w1_bus_type;
+extern struct device w1_master_device;
+extern int w1_max_slave_count;
+extern int w1_max_slave_ttl;
+extern struct list_head w1_masters;
+extern struct semaphore w1_mlock;
+
+extern int w1_process(void *);
+
 static struct w1_master * w1_alloc_dev(u32 id, int slave_count, int slave_ttl,
 				       struct device_driver *driver,
 				       struct device *device)
@@ -74,16 +83,11 @@ static struct w1_master * w1_alloc_dev(u32 id, int slave_count, int slave_ttl,
 
 	dev->driver = driver;
 
-	dev->groups = 1;
 	dev->seq = 1;
-	dev_init_netlink(dev);
 
 	err = device_register(&dev->dev);
 	if (err) {
 		printk(KERN_ERR "Failed to register master device. err=%d\n", err);
-
-		dev_fini_netlink(dev);
-
 		memset(dev, 0, sizeof(struct w1_master));
 		kfree(dev);
 		dev = NULL;
@@ -92,7 +96,7 @@ static struct w1_master * w1_alloc_dev(u32 id, int slave_count, int slave_ttl,
 	return dev;
 }
 
-static void w1_free_dev(struct w1_master *dev)
+void w1_free_dev(struct w1_master *dev)
 {
 	device_unregister(&dev->dev);
 }
@@ -131,12 +135,12 @@ int w1_add_master_device(struct w1_bus_master *master)
 
 	dev->initialized = 1;
 
-	spin_lock(&w1_mlock);
+	down(&w1_mlock);
 	list_add(&dev->w1_master_entry, &w1_masters);
-	spin_unlock(&w1_mlock);
+	up(&w1_mlock);
 
+	memset(&msg, 0, sizeof(msg));
 	msg.id.mst.id = dev->id;
-	msg.id.mst.pid = dev->thread->pid;
 	msg.type = W1_MASTER_ADD;
 	w1_netlink_send(dev, &msg);
 
@@ -153,7 +157,6 @@ int w1_add_master_device(struct w1_bus_master *master)
 void __w1_remove_master_device(struct w1_master *dev)
 {
 	struct w1_netlink_msg msg;
-	pid_t pid = dev->thread->pid;
 
 	set_bit(W1_MASTER_NEED_EXIT, &dev->flags);
 	kthread_stop(dev->thread);
@@ -166,8 +169,8 @@ void __w1_remove_master_device(struct w1_master *dev)
 			flush_signals(current);
 	}
 
+	memset(&msg, 0, sizeof(msg));
 	msg.id.mst.id = dev->id;
-	msg.id.mst.pid = pid;
 	msg.type = W1_MASTER_REMOVE;
 	w1_netlink_send(dev, &msg);
 

commit 674a396c6d2ba0341ebdd7c1c9950f32f018e2dd
Author: Evgeniy Polyakov <johnpol@2ka.mipt.ru>
Date:   Mon Feb 20 11:15:37 2006 +0300

    [PATCH] w1: use kthread api.
    
    This patch removes old-style kernel thread initialization
    and changes w1 to use kthread api.
    It is based on Christoph Hellwig <hch@lst.de> work.
    
    Signed-off-by: Evgeniy Polyakov <johnpol@2ka.mipt.ru>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/w1/w1_int.c b/drivers/w1/w1_int.c
index a2f9065e1928..68565aacec7b 100644
--- a/drivers/w1/w1_int.c
+++ b/drivers/w1/w1_int.c
@@ -22,6 +22,7 @@
 #include <linux/kernel.h>
 #include <linux/list.h>
 #include <linux/delay.h>
+#include <linux/kthread.h>
 
 #include "w1.h"
 #include "w1_log.h"
@@ -56,7 +57,6 @@ static struct w1_master * w1_alloc_dev(u32 id, int slave_count, int slave_ttl,
 	dev->max_slave_count	= slave_count;
 	dev->slave_count	= 0;
 	dev->attempts		= 0;
-	dev->kpid		= -1;
 	dev->initialized	= 0;
 	dev->id			= id;
 	dev->slave_ttl		= slave_ttl;
@@ -67,8 +67,6 @@ static struct w1_master * w1_alloc_dev(u32 id, int slave_count, int slave_ttl,
 	INIT_LIST_HEAD(&dev->slist);
 	init_MUTEX(&dev->mutex);
 
-	init_completion(&dev->dev_exited);
-
 	memcpy(&dev->dev, device, sizeof(struct device));
 	snprintf(dev->dev.bus_id, sizeof(dev->dev.bus_id),
 		  "w1_bus_master%u", dev->id);
@@ -116,12 +114,12 @@ int w1_add_master_device(struct w1_bus_master *master)
 	if (!dev)
 		return -ENOMEM;
 
-	dev->kpid = kernel_thread(&w1_process, dev, 0);
-	if (dev->kpid < 0) {
+	dev->thread = kthread_run(&w1_process, dev, "%s", dev->name);
+	if (IS_ERR(dev->thread)) {
+		retval = PTR_ERR(dev->thread);
 		dev_err(&dev->dev,
 			 "Failed to create new kernel thread. err=%d\n",
-			 dev->kpid);
-		retval = dev->kpid;
+			 retval);
 		goto err_out_free_dev;
 	}
 
@@ -138,20 +136,14 @@ int w1_add_master_device(struct w1_bus_master *master)
 	spin_unlock(&w1_mlock);
 
 	msg.id.mst.id = dev->id;
-	msg.id.mst.pid = dev->kpid;
+	msg.id.mst.pid = dev->thread->pid;
 	msg.type = W1_MASTER_ADD;
 	w1_netlink_send(dev, &msg);
 
 	return 0;
 
 err_out_kill_thread:
-	set_bit(W1_MASTER_NEED_EXIT, &dev->flags);
-	if (kill_proc(dev->kpid, SIGTERM, 1))
-		dev_err(&dev->dev,
-			 "Failed to send signal to w1 kernel thread %d.\n",
-			 dev->kpid);
-	wait_for_completion(&dev->dev_exited);
-
+	kthread_stop(dev->thread);
 err_out_free_dev:
 	w1_free_dev(dev);
 
@@ -160,18 +152,14 @@ int w1_add_master_device(struct w1_bus_master *master)
 
 void __w1_remove_master_device(struct w1_master *dev)
 {
-	int err;
 	struct w1_netlink_msg msg;
+	pid_t pid = dev->thread->pid;
 
 	set_bit(W1_MASTER_NEED_EXIT, &dev->flags);
-	err = kill_proc(dev->kpid, SIGTERM, 1);
-	if (err)
-		dev_err(&dev->dev,
-			 "%s: Failed to send signal to w1 kernel thread %d.\n",
-			 __func__, dev->kpid);
+	kthread_stop(dev->thread);
 
 	while (atomic_read(&dev->refcnt)) {
-		dev_dbg(&dev->dev, "Waiting for %s to become free: refcnt=%d.\n",
+		dev_info(&dev->dev, "Waiting for %s to become free: refcnt=%d.\n",
 				dev->name, atomic_read(&dev->refcnt));
 
 		if (msleep_interruptible(1000))
@@ -179,7 +167,7 @@ void __w1_remove_master_device(struct w1_master *dev)
 	}
 
 	msg.id.mst.id = dev->id;
-	msg.id.mst.pid = dev->kpid;
+	msg.id.mst.pid = pid;
 	msg.type = W1_MASTER_REMOVE;
 	w1_netlink_send(dev, &msg);
 

commit ecd5136c85cb4531a51f65241e7b3cd58420f3ed
Author: Patrick McHardy <kaber@trash.net>
Date:   Sun Jan 8 00:44:15 2006 +0100

    [PATCH] W1: Remove incorrect MODULE_ALIAS
    
    The w1 netlink socket is created by a hardware specific driver calling
    w1_add_master_device, so there is no point in including a module alias
    for netlink autoloading in the core.
    
    Signed-off-by: Patrick McHardy <kaber@trash.net>
    Acked-by: Evgeniy Polyakov <johnpol@2ka.mipt.ru>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/w1/w1_int.c b/drivers/w1/w1_int.c
index 4724693ad51d..a2f9065e1928 100644
--- a/drivers/w1/w1_int.c
+++ b/drivers/w1/w1_int.c
@@ -208,5 +208,3 @@ void w1_remove_master_device(struct w1_bus_master *bm)
 
 EXPORT_SYMBOL(w1_add_master_device);
 EXPORT_SYMBOL(w1_remove_master_device);
-
-MODULE_ALIAS_NET_PF_PROTO(PF_NETLINK, NETLINK_W1);

commit a9fb1c7b950bed4afe208c9d67e20f086bb6abbb
Author: Adrian Bunk <bunk@stusta.de>
Date:   Tue Dec 13 14:04:33 2005 -0800

    [PATCH] w1: misc cleanups
    
    This patch contains the following cleanups:
    - make needlessly global code static
    - declarations for global code belong into header files
    - w1.c: #if 0 the unused struct w1_slave_device
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Acked-by: Evgeniy Polyakov <johnpol@2ka.mipt.ru>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/w1/w1_int.c b/drivers/w1/w1_int.c
index c3f67eafc7ec..4724693ad51d 100644
--- a/drivers/w1/w1_int.c
+++ b/drivers/w1/w1_int.c
@@ -26,19 +26,10 @@
 #include "w1.h"
 #include "w1_log.h"
 #include "w1_netlink.h"
+#include "w1_int.h"
 
 static u32 w1_ids = 1;
 
-extern struct device_driver w1_master_driver;
-extern struct bus_type w1_bus_type;
-extern struct device w1_master_device;
-extern int w1_max_slave_count;
-extern int w1_max_slave_ttl;
-extern struct list_head w1_masters;
-extern spinlock_t w1_mlock;
-
-extern int w1_process(void *);
-
 static struct w1_master * w1_alloc_dev(u32 id, int slave_count, int slave_ttl,
 				       struct device_driver *driver,
 				       struct device *device)
@@ -103,7 +94,7 @@ static struct w1_master * w1_alloc_dev(u32 id, int slave_count, int slave_ttl,
 	return dev;
 }
 
-void w1_free_dev(struct w1_master *dev)
+static void w1_free_dev(struct w1_master *dev)
 {
 	device_unregister(&dev->dev);
 }

commit 3aca692d3ec7cf89da4575f598e41f74502b22d7
Author: Evgeniy Polyakov <johnpol@2ka.mipt.ru>
Date:   Thu Aug 11 17:27:50 2005 +0400

    [PATCH] w1: Detouching bug fixed.
    
    Signed-off-by: Evgeniy Polyakov <johnpol@2ka.mipt.ru>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/w1/w1_int.c b/drivers/w1/w1_int.c
index c13724fd0971..c3f67eafc7ec 100644
--- a/drivers/w1/w1_int.c
+++ b/drivers/w1/w1_int.c
@@ -76,7 +76,6 @@ static struct w1_master * w1_alloc_dev(u32 id, int slave_count, int slave_ttl,
 	INIT_LIST_HEAD(&dev->slist);
 	init_MUTEX(&dev->mutex);
 
-	init_completion(&dev->dev_released);
 	init_completion(&dev->dev_exited);
 
 	memcpy(&dev->dev, device, sizeof(struct device));
@@ -107,9 +106,6 @@ static struct w1_master * w1_alloc_dev(u32 id, int slave_count, int slave_ttl,
 void w1_free_dev(struct w1_master *dev)
 {
 	device_unregister(&dev->dev);
-	dev_fini_netlink(dev);
-	memset(dev, 0, sizeof(struct w1_master) + sizeof(struct w1_bus_master));
-	kfree(dev);
 }
 
 int w1_add_master_device(struct w1_bus_master *master)
@@ -184,7 +180,7 @@ void __w1_remove_master_device(struct w1_master *dev)
 			 __func__, dev->kpid);
 
 	while (atomic_read(&dev->refcnt)) {
-		printk(KERN_INFO "Waiting for %s to become free: refcnt=%d.\n",
+		dev_dbg(&dev->dev, "Waiting for %s to become free: refcnt=%d.\n",
 				dev->name, atomic_read(&dev->refcnt));
 
 		if (msleep_interruptible(1000))

commit 7f772ed8df27c6941952452330c618512389c4c7
Author: Evgeniy Polyakov <johnpol@2ka.mipt.ru>
Date:   Thu Aug 11 13:20:07 2005 +0400

    [PATCH] w1: hotplug support.
    
    Here is W1 hotplug in addition to netlink notifications.
    
    Signed-off-by: Evgeniy Polyakov <johnpol@2ka.mipt.ru>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/w1/w1_int.c b/drivers/w1/w1_int.c
index 2a538d012194..c13724fd0971 100644
--- a/drivers/w1/w1_int.c
+++ b/drivers/w1/w1_int.c
@@ -29,9 +29,9 @@
 
 static u32 w1_ids = 1;
 
-extern struct device_driver w1_driver;
+extern struct device_driver w1_master_driver;
 extern struct bus_type w1_bus_type;
-extern struct device w1_device;
+extern struct device w1_master_device;
 extern int w1_max_slave_count;
 extern int w1_max_slave_ttl;
 extern struct list_head w1_masters;
@@ -125,7 +125,7 @@ int w1_add_master_device(struct w1_bus_master *master)
 		return(-EINVAL);
         }
 
-	dev = w1_alloc_dev(w1_ids++, w1_max_slave_count, w1_max_slave_ttl, &w1_driver, &w1_device);
+	dev = w1_alloc_dev(w1_ids++, w1_max_slave_count, w1_max_slave_ttl, &w1_master_driver, &w1_master_device);
 	if (!dev)
 		return -ENOMEM;
 

commit 2d8331792ea3f5ccfd147288afba148537337019
Author: Evgeniy Polyakov <johnpol@2ka.mipt.ru>
Date:   Wed Jul 27 13:10:11 2005 +0400

    [PATCH] W1: w1_netlink: New init/fini netlink callbacks.
    
    They are guarded with NETLINK_DISABLE compile time options,
    so if CONFIG_NET is disabled, no linking errors occur.
    Bug noticed by Adrian Bunk <bunk@stusta.de>.
    
    Signed-off-by: Evgeniy Polyakov <johnpol@2ka.mipt.ru>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/w1/w1_int.c b/drivers/w1/w1_int.c
index 498ad505fa5f..2a538d012194 100644
--- a/drivers/w1/w1_int.c
+++ b/drivers/w1/w1_int.c
@@ -88,17 +88,14 @@ static struct w1_master * w1_alloc_dev(u32 id, int slave_count, int slave_ttl,
 
 	dev->groups = 1;
 	dev->seq = 1;
-	dev->nls = netlink_kernel_create(NETLINK_W1, 1, NULL, THIS_MODULE);
-	if (!dev->nls) {
-		printk(KERN_ERR "Failed to create new netlink socket(%u) for w1 master %s.\n",
-			NETLINK_NFLOG, dev->dev.bus_id);
-	}
+	dev_init_netlink(dev);
 
 	err = device_register(&dev->dev);
 	if (err) {
 		printk(KERN_ERR "Failed to register master device. err=%d\n", err);
-		if (dev->nls && dev->nls->sk_socket)
-			sock_release(dev->nls->sk_socket);
+
+		dev_fini_netlink(dev);
+
 		memset(dev, 0, sizeof(struct w1_master));
 		kfree(dev);
 		dev = NULL;
@@ -107,11 +104,10 @@ static struct w1_master * w1_alloc_dev(u32 id, int slave_count, int slave_ttl,
 	return dev;
 }
 
-static void w1_free_dev(struct w1_master *dev)
+void w1_free_dev(struct w1_master *dev)
 {
 	device_unregister(&dev->dev);
-	if (dev->nls && dev->nls->sk_socket)
-		sock_release(dev->nls->sk_socket);
+	dev_fini_netlink(dev);
 	memset(dev, 0, sizeof(struct w1_master) + sizeof(struct w1_bus_master));
 	kfree(dev);
 }

commit 066286071d3542243baa68166acb779187c848b3
Author: Patrick McHardy <kaber@trash.net>
Date:   Mon Aug 15 12:33:26 2005 -0700

    [NETLINK]: Add "groups" argument to netlink_kernel_create
    
    Signed-off-by: Patrick McHardy <kaber@trash.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/w1/w1_int.c b/drivers/w1/w1_int.c
index f3f339d057f9..498ad505fa5f 100644
--- a/drivers/w1/w1_int.c
+++ b/drivers/w1/w1_int.c
@@ -88,7 +88,7 @@ static struct w1_master * w1_alloc_dev(u32 id, int slave_count, int slave_ttl,
 
 	dev->groups = 1;
 	dev->seq = 1;
-	dev->nls = netlink_kernel_create(NETLINK_W1, NULL, THIS_MODULE);
+	dev->nls = netlink_kernel_create(NETLINK_W1, 1, NULL, THIS_MODULE);
 	if (!dev->nls) {
 		printk(KERN_ERR "Failed to create new netlink socket(%u) for w1 master %s.\n",
 			NETLINK_NFLOG, dev->dev.bus_id);

commit ad93e266a17c6f606e96304c866eb73665ae34fa
Author: Evgeniy Polyakov <johnpol@2ka.mipt.ru>
Date:   Sun Aug 14 19:24:58 2005 -0700

    [NETLINK]: w1_int.c: fix default netlink group
    
    w1 does not need to multicast its state to several groups at once,
    and upcoming netlink changes will not allow bitmask for groups anyway.
    
    Signed-off-by: Evgeniy Polyakov <johnpol@2ka.mipt.ru>
    Signed-off-by: Patrick McHardy <kaber@trash.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/w1/w1_int.c b/drivers/w1/w1_int.c
index 8809788dac26..f3f339d057f9 100644
--- a/drivers/w1/w1_int.c
+++ b/drivers/w1/w1_int.c
@@ -86,7 +86,7 @@ static struct w1_master * w1_alloc_dev(u32 id, int slave_count, int slave_ttl,
 
 	dev->driver = driver;
 
-	dev->groups = 23;
+	dev->groups = 1;
 	dev->seq = 1;
 	dev->nls = netlink_kernel_create(NETLINK_W1, NULL, THIS_MODULE);
 	if (!dev->nls) {

commit 4fdb3bb723db469717c6d38fda667d8b0fa86ebd
Author: Harald Welte <laforge@netfilter.org>
Date:   Tue Aug 9 19:40:55 2005 -0700

    [NETLINK]: Add properly module refcounting for kernel netlink sockets.
    
    - Remove bogus code for compiling netlink as module
    - Add module refcounting support for modules implementing a netlink
      protocol
    - Add support for autoloading modules that implement a netlink protocol
      as soon as someone opens a socket for that protocol
    
    Signed-off-by: Harald Welte <laforge@netfilter.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/w1/w1_int.c b/drivers/w1/w1_int.c
index b5a5e04b6d37..8809788dac26 100644
--- a/drivers/w1/w1_int.c
+++ b/drivers/w1/w1_int.c
@@ -88,7 +88,7 @@ static struct w1_master * w1_alloc_dev(u32 id, int slave_count, int slave_ttl,
 
 	dev->groups = 23;
 	dev->seq = 1;
-	dev->nls = netlink_kernel_create(NETLINK_W1, NULL);
+	dev->nls = netlink_kernel_create(NETLINK_W1, NULL, THIS_MODULE);
 	if (!dev->nls) {
 		printk(KERN_ERR "Failed to create new netlink socket(%u) for w1 master %s.\n",
 			NETLINK_NFLOG, dev->dev.bus_id);
@@ -225,3 +225,5 @@ void w1_remove_master_device(struct w1_bus_master *bm)
 
 EXPORT_SYMBOL(w1_add_master_device);
 EXPORT_SYMBOL(w1_remove_master_device);
+
+MODULE_ALIAS_NET_PF_PROTO(PF_NETLINK, NETLINK_W1);

commit 48647feed9f7a2d839c6ada12147b341833646e8
Author: David S. Miller <davem@davemloft.net>
Date:   Sun Jul 24 19:30:28 2005 -0700

    [W1]: Do not use NFLOG netlink number.
    
    Use the reserved by never used NETLINK_SKIP value instead.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/w1/w1_int.c b/drivers/w1/w1_int.c
index 35e85d961702..b5a5e04b6d37 100644
--- a/drivers/w1/w1_int.c
+++ b/drivers/w1/w1_int.c
@@ -88,7 +88,7 @@ static struct w1_master * w1_alloc_dev(u32 id, int slave_count, int slave_ttl,
 
 	dev->groups = 23;
 	dev->seq = 1;
-	dev->nls = netlink_kernel_create(NETLINK_NFLOG, NULL);
+	dev->nls = netlink_kernel_create(NETLINK_W1, NULL);
 	if (!dev->nls) {
 		printk(KERN_ERR "Failed to create new netlink socket(%u) for w1 master %s.\n",
 			NETLINK_NFLOG, dev->dev.bus_id);

commit 6adf87bd7b7832105b9c6bc08adf6a4d229f1e79
Author: Evgeniy Polyakov <johnpol@2ka.mipt.ru>
Date:   Sat Jun 4 01:29:25 2005 +0400

    [PATCH] w1: reconnect feature.
    
    I've created reconnect feature - if on start there are no registered families
    all new devices will have defailt family, later when driver for appropriate
    family is loaded, slaves, which were faound earlier, will still have defult
    family instead of right one. Reconnect feature will force control thread to run
    through all master devices and all slaves found and search for slaves with
    default family id and try to reconnect them.
    
    It does not store newly registered family and does not check only those slaves
    which have reg_num.family the same as being registered one - all slaves with
    default family are reconnected.
    
    Signed-off-by: Evgeniy Polyakov <johnpol@2ka.mipt.ru>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/w1/w1_int.c b/drivers/w1/w1_int.c
index cf18f1324f03..35e85d961702 100644
--- a/drivers/w1/w1_int.c
+++ b/drivers/w1/w1_int.c
@@ -124,10 +124,9 @@ int w1_add_master_device(struct w1_bus_master *master)
 
         /* validate minimum functionality */
         if (!(master->touch_bit && master->reset_bus) &&
-            !(master->write_bit && master->read_bit))
-        {
-           printk(KERN_ERR "w1_add_master_device: invalid function set\n");
-           return(-EINVAL);
+            !(master->write_bit && master->read_bit)) {
+		printk(KERN_ERR "w1_add_master_device: invalid function set\n");
+		return(-EINVAL);
         }
 
 	dev = w1_alloc_dev(w1_ids++, w1_max_slave_count, w1_max_slave_ttl, &w1_driver, &w1_device);
@@ -163,7 +162,7 @@ int w1_add_master_device(struct w1_bus_master *master)
 	return 0;
 
 err_out_kill_thread:
-	dev->need_exit = 1;
+	set_bit(W1_MASTER_NEED_EXIT, &dev->flags);
 	if (kill_proc(dev->kpid, SIGTERM, 1))
 		dev_err(&dev->dev,
 			 "Failed to send signal to w1 kernel thread %d.\n",
@@ -181,7 +180,7 @@ void __w1_remove_master_device(struct w1_master *dev)
 	int err;
 	struct w1_netlink_msg msg;
 
-	dev->need_exit = 1;
+	set_bit(W1_MASTER_NEED_EXIT, &dev->flags);
 	err = kill_proc(dev->kpid, SIGTERM, 1);
 	if (err)
 		dev_err(&dev->dev,

commit 2a9d0c178158da4a9bcf22311a414c26a8102d13
Author: Evgeniy Polyakov <johnpol@2ka.mipt.ru>
Date:   Sat Jun 4 01:31:02 2005 +0400

    [PATCH] w1: Adds a sysfs entry (w1_master_search) that allows you to disable/enable periodic searches.
    
    Adds a sysfs entry (w1_master_search) that allows you to disable/enable
    periodic searches.
    
    Signed-off-by: Ben Gardner <bgardner@wabtec.com>
    Signed-off-by: Evgeniy Polyakov <johnpol@2ka.mipt.ru>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/w1/w1_int.c b/drivers/w1/w1_int.c
index 280f140ae698..cf18f1324f03 100644
--- a/drivers/w1/w1_int.c
+++ b/drivers/w1/w1_int.c
@@ -69,6 +69,7 @@ static struct w1_master * w1_alloc_dev(u32 id, int slave_count, int slave_ttl,
 	dev->initialized	= 0;
 	dev->id			= id;
 	dev->slave_ttl		= slave_ttl;
+        dev->search_count	= -1; /* continual scan */
 
 	atomic_set(&dev->refcnt, 2);
 

commit be57ce267fd558c52d2389530c15618681b7cfa7
Author: Evgeniy Polyakov <johnpol@2ka.mipt.ru>
Date:   Sat Jun 4 01:21:46 2005 +0400

    [PATCH] w1: Cleans up usage of touch_bit/w1_read_bit/w1_write_bit.
    
    Cleans up usage of touch_bit/w1_read_bit/w1_write_bit.
    
    Signed-off-by: Ben Gardner <bgardner@wabtec.com>
    Signed-off-by: Evgeniy Polyakov <johnpol@2ka.mipt.ru>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/w1/w1_int.c b/drivers/w1/w1_int.c
index ce24e3b3fc2a..280f140ae698 100644
--- a/drivers/w1/w1_int.c
+++ b/drivers/w1/w1_int.c
@@ -121,6 +121,14 @@ int w1_add_master_device(struct w1_bus_master *master)
 	int retval = 0;
 	struct w1_netlink_msg msg;
 
+        /* validate minimum functionality */
+        if (!(master->touch_bit && master->reset_bus) &&
+            !(master->write_bit && master->read_bit))
+        {
+           printk(KERN_ERR "w1_add_master_device: invalid function set\n");
+           return(-EINVAL);
+        }
+
 	dev = w1_alloc_dev(w1_ids++, w1_max_slave_count, w1_max_slave_ttl, &w1_driver, &w1_device);
 	if (!dev)
 		return -ENOMEM;

commit 7785925dd8e0d2f389d4a9168f1683c6b249a552
Author: Evgeniy Polyakov <johnpol@2ka.mipt.ru>
Date:   Fri May 20 22:33:25 2005 +0400

    [PATCH] w1: cleanups.
    
     - white space changes.
     - list_for_each_entry/list_for_each_entry_safe and reverse changes.
     - small coding style changes.
     - removed redundant NULL checks.
     - use attribute group and macros instead of direct device attributes.
    Patch is havily based on work from Adrian Bunk and Dmitry Torokhov,
    thanks guys.
    
    Signed-off-by: Evgeniy Polyakov <johnpol@2ka.mipt.ru>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/w1/w1_int.c b/drivers/w1/w1_int.c
index 5f0bafbbd575..ce24e3b3fc2a 100644
--- a/drivers/w1/w1_int.c
+++ b/drivers/w1/w1_int.c
@@ -1,8 +1,8 @@
 /*
- * 	w1_int.c
+ *	w1_int.c
  *
  * Copyright (c) 2004 Evgeniy Polyakov <johnpol@2ka.mipt.ru>
- * 
+ *
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -39,8 +39,9 @@ extern spinlock_t w1_mlock;
 
 extern int w1_process(void *);
 
-struct w1_master * w1_alloc_dev(u32 id, int slave_count, int slave_ttl,
-	      struct device_driver *driver, struct device *device)
+static struct w1_master * w1_alloc_dev(u32 id, int slave_count, int slave_ttl,
+				       struct device_driver *driver,
+				       struct device *device)
 {
 	struct w1_master *dev;
 	int err;
@@ -60,13 +61,13 @@ struct w1_master * w1_alloc_dev(u32 id, int slave_count, int slave_ttl,
 
 	dev->bus_master = (struct w1_bus_master *)(dev + 1);
 
-	dev->owner 		= THIS_MODULE;
-	dev->max_slave_count 	= slave_count;
-	dev->slave_count 	= 0;
-	dev->attempts 		= 0;
-	dev->kpid 		= -1;
-	dev->initialized 	= 0;
-	dev->id 		= id;
+	dev->owner		= THIS_MODULE;
+	dev->max_slave_count	= slave_count;
+	dev->slave_count	= 0;
+	dev->attempts		= 0;
+	dev->kpid		= -1;
+	dev->initialized	= 0;
+	dev->id			= id;
 	dev->slave_ttl		= slave_ttl;
 
 	atomic_set(&dev->refcnt, 2);
@@ -105,7 +106,7 @@ struct w1_master * w1_alloc_dev(u32 id, int slave_count, int slave_ttl,
 	return dev;
 }
 
-void w1_free_dev(struct w1_master *dev)
+static void w1_free_dev(struct w1_master *dev)
 {
 	device_unregister(&dev->dev);
 	if (dev->nls && dev->nls->sk_socket)
@@ -197,10 +198,8 @@ void __w1_remove_master_device(struct w1_master *dev)
 void w1_remove_master_device(struct w1_bus_master *bm)
 {
 	struct w1_master *dev = NULL;
-	struct list_head *ent, *n;
 
-	list_for_each_safe(ent, n, &w1_masters) {
-		dev = list_entry(ent, struct w1_master, w1_master_entry);
+	list_for_each_entry(dev, &w1_masters, w1_master_entry) {
 		if (!dev->initialized)
 			continue;
 

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/w1/w1_int.c b/drivers/w1/w1_int.c
new file mode 100644
index 000000000000..5f0bafbbd575
--- /dev/null
+++ b/drivers/w1/w1_int.c
@@ -0,0 +1,220 @@
+/*
+ * 	w1_int.c
+ *
+ * Copyright (c) 2004 Evgeniy Polyakov <johnpol@2ka.mipt.ru>
+ * 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/delay.h>
+
+#include "w1.h"
+#include "w1_log.h"
+#include "w1_netlink.h"
+
+static u32 w1_ids = 1;
+
+extern struct device_driver w1_driver;
+extern struct bus_type w1_bus_type;
+extern struct device w1_device;
+extern int w1_max_slave_count;
+extern int w1_max_slave_ttl;
+extern struct list_head w1_masters;
+extern spinlock_t w1_mlock;
+
+extern int w1_process(void *);
+
+struct w1_master * w1_alloc_dev(u32 id, int slave_count, int slave_ttl,
+	      struct device_driver *driver, struct device *device)
+{
+	struct w1_master *dev;
+	int err;
+
+	/*
+	 * We are in process context(kernel thread), so can sleep.
+	 */
+	dev = kmalloc(sizeof(struct w1_master) + sizeof(struct w1_bus_master), GFP_KERNEL);
+	if (!dev) {
+		printk(KERN_ERR
+			"Failed to allocate %zd bytes for new w1 device.\n",
+			sizeof(struct w1_master));
+		return NULL;
+	}
+
+	memset(dev, 0, sizeof(struct w1_master) + sizeof(struct w1_bus_master));
+
+	dev->bus_master = (struct w1_bus_master *)(dev + 1);
+
+	dev->owner 		= THIS_MODULE;
+	dev->max_slave_count 	= slave_count;
+	dev->slave_count 	= 0;
+	dev->attempts 		= 0;
+	dev->kpid 		= -1;
+	dev->initialized 	= 0;
+	dev->id 		= id;
+	dev->slave_ttl		= slave_ttl;
+
+	atomic_set(&dev->refcnt, 2);
+
+	INIT_LIST_HEAD(&dev->slist);
+	init_MUTEX(&dev->mutex);
+
+	init_completion(&dev->dev_released);
+	init_completion(&dev->dev_exited);
+
+	memcpy(&dev->dev, device, sizeof(struct device));
+	snprintf(dev->dev.bus_id, sizeof(dev->dev.bus_id),
+		  "w1_bus_master%u", dev->id);
+	snprintf(dev->name, sizeof(dev->name), "w1_bus_master%u", dev->id);
+
+	dev->driver = driver;
+
+	dev->groups = 23;
+	dev->seq = 1;
+	dev->nls = netlink_kernel_create(NETLINK_NFLOG, NULL);
+	if (!dev->nls) {
+		printk(KERN_ERR "Failed to create new netlink socket(%u) for w1 master %s.\n",
+			NETLINK_NFLOG, dev->dev.bus_id);
+	}
+
+	err = device_register(&dev->dev);
+	if (err) {
+		printk(KERN_ERR "Failed to register master device. err=%d\n", err);
+		if (dev->nls && dev->nls->sk_socket)
+			sock_release(dev->nls->sk_socket);
+		memset(dev, 0, sizeof(struct w1_master));
+		kfree(dev);
+		dev = NULL;
+	}
+
+	return dev;
+}
+
+void w1_free_dev(struct w1_master *dev)
+{
+	device_unregister(&dev->dev);
+	if (dev->nls && dev->nls->sk_socket)
+		sock_release(dev->nls->sk_socket);
+	memset(dev, 0, sizeof(struct w1_master) + sizeof(struct w1_bus_master));
+	kfree(dev);
+}
+
+int w1_add_master_device(struct w1_bus_master *master)
+{
+	struct w1_master *dev;
+	int retval = 0;
+	struct w1_netlink_msg msg;
+
+	dev = w1_alloc_dev(w1_ids++, w1_max_slave_count, w1_max_slave_ttl, &w1_driver, &w1_device);
+	if (!dev)
+		return -ENOMEM;
+
+	dev->kpid = kernel_thread(&w1_process, dev, 0);
+	if (dev->kpid < 0) {
+		dev_err(&dev->dev,
+			 "Failed to create new kernel thread. err=%d\n",
+			 dev->kpid);
+		retval = dev->kpid;
+		goto err_out_free_dev;
+	}
+
+	retval =  w1_create_master_attributes(dev);
+	if (retval)
+		goto err_out_kill_thread;
+
+	memcpy(dev->bus_master, master, sizeof(struct w1_bus_master));
+
+	dev->initialized = 1;
+
+	spin_lock(&w1_mlock);
+	list_add(&dev->w1_master_entry, &w1_masters);
+	spin_unlock(&w1_mlock);
+
+	msg.id.mst.id = dev->id;
+	msg.id.mst.pid = dev->kpid;
+	msg.type = W1_MASTER_ADD;
+	w1_netlink_send(dev, &msg);
+
+	return 0;
+
+err_out_kill_thread:
+	dev->need_exit = 1;
+	if (kill_proc(dev->kpid, SIGTERM, 1))
+		dev_err(&dev->dev,
+			 "Failed to send signal to w1 kernel thread %d.\n",
+			 dev->kpid);
+	wait_for_completion(&dev->dev_exited);
+
+err_out_free_dev:
+	w1_free_dev(dev);
+
+	return retval;
+}
+
+void __w1_remove_master_device(struct w1_master *dev)
+{
+	int err;
+	struct w1_netlink_msg msg;
+
+	dev->need_exit = 1;
+	err = kill_proc(dev->kpid, SIGTERM, 1);
+	if (err)
+		dev_err(&dev->dev,
+			 "%s: Failed to send signal to w1 kernel thread %d.\n",
+			 __func__, dev->kpid);
+
+	while (atomic_read(&dev->refcnt)) {
+		printk(KERN_INFO "Waiting for %s to become free: refcnt=%d.\n",
+				dev->name, atomic_read(&dev->refcnt));
+
+		if (msleep_interruptible(1000))
+			flush_signals(current);
+	}
+
+	msg.id.mst.id = dev->id;
+	msg.id.mst.pid = dev->kpid;
+	msg.type = W1_MASTER_REMOVE;
+	w1_netlink_send(dev, &msg);
+
+	w1_free_dev(dev);
+}
+
+void w1_remove_master_device(struct w1_bus_master *bm)
+{
+	struct w1_master *dev = NULL;
+	struct list_head *ent, *n;
+
+	list_for_each_safe(ent, n, &w1_masters) {
+		dev = list_entry(ent, struct w1_master, w1_master_entry);
+		if (!dev->initialized)
+			continue;
+
+		if (dev->bus_master->data == bm->data)
+			break;
+	}
+
+	if (!dev) {
+		printk(KERN_ERR "Device doesn't exist.\n");
+		return;
+	}
+
+	__w1_remove_master_device(dev);
+}
+
+EXPORT_SYMBOL(w1_add_master_device);
+EXPORT_SYMBOL(w1_remove_master_device);
